Subject:  v17i061:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Patch1t/31
Newsgroups: comp.sources.games
Approved: billr@saab.CNA.TEK.COM

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 17, Issue 61
Archive-name: nethack31/Patch1t
Patch-To: nethack31: Volume 16, Issue 1-116
Environment: Amiga, Atari, Mac, MS-DOS, Windows-NT, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 20 (of 31)."
# Contents:  sys/share/lev_yacc.c1 sys/winnt/Makefile.utl
# Wrapped by billr@saab on Fri Mar  5 10:50:46 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'sys/share/lev_yacc.c1' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'sys/share/lev_yacc.c1'\" to \"'sys/share/lev_yacc.c1.orig'\"
  mv -f 'sys/share/lev_yacc.c1' 'sys/share/lev_yacc.c1.orig'
fi
echo shar: Extracting \"'sys/share/lev_yacc.c1'\" \(46649 characters\)
sed "s/^X//" >'sys/share/lev_yacc.c1' <<'END_OF_FILE'
Xextern char *malloc(), *realloc();
X
X# line 2 "lev_comp.y"
X/*	SCCS Id: @(#)lev_comp.c	3.1	93/02/13	*/
X/*	Copyright (c) 1989 by Jean-Christophe Collet */
X/* NetHack may be freely redistributed.  See license for details. */
X
X/*
X * This file contains the Level Compiler code
X * It may handle special mazes & special room-levels
X */
X
X/* In case we're using bison in AIX.  This definition must be
X * placed before any other C-language construct in the file
X * excluding comments and preprocessor directives (thanks IBM
X * for this wonderful feature...).
X *
X * Note: some cpps barf on this 'undefined control' (#pragma).
X * Addition of the leading space seems to prevent barfage for now,
X * and AIX will still see the directive in its non-standard locale.
X */
X
X#ifdef _AIX
X #pragma alloca		/* keep leading space! */
X#endif
X
X#include "hack.h"
X#include "sp_lev.h"
X#ifndef O_WRONLY
X# include <fcntl.h>
X#endif
X#ifndef O_CREAT	/* some older BSD systems do not define O_CREAT in <fcntl.h> */
X# include <sys/file.h>
X#endif
X#ifndef O_BINARY	/* used for micros, no-op for others */
X# define O_BINARY 0
X#endif
X
X#ifdef MICRO
X# define OMASK FCMASK
X#else
X# define OMASK 0644
X#endif
X
X#define MAX_REGISTERS	10
X#define ERR		(-1)
X
X#define New(type)		(type *) alloc(sizeof(type))
X#define NewTab(type, size)	(type **) alloc(sizeof(type *) * size)
X
X#ifdef MICRO
X# undef exit
Xextern void FDECL(exit, (int));
X#endif
X
Xextern void FDECL(yyerror, (char *));
Xextern void FDECL(yywarning, (char *));
Xextern int NDECL(yylex);
Xint NDECL(yyparse);
X
Xextern char *FDECL(dup_string,(char *));
Xextern int FDECL(get_floor_type, (CHAR_P));
Xextern int FDECL(get_room_type, (char *));
Xextern int FDECL(get_trap_type, (char *));
Xextern int FDECL(get_monster_id, (char *, CHAR_P));
Xextern int FDECL(get_object_id, (char *));
Xextern boolean FDECL(check_monster_char, (CHAR_P));
Xextern boolean FDECL(check_object_char, (CHAR_P));
Xextern char FDECL(what_map_char, (CHAR_P));
Xextern void FDECL(scan_map, (char *));
Xextern void NDECL(wallify_map);
Xextern boolean NDECL(check_subrooms);
Xextern void FDECL(check_coord, (int, int, char *));
Xextern void NDECL(store_part);
Xextern void NDECL(store_room);
Xextern void FDECL(write_maze, (int, specialmaze *));
Xextern void FDECL(write_lev, (int, splev *));
Xextern void FDECL(free_rooms, (room **, int));
X
Xstatic struct reg {
X	int x1, y1;
X	int x2, y2;
X}		current_region;
X
Xstatic struct coord {
X	int x;
X	int y;
X}		current_coord, current_align;
X
Xstatic struct size {
X	int height;
X	int width;
X}		current_size;
X
Xchar tmpmessage[256];
Xaltar *tmpaltar[256];
Xlad *tmplad[256];
Xstair *tmpstair[256];
Xdigpos *tmpdig[256];
Xdigpos *tmppass[32];
Xchar *tmpmap[ROWNO];
Xregion *tmpreg[256];
Xlev_region *tmplreg[32];
Xdoor *tmpdoor[256];
Xroom_door *tmprdoor[256];
Xtrap *tmptrap[256];
Xmonster *tmpmonst[256];
Xobject *tmpobj[256];
Xdrawbridge *tmpdb[256];
Xwalk *tmpwalk[256];
Xgold *tmpgold[256];
Xfountain *tmpfountain[256];
Xsink *tmpsink[256];
Xpool *tmppool[256];
Xengraving *tmpengraving[256];
Xmazepart *tmppart[10];
Xroom *tmproom[MAXNROFROOMS*2];
Xcorridor *tmpcor[256];
X
Xstatic specialmaze maze;
Xstatic splev special_lev;
Xstatic lev_init init_lev;
X
Xstatic char olist[MAX_REGISTERS], mlist[MAX_REGISTERS];
Xstatic struct coord plist[MAX_REGISTERS];
X
Xint n_olist = 0, n_mlist = 0, n_plist = 0;
X
Xunsigned int nlreg = 0, nreg = 0, ndoor = 0, ntrap = 0, nmons = 0, nobj = 0;
Xunsigned int ndb = 0, nwalk = 0, npart = 0, ndig = 0, nlad = 0, nstair = 0;
Xunsigned int naltar = 0, ncorridor = 0, nrooms = 0, ngold = 0, nengraving = 0;
Xunsigned int nfountain = 0, npool = 0, nsink = 0, npass = 0;
X
Xstatic unsigned long lev_flags = 0;
X
Xunsigned int max_x_map, max_y_map;
X
Xstatic xchar in_room;
X
Xextern int fatal_error;
Xextern int want_warnings;
Xextern char* fname;
X
X
X# line 144 "lev_comp.y"
Xtypedef union 
X{
X	int	i;
X	char*	map;
X	struct {
X		xchar room;
X		xchar wall;
X		xchar door;
X	} corpos;
X} YYSTYPE;
X# define CHAR 257
X# define INTEGER 258
X# define BOOLEAN 259
X# define MESSAGE_ID 260
X# define MAZE_ID 261
X# define LEVEL_ID 262
X# define LEV_INIT_ID 263
X# define GEOMETRY_ID 264
X# define NOMAP_ID 265
X# define OBJECT_ID 266
X# define MONSTER_ID 267
X# define TRAP_ID 268
X# define DOOR_ID 269
X# define DRAWBRIDGE_ID 270
X# define MAZEWALK_ID 271
X# define WALLIFY_ID 272
X# define REGION_ID 273
X# define FILLING 274
X# define RANDOM_OBJECTS_ID 275
X# define RANDOM_MONSTERS_ID 276
X# define RANDOM_PLACES_ID 277
X# define ALTAR_ID 278
X# define LADDER_ID 279
X# define STAIR_ID 280
X# define NON_DIGGABLE_ID 281
X# define NON_PASSWALL_ID 282
X# define ROOM_ID 283
X# define PORTAL_ID 284
X# define TELEPRT_ID 285
X# define BRANCH_ID 286
X# define LEV 287
X# define CHANCE_ID 288
X# define CORRIDOR_ID 289
X# define GOLD_ID 290
X# define ENGRAVING_ID 291
X# define FOUNTAIN_ID 292
X# define POOL_ID 293
X# define SINK_ID 294
X# define NONE 295
X# define RAND_CORRIDOR_ID 296
X# define DOOR_STATE 297
X# define LIGHT_STATE 298
X# define CURSE_TYPE 299
X# define ENGRAVING_TYPE 300
X# define DIRECTION 301
X# define RANDOM_TYPE 302
X# define O_REGISTER 303
X# define M_REGISTER 304
X# define P_REGISTER 305
X# define A_REGISTER 306
X# define ALIGNMENT 307
X# define LEFT_OR_RIGHT 308
X# define CENTER 309
X# define TOP_OR_BOT 310
X# define ALTAR_TYPE 311
X# define UP_OR_DOWN 312
X# define SUBROOM_ID 313
X# define NAME_ID 314
X# define FLAGS_ID 315
X# define FLAG_TYPE 316
X# define MON_ATTITUDE 317
X# define MON_ALERTNESS 318
X# define MON_APPEARANCE 319
X# define STRING 320
X# define MAP_ID 321
X#define yyclearin yychar = -1
X#define yyerrok yyerrflag = 0
Xextern int yychar;
Xextern int yyerrflag;
X#ifndef YYMAXDEPTH
X#define YYMAXDEPTH 150
X#endif
XYYSTYPE yylval, yyval;
X# define YYERRCODE 256
X
X# line 1542 "lev_comp.y"
X
Xint yyexca[] ={
X-1, 1,
X	0, -1,
X	-2, 0,
X-1, 179,
X	44, 98,
X	-2, 97,
X	};
X# define YYNPROD 214
X# define YYLAST 487
Xint yyact[]={
X
X   156,   451,   308,   432,   183,   380,    67,   398,   221,   155,
X   208,   253,   459,   311,    47,    20,    22,   312,   309,    21,
X   104,   103,   106,   151,    49,   157,    28,    12,   438,   439,
X   441,    21,   113,   428,   154,   293,   427,   458,   289,   213,
X    60,   414,   150,    21,   118,   119,   114,   153,   152,   222,
X    55,    56,   389,    21,   425,   368,    21,    21,    60,   314,
X   301,   185,   184,   225,   367,   181,    68,    69,   149,   311,
X    61,   452,   134,   312,   309,   131,   381,   377,   399,   234,
X   104,   103,   106,   105,   107,   115,   116,   108,    61,   396,
X   249,   158,   113,   117,   109,   120,   121,   330,   110,   111,
X   112,   374,   375,   209,   118,   119,   114,   254,   210,   327,
X   317,   255,   318,    43,   128,   453,   220,   200,   351,   202,
X   205,   207,   400,   235,   313,   297,   411,   242,    74,    36,
X    34,   215,   397,   250,   178,    64,    66,    65,    17,     8,
X     9,    25,   447,   444,   243,   281,   186,   446,   436,   430,
X   413,   407,   406,   404,   388,   369,   363,   356,    44,   354,
X   342,   339,   320,   212,   303,   298,   294,   290,   283,   270,
X   266,   247,   214,   240,   134,   131,    70,    39,   229,   230,
X   231,   232,   132,   236,   130,   129,   133,   394,   337,   335,
X   333,   246,   347,   223,   264,   195,   260,   258,   148,   147,
X   146,   143,   251,   252,   142,   141,   140,   194,   193,   256,
X   139,   192,    78,   191,   190,   187,   226,   227,   228,   176,
X   175,   174,   173,   172,   171,   170,   169,   168,   167,   166,
X   165,   164,   163,   162,   161,   160,   159,   124,   123,   122,
X    81,    80,    76,    75,    48,    38,    26,    18,    15,    14,
X   349,    54,   456,   361,   443,   180,   442,   433,   288,   431,
X   292,    98,   100,    99,    94,   429,   424,    93,    86,    84,
X   295,   296,    79,    83,   421,   418,   412,   299,   410,   405,
X   402,   401,   393,   390,   387,   383,   315,   379,   372,   371,
X   364,   362,   361,   355,   353,   325,   352,   348,   346,   341,
X   338,   336,   334,   332,   324,   321,   307,   182,   177,    77,
X   224,   306,   305,   304,   302,   300,   286,   285,   284,   282,
X   280,   279,   278,   277,   276,   217,   275,   217,   218,   274,
X   218,   267,   265,   350,   263,   262,   261,   259,   382,   378,
X   257,   357,   241,   358,   197,   204,   199,   359,   360,   370,
X   196,   189,   340,   188,   126,   343,   344,   345,   219,   331,
X   125,    50,   323,   224,    40,   391,    30,   455,   449,   237,
X   238,   328,   245,   448,   244,   445,   422,   419,   415,   349,
X    27,   181,   269,   243,   403,   220,    31,    23,    16,    11,
X     2,   216,   273,   392,    10,   365,   272,    13,   271,   268,
X   409,   385,    19,   423,   408,   384,   420,    29,   417,   416,
X   322,   180,    37,   102,   319,   101,    97,    96,    95,    45,
X    92,    51,    91,   434,   435,   437,    90,   440,    89,    88,
X    87,    85,    82,   239,   179,    63,    35,    62,    46,    33,
X    32,   145,   450,   144,   138,   454,   137,   136,   135,   376,
X   326,   329,    59,    58,   127,    73,    72,    57,    53,    24,
X    71,    52,    41,     5,     4,     3,     1,   457,   291,   287,
X     7,     6,   206,   203,   201,   198,   386,   316,   233,   426,
X   248,   395,   373,    42,   310,   366,   211 };
Xint yypact[]={
X
X  -122, -1000, -1000,  -122, -1000, -1000,  -288,  -288,   191,   190,
X -1000,  -125,   189,  -125,  -301,  -301,  -119,   188,  -290,  -119,
X   322, -1000, -1000,  -135,  -119,   187,   -80, -1000,   320, -1000,
X  -144, -1000,  -135, -1000, -1000,  -307,   186, -1000,  -296,   317,
X  -290,  -225, -1000, -1000, -1000, -1000,  -140, -1000,  -242, -1000,
X   -81, -1000,  -168, -1000, -1000,   185,   184,  -243, -1000, -1000,
X   183,   182,  -186, -1000,   181,   180,   179,   316, -1000, -1000,
X   310, -1000, -1000,  -175, -1000,   -82,   -83, -1000,  -246,  -246,
X  -277,  -277, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
X -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
X -1000, -1000, -1000,   178,   177,   176,   175,   174,   173,   172,
X   171,   170,   169,   168,   167,   166, -1000,   165,   164,   163,
X   162,   161,   -82,   341,   -83,  -248,  -113, -1000,   157, -1000,
X   309, -1000, -1000,   307, -1000, -1000, -1000, -1000, -1000, -1000,
X -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000,   156,
X   155,   153,   150,   149,   137,   306, -1000, -1000,   300,  -185,
X  -182,  -194,  -263,    25,   345,    23,    76,    76,    76,    25,
X    25,    25,    25,  -179,    25,   345,   345, -1000, -1000, -1000,
X -1000,   -85, -1000, -1000, -1000, -1000,   298,   343,   -82,   -83,
X  -301,   -87,  -169,    25,    25,    25,  -191,  -191,   296, -1000,
X -1000, -1000,   106,   293, -1000, -1000, -1000,   105,   292, -1000,
X -1000,   291, -1000, -1000,   290, -1000, -1000, -1000,   103,   288,
X   -88,   287, -1000, -1000,   342,   -89, -1000, -1000, -1000,   285,
X -1000,   282,   280,   279, -1000, -1000,   278, -1000, -1000,   277,
X   276,  -114,   275,   -90, -1000, -1000, -1000, -1000,   274, -1000,
X -1000, -1000, -1000,   273, -1000, -1000,   272,  -264,   -91,  -267,
X   -92,    25,    25,  -176,   -93,  -191,   271,  -252,   270,   -94,
X   269,   268,   267,   262,  -233,  -177,  -253,    25,  -190,   341,
X   -96,   261,   104,   260,  -194,    69,    57,   259, -1000, -1000,
X    97,   258, -1000, -1000,    96, -1000, -1000,   257,    95,   256,
X   -97, -1000,    76,   255,   -98,    76,    76,    76,   254, -1000,
X -1000, -1000,   101, -1000, -1000, -1000,   253, -1000, -1000, -1000,
X   338,  -191, -1000, -1000,  -183,   252,   250,   -99, -1000,   249,
X  -101, -1000,    25, -1000,    25, -1000,  -194, -1000,  -277,   248,
X   247,  -102,   209,   246, -1000, -1000,  -247,  -103,  -301, -1000,
X   245,   244,  -200,    37,   243,    36,   241, -1000, -1000, -1000,
X   240,  -104,  -260,   239,  -301,   238, -1000, -1000, -1000,    94,
X -1000,  -170,  -180,   237, -1000, -1000,   236,  -242, -1000,  -105,
X   235,  -106, -1000,  -107, -1000,   234, -1000,  -148,   232, -1000,
X  -108, -1000, -1000,  -271, -1000, -1000, -1000, -1000,   337, -1000,
X -1000,  -180,    36,   231,   336,  -301,   230,   335,   222, -1000,
X  -266,   221,  -109,   215, -1000, -1000, -1000,   213,  -248, -1000,
X   213,  -110, -1000, -1000,  -289,   212,   210, -1000, -1000,  -116,
X   334,  -111, -1000,  -117,   332, -1000,   327, -1000, -1000, -1000,
X -1000,  -301,  -187,  -187, -1000, -1000,   326, -1000, -1000, -1000,
X -1000, -1000, -1000, -1000,   208, -1000,  -283, -1000, -1000, -1000 };
Xint yypgo[]={
X
X     0,     6,     4,   486,     9,    10,    11,     2,   485,   484,
X     3,   483,     7,   482,   481,   480,   479,     1,   478,   477,
X   389,   380,   476,    49,   388,   186,   475,   474,   184,   473,
X   472,     0,   471,   470,   469,   468,   467,   127,   466,   390,
X   465,   464,   463,   387,   386,   462,   461,   460,   459,   458,
X   185,   182,   251,   457,   456,   455,   454,   453,   212,   452,
X   451,     5,   450,   449,   448,   447,   446,   444,   210,   206,
X   205,   204,   201,   443,   441,   200,   199,   198,   440,   439,
X   438,   437,   436,   435,   134,   434,   433,   432,   431,   430,
X   429,   428,   426,   422,   420,   418,   417,   416,   415,   413,
X     8,   405,   404,   403,   401,   400,   399,   398,   396,   395,
X   393,   392,   193,   131,   391 };
Xint yyr1[]={
X
X     0,    38,    38,    39,    39,    40,    40,    41,    42,    33,
X    24,    24,    14,    14,    20,    20,    21,    21,    43,    43,
X    48,    45,    45,    49,    49,    46,    46,    52,    52,    47,
X    47,    54,    55,    55,    56,    56,    37,    53,    53,    59,
X    57,    10,    10,    62,    62,    60,    60,    63,    63,    61,
X    61,    58,    58,    64,    64,    64,    64,    64,    64,    64,
X    64,    64,    64,    64,    64,    64,    65,    66,    67,    15,
X    15,    13,    13,    12,    12,    32,    11,    11,    44,    44,
X    78,    79,    79,    82,     1,     1,     2,     2,    80,    80,
X    83,    83,    83,    50,    50,    51,    51,    84,    86,    84,
X    81,    81,    87,    87,    87,    87,    87,    87,    87,    87,
X    87,    87,    87,    87,    87,    87,    87,    87,    87,    87,
X    87,    87,   101,    68,   102,   102,   103,   103,   103,   103,
X   103,   104,    69,   105,   105,   105,    16,    16,    17,    17,
X    88,    70,    89,    95,    96,    97,    77,   106,    91,   107,
X    92,   108,   109,    93,   111,    94,   110,   110,    23,    23,
X    72,    73,    74,    98,    99,    90,    71,    75,    76,    26,
X    26,    26,    29,    29,    29,    34,    34,    35,    35,     3,
X     3,     4,     4,    22,    22,    22,   100,   100,   100,     5,
X     5,     6,     6,     7,     7,     7,     8,     8,   114,    30,
X    27,     9,    85,    25,    28,    31,    36,    36,    18,    18,
X    19,    19,   113,   112 };
Xint yyr2[]={
X
X     0,     0,     2,     2,     4,     2,     2,    11,    15,     7,
X     1,    27,     2,     2,     1,     7,     7,     3,     0,     4,
X     7,     0,     4,     7,     7,     1,     2,     2,     4,     2,
X     2,     3,     0,     4,    11,    11,    15,     5,     5,    25,
X    25,     1,     5,    11,     3,    11,     3,    11,     3,    11,
X     3,     0,     4,     2,     2,     2,     2,     2,     2,     2,
X     2,     2,     2,     2,     2,     2,     7,     7,    19,     2,
X     2,     2,     2,     2,     2,    11,     3,     3,     2,     4,
X     7,     3,     5,    11,     2,     2,     2,     2,     0,     4,
X     7,     7,     7,     3,     7,     3,     7,     3,     1,     8,
X     0,     4,     2,     2,     2,     2,     2,     2,     2,     2,
X     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
X     2,     2,     1,    19,     0,     4,     5,     5,     5,     5,
X     7,     1,    19,     1,     9,    13,     2,     2,     2,     3,
X    11,    11,    15,    11,     3,    11,    11,     1,    17,     1,
X    17,     1,     1,    17,     1,    13,     1,     5,     3,    21,
X     7,     7,     7,     7,     7,    17,    15,    11,    15,     2,
X     3,     2,     2,     3,     2,     2,     3,     2,     3,     3,
X     2,     3,     2,     1,     5,     9,     2,     2,     3,     2,
X     2,     2,     2,     2,     2,     3,     2,     2,     9,     9,
X     9,     9,     2,     3,     3,     2,     2,     3,     2,     2,
X     2,     2,    11,    19 };
Xint yychk[]={
X
X -1000,   -38,   -39,   -40,   -41,   -42,   -32,   -33,   261,   262,
X   -39,   -20,   315,   -20,    58,    58,   -24,   263,    58,   -24,
X   -31,   320,   -31,   -43,   -48,   260,    58,   -21,   316,   -43,
X    44,   -44,   -78,   -79,   265,   -82,   264,   -43,    58,   257,
X    44,   -45,   -11,   257,   302,   -44,   -80,   321,    58,   320,
X    44,   -21,   -46,   -49,   -52,   275,   276,   -53,   -57,   -59,
X   283,   313,   -81,   -83,   275,   277,   276,    -1,   308,   309,
X   257,   -47,   -54,   -55,   296,    58,    58,   -52,   -58,   -58,
X    58,    58,   -87,   -68,   -69,   -88,   -70,   -89,   -90,   -91,
X   -92,   -93,   -94,   -71,   -72,   -95,   -96,   -97,   -77,   -75,
X   -76,   -98,   -99,   267,   266,   269,   268,   270,   273,   280,
X   284,   285,   286,   278,   292,   271,   272,   279,   290,   291,
X   281,   282,    58,    58,    58,    44,    44,   -56,   289,   -50,
X   -28,   257,   -51,   -25,   257,   -64,   -65,   -66,   -67,   -68,
X   -69,   -70,   -71,   -72,   -73,   -74,   -75,   -76,   -77,   314,
X   288,   269,   294,   293,   280,    -4,   -31,   302,    -4,    58,
X    58,    58,    58,    58,    58,    58,    58,    58,    58,    58,
X    58,    58,    58,    58,    58,    58,    58,   -50,   -84,   -85,
X  -113,    40,   -51,    -2,   310,   309,   259,    58,    44,    44,
X    58,    58,    58,    58,    58,    58,    44,    44,   -26,   -25,
X   302,   -27,   304,   -29,   -28,   302,   -30,   303,    -5,   297,
X   302,    -3,   -31,   302,  -100,  -113,  -114,   302,   305,  -112,
X    40,  -100,   -23,  -112,   287,    40,   -23,   -23,   -23,  -100,
X  -100,  -100,  -100,   -18,   258,   302,  -100,  -112,  -112,   -86,
X   258,    44,   -37,    40,   -50,   -51,   -31,   258,   -15,   259,
X   302,  -100,  -100,    -6,   298,   302,    -6,    44,    91,    44,
X    91,    44,    44,    44,    91,    44,   258,    44,  -106,    40,
X   258,  -107,  -108,  -111,    44,    44,    44,    44,    44,    44,
X    44,   259,    44,   258,    44,    44,    44,   -34,   -31,   302,
X   258,   -35,   -31,   302,   258,  -100,  -100,   301,   258,    -6,
X    44,   312,    44,   258,    44,    44,    44,    44,    -7,   307,
X    -9,   302,   306,   301,   312,  -100,   -19,   300,   302,   -84,
X   258,    44,   -37,   258,    44,    -5,   -62,    40,   302,   -60,
X    40,   302,    44,    93,    44,    93,    44,    93,    44,   258,
X   -23,    44,   258,   -23,   -23,   -23,    44,    91,    44,    41,
X    -6,   301,    44,    44,   258,    44,   258,  -100,  -100,    -5,
X    -4,    44,    44,   258,    44,  -109,    -8,   311,   302,   258,
X   -31,    44,    44,   -13,   301,   302,   -63,    40,   302,    44,
X   -61,    40,   302,    44,  -101,  -104,   -22,    44,   258,   312,
X    44,   -31,  -110,    44,    93,   -14,   259,   302,   -12,   258,
X   302,    44,    44,    -1,   258,    44,   258,   258,  -102,  -105,
X    44,   274,    44,   258,   312,    41,   -12,   -61,    44,    41,
X   -31,    44,    41,  -103,    44,   320,   -16,   302,   299,    44,
X   258,    44,   -10,    44,    -2,   -10,   258,   -31,   317,   318,
X    -7,   319,    44,    44,   259,    41,   258,   259,    41,    41,
X   -31,   -17,   258,   302,   -17,    41,    44,   -36,   320,   295 };
Xint yydef[]={
X
X     1,    -2,     2,     3,     5,     6,    14,    14,     0,     0,
X     4,    10,     0,    10,     0,     0,    18,     0,     0,    18,
X     0,   205,     9,     0,    18,     0,     0,    15,    17,    21,
X     0,     7,    78,    88,    81,     0,     0,    19,     0,     0,
X     0,    25,    75,    76,    77,    79,   100,    82,     0,    20,
X     0,    16,    32,    22,    26,     0,     0,    27,    51,    51,
X     0,     0,    80,    89,     0,     0,     0,     0,    84,    85,
X     0,     8,    29,    30,    31,     0,     0,    28,    37,    38,
X     0,     0,   101,   102,   103,   104,   105,   106,   107,   108,
X   109,   110,   111,   112,   113,   114,   115,   116,   117,   118,
X   119,   120,   121,     0,     0,     0,     0,     0,     0,     0,
X     0,     0,     0,     0,     0,     0,   144,     0,     0,     0,
X     0,     0,     0,     0,     0,     0,     0,    33,     0,    23,
X    93,   204,    24,    95,   203,    52,    53,    54,    55,    56,
X    57,    58,    59,    60,    61,    62,    63,    64,    65,     0,
X     0,     0,     0,     0,     0,     0,   181,   182,     0,     0,
X     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
X     0,     0,     0,     0,     0,     0,     0,    90,    91,    -2,
X   202,     0,    92,    83,    86,    87,     0,     0,     0,     0,
X     0,     0,     0,     0,     0,     0,     0,     0,     0,   169,
X   170,   171,     0,     0,   172,   173,   174,     0,     0,   189,
X   190,     0,   179,   180,     0,   186,   187,   188,     0,     0,
X     0,     0,   147,   158,     0,     0,   149,   151,   154,     0,
X   160,     0,     0,     0,   208,   209,     0,   163,   164,     0,
X     0,     0,     0,     0,    94,    96,    66,    67,     0,    69,
X    70,   161,   162,     0,   191,   192,     0,     0,     0,     0,
X     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
X     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
X     0,     0,     0,     0,     0,     0,     0,     0,   175,   176,
X     0,     0,   177,   178,     0,   140,   141,     0,     0,     0,
X     0,   146,     0,     0,     0,     0,     0,     0,     0,   193,
X   194,   195,     0,   143,   145,   167,     0,   210,   211,    99,
X     0,     0,    34,    35,     0,     0,     0,     0,    44,     0,
X     0,    46,     0,   200,     0,   199,     0,   198,     0,     0,
X     0,     0,     0,     0,   152,   155,     0,     0,     0,   212,
X     0,     0,     0,     0,     0,     0,     0,   122,   131,   142,
X   183,     0,     0,     0,     0,   156,   166,   196,   197,     0,
X   168,     0,     0,     0,    71,    72,     0,     0,    48,     0,
X     0,     0,    50,     0,   124,   133,   165,     0,     0,   148,
X     0,   150,   153,     0,   201,    11,    12,    13,     0,    73,
X    74,     0,     0,     0,     0,     0,     0,     0,   123,   132,
X     0,   184,     0,     0,   157,    36,    68,    41,     0,    43,
X    41,     0,    45,   125,     0,     0,     0,   136,   137,     0,
X     0,     0,    40,     0,     0,    39,     0,   126,   127,   128,
X   129,     0,     0,     0,   185,   213,     0,    42,    47,    49,
X   130,   134,   138,   139,     0,   159,     0,   135,   206,   207 };
Xtypedef struct { char *t_name; int t_val; } yytoktype;
X#ifndef YYDEBUG
X#	define YYDEBUG	0	/* don't allow debugging */
X#endif
X
X#if YYDEBUG
X
Xyytoktype yytoks[] =
X{
X	"CHAR",	257,
X	"INTEGER",	258,
X	"BOOLEAN",	259,
X	"MESSAGE_ID",	260,
X	"MAZE_ID",	261,
X	"LEVEL_ID",	262,
X	"LEV_INIT_ID",	263,
X	"GEOMETRY_ID",	264,
X	"NOMAP_ID",	265,
X	"OBJECT_ID",	266,
X	"MONSTER_ID",	267,
X	"TRAP_ID",	268,
X	"DOOR_ID",	269,
X	"DRAWBRIDGE_ID",	270,
X	"MAZEWALK_ID",	271,
X	"WALLIFY_ID",	272,
X	"REGION_ID",	273,
X	"FILLING",	274,
X	"RANDOM_OBJECTS_ID",	275,
X	"RANDOM_MONSTERS_ID",	276,
X	"RANDOM_PLACES_ID",	277,
X	"ALTAR_ID",	278,
X	"LADDER_ID",	279,
X	"STAIR_ID",	280,
X	"NON_DIGGABLE_ID",	281,
X	"NON_PASSWALL_ID",	282,
X	"ROOM_ID",	283,
X	"PORTAL_ID",	284,
X	"TELEPRT_ID",	285,
X	"BRANCH_ID",	286,
X	"LEV",	287,
X	"CHANCE_ID",	288,
X	"CORRIDOR_ID",	289,
X	"GOLD_ID",	290,
X	"ENGRAVING_ID",	291,
X	"FOUNTAIN_ID",	292,
X	"POOL_ID",	293,
X	"SINK_ID",	294,
X	"NONE",	295,
X	"RAND_CORRIDOR_ID",	296,
X	"DOOR_STATE",	297,
X	"LIGHT_STATE",	298,
X	"CURSE_TYPE",	299,
X	"ENGRAVING_TYPE",	300,
X	"DIRECTION",	301,
X	"RANDOM_TYPE",	302,
X	"O_REGISTER",	303,
X	"M_REGISTER",	304,
X	"P_REGISTER",	305,
X	"A_REGISTER",	306,
X	"ALIGNMENT",	307,
X	"LEFT_OR_RIGHT",	308,
X	"CENTER",	309,
X	"TOP_OR_BOT",	310,
X	"ALTAR_TYPE",	311,
X	"UP_OR_DOWN",	312,
X	"SUBROOM_ID",	313,
X	"NAME_ID",	314,
X	"FLAGS_ID",	315,
X	"FLAG_TYPE",	316,
X	"MON_ATTITUDE",	317,
X	"MON_ALERTNESS",	318,
X	"MON_APPEARANCE",	319,
X	",",	44,
X	":",	58,
X	"(",	40,
X	")",	41,
X	"[",	91,
X	"]",	93,
X	"STRING",	320,
X	"MAP_ID",	321,
X	"-unknown-",	-1	/* ends search */
X};
X
Xchar * yyreds[] =
X{
X	"-no such reduction-",
X	"file : /* empty */",
X	"file : levels",
X	"levels : level",
X	"levels : level levels",
X	"level : maze_level",
X	"level : room_level",
X	"maze_level : maze_def flags lev_init messages regions",
X	"room_level : level_def flags lev_init messages rreg_init rooms corridors_def",
X	"level_def : LEVEL_ID ':' string",
X	"lev_init : /* empty */",
X	"lev_init : LEV_INIT_ID ':' CHAR ',' CHAR ',' BOOLEAN ',' BOOLEAN ',' light_state ',' walled",
X	"walled : BOOLEAN",
X	"walled : RANDOM_TYPE",
X	"flags : /* empty */",
X	"flags : FLAGS_ID ':' flag_list",
X	"flag_list : FLAG_TYPE ',' flag_list",
X	"flag_list : FLAG_TYPE",
X	"messages : /* empty */",
X	"messages : message messages",
X	"message : MESSAGE_ID ':' STRING",
X	"rreg_init : /* empty */",
X	"rreg_init : rreg_init init_rreg",
X	"init_rreg : RANDOM_OBJECTS_ID ':' object_list",
X	"init_rreg : RANDOM_MONSTERS_ID ':' monster_list",
X	"rooms : /* empty */",
X	"rooms : roomlist",
X	"roomlist : aroom",
X	"roomlist : aroom roomlist",
X	"corridors_def : random_corridors",
X	"corridors_def : corridors",
X	"random_corridors : RAND_CORRIDOR_ID",
X	"corridors : /* empty */",
X	"corridors : corridors corridor",
X	"corridor : CORRIDOR_ID ':' corr_spec ',' corr_spec",
X	"corridor : CORRIDOR_ID ':' corr_spec ',' INTEGER",
X	"corr_spec : '(' INTEGER ',' DIRECTION ',' door_pos ')'",
X	"aroom : room_def room_details",
X	"aroom : subroom_def room_details",
X	"subroom_def : SUBROOM_ID ':' room_type ',' light_state ',' subroom_pos ',' room_size ',' string roomfill",
X	"room_def : ROOM_ID ':' room_type ',' light_state ',' room_pos ',' room_align ',' room_size roomfill",
X	"roomfill : /* empty */",
X	"roomfill : ',' BOOLEAN",
X	"room_pos : '(' INTEGER ',' INTEGER ')'",
X	"room_pos : RANDOM_TYPE",
X	"subroom_pos : '(' INTEGER ',' INTEGER ')'",
X	"subroom_pos : RANDOM_TYPE",
X	"room_align : '(' h_justif ',' v_justif ')'",
X	"room_align : RANDOM_TYPE",
X	"room_size : '(' INTEGER ',' INTEGER ')'",
X	"room_size : RANDOM_TYPE",
X	"room_details : /* empty */",
X	"room_details : room_details room_detail",
X	"room_detail : room_name",
X	"room_detail : room_chance",
X	"room_detail : room_door",
X	"room_detail : monster_detail",
X	"room_detail : object_detail",
X	"room_detail : trap_detail",
X	"room_detail : altar_detail",
X	"room_detail : fountain_detail",
X	"room_detail : sink_detail",
X	"room_detail : pool_detail",
X	"room_detail : gold_detail",
X	"room_detail : engraving_detail",
X	"room_detail : stair_detail",
X	"room_name : NAME_ID ':' string",
X	"room_chance : CHANCE_ID ':' INTEGER",
X	"room_door : DOOR_ID ':' secret ',' door_state ',' door_wall ',' door_pos",
X	"secret : BOOLEAN",
X	"secret : RANDOM_TYPE",
X	"door_wall : DIRECTION",
X	"door_wall : RANDOM_TYPE",
X	"door_pos : INTEGER",
X	"door_pos : RANDOM_TYPE",
X	"maze_def : MAZE_ID ':' string ',' filling",
X	"filling : CHAR",
X	"filling : RANDOM_TYPE",
X	"regions : aregion",
X	"regions : aregion regions",
X	"aregion : map_definition reg_init map_details",
X	"map_definition : NOMAP_ID",
X	"map_definition : map_geometry MAP_ID",
X	"map_geometry : GEOMETRY_ID ':' h_justif ',' v_justif",
X	"h_justif : LEFT_OR_RIGHT",
X	"h_justif : CENTER",
X	"v_justif : TOP_OR_BOT",
X	"v_justif : CENTER",
X	"reg_init : /* empty */",
X	"reg_init : reg_init init_reg",
X	"init_reg : RANDOM_OBJECTS_ID ':' object_list",
X	"init_reg : RANDOM_PLACES_ID ':' place_list",
X	"init_reg : RANDOM_MONSTERS_ID ':' monster_list",
X	"object_list : object",
X	"object_list : object ',' object_list",
X	"monster_list : monster",
X	"monster_list : monster ',' monster_list",
X	"place_list : place",
X	"place_list : place",
X	"place_list : place ',' place_list",
X	"map_details : /* empty */",
X	"map_details : map_details map_detail",
X	"map_detail : monster_detail",
X	"map_detail : object_detail",
X	"map_detail : door_detail",
X	"map_detail : trap_detail",
X	"map_detail : drawbridge_detail",
X	"map_detail : region_detail",
X	"map_detail : stair_region",
X	"map_detail : portal_region",
X	"map_detail : teleprt_region",
X	"map_detail : branch_region",
X	"map_detail : altar_detail",
X	"map_detail : fountain_detail",
X	"map_detail : mazewalk_detail",
X	"map_detail : wallify_detail",
X	"map_detail : ladder_detail",
X	"map_detail : stair_detail",
X	"map_detail : gold_detail",
X	"map_detail : engraving_detail",
X	"map_detail : diggable_detail",
X	"map_detail : passwall_detail",
X	"monster_detail : MONSTER_ID ':' monster_c ',' m_name ',' coordinate",
X	"monster_detail : MONSTER_ID ':' monster_c ',' m_name ',' coordinate monster_infos",
X	"monster_infos : /* empty */",
X	"monster_infos : monster_infos monster_info",
X	"monster_info : ',' string",
X	"monster_info : ',' MON_ATTITUDE",
X	"monster_info : ',' MON_ALERTNESS",
X	"monster_info : ',' alignment",
X	"monster_info : ',' MON_APPEARANCE string",
X	"object_detail : OBJECT_ID ':' object_c ',' o_name ',' coordinate",
X	"object_detail : OBJECT_ID ':' object_c ',' o_name ',' coordinate object_infos",
X	"object_infos : /* empty */",
X	"object_infos : ',' STRING ',' enchantment",
X	"object_infos : ',' curse_state ',' enchantment ',' art_name",
X	"curse_state : RANDOM_TYPE",
X	"curse_state : CURSE_TYPE",
X	"enchantment : INTEGER",
X	"enchantment : RANDOM_TYPE",
X	"door_detail : DOOR_ID ':' door_state ',' coordinate",
X	"trap_detail : TRAP_ID ':' trap_name ',' coordinate",
X	"drawbridge_detail : DRAWBRIDGE_ID ':' coordinate ',' DIRECTION ',' door_state",
X	"mazewalk_detail : MAZEWALK_ID ':' coordinate ',' DIRECTION",
X	"wallify_detail : WALLIFY_ID",
X	"ladder_detail : LADDER_ID ':' coordinate ',' UP_OR_DOWN",
X	"stair_detail : STAIR_ID ':' coordinate ',' UP_OR_DOWN",
X	"stair_region : STAIR_ID ':' lev_region",
X	"stair_region : STAIR_ID ':' lev_region ',' lev_region ',' UP_OR_DOWN",
X	"portal_region : PORTAL_ID ':' lev_region",
X	"portal_region : PORTAL_ID ':' lev_region ',' lev_region ',' string",
X	"teleprt_region : TELEPRT_ID ':' lev_region",
X	"teleprt_region : TELEPRT_ID ':' lev_region ',' lev_region",
X	"teleprt_region : TELEPRT_ID ':' lev_region ',' lev_region teleprt_detail",
X	"branch_region : BRANCH_ID ':' lev_region",
X	"branch_region : BRANCH_ID ':' lev_region ',' lev_region",
X	"teleprt_detail : /* empty */",
X	"teleprt_detail : ',' UP_OR_DOWN",
X	"lev_region : region",
X	"lev_region : LEV '(' INTEGER ',' INTEGER ',' INTEGER ',' INTEGER ')'",
X	"fountain_detail : FOUNTAIN_ID ':' coordinate",
X	"sink_detail : SINK_ID ':' coordinate",
X	"pool_detail : POOL_ID ':' coordinate",
X	"diggable_detail : NON_DIGGABLE_ID ':' region",
X	"passwall_detail : NON_PASSWALL_ID ':' region",
X	"region_detail : REGION_ID ':' region ',' light_state ',' room_type prefilled",
X	"altar_detail : ALTAR_ID ':' coordinate ',' alignment ',' altar_type",
X	"gold_detail : GOLD_ID ':' amount ',' coordinate",
X	"engraving_detail : ENGRAVING_ID ':' coordinate ',' engraving_type ',' string",
X	"monster_c : monster",
X	"monster_c : RANDOM_TYPE",
X	"monster_c : m_register",
X	"object_c : object",
X	"object_c : RANDOM_TYPE",
X	"object_c : o_register",
X	"m_name : string",
X	"m_name : RANDOM_TYPE",
X	"o_name : string",
X	"o_name : RANDOM_TYPE",
X	"trap_name : string",
X	"trap_name : RANDOM_TYPE",
X	"room_type : string",
X	"room_type : RANDOM_TYPE",
X	"prefilled : /* empty */",
X	"prefilled : ',' FILLING",
X	"prefilled : ',' FILLING ',' BOOLEAN",
X	"coordinate : coord",
X	"coordinate : p_register",
X	"coordinate : RANDOM_TYPE",
X	"door_state : DOOR_STATE",
X	"door_state : RANDOM_TYPE",
X	"light_state : LIGHT_STATE",
X	"light_state : RANDOM_TYPE",
X	"alignment : ALIGNMENT",
X	"alignment : a_register",
X	"alignment : RANDOM_TYPE",
X	"altar_type : ALTAR_TYPE",
X	"altar_type : RANDOM_TYPE",
X	"p_register : P_REGISTER '[' INTEGER ']'",
X	"o_register : O_REGISTER '[' INTEGER ']'",
X	"m_register : M_REGISTER '[' INTEGER ']'",
X	"a_register : A_REGISTER '[' INTEGER ']'",
X	"place : coord",
X	"monster : CHAR",
X	"object : CHAR",
X	"string : STRING",
X	"art_name : STRING",
X	"art_name : NONE",
X	"amount : INTEGER",
X	"amount : RANDOM_TYPE",
X	"engraving_type : ENGRAVING_TYPE",
X	"engraving_type : RANDOM_TYPE",
X	"coord : '(' INTEGER ',' INTEGER ')'",
X	"region : '(' INTEGER ',' INTEGER ',' INTEGER ',' INTEGER ')'",
X};
X#endif /* YYDEBUG */
X#line 1 "/usr/lib/yaccpar"
X/*	@(#)yaccpar 1.10 89/04/04 SMI; from S5R3 1.10	*/
X
X/*
X** Skeleton parser driver for yacc output
X*/
X
X/*
X** yacc user known macros and defines
X*/
X#define YYERROR		goto yyerrlab
X#define YYACCEPT	{ free(yys); free(yyv); return(0); }
X#define YYABORT		{ free(yys); free(yyv); return(1); }
X#define YYBACKUP( newtoken, newvalue )\
X{\
X	if ( yychar >= 0 || ( yyr2[ yytmp ] >> 1 ) != 1 )\
X	{\
X		yyerror( "syntax error - cannot backup" );\
X		goto yyerrlab;\
X	}\
X	yychar = newtoken;\
X	yystate = *yyps;\
X	yylval = newvalue;\
X	goto yynewstate;\
X}
X#define YYRECOVERING()	(!!yyerrflag)
X#ifndef YYDEBUG
X#	define YYDEBUG	1	/* make debugging available */
X#endif
X
X/*
X** user known globals
X*/
Xint yydebug;			/* set to 1 to get debugging */
X
X/*
X** driver internal defines
X*/
X#define YYFLAG		(-1000)
X
X/*
X** static variables used by the parser
X*/
Xstatic YYSTYPE *yyv;			/* value stack */
Xstatic int *yys;			/* state stack */
X
Xstatic YYSTYPE *yypv;			/* top of value stack */
Xstatic int *yyps;			/* top of state stack */
X
Xstatic int yystate;			/* current state */
Xstatic int yytmp;			/* extra var (lasts between blocks) */
X
Xint yynerrs;			/* number of errors */
X
Xint yyerrflag;			/* error recovery flag */
Xint yychar;			/* current input token number */
X
X
X/*
X** yyparse - return 0 if worked, 1 if syntax error not recovered from
X*/
Xint
Xyyparse()
X{
X	register YYSTYPE *yypvt;	/* top of value stack for $vars */
X	unsigned yymaxdepth = YYMAXDEPTH;
X
X	/*
X	** Initialize externals - yyparse may be called more than once
X	*/
X	yyv = (YYSTYPE*)malloc(yymaxdepth*sizeof(YYSTYPE));
X	yys = (int*)malloc(yymaxdepth*sizeof(int));
X	if (!yyv || !yys)
X	{
X		yyerror( "out of memory" );
X		return(1);
X	}
X	yypv = &yyv[-1];
X	yyps = &yys[-1];
X	yystate = 0;
X	yytmp = 0;
X	yynerrs = 0;
X	yyerrflag = 0;
X	yychar = -1;
X
X	goto yystack;
X	{
X		register YYSTYPE *yy_pv;	/* top of value stack */
X		register int *yy_ps;		/* top of state stack */
X		register int yy_state;		/* current state */
X		register int  yy_n;		/* internal state number info */
X
X		/*
X		** get globals into registers.
X		** branch to here only if YYBACKUP was called.
X		*/
X	yynewstate:
X		yy_pv = yypv;
X		yy_ps = yyps;
X		yy_state = yystate;
X		goto yy_newstate;
X
X		/*
X		** get globals into registers.
X		** either we just started, or we just finished a reduction
X		*/
X	yystack:
X		yy_pv = yypv;
X		yy_ps = yyps;
X		yy_state = yystate;
X
X		/*
X		** top of for (;;) loop while no reductions done
X		*/
X	yy_stack:
X		/*
X		** put a state and value onto the stacks
X		*/
X#if YYDEBUG
X		/*
X		** if debugging, look up token value in list of value vs.
X		** name pairs.  0 and negative (-1) are special values.
X		** Note: linear search is used since time is not a real
X		** consideration while debugging.
X		*/
X		if ( yydebug )
X		{
X			register int yy_i;
X
X			(void)printf( "State %d, token ", yy_state );
X			if ( yychar == 0 )
X				(void)printf( "end-of-file\n" );
X			else if ( yychar < 0 )
X				(void)printf( "-none-\n" );
X			else
X			{
X				for ( yy_i = 0; yytoks[yy_i].t_val >= 0;
X					yy_i++ )
X				{
X					if ( yytoks[yy_i].t_val == yychar )
X						break;
X				}
X				(void)printf( "%s\n", yytoks[yy_i].t_name );
X			}
X		}
X#endif /* YYDEBUG */
X		if ( ++yy_ps >= &yys[ yymaxdepth ] )	/* room on stack? */
X		{
X			/*
X			** reallocate and recover.  Note that pointers
X			** have to be reset, or bad things will happen
X			*/
X			int yyps_index = (yy_ps - yys);
X			int yypv_index = (yy_pv - yyv);
X			int yypvt_index = (yypvt - yyv);
X			yymaxdepth += YYMAXDEPTH;
X			yyv = (YYSTYPE*)realloc((char*)yyv,
X				yymaxdepth * sizeof(YYSTYPE));
X			yys = (int*)realloc((char*)yys,
X				yymaxdepth * sizeof(int));
X			if (!yyv || !yys)
X			{
X				yyerror( "yacc stack overflow" );
X				return(1);
X			}
X			yy_ps = yys + yyps_index;
X			yy_pv = yyv + yypv_index;
X			yypvt = yyv + yypvt_index;
X		}
X		*yy_ps = yy_state;
X		*++yy_pv = yyval;
X
X		/*
X		** we have a new state - find out what to do
X		*/
X	yy_newstate:
X		if ( ( yy_n = yypact[ yy_state ] ) <= YYFLAG )
X			goto yydefault;		/* simple state */
X#if YYDEBUG
X		/*
X		** if debugging, need to mark whether new token grabbed
X		*/
X		yytmp = yychar < 0;
X#endif
X		if ( ( yychar < 0 ) && ( ( yychar = yylex() ) < 0 ) )
X			yychar = 0;		/* reached EOF */
X#if YYDEBUG
X		if ( yydebug && yytmp )
X		{
X			register int yy_i;
X
X			(void)printf( "Received token " );
X			if ( yychar == 0 )
X				(void)printf( "end-of-file\n" );
X			else if ( yychar < 0 )
X				(void)printf( "-none-\n" );
X			else
X			{
X				for ( yy_i = 0; yytoks[yy_i].t_val >= 0;
X					yy_i++ )
X				{
X					if ( yytoks[yy_i].t_val == yychar )
X						break;
X				}
X				(void)printf( "%s\n", yytoks[yy_i].t_name );
X			}
X		}
X#endif /* YYDEBUG */
X		if ( ( ( yy_n += yychar ) < 0 ) || ( yy_n >= YYLAST ) )
X			goto yydefault;
X		if ( yychk[ yy_n = yyact[ yy_n ] ] == yychar )	/*valid shift*/
X		{
X			yychar = -1;
X			yyval = yylval;
X			yy_state = yy_n;
X			if ( yyerrflag > 0 )
X				yyerrflag--;
X			goto yy_stack;
X		}
X
X	yydefault:
X		if ( ( yy_n = yydef[ yy_state ] ) == -2 )
X		{
X#if YYDEBUG
X			yytmp = yychar < 0;
X#endif
X			if ( ( yychar < 0 ) && ( ( yychar = yylex() ) < 0 ) )
X				yychar = 0;		/* reached EOF */
X#if YYDEBUG
X			if ( yydebug && yytmp )
X			{
X				register int yy_i;
X
X				(void)printf( "Received token " );
X				if ( yychar == 0 )
X					(void)printf( "end-of-file\n" );
X				else if ( yychar < 0 )
X					(void)printf( "-none-\n" );
X				else
X				{
X					for ( yy_i = 0;
X						yytoks[yy_i].t_val >= 0;
X						yy_i++ )
X					{
X						if ( yytoks[yy_i].t_val
X							== yychar )
X						{
X							break;
X						}
X					}
X					(void)printf( "%s\n", yytoks[yy_i].t_name );
X				}
X			}
X#endif /* YYDEBUG */
X			/*
X			** look through exception table
X			*/
X			{
X				register int *yyxi = yyexca;
X
X				while ( ( *yyxi != -1 ) ||
X					( yyxi[1] != yy_state ) )
X				{
X					yyxi += 2;
X				}
X				while ( ( *(yyxi += 2) >= 0 ) &&
X					( *yyxi != yychar ) )
X					;
X				if ( ( yy_n = yyxi[1] ) < 0 )
X					YYACCEPT;
X			}
X		}
X
X		/*
X		** check for syntax error
X		*/
X		if ( yy_n == 0 )	/* have an error */
X		{
X			/* no worry about speed here! */
X			switch ( yyerrflag )
X			{
X			case 0:		/* new error */
X				yyerror( "syntax error" );
X				goto skip_init;
X			yyerrlab:
X				/*
X				** get globals into registers.
X				** we have a user generated syntax type error
X				*/
X				yy_pv = yypv;
X				yy_ps = yyps;
X				yy_state = yystate;
X				yynerrs++;
X			skip_init:
X			case 1:
X			case 2:		/* incompletely recovered error */
X					/* try again... */
X				yyerrflag = 3;
X				/*
X				** find state where "error" is a legal
X				** shift action
X				*/
X				while ( yy_ps >= yys )
X				{
X					yy_n = yypact[ *yy_ps ] + YYERRCODE;
X					if ( yy_n >= 0 && yy_n < YYLAST &&
X						yychk[yyact[yy_n]] == YYERRCODE)					{
X						/*
X						** simulate shift of "error"
X						*/
X						yy_state = yyact[ yy_n ];
X						goto yy_stack;
X					}
X					/*
X					** current state has no shift on
X					** "error", pop stack
X					*/
X#if YYDEBUG
X#	define _POP_ "Error recovery pops state %d, uncovers state %d\n"
X					if ( yydebug )
X						(void)printf( _POP_, *yy_ps,
X							yy_ps[-1] );
X#	undef _POP_
X#endif
X					yy_ps--;
X					yy_pv--;
X				}
X				/*
X				** there is no state on stack with "error" as
X				** a valid shift.  give up.
X				*/
X				YYABORT;
X			case 3:		/* no shift yet; eat a token */
X#if YYDEBUG
X				/*
X				** if debugging, look up token in list of
X				** pairs.  0 and negative shouldn't occur,
X				** but since timing doesn't matter when
X				** debugging, it doesn't hurt to leave the
X				** tests here.
X				*/
X				if ( yydebug )
X				{
X					register int yy_i;
X
X					(void)printf( "Error recovery discards " );
X					if ( yychar == 0 )
X						(void)printf( "token end-of-file\n" );
X					else if ( yychar < 0 )
X						(void)printf( "token -none-\n" );
X					else
X					{
X						for ( yy_i = 0;
X							yytoks[yy_i].t_val >= 0;
X							yy_i++ )
X						{
X							if ( yytoks[yy_i].t_val
X								== yychar )
X							{
X								break;
X							}
X						}
X						(void)printf( "token %s\n",
X							yytoks[yy_i].t_name );
X					}
X				}
X#endif /* YYDEBUG */
X				if ( yychar == 0 )	/* reached EOF. quit */
X					YYABORT;
X				yychar = -1;
X				goto yy_newstate;
X			}
X		}/* end if ( yy_n == 0 ) */
X		/*
X		** reduction by production yy_n
X		** put stack tops, etc. so things right after switch
X		*/
X#if YYDEBUG
X		/*
X		** if debugging, print the string that is the user's
X		** specification of the reduction which is just about
X		** to be done.
X		*/
X		if ( yydebug )
X			(void)printf( "Reduce by (%d) \"%s\"\n",
X				yy_n, yyreds[ yy_n ] );
X#endif
X		yytmp = yy_n;			/* value to switch over */
X		yypvt = yy_pv;			/* $vars top of value stack */
X		/*
X		** Look in goto table for next state
X		** Sorry about using yy_state here as temporary
X		** register variable, but why not, if it works...
X		** If yyr2[ yy_n ] doesn't have the low order bit
X		** set, then there is no action to be done for
X		** this reduction.  So, no saving & unsaving of
X		** registers done.  The only difference between the
X		** code just after the if and the body of the if is
X		** the goto yy_stack in the body.  This way the test
X		** can be made before the choice of what to do is needed.
X		*/
X		{
X			/* length of production doubled with extra bit */
X			register int yy_len = yyr2[ yy_n ];
X
X			if ( !( yy_len & 01 ) )
X			{
X				yy_len >>= 1;
X				yyval = ( yy_pv -= yy_len )[1];	/* $$ = $1 */
X				yy_state = yypgo[ yy_n = yyr1[ yy_n ] ] +
X					*( yy_ps -= yy_len ) + 1;
X				if ( yy_state >= YYLAST ||
X					yychk[ yy_state =
X					yyact[ yy_state ] ] != -yy_n )
X				{
X					yy_state = yyact[ yypgo[ yy_n ] ];
X				}
X				goto yy_stack;
X			}
X			yy_len >>= 1;
X			yyval = ( yy_pv -= yy_len )[1];	/* $$ = $1 */
X			yy_state = yypgo[ yy_n = yyr1[ yy_n ] ] +
X				*( yy_ps -= yy_len ) + 1;
X			if ( yy_state >= YYLAST ||
X				yychk[ yy_state = yyact[ yy_state ] ] != -yy_n )
X			{
X				yy_state = yyact[ yypgo[ yy_n ] ];
X			}
X		}
X					/* save until reenter driver code */
X		yystate = yy_state;
X		yyps = yy_ps;
X		yypv = yy_pv;
X	}
X	/*
X	** code supplied by user is placed in this switch
X	*/
X	switch( yytmp )
X	{
X		
Xcase 7:
X# line 194 "lev_comp.y"
X{
X			  int fout, i;
X
X			if (fatal_error > 0) {
X				fprintf(stderr,
X			      "%s : %d errors detected. No output created!\n",
X					fname, fatal_error);
X			} else {
X				char lbuf[20];
X				Strcpy(lbuf, yypvt[-4].map);
X				Strcat(lbuf, LEV_EXT);
X#ifdef MAC_THINKC5
X				fout = open(lbuf, O_WRONLY|O_CREAT|O_BINARY);
X#else
X				fout = open(lbuf, O_WRONLY|O_CREAT|O_BINARY, OMASK);
X#endif
X				if (fout < 0) {
X					yyerror("Can't open output file!!");
X					exit(1);
X				}
X				maze.flags = yypvt[-3].i;
X				memcpy(&(maze.init_lev), &(init_lev),
X				       sizeof(lev_init));
X				maze.numpart = npart;
X				maze.parts = NewTab(mazepart, npart);
X				for(i=0;i<npart;i++)
X				    maze.parts[i] = tmppart[i];
X				write_maze(fout, &maze);
X				(void) close(fout);
X				npart = 0;
X			}
X		  } break;
Xcase 8:
X# line 229 "lev_comp.y"
X{
X			int fout, i;
X
X			if (fatal_error > 0) {
X			    fprintf(stderr,
X			      "%s : %d errors detected. No output created!\n",
X					fname, fatal_error);
X			} else {
X				char lbuf[20];
X				Strcpy(lbuf, yypvt[-6].map);
X				Strcat(lbuf, LEV_EXT);
X#ifdef MAC_THINKC5
X				fout = open(lbuf, O_WRONLY|O_CREAT|O_BINARY);
X#else
X				fout = open(lbuf, O_WRONLY|O_CREAT|O_BINARY, OMASK);
X#endif
X				if (fout < 0) {
X					yyerror("Can't open output file!!");
X					exit(1);
X				}
X				special_lev.flags = yypvt[-5].i;
X				memcpy(&(special_lev.init_lev), &(init_lev),
X				       sizeof(lev_init));
X				special_lev.nroom = nrooms;
X				special_lev.rooms = NewTab(room, nrooms);
X				for(i=0; i<nrooms; i++)
X				    special_lev.rooms[i] = tmproom[i];
X				special_lev.ncorr = ncorridor;
X				special_lev.corrs = NewTab(corridor, ncorridor);
X				for(i=0; i<ncorridor; i++)
X				    special_lev.corrs[i] = tmpcor[i];
X				if (check_subrooms())
X				    write_lev(fout, &special_lev);
X				free_rooms(special_lev.rooms,special_lev.nroom);
X				nrooms = 0;
X				ncorridor = 0;
X				(void) close(fout);
X			}
X		  } break;
Xcase 9:
X# line 271 "lev_comp.y"
X{
X			if (index(yypvt[-0].map, '.'))
X			    yyerror("Invalid dot ('.') in level name.");
X			if (strlen(yypvt[-0].map) > 8)
X			    yyerror("Level names limited to 8 characters.");
X			yyval.map = yypvt[-0].map;
X			special_lev.nrobjects = 0;
X			special_lev.nrmonst = 0;
X		  } break;
Xcase 10:
X# line 283 "lev_comp.y"
X{
X			init_lev.init_present = FALSE;
X			yyval.i = 0;
X		  } break;
Xcase 11:
X# line 288 "lev_comp.y"
X{
X			init_lev.init_present = TRUE;
X			if((init_lev.fg = what_map_char(yypvt[-10].i)) == INVALID_TYPE)
X			    yyerror("Invalid foreground type.");
X			if((init_lev.bg = what_map_char(yypvt[-8].i)) == INVALID_TYPE)
X			    yyerror("Invalid background type.");
X			init_lev.smoothed = yypvt[-6].i;
X			init_lev.joined = yypvt[-4].i;
X			init_lev.lit = yypvt[-2].i;
X			init_lev.walled = yypvt[-0].i;
X			yyval.i = 1;
X		  } break;
Xcase 14:
X# line 307 "lev_comp.y"
X{
X			yyval.i = 0;
X		  } break;
Xcase 15:
X# line 311 "lev_comp.y"
X{
X			yyval.i = lev_flags;
X			lev_flags = 0;	/* clear for next user */
X		  } break;
Xcase 16:
X# line 318 "lev_comp.y"
X{
X			lev_flags |= yypvt[-2].i;
X		  } break;
Xcase 17:
X# line 322 "lev_comp.y"
X{
X			lev_flags |= yypvt[-0].i;
X		  } break;
Xcase 20:
X# line 332 "lev_comp.y"
X{
X			int i, j;
X
X			i = strlen(yypvt[-0].map) + 1;
X			j = tmpmessage[0] ? strlen(tmpmessage) : 0;
X			if(i+j > 255) {
X			   yyerror("Message string too long (>256 characters)");
X			} else {
X			    if(j) tmpmessage[j++] = '\n';
X			    strncpy(tmpmessage+j, yypvt[-0].map, i-1);
X			    tmpmessage[j+i-1] = 0;
X			}
X		  } break;
Xcase 23:
X# line 352 "lev_comp.y"
X{
X			if(special_lev.nrobjects) {
X			    yyerror("Object registers already initialized!");
X			} else {
X			    special_lev.nrobjects = n_olist;
X			    special_lev.robjects = (char *) alloc(n_olist);
X			    (void) memcpy((genericptr_t)special_lev.robjects,
X					  (genericptr_t)olist, n_olist);
X			}
X		  } break;
Xcase 24:
X# line 363 "lev_comp.y"
X{
X			if(special_lev.nrmonst) {
X			    yyerror("Monster registers already initialized!");
X			} else {
X			    special_lev.nrmonst = n_mlist;
X			    special_lev.rmonst = (char *) alloc(n_mlist);
X			    (void) memcpy((genericptr_t)special_lev.rmonst,
X					  (genericptr_t)mlist, n_mlist);
X			  }
X		  } break;
END_OF_FILE
if test 46649 -ne `wc -c <'sys/share/lev_yacc.c1'`; then
    echo shar: \"'sys/share/lev_yacc.c1'\" unpacked with wrong size!
fi
# end of 'sys/share/lev_yacc.c1'
if test -f 'sys/winnt/Makefile.utl' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'sys/winnt/Makefile.utl'\" to \"'sys/winnt/Makefile.utl.orig'\"
  mv -f 'sys/winnt/Makefile.utl' 'sys/winnt/Makefile.utl.orig'
fi
echo shar: Extracting \"'sys/winnt/Makefile.utl'\" \(7833 characters\)
sed "s/^X//" >'sys/winnt/Makefile.utl' <<'END_OF_FILE'
X#       SCCS Id: @(#)Makefile.utl               3.1     93/02/21
X#       Copyright (c) NetHack PC Development Team 1993
X#
X#       NT NetHack 3.1 Utilities Makefile 
X#	for MS NMAKE for Windows NT
X#  
X#	NT Version Tested:  October 1992 SDK pre-release
X#			    + December '92 compiler fix
X#
X#       For questions read the Install.nt file included with
X#       the distribution.
X#
X#	Michael Allison 
X#
X# ---------------------------------------------------------------------
X#  In addition to your C compiler,
X#
X#  if you want to change   you will need a
X#  files with suffix   workalike for
X#         .y         yacc
X#         .l         lex
X#
X#  Executables.
X#
X# All the compiler and linker executables and flags are defined
X# by including the following nmake include file.
X#
X# Do not delete the following include.
X#
X!include <..\sys\winnt\nhincl.mak>
X#
X#YACC  = bison -y
XYACC   = yacc
XLEX   = flex
X#LEX   = lex
X
X#flex skeleton file (if needed)
XFLEXSKEL =
X#FLEXSKEL = -S../sys/winnt/flex.ske
X
XYTABC  = ytab.c
XYTABH  = ytab.h
XLEXYYC   = lexyy.c
X
X#
X#  Flags.
X#
X# Most flags for Windows NT Console I/O are defined in
X# the nmake include file above.
X#
X
X#
X#       Directories
X#
X
XINCL    = ..\include
XDAT     = ..\dat
XSRC     = ..\src
XDINCL   = ..\include
X
Xdefault: all
X
X
X#############################################################################
X#
X# nothing below this line should have to be changed
X#
XNTSUB = -DWIN32CON
X#
X#  Utility Objects.
X#
X
XMAKESRC     = makedefs.c
X
XSPLEVSRC    = lev_yacc.c  lev_lex.c   lev_main.c  panic.c
X
XDGNCOMPSRC  = dgn_yacc.c  dgn_lex.c   dgn_main.c
X
XMAKEOBJS    = makedefs.o  monst.o        objects.o
X
XSPLEVOBJS   = lev_yacc.o  lev_$(LEX).o  lev_main.o  alloc.o     \
X              monst.o     objects.o     panic.o  \
X              drawing.o   decl.o
X
XDGNCOMPOBJS = dgn_yacc.o  dgn_$(LEX).o  dgn_main.o  alloc.o      \
X              panic.o
X
XRECOVOBJS   =  recover.o
X
X#
X#  Header Objects.
X#
X
XDGN_FILE_H = $(INCL)\align.h    $(INCL)\dgn_file.h
XDUNGEON_H  = $(INCL)\align.h    $(INCL)\dungeon.h
XEMIN_H     = $(DUNGEON_H)       $(INCL)\emin.h
XEPRI_H     = $(DUNGEON_H)       $(INCL)\align.h     $(INCL)\epri.h
XESHK_H     = $(DUNGEON_H)       $(INCL)\eshk.h
XMONDATA_H  = $(INCL)\align.h    $(INCL)\mondata.h
XMONST_H    = $(INCL)\align.h    $(INCL)\monst.h
XPERMONST_H = $(INCL)\monattk.h  $(INCL)\monflag.h   $(INCL)\align.h   \
X             $(INCL)\permonst.h
XRM_H       = $(INCL)\align.h    $(INCL)\rm.h
XSP_LEV_H   = $(INCL)\align.h    $(INCL)\sp_lev.h
XVAULT_H    = $(DUNGEON_H)       $(INCL)\vault.h
XYOUPROP_H  = $(PERMONST_H)      $(MONDATA_H)        $(INCL)\prop.h    \
X             $(INCL)\pm.h       $(INCL)\youprop.h
XYOU_H      = $(MONST_H)         $(YOUPROP_H)        $(INCL)\align.h   \
X             $(INCL)\attrib.h   $(INCL)\you.h
XDISPLAY_H  = $(MONDATA_H)       $(INCL)\vision.h    $(INCL)\display.h
XNTCONF_H   = $(INCL)\micro.h    $(INCL)\system.h    $(INCL)\ntconf.h
XCONFIG_H   = $(GLOBAL_H)        $(INCL)\tradstdc.h  $(INCL)\config.h
XDECL_H     = $(YOU_H)           $(INCL)\spell.h     $(INCL)\color.h   \
X             $(INCL)\obj.h      $(INCL)\onames.h    $(INCL)\pm.h      \
X             $(INCL)\decl.h
XGLOBAL_H   = $(NTCONF_H)        $(INCL)\coord.h     $(INCL)\global.h
XHACK_H     = $(CONFIG_H)        $(DUNGEON_H)        $(DECL_H)         \
X             $(DISPLAY_H)       $(INCL)\monsym.h    $(INCL)\mkroom.h  \
X             $(INCL)\objclass.h $(INCL)\trap.h      $(INCL)\flag.h    \
X             $(RM_H)            $(INCL)\vision.h    $(INCL)\wintype.h \
X             $(INCL)\engrave.h  $(INCL)\rect.h      $(INCL)\extern.h \
X             $(INCL)\trampoli.h $(INCL)\hack.h
X
X
X
X#
X#  Make Rules.
X#
X
X.SUFFIXES:  .exe .o .c .y .l
X
X.c.o:
X    $(cc) $(cflags) $(NTSUB) -I$(INCL)  $(cvars) $(cdebug) -Fo$*.o $*.c
X
X#
X#  Primary Targets.
X#
Xall:   utility.tag
X
Xutility.tag: $(INCL)\trap.h    $(INCL)\onames.h        \
X             $(INCL)\pm.h      $(SRC)\monstr.c   $(SRC)\vis_tab.c  \
X             lev_comp.exe      dgn_comp.exe    recover.exe
X    echo utilities made > utility.tag
X
Xclean:
X    if exist *.o del *.o
X    if exist *.map del *.map
X
Xspotless: clean
X    if exist utility.tag       del utility.tag
X    if exist makedefs.exe      del makedefs.exe
X    if exist lev_comp.exe      del lev_comp.exe
X    if exist dgn_comp.exe      del dgn_comp.exe
X    if exist recover.exe       del recover.exe
X    if exist $(INCL)\date.h    del $(INCL)\date.h
X    if exist $(INCL)\onames.h  del $(INCL)\onames.h
X    if exist $(INCL)\pm.h      del $(INCL)\pm.h
X    if exist $(INCL)\vis_tab.h del $(INCL)\vis_tab.h
X    if exist $(SRC)\monstr.c   del $(SRC)\monstr.c
X    if exist $(SRC)\vis_tab.c  del $(SRC)\vis_tab.c
X
X#
X#  Secondary Targets.
X#
X
X$(INCL)\onames.h: makedefs.exe
X    .\makedefs -o
X
X$(INCL)\pm.h: makedefs.exe
X    .\makedefs -p
X
X$(SRC)\monstr.c: makedefs.exe
X    .\makedefs -m
X
X$(SRC)\vis_tab.h: makedefs.exe
X    .\makedefs -z
X
X$(SRC)\vis_tab.c: makedefs.exe
X    .\makedefs -z
X
X#
X#  Makedefs Stuff
X#
X
Xmakedefs.exe:  $(MAKEOBJS)
X    $(link) $(linkdebug) $(conflags) -out:$*.exe $(MAKEOBJS) $(conlibs)
X
Xmakedefs.o:  $(CONFIG_H)        $(PERMONST_H)      $(INCL)\objclass.h \
X             $(INCL)\monsym.h   $(INCL)\qtext.h
X
X#
X#  Level Compiler Dependencies
X#
X
Xlev_comp.exe:  $(SPLEVOBJS)
X    @echo $(SPLEVOBJS) > $*.res
X    $(link) $(linkdebug) $(conflags) -out:$*.exe @$*.res $(conlibs)
X
Xlev_yacc.o:  $(HACK_H)   $(SP_LEV_H)    lev_yacc.c
X    $(cc) $(cflags) $(NTSUB) -I$(INCL)  $(cvars) $(cdebug) -Fo$*.o $*.c
X
Xlev_$(LEX).o:  $(HACK_H)   $(SP_LEV_H)    $(INCL)\lev_comp.h \
X               lev_lex.c
X	$(cc) $(cflags) $(NTSUB) -I$(INCL)  $(cvars) $(cdebug) -Fo$*.o \
X               lev_lex.c
X
Xlev_main.o:  $(HACK_H)
X
X$(INCL)\lev_comp.h: lev_yacc.c
X
Xlev_yacc.c:  lev_comp.y
X    $(YACC) -d lev_comp.y
X    copy $(YTABC) lev_yacc.c
X    copy $(YTABH) $(DINCL)\lev_comp.h
X    del $(YTABC)
X    del $(YTABH)
X
X
Xlev_lex.c:  lev_comp.l
X    $(LEX) $(FLEXSKEL) lev_comp.l
X    copy $(LEXYYC) lev_lex.c
X    del $(LEXYYC)
X
X
X#
X#  Dungeon Dependencies
X#
X
Xdgn_comp.exe:  $(DGNCOMPOBJS)
X    @echo $(DGNCOMPOBJS) > $*.res
X    $(link) $(linkdebug) $(conflags) -out:$*.exe @$*.res $(conlibs)
X
Xdgn_yacc.o:  $(HACK_H)   $(DGN_FILE_H)  dgn_yacc.c
X    $(cc) $(cflags) $(NTSUB) -I$(INCL)  $(cvars) $(cdebug) -Fo$*.o $*.c
X
Xdgn_$(LEX).o:  $(HACK_H)   $(DGN_FILE_H)  $(INCL)\dgn_comp.h \
X               dgn_lex.c
X	$(cc) $(cflags) $(NTSUB) -I$(INCL)  $(cvars) $(cdebug) -Fo$*.o \
X	       dgn_lex.c
X
Xdgn_main.o:  $(HACK_H)
X
X$(INCL)\dgn_comp.h:  dgn_yacc.c
X
Xdgn_yacc.c: dgn_comp.y
X    $(YACC) -d dgn_comp.y
X    copy $(YTABC) dgn_yacc.c
X    copy $(YTABH) $(DINCL)\dgn_comp.h
X    del $(YTABC)
X    del $(YTABH)
X
Xdgn_lex.c:  dgn_comp.l
X    $(LEX) $(FLEXSKEL)  dgn_comp.l
X    copy $(LEXYYC) dgn_lex.c
X    del $(LEXYYC)
X
X#
X#  Recover Utility
X#
X
Xrecover.exe:   $(RECOVOBJS)
X    $(link) $(linkdebug) $(conflags) -out:$*.exe $(RECOVOBJS) $(conlibs)
X
Xrecover.o:   $(CONFIG_H) recover.c
X    $(cc) $(cflags) $(NTSUB) -I$(INCL)  $(cvars) $(cdebug) -Fo$*.o $*.c
X
X#
X#  Other Dependencies.
X#
X
Xalloc.o: $(CONFIG_H)     $(SRC)\alloc.c
X    $(cc) $(cflags) $(NTSUB) -I$(INCL)  $(cvars) $(cdebug) -Fo$*.o $(SRC)\$*.c
X
Xdrawing.o: $(CONFIG_H) $(SRC)\drawing.c
X    $(cc) $(cflags) $(NTSUB) -I$(INCL)  $(cvars) $(cdebug) -Fo$*.o $(SRC)\$*.c
X
Xdecl.o: $(CONFIG_H) $(SRC)\decl.c
X    $(cc) $(cflags) $(NTSUB) -I$(INCL)  $(cvars) $(cdebug) -Fo$*.o $(SRC)\$*.c
X
Xmonst.o: $(CONFIG_H)         $(PERMONST_H)      $(ESHK_H)          \
X         $(EPRI_H)           $(VAULT_H)         $(INCL)\monsym.h   \
X         $(INCL)\color.h     $(SRC)\monst.c
X    $(cc) $(cflags) $(NTSUB) -I$(INCL)  $(cvars) $(cdebug) -Fo$*.o $(SRC)\$*.c
X
Xobjects.o: $(CONFIG_H)        $(INCL)\obj.h      $(INCL)\objclass.h \
X           $(INCL)\prop.h     $(INCL)\color.h    $(SRC)\objects.c
X    $(cc) $(cflags) $(NTSUB) -I$(INCL)  $(cvars) $(cdebug) -Fo$*.o $(SRC)\$*.c
X
Xpanic.o:   $(CONFIG_H)
END_OF_FILE
if test 7833 -ne `wc -c <'sys/winnt/Makefile.utl'`; then
    echo shar: \"'sys/winnt/Makefile.utl'\" unpacked with wrong size!
fi
# end of 'sys/winnt/Makefile.utl'
echo shar: End of archive 20 \(of 31\).
cp /dev/null ark20isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 31 archives.
    echo "Now execute 'patchit.sh'"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
