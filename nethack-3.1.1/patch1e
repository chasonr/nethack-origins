Subject:  v17i046:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Patch1e/31
Newsgroups: comp.sources.games
Approved: billr@saab.CNA.TEK.COM

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 17, Issue 46
Archive-name: nethack31/Patch1e
Patch-To: nethack31: Volume 16, Issue 
Environment: Amiga, Atari, Mac, MS-DOS, Windows-NT, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 5 (of 31)."
# Contents:  patches01j
# Wrapped by billr@saab on Fri Mar  5 10:50:42 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'patches01j' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'patches01j'\" to \"'patches01j.orig'\"
  mv -f 'patches01j' 'patches01j.orig'
fi
echo shar: Extracting \"'patches01j'\" \(55621 characters\)
sed "s/^X//" >'patches01j' <<'END_OF_FILE'
X*** /tmp/da08710	Thu Feb 25 10:25:56 1993
X--- src/weapon.c	Sun Feb 21 16:29:12 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)weapon.c	3.1	93/01/15	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)weapon.c	3.1	93/02/09	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 11,17 ****
X  
X  #ifdef OVLB
X  
X! static const char NEARDATA kebabable[] = { S_XORN, S_DRAGON, S_NAGA, S_GIANT, 0 };
X  
X  /*
X   *	hitval returns an integer representing the "to hit" bonuses
X--- 11,17 ----
X  
X  #ifdef OVLB
X  
X! static NEARDATA const char kebabable[] = { S_XORN, S_DRAGON, S_NAGA, S_GIANT, 0 };
X  
X  /*
X   *	hitval returns an integer representing the "to hit" bonuses
X***************
X*** 168,180 ****
X  	struct obj *otmp;
X  
X  	for(otmp=mtmp->minvent; otmp; otmp = otmp->nobj) {
X! 		if (otmp->otyp == x && touch_artifact(otmp,mtmp))
X  			return otmp;
X  	}
X  	return (struct obj *)0;
X  }
X  
X! static const int NEARDATA rwep[] =
X  	{ DWARVISH_SPEAR, ELVEN_SPEAR, SPEAR, ORCISH_SPEAR, JAVELIN,
X  	  SHURIKEN, SILVER_ARROW, ELVEN_ARROW, ARROW, ORCISH_ARROW,
X  	  CROSSBOW_BOLT, ELVEN_DAGGER, DAGGER, ORCISH_DAGGER, KNIFE, ROCK,
X--- 168,184 ----
X  	struct obj *otmp;
X  
X  	for(otmp=mtmp->minvent; otmp; otmp = otmp->nobj) {
X! 		if (otmp->otyp == x && touch_artifact(otmp,mtmp)
X! #ifdef MUSE
X! 			 && !(x == CORPSE && otmp->corpsenm != PM_COCKATRICE)
X! #endif
X! 									)
X  			return otmp;
X  	}
X  	return (struct obj *)0;
X  }
X  
X! static NEARDATA const int rwep[] =
X  	{ DWARVISH_SPEAR, ELVEN_SPEAR, SPEAR, ORCISH_SPEAR, JAVELIN,
X  	  SHURIKEN, SILVER_ARROW, ELVEN_ARROW, ARROW, ORCISH_ARROW,
X  	  CROSSBOW_BOLT, ELVEN_DAGGER, DAGGER, ORCISH_DAGGER, KNIFE, ROCK,
X***************
X*** 269,275 ****
X  }
X  
X  /* 0 = used by any monster; 1 = only used by strong monsters */
X! static const struct hwep { short otyp, big; } NEARDATA hwep[] = {
X  	  {TSURUGI,1}, {RUNESWORD,0},
X  	  {DWARVISH_MATTOCK,1}, {TWO_HANDED_SWORD,1}, {BATTLE_AXE,1},
X  	  {KATANA,0}, {UNICORN_HORN,1}, {CRYSKNIFE,0},
X--- 273,282 ----
X  }
X  
X  /* 0 = used by any monster; 1 = only used by strong monsters */
X! static NEARDATA const struct hwep { short otyp, big; } hwep[] = {
X! #ifdef MUSE
X! 	  {CORPSE,0},  /* cockatrice corpse */
X! #endif
X  	  {TSURUGI,1}, {RUNESWORD,0},
X  	  {DWARVISH_MATTOCK,1}, {TWO_HANDED_SWORD,1}, {BATTLE_AXE,1},
X  	  {KATANA,0}, {UNICORN_HORN,1}, {CRYSKNIFE,0},
X***************
X*** 306,312 ****
X  	for (i = 0, hw = hwep; i < SIZE(hwep); i++, hw++)
X  	    if ((strong || !hw->big) &&
X  #ifdef MUSE
X! 	      (!objects[hw->otyp].oc_bimanual || !which_armor(mtmp, W_ARMS)) &&
X  #endif
X  	(objects[hw->otyp].oc_material != SILVER || !hates_silver(mtmp->data)))
X  		Oselect(hw->otyp);
X--- 313,320 ----
X  	for (i = 0, hw = hwep; i < SIZE(hwep); i++, hw++)
X  	    if ((strong || !hw->big) &&
X  #ifdef MUSE
X! 	      (!objects[hw->otyp].oc_bimanual ||
X! 					(mtmp->misc_worn_check & W_ARMS)) &&
X  #endif
X  	(objects[hw->otyp].oc_material != SILVER || !hates_silver(mtmp->data)))
X  		Oselect(hw->otyp);
X***************
X*** 366,371 ****
X--- 374,381 ----
X  	 * be handled by waiting until mon_wield_item is actually called.
X  	 * Though the monster still wields the wrong weapon until then,
X  	 * this is OK since the player can't see it.
X+ 	 * Note that if there is no change, setting the check to NEED_WEAPON
X+ 	 * is harmless.
X  	 * Possible problem: big monster with big cursed weapon gets
X  	 * polymorphed into little monster.  But it's not quite clear how to
X  	 * handle this anyway....
X***************
X*** 412,442 ****
X  		 * can know it's cursed and needn't even bother trying.
X  		 * Still....
X  		 */
X! 		if (mw_tmp && mw_tmp->cursed) {
X! 		    if (obj->otyp == PICK_AXE) {
X! 			if (canseemon(mon)) {
X  			    pline("Since %s weapon %s welded to %s hand,",
X! 				s_suffix(mon_nam(mon)),
X! 				(mw_tmp->quan == 1L) ? "is" : "are",
X! 				humanoid(mon->data)
X! 					? (mon->female ? "her" : "his")
X! 					: "its");
X  			    pline("%s cannot wield that %s.",
X  				mon_nam(mon), xname(obj));
X! 			    mw_tmp->bknown = 1;
X! 			}
X! 		    } else {
X! 			if (canseemon(mon)) {
X  			    pline("%s tries to wield %s.", Monnam(mon),
X  				doname(obj));
X  			    pline("%s %s %s welded to %s hand!",
X! 				s_suffix(Monnam(mon)), xname(mw_tmp),
X! 				(mw_tmp->quan == 1L) ? "is" : "are",
X! 				humanoid(mon->data)
X! 					? (mon->female ? "her" : "his")
X! 					: "its");
X! 			    mw_tmp->bknown = 1;
X  			}
X  		    }
X  		    mon->weapon_check = NO_WEAPON_WANTED;
X  		    return 1;
X--- 422,445 ----
X  		 * can know it's cursed and needn't even bother trying.
X  		 * Still....
X  		 */
X! 		if (mw_tmp && mw_tmp->cursed && mw_tmp->otyp != CORPSE) {
X! 		    if (canseemon(mon)) {
X! 			if (obj->otyp == PICK_AXE) {
X  			    pline("Since %s weapon %s welded to %s hand,",
X! 				  s_suffix(mon_nam(mon)),
X! 				  (mw_tmp->quan == 1L) ? "is" : "are",
X! 				  his[pronoun_gender(mon)]);
X  			    pline("%s cannot wield that %s.",
X  				mon_nam(mon), xname(obj));
X! 			} else {
X  			    pline("%s tries to wield %s.", Monnam(mon),
X  				doname(obj));
X  			    pline("%s %s %s welded to %s hand!",
X! 				  s_suffix(Monnam(mon)), xname(mw_tmp),
X! 				  (mw_tmp->quan == 1L) ? "is" : "are",
X! 				  his[pronoun_gender(mon)]);
X  			}
X+ 			mw_tmp->bknown = 1;
X  		    }
X  		    mon->weapon_check = NO_WEAPON_WANTED;
X  		    return 1;
X***************
X*** 445,451 ****
X  		mon->weapon_check = NEED_WEAPON;
X  		if (canseemon(mon)) {
X  			pline("%s wields %s!", Monnam(mon), doname(obj));
X! 			if (obj->cursed) {
X  				pline("%s %s to %s hand!",
X  					The(xname(obj)),
X  					(obj->quan == 1L) ? "welds itself"
X--- 448,454 ----
X  		mon->weapon_check = NEED_WEAPON;
X  		if (canseemon(mon)) {
X  			pline("%s wields %s!", Monnam(mon), doname(obj));
X! 			if (obj->cursed && obj->otyp != CORPSE) {
X  				pline("%s %s to %s hand!",
X  					The(xname(obj)),
X  					(obj->quan == 1L) ? "welds itself"
X*** /tmp/da08726	Thu Feb 25 10:26:00 1993
X--- src/wield.c	Fri Feb 12 10:27:03 1993
X***************
X*** 41,47 ****
X  	}
X  }
X  
X! static const char NEARDATA wield_objs[] =
X  	{ ALL_CLASSES, ALLOW_NONE, WEAPON_CLASS, TOOL_CLASS, 0 };
X  
X  int
X--- 41,47 ----
X  	}
X  }
X  
X! static NEARDATA const char wield_objs[] =
X  	{ ALL_CLASSES, ALLOW_NONE, WEAPON_CLASS, TOOL_CLASS, 0 };
X  
X  int
X*** /tmp/da08734	Thu Feb 25 10:26:03 1993
X--- src/windows.c	Fri Feb 12 10:25:21 1993
X***************
X*** 19,25 ****
X  extern struct window_procs amii_procs ;
X  #endif
X  
X! struct window_procs NEARDATA windowprocs;
X  
X  static
X  struct win_choices {
X--- 19,25 ----
X  extern struct window_procs amii_procs ;
X  #endif
X  
X! NEARDATA struct window_procs windowprocs;
X  
X  static
X  struct win_choices {
X***************
X*** 41,47 ****
X--- 41,55 ----
X      { 0, 0 }		/* must be last */
X  };
X  
X+ static
X  void
X+ def_raw_print(s)
X+ const char *s;
X+ {
X+     puts(s);
X+ }
X+ 
X+ void
X  choose_windows(s)
X  const char *s;
X  {
X***************
X*** 54,62 ****
X--- 62,76 ----
X  	    return;
X  	}
X  
X+     if (!windowprocs.win_raw_print)
X+ 	windowprocs.win_raw_print = def_raw_print;
X+ 
X      raw_printf("Window type %s not recognized.  Choices are:", s);
X      for(i=0; winchoices[i].procs; i++)
X  	raw_printf("        %s", winchoices[i].procs->name);
X+ 
X+     if (windowprocs.win_raw_print == def_raw_print)
X+ 	terminate(0);
X  }
X  
X  /*windows.c*/
X*** /tmp/da08742	Thu Feb 25 10:26:05 1993
X--- src/wizard.c	Mon Feb 22 12:24:19 1993
X***************
X*** 23,29 ****
X  static long FDECL(strategy, (struct monst *));
X  
X  /*	TODO:	Expand this list.	*/
X! static const int NEARDATA nasties[] = {
X  	PM_COCKATRICE, PM_ETTIN, PM_STALKER, PM_MINOTAUR, PM_RED_DRAGON,
X  	PM_GREEN_DRAGON, PM_OWLBEAR, PM_PURPLE_WORM, PM_ROCK_TROLL, PM_XAN,
X  	PM_GREMLIN, PM_UMBER_HULK, PM_VAMPIRE_LORD, PM_XORN, PM_ZRUTY,
X--- 23,29 ----
X  static long FDECL(strategy, (struct monst *));
X  
X  /*	TODO:	Expand this list.	*/
X! static NEARDATA const int nasties[] = {
X  	PM_COCKATRICE, PM_ETTIN, PM_STALKER, PM_MINOTAUR, PM_RED_DRAGON,
X  	PM_GREEN_DRAGON, PM_OWLBEAR, PM_PURPLE_WORM, PM_ROCK_TROLL, PM_XAN,
X  	PM_GREMLIN, PM_UMBER_HULK, PM_VAMPIRE_LORD, PM_XORN, PM_ZRUTY,
X***************
X*** 34,40 ****
X  #endif
X  	};
X  
X! static const unsigned NEARDATA wizapp[] = {
X  	PM_HUMAN, PM_WATER_DEMON, PM_VAMPIRE,
X  	PM_RED_DRAGON, PM_TROLL, PM_UMBER_HULK,
X  	PM_XORN, PM_XAN, PM_COCKATRICE,
X--- 34,40 ----
X  #endif
X  	};
X  
X! static NEARDATA const unsigned wizapp[] = {
X  	PM_HUMAN, PM_WATER_DEMON, PM_VAMPIRE,
X  	PM_RED_DRAGON, PM_TROLL, PM_UMBER_HULK,
X  	PM_XORN, PM_XAN, PM_COCKATRICE,
X***************
X*** 421,428 ****
X  		    set_malign(mtmp);
X  		} else /* GENOD? */
X  		    mtmp = makemon((struct permonst *)0, u.ux, u.uy);
X! 		if(mtmp->data->maligntyp == 0 ||
X! 		   sgn(mtmp->data->maligntyp) == sgn(castalign))
X  		    break;
X  	    }
X      }
X--- 421,428 ----
X  		    set_malign(mtmp);
X  		} else /* GENOD? */
X  		    mtmp = makemon((struct permonst *)0, u.ux, u.uy);
X! 		if(mtmp && (mtmp->data->maligntyp == 0 ||
X! 		            sgn(mtmp->data->maligntyp) == sgn(castalign)) )
X  		    break;
X  	    }
X      }
X*** /tmp/da08750	Thu Feb 25 10:26:07 1993
X--- src/worm.c	Thu Feb 18 17:38:13 1993
X***************
X*** 322,328 ****
X      int wnum = worm->wormno;
X      int cut_chance, new_wnum;
X  
X! /*  if (!wnum) return; /* bullet proofing */
X  
X      if (x == worm->mx && y == worm->my) return;		/* hit on head */
X  
X--- 322,328 ----
X      int wnum = worm->wormno;
X      int cut_chance, new_wnum;
X  
X!     if (!wnum) return; /* bullet proofing */
X  
X      if (x == worm->mx && y == worm->my) return;		/* hit on head */
X  
X***************
X*** 370,376 ****
X      if (rn2(3) || !(new_wnum = get_wormno())) {
X  	You("cut part of the tail off of %s.", mon_nam(worm));
X  	toss_wsegs(new_tail, TRUE);
X! 	worm->mhp /= 2;
X  	return;
X      }
X  
X--- 370,376 ----
X      if (rn2(3) || !(new_wnum = get_wormno())) {
X  	You("cut part of the tail off of %s.", mon_nam(worm));
X  	toss_wsegs(new_tail, TRUE);
X! 	if (worm->mhp > 1) worm->mhp /= 2;
X  	return;
X      }
X  
X*** /tmp/da08758	Thu Feb 25 10:26:09 1993
X--- src/worn.c	Thu Feb 11 14:53:52 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)worn.c	3.1	92/12/13
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)worn.c	3.1	93/02/09
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 104,111 ****
X  
X  /* Wear first object of that type it finds, and never switch unless it
X   * has none at all.  This means that monsters with leather armor never
X!  * switch to plate mail, but it also avoids the overhead of having seven
X!  * struct obj *s for every monster in the game, more if we ever extend this.
X   */
X  void
X  m_dowear(mon, creation)
X--- 104,112 ----
X  
X  /* Wear first object of that type it finds, and never switch unless it
X   * has none at all.  This means that monsters with leather armor never
X!  * switch to plate mail, but it also avoids the overhead of either having 8
X!  * struct obj *s for every monster in the game, or of doing multiple inventory
X!  * searches each round using which_armor().
X   */
X  void
X  m_dowear(mon, creation)
X***************
X*** 124,134 ****
X  	for(obj = mon->minvent; obj; obj = obj->nobj) {
X  		long flag;
X  
X  # ifdef TOURIST
X! 		if (obj->otyp == HAWAIIAN_SHIRT) flag = W_ARMU;
X! 		else
X  # endif
X! 		if (is_cloak(obj)) flag = W_ARMC;
X  		else if (is_helmet(obj)) flag = W_ARMH;
X  		else if (is_shield(obj)) {
X  			if (MON_WEP(mon) && bimanual(MON_WEP(mon)))
X--- 125,137 ----
X  	for(obj = mon->minvent; obj; obj = obj->nobj) {
X  		long flag;
X  
X+ 		if (obj->otyp == AMULET_OF_LIFE_SAVING ||
X+ 				obj->otyp == AMULET_OF_REFLECTION)
X+ 			flag = W_AMUL;
X  # ifdef TOURIST
X! 		else if (obj->otyp == HAWAIIAN_SHIRT) flag = W_ARMU;
X  # endif
X! 		else if (is_cloak(obj)) flag = W_ARMC;
X  		else if (is_helmet(obj)) flag = W_ARMH;
X  		else if (is_shield(obj)) {
X  			if (MON_WEP(mon) && bimanual(MON_WEP(mon)))
X***************
X*** 201,213 ****
X  	register struct obj *otmp;
X  	struct permonst *mdat = mon->data;
X  	boolean vis = cansee(mon->mx, mon->my);
X! 	const char *pronoun, *ppronoun;
X  
X- 	switch(gender(mon)) {
X- 	    case 0: pronoun = "him"; ppronoun = "his"; break;
X- 	    case 1: pronoun = ppronoun = "her"; break;
X- 	    default: pronoun = "it"; ppronoun = "its"; break;
X- 	}
X  	if (breakarm(mdat)) {
X  	    if (otmp = which_armor(mon, W_ARM)) {
X  		if (vis)
X--- 204,212 ----
X  	register struct obj *otmp;
X  	struct permonst *mdat = mon->data;
X  	boolean vis = cansee(mon->mx, mon->my);
X! 	const char *pronoun = him[pronoun_gender(mon)],
X! 			*ppronoun = his[pronoun_gender(mon)];
X  
X  	if (breakarm(mdat)) {
X  	    if (otmp = which_armor(mon, W_ARM)) {
X  		if (vis)
X*** /tmp/da08766	Thu Feb 25 10:26:11 1993
X--- src/write.c	Thu Feb 18 10:58:45 1993
X***************
X*** 62,68 ****
X  	return(1000);
X  }
X  
X! static const char NEARDATA write_on[] = { SCROLL_CLASS, SPBOOK_CLASS, 0 };
X  
X  int
X  dowrite(pen)
X--- 62,68 ----
X  	return(1000);
X  }
X  
X! static NEARDATA const char write_on[] = { SCROLL_CLASS, SPBOOK_CLASS, 0 };
X  
X  int
X  dowrite(pen)
X***************
X*** 89,95 ****
X  	if(!paper)
X  		return(0);
X  	if(Blind && !paper->dknown) {
X! 		You("can't tell if that %s's blank or not!",
X  		      paper->oclass == SPBOOK_CLASS ? "spellbook" :
X  		      "scroll");
X  		return(1);
X--- 89,95 ----
X  	if(!paper)
X  		return(0);
X  	if(Blind && !paper->dknown) {
X! 		You("don't know if that %s is blank or not!",
X  		      paper->oclass == SPBOOK_CLASS ? "spellbook" :
X  		      "scroll");
X  		return(1);
X***************
X*** 96,104 ****
X  	}
X  	paper->dknown = 1;
X  	if(paper->otyp != SCR_BLANK_PAPER && paper->otyp != SPE_BLANK_PAPER) {
X! 		You("fool, that %s's not blank!",
X  		    paper->oclass == SPBOOK_CLASS ? "spellbook" :
X  		    "scroll");
X  		return(1);
X  	}
X  
X--- 96,105 ----
X  	}
X  	paper->dknown = 1;
X  	if(paper->otyp != SCR_BLANK_PAPER && paper->otyp != SPE_BLANK_PAPER) {
X! 		pline("That %s is not blank!",
X  		    paper->oclass == SPBOOK_CLASS ? "spellbook" :
X  		    "scroll");
X+ 		exercise(A_WIS, FALSE);
X  		return(1);
X  	}
X  
X***************
X*** 183,196 ****
X  	makeknown(new_obj->otyp);
X  
X  	/* success */
X- 	new_obj = addinv(new_obj);
X  	new_obj->blessed = (curseval > 0);
X  	new_obj->cursed = (curseval < 0);
X- 	prinv(NULL, new_obj, 1L);
X  #ifdef MAIL
X  	if (new_obj->otyp == SCR_MAIL) new_obj->spe = 1;
X  #endif
X! 	new_obj->known = 1;
X  	return(1);
X  }
X  
X--- 184,198 ----
X  	makeknown(new_obj->otyp);
X  
X  	/* success */
X  	new_obj->blessed = (curseval > 0);
X  	new_obj->cursed = (curseval < 0);
X  #ifdef MAIL
X  	if (new_obj->otyp == SCR_MAIL) new_obj->spe = 1;
X  #endif
X! 	new_obj = hold_another_object(new_obj, "Oops!  %s out of your grasp!",
X! 					       The(aobjnam(new_obj, "slip")),
X! 					       (const char *)0);
X! 	if (new_obj) new_obj->known = 1;
X  	return(1);
X  }
X  
X*** /tmp/da08774	Thu Feb 25 10:26:13 1993
X--- src/zap.c	Sun Feb 21 16:06:54 1993
X***************
X*** 11,18 ****
X   */
X  #define MAGIC_COOKIE 1000
X  
X! static boolean NEARDATA obj_zapped;
X! static int NEARDATA poly_zapped;
X  
X  #ifdef MUSE
X  /* kludge to use mondied instead of killed */
X--- 11,18 ----
X   */
X  #define MAGIC_COOKIE 1000
X  
X! static NEARDATA boolean obj_zapped;
X! static NEARDATA int poly_zapped;
X  
X  #ifdef MUSE
X  /* kludge to use mondied instead of killed */
X***************
X*** 21,38 ****
X  
X  static boolean FDECL(obj_resists, (struct obj *));
X  static boolean FDECL(obj_shudders, (struct obj *));
X! static void FDECL(polyuse,(struct obj*, int, int));
X  static void FDECL(do_osshock, (struct obj *));
X  static void FDECL(create_polymon, (struct obj *));
X  static int FDECL(burn_floor_paper,(int,int));
X! static void FDECL(cancel_item,(struct obj *));
X  static int FDECL(bhitm, (struct monst *,struct obj *));
X  #ifndef MUSE
X! STATIC_PTR int FDECL(bhito,(struct obj *,struct obj *));
X  #endif
X! STATIC_PTR int FDECL(bhitpile,(struct obj *,int (*)(OBJ_P,OBJ_P),int,int));
X! static void FDECL(backfire,(struct obj *));
X! static int FDECL(zhit,(struct monst *,int,int));
X  
X  #define ZT_MAGIC_MISSILE	(AD_MAGM-1)
X  #define ZT_FIRE			(AD_FIRE-1)
X--- 21,39 ----
X  
X  static boolean FDECL(obj_resists, (struct obj *));
X  static boolean FDECL(obj_shudders, (struct obj *));
X! static void FDECL(polyuse, (struct obj*, int, int));
X  static void FDECL(do_osshock, (struct obj *));
X  static void FDECL(create_polymon, (struct obj *));
X  static int FDECL(burn_floor_paper,(int,int));
X! static void FDECL(costly_cancel, (struct obj *));
X! static void FDECL(cancel_item, (struct obj *));
X  static int FDECL(bhitm, (struct monst *,struct obj *));
X  #ifndef MUSE
X! STATIC_PTR int FDECL(bhito, (struct obj *,struct obj *));
X  #endif
X! STATIC_PTR int FDECL(bhitpile, (struct obj *,int (*)(OBJ_P,OBJ_P),int,int));
X! static void FDECL(backfire, (struct obj *));
X! static int FDECL(zhit, (struct monst *,int,int));
X  
X  #define ZT_MAGIC_MISSILE	(AD_MAGM-1)
X  #define ZT_FIRE			(AD_FIRE-1)
X***************
X*** 267,274 ****
X  	return mtmp;
X  }
X  
X! static const char NEARDATA charged_objs[] = { WAND_CLASS, WEAPON_CLASS, ARMOR_CLASS, 0 };
X  
X  /* cancel obj, possibly carried by you or a monster */
X  static void
X  cancel_item(obj)
X--- 268,302 ----
X  	return mtmp;
X  }
X  
X! static NEARDATA const char charged_objs[] = { WAND_CLASS, WEAPON_CLASS, ARMOR_CLASS, 0 };
X  
X+ static void
X+ costly_cancel(obj)
X+ register struct obj *obj;
X+ {
X+ 	register struct monst *shkp = (struct monst *)0;
X+ 
X+ 	if (carried(obj)) {
X+ 		if (obj->unpaid) {
X+ 	            shkp = shop_keeper(*in_rooms(u.ux, u.uy, SHOPBASE));
X+ 		    if (!shkp) return;
X+ 		    Norep("You cancel an unpaid object, you pay for it!");
X+ 		    bill_dummy_object(obj);
X+ 		}
X+ 	} else {
X+ 	        shkp = shop_keeper(*in_rooms(obj->ox, obj->oy, SHOPBASE));
X+ 		if (!shkp || !inhishop(shkp)) return;
X+ 		if (!costly_spot(obj->ox, obj->oy)) return;
X+ 		if (costly_spot(u.ux, u.uy) && 
X+ 				*in_rooms(u.ux, u.uy, 0) ==
X+ 					*in_rooms(shkp->mx, shkp->my, 0)) {
X+ 		    Norep("You cancel it, you pay for it!");
X+ 		    bill_dummy_object(obj);
X+ 		} else
X+ 		    (void) stolen_value(obj, obj->ox, obj->oy, FALSE, FALSE);
X+ 	}
X+ }
X+ 
X  /* cancel obj, possibly carried by you or a monster */
X  static void
X  cancel_item(obj)
X***************
X*** 275,280 ****
X--- 303,310 ----
X  register struct obj *obj;
X  {
X  	boolean	u_ring = (obj == uleft) || (obj == uright);
X+ 	register boolean unpaid = (carried(obj) && obj->unpaid);
X+ 	register boolean holy = (obj->otyp == POT_WATER && obj->blessed);
X  
X  	switch(obj->otyp) {
X  		case RIN_GAIN_STRENGTH:
X***************
X*** 320,360 ****
X  	    obj->otyp == SLIME_MOLD ||
X  #endif
X  	    obj->otyp == SKELETON_KEY ||
X! 	    obj->otyp == LARGE_BOX || obj->otyp == CHEST))
X  		obj->spe = (obj->oclass == WAND_CLASS) ? -1 : 0;
X! 
X! 	if (obj->otyp == OIL_LAMP || obj->otyp == BRASS_LANTERN
X! 	    || Is_candle(obj) || obj->otyp == CANDELABRUM_OF_INVOCATION) {
X! 
X! 	    /* reducing a candle's age to 0 is */
X! 	    /* the same as destroying it.      */
X! 	    if (!Is_candle(obj)) obj->age = 0;
X! 
X! 	    /* reducing a candelabrum age to 0 */
X! 	    /* is the same as de-candling it.  */
X! 	    if(obj->otyp == CANDELABRUM_OF_INVOCATION) obj->spe = 0;
X! 
X! 	    obj->lamplit = 0;
X! 	    check_lamps();
X! 	}
X! 
X  	if (obj->oclass == SCROLL_CLASS
X  #ifdef MAIL
X  	    && obj->otyp != SCR_MAIL
X  #endif
X! 	   )
X  	    obj->otyp = SCR_BLANK_PAPER;
X! 
X! 	if (obj->oclass == SPBOOK_CLASS && obj->otyp != SPE_BOOK_OF_THE_DEAD)
X  	    obj->otyp = SPE_BLANK_PAPER;
X! 
X! 	if (obj->oclass == POTION_CLASS && obj->otyp != POT_BOOZE)
X! 	    obj->otyp = (obj->otyp==POT_SICKNESS || obj->otyp==POT_SEE_INVISIBLE || obj->otyp==POT_FRUIT_JUICE) ? POT_FRUIT_JUICE : POT_WATER;
X  	    /* sickness is "biologically contaminated" fruit juice; cancel it
X  	     * and it just becomes fruit juice... whereas see invisible
X  	     * tastes like "enchanted" fruit juice, it similarly cancels.
X  	     */
X  	unbless(obj);
X  	uncurse(obj);
X  }
X  
X--- 350,401 ----
X  	    obj->otyp == SLIME_MOLD ||
X  #endif
X  	    obj->otyp == SKELETON_KEY ||
X! 	    obj->otyp == LARGE_BOX || obj->otyp == CHEST ||
X! 	    obj->otyp == OIL_LAMP || obj->otyp == BRASS_LANTERN ||
X! 	    Is_candle(obj) || obj->otyp == CANDELABRUM_OF_INVOCATION)) {
X! 	        costly_cancel(obj);
X  		obj->spe = (obj->oclass == WAND_CLASS) ? -1 : 0;
X! 		if (unpaid) addtobill(obj, TRUE, FALSE, TRUE);
X! 	    }
X  	if (obj->oclass == SCROLL_CLASS
X+ 	    && obj->otyp != SCR_BLANK_PAPER
X  #ifdef MAIL
X  	    && obj->otyp != SCR_MAIL
X  #endif
X! 	   ) {
X! 	    costly_cancel(obj);
X  	    obj->otyp = SCR_BLANK_PAPER;
X! 	    if (unpaid) addtobill(obj, TRUE, FALSE, TRUE);
X!         }
X! 	if (obj->oclass == SPBOOK_CLASS &&
X! 	                   obj->otyp != SPE_BOOK_OF_THE_DEAD &&
X! 	                   obj->otyp != SPE_BLANK_PAPER) {
X! 	    costly_cancel(obj);
X  	    obj->otyp = SPE_BLANK_PAPER;
X! 	    if (unpaid) addtobill(obj, TRUE, FALSE, TRUE);
X! 	}
X! 	if (obj->oclass == POTION_CLASS && obj->otyp != POT_BOOZE) {
X! 	    if (obj->otyp==POT_SICKNESS ||
X! 	                 obj->otyp==POT_SEE_INVISIBLE) {
X! 	            costly_cancel(obj);
X! 	            obj->otyp = POT_FRUIT_JUICE;
X! 		    if (unpaid) addtobill(obj, TRUE, FALSE, TRUE);
X! 	    } else {
X! 	            if (obj->otyp != POT_FRUIT_JUICE &&
X! 			                     obj->otyp != POT_WATER) {
X! 		        costly_cancel(obj);
X! 	                obj->otyp = POT_WATER;
X! 			if (unpaid) addtobill(obj, TRUE, FALSE, TRUE);
X! 		    }
X! 	    }
X  	    /* sickness is "biologically contaminated" fruit juice; cancel it
X  	     * and it just becomes fruit juice... whereas see invisible
X  	     * tastes like "enchanted" fruit juice, it similarly cancels.
X  	     */
X+ 	}
X+ 	if (holy) costly_cancel(obj);
X  	unbless(obj);
X+ 	if (unpaid && holy) addtobill(obj, TRUE, FALSE, TRUE);
X  	uncurse(obj);
X  }
X  
X***************
X*** 434,439 ****
X--- 475,481 ----
X  {
X  	struct permonst *mdat = (struct permonst *)0;
X  	struct monst *mtmp;
X+ 	char *material;
X  	int pm_index;
X  
X  	/* no golems if you zap only one object -- not enough stuff */
X***************
X*** 445,450 ****
X--- 487,493 ----
X  	case METAL:
X  	case MITHRIL:
X  	    pm_index = PM_IRON_GOLEM;
X+ 	    material = "metal ";
X  	    break;
X  	case COPPER:
X  	case SILVER:
X***************
X*** 454,476 ****
X--- 497,525 ----
X  	case GLASS:
X  	case MINERAL:
X  	    pm_index = rn2(2) ? PM_STONE_GOLEM : PM_CLAY_GOLEM;
X+ 	    material = "lithic ";
X  	    break;
X  	case 0:
X  	    /* there is no flesh type, but all food is type 0, so we use it */
X  	    pm_index = PM_FLESH_GOLEM;
X+ 	    material = "organic ";
X  	    break;
X  	case WOOD:
X  	    pm_index = PM_WOOD_GOLEM;
X+ 	    material = "wood ";
X  	    break;
X  	case LEATHER:
X  	    pm_index = PM_LEATHER_GOLEM;
X+ 	    material = "leather ";
X  	    break;
X  	case CLOTH:
X  	    pm_index = PM_ROPE_GOLEM;
X+ 	    material = "cloth ";
X  	    break;
X  	default:
X  	    /* if all else fails... */
X  	    pm_index = PM_STRAW_GOLEM;
X+ 	    material = "";
X  	    break;
X  	}
X  
X***************
X*** 481,488 ****
X  	polyuse(obj, poly_zapped, (int)mons[pm_index].cwt);
X  
X  	if(!Blind && mtmp) {
X! 	    pline("Some objects in the pile merge.");
X! 	    pline("%s rises from the pile!", Amonnam(mtmp));
X  	}
X  }
X  
X--- 530,537 ----
X  	polyuse(obj, poly_zapped, (int)mons[pm_index].cwt);
X  
X  	if(!Blind && mtmp) {
X! 	    pline("Some %sobjects meld, and %s arises from the pile!",
X! 		  material, a_monnam(mtmp));
X  	}
X  }
X  
X***************
X*** 580,585 ****
X--- 629,638 ----
X  		otmp2->oeroded = obj->oeroded;
X  		otmp2->oerodeproof = obj->oerodeproof;
X  
X+ 		/* reduce spellbook abuse */
X+ 		if (obj->oclass == SPBOOK_CLASS)
X+ 		    otmp2->spestudied = obj->spestudied + 1;
X+ 
X  		/* Keep chest/box traps and poisoned ammo if we may */
X  		if (obj->otrapped && Is_box(otmp2))
X  			otmp2->otrapped = TRUE;
X***************
X*** 744,750 ****
X  	if(wand->spe < 0 || (wand->spe == 0 && rn2(121)))
X  		return 0;
X  	if(wand->spe == 0)
X! 		You("wrest one more spell from the worn-out wand.");
X  	wand->spe--;
X  	return 1;
X  }
X--- 797,803 ----
X  	if(wand->spe < 0 || (wand->spe == 0 && rn2(121)))
X  		return 0;
X  	if(wand->spe == 0)
X! 		You("wrest one last charge from the worn-out wand.");
X  	wand->spe--;
X  	return 1;
X  }
X***************
X*** 798,804 ****
X  	useup(otmp);
X  }
X  
X! static const char NEARDATA zap_syms[] = { WAND_CLASS, 0 };
X  
X  int
X  dozap()
X--- 851,857 ----
X  	useup(otmp);
X  }
X  
X! static NEARDATA const char zap_syms[] = { WAND_CLASS, 0 };
X  
X  int
X  dozap()
X***************
X*** 830,837 ****
X  		weffects(obj);
X  	}
X  	if (obj->spe < 0) {
X! 	    pline ("%s %sturns to dust.",
X! 		   The(xname(obj)), Blind ? "" : "glows violently, then ");
X  	    useup(obj);
X  	}
X  	return(1);
X--- 883,889 ----
X  		weffects(obj);
X  	}
X  	if (obj->spe < 0) {
X! 	    pline("%s turns to dust.", The(xname(obj)));
X  	    useup(obj);
X  	}
X  	return(1);
X***************
X*** 850,856 ****
X  			shieldeff(u.ux, u.uy);
X  			pline("Boing!");
X  		    } else {
X! 			You("magically bash yourself!");
X  			damage=d(8,6);
X  			exercise(A_STR, FALSE);
X  		    }
X--- 902,908 ----
X  			shieldeff(u.ux, u.uy);
X  			pline("Boing!");
X  		    } else {
X! 			You("bash yourself!");
X  			damage=d(8,6);
X  			exercise(A_STR, FALSE);
X  		    }
X***************
X*** 859,865 ****
X  		case WAN_LIGHTNING:
X  		    makeknown(WAN_LIGHTNING);
X  		    if (!Shock_resistance) {
X! 			pline("Idiot!  You've shocked yourself!");
X  			damage = d(12,6);
X  			exercise(A_CON, FALSE);
X  		    } else {
X--- 911,917 ----
X  		case WAN_LIGHTNING:
X  		    makeknown(WAN_LIGHTNING);
X  		    if (!Shock_resistance) {
X! 			You("shock yourself!");
X  			damage = d(12,6);
X  			exercise(A_CON, FALSE);
X  		    } else {
X***************
X*** 883,892 ****
X  		case WAN_FIRE:
X  		    makeknown(WAN_FIRE);
X  		case FIRE_HORN:
X! 		    pline("You've set light to yourself!");
X  		    if (Fire_resistance) {
X  			shieldeff(u.ux, u.uy);
X! 			You("feel mildly hot.");
X  #ifdef POLYSELF
X  			ugolemeffects(AD_FIRE, d(12,6));
X  #endif
X--- 935,944 ----
X  		case WAN_FIRE:
X  		    makeknown(WAN_FIRE);
X  		case FIRE_HORN:
X! 		    pline("You've set yourself afire!");
X  		    if (Fire_resistance) {
X  			shieldeff(u.ux, u.uy);
X! 			You("feel rather warm.");
X  #ifdef POLYSELF
X  			ugolemeffects(AD_FIRE, d(12,6));
X  #endif
X***************
X*** 902,908 ****
X  		case FROST_HORN:
X  		    if (Cold_resistance) {
X  			shieldeff(u.ux, u.uy);
X! 			You("feel mildly chilly.");
X  #ifdef POLYSELF
X  			ugolemeffects(AD_COLD, d(12,6));
X  #endif
X--- 954,960 ----
X  		case FROST_HORN:
X  		    if (Cold_resistance) {
X  			shieldeff(u.ux, u.uy);
X! 			You("feel a little chill.");
X  #ifdef POLYSELF
X  			ugolemeffects(AD_COLD, d(12,6));
X  #endif
X***************
X*** 1389,1394 ****
X--- 1441,1455 ----
X  			    break;
X  		    }
X  
X+ 		if (weapon == THROWN_WEAPON || weapon == KICKED_WEAPON) {
X+ 		    /* can't hit monsters/objects in rock w/solid weapons */
X+ 		    /* but beams/zaps _can_, so we need an extra pre-check */
X+ 		    if(!ZAP_POS(typ) || closed_door(bhitpos.x, bhitpos.y)) {
X+ 			bhitpos.x -= ddx;
X+ 			bhitpos.y -= ddy;
X+ 			break;
X+ 		    }
X+ 		}
X  		if ((mtmp = m_at(bhitpos.x, bhitpos.y)) != 0) {
X  			if(weapon != ZAPPED_WAND) {
X  				if(weapon != INVIS_BEAM) tmp_at(DISP_END, 0);
X***************
X*** 1495,1501 ****
X  				break;
X  			} else {	/* we catch it */
X  				tmp_at(DISP_END, 0);
X! 				pline("Skillfully, you catch the boomerang.");
X  				return(&youmonst);
X  			}
X  		}
X--- 1556,1562 ----
X  				break;
X  			} else {	/* we catch it */
X  				tmp_at(DISP_END, 0);
X! 				pline("You skillfully catch the boomerang.");
X  				return(&youmonst);
X  			}
X  		}
X***************
X*** 1634,1640 ****
X  	    /* Bug fix - KAA */
X  	    if(obj->oclass == SCROLL_CLASS
X  			|| obj->oclass == SPBOOK_CLASS) {
X! 		if (obj->otyp == SCR_FIRE || obj->otyp == SPE_FIREBALL)
X  		    continue;
X  		scrquan = obj->quan;
X  		for(i = 1; i <= scrquan ; i++)
X--- 1695,1703 ----
X  	    /* Bug fix - KAA */
X  	    if(obj->oclass == SCROLL_CLASS
X  			|| obj->oclass == SPBOOK_CLASS) {
X! 		if (obj->otyp == SCR_FIRE || obj->otyp == SPE_FIREBALL
X! 			|| obj->otyp == SPE_BOOK_OF_THE_DEAD
X! 		        || obj->oartifact)
X  		    continue;
X  		scrquan = obj->quan;
X  		for(i = 1; i <= scrquan ; i++)
X***************
X*** 1711,1719 ****
X  	    if (type >= 0) mon->data->mflags3 &= ~M3_WAITMASK;
X  	    if (rnd(20) < 18 + find_mac(mon)) {
X  #ifdef MUSE
X! 		struct obj *oshld = which_armor(mon, W_ARMS);
X  
X! 		if (oshld && oshld->otyp == SHIELD_OF_REFLECTION) {
X  		    if(cansee(mon->mx,mon->my)) {
X  			hit(fltxt, mon, exclam(0));
X  			pline("But it reflects from %s shield!",
X--- 1774,1782 ----
X  	    if (type >= 0) mon->data->mflags3 &= ~M3_WAITMASK;
X  	    if (rnd(20) < 18 + find_mac(mon)) {
X  #ifdef MUSE
X! 		struct obj *orefl = which_armor(mon, W_ARMS);
X  
X! 		if (orefl && orefl->otyp == SHIELD_OF_REFLECTION) {
X  		    if(cansee(mon->mx,mon->my)) {
X  			hit(fltxt, mon, exclam(0));
X  			pline("But it reflects from %s shield!",
X***************
X*** 1724,1729 ****
X--- 1787,1804 ----
X  
X  		    dx = -dx;
X  		    dy = -dy;
X+ 		} else if ((orefl = which_armor(mon, W_AMUL)) &&
X+ 					orefl->otyp == AMULET_OF_REFLECTION) {
X+ 		    if(cansee(mon->mx,mon->my)) {
X+ 			hit(fltxt, mon, exclam(0));
X+ 			pline("But it reflects from %s amulet!",
X+ 			      s_suffix(mon_nam(mon)));
X+ 			makeknown(AMULET_OF_REFLECTION);
X+ 			shieldeff(sx, sy);
X+ 		    }
X+ 
X+ 		    dx = -dx;
X+ 		    dy = -dy;
X  		} else
X  #endif
X  		{
X***************
X*** 1734,1743 ****
X  			    hit(fltxt, mon, exclam(tmp));
X  			    pline("%s disintegrates.", Monnam(mon));
X  			    if(Blind)
X! 		       You("sense the fragments of %s body reassembling!",
X  			         s_suffix(mon_nam(mon)));
X  			    else
X! 		       pline("%s body fragments reassemble before your %s!",
X  			         s_suffix(Monnam(mon)),
X  			         makeplural(body_part(EYE)));
X  		            pline("%s resurrects!", Monnam(mon));
X--- 1809,1818 ----
X  			    hit(fltxt, mon, exclam(tmp));
X  			    pline("%s disintegrates.", Monnam(mon));
X  			    if(Blind)
X! 		       You("hear the fragments of %s body reassembling!",
X  			         s_suffix(mon_nam(mon)));
X  			    else
X! 		       pline("%s body reintegrates before your %s!",
X  			         s_suffix(Monnam(mon)),
X  			         makeplural(body_part(EYE)));
X  		            pline("%s resurrects!", Monnam(mon));
X***************
X*** 1969,1975 ****
X  	    }
X  	    bounce = 0;
X  	    range--;
X! 	    if(range && cansee(lsx,lsy))
X  		pline("%s bounces!", The(fltxt));
X  	    if(!dx || !dy || !rn2(20)) {
X  		dx = -dx;
X--- 2044,2050 ----
X  	    }
X  	    bounce = 0;
X  	    range--;
X! 	    if(range && isok(lsx, lsy) && cansee(lsx,lsy))
X  		pline("%s bounces!", The(fltxt));
X  	    if(!dx || !dy || !rn2(20)) {
X  		dx = -dx;
X***************
X*** 2037,2043 ****
X  		if (x == u.ux && y == u.uy)
X  			spoteffects();	/* possibly drown */
X  	    } else if(is_pool(x,y)) {
X! 		const char *msgtxt = "You hear a hissing sound.";
X  		if(lev->typ != POOL) {	/* MOAT or DRAWBRIDGE_UP */
X  		    if (cansee(x,y)) msgtxt = "Some water evaporates.";
X  		} else {
X--- 2112,2118 ----
X  		if (x == u.ux && y == u.uy)
X  			spoteffects();	/* possibly drown */
X  	    } else if(is_pool(x,y)) {
X! 		const char *msgtxt = "You hear hissing gas.";
X  		if(lev->typ != POOL) {	/* MOAT or DRAWBRIDGE_UP */
X  		    if (cansee(x,y)) msgtxt = "Some water evaporates.";
X  		} else {
X***************
X*** 2065,2071 ****
X  		    if (cansee(x,y))
X  			pline("The water freezes for a moment.");
X  		    else
X! 			You("hear a soft crackling sound");
X  		    rangemod -= 1000;	/* stop */
X  		} else {
X  		    rangemod -= 3;
X--- 2140,2146 ----
X  		    if (cansee(x,y))
X  			pline("The water freezes for a moment.");
X  		    else
X! 			You("hear a soft crackling.");
X  		    rangemod -= 1000;	/* stop */
X  		} else {
X  		    rangemod -= 3;
X***************
X*** 2155,2161 ****
X  			newsym(x,y);
X  		    }
X  		    else if(flags.soundok)
X! 			You("hear a crashing sound.");
X  		    break;
X  		case ZT_LIGHTNING:
X  		    if(type >= 0 && *in_rooms(x, y, SHOPBASE)) {
X--- 2230,2236 ----
X  			newsym(x,y);
X  		    }
X  		    else if(flags.soundok)
X! 			You("hear crashing wood.");
X  		    break;
X  		case ZT_LIGHTNING:
X  		    if(type >= 0 && *in_rooms(x, y, SHOPBASE)) {
X***************
X*** 2169,2175 ****
X  			newsym(x,y);
X  		    }
X  		    else if(flags.soundok)
X! 			You("hear a crackling sound.");
X  		    break;
X  		default:
X  		def_case:
X--- 2244,2250 ----
X  			newsym(x,y);
X  		    }
X  		    else if(flags.soundok)
X! 			You("hear crackling.");
X  		    break;
X  		default:
X  		def_case:
X***************
X*** 2188,2193 ****
X--- 2263,2270 ----
X  		    newsym(x,y);
X  		    if(!Blind)
X  			You("see a puff of smoke.");
X+ 		    else
X+ 			You("smell a whiff of smoke.");
X  		}
X  	if ((mon = m_at(x,y)) != 0) {
X  		/* Cannot use wakeup() which also angers the monster */
X***************
X*** 2575,2585 ****
X  		/* The(aobjnam()) is safe since otmp is unidentified -dlc */
X  		(void) hold_another_object(otmp, u.uswallow ?
X  				       "Oops!  %s out of your reach!" :
X! 				       Is_airlevel(&u.uz) ?
X! 				       "Oops!  %s out of your grasp!" :
X  				       "Oops!  %s to the floor!",
X! 				       The(aobjnam(otmp, Is_airlevel(&u.uz) ?
X! 					       "slip" : "drop")),
X  				       (const char *)0);
X  	    u.ublesscnt += rn1(100,50);  /* the gods take notice */
X  	}
X--- 2652,2663 ----
X  		/* The(aobjnam()) is safe since otmp is unidentified -dlc */
X  		(void) hold_another_object(otmp, u.uswallow ?
X  				       "Oops!  %s out of your reach!" :
X! 				       Is_airlevel(&u.uz) || u.uinwater ?
X! 				       "Oops!  %s away from you!" :
X  				       "Oops!  %s to the floor!",
X! 				       The(aobjnam(otmp,
X! 					     Is_airlevel(&u.uz) || u.uinwater ?
X! 						   "slip" : "drop")),
X  				       (const char *)0);
X  	    u.ublesscnt += rn1(100,50);  /* the gods take notice */
X  	}
X*** /tmp/da07061	Thu Feb 25 10:18:06 1993
X--- ./Files	Wed Feb 24 16:13:40 1993
X***************
X*** 4,9 ****
X--- 4,10 ----
X  from or not transferred to your system if you wish.
X  
X  
X+ .:
X  (files in top directory)
X  Files           Porting         README
X  
X***************
X*** 30,42 ****
X  engrave.h       epri.h          eshk.h          extern.h        flag.h
X  func_tab.h      global.h        hack.h          lev.h           macconf.h
X  mail.h          mfndpos.h       micro.h         mkroom.h        monattk.h
X! mondata.h       monflag.h       monst.h         monsym.h        obj.h
X! objclass.h      os2conf.h       patchlevel.h    pcconf.h        permonst.h
X! prop.h          qtext.h         quest.h         rect.h          rm.h
X! sp_lev.h        spell.h         system.h        termcap.h       tosconf.h
X! tradstdc.h      trampoli.h      trap.h          unixconf.h      vault.h
X! vision.h        vmsconf.h       winami.h        winprocs.h      wintype.h
X! you.h           youprop.h
X  (file for tty versions)
X  wintty.h
X  (files for X versions)
X--- 31,43 ----
X  engrave.h       epri.h          eshk.h          extern.h        flag.h
X  func_tab.h      global.h        hack.h          lev.h           macconf.h
X  mail.h          mfndpos.h       micro.h         mkroom.h        monattk.h
X! mondata.h       monflag.h       monst.h         monsym.h        ntconf.h
X! obj.h           objclass.h      os2conf.h       patchlevel.h    pcconf.h
X! permonst.h      prop.h          qtext.h         quest.h         rect.h
X! rm.h            sp_lev.h        spell.h         system.h        termcap.h
X! tosconf.h       tradstdc.h      trampoli.h      trap.h          unixconf.h
X! vault.h         vision.h        vmsconf.h       winami.h        winprocs.h
X! wintype.h       you.h           youprop.h
X  (file for tty versions)
X  wintty.h
X  (files for X versions)
X***************
X*** 69,80 ****
X  (files for Amiga version)
X  HackWB.uu       Install.ami     Makefile.ami    NHinfo.uu       NetHack.cnf
X  NewGame.uu      amidos.c        amidos.p        amifont.uu      amifont8.uu
X! amigst.c        amii.hlp        amimenu.c       amirip.c        amiwbench.c
X! amiwind.c       amiwind.p       ask.uu          char.c          charwin.uu
X! colors.uu       colorwin.c      dflticon.uu     hackwb.hlp      ifchange
X! randwin.c       randwin.uu      scroll.uu       string.uu       wb.c
X! wbcli.c         wbdata.c        wbdefs.h        wbprotos.h      wbstruct.h
X! wbwin.c         wbwin.uu        winami.c        winami.p
X  
X  sys/amiga/splitter:
X  (more files for Amiga version)
X--- 70,82 ----
X  (files for Amiga version)
X  HackWB.uu       Install.ami     Makefile.ami    NHinfo.uu       NetHack.cnf
X  NewGame.uu      amidos.c        amidos.p        amifont.uu      amifont8.uu
X! amigst.c        amii.hlp        amimenu.c       amirip.c        amisnd.c
X! amiwbench.c     amiwind.c       amiwind.p       ask.uu          char.c
X! charwin.uu      colors.uu       colorwin.c      cvtsnd.c        dflticon.uu
X! hackwb.hlp      ifchange        randwin.c       randwin.uu      scroll.uu
X! string.uu       wb.c            wbcli.c         wbdata.c        wbdefs.h
X! wbprotos.h      wbstruct.h      wbwin.c         wbwin.uu        winami.c
X! winami.p
X  
X  sys/amiga/splitter:
X  (more files for Amiga version)
X***************
X*** 94,100 ****
X  macwin.c        mgetline.c      mhdump.c        mmodal.c        mstring.c
X  
X  sys/msdos:
X! (files for MSDOS versions)
X  Install.dos     MakeGCC.src     MakeGCC.utl     MakeMSC.src     MakeMSC.utl
X  Makefile.dat    exesmurf.c      exesmurf.doc    maintovl.doc    msdos.c
X  ovlmgr.asm      ovlmgr.doc      ovlmgr.uu       setup.bat       trampoli.c
X--- 96,102 ----
X  macwin.c        mgetline.c      mhdump.c        mmodal.c        mstring.c
X  
X  sys/msdos:
X! (files for MSDOS version)
X  Install.dos     MakeGCC.src     MakeGCC.utl     MakeMSC.src     MakeMSC.utl
X  Makefile.dat    exesmurf.c      exesmurf.doc    maintovl.doc    msdos.c
X  ovlmgr.asm      ovlmgr.doc      ovlmgr.uu       setup.bat       trampoli.c
X***************
X*** 108,125 ****
X  sys/share:
X  (files for MSDOS and OS/2 versions)
X  Makefile.lib    NetHack.cnf     termcap.uu
X! (file for MSDOS, OS/2, Amiga, and Atari versions)
X  pcmain.c
X! (files for MSDOS, OS/2 and Atari versions)
X! pcsys.c         pctty.c         pcunix.c
X  (Berkeley random number file, which may be included in any version)
X  random.c
X! (file for MSDOS, OS/2 and VMS versions)
X  termcap
X  (lex/yacc output for special level and dungeon compilers)
X  dgn_comp.h      dgn_lex.c       dgn_yacc.c      lev_comp.h      lev_lex.c
X  lev_yacc.c
X  
X  sys/unix:
X  (files for UNIX versions)
X  Install.unx     Makefile.dat    Makefile.doc    Makefile.src    Makefile.top
X--- 110,135 ----
X  sys/share:
X  (files for MSDOS and OS/2 versions)
X  Makefile.lib    NetHack.cnf     termcap.uu
X! (file for MSDOS, OS/2, NT, Amiga, and Atari versions)
X  pcmain.c
X! (files for MSDOS, OS/2, NT, and Atari versions)
X! pcsys.c         pcunix.c
X! (file for MSDOS, OS/2, and Atari versions)
X! pctty.c
X  (Berkeley random number file, which may be included in any version)
X  random.c
X! (file for MSDOS, OS/2, and VMS versions)
X  termcap
X  (lex/yacc output for special level and dungeon compilers)
X  dgn_comp.h      dgn_lex.c       dgn_yacc.c      lev_comp.h      lev_lex.c
X  lev_yacc.c
X  
X+ sys/share/sounds:
X+ (files for Amiga and Macintosh versions)
X+ README          bell.uu         bugle.uu        erthdrum.uu     firehorn.uu
X+ frsthorn.uu     lethdrum.uu     mgcflute.uu     mgcharp.uu      toolhorn.uu
X+ wdnflute.uu     wdnharp.uu
X+ 
X  sys/unix:
X  (files for UNIX versions)
X  Install.unx     Makefile.dat    Makefile.doc    Makefile.src    Makefile.top
X***************
X*** 138,143 ****
X--- 148,158 ----
X  vmsmisc.c       vmstty.c        vmsunix.c
X  (GNU termcap files that support VMS version)
X  gnutermcap.c    gnutparam.c
X+ 
X+ sys/winnt:
X+ (files for Windows NT version)
X+ Install.nt      Makefile.dat    Makefile.src    Makefile.utl    nhico.uu
X+ nhincl.mak      nttty.c         setup.bat       winnt.c
X  
X  util:
X  (files for all versions)
X
X*** /tmp/da07077	Thu Feb 25 10:18:10 1993
X--- ./README	Wed Feb 24 09:37:43 1993
X***************
X*** 70,88 ****
X      f.  A 'sys' directory, which contains subdirectories for files that
X          are operating-system specific.
X      g.  A 'sys/share' subdirectory, which contains files shared by some OSs.
X!     h.  A 'sys/amiga' subdirectory, which contains files specific to AmigaDOS.
X!     i.  A 'sys/amiga/splitter' subsubdirectory, which contains files
X          for the Amiga splitter program.
X!     j.  A 'sys/atari' subdirectory, which contains files specific to TOS.
X!     k.  A 'sys/mac' subdirectory, which contains files specific to MacOS.
X!     l.  A 'sys/msdos' subdirectory, which contains files specific to MS-DOS.
X!     m.  A 'sys/os2' subdirectory, which contains files specific to OS/2.
X!     n.  A 'sys/unix' subdirectory, which contains files specific to UNIX.
X!     o.  A 'sys/vms' subdirectory, which contains files specific to VMS.
X!     p.  A 'win' directory, which contains subdirectories for files that
X          are windowing-system specific (but not operating-system specific).
X!     q.  A 'win/tty' subdirectory, which contains files specific to ttys.
X!     r.  A 'win/X11' subdirectory, which contains files specific to X11.
X  
X      The names of these directories should not be changed, unless you are
X      ready to go through the makefiles and the makedefs program and change
X--- 70,91 ----
X      f.  A 'sys' directory, which contains subdirectories for files that
X          are operating-system specific.
X      g.  A 'sys/share' subdirectory, which contains files shared by some OSs.
X!     h.  A 'sys/share/sounds' subsubdirectory, which contains sound files
X!         shared by some OSs.
X!     i.  A 'sys/amiga' subdirectory, which contains files specific to AmigaDOS.
X!     j.  A 'sys/amiga/splitter' subsubdirectory, which contains files
X          for the Amiga splitter program.
X!     k.  A 'sys/atari' subdirectory, which contains files specific to TOS.
X!     l.  A 'sys/mac' subdirectory, which contains files specific to MacOS.
X!     m.  A 'sys/msdos' subdirectory, which contains files specific to MS-DOS.
X!     n.  A 'sys/os2' subdirectory, which contains files specific to OS/2.
X!     o.  A 'sys/unix' subdirectory, which contains files specific to UNIX.
X!     p.  A 'sys/vms' subdirectory, which contains files specific to VMS.
X!     q.  A 'sys/winnt' subdirectory, which contains files specific to Windows NT.
X!     r.  A 'win' directory, which contains subdirectories for files that
X          are windowing-system specific (but not operating-system specific).
X!     s.  A 'win/tty' subdirectory, which contains files specific to ttys.
X!     t.  A 'win/X11' subdirectory, which contains files specific to X11.
X  
X      The names of these directories should not be changed, unless you are
X      ready to go through the makefiles and the makedefs program and change
X*** /tmp/da09982	Thu Feb 25 21:12:44 1993
X--- sys/vms/Install.vms	Thu Feb 25 20:47:33 1993
X***************
X*** 1,4 ****
X!                Instructions for Installing NetHack 3.1.0
X                             on a VMS system
X                 =========================================
X  
X--- 1,4 ----
X!                Instructions for Installing NetHack 3.1.1
X                             on a VMS system
X                 =========================================
X  
X***************
X*** 143,148 ****
X--- 143,150 ----
X      NetHack 3.1.0.  Don't bother trying to keep them.  Ditto for RECORD,
X      the scoreboard file.  One minor change of note is that the default
X      name for a player's character is now a lowercase copy of the username.
X+     Scoreboard files from 3.1.0 are compatible with 3.1.1, but save files
X+     and bones files are not.
X  
X  2.  To specify user-preference options in your environment, define the
X      logical name NETHACKOPTIONS to have value of a quoted string
X***************
X*** 166,174 ****
X      file.  Otherwise, the following are tried:  file specified by logical
X      name NETHACKINI, file SYS$LOGIN:NETHACK.INI, and file HOME:NETHACK.CNF
X      (note that the C run-time library sets up the value of HOME to match
X!     sys$login).  Syntax for the configuration file is essentially the same
X!     as for NETHACKOPTIONS, but multiple lines can be used and comments can
X!     be included by placing '#' in the first column.
X  
X  3.  Instead of using vmsbuild.com to compile and link everything, you can
X      use the set of Makefiles found in the vms subdirectory, provided you
X--- 168,181 ----
X      file.  Otherwise, the following are tried:  file specified by logical
X      name NETHACKINI, file SYS$LOGIN:NETHACK.INI, and file HOME:NETHACK.CNF
X      (note that the C run-time library sets up the value of HOME to match
X!     sys$login).  Syntax for the configuration file is similar to
X!     NETHACKOPTIONS, but multiple lines can be used, each must start with
X!     OPTIONS=, and comments can be included by placing '#' in the first
X!     column.  Several options which take more complex values (graphics
X!     representation) can also be present; see the "Guidebook" for details.
X!     (Guidebook.txt can be found in the [.dat] subdirectory; a copy gets
X!     placed in the playground directory by install.com.  Also, an example
X!     configuration file can be found in [.win.X11]nethack.rc.)
X  
X  3.  Instead of using vmsbuild.com to compile and link everything, you can
X      use the set of Makefiles found in the vms subdirectory, provided you
X***************
X*** 306,312 ****
X      its potential security ramifications should even consider it.
X  
X      The default setup by install.com assumes no privileges and uses
X!     world-writeable files to allow arbitrary users to play.  This is
X      NOT secure and not advisable in any environment where there are
X      untrustworthy users, but works fine for many sites.  If you allow
X      users to run NetHack from captive accounts (VMS 5.1-* or earlier)
X--- 313,319 ----
X      its potential security ramifications should even consider it.
X  
X      The default setup by install.com assumes no privileges and uses
X!     world-writable files to allow arbitrary users to play.  This is
X      NOT secure and not advisable in any environment where there are
X      untrustworthy users, but works fine for many sites.  If you allow
X      users to run NetHack from captive accounts (VMS 5.1-* or earlier)
X***************
X*** 447,453 ****
X      the C run-time library's program startup code from converting it into
X      lowercase.  Any character name will be ignored in favor of "wizard".
X  
X! 14. Unless you have both Motif and the Athena Widget set from MIT, you
X      will not be able to use the X11 interface on VMS.  Even if you do
X      have both those things, such a configuration has not been tested and
X      there are no provisions for it in vmsbuild.com.  Makefile.src does
X--- 454,501 ----
X      the C run-time library's program startup code from converting it into
X      lowercase.  Any character name will be ignored in favor of "wizard".
X  
X! 14. At program startup time, NetHack uses the empty file PERM to prevent
X!     two different processes from using the same character name (under the
X!     same UIC ownership) at the same time.  It does this by temporarily
X!     giving that file a second directory entry named PERM.LOCK, then
X!     removing the alternate entry once started.  If the PERM file is
X!     missing or inaccessible, NetHack will give a message and then quit.
X!     Several possible messages and their usual causes are:
X!        Can't find file perm;1 to lock!
X!     PERM.;1 is missing from the playground directory.  Fix:  reinstall
X!     the playground directory using install.com, or use CREATE or an editor
X!     to make an empty file named PERM.  Version number must be 1.
X!        Can't lock perm;1 due to directory protection.
X!     The playground directory is not allowing write access.  Fix:  players
X!     need to be able to write files for dungeon levels and "bones" into
X!     the playground directory.  Set the protection or ACL on the xxx.DIR;1
X!     file in the playground's parent directory to allow write access.
X!        Can't unlink perm.lock;1.
X!     The empty file PERM.;1 is protected against delete access; only matters
X!     under some versions of VMS.  Fix:  set the protection or ACL on PERM.;1
X!     to allow delete access to players.  Under VMS V5.5-2, delete access is
X!     not necessary.  PERM does not have to remain writable.
X!        Waiting for access to perm;1.  (# retries left).
X!     If some other process is also starting up NetHack at about the same
X!     time, you may have to wait a short period.  NetHack will retry once
X!     per second, counting down to 0.  If 0 is reached, the message
X!        Perhaps there is an old perm.lock;1 around?
X!     will be displayed and then NetHack will give up.  Fix:  to forcibly
X!     remove a stale PERM.LOCK entry, issue the following command
X!        $ SET FILE/REMOVE PERM.LOCK;1
X!     from the playground directory.  The file PERM should remain intact.
X!     Do not use that command for real files, only alternate directory
X!     entries.  If output from a DIRECTORY command on the playground reports
X!        PERM.LOCK;1          no such file
X!     then someone has deleted PERM.;1 while the synonym entry was still
X!     in place, and PERM.LOCK was left as a dangling name which no longer
X!     points at any file.  The SET FILE/REMOVE command above will fix it.
X! 
X!     In similar fashion, synchronized access to the scoreboard file RECORD
X!     is accomplished using temporary entry RECORD.LOCK and LOGFILE using
X!     entry LOGFILE.LOCK.
X! 
X! 15. Unless you have both Motif and the Athena Widget set from MIT, you
X      will not be able to use the X11 interface on VMS.  Even if you do
X      have both those things, such a configuration has not been tested and
X      there are no provisions for it in vmsbuild.com.  Makefile.src does
X***************
X*** 473,483 ****
X      window manager in order for any changes to take effect; it's easiest
X      to just make the session manager quit and then log in again.
X  
X! 15. There is no support for VMS POSIX in this release of NetHack.
X  
X! 16. If necessary, send problem reports via e-mail to
X         "nethack-bugs@linc.cis.upenn.edu"  (numeric address 130.91.6.8).
X      Always include version information for NetHack, the operating system,
X      and the C compiler used.
X  
X! 23-JAN-1993
X--- 521,531 ----
X      window manager in order for any changes to take effect; it's easiest
X      to just make the session manager quit and then log in again.
X  
X! 16. There is no support for VMS POSIX in this release of NetHack.
X  
X! 17. If necessary, send problem reports via e-mail to
X         "nethack-bugs@linc.cis.upenn.edu"  (numeric address 130.91.6.8).
X      Always include version information for NetHack, the operating system,
X      and the C compiler used.
X  
X! 24-FEB-1993
X*** /tmp/da10006	Thu Feb 25 21:12:44 1993
X--- sys/vms/Makefile.src	Thu Feb 25 20:46:18 1993
X***************
X*** 90,96 ****
X  
X  # note: no trailing whitespace (or comment) after version or patchlevel numbers
X  VERSION  =3.1
X! PATCHLVL =0
X  
X  MAKEDEFS = $(UTL)makedefs.exe;
X  
X--- 90,96 ----
X  
X  # note: no trailing whitespace (or comment) after version or patchlevel numbers
X  VERSION  =3.1
X! PATCHLVL =1
X  
X  MAKEDEFS = $(UTL)makedefs.exe;
X  
X***************
X*** 213,219 ****
X  	$(CC) $(CFLAGS) objects.c
X       @- if f$search("$(MAKEDEFS)").nes."" then delete $(MAKEDEFS)
X  
X! $(MAKEDEFS) :	$(FIRSTOBJ) $(UTL)makedefs.c $(INC)patchlevel.h \
X  		$(INC)config.h $(INC)artilist.h $(INC)qtext.h  $(LIBOPT)
X  	$(CD) $(UTL)
X  	$(MAKE)$(MAKEFLAGS) $(MAKEDEFS)
X--- 213,219 ----
X  	$(CC) $(CFLAGS) objects.c
X       @- if f$search("$(MAKEDEFS)").nes."" then delete $(MAKEDEFS)
X  
X! $(MAKEDEFS) :	$(FIRSTOBJ) $(UTL)makedefs.c \
X  		$(INC)config.h $(INC)artilist.h $(INC)qtext.h  $(LIBOPT)
X  	$(CD) $(UTL)
X  	$(MAKE)$(MAKEFLAGS) $(MAKEDEFS)
X***************
X*** 273,279 ****
X  termcap.obj :	$(TTY)termcap.c $(INC)hack.h $(INC)wintty.h $(INC)termcap.h
X  topl.obj :	$(TTY)topl.c $(INC)hack.h $(INC)termcap.h $(INC)wintty.h
X  wintty.obj :	$(TTY)wintty.c $(INC)hack.h $(INC)termcap.h $(INC)wintty.h
X! Window.obj :	$(X11)Window.c $(INC)WindowP.h
X  dialogs.obj :	$(X11)dialogs.c $(INC)config.h
X  winX.obj :	$(X11)winX.c $(INC)hack.h $(INC)winX.h \
X  		$(X11)nh72icon $(X11)nh56icon $(X11)nh32icon
X--- 273,279 ----
X  termcap.obj :	$(TTY)termcap.c $(INC)hack.h $(INC)wintty.h $(INC)termcap.h
X  topl.obj :	$(TTY)topl.c $(INC)hack.h $(INC)termcap.h $(INC)wintty.h
X  wintty.obj :	$(TTY)wintty.c $(INC)hack.h $(INC)termcap.h $(INC)wintty.h
X! Window.obj :	$(X11)Window.c $(INC)WindowP.h $(INC)config.h
X  dialogs.obj :	$(X11)dialogs.c $(INC)config.h
X  winX.obj :	$(X11)winX.c $(INC)hack.h $(INC)winX.h \
X  		$(X11)nh72icon $(X11)nh56icon $(X11)nh32icon
X***************
X*** 421,428 ****
X  $(INC)eshk.h :	$(INC)dungeon.h
X  			$(TOUCH) $(INC)eshk.h
X  # ignore the non-VMS configuration headers
X! #$(INC)global.h :  $(INC)coord.h $(INC)vmsconf.h $(INC)unixconf.h $(INC)os2conf.h \
X! #		   $(INC)pcconf.h $(INC)tosconf.h $(INC)amiconf.h $(INC)macconf.h
X  $(INC)global.h :  $(INC)coord.h $(INC)vmsconf.h
X  			$(TOUCH) $(INC)global.h
X  $(INC)hack.h :	$(INC)config.h $(INC)dungeon.h $(INC)monsym.h $(INC)mkroom.h \
X--- 421,429 ----
X  $(INC)eshk.h :	$(INC)dungeon.h
X  			$(TOUCH) $(INC)eshk.h
X  # ignore the non-VMS configuration headers
X! #$(INC)global.h :  $(INC)coord.h $(INC)vmsconf.h $(INC)unixconf.h \
X! #		   $(INC)os2conf.h $(INC)pcconf.h $(INC)tosconf.h \
X! #		   $(INC)amiconf.h $(INC)macconf.h $(INC)ntconf.h
X  $(INC)global.h :  $(INC)coord.h $(INC)vmsconf.h
X  			$(TOUCH) $(INC)global.h
X  $(INC)hack.h :	$(INC)config.h $(INC)dungeon.h $(INC)monsym.h $(INC)mkroom.h \
X*** /tmp/da10022	Thu Feb 25 10:31:59 1993
X--- sys/vms/Makefile.utl	Wed Feb 24 09:37:38 1993
X***************
X*** 133,141 ****
X  	$(LINK) $(LFLAGS) $(MAKEOBJS),$(VMSMAKEOBJS),$(LIBS)
X  
X  makedefs.obj :	$(INC)config.h $(INC)permonst.h $(INC)objclass.h \
X! 		$(INC)monsym.h $(INC)artilist.h $(INC)qtext.h \
X! 		$(INC)patchlevel.h
X! 	$(CC) $(CFLAGS) makedefs.c
X  
X  $(INC)onames.h	: $(MAKEDEFS)
X  	$(RUN) $(MAKEDEFS) -o
X--- 133,139 ----
X  	$(LINK) $(LFLAGS) $(MAKEOBJS),$(VMSMAKEOBJS),$(LIBS)
X  
X  makedefs.obj :	$(INC)config.h $(INC)permonst.h $(INC)objclass.h \
X! 		$(INC)monsym.h $(INC)artilist.h $(INC)qtext.h
X  
X  $(INC)onames.h	: $(MAKEDEFS)
X  	$(RUN) $(MAKEDEFS) -o
X*** /tmp/da10054	Thu Feb 25 10:32:06 1993
X--- sys/vms/lev_lex.h	Sun Feb 21 16:29:50 1993
X***************
X*** 1,4 ****
X! /*       SCCS Id: @(#)lev_lex.h 3.1     92/01/10        */
X  /* "vms/lev_lex.h" copied into "util/stdio.h" for use by lev_lex.c only!
X   * This is an awful kludge to allow util/lev_lex.c to be compiled as is.
X   * It works because the actual setup of yyin & yyout is performed in
X--- 1,4 ----
X! /*	SCCS Id: @(#)lev_lex.h	3.1	93/02/07	*/
X  /* "vms/lev_lex.h" copied into "util/stdio.h" for use by lev_lex.c only!
X   * This is an awful kludge to allow util/lev_lex.c to be compiled as is.
X   * It works because the actual setup of yyin & yyout is performed in
X***************
X*** 5,16 ****
X   * src/lev_main.c, where stdin & stdout are still correctly defined.
X   */
X  /* note for 3.1: also used with util/dgn_lex.c */
X- 
X- #ifdef __GNUC__
X- # ifndef CONST_OK
X- #  define const
X- # endif
X- #endif
X  
X  #include <stdio.h>
X  #ifdef stdin
X--- 5,10 ----
END_OF_FILE
if test 55621 -ne `wc -c <'patches01j'`; then
    echo shar: \"'patches01j'\" unpacked with wrong size!
fi
# end of 'patches01j'
echo shar: End of archive 5 \(of 31\).
cp /dev/null ark5isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 31 archives.
    echo "Now execute 'patchit.sh'"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
