Subject:  v17i049:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Patch1h/31
Newsgroups: comp.sources.games
Approved: billr@saab.CNA.TEK.COM

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 17, Issue 49
Archive-name: nethack31/Patch1h
Patch-To: nethack31: Volume 16, Issue 1-116
Environment: Amiga, Atari, Mac, MS-DOS, Windows-NT, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 8 (of 31)."
# Contents:  patches01i sys/amiga/hackwb.hlp
# Wrapped by billr@saab on Fri Mar  5 10:50:43 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'patches01i' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'patches01i'\" to \"'patches01i.orig'\"
  mv -f 'patches01i' 'patches01i.orig'
fi
echo shar: Extracting \"'patches01i'\" \(54136 characters\)
sed "s/^X//" >'patches01i' <<'END_OF_FILE'
X*** /tmp/da08606	Thu Feb 25 10:25:21 1993
X--- src/sounds.c	Thu Feb 18 10:59:37 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)sounds.c	3.1	92/07/07
X  /* 	Copyright (c) 1989 Janet Walz, Mike Threepoint */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)sounds.c	3.1	93/02/09
X  /* 	Copyright (c) 1989 Janet Walz, Mike Threepoint */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 64,74 ****
X  		You("hear the tones of courtly conversation.");
X  		break;
X  	    case 1:
X! 		You("hear a sceptre being pounded in judgment.");
X  		break;
X  	    case 2:
X! 		pline("Someone just shouted \"Off with %s head!\"",
X! 		    flags.female ? "her" : "his");
X  		break;
X  	    case 3:
X  		You("hear Queen Beruthiel's cats!");
X--- 64,74 ----
X  		You("hear the tones of courtly conversation.");
X  		break;
X  	    case 1:
X! 		You("hear a sceptre pounded in judgment.");
X  		break;
X  	    case 2:
X! 		pline("Someone shouts \"Off with %s head!\"",
X! 		      his[flags.female]);
X  		break;
X  	    case 3:
X  		You("hear Queen Beruthiel's cats!");
X***************
X*** 186,195 ****
X      if (level.flags.has_zoo && !rn2(200)) {
X  	switch (rn2(2)+hallu) {
X  	    case 0:
X! 	You("hear a sound reminding you of an elephant stepping on a peanut.");
X  		break;
X  	    case 1:
X! 		You("hear a sound reminding you of a trained seal.");
X  		break;
X  	    case 2:
X  		You("hear Doctor Doolittle!");
X--- 186,195 ----
X      if (level.flags.has_zoo && !rn2(200)) {
X  	switch (rn2(2)+hallu) {
X  	    case 0:
X! 		You("hear a sound reminiscent of an elephant stepping on a peanut.");
X  		break;
X  	    case 1:
X! 		You("hear a sound reminiscent of a seal barking.");
X  		break;
X  	    case 2:
X  		You("hear Doctor Doolittle!");
X***************
X*** 421,427 ****
X  #endif
X  	case MS_BONES:
X  	    pline("%s rattles noisily.", Monnam(mtmp));
X! 	    You("freeze momentarily.");
X  	    nomul(-2);
X  	    break;
X  	case MS_HUMANOID:
X--- 421,427 ----
X  #endif
X  	case MS_BONES:
X  	    pline("%s rattles noisily.", Monnam(mtmp));
X! 	    You("freeze for a moment.");
X  	    nomul(-2);
X  	    break;
X  	case MS_HUMANOID:
X***************
X*** 449,455 ****
X  	    else if (likes_magic(mtmp->data))
X  		pline("%s talks about spellcraft.", Monnam(mtmp));
X  	    else if (carnivorous(mtmp->data))
X! 		pline("%s discusses what kinds of meat are safe to eat.", Monnam(mtmp));
X  	    else switch (monsndx(mtmp->data)){
X  		case PM_HOBBIT:
X  		    if (mtmp->mhpmax - mtmp->mhp >= 10)
X--- 449,455 ----
X  	    else if (likes_magic(mtmp->data))
X  		pline("%s talks about spellcraft.", Monnam(mtmp));
X  	    else if (carnivorous(mtmp->data))
X! 		pline("%s discusses hunting.", Monnam(mtmp));
X  	    else switch (monsndx(mtmp->data)){
X  		case PM_HOBBIT:
X  		    if (mtmp->mhpmax - mtmp->mhp >= 10)
X***************
X*** 460,468 ****
X--- 460,470 ----
X  		case PM_ARCHEOLOGIST:
X  pline("%s describes a recent article in \"Spelunker Today\" magazine.", Monnam(mtmp));
X  		    break;
X+ # ifdef TOURIST
X  		case PM_TOURIST:
X  		    verbalize("Aloha.");
X  		    break;
X+ # endif
X  		default:
X  		    pline("%s discusses dungeon exploration.", Monnam(mtmp));
X  	    }
X***************
X*** 632,638 ****
X  
X  #ifdef POLYSELF
X      if (uasmon->msound == MS_SILENT) {
X! 	Your("current form seems unable to speak.");
X  	return(0);
X      }
X  #endif
X--- 634,640 ----
X  
X  #ifdef POLYSELF
X      if (uasmon->msound == MS_SILENT) {
X! 	pline("As %s, you cannot speak.", an(uasmon->mname));
X  	return(0);
X      }
X  #endif
X***************
X*** 645,651 ****
X  	return(0);
X      }
X      if (Underwater) {
X! 	pline("All you can utter is a mouthful of air bubbles.");
X  	return(0);
X      }
X  
X--- 647,653 ----
X  	return(0);
X      }
X      if (Underwater) {
X! 	pline("Your speech is unintelligible underwater.");
X  	return(0);
X      }
X  
X*** /tmp/da08614	Thu Feb 25 10:25:23 1993
X--- src/sp_lev.c	Wed Feb 24 22:34:59 1993
X***************
X*** 67,82 ****
X  #define NewTab(type, size)	(type **) alloc(sizeof(type *) * size)
X  #define Free(ptr)		if(ptr) free((genericptr_t) (ptr))
X  
X! static walk NEARDATA walklist[50];
X  extern int min_rx, max_rx, min_ry, max_ry; /* from mkmap.c */
X  
X  static char Map[COLNO][ROWNO];
X  static char robjects[10], rloc_x[10], rloc_y[10], rmonst[10];
X  static aligntyp	ralign[3] = { AM_CHAOTIC, AM_NEUTRAL, AM_LAWFUL };
X! static xchar NEARDATA xstart, NEARDATA ystart;
X! static char NEARDATA xsize, NEARDATA ysize;
X  
X! static void FDECL(make_walls_nondiggable, (XCHAR_P,XCHAR_P,XCHAR_P,XCHAR_P));
X  static int NDECL(rnddoor);
X  static int NDECL(rndtrap);
X  static void FDECL(get_location, (schar *,schar *,int));
X--- 67,82 ----
X  #define NewTab(type, size)	(type **) alloc(sizeof(type *) * size)
X  #define Free(ptr)		if(ptr) free((genericptr_t) (ptr))
X  
X! static NEARDATA walk walklist[50];
X  extern int min_rx, max_rx, min_ry, max_ry; /* from mkmap.c */
X  
X  static char Map[COLNO][ROWNO];
X  static char robjects[10], rloc_x[10], rloc_y[10], rmonst[10];
X  static aligntyp	ralign[3] = { AM_CHAOTIC, AM_NEUTRAL, AM_LAWFUL };
X! static NEARDATA xchar xstart, ystart;
X! static NEARDATA char xsize, ysize;
X  
X! static void FDECL(set_wall_property, (XCHAR_P,XCHAR_P,XCHAR_P,XCHAR_P,int));
X  static int NDECL(rnddoor);
X  static int NDECL(rndtrap);
X  static void FDECL(get_location, (schar *,schar *,int));
X***************
X*** 96,107 ****
X  lev_init init_lev;
X  
X  /*
X!  * Make walls of the area (x1, y1, x2, y2) non diggable
X   */
X  
X  static void
X! make_walls_nondiggable(x1,y1,x2,y2)
X  xchar x1, y1, x2, y2;
X  {
X  	register xchar x, y;
X  
X--- 96,108 ----
X  lev_init init_lev;
X  
X  /*
X!  * Make walls of the area (x1, y1, x2, y2) non diggable/non passwall-able
X   */
X  
X  static void
X! set_wall_property(x1,y1,x2,y2, prop)
X  xchar x1, y1, x2, y2;
X+ int prop;
X  {
X  	register xchar x, y;
X  
X***************
X*** 108,114 ****
X  	for(y = y1; y <= y2; y++)
X  	    for(x = x1; x <= x2; x++)
X  		if(IS_STWALL(levl[x][y].typ))
X! 		    levl[x][y].diggable |= W_NONDIGGABLE;
X  }
X  
X  /*
X--- 109,115 ----
X  	for(y = y1; y <= y2; y++)
X  	    for(x = x1; x <= x2; x++)
X  		if(IS_STWALL(levl[x][y].typ))
X! 		    levl[x][y].diggable |= prop;
X  }
X  
X  /*
X***************
X*** 843,849 ****
X  		/* changed mpeaceful again; have to reset malign */
X  		set_malign(mtmp);
X  	    }
X! 	    if (m->asleep >= 0) mtmp->msleep = m->asleep;
X  	}
X  }
X  
X--- 844,860 ----
X  		/* changed mpeaceful again; have to reset malign */
X  		set_malign(mtmp);
X  	    }
X! 	    if (m->asleep >= 0) {
X! #ifdef UNIXPC
X! 		/* optimizer bug strikes again */
X! 		if (m->asleep)
X! 			mtmp->msleep = TRUE;
X! 		else
X! 			mtmp->msleep = FALSE;
X! #else
X! 		mtmp->msleep = m->asleep;
X! #endif
X! 	    }
X  	}
X  }
X  
X***************
X*** 1035,1040 ****
X--- 1046,1055 ----
X  	    get_location(&x, &y, DRY);
X  	}
X  	levl[x][y].typ = typ;
X+ 	if (typ == FOUNTAIN)
X+ 	    level.flags.nfountains++;
X+ 	else if (typ == SINK)
X+ 	    level.flags.nsinks++;
X  }
X  
X  /* 
X***************
X*** 1294,1349 ****
X  	if (!croom || croom->rtype == OROOM)
X  	    return;
X  
X! 	if(prefilled) {
X! 	    switch(croom->rtype) {
X  	    case COURT:
X! 		level.flags.has_court = 1;
X  		break;
X  #ifdef ARMY
X  	    case BARRACKS:
X! 		level.flags.has_barracks = 1;
X  		break;
X  #endif
X! 	    case ZOO:
X! 		level.flags.has_zoo = 1;
X  		break;
X- 	    case MORGUE:
X- 		level.flags.has_morgue = 1;
X- 		break;
X  	    case SWAMP:
X! 		level.flags.has_swamp = 1;
X  		break;
X- 	    case BEEHIVE:
X- 		level.flags.has_beehive = 1;
X- 		break;
X- 	    }
X- 	    return;
X  	}
X- 	/* Vault ? */
X- 	if (croom->rtype == VAULT) {
X- 		int x,y;
X- 		for (x=croom->lx;x<=croom->hx;x++)
X- 		    for (y=croom->ly;y<=croom->hy;y++)
X- 			mkgold((long)rn1(depth(&u.uz)*100, 51), x, y);
X- 		return;
X- 	}
X- 
X- 	/* Shop ? */
X- 	if (croom->rtype >= SHOPBASE) {
X- 		stock_room(croom->rtype - SHOPBASE, croom);
X- 		return;
X- 	}
X- 
X- 	/* Zoo ? */
X- 	switch (croom->rtype) {
X- 	      case COURT:
X- 	      case ZOO:
X- 	      case BEEHIVE:
X- 	      case MORGUE:
X- 	      case BARRACKS:
X- 		fill_zoo(croom);
X- 		break;
X- 	}
X  }
X  
X  static void
X--- 1309,1367 ----
X  	if (!croom || croom->rtype == OROOM)
X  	    return;
X  
X! 	if (!prefilled) {
X! 	    int x,y;
X! 
X! 	    /* Shop ? */
X! 	    if (croom->rtype >= SHOPBASE) {
X! 		    stock_room(croom->rtype - SHOPBASE, croom);
X! 		    level.flags.has_shop = TRUE;
X! 		    return;
X! 	    }
X! 
X! 	    switch (croom->rtype) {
X! 		case VAULT:
X! 		    for (x=croom->lx;x<=croom->hx;x++)
X! 			for (y=croom->ly;y<=croom->hy;y++)
X! 			    mkgold((long)rn1(abs(depth(&u.uz))*100, 51), x, y);
X! 		    break;
X! 		case COURT:
X! 		case ZOO:
X! 		case BEEHIVE:
X! 		case MORGUE:
X! 		case BARRACKS:
X! 		    fill_zoo(croom);
X! 		    break;
X! 	    }
X! 	}
X! 	switch (croom->rtype) {
X! 	    case VAULT:
X! 		level.flags.has_vault = TRUE;
X! 		break;
X! 	    case ZOO:
X! 		level.flags.has_zoo = TRUE;
X! 		break;
X  	    case COURT:
X! 		level.flags.has_court = TRUE;
X  		break;
X+ 	    case MORGUE:
X+ 		level.flags.has_morgue = TRUE;
X+ 		break;
X+ 	    case BEEHIVE:
X+ 		level.flags.has_beehive = TRUE;
X+ 		break;
X  #ifdef ARMY
X  	    case BARRACKS:
X! 		level.flags.has_barracks = TRUE;
X  		break;
X  #endif
X! 	    case TEMPLE:
X! 		level.flags.has_temple = TRUE;
X  		break;
X  	    case SWAMP:
X! 		level.flags.has_swamp = TRUE;
X  		break;
X  	}
X  }
X  
X  static void
X***************
X*** 2263,2270 ****
X  		get_location(&tmpdig.x1, &tmpdig.y1, DRY|WET);
X  		get_location(&tmpdig.x2, &tmpdig.y2, DRY|WET);
X  
X! 		make_walls_nondiggable(tmpdig.x1, tmpdig.y1,
X! 				       tmpdig.x2, tmpdig.y2);
X  	}
X  
X  	Fread((genericptr_t) &n, 1, sizeof(n), fd);
X--- 2281,2300 ----
X  		get_location(&tmpdig.x1, &tmpdig.y1, DRY|WET);
X  		get_location(&tmpdig.x2, &tmpdig.y2, DRY|WET);
X  
X! 		set_wall_property(tmpdig.x1, tmpdig.y1,
X! 				  tmpdig.x2, tmpdig.y2, W_NONDIGGABLE);
X! 	}
X! 
X! 	Fread((genericptr_t) &n, 1, sizeof(n), fd);
X! 						/* Number of non_passables */
X! 	while(n--) {
X! 		Fread((genericptr_t)&tmpdig, 1, sizeof(tmpdig), fd);
X! 
X! 		get_location(&tmpdig.x1, &tmpdig.y1, DRY|WET);
X! 		get_location(&tmpdig.x2, &tmpdig.y2, DRY|WET);
X! 
X! 		set_wall_property(tmpdig.x1, tmpdig.y1,
X! 				  tmpdig.x2, tmpdig.y2, W_NONPASSWALL);
X  	}
X  
X  	Fread((genericptr_t) &n, 1, sizeof(n), fd);
X*** /tmp/da08638	Thu Feb 25 10:25:32 1993
X--- src/timeout.c	Fri Feb 12 10:25:41 1993
X***************
X*** 14,20 ****
X  #ifdef OVLB
X  
X  /* He is being petrified - dialogue by inmet!tower */
X! static const char NEARDATA *stoned_texts[] = {
X  	"You are slowing down.",		/* 5 */
X  	"Your limbs are stiffening.",		/* 4 */
X  	"Your limbs have turned to stone.",	/* 3 */
X--- 14,20 ----
X  #ifdef OVLB
X  
X  /* He is being petrified - dialogue by inmet!tower */
X! static NEARDATA const char *stoned_texts[] = {
X  	"You are slowing down.",		/* 5 */
X  	"Your limbs are stiffening.",		/* 4 */
X  	"Your limbs have turned to stone.",	/* 3 */
X***************
X*** 36,42 ****
X  }
X  
X  /* He is getting sicker and sicker prior to vomiting */
X! static const char NEARDATA *vomiting_texts[] = {
X  	"You are feeling mildly nauseous.",	/* 14 */
X  	"You feel slightly confused.",		/* 11 */
X  	"You can't seem to think straight.",	/* 8 */
X--- 36,42 ----
X  }
X  
X  /* He is getting sicker and sicker prior to vomiting */
X! static NEARDATA const char *vomiting_texts[] = {
X  	"You are feeling mildly nauseous.",	/* 14 */
X  	"You feel slightly confused.",		/* 11 */
X  	"You can't seem to think straight.",	/* 8 */
X***************
X*** 67,73 ****
X  	exercise(A_CON, FALSE);
X  }
X  
X! static const char NEARDATA *choke_texts[] = {
X  	"You find it hard to breathe.",
X  	"You're gasping for air.",
X  	"You can no longer breathe.",
X--- 67,73 ----
X  	exercise(A_CON, FALSE);
X  }
X  
X! static NEARDATA const char *choke_texts[] = {
X  	"You find it hard to breathe.",
X  	"You're gasping for air.",
X  	"You can no longer breathe.",
X***************
X*** 334,343 ****
X  void
X  burn_lamps()
X  {
X! 	register struct obj *obj;
X  
X  	/* Note: magic lamps never go out as long as the genie's inside */
X! 	for(obj=invent; obj; obj=obj->nobj) {
X  	    if ((obj->otyp == OIL_LAMP || obj->otyp == BRASS_LANTERN)
X  							&& obj->lamplit) {
X  		obj->age--;
X--- 334,344 ----
X  void
X  burn_lamps()
X  {
X! 	register struct obj *obj, *obj2;
X  
X  	/* Note: magic lamps never go out as long as the genie's inside */
X! 	for (obj=invent; obj; obj=obj2) {
X! 	    obj2 = obj->nobj;
X  	    if ((obj->otyp == OIL_LAMP || obj->otyp == BRASS_LANTERN)
X  							&& obj->lamplit) {
X  		obj->age--;
X***************
X*** 376,382 ****
X  	    }
X  	    if ((obj->otyp == CANDELABRUM_OF_INVOCATION || Is_candle(obj)) &&
X  			obj->lamplit)
X! 		age_candle(obj);
X  	}
X  }
X  
X--- 377,383 ----
X  	    }
X  	    if ((obj->otyp == CANDELABRUM_OF_INVOCATION || Is_candle(obj)) &&
X  			obj->lamplit)
X! 		age_candle(obj);	/* candles may vanish */
X  	}
X  }
X  
X*** /tmp/da08646	Thu Feb 25 10:25:35 1993
X--- src/topten.c	Fri Feb 12 13:01:02 1993
X***************
X*** 62,68 ****
X  static int FDECL(classmon, (CHAR_P,BOOLEAN_P));
X  
X  /* must fit with end.c */
X! const char NEARDATA *killed_by_prefix[] = {
X  	"killed by ", "choked on ", "poisoned by ", "", "drowned in ",
X  	"", "crushed to death by ", "petrified by ", "",
X  	"", "",
X--- 62,68 ----
X  static int FDECL(classmon, (CHAR_P,BOOLEAN_P));
X  
X  /* must fit with end.c */
X! NEARDATA const char *killed_by_prefix[] = {
X  	"killed by ", "choked on ", "poisoned by ", "", "drowned in ",
X  	"", "crushed to death by ", "petrified by ", "",
X  	"", "",
X***************
X*** 148,153 ****
X--- 148,157 ----
X  #else
X  #define	HUP	if(!done_hup)
X  #endif
X+ 
X+ #ifdef TOS
X+ 	restore_colors();	/* make sure the screen is black on white */
X+ #endif
X  	/* create a new 'topten' entry */
X  	t0 = newttentry();
X  	/* deepest_lev_reached() is in terms of depth(), and reporting the
X***************
X*** 172,182 ****
X  		default: impossible("bad killer format?");
X  		case KILLED_BY_AN:
X  			Strcat(t0->death, killed_by_prefix[how]);
X! 			(void) strncat(t0->death, an(killer), DTHSZ);
X  			break;
X  		case KILLED_BY:
X  			Strcat(t0->death, killed_by_prefix[how]);
X! 			(void) strncat(t0->death, killer, DTHSZ);
X  			break;
X  		case NO_KILLER_PREFIX:
X  			(void) strncat(t0->death, killer, DTHSZ);
X--- 176,188 ----
X  		default: impossible("bad killer format?");
X  		case KILLED_BY_AN:
X  			Strcat(t0->death, killed_by_prefix[how]);
X! 			(void) strncat(t0->death, an(killer),
X! 						DTHSZ-strlen(t0->death));
X  			break;
X  		case KILLED_BY:
X  			Strcat(t0->death, killed_by_prefix[how]);
X! 			(void) strncat(t0->death, killer,
X! 						DTHSZ-strlen(t0->death));
X  			break;
X  		case NO_KILLER_PREFIX:
X  			(void) strncat(t0->death, killer, DTHSZ);
X*** /tmp/da08654	Thu Feb 25 10:25:37 1993
X--- src/track.c	Thu Feb 11 13:28:07 1993
X***************
X*** 7,14 ****
X  
X  #define	UTSZ	50
X  
X! STATIC_VAR int NEARDATA utcnt, NEARDATA utpnt;
X! STATIC_VAR coord NEARDATA utrack[UTSZ];
X  
X  #ifdef OVLB
X  void
X--- 7,14 ----
X  
X  #define	UTSZ	50
X  
X! STATIC_VAR NEARDATA int utcnt, utpnt;
X! STATIC_VAR NEARDATA coord utrack[UTSZ];
X  
X  #ifdef OVLB
X  void
X*** /tmp/da08662	Thu Feb 25 10:25:39 1993
X--- src/trap.c	Tue Feb 23 09:38:07 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)trap.c	3.1	92/12/10	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)trap.c	3.1	93/02/13	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 57,64 ****
X  int type;
X  boolean print;
X  {
X! 	static const char NEARDATA *action[] = { "smoulder", "rust", "rot", "corrode" };
X! 	static const char NEARDATA *msg[] =  { "burnt", "rusted", "rotten", "corroded" };
X  	boolean vulnerable = FALSE;
X  	boolean plural;
X  	boolean grprot = FALSE;
X--- 57,64 ----
X  int type;
X  boolean print;
X  {
X! 	static NEARDATA const char *action[] = { "smoulder", "rust", "rot", "corrode" };
X! 	static NEARDATA const char *msg[] =  { "burnt", "rusted", "rotten", "corroded" };
X  	boolean vulnerable = FALSE;
X  	boolean plural;
X  	boolean grprot = FALSE;
X***************
X*** 76,88 ****
X  
X  	plural = is_gloves(otmp) || is_boots(otmp);
X  
X! 	if (!vulnerable)
X  		if (flags.verbose)
X  		    Your("%s %s not affected.", ostr, plural ? "are" : "is");
X! 	else if (otmp->oeroded < MAX_ERODE) {
X! 		if (grprot && otmp->greased)
X  			grease_protect(otmp,ostr,plural);
X! 		else if (otmp->oerodeproof || (otmp->blessed && !rnl(4))) {
X  			if (flags.verbose)
X  				pline("Somehow, your %s %s not affected.",
X  					ostr, plural ? "are" : "is");
X--- 76,88 ----
X  
X  	plural = is_gloves(otmp) || is_boots(otmp);
X  
X! 	if (!vulnerable) {
X  		if (flags.verbose)
X  		    Your("%s %s not affected.", ostr, plural ? "are" : "is");
X! 	} else if (otmp->oeroded < MAX_ERODE) {
X! 		if (grprot && otmp->greased) {
X  			grease_protect(otmp,ostr,plural);
X! 		} else if (otmp->oerodeproof || (otmp->blessed && !rnl(4))) {
X  			if (flags.verbose)
X  				pline("Somehow, your %s %s not affected.",
X  					ostr, plural ? "are" : "is");
X***************
X*** 93,103 ****
X  				otmp->oeroded ? " further" : "");
X  			otmp->oeroded++;
X  		}
X! 	} else
X  		if (flags.verbose)
X  			Your("%s %s%s completely %s.", ostr,
X  			     Blind ? "feel" : "look",
X  			     plural ? "" : "s", msg[type]);
X  	return(TRUE);
X  }
X  
X--- 93,104 ----
X  				otmp->oeroded ? " further" : "");
X  			otmp->oeroded++;
X  		}
X! 	} else {
X  		if (flags.verbose)
X  			Your("%s %s%s completely %s.", ostr,
X  			     Blind ? "feel" : "look",
X  			     plural ? "" : "s", msg[type]);
X+ 	}
X  	return(TRUE);
X  }
X  
X***************
X*** 126,132 ****
X  	register struct trap *ttmp;
X  	register boolean oldplace;
X  
X! 	if (ttmp = t_at(x,y)) {
X  	    oldplace = TRUE;
X  	    if (u.utrap && (x == u.ux) && (y == u.uy) && 
X  	      ((u.utraptype == TT_BEARTRAP && typ != BEAR_TRAP) ||
X--- 127,133 ----
X  	register struct trap *ttmp;
X  	register boolean oldplace;
X  
X! 	if ((ttmp = t_at(x,y)) != 0) {
X  	    oldplace = TRUE;
X  	    if (u.utrap && (x == u.ux) && (y == u.uy) && 
X  	      ((u.utraptype == TT_BEARTRAP && typ != BEAR_TRAP) ||
X***************
X*** 174,180 ****
X  	boolean	tmp1, tmp2, tmp3, tmp4;
X  # ifdef POLYSELF
X  	tmp1 = isok(x,y) && (!IS_ROCK(levl[x][y].typ) ||
X! 		passes_walls(uasmon)) && !MON_AT(x, y);
X  # else
X  	tmp1 = isok(x,y) && !IS_ROCK(levl[x][y].typ) && !MON_AT(x, y);
X  # endif
X--- 175,181 ----
X  	boolean	tmp1, tmp2, tmp3, tmp4;
X  # ifdef POLYSELF
X  	tmp1 = isok(x,y) && (!IS_ROCK(levl[x][y].typ) ||
X! 		(passes_walls(uasmon) && may_passwall(x,y))) && !MON_AT(x, y);
X  # else
X  	tmp1 = isok(x,y) && !IS_ROCK(levl[x][y].typ) && !MON_AT(x, y);
X  # endif
X***************
X*** 191,197 ****
X  #else
X  	return( isok(x,y) &&
X  # ifdef POLYSELF
X! 		(!IS_ROCK(levl[x][y].typ) || passes_walls(uasmon)) &&
X  # else
X  		!IS_ROCK(levl[x][y].typ) &&
X  # endif
X--- 192,199 ----
X  #else
X  	return( isok(x,y) &&
X  # ifdef POLYSELF
X! 		(!IS_ROCK(levl[x][y].typ) ||
X! 		 (passes_walls(uasmon) && may_passwall(x,y))) &&
X  # else
X  		!IS_ROCK(levl[x][y].typ) &&
X  # endif
X***************
X*** 317,325 ****
X  #else
X  	   !(ttype == PIT || ttype == SPIKED_PIT) &&
X  #endif
X! 	   !(ttype == MAGIC_PORTAL || ttype == ANTI_MAGIC) && !rn2(5))
X  		You("escape a%s.", traps[ttype]);
X! 	else {
X  	    seetrap(trap);
X  	    switch(ttype) {
X  		case ARROW_TRAP:
X--- 319,327 ----
X  #else
X  	   !(ttype == PIT || ttype == SPIKED_PIT) &&
X  #endif
X! 	   !(ttype == MAGIC_PORTAL || ttype == ANTI_MAGIC) && !rn2(5)) {
X  		You("escape a%s.", traps[ttype]);
X! 	} else {
X  	    seetrap(trap);
X  	    switch(ttype) {
X  		case ARROW_TRAP:
X***************
X*** 327,335 ****
X  		    otmp = mksobj(ARROW, TRUE, FALSE);
X  		    otmp->quan = 1L;
X  		    otmp->owt = weight(otmp);
X! 		    if(thitu(8,dmgval(otmp,uasmon),otmp,"arrow"))
X  			obfree(otmp, (struct obj *)0);
X! 		    else {
X  			place_object(otmp, u.ux, u.uy);
X  			otmp->nobj = fobj;
X  			fobj = otmp;		
X--- 329,337 ----
X  		    otmp = mksobj(ARROW, TRUE, FALSE);
X  		    otmp->quan = 1L;
X  		    otmp->owt = weight(otmp);
X! 		    if(thitu(8,dmgval(otmp,uasmon),otmp,"arrow")) {
X  			obfree(otmp, (struct obj *)0);
X! 		    } else {
X  			place_object(otmp, u.ux, u.uy);
X  			otmp->nobj = fobj;
X  			fobj = otmp;		
X***************
X*** 366,377 ****
X  	pline("A trap door in the ceiling opens and a rock falls on your %s!",
X  				body_part(HEAD));
X  
X! 			if (uarmh)
X  			    if(is_metallic(uarmh)) {
X  				pline("Fortunately, you are wearing a hard helmet.");
X  				dmg = 2;
X! 			    } else if (flags.verbose)
X   				Your("%s does not protect you.", xname(uarmh));
X  
X  			stackobj(otmp);
X  			newsym(u.ux,u.uy);	/* map the rock */
X--- 368,381 ----
X  	pline("A trap door in the ceiling opens and a rock falls on your %s!",
X  				body_part(HEAD));
X  
X! 			if (uarmh) {
X  			    if(is_metallic(uarmh)) {
X  				pline("Fortunately, you are wearing a hard helmet.");
X  				dmg = 2;
X! 			    } else if (flags.verbose) {
X   				Your("%s does not protect you.", xname(uarmh));
X+ 			    }
X+ 			}
X  
X  			stackobj(otmp);
X  			newsym(u.ux,u.uy);	/* map the rock */
X***************
X*** 447,453 ****
X  		    } else
X  		    if (u.umonnum == PM_GREMLIN && rn2(3)) {
X  			pline("A gush of water hits you!");
X! 			if(mtmp = cloneu()) {
X  			    mtmp->mhpmax = (u.mhmax /= 2);
X  			    You("multiply.");
X  			}
X--- 451,457 ----
X  		    } else
X  		    if (u.umonnum == PM_GREMLIN && rn2(3)) {
X  			pline("A gush of water hits you!");
X! 			if ((mtmp = cloneu()) != 0) {
X  			    mtmp->mhpmax = (u.mhmax /= 2);
X  			    You("multiply.");
X  			}
X***************
X*** 505,513 ****
X  #endif
X  			) {
X  			if(Blind) break;
X! 			if(trap->tseen)
X  			    You("see a pit below you.");
X! 			else {
X  			    pline("A pit opens up under you!");
X  			    You("don't fall in!");
X  			}
X--- 509,517 ----
X  #endif
X  			) {
X  			if(Blind) break;
X! 			if(trap->tseen) {
X  			    You("see a pit below you.");
X! 			} else {
X  			    pline("A pit opens up under you!");
X  			    You("don't fall in!");
X  			}
X***************
X*** 657,666 ****
X  		case STATUE_TRAP:
X  		    deltrap(trap);
X  		    newsym(u.ux,u.uy);	/* get rid of trap symbol */
X! 		    for(otmp=level.objects[u.ux][u.uy];
X  						otmp; otmp = otmp->nexthere)
X! 			if(otmp->otyp == STATUE)
X! 			    if(mtmp=makemon(&mons[otmp->corpsenm],u.ux,u.uy)) {
X  				pline("The statue comes to life!");
X  				/* mimic statues become seen mimics */
X  				if(mtmp->m_ap_type) seemimic(mtmp);
X--- 661,671 ----
X  		case STATUE_TRAP:
X  		    deltrap(trap);
X  		    newsym(u.ux,u.uy);	/* get rid of trap symbol */
X! 		    for (otmp = level.objects[u.ux][u.uy];
X  						otmp; otmp = otmp->nexthere)
X! 			if (otmp->otyp == STATUE)
X! 			    if ((mtmp = makemon(&mons[otmp->corpsenm],
X! 						u.ux, u.uy)) != 0) {
X  				pline("The statue comes to life!");
X  				/* mimic statues become seen mimics */
X  				if(mtmp->m_ap_type) seemimic(mtmp);
X***************
X*** 715,720 ****
X--- 720,726 ----
X  			pline("KAABLAMM!!!  You triggered a land mine!");
X  			set_wounded_legs(LEFT_SIDE, rn1(35, 41));
X  			set_wounded_legs(RIGHT_SIDE, rn1(35, 41));
X+ 			exercise(A_DEX, FALSE);
X  		    }
X  		    losehp(rnd(16), "land mine", KILLED_BY_AN);
X  		    /* wake everything on the level */
X***************
X*** 804,810 ****
X  	if(!trap) {
X  		mtmp->mtrapped = 0;	/* perhaps teleported? */
X  	} else if (mtmp->mtrapped) {	/* was in trap */
X! 		if(!rn2(40)) 
X  			if (sobj_at(BOULDER, mtmp->mx, mtmp->my) && 
X  			    ((trap->ttyp == PIT) || 
X  			     (trap->ttyp == SPIKED_PIT))) {
X--- 810,816 ----
X  	if(!trap) {
X  		mtmp->mtrapped = 0;	/* perhaps teleported? */
X  	} else if (mtmp->mtrapped) {	/* was in trap */
X! 		if(!rn2(40)) {
X  			if (sobj_at(BOULDER, mtmp->mx, mtmp->my) && 
X  			    ((trap->ttyp == PIT) || 
X  			     (trap->ttyp == SPIKED_PIT))) {
X***************
X*** 814,819 ****
X--- 820,826 ----
X  				}
X  			} else
X  				mtmp->mtrapped = 0;
X+ 		}
X  	} else {
X  	    register int tt = trap->ttyp;
X  
X***************
X*** 874,889 ****
X  		case BEAR_TRAP:
X  			if(mptr->msize > MZ_SMALL &&
X  			   !amorphous(mptr) && !is_flyer(mptr)) {
X! 				mtmp->mtrapped = 1;
X! 				if(in_sight) {
X! 				  pline("%s is caught in a bear trap!",
X! 					Monnam(mtmp));
X! 				  seetrap(trap);
X! 				} else
X! 				    if((mptr == &mons[PM_OWLBEAR]
X! 					|| mptr == &mons[PM_BUGBEAR])
X! 					&& flags.soundok)
X! 			    You("hear the roaring of an angry bear!");
X  			}
X  			break;
X  
X--- 881,897 ----
X  		case BEAR_TRAP:
X  			if(mptr->msize > MZ_SMALL &&
X  			   !amorphous(mptr) && !is_flyer(mptr)) {
X! 			    mtmp->mtrapped = 1;
X! 			    if(in_sight) {
X! 				pline("%s is caught in a bear trap!",
X! 				      Monnam(mtmp));
X! 				seetrap(trap);
X! 			    } else {
X! 				if((mptr == &mons[PM_OWLBEAR]
X! 				    || mptr == &mons[PM_BUGBEAR])
X! 				   && flags.soundok)
X! 				    You("hear the roaring of an angry bear!");
X! 			    }
X  			}
X  			break;
X  
X***************
X*** 912,918 ****
X  				    pline("May %s rust in peace.",
X  								mon_nam(mtmp));
X  				mondied(mtmp);
X! 				trapkilled = TRUE;
X  			} else if (mptr == &mons[PM_GREMLIN] && rn2(3)) {
X  				struct monst *mtmp2 = clone_mon(mtmp);
X  
X--- 920,929 ----
X  				    pline("May %s rust in peace.",
X  								mon_nam(mtmp));
X  				mondied(mtmp);
X! #ifdef MUSE
X! 				if (mtmp->mhp <= 0)
X! #endif
X! 					trapkilled = TRUE;
X  			} else if (mptr == &mons[PM_GREMLIN] && rn2(3)) {
X  				struct monst *mtmp2 = clone_mon(mtmp);
X  
X***************
X*** 957,964 ****
X--- 968,982 ----
X  				    pline("%s falls into a pit!", Monnam(mtmp));
X  				    seetrap(trap);
X  				}
X+ #ifdef MUSE
X+ 				mselftouch(mtmp, "Falling, ", FALSE);
X+ 				if(mtmp->mhp <= 0 ||
X+ 					thitm(0, mtmp, (struct obj *)0,
X+ 					 rnd((tt==PIT) ? 6 : 10)))
X+ #else
X  				if(thitm(0, mtmp, (struct obj *)0,
X  					 rnd((tt==PIT) ? 6 : 10)))
X+ #endif
X  				    trapkilled = TRUE;
X  			}
X  			break;
X***************
X*** 1166,1172 ****
X  selftouch(arg)
X  const char *arg;
X  {
X! 	if(uwep && (uwep->otyp == CORPSE && uwep->corpsenm == PM_COCKATRICE)
X  #ifdef POLYSELF
X  			&& !resists_ston(uasmon)
X  #endif
X--- 1184,1190 ----
X  selftouch(arg)
X  const char *arg;
X  {
X! 	if(uwep && uwep->otyp == CORPSE && uwep->corpsenm == PM_COCKATRICE
X  #ifdef POLYSELF
X  			&& !resists_ston(uasmon)
X  #endif
X***************
X*** 1183,1189 ****
X--- 1201,1235 ----
X  	}
X  }
X  
X+ #ifdef MUSE
X  void
X+ mselftouch(mon,arg,byplayer)
X+ struct monst *mon;
X+ const char *arg;
X+ boolean byplayer;
X+ {
X+ 	struct obj *mwep = MON_WEP(mon);
X+ 
X+ 	if (mwep && mwep->otyp == CORPSE && mwep->corpsenm == PM_COCKATRICE
X+ 			&& !resists_ston(mon->data)) {
X+ 		if (cansee(mon->mx, mon->my)) {
X+ 			pline("%s%s touches the cockatrice corpse.",
X+ 			    arg ? arg : "", arg ? mon_nam(mon) : Monnam(mon));
X+ 			pline("%s turns to stone.", Monnam(mon));
X+ 		}
X+ 		if (poly_when_stoned(mon->data)) {
X+ 			mon_to_stone(mon);
X+ 			return;
X+ 		}
X+ 		if (byplayer) {
X+ 			stoned = TRUE;
X+ 			xkilled(mon,0);
X+ 		} else monstone(mon);
X+ 	}
X+ }
X+ #endif
X+ 
X+ void
X  float_up()
X  {
X  	if(u.utrap) {
X***************
X*** 1279,1285 ****
X  		else if (!u.uinwater && !no_msg) {
X  			if (Hallucination)
X  				pline("Bummer!  You've %s.",
X! 			      	is_pool(u.ux,u.uy) ?
X  			      		"splashed down" : "hit the ground");
X  			else
X  				You("float gently to the %s.",
X--- 1325,1331 ----
X  		else if (!u.uinwater && !no_msg) {
X  			if (Hallucination)
X  				pline("Bummer!  You've %s.",
X! 				      is_pool(u.ux,u.uy) ?
X  			      		"splashed down" : "hit the ground");
X  			else
X  				You("float gently to the %s.",
X***************
X*** 1337,1345 ****
X  			    || wizard
X  #endif
X  					) {
X! 	    if (unconscious())
X  		pline("Being unconscious, you cannot control your teleport.");
X! 	    else {
X  		    pline("To what position do you want to be teleported?");
X  		    cc.x = u.ux;
X  		    cc.y = u.uy;
X--- 1383,1391 ----
X  			    || wizard
X  #endif
X  					) {
X! 	    if (unconscious()) {
X  		pline("Being unconscious, you cannot control your teleport.");
X! 	    } else {
X  		    pline("To what position do you want to be teleported?");
X  		    cc.x = u.ux;
X  		    cc.y = u.uy;
X***************
X*** 1516,1523 ****
X  	    char buf[BUFSZ];
X  
X  	    do {
X! 	      getlin("To what level do you want to teleport? [type a number]",
X  			buf);
X  	    } while(!digit(buf[0]) && (buf[0] != '-' || !digit(buf[1])));
X  	    newlev = atoi(buf);
X  
X--- 1562,1571 ----
X  	    char buf[BUFSZ];
X  
X  	    do {
X! 		getlin("To what level do you want to teleport? [type a number]",
X  			buf);
X+ 		if (!strcmp(buf,"\033"))	/* cancelled */
X+ 		    return;
X  	    } while(!digit(buf[0]) && (buf[0] != '-' || !digit(buf[1])));
X  	    newlev = atoi(buf);
X  
X***************
X*** 1597,1603 ****
X  		} else
X  			You("are now high above the clouds...");
X  
X! 		if(Levitation || is_floater(uasmon)) {
X  		    You("float gently down to earth.");
X  		    u.uz.dnum = 0; /* he might have been in another dgn */
X  		    newlev = 1;
X--- 1645,1655 ----
X  		} else
X  			You("are now high above the clouds...");
X  
X! 		if(Levitation
X! #ifdef POLYSELF
X! 		   || is_floater(uasmon)
X! #endif
X! 		   ) {
X  		    You("float gently down to earth.");
X  		    u.uz.dnum = 0; /* he might have been in another dgn */
X  		    newlev = 1;
X***************
X*** 1802,1814 ****
X  }
X  
X  void
X! water_damage(obj,force)
X  register struct obj *obj;
X! register boolean force;
X  {
X  	/* Scrolls, spellbooks, potions, weapons and
X  	   pieces of armor may get affected by the water */
X! 	for(; obj; obj = obj->nobj) {
X  
X  		(void) snuff_lit(obj);
X  
X--- 1854,1866 ----
X  }
X  
X  void
X! water_damage(obj, force, here)
X  register struct obj *obj;
X! register boolean force, here;
X  {
X  	/* Scrolls, spellbooks, potions, weapons and
X  	   pieces of armor may get affected by the water */
X! 	for (; obj; obj = (here ? obj->nexthere : obj->nobj)) {
X  
X  		(void) snuff_lit(obj);
X  
X***************
X*** 1816,1822 ****
X  			if (force || !rn2(2)) obj->greased = 0;
X  		} else if(Is_container(obj) && !Is_box(obj) &&
X  			(obj->otyp != OILSKIN_SACK || (obj->cursed && !rn2(3)))) {
X! 			water_damage(obj->cobj,force);
X  		} else if(obj->oclass == SCROLL_CLASS && (force || rn2(12) > Luck)
X  #ifdef MAIL
X  			  && obj->otyp != SCR_MAIL
X--- 1868,1874 ----
X  			if (force || !rn2(2)) obj->greased = 0;
X  		} else if(Is_container(obj) && !Is_box(obj) &&
X  			(obj->otyp != OILSKIN_SACK || (obj->cursed && !rn2(3)))) {
X! 			water_damage(obj->cobj, force, FALSE);
X  		} else if(obj->oclass == SCROLL_CLASS && (force || rn2(12) > Luck)
X  #ifdef MAIL
X  			  && obj->otyp != SCR_MAIL
X***************
X*** 1909,1915 ****
X  
X  	/* happily wading in the same contiguous pool */
X  	if (u.uinwater && is_pool(u.ux-u.dx,u.uy-u.dy) &&
X! 	   Magical_breathing) {
X  		/* water effects on objects every now and then */
X  		if (!rn2(5)) inpool_ok = TRUE;
X  		else return(FALSE);
X--- 1961,1971 ----
X  
X  	/* happily wading in the same contiguous pool */
X  	if (u.uinwater && is_pool(u.ux-u.dx,u.uy-u.dy) &&
X! 	    (
X! #ifdef POLYSELF
X! 	     is_swimmer(uasmon) ||
X! #endif
X! 	     Magical_breathing)) {
X  		/* water effects on objects every now and then */
X  		if (!rn2(5)) inpool_ok = TRUE;
X  		else return(FALSE);
X***************
X*** 1926,1943 ****
X  			Hallucination ? "the Titanic" : "a rock");
X  	}
X  
X! 	water_damage(invent,FALSE);
X  
X  #ifdef POLYSELF
X  	if(u.umonnum == PM_GREMLIN && rn2(3)) {
X  		struct monst *mtmp;
X! 		if(mtmp = cloneu()) {
X  			mtmp->mhpmax = (u.mhmax /= 2);
X  			You("multiply.");
X  		}
X  	}
X  
X! 	if(is_swimmer(uasmon)) return(FALSE);
X  #endif
X  	if (inpool_ok) return(FALSE);
X  #ifdef WALKIES
X--- 1982,2005 ----
X  			Hallucination ? "the Titanic" : "a rock");
X  	}
X  
X! 	water_damage(invent, FALSE, FALSE);
X  
X  #ifdef POLYSELF
X  	if(u.umonnum == PM_GREMLIN && rn2(3)) {
X  		struct monst *mtmp;
X! 		if ((mtmp = cloneu()) != 0) {
X  			mtmp->mhpmax = (u.mhmax /= 2);
X  			You("multiply.");
X  		}
X  	}
X  
X! 	if(is_swimmer(uasmon) && !inpool_ok) {
X! 	    if (Punished) placebc();
X! 	    u.uinwater = 1;
X! 	    under_water(1);
X! 	    vision_full_recalc = 1;
X! 	    return(FALSE);
X! 	}
X  #endif
X  	if (inpool_ok) return(FALSE);
X  #ifdef WALKIES
X***************
X*** 1956,1961 ****
X--- 2018,2024 ----
X  		if (Punished) placebc();
X  		u.uinwater = 1;
X  		under_water(1);
X+ 		vision_full_recalc = 1;
X  		return(FALSE);
X  	}
X  	if((Teleportation || can_teleport(uasmon)) &&
X***************
X*** 2305,2315 ****
X  		case 0:
X  			pline("A cloud of %s gas billows from %s",
X  			      hcolor(), the(xname(obj)));
X! 			if(!Stunned)
X  			    if (Hallucination)
X  				pline("What a groovy feeling!");
X  			    else
X  				You("stagger and your vision blurs...");
X  			make_stunned(HStun + rn1(7, 16),FALSE);
X  			make_hallucinated(HHallucination + rn1(5, 16),FALSE,0L);
X  			break;
X--- 2368,2381 ----
X  		case 0:
X  			pline("A cloud of %s gas billows from %s",
X  			      hcolor(), the(xname(obj)));
X! 			if(!Stunned) {
X  			    if (Hallucination)
X  				pline("What a groovy feeling!");
X+ 			    else if (Blind)
X+ 				You("stagger and get dizzy...");
X  			    else
X  				You("stagger and your vision blurs...");
X+ 			}
X  			make_stunned(HStun + rn1(7, 16),FALSE);
X  			make_hallucinated(HHallucination + rn1(5, 16),FALSE,0L);
X  			break;
X***************
X*** 2410,2417 ****
X  			int yy = mon->my;
X  
X  			monkilled(mon, "", AD_PHYS);
X! 			newsym(xx, yy);
X! 			trapkilled = TRUE;
X  		}
X  	}
X  	if (obj && (!strike || d_override)) {
X--- 2476,2489 ----
X  			int yy = mon->my;
X  
X  			monkilled(mon, "", AD_PHYS);
X! #ifdef MUSE
X! 			if (mon->mhp <= 0) {
X! #endif
X! 				newsym(xx, yy);
X! 				trapkilled = TRUE;
X! #ifdef MUSE
X! 			}
X! #endif
X  		}
X  	}
X  	if (obj && (!strike || d_override)) {
X*** /tmp/da08670	Thu Feb 25 10:25:43 1993
X--- src/u_init.c	Mon Feb 22 12:24:29 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)u_init.c	3.1	92/11/13	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)u_init.c	3.1	93/02/21	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 22,27 ****
X--- 22,29 ----
X  #define	UNDEF_SPE	'\177'
X  #define	UNDEF_BLESS	2
X  
X+ static boolean random_role = FALSE;
X+ 
X  /* all roles must all have distinct first letter */
X  const char *roles[] = {	/* also used in options.c and winxxx.c */
X  			/* roles[2] and [6] are changed for females */
X***************
X*** 260,265 ****
X--- 262,271 ----
X  	    terminate(0);
X  	}
X  	i = role_index(pc);
X+ 	if (random_role) {
X+ 	    pline("This game you will be %s.", an(roles[i]));
X+ 	    display_nhwindow(WIN_MESSAGE, TRUE);
X+ 	}
X  
X  	(void) strncpy(pl_character, roles[i], PL_CSIZ-1);
X  	pl_character[PL_CSIZ-1] = 0;
X***************
X*** 475,480 ****
X--- 481,488 ----
X  	if (discover)
X  		ini_inv(Wishing);
X  #endif
X+ 	u.ugold0 += hidden_gold();	/* in case sack has gold in it */
X+ 
X  	find_ac();			/* get initial ac value */
X  	init_attr(75);			/* init attribute values */
X  	max_rank_sz();			/* set max str size for class ranks */
X***************
X*** 518,527 ****
X  		 */
X  		if (undefined) {
X  #ifdef POLYSELF
X! 			static unsigned NEARDATA nocreate = STRANGE_OBJECT;
X! 			static unsigned NEARDATA nocreate2 = STRANGE_OBJECT;
X  #endif
X! 			static unsigned NEARDATA nocreate3 = STRANGE_OBJECT;
X  
X  			while(obj->otyp == WAN_WISHING
X  #ifdef POLYSELF
X--- 526,535 ----
X  		 */
X  		if (undefined) {
X  #ifdef POLYSELF
X! 			static NEARDATA unsigned nocreate = STRANGE_OBJECT;
X! 			static NEARDATA unsigned nocreate2 = STRANGE_OBJECT;
X  #endif
X! 			static NEARDATA unsigned nocreate3 = STRANGE_OBJECT;
X  
X  			while(obj->otyp == WAN_WISHING
X  #ifdef POLYSELF
X***************
X*** 649,664 ****
X  }
X  
X  void
X! plnamesuffix() {
X  	register char *p;
X  	if ((p = rindex(plname, '-')) != 0) {
X! 		*p = 0;
X  		pl_character[0] = p[1];
X! 		pl_character[1] = 0;
X  		if(!plname[0]) {
X  			askname();
X  			plnamesuffix();
X  		}
X  	}
X  }
X  
X--- 657,680 ----
X  }
X  
X  void
X! plnamesuffix()
X! {
X  	register char *p;
X  	if ((p = rindex(plname, '-')) != 0) {
X! 		*p = '\0';
X  		pl_character[0] = p[1];
X! 		pl_character[1] = '\0';
X! 		random_role = FALSE;
X  		if(!plname[0]) {
X  			askname();
X  			plnamesuffix();
X  		}
X+ 	}
X+ 	if (pl_character[0] == '@') {	/* explicit request for random class */
X+ 		int i = rn2((int)strlen(pl_classes));
X+ 		pl_character[0] = pl_classes[i];
X+ 		pl_character[1] = '\0';
X+ 		random_role = TRUE;
X  	}
X  }
X  
X*** /tmp/da08678	Thu Feb 25 10:25:45 1993
X--- src/uhitm.c	Tue Feb 23 16:35:40 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)uhitm.c	3.1	92/12/10	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)uhitm.c	3.1	93/02/18	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 102,108 ****
X  			else if ((obj = level.objects[mtmp->mx][mtmp->my]) != 0)
X  			    pline("Wait!  There's %s hiding under %s!",
X  					an(l_monnam(mtmp)), doname(obj));
X! 			wakeup(mtmp);
X  			mtmp->data->mflags3 &= ~M3_WAITMASK;
X  			return(TRUE);
X  		}
X--- 102,108 ----
X  			else if ((obj = level.objects[mtmp->mx][mtmp->my]) != 0)
X  			    pline("Wait!  There's %s hiding under %s!",
X  					an(l_monnam(mtmp)), doname(obj));
X! 			mtmp->msleep = 0;
X  			mtmp->data->mflags3 &= ~M3_WAITMASK;
X  			return(TRUE);
X  		}
X***************
X*** 350,356 ****
X  struct monst *mon;
X  int tmp;
X  {
X! 	static int NEARDATA malive;
X  	boolean mhit = (tmp > (dieroll = rnd(20)) || u.uswallow);
X  
X  	if(tmp > dieroll) exercise(A_DEX, TRUE);
X--- 350,356 ----
X  struct monst *mon;
X  int tmp;
X  {
X! 	static NEARDATA int malive;
X  	boolean mhit = (tmp > (dieroll = rnd(20)) || u.uswallow);
X  
X  	if(tmp > dieroll) exercise(A_DEX, TRUE);
X***************
X*** 426,438 ****
X  	       obj->otyp == UNICORN_HORN || obj->oclass == ROCK_CLASS) {
X  
X  		/* If not a melee weapon, and either not thrown, or thrown */
X! 		/* and a bow (bows are >BOOMERANG), or thrown and a missile */
X! 		/* without a propellor (missiles are <DART), do 1-2 points */
X! 		if((obj->otyp >= BOW || obj->otyp < DART)
X  			&& obj->otyp != PICK_AXE && obj->otyp != UNICORN_HORN
X  			&& (!thrown ||
X  			    (obj->oclass != ROCK_CLASS &&
X! 			    (obj->otyp > BOOMERANG ||
X  				(obj->otyp < DART &&
X  				    (!uwep ||
X  				    objects[obj->otyp].w_propellor !=
X--- 426,438 ----
X  	       obj->otyp == UNICORN_HORN || obj->oclass == ROCK_CLASS) {
X  
X  		/* If not a melee weapon, and either not thrown, or thrown */
X! 		/* and a bow (bows are >= BOW), or thrown and a missile */
X! 		/* without a propellor (which means <DART), do 1-2 points */
X! 		if((obj->otyp >= BOW || obj->otyp < BOOMERANG)
X  			&& obj->otyp != PICK_AXE && obj->otyp != UNICORN_HORN
X  			&& (!thrown ||
X  			    (obj->oclass != ROCK_CLASS &&
X! 			    (obj->otyp >= BOW ||
X  				(obj->otyp < DART &&
X  				    (!uwep ||
X  				    objects[obj->otyp].w_propellor !=
X***************
X*** 448,453 ****
X--- 448,454 ----
X  			artifact_hit(&youmonst, mon, obj, &tmp, dieroll)) {
X  			if(mon->mhp <= 0) /* artifact killed monster */
X  			    return FALSE;
X+ 			if (tmp == 0) return TRUE;
X  			hittxt = TRUE;
X  		    }
X  		    if (objects[obj->otyp].oc_material == SILVER
X***************
X*** 662,673 ****
X  	if(mon->mhp < 1)
X  		destroyed = TRUE;
X  	if(mon->mtame && (!mon->mflee || mon->mfleetim)) {
X! #ifdef SOUNDS
X! 		if (rn2(8)) yelp(mon);
X! 		else growl(mon); /* give them a moment's worry */
X! #endif
X! 		mon->mtame--;
X! 		if(!mon->mtame) newsym(mon->mx, mon->my);
X  		mon->mflee = TRUE;		/* Rick Richardson */
X  		mon->mfleetim += 10*rnd(tmp);
X  	}
X--- 663,669 ----
X  	if(mon->mhp < 1)
X  		destroyed = TRUE;
X  	if(mon->mtame && (!mon->mflee || mon->mfleetim)) {
X! 		abuse_dog(mon);
X  		mon->mflee = TRUE;		/* Rick Richardson */
X  		mon->mfleetim += 10*rnd(tmp);
X  	}
X***************
X*** 758,764 ****
X  		&& u.umonnum != PM_BALROG) {
X  	    struct monst *dtmp;
X  	    pline("Some hell-p has arrived!");
X! 	    if((dtmp = makemon(!rn2(6) ? &mons[ndemon()] : uasmon, u.ux, u.uy)))
X  		(void)tamedog(dtmp, (struct obj *)0);
X  	    exercise(A_WIS, TRUE);
X  	    return(0);
X--- 754,761 ----
X  		&& u.umonnum != PM_BALROG) {
X  	    struct monst *dtmp;
X  	    pline("Some hell-p has arrived!");
X! 	    if((dtmp = makemon(!rn2(6) ? &mons[ndemon(u.ualign.type)] :
X! 					 uasmon, u.ux, u.uy)))
X  		(void)tamedog(dtmp, (struct obj *)0);
X  	    exercise(A_WIS, TRUE);
X  	    return(0);
X***************
X*** 859,873 ****
X  		    }
X  		    if (stealoid) {
X  			boolean stolen = FALSE;
X- 			/* Is "he"/"his" always correct? */
X  			if (gender(mdef) == u.mfemale &&
X  						uasmon->mlet == S_NYMPH)
X  	You("charm %s.  She gladly hands over her possessions.", mon_nam(mdef));
X  			else
X! 		You("seduce %s and %s starts to take off %s clothes.",
X! 				mon_nam(mdef),
X! 				gender(mdef) ? "she" : "he",
X! 				gender(mdef) ? "her" : "his");
X  			while(mdef->minvent) {
X  				otmp = mdef->minvent;
X  				mdef->minvent = otmp->nobj;
X--- 856,868 ----
X  		    }
X  		    if (stealoid) {
X  			boolean stolen = FALSE;
X  			if (gender(mdef) == u.mfemale &&
X  						uasmon->mlet == S_NYMPH)
X  	You("charm %s.  She gladly hands over her possessions.", mon_nam(mdef));
X  			else
X! 			You("seduce %s and %s starts to take off %s clothes.",
X! 			    mon_nam(mdef), he[pronoun_gender(mdef)],
X! 			    his[pronoun_gender(mdef)]);
X  			while(mdef->minvent) {
X  				otmp = mdef->minvent;
X  				mdef->minvent = otmp->nobj;
X***************
X*** 892,898 ****
X  				impossible("Player steal fails!");
X  			else {
X  				pline("%s finishes taking off %s suit.",
X! 				   Monnam(mdef), gender(mdef) ? "her" : "his");
X  				You("steal %s!", doname(stealoid));
X  # if defined(ARMY) && !defined(MUSE)
X  				mdef->data = &mons[PM_UNARMORED_SOLDIER];
X--- 887,893 ----
X  				impossible("Player steal fails!");
X  			else {
X  				pline("%s finishes taking off %s suit.",
X! 				      Monnam(mdef), his[pronoun_gender(mdef)]);
X  				You("steal %s!", doname(stealoid));
X  # if defined(ARMY) && !defined(MUSE)
X  				mdef->data = &mons[PM_UNARMORED_SOLDIER];
X***************
X*** 910,915 ****
X--- 905,915 ----
X  #ifdef MUSE
X  			possibly_unwield(mdef);
X  			otmp->owornmask = 0L;
X+ 			mselftouch(mdef, (const char *)0, TRUE);
X+ 			if (mdef->mhp <= 0) {
X+ 				tmp = 1; /* avoid early return from damageum */
X+ 				break;
X+ 			}
X  #endif
X  		   }
X  		}
X***************
X*** 959,969 ****
X  			int xtmp = d(2,6);
X  			pline("%s suddenly seems weaker!", Monnam(mdef));
X  			mdef->mhpmax -= xtmp;
X! 			if ((mdef->mhp -= xtmp) <= 0 || !mdef->m_lev--) {
X  				pline("%s dies!", Monnam(mdef));
X  				xkilled(mdef,0);
X  				return(2);
X  			}
X  		}
X  		tmp = 0;
X  		break;
X--- 959,970 ----
X  			int xtmp = d(2,6);
X  			pline("%s suddenly seems weaker!", Monnam(mdef));
X  			mdef->mhpmax -= xtmp;
X! 			if ((mdef->mhp -= xtmp) <= 0 || !mdef->m_lev) {
X  				pline("%s dies!", Monnam(mdef));
X  				xkilled(mdef,0);
X  				return(2);
X  			}
X+ 			mdef->m_lev--;
X  		}
X  		tmp = 0;
X  		break;
X***************
X*** 1008,1016 ****
X  #ifdef MUSE
X  		if ((mdef->misc_worn_check & W_ARMH) && rn2(8)) {
X  		    pline("%s helmet blocks your attack to %s head.",
X! 			  s_suffix(Monnam(mdef)),
X! 			  (Blind || !humanoid(mdef->data)) ? "its" :
X! 				(mdef->female ? "her" : "his"));
X  		    break;
X  		}
X  #endif
X--- 1009,1015 ----
X  #ifdef MUSE
X  		if ((mdef->misc_worn_check & W_ARMH) && rn2(8)) {
X  		    pline("%s helmet blocks your attack to %s head.",
X! 			  s_suffix(Monnam(mdef)), his[pronoun_gender(mdef)]);
X  		    break;
X  		}
X  #endif
X*** /tmp/da08686	Thu Feb 25 10:25:48 1993
X--- src/vault.c	Tue Feb  9 15:55:34 1993
X***************
X*** 253,259 ****
X  		mongone(guard);
X  		return;
X  	}
X- 	clear_nhwindow(WIN_MESSAGE);
X  	verbalize("I don't know you.");
X  	if (!u.ugold && !hidden_gold())
X  	    verbalize("Please follow me.");
X--- 253,258 ----
X***************
X*** 330,341 ****
X  	for(x = lowx-1; x <= hix+1; x++)
X  	    for(y = lowy-1; y <= hiy+1; y += (hiy-lowy+2)) {
X  		if(!IS_WALL(levl[x][y].typ) && !in_fcorridor(grd, x, y)) {
X! 		    struct monst *mon;
X! 
X! 		    if((mon = m_at(x, y)) && grd->mx != x && grd->my != y) {
X  			if (mon->data->msound != MS_SILENT)
X! 			    You("hear a scream.");
X! 			rloc(m_at(x,y));
X  		    }
X  		    if ((gold = g_at(x, y)) != 0) {
X  			move_gold(gold, EGD(grd)->vroom);
X--- 329,339 ----
X  	for(x = lowx-1; x <= hix+1; x++)
X  	    for(y = lowy-1; y <= hiy+1; y += (hiy-lowy+2)) {
X  		if(!IS_WALL(levl[x][y].typ) && !in_fcorridor(grd, x, y)) {
X! 		    if(MON_AT(x, y) && grd->mx != x && grd->my != y) {
X! 			struct monst *mon = m_at(x,y);
X  			if (mon->data->msound != MS_SILENT)
X! 			    yelp(mon);
X! 			rloc(mon);
X  		    }
X  		    if ((gold = g_at(x, y)) != 0) {
X  			move_gold(gold, EGD(grd)->vroom);
X***************
X*** 368,375 ****
X  	    for(y = lowy; y <= hiy; y++) {
X  		if(!IS_WALL(levl[x][y].typ) && !in_fcorridor(grd, x, y)) {
X  		    if(MON_AT(x, y) && grd->mx != x && grd->my != y) {
X! 			You("hear a scream.");
X! 			rloc(m_at(x,y));
X  		    }
X  		    if ((gold = g_at(x, y)) != 0) {
X  			move_gold(gold, EGD(grd)->vroom);
X--- 366,375 ----
X  	    for(y = lowy; y <= hiy; y++) {
X  		if(!IS_WALL(levl[x][y].typ) && !in_fcorridor(grd, x, y)) {
X  		    if(MON_AT(x, y) && grd->mx != x && grd->my != y) {
X! 			struct monst *mon = m_at(x,y);
X! 			if (mon->data->msound != MS_SILENT)
X! 			    yelp(mon);
X! 			rloc(mon);
X  		    }
X  		    if ((gold = g_at(x, y)) != 0) {
X  			move_gold(gold, EGD(grd)->vroom);
X***************
X*** 483,489 ****
X  			    l_monnam(grd));
X  		    return(-1);
X  		} else {
X! 		    verbalize("Well, be gone your way.");
X  		    wallify_vault(grd);
X  		    egrd->gddone = 1;
X  		    goto cleanup;
X--- 483,489 ----
X  			    l_monnam(grd));
X  		    return(-1);
X  		} else {
X! 		    verbalize("Well, begone.");
X  		    wallify_vault(grd);
X  		    egrd->gddone = 1;
X  		    goto cleanup;
X***************
X*** 708,715 ****
X  	    gx = rooms[EGD(grd)->vroom].lx + rn2(2);
X  	    gy = rooms[EGD(grd)->vroom].ly + rn2(2);
X  	    Sprintf(buf,
X! 		"To Croesus: here's the gold recovered from the %s %s...",
X! 		player_mon()->mname, plname);
X  	    make_engr_at(gx, gy, buf, 0L, ENGRAVE);
X  	}
X  	place_object(gold = mkgoldobj(u.ugold), gx, gy);
X--- 708,715 ----
X  	    gx = rooms[EGD(grd)->vroom].lx + rn2(2);
X  	    gy = rooms[EGD(grd)->vroom].ly + rn2(2);
X  	    Sprintf(buf,
X! 		"To Croesus: here's the gold recovered from %s the %s.",
X! 		plname, player_mon()->mname);
X  	    make_engr_at(gx, gy, buf, 0L, ENGRAVE);
X  	}
X  	place_object(gold = mkgoldobj(u.ugold), gx, gy);
X*** /tmp/da08694	Thu Feb 25 10:25:51 1993
X--- src/version.c	Fri Feb  5 11:20:43 1993
X***************
X*** 5,11 ****
X  #include	"hack.h"
X  #include	"date.h"
X  #ifndef BETA
X! # if defined(MICRO) && !defined(AMIGA) && !defined(TOS)
X  # include	"patchlev.h"
X  # else
X  # include	"patchlevel.h"
X--- 5,11 ----
X  #include	"hack.h"
X  #include	"date.h"
X  #ifndef BETA
X! # if defined(MICRO) && !defined(AMIGA) && !defined(TOS) && !defined(OS2_HPFS)
X  # include	"patchlev.h"
X  # else
X  # include	"patchlevel.h"
X*** /tmp/da08702	Thu Feb 25 10:25:53 1993
X--- src/vision.c	Wed Feb  3 16:37:18 1993
X***************
X*** 484,490 ****
X  		    next_rmax[row] = max(next_rmax[row], col);
X  		    next_array[row][col] = IN_SIGHT;
X  		}
X! 	    }
X  
X  	/* if in a pit, just update for immediate locations */
X  	else if (u.utrap && u.utraptype == TT_PIT) {
X--- 484,490 ----
X  		    next_rmax[row] = max(next_rmax[row], col);
X  		    next_array[row][col] = IN_SIGHT;
X  		}
X! 	}
X  
X  	/* if in a pit, just update for immediate locations */
X  	else if (u.utrap && u.utraptype == TT_PIT) {
X*** /tmp/da07333	Thu Feb 25 10:19:14 1993
X--- dat/oracles.txt	Sun Feb 21 16:16:26 1993
X***************
X*** 9,14 ****
X--- 9,16 ----
X  If thou hast had trouble with rust on thy armor or weapons, thou shouldst
X  know that thou canst prevent this by, while in a confused state, reading the
X  magical parchments which normally are used to cause their enchantment.
X+ Unguents of lubrication may provide similar protection, albeit of a
X+ transitory nature.
X  -----
X  Behold the cockatrice, whose diminutive stature belies its hidden might.  The
X  cockatrice can petrify any ordinary being it contacts--save those wise
X***************
X*** 15,37 ****
X  adventurers who eat a dead lizard or blob of acid when they feel themselves
X  slowly turning to stone.
X  -----
X! While some wayfarers rely on finding finished armour in the dungeon, the
X! resourceful consider dragon scales as truly enchanting raw material and
X! realize that dragon scale mail is an excellent investment.
X  -----
X! It is well known among travelers that extra-healing draughts may clear thy
X! senses when thou art addled by hallucinations.  But never forget, the lowly
X! potion which makes one sick may be used for the same purpose.
X  -----
X! While the consumption of lizard flesh or water beloved of the gods may
X! straighten thy head after confusion, the application of the horn of a
X! creature of utmost purity can alleviate many other afflictions as well.
X  -----
X! If thou wishest to travel quickly between distant levels, thou must be
X! able to control thy teleports, and be confused, and read the scroll
X! which usually teleports thyself around on the level.  Daring adventurers
X! have also performed the same feat sans need for scrolls or potions by
X! stepping on the correct type of trap.
X  -----
X  Almost all adventurers who come this way hope to pass the dread Medusa.  To
X  do this, the best advice is to keep thine eyes blindfolded and to cause the
X--- 17,39 ----
X  adventurers who eat a dead lizard or blob of acid when they feel themselves
X  slowly turning to stone.
X  -----
X! While some wayfarers rely on scrounging finished armour in the dungeon, the
X! resourceful know the mystical means by which mail may be fashioned out of
X! scales from a dragon's hide.
X  -----
X! It is customarily known among travelers that extra-healing draughts may clear
X! thy senses when thou art addled by delusory visions.  But never forget, the
X! lowly potion which makes one sick may be used for the same purpose.
X  -----
X! While the consumption of lizard flesh or water beloved of the gods may clear
X! the muddled head, the application of the horn of a creature of utmost purity
X! can alleviate many other afflictions as well.
X  -----
X! If thou wouldst travel quickly between distant locations, thou must be
X! able to control thy teleports, and in a confused state misread the scroll
X! which usually teleports thyself locally.  Daring adventurers have also
X! performed the same feat sans need for scrolls or potions by stepping into
X! a particular ambuscade.
X  -----
X  Almost all adventurers who come this way hope to pass the dread Medusa.  To
X  do this, the best advice is to keep thine eyes blindfolded and to cause the
X***************
X*** 52,58 ****
X  even so, few hath developed the skill to identify enchanted rings by the
X  transfigurations effected upon the voracious device's frame.
X  -----
X! The meat of enchanted creatures will ofttimes convey magical properties
X  unto the consumer.  A fresh corpse of floating eye doth fetch a high
X  price among wizards for its utility in conferring Telepathy, by which
X  the sightless may locate surrounding minds.
X--- 54,60 ----
X  even so, few hath developed the skill to identify enchanted rings by the
X  transfigurations effected upon the voracious device's frame.
X  -----
X! The meat of enchanted creatures ofttimes conveyeth magical properties
X  unto the consumer.  A fresh corpse of floating eye doth fetch a high
X  price among wizards for its utility in conferring Telepathy, by which
X  the sightless may locate surrounding minds.
X***************
X*** 66,77 ****
X  powers echo throughout legend.  Learned wayfarers can reproduce blades of
X  elven lineage, hated of the orcs, without the need for such intervention.
X  -----
X- Adventurers searching for Medusa or the Wizard of Yendor needst not wait until
X- their dungeon level corresponds with their enemies' to know their location.
X- Eat a floating eye, blind thyself, and use a mirror in thine own direction,
X- and provided thou art lucky, thou shalt know the approximate locations of
X- thine enemies.
X- -----
X  There are many stories of a mighty amulet, the origins of which are said
X  to be ancient Yendor.  This amulet doth have awesome power, and the gods
X  desireth it greatly.  Mortals mayst tap only portions of its terrible
X--- 68,73 ----
X***************
X*** 88,100 ****
X  read from Moloch's book, shall cause the earth to tremble mightily.  The
X  light of an enchanted candelabrum shall show thee the way.
X  -----
X! In the nethermost recesses of the dungeon, there standeth a castle, wherein
X! layeth a wand of wishes.  If thou wouldst gain entry, bear with thee an
X! instrument of music, for the drawbridge may be charmed down with the proper
X! melody.  What notes comprise it only the gods know, but a musical mastermind
X! may yet succeed by witful improvization.  However, the less perspicacious are
X! not without recourse, should they be prepared to circumambulate the castle to
X! the postern.
X  ----- ELBERETH
X  The name of Elbereth may strike fear into the hearts of thine enemies, if
X  thou doest write it upon the ground at thy feet.  If thou maintain the utmost
X--- 84,96 ----
X  read from Moloch's book, shall cause the earth to tremble mightily.  The
X  light of an enchanted candelabrum shall show thee the way.
X  -----
X! In the deepest recesses of the Dungeons of Doom, guarding access to the
X! nether regions, there standeth a castle, wherein layeth a wand of wishes.
X! If thou wouldst gain entry, bear with thee an instrument of music, for the
X! pontlevis may be charmed down with the proper melody.  What notes comprise
X! it only the gods know, but a musical mastermind may yet succeed by witful
X! improvization.  However, the less perspicacious are not without recourse,
X! should they be prepared to circumambulate the castle to the postern.
X  ----- ELBERETH
X  The name of Elbereth may strike fear into the hearts of thine enemies, if
X  thou doest write it upon the ground at thy feet.  If thou maintain the utmost
X
END_OF_FILE
if test 54136 -ne `wc -c <'patches01i'`; then
    echo shar: \"'patches01i'\" unpacked with wrong size!
fi
# end of 'patches01i'
if test -f 'sys/amiga/hackwb.hlp' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'sys/amiga/hackwb.hlp'\" to \"'sys/amiga/hackwb.hlp.orig'\"
  mv -f 'sys/amiga/hackwb.hlp' 'sys/amiga/hackwb.hlp.orig'
fi
echo shar: Extracting \"'sys/amiga/hackwb.hlp'\" \(2203 characters\)
sed "s/^X//" >'sys/amiga/hackwb.hlp' <<'END_OF_FILE'
XHackWB provides a WorkBench-like setting for NetHack - if
Xyou know how to use WorkBench you know how to use HackWb.
XIf you prefer a command line interface, use HackCli.
XHappy Hacking!
X
XMain Window
X    Single click to select a game.
X    Double click to start a game.
X    Use the NewGame icon to start a new game.
X
XOptions Window
X    Click on the options to toggle them on/off or enter
X    strings as appropriate.
X
XEdit Game Definition Window
X    Enter name of player and select load to load previously
X    saved game definition.
X
XProject Menu
X Help        - This file...
X About       - Credit where credit is due...
X Top Scores  - View the score file.
X Recover     - Recover a game which was interrupted by a
X               GURU, Software Failure, or other disaster.
X Edit Default Game - The file wbdefaults.def is always
X               loaded to provide the default ToolTypes
X               information for the NewGame icon (specifying
X               options, character name and character type).
X               The window opened by this selection allows
X               you to edit this information as well as
X               create new "games" by changing wbdefaults to
X               a different name and using save/load.
X Edit Configuration - The string data in nethack.cnf can be
X               edited saved and loaded using the requester
X               opened by this selection.
X
XGame Menu
X Info        - This selection lets you edit the tooltypes
X               entries for the selected icons.  The Edit
X               Game Configuration  gadget lets you change
X               the options that "Edit Default Game" let you
X               enter.  
X Change Comment  - Lets you set a comment string for the
X               save file.
X Set Options - takes you directly to the options editing
X               requester.
X Copy Options - Creates a new icon with the same options as
X               the selected game.  The new Icon has no saved
X               game associated with it.
X Discard     - Deletes the icon and any saved game
X               associated with it.
X Rename      - Lets you rename the Icon file and saved game.
X               The information in the save file is not
X               changed.
END_OF_FILE
if test 2203 -ne `wc -c <'sys/amiga/hackwb.hlp'`; then
    echo shar: \"'sys/amiga/hackwb.hlp'\" unpacked with wrong size!
fi
# end of 'sys/amiga/hackwb.hlp'
echo shar: End of archive 8 \(of 31\).
cp /dev/null ark8isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 31 archives.
    echo "Now execute 'patchit.sh'"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
