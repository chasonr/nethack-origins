Subject:  v17i042:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Patch1a/31
Newsgroups: comp.sources.games
Approved: billr@saab.CNA.TEK.COM

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 17, Issue 42
Archive-name: nethack31/Patch1a
Patch-To: nethack31: Volume 16, Issue 1-116
Environment: Amiga, Atari, Mac, MS-DOS, Windows-NT, OS2, Unix, VMS, X11

	[Here's the first set of patches to NetHack 3.1. Binaries and tar
	 files will be updated in a few days.  -br]

[From the development team:]
[[We wish to thank the many people who sent us bug reports, fixes, and
suggestions for improvements.  Please keep doing this.

More polish was applied to the Amiga, Mac, and X11 windowing systems.
X11 WM_DELETE_WINDOW handling was added by David Wexelblat.  As we said
in the initial release, the Mac and the Amiga ports are still in
development.  You will find them to be much improved, but there is more
work to be done.  Make constructive comments.

The instrument sound files were broken out from their Mac-specific format
and are now being used by the Amiga port.

A Windows NT console port was provided by Michael Allison.

Various portability fixes for more UNIX makes and HPUX versions.

Many small bugs were fixed.  Some of the most popular include misconfiguring
windowing systems, the wrong phase of the moon for some micro ports,
polymorphing into bees, "ghosts" left by reeling monsters, throwing Mjollnir
at walls, various problems with shop payment, mysterious rust damage on damp
levels, Bells of Opening for Tourists, and bones on endgame levels.

Many, many small changes having to do with message phrasing (thanks to
Felix Lee) and Amiga declaration syntax for their new compiler version
(transparent to other ports).

Please NOTE:  Old save/bones files should be deleted.  They will NOT
work with NetHack 3.1.1.]]


#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 31)."
# Contents:  MANIFEST_P1 patches01d sys sys/amiga sys/mac sys/share
#   sys/share/sounds sys/winnt
# Wrapped by billr@saab on Fri Mar  5 10:50:41 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'MANIFEST_P1' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'MANIFEST_P1'\" to \"'MANIFEST_P1.orig'\"
  mv -f 'MANIFEST_P1' 'MANIFEST_P1.orig'
fi
echo shar: Extracting \"'MANIFEST_P1'\" \(2123 characters\)
sed "s/^X//" >'MANIFEST_P1' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X MANIFEST_P1                1	This shipping list
X UPDATE1                   10	
X patches01a                 2	
X patches01b                16	
X patches01c                 9	
X patches01d                 1	
X patches01e                 6	
X patches01f                 4	
X patches01g                14	
X patches01h                 7	
X patches01i                 8	
X patches01j                 5	
X patches01k                 3	
X patches01l                17	
X patches01m                30	
X patches01n                19	
X patches01o                13	
X patches01p                12	
X patches01q                18	
X patches01r                15	
X patches01s                10	
X patches01t.uu1            25	
X patches01t.uu2            22	
X patchit.sh                 3	
X sys                        1	
X sys/amiga                  1	
X sys/amiga/amisnd.c        30	
X sys/amiga/colors.uu       12	
X sys/amiga/cvtsnd.c        11	
X sys/amiga/hackwb.hlp       8	
X sys/amiga/wbwin.uu        26	
X sys/mac                    1	
X sys/mac/NHmake.hqx        23	
X sys/mac/NHrez.hqx         28	
X sys/mac/NHrsrc.hqx        27	
X sys/share                  1	
X sys/share/dgn_lex.c       21	
X sys/share/lev_lex.c1      24	
X sys/share/lev_lex.c2      23	
X sys/share/lev_yacc.c1     20	
X sys/share/lev_yacc.c2     27	
X sys/share/sounds           1	
X sys/share/sounds/README    7	
X sys/share/sounds/bell.uu  28	
X sys/share/sounds/bugle.uu 29	
X sys/share/sounds/erthdrum.uu 11	
X sys/share/sounds/firehorn.uu 21	
X sys/share/sounds/frsthorn.uu 29	
X sys/share/sounds/lethdrum.uu 26	
X sys/share/sounds/mgcflute.uu 28	
X sys/share/sounds/mgcharp.uu 25	
X sys/share/sounds/toolhorn.uu 24	
X sys/share/sounds/wdnflute.uu 22	
X sys/share/sounds/wdnharp.uu 29	
X sys/winnt                  1	
X sys/winnt/Install.nt      30	
X sys/winnt/Makefile.dat    19	
X sys/winnt/Makefile.src    30	
X sys/winnt/Makefile.utl    20	
X sys/winnt/nhico.uu        14	
X sys/winnt/nhincl.mak      31	
X sys/winnt/nttty.c         30	
X sys/winnt/setup.bat       13	
X sys/winnt/winnt.c          9	
END_OF_FILE
if test 2123 -ne `wc -c <'MANIFEST_P1'`; then
    echo shar: \"'MANIFEST_P1'\" unpacked with wrong size!
fi
# end of 'MANIFEST_P1'
if test -f 'patches01d' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'patches01d'\" to \"'patches01d.orig'\"
  mv -f 'patches01d' 'patches01d.orig'
fi
echo shar: Extracting \"'patches01d'\" \(51083 characters\)
sed "s/^X//" >'patches01d' <<'END_OF_FILE'
X*** /tmp/da08221	Thu Feb 25 10:23:13 1993
X--- src/files.c	Sun Feb 21 16:41:38 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)files.c	3.1	92/12/07	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)files.c	3.1	93/02/20	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 17,23 ****
X  #include <signal.h>
X  #endif
X  
X! #if defined(MSDOS) || defined(OS2) || defined(TOS)
X  # ifndef GNUDOS
X  #include <sys\stat.h>
X  # else
X--- 17,23 ----
X  #include <signal.h>
X  #endif
X  
X! #if defined(MSDOS) || defined(OS2) || defined(TOS) || defined(WIN32)
X  # ifndef GNUDOS
X  #include <sys\stat.h>
X  # else
X***************
X*** 63,68 ****
X--- 63,70 ----
X  extern char PATH[];	/* see sys/amiga/amidos.c */
X  #endif
X  
X+ extern int n_dgns;		/* from dungeon.c */
X+ 
X  static char * FDECL(set_bonesfile_name, (char *,d_level*));
X  
X  /* fopen a file, with OS-dependent bells and whistles */
X***************
X*** 146,156 ****
X  	 */
X  	fd = open(lock, O_WRONLY |O_CREAT | O_TRUNC | O_BINARY, FCMASK);
X  #else
X! #ifdef MAC
X! 	fd = maccreat ( lock , LEVL_TYPE ) ;
X! #else /* MAC */
X  	fd = creat(lock, FCMASK);
X! #endif /* MAC */
X  #endif /* MICRO */
X  
X  	return fd;
X--- 148,158 ----
X  	 */
X  	fd = open(lock, O_WRONLY |O_CREAT | O_TRUNC | O_BINARY, FCMASK);
X  #else
X! # ifdef MAC
X! 	fd = maccreat(lock, LEVL_TYPE);
X! # else
X  	fd = creat(lock, FCMASK);
X! # endif
X  #endif /* MICRO */
X  
X  	return fd;
X***************
X*** 169,179 ****
X  	if (fileinfo[lev].where != ACTIVE)
X  		swapin_file(lev);
X  #endif
X! # ifdef MAC
X! 	fd = macopen ( lock , O_RDONLY | O_BINARY , LEVL_TYPE ) ;
X! # else /* MAC */
X  	fd = open(lock, O_RDONLY | O_BINARY, 0);
X! # endif /* MAC */
X  	return fd;
X  }
X  
X--- 171,181 ----
X  	if (fileinfo[lev].where != ACTIVE)
X  		swapin_file(lev);
X  #endif
X! #ifdef MAC
X! 	fd = macopen(lock, O_RDONLY | O_BINARY, LEVL_TYPE);
X! #else
X  	fd = open(lock, O_RDONLY | O_BINARY, 0);
X! #endif
X  	return fd;
X  }
X  
X***************
X*** 202,208 ****
X  # if defined(UNIX) || defined(VMS)
X  	(void) signal(SIGHUP, SIG_IGN);
X  # endif
X! 	for (x = maxledgerno(); x >= 0; x--)
X  		delete_levelfile(x);	/* not all levels need be present */
X  #endif
X  }
X--- 204,211 ----
X  # if defined(UNIX) || defined(VMS)
X  	(void) signal(SIGHUP, SIG_IGN);
X  # endif
X! 	/* can't access maxledgerno() before dungeons are created -dlc */
X! 	for (x = (n_dgns ? maxledgerno() : 0); x >= 0; x--)
X  		delete_levelfile(x);	/* not all levels need be present */
X  #endif
X  }
X***************
X*** 253,263 ****
X  	fd = open(bones, O_WRONLY |O_CREAT | O_TRUNC | O_BINARY, FCMASK);
X  #else
X  # ifdef MAC
X! 	fd = maccreat ( bones , BONE_TYPE ) ;
X! # else /* MAC */
X  	fd = creat(bones, FCMASK);
X! # endif /* MAC */
X! #  if defined(VMS) && !defined(SECURE)
X  	/*
X  	   Re-protect bones file with world:read+write+execute+delete access.
X  	   umask() doesn't seem very reliable; also, vaxcrtl won't let us set
X--- 256,266 ----
X  	fd = open(bones, O_WRONLY |O_CREAT | O_TRUNC | O_BINARY, FCMASK);
X  #else
X  # ifdef MAC
X! 	fd = maccreat(bones, BONE_TYPE);
X! # else
X  	fd = creat(bones, FCMASK);
X! # endif
X! # if defined(VMS) && !defined(SECURE)
X  	/*
X  	   Re-protect bones file with world:read+write+execute+delete access.
X  	   umask() doesn't seem very reliable; also, vaxcrtl won't let us set
X***************
X*** 267,273 ****
X  	   denies some or all access to world.
X  	 */
X  	(void) chmod(bones, FCMASK | 007);  /* allow other users full access */
X! #  endif /* VMS && !SECURE */
X  #endif /* MICRO */
X  
X  	return fd;
X--- 270,276 ----
X  	   denies some or all access to world.
X  	 */
X  	(void) chmod(bones, FCMASK | 007);  /* allow other users full access */
X! # endif /* VMS && !SECURE */
X  #endif /* MICRO */
X  
X  	return fd;
X***************
X*** 284,290 ****
X  	*bonesid = set_bonesfile_name(bones, lev);
X  	uncompress(bones);	/* no effect if nonexistent */
X  #ifdef MAC
X! 	fd = macopen ( bones , O_RDONLY | O_BINARY , BONE_TYPE ) ;
X  #else
X  	fd = open(bones, O_RDONLY | O_BINARY, 0);
X  #endif
X--- 287,293 ----
X  	*bonesid = set_bonesfile_name(bones, lev);
X  	uncompress(bones);	/* no effect if nonexistent */
X  #ifdef MAC
X! 	fd = macopen(bones, O_RDONLY | O_BINARY, BONE_TYPE);
X  #else
X  	fd = open(bones, O_RDONLY | O_BINARY, 0);
X  #endif
X***************
X*** 340,347 ****
X  # else
X  	Sprintf(SAVEF, "save/%d%s", (int)getuid(), plname);
X  	regularize(SAVEF+5);	/* avoid . or / in name */
X! # endif
X! #endif
X  }
X  
X  #ifdef INSURANCE
X--- 343,350 ----
X  # else
X  	Sprintf(SAVEF, "save/%d%s", (int)getuid(), plname);
X  	regularize(SAVEF+5);	/* avoid . or / in name */
X! # endif	/* MICRO */
X! #endif	/* VMS */
X  }
X  
X  #ifdef INSURANCE
X***************
X*** 366,376 ****
X        }
X  	Strcat(SAVEF, ".e;1");
X  # else
X! #ifdef MAC
X  	Strcat(SAVEF, "-e");
X! #else
X  	Strcat(SAVEF, ".e");
X! #endif
X  # endif
X  }
X  #endif
X--- 369,379 ----
X        }
X  	Strcat(SAVEF, ".e;1");
X  # else
X! #  ifdef MAC
X  	Strcat(SAVEF, "-e");
X! #  else
X  	Strcat(SAVEF, ".e");
X! #  endif
X  # endif
X  }
X  #endif
X***************
X*** 381,410 ****
X  create_savefile()
X  {
X  	int fd;
X! # ifdef AMIGA
X  	fd = ami_wbench_getsave(O_WRONLY | O_CREAT | O_TRUNC);
X! # else
X! #  ifdef MICRO
X  	fd = open(SAVEF, O_WRONLY | O_BINARY | O_CREAT | O_TRUNC, FCMASK);
X  #  else
X- #   ifdef MAC
X- 	fd = creat(SAVEF, SAVE_TYPE);
X- #   else /* MAC */
X  	fd = creat(SAVEF, FCMASK);
X! #   endif /* MAC */
X! #   if defined(VMS) && !defined(SECURE)
X  	/*
X  	   Make sure the save file is owned by the current process.  That's
X  	   the default for non-privileged users, but for priv'd users the
X  	   file will be owned by the directory's owner instead of the user.
X  	 */
X! #    ifdef getuid	/*(see vmsunix.c)*/
X! #     undef getuid
X! #    endif
X  	(void) chown(SAVEF, getuid(), getgid());
X! #   endif /* VMS && !SECURE */
X! #  endif
X! # endif
X  
X  	return fd;
X  }
X--- 384,413 ----
X  create_savefile()
X  {
X  	int fd;
X! #ifdef AMIGA
X  	fd = ami_wbench_getsave(O_WRONLY | O_CREAT | O_TRUNC);
X! #else
X! # ifdef MICRO
X  	fd = open(SAVEF, O_WRONLY | O_BINARY | O_CREAT | O_TRUNC, FCMASK);
X+ # else
X+ #  ifdef MAC
X+ 	fd = maccreat(SAVEF, SAVE_TYPE);
X  #  else
X  	fd = creat(SAVEF, FCMASK);
X! #  endif
X! #  if defined(VMS) && !defined(SECURE)
X  	/*
X  	   Make sure the save file is owned by the current process.  That's
X  	   the default for non-privileged users, but for priv'd users the
X  	   file will be owned by the directory's owner instead of the user.
X  	 */
X! #   ifdef getuid	/*(see vmsunix.c)*/
X! #    undef getuid
X! #   endif
X  	(void) chown(SAVEF, getuid(), getgid());
X! #  endif /* VMS && !SECURE */
X! # endif	/* MICRO */
X! #endif	/* AMIGA */
X  
X  	return fd;
X  }
X***************
X*** 420,429 ****
X  	fd = ami_wbench_getsave(O_RDONLY);
X  #else
X  # ifdef MAC
X! 	fd = macopen ( SAVEF , O_RDONLY , SAVE_TYPE ) ;
X! # else /* MAC */
X! 	fd = open(SAVEF, O_RDONLY, 0);
X! # endif /* MAC */
X  #endif /* AMIGA */
X  	return fd;
X  }
X--- 423,432 ----
X  	fd = ami_wbench_getsave(O_RDONLY);
X  #else
X  # ifdef MAC
X! 	fd = macopen(SAVEF, O_RDONLY | O_BINARY, SAVE_TYPE);
X! # else
X! 	fd = open(SAVEF, O_RDONLY | O_BINARY, 0);
X! # endif
X  #endif /* AMIGA */
X  	return fd;
X  }
X***************
X*** 476,482 ****
X  	int fd;
X  
X  	Strcpy(cfn,filename);
X! 	Strcat(cfn,".Z");
X  	if((fd = open(cfn,O_RDONLY)) >= 0) {
X  	    (void) close(fd);
X  	    Strcpy(cmd, COMPRESS);
X--- 479,487 ----
X  	int fd;
X  
X  	Strcpy(cfn,filename);
X! # ifdef COMPRESS_EXTENSION
X! 	Strcat(cfn,COMPRESS_EXTENSION);
X! # endif
X  	if((fd = open(cfn,O_RDONLY)) >= 0) {
X  	    (void) close(fd);
X  	    Strcpy(cmd, COMPRESS);
X***************
X*** 556,561 ****
X--- 561,574 ----
X  			HUP raw_printf("No write permission to lock %s!",
X  				       filename);
X  			return FALSE;
X+ # ifdef VMS			/* c__translate(vmsfiles.c) */
X+ 		    case EPERM:
X+ 			/* could be misleading, but usually right */
X+ 			HUP raw_printf(
X+ 				  "Can't lock %s due to directory protection.",
X+ 				       filename);
X+ 			return FALSE;
X+ # endif
X  		    case EEXIST:
X  			break;	/* retry checks below */
X  		    default:
X***************
X*** 620,631 ****
X  #ifdef UNIX
X  			".nethackrc";
X  #else
X! #ifdef MAC
X  			"NetHack defaults";
X! #else
X  			"NetHack.cnf";
X  #endif
X- #endif
X  
X  static FILE *FDECL(fopen_config_file, (const char *));
X  static int FDECL(get_uchars, (FILE *, char *, char *, uchar *, int, const char *));
X--- 633,644 ----
X  #ifdef UNIX
X  			".nethackrc";
X  #else
X! # ifdef MAC
X  			"NetHack defaults";
X! # else
X  			"NetHack.cnf";
X+ # endif
X  #endif
X  
X  static FILE *FDECL(fopen_config_file, (const char *));
X  static int FDECL(get_uchars, (FILE *, char *, char *, uchar *, int, const char *));
X***************
X*** 825,838 ****
X  #ifdef AMIGA
X  	} else if (!strncmpi(buf, "PATH", 4)) {
X  		(void) strncpy(PATH, bufp, PATHLEN);
X  	} else if (!strncmpi(buf, "PENS", 3)) {
X  		int i;
X  		char *t;
X- 		extern unsigned short amii_curmap[];
X  		for (i = 0, t = strtok(bufp, ",");
X  				t && i < 8;
X  				t = strtok(NULL, ","), ++i) {
X! 			sscanf(t, "%hx", &amii_curmap[i]);
X  		}
X  		amii_setpens();
X  #endif
X--- 838,852 ----
X  #ifdef AMIGA
X  	} else if (!strncmpi(buf, "PATH", 4)) {
X  		(void) strncpy(PATH, bufp, PATHLEN);
X+ #endif
X+ #ifdef AMII_GRAPHICS
X  	} else if (!strncmpi(buf, "PENS", 3)) {
X  		int i;
X  		char *t;
X  		for (i = 0, t = strtok(bufp, ",");
X  				t && i < 8;
X  				t = strtok(NULL, ","), ++i) {
X! 			sscanf(t, "%hx", &flags.amii_curmap[i]);
X  		}
X  		amii_setpens();
X  #endif
X***************
X*** 861,888 ****
X  	char	buf[BUFSZ];
X  	FILE	*fp;
X  
X! #if defined(MAC)
X! 	{
X! 		long nul = 0L ;
X! 		Str255 volName ;
X! 		/*
X! 		 * We should try and get this data from a rsrc, in the profile file
X! 		 * the user double-clicked... This data should be saved with the
X! 		 * save file in the resource fork, AND be saveable in "stationery"
X! 		 */
X! 		GetVol ( volName , & theDirs . dataRefNum ) ;
X! 		GetWDInfo ( theDirs . dataRefNum , & theDirs . dataRefNum , & theDirs .
X! 			dataDirID , & nul ) ;
X! 		if ( volName [ 0 ] > 31 ) volName [ 0 ] = 31 ;
X! 		for ( nul = 1 ; nul <= volName [ 0 ] ; nul ++ ) {
X! 			if ( volName [ nul ] == ':' ) {
X! 				volName [ nul ] = 0 ;
X! 				volName [ 0 ] = nul - 1 ;
X! 				break ;
X! 			}
X  		}
X- 		BlockMove ( volName , theDirs . dataName , 32L ) ;
X  	}
X  #endif /* MAC */
X  
X  	if (!(fp = fopen_config_file(filename))) return;
X--- 875,900 ----
X  	char	buf[BUFSZ];
X  	FILE	*fp;
X  
X! #ifdef MAC
X! 	long nul = 0L ;
X! 	Str255 volName ;
X! 	/*
X! 	 * We should try to get this data from a rsrc, in the profile file
X! 	 * the user double-clicked...  This data should be saved with the
X! 	 * save file in the resource fork, AND be saveable in "stationery"
X! 	 */
X! 	GetVol ( volName , & theDirs . dataRefNum ) ;
X! 	GetWDInfo ( theDirs . dataRefNum , & theDirs . dataRefNum , & theDirs .
X! 		dataDirID , & nul ) ;
X! 	if ( volName [ 0 ] > 31 ) volName [ 0 ] = 31 ;
X! 	for ( nul = 1 ; nul <= volName [ 0 ] ; nul ++ ) {
X! 		if ( volName [ nul ] == ':' ) {
X! 			volName [ nul ] = 0 ;
X! 			volName [ 0 ] = nul - 1 ;
X! 			break ;
X  		}
X  	}
X+ 	BlockMove ( volName , theDirs . dataName , 32L ) ;
X  #endif /* MAC */
X  
X  	if (!(fp = fopen_config_file(filename))) return;
X*** /tmp/da08229	Thu Feb 25 10:23:16 1993
X--- src/fountain.c	Tue Feb 16 16:10:19 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)fountain.c	3.1	92/12/19	*/
X  /*	Copyright Scott R. Turner, srt@ucla, 10/27/86 */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)fountain.c	3.1	93/02/13	*/
X  /*	Copyright Scott R. Turner, srt@ucla, 10/27/86 */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 41,54 ****
X  	if(mons[PM_WATER_DEMON].geno & (G_GENOD | G_EXTINCT)) return;
X  	if((mtmp = makemon(&mons[PM_WATER_DEMON],u.ux,u.uy))) {
X  	    if (!Blind)
X! 		You("have unleashed %s!", a_monnam(mtmp));
X  	    else
X  		You("feel the presence of evil.");
X  
X  	/* Give those on low levels a (slightly) better chance of survival */
X! 	    if ( rnd(100) > (80 + level_difficulty())) {
X  		pline("Grateful for %s release, %s grants you a wish!",
X! 			Blind ? "its" : "his", Blind ? "it" : "he" );
X  		makewish();
X  		mongone(mtmp);
X  	    } else if (t_at(mtmp->mx, mtmp->my))
X--- 41,54 ----
X  	if(mons[PM_WATER_DEMON].geno & (G_GENOD | G_EXTINCT)) return;
X  	if((mtmp = makemon(&mons[PM_WATER_DEMON],u.ux,u.uy))) {
X  	    if (!Blind)
X! 		You("unleash %s!", a_monnam(mtmp));
X  	    else
X  		You("feel the presence of evil.");
X  
X  	/* Give those on low levels a (slightly) better chance of survival */
X! 	    if (rnd(100) > (80 + level_difficulty())) {
X  		pline("Grateful for %s release, %s grants you a wish!",
X! 		      his[pronoun_gender(mtmp)], he[pronoun_gender(mtmp)]);
X  		makewish();
X  		mongone(mtmp);
X  	    } else if (t_at(mtmp->mx, mtmp->my))
X***************
X*** 64,70 ****
X  	if(mons[PM_WATER_NYMPH].geno & (G_GENOD | G_EXTINCT)) return;
X  	if((mtmp = makemon(&mons[PM_WATER_NYMPH],u.ux,u.uy))) {
X  		if (!Blind)
X! 		   You("have attracted %s!", a_monnam(mtmp));
X  		else
X  		   You("hear a seductive voice.");
X  		mtmp->msleep = 0;
X--- 64,70 ----
X  	if(mons[PM_WATER_NYMPH].geno & (G_GENOD | G_EXTINCT)) return;
X  	if((mtmp = makemon(&mons[PM_WATER_NYMPH],u.ux,u.uy))) {
X  		if (!Blind)
X! 		   You("attract %s!", a_monnam(mtmp));
X  		else
X  		   You("hear a seductive voice.");
X  		mtmp->msleep = 0;
X***************
X*** 111,116 ****
X--- 111,118 ----
X  
X  	levl[x][y].typ = POOL;
X  
X+ 	water_damage(level.objects[x][y], FALSE, TRUE);
X+ 
X  	if ((mtmp = m_at(x, y)) != 0)
X  		(void) minwater(mtmp);
X  	else
X***************
X*** 153,159 ****
X  			    }
X  			}
X  			/* You can see or hear this effect */
X! 			if(!mtmp) pline("The waterflow reduces to a trickle.");
X  			return;
X  		}
X  #ifdef WIZARD
X--- 155,161 ----
X  			    }
X  			}
X  			/* You can see or hear this effect */
X! 			if(!mtmp) pline("The flow reduces to a trickle.");
X  			return;
X  		}
X  #ifdef WIZARD
X***************
X*** 450,456 ****
X  		return;
X  	}
X  	switch(rn2(20)) {
X! 		static struct obj NEARDATA *otmp;
X  		case 0: You("take a sip of very cold water.");
X  			break;
X  		case 1: You("take a sip of very warm water.");
X--- 452,458 ----
X  		return;
X  	}
X  	switch(rn2(20)) {
X! 		static NEARDATA struct obj *otmp;
X  		case 0: You("take a sip of very cold water.");
X  			break;
X  		case 1: You("take a sip of very warm water.");
X***************
X*** 463,469 ****
X  		case 3: if (mons[PM_SEWER_RAT].geno & (G_GENOD | G_EXTINCT))
X  				pline("The sink seems quite dirty.");
X  			else {
X! 				static struct monst NEARDATA *mtmp;
X  
X  				mtmp = makemon(&mons[PM_SEWER_RAT], u.ux, u.uy);
X  				pline("Eek!  There's %s in the sink!",
X--- 465,471 ----
X  		case 3: if (mons[PM_SEWER_RAT].geno & (G_GENOD | G_EXTINCT))
X  				pline("The sink seems quite dirty.");
X  			else {
X! 				static NEARDATA struct monst *mtmp;
X  
X  				mtmp = makemon(&mons[PM_SEWER_RAT], u.ux, u.uy);
X  				pline("Eek!  There's %s in the sink!",
X***************
X*** 479,490 ****
X  				}
X  			} while(!otmp);
X  			otmp->cursed = otmp->blessed = 0;
X! 			if (Blind)
X! 				pline("The sink emits some odd liquid.");
X! 			else
X! 				pline("The sink emits a stream of %s water.",
X! 				    Hallucination ? hcolor() :
X! 				    OBJ_DESCR(objects[otmp->otyp]));
X  			otmp->dknown = !(Blind || Hallucination);
X  			otmp->quan++; /* Avoid panic upon useup() */
X  			otmp->corpsenm = 1; /* kludge for docall() */
X--- 481,490 ----
X  				}
X  			} while(!otmp);
X  			otmp->cursed = otmp->blessed = 0;
X! 			pline("Some %s liquid flows from the faucet.",
X! 			      Blind ? "odd" :
X! 			      Hallucination ? hcolor() :
X! 			      OBJ_DESCR(objects[otmp->otyp]));
X  			otmp->dknown = !(Blind || Hallucination);
X  			otmp->quan++; /* Avoid panic upon useup() */
X  			otmp->corpsenm = 1; /* kludge for docall() */
X*** /tmp/da08237	Thu Feb 25 10:23:18 1993
X--- src/hack.c	Wed Feb 24 16:22:24 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)hack.c	3.1	92/12/04	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)hack.c	3.1	93/02/18	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 162,168 ****
X  		long lastmovetime;
X  		lastmovetime = 0;
X  #else
X! 		static long NEARDATA lastmovetime;
X  #endif
X  		/* note: this var contains garbage initially and
X  		   after a restore */
X--- 162,168 ----
X  		long lastmovetime;
X  		lastmovetime = 0;
X  #else
X! 		static NEARDATA long lastmovetime;
X  #endif
X  		/* note: this var contains garbage initially and
X  		   after a restore */
X***************
X*** 224,235 ****
X  {
X      struct rm *lev      = &(levl[x][y]);
X      struct obj *boulder = sobj_at(BOULDER,x,y);
X  
X      if (dig_pos.x != x || dig_pos.y != y ||
X  				!on_level(&dig_level, &u.uz) || dig_down) {
X! 	if (!boulder && (lev->diggable & W_NONDIGGABLE))
X  	    You("hurt your teeth on the hard stone.");
X! 	else {
X  	    dig_down = FALSE;
X  	    dig_pos.x = x;
X  	    dig_pos.y = y;
X--- 224,238 ----
X  {
X      struct rm *lev      = &(levl[x][y]);
X      struct obj *boulder = sobj_at(BOULDER,x,y);
X+     register boolean shopedge = *in_rooms(x, y, SHOPBASE);
X+     register const char *digtxt = (const char*) 0, *dmgtxt = (const char*) 0;
X  
X      if (dig_pos.x != x || dig_pos.y != y ||
X  				!on_level(&dig_level, &u.uz) || dig_down) {
X! 	if (!boulder && (lev->diggable & W_NONDIGGABLE)) {
X  	    You("hurt your teeth on the hard stone.");
X! 	    nomul(0);
X! 	} else {
X  	    dig_down = FALSE;
X  	    dig_pos.x = x;
X  	    dig_pos.y = y;
X***************
X*** 250,257 ****
X      }
X  
X      if (boulder) {
X- 	You("eat the boulder.");	/* yum */
X  	delobj(boulder);		/* boulder goes bye-bye */
X  
X  	/*
X  	 *  The location could still block because of
X--- 253,260 ----
X      }
X  
X      if (boulder) {
X  	delobj(boulder);		/* boulder goes bye-bye */
X+ 	You("eat the boulder.");	/* yum */
X  
X  	/*
X  	 *  The location could still block because of
X***************
X*** 267,273 ****
X  	}
X  	
X      } else if (IS_WALL(lev->typ)) {
X! 	You("chew a hole in the wall.");
X  	if (level.flags.is_maze_lev) {
X  	    lev->typ = ROOM;
X  	} else if (level.flags.is_cavernous_lev) {
X--- 270,280 ----
X  	}
X  	
X      } else if (IS_WALL(lev->typ)) {
X! 	if(shopedge) {
X! 	    add_damage(x, y, 10L * ACURRSTR);
X! 	    dmgtxt = "damage";
X! 	}
X! 	digtxt = "chew a hole in the wall.";
X  	if (level.flags.is_maze_lev) {
X  	    lev->typ = ROOM;
X  	} else if (level.flags.is_cavernous_lev) {
X***************
X*** 278,307 ****
X  	}
X      } else if (lev->typ == SDOOR) {
X  	if (lev->doormask & D_TRAPPED) {
X- 	    b_trapped("secret door");
X  	    lev->doormask = D_NODOOR;
X  	} else {
X! 	    You("chew through the secret door.");
X  	    lev->doormask = D_BROKEN;
X  	}
X  	lev->typ = DOOR;
X  
X      } else if (IS_DOOR(lev->typ)) {
X  	if (lev->doormask & D_TRAPPED) {
X- 	    b_trapped("door");
X  	    lev->doormask = D_NODOOR;
X  	} else {
X! 	    You("chew through the door.");
X  	    lev->doormask = D_BROKEN;
X  	}
X  
X      } else { /* STONE or SCORR */
X! 	You("chew a passage through the rock.");
X  	lev->typ = CORR;
X      }
X  
X      unblock_point(x, y);	/* vision */
X      newsym(x, y);
X      dig_level.dnum = 0;
X      dig_level.dlevel = -1;
X      return 0;
X--- 285,321 ----
X  	}
X      } else if (lev->typ == SDOOR) {
X  	if (lev->doormask & D_TRAPPED) {
X  	    lev->doormask = D_NODOOR;
X+ 	    b_trapped("secret door");
X  	} else {
X! 	    digtxt = "chew through the secret door.";
X  	    lev->doormask = D_BROKEN;
X  	}
X  	lev->typ = DOOR;
X  
X      } else if (IS_DOOR(lev->typ)) {
X+ 	if(shopedge) {
X+ 	    add_damage(x, y, 400L);
X+ 	    dmgtxt = "break";
X+ 	}
X  	if (lev->doormask & D_TRAPPED) {
X  	    lev->doormask = D_NODOOR;
X+ 	    b_trapped("door");
X  	} else {
X! 	    digtxt = "chew through the door.";
X  	    lev->doormask = D_BROKEN;
X  	}
X  
X      } else { /* STONE or SCORR */
X! 	digtxt = "chew a passage through the rock.";
X  	lev->typ = CORR;
X      }
X  
X      unblock_point(x, y);	/* vision */
X      newsym(x, y);
X+     if (digtxt) You(digtxt);	/* after newsym */
X+     if (dmgtxt)
X+ 	pay_for_damage(dmgtxt);
X      dig_level.dnum = 0;
X      dig_level.dlevel = -1;
X      return 0;
X***************
X*** 379,384 ****
X--- 393,405 ----
X  return (!(IS_STWALL(levl[x][y].typ) && (levl[x][y].diggable & W_NONDIGGABLE)));
X  }
X  
X+ boolean
X+ may_passwall(x,y)
X+ register xchar x,y;
X+ {
X+ return (!(IS_STWALL(levl[x][y].typ) && (levl[x][y].diggable & W_NONPASSWALL)));
X+ }
X+ 
X  #endif /* OVLB */
X  #ifdef OVL1
X  
X***************
X*** 388,394 ****
X  {
X  	return(IS_ROCK(levl[x][y].typ)
X  #ifdef POLYSELF
X! 		    && !passes_walls(uasmon)
X  		    && (!tunnels(uasmon) || needspick(uasmon) || !may_dig(x,y))
X  #endif
X  	);
X--- 409,415 ----
X  {
X  	return(IS_ROCK(levl[x][y].typ)
X  #ifdef POLYSELF
X! 		    && !(passes_walls(uasmon) && may_passwall(x,y))
X  		    && (!tunnels(uasmon) || needspick(uasmon) || !may_dig(x,y))
X  #endif
X  	);
X***************
X*** 643,649 ****
X  	if (IS_ROCK(tmpr->typ)) {
X  	    if (Blind) feel_location(x,y);
X  #ifdef POLYSELF
X! 	    if (passes_walls(uasmon)) {
X  		;	/* do nothing */
X  	    } else if (tunnels(uasmon) && !needspick(uasmon)) {
X  		/* Eat the rock. */
X--- 664,670 ----
X  	if (IS_ROCK(tmpr->typ)) {
X  	    if (Blind) feel_location(x,y);
X  #ifdef POLYSELF
X! 	    if (passes_walls(uasmon) && may_passwall(x,y)) {
X  		;	/* do nothing */
X  	    } else if (tunnels(uasmon) && !needspick(uasmon)) {
X  		/* Eat the rock. */
X***************
X*** 781,792 ****
X  		int swap_result;
X  
X  		/* if trapped, there's a chance the pet goes wild */
X! 		if (mtmp->mtrapped && !rn2(4)) {
X! 		    pline ("%s suddenly goes wild!",
X! 			   mtmp->mnamelth ? NAME(mtmp) : Monnam(mtmp));
X! 		    mtmp->mtame = mtmp->mpeaceful = mtmp->msleep = 0;
X! 		}
X  
X  		mtmp->mtrapped = 0;
X  		mtmp->mundetected = 0;
X  		remove_monster(x, y);
X--- 802,823 ----
X  		int swap_result;
X  
X  		/* if trapped, there's a chance the pet goes wild */
X! 		if (mtmp->mtrapped) {
X! 		    if (!rn2(mtmp->mtame)) {
X! 			mtmp->mtame = mtmp->mpeaceful = mtmp->msleep = 0;
X! #ifndef SOUNDS
X! 			pline ("%s suddenly goes wild!",
X! 			       mtmp->mnamelth ? NAME(mtmp) : Monnam(mtmp));
X! #else
X! 		        growl(mtmp);
X! 		    } else {
X! 		        yelp(mtmp);
X! #endif
X! 		    }
X! 	        }
X  
X+ 		if(!mtmp->mtame) newsym(mtmp->mx, mtmp->my);
X+ 
X  		mtmp->mtrapped = 0;
X  		mtmp->mundetected = 0;
X  		remove_monster(x, y);
X***************
X*** 807,817 ****
X  		case 1:	/* trapped */
X  		case 3: /* changed levels */
X  		    /* there's already been a trap message, reinforce it */
X  		    pline("Trapping your pet was a selfish move.");
X! 		    if (!rn2(4)) {
X! 			pline("You'll pay!");
X! 			adjalign(-5);
X! 		    }
X  		    break;
X  		case 2:
X  		    /* it may have drowned or died.  that's no way to
X--- 838,848 ----
X  		case 1:	/* trapped */
X  		case 3: /* changed levels */
X  		    /* there's already been a trap message, reinforce it */
X+ 		    abuse_dog(mtmp);
X+ #ifndef SOUNDS	/* else complaint from abuse_dog() */
X  		    pline("Trapping your pet was a selfish move.");
X! #endif
X! 		    adjalign(-3);
X  		    break;
X  		case 2:
X  		    /* it may have drowned or died.  that's no way to
X***************
X*** 820,826 ****
X  		    if (rn2(4)) {
X  			pline ("%s complains in a booming voice:", u_gname());
X  			verbalize("Losing your pet like this was a mistake!");
X! 			u.ugangr++ ;
X  			adjalign(-15);
X  		    }
X  		    break;
X--- 851,857 ----
X  		    if (rn2(4)) {
X  			pline ("%s complains in a booming voice:", u_gname());
X  			verbalize("Losing your pet like this was a mistake!");
X! 			u.ugangr++;
X  			adjalign(-15);
X  		    }
X  		    break;
X***************
X*** 915,924 ****
X  		}
X  		else if (Is_waterlevel(&u.uz))
X  			goto stillinwater;
X! 		else if (Levitation || is_floater(uasmon))
X  			You("pop out of the water like a cork!");
X  		else if (is_flyer(uasmon))
X  			You("fly out of the water.");
X  		else if (Wwalking)
X  			You("slowly rise above the surface.");
X  		else
X--- 946,957 ----
X  		}
X  		else if (Is_waterlevel(&u.uz))
X  			goto stillinwater;
X! 		else if (Levitation)
X  			You("pop out of the water like a cork!");
X+ #ifdef POLYSELF
X  		else if (is_flyer(uasmon))
X  			You("fly out of the water.");
X+ #endif
X  		else if (Wwalking)
X  			You("slowly rise above the surface.");
X  		else
X***************
X*** 1133,1139 ****
X  	    return;		/* no entrance messages necessary */
X  
X  	/* Did we just enter a shop? */
X! 	if (*u.ushops_entered)
X              u_entered_shop(u.ushops_entered);
X  
X  	for (ptr = &u.uentered[0]; *ptr; ptr++) {
X--- 1166,1172 ----
X  	    return;		/* no entrance messages necessary */
X  
X  	/* Did we just enter a shop? */
X! 	if (*u.ushops_entered && !newlev)
X              u_entered_shop(u.ushops_entered);
X  
X  	for (ptr = &u.uentered[0]; *ptr; ptr++) {
X***************
X*** 1250,1263 ****
X  			  Blind ? "feel" : "see");
X  		return(1);
X  	}
X- 	if(!OBJ_AT(u.ux, u.uy)) {
X- 		pline("There is nothing here to pick up.");
X- 		return(0);
X- 	}
X- 	if(Levitation && !Is_airlevel(&u.uz) && !Is_waterlevel(&u.uz)) {
X- 		You("cannot reach the floor.");
X- 		return(1);
X- 	}
X  	if(is_pool(u.ux, u.uy)) {
X  		if(Wwalking
X  #ifdef POLYSELF
X--- 1283,1288 ----
X***************
X*** 1272,1277 ****
X--- 1297,1310 ----
X  			return(1);
X  		}
X  	}
X+ 	if(!OBJ_AT(u.ux, u.uy)) {
X+ 		pline("There is nothing here to pick up.");
X+ 		return(0);
X+ 	}
X+ 	if(Levitation && !Is_airlevel(&u.uz) && !Is_waterlevel(&u.uz)) {
X+ 		You("cannot reach the floor.");
X+ 		return(1);
X+ 	}
X  	pickup(-count);
X  	return(1);
X  }
X***************
X*** 1521,1528 ****
X  		carrcap = MAX_CARR_CAP;
X  	else {
X  		if(carrcap > MAX_CARR_CAP) carrcap = MAX_CARR_CAP;
X! 		if(Wounded_legs & LEFT_SIDE) carrcap -= 100;
X! 		if(Wounded_legs & RIGHT_SIDE) carrcap -= 100;
X  	}
X  	return((int) carrcap);
X  }
X--- 1554,1567 ----
X  		carrcap = MAX_CARR_CAP;
X  	else {
X  		if(carrcap > MAX_CARR_CAP) carrcap = MAX_CARR_CAP;
X! #ifdef POLYSELF
X! 		if (!is_flyer(uasmon))
X! #endif
X! 					{
X! 			if(Wounded_legs & LEFT_SIDE) carrcap -= 100;
X! 			if(Wounded_legs & RIGHT_SIDE) carrcap -= 100;
X! 		}
X! 		if (carrcap < 0) carrcap = 0;
X  	}
X  	return((int) carrcap);
X  }
X***************
X*** 1555,1564 ****
X  int
X  near_capacity()
X  {
X!     int cap, wt = inv_weight();
X  
X!     if (wt < 0) return UNENCUMBERED;
X!     cap = (wt / (weight_cap()/2)) + 1;
X      return min(cap, OVERLOADED);
X  }
X  
X--- 1594,1604 ----
X  int
X  near_capacity()
X  {
X!     int cap, wt = inv_weight(), wc = weight_cap();
X  
X!     if (wt <= 0) return UNENCUMBERED;
X!     if (wc <= 1) return OVERLOADED;
X!     cap = (wt*2 / wc) + 1;
X      return min(cap, OVERLOADED);
X  }
X  
X*** /tmp/da08245	Thu Feb 25 10:23:21 1993
X--- src/hacklib.c	Thu Feb  4 13:47:08 1993
X***************
X*** 110,116 ****
X  	Strcat(buf, "s");
X      else if(*(eos(buf)-1) == 's')
X  	Strcat(buf, "'");
X!     else 
X  	Strcat(buf, "'s");
X      return buf;
X  }
X--- 110,116 ----
X  	Strcat(buf, "s");
X      else if(*(eos(buf)-1) == 's')
X  	Strcat(buf, "'");
X!     else
X  	Strcat(buf, "'s");
X      return buf;
X  }
X***************
X*** 465,485 ****
X  	return(datestr);
X  }
X  
X  int
X! phase_of_the_moon()			/* 0-7, with 0: new, 4: full */
X! /* moon period: 2551442 seconds == 29.53058 days */
X! /* 722578680: date when there was a new moon (Tue Nov 24 04:18 1992) */
X! /* *8/2551442: divide into 8 phases */
X! /* *8 +2551442/2 /2551442: let the division round to nearest instead of down */
X  {
X! #ifdef BSD
X! 	long now = time((long *)0);
X! #else
X! 	long now = time((time_t *)0);
X! #endif
X  
X! 	return (int) (((((now - 722578680L) % 2551442L) * 8L) + 2551442L/2L)
X! 		/ 2551442L);
X  }
X  
X  boolean
X--- 465,496 ----
X  	return(datestr);
X  }
X  
X+ /*
X+  * moon period = 29.53058 days ~= 30, year = 365.2422 days
X+  * days moon phase advances on first day of year compared to preceding year
X+  *	= 365.2422 - 12*29.53058 ~= 11
X+  * years in Metonic cycle (time until same phases fall on the same days of
X+  *	the month) = 18.6 ~= 19
X+  * moon phase on first day of year (epact) ~= (11*(year%19) + 29) % 30
X+  *	(29 as initial condition)
X+  * current phase in days = first day phase + days elapsed in year
X+  * 6 moons ~= 177 days
X+  * 177 ~= 8 reported phases * 22
X+  * + 11/22 for rounding
X+  */
X  int
X! phase_of_the_moon()		/* 0-7, with 0: new, 4: full */
X  {
X! 	register struct tm *lt = getlt();
X! 	register int epact, diy, goldn;
X  
X! 	diy = lt->tm_yday;
X! 	goldn = (lt->tm_year % 19) + 1;
X! 	epact = (11 * goldn + 18) % 30;
X! 	if ((epact == 25 && goldn > 11) || epact == 24)
X! 		epact++;
X! 
X! 	return( (((((diy + epact) * 6) + 11) % 177) / 22) & 7 );
X  }
X  
X  boolean
X*** /tmp/da08253	Thu Feb 25 10:23:25 1993
X--- src/invent.c	Tue Feb 23 17:47:21 1993
X***************
X*** 636,646 ****
X  				word, buf);
X  		}
X  #ifdef REDO
X! 		if(!in_doagain)
X! 		    ilet = yn_function(qbuf, NULL, '\0');
X  		else
X  #endif
X! 		    ilet = readchar();
X  		if(ilet == '0') prezero = TRUE;
X  		while(digit(ilet) && allowcnt) {
X  #ifdef REDO
X--- 636,646 ----
X  				word, buf);
X  		}
X  #ifdef REDO
X! 		if (in_doagain)
X! 		    ilet = readchar();
X  		else
X  #endif
X! 		    ilet = yn_function(qbuf, NULL, '\0');
X  		if(ilet == '0') prezero = TRUE;
X  		while(digit(ilet) && allowcnt) {
X  #ifdef REDO
X***************
X*** 721,730 ****
X--- 721,736 ----
X  		}
X  		if(!otmp) {
X  			You("don't have that object.");
X+ #ifdef REDO
X+ 			if (in_doagain) return((struct obj *) 0);
X+ #endif
X  			continue;
X  		} else if (cnt < 0 || otmp->quan < cnt) {
X  			You("don't have that many!  You have only %ld.",
X  			    otmp->quan);
X+ #ifdef REDO
X+ 			if (in_doagain) return((struct obj *) 0);
X+ #endif
X  			continue;
X  		}
X  		break;
X***************
X*** 776,782 ****
X      return(!!(otmp->owornmask & (W_ARMOR | W_RING | W_AMUL | W_TOOL | W_WEP)));
X  }
X  
X! static const char NEARDATA removeables[] =
X  	{ ARMOR_CLASS, WEAPON_CLASS, RING_CLASS, AMULET_CLASS, TOOL_CLASS, 0 };
X  
X  /* interactive version of getobj - used for Drop, Identify and */
X--- 782,788 ----
X      return(!!(otmp->owornmask & (W_ARMOR | W_RING | W_AMUL | W_TOOL | W_WEP)));
X  }
X  
X! static NEARDATA const char removeables[] =
X  	{ ARMOR_CLASS, WEAPON_CLASS, RING_CLASS, AMULET_CLASS, TOOL_CLASS, 0 };
X  
X  /* interactive version of getobj - used for Drop, Identify and */
X***************
X*** 826,841 ****
X  	    ilets[iletct++] = ' ';
X  	    if (unpaid) ilets[iletct++] = 'u';
X  	    if (invent) ilets[iletct++] = 'a';
X  	}
X! 	ilets[iletct] = '\0';	/* outside the if to catch iletct==0 case */
X  
X! 	Sprintf(qbuf,"What kinds of thing do you want to %s? [%s]",
X! 		word, ilets);
X! 	getlin(qbuf, buf);
X! 	if(buf[0] == '\033') {
X! 		clear_nhwindow(WIN_MESSAGE);
X! 		return(0);
X! 	}
X  	ip = buf;
X  	olets[0] = 0;
X  	while ((sym = *ip++) != 0) {
X--- 832,854 ----
X  	    ilets[iletct++] = ' ';
X  	    if (unpaid) ilets[iletct++] = 'u';
X  	    if (invent) ilets[iletct++] = 'a';
X+ 	} else if (takeoff && invent) {
X+ 	    ilets[iletct++] = ' ';
X  	}
X! 	ilets[iletct++] = 'i';
X! 	ilets[iletct] = '\0';
X  
X! 	do {
X! 	    Sprintf(qbuf,"What kinds of thing do you want to %s? [%s]",
X! 		    word, ilets);
X! 	    getlin(qbuf, buf);
X! 	    if (buf[0] == '\033') return(0);
X! 	    if (index(buf, 'i')) {
X! 		(void) display_inventory(NULL, FALSE);
X! 	    } else
X! 		break;
X! 	} while (1);
X! 
X  	ip = buf;
X  	olets[0] = 0;
X  	while ((sym = *ip++) != 0) {
X***************
X*** 920,926 ****
X  	 */
X  nextclass:
X  	ilet = 'a'-1;
X! 	if ((*objchn)->otyp == GOLD_PIECE) ilet--;	/* extra iteration */
X  	for (otmp = *objchn; otmp; otmp = otmp2) {
X  		if(ilet == 'z') ilet = 'A'; else ilet++;
X  		otmp2 = otmp->nobj;
X--- 933,939 ----
X  	 */
X  nextclass:
X  	ilet = 'a'-1;
X! 	if (*objchn && (*objchn)->otyp == GOLD_PIECE) ilet--;	/* extra iteration */
X  	for (otmp = *objchn; otmp; otmp = otmp2) {
X  		if(ilet == 'z') ilet = 'A'; else ilet++;
X  		otmp2 = otmp->nobj;
X***************
X*** 1500,1529 ****
X  mergable(otmp, obj)	/* returns TRUE if obj  & otmp can be merged */
X  	register struct obj *otmp, *obj;
X  {
X! 	if(obj->otyp != otmp->otyp || obj->unpaid != otmp->unpaid ||
X! 	   obj->spe != otmp->spe || obj->dknown != otmp->dknown ||
X! 	   (obj->bknown != otmp->bknown && pl_character[0] != 'P') ||
X! 	   obj->cursed != otmp->cursed || obj->blessed != otmp->blessed ||
X! 	   obj->no_charge != otmp->no_charge ||
X! 	   obj->obroken != otmp->obroken ||
X! 	   obj->otrapped != otmp->otrapped ||
X! 	   obj->oeroded != otmp->oeroded)
X  	    return(FALSE);
X  
X! 	if((obj->oclass==WEAPON_CLASS || obj->oclass==ARMOR_CLASS) &&
X! 	   (obj->oerodeproof!=otmp->oerodeproof || obj->rknown!=otmp->rknown))
X! 		return FALSE;
X  
X! 	if(obj->oclass == FOOD_CLASS && (obj->oeaten != otmp->oeaten ||
X! 		obj->orotten != otmp->orotten))
X! 		return(FALSE);
X  
X! 	if(obj->otyp == CORPSE || obj->otyp == EGG || obj->otyp == TIN) {
X  		if((obj->corpsenm != otmp->corpsenm) ||
X  			(ONAME(obj) && strcmp(ONAME(obj), ONAME(otmp))))
X  				return FALSE;
X  	}
X  
X  /* if they have names, make sure they're the same */
X  	if ( (obj->onamelth != otmp->onamelth &&
X  		((obj->onamelth && otmp->onamelth) || obj->otyp == CORPSE)
X--- 1513,1548 ----
X  mergable(otmp, obj)	/* returns TRUE if obj  & otmp can be merged */
X  	register struct obj *otmp, *obj;
X  {
X! 	if (obj->otyp != otmp->otyp || obj->unpaid != otmp->unpaid ||
X! 	    obj->spe != otmp->spe || obj->dknown != otmp->dknown ||
X! 	    (obj->bknown != otmp->bknown && pl_character[0] != 'P') ||
X! 	    obj->cursed != otmp->cursed || obj->blessed != otmp->blessed ||
X! 	    obj->no_charge != otmp->no_charge ||
X! 	    obj->obroken != otmp->obroken ||
X! 	    obj->otrapped != otmp->otrapped ||
X! 	    obj->lamplit != otmp->lamplit ||
X! 	    obj->oeroded != otmp->oeroded)
X  	    return(FALSE);
X  
X! 	if ((obj->oclass==WEAPON_CLASS || obj->oclass==ARMOR_CLASS) &&
X! 	    (obj->oerodeproof!=otmp->oerodeproof || obj->rknown!=otmp->rknown))
X! 	    return FALSE;
X  
X! 	if (obj->oclass == FOOD_CLASS && (obj->oeaten != otmp->oeaten ||
X! 					  obj->orotten != otmp->orotten))
X! 	    return(FALSE);
X  
X! 	if (obj->otyp == CORPSE || obj->otyp == EGG || obj->otyp == TIN) {
X  		if((obj->corpsenm != otmp->corpsenm) ||
X  			(ONAME(obj) && strcmp(ONAME(obj), ONAME(otmp))))
X  				return FALSE;
X  	}
X  
X+ 	/* allow candle merging only if their ages are close */
X+ 	/* see burn_lamps() for a reference for the magic "25" */
X+ 	if (Is_candle(obj) && obj->age/25 != otmp->age/25)
X+ 	    return(FALSE);
X+ 
X  /* if they have names, make sure they're the same */
X  	if ( (obj->onamelth != otmp->onamelth &&
X  		((obj->onamelth && otmp->onamelth) || obj->otyp == CORPSE)
X***************
X*** 1661,1673 ****
X   * Conversion from a symbol to a string for printing object classes.
X   * This must match the array obj_symbols[].
X   */
X! static const char NEARDATA *names[] = {
X  	"Illegal objects", "Amulets", "Coins", "Comestibles", "Weapons",
X  	"Tools", "Iron balls", "Chains", "Boulders/Statues", "Armor",
X  	"Potions", "Scrolls", "Wands", "Spellbooks", "Rings", "Gems"
X  };
X  
X! static const char NEARDATA oth_symbols[] = {
X  #ifdef WIZARD
X  	VENOM_CLASS,
X  #endif
X--- 1680,1692 ----
X   * Conversion from a symbol to a string for printing object classes.
X   * This must match the array obj_symbols[].
X   */
X! static NEARDATA const char *names[] = {
X  	"Illegal objects", "Amulets", "Coins", "Comestibles", "Weapons",
X  	"Tools", "Iron balls", "Chains", "Boulders/Statues", "Armor",
X  	"Potions", "Scrolls", "Wands", "Spellbooks", "Rings", "Gems"
X  };
X  
X! static NEARDATA const char oth_symbols[] = {
X  #ifdef WIZARD
X  	VENOM_CLASS,
X  #endif
X***************
X*** 1675,1681 ****
X  	'\0'
X  };
X  
X! static const char NEARDATA *oth_names[] = {
X  #ifdef WIZARD
X  	"Venoms",
X  #endif
X--- 1694,1700 ----
X  	'\0'
X  };
X  
X! static NEARDATA const char *oth_names[] = {
X  #ifdef WIZARD
X  	"Venoms",
X  #endif
X***************
X*** 1690,1697 ****
X  	const char *class_name;
X  	const char *pos = index(obj_symbols, let);
X  	int len;
X! 	static char NEARDATA *buf = NULL;
X! 	static unsigned NEARDATA bufsiz = 0;
X  
X  	if (pos)
X  	    class_name = names[pos - obj_symbols];
X--- 1709,1716 ----
X  	const char *class_name;
X  	const char *pos = index(obj_symbols, let);
X  	int len;
X! 	static NEARDATA char *buf = NULL;
X! 	static NEARDATA unsigned bufsiz = 0;
X  
X  	if (pos)
X  	    class_name = names[pos - obj_symbols];
X*** /tmp/da08261	Thu Feb 25 10:23:28 1993
X--- src/lock.c	Fri Feb 12 10:26:30 1993
X***************
X*** 9,25 ****
X  STATIC_PTR int NDECL(picklock);
X  STATIC_PTR int NDECL(forcelock);
X  
X! STATIC_VAR struct xlock_s {
X  	int	door_or_box, picktyp;
X  	struct rm  *door;
X  	struct obj *box;
X  	int chance, usedtime;
X! } NEARDATA xlock;
X  
X  #ifdef OVLB
X  
X  static boolean FDECL(obstructed,(int,int));
X  static void FDECL(chest_shatter_msg, (struct obj *));
X  
X  boolean
X  picking_at(x, y)
X--- 9,37 ----
X  STATIC_PTR int NDECL(picklock);
X  STATIC_PTR int NDECL(forcelock);
X  
X! STATIC_VAR NEARDATA struct xlock_s {
X  	int	door_or_box, picktyp;
X  	struct rm  *door;
X  	struct obj *box;
X  	int chance, usedtime;
X! } xlock;
X  
X  #ifdef OVLB
X  
X  static boolean FDECL(obstructed,(int,int));
X  static void FDECL(chest_shatter_msg, (struct obj *));
X+ 
X+ boolean
X+ picking_lock(x, y)
X+ 	int *x, *y;
X+ {
X+ 	if(occupation != picklock) return 0;
X+ 	else {
X+ 		*x = u.ux + u.dx;
X+ 		*y = u.uy + u.dy;
X+ 		return 1;
X+ 	}
X+ }
X  
X  boolean
X  picking_at(x, y)
X*** /tmp/da08269	Thu Feb 25 10:23:30 1993
X--- src/mail.c	Fri Feb 12 10:26:22 1993
X***************
X*** 50,56 ****
X  /* DON'T trust all Unices to declare getpwuid() in <pwd.h> */
X  #  if !defined(_BULL_SOURCE) && !defined(sgi)
X  /* DO trust all SVR4 to typedef uid_t in <sys/types.h> (probably to a long) */
X! #   if defined(POSIX_TYPES) || defined(SVR4)
X  extern struct passwd *FDECL(getpwuid,(uid_t));
X  #   else 
X  extern struct passwd *FDECL(getpwuid,(int));
X--- 50,56 ----
X  /* DON'T trust all Unices to declare getpwuid() in <pwd.h> */
X  #  if !defined(_BULL_SOURCE) && !defined(sgi)
X  /* DO trust all SVR4 to typedef uid_t in <sys/types.h> (probably to a long) */
X! #   if defined(POSIX_TYPES) || defined(SVR4) || defined(HPUX)
X  extern struct passwd *FDECL(getpwuid,(uid_t));
X  #   else 
X  extern struct passwd *FDECL(getpwuid,(int));
X***************
X*** 242,248 ****
X  }
X  
X  /* Let the mail daemon have a larger vocabulary. */
X! static const char NEARDATA *mail_text[] = {
X      "Gangway!",
X      "Look out!",
X      "Pardon me!"
X--- 242,248 ----
X  }
X  
X  /* Let the mail daemon have a larger vocabulary. */
X! static NEARDATA const char *mail_text[] = {
X      "Gangway!",
X      "Look out!",
X      "Pardon me!"
X***************
X*** 561,567 ****
X  
X      Sprintf(qbuf, "System command (%s)", cmd);
X      getlin(qbuf, buf);
X-     clear_nhwindow(WIN_MESSAGE);
X      if (*buf != '\033') {
X  	for (p = eos(buf); p > buf; *p = '\0')
X  	    if (*--p != ' ') break;	/* strip trailing spaces */
X--- 561,566 ----
X*** /tmp/da08277	Thu Feb 25 10:23:32 1993
X--- src/makemon.c	Sun Feb 21 16:29:30 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)makemon.c	3.1	92/11/01	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)makemon.c	3.1	93/02/20	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 9,15 ****
X  # include <ctype.h>
X  #endif
X  
X! STATIC_VAR struct monst NEARDATA zeromonst;
X  
X  #define uncommon(ptr) \
X  	(((ptr)->geno & (G_GENOD | G_EXTINCT | G_NOGEN | G_UNIQ)) || \
X--- 9,15 ----
X  # include <ctype.h>
X  #endif
X  
X! STATIC_VAR NEARDATA struct monst zeromonst;
X  
X  #define uncommon(ptr) \
X  	(((ptr)->geno & (G_GENOD | G_EXTINCT | G_NOGEN | G_UNIQ)) || \
X***************
X*** 859,865 ****
X  			return 1;
X  		else return
X  			(is_flyer(mdat) || (mdat == &mons[PM_FIRE_ELEMENTAL]));
X! 	    if (passes_walls(mdat)) return 1;
X  	}
X  	if (!ACCESSIBLE(levl[x][y].typ)) return 0;
X  	if (closed_door(x, y) && (!mdat || !amorphous(mdat)))
X--- 859,865 ----
X  			return 1;
X  		else return
X  			(is_flyer(mdat) || (mdat == &mons[PM_FIRE_ELEMENTAL]));
X! 	    if (passes_walls(mdat) && may_passwall(x,y)) return 1;
X  	}
X  	if (!ACCESSIBLE(levl[x][y].typ)) return 0;
X  	if (closed_door(x, y) && (!mdat || !amorphous(mdat)))
X***************
X*** 1020,1027 ****
X  align_shift(ptr)
X  register struct permonst *ptr;
X  {
X!     static long NEARDATA oldmoves = 0L;	/* != 1, starting value of moves */
X!     static s_level NEARDATA *lev;
X      register int alshift;
X  
X      if(oldmoves != moves) {
X--- 1020,1027 ----
X  align_shift(ptr)
X  register struct permonst *ptr;
X  {
X!     static NEARDATA long oldmoves = 0L;	/* != 1, starting value of moves */
X!     static NEARDATA s_level *lev;
X      register int alshift;
X  
X      if(oldmoves != moves) {
X***************
X*** 1048,1059 ****
X  	register struct permonst *ptr;
X  	register int i, ct;
X  	register int zlevel;
X! 	static int NEARDATA minmlev, NEARDATA maxmlev, NEARDATA accept;
X! 	static long NEARDATA oldmoves = 0L;	/* != 1, starting value of moves */
X  #ifdef REINCARNATION
X! 	static boolean NEARDATA upper;
X  #endif
X! 	static boolean NEARDATA elemlevel;
X  
X  #ifdef MULDGN
X  	if(u.uz.dnum == quest_dnum && (ptr = qt_montype())) return(ptr);
X--- 1048,1059 ----
X  	register struct permonst *ptr;
X  	register int i, ct;
X  	register int zlevel;
X! 	static NEARDATA int minmlev, maxmlev, accept;
X! 	static NEARDATA long oldmoves = 0L;	/* != 1, starting value of moves */
X  #ifdef REINCARNATION
X! 	static NEARDATA boolean upper;
X  #endif
X! 	static NEARDATA boolean elemlevel;
X  
X  #ifdef MULDGN
X  	if(u.uz.dnum == quest_dnum && (ptr = qt_montype())) return(ptr);
X***************
X*** 1084,1090 ****
X  		if(tooweak(ct, minmlev) || toostrong(ct, maxmlev))
X  		    continue;
X  #ifdef REINCARNATION
X! 		if(upper && !isupper(def_monsyms[ptr->mlet])) continue;
X  #endif
X  		if(elemlevel && wrong_elem_type(ptr)) continue;
X  		if(uncommon(ptr)) continue;
X--- 1084,1090 ----
X  		if(tooweak(ct, minmlev) || toostrong(ct, maxmlev))
X  		    continue;
X  #ifdef REINCARNATION
X! 		if(upper && !isupper(def_monsyms[(int)ptr->mlet])) continue;
X  #endif
X  		if(elemlevel && wrong_elem_type(ptr)) continue;
X  		if(uncommon(ptr)) continue;
X***************
X*** 1107,1113 ****
X  		if(tooweak(i, minmlev) || toostrong(i, maxmlev))
X  		    continue;
X  #ifdef REINCARNATION
X! 		if(upper & !isupper(def_monsyms[ptr->mlet])) continue;
X  #endif
X  		if(elemlevel && wrong_elem_type(ptr)) continue;
X  		if(uncommon(ptr)) continue;
X--- 1107,1113 ----
X  		if(tooweak(i, minmlev) || toostrong(i, maxmlev))
X  		    continue;
X  #ifdef REINCARNATION
X! 		if(upper & !isupper(def_monsyms[(int)ptr->mlet])) continue;
X  #endif
X  		if(elemlevel && wrong_elem_type(ptr)) continue;
X  		if(uncommon(ptr)) continue;
X***************
X*** 1156,1162 ****
X  	for(last = first; last < NUMMONS && mons[last].mlet == class; last++)
X  	    if(!(mons[last].geno & mask)) {
X  		/* consider it */
X! 		if(num && toostrong(last, maxmlev) && rn2(2)) break;
X  		num += mons[last].geno & G_FREQ;
X  	    }
X  
X--- 1156,1163 ----
X  	for(last = first; last < NUMMONS && mons[last].mlet == class; last++)
X  	    if(!(mons[last].geno & mask)) {
X  		/* consider it */
X! 		if(num && toostrong(last, maxmlev) &&
X! 		   monstr[last] != monstr[last-1] && rn2(2)) break;
X  		num += mons[last].geno & G_FREQ;
X  	    }
X  
X***************
X*** 1168,1175 ****
X  	for(num = rnd(num); num > 0; first++)
X  	    if(!(mons[first].geno & mask)) {
X  		/* skew towards lower value monsters at lower exp. levels */
X- 		if(adj_lev(&mons[first]) > (u.ulevel*2)) num--;
X  		num -= mons[first].geno & G_FREQ;
X  	    }
X  	first--; /* correct an off-by-one error */
X  
X--- 1169,1180 ----
X  	for(num = rnd(num); num > 0; first++)
X  	    if(!(mons[first].geno & mask)) {
X  		/* skew towards lower value monsters at lower exp. levels */
X  		num -= mons[first].geno & G_FREQ;
X+ 		if (num && adj_lev(&mons[first]) > (u.ulevel*2)) {
X+ 		    /* but not when multiple monsters are same level */
X+ 		    if (mons[first].mlevel != mons[first+1].mlevel)
X+ 			num--;
X+ 		}
X  	    }
X  	first--; /* correct an off-by-one error */
X  
X***************
X*** 1410,1416 ****
X  #endif /* OVL1 */
X  #ifdef OVLB
X  
X! static char NEARDATA syms[] = {
X  	MAXOCLASSES, MAXOCLASSES+1, RING_CLASS, WAND_CLASS, WEAPON_CLASS,
X  	FOOD_CLASS, GOLD_CLASS, SCROLL_CLASS, POTION_CLASS, ARMOR_CLASS,
X  	AMULET_CLASS, TOOL_CLASS, ROCK_CLASS, GEM_CLASS, SPBOOK_CLASS,
X--- 1415,1421 ----
X  #endif /* OVL1 */
X  #ifdef OVLB
X  
X! static NEARDATA char syms[] = {
X  	MAXOCLASSES, MAXOCLASSES+1, RING_CLASS, WAND_CLASS, WEAPON_CLASS,
X  	FOOD_CLASS, GOLD_CLASS, SCROLL_CLASS, POTION_CLASS, ARMOR_CLASS,
X  	AMULET_CLASS, TOOL_CLASS, ROCK_CLASS, GEM_CLASS, SPBOOK_CLASS,
X*** /tmp/da08293	Thu Feb 25 10:23:37 1993
X--- src/mhitm.c	Sun Feb 21 16:29:04 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)mhitm.c	3.1	92/12/10	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)mhitm.c	3.1	93/02/09	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 8,16 ****
X  
X  #ifdef OVLB
X  
X! static boolean NEARDATA vis, NEARDATA far_noise;
X! static long NEARDATA noisetime;
X! static struct obj NEARDATA *otmp;
X  
X  static void FDECL(mrustm, (struct monst *, struct monst *, struct obj *));
X  static int FDECL(hitmm, (struct monst *,struct monst *,struct attack *));
X--- 8,16 ----
X  
X  #ifdef OVLB
X  
X! static NEARDATA boolean vis, far_noise;
X! static NEARDATA long noisetime;
X! static NEARDATA struct obj *otmp;
X  
X  static void FDECL(mrustm, (struct monst *, struct monst *, struct obj *));
X  static int FDECL(hitmm, (struct monst *,struct monst *,struct attack *));
X***************
X*** 213,218 ****
X--- 213,220 ----
X  			magr->weapon_check = NEED_HTH_WEAPON;
X  			if (mon_wield_item(magr) != 0) return 0;
X  		}
X+ 		remove_cadavers(&magr->minvent);
X+ 		possibly_unwield(magr);
X  		otmp = MON_WEP(magr);
X  #else
X  		otmp = select_hwep(magr);
X***************
X*** 456,462 ****
X  	/* Kill off agressor if it didn't die. */
X  	if (!(result & MM_AGR_DIED)) {
X  	    mondead(magr);
X! 	    result |= MM_AGR_DIED;
X  	}
X  
X  	return result;
X--- 458,467 ----
X  	/* Kill off agressor if it didn't die. */
X  	if (!(result & MM_AGR_DIED)) {
X  	    mondead(magr);
X! #ifdef MUSE
X! 	    if (magr->mhp <= 0)
X! #endif
X! 		result |= MM_AGR_DIED;
X  	}
X  
X  	return result;
X***************
X*** 481,487 ****
X  	   (mattk->aatyp != AT_WEAP || !otmp) &&
X  	   (mattk->aatyp != AT_GAZE && mattk->aatyp != AT_EXPL) &&
X  #ifdef MUSE
X! 	   (!which_armor(magr, W_ARMG))) {
X  #else
X  	   (!is_mercenary(pa) || !m_carrying(magr, LEATHER_GLOVES))) {
X  	   /* Note: other monsters may carry gloves, only soldiers have them */
X--- 486,492 ----
X  	   (mattk->aatyp != AT_WEAP || !otmp) &&
X  	   (mattk->aatyp != AT_GAZE && mattk->aatyp != AT_EXPL) &&
X  #ifdef MUSE
X! 	   (!(magr->misc_worn_check & W_ARMG))) {
X  #else
X  	   (!is_mercenary(pa) || !m_carrying(magr, LEATHER_GLOVES))) {
X  	   /* Note: other monsters may carry gloves, only soldiers have them */
X***************
X*** 515,520 ****
X--- 520,530 ----
X  			tmp = 0;
X  		else if(mattk->aatyp == AT_WEAP) {
X  		    if(otmp) {
X+ #ifdef MUSE
X+ 			if (otmp->otyp == CORPSE &&
X+ 				otmp->corpsenm == PM_COCKATRICE)
X+ 			    goto do_stone_goto_label;
X+ #endif
X  			tmp += dmgval(otmp, pd);
X  			if (otmp->oartifact) {
X  			    (void)artifact_hit(magr,mdef, otmp, &tmp, dieroll);
X***************
X*** 599,604 ****
X--- 609,617 ----
X  			else if(mdef->mtame)
X  			     pline("May %s rust in peace.", mon_nam(mdef));
X  			mondied(mdef);
X+ #ifdef MUSE
X+ 			if (mdef->mhp > 0) return 0;
X+ #endif
X  			return (MM_DEF_DIED | (grow_up(magr,mdef) ?
X  							0 : MM_AGR_DIED));
X  		}
X***************
X*** 611,616 ****
X--- 624,632 ----
X  			else if(mdef->mtame)
X  			     pline("May %s rot in peace.", mon_nam(mdef));
X  			mondied(mdef);
X+ #ifdef MUSE
X+ 			if (mdef->mhp > 0) return 0;
X+ #endif
X  			return (MM_DEF_DIED | (grow_up(magr,mdef) ?
X  							0 : MM_AGR_DIED));
X  		}
X***************
X*** 617,622 ****
X--- 633,641 ----
X  		tmp = 0;
X  		break;
X  	    case AD_STON:
X+ #ifdef MUSE
X+ do_stone_goto_label:
X+ #endif
X  		if(poly_when_stoned(pd)) {
X  		    mon_to_stone(mdef);
X  		    tmp = 0;
X***************
X*** 626,635 ****
X  			if(vis) pline("%s turns to stone!", Monnam(mdef));
X  			else if(mdef->mtame) You(psf);
X  			monstone(mdef);
X  			return (MM_DEF_DIED | (grow_up(magr,mdef) ?
X  							0 : MM_AGR_DIED));
X  		}
X! 		tmp = 0;	/* no damage if this fails */
X  		break;
X  	    case AD_TLPT:
X  		if(!magr->mcan && tmp < mdef->mhp) {
X--- 645,657 ----
X  			if(vis) pline("%s turns to stone!", Monnam(mdef));
X  			else if(mdef->mtame) You(psf);
X  			monstone(mdef);
X+ #ifdef MUSE
X+ 			if (mdef->mhp > 0) return 0;
X+ #endif
X  			return (MM_DEF_DIED | (grow_up(magr,mdef) ?
X  							0 : MM_AGR_DIED));
X  		}
X! 		tmp = (mattk->adtyp == AD_STON ? 0 : 1);
X  		break;
X  	    case AD_TLPT:
X  		if(!magr->mcan && tmp < mdef->mhp) {
X***************
X*** 703,708 ****
X--- 725,733 ----
X  			    else if (mdef->mtame)
X  	You("have a strangely sad feeling for a moment, then it passes.");
X  			    mondied(mdef);
X+ #ifdef MUSE
X+ 			    if (mdef->mhp > 0) return 0;
X+ #endif
X  			    return (MM_DEF_DIED | (grow_up(magr,mdef) ?
X  							0 : MM_AGR_DIED));
X  		      }
X***************
X*** 760,765 ****
X--- 785,794 ----
X  				mdef->misc_worn_check &= ~otmp->owornmask;
X  				otmp->owornmask = 0;
X  			}
X+ 			mselftouch(mdef, (const char *)0, FALSE);
X+ 			if (mdef->mhp <= 0)
X+ 				return (MM_DEF_DIED | (grow_up(magr,mdef) ?
X+ 							0 : MM_AGR_DIED));
X  #endif
X  		}
X  		tmp = 0;
X***************
X*** 828,833 ****
X--- 857,863 ----
X  		place_monster(mdef, mdef->mx, mdef->my);
X  	    }
X  	    monkilled(mdef, "", mattk->adtyp);
X+ 	    if (mdef->mhp > 0) return 0; /* mdef lifesaved */
X  	    return (MM_DEF_DIED | (grow_up(magr,mdef) ? 0 : MM_AGR_DIED));
X  	}
X  	return(MM_HIT);
X***************
X*** 884,898 ****
X  {
X  	char buf[BUFSZ];
X  	Strcpy(buf, mon_nam(mdef));
X! 	if (!flags.verbose || Blind || otemp->oclass != WEAPON_CLASS) return;
X  	pline("%s %s %s %s at %s.", Monnam(magr),
X! 	      ((otemp->otyp >= SPEAR &&
X! 	        otemp->otyp <= LANCE) ||
X! 	       (otemp->otyp >= PARTISAN &&
X! 	        otemp->otyp <= SPETUM) ||
X  	       otemp->otyp == TRIDENT) ? "thrusts" : "swings",
X! 	      humanoid(magr->data) ? (magr->female ? "her" : "his") : "its",
X! 	      xname(otemp), buf);
X  }
X  
X  /*
X--- 914,925 ----
X  {
X  	char buf[BUFSZ];
X  	Strcpy(buf, mon_nam(mdef));
X! 	if (!flags.verbose || Blind) return;
X  	pline("%s %s %s %s at %s.", Monnam(magr),
X! 	      ((otemp->otyp >= SPEAR && otemp->otyp <= LANCE) ||
X! 	       (otemp->otyp >= PARTISAN && otemp->otyp <= SPETUM) ||
X  	       otemp->otyp == TRIDENT) ? "thrusts" : "swings",
X! 	      his[pronoun_gender(magr)], xname(otemp), buf);
X  }
X  
X  /*
X
END_OF_FILE
if test 51083 -ne `wc -c <'patches01d'`; then
    echo shar: \"'patches01d'\" unpacked with wrong size!
fi
# end of 'patches01d'
if test ! -d 'sys' ; then
    echo shar: Creating directory \"'sys'\"
    mkdir 'sys'
fi
if test ! -d 'sys/amiga' ; then
    echo shar: Creating directory \"'sys/amiga'\"
    mkdir 'sys/amiga'
fi
if test ! -d 'sys/mac' ; then
    echo shar: Creating directory \"'sys/mac'\"
    mkdir 'sys/mac'
fi
if test ! -d 'sys/share' ; then
    echo shar: Creating directory \"'sys/share'\"
    mkdir 'sys/share'
fi
if test ! -d 'sys/share/sounds' ; then
    echo shar: Creating directory \"'sys/share/sounds'\"
    mkdir 'sys/share/sounds'
fi
if test ! -d 'sys/winnt' ; then
    echo shar: Creating directory \"'sys/winnt'\"
    mkdir 'sys/winnt'
fi
echo shar: End of archive 1 \(of 31\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 31 archives.
    echo "Now execute 'patchit.sh'"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
