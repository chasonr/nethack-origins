Subject:  v17i057:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Patch1p/31
Newsgroups: comp.sources.games
Approved: billr@saab.CNA.TEK.COM

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 17, Issue 57
Archive-name: nethack31/Patch1p
Patch-To: nethack31: Volume 16, Issue 1-116
Environment: Amiga, Atari, Mac, MS-DOS, Windows-NT, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 16 (of 31)."
# Contents:  patches01b
# Wrapped by billr@saab on Fri Mar  5 10:50:45 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'patches01b' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'patches01b'\" to \"'patches01b.orig'\"
  mv -f 'patches01b' 'patches01b.orig'
fi
echo shar: Extracting \"'patches01b'\" \(52704 characters\)
sed "s/^X//" >'patches01b' <<'END_OF_FILE'
X*** /tmp/da08061	Thu Feb 25 10:22:24 1993
X--- src/cmd.c	Wed Feb 17 09:59:12 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)cmd.c	3.1	92/11/25	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)cmd.c	3.1	93/02/16	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 117,126 ****
X  #endif
X  #endif /* OVLB */
X  
X- #ifdef OVL0
X- static int FDECL(click_to_cmd, (int,int,int));
X- #endif /* OVL0 */
X- 
X  STATIC_OVL char *NDECL(parse);
X  
X  #ifdef UNIX
X--- 117,122 ----
X***************
X*** 195,201 ****
X   */
X  #define BSIZE 20
X  static char pushq[BSIZE], saveq[BSIZE];
X! static int NEARDATA phead, NEARDATA ptail, NEARDATA shead, NEARDATA stail;
X  
X  static char
X  popch() {
X--- 191,197 ----
X   */
X  #define BSIZE 20
X  static char pushq[BSIZE], saveq[BSIZE];
X! static NEARDATA int phead, ptail, shead, stail;
X  
X  static char
X  popch() {
X***************
X*** 261,267 ****
X  #else
X  	getlin("#", buf);
X  #endif
X- 	clear_nhwindow(WIN_MESSAGE);
X  	if(buf[0] == '\0' || buf[0] == '\033')
X  		return 0;
X  	if(buf[0] == '?') {
X--- 257,262 ----
X***************
X*** 660,665 ****
X--- 655,661 ----
X  	{M('m'), domonability},
X  #endif /* POLYSELF */
X  	{'N', ddocall}, /* if number_pad is on */
X+ 	{M('n'), ddocall},
X  	{M('N'), ddocall},
X  	{'o', doopen},
X  	{'O', doset},
X***************
X*** 699,704 ****
X--- 695,701 ----
X  	{'/', dowhatis},
X  	{'&', dowhatdoes},
X  	{'?', dohelp},
X+ 	{M('?'), doextlist},
X  #ifdef SHELL
X  	{'!', dosh},
X  #endif
X***************
X*** 720,726 ****
X  	{'#', doextcmd},
X  	{0,0,0}
X  };
X- #undef M
X  
X  const struct ext_func_tab extcmdlist[] = {
X  	{"adjust", "adjust inventory letters", doorganize},
X--- 717,722 ----
X***************
X*** 977,988 ****
X  	return x >= 1 && x <= COLNO-1 && y >= 0 && y <= ROWNO-1;
X  }
X  
X! static int NEARDATA last_multi;
X  
X  /*
X   * convert a MAP window position into a movecmd
X   */
X! static int
X  click_to_cmd(x, y, mod)
X      int x, y, mod;
X  {
X--- 973,984 ----
X  	return x >= 1 && x <= COLNO-1 && y >= 0 && y <= ROWNO-1;
X  }
X  
X! static NEARDATA int last_multi;
X  
X  /*
X   * convert a MAP window position into a movecmd
X   */
X! int
X  click_to_cmd(x, y, mod)
X      int x, y, mod;
X  {
X***************
X*** 1007,1013 ****
X      if(mod == CLICK_1) {
X  	return (flags.num_pad ? ndir[x] : sdir[x]);
X      } else {
X! 	return (sdir[x] - 'a' + 'A'); /* run command */
X      }
X  }
X  
X--- 1003,1010 ----
X      if(mod == CLICK_1) {
X  	return (flags.num_pad ? ndir[x] : sdir[x]);
X      } else {
X! 	return (flags.num_pad ? M(ndir[x]) :
X! 		(sdir[x] - 'a' + 'A')); /* run command */
X      }
X  }
X  
X*** /tmp/da08069	Thu Feb 25 10:22:26 1993
X--- src/dbridge.c	Fri Feb 12 10:26:10 1993
X***************
X*** 223,229 ****
X  
X  #define ENTITIES 2
X  
X! static struct entity NEARDATA occupants[ENTITIES];
X  
X  static
X  struct entity *
X--- 223,229 ----
X  
X  #define ENTITIES 2
X  
X! static NEARDATA struct entity occupants[ENTITIES];
X  
X  static
X  struct entity *
X*** /tmp/da08077	Thu Feb 25 10:22:29 1993
X--- src/decl.c	Fri Feb 12 10:25:36 1993
X***************
X*** 17,35 ****
X  char *catmore = 0;		/* default pager */
X  #endif
X  
X! int NEARDATA bases[MAXOCLASSES] = DUMMY;
X  
X! int NEARDATA multi = 0;
X! int NEARDATA warnlevel = 0;		/* used by movemon and dochugw */
X! int NEARDATA nroom = 0;
X! int NEARDATA nsubroom = 0;
X! int NEARDATA occtime = 0;
X  
X  int x_maze_max, y_maze_max;	/* initialized in main, used in mkmaze.c */
X  int otg_temp;			/* used by object_to_glyph() [otg] */
X  
X  #ifdef REDO
X! int NEARDATA in_doagain = 0;
X  #endif
X  
X  /*
X--- 17,35 ----
X  char *catmore = 0;		/* default pager */
X  #endif
X  
X! NEARDATA int bases[MAXOCLASSES] = DUMMY;
X  
X! NEARDATA int multi = 0;
X! NEARDATA int warnlevel = 0;		/* used by movemon and dochugw */
X! NEARDATA int nroom = 0;
X! NEARDATA int nsubroom = 0;
X! NEARDATA int occtime = 0;
X  
X  int x_maze_max, y_maze_max;	/* initialized in main, used in mkmaze.c */
X  int otg_temp;			/* used by object_to_glyph() [otg] */
X  
X  #ifdef REDO
X! NEARDATA int in_doagain = 0;
X  #endif
X  
X  /*
X***************
X*** 43,75 ****
X  struct q_score	quest_status = DUMMY;
X  #endif
X  
X! int NEARDATA smeq[MAXNROFROOMS+1] = DUMMY;
X! int NEARDATA doorindex = 0;
X  
X! char NEARDATA *save_cm = 0;
X! int NEARDATA killer_format = 0;
X! const char NEARDATA *killer = 0;
X! const char NEARDATA *nomovemsg = 0;
X! const char NEARDATA nul[40] = DUMMY;		/* contains zeros */
X! char NEARDATA plname[PL_NSIZ] = DUMMY;		/* player name */
X! char NEARDATA pl_character[PL_CSIZ] = DUMMY;
X  
X  #ifdef TUTTI_FRUTTI
X! char NEARDATA pl_fruit[PL_FSIZ] = DUMMY;
X! int NEARDATA current_fruit = 0;
X! struct fruit NEARDATA *ffruit = (struct fruit *)0;
X  #endif
X  
X! char NEARDATA tune[6] = DUMMY;
X  
X! const char NEARDATA *occtxt = DUMMY;
X! const char NEARDATA quitchars[] = " \r\n\033";
X! const char NEARDATA vowels[] = "aeiouAEIOU";
X! const char NEARDATA ynchars[] = "yn";
X! const char NEARDATA ynqchars[] = "ynq";
X! const char NEARDATA ynaqchars[] = "ynaq";
X! const char NEARDATA ynNaqchars[] = "yn#aq";
X! long NEARDATA yn_number = 0L;
X  
X  #ifdef MICRO
X  char hackdir[PATHLEN];		/* where rumors, help, record are */
X--- 43,75 ----
X  struct q_score	quest_status = DUMMY;
X  #endif
X  
X! NEARDATA int smeq[MAXNROFROOMS+1] = DUMMY;
X! NEARDATA int doorindex = 0;
X  
X! NEARDATA char *save_cm = 0;
X! NEARDATA int killer_format = 0;
X! NEARDATA const char *killer = 0;
X! NEARDATA const char *nomovemsg = 0;
X! NEARDATA const char nul[40] = DUMMY;		/* contains zeros */
X! NEARDATA char plname[PL_NSIZ] = DUMMY;		/* player name */
X! NEARDATA char pl_character[PL_CSIZ] = DUMMY;
X  
X  #ifdef TUTTI_FRUTTI
X! NEARDATA char pl_fruit[PL_FSIZ] = DUMMY;
X! NEARDATA int current_fruit = 0;
X! NEARDATA struct fruit *ffruit = (struct fruit *)0;
X  #endif
X  
X! NEARDATA char tune[6] = DUMMY;
X  
X! NEARDATA const char *occtxt = DUMMY;
X! NEARDATA const char quitchars[] = " \r\n\033";
X! NEARDATA const char vowels[] = "aeiouAEIOU";
X! NEARDATA const char ynchars[] = "yn";
X! NEARDATA const char ynqchars[] = "ynq";
X! NEARDATA const char ynaqchars[] = "ynaq";
X! NEARDATA const char ynNaqchars[] = "yn#aq";
X! NEARDATA long yn_number = 0L;
X  
X  #ifdef MICRO
X  char hackdir[PATHLEN];		/* where rumors, help, record are */
X***************
X*** 92,159 ****
X  #undef INFOSIZE
X  
X  /* 'rogue'-like direction commands (cmd.c) */
X! const char NEARDATA sdir[] = "hykulnjb><";
X! const char NEARDATA ndir[] = "47896321><";	/* number pad mode */
X! const schar NEARDATA xdir[10] = { -1,-1, 0, 1, 1, 1, 0,-1, 0, 0 };
X! const schar NEARDATA ydir[10] = {  0,-1,-1,-1, 0, 1, 1, 1, 0, 0 };
X! const schar zdir[10]	      = {  0, 0, 0, 0, 0, 0, 0, 0, 1,-1 };
X  
X! schar NEARDATA tbx = 0, NEARDATA tby = 0;	/* mthrowu: target */
X! int NEARDATA dig_effort = 0;	/* effort expended on current pos */
X! d_level NEARDATA dig_level = { 0, 0 };
X! coord NEARDATA dig_pos = DUMMY;
X! boolean NEARDATA dig_down = FALSE;
X  
X! dungeon NEARDATA dungeons[MAXDUNGEON];	/* ini'ed by init_dungeon() */
X! s_level NEARDATA *sp_levchn;
X! int NEARDATA done_stopprint = 0;
X! int NEARDATA done_hup = 0;
X! stairway NEARDATA upstair = { 0, 0 }, NEARDATA dnstair = { 0, 0 };
X! stairway NEARDATA upladder = { 0, 0 }, NEARDATA dnladder = { 0, 0 };
X! stairway NEARDATA sstairs = { 0, 0 };
X! dest_area NEARDATA updest = { 0, 0, 0, 0, 0, 0, 0, 0 };
X! dest_area NEARDATA dndest = { 0, 0, 0, 0, 0, 0, 0, 0 };
X! coord NEARDATA inv_pos = { 0, 0 };
X  
X! boolean NEARDATA in_mklev = FALSE;
X! boolean	NEARDATA stoned = FALSE;	/* done to monsters hit by 'c' */
X! boolean	NEARDATA unweapon = FALSE;
X! boolean NEARDATA mrg_to_wielded = FALSE;
X  			 /* weapon picked is merged with wielded one */
X  
X  #ifdef KOPS
X! boolean NEARDATA allow_kops = TRUE;
X  #endif
X  
X! coord NEARDATA bhitpos = DUMMY;
X! coord NEARDATA doors[DOORMAX] = {DUMMY};
X  
X! struct mkroom NEARDATA rooms[(MAXNROFROOMS+1)*2] = {DUMMY};
X! struct mkroom* NEARDATA subrooms = &rooms[MAXNROFROOMS+1];
X  struct mkroom *upstairs_room, *dnstairs_room, *sstairs_room;
X  
X  dlevel_t level;		/* level map */
X  struct trap *ftrap = (struct trap *)0;
X! struct monst NEARDATA youmonst = DUMMY;
X! struct flag NEARDATA flags = DUMMY;
X! struct you NEARDATA u = DUMMY;
X  
X! struct obj NEARDATA *invent = (struct obj *)0, 
X!         NEARDATA *uwep = (struct obj *)0, NEARDATA *uarm = (struct obj *)0,
X  #ifdef TOURIST
X! 	NEARDATA *uarmu = (struct obj *)0, /* under-wear, so to speak */
X  #endif
X  #ifdef POLYSELF
X! 	NEARDATA *uskin = (struct obj *)0, /* dragon armor, if a dragon */
X  #endif
X! 	NEARDATA *uarmc = (struct obj *)0, NEARDATA *uarmh = (struct obj *)0, 
X!         NEARDATA *uarms = (struct obj *)0, NEARDATA *uarmg = (struct obj *)0,
X!         NEARDATA *uarmf = (struct obj *)0, NEARDATA *uamul = (struct obj *)0,
X! 	NEARDATA *uright = (struct obj *)0,
X!         NEARDATA *uleft = (struct obj *)0,
X!         NEARDATA *ublindf = (struct obj *)0,
X! 	NEARDATA *uchain = (struct obj *)0,
X!         NEARDATA *uball = (struct obj *)0;
X  
X  #ifdef TEXTCOLOR
X  /*
X--- 92,159 ----
X  #undef INFOSIZE
X  
X  /* 'rogue'-like direction commands (cmd.c) */
X! NEARDATA const char sdir[] = "hykulnjb><";
X! NEARDATA const char ndir[] = "47896321><";	/* number pad mode */
X! NEARDATA const schar xdir[10] = { -1,-1, 0, 1, 1, 1, 0,-1, 0, 0 };
X! NEARDATA const schar ydir[10] = {  0,-1,-1,-1, 0, 1, 1, 1, 0, 0 };
X! NEARDATA const schar zdir[10]	      = {  0, 0, 0, 0, 0, 0, 0, 0, 1,-1 };
X  
X! NEARDATA schar tbx = 0, tby = 0;	/* mthrowu: target */
X! NEARDATA int dig_effort = 0;	/* effort expended on current pos */
X! NEARDATA d_level dig_level = { 0, 0 };
X! NEARDATA coord dig_pos = DUMMY;
X! NEARDATA boolean dig_down = FALSE;
X  
X! NEARDATA dungeon dungeons[MAXDUNGEON];	/* ini'ed by init_dungeon() */
X! NEARDATA s_level *sp_levchn;
X! NEARDATA int done_stopprint = 0;
X! NEARDATA int done_hup = 0;
X! NEARDATA stairway upstair = { 0, 0 }, dnstair = { 0, 0 };
X! NEARDATA stairway upladder = { 0, 0 }, dnladder = { 0, 0 };
X! NEARDATA stairway sstairs = { 0, 0 };
X! NEARDATA dest_area updest = { 0, 0, 0, 0, 0, 0, 0, 0 };
X! NEARDATA dest_area dndest = { 0, 0, 0, 0, 0, 0, 0, 0 };
X! NEARDATA coord inv_pos = { 0, 0 };
X  
X! NEARDATA boolean in_mklev = FALSE;
X! NEARDATA boolean stoned = FALSE;	/* done to monsters hit by 'c' */
X! NEARDATA boolean unweapon = FALSE;
X! NEARDATA boolean mrg_to_wielded = FALSE;
X  			 /* weapon picked is merged with wielded one */
X  
X  #ifdef KOPS
X! NEARDATA boolean allow_kops = TRUE;
X  #endif
X  
X! NEARDATA coord bhitpos = DUMMY;
X! NEARDATA coord doors[DOORMAX] = {DUMMY};
X  
X! NEARDATA struct mkroom rooms[(MAXNROFROOMS+1)*2] = {DUMMY};
X! NEARDATA struct mkroom* subrooms = &rooms[MAXNROFROOMS+1];
X  struct mkroom *upstairs_room, *dnstairs_room, *sstairs_room;
X  
X  dlevel_t level;		/* level map */
X  struct trap *ftrap = (struct trap *)0;
X! NEARDATA struct monst youmonst = DUMMY;
X! NEARDATA struct flag flags = DUMMY;
X! NEARDATA struct you u = DUMMY;
X  
X! NEARDATA struct obj *invent = (struct obj *)0, 
X! 	*uwep = (struct obj *)0, *uarm = (struct obj *)0,
X  #ifdef TOURIST
X! 	*uarmu = (struct obj *)0, /* under-wear, so to speak */
X  #endif
X  #ifdef POLYSELF
X! 	 *uskin = (struct obj *)0, /* dragon armor, if a dragon */
X  #endif
X! 	*uarmc = (struct obj *)0, *uarmh = (struct obj *)0, 
X!         *uarms = (struct obj *)0, *uarmg = (struct obj *)0,
X!         *uarmf = (struct obj *)0, *uamul = (struct obj *)0,
X! 	*uright = (struct obj *)0,
X!         *uleft = (struct obj *)0,
X!         *ublindf = (struct obj *)0,
X! 	*uchain = (struct obj *)0,
X!         *uball = (struct obj *)0;
X  
X  #ifdef TEXTCOLOR
X  /*
X***************
X*** 177,206 ****
X      S_ss1, S_ss2, S_ss3, S_ss2, S_ss1, S_ss2, S_ss4,
X  };
X  
X! struct spell NEARDATA spl_book[MAXSPELL + 1] = {DUMMY};
X  
X! long NEARDATA moves = 1L, NEARDATA monstermoves = 1L;
X  	 /* These diverge when player is Fast */
X! long NEARDATA wailmsg = 0L;
X  
X  /* objects that are moving to another dungeon level */
X! struct obj NEARDATA *migrating_objs = (struct obj *)0;
X  /* objects not yet paid for */
X! struct obj NEARDATA *billobjs = (struct obj *)0;
X  
X  /* used to zero all elements of a struct obj */
X! struct obj NEARDATA zeroobj = DUMMY;
X  
X  /* originally from dog.c */
X! char NEARDATA dogname[63] = DUMMY;
X! char NEARDATA catname[63] = DUMMY;
X  char preferred_pet;	/* '\0', 'c', 'd' */
X  /* monsters that went down/up together with @ */
X! struct monst NEARDATA *mydogs = (struct monst *)0;
X  /* monsters that are moving to another dungeon level */
X! struct monst NEARDATA *migrating_mons = (struct monst *)0;
X  
X! struct c_color_names NEARDATA c_color_names = {
X  	"black", "amber", "golden",
X  	"light blue", "red", "green",
X  	"silver", "blue", "purple",
X--- 177,211 ----
X      S_ss1, S_ss2, S_ss3, S_ss2, S_ss1, S_ss2, S_ss4,
X  };
X  
X! NEARDATA struct spell spl_book[MAXSPELL + 1] = {DUMMY};
X  
X! NEARDATA long moves = 1L, monstermoves = 1L;
X  	 /* These diverge when player is Fast */
X! NEARDATA long wailmsg = 0L;
X  
X  /* objects that are moving to another dungeon level */
X! NEARDATA struct obj *migrating_objs = (struct obj *)0;
X  /* objects not yet paid for */
X! NEARDATA struct obj *billobjs = (struct obj *)0;
X  
X  /* used to zero all elements of a struct obj */
X! NEARDATA struct obj zeroobj = DUMMY;
X  
X+ /* monster pronouns, index is return value of gender(mtmp) */
X+ NEARDATA const char *he[3]  = { "he",  "she", "it" };
X+ NEARDATA const char *him[3] = { "him", "her", "it" };
X+ NEARDATA const char *his[3] = { "his", "her", "its" };
X+ 
X  /* originally from dog.c */
X! NEARDATA char dogname[63] = DUMMY;
X! NEARDATA char catname[63] = DUMMY;
X  char preferred_pet;	/* '\0', 'c', 'd' */
X  /* monsters that went down/up together with @ */
X! NEARDATA struct monst *mydogs = (struct monst *)0;
X  /* monsters that are moving to another dungeon level */
X! NEARDATA struct monst *migrating_mons = (struct monst *)0;
X  
X! NEARDATA struct c_color_names c_color_names = {
X  	"black", "amber", "golden",
X  	"light blue", "red", "green",
X  	"silver", "blue", "purple",
X***************
X*** 213,224 ****
X  };
X  
X  /* Vision */
X! boolean	NEARDATA vision_full_recalc = 0;
X! char	NEARDATA **viz_array = 0;/* used in cansee() and couldsee() macros */
X  
X  /* Global windowing data, defined here for multi-window-system support */
X! winid NEARDATA WIN_MESSAGE = WIN_ERR, NEARDATA WIN_STATUS = WIN_ERR;
X! winid NEARDATA WIN_MAP = WIN_ERR, NEARDATA WIN_INVEN = WIN_ERR;
X  char toplines[BUFSZ];
X  /* Windowing stuff that's really tty oriented, but present for all ports */
X  struct tc_gbl_data tc_gbl_data = { 0,0, 0,0 };	/* AS,AE, LI,CO */
X--- 218,229 ----
X  };
X  
X  /* Vision */
X! NEARDATA boolean vision_full_recalc = 0;
X! NEARDATA char	 **viz_array = 0;/* used in cansee() and couldsee() macros */
X  
X  /* Global windowing data, defined here for multi-window-system support */
X! NEARDATA winid WIN_MESSAGE = WIN_ERR, WIN_STATUS = WIN_ERR;
X! NEARDATA winid WIN_MAP = WIN_ERR, WIN_INVEN = WIN_ERR;
X  char toplines[BUFSZ];
X  /* Windowing stuff that's really tty oriented, but present for all ports */
X  struct tc_gbl_data tc_gbl_data = { 0,0, 0,0 };	/* AS,AE, LI,CO */
X*** /tmp/da08085	Thu Feb 25 10:22:31 1993
X--- src/detect.c	Sun Feb 21 16:06:26 1993
X***************
X*** 535,541 ****
X  level_distance(where)
X  d_level *where;
X  {
X!     register xchar ll = depth(&u.uz) - depth(where);
X      register boolean indun = (u.uz.dnum == where->dnum);
X  
X      if (ll < 0) {
X--- 535,541 ----
X  level_distance(where)
X  d_level *where;
X  {
X!     register schar ll = depth(&u.uz) - depth(where);
X      register boolean indun = (u.uz.dnum == where->dnum);
X  
X      if (ll < 0) {
X***************
X*** 639,645 ****
X  	if (flags.verbose) pline("Never mind.");
X  	return;
X      }
X!     You("peer into %s", the(bname));
X      nomul(-rnd(10));
X      nomovemsg = "";
X      if (obj->spe <= 0)
X--- 639,645 ----
X  	if (flags.verbose) pline("Never mind.");
X  	return;
X      }
X!     You("peer into %s...", the(bname));
X      nomul(-rnd(10));
X      nomovemsg = "";
X      if (obj->spe <= 0)
X***************
X*** 661,679 ****
X  		    break;
X  		default:
X  		    {
X! 		    short i = rn2(SIZE(level_detects));
X  		    You("see %s, %s.",
X  			level_detects[i].what,
X  			level_distance(level_detects[i].where));
X  		    }
X! 		    ret = 1;
X  		    break;
X  	}
X  
X! 	if (!ret)
X  	    if (!rn2(100))  /* make them nervous */
X  		You("see the Wizard of Yendor gazing out at you.");
X! 		else pline("The vision is unclear.");
X      }
X      return;
X  }
X--- 661,680 ----
X  		    break;
X  		default:
X  		    {
X! 		    int i = rn2(SIZE(level_detects));
X  		    You("see %s, %s.",
X  			level_detects[i].what,
X  			level_distance(level_detects[i].where));
X  		    }
X! 		    ret = 0;
X  		    break;
X  	}
X  
X! 	if (ret) {
X  	    if (!rn2(100))  /* make them nervous */
X  		You("see the Wizard of Yendor gazing out at you.");
X! 	    else pline("The vision is unclear.");
X! 	}
X      }
X      return;
X  }
X*** /tmp/da08101	Thu Feb 25 10:22:36 1993
X--- src/do.c	Wed Feb 24 17:53:39 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)do.c	3.1	92/11/11	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)do.c	3.1	93/02/20	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 40,46 ****
X  
X  #ifdef OVLB
X  
X! static const char NEARDATA drop_types[] =
X  	{ ALLOW_COUNT, GOLD_CLASS, ALL_CLASSES, 0 };
X  
X  int
X--- 40,46 ----
X  
X  #ifdef OVLB
X  
X! static NEARDATA const char drop_types[] =
X  	{ ALLOW_COUNT, GOLD_CLASS, ALL_CLASSES, 0 };
X  
X  int
X***************
X*** 60,66 ****
X  #ifdef OVL0
X  
X  /* Called when a boulder is dropped, thrown, or pushed.  If it ends up
X!  * in a pool, it either fills the pool up or sinks away.  In either case, 
X   * it's gone for good...  If the destination is not a pool, returns FALSE.
X   */
X  boolean
X--- 60,66 ----
X  #ifdef OVL0
X  
X  /* Called when a boulder is dropped, thrown, or pushed.  If it ends up
X!  * in a pool, it either fills the pool up or sinks away.  In either case,
X   * it's gone for good...  If the destination is not a pool, returns FALSE.
X   */
X  boolean
X***************
X*** 95,111 ****
X  		}
X  	    }
X  	    if (!fills_up || !pushing) {	/* splashing occurs */
X! 		if (pushing ? !Blind : cansee(rx,ry))
X! 		    pline("There is a large splash as %s %s the %s.",
X! 			the(xname(otmp)), fills_up ? "fills" : "falls into",
X! 			lava ? "lava" : ltyp==POOL ? "pool" : "moat");
X! 		else if (flags.soundok)
X! 		    You("hear a%s splash.", lava ? " sizzling" : "");
X! 		wake_nearby();
X  
X  		if (fills_up && u.uinwater && distu(rx,ry) == 0) {
X- 		    You("find yourself on dry land again!");
X  		    u.uinwater = 0;
X  		} else if (lava && distu(rx,ry) <= 2) {
X  		    You("are hit by molten lava%c",
X  			Fire_resistance ? '.' : '!');
X--- 95,119 ----
X  		}
X  	    }
X  	    if (!fills_up || !pushing) {	/* splashing occurs */
X! 		if (!u.uinwater) {
X! 		    if (pushing ? !Blind : cansee(rx,ry)) {
X! 			boolean moat = (ltyp != WATER) &&
X! 			    !Is_medusa_level(&u.uz) && !Is_waterlevel(&u.uz);
X  
X+ 			pline("There is a large splash as %s %s the %s.",
X+ 			      the(xname(otmp)), fills_up? "fills":"falls into",
X+ 			      lava ? "lava" : ltyp==POOL ? "pool" :
X+ 			      moat ? "moat" : "water");
X+ 		    } else if (flags.soundok)
X+ 			You("hear a%s splash.", lava ? " sizzling" : "");
X+ 		    wake_nearby();
X+ 		}
X+ 
X  		if (fills_up && u.uinwater && distu(rx,ry) == 0) {
X  		    u.uinwater = 0;
X+ 		    docrt();
X+ 		    vision_full_recalc = 1;
X+ 		    You("find yourself on dry land again!");
X  		} else if (lava && distu(rx,ry) <= 2) {
X  		    You("are hit by molten lava%c",
X  			Fire_resistance ? '.' : '!');
X***************
X*** 136,141 ****
X--- 144,152 ----
X  {
X  	struct trap *t;
X  
X+ 	/* make sure things like water_damage() have no pointers to follow */
X+ 	obj->nobj = obj->nexthere = (struct obj *)0;
X+ 
X  	if (obj->otyp == BOULDER && boulder_hits_pool(obj, x, y, FALSE))
X  		return TRUE;
X  	else if (obj->otyp == BOULDER && (t = t_at(x,y)) != 0 &&
X***************
X*** 149,170 ****
X  		    (u.utrap && x==u.ux && y==u.uy)) {
X  		    /* u.utrap = 0;     /* player remains trapped. See trap.c */
X  		    if (*verb)
X! 			pline("The boulder %ss into the pit%s.", verb, 
X! 			      (mtmp)? "" : " with you");
X  		    if (mtmp) {
X  			if (!passes_walls(mtmp->data) && !throws_rocks(mtmp->data))
X  				if (hmon(mtmp, obj, TRUE))
X! 					return FALSE; 	       /* still alive */
X  				else
X  					delallobj(x, y);  /* treasure, corpse */
X  		    } else
X  #ifdef POLYSELF
X! 		    	if (!passes_walls(uasmon) && !throws_rocks(uasmon))
X  #endif
X  			{
X! 			       losehp(rnd(15), "squished under a boulder",
X! 			       	      NO_KILLER_PREFIX);
X! 		    	       return FALSE;
X  			}
X  		}
X  		if (*verb) {
X--- 160,181 ----
X  		    (u.utrap && x==u.ux && y==u.uy)) {
X  		    /* u.utrap = 0;     /* player remains trapped. See trap.c */
X  		    if (*verb)
X! 			pline("The boulder %ss into the pit%s.", verb,
X! 				(mtmp) ? "" : " with you");
X  		    if (mtmp) {
X  			if (!passes_walls(mtmp->data) && !throws_rocks(mtmp->data))
X  				if (hmon(mtmp, obj, TRUE))
X! 					return FALSE;	  /* still alive */
X  				else
X  					delallobj(x, y);  /* treasure, corpse */
X  		    } else
X  #ifdef POLYSELF
X! 			if (!passes_walls(uasmon) && !throws_rocks(uasmon))
X  #endif
X  			{
X! 				losehp(rnd(15), "squished under a boulder",
X! 					NO_KILLER_PREFIX);
X! 				return FALSE;
X  			}
X  		}
X  		if (*verb) {
X***************
X*** 175,183 ****
X  					You("hear the boulder %s.", verb);
X  			} else if (cansee(x, y)) {
X  				pline("The boulder %sfills a %s.",
X! 				      t->tseen ? "" : "triggers and ",
X! 				      t->ttyp == TRAPDOOR ? 
X! 				      "trap door" : "pit");
X  			}
X  		}
X  		deltrap(t);
X--- 186,194 ----
X  					You("hear the boulder %s.", verb);
X  			} else if (cansee(x, y)) {
X  				pline("The boulder %sfills a %s.",
X! 					 t->tseen ? "" : "triggers and ",
X! 					 t->ttyp == TRAPDOOR ?
X! 					 "trap door" : "pit");
X  			}
X  		}
X  		deltrap(t);
X***************
X*** 184,189 ****
X--- 195,202 ----
X  		obfree(obj, (struct obj *)0);
X  		newsym(x,y);
X  		return TRUE;
X+ 	} else if (is_pool(x, y)) {
X+ 		water_damage(obj, FALSE, FALSE);
X  	}
X  	return FALSE;
X  }
X***************
X*** 198,207 ****
X  	if (Blind) return;
X  	if (obj->blessed || obj->cursed) {
X  		pline("There is %s flash as %s hit%s the altar.",
X! 		      an(Hallucination ? hcolor() :
X! 			 obj->blessed ? amber : Black),
X! 		      doname(obj),
X! 		      (obj->quan == 1L) ? "s" : "");
X  		if (!Hallucination) obj->bknown = 1;
X  	} else {
X  		pline("%s land%s on the altar.", Doname2(obj),
X--- 211,220 ----
X  	if (Blind) return;
X  	if (obj->blessed || obj->cursed) {
X  		pline("There is %s flash as %s hit%s the altar.",
X! 			an(Hallucination ? hcolor() :
X! 				obj->blessed ? amber : Black),
X! 			doname(obj),
X! 			(obj->quan == 1L) ? "s" : "");
X  		if (!Hallucination) obj->bknown = 1;
X  	} else {
X  		pline("%s land%s on the altar.", Doname2(obj),
X***************
X*** 231,240 ****
X--- 244,259 ----
X  	register boolean ideed = TRUE;
X  
X  	You("drop %s down the drain.", doname(obj));
X+ #ifndef NO_SIGNAL
X+ 	obj->in_use = TRUE;	/* block free identification via interrupt */
X+ #endif
X  	switch(obj->otyp) {	/* effects that can be noticed without eyes */
X  	    case RIN_SEARCHING:
X  		You("thought your %s got lost in the sink, but there it is!",
X  			xname(obj));
X+ #ifndef NO_SIGNAL
X+ 		obj->in_use = FALSE;
X+ #endif
X  		dropx(obj);
X  		trycall(obj);
X  		return;
X***************
X*** 339,344 ****
X--- 358,366 ----
X  	    You("hear the ring bouncing down the drainpipe.");
X  	if (!rn2(20)) {
X  		pline("The sink backs up, leaving %s.", doname(obj));
X+ #ifndef NO_SIGNAL
X+ 		obj->in_use = FALSE;
X+ #endif
X  		dropx(obj);
X  	}
X  	else
X***************
X*** 356,362 ****
X  register const char *word;
X  {
X  	if(obj->owornmask & (W_ARMOR | W_RING | W_AMUL | W_TOOL)){
X! 	       if (*word)
X  			Norep("You cannot %s something you are wearing.",word);
X  		return(FALSE);
X  	}
X--- 378,384 ----
X  register const char *word;
X  {
X  	if(obj->owornmask & (W_ARMOR | W_RING | W_AMUL | W_TOOL)){
X! 		if (*word)
X  			Norep("You cannot %s something you are wearing.",word);
X  		return(FALSE);
X  	}
X***************
X*** 380,386 ****
X  	}
X  #ifdef WALKIES
X  	if (obj->otyp == LEASH && obj->leashmon != 0) {
X! 	       if (*word)
X  			pline ("The leash is tied around your %s.",
X  					body_part(HAND));
X  		return(FALSE);
X--- 402,408 ----
X  	}
X  #ifdef WALKIES
X  	if (obj->otyp == LEASH && obj->leashmon != 0) {
X! 		if (*word)
X  			pline ("The leash is tied around your %s.",
X  					body_part(HAND));
X  		return(FALSE);
X***************
X*** 412,417 ****
X--- 434,447 ----
X  		return(1);
X  	}
X  #endif
X+ 	if (Levitation && !(Is_airlevel(&u.uz) || Is_waterlevel(&u.uz) ||
X+ 			    is_pool(u.ux, u.uy) || u.uswallow)) {
X+ 	    if(flags.verbose) You("drop %s.", doname(obj));
X+ 	    if (obj->otyp != GOLD_PIECE) freeinv(obj);
X+ 	    (void) snuff_candle(obj);
X+ 	    hitfloor(obj);
X+ 	    return(1);
X+ 	}
X  	if (IS_ALTAR(levl[u.ux][u.uy].typ) && !u.uswallow) {
X  		doaltarobj(obj);	/* set bknown */
X  	} else
X***************
X*** 429,435 ****
X  	if (obj->otyp != GOLD_PIECE) freeinv(obj);
X  	(void) snuff_candle(obj);
X  	if(!u.uswallow && obj != uball &&
X! 		          ship_object(obj, u.ux, u.uy, FALSE)) return;
X  	dropy(obj);
X  }
X  
X--- 459,465 ----
X  	if (obj->otyp != GOLD_PIECE) freeinv(obj);
X  	(void) snuff_candle(obj);
X  	if(!u.uswallow && obj != uball &&
X! 			  ship_object(obj, u.ux, u.uy, FALSE)) return;
X  	dropy(obj);
X  }
X  
X***************
X*** 483,489 ****
X  #ifdef OVL2
X  
X  /* on a ladder, used in goto_level */
X! static boolean NEARDATA at_ladder = FALSE;
X  
X  int
X  dodown()
X--- 513,519 ----
X  #ifdef OVL2
X  
X  /* on a ladder, used in goto_level */
X! static NEARDATA boolean at_ladder = FALSE;
X  
X  int
X  dodown()
X***************
X*** 516,522 ****
X  		You("are standing at the gate to Gehennom.");
X  		pline("Unspeakable cruelty and harm lurk down there.");
X  		if (yn("Are you sure you want to enter?") != 'y')
X! 		     return(0);
X  		else pline("So be it.");
X  		u.uevent.gehennom_entered = 1;	/* don't ask again */
X  	}
X--- 546,552 ----
X  		You("are standing at the gate to Gehennom.");
X  		pline("Unspeakable cruelty and harm lurk down there.");
X  		if (yn("Are you sure you want to enter?") != 'y')
X! 			return(0);
X  		else pline("So be it.");
X  		u.uevent.gehennom_entered = 1;	/* don't ask again */
X  	}
X***************
X*** 546,552 ****
X  	     && (!xupladder || u.ux != xupladder || u.uy != yupladder)
X  	     && (!sstairs.sx || u.ux != sstairs.sx || u.uy != sstairs.sy
X  			|| !sstairs.up)
X!  	  ) {
X  		You("can't go up here.");
X  		return(0);
X  	}
X--- 576,582 ----
X  	     && (!xupladder || u.ux != xupladder || u.uy != yupladder)
X  	     && (!sstairs.sx || u.ux != sstairs.sx || u.uy != sstairs.sy
X  			|| !sstairs.up)
X! 	  ) {
X  		You("can't go up here.");
X  		return(0);
X  	}
X***************
X*** 557,563 ****
X  	if(near_capacity() > SLT_ENCUMBER) {
X  		/* No levitation check; inv_weight() already allows for it */
X  		Your("load is too heavy to climb the %s.",
X! 		      levl[u.ux][u.uy].typ == STAIRS ? "stairs" : "ladder");
X  		return(1);
X  	}
X  	if(ledger_no(&u.uz) == 1) {
X--- 587,593 ----
X  	if(near_capacity() > SLT_ENCUMBER) {
X  		/* No levitation check; inv_weight() already allows for it */
X  		Your("load is too heavy to climb the %s.",
X! 			levl[u.ux][u.uy].typ == STAIRS ? "stairs" : "ladder");
X  		return(1);
X  	}
X  	if(ledger_no(&u.uz) == 1) {
X***************
X*** 584,589 ****
X--- 614,623 ----
X  {
X  	register int fd;
X  
X+ 	/* since level change might be a bit slow, flush any buffered screen
X+ 	 *  output (like "you fall through a trapdoor") */
X+ 	mark_synch();
X+ 
X  	fd = create_levelfile(ledger_no(&u.uz));
X  
X  	if(fd < 0) {
X***************
X*** 636,643 ****
X  badspot(x, y)
X  register xchar x, y;
X  {
X!         return((levl[x][y].typ != ROOM && levl[x][y].typ != AIR &&
X! 		         levl[x][y].typ != CORR) || MON_AT(x, y));
X  }
X  */
X  
X--- 670,677 ----
X  badspot(x, y)
X  register xchar x, y;
X  {
X! 	return((levl[x][y].typ != ROOM && levl[x][y].typ != AIR &&
X! 			 levl[x][y].typ != CORR) || MON_AT(x, y));
X  }
X  */
X  
X***************
X*** 653,716 ****
X  	int new = 0;	/* made a new level? */
X  #endif
X  
X! 	if(dunlev(newlevel) > dunlevs_in_dungeon(newlevel))
X! 	    	newlevel->dlevel = dunlevs_in_dungeon(newlevel);
X! 	if(newdungeon && In_endgame(newlevel)) { /* 1st Endgame Level !!! */
X! 	    	if(u.uhave.amulet) 
X  		    assign_level(newlevel, &earth_level);
X! 	    	else return;
X  	}
X! 	if(ledger_no(newlevel) <= 0)
X! 	    	done(ESCAPED);	/* in fact < 0 is impossible */
X  	/* If you have the amulet and are trying to get out of Hell, going
X  	 * up a set of stairs sometimes does some very strange things!
X  	 */
X! 	if(Inhell && up && !newdungeon && u.uhave.amulet &&
X! 	   			(dunlev(&u.uz) < dunlevs_in_dungeon(&u.uz)-3)) {
X! 	    	if(!rn2(4)) {
X! 		    if(!u.ualign.type) {		    /* neutral */
X! 		        if(rn2(2)) assign_level(newlevel, &u.uz);
X! 		        else assign_rnd_level(newlevel, &u.uz, rnd(3));
X! 		    } else if(u.ualign.type == A_LAWFUL) {    /* lawful */
X  			assign_rnd_level(newlevel, &u.uz, rnd(3));
X! 		    } else assign_level(newlevel, &u.uz); /* chaotic */
X! 	        }
X! 		pline("A mysterious force momentarily surrounds you...");
X! 	    	if(ledger_no(newlevel) < 1) assign_level(newlevel, &u.uz);
X! 	    	if(on_level(newlevel, &u.uz)) {
X! 		    (void) safe_teleds();
X  #ifdef WALKIES
X! 		    (void) next_to_u();
X  #endif
X! 		    return;
X  		}
X  	}
X  #ifdef MULDGN
X! /*	Prevent the player from going past the first quest level unless
X!  *	(s)he has been given the go-ahead by the leader.
X!  */
X! 	if(on_level(&u.uz, &qstart_level) && !newdungeon && !ok_to_quest()) {
X  
X  		pline("A mysterious force prevents you from descending.");
X  		return;
X  	}
X  #endif
X! 	if(on_level(newlevel, &u.uz)) return;	      /* this can happen */
X  
X  	fd = currentlevel_rewrite();
X! 	if(fd < 0) return;
X  
X  	if (falling) /* assuming this is only trapdoor */
X  	    impact_drop((struct obj *)0, u.ux, u.uy, newlevel->dlevel);
X  
X  	check_special_room(TRUE);		/* probably was a trap door */
X! 	if(Punished) unplacebc();
X  	u.utrap = 0;				/* needed in level_tele */
X  	fill_pit(u.ux, u.uy);
X  	u.ustuck = 0;				/* idem */
X  	u.uinwater = 0;
X  	keepdogs();
X! 	if(u.uswallow)				/* idem */
X  		u.uswldtim = u.uswallow = 0;
X  	/*
X  	 *  We no longer see anything on the level.  Make sure that this
X--- 687,749 ----
X  	int new = 0;	/* made a new level? */
X  #endif
X  
X! 	if (dunlev(newlevel) > dunlevs_in_dungeon(newlevel))
X! 		newlevel->dlevel = dunlevs_in_dungeon(newlevel);
X! 	if (newdungeon && In_endgame(newlevel)) { /* 1st Endgame Level !!! */
X! 		if (u.uhave.amulet)
X  		    assign_level(newlevel, &earth_level);
X! 		else return;
X  	}
X! 	if (ledger_no(newlevel) <= 0)
X! 		done(ESCAPED);	/* in fact < 0 is impossible */
X  	/* If you have the amulet and are trying to get out of Hell, going
X  	 * up a set of stairs sometimes does some very strange things!
X  	 */
X! 	if (Inhell && up && !newdungeon && u.uhave.amulet &&
X! 				(dunlev(&u.uz) < dunlevs_in_dungeon(&u.uz)-3)) {
X! 		if (!rn2(4)) {
X! 		    if (u.ualign.type == A_CHAOTIC ||
X! 			    (u.ualign.type == A_NEUTRAL && rn2(2)))
X! 			assign_level(newlevel, &u.uz);
X! 		    else
X  			assign_rnd_level(newlevel, &u.uz, rnd(3));
X! 
X! 		    pline("A mysterious force momentarily surrounds you...");
X! 		    if (on_level(newlevel, &u.uz)) {
X! 			(void) safe_teleds();
X  #ifdef WALKIES
X! 			(void) next_to_u();
X  #endif
X! 			return;
X! 		    }
X  		}
X  	}
X  #ifdef MULDGN
X! 	/* Prevent the player from going past the first quest level unless
X! 	 * (s)he has been given the go-ahead by the leader.
X! 	 */
X! 	if (on_level(&u.uz, &qstart_level) && !newdungeon && !ok_to_quest()) {
X  
X  		pline("A mysterious force prevents you from descending.");
X  		return;
X  	}
X  #endif
X! 	if (on_level(newlevel, &u.uz)) return;		/* this can happen */
X  
X  	fd = currentlevel_rewrite();
X! 	if (fd < 0) return;
X  
X  	if (falling) /* assuming this is only trapdoor */
X  	    impact_drop((struct obj *)0, u.ux, u.uy, newlevel->dlevel);
X  
X  	check_special_room(TRUE);		/* probably was a trap door */
X! 	if (Punished) unplacebc();
X  	u.utrap = 0;				/* needed in level_tele */
X  	fill_pit(u.ux, u.uy);
X  	u.ustuck = 0;				/* idem */
X  	u.uinwater = 0;
X  	keepdogs();
X! 	if (u.uswallow)				/* idem */
X  		u.uswldtim = u.uswallow = 0;
X  	/*
X  	 *  We no longer see anything on the level.  Make sure that this
X***************
X*** 730,736 ****
X  	assign_level(&u.uz, newlevel);
X  	assign_level(&u.utolev, newlevel);
X  	u.utotype = 0;
X! 	if(dunlev_reached(&u.uz) < dunlev(&u.uz))
X  		dunlev_reached(&u.uz) = dunlev(&u.uz);
X  
X  	/* set default level change destination areas */
X--- 763,769 ----
X  	assign_level(&u.uz, newlevel);
X  	assign_level(&u.utolev, newlevel);
X  	u.utotype = 0;
X! 	if (dunlev_reached(&u.uz) < dunlev(&u.uz))
X  		dunlev_reached(&u.uz) = dunlev(&u.uz);
X  
X  	/* set default level change destination areas */
X***************
X*** 738,744 ****
X  	(void) memset((genericptr_t) &updest, 0, sizeof updest);
X  	(void) memset((genericptr_t) &dndest, 0, sizeof dndest);
X  
X! 	if(In_endgame(&u.uz) ||
X  #ifdef MFLOPPY
X  	    /* If the level has no .where yet, it hasn't been made */
X  	    !fileinfo[ledger_no(&u.uz)].where) {
X--- 771,777 ----
X  	(void) memset((genericptr_t) &updest, 0, sizeof updest);
X  	(void) memset((genericptr_t) &dndest, 0, sizeof dndest);
X  
X! 	if (In_endgame(&u.uz) ||
X  #ifdef MFLOPPY
X  	    /* If the level has no .where yet, it hasn't been made */
X  	    !fileinfo[ledger_no(&u.uz)].where) {
X***************
X*** 763,791 ****
X  		getlev(fd, hackpid, ledger_no(&u.uz), FALSE);
X  		(void) close(fd);
X  	}
X- #ifdef MULDGN
X- 	quest_init();	/* re-initialize */
X- #endif
X  
X! 	if(portal && !In_endgame(&u.uz)) {
X  	    /* find the portal on the new level */
X  	    register struct trap *ttrap;
X  
X! 	    for(ttrap = ftrap; ttrap; ttrap = ttrap->ntrap)
X! 		if(ttrap->ttyp == MAGIC_PORTAL) break;
X  
X! 	    if(ttrap) {
X! 		u.ux = ttrap->tx;
X! 		u.uy = ttrap->ty;
X! 	    } else panic("goto_level: no corresponding portal!");
X! 	} else if(at_stairs && !In_endgame(&u.uz)) {
X! 	    if(up) {
X! 		if(at_ladder) {
X  		    u.ux = xdnladder;
X  		    u.uy = ydnladder;
X  		} else {
X! 		    if(newdungeon) {
X! 			if(Is_stronghold(&u.uz)) {
X  			    register xchar x, y;
X  
X  			    do {
X--- 796,820 ----
X  		getlev(fd, hackpid, ledger_no(&u.uz), FALSE);
X  		(void) close(fd);
X  	}
X  
X! 	if (portal && !In_endgame(&u.uz)) {
X  	    /* find the portal on the new level */
X  	    register struct trap *ttrap;
X  
X! 	    for (ttrap = ftrap; ttrap; ttrap = ttrap->ntrap)
X! 		if (ttrap->ttyp == MAGIC_PORTAL) break;
X  
X! 	    if (!ttrap) panic("goto_level: no corresponding portal!");
X! 	    u.ux = ttrap->tx;
X! 	    u.uy = ttrap->ty;
X! 	} else if (at_stairs && !In_endgame(&u.uz)) {
X! 	    if (up) {
X! 		if (at_ladder) {
X  		    u.ux = xdnladder;
X  		    u.uy = ydnladder;
X  		} else {
X! 		    if (newdungeon) {
X! 			if (Is_stronghold(&u.uz)) {
X  			    register xchar x, y;
X  
X  			    do {
X***************
X*** 797,865 ****
X  			    u.uy = y;
X  			} else u_on_sstairs();
X  		    } else u_on_dnstairs();
X! 		} 
X! 		/* Remove bug which crashes with */ 
X! 		/* levitation/punishment  KAA    */
X! 		if(Punished) {
X! 		    if(!Levitation)
X  			pline("With great effort you climb the %s.",
X! 			      !at_ladder ? "stairs" : "ladder");
X! 		    placebc();
X! 		} 
X! 		if(at_ladder && (!Punished || Levitation))
X  		    You("climb up the ladder.");
X! 	    } else { /* down */
X! 		if(at_ladder) {
X  		    u.ux = xupladder;
X  		    u.uy = yupladder;
X  		} else {
X! 		    if(newdungeon) u_on_sstairs();
X  		    else u_on_upstairs();
X  		}
X! 		if(at_stairs && u.dz && !up &&
X! 		   ((near_capacity()>UNENCUMBERED) || Punished || Fumbling)) {
X! 		    You("fall down the %s.",
X! 			!at_ladder ? "stairs" : "ladder");
X! 		    if(Punished) {
X  			drag_down();
X! 			if(carried(uball)) {
X  			    if (uwep == uball)
X  				setuwep((struct obj *)0);
X! 			    if (uwep != uball)
X! 				freeinv(uball);
X  			}
X! 			placebc();
X! 		    } 
X  		    losehp(rnd(3), "falling downstairs", KILLED_BY);
X  		    selftouch("Falling, you");
X! 		} 
X! 		else if(at_ladder && u.dz)
X  		    You("climb down the ladder.");
X  	    }
X! 	} else { /* trap door or level_tele or In_endgame */
X! 	    if(up)
X  		place_lregion(updest.lx, updest.ly,
X! 			      updest.hx, updest.hy,
X! 			      updest.nlx, updest.nly,
X! 			      updest.nhx, updest.nhy,
X! 			      LR_UPTELE, (d_level *) 0);
X  	    else
X  		place_lregion(dndest.lx, dndest.ly,
X! 			      dndest.hx, dndest.hy,
X! 			      dndest.nlx, dndest.nly,
X! 			      dndest.nhx, dndest.nhy,
X! 			      LR_DOWNTELE, (d_level *) 0);
X! 	    if(Punished) {
X! 		if(falling) ballfall();
X! 		placebc();
X! 	    }
X! 	    if(falling)
X  		selftouch("Falling, you");
X  	}
X  
X  	losedogs();
X  	obj_delivery();
X- 	check_special_room(FALSE);
X  
X  	initrack();
X  
X--- 826,884 ----
X  			    u.uy = y;
X  			} else u_on_sstairs();
X  		    } else u_on_dnstairs();
X! 		}
X! 		/* Remove bug which crashes with levitation/punishment  KAA */
X! 		if (Punished && !Levitation) {
X  			pline("With great effort you climb the %s.",
X! 				at_ladder ? "ladder" : "stairs");
X! 		} else if (at_ladder)
X  		    You("climb up the ladder.");
X! 	    } else {	/* down */
X! 		if (at_ladder) {
X  		    u.ux = xupladder;
X  		    u.uy = yupladder;
X  		} else {
X! 		    if (newdungeon) u_on_sstairs();
X  		    else u_on_upstairs();
X  		}
X! 		if (u.dz &&
X! 		    (near_capacity() > UNENCUMBERED || Punished || Fumbling)) {
X! 		    You("fall down the %s.", at_ladder ? "ladder" : "stairs");
X! 		    if (Punished) {
X  			drag_down();
X! 			if (carried(uball)) {
X  			    if (uwep == uball)
X  				setuwep((struct obj *)0);
X! 			    freeinv(uball);
X  			}
X! 		    }
X  		    losehp(rnd(3), "falling downstairs", KILLED_BY);
X  		    selftouch("Falling, you");
X! 		} else if (u.dz && at_ladder)
X  		    You("climb down the ladder.");
X  	    }
X! 	} else {	/* trap door or level_tele or In_endgame */
X! 	    if (up)
X  		place_lregion(updest.lx, updest.ly,
X! 				updest.hx, updest.hy,
X! 				updest.nlx, updest.nly,
X! 				updest.nhx, updest.nhy,
X! 				LR_UPTELE, (d_level *) 0);
X  	    else
X  		place_lregion(dndest.lx, dndest.ly,
X! 				dndest.hx, dndest.hy,
X! 				dndest.nlx, dndest.nly,
X! 				dndest.nhx, dndest.nhy,
X! 				LR_DOWNTELE, (d_level *) 0);
X! 	    if (falling) {
X! 		if (Punished) ballfall();
X  		selftouch("Falling, you");
X+ 	    }
X  	}
X  
X+ 	if (Punished) placebc();
X  	losedogs();
X  	obj_delivery();
X  
X  	initrack();
X  
X***************
X*** 878,895 ****
X  	vision_reset();		/* reset the blockages */
X  	docrt();		/* does a full vision recalc */
X  
X  	/* In Nethack 3.1, Gehennom starts after the stronghold.  Moreover,
X  	 * there are traps in the stronghold, that can send the player
X  	 * to Gehennom (gnark, gnark)!  So we have to test here:
X  	 */
X  	if(!In_hell(&u.uz0) && Inhell) {
X!             if(Is_valley(newlevel)) {
X  		You("arrive at the Valley of the Dead...");
X! 	    	pline("There is a smell of burnt flesh and decay here.");
X  #ifdef MICRO
X! 	    	display_nhwindow(WIN_MESSAGE, FALSE);
X  #endif
X! 		pline("The sounds of groans and moans fill the air.");
X  	    } else pline("It is hot here.  You smell smoke...");
X  	}
X  
X--- 897,917 ----
X  	vision_reset();		/* reset the blockages */
X  	docrt();		/* does a full vision recalc */
X  
X+ 	/* give room entrance message, if any */
X+ 	check_special_room(FALSE);
X+ 
X  	/* In Nethack 3.1, Gehennom starts after the stronghold.  Moreover,
X  	 * there are traps in the stronghold, that can send the player
X  	 * to Gehennom (gnark, gnark)!  So we have to test here:
X  	 */
X  	if(!In_hell(&u.uz0) && Inhell) {
X! 	    if(Is_valley(newlevel)) {
X  		You("arrive at the Valley of the Dead...");
X! 		pline("The odor of burnt flesh and decay pervades the air.");
X  #ifdef MICRO
X! 		display_nhwindow(WIN_MESSAGE, FALSE);
X  #endif
X! 		You("hear groans and moans everywhere.");
X  	    } else pline("It is hot here.  You smell smoke...");
X  	}
X  
X***************
X*** 898,904 ****
X  	 *  Move all plines beyond the screen reset.
X  	 */
X  	if (new && Is_rogue_level(&u.uz))
X! 	 You("have entered what appears to be an older, more primitive world.");
X  #endif
X  	/* Final confrontation */
X  	if (In_endgame(&u.uz) && newdungeon && u.uhave.amulet &&
X--- 920,926 ----
X  	 *  Move all plines beyond the screen reset.
X  	 */
X  	if (new && Is_rogue_level(&u.uz))
X! 	    You("enter what seems to be an older, more primitive world.");
X  #endif
X  	/* Final confrontation */
X  	if (In_endgame(&u.uz) && newdungeon && u.uhave.amulet &&
X***************
X*** 912,930 ****
X  	    com_pager(2);	/* the message from the leader */
X  
X  	if(Is_knox(&u.uz)) {
X! 	        register struct monst *mtmp;
X  
X! 	        You("penetrated a high security area!");
X  		pline("An alarm sounds!");
X! 		for(mtmp = fmon; mtmp; mtmp = mtmp->nmon) 
X  		    if(mtmp->msleep) mtmp->msleep = 0;
X  	}
X  #endif /* MULDGN */
X  	if(on_level(&u.uz, &astral_level)) {
X! 	        register struct monst *mtmp;
X  
X! 	        /* reset monster hostility relative to player */
X! 		for(mtmp = fmon; mtmp; mtmp = mtmp->nmon) 
X  		    reset_hostility(mtmp);
X  
X  		/* create some player-monsters */
X--- 934,952 ----
X  	    com_pager(2);	/* the message from the leader */
X  
X  	if(Is_knox(&u.uz)) {
X! 		register struct monst *mtmp;
X  
X! 		You("penetrated a high security area!");
X  		pline("An alarm sounds!");
X! 		for(mtmp = fmon; mtmp; mtmp = mtmp->nmon)
X  		    if(mtmp->msleep) mtmp->msleep = 0;
X  	}
X  #endif /* MULDGN */
X  	if(on_level(&u.uz, &astral_level)) {
X! 		register struct monst *mtmp;
X  
X! 		/* reset monster hostility relative to player */
X! 		for(mtmp = fmon; mtmp; mtmp = mtmp->nmon)
X  		    reset_hostility(mtmp);
X  
X  		/* create some player-monsters */
X***************
X*** 934,980 ****
X  		if (Conflict) {
X  		    coord mm;
X  		    int i = rnd(4);
X! 	pline("A voice booms: \"Thy desire for conflict shall be rewarded!\"");
X  		    while(i--) {
X  			mm.x = u.ux;
X  			mm.y = u.uy;
X  			if(enexto(&mm, mm.x, mm.y, &mons[PM_ANGEL]))
X  			    (void) mk_roamer(&mons[PM_ANGEL], u.ualign.type,
X! 					     mm.x, mm.y, FALSE);
X  		    }
X  
X! 		} else if(u.ualign.record > 3) {
X  		    coord mm;
X  
X  		pline("A voice whispers: \"Thou hast been worthy of me!\"");
X  		    mm.x = u.ux;
X  		    mm.y = u.uy;
X! 		    if(enexto(&mm, mm.x, mm.y, &mons[PM_ANGEL])) {
X! 			if((mtmp = mk_roamer(&mons[PM_ANGEL], u.ualign.type,
X  					   mm.x, mm.y, TRUE)) != 0) {
X! 			     register struct obj *otmp =
X! 			                   mksobj(SILVER_SABER, FALSE, FALSE);
X  
X! 			     if(!Blind)
X! 		                 pline("An angel appears near you.");
X! 			     else 
X! 		       You("feel the presence of a friendly angel near you.");
X  			    /* guardian angel -- the one case mtame doesn't
X  			     * imply an edog structure, so we don't want to
X  			     * call tamedog().
X  			     */
X! 			     mtmp->mtame = 10;
X! 			     /* make him strong enough vs. endgame foes */
X! 			     mtmp->m_lev = rn1(8,15);
X! 			     mtmp->mhp = mtmp->mhpmax = 
X! 				       d((int)mtmp->m_lev,10) + 30 + rnd(30);
X! 			     bless(otmp);
X! 			     otmp->spe = 7;
X! 			     mpickobj(mtmp, otmp);
X! 		        }
X  		    }
X  		}
X!         }
X  
X  #ifdef MULDGN
X  	onquest();
X--- 956,1002 ----
X  		if (Conflict) {
X  		    coord mm;
X  		    int i = rnd(4);
X! 	pline("A voice booms: \"Thy desire for conflict shall be fulfilled!\"");
X  		    while(i--) {
X  			mm.x = u.ux;
X  			mm.y = u.uy;
X  			if(enexto(&mm, mm.x, mm.y, &mons[PM_ANGEL]))
X  			    (void) mk_roamer(&mons[PM_ANGEL], u.ualign.type,
X! 						mm.x, mm.y, FALSE);
X  		    }
X  
X! 		} else if(u.ualign.record > 8 /* fervent */) {
X  		    coord mm;
X  
X  		pline("A voice whispers: \"Thou hast been worthy of me!\"");
X  		    mm.x = u.ux;
X  		    mm.y = u.uy;
X! 		    if (enexto(&mm, mm.x, mm.y, &mons[PM_ANGEL])) {
X! 			if ((mtmp = mk_roamer(&mons[PM_ANGEL], u.ualign.type,
X  					   mm.x, mm.y, TRUE)) != 0) {
X! 			    register struct obj *otmp =
X! 					   mksobj(SILVER_SABER, FALSE, FALSE);
X  
X! 			    if (!Blind)
X! 				pline("An angel appears near you.");
X! 			    else
X! 			You("feel the presence of a friendly angel near you.");
X  			    /* guardian angel -- the one case mtame doesn't
X  			     * imply an edog structure, so we don't want to
X  			     * call tamedog().
X  			     */
X! 			    mtmp->mtame = 10;
X! 			    /* make him strong enough vs. endgame foes */
X! 			    mtmp->m_lev = rn1(8,15);
X! 			    mtmp->mhp = mtmp->mhpmax =
X! 					d((int)mtmp->m_lev,10) + 30 + rnd(30);
X! 			    bless(otmp);
X! 			    otmp->spe = 7;
X! 			    mpickobj(mtmp, otmp);
X! 			}
X  		    }
X  		}
X! 	}
X  
X  #ifdef MULDGN
X  	onquest();
X***************
X*** 1101,1106 ****
X--- 1123,1129 ----
X  	} else if(obj->cobj && Is_container(obj) && obj->otyp != ICE_BOX)
X  	    remove_cadavers(&obj->cobj);
X  	/* pobj is only used for containers, which don't allow revive() -dlc */
X+ 	/* and for monster inventory (special cases only) under MUSE */
X  	if (obj) pobj = obj;
X      }
X  }
X***************
X*** 1136,1142 ****
X  dowipe()
X  {
X  	if(u.ucreamed)  {
X! 		static char NEARDATA buf[39];
X  
X  		Sprintf(buf, "wiping off your %s", body_part(FACE));
X  		set_occupation(wipeoff, buf, 0);
X--- 1159,1165 ----
X  dowipe()
X  {
X  	if(u.ucreamed)  {
X! 		static NEARDATA char buf[39];
X  
X  		Sprintf(buf, "wiping off your %s", body_part(FACE));
X  		set_occupation(wipeoff, buf, 0);
X*** /tmp/da08109	Thu Feb 25 10:22:39 1993
X--- src/do_name.c	Tue Feb 23 09:59:57 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)do_name.c	3.1	92/12/29	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)do_name.c	3.1	93/02/22	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 29,34 ****
X--- 29,37 ----
X  #endif
X      curs(WIN_MAP, cx,cy);
X      flush_screen(0);
X+ #ifdef MAC
X+ 	lock_mouse_cursor(TRUE);
X+ #endif
X      while((c = nh_poskey(&tx, &ty, &sidx)) != '.') {
X          if(c == '\033') {
X              cc->x = -10;
X***************
X*** 86,93 ****
X  		    loopback:
X  			for (ty = lasty; ty < ROWNO; ty++) {
X  			    for (tx = lastx; tx < COLNO; tx++) {
X! 				if ((IS_POOL(levl[tx][ty].typ) ||
X! 				     IS_FURNITURE(levl[tx][ty].typ)) &&
X  	 defsyms[sidx].sym == defsyms[glyph_to_cmap(levl[tx][ty].glyph)].sym) {
X  				    cx = tx;
X  				    lastx = tx+1;
X--- 89,95 ----
X  		    loopback:
X  			for (ty = lasty; ty < ROWNO; ty++) {
X  			    for (tx = lastx; tx < COLNO; tx++) {
X! 				if (glyph_is_cmap(levl[tx][ty].glyph) &&
X  	 defsyms[sidx].sym == defsyms[glyph_to_cmap(levl[tx][ty].glyph)].sym) {
X  				    cx = tx;
X  				    lastx = tx+1;
X***************
X*** 127,132 ****
X--- 129,137 ----
X  	curs(WIN_MAP,cx,cy);
X  	flush_screen(0);
X      }
X+ #ifdef MAC
X+ 	lock_mouse_cursor(FALSE);
X+ #endif
X      cc->x = cx;
X      cc->y = cy;
X      return;
X***************
X*** 198,204 ****
X  	Sprintf(qbuf, "What do you want to call %s?", x_monnam(mtmp, 0,
X  		(char *)0, 1));
X  	getlin(qbuf,buf);
X- 	clear_nhwindow(WIN_MESSAGE);
X  	if(!*buf || *buf == '\033') return(0);
X  
X  	/* unnames monster if all spaces */
X--- 203,208 ----
X***************
X*** 226,232 ****
X  
X  	Sprintf(qbuf, "What do you want to name %s?", doname(obj));
X  	getlin(qbuf, buf);
X- 	clear_nhwindow(WIN_MESSAGE);
X  	if(!*buf || *buf == '\033')	return;
X  
X  	/* strip trailing spaces; unnames item if all spaces */
X--- 230,235 ----
X***************
X*** 314,320 ****
X  	return otmp2;
X  }
X  
X! static const char NEARDATA callable[] = {
X  	SCROLL_CLASS, POTION_CLASS, WAND_CLASS, RING_CLASS, AMULET_CLASS,
X  	GEM_CLASS, SPBOOK_CLASS, ARMOR_CLASS, TOOL_CLASS, 0 };
X  
X--- 317,323 ----
X  	return otmp2;
X  }
X  
X! static NEARDATA const char callable[] = {
X  	SCROLL_CLASS, POTION_CLASS, WAND_CLASS, RING_CLASS, AMULET_CLASS,
X  	GEM_CLASS, SPBOOK_CLASS, ARMOR_CLASS, TOOL_CLASS, 0 };
X  
X***************
X*** 380,386 ****
X  	} else
X  		Sprintf(qbuf, "Call %s:", an(xname(&otemp)));
X  	getlin(qbuf, buf);
X- 	clear_nhwindow(WIN_MESSAGE);
X  	if(!*buf || *buf == '\033')
X  		return;
X  
X--- 383,388 ----
X***************
X*** 453,459 ****
X  		return name;
X  	}
X  	if(!canseemon(mtmp) && !sensemon(mtmp) &&
X! 					!(u.uswallow && mtmp == u.ustuck)) {
X  	    if(!mtmp->wormno || (mtmp != m_at(bhitpos.x, bhitpos.y)) ||
X  	       !(cansee(bhitpos.x, bhitpos.y) && mon_visible(mtmp))) {
X  		Strcpy(buf, "it");
X--- 455,461 ----
X  		return name;
X  	}
X  	if(!canseemon(mtmp) && !sensemon(mtmp) &&
X! 				!(u.uswallow && mtmp == u.ustuck) && !killer) {
X  	    if(!mtmp->wormno || (mtmp != m_at(bhitpos.x, bhitpos.y)) ||
X  	       !(cansee(bhitpos.x, bhitpos.y) && mon_visible(mtmp))) {
X  		Strcpy(buf, "it");
X***************
X*** 478,484 ****
X  		Strcat(buf, adjective);
X  		Strcat(buf, " ");
X  	}
X! 	if (mtmp->minvis)
X  		Strcat(buf, "invisible ");
X  	if (name && !called) {
X  		Strcat(buf, name);
X--- 480,486 ----
X  		Strcat(buf, adjective);
X  		Strcat(buf, " ");
X  	}
X! 	if (mtmp->minvis && !Blind)
X  		Strcat(buf, "invisible ");
X  	if (name && !called) {
X  		Strcat(buf, name);
X***************
X*** 579,585 ****
X  	return(bp);
X  }
X  
X! static const char NEARDATA *bogusmons[] = {
X  	"jumbo shrimp", "giant pigmy", "gnu", "killer penguin", 
X  	"giant cockroach", "giant slug", "maggot", "pterodactyl",
X  	"tyrannosaurus rex", "basilisk", "beholder", "nightmare",
X--- 581,587 ----
X  	return(bp);
X  }
X  
X! static NEARDATA const char *bogusmons[] = {
X  	"jumbo shrimp", "giant pigmy", "gnu", "killer penguin", 
X  	"giant cockroach", "giant slug", "maggot", "pterodactyl",
X  	"tyrannosaurus rex", "basilisk", "beholder", "nightmare",
X***************
X*** 640,646 ****
X  
X  #ifdef OVL2
X  
X! static const char NEARDATA *hcolors[] = {
X  	"ultraviolet", "infrared", "bluish-orange",
X  	"reddish-green", "dark white", "light black", "sky blue-pink",
X  	"salty", "sweet", "sour", "bitter",
X--- 642,648 ----
X  
X  #ifdef OVL2
X  
X! static NEARDATA const char *hcolors[] = {
X  	"ultraviolet", "infrared", "bluish-orange",
X  	"reddish-green", "dark white", "light black", "sky blue-pink",
X  	"salty", "sweet", "sour", "bitter",
X***************
X*** 670,676 ****
X  const char *str;
X  const char *pronoun;
X  {
X! 	static char NEARDATA buf[BUFSZ];
X  	register int i;
X  
X  	for(i=0; pronoun_pairs[i][0]; i++) {
X--- 672,678 ----
X  const char *str;
X  const char *pronoun;
X  {
X! 	static NEARDATA char buf[BUFSZ];
X  	register int i;
X  
X  	for(i=0; pronoun_pairs[i][0]; i++) {
X*** /tmp/da08117	Thu Feb 25 10:22:41 1993
X--- src/do_wear.c	Wed Feb 17 09:17:12 1993
X***************
X*** 6,12 ****
X  
X  #ifdef OVLB
X  
X! static int NEARDATA todelay;
X  
X  #endif /*OVLB */
X  
X--- 6,12 ----
X  
X  #ifdef OVLB
X  
X! static NEARDATA int todelay;
X  
X  #endif /*OVLB */
X  
X***************
X*** 16,24 ****
X  
X  #else /* OVLB */
X  
X! STATIC_OVL long NEARDATA takeoff_mask = 0L, NEARDATA taking_off = 0L;
X  
X! static const long NEARDATA takeoff_order[] = { WORN_BLINDF, 1L, /* weapon */
X  	WORN_SHIELD, WORN_GLOVES, LEFT_RING, RIGHT_RING, WORN_CLOAK,
X  	WORN_HELMET, WORN_AMUL, WORN_ARMOR,
X  #ifdef TOURIST
X--- 16,24 ----
X  
X  #else /* OVLB */
X  
X! STATIC_OVL NEARDATA long takeoff_mask = 0L, taking_off = 0L;
X  
X! static NEARDATA const long takeoff_order[] = { WORN_BLINDF, 1L, /* weapon */
X  	WORN_SHIELD, WORN_GLOVES, LEFT_RING, RIGHT_RING, WORN_CLOAK,
X  	WORN_HELMET, WORN_AMUL, WORN_ARMOR,
X  #ifdef TOURIST
X***************
X*** 220,226 ****
X  		}
X  		break;
X  	case OILSKIN_CLOAK:
X! 		pline("The %s fits very tightly.",xname(uarmc));
X  		break;
X  	default: impossible("Unknown type of cloak (%d)", uarmc->otyp);
X      }
X--- 220,226 ----
X  		}
X  		break;
X  	case OILSKIN_CLOAK:
X! 		pline("%s fits very tightly.",The(xname(uarmc)));
X  		break;
X  	default: impossible("Unknown type of cloak (%d)", uarmc->otyp);
X      }
X***************
X*** 774,781 ****
X  	multi = 0;
X  }
X  
X! static const char NEARDATA clothes[] = {ARMOR_CLASS, 0};
X! static const char NEARDATA accessories[] = {RING_CLASS, AMULET_CLASS, TOOL_CLASS, 0};
X  
X  int
X  dotakeoff()
X--- 774,781 ----
X  	multi = 0;
X  }
X  
X! static NEARDATA const char clothes[] = {ARMOR_CLASS, 0};
X! static NEARDATA const char accessories[] = {RING_CLASS, AMULET_CLASS, TOOL_CLASS, 0};
X  
X  int
X  dotakeoff()
X***************
X*** 1120,1126 ****
X  }
X  
X  int
X! doputon() {
X  	register struct obj *otmp;
X  	long mask = 0L;
X  
X--- 1120,1127 ----
X  }
X  
X  int
X! doputon()
X! {
X  	register struct obj *otmp;
X  	long mask = 0L;
X  
X
END_OF_FILE
if test 52704 -ne `wc -c <'patches01b'`; then
    echo shar: \"'patches01b'\" unpacked with wrong size!
fi
# end of 'patches01b'
echo shar: End of archive 16 \(of 31\).
cp /dev/null ark16isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 31 archives.
    echo "Now execute 'patchit.sh'"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
