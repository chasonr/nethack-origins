Subject:  v17i055:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Patch1n/31
Newsgroups: comp.sources.games
Approved: billr@saab.CNA.TEK.COM

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 17, Issue 55
Archive-name: nethack31/Patch1n
Patch-To: nethack31: Volume 16, Issue 1-116
Environment: Amiga, Atari, Mac, MS-DOS, Windows-NT, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 14 (of 31)."
# Contents:  patches01g sys/winnt/nhico.uu
# Wrapped by billr@saab on Fri Mar  5 10:50:45 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'patches01g' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'patches01g'\" to \"'patches01g.orig'\"
  mv -f 'patches01g' 'patches01g.orig'
fi
echo shar: Extracting \"'patches01g'\" \(52954 characters\)
sed "s/^X//" >'patches01g' <<'END_OF_FILE'
X*** /tmp/da08437	Thu Feb 25 10:24:27 1993
X--- src/objnam.c	Tue Feb 23 17:03:14 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)objnam.c	3.1	92/12/13	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)objnam.c	3.1	93/02/12	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 167,182 ****
X  register struct obj *obj;
X  {
X  #ifdef LINT	/* lint may handle static decl poorly -- static char bufr[]; */
X! char bufr[BUFSZ];
X  #else
X! static char bufr[BUFSZ];
X  #endif
X! register char *buf = &(bufr[PREFIX]);	/* leave room for "17 -3 " */
X! register int typ = obj->otyp;
X! register int nn = objects[typ].oc_name_known;
X! register const char *actualn = OBJ_NAME(objects[typ]);
X! register const char *dn = OBJ_DESCR(objects[typ]);
X! register const char *un = objects[typ].oc_uname;
X  
X  	if (pl_character[0] == 'S' && Japanese_item_name(typ))
X  		actualn = Japanese_item_name(typ);
X--- 167,182 ----
X  register struct obj *obj;
X  {
X  #ifdef LINT	/* lint may handle static decl poorly -- static char bufr[]; */
X! 	char bufr[BUFSZ];
X  #else
X! 	static char bufr[BUFSZ];
X  #endif
X! 	register char *buf = &(bufr[PREFIX]);	/* leave room for "17 -3 " */
X! 	register int typ = obj->otyp;
X! 	register int nn = objects[typ].oc_name_known;
X! 	register const char *actualn = OBJ_NAME(objects[typ]);
X! 	register const char *dn = OBJ_DESCR(objects[typ]);
X! 	register const char *un = objects[typ].oc_uname;
X  
X  	if (pl_character[0] == 'S' && Japanese_item_name(typ))
X  		actualn = Japanese_item_name(typ);
X***************
X*** 385,398 ****
X  	default:
X  		Sprintf(buf,"glorkum %d %d %d", obj->oclass, typ, obj->spe);
X  	}
X! 	if(obj->quan != 1L) Strcpy(buf, makeplural(buf));
X  
X! 	if(obj->onamelth &&
X! 	   (!obj->oartifact || !objects[obj->otyp].oc_unique)) {
X  		Strcat(buf, " named ");
X  	    nameit:
X  		Strcat(buf, ONAME(obj));
X  	}
X  	return(buf);
X  }
X  
X--- 385,400 ----
X  	default:
X  		Sprintf(buf,"glorkum %d %d %d", obj->oclass, typ, obj->spe);
X  	}
X! 	if (obj->quan != 1L) Strcpy(buf, makeplural(buf));
X  
X! 	if (obj->onamelth &&
X! 	    (!obj->oartifact || !objects[obj->otyp].oc_unique)) {
X  		Strcat(buf, " named ");
X  	    nameit:
X  		Strcat(buf, ONAME(obj));
X  	}
X+ 
X+ 	if (!strncmpi(buf, "the ", 4)) buf += 4;
X  	return(buf);
X  }
X  
X***************
X*** 487,493 ****
X  			Strcat(prefix,
X  			       is_rustprone(obj) ? "rusty " :
X  			       is_corrodeable(obj) ? "corroded " :
X! 			       is_flammable(obj) ? "burnt " : "");
X  		} else if (obj->rknown && obj->oerodeproof)
X  			Strcat(prefix,
X  			       is_rustprone(obj) ? "rustproof " :
X--- 489,495 ----
X  			Strcat(prefix,
X  			       is_rustprone(obj) ? "rusty " :
X  			       is_corrodeable(obj) ? "corroded " :
X! 			       is_flammable(obj) ? "burnt " : "eroded ");
X  		} else if (obj->rknown && obj->oerodeproof)
X  			Strcat(prefix,
X  			       is_rustprone(obj) ? "rustproof " :
X***************
X*** 904,910 ****
X  
X  	/* same singular and plural */
X  	/* note: also swine, trout, grouse */
X! 	if ((len >= 7 && !strcmp(spot-6, "samurai")) ||
X  #ifdef TUTTI_FRUTTI
X  	    (len >= 5 &&
X  	     (!strcmp(spot-4, "manes") || !strcmp(spot-4, "sheep"))) ||
X--- 906,912 ----
X  
X  	/* same singular and plural */
X  	/* note: also swine, trout, grouse */
X! 	if ((len >= 2 && !strcmp(spot-1, "ai")) || /* samurai, Uruk-hai */
X  #ifdef TUTTI_FRUTTI
X  	    (len >= 5 &&
X  	     (!strcmp(spot-4, "manes") || !strcmp(spot-4, "sheep"))) ||
X***************
X*** 971,977 ****
X  	}
X  
X  	/* Japanese words: plurals are the same as singlar */
X! 	if (len == 2 && !strcmp(str, "ya"))
X  	    goto bottom;
X  
X  	/* Default: append an 's' */
X--- 973,980 ----
X  	}
X  
X  	/* Japanese words: plurals are the same as singlar */
X! 	if ((len == 2 && !strcmp(str, "ya")) ||
X! 	    (len > 2 && !strcmp(spot-2, " ya")))
X  	    goto bottom;
X  
X  	/* Default: append an 's' */
X***************
X*** 1535,1540 ****
X--- 1538,1544 ----
X  		p = eos(bp);
X  		if(!BSTRCMP(bp, p-8, "fountain")) {
X  			levl[u.ux][u.uy].typ = FOUNTAIN;
X+ 			level.flags.nfountains++;
X  			if(!strncmpi(bp, "magic ", 6))
X  				levl[u.ux][u.uy].blessedftn = 1;
X  			pline("A %sfountain.",
X***************
X*** 1542,1547 ****
X--- 1546,1560 ----
X  			newsym(u.ux, u.uy);
X  			return(&zeroobj);
X  		}
X+ # ifdef SINKS
X+ 		if(!BSTRCMP(bp, p-4, "sink")) {
X+ 			levl[u.ux][u.uy].typ = SINK;
X+ 			level.flags.nsinks++;
X+ 			pline("A sink.");
X+ 			newsym(u.ux, u.uy);
X+ 			return &zeroobj;
X+ 		}
X+ # endif
X  		if(!BSTRCMP(bp, p-5, "altar")) {
X  		    aligntyp al;
X  
X***************
X*** 1670,1685 ****
X  		    typ = SPE_BLANK_PAPER;
X  		    break;
X  	    }
X! 
X! 	/* venom isn't really an object and can't be wished for; but allow
X! 	 * wizards to wish for it since it's faster than polymorphing and
X! 	 * spitting.
X! 	 */
X! 	if(let == VENOM_CLASS)
X  #ifdef WIZARD
X! 		if (!wizard)
X  #endif
X! 			return((struct obj *)0);
X  
X  	if(typ) {
X  		otmp = mksobj(typ, TRUE, FALSE);
X--- 1683,1695 ----
X  		    typ = SPE_BLANK_PAPER;
X  		    break;
X  	    }
X! 	/* catch any other non-wishable objects */
X! 	if (objects[typ].oc_nowish
X  #ifdef WIZARD
X! 	    && !wizard
X  #endif
X! 	    )
X! 	    return((struct obj *)0);
X  
X  	if(typ) {
X  		otmp = mksobj(typ, TRUE, FALSE);
X***************
X*** 1696,1701 ****
X--- 1706,1712 ----
X  #ifdef WIZARD
X  		wizard ||
X  #endif
X+ 		 (cnt <= 7 && Is_candle(otmp)) ||
X  		 (cnt <= 20 &&
X  		  ((let == WEAPON_CLASS && typ <= SHURIKEN) || (typ == ROCK)))))
X  			otmp->quan = (long) cnt;
X***************
X*** 1858,1863 ****
X--- 1869,1889 ----
X  		otmp = oname(otmp, name, 0);
X  		if (otmp->oartifact) otmp->quan = 1L;
X  	}
X+ 
X+ 	/* more wishing abuse: don't allow wishing for certain artifacts */
X+ 	/* and make them pay; charge them for the wish anyway! */
X+ 	if ((is_quest_artifact(otmp) || 
X+ 	     (otmp->oartifact && rn2(nartifact_exist()) > 1))
X+ # ifdef WIZARD
X+ 	    && !wizard
X+ # endif
X+ 	    ) {
X+ 	    artifact_unexist(otmp);
X+ 	    obfree(otmp, (struct obj *) 0);
X+ 	    otmp = &zeroobj;
X+ 	    pline("For a moment, you feel something in your %s, but it disappears!", makeplural(body_part(HAND)));
X+ 	}
X+ 	
X  	otmp->owt = weight(otmp);
X  	if (very && otmp->otyp == HEAVY_IRON_BALL) otmp->owt += 160;
X  	if (halfeaten && otmp->oclass == FOOD_CLASS) {
X*** /tmp/da08445	Thu Feb 25 10:24:31 1993
X--- src/options.c	Mon Feb 22 11:02:49 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)options.c	3.1	92/11/14	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)options.c	3.1	93/02/19	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 9,15 ****
X  /*
X   *  NOTE:  If you add (or delete) an option, please update the short
X   *  options help (option_help()), the long options help (dat/opthelp),
X!  *  and the current options setting display function (doset()).
X   */
X  
X  #if defined(TOS) && defined(TEXTCOLOR)
X--- 9,16 ----
X  /*
X   *  NOTE:  If you add (or delete) an option, please update the short
X   *  options help (option_help()), the long options help (dat/opthelp),
X!  *  and the current options setting display function (doset()),
X!  *  and also the Guidebooks.
X   */
X  
X  #if defined(TOS) && defined(TEXTCOLOR)
X***************
X*** 20,33 ****
X  extern char inv_order[];	/* from invent.c */
X  
X  static boolean initial, from_file;
X- static boolean NEARDATA set_order;
X  
X  static void FDECL(nmcpy, (char *, const char *, int));
X  static void FDECL(escapes, (const char *, char *));
X  static void FDECL(rejectoption, (const char *));
X  static void FDECL(badoption, (const char *));
X  static char *FDECL(string_for_env_opt, (const char *, char *));
X! static int FDECL(change_inv_order, (char *, int));
X  static void FDECL(oc_to_str, (char *, char *));
X  
X  static struct Bool_Opt
X--- 21,34 ----
X  extern char inv_order[];	/* from invent.c */
X  
X  static boolean initial, from_file;
X  
X  static void FDECL(nmcpy, (char *, const char *, int));
X  static void FDECL(escapes, (const char *, char *));
X  static void FDECL(rejectoption, (const char *));
X  static void FDECL(badoption, (const char *));
X+ static char *FDECL(string_for_opt, (char *));
X  static char *FDECL(string_for_env_opt, (const char *, char *));
X! static int FDECL(change_inv_order, (char *));
X  static void FDECL(oc_to_str, (char *, char *));
X  
X  static struct Bool_Opt
X***************
X*** 72,78 ****
X  	{"legacy",&flags.legacy, TRUE},
X  	{"lit_corridor", &flags.lit_corridor, FALSE},
X  #ifdef MAC_GRAPHICS_ENV
X! 	{"MACgraphics", &flags.MACgraphics, TRUE},
X  #endif
X  #ifdef NEWS
X  	{"news", &flags.news, TRUE},
X--- 73,79 ----
X  	{"legacy",&flags.legacy, TRUE},
X  	{"lit_corridor", &flags.lit_corridor, FALSE},
X  #ifdef MAC_GRAPHICS_ENV
X! 	{"Macgraphics", &flags.MACgraphics, TRUE},
X  #endif
X  #ifdef NEWS
X  	{"news", &flags.news, TRUE},
X***************
X*** 79,84 ****
X--- 80,88 ----
X  #endif
X  	{"null", &flags.null, TRUE},
X  	{"number_pad", &flags.num_pad, FALSE},
X+ #ifdef MAC
X+ 	{"page_wait", &flags.page_wait, TRUE},
X+ #endif
X  	{"pickup", &flags.pickup, TRUE},
X  #ifdef MAC
X  	{"popup_dialog", &flags.popup_dialog, FALSE},
X***************
X*** 87,93 ****
X  	{"rawio", &flags.rawio, FALSE},
X  #endif
X  	{"rest_on_space", &flags.rest_on_space, FALSE},
X! 	{"safepet", &flags.safe_dog, TRUE},
X  #ifdef EXP_ON_BOTL
X  	{"showexp", &flags.showexp, FALSE},
X  #endif
X--- 91,97 ----
X  	{"rawio", &flags.rawio, FALSE},
X  #endif
X  	{"rest_on_space", &flags.rest_on_space, FALSE},
X! 	{"safe_pet", &flags.safe_dog, TRUE},
X  #ifdef EXP_ON_BOTL
X  	{"showexp", &flags.showexp, FALSE},
X  #endif
X***************
X*** 129,135 ****
X  	    	monsyms[i] = (uchar) def_monsyms[i];
X  
X  	switch_graphics(ASCII_GRAPHICS);	/* set default characters */
X! #ifdef UNIX
X  	/*
X  	 * Set defaults for some options depending on what we can
X  	 * detect about the environment's capabilities.
X--- 133,139 ----
X  	    	monsyms[i] = (uchar) def_monsyms[i];
X  
X  	switch_graphics(ASCII_GRAPHICS);	/* set default characters */
X! #if defined(UNIX) && defined(TTY_GRAPHICS)
X  	/*
X  	 * Set defaults for some options depending on what we can
X  	 * detect about the environment's capabilities.
X***************
X*** 144,156 ****
X  		flags.use_color = TRUE;
X  # endif
X  	}
X! #endif /* UNIX */
X  #if defined(UNIX) || defined(VMS)
X  	/* detect whether a "vt" terminal can handle alternate charsets */
X  	if (!strncmpi(getenv("TERM"), "vt", 2) && (AS && AE) &&
X  	    !strcmp(AS, "\016") && !strcmp(AE, "\017")) {
X  		switch_graphics(DEC_GRAPHICS);
X  	}
X  #endif /* UNIX || VMS */
X  
X  #ifdef MAC_GRAPHICS_ENV
X--- 148,162 ----
X  		flags.use_color = TRUE;
X  # endif
X  	}
X! #endif /* UNIX && TTY_GRAPHICS */
X  #if defined(UNIX) || defined(VMS)
X+ # ifdef TTY_GRAPHICS
X  	/* detect whether a "vt" terminal can handle alternate charsets */
X  	if (!strncmpi(getenv("TERM"), "vt", 2) && (AS && AE) &&
X  	    !strcmp(AS, "\016") && !strcmp(AE, "\017")) {
X  		switch_graphics(DEC_GRAPHICS);
X  	}
X+ # endif
X  #endif /* UNIX || VMS */
X  
X  #ifdef MAC_GRAPHICS_ENV
X***************
X*** 186,192 ****
X  	/* result in the player's preferred fruit [better than "\033"].	*/
X  	obj_descr[SLIME_MOLD].oc_name = "fruit";
X  #endif
X! 	if(flags.female)  {	/* should have been set in NETHACKOPTIONS */
X  		roles[2] = "Cavewoman";
X  		roles[6] = "Priestess";
X  	}
X--- 192,198 ----
X  	/* result in the player's preferred fruit [better than "\033"].	*/
X  	obj_descr[SLIME_MOLD].oc_name = "fruit";
X  #endif
X! 	if (flags.female)  {	/* should have been set in NETHACKOPTIONS */
X  		roles[2] = "Cavewoman";
X  		roles[6] = "Priestess";
X  	}
X***************
X*** 292,302 ****
X  badoption(opts)
X  const char *opts;
X  {
X! 	if(!initial) {
X! 	    if(!strncmp(opts, "h", 1) || !strncmp(opts, "?", 1))
X  		option_help();
X  	    else
X! 		pline("Unknown option: %s.  Enter \"?g\" for help.", opts);
X  	    return;
X  	}
X  # ifdef AMIGA
X--- 298,308 ----
X  badoption(opts)
X  const char *opts;
X  {
X! 	if (!initial) {
X! 	    if (!strncmp(opts, "h", 1) || !strncmp(opts, "?", 1))
X  		option_help();
X  	    else
X! 		pline("Bad syntax: %s.  Enter \"?g\" for help.", opts);
X  	    return;
X  	}
X  # ifdef AMIGA
X***************
X*** 313,329 ****
X  }
X  
X  static char *
X! string_for_env_opt(optname, opts)
X! const char *optname;
X  char *opts;
X  {
X  	register char *colon;
X  
X! 	if(!initial) {
X! 		rejectoption(optname);
X! 		return NULL;
X! 	}
X! 	colon = index(opts,':');
X  	if(!colon) {
X  		badoption(opts);
X  		return NULL;
X--- 319,330 ----
X  }
X  
X  static char *
X! string_for_opt(opts)
X  char *opts;
X  {
X  	register char *colon;
X  
X! 	colon = index(opts, ':');
X  	if(!colon) {
X  		badoption(opts);
X  		return NULL;
X***************
X*** 331,351 ****
X  	return ++colon;
X  }
X  
X  /*
X   * Change the inventory order, using the given string as the new order.
X   * Missing characters in the new order are filled in at the end from
X   * the current inv_order.
X   *
X!  * This routine always returns 1 unless the parameter 'fail' is true
X!  * and there is a duplicate or bad char in the string.
X   */
X  static int
X! change_inv_order(op, fail)
X!     char *op;
X!     int  fail;	/* If TRUE, return 0 if any duplicates or bad chars. */
X  {
X      int oc_sym, num;
X!     char *sp, *tmp, buf[BUFSZ];
X  
X      for (sp = op; *sp; sp++) {
X  	oc_sym = def_char_to_objclass(*sp);
X--- 332,363 ----
X  	return ++colon;
X  }
X  
X+ static char *
X+ string_for_env_opt(optname, opts)
X+ const char *optname;
X+ char *opts;
X+ {
X+ 	if(!initial) {
X+ 		rejectoption(optname);
X+ 		return NULL;
X+ 	}
X+ 	return string_for_opt(opts);
X+ }
X+ 
X  /*
X   * Change the inventory order, using the given string as the new order.
X   * Missing characters in the new order are filled in at the end from
X   * the current inv_order.
X   *
X!  * This routine returns 1 unless there is a duplicate or bad char in
X!  * the string.
X   */
X  static int
X! change_inv_order(op)
X! char *op;
X  {
X      int oc_sym, num;
X!     char *sp, buf[BUFSZ];
X  
X      for (sp = op; *sp; sp++) {
X  	oc_sym = def_char_to_objclass(*sp);
X***************
X*** 352,365 ****
X  
X  	/* Remove bad or duplicate entries. */
X  	if (oc_sym == MAXOCLASSES ||
X! 		(!index(inv_order, oc_sym)) || (index(sp+1, *sp))) {
X  
X! 	    if (fail) return 0;
X! 	    for(tmp = sp; *tmp; tmp++)
X! 		tmp[0] = tmp[1];
X! 	    sp--;
X! 	} else
X! 	    *sp = (char) oc_sym;
X      } 
X      Strcpy(buf, op);
X      for (sp = inv_order, num = strlen(buf); *sp; sp++)
X--- 364,374 ----
X  
X  	/* Remove bad or duplicate entries. */
X  	if (oc_sym == MAXOCLASSES ||
X! 		(!index(inv_order, oc_sym)) || (index(sp+1, *sp)))
X  
X! 	    return 0;
X! 
X! 	*sp = (char) oc_sym;
X      } 
X      Strcpy(buf, op);
X      for (sp = inv_order, num = strlen(buf); *sp; sp++)
X***************
X*** 393,489 ****
X  	op = eos(opts);
X  	while (--op >= opts && isspace(*op)) *op = '\0';
X  
X! 	if(!*opts) return;
X  	negated = FALSE;
X! 	while((*opts == '!') || !strncmpi(opts, "no", 2)) {
X! 		if(*opts == '!') opts++; else opts += 2;
X  		negated = !negated;
X  	}
X  	
X! #if defined(MICRO) && !defined(AMIGA)
X! 	/* included for compatibility with old NetHack.cnf files */
X! 	if (!strncmp(opts, "IBM_", 4)) {
X! 		flags.BIOS = !negated;
X! 		return;
X! 	}
X  
X! 	/* put here cause it has to come from the config file */
X! 	if (!strncmpi(opts, "raw", 3)) {
X! 		if (initial)
X! 			flags.rawio = !negated;
X! 		else
X! 			rejectoption("rawio");
X! 		return;
X! 	}
X! #endif /* MICRO */
X! 
X! #if defined(TOS) && defined(TEXTCOLOR)
X! 	if (!strncmpi(opts, "col", 3)) {
X! 		flags.use_color = !negated;
X! 		if (flags.BIOS && !initial) {
X! 			if (colors_changed)
X! 				restore_colors();
X! 			else
X! 				set_colors();
X! 		}
X! 	}
X! #endif
X! 	/* other special-case boolean options */
X! #ifdef TERMLIB
X! 	if (!strncmpi(opts, "DEC", 3)) {
X! #ifdef REINCARNATION
X! 		if (!initial && Is_rogue_level(&u.uz))
X! 			assign_rogue_graphics(FALSE);
X! #endif
X! 		flags.DECgraphics = !negated;
X! 		need_redraw = TRUE;
X! 		switch_graphics(flags.DECgraphics ?
X! 				DEC_GRAPHICS : ASCII_GRAPHICS);
X! #ifdef REINCARNATION
X! 		if (!initial && Is_rogue_level(&u.uz))
X! 			assign_rogue_graphics(TRUE);
X! #endif
X! 		return;
X! 	}
X! #endif /* TERMLIB */
X! #ifdef ASCIIGRAPH
X! 	if (!strncmpi(opts, "IBMg", 4)) {
X! #ifdef REINCARNATION
X! 		if (!initial && Is_rogue_level(&u.uz))
X! 			assign_rogue_graphics(FALSE);
X! #endif
X! 		flags.IBMgraphics = !negated;
X! 		need_redraw = TRUE;
X! 		switch_graphics(flags.IBMgraphics ?
X! 				IBM_GRAPHICS : ASCII_GRAPHICS);
X! #ifdef REINCARNATION
X! 		if (!initial && Is_rogue_level(&u.uz))
X! 			assign_rogue_graphics(TRUE);
X! #endif
X! 		return;
X! 	}
X! #endif /* ASCIIGRAPH */
X! #ifdef MAC_GRAPHICS_ENV
X! 	if (!strncmpi(opts, "MACg", 4)) {
X! #ifdef REINCARNATION
X! 		if (!initial && Is_rogue_level(&u.uz))
X! 			assign_rogue_graphics(FALSE);
X! #endif
X! 		flags.MACgraphics = !negated;
X! 		need_redraw = TRUE;
X! 		switch_graphics(flags.MACgraphics ?
X! 				MAC_GRAPHICS : ASCII_GRAPHICS);
X! #ifdef REINCARNATION
X! 		if (!initial && Is_rogue_level(&u.uz))
X! 			assign_rogue_graphics(TRUE);
X! #endif
X! 		return;
X! 	}
X! #endif /* MAC_GRAPHICS_ENV */
X! 
X! 	/* common boolean options */
X! 
X! 	if (!strncmpi(opts, "fem", 3)) {
X  		if(!initial && flags.female == negated)
X  			pline("That is not anatomically possible.");
X  		else
X--- 402,417 ----
X  	op = eos(opts);
X  	while (--op >= opts && isspace(*op)) *op = '\0';
X  
X! 	if (!*opts) return;
X  	negated = FALSE;
X! 	while ((*opts == '!') || !strncmpi(opts, "no", 2)) {
X! 		if (*opts == '!') opts++; else opts += 2;
X  		negated = !negated;
X  	}
X  	
X! 	/* special boolean options */
X  
X! 	if (!strncmpi(opts, "female", 3)) {
X  		if(!initial && flags.female == negated)
X  			pline("That is not anatomically possible.");
X  		else
X***************
X*** 491,502 ****
X  		return;
X  	}
X  
X- 	if (!strncmpi(opts, "fix", 3)) {
X- 		flags.invlet_constant = !negated;
X- 		if (!initial && flags.invlet_constant) reassign();
X- 		return;
X- 	}
X- 
X  	if (!strncmpi(opts, "male", 4)) {
X  		if(!initial && flags.female != negated)
X  			pline("That is not anatomically possible.");
X--- 419,424 ----
X***************
X*** 505,544 ****
X  		return;
X  	}
X  
X! 	if (!strncmpi(opts, "num", 3)) {
X! 		flags.num_pad = !negated;
X! 		if (!initial) number_pad(flags.num_pad ? 1 : 0);
X  		return;
X  	}
X! #ifdef EXP_ON_BOTL
X! 	if (!strncmpi(opts, "showexp", 7)) {
X! 		flags.showexp = !negated;
X! 		flags.botl = 1;
X! 		return;
X! 	}
X! #endif
X! #ifdef SCORE_ON_BOTL
X! 	if (!strncmpi(opts, "showscore", 9)) {
X! 		flags.showscore = !negated;
X! 		flags.botl = 1;
X! 		return;
X! 	}
X! #endif
X! 	if (!strncmpi(opts, "time", 4)) {
X! 		flags.time = !negated;
X! 		flags.botl = 1;
X! 		return;
X! 	}
X  
X- 	if (!strncmpi(opts, "legacy", 6)) {
X- 	        if(!initial) rejectoption("legacy");
X- 		else flags.legacy = !negated;
X- 		return;
X- 	}
X- 
X  	/* compound options */
X  
X! 	if (!strncmpi(opts, "pet", 3)) {
X  		if ((op = string_for_env_opt("pettype", opts)) != 0)
X  		    switch (*op) {
X  			case 'd':	/* dog */
X--- 427,443 ----
X  		return;
X  	}
X  
X! #if defined(MICRO) && !defined(AMIGA)
X! 	/* included for compatibility with old NetHack.cnf files */
X! 	if (!strncmp(opts, "IBM_", 4)) {
X! 		flags.BIOS = !negated;
X  		return;
X  	}
X! #endif /* MICRO */
X  
X  	/* compound options */
X  
X! 	if (!strncmpi(opts, "pettype", 3)) {
X  		if ((op = string_for_env_opt("pettype", opts)) != 0)
X  		    switch (*op) {
X  			case 'd':	/* dog */
X***************
X*** 552,576 ****
X  			    preferred_pet = 'c';
X  			    break;
X  			default:
X! 			    pline("Unrecognized pettype '%s'", op);
X  			    break;
X  		    }
X  		return;
X  	}
X  
X! 	if (!strncmpi(opts, "cat", 3)) {
X  		if ((op = string_for_env_opt("catname", opts)) != 0)
X  			nmcpy(catname, op, 62);
X  		return;
X  	}
X  
X! 	if (!strncmpi(opts, "dog", 3)) {
X  		if ((op = string_for_env_opt("dogname", opts)) != 0)
X  			nmcpy(dogname, op, 62);
X  		return;
X  	}
X  
X! 	if (!strncmpi(opts, "msg", 3)) {
X  		if ((op = string_for_env_opt("msghistory", opts)) != 0) {
X  			flags.msg_history = atoi(op);
X  		}
X--- 451,475 ----
X  			    preferred_pet = 'c';
X  			    break;
X  			default:
X! 			    pline("Unrecognized pet type '%s'", op);
X  			    break;
X  		    }
X  		return;
X  	}
X  
X! 	if (!strncmpi(opts, "catname", 3)) {
X  		if ((op = string_for_env_opt("catname", opts)) != 0)
X  			nmcpy(catname, op, 62);
X  		return;
X  	}
X  
X! 	if (!strncmpi(opts, "dogname", 3)) {
X  		if ((op = string_for_env_opt("dogname", opts)) != 0)
X  			nmcpy(dogname, op, 62);
X  		return;
X  	}
X  
X! 	if (!strncmpi(opts, "msghistory", 3)) {
X  		if ((op = string_for_env_opt("msghistory", opts)) != 0) {
X  			flags.msg_history = atoi(op);
X  		}
X***************
X*** 577,598 ****
X  		return;
X  	}
X  #ifdef TUTTI_FRUTTI
X! 	if (!strncmpi(opts, "fr", 2)) {
X! 		op = index(opts, ':');
X! 		if (!op) {
X! 			badoption(opts);
X! 			return;
X! 		}
X! 		op++;
X  		if (!initial) {
X  		    struct fruit *f;
X- 		    int numfruits = 0;
X  
X  		    for(f=ffruit; f; f=f->nextf) {
X  			if (!strcmp(op, f->fname)) goto goodfruit;
X! 			numfruits++;
X  		    }
X! 		    if (numfruits >= 100) {
X  			pline("Doing that so many times isn't very fruitful.");
X  			return;
X  		    }
X--- 476,492 ----
X  		return;
X  	}
X  #ifdef TUTTI_FRUTTI
X! 	if (!strncmpi(opts, "fruit", 2)) {
X! 		if (!(op = string_for_opt(opts))) return;
X  		if (!initial) {
X  		    struct fruit *f;
X  
X+ 		    num = 0;
X  		    for(f=ffruit; f; f=f->nextf) {
X  			if (!strcmp(op, f->fname)) goto goodfruit;
X! 			num++;
X  		    }
X! 		    if (num >= 100) {
X  			pline("Doing that so many times isn't very fruitful.");
X  			return;
X  		    }
X***************
X*** 612,637 ****
X  	}
X  #endif
X  	/* graphics:string */
X! 	if (!strncmpi(opts, "gr", 2)) {
X  		uchar translate[MAXPCHARS+1];
X! 		int lth;
X  
X  		if (!(opts = string_for_env_opt("graphics", opts)))
X  			return;
X  		escapes(opts, opts);
X  
X! 		lth = strlen(opts);
X! 		if (lth > MAXPCHARS) lth = MAXPCHARS;
X  		/* match the form obtained from PC configuration files */
X! 		for (i = 0; i < lth; i++)
X  			translate[i] = (uchar) opts[i];
X! 		assign_graphics(translate, lth);
X  		return;
X  	}
X  
X  	/* objects:string */
X  	if (!strncmpi(opts, "objects", 7)) {
X! 		int k, length;
X  
X  		if (!(opts = string_for_env_opt("objects", opts)))
X  			return;
X--- 506,531 ----
X  	}
X  #endif
X  	/* graphics:string */
X! 	if (!strncmpi(opts, "graphics", 2)) {
X  		uchar translate[MAXPCHARS+1];
X! 		int length;
X  
X  		if (!(opts = string_for_env_opt("graphics", opts)))
X  			return;
X  		escapes(opts, opts);
X  
X! 		length = strlen(opts);
X! 		if (length > MAXPCHARS) length = MAXPCHARS;
X  		/* match the form obtained from PC configuration files */
X! 		for (i = 0; i < length; i++)
X  			translate[i] = (uchar) opts[i];
X! 		assign_graphics(translate, length);
X  		return;
X  	}
X  
X  	/* objects:string */
X  	if (!strncmpi(opts, "objects", 7)) {
X! 		int length;
X  
X  		if (!(opts = string_for_env_opt("objects", opts)))
X  			return;
X***************
X*** 650,663 ****
X  		if (length >= MAXOCLASSES)
X  		    length = MAXOCLASSES-1;	/* don't count RANDOM_OBJECT */
X  
X! 		for (k = 0; k < length; k++)
X! 		    oc_syms[k+1] = (uchar) opts[k];
X  		return;
X  	}
X  
X  	/* monsters:string */
X  	if (!strncmpi(opts, "monsters", 8)) {
X! 		int k, length;
X  
X  		if (!(opts = string_for_env_opt("monsters", opts)))
X  			return;
X--- 544,557 ----
X  		if (length >= MAXOCLASSES)
X  		    length = MAXOCLASSES-1;	/* don't count RANDOM_OBJECT */
X  
X! 		for (i = 0; i < length; i++)
X! 		    oc_syms[i+1] = (uchar) opts[i];
X  		return;
X  	}
X  
X  	/* monsters:string */
X  	if (!strncmpi(opts, "monsters", 8)) {
X! 		int length;
X  
X  		if (!(opts = string_for_env_opt("monsters", opts)))
X  			return;
X***************
X*** 668,675 ****
X  		if (length >= MAXMCLASSES)
X  		    length = MAXMCLASSES-1;	/* mon class 0 unused */
X  
X! 		for (k = 0; k < length; k++)
X! 		    monsyms[k+1] = (uchar) opts[k];
X  		return;
X  	}
X  
X--- 562,569 ----
X  		if (length >= MAXMCLASSES)
X  		    length = MAXMCLASSES-1;	/* mon class 0 unused */
X  
X! 		for (i = 0; i < length; i++)
X! 		    monsyms[i+1] = (uchar) opts[i];
X  		return;
X  	}
X  
X***************
X*** 681,697 ****
X  	}
X  
X  	/* the order to list the pack */
X! 	if (!strncmpi(opts, "pack", 4)) {
X! 		op = index(opts,':');
X! 		if(!op) {
X! 			badoption(opts);
X! 			return;
X! 		}
X! 		op++;			/* skip : */
X  
X! 		if (!change_inv_order(op, 1))
X! 		    	set_order = TRUE;
X! 		else
X  		    	badoption(opts);
X  		return;
X  	}
X--- 575,584 ----
X  	}
X  
X  	/* the order to list the pack */
X! 	if (!strncmpi(opts, "packorder", 4)) {
X! 		if (!(op = string_for_opt(opts))) return;
X  
X! 		if (!change_inv_order(op))
X  		    	badoption(opts);
X  		return;
X  	}
X***************
X*** 698,710 ****
X  
X  	/* scores:5t[op] 5a[round] o[wn] */
X  	if (!strncmpi(opts, "scores", 6)) {
X! 		op = index(opts,':');
X! 		if(!op) {
X! 			badoption(opts);
X! 			return;
X! 		}
X! 		op++;
X! 		while(*op) {
X  			num = 1;
X  			if(digit(*op)) {
X  				num = atoi(op);
X--- 585,593 ----
X  
X  	/* scores:5t[op] 5a[round] o[wn] */
X  	if (!strncmpi(opts, "scores", 6)) {
X! 		if (!(op = string_for_opt(opts))) return;
X! 
X! 		while (*op) {
X  			num = 1;
X  			if(digit(*op)) {
X  				num = atoi(op);
X***************
X*** 737,743 ****
X  		}
X  		return;
X  	}
X! 	if (!strncmpi(opts, "win", 3)) {
X  	    if ((op = string_for_env_opt("windowtype", opts)) != 0) {
X  		char buf[16];
X  		nmcpy(buf, op, 15);
X--- 620,627 ----
X  		}
X  		return;
X  	}
X! 
X! 	if (!strncmpi(opts, "windowtype", 3)) {
X  	    if ((op = string_for_env_opt("windowtype", opts)) != 0) {
X  		char buf[16];
X  		nmcpy(buf, op, 15);
X***************
X*** 750,765 ****
X  	 * options list
X  	 */
X  	for (i = 0; boolopt[i].name; i++) {
X! 		if (boolopt[i].addr && !strncmpi(boolopt[i].name, opts, 3)) {
X  			*(boolopt[i].addr) = !negated;
X- #ifdef TEXTCOLOR
X- 			if((boolopt[i].addr) == &flags.use_color)
X- 			    need_redraw = TRUE;
X  
X! 			if((boolopt[i].addr) == &flags.hilite_pet)
X  			    need_redraw = TRUE;
X  #endif
X! 			if (!initial && boolopt[i].addr==&flags.lit_corridor) {
X  			    /*
X  			     * All corridor squares seen via night vision or
X  			     * candles & lamps change.  Update them by calling
X--- 634,714 ----
X  	 * options list
X  	 */
X  	for (i = 0; boolopt[i].name; i++) {
X! 		if (boolopt[i].addr && strlen(opts) >= 3 &&
X! 		    !strncmpi(boolopt[i].name, opts, strlen(opts))) {
X! 		        /* options that must come from config file */
X! 			if (!initial &&
X! 			    ((boolopt[i].addr) == &flags.legacy
X! #if defined(MICRO) && !defined(AMIGA)
X! 			  || (boolopt[i].addr) == &flags.rawio
X! #endif
X! 			     )) {
X! 			    rejectoption(boolopt[i].name);
X! 			    return;
X! 			}
X! 
X  			*(boolopt[i].addr) = !negated;
X  
X! #if defined(TERMLIB) || defined(ASCIIGRAPH) || defined(MAC_GRAPHICS_ENV)
X! 			if (FALSE
X! # ifdef TERMLIB
X! 				 || (boolopt[i].addr) == &flags.DECgraphics
X! # endif
X! # ifdef ASCIIGRAPH
X! 				 || (boolopt[i].addr) == &flags.IBMgraphics
X! # endif
X! # ifdef MAC_GRAPHICS_ENV
X! 				 || (boolopt[i].addr) == &flags.MACgraphics
X! # endif
X! 				) {
X! # ifdef REINCARNATION
X! 			    if (!initial && Is_rogue_level(&u.uz))
X! 				assign_rogue_graphics(FALSE);
X! # endif
X  			    need_redraw = TRUE;
X+ # ifdef TERMLIB
X+ 			    if ((boolopt[i].addr) == &flags.DECgraphics)
X+ 				switch_graphics(flags.DECgraphics ?
X+ 						DEC_GRAPHICS : ASCII_GRAPHICS);
X+ # endif
X+ # ifdef ASCIIGRAPH
X+ 			    if ((boolopt[i].addr) == &flags.IBMgraphics)
X+ 				switch_graphics(flags.IBMgraphics ?
X+ 						IBM_GRAPHICS : ASCII_GRAPHICS);
X+ # endif
X+ # ifdef MAC_GRAPHICS_ENV
X+ 			    if ((boolopt[i].addr) == &flags.MACgraphics)
X+ 				switch_graphics(flags.MACgraphics ?
X+ 						MAC_GRAPHICS : ASCII_GRAPHICS);
X+ # endif
X+ # ifdef REINCARNATION
X+ 			    if (!initial && Is_rogue_level(&u.uz))
X+ 				assign_rogue_graphics(TRUE);
X+ # endif
X+ 			}
X+ #endif /* TERMLIB || ASCIIGRAPH || MAC_GRAPHICS_ENV */
X+ 
X+ 			/* only do processing below if setting with doset() */
X+ 			if (initial) return;
X+ 
X+ 			if ((boolopt[i].addr) == &flags.time
X+ #ifdef EXP_ON_BOTL
X+ 			 || (boolopt[i].addr) == &flags.showexp
X  #endif
X! #ifdef SCORE_ON_BOTL
X! 			 || (boolopt[i].addr) == &flags.showscore
X! #endif
X! 			    )
X! 			    flags.botl = TRUE;
X! 
X! 			else if ((boolopt[i].addr) == &flags.invlet_constant) {
X! 			    if (flags.invlet_constant) reassign();
X! 			}
X! 
X! 			else if ((boolopt[i].addr) == &flags.num_pad)
X! 			    number_pad(flags.num_pad ? 1 : 0);
X! 
X! 			else if ((boolopt[i].addr) == &flags.lit_corridor) {
X  			    /*
X  			     * All corridor squares seen via night vision or
X  			     * candles & lamps change.  Update them by calling
X***************
X*** 770,775 ****
X--- 719,741 ----
X  			    vision_recalc(2);		/* shut down vision */
X  			    vision_full_recalc = 1;	/* delayed recalc */
X  			}
X+ 
X+ #ifdef TEXTCOLOR
X+ 			else if ((boolopt[i].addr) == &flags.use_color
X+ 			      || (boolopt[i].addr) == &flags.hilite_pet) {
X+ 			    need_redraw = TRUE;
X+ # ifdef TOS
X+ 			    if ((boolopt[i].addr) == &flags.use_color
X+ 				&& flags.BIOS) {
X+ 				if (colors_changed)
X+ 				    restore_colors();
X+ 				else
X+ 				    set_colors();
X+ 			    }
X+ # endif
X+ 			}
X+ #endif
X+ 
X  			return;
X  		}
X  	}
X***************
X*** 869,875 ****
X  	case 's':
X  	    clear_nhwindow(WIN_MESSAGE);
X  	    getlin("What options do you want to set?", buf);
X- 	    clear_nhwindow(WIN_MESSAGE);
X  	    if(buf[0] == '\033') return 0;
X  	    need_redraw = FALSE;
X  	    parseoptions(buf, FALSE, FALSE);
X--- 835,840 ----
X*** /tmp/da08454	Thu Feb 25 10:24:34 1993
X--- src/pager.c	Mon Feb  8 14:31:40 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)pager.c	3.1	92/09/01		  */
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)pager.c	3.1	93/02/04	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 93,103 ****
X  		    (hp ? "high priest" : l_monnam(mtmp)),
X  		    u.ustuck == mtmp ?
X  #ifdef POLYSELF
X! 			(u.mtimedone ? ", being held" :
X  #endif
X! 			", holding you"
X  #ifdef POLYSELF
X! 			)
X  #endif
X  			: "");
X  	}
X--- 93,103 ----
X  		    (hp ? "high priest" : l_monnam(mtmp)),
X  		    u.ustuck == mtmp ?
X  #ifdef POLYSELF
X! 			((u.mtimedone && sticks(uasmon)) ? ", being held" :
X  #endif
X! 			 ", holding you"
X  #ifdef POLYSELF
X! 			 )
X  #endif
X  			: "");
X  	}
X***************
X*** 313,319 ****
X  	cc.y = u.uy;
X      } else {
X  	getlin("Specify what? (type the word)", out_str);
X! 	if (out_str[0] == '\033')
X  	    return 0;
X  
X  	if (out_str[1]) {	/* user typed in a complete string */
X--- 313,319 ----
X  	cc.y = u.uy;
X      } else {
X  	getlin("Specify what? (type the word)", out_str);
X! 	if (out_str[0] == '\0' || out_str[0] == '\033')
X  	    return 0;
X  
X  	if (out_str[1]) {	/* user typed in a complete string */
X*** /tmp/da08462	Thu Feb 25 10:24:36 1993
X--- src/pickup.c	Wed Feb 17 09:51:58 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)pickup.c	3.1	93/01/04	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)pickup.c	3.1	93/02/16	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 138,147 ****
X  		Sprintf(qbuf,"What kinds of thing do you want to %s? [%s]",
X  			action, ilets);
X  		getlin(qbuf,inbuf);
X! 		if (*inbuf == '\033') {
X! 			clear_nhwindow(WIN_MESSAGE);
X! 			return FALSE;
X! 		}
X  		for (p = inbuf; (sym = *p++); ) {
X  		    /* new A function (selective all) added by GAN 01/09/87 */
X  		    if (sym == ' ') continue;
X--- 138,145 ----
X  		Sprintf(qbuf,"What kinds of thing do you want to %s? [%s]",
X  			action, ilets);
X  		getlin(qbuf,inbuf);
X! 		if (*inbuf == '\033') return FALSE;
X! 
X  		for (p = inbuf; (sym = *p++); ) {
X  		    /* new A function (selective all) added by GAN 01/09/87 */
X  		    if (sym == ' ') continue;
X***************
X*** 236,248 ****
X  		}
X  	}
X  
X- #ifdef POLYSELF
X- 	if (nolimbs(uasmon)) {
X- 		You("cannot pick things up without limbs.");
X- 		return;
X- 	}
X- #endif
X- 
X  	/* added by GAN 10/24/86 to allow selective picking up */
X  	if (!all) {
X  		if (!query_classes(olets, &selective, &all_of_a_type,
X--- 234,239 ----
X***************
X*** 261,267 ****
X  
X  		    if (!all_of_a_type) {
X  			char qbuf[QBUFSZ];
X! 			Sprintf(qbuf,"Pick up %s?", doname(obj));
X  			switch ((obj->quan < 2L) ? ynaq(qbuf) : ynNaq(qbuf)) {
X  			case 'q': return;
X  			case 'n': continue;
X--- 252,258 ----
X  
X  		    if (!all_of_a_type) {
X  			char qbuf[QBUFSZ];
X! 			Sprintf(qbuf, "Pick up %s?", doname(obj));
X  			switch ((obj->quan < 2L) ? ynaq(qbuf) : ynNaq(qbuf)) {
X  			case 'q': return;
X  			case 'n': continue;
X***************
X*** 276,282 ****
X  			case '#':	/* count was entered */
X  			    if (!yn_number) continue; /* 0 count => No */
X  			    else count = yn_number;
X! 			    /* fall thru :-} */
X  			default:	/* 'y' */
X  			    break;
X  			}
X--- 267,273 ----
X  			case '#':	/* count was entered */
X  			    if (!yn_number) continue; /* 0 count => No */
X  			    else count = yn_number;
X! 			    /* fall thru */
X  			default:	/* 'y' */
X  			    break;
X  			}
X***************
X*** 384,390 ****
X  		exercise(A_WIS, FALSE);
X  		return FALSE;
X  	    }
X- 
X  	} else  if (obj->otyp == SCR_SCARE_MONSTER) {
X  	    if (obj->blessed) obj->blessed = 0;
X  	    else if (!obj->spe && !obj->cursed) obj->spe = 1;
X--- 375,380 ----
X***************
X*** 454,464 ****
X  lift_some:
X  	if (inv_cnt() >= 52) {
X  	    if (objx) unsplitobj(obj, objx, 0L);
X- 	    Your("knapsack cannot accommodate any more items.");
X  	    if (obj->otyp == SCR_SCARE_MONSTER) obj->spe = 0;
X  	    return TRUE;
X  	}
X  
X  	pickquan = obj->quan;	/* save number picked up */
X  	obj = pick_obj(obj);
X  
X--- 444,472 ----
X  lift_some:
X  	if (inv_cnt() >= 52) {
X  	    if (objx) unsplitobj(obj, objx, 0L);
X  	    if (obj->otyp == SCR_SCARE_MONSTER) obj->spe = 0;
X+ 	    Your("knapsack cannot accommodate any more items.");
X  	    return TRUE;
X  	}
X  
X+ 	if (obj->otyp != LOADSTONE &&
X+ 	    (wt*2 / weight_cap()) + 1 > SLT_ENCUMBER) {
X+ 	    /* as in near_capacity() */
X+ 		char qbuf[QBUFSZ];
X+ 		char ch;
X+ 
X+ 		Sprintf(qbuf, "%s %s.  Continue?", nearloadmsg, doname(obj));
X+ 		switch (ch = ynq(qbuf)) {
X+ 			case 'n':
X+ 			case 'q':
X+ 				if (objx) unsplitobj(obj, objx, 0L);
X+ 				if (obj->otyp == SCR_SCARE_MONSTER)
X+ 					obj->spe = 0;
X+ 				return (ch == 'q');
X+ 			default:  break;	/* 'y' */
X+ 		}
X+ 	}
X+ 
X  	pickquan = obj->quan;	/* save number picked up */
X  	obj = pick_obj(obj);
X  
X***************
X*** 465,473 ****
X  	if (!Blind) obj->dknown = 1;
X  	if (uwep && uwep == obj) mrg_to_wielded = TRUE;
X  	nearload = near_capacity();
X! 	prinv(nearload > SLT_ENCUMBER ? nearloadmsg :
X! 	      nearload > UNENCUMBERED ? moderateloadmsg : NULL,
X! 	      obj, pickquan);
X  	mrg_to_wielded = FALSE;
X  	return FALSE;
X  }
X--- 473,480 ----
X  	if (!Blind) obj->dknown = 1;
X  	if (uwep && uwep == obj) mrg_to_wielded = TRUE;
X  	nearload = near_capacity();
X! 	prinv(nearload > UNENCUMBERED && nearload < MOD_ENCUMBER ?
X! 	      moderateloadmsg : NULL, obj, pickquan);
X  	mrg_to_wielded = FALSE;
X  	return FALSE;
X  }
X***************
X*** 612,618 ****
X  
X  /* A variable set in use_container(), to be used by the callback routines */
X  /* chk_bg(), in_container(), and out_container() from askchain().	  */
X! static struct obj NEARDATA *current_container;
X  #define Icebox (current_container->otyp == ICE_BOX)
X  
X  STATIC_PTR int
X--- 619,625 ----
X  
X  /* A variable set in use_container(), to be used by the callback routines */
X  /* chk_bg(), in_container(), and out_container() from askchain().	  */
X! static NEARDATA struct obj *current_container;
X  #define Icebox (current_container->otyp == ICE_BOX)
X  
X  STATIC_PTR int
X***************
X*** 806,811 ****
X--- 813,820 ----
X  	if(!obj->unpaid && !carried(current_container) &&
X  	     costly_spot(current_container->ox, current_container->oy)) {
X  
X+ 		obj->ox = current_container->ox;
X+ 		obj->oy = current_container->oy;
X  		addtobill(obj, FALSE, FALSE, FALSE);
X  	}
X  
X***************
X*** 826,832 ****
X  }
X  
X  /* for getobj: allow counts, allow all types, expect food */
X! static const char NEARDATA frozen_food[] =
X  	{ ALLOW_COUNT, ALL_CLASSES, FOOD_CLASS, 0 };
X  
X  int
X--- 835,841 ----
X  }
X  
X  /* for getobj: allow counts, allow all types, expect food */
X! static NEARDATA const char frozen_food[] =
X  	{ ALLOW_COUNT, ALL_CLASSES, FOOD_CLASS, 0 };
X  
X  int
X*** /tmp/da08478	Thu Feb 25 10:24:41 1993
X--- src/polyself.c	Tue Feb 23 20:56:32 1993
X***************
X*** 244,250 ****
X  		if(flags.female) dochange = TRUE;
X  	} else if (is_female(&mons[mntmp])) {
X  		if(!flags.female) dochange = TRUE;
X! 	} else if (!is_neuter(&mons[mntmp])) {
X  		if(!rn2(10)) dochange = TRUE;
X  	}
X  	if (dochange) {
X--- 244,250 ----
X  		if(flags.female) dochange = TRUE;
X  	} else if (is_female(&mons[mntmp])) {
X  		if(!flags.female) dochange = TRUE;
X! 	} else if (!is_neuter(&mons[mntmp]) && mntmp != u.ulycn) {
X  		if(!rn2(10)) dochange = TRUE;
X  	}
X  	if (dochange) {
X***************
X*** 777,809 ****
X  	 * plus the trailing null, after pluralizing (since sometimes a
X  	 * buffer is made a fixed size and must be able to hold it)
X  	 */
X! 	static const char NEARDATA *humanoid_parts[] = { "arm", "eye", "face", "finger",
X  		"fingertip", "foot", "hand", "handed", "head", "leg",
X  		"light headed", "neck", "spine", "toe" };
X  #ifdef POLYSELF
X! 	static const char NEARDATA *jelly_parts[] = { "pseudopod", "dark spot", "front",
X  		"pseudopod extension", "pseudopod extremity",
X  		"pseudopod root", "grasp", "grasped", "cerebral area",
X  		"lower pseudopod", "viscous", "middle", "surface",
X  		"pseudopod extremity" },
X! 	NEARDATA *animal_parts[] = { "forelimb", "eye", "face", "foreclaw", "claw tip",
X  		"rear claw", "foreclaw", "clawed", "head", "rear limb",
X  		"light headed", "neck", "spine", "rear claw tip" },
X! 	NEARDATA *horse_parts[] = { "forelimb", "eye", "face", "forehoof", "hoof tip",
X  		"rear hoof", "foreclaw", "hooved", "head", "rear limb",
X  		"light headed", "neck", "backbone", "rear hoof tip" },
X! 	NEARDATA *sphere_parts[] = { "appendage", "optic nerve", "body", "tentacle",
X  		"tentacle tip", "lower appendage", "tentacle", "tentacled",
X  		"body", "lower tentacle", "rotational", "equator", "body",
X  		"lower tentacle tip" },
X! 	NEARDATA *fungus_parts[] = { "mycelium", "visual area", "front", "hypha",
X  		"hypha", "root", "strand", "stranded", "cap area",
X  		"rhizome", "sporulated", "stalk", "root", "rhizome tip" },
X! 	NEARDATA *vortex_parts[] = { "region", "eye", "front", "minor current",
X  		"minor current", "lower current", "swirl", "swirled",
X  		"central core", "lower current", "addled", "center",
X  		"currents", "edge" },
X! 	NEARDATA *snake_parts[] = { "vestigial limb", "eye", "face", "large scale",
X  		"large scale tip", "rear region", "scale gap", "scale gapped",
X  		"head", "rear region", "light headed", "neck", "length",
X  		"rear scale" };
X--- 777,809 ----
X  	 * plus the trailing null, after pluralizing (since sometimes a
X  	 * buffer is made a fixed size and must be able to hold it)
X  	 */
X! 	static NEARDATA const char *humanoid_parts[] = { "arm", "eye", "face", "finger",
X  		"fingertip", "foot", "hand", "handed", "head", "leg",
X  		"light headed", "neck", "spine", "toe" };
X  #ifdef POLYSELF
X! 	static NEARDATA const char *jelly_parts[] = { "pseudopod", "dark spot", "front",
X  		"pseudopod extension", "pseudopod extremity",
X  		"pseudopod root", "grasp", "grasped", "cerebral area",
X  		"lower pseudopod", "viscous", "middle", "surface",
X  		"pseudopod extremity" },
X! 	*animal_parts[] = { "forelimb", "eye", "face", "foreclaw", "claw tip",
X  		"rear claw", "foreclaw", "clawed", "head", "rear limb",
X  		"light headed", "neck", "spine", "rear claw tip" },
X! 	*horse_parts[] = { "forelimb", "eye", "face", "forehoof", "hoof tip",
X  		"rear hoof", "foreclaw", "hooved", "head", "rear limb",
X  		"light headed", "neck", "backbone", "rear hoof tip" },
X! 	*sphere_parts[] = { "appendage", "optic nerve", "body", "tentacle",
X  		"tentacle tip", "lower appendage", "tentacle", "tentacled",
X  		"body", "lower tentacle", "rotational", "equator", "body",
X  		"lower tentacle tip" },
X! 	*fungus_parts[] = { "mycelium", "visual area", "front", "hypha",
X  		"hypha", "root", "strand", "stranded", "cap area",
X  		"rhizome", "sporulated", "stalk", "root", "rhizome tip" },
X! 	*vortex_parts[] = { "region", "eye", "front", "minor current",
X  		"minor current", "lower current", "swirl", "swirled",
X  		"central core", "lower current", "addled", "center",
X  		"currents", "edge" },
X! 	*snake_parts[] = { "vestigial limb", "eye", "face", "large scale",
X  		"large scale tip", "rear region", "scale gap", "scale gapped",
X  		"head", "rear region", "light headed", "neck", "length",
X  		"rear scale" };
X*** /tmp/da08486	Thu Feb 25 10:24:43 1993
X--- src/potion.c	Thu Feb 11 13:27:58 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)potion.c	3.1	92/12/10		  */
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)potion.c	3.1	93/02/06		  */
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 8,14 ****
X  static void NDECL(ghost_from_bottle);
X  static boolean FDECL(neutralizes, (struct obj *,struct obj *));
X  
X! static int NEARDATA nothing, NEARDATA unkn;
X  #endif /* OVLB */
X  
X  extern boolean notonhead;	/* for long worms */
X--- 8,14 ----
X  static void NDECL(ghost_from_bottle);
X  static boolean FDECL(neutralizes, (struct obj *,struct obj *));
X  
X! static NEARDATA int nothing, unkn;
X  #endif /* OVLB */
X  
X  extern boolean notonhead;	/* for long worms */
X***************
X*** 18,24 ****
X  
X  #ifdef OVLB
X  
X! static const char NEARDATA beverages[] = { POTION_CLASS, 0 };
X  
X  void
X  make_confused(xtime,talk)
X--- 18,24 ----
X  
X  #ifdef OVLB
X  
X! static NEARDATA const char beverages[] = { POTION_CLASS, 0 };
X  
X  void
X  make_confused(xtime,talk)
X***************
X*** 310,317 ****
X  	case POT_WATER:
X  		if(!otmp->blessed && !otmp->cursed) {
X  			pline("This tastes like %swater.",
X! 			      otmp->spe == -1 ? "impure " : "");
X! 			lesshungry(rnd(otmp->spe == -1 ? 3 : 10));
X  			break;
X  		}
X  		unkn++;
X--- 310,317 ----
X  	case POT_WATER:
X  		if(!otmp->blessed && !otmp->cursed) {
X  			pline("This tastes like %swater.",
X! 			      otmp->odiluted ? "impure " : "");
X! 			lesshungry(rnd(otmp->odiluted ? 3 : 10));
X  			break;
X  		}
X  		unkn++;
X***************
X*** 365,375 ****
X  		break;
X  	case POT_BOOZE:
X  		unkn++;
X! 		pline("Ooph!  This tastes like %s!",
X  		      Hallucination ? "furniture polish" : "liquid fire");
X  		if (!otmp->blessed) make_confused(HConfusion + d(3,8),FALSE);
X  		/* the whiskey makes us feel better */
X! 		if(u.uhp < u.uhpmax) losehp(-1, "", 0); /* can't kill you */
X  		lesshungry(10 * (2 + bcsign(otmp)));
X  		exercise(A_WIS, FALSE);
X  		if(otmp->cursed) {
X--- 365,377 ----
X  		break;
X  	case POT_BOOZE:
X  		unkn++;
X! 		pline("Ooph!  This tastes like %s%s!",
X! 		      otmp->odiluted ? "watered down " : "",
X  		      Hallucination ? "furniture polish" : "liquid fire");
X  		if (!otmp->blessed) make_confused(HConfusion + d(3,8),FALSE);
X  		/* the whiskey makes us feel better */
X! 		if (u.uhp < u.uhpmax && !otmp->odiluted)
X! 			losehp(-1, "", 0); /* can't kill you */
X  		lesshungry(10 * (2 + bcsign(otmp)));
X  		exercise(A_WIS, FALSE);
X  		if(otmp->cursed) {
X***************
X*** 429,442 ****
X  		else pline (Hallucination ?
X  #ifdef TUTTI_FRUTTI
X  		   "This tastes like 10%% real %s juice all-natural beverage." :
X! 		   "This tastes like %s juice.", pl_fruit
X  #else
X  		   "This tastes like 10%% real fruit juice all-natural beverage." :
X! 		   "This tastes like fruit juice."
X  #endif
X  			    );
X  		if (otmp->otyp == POT_FRUIT_JUICE) {
X! 			lesshungry(10 * (2 + bcsign(otmp)));
X  			break;
X  		}
X  		if (!otmp->cursed) {
X--- 431,446 ----
X  		else pline (Hallucination ?
X  #ifdef TUTTI_FRUTTI
X  		   "This tastes like 10%% real %s juice all-natural beverage." :
X! 		   "This tastes like %s%s juice.",
X! 		   otmp->odiluted ? "reconstituted " : "", pl_fruit
X  #else
X  		   "This tastes like 10%% real fruit juice all-natural beverage." :
X! 		   "This tastes like %sfruit juice.",
X! 		   otmp->odiluted ? "reconstituted " : ""
X  #endif
X  			    );
X  		if (otmp->otyp == POT_FRUIT_JUICE) {
X! 			lesshungry((otmp->odiluted ? 5 : 10) * (2 + bcsign(otmp)));
X  			break;
X  		}
X  		if (!otmp->cursed) {
X***************
X*** 985,995 ****
X  	    case POTION_CLASS:
X  		if (obj->otyp == POT_WATER) return FALSE;
X  		Your("%s.", aobjnam(obj,"dilute"));
X! 		if (obj->spe == -1) {
X! 			obj->spe = 0;
X  			obj->blessed = obj->cursed = FALSE;
X  			obj->otyp = POT_WATER;
X! 		} else obj->spe--;
X  		return TRUE;
X  	    case SCROLL_CLASS:
X  		if (obj->otyp != SCR_BLANK_PAPER
X--- 989,999 ----
X  	    case POTION_CLASS:
X  		if (obj->otyp == POT_WATER) return FALSE;
X  		Your("%s.", aobjnam(obj,"dilute"));
X! 		if (obj->odiluted) {
X! 			obj->odiluted = 0;
X  			obj->blessed = obj->cursed = FALSE;
X  			obj->otyp = POT_WATER;
X! 		} else obj->odiluted++;
X  		return TRUE;
X  	    case SCROLL_CLASS:
X  		if (obj->otyp != SCR_BLANK_PAPER
X***************
X*** 1139,1145 ****
X  		if (Blind) obj->dknown = 0;
X  
X  		switch (neutralizes(obj, potion) ||
X! 			obj->spe == -1 /* diluted */ ? 1 : rnd(8)) {
X  			case 1:
X  				obj->otyp = POT_WATER;
X  				obj->blessed = obj->cursed = 0;
X--- 1143,1149 ----
X  		if (Blind) obj->dknown = 0;
X  
X  		switch (neutralizes(obj, potion) ||
X! 			obj->odiluted ? 1 : rnd(8)) {
X  			case 1:
X  				obj->otyp = POT_WATER;
X  				obj->blessed = obj->cursed = 0;
X***************
X*** 1165,1175 ****
X  		}
X  
X  		if (obj->otyp == POT_WATER) {
X! 			obj->spe = 0; /* in case it was diluted before */
X  			pline("The mixture bubbles violently%s.",
X  				Blind ? "" : ", then clears");
X  		} else {
X! 			obj->spe--; /* diluted */
X  			if (!Blind) {
X  				pline("The mixture looks %s.",
X  					OBJ_DESCR(objects[obj->otyp]));
X--- 1169,1179 ----
X  		}
X  
X  		if (obj->otyp == POT_WATER) {
X! 			obj->odiluted = 0; /* in case it was diluted before */
X  			pline("The mixture bubbles violently%s.",
X  				Blind ? "" : ", then clears");
X  		} else {
X! 			obj->odiluted++;
X  			if (!Blind) {
X  				pline("The mixture looks %s.",
X  					OBJ_DESCR(objects[obj->otyp]));
X***************
X*** 1208,1214 ****
X  		potion->otyp = POT_WATER;
X  		potion->blessed = 0;
X  		potion->cursed = 0;
X! 		potion->spe = 0;
X  		return(1);
X  	}
X  
X--- 1212,1218 ----
X  		potion->otyp = POT_WATER;
X  		potion->blessed = 0;
X  		potion->cursed = 0;
X! 		potion->odiluted = 0;
X  		return(1);
X  	}
X  
X*** /tmp/da08494	Thu Feb 25 10:24:46 1993
X--- src/pray.c	Tue Feb 23 16:07:40 1993
X***************
X*** 524,530 ****
X  	case 0:	break;
X  	case 1:
X  	    if (uwep && (welded(uwep) || uwep->oclass == WEAPON_CLASS ||
X! 			 uwep->otyp == PICK_AXE) && (!uwep->blessed)) {
X  		if (uwep->cursed) {
X  		    uwep->cursed = FALSE;
X  		    uwep->bknown = TRUE;
X--- 524,531 ----
X  	case 0:	break;
X  	case 1:
X  	    if (uwep && (welded(uwep) || uwep->oclass == WEAPON_CLASS ||
X! 			 uwep->otyp == PICK_AXE || uwep->otyp == UNICORN_HORN)
X! 				&& (!uwep->blessed)) {
X  		if (uwep->cursed) {
X  		    uwep->cursed = FALSE;
X  		    uwep->bknown = TRUE;
X***************
X*** 533,539 ****
X  			     Hallucination ? hcolor() : amber);
X  		    else You("feel the power of %s over your %s.",
X  			u_gname(), xname(uwep));
X! 		} else if(uwep->otyp < BOW) {
X  		    uwep->blessed = uwep->bknown = TRUE;
X  		    if (!Blind)
X  			Your("%s with %s aura.",
X--- 534,540 ----
X  			     Hallucination ? hcolor() : amber);
X  		    else You("feel the power of %s over your %s.",
X  			u_gname(), xname(uwep));
X! 		} else if(uwep->otyp < BOW || uwep->otyp > CROSSBOW) {
X  		    uwep->blessed = uwep->bknown = TRUE;
X  		    if (!Blind)
X  			Your("%s with %s aura.",
X***************
X*** 696,702 ****
X  		    break;
X  		}
X  		/* enhance weapon regardless of alignment or artifact status */
X! 		if (obj && (obj->oclass == WEAPON_CLASS)) {
X  		    bless(obj);
X  		    obj->oeroded = 0;
X  		    obj->oerodeproof = TRUE;
X--- 697,703 ----
X  		    break;
X  		}
X  		/* enhance weapon regardless of alignment or artifact status */
X! 		if (obj && obj->oclass == WEAPON_CLASS) {
X  		    bless(obj);
X  		    obj->oeroded = 0;
X  		    obj->oerodeproof = TRUE;
X***************
X*** 788,794 ****
X  	angrygods(g_align);
X  }
X  
X! static const char NEARDATA sacrifice_types[] = { FOOD_CLASS, AMULET_CLASS, 0 };
X  
X  static void
X  consume_offering(otmp)
X--- 789,795 ----
X  	angrygods(g_align);
X  }
X  
X! static NEARDATA const char sacrifice_types[] = { FOOD_CLASS, AMULET_CLASS, 0 };
X  
X  static void
X  consume_offering(otmp)
X***************
X*** 866,872 ****
X  		    exercise(A_WIS, FALSE);
X  		}
X  
X! 	    if (altaralign != A_CHAOTIC) {
X  		/* curse the lawful/neutral altar */
X  		pline("The altar is stained with %sn blood.",
X  		      (pl_character[0]=='E') ? "elve" : "huma");
X--- 867,873 ----
X  		    exercise(A_WIS, FALSE);
X  		}
X  
X! 	    if (altaralign != A_CHAOTIC && altaralign != A_NONE) {
X  		/* curse the lawful/neutral altar */
X  		pline("The altar is stained with %sn blood.",
X  		      (pl_character[0]=='E') ? "elve" : "huma");
X***************
X*** 874,881 ****
X  		angry_priest();
X  	    } else {
X  		register struct monst *dmon;
X! 		/* Human sacrifice on a chaotic altar is equivalent */
X! 		/* to demon summoning */
X  		if(u.ualign.type != A_CHAOTIC) {
X  		pline("The blood floods the altar, which vanishes in %s cloud!",
X  			  an(Hallucination ? hcolor() : Black));
X--- 875,882 ----
X  		angry_priest();
X  	    } else {
X  		register struct monst *dmon;
X! 		/* Human sacrifice on a chaotic or unaligned altar */
X! 		/* is equivalent to demon summoning */
X  		if(u.ualign.type != A_CHAOTIC) {
X  		pline("The blood floods the altar, which vanishes in %s cloud!",
X  			  an(Hallucination ? hcolor() : Black));
X***************
X*** 886,894 ****
X  		    pline("The blood covers the altar!");
X  		    change_luck(2);
X  		}
X! 		if ((dmon = makemon(&mons[dlord()], u.ux, u.uy)) != 0) {
X  		    You("have summoned %s!", a_monnam(dmon));
X! 		    if (u.ualign.type == A_CHAOTIC)
X  			dmon->mpeaceful = TRUE;
X  		    You("are terrified, and unable to move.");
X  		    nomul(-3);
X--- 887,895 ----
X  		    pline("The blood covers the altar!");
X  		    change_luck(2);
X  		}
X! 		if ((dmon = makemon(&mons[dlord(altaralign)], u.ux, u.uy))) {
X  		    You("have summoned %s!", a_monnam(dmon));
X! 		    if (sgn(u.ualign.type) == sgn(dmon->data->maligntyp))
X  			dmon->mpeaceful = TRUE;
X  		    You("are terrified, and unable to move.");
X  		    nomul(-3);
X***************
X*** 1279,1285 ****
X  doturn()
X  {	/* Knights & Priest(esse)s only please */
X  
X! 	register struct monst *mtmp;
X  	register int	xlev = 6;
X  
X  	if((pl_character[0] != 'P') &&
X--- 1280,1286 ----
X  doturn()
X  {	/* Knights & Priest(esse)s only please */
X  
X! 	register struct monst *mtmp, *mtmp2;
X  	register int	xlev = 6;
X  
X  	if((pl_character[0] != 'P') &&
X***************
X*** 1319,1325 ****
X  	}
X  	pline("Calling upon %s, you chant an arcane formula.", u_gname());
X  	exercise(A_WIS, TRUE);
X! 	for(mtmp = fmon; mtmp; mtmp = mtmp->nmon)
X  	    if(cansee(mtmp->mx,mtmp->my)) {
X  		if(!mtmp->mpeaceful && (is_undead(mtmp->data) ||
X  		   (is_demon(mtmp->data) && (u.ulevel > (MAXULEV/2))))) {
X--- 1320,1327 ----
X  	}
X  	pline("Calling upon %s, you chant an arcane formula.", u_gname());
X  	exercise(A_WIS, TRUE);
X! 	for(mtmp = fmon; mtmp; mtmp = mtmp2) {
X! 	    mtmp2 = mtmp->nmon;
X  	    if(cansee(mtmp->mx,mtmp->my)) {
X  		if(!mtmp->mpeaceful && (is_undead(mtmp->data) ||
X  		   (is_demon(mtmp->data) && (u.ulevel > (MAXULEV/2))))) {
X***************
X*** 1328,1334 ****
X  			pline("Unfortunately, your voice falters.");
X  			mtmp->mflee = mtmp->mfrozen = mtmp->msleep = FALSE;
X  			mtmp->mcanmove = TRUE;
X! 		    } else if (! resist(mtmp, '\0', 0, TELL))
X  			switch (mtmp->data->mlet) {
X  			    /* this is intentional, lichs are tougher
X  			       than zombies. */
X--- 1330,1336 ----
X  			pline("Unfortunately, your voice falters.");
X  			mtmp->mflee = mtmp->mfrozen = mtmp->msleep = FALSE;
X  			mtmp->mcanmove = TRUE;
X! 		    } else if (! resist(mtmp, '\0', 0, TELL)) {
X  			switch (mtmp->data->mlet) {
X  			    /* this is intentional, lichs are tougher
X  			       than zombies. */
X***************
X*** 1352,1359 ****
X  			default:    mtmp->mflee = TRUE;
X  			    break;
X  			}
X! 		   }
X  	    }
X  	nomul(-5);
X  	return(1);
X  }
X--- 1354,1363 ----
X  			default:    mtmp->mflee = TRUE;
X  			    break;
X  			}
X! 		    }
X! 		}
X  	    }
X+ 	}
X  	nomul(-5);
X  	return(1);
X  }
X
END_OF_FILE
if test 52954 -ne `wc -c <'patches01g'`; then
    echo shar: \"'patches01g'\" unpacked with wrong size!
fi
# end of 'patches01g'
if test -f 'sys/winnt/nhico.uu' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'sys/winnt/nhico.uu'\" to \"'sys/winnt/nhico.uu.orig'\"
  mv -f 'sys/winnt/nhico.uu' 'sys/winnt/nhico.uu.orig'
fi
echo shar: Extracting \"'sys/winnt/nhico.uu'\" \(1263 characters\)
sed "s/^X//" >'sys/winnt/nhico.uu' <<'END_OF_FILE'
Xsection 1 of uuencode 4.13 of file NETHACK.ICO    by R.E.M.
X
Xbegin 644 NETHACK.ICO
XM```!``$`("`0``````#H`@``%@```"@````@````0`````$`!```````@`(`.
XM``````````````````````````````"```"`````@(``@````(``@`"`@```6
XM@("``,#`P````/\``/\```#__P#_````_P#_`/__``#___\`]F9F9F9F9F9F*
XM9F9F9F9F9O]F9F9F9F9F9F9F9F9F9F;_B(B(B(B(B(B(B(B(B&9F_XB(B(B(D
XMB(B(B(B(B(AF9O^(B(B(A555B(B(B(B(9F;_B(B(B`!5!8B(B(B(B&9F_XB('
XMB(@```6(B(B(B(AF9O^(B%554`!56(B(B(B(9F;_B(N[N[`.XU6(B(B(B&9F[
XM_XB[N[L`ONXU6(B(B(AF9O^+N[N[N[ONXUB(B(B(9F;_B[N[N[N[ONY3B(B(N
XMB&9F_XN[NYF9F[ONXSB(B(AF9O^+N[F9F9F[ONXSB(B(9F;_B[N9F9F9F[ON?
XMXSB(B&9F_XNYF9F9F9F[7NXSB(AF9O^+N9F9F9F9NUCNXSB(9F;_B[F9F9F9J
XMF;M8CNXSB&9F_XNYF9F9F9F[6(CNXXAF9O^+N9F9F9F9NUB(CNZ(9F;_B[N9]
XMF9F9F[M8B(CNB&9F_XN[N9F9F;N[6(B(B(AF9O^+N[N9F9N[NUB(B(B(9F;_R
XMB[N[N[N[N[M8B(B(B&9F_XN[N[N[N[N[B(B(B(AF9O^+NXB(B(B+NXB(B(B(F
XM9F;_B[B(B(B(B+N(B(B(B&9F_XB(B(B(B(B(B(B(B(AF9O^(B(B(B(B(B(B(J
XMB(B(9F;_B(B(B(B(B(B(B(B(B&9F___________________V9O__________%
XM__________\`````````````````````````````````````````````````R
XM`````````````````````````````````````````````````````````````
XM`````````````````````````````````````````````````````````````
X!`````
X``
Xend
Xsum -r/size 23881/1107 section (from "begin" to "end")
Xsum -r/size 55184/766 entire input file
END_OF_FILE
if test 1263 -ne `wc -c <'sys/winnt/nhico.uu'`; then
    echo shar: \"'sys/winnt/nhico.uu'\" unpacked with wrong size!
fi
chmod +x 'sys/winnt/nhico.uu'
# end of 'sys/winnt/nhico.uu'
echo shar: End of archive 14 \(of 31\).
cp /dev/null ark14isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 31 archives.
    echo "Now execute 'patchit.sh'"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
