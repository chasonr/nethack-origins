Subject:  v17i051:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Patch1j/31
Newsgroups: comp.sources.games
Approved: billr@saab.CNA.TEK.COM

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 17, Issue 51
Archive-name: nethack31/Patch1j
Patch-To: nethack31: Volume 16, Issue 1-116
Environment: Amiga, Atari, Mac, MS-DOS, Windows-NT, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 10 (of 31)."
# Contents:  UPDATE1 patches01s
# Wrapped by billr@saab on Fri Mar  5 10:50:43 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'UPDATE1' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'UPDATE1'\" to \"'UPDATE1.orig'\"
  mv -f 'UPDATE1' 'UPDATE1.orig'
fi
echo shar: Extracting \"'UPDATE1'\" \(1331 characters\)
sed "s/^X//" >'UPDATE1' <<'END_OF_FILE'
XWe wish to thank the many people who sent us bug reports, fixes, and
Xsuggestions for improvements.  Please keep doing this.
X
XMore polish was applied to the Amiga, Mac, and X11 windowing systems.
XX11 WM_DELETE_WINDOW handling was added by David Wexelblat.  As we said
Xin the initial release, the Mac and the Amiga ports are still in
Xdevelopment.  You will find them to be much improved, but there is more
Xwork to be done.  Make constructive comments.
X
XThe instrument sound files were broken out from their Mac-specific format
Xand are now being used by the Amiga port.
X
XA Windows NT console port was provided by Michael Allison.
X
XVarious portability fixes for more UNIX makes and HPUX versions.
X
XMany small bugs were fixed.  Some of the most popular include misconfiguring
Xwindowing systems, the wrong phase of the moon for some micro ports,
Xpolymorphing into bees, "ghosts" left by reeling monsters, throwing Mjollnir
Xat walls, various problems with shop payment, mysterious rust damage on damp
Xlevels, Bells of Opening for Tourists, and bones on endgame levels.
X
XMany, many small changes having to do with message phrasing (thanks to
XFelix Lee) and Amiga declaration syntax for their new compiler version
X(transparent to other ports).
X
XPlease NOTE:  Old save/bones files should be deleted.  They will NOT
Xwork with NetHack 3.1.1.
X
END_OF_FILE
if test 1331 -ne `wc -c <'UPDATE1'`; then
    echo shar: \"'UPDATE1'\" unpacked with wrong size!
fi
# end of 'UPDATE1'
if test -f 'patches01s' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'patches01s'\" to \"'patches01s.orig'\"
  mv -f 'patches01s' 'patches01s.orig'
fi
echo shar: Extracting \"'patches01s'\" \(53863 characters\)
sed "s/^X//" >'patches01s' <<'END_OF_FILE'
X*** /tmp/da09374	Thu Feb 25 10:29:06 1993
X--- sys/mac/maccurs.c	Sun Feb 21 16:06:06 1993
X***************
X*** 91,96 ****
X--- 91,99 ----
X  }
X  
X  
X+ #if 0
X+ /* Now we use click_to_cmd() instead. */
X+ 
X  int
X  clickSector ( int x , int y , int toX , int toY )
X  {
X***************
X*** 155,161 ****
X  	}
X  }
X  
X! 
X  
X  
X  Boolean
X--- 158,164 ----
X  	}
X  }
X  
X! #endif
X  
X  
X  Boolean
X*** /tmp/da09398	Thu Feb 25 10:29:12 1993
X--- sys/mac/macmain.c	Thu Feb 11 12:12:23 1993
X***************
X*** 114,120 ****
X  		boolean remember_wiz_mode = wizard;
X  #endif
X  #ifdef NEWS
X! 		if(flags.news) display_file(NEWS, FALSE);
X  #endif
X  		pline("Restoring save file...");
X  		mark_synch();	/* flush output */
X--- 114,123 ----
X  		boolean remember_wiz_mode = wizard;
X  #endif
X  #ifdef NEWS
X! 		if(flags.news) {
X! 			display_file(NEWS, FALSE);
X! 			flags.news = FALSE;	/* in case dorecover() fails */
X! 		}
X  #endif
X  		pline("Restoring save file...");
X  		mark_synch();	/* flush output */
X***************
X*** 174,185 ****
X  	attemptingto("proceed");
X  #if defined(MAC_MPW32) && !defined(MODEL_FAR)
X  	UnloadAllSegments();						/* Do this before naming residents */
X! 	IsResident( (Ptr) display_nhwindow );		/* Sample resident segments */
X  	IsResident( (Ptr) rhack );
X  	IsResident( (Ptr) engr_at );
X  	IsResident( (Ptr) movemon );
X  	IsResident( (Ptr) attacktype ) ;
X  	IsResident( (Ptr) mac_get_nh_event ) ;
X  #endif
X  	moveloop();
X  	/*NOTREACHED*/
X--- 177,197 ----
X  	attemptingto("proceed");
X  #if defined(MAC_MPW32) && !defined(MODEL_FAR)
X  	UnloadAllSegments();						/* Do this before naming residents */
X! 	IsResident( (Ptr) um_dist );				/* Sample resident segments */
X! 	IsResident( (Ptr) flush_screen );
X  	IsResident( (Ptr) rhack );
X+ 	IsResident( (Ptr) remove_cadavers );
X+ 	IsResident( (Ptr) dog_move );
X+ 	IsResident( (Ptr) gethungry );
X  	IsResident( (Ptr) engr_at );
X+ 	IsResident( (Ptr) domove );
X+ 	IsResident( (Ptr) carried );
X  	IsResident( (Ptr) movemon );
X  	IsResident( (Ptr) attacktype ) ;
X  	IsResident( (Ptr) mac_get_nh_event ) ;
X+ 	IsResident( (Ptr) dosounds ) ;
X+ 	IsResident( (Ptr) t_at ) ;
X+ 	IsResident( (Ptr) nh_timeout ) ;
X  #endif
X  	moveloop();
X  	/*NOTREACHED*/
X***************
X*** 434,441 ****
X  #define	kUnLoaded 0x3F3C				/* if unloaded then a LoadSeg trap */
X  										/* Note: probably incorrect for -model far! */
X  
X! /* #define TRACKSEGS /* Utility to print a trace of segment load frequencies. Add
X!    a call to ListGUnloads into terminate() in end.c to use it */
X  
X  #ifdef TRACKSEGS
X  
X--- 446,452 ----
X  #define	kUnLoaded 0x3F3C				/* if unloaded then a LoadSeg trap */
X  										/* Note: probably incorrect for -model far! */
X  
X! /* #define TRACKSEGS /* Utility to print a trace of segment load frequencies. */
X  
X  #ifdef TRACKSEGS
X  
X***************
X*** 447,453 ****
X    int i;
X    FILE *f;
X    
X!   f = fopen("unloads","r+");
X    fprintf(f,"%d calls to UnloadAllSegments\n\n",gUnloads[0]);
X    for (i=1; i<=pMaxSegNum; i++) {
X  	 fprintf(f,"Unloaded %10s, segment %2d, %6d times\n",gSegNames[i],i,gUnloads[i]);
X--- 458,464 ----
X    int i;
X    FILE *f;
X    
X!   f = fopen("unloads","w");
X    fprintf(f,"%d calls to UnloadAllSegments\n\n",gUnloads[0]);
X    for (i=1; i<=pMaxSegNum; i++) {
X  	 fprintf(f,"Unloaded %10s, segment %2d, %6d times\n",gSegNames[i],i,gUnloads[i]);
X***************
X*** 504,509 ****
X--- 515,521 ----
X  	SetResLoad(false);	
X  
X  	#ifdef TRACKSEGS
X+ 	atexit(&ListGUnloads);
X  	gUnloads[0]=0;
X  	#endif
X  	for (i=1; i<=pMaxSegNum; i++) {
X*** /tmp/da09414	Thu Feb 25 10:29:17 1993
X--- sys/mac/mactopl.c	Thu Feb 18 17:37:56 1993
X***************
X*** 7,13 ****
X  #include <OSUtils.h>
X  #include <Packages.h>
X  
X- // int NDECL(mac_doprev_message);
X  // char FDECL(yn_function,(const char *, const char *, CHAR_P));
X  
X  int FDECL ( try_key_queue , ( char * ) ) ;
X--- 7,12 ----
X***************
X*** 25,59 ****
X  extern winid inSelect ;
X  extern short frame_corner ;
X  
X- int
X- mac_doprev_message(void)
X- {
X- 	NhWindow * aWin = & theWindows [ WIN_MESSAGE ] ;
X- 	char * start , * stop ;
X  
X- 	if ( ! WIN_MESSAGE )
X- 		return 0 ;
X- 
X- 	stop = * aWin -> windowText ;
X- 	start = * aWin -> windowText + aWin -> textBase - 2 ;
X- 
X- 	while ( start > stop && * start != 10 && * start != 13 )
X- 		start -- ;
X- 
X- 	if ( start <= stop )
X- 		aWin -> textBase = 0L ;
X- 	else
X- 		aWin -> textBase = start - stop + 1 ;
X- 	if ( aWin -> textBase > aWin -> windowTextLen )
X- 		aWin -> textBase = aWin -> windowTextLen ;
X- 
X- 	display_nhwindow ( WIN_MESSAGE , FALSE ) ;
X- 	InvalRect ( & ( aWin -> theWindow -> portRect ) ) ;
X- 
X- 	return 0 ;
X- }
X- 
X- 
X  char
X  queued_resp(char *resp)
X  {
X--- 24,30 ----
X***************
X*** 414,420 ****
X  		topl_set_resp(resp, def);
X  
X  		do {
X! 			c = nhgetch();
X  			if (c && resp && !strchr(resp, c)) {
X  				nhbell();
X  				c = '\0';
X--- 385,391 ----
X  		topl_set_resp(resp, def);
X  
X  		do {
X! 			c = readchar();
X  			if (c && resp && !strchr(resp, c)) {
X  				nhbell();
X  				c = '\0';
X*** /tmp/da09430	Thu Feb 25 18:16:50 1993
X--- sys/mac/macwin.c	Thu Feb 25 18:07:54 1993
X***************
X*** 79,85 ****
X--- 79,100 ----
X  
X  Boolean gClickedToMove = 0 ; /* For ObscureCursor */
X  
X+ static unsigned long gNextClickRepeat = 0xffffffff ;
X  
X+ static Point clicked_pos ;	/* For nh_poskey */
X+ static int clicked_mod ;
X+ 
X+ static Boolean cursor_locked = false ;
X+ 
X+ void
X+ lock_mouse_cursor(Boolean new_cursor_locked)
X+ {
X+ 	cursor_locked = new_cursor_locked;
X+ 	if (new_cursor_locked)
X+ 		PostEvent(osEvt, mouseMovedMessage<<24);
X+ }
X+ 
X+ 
X  /*
X   * Add key to input queue, force means replace last if full
X   */
X***************
X*** 115,120 ****
X--- 130,140 ----
X  MacFlags macFlags ;
X  
X  /*
X+  * The screen layouts on the small 512x342 screen need special cares.
X+  */
X+ Boolean small_screen;
X+ 
X+ /*
X   * Async flag for keeping track of scrollbars...
X   * Used by InvalScrollBar ( )
X   */
X***************
X*** 121,129 ****
X  static NhWindow * asyDSC = (NhWindow *) NULL ;
X  
X  /*
X!  * The font to be used in the text window
X   */
X! short text_wind_font = geneva;
X  
X  /*
X   * Whether to adjust the height of a text window according to its contents
X--- 141,150 ----
X  static NhWindow * asyDSC = (NhWindow *) NULL ;
X  
X  /*
X!  * The font to be used in the text window, will be set to geneva after
X!  * we create the base window
X   */
X! short text_wind_font = monaco;
X  
X  /*
X   * Whether to adjust the height of a text window according to its contents
X***************
X*** 136,146 ****
X  MenuHandle appleMenu ;
X  MenuHandle fileMenu ;
X  MenuHandle editMenu ;
X! MenuHandle extendMenu ;
X! MenuHandle miscMenu ;
X! MenuHandle helpMenu ;
X! MenuHandle commandsMenu ;
X  MenuHandle thingsMenu ;
X  
X  #define NHW_BASE 0
X  winid BASE_WINDOW ; // Was: , WIN_MAP , WIN_MESSAGE , WIN_INVEN , WIN_STATUS ;
X--- 157,168 ----
X  MenuHandle appleMenu ;
X  MenuHandle fileMenu ;
X  MenuHandle editMenu ;
X! MenuHandle actionMenu ;
X! MenuHandle inventoryMenu ;
X  MenuHandle thingsMenu ;
X+ MenuHandle extendedMenu ;
X+ MenuHandle infoMenu ;
X+ MenuHandle helpMenu ;
X  
X  #define NHW_BASE 0
X  winid BASE_WINDOW ; // Was: , WIN_MAP , WIN_MESSAGE , WIN_INVEN , WIN_STATUS ;
X***************
X*** 271,277 ****
X  	InitSegMgmt( itworked );	/* itworked is always in the main segment */
X  	
X  	attemptingto("start up");
X! 	
X  	if ( Gestalt ( gestaltOSAttr , & l ) ) {
X  		macFlags . processes = 0 ;
X  		macFlags . tempMem = 0 ;
X--- 293,299 ----
X  	InitSegMgmt( itworked );	/* itworked is always in the main segment */
X  	
X  	attemptingto("start up");
X! 
X  	if ( Gestalt ( gestaltOSAttr , & l ) ) {
X  		macFlags . processes = 0 ;
X  		macFlags . tempMem = 0 ;
X***************
X*** 324,330 ****
X  }
X  
X  
X! #define MAX_HEIGHT 200
X  #define MIN_HEIGHT 50
X  #define MIN_WIDTH 300
X  
X--- 346,352 ----
X  }
X  
X  
X! #define MAX_HEIGHT 100
X  #define MIN_HEIGHT 50
X  #define MIN_WIDTH 300
X  
X***************
X*** 355,361 ****
X  	width = nhWin -> charWidth * NUM_COLS ;
X  
X  	if ( ! RetrievePosition ( kMapWindow , & top , & left ) ) {
X! 		top = GetMBarHeight ( ) * 2 ;
X  		left = ( screenArea . right - width ) / 2 ;
X  	}
X  
X--- 377,383 ----
X  	width = nhWin -> charWidth * NUM_COLS ;
X  
X  	if ( ! RetrievePosition ( kMapWindow , & top , & left ) ) {
X! 		top = GetMBarHeight ( ) + ( small_screen ? 2 : 20 ) ;
X  		left = ( screenArea . right - width ) / 2 ;
X  	}
X  
X***************
X*** 389,400 ****
X  	theWindow = nhWin -> theWindow ;
X  
X  	if ( ! RetrievePosition ( kMessageWindow , & top , & left ) ) {
X! 		top = statTop + statHeight + 20 ;
X  		left = statLeft ;
X  	}
X  
X  	if ( ! RetrieveSize ( kMessageWindow , top , left , & height , & width ) ) {
X! 		height = screenArea . bottom - top - 2 ;
X  		if ( height > MAX_HEIGHT ) {
X  			height = MAX_HEIGHT ;
X  		} else if ( height < MIN_HEIGHT ) {
X--- 411,424 ----
X  	theWindow = nhWin -> theWindow ;
X  
X  	if ( ! RetrievePosition ( kMessageWindow , & top , & left ) ) {
X! 		top = statTop + statHeight ;
X! 		if ( ! small_screen )
X! 			top += 20 ;
X  		left = statLeft ;
X  	}
X  
X  	if ( ! RetrieveSize ( kMessageWindow , top , left , & height , & width ) ) {
X! 		height = screenArea . bottom - top - ( small_screen ? 2-SBARHEIGHT : 2 ) ;
X  		if ( height > MAX_HEIGHT ) {
X  			height = MAX_HEIGHT ;
X  		} else if ( height < MIN_HEIGHT ) {
X***************
X*** 410,419 ****
X  	mesgWidth = width ;
X  
X  /* Move these windows */
X- 	MoveWindow ( theWindows [ WIN_STATUS ] . theWindow , statLeft , statTop , 1 ) ;
X- 	SizeWindow ( theWindows [ WIN_STATUS ] . theWindow , statWidth , statHeight , 1 ) ;
X  	MoveWindow ( theWindows [ WIN_MESSAGE ] . theWindow , mesgLeft , mesgTop , 1 ) ;
X  	SizeWindow ( theWindows [ WIN_MESSAGE ] . theWindow , mesgWidth , mesgHeight , 1 ) ;
X  	MoveWindow ( theWindows [ WIN_MAP ] . theWindow , mainLeft , mainTop , 1 ) ;
X  	SizeWindow ( theWindows [ WIN_MAP ] . theWindow , mainWidth , mainHeight , 1 ) ;
X  
X--- 434,443 ----
X  	mesgWidth = width ;
X  
X  /* Move these windows */
X  	MoveWindow ( theWindows [ WIN_MESSAGE ] . theWindow , mesgLeft , mesgTop , 1 ) ;
X  	SizeWindow ( theWindows [ WIN_MESSAGE ] . theWindow , mesgWidth , mesgHeight , 1 ) ;
X+ 	MoveWindow ( theWindows [ WIN_STATUS ] . theWindow , statLeft , statTop , 1 ) ;
X+ 	SizeWindow ( theWindows [ WIN_STATUS ] . theWindow , statWidth , statHeight , 1 ) ;
X  	MoveWindow ( theWindows [ WIN_MAP ] . theWindow , mainLeft , mainTop , 1 ) ;
X  	SizeWindow ( theWindows [ WIN_MAP ] . theWindow , mainWidth , mainHeight , 1 ) ;
X  
X***************
X*** 437,443 ****
X  					} else {
X  						if ( ! RetrievePosition ( kTextWindow , & top , & left ) ) {
X  							top = GetMBarHeight ( ) * 2 ;
X! 							left = screenArea . right - 3 ;
X  						}
X  						top += ( numText * GetMBarHeight ( ) ) ;
X  						while ( top > screenArea . bottom - MIN_HEIGHT ) {
X--- 461,468 ----
X  					} else {
X  						if ( ! RetrievePosition ( kTextWindow , & top , & left ) ) {
X  							top = GetMBarHeight ( ) * 2 ;
X! 							left = screenArea . right - 3 - ( theWindow -> portRect . right -
X! 															  theWindow -> portRect . left ) ;
X  						}
X  						top += ( numText * GetMBarHeight ( ) ) ;
X  						while ( top > screenArea . bottom - MIN_HEIGHT ) {
X***************
X*** 445,452 ****
X  							left -= 20 ;
X  						}
X  						numText ++ ;
X! 						MoveWindow ( theWindow , left - ( theWindow -> portRect . right -
X! 							theWindow -> portRect . left ) , top , 1 ) ;
X  					}
X  				}
X  			}
X--- 470,476 ----
X  							left -= 20 ;
X  						}
X  						numText ++ ;
X! 						MoveWindow ( theWindow , left , top , 1 ) ;
X  					}
X  				}
X  			}
X***************
X*** 498,504 ****
X  	( ( WindowPeek ) aWin -> theWindow ) -> windowKind = WIN_BASE_KIND
X  		+ type ;
X  	aWin -> windowTextLen = 0L ;
X- 	aWin -> textBase = 0L ;
X  	aWin -> clear = 0 ; /* Yes, we need to inval the area on a clear */
X  	aWin -> scrollBar = (ControlHandle) NULL ;
X  	switch ( type ) {
X--- 522,527 ----
X***************
X*** 530,535 ****
X--- 553,560 ----
X  			aWin -> theWindow = (WindowPtr) NULL ;
X  			return WIN_ERR ;
X  		}
X+ 		aWin -> windowTextLen = 0L ;
X+ 		aWin -> lin = 0 ;
X  		break ;
X  	}
X  
X***************
X*** 600,606 ****
X  		siz . bottom - siz . top , FALSE ) ;
X  	MoveWindow ( aWin -> theWindow , siz . left , siz . top , FALSE ) ;
X  
X! 	if ( type == NHW_MENU || type == NHW_TEXT ) {
X  		Rect r = siz ;
X  		Boolean bool ;
X  		OffsetRect ( & r , - r . left , - r . top ) ;
X--- 625,631 ----
X  		siz . bottom - siz . top , FALSE ) ;
X  	MoveWindow ( aWin -> theWindow , siz . left , siz . top , FALSE ) ;
X  
X! 	if ( type == NHW_MENU || type == NHW_TEXT || type == NHW_MESSAGE ) {
X  		Rect r = siz ;
X  		Boolean bool ;
X  		OffsetRect ( & r , - r . left , - r . top ) ;
X***************
X*** 619,624 ****
X--- 644,660 ----
X  }
X  
X  
X+ static MenuHandle
X+ mustGetMHandle(int menu_id)
X+ {
X+ 	MenuHandle menu = GetMHandle(menu_id);
X+ 	if (menu == nil) {
X+ 		comment("Cannot find the menu.", menu_id);
X+ 		ExitToShell();
X+ 	}
X+ 	return menu;
X+ }
X+ 
X  void
X  InitRes ( void )
X  {
X***************
X*** 628,650 ****
X  	mustwork(ResError());
X  	SetMenuBar ( mBar ) ;
X  	
X! 	appleMenu = GetMHandle ( 128 ) ;
X! 	mustwork(ResError());
X  	AppendMenu ( appleMenu , ( ConstStr255Param ) "\002(-" ) ;
X  	AddResMenu ( appleMenu , 'DRVR' ) ;
X  
X! 	fileMenu = GetMHandle ( 129 ) ;
X! 	mustwork(ResError());
X! 	editMenu = GetMHandle ( 130 ) ;
X! 	mustwork(ResError());
X! 	extendMenu = GetMHandle ( 131 ) ;
X! 	mustwork(ResError());
X! 	miscMenu = GetMHandle ( 132 ) ;
X! 	mustwork(ResError());
X! 	commandsMenu = GetMHandle ( 133 ) ;
X! 	mustwork ( ResError ( ) ) ;
X! 	thingsMenu = GetMHandle ( 134 ) ;
X! 	mustwork ( ResError ( ) ) ;
X  
X  	if ( macFlags . help ) {
X  		if ( HMGetHelpMenuHandle ( & helpMenu ) ) {
X--- 664,680 ----
X  	mustwork(ResError());
X  	SetMenuBar ( mBar ) ;
X  	
X! 	appleMenu = mustGetMHandle ( 128 ) ;
X  	AppendMenu ( appleMenu , ( ConstStr255Param ) "\002(-" ) ;
X  	AddResMenu ( appleMenu , 'DRVR' ) ;
X  
X! 	fileMenu = mustGetMHandle ( 129 ) ;
X! 	editMenu = mustGetMHandle ( 130 ) ;
X! 	actionMenu = mustGetMHandle ( 131 ) ;
X! 	inventoryMenu = mustGetMHandle ( 132 ) ;
X! 	thingsMenu = mustGetMHandle ( 133 ) ;
X! 	extendedMenu = mustGetMHandle ( 134 ) ;
X! 	infoMenu = mustGetMHandle ( 135 ) ;
X  
X  	if ( macFlags . help ) {
X  		if ( HMGetHelpMenuHandle ( & helpMenu ) ) {
X***************
X*** 667,672 ****
X--- 697,706 ----
X  {
X  	int i ;
X  
X+ 	Rect scr = (*GetGrayRgn())->rgnBBox;
X+ 	small_screen = scr.bottom - scr.top <=	9*40 ||
X+ 				   scr.bottom - scr.top <= 12*40 && flags.large_font;
X+ 
X  	InitRes ( ) ;
X  
X  	theWindows = ( NhWindow * ) NewPtr ( NUM_MACWINDOWS *
X***************
X*** 688,698 ****
X      putstr(BASE_WINDOW, 0,
X  	  "         By Stichting Mathematisch Centrum and M. Stephenson.");
X      putstr(BASE_WINDOW, 0, "         See license for details.");
X!     putstr(BASE_WINDOW, 0, "  ");
X      display_nhwindow(BASE_WINDOW, FALSE);
X  
X  	flags . window_inited = 1 ;
X  	DimMenuBar ( ) ;
X  }
X  
X  
X--- 722,733 ----
X      putstr(BASE_WINDOW, 0,
X  	  "         By Stichting Mathematisch Centrum and M. Stephenson.");
X      putstr(BASE_WINDOW, 0, "         See license for details.");
X!     putstr(BASE_WINDOW, 0, "");
X      display_nhwindow(BASE_WINDOW, FALSE);
X  
X  	flags . window_inited = 1 ;
X  	DimMenuBar ( ) ;
X+ 	normal_font ( ) ;
X  }
X  
X  
X***************
X*** 720,726 ****
X  	Rect r2 = theWindow -> portRect ;
X  	Rect r = r2 ;
X  	Boolean vis ;
X! 	short val ;
X  
X  	if ( ! aWin -> scrollBar ) {
X  		return ;
X--- 755,761 ----
X  	Rect r2 = theWindow -> portRect ;
X  	Rect r = r2 ;
X  	Boolean vis ;
X! 	short val , lin ;
X  
X  	if ( ! aWin -> scrollBar ) {
X  		return ;
X***************
X*** 730,738 ****
X  	r2 . bottom -= SBARHEIGHT ;
X  	r2 . right += 1 ;
X  	r2 . top -= 1 ;
X! 	MoveControl ( aWin -> scrollBar , r2 . left , r2 . top ) ;
X! 	SizeControl ( aWin -> scrollBar , r2 . right - r2 . left ,
X! 		r2 . bottom - r2 . top ) ;
X  	vis = ( r2 . bottom > r2 . top + 50 ) ;
X  	if ( vis && ! ( * aWin -> scrollBar ) -> contrlVis ) {
X  		ShowControl ( aWin -> scrollBar ) ;
X--- 765,777 ----
X  	r2 . bottom -= SBARHEIGHT ;
X  	r2 . right += 1 ;
X  	r2 . top -= 1 ;
X! 	if ( ( * aWin -> scrollBar ) -> contrlRect . top  != r2 . top ||
X! 		 ( * aWin -> scrollBar ) -> contrlRect . left != r2 . left )
X! 		MoveControl ( aWin -> scrollBar , r2 . left , r2 . top ) ;
X! 	if ( ( * aWin -> scrollBar ) -> contrlRect . bottom != r2 . bottom ||
X! 		 ( * aWin -> scrollBar ) -> contrlRect . right  != r2 . right )
X! 		SizeControl ( aWin -> scrollBar , r2 . right  - r2 . left ,
X! 										  r2 . bottom - r2 . top ) ;
X  	vis = ( r2 . bottom > r2 . top + 50 ) ;
X  	if ( vis && ! ( * aWin -> scrollBar ) -> contrlVis ) {
X  		ShowControl ( aWin -> scrollBar ) ;
X***************
X*** 739,747 ****
X  	} else if ( ! vis && ( * aWin -> scrollBar ) -> contrlVis ) {
X  		HideControl ( aWin -> scrollBar ) ;
X  	}
X! 	if ( aWin -> lin ) {
X! 		short max = aWin -> lin - ( r . bottom - r . top ) / aWin ->
X  			charHeight ;
X  		if ( max < 0 ) max = 0 ;
X  		SetCtlMax ( aWin -> scrollBar , max ) ;
X  		if ( max ) HiliteControl ( aWin -> scrollBar , 0 ) ;
X--- 778,794 ----
X  	} else if ( ! vis && ( * aWin -> scrollBar ) -> contrlVis ) {
X  		HideControl ( aWin -> scrollBar ) ;
X  	}
X! 	lin = aWin -> lin;
X! 	if ( aWin == theWindows + WIN_MESSAGE ) {
X! 		short min ;
X! 		r . bottom -= SBARHEIGHT + 1 ;
X! 		min = aWin -> save_lin + ( r . bottom - r . top ) / aWin ->
X  			charHeight ;
X+ 		if ( lin < min )
X+ 			lin = min ;
X+ 	}
X+ 	if ( lin ) {
X+ 		short max = lin - ( r . bottom - r . top ) / aWin -> charHeight ;
X  		if ( max < 0 ) max = 0 ;
X  		SetCtlMax ( aWin -> scrollBar , max ) ;
X  		if ( max ) HiliteControl ( aWin -> scrollBar , 0 ) ;
X***************
X*** 775,780 ****
X--- 822,828 ----
X  mac_clear_nhwindow ( winid win )
X  {
X  	long l ;
X+ 	Rect r ;
X  	register char * start , * stop ;
X  	WindowPtr theWindow ;
X  	NhWindow * aWin = & theWindows [ win ] ;
X***************
X*** 791,797 ****
X  		return ;
X  	}
X  	SetPort ( theWindow ) ;
X! 	InvalRect ( & ( theWindow -> portRect ) ) ;
X  	switch ( ( ( WindowPeek ) theWindow ) -> windowKind - WIN_BASE_KIND ) {
X  	case NHW_MAP :
X  		stop = ( char * ) ( ( MapData * ) ( * aWin -> windowText ) )
X--- 839,850 ----
X  		return ;
X  	}
X  	SetPort ( theWindow ) ;
X! 	r = theWindow -> portRect ;
X! 	if ( aWin -> scrollBar )
X! 		r . right -= SBARWIDTH + 1 ;
X! 	if ( aWin == theWindows + WIN_MESSAGE )
X! 		r . bottom -= SBARHEIGHT + 1 ;
X! 	InvalRect ( & r ) ;
X  	switch ( ( ( WindowPeek ) theWindow ) -> windowKind - WIN_BASE_KIND ) {
X  	case NHW_MAP :
X  		stop = ( char * ) ( ( MapData * ) ( * aWin -> windowText ) )
X***************
X*** 806,836 ****
X  		while ( start > stop ) * -- start = CHAR_BLANK ;
X  		break ;
X  	case NHW_MESSAGE :
X! 		l = GetHandleSize ( aWin -> windowText ) ;
X! 		if ( l > TEXT_BLOCK * 2 ) {
X! 			BlockMove ( * aWin -> windowText + TEXT_BLOCK ,
X! 				* aWin -> windowText , l - TEXT_BLOCK ) ;
X! 			SetHandleSize ( aWin -> windowText , l - TEXT_BLOCK ) ;
X! 			aWin -> windowTextLen -= TEXT_BLOCK ;
X! 			if ( aWin -> windowTextLen < 0 ) {
X! 				aWin -> windowTextLen = 0 ;
X! 			}
X  		}
X! #if 1
X! 		aWin->textBase = aWin->windowTextLen;
X! #else
X! 		stop = * aWin -> windowText ;
X! 		start = stop + aWin -> windowTextLen - 1 ;
X! 		while ( -- start > stop ) {
X! 			if ( * start == CHAR_CR || * start == CHAR_LF )
X! 				break ;
X  		}
X! 		if ( start > stop ) {
X! 			aWin -> textBase = start - stop + 1 ;
X! 		} else {
X! 			aWin -> textBase = 0L ;
X  		}
X- #endif
X  		break ;
X  	default :
X  		SetHandleSize ( aWin -> windowText , TEXT_BLOCK ) ;
X--- 859,882 ----
X  		while ( start > stop ) * -- start = CHAR_BLANK ;
X  		break ;
X  	case NHW_MESSAGE :
X! 		l = 0;
X! 		while (aWin->lin > flags.msg_history) {
X! 			const char cr = CHAR_CR;
X! 			l = Munger(aWin->windowText, l, &cr, 1, nil, 0) + 1;
X! 			--aWin->lin;
X  		}
X! 		if (l) {
X! 			aWin->windowTextLen -= l;
X! 			BlockMove(*aWin->windowText + l, *aWin->windowText, aWin->windowTextLen);
X  		}
X! 		aWin->last_more_lin = aWin->lin;
X! 		aWin->save_lin		= aWin->lin;
X! 		aWin->scrollPos = aWin->lin ? aWin->lin - 1 : 0;
X! 		if (aWin->scrollBar) {
X! 			SetCtlMax  (aWin->scrollBar, aWin->lin);
X! 			SetCtlValue(aWin->scrollBar, aWin->scrollPos);
X! 			InvalScrollBar(aWin);
X  		}
X  		break ;
X  	default :
X  		SetHandleSize ( aWin -> windowText , TEXT_BLOCK ) ;
X***************
X*** 838,844 ****
X  		aWin -> lin = 0 ;
X  		aWin -> wid = 0 ;
X  		aWin -> scrollPos = 0 ;
X- 		aWin -> textBase = 0L ;
X  		if ( aWin -> scrollBar ) {
X  			SetCtlMax ( aWin -> scrollBar , 0 ) ;
X  			InvalScrollBar ( aWin ) ;
X--- 884,889 ----
X***************
X*** 853,859 ****
X  
X  Boolean
X  ClosingWindowChar(const int c) {
X! 	return  c == CHAR_ESC || c == CHAR_BLANK || c == CHAR_LF || c == CHAR_CR ;
X  }
X  
X  
X--- 898,905 ----
X  
X  Boolean
X  ClosingWindowChar(const int c) {
X! 	return  c == CHAR_ESC || c == CHAR_BLANK || c == CHAR_LF || c == CHAR_CR ||
X! 			c == 'q' ;
X  }
X  
X  
X***************
X*** 884,889 ****
X--- 930,938 ----
X  {
X  	if (!top_line || in_topl_mode())
X  		Debugger();
X+ 
X+ 	putstr(WIN_MESSAGE, ATR_BOLD, query);
X+ 
X  	(*top_line)->viewRect.left = 0;
X  
X  	topl_query_len = strlen(query);
X***************
X*** 893,899 ****
X  	TECalText(top_line);
X  
X  	display_nhwindow(WIN_MESSAGE, FALSE);
X- 	putstr(WIN_MESSAGE, ATR_BOLD, query);
X  }
X  
X  
X--- 942,947 ----
X***************
X*** 902,912 ****
X  {
X  	int ans_len = (*top_line)->teLength - topl_query_len;
X  	NhWindow *aWin = theWindows + WIN_MESSAGE;
X- 	char tmp[3] = "  ";
X  
X  	if (!in_topl_mode())
X  		Debugger();
X- 	(*top_line)->viewRect.left += 10000;
X  
X  	BlockMove(*(*top_line)->hText + topl_query_len, answer, ans_len);
X  	answer[ans_len] = '\0';
X--- 950,958 ----
X***************
X*** 916,926 ****
X  		-- aWin -> windowTextLen ;
X  		-- aWin -> lin ;
X  	}
X! 	if (strlen(answer) <= 1) {
X! 		if (answer[0]) tmp[0] = answer[0];
X! 		putstr(WIN_MESSAGE, ATR_BOLD, tmp);
X! 	} else
X! 		putstr(WIN_MESSAGE, ATR_BOLD, answer);
X  }
X  
X  /*
X--- 962,970 ----
X  		-- aWin -> windowTextLen ;
X  		-- aWin -> lin ;
X  	}
X! 	putstr(WIN_MESSAGE, ATR_BOLD, answer);
X! 
X! 	(*top_line)->viewRect.left += 10000;
X  }
X  
X  /*
X***************
X*** 1044,1054 ****
X  	int r_len, r_len1;
X  
X  	if (!resp) {
X! 		static char any_str[2] = { CHAR_ANY, '\0' };
X  		resp = any_str;
X  		def = CHAR_ANY;
X  	}
X  
X  	r_len1 = strlen(resp);
X  	r_len  = strlen(topl_resp);
X  	if (r_len < r_len1)
X--- 1088,1099 ----
X  	int r_len, r_len1;
X  
X  	if (!resp) {
X! 		const char any_str[2] = { CHAR_ANY, '\0' };
X  		resp = any_str;
X  		def = CHAR_ANY;
X  	}
X  
X+ 	SetPort(theWindows[WIN_MESSAGE].theWindow);
X  	r_len1 = strlen(resp);
X  	r_len  = strlen(topl_resp);
X  	if (r_len < r_len1)
X***************
X*** 1123,1128 ****
X--- 1168,1206 ----
X  }
X  
X  
X+ void
X+ adjust_window_pos(NhWindow *aWin, WindowPtr theWindow, short w)
X+ {
X+ 	const Rect scr_r   = (*GetGrayRgn())->rgnBBox,
X+ 			   win_ind = { 20, 2, 3, 3 };
X+ 	const short	min_w = theWindow->portRect.right - theWindow->portRect.left,
X+ 				max_w = scr_r.right - scr_r.left - win_ind.left - win_ind.right;
X+ 	Point pos;
X+ 	short h = aWin->lin * aWin->charHeight, max_h;
X+ 
X+ 	SetPort(theWindow);
X+ 	if (!RetrieveWinPos(theWindow, &pos.v, &pos.h)) {
X+ 		pos.v = theWindow->portRect.top;
X+ 		pos.h = theWindow->portRect.left;
X+ 		LocalToGlobal(&pos);
X+ 	}
X+ 
X+ 	max_h = full_screen ? scr_r.bottom - win_ind.bottom - scr_r.top - win_ind.top
X+ 						: scr_r.bottom - win_ind.bottom - pos.v;
X+ 	if (h > max_h	  ) h = max_h;
X+ 	if (h < MIN_HEIGHT) h = MIN_HEIGHT;
X+ 	if (w < min_w	  ) w = min_w;
X+ 	if (w > max_w	  ) w = max_w;
X+ 	SizeWindow(theWindow, w, h, true);
X+ 
X+ 	if (pos.v + h + win_ind.bottom > scr_r.bottom)
X+ 		pos.v = scr_r.bottom - h - win_ind.bottom;
X+ 	if (pos.h + w + win_ind.right  > scr_r.right)
X+ 		pos.h = scr_r.right	 - w - win_ind.right;
X+ 	MoveWindow(theWindow, pos.h, pos.v, false);
X+ }
X+ 
X+ 
X  /*
X   * display/select/update the window.
X   * If f is true, this window should be "modal" - don't return
X***************
X*** 1145,1213 ****
X  	}
X  
X  	if ( f && inSelect == WIN_ERR && ( win == BASE_WINDOW || win == WIN_MESSAGE ) ) {
X! 		if ( win == WIN_MESSAGE )
X  			topl_set_resp ( NULL , 0 ) ;
X! 		/* The following piece of code prevents the "-- More --" prompt to be on a new
X! 		   line by itself.  I comment it out because the result looks ugly to me. */
X! #ifdef 0
X! 		if ( aWin -> windowTextLen > 0 &&
X! 			 ( * aWin -> windowText ) [ aWin -> windowTextLen - 1 ] == CHAR_CR ) {
X! 			-- aWin -> windowTextLen ;
X! 			-- aWin -> lin ;
X  		}
X! #endif
X! 		putstr ( win , ATR_INVERSE , "-- More --" ) ;
X  	}
X  
X! 	if ( ! ( ( WindowPeek ) theWindow ) -> visible ) {
X! 		const Rect scr_r   = (*GetGrayRgn())->rgnBBox,
X! 				   win_ind = { 20, 2, 3, 3 };
X! 		const Point scr_sz = { scr_r.bottom - scr_r.top, scr_r.right - scr_r.left },
X! 					wp_sz  = { theWindow->portRect.bottom - theWindow->portRect.top,
X! 							   theWindow->portRect.right  - theWindow->portRect.left };
X! 		const short max_h = scr_sz.v - win_ind.top	- win_ind.bottom,
X! 					max_w = scr_sz.h - win_ind.left - win_ind.right;
X! 		const char cr = CHAR_CR;
X  
X! 		long line_start = 0, line_end;
X! 		short w = wp_sz.h,
X! 			  h = full_screen ? aWin->lin * aWin->charHeight : wp_sz.v;
X! 		Point pos = { theWindow->portRect.top, theWindow->portRect.left };
X! 		SetPort(theWindow);
X! 		LocalToGlobal(&pos);
X  
X! 		HLock(aWin->windowText);
X! 		while (line_start < aWin->windowTextLen) {
X! 			short line_w;
X! 			line_end = Munger(aWin->windowText, line_start, &cr, 1, nil, 0);
X! 			if (line_end < 0)
X! 				line_end = aWin->windowTextLen;
X! 			line_w = TextWidth(*aWin->windowText, line_start, line_end - line_start) +
X! 					 (SBARWIDTH + 2);
X! 			if (w < line_w)
X! 				w = line_w;
X! 			line_start = line_end + 1;
X! 		}
X! 		HUnlock(aWin->windowText);
X! 
X! 		if (h > max_h) h = max_h;
X! 		if (w > max_w) w = max_w;
X! 		SizeWindow(theWindow, w, h, FALSE);
X! 
X! 		if ( ! ( ( WindowPeek ) theWindow ) -> visible ) {
X! 			short top , left ;
X! 			if ( ! RetrieveWinPos ( theWindow , & top , & left ) ) {
X! 				if (pos.v + h + win_ind.bottom > scr_r.bottom)
X! 					pos.v = scr_r.bottom - h - win_ind.bottom;
X! 				if (pos.h + w + win_ind.right  > scr_r.right)
X! 					pos.h = scr_r.right	 - w - win_ind.right;
X! 				top = pos . v ;
X! 				left = pos . h ;
X  			}
X! 			MoveWindow(theWindow, left, top, FALSE);
X  		}
X  
X! 		SelectWindow ( theWindow ) ;
X  		ShowWindow ( theWindow ) ;
X  	}
X  
X--- 1223,1266 ----
X  	}
X  
X  	if ( f && inSelect == WIN_ERR && ( win == BASE_WINDOW || win == WIN_MESSAGE ) ) {
X! 		if ( win == WIN_MESSAGE ) {
X  			topl_set_resp ( NULL , 0 ) ;
X! 			if ( aWin -> windowTextLen > 0 &&
X! 				 ( * aWin -> windowText ) [ aWin -> windowTextLen - 1 ] == CHAR_CR ) {
X! 				-- aWin -> windowTextLen ;
X! 				-- aWin -> lin ;
X! 			}
X  		}
X! 		putstr ( win , flags . standout ? ATR_INVERSE : ATR_NONE , " --More--" ) ;
X  	}
X  
X! 	if ( ! ( ( WindowPeek ) theWindow ) -> visible || full_screen ) {
X  
X! 		int kind = ((WindowPeek)theWindow)->windowKind - WIN_BASE_KIND;
X! 		if (kind == NHW_TEXT || kind == NHW_MENU) {
X! 			const char cr = CHAR_CR;
X! 			short w = 0;
X! 			long line_start = 0;
X! 			HLock(aWin->windowText);
X  
X! 			while (line_start < aWin->windowTextLen) {
X! 				long line_end;
X! 				short line_w;
X! 				line_end = Munger(aWin->windowText, line_start, &cr, 1, nil, 0);
X! 				if (line_end < 0)
X! 					line_end = aWin->windowTextLen;
X! 				line_w = TextWidth(*aWin->windowText, line_start, line_end - line_start);
X! 				if (w < line_w)
X! 					w = line_w;
X! 				line_start = line_end + 1;
X  			}
X! 			HUnlock(aWin->windowText);
X! 
X! 			adjust_window_pos(aWin, theWindow, w + (SBARWIDTH+2));
X  		}
X  
X! 		if ( ! small_screen || win != WIN_MESSAGE || f )
X! 			SelectWindow ( theWindow ) ;
X  		ShowWindow ( theWindow ) ;
X  	}
X  
X***************
X*** 1227,1233 ****
X  
X  		if ( win == WIN_MESSAGE )
X  			topl_set_resp ( "" , '\0' ) ;
X! 		else
X  			HideWindow ( theWindow ) ;
X  
X  	} else {
X--- 1280,1286 ----
X  
X  		if ( win == WIN_MESSAGE )
X  			topl_set_resp ( "" , '\0' ) ;
X! 		else if ( win != WIN_MAP && win != WIN_STATUS )
X  			HideWindow ( theWindow ) ;
X  
X  	} else {
X***************
X*** 1325,1334 ****
X  void
X  GeneralKey ( EventRecord * theEvent , WindowPtr theWindow )
X  {
X- 	int i ;
X- 
X  	trans_num_keys ( theEvent ) ;
X- 
X  	addToKeyQueue ( topl_resp_key ( theEvent -> message & 0xff ) , 1 ) ;
X  }
X  
X--- 1378,1384 ----
X***************
X*** 1426,1431 ****
X--- 1476,1483 ----
X  		}
X  		++r_idx;
X  	}
X+ 
X+ 	macClickText(theEvent, theWindow);
X  }
X  
X  
X***************
X*** 1441,1472 ****
X  static void
X  macClickMap ( EventRecord * theEvent , WindowPtr theWindow )
X  {
X! 	if ( ! theEvent || ! theWindow ) {
X! 		Debugger ( ) ;
X! 	}
X! 	{
X! 		NhWindow * nhw = ( NhWindow * ) GetWRefCon ( theWindow ) ;
X! 		Point where ;
X! 		short posX , posY ;
X! 		short sector ;
X! 		char theDirectionChar [ 18 ] = {
X! 			' ' , 'k' , 'u' , 'l' , 'n' , 'j' , 'b' , 'h' , 'y' ,
X! 			'o' , 'K' , 'U' , 'L' , 'N' , 'J' , 'B' , 'H' , 'Y' ,
X! 		} ;
X  
X! 		where = theEvent -> where ;
X! 		GlobalToLocal ( & where ) ;
X! 		posX = where . h / nhw -> charWidth ;
X! 		posY = where . v / nhw -> charHeight ;
X! 
X! 	/* 0 is ON, 1 is top, then clockwise */
X! 		sector = clickSector ( u . ux , u . uy , posX , posY ) ;
X! 		if ( theEvent -> modifiers & shiftKey ) {
X! 			sector += 9 ;
X! 		}
X! 		addToKeyQueue ( theDirectionChar [ sector ] , 0 ) ;
X! 
X! 		gClickedToMove = 1 ;
X  	}
X  }
X  
X--- 1493,1516 ----
X  static void
X  macClickMap ( EventRecord * theEvent , WindowPtr theWindow )
X  {
X! 	int shift_down = theEvent->modifiers & shiftKey;
X! 	NhWindow *nhw = (NhWindow *)GetWRefCon(theWindow);
X! 	Point where = theEvent->where;
X! 		GlobalToLocal(&where);
X! 		where.h /= nhw->charWidth;
X! 		where.v /= nhw->charHeight;
X! 	clicked_mod = shift_down ? CLICK_2 : CLICK_1;
X  
X! 	if (strchr(topl_resp, click_to_cmd(where.h, where.v, clicked_mod)))
X! 		nhbell();
X! 	else {
X! 		if (cursor_locked)
X! 			while (WaitMouseUp())
X! 				SystemTask();
X! 		else if (!shift_down)
X! 			gNextClickRepeat = TickCount() + *(short *)KeyThresh;
X! 		gClickedToMove = TRUE;
X! 		clicked_pos = where;
X  	}
X  }
X  
X***************
X*** 1495,1508 ****
X  	SetCtlValue ( theBar , now - amtToScroll ) ;
X  	winToScroll -> scrollPos = now - amtToScroll ;
X  	r = winToScroll -> theWindow -> portRect ;
X! 	r . right -= 15 ;
X  	ScrollRect ( & r , 0 , amtToScroll * winToScroll -> charHeight , rgn ) ;
X  	if ( rgn ) {
X  		InvalRgn ( rgn ) ;
X- 		r . top = r . bottom - 16 ;
X- 		r . left = r . right ;
X- 		r . right += 15 ;
X- 		InvalRect ( & r ) ;
X  		BeginUpdate ( winToScroll -> theWindow ) ;
X  	}
X  	winToScroll -> updateFunc  ( & fake , winToScroll -> theWindow ) ;
X--- 1539,1550 ----
X  	SetCtlValue ( theBar , now - amtToScroll ) ;
X  	winToScroll -> scrollPos = now - amtToScroll ;
X  	r = winToScroll -> theWindow -> portRect ;
X! 	r . right -= SBARWIDTH ;
X! 	if ( winToScroll == theWindows + WIN_MESSAGE )
X! 		r . bottom -= SBARHEIGHT + 1 ;
X  	ScrollRect ( & r , 0 , amtToScroll * winToScroll -> charHeight , rgn ) ;
X  	if ( rgn ) {
X  		InvalRgn ( rgn ) ;
X  		BeginUpdate ( winToScroll -> theWindow ) ;
X  	}
X  	winToScroll -> updateFunc  ( & fake , winToScroll -> theWindow ) ;
X***************
X*** 1535,1548 ****
X  	SetCtlValue ( theBar , now + amtToScroll ) ;
X  	winToScroll -> scrollPos = now + amtToScroll ;
X  	r = winToScroll -> theWindow -> portRect ;
X! 	r . right -= 15 ;
X  	ScrollRect ( & r , 0 , - amtToScroll * winToScroll -> charHeight , rgn ) ; 
X  	if ( rgn ) {
X  		InvalRgn ( rgn ) ;
X- 		r . top = r . bottom - 16 ;
X- 		r . left = r . right ;
X- 		r . right += 15 ;
X- 		InvalRect ( & r ) ;
X  		BeginUpdate ( winToScroll -> theWindow ) ;
X  	}
X  	winToScroll -> updateFunc  ( & fake , winToScroll -> theWindow ) ;
X--- 1577,1588 ----
X  	SetCtlValue ( theBar , now + amtToScroll ) ;
X  	winToScroll -> scrollPos = now + amtToScroll ;
X  	r = winToScroll -> theWindow -> portRect ;
X! 	r . right -= SBARWIDTH ;
X! 	if ( winToScroll == theWindows + WIN_MESSAGE )
X! 		r . bottom -= SBARHEIGHT + 1 ;
X  	ScrollRect ( & r , 0 , - amtToScroll * winToScroll -> charHeight , rgn ) ; 
X  	if ( rgn ) {
X  		InvalRgn ( rgn ) ;
X  		BeginUpdate ( winToScroll -> theWindow ) ;
X  	}
X  	winToScroll -> updateFunc  ( & fake , winToScroll -> theWindow ) ;
X***************
X*** 1615,1620 ****
X--- 1655,1674 ----
X  }
X  
X  
X+ int
X+ mac_doprev_message(void)
X+ {
X+ 	if (WIN_MESSAGE) {
X+ 		display_nhwindow(WIN_MESSAGE, FALSE);
X+ 		amtToScroll = 1;
X+ 		winToScroll = &theWindows[WIN_MESSAGE];
X+ 		SetPort(winToScroll->theWindow);
X+ 		Up(winToScroll->scrollBar, inUpButton);
X+ 	}	
X+ 	return 0 ;
X+ }
X+ 
X+ 
X  static void
X  macClickMenu ( EventRecord * theEvent , WindowPtr theWindow )
X  {
X***************
X*** 1742,1747 ****
X--- 1796,1802 ----
X  
X  	GetClip(org_clip);
X  
X+ 	DrawControls(theWindow);
X  	DrawGrowIcon(theWindow);
X  
X  	l = 0;
X***************
X*** 1794,1808 ****
X  	/* Clip to the portrect - scrollbar/growicon *before* adjusting the rect
X  		to be larger than the size of the window (!) */
X  	RectRgn(clip, &r);
X  	if ( r . right < MIN_RIGHT )
X  		r . right = MIN_RIGHT ;
X  
X  	if (in_topl_mode()) {
X  		RgnHandle topl_rgn = NewRgn();
X  		Rect topl_r = r;
X! 		for (l = aWin->windowTextLen - 1; --l >= aWin->textBase; )
X! 			if ((*aWin->windowText)[l] == CHAR_CR)
X! 				topl_r.top += aWin->charHeight;
X  		l = (*top_line)->destRect.right - (*top_line)->destRect.left;
X  		(*top_line)->viewRect = topl_r;
X  		(*top_line)->destRect = topl_r;
X--- 1849,1880 ----
X  	/* Clip to the portrect - scrollbar/growicon *before* adjusting the rect
X  		to be larger than the size of the window (!) */
X  	RectRgn(clip, &r);
X+ 	SectRgn(clip, org_clip, clip);
X  	if ( r . right < MIN_RIGHT )
X  		r . right = MIN_RIGHT ;
X+ 	r . top -= aWin -> scrollPos * aWin -> charHeight ;
X  
X+ #if 0
X+ 	/* If you enable this band of code (and disable the next band), you will get
X+ 	   fewer flickers but a slower performance while drawing the dot line. */
X+ 	{	RgnHandle dotl_rgn = NewRgn();
X+ 		Rect dotl;
X+ 		dotl.left	= r.left;
X+ 		dotl.right	= r.right;
X+ 		dotl.bottom = r.top + aWin->save_lin * aWin->charHeight;
X+ 		dotl.top	= dotl.bottom - 1;
X+ 		FillRect(&dotl, &qd.gray);
X+ 		RectRgn(dotl_rgn, &dotl);
X+ 		DiffRgn(clip, dotl_rgn, clip);
X+ 		DisposeRgn(dotl_rgn);
X+ 		SetClip(clip);
X+ 	}
X+ #endif
X+ 
X  	if (in_topl_mode()) {
X  		RgnHandle topl_rgn = NewRgn();
X  		Rect topl_r = r;
X! 		topl_r.top += (aWin->lin - 1) * aWin->charHeight;
X  		l = (*top_line)->destRect.right - (*top_line)->destRect.left;
X  		(*top_line)->viewRect = topl_r;
X  		(*top_line)->destRect = topl_r;
X***************
X*** 1812,1830 ****
X  		RectRgn(topl_rgn, &topl_r);
X  		DiffRgn(clip, topl_rgn, clip);
X  		DisposeRgn(topl_rgn);
X  	}
X  
X- 	SectRgn(clip, org_clip, clip);
X- 	SetClip(clip);
X  	DisposeRgn(clip);
X  
X  	TextFont ( aWin -> fontNum ) ;
X  	TextSize ( aWin -> fontSize ) ;
X  	HLock ( aWin -> windowText ) ;
X! 	TextBox ( * ( aWin -> windowText ) + aWin -> textBase , aWin ->
X! 		windowTextLen - aWin -> textBase , & r , teJustLeft ) ;
X  	HUnlock ( aWin -> windowText ) ;
X  
X  	SetClip(org_clip);
X  	DisposeRgn(org_clip);
X  }
X--- 1884,1906 ----
X  		RectRgn(topl_rgn, &topl_r);
X  		DiffRgn(clip, topl_rgn, clip);
X  		DisposeRgn(topl_rgn);
X+ 		SetClip(clip);
X  	}
X  
X  	DisposeRgn(clip);
X  
X  	TextFont ( aWin -> fontNum ) ;
X  	TextSize ( aWin -> fontSize ) ;
X  	HLock ( aWin -> windowText ) ;
X! 	TextBox ( * aWin -> windowText , aWin -> windowTextLen , & r , teJustLeft ) ;
X  	HUnlock ( aWin -> windowText ) ;
X  
X+ #if 1
X+ 	r.bottom = r.top + aWin->save_lin * aWin->charHeight;
X+ 	r.top	 = r.bottom - 1;
X+ 	FillRect(&r, &qd.gray);
X+ #endif
X+ 
X  	SetClip(org_clip);
X  	DisposeRgn(org_clip);
X  }
X***************
X*** 1941,1948 ****
X  		r . right = MIN_RIGHT ;
X  	r . top -= aWin -> scrollPos * aWin -> charHeight ;
X  	HLock ( aWin -> windowText ) ;
X! 	TextBox ( * ( aWin -> windowText ) + aWin -> textBase , aWin ->
X! 		windowTextLen - aWin -> textBase , & r , teJustLeft ) ;
X  	HUnlock ( aWin -> windowText ) ;
X  	if ( h ) {
X  		SetClip ( h ) ;
X--- 2017,2023 ----
X  		r . right = MIN_RIGHT ;
X  	r . top -= aWin -> scrollPos * aWin -> charHeight ;
X  	HLock ( aWin -> windowText ) ;
X! 	TextBox ( * aWin -> windowText , aWin -> windowTextLen , & r , teJustLeft ) ;
X  	HUnlock ( aWin -> windowText ) ;
X  	if ( h ) {
X  		SetClip ( h ) ;
X***************
X*** 1989,1996 ****
X  	r . top -= aWin -> scrollPos * aWin -> charHeight ;
X  	r . right -= SBARWIDTH;
X  	HLock ( aWin -> windowText ) ;
X! 	TextBox ( * ( aWin -> windowText ) + aWin -> textBase , aWin ->
X! 		windowTextLen - aWin -> textBase , & r , teJustLeft ) ;
X  	HUnlock ( aWin -> windowText ) ;
X  	draw_growicon_vert_only(theWindow);
X  	if ( h ) {
X--- 2064,2070 ----
X  	r . top -= aWin -> scrollPos * aWin -> charHeight ;
X  	r . right -= SBARWIDTH;
X  	HLock ( aWin -> windowText ) ;
X! 	TextBox ( * aWin -> windowText , aWin -> windowTextLen , & r , teJustLeft ) ;
X  	HUnlock ( aWin -> windowText ) ;
X  	draw_growicon_vert_only(theWindow);
X  	if ( h ) {
X***************
X*** 2037,2042 ****
X--- 2111,2117 ----
X  macCursorMap ( EventRecord * theEvent , WindowPtr theWindow , RgnHandle mouseRgn )
X  {
X  	Point where ;
X+ 	char * dir_bas , * dir ;
X  	CursHandle ch ;
X  	GrafPtr gp ;
X  	NhWindow * nhw = ( NhWindow * ) GetWRefCon ( theWindow ) ;
X***************
X*** 2047,2059 ****
X  
X  	where = theEvent -> where ;
X  	GlobalToLocal ( & where ) ;
X! 	ch = GetCursor ( 512 + clickSector ( u . ux , u . uy , where . h / nhw -> charWidth ,
X! 		where . v / nhw -> charHeight ) ) ;
X  	if ( ch ) {
X  
X  		HLock ( ( Handle ) ch ) ;
X  		SetCursor ( * ch ) ;
X! 		ReleaseResource ( ( Handle ) ch ) ;
X  
X  	} else {
X  
X--- 2122,2142 ----
X  
X  	where = theEvent -> where ;
X  	GlobalToLocal ( & where ) ;
X! 
X! 	if ( cursor_locked )
X! 		dir = NULL ;
X! 	else {
X! 		dir_bas = flags . num_pad ? ndir : sdir ;
X! 		dir = strchr ( dir_bas , click_to_cmd ( where . h / nhw -> charWidth ,
X! 												where . v / nhw -> charHeight ,
X! 												CLICK_1 ) ) ;
X! 	}
X! 	ch = GetCursor ( dir ? dir - dir_bas + 513 : 512 ) ;
X  	if ( ch ) {
X  
X  		HLock ( ( Handle ) ch ) ;
X  		SetCursor ( * ch ) ;
X! 		HUnlock ( ( Handle ) ch ) ;
X  
X  	} else {
X  
X***************
X*** 2226,2231 ****
X--- 2309,2316 ----
X  			InitCursor ( ) ;
X  			SetRect ( & r , 80 , 2 * aWin -> charHeight + 1 , r . right ,
X  				r . bottom ) ;
X+ 			if ( aWin == theWindows + WIN_MESSAGE )
X+ 				r . top += SBARHEIGHT + 1 ;
X  			l = GrowWindow ( theWindow , theEvent -> where , & r ) ;
X  			SizeWindow ( theWindow , l & 0xffff , l >> 16 , FALSE ) ;
X  			SaveWindowSize ( theWindow ) ;
X***************
X*** 2347,2372 ****
X  			}
X  			FlushEvents ( keyDownMask , 0 ) ;
X  		}
X- 		/*
X- 		 * This somewhat elaborate hack is needed to make the menu
X- 		 * commands work right. They're also needed for fast typists.
X- 		 */
X- 		if ( keyQueue [ 0 ] && in_topl_mode() ) {
X- 			int i ;
X- 
X- 			theEvent -> what = keyDown ;
X- 			theEvent -> modifiers = 0 ;
X- 			theEvent -> message = keyQueue [ 0 ] ;
X- 
X- /* extract from key queue */
X- 			for ( i = 0 ; i < QUEUE_LEN - 1 ; i ++ ) {
X- 				keyQueue [ i ] = keyQueue [ i + 1 ] ;
X- 			}
X- 			keyQueue [ i ] = 0 ;
X- 			SetPort ( theWindows [ WIN_MESSAGE ] . theWindow ) ;
X- 			theWindows [ WIN_MESSAGE ] . keyFunc ( theEvent ,
X- 				theWindows [ WIN_MESSAGE ] . theWindow ) ;
X- 		}
X  		break ;
X  	}
X  }
X--- 2432,2437 ----
X***************
X*** 2380,2389 ****
X  	DisableItem ( appleMenu , 0 ) ;
X  	DisableItem ( fileMenu , 0 ) ;
X  	DisableItem ( editMenu , 0 ) ;
X! 	DisableItem ( extendMenu , 0 ) ;
X! 	DisableItem ( miscMenu , 0 ) ;
X! 	DisableItem ( commandsMenu , 0 ) ;
X  	DisableItem ( thingsMenu , 0 ) ;
X  	DrawMenuBar ( ) ;
X  }
X  
X--- 2445,2455 ----
X  	DisableItem ( appleMenu , 0 ) ;
X  	DisableItem ( fileMenu , 0 ) ;
X  	DisableItem ( editMenu , 0 ) ;
X! 	DisableItem ( actionMenu , 0 ) ;
X! 	DisableItem ( inventoryMenu , 0 ) ;
X  	DisableItem ( thingsMenu , 0 ) ;
X+ 	DisableItem ( extendedMenu , 0 ) ;
X+ 	DisableItem ( infoMenu , 0 ) ;
X  	DrawMenuBar ( ) ;
X  }
X  
X***************
X*** 2394,2403 ****
X  	EnableItem ( appleMenu , 0 ) ;
X  	EnableItem ( fileMenu , 0 ) ;
X  	EnableItem ( editMenu , 0 ) ;
X! 	EnableItem ( extendMenu , 0 ) ;
X! 	EnableItem ( miscMenu , 0 ) ;
X! 	EnableItem ( commandsMenu , 0 ) ;
X  	EnableItem ( thingsMenu , 0 ) ;
X  	DrawMenuBar ( ) ;
X  }
X  
X--- 2460,2470 ----
X  	EnableItem ( appleMenu , 0 ) ;
X  	EnableItem ( fileMenu , 0 ) ;
X  	EnableItem ( editMenu , 0 ) ;
X! 	EnableItem ( actionMenu , 0 ) ;
X! 	EnableItem ( inventoryMenu , 0 ) ;
X  	EnableItem ( thingsMenu , 0 ) ;
X+ 	EnableItem ( extendedMenu , 0 ) ;
X+ 	EnableItem ( infoMenu , 0 ) ;
X  	DrawMenuBar ( ) ;
X  }
X  
X***************
X*** 2408,2422 ****
X  {
X  	EventRecord anEvent ;
X  
X! 	if ( ( inSelect != WIN_ERR || ! flags . window_inited || in_topl_mode() ) &&
X! 		! mBarDimmed ) {
X! 		DimMenuBar ( ) ;
X! 		mBarDimmed = 1 ;
X! 	} else if ( inSelect == WIN_ERR && flags . window_inited && mBarDimmed &&
X! 				! in_topl_mode() ) {
X! 		UndimMenuBar ( ) ;
X! 		mBarDimmed = 0 ;
X! 	}
X  	/*
X  	 * We want to take care of keys in the buffer as fast as
X  	 * possible
X--- 2475,2489 ----
X  {
X  	EventRecord anEvent ;
X  
X! 	if ( ( inSelect == WIN_ERR && flags . window_inited && ! in_topl_mode ( ) )
X! 		 == mBarDimmed )
X! 		if ( mBarDimmed ) {
X! 			UndimMenuBar ( ) ;
X! 			mBarDimmed = 0 ;
X! 		} else {
X! 			DimMenuBar ( ) ;
X! 			mBarDimmed = 1 ;
X! 		}
X  	/*
X  	 * We want to take care of keys in the buffer as fast as
X  	 * possible
X***************
X*** 2447,2459 ****
X  {
X  	int ch ;
X  	register int i ;
X  
X  	wait_synch ( ) ;
X  
X! 	if ( flags . window_inited && ! theWindows [ WIN_MAP ] . cursorDrawn &&
X! 		theWindows [ WIN_MAP ] . theWindow ) {
X! 		SetPort ( theWindows [ WIN_MAP ] . theWindow ) ;
X! 		DrawMapCursor ( & theWindows [ WIN_MAP ] ) ;
X  	}
X  
X  	if ( ! keyQueue [ 0 ] ) {
X--- 2514,2532 ----
X  {
X  	int ch ;
X  	register int i ;
X+ 	NhWindow * nhw = flags . window_inited ? theWindows + WIN_MAP : nil ;
X  
X+ 	if ( theWindows ) {
X+ 		NhWindow * aWin = theWindows + WIN_MESSAGE ;
X+ 		if ( aWin )
X+ 			aWin -> last_more_lin = aWin -> lin ;
X+ 	}
X+ 
X  	wait_synch ( ) ;
X  
X! 	if ( nhw && ! nhw -> cursorDrawn && nhw -> theWindow ) {
X! 		SetPort ( nhw -> theWindow ) ;
X! 		DrawMapCursor ( nhw ) ;
X  	}
X  
X  	if ( ! keyQueue [ 0 ] ) {
X***************
X*** 2461,2469 ****
X  		static char warn = 0 ;
X  
X  		PurgeSpace ( & total , & contig ) ;
X! 		if ( contig < 64000L || total < 256000L ) {
X  			if ( ! warn ) {
X! 				DebugStr ( ( ConstStr255Param ) "\014Low Memory !" ) ;
X  				warn = 1 ;
X  			}
X  		} else {
X--- 2534,2542 ----
X  		static char warn = 0 ;
X  
X  		PurgeSpace ( & total , & contig ) ;
X! 		if ( contig < 25000L || total < 50000L ) {
X  			if ( ! warn ) {
X! 				pline ( "Low Memory!" ) ;
X  				warn = 1 ;
X  			}
X  		} else {
X***************
X*** 2473,2481 ****
X  
X  	do {
X  		doDawdle = ( in_topl_mode() ? GetCaretTime ( ) : 120L ) ;
X  		get_nh_event ( ) ;
X  		ch = keyQueue [ 0 ] ;
X! 	} while ( ! ch ) ;
X  
X  	if ( ! gClickedToMove ) {
X  		ObscureCursor ( ) ;
X--- 2546,2573 ----
X  
X  	do {
X  		doDawdle = ( in_topl_mode() ? GetCaretTime ( ) : 120L ) ;
X+ 
X+ 		if ( nhw ) {
X+ 			SetPort ( nhw -> theWindow ) ;
X+ 			if ( WaitMouseUp ( ) ) {
X+ 				unsigned long tick = TickCount ( ) ;
X+ 				if ( tick >= gNextClickRepeat ) {
X+ 					Point where ;
X+ 					GetMouse ( & where ) ;
X+ 					SetPt ( & clicked_pos , where . h / nhw -> charWidth ,
X+ 											where . v / nhw -> charHeight ) ;
X+ 					gClickedToMove = TRUE ;
X+ 					gNextClickRepeat = tick + * ( short * ) KeyRepThresh ;
X+ 				}
X+ 				if ( doDawdle > * ( short * ) KeyRepThresh )
X+ 					doDawdle = * ( short * ) KeyRepThresh ;
X+ 			} else
X+ 				gNextClickRepeat = 0xffffffff ;
X+ 		}
X+ 
X  		get_nh_event ( ) ;
X  		ch = keyQueue [ 0 ] ;
X! 	} while ( ! ch && ! gClickedToMove ) ;
X  
X  	if ( ! gClickedToMove ) {
X  		ObscureCursor ( ) ;
X***************
X*** 2536,2548 ****
X  	/* Here and in mac_raw_print_bold I assume that once theWindows got
X  	   allocated by mac_init_nhwindows we can safely do putstr on BASE_WINDOW,
X  	   even after mac_exit_nhwindows is called or flags.window_inited is reset
X! 	   to zero.  Is this assumption correct? */
X  	if ( theWindows ) {
X  
X  		ShowWindow ( theWindows [ BASE_WINDOW ] . theWindow ) ;
X  		SelectWindow ( theWindows [ BASE_WINDOW ] . theWindow ) ;
X  
X! 		putstr ( BASE_WINDOW , 0 , str ) ;
X  
X  	} else
X  		showerror ( str , NULL ) ;
X--- 2628,2644 ----
X  	/* Here and in mac_raw_print_bold I assume that once theWindows got
X  	   allocated by mac_init_nhwindows we can safely do putstr on BASE_WINDOW,
X  	   even after mac_exit_nhwindows is called or flags.window_inited is reset
X! 	   to zero.  Is this assumption correct?
X! 	   Also add a space or a bullet before each line to indicate the bold face
X! 	   before we really implement the text attributes */
X  	if ( theWindows ) {
X+ 		char lstr [ 200 ] = " " ;
X+ 		strcat ( lstr , str ) ;
X  
X  		ShowWindow ( theWindows [ BASE_WINDOW ] . theWindow ) ;
X  		SelectWindow ( theWindows [ BASE_WINDOW ] . theWindow ) ;
X  
X! 		putstr ( BASE_WINDOW , 0 , lstr ) ;
X  
X  	} else
X  		showerror ( str , NULL ) ;
X***************
X*** 2553,2563 ****
X  mac_raw_print_bold ( const char * str )
X  {
X  	if ( theWindows ) {
X  
X  		ShowWindow ( theWindows [ BASE_WINDOW ] . theWindow ) ;
X  		SelectWindow ( theWindows [ BASE_WINDOW ] . theWindow ) ;
X  
X! 		putstr ( BASE_WINDOW , ATR_BOLD , str ) ;
X  
X  	} else {
X  		nhbell ( ) ;
X--- 2649,2661 ----
X  mac_raw_print_bold ( const char * str )
X  {
X  	if ( theWindows ) {
X+ 		char lstr [ 200 ] = "\xA5"/*bullet*/ ;
X+ 		strcat ( lstr , str ) ;
X  
X  		ShowWindow ( theWindows [ BASE_WINDOW ] . theWindow ) ;
X  		SelectWindow ( theWindows [ BASE_WINDOW ] . theWindow ) ;
X  
X! 		putstr ( BASE_WINDOW , ATR_BOLD , lstr ) ;
X  
X  	} else {
X  		nhbell ( ) ;
X***************
X*** 2596,2602 ****
X  	Rect r ;
X  
X  	if ( in_putstr > 3 ) {
X! 		DebugStr ( ( ConstStr255Param ) "\012Recursion!" ) ;
X  		return ;
X  	}
X  	if ( win < 0 || win >= NUM_MACWINDOWS ) {
X--- 2694,2700 ----
X  	Rect r ;
X  
X  	if ( in_putstr > 3 ) {
X! 		DebugStr ( ( ConstStr255Param ) "\pRecursion!" ) ;
X  		return ;
X  	}
X  	if ( win < 0 || win >= NUM_MACWINDOWS ) {
X***************
X*** 2612,2642 ****
X  	in_putstr ++ ;
X  	kind = ( ( WindowPeek ) ( aWin -> theWindow ) ) -> windowKind -
X  		WIN_BASE_KIND ;
X  
X  	if ( kind == NHW_MAP || kind == NHW_STATUS ) {
X! 		short	h = ( NUM_COLS - aWin->cursor.h - strlen(str) );
X! 		/*
X! 		 * The "dungeon" window
X! 		 * putsym will call curs, so no updates necessary.
X! 		 */
X! 		while ( * str ) {
X! 			putsym ( win , aWin -> cursor . h , aWin -> cursor . v , * str ) ;
X! 			curs ( win , aWin -> cursor . h + 1 , aWin -> cursor . v ) ;
X! 			str ++ ;
X! 		}
X! 		h = (h < 0) ? 0 : h;
X! 		while( h-- ) {
X! 			putsym ( win , aWin -> cursor . h , aWin -> cursor . v , CHAR_BLANK ) ;
X! 			curs ( win , aWin -> cursor . h + 1 , aWin -> cursor . v ) ;
X! 		}
X  	} else {
X  		char * sr , * ds ;
X  		/*
X  		 * A "default" text window - uses TextBox
X  		 * We just add the text, without attributes for now
X  		 */
X  		len = GetHandleSize ( aWin -> windowText ) ;
X- 		slen = strlen ( str ) ;
X  		while ( aWin -> windowTextLen + slen + 1 > len ) {
X  			len = ( len > 2048 ) ? ( len + 2048 ) : ( len * 2 ) ;
X  			SetHandleSize ( aWin -> windowText , len ) ;
X--- 2710,2753 ----
X  	in_putstr ++ ;
X  	kind = ( ( WindowPeek ) ( aWin -> theWindow ) ) -> windowKind -
X  		WIN_BASE_KIND ;
X+ 	slen = strlen ( str ) ;
X  
X  	if ( kind == NHW_MAP || kind == NHW_STATUS ) {
X! 		char *row;
X! 		r.right	 = aWin->theWindow->portRect.right;
X! 		r.left	 = aWin->charWidth	* aWin->cursor.h;
X! 		r.bottom = aWin->charHeight *(aWin->cursor.v + 1);
X! 		r.top	 = r.bottom - aWin->charHeight;
X! 		EraseRect(&r);
X! 		MoveTo(r.left, r.bottom - aWin->leading);
X! 		DrawText(str, 0, slen);
X! 
X! 		if (slen > NUM_COLS - aWin->cursor.h)
X! 			slen = NUM_COLS - aWin->cursor.h;
X! 		row = &((MapData *)*aWin->windowText)->map[aWin->cursor.v][aWin->cursor.h];
X! 		strncpy(row, str, slen);
X! 		memset(row + slen, CHAR_BLANK, NUM_COLS - slen - aWin->cursor.h);
X! 		curs(win, NUM_COLS, aWin->cursor.v);
X! 
X  	} else {
X  		char * sr , * ds ;
X+ 
X+ 		r = aWin->theWindow->portRect;
X+ 		if (win && win == WIN_MESSAGE) {
X+ 			r.right  -= SBARWIDTH  + 1;
X+ 			r.bottom -= SBARHEIGHT + 1;
X+ 			if ( aWin->last_more_lin < aWin->scrollPos )
X+ 				aWin->last_more_lin = aWin->scrollPos;
X+ 			if ( flags.page_wait && aWin->last_more_lin <=
X+ 				 aWin->lin - (r.bottom - r.top) / aWin->charHeight )
X+ 				display_nhwindow(win, TRUE);
X+ 		}
X+ 
X  		/*
X  		 * A "default" text window - uses TextBox
X  		 * We just add the text, without attributes for now
X  		 */
X  		len = GetHandleSize ( aWin -> windowText ) ;
X  		while ( aWin -> windowTextLen + slen + 1 > len ) {
X  			len = ( len > 2048 ) ? ( len + 2048 ) : ( len * 2 ) ;
X  			SetHandleSize ( aWin -> windowText , len ) ;
X***************
X*** 2643,2649 ****
X  			if ( MemError ( ) ) {
X  				error ( "SetHandleSize (putstr)" ) ;
X  				aWin -> windowTextLen = 0L ;
X! 				aWin -> textBase = 0 ;
X  				aWin -> lin = 0 ;
X  			}
X  		}
X--- 2754,2760 ----
X  			if ( MemError ( ) ) {
X  				error ( "SetHandleSize (putstr)" ) ;
X  				aWin -> windowTextLen = 0L ;
X! 				aWin -> save_lin = 0 ;
X  				aWin -> lin = 0 ;
X  			}
X  		}
X***************
X*** 2662,2701 ****
X  			sr ++ ;
X  			ds ++ ;
X  		}
X! 		if ( slen > 1 ) {
X! 			( * ( aWin -> windowText ) ) [ len + slen ] = CHAR_CR ;
X! 			aWin -> windowTextLen += slen + 1 ;
X! 			aWin -> lin ++ ;
X! 		} else {
X! 			aWin -> windowTextLen += slen ;
X! 		}
X  	
X  		SetPort ( aWin -> theWindow ) ;
X- 		r = aWin -> theWindow -> portRect ;
X- 		if ( win && win == WIN_MESSAGE ) {
X- 			r . bottom -= SBARHEIGHT + 1 ;
X- 		}
X  		InvalRect ( & r ) ;
X  		aWin -> clear = 0 ;
X  		if ( kind == NHW_MESSAGE ) {
X! 			char * ptr , * stop ;
X! 			long oldBase = aWin -> textBase ;
X! 			short lines = ( r . bottom - r . top ) / aWin -> charHeight - 1 ;
X! 
X! 			stop = * aWin -> windowText ;
X! 			ptr = stop + aWin -> windowTextLen - 1 ;
X! 			while ( lines >= 0 && -- ptr > stop ) {
X! 				if ( * ptr == CHAR_CR || * ptr == CHAR_LF )
X! 					lines -- ;
X  			}
X- 			if ( ptr <= stop ) {
X- 				aWin -> textBase = 0L ;
X- 			} else {
X- 				aWin -> textBase = ptr - stop + 1 ;
X- 			}
X- 			if ( oldBase > aWin -> textBase ) {
X- 				aWin -> textBase = oldBase ;
X- 			}
X  		}
X  		if ( aWin -> scrollBar ) {
X  			InvalScrollBar ( aWin ) ;
X--- 2773,2793 ----
X  			sr ++ ;
X  			ds ++ ;
X  		}
X! 
X! 		( * ( aWin -> windowText ) ) [ len + slen ] = CHAR_CR ;
X! 		aWin -> windowTextLen += slen + 1 ;
X! 		aWin -> lin ++ ;
X  	
X  		SetPort ( aWin -> theWindow ) ;
X  		InvalRect ( & r ) ;
X  		aWin -> clear = 0 ;
X  		if ( kind == NHW_MESSAGE ) {
X! 			short min = aWin->lin - (r.bottom - r.top) / aWin->charHeight;
X! 			if (aWin->scrollPos < min) {
X! 				aWin->scrollPos = min;
X! 				SetCtlMax  (aWin->scrollBar, aWin->lin);
X! 				SetCtlValue(aWin->scrollBar, min);
X  			}
X  		}
X  		if ( aWin -> scrollBar ) {
X  			InvalScrollBar ( aWin ) ;
X***************
X*** 2751,2760 ****
X--- 2843,2856 ----
X  			break ;
X  		}
X  	} else {
X+ #if 1
X+ 		Debugger ( ) ;
X+ #else
X  		char ss [ 2 ] ;
X  		ss [ 0 ] = sym ;
X  		ss [ 1 ] = 0 ;
X  		putstr ( win , 0 , ss ) ;
X+ #endif
X  	}
X  }
X  
X***************
X*** 2881,2890 ****
X  int
X  mac_nh_poskey ( int * a , int * b , int * c )
X  {
X! 	if ( ! a || ! b || ! c ) {
X! 		Debugger ( ) ;
X! 	}
X! 	return nhgetch ( ) ;
X  }
X  
X  
X--- 2977,2987 ----
X  int
X  mac_nh_poskey ( int * a , int * b , int * c )
X  {
X! 	int ch = nhgetch();
X! 	*a = clicked_pos.h;
X! 	*b = clicked_pos.v;
X! 	*c = clicked_mod;
X! 	return ch;
X  }
X  
X  
X***************
X*** 2891,2902 ****
X  void
X  mac_start_menu ( winid win )
X  {
X! 	NhWindow * aWin = & theWindows [ win ] ;
X! 
X! 	HideWindow ( aWin -> theWindow ) ;
X! 	SetHandleSize ( aWin -> windowText , TEXT_BLOCK ) ;
X! 	aWin -> wid = 0 ;
X! 	aWin -> lin = 0 ;
X  	clear_nhwindow ( win ) ;
X  }
X  
X--- 2988,2994 ----
X  void
X  mac_start_menu ( winid win )
X  {
X! 	HideWindow ( theWindows [ win ] . theWindow ) ;
X  	clear_nhwindow ( win ) ;
X  }
X  
X***************
X*** 2956,2982 ****
X  char
X  mac_select_menu ( winid win )
X  {
X- 	short w , h ;
X  	int c , l ;
X- 	WindowPtr theWin = theWindows [ win ] . theWindow ;
X  	NhWindow * aWin = & theWindows [ win ] ;
X  
X  	inSelect = win ;
X  
X  	SetPort ( theWin ) ;
X! 	if ( aWin -> wid && aWin -> lin ) {
X! 		w = aWin -> wid + 16 ;
X! 		h = aWin -> lin * aWin -> charHeight ;
X! 		if ( w > 450 ) {
X! 			w = 450 ;
X! 		}
X! 		if ( h > 300 ) {
X! 			h = 300 ;
X! 		}
X! 		SizeWindow ( theWin , w , h , TRUE ) ;
X! 		if ( aWin -> scrollBar ) {
X! 			InvalScrollBar ( aWin ) ;
X! 		}
X  	}
X  	SelectWindow ( theWin ) ;
X  	ShowWindow ( theWin ) ;
X--- 3048,3063 ----
X  char
X  mac_select_menu ( winid win )
X  {
X  	int c , l ;
X  	NhWindow * aWin = & theWindows [ win ] ;
X+ 	WindowPtr theWin = aWin -> theWindow ;
X  
X  	inSelect = win ;
X  
X+ 	adjust_window_pos ( aWin , theWin , aWin -> wid + ( SBARWIDTH + 2 ) ) ;
X  	SetPort ( theWin ) ;
X! 	if ( aWin -> scrollBar ) {
X! 		InvalScrollBar ( aWin ) ;
X  	}
X  	SelectWindow ( theWin ) ;
X  	ShowWindow ( theWin ) ;
X***************
X*** 2983,2989 ****
X  	InvalRect ( & ( theWin -> portRect ) ) ;
X  
X  	do {
X! 		while ( ! ( c =  nhgetch ( ) ) ) ;
X  		for ( l = 0 ; l < aWin -> lin ; l ++ ) {
X  			if ( aWin -> itemChars [ l ] == c )
X  				goto done ;
X--- 3064,3070 ----
X  	InvalRect ( & ( theWin -> portRect ) ) ;
X  
X  	do {
X! 		c = nhgetch ( ) ;
X  		for ( l = 0 ; l < aWin -> lin ; l ++ ) {
X  			if ( aWin -> itemChars [ l ] == c )
X  				goto done ;
X***************
X*** 3185,3191 ****
X  	DialogPtr		characterDialog;
X  	short			itemHit, lastItemSelected, type;
X  	Rect			box;
X! 	
X  	characterDialog = GetNewDialog(132, (Ptr) NULL, (WindowPtr) -1);
X  	
X  	/*
X--- 3266,3287 ----
X  	DialogPtr		characterDialog;
X  	short			itemHit, lastItemSelected, type;
X  	Rect			box;
X! 
X! 	char pc;
X! 	if ((pc = highc(pl_character[0])) != 0) {
X! 		char pbuf[QBUFSZ];
X! 		EventRecord update_evt;
X! 		if(index(pl_classes, pc) != (char*) 0) {
X! 			pl_character[0] = pc;
X! 			return;
X! 		}
X! 		putstr(WIN_MESSAGE, 0, "");
X! 		Sprintf(pbuf, "Unknown role: %c", pc);
X! 		putstr(WIN_MESSAGE, 0, pbuf);
X! 		while (CheckUpdate(&update_evt))
X! 			HandleUpdate(&update_evt);
X! 	}
X! 
X  	characterDialog = GetNewDialog(132, (Ptr) NULL, (WindowPtr) -1);
X  	
X  	/*
X
END_OF_FILE
if test 53863 -ne `wc -c <'patches01s'`; then
    echo shar: \"'patches01s'\" unpacked with wrong size!
fi
# end of 'patches01s'
echo shar: End of archive 10 \(of 31\).
cp /dev/null ark10isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 31 archives.
    echo "Now execute 'patchit.sh'"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
