Subject:  v17i062:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Patch1u/31
Newsgroups: comp.sources.games
Approved: billr@saab.CNA.TEK.COM

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 17, Issue 62
Archive-name: nethack31/Patch1u
Patch-To: nethack31: Volume 16, Issue 1-116
Environment: Amiga, Atari, Mac, MS-DOS, Windows-NT, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 21 (of 31)."
# Contents:  sys/share/dgn_lex.c sys/share/sounds/firehorn.uu
# Wrapped by billr@saab on Fri Mar  5 10:50:47 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'sys/share/dgn_lex.c' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'sys/share/dgn_lex.c'\" to \"'sys/share/dgn_lex.c.orig'\"
  mv -f 'sys/share/dgn_lex.c' 'sys/share/dgn_lex.c.orig'
fi
echo shar: Extracting \"'sys/share/dgn_lex.c'\" \(36124 characters\)
sed "s/^X//" >'sys/share/dgn_lex.c' <<'END_OF_FILE'
X/* A lexical scanner generated by flex */
X
X/* scanner skeleton version:
X * $Header: /usr/fsys/odin/a/vern/flex/RCS/flex.skel,v 2.16 90/08/03 14:09:36 vern Exp $
X */
X
X#define FLEX_SCANNER
X
X#include <stdio.h>
X
X
X/* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
X#ifdef c_plusplus
X#ifndef __cplusplus
X#define __cplusplus
X#endif
X#endif
X
X
X#ifdef __cplusplus
X
X#include <stdlib.h>
X#include <osfcn.h>
X
X/* use prototypes in function declarations */
X#define YY_USE_PROTOS
X
X/* the "const" storage-class-modifier is valid */
X#define YY_USE_CONST
X
X#else	/* ! __cplusplus */
X
X#ifdef __STDC__
X
X#ifdef __GNUC__
X#include <stddef.h>
Xvoid *malloc( size_t );
X#else
X#include <stdlib.h>
X#endif	/* __GNUC__ */
X
X#define YY_USE_PROTOS
X#define YY_USE_CONST
X
X#endif	/* __STDC__ */
X#endif	/* ! __cplusplus */
X
X
X#ifdef __TURBOC__
X#define YY_USE_CONST
X#endif
X#ifdef VMS
X# define YY_USE_CONST
X# ifdef USE_PROTOTYPES
X#  define YY_USE_PROTOS
X# endif
X#endif
X
X
X#ifndef YY_USE_CONST
X#define const
X#endif
X
X
X#ifdef YY_USE_PROTOS
X#define YY_PROTO(proto) proto
X#else
X#define YY_PROTO(proto) ()
X/* we can't get here if it's an ANSI C compiler, or a C++ compiler,
X * so it's got to be a K&R compiler, and therefore there's no standard
X * place from which to include these definitions
X */
Xchar *malloc();
Xint read();
X#endif
X
X
X/* amount of stuff to slurp up with each read */
X#ifndef YY_READ_BUF_SIZE
X#define YY_READ_BUF_SIZE 8192
X#endif
X
X/* returned upon end-of-file */
X#define YY_END_TOK 0
X
X/* copy whatever the last rule matched to the standard output */
X
X/* cast to (char *) is because for 8-bit chars, yytext is (unsigned char *) */
X/* this used to be an fputs(), but since the string might contain NUL's,
X * we now use fwrite()
X */
X#define ECHO (void) fwrite( (char *) yytext, yyleng, 1, yyout )
X
X/* gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
X * is returned in "result".
X */
X#define YY_INPUT(buf,result,max_size) \
X	if ( (result = read( fileno(yyin), (char *) buf, max_size )) < 0 ) \
X	    YY_FATAL_ERROR( "read() in flex scanner failed" );
X#define YY_NULL 0
X
X/* no semi-colon after return; correct usage is to write "yyterminate();" -
X * we don't want an extra ';' after the "return" because that will cause
X * some compilers to complain about unreachable statements.
X */
X#define yyterminate() return ( YY_NULL )
X
X/* report a fatal error */
X
X/* The funky do-while is used to turn this macro definition into
X * a single C statement (which needs a semi-colon terminator).
X * This avoids problems with code like:
X *
X * 	if ( something_happens )
X *		YY_FATAL_ERROR( "oops, the something happened" );
X *	else
X *		everything_okay();
X *
X * Prior to using the do-while the compiler would get upset at the
X * "else" because it interpreted the "if" statement as being all
X * done when it reached the ';' after the YY_FATAL_ERROR() call.
X */
X
X#define YY_FATAL_ERROR(msg) \
X	do \
X		{ \
X		(void) fputs( msg, stderr ); \
X		(void) putc( '\n', stderr ); \
X		exit( 1 ); \
X		} \
X	while ( 0 )
X
X/* default yywrap function - always treat EOF as an EOF */
X#define yywrap() 1
X
X/* enter a start condition.  This macro really ought to take a parameter,
X * but we do it the disgusting crufty way forced on us by the ()-less
X * definition of BEGIN
X */
X#define BEGIN yy_start = 1 + 2 *
X
X/* action number for EOF rule of a given start state */
X#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
X
X/* special action meaning "start processing a new file" */
X#define YY_NEW_FILE \
X	do \
X		{ \
X		yy_init_buffer( yy_current_buffer, yyin ); \
X		yy_load_buffer_state(); \
X		} \
X	while ( 0 )
X
X/* default declaration of generated scanner - a define so the user can
X * easily add parameters
X */
X#define YY_DECL int yylex YY_PROTO(( void )) 
X
X/* code executed at the end of each rule */
X#define YY_BREAK break;
X
X#define YY_END_OF_BUFFER_CHAR 0
X
X#ifndef YY_BUF_SIZE
X#define YY_BUF_SIZE (YY_READ_BUF_SIZE * 2) /* size of default input buffer */
X#endif
X
Xtypedef struct yy_buffer_state *YY_BUFFER_STATE;
X
X#define YY_CHAR char
X# line 1 "dgn_comp.l"
X#define INITIAL 0
X# line 2 "dgn_comp.l"
X/*	SCCS Id: @(#)dgn_lex.c	3.1	92/10/23	*/
X/*	Copyright (c) 1989 by Jean-Christophe Collet */
X/*	Copyright (c) 1990 by M. Stephenson	     */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#define DGN_COMP
X
X#include "config.h"
X#include "dgn_comp.h"
X#include "dgn_file.h"
X
Xlong *FDECL(alloc, (unsigned int));
X/*
X * Most of these don't exist in flex, yywrap is macro and
X * yyunput is properly declared in flex.skel.
X */
X#ifndef FLEX_SCANNER
Xint FDECL (yyback, (int *, int));
Xint NDECL (yylook);
Xint NDECL (yyinput);
Xint NDECL (yywrap);
Xint NDECL (yylex);
X	/* Traditional lexes let yyunput() and yyoutput() default to int;
X	 * newer ones may declare them as void since they don't return
X	 * values.  For even more fun, the lex supplied as part of the
X	 * newer unbundled compiler for SunOS 4.x adds the void declarations
X	 * (under __STDC__ or _cplusplus ifdefs -- otherwise they remain
X	 * int) while the bundled lex and the one with the older unbundled
X	 * compiler do not.  To detect this, we need help from outside --
X	 * sys/unix/Makefile.utl.
X	 */
X# if defined(NeXT) || defined(SVR4)
X#  define VOIDYYPUT
X# endif
X# if !defined(VOIDYYPUT)
X#  if defined(POSIX_TYPES) && !defined(BOS) && !defined(HISX)
X#   define VOIDYYPUT
X#  endif
X# endif
X# if !defined(VOIDYYPUT) && defined(WEIRD_LEX)
X#  if defined(SUNOS4) && defined(__STDC__) && (WEIRD_LEX > 1) 
X#   define VOIDYYPUT
X#  endif
X# endif
X# ifdef VOIDYYPUT
Xvoid FDECL (yyunput, (int));
Xvoid FDECL (yyoutput, (int));
X# else
Xint FDECL (yyunput, (int));
Xint FDECL (yyoutput, (int));
X# endif
X#endif	/* FLEX_SCANNER */
X
Xvoid FDECL (init_yyin, (FILE *));
Xvoid FDECL (init_yyout, (FILE *));
X
X#ifdef MICRO
X#undef exit
Xextern void FDECL(exit, (int));
X#endif
X
X/* this doesn't always get put in dgn_comp.h
X * (esp. when using older versions of bison)
X */
X
Xextern YYSTYPE yylval;
X
Xint line_number = 1;
X/*
X *	This is a hack required by Michael Hamel to get things
X *	working on the Mac.
X */
X#if defined(applec) && !defined(FLEX_SCANNER)
X#undef input
X#undef unput
X#define unput(c) { yytchar = (c); if (yytchar == 10) yylineno--; *yysptr++ = yytchar; }				  
X# ifndef YYNEWLINE
X# define YYNEWLINE 10
X# endif
X
Xchar
Xinput() {	/* Under MPW \n is chr(13)! Compensate for this. */
X
X	if (yysptr > yysbuf) return(*--yysptr);
X	else {
X		yytchar = getc(yyin);
X	 	if (yytchar == '\n') {
X		    yylineno++;
X		    return(YYNEWLINE);
X		}
X		if (yytchar == EOF) return(0);
X		else		    return(yytchar);
X	}
X}
X#endif	/* applec && !FLEX_SCANNER */
X
X# line 99 "dgn_comp.l"
X
X/* done after the current pattern has been matched and before the
X * corresponding action - sets up yytext
X */
X#define YY_DO_BEFORE_ACTION \
X	yytext = yy_bp; \
X	yyleng = yy_cp - yy_bp; \
X	yy_hold_char = *yy_cp; \
X	*yy_cp = '\0'; \
X	yy_c_buf_p = yy_cp;
X
X#define EOB_ACT_CONTINUE_SCAN 0
X#define EOB_ACT_END_OF_FILE 1
X#define EOB_ACT_LAST_MATCH 2
X
X/* return all but the first 'n' matched characters back to the input stream */
X#define yyless(n) \
X	do \
X		{ \
X		/* undo effects of setting up yytext */ \
X		*yy_cp = yy_hold_char; \
X		yy_c_buf_p = yy_cp = yy_bp + n; \
X		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
X		} \
X	while ( 0 )
X
X#define unput(c) yyunput( c, yytext )
X
X
Xstruct yy_buffer_state
X    {
X    FILE *yy_input_file;
X
X    YY_CHAR *yy_ch_buf;		/* input buffer */
X    YY_CHAR *yy_buf_pos;	/* current position in input buffer */
X
X    /* size of input buffer in bytes, not including room for EOB characters*/
X    int yy_buf_size;	
X
X    /* number of characters read into yy_ch_buf, not including EOB characters */
X    int yy_n_chars;
X
X    int yy_eof_status;		/* whether we've seen an EOF on this buffer */
X#define EOF_NOT_SEEN 0
X    /* "pending" happens when the EOF has been seen but there's still
X     * some text process
X     */
X#define EOF_PENDING 1
X#define EOF_DONE 2
X    };
X
Xstatic YY_BUFFER_STATE yy_current_buffer;
X
X/* we provide macros for accessing buffer states in case in the
X * future we want to put the buffer states in a more general
X * "scanner state"
X */
X#define YY_CURRENT_BUFFER yy_current_buffer
X
X
X/* yy_hold_char holds the character lost when yytext is formed */
Xstatic YY_CHAR yy_hold_char;
X
Xstatic int yy_n_chars;		/* number of characters read into yy_ch_buf */
X
X
X
X#ifndef YY_USER_ACTION
X#define YY_USER_ACTION
X#endif
X
X#ifndef YY_USER_INIT
X#define YY_USER_INIT
X#endif
X
Xextern YY_CHAR *yytext;
Xextern int yyleng;
Xextern FILE *yyin, *yyout;
X
XYY_CHAR *yytext;
Xint yyleng;
X
XFILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
X
X#define YY_END_OF_BUFFER 36
Xtypedef int yy_state_type;
Xstatic const short int yy_accept[194] =
X    {   0,
X        0,    0,   36,   34,   33,   32,   34,   29,   34,   34,
X       34,   34,   34,   34,   34,   34,   34,   34,   34,   34,
X       34,   34,   34,   34,   34,   34,   34,   34,   33,    0,
X       30,   29,    0,    0,    0,    0,    0,    0,    0,    0,
X        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
X        0,    0,    0,    2,    0,   31,    0,    0,    0,    0,
X        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
X        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
X        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
X        3,    0,    0,    0,    0,    0,    0,    0,    0,    0,
X
X        0,   14,    0,    0,    0,    0,    0,    0,    4,    0,
X       25,    0,    0,    0,    0,    0,    0,    0,    0,    0,
X        6,    0,    0,    0,    5,    0,    0,   23,    0,    0,
X        0,    0,    0,    0,    0,    0,    0,    0,    0,   20,
X        0,    0,    0,    0,    8,    0,    0,    0,    0,    0,
X        0,    1,    0,    0,    0,    0,    0,   22,   15,    0,
X       21,    7,   19,    0,    0,    0,    0,    0,    0,   13,
X        0,    0,    0,   26,   16,    0,    0,   12,    0,    0,
X        0,   11,    9,    0,   17,   18,    0,   27,    0,   28,
X       24,   10,    0
X
X    } ;
X
Xstatic const YY_CHAR yy_ec[128] =
X    {   0,
X        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    2,    1,    4,    5,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    6,    1,    1,    6,    6,    6,
X        6,    6,    6,    6,    6,    6,    6,    1,    1,    1,
X        1,    1,    1,    1,    7,    8,    9,   10,   11,   12,
X       13,   14,   15,    1,    1,   16,   17,   18,   19,   20,
X        1,   21,   22,   23,   24,   25,    1,    1,   26,    1,
X        1,    1,    1,    1,   27,    1,   28,    1,   29,   30,
X
X       31,   32,   33,   34,   35,    1,   36,   37,   38,   39,
X       40,   41,    1,   42,   43,   44,   45,    1,   46,    1,
X        1,   47,    1,    1,    1,    1,    1
X    } ;
X
Xstatic const YY_CHAR yy_meta[48] =
X    {   0,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    1,    1
X    } ;
X
Xstatic const short int yy_base[196] =
X    {   0,
X        0,  212,  216,  218,  213,  218,  210,  207,  196,  190,
X      196,   37,  191,  197,  186,  188,  171,  164,  172,  174,
X      173,   18,  160,  159,  154,  157,   11,  193,  193,  190,
X      218,  187,  177,  184,  183,  167,  170,  164,  161,  166,
X      174,  155,  136,  144,  134,  132,  133,   26,  135,  143,
X      147,  128,  145,  218,  169,  218,  158,  152,  154,  159,
X      154,  145,   44,  142,   47,  124,  124,  125,  129,  129,
X      115,   27,  121,  113,  111,  120,  115,  116,  134,  142,
X      132,  128,  137,  121,  130,  129,  125,  129,  131,   97,
X      218,  105,   94,  101,   95,   96,   94,   99,  105,  101,
X
X       89,  218,   95,  112,  114,   51,  112,  107,  218,  110,
X      114,  111,  106,   96,   85,   76,   81,   82,   88,   69,
X      218,   81,   76,   75,  218,   78,   99,  218,   88,   97,
X       87,   88,   92,   93,   88,   91,   90,   71,   65,  218,
X       62,   60,   57,   56,  218,   59,   54,   74,   84,   65,
X       66,  218,   70,   65,   70,   60,   68,  218,  218,   52,
X      218,  218,  218,   46,   50,   57,   61,   67,   62,  218,
X       67,   64,   63,  218,  218,   42,   41,  218,   61,   53,
X       49,  218,  218,   50,  218,  218,   51,  218,   46,  218,
X      218,  218,  218,   61,   59
X
X    } ;
X
Xstatic const short int yy_def[196] =
X    {   0,
X      193,    1,  193,  193,  193,  193,  194,  193,  193,  193,
X      193,  193,  193,  193,  193,  193,  193,  193,  193,  193,
X      193,  193,  193,  193,  193,  193,  193,  195,  193,  194,
X      193,  193,  193,  193,  193,  193,  193,  193,  193,  193,
X      193,  193,  193,  193,  193,  193,  193,  193,  193,  193,
X      193,  193,  193,  193,  195,  193,  193,  193,  193,  193,
X      193,  193,  193,  193,  193,  193,  193,  193,  193,  193,
X      193,  193,  193,  193,  193,  193,  193,  193,  193,  193,
X      193,  193,  193,  193,  193,  193,  193,  193,  193,  193,
X      193,  193,  193,  193,  193,  193,  193,  193,  193,  193,
X
X      193,  193,  193,  193,  193,  193,  193,  193,  193,  193,
X      193,  193,  193,  193,  193,  193,  193,  193,  193,  193,
X      193,  193,  193,  193,  193,  193,  193,  193,  193,  193,
X      193,  193,  193,  193,  193,  193,  193,  193,  193,  193,
X      193,  193,  193,  193,  193,  193,  193,  193,  193,  193,
X      193,  193,  193,  193,  193,  193,  193,  193,  193,  193,
X      193,  193,  193,  193,  193,  193,  193,  193,  193,  193,
X      193,  193,  193,  193,  193,  193,  193,  193,  193,  193,
X      193,  193,  193,  193,  193,  193,  193,  193,  193,  193,
X      193,  193,    0,  193,  193
X
X    } ;
X
Xstatic const short int yy_nxt[266] =
X    {   0,
X        4,    5,    6,    7,    4,    8,    9,   10,   11,   12,
X       13,    4,    4,    4,    4,   14,    4,    4,    4,   15,
X       16,    4,    4,    4,    4,    4,    4,    4,   17,   18,
X        4,    4,    4,   19,    4,    4,   20,   21,   22,    4,
X       23,   24,   25,   26,   27,    4,    4,   36,   47,   53,
X       85,   54,   72,   73,   86,   88,   96,   48,  129,   55,
X       37,   30,   89,  192,  191,  190,  130,  189,  188,  187,
X      186,   97,  185,  184,  183,  182,  181,  180,  179,  178,
X      177,  176,  175,  174,  173,  172,  171,  170,  169,  168,
X      167,  166,  165,  164,  163,  162,  161,  160,  159,  158,
X
X      157,  156,  155,  154,  153,  152,  151,  150,  149,  148,
X      147,  146,  145,  144,  143,  142,  141,  140,  139,  138,
X      137,  136,  135,  134,  133,  132,  131,  128,  127,  126,
X      125,  124,  123,  122,  121,  120,  119,  118,  117,  116,
X      115,  114,  113,  112,  111,  110,  109,  108,  107,  106,
X      105,  104,  103,  102,  101,  100,   99,   98,   95,   94,
X       93,   92,   91,   90,   87,   84,   83,   82,   81,   80,
X       79,   56,   78,   77,   76,   75,   74,   71,   70,   69,
X       68,   67,   66,   65,   64,   63,   62,   61,   60,   59,
X       58,   57,   32,   31,   29,   56,   52,   51,   50,   49,
X
X       46,   45,   44,   43,   42,   41,   40,   39,   38,   35,
X       34,   33,   32,   31,   29,  193,   28,    3,  193,  193,
X      193,  193,  193,  193,  193,  193,  193,  193,  193,  193,
X      193,  193,  193,  193,  193,  193,  193,  193,  193,  193,
X      193,  193,  193,  193,  193,  193,  193,  193,  193,  193,
X      193,  193,  193,  193,  193,  193,  193,  193,  193,  193,
X      193,  193,  193,  193,  193
X    } ;
X
Xstatic const short int yy_chk[266] =
X    {   0,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    1,    1,   12,   22,   27,
X       63,   27,   48,   48,   63,   65,   72,   22,  106,  195,
X       12,  194,   65,  189,  187,  184,  106,  181,  180,  179,
X      177,   72,  176,  173,  172,  171,  169,  168,  167,  166,
X      165,  164,  160,  157,  156,  155,  154,  153,  151,  150,
X      149,  148,  147,  146,  144,  143,  142,  141,  139,  138,
X
X      137,  136,  135,  134,  133,  132,  131,  130,  129,  127,
X      126,  124,  123,  122,  120,  119,  118,  117,  116,  115,
X      114,  113,  112,  111,  110,  108,  107,  105,  104,  103,
X      101,  100,   99,   98,   97,   96,   95,   94,   93,   92,
X       90,   89,   88,   87,   86,   85,   84,   83,   82,   81,
X       80,   79,   78,   77,   76,   75,   74,   73,   71,   70,
X       69,   68,   67,   66,   64,   62,   61,   60,   59,   58,
X       57,   55,   53,   52,   51,   50,   49,   47,   46,   45,
X       44,   43,   42,   41,   40,   39,   38,   37,   36,   35,
X       34,   33,   32,   30,   29,   28,   26,   25,   24,   23,
X
X       21,   20,   19,   18,   17,   16,   15,   14,   13,   11,
X       10,    9,    8,    7,    5,    3,    2,  193,  193,  193,
X      193,  193,  193,  193,  193,  193,  193,  193,  193,  193,
X      193,  193,  193,  193,  193,  193,  193,  193,  193,  193,
X      193,  193,  193,  193,  193,  193,  193,  193,  193,  193,
X      193,  193,  193,  193,  193,  193,  193,  193,  193,  193,
X      193,  193,  193,  193,  193
X    } ;
X
Xstatic yy_state_type yy_last_accepting_state;
Xstatic YY_CHAR *yy_last_accepting_cpos;
X
X/* the intent behind this definition is that it'll catch
X * any uses of REJECT which flex missed
X */
X#define REJECT reject_used_but_not_detected
X#define yymore() yymore_used_but_not_detected
X#define YY_MORE_ADJ 0
X
X/* these variables are all declared out here so that section 3 code can
X * manipulate them
X */
X/* points to current character in buffer */
Xstatic YY_CHAR *yy_c_buf_p = (YY_CHAR *) 0;
Xstatic int yy_init = 1;		/* whether we need to initialize */
Xstatic int yy_start = 0;	/* start state number */
X
X/* flag which is used to allow yywrap()'s to do buffer switches
X * instead of setting up a fresh yyin.  A bit of a hack ...
X */
Xstatic int yy_did_buffer_switch_on_eof;
X
Xstatic yy_state_type yy_get_previous_state YY_PROTO(( void ));
Xstatic yy_state_type yy_try_NUL_trans YY_PROTO(( yy_state_type current_state ));
Xstatic int yy_get_next_buffer YY_PROTO(( void ));
Xstatic void yyunput YY_PROTO(( YY_CHAR c, YY_CHAR *buf_ptr ));
Xvoid yyrestart YY_PROTO(( FILE *input_file ));
Xvoid yy_switch_to_buffer YY_PROTO(( YY_BUFFER_STATE new_buffer ));
Xvoid yy_load_buffer_state YY_PROTO(( void ));
XYY_BUFFER_STATE yy_create_buffer YY_PROTO(( FILE *file, int size ));
Xvoid yy_delete_buffer YY_PROTO(( YY_BUFFER_STATE b ));
Xvoid yy_init_buffer YY_PROTO(( YY_BUFFER_STATE b, FILE *file ));
X
X#define yy_new_buffer yy_create_buffer
X
X#ifdef __cplusplus
Xstatic int yyinput YY_PROTO(( void ));
X#else
Xstatic int input YY_PROTO(( void ));
X#endif
X
XYY_DECL
X    {
X    register yy_state_type yy_current_state;
X    register YY_CHAR *yy_cp, *yy_bp;
X    register int yy_act;
X
X
X
X    if ( yy_init )
X	{
X	YY_USER_INIT;
X
X	if ( ! yy_start )
X	    yy_start = 1;	/* first start state */
X
X	if ( ! yyin )
X	    yyin = stdin;
X
X	if ( ! yyout )
X	    yyout = stdout;
X
X	if ( yy_current_buffer )
X	    yy_init_buffer( yy_current_buffer, yyin );
X	else
X	    yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );
X
X	yy_load_buffer_state();
X
X	yy_init = 0;
X	}
X
X    while ( 1 )		/* loops until end-of-file is reached */
X	{
X	yy_cp = yy_c_buf_p;
X
X	/* support of yytext */
X	*yy_cp = yy_hold_char;
X
X	/* yy_bp points to the position in yy_ch_buf of the start of the
X	 * current run.
X	 */
X	yy_bp = yy_cp;
X
X	yy_current_state = yy_start;
X	if ( yy_bp[-1] == '\n' )
X	    ++yy_current_state;
Xyy_match:
X	do
X	    {
X	    register YY_CHAR yy_c = yy_ec[*yy_cp];
X	    if ( yy_accept[yy_current_state] )
X		{
X		yy_last_accepting_state = yy_current_state;
X		yy_last_accepting_cpos = yy_cp;
X		}
X	    while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
X		{
X		yy_current_state = yy_def[yy_current_state];
X		if ( yy_current_state >= 194 )
X		    yy_c = yy_meta[yy_c];
X		}
X	    yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
X	    ++yy_cp;
X	    }
X	while ( yy_current_state != 193 );
X	yy_cp = yy_last_accepting_cpos;
X	yy_current_state = yy_last_accepting_state;
X
Xyy_find_action:
X	yy_act = yy_accept[yy_current_state];
X
X	YY_DO_BEFORE_ACTION;
X	YY_USER_ACTION;
X
Xdo_action:	/* this label is used only to access EOF actions */
X
X
X	switch ( yy_act )
X	    {
X	    case 0: /* must backtrack */
X	    /* undo the effects of YY_DO_BEFORE_ACTION */
X	    *yy_cp = yy_hold_char;
X	    yy_cp = yy_last_accepting_cpos;
X	    yy_current_state = yy_last_accepting_state;
X	    goto yy_find_action;
X
Xcase 1:
X# line 100 "dgn_comp.l"
Xreturn(A_DUNGEON);
X	YY_BREAK
Xcase 2:
X# line 101 "dgn_comp.l"
X{ yylval.i=1; return(UP_OR_DOWN); }
X	YY_BREAK
Xcase 3:
X# line 102 "dgn_comp.l"
X{ yylval.i=0; return(UP_OR_DOWN); }
X	YY_BREAK
Xcase 4:
X# line 103 "dgn_comp.l"
Xreturn(ENTRY);
X	YY_BREAK
Xcase 5:
X# line 104 "dgn_comp.l"
Xreturn(STAIR);
X	YY_BREAK
Xcase 6:
X# line 105 "dgn_comp.l"
Xreturn(NO_UP);
X	YY_BREAK
Xcase 7:
X# line 106 "dgn_comp.l"
Xreturn(NO_DOWN);
X	YY_BREAK
Xcase 8:
X# line 107 "dgn_comp.l"
Xreturn(PORTAL);
X	YY_BREAK
Xcase 9:
X# line 108 "dgn_comp.l"
Xreturn(PROTOFILE);
X	YY_BREAK
Xcase 10:
X# line 109 "dgn_comp.l"
Xreturn(DESCRIPTION);
X	YY_BREAK
Xcase 11:
X# line 110 "dgn_comp.l"
Xreturn(LEVELDESC);
X	YY_BREAK
Xcase 12:
X# line 111 "dgn_comp.l"
Xreturn(ALIGNMENT);
X	YY_BREAK
Xcase 13:
X# line 112 "dgn_comp.l"
Xreturn(LEVALIGN);
X	YY_BREAK
Xcase 14:
X# line 113 "dgn_comp.l"
X{ yylval.i=TOWN ; return(DESCRIPTOR); }
X	YY_BREAK
Xcase 15:
X# line 114 "dgn_comp.l"
X{ yylval.i=HELLISH ; return(DESCRIPTOR); }
X	YY_BREAK
Xcase 16:
X# line 115 "dgn_comp.l"
X{ yylval.i=MAZELIKE ; return(DESCRIPTOR); }
X	YY_BREAK
Xcase 17:
X# line 116 "dgn_comp.l"
X{ yylval.i=ROGUELIKE ; return(DESCRIPTOR); }
X	YY_BREAK
Xcase 18:
X# line 117 "dgn_comp.l"
X{ yylval.i=D_ALIGN_NONE ; return(DESCRIPTOR); }
X	YY_BREAK
Xcase 19:
X# line 118 "dgn_comp.l"
X{ yylval.i=D_ALIGN_NONE ; return(DESCRIPTOR); }
X	YY_BREAK
Xcase 20:
X# line 119 "dgn_comp.l"
X{ yylval.i=D_ALIGN_LAWFUL ; return(DESCRIPTOR); }
X	YY_BREAK
Xcase 21:
X# line 120 "dgn_comp.l"
X{ yylval.i=D_ALIGN_NEUTRAL ; return(DESCRIPTOR); }
X	YY_BREAK
Xcase 22:
X# line 121 "dgn_comp.l"
X{ yylval.i=D_ALIGN_CHAOTIC ; return(DESCRIPTOR); }
X	YY_BREAK
Xcase 23:
X# line 122 "dgn_comp.l"
Xreturn(BRANCH);
X	YY_BREAK
Xcase 24:
X# line 123 "dgn_comp.l"
Xreturn(CHBRANCH);
X	YY_BREAK
Xcase 25:
X# line 124 "dgn_comp.l"
Xreturn(LEVEL);
X	YY_BREAK
Xcase 26:
X# line 125 "dgn_comp.l"
Xreturn(RNDLEVEL);
X	YY_BREAK
Xcase 27:
X# line 126 "dgn_comp.l"
Xreturn(CHLEVEL);
X	YY_BREAK
Xcase 28:
X# line 127 "dgn_comp.l"
Xreturn(RNDCHLEVEL);
X	YY_BREAK
Xcase 29:
X# line 128 "dgn_comp.l"
X{ yylval.i=atoi(yytext); return(INTEGER); }
X	YY_BREAK
Xcase 30:
X# line 129 "dgn_comp.l"
X{ yytext[yyleng-1] = 0; /* Discard the trailing \" */
X		  yylval.str = (char *) alloc(strlen(yytext+1)+1);
X		  strcpy(yylval.str, yytext+1); /* Discard the first \" */
X		  return(STRING); }
X	YY_BREAK
Xcase 31:
X# line 133 "dgn_comp.l"
X{ line_number++; }
X	YY_BREAK
Xcase 32:
X# line 134 "dgn_comp.l"
X{ line_number++; }
X	YY_BREAK
Xcase 33:
X# line 135 "dgn_comp.l"
X;	/* skip trailing tabs & spaces */
X	YY_BREAK
Xcase 34:
X# line 136 "dgn_comp.l"
X{ return yytext[0]; }
X	YY_BREAK
Xcase 35:
X# line 137 "dgn_comp.l"
XECHO;
X	YY_BREAK
Xcase YY_STATE_EOF(INITIAL):
X    yyterminate();
X
X	    case YY_END_OF_BUFFER:
X		{
X		/* amount of text matched not including the EOB char */
X		int yy_amount_of_matched_text = yy_cp - yytext - 1;
X
X		/* undo the effects of YY_DO_BEFORE_ACTION */
X		*yy_cp = yy_hold_char;
X
X		/* note that here we test for yy_c_buf_p "<=" to the position
X		 * of the first EOB in the buffer, since yy_c_buf_p will
X		 * already have been incremented past the NUL character
X		 * (since all states make transitions on EOB to the end-
X		 * of-buffer state).  Contrast this with the test in yyinput().
X		 */
X		if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )
X		    /* this was really a NUL */
X		    {
X		    yy_state_type yy_next_state;
X
X		    yy_c_buf_p = yytext + yy_amount_of_matched_text;
X
X		    yy_current_state = yy_get_previous_state();
X
X		    /* okay, we're now positioned to make the
X		     * NUL transition.  We couldn't have
X		     * yy_get_previous_state() go ahead and do it
X		     * for us because it doesn't know how to deal
X		     * with the possibility of jamming (and we
X		     * don't want to build jamming into it because
X		     * then it will run more slowly)
X		     */
X
X		    yy_next_state = yy_try_NUL_trans( yy_current_state );
X
X		    yy_bp = yytext + YY_MORE_ADJ;
X
X		    if ( yy_next_state )
X			{
X			/* consume the NUL */
X			yy_cp = ++yy_c_buf_p;
X			yy_current_state = yy_next_state;
X			goto yy_match;
X			}
X
X		    else
X			{
X			    yy_cp = yy_last_accepting_cpos;
X			    yy_current_state = yy_last_accepting_state;
X			goto yy_find_action;
X			}
X		    }
X
X		else switch ( yy_get_next_buffer() )
X		    {
X		    case EOB_ACT_END_OF_FILE:
X			{
X			yy_did_buffer_switch_on_eof = 0;
X
X			if ( yywrap() )
X			    {
X			    /* note: because we've taken care in
X			     * yy_get_next_buffer() to have set up yytext,
X			     * we can now set up yy_c_buf_p so that if some
X			     * total hoser (like flex itself) wants
X			     * to call the scanner after we return the
X			     * YY_NULL, it'll still work - another YY_NULL
X			     * will get returned.
X			     */
X			    yy_c_buf_p = yytext + YY_MORE_ADJ;
X
X			    yy_act = YY_STATE_EOF((yy_start - 1) / 2);
X			    goto do_action;
X			    }
X
X			else
X			    {
X			    if ( ! yy_did_buffer_switch_on_eof )
X				YY_NEW_FILE;
X			    }
X			}
X			break;
X
X		    case EOB_ACT_CONTINUE_SCAN:
X			yy_c_buf_p = yytext + yy_amount_of_matched_text;
X
X			yy_current_state = yy_get_previous_state();
X
X			yy_cp = yy_c_buf_p;
X			yy_bp = yytext + YY_MORE_ADJ;
X			goto yy_match;
X
X		    case EOB_ACT_LAST_MATCH:
X			yy_c_buf_p =
X			    &yy_current_buffer->yy_ch_buf[yy_n_chars];
X
X			yy_current_state = yy_get_previous_state();
X
X			yy_cp = yy_c_buf_p;
X			yy_bp = yytext + YY_MORE_ADJ;
X			goto yy_find_action;
X		    }
X		break;
X		}
X
X	    default:
X#ifdef FLEX_DEBUG
X		printf( "action # %d\n", yy_act );
X#endif
X		YY_FATAL_ERROR(
X			"fatal flex scanner internal error--no action found" );
X	    }
X	}
X    }
X
X
X/* yy_get_next_buffer - try to read in a new buffer
X *
X * synopsis
X *     int yy_get_next_buffer();
X *     
X * returns a code representing an action
X *     EOB_ACT_LAST_MATCH - 
X *     EOB_ACT_CONTINUE_SCAN - continue scanning from current position
X *     EOB_ACT_END_OF_FILE - end of file
X */
X
Xstatic int yy_get_next_buffer()
X
X    {
X    register YY_CHAR *dest = yy_current_buffer->yy_ch_buf;
X    register YY_CHAR *source = yytext - 1; /* copy prev. char, too */
X    register int number_to_move, i;
X    int ret_val;
X
X    if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )
X	YY_FATAL_ERROR(
X		"fatal flex scanner internal error--end of buffer missed" );
X
X    /* try to read more data */
X
X    /* first move last chars to start of buffer */
X    number_to_move = yy_c_buf_p - yytext;
X
X    for ( i = 0; i < number_to_move; ++i )
X	*(dest++) = *(source++);
X
X    if ( yy_current_buffer->yy_eof_status != EOF_NOT_SEEN )
X	/* don't do the read, it's not guaranteed to return an EOF,
X	 * just force an EOF
X	 */
X	yy_n_chars = 0;
X
X    else
X	{
X	int num_to_read = yy_current_buffer->yy_buf_size - number_to_move - 1;
X
X	if ( num_to_read > YY_READ_BUF_SIZE )
X	    num_to_read = YY_READ_BUF_SIZE;
X
X	else if ( num_to_read <= 0 )
X	    YY_FATAL_ERROR( "fatal error - scanner input buffer overflow" );
X
X	/* read in more data */
X	YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),
X		  yy_n_chars, num_to_read );
X	}
X
X    if ( yy_n_chars == 0 )
X	{
X	if ( number_to_move == 1 )
X	    {
X	    ret_val = EOB_ACT_END_OF_FILE;
X	    yy_current_buffer->yy_eof_status = EOF_DONE;
X	    }
X
X	else
X	    {
X	    ret_val = EOB_ACT_LAST_MATCH;
X	    yy_current_buffer->yy_eof_status = EOF_PENDING;
X	    }
X	}
X
X    else
X	ret_val = EOB_ACT_CONTINUE_SCAN;
X
X    yy_n_chars += number_to_move;
X    yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
X    yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;
X
X    /* yytext begins at the second character in yy_ch_buf; the first
X     * character is the one which preceded it before reading in the latest
X     * buffer; it needs to be kept around in case it's a newline, so
X     * yy_get_previous_state() will have with '^' rules active
X     */
X
X    yytext = &yy_current_buffer->yy_ch_buf[1];
X
X    return ( ret_val );
X    }
X
X
X/* yy_get_previous_state - get the state just before the EOB char was reached
X *
X * synopsis
X *     yy_state_type yy_get_previous_state();
X */
X
Xstatic yy_state_type yy_get_previous_state()
X
X    {
X    register yy_state_type yy_current_state;
X    register YY_CHAR *yy_cp;
X
X    register YY_CHAR *yy_bp = yytext;
X
X    yy_current_state = yy_start;
X    if ( yy_bp[-1] == '\n' )
X	++yy_current_state;
X
X    for ( yy_cp = yytext + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )
X	{
X	register YY_CHAR yy_c = (*yy_cp ? yy_ec[*yy_cp] : 1);
X	if ( yy_accept[yy_current_state] )
X	    {
X	    yy_last_accepting_state = yy_current_state;
X	    yy_last_accepting_cpos = yy_cp;
X	    }
X	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
X	    {
X	    yy_current_state = yy_def[yy_current_state];
X	    if ( yy_current_state >= 194 )
X		yy_c = yy_meta[yy_c];
X	    }
X	yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
X	}
X
X    return ( yy_current_state );
X    }
X
X
X/* yy_try_NUL_trans - try to make a transition on the NUL character
X *
X * synopsis
X *     next_state = yy_try_NUL_trans( current_state );
X */
X
X#ifdef YY_USE_PROTOS
Xstatic yy_state_type yy_try_NUL_trans( register yy_state_type yy_current_state )
X#else
Xstatic yy_state_type yy_try_NUL_trans( yy_current_state )
Xregister yy_state_type yy_current_state;
X#endif
X
X    {
X    register int yy_is_jam;
X    register YY_CHAR *yy_cp = yy_c_buf_p;
X
X    register YY_CHAR yy_c = 1;
X    if ( yy_accept[yy_current_state] )
X	{
X	yy_last_accepting_state = yy_current_state;
X	yy_last_accepting_cpos = yy_cp;
X	}
X    while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
X	{
X	yy_current_state = yy_def[yy_current_state];
X	if ( yy_current_state >= 194 )
X	    yy_c = yy_meta[yy_c];
X	}
X    yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
X    yy_is_jam = (yy_current_state == 193);
X
X    return ( yy_is_jam ? 0 : yy_current_state );
X    }
X
X
X#ifdef YY_USE_PROTOS
Xstatic void yyunput( YY_CHAR c, register YY_CHAR *yy_bp )
X#else
Xstatic void yyunput( c, yy_bp )
XYY_CHAR c;
Xregister YY_CHAR *yy_bp;
X#endif
X
X    {
X    register YY_CHAR *yy_cp = yy_c_buf_p;
X
X    /* undo effects of setting up yytext */
X    *yy_cp = yy_hold_char;
X
X    if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
X	{ /* need to shift things up to make room */
X	register int number_to_move = yy_n_chars + 2; /* +2 for EOB chars */
X	register YY_CHAR *dest =
X	    &yy_current_buffer->yy_ch_buf[yy_current_buffer->yy_buf_size + 2];
X	register YY_CHAR *source =
X	    &yy_current_buffer->yy_ch_buf[number_to_move];
X
X	while ( source > yy_current_buffer->yy_ch_buf )
X	    *--dest = *--source;
X
X	yy_cp += dest - source;
X	yy_bp += dest - source;
X	yy_n_chars = yy_current_buffer->yy_buf_size;
X
X	if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
X	    YY_FATAL_ERROR( "flex scanner push-back overflow" );
X	}
X
X    if ( yy_cp > yy_bp && yy_cp[-1] == '\n' )
X	yy_cp[-2] = '\n';
X
X    *--yy_cp = c;
X
X    /* note: the formal parameter *must* be called "yy_bp" for this
X     *       macro to now work correctly
X     */
X    YY_DO_BEFORE_ACTION; /* set up yytext again */
X    }
X
X
X#ifdef __cplusplus
Xstatic int yyinput()
X#else
Xstatic int input()
X#endif
X
X    {
X    int c;
X    YY_CHAR *yy_cp = yy_c_buf_p;
X
X    *yy_cp = yy_hold_char;
X
X    if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
X	{
X	/* yy_c_buf_p now points to the character we want to return.
X	 * If this occurs *before* the EOB characters, then it's a
X	 * valid NUL; if not, then we've hit the end of the buffer.
X	 */
X	if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )
X	    /* this was really a NUL */
X	    *yy_c_buf_p = '\0';
X
X	else
X	    { /* need more input */
X	    yytext = yy_c_buf_p;
X	    ++yy_c_buf_p;
X
X	    switch ( yy_get_next_buffer() )
X		{
X		case EOB_ACT_END_OF_FILE:
X		    {
X		    if ( yywrap() )
X			{
X			yy_c_buf_p = yytext + YY_MORE_ADJ;
X			return ( EOF );
X			}
X
X		    YY_NEW_FILE;
X
X#ifdef __cplusplus
X		    return ( yyinput() );
X#else
X		    return ( input() );
X#endif
X		    }
X		    break;
X
X		case EOB_ACT_CONTINUE_SCAN:
X		    yy_c_buf_p = yytext + YY_MORE_ADJ;
X		    break;
X
X		case EOB_ACT_LAST_MATCH:
X#ifdef __cplusplus
X		    YY_FATAL_ERROR( "unexpected last match in yyinput()" );
X#else
X		    YY_FATAL_ERROR( "unexpected last match in input()" );
X#endif
X		}
X	    }
X	}
X
X    c = *yy_c_buf_p;
X    yy_hold_char = *++yy_c_buf_p;
X
X    return ( c );
X    }
X
X
X#ifdef YY_USE_PROTOS
Xvoid yyrestart( FILE *input_file )
X#else
Xvoid yyrestart( input_file )
XFILE *input_file;
X#endif
X
X    {
X    yy_init_buffer( yy_current_buffer, input_file );
X    yy_load_buffer_state();
X    }
X
X
X#ifdef YY_USE_PROTOS
Xvoid yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
X#else
Xvoid yy_switch_to_buffer( new_buffer )
XYY_BUFFER_STATE new_buffer;
X#endif
X
X    {
X    if ( yy_current_buffer == new_buffer )
X	return;
X
X    if ( yy_current_buffer )
X	{
X	/* flush out information for old buffer */
X	*yy_c_buf_p = yy_hold_char;
X	yy_current_buffer->yy_buf_pos = yy_c_buf_p;
X	yy_current_buffer->yy_n_chars = yy_n_chars;
X	}
X
X    yy_current_buffer = new_buffer;
X    yy_load_buffer_state();
X
X    /* we don't actually know whether we did this switch during
X     * EOF (yywrap()) processing, but the only time this flag
X     * is looked at is after yywrap() is called, so it's safe
X     * to go ahead and always set it.
X     */
X    yy_did_buffer_switch_on_eof = 1;
X    }
X
X
X#ifdef YY_USE_PROTOS
Xvoid yy_load_buffer_state( void )
X#else
Xvoid yy_load_buffer_state()
X#endif
X
X    {
X    yy_n_chars = yy_current_buffer->yy_n_chars;
X    yytext = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
X    yyin = yy_current_buffer->yy_input_file;
X    yy_hold_char = *yy_c_buf_p;
X    }
X
X
X#ifdef YY_USE_PROTOS
XYY_BUFFER_STATE yy_create_buffer( FILE *file, int size )
X#else
XYY_BUFFER_STATE yy_create_buffer( file, size )
XFILE *file;
Xint size;
X#endif
X
X    {
X    YY_BUFFER_STATE b;
X
X    b = (YY_BUFFER_STATE) malloc( sizeof( struct yy_buffer_state ) );
X
X    if ( ! b )
X	YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
X
X    b->yy_buf_size = size;
X
X    /* yy_ch_buf has to be 2 characters longer than the size given because
X     * we need to put in 2 end-of-buffer characters.
X     */
X    b->yy_ch_buf = (YY_CHAR *) malloc( (unsigned) (b->yy_buf_size + 2) );
X
X    if ( ! b->yy_ch_buf )
X	YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
X
X    yy_init_buffer( b, file );
X
X    return ( b );
X    }
X
X
X#ifdef YY_USE_PROTOS
Xvoid yy_delete_buffer( YY_BUFFER_STATE b )
X#else
Xvoid yy_delete_buffer( b )
XYY_BUFFER_STATE b;
X#endif
X
X    {
X    if ( b == yy_current_buffer )
X	yy_current_buffer = (YY_BUFFER_STATE) 0;
X
X    free( (char *) b->yy_ch_buf );
X    free( (char *) b );
X    }
X
X
X#ifdef YY_USE_PROTOS
Xvoid yy_init_buffer( YY_BUFFER_STATE b, FILE *file )
X#else
Xvoid yy_init_buffer( b, file )
XYY_BUFFER_STATE b;
XFILE *file;
X#endif
X
X    {
X    b->yy_input_file = file;
X
X    /* we put in the '\n' and start reading from [1] so that an
X     * initial match-at-newline will be true.
X     */
X
X    b->yy_ch_buf[0] = '\n';
X    b->yy_n_chars = 1;
X
X    /* we always need two end-of-buffer characters.  The first causes
X     * a transition to the end-of-buffer state.  The second causes
X     * a jam in that state.
X     */
X    b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
X    b->yy_ch_buf[2] = YY_END_OF_BUFFER_CHAR;
X
X    b->yy_buf_pos = &b->yy_ch_buf[1];
X
X    b->yy_eof_status = EOF_NOT_SEEN;
X    }
X# line 137 "dgn_comp.l"
X
X
X/* routine to switch to another input file; needed for flex */
Xvoid init_yyin( input_f )
XFILE *input_f;
X{
X#ifdef FLEX_SCANNER
X	if (yyin)
X	    yyrestart(input_f);
X	else
X#endif
X	    yyin = input_f;
X}
X/* analogous routine (for completeness) */
Xvoid init_yyout( output_f )
XFILE *output_f;
X{
X	yyout = output_f;
X}
X
END_OF_FILE
if test 36124 -ne `wc -c <'sys/share/dgn_lex.c'`; then
    echo shar: \"'sys/share/dgn_lex.c'\" unpacked with wrong size!
fi
# end of 'sys/share/dgn_lex.c'
if test -f 'sys/share/sounds/firehorn.uu' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'sys/share/sounds/firehorn.uu'\" to \"'sys/share/sounds/firehorn.uu.orig'\"
  mv -f 'sys/share/sounds/firehorn.uu' 'sys/share/sounds/firehorn.uu.orig'
fi
echo shar: Extracting \"'sys/share/sounds/firehorn.uu'\" \(18370 characters\)
sed "s/^X//" >'sys/share/sounds/firehorn.uu' <<'END_OF_FILE'
Xbegin 644 Fire_Horn
XM``E&:7)E($AO<FX`````````````````````````````````````````````
XM``````````````````````````!!249&4V0R80$``!H`SP```````#$B```!
XMSJ<]K<2G/:W+``````````````````````````````"!@2)]``!&3U)-```Q
XM&D%)1D934TY$```O'@``````````````````````````````````````````
XM````````````````````````````````````````````````````````````
XM````````````````````````````````````````````````````````````
XM````````````________________________________________________
XM________``````````````#_____````````````````````````________
XM__________________\```````#___\``@(!_OK]``$!_0`&`_[Y]/7Y^OG\
XM!`@!]N_S``4```P9(!P)]>[R]/+T]P0*^_O__@#X]/X0'QX3`^WL]^SD[OH"
XM`/3LY^7JY.P/("<H#0$(#@WZ_!<C,C8@&`[[^_X#%2LS(@P"]^GGYN?^$`L,
XM!_CLYO3\`QXF%/_Z__+L\_,%(2,;&0?U_@#W!!DH(@7PYN#BTL?:YNOZ]^;9
XMU-/;[O+MZ.7?U-[AP+S8Y>OQ[>CH[_#P`Q,1"``%!_[]].ST_P'Z\>[N[_8`
XM_PT:`?;^]?C_]OP.(2\H%PH2("`J,BLT,!DA,!X+"`<1(1\#X=74V.?S_0@&
XM_N[0N[B]S=[O`Q06_>3G\@@?)SA$/28,_O'Q`0\<+S,D$?7:U.?MZO\3$@3R
XMX<S`P\[H!146"/;IZOL.(#)*4SHA$0/[_@TA+3$Q'P#JZ_/N\?G\`OC>S<6X
XML;G4`!D7#@#\`@H>-DI985D_'0\0#`P5*3HY,1CV[_'GX>[T^`'YY]+`OKB]
XMX/L$_N73S\K0W^WY!1`4#P/NW=KI^OX!`.;-R\S/V.'BY_;HR;FSLK"[W/+Z
XM^>GG[.3D\0`'#!($\NOCZO@%&BHH'A,-!?OV]?8!&B(/]>;>W-W6U^SX[-O3
XMU=K@Z?<1*B\;`_?U``T*#R`H(Q+][N3CY^O_%!L9!N[AY_7V_Q8?'QT2!@#^
XM`0PA+R\@`_/]"A0<+$%!.S,<#@?^_`D?+"PI%O;EYN_["Q,(^_#CW-S?Y?L>
XM+B\U)@L"`@0'$R<B$07]^?+Q]P4D-2L5\=3*S-_S^P,'"/SKZ>KK\?<$$0_^
XMXM'0UN?^$AXD(1D-`?;U`1$N3$XX&?KEX_D0'2D@"?GCRL#*VN\/)1X-^N;<
XMWNCT_@@*`_OOX-'*T^X+'!X3_]_'Q,G7[P0-$0W[[.[MWN0!#PX/`^OJ^0(0
XM'B@Q.#8@!_GP[/H7)B8E&@;Z]?3R[>[T`0;OX.3CW.7]"R`\*04#`OCW]^_J
XM\.W9SM+-RN(#"@+WX=_T^N_H[?'S"!0!\O/T\?/_!?[SX]KG^?W\`@4'!?GS
XM_00$"!HL,"@7#10I,QX,$A43&B`>%@W_^0XG*1T0"Q`=*28>*C0E%@KXZ^/5
XMS=SN[>+:UMKP`OOZ"@X'!PH-$`P.&"U`-R4?%PL(#A`6*"\C&Q8%\>#,Q=KJ
XMX]KCZ>+O`OK]#`P*$QL2_>[=U.D'(CHW&?OV_?KX_@`""PKZ[N?;U-KBY>CK
XMY.+R]^OI[_/]#0GNX^WV]_+R^`()_>[S_/P"#!(:(!<)_O;O[_7X]O+JV<W0
XMT]7E\/8+%0C\]_/V_PT:)BXG&1`)_P(8(B(D$O'?V]#%R\_.U-/&O\/%N[[5
XMXN\`^^OFZ_#U_?[^_?#EY_#Y^P$5)BTK%/7JYN#G\/+S[NGH[O3Q\P,3'!L4
XM"?COY^+T%2@F*2\?%18/#1$>-T,W)!,(!0T?,3(D$O_V\^KL^P<2'2(<"_KM
XMZP`G.S`B&`?^``8,&2\Z/#TQ%OKHY?`&'B,7`O/IXM_A\`03&18/`_7KZ?@5
XM*3(S)10(`0@8'R$I-#<Q'@/NY>SW_0H-`//GXN3H\@$,$0X"[N7D[`89&A@1
XM"`(#"!$D+B8C)!\8$@L%#!89$@'NW=?@[OL&#`?[\^;3S\_.V>OW\^+5UM[A
XMY>[_$Q,$]=S&R]74W.[X^^_5Q,'(V^SS^P$#__;OYN#:W_X9&0+IUL_H_/?[
XM`P+X[O/VZ^3AX_'Y[]?$P\;,T]C?Z>WFW=G=Y>KP\_7WZM#&U.L#%!<0#`C\
XM\_'NY^GX`/WWZ-3*TN#L^0'Z[.+AY_,#!@@3'!H.`/7MZ_`$'BHE'1P<'",L
XM)RDW,A\+^.;@ZO+W#2(:"0/__0,,$!4F,B8/_>OB\?T&&B8:`?7PZ.;H\0H@
XM)"`9$/[EV.,`(B8/!0T-_P$.&C9(-RPN)QT+\_,-)"DI+S@X*!X>)34X*2`C
XM)B(6#1<K)A<2#!0=&ATD-DA#/#LU(PT*#B$Y,B0C'Q@0"@4'%!</`?+MX,O#
XMP]GS[-_;VM?%L;31\``/$?K@SKVQON+U]?T$__CPX]KF^@@5$?/9SLW.T-CH
XM\?/RYM3*S=#6ZP8A*1'UZO/_]?$"%1P1`/7R[.?T"1PN)@7Q\_+H[``7*BD7
XM"0'UY]O?]1D^1";]YM[5V?,/(!L)!`7_\N+E_ATD#?#=VM3)UNG^'!D`^_[U
XMZ>7M`1HE%?ST^_?R_P@1'1<'^OS]]OD"#AD0[<.OKK;+X?'Z_??FVL_#T>P!
XM%A\?&/O8LJ;']1$7#P7_^-[&T_0-%!43^,^VL;W9_A<>(B09!?/T!QXY2$8[
XM*`7>V@4O.3@W)Q("Z]O;Z`(?,SP['_'2T.L+&1PA*RD.[^X%'#%"2DM(+P#>
XMX?L7+3@T*!D(^/@$"!0L+AD!X<:[P]OO_08&!/;?VN?Z"QLP03H@"/KY$#!)
XM54X[&/3K^0X;%@X2&0C@O**IOLS@[.WHT+JRN]3D[0$8'`GVY,K$U.H'(281
XM\NKW!`T0$!DE'P3JV<_+TND!#@T`]?'W^_3Q\@$0#@@&"Q,1#B)-8$(3]/8.
XM%PX%_P8+`>_H]OGJZ^[JZN_OZ?+]_/X#_.OM^.WM_?GM]0L."Q@.!",[.3$G
XM'A81"OOU^?OS\??LV=7D`A03#P@!_?G]`@<1("HD'!\@(B4?'RDV.BX:`.SQ
XM_?;O^P@![-O+O,/;]`0&`_3>U=/=\/O]_/+<Q+JVM<SL"2(O,2,,_/+U`@P1
XM#0L,_.G8R=3R%C0O%/WLX=SI_@D6(!0#`@P#[_,!%S(S'P\`]/7]!A0?&Q45
XM#/KLZ_0'*3HN&@D$^?`((S([*0GTZMW2X/,!(30K'QD.`PX@'AD5`>ODXM7$
XMR^4"&Q7^\>KEW^+^'"$6"_KKZ>CDX_(/'QT8"?3O\O@&#PL(!_CGX.'HY^CT
XM`0?[XLG"UNX&'"$;"_'8R,3+U.3Y%2\R&P8'%2(N,R@<&A,#]O7X]?L,%QP-
XMZM7:[?7T`Q44"P$"$Q;]V<SD_`/WX=WL^?CM]0T5$0D!`PC_Z>/R!A4&Z>L$
XM&A8(&#([+AD8'AL1_?4+)3`H&!TT.S`B&!L:__,"#PW_\O4&$`P$^?H&"Q(<
XM(RH@"@D9'!$$^?<##PH"`0,&!`$#"Q4._OK]_??JZ/8!!/OU\.'B[_H,%!,+
XM^_'MXM''S>'X!PT%[-G>[_OX\/#FV]O/Q='=X>+=YOCNU,G(U>S\`0,#^NWN
XM]O7O[_7\"A#^Y]G6Y/+T]0(-!0+_ZNX)$1$;)B@@&1<>)B<L-4$_)QL=%@P,
XM#`H3'A3^]OX)$182$14*]NWK[_H*%!`+!/S[]/$%$!$@*A\0#@C]_@<7+3DO
XM'A4*__K\``4+#`3V[/+MW=C?\P'W[>??W-KD_08'#0?\]?3NW^#V#A82#@D-
XM$0\6&A4)^O3HW^;EZ?@(#O[IX-?7V^H*'1@*!`0$#1,2'2XS*2$8"/?GX_$*
XM&`#DW=G<ZNSJ]@<.#0'U_`+OYO<0'!0'`@(*%`\!_P4)%!H;(!T1%2PU)A0)
XM^>GD[.WG]/GM]?CEV^'?V^X!]N7BYN/F^`0'!0`!"`P+"`/Z!!TC&`/LY-[7
XMW^;@Y.O@U-7,P\S0R=#G[^7>WM;0W.39VN\`$1L7$@X)"QTM)QL:$/_[_OGQ
XM]P82&A\6`/7NY_0%!/___?GY]_H"^_P-%1@9$P#GY@(5#@XC)Q\>#O?^$QHD
XM.#XS)!$""!X@#`@6'QT2^-O<Z.O_&"`C&@'W!R0Q(QP=$@;^[]WE]_;[%"4<
XM"O[R]@L+^_T!]O/__>;?Y_,,)BL@'R(?)"XH'!TC%@,#`O+M_`8+%!<'\O(!
XM"Q0<$P+X[-_C[-W)T>?Y"A<0__X&"APN)`X!]NGJY]#/ZOT#_??Y]O'W_PL;
XM&@/MXN/]%/_DZ_C[^?;S]?T&#18F)Q8,"A$;$_SS_@X1#0D,#@<4,3(?$0+N
XMZ?D&!?SU^000%Q`-"`85(AX8&0??U>/FY.'<V][@VM?E\/,)'@KR^?CAW.[_
XM!/WP[OO\[.?V!A8F'/[U_O38T>K\\=W*N;J^L:_.[?H+$O[O[=S`Q^X'_^;9
XMX.WZ].H`)"TA#O7Q_O/7U_L9#.[I[.OJV<OJ$A@9)!+X\>'-W@LG%?7JY^3A
XMX.+P!A(:'1``^.WI_A<6_//^`?;Q]/4#%QTJ0#\A!O7P`A<;"OX.&0T1(R@G
XM*2XU,"$-_?S\^__TW>#Y!P@.%0'Q_PH9+2,.#0[]\@@6!O\+$!8G+1X?+#$\
XM.B47%A4)!104^_+\]_4'!_#J_PP1'!H*_.W;T]OEW-;D[?+\`O\&&B`6$`;P
XMV<S+V>OJUM+G\^KCW,_1Z/7_%R(-\N+=]1@4^_H/$P#U]_T/)C0Q+"X;_/3S
XM`!D9!_\'#`3X[>7E^`T-$1X4^_'Y`@3_^/D($1$-"0D'$"HP%O?DVM'/U=KG
XMZ>;IV]7H[]_<^A(2$P_\\O+Q]?\&_O7\].;N^OD#'"@J*!/X[?+W^/CTY^?U
XM[=G=V\7(X^SN!AH&[N??W^#8U>'[#!,7%14;("(O1$(I&A$&`O7@Y/X4(RDA
XM#O;BW-_L"1T6#Q01`-_)S=CB[?H$_>34U>#V"@X'%"$0]MW#M\7?\PL>%/GB
XMW./C]A$+$"$5^^7=Y>_X"!XW/2D0!`D;*"$5$PS^]NO@Y.WZ#!@8#@<$^_?X
XM`A,.^>_T_OSV]_X-%A$1'"DN+2<L2U`M%0X#_?WUZ_'_`_/J\^_N___Y$Q_X
XMU\[!PM#6Y/P,!_;^%!XF)Q\F03T)Z>/7UMK:\@P%]OCX\_GZ^0((#@O_!/G?
XMW./L`Q+^ZP`+``85'24V.A\4'A0`^?3S"B`1`Q(;%Q,2$!,6"@86$/'<T,_N
XM&"`-"1@5!`4*#Q80#Q49$._6U][?X?,'$Q($`00`!/KBZ`D>!-G-U-++T^\+
XM(RD7#A,6$`,%'#=#,Q/WZ=S"M<?F_/?GZO'GU\G%W@@9_=_4Q*V>JM3Z"Q8?
XM*C(>_N[W$2,H(AD0\<FZO]'H_Q$:'!3]Y-K?X_<<(@KMR:VHM,C2S^<-$@;[
XMZ>'T!081)2(+\-/$TNOP\!4W*A86"P`(`OX;(_S;TL_<]`$!"B@O%!0M+R<J
XM)2<X*`/W^O'N^/CT_0L&Z=WGZ.OMY0(C`M3/W^OV!Q(E-R\C(B4N-CDY16-?
XM+Q`'^_CYZN?_"_SZ`P4/%1,<+3HN">C6R]/CZO\9%A<G)QX;&A\I*1H'__GL
XMW=KJ]?7JX.KT\.[HXO86$007$.C/N:K"Y>G8TN'W!@D!`B(^+A\B(!4`X-#P
XM$0;U]P0(^.[S_`\@'QPG)PCHT];Z"0('"Q,:$@7_"!PF*RP>#0#PW=WU^N_O
XM]P4&_/C]_P`'#Q@H*!/][N?BZ?\*"Q,2!P8+!P87*BL=%`X#\]K.S<G+S<S0
XMV>/>W.SZ_/+EXM_1NJRSP=+FZ>S^!_?K]`,:,"8."Q((\NSZ!P@"]>CI[>;>
XMW_$,"OT!`O74N+2]SMG4W>KNZMO<]`XC*2<A%0GRV^'Z!OOR_/[LX>7R`1LV
XM-"<@&`OZ^0L9'2,G*B<@&1,3&2$P/#8@#0'Y_@L3$@L)"?WOZN[Z!@4)%0W[
XM`0H&!P\0$187#P@&`@03'RTZ-R84#PX,#`8#"`+NWM_HZ^WT`!0>$//@XM_7
XMWNKX!@3Z_`@0"_T!%2(C&PP)$0P!`@@.$@?LX.GJW=OG\@`&]NW_"_?E[O?T
XM\?'P^Q,;$0\1&20?%A,>(1`.'1T3!_?U`@D&!PT0"P$$!O;^&!86)B(1`?3R
XM]OL'%!\:`//U[N\"$`X8)P[MZN+:Z/3X^_OOW-38V];A_0@)!>_AYM_7Y/L*
XM$0P`_0,(`?D/*R@@%//:ULBYS_7\]N[6Q\G/R\?6YN;@TL;-U=;>`!P7#PL'
XM$!$&`0TN2$(G%`K^\.#D!!P2]^3@W=?8W>X/$^[4S,&^OL'<!!0$\N[O\O7Z
XM`A0H'PH+#0'_^_$`&!<,"`/\]>WR`0H0#PP+`??[^/<4,283$PL+&1@A+R<C
XM)RXV*1P@'109&0D&"?CT!`@2(10"!`H![O`%$1(5&!47%0T8*C1*4CDO-"<8
XM#PD3(AH,!?OV]/'R]0,1`^?;V]S;T]+M`/L&$@?X[>CR`Q,;&!,1#@T-"0H0
XM`/,##?GL[_8""`0+%@KY^_WNY.GLW=7K^.GL^O\.%@P0&1()`P()$AD9#`P>
XM'`3]!Q@H(Q4>*A7\^OT!`._>U=;F\.?A[@#^]@4;&PC]_@01"OC\_?D%`N_M
XM]O3GY_T2%0S\\P$$W\G8X^?N[.?N_O_N[0HF)A(!!`KNQ\+*TN'HXN/NZM?)
XMT.O[].KI[^O/M+?(T=OG\OW]\>GA[!,G&Q,7&A+YY_'Z\?8%#141`O+G]`\8
XM%1<3!?3<Q,'#PM#B[>K9W.?K`1LA(B(/_OGOZ_L"_0PE)`OW^@(%$2(J.4$C
XM$!,#]?O\`2`R'0/\`@8#%CQ485(D#0P"_P<!`AH<!/+K[_#I^!HV2D8M)283
XM_?3R_Q$-"0T-$Q`"$C]94SLC'1P*\^GM]?CU]/7\"`#L^A<3#1,+"Q(%\>CG
XMYN7CY.GN^/;K_A48(B`/%1@(!0G_\.KKZ^_W^O3V"`G\`@<``0$%#?O@U]K=
XMX^GK[O/[#1H8("`,"0@#"@7Y]_3T]O/V!Q<<'Q\8'1\5%1(4$O3F\?3U^?+R
XM`0;\!!HF-#DE%`X']^7CX^'?UL_;[N;;[0`(&R4>(B47`.3:U\_7Z/0!_.7@
XM]Q(>*2XH)!7YX,_0U,_/T]WNZM/-VN7H[/;U[.GHWL_.S\G,W.ORZ^'E\@08
XM)S4],!8'^^GL_``$"0+QX=K?[/H$"`S^V\;/VMOCY-G:X-S;V-/?]A`F.D<S
XM$0'[[N;X!0(%^.7L\.?N!B,R/D8P$0,$"@X9)"(0^?<"`?T#%3%-5U(^'@P*
XM`P,3'Q@!Z>'EYNS["1\R+2XI$/[S\/H(#/?;T]SK\_@)'#5'04=$(PX.#Q`9
XM$_';V-WH\?G^!10._P8&]?#S\?/^\-+&P\[E]``+#Q47'C4X*2(@(2(<"_;I
XMXN?U_@8/"P'S\@(#^_T"`P,'!/#CVN'X`@@%]_P$#"`D&!04#0+]]>OJ\@DD
XM,2\8!0P-#Q\9#!(4`NKHZN+CY>T%$@KW[OL&#2(J(B4@`^_QZMG6V-WT"`#N
XMZO7W`B$J(2(6^^?9R,+/UN8$"OOT]@`'%RPQ+R8/^.[JV<K3W>K]^>'.RLO(
XMUO#_`?CLY=O-O+[8ZO<*"??M[?<#%"\W*R$6"O_RY^3M^0(-#__NYN/@Z/S_
XM^/7O[.?@U,O4XNX!`^[DY>CU#1X:#PG__/SJV-_K[?\<(143$A0A)RLN*2,<
XM%0T`]>_J\`$:(0X(#ADL,#`T*1X?(!\.^.WJ\`0:&@T-$1,8$QDF&0<'"@?Z
XMY]7.X/\=)QX=)BPK*38^+!4/%1D0]=?2Y/@+#_[W^O'G[/?_]NOR^_?CR+W%
XMT.4&%A8=&@8$%B@H%@H0&Q<`ZM[F]P,3'QP4_NKN_`D+`O\-&PSNV];;Y_83
XM)2$7`N_U#1\B&!0:%@;NX_,`!!,I+"`9">_T"!$4"P+_].32P\K?Z_H:*AH-
XM`_+^'C$[.B@9"O7?S=#D]`<<%/WZ[=KL"A8C)`KRY]S'N<+8\0\@%@L4$@82
XM)R\V+0OR[>38V>+N_`'\\>?@T<35]0@0`N37U,:ZO\_D^P/W[O<'"`,3+3,H
XM%/WV_/GL\0@9(A@"^?KTY>+W#Q(']-S/T,S&UN_OZ>OEW^7O\OL:)Q4)_N??
XMWMC?\@8,"`7U\0$,#A@L+A@1">[FY-_G^PL,$10*"A$4'S9-33TT*!,'`/L"
XM"P@%#A$&`@8-%2$M*AL:&@?Z\NOKZNOP``D%#!4:*CI&13,I(A4/"P8#!0@*
XM$`L!!P@&!/\)$0#U\^?;U]#"P='>Z>OI^@L*"A`A*1H)_/@``/CV_`8)"P;^
XM!PT"^?T*"?[[]_CYZMO8W^GN\.OP!PP"`Q$C*B0:$0P$_/H`!P4&!P`&%Q$#
XM!A<B&0L%`OGKV]7;X^GQ^_T!#A`,%!\H)20L*!+VYN;K\O3T^??V`/_[_PP:
XM%P\3#??CVM+0UMC?Z.;H^`,!!Q8@(2`E)Q;]\.ON^``$_NC7Y.[GY^WR]?/M
XMW\Z_N[_%TN'HY-G>]P@(#1PE)1\6$@GV[/#^%"<E#_CK[?C[_P@0$`<`^^S9
XMT-'6YOCQW-'4X_3\"1L?$P4'#@?PV]ST#Q8)^._O^081)C@U(A,2$0?UX^7]
XM%1D)^._O`Q89*3@P(1L;'R`4__D$%"$?$0'X`@P-&R8:#0<&!0+[[.#@[/O]
XM\>7F^Q<D)20>&147'2`>$P/_"A@6!_SU_0H!_`<'^>GBYNGCTKZ]U>OKY./L
XM!!<3#Q88$`3Z`Q,2`O/R!1D;!_?V_@'TZ_8"!@+]!`X$Z]O:Y//W\._S]_KY
XM_@@-$A`3)BL5__CY``D0#@P.#`D$_P(*#@P'!P+PW-+8Z?D$!PD)"`T-"A,;
XM(RDD'!0,`/?^"Q8B(QP1"0?_^/X)&R06`_WWY]G@[O<"!__[!`H#_@<3(RTE
XM&!(-_?']#1`,`??Y^O+CVN+L\?'DUMC4Q</1Y.WHX>'J]?OX]@42$`;]^OKU
XM\_D,'AT._??\^_SZ]0`'^O'R[>'8T=_[`_/?U-3:WNCU^@$$^O/U]_3O[P,9
XM'!4)_OK]`@X6$!`2"`0'!OKN\?P'#0D!^?/V_@\A'148&AH8%A,.#A(7&1P@
XM&`T'"!H@!_D!`?GX^/7V]_;[!0H+!_OV`A(2`/L#`@0-$AHA%P<'%1P?'0\'
XM"@T`[.KP[.7CZ//WY=GA[??^`/O[!PO_\_H`]^_S^P,)`OCZ!1$9'!4*`/GS
XM[O7_\^3H[>WLY./O_`0#`/CIX^7HZ_X4$04("`$`_OK]"QD@*B<.^?3R]@PA
XM%/_]^.OGYN+K`1$9(!D#]O?X^Q(N*Q@0"08,"0<-%B,R.#`="?SS\@4@&O[Q
XMY^#DZ.WZ#Q\@(!@(_O/O^!$K(0+W]?;]_OT)&!H4$Q$'^>36W/H2`M_/S,S/
XMS];L_?[W^/OV[N+9Z@D6`N?AXN;M[/()&!0+#A`*`?'J]@H3`.+3T=/5U.+]
XM`OCR[^WIX-33Z`0-_NGBXM_D\/T0&QD0"PX,`OCX!1(;$_OP[NOM[_8*&AD1
XM$1(/#`@(#ATN)@\)"P@'!081'2,A&AH9$`8$"0X/`_'L[_'T\O0%%1<1$142
XM#/_X_P8,!O3P``H&_O\*#@\.#0\1"?GX`?[X[=[?[O3JXN;N^`'__08(]^_]
XM"07\\>7K``;\^`$*"Q`6%181_O4%$P?WZM?7Y^SI[?3Z_@,+"P?^\?0/)R(2
XM!_GQ]OK]`@,$#!<=&0W]]0`8*",5"?;I[//[`?S[!Q,:%`/S[_\7)209"_KL
XMZ?+_"08%#1D?&@W]]`$8)R48`^;/S=GL^_T!"Q`/"O[PZ_4*&QX7!>S?X^_[
XM!@@$"`T,!OONY^W["`L"[]2]NLO<Y^KJ[>[Q\_#KZ.S["`?]\^7:W^_\!@D'
XM`@('!@0&!PL4%PS\[]S'R-[R_O_X[^OLZN?M^`$+#P3U[^73U_('$`\%_?K]
XM^?#Y#!8?(1("__3>W?$`"0D!_/CU[NCY#A8<(!@+"`+S]0H7%A`/$`\+!@86
XM*"LD'A('`O;H\0(%!0<'#0X'`@(+&!,*"P3[_P,!!1`0!P'^``+^_0$(#Q$,
XM`_CO\/7W^?WU[.GHZO#S]?L#!@/_]^GAZ_L$"@P(__;S\O/W_``)$A41`^S=
XMX._X^O__]NSGZ?+_!P8*$1(/!O/F[?T#!@L*"`/_`@<-$Q$5'2`B'@[_!1$.
XM"0T,`O?Q\_H#"`(!!@8&!?OW`Q,3#PX(`/SY^P,0%A(4%@X*"OWR_0H$_@#\
XM]._IZO8&#P\)`/7R\^WJ_`X0#@T%_?GR[?0`!`+^]>_MZ^;E\O_Y\?#NZ^;;
XMV.GZ_O[Y[>3@V=7=\?_\]/+U^?7O\/H#!@8$``#]\_/_#`\%]_#R]/#L[_?^
XM`@'\].SDW^H!$!0*_/;X^OC[!0P-#`H)!?[V\@(<*286`OCX\_/_!PL0$A$1
XM#0'S\0(8)"8;"@/_^?L&#Q,4%1<8$P/V]P06)241_?;R]/\.%!`0#PP-!_OR
XM]`$/&AP/`?KS\P$+"`0#^_K^^?#M]`(,%!<*^?'J[/T,$`X'_?K[]>_M\/D%
XM#0P$^/'O\?\*!@,"^_?W\N_R\_G___[YZ=_>Y?H$__OW\>[MZ^_U]?C^_/[^
XM]/+X!!$4#0<%`_\```,)"0T4$`T*`/T!"!,6"@0%_//X`0P6%0\+`?S\^/D"
XM#!88#PD'`?T``@0(!@,%_O/O[O'X!!`2#`P.`_;W_``("PH,!_SX]_H`!`@%
XM_?\"^?3U\>_T]/3Z^/#P]OO]_@0#_/T!_/GX\N_S]/7Y[^;N]_\$!`<%^_L#
XM!`<-"00%`O[ZZ^/M^@8-"P@#]>[Q]OO^^OD!!0'][^3M^P</#@T,`/;X_@$#
XM!08+"P<!\.?S_0<4$Q`/!_X!!PX1#`L2%`\'^>_T^@0.#`D(`?P"#!(0#`P0
XM#P;]]._Z`@80$`P(_/8`#1(2"@,$`??S\O'Z`00(`_GRZ.OZ!@X.!@(%_^WH
XMZ^WX!0H,"P7Z[_#[!PX/"@4!^NWM\_8!"@L-"?[RZO#]"1$3#0H)_>KBX-SF
XM]/K]^_7OZNWX`@8$`?[Y\>SO\_0!#0L%_?/N[_0`"PT*!@#^_/?Y_?T$#PX&
XM_?H``P0.&R`<%0P&`/K\`0$'#@7UZN?N]?P(%AL4#`/^__[]__X'$`7W\/+^
XM"`L4'A\8#@4#`?T!!P8+#P+QY>/L]?P&#Q`(__GV]O?\`?X!!?GKYN;P_P@-
XM#PL#_?K[_/G_"@D*#0#PZNGP_`((#Q$+`P`!_OT#!OWZ_.[AY.CQ`@T.#0L'
XM`P$```$#!/_^_O+IZ>CM_`$!`P,!``$#!`4("00"`OGQ\_<!#A05%!`.$!$/
XM$!$,!0'_^_+L[?+[!@L,#`H*#0T.$1$.#@D!^_#FZ._Y`PH2%`T)"0H,#@P%
XM`O_\^.W?W.+J\/C^_O\!`/\!`?WX]_?V^?/JZ_'U^P`#!@@+#`T3%1`)!?[Z
XM_?KQ[^_P\_+O[_;_`P@-"P7\\^[M[^_M\?/S^/OV^0('"@X4%Q((_O;S]?7V
XM^OOY_?SU]OT$#!4?)"`6#`8%!0(#"0H'"@H&!Q$9'"(G*2(4!P'\]O+S^/OY
XM^_SW^/\#!@T4&A<)__KW]O7U^/K[_@,%!@P7'A\?'QL-`?SW\O#P\/#N[O+R
XM[_+\!0H,#0P#]O#N\/3U]/'P\?3T\O<%$A<9&14+__CS\/'S\O#N[N_P[_'^
XM"0\1$A`'^.[K[?'W^/;V^?S\^_X'$QD9&A<,`/CT\_3V\_'Q\_7T\_8`"@\0
XM$Q40!?[Z^?O__?KX^?W_``80&1T<&10+`/KU\/#S]??Z^OO[^P$)#Q(3$@X'
XM_OGX]O?Z^OGZ^_S[^0,1%QL=&!0+_/3PZ^OMZNGM\/+R\?@&#`X/"@3_^??W
XM]OCZ^/;U\O3X^?\,$Q<:%A`(_OK\^/3U\_#P\//W^/\*#Q(3#P@`]_7X]/'S
XM\_+R\/+T]/H$"Q$5$0P(_O?W]O7[__SZ^O\!_P,+$18;&QD5#`4%`P$&"`4#
XM!`<(!PL3&1X?&A<3!OKX]O;[_?KY_04'`?X%"@T-#`T,`OGX^/G\^_CZ`0D+
XM!PH1%143#@X0!OCS\O/S\>SL\_K]_/T#!0(`_?X!^O+U^OO[]_#N\/7Z^P$*
XM#`L*!P<'_O7U]O?U[^GJ[_+V^?P"!04%`@#^]O+U^?O\^_?V]OC\_?\%!P8'
XM!P8"_/?W]O7V]/'Q\?+X_?X``@4)"PH(`P`"`0```?_]^_X%"0@*#`P.#@L&
XM`/[^_?O[^_K[_@('"@D)"`8&!P@'!`$"`?\``?_]_P,)#@\/$`\.#`@#_OGV
XM]/+R]/7T]/;[_OW_`0$#!0,"__S[^_K[_?W[^/?[`00%!@<+#0H%`/KX]_;V
XM^?W]_/K\``$"!0<*"P@&`OOV]/+S]_OZ]_7X_/\"!`<+#`H(`_SW]?/S]?CZ
XM^OO^`0$#"`T1$1`0#PL%`O\``@4'!@8*#`L-$!`1$0\.#`7^^O?V]_G\_?O]
XM`0(#!08&!@4&!P+]^OCX^/K]__\#!P<'"@H)!P,#`_WT\._N\//U]//U^?S]
XM_P$#!`'___WY]_7R\O?\^_G[_P(%"`H-#@P)!?_X\_+R\_?[^_GY^_T``P0&
XM!@0#`P'\^?CX^?S^_OX!`P,"!@H.#@P*!P/]^/7T]?CZ^?G[_@`#"`L-#Q`.
XM"@8"``#^^_S_`0$#!@<("PP+"PD&`__Z]_?V]OCZ^?C]`@0$!PD)"0<$`@#\
XM^OO[^?K[^/;[`@4&!PD)"`7^^_GU\_/S\_7V\_#T^_W^`00("P@"__WZ^/CY
XM^?O^^OC]`P8&!PH-#PP&`?WX]?/R\O;Z^?G^`P4#`P4("@@%!`/_^_KY^/?W
XM]_G^`P,!`0,%!`(!``#]^/7T\O#R\O3[!`<'!PD+#`L)"`D)"`<%`P$!```%
XM#1`0#@T,"04#`0$"`0$!_OOZ^/K_!@H+"PH)"`4`_?W^_O[^_/W__?P!"`P-
XM#`L*!P+\^/?X^/CX^/?V]//V_/\!`@($`P'^^OGY]_;W^/G[^_O_!0@("`D+
XM"@8`_/KX]/#P\?/U]??]`0("`0(#!`,!`/[[^/?V]?;Y^_X#!P8$!`0#`@#_
XM_O[]^/7S\_3V^?T#"0L*"`D+"@@("0D(!@+^^_O^`0,%"0L+"@D(!P4%!`,#
XM`?_]_/S^_P(%"`D'!04'!0#\_/[]_/KY^/G\_/T"!P@&`P,$`_[Y]_;V]?/Q
XM\/+V]_;X_?___?X"`P'__?S[^??W^/G\_P$#!00"`0,'!@'^_/GV\N_P\_;Z
XM_?[_`0'^_@`$!@0#`@#]^?7T]/;Z_O\``@(``/\``0```/[Z]O3S\_7Z_P,%
XM!@4%!`0$!@4%!@8$!`,"`@,%"`D*#`L*"0D*"@D(!P,!__SZ^OS_`P8%`P,$
XM!`,$!`,#`__]_?W\_?X!!`8&!@8'!P8$`P$`__OX]O7U^/G[_P$!`/___P$#
XM!`0$`__[^OGY^OP``P4%`P("`0``__\`__SY]_3R\_7X_0`````!``#__O[_
XM`/[\^OGX]_?X^_W^_P$"`@+__?S]_?S[^OGX]_?X^_X``00%!04%!`,!````
XM``$!`0("`P,"`@0&!P@'!@,!`/_^_?S[^_W^_P$!``$"`P,"`@#^_?W[^OK\
XM_@`!`@,"__[^___^_?W[^_OZ^/;V]_G[_0``_O[___[\_?_^_O[^_?S\_/[_
XM`00$`@$"`P(`_O[]_/S\^_KY^?K[_/___O\!`@'____^_OW]_O[__P$"`@,#
XM`P0%!@8$`P,"__[^_O[]_?\``0("`0($!04#`P,#`@("`@(#!`<)"0H)!P8%
XM!`,#`@,#`@$!`?_]_/W_``(#`@,%!00!__________[^_OX``0,#!`4&!0,`
XM_?S]_/O\_?[^_?S\_/S[^_X!`P,!_OS[^OGY^OS^_O\``0$`_O\!`0$!```!
XM__W\^OK\_/W_`/_]_/W^___^_O\`__W]_/O[^_W_`0(````!`?_]_@`!`?_^
XM_/OZ^OS_`0("````__[\_/W_`0(#`@$````!`@0%!04$`P#^_?W^_P$"`0#_
XM_O\```$!`0(#`P'^_/S\_?W]_O___O[_______\``0#^_/O\_?W\_/S\_/X`
XM``#__OW]_OW\_/S\_?[^_____P`#`P,"`0$"`0#^_?W_`````/_]_/W_````
XM_OW^_OS[^_S^`0("`@(!_P`"`P0%!@8&!0+__?W_`0("`P(`_OX``0(#!`0$
XM!`'__?W_`@0%!@<'!00#`P,$!`0&!@,!__[^``,$!`0$`P("`@,#`P,#`P'_
XM_?S\_?[_``$!```````!```"`@#^_?S\_?[^_O[__OW]_O[^_?S\^_GX]_?X
XM^OS^_O[^_O[^_O[^_O[^_?OZ^?GY^OS^_O[]_?W]_O[^_O[^_OOZ^OO]_O\`
XM`/__``````$!`0$``/[]_/S^``$!`0#_``$"`@0%!00#`?[]_?[_`@0%!00"
XM`0(#`P,#`P,"`?_]_?X``0(#`P,"`0$"`@,#`P0#`?[\^_O\_?\`````__\`
XM``#__P#__OW\^_O[_/W^_O________[^_O____W\_/O[_/W_``$#`P0$`P(`
XM````___^_O[^_?W]_?W_``$!`0#__O____[^_O[^_P`````!`@,#`P(!`0``
XM`/_^_O\``0$`__\``0("`P,#`@$!`/___O[^``("`0$!`0("`0$!`0$!`/_^
XM_?W^_P```0$````````````!`0#^_?W]_O\````!`0(#`P,"`@$!`0$!````
XM``$``/___P`!`````/____[^_O[^_O[^_O[^_P`!`0#___[^_OW]_?[^__[^
XM_O[]_O\``0$``/_^_O[^_O[_`/_____^_P`!`0$!`@$`________````___^
XM_?X``````0$`__[^_?W^__\``0$``````````0("`0$`___^_P`!`@,"`0``
XM``#_``$!`@(!`/_^_O[_``$!`0$!`0#___\```$!`/_^_?S\_?W]_O[__OW]
XM_?W]_?W^_P#_______[^_P`"`@$!`0$`__[^_P````````#__O[^_P```0``
XM`/______``````#___\`_P`!`0$!``````````$!`0$`______\``0$!`0#_
XM_O[__P`!`@(!``#__P````$!`0$``/____\```$!`0```/\```````#_____
XM__\````````!`0$!`0$````````!`0$```#__O[______P``_________P#_
XM_____O[_``````#___[^__\```````#__O[^_P``````___^____``$!````
XM____``$!`0$!``````````$!`0$!`/___P`````!`````/___P``````````
XM````````_____P````````$!```````!````_____________________P``
XM_____O[^_O[^_O[____^_OW]_O[^___^_O[^_O[__O[______O[^_O__``#_
XM________````````_____O___P``__\````````````````````!`0``````
XM```````````````````!``````````$!`0$!````____````````_____P``
XM````````````````````____`````````````````0$!````____`````/__
XM________``````#_____````____________________________________
XM________________````_________P```````/____\`````________````
XM````______\`````_________P``````_____P```````/___P``````````
XM`````````````/__`````````````````````/______________________
XM______________\`__________\```````#_____________________````
XM``#__________P``````````````````____________````````````````
XM`````/____\`````````````````````````____````````````````_P``
XM````````````````````````____________````````````````````````
XM````````````````````````````````````````````````````````````
XM````````````````````0T]-30```!(``0``+Q8`"$`-K$0```````!-05)+
XM`````@``24Y35````!0\``!_`'\``````````````````$%04$P```&H4V0R
XM80`"````````````````````````````````````````````````````````
XM````````````````````````````````````````````````````````````
XM````````````````````````````````````````````````````````````
XM````````````````````````````````````````````````````````````
XM``````````````````````````````````(`````````````````````````
XM````````````````````````````````````````````````````````!`@`
XM``````D`(P````````````````!X````!``$````````_`#___^``````0$`
XM!E%5;FET<P````````````````````````````````````````$"``8@<V%M
XM<',`````````````````````````````````````````````````````````
XM```````G`"\`#__V__D``0``````````````````````````````````````
XM````````````````````````````````````````````````````````````
XM``````````````````````````````$````!>````'@```!6__3_\O_P_^[_
XM[/_H_^?_Y__N__@`!P`8`"@`-0`_`$4)1FER92!(;W)N`@```$%)1D939#)A
XM````````````````04E&1E-D,F$```````````````````````````````"G
XM/:W$```Q(@```<[_G_^L_\P``@!&`(P`R`#R`0D!#P$)`/P`Y0#'`*<`A@!E
XM`$0`)``$_^;_S?^[_Z[_J?^H_ZO_K_^R_[3_LO^P_ZS_J/^G_Z3_I/^C_Z3_
XMI?^I_[/_Q/_=__\`)0!.`'``BP"=`*0`I`"<`)``?P!J`%8`0P`Q`"``#P`!
XM__3_Z/_=````&@`I``\":@,Q`"H``P)M`ST`*0`/`D$#(@$`````&@`I``\!
XM4`'Q`"H``P)M`ST`````````````````&@`L`!8!/@'<`"H``P)M`ST`````
XM````````````&@`````````````````````````````````````!`````7@`
XM``!X````5@!QN+P<I@```!P`5@``5W-T80`#``H``?__`````````````O__
XM````'@```````___````/```````!/__````6@``````````````````````
XE````````````````````````````````````````````````````
X`
Xend
END_OF_FILE
if test 18370 -ne `wc -c <'sys/share/sounds/firehorn.uu'`; then
    echo shar: \"'sys/share/sounds/firehorn.uu'\" unpacked with wrong size!
fi
# end of 'sys/share/sounds/firehorn.uu'
echo shar: End of archive 21 \(of 31\).
cp /dev/null ark21isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 31 archives.
    echo "Now execute 'patchit.sh'"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
