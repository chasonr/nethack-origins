Subject:  v17i056:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Patch1o/31
Newsgroups: comp.sources.games
Approved: billr@saab.CNA.TEK.COM

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 17, Issue 56
Archive-name: nethack31/Patch1o
Patch-To: nethack31: Volume 16, Issue 1-116
Environment: Amiga, Atari, Mac, MS-DOS, Windows-NT, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 15 (of 31)."
# Contents:  patches01r
# Wrapped by billr@saab on Fri Mar  5 10:50:45 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'patches01r' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'patches01r'\" to \"'patches01r.orig'\"
  mv -f 'patches01r' 'patches01r.orig'
fi
echo shar: Extracting \"'patches01r'\" \(52863 characters\)
sed "s/^X//" >'patches01r' <<'END_OF_FILE'
X*** /tmp/da09102	Thu Feb 25 10:27:36 1993
X--- sys/amiga/wb.c	Wed Feb 24 20:25:19 1993
X***************
X*** 87,93 ****
X      ZapOptions( curopts );
X      InitWB( argc, argv );
X      SetupWB( ); /* open window, build menus */
X!     errmsg( NO_FLASH, "Welcome to NetHack Version 3.1!" );
X      CopyRight( );
X  
X      ReadConfig( );
X--- 87,93 ----
X      ZapOptions( curopts );
X      InitWB( argc, argv );
X      SetupWB( ); /* open window, build menus */
X!     errmsg( NO_FLASH, "Welcome to NetHack Version 3.1.1!" );
X      CopyRight( );
X  
X      ReadConfig( );
X***************
X*** 151,156 ****
X--- 151,157 ----
X  
X  	    case MENUPICK:
X  		do_menu( mimsg.Code );
X+ 		flushIDCMP( win->UserPort );
X  		break;
X  
X  	    case RAWKEY:
X***************
X*** 169,174 ****
X--- 170,176 ----
X  			    &Help2_IntuiTextList8 );
X  		    }
X  		}
X+ 		flushIDCMP( win->UserPort );
X  		break;
X  
X  	    case CLOSEWINDOW:
X***************
X*** 190,195 ****
X--- 192,198 ----
X  
X  	    case MOUSEBUTTONS:
X  		do_buttons( &mimsg );
X+ 		flushIDCMP( win->UserPort );
X  		break;
X  	    }
X  	}
X***************
X*** 250,255 ****
X--- 253,267 ----
X      cleanup( 0 );
X  }
X  
X+ void
X+ flushIDCMP( port )
X+ 	struct MsgPort *port;
X+ {
X+ 	struct Message *msg;
X+ 	while( msg = GetMsg( port ) )
X+ 		ReplyMsg( msg );
X+ }
X+ 
X  void CopyRight( )
X  {
X      extern char *copyright_text[];
X***************
X*** 325,331 ****
X  		case 'c':       /* Configuration to load */
X  		    if( i + 1 < argc && argv[i][j+1] == 0 )
X  		    {
X! 			strcpy( NetHackCnf, argv[ ++i ] );
X  			goto nextargv;
X  		    }
X  		    else
X--- 337,343 ----
X  		case 'c':       /* Configuration to load */
X  		    if( i + 1 < argc && argv[i][j+1] == 0 )
X  		    {
X! 			strcpy( StrConf, argv[ ++i ] );
X  			goto nextargv;
X  		    }
X  		    else
X***************
X*** 371,377 ****
X  		    fprintf( stderr, "%s: invalid option %c\n",
X  			argv[0], c );
X  		    fprintf( stderr,
X! 			"usage: %s [-m] [-f name] [-c name][ -N screen] \n",
X  			argv[ 0 ] );
X  		    cleanup( 1 );
X  		}
X--- 383,389 ----
X  		    fprintf( stderr, "%s: invalid option %c\n",
X  			argv[0], c );
X  		    fprintf( stderr,
X! "usage: %s [-m] [-f .def filename] [-c config filename] [ -N screen]\n",
X  			argv[ 0 ] );
X  		    cleanup( 1 );
X  		}
X***************
X*** 402,408 ****
X  
X  	    if( s = FindToolType( tools, "CONFIG" ) )
X  	    {
X! 		strcpy( NetHackCnf, s );
X  	    }
X  
X  	    /* A different set of defaults then 'wbdefaults.def' */
X--- 414,420 ----
X  
X  	    if( s = FindToolType( tools, "CONFIG" ) )
X  	    {
X! 		strcpy( StrConf, s );
X  	    }
X  
X  	    /* A different set of defaults then 'wbdefaults.def' */
X***************
X*** 445,453 ****
X  
X      /* If the file is not there, can't load it */
X  
X!     if( ( fp = fopen( NetHackCnf, "r" ) ) == NULL )
X      {
X! 	errmsg( FLASH, "Can't load config file %s", NetHackCnf );
X  	free( buf );
X  	return;
X      }
X--- 457,465 ----
X  
X      /* If the file is not there, can't load it */
X  
X!     if( ( fp = fopen( StrConf, "r" ) ) == NULL )
X      {
X! 	errmsg( FLASH, "Can't load config file %s", StrConf );
X  	free( buf );
X  	return;
X      }
X***************
X*** 468,474 ****
X  	}
X  	else if( strnicmp( buf, "PENS=", 4 ) == 0 )
X  	{
X! 	    setoneopt( PENS_IDX, buf + 4 );
X  	}
X  	else if( strnicmp( buf, "OPTIONS=", 8 ) == 0 )
X  	{
X--- 480,486 ----
X  	}
X  	else if( strnicmp( buf, "PENS=", 4 ) == 0 )
X  	{
X! 	    setoneopt( PENS_IDX, buf + 5 );
X  	}
X  	else if( strnicmp( buf, "OPTIONS=", 8 ) == 0 )
X  	{
X***************
X*** 545,550 ****
X--- 557,564 ----
X      NewScreenStructure.Width = GfxBase->NormalDisplayColumns;
X      NewScreenStructure.Height = GfxBase->NormalDisplayRows;
X  
X+     NewScreenStructure.DefaultTitle = "WorkBench for V3.1.1 of NetHack";
X+ 
X  #ifdef  INTUI_NEW_LOOK
X      if( IntuitionBase->LibNode.lib_Version < 37 )
X      {
X***************
X*** 630,636 ****
X  
X  #ifdef  INTUI_NEW_LOOK
X      if( scrlocked )
X! 	strcpy( mytitle, "NetHack WB 3.1 - Select a GAME or press HELP" );
X      else
X  	strcpy( mytitle, "Select a GAME or press HELP" );
X  
X--- 644,650 ----
X  
X  #ifdef  INTUI_NEW_LOOK
X      if( scrlocked )
X! 	strcpy( mytitle, "NetHack WB 3.1.1 - Select a GAME or press HELP" );
X      else
X  	strcpy( mytitle, "Select a GAME or press HELP" );
X  
X***************
X*** 1056,1061 ****
X--- 1070,1076 ----
X  	Help3_NewWindowStructure10.Height += txtdiff;
X      }
X  
X+     Help3_NewWindowStructure10.Title = "Help for NetHack WorkBench V3.1.1";
X      Help3_NewWindowStructure10.Screen = scrn;
X      if( ( win = MyOpenWindow( &Help3_NewWindowStructure10 ) ) == NULL )
X      {
X***************
X*** 1111,1116 ****
X--- 1126,1134 ----
X  		    done = 1;
X  		    break;
X  
X+ 		case MOUSEBUTTONS:
X+ 		case INACTIVEWINDOW:
X+ 		case ACTIVEWINDOW:
X  		case GADGETUP:
X  		    lastdown = 0;
X  		    break;
X***************
X*** 1132,1138 ****
X  				win->BorderLeft,
X  				win->BorderTop + 2,
X  				win->Width - win->BorderRight - 1,
X! 				win->BorderTop + 2 +
X  				(lines*win->RPort->TxHeight) );
X  			    getline( fp, loff, line + lines - 1,
X  				buf, sizeof( buf ) );
X--- 1150,1156 ----
X  				win->BorderLeft,
X  				win->BorderTop + 2,
X  				win->Width - win->BorderRight - 1,
X! 				win->BorderTop + 1 +
X  				(lines*win->RPort->TxHeight) );
X  			    getline( fp, loff, line + lines - 1,
X  				buf, sizeof( buf ) );
X***************
X*** 1146,1151 ****
X--- 1164,1170 ----
X  			{
X  			    /* EOF */
X  			    DisplayBeep( scrn );
X+ 			    lastdown = 0;
X  			}
X  		    }
X  		    else if( lastdown == GADHELPBKWD )
X***************
X*** 1160,1166 ****
X  				win->BorderLeft,
X  				win->BorderTop + 2,
X  				win->Width - win->BorderRight - 1,
X! 				win->BorderTop + 2 +
X  				(lines*win->RPort->TxHeight) );
X  			    getline( fp, loff, line, buf, sizeof( buf ) );
X  			    Move( win->RPort, win->BorderLeft + 2, topline );
X--- 1179,1185 ----
X  				win->BorderLeft,
X  				win->BorderTop + 2,
X  				win->Width - win->BorderRight - 1,
X! 				win->BorderTop + 1 +
X  				(lines*win->RPort->TxHeight) );
X  			    getline( fp, loff, line, buf, sizeof( buf ) );
X  			    Move( win->RPort, win->BorderLeft + 2, topline );
X***************
X*** 1170,1175 ****
X--- 1189,1195 ----
X  			else
X  			{
X  			    DisplayBeep( scrn );
X+ 			    lastdown = 0;
X  			}
X  		    }
X  		    break;
X***************
X*** 1409,1415 ****
X  
X      /* Set the game name for the status command */
X  
X!     sprintf( gptr->gname, "NetHack 3.1 %s", gptr->name );
X  
X      /* Create a process for the game to execute in */
X  
X--- 1429,1435 ----
X  
X      /* Set the game name for the status command */
X  
X!     sprintf( gptr->gname, "NetHack 3.1.1 %s", gptr->name );
X  
X      /* Create a process for the game to execute in */
X  
X***************
X*** 1451,1457 ****
X      gptr->wbs->sm_Process = proc;
X      gptr->wbs->sm_Segment = gptr->seglist;
X      gptr->wbs->sm_NumArgs = 2;
X!     gptr->wbs->sm_ToolWindow = "con:0/0/350/50/Amiga NetHack 3.1";
X      gptr->wbs->sm_ArgList = gptr->wba;
X  
X      /* Fill in the args */
X--- 1471,1477 ----
X      gptr->wbs->sm_Process = proc;
X      gptr->wbs->sm_Segment = gptr->seglist;
X      gptr->wbs->sm_NumArgs = 2;
X!     gptr->wbs->sm_ToolWindow = "con:0/0/350/50/Amiga NetHack 3.1.1";
X      gptr->wbs->sm_ArgList = gptr->wba;
X  
X      /* Fill in the args */
X***************
X*** 2025,2031 ****
X  				ActivateGadget( gd, cwin, NULL );
X  			    break;
X  
X! 			case GADCONFLOAD: case GADCONFNAME:
X  			    ReadConfig( );
X  			    strcpy( StrPath, options[ PATH_IDX ] );
X  			    strcpy( StrHackdir, options[ HACKDIR_IDX ] );
X--- 2045,2054 ----
X  				ActivateGadget( gd, cwin, NULL );
X  			    break;
X  
X! 			case GADCONFNAME:	/* Do nothing... */
X! 			    break;
X! 
X! 			case GADCONFLOAD:
X  			    ReadConfig( );
X  			    strcpy( StrPath, options[ PATH_IDX ] );
X  			    strcpy( StrHackdir, options[ HACKDIR_IDX ] );
X***************
X*** 2036,2042 ****
X  			    break;
X  
X  			case GADCONFSAVE:
X! 			    errmsg( FLASH, "Save not implemented" );
X  			    break;
X  
X  			default:
X--- 2059,2136 ----
X  			    break;
X  
X  			case GADCONFSAVE:
X!         		    {
X!         		    	FILE *fp, *nfp;
X!         		    	char buf[ 300 ], *t, nname[ 100 ], oname[100], *b;
X! 
X!                                 setoneopt( PATH_IDX, StrPath );
X!                                 PutOptions( curopts );
X!                                 setoneopt( HACKDIR_IDX, StrHackdir );
X!                                 setoneopt( PENS_IDX, StrPens );
X!                                 setoneopt( LEVELS_IDX, StrLevels );
X!                                 setoneopt( SAVE_IDX, StrSave );
X! 
X!         			fp = fopen( StrConf, "r" );
X!         			if( !fp )
X! 				    fp = fopen( "NetHack:NetHack.cnf", "r" );
X!         			if( !fp )
X!         			{
X!                         	    errmsg( FLASH, "Can't open nethack.cnf" );
X!                         	    break;
X!                         	}
X! 
X!                           	t = dirname( StrConf );
X!                         	b = basename( StrConf );
X!                           	if( t[ strlen(t)-1 ] == ':' )
X!                           	{
X!                           	    sprintf( nname, "%snew_%s", t, b);
X!                           	    sprintf( oname, "%sold_%s", t, b);
X!                         	}
X!                      		else
X! 				{
X!                             	    sprintf( oname, "%s/old_%s", t, b);
X!                             	    sprintf( nname, "%s/new_%s", t, b);
X!                         	}
X! 
X!         			nfp = fopen( nname, "w" );
X!         			if( !nfp )
X!         			{
X!                         	    errmsg( FLASH, "Can't open new_nethack.cnf for write" );
X!                         	    fclose( fp );
X!                         	    break;
X!                         	}
X! 
X!         			while( fgets( buf, sizeof( buf ), fp ) )
X!         			{
X!         			    if( strncmp( buf, "PATH=", 5 ) == 0 )
X!         			    	fprintf( nfp, "PATH=%s\n",
X! 						options[ PATH_IDX ] );
X!         			    else if( strncmp( buf, "LEVELS=", 7 ) == 0 )
X!         			    	fprintf( nfp, "LEVELS=%s\n",
X! 						options[ LEVELS_IDX ] );
X!         			    else if( strncmp( buf, "PENS=", 5 ) == 0 )
X!         			    	fprintf( nfp, "PENS=%s\n",
X! 						options[ PENS_IDX ] );
X!         			    else if( strncmp( buf, "OPTIONS=", 8 ) == 0 )
X!         			    	fprintf( nfp, "OPTIONS=%s\n",
X! 						options[ OPTIONS_IDX ] );
X!         			    else if( strncmp( buf, "SAVE=", 5 ) == 0 )
X!         			    	fprintf( nfp, "SAVE=%s\n",
X! 						options[ SAVE_IDX ] );
X!         			    else if( strncmp( buf, "HACKDIR=", 8 ) == 0 )
X!         			    	fprintf( nfp, "HACKDIR=%s\n",
X! 						options[ HACKDIR_IDX ] );
X!         			    else
X!         			    {
X!         			    	fputs( buf, nfp );
X!         			    }
X!         			}
X!         			fclose( fp );
X!         			fclose( nfp );
X!         			unlink( oname );
X!         			rename( StrConf, oname );
X!         			rename( nname, StrConf );
X!         		    }
X  			    break;
X  
X  			default:
X***************
X*** 2061,2071 ****
X      MapGadgets( R_DISK, 1 );
X  }
X  
X  void menu_editdef( gametype )
X      int gametype;
X  {
X      register struct Window *cwin;
X!     int done = 0;
X      USHORT mcode;
X      long class, qual, code;
X      register struct IntuiMessage *imsg;
X--- 2155,2252 ----
X      MapGadgets( R_DISK, 1 );
X  }
X  
X+ void
X+ UpdateCnfFile()
X+ {
X+     FILE *fp, *nfp;
X+     char buf[ 300 ];
X+     char path=0,option=0,dir=0,pens=0,levels=0,save=0;
X+ 
X+     setoneopt( PATH_IDX, StrPath );
X+     PutOptions( curopts );
X+     setoneopt( HACKDIR_IDX, StrHackdir );
X+     setoneopt( PENS_IDX, StrPens );
X+     setoneopt( LEVELS_IDX, StrLevels );
X+     setoneopt( SAVE_IDX, StrSave );
X+ 
X+     fp = fopen( "nethack.cnf", "r" );
X+     if( !fp )
X+     {
X+         errmsg( FLASH, "Can't open nethack.cnf" );
X+ 		return;
X+     }
X+     nfp = fopen( "new_nethack.cnf", "w" );
X+     if( !nfp )
X+     {
X+         errmsg( FLASH, "Can't open new_nethack.cnf for write" );
X+         fclose( fp );
X+         return;
X+     }
X+     while( fgets( buf, sizeof( buf ), fp ) )
X+     {
X+         if( strncmp( buf, "PATH=", 5 ) == 0 )
X+ 	{
X+             fprintf( nfp, "PATH=%s\n", options[ PATH_IDX ] );
X+ 	    path=1;
X+ 	}
X+         else if( strncmp( buf, "LEVELS=", 7 ) == 0 )
X+ 	{
X+             fprintf( nfp, "LEVELS=%s\n", options[ LEVELS_IDX ] );
X+ 	    levels=1;
X+ 	}
X+         else if( strncmp( buf, "PENS=", 5 ) == 0 )
X+ 	{
X+             fprintf( nfp, "PENS=%s\n", options[ PENS_IDX ] );
X+ 	    pens=1;
X+ 	}
X+         else if( strncmp( buf, "OPTIONS=", 8 ) == 0 )
X+ 	{
X+             fprintf( nfp, "OPTIONS=%s\n", options[ OPTIONS_IDX ] );
X+ 	    option=1;
X+ 	}
X+         else if( strncmp( buf, "SAVE=", 5 ) == 0 )
X+ 	{
X+             fprintf( nfp, "SAVE=%s\n", options[ SAVE_IDX ] );
X+ 	    save=1;
X+ 	}
X+         else if( strncmp( buf, "HACKDIR=", 8 ) == 0 )
X+ 	{
X+             fprintf( nfp, "HACKDIR=%s\n", options[ HACKDIR_IDX ] );
X+ 	    dir=1;
X+ 	}
X+         else
X+         {
X+        	    fputs( buf, nfp );
X+         }
X+     }
X+ 
X+     /* Write any that weren't already in the file */
X+     if( !path )
X+         fprintf( nfp, "PATH=%s\n", options[ PATH_IDX ] );
X+     if( !levels )
X+         fprintf( nfp, "LEVELS=%s\n", options[ LEVELS_IDX ] );
X+     if( !pens )
X+         fprintf( nfp, "PENS=%s\n", options[ PENS_IDX ] );
X+     if( !option )
X+         fprintf( nfp, "OPTIONS=%s\n", options[ OPTIONS_IDX ] );
X+     if( !save )
X+         fprintf( nfp, "SAVE=%s\n", options[ SAVE_IDX ] );
X+     if( !dir )
X+         fprintf( nfp, "HACKDIR=%s\n", options[ HACKDIR_IDX ] );
X+ 
X+     /* Close up and rename files */
X+     fclose( fp );
X+     fclose( nfp );
X+     unlink( "old_nethack.cnf" );
X+     rename( "nethack.cnf", "old_nethack.cnf" );
X+     rename( "new_nethack.cnf", "nethack.cnf" );
X+ }
X+ 
X  void menu_editdef( gametype )
X      int gametype;
X  {
X      register struct Window *cwin;
X!     int done = 0, err;
X      USHORT mcode;
X      long class, qual, code;
X      register struct IntuiMessage *imsg;
X***************
X*** 2259,2271 ****
X  			    break;
X  
X  			case GADDEFLOAD:
X! 			    LoadDefaults( DefPlayerName );
X! 			    strcpy( DefOutFile, DefPlayerName );
X! 			    CopyDefs2Gad();
X! 			    UpdateTypes( cwin );
X! 			    sprintf( buf, "Game definition loaded from: %s",
X! 				DefPlayerName );
X! 			    errmsg( NO_FLASH, buf );
X  			    break;
X  
X  			default:
X--- 2440,2455 ----
X  			    break;
X  
X  			case GADDEFLOAD:
X! 			    err = !LoadDefaults( DefPlayerName );
X! 			    if( !err )
X! 			    {
X! 				strcpy( DefOutFile, DefPlayerName );
X! 				CopyDefs2Gad();
X! 				UpdateTypes( cwin );
X! 				sprintf( buf, "Game definition loaded from: %s",
X! 				    DefPlayerName );
X! 				errmsg( NO_FLASH, buf );
X! 			    }
X  			    break;
X  
X  			default:
X***************
X*** 2634,2639 ****
X--- 2818,2824 ----
X  			     * is displayed in the gadget.
X  			     */
X  
X+ 			    sp = gptr->dobj->do_ToolTypes;
X  			    strcpy( StrTools, *sp );
X  			    UpdateInfoWin( cwin );
X  			    break;
X***************
X*** 2804,2809 ****
X--- 2989,3000 ----
X  void SetGadgetUP( gad )
X      register struct Gadget *gad;
X  {
X+     if( gad->Flags & GADGIMAGE )
X+     {
X+ 	DrawImage( win->RPort, (struct Image *)gad->GadgetRender,
X+ 		gad->LeftEdge, gad->TopEdge );
X+     }
X+ #if 0
X      RemoveGadget( win, gad );
X      gad->Flags &= ~(SELECTED|GADGHIGHBITS);
X      gad->Flags |= GADGHIMAGE|GADGIMAGE;
X***************
X*** 2815,2820 ****
X--- 3006,3012 ----
X      gad->Flags |= GADGHNONE;
X      gad->Activation &= ~TOGGLESELECT;
X      AddGadget( win, gad, 0 );
X+ #endif
X  }
X  
X  /*
X***************
X*** 2824,2829 ****
X--- 3016,3027 ----
X  void SetGadgetDOWN( gad )
X      register struct Gadget *gad;
X  {
X+     if( gad->Flags & GADGHIMAGE )
X+     {
X+ 	DrawImage( win->RPort, (struct Image *)gad->SelectRender,
X+ 		gad->LeftEdge, gad->TopEdge );
X+     }
X+ #if 0
X      RemoveGadget( win, gad );
X      gad->Flags &= ~GADGHIGHBITS;
X      gad->Flags |= GADGHIMAGE|GADGIMAGE|SELECTED;
X***************
X*** 2835,2840 ****
X--- 3033,3039 ----
X      gad->Flags |= GADGHNONE;
X      gad->Activation &= ~TOGGLESELECT;
X      AddGadget( win, gad, 0 );
X+ #endif
X  }
X  
X  /*
X***************
X*** 2935,2941 ****
X   * Load a defaults file into global structures
X   */
X  
X! void LoadDefaults( player )
X      char *player;
X  {
X      FILE *fp;
X--- 3134,3140 ----
X   * Load a defaults file into global structures
X   */
X  
X! LoadDefaults( player )
X      char *player;
X  {
X      FILE *fp;
X***************
X*** 2950,2956 ****
X      {
X  	errmsg( FLASH,
X  	    "Can't open defaults, %s, in current directory", fname );
X! 	return;
X      }
X  
X      while( fgets( buf, sizeof( buf ), fp ) != NULL )
X--- 3149,3155 ----
X      {
X  	errmsg( FLASH,
X  	    "Can't open defaults, %s, in current directory", fname );
X! 	return 0;
X      }
X  
X      while( fgets( buf, sizeof( buf ), fp ) != NULL )
X***************
X*** 2986,2994 ****
X--- 3185,3198 ----
X  	    defgame.options = strdup( buf + 8 );
X  	}
X  	else
X+ 	{
X  	    errmsg( FLASH, "Invalid line in defaults file" );
X+ 	    fclose( fp );
X+ 	    return( 0 );
X+ 	}
X      }
X      fclose( fp );
X+     return( 1 );
X  }
X  
X  /*
X***************
X*** 3083,3088 ****
X--- 3287,3294 ----
X  
X      Defs_PlayerType.GadgetText->IText = players[ defgame.pltype ];
X      RefreshGList( &Defs_PlayerType, cwin, NULL, 1 );
X+     RefreshGList( &Defs_PlayerName, cwin, NULL, 1 );
X+     RefreshGList( &Defs_DefaultName, cwin, NULL, 1 );
X  }
X  
X  /*
X***************
X*** 3321,3331 ****
X  	    case ITEM_SETOPT:
X  	    case ITEM_RENAME:
X  	    case ITEM_DISCARD:
X- 	    case ITEM_COPYOPT:
X  		ino = MENUITEMNO( 1,i,NOSUB );
X  		OffMenu( win, ino );
X  		break;
X  
X  	    case ITEM_INFO:
X  	    case ITEM_SETCOMMENT:
X  		ino = MENUITEMNO( 1,i,NOSUB );
X--- 3527,3537 ----
X  	    case ITEM_SETOPT:
X  	    case ITEM_RENAME:
X  	    case ITEM_DISCARD:
X  		ino = MENUITEMNO( 1,i,NOSUB );
X  		OffMenu( win, ino );
X  		break;
X  
X+ 	    case ITEM_COPYOPT:
X  	    case ITEM_INFO:
X  	    case ITEM_SETCOMMENT:
X  		ino = MENUITEMNO( 1,i,NOSUB );
X***************
X*** 3808,3811 ****
X--- 4014,4032 ----
X      if( defgame.options )
X  	free( defgame.options );
X      defgame.options = strdup( ToolsEntry( gptr, "OPTIONS" ) );
X+ }
X+ 
X+ char *basename( str )
X+     char *str;
X+ {
X+     char *t;
X+ 
X+     t = strrchr( str, '/' );
X+     if( !t )
X+ 	t = strrchr( str, ':' );
X+     if( !t )
X+ 	t = str;
X+     else
X+ 	++t;
X+     return( t );
X  }
X*** /tmp/da09182	Thu Feb 25 10:28:16 1993
X--- sys/amiga/splitter/amiout.h	Mon Feb  8 13:48:57 1993
X***************
X*** 27,33 ****
X  #define HUNK_RELOC32	1004
X  #define HUNK_RELOC16	1005
X  #define HUNK_RELOC8	1006
X! /*#define HUNK_RELOC32s ???		/* ADOS 2.0 */
X  #define HUNK_DRELOC32	0x3f7		/* Lattice & ADOS 2.0 */
X  #define HUNK_DRELOC16	0x3f8		/* Lattice & ADOS 2.0 */
X  #define HUNK_DRELOC8	0x3f9		/* Lattice & ADOS 2.0 */
X--- 27,33 ----
X  #define HUNK_RELOC32	1004
X  #define HUNK_RELOC16	1005
X  #define HUNK_RELOC8	1006
X! #define HUNK_RELOC32s	0x3fc		/* ADOS 2.0 */
X  #define HUNK_DRELOC32	0x3f7		/* Lattice & ADOS 2.0 */
X  #define HUNK_DRELOC16	0x3f8		/* Lattice & ADOS 2.0 */
X  #define HUNK_DRELOC8	0x3f9		/* Lattice & ADOS 2.0 */
X*** /tmp/da09206	Thu Feb 25 10:28:22 1993
X--- sys/amiga/splitter/loader.c	Mon Feb 22 11:49:59 1993
X***************
X*** 8,14 ****
X  
X  /*#define LDEBUG	 	/* turn on debugging I/O */
X  #define SDEBUG		/* static primary array allocation */
X! /*#define NOCLEAN		/* turn off $ovl_memchain code */
X  /*#define NOSPLIT		/* debug: load an unsplit binary(run ONCE!)*/
X  #define MULTI			/* real file reading code */
X  /*#define PARANOID		/* check for refs off end that might be OK */
X--- 8,14 ----
X  
X  /*#define LDEBUG	 	/* turn on debugging I/O */
X  #define SDEBUG		/* static primary array allocation */
X! /*#define NOCLEAN		/* turn off ovl$memchain code */
X  /*#define NOSPLIT		/* debug: load an unsplit binary(run ONCE!)*/
X  #define MULTI			/* real file reading code */
X  /*#define PARANOID		/* check for refs off end that might be OK */
X***************
X*** 28,33 ****
X--- 28,37 ----
X  #include <proto/dos.h>
X  #include <proto/exec.h>
X  #include <dos.h>			/* NOT libraries/dos.h! */
X+ #include <setjmp.h>
X+ 
X+ jmp_buf jbuf;
X+ 
X  #include "amiout.h"
X  
X  #include "multi.h"
X***************
X*** 37,55 ****
X  
X  #define HT(x)	((x) & ~MEM_OBJ_EXTEND)
X  
X! void *$ovl_AllocMem(unsigned int);
X  void spanic(char *);			/* think about this!!!! */
X  void exit(int);
X  
X  #ifdef SDEBUG
X! unsigned long *$ovl_hunktable[500];	/* 223 as of 10/21/92 */
X  #else
X! unsigned long *(*$ovl_hunktable)[];
X! int $ovl_hunktablesize;
X  #endif
X  
X  #ifndef NOCLEAN
X! BPTR $ovlmemchain=0;
X  #endif
X  BPTR ovlfile=0;
X  BPTR fh;
X--- 41,59 ----
X  
X  #define HT(x)	((x) & ~MEM_OBJ_EXTEND)
X  
X! void *ovl$AllocMem(unsigned int);
X  void spanic(char *);			/* think about this!!!! */
X  void exit(int);
X  
X  #ifdef SDEBUG
X! unsigned long *ovl$hunktable[500];	/* 229 as of 2/3/93 */
X  #else
X! unsigned long *(*ovl$hunktable)[];
X! int ovl$hunktablesize;
X  #endif
X  
X  #ifndef NOCLEAN
X! BPTR ovl$memchain=0;
X  #endif
X  BPTR ovlfile=0;
X  BPTR fh;
X***************
X*** 74,79 ****
X--- 78,86 ----
X  	{
X  	static BPTR base;
X  	static char never=1;
X+ 
X+ 	if( setjmp( jbuf ) != 0 )
X+ 		return( NULL );
X  	if(never){
X  #ifdef LDEBUG
X  		fprintf(stderr,"s_LoadSeg waiting\n");
X***************
X*** 133,143 ****
X  	fprintf(stderr,"hunk count=%d\n",hc);
X  #endif
X  #ifndef SDEBUG
X! 	$ovl_hunktable= (long*(*)[])$ovl_AllocMem(hc*4);
X! 	$ovl_hunktablesize=hc*4;
X  #endif
X  #ifdef LDEBUG
X! 	fprintf(stderr,"table at %08x\n",$ovl_hunktable);
X  #endif
X  	Read(fh,&x,4);	/* F==0 */
X  	Read(fh,&x,4);	/* L==size-1 */
X--- 140,150 ----
X  	fprintf(stderr,"hunk count=%d\n",hc);
X  #endif
X  #ifndef SDEBUG
X! 	ovl$hunktable= (long*(*)[])ovl$AllocMem(hc*4);
X! 	ovl$hunktablesize=hc*4;
X  #endif
X  #ifdef LDEBUG
X! 	fprintf(stderr,"table at %08x\n",ovl$hunktable);
X  #endif
X  	Read(fh,&x,4);	/* F==0 */
X  	Read(fh,&x,4);	/* L==size-1 */
X***************
X*** 144,152 ****
X  	for(c=0;c<hc;c++){
X  		Read(fh,&x,4);
X  #ifdef SDEBUG
X! 		xx=$ovl_hunktable[c]=$ovl_AllocMem(x*4);
X  #else
X! 		xx=(*$ovl_hunktable)[c]=$ovl_AllocMem(x*4);
X  #endif
X  #ifdef LDEBUG
X  		fprintf(stderr,"t[%d]=%08x, len=%08x\n",c,xx,((long*)xx)[-2]);
X--- 151,159 ----
X  	for(c=0;c<hc;c++){
X  		Read(fh,&x,4);
X  #ifdef SDEBUG
X! 		xx=ovl$hunktable[c]=ovl$AllocMem(x*4);
X  #else
X! 		xx=(*ovl$hunktable)[c]=ovl$AllocMem(x*4);
X  #endif
X  #ifdef LDEBUG
X  		fprintf(stderr,"t[%d]=%08x, len=%08x\n",c,xx,((long*)xx)[-2]);
X***************
X*** 158,173 ****
X  	for(c=0,xp=(unsigned long*)1;xp;c++){
X  #ifdef LDEBUG
X  # ifdef SDEBUG
X! 		yy=$ovl_hunktable[c];
X  # else
X! 		yy=(*$ovl_hunktable)[c];
X  # endif
X  		fprintf(stderr,"loading hunk %d@%08x len=%08x\n",c,yy,yy[-2]);
X  #endif
X  #ifdef SDEBUG
X! 		xp=load_hunk(fh,dummy,$ovl_hunktable[c]);
X  #else
X! 		xp=load_hunk(fh,dummy,(*$ovl_hunktable)[c]);
X  #endif
X  	}
X  	database=c-1;	/* first hunk for use for data on each load */
X--- 165,180 ----
X  	for(c=0,xp=(unsigned long*)1;xp;c++){
X  #ifdef LDEBUG
X  # ifdef SDEBUG
X! 		yy=ovl$hunktable[c];
X  # else
X! 		yy=(*ovl$hunktable)[c];
X  # endif
X  		fprintf(stderr,"loading hunk %d@%08x len=%08x\n",c,yy,yy[-2]);
X  #endif
X  #ifdef SDEBUG
X! 		xp=load_hunk(fh,dummy,ovl$hunktable[c]);
X  #else
X! 		xp=load_hunk(fh,dummy,(*ovl$hunktable)[c]);
X  #endif
X  	}
X  	database=c-1;	/* first hunk for use for data on each load */
X***************
X*** 174,188 ****
X  	Close(fh);
X  #ifdef LDEBUG
X  # ifdef SDEBUG
X! 	fprintf(stderr,"retval=%08x\n",$ovl_hunktable[0]);
X  # else
X! 	fprintf(stderr,"retval=%08x\n",(*$ovl_hunktable)[0]);
X  # endif
X  #endif
X  #ifdef SDEBUG
X! 	r= (unsigned long) $ovl_hunktable[0];		/* BPTR to seglist */
X  #else
X! 	r= (unsigned long) (*$ovl_hunktable)[0];	/* BPTR to seglist */
X  #endif
X  	return (BPTR)(r>>2)-1;
X  }
X--- 181,195 ----
X  	Close(fh);
X  #ifdef LDEBUG
X  # ifdef SDEBUG
X! 	fprintf(stderr,"retval=%08x\n",ovl$hunktable[0]);
X  # else
X! 	fprintf(stderr,"retval=%08x\n",(*ovl$hunktable)[0]);
X  # endif
X  #endif
X  #ifdef SDEBUG
X! 	r= (unsigned long) ovl$hunktable[0];		/* BPTR to seglist */
X  #else
X! 	r= (unsigned long) (*ovl$hunktable)[0];	/* BPTR to seglist */
X  #endif
X  	return (BPTR)(r>>2)-1;
X  }
X***************
X*** 203,211 ****
X  			/* doing it this way we don't need the hunk count */
X  	for(c=database,x=(unsigned long*)1;x;c++){
X  #ifdef SDEBUG
X! 		x=load_hunk(fh,fl,$ovl_hunktable[c]);
X  #else
X! 		x=load_hunk(fh,fl,(*$ovl_hunktable)[c]);
X  #endif
X  	}
X  #ifdef LDEBUG
X--- 210,218 ----
X  			/* doing it this way we don't need the hunk count */
X  	for(c=database,x=(unsigned long*)1;x;c++){
X  #ifdef SDEBUG
X! 		x=load_hunk(fh,fl,ovl$hunktable[c]);
X  #else
X! 		x=load_hunk(fh,fl,(*ovl$hunktable)[c]);
X  #endif
X  	}
X  #ifdef LDEBUG
X***************
X*** 224,236 ****
X  	unsigned long data[2];
X  	unsigned long *where;
X  	unsigned long reloc_type;
X  
X  #ifdef LDEBUG
X  	{
X  	int pos=Seek(ovlfile,0,0);
X  	fprintf(stderr,"load_hunk (fpos=%08x) @%08x len=%08x(%08x)\n",pos,
X! 	lbase,lbase[-2],lbase[-2]/4);
X  	}
X  #endif
X  	if(0==Read(ovlfile,data,sizeof(data))){
X  #ifdef LDEBUG
X--- 231,251 ----
X  	unsigned long data[2];
X  	unsigned long *where;
X  	unsigned long reloc_type;
X+ 	static int lbufsize=680;	/* max xref in one hunk 347 2/3/93 */
X+ 	static unsigned long *lbuf=0;	/* load buffer */
X+ 	unsigned long *lbp;
X+ 	unsigned short *lbps;
X  
X+ 	if(!lbuf)lbuf=malloc(lbufsize*4);
X+ 	if(!lbuf)spanic("Can't allocate lbuf");
X  #ifdef LDEBUG
X+ # ifndef MULTI
X  	{
X  	int pos=Seek(ovlfile,0,0);
X  	fprintf(stderr,"load_hunk (fpos=%08x) @%08x len=%08x(%08x)\n",pos,
X! 		lbase,lbase[-2],lbase[-2]/4);
X  	}
X+ # endif
X  #endif
X  	if(0==Read(ovlfile,data,sizeof(data))){
X  #ifdef LDEBUG
X***************
X*** 240,246 ****
X  		return(0);	/* EOF */
X  	}
X  #ifdef LDEBUG
X! 	fprintf(stderr,"read type=%08x len=%08x(longs)\n",data[0],data[1]);
X  #endif
X  	if( HT(data[0])!=HUNK_CODE &&
X  	    HT(data[0])!=HUNK_DATA &&
X--- 255,261 ----
X  		return(0);	/* EOF */
X  	}
X  #ifdef LDEBUG
X! 	fprintf(stderr,"read type=%08x len=%08x\n",data[0],data[1]<<2);
X  #endif
X  	if( HT(data[0])!=HUNK_CODE &&
X  	    HT(data[0])!=HUNK_DATA &&
X***************
X*** 278,317 ****
X  #endif
X  	}
X  			/* link/relocate as needed */
X- 			/* NB this could be done faster if we keep a buffer of
X- 			 * relocation information (instead of issuing 4 byte
X- 			 * Reads)
X- 			 */
X  	xx=Read(ovlfile,&reloc_type,sizeof(reloc_type));
X  	if(xx!=sizeof(reloc_type))spanic("lost reloc_type");
X  	while(reloc_type!=HUNK_END){
X  		unsigned long reloc_count;
X! 		unsigned long reloc_hunk;
X  		unsigned long *base;
X  		unsigned long reloc_offset;
X! 		if(reloc_type!=HUNK_RELOC32){
X! 			if(reloc_type==HUNK_END)continue;	/* and quit */
X  			fprintf(stderr,"bad data %08x\n",reloc_type);
X  			spanic("ovlfile reloc cookie botch");
X  		}
X  		xx=Read(ovlfile,&reloc_count,sizeof(reloc_count));
X  		if(xx!=sizeof(reloc_count))spanic("lost reloc_count");
X! 		while(reloc_count){
X! 			xx=Read(ovlfile,&reloc_hunk,sizeof(reloc_hunk));
X! 			if(xx!=sizeof(reloc_count))spanic("lost reloc_hunk");
X  #ifdef SDEBUG
X! 			base=$ovl_hunktable[reloc_hunk];
X  #else
X! 			base=(*$ovl_hunktable)[reloc_hunk];
X  #endif
X  #ifdef LDEBUG
X  			fprintf(stderr,"reloc #%d: hunk #%d@%08x\n",
X! 			  reloc_count,reloc_hunk,base);
X  #endif
X  			while(reloc_count--){
X! 				xx=Read(ovlfile,&reloc_offset,sizeof(long));
X! 				if(xx!=sizeof(reloc_count))
X! 					spanic("lost offset");
X  				if(reloc_offset<0 || reloc_offset>where[-2]){
X  					fprintf(stderr,"where[-2]==%08x\n",
X  					  where[-2]);
X--- 293,345 ----
X  #endif
X  	}
X  			/* link/relocate as needed */
X  	xx=Read(ovlfile,&reloc_type,sizeof(reloc_type));
X  	if(xx!=sizeof(reloc_type))spanic("lost reloc_type");
X  	while(reloc_type!=HUNK_END){
X  		unsigned long reloc_count;
X! 		unsigned long reloc_count2;
X  		unsigned long *base;
X  		unsigned long reloc_offset;
X! 		unsigned long reloc_shift;
X! 		int hnum;
X! 		if(reloc_type==HUNK_END)continue;	/* and quit */
X! 		if(reloc_type!=HUNK_RELOC32 && reloc_type!=HUNK_RELOC32s){
X  			fprintf(stderr,"bad data %08x\n",reloc_type);
X  			spanic("ovlfile reloc cookie botch");
X  		}
X+ 		reloc_shift=(reloc_type==HUNK_RELOC32)?2:1;
X  		xx=Read(ovlfile,&reloc_count,sizeof(reloc_count));
X  		if(xx!=sizeof(reloc_count))spanic("lost reloc_count");
X! 
X! 		reloc_count2=reloc_count;
X! 		while(reloc_count){     /* fix indent */
X! 			if((reloc_count<<reloc_shift) >= (lbufsize*4)){
X! 				free(lbuf);
X! 				lbufsize=10+reloc_count;
X! 				lbuf=malloc(lbufsize*4);
X! 				if(!lbuf)spanic("Can't realloc lbuf");
X! 			}
X! 			xx=Read(ovlfile,lbuf,((1+reloc_count)<<reloc_shift));
X! 			if(xx!=((1+reloc_count)<<reloc_shift))
X! 				spanic("can't fill lbuf");
X! 			lbp= &lbuf[1];		/* 0 is reloc_hunk */
X! 			lbps= ((unsigned short *)lbuf)+1;
X! 			hnum=(reloc_shift==2)? lbp[-1]: lbps[-1];
X  #ifdef SDEBUG
X! 			base=ovl$hunktable[hnum];
X  #else
X! 			base=(*ovl$hunktable)[hnum];
X  #endif
X  #ifdef LDEBUG
X  			fprintf(stderr,"reloc #%d: hunk #%d@%08x\n",
X! 			  reloc_count,hnum,base);
X  #endif
X  			while(reloc_count--){
X! 				if(reloc_shift==2){
X! 					reloc_offset= *lbp++;
X! 				} else {
X! 					reloc_offset= *lbps++;
X! 				}
X  				if(reloc_offset<0 || reloc_offset>where[-2]){
X  					fprintf(stderr,"where[-2]==%08x\n",
X  					  where[-2]);
X***************
X*** 339,350 ****
X--- 367,386 ----
X  #endif
X  				}
X  			}
X+ 			if( reloc_shift == 1 && (reloc_count2 & 1) == 0){ /* longword align */
X+ 				short x;
X+ 				Read(ovlfile,&x,sizeof(x));
X+ 			}
X  			xx=Read(ovlfile,&reloc_count,sizeof(reloc_count));
X  			if(xx!=sizeof(reloc_count))spanic("lost reloc_count2");
X+ 			reloc_count2=reloc_count;
X  		}
X  		xx=Read(ovlfile,&reloc_type,sizeof(reloc_type));
X  		if(xx!=sizeof(reloc_count))spanic("lost reloc_type2");
X  	}
X+ /* BUG -
X+  * lbuf never freed
X+  */
X  	return(where);			/* return execute start point */
X  }
X  
X***************
X*** 354,360 ****
X  	 0	data
X   */
X  void *
X! $ovl_AllocMem(len)
X  	unsigned int len;
X  	{
X  	unsigned long *adr;
X--- 390,396 ----
X  	 0	data
X   */
X  void *
X! ovl$AllocMem(len)
X  	unsigned int len;
X  	{
X  	unsigned long *adr;
X***************
X*** 376,383 ****
X  	if(!adr)spanic("allocation failure");
X  	adr[0]=length;
X  #ifndef NOCLEAN
X! 	adr[1]=(unsigned long)$ovlmemchain;	/* list for freeing at end */
X! 	$ovlmemchain=((long)adr>>2)+1;	/* BPTR to next ptr */
X  # ifdef LDEBUG
X  	fprintf(stderr,"Alloc: adr[0]=%08x adr[1]=%08x\n",adr[0],adr[1]);
X  # endif
X--- 412,419 ----
X  	if(!adr)spanic("allocation failure");
X  	adr[0]=length;
X  #ifndef NOCLEAN
X! 	adr[1]=(unsigned long)ovl$memchain;	/* list for freeing at end */
X! 	ovl$memchain=((long)adr>>2)+1;	/* BPTR to next ptr */
X  # ifdef LDEBUG
X  	fprintf(stderr,"Alloc: adr[0]=%08x adr[1]=%08x\n",adr[0],adr[1]);
X  # endif
X***************
X*** 392,400 ****
X  	BPTR p,p1;
X  
X  # ifdef LDEBUG
X! 	fprintf(stderr,"starting Free loop: ovlmemchain=%x\n",$ovlmemchain);
X  # endif
X! 	for(p=$ovlmemchain;p;p=p1){
X  		p1=*(BPTR *)BADDR(p);
X  # ifdef LDEBUG
X  		fprintf(stderr,"Free(%x,%x)\n",BADDR(p-1),
X--- 428,436 ----
X  	BPTR p,p1;
X  
X  # ifdef LDEBUG
X! 	fprintf(stderr,"starting Free loop: ovlmemchain=%x\n",ovl$memchain);
X  # endif
X! 	for(p=ovl$memchain;p;p=p1){
X  		p1=*(BPTR *)BADDR(p);
X  # ifdef LDEBUG
X  		fprintf(stderr,"Free(%x,%x)\n",BADDR(p-1),
X***************
X*** 404,410 ****
X  	}
X  #endif
X  #ifndef SDEBUG
X! 	FreeMem($ovl_hunktable,$ovl_hunktablesize);
X  #endif
X  	return;
X  }
X--- 440,446 ----
X  	}
X  #endif
X  #ifndef SDEBUG
X! 	FreeMem(ovl$hunktable,ovl$hunktablesize);
X  #endif
X  	return;
X  }
X***************
X*** 415,421 ****
X  	char *s;
X  {
X  	fprintf(stderr,"s_LoadSeg failed: %s\n",s);
X! 	getchar();
X! 	exit(1);
X  }
X  #endif /* SPLIT */
X--- 451,457 ----
X  	char *s;
X  {
X  	fprintf(stderr,"s_LoadSeg failed: %s\n",s);
X! 	s_UnLoadSeg();
X! 	longjmp( jbuf, -1 );
X  }
X  #endif /* SPLIT */
X*** /tmp/da09214	Thu Feb 25 10:28:24 1993
X--- sys/amiga/splitter/multi.c	Mon Feb  8 14:10:28 1993
X***************
X*** 94,100 ****
X  			break;			/* comment, blank lines */
X  		default:
X  			if(line[0]==mfp->mfh_mo.r.mor_tag){
X! 				mfp->mfh_fh=Open(&line[1],MODE_OLDFILE);
X  				if(!mfp->mfh_fh){
X  					return -1;	/* error */
X  				}
X--- 94,103 ----
X  			break;			/* comment, blank lines */
X  		default:
X  			if(line[0]==mfp->mfh_mo.r.mor_tag){
X! 						/* allow blanks after tag */
X! 				char *file= &line[1];
X! 				while(*file && isspace(*file))file++;
X! 				mfp->mfh_fh=Open(file,MODE_OLDFILE);
X  				if(!mfp->mfh_fh){
X  					return -1;	/* error */
X  				}
X*** /tmp/da09230	Thu Feb 25 10:28:27 1993
X--- sys/amiga/splitter/split.doc	Tue Feb 23 09:38:23 1993
X***************
X*** 1,4 ****
X! 	Splitter			[split.doc 93/01/08]
X  
X  Usage:
X  	splitter [-Cc_prototype] [-Dd_prototype] [-ddir_prototype] binary
X--- 1,4 ----
X! 	Splitter			[split.doc 93/02/21]
X  
X  Usage:
X  	splitter [-Cc_prototype] [-Dd_prototype] [-ddir_prototype] binary
X***************
X*** 31,37 ****
X  preceed all D entries.
X  
X  Maximum output file size is 800K (819200 bytes) - this leaves just enough
X! space on an empty floppy for a small icon.
X  
X  Code file contents:
X  The first code file contains:
X--- 31,38 ----
X  preceed all D entries.
X  
X  Maximum output file size is 800K (819200 bytes) - this leaves just enough
X! space on an empty floppy for a small icon.  Note that splitter will not
X! break a hunk - VERY large hunks will result in files above the limit.
X  
X  Code file contents:
X  The first code file contains:
X***************
X*** 48,53 ****
X--- 49,60 ----
X  	[SASC5]
X  	lc -L splitter.c arg.c
X  
X+ CHANGES FOR 3.1.1:
X+ 	Faster loading by buffering offsets.
X+ 	Smaller files: splitter will now write out HUNK_RELOC32short
X+ 	relocation blocks whenever possible.
X+ 	Blanks may now be between the C/D and the file name in the .dir file.
X+ 
X  BUGS
X  	The present system for generating multiple files is a hack -
X  	multi.[ch] should be upgraded instead.
X***************
X*** 54,58 ****
X  
X  	Many optimizations for minimizing the size of the output file
X  	could/should/will be added.
X- 
X- 	Not tested with SASC 6.0 yet.
X--- 61,63 ----
X*** /tmp/da09238	Thu Feb 25 10:28:29 1993
X--- sys/amiga/splitter/split.h	Mon Feb  8 13:49:08 1993
X***************
X*** 7,15 ****
X   * Common definitions for binary file splitting and loading of split files.
X   */
X  
X! #define SVER	1	/* Basic file splitting capability */
X! /*#define SVER	2	/* */
X! /*#define SVER	3	/* */
X  
X  /* Nothing below this line should need to be modified. */
X  
X--- 7,14 ----
X   * Common definitions for binary file splitting and loading of split files.
X   */
X  
X! /*#define SVER	1	/* Basic file splitting capability */
X! #define SVER	2	/* emit HUNK_RELOC32s as appropriate */
X  
X  /* Nothing below this line should need to be modified. */
X  
X***************
X*** 17,24 ****
X   __SPLIT_H__SVER_MUST_BE_DEFINED
X  #endif
X  
X! #if SVER >= 2
X  	/* enable options */
X  #endif
X  
X  /* internal structures, etc */
X--- 16,24 ----
X   __SPLIT_H__SVER_MUST_BE_DEFINED
X  #endif
X  
X! #if SVER == 2
X  	/* enable options */
X+ # define EMIT_32s
X  #endif
X  
X  /* internal structures, etc */
X***************
X*** 176,181 ****
X--- 176,182 ----
X  extern void write_header(void);
X  extern void owrite(void*,long);
X  extern void owrite_long(long);
X+ extern void owrite_short(short);
X  extern void out_start(char *);
X  extern void out_stop(void);
X  extern void new_file(void);
X*** /tmp/da09246	Thu Feb 25 10:28:31 1993
X--- sys/amiga/splitter/splitter.c	Mon Feb  8 13:49:20 1993
X***************
X*** 293,298 ****
X--- 293,326 ----
X  	hunk *hp;listlist *ll;
X  	{
X  	block *bp;
X+ #ifdef EMIT_32s
X+ 	int x;
X+ 	ULONG *p;
X+ 		/* can we write the entire block with a HUNK_RELOC32s? */
X+ 	foreach(bp,&(ll->list),(block*)){
X+ 		if((((*hlist)[bp->b[1]]).h->hunknum)>0xffff)goto no_32s; /*no*/
X+ 		for(p= &(bp->b[2]), x=bp->b[0];x;x--,p++){
X+ 			if(*p>0xffff)goto no_32s;	/*no, offset too big*/
X+ 		}
X+ 	}
X+ 		/* yes */
X+ 	owrite_long(HUNK_RELOC32s);
X+ 	foreach(bp,&(ll->list),(block*)){
X+ 		owrite_long(bp->b[0]);
X+ 		owrite_short(((*hlist)[bp->b[1]]).h->hunknum);
X+ 		for(p= &(bp->b[2]), x=bp->b[0];x;x--,p++){
X+ 			owrite_short(*p);
X+ 		}
X+ 			/* force long alignment.  Not documented, but makes
X+ 			 * reading dumps easier */
X+ 		if((bp->b[0] & 1) == 0){	/* note hunknum also short */
X+ 			owrite_short(0);
X+ 		}
X+ 	}
X+ 	owrite_long(0);
X+ 	return;
X+ no_32s:
X+ #endif
X  	owrite_long(HUNK_RELOC32);
X  	foreach(bp,&(ll->list),(block*)){
X  		owrite_long(bp->b[0]);
X***************
X*** 360,365 ****
X--- 388,401 ----
X  }
X  
X  void
X+ owrite_short(literal)
X+ 	short literal;
X+ {
X+ 	short x=literal;
X+ 	owrite(&x,sizeof(x));
X+ }
X+ 
X+ void
X  owrite(where,len)
X  	void *where;
X  	long len;
X***************
X*** 390,395 ****
X--- 426,441 ----
X  	long literal;
X  {
X  	long x=literal;
X+ 	if((osize+sizeof(x))>SPLITSIZE)new_file();
X+ 	owrite(&x,sizeof(x));
X+ 	osize += sizeof(x);
X+ }
X+ 
X+ void
X+ owrite_short(literal)
X+ 	short literal;
X+ {
X+ 	short x=literal;
X  	if((osize+sizeof(x))>SPLITSIZE)new_file();
X  	owrite(&x,sizeof(x));
X  	osize += sizeof(x);
X*** /tmp/da09302	Thu Feb 25 10:28:45 1993
X--- sys/atari/tos.c	Tue Feb 23 11:25:37 1993
X***************
X*** 102,117 ****
X   * "meta" bit for it.  -3.
X   */
X  #define SCANLO		0x10
X- #define SCANHI		0x32
X- #define SCANKEYS	(SCANHI - SCANLO + 1)
X- #define inmap(x)	(SCANLO <= (x) && (x) <= SCANHI)
X  
X! static const char scanmap[SCANKEYS] = { 	/* ... */
X  	'q','w','e','r','t','y','u','i','o','p','[',']', '\n',
X  	0, 'a','s','d','f','g','h','j','k','l',';','\'', '`',
X! 	0, '\\', 'z','x','c','v','b','N','m' 	/* ... */
X  };
X  
X  /*
X   * BIOSgetch gets keys directly with a BIOS call.
X   */
X--- 102,116 ----
X   * "meta" bit for it.  -3.
X   */
X  #define SCANLO		0x10
X  
X! static const char scanmap[] = { 	/* ... */
X  	'q','w','e','r','t','y','u','i','o','p','[',']', '\n',
X  	0, 'a','s','d','f','g','h','j','k','l',';','\'', '`',
X! 	0, '\\', 'z','x','c','v','b','N','m',',','.','?' 	/* ... */
X  };
X  
X+ #define inmap(x)	(SCANLO <= (x) && (x) < SCANLO + SIZE(scanmap))
X+ 
X  /*
X   * BIOSgetch gets keys directly with a BIOS call.
X   */
X***************
X*** 232,240 ****
X--- 231,248 ----
X  void
X  get_scr_size()
X  {
X+ # ifdef MINT
X+ #  include <ioctl.h>
X+ 	struct winsize win;
X+ 
X+ 	ioctl(0,TIOCGWINSZ, &win);
X+ 	LI = win.ws_row;
X+ 	CO = win.ws_col;
X+ # else
X  	init_aline();
X  	LI = (*((WORD  *)(_a_line + -42L))) + 1;
X  	CO = (*((WORD  *)(_a_line + -44L))) + 1;
X+ # endif
X  }
X  
X  # define BIGBUF  8192
X***************
X*** 289,294 ****
X--- 297,304 ----
X  void
X  set_colors()
X  {
X+ 	static char colorHE[] = "\033q\033b0";
X+ 
X  	if (!flags.BIOS)
X  		return;
X  	init_aline();
X***************
X*** 298,303 ****
X--- 308,314 ----
X  		return;
X  	} else {
X  		colors_changed = TRUE;
X+ 		HE = colorHE;
X  	}
X  }
X  
X***************
X*** 304,309 ****
X--- 315,324 ----
X  void
X  restore_colors()
X  {
X+ 	static char plainHE[] = "\033q";
X+ 
X+ 	if (colors_changed)
X+ 		HE = plainHE;
X  	colors_changed = FALSE;
X  }
X  # endif /* TEXTCOLOR */
X*** /tmp/da09542	Thu Feb 25 10:29:52 1993
X--- sys/msdos/msdos.c	Wed Feb 17 09:51:36 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)msdos.c	 3.1	 93/01/05		  */
X  /* Copyright (c) NetHack PC Development Team 1990, 1991, 1992	  */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)msdos.c	 3.1	 93/02/16		  */
X  /* Copyright (c) NetHack PC Development Team 1990, 1991, 1992	  */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 128,142 ****
X   * "meta" bit for it.  -3.
X   */
X  #define SCANLO		0x10
X- #define SCANHI		0x32
X- #define SCANKEYS	(SCANHI - SCANLO + 1)
X- #define inmap(x)	(SCANLO <= (x) && (x) <= SCANHI)
X  
X! static const char scanmap[SCANKEYS] = { 	/* ... */
X  	'q','w','e','r','t','y','u','i','o','p','[',']', '\n',
X  	0, 'a','s','d','f','g','h','j','k','l',';','\'', '`',
X! 	0, '\\', 'z','x','c','v','b','N','m' 	/* ... */
X  };
X  
X  /*
X   * BIOSgetch gets keys directly with a BIOS call.
X--- 128,141 ----
X   * "meta" bit for it.  -3.
X   */
X  #define SCANLO		0x10
X  
X! static const char scanmap[] = { 	/* ... */
X  	'q','w','e','r','t','y','u','i','o','p','[',']', '\n',
X  	0, 'a','s','d','f','g','h','j','k','l',';','\'', '`',
X! 	0, '\\', 'z','x','c','v','b','n','m',',','.','?'	/* ... */
X  };
X+ 
X+ #define inmap(x)	(SCANLO <= (x) && (x) < SCANLO + SIZE(scanmap))
X  
X  /*
X   * BIOSgetch gets keys directly with a BIOS call.
X*** /tmp/da09606	Thu Feb 25 10:30:08 1993
X--- sys/os2/Install.os2	Thu Feb  4 10:39:38 1993
X***************
X*** 2,8 ****
X                                 on an OS/2 system
X               =====================================================
X                                  Timo Hakulinen
X!                           Last revision: 24 Jan 1993
X  
X  0.  Read this entire file before starting, and come back to the Notes below if
X      you have any problems.
X--- 2,8 ----
X                                 on an OS/2 system
X               =====================================================
X                                  Timo Hakulinen
X!                           Last revision: 4 Feb 1993
X  
X  0.  Read this entire file before starting, and come back to the Notes below if
X      you have any problems.
X***************
X*** 78,83 ****
X--- 78,88 ----
X      definitions there, because every compiler has its own way of declaring
X      the necessary system functions and data structures.  In general you
X      should prefer the compiler's offerings, if possible.
X+ 
X+     If you are going to compile the game on an HPFS drive, uncomment OS2_HPFS,
X+     which will enable the use of longer file names during compilation.  The
X+     generated executable will only use file names compatible with FAT drives,
X+     however.
X  
X      If you are using a 32 bit compiler other than GCC emx 0.8f or C Set/2 in
X      OS/2 2.x, force OS2_32BITAPI to be defined.  Otherwise it is defined only
X*** /tmp/da09614	Thu Feb 25 10:30:10 1993
X--- sys/os2/Makefile.os2	Thu Feb  4 10:39:29 1993
X***************
X*** 1,4 ****
X! #	SCCS Id: @(#)Makefile.os2	3.1	93/01/24
X  #	OS/2 NetHack 3.1 Makefile for OS/2 versions 1.x and 2.x
X  #	Copyright (C) 1990, 1991, 1992, 1993 Timo Hakulinen
X  #
X--- 1,4 ----
X! #	SCCS Id: @(#)Makefile.os2	3.1	93/02/02
X  #	OS/2 NetHack 3.1 Makefile for OS/2 versions 1.x and 2.x
X  #	Copyright (C) 1990, 1991, 1992, 1993 Timo Hakulinen
X  #
X***************
X*** 207,213 ****
X  #
X  #	GCC: max. reasonable GCC warning levels.  Can't use -Wall, because then
X  #	it would whine about all the zillions of unused declarations etc.
X! #	Even with these switch you'll get a lot of warnings, but they should
X  #	all be benign.
X  #
X  #	CSet/2: warning level 3.  The second optional parameter gives
X--- 207,213 ----
X  #
X  #	GCC: max. reasonable GCC warning levels.  Can't use -Wall, because then
X  #	it would whine about all the zillions of unused declarations etc.
X! #	Even with these switches you'll get a lot of warnings, but they should
X  #	all be benign.
X  #
X  #	CSet/2: warning level 3.  The second optional parameter gives
X***************
X*** 219,226 ****
X  #WARN	= #/W3 #/Kbper	# CSet/2
X  
X  #
X! #	GCC object format selection.  Upper line for standard OS/2 OMF
X! #	object format, lower for Unix style a.out format.
X  #
X  
X  #GCCO	= -Zomf -Zsys	# GCC OMF
X--- 219,226 ----
X  #WARN	= #/W3 #/Kbper	# CSet/2
X  
X  #
X! #	GCC object format selection.  The upper line for standard OS/2 OMF
X! #	object format, the lower for Unix style a.out format.
X  #
X  
X  #GCCO	= -Zomf -Zsys	# GCC OMF
X***************
X*** 241,254 ****
X  CL	=
X  
X  #
X! #	MSC, CSet/2: don't ignore case in symbols, no default lib search, stack
X! #	8KB, allow max 1024 segments in program.
X  #
X  #	GCC: likes a big stack.
X  #
X  
X  LFLAGS	= /noig /nod /stack:8192 /seg:1024 $(LDFLAGS)	# MSC, CSet/2
X! #LFLAGS	= /noig /stack:40000				# GCC
X  
X  #
X  #	Prepare for a debugger.
X--- 241,254 ----
X  CL	=
X  
X  #
X! #	MSC, CSet/2: don't ignore case in symbols, no default lib search,
X! #	stack 8KB, allow max 1024 segments in program.
X  #
X  #	GCC: likes a big stack.
X  #
X  
X  LFLAGS	= /noig /nod /stack:8192 /seg:1024 $(LDFLAGS)	# MSC, CSet/2
X! #LFLAGS	= /noig /stack:40000				# GCC OMF
X  
X  #
X  #	Prepare for a debugger.
X***************
X*** 386,398 ****
X  
X  #
X  #	Short / long file name selection for FAT and HPFS.
X! #	Only two files need consideration.
X  #
X  
X  GUIDEBOO = Guideboo	# FAT
X  PATCHLEV = patchlev	# - " -
X  #GUIDEBOO = Guidebook	# HPFS
X  #PATCHLEV = patchlevel	# - " -
X  
X  
X  #
X--- 386,400 ----
X  
X  #
X  #	Short / long file name selection for FAT and HPFS.
X! #	Only three files need consideration.
X  #
X  
X  GUIDEBOO = Guideboo	# FAT
X  PATCHLEV = patchlev	# - " -
X+ DATABASE = data.bas	# - " -
X  #GUIDEBOO = Guidebook	# HPFS
X  #PATCHLEV = patchlevel	# - " -
X+ #DATABASE = data.base	# - " -
X  
X  
X  #
X***************
X*** 422,439 ****
X  
X  #
X  #	If you have yacc and lex programs and make any changes, uncomment
X! #	the lowermost two lines and uncomment the others.  If you make
X! #	changes to the .y and .l files but prefer to process the files
X  #	separately elsewhere, activate the middle two lines, so your changes
X  #	don't get overwritten.
X  #
X  
X! #do_yacc : yacc_cpy	# use pre-generated files
X! #do_lex :  lex_cpy	#	- " -
X  #do_yacc : yacc_msg	# show message if changed
X  #do_lex :  lex_msg	#	- " -
X! do_yacc : yacc_act	# re-process files
X! do_lex :  lex_act	#	- " -
X  
X  #
X  #	If you don't have uudecode program, use the upper line.
X--- 424,441 ----
X  
X  #
X  #	If you have yacc and lex programs and make any changes, uncomment
X! #	the lowermost two lines and comment out the others.  If you make
X! #	changes to the .y and .l files but prefer processing the files
X  #	separately elsewhere, activate the middle two lines, so your changes
X  #	don't get overwritten.
X  #
X  
X! do_yacc : yacc_cpy	# use pre-generated files
X! do_lex :  lex_cpy	#	- " -
X  #do_yacc : yacc_msg	# show message if changed
X  #do_lex :  lex_msg	#	- " -
X! #do_yacc : yacc_act	# re-process files
X! #do_lex :  lex_act	#	- " -
X  
X  #
X  #	If you don't have uudecode program, use the upper line.
X***************
X*** 782,788 ****
X  $(OBJ)\monstr.o : $(CB)
X  	$(SRCCC)
X  
X! $(GAMEDIR)\data : $(DAT)\data.bas $(TEMP)\makedefs.exe
X  	$(TEMP)\makedefs -d
X  	$(CP) $(DAT)\data $(GAMEDIR)
X  	$(RM) $(DAT)\data
X--- 784,790 ----
X  $(OBJ)\monstr.o : $(CB)
X  	$(SRCCC)
X  
X! $(GAMEDIR)\data : $(DAT)\$(DATABASE) $(TEMP)\makedefs.exe
X  	$(TEMP)\makedefs -d
X  	$(CP) $(DAT)\data $(GAMEDIR)
X  	$(RM) $(DAT)\data
X*** /tmp/da09678	Thu Feb 25 10:30:27 1993
X--- sys/share/lev_comp.h	Wed Feb 17 10:11:53 1993
X***************
X*** 35,76 ****
X  # define LADDER_ID 279
X  # define STAIR_ID 280
X  # define NON_DIGGABLE_ID 281
X! # define ROOM_ID 282
X! # define PORTAL_ID 283
X! # define TELEPRT_ID 284
X! # define BRANCH_ID 285
X! # define LEV 286
X! # define CHANCE_ID 287
X! # define CORRIDOR_ID 288
X! # define GOLD_ID 289
X! # define ENGRAVING_ID 290
X! # define FOUNTAIN_ID 291
X! # define POOL_ID 292
X! # define SINK_ID 293
X! # define NONE 294
X! # define RAND_CORRIDOR_ID 295
X! # define DOOR_STATE 296
X! # define LIGHT_STATE 297
X! # define CURSE_TYPE 298
X! # define ENGRAVING_TYPE 299
X! # define DIRECTION 300
X! # define RANDOM_TYPE 301
X! # define O_REGISTER 302
X! # define M_REGISTER 303
X! # define P_REGISTER 304
X! # define A_REGISTER 305
X! # define ALIGNMENT 306
X! # define LEFT_OR_RIGHT 307
X! # define CENTER 308
X! # define TOP_OR_BOT 309
X! # define ALTAR_TYPE 310
X! # define UP_OR_DOWN 311
X! # define SUBROOM_ID 312
X! # define NAME_ID 313
X! # define FLAGS_ID 314
X! # define FLAG_TYPE 315
X! # define MON_ATTITUDE 316
X! # define MON_ALERTNESS 317
X! # define MON_APPEARANCE 318
X! # define STRING 319
X! # define MAP_ID 320
X--- 35,77 ----
X  # define LADDER_ID 279
X  # define STAIR_ID 280
X  # define NON_DIGGABLE_ID 281
X! # define NON_PASSWALL_ID 282
X! # define ROOM_ID 283
X! # define PORTAL_ID 284
X! # define TELEPRT_ID 285
X! # define BRANCH_ID 286
X! # define LEV 287
X! # define CHANCE_ID 288
X! # define CORRIDOR_ID 289
X! # define GOLD_ID 290
X! # define ENGRAVING_ID 291
X! # define FOUNTAIN_ID 292
X! # define POOL_ID 293
X! # define SINK_ID 294
X! # define NONE 295
X! # define RAND_CORRIDOR_ID 296
X! # define DOOR_STATE 297
X! # define LIGHT_STATE 298
X! # define CURSE_TYPE 299
X! # define ENGRAVING_TYPE 300
X! # define DIRECTION 301
X! # define RANDOM_TYPE 302
X! # define O_REGISTER 303
X! # define M_REGISTER 304
X! # define P_REGISTER 305
X! # define A_REGISTER 306
X! # define ALIGNMENT 307
X! # define LEFT_OR_RIGHT 308
X! # define CENTER 309
X! # define TOP_OR_BOT 310
X! # define ALTAR_TYPE 311
X! # define UP_OR_DOWN 312
X! # define SUBROOM_ID 313
X! # define NAME_ID 314
X! # define FLAGS_ID 315
X! # define FLAG_TYPE 316
X! # define MON_ATTITUDE 317
X! # define MON_ALERTNESS 318
X! # define MON_APPEARANCE 319
X! # define STRING 320
X! # define MAP_ID 321
X*** /tmp/da09702	Thu Feb 25 10:30:37 1993
X--- sys/share/pcmain.c	Sun Feb 21 16:41:36 1993
X***************
X*** 1,8 ****
X! /*	SCCS Id: @(#)pcmain.c	3.1	92/12/04	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X! /* main.c - MSDOS, OS/2, ST, and Amiga NetHack */
X  
X  #include "hack.h"
X  
X--- 1,8 ----
X! /*	SCCS Id: @(#)pcmain.c	3.1	93/02/07	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X! /* main.c - MSDOS, OS/2, ST, Amiga, and NT NetHack */
X  
X  #include "hack.h"
X  
X***************
X*** 39,44 ****
X--- 39,47 ----
X  #ifdef AMIGA
X  extern int bigscreen;
X  #endif
X+ #ifdef AMII_GRAPHICS
X+ extern unsigned short amii_initmap[8];
X+ #endif
X  
X  static void FDECL(process_options,(int argc,char **argv));
X  
X***************
X*** 104,109 ****
X--- 107,115 ----
X  	ami_argc=argc;
X  	ami_argv=argv;
X  #endif
X+ #ifdef AMII_GRAPHICS
X+ 	memcpy(flags.amii_curmap,amii_initmap,sizeof(flags.amii_curmap));
X+ #endif
X  	initoptions();
X  
X  #if defined(TOS) && defined(TEXTCOLOR)
X***************
X*** 160,174 ****
X  	u.uhp = 1;	/* prevent RIP on early quits */
X  	u.ux = 0;	/* prevent flush_screen() */
X  
X! 	/*
X! 	 * Find the creation date of this game,
X! 	 * so as to avoid restoring outdated savefiles.
X  	 */
X- 	/* gethdate(hname); */
X- 
X- 	/*
X- 	 * We cannot do chdir earlier, otherwise gethdate will fail.
X- 	 */
X  #ifdef CHDIR
X  	chdirx(hackdir,1);
X  #endif
X--- 166,175 ----
X  	u.uhp = 1;	/* prevent RIP on early quits */
X  	u.ux = 0;	/* prevent flush_screen() */
X  
X! 	/* chdir shouldn't be called before this point to keep the
X! 	 * code parallel to other ports which call gethdate just
X! 	 * before here.
X  	 */
X  #ifdef CHDIR
X  	chdirx(hackdir,1);
X  #endif
X***************
X*** 260,266 ****
X  		(void) signal(SIGINT, (SIG_RET_TYPE) done1);
X  #endif
X  #ifdef NEWS
X! 		if(flags.news) display_file(NEWS, FALSE);
X  #endif
X  		pline("Restoring save file...");
X  		mark_synch();	/* flush output */
X--- 261,270 ----
X  		(void) signal(SIGINT, (SIG_RET_TYPE) done1);
X  #endif
X  #ifdef NEWS
X! 		if(flags.news){
X! 		    display_file(NEWS, FALSE);
X! 		    flags.news = FALSE;
X! 		}
X  #endif
X  		pline("Restoring save file...");
X  		mark_synch();	/* flush output */
X*** /tmp/da09710	Thu Feb 25 10:30:39 1993
X--- sys/share/pcsys.c	Thu Feb 25 09:01:38 1993
X***************
X*** 26,31 ****
X--- 26,35 ----
X  static boolean NDECL(comspec_exists);
X  #endif
X  
X+ #ifdef WIN32CON
X+ extern int ProgmanLaunched;    /* from nttty.c */
X+ #endif
X+ 
X  # ifdef MICRO
X  
X  void
X***************
X*** 58,64 ****
X--- 62,72 ----
X  		suspend_nhwindows((char *)0);
X  #   endif /* TOS */
X  		chdirx(orgdir, 0);
X+ #ifdef __GO32__
X+ 		if (system(comspec) < 0) {  /* wsu@eecs.umich.edu */
X+ #else
X  		if (spawnl(P_WAIT, comspec, comspec, NULL) < 0) {
X+ #endif
X  			raw_printf("Can't spawn \"%s\"!", comspec);
X  			getreturn("to continue");
X  		}
X***************
X*** 422,428 ****
X--- 430,438 ----
X  
X  	flushout();
X  # ifndef TOS
X+ #  ifndef WIN32
X  	enable_ctrlP();		/* in case this wasn't done */
X+ #  endif
X  # endif
X  # ifdef MFLOPPY
X  	if (ramdisk) copybones(TOPERM);
X***************
X*** 438,443 ****
X--- 448,462 ----
X  	if (colors_changed)
X  		restore_colors();
X  #  endif
X+ # endif
X+ # ifdef WIN32CON
X+ 	/* Only if we started from Progman, not command prompt,
X+ 	 * we need to get one last return, so the score board does
X+ 	 * not vanish instantly after being created.
X+ 	 * ProgmanLaunched is defined and set in nttty.c.
X+          */
X+ 	 
X+ 	if (ProgmanLaunched) getreturn("to end");
X  # endif
X  	exit(code);
X  	return;
X*** /tmp/da09726	Thu Feb 25 10:30:43 1993
X--- sys/share/pcunix.c	Tue Feb  2 10:19:29 1993
X***************
X*** 110,115 ****
X--- 110,124 ----
X  # endif
X  		    *lp == '|' || *lp >= 127 || (*lp >= '[' && *lp <= ']'))
X                          *lp = '_';
X+ # ifdef WIN32
X+               /* "Open" was failing on NT, but only on FAT file system     */
X+               /* volumes, not on NTFS volumes.  NT does not auto-truncate  */
X+               /* the way MSDOS did in such cases, so we need to check      */
X+               /* the file name to see if it falls with-in the file systems */
X+               /* limitations, and if necessary truncate it ourselves       */
X+ 
X+                 nt_regularize(s);         /* In winnt.c */
X+ # endif
X  }
X  
X  #endif /* OVLB */
X
END_OF_FILE
if test 52863 -ne `wc -c <'patches01r'`; then
    echo shar: \"'patches01r'\" unpacked with wrong size!
fi
# end of 'patches01r'
echo shar: End of archive 15 \(of 31\).
cp /dev/null ark15isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 31 archives.
    echo "Now execute 'patchit.sh'"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
