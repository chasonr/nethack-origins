Subject:  v17i050:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Patch1i/31
Newsgroups: comp.sources.games
Approved: billr@saab.CNA.TEK.COM

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 17, Issue 50
Archive-name: nethack31/Patch1i
Patch-To: nethack31: Volume 16, Issue 1-116
Environment: Amiga, Atari, Mac, MS-DOS, Windows-NT, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 9 (of 31)."
# Contents:  patches01c sys/winnt/winnt.c
# Wrapped by billr@saab on Fri Mar  5 10:50:43 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'patches01c' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'patches01c'\" to \"'patches01c.orig'\"
  mv -f 'patches01c' 'patches01c.orig'
fi
echo shar: Extracting \"'patches01c'\" \(53866 characters\)
sed "s/^X//" >'patches01c' <<'END_OF_FILE'
X*** /tmp/da08125	Thu Feb 25 10:22:44 1993
X--- src/dog.c	Tue Feb 23 17:25:10 1993
X***************
X*** 184,189 ****
X--- 184,197 ----
X  			if(nmv > (long)mtmp->mspec_used) mtmp->mspec_used = 0;
X  			else mtmp->mspec_used -= nmv;
X  
X+ 			/* reduce tameness for every 150 moves you are away */
X+ 			if (mtmp->mtame > nmv/150) mtmp->mtame -= nmv/150;
X+ 			else mtmp->mtame = 0;
X+ 
X+ 			/* let monster move a bit on the new level */
X+ 			/* see placement code below */
X+ 			mtmp->mx = min(nmv, 8);
X+ 
X  			if(!regenerates(mtmp->data)) nmv /= 20;
X  			if((long)mtmp->mhp + nmv >= (long)mtmp->mhpmax)
X  			    mtmp->mhp = mtmp->mhpmax;
X***************
X*** 202,222 ****
X  		    } else if (mtmp->isshk && mtmp->mpeaceful)
X  			home_shk(mtmp, TRUE);
X  		    else switch(mtmp->my) {
X! 			xchar *xlocale, *ylocale;
X  
X! 			case 1: xlocale = &xupstair; ylocale = &yupstair;
X  				goto common;
X! 			case 2: xlocale = &xdnstair; ylocale = &ydnstair;
X  				goto common;
X! 			case 3: xlocale = &xupladder; ylocale = &yupladder;
X  				goto common;
X! 			case 4: xlocale = &xdnladder; ylocale = &ydnladder;
X  				goto common;
X! 			case 5: xlocale = &sstairs.sx; ylocale = &sstairs.sy;
X  				goto common;
X  common:
X! 				if (*xlocale && *ylocale) {
X! 			    (void) mnearto(mtmp, *xlocale, *ylocale, FALSE);
X  				    break;
X  				} /* else fall through */
X  			default: 
X--- 210,254 ----
X  		    } else if (mtmp->isshk && mtmp->mpeaceful)
X  			home_shk(mtmp, TRUE);
X  		    else switch(mtmp->my) {
X! 			xchar xlocale, ylocale;
X  
X! 			case 1: xlocale = xupstair; ylocale = yupstair;
X  				goto common;
X! 			case 2: xlocale = xdnstair; ylocale = ydnstair;
X  				goto common;
X! 			case 3: xlocale = xupladder; ylocale = yupladder;
X  				goto common;
X! 			case 4: xlocale = xdnladder; ylocale = ydnladder;
X  				goto common;
X! 			case 5: xlocale = sstairs.sx; ylocale = sstairs.sy;
X  				goto common;
X  common:
X! 				if (xlocale) {
X! 				    if(mtmp->mx) {
X! 					/* monster moved a bit */
X! 					/* pick a nearby location */
X! 					/* mnearto() deals w/stone, et al */
X! 					int i, j;
X! 					char *rmlist = in_rooms(xlocale,
X! 								ylocale, 0);
X! 
X! 					if (rmlist) {
X! 					    xlocale = somex(
X! 						&rooms[*rmlist - ROOMOFFSET]);
X! 					    ylocale = somey(
X! 						&rooms[*rmlist - ROOMOFFSET]);
X! 					} else {
X! 					    i = max(1, xlocale - mtmp->mx);
X! 					    j = min(COLNO-1, xlocale+mtmp->mx);
X! 					    xlocale = rn1(j-i,i);
X! 
X! 					    i = max(0, ylocale - mtmp->mx);
X! 					    j = min(ROWNO-1, ylocale+mtmp->mx);
X! 					    ylocale = rn1(j-i,i);
X! 					}
X! 				    }
X! 				    (void) mnearto(mtmp,
X! 						   xlocale, ylocale, FALSE);
X  				    break;
X  				} /* else fall through */
X  			default: 
X***************
X*** 336,346 ****
X  	migrating_mons = mtmp;
X  #ifdef WALKIES
X  	if (mtmp->mleashed)  {
X- 		pline("The leash comes off!");
X  		m_unleash(mtmp);
X  	}
X  #endif
X- 	mtmp->mtame = 0;
X  	newsym(mtmp->mx,mtmp->my);
X  	/* make sure to reset mtmp->[mx,my] to 0 when releasing, */
X  	/* so rloc() on next level doesn't affect MON_AT() state */
X--- 368,378 ----
X  	migrating_mons = mtmp;
X  #ifdef WALKIES
X  	if (mtmp->mleashed)  {
X  		m_unleash(mtmp);
X+ 		mtmp->mtame--;
X+ 		pline("The leash comes off!");
X  	}
X  #endif
X  	newsym(mtmp->mx,mtmp->my);
X  	/* make sure to reset mtmp->[mx,my] to 0 when releasing, */
X  	/* so rloc() on next level doesn't affect MON_AT() state */
X***************
X*** 455,461 ****
X  	    )
X  		return((struct monst *)0);
X  
X! 	/* worst case, at least he'll be peaceful. */
X  	mtmp->mpeaceful = 1;
X  	set_malign(mtmp);
X  	if(flags.moonphase == FULL_MOON && night() && rn2(6) && obj
X--- 487,493 ----
X  	    )
X  		return((struct monst *)0);
X  
X! 	/* worst case, at least it'll be peaceful. */
X  	mtmp->mpeaceful = 1;
X  	set_malign(mtmp);
X  	if(flags.moonphase == FULL_MOON && night() && rn2(6) && obj
X***************
X*** 462,470 ****
X  						&& mtmp->data->mlet == S_DOG)
X  		return((struct monst *)0);
X  
X! 	/* If we cannot tame him, at least he's no longer afraid. */
X  	mtmp->mflee = 0;
X  	mtmp->mfleetim = 0;
X  	if(mtmp->mtame || !mtmp->mcanmove ||
X  	   /* monsters with conflicting structures cannot be tamed */
X  	   mtmp->isshk || mtmp->isgd || mtmp->ispriest || mtmp->isminion ||
X--- 494,506 ----
X  						&& mtmp->data->mlet == S_DOG)
X  		return((struct monst *)0);
X  
X! 	/* If we cannot tame it, at least it's no longer afraid. */
X  	mtmp->mflee = 0;
X  	mtmp->mfleetim = 0;
X+ 	/* feeding it treats makes it tamer */
X+ 	if (mtmp->mtame && mtmp->mtame < 20 && 
X+ 	    obj && dogfood(mtmp, obj) > ACCFOOD)
X+ 	    mtmp->mtame++;
X  	if(mtmp->mtame || !mtmp->mcanmove ||
X  	   /* monsters with conflicting structures cannot be tamed */
X  	   mtmp->isshk || mtmp->isgd || mtmp->ispriest || mtmp->isminion ||
X***************
X*** 480,490 ****
X  	if(obj) {
X  		if(dogfood(mtmp, obj) >= MANFOOD) return((struct monst *)0);
X  		if(cansee(mtmp->mx,mtmp->my))
X! 			pline("%s devours the %s.", Monnam(mtmp), xname(obj));
X  		obfree(obj, (struct obj *)0);
X  	}
X  	if (u.uswallow && mtmp == u.ustuck)
X  		expels(mtmp, mtmp->data, TRUE);
X  	mtmp2 = newmonst(sizeof(struct edog) + mtmp->mnamelth);
X  	*mtmp2 = *mtmp;
X  	mtmp2->mxlth = sizeof(struct edog);
X--- 516,532 ----
X  	if(obj) {
X  		if(dogfood(mtmp, obj) >= MANFOOD) return((struct monst *)0);
X  		if(cansee(mtmp->mx,mtmp->my))
X! 			pline("%s devours %s.", Monnam(mtmp), the(xname(obj)));
X  		obfree(obj, (struct obj *)0);
X  	}
X  	if (u.uswallow && mtmp == u.ustuck)
X  		expels(mtmp, mtmp->data, TRUE);
X+ 	else if (mtmp == u.ustuck
X+ #ifdef POLYSELF
X+ 		 && !(u.mtimedone && sticks(uasmon))
X+ #endif
X+ 		 )
X+ 		unstuck(mtmp);
X  	mtmp2 = newmonst(sizeof(struct edog) + mtmp->mnamelth);
X  	*mtmp2 = *mtmp;
X  	mtmp2->mxlth = sizeof(struct edog);
X***************
X*** 493,498 ****
X--- 535,556 ----
X  	replmon(mtmp,mtmp2);
X  	newsym(mtmp2->mx, mtmp2->my);
X  	return(mtmp2);
X+ }
X+ 
X+ void
X+ abuse_dog(mtmp)
X+ struct monst *mtmp;
X+ {
X+ 	if (!mtmp->mtame) return;
X+ 
X+ 	if (Aggravate_monster || Conflict) mtmp->mtame /=2;
X+ 	else mtmp->mtame--;
X+ 
X+ #ifdef SOUNDS
X+ 	if (mtmp->mtame && rn2(mtmp->mtame)) yelp(mtmp);
X+ 	else growl(mtmp);	/* give them a moment's worry */
X+ #endif
X+ 	if (!mtmp->mtame) newsym(mtmp->mx, mtmp->my);
X  }
X  
X  #endif /* OVLB */
X*** /tmp/da08133	Thu Feb 25 10:22:46 1993
X--- src/dogmove.c	Fri Feb 19 13:51:09 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)dogmove.c	3.1	92/11/26	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)dogmove.c	3.1	93/02/09	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 31,37 ****
X  }
X  #endif
X  
X! static const char NEARDATA nofetch[] = { BALL_CLASS, CHAIN_CLASS, ROCK_CLASS, 0 };
X  
X  #endif /* OVL0 */
X  
X--- 31,37 ----
X  }
X  #endif
X  
X! static NEARDATA const char nofetch[] = { BALL_CLASS, CHAIN_CLASS, ROCK_CLASS, 0 };
X  
X  #endif /* OVL0 */
X  
X***************
X*** 479,485 ****
X  			 && (perceives(mtmp->data) || !mtmp2->minvis)) ||
X  			(mtmp2->data==&mons[PM_GELATINOUS_CUBE] && rn2(10)) ||
X  			(max_passive_dmg(mtmp2, mtmp) >= mtmp->mhp) ||
X! 			(mtmp->mhp*4 < mtmp->mhpmax &&
X  			 mtmp2->mpeaceful && !Conflict) ||
X  			   (mtmp2->data->mlet == S_COCKATRICE &&
X  				!resists_ston(mtmp->data)))
X--- 479,491 ----
X  			 && (perceives(mtmp->data) || !mtmp2->minvis)) ||
X  			(mtmp2->data==&mons[PM_GELATINOUS_CUBE] && rn2(10)) ||
X  			(max_passive_dmg(mtmp2, mtmp) >= mtmp->mhp) ||
X! 			((mtmp->mhp*4 < mtmp->mhpmax ||
X! #ifdef MULDGN
X! 			  mtmp2->data->msound == MS_GUARDIAN ||
X! 			  mtmp2->data->msound == MS_LEADER
X! #endif
X! 
X! 			  ) &&
X  			 mtmp2->mpeaceful && !Conflict) ||
X  			   (mtmp2->data->mlet == S_COCKATRICE &&
X  				!resists_ston(mtmp->data)))
X***************
X*** 493,499 ****
X  		    if (stat & MM_AGR_DIED) return 2;
X  
X  		    if ((stat & MM_HIT) && !(stat & MM_DEF_DIED) &&
X! 			rn2(4) && mtmp2->mlstmv != monstermoves) {
X  			stat = mattackm(mtmp2, mtmp);	/* return attack */
X  			if (stat & MM_DEF_DIED) return 2;
X  		    }
X--- 499,506 ----
X  		    if (stat & MM_AGR_DIED) return 2;
X  
X  		    if ((stat & MM_HIT) && !(stat & MM_DEF_DIED) &&
X! 			rn2(4) && mtmp2->mlstmv != monstermoves &&
X! 			!onscary(mtmp->mx, mtmp->my, mtmp2)) {
X  			stat = mattackm(mtmp2, mtmp);	/* return attack */
X  			if (stat & MM_DEF_DIED) return 2;
X  		    }
X***************
X*** 536,542 ****
X  
X  		/* dog eschews cursed objects, but likes dog food */
X  		for (obj = level.objects[nx][ny]; obj; obj = obj->nexthere) {
X! 		    if (obj->cursed && !mtmp->mleashed && uncursedcnt)
X  			goto nxti;
X  		    if (obj->cursed) cursemsg = TRUE;
X  		    if (has_edog && (otyp = dogfood(mtmp, obj)) < MANFOOD &&
X--- 543,550 ----
X  
X  		/* dog eschews cursed objects, but likes dog food */
X  		for (obj = level.objects[nx][ny]; obj; obj = obj->nexthere) {
X! 		    if (obj->cursed && !mtmp->mleashed && uncursedcnt &&
X! 			has_edog)
X  			goto nxti;
X  		    if (obj->cursed) cursemsg = TRUE;
X  		    if (has_edog && (otyp = dogfood(mtmp, obj)) < MANFOOD &&
X***************
X*** 575,584 ****
X  #ifdef WALKIES
X  			if (mtmp->mleashed) { /* play it safe */
X  				pline("%s breaks loose of %s leash!",
X! 					Monnam(mtmp),
X! 					humanoid(mtmp->data)
X! 					    ? (mtmp->female ? "her" : "his")
X! 					    : "its");
X  				m_unleash(mtmp);
X  			}
X  #endif
X--- 583,589 ----
X  #ifdef WALKIES
X  			if (mtmp->mleashed) { /* play it safe */
X  				pline("%s breaks loose of %s leash!",
X! 				      Monnam(mtmp), his[pronoun_gender(mtmp)]);
X  				m_unleash(mtmp);
X  			}
X  #endif
X*** /tmp/da08141	Thu Feb 25 22:59:32 1993
X--- src/dokick.c	Thu Feb 25 20:46:57 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)dokick.c	3.1	92/10/06	*/
X  /* Copyright (c) Izchak Miller, Mike Stephenson, Steve Linhart, 1989. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)dokick.c	3.1	93/02/18	*/
X  /* Copyright (c) Izchak Miller, Mike Stephenson, Steve Linhart, 1989. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 13,19 ****
X  			 || is_bigfoot(uasmon))
X  #endif
X  
X! static struct rm NEARDATA *maploc;
X  
X  extern boolean notonhead;	/* for long worms */
X  
X--- 13,19 ----
X  			 || is_bigfoot(uasmon))
X  #endif
X  
X! static NEARDATA struct rm *maploc;
X  
X  extern boolean notonhead;	/* for long worms */
X  
X***************
X*** 25,31 ****
X  static const char *FDECL(gate_str, (XCHAR_P));
X  static void FDECL(drop_to, (coord *, XCHAR_P));
X  
X! static struct obj NEARDATA *kickobj;
X  
X  #define IS_SHOP(x)	(rooms[x].rtype >= SHOPBASE)
X  
X--- 25,31 ----
X  static const char *FDECL(gate_str, (XCHAR_P));
X  static void FDECL(drop_to, (coord *, XCHAR_P));
X  
X! static NEARDATA struct obj *kickobj;
X  
X  #define IS_SHOP(x)	(rooms[x].rtype >= SHOPBASE)
X  
X***************
X*** 48,59 ****
X  
X  	/* squeeze some guilt feelings... */
X  	if(mon->mtame) {
X! #ifdef SOUNDS
X! 	    if (rn2(10)) yelp(mon);
X! 	    else growl(mon); /* give them a moment's worry */
X! #endif
X! 	    mon->mtame--;
X! 	    if(!mon->mtame) newsym(mon->mx, mon->my);
X  	    mon->mflee = mon->mtame ? 1 : 0;
X  #ifdef HISX
X  	    mon->mfleetim = mon->mfleetim + (dmg ? rnd(dmg) : 1);
X--- 48,54 ----
X  
X  	/* squeeze some guilt feelings... */
X  	if(mon->mtame) {
X! 	    abuse_dog(mon);
X  	    mon->mflee = mon->mtame ? 1 : 0;
X  #ifdef HISX
X  	    mon->mfleetim = mon->mfleetim + (dmg ? rnd(dmg) : 1);
X***************
X*** 70,76 ****
X  		killed(mon);
X  		return;
X  	}
X! 	if(martial() && !bigmonst(mon->data) && !rn2(3) && mon->mcanmove) {
X  		/* see if the monster has a place to move into */
X  		mdx = mon->mx + u.dx;
X  		mdy = mon->my + u.dy;
X--- 65,72 ----
X  		killed(mon);
X  		return;
X  	}
X! 	if(martial() && !bigmonst(mon->data) && !rn2(3) && mon->mcanmove
X! 	   && mon != u.ustuck) {
X  		/* see if the monster has a place to move into */
X  		mdx = mon->mx + u.dx;
X  		mdy = mon->my + u.dy;
X***************
X*** 77,82 ****
X--- 73,79 ----
X  		if(goodpos(mdx, mdy, mon, mon->data)) {
X  			pline("%s reels from the blow.", Monnam(mon));
X  			remove_monster(mon->mx, mon->my);
X+ 			newsym(mon->mx, mon->my);
X  			place_monster(mon, mdx, mdy);
X  			newsym(mon->mx, mon->my);
X  			set_apparxy(mon);
X***************
X*** 231,238 ****
X  				robbed -= gold->quan;
X  				if (robbed < 0) robbed = 0;
X  				pline("The amount %scovers %s recent losses.",
X! 					!robbed ? "" : "partially ",
X! 					mtmp->female ? "her" : "his");
X  				ESHK(mtmp)->robbed = robbed;
X  				if(!robbed)
X  					make_happy_shk(mtmp, FALSE);
X--- 228,235 ----
X  				robbed -= gold->quan;
X  				if (robbed < 0) robbed = 0;
X  				pline("The amount %scovers %s recent losses.",
X! 				      !robbed ? "" : "partially ",
X! 				      his[mtmp->female]);
X  				ESHK(mtmp)->robbed = robbed;
X  				if(!robbed)
X  					make_happy_shk(mtmp, FALSE);
X***************
X*** 250,282 ****
X  			    verbalize("Thank you for your contribution.");
X  			else verbalize("Thanks, scum!");
X  		}
X! 		else if(is_mercenary(mtmp->data)) {
X! 		    if(rn2(3)) {
X! 			if(mtmp->data == &mons[PM_SOLDIER]) {
X! 			   if(gold->quan > 100 + (u.ugold + (u.ulevel*rn2(5)))
X! 					    /ACURR(A_CHA))
X! 			    mtmp->mpeaceful = 1;
X! 			    }
X! 			if(mtmp->data == &mons[PM_SERGEANT]) {
X! 			   if(gold->quan > 250 + (u.ugold + (u.ulevel*rn2(5)))
X! 					    /ACURR(A_CHA))
X! 			    mtmp->mpeaceful = 1;
X! 			    }
X! 			if(mtmp->data == &mons[PM_LIEUTENANT]) {
X! 			   if(gold->quan > 500 + (u.ugold + (u.ulevel*rn2(5)))
X! 					    /ACURR(A_CHA))
X! 			    mtmp->mpeaceful = 1;
X! 			    }
X! 			if(mtmp->data == &mons[PM_CAPTAIN]) {
X! 			   if(gold->quan > 750 + (u.ugold + (u.ulevel*rn2(5)))
X! 					    /ACURR(A_CHA))
X! 			    mtmp->mpeaceful = 1;
X! 			    }
X  		     }
X! 		     if(mtmp->mpeaceful)
X  			    verbalize("That should do.  Now beat it!");
X  		     else verbalize("That's not enough, coward!");
X! 		     }
X  
X  		dealloc_obj(gold);
X  		return(1);
X--- 247,277 ----
X  			    verbalize("Thank you for your contribution.");
X  			else verbalize("Thanks, scum!");
X  		}
X! #ifdef ARMY
X! 		else if (is_mercenary(mtmp->data)) {
X! 		    long goldreqd = 0L;
X! 
X! 		    if (rn2(3)) {
X! 			if (mtmp->data == &mons[PM_SOLDIER])
X! 			   goldreqd = 100L;
X! 			else if (mtmp->data == &mons[PM_SERGEANT])
X! 			   goldreqd = 250L;
X! 			else if (mtmp->data == &mons[PM_LIEUTENANT])
X! 			   goldreqd = 500L;
X! 			else if (mtmp->data == &mons[PM_CAPTAIN])
X! 			   goldreqd = 750L;
X! 
X! 			if (goldreqd) {
X! 			   if (gold->quan > goldreqd +
X! 				(u.ugold + u.ulevel*rn2(5))/ACURR(A_CHA))
X! 			    mtmp->mpeaceful = TRUE;
X! 			}
X  		     }
X! 		     if (mtmp->mpeaceful)
X  			    verbalize("That should do.  Now beat it!");
X  		     else verbalize("That's not enough, coward!");
X! 		 }
X! #endif
X  
X  		dealloc_obj(gold);
X  		return(1);
X***************
X*** 512,518 ****
X  static char *
X  kickstr()
X  {
X! 	static char NEARDATA buf[BUFSZ];
X  
X  	if (kickobj) Sprintf(buf, "kicking %s", doname(kickobj));
X  	else {
X--- 507,513 ----
X  static char *
X  kickstr()
X  {
X! 	static NEARDATA char buf[BUFSZ];
X  
X  	if (kickobj) Sprintf(buf, "kicking %s", doname(kickobj));
X  	else {
X***************
X*** 547,552 ****
X--- 542,549 ----
X  {
X  	register int x, y;
X  	register int avrg_attrib = (ACURRSTR+ACURR(A_DEX)+ACURR(A_CON))/3;
X+ 	register struct monst *mtmp;
X+ 	register s_level *slev = Is_special(&u.uz);
X  
X  #ifdef POLYSELF
X  	if(nolimbs(uasmon)) {
X***************
X*** 616,629 ****
X  	/* non-doors, doors.			   */
X  
X  	if(MON_AT(x, y)) {
X  		kick_monster(x, y);
X  		if((Is_airlevel(&u.uz) || Levitation) && flags.move) {
X  		    int range;
X- 		    struct monst *mon;
X  
X! 		    mon = m_at(x,y);
X! 		    range = (3*(int)mon->data->cwt) /
X! 			((int)uasmon->cwt + (weight_cap() + inv_weight()));
X  		    if(range < 1) range = 1;
X  		    hurtle(-u.dx, -u.dy, range);
X  		}
X--- 613,627 ----
X  	/* non-doors, doors.			   */
X  
X  	if(MON_AT(x, y)) {
X+ 		struct permonst *mdat = m_at(x,y)->data;
X  		kick_monster(x, y);
X  		if((Is_airlevel(&u.uz) || Levitation) && flags.move) {
X  		    int range;
X  
X! 		    range = ((int)uasmon->cwt + (weight_cap() + inv_weight()));
X! 		    if (range < 1) range = 1; /* divide by zero avoidance */
X! 		    range = (3*(int)mdat->cwt) / range;
X! 
X  		    if(range < 1) range = 1;
X  		    hurtle(-u.dx, -u.dy, range);
X  		}
X***************
X*** 811,818 ****
X  			exercise(A_STR, FALSE);
X  			set_wounded_legs(RIGHT_SIDE, 5 + rnd(5));
X  		}
X! 		if(Is_airlevel(&u.uz) || Levitation)
X! 		    hurtle(-u.dx, -u.dy, rn2(2));
X  		return(0);
X  	}
X  
X--- 809,818 ----
X  			exercise(A_STR, FALSE);
X  			set_wounded_legs(RIGHT_SIDE, 5 + rnd(5));
X  		}
X! 		if ((Is_airlevel(&u.uz) || Levitation) && rn2(2)) {
X! 		    hurtle(-u.dx, -u.dy, 1);
X! 		    return 1;		/* you moved, so use up a turn */
X! 		}
X  		return(0);
X  	}
X  
X***************
X*** 847,856 ****
X--- 847,886 ----
X  		else
X  		    newsym(x,y);
X  		unblock_point(x,y);		/* vision */
X+ 		if(slev && slev->flags.town)
X+ 		  for(mtmp = fmon; mtmp; mtmp = mtmp->nmon) {
X+ 		    if((mtmp->data == &mons[PM_WATCHMAN] ||
X+ 			mtmp->data == &mons[PM_WATCH_CAPTAIN]) &&
X+ 			couldsee(mtmp->mx, mtmp->my) &&
X+ 			mtmp->mpeaceful) {
X+ 			pline("%s yells:", Amonnam(mtmp));
X+ 			verbalize("Halt, thief!  You're under arrest!");
X+ 			(void) angry_guards(FALSE);
X+ 			break;
X+ 		    }
X+ 		  }
X  	} else {
X  	    if (Blind) feel_location(x,y);	/* we know we hit it */
X  	    exercise(A_STR, TRUE);
X  	    pline("WHAMMM!!!");
X+ 	    if(slev && slev->flags.town)
X+ 	      for(mtmp = fmon; mtmp; mtmp = mtmp->nmon) {
X+ 	        if((mtmp->data == &mons[PM_WATCHMAN] ||
X+ 		  mtmp->data == &mons[PM_WATCH_CAPTAIN]) &&
X+ 	          couldsee(mtmp->mx, mtmp->my) &&
X+ 	          mtmp->mpeaceful) {
X+ 		
X+ 		  pline("%s yells:", Amonnam(mtmp));
X+ 		  if(levl[x][y].looted & D_WARNED) {
X+ 			verbalize("Halt, vandal!  You're under arrest!");
X+ 			(void) angry_guards(FALSE);
X+ 		  } else {
X+ 			verbalize("Hey, stop damaging that door!");
X+ 			levl[x][y].looted |= D_WARNED;
X+ 		  }
X+ 		  break;
X+ 	        }
X+ 	      }
X  	}
X  	return(1);
X  }
X***************
X*** 955,960 ****
X--- 985,991 ----
X  		if(obj == missile) continue;
X  		/* number of objects in the pile */
X  		oct += obj->quan;
X+ 		if(obj == uball || obj == uchain) continue;
X  		/* boulders can fall too, but rarely & never due to rocks */
X  		if((isrock && obj->otyp == BOULDER) ||
X  		   rn2(obj->otyp == BOULDER ? 30 : 3)) continue;
X*** /tmp/da08149	Thu Feb 25 10:22:52 1993
X--- src/dothrow.c	Sun Feb 21 16:06:42 1993
X***************
X*** 6,17 ****
X  
X  #include "hack.h"
X  
X- static void FDECL(hitfloor, (struct obj *));
X  static int FDECL(gem_accept, (struct monst *, struct obj *));
X  static int FDECL(throw_gold, (struct obj *));
X  static void FDECL(check_shop_obj, (struct obj *,XCHAR_P,XCHAR_P,BOOLEAN_P));
X  
X! static const char NEARDATA toss_objs[] =
X  	{ ALLOW_COUNT, GOLD_CLASS, ALL_CLASSES, WEAPON_CLASS, 0 };
X  extern boolean notonhead;	/* for long worms */
X  
X--- 6,16 ----
X  
X  #include "hack.h"
X  
X  static int FDECL(gem_accept, (struct monst *, struct obj *));
X  static int FDECL(throw_gold, (struct obj *));
X  static void FDECL(check_shop_obj, (struct obj *,XCHAR_P,XCHAR_P,BOOLEAN_P));
X  
X! static NEARDATA const char toss_objs[] =
X  	{ ALLOW_COUNT, GOLD_CLASS, ALL_CLASSES, WEAPON_CLASS, 0 };
X  extern boolean notonhead;	/* for long worms */
X  
X***************
X*** 75,88 ****
X  	return(throwit(obj));
X  }
X  
X! static void
X  hitfloor(obj)
X  register struct obj *obj;
X  {
X  	if (IS_SOFT(levl[u.ux][u.uy].typ) || u.uinwater) {
X  		dropy(obj);
X- 		if(*u.ushops)
X- 		    check_shop_obj(obj, obj->ox, obj->oy, FALSE);
X  		return;
X  	}
X  	if (IS_ALTAR(levl[u.ux][u.uy].typ)) doaltarobj(obj);
X--- 74,85 ----
X  	return(throwit(obj));
X  }
X  
X! void
X  hitfloor(obj)
X  register struct obj *obj;
X  {
X  	if (IS_SOFT(levl[u.ux][u.uy].typ) || u.uinwater) {
X  		dropy(obj);
X  		return;
X  	}
X  	if (IS_ALTAR(levl[u.ux][u.uy].typ)) doaltarobj(obj);
X***************
X*** 99,106 ****
X  		if(ship_object(obj, u.ux, u.uy, FALSE)) 
X  		    return;
X  		dropy(obj);
X- 		if(*u.ushops)
X- 		    check_shop_obj(obj, obj->ox, obj->oy, FALSE);
X  	}
X  }
X  
X--- 96,101 ----
X***************
X*** 130,136 ****
X  	ny = u.uy + dy;
X  
X  	if(!isok(nx,ny)) break;
X! 	if(IS_ROCK(levl[nx][ny].typ) || closed_door(nx,ny)) {
X  	    pline("Ouch!");
X  	    losehp(rnd(2+range), IS_ROCK(levl[nx][ny].typ) ?
X  		   "bumping to a wall" : "bumping into a door", KILLED_BY);
X--- 125,132 ----
X  	ny = u.uy + dy;
X  
X  	if(!isok(nx,ny)) break;
X! 	if(IS_ROCK(levl[nx][ny].typ) || closed_door(nx,ny) ||
X! 	   (IS_DOOR(levl[nx][ny].typ) && (levl[nx][ny].doormask & D_ISOPEN))) {
X  	    pline("Ouch!");
X  	    losehp(rnd(2+range), IS_ROCK(levl[nx][ny].typ) ?
X  		   "bumping to a wall" : "bumping into a door", KILLED_BY);
X***************
X*** 215,233 ****
X  			   Hallucination || Fumbling);
X  	int do_death = 0;
X  
X! 	if (obj->cursed && (u.dx || u.dy) && !rn2(7)) {
X  		boolean slipok = TRUE;
X  	    if ((obj->oclass == WEAPON_CLASS || obj->oclass == GEM_CLASS)
X  		&& uwep && (objects[obj->otyp].w_propellor > 0) &&
X  		(objects[obj->otyp].w_propellor ==
X                                               -objects[uwep->otyp].w_propellor))
X! 		pline("The %s misfires!", xname(obj));
X  	    else {
X! 		/* only slip if it's meant to be thrown */
X! 		if((obj->otyp >= DART && obj->otyp <= JAVELIN) ||
X  		   (obj->otyp >= DAGGER && obj->otyp <= CRYSKNIFE &&
X  		    obj->otyp != ATHAME) || obj->otyp == WAR_HAMMER)
X! 		    pline("The %s slips as you throw it!", xname(obj));
X  		else slipok = FALSE;
X  	    }
X  	    if (slipok) {
X--- 211,230 ----
X  			   Hallucination || Fumbling);
X  	int do_death = 0;
X  
X! 	if ((obj->cursed || obj->greased) && (u.dx || u.dy) && !rn2(7)) {
X  		boolean slipok = TRUE;
X  	    if ((obj->oclass == WEAPON_CLASS || obj->oclass == GEM_CLASS)
X  		&& uwep && (objects[obj->otyp].w_propellor > 0) &&
X  		(objects[obj->otyp].w_propellor ==
X                                               -objects[uwep->otyp].w_propellor))
X! 		pline("%s misfires!", The(xname(obj)));
X  	    else {
X! 		/* only slip if it's greased or meant to be thrown */
X! 		if(obj->greased ||
X! 		   (obj->otyp >= DART && obj->otyp <= JAVELIN) ||
X  		   (obj->otyp >= DAGGER && obj->otyp <= CRYSKNIFE &&
X  		    obj->otyp != ATHAME) || obj->otyp == WAR_HAMMER)
X! 		    pline("%s slips as you throw it!", The(xname(obj)));
X  		else slipok = FALSE;
X  	    }
X  	    if (slipok) {
X***************
X*** 284,291 ****
X  		if (!breaks(obj, TRUE)) {
X  		    if(!ship_object(obj, u.ux, u.uy, FALSE)) {
X  			dropy(obj);
X- 			if(*u.ushops)
X- 			    check_shop_obj(obj, obj->ox, obj->oy, FALSE);
X  		    }
X  		}
X  		if (do_death == STONING)
X--- 281,286 ----
X***************
X*** 372,386 ****
X  
X  		if (obj->oartifact == ART_MJOLLNIR && pl_character[0] == 'V') {
X  		    /* we must be wearing Gauntlets of Power to get here */
X- 		    int x = bhitpos.x - u.dx, y = bhitpos.y - u.dy;
X  
X! 		    tmp_at(DISP_FLASH, obj_glyph);
X! 		    while(x != u.ux || y != u.uy) {
X! 			tmp_at(x, y);
X! 			delay_output();
X! 			x -= u.dx; y -= u.dy;
X  		    }
X- 		    tmp_at(DISP_END, 0);
X  
X  		    if(!impaired) {
X  			pline("%s returns to your hand!", The(xname(obj)));
X--- 367,385 ----
X  
X  		if (obj->oartifact == ART_MJOLLNIR && pl_character[0] == 'V') {
X  		    /* we must be wearing Gauntlets of Power to get here */
X  
X! 		    /* might already be our location (bounced off a wall) */
X! 		    if (bhitpos.x != u.ux || bhitpos.y != u.uy) {
X! 			int x = bhitpos.x - u.dx, y = bhitpos.y - u.dy;
X! 
X! 			tmp_at(DISP_FLASH, obj_glyph);
X! 			while(x != u.ux || y != u.uy) {
X! 			    tmp_at(x, y);
X! 			    delay_output();
X! 			    x -= u.dx; y -= u.dy;
X! 			}
X! 			tmp_at(DISP_END, 0);
X  		    }
X  
X  		    if(!impaired) {
X  			pline("%s returns to your hand!", The(xname(obj)));
X***************
X*** 603,613 ****
X  	boolean is_buddy = sgn(mon->data->maligntyp) == sgn(u.ualign.type);
X  	boolean is_gem = objects[obj->otyp].oc_material == GEMSTONE;
X  	int ret = 0;
X! 	static const char NEARDATA nogood[] = " is not interested in your junk.";
X! 	static const char NEARDATA acceptgift[] = " accepts your gift.";
X! 	static const char NEARDATA maybeluck[] = " hesitatingly";
X! 	static const char NEARDATA noluck[] = " graciously";
X! 	static const char NEARDATA addluck[] = " gratefully";
X  
X  	Strcpy(buf,Monnam(mon));
X  
X--- 602,612 ----
X  	boolean is_buddy = sgn(mon->data->maligntyp) == sgn(u.ualign.type);
X  	boolean is_gem = objects[obj->otyp].oc_material == GEMSTONE;
X  	int ret = 0;
X! 	static NEARDATA const char nogood[] = " is not interested in your junk.";
X! 	static NEARDATA const char acceptgift[] = " accepts your gift.";
X! 	static NEARDATA const char maybeluck[] = " hesitatingly";
X! 	static NEARDATA const char noluck[] = " graciously";
X! 	static NEARDATA const char addluck[] = " gratefully";
X  
X  	Strcpy(buf,Monnam(mon));
X  
X*** /tmp/da08165	Thu Feb 25 10:22:57 1993
X--- src/dungeon.c	Thu Feb 18 11:17:51 1993
X***************
X*** 639,645 ****
X  
X  	    if (i) {	/* set depth */
X  		branch *br;
X! 		xchar from_depth;
X  		boolean from_up;
X  
X  		br = add_branch(i, dungeons[i].entry_lev, &pd);
X--- 639,645 ----
X  
X  	    if (i) {	/* set depth */
X  		branch *br;
X! 		schar from_depth;
X  		boolean from_up;
X  
X  		br = add_branch(i, dungeons[i].entry_lev, &pd);
X***************
X*** 770,776 ****
X  	    assign_level(&knox_level, &x->dlevel);
X  	    /*
X  	     * Kludge to allow floating Knox entrance.  We specify a floating
X! 	     * entrance by the fact that it's entrance (end1) has a bogus dnum,
X  	     * namely n_dgns.
X  	     */
X  	    for (br = branches; br; br = br->next)
X--- 770,776 ----
X  	    assign_level(&knox_level, &x->dlevel);
X  	    /*
X  	     * Kludge to allow floating Knox entrance.  We specify a floating
X! 	     * entrance by the fact that its entrance (end1) has a bogus dnum,
X  	     * namely n_dgns.
X  	     */
X  	    for (br = branches; br; br = br->next)
X***************
X*** 844,850 ****
X  	 */
X  	register int i;
X  	d_level tmp;
X! 	register xchar ret = 0;
X  
X  	for(i = 0; i < n_dgns; i++) {
X  	    if((tmp.dlevel = dungeons[i].dunlev_ureached) == 0) continue;
X--- 844,850 ----
X  	 */
X  	register int i;
X  	d_level tmp;
X! 	register schar ret = 0;
X  
X  	for(i = 0; i < n_dgns; i++) {
X  	    if((tmp.dlevel = dungeons[i].dunlev_ureached) == 0) continue;
X***************
X*** 853,859 ****
X  	    tmp.dnum = i;
X  	    if(depth(&tmp) > ret) ret = depth(&tmp);
X  	}
X! 	return(ret);
X  }
X  
X  /* return a bookkeeping level number for purpose of comparisons and
X--- 853,859 ----
X  	    tmp.dnum = i;
X  	    if(depth(&tmp) > ret) ret = depth(&tmp);
X  	}
X! 	return((xchar) ret);
X  }
X  
X  /* return a bookkeeping level number for purpose of comparisons and
X***************
X*** 908,914 ****
X  
X  /* returns the depth of a level, in floors below the surface	*/
X  /* (note levels in different dungeons can have the same depth).	*/
X! xchar
X  depth(lev)
X  d_level	*lev;
X  {
X--- 908,914 ----
X  
X  /* returns the depth of a level, in floors below the surface	*/
X  /* (note levels in different dungeons can have the same depth).	*/
X! schar
X  depth(lev)
X  d_level	*lev;
X  {
X***************
X*** 1110,1116 ****
X  	xchar dgn = u.uz.dnum;
X  
X  	if (levnum <= 0) {
X! 	    impossible("get_level:  levnum = %d\n", levnum);
X  	    levnum = u.uz.dlevel;
X  	} else if (levnum > dungeons[dgn].depth_start
X  			    + dungeons[dgn].num_dunlevs - 1) {
X--- 1110,1116 ----
X  	xchar dgn = u.uz.dnum;
X  
X  	if (levnum <= 0) {
X! 	    /* can only currently happen in endgame */
X  	    levnum = u.uz.dlevel;
X  	} else if (levnum > dungeons[dgn].depth_start
X  			    + dungeons[dgn].num_dunlevs - 1) {
X***************
X*** 1308,1319 ****
X  level_difficulty()
X  {
X  	if (In_endgame(&u.uz))
X! 		return(depth(&sanctum_level) + u.ulevel/2);
X  	else
X  		if (u.uhave.amulet)
X  			return(deepest_lev_reached(FALSE));
X  		else
X! 			return(depth(&u.uz));
X  }
X  
X  
X--- 1308,1319 ----
X  level_difficulty()
X  {
X  	if (In_endgame(&u.uz))
X! 		return((xchar) depth(&sanctum_level) + u.ulevel/2);
X  	else
X  		if (u.uhave.amulet)
X  			return(deepest_lev_reached(FALSE));
X  		else
X! 			return((xchar) depth(&u.uz));
X  }
X  
X  
X*** /tmp/da08173	Thu Feb 25 10:23:00 1993
X--- src/eat.c	Tue Feb 23 11:25:49 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)eat.c	3.1	92/12/06	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)eat.c	3.1	93/02/19	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 74,91 ****
X  
X  #ifndef OVLB
X  
X! STATIC_DCL const char NEARDATA comestibles[];
X  #ifdef POLYSELF
X! STATIC_OVL const char NEARDATA allobj[];
X  #endif /* POLYSELF */
X  
X  #else
X  
X! STATIC_OVL const char NEARDATA comestibles[] = { FOOD_CLASS, 0 };
X  
X  #ifdef POLYSELF
X  /* Gold must come first for getobj(). */
X! STATIC_OVL const char NEARDATA allobj[] = {
X  	GOLD_CLASS, WEAPON_CLASS, ARMOR_CLASS, POTION_CLASS, SCROLL_CLASS,
X  	WAND_CLASS, RING_CLASS, AMULET_CLASS, FOOD_CLASS, TOOL_CLASS,
X  	GEM_CLASS, ROCK_CLASS, BALL_CLASS, CHAIN_CLASS, SPBOOK_CLASS, 0 };
X--- 74,91 ----
X  
X  #ifndef OVLB
X  
X! STATIC_DCL NEARDATA const char comestibles[];
X  #ifdef POLYSELF
X! STATIC_OVL NEARDATA const char allobj[];
X  #endif /* POLYSELF */
X  
X  #else
X  
X! STATIC_OVL NEARDATA const char comestibles[] = { FOOD_CLASS, 0 };
X  
X  #ifdef POLYSELF
X  /* Gold must come first for getobj(). */
X! STATIC_OVL NEARDATA const char allobj[] = {
X  	GOLD_CLASS, WEAPON_CLASS, ARMOR_CLASS, POTION_CLASS, SCROLL_CLASS,
X  	WAND_CLASS, RING_CLASS, AMULET_CLASS, FOOD_CLASS, TOOL_CLASS,
X  	GEM_CLASS, ROCK_CLASS, BALL_CLASS, CHAIN_CLASS, SPBOOK_CLASS, 0 };
X***************
X*** 110,116 ****
X  #ifdef OVLB
X  
X  void
X! init_uhunger(){
X  	u.uhunger = 900;
X  	u.uhs = NOT_HUNGRY;
X  }
X--- 110,117 ----
X  #ifdef OVLB
X  
X  void
X! init_uhunger()
X! {
X  	u.uhunger = 900;
X  	u.uhs = NOT_HUNGRY;
X  }
X***************
X*** 126,137 ****
X  };
X  #define	TTSZ	SIZE(tintxts)
X  
X! static struct {
X  	struct	obj *tin;
X  	int	usedtime, reqtime;
X! } NEARDATA tin;
X  
X! static struct {
X  	struct	obj *piece;	/* the thing being eaten, or last thing that
X  				 * was partially eaten, unless that thing was
X  				 * a tin, which uses the tin structure above */
X--- 127,138 ----
X  };
X  #define	TTSZ	SIZE(tintxts)
X  
X! static NEARDATA struct {
X  	struct	obj *tin;
X  	int	usedtime, reqtime;
X! } tin;
X  
X! static NEARDATA struct {
X  	struct	obj *piece;	/* the thing being eaten, or last thing that
X  				 * was partially eaten, unless that thing was
X  				 * a tin, which uses the tin structure above */
X***************
X*** 142,152 ****
X  	Bitfield(fullwarn,1);	/* have warned about being full */
X  	Bitfield(eating,1);	/* victual currently being eaten */
X  	Bitfield(doreset,1);	/* stop eating at end of turn */
X! } NEARDATA victual;
X  
X  STATIC_PTR
X  int
X! eatmdone() {		/* called after mimicing is over */
X  	u.usym =
X  #ifdef POLYSELF
X  		u.mtimedone ? uasmon->mlet :
X--- 143,154 ----
X  	Bitfield(fullwarn,1);	/* have warned about being full */
X  	Bitfield(eating,1);	/* victual currently being eaten */
X  	Bitfield(doreset,1);	/* stop eating at end of turn */
X! } victual;
X  
X  STATIC_PTR
X  int
X! eatmdone()		/* called after mimicing is over */
X! {
X  	u.usym =
X  #ifdef POLYSELF
X  		u.mtimedone ? uasmon->mlet :
X***************
X*** 172,177 ****
X--- 174,181 ----
X  	if (pl_character[0] == 'K' && u.ualign.type == A_LAWFUL)
X  		u.ualign.record--;	/* gluttony is unchivalrous */
X  
X+ 	exercise(A_CON, FALSE);
X+ 
X  	if (!rn2(20)) {
X  		You("stuff yourself and then vomit voluminously.");
X  		morehungry(1000);	/* you just got *very* sick! */
X***************
X*** 206,212 ****
X  }
X  
X  static void
X! recalc_wt() {	/* modify object wt. depending on time spent consuming it */
X  	register struct obj *piece = victual.piece;
X  
X  #ifdef DEBUG
X--- 210,217 ----
X  }
X  
X  static void
X! recalc_wt()	/* modify object wt. depending on time spent consuming it */
X! {
X  	register struct obj *piece = victual.piece;
X  
X  #ifdef DEBUG
X***************
X*** 223,230 ****
X  }
X  
X  void
X! reset_eat() {		/* called when eating interrupted by an event */
X! 
X      /* we only set a flag here - the actual reset process is done after
X       * the round is spent eating.
X       */
X--- 228,235 ----
X  }
X  
X  void
X! reset_eat()		/* called when eating interrupted by an event */
X! {
X      /* we only set a flag here - the actual reset process is done after
X       * the round is spent eating.
X       */
X***************
X*** 276,286 ****
X  
X  	if (!otmp->oeaten) {
X  	    if(((!carried(otmp) && costly_spot(otmp->ox, otmp->oy) &&
X! 		 saleable(rooms[*u.ushops-ROOMOFFSET].rtype-SHOPBASE, otmp))
X  		 || otmp->unpaid) &&
X  		 (otmp->otyp == CORPSE || objects[otmp->otyp].oc_delay > 1)) {
X  		/* create a dummy duplicate to put on bill */
X! 		You("bite it, you bought it!");
X  		bill_dummy_object(otmp);
X  	    }
X  	    otmp->oeaten = (otmp->otyp == CORPSE ?
X--- 281,291 ----
X  
X  	if (!otmp->oeaten) {
X  	    if(((!carried(otmp) && costly_spot(otmp->ox, otmp->oy) &&
X! 		 !otmp->no_charge)
X  		 || otmp->unpaid) &&
X  		 (otmp->otyp == CORPSE || objects[otmp->otyp].oc_delay > 1)) {
X  		/* create a dummy duplicate to put on bill */
X! 		verbalize("You bite it, you bought it!");
X  		bill_dummy_object(otmp);
X  	    }
X  	    otmp->oeaten = (otmp->otyp == CORPSE ?
X***************
X*** 331,337 ****
X  
X  STATIC_PTR
X  int
X! eatfood() {		/* called each move during eating process */
X  	if(!carried(victual.piece) && !obj_here(victual.piece, u.ux, u.uy)) {
X  		/* maybe it was stolen? */
X  		do_reset_eat();
X--- 336,343 ----
X  
X  STATIC_PTR
X  int
X! eatfood()		/* called each move during eating process */
X! {
X  	if(!carried(victual.piece) && !obj_here(victual.piece, u.ux, u.uy)) {
X  		/* maybe it was stolen? */
X  		do_reset_eat();
X***************
X*** 377,382 ****
X--- 383,393 ----
X  register int pm;
X  {
X  	if ((pl_character[0]=='E') ? is_elf(&mons[pm]) : is_human(&mons[pm])) {
X+ #ifdef POLYSELF
X+ 		if (uasmon != &playermon) {
X+ 			You("have a bad feeling deep inside.");
X+ 		}
X+ #endif /* POLYSELF */
X  		You("cannibal!  You will regret this!");
X  		Aggravate_monster |= FROMOUTSIDE;
X  	}
X***************
X*** 589,595 ****
X  		debugpline("Trying to give fire resistance");
X  #endif
X  		if(!(HFire_resistance & FROMOUTSIDE)) {
X! 			You("feel a momentary chill.");
X  			HFire_resistance |= FROMOUTSIDE;
X  		}
X  		break;
X--- 600,607 ----
X  		debugpline("Trying to give fire resistance");
X  #endif
X  		if(!(HFire_resistance & FROMOUTSIDE)) {
X! 			You(Hallucination ? "be chillin'." :
X! 			    "feel a momentary chill.");
X  			HFire_resistance |= FROMOUTSIDE;
X  		}
X  		break;
X***************
X*** 616,622 ****
X  		debugpline("Trying to give disintegration resistance");
X  #endif
X  		if(!(HDisint_resistance & FROMOUTSIDE)) {
X! 			You("feel very firm.");
X  			HDisint_resistance |= FROMOUTSIDE;
X  		}
X  		break;
X--- 628,636 ----
X  		debugpline("Trying to give disintegration resistance");
X  #endif
X  		if(!(HDisint_resistance & FROMOUTSIDE)) {
X! 			You(Hallucination ?
X! 			    "feel totally together, man." :
X! 			    "feel very firm.");
X  			HDisint_resistance |= FROMOUTSIDE;
X  		}
X  		break;
X***************
X*** 625,631 ****
X  		debugpline("Trying to give shock resistance");
X  #endif
X  		if(!(HShock_resistance & FROMOUTSIDE)) {
X! 			Your("health currently feels amplified!");
X  			HShock_resistance |= FROMOUTSIDE;
X  		}
X  		break;
X--- 639,648 ----
X  		debugpline("Trying to give shock resistance");
X  #endif
X  		if(!(HShock_resistance & FROMOUTSIDE)) {
X! 			if (Hallucination)
X! 				You("feel grounded in reality.");
X! 			else
X! 				Your("health currently feels amplified!");
X  			HShock_resistance |= FROMOUTSIDE;
X  		}
X  		break;
X***************
X*** 643,649 ****
X  		debugpline("Trying to give teleport");
X  #endif
X  		if(!(HTeleportation & FROMOUTSIDE)) {
X! 			You("feel very jumpy.");
X  			HTeleportation |= FROMOUTSIDE;
X  		}
X  		break;
X--- 660,667 ----
X  		debugpline("Trying to give teleport");
X  #endif
X  		if(!(HTeleportation & FROMOUTSIDE)) {
X! 			You(Hallucination ? "feel diffuse." :
X! 			    "feel very jumpy.");
X  			HTeleportation |= FROMOUTSIDE;
X  		}
X  		break;
X***************
X*** 652,658 ****
X  		debugpline("Trying to give teleport control");
X  #endif
X  		if(!(HTeleport_control & FROMOUTSIDE)) {
X! 			You("feel in control of yourself.");
X  			HTeleport_control |= FROMOUTSIDE;
X  		}
X  		break;
X--- 670,678 ----
X  		debugpline("Trying to give teleport control");
X  #endif
X  		if(!(HTeleport_control & FROMOUTSIDE)) {
X! 			You(Hallucination ?
X! 			    "feel centered in your personal space." :
X! 			    "feel in control of yourself.");
X  			HTeleport_control |= FROMOUTSIDE;
X  		}
X  		break;
X***************
X*** 661,668 ****
X  		debugpline("Trying to give telepathy");
X  #endif
X  		if(!(HTelepat & FROMOUTSIDE)) {
X! 			You("feel a %s mental acuity.",
X! 				Hallucination ? "normal" : "strange");
X  			HTelepat |= FROMOUTSIDE;
X  			/* If blind, make sure monsters show up. */
X  			if (Blind) see_monsters();
X--- 681,689 ----
X  		debugpline("Trying to give telepathy");
X  #endif
X  		if(!(HTelepat & FROMOUTSIDE)) {
X! 			You(Hallucination ?
X! 			    "feel in touch with the cosmos." :
X! 			    "feel a strange mental acuity.");
X  			HTelepat |= FROMOUTSIDE;
X  			/* If blind, make sure monsters show up. */
X  			if (Blind) see_monsters();
X***************
X*** 732,744 ****
X  	    case PM_SMALL_MIMIC:
X  		tmp += 20;
X  		if(u.usym == S_HUMAN) {
X! 		    You("cannot resist the temptation to mimic a pile of gold.");
X  		    nomul(-tmp);
X  		    afternmv = eatmdone;
X  		    if (pl_character[0]=='E')
X! 			nomovemsg = "You now again prefer mimicking an elf.";
X  		    else
X! 			nomovemsg = "You now again prefer mimicking a human.";
X  		    u.usym = 0; /* hack! no monster sym 0; use for gold */
X  		    newsym(u.ux,u.uy);
X  		}
X--- 753,765 ----
X  	    case PM_SMALL_MIMIC:
X  		tmp += 20;
X  		if(u.usym == S_HUMAN) {
X! 		    You("can't resist the temptation to mimic a pile of gold.");
X  		    nomul(-tmp);
X  		    afternmv = eatmdone;
X  		    if (pl_character[0]=='E')
X! 			nomovemsg = "You now prefer mimicking an elf again.";
X  		    else
X! 			nomovemsg = "You now prefer mimicking a human again.";
X  		    u.usym = 0; /* hack! no monster sym 0; use for gold */
X  		    newsym(u.ux,u.uy);
X  		}
X***************
X*** 869,874 ****
X--- 890,897 ----
X  	    r = tin.tin->cursed ? 4 :		/* Always rotten if cursed */
X  		    (tin.tin->spe == -1) ? 5 :	/* "homemade" if player made */
X  			rn2(TTSZ-1);		/* else take your pick */
X+ 	    if (tin.tin->spe == -1 && !tin.tin->blessed && !rn2(7))
X+ 		r = 4;				/* some homemade tins go bad */
X  	    pline("It smells like %s.", makeplural(
X  		  Hallucination ? rndmonnam() : mons[tin.tin->corpsenm].mname));
X  	    if (yn("Eat it?") == 'n') {
X***************
X*** 876,881 ****
X--- 899,908 ----
X  		if (flags.verbose) You("discard the open tin.");
X  		goto use_me;
X  	    }
X+ 	    /* in case stop_occupation() was called on previous meal */
X+ 	    victual.piece = (struct obj *)0;
X+ 	    victual.fullwarn = victual.eating = victual.doreset = FALSE;
X+ 
X  	    You("consume %s %s.", tintxts[r].txt,
X  			mons[tin.tin->corpsenm].mname);
X  	    tin.tin->dknown = tin.tin->known = TRUE;
X***************
X*** 886,894 ****
X  	    else lesshungry(tintxts[r].nut);
X  
X  	    if(r == 0) {			/* Deep Fried */
X! 		Glib = rnd(15);
X  		pline("Eating deep fried food made your %s very slippery.",
X! 			makeplural(body_part(FINGER)));
X  	    }
X  	} else {
X  	    if (tin.tin->cursed)
X--- 913,922 ----
X  	    else lesshungry(tintxts[r].nut);
X  
X  	    if(r == 0) {			/* Deep Fried */
X! 	        /* Assume !Glib, because you can't open tins when Glib. */
X! 		Glib += rnd(15);
X  		pline("Eating deep fried food made your %s very slippery.",
X! 		      makeplural(body_part(FINGER)));
X  	    }
X  	} else {
X  	    if (tin.tin->cursed)
X***************
X*** 958,964 ****
X  no_opener:
X  		pline("It is not so easy to open this tin.");
X  		if(Glib) {
X! 			pline("The tin slips out of your hands.");
X  			if(otmp->quan > 1L) {
X  				register struct obj *obj;
X  				obj = splitobj(otmp, 1L);
X--- 986,993 ----
X  no_opener:
X  		pline("It is not so easy to open this tin.");
X  		if(Glib) {
X! 			pline("The tin slips from your %s.",
X! 			      makeplural(body_part(FINGER)));
X  			if(otmp->quan > 1L) {
X  				register struct obj *obj;
X  				obj = splitobj(otmp, 1L);
X***************
X*** 978,984 ****
X  }
X  
X  int
X! Hear_again() {		/* called when waking up after fainting */
X  	flags.soundok = 1;
X  	return 0;
X  }
X--- 1007,1014 ----
X  }
X  
X  int
X! Hear_again()		/* called when waking up after fainting */
X! {
X  	flags.soundok = 1;
X  	return 0;
X  }
X***************
X*** 1005,1011 ****
X  		make_blinded((long)d(2,10),FALSE);
X  	} else if(!rn2(3)) {
X  		if(Blind)
X! 		  pline("The world spins and you slap against the floor.");
X  		else
X  		  pline("The world spins and goes dark.");
X  		flags.soundok = 0;
X--- 1035,1043 ----
X  		make_blinded((long)d(2,10),FALSE);
X  	} else if(!rn2(3)) {
X  		if(Blind)
X! 		  pline("The world spins and you %s.",
X! 			Levitation ? "collapse in place" :
X! 			"slap against the floor");
X  		else
X  		  pline("The world spins and goes dark.");
X  		flags.soundok = 0;
X***************
X*** 1081,1090 ****
X  	}
X  	if(!tp && otmp->corpsenm != PM_LIZARD && (otmp->orotten || !rn2(7))) {
X  #ifdef POLYSELF
X! 	    if(rottenfood(otmp)) {
X  #else
X! 	    if(rottenfood()) {
X  #endif
X  		otmp->orotten = TRUE;
X  		(void)touchfood(otmp);
X  		return(1);
X--- 1113,1123 ----
X  	}
X  	if(!tp && otmp->corpsenm != PM_LIZARD && (otmp->orotten || !rn2(7))) {
X  #ifdef POLYSELF
X! 	    if(rottenfood(otmp))
X  #else
X! 	    if(rottenfood())
X  #endif
X+ 	    {
X  		otmp->orotten = TRUE;
X  		(void)touchfood(otmp);
X  		return(1);
X***************
X*** 1183,1189 ****
X  #ifdef TUTTI_FRUTTI
X  		if (otmp->otyp==SLIME_MOLD && !otmp->cursed
X  			&& otmp->spe == current_fruit)
X! 		    pline("My, that was a yummy %s!", singular(otmp, xname));
X  		else
X  #endif
X  #ifdef UNIX
X--- 1216,1224 ----
X  #ifdef TUTTI_FRUTTI
X  		if (otmp->otyp==SLIME_MOLD && !otmp->cursed
X  			&& otmp->spe == current_fruit)
X! 		    pline("My, that was a %s %s!",
X! 			  Hallucination ? "primo" : "yummy",
X! 			  singular(otmp, xname));
X  		else
X  #endif
X  #ifdef UNIX
X***************
X*** 1200,1209 ****
X  		    }
X  		} else
X  #endif
X! 		    pline("This %s is %s!", singular(otmp, xname),
X! 		      otmp->cursed ? (Hallucination ? "grody" : "terrible"):
X! 		      Hallucination ? "gnarly" :
X! 			(otmp->otyp==CRAM_RATION ? "bland" : "delicious"));
X  		break;
X  	}
X  }
X--- 1235,1244 ----
X  		    }
X  		} else
X  #endif
X! 		    pline("This %s is %s", singular(otmp, xname),
X! 		      otmp->cursed ? (Hallucination ? "grody!" : "terrible!") :
X! 		      otmp->otyp == CRAM_RATION ? "bland." :
X! 		      Hallucination ? "gnarly!" : "delicious!");
X  		break;
X  	}
X  }
X***************
X*** 1488,1497 ****
X  		(otmp->orotten || !rn2(7))))) {
X  
X  #ifdef POLYSELF
X! 		if(rottenfood(otmp)) {
X  #else
X! 		if(rottenfood()) {
X  #endif
X  		    otmp->orotten = TRUE;
X  		    return(1);
X  		}
X--- 1523,1533 ----
X  		(otmp->orotten || !rn2(7))))) {
X  
X  #ifdef POLYSELF
X! 		if(rottenfood(otmp))
X  #else
X! 		if(rottenfood())
X  #endif
X+ 		{
X  		    otmp->orotten = TRUE;
X  		    return(1);
X  		}
X***************
X*** 1642,1648 ****
X  		    victual.fullwarn = TRUE;
X  		    if (victual.canchoke &&
X  			/* a one-gulp food will not survive a stop */
X! 				objects[victual.piece->otyp].oc_delay > 1) {
X  			if(yn("Stop eating?") == 'y')
X  			{
X  				reset_eat();
X--- 1678,1684 ----
X  		    victual.fullwarn = TRUE;
X  		    if (victual.canchoke &&
X  			/* a one-gulp food will not survive a stop */
X! 				victual.reqtime > 1) {
X  			if(yn("Stop eating?") == 'y')
X  			{
X  				reset_eat();
X***************
X*** 1658,1664 ****
X  
X  STATIC_PTR
X  int
X! unfaint() {
X  	(void) Hear_again();
X  	if(u.uhs > FAINTING)
X  		u.uhs = FAINTING;
X--- 1694,1701 ----
X  
X  STATIC_PTR
X  int
X! unfaint()
X! {
X  	(void) Hear_again();
X  	if(u.uhs > FAINTING)
X  		u.uhs = FAINTING;
X***************
X*** 1671,1688 ****
X  #ifdef OVL0
X  
X  boolean
X! is_fainted() {
X  	return(u.uhs == FAINTED);
X  }
X  
X  void
X! reset_faint() {	/* call when a faint must be prematurely terminated */
X  	if(is_fainted()) nomul(0);
X  }
X  
X  #if 0
X  void
X! sync_hunger() {
X  
X  	if(is_fainted()) {
X  
X--- 1708,1728 ----
X  #ifdef OVL0
X  
X  boolean
X! is_fainted()
X! {
X  	return(u.uhs == FAINTED);
X  }
X  
X  void
X! reset_faint()	/* call when a faint must be prematurely terminated */
X! {
X  	if(is_fainted()) nomul(0);
X  }
X  
X  #if 0
X  void
X! sync_hunger()
X! {
X  
X  	if(is_fainted()) {
X  
X***************
X*** 1842,1848 ****
X  /* added nomul (MRS) - it makes sense, you're too busy being sick! */
X  /* TO DO: regurgitate swallowed monsters when poly'd */
X  void
X! vomit() {		/* A good idea from David Neves */
X  	make_sick(0L,TRUE);
X  	nomul(-2);
X  }
X--- 1882,1889 ----
X  /* added nomul (MRS) - it makes sense, you're too busy being sick! */
X  /* TO DO: regurgitate swallowed monsters when poly'd */
X  void
X! vomit()		/* A good idea from David Neves */
X! {
X  	make_sick(0L,TRUE);
X  	nomul(-2);
X  }
X*** /tmp/da08181	Thu Feb 25 10:23:03 1993
X--- src/end.c	Thu Feb 18 10:54:51 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)end.c	3.1	93/01/15	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)end.c	3.1	93/02/09	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 18,24 ****
X  /*
X   * The order of these needs to match the macros in hack.h.
X   */
X! static const char NEARDATA *deaths[] = {		/* the array of death */
X  	"died", "choked", "poisoned", "starvation", "drowning",
X  	"burning", "crushed", "turned to stone", "genocided",
X  	"panic", "trickery",
X--- 18,24 ----
X  /*
X   * The order of these needs to match the macros in hack.h.
X   */
X! static NEARDATA const char *deaths[] = {		/* the array of death */
X  	"died", "choked", "poisoned", "starvation", "drowning",
X  	"burning", "crushed", "turned to stone", "genocided",
X  	"panic", "trickery",
X***************
X*** 25,31 ****
X  	"quit", "escaped", "ascended"
X  };
X  
X! static const char NEARDATA *ends[] = {		/* "when you..." */
X  	"died", "choked", "were poisoned", "starved", "drowned",
X  	"burned", "were crushed", "turned to stone", "were genocided",
X  	"panicked", "were tricked",
X--- 25,31 ----
X  	"quit", "escaped", "ascended"
X  };
X  
X! static NEARDATA const char *ends[] = {		/* "when you..." */
X  	"died", "choked", "were poisoned", "starved", "drowned",
X  	"burned", "were crushed", "turned to stone", "were genocided",
X  	"panicked", "were tricked",
X***************
X*** 130,135 ****
X--- 130,136 ----
X  	char buf[BUFSZ];
X  
X  	You("die...");
X+ 	mark_synch();	/* flush buffered screen output */
X  	buf[0] = '\0';
X  	if (type_is_pname(mtmp->data) || (mtmp->data->geno & G_UNIQ)) {
X  	     if (!(type_is_pname(mtmp->data) && (mtmp->data->geno & G_UNIQ)))
X***************
X*** 399,405 ****
X  	 * On those rare occasions you get hosed immediately, go out
X  	 * smiling... :-)  -3.
X  	 */
X! 	if (moves <= 1 && how < QUIT)
X  	    /* You die... --More-- */
X  	    pline("Do not pass go.  Do not collect 200 zorkmids.");
X  
X--- 400,406 ----
X  	 * On those rare occasions you get hosed immediately, go out
X  	 * smiling... :-)  -3.
X  	 */
X! 	if (moves <= 1 && how < PANICKED)
X  	    /* You die... --More-- */
X  	    pline("Do not pass go.  Do not collect 200 zorkmids.");
X  
X***************
X*** 446,451 ****
X--- 447,453 ----
X  	 * happen to bones levels */
X  	taken = paybill(how != QUIT);
X  	paygd();
X+ 	clearpriests();
X  	clearlocks();
X  #ifdef AMIGA
X  	clear_icon();
X***************
X*** 461,466 ****
X--- 463,486 ----
X  		savebones();
X  	}
X  
X+ 	/* calculate score */
X+ 	{
X+ 	    long tmp;
X+ 	    int deepest = deepest_lev_reached(FALSE);
X+ 
X+ 	    u.ugold += hidden_gold();	/* accumulate gold from containers */
X+ 	    tmp = u.ugold - u.ugold0;
X+ 	    if (tmp < 0L)
X+ 		tmp = 0L;
X+ 	    if (how < PANICKED)
X+ 		tmp -= tmp / 10L;
X+ 	    u.urexp += tmp;
X+ 	    u.urexp += 50L * (long)(deepest - 1);
X+ 	    if (deepest > 20)
X+ 		u.urexp += 1000L * (long)((deepest > 30) ? 10 : deepest - 20);
X+ 	    if (how == ASCENDED) u.urexp *= 2L;
X+ 	}
X+ 
X  	/* clean up unneeded windows */
X  	if (have_windows) {
X  	    destroy_nhwindow(WIN_MAP);
X***************
X*** 486,506 ****
X  	    putstr(endwin, 0, pbuf);
X  	    putstr(endwin, 0, "");
X  	}
X- 	{   long tmp;
X- 	    int deepest = deepest_lev_reached(FALSE);
X- 
X- 	    u.ugold += hidden_gold();	/* accumulate gold from containers */
X- 	    tmp = u.ugold - u.ugold0;
X- 	    if (tmp < 0L)
X- 		tmp = 0L;
X- 	    if (how < PANICKED)
X- 		tmp -= tmp / 10L;
X- 	    u.urexp += tmp;
X- 	    u.urexp += 50L * (long)(deepest - 1);
X- 	    if (deepest > 20)
X- 		u.urexp += 1000L * (long)((deepest > 30) ? 10 : deepest - 20);
X- 	    if (how == ASCENDED) u.urexp *= 2L;
X- 	}
X  	if (how == ESCAPED || how == ASCENDED) {
X  		register struct monst *mtmp;
X  		register struct obj *otmp;
X--- 506,511 ----
X***************
X*** 672,678 ****
X  	    if (Is_container(box) && box->otyp != BAG_OF_TRICKS) {
X  		if (box->cobj) {
X  		    winid tmpwin = create_nhwindow(NHW_MENU);
X! 		    Sprintf(buf, "Contents of the %s:", xname(box));
X  		    putstr(tmpwin, 0, buf); putstr(tmpwin, 0, "");
X  		    for (obj = box->cobj; obj; obj = obj->nobj) {
X  			if (identified) {
X--- 677,683 ----
X  	    if (Is_container(box) && box->otyp != BAG_OF_TRICKS) {
X  		if (box->cobj) {
X  		    winid tmpwin = create_nhwindow(NHW_MENU);
X! 		    Sprintf(buf, "Contents of %s:", the(xname(box)));
X  		    putstr(tmpwin, 0, buf); putstr(tmpwin, 0, "");
X  		    for (obj = box->cobj; obj; obj = obj->nobj) {
X  			if (identified) {
X*** /tmp/da08189	Thu Feb 25 10:23:05 1993
X--- src/engrave.c	Fri Feb 12 10:26:02 1993
X***************
X*** 6,12 ****
X  #include "lev.h"
X  #include <ctype.h>
X  
X! STATIC_VAR struct engr NEARDATA *head_engr;
X  
X  STATIC_DCL void FDECL(del_engr, (struct engr *));
X  
X--- 6,12 ----
X  #include "lev.h"
X  #include <ctype.h>
X  
X! STATIC_VAR NEARDATA struct engr *head_engr;
X  
X  STATIC_DCL void FDECL(del_engr, (struct engr *));
X  
X***************
X*** 225,231 ****
X  		return(1);*/
X  }
X  
X! static const char NEARDATA styluses[] =
X  	{ ALL_CLASSES, ALLOW_NONE, TOOL_CLASS, WEAPON_CLASS, WAND_CLASS,
X  	  GEM_CLASS, RING_CLASS, 0 };
X  
X--- 225,231 ----
X  		return(1);*/
X  }
X  
X! static NEARDATA const char styluses[] =
X  	{ ALL_CLASSES, ALLOW_NONE, TOOL_CLASS, WEAPON_CLASS, WAND_CLASS,
X  	  GEM_CLASS, RING_CLASS, 0 };
X  
X***************
X*** 256,265 ****
X   * moonstone  -  6	(orthoclase)	*
X   */
X  
X! static const short NEARDATA hard_gems[] =
X  	{ DIAMOND, RUBY, SAPPHIRE, TOPAZ, EMERALD, AQUAMARINE, GARNET, 0 };
X  
X! static const char NEARDATA *hard_ring_names[] =
X  	{"diamond", "ruby", "sapphire", "emerald", "topaz", ""};
X  
X  /* return 1 if action took 1 (or more) moves, 0 if error or aborted */
X--- 256,265 ----
X   * moonstone  -  6	(orthoclase)	*
X   */
X  
X! static NEARDATA const short hard_gems[] =
X  	{ DIAMOND, RUBY, SAPPHIRE, TOPAZ, EMERALD, AQUAMARINE, GARNET, 0 };
X  
X! static NEARDATA const char *hard_ring_names[] =
X  	{"diamond", "ruby", "sapphire", "emerald", "topaz", ""};
X  
X  /* return 1 if action took 1 (or more) moves, 0 if error or aborted */
X***************
X*** 758,764 ****
X  	/* Prompt for engraving! */
X  	Sprintf(qbuf,"What do you want to %s %s here?", everb, eloc);
X  	getlin(qbuf, ebuf);
X- 	clear_nhwindow(WIN_MESSAGE);
X  
X  	/* Mix up engraving if surface or state of mind is unsound.  */
X  	/* Original kludge by stewr 870708.  modified by njm 910722. */
X--- 758,763 ----
X*** /tmp/da08205	Thu Feb 25 10:23:10 1993
X--- src/explode.c	Thu Feb 18 10:58:30 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)explode.c 3.1	90/11/06
X  /*	Copyright (C) 1990 by Ken Arromdee */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)explode.c 3.1	93/02/17
X  /*	Copyright (C) 1990 by Ken Arromdee */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 146,152 ****
X  				pline("%s gets heartburn!",
X  				      Monnam(u.ustuck));
X  			else
X! 				pline("%s gets toasted slightly!",
X  				      Monnam(u.ustuck));
X  		} else
X  		pline("%s is caught in the %s!",
X--- 146,152 ----
X  				pline("%s gets heartburn!",
X  				      Monnam(u.ustuck));
X  			else
X! 				pline("%s gets slightly toasted!",
X  				      Monnam(u.ustuck));
X  		} else
X  		pline("%s is caught in the %s!",
X***************
X*** 203,210 ****
X  			if (type >= 0 && olet != SCROLL_CLASS) {
X  			    killer_format = NO_KILLER_PREFIX;
X  			    Sprintf(buf, "caught %sself in %s own %s.",
X! 				flags.female ? "her" : "him",
X! 				flags.female ? "her" : "his", str);
X  			} else {
X  			    killer_format = KILLED_BY;
X  			    Strcpy(buf, str);
X--- 203,209 ----
X  			if (type >= 0 && olet != SCROLL_CLASS) {
X  			    killer_format = NO_KILLER_PREFIX;
X  			    Sprintf(buf, "caught %sself in %s own %s.",
X! 				    him[flags.female], his[flags.female], str);
X  			} else {
X  			    killer_format = KILLED_BY;
X  			    Strcpy(buf, str);
X*** /tmp/da08213	Thu Feb 25 10:23:12 1993
X--- src/extralev.c	Fri Feb 12 10:25:48 1993
X***************
X*** 18,24 ****
X  #define LEFT 4
X  #define RIGHT 8
X  
X! static struct rogueroom NEARDATA r[3][3];
X  static void FDECL(roguejoin,(int,int,int,int,int));
X  static void FDECL(roguecorr,(int,int,int));
X  static void FDECL(miniwalk,(int,int));
X--- 18,24 ----
X  #define LEFT 4
X  #define RIGHT 8
X  
X! static NEARDATA struct rogueroom r[3][3];
X  static void FDECL(roguejoin,(int,int,int,int,int));
X  static void FDECL(roguecorr,(int,int,int));
X  static void FDECL(miniwalk,(int,int));
X
END_OF_FILE
if test 53866 -ne `wc -c <'patches01c'`; then
    echo shar: \"'patches01c'\" unpacked with wrong size!
fi
# end of 'patches01c'
if test -f 'sys/winnt/winnt.c' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'sys/winnt/winnt.c'\" to \"'sys/winnt/winnt.c.orig'\"
  mv -f 'sys/winnt/winnt.c' 'sys/winnt/winnt.c.orig'
fi
echo shar: Extracting \"'sys/winnt/winnt.c'\" \(2186 characters\)
sed "s/^X//" >'sys/winnt/winnt.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)winnt.c	 3.1	 93/01/31		  */
X/* Copyright (c) NetHack PC Development Team 1990, 1991, 1992	  */
X/* NetHack may be freely redistributed.  See license for details. */
X
X/*
X *  Windows NT system functions.
X *
X *  Initial Creation: Michael Allison - January 31/93
X *
X */
X
X#define NEED_VARARGS
X#include "hack.h"
X
X#ifdef WIN32
X
X#include <dos.h>
X#include <direct.h>
X#include <ctype.h>
X#include <windows.h>
X
X/*
X * The following WIN32 API routines are used in this file.
X *
X * GetDiskFreeSpace
X * GetVolumeInformation
X * FindFirstFile
X * FindNextFile
X * FindClose
X *
X */
X
X
X/* globals required within here */
XHANDLE ffhandle = NULL;
XWIN32_FIND_DATA ffd;
X
X
Xchar
Xswitchar()
X{
X /* Could not locate a WIN32 API call for this- MJA */
X	return '-';
X}
X
Xlong
Xfreediskspace(path)
Xchar *path;
X{
X	char tmppath[4];
X	DWORD SectorsPerCluster = 0;
X	DWORD BytesPerSector = 0;
X	DWORD FreeClusters = 0;
X	DWORD TotalClusters = 0;
X
X	tmppath[0] = *path;
X	tmppath[1] = ':';
X	tmppath[2] = '\\';
X	tmppath[3] = '\0';
X	GetDiskFreeSpace(tmppath, &SectorsPerCluster,
X			&BytesPerSector,
X			&FreeClusters,
X			&TotalClusters);
X	return (long)(SectorsPerCluster * BytesPerSector *
X			FreeClusters);
X}
X
X/*
X * Functions to get filenames using wildcards
X */
Xint
Xfindfirst(path)
Xchar *path;
X{
X	if (ffhandle){
X		 FindClose(ffhandle);
X		 ffhandle = NULL;
X	}
X	ffhandle = FindFirstFile(path,&ffd);
X	return 
X	  (ffhandle == INVALID_HANDLE_VALUE) ? 0 : 1;
X}
X
Xint
Xfindnext() 
X{
X	return FindNextFile(ffhandle,&ffd) ? 1 : 0;
X}
X
Xchar *
Xfoundfile_buffer()
X{
X	return &ffd.cFileName[0];
X}
X
Xlong
Xfilesize(file)
Xchar *file;
X{
X	if (findfirst(file)) {
X		return ((long *)&ffd.nFileSizeLow);
X	} else
X		return -1L;
X}
X
X/*
X * Chdrive() changes the default drive.
X */
Xvoid
Xchdrive(str)
Xchar *str;
X{
X	char *ptr;
X	char drive;
X	if ((ptr = index(str, ':')) != NULL) 
X	{
X		drive = toupper(*(ptr - 1));
X		_chdrive((drive - 'A') + 1);
X	}
X}
X
X/* NT supports long file names, but does THIS particular volume? */
Xvoid
Xnt_regularize(s)
Xchar *s;
X{
X	DWORD maxflen;
X	int status=0;
X	
X	status = GetVolumeInformation(NULL,NULL,NULL
X			,NULL,&maxflen,NULL,NULL,NULL);
X	if (status)
X	{
X	   if (strlen(s) > maxflen-4) s[maxflen-4] = '\0';
X	}
X}
X#endif /* WIN32 */
END_OF_FILE
if test 2186 -ne `wc -c <'sys/winnt/winnt.c'`; then
    echo shar: \"'sys/winnt/winnt.c'\" unpacked with wrong size!
fi
# end of 'sys/winnt/winnt.c'
echo shar: End of archive 9 \(of 31\).
cp /dev/null ark9isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 31 archives.
    echo "Now execute 'patchit.sh'"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
