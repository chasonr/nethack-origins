Subject:  v17i047:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Patch1f/31
Newsgroups: comp.sources.games
Approved: billr@saab.CNA.TEK.COM

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 17, Issue 47
Archive-name: nethack31/Patch1f
Patch-To: nethack31: Volume 16, Issue 1-116
Environment: Amiga, Atari, Mac, MS-DOS, Windows-NT, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 6 (of 31)."
# Contents:  patches01e
# Wrapped by billr@saab on Fri Mar  5 10:50:42 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'patches01e' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'patches01e'\" to \"'patches01e.orig'\"
  mv -f 'patches01e' 'patches01e.orig'
fi
echo shar: Extracting \"'patches01e'\" \(55585 characters\)
sed "s/^X//" >'patches01e' <<'END_OF_FILE'
X*** /tmp/da08301	Thu Feb 25 10:23:40 1993
X--- src/mhitu.c	Wed Feb 24 14:47:25 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)mhitu.c	3.1	92/12/10	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)mhitu.c	3.1	93/02/09	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 5,11 ****
X  #include "hack.h"
X  #include "artifact.h"
X  
X! STATIC_VAR struct obj NEARDATA *otmp;
X  
X  #ifdef POLYSELF
X  STATIC_DCL void FDECL(urustm, (struct monst *, struct obj *));
X--- 5,11 ----
X  #include "hack.h"
X  #include "artifact.h"
X  
X! STATIC_VAR NEARDATA struct obj *otmp;
X  
X  #ifdef POLYSELF
X  STATIC_DCL void FDECL(urustm, (struct monst *, struct obj *));
X***************
X*** 24,30 ****
X  STATIC_DCL int FDECL(hitmu, (struct monst *,struct attack *));
X  STATIC_DCL int FDECL(gulpmu, (struct monst *,struct attack *));
X  STATIC_DCL int FDECL(explmu, (struct monst *,struct attack *,BOOLEAN_P));
X- STATIC_DCL int FDECL(gazemu, (struct monst *,struct attack *));
X  STATIC_DCL void FDECL(missmu,(struct monst *,BOOLEAN_P,struct attack *));
X  STATIC_DCL void FDECL(mswings,(struct monst *,struct obj *));
X  STATIC_DCL void FDECL(wildmiss,(struct monst *));
X--- 24,29 ----
X***************
X*** 107,122 ****
X  register struct monst *mtmp;
X  register struct obj *otemp;
X  {
X! 	if (!flags.verbose || Blind || !mon_visible(mtmp) ||
X! 		otemp->oclass != WEAPON_CLASS) return;
X  	pline("%s %s %s %s.", Monnam(mtmp),
X! 	      ((otemp->otyp >= SPEAR &&
X! 	        otemp->otyp <= LANCE) ||
X! 	       (otemp->otyp >= PARTISAN &&
X! 	        otemp->otyp <= SPETUM) ||
X  	       otemp->otyp == TRIDENT) ? "thrusts" : "swings",
X! 	      !humanoid(mtmp->data) ? "its" : mtmp->female ? "her" : "his",
X! 	      xname(otemp));
X  }
X  
X  #endif /* OVL1 */
X--- 106,118 ----
X  register struct monst *mtmp;
X  register struct obj *otemp;
X  {
X! 	if (!flags.verbose || Blind || !mon_visible(mtmp))
X! 		return;
X  	pline("%s %s %s %s.", Monnam(mtmp),
X! 	      ((otemp->otyp >= SPEAR && otemp->otyp <= LANCE) ||
X! 	       (otemp->otyp >= PARTISAN && otemp->otyp <= SPETUM) ||
X  	       otemp->otyp == TRIDENT) ? "thrusts" : "swings",
X! 	      his[pronoun_gender(mtmp)], xname(otemp));
X  }
X  
X  #endif /* OVL1 */
X***************
X*** 311,317 ****
X  						Monnam(mtmp), uasmon->mname);
X  			killed(mtmp);
X  			newsym(u.ux,u.uy);
X! 			return(0);
X  		    }
X  		    if (u.usym != S_PIERCER)
X  			return(0);	/* trappers don't attack */
X--- 307,317 ----
X  						Monnam(mtmp), uasmon->mname);
X  			killed(mtmp);
X  			newsym(u.ux,u.uy);
X! #ifdef MUSE
X! 			if (mtmp->mhp > 0) return(0);
X! 			else
X! #endif
X! 				return(1);
X  		    }
X  		    if (u.usym != S_PIERCER)
X  			return(0);	/* trappers don't attack */
X***************
X*** 405,412 ****
X  
X  	    if(!rn2(10) && !mtmp->mcan) {
X  		if(youseeit) {
X! 			pline("%s summons help!",youseeit ?
X! 				Monnam(mtmp) : "It");
X  		} else
X  			You("feel hemmed in.");
X  		/* Technically wrong; we really should check if you can see the
X--- 405,411 ----
X  
X  	    if(!rn2(10) && !mtmp->mcan) {
X  		if(youseeit) {
X! 			pline("%s summons help!", Monnam(mtmp));
X  		} else
X  			You("feel hemmed in.");
X  		/* Technically wrong; we really should check if you can see the
X***************
X*** 501,507 ****
X  			    }
X  			    stoned = TRUE;
X  			    killed(mtmp);
X! 			    sum[i] = 2;
X  			}
X  			break;
X  
X--- 500,511 ----
X  			    }
X  			    stoned = TRUE;
X  			    killed(mtmp);
X! #ifdef MUSE
X! 			    if (mtmp->mhp > 0)
X! 				sum[i] = 0;
X! 			    else
X! #endif
X! 				sum[i] = 2;
X  			}
X  			break;
X  
X***************
X*** 564,569 ****
X--- 568,575 ----
X  			    if (foundyou) {
X  				set_uasmon();
X  #ifdef MUSE
X+ 				remove_cadavers(&mtmp->minvent);
X+ 				possibly_unwield(mtmp);
X  				otmp = MON_WEP(mtmp);
X  #else
X  				otmp = select_hwep(mtmp);
X***************
X*** 648,654 ****
X  			continue;
X  		break;
X  	    case 1:
X! 		if (uarmc) break;
X  		/* Note the difference between break and continue;
X  		 * break means it was hit and didn't rust; continue
X  		 * means it wasn't a target and though it didn't rust
X--- 654,664 ----
X  			continue;
X  		break;
X  	    case 1:
X! 		if (uarmc) {
X! 		    if (!rusting)
X! 			(void)rust_dmg(uarmc, "cloak", hurt, TRUE);
X! 		    break;
X! 		}
X  		/* Note the difference between break and continue;
X  		 * break means it was hit and didn't rust; continue
X  		 * means it wasn't a target and though it didn't rust
X***************
X*** 764,771 ****
X  #endif
X  								) {
X  		    if(!u.ustuck && rn2(2)) {
X! 			u.ustuck = mtmp;
X! 			pline("%s grabs you!", Monnam(mtmp));
X  		    } else if(u.ustuck == mtmp) {
X  		        exercise(A_STR, FALSE);
X  			You("are being %s.",
X--- 774,794 ----
X  #endif
X  								) {
X  		    if(!u.ustuck && rn2(2)) {
X! 			register struct obj *obj = (uarmc ? uarmc : uarm);
X! 
X! 			/* if your cloak/armor is greased, monster slips off */
X! 			if (obj && obj->greased) {
X! 			    dmg = 0;
X! 			    pline("%s grabs you, but cannot hold onto your greased %s!",
X! 				  Monnam(mtmp), xname(obj));
X! 			    if (!rn2(2)) {
X! 				pline("The grease wears off.");
X! 				obj->greased = 0;
X! 			    }
X! 			} else {
X! 			    u.ustuck = mtmp;
X! 			    pline("%s grabs you!", Monnam(mtmp));
X! 			}
X  		    } else if(u.ustuck == mtmp) {
X  		        exercise(A_STR, FALSE);
X  			You("are being %s.",
X***************
X*** 774,779 ****
X--- 797,812 ----
X  		    }
X  		} else {			  /* hand to hand weapon */
X  		    if(mattk->aatyp == AT_WEAP && otmp) {
X+ #ifdef MUSE
X+ 			if (otmp->otyp == CORPSE
X+ 				&& otmp->corpsenm == PM_COCKATRICE) {
X+ 			    dmg = 1;
X+ 			    pline("%s hits you with the cockatrice corpse.",
X+ 				Monnam(mtmp));
X+ 			    if (!Stoned)
X+ 			        goto do_stone;
X+ 			}
X+ #endif
X  			dmg += dmgval(otmp, uasmon);
X  			if (dmg <= 0) dmg = 1;
X  			if (!(otmp->oartifact &&
X***************
X*** 780,785 ****
X--- 813,819 ----
X  				artifact_hit(mtmp, &youmonst, otmp, &dmg,dieroll)))
X  			     hitmsg(mtmp, mattk);
X  #ifdef POLYSELF
X+ 			if (!dmg) break;
X  			if (u.mh > 1 && u.mh > ((u.uac>0) ? dmg : dmg+u.uac) &&
X  					(u.umonnum==PM_BLACK_PUDDING
X  					|| u.umonnum==PM_BROWN_PUDDING)) {
X***************
X*** 962,967 ****
X--- 996,1004 ----
X  		    } else {
X  			if (flags.soundok)
X  			    You("hear %s hissing!", s_suffix(mon_nam(mtmp)));
X+ #ifdef MUSE
X+ do_stone:
X+ #endif
X  			if((!rn2(10) ||
X  			    (flags.moonphase == NEW_MOON && !have_lizard()))
X  #ifdef POLYSELF
X***************
X*** 987,1000 ****
X  							) u.ustuck = mtmp;
X  		break;
X  	    case AD_WRAP:
X! 		if(ctmp
X  #ifdef POLYSELF
X  			&& !sticks(uasmon)
X  #endif
X  					  ) {
X  		    if(!u.ustuck && !rn2(10)) {
X! 			pline("%s swings itself around you!", Monnam(mtmp));
X! 			u.ustuck = mtmp;
X  		    } else if(u.ustuck == mtmp) {
X  			if (is_pool(mtmp->mx,mtmp->my)
X  #ifdef POLYSELF
X--- 1024,1051 ----
X  							) u.ustuck = mtmp;
X  		break;
X  	    case AD_WRAP:
X! 		if((!mtmp->mcan || (u.ustuck == mtmp))
X  #ifdef POLYSELF
X  			&& !sticks(uasmon)
X  #endif
X  					  ) {
X  		    if(!u.ustuck && !rn2(10)) {
X! 			register struct obj *obj = (uarmc ? uarmc : uarm);
X! 
X! 			/* if your cloak/armor is greased, monster slips off */
X! 			if (obj && obj->greased) {
X! 			    dmg = 0;
X! 			    pline("%s slips off of your greased %s!",
X! 				  Monnam(mtmp), xname(obj));
X! 			    if (!rn2(2)) {
X! 				pline("The grease wears off.");
X! 				obj->greased = 0;
X! 			    }
X! 			} else {
X! 			    pline("%s swings itself around you!",
X! 				  Monnam(mtmp));
X! 			    u.ustuck = mtmp;
X! 			}
X  		    } else if(u.ustuck == mtmp) {
X  			if (is_pool(mtmp->mx,mtmp->my)
X  #ifdef POLYSELF
X***************
X*** 1002,1008 ****
X--- 1053,1069 ----
X  #endif
X  			    && !Magical_breathing
X  			   ) {
X+ 			    boolean moat = (levl[u.ux][u.uy].typ != POOL) &&
X+ 				(levl[u.ux][u.uy].typ != WATER) &&
X+ 				!Is_medusa_level(&u.uz) &&
X+ 				!Is_waterlevel(&u.uz);
X+ 
X  			    pline("%s drowns you....", Monnam(mtmp));
X+ 			    killer_format = KILLED_BY_AN;
X+ 			    Sprintf(buf, "%s by %s",
X+ 				    moat ? "moat" : "pool of water",
X+ 				    a_monnam(mtmp));
X+ 			    killer = buf;
X  			    done(DROWNING);
X  			} else if(mattk->aatyp == AT_HUGS)
X  			    You("are being crushed.");
X***************
X*** 1087,1094 ****
X  	    case AD_SAMU:
X  		hitmsg(mtmp, mattk);
X  		/* when the Wiz hits, 1/20 steals the amulet */
X! 		if (!u.uhave.amulet) break;
X! 		if (!rn2(20)) stealamulet(mtmp);
X  		break;
X  
X  	    case AD_TLPT:
X--- 1148,1160 ----
X  	    case AD_SAMU:
X  		hitmsg(mtmp, mattk);
X  		/* when the Wiz hits, 1/20 steals the amulet */
X! 		if ( u.uhave.amulet ||
X! 		     u.uhave.bell || u.uhave.book || u.uhave.menorah
X! #ifdef MULDGN
X! 		     || u.uhave.questart /* carrying the Quest Artifact */
X! #endif
X! 		   )
X! 		    if (!rn2(20)) stealamulet(mtmp);
X  		break;
X  
X  	    case AD_TLPT:
X***************
X*** 1149,1155 ****
X  		        exercise(A_STR, TRUE);
X  		        exercise(A_CON, TRUE);
X  			flags.botl = 1;
X! 			if(!rn2(50)) rloc(mtmp);
X  			dmg = 0;
X  		} else
X  		    if(pl_character[0] == 'H') {
X--- 1215,1226 ----
X  		        exercise(A_STR, TRUE);
X  		        exercise(A_CON, TRUE);
X  			flags.botl = 1;
X! 			if (mtmp->mhp == 0)
X! 			    return 2; /* mongone() was called above */
X! 			if(!rn2(50)) {
X! 			    rloc(mtmp);
X! 			    return 3;
X! 			}
X  			dmg = 0;
X  		} else
X  		    if(pl_character[0] == 'H') {
X***************
X*** 1279,1287 ****
X  	}
X  
X  #ifdef POLYSELF
X! 	res = passiveum(olduasmon, mtmp, mattk);
X! 	stop_occupation();
X! 	return res;
X  #else
X  	stop_occupation();
X  	return 1;
X--- 1350,1361 ----
X  	}
X  
X  #ifdef POLYSELF
X! 	if (dmg) {
X! 	    res = passiveum(olduasmon, mtmp, mattk);
X! 	    stop_occupation();
X! 	    return res;
X! 	} else
X! 	    return 1;
X  #else
X  	stop_occupation();
X  	return 1;
X***************
X*** 1325,1331 ****
X  		}
X  #ifdef WALKIES
X  		if((i = number_leashed()) > 0) {
X! 			pline("The leash%s snap%s loose...",
X  					(i > 1) ? "es" : "",
X  					(i > 1) ? "" : "s");
X  			unleash_all();
X--- 1399,1405 ----
X  		}
X  #ifdef WALKIES
X  		if((i = number_leashed()) > 0) {
X! 			pline("The leash%s snap%s loose.",
X  					(i > 1) ? "es" : "",
X  					(i > 1) ? "" : "s");
X  			unleash_all();
X***************
X*** 1336,1342 ****
X  			pline("%s turns to stone!", Monnam(mtmp));
X  			stoned = 1;
X  			xkilled(mtmp, 0);
X! 			return 2;
X  		}
X  #endif
X  		display_nhwindow(WIN_MESSAGE, FALSE);
X--- 1410,1420 ----
X  			pline("%s turns to stone!", Monnam(mtmp));
X  			stoned = 1;
X  			xkilled(mtmp, 0);
X! # ifdef MUSE
X! 			if (mtmp->mhp > 0) return 0;
X! 			else
X! # endif
X! 				return 2;
X  		}
X  #endif
X  		display_nhwindow(WIN_MESSAGE, FALSE);
X***************
X*** 1356,1364 ****
X  	    switch(mattk->adtyp) {
X  
X  		case AD_DGST:
X! 		    if(!u.uswldtim) {	/* a3 *//*no cf unsigned <=0*/
X  			pline("%s totally digests you!", Monnam(mtmp));
X  			tmp = u.uhp;
X  		    } else {
X  			pline("%s digests you!", Monnam(mtmp));
X  		        exercise(A_STR, FALSE);
X--- 1434,1443 ----
X  	    switch(mattk->adtyp) {
X  
X  		case AD_DGST:
X! 		    if(u.uswldtim <= 1) {	/* a3 *//*no cf unsigned <=0*/
X  			pline("%s totally digests you!", Monnam(mtmp));
X  			tmp = u.uhp;
X+ 			if (Half_physical_damage) tmp *= 2; /* sorry */
X  		    } else {
X  			pline("%s digests you!", Monnam(mtmp));
X  		        exercise(A_STR, FALSE);
X***************
X*** 1437,1443 ****
X  	    }
X  	}
X  
X! 	if(Half_physical_damage) tmp = (tmp+1) / 2;
X  
X  	mdamageu(mtmp, tmp);
X  	if(tmp) stop_occupation();
X--- 1516,1522 ----
X  	    }
X  	}
X  
X! 	if (Half_physical_damage) tmp = (tmp+1) / 2;
X  
X  	mdamageu(mtmp, tmp);
X  	if(tmp) stop_occupation();
X***************
X*** 1452,1458 ****
X  	    if (u.umonnum == PM_COCKATRICE) {
X  		pline("%s very hurriedly %s you!", Monnam(mtmp), 
X  		       is_animal(mtmp->data)? "regurgitates" : "expels");
X- 		u.uswldtim = 0;
X  	    } else {
X  #endif
X  		You("get %s!", 
X--- 1531,1536 ----
X***************
X*** 1490,1499 ****
X  		not_affected |= Cold_resistance;
X  
X  		if (!not_affected) {
X- 		    if (flags.verbose) You("get blasted!");
X  		    if (ACURR(A_DEX) > rnd(20)) {
X! 			You("duck the blast...");
X  			tmp = (tmp+1) / 2;
X  		    }
X  		    if (Half_physical_damage) tmp = (tmp+1) / 2;
X  		    mdamageu(mtmp, tmp);
X--- 1568,1578 ----
X  		not_affected |= Cold_resistance;
X  
X  		if (!not_affected) {
X  		    if (ACURR(A_DEX) > rnd(20)) {
X! 			You("duck some of the blast.");
X  			tmp = (tmp+1) / 2;
X+ 		    } else {
X+ 		        if (flags.verbose) You("get blasted!");
X  		    }
X  		    if (Half_physical_damage) tmp = (tmp+1) / 2;
X  		    mdamageu(mtmp, tmp);
X***************
X*** 1511,1516 ****
X--- 1590,1596 ----
X  			You("are blinded by a blast of light!");
X  			make_blinded((long)tmp, FALSE);
X  		    } else
X+ 			if (flags.verbose)
X  			You("get the impression it was not terribly bright.");
X  		}
X  		break;
X***************
X*** 1526,1535 ****
X  	}
X      }
X      mondead(mtmp);
X      return(2);	/* it dies */
X  }
X  
X! STATIC_OVL int
X  gazemu(mtmp, mattk)	/* monster gazes at you */
X  	register struct monst *mtmp;
X  	register struct attack  *mattk;
X--- 1606,1618 ----
X  	}
X      }
X      mondead(mtmp);
X+ #ifdef MUSE
X+     if (mtmp->mhp > 0) return(0);
X+ #endif
X      return(2);	/* it dies */
X  }
X  
X! int
X  gazemu(mtmp, mattk)	/* monster gazes at you */
X  	register struct monst *mtmp;
X  	register struct attack  *mattk;
X***************
X*** 1627,1635 ****
X  register struct monst *mon;
X  register struct obj *obj;
X  {
X! 	boolean vis = cansee(mon->mx, mon->my);
X  
X  	if (!mon || !obj) return; /* just in case */
X  	if (u.umonnum == PM_RUST_MONSTER && 
X  	    is_rustprone(obj) && obj->oeroded < MAX_ERODE) {
X  		if (obj->greased || obj->oerodeproof || (obj->blessed && rn2(3))) {
X--- 1710,1719 ----
X  register struct monst *mon;
X  register struct obj *obj;
X  {
X! 	boolean vis;
X  
X  	if (!mon || !obj) return; /* just in case */
X+ 	vis = cansee(mon->mx, mon->my);
X  	if (u.umonnum == PM_RUST_MONSTER && 
X  	    is_rustprone(obj) && obj->oeroded < MAX_ERODE) {
X  		if (obj->greased || obj->oerodeproof || (obj->blessed && rn2(3))) {
X***************
X*** 1716,1729 ****
X  
X  	if (mon->mcan || mon->mspec_used) {
X    		pline("%s acts as though %s has got a %sheadache.",
X!   			Monnam(mon), Blind ? "it" : fem ? "she" : "he",
X! 			mon->mcan ? "severe " : "");
X  		return 0;
X  	}
X  
X  	if (unconscious()) {
X  		pline("%s seems dismayed at your lack of response.",
X! 			Monnam(mon));
X  		return 0;
X  	}
X  
X--- 1800,1813 ----
X  
X  	if (mon->mcan || mon->mspec_used) {
X    		pline("%s acts as though %s has got a %sheadache.",
X! 		      Monnam(mon), he[pronoun_gender(mon)],
X! 		      mon->mcan ? "severe " : "");
X  		return 0;
X  	}
X  
X  	if (unconscious()) {
X  		pline("%s seems dismayed at your lack of response.",
X! 		      Monnam(mon));
X  		return 0;
X  	}
X  
X***************
X*** 2024,2030 ****
X  		    mattk->aatyp != AT_GAZE && mattk->aatyp != AT_EXPL &&
X  		    mattk->aatyp != AT_MAGC &&
X  #ifdef MUSE
X! 		    (!which_armor(mtmp, W_ARMG))) {
X  #else
X  		    (!is_mercenary(mdat) ||
X  				      !m_carrying(mtmp, LEATHER_GLOVES))) {
X--- 2108,2114 ----
X  		    mattk->aatyp != AT_GAZE && mattk->aatyp != AT_EXPL &&
X  		    mattk->aatyp != AT_MAGC &&
X  #ifdef MUSE
X! 		    (!(mtmp->misc_worn_check & W_ARMG))) {
X  #else
X  		    (!is_mercenary(mdat) ||
X  				      !m_carrying(mtmp, LEATHER_GLOVES))) {
X***************
X*** 2036,2041 ****
X--- 2120,2128 ----
X  		    pline("%s turns to stone!", Monnam(mtmp));
X  		    stoned = 1;
X  		    xkilled(mtmp, 0);
X+ #ifdef MUSE
X+ 		    if (mtmp->mhp > 0) return 1;
X+ #endif
X  		    return 2;
X  		}
X  		return 1;
X***************
X*** 2125,2130 ****
X--- 2212,2220 ----
X  	if((mtmp->mhp -= tmp) <= 0) {
X  		pline("%s dies!", Monnam(mtmp));
X  		xkilled(mtmp,0);
X+ #ifdef MUSE
X+ 		if (mtmp->mhp > 0) return 1;
X+ #endif
X  		return 2;
X  	}
X  	return 1;
X*** /tmp/da08309	Thu Feb 25 10:23:43 1993
X--- src/minion.c	Thu Feb 18 10:55:31 1993
X***************
X*** 8,32 ****
X  
X  void
X  msummon(ptr)		/* ptr summons a monster */
X! 	register struct permonst *ptr;
X  {
X! 	register int dtype = 0, cnt = 0;
X  
X! 	if(is_dprince(ptr) || (ptr == &mons[PM_WIZARD_OF_YENDOR])) {
X  
X! 	    dtype = (!rn2(20)) ? dprince() : (!rn2(4)) ? dlord() : ndemon();
X  	    cnt = (!rn2(4) && !is_dprince(&mons[dtype])) ? 2 : 1;
X  
X! 	} else if(is_dlord(ptr)) {
X  
X! 	    dtype = (!rn2(50)) ? dprince() : (!rn2(20)) ? dlord() : ndemon();
X  	    cnt = (!rn2(4) && is_ndemon(&mons[dtype])) ? 2 : 1;
X  
X! 	} else if(is_ndemon(ptr)) {
X  
X! 	    dtype = (!rn2(20)) ? dlord() : (!rn2(6)) ? ndemon() : monsndx(ptr);
X  	    cnt = 1;
X! 	} else if(is_lminion(ptr)) {
X  
X  	    dtype = (is_lord(ptr) && !rn2(20)) ? llord() :
X  		     (is_lord(ptr) || !rn2(6)) ? lminion() : monsndx(ptr);
X--- 8,35 ----
X  
X  void
X  msummon(ptr)		/* ptr summons a monster */
X! register struct permonst *ptr;
X  {
X! 	register int dtype = 0, cnt = 0, atyp = sgn(ptr->maligntyp);
X  
X! 	if (is_dprince(ptr) || (ptr == &mons[PM_WIZARD_OF_YENDOR])) {
X  
X! 	    dtype = (!rn2(20)) ? dprince(atyp) :
X! 				 (!rn2(4)) ? dlord(atyp) : ndemon(atyp);
X  	    cnt = (!rn2(4) && !is_dprince(&mons[dtype])) ? 2 : 1;
X  
X! 	} else if (is_dlord(ptr)) {
X  
X! 	    dtype = (!rn2(50)) ? dprince(atyp) :
X! 				 (!rn2(20)) ? dlord(atyp) : ndemon(atyp);
X  	    cnt = (!rn2(4) && is_ndemon(&mons[dtype])) ? 2 : 1;
X  
X! 	} else if (is_ndemon(ptr)) {
X  
X! 	    dtype = (!rn2(20)) ? dlord(atyp) :
X! 				 (!rn2(6)) ? ndemon(atyp) : monsndx(ptr);
X  	    cnt = 1;
X! 	} else if (is_lminion(ptr)) {
X  
X  	    dtype = (is_lord(ptr) && !rn2(20)) ? llord() :
X  		     (is_lord(ptr) || !rn2(6)) ? lminion() : monsndx(ptr);
X***************
X*** 34,43 ****
X  
X  	}
X  
X! 	if(!dtype) return;
X  
X! 	while(cnt > 0) {
X  
X  	    (void)makemon(&mons[dtype], u.ux, u.uy);
X  	    cnt--;
X  	}
X--- 37,55 ----
X  
X  	}
X  
X! 	if (!dtype) return;
X  
X! 	/*
X! 	 * If this daemon is unique and being re-summoned (the only way we
X! 	 * could get this far with an extinct dtype), try another.
X! 	 */
X! 	if (mons[dtype].geno & (G_EXTINCT | G_GENOD)) {
X! 	    dtype = ndemon(atyp);
X! 	    if (!dtype) return;
X! 	}
X  
X+ 	while (cnt > 0) {
X+ 
X  	    (void)makemon(&mons[dtype], u.ux, u.uy);
X  	    cnt--;
X  	}
X***************
X*** 46,80 ****
X  
X  void
X  summon_minion(alignment, talk)
X!     aligntyp alignment;
X!     boolean talk;
X  {
X      register struct monst *mon;
X      int mnum;
X  
X!     switch(alignment) {
X!     case A_LAWFUL: {
X! 	mnum = lminion();
X! 	break;
X      }
X!     case A_NEUTRAL: {
X! 	mnum = PM_AIR_ELEMENTAL + rn2(4);
X! 	break;
X!     }
X!     case A_CHAOTIC:
X! 	mnum = ndemon();
X! 	break;
X!     default:
X! 	impossible("unaligned player?");
X! 	mnum = ndemon();
X! 	break;
X!     }
X!     if(mons[mnum].pxlth == 0) {
X  	struct permonst *pm = &mons[mnum];
X  	pm->pxlth = sizeof(struct emin);
X  	mon = makemon(pm, u.ux, u.uy);
X  	pm->pxlth = 0;
X! 	if(mon) {
X  	    mon->isminion = TRUE;
X  	    EMIN(mon)->min_align = alignment;
X  	}
X--- 58,91 ----
X  
X  void
X  summon_minion(alignment, talk)
X! aligntyp alignment;
X! boolean talk;
X  {
X      register struct monst *mon;
X      int mnum;
X  
X!     switch ((int)alignment) {
X! 	case A_LAWFUL:
X! 	    mnum = lminion();
X! 	    break;
X! 	case A_NEUTRAL:
X! 	    mnum = PM_AIR_ELEMENTAL + rn2(4);
X! 	    break;
X! 	case A_CHAOTIC:
X! 	case A_NONE:
X! 	    mnum = ndemon(alignment);
X! 	    break;
X! 	default:
X! 	    impossible("unaligned player?");
X! 	    mnum = ndemon(A_NONE);
X! 	    break;
X      }
X!     if (mons[mnum].pxlth == 0) {
X  	struct permonst *pm = &mons[mnum];
X  	pm->pxlth = sizeof(struct emin);
X  	mon = makemon(pm, u.ux, u.uy);
X  	pm->pxlth = 0;
X! 	if (mon) {
X  	    mon->isminion = TRUE;
X  	    EMIN(mon)->min_align = alignment;
X  	}
X***************
X*** 86,96 ****
X  	}
X      } else
X  	mon = makemon(&mons[mnum], u.ux, u.uy);
X!     if(mon) {
X! 	if(talk) {
X  	    pline("The voice of %s booms:", align_gname(alignment));
X  	    verbalize("Thou shalt pay for thy indiscretion!");
X! 	    if(!Blind)
X  		pline("%s appears before you.", Amonnam(mon));
X  	}
X  	mon->mpeaceful = FALSE;
X--- 97,107 ----
X  	}
X      } else
X  	mon = makemon(&mons[mnum], u.ux, u.uy);
X!     if (mon) {
X! 	if (talk) {
X  	    pline("The voice of %s booms:", align_gname(alignment));
X  	    verbalize("Thou shalt pay for thy indiscretion!");
X! 	    if (!Blind)
X  		pline("%s appears before you.", Amonnam(mon));
X  	}
X  	mon->mpeaceful = FALSE;
X***************
X*** 106,112 ****
X  {
X  	long	demand, offer;
X  
X! 	if(uwep && uwep->oartifact == ART_EXCALIBUR) {
X  	    pline("%s looks very angry.", Amonnam(mtmp));
X  	    mtmp->mpeaceful = mtmp->mtame = 0;
X  	    newsym(mtmp->mx, mtmp->my);
X--- 117,123 ----
X  {
X  	long	demand, offer;
X  
X! 	if (uwep && uwep->oartifact == ART_EXCALIBUR) {
X  	    pline("%s looks very angry.", Amonnam(mtmp));
X  	    mtmp->mpeaceful = mtmp->mtame = 0;
X  	    newsym(mtmp->mx, mtmp->my);
X***************
X*** 114,125 ****
X  	}
X  
X  	/* Slight advantage given. */
X! 	if(is_dprince(mtmp->data) && mtmp->minvis) {
X  	    mtmp->minvis = 0;
X  	    if (!Blind) pline("%s appears before you.", Amonnam(mtmp));
X  	    newsym(mtmp->mx,mtmp->my);
X  	}
X! 	if(u.usym == S_DEMON) {	/* Won't blackmail their own. */
X  
X  	    pline("%s says, \"Good hunting, %s.\" and vanishes.",
X  		  Amonnam(mtmp), flags.female ? "Sister" : "Brother");
X--- 125,136 ----
X  	}
X  
X  	/* Slight advantage given. */
X! 	if (is_dprince(mtmp->data) && mtmp->minvis) {
X  	    mtmp->minvis = 0;
X  	    if (!Blind) pline("%s appears before you.", Amonnam(mtmp));
X  	    newsym(mtmp->mx,mtmp->my);
X  	}
X! 	if (u.usym == S_DEMON) {	/* Won't blackmail their own. */
X  
X  	    pline("%s says, \"Good hunting, %s.\" and vanishes.",
X  		  Amonnam(mtmp), flags.female ? "Sister" : "Brother");
X***************
X*** 126,144 ****
X  	    rloc(mtmp);
X  	    return(1);
X  	}
X! 	demand = (u.ugold * (rnd(80) + 20 * Athome)) / 100;
X! 	if(!demand)  		/* you have no gold */
X  	    return mtmp->mpeaceful = 0;
X  	else {
X- 
X  	    pline("%s demands %ld zorkmid%s for safe passage.",
X  		  Amonnam(mtmp), demand, plur(demand));
X  
X! 	    if((offer = bribe(mtmp)) >= demand) {
X  		pline("%s vanishes, laughing about cowardly mortals.",
X  		      Amonnam(mtmp));
X  	    } else {
X! 		if((long)rnd(40) > (demand - offer)) {
X  		    pline("%s scowls at you menacingly, then vanishes.",
X  			  Amonnam(mtmp));
X  		} else {
X--- 137,155 ----
X  	    rloc(mtmp);
X  	    return(1);
X  	}
X! 	demand = (u.ugold * (rnd(80) + 20 * Athome)) /
X! 		 100 * (1 + (sgn(u.ualign.type) == sgn(mtmp->data->maligntyp)));
X! 	if (!demand)  		/* you have no gold */
X  	    return mtmp->mpeaceful = 0;
X  	else {
X  	    pline("%s demands %ld zorkmid%s for safe passage.",
X  		  Amonnam(mtmp), demand, plur(demand));
X  
X! 	    if ((offer = bribe(mtmp)) >= demand) {
X  		pline("%s vanishes, laughing about cowardly mortals.",
X  		      Amonnam(mtmp));
X  	    } else {
X! 		if ((long)rnd(40) > (demand - offer)) {
X  		    pline("%s scowls at you menacingly, then vanishes.",
X  			  Amonnam(mtmp));
X  		} else {
X***************
X*** 161,174 ****
X  	getlin("How much will you offer?", buf);
X  	(void) sscanf(buf, "%ld", &offer);
X  
X! /*Michael Paddon -- fix for negative offer to monster*/	/*JAR880815 - */
X!  	if(offer < 0L) {
X!  		You("try to shortchange %s, but fumble.", 
X   			mon_nam(mtmp));
X   		offer = 0L;
X!  	} else if(offer == 0L) {
X  		You("refuse.");
X!  	} else if(offer >= u.ugold) {
X  		You("give %s all your gold.", mon_nam(mtmp));
X  		offer = u.ugold;
X  	} else You("give %s %ld zorkmid%s.", mon_nam(mtmp), offer,
X--- 172,186 ----
X  	getlin("How much will you offer?", buf);
X  	(void) sscanf(buf, "%ld", &offer);
X  
X! 	/*Michael Paddon -- fix for negative offer to monster*/
X! 	/*JAR880815 - */
X!  	if (offer < 0L) {
X!  		You("try to shortchange %s, but fumble.",
X   			mon_nam(mtmp));
X   		offer = 0L;
X!  	} else if (offer == 0L) {
X  		You("refuse.");
X!  	} else if (offer >= u.ugold) {
X  		You("give %s all your gold.", mon_nam(mtmp));
X  		offer = u.ugold;
X  	} else You("give %s %ld zorkmid%s.", mon_nam(mtmp), offer,
X***************
X*** 181,208 ****
X  }
X  
X  int
X! dprince() {
X! 	int	tryct, pm;
X  
X! 	for(tryct = 0; tryct < 20; tryct++) {
X  	    pm = rn1(PM_DEMOGORGON + 1 - PM_ORCUS, PM_ORCUS);
X! 	    if(!(mons[pm].geno & (G_GENOD | G_EXTINCT)))
X  		return(pm);
X  	}
X! 	return(dlord());	/* approximate */
X  }
X  
X  int
X! dlord()
X  {
X! 	int	tryct, pm;
X  
X! 	for(tryct = 0; tryct < 20; tryct++) {
X  	    pm = rn1(PM_YEENOGHU + 1 - PM_JUIBLEX, PM_JUIBLEX);
X! 	    if(!(mons[pm].geno & (G_GENOD | G_EXTINCT)))
X  		return(pm);
X  	}
X! 	return(ndemon());	/* approximate */
X  }
X  
X  /* create lawful (good) lord */
X--- 193,225 ----
X  }
X  
X  int
X! dprince(atyp)
X! aligntyp atyp;
X! {
X! 	int tryct, pm;
X  
X! 	for (tryct = 0; tryct < 20; tryct++) {
X  	    pm = rn1(PM_DEMOGORGON + 1 - PM_ORCUS, PM_ORCUS);
X! 	    if (!(mons[pm].geno & (G_GENOD | G_EXTINCT)) &&
X! 		    (atyp == A_NONE || sgn(mons[pm].maligntyp) == sgn(atyp)))
X  		return(pm);
X  	}
X! 	return(dlord(atyp));	/* approximate */
X  }
X  
X  int
X! dlord(atyp)
X! aligntyp atyp;
X  {
X! 	int tryct, pm;
X  
X! 	for (tryct = 0; tryct < 20; tryct++) {
X  	    pm = rn1(PM_YEENOGHU + 1 - PM_JUIBLEX, PM_JUIBLEX);
X! 	    if (!(mons[pm].geno & (G_GENOD | G_EXTINCT)) &&
X! 		    (atyp == A_NONE || sgn(mons[pm].maligntyp) == sgn(atyp)))
X  		return(pm);
X  	}
X! 	return(ndemon(atyp));	/* approximate */
X  }
X  
X  /* create lawful (good) lord */
X***************
X*** 209,215 ****
X  int
X  llord()
X  {
X! 	if(!(mons[PM_ARCHON].geno & (G_GENOD | G_EXTINCT)))
X  		return(PM_ARCHON);
X  
X  	return(lminion());	/* approximate */
X--- 226,232 ----
X  int
X  llord()
X  {
X! 	if (!(mons[PM_ARCHON].geno & (G_GENOD | G_EXTINCT)))
X  		return(PM_ARCHON);
X  
X  	return(lminion());	/* approximate */
X***************
X*** 221,235 ****
X  	int	tryct;
X  	struct	permonst *ptr;
X  
X! 	for(tryct = 0; tryct < 20; tryct++)
X! 	    if((ptr = mkclass(S_ANGEL,0)) && !is_lord(ptr))
X  		return(monsndx(ptr));
X  
X  	return(0);
X  }
X  
X  int
X! ndemon()
X  {
X  	int	tryct;
X  	struct	permonst *ptr;
X--- 238,255 ----
X  	int	tryct;
X  	struct	permonst *ptr;
X  
X! 	for (tryct = 0; tryct < 20; tryct++) {
X! 	    ptr = mkclass(S_ANGEL,0);
X! 	    if (ptr && !is_lord(ptr))
X  		return(monsndx(ptr));
X+ 	}
X  
X  	return(0);
X  }
X  
X  int
X! ndemon(atyp)
X! aligntyp atyp;
X  {
X  	int	tryct;
X  	struct	permonst *ptr;
X***************
X*** 236,242 ****
X  
X  	for (tryct = 0; tryct < 20; tryct++) {
X  	    ptr = mkclass(S_DEMON, 0);
X! 	    if (is_ndemon(ptr))
X  		return(monsndx(ptr));
X  	}
X  
X--- 256,263 ----
X  
X  	for (tryct = 0; tryct < 20; tryct++) {
X  	    ptr = mkclass(S_DEMON, 0);
X! 	    if (is_ndemon(ptr) &&
X! 		    (atyp == A_NONE || sgn(ptr->maligntyp) == sgn(atyp)))
X  		return(monsndx(ptr));
X  	}
X  
X*** /tmp/da08317	Thu Feb 25 10:23:45 1993
X--- src/mklev.c	Mon Feb 22 17:02:31 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)mklev.c	3.1	92/10/10	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)mklev.c	3.1	93/02/21	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 437,455 ****
X  	}
X  	*xx = dd.x;
X  	*yy = dd.y;
X! 	return(isok(*xx,*yy+*dy) && levl[*xx][(*yy)+(*dy)].typ == STONE);
X  }
X  
X! /* there should be one of these per trap */
X! const char *trap_engravings[TRAPNUM] = {
X! 				"", "", "", "", "", "", "",
X! 				"", "", "", "", "", "",
X! 				"ad ae?ar um", "?la? ?as ?er?", "ad ae?ar um",
X! 				"", "", "", ""
X  #ifdef POLYSELF
X! 				,""
X  #endif
X! 				};
X  
X  static void
X  makeniche(trap_type)
X--- 437,458 ----
X  	}
X  	*xx = dd.x;
X  	*yy = dd.y;
X! 	return((isok(*xx,*yy+*dy) && levl[*xx][*yy+*dy].typ == STONE)
X! 	    && (isok(*xx,*yy-*dy) && !IS_POOL(levl[*xx][*yy-*dy].typ)
X! 				  && !IS_FURNITURE(levl[*xx][*yy-*dy].typ)));
X  }
X  
X! /* there should be one of these per trap, in the same order as trap.h */
X! static NEARDATA const char *trap_engravings[TRAPNUM] = {
X! 				NULL, NULL, NULL, NULL, NULL, NULL,
X! 				NULL, NULL, NULL, NULL, NULL, NULL,
X! 			/* 12..14: trapdoor, teleport, level-teleport */
X! 				"?la? ?as ?er?", "ad ae?ar um", "ad ae?ar um",
X! 				NULL, NULL, NULL, NULL, NULL,
X  #ifdef POLYSELF
X! 				NULL,
X  #endif
X! };
X  
X  static void
X  makeniche(trap_type)
X***************
X*** 477,484 ****
X  			trap_type = ROCKTRAP;
X  		    ttmp = maketrap(xx, yy+dy, trap_type);
X  		    ttmp->once = 1;
X! 		    if (*trap_engravings[trap_type])
X! 			make_engr_at(xx, yy-dy, trap_engravings[trap_type], 0L, DUST);
X  		}
X  		dosdoor(xx, yy, aroom, SDOOR);
X  	    } else {
X--- 480,488 ----
X  			trap_type = ROCKTRAP;
X  		    ttmp = maketrap(xx, yy+dy, trap_type);
X  		    ttmp->once = 1;
X! 		    if (trap_engravings[trap_type])
X! 			make_engr_at(xx, yy-dy,
X! 				     trap_engravings[trap_type], 0L, DUST);
X  		}
X  		dosdoor(xx, yy, aroom, SDOOR);
X  	    } else {
X***************
X*** 571,576 ****
X--- 575,581 ----
X  	nroom = 0;
X  	rooms[0].hx = -1;
X  	nsubroom = 0;
X+ 	subrooms[0].hx = -1;
X  	doorindex = 0;
X  	init_rect();
X  	init_vault();
X***************
X*** 769,775 ****
X  				     somex(croom), somey(croom), TRUE);
X  
X  		/* maybe make some graffiti */
X! 		if(!rn2(27 + 3 * depth(&u.uz))) {
X  		    const char *mesg = random_engraving();
X  		    if (mesg) {
X  			do {
X--- 774,780 ----
X  				     somex(croom), somey(croom), TRUE);
X  
X  		/* maybe make some graffiti */
X! 		if(!rn2(27 + 3 * abs(depth(&u.uz)))) {
X  		    const char *mesg = random_engraving();
X  		    if (mesg) {
X  			do {
X***************
X*** 808,813 ****
X--- 813,820 ----
X  	makelevel();
X  	bound_digging();
X  	in_mklev = FALSE;
X+ 	/* has_morgue gets cleared once morgue entered; graveyard stays set */
X+ 	level.flags.graveyard = level.flags.has_morgue;
X  	if(!level.flags.is_maze_lev) {
X  	    for (croom = &rooms[0]; croom != &rooms[nroom]; croom++)
X  #ifdef SPECIALIZATION
X***************
X*** 1341,1347 ****
X  	extern int n_dgns;		/* from dungeon.c */
X  	d_level *source;
X  	branch *br;
X! 	xchar u_depth;
X  
X  	br = dungeon_branch("Fort Ludios");
X  	if (on_level(&knox_level, &br->end1)) {
X--- 1348,1354 ----
X  	extern int n_dgns;		/* from dungeon.c */
X  	d_level *source;
X  	branch *br;
X! 	schar u_depth;
X  
X  	br = dungeon_branch("Fort Ludios");
X  	if (on_level(&knox_level, &br->end1)) {
X*** /tmp/da08341	Thu Feb 25 10:23:52 1993
X--- src/mkobj.c	Wed Feb 17 09:26:55 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)mkobj.c	3.1	93/01/17	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)mkobj.c	3.1	93/02/10	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 66,72 ****
X  { 4, AMULET_CLASS}
X  };
X  
X! static int NEARDATA mksx=0, NEARDATA mksy=0;
X  
X  struct obj *
X  mkobj_at(let,x,y, artif)
X--- 66,72 ----
X  { 4, AMULET_CLASS}
X  };
X  
X! static NEARDATA int mksx=0, mksy=0;
X  
X  struct obj *
X  mkobj_at(let,x,y, artif)
X***************
X*** 598,604 ****
X  	if (obj->otyp == CORPSE && obj->corpsenm > -1)
X  		return (int)obj->quan * mons[obj->corpsenm].cwt;
X  	else if (obj->otyp == GOLD_PIECE)
X! 		return (int)((obj->quan + 500L) / 1000L);
X  	return(wt ? wt*(int)obj->quan : ((int)obj->quan + 1)>>1);
X  }
X  
X--- 598,604 ----
X  	if (obj->otyp == CORPSE && obj->corpsenm > -1)
X  		return (int)obj->quan * mons[obj->corpsenm].cwt;
X  	else if (obj->otyp == GOLD_PIECE)
X! 		return (int)((obj->quan + 50L) / 100L);
X  	return(wt ? wt*(int)obj->quan : ((int)obj->quan + 1)>>1);
X  }
X  
X***************
X*** 676,682 ****
X  		otmp = oname(otmp, nm, FALSE);
X  		fobj = otmp;
X  		level.objects[x][y] = otmp;
X- 		if (is_pool(x,y)) water_damage(otmp,TRUE);
X  	}
X  	return(otmp);
X  }
X--- 676,681 ----
X***************
X*** 689,697 ****
X  
X  	if (objects[otyp].oc_oprop == FIRE_RES) return FALSE;
X  
X! 	return((objects[otyp].oc_material == WOOD ||
X! 			objects[otyp].oc_material == 0));
X! 
X  }
X  
X  #endif /* OVLB */
X--- 688,695 ----
X  
X  	if (objects[otyp].oc_oprop == FIRE_RES) return FALSE;
X  
X! 	return((objects[otyp].oc_material <= WOOD &&
X! 			objects[otyp].oc_material != LIQUID));
X  }
X  
X  #endif /* OVLB */
X***************
X*** 719,725 ****
X  	otmp->nexthere = otmp2;
X  	level.objects[x][y] = otmp;
X      }
X-     if (is_pool(x,y)) water_damage(otmp,TRUE);
X  
X      /* set the new object's location */
X      otmp->ox = x;
X--- 717,722 ----
X*** /tmp/da08349	Thu Feb 25 10:23:56 1993
X--- src/mkroom.c	Thu Feb  4 10:41:22 1993
X***************
X*** 371,378 ****
X  	register int i = rn2(100), hd = rn2(level_difficulty());
X  
X  	if(hd > 10 && i < 10)
X! 		return((Inhell || In_endgame(&u.uz)) ? 
X! 		                    mkclass(S_DEMON,0) : &mons[ndemon()]);
X  	if(hd > 8 && i > 85)
X  		return(mkclass(S_VAMPIRE,0));
X  
X--- 371,378 ----
X  	register int i = rn2(100), hd = rn2(level_difficulty());
X  
X  	if(hd > 10 && i < 10)
X! 		return((Inhell || In_endgame(&u.uz)) ? mkclass(S_DEMON,0) :
X! 						       &mons[ndemon(A_NONE)]);
X  	if(hd > 8 && i > 85)
X  		return(mkclass(S_VAMPIRE,0));
X  
X*** /tmp/da08357	Thu Feb 25 10:23:58 1993
X--- src/mon.c	Wed Feb 24 16:22:21 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)mon.c	3.1	93/01/19	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)mon.c	3.1	93/02/21	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 230,236 ****
X  {
X      boolean inpool, infountain;
X  
X!     inpool = is_pool(mtmp->mx,mtmp->my);
X      infountain = IS_FOUNTAIN(levl[mtmp->mx][mtmp->my].typ);
X  
X      /* Gremlin multiplying won't go on forever since the hit points
X--- 230,237 ----
X  {
X      boolean inpool, infountain;
X  
X!     inpool = is_pool(mtmp->mx,mtmp->my) &&
X! 	     !is_flyer(mtmp->data) && !is_floater(mtmp->data);
X      infountain = IS_FOUNTAIN(levl[mtmp->mx][mtmp->my].typ);
X  
X      /* Gremlin multiplying won't go on forever since the hit points
X***************
X*** 246,260 ****
X  		pline("%s multiplies.", Monnam(mtmp));
X  	    dryup(mtmp->mx,mtmp->my);
X  	}
X  	return (0);
X      }
X      if (inpool) {
X! 	/* most monsters drown in pools */
X! 	if (!is_flyer(mtmp->data) && !is_clinger(mtmp->data)
X  	    && !is_swimmer(mtmp->data) && !magic_breathing(mtmp->data)) {
X  	    if (cansee(mtmp->mx,mtmp->my))
X  		pline("%s drowns.", Monnam(mtmp));
X  	    mondead(mtmp);
X  	    return (1);
X  	}
X      } else {
X--- 247,272 ----
X  		pline("%s multiplies.", Monnam(mtmp));
X  	    dryup(mtmp->mx,mtmp->my);
X  	}
X+ 	if (inpool) water_damage(mtmp->minvent, FALSE, FALSE);
X  	return (0);
X      }
X      if (inpool) {
X! 	/* Most monsters drown in pools.  flooreffects() will take care of
X! 	 * water damage to dead monsters' inventory, but survivors need to
X! 	 * be handled here.  Swimmers are able to protect their stuff...
X! 	 */
X! 	if (!is_clinger(mtmp->data)
X  	    && !is_swimmer(mtmp->data) && !magic_breathing(mtmp->data)) {
X  	    if (cansee(mtmp->mx,mtmp->my))
X  		pline("%s drowns.", Monnam(mtmp));
X  	    mondead(mtmp);
X+ #ifdef MUSE
X+ 	    if (mtmp->mhp > 0) {
X+ 		rloc(mtmp);
X+ 		water_damage(mtmp->minvent, FALSE, FALSE);
X+ 		return 0;
X+ 	    }
X+ #endif
X  	    return (1);
X  	}
X      } else {
X***************
X*** 494,503 ****
X  #ifdef MUSE
X  		!str ? searches_for_item(mtmp,otmp) :
X  #endif
X! 		  (index(str, otmp->oclass)
X! 		   && (otmp->otyp != CORPSE || mtmp->data->mlet == S_NYMPH))) {
X! 		if (!touch_artifact(otmp,mtmp)) return;
X! 		if (!can_carry(mtmp,otmp)) return;
X  		if (cansee(mtmp->mx,mtmp->my) && flags.verbose)
X  			pline("%s picks up %s.", Monnam(mtmp), doname(otmp));
X  		freeobj(otmp);
X--- 506,520 ----
X  #ifdef MUSE
X  		!str ? searches_for_item(mtmp,otmp) :
X  #endif
X! 		  !!(index(str, otmp->oclass))) {
X! 		if (otmp->otyp == CORPSE && mtmp->data->mlet != S_NYMPH
X! #ifdef MUSE
X!     && (otmp->corpsenm != PM_COCKATRICE || !(mtmp->misc_worn_check & W_ARMG))
X! #endif
X! 									)
X! 			continue;
X! 		if (!touch_artifact(otmp,mtmp)) continue;
X! 		if (!can_carry(mtmp,otmp)) continue;
X  		if (cansee(mtmp->mx,mtmp->my) && flags.verbose)
X  			pline("%s picks up %s.", Monnam(mtmp), doname(otmp));
X  		freeobj(otmp);
X***************
X*** 565,570 ****
X--- 582,590 ----
X  	register int newload = otmp->owt;
X  
X  	if (otmp->otyp == CORPSE && otmp->corpsenm == PM_COCKATRICE
X+ #ifdef MUSE
X+ 			&& !(mtmp->misc_worn_check & W_ARMG)
X+ #endif
X  						&& !resists_ston(mtmp->data))
X  		return(FALSE);
X  	if (mtmp->isshk) return(TRUE); /* no limit */
X***************
X*** 624,631 ****
X  	for(nx = max(1,x-1); nx <= maxx; nx++)
X  	  for(ny = max(0,y-1); ny <= maxy; ny++) {
X  	    if(nx == x && ny == y) continue;
X! 	    if(IS_ROCK(ntyp = levl[nx][ny].typ) && !(flag & ALLOW_WALL) &&
X! 		!((flag & ALLOW_DIG) && may_dig(nx,ny))) continue;
X  	    if(IS_DOOR(ntyp) && !amorphous(mon->data) &&
X  	       ((levl[nx][ny].doormask & D_CLOSED && !(flag & OPENDOOR)) ||
X  		(levl[nx][ny].doormask & D_LOCKED && !(flag & UNLOCKDOOR))
X--- 644,652 ----
X  	for(nx = max(1,x-1); nx <= maxx; nx++)
X  	  for(ny = max(0,y-1); ny <= maxy; ny++) {
X  	    if(nx == x && ny == y) continue;
X! 	    if(IS_ROCK(ntyp = levl[nx][ny].typ) &&
X! 	       !((flag & ALLOW_WALL) && may_passwall(nx,ny)) &&
X! 	       !((flag & ALLOW_DIG) && may_dig(nx,ny))) continue;
X  	    if(IS_DOOR(ntyp) && !amorphous(mon->data) &&
X  	       ((levl[nx][ny].doormask & D_CLOSED && !(flag & OPENDOOR)) ||
X  		(levl[nx][ny].doormask & D_LOCKED && !(flag & UNLOCKDOOR))
X***************
X*** 837,842 ****
X--- 858,903 ----
X  	if(mtmp->wormno) wormgone(mtmp);
X  }
X  
X+ #ifdef MUSE
X+ static void FDECL(lifesaved_monster, (struct monst *));
X+ 
X+ static void
X+ lifesaved_monster(mtmp)
X+ struct monst *mtmp;
X+ {
X+ 	struct obj *lifesave;
X+ 
X+ 	if ((lifesave = which_armor(mtmp, W_AMUL))
X+ 			&& lifesave->otyp == AMULET_OF_LIFE_SAVING) {
X+ 		pline("But wait...");
X+ 		if (canseemon(mtmp)) {
X+ 			pline("%s's medallion begins to glow!",
X+ 				Monnam(mtmp));
X+ 			makeknown(AMULET_OF_LIFE_SAVING);
X+ 			pline("%s looks much better!", Monnam(mtmp));
X+ 			pline("The medallion crumbles to dust!");
X+ 		} else
X+ 			pline("Maybe not...");
X+ 		m_useup(mtmp, lifesave);
X+ 		if (mtmp->mhpmax <= 0) mtmp->mhpmax = 10;
X+ 		mtmp->mhp = mtmp->mhpmax;
X+ 		mtmp->mcanmove = 1;
X+ 		mtmp->mfrozen = 0;
X+ 		if (mtmp->mtame && !mtmp->isminion) {
X+ 			struct edog *edog = EDOG(mtmp);
X+ 			if (edog->hungrytime < moves+500)
X+ 				edog->hungrytime = moves+500;
X+ 		}
X+ 		if (mtmp->data->geno & G_GENOD)
X+ 			pline("Unfortunately %s is still genocided...",
X+ 				mon_nam(mtmp));
X+ 		else
X+ 			return;
X+ 	}
X+ 	mtmp->mhp = 0;
X+ }
X+ #endif
X+ 
X  void
X  mondead(mtmp)
X  register struct monst *mtmp;
X***************
X*** 848,853 ****
X--- 909,918 ----
X  		 * the m_detach or there will be relmon problems later */
X  		if(!grddead(mtmp)) return;
X  	}
X+ #ifdef MUSE
X+ 	lifesaved_monster(mtmp);
X+ 	if (mtmp->mhp > 0) return;
X+ #endif
X  
X  	/* restore chameleon, lycanthropes to true form at death */
X  	if(mtmp->cham) mtmp->data = &mons[PM_CHAMELEON];
X***************
X*** 948,953 ****
X--- 1013,1027 ----
X  	struct obj *otmp, *contents;
X  	xchar x = mdef->mx, y = mdef->my;
X  
X+ #ifdef MUSE
X+ 	/* we have to make the statue before calling mondead, to be able to
X+ 	 * put inventory in it, and we have to check for lifesaving before
X+ 	 * making the statue....
X+ 	 */
X+ 	lifesaved_monster(mdef);
X+ 	if (mdef->mhp > 0) return;
X+ #endif
X+ 
X  	if((int)mdef->data->msize > MZ_TINY ||
X  	   !rn2(2 + ((mdef->data->geno & G_FREQ) > 2))) {
X  		otmp = mk_named_object(STATUE, mdef->data, x, y,
X***************
X*** 971,980 ****
X  	} else
X  		otmp = mksobj_at(ROCK, x, y, TRUE);
X  
X- 	mondead(mdef);
X- 
X  	stackobj(otmp);
X  	if (cansee(x, y)) newsym(x,y);
X  }
X  
X  /* another monster has killed the monster mdef */
X--- 1045,1053 ----
X  	} else
X  		otmp = mksobj_at(ROCK, x, y, TRUE);
X  
X  	stackobj(otmp);
X  	if (cansee(x, y)) newsym(x,y);
X+ 	mondead(mdef);
X  }
X  
X  /* another monster has killed the monster mdef */
X***************
X*** 1066,1071 ****
X--- 1139,1148 ----
X  	if(stoned) monstone(mtmp);
X  	else mondead(mtmp);
X  
X+ #ifdef MUSE
X+ 	if (mtmp->mhp > 0) return; /* monster lifesaved */
X+ #endif
X+ 
X  	mdat = mtmp->data; /* note: mondead can change mtmp->data */
X  
X  	if (stoned) {
X***************
X*** 1077,1083 ****
X  #ifdef REINCARNATION
X  		 || Is_rogue_level(&u.uz)
X  #endif
X! 	   || (mdat == &mons[PM_WRAITH] && Is_valley(&u.uz) && rn2(5)))
X  		goto cleanup;
X  
X  #ifdef MAIL
X--- 1154,1161 ----
X  #ifdef REINCARNATION
X  		 || Is_rogue_level(&u.uz)
X  #endif
X! 	   || (level.flags.graveyard && is_undead(mdat) &&
X! 			rn2(mdat == &mons[PM_WRAITH] ? 5 : 2)))
X  		goto cleanup;
X  
X  #ifdef MAIL
X***************
X*** 1136,1142 ****
X  	if(redisp) newsym(x,y);
X  cleanup:
X  	/* punish bad behaviour */
X! 	if(is_human(mdat) && !always_hostile(mdat) &&
X  	   (monsndx(mdat) < PM_ARCHEOLOGIST || monsndx(mdat) > PM_WIZARD) &&
X  	   u.ualign.type != A_CHAOTIC) {
X  		HTelepat &= ~INTRINSIC;
X--- 1214,1220 ----
X  	if(redisp) newsym(x,y);
X  cleanup:
X  	/* punish bad behaviour */
X! 	if(is_human(mdat) && (!always_hostile(mdat) && mtmp->malign <= 0) &&
X  	   (monsndx(mdat) < PM_ARCHEOLOGIST || monsndx(mdat) > PM_WIZARD) &&
X  	   u.ualign.type != A_CHAOTIC) {
X  		HTelepat &= ~INTRINSIC;
X***************
X*** 1321,1328 ****
X--- 1399,1421 ----
X      if(mtmp->data->msound == MS_SHRIEK) {
X  	if(flags.soundok)
X  	    pline("%s shrieks.", Monnam(mtmp));
X+ 	if (!rn2(10)) {
X+ 	    if (!rn2(13))
X+ 		(void) makemon(&mons[PM_PURPLE_WORM], 0, 0);
X+ 	    else
X+ 		(void) makemon((struct permonst *)0, 0, 0);
X+ 
X+ 	}
X  	aggravate();
X      }
X+     if(mtmp->data == &mons[PM_MEDUSA] && !mtmp->mcan) {
X+ 	register int i;
X+ 	for(i = 0; i < NATTK; i++)
X+ 	     if(mtmp->data->mattk[i].aatyp == AT_GAZE) {
X+ 		 (void) gazemu(mtmp, &mtmp->data->mattk[i]);
X+ 		 break;
X+ 	     }
X+     }
X  }
X  
X  #endif /* OVLB */
X***************
X*** 1552,1557 ****
X--- 1645,1654 ----
X  	newsym(mtmp->mx,mtmp->my);
X  #ifdef MUSE
X  	mon_break_armor(mtmp);
X+ 	/* Unfortunately, by now we forgot who did the polymorph, so we don't
X+ 	 * have any way to give the player credit if this was a polymorph wand.
X+ 	 */
X+ 	mselftouch(mtmp, "No longer petrify-resistant, ", FALSE);
X  	possibly_unwield(mtmp);
X  #endif
X  	return(1);
X*** /tmp/da08365	Thu Feb 25 10:24:01 1993
X--- src/mondata.c	Thu Feb 11 14:36:36 1993
X***************
X*** 274,282 ****
X  /* returns 3 values (0=male, 1=female, 2=none) */
X  int
X  gender(mtmp)
X! 	register struct monst *mtmp;
X  {
X  	if (is_neuter(mtmp->data)) return 2;
X  	return mtmp->female;
X  }
X  
X--- 274,291 ----
X  /* returns 3 values (0=male, 1=female, 2=none) */
X  int
X  gender(mtmp)
X! register struct monst *mtmp;
X  {
X  	if (is_neuter(mtmp->data)) return 2;
X+ 	return mtmp->female;
X+ }
X+ 
X+ /* like gender(), but lower animals and such are still "it" */
X+ int
X+ pronoun_gender(mtmp)
X+ register struct monst *mtmp;
X+ {
X+ 	if (Blind || !humanoid(mtmp->data)) return 2;
X  	return mtmp->female;
X  }
X  
X*** /tmp/da08373	Thu Feb 25 10:24:03 1993
X--- src/monmove.c	Thu Feb 18 10:59:32 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)monmove.c	3.1	92/12/06	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)monmove.c	3.1	93/02/17	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 10,22 ****
X  
X  static int FDECL(disturb,(struct monst *));
X  static void FDECL(distfleeck,(struct monst *,int *,int *,int *));
X  
X  #endif /* OVL0 */
X- #ifdef OVL1
X- 
X- STATIC_OVL boolean FDECL(mdig_tunnel,(struct monst *));
X- 
X- #endif /* OVL1 */
X  #ifdef OVLB
X  
X  boolean /* TRUE : mtmp died */
X--- 10,19 ----
X  
X  static int FDECL(disturb,(struct monst *));
X  static void FDECL(distfleeck,(struct monst *,int *,int *,int *));
X+ STATIC_DCL boolean FDECL(mdig_tunnel,(struct monst *));
X+ static void FDECL(watch_on_duty,(struct monst *));
X  
X  #endif /* OVL0 */
X  #ifdef OVLB
X  
X  boolean /* TRUE : mtmp died */
X***************
X*** 33,46 ****
X  	mtmp->mhp -= rnd(15);
X  	if(mtmp->mhp <= 0) {
X  		mondied(mtmp);
X! 		return(TRUE);
X  	}
X  	return(FALSE);
X  }
X  
X  #endif /* OVLB */
X! #ifdef OVL1
X  
X  /* Return TRUE if monster died, FALSE otherwise. */
X  STATIC_OVL boolean
X  mdig_tunnel(mtmp)
X--- 30,77 ----
X  	mtmp->mhp -= rnd(15);
X  	if(mtmp->mhp <= 0) {
X  		mondied(mtmp);
X! #ifdef MUSE
X! 		if (mtmp->mhp > 0) /* lifesaved */
X! 			return(FALSE);
X! 		else
X! #endif
X! 			return(TRUE);
X  	}
X  	return(FALSE);
X  }
X  
X  #endif /* OVLB */
X! #ifdef OVL0
X  
X+ static void
X+ watch_on_duty(mtmp)
X+ register struct monst *mtmp;
X+ {
X+ 	register s_level *slev = Is_special(&u.uz);
X+ 	int	x, y;
X+ 
X+ 	if(slev && slev->flags.town && mtmp->mpeaceful &&
X+ 	   m_canseeu(mtmp) && !rn2(3)) {
X+ 
X+ 	    if(picking_lock(&x, &y) && IS_DOOR(levl[x][y].typ) &&
X+ 	       (levl[x][y].doormask & D_LOCKED)) {
X+ 
X+ 		if(couldsee(mtmp->mx, mtmp->my)) {
X+ 
X+ 		  pline("%s yells:", Amonnam(mtmp));
X+ 		  if(levl[x][y].looted & D_WARNED) {
X+ 			verbalize("Halt, thief!  You're under arrest!");
X+ 			angry_guards(!(flags.soundok));
X+ 		  } else {
X+ 			verbalize("Hey, stop picking that lock!");
X+ 			levl[x][y].looted |=  D_WARNED;
X+ 		  }
X+ 		  stop_occupation();
X+ 		}
X+ 	    }
X+ 	}
X+ }
X+ 
X  /* Return TRUE if monster died, FALSE otherwise. */
X  STATIC_OVL boolean
X  mdig_tunnel(mtmp)
X***************
X*** 65,71 ****
X  		}
X  	    } else {
X  		if(!rn2(3) && flags.verbose)	/* not too often.. */
X! 		    You("feel an unexpected draft of air.");
X  		here->doormask = D_BROKEN;
X  	    }
X  	    newsym(mtmp->mx,mtmp->my);
X--- 96,102 ----
X  		}
X  	    } else {
X  		if(!rn2(3) && flags.verbose)	/* not too often.. */
X! 		    You("feel an unexpected draft.");
X  		here->doormask = D_BROKEN;
X  	    }
X  	    newsym(mtmp->mx,mtmp->my);
X***************
X*** 84,90 ****
X  
X  	if(IS_WALL(here->typ)) {
X  	    if(flags.soundok && flags.verbose && !rn2(5))
X! 		You("hear the sound of crashing rock.");
X  	    if (*in_rooms(mtmp->mx, mtmp->my, SHOPBASE))
X  	    	add_damage(mtmp->mx, mtmp->my, 0L);
X  	    if (level.flags.is_maze_lev) {
X--- 115,121 ----
X  
X  	if(IS_WALL(here->typ)) {
X  	    if(flags.soundok && flags.verbose && !rn2(5))
X! 		You("hear crashing rock.");
X  	    if (*in_rooms(mtmp->mx, mtmp->my, SHOPBASE))
X  	    	add_damage(mtmp->mx, mtmp->my, 0L);
X  	    if (level.flags.is_maze_lev) {
X***************
X*** 108,113 ****
X--- 139,147 ----
X  	return FALSE ;
X  }
X  
X+ #endif /* OVL0 */
X+ #ifdef OVL1
X+ 
X  int
X  dochugw(mtmp)
X  	register struct monst *mtmp;
X***************
X*** 302,323 ****
X  	wipe_engr_at(mtmp->mx, mtmp->my, 1);
X  
X  	/* confused monsters get unconfused with small probability */
X! 	if(mtmp->mconf && !rn2(50)) mtmp->mconf = 0;
X  
X  	/* stunned monsters get un-stunned with larger probability */
X! 	if(mtmp->mstun && !rn2(10)) mtmp->mstun = 0;
X  
X  	/* some monsters teleport */
X! 	if(mtmp->mflee && !rn2(40) && can_teleport(mdat) && !mtmp->iswiz) {
X  		rloc(mtmp);
X  		return(0);
X  	}
X! 	if(mdat->msound == MS_SHRIEK && !um_dist(mtmp->mx, mtmp->my, 1))
X  	    m_respond(mtmp);
X! 	if(mdat->mmove < rnd(6)) return(0);
X  
X  	/* fleeing monsters might regain courage */
X! 	if(mtmp->mflee && !mtmp->mfleetim
X  	   && mtmp->mhp == mtmp->mhpmax && !rn2(25)) mtmp->mflee = 0;
X  
X  	set_apparxy(mtmp);
X--- 336,359 ----
X  	wipe_engr_at(mtmp->mx, mtmp->my, 1);
X  
X  	/* confused monsters get unconfused with small probability */
X! 	if (mtmp->mconf && !rn2(50)) mtmp->mconf = 0;
X  
X  	/* stunned monsters get un-stunned with larger probability */
X! 	if (mtmp->mstun && !rn2(10)) mtmp->mstun = 0;
X  
X  	/* some monsters teleport */
X! 	if (mtmp->mflee && !rn2(40) && can_teleport(mdat) && !mtmp->iswiz) {
X  		rloc(mtmp);
X  		return(0);
X  	}
X! 	if (mdat->msound == MS_SHRIEK && !um_dist(mtmp->mx, mtmp->my, 1))
X  	    m_respond(mtmp);
X! 	if (mdat == &mons[PM_MEDUSA] && cansee(mtmp->mx, mtmp->my))
X! 	    m_respond(mtmp);
X! 	if (mdat->mmove < rnd(6)) return(0);
X  
X  	/* fleeing monsters might regain courage */
X! 	if (mtmp->mflee && !mtmp->mfleetim
X  	   && mtmp->mhp == mtmp->mhpmax && !rn2(25)) mtmp->mflee = 0;
X  
X  	set_apparxy(mtmp);
X***************
X*** 347,353 ****
X  	if(nearby && mdat->msound == MS_BRIBE &&
X  	   mtmp->mpeaceful && !mtmp->mtame) {
X  		if (mtmp->mux != u.ux || mtmp->muy != u.uy) {
X! 			pline("%s whispers something to thin air.",
X  			    cansee(mtmp->mux, mtmp->muy) ? Monnam(mtmp) : "It");
X  #ifdef POLYSELF
X  			if (is_demon(uasmon)) rloc(mtmp);
X--- 383,389 ----
X  	if(nearby && mdat->msound == MS_BRIBE &&
X  	   mtmp->mpeaceful && !mtmp->mtame) {
X  		if (mtmp->mux != u.ux || mtmp->muy != u.uy) {
X! 			pline("%s whispers at thin air.",
X  			    cansee(mtmp->mux, mtmp->muy) ? Monnam(mtmp) : "It");
X  #ifdef POLYSELF
X  			if (is_demon(uasmon)) rloc(mtmp);
X***************
X*** 356,362 ****
X  #endif
X  			    mtmp->minvis = 0;
X  			    /* Why?  For the same reason in real demon talk */
X! 			    pline("%s gets angry.", Amonnam(mtmp));
X  			    mtmp->mpeaceful = 0;
X  			    /* since no way is an image going to pay it off */
X  #ifdef POLYSELF
X--- 392,398 ----
X  #endif
X  			    mtmp->minvis = 0;
X  			    /* Why?  For the same reason in real demon talk */
X! 			    pline("%s gets angry!", Amonnam(mtmp));
X  			    mtmp->mpeaceful = 0;
X  			    /* since no way is an image going to pay it off */
X  #ifdef POLYSELF
X***************
X*** 365,371 ****
X  		} else if(demon_talk(mtmp)) return(1);	/* you paid it off */
X  	}
X  
X! 	if (mdat == &mons[PM_MIND_FLAYER] && !rn2(20)) {
X  		struct monst *m2, *nmon = (struct monst *)0;
X  
X  		if (canseemon(mtmp))
X--- 401,411 ----
X  		} else if(demon_talk(mtmp)) return(1);	/* you paid it off */
X  	}
X  
X! 	/* the watch will look around and see if you are up to no good :-) */
X! 	if (mdat == &mons[PM_WATCHMAN] || mdat == &mons[PM_WATCH_CAPTAIN]) 
X! 		watch_on_duty(mtmp);
X! 
X! 	else if (mdat == &mons[PM_MIND_FLAYER] && !rn2(20)) {
X  		struct monst *m2, *nmon = (struct monst *)0;
X  
X  		if (canseemon(mtmp))
X***************
X*** 374,389 ****
X  			You("sense a faint wave of psychic energy.");
X  			goto toofar;
X  		}
X! 		You("sense a wave of psychic energy pouring over you!");
X  		if (mtmp->mpeaceful &&
X  		    (!Conflict || resist(mtmp, RING_CLASS, 0, 0)))
X! 			pline("It seems quite soothing.");
X  		else {
X  			register boolean m_sen = sensemon(mtmp);
X  
X  			if (m_sen || (Telepat && rn2(2)) || !rn2(10)) {
X  				int dmg;
X! 				pline("It locks in on your %s!",
X  					m_sen ? "telepathy" :
X  					Telepat ? "latent telepathy" : "mind");
X  				dmg = rnd(15);
X--- 414,429 ----
X  			You("sense a faint wave of psychic energy.");
X  			goto toofar;
X  		}
X! 		pline("A wave of psychic energy pours over you!");
X  		if (mtmp->mpeaceful &&
X  		    (!Conflict || resist(mtmp, RING_CLASS, 0, 0)))
X! 			pline("It feels quite soothing.");
X  		else {
X  			register boolean m_sen = sensemon(mtmp);
X  
X  			if (m_sen || (Telepat && rn2(2)) || !rn2(10)) {
X  				int dmg;
X! 				pline("It locks on to your %s!",
X  					m_sen ? "telepathy" :
X  					Telepat ? "latent telepathy" : "mind");
X  				dmg = rnd(15);
X***************
X*** 399,405 ****
X  			if ((telepathic(m2->data) &&
X  			    (rn2(2) || m2->mblinded)) || !rn2(10)) {
X  				if (cansee(m2->mx, m2->my))
X! 				    pline("It locks in on %s.", mon_nam(m2));
X  				m2->mhp -= rnd(15);
X  				if (m2->mhp <= 0)
X  				    monkilled(m2, "", AD_DRIN);
X--- 439,445 ----
X  			if ((telepathic(m2->data) &&
X  			    (rn2(2) || m2->mblinded)) || !rn2(10)) {
X  				if (cansee(m2->mx, m2->my))
X! 				    pline("It locks on to %s.", mon_nam(m2));
X  				m2->mhp -= rnd(15);
X  				if (m2->mhp <= 0)
X  				    monkilled(m2, "", AD_DRIN);
X***************
X*** 484,494 ****
X  	return(tmp == 2);
X  }
X  
X! static const char NEARDATA practical[] = { WEAPON_CLASS, ARMOR_CLASS, GEM_CLASS, FOOD_CLASS, 0 };
X! static const char NEARDATA magical[] = {
X  	AMULET_CLASS, POTION_CLASS, SCROLL_CLASS, WAND_CLASS, RING_CLASS,
X  	SPBOOK_CLASS, 0 };
X! static const char NEARDATA indigestion[] = { BALL_CLASS, ROCK_CLASS, 0 };
X  
X  #ifdef POLYSELF
X  boolean
X--- 524,534 ----
X  	return(tmp == 2);
X  }
X  
X! static NEARDATA const char practical[] = { WEAPON_CLASS, ARMOR_CLASS, GEM_CLASS, FOOD_CLASS, 0 };
X! static NEARDATA const char magical[] = {
X  	AMULET_CLASS, POTION_CLASS, SCROLL_CLASS, WAND_CLASS, RING_CLASS,
X  	SPBOOK_CLASS, 0 };
X! static NEARDATA const char indigestion[] = { BALL_CLASS, ROCK_CLASS, 0 };
X  
X  #ifdef POLYSELF
X  boolean
X***************
X*** 710,718 ****
X  	    for(otmp = fobj; otmp; otmp = otmp->nobj) {
X  		xx = otmp->ox;
X  		yy = otmp->oy;
X  		if(xx >= lmx && xx <= oomx && yy >= lmy && yy <= oomy) {
X  		    if(((likegold && otmp->otyp == GOLD_PIECE) ||
X! 		       (likeobjs && index(practical, otmp->oclass)) ||
X  		       (likemagic && index(magical, otmp->oclass)) ||
X  #ifdef MUSE
X  		       (uses_items && searches_for_item(mtmp, otmp)) ||
X--- 750,764 ----
X  	    for(otmp = fobj; otmp; otmp = otmp->nobj) {
X  		xx = otmp->ox;
X  		yy = otmp->oy;
X+ 		/* Nymphs take everything.  Most other creatures should not
X+ 		 * pick up corpses except as a special case like in
X+ 		 * searches_for_item().  We need to do this check in
X+ 		 * mpickstuff() as well.
X+ 		 */
X  		if(xx >= lmx && xx <= oomx && yy >= lmy && yy <= oomy) {
X  		    if(((likegold && otmp->otyp == GOLD_PIECE) ||
X! 		       (likeobjs && index(practical, otmp->oclass) &&
X! 			(otmp->otyp != CORPSE || ptr->mlet == S_NYMPH)) ||
X  		       (likemagic && index(magical, otmp->oclass)) ||
X  #ifdef MUSE
X  		       (uses_items && searches_for_item(mtmp, otmp)) ||
X***************
X*** 918,926 ****
X  		    } else {
X  			if (flags.verbose) {
X  			    if (canseeit)
X! 			      You("see a door being unlocked and opened.");
X  			    else if (flags.soundok)
X! 			       You("hear a door being unlocked and opened.");
X  		        }
X  		        here->doormask = D_ISOPEN;
X  			/* newsym(mtmp->mx, mtmp->my); */
X--- 964,972 ----
X  		    } else {
X  			if (flags.verbose) {
X  			    if (canseeit)
X! 			       You("see a door unlock and open.");
X  			    else if (flags.soundok)
X! 			       You("hear a door unlock and open.");
X  		        }
X  		        here->doormask = D_ISOPEN;
X  			/* newsym(mtmp->mx, mtmp->my); */
X***************
X*** 935,943 ****
X  		    } else {
X  		        if (flags.verbose) {
X  			    if (canseeit)
X! 			         You("see a door being opened.");
X  			    else if (flags.soundok)
X! 			         You("hear the sound of a door opening.");
X  		        }
X  		        here->doormask = D_ISOPEN;
X  			/* newsym(mtmp->mx, mtmp->my); */  /* done below */
X--- 981,989 ----
X  		    } else {
X  		        if (flags.verbose) {
X  			    if (canseeit)
X! 			         You("see a door open.");
X  			    else if (flags.soundok)
X! 			         You("hear a door open.");
X  		        }
X  		        here->doormask = D_ISOPEN;
X  			/* newsym(mtmp->mx, mtmp->my); */  /* done below */
X***************
X*** 955,961 ****
X  			    if (canseeit)
X  			        You("see a door crash open.");
X  			    else if (flags.soundok)
X! 			        You("hear the sound of a door crashing open.");
X  		        }
X  		        if (here->doormask & D_LOCKED && !rn2(2))
X  			        here->doormask = D_NODOOR;
X--- 1001,1007 ----
X  			    if (canseeit)
X  			        You("see a door crash open.");
X  			    else if (flags.soundok)
X! 			        You("hear a door crash open.");
X  		        }
X  		        if (here->doormask & D_LOCKED && !rn2(2))
X  			        here->doormask = D_NODOOR;
X
END_OF_FILE
if test 55585 -ne `wc -c <'patches01e'`; then
    echo shar: \"'patches01e'\" unpacked with wrong size!
fi
# end of 'patches01e'
echo shar: End of archive 6 \(of 31\).
cp /dev/null ark6isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 31 archives.
    echo "Now execute 'patchit.sh'"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
