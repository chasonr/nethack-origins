Relay-Version: version B 2.10 5/3/83; site utzoo.UUCP
Path: utzoo!mnetor!uunet!tektronix!tekgen!tekred!games-request
From: games-request@tekred.TEK.COM
Newsgroups: comp.sources.games
Subject: v03i008:  NetHack2.2 - display oriented dungeons and dragons, Part08/20
Message-ID: <1894@tekred.TEK.COM>
Date: Wed, 2-Dec-87 11:59:45 EST
Article-I.D.: tekred.1894
Posted: Wed Dec  2 11:59:45 1987
Date-Received: Sun, 6-Dec-87 04:35:43 EST
Sender: billr@tekred.TEK.COM
Lines: 2142
Approved: billr@tekred.TEK.COM

Submitted by: mike@genat.UUCP (Mike Stephenson)
Comp.sources.games: Volume 3, Issue 8
Archive-name: nethack2.2/Part08



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 8 (of 20)."
# Contents:  apply.c edog.h fight.c read.c
# Wrapped by billr@tekred on Tue Dec  1 16:24:56 1987
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f apply.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"apply.c\"
else
echo shar: Extracting \"apply.c\" \(17145 characters\)
sed "s/^X//" >apply.c <<'END_OF_apply.c'
X/*	SCCS Id: @(#)apply.c	2.1	87/09/23
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X
X#include	"hack.h"
X#include	"edog.h"
X#include	"mkroom.h"
Xstatic struct monst *bchit();
Xextern struct obj *addinv();
Xextern struct trap *maketrap();
Xextern int (*occupation)();
Xextern char *occtxt;
Xextern char quitchars[];
Xextern char pl_character[];
X
X#ifdef KAA
Xextern boolean unweapon;
X#endif
Xstatic use_camera(), use_ice_box(), use_whistle();
Xstatic use_magic_whistle(), use_pick_axe();
X#ifdef MARKER
Xextern int dowrite();
X#endif
X#ifdef RPH
Xstatic use_mirror();
X#endif
X
Xdoapply() {
X	register struct obj *obj;
X	register int res = 1;
X
X	obj = getobj("(", "use or apply");
X	if(!obj) return(0);
X
X	switch(obj->otyp){
X	case EXPENSIVE_CAMERA:
X		use_camera(obj); break;
X	case ICE_BOX:
X		use_ice_box(obj); break;
X	case PICK_AXE:
X		res = use_pick_axe(obj);
X		break;
X
X	case MAGIC_WHISTLE:
X		if(pl_character[0] == 'W' || u.ulevel > 9) {
X			use_magic_whistle(obj);
X			break;
X		}
X		/* fall into next case */
X	case WHISTLE:
X		use_whistle(obj);
X		break;
X#ifdef RPH
X	case MIRROR:
X		use_mirror(obj);
X		break;
X#endif
X#ifdef WALKIES
X	case LEASH:
X		use_leash(obj);
X		break;
X#endif
X#ifdef MARKER
X	case MAGIC_MARKER:
X		dowrite(obj);
X		break;
X#endif
X	case CAN_OPENER:
X		if(!carrying(TIN)) {
X			pline("You have no can to open.");
X			goto xit;
X		}
X		pline("You cannot open a tin without eating its contents.");
X		pline("In order to eat, use the 'e' command.");
X		if(obj != uwep)
X    pline("Opening the tin will be much easier if you wield the can-opener.");
X		goto xit;
X
X#ifdef KAA
X	case STETHOSCOPE:
X		res = use_stethoscope();
X		break;
X#endif
X	case BLINDFOLD:
X		if (Blindfolded) {
X		    Blindfolded = 0;
X		    if (!Blinded)	Blinded = 1;	/* see on next move */
X		    else		pline("You still cannot see.");
X		} else {
X		    Blindfolded = 1;
X		    seeoff(0);
X		}
X		break;
X	default:
X		pline("Sorry, I don't know how to use that.");
X	xit:
X		nomul(0);
X		return(0);
X	}
X	nomul(0);
X	return(res);
X}
X
X/* ARGSUSED */
Xstatic
Xuse_camera(obj) /* register */ struct obj *obj; {
Xregister struct monst *mtmp;
X	if(!getdir(1)){		/* ask: in what direction? */
X		flags.move = multi = 0;
X		return;
X	}
X	if(u.uswallow) {
X		pline("You take a picture of %s's stomach.", monnam(u.ustuck));
X		return;
X	}
X	if(u.dz) {
X		pline("You take a picture of the %s.",
X			(u.dz > 0) ? "floor" : "ceiling");
X		return;
X	}
X#ifdef KAA
X	if(!u.dx && !u.dy && !u.dz) {
X		if(!Blind) {
X			pline("You are blinded by the flash!");
X			Blinded += rnd(25);
X			seeoff(0);
X		}
X		return;
X	}
X#endif
X	if(mtmp = bchit(u.dx, u.dy, COLNO, '!')) {
X		if(mtmp->msleep){
X			mtmp->msleep = 0;
X			pline("The flash awakens %s.", monnam(mtmp)); /* a3 */
X		} else
X		if(mtmp->data->mlet != 'y')
X		if(mtmp->mcansee || mtmp->mblinded){
X			register int tmp = dist(mtmp->mx,mtmp->my);
X			register int tmp2;
X			if(cansee(mtmp->mx,mtmp->my))
X			  pline("%s is blinded by the flash!", Monnam(mtmp));
X			setmangry(mtmp);
X			if(tmp < 9 && !mtmp->isshk && rn2(4)) {
X				mtmp->mflee = 1;
X				if(rn2(4)) mtmp->mfleetim = rnd(100);
X			}
X			if(tmp < 3) mtmp->mcansee  = mtmp->mblinded = 0;
X			else {
X				tmp2 = mtmp->mblinded;
X				tmp2 += rnd(1 + 50/tmp);
X				if(tmp2 > 127) tmp2 = 127;
X				mtmp->mblinded = tmp2;
X				mtmp->mcansee = 0;
X			}
X		}
X	}
X}
X
X#ifdef KAA
X/* Strictly speaking it makes no sense for usage of a stethoscope to
X   not take any time; however, unless it did, the stethoscope would be
X   almost useless. */
Xstatic use_stethoscope() {
Xregister struct monst *mtmp;
Xregister struct rm *lev;
Xregister int rx, ry;
X	if(!freehand()) {
X		pline("You have no free hand!");
X		return(1);
X	}
X	if (!getdir(1)) {
X		flags.move=multi=0;
X		return(0);
X	}
X	if(u.dz < 0 || (u.dz && Levitation)) {
X		pline("You can't reach the %s!", u.dz<0 ? "ceiling" : "floor");
X		return(1);
X	}
X	if(u.dz) {
X		pline("The floor seems healthy enough.");
X		return(0);
X	}
X	if (Confusion) confdir();
X	rx = u.ux + u.dx; ry = u.uy + u.dy;
X	if(u.uswallow) {
X		mstatusline(u.ustuck);
X		return(0);
X	}
X	if(mtmp=m_at(rx,ry)) {
X		mstatusline(mtmp);
X		return(0);
X	}
X	if (!isok(rx,ry)) {
X		pline("You hear the sounds at the end of the universe.");
X		return(0);
X	}
X	lev = &levl[rx][ry];
X	if(lev->typ == SDOOR) {
X		pline("You hear a hollow sound!  This must be a secret door!");
X		lev->typ = DOOR;
X		atl(rx, ry, DOOR_SYM);
X		return(0);
X	}
X	if(lev->typ == SCORR) {
X		pline("You hear a hollow sound!  This must be a secret passage!");
X		lev->typ = CORR;
X		atl(rx, ry, CORR_SYM);
X		return(0);
X	}
X	pline("You hear nothing special.");
X	return(0);
X}
X#endif	
X	
Xstatic
Xstruct obj *current_ice_box;	/* a local variable of use_ice_box, to be
X				used by its local procedures in/ck_ice_box */
Xstatic
Xin_ice_box(obj) register struct obj *obj; {
X	if(obj == current_ice_box ||
X		(Punished && (obj == uball || obj == uchain))){
X		pline("You must be kidding.");
X		return(0);
X	}
X	if(obj->owornmask & (W_ARMOR | W_RING)) {
X		pline("You cannot refrigerate something you are wearing.");
X		return(0);
X	}
X	if(obj->owt + current_ice_box->owt > 70) {
X		pline("It won't fit.");
X		return(1);	/* be careful! */
X	}
X	if(obj == uwep) {
X		if(uwep->cursed) {
X			pline("Your weapon is welded to your hand!");
X			return(0);
X		}
X		setuwep((struct obj *) 0);
X	}
X	current_ice_box->owt += obj->owt;
X	freeinv(obj);
X	obj->o_cnt_id = current_ice_box->o_id;
X	obj->nobj = fcobj;
X	fcobj = obj;
X	obj->age = moves - obj->age;	/* actual age */
X	return(1);
X}
X
Xstatic
Xck_ice_box(obj) register struct obj *obj; {
X	return(obj->o_cnt_id == current_ice_box->o_id);
X}
X
Xstatic
Xout_ice_box(obj) register struct obj *obj; {
Xregister struct obj *otmp;
X	if(obj == fcobj) fcobj = fcobj->nobj;
X	else {
X		for(otmp = fcobj; otmp->nobj != obj; otmp = otmp->nobj)
X			if(!otmp->nobj) panic("out_ice_box");
X		otmp->nobj = obj->nobj;
X	}
X	current_ice_box->owt -= obj->owt;
X	obj->age = moves - obj->age;	/* simulated point of time */
X	(void) addinv(obj);
X}
X
Xstatic
Xuse_ice_box(obj) register struct obj *obj; {
Xregister int cnt = 0;
Xregister struct obj *otmp;
X	current_ice_box = obj;	/* for use by in/out_ice_box */
X	for(otmp = fcobj; otmp; otmp = otmp->nobj)
X		if(otmp->o_cnt_id == obj->o_id)
X			cnt++;
X	if(!cnt) pline("Your ice-box is empty.");
X	else {
X	    pline("Do you want to take something out of the ice-box? [yn] ");
X	    if(readchar() == 'y')
X		if(askchain(fcobj, (char *) 0, 0, out_ice_box, ck_ice_box, 0))
X		    return;
X		pline("That was all. Do you wish to put something in? [yn] ");
X		if(readchar() != 'y') return;
X	}
X	/* call getobj: 0: allow cnt; #: allow all types; %: expect food */
X	otmp = getobj("0#%", "put in");
X	if(!otmp || !in_ice_box(otmp))
X		flags.move = multi = 0;
X}
X
Xstatic
Xstruct monst *
Xbchit(ddx,ddy,range,sym) register int ddx,ddy,range; char sym; {
X	register struct monst *mtmp = (struct monst *) 0;
X	register int bchx = u.ux, bchy = u.uy;
X
X	if(sym) Tmp_at(-1, sym);	/* open call */
X	while(range--) {
X		bchx += ddx;
X		bchy += ddy;
X		if(mtmp = m_at(bchx,bchy))
X			break;
X		if(!ZAP_POS(levl[bchx][bchy].typ)) {
X			bchx -= ddx;
X			bchy -= ddy;
X			break;
X		}
X		if(sym) Tmp_at(bchx, bchy);
X	}
X	if(sym) Tmp_at(-1, -1);
X	return(mtmp);
X}
X
X/* ARGSUSED */
Xstatic
Xuse_whistle(obj) struct obj *obj; {
Xregister struct monst *mtmp = fmon;
X	pline("You produce a high whistling sound.");
X	while(mtmp) {
X		if(dist(mtmp->mx,mtmp->my) < u.ulevel*20) {
X			if(mtmp->msleep)
X				mtmp->msleep = 0;
X			if(mtmp->mtame)
X				EDOG(mtmp)->whistletime = moves;
X		}
X		mtmp = mtmp->nmon;
X	}
X}
X
X/* ARGSUSED */
Xstatic
Xuse_magic_whistle(obj) struct obj *obj; {
Xregister struct monst *mtmp = fmon;
X	pline("You produce a strange whistling sound.");
X	while(mtmp) {
X		if(mtmp->mtame) mnexto(mtmp);
X		mtmp = mtmp->nmon;
X	}
X}
X
X#ifdef WALKIES
X/* ARGSUSED */
Xstatic
Xuse_leash(obj) struct obj *obj; {
Xregister struct monst *mtmp = fmon;
X
X	while(mtmp && !mtmp->mleashed) mtmp = mtmp->nmon;
X
X	if(mtmp) {
X
X		if (next_to(mtmp))  {
X
X			mtmp->mleashed = 0;
X			pline("You remove the leash from your %s.",
X#ifdef RPH
X		/* a hack to include the dogs full name.  +4 elminates */
X		/* the 'the' at the start of the name */
X				 lmonnam(mtmp) + 4);
X#else
X				 mtmp->data->mname);
X#endif
X		} else	pline("You must be next to your %s to unleash him.",
X#ifdef RPH
X				lmonnam(mtmp)+4);
X#else
X				 mtmp->data->mname);
X#endif
X	} else {
X
X	    for(mtmp = fmon; mtmp; mtmp = mtmp->nmon) {
X
X		if(mtmp->mtame && next_to(mtmp)) {
X
X			pline("You slip the leash around your %s.", mtmp->data->mname);
X			mtmp->mleashed = 1;
X			if(mtmp->msleep)  mtmp->msleep = 0;
X			return(0);
X		}
X	    }
X	    pline("There's nothing here to put a leash on.");
X	}
X	return(0);
X}
X
Xnext_to(mtmp) register struct monst *mtmp; {
X
X	return((abs(u.ux - mtmp->mx) <= 1) && (abs(u.uy - mtmp->my) <= 1));
X}
X#endif
X
Xstatic int dig_effort;	/* effort expended on current pos */
Xstatic uchar dig_level;
Xstatic coord dig_pos;
Xstatic boolean dig_down;
X
Xstatic
Xdig() {
X	register struct rm *lev;
X	register dpx = dig_pos.x, dpy = dig_pos.y;
X
X	/* perhaps a nymph stole his pick-axe while he was busy digging */
X	/* or perhaps he teleported away */
X	if(u.uswallow || !uwep || uwep->otyp != PICK_AXE ||
X	    dig_level != dlevel ||
X	    ((dig_down && (dpx != u.ux || dpy != u.uy)) ||
X	     (!dig_down && dist(dpx,dpy) > 2)))
X		return(0);
X
X	dig_effort += 10 + abon() + uwep->spe + rn2(5);
X	if(dig_down) {
X		if(!xdnstair) {
X			pline("The floor here seems too hard to dig in.");
X			return(0);
X		}
X		if(dig_effort > 250) {
X			dighole();
X			return(0);	/* done with digging */
X		}
X		if(dig_effort > 50) {
X			register struct trap *ttmp = t_at(dpx,dpy);
X
X			if(!ttmp) {
X				ttmp = maketrap(dpx,dpy,PIT);
X				ttmp->tseen = 1;
X				pline("You have dug a pit.");
X				u.utrap = rn1(4,2);
X				u.utraptype = TT_PIT;
X				return(0);
X			}
X		}
X	} else
X	if(dig_effort > 100) {
X		register char *digtxt;
X		register struct obj *obj;
X
X		lev = &levl[dpx][dpy];
X		if(obj = sobj_at(ENORMOUS_ROCK, dpx, dpy)) {
X			fracture_rock(obj);
X			digtxt = "The rock falls apart.";
X		} else if(!lev->typ || lev->typ == SCORR) {
X			lev->typ = CORR;
X			digtxt = "You succeeded in cutting away some rock.";
X		} else if(lev->typ == HWALL || lev->typ == VWALL
X					    || lev->typ == SDOOR) {
X			lev->typ = xdnstair ? DOOR : ROOM;
X			digtxt = "You just made an opening in the wall.";
X		} else
X		  digtxt = "Now what exactly was it that you were digging in?";
X		mnewsym(dpx, dpy);
X		prl(dpx, dpy);
X		pline(digtxt);		/* after mnewsym & prl */
X		return(0);
X	} else {
X		if(IS_WALL(levl[dpx][dpy].typ)) {
X			register int rno = inroom(dpx,dpy);
X
X			if(rno >= 0 && rooms[rno].rtype >= SHOPBASE) {
X			  pline("This wall seems too hard to dig into.");
X			  return(0);
X			}
X		}
X		pline("You hit the rock with all your might.");
X	}
X	return(1);
X}
X
X/* When will hole be finished? Very rough indication used by shopkeeper. */
Xholetime() {
X	return( (occupation == dig) ? (250 - dig_effort)/20 : -1);
X}
X
Xdighole()
X{
X	register struct trap *ttmp = t_at(u.ux, u.uy);
X
X	if(!xdnstair) {
X		pline("The floor here seems too hard to dig in.");
X	} else {
X		if(ttmp)
X			ttmp->ttyp = TRAPDOOR;
X		else
X			ttmp = maketrap(u.ux, u.uy, TRAPDOOR);
X		ttmp->tseen = 1;
X		pline("You've made a hole in the floor.");
X		if(!u.ustuck && !Levitation) {			/* KAA */
X			if(inshop())
X				shopdig(1);
X			pline("You fall through ...");
X			if(u.utraptype == TT_PIT) {
X				u.utrap = 0;
X				u.utraptype = 0;
X			}
X			goto_level(dlevel+1, FALSE);
X		}
X	}
X}
X
Xstatic
Xuse_pick_axe(obj)
Xstruct obj *obj;
X{
X	char dirsyms[12];
X	extern char sdir[];
X	register char *dsp = dirsyms, *sdp = sdir;
X	register struct monst *mtmp;
X	register struct rm *lev;
X	register int rx, ry, res = 0;
X
X#ifndef FREEHAND
X	/* edited by GAN 10/20/86 so that you can't apply the
X	 * pick-axe while wielding a cursed weapon
X	 */
X	if(!freehand())  {
X		pline("You have no free hand to dig with!");
X		return(0);
X	}
X# ifdef KAA
X	if(cantwield(u.usym)) {
X		pline("You can't hold it strongly enough.");
X		return(0);
X	}
X# endif
X#else
X	if(obj != uwep) {
X		if(uwep && uwep->cursed) {
X			/* Andreas Bormann - ihnp4!decvax!mcvax!unido!ab */
X			pline("Since your weapon is welded to your hand,");
X			pline("you cannot use that pick-axe.");
X			return(0);
X		}
X# ifdef KAA
X		if(cantwield(u.usym)) {
X			pline("You can't hold it strongly enough.");
X			return(0);
X		}
X		unweapon = TRUE;
X# endif
X		pline("You now wield %s.", doname(obj));
X		setuwep(obj);
X		res = 1;
X	}
X#endif
X	while(*sdp) {
X		(void) movecmd(*sdp);	/* sets u.dx and u.dy and u.dz */
X		rx = u.ux + u.dx;
X		ry = u.uy + u.dy;
X		if(u.dz > 0 || (u.dz == 0 && isok(rx, ry) &&
X		    (IS_ROCK(levl[rx][ry].typ)
X		    || sobj_at(ENORMOUS_ROCK, rx, ry))))
X			*dsp++ = *sdp;
X		sdp++;
X	}
X	*dsp = 0;
X	pline("In what direction do you want to dig? [%s] ", dirsyms);
X	if(!getdir(0))		/* no txt */
X		return(res);
X	if(u.uswallow && attack(u.ustuck)) /* return(1) */;
X	else
X	if(u.dz < 0)
X		pline("You cannot reach the ceiling.");
X	else
X#ifdef KAA
X	if(!u.dx && !u.dy && !u.dz) {
X		pline("You hit yourself with your own pick-axe.");
X		losehp(rnd(2)+dbon(), "self-inflicted wound");
X		flags.botl=1;
X		return(1);
X	}
X#endif
X	if(u.dz == 0) {
X		if(Confusion)
X			confdir();
X		rx = u.ux + u.dx;
X		ry = u.uy + u.dy;
X		if((mtmp = m_at(rx, ry)) && attack(mtmp))
X			return(1);
X		if(!isok(rx, ry)) {
X			pline("Clash!");
X			return(1);
X		}
X		lev = &levl[rx][ry];
X		if(lev->typ == DOOR)
X			pline("Your %s against the door.",
X				aobjnam(obj, "clang"));
X		else if(!IS_ROCK(lev->typ)
X		     && !sobj_at(ENORMOUS_ROCK, rx, ry)) {
X			/* ACCESSIBLE or POOL */
X			pline("You swing your %s through thin air.",
X				aobjnam(obj, (char *) 0));
X		} else {
X			if(dig_pos.x != rx || dig_pos.y != ry
X			    || dig_level != dlevel || dig_down) {
X				dig_down = FALSE;
X				dig_pos.x = rx;
X				dig_pos.y = ry;
X				dig_level = dlevel;
X				dig_effort = 0;
X				pline("You start digging.");
X			} else
X				pline("You continue digging.");
X#ifdef DGKMOD
X			set_occupation(dig, "digging", 0);
X#else
X			occupation = dig;
X			occtxt = "digging";
X#endif
X		}
X	} else if(Levitation) {
X		pline("You cannot reach the floor.");
X	} else {
X		if(dig_pos.x != u.ux || dig_pos.y != u.uy
X		    || dig_level != dlevel || !dig_down) {
X			dig_down = TRUE;
X			dig_pos.x = u.ux;
X			dig_pos.y = u.uy;
X			dig_level = dlevel;
X			dig_effort = 0;
X			pline("You start digging in the floor.");
X			if(inshop())
X				shopdig(0);
X		} else
X			pline("You continue digging in the floor.");
X#ifdef DGKMOD
X		set_occupation(dig, "digging", 0);
X#else
X		occupation = dig;
X		occtxt = "digging";
X#endif
X	}
X	return(1);
X}
X
X#ifdef RPH
Xstatic
Xuse_mirror(obj)
Xstruct obj *obj;
X{
X     register struct monst *mtmp;
X     register char mlet;
X     extern mpickobj(), freeinv(), rloc();
X
X	if(!getdir(1)){		/* ask: in what direction? */
X		flags.move = multi = 0;
X		return;
X	}
X	if(u.uswallow) {
X		pline("You reflect %s's stomach.", monnam(u.ustuck));
X		return;
X	}
X	if(u.dz) {
X		pline("You reflect the %s.",
X			(u.dz > 0) ? "floor" : "ceiling");
X		return;
X	}
X	if(!u.dx && !u.dy && !u.dz) {
X		if(!Blind) 
X		    pline ("You look as ugly as ever.");
X		else {
X		    if (rn2(4-u.uluck/3) || !HTelepat) 
X		        pline ("You can't see your ugly face.");
X		    else {
X			char *tm, *tl; int ll;
X			if (rn2(4)) {
X			    tm = "ugly monster";
X			    ll = dlevel - u.medusa_level;
X			}
X			else {
X			    tm = "intelligent being";
X			    ll = dlevel - u.wiz_level;
X			}
X			if (ll < -10) tl = "far below you";
X			else if (ll < -1) tl = "below you";
X			else if (ll == -1) tl = "under your feet";
X			else if (ll == 0)  tl = "very close to you";
X			else if (ll == 1) tl = "above your head";
X			else if (ll > 10) tl = "far above you";
X			else tl = "above you";
X			pline ("You get an impression that an %s lives %s.",
X				tm, tl);
X		    }
X		}
X		return;
X	}
X	if(mtmp = bchit(u.dx, u.dy, COLNO, 0)) {
X	    mlet = mtmp->data->mlet;
X	    if(mtmp->msleep){
X	        pline ("%s is tired and doesn't look at your mirror.",
X	        	    Monnam(mtmp));
X	        mtmp->msleep = 0;
X	    } else
X	    if (!mtmp->mcansee) {
X	        pline("%s can't see anything at the moment.",
X	        	Monnam(mtmp));
X	    }
X	    /* some monsters do special things */
X	    else if (!mtmp->mcan && index("EUN8",mlet))
X	     switch (mlet) {
X	      case '8':
X	      	    pline("%s is turned to stone!", Monnam(mtmp));
X		    killed(mtmp);
X		    break;
X	      case 'E':
X	            pline("%s is frozen by its reflection.",Monnam(mtmp));
X	            mtmp->mfroz = 1;
X	    	    break;
X	      case 'U':
X	    	    pline ("%s has confused itself!", Monnam(mtmp));
X	    	    mtmp->mconf = 1;
X		    break;
X	      case 'N':
X	    	    pline ("%s looks beautiful in your mirror.",Monnam(mtmp));
X	    	    pline ("She decides to take it!");
X	    	    freeinv(obj);
X	    	    mpickobj(mtmp,obj);
X	    	    rloc(mtmp);
X	    	    break;
X	      default:
X	      	    break;
X	     }
X	    else if (mlet == 'V' || mlet == '&') 
X	        pline ("%s doesn't seem to reflect anything.", Monnam(mtmp));
X	    else if (!index("agquv1N", mlet) && rn2(5)) {
X	        pline ("%s is frightened by its reflection.",
X	        	    Monnam(mtmp));
X	        mtmp->mflee = 1;
X	        mtmp->mfleetim += d(2,4);
X	    }
X	    else
X	        pline ("%s doesn't seem to mind %s refection.",
X	    	    Monnam(mtmp),
X	    	    (mlet=='1'?"his":(mlet=='N'?"her":"its")));
X	}/* if monster hit with mirror */
X}/* use_mirror */
X
X#endif
END_OF_apply.c
if test 17145 -ne `wc -c <apply.c`; then
    echo shar: \"apply.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f edog.h -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"edog.h\"
else
echo shar: Extracting \"edog.h\" \(670 characters\)
sed "s/^X//" >edog.h <<'END_OF_edog.h'
X/*	SCCS Id: @(#)edog.h	1.4	87/08/08
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* edog.h - version 1.0.2 */
X
X/*	various types of food, the lower, the better liked.	*/
X
X#define	DOGFOOD	0
X#define	CADAVER	1
X#define	ACCFOOD	2
X#define	MANFOOD	3
X#define	APPORT	4
X#define	POISON	5
X#define	UNDEF	6
X
Xstruct edog {
X	long hungrytime;	/* at this time dog gets hungry */
X	long eattime;		/* dog is eating */
X	long droptime;		/* moment dog dropped object */
X	unsigned dropdist;		/* dist of drpped obj from @ */
X	unsigned apport;		/* amount of training */
X	long whistletime;		/* last time he whistled */
X};
X#define	EDOG(mp)	((struct edog *)(&(mp->mextra[0])))
END_OF_edog.h
if test 670 -ne `wc -c <edog.h`; then
    echo shar: \"edog.h\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f fight.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"fight.c\"
else
echo shar: Extracting \"fight.c\" \(16202 characters\)
sed "s/^X//" >fight.c <<'END_OF_fight.c'
X/*	SCCS Id: @(#)fight.c	2.1	87/10/17
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X
X#include	<stdio.h>
X#include	"hack.h"
X
Xextern struct permonst li_dog, dog, la_dog;
Xextern char *exclam(), *hcolor(), *xname();
Xextern struct obj *mkobj_at();
X#ifdef KAA
Xextern boolean stoned;
Xextern boolean unweapon;
Xextern char *nomovemsg, *defmonnam();
Xextern struct monst *mkmon_at();
X#endif
X#ifdef RPH
Xextern struct obj *mk_named_obj();
X#endif
X
Xstatic boolean far_noise;
Xstatic long noisetime;
X
X/* hitmm returns 0 (miss), 1 (hit), or 2 (kill) */
Xhitmm(magr,mdef) register struct monst *magr,*mdef; {
Xregister struct permonst *pa = magr->data, *pd = mdef->data;
Xint hit;
Xschar tmp;
Xboolean vis;
X	if(!magr || !mdef) return(0);		/* mike@genat */
X	if(index("Eauy", pa->mlet)) return(0);
X	if(magr->mfroz) return(0);		/* riv05!a3 */
X	tmp = pd->ac + pa->mlevel;
X	if(mdef->mconf || mdef->mfroz || mdef->msleep){
X		tmp += 4;
X		if(mdef->msleep) mdef->msleep = 0;
X	}
X	hit = (tmp > rnd(20));
X	if(hit) mdef->msleep = 0;
X	vis = (cansee(magr->mx,magr->my) && cansee(mdef->mx,mdef->my));
X	if(vis){
X		char buf[BUFSZ];
X		if(mdef->mimic) seemimic(mdef);
X		if(magr->mimic) seemimic(magr);
X		(void) sprintf(buf,"%s %s", Monnam(magr),
X			hit ? "hits" : "misses");
X		pline("%s %s.", buf, monnam(mdef));
X	} else {
X		boolean farq = (dist(magr->mx, magr->my) > 15);
X		if(farq != far_noise || moves-noisetime > 10) {
X			far_noise = farq;
X			noisetime = moves;
X			pline("You hear some noises%s.",
X				farq ? " in the distance" : "");
X		}
X	}
X	if(hit){
X		if(magr->data->mlet == 'c' && !magr->cham) {
X			magr->mhpmax += 3;
X			if(vis) pline("%s is turned to stone!", Monnam(mdef));
X			else if(mdef->mtame)
X     pline("You have a peculiarly sad feeling for a moment, then it passes.");
X			monstone(mdef);
X			hit = 2;
X		} else
X		if((mdef->mhp -= d(pa->damn,pa->damd)) < 1) {
X			magr->mhpmax += 1 + rn2(pd->mlevel+1);
X			if(magr->mtame && magr->mhpmax > 8*pa->mlevel){
X				if(pa == &li_dog) magr->data = pa = &dog;
X				else if(pa == &dog) magr->data = pa = &la_dog;
X			}
X			if(vis) pline("%s is killed!", Monnam(mdef));
X			else if(mdef->mtame)
X		pline("You have a sad feeling for a moment, then it passes.");
X			mondied(mdef);
X			hit = 2;
X		}
X		/* fixes a bug where max monster hp could overflow. */
X		if(magr->mhpmax <= 0) magr->mhpmax = 127;
X	}
X#ifdef KAA
X	if(hit == 1 && magr->data->mlet == 'Q') {
X		rloc(mdef);
X		if(vis && !cansee(mdef->mx,mdef->my))
X			pline("%s suddenly disappears!",Monnam(mdef));
X	}
X#endif
X	return(hit);
X}
X
X/* drop (perhaps) a cadaver and remove monster */
Xmondied(mdef) register struct monst *mdef; {
Xregister struct permonst *pd = mdef->data;
X#ifdef KOPS
X	if(pd->mlet != 'K')
X#endif
X	{
X#if defined(ROCKMOLE) && defined(KJSMODS)
X	    /* if a giant rat is killed by a monster, do not make a 
X	     * corpse (like Keystone Kops above). */
X	    if(!(pd->mlet == 'r' && dlevel < 4))
X#endif
X		if(letter(pd->mlet) && rn2(3)) {
X		    if (pd->mlet == '1') panic("mondied: making obj '1'");
X#ifndef RPH
X		    (void) mkobj_at(pd->mlet,mdef->mx,mdef->my);
X#else
X		    (void) mk_named_obj_at(pd->mlet,mdef->mx,mdef->my,
X					   NAME(mdef), mdef->mnamelth);
X#endif
X		    if(cansee(mdef->mx,mdef->my)){
X			unpmon(mdef);
X			atl(mdef->mx,mdef->my,fobj->olet);
X		    }
X		    stackobj(fobj);
X		}
X		mondead(mdef);
X	}
X}
X
X/* drop a rock and remove monster */
Xmonstone(mdef)
X	register struct monst *mdef;
X{
X	extern char mlarge[];
X	if(index(mlarge, mdef->data->mlet))
X		mksobj_at(ENORMOUS_ROCK, mdef->mx, mdef->my);
X	else
X		mksobj_at(ROCK, mdef->mx, mdef->my);
X	if(cansee(mdef->mx, mdef->my)){
X		unpmon(mdef);
X		atl(mdef->mx,mdef->my,fobj->olet);
X	}
X	mondead(mdef);
X}
X		
X
Xfightm(mtmp)
X	register struct monst *mtmp;
X{
Xregister struct monst *mon;
X
X	for(mon = fmon; mon; mon = mon->nmon)
X	    if(mon != mtmp) {
X		if(DIST(mon->mx,mon->my,mtmp->mx,mtmp->my) < 3)
X		    if(rn2(4))  return(hitmm(mtmp,mon));
X	    }
X	return(-1);
X}
X
X/* u is hit by sth, but not a monster */
Xthitu(tlev,dam,name)
X	register tlev,dam;
X	register char *name;
X{
X	char buf[BUFSZ];
X
X	setan(name,buf);
X	if(u.uac + tlev <= rnd(20)) {
X		if(Blind) pline("It misses.");
X		else pline("You are almost hit by %s!", buf);
X		return(0);
X	} else {
X		if(Blind) pline("You are hit!");
X		else pline("You are hit by %s!", buf);
X		losehp(dam,name);
X		return(1);
X	}
X}
X
X#ifdef KAA
Xchar mlarge[] = "bCDdegIlmnoPSsTUwY',&9";
X#else
Xchar mlarge[] = "bCDdegIlmnoPSsTUwY',&";
X#endif
X
Xboolean
Xhmon(mon,obj,thrown)	/* return TRUE if mon still alive */
Xregister struct monst *mon;
Xregister struct obj *obj;
Xregister thrown;
X{
X	register tmp;
X	boolean hittxt = FALSE;
X
X#ifdef KAA
X	stoned = FALSE;		/* this refers to the thing hit, not you */
X#endif
X	if(!obj){
X#ifdef KAA
X/* Note that c, y, and F can never wield weapons anyway */
X	  if (u.usym == 'c' && mon->data->mlet != 'c') {
X	       pline("You turn %s to stone!", monnam(mon));
X	       stoned = TRUE;
X	       xkilled(mon,0);
X	       return(FALSE);
X	  } else if (u.usym == 'y' && mon->data->mlet != 'y') {
X	       pline("%s is blinded by your flash of light!",Monnam(mon));
X	       if (!mon->mblinded) {
X		    mon->mblinded += rn2(25);
X		    mon->mcansee = 0;
X	       }
X	       rehumanize();
X	       return(TRUE);
X	  } else if (u.usym == 'F') {
X	       pline("You explode!");
X	       if (!index("gFY",mon->data->mlet)) {
X		    pline("%s gets blasted!", Monnam(mon));
X		    mon->mhp -= d(6,6);
X		    rehumanize();
X		    if (mon->mhp <= 0) {
X			 killed(mon);
X			 return(FALSE);
X		    } else return(TRUE);
X	       } else {
X		    pline("The blast doesn't seem to affect %s.", monnam(mon));
X		    rehumanize();
X		    return(TRUE);
X	       }
X	  } else if (index("P,'", u.usym) && u.uhunger < 1500
X		  && !u.uswallow && mon->data->mlet != 'c') {
X	       static char msgbuf[BUFSZ];
X	       pline("You swallow %s whole!", monnam(mon));
X	       u.uhunger += 20*mon->mhpmax;
X	       newuhs(FALSE);
X	       xkilled(mon,2);
X	       if (tmp = mon->mhpmax/5) {
X		    nomul(-tmp);
X		    (void)sprintf(msgbuf, "You finished digesting %s.",
X			 monnam(mon));
X		    nomovemsg = msgbuf;
X	       }
X	       return(FALSE);
X	  } else if (u.usym != '@') {
X	       if (u.usym == '&' && !rn2(5)) {
X		    struct monst *dtmp;
X		    pline("Some hell-p has arrived!");
X		    if((dtmp = mkmon_at('&',u.ux,u.uy)))
X			(void)tamedog(dtmp,(struct obj *)0);
X	       }
X	       tmp = d(mons[u.umonnum].damn, mons[u.umonnum].damd);
X	  } else
X#endif
X		tmp = rnd(2);	/* attack with bare hands */
X#ifdef KAA
X		if (mon->data->mlet == 'c' && !uarmg && u.usym != 'c'){
X#else
X		if(mon->data->mlet == 'c' && !uarmg){
X#endif
X			pline("You hit the cockatrice with your bare hands.");
X			pline("You turn to stone ...");
X			done_in_by(mon);
X		}
X	} else if(obj->olet == WEAPON_SYM || obj->otyp == PICK_AXE) {
X	    if(obj == uwep && (obj->otyp > SPEAR || obj->otyp < BOOMERANG))
X		tmp = rnd(2);
X	    else {
X		if(index(mlarge, mon->data->mlet)) {
X		    tmp = rnd(objects[obj->otyp].wldam);
X		    switch (obj->otyp) {
X			case SLING_BULLET:
X			case CROSSBOW_BOLT:
X			case MORNING_STAR:
X			case PARTISAN:
X			case BROAD_SWORD:	tmp += 1; break;
X
X			case FLAIL:
X			case RANSEUR:
X			case VOULGE:		tmp += rnd(4); break;
X
X			case HALBERD:
X			case SPETUM:		tmp += rnd(6); break;
X
X			case BARDICHE:
X			case TRIDENT:		tmp += d(2,4); break;
X
X			case TWO_HANDED_SWORD: 
X			case KATANA: 		tmp += d(2,6); break;
X		    }
X		} else {
X		    tmp = rnd(objects[obj->otyp].wsdam);
X		    switch (obj->otyp) {
X			case SLING_BULLET:
X			case CROSSBOW_BOLT:
X			case MACE:
X			case FLAIL:
X			case SPETUM:
X			case TRIDENT:		tmp += 1; break;
X
X			case BARDICHE:
X			case BILL_GUISARME:
X			case GUISARME:
X			case LUCERN_HAMMER:
X			case MORNING_STAR:
X			case RANSEUR:
X			case BROAD_SWORD:
X			case VOULGE:		tmp += rnd(4); break;
X		    }
X		}
X		tmp += obj->spe;
X#ifdef KAA
X		if(obj->olet == WEAPON_SYM && obj->dknown && index("VWZ &",
X				mon->data->mlet)) tmp += rn2(4);
X#endif
X		if(!thrown && obj == uwep && obj->otyp == BOOMERANG
X		 && !rn2(3)){
X		  pline("As you hit %s, the boomerang breaks into splinters.",
X				monnam(mon));
X			freeinv(obj);
X			setworn((struct obj *) 0, obj->owornmask);
X			obfree(obj, (struct obj *) 0);
X			tmp++;
X		}
X	    }
X#ifdef BVH
X	    if(!strcmp(ONAME(obj), "Excalibur")) tmp += rnd(10);
X	    else
X#endif
X		if(obj->otyp == KATANA
X		   && !strcmp(ONAME(obj), "Snickersnee")) tmp += rnd(5);
X
X	    else if(mon->data->mlet == 'O' && obj->otyp == TWO_HANDED_SWORD
X		    && !strcmp(ONAME(obj), "Orcrist"))	tmp += rnd(10);
X
X	} else	switch(obj->otyp) {
X		case HEAVY_IRON_BALL:
X			tmp = rnd(25); break;
X		case ENORMOUS_ROCK:
X			tmp = rnd(20); break;
X#ifdef RPH
X		case MIRROR:
X			pline("You break your mirror.  That's bad luck!");
X		        u.uluck -= 2;
X		        if ((int)u.uluck < LUCKMIN) u.uluck = LUCKMIN;
X			freeinv(obj);
X			if(obj->owornmask)
X				setworn((struct obj *) 0, obj->owornmask);
X			obfree(obj, (struct obj *) 0);
X			return(TRUE);
X#endif
X		case EXPENSIVE_CAMERA:
X	pline("You succeed in destroying your camera. Congratulations!");
X			freeinv(obj);
X			if(obj->owornmask)
X				setworn((struct obj *) 0, obj->owornmask);
X			obfree(obj, (struct obj *) 0);
X			return(TRUE);
X		case DEAD_COCKATRICE:	/* fixed by polder@cs.vu.nl */
X			pline("You hit %s with the cockatrice corpse.",
X				monnam(mon));
X			if(mon->data->mlet == 'c') {
X				tmp = 1;
X				hittxt = TRUE;
X				break;
X			}
X			pline ("%s is turned to stone!", Monnam(mon));
X#ifdef KAA
X			stoned = TRUE;
X			xkilled(mon,0);
X#else
X			killed(mon);
X#endif
X			return(FALSE);
X		case CLOVE_OF_GARLIC:		/* no effect against demons */
X			if(index(UNDEAD, mon->data->mlet))
X				mon->mflee = 1;
X			tmp = 1;
X			break;
X		default:
X			/* non-weapons can damage because of their weight */
X			/* (but not too much) */
X			tmp = obj->owt/10;
X			if(tmp < 1) tmp = 1;
X			else tmp = rnd(tmp);
X			if(tmp > 6) tmp = 6;
X		}
X
X	/****** NOTE: perhaps obj is undefined!! (if !thrown && BOOMERANG) */
X
X	tmp += u.udaminc + dbon();
X	if(u.uswallow) {
X		if((tmp -= u.uswldtim) <= 0) {
X			pline("Your arms are no longer able to hit.");
X			return(TRUE);
X		}
X	}
X	if(tmp < 1) tmp = 1;
X	mon->mhp -= tmp;
X	if(mon->mhp < 1) {
X		killed(mon);
X		return(FALSE);
X	}
X	if(mon->mtame && (!mon->mflee || mon->mfleetim)) {
X		mon->mflee = 1;			/* Rick Richardson */
X		mon->mfleetim += 10*rnd(tmp);
X	}
X
X	if(!hittxt) {
X		if(thrown)
X			/* this assumes that we cannot throw plural things */
X			hit( xname(obj)  /* or: objects[obj->otyp].oc_name */,
X				mon, exclam(tmp) );
X		else if(Blind)
X			pline("You hit it.");
X		else
X			pline("You hit %s%s", monnam(mon), exclam(tmp));
X	}
X
X	if(u.umconf && !thrown) {
X		if(!Blind) {
X			pline("Your hands stop glowing %s.",
X			Hallucination ? hcolor() : "blue");
X		}
X		if (!resist(mon, '+', 0, NOTELL)) mon->mconf = 1;
X		if(!mon->mfroz && !mon->msleep && !Blind && mon->mconf)
X			pline("%s appears confused.",Monnam(mon));
X		u.umconf = 0;
X	}
X	if(!thrown && rn2(2) && index("VW",u.usym) &&
X	   !index("VW",mon->data->mlet)){
X		int tmp=d(2,6);
X		pline("%s suddenly seems weaker!",Monnam(mon));
X		mon->mhpmax -= tmp;
X		if ((mon->mhp -= tmp) <= 0) {
X			pline("%s dies!",Monnam(mon));
X			xkilled(mon,0);
X			return(FALSE);
X		}
X	}
X	return(TRUE);	/* mon still alive */
X}
X
X/* try to attack; return FALSE if monster evaded */
X/* u.dx and u.dy must be set */
Xattack(mtmp)
Xregister struct monst *mtmp;
X{
X	schar tmp;
X	boolean malive = TRUE;
X	register struct permonst *mdat;
X	mdat = mtmp->data;
X
X#ifdef KAA
X	if(unweapon) {
X		unweapon=FALSE;
X		if(uwep)
X			pline("You begin bashing monsters with your %s.",
X				aobjnam(uwep,(char *)0));
X	}
X#endif
X	u_wipe_engr(3);   /* andrew@orca: prevent unlimited pick-axe attacks */
X
X	if(mdat->mlet == 'L' && !mtmp->mfroz && !mtmp->msleep &&
X	   !mtmp->mconf && mtmp->mcansee && !rn2(7) &&
X	   (m_move(mtmp, 0) == 2 /* he died */ || /* he moved: */
X		mtmp->mx != u.ux+u.dx || mtmp->my != u.uy+u.dy))
X		return(FALSE);
X#ifdef SAFE_ATTACK
X	/* This section of code provides protection against accidentally
X	 * hitting peaceful (like '@') and tame (like 'd') monsters.
X	 * There is protection only if you're not blind, confused or
X	 * invisible.
X	 */
X	/*  changes by wwp 5/16/85 */
X	if (!Blind && !Confusion && !Hallucination
X	    && mdat->mlet == 'd' && mtmp->mtame) {
X		char *dname;		/* added by Janet Walz (walz@mimsy) */
X		mtmp->mflee = 1;
X		mtmp->mfleetim = rnd(6);
X		if (dname = NAME(mtmp))
X		    pline("You stop to avoid hitting %s.",dname);
X		else
X		    pline("You stop to avoid hitting your dog.");
X		return(TRUE);
X	}
X	if (flags.confirm && (mtmp->mpeaceful || mtmp->mtame) && ! Confusion
X	    && !Hallucination && !Invisible)
X
X		if (Blind ? Telepat : (!mtmp->minvis || See_invisible)) {
X			pline("Really attack %s?", monnam(mtmp));
X			(void) fflush(stdout);
X			if (readchar() != 'y') {
X				flags.move = 0;
X				return(TRUE);
X			}
X		}
X#endif /* SAFE_ATTACK /**/
X
X	if(mtmp->mimic){
X		if(!u.ustuck && !mtmp->mflee) u.ustuck = mtmp;
X		if (levl[u.ux+u.dx][u.uy+u.dy].scrsym == DOOR_SYM)
X		{
X		    if (okdoor(u.ux+u.dx, u.uy+u.dy))
X			pline("The door actually was %s.", defmonnam(mtmp));
X		    else
X			pline("That spellbook was %s.", defmonnam(mtmp));
X		}
X		else if (levl[u.ux+u.dx][u.uy+u.dy].scrsym == GOLD_SYM)
X			pline("The chest was %s!", defmonnam(mtmp));
X		else
X			pline("Wait! That's %s!",defmonnam(mtmp));
X		wakeup(mtmp);	/* clears mtmp->mimic */
X		return(TRUE);
X	}
X
X	wakeup(mtmp);
X
X	if(mtmp->mhide && mtmp->mundetected){
X		register struct obj *obj;
X
X		mtmp->mundetected = 0;
X		if((obj = o_at(mtmp->mx,mtmp->my)) && !Blind)
X			pline("Wait! There's %s hiding under %s!",
X				defmonnam(mtmp), doname(obj));
X		return(TRUE);
X	}
X#ifdef KAA
X	tmp = u.uluck + (u.mtimedone ? mons[u.umonnum].mlevel : u.ulevel) +
X			mdat->ac + abon();
X	if (u.usym=='y' || u.usym=='F') tmp=100;
X	if (index("uEa",u.usym)) return(TRUE);
X#else
X	tmp = u.uluck + u.ulevel + mdat->ac + abon();
X#endif
X	if(uwep) {
X#ifdef KAA	/* Blessed weapons used against undead or demons */
X		if(uwep->olet == WEAPON_SYM && uwep->dknown && index("VWZ &",
X			mtmp->data->mlet)) tmp += 2;
X#endif
X		if(uwep->olet == WEAPON_SYM || uwep->otyp == PICK_AXE)
X			tmp += uwep->spe;
X#ifdef  BVH
X		if(!strcmp(ONAME(uwep),"Excalibur")) tmp += 5;
X#endif
X		if(uwep->otyp == TWO_HANDED_SWORD) tmp -= 1;
X		else if(uwep->otyp == KATANA) tmp += 1;
X		else if(uwep->otyp == DAGGER ||
X			uwep->otyp == SHURIKEN) tmp += 2;
X		else if(uwep->otyp == CRYSKNIFE) tmp += 3;
X		else if(uwep->otyp == SPEAR &&
X			index("XDne", mdat->mlet)) tmp += 2;
X	}
X	if(mtmp->msleep) {
X		mtmp->msleep = 0;
X		tmp += 2;
X	}
X	if(mtmp->mfroz) {
X		tmp += 4;
X		if(!rn2(10)) mtmp->mfroz = 0;
X	}
X	if(mtmp->mflee) tmp += 2;
X	if(u.utrap) tmp -= 3;
X
X	/* with a lot of luggage, your agility diminishes */
X	tmp -= (inv_weight() + 40)/20;
X
X	if(tmp <= rnd(20) && !u.uswallow){
X		if(Blind) pline("You miss it.");
X		else pline("You miss %s.",monnam(mtmp));
X	} else {
X		/* we hit the monster; be careful: it might die! */
X
X		if((malive = hmon(mtmp,uwep,0)) == TRUE) {
X		/* monster still alive */
X			if(!rn2(25) && mtmp->mhp < mtmp->mhpmax/2) {
X				mtmp->mflee = 1;
X				if(!rn2(3)) mtmp->mfleetim = rnd(100);
X				if(u.ustuck == mtmp && !u.uswallow)
X					u.ustuck = 0;
X			}
X#ifndef NOWORM
X			if(mtmp->wormno)
X				cutworm(mtmp, u.ux+u.dx, u.uy+u.dy,
X					uwep ? uwep->otyp : 0);
X#endif
X		}
X		if(mdat->mlet == 'a') {
X			if(rn2(2)) {
X				if (Blind) pline("You are splashed!");
X				else	   pline("You are splashed by %s's acid!",monnam(mtmp));
X				if (u.usym != 'a') {
X					losehp_m(rnd(6), mtmp);
X					if(!rn2(30)) corrode_armor();
X				}
X			}
X			if(!rn2(6)) corrode_weapon();
X		}
X	}
X#ifdef KAA
X	if (malive) if (u.usym=='N' && mtmp->minvent) {
X		struct obj *otmp, *addinv();
X		otmp = mtmp->minvent;
X		mtmp->minvent = otmp->nobj;
X		otmp = addinv(otmp);
X		pline("You steal:");
X		prinv(otmp);
X	} else if (u.usym=='L' && mtmp->mgold) {
X		u.ugold += mtmp->mgold;
X		mtmp->mgold = 0;
X		pline("Your purse feels heavier.");
X	} else if (u.usym=='Q') rloc(mtmp);
X#endif
X	if(malive && mdat->mlet == 'E' && canseemon(mtmp)
X	   && !mtmp->mcan && rn2(3)) {
X	    if(mtmp->mcansee) {
X	      pline("You are frozen by %s's gaze!",monnam(mtmp));
X	      nomul((u.ulevel > 6 || rn2(4)) ? rn1(20,-21) : -200);
X	    } else {
X	      pline("%s cannot defend itself.", Amonnam(mtmp,"blinded"));
X	      if(!rn2(500)) if((int)u.uluck > LUCKMIN) u.uluck--;
X	    }
X	}
X	return(TRUE);
X}
END_OF_fight.c
if test 16202 -ne `wc -c <fight.c`; then
    echo shar: \"fight.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f read.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"read.c\"
else
echo shar: Extracting \"read.c\" \(16984 characters\)
sed "s/^X//" >read.c <<'END_OF_read.c'
X/*	SCCS Id: @(#)read.c	2.2	87/11/29
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X
X#include "hack.h"
X
Xextern struct monst *makemon();
Xextern struct permonst pm_eel;
Xextern struct obj *mkobj_at();
Xchar *hcolor();
Xboolean	known; 
Xint identify();
X
Xdoread() {
X	register struct obj *scroll;
X	register boolean confused = (Confusion != 0);
X
X	known = FALSE;
X	scroll = getobj("#-?", "read");	/*  "#-" added by GAN 10/22/86 */
X	if(!scroll) return(0);
X	
X	/* below added to allow reading of fortune cookies */
X	if(scroll->otyp == FORTUNE_COOKIE) {
X		if(Blind) {
X			pline("This cookie has a scrap of paper inside!");
X			pline("What a pity, that you cannot read it!");
X		} else
X			outrumor();
X		useup(scroll);
X		return(1);
X	}  else
X		if(scroll->olet != SCROLL_SYM) {
X			pline("That is a silly thing to read.");
X			return(0);
X		}
X
X	if(!scroll->dknown && Blind) {
X	    pline("Being blind, you cannot read the formula on the scroll.");
X	    return(0);
X	}
X	if(Blind)
X	  pline("As you pronounce the formula on it, the scroll disappears.");
X	else
X	  pline("As you read the scroll, it disappears.");
X	if(confused) {
X	  if (Hallucination)
X	      pline("Being so trippy, you screw up ... ");
X	  else
X	      pline("Being confused, you mispronounce the magic words ... ");
X	}
X	if(!seffects(scroll))  {
X		if(!objects[scroll->otyp].oc_name_known) {
X		    if(known && !confused) {
X			objects[scroll->otyp].oc_name_known = 1;
X			more_experienced(0,10);
X		    } else if(!objects[scroll->otyp].oc_uname)
X			docall(scroll);
X		}
X#ifdef MARKER
X		if(!(scroll->otyp == SCR_BLANK_PAPER) || confused)
X#endif
X			useup(scroll);
X	}
X	return(1);
X}
X
Xseffects(sobj)
X	register struct obj	*sobj;
X{
X	extern struct obj *some_armor();
X	register boolean confused = (Confusion != 0);
X
X	switch(sobj->otyp) {
X#ifdef MAIL
X	case SCR_MAIL:
X		readmail(/* scroll */);
X		break;
X#endif
X	case SCR_ENCHANT_ARMOR:
X	    {
X		register struct obj *otmp = some_armor();
X		if(!otmp) {
X			strange_feeling(sobj,"Your skin glows then fades.");
X			return(1);
X		}
X		if(confused) {
X			pline("Your %s is covered by a shimmering %s %s!",
X				objects[otmp->otyp].oc_name, Hallucination ? hcolor() :
X				"gold", (otmp->otyp == SHIELD ? "layer" : "shield"));
X			otmp->rustfree = 1;
X			break;
X		}
X#ifdef KAA
X		if(otmp->spe > (otmp->otyp == ELFIN_CHAIN_MAIL ? 5 : 3)
X				&& rn2(otmp->spe)) {
X#else
X		if(otmp->spe > 3 && rn2(otmp->spe)) {
X#endif
X		pline("Your %s glows violently %s for a while, then evaporates.",
X			objects[otmp->otyp].oc_name,
X			Hallucination ? hcolor() : "green");
X			useup(otmp);
X			break;
X		}
X		pline("Your %s glows %s for a moment.",
X			objects[otmp->otyp].oc_name,
X			Hallucination ? hcolor() : "green");
X		otmp->cursed = 0;
X		otmp->spe++;
X		break;
X	    }
X	case SCR_DESTROY_ARMOR:
X		if(confused) {
X			register struct obj *otmp = some_armor();
X			if(!otmp) {
X				strange_feeling(sobj,"Your bones itch.");
X				return(1);
X			}
X			pline("Your %s glows %s for a moment.",
X				objects[otmp->otyp].oc_name,
X				Hallucination ? hcolor() : "purple");
X			otmp->rustfree = 0;
X			break;
X		}
X		if(!destroy_arm()) {
X			strange_feeling(sobj,"Your skin itches.");
X			return(1);
X		}
X		break;
X	case SCR_CONFUSE_MONSTER:
X#ifdef SPELLS
X	case SPE_CONFUSE_MONSTER:
X#endif
X		if(u.usym != '@') {
X			pline("You feel confused.");
X			HConfusion += rnd(100);
X		} else  if(confused) {
X			pline("Your hands begin to glow %s.",
X			Hallucination ? hcolor() : "purple");
X			HConfusion += rnd(100);
X		} else {
X			pline("Your hands begin to glow %s.",
X			Hallucination ? hcolor() : "blue");
X			u.umconf = 1;
X		}
X		break;
X	case SCR_SCARE_MONSTER:
X#ifdef SPELLS
X	case SPE_CAUSE_FEAR:
X#endif
X	    {	register int ct = 0;
X		register struct monst *mtmp;
X
X		for(mtmp = fmon; mtmp; mtmp = mtmp->nmon)
X		    if(cansee(mtmp->mx,mtmp->my)) {
X			if(confused)
X			    mtmp->mflee = mtmp->mfroz = mtmp->msleep = 0;
X			else
X			    if (! resist(mtmp, sobj->olet, 0, NOTELL))
X				mtmp->mflee = 1;
X			ct++;
X		    }
X		if(!ct)
X		    pline("You hear %s in the distance.",
X			  (confused) ? "sad wailing" : "maniacal laughter");
X#ifdef KAA
X# ifdef SPELLS
X		    else if(sobj->otyp == SCR_SCARE_MONSTER)
X# endif
X			pline ("You hear %s close by.",
X			       (confused) ? "sad wailing" : "maniacal laughter");
X#endif
X		break;
X	    }
X	case SCR_BLANK_PAPER:
X		if(confused)
X		    pline("You see strange patterns on this scroll.");
X		else  {
X		    pline("This scroll seems to be blank.");
X#ifdef MARKER
X		    pline("No, wait...");
X		    known = TRUE;
X#endif
X		}
X		break;
X	case SCR_REMOVE_CURSE:
X#ifdef SPELLS
X	case SPE_REMOVE_CURSE:
X#endif
X	    {	register struct obj *obj;
X		if(confused)
X		    if (Hallucination)
X			pline("You feel the power of the Force against you!");
X		    else
X			pline("You feel like you need some help.");
X		else
X		    if (Hallucination)
X			pline("You feel in touch with the Universal Oneness.");
X		    else
X			pline("You feel like someone is helping you.");
X		for(obj = invent; obj ; obj = obj->nobj)
X			if(obj->owornmask)
X				obj->cursed = confused;
X		if(Punished && !confused) {
X			Punished = 0;
X			freeobj(uchain);
X			unpobj(uchain);
X			free((char *) uchain);
X			uball->spe = 0;
X			uball->owornmask &= ~W_BALL;
X			uchain = uball = (struct obj *) 0;
X		}
X		break;
X	    }
X	case SCR_CREATE_MONSTER:
X#ifdef SPELLS
X	case SPE_CREATE_MONSTER:
X#endif
X	    {	register int cnt = 1;
X
X		if(!rn2(73)) cnt += rnd(4);
X		if(confused) cnt += 12;
X		while(cnt--)
X#ifdef WIZARD
X			if(wizard)  {
X				char buf[BUFSZ], cmlet;
X				struct permonst *crmonst;
X				
X				do {
X					pline("What monster to create? ");
X					getlin(buf);
X				} while(strlen(buf) != 1);
X				cmlet = buf[0];
X				for(crmonst = mons; crmonst->mlet != cmlet &&
X					crmonst != PM_EEL; crmonst++) ;
X				(void) makemon(crmonst, u.ux, u.uy);
X			} else
X#endif /* WIZARD /**/
X				(void) makemon(confused ? PM_ACID_BLOB :
X					(struct permonst *) 0, u.ux, u.uy);
X		break;
X	    }
X	case SCR_ENCHANT_WEAPON:
X		if(uwep && uwep->olet == WEAPON_SYM && confused) {
X		/* olet check added 10/25/86 GAN */
X			pline("Your %s covered by a shimmering %s shield!",
X				aobjnam(uwep, "are"),
X				Hallucination ? hcolor() : "gold");
X			uwep->rustfree = 1;
X		} else
X			if(!chwepon(sobj, 1))		/* tests for !uwep */
X				return(1);
X		break;
X	case SCR_DAMAGE_WEAPON:
X		if(uwep && uwep->olet == WEAPON_SYM && confused) {
X		/* olet check added 10/25/86 GAN */
X			pline("Your %s %s for a moment.",
X				aobjnam(uwep,"glow"),
X				Hallucination ? hcolor() : "purple");
X			uwep->rustfree = 0;
X		} else
X			if(!chwepon(sobj, -1))	/* tests for !uwep */
X				return(1);
X		break;
X	case SCR_TAMING:
X#ifdef SPELLS
X	case SPE_CHARM_MONSTER:
X#endif
X	    {	register int i,j;
X		register int bd = confused ? 5 : 1;
X		register struct monst *mtmp;
X
X		for(i = -bd; i <= bd; i++) for(j = -bd; j <= bd; j++)
X		if(mtmp = m_at(u.ux+i, u.uy+j))
X		    if(!resist(mtmp, sobj->olet, 0, NOTELL))
X			(void) tamedog(mtmp, (struct obj *) 0);
X		break;
X	    }
X	case SCR_GENOCIDE:
X		pline("You have found a scroll of genocide!");
X#ifdef SPELLS
X	case SPE_GENOCIDE:
X#endif
X		known = TRUE;
X		do_genocide();
X		break;
X	case SCR_LIGHT:
X		if(!Blind) known = TRUE;
X		litroom(!confused);
X		break;
X	case SCR_TELEPORTATION:
X		if(confused)
X			level_tele();
X		else {
X#ifdef QUEST
X			register int oux = u.ux, ouy = u.uy;
X			tele();
X			if(dist(oux, ouy) > 100) known = TRUE;
X#else
X			register int uroom = inroom(u.ux, u.uy);
X			tele();
X			if(uroom != inroom(u.ux, u.uy)) known = TRUE;
X#endif
X			if(Teleport_control)
X				known = TRUE;
X		}
X		break;
X	case SCR_GOLD_DETECTION:
X	    /* Unfortunately this code has become slightly less elegant,
X	       now that gold and traps no longer are of the same type. */
X	    if(confused) {
X		register struct trap *ttmp;
X
X		if(!ftrap) {
X			strange_feeling(sobj, "Your toes stop itching.");
X			return(1);
X		} else {
X			for(ttmp = ftrap; ttmp; ttmp = ttmp->ntrap)
X				if(ttmp->tx != u.ux || ttmp->ty != u.uy)
X					goto outtrapmap;
X			/* only under me - no separate display required */
X			pline("Your toes itch!");
X			break;
X		outtrapmap:
X			cls();
X			for(ttmp = ftrap; ttmp; ttmp = ttmp->ntrap)
X				at(ttmp->tx, ttmp->ty, Hallucination ? rndobjsym() : GOLD_SYM);
X			prme();
X			pline("You feel very greedy!");
X		}
X	    } else {
X		register struct gold *gtmp;
X
X		if(!fgold) {
X			strange_feeling(sobj, "You feel materially poor.");
X			return(1);
X		} else {
X			known = TRUE;
X			for(gtmp = fgold; gtmp; gtmp = gtmp->ngold)
X				if(gtmp->gx != u.ux || gtmp->gy != u.uy)
X					goto outgoldmap;
X			/* only under me - no separate display required */
X			pline("You notice some gold between your feet.");
X			break;
X		outgoldmap:
X			cls();
X			for(gtmp = fgold; gtmp; gtmp = gtmp->ngold)
X				at(gtmp->gx, gtmp->gy, Hallucination ? rndobjsym() : GOLD_SYM);
X			prme();
X			pline("You feel very greedy, and sense gold!");
X		}
X	    }
X		/* common sequel */
X		more();
X		docrt();
X		break;
X	case SCR_FOOD_DETECTION:
X#ifdef SPELLS
X	case SPE_DETECT_FOOD:
X#endif
X	    {	register ct = 0, ctu = 0;
X		register struct obj *obj;
X		register char foodsym = confused ? POTION_SYM : FOOD_SYM;
X
X		for(obj = fobj; obj; obj = obj->nobj)
X			if(obj->olet == foodsym) {
X				if(obj->ox == u.ux && obj->oy == u.uy) ctu++;
X				else ct++;
X			}
X		if(!ct && !ctu) {
X			strange_feeling(sobj,"Your nose twitches.");
X			return(1);
X		} else if(!ct) {
X			known = TRUE;
X			pline("You smell %s close nearby.",
X				confused ? "something" : "food");
X			
X		} else {
X			known = TRUE;
X			cls();
X			for(obj = fobj; obj; obj = obj->nobj)
X			    if(obj->olet == foodsym)
X				at(obj->ox, obj->oy, Hallucination ? rndobjsym() :
X				 FOOD_SYM);
X			prme();
X			pline("Your nose tingles and you smell %s!",
X				confused ? "something" : "food");
X			more();
X			docrt();
X		}
X		break;
X	    }
X	case SCR_IDENTIFY:
X		/* known = TRUE; */
X		if(confused)
X			pline("You identify this as an identify scroll.");
X		else
X			pline("This is an identify scroll.");
X		useup(sobj);
X		objects[SCR_IDENTIFY].oc_name_known = 1;
X#ifdef SPELLS
X	case SPE_IDENTIFY:
X#endif
X		if(!confused)
X		    while(!ggetobj("identify", identify, rn2(5) ? 1 : rn2(5)) && invent);
X		return(1);
X	case SCR_MAGIC_MAPPING:
X		known = TRUE;
X		pline("On this scroll %s a map!", confused ? "was" : "is");
X#ifdef SPELLS
X	case SPE_MAGIC_MAPPING:
X#endif
X		do_mapping();
X		break;
X	case SCR_AMNESIA:
X	    {	register int zx, zy;
X
X		known = TRUE;
X		for(zx = 0; zx < COLNO; zx++) for(zy = 0; zy < ROWNO; zy++)
X		    if(!confused || rn2(7))
X			if(!cansee(zx,zy))
X			    levl[zx][zy].seen = 0;
X		docrt();
X		pline("Who was that Maude person anyway?");
X#ifdef SPELLS
X		losespells();
X#endif
X		break;
X	    }
X	case SCR_FIRE:
X	    {	register int num;
X		register struct monst *mtmp;
X
X/* 
X * Note: This case was modified 11/4/86 by DKC to eliminate the problem with
X * reading a scroll of fire while confused or resistant to fire.  Formerly,
X * the code failed to initialize the variable "num" in these cases, resulting
X * in monsters being hit for a possibly large (and possibly negative) damage.
X * The actions taken now are: 
X * 				If the player is fire resistant, monsters
X * take the normal damage (1-6 except for Y's and F's), and the player is
X * unaffected.
X */
X		known = TRUE;
X		if(confused) {
X		    if(Fire_resistance)
X			pline("Oh look, what a pretty fire in your hands.");
X		    else {
X			pline("The scroll catches fire and you burn your hands.");
X			losehp(1, "scroll of fire");
X		    }
X		    break;
X		}
X		pline("The scroll erupts in a tower of flame!");
X		num = rnd(6);
X		if(Fire_resistance)
X			pline("You are uninjured.");
X		else {
X			u.uhpmax -= num;
X			losehp(num, "scroll of fire");
X		}
X		num = (2*num + 1)/3;
X		for(mtmp = fmon; mtmp; mtmp = mtmp->nmon) {
X		    if(dist(mtmp->mx,mtmp->my) < 3) {
X			mtmp->mhp -= num;		/* No saving throw! */
X			if(index("FY", mtmp->data->mlet))
X			    mtmp->mhp -= 3*num;	/* this might well kill 'F's */
X			if(mtmp->mhp < 1) {
X			    killed(mtmp);
X			    break;		/* primitive */
X			}
X		    }
X		}
X		break;
X	    }
X	case SCR_PUNISHMENT:
X		known = TRUE;
X		if(confused) {
X			pline("You feel guilty.");
X			break;
X		}
X		pline("You are being punished for your misbehavior!");
X		if(Punished){
X			pline("Your iron ball gets heavier.");
X			uball->owt += 15;
X			break;
X		}
X		Punished = INTRINSIC;
X		setworn(mkobj_at(CHAIN_SYM, u.ux, u.uy), W_CHAIN);
X		setworn(mkobj_at(BALL_SYM, u.ux, u.uy), W_BALL);
X		uball->spe = 1;		/* special ball (see save) */
X		break;
X	default:
X		impossible("What weird effect is this? (%u)", sobj->otyp);
X	}
X	return(0);
X}
X
Xidentify(otmp)		/* also called by newmail() */
Xregister struct obj *otmp;
X{
X	objects[otmp->otyp].oc_name_known = 1;
X#ifdef KAA
X	otmp->known = 1;
X	if (otmp->olet != WEAPON_SYM) otmp->dknown = 1;
X/* Now, the dknown field is special for weapons, indicating blessing. */
X#else
X	otmp->known = otmp->dknown = 1;
X#endif
X	prinv(otmp);
X	return(1);
X}
X
Xlitroom(on)
Xregister boolean on;
X{
X	register num,zx,zy;
X
X	/* first produce the text (provided he is not blind) */
X	if(Blind) goto do_it;
X	if(!on) {
X		if(u.uswallow || !xdnstair || levl[u.ux][u.uy].typ == CORR ||
X		    !levl[u.ux][u.uy].lit) {
X			pline("It seems even darker in here than before.");
X			return;
X		} else
X			pline("It suddenly becomes dark in here.");
X	} else {
X		if(u.uswallow){
X			pline("%s's stomach is lit.", Monnam(u.ustuck));
X			return;
X		}
X		if(!xdnstair){
X			pline("Nothing Happens.");
X			return;
X		}
X#ifdef QUEST
X		pline("The cave lights up around you, then fades.");
X		return;
X#else
X		if(levl[u.ux][u.uy].typ == CORR) {
X		    pline("The corridor lights up around you, then fades.");
X		    return;
X		} else if(levl[u.ux][u.uy].lit) {
X		    pline("The light here seems better now.");
X		    return;
X		} else
X		    pline("The room is lit.");
X#endif
X	}
X
Xdo_it:
X#ifdef QUEST
X	return;
X#else
X	if(levl[u.ux][u.uy].lit == on)
X		return;
X	if(levl[u.ux][u.uy].typ == DOOR) {
X		if(IS_ROOM(levl[u.ux][u.uy+1].typ)) zy = u.uy+1;
X		else if(IS_ROOM(levl[u.ux][u.uy-1].typ)) zy = u.uy-1;
X		else zy = u.uy;
X		if(IS_ROOM(levl[u.ux+1][u.uy].typ)) zx = u.ux+1;
X		else if(IS_ROOM(levl[u.ux-1][u.uy].typ)) zx = u.ux-1;
X		else zx = u.ux;
X	} else {
X		zx = u.ux;
X		zy = u.uy;
X	}
X	for(seelx = u.ux; (num = levl[seelx-1][zy].typ) != CORR && num != 0;
X		seelx--);
X	for(seehx = u.ux; (num = levl[seehx+1][zy].typ) != CORR && num != 0;
X		seehx++);
X	for(seely = u.uy; (num = levl[zx][seely-1].typ) != CORR && num != 0;
X		seely--);
X	for(seehy = u.uy; (num = levl[zx][seehy+1].typ) != CORR && num != 0;
X		seehy++);
X	for(zy = seely; zy <= seehy; zy++)
X		for(zx = seelx; zx <= seehx; zx++) {
X			levl[zx][zy].lit = on;
X			if(!Blind && dist(zx,zy) > 2)
X				if(on) prl(zx,zy); else nosee(zx,zy);
X		}
X	if(!on) seehx = 0;
X#endif
X}
X
X/* Test whether we may genocide all monsters with symbol  ch  */
Xmonstersym(ch)				/* arnold@ucsfcgl */
Xregister char ch;
X{
X	register struct permonst *mp;
X
X	/*
X	 * can't genocide certain monsters
X	 */
X#ifdef SAC
X	if (index("123 &:", ch)) return FALSE;
X#else
X	if (index("12 &:", ch))  return FALSE;
X#endif
X	if (ch == pm_eel.mlet)	return TRUE;
X	for (mp = mons; mp < &mons[CMNUM+2]; mp++)
X		if (mp->mlet == ch) return TRUE;
X
X	return FALSE;
X}
X
Xdo_genocide() {
X	extern char genocided[], fut_geno[];
X	char buf[BUFSZ];
X	register struct monst *mtmp, *mtmp2;
X
X	if(Confusion != 0)  *buf = u.usym;
X	else do {
X	    pline("What monster do you want to genocide (Type the letter)? ");
X	    getlin(buf);
X	}
X
X	while(strlen(buf) != 1 || !monstersym(*buf));
X
X	if(!index(fut_geno, *buf))  charcat(fut_geno, *buf);
X	if(!index(genocided, *buf)) charcat(genocided, *buf);
X	else {
X		pline("Such monsters do not exist in this world.");
X		return;
X	}
X	for(mtmp = fmon; mtmp; mtmp = mtmp2){
X		mtmp2 = mtmp->nmon;
X		if(mtmp->data->mlet == *buf)
X			mondead(mtmp);
X	}
X	pline("Wiped out all %c's.", Hallucination ? '@' : *buf);
X	/* Scare the hallucinating player */
X	if(*buf == '@') {
X		u.uhp = -1;
X		killer = "scroll of genocide";
X	/* A polymorphed character will die as soon as he is rehumanized. */
X		if(u.usym != '@')	pline("You feel dead inside.");
X		else			done("died");
X	}
X#ifdef KAA
X	else if (*buf==u.usym) rehumanize();
X#endif
X}
X
Xdo_mapping()
X{
X	register struct rm *lev;
X	register int num, zx, zy;
X
X	for(zy = 0; zy < ROWNO; zy++)
X	    for(zx = 0; zx < COLNO; zx++) {
X
X		if((Confusion != 0) && rn2(7)) continue;
X		lev = &(levl[zx][zy]);
X		if((num = lev->typ) == 0)	continue;
X
X		if(num == SCORR) {
X			lev->typ = CORR;
X			lev->scrsym = CORR_SYM;
X		} else	if(num == SDOOR) {
X			lev->typ = DOOR;
X			lev->scrsym = DOOR_SYM;
X		/* do sth in doors ? */
X		} else if(lev->seen) continue;
X#ifndef QUEST
X		if(num != ROOM)
X#endif
X		{
X			lev->seen = lev->new = 1;
X			if(lev->scrsym == STONE_SYM || !lev->scrsym)
X				newsym(zx,zy);
X			else	on_scr(zx,zy);
X		}
X	    }
X}
X
Xdestroy_arm() {
X
X	if(uarm) {
X		pline("Your armor turns to dust and falls to the floor!");
X		useup(uarm);
X	} else if(uarmh) {
X		pline("Your helmet turns to dust and is blown away!");
X		useup(uarmh);
X	} else if(uarmg) {
X		pline("Your gloves vanish!");
X		useup(uarmg);
X		selftouch("You");
X	} else if(uarms) {
X		pline("Your shield crumbles away!");
X		useup(uarms);
X	} else  return(0);		/* could not destroy anything */
X
X	return(1);
X}
END_OF_read.c
if test 16984 -ne `wc -c <read.c`; then
    echo shar: \"read.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
echo shar: End of archive 8 \(of 20\).
cp /dev/null ark8isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 20 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
