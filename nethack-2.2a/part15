Relay-Version: version B 2.10 5/3/83; site utzoo.UUCP
Path: utzoo!mnetor!uunet!tektronix!tekgen!tekred!games-request
From: games-request@tekred.TEK.COM
Newsgroups: comp.sources.games
Subject: v03i015:  NetHack2.2 - display oriented dungeons and dragons, Part15/20
Message-ID: <1902@tekred.TEK.COM>
Date: Thu, 3-Dec-87 11:55:46 EST
Article-I.D.: tekred.1902
Posted: Thu Dec  3 11:55:46 1987
Date-Received: Wed, 9-Dec-87 23:32:36 EST
Sender: billr@tekred.TEK.COM
Lines: 2339
Approved: billr@tekred.TEK.COM

Submitted by: mike@genat.UUCP (Mike Stephenson)
Comp.sources.games: Volume 3, Issue 15
Archive-name: nethack2.2/Part15



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 15 (of 20)."
# Contents:  do.c do_name.c end.c makemon.c onames.h unixtty.c
# Wrapped by billr@tekred on Tue Dec  1 16:25:10 1987
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f do.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"do.c\"
else
echo shar: Extracting \"do.c\" \(8810 characters\)
sed "s/^X//" >do.c <<'END_OF_do.c'
X/*	SCCS Id: @(#)do.c	2.0	87/09/15
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X
X/* Contains code for 'd', 'D' (drop), '>', '<' (up, down) and 't' (throw) */
X
X#include "hack.h"
X
Xextern struct obj *splitobj(), *addinv();
Xextern boolean hmon();
Xextern boolean level_exists[];
Xextern struct monst youmonst;
Xextern char *Doname();
Xextern char *nomovemsg;
Xint	identify();
X#ifdef KAA
Xextern char *xname();
X#endif
X
Xdodrop() {
X	if(u.ugold)	return(drop(getobj("0$#", "drop")));
X	else		return(drop(getobj("0#", "drop")));
X}
X
Xstatic
Xdrop(obj) register struct obj *obj; {
X	if(!obj) return(0);
X	if(obj->olet == GOLD_SYM) {		/* pseudo object */
X		register long amount = OGOLD(obj);
X
X		if(amount == 0)
X			pline("You didn't drop any gold pieces.");
X/* Fix bug with dropping huge amounts of gold read as negative    KAA */
X		else if(amount < 0) {
X			u.ugold += amount;
X	pline("The LRS would be very interested to know you have that much.");
X		} else {
X			/* uswallow test added by GAN 01/29/87 */
X			pline("You dropped %ld gold piece%s.",
X				 amount, plur(amount));
X			if(u.uswallow)
X				(u.ustuck)->mgold += amount;
X			else {
X				mkgold(amount, u.ux, u.uy);
X				if(Invisible) newsym(u.ux, u.uy);
X			}
X		}
X		free((char *) obj);
X		return(1);
X	}
X	if(obj->owornmask & (W_ARMOR | W_RING)){
X		pline("You cannot drop something you are wearing.");
X		return(0);
X	}
X	if(obj == uwep) {
X		if(uwep->cursed) {
X			pline("Your weapon is welded to your hand!");
X			return(0);
X		}
X		setuwep((struct obj *) 0);
X	}
X#ifdef WALKIES
X        if (obj->otyp == LEASH) {
X            register struct monst *mtmp = fmon;
X            while (mtmp && !mtmp->mleashed) mtmp = mtmp->nmon;
X            if (mtmp) {
X                pline ("Your leash is tied around your hand.");
X                return (0);
X            }
X        }
X#endif
X	pline("You dropped %s.", doname(obj));
X	dropx(obj);
X	return(1);
X}
X
X/* Called in several places - should not produce texts */
Xdropx(obj)
Xregister struct obj *obj;
X{
X	freeinv(obj);
X	dropy(obj);
X}
X
Xdropy(obj)
Xregister struct obj *obj;
X{
X	if(obj->otyp == CRYSKNIFE)
X		obj->otyp = WORM_TOOTH;
X	/* uswallow check done by GAN 01/29/87 */
X	if(u.uswallow)
X		mpickobj(u.ustuck,obj);
X	else  {
X		obj->ox = u.ux;
X		obj->oy = u.uy;
X		/* Blind check added by GAN 02/18/87 */
X		if(Blind)  {
X#ifdef KAA
X			if(obj->olet != ')')
X#endif
X			    obj->dknown = index("/=!?*",obj->olet) ? 0 : 1;
X			obj->known = 0;
X		}
X		obj->nobj = fobj;
X		fobj = obj;
X		if(Invisible) newsym(u.ux,u.uy);
X		subfrombill(obj);
X		stackobj(obj);
X	}
X}
X
X/* drop several things */
Xdoddrop() {
X	return(ggetobj("drop", drop, 0));
X}
X
Xdodown()
X{
X	if(u.ux != xdnstair || u.uy != ydnstair) {
X		pline("You can't go down here.");
X		return(0);
X	}
X	if(u.ustuck) {
X		pline("You are being held, and cannot go down.");
X		return(1);
X	}
X	if(Levitation) {
X		pline("Your floating high above the stairs.");
X		return(0);
X	}
X
X	goto_level(dlevel+1, TRUE);
X	return(1);
X}
X
Xdoup()
X{
X	if(u.ux != xupstair || u.uy != yupstair) {
X		pline("You can't go up here.");
X		return(0);
X	}
X	if(u.ustuck) {
X		pline("You are being held, and cannot go up.");
X		return(1);
X	}
X	if(!Levitation && inv_weight() + 5 > 0) {
X		pline("Your load is too heavy to climb the stairs.");
X		return(1);
X	}
X
X	goto_level(dlevel-1, TRUE);
X	return(1);
X}
X
Xgoto_level(newlevel, at_stairs)
Xregister int newlevel;
Xregister boolean at_stairs;
X{
X	register fd;
X	register boolean up = (newlevel < dlevel);
X
X	if(newlevel <= 0) done("escaped");    /* in fact < 0 is impossible */
X	if(newlevel > MAXLEVEL) newlevel = MAXLEVEL;	/* strange ... */
X	if(newlevel == dlevel) return;	      /* this can happen */
X
X	glo(dlevel);
X#ifdef DGK
X	/* Use O_TRUNC to force the file to be shortened if it already
X	 * exists and is currently longer.
X	 */
X	fd = open(lock, O_WRONLY | O_BINARY | O_CREAT | O_TRUNC, FMASK);
X#else
X	fd = creat(lock, FMASK);
X#endif
X	if(fd < 0) {
X		/*
X		 * This is not quite impossible: e.g., we may have
X		 * exceeded our quota. If that is the case then we
X		 * cannot leave this level, and cannot save either.
X		 * Another possibility is that the directory was not
X		 * writable.
X		 */
X#ifdef DGK
X		pline("Cannot create level file '%s'.", lock);
X#else
X		pline("A mysterious force prevents you from going %s.",
X			up ? "up" : "down");
X#endif
X		return;
X	}
X
X#ifdef DGK
X	if (!savelev(fd, dlevel, COUNT)) {
X		(void) close(fd);
X		(void) unlink(lock);
X		pline("HACK is out of disk space for making levels!");
X		pline("You can save, quit, or continue playing.");
X		return;
X	}
X#endif
X	if(Punished) unplacebc();
X	u.utrap = 0;				/* needed in level_tele */
X	u.ustuck = 0;				/* idem */
X	keepdogs();
X	seeoff(1);
X	if(u.uswallow)				/* idem */
X		u.uswldtim = u.uswallow = 0;
X	flags.nscrinh = 1;
X	u.ux = FAR;				/* hack */
X	(void) inshop();			/* probably was a trapdoor */
X
X#ifdef DGK
X	savelev(fd,dlevel, WRITE);
X#else
X	savelev(fd,dlevel);
X#endif
X	(void) close(fd);
X
X	dlevel = newlevel;
X	if(maxdlevel < dlevel)
X		maxdlevel = dlevel;
X	glo(dlevel);
X#ifdef MSDOS
X	/* If the level has no where yet, it hasn't been made
X	 */
X	if(!fileinfo[dlevel].where)
X#else
X	if(!level_exists[dlevel])
X#endif
X		mklev();
X	else {
X		extern int hackpid;
X#ifdef DGK
X		/* If not currently accessible, swap it in.
X		 */
X		if (fileinfo[dlevel].where != ACTIVE)
X			swapin_file(dlevel);
X
X		if((fd = open(lock, O_RDONLY | O_BINARY)) < 0) {
X#else
X		if((fd = open(lock,0)) < 0) {
X#endif
X			pline("Cannot open %s .", lock);
X			pline("Probably someone removed it.");
X			done("tricked");
X		}
X		getlev(fd, hackpid, dlevel);
X		(void) close(fd);
X	}
X
X	if(at_stairs) {
X	    if(up) {
X		u.ux = xdnstair;
X		u.uy = ydnstair;
X		if(!u.ux) {		/* entering a maze from below? */
X		    u.ux = xupstair;	/* this will confuse the player! */
X		    u.uy = yupstair;
X		}
X/* Remove bug which crashes with levitation/punishment  KAA */
X		if(Punished) {
X		    if(!Levitation) 
X			pline("With great effort you climb the stairs.");
X		    placebc(1);
X		}
X	    } else {
X		u.ux = xupstair;
X		u.uy = yupstair;
X		if(inv_weight() + 5 > 0 || Punished){
X			pline("You fall down the stairs.");	/* %% */
X			losehp(rnd(3), "fall");
X			if(Punished) {
X			    if(uwep != uball && rn2(3)){
X				pline("... and are hit by the iron ball.");
X				losehp(rnd(20), "iron ball");
X			    }
X			    placebc(1);
X			}
X			selftouch("Falling, you");
X		}
X	    }
X	    { register struct monst *mtmp = m_at(u.ux, u.uy);
X	      if(mtmp)
X		mnexto(mtmp);
X	    }
X	} else {	/* trapdoor or level_tele */
X	    do {
X		u.ux = rnd(COLNO-1);
X		u.uy = rn2(ROWNO);
X	    } while(levl[u.ux][u.uy].typ != ROOM ||
X			m_at(u.ux,u.uy));
X	    if(Punished){
X		if(uwep != uball && !up /* %% */ && rn2(5)){
X			pline("The iron ball falls on your head.");
X			losehp(rnd(25), "iron ball");
X		}
X		placebc(1);
X	    }
X	    selftouch("Falling, you");
X	}
X	(void) inshop();
X	initrack();
X
X	losedogs();
X	{ register struct monst *mtmp;
X	  if(mtmp = m_at(u.ux, u.uy)) mnexto(mtmp);	/* riv05!a3 */
X	}
X	flags.nscrinh = 0;
X	setsee();
X	seeobjs();	/* make old cadavers disappear - riv05!a3 */
X	docrt();
X	pickup(1);
X	read_engr_at(u.ux,u.uy);
X}
X
Xdonull() {
X	return(1);	/* Do nothing, but let other things happen */
X}
X
X#if defined(KAA) && defined(KOPS)
Xwipeoff()
X{
X	if(u.ucreamed < 4)	u.ucreamed = 0;
X	else			u.ucreamed -= 4;
X	if(u.ucreamed > 0)  {
X		Blinded -= 4;
X		if(Blind <= 1) {
X			pline("You've got the glop off.");
X			u.ucreamed = 0;
X			Blinded = 1;
X			return(0);
X		}
X		return(1);		/* still busy */
X	}
X	pline("Your face feels clean now.");
X	u.ucreamed = 0;
X	return(0);
X}
X	
Xdowipe()
X{
X	if(u.ucreamed)  {
X#ifdef DGKMOD
X		set_occupation(wipeoff, "wiping off your face", 0);
X#else
X		occupation = wipeoff;
X		occtxt = "wiping off your face";
X#endif
X		return(1);
X	}
X	pline("Your face is already clean.");
X	return(1);
X}
X#endif
X
X/* split obj so that it gets size num */
X/* remainder is put in the object structure delivered by this call */
Xstruct obj *
Xsplitobj(obj, num) register struct obj *obj; register int num; {
Xregister struct obj *otmp;
X	otmp = newobj(0);
X	*otmp = *obj;		/* copies whole structure */
X	otmp->o_id = flags.ident++;
X	otmp->onamelth = 0;
X	obj->quan = num;
X	obj->owt = weight(obj);
X	otmp->quan -= num;
X	otmp->owt = weight(otmp);	/* -= obj->owt ? */
X	obj->nobj = otmp;
X	if(obj->unpaid) splitbill(obj,otmp);
X	return(otmp);
X}
X
Xmore_experienced(exp,rexp)
Xregister int exp, rexp;
X{
X	extern char pl_character[];
X
X	u.uexp += exp;
X	u.urexp += 4*exp + rexp;
X	if(exp) flags.botl = 1;
X	if(u.urexp >= ((pl_character[0] == 'W') ? 1000 : 2000))
X		flags.beginner = 0;
X}
X
Xset_wounded_legs(side, timex)
Xregister long side;
Xregister int timex;
X{
X	if(!Wounded_legs || (Wounded_legs & TIMEOUT))
X		Wounded_legs |= side + timex;
X	else
X		Wounded_legs |= side;
X}
X
Xheal_legs()
X{
X	if(Wounded_legs) {
X		if((Wounded_legs & BOTH_SIDES) == BOTH_SIDES)
X			pline("Your legs feel somewhat better.");
X		else
X			pline("Your leg feels somewhat better.");
X		Wounded_legs = 0;
X	}
X}
END_OF_do.c
if test 8810 -ne `wc -c <do.c`; then
    echo shar: \"do.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f do_name.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"do_name.c\"
else
echo shar: Extracting \"do_name.c\" \(7416 characters\)
sed "s/^X//" >do_name.c <<'END_OF_do_name.c'
X/*	SCCS Id: @(#)do_name.c	2.1	87/11/09
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X
X#include <stdio.h>
X#include "hack.h"
Xextern char plname[];
Xextern char *rndmonnam();
X
Xgetpos(cc,force,goal)
Xcoord	*cc;
Xint force; char *goal;
X{
Xregister cx,cy,i,c;
Xextern char sdir[];		/* defined in hack.c */
Xextern schar xdir[], ydir[];	/* idem */
Xextern char *visctrl();		/* see below */
X	pline("(For instructions type a ?)");
X	cx = u.ux;
X	cy = u.uy;
X	curs(cx,cy+2);
X	while((c = readchar()) != '.'){
X		for(i=0; i<8; i++) if(sdir[i] == c){
X			if(1 <= cx + xdir[i] && cx + xdir[i] <= COLNO)
X				cx += xdir[i];
X			if(0 <= cy + ydir[i] && cy + ydir[i] <= ROWNO-1)
X				cy += ydir[i];
X			goto nxtc;
X		}
X		if(c == '?'){
X			pline("Use [hjkl] to move the cursor to %s.", goal);
X			pline("Type a . when you are at the right place.");
X		} else {
X			pline("Unknown direction: '%s' (%s).",
X				visctrl(c),
X				force ? "use hjkl or ." : "aborted");
X			if(force) goto nxtc;
X			cc->x = -1;
X			cc->y = 0;
X			return(0);
X		}
X	nxtc:	;
X		curs(cx,cy+2);
X	}
X	cc->x = cx;
X	cc->y = cy;
X	return(0);
X}
X
Xdo_mname(){
Xchar buf[BUFSZ];
Xcoord cc;
Xregister int cx,cy,lth,i;
Xregister struct monst *mtmp, *mtmp2;
Xextern char *lmonnam();
X	getpos(&cc, 0, "the monster you want to name");
X	cx = cc.x;
X	cy = cc.y;
X	if(cx < 0) return(0);
X#ifdef DGKMOD
X	if (cx == u.ux && cy == u.uy) {
X		pline("This ugly monster is called %s and cannot be renamed.",
X		plname);
X		return(1);
X	}
X	if (!cansee(cx, cy) || !(mtmp = m_at(cx, cy)) || mtmp->mimic) {
X		pline("I see no monster there.");
X		return(1);
X	}
X#else
X	mtmp = m_at(cx,cy);
X	if(!mtmp){
X	    if(cx == u.ux && cy == u.uy)
X		pline("This ugly monster is called %s and cannot be renamed.",
X		    plname);
X	    else
X		pline("There is no monster there.");
X	    return(1);
X	}
X	if(mtmp->mimic){
X	    pline("I see no monster there.");
X	    return(1);
X	}
X	if(!cansee(cx,cy)) {
X	    pline("I cannot see a monster there.");
X	    return(1);
X	}
X#endif
X	pline("What do you want to call %s? ", lmonnam(mtmp));
X	getlin(buf);
X	clrlin();
X	if(!*buf || *buf == '\033')
X		return(1);
X	lth = strlen(buf)+1;
X	if(lth > 63){
X		buf[62] = 0;
X		lth = 63;
X	}
X	mtmp2 = newmonst(mtmp->mxlth + lth);
X	*mtmp2 = *mtmp;
X	for(i=0; i<mtmp->mxlth; i++)
X		((char *) mtmp2->mextra)[i] = ((char *) mtmp->mextra)[i];
X	mtmp2->mnamelth = lth;
X	(void) strcpy(NAME(mtmp2), buf);
X	replmon(mtmp,mtmp2);
X	return(1);
X}
X
X/*
X * This routine changes the address of  obj . Be careful not to call it
X * when there might be pointers around in unknown places. For now: only
X * when  obj  is in the inventory.
X */
Xdo_oname(obj)
X	register struct obj *obj;
X{
X	char buf[BUFSZ];
X
X	pline("What do you want to name %s? ", doname(obj));
X	getlin(buf);
X	clrlin();
X	if(!*buf || *buf == '\033')	return;
X#ifdef RPH
X	if(!strcmp(buf, "Excalibur")) {
X		pline("Somehow you can't seem to engrave that word.");
X		return;
X	}
X#endif
X	oname(obj, buf);
X}
X
Xoname(obj, buf)
X	register struct obj *obj;
X	char	*buf;
X{
Xregister struct obj *otmp, *otmp2;
Xregister int	lth;
X
X	lth = strlen(buf)+1;
X	if(lth > 63){
X		buf[62] = 0;
X		lth = 63;
X	}
X	otmp2 = newobj(lth);
X	*otmp2 = *obj;
X	otmp2->onamelth = lth;
X	(void) strcpy(ONAME(otmp2), buf);
X
X	setworn((struct obj *) 0, obj->owornmask);
X	setworn(otmp2, otmp2->owornmask);
X
X	/* do freeinv(obj); etc. by hand in order to preserve
X	   the position of this object in the inventory */
X	if(obj == invent) invent = otmp2;
X	else for(otmp = invent; ; otmp = otmp->nobj){
X		if(!otmp)
X			panic("oname: cannot find obj.");
X		if(otmp->nobj == obj){
X			otmp->nobj = otmp2;
X			break;
X		}
X	}
X	/* obfree(obj, otmp2);	/* now unnecessary: no pointers on bill */
X	free((char *) obj);	/* let us hope nobody else saved a pointer */
X}
X
Xddocall()
X{
X	register struct obj *obj;
X	char	ch;
X
X#ifdef REDO
X	if (!in_doagain)
X#endif
X		pline("Do you want to name an individual object? [ny] ");
X	switch(ch = readchar()) {
X	case '\033':
X		break;
X	case 'y':
X#ifdef REDO
X		savech(ch);
X#endif
X		obj = getobj("#", "name");
X		if(obj) do_oname(obj);
X		break;
X	default:
X#ifdef REDO
X		savech(ch);
X#endif
X#ifdef KAA
X		obj = getobj("?!=/*", "call");
X#else
X		obj = getobj("?!=/", "call");
X#endif
X		if(obj) docall(obj);
X	}
X	return(0);
X}
X
Xdocall(obj)
Xregister struct obj *obj;
X{
X	char buf[BUFSZ];
X	struct obj otemp;
X	register char **str1;
X	extern char *xname();
X	register char *str;
X
X	otemp = *obj;
X	otemp.quan = 1;
X	otemp.onamelth = 0;
X	str = xname(&otemp);
X	pline("Call %s %s: ", index(vowels,*str) ? "an" : "a", str);
X	getlin(buf);
X	clrlin();
X	if(!*buf || *buf == '\033')
X		return;
X	str = newstring(strlen(buf)+1);
X	(void) strcpy(str,buf);
X	str1 = &(objects[obj->otyp].oc_uname);
X	if(*str1) free(*str1);
X	*str1 = str;
X}
X
Xchar *ghostnames[] = {		/* these names should have length < PL_NSIZ */
X	/* Capitalize the names for asthetics -dgk
X	 */
X	"Adri", "Andries", "Andreas", "Bert", "David", "Dirk", "Emile",
X	"Frans", "Fred", "Greg", "Hether", "Jay", "John", "Jon", "Karnov",
X	"Kay", "Kenny", "Kevin", "Maud", "Michiel", "Mike", "Peter", "Robert",
X	"Ron", "Tom", "Wilmar", "Nick Danger", "Phoenix", "Miracleman",
X	"Stephan"
X};
X
Xchar *
Xxmonnam(mtmp, vb) register struct monst *mtmp; int vb; {
Xstatic char buf[BUFSZ];		/* %% */
Xextern char *shkname();
X	if(mtmp->mnamelth && !vb) {
X		(void) strcpy(buf, NAME(mtmp));
X		return(buf);
X	}
X	switch(mtmp->data->mlet) {
X	case ' ':
X		{ register char *gn = (char *) mtmp->mextra;
X		  if(!*gn) {		/* might also look in scorefile */
X		    gn = ghostnames[rn2(SIZE(ghostnames))];
X		    if(!rn2(2)) (void)
X		      strcpy((char *) mtmp->mextra, !rn2(5) ? plname : gn);
X		  }
X		  (void) sprintf(buf, "%s's ghost", gn);
X		}
X		break;
X	case '@':
X		if(mtmp->isshk) {
X			(void) strcpy(buf, shkname(mtmp));
X			break;
X		}
X		/* fall into next case */
X	default:
X		(void) sprintf(buf, "the %s%s",
X			mtmp->minvis ? "invisible " : "",
X			(Hallucination ? rndmonnam() : mtmp->data->mname));
X	}
X	if(vb && mtmp->mnamelth) {
X		(void) strcat(buf, " called ");
X		(void) strcat(buf, NAME(mtmp));
X	}
X	return(buf);
X}
X
Xchar *
Xlmonnam(mtmp) register struct monst *mtmp; {
X	return(xmonnam(mtmp, 1));
X}
X
Xchar *
Xmonnam(mtmp) register struct monst *mtmp; {
X	return(xmonnam(mtmp, 0));
X}
X
Xchar *
XMonnam(mtmp) register struct monst *mtmp; {
Xregister char *bp = monnam(mtmp);
X	if('a' <= *bp && *bp <= 'z') *bp += ('A' - 'a');
X	return(bp);
X}
X
Xchar *
Xamonnam(mtmp,adj)
Xregister struct monst *mtmp;
Xregister char *adj;
X{
X	register char *bp = monnam(mtmp);
X	static char buf[BUFSZ];		/* %% */
X
X	if(!strncmp(bp, "the ", 4)) bp += 4;
X	(void) sprintf(buf, "the %s %s", adj, bp);
X	return(buf);
X}
X
Xchar *
XAmonnam(mtmp, adj)
Xregister struct monst *mtmp;
Xregister char *adj;
X{
X	register char *bp = amonnam(mtmp,adj);
X
X	*bp = 'T';
X	return(bp);
X}
X
Xchar *
XXmonnam(mtmp) register struct monst *mtmp; {
Xregister char *bp = Monnam(mtmp);
X	if(!strncmp(bp, "The ", 4)) {
X#ifdef KAA
X		if(index("AEIOUaeio",*(bp+4))) {
X			bp += 1; *(bp+1) = 'n';
X		} else
X#endif
X			bp += 2;
X		*bp = 'A';
X	}
X	return(bp);
X}
X
Xchar *
Xdefmonnam(mtmp) register struct monst *mtmp; {
Xregister char *bp = Xmonnam(mtmp);
X	if (!strncmp(bp,"A ",2) || !strncmp(bp,"An ",3))
X		*bp = 'a';
X	return(bp);
X}
X
Xchar *
Xrndmonnam() {  /* Random name of monster type, if hallucinating */
Xint x;
X	if ((x=rn2(CMNUM+2)) != CMNUM+1) return (&mons[x])->mname;
X	return("giant eel");
X}
X
Xchar *
Xvisctrl(c)
Xchar c;
X{
Xstatic char ccc[3];
X	if(c < 040) {
X		ccc[0] = '^';
X		ccc[1] = c + 0100;
X		ccc[2] = 0;
X	} else {
X		ccc[0] = c;
X		ccc[1] = 0;
X	}
X	return(ccc);
X}
END_OF_do_name.c
if test 7416 -ne `wc -c <do_name.c`; then
    echo shar: \"do_name.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f end.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"end.c\"
else
echo shar: Extracting \"end.c\" \(8789 characters\)
sed "s/^X//" >end.c <<'END_OF_end.c'
X/*	SCCS Id: @(#)end.c	2.1	87/10/07
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X
X#include <stdio.h>
X#include <signal.h>
X#include "hack.h"
X#define	Sprintf	(void) sprintf
Xextern char plname[], pl_character[], SAVEF[];
X
Xxchar maxdlevel = 1;
Xint done_stopprint;
Xint done_hup;
X
X
Xdone1()
X{
X	(void) signal(SIGINT,SIG_IGN);
X#if defined(WIZARD) && defined(UNIX) && !defined(KJSMODS)
X	if(wizard) {
X	    pline("Dump core?");
X	    if(readchar() == 'y') {
X		(void) signal(SIGINT,done1);
X		abort();
X	    }
X	}
X#endif
X	pline("Really quit?");
X	if(readchar() != 'y') {
X		(void) signal(SIGINT,done1);
X		clrlin();
X		(void) fflush(stdout);
X		if(multi > 0) nomul(0);
X		return(0);
X	}
X	done("quit");
X	/* NOTREACHED */
X}
X
Xdone_intr(){
X	done_stopprint++;
X	(void) signal(SIGINT, SIG_IGN);
X#ifdef UNIX
X	(void) signal(SIGQUIT, SIG_IGN);
X#endif
X}
X
X#ifdef UNIX
Xdone_hangup(){
X	done_hup++;
X	(void) signal(SIGHUP, SIG_IGN);
X	done_intr();
X}
X#endif
X
Xdone_in_by(mtmp)
Xregister struct monst *mtmp;
X{
X	char *hallmon();
X	static char buf[BUFSZ], *prefix;
X	extern char *eos(), *shkname();
X	pline("You die ...");
X	if (Hallucination) { 
X		Sprintf(buf, "hallucinated %s (actually ", hallmon()); 
X		prefix = (index("aeiou",*mtmp->data->mname) ? "an" : "a");
X	}
X	if(mtmp->data->mlet == ' ') {
X		if (Hallucination) Sprintf(eos(buf), "the ghost of %s)",
X					   (char *) mtmp->mextra);
X		else Sprintf(buf, "the ghost of %s", (char *) mtmp->mextra);
X	} else if(mtmp->mnamelth) {
X		if (Hallucination) Sprintf(eos(buf), "%s %s called %s)",
X					   prefix, mtmp->data->mname,
X					   NAME(mtmp));
X		else Sprintf(buf, "%s called %s",
X			     mtmp->data->mname, NAME(mtmp));
X	} else if(mtmp->minvis) {
X		if (Hallucination) Sprintf(eos(buf), "an invisible %s)",
X					   mtmp->data->mname);
X		else Sprintf(buf, "invisible %s", mtmp->data->mname);
X	} else if(mtmp->isshk) {
X		if (Hallucination) Sprintf(eos(buf), "%s %s the shopkeeper)",
X					   rn2(2) ? "Mr." : "Ms.",
X					   shkname(mtmp));
X		else Sprintf(buf, "%s %s, the shopkeeper!",
X			     rn2(2) ? "Mr." : "Ms.", shkname(mtmp));
X	} else {
X		if (Hallucination) Sprintf(eos(buf), "%s %s)",
X					   prefix, mtmp->data->mname);
X		else Sprintf(buf, "%s", mtmp->data->mname);
X	}
X	killer = buf;
X	done("died");
X}
X
X/*VARARGS1*/
Xboolean panicking;
X
Xpanic(str,a1,a2,a3,a4,a5,a6)
Xchar *str;
X{
X	if(panicking++) abort();    /* avoid loops - this should never happen*/
X				    /* was exit(1) */
X	home(); cls();
X	puts(" Suddenly, the dungeon collapses.");
X#ifdef WIZARD
X	pline("Report error to %s and it may be possible to rebuild.",WIZARD);
X	more();
X	(void) sprintf (SAVEF, "%s.e", SAVEF);
X	dosave0(0);
X#endif	
X	fputs(" ERROR:  ", stdout);
X	printf(str,a1,a2,a3,a4,a5,a6);
X	more();				/* contains a fflush() */
X#ifdef WIZARD
X# ifdef UNIX
X	if (wizard)	abort();	/* generate core dump */
X# endif
X#endif
X	done("panicked");
X}
X
X/* called with arg "died", "drowned", "escaped", "quit", "choked", "panicked",
X   "burned", "starved" or "tricked" */
X/* Be careful not to call panic from here! */
Xdone(st1)
Xregister char *st1;
X{
X#ifdef DIAGS
X	char	c;
X#endif
X#ifdef WIZARD
X	extern char	*nomovemsg;
X
X	if(wizard && index("bcds", *st1)){
X		char buf[BUFSZ];
X		pline("Die? ");
X		getlin(buf);
X		if(index("yY",buf[0])) goto die;
X		u.uswldtim = 0;
X		if(u.uhpmax < 0) u.uhpmax = 100;	/* arbitrary */
X		u.uhp = u.uhpmax;
X		pline("Ok, so you don't die.");
X		nomovemsg = "You survived that attempt on your life.";
X		flags.move = 0;
X		if(multi > 0) multi = 0; else multi = -1;
X		flags.botl = 1;
X		return;
X	}
X#endif /* WIZARD /**/
Xdie:
X	(void) signal(SIGINT, done_intr);
X#ifdef UNIX
X	(void) signal(SIGQUIT, done_intr);
X	(void) signal(SIGHUP, done_hangup);
X#endif
X	if(*st1 == 'q' && u.uhp < 1){
X		st1 = "died";
X		killer = "quit while already on Charon's boat";
X	}
X	if(*st1 == 's') killer = "starvation"; else
X	if(*st1 == 'd' && st1[1] == 'r') killer = "drowning"; else
X	if(*st1 == 'p') killer = "panic"; else
X	if(*st1 == 't') killer = "trickery"; else
X	if(!index("bcd", *st1)) killer = st1;
X	paybill();
X	clearlocks();
X	if(flags.toplin == 1) more();
X#ifdef DIAGS
X	pline("Do you want to have your possessions identified? [Yynq] ");
X	/* New dump format by maartenj@cs.vu.nl */
X	if ((c = readchar()) == 'y' || c == 'Y') {
X	    struct obj *obj;
X
X	    for(obj = invent; obj && !done_stopprint; obj = obj->nobj) {
X		objects[obj->otyp].oc_name_known = 1;
X# ifdef KAA
X		obj->known = 1;
X		if (obj->olet != WEAPON_SYM) obj->dknown = 1;
X# else
X		obj->known = obj->dknown = 1;
X# endif /* KAA */
X	    }
X	    doinv((char *) 0);
X	}
X	if (c == 'q' || c == 'Y')  done_stopprint++;
X#endif
X	if(index("bcds", *st1)){
X#ifdef WIZARD
X	    if(wizard) {
X		char buf[BUFSZ];
X		pline("Save bones? ");
X		getlin(buf);
X		if(buf[0] == 'y') savebones();
X	    }  else
X#endif
X		savebones();
X		if(!flags.notombstone) outrip();
X	}
X	if(*st1 == 'c') killer = st1;		/* after outrip() */
X#ifdef KJSMODS
X	if(with_amulet()) (void) strcat(killer," (with amulet)");
X#endif 
X	settty((char *) 0);	/* does a clear_screen() */
X	if(!done_stopprint)
X		printf("Goodbye %s %s...\n\n", pl_character, plname);
X	{ long int tmp;
X	  tmp = u.ugold - u.ugold0;
X	  if(tmp < 0)
X		tmp = 0;
X	  if(*st1 == 'd' || *st1 == 'b')
X		tmp -= tmp/10;
X	  u.urexp += tmp;
X	  u.urexp += 50 * maxdlevel;
X	  if(maxdlevel > 20)
X		u.urexp += 1000*((maxdlevel > 30) ? 10 : maxdlevel - 20);
X	}
X	if(*st1 == 'e') {
X		extern struct monst *mydogs;
X		register struct monst *mtmp;
X		register struct obj *otmp;
X#ifdef DGKMOD
X		long i;
X#else
X		register int i;
X#endif
X		register unsigned worthlessct = 0;
X		boolean has_amulet = FALSE;
X
X		killer = st1;
X		keepdogs();
X		mtmp = mydogs;
X		if(mtmp) {
X			if(!done_stopprint) printf("You");
X			while(mtmp) {
X				if(!done_stopprint)
X					printf(" and %s", monnam(mtmp));
X				if(mtmp->mtame)
X					u.urexp += mtmp->mhp;
X				mtmp = mtmp->nmon;
X			}
X			if(!done_stopprint)
X		    printf("\nescaped from the dungeon with %ld points,\n",
X			u.urexp);
X		} else
X		if(!done_stopprint)
X		  printf("You escaped from the dungeon with %ld points,\n",
X		    u.urexp);
X		for(otmp = invent; otmp; otmp = otmp->nobj) {
X			if(otmp->olet == GEM_SYM){
X				objects[otmp->otyp].oc_name_known = 1;
X#ifdef DGKMOD
X				i = (long) otmp->quan *
X					objects[otmp->otyp].g_val;
X#else
X				i = otmp->quan*objects[otmp->otyp].g_val;
X#endif
X				if(i == 0) {
X					worthlessct += otmp->quan;
X					continue;
X				}
X				u.urexp += i;
X#ifndef DGKMOD
X				if(!done_stopprint)
X				  printf("\t%s (worth %d Zorkmids),\n",
X#else
X				printf("        %s (worth %ld Zorkmids),\n",
X#endif
X				    doname(otmp), i);
X			} else if(otmp->olet == AMULET_SYM) {
X				otmp->known = 1;
X				i = (otmp->spe < 0) ? 2 : 5000;
X				u.urexp += i;
X#ifndef DGKMOD
X				if(!done_stopprint)
X				  printf("\t%s (worth %d Zorkmids),\n",
X#else
X				printf("        %s (worth %d Zorkmids),\n",
X#endif
X				    doname(otmp), i);
X				if(otmp->spe >= 0) {
X					has_amulet = TRUE;
X					killer = "escaped (with amulet)";
X				}
X			}
X		}
X		if(worthlessct)
X#ifndef DGKMOD
X		  if(!done_stopprint)
X		    printf("\t%u worthless piece%s of colored glass,\n",
X#else
X		  printf("        %u worthless piece%s of colored glass,\n",
X#endif
X			worthlessct, plur(worthlessct));
X		if(has_amulet) u.urexp *= 2;
X	} else
X		if(!done_stopprint)
X		  printf("You %s on dungeon level %d with %ld points,\n",
X		    st1, dlevel, u.urexp);
X	if(!done_stopprint)
X	  printf("and %ld piece%s of gold, after %ld move%s.\n",
X	    u.ugold, plur(u.ugold), moves, plur(moves));
X	if(!done_stopprint)
X  printf("You were level %u with a maximum of %d hit points when you %s.\n",
X	    u.ulevel, u.uhpmax, st1);
X	if(*st1 == 'e' && !done_stopprint){
X		getret();	/* all those pieces of coloured glass ... */
X		cls();
X	}
X#ifdef WIZARD
X	if(!wizard)
X#endif
X		topten();
X	if(done_stopprint) printf("\n\n");
X#ifdef APOLLO
X	getret();
X#endif
X#ifdef MSDOSCOLOR
X	getret();
X	end_screen();
X#endif
X	exit(0);
X}
Xclearlocks(){
X#ifdef DGK
X	eraseall(levels, alllevels);
X	if (ramdisk)
X		eraseall(permbones, alllevels);
X#else
X# ifdef UNIX
Xregister x;
X	(void) signal(SIGHUP,SIG_IGN);
X	for(x = maxdlevel; x >= 0; x--) {
X		glo(x);
X		(void) unlink(lock);	/* not all levels need be present */
X	}
X# endif
X#endif
X}
X
X#ifdef NOSAVEONHANGUP
Xhangup()
X{
X	(void) signal(SIGINT, SIG_IGN);
X	clearlocks();
X	exit(1);
X}
X#endif
X
X/* it is the callers responsibility to check that there is room for c */
Xcharcat(s,c) register char *s, c; {
X	while(*s) s++;
X	*s++ = c;
X	*s = 0;
X}
X
Xchar *
Xhallmon()
X{
X	register char let;
X	register int ct;
X	register struct permonst *ptr;
X
X	let = rndmonsym();
X	for(ct = 0; ct < CMNUM+1 ; ct++) {
X		ptr = &mons[ct];
X		if(ptr->mlet == let) return(ptr->mname);
X			
X	}
X	return("giant eel");
X}
X
X#ifdef KJSMODS
Xwith_amulet()
X{
X	register struct obj *otmp;
X	for(otmp = invent; otmp; otmp = otmp->nobj) {
X		if(otmp->olet == AMULET_SYM) { 
X			if(otmp->spe >= 0) return(1);
X		}
X	}
X	return(0);
X}
X#endif 
END_OF_end.c
if test 8789 -ne `wc -c <end.c`; then
    echo shar: \"end.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f makemon.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"makemon.c\"
else
echo shar: Extracting \"makemon.c\" \(8401 characters\)
sed "s/^X//" >makemon.c <<'END_OF_makemon.c'
X/*	SCCS Id: @(#)makemon.c	2.2	87/11/29
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X
X#include	"hack.h"
Xextern char fut_geno[];
Xextern char *index();
Xextern struct obj *mkobj_at(), *mksobj(), *mkobj();
Xstruct monst zeromonst;
Xextern boolean in_mklev;
X
X#ifdef HARD		/* used in hell for bigger, badder demons! */
X
Xstruct permonst d_lord   = { "demon lord",	'&',12,13,-5,50,1,5,0 },
X		d_prince = { "demon prince",	'&',14,14,-6,70,1,6,0 };
X#endif
X#ifdef KJSMODS
X# ifdef KOPS
Xstruct permonst kobold = { "kobold",'K',1,6,7,0,1,4,0 };
X# endif
X# ifdef ROCKMOLE
Xstruct permonst giant_rat = { "giant rat",'r',0,12,7,0,1,3,0 };
X# endif
X#endif /* KJSMODS /**/
X
X/*
X * called with [x,y] = coordinates;
X *	[0,0] means anyplace
X *	[u.ux,u.uy] means: call mnexto (if !in_mklev)
X *
X *	In case we make an Orc or killer bee, we make an entire horde
X *	(swarm); note that in this case we return only one of them
X *	(the one at [x,y]).
X */
Xstruct monst *
Xmakemon(ptr,x,y)
Xregister struct permonst *ptr;
X{
X	register struct monst *mtmp;
X	register nleft, deep, ct;
X	boolean anything = (!ptr);
X	int zlevel = dlevel;
X#ifdef BVH
X	if(has_amulet()) zlevel = 40;
X#endif
X	/* if a monster already exists at the position, return */
X	if(x != 0 || y != 0) if(m_at(x,y)) return((struct monst *) 0);
X	if(ptr){
X		/* if you are to make a specific monster and it has 
X		   already been genocided, return */
X		if(index(fut_geno, ptr->mlet)) return((struct monst *) 0);
X	} else {
X		/* make a random (common) monster. */
X		nleft = CMNUM - strlen(fut_geno);
X		if(index(fut_geno, 'm')) nleft++;  /* only 1 minotaur */
X		if(index(fut_geno, '@')) nleft++;
X		if(nleft <= 0)
X		    return((struct monst *) 0);	/* no more monsters! */
X
X		/* determine the strongest monster to make. */
X#ifdef ROCKMOLE
X		deep = rn2(nleft*zlevel/24 + 6);
X#else
X		deep = rn2(nleft*zlevel/24 + 7);
X#endif
X		if(deep < zlevel - 4) deep = rn2(nleft*zlevel/24 + 12);
X		/* if deep is greater than the number of monsters left 
X		   to create, set deep to a random number between half 
X		   the number left and the number left. */
X		if(deep >= nleft) deep = rn1(nleft - nleft/2, nleft/2);
X
X		for(ct = 0 ; ct < CMNUM ; ct++){
X			ptr = &mons[ct];
X			if(index(fut_geno, ptr->mlet)) continue;
X#ifdef KOPS
X			if(ptr->mlet == 'K') {
X# ifdef KJSMODS
X				/* since this is a random monster, make 
X				   a Kobold instead of a Kop. */
X				ptr = &kobold;
X# else
X				deep--;
X# endif
X				continue;
X			}
X#endif /* KOPS /**/
X			if(deep-- <= 0) goto gotmon;
X		}
X		/* this can happen if you are deep in the dungeon and 
X		   mostly weak monsters have been genocided. */
X		return((struct monst *) 0);
X	}
Xgotmon:
X#if defined(KJSMODS) && defined(ROCKMOLE)
X	/* make a giant rat */
X	if((zlevel < 4 && ptr->mlet == 'r')
X	   || (zlevel == 1 && (ptr->mlet == 'h' || ptr->mlet == 'i'))
X	   || (zlevel == 2 && (ptr->mlet == 'o' || ptr->mlet == 'y'))
X	) ptr = &giant_rat;
X#endif
X	mtmp = newmonst(ptr->pxlth);
X	*mtmp = zeromonst;	/* clear all entries in structure */
X	for(ct = 0; ct < ptr->pxlth; ct++)
X		((char *) &(mtmp->mextra[0]))[ct] = 0;
X	mtmp->nmon = fmon;
X	fmon = mtmp;
X	mtmp->m_id = flags.ident++;
X	mtmp->data = ptr;
X	mtmp->mxlth = ptr->pxlth;
X	if(ptr->mlet == 'D') mtmp->mhpmax = mtmp->mhp = 80;
X	else if(!ptr->mlevel) mtmp->mhpmax = mtmp->mhp = rnd(4);
X	else mtmp->mhpmax = mtmp->mhp = d(ptr->mlevel, 8);
X	mtmp->mx = x;
X	mtmp->my = y;
X	mtmp->mcansee = 1;
X	if(ptr->mlet == 'M'){
X		mtmp->mimic = 1;
X		mtmp->mappearance = ']';
X	}
X	if(!in_mklev) {
X		if(x == u.ux && y == u.uy && ptr->mlet != ' ')
X			mnexto(mtmp);
X		if(x == 0 && y == 0)
X			rloc(mtmp);
X	}
X	if(ptr->mlet == 's' || ptr->mlet == 'S') {
X		mtmp->mhide = mtmp->mundetected = 1;
X		if(in_mklev)
X		if(mtmp->mx && mtmp->my)
X			(void) mkobj_at(0, mtmp->mx, mtmp->my);
X	}
X	if(ptr->mlet == ':') {
X#ifdef DGKMOD
X		/* If you're protected with a ring, don't create
X		 * any shape-changing chameleons -dgk
X		 */
X		if (Protection_from_shape_changers)
X			mtmp->cham = 0;
X		else {
X			mtmp->cham = 1;
X			(void) newcham(mtmp,
X				&mons[zlevel+14+rn2(CMNUM-14-zlevel)]);
X		}
X#else
X		mtmp->cham = 1;
X		(void) newcham(mtmp, &mons[zlevel+14+rn2(CMNUM-14-zlevel)]);
X#endif
X	}
X	if(ptr->mlet == 'I' || ptr->mlet == ';')
X		mtmp->minvis = 1;
X	if(ptr->mlet == 'L' || ptr->mlet == 'N'
X	    || (in_mklev && index("&w;", ptr->mlet) && rn2(5))
X	) mtmp->msleep = 1;
X#ifdef HARD
X	if(ptr->mlet == '&' && (Inhell || u.udemigod)) {
X
X		if(!rn2(3 + !Inhell + !u.udemigod)) {
X		    if (rn2(3 + Inhell)) mtmp->data = &d_lord;
X		    else  {
X			mtmp->data = &d_prince;
X			mtmp->mpeaceful = 1;
X			mtmp->minvis = 1;
X		    }
X		}
X#ifdef RPH
X		if(uwep)
X		    if(!strcmp(ONAME(uwep), "Excalibur"))
X			mtmp->mpeaceful = mtmp->mtame = 0;
X#endif
X	}
X#endif /* HARD /**/
X#ifndef NOWORM
X	if(ptr->mlet == 'w' && getwn(mtmp))  initworm(mtmp);
X#endif
X
X	if(anything)
X	    if(ptr->mlet == 'O' || ptr->mlet == 'k'
X#ifdef SAC
X	       || ptr->mlet == '3'
X#endif /* SAC /**/
X				  ) {
X
X		coord mm;
X		register int cnt = rnd(10);
X		mm.x = x;
X		mm.y = y;
X		while(cnt--) {
X			enexto(&mm, mm.x, mm.y);
X			(void) makemon(ptr, mm.x, mm.y);
X		}
X	}
X#ifdef DGKMOD
X	m_initinv(mtmp);
X#endif
X	return(mtmp);
X}
X
X#ifdef DGKMOD
X/* Give some monsters an initial inventory to use */
Xm_initinv(mtmp)
Xstruct monst *mtmp;
X{
X	struct obj *otmp;
X
X	switch (mtmp->data->mlet) {
X# ifdef KAA
X	case '9':
X		if (rn2(2)) {
X			otmp = mksobj(ENORMOUS_ROCK);
X			mpickobj(mtmp, otmp);
X		}
X# endif
X# ifdef SAC
X	case '3':			/* Outfit the troops */
X		if (!rn2(4)) {
X			otmp = mksobj(HELMET);
X			mpickobj(mtmp, otmp); }
X		if (!rn2(4)) {
X			otmp = mksobj(CHAIN_MAIL);
X			mpickobj(mtmp, otmp); }
X		if (!rn2(3)) {
X			otmp = mksobj(DAGGER);
X			mpickobj(mtmp, otmp); }
X		if (!rn2(6)) {
X			otmp = mksobj(SPEAR);
X			mpickobj(mtmp, otmp); }
X		if (!rn2(2)) {
X			otmp = mksobj(TIN);
X			mpickobj(mtmp, otmp); }
X# endif /* SAC /**/
X# ifdef KOPS
X	case 'K':		/* create Keystone Kops with cream pies to
X				 * throw. As suggested by KAA.	   [MRS]
X				 */
X		if (!rn2(4)
X#  ifdef KJSMODS
X  		    && !strcmp(mtmp->data->mname, "Keystone Kop")
X#  endif
X								) {
X			otmp = mksobj(CREAM_PIE);
X			otmp->quan = 2 + rnd(2);
X			otmp->owt = weight(otmp);
X			mpickobj(mtmp, otmp);
X		}
X		break;
X	case 'O':
X# else
X	case 'K':
X# endif
X		if (!rn2(4)) {
X			otmp = mksobj(DART);
X			otmp->quan = 2 + rnd(12);
X			otmp->owt = weight(otmp);
X			mpickobj(mtmp, otmp);
X		}
X		break;
X
X	case 'C':
X		if (rn2(2)) {
X			otmp = mksobj(CROSSBOW);
X			otmp->cursed = rn2(2);
X			mpickobj(mtmp, otmp);
X			otmp = mksobj(CROSSBOW_BOLT);
X			otmp->quan = 2 + rnd(12);
X			otmp->owt = weight(otmp);
X			mpickobj(mtmp, otmp);
X		}
X		break;
X	default:
X		break;
X	}
X}
X#endif
X
Xenexto(cc, xx,yy)
Xcoord	*cc;
Xregister xchar xx,yy;
X{
X	register xchar x,y;
X	coord foo[15], *tfoo;
X	int range, i;
X
X	tfoo = foo;
X	range = 1;
X	do {	/* full kludge action. */
X		for(x = xx-range; x <= xx+range; x++)
X			if(goodpos(x, yy-range)) {
X				tfoo->x = x;
X				(tfoo++)->y = yy-range;
X				if(tfoo == &foo[15]) goto foofull;
X			}
X		for(x = xx-range; x <= xx+range; x++)
X			if(goodpos(x,yy+range)) {
X				tfoo->x = x;
X				(tfoo++)->y = yy+range;
X				if(tfoo == &foo[15]) goto foofull;
X			}
X		for(y = yy+1-range; y < yy+range; y++)
X			if(goodpos(xx-range,y)) {
X				tfoo->x = xx-range;
X				(tfoo++)->y = y;
X				if(tfoo == &foo[15]) goto foofull;
X			}
X		for(y = yy+1-range; y < yy+range; y++)
X			if(goodpos(xx+range,y)) {
X				tfoo->x = xx+range;
X				(tfoo++)->y = y;
X				if(tfoo == &foo[15]) goto foofull;
X			}
X		range++;
X	} while(tfoo == foo);
Xfoofull:
X	i = rn2(tfoo - foo);
X	cc->x = foo[i].x;
X	cc->y = foo[i].y;
X	return(0);
X}
X
Xgoodpos(x,y)	/* used only in mnexto and rloc */
X{
X	return(
X	! (x < 1 || x > COLNO-2 || y < 1 || y > ROWNO-2 ||
X	   m_at(x,y) || !ACCESSIBLE(levl[x][y].typ)
X	   || (x == u.ux && y == u.uy)
X	   || sobj_at(ENORMOUS_ROCK, x, y)
X	));
X}
X
Xrloc(mtmp)
Xstruct monst *mtmp;
X{
X	register tx,ty;
X	register char ch = mtmp->data->mlet;
X
X#ifndef NOWORM
X	if(ch == 'w' && mtmp->mx) return;	/* do not relocate worms */
X#endif
X	do {
X		tx = rn1(COLNO-3,2);
X		ty = rn2(ROWNO);
X	} while(!goodpos(tx,ty));
X	mtmp->mx = tx;
X	mtmp->my = ty;
X	if(u.ustuck == mtmp){
X		if(u.uswallow) {
X			u.ux = tx;
X			u.uy = ty;
X			docrt();
X		} else	u.ustuck = 0;
X	}
X	pmon(mtmp);
X}
X
Xstruct monst *
Xmkmon_at(let,x,y)
Xchar let;
Xregister int x,y;
X{
X	register int ct;
X	register struct permonst *ptr;
X
X	for(ct = 0; ct < CMNUM; ct++) {
X		ptr = &mons[ct];
X		if(ptr->mlet == let)
X			return(makemon(ptr,x,y));
X	}
X	return((struct monst *)0);
X}
END_OF_makemon.c
if test 8401 -ne `wc -c <makemon.c`; then
    echo shar: \"makemon.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f onames.h -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"onames.h\"
else
echo shar: Extracting \"onames.h\" \(8681 characters\)
sed "s/^X//" >onames.h <<'END_OF_onames.h'
X#define	STRANGE_OBJECT	0
X#define	AMULET_OF_YENDOR	1
X#define	FOOD_RATION	2
X#define	TRIPE_RATION	3
X#define	PANCAKE	4
X#define	DEAD_LIZARD	5
X#define	FORTUNE_COOKIE	6
X#define	CARROT	7
X#define	SLICE_OF_PIZZA	8
X#define	CREAM_PIE	9
X#define	TIN	10
X#define	ORANGE	11
X#define	APPLE	12
X#define	PEAR	13
X#define	MELON	14
X#define	BANANA	15
X#define	CANDY_BAR	16
X#define	EGG	17
X#define	CLOVE_OF_GARLIC	18
X#define	LUMP_OF_ROYAL_JELLY	19
X#define	DEAD_HUMAN	20
X#define	DEAD_GIANT_ANT	21
X#define	DEAD_GIANT_BAT	22
X#define	DEAD_CENTAUR	23
X#define	DEAD_DRAGON	24
X#define	DEAD_FLOATING_EYE	25
X#define	DEAD_FREEZING_SPHERE	26
X#define	DEAD_GNOME	27
X#define	DEAD_HOBGOBLIN	28
X#define	DEAD_STALKER	29
X#define	DEAD_JACKAL	30
X#define	DEAD_KOBOLD	31
X#define	DEAD_LEPRECHAUN	32
X#define	DEAD_MIMIC	33
X#define	DEAD_NYMPH	34
X#define	DEAD_ORC	35
X#define	DEAD_PURPLE_WORM	36
X#define	DEAD_QUANTUM_MECHANIC	37
X#define	DEAD_RUST_MONSTER	38
X#define	DEAD_SNAKE	39
X#define	DEAD_TROLL	40
X#define	DEAD_UMBER_HULK	41
X#define	DEAD_VAMPIRE	42
X#define	DEAD_WRAITH	43
X#define	DEAD_XORN	44
X#define	DEAD_YETI	45
X#define	DEAD_ZOMBIE	46
X#define	DEAD_ACID_BLOB	47
X#define	DEAD_GIANT_BEETLE	48
X#define	DEAD_COCKATRICE	49
X#define	DEAD_DOG	50
X#define	DEAD_ETTIN	51
X#define	DEAD_FOG_CLOUD	52
X#define	DEAD_GELATINOUS_CUBE	53
X#define	DEAD_HOMUNCULUS	54
X#define	DEAD_IMP	55
X#define	DEAD_JAGUAR	56
X#define	DEAD_KILLER_BEE	57
X#define	DEAD_LEOCROTTA	58
X#define	DEAD_MINOTAUR	59
X#define	DEAD_NURSE	60
X#define	DEAD_OWLBEAR	61
X#define	DEAD_PIERCER	62
X#define	DEAD_QUIVERING_BLOB	63
X#define	DEAD_GIANT_RAT	64
X#define	DEAD_GIANT_SCORPION	65
X#define	DEAD_TENGU	66
X#define	DEAD_UNICORN	67
X#define	DEAD_VIOLET_FUNGUS	68
X#define	DEAD_LONG_WORM	69
X#define	DEAD_XAN	70
X#define	DEAD_YELLOW_LIGHT	71
X#define	DEAD_ZRUTY	72
X#define	DEAD_SOLDIER	73
X#define	DEAD_GIANT	74
X#define	DEAD_DEMON	75
X#define	ARROW	76
X#define	SLING_BULLET	77
X#define	CROSSBOW_BOLT	78
X#define	DART	79
X#define	SHURIKEN	80
X#define	ROCK	81
X#define	BOOMERANG	82
X#define	MACE	83
X#define	AXE	84
X#define	FLAIL	85
X#define	LONG_SWORD	86
X#define	TWO_HANDED_SWORD	87
X#define	DAGGER	88
X#define	WORM_TOOTH	89
X#define	CRYSKNIFE	90
X#define	AKLYS	91
X#define	BARDICHE	92
X#define	BEC_DE_CORBIN	93
X#define	BILL_GUISARME	94
X#define	CLUB	95
X#define	FAUCHARD	96
X#define	GLAIVE	97
X#define	GUISARME	98
X#define	HALBERD	99
X#define	LUCERN_HAMMER	100
X#define	JAVELIN	101
X#define	KATANA	102
X#define	LANCE	103
X#define	MORNING_STAR	104
X#define	PARTISAN	105
X#define	RANSEUR	106
X#define	SCIMITAR	107
X#define	SPETUM	108
X#define	BROAD_SWORD	109
X#define	SHORT_SWORD	110
X#define	TRIDENT	111
X#define	VOULGE	112
X#define	SPEAR	113
X#define	BOW	114
X#define	SLING	115
X#define	CROSSBOW	116
X#define	WHISTLE	117
X#define	LEASH	118
X#define	MAGIC_WHISTLE	119
X#define	BLINDFOLD	120
X#define	MIRROR	121
X#define	EXPENSIVE_CAMERA	122
X#define	ICE_BOX	123
X#define	PICK_AXE	124
X#define	MAGIC_MARKER	125
X#define	STETHOSCOPE	126
X#define	CAN_OPENER	127
X#define	HEAVY_IRON_BALL	128
X#define	IRON_CHAIN	129
X#define	ENORMOUS_ROCK	130
X#define	HELMET	131
X#define	PLATE_MAIL	132
X#define	SPLINT_MAIL	133
X#define	BANDED_MAIL	134
X#define	CHAIN_MAIL	135
X#define	SCALE_MAIL	136
X#define	RING_MAIL	137
X#define	STUDDED_LEATHER_ARMOR	138
X#define	ELFIN_CHAIN_MAIL	139
X#define	BRONZE_PLATE_MAIL	140
X#define	CRYSTAL_PLATE_MAIL	141
X#define	LEATHER_ARMOR	142
X#define	ELVEN_CLOAK	143
X#define	SHIELD	144
X#define	PAIR_OF_GLOVES	145
X#define	POT_RESTORE_STRENGTH	146
X#define	POT_GAIN_ENERGY	147
X#define	POT_BOOZE	148
X#define	POT_INVISIBILITY	149
X#define	POT_FRUIT_JUICE	150
X#define	POT_HEALING	151
X#define	POT_PARALYSIS	152
X#define	POT_MONSTER_DETECTION	153
X#define	POT_OBJECT_DETECTION	154
X#define	POT_SICKNESS	155
X#define	POT_CONFUSION	156
X#define	POT_GAIN_STRENGTH	157
X#define	POT_SPEED	158
X#define	POT_BLINDNESS	159
X#define	POT_GAIN_LEVEL	160
X#define	POT_EXTRA_HEALING	161
X#define	POT_LEVITATION	162
X#define	POT_HALLUCINATION	163
X#define	POT_HOLY_WATER	164
X#define	SCR_MAIL	167
X#define	SCR_ENCHANT_ARMOR	168
X#define	SCR_DESTROY_ARMOR	169
X#define	SCR_CONFUSE_MONSTER	170
X#define	SCR_SCARE_MONSTER	171
X#define	SCR_BLANK_PAPER	172
X#define	SCR_REMOVE_CURSE	173
X#define	SCR_ENCHANT_WEAPON	174
X#define	SCR_DAMAGE_WEAPON	175
X#define	SCR_CREATE_MONSTER	176
X#define	SCR_TAMING	177
X#define	SCR_GENOCIDE	178
X#define	SCR_LIGHT	179
X#define	SCR_TELEPORTATION	180
X#define	SCR_GOLD_DETECTION	181
X#define	SCR_FOOD_DETECTION	182
X#define	SCR_IDENTIFY	183
X#define	SCR_MAGIC_MAPPING	184
X#define	SCR_AMNESIA	185
X#define	SCR_FIRE	186
X#define	SCR_PUNISHMENT	187
X#define	WAN_LIGHT	192
X#define	WAN_SECRET_DOOR_DETECTION	193
X#define	WAN_CREATE_MONSTER	194
X#define	WAN_WISHING	195
X#define	WAN_STRIKING	196
X#define	WAN_NOTHING	197
X#define	WAN_SLOW_MONSTER	198
X#define	WAN_SPEED_MONSTER	199
X#define	WAN_UNDEAD_TURNING	200
X#define	WAN_POLYMORPH	201
X#define	WAN_CANCELLATION	202
X#define	WAN_TELEPORTATION	203
X#define	WAN_MAKE_INVISIBLE	204
X#define	WAN_PROBING	205
X#define	WAN_DIGGING	206
X#define	WAN_MAGIC_MISSILE	207
X#define	WAN_FIRE	208
X#define	WAN_SLEEP	209
X#define	WAN_COLD	210
X#define	WAN_DEATH	211
X#define	SPE_MAGIC_MISSILE	214
X#define	SPE_FIREBALL	215
X#define	SPE_SLEEP	216
X#define	SPE_CONE_OF_COLD	217
X#define	SPE_FINGER_OF_DEATH	218
X#define	SPE_HEALING	219
X#define	SPE_DETECT_MONSTERS	220
X#define	SPE_FORCE_BOLT	221
X#define	SPE_LIGHT	222
X#define	SPE_CONFUSE_MONSTER	223
X#define	SPE_CURE_BLINDNESS	224
X#define	SPE_SLOW_MONSTER	225
X#define	SPE_CREATE_MONSTER	226
X#define	SPE_DETECT_FOOD	227
X#define	SPE_HASTE_SELF	228
X#define	SPE_CAUSE_FEAR	229
X#define	SPE_CURE_SICKNESS	230
X#define	SPE_DETECT_UNSEEN	231
X#define	SPE_EXTRA_HEALING	232
X#define	SPE_CHARM_MONSTER	233
X#define	SPE_LEVITATION	234
X#define	SPE_RESTORE_STRENGTH	235
X#define	SPE_INVISIBILITY	236
X#define	SPE_DETECT_TREASURE	237
X#define	SPE_DIG	238
X#define	SPE_REMOVE_CURSE	239
X#define	SPE_MAGIC_MAPPING	240
X#define	SPE_IDENTIFY	241
X#define	SPE_TURN_UNDEAD	242
X#define	SPE_POLYMORPH	243
X#define	SPE_CREATE_FAMILIAR	244
X#define	SPE_TELEPORT_AWAY	245
X#define	SPE_CANCELLATION	246
X#define	SPE_GENOCIDE	247
X#define	Adornment	u.uprops[0].p_flgs
X#define	RIN_ADORNMENT	252
X#define	HTeleportation	u.uprops[1].p_flgs
X#define	Teleportation	((HTeleportation) || index("LNt", u.usym))
X#define	RIN_TELEPORTATION	253
X#define	HRegeneration	u.uprops[2].p_flgs
X#define	Regeneration	((HRegeneration) || index("TVi", u.usym))
X#define	RIN_REGENERATION	254
X#define	Searching	u.uprops[3].p_flgs
X#define	RIN_SEARCHING	255
X#define	HSee_invisible	u.uprops[4].p_flgs
X#define	See_invisible	((HSee_invisible) || index("I", u.usym))
X#define	RIN_SEE_INVISIBLE	256
X#define	Stealth	u.uprops[5].p_flgs
X#define	RIN_STEALTH	257
X#define	Levitation	u.uprops[6].p_flgs
X#define	RIN_LEVITATION	258
X#define	HPoison_resistance	u.uprops[7].p_flgs
X#define	Poison_resistance	((HPoison_resistance) || index("abcghikqsuvxyADFQSVWXZ&", u.usym))
X#define	RIN_POISON_RESISTANCE	259
X#define	Aggravate_monster	u.uprops[8].p_flgs
X#define	RIN_AGGRAVATE_MONSTER	260
X#define	Hunger	u.uprops[9].p_flgs
X#define	RIN_HUNGER	261
X#define	HFire_resistance	u.uprops[10].p_flgs
X#define	Fire_resistance	((HFire_resistance) || index("gD&", u.usym))
X#define	RIN_FIRE_RESISTANCE	262
X#define	HCold_resistance	u.uprops[11].p_flgs
X#define	Cold_resistance	((HCold_resistance) || index("gFY", u.usym))
X#define	RIN_COLD_RESISTANCE	263
X#define	Protection_from_shape_changers	u.uprops[12].p_flgs
X#define	RIN_PROTECTION_FROM_SHAPE_CHAN	264
X#define	Conflict	u.uprops[13].p_flgs
X#define	RIN_CONFLICT	265
X#define	Gain_strength	u.uprops[14].p_flgs
X#define	RIN_GAIN_STRENGTH	266
X#define	Increase_damage	u.uprops[15].p_flgs
X#define	RIN_INCREASE_DAMAGE	267
X#define	Protection	u.uprops[16].p_flgs
X#define	RIN_PROTECTION	268
X#define	Warning	u.uprops[17].p_flgs
X#define	RIN_WARNING	269
X#define	HTeleport_control	u.uprops[18].p_flgs
X#define	Teleport_control	((HTeleport_control) || index("t", u.usym))
X#define	RIN_TELEPORT_CONTROL	270
X#define	Polymorph	u.uprops[19].p_flgs
X#define	RIN_POLYMORPH	271
X#define	Polymorph_control	u.uprops[20].p_flgs
X#define	RIN_POLYMORPH_CONTROL	272
X#define	DILITHIUM_CRYSTAL	275
X#define	DIAMOND	276
X#define	RUBY	277
X#define	SAPPHIRE	278
X#define	EMERALD	279
X#define	TURQUOISE	280
X#define	AQUAMARINE	281
X#define	TOURMALINE	282
X#define	TOPAZ	283
X#define	OPAL	284
X#define	GARNET	285
X#define	AMETHYST	286
X#define	AGATE	287
X#define	ONYX	288
X#define	JASPER	289
X#define	JADE	290
X/* #define	WORTHLESS_PIECE_OF_BLUE_GLASS	291 */
X/* #define	WORTHLESS_PIECE_OF_RED_GLASS	292 */
X/* #define	WORTHLESS_PIECE_OF_YELLOW_GLASS	293 */
X/* #define	WORTHLESS_PIECE_OF_GREEN_GLASS	294 */
X
X#define	CORPSE		DEAD_HUMAN
X#define	DEAD_KOP		DEAD_KOBOLD
X#define	DEAD_GIANT_SPIDER	DEAD_GIANT_SCORPION
X#define	DEAD_ROCKMOLE		DEAD_GIANT_RAT
X#define	LAST_GEM	(JADE+1)
X#define	LAST_RING	21
X#define MAXSPELL	35
X#define	NROFOBJECTS	294
END_OF_onames.h
if test 8681 -ne `wc -c <onames.h`; then
    echo shar: \"onames.h\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f unixtty.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"unixtty.c\"
else
echo shar: Extracting \"unixtty.c\" \(8711 characters\)
sed "s/^X//" >unixtty.c <<'END_OF_unixtty.c'
X/*	SCCS Id: @(#)unixtty.c	2.1	87/11/09
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* tty.c - (Unix) version */
X
X/* With thanks to the people who sent code for SYSV - hpscdi!jon,
X * arnold@ucsf-cgl, wcs@bo95b, cbcephus!pds and others.
X */
X
X#include	<stdio.h>
X#include	"extern.h"
X#include	"hack.h"
X#include	"func_tab.h"
X
X#define	ON	1
X#define OFF	0
X
X/*
X * The distinctions here are not BSD - rest but rather USG - rest, as
X * BSD still has the old sgttyb structure, but SYSV has termio. Thus:
X */
X#ifdef BSD
X#define	V7
X#else
X#define USG
X#endif
X
X/*
X * Some systems may have getchar() return EOF for various reasons, and
X * we should not quit before seeing at least NR_OF_EOFS consecutive EOFs.
X */
X#ifndef BSD
X#define	NR_OF_EOFS	20
X#endif
X
X
X#ifdef USG
X
X#include	<termio.h>
X#define termstruct	termio
X#define kill_sym	c_cc[VKILL]
X#define erase_sym	c_cc[VERASE]
X#define EXTABS		TAB3
X#define tabflgs		c_oflag
X#define echoflgs	c_lflag
X#define cbrkflgs	c_lflag
X#define CBRKMASK	ICANON
X#define CBRKON		! /* reverse condition */
X#define OSPEED(x)	((x).c_cflag & CBAUD)
X#define GTTY(x)		(ioctl(0, TCGETA, x))
X/* STTY now modified to run under Sys V R3.	- may have to be #ifdef'ed */
X#define STTY(x)		(ioctl(0, TCSETAW, x))	/* TCSETAF? TCSETAW? */
X
X#else	/* V7 */
X
X#include	<sgtty.h>
X#define termstruct	sgttyb
X#define	kill_sym	sg_kill
X#define	erase_sym	sg_erase
X#define EXTABS		XTABS
X#define tabflgs		sg_flags
X#define echoflgs	sg_flags
X#define cbrkflgs	sg_flags
X#define CBRKMASK	CBREAK
X#define CBRKON		/* empty */
X#define OSPEED(x)	(x).sg_ospeed
X#define GTTY(x)		(gtty(0, x))
X#define STTY(x)		(stty(0, x))
X
X#endif
X
Xextern short ospeed;
Xstatic char erase_char, kill_char;
Xstatic boolean settty_needed = FALSE;
Xstruct termstruct inittyb, curttyb;
X
X/*
X * Get initial state of terminal, set ospeed (for termcap routines)
X * and switch off tab expansion if necessary.
X * Called by startup() in termcap.c and after returning from ! or ^Z
X */
Xgettty(){
X	if(GTTY(&inittyb) < 0)
X		perror("Hack (gettty)");
X	curttyb = inittyb;
X	ospeed = OSPEED(inittyb);
X	erase_char = inittyb.erase_sym;
X	kill_char = inittyb.kill_sym;
X	getioctls();
X
X	/* do not expand tabs - they might be needed inside a cm sequence */
X	if(curttyb.tabflgs & EXTABS) {
X		curttyb.tabflgs &= ~EXTABS;
X		setctty();
X	}
X	settty_needed = TRUE;
X}
X
X/* reset terminal to original state */
Xsettty(s) char *s; {
X	clear_screen();
X	end_screen();
X	if(s) printf(s);
X	(void) fflush(stdout);
X	if(STTY(&inittyb) < 0)
X		perror("Hack (settty)");
X	flags.echo = (inittyb.echoflgs & ECHO) ? ON : OFF;
X	flags.cbreak = (CBRKON(inittyb.cbrkflgs & CBRKMASK)) ? ON : OFF;
X	setioctls();
X}
X
Xsetctty(){
X	if(STTY(&curttyb) < 0)
X		perror("Hack (setctty)");
X}
X
X
Xsetftty(){
Xregister int ef = 0;			/* desired value of flags & ECHO */
Xregister int cf = CBRKON(CBRKMASK);	/* desired value of flags & CBREAK */
Xregister int change = 0;
X	flags.cbreak = ON;
X	flags.echo = OFF;
X	/* Should use (ECHO|CRMOD) here instead of ECHO */
X	if((curttyb.echoflgs & ECHO) != ef){
X		curttyb.echoflgs &= ~ECHO;
X/*		curttyb.echoflgs |= ef;					*/
X		change++;
X	}
X	if((curttyb.cbrkflgs & CBRKMASK) != cf){
X		curttyb.cbrkflgs &= ~CBRKMASK;
X		curttyb.cbrkflgs |= cf;
X#ifdef USG
X		/* be satisfied with one character; no timeout */
X		curttyb.c_cc[VMIN] = 1;		/* was VEOF */
X		curttyb.c_cc[VTIME] = 0;	/* was VEOL */
X#endif
X		change++;
X	}
X	if(change){
X		setctty();
X	}
X	start_screen();
X}
X
X
X/* fatal error */
X/*VARARGS1*/
Xerror(s,x,y) char *s; {
X	if(settty_needed)
X		settty((char *) 0);
X	printf(s,x,y);
X	putchar('\n');
X	exit(1);
X}
X
X/*
X * Read a line closed with '\n' into the array char bufp[BUFSZ].
X * (The '\n' is not stored. The string is closed with a '\0'.)
X * Reading can be interrupted by an escape ('\033') - now the
X * resulting string is "\033".
X */
Xgetlin(bufp)
Xregister char *bufp;
X{
X	register char *obufp = bufp;
X	register int c;
X
X	flags.toplin = 2;		/* nonempty, no --More-- required */
X	for(;;) {
X		(void) fflush(stdout);
X		if((c = getchar()) == EOF) {
X			*bufp = 0;
X			return;
X		}
X		if(c == '\033') {
X			*obufp = c;
X			obufp[1] = 0;
X			return;
X		}
X		if(c == erase_char || c == '\b') {
X			if(bufp != obufp) {
X				bufp--;
X				putstr("\b \b"); /* putsym converts \b */
X			} else	bell();
X		} else if(c == '\n') {
X			*bufp = 0;
X			return;
X		} else if(' ' <= c && c < '\177') {
X				/* avoid isprint() - some people don't have it
X				   ' ' is not always a printing char */
X			*bufp = c;
X			bufp[1] = 0;
X			putstr(bufp);
X			if(bufp-obufp < BUFSZ-1 && bufp-obufp < COLNO)
X				bufp++;
X		} else if(c == kill_char || c == '\177') { /* Robert Viduya */
X				/* this test last - @ might be the kill_char */
X			while(bufp != obufp) {
X				bufp--;
X				putstr("\b \b");
X			}
X		} else
X			bell();
X	}
X}
X
Xgetret() {
X	cgetret("");
X}
X
Xcgetret(s)
Xregister char *s;
X{
X	putsym('\n');
X	if(flags.standout)
X		standoutbeg();
X	putstr("Hit ");
X	putstr(flags.cbreak ? "space" : "return");
X	putstr(" to continue: ");
X	if(flags.standout)
X		standoutend();
X	xwaitforspace(s);
X}
X
Xchar morc;	/* tell the outside world what char he used */
X
Xxwaitforspace(s)
Xregister char *s;	/* chars allowed besides space or return */
X{
Xregister int c;
X
X	morc = 0;
X
X	while((c = readchar()) != '\n') {
X	    if(flags.cbreak) {
X		if(c == ' ') break;
X		if(s && index(s,c)) {
X			morc = c;
X			break;
X		}
X		bell();
X	    }
X	}
X}
X
Xstatic int last_multi;
X
Xchar *
Xparse()
X{
X	static char inline[COLNO];
X	register foo;
X
X	multi = 0;
X	flags.move = 1;
X	if(!Invisible) curs_on_u(); else home();
X	while((foo = readchar()) >= '0' && foo <= '9') {
X		multi = 10*multi+foo-'0';
X#ifdef DGKMOD
X		if (multi < 0 || multi > LARGEST_INT)
X			multi = LARGEST_INT;
X		if (multi > 9) {
X			remember_topl();
X			home();
X			cl_end();
X			printf("Count: %d", multi);
X		}
X#endif
X		last_multi = multi;
X	}
X# ifdef REDO
X	if (foo == DOAGAIN || in_doagain)
X		multi = last_multi;
X	else {
X		savech(0);	/* reset input queue */
X		savech(foo);
X	}
X# endif
X	if(multi) {
X		multi--;
X		save_cm = inline;
X	}
X	inline[0] = foo;
X	inline[1] = 0;
X	if(foo == 'g' || foo == 'G'){
X		inline[1] = getchar();
X#ifdef QUEST
X		if(inline[1] == foo) inline[2] = getchar(); else
X#endif
X		inline[2] = 0;
X	}
X	if(foo == 'm' || foo == 'M'){
X		inline[1] = getchar();
X		inline[2] = 0;
X	}
X	clrlin();
X	return(inline);
X}
X
Xchar
Xreadchar() {
X	register int sym;
X
X	(void) fflush(stdout);
X	if((sym = getchar()) == EOF)
X#ifdef NR_OF_EOFS
X	{ /*
X	   * Some SYSV systems seem to return EOFs for various reasons
X	   * (?like when one hits break or for interrupted systemcalls?),
X	   * and we must see several before we quit.
X	   */
X		register int cnt = NR_OF_EOFS;
X		while (cnt--) {
X		    clearerr(stdin);	/* omit if clearerr is undefined */
X		    if((sym = getchar()) != EOF) goto noteof;
X		}
X		end_of_input();
X	     noteof:	;
X	}
X#else
X		end_of_input();
X#endif /* NR_OF_EOFS /**/
X	if(flags.toplin == 1)
X		flags.toplin = 2;
X	return((char) sym);
X}
X
Xend_of_input()
X{
X	settty("End of input?\n");
X	clearlocks();
X	exit(0);
X}
X
X#ifdef COM_COMPL
X/* Read in an extended command - doing command line completion for
X * when enough character have been entered to make a unique command.
X * This is just a modified getlin().   -jsb
X */
Xget_ext_cmd(bufp)
Xregister char *bufp;
X{
X	register char *obufp = bufp;
X	register int c;
X	int com_index, index;
X
X	flags.toplin = 2;		/* nonempty, no --More-- required */
X
X	for(;;) {
X		(void) fflush(stdout);
X		if((c = readchar()) == EOF) {
X			*bufp = 0;
X			return;
X		}
X		if(c == '\033') {
X			*obufp = c;
X			obufp[1] = 0;
X			return;
X		}
X		if(c == erase_char || c == '\b') {
X			if(bufp != obufp) {
X				bufp--;
X				putstr("\b \b"); /* putsym converts \b */
X			} else	bell();
X		} else if(c == '\n') {
X			*bufp = 0;
X			return;
X		} else if(' ' <= c && c < '\177') {
X				/* avoid isprint() - some people don't have it
X				   ' ' is not always a printing char */
X			*bufp = c;
X			bufp[1] = 0;
X			index = 0;
X			com_index = -1;
X
X			while(extcmdlist[index].ef_txt != (char *) 0){
X				if(!strncmp(obufp, extcmdlist[index].ef_txt,
X				strlen(obufp)))
X					if(com_index == -1) /* No matches yet*/
X					    com_index = index;
X					else /* More than 1 match */
X					    com_index = -2;
X				index++;
X			}
X			if(com_index >= 0){
X				strcpy(obufp,
X				extcmdlist[com_index].ef_txt);
X				/* finish print our string */
X				putstr(bufp);
X				bufp = obufp; /* reset it */
X				if(strlen(obufp) < BUFSIZ-1 &&
X				 strlen(obufp) < COLNO)
X					/* set bufp at the end of our
X					 * string
X					 */
X					bufp += strlen(obufp);
X			} else {
X				putstr(bufp);
X				if(bufp-obufp < BUFSZ-1 && bufp-obufp < COLNO)
X					bufp++;
X			}
X		} else if(c == kill_char || c == '\177') { /* Robert Viduya */
X				/* this test last - @ might be the kill_char */
X			while(bufp != obufp) {
X				bufp--;
X				putstr("\b \b");
X			}
X		} else
X			bell();
X	}
X
X}
X#endif COM_COMPL
END_OF_unixtty.c
if test 8711 -ne `wc -c <unixtty.c`; then
    echo shar: \"unixtty.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
echo shar: End of archive 15 \(of 20\).
cp /dev/null ark15isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 20 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
