Relay-Version: version B 2.10 5/3/83; site utzoo.UUCP
Path: utzoo!mnetor!uunet!husc6!mit-eddie!uw-beaver!tektronix!tekgen!tekred!games-request
From: games-request@tekred.TEK.COM
Newsgroups: comp.sources.games
Subject: v03i019:  NetHack2.2 - display oriented dungeons and dragons, Part19/20
Message-ID: <1906@tekred.TEK.COM>
Date: Thu, 3-Dec-87 11:58:24 EST
Article-I.D.: tekred.1906
Posted: Thu Dec  3 11:58:24 1987
Date-Received: Thu, 10-Dec-87 04:41:24 EST
Sender: billr@tekred.TEK.COM
Lines: 1997
Approved: billr@tekred.TEK.COM

Submitted by: mike@genat.UUCP (Mike Stephenson)
Comp.sources.games: Volume 3, Issue 19
Archive-name: nethack2.2/Part19



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 19 (of 20)."
# Contents:  alloc.c bones.c flag.h monst.c nansi.sys.uu pcunix.c rm.h
#   rumors.c rumors.kaa search.c sit.c timeout.c topl.c wield.c you.h
# Wrapped by billr@tekred on Tue Dec  1 16:25:17 1987
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f alloc.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"alloc.c\"
else
echo shar: Extracting \"alloc.c\" \(865 characters\)
sed "s/^X//" >alloc.c <<'END_OF_alloc.c'
X/*	SCCS Id: @(#)alloc.c	1.4	87/08/08
X/* alloc.c - version 1.0.2 */
X#ifdef LINT
X
X/*
X   a ridiculous definition, suppressing
X	"possible pointer alignment problem" for (long *) malloc()
X	"enlarg defined but never used"
X	"ftell defined (in <stdio.h>) but never used"
X   from lint
X*/
X#include <stdio.h>
Xlong *
Xalloc(n) unsigned n; {
Xlong dummy = ftell(stderr);
X	if(n) dummy = 0;	/* make sure arg is used */
X	return(&dummy);
X}
X
X#else
X
Xextern char *malloc();
Xextern char *realloc();
X
Xlong *
Xalloc(lth)
Xregister unsigned lth;
X{
X	register char *ptr;
X
X	if(!(ptr = malloc(lth)))
X		panic("Cannot get %d bytes", lth);
X	return((long *) ptr);
X}
X
X#ifndef DGK
Xlong *
Xenlarge(ptr,lth)
Xregister char *ptr;
Xregister unsigned lth;
X{
X	register char *nptr;
X
X	if(!(nptr = realloc(ptr,lth)))
X		panic("Cannot reallocate %d bytes", lth);
X	return((long *) nptr);
X}
X#endif
X
X#endif /* LINT /**/
END_OF_alloc.c
if test 865 -ne `wc -c <alloc.c`; then
    echo shar: \"alloc.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f bones.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"bones.c\"
else
echo shar: Extracting \"bones.c\" \(3830 characters\)
sed "s/^X//" >bones.c <<'END_OF_bones.c'
X/*	SCCS Id: @(#)bones.c	1.4	87/08/08
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* bones.c - version 1.0.3 */
X
X#include "hack.h"
Xextern char plname[PL_NSIZ];
Xextern long somegold();
Xextern struct monst *makemon();
Xextern struct permonst pm_ghost;
X
X#ifdef DGK
Xchar bones[FILENAME];
X#else
Xchar bones[] = "bones_xx";
X#endif
X
X/* save bones and possessions of a deceased adventurer */
Xsavebones(){
Xregister fd;
Xregister struct obj *otmp;
Xregister struct trap *ttmp;
Xregister struct monst *mtmp;
X	if(dlevel <= 0 || dlevel > MAXLEVEL) return;
X	if(!rn2(1 + dlevel/2)	/* not so many ghosts on low levels */
X#ifdef WIZARD
X		&& !wizard
X#endif
X		) return;
X#ifdef DGK
X	name_file(bones, dlevel);
X#else
X	bones[6] = '0' + (dlevel/10);
X	bones[7] = '0' + (dlevel%10);
X#endif
X	if((fd = open(bones,0)) >= 0){
X		(void) close(fd);
X#ifdef WIZARD
X		if(wizard)
X			pline("Bones file already exists.");
X#endif
X		return;
X	}
X	/* drop everything; the corpse's possessions are usually cursed */
X	otmp = invent;
X	while(otmp){
X		otmp->ox = u.ux;
X		otmp->oy = u.uy;
X		otmp->age = 0;		/* very long ago */
X		otmp->owornmask = 0;
X		if(rn2(5)) otmp->cursed = 1;
X		if(!otmp->nobj){
X			otmp->nobj = fobj;
X			fobj = invent;
X			invent = 0;	/* superfluous */
X			break;
X		}
X		otmp = otmp->nobj;
X	}
X	/* spill any contained objects - added by GAN 03/23/87 */
X	otmp = fcobj;
X	while(otmp)  {
X		register struct obj *otmp2;
X
X		otmp2 = otmp->nobj;
X		spill_obj(otmp);
X		otmp = otmp2;
X	}
X	if(!(mtmp = makemon(PM_GHOST, u.ux, u.uy))) return;
X	mtmp->mx = u.ux;
X	mtmp->my = u.uy;
X	mtmp->msleep = 1;
X	(void) strcpy((char *) mtmp->mextra, plname);
X	mkgold(somegold() + d(dlevel,30), u.ux, u.uy);
X	for(mtmp = fmon; mtmp; mtmp = mtmp->nmon){
X		mtmp->m_id = 0;
X		if(mtmp->mtame) {
X			mtmp->mtame = 0;
X			mtmp->mpeaceful = 0;
X		}
X		mtmp->mlstmv = 0;
X		if(mtmp->mdispl) unpmon(mtmp);
X	}
X	for(ttmp = ftrap; ttmp; ttmp = ttmp->ntrap)
X		ttmp->tseen = 0;
X	for(otmp = fobj; otmp; otmp = otmp->nobj) {
X		otmp->o_id = 0;
X	     /* otmp->o_cnt_id = 0; - superfluous */
X		otmp->onamelth = 0;
X		otmp->known = 0;
X		otmp->invlet = 0;
X		if(otmp->olet == AMULET_SYM && !otmp->spe) {
X			otmp->spe = -1;      /* no longer the actual amulet */
X			otmp->cursed = 1;    /* flag as gotten from a ghost */
X		}
X	}
X#ifdef DGK
X	fd = open(bones, O_WRONLY | O_BINARY | O_CREAT, FMASK);
X#else
X	fd = creat(bones, FMASK);
X#endif
X	if(fd < 0) {
X#ifdef WIZARD
X		if(wizard)
X			pline("Cannot create bones file - creat failed");
X#endif
X		return;
X	}
X#ifdef DGK
X	savelev(fd,dlevel, COUNT | WRITE);
X#else
X	savelev(fd,dlevel);
X#endif
X	(void) close(fd);
X}
X
X/*
X * "spill" object out of box onto floor
X */
Xspill_obj(obj)
Xstruct obj *obj;
X{
X	struct obj *otmp;
X
X	for(otmp = fobj; otmp; otmp = otmp->nobj)
X		if(obj->o_cnt_id == otmp->o_id)  {
X			obj->ox = otmp->ox;
X			obj->oy = otmp->oy;
X			obj->age = 0;
X			if(rn2(5))
X				obj->cursed = 1;
X			obj->nobj = otmp->nobj;
X			otmp->nobj = obj;
X			return;
X		}
X}
X		
Xgetbones(){
Xregister fd,x,y,ok;
X	/* wizard check added by GAN 02/05/87 */
X	if(rn2(3)	/* only once in three times do we find bones */
X#ifdef WIZARD
X		&& !wizard
X#endif
X		) return(0);
X#ifdef DGK
X	name_file(bones, dlevel);
X#else
X	bones[6] = '0' + dlevel/10;
X	bones[7] = '0' + dlevel%10;
X#endif
X	if((fd = open(bones, 0)) < 0) return(0);
X	if((ok = uptodate(fd)) != 0){
X#ifdef WIZARD
X		if(wizard)  {
X			char buf[BUFSZ];
X			pline("Get bones? ");
X			getlin(buf);
X			if(buf[0] == 'n')  {
X				(void) close(fd);
X				return(0);
X			}
X		}
X#endif
X		getlev(fd, 0, dlevel);
X		for(x = 0; x < COLNO; x++) for(y = 0; y < ROWNO; y++)
X			levl[x][y].seen = levl[x][y].new = 0;
X	}
X	(void) close(fd);
X#ifdef WIZARD
X	if(wizard)  {
X		char buf[BUFSZ];
X		pline("Unlink bones? ");
X		getlin(buf);
X		if(buf[0] == 'n')
X			return(ok);
X	}
X#endif
X	if(unlink(bones) < 0){
X		pline("Cannot unlink %s .", bones);
X		return(0);
X	}
X	return(ok);
X}
END_OF_bones.c
if test 3830 -ne `wc -c <bones.c`; then
    echo shar: \"bones.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f flag.h -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"flag.h\"
else
echo shar: Extracting \"flag.h\" \(2142 characters\)
sed "s/^X//" >flag.h <<'END_OF_flag.h'
X/*	SCCS Id: @(#)flag.h	1.4	87/08/08
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* flag.h - version 1.0.3 */
X
Xstruct flag {
X	unsigned ident;		/* social security number for each monster */
X	unsigned debug;		/* in debugging mode */
X#define	wizard	flags.debug
X	unsigned toplin;	/* a top line (message) has been printed */
X				/* 0: top line empty; 2: no --More-- reqd. */
X	unsigned cbreak;	/* in cbreak mode, rogue format */
X	unsigned standout;	/* use standout for --More-- */
X	unsigned nonull;	/* avoid sending nulls to the terminal */
X	unsigned time;		/* display elapsed 'time' */
X	unsigned nonews;	/* suppress news printing */
X	unsigned notombstone;
X	unsigned end_top, end_around;	/* describe desired score list */
X	unsigned end_own;		/* idem (list all own scores) */
X	unsigned no_rest_on_space;	/* spaces are ignored */
X	unsigned beginner;
X	unsigned female;
X	unsigned invlet_constant;	/* let objects keep their
X					   inventory symbol */
X	unsigned move;
X	unsigned mv;
X	unsigned run;		/* 0: h (etc), 1: H (etc), 2: fh (etc) */
X				/* 3: FH, 4: ff+, 5: ff-, 6: FF+, 7: FF- */
X	unsigned nopick;	/* do not pickup objects */
X	unsigned echo;		/* 1 to echo characters */
X	unsigned botl;		/* partially redo status line */
X	unsigned botlx;		/* print an entirely new bottom line */
X	unsigned nscrinh;	/* inhibit nscr() in pline(); */
X	unsigned made_amulet;
X	unsigned no_of_wizards;	/* 0, 1 or 2 (wizard and his shadow) */
X				/* reset from 2 to 1, but never to 0 */
X	unsigned moonphase;
X#define	NEW_MOON	0
X#define	FULL_MOON	4
X
X#ifdef SORTING
X	unsigned sortpack;	/* sorted inventory */
X#endif
X#ifdef SAFE_ATTACK
X	unsigned confirm;	/* confirm before hitting tame monsters */
X#endif
X#ifdef DGKMOD
X	unsigned silent;	/* whether the bell rings or not */
X	unsigned pickup;	/* whether you pickup or move and look */
X#endif
X#ifdef DGK
X	unsigned IBMBIOS;	/* whether we can use a BIOS call for
X				 * redrawing the screen and character input */
X	unsigned DECRainbow;	/* Used for DEC Rainbow graphics. */
X	unsigned rawio;		/* Whether can use rawio (IOCTL call) */
X	unsigned extra1;
X	unsigned extra2;
X#endif
X};
X
Xextern struct flag flags;
END_OF_flag.h
if test 2142 -ne `wc -c <flag.h`; then
    echo shar: \"flag.h\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f monst.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"monst.c\"
else
echo shar: Extracting \"monst.c\" \(4089 characters\)
sed "s/^X//" >monst.c <<'END_OF_monst.c'
X/*	SCCS Id: @(#)monst.c	2.2	87/11/29
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X
X#include "hack.h"
X#include "eshk.h"
Xextern char plname[PL_NSIZ];
X
Xstruct permonst mons[CMNUM+2] = {
X	{ "bat",		'B',  1, 22, 8,  0, 1,  4, 0 },
X	{ "gnome",		'G',  1,  6, 5,  0, 1,  6, 0 },
X	{ "hobgoblin",		'H',  1,  9, 5,  0, 1,  8, 0 },
X	{ "jackal",		'J',  0, 12, 7,  0, 1,  2, 0 },
X#ifdef KOPS
X	{ "Keystone Kop",       'K',  1,  6, 7, 10, 1,  4, 0 },
X#else
X	{ "kobold",		'K',  1,  6, 7,  0, 1,  4, 0 },
X#endif
X#ifndef ROCKMOLE
X	{ "giant rat",		'r',  0, 12, 7,  0, 1,  3, 0 },
X#endif
X	{ "acid blob",		'a',  2,  3, 8,  0, 0,  0, 0 },
X	{ "floating eye",	'E',  2,  1, 9, 10, 0,  0, 0 },
X	{ "homunculus",		'h',  2,  6, 6, 10, 1,  3, 0 },
X	{ "imp",		'i',  2,  6, 2, 20, 1,  4, 0 },
X	{ "leprechaun",		'L',  5, 15, 8, 20, 1,  2, 0 },
X	{ "orc",		'O',  2,  9, 6,  0, 1,  8, 0 },
X	{ "yellow light",	'y',  3, 15, 0,  0, 0,  0, 0 },
X	{ "zombie",		'Z',  2,  6, 8,  0, 1,  8, 0 },
X	{ "giant ant",		'A',  3, 18, 3,  0, 1,  6, 0 },
X#ifdef ROCKMOLE
X	{ "rock mole",          'r',  3,  3, 0, 20, 1,  6, 0 },
X#endif
X	{ "fog cloud",		'f',  3,  1, 0,  0, 1,  6, 0 },
X	{ "nymph",		'N',  6, 12, 9, 20, 1,  2, 0 },
X	{ "piercer",		'p',  3,  1, 3,  0, 2,  6, 0 },
X#ifdef KAA
X	{ "quantum mechanic",	'Q',  6, 12, 3, 10, 1,  4, 0 },
X#else
X	{ "quasit",		'Q',  3, 15, 3, 20, 1,  4, 0 },
X#endif
X	{ "quivering blob",	'q',  3,  1, 8,  0, 1,  8, 0 },
X#ifdef KAA
X	{ "violet fungus",	'v',  3,  1, 7,  0, 1,  4, 0 },
X#else
X	{ "violet fungi",	'v',  3,  1, 7,  0, 1,  4, 0 },
X#endif
X	{ "giant beetle",	'b',  4,  6, 4,  0, 3,  4, 0 },
X	{ "centaur",		'C',  4, 18, 4, 10, 1,  6, 0 },
X	{ "cockatrice",		'c',  4,  6, 6, 30, 1,  3, 0 },
X	{ "gelatinous cube",	'g',  4,  6, 8,  0, 2,  4, 0 },
X	{ "jaguar",		'j',  4, 15, 6,  0, 1,  8, 0 },
X	{ "killer bee",		'k',  4, 14, 4,  0, 2,  4, 0 },
X	{ "snake",		'S',  4, 15, 3,  0, 1,  6, 0 },
X	{ "freezing sphere",	'F',  2, 13, 4,  0, 0,  0, 0 },
X	{ "owlbear",		'o',  5, 12, 5,  0, 2,  6, 0 },
X	{ "rust monster",	'R', 10, 18, 3,  0, 0,  0, 0 },
X#ifdef SPIDERS
X	{ "giant spider",	's',  5, 15, 3,  0, 1,  4, 0 },
X#else
X	{ "scorpion",		's',  5, 15, 3,  0, 1,  4, 0 },
X#endif
X	{ "tengu",		't',  5, 13, 5, 30, 1,  7, 0 },
X	{ "wraith",		'W',  5, 12, 5, 15, 1,  6, 0 },
X#ifdef NOWORM
X	{ "wumpus",		'w',  8,  3, 2, 10, 3,  6, 0 },
X#else
X	{ "long worm",		'w',  8,  3, 5, 10, 1,  4, 0 },
X#endif
X	{ "large dog",		'd',  6, 15, 4,  0, 2,  4, 0 },
X	{ "leocrotta",		'l',  6, 18, 4, 10, 3,  6, 0 },
X	{ "mimic",		'M',  7,  3, 7,  0, 3,  4, 0 },
X	{ "troll",		'T',  7, 12, 4,  0, 2,  7, 0 },
X	{ "unicorn",		'u',  8, 24, 5, 70, 1, 10, 0 },
X	{ "yeti",		'Y',  5, 15, 6,  0, 1,  6, 0 },
X	{ "stalker",		'I',  8, 12, 3,  0, 4,  4, 0 },
X	{ "umber hulk",		'U',  9,  6, 2, 25, 2, 10, 0 },
X	{ "vampire",		'V',  8, 12, 1, 25, 1,  6, 0 },
X	{ "xorn",		'X',  8,  9,-2, 20, 4,  6, 0 },
X	{ "xan",		'x',  7, 18,-2,  0, 2,  4, 0 },
X	{ "zruty",		'z',  9,  8, 3,  0, 3,  6, 0 },
X	{ "chameleon",		':',  6,  5, 6, 10, 4,  2, 0 },
X	{ "giant",		'9',  9, 18, 5,  0, 2, 12, 0 },
X	{ "dragon",		'D', 10,  9,-1, 20, 3,  8, 0 },
X	{ "ettin",		'e', 10, 12, 3,  0, 2,  8, 0 },
X	{ "lurker above",	'\'',10,  3, 3,  0, 0,  0, 0 },
X	{ "nurse",		'n', 11,  6, 0,  0, 2,  6, 0 },
X	{ "trapper",		',', 12,  3, 3,  0, 0,  0, 0 },
X	{ "purple worm",	'P', 15,  9, 6, 20, 2,  8, 0 },
X	{ "demon",		'&', 10, 12,-4, 30, 1,  4, 0 },
X#ifdef SAC
X	{ "soldier",		'3', 12,  9,-3, 15,10,  4, 0 },
X#endif /* SAC */
X	{ "minotaur",		'm', 15, 15, 6,  0, 4, 10, 0 },
X	{ "shopkeeper", 	'@', 12, 18, 0, 50, 4,  8, sizeof(struct eshk) }
X};
X
Xstruct permonst pm_ghost = { "ghost", ' ', 10, 3, -5, 50, 1, 1, sizeof(plname) };
X#ifdef SAC
Xstruct permonst pm_wizard = { "wizard of Yendor", '1', 20, 12, -8, 100, 2, 12, 0 };
X#else
Xstruct permonst pm_wizard = { "wizard of Yendor", '1', 15, 12, -2, 70, 1, 12, 0 };
X#endif
X#ifdef RPH
Xstruct permonst pm_medusa = {"medusa", '8', 15, 12, 2, 50, 1, 8, 0};
X#endif
X#ifdef MAIL
Xstruct permonst pm_mail_daemon = { "mail daemon", '2', 100, 1, 10, 127, 0, 0, 0 };
X#endif
Xstruct permonst pm_eel = { "giant eel", ';', 15, 6, -3, 0, 3, 6, 0 };
X
END_OF_monst.c
if test 4089 -ne `wc -c <monst.c`; then
    echo shar: \"monst.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f nansi.sys.uu -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"nansi.sys.uu\"
else
echo shar: Extracting \"nansi.sys.uu\" \(3476 characters\)
sed "s/^X//" >nansi.sys.uu <<'END_OF_nansi.sys.uu'
Xbegin 644 ./nansi.sys
XM_____Q.`RP#6`$-/3B`@("`@&ULR2DYA;G-I+G-Y<R!V,BXR.B!.97<@04Y3
XM22!D<FEV97(@*$,I($1A;FEE;"!+96=E;"P@4&%S861E;F$L($-!(#$Y.#8-
XM"AH``````0```QA/```````'```````````````#````````````6QL``'@`
XM````````=P``````H64`B]BT`)**Q[0`*]!"BL/^P/8F9P`"QX#4``/`E\-P
XM"2,!(P$?`28!-0%)`50!F`&8`2,!(P$NB1Y<`"Z,!EX`R_M04U%25597'@8N
XMQ1Y<`(I'`L1W#HM/$CP,=R"3T>.,R([8_Y>S`"[%'EP`#0`!B4<#!Q]?7EU:
XM65M8R^@*`.OF+L<&BP`!`,^X$PC#,\##XPJ+_E'HXP)9JN+X,\##Z",#=`O%
XM'EP`B$<-,\#K`[@``L/H#P.X``)T`C/`PS/`HX,`HX<`HXL`HX\`N$``CL`F
XMH1H`)J,<`#/`PP#['@904U%25597N0$`C,N.PX[;OG(!B`3H"@!?7EU:65M8
XM!Q_/C`9O`+A``([8H4D`+J)C`/[,+H@F90"@8@"8`\"3BX=0`"ZC9@"A8P`N
XMHW,`H4X`T>C1Z-'HT>B`Q+`N@#YC``=T`X#$"`X?HVT`CL#HJ_[H%`%R`^B?
XM`8L>=0"*)FL`CAYO`/SC(RZ#/F$``'50Z/4`<@/I#`&L/!QR(B[7JTK@]70$
XMZP3@YW1HC,B.V*!E`/[`*L*B9@#H+0$SP,,\&W0:/`UT+SP*=&`\"70+/`AT
XM$#P'=!CIP@#K>9#II`+IE`(N.A9E`'<#3T]"Z[CH(@(*P.NQ+J!E`/[`*L*T
XM`"OX*_@NBA9E`$(NBB9K``P!ZY1!+O8&8``!=05/3T+KABZ*%F4`0BOZ*_HN
XMH&0`+C@&9P!R!>@%`>L0+OX&9P`NH&4`M`!``\`#^"Z*)FL`#`'I4O\NH&4`
XM_L`JPE&U`(K(@.$']MF`P0@KT9RP(.@6`','\ZN=6>DL_P/1Z#P`2N+ZG5GI
XM'_\N@#YC``1R"BZ`/F,`!W0"^,/YP^CI_W,(Z?G^K#P<<@TNU^@.`$K@\W0&
XMZ?7^Z0;_Z5?_4E%34"Z@90#^P"K"+J)F`"Z+%F8`,]NT`LT0N0$`6%"*W+<`
XMM`G-$%A;65K#Z)S_<RJ+W]'KBQ9S`+`.[NL`0HK'[NL`2K`/[NL`0HK#[KA`
XM`([8+J%F`*-0`,.X%H_HGO_#M`#H9/]S%RZ*)FL`@.1_+H`^8P`'=0>`_`%U
XM`K0'PU!345+HVO^*_+`!M`:Q`+4`+HH690`NBC9D`,T06EE;6,.+-N`$"L!T
XM`K0`.S;>!'8.BPP[1/YT"X/N!"OQZ^P+]NL'@^X"*_$ZP,.Y!`"[?P"#PP2+
XM-POVX??#Z.W_="G_#TZ+;P(^B@*#[@%R&8'[@P!T$PK`=0__#SZ*(L<&@P`!
XM`(@F>`#K&[0`S18+P'3XZ(W_=0J)#H\`B3:1`.N[/`!TV</HH_]T"4Z+;P(^
XMB@+K&K0!S19T%PO`=0:T`,T6Z_#H6_]U!0/QBD3_@,P!PQ0%`P!04U%25597
XML+:Z0P#N2BZAAP3K`.Z&X.L`[KIA`.L`[%`,`^L`[@:X0`".P":+'FP`+@,>
XMB02Y__\FH6P`.\-_`N+V!U@D_.Y?7EU:65M8PP``,#`P,#`NB1YQ`"ZC80#I
XM-/TNBQYQ`"[_)F$`Z9D`X@6X`@7KX*P\6W7Q+HL>W`0NQ@<`+L8&VP0`X@6X
XM'07KQ:P\/70'/#]T`T[K!^(%N#`%Z[*L/#!R%CPY=Q(L,"Z(!R[&!ML$`>)B
XMN*@%ZY<\(G0$/"=U="ZB:@#B!;A>!>N$K"XZ!FH`=!,NB`<N.Q[>!(/3`.+K
XMN%X%Z6G_+L8'`.(&N(4%Z5W_K#P[=`)!3N*BN#`%Z4[_+L<&80```"Z*)FL`
XM+HL>=0#I:_VL/#!R&CPY=Q8L,"Z&!U*R"O;B6BX`!^+GN*@%Z1O_/#MU$"X[
XM'MX$@],`+L8&VP0`ZYX\0'*U/'IWL3Q:=@8\87*I+`9641X.'RQ`F`/`!44&
XMB\LNBS;<!"O.+O8&VP0!=`%!DZ!E`$`JPJ)F`+0`K`K`=0%`_Q<?65XNBB9K
XM`"Z+'G4`+L<&80````O2Z>7[U`H%,#"&X*J&X*K#30@`!_H&YP;M!J\&KP:O
XM!K`&KP9/!T8'(P@?"*\&KP91"*\&KP:O!J\&KP:O!J\&KP:O!J\&KP:O!J\&
XMKP:O!K`&KP:2"*\&KP:O!@H)'`=S!Z\&J`>O!J\&#0>O!A0'KP:O!J\&#@FO
XM!L,*P'0!2*)G`#/`@_D"<@:L"L!T`4BB9@"A9@`Z!F4`=@:@90"B9@`Z)F0`
XM=@:@9`"B9P#HK?G#``9F`.O;*`9F`',%Q@9F``#KS@`&9P#KR"@&9P!S!<8&
XM9P``Z[NA9@"C:`##H6@`HV8`ZZQ."\EU!,8$`$&L4;D6`)"[*PF#PP,Z!^#Y
XM=0N+1P$@!FL`""9K`%GBX,-2BPYF`(KUZQ0\`G4?QP9F````Z#?Y4C/)BC9D
XM`.@P_(K\BA9E`+@`!LT06L-74@:,R([`_;^``*!G`/[`Z+/^L#NJH&8`_L#H
XMJ/ZP4JJP#8D^B0"JN((`*\>CAP#\!UI?PPO)=%G\3DE)K0K`=`)!3E<&45;]
XM'@?H%OQU%H/!!(LNW@0!#MX$3HO^`_F+SBO-\Z1>68L^W@2#[P2+WRO9@^L0
XM.Q[<!'(2B4T#B44!XP:D@\8"XOJ)/MX$!U_\PP8>!_V+/N`$N`$`J[@`<JNP
XM$*J)/MX$!^ODM`;K`K0'BCYD`"H^9P`ZQW8"L`!0Z%_[BOQ8L0"*+F<`4HH6
XM90"*-F0`S1!:P[4!ZP*U`.BI^G,Y.L)V`HK"5Y&+Z;4`B_<#\0/Q]MD"RK4`
XM_/;$`70,A_[]B\%(`\`#^`/P!A_SI8O-Z`O[L"#SJ_Q?P['_/`=U!H@.8`#K
XM:SPK=4*T$KL0_\T0]\/\_G5:Z$WZ<U6T`*!C`,T0N!(1LP#-$+@`$K,@S1"T
XM`;D'!\T0BQ9S`+`*[NL`0K`'[L8&9``JZPFT`,T0Q@9D`!BX0``>CMBA20`?
XMHF,`_LR()F4`QP9F````Z(KWP[$`ZX:+'G4`XP].K4EU`HK@`MB`UP"()\,S
XMP(@'0_[`=?GK]```!P'_"`3X`07_@`?X<`B(`![X`!_X!"#X`B'X!B+X`2/X
XM!23X`R7X!RB/`"F/0"J/("N/8"R/$"V/4"Z/,"^/<#/`CMB[;`#'!Q<!C$\"
XMNZ0`QP=S`8Q/`@X?#@?\OW`)B3[<!(''``*)/MX$1[`0JK@`<JNX`0")/N`$
X9JXD^=0`SP*K^P'7[,\#%-EP`B7P.C$P0PP*)
X`
Xend
END_OF_nansi.sys.uu
if test 3476 -ne `wc -c <nansi.sys.uu`; then
    echo shar: \"nansi.sys.uu\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f pcunix.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"pcunix.c\"
else
echo shar: Extracting \"pcunix.c\" \(3611 characters\)
sed "s/^X//" >pcunix.c <<'END_OF_pcunix.c'
X/*	SCCS Id: @(#)pcunix.c	1.4	87/08/08
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* unix.c - version 1.0.3 */
X
X/* This file collects some Unix dependencies; pager.c contains some more */
X
X/*
X * The time is used for:
X *	- seed for rand()
X *	- year on tombstone and yymmdd in record file
X *	- phase of the moon (various monsters react to NEW_MOON or FULL_MOON)
X *	- night and midnight (the undead are dangerous at midnight)
X *	- determination of what files are "very old"
X */
X
X#include <stdio.h>	/* mainly for NULL */
X#include "hack.h"	/* mainly for index() which depends on BSD */
X
X#ifndef __TURBOC__  /* Turbo C has time_t in time.h */
X#include	<sys/types.h>		/* for time_t */
X#endif
X#include	<time.h>
X#include        <sys/stat.h>
X
Xextern time_t time();
Xstatic struct stat buf, hbuf;
X
Xsetrandom()
X{
X	(void) srand((int) time ((time_t *) 0));
X}
X
Xstruct tm *
Xgetlt()
X{
X	time_t date;
X	struct tm *localtime();
X
X	(void) time(&date);
X	return(localtime(&date));
X}
X
Xgetyear()
X{
X	return(1900 + getlt()->tm_year);
X}
X
Xchar *
Xgetdate()
X{
X	static char datestr[7];
X	register struct tm *lt = getlt();
X
X	(void) sprintf(datestr, "%2d%2d%2d",
X		lt->tm_year, lt->tm_mon + 1, lt->tm_mday);
X	if(datestr[2] == ' ') datestr[2] = '0';
X	if(datestr[4] == ' ') datestr[4] = '0';
X	return(datestr);
X}
X
Xphase_of_the_moon()			/* 0-7, with 0: new, 4: full */
X{					/* moon period: 29.5306 days */
X					/* year: 365.2422 days */
X	register struct tm *lt = getlt();
X	register int epact, diy, golden;
X
X	diy = lt->tm_yday;
X	golden = (lt->tm_year % 19) + 1;
X	epact = (11 * golden + 18) % 30;
X	if ((epact == 25 && golden > 11) || epact == 24)
X		epact++;
X
X	return( (((((diy + epact) * 6) + 11) % 177) / 22) & 7 );
X}
X
Xnight()
X{
X	register int hour = getlt()->tm_hour;
X
X	return(hour < 6 || hour > 21);
X}
X
Xmidnight()
X{
X	return(getlt()->tm_hour == 0);
X}
X
Xgethdate(name) char *name; {
X/* old version - for people short of space */
X/*
X/* register char *np;
X/*      if(stat(name, &hbuf))
X/*              error("Cannot get status of %s.",
X/*                      (np = rindex(name, '/')) ? np+1 : name);
X/*
X/* version using PATH from: seismo!gregc@ucsf-cgl.ARPA (Greg Couch) */
X
X/*
X * The problem with   #include  <sys/param.h> is that this include file
X * does not exist on all systems, and moreover, that it sometimes includes
X * <sys/types.h> again, so that the compiler sees these typedefs twice.
X */
X#define         MAXPATHLEN      1024
X
Xregister char *np, *path;
Xchar filename[MAXPATHLEN+1];
X
X    if (index(name, '/') != NULL || (path = getenv("PATH")) == NULL)
X        path = "";
X
X    for (;;) {
X        if ((np = index(path, ':')) == NULL)
X            np = path + strlen(path);       /* point to end str */
X        if (np - path <= 1)                     /* %% */
X            (void) strcpy(filename, name);
X        else {
X            (void) strncpy(filename, path, np - path);
X            filename[np - path] = '/';
X            (void) strcpy(filename + (np - path) + 1, name);
X        }
X        if (stat(filename, &hbuf) == 0)
X            return;
X        if (*np == '\0')
X        path = "";
X        path = np + 1;
X    }
X    error("Cannot get status of %s.", (np = rindex(name, '/')) ? np+1 : name);
X}
X
Xuptodate(fd) {
X    if(fstat(fd, &buf)) {
X        pline("Cannot get status of saved level? ");
X        return(0);
X    }
X    if(buf.st_mtime < hbuf.st_mtime) {
X        pline("Saved level is out of date. ");
X        return(0);
X    }
X    return(1);
X}
X
Xregularize(s)	/* normalize file name - we don't like ..'s or /'s */
Xregister char *s;
X{
X	register char *lp;
X
X	while((lp = index(s, '.')) || (lp = index(s, '/')))
X		*lp = '_';
X}
END_OF_pcunix.c
if test 3611 -ne `wc -c <pcunix.c`; then
    echo shar: \"pcunix.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f rm.h -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"rm.h\"
else
echo shar: Extracting \"rm.h\" \(3871 characters\)
sed "s/^X//" >rm.h <<'END_OF_rm.h'
X/*	SCCS Id: @(#)rm.h	2.1	87/10/17
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X
X/*
X * The dungeon presentation graphics code and data structures were rewritten
X * and generalized for NetHack's release 2 by Eric S. Raymond (eric@snark)
X * building on Don G. Kneller's MS-DOS implementation. See options.c for
X * the code that permits the user to set the contents of the symbol structure.
X */
X
X/* Level location types */
X#define	HWALL 1
X#define	VWALL 2
X#define	SDOOR 3
X#define	SCORR 4
X#define	LDOOR 5
X#define	POOL	6	/* not yet fully implemented */
X			/* this should in fact be a bit like lit */
X#define	DOOR 7
X#define	CORR 8
X#define	ROOM 9
X#define	STAIRS 10
X#define FOUNTAIN 11
X#define THRONE 12
X
X/*
X * Avoid using the level types in inequalities:
X *  these types are subject to change.
X * Instead, use one of the macros below.
X */
X#define	IS_WALL(typ)	((typ) <= VWALL)
X#define IS_ROCK(typ)	((typ) < POOL)		/* absolutely nonaccessible */
X#define	ACCESSIBLE(typ)	((typ) >= DOOR)			/* good position */
X#define	IS_ROOM(typ)		((typ) >= ROOM)		/* ROOM or STAIRS */
X#ifdef RPH
X/* zappable positions include 1 in 5 doors. */
X#define ZAP_POS(typ)	((typ) >= POOL || (((typ) == DOOR) && !rn2(5)))
X#define SPACE_POS(typ)	((typ) > DOOR)
X#else
X#define	ZAP_POS(typ)		((typ) > DOOR)
X#endif
X#define IS_POOL(typ)    ((typ) == POOL)
X#define IS_THRONE(typ)    ((typ) == THRONE)
X#define IS_FOUNTAIN(typ)        ((typ) == FOUNTAIN)
X
X/*
X * The level-map symbols may be compiled in or defined at initialization time
X */
X#ifndef GRAPHICS
X
X#define STONE_SYM	' '
X#define VWALL_SYM	'|'
X#define HWALL_SYM	'-'
X#define TLCORN_SYM	'+'
X#define TRCORN_SYM	'+'
X#define BLCORN_SYM	'+'
X#define BRCORN_SYM	'+'
X#define DOOR_SYM	'+'
X#define ROOM_SYM	'.'
X#ifdef QUEST
X# define	CORR_SYM	':'
X#else
X# define	CORR_SYM	'#'
X#endif
X#define UP_SYM		'<'
X#define DN_SYM		'>'
X#define TRAP_SYM	'^'
X#define	POOL_SYM	'}'
X#define FOUNTAIN_SYM    '{'
X#define THRONE_SYM      '\\'
X#define WEB_SYM         '"'
X#else /* GRAPHICS */
X
X/* screen symbols for using character graphics. */
Xstruct symbols {
X    unsigned char stone, vwall, hwall, tlcorn, trcorn, blcorn, brcorn;
X    unsigned char door, room, corr, upstair, dnstair, trap;
X#ifdef FOUNTAINS
X    unsigned char pool, fountain;
X#endif
X#ifdef NEWCLASS
X    unsigned char throne;
X#endif
X#ifdef SPIDERS
X    unsigned char web;
X#endif
X};
Xextern struct symbols showsyms, defsyms;
X
X#define STONE_SYM	showsyms.stone
X#define VWALL_SYM	showsyms.vwall
X#define HWALL_SYM	showsyms.hwall
X#define TLCORN_SYM	showsyms.tlcorn
X#define TRCORN_SYM	showsyms.trcorn
X#define BLCORN_SYM	showsyms.blcorn
X#define BRCORN_SYM	showsyms.brcorn
X#define DOOR_SYM	showsyms.door
X#define ROOM_SYM	showsyms.room
X#define	CORR_SYM	showsyms.corr
X#define UP_SYM		showsyms.upstair
X#define DN_SYM		showsyms.dnstair
X#define TRAP_SYM	showsyms.trap
X#define	POOL_SYM	showsyms.pool
X#define FOUNTAIN_SYM    showsyms.fountain
X#define THRONE_SYM      showsyms.throne
X#define WEB_SYM         showsyms.web
X#endif
X
X#define	ERRCHAR	']'
X
X#define MAXPCHARS	17	/* maximum number of mapped characters */
X
X#define IS_CORNER(x)	((x) == TLCORN_SYM || (x) == TRCORN_SYM \
X			 || (x) == BLCORN_SYM || (x) == BRCORN_SYM)
X
X/*
X * The structure describing a coordinate position.
X * Before adding fields, remember that this will significantly affect
X * the size of temporary files and save files.
X */
X#ifdef MSDOS
X/* Save disk space by using unsigned char's instead of unsigned ints
X */
Xstruct rm {
X	uchar scrsym;
X	unsigned typ:5;
X	unsigned new:1;
X	unsigned seen:1;
X	unsigned lit:1;
X};
X#else
Xstruct rm {
X	char scrsym;
X	Bitfield(typ,5);
X	Bitfield(new,1);
X	Bitfield(seen,1);
X	Bitfield(lit,1);
X};
X#endif /* MSDOS /**/
Xextern struct rm levl[COLNO][ROWNO];
X
X#ifdef DGK
X#define ACTIVE	1
X#define SWAPPED	2
X
Xstruct finfo {
X	int	where;
X	long	time;
X	long	size;
X};
Xextern struct finfo fileinfo[];
X#define ZFINFO	{ 0, 0L, 0L }
X#endif
END_OF_rm.h
if test 3871 -ne `wc -c <rm.h`; then
    echo shar: \"rm.h\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f rumors.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"rumors.c\"
else
echo shar: Extracting \"rumors.c\" \(2892 characters\)
sed "s/^X//" >rumors.c <<'END_OF_rumors.c'
X/*	SCCS Id: @(#)rumors.c	1.4	87/08/08
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* hack.rumors.c - version 1.0.3 */
X
X#include	<stdio.h>
X#include	"hack.h"		/* for RUMORFILE and BSD (index) */
X#ifdef DGK
X/* Rumors has been entirely rewritten to speed up the access.  This is
X * essential when working from floppies.  Using fseek() the way that's done
X * here means rumors following longer rumors are output more often than those
X * following shorter rumors.  Also, you may see the same rumor more than once
X * in a particular game (although the odds are highly against it), but
X * this also happens with real fortune cookies.  Besides, a person can
X * just read the rumor file if they desire.  -dgk
X */
Xlong rumors_size;
Xextern char *index();
Xextern long ftell();
X
Xoutrumor()
X{
X	char	line[COLNO];
X	char	*endp;
X	char	roomer[FILENAME];
X	FILE	*rumors;
X
X	if (rumors_size < 0)	/* We couldn't open RUMORFILE */
X		return;
X	if(rumors = fopen(RUMORFILE, "r")) {
X		if (!rumors_size) {	/* if this is the first outrumor() */
X			fseek(rumors, 0L, 2);
X			rumors_size = ftell(rumors);
X		}
X		fseek(rumors, rand() % rumors_size, 0);
X		fgets(line, COLNO, rumors);
X		if (!fgets(line, COLNO, rumors)) {	/* at EOF ? */
X			fseek(rumors, 0L, 0);		/* seek back to start */
X			fgets(line, COLNO, rumors);
X		}
X		if(endp = index(line, '\n')) *endp = 0;
X		pline("This cookie has a scrap of paper inside! It reads: ");
X		pline(line);
X		fclose(rumors);
X	} else {
X		pline("Can't open rumors file!");
X		rumors_size = -1;	/* don't try to open it again */
X	}
X}
X
X#else
X
X#define	CHARSZ	8			/* number of bits in a char */
Xextern long *alloc();
Xextern char *index();
Xint n_rumors = 0;
Xint n_used_rumors = -1;
Xchar *usedbits;
X
Xinit_rumors(rumf) register FILE *rumf; {
Xregister int i;
X	n_used_rumors = 0;
X	while(skipline(rumf)) n_rumors++;
X	rewind(rumf);
X	i = n_rumors/CHARSZ;
X	usedbits = (char *) alloc((unsigned)(i+1));
X	for( ; i>=0; i--) usedbits[i] = 0;
X}
X
Xskipline(rumf) register FILE *rumf; {
Xchar line[COLNO];
X	while(1) {
X		if(!fgets(line, sizeof(line), rumf)) return(0);
X		if(index(line, '\n')) return(1);
X	}
X}
X
Xoutline(rumf) register FILE *rumf; {
Xchar line[COLNO];
Xregister char *ep;
X	if(!fgets(line, sizeof(line), rumf)) return;
X	if((ep = index(line, '\n')) != 0) *ep = 0;
X	pline("This cookie has a scrap of paper inside! It reads: ");
X	pline(line);
X}
X
Xoutrumor(){
Xregister int rn,i;
Xregister FILE *rumf;
X	if(n_rumors <= n_used_rumors ||
X	  (rumf = fopen(RUMORFILE, "r")) == (FILE *) 0) return;
X	if(n_used_rumors < 0) init_rumors(rumf);
X	if(!n_rumors) goto none;
X	rn = rn2(n_rumors - n_used_rumors);
X	i = 0;
X	while(rn || used(i)) {
X		(void) skipline(rumf);
X		if(!used(i)) rn--;
X		i++;
X	}
X	usedbits[i/CHARSZ] |= (1 << (i % CHARSZ));
X	n_used_rumors++;
X	outline(rumf);
Xnone:
X	(void) fclose(rumf);
X}
X
Xused(i) register int i; {
X	return(usedbits[i/CHARSZ] & (1 << (i % CHARSZ)));
X}
X
X#endif /* DGK /**/
END_OF_rumors.c
if test 2892 -ne `wc -c <rumors.c`; then
    echo shar: \"rumors.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f rumors.kaa -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"rumors.kaa\"
else
echo shar: Extracting \"rumors.kaa\" \(3523 characters\)
sed "s/^X//" >rumors.kaa <<'END_OF_rumors.kaa'
XYou should always be sure to learn about quantum mechanics.
XAn apple a day keeps the doctor away.
XA crystal plate mail will not rust.
XTry using your magic marker on wet scrolls!
XCrystal plate is the rarest of all.
XHealers are immune to the effects of nurses.
XBashing monsters with a bow is not such a good idea.
XWait!  That's a fortune!
XEver broken an egg against the ground?
XFinding traps is a lot like finding gold.
XFinding potions is a lot like finding food.
XRust traps are harmless if you are wearing an elven cloak.
XDon't bother trying to control teleports if you are not awake.
XEver gone into the morgue at midnight?
XWielding a dead cockatrice may actually work.
XLeaving the dungeon while hallucinating may get you arrested.
XDrinking potions of booze may land you in jail if you are under 21.
XA dilithium crystal is the most valuable mineral around.
XValkyrie comes from the north, and has commensurate abilities.
XElf has extra speed.
XGushes of water won't necessarily hit your head.
XPlaying Gauntlet might be enlightening in some situations.
XA short sword is not as good as a long sword.
XA bardiche is better than a sword.
XA trident is a nice thing to have.
XUsing a morning star in the evening has no effect.
XPolymorphing a shopkeeper might make you safer.
XYou cannot quench your thirst in a water trap.
XAfraid of nymphs?  Wear a ring of adornment.
XGiant bats turn into giant vampires.
XI wouldn't advise playing catch with a giant.
XAfraid of your valuables being stolen?  Carry more junk!
XHoly water has many uses.
XYou swallowed the fortune!!!
XYou hear the fortune cookie's hissing!
XA pie fight.  Now that's fun!
XMesses attract ants.
XWhy are you wasting time reading fortunes?
XHelp!  I'm being held prisoner in a fortune cookie factory!
XOnly elves can wear elfin chain mail.
XAre you SURE that's a wand of wishing?
XCroesus?  Who's he?
XIf you want a sex change, you must get it before the game.
XShopkeepers value money more than revenge.
XShopkeepers can't tell identical twins apart.
XYou're going into the morgue at midnight????
XDidn't your mother tell you not to eat food off the floor?
XTrolls are described as rubbery:  they keep bouncing back.
XMark your way with a magic marker.
XA magic marker is like a wand of digging, but less so.
XA dead cockatrice is just a dead lizard.
XYou need 512k to implement the magic memory vaults.
XEveryone's goal is to get to heaven.
XHeaven can wait.
XUnused potions are like unburned scrolls.
XEver read a tin of fire?
XYou may want to dip into a potion of bottled blessings.
XTridents are for use underwater.
XWe have new ways of detecting treachery...
XCave(wo)men all belong to the same club.
XIf you thought the wizard was bad, just wait till you meet the Warlord!
XYou are filled with a feeling of awwwww.
XValkyries, elves, and wizards need food badly.
XNetHack was modified by Miracleman (Ken Arromdee).
XYou may discover a fine spirit inside a potion bottle.
XLong live Phoenix!
XMost of the bugs in Hack are on the floor.
XWhat does a dead demon taste like?
XIf you kill a ghost, how will you find the body?
XA ring of dungeon master control is a great find.
XEver lifted a dead dragon?
XEver see your weapon glow plaid?
XPlaying AD&D may be helpful.
XWhat is a three sided die shaped like?
XWhat is a zero sided die shaped like?
XWhat is a cockatrice going to eat when it gets hungry?
XHitting a giant that is picking up a boulder may be difficult.
XA softly glowing weapon can kill a demon.
XThe orc swings his two handed sword named Elfrist at you.  You die...
XZap yourself and see what happens...
END_OF_rumors.kaa
if test 3523 -ne `wc -c <rumors.kaa`; then
    echo shar: \"rumors.kaa\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f search.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"search.c\"
else
echo shar: Extracting \"search.c\" \(3589 characters\)
sed "s/^X//" >search.c <<'END_OF_search.c'
X/*	SCCS Id: @(#)search.c	2.1	87/11/10
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X
X#include "hack.h"
Xchar *rndmonnam(), *defmonnam();
X
Xextern struct monst *makemon();
X
Xfindit()	/* returns number of things found */
X{
X	int num;
X	register xchar zx,zy;
X	register struct trap *ttmp;
X	register struct monst *mtmp;
X	xchar lx,hx,ly,hy;
X
X	if(u.uswallow) return(0);
X	for(lx = u.ux; (num = levl[lx-1][u.uy].typ) && num != CORR; lx--) ;
X	for(hx = u.ux; (num = levl[hx+1][u.uy].typ) && num != CORR; hx++) ;
X	for(ly = u.uy; (num = levl[u.ux][ly-1].typ) && num != CORR; ly--) ;
X	for(hy = u.uy; (num = levl[u.ux][hy+1].typ) && num != CORR; hy++) ;
X	num = 0;
X	for(zy = ly; zy <= hy; zy++)
X		for(zx = lx; zx <= hx; zx++) {
X			if(levl[zx][zy].typ == SDOOR) {
X				levl[zx][zy].typ = DOOR;
X				atl(zx, zy, DOOR_SYM);
X				num++;
X			} else if(levl[zx][zy].typ == SCORR) {
X				levl[zx][zy].typ = CORR;
X				atl(zx, zy, CORR_SYM);
X				num++;
X			} else if(ttmp = t_at(zx, zy)) {
X				if(ttmp->ttyp == PIERC){
X					(void) makemon(PM_PIERCER, zx, zy);
X					num++;
X					deltrap(ttmp);
X				} else if(!ttmp->tseen) {
X					ttmp->tseen = 1;
X					if(!vism_at(zx, zy))
X						atl(zx,zy,TRAP_SYM);
X					num++;
X				}
X			} else if(mtmp = m_at(zx,zy)) if(mtmp->mimic){
X				seemimic(mtmp);
X				num++;
X			}
X		}
X	return(num);
X}
X
Xdosearch()
X{
X	register xchar x,y;
X	register struct trap *trap;
X	register struct monst *mtmp;
X#ifdef BVH	/* if weapon is Excalibur give the user the sword's
X		 * magic bonus (+ or -) to search for hidden objects.
X		 */
X	int fund = (uwep && !strcmp(ONAME(uwep),"Excalibur")) ?
X			((uwep->spe > 5) ? 5 : uwep->spe) : 0;
X#endif
X
X	if(u.uswallow)
X		pline("What are you looking for? The exit?");
X	else
X	for(x = u.ux-1; x < u.ux+2; x++)
X	for(y = u.uy-1; y < u.uy+2; y++) if(x != u.ux || y != u.uy) {
X		if(levl[x][y].typ == SDOOR) {
X			if(rn2(7-fund)) continue;
X			levl[x][y].typ = DOOR;
X			levl[x][y].seen = 0;	/* force prl */
X			prl(x,y);
X			nomul(0);
X		} else if(levl[x][y].typ == SCORR) {
X			if(rn2(7-fund)) continue;
X			levl[x][y].typ = CORR;
X			levl[x][y].seen = 0;	/* force prl */
X			prl(x,y);
X			nomul(0);
X		} else {
X		/* Be careful not to find anything in an SCORR or SDOOR */
X			if(mtmp = m_at(x,y)) if(mtmp->mimic){
X				seemimic(mtmp);
X				pline("You find %s.",defmonnam(mtmp));
X				return(1);
X			}
X			for(trap = ftrap; trap; trap = trap->ntrap)
X			if(trap->tx == x && trap->ty == y &&
X			   !trap->tseen && !rn2(8)) {
X				nomul(0);
X				if (trap->ttyp != PIERC)
X				pline("You find a%s.", traps[Hallucination ?
X				rn2(TRAPNUM-2) : trap->ttyp ]);
X
X				if(trap->ttyp == PIERC) {
X				    deltrap(trap);
X				    if((mtmp=makemon(PM_PIERCER,x,y)))
X					pline("You find %s.", defmonnam(mtmp));
X				    return(1);
X				}
X				trap->tseen = 1;
X				if(!vism_at(x,y)) atl(x,y,TRAP_SYM);
X			}
X		}
X	}
X	return(1);
X}
X
Xdoidtrap() {
Xregister struct trap *trap;
Xregister int x,y;
X	if(!getdir(1)) return(0);
X	x = u.ux + u.dx;
X	y = u.uy + u.dy;
X	for(trap = ftrap; trap; trap = trap->ntrap)
X		if(trap->tx == x && trap->ty == y && trap->tseen) {
X		    if(u.dz)
X			if((u.dz < 0) != (!xdnstair && trap->ttyp == TRAPDOOR))
X			    continue;
X			pline("That is a%s.",traps[ Hallucination ? rn2(TRAPNUM-2) :
X			trap->ttyp]);
X		    return(0);
X		}
X	pline("I can't see a trap there.");
X	return(0);
X}
X
Xwakeup(mtmp)
Xregister struct monst *mtmp;
X{
X	mtmp->msleep = 0;
X	setmangry(mtmp);
X	if(mtmp->mimic) seemimic(mtmp);
X}
X
X/* NOTE: we must check if(mtmp->mimic) before calling this routine */
Xseemimic(mtmp)
Xregister struct monst *mtmp;
X{
X		mtmp->mimic = 0;
X		mtmp->mappearance = 0;
X		unpmon(mtmp);
X		pmon(mtmp);
X}
END_OF_search.c
if test 3589 -ne `wc -c <search.c`; then
    echo shar: \"search.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f sit.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"sit.c\"
else
echo shar: Extracting \"sit.c\" \(3725 characters\)
sed "s/^X//" >sit.c <<'END_OF_sit.c'
X/*	SCCS Id: @(#)sit.c	2.1	87/11/09
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X
X#include "hack.h"
X
X#ifdef NEWCLASS
Xint	identify();
Xextern struct monst *makemon();
Xextern struct permonst *courtmon();
X
Xdosit() {
X	extern struct obj *readobjnam(), *addinv();
X	struct	 obj	*sobj_at();
X	register int	cnt;
X
X	if(Levitation)  {
X
X		pline("You are floating in the air, you can't sit!");
X	} else	if(IS_THRONE(levl[u.ux][u.uy].typ)) {
X
X		pline("As you sit in the opulent throne");
X		if (rnd(6) > 4)  {
X
X			switch (rnd(13))  {
X
X			    case 1:
X				pline("you feel suddenly weaker.");
X				if(Poison_resistance) {
X
X				    losestr(rn1(1,2));
X				    losehp(rnd(6), "cursed throne");
X				} else {
X
X				    losestr(rn1(4,3));
X				    losehp(rnd(10), "cursed throne");
X				}
X				break;
X			    case 2:
X				pline("you feel suddenly stronger.");
X				gainstr(0);
X				break;
X			    case 3:
X				pline("A massive charge of electricity shoots through your body!");
X				losehp(rnd(30), "electric chair");
X				break;
X			    case 4:
X				pline("you feel much, much better!");
X				if(u.uhp >= (u.uhpmax - 5))  u.uhpmax += 4;
X				u.uhp = u.uhpmax;
X				if (Blinded) Blinded = 1;
X				if (Sick)  Sick = 0;
X				heal_legs();
X				flags.botl = 1;
X				break;
X			    case 5:
X				if (u.ugold <= 0)  {
X
X					pline("you feel a strange sensation.");
X				} else {
X					pline("you notice you have no gold!");
X					u.ugold = 0;
X					flags.botl = 1;
X				}
X				break;
X			    case 6:
X				if(u.uluck + rn2(5) < 0) {
X
X				    pline("you feel your luck is changing.");
X				    u.uluck++;
X				} else	    makewish();
X				break;
X			    case 7:
X				cnt = rnd(10);
X				pline("you hear a voice echo:");
X				pline("Your audience has been summoned, Sire!");
X				while(cnt--)
X				    (void) makemon(courtmon(), u.ux, u.uy);
X				break;
X			    case 8:
X				if (Confusion != 0)  {
X
X				    pline("you hear a voice echo:");
X				    pline("By your Imperious order Sire...");
X				}
X				do_genocide();
X				break;
X			    case 9:
X				pline("you hear a voice echo:");
X				pline("A curse upon you for sitting upon this most holy throne!");
X				if (u.uluck > 0)  {
X
X				    if(!Blind)	pline("a cloud of darkness falls upon you.");
X				    Blinded += rn1(100,250);
X				    seeoff(0);
X				} else	    rndcurse();
X				break;
X			    case 10:
X				if (u.uluck < 0)  {
X
X					pline("an image forms in your mind.");
X					do_mapping();
X				} else  {
X
X					pline("your vision clarifies.");
X					HSee_invisible |= INTRINSIC;
X				}
X				break;
X			    case 11:
X				if (u.uluck < 0)  {
X
X				    pline("you feel threatened.");
X				    aggravate();
X				} else  {
X
X				    pline("you feel a wrenching sensation.");
X				    tele();		/* teleport him */
X				}
X				break;
X			    case 12:
X				pline("you are granted a gift of insight!");
X				while (!ggetobj("identify", identify, rn2(5))
X					&& invent);
X				break;
X			    case 13:
X				pline("your mind turns into a pretzel!");
X				HConfusion += rn1(7,16);
X				break;
X			    default:	impossible("throne effect");
X					break;
X			}
X		} else	pline("you feel somehow out of place...");
X
X		if (!rn2(3) && IS_THRONE(levl[u.ux][u.uy].typ))	{
X
X			pline("The throne vanishes in a puff of logic.");
X/*			levl[u.ux][u.uy].scrsym = ROOM_SYM; */
X			levl[u.ux][u.uy].typ = ROOM;
X		}
X
X	} else	pline("Having fun sitting on the floor???");
X	return(1);
X}
X#endif /* NEWCLASS /**/
X
X#if defined(NEWCLASS) || defined(PRAYERS) || defined(HARD)
Xrndcurse() {			/* curse a few inventory items at random! */
X
X	int	nobj = 0;
X	int	cnt, onum;
X	struct	obj	*otmp;
X
X	for (otmp = invent; otmp; otmp = otmp->nobj)  nobj++;
X	    for (cnt = rnd(6); cnt > 0; cnt--)  {
X
X		onum = rn2(nobj);
X		for(otmp = invent; onum != 0; onum--)
X		    otmp = otmp->nobj;
X
X			otmp->cursed++;
X	    }
X}
X#endif
END_OF_sit.c
if test 3725 -ne `wc -c <sit.c`; then
    echo shar: \"sit.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f timeout.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"timeout.c\"
else
echo shar: Extracting \"timeout.c\" \(2056 characters\)
sed "s/^X//" >timeout.c <<'END_OF_timeout.c'
X/*	SCCS Id: @(#)timeout.c	2.0	87/09/18
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X
X#include	"hack.h"
X
Xtimeout(){
Xregister struct prop *upp;
X#ifdef KAA
Xregister struct monst *mtmp;
X#endif
X	if(Stoned) stoned_dialogue();
X#ifdef KAA
X	if(u.mtimedone) if (!--u.mtimedone) rehumanize();
X# ifdef KOPS
X	if(u.ucreamed > 0) u.ucreamed--;
X# endif
X#endif
X	for(upp = u.uprops; upp < u.uprops+SIZE(u.uprops); upp++)
X	    if((upp->p_flgs & TIMEOUT) && !(--upp->p_flgs & TIMEOUT)) {
X		if(upp->p_tofn) (*upp->p_tofn)();
X		else switch(upp - u.uprops){
X		case STONED:
X			killer = "cockatrice";
X			done("died");
X			break;
X		case SICK:
X			pline("You die because of food poisoning.");
X			killer = u.usick_cause;
X			done("died");
X			break;
X		case FAST:
X			pline("You feel yourself slowing down.");
X			break;
X		case CONFUSION:
X			if (Hallucination) pline("You feel less trippy now.");
X			else
X				pline("You feel less confused now.");
X			break;
X		case BLINDED:
X			if (Hallucination) pline("Oh like wow! What a rush.");
X			else		   pline("You can see again.");
X			setsee();
X			break;
X		case INVIS:
X			on_scr(u.ux,u.uy);
X			if (!See_invisible)
X				pline("You are no longer invisible.");
X			break;
X		case WOUNDED_LEGS:
X			heal_legs();
X			break;
X#ifdef KAA
X		case HALLUCINATION:
X			pline("Everything looks SO boring now.");
X			setsee();
X			for (mtmp=fmon; mtmp; mtmp=mtmp->nmon)
X				if ((Blind && Telepat) || canseemon(mtmp))
X					atl(mtmp->mx, mtmp->my, (!mtmp->mappearance || 
X					Protection_from_shape_changers) 
X					? mtmp->data->mlet : mtmp->mappearance);
X			break;
X#endif
X		}
X	}
X}
X
X/* He is being petrified - dialogue by inmet!tower */
Xchar *stoned_texts[] = {
X	"You are slowing down.",		/* 5 */
X	"Your limbs are stiffening.",		/* 4 */
X	"Your limbs have turned to stone.",	/* 3 */
X	"You have turned to stone.",		/* 2 */
X	"You are a statue."			/* 1 */
X};
X
Xstoned_dialogue()
X{
X	register long i = (Stoned & TIMEOUT);
X
X	if(i > 0 && i <= SIZE(stoned_texts))
X		pline(stoned_texts[SIZE(stoned_texts) - i]);
X	if(i == 5)
X		Fast = 0;
X	if(i == 3)
X		nomul(-3);
X}
END_OF_timeout.c
if test 2056 -ne `wc -c <timeout.c`; then
    echo shar: \"timeout.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f topl.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"topl.c\"
else
echo shar: Extracting \"topl.c\" \(4000 characters\)
sed "s/^X//" >topl.c <<'END_OF_topl.c'
X/*	SCCS Id: @(#)topl.c	2.0	87/09/15
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X
X#include <stdio.h>
X#include "hack.h"
X#ifdef GENIX
X#define	void	int	/* jhn - mod to prevent compiler from bombing */
X#endif
X
Xextern char *eos();
Xextern int CO;
X
Xchar toplines[BUFSIZ];
Xxchar tlx, tly;			/* set by pline; used by addtopl */
X
Xstruct topl {
X	struct topl *next_topl;
X	char *topl_text;
X} *old_toplines, *last_redone_topl;
X#define	OTLMAX	20		/* max nr of old toplines remembered */
X
Xdoredotopl(){
X	if(last_redone_topl)
X		last_redone_topl = last_redone_topl->next_topl;
X	if(!last_redone_topl)
X		last_redone_topl = old_toplines;
X	if(last_redone_topl){
X		(void) strcpy(toplines, last_redone_topl->topl_text);
X	}
X	redotoplin();
X	return(0);
X}
X
Xredotoplin() {
X	home();
X	if(index(toplines, '\n')) cl_end();
X	putstr(toplines);
X	cl_end();
X	tlx = curx;
X	tly = cury;
X	flags.toplin = 1;
X	if(tly > 1)
X		more();
X}
X
Xremember_topl() {
Xregister struct topl *tl;
Xregister int cnt = OTLMAX;
X	if(last_redone_topl &&
X	   !strcmp(toplines, last_redone_topl->topl_text)) return;
X	if(old_toplines &&
X	   !strcmp(toplines, old_toplines->topl_text)) return;
X	last_redone_topl = 0;
X	tl = (struct topl *)
X		alloc((unsigned)(strlen(toplines) + sizeof(struct topl) + 1));
X	tl->next_topl = old_toplines;
X	tl->topl_text = (char *)(tl + 1);
X	(void) strcpy(tl->topl_text, toplines);
X	old_toplines = tl;
X	while(cnt && tl){
X		cnt--;
X		tl = tl->next_topl;
X	}
X	if(tl && tl->next_topl){
X		free((char *) tl->next_topl);
X		tl->next_topl = 0;
X	}
X}
X
Xaddtopl(s) char *s; {
X	curs(tlx,tly);
X	if(tlx + strlen(s) > CO) putsym('\n');
X	putstr(s);
X	tlx = curx;
X	tly = cury;
X	flags.toplin = 1;
X}
X
Xxmore(s)
Xchar *s;	/* allowed chars besides space/return */
X{
X	if(flags.toplin) {
X		curs(tlx, tly);
X		if(tlx + 8 > CO) putsym('\n'), tly++;
X	}
X
X	if(flags.standout)
X		standoutbeg();
X	putstr("--More--");
X	if(flags.standout)
X		standoutend();
X
X	xwaitforspace(s);
X	if(flags.toplin && tly > 1) {
X		home();
X		cl_end();
X		docorner(1, tly-1);
X	}
X	flags.toplin = 0;
X}
X
Xmore(){
X	xmore("");
X}
X
Xcmore(s)
Xregister char *s;
X{
X	xmore(s);
X}
X
Xclrlin(){
X	if(flags.toplin) {
X		home();
X		cl_end();
X		if(tly > 1) docorner(1, tly-1);
X		remember_topl();
X	}
X	flags.toplin = 0;
X}
X
X/*VARARGS1*/
X/* Because the modified mstatusline has 9 arguments KAA */
Xpline(line,arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9)
Xregister char *line,*arg1,*arg2,*arg3,*arg4,*arg5,*arg6,*arg7,*arg8,*arg9;
X{
X	char pbuf[BUFSZ];
X	register char *bp = pbuf, *tl;
X	register int n,n0;
X
X	if(!line || !*line) return;
X	if(!index(line, '%')) (void) strcpy(pbuf,line); else
X	(void) sprintf(pbuf,line,arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
X	if(flags.toplin == 1 && !strcmp(pbuf, toplines)) return;
X	nscr();		/* %% */
X
X	/* If there is room on the line, print message on same line */
X	/* But messages like "You die..." deserve their own line */
X	n0 = strlen(bp);
X	if(flags.toplin == 1 && tly == 1 &&
X	    n0 + strlen(toplines) + 3 < CO-8 &&  /* leave room for --More-- */
X	    strncmp(bp, "You ", 4)) {
X		(void) strcat(toplines, "  ");
X		(void) strcat(toplines, bp);
X		tlx += 2;
X		addtopl(bp);
X		return;
X	}
X	if(flags.toplin == 1) more();
X	remember_topl();
X	toplines[0] = 0;
X	while(n0){
X		if(n0 >= CO){
X			/* look for appropriate cut point */
X			n0 = 0;
X			for(n = 0; n < CO; n++) if(bp[n] == ' ')
X				n0 = n;
X			if(!n0) for(n = 0; n < CO-1; n++)
X				if(!letter(bp[n])) n0 = n;
X			if(!n0) n0 = CO-2;
X		}
X		(void) strncpy((tl = eos(toplines)), bp, n0);
X		tl[n0] = 0;
X		bp += n0;
X
X		/* remove trailing spaces, but leave one */
X		while(n0 > 1 && tl[n0-1] == ' ' && tl[n0-2] == ' ')
X			tl[--n0] = 0;
X
X		n0 = strlen(bp);
X		if(n0 && tl[0]) (void) strcat(tl, "\n");
X	}
X	redotoplin();
X}
X
Xputsym(c) char c; {
X	switch(c) {
X	case '\b':
X		backsp();
X		return;
X	case '\n':
X		curx = 1;
X		cury++;
X		if(cury > tly) tly = cury;
X		break;
X	default:
X		if(curx == CO)
X			putsym('\n');	/* 1 <= curx <= CO; avoid CO */
X		else
X			curx++;
X	}
X	(void) putchar(c);
X}
X
Xputstr(s) register char *s; {
X	while(*s) putsym(*s++);
X}
END_OF_topl.c
if test 4000 -ne `wc -c <topl.c`; then
    echo shar: \"topl.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f wield.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"wield.c\"
else
echo shar: Extracting \"wield.c\" \(3472 characters\)
sed "s/^X//" >wield.c <<'END_OF_wield.c'
X/*	SCCS Id: @(#)wield.c	2.1	87/11/09
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X
X#include	"hack.h"
Xextern struct obj zeroobj;
Xextern char *hcolor();
X#ifdef KAA
Xextern boolean unweapon;
X#endif
X
Xsetuwep(obj) register struct obj *obj; {
X	setworn(obj, W_WEP);
X}
X
Xdowield()
X{
X	register struct obj *wep;
X	register int res = 0;
X
X	multi = 0;
X#ifdef KAA
X	if (cantwield(u.usym)) {
X		pline("Don't be ridiculous!");
X		return(0);
X	}
X#endif
X	if(!(wep = getobj("#-)", "wield"))) /* nothing */;
X	else if(wep == &zeroobj) {
X	  if(uwep == 0) {
X	    pline("You are already empty handed.");
X	  } else if (welded(uwep))
X		pline("The %s welded to your hand!",aobjnam(uwep,"are"));
X	  	else  {
X	  	  setuwep((struct obj *) 0);
X	  	  res++;
X	  	  pline("You are empty handed.");
X	  	}
X	} else if(uwep == wep)
X		pline("You are already wielding that!");
X	else if(welded(uwep))
X		pline("The %s welded to your hand!",
X			aobjnam(uwep, "are"));
X	/* Prevent wielding a cockatrice in pack when not wearing gloves KAA*/
X	else if (!uarmg && wep->otyp == DEAD_COCKATRICE) {
X		pline("You wield the dead cockatrice in your bare hands.");
X		pline("You turn to stone ...");
X		killer="dead cockatrice";
X		done("died");
X	} else if(uarms && wep->otyp == TWO_HANDED_SWORD)
X	pline("You cannot wield a two-handed sword and wear a shield.");
X	else if(wep->owornmask & (W_ARMOR | W_RING))
X		pline("You cannot wield that!");
X	else {
X		setuwep(wep);
X		res++;
X		if(welded(uwep))
X		    pline("The %s %s to your hand!",
X			aobjnam(uwep, "weld"),
X			(uwep->quan == 1) ? "itself" : "themselves"); /* a3 */
X		else prinv(uwep);
X	}
X#ifdef KAA
X	if(res && uwep)
X		unweapon = (uwep->otyp >= BOW || uwep->otyp <= BOOMERANG) ? 
X		TRUE : FALSE;
X#endif
X	return(res);
X}
X
Xcorrode_weapon(){
X	if(!uwep || uwep->olet != WEAPON_SYM) return;	/* %% */
X	if(uwep->rustfree)
X		pline("Your %s not affected.", aobjnam(uwep, "are"));
X	else if (uwep->spe > -6) {
X		pline("Your %s!", aobjnam(uwep, "corrode"));
X		uwep->spe--;
X	} else	pline("Your %s quite rusted now.", aobjnam(uwep, "look"));
X}
X
Xchwepon(otmp,amount)
Xregister struct obj *otmp;
Xregister amount;
X{
Xregister char *color = (amount < 0) ? "black" : "green";
Xregister char *time;
X
X	if(Hallucination) color=hcolor();
X	if(!uwep || uwep->olet != WEAPON_SYM) {
X		strange_feeling(otmp,
X			(amount > 0) ? "Your hands twitch."
X				     : "Your hands itch.");
X		return(0);
X	}
X
X	if(uwep->otyp == WORM_TOOTH && amount > 0) {
X		uwep->otyp = CRYSKNIFE;
X		pline("Your weapon seems sharper now.");
X		uwep->cursed = 0;
X		return(1);
X	}
X
X	if(uwep->otyp == CRYSKNIFE && amount < 0) {
X		uwep->otyp = WORM_TOOTH;
X		pline("Your weapon looks duller now.");
X		return(1);
X	}
X
X	/* there is a (soft) upper limit to uwep->spe */
X	if(amount > 0 && uwep->spe > 5 && rn2(3)) {
X	    pline("Your %s violently %s for a while and then evaporate%s.",
X		aobjnam(uwep,"glow"),Hallucination ? hcolor() : "green",
X		plur(uwep->quan));
X
X	    while(uwep)		/* let all of them disappear */
X				/* note: uwep->quan = 1 is nogood if unpaid */
X		useup(uwep);
X	    return(1);
X	}
X	if(!rn2(6)) amount *= 2;
X	time = (amount*amount == 1) ? "moment" : "while";
X	pline("Your %s %s for a %s.",
X		aobjnam(uwep, "glow"), color, time);
X	uwep->spe += amount;
X	if(amount > 0) uwep->cursed = 0;
X	return(1);
X}
X
Xint
Xwelded(obj) register struct obj *obj;  {
X	return(obj && obj == uwep && obj->cursed &&
X	       (obj->olet == WEAPON_SYM || obj->otyp == HEAVY_IRON_BALL ||
X		obj->otyp == CAN_OPENER || obj->otyp == PICK_AXE));
X}
END_OF_wield.c
if test 3472 -ne `wc -c <wield.c`; then
    echo shar: \"wield.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f you.h -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"you.h\"
else
echo shar: Extracting \"you.h\" \(3881 characters\)
sed "s/^X//" >you.h <<'END_OF_you.h'
X/*	SCCS Id: @(#)you.h	2.1	87/11/09
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X
X#ifndef YOU_H
X#define YOU_H
X
X#include "config.h"
X#include "onames.h"
X#include "permonst.h"
X
Xstruct prop {
X
X#define	TIMEOUT		007777	/* mask */
X#define	LEFT_RING	W_RINGL	/* 010000L */
X#define	RIGHT_RING	W_RINGR	/* 020000L */
X#define	INTRINSIC	040000L
X#define	LEFT_SIDE	LEFT_RING
X#define	RIGHT_SIDE	RIGHT_RING
X#define	BOTH_SIDES	(LEFT_SIDE | RIGHT_SIDE)
X
X	long p_flgs;
X	int (*p_tofn)();	/* called after timeout */
X};
X
Xstruct you {
X	xchar ux, uy;
X	schar dx, dy, dz;	/* direction of move (or zap or ... ) */
X	schar di;		/* direction of FF */
X	xchar ux0, uy0;		/* initial position FF */
X	xchar udisx, udisy;	/* last display pos */
X	char usym;		/* usually '@' */
X	schar uluck;
X#define	LUCKMAX		10	/* on moonlit nights 11 */
X#define	LUCKMIN		(-10)
X	int last_str_turn;	/* 0: none, 1: half turn, 2: full turn */
X				/* +: turn right, -: turn left */
X	unsigned udispl;	/* @ on display */
X	unsigned ulevel;	/* 1 - 14 */
X#ifdef QUEST
X	unsigned uhorizon;
X#endif
X	unsigned utrap;		/* trap timeout */
X	unsigned utraptype;	/* defined if utrap nonzero */
X#define	TT_BEARTRAP	0
X#define	TT_PIT		1
X#ifdef SPIDERS
X#define	TT_WEB		2
X#endif
X	unsigned uinshop;	/* used only in shk.c - (roomno+1) of shop */
X
X/* perhaps these #define's should also be generated by makedefs */
X#define	TELEPAT		LAST_RING		/* not a ring */
X#define	HTelepat	u.uprops[TELEPAT].p_flgs
X#define	Telepat		((HTelepat) || (u.usym == 'E'))
X#define	FAST		(LAST_RING+1)		/* not a ring */
X#define	Fast		u.uprops[FAST].p_flgs
X#define	CONFUSION	(LAST_RING+2)		/* not a ring */
X#define	HConfusion	u.uprops[CONFUSION].p_flgs
X#define Confusion	((HConfusion) || index("BIy", u.usym))
X#define	INVIS		(LAST_RING+3)		/* not a ring */
X#define	HInvis		u.uprops[INVIS].p_flgs
X#define Invis		((HInvis) || u.usym == 'I')
X#define Invisible	(Invis && !See_invisible)
X#define	GLIB		(LAST_RING+4)		/* not a ring */
X#define	Glib		u.uprops[GLIB].p_flgs
X#define	PUNISHED	(LAST_RING+5)		/* not a ring */
X#define	Punished	u.uprops[PUNISHED].p_flgs
X#define	SICK		(LAST_RING+6)		/* not a ring */
X#define	Sick		u.uprops[SICK].p_flgs
X#define	BLINDED		(LAST_RING+7)		/* not a ring */
X#define	Blinded		u.uprops[BLINDED].p_flgs
X#define	WOUNDED_LEGS	(LAST_RING+8)		/* not a ring */
X#define Wounded_legs	u.uprops[WOUNDED_LEGS].p_flgs
X#define STONED		(LAST_RING+9)		/* not a ring */
X#define Stoned		u.uprops[STONED].p_flgs
X#define HALLUCINATION	(LAST_RING+10)		/* not a ring */
X#define Hallucination	u.uprops[HALLUCINATION].p_flgs
X#define	BLINDFOLDED	(LAST_RING+11)		/* not a ring */
X#define	Blindfolded	u.uprops[BLINDFOLDED].p_flgs
X#define Blind		(Blinded || Blindfolded)
X#define PROP(x) (x-RIN_ADORNMENT)       /* convert ring to index in uprops */
X	struct prop uprops[LAST_RING+11];
X
X	unsigned umconf;
X	char *usick_cause;
X	int mh, mhmax, mtimedone, umonnum;	/* for polymorph-self */
X	schar mstr, mstrmax;			/* for saving ustr/ustrmax */
X#if defined(KOPS) && defined(KAA)
X	unsigned ucreamed;
X#endif
X	unsigned uswallow;		/* set if swallowed by a monster */
X	unsigned uswldtim;		/* time you have been swallowed */
X	unsigned uhs;			/* hunger state - see hack.eat.c */
X#ifdef HARD
X	unsigned udemigod;		/* once you kill the wiz */
X	unsigned udg_cnt;		/* how long you have been demigod */
X#endif
X#ifdef RPH
X	int medusa_level;		/* level of wiz and medusa */
X	int wiz_level;
X#endif	
X	schar ustr,ustrmax;
X	schar udaminc;
X	schar uac;
X	int uhp,uhpmax;
X#ifdef SPELLS
X	int uen,uenmax;			/* magical energy - M. Stephenson */
X#endif
X#ifdef PRAYERS
X	int ugangr;			/* if the gods are angry at you */
X	int ublessed,ublesscnt;		/* blessing/duration from #pray */
X#endif
X	long int ugold,ugold0,uexp,urexp;
X	int uhunger;			/* refd only in eat.c and shk.c */
X	int uinvault;
X	struct monst *ustuck;
X	int nr_killed[CMNUM+2];		/* used for experience bookkeeping */
X};
X
X#endif /* YOU_H /**/
END_OF_you.h
if test 3881 -ne `wc -c <you.h`; then
    echo shar: \"you.h\" unpacked with wrong size!
fi
# end of overwriting check
fi
echo shar: End of archive 19 \(of 20\).
cp /dev/null ark19isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 20 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
