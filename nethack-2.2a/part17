Relay-Version: version B 2.10 5/3/83; site utzoo.UUCP
Path: utzoo!mnetor!uunet!tektronix!tekgen!tekred!games-request
From: games-request@tekred.TEK.COM
Newsgroups: comp.sources.games
Subject: v03i017:  NetHack2.2 - display oriented dungeons and dragons, Part17/20
Message-ID: <1904@tekred.TEK.COM>
Date: Thu, 3-Dec-87 11:57:06 EST
Article-I.D.: tekred.1904
Posted: Thu Dec  3 11:57:06 1987
Date-Received: Wed, 9-Dec-87 23:34:22 EST
Sender: billr@tekred.TEK.COM
Lines: 2147
Approved: billr@tekred.TEK.COM

Submitted by: mike@genat.UUCP (Mike Stephenson)
Comp.sources.games: Volume 3, Issue 17
Archive-name: nethack2.2/Part17



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 17 (of 20)."
# Contents:  Makefile.unix Makefile.xenix dothrow.c mkshop.c o_init.c
#   polyself.c pray.c vault.c
# Wrapped by billr@tekred on Tue Dec  1 16:25:13 1987
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f Makefile.unix -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"Makefile.unix\"
else
echo shar: Extracting \"Makefile.unix\" \(7451 characters\)
sed "s/^X//" >Makefile.unix <<'END_OF_Makefile.unix'
X#	Hack or Quest Makefile.
X#	SCCS Id: @(#)Makefile.unix	2.1	87/10/08
X
X# if you are cross-compiling (eg. from Xenix into a Dos enviornment)
X# you will have to redefine these filenames.
XMAIN = unixmain.c
XTTY  = unixtty.c
XUNIX = unixunix.c
X
X# flags may have to be changed as required
XCFLAGS = -O
XLFLAGS =
X
X# on some systems the termcap library is in -ltermcap
XTERMLIB = -ltermlib
X
X# make NetHack
XGAME     = nethack
XGAMEUID  = games
XGAMEGRP  = bin
X
X#	GAMEDIR also appears in config.h as "HACKDIR".
XGAMEDIR  = /usr/games/lib/$(GAME)dir
XSHELLDIR = /usr/games
XMANDIR   = /usr/man/man6
XMANEXT   = 6
X
XHACKCSRC = alloc.c apply.c bones.c cmd.c decl.c do.c do_name.c do_wear.c\
X	dog.c dogmove.c dothrow.c eat.c end.c engrave.c fight.c fountain.c\
X	hack.c invent.c ioctl.c lev.c main.c makemon.c mhitu.c\
X	mklev.c mkmaze.c mkobj.c mkshop.c mon.c monmove.c monst.c o_init.c\
X	objnam.c options.c pager.c polyself.c potion.c pray.c pri.c\
X	prisym.c read.c rip.c rnd.c rumors.c save.c search.c shk.c shknam.c\
X	sit.c spell.c steal.c termcap.c timeout.c topl.c topten.c track.c\
X	trap.c tty.c u_init.c unix.c vault.c version.c wield.c wizard.c\
X	worm.c worn.c write.c zap.c
X
XCSOURCES = $(HACKCSRC) makedefs.c
X
XHSOURCES = config.h date.h edog.h eshk.h extern.h flag.h func_tab.h\
X	gen.h gold.h hack.h mfndpos.h mkroom.h monst.h msdos.h\
X	obj.h objclass.h objects.h onames.h permonst.h rm.h\
X	spell.h trap.h wseg.h you.h
X
XSOURCES = $(CSOURCES) $(HSOURCES)
X
XSPECIFICS = main.o tty.o unix.o
XAUX = help hh nethack.6 nethack.sh
XVARAUX = data rumors
X
XDISTR = $(SOURCES) $(AUX) $(VARAUX) README.OLD README\
X	Makefile Makefile.pc Make.ini
X
XHOBJ = alloc.o apply.o bones.o cmd.o decl.o do.o do_name.o do_wear.o\
X	dog.o dogmove.o dothrow.o eat.o end.o engrave.o fight.o fountain.o\
X	hack.o invent.o ioctl.o lev.o main.o makemon.o mhitu.o\
X	mklev.o mkmaze.o mkobj.o mkshop.o mon.o monmove.o monst.o o_init.o\
X	objnam.o options.o pager.o polyself.o potion.o pray.o pri.o\
X	prisym.o read.o rip.o rnd.o rumors.o save.o search.o shk.o shknam.o\
X	sit.o spell.o steal.o termcap.o timeout.o topl.o topten.o track.o\
X	trap.o tty.o u_init.o unix.o vault.o version.o wield.o wizard.o\
X	worm.o worn.o write.o zap.o
X
X$(GAME):	$(SPECIFICS) $(HOBJ) Makefile
X	@echo "Loading ..."
X	@cc $(LFLAGS) -o $(GAME) $(HOBJ) $(TERMLIB)
X
Xall:	$(GAME) Guidebook lint
X	@echo "Done."
X
XGuidebook:	Guidebook.mn
X	nroff -mn Guidebook.mn > Guidebook
X
Xmakedefs:	makedefs.c alloc.o config.h
X	cc -o makedefs alloc.o makedefs.c
X
XRUMORFILES= rumors.base rumors.kaa rumors.mrx
X
Xrumors:	config.h $(RUMORFILES) makedefs
X	./makedefs -r
X
Xdata:	config.h data.base makedefs
X	./makedefs -d
X
Xdate.h:	$(SOURCES) makedefs
X	./makedefs -D
X
Xtrap.h:	config.h makedefs
X	./makedefs -t
X
Xonames.h:	makedefs objects.h
X	./makedefs -o
X
Xmain.o:
X
Xmain.c:	unixmain.c hack.h
X	cp $(MAIN) main.c
X
Xtty.o:
X
Xtty.c:	unixtty.c hack.h func_tab.h
X	cp $(TTY) tty.c
X
Xunix.o:
X
Xunix.c:	unixunix.c hack.h mkroom.h
X	cp $(UNIX) unix.c
X
Xlint:
X# lint cannot have -p here because (i) capitals are meaningful:
X# [Ww]izard, (ii) identifiers may coincide in the first six places:
X# doweararm() versus dowearring().
X# _flsbuf comes from <stdio.h>, a bug in the system libraries.
X	@echo lint -axbh -DLINT ...
X	@lint -axbh -DLINT $(HACKCSRC) | sed '/_flsbuf/d'
X
X
Xdiff:
X	@- for i in $(SOURCES) $(AUX) ; do \
X		cmp -s $$i $D/$$i || \
X		( echo diff $D/$$i $$i ; diff $D/$$i $$i ; echo ) ; done
X
Xdistribution: Makefile
X	@- for i in READ_ME $(SOURCES) $(AUX) Makefile date.h onames.h\
X		; do \
X		cmp -s $$i $D/$$i || \
X		( echo cp $$i $D ; cp $$i $D ) ; done
X# the distribution directory also contains the empty files perm and record.
X
Xinitial:
X	-rm -rf $(GAMEDIR)
X	-mkdir $(SHELLDIR)
X	mkdir $(GAMEDIR) $(GAMEDIR)/save
X	touch $(GAMEDIR)/perm
X	touch $(GAMEDIR)/record
X	chown $(GAMEUID) $(SHELLDIR)/$(GAME) $(GAMEDIR) $(GAMEDIR)/*
X	chgrp $(GAMEGRP) $(SHELLDIR)/$(GAME) $(GAMEDIR) $(GAMEDIR)/*
X	chmod 666 $(GAMEDIR)/*
X	chmod 777 $(GAMEDIR) $(GAMEDIR)/save
X
Xinstall: $(VARAUX) $(GAME)
X	-mkdir $(GAMEDIR)
X	-mkdir $(GAMEDIR)/save
X	-rm -f $(GAMEDIR)/$(GAME)
X	-rm -f $(GAMEDIR)/bones* $(GAMEDIR)/alock* $(GAMEDIR)/wizard*
X	-rm -f $(GAMEDIR)/save/*
X	touch $(GAMEDIR)/perm $(GAMEDIR)/record
X	cp help hh rumors data $(GAMEDIR)
X	cp $(GAME).sh $(SHELLDIR)/$(GAME)
X	cp $(GAME) $(GAMEDIR)/$(GAME)
X	chown $(GAMEUID) $(SHELLDIR)/$(GAME) $(GAMEDIR)/*
X	chgrp $(GAMEGRP) $(SHELLDIR)/$(GAME) $(GAMEDIR)/*
X	chmod 0755 $(SHELLDIR)/$(GAME)
X	chmod 04755 $(GAMEDIR)/$(GAME)
X	-cp nethack.6 $(MANDIR)/$(GAME).$(MANEXT)
X
Xdebug:
X	ln $(GAMEDIR)/$(GAME) a.out
X	ln $(GAMEDIR)/core core
X
Xtags: $(SOURCES)
X	@echo ctags -tw ...
X	@ctags -tw $(SOURCES)
X  
Xclean:
X	rm -f *.o
X
Xspotless: clean
X	rm -f a.out core $(GAME) makedefs
X	rm -f Makefile $(VARAUX) main.c tty.c unix.c
X
Xdepend:
X# For the moment we are lazy and disregard /usr/include files because
X# the sources contain them conditionally. Perhaps we should use cpp.
X#		( /bin/grep '^#[ 	]*include' $$i | sed -n \
X#			-e 's,<\(.*\)>,"/usr/include/\1",' \
X#
X	for i in ${CSOURCES}; do \
X		( /bin/grep '^#[ 	]*include[ 	]*"' $$i | sed -n \
X			-e 's/[^"]*"\([^"]*\)".*/\1/' \
X			-e H -e '$$g' -e '$$s/\n/ /g' \
X			-e '$$s/.*/'$$i': &/' -e '$$s/\.c:/.o:/p' \
X			>> makedep); done
X	for i in ${HSOURCES}; do \
X		( /bin/grep '^#[ 	]*include[ 	]*"' $$i | sed -n \
X			-e 's/[^"]*"\([^"]*\)".*/\1/' \
X			-e H -e '$$g' -e '$$s/\n/ /g' \
X			-e '$$s/.*/'$$i': &\
X				touch '$$i/p \
X			>> makedep); done
X	@echo '/^# DO NOT DELETE THIS LINE/+2,$$d' >eddep
X	@echo '$$r makedep' >>eddep
X	@echo 'w' >>eddep
X	@cp Makefile Makefile.bak
X	ed - Makefile < eddep
X	@rm -f eddep makedep
X	@echo '# DEPENDENCIES MUST END AT END OF FILE' >> Makefile
X	@echo '# IF YOU PUT STUFF HERE IT WILL GO AWAY' >> Makefile
X	@echo '# see make depend above' >> Makefile
X	- diff Makefile Makefile.bak
X	@rm -f Makefile.bak
X
X# DO NOT DELETE THIS LINE
X
Xdecl.o:  hack.h mkroom.h
Xapply.o:  hack.h edog.h mkroom.h
Xbones.o:  hack.h
Xhack.o:  hack.h
Xcmd.o:  hack.h func_tab.h
Xdo.o:  hack.h
Xdo_name.o:  hack.h
Xdo_wear.o:  hack.h
Xdog.o:  hack.h edog.h mkroom.h
Xdogmove.o:  hack.h mfndpos.h edog.h mkroom.h
Xdothrow.o:  hack.h
Xeat.o:  hack.h
Xend.o:  hack.h
Xengrave.o:  hack.h
Xfight.o:  hack.h
Xfountain.o:  hack.h mkroom.h
Xinvent.o:  hack.h wseg.h
Xioctl.o:  config.h
Xlev.o:  hack.h mkroom.h wseg.h
Xmakemon.o:  hack.h
Xmhitu.o:  hack.h
Xmklev.o:  hack.h mkroom.h
Xmkmaze.o:  hack.h mkroom.h
Xmkobj.o:  hack.h
Xmkshop.o:  hack.h mkroom.h eshk.h
Xmon.o:  hack.h mfndpos.h
Xmonmove.o:  hack.h mfndpos.h
Xmonst.o:  hack.h eshk.h
Xo_init.o:  config.h objects.h onames.h
Xobjnam.o:  hack.h
Xoptions.o:  hack.h
Xpager.o:  hack.h
Xpolyself.o: hack.h
Xpotion.o:  hack.h
Xpray.o:  hack.h
Xpri.o:  hack.h
Xprisym.o:  hack.h wseg.h
Xread.o:  hack.h
Xrip.o:  hack.h
Xrumors.o:  hack.h
Xsave.o:  hack.h
Xsearch.o:  hack.h
Xshk.o:  hack.h mfndpos.h mkroom.h eshk.h
Xshknam.o:  hack.h
Xsit.o: hack.h
Xspell.o:  hack.h
Xsteal.o:  hack.h
Xtermcap.o:  hack.h
Xtimeout.o:  hack.h
Xtopl.o:  hack.h
Xtopten.o:  hack.h
Xtrack.o:  hack.h
Xtrap.o:  hack.h edog.h mkroom.h
Xu_init.o:  hack.h
Xvault.o:  hack.h mkroom.h
Xwield.o:  hack.h
Xwizard.o:  hack.h
Xworm.o:  hack.h wseg.h
Xworn.o:  hack.h
Xwrite.o:  hack.h
Xzap.o:  hack.h
Xversion.o:  hack.h date.h
Xextern.h: config.h spell.h obj.h
X	touch extern.h
Xhack.h: extern.h flag.h gold.h monst.h objclass.h rm.h trap.h you.h 
X	touch hack.h
Xobjects.h:  config.h objclass.h
X	touch objects.h
Xyou.h: config.h onames.h permonst.h 
X	touch you.h
X# DEPENDENCIES MUST END AT END OF FILE
X# IF YOU PUT STUFF HERE IT WILL GO AWAY
X# see make depend above
END_OF_Makefile.unix
if test 7451 -ne `wc -c <Makefile.unix`; then
    echo shar: \"Makefile.unix\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f Makefile.xenix -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"Makefile.xenix\"
else
echo shar: Extracting \"Makefile.xenix\" \(6167 characters\)
sed "s/^X//" >Makefile.xenix <<'END_OF_Makefile.xenix'
X#	Hack or Quest Makefile.
X#	SCCS Id: @(#)Makefile.xenix	2.1	87/10/08
X
X# if you are cross-compiling (eg. from Xenix into a Dos enviornment)
X# you will have to redefine these filenames.
XMAIN = unixmain.c
XTTY  = unixtty.c
XUNIX = unixunix.c
X
X# on some systems the termcap library is in -ltermcap
XTERMLIB = -ltermlib
XCRT0   =
XLIBS = ${TERMLIB} 
X
X# flags may have to be changed as required
XCFLAGS = -LARGE -Ml
XLFLAGS = -Ml
X
X# make NetHack
XGAME     = nethack
XGAMEUID  = games
XGAMEGRP  = bin
XGAMEDIR  = /usr/games/lib/$(GAME)dir
XSHELLDIR = /usr/games
XMANDIR   = /usr/man/manl
XMANEXT   = l
X
XHACKCSRC = apply.c bones.c decl.c\
X	cmd.c do.c dothrow.c do_name.c do_wear.c dog.c dogmove.c eat.c end.c\
X	engrave.c fight.c fountain.c hack.c invent.c ioctl.c lev.c main.c\
X	makemon.c mhitu.c mklev.c mkmaze.c mkobj.c mkshop.c\
X	mon.c monmove.c monst.c o_init.c objnam.c options.c\
X	pager.c polyself.c potion.c pray.c pri.c prisym.c read.c rip.c\
X	rumors.c save.c search.c shk.c shknam.c sit.c spell.c steal.c\
X	termcap.c timeout.c topl.c topten.c track.c trap.c tty.c unix.c\
X	u_init.c vault.c wield.c wizard.c worm.c worn.c write.c zap.c\
X	version.c rnd.c alloc.c
X
XCSOURCES = $(HACKCSRC) makedefs.c
X
XHSOURCES = hack.h mfndpos.h config.h edog.h eshk.h extern.h\
X	flag.h func_tab.h gold.h mkroom.h monst.h obj.h\
X	objclass.h objects.h permonst.h rm.h spell.h trap.h wseg.h you.h
X
XSOURCES = $(CSOURCES) $(HSOURCES)
X
XAUX = help hh nethack.6 nethack.sh
XVARAUX = data rumors
XSPECIFICS = main.o tty.o unix.o
X
XDISTR = $(SOURCES) $(AUX) $(VARAUX) README.OLD README\
X	Makefile.unix Makefile.xenix Makefile.pc Make.ini
X
XHOBJ = apply.o bones.o decl.o cmd.o do.o dothrow.o do_name.o do_wear.o dog.o\
X	dogmove.o eat.o end.o engrave.o fight.o fountain.o hack.o\
X	invent.o ioctl.o lev.o main.o makemon.o mhitu.o mklev.o\
X	mkmaze.o mkobj.o mkshop.o mon.o monmove.o monst.o\
X	o_init.o objnam.o options.o pager.o polyself.o potion.o pray.o\
X	pri.o prisym.o read.o rip.o rumors.o save.o search.o shk.o shknam.o\
X	sit.o spell.o steal.o termcap.o timeout.o topl.o topten.o track.o\
X	trap.o tty.o unix.o u_init.o vault.o wield.o wizard.o worm.o worn.o\
X	write.o zap.o version.o rnd.o alloc.o
X
X.c.o:
X	cc -O -c -Gt24 ${CFLAGS} $*.c
X
X$(GAME):	$(SPECIFICS) $(HOBJ) Makefile
X	cc $(LFLAGS) -m hack.map -o $(GAME) /lib/Lsignal.o $(CRT0) $(HOBJ) $(LIBS) -SEG#256
X
X	
Xall:	$(GAME) lint
X	@echo "Done."
X
Xmakedefs:	makedefs.c Salloc.o config.h
X	cc -O -o makedefs Salloc.o makedefs.c
X
XSalloc.o:	alloc.c
X	cp alloc.c Salloc.c
X	cc -O -c Salloc.c
Xpc: 
X	cd dos; make
X
XRUMORFILES= rumors.base rumors.kaa rumors.mrx
X
Xrumors:	config.h $(RUMORFILES) makedefs
X	./makedefs -r
X
Xdata:	config.h data.base makedefs
X	./makedefs -d
X
Xdate.h:	$(SOURCES) makedefs
X	./makedefs -D
X
Xtrap.h:	config.h makedefs
X	./makedefs -t
X
Xonames.h:	makedefs objects.h
X	./makedefs -o
X
Xmain.o: main.c
X
Xmain.c:	unixmain.c hack.h
X	cp ${MAIN} main.c
X
Xtty.o:	tty.c
X	cc ${CFLAGS} -c tty.c
X
Xtty.c:	unixtty.c extern.h
X	cp ${TTY} tty.c
X
Xunix.c:	unixunix.c hack.h mkroom.h
X	cp ${UNIX} unix.c
X
Xlint:
X# lint cannot have -p here because (i) capitals are meaningful:
X# [Ww]izard, (ii) identifiers may coincide in the first six places:
X# doweararm() versus dowearring().
X# _flsbuf comes from <stdio.h>, a bug in the system libraries.
X	@echo lint -axbh -DLINT ...
X	@lint -axbh -DLINT $(HACKCSRC) | sed '/_flsbuf/d'
X
X
Xdiff:
X	@- for i in $(SOURCES) $(AUX) ; do \
X		cmp -s $$i $D/$$i || \
X		( echo diff $D/$$i $$i ; diff $D/$$i $$i ; echo ) ; done
X
Xdistribution: Makefile
X	@- for i in READ_ME $(SOURCES) $(AUX) Makefile date.h onames.h\
X		; do \
X		cmp -s $$i $D/$$i || \
X		( echo cp $$i $D ; cp $$i $D ) ; done
X# the distribution directory also contains the empty files perm and record.
X
Xinitial:
X	-rm -rf $(GAMEDIR)
X	-mkdir $(SHELLDIR)
X	mkdir $(GAMEDIR) $(GAMEDIR)/save
X	touch $(GAMEDIR)/perm
X	touch $(GAMEDIR)/record
X	chown $(GAMEUID) $(GAMEDIR) $(GAMEDIR)/*
X	chgrp $(GAMEGRP) $(GAMEDIR) $(GAMEDIR)/*
X	chmod 666 $(GAMEDIR)/*
X	chmod 777 $(GAMEDIR) $(GAMEDIR)/save
X
Xinstall: $(VARAUX) $(GAME)
X	-rm -f $(GAMEDIR)/$(GAME)
X	-rm -f $(GAMEDIR)/bones* $(GAMEDIR)/alock* $(GAMEDIR)/wizard*
X	-rm -f $(GAMEDIR)/save/*
X	cp help hh rumors data $(GAMEDIR)
X	cp $(GAME).sh $(SHELLDIR)/$(GAME)
X	cp $(GAME) $(GAMEDIR)/$(GAME)
X	chown $(GAMEUID) $(SHELLDIR)/$(GAME) $(GAMEDIR) $(GAMEDIR)/*
X	chgrp $(GAMEGRP) $(SHELLDIR)/$(GAME) $(GAMEDIR) $(GAMEDIR)/*
X	chmod 0755 $(SHELLDIR)/$(GAME)
X	chmod 04755 $(GAMEDIR)/$(GAME)
X	-cp nethack.6 $(MANDIR)/$(GAME).$(MANEXT)
X
Xdebug:
X	ln $(GAMEDIR)/$(GAME) a.out
X	ln $(GAMEDIR)/core core
X
Xclean:
X	rm -f *.o
X
Xspotless: clean
X	rm -f a.out core $(GAME) makedefs
X	rm -f Makefile $(VARAUX) main.c tty.c unix.c
X
Xdecl.o:  hack.h mkroom.h
Xapply.o:  hack.h edog.h mkroom.h
Xbones.o:  hack.h
Xhack.o:  hack.h
Xcmd.o:  hack.h func_tab.h
Xdo.o:  hack.h
Xdo_name.o:  hack.h
Xdo_wear.o:  hack.h
Xdog.o:  hack.h edog.h mkroom.h
Xdogmove.o:  hack.h mfndpos.h edog.h mkroom.h
Xdothrow.o:  hack.h
Xeat.o:  hack.h
Xend.o:  hack.h
Xengrave.o:  hack.h
Xfight.o:  hack.h
Xfountain.o:  hack.h mkroom.h
Xinvent.o:  hack.h wseg.h
Xioctl.o:  config.h
Xlev.o:  hack.h mkroom.h wseg.h
Xmakemon.o:  hack.h
Xmhitu.o:  hack.h
Xmklev.o:  hack.h mkroom.h
Xmkmaze.o:  hack.h mkroom.h
Xmkobj.o:  hack.h
Xmkshop.o:  hack.h mkroom.h eshk.h
Xmon.o:  hack.h mfndpos.h
Xmonmove.o:  hack.h mfndpos.h
Xmonst.o:  hack.h eshk.h
Xo_init.o:  config.h objects.h onames.h
Xobjnam.o:  hack.h
Xoptions.o:  hack.h
Xpager.o:  hack.h
Xpolyself.o: hack.h
Xpotion.o:  hack.h
Xpray.o:  hack.h
Xpri.o:  hack.h
Xprisym.o:  hack.h wseg.h
Xread.o:  hack.h
Xrip.o:  hack.h
Xrumors.o:  hack.h
Xsave.o:  hack.h
Xsearch.o:  hack.h
Xshk.o:  hack.h mfndpos.h mkroom.h eshk.h
Xshknam.o:  hack.h
Xsit.o: hack.h
Xspell.o:  hack.h
Xsteal.o:  hack.h
Xtermcap.o:  hack.h
Xtimeout.o:  hack.h
Xtopl.o:  hack.h
Xtopten.o:  hack.h
Xtrack.o:  hack.h
Xtrap.o:  hack.h edog.h mkroom.h
Xu_init.o:  hack.h
Xvault.o:  hack.h mkroom.h
Xwield.o:  hack.h
Xwizard.o:  hack.h
Xworm.o:  hack.h wseg.h
Xworn.o:  hack.h
Xwrite.o:  hack.h
Xzap.o:  hack.h
Xversion.o:  hack.h date.h
Xextern.h: config.h spell.h obj.h
X	touch extern.h
Xhack.h: extern.h flag.h gold.h monst.h objclass.h rm.h trap.h you.h 
X	touch hack.h
Xobjects.h:  config.h objclass.h
X	touch objects.h
Xyou.h: config.h onames.h permonst.h 
X	touch you.h
END_OF_Makefile.xenix
if test 6167 -ne `wc -c <Makefile.xenix`; then
    echo shar: \"Makefile.xenix\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f dothrow.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"dothrow.c\"
else
echo shar: Extracting \"dothrow.c\" \(7031 characters\)
sed "s/^X//" >dothrow.c <<'END_OF_dothrow.c'
X/*	SCCS Id: @(#)dothrow.c	2.1	87/11/01
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* dothrow.c - version 1.0 */
X
X/* Contains code for 't' (throw) */
X
X#include "hack.h"
X
Xextern struct obj *splitobj(), *addinv();
Xextern boolean hmon();
Xextern struct monst youmonst;
Xextern char *Doname();
X#ifdef KAA
Xextern char *xname();
X#endif
X
Xstruct monst *bhit(), *boomhit();
Xdothrow()
X{
X	register struct obj *obj;
X
X	obj = getobj("#)", "throw");   /* it is also possible to throw food */
X				       /* (or jewels, or iron balls ... ) */
X	if(!obj || !getdir(1))	       /* ask "in what direction?" */
X		return(0);
X	if(obj->owornmask & (W_ARMOR | W_RING)){
X		pline("You can't throw something you are wearing.");
X		return(0);
X	}
X#ifdef KAA
X	if(obj->otyp == ENORMOUS_ROCK && u.usym != '9') {
X		pline("It's too heavy.");
X		return(1);
X	}
X	if(!u.dx && !u.dy && !u.dz) {
X		pline("You cannot throw an object at yourself.");
X		return(0);
X	}
X#endif
X	u_wipe_engr(2);
X
X	if(obj == uwep){
X		if(obj->cursed){
X			pline("Your weapon is welded to your hand.");
X			return(1);
X		}
X		if(obj->quan > 1)
X			setuwep(splitobj(obj, 1));
X		else
X			setuwep((struct obj *) 0);
X	}
X	else if(obj->quan > 1)
X		(void) splitobj(obj, 1);
X	freeinv(obj);
X	return(throwit(obj));
X}
X
Xthrowit(obj)
X	register struct obj *obj;
X{
X	register struct monst *mon;
X
X	if(u.uswallow) {
X		mon = u.ustuck;
X		bhitpos.x = mon->mx;
X		bhitpos.y = mon->my;
X	} else if(u.dz) {
X	  if(u.dz < 0) {
X	    pline("%s hits the ceiling, then falls back on top of your head.",
X		Doname(obj));		/* note: obj->quan == 1 */
X	    if(obj->olet == POTION_SYM)
X		potionhit(&youmonst, obj);
X	    else {
X		if(uarmh) pline("Fortunately, you are wearing a helmet!");
X		losehp(uarmh ? 1 : rnd((int)(obj->owt)), "falling object");
X		dropy(obj);
X	    }
X	  } else hitfloor(obj);
X	  return(1);
X
X	} else if(obj->otyp == BOOMERANG) {
X		mon = boomhit(u.dx, u.dy);
X		if(mon == &youmonst) {		/* the thing was caught */
X			(void) addinv(obj);
X			return(1);
X		}
X	} else {
X		if(obj->otyp == PICK_AXE && shkcatch(obj))
X		    return(1);
X
X		mon = bhit(u.dx, u.dy, (obj->otyp == ICE_BOX) ? 1 :
X			(!Punished || obj != uball) ? 8 : !u.ustuck ? 5 : 1,
X			obj->olet,
X			(int (*)()) 0, (int (*)()) 0, obj);
X	}
X	if(mon) {
X		/* awake monster if sleeping */
X		wakeup(mon);
X		if(thitmonst(mon, obj)) return(1);
X	}
X	if(!u.uswallow)  {
X		/* the code following might become part of dropy() */
X		if(obj->otyp == CRYSKNIFE)
X			obj->otyp = WORM_TOOTH;
X		obj->ox = bhitpos.x;
X		obj->oy = bhitpos.y;
X		obj->nobj = fobj;
X		fobj = obj;
X		/* prevent him from throwing articles to the exit and escaping */
X		/* subfrombill(obj); */
X		stackobj(obj);
X		if(Punished && obj == uball &&
X			(bhitpos.x != u.ux || bhitpos.y != u.uy)){
X			freeobj(uchain);
X			unpobj(uchain);
X			if(u.utrap){
X				if(u.utraptype == TT_PIT)
X					pline("The ball pulls you out of the pit!");
X#ifdef SPIDERS
X				else if(u.utraptype == TT_WEB)  {
X					pline("The ball pulls you out of the web!");
X					pline("The web is destroyed!");
X					deltrap(t_at(u.ux,u.uy));
X				}
X#endif
X				else  {
X				register long side =
X					rn2(3) ? LEFT_SIDE : RIGHT_SIDE;
X				pline("The ball pulls you out of the bear trap.");
X				pline("Your %s leg is severely damaged.",
X					(side == LEFT_SIDE) ? "left" : "right");                                set_wounded_legs(side, 500+rn2(1000));
X				losehp(2, "thrown ball");
X				}
X				u.utrap = 0;
X			}        
X			unsee();
X			uchain->nobj = fobj;
X			fobj = uchain;
X			u.ux = uchain->ox = bhitpos.x - u.dx;
X			u.uy = uchain->oy = bhitpos.y - u.dy;
X			setsee();
X			(void) inshop();
X		}
X		if(cansee(bhitpos.x, bhitpos.y)) prl(bhitpos.x,bhitpos.y);
X	}  else  
X		mpickobj(u.ustuck,obj);
X	return(1);
X}
X
Xhitfloor(obj)
X	register struct obj *obj;
X{
X	pline("%s hits the floor.", Doname(obj));
X	if(obj->otyp == EXPENSIVE_CAMERA) {
X		pline("It is shattered in a thousand pieces!");
X		obfree(obj, Null(obj));
X#ifdef RPH
X	} else	if(obj->otyp == MIRROR) {
X	    	pline ("The mirror shatters.  That's seven years bad luck!");
X		obfree(obj, Null(obj));
X		u.uluck -= 2;
X		if ((int)u.uluck < LUCKMIN) u.uluck = LUCKMIN;
X#endif	
X	} else	if(obj->otyp == EGG) {
X		pline("\"Splash!\"");
X		obfree(obj, Null(obj));
X#ifdef KAA
X	} else	if(obj->otyp == CREAM_PIE) {
X		pline("What a mess!");
X		obfree(obj, Null(obj));
X#endif
X	} else	if(obj->olet == POTION_SYM) {
X		pline("The flask breaks, and you smell a peculiar odor ...");
X		potionbreathe(obj);
X		obfree(obj, Null(obj));
X	} else
X		dropy(obj);
X}
X
Xthitmonst(mon, obj)
X	register struct monst *mon;
X	register struct obj   *obj;
X{
X	register int	tmp;
X
X	if(obj->olet == WEAPON_SYM) {
X		tmp = -1+u.ulevel+mon->data->ac+abon();
X		if(obj->otyp < DART) {
X			if(!uwep ||
X			    uwep->otyp != obj->otyp+(BOW-ARROW))
X				tmp -= 4;
X			else {
X				tmp += uwep->spe;
X			}
X		} else
X		if(obj->otyp == BOOMERANG) tmp += 4;
X		tmp += obj->spe;
X		if(u.uswallow || tmp >= rnd(20)) {
X			if(hmon(mon,obj,1) == TRUE){
X			  /* mon still alive */
X#ifndef NOWORM
X			  cutworm(mon,bhitpos.x,bhitpos.y,obj->otyp);
X#endif
X			} else mon = 0;
X			/* weapons thrown disappear sometimes */
X			if(obj->otyp < BOOMERANG && rn2(3)) {
X				/* check bill; free */
X				obfree(obj, (struct obj *) 0);
X				return(1);
X			}
X		} else miss(objects[obj->otyp].oc_name, mon);
X	} else if(obj->otyp == HEAVY_IRON_BALL) {
X		tmp = -1+u.ulevel+mon->data->ac+abon();
X		if(!Punished || obj != uball) tmp += 2;
X		if(u.utrap) tmp -= 2;
X		if(u.uswallow || tmp >= rnd(20)) {
X			if(hmon(mon,obj,1) == FALSE)
X				mon = 0;	/* he died */
X		} else miss("iron ball", mon);
X#ifdef KAA
X	} else if (obj->otyp == ENORMOUS_ROCK) {
X		tmp = 15+mon->data->ac;  /* Very likely to hit! */
X		if (hmon(mon, obj, 1) == FALSE)	mon=0;
X		else miss("enormous rock",mon);
X	} else if(obj->otyp == CREAM_PIE &&
X		(u.ulevel > rn2(10)) || u.ustuck == mon) {
X		pline("The cream pie splashes over %s%s!",monnam(mon),
X			index("aEfgy",mon->data->mlet) ? "" : "'s face");
X		obfree(obj, (struct obj *) 0);
X		if(mon->msleep) mon->msleep = 0;
X		setmangry(mon);
X		mon->mcansee = 0;
X		mon->mblinded += rnd(25);
X		if (mon->mblinded <= 0) mon->mblinded = 127;
X		return(1);
X#endif
X	} else if(obj->olet == POTION_SYM && u.ulevel > rn2(15)) {
X		potionhit(mon, obj);
X		return(1);
X	} else {
X		pline("The %s misses %s.",xname(obj), 
X		cansee(bhitpos.x,bhitpos.y) ? monnam(mon) : "it");
X
X		if(obj->olet == FOOD_SYM && mon->data->mlet == 'd')
X			if(tamedog(mon,obj)) return(1);
X		if(obj->olet == GEM_SYM && mon->data->mlet == 'u' &&
X			!mon->mtame){
X			char buf[BUFSZ];
X			char *nogood = " is not interested in your junk.";
X			char *addluck = " graciously accepts your gift.";
X	
X			strcpy(buf,Monnam(mon));
X 
X			if(obj->dknown &&
X			   objects[obj->otyp].oc_name_known)  {
X				if(objects[obj->otyp].g_val > 0)  {
X					u.uluck += 5;
X					strcat(buf,addluck);
X				}  else
X					strcat(buf,nogood);
X			}  else  {  /* value unknown to @ */
X				u.uluck++;
X				strcat(buf,addluck);
X			}
X			if(u.uluck > LUCKMAX)   /* dan@ut-ngp */
X				u.uluck = LUCKMAX;
X			pline(buf);
X			mpickobj(mon, obj);
X			rloc(mon);
X			return(1);
X		}
X	}
X	return(0);
X}
END_OF_dothrow.c
if test 7031 -ne `wc -c <dothrow.c`; then
    echo shar: \"dothrow.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f mkshop.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"mkshop.c\"
else
echo shar: Extracting \"mkshop.c\" \(5986 characters\)
sed "s/^X//" >mkshop.c <<'END_OF_mkshop.c'
X/*	SCCS Id: @(#)mkshop.c	2.1	87/09/23
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X
X#ifndef QUEST
X#include "hack.h"
X#include "mkroom.h"
Xextern struct monst *makemon();
Xextern struct obj *mkobj_at();
Xextern int nroom;
X
Xmkshop(){
Xregister struct mkroom *sroom;
Xint roomno, i = -1;
X#ifdef WIZARD
Xextern char *getenv();
X
X	/* first determine shoptype */
X	if(wizard){
X		register char *ep = getenv("SHOPTYPE");
X		if(ep){
X			if(*ep == 'z' || *ep == 'Z'){
X				mkzoo(ZOO);
X				return;
X			}
X			if(*ep == 'm' || *ep == 'M'){
X				mkzoo(MORGUE);
X				return;
X			}
X			if(*ep == 'b' || *ep == 'B'){
X				mkzoo(BEEHIVE);
X				return;
X			}
X#ifdef NEWCLASS
X			if(*ep == 't' || *ep == 'T'){
X				mkzoo(COURT);
X				return;
X			}
X#endif
X			if(*ep == 's' || *ep == 'S'){
X				mkswamp();
X				return;
X			}
X			for(i=0; shtypes[i].name; i++)
X				if(*ep == shtypes[i].symb) goto gottype;
X			i = -1;
X		}
X	}
Xgottype:
X#endif
X	for(sroom = &rooms[0], roomno = 0; ; sroom++, roomno++){
X		if(sroom->hx < 0) return;
X		if(sroom - rooms >= nroom) {
X			pline("rooms not closed by -1?");
X			return;
X		}
X		if(sroom->rtype != OROOM) continue;
X		if(!sroom->rlit || has_dnstairs(sroom) || has_upstairs(sroom))
X			continue;
X		if(
X#ifdef WIZARD
X		   (wizard && getenv("SHOPTYPE") && sroom->doorct != 0) ||
X#endif
X			sroom->doorct == 1) break;
X	}
X
X	if(i < 0) {			/* shoptype not yet determined */
X	    register int j;
X
X	    /* pick a shop type at random */
X	    for(j = rn2(100), i = 0; j -= shtypes[i].prob; i++)
X		if (j < 0)	break;
X
X	    /* big rooms cannot be wand or book shops,
X	     * - so make them general stores
X	     */
X	    if(isbig(sroom) && (shtypes[i].symb == WAND_SYM
X#ifdef SPELLS
X				|| shtypes[i].symb == SPBOOK_SYM
X#endif
X								)) i = 0;
X	}
X	sroom->rtype = SHOPBASE + i;
X
X	/* stock the room with a shopkeeper and artifacts */
X	stock_room(&(shtypes[i]), sroom);
X}
X
Xmkzoo(type)
Xint type;
X{
X	register struct mkroom *sroom;
X	register struct monst *mon;
X	register int sh,sx,sy,i;
X	int goldlim = 500 * dlevel;
X	int moct = 0;
X	struct permonst *morguemon();
X#ifdef NEWCLASS
X	struct permonst *courtmon();
X#endif
X
X	i = nroom;
X	for(sroom = &rooms[rn2(nroom)]; ; sroom++) {
X		if(sroom == &rooms[nroom])
X			sroom = &rooms[0];
X		if(!i-- || sroom->hx < 0)
X			return;
X		if(sroom->rtype != OROOM)	continue;
X		if(has_upstairs(sroom) || (has_dnstairs(sroom) && rn2(3)))
X			continue;
X		if(sroom->doorct == 1 || !rn2(5))
X			break;
X	}
X	sroom->rtype = type;
X	sh = sroom->fdoor;
X	for(sx = sroom->lx; sx <= sroom->hx; sx++)
X	    for(sy = sroom->ly; sy <= sroom->hy; sy++){
X		if((sx == sroom->lx && doors[sh].x == sx-1) ||
X		   (sx == sroom->hx && doors[sh].x == sx+1) ||
X		   (sy == sroom->ly && doors[sh].y == sy-1) ||
X		   (sy == sroom->hy && doors[sh].y == sy+1)) continue;
X		mon = makemon(
X#ifdef NEWCLASS
X		   (type == COURT) ? courtmon() :
X#endif
X		   (type == MORGUE) ? morguemon() :
X		   (type == BEEHIVE) ? PM_KILLER_BEE : (struct permonst *) 0,
X		   sx, sy);
X		if(mon) mon->msleep = 1;
X		switch(type) {
X		case ZOO:
X		   i = sq(dist2(sx,sy,doors[sh].x,doors[sh].y));
X		   if(i >= goldlim) i = 5*dlevel;
X		   goldlim -= i;
X		   mkgold((long)(10 + rn2(i)), sx, sy);
X		   break;
X		case MORGUE:
X		   /* Usually there is one dead body in the morgue */
X		   if(!moct && rn2(3)) {
X			mksobj_at(CORPSE, sx, sy);
X			moct++;
X		   }
X		   break;
X		case BEEHIVE:
X		   if(!rn2(3)) mksobj_at(LUMP_OF_ROYAL_JELLY, sx, sy);
X		   break;
X		}
X	}
X#ifdef NEWCLASS
X	if(type == COURT)  {
X
X		sx = sroom->lx + (rn2(sroom->hx - sroom->lx));
X		sy = sroom->ly + (rn2(sroom->hy - sroom->ly));
X		levl[sx][sy].typ = THRONE;
X		levl[sx][sy].scrsym = THRONE_SYM;
X		mkgold((long) rn1(50 * dlevel,10), sx, sy);
X	}
X#endif
X
X}
X
Xstruct permonst *
Xmorguemon()
X{
X	extern struct permonst pm_ghost;
X	register int i = rn2(100), hd = rn2(dlevel);
X
X	if(hd > 10 && i < 10) return(PM_DEMON);
X	if(hd > 8 && i > 85) return(PM_VAMPIRE);
X	return((i < 40) ? PM_GHOST : (i < 60) ? PM_WRAITH : PM_ZOMBIE);
X}
X
Xmkswamp()	/* Michiel Huisjes & Fred de Wilde */
X{
X	register struct mkroom *sroom;
X	register int sx,sy,i,eelct = 0;
X	extern struct permonst pm_eel;
X
X	for(i=0; i<5; i++) {		/* 5 tries */
X		sroom = &rooms[rn2(nroom)];
X		if(sroom->hx < 0 || sroom->rtype != OROOM ||
X		   has_upstairs(sroom) || has_dnstairs(sroom))
X			continue;
X
X		/* satisfied; make a swamp */
X		sroom->rtype = SWAMP;
X		for(sx = sroom->lx; sx <= sroom->hx; sx++)
X		for(sy = sroom->ly; sy <= sroom->hy; sy++)
X		if((sx+sy)%2 && !o_at(sx,sy) && !t_at(sx,sy)
X			     && !m_at(sx,sy) && !nexttodoor(sx,sy)){
X			levl[sx][sy].typ = POOL;
X			levl[sx][sy].scrsym = POOL_SYM;
X			if(!eelct || !rn2(4)) {
X				(void) makemon(PM_EEL, sx, sy);
X				eelct++;
X			}
X		}
X	}
X}
X
Xnexttodoor(sx,sy)
Xregister sx,sy;
X{
X	register dx,dy;
X	register struct rm *lev;
X	for(dx = -1; dx <= 1; dx++) for(dy = -1; dy <= 1; dy++)
X		if((lev = &levl[sx+dx][sy+dy])->typ == DOOR ||
X		    lev->typ == SDOOR || lev->typ == LDOOR)
X			return(1);
X	return(0);
X}
X
Xhas_dnstairs(sroom)
Xregister struct mkroom *sroom;
X{
X	return(sroom->lx <= xdnstair && xdnstair <= sroom->hx &&
X		   sroom->ly <= ydnstair && ydnstair <= sroom->hy);
X}
X
Xhas_upstairs(sroom)
Xregister struct mkroom *sroom;
X{
X	return(sroom->lx <= xupstair && xupstair <= sroom->hx &&
X		   sroom->ly <= yupstair && yupstair <= sroom->hy);
X}
X
Xisbig(sroom)
Xregister struct mkroom *sroom;
X{
X	register int area = (sroom->hx - sroom->lx) * (sroom->hy - sroom->ly);
X	return( area > 20 );
X}
X
Xdist2(x0,y0,x1,y1){
X	return((x0-x1)*(x0-x1) + (y0-y1)*(y0-y1));
X}
X
Xsq(a) int a; {
X	return(a*a);
X}
X#endif /* QUEST /**/
X
X#ifdef NEWCLASS
Xstruct permonst *
Xcourtmon()
X{
X	int     i = rn2(60) + rn2(3*dlevel);
X
X	if (i > 100)		return(PM_DRAGON);
X	else if (i > 95)	return(PM_XORN);
X	else if (i > 85)	return(PM_TROLL);
X	else if (i > 75)	return(PM_ETTIN);
X	else if (i > 60)	return(PM_CENTAUR);
X	else if (i > 45)	return(PM_ORC);
X	else if (i > 30)	return(PM_HOBGOBLIN);
X#ifdef KOPS
X	else			return(PM_GNOME);
X#else
X	else if (i > 15)	return(PM_GNOME);
X	else			return(PM_KOBOLD);
X#endif
X}
X#endif /* NEWCLASS /**/
END_OF_mkshop.c
if test 5986 -ne `wc -c <mkshop.c`; then
    echo shar: \"mkshop.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f o_init.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"o_init.c\"
else
echo shar: Extracting \"o_init.c\" \(5617 characters\)
sed "s/^X//" >o_init.c <<'END_OF_o_init.c'
X/*	SCCS Id: @(#)o_init.c	2.0	87/09/16
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X
X#include	"config.h"		/* for typedefs */
X#include	"objects.h"
X#include	"onames.h"		/* for LAST_GEM */
Xextern char *index();
X
Xint
Xletindex(let) register char let; {
Xregister int i = 0;
Xregister char ch;
X	while((ch = obj_symbols[i++]) != 0)
X		if(ch == let) return(i);
X	return(0);
X}
X
Xinit_objects(){
Xregister int i, j, first, last, sum, end;
X#ifdef MSDOS
Xregister int tmp_i;
X#endif
Xregister char let, *tmp;
X
X	/* bug fix to prevent "initialization error" abort on Intel Xenix.
X	 * reported by mikew@semike
X	 */
X        for(i = 0; i != sizeof(obj_symbols); i++)
X                bases[i] = 0;
X
X	/* init base; if probs given check that they add up to 100, 
X	   otherwise compute probs; shuffle descriptions */
X	end = SIZE(objects);
X#ifdef MSDOS
X	/* Assign indices to all oc_descr_i first */
X	for (i = 0; i < end; i++)
X		objects[i].oc_descr_i = i;
X#endif
X	first = 0;
X	while( first < end ) {
X		let = objects[first].oc_olet;
X		last = first+1;
X		while(last < end && objects[last].oc_olet == let
X				 && objects[last].oc_name != NULL) last++;
X		i = letindex(let);
X		if((!i && let != ILLOBJ_SYM) || bases[i] != 0)
X			error("initialization error");
X		bases[i] = first;
X
X		if(let == GEM_SYM) setgemprobs();
X	check:
X		sum = 0;
X		for(j = first; j < last; j++) sum += objects[j].oc_prob;
X		if(sum == 0) {
X			for(j = first; j < last; j++)
X			    objects[j].oc_prob = (100+j-first)/(last-first);
X			goto check;
X		}
X		if(sum != 100)
X			error("init-prob error for %c (%d%%)", let, sum);
X
X		if(objects[first].oc_descr != NULL && let != TOOL_SYM){
X			/* shuffle, also some additional descriptions */
X			while(last < end && objects[last].oc_olet == let)
X				last++;
X			j = last;
X			while(--j > first) {
X				i = first + rn2(j+1-first);
X				tmp = objects[j].oc_descr;
X				objects[j].oc_descr = objects[i].oc_descr;
X				objects[i].oc_descr = tmp;
X#ifdef MSDOS
X	/* keep track of where the description came from */
X				tmp_i = objects[j].oc_descr_i;
X				objects[j].oc_descr_i = objects[i].oc_descr_i;
X				objects[i].oc_descr_i = tmp_i;
X#endif
X			}
X		}
X		first = last;
X	}
X}
X
Xprobtype(let) register char let; {
Xregister int i = bases[letindex(let)];
Xregister int prob = rn2(100);
X	while((prob -= objects[i].oc_prob) >= 0) i++;
X	if(objects[i].oc_olet != let || !objects[i].oc_name)
X		panic("probtype(%c) error, i=%d", let, i);
X	return(i);
X}
X
Xsetgemprobs()
X{
X	register int j,first;
X	extern xchar dlevel;
X
X	first = bases[letindex(GEM_SYM)];
X
X	for(j = 0; j < 9-dlevel/3; j++)
X		objects[first+j].oc_prob = 0;
X	first += j;
X	if(first >= LAST_GEM || first >= SIZE(objects) ||
X	    objects[first].oc_olet != GEM_SYM ||
X	    objects[first].oc_name == NULL)
X		printf("Not enough gems? - first=%d j=%d LAST_GEM=%d\n",
X			first, j, LAST_GEM);
X	for(j = first; j < LAST_GEM; j++)
X		objects[j].oc_prob = (20+j-first)/(LAST_GEM-first);
X}
X
Xoinit()			/* level dependent initialization */
X{
X	setgemprobs();
X}
X
Xextern long *alloc();
X
Xsavenames(fd) register fd; {
Xregister int i;
Xunsigned len;
X	bwrite(fd, (char *) bases, sizeof bases);
X	bwrite(fd, (char *) objects, sizeof objects);
X	/* as long as we use only one version of Hack/Quest we
X	   need not save oc_name and oc_descr, but we must save
X	   oc_uname for all objects */
X	for(i=0; i < SIZE(objects); i++) {
X		if(objects[i].oc_uname) {
X			len = strlen(objects[i].oc_uname)+1;
X			bwrite(fd, (char *) &len, sizeof len);
X			bwrite(fd, objects[i].oc_uname, len);
X		}
X	}
X}
X
Xrestnames(fd) register fd; {
Xregister int i;
Xunsigned len;
X#ifdef MSDOS
X	char *oc_descr[NROFOBJECTS + 1], *oc_name;
X
X	mread(fd, (char *) bases, sizeof bases);
X
X	/* Read in objects 1 at a time, correcting oc_name pointer and
X	 * saving pointer to current description.
X	 */
X	for (i = 0; i < SIZE(objects); i++) {
X		oc_name = objects[i].oc_name;
X		oc_descr[i] = objects[i].oc_descr;
X		mread(fd, (char *) &objects[i], sizeof (struct objclass));
X		objects[i].oc_name = oc_name;
X	}
X
X	/* Convert from saved indices into pointers */
X	for (i = 0; i < SIZE(objects); i++)
X		objects[i].oc_descr = oc_descr[objects[i].oc_descr_i];
X#else
X	mread(fd, (char *) bases, sizeof bases);
X	mread(fd, (char *) objects, sizeof objects);
X#endif
X	for(i=0; i < SIZE(objects); i++) if(objects[i].oc_uname) {
X		mread(fd, (char *) &len, sizeof len);
X		objects[i].oc_uname = (char *) alloc(len);
X		mread(fd, objects[i].oc_uname, len);
X	}
X}
X
Xdodiscovered()				/* free after Robert Viduya */
X{
X    extern char *typename();
X    register int i, end;
X    int	ct = 0;
X#ifdef DGKMOD
X    char class = -1;
X    extern char *let_to_name();
X#endif
X
X    cornline(0, "Discoveries");
X
X    end = SIZE(objects);
X    for (i = 0; i < end; i++) {
X	if (interesting_to_discover (i)) {
X	    ct++;
X#ifdef DGKMOD
X	    if (objects[i].oc_olet != class) {
X		class = objects[i].oc_olet;
X		cornline(1, let_to_name(class));
X	    }
X#endif
X	    cornline(1, typename(i));
X	}
X    }
X    if (ct == 0) {
X	pline ("You haven't discovered anything yet...");
X	cornline(3, (char *) 0);
X    } else
X	cornline(2, (char *) 0);
X
X    return(0);
X}
X
Xinteresting_to_discover(i)
Xregister int i;
X{
X    return(
X	objects[i].oc_uname != NULL ||
X	 (objects[i].oc_name_known && objects[i].oc_descr != NULL)
X    );
X}
X
Xinit_corpses() {
X
X#ifdef SPIDERS
X	strcpy(objects[DEAD_GIANT_SPIDER].oc_name, "dead giant spider");
X#endif
X
X#ifdef KOPS
X	strcpy(objects[DEAD_KOP].oc_name, "dead Kop");
X# endif
X
X#ifdef ROCKMOLE
X	strcpy(objects[DEAD_ROCKMOLE].oc_name, "dead rockmole");
X#endif
X
X#ifndef KAA
X	strcpy(objects[DEAD_QUASIT].oc_name, "dead quasit");
X	strcpy(objects[DEAD_VIOLET_FUNGI].oc_name, "dead violet fungi");
X#endif
X	return(0);
X}
END_OF_o_init.c
if test 5617 -ne `wc -c <o_init.c`; then
    echo shar: \"o_init.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f polyself.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"polyself.c\"
else
echo shar: Extracting \"polyself.c\" \(6362 characters\)
sed "s/^X//" >polyself.c <<'END_OF_polyself.c'
X/*	SCCS Id: @(#)polyself.c	2.2	87/11/29
X/* Polymorph self routine.  Called in zap.c. Copyright 1987 by Ken Arromdee */
X
X#include "hack.h"
X
X#ifdef KAA
X
Xextern char genocided[];
Xextern char pl_character[PL_CSIZ];
Xextern char plname[PL_NSIZ];
X
Xextern long newuexp();
X
Xpolyself()
X{
X	char buf[BUFSZ];
X	int tmp, tmp2, mntmp;
X
X#ifdef BVH
X	if(!Polymorph_control) {
X#endif
X	    if (rn2(5)-3 > u.uluck) {
X		pline("You shudder for a moment.");
X		losehp(rn2(30),"system shock");
X		return;
X	    }
X#ifdef BVH
X	} else {
X	    char buf[BUFSZ];
X	    int i;
X
X	    pline("Type the letter of the monster to become: ");
X	    getlin(buf);
X	    for(i=0; i<CMNUM; ++i)
X		if(mons[i].mlet == *buf) {
X		    mntmp = i;
X		    goto gotone;
X		}
X	}
X#endif
X	mntmp = rn2(CMNUM);
Xgotone:
X/* We want to disallow certain monsters, but also allow humans. */
X	if (index("w:",mons[mntmp].mlet) || !rn2(5)) {
X	    if (!rn2(10)) flags.female = !flags.female;
X	    tmp = u.uhpmax;
X	    tmp2 = u.ulevel;
X	    u.usym = '@';
X	    prme();
X	    u.mtimedone = u.mh = u.mhmax = 0;
X	    u.ulevel = u.ulevel-2+rn2(5);
X	    if (u.ulevel > 127 || u.ulevel == 0) u.ulevel = 1;
X	    if (u.ulevel > 14) u.ulevel = 14;
X	    if (u.ulevel == 1) u.uexp = rnd(10);
X	    else {  /* For the new experience level, random EXP. */
X		u.ulevel--;     
X		u.uexp = newuexp();
X		u.uexp += rn2(u.uexp);
X		u.ulevel++;
X	    }
X	    u.uhpmax = (u.uhpmax-10)*u.ulevel/tmp2 + 19 - rn2(19);
X/* If it was u.uhpmax*u.ulevel/tmp+9-rn2(19), then a 1st level character
X   with 16 hp who polymorphed into a 3rd level one would have an average
X   of 48 hp.  */
X	    u.uhp = u.uhp*u.uhpmax/tmp;
X	    tmp = u.ustrmax;
X	    u.ustrmax += (rn2(5)-2);
X	    if (u.ustrmax > 118) u.ustrmax = 118;
X	    if (u.ustrmax < 3) u.ustrmax = 3;
X	    u.ustr = u.ustr * u.ustrmax / tmp;
X	    if (u.ustr < 3) u.ustr = 3;  /* > 118 is impossible */
X	    u.uhunger = 500 + rn2(500);
X	    Sick = 0;
X	    Stoned = 0;
X	    if (u.uhp <= 0 || u.uhpmax <= 0) {
X#ifdef BVH
X		if(Polymorph_control) {
X		    u.uhp = (u.uhp <= 0) ? 1 : u.uhp;
X		    u.uhpmax = (u.uhpmax <= 0) ? 1  : u.uhpmax;
X		} else {
X#endif
X		    killer="unsuccessful polymorph";
X		    done("died");
X#ifdef BVH
X		}
X#endif
X	    }
X	    pline("You feel like a new %sman!", flags.female ? "wo" : "");
Xnewname:    more();
X	    do {
X		pline("What is your new name? ");
X		getlin(buf);
X	    } while (buf[0]=='\033' || buf[0]==0);
X	    if (!strcmp(plname,buf)) {
X		pline("That is the same as your old name!");
X		goto newname;
X	    }
X	    (void)strncpy(plname, buf, sizeof(plname)-1);
X	    flags.botl = 1;
X	    find_ac();
X	} else {
X	    if (index(genocided,mons[mntmp].mlet)) {
X		pline("You feel rather %sish.",mons[mntmp].mname);
X		return;
X	    }
X	    if(u.usym == '@') {
X		u.mstr = u.ustr;
X		u.mstrmax = u.ustrmax;
X	    }
X	    u.umonnum = mntmp;
X	    u.usym = mons[mntmp].mlet;
X	    if(index("CDelmoPTUVXYz9", u.usym)) u.ustr = u.ustrmax = 118;
X	    if (u.usym == 'D') u.mhmax = 80;
X	    else if (!(mons[mntmp].mlevel)) u.mhmax = rnd(4);
X	    else u.mhmax = d(mons[mntmp].mlevel,8);
X	    u.mh = u.mhmax;
X	    pline("You turn into a%s %s!", index("aeioOU",u.usym) ? "n" : "",
X		  mons[mntmp].mname);
X	    break_armor(u.usym);
X	    drop_weapon(u.usym);
X	    prme();
X	    u.mtimedone = 500 + rn2(500);
X	    flags.botl = 1;
X	    if (u.usym == 'D')
X		pline("Use the command #breathe to breathe.");
X	    if (u.usym == 'N')
X		pline("Use the command #remove if you have to remove an iron ball.");
X	    find_ac();
X	}
X	if (Inhell && !Fire_resistance) {
X	    pline("You burn to a crisp.");
X	    killer = "unwise polymorph";
X	    done("died");
X	}
X}
X
Xbreak_armor(turninto)
Xchar turninto;
X{
X     struct obj *otmp;
X     if (uarm) {
X	  if (index("CDMPRUXYdejlouz,'9", turninto)) {
X	       pline("The transformation causes you to break out of your armor!");
X	       if (uarm2) useup(uarm2);
X	       useup(uarm);
X	  } else if (index("abcfghikpqrstvxyABEFJQS", turninto)) {
X	       pline("Your armor falls around you!");
X	       if (otmp = uarm2) {
X		    setworn((struct obj *)0,otmp->owornmask & W_ARM2);
X		    dropx(otmp);
X	       }
X	       otmp = uarm;
X	       setworn((struct obj *)0, otmp->owornmask & W_ARM);
X	       dropx(otmp);
X	  }
X     }
X     if (!index("enozCGHIKLNOTUVWXYZ&',", turninto)) {
X	  if (otmp = uarmg) {
X	       pline("You drop your gloves!");
X	       setworn((struct obj *)0, otmp->owornmask & W_ARMG);
X	       dropx(otmp);
X	       drop_weapon('a'); /* the 'a' is dummy to ensure dropping */
X	  }
X	  if (otmp = uarms) {
X	       pline("You can no longer hold your shield!");
X	       setworn((struct obj *)0, otmp->owornmask & W_ARMS);
X	       dropx(otmp);
X	  }
X	  if (otmp = uarmh) {
X	       pline("Your helmet falls to the floor!");
X	       setworn((struct obj *)0, otmp->owornmask & W_ARMH);
X	       dropx(otmp);
X	  }
X     }
X}
X
Xdrop_weapon(turninto) 
Xchar turninto;
X{
X     struct obj *otmp;
X     if (otmp = uwep) {
X	  if (cantwield(turninto)) {
X	       pline("You find you must drop your weapon!");
X	       setuwep((struct obj *)0);
X	       dropx(otmp);
X	  }
X     }
X}
X
Xcantwield(c)  /* creature type c cannot wield a weapon */
Xchar c;
X{
X     return(!!index("abcdfgjklpqrsuvxyABEFJPRS',",c));
X}
X
Xcantweararm(c)   /* creature type c cannot wear armor */
Xchar c;
X{
X     return(!index("@nGHIKLNOTVWZ&',",c));
X}
X
Xrehumanize()
X{
X	u.mh = u.mhmax = u.mtimedone = 0;
X	u.ustr = u.mstr;
X	u.ustrmax = u.mstrmax;
X	u.usym = '@';
X	prme();
X	pline("You return to %sn form!",(pl_character[0]=='E')?"elve":"huma");
X
X	if (u.uhp < 1)	done("died");
X	if (!Fire_resistance && Inhell) {
X	    pline("You burn to a crisp.");
X	    killer = "dissipating polymorph spell";
X	   done("died");
X	}
X	flags.botl = 1;
X	find_ac();
X}
X
Xdobreathe()
X{
X     if (u.usym == 'D') {
X	  if(!getdir(1)) return(0);
X	  if (rn2(4))
X	       pline("You exhale a bit of smoke.");
X	  else buzz(10, u.ux, u.uy, u.dx, u.dy);
X     /* Changes must be made in zap.c to accommodate this. */
X     } else pline("You do not have the ability to breathe fire!");
X     return(1);
X}
X
Xdoremove()
X{
X     if (!Punished) {
X	  pline("You do not have a ball attached to your leg!");
X	  return(0);
X     }
X     if(u.usym != 'N')
X	  pline("You are not capable of removing a locked chain!");
X     else {
X	  Punished = 0;
X	  uchain->spe = 0;
X	  uball->spe = 0;
X	  uchain->owornmask &= ~W_CHAIN;
X	  uball->owornmask &= ~W_BALL;
X	  uchain = uball = (struct obj *)0;
X     }
X     return(1);
X}
X#endif
END_OF_polyself.c
if test 6362 -ne `wc -c <polyself.c`; then
    echo shar: \"polyself.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f pray.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"pray.c\"
else
echo shar: Extracting \"pray.c\" \(5803 characters\)
sed "s/^X//" >pray.c <<'END_OF_pray.c'
X/*	SCCS Id: @(#)pray.c	2.1	87/10/07
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X
X#include "hack.h"
X
Xextern char *nomovemsg;
Xextern struct monst *mkmon_at();
Xextern struct obj *mkobj_at();
X
Xdopray() {		/* M. Stephenson (1.0.3b) */
X#ifdef PRAYERS
X	if (u.ublesscnt > 0)  {		/* disturbing the gods too much */
X
X		u.ublesscnt += 200;
X		u.uluck -= 3;
X		if (u.uluck < LUCKMIN)  u.uluck = LUCKMIN;
X#ifdef HARD
X		u.ugangr++;
X		angrygods();
X#else
X		if (u.ugangr++)	angrygods();
X		else {			/* exactly one warning */
X			pline("A voice booms out: You have angered us,");
X			pline("Disturb us again at your own risk!");
X		}
X#endif
X	} else  if (u.uluck < 0) angrygods();	/* a bad boy/girl */
X	else	pleased();	    		/* or a good boy/girl */
X#endif
X	nomovemsg = "You finished your prayer.";
X	nomul(-3);
X	return(1);
X}
X
X#ifdef PRAYERS
Xangrygods() {
X	register int	tmp;
X
X	pline ("You get the feeling the gods are angry...");
X	/* changed from tmp = u.ugangr + abs (u.uluck) -- rph */
X	tmp =  3*u.ugangr + (u.uluck > 0 ? -u.uluck/3 : -u.uluck);
X	tmp =  (tmp > 15 ? 15 : tmp);  /* lets be a little reasonable */
X	switch (tmp ? rn2(tmp): 0) {
X
X	    case 0:
X	    case 1:	pline("but nothing appears to happen.");
X			break;
X	    case 2:
X	    case 3:	pline("A voice booms out: You are arrogant, mortal.");
X			pline("You must relearn your lessons!");
X			if (u.ulevel > 1)	losexp();
X			else  {
X			    u.uexp = 0;
X			    flags.botl = 1;
X			}
X			break;
X	    case 4:
X	    case 5:
X	    case 6:	pline("A black glow surrounds you.");
X			rndcurse();
X			break;
X	    case 7:
X	    case 8:	pline("A voice booms out: You dare to call upon us?");
X			pline("Then, die mortal!");
X			mkmon_at('&', u.ux, u.uy);
X			break;
X				
X	    default:	pline("Suddenly, a bolt of lightning strikes you!");
X			pline("You are fried to a crisp.");
X			killer = "pissed off deity";
X			done("died");
X			break;
X	}
X	u.ublesscnt = 250;
X	return(0);
X}
X
Xpleased() {
X
X	char	*tmp, *hcolor();
X
X	u.ugangr--;
X	if (u.ugangr < 0) u.ugangr = 0;
X	pline("You feel the gods are pleased.");
X
X	switch(rn2((u.uluck + 6)/2))  {
X
X	    case 0:	pline("but nothing seems to happen.");
X			break;
X	    case 1:
X			if(!uwep) {
X			    if(uleft && uleft->cursed) {
X				pline("your left hand glows amber.");
X				uleft->cursed = 0;
X			    } else if(uright && uright->cursed) {
X				pline("your right hand glows amber.");
X				uright->cursed = 0;
X			    } else    pline("but nothing seems to happen.");
X			    break;
X			}
X#ifdef KAA
X			if(uwep->olet == WEAPON_SYM) {
X			    if (uwep->cursed) {
X				uwep->cursed=0;
X				pline("Your %s %s.", aobjnam(uwep,"softly glow"), 
X				Hallucination ? hcolor() : "amber");
X			    } else if(uwep->otyp >= ARROW && uwep->otyp <= SPEAR) {
X				uwep->dknown=1;
X				tmp = Hallucination ? hcolor() : "light blue";
X				pline("Your %s with a%s %s aura.", aobjnam(uwep,"softly glow"),
X				index("aeiou",*tmp) ? "n" : "", tmp);
X			    }
X			} else
X#endif
X				pline("but nothing seems to happen.");
X			break;
X	    case 2:
X	    case 3:
X			pline("A %s glow surrounds you",
X			      Hallucination ? hcolor() : "golden");
X			u.uhp = u.uhpmax += 5;
X			u.ustr = u.ustrmax;
X			if (u.uhunger < 900)	init_uhunger();
X			if (u.uluck < 0)	u.uluck = 0;
X			if (Blinded)		Blinded = 1;
X			flags.botl = 1;
X			break;
X	    case 4:
X	    case 5:	pline("A voice booms out: We are pleased with your progress,");
X			pline("and grant you the gift of");
X			if (!(HTelepat & INTRINSIC))  {
X				HTelepat |= INTRINSIC;
X				pline ("Telepathy,");
X			} else if (!(Fast & INTRINSIC))  {
X				Fast |= INTRINSIC;
X				pline ("Speed,");
X			} else if (!(Stealth & INTRINSIC))  {
X				Stealth |= INTRINSIC;
X				pline ("Stealth,");
X			} else {
X			    if (!(Protection & INTRINSIC))  {
X				Protection |= INTRINSIC;
X				if (!u.ublessed)  u.ublessed = rnd(3) + 1;
X			    } else u.ublessed++;
X			    pline ("our protection,");
X			}
X			pline ("Use it wisely in our names!");
X			break;
X
X	    case 6:	pline ("An object appears at your feet!");
X#ifdef SPELLS
X			mkobj_at('+', u.ux, u.uy);
X#else
X			mkobj_at('?', u.ux, u.uy);
X#endif
X			break;
X
X	    case 7:	pline("A voice booms out:  We crown thee...");
X			pline("The Hand of Elbereth!");
X			HInvis |= INTRINSIC;
X			HSee_invisible |= INTRINSIC;
X			HFire_resistance |= INTRINSIC;
X			HCold_resistance |= INTRINSIC;
X			HPoison_resistance |= INTRINSIC;
X#ifdef RPH
X			if(uwep && (uwep->otyp == LONG_SWORD))
X				oname(uwep, "Excalibur");
X#endif
X			break;
X
X	    default:	impossible("Confused deity!");
X			break;
X	}
X	u.ublesscnt = 300;
X#ifdef HARD
X	u.ublesscnt += (u.udemigod * 1000);
X#endif
X	return(0);
X}
X#endif /* PRAYERS /**/
X#ifdef NEWCLASS
Xdoturn() {	/* Knights & Priest(esse)s only please */
X
X	register struct monst *mtmp;
X	register int	xlev = 6;
X	extern char	pl_character[];
X
X	if((pl_character[0] != 'P') &&
X	   (pl_character[0] != 'K')) {
X
X		pline("You don't know how to turn undead!");
X		return(0);
X	}
X	if (Inhell) {
X
X		pline("Being in hell, your gods won't help you.");
X		aggravate();
X		return(0);
X	}
X	pline("Calling upon your gods, you chant an arcane formula.");
X	for(mtmp = fmon; mtmp; mtmp = mtmp->nmon)
X	    if(cansee(mtmp->mx,mtmp->my)) {
X		if(index(UNDEAD,mtmp->data->mlet) ||
X		   ((mtmp->data->mlet == '&') && (u.ulevel > 10))) {
X
X		    if(Confusion) {
X			pline("Unfortunately, your voice falters.");
X			mtmp->mflee = mtmp->mfroz = mtmp->msleep = 0;
X		    } else if (! resist(mtmp, '+', 0, TELL))
X			switch (mtmp->data->mlet) {
X			    case 'V':   xlev += 2;
X			    case 'W':   xlev += 4;
X			    case 'Z':   if(u.ulevel >= xlev)  {
X					    if(!resist(mtmp, '+', 0, NOTELL)) {
X						pline("You destroy the %s", monnam(mtmp));
X						mondied(mtmp);
X					    } else	mtmp->mflee = 1;
X					} else	mtmp->mflee = 1;
X					break;
X			    default:    mtmp->mflee = 1;
X					break;
X			}
X		   }
X	    }
X	    nomul(-5);
X	    return(1);
X}
X#endif /* NEWCLASS /**/
X
END_OF_pray.c
if test 5803 -ne `wc -c <pray.c`; then
    echo shar: \"pray.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f vault.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"vault.c\"
else
echo shar: Extracting \"vault.c\" \(5953 characters\)
sed "s/^X//" >vault.c <<'END_OF_vault.c'
X/*	SCCS Id: @(#)vault.c	2.1	87/10/17
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X
X#include	"hack.h"
X#ifdef QUEST
Xsetgd(/* mtmp */) /* struct monst *mtmp; */ {}
Xgd_move() { return(2); }
Xgddead(mtmp) struct monst *mtmp; {}
Xreplgd(mtmp,mtmp2) struct monst *mtmp, *mtmp2; {}
Xinvault(){}
X
X#else
X
X
X#include "mkroom.h"
Xextern struct monst *makemon();
X#define	FCSIZ	(ROWNO+COLNO)
Xstruct fakecorridor {
X	xchar fx,fy,ftyp;
X};
X
Xstruct egd {
X	int fcbeg, fcend;	/* fcend: first unused pos */
X	xchar gdx, gdy;		/* goal of guard's walk */
X	unsigned gddone:1;
X	struct fakecorridor fakecorr[FCSIZ];
X};
X
Xstruct permonst pm_guard =
X	{ "guard", '@', 12, 12, -1, 40, 4, 10, sizeof(struct egd) };
X
Xstatic struct monst *guard;
Xstatic int gdlevel;
X#define	EGD	((struct egd *)(&(guard->mextra[0])))
X
Xstatic
Xrestfakecorr()
X{
X	register fcx,fcy,fcbeg;
X	register struct rm *crm;
X
X	while((fcbeg = EGD->fcbeg) < EGD->fcend) {
X		fcx = EGD->fakecorr[fcbeg].fx;
X		fcy = EGD->fakecorr[fcbeg].fy;
X		if((u.ux == fcx && u.uy == fcy) || cansee(fcx,fcy) ||
X		   m_at(fcx,fcy))
X			return;
X		crm = &levl[fcx][fcy];
X		crm->typ = EGD->fakecorr[fcbeg].ftyp;
X		if(!crm->typ) crm->seen = 0;
X		newsym(fcx,fcy);
X		EGD->fcbeg++;
X	}
X	/* it seems he left the corridor - let the guard disappear */
X	mondead(guard);
X	guard = 0;
X}
X
Xstatic
Xgoldincorridor()
X{
X	register int fci;
X
X	for(fci = EGD->fcbeg; fci < EGD->fcend; fci++)
X		if(g_at(EGD->fakecorr[fci].fx, EGD->fakecorr[fci].fy))
X			return(1);
X	return(0);
X}
X
Xsetgd(){
Xregister struct monst *mtmp;
X	for(mtmp = fmon; mtmp; mtmp = mtmp->nmon) if(mtmp->isgd){
X		guard = mtmp;
X		gdlevel = dlevel;
X		return;
X	}
X	guard = 0;
X}
X
Xinvault(){
Xregister tmp = inroom(u.ux, u.uy);
X    if(tmp < 0 || rooms[tmp].rtype != VAULT) {
X	u.uinvault = 0;
X	return;
X    }
X    if(++u.uinvault % 50 == 0 && (!guard || gdlevel != dlevel)) {
X	char buf[BUFSZ];
X	register x,y,dd,gx,gy;
X
X	/* first find the goal for the guard */
X	for(dd = 1; (dd < ROWNO || dd < COLNO); dd++) {
X	  for(y = u.uy-dd; y <= u.uy+dd; y++) {
X	    if(y < 0 || y > ROWNO-1) continue;
X	    for(x = u.ux-dd; x <= u.ux+dd; x++) {
X	      if(y != u.uy-dd && y != u.uy+dd && x != u.ux-dd)
X		x = u.ux+dd;
X	      if(x < 0 || x > COLNO-1) continue;
X	      if(levl[x][y].typ == CORR) goto fnd;
X	    }
X	  }
X	}
X	impossible("Not a single corridor on this level??");
X	tele();
X	return;
Xfnd:
X	gx = x; gy = y;
X
X	/* next find a good place for a door in the wall */
X	x = u.ux; y = u.uy;
X	while(levl[x][y].typ == ROOM) {
X		register int dx,dy;
X
X		dx = (gx > x) ? 1 : (gx < x) ? -1 : 0;
X		dy = (gy > y) ? 1 : (gy < y) ? -1 : 0;
X		if(abs(gx-x) >= abs(gy-y))
X			x += dx;
X		else
X			y += dy;
X	}
X
X	/* make something interesting happen */
X	if(!(guard = makemon(&pm_guard,x,y))) return;
X	guard->isgd = guard->mpeaceful = 1;
X	EGD->gddone = 0;
X	gdlevel = dlevel;
X	if(!cansee(guard->mx, guard->my)) {
X		mondead(guard);
X		guard = 0;
X		return;
X	}
X
X	pline("Suddenly one of the Vault's guards enters!");
X	pmon(guard);
X	do {
X		pline("\"Hello stranger, who are you?\" - ");
X		getlin(buf);
X	} while (!letter(buf[0]));
X
X	if(!strcmp(buf, "Croesus") || !strcmp(buf, "Kroisos")) {
X		pline("\"Oh, yes - of course. Sorry to have disturbed you.\"");
X		mondead(guard);
X		guard = 0;
X		return;
X	}
X	clrlin();
X	pline("\"I don't know you.\"");
X	if(!u.ugold)
X	    pline("\"Please follow me.\"");
X	else {
X	    pline("\"Most likely all that gold was stolen from this vault.\"");
X	    pline("\"Please drop your gold (say d$ ) and follow me.\"");
X	}
X	EGD->gdx = gx;
X	EGD->gdy = gy;
X	EGD->fcbeg = 0;
X	EGD->fakecorr[0].fx = x;
X	EGD->fakecorr[0].fy = y;
X	EGD->fakecorr[0].ftyp = levl[x][y].typ;
X	levl[x][y].typ = DOOR;
X	EGD->fcend = 1;
X    }
X}
X
Xgd_move(){
Xregister int x,y,dx,dy,gx,gy,nx,ny,typ;
Xregister struct fakecorridor *fcp;
Xregister struct rm *crm;
X	if(!guard || gdlevel != dlevel){
X		impossible("Where is the guard?");
X		return(2);	/* died */
X	}
X	if(u.ugold || goldincorridor())
X		return(0);	/* didnt move */
X	if(dist(guard->mx,guard->my) > 1 || EGD->gddone) {
X		restfakecorr();
X		return(0);	/* didnt move */
X	}
X	x = guard->mx;
X	y = guard->my;
X	/* look around (hor & vert only) for accessible places */
X	for(nx = x-1; nx <= x+1; nx++) for(ny = y-1; ny <= y+1; ny++) {
X	    if(nx == x || ny == y) if(nx != x || ny != y)
X	    if(isok(nx,ny))
X	    if(!IS_WALL(typ = (crm = &levl[nx][ny])->typ) && typ != POOL) {
X		register int i;
X		for(i = EGD->fcbeg; i < EGD->fcend; i++)
X			if(EGD->fakecorr[i].fx == nx &&
X			   EGD->fakecorr[i].fy == ny)
X				goto nextnxy;
X		if((i = inroom(nx,ny)) >= 0 && rooms[i].rtype == VAULT)
X			goto nextnxy;
X		/* seems we found a good place to leave him alone */
X		EGD->gddone = 1;
X		if(ACCESSIBLE(typ)) goto newpos;
X		crm->typ = (typ == SCORR) ? CORR : DOOR;
X		goto proceed;
X	    }
X    nextnxy:	;
X	}
X	nx = x;
X	ny = y;
X	gx = EGD->gdx;
X	gy = EGD->gdy;
X	dx = (gx > x) ? 1 : (gx < x) ? -1 : 0;
X	dy = (gy > y) ? 1 : (gy < y) ? -1 : 0;
X	if(abs(gx-x) >= abs(gy-y)) nx += dx; else ny += dy;
X
X	while((typ = (crm = &levl[nx][ny])->typ) != 0) {
X	/* in view of the above we must have IS_WALL(typ) or typ == POOL */
X	/* must be a wall here */
X		if(isok(nx+nx-x,ny+ny-y) && typ != POOL &&
X#ifdef RPH
X		    SPACE_POS(levl[nx+nx-x][ny+ny-y].typ)){
X#else
X		    ZAP_POS(levl[nx+nx-x][ny+ny-y].typ)){
X#endif
X			crm->typ = DOOR;
X			goto proceed;
X		}
X		if(dy && nx != x) {
X			nx = x; ny = y+dy;
X			continue;
X		}
X		if(dx && ny != y) {
X			ny = y; nx = x+dx; dy = 0;
X			continue;
X		}
X		/* I don't like this, but ... */
X		crm->typ = DOOR;
X		goto proceed;
X	}
X	crm->typ = CORR;
Xproceed:
X	if(cansee(nx,ny)) {
X		mnewsym(nx,ny);
X		prl(nx,ny);
X	}
X	fcp = &(EGD->fakecorr[EGD->fcend]);
X	if(EGD->fcend++ == FCSIZ) panic("fakecorr overflow");
X	fcp->fx = nx;
X	fcp->fy = ny;
X	fcp->ftyp = typ;
Xnewpos:
X	if(EGD->gddone) nx = ny = 0;
X	guard->mx = nx;
X	guard->my = ny;
X	pmon(guard);
X	restfakecorr();
X	return(1);
X}
X
Xgddead(){
X	guard = 0;
X}
X
Xreplgd(mtmp,mtmp2)
Xregister struct monst *mtmp, *mtmp2;
X{
X	if(mtmp == guard)
X		guard = mtmp2;
X}
X
X#endif /* QUEST /**/
END_OF_vault.c
if test 5953 -ne `wc -c <vault.c`; then
    echo shar: \"vault.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
echo shar: End of archive 17 \(of 20\).
cp /dev/null ark17isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 20 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
