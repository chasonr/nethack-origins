Relay-Version: version B 2.10 5/3/83; site utzoo.UUCP
Path: utzoo!mnetor!uunet!tektronix!tekgen!tekred!games-request
From: games-request@tekred.TEK.COM
Newsgroups: comp.sources.games
Subject: v03i009:  NetHack2.2 - display oriented dungeons and dragons, Part09/20
Message-ID: <1895@tekred.TEK.COM>
Date: Wed, 2-Dec-87 12:00:26 EST
Article-I.D.: tekred.1895
Posted: Wed Dec  2 12:00:26 1987
Date-Received: Sun, 6-Dec-87 04:55:54 EST
Sender: billr@tekred.TEK.COM
Lines: 2124
Approved: billr@tekred.TEK.COM

Submitted by: mike@genat.UUCP (Mike Stephenson)
Comp.sources.games: Volume 3, Issue 9
Archive-name: nethack2.2/Part09



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 9 (of 20)."
# Contents:  Makefile.att eat.c msdos.c objects.h
# Wrapped by billr@tekred on Tue Dec  1 16:24:58 1987
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f Makefile.att -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"Makefile.att\"
else
echo shar: Extracting \"Makefile.att\" \(7004 characters\)
sed "s/^X//" >Makefile.att <<'END_OF_Makefile.att'
X#	Hack or Quest Makefile.
X#	SCCS Id: @(#)Makefile.att	2.2	87/11/11
X
Xinclude $(MAKEINC)/Makepre.h
X
X# if you are cross-compiling (eg. from Xenix into a Dos enviornment)
X# you will have to redefine these filenames.
XMAIN = unixmain.c
XTTY  = unixtty.c
XUNIX = unixunix.c
X
X# on some systems the termcap library is in -ltermcap
X#TERMLIB = -ltermlib
XTERMLIB =
X
X# make NetHack
XGAME = nethack
XGAMEUID = games
XGAMEGRP = bin
X#	GAMEDIR also appears in config.h as "HACKDIR".
XGAMEDIR = /usr/games/lib/$(GAME)dir
XSHELLDIR = /usr/games
XMANDIR  = /usr/man/man6
XCFLAGS = -O
XLFLAGS =
X
XHACKCSRC = alloc.c apply.c bones.c cmd.c decl.c do.c do_name.c do_wear.c\
X	dog.c dogmove.c dothrow.c eat.c end.c engrave.c fight.c fountain.c\
X	hack.c invent.c ioctl.c lev.c main.c makemon.c mhitu.c\
X	mklev.c mkmaze.c mkobj.c mkshop.c mon.c monmove.c monst.c o_init.c\
X	objnam.c options.c pager.c polyself.c potion.c pray.c pri.c\
X	prisym.c read.c rip.c rnd.c rumors.c save.c search.c shk.c shknam.c\
X	sit.c spell.c steal.c termcap.c timeout.c topl.c topten.c track.c\
X	trap.c tty.c u_init.c unix.c vault.c version.c wield.c wizard.c\
X	worm.c worn.c write.c zap.c
X
XCSOURCES = $(HACKCSRC) makedefs.c
X
XHSOURCES = hack.h mfndpos.h config.h edog.h eshk.h extern.h\
X	flag.h func_tab.h gold.h mkroom.h monst.h obj.h objclass.h\
X	objects.h permonst.h rm.h spell.h trap.h wseg.h you.h
X
XSOURCES = $(CSOURCES) $(HSOURCES)
X
XAUX = help hh nethack.6 nethack.sh
XVARAUX = data rumors
XSPECIFICS = main.o tty.o unix.o
X
X
XDISTR = $(SOURCES) $(AUX) $(VARAUX) README.OLD README\
X	Makefile Makefile.pc Make.ini
X
XHOBJ = alloc.o apply.o bones.o cmd.o decl.o do.o do_name.o do_wear.o\
X	dog.o dogmove.o dothrow.o eat.o end.o engrave.o fight.o fountain.o\
X	hack.o invent.o ioctl.o lev.o main.o makemon.o mhitu.o\
X	mklev.o mkmaze.o mkobj.o mkshop.o mon.o monmove.o monst.o o_init.o\
X	objnam.o options.o pager.o polyself.o potion.o pray.o pri.o\
X	prisym.o read.o rip.o rnd.o rumors.o save.o search.o shk.o shknam.o\
X	sit.o spell.o steal.o termcap.o timeout.o topl.o topten.o track.o\
X	trap.o tty.o u_init.o unix.o vault.o version.o wield.o wizard.o\
X	worm.o worn.o write.o zap.o
X
X$(GAME):	$(SPECIFICS) $(HOBJ) Makefile
X	@echo "Loading ..."
X	@ld $(LFLAGS) $(SHAREDLIB) -o $(GAME) $(HOBJ) $(TERMLIB)
X
Xall:	$(GAME) lint
X	@echo "Done."
X
Xmakedefs:	makedefs.c alloc.o config.h
X	cc -o makedefs alloc.o makedefs.c
X
XRUMORFILES= rumors.base rumors.kaa rumors.mrx
X
Xrumors:	config.h $(RUMORFILES) makedefs
X	makedefs -r
X
Xdata:	config.h data.base makedefs
X	makedefs -d
X
Xdate.h:	$(SOURCES) makedefs
X	makedefs -D
X
Xtrap.h:	config.h makedefs
X	makedefs -t
X
Xonames.h:	makedefs objects.h
X	makedefs -o
X
Xmain.o:
X
Xmain.c:	unixmain.c hack.h
X	cp $(MAIN) main.c
X
Xtty.o:
X
Xtty.c:	unixtty.c extern.h
X	cp $(TTY) tty.c
X
Xunix.o:
X
Xunix.c:	unixunix.c hack.h mkroom.h
X	cp $(UNIX) unix.c
X
Xlint:
X# lint cannot have -p here because (i) capitals are meaningful:
X# [Ww]izard, (ii) identifiers may coincide in the first six places:
X# doweararm() versus dowearring().
X# _flsbuf comes from <stdio.h>, a bug in the system libraries.
X	@echo lint -axbh -DLINT ...
X	@lint -axbh -DLINT $(HACKCSRC) | sed '/_flsbuf/d'
X
X
Xdiff:
X	@- for i in $(SOURCES) $(AUX) ; do \
X		cmp -s $$i $D/$$i || \
X		( echo diff $D/$$i $$i ; diff $D/$$i $$i ; echo ) ; done
X
Xdistribution: Makefile
X	@- for i in READ_ME $(SOURCES) $(AUX) Makefile date.h onames.h\
X		; do \
X		cmp -s $$i $D/$$i || \
X		( echo cp $$i $D ; cp $$i $D ) ; done
X# the distribution directory also contains the empty files perm and record.
X
Xinitial:
X	-rm -rf $(GAMEDIR)
X	-mkdir $(SHELLDIR)
X	mkdir $(GAMEDIR) $(GAMEDIR)/save
X	touch $(GAMEDIR)/perm
X	touch $(GAMEDIR)/record
X	chown $(GAMEUID) $(GAMEDIR) $(GAMEDIR)/*
X	chgrp $(GAMEGRP) $(GAMEDIR) $(GAMEDIR)/*
X	chmod 666 $(GAMEDIR)/*
X	chmod 777 $(GAMEDIR) $(GAMEDIR)/save
X
Xinstall: $(VARAUX)
X	-rm -f $(GAMEDIR)/$(GAME)
X	-rm -f $(GAMEDIR)/bones*
X	-rm -f $(GAMEDIR)/save/*
X	cp help hh rumors data $(GAMEDIR)
X	cp $(GAME).sh $(SHELLDIR)/$(GAME)
X	cp $(GAME) $(GAMEDIR)/$(GAME)
X	chown $(GAMEUID) $(SHELLDIR)/$(GAME) $(GAMEDIR)/*
X	chgrp $(GAMEGRP) $(SHELLDIR)/$(GAME) $(GAMEDIR)/*
X	chmod 0755 $(SHELLDIR)/$(GAME)
X	chmod 04755 $(GAMEDIR)/$(GAME)
X	-cp nethack.6 $(MANDIR)
X
Xclean:
X	rm -f *.o
X
Xspotless: clean
X	rm -f a.out core $(GAME) makedefs
X	rm -f Makefile $(VARAUX) main.c tty.c unix.c
X
Xdepend:
X# For the moment we are lazy and disregard /usr/include files because
X# the sources contain them conditionally. Perhaps we should use cpp.
X#		( /bin/grep '^#[ 	]*include' $$i | sed -n \
X#			-e 's,<\(.*\)>,"/usr/include/\1",' \
X#
X	for i in ${CSOURCES}; do \
X		( /bin/grep '^#[ 	]*include[ 	]*"' $$i | sed -n \
X			-e 's/[^"]*"\([^"]*\)".*/\1/' \
X			-e H -e '$$g' -e '$$s/\n/ /g' \
X			-e '$$s/.*/'$$i': &/' -e '$$s/\.c:/.o:/p' \
X			>> makedep); done
X	for i in ${HSOURCES}; do \
X		( /bin/grep '^#[ 	]*include[ 	]*"' $$i | sed -n \
X			-e 's/[^"]*"\([^"]*\)".*/\1/' \
X			-e H -e '$$g' -e '$$s/\n/ /g' \
X			-e '$$s/.*/'$$i': &\
X				touch '$$i/p \
X			>> makedep); done
X	@echo '/^# DO NOT DELETE THIS LINE/+2,$$d' >eddep
X	@echo '$$r makedep' >>eddep
X	@echo 'w' >>eddep
X	@cp Makefile Makefile.bak
X	ed - Makefile < eddep
X	@rm -f eddep makedep
X	@echo '# DEPENDENCIES MUST END AT END OF FILE' >> Makefile
X	@echo '# IF YOU PUT STUFF HERE IT WILL GO AWAY' >> Makefile
X	@echo '# see make depend above' >> Makefile
X	- diff Makefile Makefile.bak
X	@rm -f Makefile.bak
X
X# DO NOT DELETE THIS LINE
X
Xdecl.o:  hack.h mkroom.h
Xapply.o:  hack.h edog.h mkroom.h
Xbones.o:  hack.h
Xhack.o:  hack.h
Xcmd.o:  hack.h func_tab.h
Xdo.o:  hack.h
Xdo_name.o:  hack.h
Xdo_wear.o:  hack.h
Xdog.o:  hack.h edog.h mkroom.h
Xdogmove.o:  hack.h mfndpos.h edog.h mkroom.h
Xdothrow.o:  hack.h
Xeat.o:  hack.h
Xend.o:  hack.h
Xengrave.o:  hack.h
Xfight.o:  hack.h
Xfountain.o:  hack.h mkroom.h
Xinvent.o:  hack.h wseg.h
Xioctl.o:  config.h
Xlev.o:  hack.h mkroom.h wseg.h
Xmakemon.o:  hack.h
Xmhitu.o:  hack.h
Xmklev.o:  hack.h mkroom.h
Xmkmaze.o:  hack.h mkroom.h
Xmkobj.o:  hack.h
Xmkshop.o:  hack.h mkroom.h eshk.h
Xmon.o:  hack.h mfndpos.h
Xmonmove.o:  hack.h mfndpos.h
Xmonst.o:  hack.h eshk.h
Xo_init.o:  config.h objects.h onames.h
Xobjnam.o:  hack.h
Xoptions.o:  hack.h
Xpager.o:  hack.h
Xpolyself.o: hack.h
Xpotion.o:  hack.h
Xpray.o:  hack.h
Xpri.o:  hack.h
Xprisym.o:  hack.h wseg.h
Xread.o:  hack.h
Xrip.o:  hack.h
Xrumors.o:  hack.h
Xsave.o:  hack.h
Xsearch.o:  hack.h
Xshk.o:  hack.h mfndpos.h mkroom.h eshk.h
Xshknam.o:  hack.h
Xsit.o: hack.h
Xspell.o:  hack.h
Xsteal.o:  hack.h
Xtermcap.o:  hack.h
Xtimeout.o:  hack.h
Xtopl.o:  hack.h
Xtopten.o:  hack.h
Xtrack.o:  hack.h
Xtrap.o:  hack.h edog.h mkroom.h
Xu_init.o:  hack.h
Xvault.o:  hack.h mkroom.h
Xwield.o:  hack.h
Xwizard.o:  hack.h
Xworm.o:  hack.h wseg.h
Xworn.o:  hack.h
Xwrite.o:  hack.h
Xzap.o:  hack.h
Xversion.o:  hack.h date.h
Xextern.h: config.h spell.h obj.h
X	touch extern.h
Xhack.h: extern.h flag.h gold.h monst.h objclass.h rm.h trap.h you.h 
X	touch hack.h
Xobjects.h:  config.h objclass.h
X	touch objects.h
Xyou.h: config.h onames.h permonst.h 
X	touch you.h
X# DEPENDENCIES MUST END AT END OF FILE
X# IF YOU PUT STUFF HERE IT WILL GO AWAY
X# see make depend above
END_OF_Makefile.att
if test 7004 -ne `wc -c <Makefile.att`; then
    echo shar: \"Makefile.att\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f eat.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"eat.c\"
else
echo shar: Extracting \"eat.c\" \(13762 characters\)
sed "s/^X//" >eat.c <<'END_OF_eat.c'
X/*	SCCS Id: @(#)eat.c	2.2	87/11/29
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X
X#include	"hack.h"
X#ifdef KAA
Xchar POISONOUS[] = "ADKSVabhks&";
X#else
Xchar POISONOUS[] = "ADKSVabhks";
X#endif
Xextern char *nomovemsg;
Xextern int (*afternmv)();
Xextern int (*occupation)();
Xextern char *occtxt;
Xextern struct obj *splitobj(), *addinv();
X
X/* hunger texts used on bottom line (each 8 chars long) */
X#define	SATIATED	0
X#define NOT_HUNGRY	1
X#define	HUNGRY		2
X#define	WEAK		3
X#define	FAINTING	4
X#define FAINTED		5
X#define STARVED		6
X
Xchar *hu_stat[] = {
X	"Satiated",
X	"        ",
X	"Hungry  ",
X	"Weak    ",
X	"Fainting",
X	"Fainted ",
X	"Starved "
X};
X
Xinit_uhunger(){
X	u.uhunger = 900;
X	u.uhs = NOT_HUNGRY;
X}
X
Xstruct { char *txt; int nut; } tintxts[] = {
X	"It contains salmon - not bad!",	60,
X	"It contains first quality peaches - what a surprise!",	40,
X	"It contains apple juice - perhaps not what you hoped for.", 20,
X	"It contains some nondescript substance, tasting awfully.", 500,
X	"It contains rotten meat. You vomit.", -50,
X	"It turns out to be empty.",	0
X};
X#define	TTSZ	SIZE(tintxts)
X
Xstatic struct {
X	struct obj *tin;
X	int usedtime, reqtime;
X} tin;
X
Xopentin(){
X	register int r;
X
X	if(!carried(tin.tin))		/* perhaps it was stolen? */
X		return(0);		/* %% probably we should use tinoid */
X	if(tin.usedtime++ >= 50) {
X		pline("You give up your attempt to open the tin.");
X		return(0);
X	}
X	if(tin.usedtime < tin.reqtime)
X		return(1);		/* still busy */
X
X	pline("You succeed in opening the tin.");
X	useup(tin.tin);
X	r = rn2(2*TTSZ);
X	if(r < TTSZ) {
X	    pline(tintxts[r].txt);
X	    lesshungry(tintxts[r].nut);
X	    /* check for vomiting added by GAN 01/16/87 */
X	    if(tintxts[r].nut < 0 && Sick) {
X		Sick = 0;
X		pline("What a relief!");
X	    }
X	    if(r == 0) {			/* Salmon */
X		Glib = rnd(15);
X		pline("Eating salmon made your fingers very slippery.");
X	    }
X	} else {
X	    pline("It contains spinach - this makes you feel like %s!",
X		Hallucination ? "Swee'pea" : "Popeye");
X
X	    lesshungry(600);
X	    gainstr(0);
X	}
X	return(0);
X}
X
XMeatdone(){
X	u.usym = '@';
X	prme();
X}
X
Xdoeat(){
X	register struct obj *otmp;
X	register struct objclass *ftmp;
X	register tmp;
X
X	/* Is there some food (probably a heavy corpse) here on the ground? */
X	if(!Levitation)
X	for(otmp = fobj; otmp; otmp = otmp->nobj) {
X		if(otmp->ox == u.ux && otmp->oy == u.uy &&
X		   otmp->olet == FOOD_SYM) {
X			pline("There %s %s here; eat %s? [ny] ",
X				(otmp->quan == 1) ? "is" : "are",
X				doname(otmp),
X				(otmp->quan == 1) ? "it" : "one");
X			if(readchar() == 'y') {
X				if(otmp->quan != 1)
X					(void) splitobj(otmp, 1);
X				freeobj(otmp);
X				otmp = addinv(otmp);
X				addtobill(otmp);
X				if(Invisible) newsym(u.ux, u.uy);
X				goto gotit;
X			}
X		}
X	}
X	otmp = getobj("%", "eat");
X	if(!otmp) return(0);
Xgotit:
X	if(otmp->otyp == TIN) {
X		if(uwep) {
X			switch(uwep->otyp) {
X			case CAN_OPENER:
X				tmp = 1;
X				break;
X			case DAGGER:
X			case CRYSKNIFE:
X				tmp = 3;
X				break;
X			case PICK_AXE:
X			case AXE:
X				tmp = 6;
X				break;
X			default:
X				goto no_opener;
X			}
X			pline("Using your %s you try to open the tin.",
X				aobjnam(uwep, (char *) 0));
X		} else {
X		no_opener:
X			pline("It is not so easy to open this tin.");
X			if(Glib) {
X				pline("The tin slips out of your hands.");
X				if(otmp->quan > 1) {
X					register struct obj *obj;
X					extern struct obj *splitobj();
X
X					obj = splitobj(otmp, 1);
X					if(otmp == uwep) setuwep(obj);
X				}
X				dropx(otmp);
X				return(1);
X			}
X			tmp = 10 + rn2(1 + 500/((int)(u.ulevel + u.ustr)));
X		}
X		tin.reqtime = tmp;
X		tin.usedtime = 0;
X		tin.tin = otmp;
X#ifdef DGK
X		set_occupation(opentin, "opening the tin", 0);
X#else
X		occupation = opentin;
X		occtxt = "opening the tin";
X#endif
X		return(1);
X	}
X	ftmp = &objects[otmp->otyp];
X	multi = -ftmp->oc_delay;
X	if(otmp->otyp >= CORPSE && eatcorpse(otmp)) goto eatx;
X#ifdef DGKMOD
X	if(!rn2(7) && otmp->otyp != FORTUNE_COOKIE && otmp->otyp != DEAD_LIZARD) {
X#else
X	if(!rn2(7) && otmp->otyp != FORTUNE_COOKIE) {
X#endif
X#ifdef KAA
X		if (otmp->otyp == DEAD_VIOLET_FUNGUS)
X			pline("Seems rather stale though...");
X		else
X#endif
X		pline("Blecch!  Rotten food!");
X		if(!rn2(4)) {
X			if (Hallucination) pline("You feel rather trippy.");
X			else
X				pline("You feel rather light headed.");
X			HConfusion += d(2,4);
X		} else if(!rn2(4) && !Blind) {
X			pline("Everything suddenly goes dark.");
X			Blinded = d(2,10);
X			seeoff(0);
X		} else if(!rn2(3)) {
X			if(Blind)
X			  pline("The world spins and you slap against the floor.");
X			else
X			  pline("The world spins and goes dark.");
X			nomul(-rnd(10));
X			nomovemsg = "You are conscious again.";
X		}
X		lesshungry(ftmp->nutrition / 4);
X	} else {
X		if(u.uhunger >= 1500) choke(ftmp);
X
X		switch(otmp->otyp){
X		case FOOD_RATION:
X			if(u.uhunger <= 200)
X			    if (Hallucination)
X				pline("Oh wow, like superior man!");
X			    else
X				pline("That food really hit the spot!");
X			else if(u.uhunger <= 700)
X				pline("That satiated your stomach!");
X#ifdef DGKMOD
X	/* Have lesshungry() report when you're nearly full so all eating
X	 * warns when you're about to choke.
X	 */
X			lesshungry(ftmp->nutrition);
X#else
X			else {
X	pline("You're having a hard time getting all that food down.");
X				multi -= 2;
X			}
X			lesshungry(ftmp->nutrition);
X			if(multi < 0) nomovemsg = "You finished your meal.";
X#endif /* DGKMOD /**/
X			break;
X		case TRIPE_RATION:
X			if (u.usym != '@')
X			    pline("That tripe ration was surprisingly good!");
X			else {
X			    pline("Yak - dog food!");
X			    more_experienced(1,0);
X			    flags.botl = 1;
X			}
X			if(rn2(2) && u.usym == '@'){
X				pline("You vomit.");
X				morehungry(20);
X				if(Sick) {
X					Sick = 0;	/* David Neves */
X					pline("What a relief!");
X				}
X			} else	lesshungry(ftmp->nutrition);
X			break;
X		default:
X			if(u.usym == '@' && otmp->otyp >= CORPSE) {
X#ifdef KAA
X			    if(otmp->otyp != DEAD_VIOLET_FUNGUS)
X#endif
X			    pline("That %s tasted terrible!",ftmp->oc_name);
X			} else
X			pline("That %s was delicious!",ftmp->oc_name);
X			lesshungry(ftmp->nutrition);
X#ifdef DGKMOD
X			/* Relief from cockatrices -dgk */
X			if (otmp->otyp == DEAD_LIZARD) {
X				if (Stoned) {
X					Stoned = 0;
X					pline("You feel more limber!");
X				}
X				if (HConfusion > 2)
X					HConfusion = 2;
X			}
X#else
X			if(otmp->otyp == DEAD_LIZARD && (HConfusion > 2))
X				HConfusion = 2;
X#endif /* DGKMOD /**/
X			else
X#ifdef QUEST
X			if(otmp->otyp == CARROT && !Blind) {
X				u.uhorizon++;
X				setsee();
X				pline("Your vision improves.");
X			} else
X#endif
X#ifdef KAA
X			if(otmp->otyp == CARROT && Blind) Blinded = 1;
X			else
X#endif
X			if(otmp->otyp == FORTUNE_COOKIE) {
X			  if(Blind) {
X			    pline("This cookie has a scrap of paper inside!");
X			    pline("What a pity, that you cannot read it!");
X			  } else
X			    outrumor();
X			} else
X			if(otmp->otyp == LUMP_OF_ROYAL_JELLY) {
X				/* This stuff seems to be VERY healthy! */
X				gainstr(1);
X				u.uhp += rnd(20);
X				if(u.uhp > u.uhpmax) {
X					if(!rn2(17)) u.uhpmax++;
X					u.uhp = u.uhpmax;
X				}
X				heal_legs();
X			}
X			break;
X		}
X	}
Xeatx:
X	if(multi<0 && !nomovemsg){
X		static char msgbuf[BUFSZ];
X		(void) sprintf(msgbuf, "You finished eating the %s.",
X				ftmp->oc_name);
X		nomovemsg = msgbuf;
X	}
X	useup(otmp);
X	return(1);
X}
X
X/* called in main.c */
Xgethungry(){
X	--u.uhunger;
X	if(moves % 2) {
X		if(HRegeneration) u.uhunger--;
X		if(Hunger) u.uhunger--;
X		/* a3:  if(Hunger & LEFT_RING) u.uhunger--;
X			if(Hunger & RIGHT_RING) u.uhunger--;
X		   etc. */
X	}
X	if(moves % 20 == 0) {			/* jimt@asgb */
X		if(uleft) u.uhunger--;
X		if(uright) u.uhunger--;
X	}
X	newuhs(TRUE);
X}
X
X/* called after vomiting and after performing feats of magic */
Xmorehungry(num) register num; {
X	u.uhunger -= num;
X	newuhs(TRUE);
X}
X
X/* called after eating something (and after drinking fruit juice) */
Xlesshungry(num) register num; {
X	u.uhunger += num;
X	if(u.uhunger >= 2000) choke((struct objclass *) 0);
X#ifdef DGKMOD
X	else {
X	    /* Have lesshungry() report when you're nearly full so all eating
X	     * warns when you're about to choke.
X	     */
X	    if (u.uhunger >= 1500) {
X		pline("You're having a hard time getting all of it down.");
X		multi -= 2;
X		nomovemsg = "You're finally finished.";
X	    }
X	}
X#endif /* DGKMOD /**/
X	newuhs(FALSE);
X}
X
Xunfaint(){
X	u.uhs = FAINTING;
X	flags.botl = 1;
X}
X
Xnewuhs(incr) boolean incr; {
X	register int newhs, h = u.uhunger;
X
X	newhs = (h > 1000) ? SATIATED :
X		(h > 150) ? NOT_HUNGRY :
X		(h > 50) ? HUNGRY :
X		(h > 0) ? WEAK : FAINTING;
X
X	if(newhs == FAINTING) {
X		if(u.uhs == FAINTED) newhs = FAINTED;
X		if(u.uhs <= WEAK || rn2(20-u.uhunger/10) >= 19) {
X			if(u.uhs != FAINTED && multi >= 0 /* %% */) {
X				pline("You faint from lack of food.");
X				nomul(-10+(u.uhunger/10));
X				nomovemsg = "You regain consciousness.";
X				afternmv = unfaint;
X				newhs = FAINTED;
X			}
X		} else
X		if(u.uhunger < -(int)(200 + 25*u.ulevel)) {
X			u.uhs = STARVED;
X			flags.botl = 1;
X			bot();
X			pline("You die from starvation.");
X			done("starved");
X		}
X	}
X
X	if(newhs != u.uhs) {
X		if(newhs >= WEAK && u.uhs < WEAK)
X			losestr(1);	/* this may kill you -- see below */
X		else
X		if(newhs < WEAK && u.uhs >= WEAK && u.ustr < u.ustrmax)
X			losestr(-1);
X		switch(newhs){
X		case HUNGRY:
X			if (Hallucination) {
X			    pline((!incr) ?
X				"You now have a lesser case of the munchies." :
X				"You are getting the munchies.");
X			} else
X			    pline((!incr) ? "You only feel hungry now." :
X				  (u.uhunger < 145) ? "You feel hungry." :
X				   "You are beginning to feel hungry.");
X			break;
X		case WEAK:
X			if (Hallucination)
X			    pline((!incr) ?
X				  "You still have the munchies." :
X				  "The munchies are starting to interfere with your motor capabilities.");
X			else
X			    pline((!incr) ? "You feel weak now." :
X				  (u.uhunger < 45) ? "You feel weak." :
X				   "You are beginning to feel weak.");
X			break;
X		}
X		u.uhs = newhs;
X		flags.botl = 1;
X		if(u.uhp < 1) {
X			pline("You die from hunger and exhaustion.");
X			killer = "exhaustion";
X			done("starved");
X		}
X	}
X}
X
X#define	CORPSE_I_TO_C(otyp)	(char) ((otyp >= DEAD_ACID_BLOB)\
X		     ?  'a' + (otyp - DEAD_ACID_BLOB)\
X		     :	'@' + (otyp - DEAD_HUMAN))
Xpoisonous(otmp)
Xregister struct obj *otmp;
X{
X#ifdef KAA
X	if(otmp->otyp == DEAD_DEMON) return(1);
X#endif
X	return(index(POISONOUS, CORPSE_I_TO_C(otmp->otyp)) != 0);
X}
X
X/* returns 1 if some text was printed */
Xeatcorpse(otmp) register struct obj *otmp; {
X#ifdef KAA
Xregister char let;
X#else
Xregister char let = CORPSE_I_TO_C(otmp->otyp);
X#endif
Xregister tp = 0;
X#ifdef KAA
X	if(otmp->otyp == DEAD_DEMON) let='&';
X	else if (otmp->otyp == DEAD_GIANT) let='9';
X	else let = CORPSE_I_TO_C(otmp->otyp);
X#endif
X	if(let != 'a' && moves > otmp->age + 50 + rn2(100)) {
X		tp++;
X		pline("Ulch -- that meat was tainted!");
X		pline("You get very sick.");
X		Sick = 10 + rn2(10);
X		u.usick_cause = objects[otmp->otyp].oc_name;
X	} else if(index(POISONOUS, let) && rn2(5)){
X		tp++;
X		pline("Ecch -- that must have been poisonous!");
X		if(!Poison_resistance){
X			losestr(rnd(4));
X			losehp(rnd(15), "poisonous corpse");
X		} else
X			pline("You don't seem affected by the poison.");
X	} else if(index("ELNOPQRUuxz", let) && rn2(5)){
X		tp++;
X		pline("You feel sick.");
X		losehp(rnd(8), "cadaver");
X	}
X	switch(let) {
X	case 'L':
X	case 'N':
X	case 't':
X#ifdef KAA
X	case 'Q':
X#endif
X		HTeleportation |= INTRINSIC;
X		break;
X	case 'W':
X		pluslvl();
X		break;
X	case 'n':
X		u.uhp = u.uhpmax;
X		flags.botl = 1;
X		/* fall into next case */
X#ifdef SAC
X	case '3':
X#endif
X	case '@':
X		pline("You cannibal! You will be sorry for this!");
X		/* not tp++; */
X		/* fall into next case */
X	case 'd':
X		Aggravate_monster |= INTRINSIC;
X		break;
X	case 'I':
X		if(!Invis) {
X			HInvis = 50+rn2(100);
X			if(!See_invisible)
X				newsym(u.ux, u.uy);
X		} else {
X			HInvis |= INTRINSIC;
X			HSee_invisible |= INTRINSIC;
X		}
X		/* fall into next case */
X	case 'y':
X#ifdef QUEST
X		u.uhorizon++;
X#endif
X		/* fall into next case */
X	case 'B':
X		HConfusion += 50;
X		break;
X	case 'D':
X		HFire_resistance |= INTRINSIC;
X		break;
X	case 'E':
X		HTelepat |= INTRINSIC;
X		break;
X	case 'F':
X	case 'Y':
X		HCold_resistance |= INTRINSIC;
X		break;
X#ifdef KAA
X	case '9':
X		gainstr(1);
X		break;
X#endif
X#ifdef KJSMODS
X	case 'S':	/* if a snake can kill you with poison, at least
X			 * have the possibility of getting resistance */
X		if ( rn2(5) ) break;
X		/* fall into next case */
X#endif
X	case 'k':
X	case 's':
X		HPoison_resistance |= INTRINSIC;
X		break;
X	case 'c':
X		if (u.usym != 'c') {
X
X			pline("You turn to stone.");
X			killer = "dead cockatrice";
X			done("died");
X		}
X		break;
X	case 'a':
X	  if(Stoned) {
X	      pline("What a pity - you just destroyed a future piece of art!");
X	      tp++;
X	      Stoned = 0;
X	  }
X	  break;
X#ifdef KAA
X	case 'v':
X		pline ("Oh wow!  Great stuff!");
X		Hallucination += 200;
X		setsee();
X		break;
X#endif
X	case 'M':
X		if(u.usym == '@') {
X		    pline("You cannot resist the temptation to mimic a treasure chest.");
X		    tp++;
X		    nomul(-30);
X		    afternmv = Meatdone;
X		    nomovemsg = "You now again prefer mimicking a human.";
X		    u.usym = GOLD_SYM;
X		    prme();
X		}
X		break;
X	}
X	return(tp);
X}
X
X/* Created by GAN 01/28/87
X * Amended by AKP 09/22/87: if not hard, don't choke, just vomit.
X *
X * Note that if you have enough food, you can always stop being Sick!
X * choke() returns if you don't choke, kills you if you do.
X */
Xchoke(food)
Xregister struct objclass *food;
X{
X	/* only happens if you were satiated */
X	if(u.uhs != SATIATED) return;
X#ifdef HARD
X	if(food)	killer = food->oc_name;
X	else		killer = "exuberant appetite";
X	pline("You choke over your food.");
X	pline("You die...");
X	done("choked");
X#else
X	pline("You stuff yourself and then vomit voluminously.");
X	morehungry(1000);	/* you just got *very* sick! */
X	if(Sick) {
X		Sick = 0;	/* A good idea from David Neves */
X		pline("What a relief!");
X	}
X#endif
X}
END_OF_eat.c
if test 13762 -ne `wc -c <eat.c`; then
    echo shar: \"eat.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f msdos.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"msdos.c\"
else
echo shar: Extracting \"msdos.c\" \(15042 characters\)
sed "s/^X//" >msdos.c <<'END_OF_msdos.c'
X/*	SCCS Id: @(#)msdos.c	2.1	87/10/19
X/* An assortment of MSDOS functions.
X */
X
X#include <stdio.h>
X#include "hack.h"
X
X#ifdef MSDOS
X# include <dos.h>
X
Xvoid
Xflushout()
X{
X	(void) fflush(stdout);
X}
X
Xgetuid() {
X	return 1;
X}
X
Xchar *
Xgetlogin() {
X	return ((char *) NULL);
X}
X# ifdef REDO
Xtgetch() {
X	char ch, popch();
X	static char DOSgetch(), BIOSgetch();
X
X	if (!(ch = popch())) {
X#  ifdef DGK
X		/* BIOSgetch can use the numeric key pad on IBM compatibles. */
X		if (flags.IBMBIOS)
X			ch = BIOSgetch();
X		else
X#  endif
X			ch = DOSgetch();
X	}
X	return ((ch == '\r') ? '\n' : ch);
X}
X# else /* REDO /**/
Xtgetch() {
X	char ch;
X	static char DOSgetch(), BIOSgetch();
X
X#  ifdef DGK
X	/* BIOSgetch can use the numeric key pad on IBM compatibles. */
X	if (flags.IBMBIOS)
X		ch = BIOSgetch();
X	else
X#  endif
X		ch = DOSgetch();
X	return ((ch == '\r') ? '\n' : ch);
X}
X# endif /* REDO /**/
X
X# define DIRECT_INPUT	0x7
Xstatic char
XDOSgetch() {
X	union REGS regs;
X
X	regs.h.ah = DIRECT_INPUT;
X	intdos(&regs, &regs);
X	if (!regs.h.al) {	/* an extended code -- not yet supported */
X		regs.h.ah = DIRECT_INPUT;
X		intdos(&regs, &regs);	/* eat the next character */
X		regs.h.al = 0;		/* and return a 0 */
X	}
X	return (regs.h.al);
X}
X
X
X# ifdef DGK
X#  include <ctype.h>
X#  include <fcntl.h>
X
X#  define Sprintf (void) sprintf
X#  define WARN 1
X#  define NOWARN 0
X
Xstatic char *
Xgetcomspec(warn) {
X	return getenv("COMSPEC");
X}
X
X#  ifdef SHELL
X#   include <process.h>
Xdosh() {
X	extern char orgdir[];
X	char *comspec;
X
X	if (comspec = getcomspec()) {
X		settty("To return to HACK, type \"exit\" at the DOS prompt.\n");
X		chdirx(orgdir, 0);
X		if (spawnl(P_WAIT, comspec, comspec, NULL) < 0) {
X			printf("\nCan't spawn %s !\n", comspec);
X			flags.toplin = 0;
X			more();
X		}
X		chdirx(hackdir, 0);
X		start_screen();
X		docrt();
X	} else
X		pline("No COMSPEC !?  Can't exec COMMAND.COM");
X	return(0);
X}
X#  endif /* SHELL */
X
X/* Normal characters are output when the shift key is not pushed.
X * Shift characters are output when either shift key is pushed.
X */
X#  define KEYPADHI	83
X#  define KEYPADLOW	71
X#  define iskeypad(x)	(KEYPADLOW <= (x) && (x) <= KEYPADHI)
Xstatic struct {
X	char normal, shift;
X	} keypad[KEYPADHI - KEYPADLOW + 1] = {
X			{'y', 'Y'},		/* 7 */
X			{'k', 'K'},		/* 8 */
X			{'u', 'U'},		/* 9 */
X			{'m', CTRL('P')},	/* - */
X			{'h', 'H'},		/* 4 */
X			{'g', 'g'},		/* 5 */
X			{'l', 'L'},		/* 6 */
X			{'p', 'P'},		/* + */
X			{'b', 'B'},		/* 1 */
X			{'j', 'J'},		/* 2 */
X			{'n', 'N'},		/* 3 */
X			{'i', 'I'},		/* Ins */
X			{'.', ':'}		/* Del */
X};
X
X/* BIOSgetch gets keys directly with a BIOS call.
X */
X#  define SHIFT		(0x1 | 0x2)
X#  define KEYBRD_BIOS	0x16
X
Xstatic char
XBIOSgetch() {
X	unsigned char scan, shift, ch;
X	union REGS regs;
X
X	/* Get scan code.
X	 */
X	regs.h.ah = 0;
X	int86(KEYBRD_BIOS, &regs, &regs);
X	ch = regs.h.al;
X	scan = regs.h.ah;
X
X	/* Get shift status.
X	 */
X	regs.h.ah = 2;
X	int86(KEYBRD_BIOS, &regs, &regs);
X	shift = regs.h.al;
X
X	/* If scan code is for the keypad, translate it.
X	 */
X	if (iskeypad(scan)) {
X		if (shift & SHIFT)
X			ch = keypad[scan - KEYPADLOW].shift;
X		else
X			ch = keypad[scan - KEYPADLOW].normal;
X	}
X	return ch;
X}
X
X/* construct the string  file.level */
Xvoid
Xname_file(file, level)
Xchar *file;
Xint level;
X{
X	char *tf;
X	
X	if (tf = rindex(file, '.'))
X		Sprintf(tf+1, "%d", level);
X}
X
X
X#  define FINDFIRST	0x4E00
X#  define FINDNEXT	0x4F00
X#  define GETDTA	0x2F00
X#  define SETFILETIME	0x5701
X#  define GETSWITCHAR	0x3700
X#  define FREESPACE	0x36
X
Xstatic char
Xswitchar()
X{
X	union REGS regs;
X
X	regs.x.ax = GETSWITCHAR;
X	intdos(&regs, &regs);
X	return regs.h.dl;
X}
X
Xlong
Xfreediskspace(path)
Xchar *path;
X{
X	union REGS regs;
X
X	regs.h.ah = FREESPACE;
X	if (path[0] && path[1] == ':')
X		regs.h.dl = (toupper(path[0]) - 'A') + 1;
X	else
X		regs.h.dl = 0;
X	intdos(&regs, &regs);
X	if (regs.x.ax == 0xFFFF)
X		return -1L;		/* bad drive number */
X	else
X		return ((long) regs.x.bx * regs.x.cx * regs.x.ax);
X}
X
X/* Functions to get filenames using wildcards
X */
Xstatic
Xfindfirst(path)
Xchar *path;
X{
X	union REGS regs;
X	struct SREGS sregs;
X
X	regs.x.ax = FINDFIRST;
X	regs.x.cx = 0;		/* normal files */
X	regs.x.dx = FP_OFF(path);
X	sregs.ds = FP_SEG(path);
X	intdosx(&regs, &regs, &sregs);
X	return !regs.x.cflag;
X}
X
Xstatic
Xfindnext() {
X	union REGS regs;
X
X	regs.x.ax = FINDNEXT;
X	intdos(&regs, &regs);
X	return !regs.x.cflag;
X}
X
X#ifndef __TURBOC__
X/* Get disk transfer area, Turbo C already has getdta */
Xstatic char *
Xgetdta() {
X	union REGS regs;
X	struct SREGS sregs;
X	char *ret;
X
X	regs.x.ax = GETDTA;
X	intdosx(&regs, &regs, &sregs);
X	FP_OFF(ret) = regs.x.bx;
X	FP_SEG(ret) = sregs.es;
X	return ret;
X}
X#endif
X
Xlong
Xfilesize(file)
Xchar *file;
X{
X	char *dta;
X
X	if (findfirst(file)) {
X		dta = getdta();
X		return  (* (long *) (dta + 26));
X	} else
X		return -1L;
X}
X
Xvoid
Xeraseall(path, files)
Xchar *path, *files;
X{
X	char	*dta, buf[PATHLEN];
X
X	dta = getdta();
X	Sprintf(buf, "%s%s", path, files);
X	if (findfirst(buf))
X		do {
X			Sprintf(buf, "%s%s", path, dta + 30);
X			(void) unlink(buf);
X		} while (findnext());
X}
X
X/* Rewritten for version 3.3 to be faster
X */
Xvoid
Xcopybones(mode) {
X	char from[PATHLEN], to[PATHLEN], last[13], copy[8];
X	char *frompath, *topath, *dta, *comspec;
X	int status;
X	long fs;
X	extern saveprompt;
X
X	if (!ramdisk)
X		return;
X
X	/* Find the name of the last file to be transferred
X	 */
X	frompath = (mode != TOPERM) ? permbones : levels;
X	dta = getdta();
X	last[0] = '\0';
X	Sprintf(from, "%s%s", frompath, allbones);
X	if (findfirst(from))
X		do {
X			strcpy(last, dta + 30);
X		} while (findnext());
X
X	topath = (mode == TOPERM) ? permbones : levels;
X	if (last[0]) {
X		Sprintf(copy, "%cC copy", switchar());
X
X		/* Remove any bones files in `to' directory.
X		 */
X		eraseall(topath, allbones);
X
X		/* Copy `from' to `to' */
X		Sprintf(to, "%s%s", topath, allbones);
X		comspec = getcomspec();
X		status =spawnl(P_WAIT, comspec, comspec, copy, from,
X			to, "> nul", NULL);
X	} else
X		return;
X
X	/* See if the last file got there.  If so, remove the ramdisk bones
X	 * files.
X	 */
X	Sprintf(to, "%s%s", topath, last);
X	if (findfirst(to)) {
X		if (mode == TOPERM)
X			eraseall(frompath, allbones);
X		return;
X	}
X
X	/* Last file didn't get there.
X	 */
X	Sprintf(to, "%s%s", topath, allbones);
X	msmsg("Cannot copy `%s' to `%s' -- %s\n", from, to,
X		(status < 0) ? "can't spawn COMSPEC !" :
X		(freediskspace(topath) < filesize(from)) ?
X			"insufficient disk space." : "bad path(s)?");
X	if (mode == TOPERM) {
X		msmsg("Bones will be left in `%s'\n",
X			*levels ? levels : hackdir);
X		return;
X	} else {
X		/* Remove all bones files on the RAMdisk */
X		eraseall(levels, allbones);
X		playwoRAMdisk();
X	}
X}
X
XplaywoRAMdisk() {
X	msmsg("Do you wish to play without a RAMdisk (y/n) ? ");
X
X	/* Set ramdisk false *before* exit'ing (because msexit calls
X	 * copybones)
X	 */
X	ramdisk = FALSE;
X	if (getchar() != 'y') {
X		settty("Be seeing you ...\n");
X		exit(0);
X	}
X	set_lock_and_bones();
X	return;
X}
X
XsaveDiskPrompt(start) {
X	extern saveprompt;
X	char buf[BUFSIZ], *bp;
X	int fd;
X
X	if (saveprompt) {
X		/* Don't prompt if you can find the save file */
X		if ((fd = open(SAVEF, 0)) >= 0) {
X			(void) close(fd);
X			return 1;
X		}
X		remember_topl();
X		home();
X		cl_end();
X		msmsg("If save file is on a SAVE disk, put that disk in now.\n");
X		cl_end();
X		msmsg("File name (default `%s'%s) ? ", SAVEF,
X			start ? "" : ", <Esc> cancels save");
X		getlin(buf);
X		home();
X		cl_end();
X		curs(1, 2);
X		cl_end();
X		if (!start && *buf == '\033')
X			return 0;
X
X		/* Strip any whitespace. Also, if nothing was entered except
X		 * whitespace, do not change the value of SAVEF.
X		 */
X		for (bp = buf; *bp; bp++)
X			if (!isspace(*bp)) {
X				strncpy(SAVEF, bp, PATHLEN);
X				break;
X			}
X	}
X	return 1;
X}
X
X/* Return 1 if the record file was found */
Xstatic
Xrecord_exists() {
X	int fd;
X
X	if ((fd = open(RECORD, 0)) >= 0) {
X		close(fd);
X		return TRUE;
X	}
X	return FALSE;
X}
X
X/* Return 1 if the comspec was found */
Xstatic
Xcomspec_exists() {
X	int fd;
X	char *comspec;
X
X	if (comspec = getcomspec())
X		if ((fd = open(comspec, 0)) >= 0) {
X			close(fd);
X			return TRUE;
X		}
X	return FALSE;
X}
X
X/* Prompt for game disk, then check for record file.
X */
Xvoid
XgameDiskPrompt() {
X	extern saveprompt;
X
X	if (saveprompt) {
X		if (record_exists() && comspec_exists())
X			return;
X		(void) putchar('\n');
X		getreturn("when the GAME disk has been put in");
X	}
X	if (comspec_exists() && record_exists())
X		return;
X
X	if (!comspec_exists())
X		msmsg("\n\nWARNING: can't find comspec `%s'!\n", getcomspec());
X	if (!record_exists())
X		msmsg("\n\nWARNING: can't find record file `%s'!\n", RECORD);
X	msmsg("If the GAME disk is not in, put it in now.\n");
X	getreturn("to continue");
X}
X
X/* Read configuration */
Xvoid
Xread_config_file() {
X	char	tmp_ramdisk[PATHLEN], tmp_levels[PATHLEN];
X	char	buf[BUFSZ], *bufp;
X	FILE	*fp, *fopenp();
X	extern	char plname[];
X	extern	int saveprompt;
X
X	tmp_ramdisk[0] = 0;
X	tmp_levels[0] = 0;
X	if ((fp = fopenp(configfile, "r")) == NULL) {
X		msmsg("Warning: no configuration file!\n");
X		getreturn("to continue");
X		return;
X	}
X	while (fgets(buf, BUFSZ, fp)) {
X		if (*buf == '#')
X			continue;
X
X		/* remove trailing whitespace
X		 */
X		bufp = index(buf, '\n');
X		while (bufp > buf && isspace(*bufp))
X			bufp--;
X		if (bufp == buf)
X			continue;		/* skip all-blank lines */
X		else
X			*(bufp + 1) = 0;	/* 0 terminate line */
X
X		/* find the '=' */
X		if (!(bufp = strchr(buf, '='))) {
X			msmsg("Bad option line: '%s'\n", buf);
X			getreturn("to continue");
X			continue;
X		}
X		
X		/* skip  whitespace between '=' and value */
X		while (isspace(*++bufp))
X			;
X
X		/* Go through possible variables */
X		if (!strncmp(buf, "HACKDIR", 4)) {
X			strncpy(hackdir, bufp, PATHLEN);
X		
X		} else if (!strncmp(buf, "RAMDISK", 3)) {
X			strncpy(tmp_ramdisk, bufp, PATHLEN);
X
X		} else if (!strncmp(buf, "LEVELS", 4)) {
X			strncpy(tmp_levels, bufp, PATHLEN);
X
X		} else if (!strncmp(buf, "OPTIONS", 4)) {
X			parseoptions(bufp, TRUE);
X			if (plname[0])		/* If a name was given */
X				plnamesuffix();	/* set the character class */
X
X		} else if (!strncmp(buf, "SAVE", 4)) {
X			char *ptr;
X			if (ptr = index(bufp, ';')) {
X				*ptr = '\0';
X				if (*(ptr+1) == 'n' || *(ptr+1) == 'N')
X					saveprompt = FALSE;
X			}
X			(void) strncpy(SAVEF, bufp, PATHLEN);
X			append_slash(SAVEF);
X#ifdef GRAPHICS
X		} else if (!strncmp(buf, "GRAPHICS", 4)) {
X			char translate[17];
X			short i;
X
X		     if ((i = sscanf(bufp, "%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u",
X				&translate[0], &translate[1], &translate[2],
X				&translate[3], &translate[4], &translate[5],
X				&translate[6], &translate[7], &translate[8],
X				&translate[9], &translate[10], &translate[11],
X				&translate[12], &translate[13], &translate[14],
X				&translate[15], &translate[16])) < 0) {
X					msmsg ("Syntax error in GRAPHICS\n");
X					getreturn("to continue");
X			}
X			translate[i] = '\0';
X#endif /* GRAPHICS /**/
X/*
X * You could have problems here if you configure FOUNTAINS, SPIDERS or NEWCLASS
X * in or out and forget to change the tail entries in your graphics string.
X */
X#define SETPCHAR(f, n)	showsyms.f = (strlen(translate) > n) ? translate[n] : defsyms.f
X			SETPCHAR(stone, 0);
X			SETPCHAR(vwall, 1);
X			SETPCHAR(hwall, 2);
X			SETPCHAR(tlcorn, 3);
X			SETPCHAR(trcorn, 4);
X			SETPCHAR(blcorn, 5);
X			SETPCHAR(brcorn, 6);
X			SETPCHAR(door, 7);
X			SETPCHAR(room, 8);
X			SETPCHAR(corr, 9);
X			SETPCHAR(upstair, 10);
X			SETPCHAR(dnstair, 11);
X			SETPCHAR(trap, 12);
X#ifdef FOUNTAINS
X			SETPCHAR(pool, 13);
X			SETPCHAR(fountain, 14);
X#endif
X#ifdef NEWCLASS
X			SETPCHAR(throne, 15);
X#endif
X#ifdef SPIDERS
X			SETPCHAR(web, 16);
X#endif
X#undef SETPCHAR
X		} else {
X			msmsg("Bad option line: '%s'\n", buf);
X			getreturn("to continue");
X		}
X	}
X	fclose(fp);
X
X	strcpy(permbones, tmp_levels);
X	if (tmp_ramdisk[0]) {
X		strcpy(levels, tmp_ramdisk);
X		if (strcmpi(permbones, levels))		/* if not identical */
X			ramdisk = TRUE;
X	} else
X		strcpy(levels, tmp_levels);
X	strcpy(bones, levels);
X}
X
X/* Set names for bones[] and lock[]
X */
Xvoid
Xset_lock_and_bones() {
X	if (!ramdisk) {
X		strcpy(levels, permbones);
X		strcpy(bones, permbones);
X	}
X	append_slash(permbones);
X	append_slash(levels);
X	append_slash(bones);
X	strcat(bones, allbones);
X	strcpy(lock, levels);
X	strcat(lock, alllevels);
X}
X
X/* Add a backslash to any name not ending in /, \ or :   There must
X * be room for the \
X */
Xvoid
Xappend_slash(name)
Xchar *name;
X{
X	char *ptr;
X
X	if (!*name)
X		return;
X	ptr = name + (strlen(name) - 1);
X	if (*ptr != '\\' && *ptr != '/' && *ptr != ':') {
X		*++ptr = '\\';
X		*++ptr = '\0';
X	}
X}
X
X
Xvoid
Xgetreturn(str)
Xchar *str;
X{
X	int ch;
X
X	msmsg("Hit <RETURN> %s.", str);
X	while ((ch = getchar()) != '\n')
X		;
X}
X
Xvoid
Xmsmsg(fmt, a1, a2, a3)
Xchar *fmt;
Xlong a1, a2, a3;
X{
X	printf(fmt, a1, a2, a3);
X	flushout();
X}
X
X/* Chdrive() changes the default drive.
X */
X#define SELECTDISK	0x0E
Xvoid
Xchdrive(str)
Xchar *str;
X{
X	char *ptr;
X	union REGS inregs;
X	char drive;
X
X	if ((ptr = index(str, ':')) != NULL) {
X		drive = toupper(*(ptr - 1));
X		inregs.h.ah = SELECTDISK;
X		inregs.h.dl = drive - 'A';
X		intdos(&inregs, &inregs);
X	}
X}
X
X/* Use the IOCTL DOS function call to change stdin and stdout to raw
X * mode.  For stdin, this prevents MSDOS from trapping ^P, thus
X * freeing us of ^P toggling 'echo to printer'.
X * Thanks to Mark Zbikowski (markz@microsoft.UUCP).
X */
X
X#  define DEVICE	0x80
X#  define RAW		0x20
X#  define IOCTL		0x44
X#  define STDIN		fileno(stdin)
X#  define STDOUT	fileno(stdout)
X#  define GETBITS	0
X#  define SETBITS	1
X
Xstatic unsigned	old_stdin, old_stdout, ioctl();
X
Xdisable_ctrlP() {
X	if (!flags.rawio)
X		return;
X	old_stdin = ioctl(STDIN, GETBITS, 0);
X	old_stdout = ioctl(STDOUT, GETBITS, 0);
X	if (old_stdin & DEVICE)
X		ioctl(STDIN, SETBITS, old_stdin | RAW);
X	if (old_stdout & DEVICE)
X		ioctl(STDOUT, SETBITS, old_stdout | RAW);
X}
X
Xenable_ctrlP() {
X	if (!flags.rawio)
X		return;
X	if (old_stdin)
X		(void) ioctl(STDIN, SETBITS, old_stdin);
X	if (old_stdout)
X		(void) ioctl(STDOUT, SETBITS, old_stdout);
X}
X
Xstatic unsigned
Xioctl(handle, mode, setvalue)
Xunsigned setvalue;
X{
X	union REGS regs;
X
X	regs.h.ah = IOCTL;
X	regs.h.al = mode;
X	regs.x.bx = handle;
X	regs.h.dl = setvalue;
X	regs.h.dh = 0;			/* Zero out dh */
X	intdos(&regs, &regs);
X	return (regs.x.dx);
X}
X
X/* Follow the PATH, trying to fopen the file.
X */
X#define PATHSEP	';'
X
XFILE *
Xfopenp(name, mode)
Xchar *name, *mode;
X{
X	char buf[BUFSIZ], *bp, *pp, *getenv(), lastch;
X	FILE *fp;
X
X	/* Try the default directory first.  Then look along PATH.
X	 */
X	strcpy(buf, name);
X	if (fp = fopen(buf, mode))
X		return fp;
X	else {
X		pp = getenv("PATH");
X		while (pp && *pp) {
X			bp = buf;
X			while (*pp && *pp != PATHSEP)
X				lastch = *bp++ = *pp++;
X			if (lastch != '\\' && lastch != '/')
X				*bp++ = '\\';
X			strcpy(bp, name);
X			if (fp = fopen(buf, mode))
X				return fp;
X			if (*pp)
X				pp++;
X		}
X	}
X	return NULL;
X}
X# endif /* DGK */
X
X/* Chdir back to original directory
X */
X# undef exit
Xvoid
Xmsexit(code)
X{
X# ifdef CHDIR
X	extern char orgdir[];
X# endif
X
X# ifdef DGK
X	flushout();
X	enable_ctrlP();		/* in case this wasn't done */
X	if (ramdisk)
X		copybones(TOPERM);
X# endif
X# ifdef CHDIR
X	chdir(orgdir);		/* chdir, not chdirx */
X#  ifdef DGK
X	chdrive(orgdir);
X#  endif
X# endif
X	exit(code);
X}
X#endif /* MSDOS */
END_OF_msdos.c
if test 15042 -ne `wc -c <msdos.c`; then
    echo shar: \"msdos.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f objects.h -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"objects.h\"
else
echo shar: Extracting \"objects.h\" \(15739 characters\)
sed "s/^X//" >objects.h <<'END_OF_objects.h'
X/*	SCCS Id: @(#)objects.h	2.2	87/11/29
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X
X/* objects have letter " % ) ( 0 _ ` [ ! ? / = * + */
X#include "config.h"
X#include "objclass.h"
X#define	NULL	(char *)0
X
Xstruct objclass objects[] = {
X
X	{ "strange object", NULL, NULL, 1, 0,
X		ILLOBJ_SYM, 0, 0, 0, 0, 0, 0 },
X	{ "amulet of Yendor", NULL, NULL, 1, 0,
X		AMULET_SYM, 100, 0, 2, 0, 0, 0 },
X
X#define	FOOD(name,prob,delay,weight,nutrition)	{ name, NULL, NULL, 1, 1,\
X		FOOD_SYM, prob, delay, weight, 0, 0, nutrition }
X
X/* dog eats foods 0-4 but prefers 1 above 0,2,3,4 */
X/* food 4 can be read */
X/* food 5 improves your vision */
X/* food 6 makes you stronger (like Popeye) */
X/* foods CORPSE up to CORPSE+52 are cadavers */
X
X	FOOD("food ration", 	46, 5, 4, 800),
X	FOOD("tripe ration",	16, 1, 2, 200),
X	FOOD("pancake",		3, 1, 1, 200),
X	FOOD("dead lizard",	3, 0, 1, 40),
X	FOOD("fortune cookie",	7, 0, 1, 40),
X	FOOD("carrot",		2, 0, 1, 50),
X	FOOD("slice of pizza",	5, 0, 1, 250),
X	FOOD("cream pie",	3, 0, 1, 100),
X	FOOD("tin",		7, 0, 1, 0),
X	FOOD("orange",		1, 0, 1, 80),
X	FOOD("apple",		1, 0, 1, 50),
X	FOOD("pear",		1, 0, 1, 50),
X	FOOD("melon",		1, 0, 1, 100),
X	FOOD("banana",		1, 0, 1, 80),
X	FOOD("candy bar",	1, 0, 1, 100),
X	FOOD("egg",		1, 0, 1, 80),
X	FOOD("clove of garlic",	1, 0, 1, 40),
X	FOOD("lump of royal jelly", 0, 0, 1, 200),
X
X	FOOD("dead human",	0, 4, 40, 400),
X	FOOD("dead giant ant",	0, 1, 3, 30),
X	FOOD("dead giant bat",	0, 1, 3, 30),
X	FOOD("dead centaur",	0, 5, 50, 500),
X	FOOD("dead dragon",	0, 15, 150, 1500),
X	FOOD("dead floating eye",	0, 1, 1, 10),
X	FOOD("dead freezing sphere",	0, 1, 1, 10),
X	FOOD("dead gnome",	0, 1, 10, 100),
X	FOOD("dead hobgoblin",	0, 2, 20, 200),
X	FOOD("dead stalker",	0, 4, 40, 400),
X	FOOD("dead jackal",	0, 1, 10, 100),
X	FOOD("dead kobold",	0, 1, 10, 100),
X	FOOD("dead leprechaun",	0, 4, 40, 400),
X	FOOD("dead mimic",	0, 4, 40, 400),
X	FOOD("dead nymph",	0, 4, 40, 400),
X	FOOD("dead orc",	0, 2, 20, 200),
X	FOOD("dead purple worm",	0, 7, 70, 700),
X	FOOD("dead quantum mechanic", 0, 2, 20, 200),
X	FOOD("dead rust monster",	0, 5, 50, 500),
X	FOOD("dead snake",	0, 1, 10, 100),
X	FOOD("dead troll",	0, 4, 40, 400),
X	FOOD("dead umber hulk",	0, 5, 50, 500),
X	FOOD("dead vampire",	0, 4, 40, 400),
X	FOOD("dead wraith",	0, 1, 1, 10),
X	FOOD("dead xorn",	0, 7, 70, 700),
X	FOOD("dead yeti",	0, 7, 70, 700),
X	FOOD("dead zombie",	0, 1, 3, 30),
X	FOOD("dead acid blob",	0, 1, 3, 30),
X	FOOD("dead giant beetle",	0, 1, 1, 10),
X	FOOD("dead cockatrice",	0, 1, 3, 30),
X	FOOD("dead dog",	0, 2, 20, 200),
X	FOOD("dead ettin",	0, 1, 3, 30),
X	FOOD("dead fog cloud",	0, 1, 1, 10),
X	FOOD("dead gelatinous cube",	0, 1, 10, 100),
X	FOOD("dead homunculus",	0, 2, 20, 200),
X	FOOD("dead imp",	0, 1, 1, 10),
X	FOOD("dead jaguar",	0, 3, 30, 300),
X	FOOD("dead killer bee",	0, 1, 1, 10),
X	FOOD("dead leocrotta",	0, 5, 50, 500),
X	FOOD("dead minotaur",	0, 7, 70, 700),
X	FOOD("dead nurse",	0, 4, 40, 400),
X	FOOD("dead owlbear",	0, 7, 70, 700),
X	FOOD("dead piercer",	0, 2, 20, 200),
X	FOOD("dead quivering blob",	0, 1, 10, 100),
X	FOOD("dead giant rat",	0, 1, 3, 30),
X	FOOD("dead giant scorpion",	0, 1, 10, 100),
X	FOOD("dead tengu",	0, 3, 30, 300),
X	FOOD("dead unicorn",	0, 3, 30, 300),
X	FOOD("dead violet fungus",	0, 1, 10, 100),
X	FOOD("dead long worm",	0, 5, 50, 500),
X/* %% wt of long worm should be proportional to its length */
X	FOOD("dead xan",	0, 3, 30, 300),
X	FOOD("dead yellow light",	0, 1, 1, 10),
X	FOOD("dead zruty",	0, 6, 60, 600),
X#ifdef SAC
X	FOOD("dead soldier",	0, 4, 40, 400),
X#endif /* SAC */
X	FOOD("dead giant",	0, 7, 70, 700),
X	FOOD("dead demon",	0, 8, 80, 800),
X
X/* weapons ... - ROCK come several at a time */
X/* weapons ... - (DART-1) are shot using idem+(BOW-ARROW) */
X/* weapons AXE, SWORD, KATANA, THSWORD are good for worm-cutting */
X/* weapons (PICK-)AXE, DAGGER, CRYSKNIFE are good for tin-opening */
X#define WEAPON(name,prob,wt,sdam,ldam)	{ name, NULL, NULL, 1, 0 /*%%*/,\
X		WEAPON_SYM, prob, 0, wt, sdam, ldam, 0 }
X
X/* Note: for weapons that don't do an even die of damage (i.e. 2-7 or 3-18)
X * the extra damage is added on in fight.c, not here! */
X
X	WEAPON("arrow",		6, 0, 6, 6),
X	WEAPON("sling bullet",	6, 0, 4, 6),
X	WEAPON("crossbow bolt",	6, 0, 4, 6),
X	WEAPON("dart",		6, 0, 3, 2),
X	WEAPON("shuriken",	3, 0, 8, 6),
X	WEAPON("rock",		4, 1, 3, 3),
X	WEAPON("boomerang",	1, 3, 9, 9),
X	WEAPON("mace",		6, 3, 6, 7), /* +1 small */
X	WEAPON("axe",		5, 3, 6, 4),
X	WEAPON("flail",		5, 3, 6, 5), /* +1 small, +1d4 large */
X	WEAPON("long sword",	5, 3, 8, 12),
X	WEAPON("two-handed sword",	4, 4, 12, 6), /* +2d6 large */
X	WEAPON("dagger",	4, 3, 4, 3),
X	WEAPON("worm tooth",	0, 4, 2, 2),
X	WEAPON("crysknife",	0, 3, 10, 10),
X	WEAPON("aklys",		1, 3, 6, 3), 
X	WEAPON("bardiche",	1, 3, 4, 4), /* +1d4 small, +2d4 large */
X	WEAPON("bec de corbin",	1, 3, 8, 6),
X	WEAPON("bill-guisarme",	1, 3, 4, 10), /* +1d4 small */
X	WEAPON("club",		1, 3, 6, 3),
X	WEAPON("fauchard",	1, 3, 6, 8),
X	WEAPON("glaive",	1, 3, 6, 10),
X	WEAPON("guisarme",	1, 3, 4, 8), /* +1d4 small */
X	WEAPON("halberd",	1, 3, 10, 6), /* +1d6 large */
X	WEAPON("lucern hammer",	1, 3, 4, 6), /* +1d4 small */
X	WEAPON("javelin",	1, 3, 6, 6),
X	WEAPON("katana",	1, 3, 12, 12),
X	WEAPON("lance",		1, 3, 6, 8),
X	WEAPON("morning star",	1, 3, 4, 6), /* +d4 small, +1 large */
X	WEAPON("partisan",	1, 3, 6, 6), /* +1 large */
X	WEAPON("ranseur",	1, 3, 4, 4), /* +d4 both */
X	WEAPON("scimitar",	1, 3, 8, 8), 
X	WEAPON("spetum",	1, 3, 6, 6), /* +1 small, +d6 large */
X	WEAPON("broad sword",	1, 3, 4, 6), /* +d4 small, +1 large */
X	WEAPON("short sword",	1, 3, 6, 8),
X	WEAPON("trident",	1, 3, 6, 4), /* +1 small, +2d4 large */
X	WEAPON("voulge",	1, 3, 4, 4), /* +d4 both */
X	WEAPON("spear",		4, 3, 6, 8),
X	WEAPON("bow",		4, 3, 4, 6),
X	WEAPON("sling",		4, 3, 6, 6),
X	WEAPON("crossbow",	5, 3, 4, 6),
X
X#ifdef WALKIES
X	{ "whistle", "whistle", NULL, 0, 0, TOOL_SYM, 55, 0, 2, 0, 0, 0 },
X	{ "leash", NULL, NULL, 1, 0, TOOL_SYM, 20, 0, 20, 0, 0, 0 },
X#else
X	{ "whistle", "whistle", NULL, 0, 0, TOOL_SYM, 75, 0, 2, 0, 0, 0 },
X	{ "leash", NULL, NULL, 1, 0, TOOL_SYM, 0, 0, 20, 0, 0, 0 },
X#endif
X	{ "magic whistle", "whistle", NULL, 0, 0, TOOL_SYM, 9, 0, 2, 0, 0, 0 },
X#ifdef RPH
X	{ "blindfold", "blindfold", NULL, 0, 0, TOOL_SYM, 5, 0, 2, 0, 0, 0 },
X	{ "mirror", "mirror", NULL, 0, 0, TOOL_SYM, 5, 0, 3, 0, 0, 0},
X#else
X	{ "blindfold", "blindfold", NULL, 0, 0, TOOL_SYM, 10, 0, 2, 0, 0, 0 },
X	{ "mirror", "mirror", NULL, 0, 0, TOOL_SYM, 0, 0, 3, 0, 0, 0},
X#endif
X	{ "expensive camera", NULL, NULL, 1, 1, TOOL_SYM, 1, 0, 3, 0, 0, 0 },
X	{ "ice box", "large box", NULL, 0, 0, TOOL_SYM, 1, 0, 40, 0, 0, 0 },
X	{ "pick-axe", NULL, NULL, 1, 1, TOOL_SYM, 1, 0, 5, 6, 3, 0 },
X	{ "magic marker", NULL, NULL, 1, 0, TOOL_SYM, 1, 0, 1, 0, 0, 0 },
X	{ "stethoscope", NULL, NULL, 1, 0, TOOL_SYM, 1, 0, 3, 0, 0, 0 },
X	{ "can opener", NULL, NULL, 1, 1, TOOL_SYM, 1, 0, 1, 0, 0, 0 },
X
X	{ "heavy iron ball", NULL, NULL, 1, 0,
X		BALL_SYM, 100, 0, 20, 0, 0, 0 },
X	{ "iron chain", NULL, NULL, 1, 0,
X		CHAIN_SYM, 100, 0, 20, 0, 0, 0 },
X	/* Because giants can throw rocks */
X#ifdef HARD
X# ifdef KAA
X	{ "enormous rock", NULL, NULL, 1, 0,
X		ROCK_SYM, 100, 0, 200 /* > MAX_CARR_CAP */, 0, 20, 20 },
X# else
X	{ "enormous rock", NULL, NULL, 1, 0,
X		ROCK_SYM, 100, 0, 250 /* > MAX_CARR_CAP */, 0, 0, 0 },
X# endif
X#else
X# ifdef KAA
X	{ "enormous rock", NULL, NULL, 1, 0,
X		ROCK_SYM, 100, 0, 400 /* > MAX_CARR_CAP */, 0, 20, 20 },
X# else
X	{ "enormous rock", NULL, NULL, 1, 0,
X		ROCK_SYM, 100, 0, 550 /* > MAX_CARR_CAP */, 0, 0, 0 },
X# endif
X#endif
X
X#define ARMOR(name,prob,delay,weight,ac,can)	{ name, NULL, NULL, 1, 0,\
X		ARMOR_SYM, prob, delay, weight, ac, can, 0 }
X/* Originally, weight was always 8, which is ridiculous.  (Plate mail weighs
X   the same as a pair of gloves?) */
X	ARMOR("helmet",			 3, 1, 2, 9, 0),
X	ARMOR("plate mail",		 5, 5, 9, 3, 2),
X	ARMOR("splint mail",		 7, 5, 8, 4, 1),
X	ARMOR("banded mail",		 9, 5, 8, 4, 0),
X	ARMOR("chain mail",		10, 5, 6, 5, 1),
X	ARMOR("scale mail",		10, 5, 5, 6, 0),
X	ARMOR("ring mail",		12, 5, 3, 7, 0),
X	/* the armors below do not rust */
X	ARMOR("studded leather armor",	12, 3, 3, 7, 1),
X	ARMOR("elfin chain mail",	 1, 1, 2, 5, 3),
X	ARMOR("bronze plate mail",	 6, 5, 9, 4, 0),
X	ARMOR("crystal plate mail",	 1, 5, 9, 3, 2),
X	ARMOR("leather armor",		15, 3, 2, 8, 0),
X	ARMOR("elven cloak",		 5, 0, 2, 9, 3),
X	ARMOR("shield",			 3, 0, 2, 9, 0),
X	ARMOR("pair of gloves",		 1, 1, 2, 9, 0),
X
X#define POTION(name,color)	{ name, color, NULL, 0, 1,\
X		POTION_SYM, 0, 0, 2, 0, 0, 0 }
X
X	POTION("restore strength",	"orange"),
X	POTION("gain energy", "cyan"),
X	POTION("booze",		"bubbly"),
X	POTION("invisibility",	"glowing"),
X	POTION("fruit juice",	"smoky"),
X	POTION("healing",	"pink"),
X	POTION("paralysis",	"puce"),
X	POTION("monster detection",	"purple"),
X	POTION("object detection",	"yellow"),
X	POTION("sickness",	"white"),
X	POTION("confusion",	"swirly"),
X	POTION("gain strength",	"purple-red"),
X	POTION("speed",		"ruby"),
X	POTION("blindness",	"dark green"),
X	POTION("gain level",	"emerald"),
X	POTION("extra healing",	"sky blue"),
X	POTION("levitation",	"brown"),
X	POTION("hallucination",	"brilliant blue"),
X	POTION("holy water",	"clear"),
X	POTION(NULL,	"magenta"),
X	POTION(NULL,	"ebony"),
X
X#define SCROLL(name,text,prob) { name, text, NULL, 0, 1,\
X		SCROLL_SYM, prob, 0, 3, 0, 0, 0 }
X	SCROLL("mail",	"KIRJE", 0),
X	SCROLL("enchant armor", "ZELGO MER", 6),
X	SCROLL("destroy armor", "JUYED AWK YACC", 5),
X	SCROLL("confuse monster", "NR 9", 5),
X	SCROLL("scare monster", "XIXAXA XOXAXA XUXAXA", 4),
X	SCROLL("blank paper", "READ ME", 3),
X	SCROLL("remove curse", "PRATYAVAYAH", 6),
X	SCROLL("enchant weapon", "DAIYEN FOOELS", 6),
X	SCROLL("damage weapon", "HACKEM MUCHE", 5),
X	SCROLL("create monster", "LEP GEX VEN ZEA", 5),
X	SCROLL("taming", "PRIRUTSENIE", 1),
X	SCROLL("genocide", "ELBIB YLOH",2),
X	SCROLL("light", "VERR YED HORRE", 10),
X	SCROLL("teleportation", "VENZAR BORGAVVE", 5),
X	SCROLL("gold detection", "THARR", 4),
X	SCROLL("food detection", "YUM YUM", 1),
X	SCROLL("identify", "KERNOD WEL", 18),
X	SCROLL("magic mapping", "ELAM EBOW", 5),
X	SCROLL("amnesia", "DUAM XNAHT", 3),
X	SCROLL("fire", "ANDOVA BEGARIN", 5),
X	SCROLL("punishment", "VE FORBRYDERNE", 1),
X	SCROLL(NULL, "VELOX NEB", 0),
X	SCROLL(NULL, "FOOBIE BLETCH", 0),
X	SCROLL(NULL, "TEMOV", 0),
X	SCROLL(NULL, "GARVEN DEH", 0),
X
X#define	WAND(name,metal,prob,flags)	{ name, metal, NULL, 0, 0,\
X		WAND_SYM, prob, 0, 3, flags, 0, 0 }
X
X	WAND("light",	"iridium",		10,	NODIR),
X	WAND("secret door detection",	"tin",	5,	NODIR),
X	WAND("create monster",	"platinum",	5,	NODIR),
X	WAND("wishing",		"glass",	1,	NODIR),
X#ifdef KAA
X	WAND("striking",	"zinc",		7,	IMMEDIATE),
X	WAND("nothing",		"uranium",	2,	IMMEDIATE),
X#else
X	WAND("striking",	"zinc",		9,	IMMEDIATE),
X	WAND("nothing",		"uranium",	0,	IMMEDIATE),
X#endif 
X	WAND("slow monster",	"balsa",	5,	IMMEDIATE),
X	WAND("speed monster",	"copper",	5,	IMMEDIATE),
X	WAND("undead turning",	"silver",	5,	IMMEDIATE),
X	WAND("polymorph",	"brass",	5,	IMMEDIATE),
X	WAND("cancellation",	"maple",	5,	IMMEDIATE),
X	WAND("teleportation",	"pine",		5,	IMMEDIATE),
X#ifdef PROBING
X	WAND("make invisible",	"marble",	7,	IMMEDIATE),
X	WAND("probing",		"oak",		2,	IMMEDIATE),
X#else
X	WAND("make invisible",	"marble",	9,	IMMEDIATE),
X	WAND("probing",		"oak",		0,	IMMEDIATE),
X#endif
X	WAND("digging",		"iron",		5,	RAY),
X	WAND("magic missile",	"aluminum",	10,	RAY),
X	WAND("fire",		"steel",	5,	RAY),
X	WAND("sleep",		"curved",	5,	RAY),
X	WAND("cold",		"short",	5,	RAY),
X	WAND("death",		"long",		1,	RAY),
X	WAND(NULL,		"ebony",	0,	0),
X	WAND(NULL,		"runed",	0,	0),
X
X#ifdef SPELLS
X/* books */
X#define SPELL(name,desc,prob,delay,flags,level)	{ name, desc, NULL, 0, 0, SPBOOK_SYM, prob, delay, 5, flags, 0, level }
X	SPELL("magic missile", "parchment", 4, 3, RAY, 2),
X	SPELL("fireball", "shining", 2, 6, RAY, 4),
X	SPELL("sleep", "glowing", 6, 1, RAY, 1),
X	SPELL("cone of cold", "mottled", 1, 8, RAY, 5),
X	SPELL("finger of death", "ragged", 1, 10, RAY, 7),
X
X	SPELL("healing", "yellow", 6, 2, NODIR, 1),
X	SPELL("detect monsters", "light green", 5, 1, NODIR, 1),
X	SPELL("force bolt", "dark blue", 4, 2, IMMEDIATE, 1),
X	SPELL("light", "copper", 5, 1, NODIR, 1),
X	SPELL("confuse monster", "white", 5, 2, IMMEDIATE, 2),
X	SPELL("cure blindness", "red", 3, 2, IMMEDIATE, 2),
X	SPELL("slow monster", "dark brown", 4, 2, IMMEDIATE, 2),
X	SPELL("create monster", "light brown", 4, 3, NODIR, 2),
X	SPELL("detect food", "pink", 5, 3, NODIR, 2),
X	SPELL("haste self", "light blue", 3, 4, NODIR, 3),
X	SPELL("cause fear", "black", 4, 3, NODIR, 3),
X	SPELL("cure sickness", "rusty", 3, 3, NODIR, 3),
X	SPELL("detect unseen", "dark green", 4, 4, NODIR, 3),
X	SPELL("extra healing", "magenta", 3, 5, NODIR, 3),
X	SPELL("charm monster", "silver", 3, 3, IMMEDIATE, 3),
X	SPELL("levitation", "indigo", 3, 4, NODIR, 4),
X	SPELL("restore strength", "plaid", 2, 5, NODIR, 4),
X	SPELL("invisibility", "orange", 3, 5, NODIR, 4),
X	SPELL("detect treasure", "bronze", 3, 5, NODIR, 4),
X	SPELL("dig", "cloth", 2, 6, RAY, 5),
X	SPELL("remove curse", "grey", 2, 5, NODIR, 5),
X	SPELL("magic mapping", "purple", 2, 7, NODIR, 5),
X	SPELL("identify", "violet", 1, 8, NODIR, 5),
X	SPELL("turn undead", "turquoise", 1, 8, IMMEDIATE, 6),
X	SPELL("polymorph", "cyan", 1, 8, IMMEDIATE, 6),
X	SPELL("create familiar", "tan", 1, 7, NODIR, 6),
X	SPELL("teleport away", "paper", 2, 6, IMMEDIATE, 6),
X	SPELL("cancellation", "leather", 1, 8, IMMEDIATE, 7),
X	SPELL("genocide", "gold", 1, 10, NODIR, 7),
X/* randomization */
X	SPELL(NULL, "dog eared", 0, 0, 0, 0),
X	SPELL(NULL, "thick", 0, 0, 0, 0),
X	SPELL(NULL, "thin", 0, 0, 0, 0),
X	SPELL(NULL, "stained", 0, 0, 0, 0),
X#endif /* SPELLS /**/
X
X#define	RING(name,stone,spec)	{ name, stone, NULL, 0, 0,\
X		RING_SYM, 0, 0, 1, spec, 0, 0 }
X
X	RING("adornment",	"engagement",	0),
X	RING("teleportation",	"wooden",	0),
X	RING("regeneration",	"black onyx",	0),
X	RING("searching",	"topaz",	0),
X	RING("see invisible",	"pearl",	0),
X	RING("stealth",		"sapphire",	0),
X	RING("levitation",	"moonstone",	0),
X	RING("poison resistance", "agate",	0),
X	RING("aggravate monster", "tiger eye",	0),
X	RING("hunger",		"shining",	0),
X	RING("fire resistance",	"gold",		0),
X	RING("cold resistance",	"copper",	0),
X	RING("protection from shape changers", "diamond", 0),
X	RING("conflict",	"jade",		0),
X	RING("gain strength",	"ruby",		SPEC),
X	RING("increase damage",	"silver",	SPEC),
X	RING("protection",	"granite",	SPEC),
X	RING("warning",		"wire",		0),
X	RING("teleport control", "iron",	0),
X	RING("polymorph",	"ivory",	0),
X	RING("polymorph control","blackened",	0),
X	RING(NULL,		"hematite",	0),
X	RING(NULL,		"brass",	0),
X
X/* gems ************************************************************/
X#define	GEM(name,color,prob,gval)	{ name, color, NULL, 0, 1,\
X		GEM_SYM, prob, 0, 1, 0, 0, gval }
X	GEM("dilithium crystal", "lavender", 1, 4500),
X	GEM("diamond", "blue", 1, 4000),
X	GEM("ruby", "red", 1, 3500),
X	GEM("sapphire", "blue", 1, 3000),
X	GEM("emerald", "green", 1, 2500),
X	GEM("turquoise", "green", 1, 2000),
X	GEM("aquamarine", "blue", 1, 1500),
X	GEM("tourmaline", "green", 1, 1000),
X	GEM("topaz", "yellow", 1, 900),
X	GEM("opal", "yellow", 1, 800),
X	GEM("garnet", "dark", 1, 700),
X	GEM("amethyst", "violet", 1, 650),
X	GEM("agate", "green", 2, 600),
X	GEM("onyx", "white", 2, 550),
X	GEM("jasper", "yellowish brown", 2, 500),
X	GEM("jade", "green", 2, 450),
X	GEM("worthless piece of blue glass", "blue", 20, 0),
X	GEM("worthless piece of red glass", "red", 20, 0),
X	GEM("worthless piece of yellow glass", "yellow", 20, 0),
X	GEM("worthless piece of green glass", "green", 20, 0),
X	{ NULL, NULL, NULL, 0, 0, ILLOBJ_SYM, 0, 0, 0, 0, 0, 0 }
X};
X
Xchar obj_symbols[] = {
X	ILLOBJ_SYM, AMULET_SYM, FOOD_SYM, WEAPON_SYM, TOOL_SYM,
X	BALL_SYM, CHAIN_SYM, ROCK_SYM, ARMOR_SYM,
X	POTION_SYM, SCROLL_SYM, WAND_SYM,
X#ifdef SPELLS
X	SPBOOK_SYM,
X#endif
X	RING_SYM, GEM_SYM, 0 };
Xint bases[sizeof(obj_symbols)];
END_OF_objects.h
if test 15739 -ne `wc -c <objects.h`; then
    echo shar: \"objects.h\" unpacked with wrong size!
fi
# end of overwriting check
fi
echo shar: End of archive 9 \(of 20\).
cp /dev/null ark9isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 20 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
