Path: utzoo!utgpu!jarvis.csri.toronto.edu!rutgers!cs.utexas.edu!uunet!zephyr.ens.tek.com!tekgen!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v07i098:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Patch1e
Message-ID: <4392@tekred.CNA.TEK.COM>
Date: 3 Aug 89 16:59:44 GMT
Sender: nobody@tekred.CNA.TEK.COM
Lines: 2202
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 7, Issue 98
Archive-name: NetHack3/Patch1e
Patch-To: NetHack3: Volume 7, Issue 56-93



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 5 (of 6)."
# Contents:  src3.diff
# Wrapped by billr@saab on Thu Aug  3 09:57:35 1989
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'src3.diff' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src3.diff'\"
else
echo shar: Extracting \"'src3.diff'\" \(55712 characters\)
sed "s/^X//" >'src3.diff' <<'END_OF_FILE'
XSource patches, part 3
X
X-----------------------------------Cut---------------------------------
X*** src/Old/objnam.c	Mon Jul 31 14:24:55 1989
X--- src/objnam.c	Sun Jul 30 11:30:32 1989
X***************
X*** 3,8 ****
X--- 3,9 ----
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X  #include	"hack.h"
X+ #include <ctype.h>	/* for isalpha() */
X  
X  #define	PREFIX	30
X  
X***************
X*** 157,163 ****
X  
X  	long save_Blinded = Blinded;
X  	Blinded = 1;
X! 	str = func(obj);
X  	Blinded = save_Blinded;
X  	return str;
X  }
X--- 158,164 ----
X  
X  	long save_Blinded = Blinded;
X  	Blinded = 1;
X! 	str = (*func)(obj);
X  	Blinded = save_Blinded;
X  	return str;
X  }
X***************
X*** 237,242 ****
X--- 238,244 ----
X  		} else	Strcat(buf, dn);
X  		break;
X  	    case FOOD_SYM:
X+ #ifdef TUTTI_FRUTTI
X  		if (obj->otyp == SLIME_MOLD) {
X  			register struct fruit *f;
X  
X***************
X*** 249,254 ****
X--- 251,257 ----
X  			if (!f) impossible("Bad fruit #%d?", obj->spe);
X  			break;
X  		}
X+ #endif
X  		Strcpy(buf, an);
X  		if(obj->otyp == TIN && obj->known) {
X  		    if(obj->spe > 0)
X***************
X*** 519,525 ****
X  			break;
X  	}
X  
X! 	if(obj->owornmask & W_WEP) {
X  		Strcat(bp, " (weapon in ");
X  		Strcat(bp, body_part(HAND));
X  		Strcat(bp, ")");
X--- 522,528 ----
X  			break;
X  	}
X  
X! 	if((obj->owornmask & W_WEP) && !mrg_to_wielded) {
X  		Strcat(bp, " (weapon in ");
X  		Strcat(bp, body_part(HAND));
X  		Strcat(bp, ")");
X***************
X*** 631,649 ****
X  
X  	/* Search for common compounds, i.e. lump of royal jelly */
X  	for(excess=0, spot=str; *spot; spot++) {
X! 		if (!strncmp(spot, " of ", 4) || !strncmp(spot, " with ", 6)
X! 				|| !strncmp(spot, " a la ", 6)
X! 				|| !strncmp(spot, " from ", 6)
X! 				|| !strncmp(spot, " in ", 4)
X  				|| !strncmp(spot, " labeled ", 9)
X  				|| !strncmp(spot, " called ", 8)
X  				|| !strncmp(spot, " named ", 7)
X- 				|| !strncmp(spot, " on ", 4)
X  				|| !strcmp(spot, " above") /* lurkers above */
X  				|| !strncmp(spot, " versus ", 8)
X  				|| !strncmp(spot, " de ", 4)
X  				|| !strncmp(spot, " d'", 3)
X! 				|| !strncmp(spot, " du ", 4)) {
X  			excess = oldstr + (spot - str);
X  			*spot = 0;
X  			break;
X--- 634,656 ----
X  
X  	/* Search for common compounds, i.e. lump of royal jelly */
X  	for(excess=0, spot=str; *spot; spot++) {
X! 		if (!strncmp(spot, " of ", 4)
X  				|| !strncmp(spot, " labeled ", 9)
X  				|| !strncmp(spot, " called ", 8)
X  				|| !strncmp(spot, " named ", 7)
X  				|| !strcmp(spot, " above") /* lurkers above */
X  				|| !strncmp(spot, " versus ", 8)
X+ #ifdef TUTTI_FRUTTI
X+ 				|| !strncmp(spot, " from ", 6)
X+ 				|| !strncmp(spot, " in ", 4)
X+ 				|| !strncmp(spot, " on ", 4)
X+ 				|| !strncmp(spot, " a la ", 6)
X+ 				|| !strncmp(spot, " with", 5)
X  				|| !strncmp(spot, " de ", 4)
X  				|| !strncmp(spot, " d'", 3)
X! 				|| !strncmp(spot, " du ", 4)
X! #endif
X! 				) {
X  			excess = oldstr + (spot - str);
X  			*spot = 0;
X  			break;
X***************
X*** 654,665 ****
X  	*(spot+1) = 0;
X  	/* Now spot is the last character of the string */
X  
X- 	/* Single letters */
X  	len = strlen(str);
X! 	if (len==1) {
X  		Strcpy(spot+1, "'s");
X  		goto bottom;
X  	}
X  
X  	/* man/men ("Wiped out all cavemen.") */
X  	if (len >= 3 && !strcmp(spot-2, "man") &&
X--- 661,674 ----
X  	*(spot+1) = 0;
X  	/* Now spot is the last character of the string */
X  
X  	len = strlen(str);
X! #ifdef TUTTI_FRUTTI
X! 	/* Single letters */
X! 	if (len==1 || !isalpha(*spot)) {
X  		Strcpy(spot+1, "'s");
X  		goto bottom;
X  	}
X+ #endif
X  
X  	/* man/men ("Wiped out all cavemen.") */
X  	if (len >= 3 && !strcmp(spot-2, "man") &&
X***************
X*** 669,692 ****
X  		goto bottom;
X  	}
X  
X- 	/* mouse/mice,louse/lice (not a monster, but possible in a food name) */
X- 	if (len >= 5 && !strcmp(spot-3, "ouse") && index("MmLl", *(spot-4))) {
X- 		Strcpy(spot-3, "ice");
X- 		goto bottom;
X- 	}
X- 
X- 	/* matzoh/matzot, possible food name */
X- 	if (len >= 6 && !strcmp(spot-5, "matzoh")) {
X- 		*(spot) = 't';
X- 		goto bottom;
X- 	}
X- 
X- 	/* child/children (for the wise guys who give their food funny names) */
X- 	if (len >= 5 && !strcmp(spot-4, "child")) {
X- 		Strcpy(spot, "dren");
X- 		goto bottom;
X- 	}
X- 
X  	/* tooth/teeth */
X  	if (len >= 5 && !strcmp(spot-4, "tooth")) {
X  		Strcpy(spot-3, "eeth");
X--- 678,683 ----
X***************
X*** 716,724 ****
X--- 707,719 ----
X  	}
X  
X  	/* algae, larvae, hyphae (another fungus part) */
X+ #ifdef TUTTI_FRUTTI
X  	if ((len >= 4 && !strcmp(spot-3, "alga")) ||
X  	    (len >= 5 &&
X  	     (!strcmp(spot-4, "hypha") || !strcmp(spot-4, "larva")))) {
X+ #else
X+ 	if (len >= 5 && (!strcmp(spot-4, "hypha"))) {
X+ #endif
X  		Strcpy(spot, "ae");
X  		goto bottom;
X  	}
X***************
X*** 746,761 ****
X  	/* note: also swine, trout, grouse */
X  	if ((len >= 7 && !strcmp(spot-6, "samurai")) ||
X  	    (len >= 5 &&
X  	     (!strcmp(spot-4, "manes") || !strcmp(spot-4, "sheep"))) ||
X  	    (len >= 4 &&
X  	     (!strcmp(spot-3, "fish") || !strcmp(spot-3, "tuna") ||
X  	      !strcmp(spot-3, "deer"))))
X  		goto bottom;
X  
X! 	/* Aren't the following two going a bit far?  --KAA */
X! 	/* eau/eaux (gateau) */
X! 	if (len >= 3 && !strcmp(spot-2, "eau")) {
X! 		Strcpy(spot, "ux");
X  		goto bottom;
X  	}
X  
X--- 741,772 ----
X  	/* note: also swine, trout, grouse */
X  	if ((len >= 7 && !strcmp(spot-6, "samurai")) ||
X  	    (len >= 5 &&
X+ #ifdef TUTTI_FRUTTI
X  	     (!strcmp(spot-4, "manes") || !strcmp(spot-4, "sheep"))) ||
X  	    (len >= 4 &&
X  	     (!strcmp(spot-3, "fish") || !strcmp(spot-3, "tuna") ||
X  	      !strcmp(spot-3, "deer"))))
X+ #else
X+ 	     !strcmp(spot-4, "manes")))
X+ #endif
X+ 		goto bottom;
X+ 
X+ #ifdef TUTTI_FRUTTI
X+ 	/* mouse/mice,louse/lice (not a monster, but possible in a food name) */
X+ 	if (len >= 5 && !strcmp(spot-3, "ouse") && index("MmLl", *(spot-4))) {
X+ 		Strcpy(spot-3, "ice");
X+ 		goto bottom;
X+ 	}
X+ 
X+ 	/* matzoh/matzot, possible food name */
X+ 	if (len >= 6 && !strcmp(spot-5, "matzoh")) {
X+ 		*(spot) = 't';
X  		goto bottom;
X+ 	}
X  
X! 	/* child/children (for the wise guys who give their food funny names) */
X! 	if (len >= 5 && !strcmp(spot-4, "child")) {
X! 		Strcpy(spot, "dren");
X  		goto bottom;
X  	}
X  
X***************
X*** 765,783 ****
X  		goto bottom;
X  	}
X  
X  	/* note: ox/oxen, VAX/VAXen, goose/geese */
X  
X  	/* Ends in z, x, s, ch, sh; add an "es" */
X! 	if (index("zxsv", *spot) || (*spot=='h' && index("cs", *(spot-1))) ||
X  	/* Kludge to get "tomatoes" and "potatoes" right */
X! 				(len >= 4 && !strcmp(spot-2, "ato"))) {
X  		Strcpy(spot+1, "es");
X  		goto bottom;
X  	}
X  
X! 	/* Ends in y preceded by consonant or "qu"; change to "ies" */
X  	if (*spot == 'y' &&
X! 	    (!index(vowels, *(spot-1)) || !strncmp("qu", spot-2, 2))) {
X  		Strcpy(spot, "ies");
X  		goto bottom;
X  	}
X--- 776,799 ----
X  		goto bottom;
X  	}
X  
X+ 	/* note: -eau/-eaux (gateau, bordeau...) */
X  	/* note: ox/oxen, VAX/VAXen, goose/geese */
X+ #endif
X  
X  	/* Ends in z, x, s, ch, sh; add an "es" */
X! 	if (index("zxsv", *spot) || (*spot=='h' && index("cs", *(spot-1)))
X! #ifdef TUTTI_FRUTTI
X  	/* Kludge to get "tomatoes" and "potatoes" right */
X! 				|| (len >= 4 && !strcmp(spot-2, "ato"))
X! #endif
X! 									) {
X  		Strcpy(spot+1, "es");
X  		goto bottom;
X  	}
X  
X! 	/* Ends in y preceded by consonant (note: also "qu"); change to "ies" */
X  	if (*spot == 'y' &&
X! 	    (!index(vowels, *(spot-1)))) {
X  		Strcpy(spot, "ies");
X  		goto bottom;
X  	}
X***************
X*** 808,817 ****
X  	register char *p;
X  	register int i;
X  	register struct obj *otmp;
X- 	struct fruit *f;
X  	int cnt, spe, spesgn, typ, heavy, blessed, uncursed;
X  	int iscursed, ispoisoned, mntmp, contents, iskey=0;
X! 	int  isnamedbox=0, ftype = current_fruit;
X  	char let;
X  	char *un, *dn, *an;
X  	char *name=0;
X--- 824,836 ----
X  	register char *p;
X  	register int i;
X  	register struct obj *otmp;
X  	int cnt, spe, spesgn, typ, heavy, blessed, uncursed;
X  	int iscursed, ispoisoned, mntmp, contents, iskey=0;
X! 	int  isnamedbox=0;
X! #ifdef TUTTI_FRUTTI
X! 	struct fruit *f;
X! 	int ftype = current_fruit;
X! #endif
X  	char let;
X  	char *un, *dn, *an;
X  	char *name=0;
X***************
X*** 946,951 ****
X--- 965,971 ----
X  	if(cnt == 1 && !strncmp(bp, "pair of ",8)) {
X  		bp += 8;
X  		cnt = 2;
X+ 		goto sing;
X  		/* cnt is ignored for armor and other non-stackable objects;
X  		   DTRT for stackable objects */
X  	} else if(cnt > 1 && !strncmp(bp, "pairs of ",9)) {
X***************
X*** 996,1001 ****
X--- 1016,1026 ----
X  					goto sing;
X  				}
X  
X+ 				if(!strcmp(p-6, "staves")) {
X+ 					Strcpy(p-3, "ff");
X+ 					goto sing;
X+ 				}
X+ 
X  				/* note: nurses, axes but boxes */
X  				if(!strcmp(p-5, "boxes")) {
X  					p[-2] = 0;
X***************
X*** 1194,1199 ****
X--- 1219,1225 ----
X  		}
X  		i++;
X  	}
X+ #ifdef TUTTI_FRUTTI
X  	for(f=ffruit; f; f = f->nextf) {
X  		char *f1 = f->fname, *f2 = makeplural(f->fname);
X  
X***************
X*** 1204,1209 ****
X--- 1230,1236 ----
X  			goto typfnd;
X  		}
X  	}
X+ #endif
X  	if(!let) return((struct obj *)0);
X  any:
X  	if(!let) let = wrpsym[rn2(sizeof(wrpsym))];
X***************
X*** 1273,1280 ****
X--- 1300,1309 ----
X  				otmp->spe = 1;
X  			}
X  			break;
X+ #ifdef TUTTI_FRUTTI
X  		case SLIME_MOLD: otmp->spe = ftype;
X  			/* Fall through */
X+ #endif
X  		case SKELETON_KEY: case KEY: case CHEST: case LARGE_BOX:
X  		case HEAVY_IRON_BALL: case IRON_CHAIN: case STATUE:
X  			/* otmp->spe already done in mksobj() */
X*** src/Old/options.c	Mon Jul 31 14:26:18 1989
X--- src/options.c	Fri Jul 28 17:53:32 1989
X***************
X*** 24,30 ****
X--- 24,32 ----
X  	flags.confirm = TRUE;
X  	flags.safe_dog = TRUE;
X  	flags.silent = 	flags.pickup = TRUE;
X+ #ifdef TUTTI_FRUTTI
X  	nmcpy(pl_fruit, objects[SLIME_MOLD].oc_name, PL_FSIZ);
X+ #endif
X  	flags.num_pad = FALSE;
X  #ifdef MSDOS
X  #ifdef DECRAINBOW
X***************
X*** 32,37 ****
X--- 34,42 ----
X  #endif
X  #ifdef DGK
X  	flags.IBMBIOS =
X+ #ifdef TOS
X+ 	TRUE;			/* BIOS might as well always be on for TOS */
X+ #endif
X  	flags.rawio = FALSE;
X  #endif
X  	read_config_file();
X***************
X*** 38,47 ****
X--- 43,54 ----
X  #endif /* MSDOS */
X  	if(opts = getenv("NETHACKOPTIONS"))
X  		parseoptions(opts,TRUE);
X+ #ifdef TUTTI_FRUTTI
X  	(void)fruitadd(pl_fruit);
X  	objects[SLIME_MOLD].oc_name = "\033";
X  	/* Put something untypable in there */
X  	/* We cannot just use NULL because that marks the end of objects */
X+ #endif
X  }
X  
X  static void
X***************
X*** 154,160 ****
X  	}
X  	
X  #ifndef MSDOS
X! 	if (!strncmp(opts, "standout", 4)) {
X  		flags.standout = !negated;
X  		return;
X  	}
X--- 161,167 ----
X  	}
X  	
X  #ifndef MSDOS
X! 	if (!strncmp(opts, "stan", 4)) {
X  		flags.standout = !negated;
X  		return;
X  	}
X***************
X*** 165,176 ****
X  	}
X  #endif
X  
X! 	if (!strncmp(opts, "ignintr", 3)) {
X  		flags.ignintr = !negated;
X  		return;
X  	}
X  
X! 	if (!strncmp(opts, "tombstone", 4)) {
X  		flags.notombstone = negated;
X  		return;
X  	}
X--- 172,183 ----
X  	}
X  #endif
X  
X! 	if (!strncmp(opts, "ign", 3)) {
X  		flags.ignintr = !negated;
X  		return;
X  	}
X  
X! 	if (!strncmp(opts, "tomb", 4)) {
X  		flags.notombstone = negated;
X  		return;
X  	}
X***************
X*** 182,188 ****
X  	}
X  #endif
X  
X! 	if (!strncmp(opts, "confirm", 4)) {
X  		flags.confirm = !negated;
X  		return;
X  	}
X--- 189,195 ----
X  	}
X  #endif
X  
X! 	if (!strncmp(opts, "conf", 4)) {
X  		flags.confirm = !negated;
X  		return;
X  	}
X***************
X*** 191,212 ****
X  		return;
X  	}
X  
X! 	if (!strncmp(opts, "silent", 4)) {
X  		flags.silent = !negated;
X  		return;
X  	}
X  
X! 	if (!strncmp(opts, "verbose", 4)) {
X  		flags.verbose = !negated;
X  		return;
X  	}
X  
X! 	if (!strncmp(opts, "pickup", 4)) {
X  		flags.pickup = !negated;
X  		return;
X  	}
X  
X! 	if (!strncmp(opts, "number_pad", 4)) {
X  		flags.num_pad = !negated;
X  		return;
X  	}
X--- 198,219 ----
X  		return;
X  	}
X  
X! 	if (!strncmp(opts, "sil", 3)) {
X  		flags.silent = !negated;
X  		return;
X  	}
X  
X! 	if (!strncmp(opts, "verb", 4)) {
X  		flags.verbose = !negated;
X  		return;
X  	}
X  
X! 	if (!strncmp(opts, "pick", 4)) {
X  		flags.pickup = !negated;
X  		return;
X  	}
X  
X! 	if (!strncmp(opts, "numb", 4)) {
X  		flags.num_pad = !negated;
X  		return;
X  	}
X***************
X*** 217,223 ****
X  		return;
X  	}
X  
X! 	if (!strncmp(opts, "rawio", 4)) {
X  		if (from_env)
X  			flags.rawio = !negated;
X  		else
X--- 224,230 ----
X  		return;
X  	}
X  
X! 	if (!strncmp(opts, "raw", 3)) {
X  		if (from_env)
X  			flags.rawio = !negated;
X  		else
X***************
X*** 241,247 ****
X  	/*
X  	 * the order to list the pack
X  	 */
X! 	if (!strncmp(opts, "packorder", 4)) {
X  		register char	*sp, *tmp;
X  		int tmpend;
X  
X--- 248,254 ----
X  	/*
X  	 * the order to list the pack
X  	 */
X! 	if (!strncmp(opts, "pack", 4)) {
X  		register char	*sp, *tmp;
X  		int tmpend;
X  
X***************
X*** 276,287 ****
X  		return;
X  	}
X  
X! 	if (!strncmp(opts, "rest_on_space", 4)) {
X  		flags.no_rest_on_space = negated;
X  		return;
X  	}
X  
X! 	if (!strncmp(opts, "fixinv", 3)) {
X  		flags.invlet_constant = !negated;
X  		if(!from_env && flags.invlet_constant) reassign ();
X  		return;
X--- 283,294 ----
X  		return;
X  	}
X  
X! 	if (!strncmp(opts, "rest", 4)) {
X  		flags.no_rest_on_space = negated;
X  		return;
X  	}
X  
X! 	if (!strncmp(opts, "fix", 3)) {
X  		flags.invlet_constant = !negated;
X  		if(!from_env && flags.invlet_constant) reassign ();
X  		return;
X***************
X*** 294,300 ****
X  			flags.female = negated;
X  		return;
X  	}
X! 	if (!strncmp(opts, "female", 3)) {
X  		if(!from_env && flags.female == negated)
X  			pline("That is not anatomically possible.");
X  		else
X--- 301,307 ----
X  			flags.female = negated;
X  		return;
X  	}
X! 	if (!strncmp(opts, "fem", 3)) {
X  		if(!from_env && flags.female == negated)
X  			pline("That is not anatomically possible.");
X  		else
X***************
X*** 319,325 ****
X  	}
X  
X  	/* graphics:string */
X! 	if (!strncmp(opts, "graphics", 4)) {
X  		if(!from_env) {
X  #ifdef MSDOS
X  		  pline("\"graphics\" settable only from %s.", configfile);
X--- 326,332 ----
X  	}
X  
X  	/* graphics:string */
X! 	if (!strncmp(opts, "gr", 2)) {
X  		if(!from_env) {
X  #ifdef MSDOS
X  		  pline("\"graphics\" settable only from %s.", configfile);
X***************
X*** 382,388 ****
X  	}
X  
X  	/* endgame:5t[op] 5a[round] o[wn] */
X! 	if (!strncmp(opts, "endgame", 3)) {
X  		op = index(opts,':');
X  		if(!op) goto bad;
X  		op++;
X--- 389,395 ----
X  	}
X  
X  	/* endgame:5t[op] 5a[round] o[wn] */
X! 	if (!strncmp(opts, "end", 3)) {
X  		op = index(opts,':');
X  		if(!op) goto bad;
X  		op++;
X***************
X*** 414,420 ****
X  		}
X  		return;
X  	}
X! 	if (!strncmp(opts, "dogname", 3)) {
X  		if(!from_env) {
X  #ifdef MSDOS
X  		  pline("\"dogname\" settable only from %s.", configfile);
X--- 421,427 ----
X  		}
X  		return;
X  	}
X! 	if (!strncmp(opts, "dog", 3)) {
X  		if(!from_env) {
X  #ifdef MSDOS
X  		  pline("\"dogname\" settable only from %s.", configfile);
X***************
X*** 428,434 ****
X  		nmcpy(dogname, ++op, 62);
X  		return;
X  	}
X! 	if (!strncmp(opts, "catname", 3)) {
X  		if(!from_env) {
X  #ifdef MSDOS
X  		  pline("\"catname\" settable only from %s.", configfile);
X--- 435,441 ----
X  		nmcpy(dogname, ++op, 62);
X  		return;
X  	}
X! 	if (!strncmp(opts, "cat", 3)) {
X  		if(!from_env) {
X  #ifdef MSDOS
X  		  pline("\"catname\" settable only from %s.", configfile);
X***************
X*** 442,448 ****
X  		nmcpy(catname, ++op, 62);
X  		return;
X  	}
X! 	if (!strncmp(opts, "fruit", 2)) {
X  		op = index(opts, ':');
X  		if (!op++) goto bad;
X  		if (!from_env) {
X--- 449,456 ----
X  		nmcpy(catname, ++op, 62);
X  		return;
X  	}
X! #ifdef TUTTI_FRUTTI
X! 	if (!strncmp(opts, "fr", 2)) {
X  		op = index(opts, ':');
X  		if (!op++) goto bad;
X  		if (!from_env) {
X***************
X*** 469,474 ****
X--- 477,483 ----
X  		 */
X  		return;
X  	}
X+ #endif
X  bad:
X  	if(!from_env) {
X  		if(!strncmp(opts, "h", 1) ||
X***************
X*** 534,540 ****
X--- 543,551 ----
X  	    if (flags.silent) Strcat(buf,"silent,");
X  	    if (flags.time) Strcat(buf,"time,");
X  	    if (flags.verbose) Strcat(buf,"verbose,");
X+ #ifdef TUTTI_FRUTTI
X  	    Sprintf(eos(buf), "fruit:%s,", pl_fruit);
X+ #endif
X  	    if(flags.end_top != 5 || flags.end_around != 4 || flags.end_own){
X  		Sprintf(eos(buf), "endgame: %u top scores/%u around me",
X  			flags.end_top, flags.end_around);
X***************
X*** 559,570 ****
X  	return 0;
X  }
X  
X- char	packorder[] =	{
X- 	AMULET_SYM, WEAPON_SYM, ARMOR_SYM, FOOD_SYM, SCROLL_SYM,
X- # ifdef SPELLS
X- 	SPBOOK_SYM,
X- # endif
X- 	WAND_SYM, RING_SYM, POTION_SYM, TOOL_SYM, GEM_SYM, BALL_SYM, ROCK_SYM };
X  #define Page_line(x)	if(page_line(x)) goto quit
X  
X  void
X--- 570,575 ----
X***************
X*** 611,619 ****
X  	Page_line("`dogname'   - the name of your (first) dog (e.g., dogname:Fang),");
X  
X  	Page_line("`packorder' - the inventory order of the items in your pack");
X! 	Sprintf(buf, "              (currently, packorder:%s ),", packorder);
X  	Page_line(buf);
X  	Page_line("`fruit'     - the name of a fruit you enjoy eating,");
X  
X  	Page_line("`endgame'   - the parts of the score list you wish to see,");
X  
X--- 616,626 ----
X  	Page_line("`dogname'   - the name of your (first) dog (e.g., dogname:Fang),");
X  
X  	Page_line("`packorder' - the inventory order of the items in your pack");
X! 	Sprintf(buf, "              (currently, packorder:%s ),", inv_order);
X  	Page_line(buf);
X+ #ifdef TUTTI_FRUTTI
X  	Page_line("`fruit'     - the name of a fruit you enjoy eating,");
X+ #endif
X  
X  	Page_line("`endgame'   - the parts of the score list you wish to see,");
X  
X***************
X*** 628,633 ****
X--- 635,641 ----
X  	return;
X  }
X  
X+ #ifdef TUTTI_FRUTTI
X  /* Returns the fid of the fruit type; if that type already exists, it
X   * returns the fid of that one; if it does not exist, it adds a new fruit
X   * type to the chain and returns the new one.
X***************
X*** 666,672 ****
X  		    (!strncmp(buf, "tin of ", 7) && name_to_mon(buf+7) > -1) ||
X  		    !strcmp(buf, "empty tin") ||
X  		    !strcmp(buf, "tin of spinach") ||
X! 		    (!strncmp(eos(buf)-6," corpse",6) && name_to_mon(buf) > -1))
X  			{
X  				Strcpy(buf, pl_fruit);
X  				Strcpy(pl_fruit, "candied ");
X--- 674,682 ----
X  		    (!strncmp(buf, "tin of ", 7) && name_to_mon(buf+7) > -1) ||
X  		    !strcmp(buf, "empty tin") ||
X  		    !strcmp(buf, "tin of spinach") ||
X! 		    ((!strncmp(eos(buf)-6," corpse",6) ||
X! 						!strncmp(eos(buf)-3, " egg",3))
X! 			&& name_to_mon(buf) > -1))
X  			{
X  				Strcpy(buf, pl_fruit);
X  				Strcpy(pl_fruit, "candied ");
X***************
X*** 693,695 ****
X--- 703,706 ----
X  	if (user_specified) current_fruit = highest_fruit_id;
X  	return f->fid;
X  }
X+ #endif
X*** src/Old/pager.c	Mon Jul 31 14:27:19 1989
X--- src/pager.c	Fri Jul 28 17:53:34 1989
X***************
X*** 10,16 ****
X  #define MONATTK_H
X  #include	 "hack.h"
X  
X! #ifndef TOS
X  #include <signal.h>
X  #endif
X  #if defined(BSD) || defined(ULTRIX)
X--- 10,16 ----
X  #define MONATTK_H
X  #include	 "hack.h"
X  
X! #ifndef NO_SIGNAL
X  #include <signal.h>
X  #endif
X  #if defined(BSD) || defined(ULTRIX)
X*** src/Old/pickup.c	Mon Jul 31 14:28:29 1989
X--- src/pickup.c	Sun Jul 30 11:30:32 1989
X***************
X*** 241,260 ****
X  				obj->quan = savequan;
X  				qq--;
X  				/* we can carry qq of them */
X! 				if(!qq) goto too_heavy;
X! 			You("can only carry %s of the %s lying here.",
X! 					(qq == 1) ? "one" : "some",
X! 					doname(obj));
X! 				{
X! 				register struct obj *obj3;
X  
X! 				obj3 = splitobj(obj, qq);
X! 				if(obj3->otyp == SCR_SCARE_MONSTER)
X! 					if(obj3->spe) obj->spe = 0;
X  				}
X- 				goto lift_some;
X  			}
X- 		too_heavy:
X  			pline("There %s %s here, but %s.",
X  				(obj->quan == 1) ? "is" : "are",
X  				doname(obj),
X--- 241,258 ----
X  				obj->quan = savequan;
X  				qq--;
X  				/* we can carry qq of them */
X! 				if(qq) {
X! 				    register struct obj *obj3;
X  
X! 				You("can only carry %s of the %s lying here.",
X! 					    (qq == 1) ? "one" : "some",
X! 					    doname(obj));
X! 				    obj3 = splitobj(obj, qq);
X! 				    if(obj3->otyp == SCR_SCARE_MONSTER)
X! 					    if(obj3->spe) obj->spe = 0;
X! 				    goto lift_some;
X  				}
X  			}
X  			pline("There %s %s here, but %s.",
X  				(obj->quan == 1) ? "is" : "are",
X  				doname(obj),
X***************
X*** 267,274 ****
X  	lift_some:
X  		if(inv_cnt() >= 52) {
X  		    Your("knapsack cannot accommodate any more items.");
X! 				if(obj->otyp == SCR_SCARE_MONSTER)
X! 					if(obj->spe) obj->spe = 0;
X  		    break;
X  		}
X  		freeobj(obj);
X--- 265,272 ----
X  	lift_some:
X  		if(inv_cnt() >= 52) {
X  		    Your("knapsack cannot accommodate any more items.");
X! 		    if(obj->otyp == SCR_SCARE_MONSTER)
X! 			    if(obj->spe) obj->spe = 0;
X  		    break;
X  		}
X  		freeobj(obj);
X***************
X*** 277,287 ****
X  		if(wt > -5) You("have a little trouble lifting");
X  		{ int pickquan = obj->quan;
X  		  int mergquan;
X! 		if(!Blind) obj->dknown = 1;
X! 		obj = addinv(obj);    /* might merge it with other objects */
X  		  mergquan = obj->quan;
X  		  obj->quan = pickquan; /* to fool prinv() */
X! 		prinv(obj);
X  		  obj->quan = mergquan;
X  		}
X  	    }
X--- 275,287 ----
X  		if(wt > -5) You("have a little trouble lifting");
X  		{ int pickquan = obj->quan;
X  		  int mergquan;
X! 		  if(!Blind) obj->dknown = 1;
X! 		  obj = addinv(obj);    /* might merge it with other objects */
X  		  mergquan = obj->quan;
X  		  obj->quan = pickquan; /* to fool prinv() */
X! 		  if(uwep && uwep == obj) mrg_to_wielded = TRUE;
X! 		  prinv(obj);
X! 		  if(mrg_to_wielded) mrg_to_wielded = FALSE;
X  		  obj->quan = mergquan;
X  		}
X  	    }
X*** src/Old/potion.c	Mon Jul 31 14:30:21 1989
X--- src/potion.c	Thu Jul 27 15:51:29 1989
X***************
X*** 349,356 ****
X--- 349,361 ----
X  			  Hallucination ? "overripe" : "rotten"
X  			 );
X  		else pline (Hallucination ?
X+ #ifdef TUTTI_FRUTTI
X  		   "This tastes like 10%% real %s juice all-natural beverage." :
X  		   "This tastes like %s juice.", pl_fruit);
X+ #else
X+ 		   "This tastes like 10%% real fruit juice all-natural beverage." :
X+ 		   "This tastes like fruit juice.");
X+ #endif
X  		if (otmp->otyp == POT_FRUIT_JUICE) {
X  			lesshungry(10 * (2 + bcsign(otmp)));
X  			break;
X***************
X*** 391,403 ****
X  	case POT_SICKNESS:
X  		pline("Yecch!  This stuff tastes like poison.");
X  		if (otmp->blessed) {
X! 			pline("(But in fact it was mildly stale %s juice.)",
X! 								pl_fruit);
X  			if (pl_character[0] != 'H')
X  				losehp(1, "mildly contaminated potion");
X  		} else {
X  		    if(Poison_resistance)
X      pline("(But in fact it was biologically contaminated %s juice.)",pl_fruit);
X  		    if (pl_character[0] == 'H')
X  			pline("Fortunately, you have been immunized.");
X  		    else {
X--- 396,415 ----
X  	case POT_SICKNESS:
X  		pline("Yecch!  This stuff tastes like poison.");
X  		if (otmp->blessed) {
X! #ifdef TUTTI_FRUTTI
X! 		pline("(But in fact it was mildly stale %s juice.)", pl_fruit);
X! #else
X! 		pline("(But in fact it was mildly stale orange juice.)");
X! #endif
X  			if (pl_character[0] != 'H')
X  				losehp(1, "mildly contaminated potion");
X  		} else {
X  		    if(Poison_resistance)
X+ #ifdef TUTTI_FRUTTI
X      pline("(But in fact it was biologically contaminated %s juice.)",pl_fruit);
X+ #else
X+     pline("(But in fact it was biologically contaminated orange juice.)");
X+ #endif
X  		    if (pl_character[0] == 'H')
X  			pline("Fortunately, you have been immunized.");
X  		    else {
X***************
X*** 1077,1081 ****
X--- 1089,1164 ----
X  		more();
X  		docrt();
X  	}
X+ 	return(0);
X+ }
X+ 
X+ /* the detections are pulled out so they can	*/
X+ /* also be used in the crystal ball routine	*/
X+ /* returns 1 if nothing was detected		*/
X+ /* returns 0 if something was detected		*/
X+ int
X+ trap_detect(sobj)
X+ register struct obj	*sobj;
X+ /* sobj is null if crystal ball, *scroll if gold detection scroll */
X+ {
X+ 	register struct trap *ttmp;
X+ 	register struct obj *obj;
X+ 	register int door;
X+ 	boolean found = FALSE;
X+ 	coord cc;
X+ 
X+ 	for(ttmp = ftrap; ttmp; ttmp = ttmp->ntrap) {
X+ 		if(ttmp->tx != u.ux || ttmp->ty != u.uy)
X+ 			goto outtrapmap;
X+ 		else found = TRUE;
X+ 	}
X+ 	for(obj = fobj; obj; obj = obj->nobj) {
X+ 		if ((obj->otyp==LARGE_BOX || obj->otyp==CHEST) && obj->otrapped)
X+ 			if (obj->ox != u.ux || obj->oy != u.uy)
X+ 				goto outtrapmap;
X+ 			else found = TRUE;
X+ 	}
X+ 	for(door=0; door<=doorindex; door++) {
X+ 		cc = doors[door];
X+ 		if (levl[cc.x][cc.y].doormask & D_TRAPPED)
X+ 			if (cc.x != u.ux || cc.x != u.uy)
X+ 				goto outtrapmap;
X+ 			else found = TRUE;
X+ 	}
X+ 	if(!found) {
X+ 		char buf[42];
X+ 		Sprintf(buf, "Your %s stop itching.",
X+ 			makeplural(body_part(TOE)));
X+ 		strange_feeling(sobj,buf);
X+ 		return(1);
X+ 	}
X+ 	/* traps exist, but only under me - no separate display required */
X+ 	Your("%s itch.", makeplural(body_part(TOE)));
X+ 	return(0);
X+ outtrapmap:
X+ 	cls();
X+ #define SYMBOL (uchar)(Hallucination ? rndobjsym() : \
X+ 		(sobj && sobj->cursed) ? GOLD_SYM : TRAP_SYM)
X+ #define AT Hallucination || (sobj && sobj->cursed) ? AT_OBJ : AT_MAP
X+ 	for(ttmp = ftrap; ttmp; ttmp = ttmp->ntrap)
X+ 		at(ttmp->tx, ttmp->ty, SYMBOL, AT);
X+ 	for(obj = fobj; obj; obj = obj->nobj) {
X+ 		if ((obj->otyp==LARGE_BOX || obj->otyp==CHEST) && obj->otrapped)
X+ 			at(obj->ox, obj->oy, SYMBOL, AT);
X+ 	}
X+ 	for(door=0; door<=doorindex; door++) {
X+ 		cc = doors[door];
X+ 		if (levl[cc.x][cc.y].doormask & D_TRAPPED)
X+ 			at(cc.x, cc.y, SYMBOL, AT);
X+ 	}
X+ #undef SYMBOL
X+ #undef AT
X+ 	prme();
X+ 	if (sobj && sobj->cursed)
X+ 		You("feel very greedy.");
X+ 	else
X+ 		You("feel entrapped.");
X+ 	more();
X+ 	docrt();
X  	return(0);
X  }
X*** src/Old/pray.c	Mon Jul 31 14:31:50 1989
X--- src/pray.c	Mon Jul 31 09:21:03 1989
X***************
X*** 43,48 ****
X--- 43,50 ----
X  #define TROUBLE_STARVING 4
X  #define TROUBLE_HIT 5
X  #define TROUBLE_STUCK_IN_WALL 6
X+ #define TROUBLE_LEVITATED_FOREVER 7
X+ #define TROUBLE_BLINDED_FOREVER 8
X  
X  #define TROUBLE_PUNISHED (-1)
X  #define TROUBLE_LYCANTHROPE (-2)
X***************
X*** 104,109 ****
X--- 106,117 ----
X  	    && !passes_walls(uasmon)
X  #endif
X  	    ) return(TROUBLE_STUCK_IN_WALL);
X+ 	if((uarmf && uarmf->otyp==LEVITATION_BOOTS && uarmf->cursed) ||
X+ 		(uleft && uleft->otyp==RIN_LEVITATION && uleft->cursed) ||
X+ 		(uright && uright->otyp==RIN_LEVITATION && uleft->cursed))
X+ 		return(TROUBLE_LEVITATED_FOREVER);
X+ 	if(ublindf && ublindf->cursed) return(TROUBLE_BLINDED_FOREVER);
X+ 
X  	if(Punished) return(TROUBLE_PUNISHED);
X  #ifdef POLYSELF
X  	if(u.ulycn >= 0) return(TROUBLE_LYCANTHROPE);
X***************
X*** 117,133 ****
X  	   (uarmg && uarmg->cursed) ||	/* gloves */
X  	   (uarm && uarm->cursed) ||	/* armor */
X  	   (uarmc && uarmc->cursed) ||	/* cloak */
X! 	   (uarmf && uarmf->cursed) ||	/* boots */
X  #ifdef SHIRT
X  	   (uarmu && uarmu->cursed) ||  /* shirt */
X  #endif
X! 	   (uwep && (uwep->olet == WEAPON_SYM || uwep->otyp==PICK_AXE
X! 		|| uwep->otyp==TIN_OPENER || uwep->otyp==HEAVY_IRON_BALL) &&
X! 		(uwep->cursed)) ||
X! 	   (uleft && uleft->cursed) ||
X! 	   (uright && uright->cursed) ||
X! 	   (uamul && uamul->cursed) ||
X! 	   (ublindf && ublindf->cursed))
X  
X  	   return(TROUBLE_CURSED_ITEMS);
X  
X--- 125,139 ----
X  	   (uarmg && uarmg->cursed) ||	/* gloves */
X  	   (uarm && uarm->cursed) ||	/* armor */
X  	   (uarmc && uarmc->cursed) ||	/* cloak */
X! 	   (uarmf && uarmf->cursed && uarmf->otyp != LEVITATION_BOOTS) ||
X! 					/* boots */
X  #ifdef SHIRT
X  	   (uarmu && uarmu->cursed) ||  /* shirt */
X  #endif
X! 	   (uwep && welded(uwep)) ||
X! 	   (uleft && uleft->cursed && uleft->otyp != RIN_LEVITATION) ||
X! 	   (uright && uright->cursed && uright->otyp != RIN_LEVITATION) ||
X! 	   (uamul && uamul->cursed))
X  
X  	   return(TROUBLE_CURSED_ITEMS);
X  
X***************
X*** 143,153 ****
X--- 149,165 ----
X  	return(0);
X  }
X  
X+ const char leftglow[] = "left ring softly glows";
X+ const char rightglow[] = "right ring softly glows";
X+ 
X  static void
X  fix_worst_trouble(trouble)
X  register int trouble;
X  {
X  	int i;
X+ 	struct obj *otmp = (struct obj *)0;
X+ 	char *what = NULL;
X+ 
X  	u.ublesscnt += rnz(100);
X  	switch (trouble) {
X  	    case TROUBLE_STONED:
X***************
X*** 182,187 ****
X--- 194,217 ----
X  		    Your("surroundings change.");
X  		    tele();
X  		    break;
X+ 	    case TROUBLE_LEVITATED_FOREVER:
X+ 		    if (uarmf && uarmf->otyp==LEVITATION_BOOTS
X+ 						&& uarmf->cursed)
X+ 			otmp = uarmf;
X+ 		    else if (uleft && uleft->otyp==RIN_LEVITATION
X+ 						&& uleft->cursed) {
X+ 			otmp = uleft;
X+ 			what = leftglow;
X+ 		    } else {
X+ 			otmp = uright;
X+ 			what = rightglow;
X+ 		    }
X+ 		    goto decurse;
X+ 		    break;
X+ 	    case TROUBLE_BLINDED_FOREVER:
X+ 		    otmp = ublindf;
X+ 		    goto decurse;
X+ 		    break;
X  	    case TROUBLE_PUNISHED:
X  		    Your("chain disappears.");
X  		    unpunish();
X***************
X*** 195,246 ****
X  		    break;
X  #endif
X  	    case TROUBLE_CURSED_ITEMS:
X! 		    {	struct obj *otmp;
X! 			char * what;
X! 			otmp = (struct obj *)0;
X! 			what = NULL;
X! 			if (uarmh && uarmh->cursed) 	/* helmet */
X  			    otmp = uarmh;
X! 			else if (uarms && uarms->cursed) /* shield */
X  			    otmp = uarms;
X! 			else if (uarmg && uarmg->cursed) /* gloves */
X  			    otmp = uarmg;
X! 			else if (uarm && uarm->cursed) /* armor */
X  			    otmp = uarm;
X! 			else if (uarmc && uarmc->cursed) /* cloak */
X  			    otmp = uarmc;
X! 			else if (uarmf && uarmf->cursed) /* boots */
X  			    otmp = uarmf;
X  #ifdef SHIRT
X! 			else if (uarmu && uarmu->cursed) /* shirt */
X  			    otmp = uarmu;
X  #endif
X! 			else if (uleft && uleft->cursed) {
X  			    otmp = uleft;
X! 			    what = "left ring softly glows";
X! 			} else if (uright && uright->cursed) {
X  			    otmp = uright;
X! 			    what = "right ring softly glows";
X! 			} else if (uamul && uamul->cursed) /* amulet */
X  			    otmp = uamul;
X! 			else if (ublindf && ublindf->cursed) /* blindfold */
X  			    otmp = ublindf;
X! 			else if (welded(uwep)) otmp = uwep;
X! 			else {
X  			    for(otmp=invent; otmp; otmp=otmp->nobj)
X  				if ((otmp->otyp==LOADSTONE ||
X  				     otmp->otyp==LUCKSTONE) && otmp->cursed)
X  					break;
X! 			}
X! 
X! 			otmp->cursed = 0;
X! 			otmp->bknown = 1;
X! 			if (!Blind)
X  			    Your("%s %s.",
X  				   what ? what : aobjnam (otmp, "softly glow"),
X  				   Hallucination ? hcolor() : amber);
X! 			break;
X! 		    }
X  	    case TROUBLE_HALLUCINATION:
X  		    pline ("Looks like you are back in Kansas.");
X  		    make_hallucinated(0L,FALSE);
X--- 225,271 ----
X  		    break;
X  #endif
X  	    case TROUBLE_CURSED_ITEMS:
X! 		    if (uarmh && uarmh->cursed) 	/* helmet */
X  			    otmp = uarmh;
X! 		    else if (uarms && uarms->cursed) /* shield */
X  			    otmp = uarms;
X! 		    else if (uarmg && uarmg->cursed) /* gloves */
X  			    otmp = uarmg;
X! 		    else if (uarm && uarm->cursed) /* armor */
X  			    otmp = uarm;
X! 		    else if (uarmc && uarmc->cursed) /* cloak */
X  			    otmp = uarmc;
X! 		    else if (uarmf && uarmf->cursed) /* boots */
X  			    otmp = uarmf;
X  #ifdef SHIRT
X! 		    else if (uarmu && uarmu->cursed) /* shirt */
X  			    otmp = uarmu;
X  #endif
X! 		    else if (uleft && uleft->cursed) {
X  			    otmp = uleft;
X! 			    what = leftglow;
X! 		    } else if (uright && uright->cursed) {
X  			    otmp = uright;
X! 			    what = rightglow;
X! 		    } else if (uamul && uamul->cursed) /* amulet */
X  			    otmp = uamul;
X! 		    else if (ublindf && ublindf->cursed) /* blindfold */
X  			    otmp = ublindf;
X! 		    else if (welded(uwep)) otmp = uwep;
X! 		    else {
X  			    for(otmp=invent; otmp; otmp=otmp->nobj)
X  				if ((otmp->otyp==LOADSTONE ||
X  				     otmp->otyp==LUCKSTONE) && otmp->cursed)
X  					break;
X! 		    }
X! decurse:
X! 		    otmp->cursed = 0;
X! 		    otmp->bknown = 1;
X! 		    if (!Blind)
X  			    Your("%s %s.",
X  				   what ? what : aobjnam (otmp, "softly glow"),
X  				   Hallucination ? hcolor() : amber);
X! 		    break;
X  	    case TROUBLE_HALLUCINATION:
X  		    pline ("Looks like you are back in Kansas.");
X  		    make_hallucinated(0L,FALSE);
X***************
X*** 713,721 ****
X  			register struct monst *dmon;
X  			const char *color = Hallucination ? hcolor() : black;
X      /* Human sacrifice on a chaotic altar is equivalent to demon summoning */
X      pline("The blood floods over the altar, which vanishes in a%s %s cloud!",
X! 				index(vowels, *color) ? "n" : "", color);
X! 			levl[u.ux][u.uy].typ = ROOM;
X  			if(Invisible) newsym(u.ux, u.uy);
X  			if(dmon = makemon(&mons[dlord()], u.ux, u.uy)) {
X  				You("have summoned a demon lord!");
X--- 738,755 ----
X  			register struct monst *dmon;
X  			const char *color = Hallucination ? hcolor() : black;
X      /* Human sacrifice on a chaotic altar is equivalent to demon summoning */
X+ #ifdef THEOLOGY
X+ 			if (levl[u.ux][u.uy].altarmask & A_SHRINE)
X+ 				pline("The blood covers the altar!");
X+ 			else {
X+ #endif
X      pline("The blood floods over the altar, which vanishes in a%s %s cloud!",
X! 				  index(vowels, *color) ? "n" : "", color);
X! 				levl[u.ux][u.uy].typ = ROOM;
X! #ifdef THEOLOGY
X! 			}
X! #endif
X! 			change_luck(2);
X  			if(Invisible) newsym(u.ux, u.uy);
X  			if(dmon = makemon(&mons[dlord()], u.ux, u.uy)) {
X  				You("have summoned a demon lord!");
X*** src/Old/pri.c	Mon Jul 31 14:33:30 1989
X--- src/pri.c	Mon Jul 31 09:37:35 1989
X***************
X*** 6,11 ****
X--- 6,14 ----
X  #define MONATTK_H
X  #include "hack.h"
X  #include <ctype.h>  /* for isalpha() */
X+ #if defined(ALTARS) && defined(THEOLOGY)
X+ #include "epri.h"
X+ #endif
X  
X  static void hilite P((uchar, uchar));
X  static void cornbot P((int));
X***************
X*** 147,153 ****
X  #ifdef POLYSELF
X  			&& !u.uundetected
X  #endif
X! 					) at(u.ux,u.uy,u.usym,AT_U);
X  }
X  
X  void
X--- 150,156 ----
X  #ifdef POLYSELF
X  			&& !u.uundetected
X  #endif
X! 					) atl(u.ux,u.uy,(char)u.usym);
X  }
X  
X  void
X***************
X*** 213,219 ****
X  /* Some ridiculous code to get display of @ and monsters (almost) right */
X  	if(!Invisible
X  #ifdef POLYSELF
X! 			|| u.uundetected
X  #endif
X  					) {
X  		levl[(u.udisx = u.ux)][(u.udisy = u.uy)].scrsym = u.usym;
X--- 216,222 ----
X  /* Some ridiculous code to get display of @ and monsters (almost) right */
X  	if(!Invisible
X  #ifdef POLYSELF
X! 			&& !u.uundetected
X  #endif
X  					) {
X  		levl[(u.udisx = u.ux)][(u.udisy = u.uy)].scrsym = u.usym;
X***************
X*** 233,243 ****
X  		for(y = 0; y < ROWNO; y++) {
X  			char buf[COLNO+1];
X  			int start, end;
X! #ifdef TOS
X  			setmem(buf, COLNO, ' ');
X  #else
X  			memset(buf, ' ', COLNO);
X! #endif /* TOS */
X  			for(x = 0, start = -1, end = -1; x < COLNO; x++)
X  				if((room = &levl[x][y])->new) {
X  					room->new = 0;
X--- 236,246 ----
X  		for(y = 0; y < ROWNO; y++) {
X  			char buf[COLNO+1];
X  			int start, end;
X! #ifdef OLD_TOS
X  			setmem(buf, COLNO, ' ');
X  #else
X  			memset(buf, ' ', COLNO);
X! #endif /* OLD_TOS */
X  			for(x = 0, start = -1, end = -1; x < COLNO; x++)
X  				if((room = &levl[x][y])->new) {
X  					room->new = 0;
X***************
X*** 971,979 ****
X  mstatusline(mtmp)
X  register struct monst *mtmp;
X  {
X  	pline("Status of %s (%s): ", mon_nam(mtmp),
X! 		(mtmp->data->maligntyp <= -1) ? "chaotic" :
X! 		mtmp->data->maligntyp ? "lawful" : "neutral");
X  	pline("Level %d  Gold %lu  HP %d(%d)",
X  	    mtmp->m_lev, mtmp->mgold, mtmp->mhp, mtmp->mhpmax);
X  	pline("AC %d%s%s", mtmp->data->ac,
X--- 974,989 ----
X  mstatusline(mtmp)
X  register struct monst *mtmp;
X  {
X+ #if defined(ALTARS) && defined(THEOLOGY)
X+ 	int align = mtmp->ispriest
X+ 		? ((EPRI(mtmp)->shralign & ~A_SHRINE)-1) :
X+ 		mtmp->data->maligntyp;
X+ #else
X+ 	int align = mtmp->data->maligntyp;
X+ #endif
X  	pline("Status of %s (%s): ", mon_nam(mtmp),
X! 		(align <= -1) ? "chaotic" :
X! 		align ? "lawful" : "neutral");
X  	pline("Level %d  Gold %lu  HP %d(%d)",
X  	    mtmp->m_lev, mtmp->mgold, mtmp->mhp, mtmp->mhpmax);
X  	pline("AC %d%s%s", mtmp->data->ac,
X*** src/Old/read.c	Mon Jul 31 14:35:59 1989
X--- src/read.c	Mon Jul 31 09:13:43 1989
X***************
X*** 339,345 ****
X  	    }
X  /*	    break;	/*NOTREACHED*/
X  	case SCR_ENCHANT_WEAPON:
X! 		if(uwep && (uwep->olet == WEAPON_SYM || uwep->olet == PICK_AXE)
X  							&& confused) {
X  		/* olet check added 10/25/86 GAN */
X  			if(Blind)
X--- 339,345 ----
X  	    }
X  /*	    break;	/*NOTREACHED*/
X  	case SCR_ENCHANT_WEAPON:
X! 		if(uwep && (uwep->olet == WEAPON_SYM || uwep->otyp == PICK_AXE)
X  							&& confused) {
X  		/* olet check added 10/25/86 GAN */
X  			if(Blind)
X***************
X*** 476,492 ****
X  		    case MAGIC_LAMP:
X  			if (sobj->cursed) stripspe(obj);
X  			else if (sobj->blessed) {
X! 			    if (obj->spe == 1) pline(nothing_happens);
X  			    else {
X  				obj->spe = 1;
X  				p_glow1(obj);
X  			    }
X  			} else {
X! 			    if (obj->spe == 1) pline(nothing_happens);
X  			    else {
X  				n = rn2(2);
X  				if (!n) {
X  				    obj->spe = 1;
X  				    p_glow1(obj);
X  				} else pline(nothing_happens);
X  			    }
X--- 476,496 ----
X  		    case MAGIC_LAMP:
X  			if (sobj->cursed) stripspe(obj);
X  			else if (sobj->blessed) {
X! 			    if (obj->spe == 1 || obj->recharged)
X! 				pline(nothing_happens);
X  			    else {
X  				obj->spe = 1;
X+ 				obj->recharged = 1;
X  				p_glow1(obj);
X  			    }
X  			} else {
X! 			    if (obj->spe == 1 || obj->recharged)
X! 				pline(nothing_happens);
X  			    else {
X  				n = rn2(2);
X  				if (!n) {
X  				    obj->spe = 1;
X+ 				    obj->recharged = 1;
X  				    p_glow1(obj);
X  				} else pline(nothing_happens);
X  			    }
X***************
X*** 1020,1096 ****
X  	} else 	return(0);		/* could not destroy anything */
X  
X  	return(1);
X- }
X- 
X- /* the detections are pulled out so they can	*/
X- /* also be used in the crystal ball routine	*/
X- /* returns 1 if nothing was detected		*/
X- /* returns 0 if something was detected		*/
X- int
X- trap_detect(sobj)
X- register struct obj	*sobj;
X- /* sobj is null if crystal ball, *scroll if gold detection scroll */
X- {
X- 	register struct trap *ttmp;
X- 	register struct obj *obj;
X- 	register int door;
X- 	boolean found = FALSE;
X- 	coord cc;
X- 
X- 	for(ttmp = ftrap; ttmp; ttmp = ttmp->ntrap) {
X- 		if(ttmp->tx != u.ux || ttmp->ty != u.uy)
X- 			goto outtrapmap;
X- 		else found = TRUE;
X- 	}
X- 	for(obj = fobj; obj; obj = obj->nobj) {
X- 		if ((obj->otyp==LARGE_BOX || obj->otyp==CHEST) && obj->otrapped)
X- 			if (obj->ox != u.ux || obj->oy != u.uy)
X- 				goto outtrapmap;
X- 			else found = TRUE;
X- 	}
X- 	for(door=0; door<=doorindex; door++) {
X- 		cc = doors[door];
X- 		if (levl[cc.x][cc.y].doormask & D_TRAPPED)
X- 			if (cc.x != u.ux || cc.x != u.uy)
X- 				goto outtrapmap;
X- 			else found = TRUE;
X- 	}
X- 	if(!found) {
X- 		char buf[42];
X- 		Sprintf(buf, "Your %s stop itching.",
X- 			makeplural(body_part(TOE)));
X- 		strange_feeling(sobj,buf);
X- 		return(1);
X- 	}
X- 	/* traps exist, but only under me - no separate display required */
X- 	Your("%s itch.", makeplural(body_part(TOE)));
X- 	return(0);
X- outtrapmap:
X- 	cls();
X- #define SYMBOL (uchar)(Hallucination ? rndobjsym() : \
X- 		(sobj && sobj->cursed) ? GOLD_SYM : TRAP_SYM)
X- #define AT Hallucination || (sobj && sobj->cursed) ? AT_OBJ : AT_MAP
X- 	for(ttmp = ftrap; ttmp; ttmp = ttmp->ntrap)
X- 		at(ttmp->tx, ttmp->ty, SYMBOL, AT);
X- 	for(obj = fobj; obj; obj = obj->nobj) {
X- 		if ((obj->otyp==LARGE_BOX || obj->otyp==CHEST) && obj->otrapped)
X- 			at(obj->ox, obj->oy, SYMBOL, AT);
X- 	}
X- 	for(door=0; door<=doorindex; door++) {
X- 		cc = doors[door];
X- 		if (levl[cc.x][cc.y].doormask & D_TRAPPED)
X- 			at(cc.x, cc.y, SYMBOL, AT);
X- 	}
X- #undef SYMBOL
X- #undef AT
X- 	prme();
X- 	if (sobj && sobj->cursed)
X- 		You("feel very greedy.");
X- 	else
X- 		You("feel entrapped.");
X- 	more();
X- 	docrt();
X- 	return(0);
X  }
X  
X  int
X--- 1024,1029 ----
X*** src/Old/restore.c	Mon Jul 31 14:37:16 1989
X--- src/restore.c	Fri Jul 28 17:54:07 1989
X***************
X*** 10,16 ****
X--- 10,18 ----
X  #endif
X  
X  boolean restoring = FALSE;
X+ #ifdef TUTTI_FRUTTI
X  static struct fruit *oldfruit;
X+ #endif
X  static long omoves;
X  
X  /*
X***************
X*** 44,50 ****
X--- 46,54 ----
X  {
X  	register struct obj *otmp, *otmp2;
X  	register struct obj *first = 0;
X+ #ifdef TUTTI_FRUTTI
X  	register struct fruit *oldf;
X+ #endif
X  	int xl;
X  #ifdef LINT
X  	/* suppress "used before set" warning from lint */
X***************
X*** 58,63 ****
X--- 62,68 ----
X  		else otmp2->nobj = otmp;
X  		mread(fd, (genericptr_t) otmp, (unsigned) xl + sizeof(struct obj));
X  		if(!otmp->o_id) otmp->o_id = flags.ident++;
X+ #ifdef TUTTI_FRUTTI
X  		if(ghostly && otmp->otyp == SLIME_MOLD) {
X  			for(oldf=oldfruit; oldf; oldf=oldf->nextf)
X  				if (oldf->fid == otmp->spe) break;
X***************
X*** 64,69 ****
X--- 69,75 ----
X  			if(!oldf) impossible("no old fruit?");
X  			else otmp->spe = fruitadd(oldf->fname);
X  		}
X+ #endif
X  	/* Ghost levels get object age shifted from old player's clock to
X  	 * new player's clock.  Assumption: new player arrived immediately
X  	 * after old player died.
X***************
X*** 158,164 ****
X--- 164,172 ----
X  	xchar ltmp;
X  	unsigned int mid;		/* idem */
X  	struct obj *otmp;
X+ #ifdef TUTTI_FRUTTI
X  	struct fruit *fruit;
X+ #endif
X  #ifdef MSDOS
X  	struct flag oldflags;
X  
X***************
X*** 227,232 ****
X--- 235,241 ----
X  	if(u.ustuck)
X  		mread(fd, (genericptr_t) &mid, sizeof mid);
X  	mread(fd, (genericptr_t) pl_character, sizeof pl_character);
X+ #ifdef TUTTI_FRUTTI
X  	mread(fd, (genericptr_t) pl_fruit, sizeof pl_fruit);
X  	mread(fd, (genericptr_t) &current_fruit, sizeof current_fruit);
X  	ffruit = 0;
X***************
X*** 237,242 ****
X--- 246,252 ----
X  		ffruit = fruit;
X  	}
X  	free((genericptr_t) fruit);
X+ #endif
X  
X  	restnames(fd);
X  #ifdef DGK
X***************
X*** 266,272 ****
X  		nfd = creat(lock, FCMASK);
X  #endif
X  		if (nfd < 0)	panic("Cannot open temp file %s!\n", lock);
X! #if defined(DGK) && !defined(TOS)
X  		if (!savelev(nfd, ltmp, COUNT | WRITE)) {
X  
X  			/* The savelev can't proceed because the size required
X--- 276,282 ----
X  		nfd = creat(lock, FCMASK);
X  #endif
X  		if (nfd < 0)	panic("Cannot open temp file %s!\n", lock);
X! #if defined(DGK) && !defined(OLD_TOS)
X  		if (!savelev(nfd, ltmp, COUNT | WRITE)) {
X  
X  			/* The savelev can't proceed because the size required
X***************
X*** 373,381 ****
X  	short tlev;
X  #endif
X  
X! #ifdef MSDOS
X! 	setmode(fd, O_BINARY);	    /* is this required for TOS??? */
X  #endif
X  	/* Load the old fruit info.  We have to do it first, so the infor-
X  	 * mation is available when restoring the objects.  
X  	 */
X--- 383,392 ----
X  	short tlev;
X  #endif
X  
X! #if defined(MSDOS) && !defined(TOS)
X! 	setmode(fd, O_BINARY);	    /* is this required for TOS??? NO --ERS */
X  #endif
X+ #ifdef TUTTI_FRUTTI
X  	/* Load the old fruit info.  We have to do it first, so the infor-
X  	 * mation is available when restoring the objects.  
X  	 */
X***************
X*** 391,406 ****
X  		}
X  		free((genericptr_t) fruit);
X  	}
X  
X  	/* First some sanity checks */
X  	mread(fd, (genericptr_t) &hpid, sizeof(hpid));
X  #ifdef TOS
X  	mread(fd, (genericptr_t) &tlev, sizeof(tlev));
X! 	dlvl=tlev&0xff;
X  #else
X  	mread(fd, (genericptr_t) &dlvl, sizeof(dlvl));
X  #endif
X  	if((pid && pid != hpid) || (lev && dlvl != lev)) {
X  		pline("Strange, this map is not as I remember it.");
X  		pline("Somebody is trying some trickery here...");
X  		pline("This game is void.");
X--- 402,426 ----
X  		}
X  		free((genericptr_t) fruit);
X  	}
X+ #endif
X  
X  	/* First some sanity checks */
X  	mread(fd, (genericptr_t) &hpid, sizeof(hpid));
X  #ifdef TOS
X  	mread(fd, (genericptr_t) &tlev, sizeof(tlev));
X! 	dlvl=tlev&0x00ff;
X  #else
X  	mread(fd, (genericptr_t) &dlvl, sizeof(dlvl));
X  #endif
X  	if((pid && pid != hpid) || (lev && dlvl != lev)) {
X+ #ifdef WIZARD
X+ 		if (wizard) {
X+ 			if (pid && pid != hpid)
X+ 				pline("PID (%d) doesn't match saved PID (%d)!", hpid, pid);
X+ 			else if (lev && dlvl != lev)
X+ 				pline("This is level %d, not %d!", dlvl, lev);
X+ 		}
X+ #endif
X  		pline("Strange, this map is not as I remember it.");
X  		pline("Somebody is trying some trickery here...");
X  		pline("This game is void.");
X***************
X*** 654,659 ****
X--- 674,680 ----
X  	}
X  	mread(fd, (genericptr_t)wgrowtime, sizeof(wgrowtime));
X  #endif
X+ #ifdef TUTTI_FRUTTI
X  	/* Now get rid of all the temp fruits... */
X  	if (ghostly) {
X  		struct fruit *fruit;
X***************
X*** 664,669 ****
X--- 685,691 ----
X  			oldfruit = fruit;
X  		}
X  	}
X+ #endif
X  }
X  
X  #ifdef ZEROCOMP
X*** src/Old/save.c	Mon Jul 31 14:39:09 1989
X--- src/save.c	Fri Jul 28 17:54:12 1989
X***************
X*** 11,19 ****
X  #include "wseg.h"
X  #endif
X  
X! #ifndef TOS
X  #include <signal.h>
X! #endif /* !TOS */
X  #ifdef EXPLORE_MODE
X  #include <fcntl.h>
X  #endif /* EXPLORE_MODE */
X--- 11,19 ----
X  #include "wseg.h"
X  #endif
X  
X! #ifndef NO_SIGNAL
X  #include <signal.h>
X! #endif /* !NO_SIGNAL */
X  #ifdef EXPLORE_MODE
X  #include <fcntl.h>
X  #endif /* EXPLORE_MODE */
X***************
X*** 20,26 ****
X  
X  boolean hu;		/* set during hang-up */
X  
X! #if defined(DGK) && !defined(TOS)
X  struct finfo fileinfo[MAXLEVEL+1];
X  long bytes_counted;
X  int count_only;
X--- 20,26 ----
X  
X  boolean hu;		/* set during hang-up */
X  
X! #if defined(DGK) && !defined(OLD_TOS)
X  struct finfo fileinfo[MAXLEVEL+1];
X  long bytes_counted;
X  int count_only;
X***************
X*** 28,49 ****
X  boolean level_exists[MAXLEVEL+1];
X  #endif
X  
X! #if defined(DGK) && !defined(TOS)
X  static void savelev0();
X! #endif /* DGK && !TOS */
X  static void saveobjchn();
X  static void savemonchn();
X  static void savegoldchn();
X  static void savetrapchn();
X  static void savegenoinfo();
X! #if defined(DGK) && !defined(TOS)
X  static boolean swapout_oldest();
X  static void copyfile();
X! #endif /* defined(DGK) && !defined(TOS) */
X  static void spill_objs();
X  
X  int
X  dosave(){
X  	pline("Really save? ");	/* especially useful if COMPRESS defined */
X  	if(yn() == 'n') {
X  		clrlin();
X--- 28,50 ----
X  boolean level_exists[MAXLEVEL+1];
X  #endif
X  
X! #if defined(DGK) && !defined(OLD_TOS)
X  static void savelev0();
X! #endif /* DGK && !OLD_TOS */
X  static void saveobjchn();
X  static void savemonchn();
X  static void savegoldchn();
X  static void savetrapchn();
X  static void savegenoinfo();
X! #if defined(DGK) && !defined(OLD_TOS)
X  static boolean swapout_oldest();
X  static void copyfile();
X! #endif /* defined(DGK) && !defined(OLD_TOS) */
X  static void spill_objs();
X  
X  int
X  dosave(){
X+ 	clrlin();
X  	pline("Really save? ");	/* especially useful if COMPRESS defined */
X  	if(yn() == 'n') {
X  		clrlin();
X***************
X*** 83,89 ****
X  	register int fd, ofd;
X  	int tmp;		/* not register ! */
X  	xchar ltmp;
X! #if defined(DGK) && !defined(TOS)
X  	long fds, needed;
X  	int mode;
X  #endif
X--- 84,90 ----
X  	register int fd, ofd;
X  	int tmp;		/* not register ! */
X  	xchar ltmp;
X! #if defined(DGK) && !defined(OLD_TOS)
X  	long fds, needed;
X  	int mode;
X  #endif
X***************
X*** 93,99 ****
X  #ifdef UNIX
X  	(void) signal(SIGHUP, SIG_IGN);
X  #endif
X! #if !defined(__TURBOC__) && !defined(TOS)
X  	(void) signal(SIGINT, SIG_IGN);
X  #endif
X  
X--- 94,100 ----
X  #ifdef UNIX
X  	(void) signal(SIGHUP, SIG_IGN);
X  #endif
X! #if !defined(__TURBOC__) && !defined(OLD_TOS)
X  	(void) signal(SIGINT, SIG_IGN);
X  #endif
X  
X***************
X*** 141,147 ****
X  		change_luck(-1);		/* and unido!ab */
X  	home();
X  	cl_end();
X! #if defined(DGK) && !defined(TOS)
X  	if(!hu) msmsg("Saving: ");
X  	mode = COUNT;
X  again:
X--- 142,148 ----
X  		change_luck(-1);		/* and unido!ab */
X  	home();
X  	cl_end();
X! #if defined(DGK) && !defined(OLD_TOS)
X  	if(!hu) msmsg("Saving: ");
X  	mode = COUNT;
X  again:
X***************
X*** 183,193 ****
X  	if(u.ustuck)
X  		bwrite(fd, (genericptr_t) &(u.ustuck->m_id), sizeof u.ustuck->m_id);
X  	bwrite(fd, (genericptr_t) pl_character, sizeof pl_character);
X  	bwrite(fd, (genericptr_t) pl_fruit, sizeof pl_fruit);
X  	bwrite(fd, (genericptr_t) &current_fruit, sizeof current_fruit);
X  	savefruitchn(fd);
X  	savenames(fd);
X! #if defined(DGK) && !defined(TOS)
X  	if (mode == COUNT) {
X  # ifdef ZEROCOMP
X  		bflush(fd);
X--- 184,196 ----
X  	if(u.ustuck)
X  		bwrite(fd, (genericptr_t) &(u.ustuck->m_id), sizeof u.ustuck->m_id);
X  	bwrite(fd, (genericptr_t) pl_character, sizeof pl_character);
X+ #ifdef TUTTI_FRUTTI
X  	bwrite(fd, (genericptr_t) pl_fruit, sizeof pl_fruit);
X  	bwrite(fd, (genericptr_t) &current_fruit, sizeof current_fruit);
X  	savefruitchn(fd);
X+ #endif
X  	savenames(fd);
X! #if defined(DGK) && !defined(OLD_TOS)
X  	if (mode == COUNT) {
X  # ifdef ZEROCOMP
X  		bflush(fd);
X***************
X*** 214,220 ****
X  	}
X  #endif
X  	for(ltmp = (xchar)1; ltmp <= maxdlevel; ltmp++) {
X! #if defined(DGK) && !defined(TOS)
X  		if (ltmp == dlevel || !fileinfo[ltmp].where) continue;
X  		if (fileinfo[ltmp].where != ACTIVE)
X  			swapin_file(ltmp);
X--- 217,223 ----
X  	}
X  #endif
X  	for(ltmp = (xchar)1; ltmp <= maxdlevel; ltmp++) {
X! #if defined(DGK) && !defined(OLD_TOS)
X  		if (ltmp == dlevel || !fileinfo[ltmp].where) continue;
X  		if (fileinfo[ltmp].where != ACTIVE)
X  			swapin_file(ltmp);
X***************
X*** 238,244 ****
X  		getlev(ofd, hackpid, ltmp, FALSE);
X  		(void) close(ofd);
X  		bwrite(fd, (genericptr_t) &ltmp, sizeof ltmp);  /* level number */
X! #if defined(DGK) && !defined(TOS)
X  		savelev(fd, ltmp, WRITE);			/* actual level */
X  #else
X  		savelev(fd, ltmp);			/* actual level */
X--- 241,247 ----
X  		getlev(ofd, hackpid, ltmp, FALSE);
X  		(void) close(ofd);
X  		bwrite(fd, (genericptr_t) &ltmp, sizeof ltmp);  /* level number */
X! #if defined(DGK) && !defined(OLD_TOS)
X  		savelev(fd, ltmp, WRITE);			/* actual level */
X  #else
X  		savelev(fd, ltmp);			/* actual level */
X***************
X*** 266,272 ****
X  	return(1);
X  }
X  
X! #if defined(DGK) && !defined(TOS)
X  boolean
X  savelev(fd, lev, mode)
X  int fd;
X--- 269,275 ----
X  	return(1);
X  }
X  
X! #if defined(DGK) && !defined(OLD_TOS)
X  boolean
X  savelev(fd, lev, mode)
X  int fd;
X***************
X*** 320,332 ****
X  #endif
X  
X  	if(fd < 0) panic("Save on bad file!");	/* impossible */
X! #if !defined(DGK) || defined(TOS)
X  	if(lev >= 0 && lev <= MAXLEVEL)
X  		level_exists[lev] = TRUE;
X  #endif
X  	bwrite(fd,(genericptr_t) &hackpid,sizeof(hackpid));
X  #ifdef TOS
X! 	tlev=lev;
X  	bwrite(fd,(genericptr_t) &tlev,sizeof(tlev));
X  #else
X  	bwrite(fd,(genericptr_t) &lev,sizeof(lev));
X--- 323,335 ----
X  #endif
X  
X  	if(fd < 0) panic("Save on bad file!");	/* impossible */
X! #if !defined(DGK) || defined(OLD_TOS)
X  	if(lev >= 0 && lev <= MAXLEVEL)
X  		level_exists[lev] = TRUE;
X  #endif
X  	bwrite(fd,(genericptr_t) &hackpid,sizeof(hackpid));
X  #ifdef TOS
X! 	tlev=lev; tlev &= 0x00ff;
X  	bwrite(fd,(genericptr_t) &tlev,sizeof(tlev));
X  #else
X  	bwrite(fd,(genericptr_t) &lev,sizeof(lev));
X***************
X*** 376,382 ****
X  		for(wtmp = wsegs[tmp]; wtmp; wtmp = wtmp->nseg){
X  			bwrite(fd,(genericptr_t) wtmp,sizeof(struct wseg));
X  		}
X! #if defined(DGK) && !defined(TOS)
X  		if (!count_only)
X  #endif
X  			wsegs[tmp] = 0;
X--- 379,385 ----
X  		for(wtmp = wsegs[tmp]; wtmp; wtmp = wtmp->nseg){
X  			bwrite(fd,(genericptr_t) wtmp,sizeof(struct wseg));
X  		}
X! #if defined(DGK) && !defined(OLD_TOS)
X  		if (!count_only)
X  #endif
X  			wsegs[tmp] = 0;
X***************
X*** 383,389 ****
X  	}
X  	bwrite(fd,(genericptr_t) wgrowtime,sizeof(wgrowtime));
X  #endif /* WORM /**/
X! #if defined(DGK) && !defined(TOS)
X  	if (count_only)	return;
X  #endif
X  	billobjs = 0;
X--- 386,392 ----
X  	}
X  	bwrite(fd,(genericptr_t) wgrowtime,sizeof(wgrowtime));
X  #endif /* WORM /**/
X! #if defined(DGK) && !defined(OLD_TOS)
X  	if (count_only)	return;
X  #endif
X  	billobjs = 0;
X***************
X*** 432,438 ****
X  	  flushoutrun(outrunlength);
X        }
X        if (outbufp) {
X! #ifdef	DGK
X  	  if (!count_only)    /* flush buffer */
X  #endif
X  		  (void) write(fd, outbuf, outbufp);
X--- 435,441 ----
X  	  flushoutrun(outrunlength);
X        }
X        if (outbufp) {
X! #if defined(DGK) && !defined(OLD_TOS)
X  	  if (!count_only)    /* flush buffer */
X  #endif
X  		  (void) write(fd, outbuf, outbufp);
X***************
X*** 470,476 ****
X  register genericptr_t loc;
X  register unsigned num;
X  {
X! #if defined(DGK) && !defined(TOS)
X  	bytes_counted += num;
X  	if (!count_only)
X  #endif
X--- 473,479 ----
X  register genericptr_t loc;
X  register unsigned num;
X  {
X! #if defined(DGK) && !defined(OLD_TOS)
X  	bytes_counted += num;
X  	if (!count_only)
X  #endif
X***************
X*** 503,509 ****
X  	    xl = otmp->onamelth;
X  	    bwrite(fd, (genericptr_t) &xl, sizeof(int));
X  	    bwrite(fd, (genericptr_t) otmp, xl + sizeof(struct obj));
X! #if defined(DGK) && !defined(TOS)
X  	    if (!count_only)
X  #endif
X  		free((genericptr_t) otmp);
X--- 506,512 ----
X  	    xl = otmp->onamelth;
X  	    bwrite(fd, (genericptr_t) &xl, sizeof(int));
X  	    bwrite(fd, (genericptr_t) otmp, xl + sizeof(struct obj));
X! #if defined(DGK) && !defined(OLD_TOS)
X  	    if (!count_only)
X  #endif
X  		free((genericptr_t) otmp);
X***************
X*** 530,536 ****
X  		bwrite(fd, (genericptr_t) &xl, sizeof(int));
X  		bwrite(fd, (genericptr_t) mtmp, xl + sizeof(struct monst));
X  		if(mtmp->minvent) saveobjchn(fd,mtmp->minvent);
X! #if defined(DGK) && !defined(TOS)
X  		if (!count_only)
X  #endif
X  		free((genericptr_t) mtmp);
X--- 533,539 ----
X  		bwrite(fd, (genericptr_t) &xl, sizeof(int));
X  		bwrite(fd, (genericptr_t) mtmp, xl + sizeof(struct monst));
X  		if(mtmp->minvent) saveobjchn(fd,mtmp->minvent);
X! #if defined(DGK) && !defined(OLD_TOS)
X  		if (!count_only)
X  #endif
X  		free((genericptr_t) mtmp);
X***************
X*** 548,554 ****
X  	while(gold) {
X  		gold2 = gold->ngold;
X  		bwrite(fd, (genericptr_t) gold, sizeof(struct gold));
X! #if defined(DGK) && !defined(TOS)
X  		if (!count_only)
X  #endif
X  			free((genericptr_t) gold);
X--- 551,557 ----
X  	while(gold) {
X  		gold2 = gold->ngold;
X  		bwrite(fd, (genericptr_t) gold, sizeof(struct gold));
X! #if defined(DGK) && !defined(OLD_TOS)
X  		if (!count_only)
X  #endif
X  			free((genericptr_t) gold);
X***************
X*** 566,572 ****
X  	while(trap) {
X  		trap2 = trap->ntrap;
X  		bwrite(fd, (genericptr_t) trap, sizeof(struct trap));
X! #if defined(DGK) && !defined(TOS)
X  		if (!count_only)
X  #endif
X  			free((genericptr_t) trap);
X--- 569,575 ----
X  	while(trap) {
X  		trap2 = trap->ntrap;
X  		bwrite(fd, (genericptr_t) trap, sizeof(struct trap));
X! #if defined(DGK) && !defined(OLD_TOS)
X  		if (!count_only)
X  #endif
X  			free((genericptr_t) trap);
X***************
X*** 575,580 ****
X--- 578,584 ----
X  	bwrite(fd, (genericptr_t)nul, sizeof(struct trap));
X  }
X  
X+ #ifdef TUTTI_FRUTTI
X  /* save all the fruit names and ID's; this is used only in saving whole games
X   * (not levels) and in saving bones levels.  When saving a bones level,
X   * we only want to save the fruits which exist on the bones level; the bones
X***************
X*** 584,599 ****
X  savefruitchn(fd)
X  register int fd;
X  {
X! 	register struct fruit *f2;
X! 	while(ffruit) {
X! 		f2 = ffruit->nextf;
X! 		if (ffruit->fid >= 0)
X! 			bwrite(fd, (genericptr_t) ffruit, sizeof(struct fruit));
X! 		free((genericptr_t) ffruit);
X! 		ffruit = f2;
X  	}
X  	bwrite(fd, (genericptr_t)nul, sizeof(struct fruit));
X  }
X  
X  static void
X  savegenoinfo(fd)
X--- 588,610 ----
X  savefruitchn(fd)
X  register int fd;
X  {
X! 	register struct fruit *f2, *f1;
X! 
X! 	f1 = ffruit;
X! 	while(f1) {
X! 		f2 = f1->nextf;
X! 		if (f1->fid >= 0) {
X! 			bwrite(fd, (genericptr_t) f1, sizeof(struct fruit));
X! 		}
X! #if defined(DGK) && !defined(OLD_TOS)
X! 		if (!count_only)
X! #endif
X! 			free((genericptr_t) f1);
X! 		f1 = f2;
X  	}
X  	bwrite(fd, (genericptr_t)nul, sizeof(struct fruit));
X  }
X+ #endif
X  
X  static void
X  savegenoinfo(fd)
X***************
X*** 605,611 ****
X  		bwrite(fd, (genericptr_t) &(mons[i].geno), sizeof(unsigned));
X  }
X  
X! #if defined(DGK) && !defined(TOS)
X  boolean
X  swapin_file(lev)
X  int lev;
X--- 616,622 ----
X  		bwrite(fd, (genericptr_t) &(mons[i].geno), sizeof(unsigned));
X  }
X  
X! #if defined(DGK) && !defined(OLD_TOS)
X  boolean
X  swapin_file(lev)
X  int lev;
X***************
X*** 668,673 ****
X--- 679,690 ----
X  copyfile(from, to)
X  char *from, *to;
X  {
X+ #ifdef TOS
X+ 	extern int _copyfile();
X+ 
X+ 	if (_copyfile(from, to))
X+ 		panic("Can't copy %s to %s\n", from, to);
X+ #else
X  	char buf[BUFSIZ];
X  	int nfrom, nto, fdfrom, fdto;
X  
X***************
X*** 683,688 ****
X--- 700,706 ----
X  	} while (nfrom == BUFSIZ);
X  	(void) close(fdfrom);
X  	(void) close(fdto);
X+ #endif /* TOS */
X  }
X  #endif
X  
END_OF_FILE
if test 55712 -ne `wc -c <'src3.diff'`; then
    echo shar: \"'src3.diff'\" unpacked with wrong size!
fi
# end of 'src3.diff'
fi
echo shar: End of archive 5 \(of 6\).
cp /dev/null ark5isdone
MISSING=""
for I in 1 2 3 4 5 6 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 6 archives.
    echo "now type ./do_patch.sh"
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
