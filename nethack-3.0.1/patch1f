Path: utzoo!utgpu!jarvis.csri.toronto.edu!rutgers!usc!cs.utexas.edu!uunet!zephyr.ens.tek.com!tekgen!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v07i099:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Patch1f
Message-ID: <4393@tekred.CNA.TEK.COM>
Date: 3 Aug 89 17:00:44 GMT
Sender: nobody@tekred.CNA.TEK.COM
Lines: 1891
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 7, Issue 99
Archive-name: NetHack3/Patch1f
Patch-To: NetHack3: Volume 7, Issue 56-93



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 6 (of 6)."
# Contents:  src4.diff
# Wrapped by billr@saab on Thu Aug  3 09:57:48 1989
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'src4.diff' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src4.diff'\"
else
echo shar: Extracting \"'src4.diff'\" \(48599 characters\)
sed "s/^X//" >'src4.diff' <<'END_OF_FILE'
XSource patches, part 4 and final
X
X-----------------------------------Cut---------------------------------
X*** src/Old/shk.c	Mon Jul 31 14:40:35 1989
X--- src/shk.c	Thu Jul 27 11:37:49 1989
X***************
X*** 386,392 ****
X  register struct monst *shkp;
X  {
X  	long robbed = ESHK(shkp)->robbed;
X! 	long balance = ((tmp <= 0) ? tmp : check_credit(tmp, shkp));
X  
X  	u.ugold -= balance;
X  	shkp->mgold += balance;
X--- 386,392 ----
X  register struct monst *shkp;
X  {
X  	long robbed = ESHK(shkp)->robbed;
X! 	long balance = ((tmp <= 0L) ? tmp : check_credit(tmp, shkp));
X  
X  	u.ugold -= balance;
X  	shkp->mgold += balance;
X***************
X*** 393,399 ****
X  	flags.botl = 1;
X  	if(robbed) {
X  		robbed -= tmp;
X! 		if(robbed < 0) robbed = 0;
X  		ESHK(shkp)->robbed = robbed;
X  	}
X  }
X--- 393,399 ----
X  	flags.botl = 1;
X  	if(robbed) {
X  		robbed -= tmp;
X! 		if(robbed < 0) robbed = 0L;
X  		ESHK(shkp)->robbed = robbed;
X  	}
X  }
X***************
X*** 421,427 ****
X  
X  	NOTANGRY(shkp) = 1;
X  	ESHK(shkp)->following = 0;
X! 	ESHK(shkp)->robbed = 0;
X  	if (pl_character[0] != 'R')
X  		adjalign(sgn(u.ualigntyp));
X  	if(!inhishop(shkp)) {
X--- 421,427 ----
X  
X  	NOTANGRY(shkp) = 1;
X  	ESHK(shkp)->following = 0;
X! 	ESHK(shkp)->robbed = 0L;
X  	if (pl_character[0] != 'R')
X  		adjalign(sgn(u.ualigntyp));
X  	if(!inhishop(shkp)) {
X***************
X*** 477,483 ****
X  			You("give %s all your gold.", mon_nam(shkp));
X  			pay(u.ugold, shkp);
X  		    }
X! 		    if(ugold < ltmp/2)
X  			pline("Unfortunately, %s doesn't look satisfied.",
X  			    ESHK(shkp)->ismale ? "he" : "she");
X  		    else
X--- 477,483 ----
X  			You("give %s all your gold.", mon_nam(shkp));
X  			pay(u.ugold, shkp);
X  		    }
X! 		    if(ugold < ltmp/2L)
X  			pline("Unfortunately, %s doesn't look satisfied.",
X  			    ESHK(shkp)->ismale ? "he" : "she");
X  		    else
X***************
X*** 487,499 ****
X  	}
X  
X  	/* ltmp is still ESHK(shkp)->robbed here */
X! 	if(!ESHK(shkp)->billct) {
X  		if(!ltmp && NOTANGRY(shkp)) {
X  		    You("do not owe %s anything.", mon_nam(shkp));
X  		    if(!u.ugold) pline(no_money);
X  		} else if(ltmp) {
X  		    pline("%s is after blood, not money!", mon_nam(shkp));
X! 		    if(u.ugold < ltmp/2) {
X  			if(!u.ugold) pline(no_money);
X  			else pline("Besides, you don't have enough to interest %s.",
X  				ESHK(shkp)->ismale ? "him" : "her");
X--- 487,499 ----
X  	}
X  
X  	/* ltmp is still ESHK(shkp)->robbed here */
X! 	if(!ESHK(shkp)->billct && !ESHK(shkp)->debit) {
X  		if(!ltmp && NOTANGRY(shkp)) {
X  		    You("do not owe %s anything.", mon_nam(shkp));
X  		    if(!u.ugold) pline(no_money);
X  		} else if(ltmp) {
X  		    pline("%s is after blood, not money!", mon_nam(shkp));
X! 		    if(u.ugold < ltmp/2L) {
X  			if(!u.ugold) pline(no_money);
X  			else pline("Besides, you don't have enough to interest %s.",
X  				ESHK(shkp)->ismale ? "him" : "her");
X***************
X*** 512,518 ****
X  		     * door broken, attacked, etc. */
X  		    pline("%s is after your hide, not your money!",
X  					mon_nam(shkp));
X! 		    if(u.ugold < 1000) {
X  			if(!u.ugold) pline(no_money);
X  			else
X  		pline("Besides, you don't have enough to interest %s.",
X--- 512,518 ----
X  		     * door broken, attacked, etc. */
X  		    pline("%s is after your hide, not your money!",
X  					mon_nam(shkp));
X! 		    if(u.ugold < 1000L) {
X  			if(!u.ugold) pline(no_money);
X  			else
X  		pline("Besides, you don't have enough to interest %s.",
X***************
X*** 618,624 ****
X  	}
X  	obj->unpaid = 0;
X  	ltmp = bp->price * bp->bquan;
X! 	if(ANGRY(shopkeeper)) ltmp += ltmp/3;
X  	if(u.ugold + ESHK(shopkeeper)->credit < ltmp){
X  		You("don't have gold%s enough to pay for %s.",
X  			(ESHK(shopkeeper)->credit > 0L) ? " or credit" : "",
X--- 618,624 ----
X  	}
X  	obj->unpaid = 0;
X  	ltmp = bp->price * bp->bquan;
X! 	if(ANGRY(shopkeeper)) ltmp += ltmp/3L;
X  	if(u.ugold + ESHK(shopkeeper)->credit < ltmp){
X  		You("don't have gold%s enough to pay for %s.",
X  			(ESHK(shopkeeper)->credit > 0L) ? " or credit" : "",
X***************
X*** 647,653 ****
X  boolean
X  paybill(){
X  	register struct monst *mtmp;
X! 	register int loss = 0;
X  	register struct obj *otmp;
X  	register xchar ox, oy;
X  	register boolean take = FALSE;
X--- 647,653 ----
X  boolean
X  paybill(){
X  	register struct monst *mtmp;
X! 	register long loss = 0L;
X  	register struct obj *otmp;
X  	register xchar ox, oy;
X  	register boolean take = FALSE;
X***************
X*** 666,680 ****
X  	/* shopkeeper is peaceful, nothing stolen, nothing owed. */
X  	if(in_shop(u.ux,u.uy) && !IS_DOOR(levl[u.ux][u.uy].typ) &&
X  	    !ESHK(shopkeeper)->billct && !ESHK(shopkeeper)->robbed &&
X! 	    inhishop(shopkeeper) && NOTANGRY(shopkeeper) &&
X! 	    !ESHK(shopkeeper)->following) {
X  		pline("%s gratefully inherits all your possessions.",
X  				Monnam(shopkeeper));
X  		goto clear;
X  	}
X  
X! 	if(ESHK(shopkeeper)->billct || ESHK(shopkeeper)->robbed) {
X  		addupbill();
X  		loss = ((total >= ESHK(shopkeeper)->robbed) ? total :
X  				ESHK(shopkeeper)->robbed);
X  		take = TRUE;
X--- 666,682 ----
X  	/* shopkeeper is peaceful, nothing stolen, nothing owed. */
X  	if(in_shop(u.ux,u.uy) && !IS_DOOR(levl[u.ux][u.uy].typ) &&
X  	    !ESHK(shopkeeper)->billct && !ESHK(shopkeeper)->robbed &&
X! 	    !ESHK(shopkeeper)->debit && inhishop(shopkeeper) && 
X! 	     NOTANGRY(shopkeeper) && !ESHK(shopkeeper)->following) {
X  		pline("%s gratefully inherits all your possessions.",
X  				Monnam(shopkeeper));
X  		goto clear;
X  	}
X  
X! 	if(ESHK(shopkeeper)->billct || ESHK(shopkeeper)->debit ||
X! 			ESHK(shopkeeper)->robbed) {
X  		addupbill();
X+ 		total += ESHK(shopkeeper)->debit;
X  		loss = ((total >= ESHK(shopkeeper)->robbed) ? total :
X  				ESHK(shopkeeper)->robbed);
X  		take = TRUE;
X***************
X*** 686,692 ****
X  					Monnam(shopkeeper));
X  			taken = TRUE;
X  			shopkeeper->mgold += u.ugold;
X! 			u.ugold = 0;
X  			/* in case bones: make it be for real... */
X  			if(!in_shop(u.ux, u.uy) || IS_DOOR(levl[u.ux][u.uy].typ)) {
X  			    /* shk.x,shk.y is the position immediately in
X--- 688,694 ----
X  					Monnam(shopkeeper));
X  			taken = TRUE;
X  			shopkeeper->mgold += u.ugold;
X! 			u.ugold = 0L;
X  			/* in case bones: make it be for real... */
X  			if(!in_shop(u.ux, u.uy) || IS_DOOR(levl[u.ux][u.uy].typ)) {
X  			    /* shk.x,shk.y is the position immediately in
X***************
X*** 768,775 ****
X  {
X  	register long tmp;
X  
X! 	tmp = getprice(obj);
X! 	if (!tmp) tmp = 5;
X  	if (ANGRY(shopkeeper) || 
X  		(pl_character[0] == 'T' && u.ulevel < (MAXULEV/2))
X  #ifdef SHIRT
X--- 770,777 ----
X  {
X  	register long tmp;
X  
X! 	tmp = (long) getprice(obj);
X! 	if (!tmp) tmp = 5L;
X  	if (ANGRY(shopkeeper) || 
X  		(pl_character[0] == 'T' && u.ulevel < (MAXULEV/2))
X  #ifdef SHIRT
X***************
X*** 776,788 ****
X  	    || (uarmu && !uarm) /* wearing just a Hawaiian shirt */
X  #endif
X  	   )
X! 		tmp += tmp/3;
X! 	if (ACURR(A_CHA) > 18)		tmp /= 2;
X! 	else if (ACURR(A_CHA) > 17)	tmp = (tmp * 2)/3;
X! 	else if (ACURR(A_CHA) > 15)	tmp = (tmp * 3)/4;
X! 	else if (ACURR(A_CHA) < 11)	tmp = (tmp * 4)/3;
X! 	else if (ACURR(A_CHA) < 8)	tmp = (tmp * 3)/2;
X! 	else if (ACURR(A_CHA) < 6)	tmp *= 2;
X  	return(tmp);
X  }
X  
X--- 778,790 ----
X  	    || (uarmu && !uarm) /* wearing just a Hawaiian shirt */
X  #endif
X  	   )
X! 		tmp += tmp/3L;
X! 	if (ACURR(A_CHA) > 18)		tmp /= 2L;
X! 	else if (ACURR(A_CHA) > 17)	tmp = (tmp * 2L)/3L;
X! 	else if (ACURR(A_CHA) > 15)	tmp = (tmp * 3L)/4L;
X! 	else if (ACURR(A_CHA) < 11)	tmp = (tmp * 4L)/3L;
X! 	else if (ACURR(A_CHA) < 8)	tmp = (tmp * 3L)/2L;
X! 	else if (ACURR(A_CHA) < 6)	tmp *= 2L;
X  	return(tmp);
X  }
X  
X***************
X*** 891,902 ****
X  register struct obj *obj;
X  {
X  	long ltmp;
X- 	/* register int tmp;	/* use of tmp commented out below */
X- 	register struct obj *otmp;
X  	register struct bill_x *bp;
X  	if(!costly_spot(u.ux,u.uy))
X  		return;
X  	if((bp = onbill(obj)) != 0) {
X  		obj->unpaid = 0;
X  		if(bp->bquan > obj->quan){
X  			otmp = newobj(0);
X--- 893,905 ----
X  register struct obj *obj;
X  {
X  	long ltmp;
X  	register struct bill_x *bp;
X+ 
X  	if(!costly_spot(u.ux,u.uy))
X  		return;
X  	if((bp = onbill(obj)) != 0) {
X+ 		register struct obj *otmp;
X+ 
X  		obj->unpaid = 0;
X  		if(bp->bquan > obj->quan){
X  			otmp = newobj(0);
X***************
X*** 923,932 ****
X  	/* he dropped something of his own - probably wants to sell it */
X  	if(shopkeeper->msleep || shopkeeper->mfroz || !inhishop(shopkeeper))
X  		return;
X! 	ltmp = getprice(obj) * obj->quan;
X  	if(ESHK(shopkeeper)->billct == BILLSZ
X  	   || !saleable(rooms[ESHK(shopkeeper)->shoproom].rtype-SHOPBASE, obj)
X! 	   || otmp->olet == BALL_SYM || ltmp == 0L) {
X  		pline("%s seems not interested.", Monnam(shopkeeper));
X  		obj->no_charge = 1;
X  		return;
X--- 926,935 ----
X  	/* he dropped something of his own - probably wants to sell it */
X  	if(shopkeeper->msleep || shopkeeper->mfroz || !inhishop(shopkeeper))
X  		return;
X! 	ltmp = (long) getprice(obj) * (long) obj->quan;
X  	if(ESHK(shopkeeper)->billct == BILLSZ
X  	   || !saleable(rooms[ESHK(shopkeeper)->shoproom].rtype-SHOPBASE, obj)
X! 	   || obj->olet == BALL_SYM || ltmp == 0L) {
X  		pline("%s seems not interested.", Monnam(shopkeeper));
X  		obj->no_charge = 1;
X  		return;
X***************
X*** 936,947 ****
X  	    || (uarmu && !uarm) /* wearing just a Hawaiian shirt */
X  #endif
X  	   ) {
X! 		ltmp /= 3;
X  		NOTANGRY(shopkeeper) = 1;
X! 	} else	ltmp /= 2;
X  	if(ESHK(shopkeeper)->robbed) {
X! 		if((ESHK(shopkeeper)->robbed -= ltmp) < 0)
X! 			ESHK(shopkeeper)->robbed = 0;
X  pline("\"Thank you for your contribution to restock this recently plundered shop.\"");
X  		return;
X  	}
X--- 939,950 ----
X  	    || (uarmu && !uarm) /* wearing just a Hawaiian shirt */
X  #endif
X  	   ) {
X! 		ltmp /= 3L;
X  		NOTANGRY(shopkeeper) = 1;
X! 	} else	ltmp /= 2L;
X  	if(ESHK(shopkeeper)->robbed) {
X! 		if((ESHK(shopkeeper)->robbed -= ltmp) < 0L)
X! 			ESHK(shopkeeper)->robbed = 0L;
X  pline("\"Thank you for your contribution to restock this recently plundered shop.\"");
X  		return;
X  	}
X***************
X*** 986,992 ****
X  	if(page_line("Unpaid articles already used up:") || page_line(""))
X  	    goto quit;
X  
X! 	totused = 0;
X  	for(bp = bill; bp - bill < ESHK(shopkeeper)->billct; bp++) {
X  	    obj = bp_to_obj(bp);
X  	    if(!obj) {
X--- 989,995 ----
X  	if(page_line("Unpaid articles already used up:") || page_line(""))
X  	    goto quit;
X  
X! 	totused = 0L;
X  	for(bp = bill; bp - bill < ESHK(shopkeeper)->billct; bp++) {
X  	    obj = bp_to_obj(bp);
X  	    if(!obj) {
X***************
X*** 1047,1053 ****
X  			tmp = 0;
X  		break;
X  	case ARMOR_SYM:
X- 		if (u.uac > 0) tmp += u.uac * 2;
X  	case WEAPON_SYM:
X  		if (obj->spe > 0) tmp += 10 * obj->spe;
X  		break;
X--- 1050,1055 ----
X***************
X*** 1156,1162 ****
X  		    uondoor = (u.ux == ESHK(shkp)->shd.x &&
X  				u.uy == ESHK(shkp)->shd.y);
X  		    if(uondoor) {
X! 			if(ESHK(shkp)->billct && inhishop(shkp))
X  			    pline(NOTANGRY(shkp) ?
X  				"\"Hello, %s!  Will you please pay before leaving?\"" :
X  				"\"Hey, %s!  Don't leave without paying!\"",
X--- 1158,1165 ----
X  		    uondoor = (u.ux == ESHK(shkp)->shd.x &&
X  				u.uy == ESHK(shkp)->shd.y);
X  		    if(uondoor) {
X! 			if((ESHK(shkp)->billct || ESHK(shkp)->debit) 
X! 					&& inhishop(shkp))
X  			    pline(NOTANGRY(shkp) ?
X  				"\"Hello, %s!  Will you please pay before leaving?\"" :
X  				"\"Hey, %s!  Don't leave without paying!\"",
X***************
X*** 1170,1176 ****
X  			badinv = FALSE;
X  		    }
X  
X! 		    if(((!ESHK(shkp)->robbed && !ESHK(shkp)->billct) || avoid)
X  			&& GDIST(omx,omy) < 3) {
X  			if(!badinv && !online(omx,omy))
X  			    return(0);
X--- 1173,1180 ----
X  			badinv = FALSE;
X  		    }
X  
X! 		    if(((!ESHK(shkp)->robbed && !ESHK(shkp)->billct &&
X! 				!ESHK(shkp)->debit) || avoid)
X  			&& GDIST(omx,omy) < 3) {
X  			if(!badinv && !online(omx,omy))
X  			    return(0);
X***************
X*** 1263,1281 ****
X  	register int kcnt = (cnt / 9);		/* and maybe a kaptain */
X  
X  	while(cnt--) {
X! 	    enexto(mm, mm->x, mm->y);
X  	    (void) makemon(&mons[PM_KEYSTONE_KOP], mm->x, mm->y);
X  	}
X  	while(scnt--) {
X! 	    enexto(mm, mm->x, mm->y);
X  	    (void) makemon(&mons[PM_KOP_SERGEANT], mm->x, mm->y);
X  	}
X  	while(lcnt--) {
X! 	    enexto(mm, mm->x, mm->y);
X  	    (void) makemon(&mons[PM_KOP_LIEUTENANT], mm->x, mm->y);
X  	}
X  	while(kcnt--) {
X! 	    enexto(mm, mm->x, mm->y);
X  	    (void) makemon(&mons[PM_KOP_KAPTAIN], mm->x, mm->y);
X  	}
X  	return(cnt + scnt + lcnt + kcnt);
X--- 1267,1285 ----
X  	register int kcnt = (cnt / 9);		/* and maybe a kaptain */
X  
X  	while(cnt--) {
X! 	    enexto(mm, mm->x, mm->y, &mons[PM_KEYSTONE_KOP]);
X  	    (void) makemon(&mons[PM_KEYSTONE_KOP], mm->x, mm->y);
X  	}
X  	while(scnt--) {
X! 	    enexto(mm, mm->x, mm->y, &mons[PM_KOP_SERGEANT]);
X  	    (void) makemon(&mons[PM_KOP_SERGEANT], mm->x, mm->y);
X  	}
X  	while(lcnt--) {
X! 	    enexto(mm, mm->x, mm->y, &mons[PM_KOP_LIEUTENANT]);
X  	    (void) makemon(&mons[PM_KOP_LIEUTENANT], mm->x, mm->y);
X  	}
X  	while(kcnt--) {
X! 	    enexto(mm, mm->x, mm->y, &mons[PM_KOP_KAPTAIN]);
X  	    (void) makemon(&mons[PM_KOP_KAPTAIN], mm->x, mm->y);
X  	}
X  	return(cnt + scnt + lcnt + kcnt);
X***************
X*** 1353,1359 ****
X  
X  	if(um_dist(x, y, 1)) goto chase;
X  
X! 	if(u.ugold < damage || !rn2(50)) {
X  chase:
X  		if(um_dist(x, y, 1))
X  		    pline("%s shouts: \"Who dared %s my door?\"",
X--- 1357,1363 ----
X  
X  	if(um_dist(x, y, 1)) goto chase;
X  
X! 	if(u.ugold < (long) damage || !rn2(50)) {
X  chase:
X  		if(um_dist(x, y, 1))
X  		    pline("%s shouts: \"Who dared %s my door?\"",
X***************
X*** 1366,1373 ****
X  
X  	pline("\"Cad!  You did %d zorkmids worth of damage!\"  Pay? ", damage);
X  	if(yn() != 'n') {
X! 		u.ugold -= damage;
X! 		shopkeeper->mgold += damage;
X  		flags.botl = 1;
X  		pline("Mollified, %s accepts your restitution.",
X  			shkname(shopkeeper));
X--- 1370,1377 ----
X  
X  	pline("\"Cad!  You did %d zorkmids worth of damage!\"  Pay? ", damage);
X  	if(yn() != 'n') {
X! 		u.ugold -= (long) damage;
X! 		shopkeeper->mgold += (long) damage;
X  		flags.botl = 1;
X  		pline("Mollified, %s accepts your restitution.",
X  			shkname(shopkeeper));
X***************
X*** 1433,1439 ****
X  	register long tmp = get_cost(otmp);
X  
X  	/* The idea is to make the exhaustive use of */
X! 	/* an unpaid item more expansive than buying */
X  	/* outright.				     */
X  	if(otmp->otyp == MAGIC_LAMP) {			 /* 1 */
X  		tmp += (tmp/3L);
X--- 1437,1443 ----
X  	register long tmp = get_cost(otmp);
X  
X  	/* The idea is to make the exhaustive use of */
X! 	/* an unpaid item more expensive than buying */
X  	/* outright.				     */
X  	if(otmp->otyp == MAGIC_LAMP) {			 /* 1 */
X  		tmp += (tmp/3L);
X*** src/Old/shknam.c	Mon Jul 31 14:41:46 1989
X--- src/shknam.c	Sun Jul 30 18:57:44 1989
X***************
X*** 268,285 ****
X  	ESHK(shk)->shd = doors[sh];
X  	ESHK(shk)->shk.x = sx;
X  	ESHK(shk)->shk.y = sy;
X! 	/* makemon() has already zeroed out all the extra space
X! 	ESHK(shk)->robbed = 0;
X! 	ESHK(shk)->credit = 0;
X! 	ESHK(shk)->debit = 0;
X  	ESHK(shk)->visitct = 0;
X  	ESHK(shk)->following = 0;
X  	ESHK(shk)->billct = 0;
X! 	*/
X! 	shk->mgold = 1000 + 30*rnd(100);	/* initial capital */
X  	if (shp->shknms == shktools) {
X  		static int who;
X! 		who = rn2(sizeof(shktools)/sizeof(char *));
X  		if (who==21) ESHK(shk)->ismale = FALSE;
X  		else ESHK(shk)->ismale = TRUE;
X  		(void) strncpy(ESHK(shk)->shknam, shp->shknms[who], PL_NSIZ);
X--- 268,283 ----
X  	ESHK(shk)->shd = doors[sh];
X  	ESHK(shk)->shk.x = sx;
X  	ESHK(shk)->shk.y = sy;
X! 	ESHK(shk)->robbed = 0L;
X! 	ESHK(shk)->credit = 0L;
X! 	ESHK(shk)->debit = 0L;
X  	ESHK(shk)->visitct = 0;
X  	ESHK(shk)->following = 0;
X  	ESHK(shk)->billct = 0;
X! 	shk->mgold = 1000L + 30L*(long)rnd(100);	/* initial capital */
X  	if (shp->shknms == shktools) {
X  		static int who;
X! 		who = rn2(sizeof(shktools)/sizeof(char *) - 1);
X  		if (who==21) ESHK(shk)->ismale = FALSE;
X  		else ESHK(shk)->ismale = TRUE;
X  		(void) strncpy(ESHK(shk)->shknam, shp->shknms[who], PL_NSIZ);
X*** src/Old/sounds.c	Mon Jul 31 14:42:44 1989
X--- src/sounds.c	Sat Jul 29 12:04:51 1989
X***************
X*** 585,591 ****
X      }
X  
X      tx = u.ux+u.dx; ty = u.uy+u.dy;
X!     if (!cansee(tx,ty) || !levl[tx][ty].mmask || (mtmp = m_at(tx, ty))->mimic) {
X  	pline("I see nobody there.");
X  	return(0);
X      }
X--- 585,592 ----
X      }
X  
X      tx = u.ux+u.dx; ty = u.uy+u.dy;
X!     if ((Blind && !Telepat) || !levl[tx][ty].mmask ||
X! 	    (mtmp = m_at(tx, ty))->mimic || mtmp->mundetected) {
X  	pline("I see nobody there.");
X  	return(0);
X      }
X*** src/Old/spell.c	Mon Jul 31 14:43:48 1989
X--- src/spell.c	Mon Jul 24 14:47:30 1989
X***************
X*** 297,303 ****
X  		energy *= rnd(6);
X  	}
X  	if(energy > u.uen)  {
X! 		You("are too weak to cast that spell.");
X  		return(0);
X  	} else	if ((u.uhunger <= 100 && spell != SPE_DETECT_FOOD) ||
X  						(ACURR(A_STR) < 6))  {
X--- 297,303 ----
X  		energy *= rnd(6);
X  	}
X  	if(energy > u.uen)  {
X! 		You("don't have enough energy to cast that spell.");
X  		return(0);
X  	} else	if ((u.uhunger <= 100 && spell != SPE_DETECT_FOOD) ||
X  						(ACURR(A_STR) < 6))  {
X*** src/Old/termcap.c	Mon Jul 31 14:44:47 1989
X--- src/termcap.c	Mon Jul 31 09:13:43 1989
X***************
X*** 17,22 ****
X--- 17,28 ----
X  short	ospeed = 0;	/* gets around "not defined" error message */
X  #endif
X  
X+ #ifdef MICROPORT_286_BUG
X+ #define Tgetstr(key) (tgetstr(key,tbuf))
X+ #else
X+ #define Tgetstr(key) (tgetstr(key,&tbufptr))
X+ #endif /* MICROPORT_286_BUG **/
X+ 
X  static void nocmov();
X  #ifdef MSDOSCOLOR
X  static void init_hilite();
X***************
X*** 44,50 ****
X  void
X  startup()
X  {
X! #ifdef TOS
X  	HO = "\033H";
X  	CL = "\033E";		/* the VT52 termcap */
X  	CE = "\033K";
X--- 50,56 ----
X  void
X  startup()
X  {
X! #if defined(TOS) && !defined(TERMLIB)
X  	HO = "\033H";
X  	CL = "\033E";		/* the VT52 termcap */
X  	CE = "\033K";
X***************
X*** 63,71 ****
X  	char *tbufptr, *pc;
X  	register int i;
X  
X- 	tptr = (char *) alloc(1024);
X- 
X- 	tbufptr = tbuf;
X  	if(!(term = getenv("TERM")))
X  # ifdef ANSI_DEFAULT
X  	{
X--- 69,74 ----
X***************
X*** 80,86 ****
X  		BC = "\033[D";
X  		HI = SO = "\033[1m";
X  		US = "\033[4m";
X! 		TI = HE = SE = UE = "\033[0m";
X  		/* strictly, SE should be 2, and UE should be 24,
X  		   but we can't trust all ANSI emulators to be
X  		   that complete.  -3. */
X--- 83,90 ----
X  		BC = "\033[D";
X  		HI = SO = "\033[1m";
X  		US = "\033[4m";
X! 		MR = "\033[7m";
X! 		TI = HE = SE = UE = ME = "\033[0m";
X  		/* strictly, SE should be 2, and UE should be 24,
X  		   but we can't trust all ANSI emulators to be
X  		   that complete.  -3. */
X***************
X*** 87,106 ****
X  		AS = "\016";
X  		AE = "\017";
X  		VS = VE = "";
X! 	} else {
X  # else
X  		error("Can't get TERM.");
X  # endif
X  	if(!strncmp(term, "5620", 4))
X  		flags.nonull = 1;	/* this should be a termcap flag */
X  	if(tgetent(tptr, term) < 1)
X  		error("Unknown terminal type: %s.", term);
X! 	if(pc = tgetstr("pc", &tbufptr))
X  		PC = *pc;
X  #ifdef TERMINFO
X! 	if(!(BC = tgetstr("le", &tbufptr))) {	
X  #else
X! 	if(!(BC = tgetstr("bc", &tbufptr))) {	
X  #endif
X  #if !defined(MINIMAL_TERM) && !defined(HISX)
X  		if(!tgetflag("bs"))
X--- 91,126 ----
X  		AS = "\016";
X  		AE = "\017";
X  		VS = VE = "";
X! #  ifdef MSDOSCOLOR
X! 		HI_WHITE = HI;
X! 		HI_RED = "\033[1;31m";
X! 		HI_YELLOW = "\033[1;33m";
X! 		HI_GREEN = "\033[1;32m";
X! 		HI_BLUE = "\033[1;34m";
X! #  endif
X! 		return;
X! 	}
X  # else
X+ #  if defined(TOS) && defined(__GNUC__)		/* library has a default */
X+ 		term = "st52";
X+ #  else
X  		error("Can't get TERM.");
X+ #  endif
X  # endif
X+ 
X+ 	tptr = (char *) alloc(1024);
X+ 
X+ 	tbufptr = tbuf;
X  	if(!strncmp(term, "5620", 4))
X  		flags.nonull = 1;	/* this should be a termcap flag */
X  	if(tgetent(tptr, term) < 1)
X  		error("Unknown terminal type: %s.", term);
X! 	if(pc = Tgetstr("pc"))
X  		PC = *pc;
X  #ifdef TERMINFO
X! 	if(!(BC = Tgetstr("le"))) {	
X  #else
X! 	if(!(BC = Tgetstr("bc"))) {	
X  #endif
X  #if !defined(MINIMAL_TERM) && !defined(HISX)
X  		if(!tgetflag("bs"))
X***************
X*** 113,159 ****
X  #ifdef MINIMAL_TERM
X  	HO = NULL;
X  #else
X! 	HO = tgetstr("ho", &tbufptr);
X  #endif
X  	CO = tgetnum("co");
X  	LI = tgetnum("li");
X! 	if(CO < COLNO || LI < ROWNO+2)
X  		setclipped();
X! 	if(!(CL = tgetstr("cl", &tbufptr)))
X  		error("Hack needs CL.");
X! 	ND = tgetstr("nd", &tbufptr);
X  	if(tgetflag("os"))
X  		error("Hack can't have OS.");
X! 	CE = tgetstr("ce", &tbufptr);
X! 	UP = tgetstr("up", &tbufptr);
X  	/* It seems that xd is no longer supported, and we should use
X  	   a linefeed instead; unfortunately this requires resetting
X  	   CRMOD, and many output routines will have to be modified
X  	   slightly. Let's leave that till the next release. */
X! 	XD = tgetstr("xd", &tbufptr);
X! /* not: 		XD = tgetstr("do", &tbufptr); */
X! 	if(!(CM = tgetstr("cm", &tbufptr))) {
X  		if(!UP && !HO)
X  			error("Hack needs CM or UP or HO.");
X  		Printf("Playing hack on terminals without cm is suspect...\n");
X  		getret();
X  	}
X! 	SO = tgetstr("so", &tbufptr);
X! 	SE = tgetstr("se", &tbufptr);
X! 	US = tgetstr("us", &tbufptr);
X! 	UE = tgetstr("ue", &tbufptr);
X  	SG = tgetnum("sg");	/* -1: not fnd; else # of spaces left by so */
X  	if(!SO || !SE || (SG > 0)) SO = SE = US = UE = "";
X! 	TI = tgetstr("ti", &tbufptr);
X! 	TE = tgetstr("te", &tbufptr);
X  	VS = VE = "";
X  #if 0
X! 	MB = tgetstr("mb", &tbufptr);	/* blink */
X! 	MD = tgetstr("md", &tbufptr);	/* boldface */
X! 	MH = tgetstr("mh", &tbufptr);	/* dim */
X  #endif
X! 	MR = tgetstr("mr", &tbufptr);	/* reverse */
X! 	ME = tgetstr("me", &tbufptr);
X  
X  	/* Get rid of padding numbers for HI and HE.  Hope they
X  	 * aren't really needed!!!  HI and HE are ouputted to the
X--- 133,179 ----
X  #ifdef MINIMAL_TERM
X  	HO = NULL;
X  #else
X! 	HO = Tgetstr("ho");
X  #endif
X  	CO = tgetnum("co");
X  	LI = tgetnum("li");
X! 	if(CO < COLNO || LI < ROWNO+3)
X  		setclipped();
X! 	if(!(CL = Tgetstr("cl")))
X  		error("Hack needs CL.");
X! 	ND = Tgetstr("nd");
X  	if(tgetflag("os"))
X  		error("Hack can't have OS.");
X! 	CE = Tgetstr("ce");
X! 	UP = Tgetstr("up");
X  	/* It seems that xd is no longer supported, and we should use
X  	   a linefeed instead; unfortunately this requires resetting
X  	   CRMOD, and many output routines will have to be modified
X  	   slightly. Let's leave that till the next release. */
X! 	XD = Tgetstr("xd");
X! /* not: 		XD = Tgetstr("do"); */
X! 	if(!(CM = Tgetstr("cm"))) {
X  		if(!UP && !HO)
X  			error("Hack needs CM or UP or HO.");
X  		Printf("Playing hack on terminals without cm is suspect...\n");
X  		getret();
X  	}
X! 	SO = Tgetstr("so");
X! 	SE = Tgetstr("se");
X! 	US = Tgetstr("us");
X! 	UE = Tgetstr("ue");
X  	SG = tgetnum("sg");	/* -1: not fnd; else # of spaces left by so */
X  	if(!SO || !SE || (SG > 0)) SO = SE = US = UE = "";
X! 	TI = Tgetstr("ti");
X! 	TE = Tgetstr("te");
X  	VS = VE = "";
X  #if 0
X! 	MB = Tgetstr("mb");	/* blink */
X! 	MD = Tgetstr("md");	/* boldface */
X! 	MH = Tgetstr("mh");	/* dim */
X  #endif
X! 	MR = Tgetstr("mr");	/* reverse */
X! 	ME = Tgetstr("me");
X  
X  	/* Get rid of padding numbers for HI and HE.  Hope they
X  	 * aren't really needed!!!  HI and HE are ouputted to the
X***************
X*** 168,185 ****
X  	    i = 0;
X  	    while(isdigit(SE[i])) i++;
X  	    Strcpy(HE, &SE[i]);
X! 	AS = tgetstr("as", &tbufptr);
X! 	AE = tgetstr("ae", &tbufptr);
X! 	CD = tgetstr("cd", &tbufptr);
X! # ifdef ANSI_DEFAULT
X! 	}
X! # endif
X  	set_whole_screen();		/* uses LI and CD */
X  	if(tbufptr-tbuf > sizeof(tbuf)) error("TERMCAP entry too big...\n");
X  	free((genericptr_t)tptr);
X! #ifdef MSDOSCOLOR
X  	init_hilite();
X! #endif
X  #endif /* TOS /* */
X  }
X  
X--- 188,202 ----
X  	    i = 0;
X  	    while(isdigit(SE[i])) i++;
X  	    Strcpy(HE, &SE[i]);
X! 	AS = Tgetstr("as");
X! 	AE = Tgetstr("ae");
X! 	CD = Tgetstr("cd");
X  	set_whole_screen();		/* uses LI and CD */
X  	if(tbufptr-tbuf > sizeof(tbuf)) error("TERMCAP entry too big...\n");
X  	free((genericptr_t)tptr);
X! # ifdef MSDOSCOLOR
X  	init_hilite();
X! # endif
X  #endif /* TOS /* */
X  }
X  
X*** src/Old/topten.c	Mon Jul 31 14:46:14 1989
X--- src/topten.c	Sat Jul 29 21:26:29 1989
X***************
X*** 6,12 ****
X  #define MONATTK_H
X  #include "hack.h"
X  
X! #include <errno.h>      /* George Barbanis */
X  
X  static char *itoa P((int)), *ordin P((int));
X  static void outheader();
X--- 6,15 ----
X  #define MONATTK_H
X  #include "hack.h"
X  
X! #include <errno.h>	/* George Barbanis */
X! #ifdef NO_FILE_LINKS
X! #include <fcntl.h>	/* Ralf Brown */
X! #endif
X  
X  static char *itoa P((int)), *ordin P((int));
X  static void outheader();
X***************
X*** 42,48 ****
X  	char *recfile = RECORD;
X  #ifdef UNIX
X  	char *reclock = "record_lock";
X! #endif
X  	int sleepct = 300;
X  	FILE *rfile;
X  	register int flg = 0;
X--- 45,54 ----
X  	char *recfile = RECORD;
X  #ifdef UNIX
X  	char *reclock = "record_lock";
X! # ifdef NO_FILE_LINKS
X! 	int lockfd ;
X! # endif
X! #endif /* UNIX */
X  	int sleepct = 300;
X  	FILE *rfile;
X  	register int flg = 0;
X***************
X*** 49,58 ****
X  #ifdef LOGFILE
X  	char *lgfile = LOGFILE;
X  	FILE *lfile;
X! #ifdef UNIX
X  	char *loglock = "logfile_lock";
X  	int sleeplgct = 30;
X! #endif /* UNIX */
X  #endif /* LOGFILE */
X  
X  #ifdef MSDOS
X--- 55,64 ----
X  #ifdef LOGFILE
X  	char *lgfile = LOGFILE;
X  	FILE *lfile;
X! # ifdef UNIX
X  	char *loglock = "logfile_lock";
X  	int sleeplgct = 30;
X! # endif /* UNIX */
X  #endif /* LOGFILE */
X  
X  #ifdef MSDOS
X***************
X*** 62,68 ****
X--- 68,83 ----
X  #endif
X  
X  #ifdef UNIX
X+ # ifdef NO_FILE_LINKS
X+ 	reclock = (char *)alloc(sizeof(LOCKDIR)+1+strlen(recfile)+7);
X+ 	Strcpy(reclock,LOCKDIR) ;
X+ 	Strcat(reclock,"/") ;
X+ 	Strcat(reclock,recfile) ;
X+ 	Strcat(reclock,"_lock") ;
X+ 	while ((lockfd = open(reclock,O_RDWR|O_CREAT|O_EXCL,0666)) == -1) {
X+ # else
X  	while(link(recfile, reclock) == -1) {
X+ # endif /* NO_FILE_LINKS */
X  		HUP perror(reclock);
X  		if(!sleepct--) {
X  			HUP (void) puts("I give up.  Sorry.");
X***************
X*** 72,87 ****
X  		HUP Printf("Waiting for access to record file. (%d)\n",
X  			sleepct);
X  		HUP (void) fflush(stdout);
X! #if defined(SYSV) || defined(ULTRIX)
X  		(void)
X! #endif
X  		    sleep(1);
X  	}
X! #endif
X  	if(!(rfile = fopen(recfile,"r"))){
X  		HUP (void) puts("Cannot open record file!");
X  		goto unlock;
X  	}
X  	HUP (void) putchar('\n');
X  
X  	/* create a new 'topten' entry */
X--- 87,105 ----
X  		HUP Printf("Waiting for access to record file. (%d)\n",
X  			sleepct);
X  		HUP (void) fflush(stdout);
X! # if defined(SYSV) || defined(ULTRIX)
X  		(void)
X! # endif
X  		    sleep(1);
X  	}
X! #endif /* UNIX */
X  	if(!(rfile = fopen(recfile,"r"))){
X  		HUP (void) puts("Cannot open record file!");
X  		goto unlock;
X  	}
X+ #ifdef NO_FILE_LINKS
X+ 	(void) close(lockfd) ;
X+ #endif
X  	HUP (void) putchar('\n');
X  
X  	/* create a new 'topten' entry */
X***************
X*** 103,110 ****
X  	/* assure minimum number of points */
X  	if(t0->points < POINTSMIN) t0->points = 0;
X  #ifdef LOGFILE		/* used for debugging (who dies of what, where) */
X! #ifdef UNIX
X  	while(link(lgfile, loglock) == -1) {
X  		extern int errno;
X  
X  		if (errno == ENOENT) /* If no such file, do not keep log */
X--- 121,137 ----
X  	/* assure minimum number of points */
X  	if(t0->points < POINTSMIN) t0->points = 0;
X  #ifdef LOGFILE		/* used for debugging (who dies of what, where) */
X! # ifdef UNIX
X! #  ifdef NO_FILE_LINKS
X! 	loglock = (char *)alloc(sizeof(LOCKDIR)+1+strlen(lgfile)+6);
X! 	Strcpy(loglock,LOCKDIR) ;
X! 	Strcat(loglock,"/") ;
X! 	Strcat(loglock,lgfile) ;
X! 	Strcat(loglock,"_lock") ;
X! 	while ((lockfd = open(loglock,O_RDWR|O_CREAT|O_EXCL,0666)) == -1) {
X! #  else
X  	while(link(lgfile, loglock) == -1) {
X+ #  endif /* NO_FILE_LINKS */
X  		extern int errno;
X  
X  		if (errno == ENOENT) /* If no such file, do not keep log */
X***************
X*** 118,129 ****
X  		HUP Printf("Waiting for access to log file. (%d)\n",
X   			sleeplgct);
X  		HUP (void) fflush(stdout);
X! #if defined(SYSV) || defined(ULTRIX)
X  		(void)
X! #endif
X  		    sleep(1);
X  	}
X! #endif /* UNIX */
X  	if(!(lfile = fopen(lgfile,"a"))){
X  		HUP (void) puts("Cannot open log file!");
X  		goto lgend;
X--- 145,156 ----
X  		HUP Printf("Waiting for access to log file. (%d)\n",
X   			sleeplgct);
X  		HUP (void) fflush(stdout);
X! #  if defined(SYSV) || defined(ULTRIX)
X  		(void)
X! #  endif
X  		    sleep(1);
X  	}
X! # endif /* UNIX */
X  	if(!(lfile = fopen(lgfile,"a"))){
X  		HUP (void) puts("Cannot open log file!");
X  		goto lgend;
X***************
X*** 134,143 ****
X  	    t0->hp, t0->maxhp, t0->points,
X  	    t0->plchar, t0->sex, t0->name, t0->death);
X  	(void) fclose(lfile);
X! #ifdef UNIX
X  	(void) unlink(loglock);
X! #endif /* UNIX */
X        lgend:;
X  #endif /* LOGFILE */
X  
X  	t1 = tt_head = newttentry();
X--- 161,173 ----
X  	    t0->hp, t0->maxhp, t0->points,
X  	    t0->plchar, t0->sex, t0->name, t0->death);
X  	(void) fclose(lfile);
X! # ifdef UNIX
X  	(void) unlink(loglock);
X! # endif /* UNIX */
X        lgend:;
X+ # ifdef NO_FILE_LINKS
X+ 	(void) close(lockfd) ;
X+ # endif
X  #endif /* LOGFILE */
X  
X  	t1 = tt_head = newttentry();
X***************
X*** 144,150 ****
X  	tprev = 0;
X  	/* rank0: -1 undefined, 0 not_on_list, n n_th on list */
X  	for(rank = 1; ; ) {
X! #ifdef TOS
X  	    char k1[2],k2[2];
X  	    if(fscanf(rfile, "%6s %d %d %d %d %d %ld %1s%1s %s %s]",
X  #else
X--- 174,180 ----
X  	tprev = 0;
X  	/* rank0: -1 undefined, 0 not_on_list, n n_th on list */
X  	for(rank = 1; ; ) {
X! #ifdef OLD_TOS
X  	    char k1[2],k2[2];
X  	    if(fscanf(rfile, "%6s %d %d %d %d %d %ld %1s%1s %s %s]",
X  #else
X***************
X*** 153,159 ****
X  		t1->date, &t1->uid,
X  		&t1->level, &t1->maxlvl,
X  		&t1->hp, &t1->maxhp, &t1->points,
X! #ifdef TOS
X  		k1, k2,
X  #else
X  		&t1->plchar, &t1->sex,
X--- 183,189 ----
X  		t1->date, &t1->uid,
X  		&t1->level, &t1->maxlvl,
X  		&t1->hp, &t1->maxhp, &t1->points,
X! #ifdef OLD_TOS
X  		k1, k2,
X  #else
X  		&t1->plchar, &t1->sex,
X***************
X*** 161,167 ****
X  		t1->name, t1->death) != 11 || t1->points < POINTSMIN)
X  			t1->points = 0;
X  
X! #ifdef TOS
X  	    t1->plchar=k1[0];
X  	    t1->sex=k2[0];
X  #endif
X--- 191,197 ----
X  		t1->name, t1->death) != 11 || t1->points < POINTSMIN)
X  			t1->points = 0;
X  
X! #ifdef OLD_TOS
X  	    t1->plchar=k1[0];
X  	    t1->sex=k2[0];
X  #endif
X***************
X*** 259,265 ****
X  	(void) fclose(rfile);
X  unlock:	;
X  #ifdef UNIX
X! 	(void) unlink(reclock);
X  #endif
X  }
X  
X--- 289,299 ----
X  	(void) fclose(rfile);
X  unlock:	;
X  #ifdef UNIX
X! # ifdef NO_FILE_LINKS
X! 	(void) close(lockfd) ;
X! # endif
X! 	if (unlink(reclock) < 0)
X! 		Printf("Can't unlink %s\n",reclock) ;
X  #endif
X  }
X  
X***************
X*** 330,335 ****
X--- 364,370 ----
X  	if(iskilled) Sprintf(eos(linebuf), " by %s%s",
X  	  (!strncmp(t1->death, "trick", 5) || !strncmp(t1->death, "the ", 4)
X  	   || !strncmp(t1->death, "Mr. ", 4) || !strncmp(t1->death, "Ms. ", 4)
X+ 	   || !strncmp(eos(t1->death)-4, "tion", 4)
X  	   ) ? "" :
X  	  index(vowels,*t1->death) ? "an " : "a ",
X  	  t1->death);
X***************
X*** 463,469 ****
X  
X  	t1 = tt_head = newttentry();
X  	for(rank = 1; ; rank++) {
X! #ifdef TOS
X  	  char k1[2], k2[2];
X  	  if(fscanf(rfile, "%6s %d %d %d %d %d %ld %1s%1s %s %s]",
X  #else
X--- 498,504 ----
X  
X  	t1 = tt_head = newttentry();
X  	for(rank = 1; ; rank++) {
X! #ifdef OLD_TOS
X  	  char k1[2], k2[2];
X  	  if(fscanf(rfile, "%6s %d %d %d %d %d %ld %1s%1s %s %s]",
X  #else
X***************
X*** 472,478 ****
X  		t1->date, &t1->uid,
X  		&t1->level, &t1->maxlvl,
X  		&t1->hp, &t1->maxhp, &t1->points,
X! #ifdef TOS
X  		k1, k2,
X  #else
X  		&t1->plchar, &t1->sex,
X--- 507,513 ----
X  		t1->date, &t1->uid,
X  		&t1->level, &t1->maxlvl,
X  		&t1->hp, &t1->maxhp, &t1->points,
X! #ifdef OLD_TOS
X  		k1, k2,
X  #else
X  		&t1->plchar, &t1->sex,
X***************
X*** 480,486 ****
X  		t1->name, t1->death) != 11)
X  			t1->points = 0;
X  	  if(t1->points == 0) break;
X! #ifdef TOS
X  	  t1->plchar=k1[0];
X  	  t1->sex=k2[0];
X  #endif
X--- 515,521 ----
X  		t1->name, t1->death) != 11)
X  			t1->points = 0;
X  	  if(t1->points == 0) break;
X! #ifdef OLD_TOS
X  	  t1->plchar=k1[0];
X  	  t1->sex=k2[0];
X  #endif
X***************
X*** 609,615 ****
X  	rank = rnd(10);
X  pickentry:
X  	for(i = rank; i; i--) {
X! #ifdef TOS
X  	  char k1[2], k2[2];
X  	  if(fscanf(rfile, "%6s %d %d %d %d %d %ld %1s%1s %s %s]",
X  #else
X--- 644,650 ----
X  	rank = rnd(10);
X  pickentry:
X  	for(i = rank; i; i--) {
X! #ifdef OLD_TOS
X  	  char k1[2], k2[2];
X  	  if(fscanf(rfile, "%6s %d %d %d %d %d %ld %1s%1s %s %s]",
X  #else
X***************
X*** 618,624 ****
X  		tt->date, &tt->uid,
X  		&tt->level, &tt->maxlvl,
X  		&tt->hp, &tt->maxhp, &tt->points,
X! #ifdef TOS
X  		k1, k2,
X  #else
X  		&tt->plchar, &tt->sex,
X--- 653,659 ----
X  		tt->date, &tt->uid,
X  		&tt->level, &tt->maxlvl,
X  		&tt->hp, &tt->maxhp, &tt->points,
X! #ifdef OLD_TOS
X  		k1, k2,
X  #else
X  		&tt->plchar, &tt->sex,
X***************
X*** 626,632 ****
X  		tt->name, tt->death) != 11)
X  			tt->points = 0;
X  	  if(tt->points == 0) break;
X! #ifdef TOS
X  	  tt->plchar=k1[0];
X  	  tt->sex=k2[0];
X  #endif
X--- 661,667 ----
X  		tt->name, tt->death) != 11)
X  			tt->points = 0;
X  	  if(tt->points == 0) break;
X! #ifdef OLD_TOS
X  	  tt->plchar=k1[0];
X  	  tt->sex=k2[0];
X  #endif
X*** src/Old/trap.c	Wed Jul 19 04:10:30 1989
X--- src/trap.c	Mon Jul 31 21:56:52 1989
X***************
X*** 295,301
X  		    } else {
X  			(void) mksobj_at(DART, u.ux, u.uy);
X  			fobj->quan = 1;
X! 			fobj->opoisoned = 1;
X  			fobj->owt = weight(fobj);
X  		    }
X  		    break;
X
X--- 295,301 -----
X  		    } else {
X  			(void) mksobj_at(DART, u.ux, u.uy);
X  			fobj->quan = 1;
X! 			if(!rn2(6)) fobj->opoisoned = 1;
X  			fobj->owt = weight(fobj);
X  		    }
X  		    break;
X***************
X*** 689,694
X  		case DART_TRAP:
X  			otmp = mksobj(DART, FALSE);
X  			otmp->quan = 1;
X  			otmp->owt = weight(otmp);
X  			if(thitm(7, mtmp, otmp, 0)) trapkilled = TRUE;
X  			break;
X
X--- 689,695 -----
X  		case DART_TRAP:
X  			otmp = mksobj(DART, FALSE);
X  			otmp->quan = 1;
X+ 			if (!rn2(6)) otmp->opoisoned = 1;
X  			otmp->owt = weight(otmp);
X  			if(thitm(7, mtmp, otmp, 0)) trapkilled = TRUE;
X  			break;
X***************
X*** 943,949
X  		u.uundetected = 0;
X  	if (u.usym == S_MIMIC_DEF) u.usym = S_MIMIC;
X  #endif
X- 	setsee();
X  	if(Punished) placebc(1);
X  	if(u.uswallow){
X  		u.uswldtim = u.uswallow = 0;
X
X--- 944,949 -----
X  		u.uundetected = 0;
X  	if (u.usym == S_MIMIC_DEF) u.usym = S_MIMIC;
X  #endif
X  	if(Punished) placebc(1);
X  	if(u.uswallow){
X  		u.uswldtim = u.uswallow = 0;
X***************
X*** 949,954
X  		u.uswldtim = u.uswallow = 0;
X  		docrt();
X  	}
X  	nomul(0);
X  	spoteffects();
X  }
X
X--- 949,955 -----
X  		u.uswldtim = u.uswallow = 0;
X  		docrt();
X  	}
X+ 	setsee();
X  	nomul(0);
X  	spoteffects();
X  }
X***************
X*** 1621,1626
X  			if (dam < 1) dam = 1;
X  		}
X  		if ((mon->mhp -= dam) <= 0) {
X  			if (cansee(mon->mx, mon->my))
X  				pline("%s is killed!", Monnam(mon));
X  			else if (mon->mtame)
X
X--- 1622,1630 -----
X  			if (dam < 1) dam = 1;
X  		}
X  		if ((mon->mhp -= dam) <= 0) {
X+ 			int xx = mon->mx;
X+ 			int yy = mon->my;
X+ 
X  			if (cansee(mon->mx, mon->my))
X  				pline("%s is killed!", Monnam(mon));
X  			else if (mon->mtame)
X***************
X*** 1626,1631
X  			else if (mon->mtame)
X  	You("have a sad feeling for a moment, then it passes.");
X  			mondied(mon);
X  			trapkilled = TRUE;
X  		}
X  	}
X
X--- 1630,1636 -----
X  			else if (mon->mtame)
X  	You("have a sad feeling for a moment, then it passes.");
X  			mondied(mon);
X+ 			newsym(xx, yy);
X  			trapkilled = TRUE;
X  		}
X  	}
X*** src/Old/uhitm.c	Mon Jul 31 14:50:00 1989
X--- src/uhitm.c	Mon Jul 31 09:20:24 1989
X***************
X*** 11,17 ****
X  #ifdef POLYSELF
X  static boolean hmonas();
X  #endif
X- static int passive();
X  
X  #ifdef WORM
X  extern boolean notonhead;
X--- 11,16 ----
X***************
X*** 26,32 ****
X  
X  	mm.x = mon->mx;
X  	mm.y = mon->my;
X! 	enexto(&mm, mm.x, mm.y);
X  	if (levl[mm.x][mm.y].mmask || mon->mhp <= 1) return (struct monst *)0;
X  	m2 = newmonst(0);
X  	*m2 = *mon;			/* copy condition of old monster */
X--- 25,31 ----
X  
X  	mm.x = mon->mx;
X  	mm.y = mon->my;
X! 	enexto(&mm, mm.x, mm.y, mon->data);
X  	if (levl[mm.x][mm.y].mmask || mon->mhp <= 1) return (struct monst *)0;
X  	m2 = newmonst(0);
X  	*m2 = *mon;			/* copy condition of old monster */
X***************
X*** 301,309 ****
X  register int thrown;
X  {
X  	register int tmp;
X! 	boolean hittxt = FALSE;
X  	boolean get_dmg_bonus = TRUE;
X! 	boolean ispoisoned = FALSE;
X  
X  	wakeup(mon);
X  	if(!obj) {
X--- 300,308 ----
X  register int thrown;
X  {
X  	register int tmp;
X! 	boolean hittxt = FALSE, destroyed = FALSE;
X  	boolean get_dmg_bonus = TRUE;
X! 	boolean ispoisoned = FALSE, needpoismsg = FALSE;
X  
X  	wakeup(mon);
X  	if(!obj) {
X***************
X*** 318,343 ****
X  			mon_nam(mon), makeplural(body_part(HAND)));
X  		You("turn to stone...");
X  		done_in_by(mon);
X  	    }
X  	} else {
X  	    if(obj->olet == WEAPON_SYM || obj->otyp == PICK_AXE ||
X  	       obj->olet == ROCK_SYM) {
X  
X- 		if(mon->data == &mons[PM_RUST_MONSTER] && obj == uwep &&
X- 			objects[obj->otyp].oc_material == METAL &&
X- 			obj->spe > -2) {
X- 		    if(obj->rustfree) {
X- 			pline("The rust on your %s vanishes instantly!",
X- 			      is_sword(obj) ? "sword" : "weapon");
X- 		    } else if(obj->blessed && rnl(4))
X- 			pline("Somehow your %s is not affected!",
X- 			      is_sword(obj) ? "sword" : "weapon");
X- 		    else {
X- 		    	Your("%s!", aobjnam(uwep, "corrode"));
X- 		    	uwep->spe--;
X- 		    }
X- 		}
X- 
X  		if(obj == uwep && (obj->otyp > VOULGE || obj->otyp < BOOMERANG)
X  				&& obj->otyp != PICK_AXE)
X  		    tmp = rnd(2);
X--- 317,328 ----
X  			mon_nam(mon), makeplural(body_part(HAND)));
X  		You("turn to stone...");
X  		done_in_by(mon);
X+ 		hittxt = TRUE; /* maybe lifesaved */
X  	    }
X  	} else {
X  	    if(obj->olet == WEAPON_SYM || obj->otyp == PICK_AXE ||
X  	       obj->olet == ROCK_SYM) {
X  
X  		if(obj == uwep && (obj->otyp > VOULGE || obj->otyp < BOOMERANG)
X  				&& obj->otyp != PICK_AXE)
X  		    tmp = rnd(2);
X***************
X*** 513,524 ****
X  	}
X   */
X  	if (ispoisoned) {
X- 	    /* OK to reference obj because ispoisoned can only be set
X- 	     * when obj is a throwing weapon */
X- 	    hit(xname(obj), mon, exclam(tmp));
X- 	    hittxt = TRUE;
X  	    if(resists_poison(mon->data))
X! 		kludge("The poison doesn't seem to affect %s.", mon_nam(mon));
X  	    else if (rn2(10))
X  		tmp += rnd(6);
X  	    else {
X--- 498,505 ----
X  	}
X   */
X  	if (ispoisoned) {
X  	    if(resists_poison(mon->data))
X! 		needpoismsg = TRUE;
X  	    else if (rn2(10))
X  		tmp += rnd(6);
X  	    else {
X***************
X*** 530,539 ****
X  	if(tmp < 1) tmp = 1;
X  
X  	mon->mhp -= tmp;
X! 	if(mon->mhp < 1) {
X! 		killed(mon);
X! 		return(FALSE);
X! 	}
X  	if(mon->mtame && (!mon->mflee || mon->mfleetim)) {
X  #ifdef SOUNDS
X  		if (rn2(8)) yelp(mon);
X--- 511,518 ----
X  	if(tmp < 1) tmp = 1;
X  
X  	mon->mhp -= tmp;
X! 	if(mon->mhp < 1)
X! 		destroyed = TRUE;
X  	if(mon->mtame && (!mon->mflee || mon->mfleetim)) {
X  #ifdef SOUNDS
X  		if (rn2(8)) yelp(mon);
X***************
X*** 544,552 ****
X  		mon->mfleetim += 10*rnd(tmp);
X  	}
X  	if((mon->data == &mons[PM_BLACK_PUDDING] ||
X! 		   mon->data == &mons[PM_BROWN_PUDDING]) && uwep &&
X! 		   uwep == obj && objects[obj->otyp].oc_material == METAL
X! 		   && mon->mhp > 1 && !thrown && !mon->mcan) {
X  
X  		if (clone_mon(mon)) {
X  			pline("%s divides as you hit it!", Monnam(mon));
X--- 523,532 ----
X  		mon->mfleetim += 10*rnd(tmp);
X  	}
X  	if((mon->data == &mons[PM_BLACK_PUDDING] ||
X! 		   mon->data == &mons[PM_BROWN_PUDDING]) && obj &&
X! 		   obj == uwep && objects[obj->otyp].oc_material == METAL
X! 		   && mon->mhp > 1 && !thrown && !mon->mcan
X! 		   /* && !destroyed  -- guaranteed by mhp > 1 */ ) {
X  
X  		if (clone_mon(mon)) {
X  			pline("%s divides as you hit it!", Monnam(mon));
X***************
X*** 554,560 ****
X  		}
X  	}
X  
X! 	if(!hittxt) {
X  		if(thrown)
X  		    /* thrown => obj exists */
X  		    hit(xname(obj), mon, exclam(tmp) );
X--- 534,540 ----
X  		}
X  	}
X  
X! 	if(!hittxt && !destroyed) {
X  		if(thrown)
X  		    /* thrown => obj exists */
X  		    hit(xname(obj), mon, exclam(tmp) );
X***************
X*** 562,568 ****
X  		else	You("hit %s%s", mon_nam(mon), exclam(tmp));
X  	}
X  
X! 	if(u.umconf && !thrown) {
X  		if(!Blind) {
X  			Your("%s stop glowing %s.",
X  			makeplural(body_part(HAND)),
X--- 542,553 ----
X  		else	You("hit %s%s", mon_nam(mon), exclam(tmp));
X  	}
X  
X! 	if (needpoismsg)
X! 		kludge("The poison doesn't seem to affect %s.", mon_nam(mon));
X! 
X! 	if (destroyed)
X! 		killed(mon);	/* takes care of messages */
X! 	else if(u.umconf && !thrown) {
X  		if(!Blind) {
X  			Your("%s stop glowing %s.",
X  			makeplural(body_part(HAND)),
X***************
X*** 574,580 ****
X  			pline("%s appears confused.", Monnam(mon));
X  		u.umconf = 0;
X  	}
X! 	return(TRUE);	/* mon still alive */
X  }
X  
X  #ifdef POLYSELF
X--- 559,581 ----
X  			pline("%s appears confused.", Monnam(mon));
X  		u.umconf = 0;
X  	}
X! 
X! 	if(mon->data == &mons[PM_RUST_MONSTER] && obj && obj == uwep &&
X! 		objects[obj->otyp].oc_material == METAL &&
X! 		obj->olet == WEAPON_SYM && obj->spe > -2) {
X! 	    if(obj->rustfree) {
X! 		pline("The rust on your %s vanishes instantly!",
X! 		      is_sword(obj) ? "sword" : "weapon");
X! 	    } else if(obj->blessed && rnl(4))
X! 		pline("Somehow your %s is not affected!",
X! 		      is_sword(obj) ? "sword" : "weapon");
X! 	    else {
X! 		Your("%s!", aobjnam(obj, "corrode"));
X! 		obj->spe--;
X! 	    }
X! 	}
X! 
X! 	return(destroyed ? FALSE : TRUE);
X  }
X  
X  #ifdef POLYSELF
X***************
X*** 911,922 ****
X  		kludge("You engulf %s!", mon_nam(mdef));
X  		switch(mattk->adtyp) {
X  		    case AD_DGST:
X! 			u.uhunger += 20*mdef->mhpmax;
X  			newuhs(FALSE);
X  			xkilled(mdef,2);
X  			Sprintf(msgbuf, "You totally digest %s.",
X  					Blind ? "it" : mon_nam(mdef));
X! 			if ((tmp = mdef->mhpmax/5)) {
X  			    kludge("You digest %s.", mon_nam(mdef));
X  			    nomul(-tmp);
X  			    nomovemsg = msgbuf;
X--- 912,923 ----
X  		kludge("You engulf %s!", mon_nam(mdef));
X  		switch(mattk->adtyp) {
X  		    case AD_DGST:
X! 			u.uhunger += mdef->data->cnutrit;
X  			newuhs(FALSE);
X  			xkilled(mdef,2);
X  			Sprintf(msgbuf, "You totally digest %s.",
X  					Blind ? "it" : mon_nam(mdef));
X! 			if (tmp = 3 + (mdef->data->cwt >> 2)) {
X  			    kludge("You digest %s.", mon_nam(mdef));
X  			    nomul(-tmp);
X  			    nomovemsg = msgbuf;
X***************
X*** 1170,1176 ****
X  
X  /*	Special (passive) attacks on you by monsters done here.		*/
X  
X! static int
X  passive(mon, mhit, malive)
X  register struct monst *mon;
X  register boolean mhit;
X--- 1171,1177 ----
X  
X  /*	Special (passive) attacks on you by monsters done here.		*/
X  
X! int
X  passive(mon, mhit, malive)
X  register struct monst *mon;
X  register boolean mhit;
X*** src/Old/unixmain.c	Mon Jul 31 14:51:12 1989
X--- src/unixmain.c	Sun Jul 30 18:19:38 1989
X***************
X*** 188,198 ****
X  		(void) signal(SIGQUIT,SIG_IGN);
X  		(void) signal(SIGINT,SIG_IGN);
X  		if(!locknum)
X! 			Strcpy(lock,plname);
X  		getlock();	/* sets lock if locknum != 0 */
X  #ifdef WIZARD
X  	} else
X! 		Strcpy(lock,plname);
X  #endif /* WIZARD /**/
X  	setftty();
X  
X--- 188,198 ----
X  		(void) signal(SIGQUIT,SIG_IGN);
X  		(void) signal(SIGINT,SIG_IGN);
X  		if(!locknum)
X! 			Sprintf(lock, "%d%s", getuid(), plname);
X  		getlock();	/* sets lock if locknum != 0 */
X  #ifdef WIZARD
X  	} else
X! 		Sprintf(lock, "%d%s", getuid(), plname);
X  #endif /* WIZARD /**/
X  	setftty();
X  
X*** src/Old/unixunix.c	Mon Jul 31 14:52:10 1989
X--- src/unixunix.c	Sat Jul 29 21:26:29 1989
X***************
X*** 15,24 ****
X--- 15,28 ----
X  
X  /* block some unused #defines to avoid overloading some cpp's */
X  #define MONATTK_H
X+ #define MONFLAG_H
X  #include "hack.h"	/* mainly for index() which depends on BSD */
X  
X  #include <errno.h>
X  #include <sys/stat.h>
X+ #ifdef NO_FILE_LINKS
X+ #include <fcntl.h>
X+ #endif
X  
X  void
X  setrandom()
X***************
X*** 215,220 ****
X--- 219,228 ----
X  {
X  	extern int errno;
X  	register int i = 0, fd;
X+ #ifdef NO_FILE_LINKS
X+ 	int hlockfd ;
X+ 	int sleepct = 20 ;
X+ #endif
X  
X  #ifdef HARD
X  	/* idea from rpick%ucqais@uccba.uc.edu
X***************
X*** 230,235 ****
X--- 238,261 ----
X  	(void) fflush(stdout);
X  
X  	/* we ignore QUIT and INT at this point */
X+ #ifdef NO_FILE_LINKS
X+ 	while ((hlockfd = open(LLOCK,O_RDONLY|O_CREAT|O_EXCL,0644)) == -1) {
X+ 	    if (--sleepct) {
X+ 		Printf( "Lock file in use.  %d retries left.\n",sleepct);
X+ 		(void) fflush(stdout);
X+ # if defined(SYSV) || defined(ULTRIX)
X+ 		(void)
X+ # endif
X+ 		    sleep(1);
X+ 	    } else {
X+ 		Printf("I give up!  Try again later.\n");
X+ 		getret();
X+ 		error("");
X+ 	    }
X+ 	}
X+ 	(void) close(hlockfd);
X+ 
X+ #else	/* NO_FILE_LINKS */
X  	if (link(HLOCK, LLOCK) == -1) {
X  		register int errnosv = errno;
X  
X***************
X*** 252,257 ****
X--- 278,284 ----
X  		error("");
X  		/*NOTREACHED*/
X  	}
X+ #endif /* NO_FILE_LINKS */
X  
X  	regularize(lock);
X  	glo(0);
X*** src/Old/vault.c	Mon Jul 31 14:52:40 1989
X--- src/vault.c	Wed Jul 26 12:01:14 1989
X***************
X*** 101,107 ****
X  
X  	/* make something interesting happen */
X  	if(!(guard = makemon(&mons[PM_GUARD], x, y))) return;
X! 	guard->isgd = guard->mpeaceful = 1;
X  	EGD->gddone = 0;
X  	gdlevel = dlevel;
X  	if(!cansee(guard->mx, guard->my)) {
X--- 101,108 ----
X  
X  	/* make something interesting happen */
X  	if(!(guard = makemon(&mons[PM_GUARD], x, y))) return;
X! 	guard->isgd = 1;
X! 	guard->mpeaceful = 1;
X  	EGD->gddone = 0;
X  	gdlevel = dlevel;
X  	if(!cansee(guard->mx, guard->my)) {
X***************
X*** 177,184 ****
X  		/* seems we found a good place to leave him alone */
X  		EGD->gddone = 1;
X  		if(ACCESSIBLE(typ)) goto newpos;
X! 
X  		crm->typ = (typ == SCORR) ? CORR : DOOR;
X  		if(crm->typ == DOOR) crm->doormask = D_NODOOR;
X  		goto proceed;
X  	    }
X--- 178,191 ----
X  		/* seems we found a good place to leave him alone */
X  		EGD->gddone = 1;
X  		if(ACCESSIBLE(typ)) goto newpos;
X! #ifdef STUPID
X! 		if (typ == SCORR)
X! 		    crm->typ = CORR;
X! 		else
X! 		    crm->typ = DOOR;
X! #else
X  		crm->typ = (typ == SCORR) ? CORR : DOOR;
X+ #endif
X  		if(crm->typ == DOOR) crm->doormask = D_NODOOR;
X  		goto proceed;
X  	    }
X*** src/Old/zap.c	Sat Jul 22 08:19:59 1989
X--- src/zap.c	Mon Jul 31 21:56:58 1989
X***************
X*** 245,250
X  #ifdef SPELLS
X  	case SPE_POLYMORPH:
X  #endif
X  #ifdef MAIL
X  		/* You can't send yourself 100 mail messages and then
X  		 * polymorph them into useful scrolls
X
X--- 245,253 -----
X  #ifdef SPELLS
X  	case SPE_POLYMORPH:
X  #endif
X+ 		/* preserve symbol and quantity */
X+ 		otmp2 = mkobj_at(obj->olet, obj->ox, obj->oy);
X+ 		otmp2->quan = obj->quan;
X  #ifdef MAIL
X  		/* You can't send yourself 100 mail messages and then
X  		 * polymorph them into useful scrolls
X***************
X*** 249,255
X  		/* You can't send yourself 100 mail messages and then
X  		 * polymorph them into useful scrolls
X  		 */
X! 		if (obj->otyp == SCR_MAIL) obj->spe = 1;
X  #endif
X  		/* preserve symbol and quantity */
X  		otmp2 = mkobj_at(obj->olet, obj->ox, obj->oy);
X
X--- 252,261 -----
X  		/* You can't send yourself 100 mail messages and then
X  		 * polymorph them into useful scrolls
X  		 */
X! 		if (obj->otyp == SCR_MAIL) {
X! 			otmp2->otyp = SCR_MAIL;
X! 			obj->spe = 1;
X! 		}
X  #endif
X  		/* keep special fields (including charges on wands) */
X  		if (index(charged_objs, otmp2->olet)) otmp2->spe = obj->spe;
X***************
X*** 251,260
X  		 */
X  		if (obj->otyp == SCR_MAIL) obj->spe = 1;
X  #endif
X- 		/* preserve symbol and quantity */
X- 		otmp2 = mkobj_at(obj->olet, obj->ox, obj->oy);
X- 		otmp2->quan = obj->quan;
X- 
X  		/* keep special fields (including charges on wands) */
X  		if (index(charged_objs, otmp2->olet)) otmp2->spe = obj->spe;
X  
X
X--- 257,262 -----
X  			obj->spe = 1;
X  		}
X  #endif
X  		/* keep special fields (including charges on wands) */
X  		if (index(charged_objs, otmp2->olet)) otmp2->spe = obj->spe;
X  
X***************
X*** 1226,1232
X  #ifdef MSDOSCOLOR
X  	Tmp_at2(-3, (int)(abstype == 1 ? AT_RED :	/* fire */
X  			  abstype == 3 || abstype == 5 ? AT_WHITE :	/* cold/elec */
X! 			  AT_ZAP);
X  #endif
X  	while(range-- > 0) {
X  		sx += dx;
X
X--- 1228,1234 -----
X  #ifdef MSDOSCOLOR
X  	Tmp_at2(-3, (int)(abstype == 1 ? AT_RED :	/* fire */
X  			  abstype == 3 || abstype == 5 ? AT_WHITE :	/* cold/elec */
X! 			  AT_ZAP));
X  #endif
X  	while(range-- > 0) {
X  		sx += dx;
X***************
X*** 1589,1595
X  	do {
X  		tx = rn1(COLNO-3,2);
X  		ty = rn2(ROWNO);
X! 	} while(!goodpos(tx,ty));
X  	obj->ox = tx;
X  	obj->oy = ty;
X  	set_omask(otx,oty);
X
X--- 1591,1597 -----
X  	do {
X  		tx = rn1(COLNO-3,2);
X  		ty = rn2(ROWNO);
X! 	} while(!goodpos(tx,ty,(struct permonst *)0));
X  	obj->ox = tx;
X  	obj->oy = ty;
X  	set_omask(otx,oty);
X***************
X*** 1606,1612
X  {
X  	/* unpobj(obj); */
X  	obj->otyp = ROCK;
X- 	obj->blessed = FALSE;
X  	obj->quan = 7 + rn2(60);
X  	obj->owt = weight(obj);
X  	obj->olet = GEM_SYM;
X
X--- 1608,1613 -----
X  {
X  	/* unpobj(obj); */
X  	obj->otyp = ROCK;
X  	obj->quan = 7 + rn2(60);
X  	obj->owt = weight(obj);
X  	obj->olet = GEM_SYM;
END_OF_FILE
if test 48599 -ne `wc -c <'src4.diff'`; then
    echo shar: \"'src4.diff'\" unpacked with wrong size!
fi
# end of 'src4.diff'
fi
echo shar: End of archive 6 \(of 6\).
cp /dev/null ark6isdone
MISSING=""
for I in 1 2 3 4 5 6 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 6 archives.
    echo "now type ./do_patch.sh"
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
