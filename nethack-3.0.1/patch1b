Path: utzoo!utgpu!jarvis.csri.toronto.edu!rutgers!cs.utexas.edu!uunet!zephyr.ens.tek.com!tekgen!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v07i095:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Patch1b
Message-ID: <4389@tekred.CNA.TEK.COM>
Date: 3 Aug 89 16:57:06 GMT
Sender: nobody@tekred.CNA.TEK.COM
Lines: 1860
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 7, Issue 95
Archive-name: NetHack3/Patch1b
Patch-To: NetHack3: Volume 7, Issue 56-93



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 2 (of 6)."
# Contents:  misc.diff
# Wrapped by billr@saab on Thu Aug  3 09:56:52 1989
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'misc.diff' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'misc.diff'\"
else
echo shar: Extracting \"'misc.diff'\" \(47044 characters\)
sed "s/^X//" >'misc.diff' <<'END_OF_FILE'
XThis is the bundled patches for everything except src.  
X
XThe order of diffs by directories: amiga, auxil, include, others.
X
XThe batches are easily separated by searching for 'dirname/', starting
Xwith amiga (the top directory diffs have no directory prefix).
X
X-------------------------------------Cut-----------------------------------
X*** amiga/Old/amidos.c	Mon Jul 31 13:12:19 1989
X--- amiga/amidos.c	Mon Jul 31 09:55:52 1989
X***************
X*** 484,490 ****
X  	    (void) strncpy(SAVEF, bufp, PATHLEN);
X  	    append_slash(SAVEF);
X  	} else if (!strncmp(buf, "GRAPHICS", 4)) {
X! 	    unsigned int translate[28];   /* MAXPCHARS */
X  	    int  i;
X  
X  	    if ((i = sscanf(bufp,
X--- 484,490 ----
X  	    (void) strncpy(SAVEF, bufp, PATHLEN);
X  	    append_slash(SAVEF);
X  	} else if (!strncmp(buf, "GRAPHICS", 4)) {
X! 	    unsigned int translate[MAXPCHARS+1]; /* for safety */
X  	    int  i;
X  
X  	    if ((i = sscanf(bufp,
X*** auxil/Old/Guidebook.mn	Mon Jul 31 13:16:30 1989
X--- auxil/Guidebook.mn	Sat Jul 29 19:09:48 1989
X***************
X*** 4,10 ****
X  .ds vr "NetHack Version 3.0
X  .ds f0 "\*(vr
X  .ds f1
X! .ds f2 "July 19, 1989
X  .mt
X  A Guide to the Mazes of Menace
X  .au
X--- 4,10 ----
X  .ds vr "NetHack Version 3.0
X  .ds f0 "\*(vr
X  .ds f1
X! .ds f2 "July 22, 1989
X  .mt
X  A Guide to the Mazes of Menace
X  .au
X***************
X*** 44,50 ****
X  them an advantage in arms and armor.
X  .pg
X  \fIHealers\fP are wise in medicine and the apothecary.  They know the
X! herbs and simples that can restore vitality, ease pain, anestheticize,
X  and neutralize
X  poisons; and with their instruments, they can divine a being's state
X  of health or sickness.  Their medical practice earns them quite reasonable
X--- 44,50 ----
X  them an advantage in arms and armor.
X  .pg
X  \fIHealers\fP are wise in medicine and the apothecary.  They know the
X! herbs and simples that can restore vitality, ease pain, anesthetize,
X  and neutralize
X  poisons; and with their instruments, they can divine a being's state
X  of health or sickness.  Their medical practice earns them quite reasonable
X***************
X*** 355,363 ****
X  prefix:  move without picking up any objects.
X  .lp M[yuhjklbn]
X  prefix:  move far, no pickup.
X! .lp "g[yuhjklbn] or <CONTROL->[yuhjklbn]
X  prefix:  move until something interesting is found.
X! .lp G[yuhjklbn]
X  prefix:  same as `g', but forking of corridors is not considered interesting.
X  .lp .
X  rest, do nothing for one turn.
X--- 355,363 ----
X  prefix:  move without picking up any objects.
X  .lp M[yuhjklbn]
X  prefix:  move far, no pickup.
X! .lp "g[yuhjklbn]
X  prefix:  move until something interesting is found.
X! .lp G[yuhjklbn] or <CONTROL->[yuhjklbn]
X  prefix:  same as `g', but forking of corridors is not considered interesting.
X  .lp .
X  rest, do nothing for one turn.
X***************
X*** 734,740 ****
X  .pg
X  You can name one food item after something you like to eat with the
X  .op fruit
X! option.
X  .pg
X  The command to eat food is `e'.
X  .hn 2
X--- 734,740 ----
X  .pg
X  You can name one food item after something you like to eat with the
X  .op fruit
X! option, if your dungeon has it.
X  .pg
X  The command to eat food is `e'.
X  .hn 2
X***************
X*** 836,846 ****
X  .pg
X  You may encounter chests or boxes in your travels.  These can be
X  opened with the ``#loot'' extended command when they are on the floor,
X! or with the `a' (apply) command when you are carrying one.  However,
X! chests are often locked, and require you to either use a key to unlock
X! it, a tool to pick the lock, or to break it open with brute force.
X! Chests are unwieldy objects, and must be set down to be unlocked (by
X! kicking them,
X  using a key or lock picking tool with the `a' (apply) command, or
X  by using a weapon to force the lock with the ``#force'' extended command).
X  .pg
X--- 836,844 ----
X  .pg
X  You may encounter chests or boxes in your travels.  These can be
X  opened with the ``#loot'' extended command when they are on the floor,
X! or with the `a' (apply) command when you are carrying one.
X! Chests are unwieldy objects, and must be set down to be unlocked
X! (which can be accomplished by kicking them,
X  using a key or lock picking tool with the `a' (apply) command, or
X  by using a weapon to force the lock with the ``#force'' extended command).
X  .pg
X***************
X*** 1028,1034 ****
X  .lp sortpack
X  (default on) sort the pack contents by type when displaying inventory.
X  .lp standout
X! (default off) boldface objects, monsters, zaps, and ``\fB--More--\fP''.
X  .lp time\ \ \ \ 
X  (default off) show the elapsed game time in turns on bottom line.
X  .lp tombstone
X--- 1026,1032 ----
X  .lp sortpack
X  (default on) sort the pack contents by type when displaying inventory.
X  .lp standout
X! (default off) boldface monsters and ``\fB--More--\fP''.
X  .lp time\ \ \ \ 
X  (default off) show the elapsed game time in turns on bottom line.
X  .lp tombstone
X***************
X*** 1068,1074 ****
X  .pg
X  NetHack is an intricate and difficult game.  Novices might falter
X  in fear, aware of their ignorance of the means to survive.  Well, fear
X! not.  Your dungeon may come equipped with an "explore" or "discovery"
X  mode, that enables you to keep old save files and cheat death, at the
X  paltry cost of not getting on the high score list.
X  .pg
X--- 1066,1072 ----
X  .pg
X  NetHack is an intricate and difficult game.  Novices might falter
X  in fear, aware of their ignorance of the means to survive.  Well, fear
X! not.  Your dungeon may come equipped with an ``explore'' or ``discovery''
X  mode, that enables you to keep old save files and cheat death, at the
X  paltry cost of not getting on the high score list.
X  .pg
X***************
X*** 1102,1125 ****
X  .ux
X  machines to the Usenet.
X  .pg
X! \fBDon G. Kneller\fP ported Hack 1.0.3 to Microsoft C and MS-DOS,
X! producing PC HACK, of which at least seven versions are recorded (from
X! 1.01e and 1.03g up to 3.6).
X  .pg
X  \fBR. Black\fP ported PC HACK to Lattice C and the Atari 520/1040ST,
X  producing ST Hack 1.03.
X  .pg
X  \fBMike Stephenson\fP merged these various versions back together,
X! incorporating many of the added features, and produced NetHack 1.4.
X! He later coordinated a cast of thousands throughout the Usenet in
X! adding and debugging features, and released NetHack versions 2.2, 2.3,
X! and 3.0.
X  .pg
X  \fBOlaf Siebert\fP ported NetHack 2.3 and 3.0 to the Amiga.
X  .pg
X! The following folks didn't actually re-write the game, or port it to
X! a new machine, but have made significant contributions to the playability of
X! the game:
X  
X  .sd
X  .TS S
X--- 1100,1126 ----
X  .ux
X  machines to the Usenet.
X  .pg
X! \fBDon G. Kneller\fP ported Hack 1.0.3 to Microsoft C and MS-DOS, producing PC
X! HACK 1.01e, added support for DEC Rainbow graphics in version 1.03g, and went
X! on to produce at least four more versions (3.0, 3.2, 3.51, and 3.6).
X  .pg
X  \fBR. Black\fP ported PC HACK to Lattice C and the Atari 520/1040ST,
X  producing ST Hack 1.03.
X  .pg
X  \fBMike Stephenson\fP merged these various versions back together,
X! incorporating many of the added features, and produced NetHack 1.4.  He later
X! coordinated a cast of thousands throughout the Usenet in adding and debugging
X! features, and released NetHack versions 2.2 and 2.3.  Later, he coordinated a
X! major rewrite of the game, heading a team which included Ken Arromdee,
X! Jean-Christophe Collet, Steve Creps, Eric Hendrickson, Izchak Miller, John
X! Rupley, Mike Threepoint, and Janet Walz, to produce NetHack 3.0.
X  .pg
X  \fBOlaf Siebert\fP ported NetHack 2.3 and 3.0 to the Amiga.
X  .pg
X! \fBEric R. Smith\fP ported NetHack 3.0 to the Atari.
X! .pg
X! The following folks have made significant contributions to the playability
X! of the game:
X  
X  .sd
X  .TS S
X***************
X*** 1126,1137 ****
X  center;
X  c c c.
X  Tom Almy	Eric Hendrickson	Izchak Miller
X! Ken Arromdee	Bruce Holloway	Gil Neiger
X  Eric Backus	Richard P. Hughey	Eric S. Raymond
X! John S. Bien	Greg Laskin	John Rupley
X! Ralf Brown	Steve Linhart	Kevin Sweet
X  Jean-Christophe Collet	Roland McGrath	Scott R. Turner
X! Steve Creps	Bruce Mewborne	Janet Walz
X  .TE
X  .ed
X  
X--- 1127,1138 ----
X  center;
X  c c c.
X  Tom Almy	Eric Hendrickson	Izchak Miller
X! Ken Arromdee	Bruce Holloway		Gil Neiger
X  Eric Backus	Richard P. Hughey	Eric S. Raymond
X! John S. Bien	Greg Laskin		John Rupley
X! Ralf Brown	Steve Linhart		Kevin Sweet
X  Jean-Christophe Collet	Roland McGrath	Scott R. Turner
X! Steve Creps	Bruce Mewborne		Janet Walz
X  .TE
X  .ed
X  
X*** auxil/Old/Makefile.auxil	Mon Jul 31 13:17:44 1989
X--- auxil/Makefile.auxil	Mon Jul 31 09:27:34 1989
X***************
X*** 5,12 ****
X  
X  all:	Guidebook $(VARAUX) spec_levs
X  
X  Guidebook:	Guidebook.mn
X! 	nroff -mn Guidebook.mn > Guidebook
X  
X  data:	data.base ../include/config.h
X  	( cd ../src ; ./makedefs -d )
X--- 5,18 ----
X  
X  all:	Guidebook $(VARAUX) spec_levs
X  
X+ # The tmac.n macros come with the B news software, which should be available
X+ # at your friendly local archive site if you don't already have it.
X+ # An updated version also comes with the Elm mail distribution.
X+ # They are used here because they are more widely available (if not more
X+ # widely installed) than various proprietary macro packages that came with
X+ # your machine but not your neighbor's.
X  Guidebook:	Guidebook.mn
X! 	tbl Guidebook.mn | nroff -mn | col > Guidebook
X  
X  data:	data.base ../include/config.h
X  	( cd ../src ; ./makedefs -d )
X*** auxil/Old/data.base	Mon Jul 31 13:18:12 1989
X--- auxil/data.base	Thu Jul 27 15:38:28 1989
X***************
X*** 105,111 ****
X  		this is to transform the human, over time, into an undead of
X  		great magical power.  A Lich  hates life in any form; even a
X  		touch from one of these  creatures will cause a numbing cold
X! 		in the victim.  They all posess the capability to use magic.
X  m	a mimic
X  n	a naga;
X  		The naga is a mystical creature with the body of a snake and
X--- 105,111 ----
X  		this is to transform the human, over time, into an undead of
X  		great magical power.  A Lich  hates life in any form; even a
X  		touch from one of these  creatures will cause a numbing cold
X! 		in the victim.  They all possess the capability to use magic.
X  m	a mimic
X  n	a naga;
X  		The naga is a mystical creature with the body of a snake and
X*** auxil/Old/history	Mon Jul 31 13:18:44 1989
X--- auxil/history	Fri Jul 28 17:57:09 1989
X***************
X*** 4,17 ****
X  Jay Fenlason wrote the original Hack with help from Kenny Woodland,
X  Mike Thome, and Jon Payne.
X  
X! Andries Brouwer did a major re-write and published (at least) three versions
X! (1.0.1, 1.0.2, and 1.0.3) for UNIX(tm) machines to the Usenet.
X  
X! Don Kneller ported 1.0.3 Hack to Microsoft(tm) C and MSDOS(tm), producing
X! PC HACK 1.01e, added support for DEC Rainbow graphics in version 1.03g,
X! and went on to produce at least four more versions (3.0, 3.2, 3.51, and 3.6).
X  
X! R. Black ported PC HACK 3.51 to Lattice(tm) C and the Atari 520/1040,
X  producing ST Hack 1.03.
X  
X  Mike Stephenson merged these various versions back together, incorporating
X--- 4,18 ----
X  Jay Fenlason wrote the original Hack with help from Kenny Woodland,
X  Mike Thome, and Jon Payne.
X  
X! Andries Brouwer did a major re-write, transforming Hack into a very different
X! game, and published (at least) three versions (1.0.1, 1.0.2, and 1.0.3) for
X! UNIX(tm) machines to the Usenet.
X  
X! Don G. Kneller ported Hack 1.0.3 to Microsoft(tm) C and MS-DOS(tm), producing
X! PC HACK 1.01e, added support for DEC Rainbow graphics in version 1.03g, and
X! went on to produce at least four more versions (3.0, 3.2, 3.51, and 3.6).
X  
X! R. Black ported PC HACK 3.51 to Lattice(tm) C and the Atari 520/1040ST,
X  producing ST Hack 1.03.
X  
X  Mike Stephenson merged these various versions back together, incorporating
X***************
X*** 23,28 ****
X--- 24,31 ----
X  Threepoint, and Janet Walz, to produce NetHack 3.0. 
X  
X  Olaf Seibert ported NetHack 2.3 and 3.0 to the Amiga.
X+ 
X+ Eric R. Smith ported NetHack 3.0 to the Atari.
X  
X   
X  From time to time, some depraved individual out there in netland sends a
X*** auxil/Old/rumors.tru	Mon Jul 31 13:19:14 1989
X--- auxil/rumors.tru	Mon Jul 24 14:47:51 1989
X***************
X*** 172,178 ****
X  What is a cockatrice going to eat when it gets hungry?
X  Where do you think all those demons come from?  From hell, of course.
X  Where do you think hell is located?  It must be deep, deep down.
X- Who would ever have thought one could live by eating fog clouds?
X  Why do you suppose they call them MAGIC markers?
X  Why would anybody in his sane mind engrave "Elbereth"?
X  Wishing too much may bring you too little.
X--- 172,177 ----
X*** include/Old/config.h	Mon Jul 31 13:20:47 1989
X--- include/config.h	Mon Jul 31 09:10:17 1989
X***************
X*** 27,32 ****
X--- 27,35 ----
X  			   avoid overloading limited preprocessors */
X  /* #define TERMINFO	/* uses terminfo rather than termcap */
X  			/* should be defined for most, but not all, SYSV */
X+ 			/* in particular, it should NOT be defined for the
X+ 			 * UNIXPC unless you remove the use of the shared
X+ 			 * library in the makefile */
X  /* #define MINIMAL_TERM	/* if a terminal handles highlighting or tabs poorly,
X  			   try this define, used in pager.c and termcap.c */
X  #endif
X***************
X*** 47,52 ****
X--- 50,65 ----
X  #define	LOGFILE	"logfile" /* larger file for debugging purposes */
X  #define	NEWS	"news"	  /* the file containing the latest hack news */
X  
X+ /*
X+  *	If COMPRESS is defined, it should contain the full path name of your
X+  *	'compress' program.  Defining ZEROCOMP causes NetHack to do simpler
X+  *	zero-run compression internally.  Both COMPRESS and ZEROCOMP create
X+  *	smaller bones/level/save files, but require additional code and time.
X+  */
X+ 
X+ #define COMPRESS "/usr/local/compress"
X+ /* #define ZEROCOMP	/* Use only if COMPRESS is not used -- Olaf Seibert */
X+ 
X  
X  #define	CHDIR		/* delete if no chdir() available */
X  
X***************
X*** 148,157 ****
X  #define	SHIRT		/* Hawaiian shirt code by Steve Linhart */
X  #define THEOLOGY	/* Smarter gods - The Unknown Hacker */
X  #define SINKS		/* Kitchen sinks - Janet Walz */
X- #define COMPRESS "/usr/local/compress"	/* the location of 'compress' */
X- 			/* Compressed bones / save files - Izchak Miller */
X- /* #define ZEROCOMP	/* Zero-run compression of files - Olaf Seibert */
X- 			/* Use only if COMPRESS is not used */
X  #define SOUNDS		/* Add more life to the dungeon */
X  #define REINCARNATION	/* Rogue-like levels */
X  #define ELBERETH	/* Allow for disabling the E word - Mike 3point */
X--- 161,166 ----
X***************
X*** 168,176 ****
X  #define GOLEMS		/* Golems, by KAA */
X  #define TOLKIEN		/* More varieties of objects and monsters */
X  #define KICK		/* Allow kicking things besides doors -Izchak Miller */
X  
X  #ifdef REDO
X! #define DOAGAIN	'\001'		/* The "redo" key Used in tty.c and cmd.c */
X  #endif
X  
X  #define	EXP_ON_BOTL	/* Show experience on bottom line */
X--- 177,186 ----
X  #define GOLEMS		/* Golems, by KAA */
X  #define TOLKIEN		/* More varieties of objects and monsters */
X  #define KICK		/* Allow kicking things besides doors -Izchak Miller */
X+ #define TUTTI_FRUTTI	/* Fruits as in Rogue, but which work... -KAA */
X  
X  #ifdef REDO
X! #define DOAGAIN	'\001'		/* The "redo" key used in tty.c and cmd.c */
X  #endif
X  
X  #define	EXP_ON_BOTL	/* Show experience on bottom line */
X*** include/Old/decl.h	Mon Jul 31 13:21:37 1989
X--- include/decl.h	Mon Jul 31 09:10:21 1989
X***************
X*** 51,59 ****
X--- 51,61 ----
X  E xchar fountsound, sinksound;	/* numbers of noisy things */
X  
X  E char pl_character[PL_CSIZ];
X+ #ifdef TUTTI_FRUTTI
X  E char pl_fruit[PL_FSIZ];
X  E int current_fruit;
X  E struct fruit *ffruit;
X+ #endif
X  #ifdef STRONGHOLD
X  E char tune[6];
X  #  ifdef MUSIC
X***************
X*** 98,106 ****
X  E long moves;
X  E long wailmsg;
X  
X- E boolean unweapon;
X- E boolean stoned;
X  E boolean in_mklev;
X  #ifdef KOPS
X  E boolean allow_kops;
X  #endif
X--- 100,110 ----
X  E long moves;
X  E long wailmsg;
X  
X  E boolean in_mklev;
X+ E boolean stoned;
X+ E boolean unweapon;
X+ E boolean mrg_to_wielded;
X+ 
X  #ifdef KOPS
X  E boolean allow_kops;
X  #endif
X*** include/Old/extern.h	Sun Jul 23 22:08:29 1989
X--- include/extern.h	Mon Jul 31 21:56:47 1989
X***************
X*** 387,392
X  E int doopen();
X  E int doclose();
X  
X  /* ### makemon.c ### */
X  
X  E struct monst *makemon P((struct permonst *,int,int));
X
X--- 387,402 -----
X  E int doopen();
X  E int doclose();
X  
X+ /* ### mail.c ### */
X+ 
X+ #ifdef MAIL
X+ #ifdef UNIX
X+ E void getmailstatus();
X+ #endif
X+ E void ckmailstatus();
X+ E void readmail();
X+ #endif /* MAIL */
X+ 
X  /* ### makemon.c ### */
X  
X  E struct monst *makemon P((struct permonst *,int,int));
X***************
X*** 390,397
X  /* ### makemon.c ### */
X  
X  E struct monst *makemon P((struct permonst *,int,int));
X! E void enexto P((coord *,xchar,xchar));
X! E int goodpos P((int,int));
X  E void rloc P((struct monst *));
X  E struct monst *mkmon_at P((char *,int,int));
X  E void init_monstr();
X
X--- 400,407 -----
X  /* ### makemon.c ### */
X  
X  E struct monst *makemon P((struct permonst *,int,int));
X! E void enexto P((coord *,xchar,xchar,struct permonst *));
X! E int goodpos P((int,int, struct permonst *));
X  E void rloc P((struct monst *));
X  E struct monst *mkmon_at P((char *,int,int));
X  E void init_monstr();
X***************
X*** 638,643
X  E int doset();
X  E int dotogglepickup();
X  E void option_help();
X  E int fruitadd P((char *));
X  
X  /* ### pager.c ### */
X
X--- 648,654 -----
X  E int doset();
X  E int dotogglepickup();
X  E void option_help();
X+ #ifdef TUTTI_FRUTTI
X  E int fruitadd P((char *));
X  #endif
X  
X***************
X*** 639,644
X  E int dotogglepickup();
X  E void option_help();
X  E int fruitadd P((char *));
X  
X  /* ### pager.c ### */
X  
X
X--- 650,656 -----
X  E void option_help();
X  #ifdef TUTTI_FRUTTI
X  E int fruitadd P((char *));
X+ #endif
X  
X  /* ### pager.c ### */
X  
X***************
X*** 685,691
X  /* ### pcunix.c ### */
X  
X  #ifdef MSDOS
X! #ifndef TOS
X  E void setrandom();
X  E int getyear();
X  E char *getdate();
X
X--- 697,703 -----
X  /* ### pcunix.c ### */
X  
X  #ifdef MSDOS
X! #ifndef OLD_TOS
X  E void setrandom();
X  E int getyear();
X  E char *getdate();
X***************
X*** 748,753
X  E void djinni_from_bottle P((struct obj *));
X  E int monster_detect P((struct obj *));
X  E int object_detect P((struct obj *));
X  
X  /* ### pray.c ### */
X  
X
X--- 760,766 -----
X  E void djinni_from_bottle P((struct obj *));
X  E int monster_detect P((struct obj *));
X  E int object_detect P((struct obj *));
X+ E int trap_detect P((struct obj *));
X  
X  /* ### pray.c ### */
X  
X***************
X*** 838,844
X  E void do_mapping();
X  E void do_vicinity_map();
X  E int destroy_arm P((struct obj *));
X- E int trap_detect P((struct obj *));
X  E int gold_detect P((struct obj *));
X  E int food_detect P((struct obj *));
X  E void punish P((struct obj *));
X
X--- 851,856 -----
X  E void do_mapping();
X  E void do_vicinity_map();
X  E int destroy_arm P((struct obj *));
X  E int gold_detect P((struct obj *));
X  E int food_detect P((struct obj *));
X  E void punish P((struct obj *));
X***************
X*** 889,895
X  E int hangup();
X  #endif /* NOSAVEONHANGUP */
X  E int dosave0();
X! #if defined(DGK) && !defined(TOS)
X  E boolean savelev P((int,xchar,int));
X  E boolean swapin_file P((int));
X  #else /* DGK && !TOS */
X
X--- 901,907 -----
X  E int hangup();
X  #endif /* NOSAVEONHANGUP */
X  E int dosave0();
X! #if defined(DGK) && !defined(OLD_TOS)
X  E boolean savelev P((int,xchar,int));
X  E boolean swapin_file P((int));
X  #else /* DGK && !OLD_TOS */
X***************
X*** 892,898
X  #if defined(DGK) && !defined(TOS)
X  E boolean savelev P((int,xchar,int));
X  E boolean swapin_file P((int));
X! #else /* DGK && !TOS */
X  E void savelev P((int, xchar));
X  #endif /* DGK && !TOS */
X  #ifdef ZEROCOMP
X
X--- 904,910 -----
X  #if defined(DGK) && !defined(OLD_TOS)
X  E boolean savelev P((int,xchar,int));
X  E boolean swapin_file P((int));
X! #else /* DGK && !OLD_TOS */
X  E void savelev P((int, xchar));
X  #endif /* DGK && !OLD_TOS */
X  #ifdef ZEROCOMP
X***************
X*** 894,900
X  E boolean swapin_file P((int));
X  #else /* DGK && !TOS */
X  E void savelev P((int, xchar));
X! #endif /* DGK && !TOS */
X  #ifdef ZEROCOMP
X  E void bflush P((int));
X  #endif
X
X--- 906,912 -----
X  E boolean swapin_file P((int));
X  #else /* DGK && !OLD_TOS */
X  E void savelev P((int, xchar));
X! #endif /* DGK && !OLD_TOS */
X  #ifdef ZEROCOMP
X  E void bflush P((int));
X  #endif
X***************
X*** 899,904
X  E void bflush P((int));
X  #endif
X  E void bwrite P((int,genericptr_t,unsigned int));
X  E void savefruitchn P((int));
X  
X  /* ### search.c ### */
X
X--- 911,917 -----
X  E void bflush P((int));
X  #endif
X  E void bwrite P((int,genericptr_t,unsigned int));
X+ #ifdef TUTTI_FRUTTI
X  E void savefruitchn P((int));
X  #endif
X  
X***************
X*** 900,905
X  #endif
X  E void bwrite P((int,genericptr_t,unsigned int));
X  E void savefruitchn P((int));
X  
X  /* ### search.c ### */
X  
X
X--- 913,919 -----
X  E void bwrite P((int,genericptr_t,unsigned int));
X  #ifdef TUTTI_FRUTTI
X  E void savefruitchn P((int));
X+ #endif
X  
X  /* ### search.c ### */
X  
X***************
X*** 1087,1092
X  E boolean special_case P((struct monst *));
X  E boolean attack P((struct monst *));
X  E boolean hmon P((struct monst *,struct obj *,int));
X  
X  /* ### unixmain.c ### */
X  
X
X--- 1101,1107 -----
X  E boolean special_case P((struct monst *));
X  E boolean attack P((struct monst *));
X  E boolean hmon P((struct monst *,struct obj *,int));
X+ E int passive P((struct monst *,boolean,int));
X  
X  /* ### unixmain.c ### */
X  
X***************
X*** 1122,1132
X  E void gethdate P((char *));
X  E int uptodate P((int));
X  E void getlock();
X- #ifdef MAIL
X- E void getmailstatus();
X- E void ckmailstatus();
X- E void readmail();
X- #endif /* MAIL */
X  E void regularize P((char *));
X  #endif /* UNIX */
X  
X
X--- 1137,1142 -----
X  E void gethdate P((char *));
X  E int uptodate P((int));
X  E void getlock();
X  E void regularize P((char *));
X  #endif /* UNIX */
X  
X***************
X*** 1197,1203
X  E void wormdead P((struct monst *));
X  E void wormhit P((struct monst *));
X  E void wormsee P((unsigned int));
X! E void cutworm P((struct monst *,xchar,xchar,uchar));
X  #endif /* WORM */
X  
X  /* ### worn.c ### */
X
X--- 1207,1213 -----
X  E void wormdead P((struct monst *));
X  E void wormhit P((struct monst *));
X  E void wormsee P((unsigned int));
X! E void cutworm P((struct monst *,xchar,xchar,unsigned));
X  #endif /* WORM */
X  
X  /* ### worn.c ### */
X*** include/Old/lev.h	Mon Jul 31 13:26:08 1989
X--- include/lev.h	Fri Jul 28 17:54:31 1989
X***************
X*** 7,13 ****
X  #ifndef LEV_H
X  #define LEV_H
X  
X! #ifndef TOS
X  #define OMASK	0
X  #else
X  #define msmsg	cprintf
X--- 7,13 ----
X  #ifndef LEV_H
X  #define LEV_H
X  
X! #ifndef OLD_TOS
X  #define OMASK	0
X  #else
X  #define msmsg	cprintf
X*** include/Old/msdos.h	Mon Jul 31 13:29:15 1989
X--- include/msdos.h	Fri Jul 28 17:54:36 1989
X***************
X*** 5,17 ****
X  #ifndef MSDOS_H
X  #define MSDOS_H
X  
X! #ifdef TOS
X  #define msmsg	cprintf
X  #endif
X  extern const char *alllevels, *allbones;
X  extern char levels[], bones[], permbones[], SAVEF[], hackdir[];
X  extern int ramdisk;
X! #if defined(DGK) && !defined(TOS)
X  extern int count_only;
X  #endif
X  
X--- 5,17 ----
X  #ifndef MSDOS_H
X  #define MSDOS_H
X  
X! #ifdef OLD_TOS
X  #define msmsg	cprintf
X  #endif
X  extern const char *alllevels, *allbones;
X  extern char levels[], bones[], permbones[], SAVEF[], hackdir[];
X  extern int ramdisk;
X! #if defined(DGK) && !defined(OLD_TOS)
X  extern int count_only;
X  #endif
X  
X*** include/Old/objclass.h	Mon Jul 31 13:29:54 1989
X--- include/objclass.h	Mon Jul 24 19:01:39 1989
X***************
X*** 82,87 ****
X--- 82,88 ----
X   * pager.c:	if(q == '%') pline("%%	a piece of food");
X   */
X  
X+ #ifdef TUTTI_FRUTTI
X  struct fruit {
X  	char fname[PL_FSIZ];
X  	int fid;
X***************
X*** 88,91 ****
X--- 89,93 ----
X  	struct fruit *nextf;
X  };
X  #define newfruit() (struct fruit *)alloc(sizeof(struct fruit))
X+ #endif
X  #endif /* OBJCLASS_H */
X*** include/Old/patchlevel.h	Mon Jul 31 13:30:17 1989
X--- include/patchlevel.h	Mon Jul 31 12:15:13 1989
X***************
X*** 1,1 ****
X! #define PATCHLEVEL	0
X--- 1,12 ----
X! /*
X!  *  Patch 1, July 31, 1989
X!  *  add support for Atari TOS (courtesy Eric Smith) and Andrew File System
X!  *	(courtesy Ralf Brown)
X!  *  include the uuencoded version of termcap.arc for the MSDOS versions that
X!  *	was included with 2.2 and 2.3
X!  *  make a number of simple changes to accommodate various compilers
X!  *  fix a handful of bugs, and do some code cleaning elsewhere
X!  *  add more instructions for new environments and things commonly done wrong
X!  */
X! 
X! #define PATCHLEVEL	1
X*** include/Old/rm.h	Mon Jul 31 13:31:32 1989
X--- include/rm.h	Fri Jul 28 17:54:41 1989
X***************
X*** 221,227 ****
X  
X  extern struct rm levl[COLNO][ROWNO];
X  
X! #if defined(DGK) && !defined(TOS)
X  #define ACTIVE	1
X  #define SWAPPED	2
X  
X--- 221,227 ----
X  
X  extern struct rm levl[COLNO][ROWNO];
X  
X! #if defined(DGK) && !defined(OLD_TOS)
X  #define ACTIVE	1
X  #define SWAPPED	2
X  
X*** include/Old/system.h	Mon Jul 31 13:32:31 1989
X--- include/system.h	Fri Jul 28 17:54:46 1989
X***************
X*** 20,25 ****
X--- 20,29 ----
X  #define time_t long
X  #endif
X  
X+ #if defined(TOS) && defined(__GNUC__)
X+ #define _SIZE_T
X+ #endif
X+ 
X  /* some old <sys/types.h> may not define off_t and size_t; if your system is
X   * one of these, define them here
X   */
X***************
X*** 155,161 ****
X--- 159,167 ----
X  #define OLD_SPRINTF
X  E char *sprintf();
X  #else
X+ #ifndef TOS	/* problem with prototype mismatches with <stdio.h> */
X  E int sprintf P((char *,const char *,...));
X+ #endif
X  #endif
X  
X  #define Sprintf	(void) sprintf
X*** include/Old/tosconf.h	Mon Jul 31 13:32:55 1989
X--- include/tosconf.h	Fri Jul 28 17:12:48 1989
X***************
X*** 8,14 ****
X--- 8,27 ----
X  
X  #define MSDOS		/* must be defined to allow some inclusions */
X  
X+ /* NOTE: if your TOS compiler is dumb, #define OLD_TOS and compile with
X+    oldtos.c to get a minimal configuration (you may need to do some
X+    tweaking); otherwise (e.g. GCC) don't do it. OLD_TOS corresponds
X+    most closely to LATTICE C, I think */
X+ 
X+ /* #define OLD_TOS */
X+ /* #define NO_SIGNAL */
X+ 
X+ #ifdef __GNUC__
X+ #define FCMASK	0666
X+ #define O_BINARY 0
X+ #else
X  #define FCMASK	0x8000
X+ #endif
X  
X  #ifdef UNIXDEBUG
X  #define O_BINARY	0
X***************
X*** 15,25 ****
X  #define remove(x)	unlink(x)
X  #endif
X  
X  #define Rand() rand()
X  #define Srand() srand()
X  
X! #include "msdos.h"
X! #include "pcconf.h"	    /* remainder of stuff is same as the PC */
X  
X  #endif /* TOSCONF_H /* */
X  #endif /* TOS /* */
X--- 28,48 ----
X  #define remove(x)	unlink(x)
X  #endif
X  
X+ #ifdef OLD_TOS
X  #define Rand() rand()
X  #define Srand() srand()
X+ #endif
X  
X! #define DGK
X! #define RANDOM
X! #define SHELL
X  
X+ #ifndef MSDOS_H
X+ #include "msdos.h"
X+ #endif
X+ #ifndef PCCONF_H
X+ #include "pcconf.h"	 	 /* remainder of stuff is same as the PC */
X+ #endif
X+ #undef ANSI_DEFAULT
X  #endif /* TOSCONF_H /* */
X  #endif /* TOS /* */
X*** include/Old/tradstdc.h	Mon Jul 31 13:33:18 1989
X--- include/tradstdc.h	Sat Jul 29 19:46:25 1989
X***************
X*** 62,65 ****
X--- 62,69 ----
X  
X  #endif /* __STDC__ */
X  
X+ #ifdef __HC__	/* MetaWare High-C defaults to unsigned chars */
X+ # undef signed
X+ #endif
X+ 
X  #endif /* TRADSTDC_H /**/
X*** include/Old/unixconf.h	Mon Jul 31 13:34:21 1989
X--- include/unixconf.h	Mon Jul 31 09:10:03 1989
X***************
X*** 38,44 ****
X--- 38,60 ----
X  /* #define APOLLO	/* same for the Apollo */
X  /* #define RANDOM	/* if neither random/srandom nor lrand48/srand48
X  			   is available from your system */
X+ /* #define MICROPORT_286_BUG /* Changes needed in termcap.c to get it to
X+ 			   run with Microport Sys V/AT version 2.4.
X+ 			   By Jay Maynard */
X  
X+ 
X+ /*
X+  * The next two defines are intended mainly for the Andrew File System,
X+  * which does not allow hard links.  If NO_FILE_LINKS is defined, lock files
X+  * will be created in LOCKDIR using open() instead of in the playground using
X+  * link().
X+  *		Ralf Brown, 7/26/89 (from v2.3 hack of 10/10/88)
X+  */
X+ 
X+ /* #define NO_FILE_LINKS	/* if no hard links */
X+ /* #define LOCKDIR "/usr/games/lib/nethackdir"	/* where to put locks */
X+ 
X+ 
X  /*
X   * Define DEF_PAGER as your default pager, e.g. "/bin/cat" or "/usr/ucb/more"
X   * If defined, it can be overridden by the environment variable PAGER.
X***************
X*** 113,118 ****
X--- 129,142 ----
X  #define Rand()	lrand48()
X  #define Srand(seed) srand48(seed)
X  #endif
X+ 
X+ #ifdef hc	/* older versions of the MetaWare High-C compiler define this */
X+ # ifdef __HC__
X+ #  undef __HC__
X+ # endif __HC__
X+ # define __HC__ hc
X+ # undef hc
X+ #endif hc
X  
X  #include "extern.h"
X  
X*** others/Old/Makefile.pc	Mon Jul 31 13:36:38 1989
X--- others/Makefile.pc	Sun Jul 30 21:45:59 1989
X***************
X*** 47,56 ****
X  
X  VOBJ =	o\alloc.o o\apply.o o\artifact.o o\attrib.o o\bones.o o\cmd.o \
X  	o\dbridge.o o\decl.o o\demon.o o\do.o o\do_name.o o\do_wear.o \
X! 	o\dog.o o\dogmove.o o\dothrow.o o\eat.o o\end.o o\engrave.o \
X  	o\exper.o o\extralev.o o\fountain.o o\getline.o o\hack.o o\invent.o \
X  	o\lock.o o\mail.o o\main.o o\makemon.o o\mcastu.o o\mhitm.o o\mhitu.o \
X! 	o\mklev.o o\mkmaze.o o\mkobj.o o\mkshop.o o\mon.o o\mondata.o \
X  	o\msdos.o o\monmove.o o\monst.o o\mthrowu.o o\music.o o\o_init.o \
X  	o\objects.o o\objnam.o o\options.o o\pager.o o\pickup.o o\polyself.o \
X  	o\potion.o o\pray.o o\pri.o o\priest.o o\prisym.o $(RANDOM) o\read.o \
X--- 47,56 ----
X  
X  VOBJ =	o\alloc.o o\apply.o o\artifact.o o\attrib.o o\bones.o o\cmd.o \
X  	o\dbridge.o o\decl.o o\demon.o o\do.o o\do_name.o o\do_wear.o \
X! 	o\dog.o o\dogmove.o o\dokick.o o\dothrow.o o\eat.o o\end.o o\engrave.o \
X  	o\exper.o o\extralev.o o\fountain.o o\getline.o o\hack.o o\invent.o \
X  	o\lock.o o\mail.o o\main.o o\makemon.o o\mcastu.o o\mhitm.o o\mhitu.o \
X! 	o\mklev.o o\mkmaze.o o\mkobj.o o\mkroom.o o\mon.o o\mondata.o \
X  	o\msdos.o o\monmove.o o\monst.o o\mthrowu.o o\music.o o\o_init.o \
X  	o\objects.o o\objnam.o o\options.o o\pager.o o\pickup.o o\polyself.o \
X  	o\potion.o o\pray.o o\pri.o o\priest.o o\prisym.o $(RANDOM) o\read.o \
X*** others/Old/msdos.c	Mon Jul 31 13:38:36 1989
X--- others/msdos.c	Fri Jul 28 17:58:03 1989
X***************
X*** 3,11 ****
X  /* An assortment of MSDOS functions.
X   */
X  
X- #ifdef MSDOS
X- #include <dos.h>
X  #include "hack.h"
X  static char DOSgetch();
X  #ifdef DGK
X  static char BIOSgetch();
X--- 3,21 ----
X  /* An assortment of MSDOS functions.
X   */
X  
X  #include "hack.h"
X+ #ifdef MSDOS
X+ # ifdef TOS
X+ #  include <osbind.h>
X+ # else
X+ #  ifdef __TURBOC__	/* avoid incompatible redeclaration */
X+ #   define getdate quux
X+ #  endif
X+ #  include <dos.h>
X+ #  ifdef __TURBOC__
X+ #   undef getdate
X+ #  endif
X+ # endif
X  static char DOSgetch();
X  #ifdef DGK
X  static char BIOSgetch();
X***************
X*** 36,41 ****
X--- 46,54 ----
X  #define DIRECT_INPUT	0x7
X  static char
X  DOSgetch() {
X+ #ifdef TOS
X+ 	return (Crawcin() & 0x007f);
X+ #else
X  	union REGS regs;
X  
X  	regs.h.ah = DIRECT_INPUT;
X***************
X*** 46,51 ****
X--- 59,65 ----
X  		regs.h.al = 0;		/* and return a 0 */
X  	}
X  	return (regs.h.al);
X+ #endif /* TOS */
X  }
X  
X  #include <ctype.h>
X***************
X*** 52,58 ****
X  #include <fcntl.h>
X  #include <process.h>
X  
X! static char *COMSPEC = "COMSPEC";
X  #define getcomspec() getenv(COMSPEC)
X  
X  #ifdef SHELL
X--- 66,78 ----
X  #include <fcntl.h>
X  #include <process.h>
X  
X! static char *COMSPEC = 
X! #ifdef TOS
X! "SHELL";
X! #else
X! "COMSPEC";
X! #endif
X! 
X  #define getcomspec() getenv(COMSPEC)
X  
X  #ifdef SHELL
X***************
X*** 77,83 ****
X--- 97,107 ----
X  		start_screen();
X  		docrt();
X  	} else
X+ #ifdef TOS
X+ 		pline("Cannot find SHELL");
X+ #else
X  		pline("Cannot exec COMMAND.COM");
X+ #endif
X  	return 0;
X  }
X  #endif /* SHELL */
X***************
X*** 86,93 ****
X--- 110,123 ----
X  /* Normal characters are output when the shift key is not pushed.
X   * Shift characters are output when either shift key is pushed.
X   */
X+ #ifdef TOS
X+ #define KEYPADHI	113
X+ #define KEYPADLOW	103
X+ #else
X  #define KEYPADHI	83
X  #define KEYPADLOW	71
X+ #endif
X+ 
X  #define PADKEYS		(KEYPADHI - KEYPADLOW + 1)
X  #define iskeypad(x)	(KEYPADLOW <= (x) && (x) <= KEYPADHI)
X  static const struct pad {
X***************
X*** 96,106 ****
X--- 126,144 ----
X  			{'y', 'Y'},		/* 7 */
X  			{'k', 'K'},		/* 8 */
X  			{'u', 'U'},		/* 9 */
X+ #ifndef TOS
X  			{'m', CTRL('P')},	/* - */
X+ #endif
X  			{'h', 'H'},		/* 4 */
X+ #ifdef TOS
X+ 			{'.', '.'},
X+ #else
X  			{'g', 'g'},		/* 5 */
X+ #endif
X  			{'l', 'L'},		/* 6 */
X+ #ifndef TOS
X  			{'p', 'P'},		/* + */
X+ #endif
X  			{'b', 'B'},		/* 1 */
X  			{'j', 'J'},		/* 2 */
X  			{'n', 'N'},		/* 3 */
X***************
X*** 110,120 ****
X--- 148,166 ----
X  			{'7', '7'},		/* 7 */
X  			{'8', '8'},		/* 8 */
X  			{'9', '9'},		/* 9 */
X+ #ifndef TOS
X  			{'m', CTRL('P')},	/* - */
X+ #endif
X  			{'4', '4'},		/* 4 */
X+ #ifdef TOS
X+ 			{'.', '.'},		/* 5 */
X+ #else
X  			{'g', 'G'},		/* 5 */
X+ #endif
X  			{'6', '6'},		/* 6 */
X+ #ifndef TOS
X  			{'p', 'P'},		/* + */
X+ #endif
X  			{'1', '1'},		/* 1 */
X  			{'2', '2'},		/* 2 */
X  			{'3', '3'},		/* 3 */
X***************
X*** 125,131 ****
X  /* BIOSgetch gets keys directly with a BIOS call.
X   */
X  #define SHIFT		(0x1 | 0x2)
X! #define CTRL		0x4
X  /* #define ALT		0x8 */
X  #define KEYBRD_BIOS	0x16
X  
X--- 171,177 ----
X  /* BIOSgetch gets keys directly with a BIOS call.
X   */
X  #define SHIFT		(0x1 | 0x2)
X! /* #define CTRL		0x4 */
X  /* #define ALT		0x8 */
X  #define KEYBRD_BIOS	0x16
X  
X***************
X*** 132,160 ****
X  static char
X  BIOSgetch() {
X  	unsigned char scan, shift, ch;
X  	union REGS regs;
X  	struct pad (*kpad)[PADKEYS];
X  
X  	/* Get scan code.
X  	 */
X  	regs.h.ah = 0;
X  	int86(KEYBRD_BIOS, &regs, &regs);
X  	ch = regs.h.al;
X  	scan = regs.h.ah;
X! 
X  	/* Get shift status.
X  	 */
X  	regs.h.ah = 2;
X  	int86(KEYBRD_BIOS, &regs, &regs);
X  	shift = regs.h.al;
X! 
X  	/* If scan code is for the keypad, translate it.
X  	 */
X  	kpad = flags.num_pad ? numpad : keypad;
X  	if (iskeypad(scan)) {
X  		if (shift & SHIFT) {
X  			flags.mv = flags.run = 1;
X  			/* necessary if number_pad is on */
X  			ch = (*kpad)[scan - KEYPADLOW].shift;
X  		} else
X  			ch = (*kpad)[scan - KEYPADLOW].normal;
X--- 178,220 ----
X  static char
X  BIOSgetch() {
X  	unsigned char scan, shift, ch;
X+ #ifdef TOS
X+ 	long  x;
X+ #else
X  	union REGS regs;
X+ #endif
X  	struct pad (*kpad)[PADKEYS];
X  
X  	/* Get scan code.
X  	 */
X+ #ifdef TOS
X+ 	x = Crawcin();
X+ 	ch = x & 0x0ff;
X+ 	scan = (x & 0x00ff0000L) >> 16;
X+ #else	
X  	regs.h.ah = 0;
X  	int86(KEYBRD_BIOS, &regs, &regs);
X  	ch = regs.h.al;
X  	scan = regs.h.ah;
X! #endif
X  	/* Get shift status.
X  	 */
X+ #ifdef TOS
X+ 	shift = Kbshift(-1);
X+ #else
X  	regs.h.ah = 2;
X  	int86(KEYBRD_BIOS, &regs, &regs);
X  	shift = regs.h.al;
X! #endif
X  	/* If scan code is for the keypad, translate it.
X  	 */
X  	kpad = flags.num_pad ? numpad : keypad;
X  	if (iskeypad(scan)) {
X  		if (shift & SHIFT) {
X+ #ifndef TOS
X  			flags.mv = flags.run = 1;
X  			/* necessary if number_pad is on */
X+ #endif
X  			ch = (*kpad)[scan - KEYPADLOW].shift;
X  		} else
X  			ch = (*kpad)[scan - KEYPADLOW].normal;
X***************
X*** 162,167 ****
X--- 222,229 ----
X  	return ch;
X  }
X  
X+ #ifndef TOS
X+ 
X  #define FINDFIRST	0x4E00
X  #define FINDNEXT	0x4F00
X  #define GETDTA		0x2F00
X***************
X*** 245,250 ****
X--- 307,349 ----
X  	return ret;
X  }
X  
X+ #else /* TOS */
X+ 
X+ long
X+ freediskspace(path)
X+ char *path;
X+ {
X+ 	int drive = 0;
X+ 	struct {
X+ 		long freal; /*free allocation units*/
X+ 		long total; /*total number of allocation units*/
X+ 		long bps;   /*bytes per sector*/
X+ 		long pspal; /*physical sectors per allocation unit*/
X+ 	} freespace;
X+ 	if (path[0] && path[1] == ':')
X+ 		drive = (toupper(path[0]) - 'A') + 1;
X+ 	if (Dfree(&freespace,drive)<0) return -1;
X+ 	return freespace.freal*freespace.bps*freespace.pspal;
X+ }
X+ 
X+ static int
X+ findfirst(path)
X+ char *path;
X+ {
X+ 	return (Fsfirst(path, 0) == 0);
X+ }
X+ 
X+ static int findnext() {
X+ 	return (Fsnext() == 0);
X+ }
X+ 
X+ static char *
X+ getdta() {
X+ 	return (char *) Fgetdta();
X+ }
X+ 
X+ #endif /* TOS */
X+ 
X  long
X  filesize(file)
X  char *file;
X***************
X*** 283,289 ****
X  	int status;
X  	long fs;
X  	extern saveprompt;
X! 
X  	if (!ramdisk)
X  		return;
X  
X--- 382,390 ----
X  	int status;
X  	long fs;
X  	extern saveprompt;
X! #ifdef TOS
X! 	extern int _copyfile();
X! #endif
X  	if (!ramdisk)
X  		return;
X  
X***************
X*** 293,304 ****
X  	dta = getdta();
X  	last[0] = '\0';
X  	Sprintf(from, "%s%s", frompath, allbones);
X  	if (findfirst(from))
X  		do {
X  			Strcpy(last, dta + 30);
X  		} while (findnext());
X! 
X! 	topath = (mode == TOPERM) ? permbones : levels;
X  	if (last[0]) {
X  		Sprintf(copy, "%cC copy", switchar());
X  
X--- 394,417 ----
X  	dta = getdta();
X  	last[0] = '\0';
X  	Sprintf(from, "%s%s", frompath, allbones);
X+ 	topath = (mode == TOPERM) ? permbones : levels;
X+ #ifdef TOS
X+ 	eraseall(topath, allbones);
X+ #endif
X  	if (findfirst(from))
X  		do {
X+ #ifdef TOS
X+ 			Sprintf(from, "%s%s", frompath, dta+30); 
X+ 			Sprintf(to, "%s%s", topath, dta+30);
X+ 			if (_copyfile(from, to))
X+ 				goto error_copying;
X+ #endif
X  			Strcpy(last, dta + 30);
X  		} while (findnext());
X! #ifdef TOS
X! 	else
X! 		return;
X! #else
X  	if (last[0]) {
X  		Sprintf(copy, "%cC copy", switchar());
X  
X***************
X*** 313,318 ****
X--- 426,432 ----
X  			to, "> nul", NULL);
X  	} else
X  		return;
X+ #endif /* TOS */
X  
X  	/* See if the last file got there.  If so, remove the ramdisk bones
X  	 * files.
X***************
X*** 324,329 ****
X--- 438,444 ----
X  		return;
X  	}
X  
X+ error_copying:
X  	/* Last file didn't get there.
X  	 */
X  	Sprintf(to, "%s%s", topath, allbones);
X***************
X*** 409,414 ****
X--- 524,532 ----
X  	return FALSE;
X  }
X  
X+ #ifdef TOS
X+ #define comspec_exists() 1
X+ #else
X  /* Return 1 if the comspec was found */
X  static boolean
X  comspec_exists() {
X***************
X*** 422,427 ****
X--- 540,546 ----
X  		}
X  	return FALSE;
X  }
X+ #endif
X  
X  /* Prompt for game disk, then check for record file.
X   */
X***************
X*** 675,688 ****
X--- 794,813 ----
X  char *str;
X  {
X  	char *ptr;
X+ #ifndef TOS
X  	union REGS inregs;
X+ #endif
X  	char drive;
X  
X  	if ((ptr = index(str, ':')) != NULL) {
X  		drive = toupper(*(ptr - 1));
X+ #ifdef TOS
X+ 		Dsetdrv(drive - 'A');
X+ #else
X  		inregs.h.ah = SELECTDISK;
X  		inregs.h.dl = drive - 'A';
X  		intdos(&inregs, &inregs);
X+ #endif
X  	}
X  	return;
X  }
X***************
X*** 697,702 ****
X--- 822,828 ----
X  }
X  #endif
X  
X+ #ifndef TOS
X  /* Use the IOCTL DOS function call to change stdin and stdout to raw
X   * mode.  For stdin, this prevents MSDOS from trapping ^P, thus
X   * freeing us of ^P toggling 'echo to printer'.
X***************
X*** 754,764 ****
X--- 880,895 ----
X  	intdos(&regs, &regs);
X  	return (regs.x.dx);
X  }
X+ #endif /* TOS */
X  
X  #ifdef DGK
X  /* Follow the PATH, trying to fopen the file.
X   */
X+ #ifdef TOS
X+ #define PATHSEP ','
X+ #else
X  #define PATHSEP	';'
X+ #endif
X  
X  FILE *
X  fopenp(name, mode)
X***************
X*** 803,809 ****
X--- 934,942 ----
X  #endif
X  
X  	flushout();
X+ #ifndef TOS
X  	enable_ctrlP();		/* in case this wasn't done */
X+ #endif
X  #ifdef DGK
X  	if (ramdisk) copybones(TOPERM);
X  #endif
X***************
X*** 811,817 ****
X--- 944,982 ----
X  	chdir(orgdir);		/* chdir, not chdirx */
X  	chdrive(orgdir);
X  #endif
X+ #ifdef TOS
X+ 	getreturn("to continue"); /* so the user can read the score list */
X+ #endif
X  	exit(code);
X  	return;
X  }
X  #endif /* MSDOS */
X+ 
X+ #ifdef TOS
X+ #define BIGBUF  8192
X+ 
X+ int
X+ _copyfile(from, to)
X+ {
X+ 	int fromfd, tofd, r;
X+ 	char *buf;
X+ 
X+ 	if ((fromfd = open(from, O_RDONLY|O_BINARY, 0)) < 0)
X+ 		return -1;
X+ 	if ((tofd = open(to, O_WRONLY|O_CREAT|O_TRUNC|O_BINARY, FCMASK)) < 0)
X+ 		return -1;
X+ 	if (!(buf = (char *)malloc((size_t)BIGBUF)))
X+ 		return -1;
X+ 	while ( (r = read(fromfd, buf, BIGBUF)) > 0)
X+ 		write(tofd, buf, r);
X+ 	close(fromfd);
X+ 	close(tofd);
X+ 	free(buf);
X+ 	return 0;	/* successful */
X+ }
X+ 
X+ int kbhit()
X+ {
X+ 	return Cconis();
X+ }
X+ #endif /* TOS */
X*** others/Old/oldtos.c	Mon Jul 31 13:39:38 1989
X--- others/oldtos.c	Mon Jul 31 12:10:02 1989
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)tos.c	3.0	88/11/09
X   * An assortment of functions for the Atari with Lattice C compiler.
X   * Adapted from a similar set for MSDOS (written by Don Kneller) by
X   * R. Black (Louisville, CO).
X--- 1,4 ----
X! /*	SCCS Id: @(#)oldtos.c	3.0	88/11/09
X   * An assortment of functions for the Atari with Lattice C compiler.
X   * Adapted from a similar set for MSDOS (written by Don Kneller) by
X   * R. Black (Louisville, CO).
X***************
X*** 6,12 ****
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X  #include "hack.h"
X- #include "osbind.h"
X  
X  extern int errno;
X  
X--- 6,11 ----
X*** others/Old/pcmain.c	Mon Jul 31 13:40:29 1989
X--- others/pcmain.c	Fri Jul 28 17:53:43 1989
X***************
X*** 3,14 ****
X  /* NetHack may be freely redistributed.  See license for details. */
X  /* main.c - (PC, TOS and AMIGA) version */
X  
X! #ifndef TOS
X  #include <signal.h>
X- #else
X- #define msmsg	cprintf
X  #endif
X- #include "hack.h"
X  
X  char orgdir[PATHLEN];
X  
X--- 3,12 ----
X  /* NetHack may be freely redistributed.  See license for details. */
X  /* main.c - (PC, TOS and AMIGA) version */
X  
X! #include "hack.h"
X! #ifndef NO_SIGNAL
X  #include <signal.h>
X  #endif
X  
X  char orgdir[PATHLEN];
X  
X***************
X*** 18,27 ****
X  int (*afternmv)(), (*occupation)();
X  static void moveloop();	/* a helper function for MSC optimizer */
X  
X! #if defined(DGK) && !defined(TOS)
X  struct finfo	zfinfo = ZFINFO;
X  int i;
X! #endif /* DGK && !TOS */
X  
X  char SAVEF[FILENAME];
X  char *hname = "NetHack";	/* used for syntax messages */
X--- 16,25 ----
X  int (*afternmv)(), (*occupation)();
X  static void moveloop();	/* a helper function for MSC optimizer */
X  
X! #if defined(DGK) && !defined(OLD_TOS)
X  struct finfo	zfinfo = ZFINFO;
X  int i;
X! #endif /* DGK && !OLD_TOS */
X  
X  char SAVEF[FILENAME];
X  char *hname = "NetHack";	/* used for syntax messages */
X***************
X*** 35,41 ****
X  extern unsigned char _osmajor;
X  #endif
X  
X! #ifdef TOS
X  #define OMASK	0x8000
X  #else
X  #define OMASK	0
X--- 33,43 ----
X  extern unsigned char _osmajor;
X  #endif
X  
X! #if defined(TOS) && defined(__GNUC__)
X! long _stksize = 16*1024;
X! #endif
X! 
X! #ifdef OLD_TOS
X  #define OMASK	0x8000
X  #else
X  #define OMASK	0
X***************
X*** 62,67 ****
X--- 64,74 ----
X  	 */
X  	int (*funcp)();
X  
X+ #if defined(TOS) && defined(__GNUC__)
X+ 	extern int _unixmode;
X+ 	_unixmode = 0;
X+ #endif
X+ 
X  # ifdef __TURBOC__
X  	if (_osmajor >= 3) hname = argv[0];	/* DOS 3.0+ */
X  # endif
X***************
X*** 72,78 ****
X  	funcp = exit;	/* Kludge to get around LINT_ARGS of signal.
X  			 * This will produce a compiler warning, but that's OK.
X  			 */
X! # ifndef TOS
X  	signal(SIGINT, (SIG_RET_TYPE) funcp);	/* restore original directory */
X  # endif
X  #endif /* AMIGA */
X--- 79,85 ----
X  	funcp = exit;	/* Kludge to get around LINT_ARGS of signal.
X  			 * This will produce a compiler warning, but that's OK.
X  			 */
X! # ifndef NO_SIGNAL
X  	signal(SIGINT, (SIG_RET_TYPE) funcp);	/* restore original directory */
X  # endif
X  #endif /* AMIGA */
X***************
X*** 85,95 ****
X  		chdirx (dir, 1);
X  #endif
X  	}
X! #if defined(DGK) && !defined(TOS)
X  	/* zero "fileinfo" array to prevent crashes on level change */
X! 	for (i = 0 ; i <= MAXLEVEL + 1; i++)
X  		fileinfo[i] = zfinfo;
X! #endif /* DGK && !TOS */
X  	initoptions();
X  	if (!hackdir[0])
X  		Strcpy(hackdir, orgdir);
X--- 92,103 ----
X  		chdirx (dir, 1);
X  #endif
X  	}
X! #if defined(DGK) && !defined(OLD_TOS)
X  	/* zero "fileinfo" array to prevent crashes on level change */
X! 	for (i = 0 ; i <= MAXLEVEL; i++) {
X  		fileinfo[i] = zfinfo;
X! 	}
X! #endif /* DGK && !OLD_TOS */
X  	initoptions();
X  	if (!hackdir[0])
X  		Strcpy(hackdir, orgdir);
X***************
X*** 141,147 ****
X  	cls();
X  	u.uhp = 1;	/* prevent RIP on early quits */
X  	u.ux = FAR;	/* prevent nscr() */
X! #ifndef TOS
X  	/*
X  	 * We cannot do chdir earlier, otherwise gethdate will fail.
X  	 */
X--- 149,155 ----
X  	cls();
X  	u.uhp = 1;	/* prevent RIP on early quits */
X  	u.ux = FAR;	/* prevent nscr() */
X! #ifndef OLD_TOS
X  	/*
X  	 * We cannot do chdir earlier, otherwise gethdate will fail.
X  	 */
X***************
X*** 255,261 ****
X  #endif /* DGK */
X  	    ((fd = open(SAVEF, OMASK)) >= 0) &&
X  	    (uptodate(fd) || !unlink(SAVEF))) {
X! #ifndef TOS
X  		(void) signal(SIGINT, (SIG_RET_TYPE) done1);
X  #endif
X  		pline("Restoring old save file...");
X--- 263,269 ----
X  #endif /* DGK */
X  	    ((fd = open(SAVEF, OMASK)) >= 0) &&
X  	    (uptodate(fd) || !unlink(SAVEF))) {
X! #ifndef NO_SIGNAL
X  		(void) signal(SIGINT, (SIG_RET_TYPE) done1);
X  #endif
X  		pline("Restoring old save file...");
X***************
X*** 286,292 ****
X  		flags.ident = 1;
X  		init_objects();
X  		u_init();
X! #ifndef TOS
X  		(void) signal(SIGINT, (SIG_RET_TYPE) done1);
X  #endif
X  		mklev();
X--- 294,300 ----
X  		flags.ident = 1;
X  		init_objects();
X  		u_init();
X! #ifndef NO_SIGNAL
X  		(void) signal(SIGINT, (SIG_RET_TYPE) done1);
X  #endif
X  		mklev();
X***************
X*** 323,329 ****
X  	}
X  
X  	initrack();
X! #ifndef TOS
X  	(void) signal(SIGINT, SIG_IGN);
X  #endif
X  	/* Help for Microsoft optimizer.  Otherwise main is too large -dgk*/
X--- 331,337 ----
X  	}
X  
X  	initrack();
X! #ifndef NO_SIGNAL
X  	(void) signal(SIGINT, SIG_IGN);
X  #endif
X  	/* Help for Microsoft optimizer.  Otherwise main is too large -dgk*/
X*** others/Old/pcunix.c	Mon Jul 31 13:41:26 1989
X--- others/pcunix.c	Fri Jul 28 17:54:01 1989
X***************
X*** 15,21 ****
X  
X  #include "hack.h"	/* mainly for index() which depends on BSD */
X  #ifdef TOS
X! #ifdef UNIXDEBUG
X  #include <errno.h>
X  #else
X  #include <error.h>
X--- 15,21 ----
X  
X  #include "hack.h"	/* mainly for index() which depends on BSD */
X  #ifdef TOS
X! #ifndef OLD_TOS
X  #include <errno.h>
X  #else
X  #include <error.h>
X***************
X*** 25,31 ****
X  #include	<sys/types.h>
X  #include	<sys/stat.h>
X  
X! #ifndef TOS
X  static struct stat buf, hbuf;
X  void
X  setrandom()
X--- 25,31 ----
X  #include	<sys/types.h>
X  #include	<sys/stat.h>
X  
X! #ifndef OLD_TOS
X  static struct stat buf, hbuf;
X  void
X  setrandom()
X***************
X*** 95,100 ****
X--- 95,101 ----
X  gethdate(name)
X  char *name;
X  {
X+ #if defined(TOS) && !defined(__GNUC__)
X  /* old version - for people short of space */
X  /*
X  /* register char *np;
X***************
X*** 134,143 ****
X--- 135,146 ----
X  	path = np + 1;
X      }
X      error("Cannot get status of %s.", (np = rindex(name, '/')) ? np+1 : name);
X+ #endif /* TOS && __GNUC__ */
X  }
X  
X  int
X  uptodate(fd) {
X+ #if defined(TOS) && !defined(__GNUC__) /* no fstat yet */
X      if(fstat(fd, &buf)) {
X  	pline("Cannot get status of saved level? ");
X  	return(0);
X***************
X*** 146,154 ****
X  	pline("Saved level is out of date. ");
X  	return(0);
X      }
X      return(1);
X  }
X! #endif /* TOS /* */
X  
X  void
X  regularize(s)	/* normalize file name - we don't like .'s, /'s, spaces */
X--- 149,158 ----
X  	pline("Saved level is out of date. ");
X  	return(0);
X      }
X+ #endif
X      return(1);
X  }
X! #endif /* MIN_TOS /* */
X  
X  void
X  regularize(s)	/* normalize file name - we don't like .'s, /'s, spaces */
END_OF_FILE
if test 47044 -ne `wc -c <'misc.diff'`; then
    echo shar: \"'misc.diff'\" unpacked with wrong size!
fi
# end of 'misc.diff'
fi
echo shar: End of archive 2 \(of 6\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 3 4 5 6 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 6 archives.
    echo "now type ./do_patch.sh"
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
