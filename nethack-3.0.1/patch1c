Path: utzoo!utgpu!jarvis.csri.toronto.edu!rutgers!cs.utexas.edu!uunet!zephyr.ens.tek.com!tekgen!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v07i096:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Patch1c
Message-ID: <4390@tekred.CNA.TEK.COM>
Date: 3 Aug 89 16:58:00 GMT
Sender: nobody@tekred.CNA.TEK.COM
Lines: 2135
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 7, Issue 96
Archive-name: NetHack3/Patch1c
Patch-To: NetHack3: Volume 7, Issue 56-93



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 3 (of 6)."
# Contents:  src1.diff
# Wrapped by billr@saab on Thu Aug  3 09:57:11 1989
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'src1.diff' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src1.diff'\"
else
echo shar: Extracting \"'src1.diff'\" \(54643 characters\)
sed "s/^X//" >'src1.diff' <<'END_OF_FILE'
XSource patches, part 1
X
X------------------------------------Cut------------------------------------
X*** src/Old/Makefile.src	Mon Jul 31 13:42:55 1989
X--- src/Makefile.src	Mon Jul 31 12:40:38 1989
X***************
X*** 26,31 ****
X--- 26,40 ----
X  # Systos wants 'pc'; everything else normally wants 'unix'
X  TARG = unix
X  
X+ # if you are using gcc as your compiler:
X+ #	add -fwritable-strings to your other CFLAGS
X+ #	uncomment the CC definition below if it's not in your environment
X+ #	ignore warnings about initializing non-const *s from const *s
X+ #	if you get setcgtty() warnings during execution, you are feeding gcc
X+ #		a non-ANSI <sys/ioctl.h> -- either run fixincludes on it or use
X+ #		-traditional in CFLAGS
X+ # CC = gcc
X+ 
X  # flags may have to be changed as required
X  # flags for 286 Xenix:
X  # CFLAGS = -O -Gt24 -LARGE -Ml -I../include
X***************
X*** 60,67 ****
X  # if, instead of yacc/lex you have bison/flex, comment/uncomment the following.
X  YACC     = yacc
X  LEX      = lex
X! #YACC     = bison
X! #LEX      = flex
X  
X  # make NetHack
X  GAME     = nethack
X--- 69,76 ----
X  # if, instead of yacc/lex you have bison/flex, comment/uncomment the following.
X  YACC     = yacc
X  LEX      = lex
X! # YACC     = bison -y
X! # LEX      = flex
X  
X  # make NetHack
X  GAME     = nethack
X***************
X*** 85,96 ****
X  	   mthrowu.c music.c o_init.c objects.c objnam.c options.c pager.c\
X  	   pickup.c polyself.c potion.c pray.c pri.c priest.c prisym.c read.c\
X   	   restore.c rip.c rnd.c rumors.c save.c search.c shk.c shknam.c sit.c\
X! 	   sounds.c sp_lev.c spell.c steal.c termcap.c timeout.c topl.c topten.c\
X! 	   track.c trap.c u_init.c uhitm.c vault.c version.c weapon.c were.c\
X! 	   wield.c wizard.c worm.c worn.c write.c zap.c
X  
X! # all .c files but msdos.c, tos.c, *main.c, *tty.c, *unix.c, (system specific)
X! # and makedefs.c, lev_comp.c, panic.c (not part of any nethack)
X  
X  CSOURCES = $(HACKCSRC) $(TARG)main.c $(TARG)main.c $(TARG)main.c makedefs.c panic.c
X  
X--- 94,104 ----
X  	   mthrowu.c music.c o_init.c objects.c objnam.c options.c pager.c\
X  	   pickup.c polyself.c potion.c pray.c pri.c priest.c prisym.c read.c\
X   	   restore.c rip.c rnd.c rumors.c save.c search.c shk.c shknam.c sit.c\
X! 	   sounds.c sp_lev.c spell.c steal.c termcap.c timeout.c topl.c\
X! 	   topten.c track.c trap.c u_init.c uhitm.c vault.c version.c weapon.c\
X! 	   were.c wield.c wizard.c worm.c worn.c write.c zap.c
X  
X! # all .c that are part of the main NetHack program and are not system specific
X  
X  CSOURCES = $(HACKCSRC) $(TARG)main.c $(TARG)main.c $(TARG)main.c makedefs.c panic.c
X  
X***************
X*** 144,152 ****
X  	@$(LD) $(LFLAGS) /lib/crt0s.o /lib/shlib.ifile -o $(GAME) $(HOBJ)
X  	@touch Sysatt
X  
X! Systos:	$(HOBJ) tos.o Makefile
X  	@echo "Loading ..."
X! 	@$(CC) $(LFLAGS) -o $(GAME) $(HOBJ) tos.o $(TERMLIB)
X  	@touch Systos
X  
X  SysV-AT:	DUMB.Setup $(HOBJ) Makefile
X--- 152,160 ----
X  	@$(LD) $(LFLAGS) /lib/crt0s.o /lib/shlib.ifile -o $(GAME) $(HOBJ)
X  	@touch Sysatt
X  
X! Systos:	$(HOBJ) oldtos.o Makefile
X  	@echo "Loading ..."
X! 	@$(CC) $(LFLAGS) -o $(GAME) $(HOBJ) oldtos.o $(TERMLIB)
X  	@touch Systos
X  
X  SysV-AT:	DUMB.Setup $(HOBJ) Makefile
X***************
X*** 351,357 ****
X  	@rm -f Makefile.bak
X  
X  # PC dependency for Systos that won't be made on a UNIX system
X! tos.o:	../include/hack.h ../include/osbind.h
X  
X  # DO NOT DELETE THIS LINE
X  
X--- 359,365 ----
X  	@rm -f Makefile.bak
X  
X  # PC dependency for Systos that won't be made on a UNIX system
X! oldtos.o:  ../include/hack.h
X  
X  # DO NOT DELETE THIS LINE
X  
X*** src/Old/apply.c	Mon Jul 31 13:44:15 1989
X--- src/apply.c	Sat Jul 29 12:04:03 1989
X***************
X*** 158,163 ****
X--- 158,167 ----
X  	if(lev->mmask) {
X  		mtmp = m_at(rx,ry);
X  		mstatusline(mtmp);
X+ 		if (mtmp->mundetected) {
X+ 			mtmp->mundetected = 0;
X+ 			if (cansee(rx,ry)) pmon(mtmp);
X+ 		}
X  		return;
X  	}
X  	if(lev->typ == SDOOR) {
X***************
X*** 491,497 ****
X--- 495,508 ----
X  			lev->typ = CORR;
X  			digtxt = "You succeeded in cutting away some rock.";
X  		} else if(IS_WALL(lev->typ)) {
X+ #ifdef STUPID
X+ 		        if (is_maze_lev)
X+ 			    lev->typ = ROOM;
X+ 			else
X+ 			    lev->typ = DOOR;
X+ #else
X  			lev->typ = is_maze_lev ? ROOM : DOOR;
X+ #endif
X  			digtxt = "You just made an opening in the wall.";
X  		} else if(lev->typ == SDOOR) {
X  			lev->typ = DOOR;
X***************
X*** 1006,1011 ****
X--- 1017,1023 ----
X  	    if (uwep->spe > 0 && !rn2(3)) {
X  		uwep->spe = 0;
X  		djinni_from_bottle(uwep);
X+ 		makeknown(MAGIC_LAMP);
X  	    } else if (rn2(2) && !Blind)
X  		You("see a puff of smoke.");
X  	    else pline(nothing_happens);
X*** src/Old/artifact.c	Mon Jul 31 13:45:11 1989
X--- src/artifact.c	Tue Jul 25 14:39:11 1989
X***************
X*** 11,17 ****
X  /* the artifacts (currently weapons only) */
X  static const struct artifact artilist[] = {
X  
X! #define	    NO_ATTK	0, 0, 0, 0
X  
X  { LONG_SWORD,	 "Excalibur",	(SPFX_NOGEN | SPFX_SEEK | SPFX_DEFN |
X  								SPFX_SEARCH), 0,
X--- 11,17 ----
X  /* the artifacts (currently weapons only) */
X  static const struct artifact artilist[] = {
X  
X! #define	    NO_ATTK	{ 0, 0, 0, 0 }
X  
X  { LONG_SWORD,	 "Excalibur",	(SPFX_NOGEN | SPFX_SEEK | SPFX_DEFN |
X  								SPFX_SEARCH), 0,
X*** src/Old/bones.c	Mon Jul 31 13:46:09 1989
X--- src/bones.c	Fri Jul 28 17:53:10 1989
X***************
X*** 4,10 ****
X  
X  #include "hack.h"
X  
X! #ifdef TOS
X  #define OMASK	0x8000
X  #else
X  #define OMASK	0
X--- 4,10 ----
X  
X  #include "hack.h"
X  
X! #ifdef OLD_TOS
X  #define OMASK	0x8000
X  #else
X  #define OMASK	0
X***************
X*** 12,17 ****
X--- 12,20 ----
X  
X  #ifdef DGK
X  char bones[FILENAME];
X+ #ifndef OLD_TOS
X+ extern long bytes_counted;
X+ #endif
X  #else
X  char bones[] = "bones.xx";
X  #endif
X***************
X*** 49,54 ****
X--- 52,58 ----
X  		);
X  }
X  
X+ #ifdef TUTTI_FRUTTI
X  static void
X  goodfruit(id)
X  int id;
X***************
X*** 62,67 ****
X--- 66,72 ----
X  		}
X  	}
X  }
X+ #endif
X  
X  /* save bones and possessions of a deceased adventurer */
X  void
X***************
X*** 70,76 ****
X--- 75,83 ----
X  	register struct obj *otmp;
X  	register struct trap *ttmp;
X  	register struct monst *mtmp, *mtmp2;
X+ #ifdef TUTTI_FRUTTI
X  	struct fruit *f;
X+ #endif
X  
X  	if(dlevel <= 0 || dlevel > MAXLEVEL) return;
X  	if(no_bones_level(dlevel)) return; /* no bones for specific levels */
X***************
X*** 113,122 ****
X--- 120,131 ----
X  		if(mtmp->data == &mons[PM_MEDUSA]) mongone(mtmp);
X  #endif
X  	}
X+ #ifdef TUTTI_FRUTTI
X  	/* mark all fruits as nonexistent; when we come to them we'll mark
X  	 * them as existing (using goodfruit())
X  	 */
X  	for(f=ffruit; f; f=f->nextf) f->fid = -f->fid;
X+ #endif
X  
X  	/* drop everything; the corpse's possessions are usually cursed */
X  	otmp = invent;
X***************
X*** 124,130 ****
X--- 133,141 ----
X  		otmp->ox = u.ux;
X  		otmp->oy = u.uy;
X  		otmp->owornmask = 0;
X+ #ifdef TUTTI_FRUTTI
X  		if(otmp->otyp == SLIME_MOLD) goodfruit(otmp->spe);
X+ #endif
X  		if(rn2(5)) curse(otmp);
X  		if(!otmp->nobj){
X  			otmp->nobj = fobj;
X***************
X*** 160,166 ****
X--- 171,179 ----
X  	for(mtmp = fmon; mtmp; mtmp = mtmp->nmon){
X  		for(otmp = mtmp->minvent; otmp; otmp = otmp->nobj) {
X  		    otmp->dknown = otmp->bknown = 0;
X+ #ifdef TUTTI_FRUTTI
X  		    if(otmp->otyp == SLIME_MOLD) goodfruit(otmp->spe);
X+ #endif
X  		    if(uses_known(otmp)) otmp->known = 0;
X  		    if(otmp->otyp == AMULET_OF_YENDOR && !otmp->spe) {
X  			otmp->spe = -1;  /* no longer the actual amulet */
X***************
X*** 186,192 ****
X--- 199,207 ----
X  		   )
X  			otmp->onamelth = 0;
X  		if(uses_known(otmp)) otmp->known = 0;
X+ #ifdef TUTTI_FRUTTI
X  		if(otmp->otyp == SLIME_MOLD) goodfruit(otmp->spe);
X+ #endif
X  		otmp->dknown = otmp->bknown = 0;
X  		otmp->invlet = 0;
X  #ifdef MAIL
X***************
X*** 218,226 ****
X  #endif
X  		return;
X  	}
X  	savefruitchn(fd);
X! #ifdef DGK
X! 	savelev(fd,dlevel, COUNT | WRITE);
X  #else
X  	savelev(fd,dlevel);
X  #endif
X--- 233,262 ----
X  #endif
X  		return;
X  	}
X+ 
X+ #if defined(DGK) && !defined(OLD_TOS)	/* check whether there is room */
X+ 	count_only = TRUE;
X+ #ifdef TUTTI_FRUTTI
X  	savefruitchn(fd);
X! #endif
X! 	savelev(fd, dlevel, COUNT);
X! 	bflush(fd);
X! 	if (bytes_counted > freediskspace(bones)) {	/* not enough room */
X! #ifdef WIZARD
X! 		if (wizard)
X! 			pline("Insufficient space to create bones file.");
X! #endif
X! 		unlink(bones);
X! 		return;
X! 	}
X! 	count_only = FALSE;
X! #endif /* DGK */
X! 
X! #ifdef TUTTI_FRUTTI
X! 	savefruitchn(fd);
X! #endif
X! #if defined(DGK) && !defined(OLD_TOS)
X! 	savelev(fd, dlevel, WRITE);
X  #else
X  	savelev(fd,dlevel);
X  #endif
X*** src/Old/cmd.c	Mon Jul 31 13:46:45 1989
X--- src/cmd.c	Thu Jul 27 11:22:54 1989
X***************
X*** 50,56 ****
X  extern int dowhatdoes(); /**/
X  extern int dohelp(); /**/
X  extern int dohistory(); /**/
X- extern int dosh(); /**/
X  extern int doloot(); /**/
X  extern int dodrink(); /**/
X  extern int dodip(); /**/
X--- 50,55 ----
X*** src/Old/dbridge.c	Mon Jul 31 13:47:32 1989
X--- src/dbridge.c	Mon Jul 24 18:19:07 1989
X***************
X*** 256,262 ****
X  		/* So, you didn't die */
X  		pline("A %s force teleports you away...",
X  		      Hallucination ? "normal" : "strange");
X! 		enexto(&xy, x2, y2);
X  		teleds(xy.x, xy.y);
X  	}
X  	redosym(x,y);
X--- 256,262 ----
X  		/* So, you didn't die */
X  		pline("A %s force teleports you away...",
X  		      Hallucination ? "normal" : "strange");
X! 		enexto(&xy, x2, y2, &playermon);
X  		teleds(xy.x, xy.y);
X  	}
X  	redosym(x,y);
X***************
X*** 358,364 ****
X  		/* So, you didn't die */
X  		pline("A %s force teleports you away...",
X  		      Hallucination ? "normal" : "strange");
X! 		enexto(&xy, x2, y2);
X  		teleds(xy.x, xy.y);
X  	}
X  	redosym(x,y);
X--- 358,364 ----
X  		/* So, you didn't die */
X  		pline("A %s force teleports you away...",
X  		      Hallucination ? "normal" : "strange");
X! 		enexto(&xy, x2, y2, &playermon);
X  		teleds(xy.x, xy.y);
X  	}
X  	redosym(x,y);
X*** src/Old/decl.c	Mon Jul 31 13:48:08 1989
X--- src/decl.c	Sun Jul 30 11:30:32 1989
X***************
X*** 46,54 ****
X--- 46,58 ----
X  const char nul[40] = DUMMY;		/* contains zeros */
X  char plname[PL_NSIZ] = DUMMY;		/* player name */
X  char pl_character[PL_CSIZ] = DUMMY;
X+ 
X+ #ifdef TUTTI_FRUTTI
X  char pl_fruit[PL_FSIZ] = DUMMY;
X  int current_fruit = 0;
X  struct fruit *ffruit = 0;
X+ #endif
X+ 
X  #ifdef STRONGHOLD
X  char tune[6] = DUMMY;
X  #  ifdef MUSIC
X***************
X*** 55,60 ****
X--- 59,65 ----
X  schar music_heard = 0;
X  #  endif
X  #endif
X+ 
X  char *occtxt = DUMMY;
X  const char quitchars[] = " \r\n\033";
X  const char vowels[] = "aeiouAEIOU";
X***************
X*** 75,80 ****
X--- 80,86 ----
X  const char *configfile = "NetHack.cnf";	/* read by read_config_file() */
X  char levels[PATHLEN];		/* where levels are */
X  #endif /* MSDOS */
X+ 
X  #ifdef DGK
X  char lock[FILENAME];		/* pathname of level files */
X  char permbones[PATHLEN];	/* where permanent copy of bones go */
X***************
X*** 109,114 ****
X--- 115,122 ----
X  boolean in_mklev = FALSE;
X  boolean	stoned = FALSE;			/* done to monsters hit by 'c' */
X  boolean	unweapon = FALSE;
X+ boolean mrg_to_wielded = FALSE; /* weapon picked is merged with wielded one */
X+ 
X  #ifdef KOPS
X  boolean allow_kops = TRUE;
X  #endif
X*** src/Old/do.c	Mon Jul 31 13:49:10 1989
X--- src/do.c	Fri Jul 28 17:53:13 1989
X***************
X*** 6,12 ****
X  
X  #include "hack.h"
X  
X! #if defined(DGK) && !defined(TOS)
X  extern struct finfo fileinfo[];
X  #else
X  extern boolean level_exists[];
X--- 6,12 ----
X  
X  #include "hack.h"
X  
X! #if defined(DGK) && !defined(OLD_TOS)
X  extern struct finfo fileinfo[];
X  #else
X  extern boolean level_exists[];
X***************
X*** 106,112 ****
X--- 106,116 ----
X  		pline("The sink quivers upward for a moment.");
X  		break;
X  	    case RIN_POISON_RESISTANCE:
X+ #ifdef TUTTI_FRUTTI
X  		You("smell rotten %s.", makeplural(pl_fruit));
X+ #else
X+ 		You("smell rotten fruit.");
X+ #endif
X  		break;
X  	    case RIN_AGGRAVATE_MONSTER:
X  		pline("Several flies buzz angrily around the sink.");
X***************
X*** 591,597 ****
X  # ifdef ENDGAME
X  	   dlevel == ENDLEVEL ||
X  # endif
X! #if defined(DGK) && !defined(TOS)
X  	/* If the level has no .where yet, it hasn't been made */
X  	   !fileinfo[dlevel].where)
X  #else
X--- 595,601 ----
X  # ifdef ENDGAME
X  	   dlevel == ENDLEVEL ||
X  # endif
X! #if defined(DGK) && !defined(OLD_TOS)
X  	/* If the level has no .where yet, it hasn't been made */
X  	   !fileinfo[dlevel].where)
X  #else
X***************
X*** 599,605 ****
X  #endif
X  		mklev();
X  	else {
X! #if defined(DGK) && !defined(TOS)
X  		/* If not currently accessible, swap it in. */
X  		if (fileinfo[dlevel].where != ACTIVE)
X  			swapin_file(dlevel);
X--- 603,609 ----
X  #endif
X  		mklev();
X  	else {
X! #if defined(DGK) && !defined(OLD_TOS)
X  		/* If not currently accessible, swap it in. */
X  		if (fileinfo[dlevel].where != ACTIVE)
X  			swapin_file(dlevel);
X*** src/Old/do_wear.c	Mon Jul 31 13:50:44 1989
X--- src/do_wear.c	Sun Jul 30 21:04:15 1989
X***************
X*** 861,866 ****
X--- 861,867 ----
X  		else setworn((struct obj *)0, otmp->owornmask & W_ARMOR);
X  		off_msg(otmp);
X  	}
X+ 	takeoff_mask = taking_off = 0L;
X  	return(1);
X  }
X  
X***************
X*** 986,991 ****
X--- 987,993 ----
X  /*		if(is_shield(otmp)) (void) Shield_on(); */
X  		on_msg(otmp);
X  	}
X+ 	takeoff_mask = taking_off = 0L;
X  	return(1);
X  }
X  
X***************
X*** 1132,1141 ****
X  }
X  
X  void
X! glibr(){
X! register struct obj *otmp;
X! int xfl = 0;
X! 	if(!uarmg) if(uleft || uright)
X  #ifdef POLYSELF
X  				if(!nolimbs(uasmon))
X  #endif
X--- 1134,1154 ----
X  }
X  
X  void
X! glibr()
X! {
X! 	register struct obj *otmp;
X! 	int xfl = 0;
X! #ifdef HARD
X! 	boolean leftfall, rightfall;
X! 
X! 	leftfall = (uleft && !uleft->cursed && (!uwep || !uwep->cursed));
X! 	rightfall = (uright && !uright->cursed && (!uwep || !uwep->cursed
X! 		|| !bimanual(uwep)));
X! #else
X! #define leftfall uleft
X! #define rightfall uright
X! #endif
X! 	if(!uarmg) if(leftfall || rightfall)
X  #ifdef POLYSELF
X  				if(!nolimbs(uasmon))
X  #endif
X***************
X*** 1143,1160 ****
X  		/* Note: at present also cursed rings fall off */
X  		/* changed 10/30/86 by GAN */
X  		Your("%s off your %s.",
X! #ifdef HARD
X! 			((uleft && !uleft->cursed) && (uright && !uright->cursed)) ? "rings slip" : "ring slips",
X! #else
X! 			(uleft && uright) ? "rings slip" : "ring slips",
X! #endif
X  			makeplural(body_part(FINGER)));
X  		xfl++;
X! 		if((otmp = uleft) != (struct obj *)0){
X  			Ring_off(uleft);
X  			dropx(otmp);
X  		}
X! 		if((otmp = uright) != (struct obj *)0){
X  			Ring_off(uright);
X  			dropx(otmp);
X  		}
X--- 1156,1171 ----
X  		/* Note: at present also cursed rings fall off */
X  		/* changed 10/30/86 by GAN */
X  		Your("%s off your %s.",
X! 			(leftfall && rightfall) ? "rings slip" : "ring slips",
X  			makeplural(body_part(FINGER)));
X  		xfl++;
X! 		if(leftfall) {
X! 			otmp = uleft;
X  			Ring_off(uleft);
X  			dropx(otmp);
X  		}
X! 		if(rightfall) {
X! 			otmp = uright;
X  			Ring_off(uright);
X  			dropx(otmp);
X  		}
X*** src/Old/dog.c	Mon Jul 31 13:51:44 1989
X--- src/dog.c	Tue Jul 25 14:37:41 1989
X***************
X*** 229,239 ****
X  	    switch (obj->otyp) {
X  		case TRIPE_RATION:
X  		    return (carn ? DOGFOOD : MANFOOD);
X- 		case CORPSE:
X  		case EGG:
X! 		    if ((obj->age + 50 <= moves && mon->data->mlet != S_FUNGUS) ||
X! 			(poisonous(&mons[obj->corpsenm]) && !resists_poison(mon->data)) ||
X! 			(obj->corpsenm == PM_COCKATRICE && !resists_ston(mon->data)))
X  			return POISON;
X  		    else return (carn ? CADAVER : MANFOOD);
X  		case DEAD_LIZARD:
X--- 229,243 ----
X  	    switch (obj->otyp) {
X  		case TRIPE_RATION:
X  		    return (carn ? DOGFOOD : MANFOOD);
X  		case EGG:
X! 		    if (obj->corpsenm == PM_COCKATRICE &&
X! 						!resists_ston(mon->data))
X! 			return POISON;
X! 		    return (carn ? CADAVER : MANFOOD);
X! 		case CORPSE:
X! 		    if ((obj->age+50 <= moves && mon->data->mlet != S_FUNGUS) ||
X! 			(poisonous(&mons[obj->corpsenm]) &&
X! 						!resists_poison(mon->data)))
X  			return POISON;
X  		    else return (carn ? CADAVER : MANFOOD);
X  		case DEAD_LIZARD:
X*** src/Old/dogmove.c	Mon Jul 31 13:52:17 1989
X--- src/dogmove.c	Tue Jul 25 21:33:11 1989
X***************
X*** 335,352 ****
X  
X  		nx = sgn(omx - u.ux);
X  		ny = sgn(omy - u.uy);
X! 		if(goodpos((cc.x = u.ux+nx), (cc.y = u.uy+ny))) goto dognext;
X  
X  	 	i  = xytod(nx, ny);
X  		for(j = (i + 7)%8; j < (i + 1)%8; j++) {
X! 
X! 		   dtoxy(&cc, j);
X! 		   if(goodpos(cc.x, cc.y)) goto dognext;
X  		}
X  		for(j = (i + 6)%8; j < (i + 2)%8; j++) {
X! 
X! 		   dtoxy(&cc, j);
X! 		   if(goodpos(cc.x, cc.y)) goto dognext;
X  		}
X  		cc.x = mtmp->mx;
X  		cc.y = mtmp->my;
X--- 335,351 ----
X  
X  		nx = sgn(omx - u.ux);
X  		ny = sgn(omy - u.uy);
X! 		if(goodpos((cc.x = u.ux+nx), (cc.y = u.uy+ny), mtmp->data))
X! 			goto dognext;
X  
X  	 	i  = xytod(nx, ny);
X  		for(j = (i + 7)%8; j < (i + 1)%8; j++) {
X! 			dtoxy(&cc, j);
X! 			if(goodpos(cc.x, cc.y, mtmp->data)) goto dognext;
X  		}
X  		for(j = (i + 6)%8; j < (i + 2)%8; j++) {
X! 			dtoxy(&cc, j);
X! 			if(goodpos(cc.x, cc.y, mtmp->data)) goto dognext;
X  		}
X  		cc.x = mtmp->mx;
X  		cc.y = mtmp->my;
X*** src/Old/dokick.c	Mon Jul 31 13:53:05 1989
X--- src/dokick.c	Mon Jul 31 09:37:37 1989
X***************
X*** 46,53 ****
X  # endif
X  	}
X  	
X! 	mon->mhp -= (!martial() ? rnd(dmg) : rnd(dmg)+rnd(ACURR(A_DEX)/2));  
X  	if(mon->mhp < 1) {
X  		killed(mon);
X  		return;
X  	}
X--- 46,56 ----
X  # endif
X  	}
X  	
X! 	if (dmg)
X! 		mon->mhp -= (!martial() ? rnd(dmg) :
X! 			rnd(dmg)+rnd(ACURR(A_DEX)/2));  
X  	if(mon->mhp < 1) {
X+ 		(void) passive(mon, TRUE, 0);
X  		killed(mon);
X  		return;
X  	}
X***************
X*** 55,62 ****
X  	    	/* see if the monster has a place to move into */
X  	    	mdx = mon->mx + u.dx;
X  	    	mdy = mon->my + u.dy;
X! 	    	if(goodpos(mdx, mdy)) {
X! 			pline("%s reels from the blow.", Monnam(mon));
X  			levl[mon->mx][mon->my].mmask = 0;
X  			levl[mdx][mdy].mmask = 1;
X  			mon->mx = mdx;
X--- 58,65 ----
X  	    	/* see if the monster has a place to move into */
X  	    	mdx = mon->mx + u.dx;
X  	    	mdy = mon->my + u.dy;
X! 	    	if(goodpos(mdx, mdy, mon->data)) {
X! 			kludge("%s reels from the blow.", Monnam(mon));
X  			levl[mon->mx][mon->my].mmask = 0;
X  			levl[mdx][mdy].mmask = 1;
X  			mon->mx = mdx;
X***************
X*** 65,70 ****
X--- 68,74 ----
X  			set_apparxy(mon);
X  	    	}
X  	}
X+ 	(void) passive(mon, FALSE, 1);
X  
X  /*	it is unchivalrous to attack the defenseless or from behind */
X  	if (pl_character[0] == 'K' && u.ualigntyp == U_LAWFUL && 
X***************
X*** 92,100 ****
X  
X  	setmangry(mon);
X  
X! 	if(Levitation && !rn2(3) && verysmall(mon->data) && 
X! 			!is_floater(mon->data) && !is_flyer(mon->data)) {
X! 		You("are floating in the air, and miss wildly!");
X  		return;
X  	}
X  
X--- 96,105 ----
X  
X  	setmangry(mon);
X  
X! 	if(Levitation && !rn2(3) && verysmall(mon->data) &&
X! 	   !is_flyer(mon->data)) {
X! 		pline("Floating in the air, you miss wildly!");
X! 		(void) passive(mon, FALSE, 1);
X  		return;
X  	}
X  
X***************
X*** 105,110 ****
X--- 110,116 ----
X  		if(!rn2((i < j/10) ? 2 : (i < j/5) ? 3 : 4)) {
X  			if(martial() && !rn2(2)) goto doit;
X  			Your("clumsy kick does no damage.");
X+ 			(void) passive(mon, FALSE, 1);
X  			return;
X  		}
X  		if(i < j/10) clumsy = TRUE;
X***************
X*** 118,132 ****
X  doit:
X  	kludge("You kick %s.", mon_nam(mon));
X  	if(!rn2(clumsy ? 3 : 4) && (clumsy || !bigmonst(mon->data)) && 
X! 	   mon->mcansee && !thick_skinned(mon->data) &&
X! 	   !mon->mfroz && !mon->mstun && !mon->mconf) {
X! 		mnexto(mon);
X! 		if(mon->mx != x || mon->my != y) {
X! 		    kludge("%s jumps, %s evading your %skick.", Monnam(mon),
X! 				clumsy ? "easily" : "nimbly",
X  				clumsy ? "clumsy " : "");
X  		    return;
X! 		} /* else fall to the next case */		
X  	}
X  	kickdmg(mon, clumsy);
X  }
X--- 124,153 ----
X  doit:
X  	kludge("You kick %s.", mon_nam(mon));
X  	if(!rn2(clumsy ? 3 : 4) && (clumsy || !bigmonst(mon->data)) && 
X! 	   mon->mcansee && !mon->mtrapped && !thick_skinned(mon->data) && 
X! 	   mon->data->mlet != S_EEL && haseyes(mon->data) && !mon->mfroz && 
X! 	   !mon->mstun && !mon->mconf && mon->data->mmove >= 12) {
X! 		if(!nohands(mon->data) && !rn2(martial() ? 5 : 3)) {
X! 		    kludge("%s blocks your %skick.", Monnam(mon), 
X  				clumsy ? "clumsy " : "");
X+ 		    (void) passive(mon, FALSE, 1);
X  		    return;
X! 		} else {
X! 		    mnexto(mon);
X! 		    if(mon->mx != x || mon->my != y) {
X! 		        pline("%s %s, %s evading your %skick.", 
X! 				Blind ? "It" : Monnam(mon),
X! 				(can_teleport(mon->data) ? "teleports" :
X! 				 is_flyer(mon->data) ? "flutters" :
X! 				 is_floater(mon->data) ? "floats" :
X! 				 nolimbs(mon->data) ? "slides" :
X! 				 "jumps"),
X! 				clumsy ? "easily" : "nimbly",
X! 				clumsy ? "clumsy " : "");
X! 			(void) passive(mon, FALSE, 1);
X! 		        return;
X! 		    } 
X! 		}
X  	}
X  	kickdmg(mon, clumsy);
X  }
X***************
X*** 150,156 ****
X  		if(!rn2(4)) setmangry(mtmp); /* not always pleasing */
X  		
X  		/* greedy monsters catch gold */
X! 		pline("%s catches the gold.", Monnam(mtmp));
X  		mtmp->mgold += amount;
X  		if (mtmp->isshk) {
X  			long robbed = ESHK(mtmp)->robbed;
X--- 171,177 ----
X  		if(!rn2(4)) setmangry(mtmp); /* not always pleasing */
X  		
X  		/* greedy monsters catch gold */
X! 		kludge("%s catches the gold.", Monnam(mtmp));
X  		mtmp->mgold += amount;
X  		if (mtmp->isshk) {
X  			long robbed = ESHK(mtmp)->robbed;
X***************
X*** 245,255 ****
X  	/* if a pile, the "top" object gets kicked */
X  	for (otmp = fobj; otmp; otmp = otmp->nobj)
X  		if(otmp->ox == x && otmp->oy == y)
X! 		    if(!otmp->cobj)
X! 			if (otmp != uchain) {
X  			    cnt++;
X  			    if(cnt == 1) obj = otmp;
X! 			}
X  
X  	/* range < 2 means the object will not move.	*/
X  	/* maybe dexterity should also figure here.     */
X--- 266,275 ----
X  	/* if a pile, the "top" object gets kicked */
X  	for (otmp = fobj; otmp; otmp = otmp->nobj)
X  		if(otmp->ox == x && otmp->oy == y)
X! 		    if(!otmp->cobj) {
X  			    cnt++;
X  			    if(cnt == 1) obj = otmp;
X! 		    }
X  
X  	/* range < 2 means the object will not move.	*/
X  	/* maybe dexterity should also figure here.     */
X***************
X*** 291,297 ****
X  		return(1);
X  	}
X  
X! 	if(obj->otyp == BOULDER || obj == uball)
X  		return(0);
X  
X  	/* a box gets a chance of breaking open here */
X--- 311,317 ----
X  		return(1);
X  	}
X  
X! 	if(obj->otyp == BOULDER || obj == uball || obj == uchain)
X  		return(0);
X  
X  	/* a box gets a chance of breaking open here */
X***************
X*** 375,380 ****
X--- 395,401 ----
X  	obj->oy = bhitpos.y;
X  	levl[obj->ox][obj->oy].omask = 1;
X  	stackobj(obj);
X+ 	if(!levl[obj->ox][obj->oy].mmask) newsym(obj->ox, obj->oy);
X  	return(1);
X  }
X  #endif /* KICK */
X***************
X*** 583,589 ****
X  #ifdef KICK
X  dumb:
X  #endif
X! 		if (martial() || ACURR(A_DEX) >= 16) {
X  			You("kick at empty space.");
X  		} else {
X  			pline("Dumb move!  You strain a muscle.");
X--- 604,610 ----
X  #ifdef KICK
X  dumb:
X  #endif
X! 		if (martial() || ACURR(A_DEX) >= 16 || rn2(3)) {
X  			You("kick at empty space.");
X  		} else {
X  			pline("Dumb move!  You strain a muscle.");
X*** src/Old/eat.c	Mon Jul 31 13:54:35 1989
X--- src/eat.c	Wed Jul 26 19:33:43 1989
X***************
X*** 557,568 ****
X  			/* Fall through otherwise */
X  #endif
X  		default:
X! 			if (otmp->otyp==SLIME_MOLD && !otmp->cursed &&
X! 				otmp->spe == current_fruit)
X  			    pline(!Hallucination ?
X  				    "Mmm!  Your favorite!" :
X  				    "Yum!  Your fave fruit!");
X! 			else {
X  			    int oldquan = otmp->quan;
X  			    otmp->quan = 1;
X  			    pline("That %s was %s!", xname(otmp),
X--- 557,572 ----
X  			/* Fall through otherwise */
X  #endif
X  		default:
X! #ifdef TUTTI_FRUTTI
X! 			if (otmp->otyp==SLIME_MOLD && !otmp->cursed
X! 				&& otmp->spe == current_fruit
X! 								)
X  			    pline(!Hallucination ?
X  				    "Mmm!  Your favorite!" :
X  				    "Yum!  Your fave fruit!");
X! 			else
X! #endif
X! 			{
X  			    int oldquan = otmp->quan;
X  			    otmp->quan = 1;
X  			    pline("That %s was %s!", xname(otmp),
X*** src/Old/end.c	Mon Jul 31 13:55:29 1989
X--- src/end.c	Sun Jul 30 12:12:38 1989
X***************
X*** 2,14 ****
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X- #ifndef TOS
X- #include <signal.h>
X- #endif
X- 
X  /* block some unused #defines to avoid overloading some cpp's */
X  #define MONATTK_H
X  #include "hack.h"
X  
X  #include "eshk.h"
X  
X--- 2,13 ----
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X  /* block some unused #defines to avoid overloading some cpp's */
X  #define MONATTK_H
X  #include "hack.h"
X+ #ifndef NO_SIGNAL
X+ #include <signal.h>
X+ #endif
X  
X  #include "eshk.h"
X  
X***************
X*** 17,27 ****
X  int
X  done1()
X  {
X! #ifndef TOS
X  	(void) signal(SIGINT,SIG_IGN);
X  #endif
X  	if(flags.ignintr) {
X! #ifndef TOS
X  		(void) signal(SIGINT, (SIG_RET_TYPE) done1);
X  #endif
X  		clrlin();
X--- 16,26 ----
X  int
X  done1()
X  {
X! #ifndef NO_SIGNAL
X  	(void) signal(SIGINT,SIG_IGN);
X  #endif
X  	if(flags.ignintr) {
X! #ifndef NO_SIGNAL
X  		(void) signal(SIGINT, (SIG_RET_TYPE) done1);
X  #endif
X  		clrlin();
X***************
X*** 38,44 ****
X  {
X  	pline("Really quit? ");
X  	if(yn() == 'n') {
X! #ifndef TOS
X  		(void) signal(SIGINT, (SIG_RET_TYPE) done1);
X  #endif
X  		clrlin();
X--- 37,43 ----
X  {
X  	pline("Really quit? ");
X  	if(yn() == 'n') {
X! #ifndef NO_SIGNAL
X  		(void) signal(SIGINT, (SIG_RET_TYPE) done1);
X  #endif
X  		clrlin();
X***************
X*** 70,76 ****
X  int
X  done_intr(){
X  	done_stopprint++;
X! #ifndef TOS
X  	(void) signal(SIGINT, SIG_IGN);
X  #ifdef UNIX
X  	(void) signal(SIGQUIT, SIG_IGN);
X--- 69,75 ----
X  int
X  done_intr(){
X  	done_stopprint++;
X! #ifndef NO_SIGNAL
X  	(void) signal(SIGINT, SIG_IGN);
X  #ifdef UNIX
X  	(void) signal(SIGQUIT, SIG_IGN);
X***************
X*** 182,190 ****
X  register char *st1;
X  {
X  	struct permonst *upmon;
X! 	char buf[BUFSZ], buf1[BUFSZ], buf2[BUFSZ];
X  	char	c;
X  	boolean taken;
X  #ifdef WIZARD
X  	if (wizard && *st1=='t') {
X  		You("are a very tricky wizard, it seems.");
X--- 181,199 ----
X  register char *st1;
X  {
X  	struct permonst *upmon;
X! 	char buf[BUFSZ], buf1[BUFSZ], buf2[BUFSZ], buf3[BUFSZ];
X! 	/* buf: used if killer gets changed
X! 	 * buf1: used if st1 gets changed
X! 	 * buf2: same as player name, except it is capitalized
X! 	 * buf3: used to copy killer in case it comes from something like
X! 		xname(), which would otherwise get overwritten when we call
X! 		xname() when listing possessions
X! 	 */
X  	char	c;
X  	boolean taken;
X+ 
X+ 	Strcpy(buf3, killer);
X+ 	killer = buf3;
X  #ifdef WIZARD
X  	if (wizard && *st1=='t') {
X  		You("are a very tricky wizard, it seems.");
X***************
X*** 236,248 ****
X  	}
X  #endif /* WIZARD || EXPLORE_MODE */
X  die:
X! #ifndef TOS
X  	(void) signal(SIGINT, (SIG_RET_TYPE) done_intr);
X  #ifdef UNIX
X  	(void) signal(SIGQUIT, (SIG_RET_TYPE) done_intr);
X  	(void) signal(SIGHUP, (SIG_RET_TYPE) done_hangup);
X  #endif
X! #endif /* TOS /* */
X  	upmon = player_mon();
X  	if(u.ugrave_arise > -1) /* create no corpse */ ;
X  	else if(*st1 == 's' && st1[2] == 'o') 
X--- 245,257 ----
X  	}
X  #endif /* WIZARD || EXPLORE_MODE */
X  die:
X! #ifndef NO_SIGNAL
X  	(void) signal(SIGINT, (SIG_RET_TYPE) done_intr);
X  #ifdef UNIX
X  	(void) signal(SIGQUIT, (SIG_RET_TYPE) done_intr);
X  	(void) signal(SIGHUP, (SIG_RET_TYPE) done_hangup);
X  #endif
X! #endif /* NO_SIGNAL /* */
X  	upmon = player_mon();
X  	if(u.ugrave_arise > -1) /* create no corpse */ ;
X  	else if(*st1 == 's' && st1[2] == 'o') 
X***************
X*** 435,446 ****
X  
X  void
X  clearlocks(){
X! #if defined(DGK) && !defined(TOS)
X  	eraseall(levels, alllevels);
X  	if (ramdisk)
X  		eraseall(permbones, alllevels);
X  #else
X! #if defined(UNIX) || (defined(MSDOS) && !defined(TOS))
X  	register int x;
X  #ifdef UNIX
X  	(void) signal(SIGHUP,SIG_IGN);
X--- 444,455 ----
X  
X  void
X  clearlocks(){
X! #if defined(DGK) && !defined(OLD_TOS)
X  	eraseall(levels, alllevels);
X  	if (ramdisk)
X  		eraseall(permbones, alllevels);
X  #else
X! #if defined(UNIX) || (defined(MSDOS) && !defined(OLD_TOS))
X  	register int x;
X  #ifdef UNIX
X  	(void) signal(SIGHUP,SIG_IGN);
X*** src/Old/engrave.c	Mon Jul 31 13:56:16 1989
X--- src/engrave.c	Sun Jul 30 18:57:51 1989
X***************
X*** 208,214 ****
X  	/* There's no reason you should be able to write with a wand
X  	 * while both your hands are tied up.
X  	 */
X! 	if (!freehand() && otmp != uwep) {
X  		You("have no free %s to write with!", body_part(HAND));
X  		return(0);
X  	}
X--- 208,214 ----
X  	/* There's no reason you should be able to write with a wand
X  	 * while both your hands are tied up.
X  	 */
X! 	if (!freehand() && otmp != uwep && !otmp->owornmask) {
X  		You("have no free %s to write with!", body_part(HAND));
X  		return(0);
X  	}
X***************
X*** 218,223 ****
X--- 218,227 ----
X  		return(0);
X  	}
X  #endif
X+ 	if(otmp == ublindf) {
X+ 		pline("That is a bit difficult to engrave with, don't you think?");
X+ 		return(1);
X+ 	}
X  	if(otmp != &zeroobj && index(too_large,otmp->olet)) {
X  		You("can't engrave with such a large object!");
X  		return(1);
X***************
X*** 238,246 ****
X  			makeplural(body_part(FINGER)));
X  		type = DUST;
X  	} else if(otmp->olet == WAND_SYM && zappable(otmp)) {
X! 		/* changed so any wand gets zapped out, but fire
X! 		 * wands become known.
X! 		 */
X  		if((objects[otmp->otyp].bits & NODIR))  {
X  			zapnodir(otmp);
X  			type = DUST;
X--- 242,248 ----
X  			makeplural(body_part(FINGER)));
X  		type = DUST;
X  	} else if(otmp->olet == WAND_SYM && zappable(otmp)) {
X! 		/* changed so any wand gets zapped out */
X  		if((objects[otmp->otyp].bits & NODIR))  {
X  			zapnodir(otmp);
X  			type = DUST;
X***************
X*** 307,313 ****
X  					do  {
X  						tx = rn1(COLNO-3,2);
X  						ty = rn2(ROWNO);
X! 					}  while(!goodpos(tx,ty));
X  					oep->engr_x = tx;
X  					oep->engr_y = ty;
X  					pline("The engraving on the floor vanishes!");
X--- 309,315 ----
X  					do  {
X  						tx = rn1(COLNO-3,2);
X  						ty = rn2(ROWNO);
X! 					}  while(!goodpos(tx,ty,(struct permonst *)0));
X  					oep->engr_x = tx;
X  					oep->engr_y = ty;
X  					pline("The engraving on the floor vanishes!");
X***************
X*** 323,334 ****
X  			   doname(otmp));
X  
X  	} else {
X! 		if(otmp->otyp == DAGGER ||
X  #ifdef WORM
X  		   otmp->otyp == CRYSKNIFE ||
X  #endif
X! 		   is_sword(otmp) || otmp->otyp == AXE) {
X  			type = ENGRAVE;
X  			if((int)otmp->spe <= -3) {
X  				Your("%s too dull for engraving.",
X  					aobjnam(otmp, "are"));
X--- 325,337 ----
X  			   doname(otmp));
X  
X  	} else {
X! 		if((otmp->otyp >= DAGGER && otmp->otyp <= AXE) ||
X  #ifdef WORM
X  		   otmp->otyp == CRYSKNIFE ||
X  #endif
X! 		   is_sword(otmp)) {
X  			type = ENGRAVE;
X+ 
X  			if((int)otmp->spe <= -3) {
X  				Your("%s too dull for engraving.",
X  					aobjnam(otmp, "are"));
X***************
X*** 529,535 ****
X  		bwrite(fd, (genericptr_t)&(ep->engr_lth), sizeof(ep->engr_lth));
X  		bwrite(fd, (genericptr_t)ep, sizeof(struct engr) + ep->engr_lth);
X  	    }
X! #if defined(DGK) && !defined(TOS)
X  	    if (!count_only)
X  #endif
X  		free((genericptr_t) ep);
X--- 532,538 ----
X  		bwrite(fd, (genericptr_t)&(ep->engr_lth), sizeof(ep->engr_lth));
X  		bwrite(fd, (genericptr_t)ep, sizeof(struct engr) + ep->engr_lth);
X  	    }
X! #if defined(DGK) && !defined(OLD_TOS)
X  	    if (!count_only)
X  #endif
X  		free((genericptr_t) ep);
X***************
X*** 536,542 ****
X  	    ep = ep2;
X  	}
X  	bwrite(fd, (genericptr_t)nul, sizeof(unsigned));
X! #if defined(DGK) && !defined(TOS)
X  	if (!count_only)
X  #endif
X  		head_engr = 0;
X--- 539,545 ----
X  	    ep = ep2;
X  	}
X  	bwrite(fd, (genericptr_t)nul, sizeof(unsigned));
X! #if defined(DGK) && !defined(OLD_TOS)
X  	if (!count_only)
X  #endif
X  		head_engr = 0;
X*** src/Old/fountain.c	Mon Jul 31 13:57:44 1989
X--- src/fountain.c	Sat Jul 29 12:04:24 1989
X***************
X*** 125,131 ****
X  	}
X  	else if (fate < 10) {
X  		pline("The cool draught refreshes you.");
X! 		lesshungry(rnd(10));
X  	} else {
X  	    switch (fate) {
X  
X--- 125,131 ----
X  	}
X  	else if (fate < 10) {
X  		pline("The cool draught refreshes you.");
X! 		u.uhunger += rnd(10); /* don't choke on water */
X  	} else {
X  	    switch (fate) {
X  
X***************
X*** 148,154 ****
X--- 148,158 ----
X  
X  			pline("The water is contaminated!");
X  			if (Poison_resistance) {
X+ #ifdef TUTTI_FRUTTI
X  	   pline("Perhaps it is runoff from the nearby %s farm.", pl_fruit);
X+ #else
X+ 	   pline("Perhaps it is runoff from the nearby orange farm.");
X+ #endif
X  			   losehp(rnd(4),"unrefrigerated sip of juice");
X  			   break;
X  			}
X*** src/Old/hack.c	Mon Jul 31 13:59:24 1989
X--- src/hack.c	Sat Jul 29 12:04:28 1989
X***************
X*** 688,694 ****
X  	for(x = u.ux-1; x <= u.ux+1; x++) for(y = u.uy-1; y <= u.uy+1; y++) {
X  		if(x == u.ux && y == u.uy) continue;
X  		if(levl[x][y].mmask && (mtmp = m_at(x,y)) && !mtmp->mimic &&
X! 		    (!mtmp->minvis || See_invisible)) {
X  			if((flags.run != 1 && !mtmp->mtame) || (x == u.ux+u.dx && y == u.uy+u.dy))
X  				goto stop;
X  		} else mtmp = 0;
X--- 688,694 ----
X  	for(x = u.ux-1; x <= u.ux+1; x++) for(y = u.uy-1; y <= u.uy+1; y++) {
X  		if(x == u.ux && y == u.uy) continue;
X  		if(levl[x][y].mmask && (mtmp = m_at(x,y)) && !mtmp->mimic &&
X! 		    (!mtmp->minvis || See_invisible) && !mtmp->mundetected) {
X  			if((flags.run != 1 && !mtmp->mtame) || (x == u.ux+u.dx && y == u.uy+u.dy))
X  				goto stop;
X  		} else mtmp = 0;
X***************
X*** 803,809 ****
X  cansee(x,y)
X  xchar x,y;
X  {
X! 	if(Blind || u.uswallow) return(0);
X  	if(dist(x,y) < 3) return(1);
X  	if(IS_ROCK(levl[x][y].typ) && levl[u.ux][u.uy].typ == CORR &&
X  							!levl[u.ux][u.uy].lit)
X--- 803,809 ----
X  cansee(x,y)
X  xchar x,y;
X  {
X! 	if(Blind || (u.uswallow && (x != u.ux || y != u.uy))) return(0);
X  	if(dist(x,y) < 3) return(1);
X  	if(IS_ROCK(levl[x][y].typ) && levl[u.ux][u.uy].typ == CORR &&
X  							!levl[u.ux][u.uy].lit)
X***************
X*** 950,955 ****
X--- 950,956 ----
X  				    (!!(HSleep_resistance & INTRINSIC)) +
X  				    (!!(HDisint_resistance & INTRINSIC)) +
X  				    (!!(HTeleport_control & INTRINSIC)) +
X+ 				    (!!(Stealth & INTRINSIC)) +
X  				    (!!(Fast & INTRINSIC)) +
X  				    (!!(HInvis & INTRINSIC)))
X  				pline("%s, all your powers will be lost...",
X*** src/Old/invent.c	Mon Jul 31 14:00:38 1989
X--- src/invent.c	Sat Jul 29 21:59:04 1989
X***************
X*** 145,150 ****
X--- 145,151 ----
X  	} else {
X  		setnotworn(obj);
X  		freeinv(obj);
X+ 		delete_contents(obj);
X  		obfree(obj, (struct obj *) 0);
X  	}
X  }
X***************
X*** 187,194 ****
X  	freeobj(obj);
X  	unpobj(obj);
X  
X! /*	if contained in something else, decrease the container weight */
X! 	if(obj->cobj) dec_cwt(obj->cobj, obj);
X  
X  	obfree(obj, (struct obj *) 0);
X  }
X--- 188,195 ----
X  	freeobj(obj);
X  	unpobj(obj);
X  
X! /*	if a container, get rid of the contents */
X! 	delete_contents(obj);
X  
X  	obfree(obj, (struct obj *) 0);
X  }
X*** src/Old/lock.c	Mon Jul 31 14:05:39 1989
X--- src/lock.c	Mon Jul 24 15:20:37 1989
X***************
X*** 166,172 ****
X  
X  #ifdef POLYSELF
X  	if(nohands(uasmon)) {
X! 		You("can't hold a %s - you have no hands!");
X  		return(0);
X  	}
X  #endif
X--- 166,172 ----
X  
X  #ifdef POLYSELF
X  	if(nohands(uasmon)) {
X! 		You("can't hold a %s - you have no hands!", xname(pick));
X  		return(0);
X  	}
X  #endif
X*** src/Old/mail.c	Mon Jul 31 14:06:16 1989
X--- src/mail.c	Thu Jul 27 11:37:31 1989
X***************
X*** 47,53 ****
X   *	- It may also do this with adjoining castle rooms.
X   */
X  
X! # ifdef AMIGA
X  int mustgetmail = -1;
X  # endif
X  
X--- 47,53 ----
X   *	- It may also do this with adjoining castle rooms.
X   */
X  
X! # ifndef UNIX
X  int mustgetmail = -1;
X  # endif
X  
X***************
X*** 180,186 ****
X  	nscr();
X  }
X  
X! # ifdef AMIGA
X  void
X  ckmailstatus() {
X  	if (mustgetmail < 0)
X--- 180,186 ----
X  	nscr();
X  }
X  
X! # ifndef UNIX
X  void
X  ckmailstatus() {
X  	if (mustgetmail < 0)
X***************
X*** 194,204 ****
X  void
X  readmail()
X  {
X! 	pline("It says: \"How nice to get a letter down here!\"");
X  }
X- # endif /* AMIGA */
X  
X! # ifdef UNIX
X  void
X  ckmailstatus() {
X  	if(!mailbox
X--- 194,204 ----
X  void
X  readmail()
X  {
X! 	pline("It says:  \"Please disregard previous letter.\"");
X  }
X  
X! # else /* UNIX */
X! 
X  void
X  ckmailstatus() {
X  	if(!mailbox
X*** src/Old/makedefs.c	Mon Jul 31 14:06:47 1989
X--- src/makedefs.c	Fri Jul 28 17:53:20 1989
X***************
X*** 18,24 ****
X--- 18,26 ----
X  #endif
X  
X  #ifdef MSDOS
X+ #ifndef TOS
X  # define freopen _freopen
X+ #endif
X  # undef	exit
X  extern void exit P((int));
X  # define RDMODE	"r"
X***************
X*** 416,422 ****
X  #endif
X  
X  #ifdef MSDOS
X! # ifndef AMIGA
X  /* Get around bug in freopen when opening for writing	*/
X  /* Supplied by Nathan Glasser (nathan@mit-eddie)	*/
X  #undef freopen
X--- 418,424 ----
X  #endif
X  
X  #ifdef MSDOS
X! # if !defined(AMIGA) && !defined(TOS)
X  /* Get around bug in freopen when opening for writing	*/
X  /* Supplied by Nathan Glasser (nathan@mit-eddie)	*/
X  #undef freopen
X***************
X*** 439,445 ****
X      else
X  	return freopen(fname,fmode,fp);
X  }
X! # endif /* AMIGA */
X  
X  # if defined(__TURBOC__) || defined(AMIGA)
X  int
X--- 441,447 ----
X      else
X  	return freopen(fname,fmode,fp);
X  }
X! # endif /* !AMIGA && !TOS */
X  
X  # if defined(__TURBOC__) || defined(AMIGA)
X  int
X*** src/Old/makemon.c	Mon Jul 31 14:07:38 1989
X--- src/makemon.c	Tue Jul 25 14:39:14 1989
X***************
X*** 32,38 ****
X  		 * are peaceful and some are not, the result will just be a
X  		 * smaller group.
X  		 */
X! 		enexto(&mm, mm.x, mm.y);
X  		mon = makemon(mtmp->data, mm.x, mm.y);
X  		mon->mpeaceful = 0;
X  		set_malign(mon);
X--- 32,38 ----
X  		 * are peaceful and some are not, the result will just be a
X  		 * smaller group.
X  		 */
X! 		enexto(&mm, mm.x, mm.y, mtmp->data);
X  		mon = makemon(mtmp->data, mm.x, mm.y);
X  		mon->mpeaceful = 0;
X  		set_malign(mon);
X***************
X*** 421,427 ****
X  		do {
X  			x = rn1(COLNO-3,2);
X  			y = rn2(ROWNO);
X! 		} while(!goodpos(x, y));
X  	}
X  
X  	/* if a monster already exists at the position, return */
X--- 421,427 ----
X  		do {
X  			x = rn1(COLNO-3,2);
X  			y = rn2(ROWNO);
X! 		} while(!goodpos(x, y, ptr));
X  	}
X  
X  	/* if a monster already exists at the position, return */
X***************
X*** 575,583 ****
X  }
X  
X  void
X! enexto(cc, xx,yy)
X  coord *cc;
X  register xchar xx, yy;
X  {
X  	register xchar x,y;
X  	coord foo[15], *tfoo;
X--- 575,584 ----
X  }
X  
X  void
X! enexto(cc, xx, yy, mdat)
X  coord *cc;
X  register xchar xx, yy;
X+ struct permonst *mdat;
X  {
X  	register xchar x,y;
X  	coord foo[15], *tfoo;
X***************
X*** 587,611 ****
X  	range = 1;
X  	do {	/* full kludge action. */
X  		for(x = xx-range; x <= xx+range; x++)
X! 			if(goodpos(x, yy-range)) {
X  				tfoo->x = x;
X  				(tfoo++)->y = yy-range;
X  				if(tfoo == &foo[15]) goto foofull;
X  			}
X  		for(x = xx-range; x <= xx+range; x++)
X! 			if(goodpos(x,yy+range)) {
X  				tfoo->x = x;
X  				(tfoo++)->y = yy+range;
X  				if(tfoo == &foo[15]) goto foofull;
X  			}
X  		for(y = yy+1-range; y < yy+range; y++)
X! 			if(goodpos(xx-range,y)) {
X  				tfoo->x = xx-range;
X  				(tfoo++)->y = y;
X  				if(tfoo == &foo[15]) goto foofull;
X  			}
X  		for(y = yy+1-range; y < yy+range; y++)
X! 			if(goodpos(xx+range,y)) {
X  				tfoo->x = xx+range;
X  				(tfoo++)->y = y;
X  				if(tfoo == &foo[15]) goto foofull;
X--- 588,612 ----
X  	range = 1;
X  	do {	/* full kludge action. */
X  		for(x = xx-range; x <= xx+range; x++)
X! 			if(goodpos(x, yy-range, mdat)) {
X  				tfoo->x = x;
X  				(tfoo++)->y = yy-range;
X  				if(tfoo == &foo[15]) goto foofull;
X  			}
X  		for(x = xx-range; x <= xx+range; x++)
X! 			if(goodpos(x, yy+range, mdat)) {
X  				tfoo->x = x;
X  				(tfoo++)->y = yy+range;
X  				if(tfoo == &foo[15]) goto foofull;
X  			}
X  		for(y = yy+1-range; y < yy+range; y++)
X! 			if(goodpos(xx-range, y, mdat)) {
X  				tfoo->x = xx-range;
X  				(tfoo++)->y = y;
X  				if(tfoo == &foo[15]) goto foofull;
X  			}
X  		for(y = yy+1-range; y < yy+range; y++)
X! 			if(goodpos(xx+range, y, mdat)) {
X  				tfoo->x = xx+range;
X  				(tfoo++)->y = y;
X  				if(tfoo == &foo[15]) goto foofull;
X***************
X*** 620,645 ****
X  }
X  
X  int
X! goodpos(x, y)
X  {
X! #ifdef STUPID
X! 	if (x < 1 || x > COLNO-2 || y < 1 || y > ROWNO-2 ||
X! 	    levl[x][y].mmask || !ACCESSIBLE(levl[x][y].typ))
X! 	  return 0;
X  	if (IS_DOOR(levl[x][y].typ) &&
X! 	    (levl[x][y].doormask & (D_LOCKED | D_CLOSED)))
X! 	  return 0;
X! 	return !((x == u.ux && y == u.uy) || sobj_at(BOULDER, x, y));
X! #else
X! 	return
X! 	! (x < 1 || x > COLNO-2 || y < 1 || y > ROWNO-2 ||
X! 	   levl[x][y].mmask || !ACCESSIBLE(levl[x][y].typ) ||
X! 	   (IS_DOOR(levl[x][y].typ) && 
X! 		(levl[x][y].doormask & (D_LOCKED | D_CLOSED)) )
X! 	   || (x == u.ux && y == u.uy)
X! 	   || sobj_at(BOULDER, x, y)
X! 	);
X! #endif /* STUPID */
X  }
X  
X  void
X--- 621,647 ----
X  }
X  
X  int
X! goodpos(x, y, mdat)
X! int x,y;
X! struct permonst *mdat;
X  {
X! 	if (x < 1 || x > COLNO-2 || y < 1 || y > ROWNO-2 || levl[x][y].mmask)
X! 		return 0;
X! 	if (x == u.ux && y == u.uy) return 0;
X! 	if (mdat) {
X! 	    if (IS_POOL(levl[x][y].typ))
X! 		if (mdat == &playermon && HLevitation)	return 1;
X! 		else	return (is_flyer(mdat) || is_swimmer(mdat));
X! 	    if (passes_walls(mdat)) return 1;
X! 	}
X! 	if (!ACCESSIBLE(levl[x][y].typ)) return 0;
X  	if (IS_DOOR(levl[x][y].typ) &&
X! 		    (levl[x][y].doormask & (D_LOCKED | D_CLOSED)) &&
X! 		    (!mdat || !amorphous(mdat)))
X! 		return 0;
X! 	if (sobj_at(BOULDER, x, y) && (!mdat || !throws_rocks(mdat)))
X! 		return 0;
X! 	return 1;
X  }
X  
X  void
X***************
X*** 653,663 ****
X  #endif
X  	/* if the wiz teleports away to heal, try the up staircase,
X  	   to block the player's escaping before he's healed */
X! 	if(!mtmp->iswiz || !goodpos(tx = xupstair, ty = yupstair))
X  	   do {
X  		tx = rn1(COLNO-3,2);
X  		ty = rn2(ROWNO);
X! 	   } while(!goodpos(tx,ty));
X  	if(mtmp->mx != 0 && mtmp->my != 0)
X  		levl[mtmp->mx][mtmp->my].mmask = 0;
X  	mtmp->mx = tx;
X--- 655,665 ----
X  #endif
X  	/* if the wiz teleports away to heal, try the up staircase,
X  	   to block the player's escaping before he's healed */
X! 	if(!mtmp->iswiz || !goodpos(tx = xupstair, ty = yupstair, mtmp->data))
X  	   do {
X  		tx = rn1(COLNO-3,2);
X  		ty = rn2(ROWNO);
X! 	   } while(!goodpos(tx,ty,mtmp->data));
X  	if(mtmp->mx != 0 && mtmp->my != 0)
X  		levl[mtmp->mx][mtmp->my].mmask = 0;
X  	mtmp->mx = tx;
X***************
X*** 1096,1102 ****
X  		int s_sym = get_shop_item(rt - SHOPBASE);
X  
X  		if (s_sym < 0) sym = objects[-sym].oc_olet;
X! 		else if (sym == RANDOM_SYM)
X  			sym = syms[rn2(sizeof(syms)-2) + 2];
X  		else sym = s_sym;
X  	} else sym = syms[rn2(sizeof syms)];
X--- 1098,1104 ----
X  		int s_sym = get_shop_item(rt - SHOPBASE);
X  
X  		if (s_sym < 0) sym = objects[-sym].oc_olet;
X! 		else if (s_sym == RANDOM_SYM)
X  			sym = syms[rn2(sizeof(syms)-2) + 2];
X  		else sym = s_sym;
X  	} else sym = syms[rn2(sizeof syms)];
X*** src/Old/mhitm.c	Mon Jul 31 14:09:22 1989
X--- src/mhitm.c	Sun Jul 30 18:57:41 1989
X***************
X*** 281,288 ****
X--- 281,291 ----
X  	if(cansee(magr->mx, magr->my))	pmon(magr);
X  	if((tmp = mdamagem(magr, mdef, mattk)) == 2) {
X  		levl[mx][my].mmask = 0;
X+ 		levl[magr->mx][magr->my].mmask = 1;
X  		return(2);	/* defender died */
X  	} else {		/* defender survived */
X+ 		if(cansee(mdef->mx, mdef->my))
X+ 			pline("%s is regurgitated!", Monnam(mdef));
X  		if(cansee(magr->mx, magr->my))	unpmon(magr);
X  		magr->mx = mx;
X  		magr->my = my;
X***************
X*** 289,294 ****
X--- 292,298 ----
X  		/* move off of defender */
X  		if(cansee(magr->mx, magr->my))	pmon(magr);
X  		if(cansee(mdef->mx, mdef->my))	pmon(mdef);
X+ 		nscr();
X  		return(tmp);
X  	}
X  }
X***************
X*** 458,464 ****
X  		tmp = 0;	/* no damage if this fails */
X  		break;
X  	    case AD_TLPT:
X! 		if(!magr->mcan && tmp >= mdef->mhp) {
X  		    rloc(mdef);
X  		    if(vis && !cansee(mdef->mx, mdef->my))
X  			pline("%s suddenly disappears!", Monnam(mdef));
X--- 462,468 ----
X  		tmp = 0;	/* no damage if this fails */
X  		break;
X  	    case AD_TLPT:
X! 		if(!magr->mcan && tmp < mdef->mhp) {
X  		    rloc(mdef);
X  		    if(vis && !cansee(mdef->mx, mdef->my))
X  			pline("%s suddenly disappears!", Monnam(mdef));
X*** src/Old/mhitu.c	Mon Jul 31 14:10:51 1989
X--- src/mhitu.c	Sat Jul 29 12:04:33 1989
X***************
X*** 58,64 ****
X  {
X  	/* Note: if opposite gender, "seductively" */
X  	/* If same gender, "engagingly" for nymph, normal msg for others */
X! 	if(sp_melee(mtmp) && !mtmp->mcan) {
X  		if(!is_nymph(mtmp) && incompatible(mtmp)) goto strike;
X  	    	kludge("%s %s you %s.", Monnam(mtmp),
X  			Blind ? "talks to" : "smiles at",
X--- 58,64 ----
X  {
X  	/* Note: if opposite gender, "seductively" */
X  	/* If same gender, "engagingly" for nymph, normal msg for others */
X! 	if(sp_melee(mtmp) && !mtmp->mcan && !mtmp->mspec_used) {
X  		if(!is_nymph(mtmp) && incompatible(mtmp)) goto strike;
X  	    	kludge("%s %s you %s.", Monnam(mtmp),
X  			Blind ? "talks to" : "smiles at",
X***************
X*** 248,258 ****
X  		    mtmp->mx = u.ux; mtmp->my = u.uy;
X  		    levl[mtmp->mx][mtmp->my].mmask = 1;
X  		    pmon(mtmp);
X! 		    enexto(&cc, u.ux, u.uy);
X! 		    /* Luckily piercers cannot walk through walls, so this
X! 		     * will work.  If they can (i.e., if someone adds a potion
X! 		     * of phasing), we gotta change this...
X! 		     */
X  		    teleds(cc.x, cc.y);
X  		    You("fall from the ceiling!");
X  		    if (is_mercenary(mtmp->data) && m_carrying(mtmp,HELMET)) {
X--- 248,254 ----
X  		    mtmp->mx = u.ux; mtmp->my = u.uy;
X  		    levl[mtmp->mx][mtmp->my].mmask = 1;
X  		    pmon(mtmp);
X! 		    enexto(&cc, u.ux, u.uy, &playermon);
X  		    teleds(cc.x, cc.y);
X  		    You("fall from the ceiling!");
X  		    if (is_mercenary(mtmp->data) && m_carrying(mtmp,HELMET)) {
X***************
X*** 839,845 ****
X  		 * is, no matter what covers it.
X  		 */
X  		getbronze = (mdat == &mons[PM_BLACK_PUDDING] &&
X! 			     uarm->otyp == BRONZE_PLATE_MAIL);
X  		while (1) {
X  		    switch(rn2(5)) {
X  		    case 0:
X--- 835,841 ----
X  		 * is, no matter what covers it.
X  		 */
X  		getbronze = (mdat == &mons[PM_BLACK_PUDDING] &&
X! 			     uarm && uarm->otyp == BRONZE_PLATE_MAIL);
X  		while (1) {
X  		    switch(rn2(5)) {
X  		    case 0:
X***************
X*** 1240,1245 ****
X--- 1236,1242 ----
X  	register struct attack  *mattk;
X  {
X  	switch(mattk->adtyp) {
X+ #ifdef MEDUSA
X  	    case AD_STON:
X  		if (mtmp->mcan) {
X  		    You("notice that %s isn't all that ugly.",mon_nam(mtmp));
X***************
X*** 1258,1263 ****
X--- 1255,1261 ----
X  			done("stoned");
X  	    	}
X  		break;
X+ #endif
X  	    case AD_CONF:
X  		if(!mtmp->mcan && canseemon(mtmp) && mtmp->mcansee && 
X  					!mtmp->mspec_used && rn2(5)) {
X*** src/Old/mklev.c	Thu Jul 20 14:11:02 1989
X--- src/mklev.c	Mon Jul 31 15:23:45 1989
X***************
X*** 788,794
X  			mtmp->msleep = 1;
X  		for (tryct = rn1(1,3); tryct; tryct--) {
X  			x = somex(croom); y = somey(croom);
X! 			if (goodpos(x,y))
X  				(void) mk_tt_statue(x, y);
X  		}
X  	}
X
X--- 788,794 -----
X  			mtmp->msleep = 1;
X  		for (tryct = rn1(1,3); tryct; tryct--) {
X  			x = somex(croom); y = somey(croom);
X! 			if (goodpos(x,y,(struct permonst *)0))
X  				(void) mk_tt_statue(x, y);
X  		}
X  	}
X***************
X*** 815,821
X  #ifdef REINCARNATION
X  	if (dlevel == rogue_level) {
X  	   You("feel as though you were here in a previous lifetime.");
X! 	   return;
X  	}
X  #endif
X  	makecorridors();
X
X--- 815,821 -----
X  #ifdef REINCARNATION
X  	if (dlevel == rogue_level) {
X  	   You("feel as though you were here in a previous lifetime.");
X! 	   goto skip0;
X  	}
X  #endif
X  	makecorridors();
X***************
X*** 871,877
X  #endif
X  	if(dlevel > 18 && !rn2(6)) mkroom(SWAMP);
X  
X! 
X  	/* for each room: put things inside */
X  	for(croom = rooms; croom->hx > 0; croom++) {
X  		register boolean boxinlev = FALSE;
X
X--- 871,879 -----
X  #endif
X  	if(dlevel > 18 && !rn2(6)) mkroom(SWAMP);
X  
X! #ifdef REINCARNATION
X! skip0:
X! #endif
X  	/* for each room: put things inside */
X  	for(croom = rooms; croom->hx > 0; croom++) {
X  		register boolean boxinlev = FALSE;
X*** src/Old/mkobj.c	Mon Jul 31 14:13:59 1989
X--- src/mkobj.c	Sat Jul 29 12:04:35 1989
X***************
X*** 138,144 ****
X  
X  static void
X  mkbox_cnts(box)
X! /* Note: does not check to see if it overloaded the box weight; usually
X   * possible only with corpses in ice boxes.
X   */
X  struct obj *box;
X--- 138,144 ----
X  
X  static void
X  mkbox_cnts(box)
X! /* Note: does not check to see if it overloaded the box capacity; usually
X   * possible only with corpses in ice boxes.
X   */
X  struct obj *box;
X***************
X*** 160,166 ****
X  	for(n = rn2(n+1); n > 0; n--) {
X  	    if (box->otyp == ICE_BOX) {
X  		otmp = mksobj(CORPSE, TRUE);
X! 		otmp->age = moves;
X  	    } else {
X  		register int tprob;
X  		struct icp *iprobs = boxiprobs;
X--- 160,169 ----
X  	for(n = rn2(n+1); n > 0; n--) {
X  	    if (box->otyp == ICE_BOX) {
X  		otmp = mksobj(CORPSE, TRUE);
X! 		/* Note: setting age to 0 is correct.  Age has a different
X! 		 * from usual meaning for objects stored in ice boxes. -KAA
X! 		 */
X! 		otmp->age = 0;
X  	    } else {
X  		register int tprob;
X  		struct icp *iprobs = boxiprobs;
X***************
X*** 174,180 ****
X  		otmp->cobj = box;
X  		otmp->nobj = fcobj;
X  		fcobj = otmp;
X! 		inc_cwt(box, otmp);
X  	    }
X  	}
X  	return;
X--- 177,183 ----
X  		otmp->cobj = box;
X  		otmp->nobj = fcobj;
X  		fcobj = otmp;
X! 		/* inc_cwt(box, otmp); --done by weight() */
X  	    }
X  	}
X  	return;
X***************
X*** 264,271 ****
X  			otmp->corpsenm = rndmonnum();
X  		    } while (mons[otmp->corpsenm].geno & G_NOCORPSE);
X  		    blessorcurse(otmp, 10);
X! 		} else if (otmp->otyp == SLIME_MOLD)
X  		    otmp->spe = current_fruit;
X  		/* fall into next case */
X  	case GEM_SYM:
X  		if (otmp->otyp == LOADSTONE) curse(otmp);
X--- 267,277 ----
X  			otmp->corpsenm = rndmonnum();
X  		    } while (mons[otmp->corpsenm].geno & G_NOCORPSE);
X  		    blessorcurse(otmp, 10);
X! 		}
X! #ifdef TUTTI_FRUTTI
X! 		else if (otmp->otyp == SLIME_MOLD)
X  		    otmp->spe = current_fruit;
X+ #endif
X  		/* fall into next case */
X  	case GEM_SYM:
X  		if (otmp->otyp == LOADSTONE) curse(otmp);
X***************
X*** 279,284 ****
X--- 285,291 ----
X  					blessorcurse(otmp, 5);
X  					break;
X  		case MAGIC_LAMP:	otmp->spe = 1;
X+ 					otmp->recharged = 0;
X  					blessorcurse(otmp, 2);
X  					break;
X  		case KEY:		/* key # index */
X***************
X*** 452,457 ****
X--- 459,465 ----
X  
X  	if (Is_container(obj)) {
X  		struct obj *contents;
X+ 		obj->owt = wt;
X  		for(contents=fcobj; contents; contents=contents->nobj) {
X  			if (contents->cobj == obj)
X  				inc_cwt(obj, contents);
X*** src/Old/mkroom.c	Mon Jul 31 14:14:45 1989
X--- src/mkroom.c	Wed Jul 26 19:32:59 1989
X***************
X*** 253,260 ****
X  		levl[tx][ty].typ = THRONE;
X  		levl[tx][ty].scrsym = THRONE_SYM;
X  
X! 		tx = somex(sroom);
X! 		ty = somey(sroom);
X  		mkgold((long) rn1(50 * dlevel,10), sx, sy);
X  		(void) mksobj_at(CHEST, sx, sy);    /* the royal coffers */
X  	}
X--- 253,260 ----
X  		levl[tx][ty].typ = THRONE;
X  		levl[tx][ty].scrsym = THRONE_SYM;
X  
X! 		sx = somex(sroom);
X! 		sy = somey(sroom);
X  		mkgold((long) rn1(50 * dlevel,10), sx, sy);
X  		(void) mksobj_at(CHEST, sx, sy);    /* the royal coffers */
X  	}
X***************
X*** 439,448 ****
X  squadmon() {	    /* return soldier types. */
X  
X  	register struct permonst *ptr;
X! 	register int	i, cpro, sel = rnd(80+dlevel);
X  
X  	for(cpro = i = 0; i < NSTYPES; i++)
X! 	    if((cpro += squadprob[i].prob) > sel) {
X  
X  		ptr = &mons[squadprob[i].pm];
X  		goto gotone;
X--- 439,448 ----
X  squadmon() {	    /* return soldier types. */
X  
X  	register struct permonst *ptr;
X! 	register int	i, cpro, sel_prob = rnd(80+dlevel);
X  
X  	for(cpro = i = 0; i < NSTYPES; i++)
X! 	    if((cpro += squadprob[i].prob) > sel_prob) {
X  
X  		ptr = &mons[squadprob[i].pm];
X  		goto gotone;
X*** src/Old/mon.c	Mon Jul 31 14:15:45 1989
X--- src/mon.c	Mon Jul 31 12:58:38 1989
X***************
X*** 292,297 ****
X--- 292,299 ----
X  			mtmp->mhp += objects[otmp->otyp].oc_weight;
X  			if (mtmp->mhp > mtmp->mhpmax) mtmp->mhp = mtmp->mhpmax;
X  		    }
X+ 		    if((uball && otmp == uball) ||
X+ 		       (uchain && otmp == uchain)) unpunish();
X  		    freeobj(otmp);
X  		    /* Left behind a pile? */
X  		    if(rnd(25) < 3) (void) mksobj_at(ROCK, mtmp->mx, mtmp->my);
X***************
X*** 312,318 ****
X  	for (otmp = fobj; otmp; otmp = otmp2) {
X  	    otmp2 = otmp->nobj;
X  	    if (otmp->ox == mtmp->mx && otmp->oy == mtmp->my) {
X! 		if(!objects[otmp->otyp].oc_material <= WOOD) {
X  		    if (cansee(mtmp->mx,mtmp->my) && flags.verbose)
X  			pline("%s eats %s!", Monnam(mtmp),
X  				distant_name(otmp, doname));
X--- 314,320 ----
X  	for (otmp = fobj; otmp; otmp = otmp2) {
X  	    otmp2 = otmp->nobj;
X  	    if (otmp->ox == mtmp->mx && otmp->oy == mtmp->my) {
X! 		if(objects[otmp->otyp].oc_material <= WOOD) {
X  		    if (cansee(mtmp->mx,mtmp->my) && flags.verbose)
X  			pline("%s eats %s!", Monnam(mtmp),
X  				distant_name(otmp, doname));
X***************
X*** 423,428 ****
X--- 425,433 ----
X  {
X  	register int newload = weight(otmp);
X  
X+ 	if (otmp->otyp == CORPSE && otmp->corpsenm == PM_COCKATRICE
X+ 						&& !resists_ston(mtmp->data))
X+ 		return(FALSE);
X  	if (mtmp->isshk) return(TRUE); /* no limit */
X  	if (mtmp->mpeaceful && !mtmp->mtame) return(FALSE);
X  	/* otherwise players might find themselves obligated to violate
X***************
X*** 1061,1067 ****
X  	struct monst *mtmp;
X  {
X  	coord mm;
X! 	enexto(&mm, u.ux, u.uy);
X  	levl[mtmp->mx][mtmp->my].mmask = 0;
X  	levl[mm.x][mm.y].mmask = 1;
X  	mtmp->mx = mm.x;
X--- 1066,1072 ----
X  	struct monst *mtmp;
X  {
X  	coord mm;
X! 	enexto(&mm, u.ux, u.uy, mtmp->data);
X  	levl[mtmp->mx][mtmp->my].mmask = 0;
X  	levl[mm.x][mm.y].mmask = 1;
X  	mtmp->mx = mm.x;
X***************
X*** 1077,1084 ****
X  	boolean gz;     
X  {
X  	coord mm;
X! 	if(!gz || !goodpos(x,y)) {
X! 		enexto(&mm, x, y);
X  		x = mm.x; y = mm.y;
X  	}
X  	if(x == mtmp->mx && y == mtmp->my) /* that was easy */
X--- 1082,1089 ----
X  	boolean gz;     
X  {
X  	coord mm;
X! 	if(!gz || !goodpos(x,y,mtmp->data)) {
X! 		enexto(&mm, x, y, mtmp->data);
X  		x = mm.x; y = mm.y;
X  	}
X  	if(x == mtmp->mx && y == mtmp->my) /* that was easy */
X*** src/Old/monmove.c	Mon Jul 31 14:17:24 1989
X--- src/monmove.c	Wed Jul 26 12:01:12 1989
X***************
X*** 204,210 ****
X--- 204,217 ----
X  #endif
X  			unstuck(mtmp);	/* monster lets go when fleeing */
X  		mtmp->mflee = 1;
X+ #ifdef STUPID
X+ 		if (rn2(7))
X+ 		    mtmp->mfleetim = rnd(10);
X+ 		else
X+ 		    mtmp->mfleetim = rnd(100);
X+ #else
X  		mtmp->mfleetim = (rn2(7) ? rnd(10) : rnd(100));
X+ #endif
X  	}
X  
X  #ifdef HARD	/* Demonic Blackmail!!! */
X***************
X*** 262,268 ****
X--- 269,282 ----
X  							(BOLT_LIM * BOLT_LIM));
X  		if(scared && !mtmp->mflee) {
X  			mtmp->mflee = 1;
X+ #ifdef STUPID
X+ 			if (rn2(7))
X+ 			    mtmp->mfleetim = rnd(10);
X+ 			else
X+ 			    mtmp->mfleetim = rnd(100);
X+ #else
X  			mtmp->mfleetim = (rn2(7) ? rnd(10) : rnd(100));
X+ #endif
X  		}
X  	}
X  
END_OF_FILE
if test 54643 -ne `wc -c <'src1.diff'`; then
    echo shar: \"'src1.diff'\" unpacked with wrong size!
fi
# end of 'src1.diff'
fi
echo shar: End of archive 3 \(of 6\).
cp /dev/null ark3isdone
MISSING=""
for I in 1 2 3 4 5 6 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 6 archives.
    echo "now type ./do_patch.sh"
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
