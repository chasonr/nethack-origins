Path: uunet!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v16i111:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Part103/108
Message-ID: <4476@master.CNA.TEK.COM>
Date: 5 Feb 93 22:03:49 GMT
Sender: news@master.CNA.TEK.COM
Lines: 1692
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1662

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 16, Issue 111
Archive-name: nethack31/Part103
Supersedes: nethack3p9: Volume 10, Issue 46-108
Environment: Amiga, Atari, Mac, MS-DOS, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 103 (of 108)."
# Contents:  dat/hh dat/history dat/license include/monst.h
#   include/obj.h src/write.c sys/atari/setup.g sys/mac/Install.mpw
#   sys/mac/macerrs.c sys/share/NetHack.cnf sys/unix/Makefile.top
#   win/tty/getline.c
# Wrapped by billr@saab on Wed Jan 27 16:09:31 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'dat/hh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dat/hh'\"
else
echo shar: Extracting \"'dat/hh'\" \(4490 characters\)
sed "s/^X//" >'dat/hh' <<'END_OF_FILE'
Xy k u   7 8 9   Move commands:
X \|/     \|/            yuhjklbn: go one step in specified direction
Xh-.-l   4-.-6           YUHJKLBN: go in specified direction until you
X /|\     /|\                        hit a wall or run into something
Xb j n   1 2 3           g<dir>:   run in direction <dir> until something
X      numberpad                     interesting is seen
X                        G<dir>,   same, except a branching corridor isn't
X                        ^<dir>:     considered interesting
X                        m<dir>:   move without picking up objects
X                If the number_pad option is set, the number keys move instead.
X
XGeneral commands:
X?       help    display one of several informative texts
XQ       quit    end the game
XS       save    save the game (to be continued later)
X!       sh      escape to some SHELL (if allowed)
X^Z      suspend suspend the game (independent of your current suspend char)
XO       options set options
X/       whatis  tell what a map symbol represents
X\       known   display list of what's been discovered
Xv       version display version number
XV       history display game history
XX       explore switch the game to explore (discovery) mode
X^A      again   redo the previous command (^A denotes the keystroke CTRL-A)
X^R      redraw  redraw the screen
X^P      prevmsg repeat previous message (subsequent ^P's repeat earlier ones)
X#               introduces an extended command (#? for a list of them)
X
XGame commands:
X^D      kick    kick (a door, or something else)
X^T      'port   teleport (if you can)
Xa       apply   apply or use a tool (pick-axe, key, camera, etc.)
XA       armor   take off all armor
Xc       close   close a door
XC       call    name an individual monster (ex. baptize your dog)
Xd       drop    drop an object.  d7a:  drop seven items of object 'a'
XD       Drop    drop selected types of objects
Xe       eat     eat something
XE       engrave write a message in the dust on the floor  (E-  use fingers)
Xi       invent  list your inventory (all objects you are carrying)
XI       Invent  list selected parts of your inventory
X                Iu: list unpaid objects
X                Ix: list unpaid but used up items
X                I$: count your money
Xo       open    open a door
Xp       pay     pay your bill (in a shop)
XP       puton   put on an accessory (ring, amulet, etc)
Xq       quaff   drink a potion
Xr       read    read a scroll or spell book
XR       remove  remove an accessory (ring, amulet, etc)
Xs       search  search for secret doors, hidden traps and monsters
Xt       throw   throw or shoot a weapon
XT       takeoff take off some armor
Xw       wield   wield a weapon  (w-  wield nothing)
XW       wear    put on some armor
Xx       spells  list the spells you know
Xz       zap     zap a wand
XZ       Zap     cast a spell
X<       up      go up the stairs
X>       down    go down the stairs
X^       trap_id identify a previously found trap
X),[,=,",(               ask for current items of specified symbol in use
X$       gold    count your gold
X+       spells  list the spells you know
X.       rest    wait a moment
X,       pickup  pick up all you can carry
X@               toggle "pickup" (auto pickup) option on and off
X:       look    look at what is here
X;       farlook look at what is somewhere else by selecting a map symbol
X
XKeyboards that have a meta key can also use these extended commands:
X
XM-a     adjust  adjust inventory letters
XM-c     chat    talk to someone
XM-d     dip     dip an object into something
XM-f     force   force a lock
XM-i     invoke  invoke an object's special powers
XM-j     jump    jump to another location
XM-l     loot    loot a box on the floor
XM-m     monster use a monster's special ability (only if defined)
XM-n     name    name an item or type of object
XM-o     offer   offer a sacrifice to the gods
XM-p     pray    pray to the gods for help
XM-r     rub     rub a lamp
XM-s     sit     sit down
XM-t     turn    turn undead
XM-u     untrap  untrap something (usually a trapped object)
XM-v     version print compile time options for this version
XM-w     wipe    wipe off your face
X
XIf the "number_pad" option is on, these additional commands are available:
X
Xn               followed by number of times to repeat the next command
Xj       jump    jump to another location
Xk       kick    kick something (usually a door)
Xl       loot    loot a box on the floor
XN       name    name an item or type of object
Xu       untrap  untrap something (usually a trapped object)
END_OF_FILE
if test 4490 -ne `wc -c <'dat/hh'`; then
    echo shar: \"'dat/hh'\" unpacked with wrong size!
fi
# end of 'dat/hh'
fi
if test -f 'dat/history' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dat/history'\"
else
echo shar: Extracting \"'dat/history'\" \(4962 characters\)
sed "s/^X//" >'dat/history' <<'END_OF_FILE'
X
XBehold, mortal, the origins of NetHack...
X
XJay Fenlason wrote the original Hack with help from Kenny Woodland,
XMike Thome, and Jon Payne.
X
XAndries Brouwer did a major re-write, transforming Hack into a very different
Xgame, and published (at least) three versions (1.0.1, 1.0.2, and 1.0.3) for
XUNIX(tm) machines to the Usenet.
X
XDon G. Kneller ported Hack 1.0.3 to Microsoft(tm) C and MS-DOS(tm), producing
XPC HACK 1.01e, added support for DEC Rainbow graphics in version 1.03g, and
Xwent on to produce at least four more versions (3.0, 3.2, 3.51, and 3.6).
X
XR. Black ported PC HACK 3.51 to Lattice(tm) C and the Atari 520/1040ST,
Xproducing ST Hack 1.03.
X
XMike Stephenson merged these various versions back together, incorporating
Xmany of the added features, and produced NetHack version 1.4.  He then
Xcoordinated a cast of thousands in enhancing and debugging NetHack 1.4 and
Xreleased NetHack versions 2.2 and 2.3.
X 
XLater, Mike coordinated a major rewrite of the game, heading a team which
Xincluded Ken Arromdee, Jean-Christophe Collet, Steve Creps, Eric Hendrickson,
XIzchak Miller, Eric S. Raymond, John Rupley, Mike Threepoint, and Janet Walz,
Xto produce NetHack 3.0c.  The same group subsequently released ten patch-
Xlevel revisions and updates of 3.0.
X
XNetHack 3.0 was ported to the Atari by Eric R. Smith, to OS/2 by Timo
XHakulinen, and to VMS by David Gentzel.  The three of them and Kevin Darcy
Xlater joined the main development team to produce subsequent revisions of
X3.0.
X
XOlaf Seibert ported NetHack 2.3 and 3.0 to the Amiga.  Norm Meluch, Stephen
XSpackman and Pierre Martineau designed overlay code for PC NetHack 3.0.
XJohnny Lee ported NetHack 3.0 to the Macintosh.  Along with various other
XDungeoneers, they continued to enhance the PC, Macintosh, and Amiga ports
Xthrough the later revisions of 3.0.
X 
XHeaded by Mike Stephenson and coordinated by Izchak Miller and Janet Walz,
Xthe development team which now included Ken Arromdee, David Cohrs,
XJean-Christophe Collet, Kevin Darcy, Matt Day, Timo Hakulinen, Steve Linhart,
XDean Luick, Pat Rankin, Eric Raymond, and Eric Smith undertook a radical
Xrevision of 3.0.  They re-structured the game's design, and re-wrote major
Xparts of the code.  They added multiple dungeons, a new display, special
Xindividual character quests, a new endgame and many other new features, and
Xproduced NetHack 3.1.
X
XKen Lorber, Gregg Wonderly and Greg Olson, with help from Richard Addison,
XMike Passaretti, and Olaf Seibert, developed NetHack 3.1 for the Amiga.
X
XNorm Meluch and Kevin Smolkowski, with help from Carl Schelin, Stephen
XSpackman, Steve VanDevender, and Paul Winner, ported NetHack 3.1 to the PC.
X
XJon W{tte, with help from Ross Brown, Mike Engber, David Hairston, Michael
XHamel, Jonathan Handler, Johnny Lee, Tim Lennan, Rob Menke, Andy Swanson, and
Xespecially from Hao-yang Wang, developed NetHack 3.1 for the Macintosh.
X
XTimo Hakulinen ported NetHack 3.1 to OS/2.  Eric Smith ported NetHack 3.1
Xto the Atari.  Pat Rankin, with help from Joshua Delahunty, is responsible
Xfor the VMS version of NetHack 3.1.
X
XDean Luick, with help from David Cohrs, developed NetHack 3.1 for X11.
X
X                           - - - - - - - - - -
X 
XFrom time to time, some depraved individual out there in netland sends a
Xparticularly intriguing modification to help out with the game.  The Gods of
Xthe Dungeon sometimes make note of the names of the worst of these miscreants
Xin this, the list of Dungeoneers:
X
X    Richard Addison           Eric Hendrickson       Mike Passaretti
X    Tom Almy                  Bruce Holloway         Pat Rankin
X    Ken Arromdee              Richard P. Hughey      Eric S. Raymond
X    Eric Backus               Ari Huttunen           Frederick Roeber
X    John S. Bien              John Kallen            John Rupley
X    Ralf Brown                Del Lamb               Carl Schelin
X    Ross Brown                Greg Laskin            Olaf Seibert
X    David Cohrs               Johnny Lee             Kevin Sitze
X    Jean-Christophe Collet    Tim Lennan             Eric R. Smith
X    Steve Creps               Merlyn LeRoy           Kevin Smolkowski
X    Kevin Darcy               Steve Linhart          Michael Sokolov
X    Matthew Day               Ken Lorber             Stephen Spackman
X    Joshua Delahunty          Dean Luick             Andy Swanson
X    Bill Dyer                 Benson I. Margulies    Kevin Sweet
X    Mike Engber               Pierre Martineau       Scott R. Turner
X    Jochen Erwied             Roland McGrath         Steve VanDevender
X    Mike Gallop               Norm Meluch            Janet Walz   
X    David Gentzel             Rob Menke              Hao-yang Wang
X    Mark Gooderum             Deron Meranda          Jon W{tte
X    David Hairston            Bruce Mewborne         Tom West
X    Timo Hakulinen            Izchak Miller          Paul Winner
X    Michael Hamel             Gil Neiger             Gregg Wonderly
X    Jonathan Handler          Greg Olson
END_OF_FILE
if test 4962 -ne `wc -c <'dat/history'`; then
    echo shar: \"'dat/history'\" unpacked with wrong size!
fi
# end of 'dat/history'
fi
if test -f 'dat/license' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dat/license'\"
else
echo shar: Extracting \"'dat/license'\" \(4975 characters\)
sed "s/^X//" >'dat/license' <<'END_OF_FILE'
X                    NETHACK GENERAL PUBLIC LICENSE
X                    (Copyright 1989 M. Stephenson)
X
X               (Based on the BISON general public license,
X                   copyright 1988 Richard M. Stallman)
X
X Everyone is permitted to copy and distribute verbatim copies of this
X license, but changing it is not allowed.  You can also use this wording to
X make the terms for other programs.
X
X  The license agreements of most software companies keep you at the mercy of
Xthose companies.  By contrast, our general public license is intended to give
Xeveryone the right to share NetHack.  To make sure that you get the rights we
Xwant you to have, we need to make restrictions that forbid anyone to deny you
Xthese rights or to ask you to surrender the rights.  Hence this license
Xagreement.
X
X  Specifically, we want to make sure that you have the right to give away
Xcopies of NetHack, that you receive source code or else can get it if you
Xwant it, that you can change NetHack or use pieces of it in new free
Xprograms, and that you know you can do these things.
X
X  To make sure that everyone has such rights, we have to forbid you to
Xdeprive anyone else of these rights.  For example, if you distribute copies
Xof NetHack, you must give the recipients all the rights that you have.  You
Xmust make sure that they, too, receive or can get the source code.  And you
Xmust tell them their rights.
X
X  Also, for our own protection, we must make certain that everyone finds out
Xthat there is no warranty for NetHack.  If NetHack is modified by someone
Xelse and passed on, we want its recipients to know that what they have is
Xnot what we distributed.
X
X  Therefore we (Mike Stephenson and other holders of NetHack copyrights) make
Xthe following terms which say what you must do to be allowed to distribute or
Xchange NetHack.
X
X
X                        COPYING POLICIES
X
X  1. You may copy and distribute verbatim copies of NetHack source code as
Xyou receive it, in any medium, provided that you keep intact the notices on
Xall files that refer to copyrights, to this License Agreement, and to the
Xabsence of any warranty; and give any other recipients of the NetHack
Xprogram a copy of this License Agreement along with the program.
X
X  2. You may modify your copy or copies of NetHack or any portion of it, and
Xcopy and distribute such modifications under the terms of Paragraph 1 above
X(including distributing this License Agreement), provided that you also do the
Xfollowing:
X
X    a) cause the modified files to carry prominent notices stating that you
X    changed the files and the date of any change; and
X
X    b) cause the whole of any work that you distribute or publish, that in
X    whole or in part contains or is a derivative of NetHack or any part
X    thereof, to be licensed at no charge to all third parties on terms
X    identical to those contained in this License Agreement (except that you
X    may choose to grant more extensive warranty protection to some or all
X    third parties, at your option)
X
X    c) You may charge a distribution fee for the physical act of
X    transferring a copy, and you may at your option offer warranty protection
X    in exchange for a fee.
X
X  3. You may copy and distribute NetHack (or a portion or derivative of it,
Xunder Paragraph 2) in object code or executable form under the terms of
XParagraphs 1 and 2 above provided that you also do one of the following:
X
X    a) accompany it with the complete machine-readable source code, which
X    must be distributed under the terms of Paragraphs 1 and 2 above; or,
X
X    b) accompany it with full information as to how to obtain the complete
X    machine-readable source code from an appropriate archive site.  (This
X    alternative is allowed only for noncommercial distribution.)
X
XFor these purposes, complete source code means either the full source
Xdistribution as originally released over Usenet or updated copies of the
Xfiles in this distribution used to create the object code or executable.
X
X  4. You may not copy, sublicense, distribute or transfer NetHack except as
Xexpressly provided under this License Agreement.  Any attempt otherwise to
Xcopy, sublicense, distribute or transfer NetHack is void and your rights to
Xuse the program under this License agreement shall be automatically
Xterminated.  However, parties who have received computer software programs
Xfrom you with this License Agreement will not have their licenses terminated
Xso long as such parties remain in full compliance.
X
X
XStated plainly:  You are prohibited by the terms of this License Agreement
Xfrom using NetHack for gainful purposes.  You are permitted to modify
XNetHack, or otherwise use parts of NetHack, provided that you comply with
Xthe conditions specified above; in particular, your modified NetHack or
Xprogram containing parts of NetHack must remain freely available as provided
Xin this License Agreement.  In other words, go ahead and share NetHack, but
Xdon't try to stop anyone else from sharing it farther.
END_OF_FILE
if test 4975 -ne `wc -c <'dat/license'`; then
    echo shar: \"'dat/license'\" unpacked with wrong size!
fi
# end of 'dat/license'
fi
if test -f 'include/monst.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/monst.h'\"
else
echo shar: Extracting \"'include/monst.h'\" \(4837 characters\)
sed "s/^X//" >'include/monst.h' <<'END_OF_FILE'
X/*	SCCS Id: @(#)monst.h	3.1	92/10/18	*/
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#ifndef MONST_H
X#define MONST_H
X
X#ifdef MUSE
X/* The weapon_check flag is used two ways:
X * 1) When calling mon_wield_item, is 2 or 3 depending on what is desired.
X * 2) Between calls to mon_wield_item, is 0 or 1 depending on whether or not
X *    the weapon is known by the monster to be cursed (so it shouldn't bother
X *    trying for another weapon).
X * I originally planned to also use 0 if the monster already had its best
X * weapon, to avoid the overhead of a call to mon_wield_item, but it turns out
X * that there are enough situations which might make a monster change its
X * weapon that this is impractical.
X */
X#define NO_WEAPON_WANTED 0
X#define NEED_WEAPON 1
X#define NEED_RANGED_WEAPON 2
X#define NEED_HTH_WEAPON 3
X#define NEED_PICK_AXE 4
X#endif
X
X#ifndef ALIGN_H
X#include "align.h"
X#endif
X
Xstruct monst {
X	struct monst *nmon;
X	struct permonst *data;
X	unsigned m_id;
X	short mnum;		/* permanent monster index number */
X	uchar m_lev;		/* adjusted difficulty level of monster */
X	aligntyp malign;	/* alignment of this monster, relative to the
X				   player (positive = good to kill) */
X	xchar mx, my;
X	xchar mux, muy;		/* where the monster thinks you are */
X#define MTSZ	4
X	coord mtrack[MTSZ];	/* monster track */
X	int mhp, mhpmax;
X	unsigned mappearance;	/* for undetected mimics and the wiz */
X	uchar	 m_ap_type;	/* what mappearance is describing: */
X#define M_AP_NOTHING	0	/* mappearance is unused -- monster appears
X				   as itself */
X#define M_AP_FURNITURE	1	/* stairs, a door, an altar, etc. */
X#define M_AP_OBJECT	2	/* an object */
X#define M_AP_MONSTER	3	/* a monster */
X
X	schar mtame;		/* level of tameness, implies peaceful */
X	int mspec_used;		/* monster's special ability attack timeout */
X
X	Bitfield(female,1);	/* is female */
X	Bitfield(minvis,1);	/* invisible */
X	Bitfield(cham,1);	/* shape-changer */
X	Bitfield(mundetected,1);	/* not seen in present hiding place */
X				/* implies one of M1_CONCEAL or M1_HIDE,
X				 * but not mimic (that is, snake, spider,
X				 * trapper, piercer)
X				 */
X	Bitfield(mcan,1);	/* has been cancelled */
X	Bitfield(mspeed,2);
X	/* free bit! */
X
X	Bitfield(mflee,1);	/* fleeing */
X	Bitfield(mfleetim,7);	/* timeout for mflee */
X
X	Bitfield(mcansee,1);	/* cansee 1, temp.blinded 0, blind 0 */
X	Bitfield(mblinded,7);	/* cansee 0, temp.blinded n, blind 0 */
X
X	Bitfield(mcanmove,1);	/* paralysis, similar to mblinded */
X	Bitfield(mfrozen,7);
X
X	Bitfield(msleep,1);	/* sleeping */
X	Bitfield(mstun,1);	/* stunned (off balance) */
X	Bitfield(mconf,1);	/* confused */
X	Bitfield(mpeaceful,1);	/* does not attack unprovoked */
X	Bitfield(mtrapped,1);	/* trapped in a pit or bear trap */
X	Bitfield(mleashed,1);	/* monster is on a leash */
X	Bitfield(isshk,1);	/* is shopkeeper */
X	Bitfield(isminion,1);	/* is a minion */
X
X	Bitfield(isgd,1);	/* is guard */
X	Bitfield(ispriest,1);	/* is a priest */
X	Bitfield(iswiz,1);	/* is the Wizard of Yendor */
X	Bitfield(wormno,5);	/* at most 31 worms on any level */
X#define MAX_NUM_WORMS	32	/* should be 2^(wormno bitfield size) */
X
X	long mstrategy;		/* for monsters with mflag3: current strategy */
X	long mtrapseen;		/* bitmap of traps we've been trapped in */
X	long mlstmv;		/* prevent two moves at once */
X	long mgold;
X	struct obj *minvent;
X#ifdef MUSE
X	struct obj *mw;
X	long misc_worn_check;
X	xchar weapon_check;
X#endif
X	uchar mnamelth;		/* length of name (following mxlth) */
X	short mxlth;		/* length of following data */
X	/* in order to prevent alignment problems mextra should
X	   be (or follow) a long int */
X	int meating;		/* monster is eating timeout */
X	long mextra[1];	/* monster dependent info */
X};
X
X/*
X * Note that mextra[] may correspond to any of a number of structures, which
X * are indicated by some of the other fields.
X *	isgd	 ->	struct egd
X *	ispriest ->	struct epri
X *	isshk	 ->	struct eshk
X *	isminion ->	struct emin
X *			(struct epri for roaming priests and angels, which is
X *			 compatible with emin for polymorph purposes)
X *	mtame	 ->	struct edog
X *			(struct epri for guardian angels, which do not eat
X *			 or do other doggy things)
X * Since at most one structure can be indicated in this manner, it is not
X * possible to tame any creatures using the other structures (the only
X * exception being the guardian angels which are tame on creation).
X */
X
X#define newmonst(xl) (struct monst *)alloc((unsigned)(xl) + sizeof(struct monst))
X#define dealloc_monst(mon) free((genericptr_t)(mon))
X
X/* these are in mspeed */
X#define MSLOW 1		/* slow monster */
X#define MFAST 2		/* speeded monster */
X
X#define NAME(mtmp)	(((char *)(mtmp)->mextra) + (mtmp)->mxlth)
X
X#define MON_WEP(mon)	((mon)->mw)
X#define MON_NOWEP(mon)	((mon)->mw = (struct obj *)0)
X
X#endif /* MONST_H */
END_OF_FILE
if test 4837 -ne `wc -c <'include/monst.h'`; then
    echo shar: \"'include/monst.h'\" unpacked with wrong size!
fi
# end of 'include/monst.h'
fi
if test -f 'include/obj.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/obj.h'\"
else
echo shar: Extracting \"'include/obj.h'\" \(4629 characters\)
sed "s/^X//" >'include/obj.h' <<'END_OF_FILE'
X/*	SCCS Id: @(#)obj.h	3.1	92/10/18	*/
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#ifndef OBJ_H
X#define OBJ_H
X
X/* #define obj obj_nh	/* uncomment for SCO UNIX, which has a conflicting
X			 * typedef for "obj" in <sys/types.h> */
X
Xstruct obj {
X	struct obj *nobj;
X	struct obj *nexthere;	/* for location lists */
X	struct obj *cobj;	/* contents list for containers */
X/*	unsigned o_cwt;		/* container weight capacity */
X	unsigned o_id;
X	xchar ox,oy;
X	short otyp;		/* object class number */
X	unsigned owt;
X	long quan;		/* number of items */
X
X	schar spe;		/* quality of weapon, armor or ring (+ or -)
X				   number of charges for wand ( >= -1 )
X				   marks your eggs, spinach tins
X				   indicates statues have spellbooks inside
X				   tells which fruit a fruit is
X				   marks diluted potions
X				   special for uball and amulet %% BAH */
X	char	oclass;		/* object class */
X	char	invlet;		/* designation in inventory */
X	char	oartifact;	/* artifact array index */
X
X	Bitfield(cursed,1);
X	Bitfield(blessed,1);
X	Bitfield(unpaid,1);	/* on some bill */
X	Bitfield(no_charge,1);	/* if shk shouldn't charge for this */
X	Bitfield(known,1);	/* exact nature known */
X	Bitfield(dknown,1);	/* color or text known */
X	Bitfield(bknown,1);	/* blessing or curse known */
X	Bitfield(rknown,1);	/* rustproof or not known */
X
X	Bitfield(oeroded,2);	/* rusted/corroded/burnt/rotted weapon/armor */
X#define MAX_ERODE 3
X#define orotten oeroded		/* rotten food */
X	Bitfield(oerodeproof,1); /* erodeproof weapon/armor */
X	Bitfield(olocked,1);	/* object is locked */
X#define recharged olocked	/* recharged once */
X	Bitfield(obroken,1);	/* lock has been broken */
X	Bitfield(otrapped,1);	/* container is trapped */
X#define opoisoned otrapped	/* object (weapon) is coated with poison */
X	Bitfield(oldcorpse,1);	/* for troll corpses too old to revive */
X#ifndef NO_SIGNAL
X# define in_use oldcorpse	/* for magic items before useup items */
X#endif
X	Bitfield(lamplit,1);    /* a light-source -- can be lit */
X
X	Bitfield(oinvis,1);	/* not yet implemented */
X	Bitfield(greased,1);	/* covered with grease */
X	Bitfield(onamelth,6);
X
X	int	corpsenm;	/* type of corpse is mons[corpsenm] */
X#define leashmon  corpsenm	/* gets m_id of attached pet */
X#define spestudied corpsenm	/* how many times a spellbook has been studied */
X	unsigned oeaten;	/* nutrition left in food, if partly eaten */
X	long age;		/* creation date */
X	long owornmask;
X
X/* note that TIMEOUT in you.h is defined as 07777L; no bits for items that
X * confer properties may overlap that mask, or timeout.c will happily
X * rearrange the bits behind the back of the property code
X * shirts, balls, and chains are currently safe
X * FROMOUTSIDE and FROMEXPER in you.h are defined as 020000000L and 0400000000L
X * respectively.  Declarations here should not overlap with those bits either.
X */
X#define W_BALL	02000L
X#define W_CHAIN	04000L
X#define W_RINGL	010000L		/* make W_RINGL = RING_LEFT (see uprop) */
X#define W_RINGR	020000L
X#define W_RING	(W_RINGL | W_RINGR)
X#define W_ARM	040000L
X#define W_ARMC	0100000L
X#define W_ARMH	0200000L
X#define W_ARMS	0400000L
X#define W_ARMG	01000000L
X#define W_ARMF	02000000L
X#define W_AMUL	04000000L
X#define W_TOOL	010000000L	/* wearing another tool (see uprop) */
X#define W_WEP	020000000L
X#define W_ART	040000000L	/* _carrying_ an artifact, not really worn */
X#define W_ARTI	0100000000L	/* an invoked artifact, not really worn */
X#ifdef TOURIST
X#define W_ARMU	01000L
X#define W_ARMOR	(W_ARM | W_ARMC | W_ARMH | W_ARMS | W_ARMG | W_ARMF | W_ARMU)
X#else
X#define W_ARMOR	(W_ARM | W_ARMC | W_ARMH | W_ARMS | W_ARMG | W_ARMF)
X#endif
X	long oextra[1];		/* used for name of ordinary objects - length
X				   is flexible; amount for tmp gold objects */
X};
X
X#define newobj(xl)	(struct obj *)alloc((unsigned)(xl) + sizeof(struct obj))
X#define dealloc_obj(obj) free((genericptr_t) (obj))
X#define ONAME(otmp)	((char *)(otmp)->oextra)
X
X#define Is_container(otmp) (otmp->otyp >= LARGE_BOX && \
X			    otmp->otyp <= BAG_OF_TRICKS)
X#define Is_box(otmp)	(otmp->otyp == LARGE_BOX || otmp->otyp == CHEST)
X#define Is_mbag(otmp)	(otmp->otyp == BAG_OF_HOLDING || \
X			 otmp->otyp == BAG_OF_TRICKS)
X
X#define is_sword(otmp)	(otmp->otyp >= SHORT_SWORD && \
X			 otmp->otyp <= RUNESWORD)
X#define is_blade(otmp)	(otmp->otyp >= DAGGER && \
X			 otmp->otyp <= BILL_GUISARME)
X#define bimanual(otmp)	((otmp->oclass == WEAPON_CLASS || \
X			  otmp->otyp == UNICORN_HORN) && \
X			 objects[otmp->otyp].oc_bimanual)
X
X#define Is_candle(otmp)	(otmp->otyp == TALLOW_CANDLE || \
X			 otmp->otyp == WAX_CANDLE)
X
X#endif /* OBJ_H */
END_OF_FILE
if test 4629 -ne `wc -c <'include/obj.h'`; then
    echo shar: \"'include/obj.h'\" unpacked with wrong size!
fi
# end of 'include/obj.h'
fi
if test -f 'src/write.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/write.c'\"
else
echo shar: Extracting \"'src/write.c'\" \(4618 characters\)
sed "s/^X//" >'src/write.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)write.c	3.1	91/01/04
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include "hack.h"
X
Xstatic int FDECL(cost,(struct obj *));
X
X/*
X * returns basecost of a scroll or a spellbook
X */
Xstatic int
Xcost(otmp)
Xregister struct obj *otmp;
X{
X
X	if (otmp->oclass == SPBOOK_CLASS)
X		return(10 * objects[otmp->otyp].oc_level);
X
X	switch(otmp->otyp)  {
X# ifdef MAIL
X	case SCR_MAIL:
X		return(2);
X/*		break; */
X# endif
X	case SCR_LIGHT:
X	case SCR_GOLD_DETECTION:
X	case SCR_FOOD_DETECTION:
X	case SCR_MAGIC_MAPPING:
X	case SCR_AMNESIA:
X	case SCR_FIRE:
X		return(8);
X/*		break; */
X	case SCR_DESTROY_ARMOR:
X	case SCR_CREATE_MONSTER:
X	case SCR_PUNISHMENT:
X		return(10);
X/*		break; */
X	case SCR_CONFUSE_MONSTER:
X		return(12);
X/*		break; */
X	case SCR_IDENTIFY:
X		return(14);
X/*		break; */
X	case SCR_ENCHANT_ARMOR:
X	case SCR_REMOVE_CURSE:
X	case SCR_ENCHANT_WEAPON:
X	case SCR_CHARGING:
X		return(16);
X/*		break; */
X	case SCR_SCARE_MONSTER:
X	case SCR_TAMING:
X	case SCR_TELEPORTATION:
X		return(20);
X/*		break; */
X	case SCR_GENOCIDE:
X		return(30);
X/*		break; */
X	case SCR_BLANK_PAPER:
X	default:
X		impossible("You can't write such a weird scroll!");
X	}
X	return(1000);
X}
X
Xstatic const char NEARDATA write_on[] = { SCROLL_CLASS, SPBOOK_CLASS, 0 };
X
Xint
Xdowrite(pen)
Xregister struct obj *pen;
X{
X	register struct obj *paper;
X	char namebuf[BUFSZ], scrbuf[BUFSZ];
X	register struct obj *new_obj;
X	int basecost, actualcost;
X	int curseval;
X	char qbuf[QBUFSZ];
X	
X	if(!pen)
X		return(0);
X	/* already tested before only call of dowrite() (from doapply())
X	if(pen->otyp != MAGIC_MARKER)  {
X		You("can't write with that!");
X		return(0);
X	}
X	*/
X
X	/* get paper to write on */
X	paper = getobj(write_on,"write on");
X	if(!paper)
X		return(0);
X	if(Blind && !paper->dknown) {
X		You("can't tell if that %s's blank or not!",
X		      paper->oclass == SPBOOK_CLASS ? "spellbook" :
X		      "scroll");
X		return(1);
X	}
X	paper->dknown = 1;
X	if(paper->otyp != SCR_BLANK_PAPER && paper->otyp != SPE_BLANK_PAPER) {
X		You("fool, that %s's not blank!",
X		    paper->oclass == SPBOOK_CLASS ? "spellbook" :
X		    "scroll");
X		return(1);
X	}
X
X	/* what to write */
X	Sprintf(qbuf, "What type of %s do you want to write? ",
X	      paper->oclass == SPBOOK_CLASS ? "spellbook" :
X	      "scroll");
X	getlin(qbuf, namebuf);
X	if(namebuf[0] == '\033' || !namebuf[0])
X		return(1);
X	scrbuf[0] = '\0';
X	if (paper->oclass == SPBOOK_CLASS) {
X		if(strncmp(namebuf,"spellbook of ",13) != 0)
X			Strcpy(scrbuf,"spellbook of ");
X	}
X	else if(strncmp(namebuf,"scroll of ",10) != 0)
X		Strcpy(scrbuf,"scroll of ");
X	Strcat(scrbuf,namebuf);
X	new_obj = readobjnam(scrbuf);
X
X	new_obj->bknown = (paper->bknown && pen->bknown);
X
X	if((new_obj->oclass != SCROLL_CLASS ||
X	              new_obj->otyp == SCR_BLANK_PAPER)
X	    && (new_obj->oclass != SPBOOK_CLASS || 
X                      new_obj->otyp == SPE_BLANK_PAPER)) {
X		You("can't write that!");
X		pline("It's obscene!");
X		obfree(new_obj, (struct obj *) 0); /* pb@ethz.uucp */
X		return(1);
X	}
X
X	/* see if there's enough ink */
X	basecost = cost(new_obj);
X	if(pen->spe < basecost/2)  {
X		Your("marker is too dry to write that!");
X		obfree(new_obj, (struct obj *) 0);
X		return(1);
X	}
X
X	/* we're really going to write now, so calculate cost
X	 */
X	actualcost = rn1(basecost/2,basecost/2);
X	curseval = bcsign(pen) + bcsign(paper);
X	exercise(A_WIS, TRUE);
X	/* dry out marker */
X	if(pen->spe < actualcost)  {
X		Your("marker dries out!");
X		/* scrolls disappear, spellbooks don't */
X		if (paper->oclass == SPBOOK_CLASS)
X			pline("The spellbook is left unfinished.");
X		else {
X			pline("The scroll is now useless and disappears!");
X			useup(paper);
X		}
X		pen->spe = 0;
X		obfree(new_obj, (struct obj *) 0);
X		return(1);
X	}
X	pen->spe -= actualcost;
X
X	/* can't write if we don't know it - unless we're lucky */
X	if(!(objects[new_obj->otyp].oc_name_known) && 
X	   !(objects[new_obj->otyp].oc_uname) && 
X	   (rnl(pl_character[0] == 'W' ? 3 : 15))) {
X		You("don't know how to write that!");
X		/* scrolls disappear, spellbooks don't */
X		if (paper->oclass == SPBOOK_CLASS)
X			You("write in your best handwriting:  \"My Diary\".");
X		else {
X			You("write \"%s was here!\" and the scroll disappears.",plname);
X			useup(paper);
X		}
X		obfree(new_obj, (struct obj *) 0);
X		return(1);
X	}
X
X	/* useup old scroll / spellbook */
X	useup(paper);
X
X	/* now you know it! */
X	makeknown(new_obj->otyp);
X
X	/* success */
X	new_obj = addinv(new_obj);
X	new_obj->blessed = (curseval > 0);
X	new_obj->cursed = (curseval < 0);
X	prinv(NULL, new_obj, 1L);
X#ifdef MAIL
X	if (new_obj->otyp == SCR_MAIL) new_obj->spe = 1;
X#endif
X	new_obj->known = 1;
X	return(1);
X}
X
X/*write.c*/
END_OF_FILE
if test 4618 -ne `wc -c <'src/write.c'`; then
    echo shar: \"'src/write.c'\" unpacked with wrong size!
fi
# end of 'src/write.c'
fi
if test -f 'sys/atari/setup.g' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/atari/setup.g'\"
else
echo shar: Extracting \"'sys/atari/setup.g'\" \(288 characters\)
sed "s/^X//" >'sys/atari/setup.g' <<'END_OF_FILE'
X# gulam shell script -- should work with tcsh and many
X# other Atari shells, too
X
Xcp ..\unix\Makefile.top ..\..\Makefile
Xcp ..\unix\Makefile.dat ..\..\dat\Makefile
Xcp ..\unix\Makefile.doc ..\..\doc\Makefile
Xcp ..\unix\Makefile.src ..\..\src\Makefile
Xcp .\Makefile.utl ..\..\util\Makefile
END_OF_FILE
if test 288 -ne `wc -c <'sys/atari/setup.g'`; then
    echo shar: \"'sys/atari/setup.g'\" unpacked with wrong size!
fi
# end of 'sys/atari/setup.g'
fi
if test -f 'sys/mac/Install.mpw' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/mac/Install.mpw'\"
else
echo shar: Extracting \"'sys/mac/Install.mpw'\" \(4858 characters\)
sed "s/^X//" >'sys/mac/Install.mpw' <<'END_OF_FILE'
XHow to make Mac NetHack 3.1 using MPW
XCopyright (c) 1992-11-23 Jon W{tte
X
X
XPlease read these instructions through carefully before starting to
Xbuild NetHack for the Macintosh.  Most important is the part about
Xkeeping the folder structure intact, and how to move a few files
Xaround.
X
XFor me, having done this a few times, steps 1-7 take less than five
Xminutes.  Add to that an average compilation time of 25 minutes
X(without VISION_TABLES, see below) and a full build of NetHack from
Xscratch doesn't take more than a lunch break.
X
X0)	Requirements:
X	- MPW C 3.2
X	- Mac with 68020 or better CPU (this is required to run MPW 3.2)
X	- 10 MB free disk (at least)
X	- 8 MB memory (using System 6, or a slimmed System 7)
X	  More is quite preferable.
X	- About 7 minutes of time on a Quadra with a RAM disk that fits
X	  the entire compilation.  Less than an hour for an SE/30 with
X	  standard hard disk.
X	- Do NOT use virtual memory, or the compilation will quite possibly
X	  take the whole weekend.  We're serious.
X
X1)	Move all source files onto your hard disk.  Make sure to keep the
X	folder structure the way it is.  You can skip the "tty" "X11" "amiga"
X	"msdos" "os2" and "vms" folders if you are hard pressed for space.
X	Also make sure the files are in native mac text format (i.e. ASCII
X	13 is used for newlines).
X
X2)	De-binhex the file :sys:mac:NHmake.hqx using Stuffit, Compact Pro,
X	tickle, or any other de-binhexer.  Move the resulting file
X	(Nethack.make) into the "top" folder (the one containing the
X	folders "src" "include" etc).
X
X3)	De-binhex the files :sys:mac:NHrez.hqx, :sys:mac:NHrsrc.hqx and
X	:sys:mac:NHsound.hqx. If there is no sound file, or you do not
X	want the sounds (they take up 200K in the final binary) you must
X	create an empty resource file called "Sounds.rsrc" in the folder
X	:sys:mac, using ResEdit.
X	The resulting files should be left in :sys:mac:
X
X4)	Edit the make file Nethack.make to set the Top variable.  If your top
X	folder is called "nh31" and is in the MPW folder, this is not needed.
X
X5)	Create two new folders in the top folder, named "Dungeon" and "Obj".
X
X6)	You may want to edit some of the options in :include:config.h to suit
X	your tastes.  However, using MPW, this file will self-configure for
X	the default Mac distribution.
X
X	NOTE: The make file defines VISION_TABLES, and macconf.h sets
X	the option BRACES to match, so you should not concern yourself
X	with that option in config.h. However, compiling with the option
X	VISION_TABLES will generate a faster binary, at the expense of
X	the size of the application, and compilation time.
X
X	Your MPW shell will need at least 7000K REAL MEMORY (TempMem
X	won't do) for this compile to work. If you don't have it, you
X	can try removing the VISION_TABLES option in the make file,
X	you will however still need around 3000K for the MPW shell.
X
X7)	Use BuildProgram on the make file. This is Cmd-B for most folks.
X	Sit back and relax. The linker will spew out a lot of warnings
X	about global data size (Error 34) but that's OK. If you don't
X	want the warnings, turn on -model far in the make file; this will
X	make a slightly less efficient program but gives no warnings.
X
X8)	When the build is done, a short melody is played, and the results are
X	in the Dungeon folder.  Enjoy!
X
X9)	If you want to make any changes to the dungeon compiler or the special
X	level compiler, you will need to edit the makefile to remove the
X	dependencies for dgn_comp.h and lev_comp.h.  You should then add 
X	dependencies for dgn_lex.c and lev_lex.c (output by lex) You
X	will also need dependencies for dgn_yacc.c and lev_yacc.c (Output
X	of yacc).  All four of these files should end up in the Top:sys:share
X	folder.  Finally, the y.tab.h output from yacc should end up in
X	the include folder as dgn_comp.h/lev_comp.h.
X	
X
X10)	If, heaven forbid, you experience any configuration problems or make
X	errors, try to fix it yourself (there are several READMEs and the
X	like you can check), but be sure to save a copy of the original files
X	if you change anything.  There should be no problems if you use the
X	correct versions etc. as per step 0 but you never know.  As always,
X	turn off all INITs and re-boot if you have any problems, and they
X	might go away.
X
X	If you experience any bugs, please mail them to the bug report address
X	nethack-bugs@linc.cis.upenn.edu
X	Be sure to include what computer you use, how it is configured, what
X	version of MPW and C and the headers you use, where you got the
X	NetHack code etc. etc.
X
X11)	This code is provided "as is" free of charge, and no warranty of any
X	kind can or will cover it.  Use at your own risk.  This code is
X	protected under copyright law, and may only be re-distributed under
X	the terms of the NetHack license also found in this package, or
X	otherwise with the authors' permission.  (If the license is missing,
X	mail the bug report address for a copy.)
END_OF_FILE
if test 4858 -ne `wc -c <'sys/mac/Install.mpw'`; then
    echo shar: \"'sys/mac/Install.mpw'\" unpacked with wrong size!
fi
# end of 'sys/mac/Install.mpw'
fi
if test -f 'sys/mac/macerrs.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/mac/macerrs.c'\"
else
echo shar: Extracting \"'sys/mac/macerrs.c'\" \(4349 characters\)
sed "s/^X//" >'sys/mac/macerrs.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)macerrs.c	3.1	93/01/24		  */
X/* Copyright (c) Michael Hamel, 1991 */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#ifdef applec	/* This needs to be resident always */
X#pragma segment Main
X#endif
X
X#include "hack.h"
X
X#include <OSUtils.h>
X#include <files.h>
X#include <Types.h>
X#ifdef MAC_MPW32
X#include <String.h>
X#include <Strings.h>
X#endif
X#ifdef MAC_THINKC5
X#include <pascal.h>
X#endif
X#include <Dialogs.h>
X#include <Packages.h>
X#include <ToolUtils.h>
X#include <Resources.h>
X
X#define stackDepth  4
X#define errAlertID 129
X#define stdIOErrID 1999
X
Xvoid FDECL(comment,(char *, long));
Xvoid FDECL(showerror,(char *, const char *));
XBoolean FDECL(itworked,(short));
Xvoid FDECL(mustwork,(short));
Xstatic void VDECL(vprogerror,(const char *line, va_list the_args));
Xvoid FDECL(attemptingto,( char * activity ));
Xvoid FDECL(pushattemptingto,( char * activity ));
Xvoid NDECL(popattempt);
X
Xstatic Str255 gActivities[stackDepth] = {"","","",""};
Xstatic short gTopactivity = 1;
X
Xvoid  comment( char *s, long n )
X{
X  Str255 paserr;
X  short itemHit;
X  
X  sprintf((char *)paserr, "%s - %d",s,n);
X  ParamText(c2pstr((char *)paserr),(StringPtr)"",(StringPtr)"",(StringPtr)"");
X  itemHit = Alert(128, (ModalFilterProcPtr)nil);
X}
X
Xvoid showerror( char * errdesc, const char * errcomment )
X{
X   	short		itemHit;
X	Str255		paserr,
X				pascomment;
X				
X	SetCursor(&qd.arrow);
X	if (errcomment == nil)  pascomment[0] = '\0';
X	  else strcpy((char *)pascomment,(char *)errcomment);
X	strcpy((char *)paserr,(char *)errdesc);
X	ParamText(c2pstr((char *)paserr),c2pstr((char *)pascomment),gActivities[gTopactivity],(StringPtr)"");
X	itemHit = Alert(errAlertID, (ModalFilterProcPtr)nil);
X}
X
X
XBoolean itworked( short errcode )
X/* Return TRUE if it worked, do an error message and return false if it didn't. Error
X   strings for native C errors are in STR#1999, Mac errs in STR 2000-errcode, e.g
X   2108 for not enough memory */
X
X{
X  if (errcode != 0) {
X    short		 itemHit;
X	Str255 		 errdesc;
X	StringHandle strh;
X	Ptr			 junk;
X	
X	errdesc[0] = '\0';
X	if (errcode > 0) GetIndString(errdesc,stdIOErrID,errcode);  /* STDIO file rres, etc */
X	else {
X	   strh = GetString(2000-errcode);
X	   if (strh != (StringHandle) nil) {
X	      memcpy(errdesc,*strh,256);
X		  ReleaseResource((Handle)strh);
X	   }
X	}
X	if (errdesc[0] == '\0') {  /* No description found, just give the number */
X	   sprintf((char *)errdesc,"a %d error occurred",errcode);
X	   (void)c2pstr((char *)errdesc);
X	}
X	SetCursor(&qd.arrow);
X	ParamText(errdesc,(StringPtr)"",gActivities[gTopactivity],(StringPtr)"");
X	itemHit = Alert(errAlertID, (ModalFilterProcPtr)nil);
X
X  }
X  return(errcode==0);
X}
X
Xvoid mustwork( short errcode )
X/* For cases where we can't recover from the error by any means */
X{
X  if (itworked(errcode)) ;
X  	 else ExitToShell();
X}
X
X
X#if defined(USE_STDARG) || defined(USE_VARARGS)
X# ifdef USE_STDARG
Xstatic void vprogerror(const char *line, va_list the_args);
X# else
Xstatic void vprogerror();
X# endif
X
X/* Macro substitute for error() */
Xvoid progerror VA_DECL(const char *, line)
X	VA_START(line);
X	VA_INIT(line, char *);
X	vprogerror(line, VA_ARGS);
X	VA_END();
X}
X
X# ifdef USE_STDARG
Xstatic void
Xvprogerror(const char *line, va_list the_args) {
X# else
Xstatic void
Xvprogerror(line, the_args) const char *line; va_list the_args; {
X# endif
X
X#else  /* USE_STDARG | USE_VARARG */
X
Xvoid
Xprogerror VA_DECL(const char *, line)
X#endif
X/* Do NOT use VA_START and VA_END in here... see above */
X
X	if(!index(line, '%'))
X	    showerror("of an internal error",line);
X	else {
X	    char pbuf[BUFSZ];
X	    Vsprintf(pbuf,line,VA_ARGS);
X	    showerror("of an internal error",pbuf);
X	}
X}
X
Xvoid attemptingto( char * activity )
X/* Say what we are trying to do for subsequent error-handling: will appear as x in an
X   alert in the form "Could not x because y" */
X{
X   strcpy((char *)gActivities[gTopactivity],activity);
X   activity = (char *)c2pstr((char *)gActivities[gTopactivity]);
X}
X
Xvoid pushattemptingto( char * activity )
X/* Push a new description onto stack so we can pop later to previous state */
X{
X  if (gTopactivity < stackDepth) {
X    gTopactivity++;
X    attemptingto(activity);
X  }
X  else progerror("activity stack overflow");
X}
X
Xvoid popattempt( void )
X/* Pop to previous state */
X{
X  if (gTopactivity > 1) --gTopactivity;
X				   else progerror("activity stack underflow");
X}
END_OF_FILE
if test 4349 -ne `wc -c <'sys/mac/macerrs.c'`; then
    echo shar: \"'sys/mac/macerrs.c'\" unpacked with wrong size!
fi
# end of 'sys/mac/macerrs.c'
fi
if test -f 'sys/share/NetHack.cnf' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/share/NetHack.cnf'\"
else
echo shar: Extracting \"'sys/share/NetHack.cnf'\" \(4547 characters\)
sed "s/^X//" >'sys/share/NetHack.cnf' <<'END_OF_FILE'
X# A '#' at the beginning of a line means the rest of the line is a comment.
X#
X# This configuration file is set up for two cases, for a hard disk
X# (as drive C:), and for two floppy disks.
X#
X# To change the configuration, comment out the unwanted lines, and
X# uncomment the configuration you want.
X
X
X# *** OPTIONS ***
X#
X# These two options should be used for most setups.  If you're machine isn't
X# very IBM-compatible, and NetHack doesn't work, try commenting out this line.
X#
XOPTIONS=rawio,BIOS,IBMgraphics
X# DEC Rainbows will hang if rawio is set, so they should instead use:
X#OPTIONS=BIOS,DECgraphics
X#
X#
X# Some options to set personal preferences.  Uncomment and change these to
X# suit your personal preference.  If several people are to use the same
X# configuration, options like these should not be set.
X#
X#OPTIONS=name:Janet-V,female,dogname:Fido,catname:Morris,fruit:apricot
X#OPTIONS=packorder:")[%?+/=!(*0_`,scores:10 top/2 around/own
X#
X#
X# Other general options.  You might also set "silent" so as not to attract
X# the boss's attention.
X#
XOPTIONS=time,rest_on_space,nopickup,number_pad
X
X
X# *** HARD DISK CONFIGURATION ***
X#
XHACKDIR=c:\games\nethack
X#
X#   LEVELS and SAVE default to HACKDIR
X#
X#LEVELS=c:\games\nethack\bones
X#SAVE=c:\games\nethack\bones;n
X#
X#   appending a ";n" to SAVE means don't prompt to insert a disk.
XSAVE=;n
X#
X# Note that RAMDISK must *not* be the same (or even implicitly
X# get expanded to the same path by the OS) as HACKDIR.
X#
X#RAMDISK=d:
X
X
X# *** 2-FLOPPY CONFIGURATION ***
X#
X# HACKDIR=a:\
X# LEVELS=b:\
X# SAVE=b:\
X# RAMDISK=c:
X
X
X# *** CHARACTER GRAPHICS ***
X#
X# The 69 GRAPHICS characters (0-68) are:
X#
X# stone,
X# walls: vertical, horizontal,
X#	 4 corners: top left, top right, bottom left, bottom right,
X#	 cross wall,
X#	 4 T walls: upward, downward, left, right,
X# doors: no door,
X#	 open doors: vertical, horizontal,
X#	 closed doors: vertical, horizontal,
X# floor,
X# corridors: unlit, lit,
X# stairs up, stairs down, ladder up, ladder down,
X# trap, web, altar, throne, sink, fountain, pool/moat, ice, lava,
X# lowered drawbridge: vertical, horizontal,
X# raised drawbridge: vertical, horizontal,
X# air, cloud, water,
X# 4 beams: vertical, horizontal, left slant, right slant,
X# digging beam, camera flash beam, left boomerang, right boomerang,
X# 4 magic shield display symbols,
X# 8 swallowed: top left/middle/right, mid left/right, bottom left/mid/right,
X# 9 explosion: [3 rows (top, middle, bottom) of 3 characters]
X#
X# If you specify fewer that 69 ASCII values, the remaining characters will be
X# set to their respective defaults:
X#	   ' '  |   -   -   -   -   -   -   -   -
X#           |   |   .   -   |   +   +   .   #   #
X#	    <   >   <   >   ^   "   _   \   #   {
X#	    }   .   }   .   .   #   #  ' '  #   }
X#	    |   -   \   /   *   !   )   (   0   #
X#	    @   *   /   -   \   |   |   \   -   /
X#	    /   -   \   |  ' '  |   \   -   /
X#
X# If you merely set the IBMgraphics option as above, NetHack will use IBM
X# extended ASCII for dungeon characters.  If you don't like the selections,
X# you can make up your own via the graphics option, but you should still set
X# IBMgraphics if you are using IBM graphics characters to get the correct
X# processing.
X#
X# An example using the IBM graphics character set:
X#GRAPHICS= 032 179 196 218 191 192 217 197 193 194 \
X#	   180 195 249 239 239 254 254 249 177 177 \
X#	   060 062 060 062 094 157 220 190 035 244 \
X#	   247 249 247 042 042 186 205 046 035 247 \
X#	   179 196 092 047 042 033 041 040 048 035 \
X#	   064 042 047 045 092 058 058 092 045 047 \
X#	   047 045 092 058 032 058 092 045 047
X# An alternative:
X#GRAPHICS= 032 186 205 201 187 200 188 206 202 203 \
X#	   185 204 249 239 239 254 254 249 177 177 \
X#	   060 062 060 062 094 034 095 092 035 244 \
X#	   247 249 247 042 042 179 196 046 035 247 \
X#	   179 196 092 047 042 033 041 040 048 035 \
X#	   064 042 047 045 092 058 058 092 045 047 \
X#	   047 045 092 058 032 058 092 045 047
X#
X
X#
X# Using the DEC Rainbow/ANSI line-drawing character set:
X#
X# If you have compiled with TERMLIB, merely set the DECgraphics option as
X# above.  NetHack will then switch into the VTxxx line-drawing character set
X# (aka ANSI ruling character set '0') for dungeon characters.  If you don't
X# like the selections, you can make up your own via the graphics option,
X# adding 128 to the value of any line-drawing character you want to use.
X# (But you should still set DECgraphics to get the correct processing.)
X#
X#GRAPHICS= 032 248 241 236 235 237 234 238 246 247 \
X#	   245 244 248 241 092 047 254 241 248 043 \
X#	   254 225
END_OF_FILE
if test 4547 -ne `wc -c <'sys/share/NetHack.cnf'`; then
    echo shar: \"'sys/share/NetHack.cnf'\" unpacked with wrong size!
fi
# end of 'sys/share/NetHack.cnf'
fi
if test -f 'sys/unix/Makefile.top' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/unix/Makefile.top'\"
else
echo shar: Extracting \"'sys/unix/Makefile.top'\" \(4893 characters\)
sed "s/^X//" >'sys/unix/Makefile.top' <<'END_OF_FILE'
X#	NetHack Makefile.
X#	SCCS Id: @(#)Makefile.top	3.1	92/01/05
X
X# newer makes predefine $(MAKE) to 'make' and do smarter processing of
X# recursive make calls if $(MAKE) is used
X# these makes allow $(MAKE) to be overridden by the environment if someone
X# wants to (or has to) use something other than the standard make, so we do
X# not want to unconditionally set $(MAKE) here
X#
X# unfortunately, some older makes do not predefine $(MAKE); if you have one of
X# these, uncomment the following line
X# (you will know that you have one if you get complaints about unable to
X# execute things like 'data' and 'rumors')
X# MAKE = make
X
X# make NetHack
XGAME     = nethack
XGAMEUID  = games
XGAMEGRP  = bin
X
X# Permissions - some places use setgid instead of setuid, for instance
X# See also the option "SECURE" in include/config.h
XGAMEPERM = 04755
XFILEPERM = 0644
XEXEPERM  = 0755
XDIRPERM  = 0755
X
X# GAMEDIR also appears in config.h as "HACKDIR".
X#
X# note that 'make install' believes in creating a nice tidy GAMEDIR for
X# installation, free of debris from previous NetHack versions --
X# therefore there should not be anything in GAMEDIR that you want to keep
X# (if there is, you'll have to do the installation by hand or modify the
X# instructions)
XGAMEDIR  = /usr/games/lib/$(GAME)dir
XSHELLDIR = /usr/games
X
XDATHELP = help hh cmdhelp history opthelp wizhelp
XVARDAT = data oracles options quest.dat rumors
X
XSPEC_LEVS = asmodeus.lev baalz.lev bigroom.lev castle.lev fakewiz?.lev \
X	juiblex.lev knox.lev medusa-?.lev mine_end.lev minefill.lev \
X	minetown.lev oracle.lev orcus.lev sanctum.lev tower?.lev valley.lev \
X	wizard?.lev astral.lev air.lev earth.lev fire.lev water.lev
XQUEST_LEVS = ?-goal.lev ?-fill?.lev ?-locate.lev ?-start.lev
X
XSCRIPT = dungeon
XDAT = $(DATHELP) $(VARDAT) $(SPEC_LEVS) $(QUEST_LEVS) $(SCRIPT) license
X
X$(GAME):
X	( cd src ; $(MAKE) )
X
Xall:	$(GAME) Guidebook $(VARDAT) dungeon spec_levs
X	@echo "Done."
X
XGuidebook:
X	( cd doc ; $(MAKE) Guidebook )
X
Xmanpages:
X	( cd doc ; $(MAKE) manpages )
X
Xdata:
X	( cd dat ; $(MAKE) data )
X
Xrumors:
X	( cd dat ; $(MAKE) rumors )
X
Xoracles:
X	( cd dat ; $(MAKE) oracles )
X
X#	Note: options should have already been made with make, but...
Xoptions:
X	( cd dat ; $(MAKE) options )
X
Xquest.dat:
X	( cd dat ; $(MAKE) quest.dat )
X
Xspec_levs:
X	( cd util ; $(MAKE) lev_comp )
X	( cd dat ; $(MAKE) spec_levs )
X	( cd dat ; $(MAKE) quest_levs )
X	
Xdungeon:
X	( cd util ; $(MAKE) dgn_comp )
X	( cd dat ; $(MAKE) dungeon )
X	
Xupdate: $(GAME) $(VARDAT) dungeon spec_levs
X#	(don't yank the old version out from under people who're playing it)
X	-mv $(GAMEDIR)/$(GAME) $(GAMEDIR)/$(GAME).old
X#	quest.dat is also kept open and has the same problems over NFS
X	-mv $(GAMEDIR)/quest.dat $(GAMEDIR)/quest.dat.old
X# copy over new versions of the game files
X	( cd dat ; cp $(DAT) $(GAMEDIR) )
X	cp src/$(GAME) $(GAMEDIR)
X	-rm -f $(SHELLDIR)/$(GAME)
X	sed -e 's;/usr/games/lib/nethackdir;$(GAMEDIR);' \
X		-e 's;HACKDIR/nethack;HACKDIR/$(GAME);' \
X		< sys/unix/nethack.sh \
X		> $(SHELLDIR)/$(GAME)
X# correct the permissions on the new versions
X	-( cd $(GAMEDIR) ; chown $(GAMEUID) $(DAT) $(GAME) ; \
X			chgrp $(GAMEGRP) $(DAT) $(GAME) ; \
X			chmod $(FILEPERM) $(DAT) )
X	-chown $(GAMEUID) $(SHELLDIR)/$(GAME)
X	chgrp $(GAMEGRP) $(SHELLDIR)/$(GAME)
X	chmod $(EXEPERM) $(SHELLDIR)/$(GAME)
X	chmod $(GAMEPERM) $(GAMEDIR)/$(GAME)
X# touch time-sensitive files
X	-touch -c $(GAMEDIR)/bones* $(GAMEDIR)/?lock* $(GAMEDIR)/wizard*
X	-touch -c $(GAMEDIR)/save/*
X	touch $(GAMEDIR)/perm $(GAMEDIR)/record
X# and a reminder
X	@echo You may also want to install the man pages via the doc Makefile.
X
Xinstall: $(GAME) $(VARDAT) dungeon spec_levs
X# set up the directories
X	-mkdir $(SHELLDIR)
X	-rm -rf $(GAMEDIR)
X	-mkdir $(GAMEDIR) $(GAMEDIR)/save
X# create some files
X	touch $(GAMEDIR)/perm $(GAMEDIR)/record $(GAMEDIR)/logfile
X# copy over the game files
X	( cd dat ; cp $(DAT) $(GAMEDIR) )
X	cp src/$(GAME) $(GAMEDIR)
X	-rm -f $(SHELLDIR)/$(GAME)
X	sed -e 's;/usr/games/lib/nethackdir;$(GAMEDIR);' \
X		-e 's;HACKDIR/nethack;HACKDIR/$(GAME);' \
X		< sys/unix/nethack.sh \
X		> $(SHELLDIR)/$(GAME)
X# set up the permissions
X	-( cd $(GAMEDIR) ; chown $(GAMEUID) . * $(SHELLDIR)/$(GAME) )
X	( cd $(GAMEDIR) ; chgrp $(GAMEGRP) . * $(SHELLDIR)/$(GAME) )
X	chmod $(EXEPERM) $(SHELLDIR)/$(GAME)
X	chmod $(FILEPERM) $(GAMEDIR)/*
X	chmod $(DIRPERM) $(GAMEDIR) $(GAMEDIR)/save
X	chmod $(GAMEPERM) $(GAMEDIR)/$(GAME)
X# and a reminder
X	@echo You may also want to reinstall the man pages via the doc Makefile.
X
X# 'make clean' removes all the .o files, but leaves around all the executables
X# and compiled data files
Xclean:
X	( cd src ; $(MAKE) clean )
X	( cd util ; $(MAKE) clean )
X
X# 'make spotless' returns the source tree to near-distribution condition.
X# it removes .o files, executables, and compiled data files
Xspotless:
X	( cd src ; $(MAKE) spotless )
X	( cd util ; $(MAKE) spotless )
X	( cd dat ; $(MAKE) spotless )
X	( cd doc ; $(MAKE) spotless )
END_OF_FILE
if test 4893 -ne `wc -c <'sys/unix/Makefile.top'`; then
    echo shar: \"'sys/unix/Makefile.top'\" unpacked with wrong size!
fi
# end of 'sys/unix/Makefile.top'
fi
if test -f 'win/tty/getline.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'win/tty/getline.c'\"
else
echo shar: Extracting \"'win/tty/getline.c'\" \(4670 characters\)
sed "s/^X//" >'win/tty/getline.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)getline.c	3.1	92/01/05	*/
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include "hack.h"
X#include "wintty.h"
X#include "func_tab.h"
X
X#ifdef OVL1
X
Xchar morc = 0;	/* tell the outside world what char you chose */
X
X#endif /* OVL1 */
X
Xextern char erase_char, kill_char;	/* from appropriate tty.c file */
X
X#ifdef OVL1
X
X/*
X * Read a line closed with '\n' into the array char bufp[BUFSZ].
X * (The '\n' is not stored. The string is closed with a '\0'.)
X * Reading can be interrupted by an escape ('\033') - now the
X * resulting string is "\033".
X */
Xvoid
Xtty_getlin(query, bufp)
Xconst char *query;
Xregister char *bufp;
X{
X	register char *obufp = bufp;
X	register int c;
X	struct WinDesc *cw = wins[WIN_MESSAGE];
X	boolean doprev = 0;
X
X	if(ttyDisplay->toplin == 1 && !(cw->flags & WIN_STOP)) more();
X	cw->flags &= ~WIN_STOP;
X	ttyDisplay->toplin = 3; /* special prompt state */
X	ttyDisplay->inread++;
X	pline("%s ", query);
X	for(;;) {
X		(void) fflush(stdout);
X		if((c = Getchar()) == EOF) {
X			*bufp = 0;
X			break;
X		}
X		if(c == '\033') {
X			*obufp = c;
X			obufp[1] = 0;
X			break;
X		}
X		if(c == '\020') { /* ctrl-P */
X		    if(!doprev)
X			(void) tty_doprev_message(); /* need two initially */
X		    (void) tty_doprev_message();
X		    doprev = 1;
X		    continue;
X		} else if(doprev) {
X		    tty_clear_nhwindow(WIN_MESSAGE);
X		    cw->maxcol = cw->maxrow;
X		    doprev = 0;
X		    addtopl(query);
X		    addtopl(" ");
X		    *bufp = 0;
X		    addtopl(obufp);
X		}
X		if(c == erase_char || c == '\b') {
X			if(bufp != obufp) {
X				bufp--;
X				putsyms("\b \b");/* putsym converts \b */
X			} else	tty_nhbell();
X#if defined(apollo)
X		} else if(c == '\n' || c == '\r') {
X#else
X		} else if(c == '\n') {
X#endif
X			*bufp = 0;
X			break;
X		} else if(' ' <= c && c < '\177' && 
X			    (bufp-obufp < BUFSZ-1 || bufp-obufp < COLNO)) {
X				/* avoid isprint() - some people don't have it
X				   ' ' is not always a printing char */
X			*bufp = c;
X			bufp[1] = 0;
X			putsyms(bufp);
X			bufp++;
X		} else if(c == kill_char || c == '\177') { /* Robert Viduya */
X				/* this test last - @ might be the kill_char */
X			while(bufp != obufp) {
X				bufp--;
X				putsyms("\b \b");
X			}
X		} else
X			tty_nhbell();
X	}
X	ttyDisplay->toplin = 2;		/* nonempty, no --More-- required */
X	ttyDisplay->inread--;
X}
X
Xvoid
Xxwaitforspace(s)
Xregister const char *s;	/* chars allowed besides space or return */
X{
X    register int c;
X
X    morc = 0;
X
X    while((c = tty_nhgetch()) != '\n') {
X	if(flags.cbreak) {
X	    if(c == ' ') break;
X	    if(s && index(s,c)) {
X		morc = c;
X		break;
X	    }
X	    tty_nhbell();
X	}
X    }
X
X}
X
X#endif /* OVL1 */
X#ifdef OVL2
X
X#ifdef COM_COMPL
X/* Read in an extended command - doing command line completion for
X * when enough characters have been entered to make a unique command.
X * This is just a modified getlin().   -jsb
X */
Xvoid
Xtty_get_ext_cmd(bufp)
Xregister char *bufp;
X{
X	register char *obufp = bufp;
X	register int c;
X	int com_index, oindex;
X
X	pline("# ");
X	ttyDisplay->toplin = 2;		/* nonempty, no --More-- required */
X
X	for(;;) {
X		(void) fflush(stdout);
X		if((c = readchar()) == EOF) {
X			*bufp = 0;
X			return;
X		}
X		if(c == '\033') {
X			*obufp = c;
X			obufp[1] = 0;
X			return;
X		}
X		if(c == erase_char || c == '\b') {
X			if(bufp != obufp) {
X				bufp--;
X				putsyms("\b \b"); /* putsym converts \b */
X			} else	tty_nhbell();
X#if defined(apollo)
X		} else if(c == '\n' || c == '\r') {
X#else
X		} else if(c == '\n') {
X#endif
X			*bufp = 0;
X			return;
X		} else if(' ' <= c && c < '\177') {
X				/* avoid isprint() - some people don't have it
X				   ' ' is not always a printing char */
X			*bufp = c;
X			bufp[1] = 0;
X			oindex = 0;
X			com_index = -1;
X
X			while(extcmdlist[oindex].ef_txt != NULL){
X				if(!strncmpi(obufp, extcmdlist[oindex].ef_txt,
X				    strlen(obufp)))
X					if(com_index == -1) /* No matches yet*/
X					    com_index = oindex;
X					else /* More than 1 match */
X					    com_index = -2;
X				oindex++;
X			}
X			if(com_index >= 0){
X				Strcpy(obufp, extcmdlist[com_index].ef_txt);
X				/* finish printing our string */
X				putsyms(bufp);
X				bufp = obufp; /* reset it */
X				if((int)strlen(obufp) < BUFSZ-1 &&
X						(int)strlen(obufp) < COLNO)
X					/* set bufp at the end of our string */
X					bufp += strlen(obufp);
X			} else {
X				putsyms(bufp);
X				if(bufp-obufp < BUFSZ-1 && bufp-obufp < COLNO)
X					bufp++;
X			}
X		} else if(c == kill_char || c == '\177') { /* Robert Viduya */
X				/* this test last - @ might be the kill_char */
X			while(bufp != obufp) {
X				bufp--;
X				putsyms("\b \b");
X			}
X		} else
X			tty_nhbell();
X	}
X
X}
X#endif /* COM_COMPL */
X
X#endif /* OVL2 */
X
X/*getline.c*/
END_OF_FILE
if test 4670 -ne `wc -c <'win/tty/getline.c'`; then
    echo shar: \"'win/tty/getline.c'\" unpacked with wrong size!
fi
# end of 'win/tty/getline.c'
fi
echo shar: End of archive 103 \(of 108\).
cp /dev/null ark103isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \
21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \
41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 \
61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 \
81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 \
101 102 103 104 105 106 107 108 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 108 archives.
    echo "Now execute 'rebuild.sh'"
    rm -f ark10[0-8]isdone ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
