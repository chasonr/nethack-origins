Path: uunet!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v16i065:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Part57/108
Message-ID: <4368@master.CNA.TEK.COM>
Date: 1 Feb 93 19:44:26 GMT
Sender: news@master.CNA.TEK.COM
Lines: 2177
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1615

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 16, Issue 65
Archive-name: nethack31/Part57
Supersedes: nethack3p9: Volume 10, Issue 46-102
Environment: Amiga, Atari, Mac, MS-DOS, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 57 (of 108)."
# Contents:  src/mhitu.c2 sys/share/dgn_yacc.c
# Wrapped by billr@saab on Wed Jan 27 16:09:09 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'src/mhitu.c2' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/mhitu.c2'\"
else
echo shar: Extracting \"'src/mhitu.c2'\" \(21658 characters\)
sed "s/^X//" >'src/mhitu.c2' <<'END_OF_FILE'
X#ifdef OVLB
X
XSTATIC_OVL int
Xgulpmu(mtmp, mattk)	/* monster swallows you, or damage if u.uswallow */
X	register struct monst *mtmp;
X	register struct attack  *mattk;
X{
X	struct trap *t = t_at(u.ux, u.uy);
X	int	tmp = d((int)mattk->damn, (int)mattk->damd);
X	int	tim_tmp;
X	register struct obj *otmp2;
X#ifdef WALKIES
X	int	i;
X#endif
X
X	if(!u.uswallow) {	/* swallows you */
X#ifdef POLYSELF
X		if (uasmon->msize >= MZ_HUGE) return(0);
X#endif
X		if ((t && ((t->ttyp == PIT) || (t->ttyp == SPIKED_PIT))) &&
X		    sobj_at(BOULDER, u.ux, u.uy))
X			return(0);	
X		if (Punished) unplacebc();	/* ball&chain go away */
X		remove_monster(mtmp->mx, mtmp->my);
X		place_monster(mtmp, u.ux, u.uy);
X		u.ustuck = mtmp;
X		newsym(mtmp->mx,mtmp->my);
X		pline("%s engulfs you!", Monnam(mtmp));
X		stop_occupation();
X		if (u.utrap) {
X			You("are released from the %s!",
X				u.utraptype==TT_WEB ? "web" : "trap");
X			u.utrap = 0;
X		}
X#ifdef WALKIES
X		if((i = number_leashed()) > 0) {
X			pline("The leash%s snap%s loose...",
X					(i > 1) ? "es" : "",
X					(i > 1) ? "" : "s");
X			unleash_all();
X		}
X#endif
X#ifdef POLYSELF
X		if (u.umonnum==PM_COCKATRICE && !resists_ston(mtmp->data)) {
X			pline("%s turns to stone!", Monnam(mtmp));
X			stoned = 1;
X			xkilled(mtmp, 0);
X			return 2;
X		}
X#endif
X		display_nhwindow(WIN_MESSAGE, FALSE);
X		vision_recalc(2);	/* hero can't see anything */
X		u.uswallow = 1;
X		/*assume that u.uswldtim always set >=0*/
X		u.uswldtim = (tim_tmp =
X			(-u.uac + 10 + rnd(25 - (int)mtmp->m_lev)) >> 1) > 0 ?
X			    tim_tmp : 0;
X		swallowed(1);
X		for(otmp2 = invent; otmp2; otmp2 = otmp2->nobj) {
X			(void) snuff_lit(otmp2);
X		}
X	} else {
X
X	    if(mtmp != u.ustuck) return(0);
X	    switch(mattk->adtyp) {
X
X		case AD_DGST:
X		    if(!u.uswldtim) {	/* a3 *//*no cf unsigned <=0*/
X			pline("%s totally digests you!", Monnam(mtmp));
X			tmp = u.uhp;
X		    } else {
X			pline("%s digests you!", Monnam(mtmp));
X		        exercise(A_STR, FALSE);
X		    }
X		    break;
X		case AD_PHYS:
X		    You("are pummeled with debris!");
X		    exercise(A_STR, FALSE);
X		    break;
X		case AD_ACID:
X#ifdef POLYSELF
X		    if (resists_acid(uasmon)) {
X			You("are covered with a seemingly harmless goo.");
X			tmp = 0;
X		    } else
X#endif
X		    {
X		      if (Hallucination) pline("Ouch!  You've been slimed!");
X		      else You("are covered in slime!  It burns!");
X		      exercise(A_STR, FALSE);
X		    }
X		    break;
X		case AD_BLND:
X		    if (!defends(AD_BLND, uwep)) {
X			if(!Blind) {
X			    You("can't see in here!");
X			    make_blinded((long)tmp,FALSE);
X			} else
X			    /* keep him blind until disgorged */
X			    make_blinded(Blinded+1,FALSE);
X		    }
X		    tmp = 0;
X		    break;
X		case AD_ELEC:
X		    if(!mtmp->mcan && rn2(2)) {
X			pline("The air around you crackles with electricity.");
X			if (Shock_resistance) {
X				shieldeff(u.ux, u.uy);
X				You("seem unhurt.");
X#if defined(POLYSELF)
X				ugolemeffects(AD_ELEC,tmp);
X#endif
X				tmp = 0;
X			}
X		    } else tmp = 0;
X		    break;
X		case AD_COLD:
X		    if(!mtmp->mcan && rn2(2)) {
X			if (Cold_resistance) {
X				shieldeff(u.ux, u.uy);
X				You("feel mildly chilly.");
X#if defined(POLYSELF)
X				ugolemeffects(AD_COLD,tmp);
X#endif
X				tmp = 0;
X			} else You("are freezing to death!");
X		    } else tmp = 0;
X		    break;
X		case AD_FIRE:
X		    if(!mtmp->mcan && rn2(2)) {
X			if (Fire_resistance) {
X				shieldeff(u.ux, u.uy);
X				You("feel mildly hot.");
X#if defined(POLYSELF)
X				ugolemeffects(AD_FIRE,tmp);
X#endif
X				tmp = 0;
X			} else You("are burning to a crisp!");
X		    } else tmp = 0;
X		    break;
X		case AD_DISE:
X		    if (!diseasemu(mtmp->data)) tmp = 0;
X		    break;
X		default:	tmp = 0;
X				break;
X	    }
X	}
X
X	if(Half_physical_damage) tmp = (tmp+1) / 2;
X
X	mdamageu(mtmp, tmp);
X	if(tmp) stop_occupation();
X	if(u.uswldtim) --u.uswldtim;
X	if(!u.uswldtim
X#ifdef POLYSELF
X	    || u.umonnum==PM_COCKATRICE
X	    || uasmon->msize >= MZ_HUGE
X#endif
X	    ) {
X#ifdef POLYSELF
X	    if (u.umonnum == PM_COCKATRICE) {
X		pline("%s very hurriedly %s you!", Monnam(mtmp), 
X		       is_animal(mtmp->data)? "regurgitates" : "expels");
X		u.uswldtim = 0;
X	    } else {
X#endif
X		You("get %s!", 
X		    is_animal(mtmp->data)? "regurgitated" : "expelled");
X		if(flags.verbose && is_animal(mtmp->data))
X			pline("Obviously %s doesn't like your taste.",
X			       mon_nam(mtmp));
X#ifdef POLYSELF
X	    }
X#endif
X	    expels(mtmp, mtmp->data, FALSE);
X	}
X	return(1);
X}
X
XSTATIC_OVL int
Xexplmu(mtmp, mattk, ufound)	/* monster explodes in your face */
Xregister struct monst *mtmp;
Xregister struct attack  *mattk;
Xboolean ufound;
X{
X    if (mtmp->mcan) return(0);
X
X    if (!ufound)
X	pline("%s explodes at a spot in thin air!",
X	      canseemon(mtmp) ? Monnam(mtmp) : "It");
X    else {
X	register int tmp = d((int)mattk->damn, (int)mattk->damd);
X	register boolean not_affected = defends((int)mattk->adtyp, uwep);
X
X	hitmsg(mtmp, mattk);
X
X	switch (mattk->adtyp) {
X	    case AD_COLD:
X		not_affected |= Cold_resistance;
X
X		if (!not_affected) {
X		    if (flags.verbose) You("get blasted!");
X		    if (ACURR(A_DEX) > rnd(20)) {
X			You("duck the blast...");
X			tmp = (tmp+1) / 2;
X		    }
X		    if (Half_physical_damage) tmp = (tmp+1) / 2;
X		    mdamageu(mtmp, tmp);
X		}
X		break;
X
X	    case AD_BLND:
X		not_affected |=
X#ifdef POLYSELF
X			(u.umonnum == PM_YELLOW_LIGHT) ||
X#endif
X			Blind;
X		if (!not_affected) {
X		    if (mon_visible(mtmp)) {
X			You("are blinded by a blast of light!");
X			make_blinded((long)tmp, FALSE);
X		    } else
X			You("get the impression it was not terribly bright.");
X		}
X		break;
X
X	    default:
X		break;
X	}
X	if (not_affected) {
X	    You("seem unaffected by it.");
X#if defined(POLYSELF)
X	    ugolemeffects((int)mattk->adtyp, tmp);
X#endif
X	}
X    }
X    mondead(mtmp);
X    return(2);	/* it dies */
X}
X
XSTATIC_OVL int
Xgazemu(mtmp, mattk)	/* monster gazes at you */
X	register struct monst *mtmp;
X	register struct attack  *mattk;
X{
X	switch(mattk->adtyp) {
X	    case AD_STON:
X		if (mtmp->mcan) {
X		    You("notice that %s isn't all that ugly.",mon_nam(mtmp));
X		   break;
X		}
X		if (canseemon(mtmp)) {
X			You("look upon %s.", mon_nam(mtmp));
X# ifdef POLYSELF
X			if (resists_ston(uasmon)) {
X				pline("So what?");
X				break;
X			}
X			if(poly_when_stoned(uasmon) && polymon(PM_STONE_GOLEM))
X			    break;
X# endif
X			You("turn to stone...");
X			killer_format = KILLED_BY_AN;
X			killer = mons[PM_MEDUSA].mname;
X			done(STONING);
X	    	}
X		break;
X	    case AD_CONF:
X		if(!mtmp->mcan && canseemon(mtmp) && mtmp->mcansee && 
X					!mtmp->mspec_used && rn2(5)) {
X		    int conf = d(3,4);
X
X		    mtmp->mspec_used = mtmp->mspec_used + (conf + rn2(6));
X		    if(!Confusion)
X			pline("%s gaze confuses you!", 
X			                  s_suffix(Monnam(mtmp)));
X		    else
X			You("are getting more and more confused.");
X		    make_confused(HConfusion + conf, FALSE);
X		}
X		break;
X	    case AD_STUN:
X		if(!mtmp->mcan && canseemon(mtmp) && mtmp->mcansee &&
X					!mtmp->mspec_used && rn2(5)) {
X		    int stun = d(2,6);
X
X		    pline("%s stares piercingly at you!", Monnam(mtmp));
X		    mtmp->mspec_used = mtmp->mspec_used + (stun + rn2(6));
X		    make_stunned(HStun + stun, TRUE);
X		}
X		break;
X	    case AD_BLND:
X		if(!mtmp->mcan && canseemon(mtmp) && !defends(AD_BLND, uwep) &&
X		   distu(mtmp->mx,mtmp->my) <= BOLT_LIM*BOLT_LIM) {
X		    int blnd = d((int)mattk->damn, (int)mattk->damd);
X		    You("are blinded by %s radiance!", 
X			              s_suffix(mon_nam(mtmp)));
X		    make_blinded((long)blnd,FALSE);
X		    make_stunned((long)d(1,3),TRUE);
X		}
X		break;
X	    default: impossible("Gaze attack %d?", mattk->adtyp);
X		break;
X	}
X	return(1);
X}
X
X#endif /* OVLB */
X#ifdef OVL1
X
Xvoid
Xmdamageu(mtmp, n)	/* mtmp hits you for n points damage */
X	register struct monst *mtmp;
X	register int n;
X{
X#ifdef POLYSELF
X	if (u.mtimedone) {
X		u.mh -= n;
X		flags.botl = 1;
X		if (u.mh < 1) rehumanize();
X		return;
X	}
X#endif
X	u.uhp -= n;
X	flags.botl = 1;
X	if(u.uhp < 1)
X		done_in_by(mtmp);
X}
X
X#endif /* OVL1 */
X#ifdef OVLB
X
X#ifdef POLYSELF
XSTATIC_OVL void
Xurustm(mon, obj)
Xregister struct monst *mon;
Xregister struct obj *obj;
X{
X	boolean vis = cansee(mon->mx, mon->my);
X
X	if (!mon || !obj) return; /* just in case */
X	if (u.umonnum == PM_RUST_MONSTER && 
X	    is_rustprone(obj) && obj->oeroded < MAX_ERODE) {
X		if (obj->greased || obj->oerodeproof || (obj->blessed && rn2(3))) {
X		    if (vis)
X			pline("Somehow, %s weapon is not affected.",
X						s_suffix(mon_nam(mon)));
X		    if (obj->greased && !rn2(2)) obj->greased = 0;
X		} else {
X		    if (vis)
X			pline("%s %s%s!",
X			        s_suffix(Monnam(mon)), aobjnam(obj, "rust"),
X			        obj->oeroded ? " further" : "");
X		    obj->oeroded++;
X		}
X	}
X}
X#endif
X
X#endif /* OVLB */
X#ifdef OVL1
X
Xint
Xcould_seduce(magr,mdef,mattk)
Xstruct monst *magr, *mdef;
Xstruct attack *mattk;
X/* returns 0 if seduction impossible,
X *	   1 if fine,
X *	   2 if wrong gender for nymph */
X{
X	register struct permonst *pagr;
X	boolean agrinvis, defperc;
X	xchar genagr, gendef;
X
X	if(magr == &youmonst) {
X		pagr = uasmon;
X		agrinvis = (Invis != 0);
X		genagr = poly_gender();
X	} else {
X		pagr = magr->data;
X		agrinvis = magr->minvis;
X		genagr = gender(magr);
X	}
X	if(mdef == &youmonst) {
X		defperc = (See_invisible != 0);
X		gendef = poly_gender();
X	} else {
X		defperc = perceives(mdef->data);
X		gendef = gender(mdef);
X	}
X
X	if(agrinvis && !defperc
X#ifdef SEDUCE
X		&& mattk && mattk->adtyp != AD_SSEX
X#endif
X		)
X		return 0;
X
X	if(pagr->mlet != S_NYMPH
X		&& ((pagr != &mons[PM_INCUBUS] && pagr != &mons[PM_SUCCUBUS])
X#ifdef SEDUCE
X		    || (mattk && mattk->adtyp != AD_SSEX)
X#endif
X		   ))
X		return 0;
X	
X	if(genagr == 1 - gendef)
X		return 1;
X	else
X		return (pagr->mlet == S_NYMPH) ? 2 : 0;
X}
X
X#endif /* OVL1 */
X#ifdef OVLB
X
X#ifdef SEDUCE
X/* Returns 1 if monster teleported */
Xint
Xdoseduce(mon)
Xregister struct monst *mon;
X{
X	register struct obj *ring;
X	boolean fem = (mon->data == &mons[PM_SUCCUBUS]); /* otherwise incubus */
X	char qbuf[QBUFSZ];
X
X	if (mon->mcan || mon->mspec_used) {
X  		pline("%s acts as though %s has got a %sheadache.",
X  			Monnam(mon), Blind ? "it" : fem ? "she" : "he",
X			mon->mcan ? "severe " : "");
X		return 0;
X	}
X
X	if (unconscious()) {
X		pline("%s seems dismayed at your lack of response.",
X			Monnam(mon));
X		return 0;
X	}
X
X	if (Blind) pline("It caresses you...");
X	else You("feel very attracted to %s.", mon_nam(mon));
X
X	for(ring = invent; ring; ring = ring->nobj) {
X	    if (ring->otyp != RIN_ADORNMENT) continue;
X	    if (fem) {
X		if (rn2(20) < ACURR(A_CHA)) {
X		    Sprintf(qbuf, "\"That %s looks pretty.  May I have it?\"",
X			xname(ring));
X		    makeknown(RIN_ADORNMENT);
X		    if (yn(qbuf) == 'n') continue;
X		} else pline("%s decides she'd like your %s, and takes it.",
X			Blind ? "She" : Monnam(mon), xname(ring));
X		makeknown(RIN_ADORNMENT);
X		if (ring==uleft || ring==uright) Ring_gone(ring);
X		if (ring==uwep) setuwep((struct obj *)0);
X		freeinv(ring);
X		mpickobj(mon,ring);
X	    } else {
X		char buf[BUFSZ];
X
X		if (uleft && uright && uleft->otyp == RIN_ADORNMENT
X				&& uright->otyp==RIN_ADORNMENT)
X			break;
X		if (ring==uleft || ring==uright) continue;
X		if (rn2(20) < ACURR(A_CHA)) {
X		    Sprintf(qbuf,"\"That %s looks pretty.  Would you wear it for me?\"",
X			xname(ring));
X		    makeknown(RIN_ADORNMENT);
X		    if (yn(qbuf) == 'n') continue;
X		} else {
X		    pline("%s decides you'd look prettier wearing your %s,",
X			Blind ? "He" : Monnam(mon), xname(ring));
X		    pline("and puts it on your finger.");
X		}
X		makeknown(RIN_ADORNMENT);
X		if (!uright) {
X		    pline("%s puts %s on your right hand.",
X			Blind ? "He" : Monnam(mon), the(xname(ring)));
X		    setworn(ring, RIGHT_RING);
X		} else if (!uleft) {
X		    pline("%s puts %s on your left hand.",
X			Blind ? "He" : Monnam(mon), the(xname(ring)));
X		    setworn(ring, LEFT_RING);
X		} else if (uright && uright->otyp != RIN_ADORNMENT) {
X		    Strcpy(buf, xname(uright));
X		    pline("%s replaces your %s with your %s.",
X			Blind ? "He" : Monnam(mon), buf, xname(ring));
X		    Ring_gone(uright);
X		    setworn(ring, RIGHT_RING);
X		} else if (uleft && uleft->otyp != RIN_ADORNMENT) {
X		    Strcpy(buf, xname(uleft));
X		    pline("%s replaces your %s with your %s.",
X			Blind ? "He" : Monnam(mon), buf, xname(ring));
X		    Ring_gone(uleft);
X		    setworn(ring, LEFT_RING);
X		} else impossible("ring replacement");
X		Ring_on(ring);
X	    	prinv(NULL, ring, 0L);
X	    }
X	}
X
X	if (!uarmc && !uarmf && !uarmg && !uarms && !uarmh
X#ifdef TOURIST
X								&& !uarmu
X#endif
X									)
X		pline("%s murmurs sweet nothings into your ear.",
X			Blind ? (fem ? "She" : "He") : Monnam(mon));
X	else
X		pline("%s murmurs in your ear, while helping you undress.",
X			Blind ? (fem ? "She" : "He") : Monnam(mon));
X	mayberem(uarmc, "cloak");
X	if(!uarmc)
X		mayberem(uarm, "suit");
X	mayberem(uarmf, "boots");
X	if(!uwep || !welded(uwep))
X		mayberem(uarmg, "gloves");
X	mayberem(uarms, "shield");
X	mayberem(uarmh, "helmet");
X#ifdef TOURIST
X	if(!uarmc && !uarm)
X		mayberem(uarmu, "shirt");
X#endif
X
X	if (uarm || uarmc) {
X		verbalize("You're such a %s; I wish...",
X				flags.female ? "sweet lady" : "nice guy");
X		rloc(mon);
X		return 1;
X	}
X	if (u.ualign.type == A_CHAOTIC && u.ualign.record < ALIGNLIM)
X	    u.ualign.record++;
X
X	/* by this point you have discovered mon's identity, blind or not... */
X	pline("Time stands still while you and %s lie in each other's arms...",
X		mon_nam(mon));
X	if (rn2(35) > ACURR(A_CHA) + ACURR(A_INT)) {
X		/* Don't bother with mspec_used here... it didn't get tired! */
X		pline("%s seems to have enjoyed it more than you...",
X			Monnam(mon));
X		switch (rn2(5)) {
X			case 0: You("feel drained of energy.");
X				u.uen = 0;
X				u.uenmax -= rnd(Half_physical_damage ? 5 : 10);
X			        exercise(A_CON, FALSE);
X				if (u.uenmax < 0) u.uenmax = 0;
X				break;
X			case 1: You("are down in the dumps.");
X				(void) adjattrib(A_CON, -1, TRUE);
X			        exercise(A_CON, FALSE);
X				flags.botl = 1;
X				break;
X			case 2: Your("senses are dulled.");
X				(void) adjattrib(A_WIS, -1, TRUE);
X			        exercise(A_WIS, FALSE);
X				flags.botl = 1;
X				break;
X			case 3:
X#ifdef POLYSELF
X				if (resists_drli(uasmon))
X				    You("have a curious feeling...");
X				else {
X#endif
X				    You("feel out of shape.");
X				    losexp();
X				    if(u.uhp <= 0) {
X					killer_format = KILLED_BY;
X					killer = "overexertion";
X					done(DIED);
X				    }
X#ifdef POLYSELF
X				}
X#endif
X				break;
X			case 4: {
X				int tmp;
X				You("feel exhausted.");
X			        exercise(A_STR, FALSE);
X				tmp = rn1(10, 6);
X				if(Half_physical_damage) tmp = (tmp+1) / 2;
X				losehp(tmp, "exhaustion", KILLED_BY);
X				break;
X			}
X		}
X	} else {
X		mon->mspec_used = rnd(100); /* monster is worn out */
X		You("seem to have enjoyed it more than %s...", mon_nam(mon));
X		switch (rn2(5)) {
X			case 0: You("feel raised to your full potential.");
X			        exercise(A_CON, TRUE);
X				u.uen = (u.uenmax += rnd(5));
X				break;
X			case 1: You("feel good enough to do it again.");
X				(void) adjattrib(A_CON, 1, TRUE);
X			        exercise(A_CON, TRUE);
X				flags.botl = 1;
X				break;
X			case 2: You("will always remember %s...", mon_nam(mon));
X				(void) adjattrib(A_WIS, 1, TRUE);
X			        exercise(A_WIS, TRUE);
X				flags.botl = 1;
X				break;
X			case 3: pline("That was a very educational experience.");
X				pluslvl();
X			        exercise(A_WIS, TRUE);
X				break;
X			case 4: You("feel restored to health!");
X				u.uhp = u.uhpmax;
X#ifdef POLYSELF
X				if (u.mtimedone) u.mh = u.mhmax;
X#endif
X			        exercise(A_STR, TRUE);
X				flags.botl = 1;
X				break;
X		}
X	}
X
X	if (mon->mtame) /* don't charge */ ;
X	else if (rn2(20) < ACURR(A_CHA)) {
X		pline("%s demands that you pay %s, but you refuse...",
X			Monnam(mon), (fem ? "her" : "him"));
X	}
X#ifdef POLYSELF
X	else if (u.umonnum == PM_LEPRECHAUN)
X		pline("%s tries to take your money, but fails...",
X				Monnam(mon));
X#endif
X	else {
X		long cost;
X
X		if (u.ugold > (long)LARGEST_INT - 10L)
X			cost = (long) rnd(LARGEST_INT) + 500L;
X		else
X			cost = (long) rnd((int)u.ugold + 10) + 500L;
X		if (mon->mpeaceful) {
X			cost /= 5L;
X			if (!cost) cost = 1L;
X		}
X		if (cost > u.ugold) cost = u.ugold;
X		if (!cost) verbalize("It's on the house!");
X		else {
X		    pline("%s takes %ld zorkmid%s for services rendered!",
X			    Monnam(mon), cost, plur(cost));
X		    u.ugold -= cost;
X		    mon->mgold += cost;
X		    flags.botl = 1;
X		}
X	}
X	if (!rn2(25)) mon->mcan = 1; /* monster is worn out */
X	rloc(mon);
X	return 1;
X}
X
Xstatic void
Xmayberem(obj, str)
Xregister struct obj *obj;
Xconst char *str;
X{
X	char qbuf[QBUFSZ];
X
X	if (!obj || !obj->owornmask) return;
X
X	if (rn2(20) < ACURR(A_CHA)) {
X		Sprintf(qbuf,"\"Shall I remove your %s, %s?\"",
X			str,
X			(!rn2(2) ? "lover" : !rn2(2) ? "dear" : "sweetheart"));
X		if (yn(qbuf) == 'n') return;
X	} else verbalize("Take off your %s; %s.", str,
X			(obj == uarm)  ? "let's get a little closer" :
X			(obj == uarmc || obj == uarms) ? "it's in the way" :
X			(obj == uarmf) ? "let me rub your feet" :
X			(obj == uarmg) ? "they're too clumsy" :
X#ifdef TOURIST
X			(obj == uarmu) ? "let me massage you" :
X#endif
X			/* obj == uarmh */
X			"let me run my fingers through your hair");
X
X	if (donning(obj)) cancel_don();
X	if (obj == uarm)  (void) Armor_off();
X	else if (obj == uarmc) (void) Cloak_off();
X	else if (obj == uarmf) (void) Boots_off();
X	else if (obj == uarmg) (void) Gloves_off();
X	else if (obj == uarmh) (void) Helmet_off();
X	else setworn((struct obj *)0, obj->owornmask & W_ARMOR);
X}
X#endif  /* SEDUCE */
X
X#endif /* OVLB */
X
X#ifdef POLYSELF
X
X#ifdef OVL1
X
Xstatic int
Xpassiveum(olduasmon,mtmp,mattk)
Xstruct permonst *olduasmon;
Xregister struct monst *mtmp;
Xregister struct attack *mattk;
X{
X	register struct permonst *mdat = mtmp->data;
X	int i, tmp;
X
X	for(i = 0; ; i++) {
X	    if(i >= NATTK) return 1;
X	    if(olduasmon->mattk[i].aatyp == AT_NONE) break;
X	}
X	if (olduasmon->mattk[i].damn)
X	    tmp = d((int)olduasmon->mattk[i].damn, 
X                                    (int)olduasmon->mattk[i].damd);
X	else if(olduasmon->mattk[i].damd)
X	    tmp = d((int)olduasmon->mlevel+1, (int)olduasmon->mattk[i].damd);
X	else
X	    tmp = 0;
X
X	/* These affect the enemy even if you were "killed" (rehumanized) */
X	switch(olduasmon->mattk[i].adtyp) {
X	    case AD_ACID:
X		if (!rn2(2)) {
X		    pline("%s is splashed by your acid!", Monnam(mtmp));
X		    if(resists_acid(mdat)) {
X			pline("%s is not affected.", Monnam(mtmp));
X			tmp = 0;
X		    }
X		} else tmp = 0;
X		goto assess_dmg;
X	    case AD_STON: /* cockatrice */
X		if (!resists_ston(mdat) &&
X#ifdef MUSE
X		    (mattk->aatyp != AT_WEAP || !MON_WEP(mtmp)) &&
X#else
X		    (mattk->aatyp != AT_WEAP || !select_hwep(mtmp)) &&
X#endif
X		    mattk->aatyp != AT_GAZE && mattk->aatyp != AT_EXPL &&
X		    mattk->aatyp != AT_MAGC &&
X#ifdef MUSE
X		    (!which_armor(mtmp, W_ARMG))) {
X#else
X		    (!is_mercenary(mdat) ||
X				      !m_carrying(mtmp, LEATHER_GLOVES))) {
X#endif
X		    if(poly_when_stoned(mdat)) {
X			mon_to_stone(mtmp);
X			return (1);
X		    }
X		    pline("%s turns to stone!", Monnam(mtmp));
X		    stoned = 1;
X		    xkilled(mtmp, 0);
X		    return 2;
X		}
X		return 1;
X	    default:
X		break;
X	}
X	if (!u.mtimedone) return 1;
X
X	/* These affect the enemy only if you are still a monster */
X	if (rn2(3)) switch(uasmon->mattk[i].adtyp) {
X	    case AD_PLYS: /* Floating eye */
X		if (u.umonnum == PM_FLOATING_EYE) {
X		    if (!rn2(4)) tmp = 120;
X		    if (mtmp->mcansee && haseyes(mtmp->data) && rn2(3) &&
X				(perceives(mdat) || !Invis)) {
X			if (Blind)
X			    pline("As a blind %s, you cannot defend yourself.",
X							uasmon->mname);
X		        else {
X			    pline("%s is frozen by your gaze!", Monnam(mtmp));
X			    mtmp->mcanmove = 0;
X			    mtmp->mfrozen = tmp;
X			    return 3;
X			}
X		    }
X		} else { /* gelatinous cube */
X		    pline("%s is frozen by you.", Monnam(mtmp));
X		    mtmp->mcanmove = 0;
X		    mtmp->mfrozen = tmp;
X		    return 3;
X		}
X		return 1;
X	    case AD_COLD: /* Brown mold or blue jelly */
X		if(resists_cold(mdat)) {
X  		    shieldeff(mtmp->mx, mtmp->my);
X		    pline("%s is mildly chilly.", Monnam(mtmp));
X		    golemeffects(mtmp, AD_COLD, tmp);
X		    tmp = 0;
X		    break;
X		}
X		pline("%s is suddenly very cold!", Monnam(mtmp));
X		u.mh += tmp / 2;
X		if (u.mhmax < u.mh) u.mhmax = u.mh;
X		if (u.mhmax > ((uasmon->mlevel+1) * 8)) {
X			register struct monst *mon;
X
X			if ((mon = cloneu()) != 0) {
X			    mon->mhpmax = u.mhmax /= 2;
X			    You("multiply from %s heat!", 
X				           s_suffix(mon_nam(mtmp)));
X			}
X		}
X		break;
X	    case AD_STUN: /* Yellow mold */
X		if (!mtmp->mstun) {
X		    mtmp->mstun = 1;
X		    pline("%s staggers.", Monnam(mtmp));
X		}
X		tmp = 0;
X		break;
X	    case AD_FIRE: /* Red mold */
X		if(resists_fire(mdat)) {
X  		    shieldeff(mtmp->mx, mtmp->my);
X		    pline("%s is mildly warm.", Monnam(mtmp));
X		    golemeffects(mtmp, AD_FIRE, tmp);
X		    tmp = 0;
X		    break;
X		}
X		pline("%s is suddenly very hot!", Monnam(mtmp));
X		break;
X	    case AD_ELEC:
X		if(resists_elec(mdat)) {
X  		    shieldeff(mtmp->mx, mtmp->my);
X		    pline("%s is slightly tingled.", Monnam(mtmp));
X		    golemeffects(mtmp, AD_ELEC, tmp);
X		    tmp = 0;
X		    break;
X		}
X		pline("%s is jolted with your electricity!", Monnam(mtmp));
X		break;
X	    default: tmp = 0;
X		break;
X	}
X	else tmp = 0;
X
X    assess_dmg:
X	if((mtmp->mhp -= tmp) <= 0) {
X		pline("%s dies!", Monnam(mtmp));
X		xkilled(mtmp,0);
X		return 2;
X	}
X	return 1;
X}
X
X#endif /* OVL1 */
X#ifdef OVLB
X
X#include "edog.h"
Xstruct monst *
Xcloneu()
X{
X	register struct monst *mon;
X
X	if (u.mh <= 1) return(struct monst *)0;
X	if (uasmon->geno & G_EXTINCT) return(struct monst *)0;
X	uasmon->pxlth += sizeof(struct edog);
X	mon = makemon(uasmon, u.ux, u.uy);
X	uasmon->pxlth -= sizeof(struct edog);
X	mon = christen_monst(mon, plname);
X	initedog(mon);
X	mon->m_lev = uasmon->mlevel;
X	mon->mhp = u.mh /= 2;
X	mon->mhpmax = u.mhmax;
X	return(mon);
X}
X
X#endif /* OVLB */
X
X#endif /* POLYSELF */
X
X/*mhitu.c*/
END_OF_FILE
if test 21658 -ne `wc -c <'src/mhitu.c2'`; then
    echo shar: \"'src/mhitu.c2'\" unpacked with wrong size!
fi
# end of 'src/mhitu.c2'
fi
if test -f 'sys/share/dgn_yacc.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/share/dgn_yacc.c'\"
else
echo shar: Extracting \"'sys/share/dgn_yacc.c'\" \(32600 characters\)
sed "s/^X//" >'sys/share/dgn_yacc.c' <<'END_OF_FILE'
Xextern char *malloc(), *realloc();
X
X# line 2 "dgn_comp.y"
X/*	SCCS Id: @(#)dgn_comp.c	3.1	93/01/17	*/
X/*	Copyright (c) 1989 by Jean-Christophe Collet */
X/*	Copyright (c) 1990 by M. Stephenson				  */
X/* NetHack may be freely redistributed.  See license for details. */
X
X/*
X * This file contains the Dungeon Compiler code
X */
X
X/* In case we're using bison in AIX.  This definition must be
X * placed before any other C-language construct in the file
X * excluding comments and preprocessor directives (thanks IBM
X * for this wonderful feature...).
X *
X * Note: some cpps barf on this 'undefined control' (#pragma).
X * Addition of the leading space seems to prevent barfage for now,
X * and AIX will still see the directive in its non-standard locale.
X */
X
X#ifdef _AIX
X #pragma alloca		/* keep leading space! */
X#endif
X
X#include "config.h"
X#include "dgn_file.h"
X
Xvoid FDECL(yyerror, (char *));
Xvoid FDECL(yywarning, (char *));
Xint NDECL(yylex);
Xint NDECL(yyparse);
Xint FDECL(getchain, (char *));
Xint NDECL(check_dungeon);
Xint NDECL(check_branch);
Xint NDECL(check_level);
Xvoid NDECL(init_dungeon);
Xvoid NDECL(init_branch);
Xvoid NDECL(init_level);
Xvoid NDECL(output_dgn);
X
X#ifdef AMIGA
X# undef	printf
X#ifndef	LATTICE
X# define    memset(addr,val,len)    setmem(addr,len,val)
X#endif
X#endif
X
X#ifdef MICRO
X# undef exit
Xextern void FDECL(exit, (int));
X#endif
X
X#undef NULL
X
X#define ERR		(-1)
X
Xstatic struct couple couple;
Xstatic struct tmpdungeon tmpdungeon[MAXDUNGEON];
Xstatic struct tmplevel tmplevel[LEV_LIMIT];
Xstatic struct tmpbranch tmpbranch[BRANCH_LIMIT];
X
Xstatic int in_dungeon = 0, n_dgns = -1, n_levs = -1, n_brs = -1;
X
Xextern int fatal_error;
Xextern char* fname;
X
X
X# line 69 "dgn_comp.y"
Xtypedef union 
X{
X	int	i;
X	char*	str;
X} YYSTYPE;
X# define INTEGER 257
X# define A_DUNGEON 258
X# define BRANCH 259
X# define CHBRANCH 260
X# define LEVEL 261
X# define RNDLEVEL 262
X# define CHLEVEL 263
X# define RNDCHLEVEL 264
X# define UP_OR_DOWN 265
X# define PROTOFILE 266
X# define DESCRIPTION 267
X# define DESCRIPTOR 268
X# define LEVELDESC 269
X# define ALIGNMENT 270
X# define LEVALIGN 271
X# define ENTRY 272
X# define STAIR 273
X# define NO_UP 274
X# define NO_DOWN 275
X# define PORTAL 276
X# define STRING 277
X#define yyclearin yychar = -1
X#define yyerrok yyerrflag = 0
Xextern int yychar;
Xextern int yyerrflag;
X#ifndef YYMAXDEPTH
X#define YYMAXDEPTH 150
X#endif
XYYSTYPE yylval, yyval;
X# define YYERRCODE 256
X
X# line 450 "dgn_comp.y"
X
X
Xvoid
Xinit_dungeon()
X{
X	if(++n_dgns > MAXDUNGEON) {
X	    fprintf(stderr, "FATAL - Too many dungeons (limit: %d).\n",
X		    MAXDUNGEON);
X	    fprintf(stderr, "To increase the limit edit MAXDUNGEON in global.h\n");
X	    exit(1);
X	}
X
X	in_dungeon = 1;
X	tmpdungeon[n_dgns].lev.base = 0;
X	tmpdungeon[n_dgns].lev.rand = 0;
X	tmpdungeon[n_dgns].chance = 100;
X	strcpy(tmpdungeon[n_dgns].name, "");
X	strcpy(tmpdungeon[n_dgns].protoname, "");
X	tmpdungeon[n_dgns].flags = 0;
X	tmpdungeon[n_dgns].levels = 0;
X	tmpdungeon[n_dgns].branches = 0;
X	tmpdungeon[n_dgns].entry_lev = 0;
X}
X
Xvoid
Xinit_level()
X{
X	if(++n_levs > LEV_LIMIT) {
X
X		yyerror("FATAL - Too many special levels defined.");
X		exit(1);
X	}
X	tmplevel[n_levs].lev.base = 0;
X	tmplevel[n_levs].lev.rand = 0;
X	tmplevel[n_levs].chance = 100;
X	tmplevel[n_levs].rndlevs = 0;
X	tmplevel[n_levs].flags = 0;
X	strcpy(tmplevel[n_levs].name, "");
X	tmplevel[n_levs].chain = -1;
X}
X
Xvoid
Xinit_branch()
X{
X	if(++n_brs > BRANCH_LIMIT) {
X
X		yyerror("FATAL - Too many special levels defined.");
X		exit(1);
X	}
X	tmpbranch[n_brs].lev.base = 0;
X	tmpbranch[n_brs].lev.rand = 0;
X	strcpy(tmpbranch[n_brs].name, "");
X	tmpbranch[n_brs].chain = -1;
X}
X
Xint
Xgetchain(s)
X	char	*s;
X{
X	int i;
X
X	if(strlen(s)) {
X
X	    for(i = n_levs - tmpdungeon[n_dgns].levels + 1; i <= n_levs; i++)
X		if(!strcmp(tmplevel[i].name, s)) return i;
X
X	    yyerror("Can't locate the specified chain level.");
X	    return(-2);
X	}
X	return(-1);
X}
X
X/*
X *	Consistancy checking routines:
X *
X *	- A dungeon must have a unique name.
X *	- A dungeon must have a originating "branch" command
X *	  (except, of course, for the first dungeon).
X *	- A dungeon must have a proper depth (at least (1, 0)).
X */
X
Xint
Xcheck_dungeon()
X{
X	int i;
X
X	for(i = 0; i < n_dgns; i++)
X	    if(!strcmp(tmpdungeon[i].name, tmpdungeon[n_dgns].name)) {
X		yyerror("Duplicate dungeon name.");
X		return(0);
X	    }
X
X	if(n_dgns)
X	  for(i = 0; i < n_brs - tmpdungeon[n_dgns].branches; i++) {
X	    if(!strcmp(tmpbranch[i].name, tmpdungeon[n_dgns].name)) break;
X
X	    if(i >= n_brs - tmpdungeon[n_dgns].branches) {
X		yyerror("Dungeon cannot be reached.");
X		return(0);
X	    }
X	  }
X
X	if(tmpdungeon[n_dgns].lev.base <= 0 ||
X	   tmpdungeon[n_dgns].lev.rand < 0) {
X		yyerror("Invalid dungeon depth specified.");
X		return(0);
X	}
X	return(1);	/* OK */
X}
X
X/*
X *	- A level must have a unique level name.
X *	- If chained, the level used as reference for the chain
X *	  must be in this dungeon, must be previously defined, and
X *	  the level chained from must be "non-probabalistic" (ie.
X *	  have a 100% chance of existing).
X */
X
Xint
Xcheck_level()
X{
X	int i;
X
X	if(!in_dungeon) {
X		yyerror("Level defined outside of dungeon.");
X		return(0);
X	}
X
X	for(i = 0; i < n_levs; i++)
X	    if(!strcmp(tmplevel[i].name, tmplevel[n_levs].name)) {
X		yyerror("Duplicate level name.");
X		return(0);
X	    }
X
X	if(tmplevel[i].chain == -2) {
X		yyerror("Invaild level chain reference.");
X		return(0);
X	} else if(tmplevel[i].chain != -1) {	/* there is a chain */
X	    if(tmplevel[tmpbranch[i].chain].chance != 100) {
X		yyerror("Level cannot chain from a probabalistic level.");
X		return(0);
X	    } else if(tmplevel[i].chain == n_levs) {
X		yyerror("A level cannot chain to itself!");
X		return(0);
X	    }
X	}
X	return(1);	/* OK */
X}
X
X/*
X *	- A branch may not branch backwards - to avoid branch loops.
X *	- A branch name must be unique.
X *	  (ie. You can only have one entry point to each dungeon).
X *	- If chained, the level used as reference for the chain
X *	  must be in this dungeon, must be previously defined, and
X *	  the level chained from must be "non-probabalistic" (ie.
X *	  have a 100% chance of existing).
X */
X
Xint
Xcheck_branch()
X{
X	int i;
X
X	if(!in_dungeon) {
X		yyerror("Branch defined outside of dungeon.");
X		return(0);
X	}
X
X	for(i = 0; i < n_dgns; i++)
X	    if(!strcmp(tmpdungeon[i].name, tmpbranch[n_brs].name)) {
X
X		yyerror("Reverse branching not allowed.");
X		return(0);
X	    }
X
X	if(tmpbranch[i].chain == -2) {
X
X		yyerror("Invaild branch chain reference.");
X		return(0);
X	} else if(tmpbranch[i].chain != -1) {	/* it is chained */
X
X	    if(tmplevel[tmpbranch[i].chain].chance != 100) {
X		yyerror("Branch cannot chain from a probabalistic level.");
X		return(0);
X	    }
X	}
X	return(1);	/* OK */
X}
X
X/*
X *	Output the dungon definition into a file.
X *
X *	The file will have the following format:
X *
X *	[ number of dungeons ]
X *	[ first dungeon struct ]
X *	[ levels for the first dungeon ]
X *	  ...
X *	[ branches for the first dungeon ]
X *	  ...
X *	[ second dungeon struct ]
X *	  ...
X */
X
Xvoid
Xoutput_dgn()
X{
X	int	nd, cl = 0, nl = 0,
X		    cb = 0, nb = 0;
X
X	if(++n_dgns <= 0) {
X
X	    yyerror("FATAL - no dungeons were defined.");
X	    exit(1);
X	}
X
X	fwrite((char *)(&n_dgns), sizeof(int), 1, stdout);
X	for(nd = 0; nd < n_dgns; nd++) {
X
X	    fwrite((char *)&tmpdungeon[nd], sizeof(struct tmpdungeon), 1,
X								stdout);
X
X	    nl += tmpdungeon[nd].levels;
X	    for(; cl < nl; cl++)
X		fwrite((char *)&tmplevel[cl], sizeof(struct tmplevel), 1,
X								stdout);
X
X	    nb += tmpdungeon[nd].branches;
X	    for(; cb < nb; cb++)
X		fwrite((char *)&tmpbranch[cb], sizeof(struct tmpbranch), 1,
X								stdout);
X	}
X}
Xint yyexca[] ={
X-1, 1,
X	0, -1,
X	-2, 0,
X	};
X# define YYNPROD 48
X# define YYLAST 145
Xint yyact[]={
X
X     8,    22,    23,    24,    25,    28,    29,    74,    21,    30,
X    73,    26,    31,    27,    19,    65,    79,    80,    81,    82,
X   106,    64,    63,    62,    61,    59,    56,    55,    52,    51,
X    50,    49,    48,    46,    58,    57,    54,    53,    91,   103,
X   102,   101,    99,    98,    95,    94,    83,    77,    76,    47,
X    90,    66,    78,    68,    72,    71,    60,    45,    44,    43,
X    42,    41,    40,    39,    38,    37,    36,    35,    34,    33,
X    92,    89,    88,    87,    70,   105,   104,    67,    69,     3,
X    13,    12,    32,    18,    17,    16,    15,    14,    20,    11,
X    10,     9,     7,     6,     5,     4,     2,     1,    75,     0,
X     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
X     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
X     0,     0,    84,     0,     0,    85,    86,     0,     0,     0,
X     0,     0,     0,     0,     0,     0,     0,    93,     0,    96,
X    97,     0,     0,     0,   100 };
Xint yypact[]={
X
X  -258, -1000,  -258, -1000, -1000, -1000, -1000, -1000,    11, -1000,
X -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000,    10,
X -1000,     9,     8,     7,     6,     5,     4,     3,     2,     1,
X     0,    -1, -1000,  -244,  -208,  -245,  -246,  -247,  -248,  -249,
X  -231,  -232,  -250,  -251,  -233,  -234,  -252, -1000, -1000,    -8,
X  -253,  -254,  -255, -1000, -1000,  -256,  -262, -1000, -1000,    37,
X    38,    31,    -9,   -10,  -267,  -270,  -209,  -210,  -257,  -211,
X    37,    38,    38,    30,    29, -1000, -1000,    27,  -227, -1000,
X -1000, -1000, -1000,    26,  -257,  -212,  -213,    37,    37,  -214,
X -1000, -1000,  -215,  -227, -1000,  -216,  -217,  -218,    35,    34,
X -1000, -1000, -1000,  -237, -1000, -1000, -1000 };
Xint yypgo[]={
X
X     0,    98,    50,    52,    97,    96,    79,    95,    94,    93,
X    92,    51,    91,    90,    89,    88,    87,    86,    85,    84,
X    83,    53,    81,    80 };
Xint yyr1[]={
X
X     0,     4,     4,     5,     5,     6,     6,     6,     6,     7,
X     1,     1,     8,     8,     8,    12,    13,    15,    15,    14,
X    10,    10,    10,    10,    10,    16,    16,    17,    17,    18,
X    18,    19,    19,    20,    20,     9,     9,    22,    23,     3,
X     3,     3,     3,     3,     2,     2,    21,    11 };
Xint yyr2[]={
X
X     0,     0,     3,     2,     4,     2,     2,     2,     2,    13,
X     1,     3,     2,     2,     2,     7,     2,     7,     7,     7,
X     2,     2,     2,     2,     2,    13,    15,    15,    17,     7,
X     7,    15,    17,    17,    19,     2,     2,    15,    17,     1,
X     3,     3,     3,     3,     1,     3,    11,    11 };
Xint yychk[]={
X
X -1000,    -4,    -5,    -6,    -7,    -8,    -9,   -10,   258,   -12,
X   -13,   -14,   -22,   -23,   -16,   -17,   -18,   -19,   -20,   272,
X   -15,   266,   259,   260,   261,   262,   269,   271,   263,   264,
X   267,   270,    -6,    58,    58,    58,    58,    58,    58,    58,
X    58,    58,    58,    58,    58,    58,   277,   257,   277,   277,
X   277,   277,   277,   268,   268,   277,   277,   268,   268,   277,
X    64,   277,   277,   277,   277,   277,   -11,    40,   -21,    40,
X    43,    64,    64,   277,   277,    -1,   257,   257,    -3,   273,
X   274,   275,   276,   257,   -11,   -21,   -21,    43,    43,    44,
X    -2,   265,    44,    -3,   257,   257,   -11,   -11,   257,   257,
X    -2,   257,   257,   257,    41,    41,   257 };
Xint yydef[]={
X
X     1,    -2,     2,     3,     5,     6,     7,     8,     0,    12,
X    13,    14,    35,    36,    20,    21,    22,    23,    24,     0,
X    16,     0,     0,     0,     0,     0,     0,     0,     0,     0,
X     0,     0,     4,     0,     0,     0,     0,     0,     0,     0,
X     0,     0,     0,     0,     0,     0,     0,    15,    19,     0,
X     0,     0,     0,    29,    30,     0,     0,    17,    18,     0,
X     0,     0,     0,     0,     0,     0,    10,     0,    39,     0,
X     0,     0,     0,     0,     0,     9,    11,     0,    44,    40,
X    41,    42,    43,     0,    39,    25,     0,     0,     0,     0,
X    37,    45,     0,    44,    27,    26,    31,     0,     0,     0,
X    38,    28,    33,    32,    47,    46,    34 };
Xtypedef struct { char *t_name; int t_val; } yytoktype;
X#ifndef YYDEBUG
X#	define YYDEBUG	0	/* don't allow debugging */
X#endif
X
X#if YYDEBUG
X
Xyytoktype yytoks[] =
X{
X	"INTEGER",	257,
X	"A_DUNGEON",	258,
X	"BRANCH",	259,
X	"CHBRANCH",	260,
X	"LEVEL",	261,
X	"RNDLEVEL",	262,
X	"CHLEVEL",	263,
X	"RNDCHLEVEL",	264,
X	"UP_OR_DOWN",	265,
X	"PROTOFILE",	266,
X	"DESCRIPTION",	267,
X	"DESCRIPTOR",	268,
X	"LEVELDESC",	269,
X	"ALIGNMENT",	270,
X	"LEVALIGN",	271,
X	"ENTRY",	272,
X	"STAIR",	273,
X	"NO_UP",	274,
X	"NO_DOWN",	275,
X	"PORTAL",	276,
X	"STRING",	277,
X	"-unknown-",	-1	/* ends search */
X};
X
Xchar * yyreds[] =
X{
X	"-no such reduction-",
X	"file : /* empty */",
X	"file : dungeons",
X	"dungeons : dungeon",
X	"dungeons : dungeons dungeon",
X	"dungeon : dungeonline",
X	"dungeon : dungeondesc",
X	"dungeon : branches",
X	"dungeon : levels",
X	"dungeonline : A_DUNGEON ':' STRING STRING rcouple optional_int",
X	"optional_int : /* empty */",
X	"optional_int : INTEGER",
X	"dungeondesc : entry",
X	"dungeondesc : descriptions",
X	"dungeondesc : prototype",
X	"entry : ENTRY ':' INTEGER",
X	"descriptions : desc",
X	"desc : DESCRIPTION ':' DESCRIPTOR",
X	"desc : ALIGNMENT ':' DESCRIPTOR",
X	"prototype : PROTOFILE ':' STRING",
X	"levels : level1",
X	"levels : level2",
X	"levels : levdesc",
X	"levels : chlevel1",
X	"levels : chlevel2",
X	"level1 : LEVEL ':' STRING STRING '@' acouple",
X	"level1 : RNDLEVEL ':' STRING STRING '@' acouple INTEGER",
X	"level2 : LEVEL ':' STRING STRING '@' acouple INTEGER",
X	"level2 : RNDLEVEL ':' STRING STRING '@' acouple INTEGER INTEGER",
X	"levdesc : LEVELDESC ':' DESCRIPTOR",
X	"levdesc : LEVALIGN ':' DESCRIPTOR",
X	"chlevel1 : CHLEVEL ':' STRING STRING STRING '+' rcouple",
X	"chlevel1 : RNDCHLEVEL ':' STRING STRING STRING '+' rcouple INTEGER",
X	"chlevel2 : CHLEVEL ':' STRING STRING STRING '+' rcouple INTEGER",
X	"chlevel2 : RNDCHLEVEL ':' STRING STRING STRING '+' rcouple INTEGER INTEGER",
X	"branches : branch",
X	"branches : chbranch",
X	"branch : BRANCH ':' STRING '@' acouple branch_type direction",
X	"chbranch : CHBRANCH ':' STRING STRING '+' rcouple branch_type direction",
X	"branch_type : /* empty */",
X	"branch_type : STAIR",
X	"branch_type : NO_UP",
X	"branch_type : NO_DOWN",
X	"branch_type : PORTAL",
X	"direction : /* empty */",
X	"direction : UP_OR_DOWN",
X	"acouple : '(' INTEGER ',' INTEGER ')'",
X	"rcouple : '(' INTEGER ',' INTEGER ')'",
X};
X#endif /* YYDEBUG */
X#line 1 "/usr/lib/yaccpar"
X/*	@(#)yaccpar 1.10 89/04/04 SMI; from S5R3 1.10	*/
X
X/*
X** Skeleton parser driver for yacc output
X*/
X
X/*
X** yacc user known macros and defines
X*/
X#define YYERROR		goto yyerrlab
X#define YYACCEPT	{ free(yys); free(yyv); return(0); }
X#define YYABORT		{ free(yys); free(yyv); return(1); }
X#define YYBACKUP( newtoken, newvalue )\
X{\
X	if ( yychar >= 0 || ( yyr2[ yytmp ] >> 1 ) != 1 )\
X	{\
X		yyerror( "syntax error - cannot backup" );\
X		goto yyerrlab;\
X	}\
X	yychar = newtoken;\
X	yystate = *yyps;\
X	yylval = newvalue;\
X	goto yynewstate;\
X}
X#define YYRECOVERING()	(!!yyerrflag)
X#ifndef YYDEBUG
X#	define YYDEBUG	1	/* make debugging available */
X#endif
X
X/*
X** user known globals
X*/
Xint yydebug;			/* set to 1 to get debugging */
X
X/*
X** driver internal defines
X*/
X#define YYFLAG		(-1000)
X
X/*
X** static variables used by the parser
X*/
Xstatic YYSTYPE *yyv;			/* value stack */
Xstatic int *yys;			/* state stack */
X
Xstatic YYSTYPE *yypv;			/* top of value stack */
Xstatic int *yyps;			/* top of state stack */
X
Xstatic int yystate;			/* current state */
Xstatic int yytmp;			/* extra var (lasts between blocks) */
X
Xint yynerrs;			/* number of errors */
X
Xint yyerrflag;			/* error recovery flag */
Xint yychar;			/* current input token number */
X
X
X/*
X** yyparse - return 0 if worked, 1 if syntax error not recovered from
X*/
Xint
Xyyparse()
X{
X	register YYSTYPE *yypvt;	/* top of value stack for $vars */
X	unsigned yymaxdepth = YYMAXDEPTH;
X
X	/*
X	** Initialize externals - yyparse may be called more than once
X	*/
X	yyv = (YYSTYPE*)malloc(yymaxdepth*sizeof(YYSTYPE));
X	yys = (int*)malloc(yymaxdepth*sizeof(int));
X	if (!yyv || !yys)
X	{
X		yyerror( "out of memory" );
X		return(1);
X	}
X	yypv = &yyv[-1];
X	yyps = &yys[-1];
X	yystate = 0;
X	yytmp = 0;
X	yynerrs = 0;
X	yyerrflag = 0;
X	yychar = -1;
X
X	goto yystack;
X	{
X		register YYSTYPE *yy_pv;	/* top of value stack */
X		register int *yy_ps;		/* top of state stack */
X		register int yy_state;		/* current state */
X		register int  yy_n;		/* internal state number info */
X
X		/*
X		** get globals into registers.
X		** branch to here only if YYBACKUP was called.
X		*/
X	yynewstate:
X		yy_pv = yypv;
X		yy_ps = yyps;
X		yy_state = yystate;
X		goto yy_newstate;
X
X		/*
X		** get globals into registers.
X		** either we just started, or we just finished a reduction
X		*/
X	yystack:
X		yy_pv = yypv;
X		yy_ps = yyps;
X		yy_state = yystate;
X
X		/*
X		** top of for (;;) loop while no reductions done
X		*/
X	yy_stack:
X		/*
X		** put a state and value onto the stacks
X		*/
X#if YYDEBUG
X		/*
X		** if debugging, look up token value in list of value vs.
X		** name pairs.  0 and negative (-1) are special values.
X		** Note: linear search is used since time is not a real
X		** consideration while debugging.
X		*/
X		if ( yydebug )
X		{
X			register int yy_i;
X
X			(void)printf( "State %d, token ", yy_state );
X			if ( yychar == 0 )
X				(void)printf( "end-of-file\n" );
X			else if ( yychar < 0 )
X				(void)printf( "-none-\n" );
X			else
X			{
X				for ( yy_i = 0; yytoks[yy_i].t_val >= 0;
X					yy_i++ )
X				{
X					if ( yytoks[yy_i].t_val == yychar )
X						break;
X				}
X				(void)printf( "%s\n", yytoks[yy_i].t_name );
X			}
X		}
X#endif /* YYDEBUG */
X		if ( ++yy_ps >= &yys[ yymaxdepth ] )	/* room on stack? */
X		{
X			/*
X			** reallocate and recover.  Note that pointers
X			** have to be reset, or bad things will happen
X			*/
X			int yyps_index = (yy_ps - yys);
X			int yypv_index = (yy_pv - yyv);
X			int yypvt_index = (yypvt - yyv);
X			yymaxdepth += YYMAXDEPTH;
X			yyv = (YYSTYPE*)realloc((char*)yyv,
X				yymaxdepth * sizeof(YYSTYPE));
X			yys = (int*)realloc((char*)yys,
X				yymaxdepth * sizeof(int));
X			if (!yyv || !yys)
X			{
X				yyerror( "yacc stack overflow" );
X				return(1);
X			}
X			yy_ps = yys + yyps_index;
X			yy_pv = yyv + yypv_index;
X			yypvt = yyv + yypvt_index;
X		}
X		*yy_ps = yy_state;
X		*++yy_pv = yyval;
X
X		/*
X		** we have a new state - find out what to do
X		*/
X	yy_newstate:
X		if ( ( yy_n = yypact[ yy_state ] ) <= YYFLAG )
X			goto yydefault;		/* simple state */
X#if YYDEBUG
X		/*
X		** if debugging, need to mark whether new token grabbed
X		*/
X		yytmp = yychar < 0;
X#endif
X		if ( ( yychar < 0 ) && ( ( yychar = yylex() ) < 0 ) )
X			yychar = 0;		/* reached EOF */
X#if YYDEBUG
X		if ( yydebug && yytmp )
X		{
X			register int yy_i;
X
X			(void)printf( "Received token " );
X			if ( yychar == 0 )
X				(void)printf( "end-of-file\n" );
X			else if ( yychar < 0 )
X				(void)printf( "-none-\n" );
X			else
X			{
X				for ( yy_i = 0; yytoks[yy_i].t_val >= 0;
X					yy_i++ )
X				{
X					if ( yytoks[yy_i].t_val == yychar )
X						break;
X				}
X				(void)printf( "%s\n", yytoks[yy_i].t_name );
X			}
X		}
X#endif /* YYDEBUG */
X		if ( ( ( yy_n += yychar ) < 0 ) || ( yy_n >= YYLAST ) )
X			goto yydefault;
X		if ( yychk[ yy_n = yyact[ yy_n ] ] == yychar )	/*valid shift*/
X		{
X			yychar = -1;
X			yyval = yylval;
X			yy_state = yy_n;
X			if ( yyerrflag > 0 )
X				yyerrflag--;
X			goto yy_stack;
X		}
X
X	yydefault:
X		if ( ( yy_n = yydef[ yy_state ] ) == -2 )
X		{
X#if YYDEBUG
X			yytmp = yychar < 0;
X#endif
X			if ( ( yychar < 0 ) && ( ( yychar = yylex() ) < 0 ) )
X				yychar = 0;		/* reached EOF */
X#if YYDEBUG
X			if ( yydebug && yytmp )
X			{
X				register int yy_i;
X
X				(void)printf( "Received token " );
X				if ( yychar == 0 )
X					(void)printf( "end-of-file\n" );
X				else if ( yychar < 0 )
X					(void)printf( "-none-\n" );
X				else
X				{
X					for ( yy_i = 0;
X						yytoks[yy_i].t_val >= 0;
X						yy_i++ )
X					{
X						if ( yytoks[yy_i].t_val
X							== yychar )
X						{
X							break;
X						}
X					}
X					(void)printf( "%s\n", yytoks[yy_i].t_name );
X				}
X			}
X#endif /* YYDEBUG */
X			/*
X			** look through exception table
X			*/
X			{
X				register int *yyxi = yyexca;
X
X				while ( ( *yyxi != -1 ) ||
X					( yyxi[1] != yy_state ) )
X				{
X					yyxi += 2;
X				}
X				while ( ( *(yyxi += 2) >= 0 ) &&
X					( *yyxi != yychar ) )
X					;
X				if ( ( yy_n = yyxi[1] ) < 0 )
X					YYACCEPT;
X			}
X		}
X
X		/*
X		** check for syntax error
X		*/
X		if ( yy_n == 0 )	/* have an error */
X		{
X			/* no worry about speed here! */
X			switch ( yyerrflag )
X			{
X			case 0:		/* new error */
X				yyerror( "syntax error" );
X				goto skip_init;
X			yyerrlab:
X				/*
X				** get globals into registers.
X				** we have a user generated syntax type error
X				*/
X				yy_pv = yypv;
X				yy_ps = yyps;
X				yy_state = yystate;
X				yynerrs++;
X			skip_init:
X			case 1:
X			case 2:		/* incompletely recovered error */
X					/* try again... */
X				yyerrflag = 3;
X				/*
X				** find state where "error" is a legal
X				** shift action
X				*/
X				while ( yy_ps >= yys )
X				{
X					yy_n = yypact[ *yy_ps ] + YYERRCODE;
X					if ( yy_n >= 0 && yy_n < YYLAST &&
X						yychk[yyact[yy_n]] == YYERRCODE)					{
X						/*
X						** simulate shift of "error"
X						*/
X						yy_state = yyact[ yy_n ];
X						goto yy_stack;
X					}
X					/*
X					** current state has no shift on
X					** "error", pop stack
X					*/
X#if YYDEBUG
X#	define _POP_ "Error recovery pops state %d, uncovers state %d\n"
X					if ( yydebug )
X						(void)printf( _POP_, *yy_ps,
X							yy_ps[-1] );
X#	undef _POP_
X#endif
X					yy_ps--;
X					yy_pv--;
X				}
X				/*
X				** there is no state on stack with "error" as
X				** a valid shift.  give up.
X				*/
X				YYABORT;
X			case 3:		/* no shift yet; eat a token */
X#if YYDEBUG
X				/*
X				** if debugging, look up token in list of
X				** pairs.  0 and negative shouldn't occur,
X				** but since timing doesn't matter when
X				** debugging, it doesn't hurt to leave the
X				** tests here.
X				*/
X				if ( yydebug )
X				{
X					register int yy_i;
X
X					(void)printf( "Error recovery discards " );
X					if ( yychar == 0 )
X						(void)printf( "token end-of-file\n" );
X					else if ( yychar < 0 )
X						(void)printf( "token -none-\n" );
X					else
X					{
X						for ( yy_i = 0;
X							yytoks[yy_i].t_val >= 0;
X							yy_i++ )
X						{
X							if ( yytoks[yy_i].t_val
X								== yychar )
X							{
X								break;
X							}
X						}
X						(void)printf( "token %s\n",
X							yytoks[yy_i].t_name );
X					}
X				}
X#endif /* YYDEBUG */
X				if ( yychar == 0 )	/* reached EOF. quit */
X					YYABORT;
X				yychar = -1;
X				goto yy_newstate;
X			}
X		}/* end if ( yy_n == 0 ) */
X		/*
X		** reduction by production yy_n
X		** put stack tops, etc. so things right after switch
X		*/
X#if YYDEBUG
X		/*
X		** if debugging, print the string that is the user's
X		** specification of the reduction which is just about
X		** to be done.
X		*/
X		if ( yydebug )
X			(void)printf( "Reduce by (%d) \"%s\"\n",
X				yy_n, yyreds[ yy_n ] );
X#endif
X		yytmp = yy_n;			/* value to switch over */
X		yypvt = yy_pv;			/* $vars top of value stack */
X		/*
X		** Look in goto table for next state
X		** Sorry about using yy_state here as temporary
X		** register variable, but why not, if it works...
X		** If yyr2[ yy_n ] doesn't have the low order bit
X		** set, then there is no action to be done for
X		** this reduction.  So, no saving & unsaving of
X		** registers done.  The only difference between the
X		** code just after the if and the body of the if is
X		** the goto yy_stack in the body.  This way the test
X		** can be made before the choice of what to do is needed.
X		*/
X		{
X			/* length of production doubled with extra bit */
X			register int yy_len = yyr2[ yy_n ];
X
X			if ( !( yy_len & 01 ) )
X			{
X				yy_len >>= 1;
X				yyval = ( yy_pv -= yy_len )[1];	/* $$ = $1 */
X				yy_state = yypgo[ yy_n = yyr1[ yy_n ] ] +
X					*( yy_ps -= yy_len ) + 1;
X				if ( yy_state >= YYLAST ||
X					yychk[ yy_state =
X					yyact[ yy_state ] ] != -yy_n )
X				{
X					yy_state = yyact[ yypgo[ yy_n ] ];
X				}
X				goto yy_stack;
X			}
X			yy_len >>= 1;
X			yyval = ( yy_pv -= yy_len )[1];	/* $$ = $1 */
X			yy_state = yypgo[ yy_n = yyr1[ yy_n ] ] +
X				*( yy_ps -= yy_len ) + 1;
X			if ( yy_state >= YYLAST ||
X				yychk[ yy_state = yyact[ yy_state ] ] != -yy_n )
X			{
X				yy_state = yyact[ yypgo[ yy_n ] ];
X			}
X		}
X					/* save until reenter driver code */
X		yystate = yy_state;
X		yyps = yy_ps;
X		yypv = yy_pv;
X	}
X	/*
X	** code supplied by user is placed in this switch
X	*/
X	switch( yytmp )
X	{
X		
Xcase 2:
X# line 86 "dgn_comp.y"
X{
X			output_dgn();
X		  } break;
Xcase 9:
X# line 102 "dgn_comp.y"
X{
X			init_dungeon();
X			strcpy(tmpdungeon[n_dgns].name, yypvt[-3].str);
X			if (!strcmp(yypvt[-2].str, "none"))
X				tmpdungeon[n_levs].boneschar = '\0';
X			else if (yypvt[-2].str[1])
X				yyerror("Bones marker must be a single char, or \"none\"!");
X			else
X				tmpdungeon[n_dgns].boneschar = yypvt[-2].str[0];
X			tmpdungeon[n_dgns].lev.base = couple.base;
X			tmpdungeon[n_dgns].lev.rand = couple.rand;
X			tmpdungeon[n_dgns].chance = yypvt[-0].i;
X		  } break;
Xcase 10:
X# line 118 "dgn_comp.y"
X{
X			yyval.i = 0;
X		  } break;
Xcase 11:
X# line 122 "dgn_comp.y"
X{
X			yyval.i = yypvt[-0].i;
X		  } break;
Xcase 15:
X# line 133 "dgn_comp.y"
X{
X			tmpdungeon[n_dgns].entry_lev = yypvt[-0].i;
X		  } break;
Xcase 17:
X# line 142 "dgn_comp.y"
X{
X			if(yypvt[-0].i <= TOWN || yypvt[-0].i >= D_ALIGN_CHAOTIC)
X			    yyerror("Illegal description - ignoring!");
X			else
X			    tmpdungeon[n_dgns].flags |= yypvt[-0].i ;
X		  } break;
Xcase 18:
X# line 149 "dgn_comp.y"
X{
X			if(yypvt[-0].i && yypvt[-0].i < D_ALIGN_CHAOTIC)
X			    yyerror("Illegal alignment - ignoring!");
X			else
X			    tmpdungeon[n_dgns].flags |= yypvt[-0].i ;
X		  } break;
Xcase 19:
X# line 158 "dgn_comp.y"
X{
X			strcpy(tmpdungeon[n_dgns].protoname, yypvt[-0].str);
X		  } break;
Xcase 25:
X# line 171 "dgn_comp.y"
X{
X			init_level();
X			strcpy(tmplevel[n_levs].name, yypvt[-3].str);
X			if (!strcmp(yypvt[-2].str, "none"))
X				tmplevel[n_levs].boneschar = '\0';
X			else if (yypvt[-2].str[1])
X				yyerror("Bones marker must be a single char, or \"none\"!");
X			else
X				tmplevel[n_levs].boneschar = yypvt[-2].str[0];
X			tmplevel[n_levs].lev.base = couple.base;
X			tmplevel[n_levs].lev.rand = couple.rand;
X			tmpdungeon[n_dgns].levels++;
X		  } break;
Xcase 26:
X# line 185 "dgn_comp.y"
X{
X			init_level();
X			strcpy(tmplevel[n_levs].name, yypvt[-4].str);
X			if (!strcmp(yypvt[-3].str, "none"))
X				tmplevel[n_levs].boneschar = '\0';
X			else if (yypvt[-3].str[1])
X				yyerror("Bones marker must be a single char, or \"none\"!");
X			else
X				tmplevel[n_levs].boneschar = yypvt[-3].str[0];
X			tmplevel[n_levs].lev.base = couple.base;
X			tmplevel[n_levs].lev.rand = couple.rand;
X			tmplevel[n_levs].rndlevs = yypvt[-0].i;
X			tmpdungeon[n_dgns].levels++;
X		  } break;
Xcase 27:
X# line 202 "dgn_comp.y"
X{
X			init_level();
X			strcpy(tmplevel[n_levs].name, yypvt[-4].str);
X			if (!strcmp(yypvt[-3].str, "none"))
X				tmplevel[n_levs].boneschar = '\0';
X			else if (yypvt[-3].str[1])
X				yyerror("Bones marker must be a single char, or \"none\"!");
X			else
X				tmplevel[n_levs].boneschar = yypvt[-3].str[0];
X			tmplevel[n_levs].lev.base = couple.base;
X			tmplevel[n_levs].lev.rand = couple.rand;
X			tmplevel[n_levs].chance = yypvt[-0].i;
X			tmpdungeon[n_dgns].levels++;
X		  } break;
Xcase 28:
X# line 217 "dgn_comp.y"
X{
X			init_level();
X			strcpy(tmplevel[n_levs].name, yypvt[-5].str);
X			if (!strcmp(yypvt[-4].str, "none"))
X				tmplevel[n_levs].boneschar = '\0';
X			else if (yypvt[-4].str[1])
X				yyerror("Bones marker must be a single char, or \"none\"!");
X			else
X				tmplevel[n_levs].boneschar = yypvt[-4].str[0];
X			tmplevel[n_levs].lev.base = couple.base;
X			tmplevel[n_levs].lev.rand = couple.rand;
X			tmplevel[n_levs].chance = yypvt[-1].i;
X			tmplevel[n_levs].rndlevs = yypvt[-0].i;
X			tmpdungeon[n_dgns].levels++;
X		  } break;
Xcase 29:
X# line 235 "dgn_comp.y"
X{
X			if(yypvt[-0].i >= D_ALIGN_CHAOTIC)
X			    yyerror("Illegal description - ignoring!");
X			else
X			    tmplevel[n_levs].flags |= yypvt[-0].i ;
X		  } break;
Xcase 30:
X# line 242 "dgn_comp.y"
X{
X			if(yypvt[-0].i && yypvt[-0].i < D_ALIGN_CHAOTIC)
X			    yyerror("Illegal alignment - ignoring!");
X			else
X			    tmplevel[n_levs].flags |= yypvt[-0].i ;
X		  } break;
Xcase 31:
X# line 251 "dgn_comp.y"
X{
X			init_level();
X			strcpy(tmplevel[n_levs].name, yypvt[-4].str);
X			if (!strcmp(yypvt[-3].str, "none"))
X				tmplevel[n_levs].boneschar = '\0';
X			else if (yypvt[-3].str[1])
X				yyerror("Bones marker must be a single char, or \"none\"!");
X			else
X				tmplevel[n_levs].boneschar = yypvt[-3].str[0];
X			tmplevel[n_levs].chain = getchain(yypvt[-2].str);
X			tmplevel[n_levs].lev.base = couple.base;
X			tmplevel[n_levs].lev.rand = couple.rand;
X			if(!check_level()) n_levs--;
X			else tmpdungeon[n_dgns].levels++;
X		  } break;
Xcase 32:
X# line 267 "dgn_comp.y"
X{
X			init_level();
X			strcpy(tmplevel[n_levs].name, yypvt[-5].str);
X			if (!strcmp(yypvt[-4].str, "none"))
X				tmplevel[n_levs].boneschar = '\0';
X			else if (yypvt[-4].str[1])
X				yyerror("Bones marker must be a single char, or \"none\"!");
X			else
X				tmplevel[n_levs].boneschar = yypvt[-4].str[0];
X			tmplevel[n_levs].chain = getchain(yypvt[-3].str);
X			tmplevel[n_levs].lev.base = couple.base;
X			tmplevel[n_levs].lev.rand = couple.rand;
X			tmplevel[n_levs].rndlevs = yypvt[-0].i;
X			if(!check_level()) n_levs--;
X			else tmpdungeon[n_dgns].levels++;
X		  } break;
Xcase 33:
X# line 286 "dgn_comp.y"
X{
X			init_level();
X			strcpy(tmplevel[n_levs].name, yypvt[-5].str);
X			if (!strcmp(yypvt[-4].str, "none"))
X				tmplevel[n_levs].boneschar = '\0';
X			else if (yypvt[-4].str[1])
X				yyerror("Bones marker must be a single char, or \"none\"!");
X			else
X				tmplevel[n_levs].boneschar = yypvt[-4].str[0];
X			tmplevel[n_levs].chain = getchain(yypvt[-3].str);
X			tmplevel[n_levs].lev.base = couple.base;
X			tmplevel[n_levs].lev.rand = couple.rand;
X			tmplevel[n_levs].chance = yypvt[-0].i;
X			if(!check_level()) n_levs--;
X			else tmpdungeon[n_dgns].levels++;
X		  } break;
Xcase 34:
X# line 303 "dgn_comp.y"
X{
X			init_level();
X			strcpy(tmplevel[n_levs].name, yypvt[-6].str);
X			if (!strcmp(yypvt[-5].str, "none"))
X				tmplevel[n_levs].boneschar = '\0';
X			else if (yypvt[-5].str[1])
X				yyerror("Bones marker must be a single char, or \"none\"!");
X			else
X				tmplevel[n_levs].boneschar = yypvt[-5].str[0];
X			tmplevel[n_levs].chain = getchain(yypvt[-4].str);
X			tmplevel[n_levs].lev.base = couple.base;
X			tmplevel[n_levs].lev.rand = couple.rand;
X			tmplevel[n_levs].chance = yypvt[-1].i;
X			tmplevel[n_levs].rndlevs = yypvt[-0].i;
X			if(!check_level()) n_levs--;
X			else tmpdungeon[n_dgns].levels++;
X		  } break;
Xcase 37:
X# line 327 "dgn_comp.y"
X{
X			init_branch();
X			strcpy(tmpbranch[n_brs].name, yypvt[-4].str);
X			tmpbranch[n_brs].lev.base = couple.base;
X			tmpbranch[n_brs].lev.rand = couple.rand;
X			tmpbranch[n_brs].type = yypvt[-1].i;
X			tmpbranch[n_brs].up = yypvt[-0].i;
X			if(!check_branch()) n_brs--;
X			else tmpdungeon[n_dgns].branches++;
X		  } break;
Xcase 38:
X# line 340 "dgn_comp.y"
X{
X			init_branch();
X			strcpy(tmpbranch[n_brs].name, yypvt[-5].str);
X			tmpbranch[n_brs].chain = getchain(yypvt[-4].str);
X			tmpbranch[n_brs].lev.base = couple.base;
X			tmpbranch[n_brs].lev.rand = couple.rand;
X			tmpbranch[n_brs].type = yypvt[-1].i;
X			tmpbranch[n_brs].up = yypvt[-0].i;
X			if(!check_branch()) n_brs--;
X			else tmpdungeon[n_dgns].branches++;
X		  } break;
Xcase 39:
X# line 354 "dgn_comp.y"
X{
X			yyval.i = TBR_STAIR;	/* two way stair */
X		  } break;
Xcase 40:
X# line 358 "dgn_comp.y"
X{
X			yyval.i = TBR_STAIR;	/* two way stair */
X		  } break;
Xcase 41:
X# line 362 "dgn_comp.y"
X{
X			yyval.i = TBR_NO_UP;	/* no up staircase */
X		  } break;
Xcase 42:
X# line 366 "dgn_comp.y"
X{
X			yyval.i = TBR_NO_DOWN;	/* no down staircase */
X		  } break;
Xcase 43:
X# line 370 "dgn_comp.y"
X{
X			yyval.i = TBR_PORTAL;	/* portal connection */
X		  } break;
Xcase 44:
X# line 376 "dgn_comp.y"
X{
X			yyval.i = 0;	/* defaults to down */
X		  } break;
Xcase 45:
X# line 380 "dgn_comp.y"
X{
X			yyval.i = yypvt[-0].i;
X		  } break;
Xcase 46:
X# line 403 "dgn_comp.y"
X{
X			if (yypvt[-3].i < -MAXLEVEL || yypvt[-3].i > MAXLEVEL) {
X			    yyerror("Abs base out of dlevel range - zeroing!");
X			    couple.base = couple.rand = 0;
X			} else if (yypvt[-1].i < -1 ||
X				((yypvt[-3].i < 0) ? (MAXLEVEL + yypvt[-3].i + yypvt[-1].i + 1) > MAXLEVEL :
X					(yypvt[-3].i + yypvt[-1].i) > MAXLEVEL)) {
X			    yyerror("Abs range out of dlevel range - zeroing!");
X			    couple.base = couple.rand = 0;
X			} else {
X			    couple.base = yypvt[-3].i;
X			    couple.rand = yypvt[-1].i;
X			}
X		  } break;
Xcase 47:
X# line 440 "dgn_comp.y"
X{
X			if (yypvt[-3].i < -MAXLEVEL || yypvt[-3].i > MAXLEVEL) {
X			    yyerror("Rel base out of dlevel range - zeroing!");
X			    couple.base = couple.rand = 0;
X			} else {
X			    couple.base = yypvt[-3].i;
X			    couple.rand = yypvt[-1].i;
X			}
X		  } break;
X	}
X	goto yystack;		/* reset registers in driver code */
X}
END_OF_FILE
if test 32600 -ne `wc -c <'sys/share/dgn_yacc.c'`; then
    echo shar: \"'sys/share/dgn_yacc.c'\" unpacked with wrong size!
fi
# end of 'sys/share/dgn_yacc.c'
fi
echo shar: End of archive 57 \(of 108\).
cp /dev/null ark57isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \
21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \
41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 \
61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 \
81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 \
101 102 103 104 105 106 107 108 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 108 archives.
    echo "Now execute 'rebuild.sh'"
    rm -f ark10[0-8]isdone ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
