Path: uunet!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v16i008:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Part08/108
Message-ID: <4291@master.CNA.TEK.COM>
Date: 28 Jan 93 19:11:33 GMT
Sender: news@master.CNA.TEK.COM
Lines: 2079
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1564

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 16, Issue 8
Archive-name: nethack31/Part08
Supersedes: nethack3p9: Volume 10, Issue 46-102
Environment: Amiga, Atari, Mac, MS-DOS, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 8 (of 108)."
# Contents:  dat/dungeon.def sys/unix/cpp3.shr
# Wrapped by billr@saab on Wed Jan 27 16:08:48 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'dat/dungeon.def' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dat/dungeon.def'\"
else
echo shar: Extracting \"'dat/dungeon.def'\" \(3434 characters\)
sed "s/^X//" >'dat/dungeon.def' <<'END_OF_FILE'
X#	SCCS Id: @(#)dungeon.def	3.1	92/01/26
X#	Copyright (c) 1990-92 by M. Stephenson
X# NetHack may be freely redistributed.  See license for details.
X#
X#	The dungeon description file for the "standard" 3.1 NetHack.
X#
X#	Note:	The order of the definition of dungeons in this file
X#		reflects in their order of creation in the real dungeon.
X#		The "Main" branch must *always* be first.
X#
X
XDUNGEON:	"The Dungeons of Doom" "D" (25, 5)
XALIGNMENT:	unaligned
X%MULDGN	BRANCH:	"The Gnomish Mines" @ (2, 3)
X%REINCARNATION LEVEL:		"rogue" "R" @ (15, 4)
XLEVEL:		"oracle" "O" @ (5, 5)
XLEVALIGN:	neutral
XLEVEL:		"bigroom" "B" @ (10, 3) 15
X%MULDGN	CHAINBRANCH:	"The Quest" "oracle" + (6, 2) portal
X%MULDGN BRANCH:		"Fort Ludios" @ (18, 4) portal
XRNDLEVEL:	"medusa" "none" @ (-5, 4) 2
XLEVALIGN:	chaotic
XLEVEL:		"castle" "none" @ (-1, 0)
XCHAINBRANCH:	"Gehennom" "castle" + (0, 0) no_down
XBRANCH:		"The Elemental Planes" @ (1, 0) no_down up
X
X#
X#	Gehennom
X#
X#	Now re-worked for 3.1  hell is hopefully going to be a little
X#	less boring.  Also, in 3.1, the tower is not considered as a
X#	part of hell, but is set up as a separate dungeon.
X#
X#	Gehennom is no longer considered "hellish" as a complete dungeon.
X#	That is, fire resistance is no longer a condition for survival in
X#	it.  However, Gehennom, and the special levels in it in particular,
X#	is abundant with fire traps.  As a result, fire resistance is still
X#	a prudent survival strategy in Gehennom.
X#
X#	Note:	Gehennom *must* be the second dungeon defined so that
X#		monsters can properly migrate here under certain
X#		circumstances.
X#
XDUNGEON:	"Gehennom" "G" (25, 5)
XDESCRIPTION:	mazelike
XDESCRIPTION:	hellish
XALIGNMENT:	noalign
XBRANCH:		"Vlad's Tower" @ (13, 5) up
XLEVEL:		"valley" "V" @ (1, 0)
XLEVEL:		"sanctum" "none" @ (-1, 0)
XLEVEL:		"juiblex" "J" @ (6, 4)
XLEVEL:		"baalz" "B" @ (9, 4)
XLEVEL:		"asmodeus" "A" @ (2, 6)
XLEVEL:		"wizard1" "none" @ (15, 6)
XCHAINLEVEL:	"wizard2" "X" "wizard1" + (1, 0)
XCHAINLEVEL:	"wizard3" "Y" "wizard1" + (2, 0)
XLEVEL:		"orcus" "O" @ (15, 5)
XLEVEL:		"fakewiz1" "F" @ (-6,4)
XLEVEL:		"fakewiz2" "G" @ (-6,4)
X
X#
X#	The Mines of the Gnomes of Zurich.
X#
X%MULDGN	DUNGEON:	"The Gnomish Mines" "M" (8, 2)
X%MULDGN ALIGNMENT:	lawful
X%MULDGN	DESCRIPTION:	mazelike
X%MULDGN	LEVEL:		"minetown" "T" @ (3, 2)
X%MULDGN	LEVELDESC:	town
X%MULDGN	LEVEL:		"mine_end" "E" @ (-1, 0)
X
X#
X#	The Questdungeon
X#
X#	This is a proto-dungeon.  The level file names will be prepended with
X#	the first letter of the character name during initialization.
X#	A special "x-fill" level must be defined in the levels description
X#	file.  It will be used for all levels not defined explicitly below.
X#
X%MULDGN	DUNGEON:	"The Quest" "Q" (5, 2)
X%MULDGN	LEVEL:	"x-start" "none" @ (1, 1)
X%MULDGN	LEVEL:	"x-locate" "L" @ (3, 1)
X%MULDGN	LEVEL:	"x-goal" "none" @ (-1, 0)
X
X#
X#	The Central Vault of Croesus.
X#
X%MULDGN DUNGEON:	"Fort Ludios" "K" (1, 0)
X%MULDGN DESCRIPTION:	mazelike
X%MULDGN ALIGNMENT:	unaligned
X%MULDGN LEVEL:		"knox" "K" @ (-1, 0)
X#
X#	Vlad's Tower
X#
X#	It has been removed from Gehennom, and it is surrounded by stone.
X#
XDUNGEON:	"Vlad's Tower" "T" (3, 0)
XPROTOFILE:	"tower"
XDESCRIPTION:	mazelike
XALIGNMENT:	chaotic
XENTRY:		-1
X
X#
X#	The Endgame levels
X#
XDUNGEON:	"The Elemental Planes" "E" (5, 0)
XDESCRIPTION:	mazelike
XALIGNMENT:	unaligned
XENTRY:		-1
XLEVEL:		"astral" "Z" @ (1, 0)
XLEVEL:		"water"  "W" @ (2, 0)
XLEVEL:		"fire"   "F" @ (3, 0)
XLEVEL:		"air"    "A" @ (4, 0)
XLEVEL:		"earth"  "E" @ (5, 0)
END_OF_FILE
if test 3434 -ne `wc -c <'dat/dungeon.def'`; then
    echo shar: \"'dat/dungeon.def'\" unpacked with wrong size!
fi
# end of 'dat/dungeon.def'
fi
if test -f 'sys/unix/cpp3.shr' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/unix/cpp3.shr'\"
else
echo shar: Extracting \"'sys/unix/cpp3.shr'\" \(51837 characters\)
sed "s/^X//" >'sys/unix/cpp3.shr' <<'END_OF_FILE'
X#!/bin/sh
X# This is a shell archive.  Save it in a file, remove anything before
X# this line, and then unpack it by entering "sh file".  Note, it may
X# create directories; files and directories will be owned by you and
X# have default permissions.
X#
X# This archive contains:
X#
X#	cpp5.c
X#	cpp6.c
X#
Xecho x - cpp5.c
Xsed 's/^X//' >cpp5.c << 'END-of-cpp5.c'
XX/*
XX *			    C P P 5 . C
XX *		E x p r e s s i o n   E v a l u a t i o n
XX *
XX * Edit History
XX * 31-Aug-84	MM	USENET net.sources release
XX * 04-Oct-84	MM	__LINE__ and __FILE__ must call ungetstring()
XX *			so they work correctly with token concatenation.
XX *			Added string formal recognition.
XX * 25-Oct-84	MM	"Short-circuit" evaluate #if's so that we
XX *			don't print unnecessary error messages for
XX *			#if !defined(FOO) && FOO != 0 && 10 / FOO ...
XX * 31-Oct-84	ado/MM	Added token concatenation
XX *  6-Nov-84	MM	Split from #define stuff, added sizeof stuff
XX * 19-Nov-84	ado	#if error returns TRUE for (sigh) compatibility
XX */
XX
XX#include	<stdio.h>
XX#include	<ctype.h>
XX#include	"cppdef.h"
XX#include	"cpp.h"
XX
XX/*
XX * Evaluate an #if expression.
XX */
XX
XXstatic char	*opname[] = {		/* For debug and error messages	*/
XX"end of expression", "val", "id",
XX  "+",   "-",  "*",  "/",  "%",
XX  "<<", ">>",  "&",  "|",  "^",
XX  "==", "!=",  "<", "<=", ">=",  ">",
XX  "&&", "||",  "?",  ":",  ",",
XX  "unary +", "unary -", "~", "!",  "(",  ")", "(none)",
XX};
XX
XX/*
XX * opdope[] has the operator precedence:
XX *     Bits
XX *	  7	Unused (so the value is always positive)
XX *	6-2	Precedence (000x .. 017x)
XX *	1-0	Binary op. flags:
XX *	    01	The binop flag should be set/cleared when this op is seen.
XX *	    10	The new value of the binop flag.
XX * Note:  Expected, New binop
XX * constant	0	1	Binop, end, or ) should follow constants
XX * End of line	1	0	End may not be preceeded by an operator
XX * binary	1	0	Binary op follows a value, value follows.
XX * unary	0	0	Unary op doesn't follow a value, value follows
XX *   (		0	0	Doesn't follow value, value or unop follows
XX *   )		1	1	Follows value.  Op follows.
XX */
XX
XXstatic char	opdope[OP_MAX] = {
XX  0001,					/* End of expression		*/
XX  0002,					/* Digit			*/
XX  0000,					/* Letter (identifier)		*/
XX  0141, 0141, 0151, 0151, 0151,		/* ADD, SUB, MUL, DIV, MOD	*/
XX  0131, 0131, 0101, 0071, 0071,		/* ASL, ASR, AND,  OR, XOR	*/
XX  0111, 0111, 0121, 0121, 0121,	0121,	/*  EQ,  NE,  LT,  LE,  GE,  GT	*/
XX  0061, 0051, 0041, 0041, 0031,		/* ANA, ORO, QUE, COL, CMA	*/
XX/*
XX * Unary op's follow
XX */
XX  0160, 0160, 0160, 0160,		/* NEG, PLU, COM, NOT		*/
XX  0170, 0013, 0023,			/* LPA, RPA, END		*/
XX};
XX/*
XX * OP_QUE and OP_RPA have alternate precedences:
XX */
XX#define	OP_RPA_PREC	0013
XX#define OP_QUE_PREC	0034
XX
XX/*
XX * S_ANDOR and S_QUEST signal "short-circuit" boolean evaluation, so that
XX *	#if FOO != 0 && 10 / FOO ...
XX * doesn't generate an error message.  They are stored in optab.skip.
XX */
XX#define S_ANDOR		2
XX#define S_QUEST		1
XX
XXtypedef struct optab {
XX    char	op;			/* Operator			*/
XX    char	prec;			/* Its precedence		*/
XX    char	skip;			/* Short-circuit: TRUE to skip	*/
XX} OPTAB;
XXstatic int	evalue;			/* Current value from evallex()	*/
XX
XX#ifdef	nomacargs
XXFILE_LOCAL int
XXisbinary(op)
XXregister int	op;
XX{
XX	return (op >= FIRST_BINOP && op <= LAST_BINOP);
XX}
XX
XXFILE_LOCAL int
XXisunary(op)
XXregister int	op;
XX{
XX	return (op >= FIRST_UNOP && op <= LAST_UNOP);
XX}
XX#else
XX#define	isbinary(op)	(op >= FIRST_BINOP && op <= LAST_BINOP)
XX#define	isunary(op)	(op >= FIRST_UNOP  && op <= LAST_UNOP)
XX#endif
XX
XX/*
XX * The following definitions are used to specify basic variable sizes.
XX */
XX
XX#ifndef	S_CHAR
XX#define	S_CHAR		(sizeof (char))
XX#endif
XX#ifndef	S_SINT
XX#define	S_SINT		(sizeof (short int))
XX#endif
XX#ifndef	S_INT
XX#define	S_INT		(sizeof (int))
XX#endif
XX#ifndef	S_LINT
XX#define	S_LINT		(sizeof (long int))
XX#endif
XX#ifndef	S_FLOAT
XX#define	S_FLOAT		(sizeof (float))
XX#endif
XX#ifndef	S_DOUBLE
XX#define	S_DOUBLE	(sizeof (double))
XX#endif
XX#ifndef	S_PCHAR
XX#define	S_PCHAR		(sizeof (char *))
XX#endif
XX#ifndef	S_PSINT
XX#define	S_PSINT		(sizeof (short int *))
XX#endif
XX#ifndef	S_PINT
XX#define	S_PINT		(sizeof (int *))
XX#endif
XX#ifndef	S_PLINT
XX#define	S_PLINT		(sizeof (long int *))
XX#endif
XX#ifndef	S_PFLOAT
XX#define	S_PFLOAT	(sizeof (float *))
XX#endif
XX#ifndef	S_PDOUBLE
XX#define	S_PDOUBLE	(sizeof (double *))
XX#endif
XX#ifndef	S_PFPTR
XX#define S_PFPTR		(sizeof (int (*)()))
XX#endif
XX
XXtypedef struct types {
XX    short	type;			/* This is the bit if		*/
XX    char	*name;			/* this is the token word	*/
XX} TYPES;
XX
XXstatic TYPES basic_types[] = {
XX	{ T_CHAR,	"char",		},
XX	{ T_INT,	"int",		},
XX	{ T_FLOAT,	"float",	},
XX	{ T_DOUBLE,	"double",	},
XX	{ T_SHORT,	"short",	},
XX	{ T_LONG,	"long",		},
XX	{ T_SIGNED,	"signed",	},
XX	{ T_UNSIGNED,	"unsigned",	},
XX	{ 0,		NULL,		},	/* Signal end		*/
XX};
XX
XX/*
XX * Test_table[] is used to test for illegal combinations.
XX */
XXstatic short test_table[] = {
XX	T_FLOAT | T_DOUBLE | T_LONG | T_SHORT,
XX	T_FLOAT | T_DOUBLE | T_CHAR | T_INT,
XX	T_FLOAT | T_DOUBLE | T_SIGNED | T_UNSIGNED,
XX	T_LONG  | T_SHORT  | T_CHAR,
XX	0						/* end marker	*/
XX};
XX
XX/*
XX * The order of this table is important -- it is also referenced by
XX * the command line processor to allow run-time overriding of the
XX * built-in size values.  The order must not be changed:
XX *	char, short, int, long, float, double (func pointer)
XX */
XXSIZES size_table[] = {
XX    { T_CHAR,	S_CHAR,		S_PCHAR		},	/* char		*/
XX    { T_SHORT,	S_SINT,		S_PSINT		},	/* short int	*/
XX    { T_INT,	S_INT,		S_PINT		},	/* int		*/
XX    { T_LONG,	S_LINT,		S_PLINT		},	/* long		*/
XX    { T_FLOAT,	S_FLOAT,	S_PFLOAT	},	/* float	*/
XX    { T_DOUBLE,	S_DOUBLE,	S_PDOUBLE	},	/* double	*/
XX    { T_FPTR,	0,		S_PFPTR		},	/* int (*()) 	*/
XX    { 0,	0,		0		},	/* End of table	*/
XX};
XX
XXint
XXeval()
XX/*
XX * Evaluate an expression.  Straight-forward operator precedence.
XX * This is called from control() on encountering an #if statement.
XX * It calls the following routines:
XX * evallex	Lexical analyser -- returns the type and value of
XX *		the next input token.
XX * evaleval	Evaluate the current operator, given the values on
XX *		the value stack.  Returns a pointer to the (new)
XX *		value stack.
XX * For compatiblity with older cpp's, this return returns 1 (TRUE)
XX * if a syntax error is detected.
XX */
XX{
XX	register int	op;		/* Current operator		*/
XX	register int	*valp;		/* -> value vector		*/
XX	register OPTAB	*opp;		/* Operator stack		*/
XX	int		prec;		/* Op precedence		*/
XX	int		binop;		/* Set if binary op. needed	*/
XX	int		op1;		/* Operand from stack		*/
XX	int		skip;		/* For short-circuit testing	*/
XX	int		value[NEXP];	/* Value stack			*/
XX	OPTAB		opstack[NEXP];	/* Operand stack		*/
XX	extern int	*evaleval();	/* Does actual evaluation	*/
XX
XX	valp = value;
XX	opp = opstack;
XX	opp->op = OP_END;		/* Mark bottom of stack		*/
XX	opp->prec = opdope[OP_END];	/* And its precedence		*/
XX	opp->skip = 0;			/* Not skipping now		*/
XX	binop = 0;
XXagain:	;
XX#ifdef	DEBUG_EVAL
XX	printf("In #if at again: skip = %d, binop = %d, line is: %s",
XX	    opp->skip, binop, infile->bptr);
XX#endif
XX	if ((op = evallex(opp->skip)) == OP_SUB && binop == 0)
XX	    op = OP_NEG;			/* Unary minus		*/
XX	else if (op == OP_ADD && binop == 0)
XX	    op = OP_PLU;			/* Unary plus		*/
XX	else if (op == OP_FAIL)
XX	    return (1);				/* Error in evallex	*/
XX#ifdef	DEBUG_EVAL
XX	printf("op = %s, opdope = %03o, binop = %d, skip = %d\n",
XX	    opname[op], opdope[op], binop, opp->skip);
XX#endif
XX	if (op == DIG) {			/* Value?		*/
XX	    if (binop != 0) {
XX		cerror("misplaced constant in #if", NULLST);
XX		return (1);
XX	    }
XX	    else if (valp >= &value[NEXP-1]) {
XX		cerror("#if value stack overflow", NULLST);
XX		return (1);
XX	    }
XX	    else {
XX#ifdef	DEBUG_EVAL
XX		printf("pushing %d onto value stack[%d]\n",
XX		    evalue, valp - value);
XX#endif
XX		*valp++ = evalue;
XX		binop = 1;
XX	    }
XX	    goto again;
XX	}
XX	else if (op > OP_END) {
XX	    cerror("Illegal #if line", NULLST);
XX	    return (1);
XX	}
XX	prec = opdope[op];
XX	if (binop != (prec & 1)) {
XX	    cerror("Operator %s in incorrect context", opname[op]);
XX	    return (1);
XX	}
XX	binop = (prec & 2) >> 1;
XX	for (;;) {
XX#ifdef	DEBUG_EVAL
XX	    printf("op %s, prec %d., stacked op %s, prec %d, skip %d\n",
XX		opname[op], prec, opname[opp->op], opp->prec, opp->skip);
XX#endif
XX	    if (prec > opp->prec) {
XX		if (op == OP_LPA)
XX		    prec = OP_RPA_PREC;
XX		else if (op == OP_QUE)
XX		    prec = OP_QUE_PREC;
XX		op1 = opp->skip;		/* Save skip for test	*/
XX		/*
XX		 * Push operator onto op. stack.
XX		 */
XX		opp++;
XX		if (opp >= &opstack[NEXP]) {
XX		    cerror("expression stack overflow at op \"%s\"",
XX			opname[op]);
XX		    return (1);
XX		}
XX		opp->op = op;
XX		opp->prec = prec;
XX		skip = (valp[-1] != 0);		/* Short-circuit tester	*/
XX		/*
XX		 * Do the short-circuit stuff here.  Short-circuiting
XX		 * stops automagically when operators are evaluated.
XX		 */
XX		if ((op == OP_ANA && !skip)
XX		 || (op == OP_ORO && skip))
XX		    opp->skip = S_ANDOR;	/* And/or skip starts	*/
XX		else if (op == OP_QUE)		/* Start of ?: operator	*/
XX		    opp->skip = (op1 & S_ANDOR) | ((!skip) ? S_QUEST : 0);
XX		else if (op == OP_COL) {	/* : inverts S_QUEST	*/
XX		    opp->skip = (op1 & S_ANDOR)
XX			      | (((op1 & S_QUEST) != 0) ? 0 : S_QUEST);
XX		}
XX		else {				/* Other ops leave	*/
XX		    opp->skip = op1;		/*  skipping unchanged.	*/
XX		}
XX#ifdef	DEBUG_EVAL
XX		printf("stacking %s, valp[-1] == %d at %s",
XX		    opname[op], valp[-1], infile->bptr);
XX		dumpstack(opstack, opp, value, valp);
XX#endif
XX		goto again;
XX	    }
XX	    /*
XX	     * Pop operator from op. stack and evaluate it.
XX	     * End of stack and '(' are specials.
XX	     */
XX	    skip = opp->skip;			/* Remember skip value	*/
XX	    switch ((op1 = opp->op)) {		/* Look at stacked op	*/
XX	    case OP_END:			/* Stack end marker	*/
XX		if (op == OP_EOE)
XX		    return (valp[-1]);		/* Finished ok.		*/
XX		goto again;			/* Read another op.	*/
XX
XX	    case OP_LPA:			/* ( on stack		*/
XX		if (op != OP_RPA) {		/* Matches ) on input	*/
XX		    cerror("unbalanced paren's, op is \"%s\"", opname[op]);
XX		    return (1);
XX		}
XX		opp--;				/* Unstack it		*/
XX		/* goto again;			-- Fall through		*/
XX
XX	    case OP_QUE:
XX		goto again;			/* Evaluate true expr.	*/
XX
XX	    case OP_COL:			/* : on stack.		*/
XX		opp--;				/* Unstack :		*/
XX		if (opp->op != OP_QUE) {	/* Matches ? on stack?	*/
XX		    cerror("Misplaced '?' or ':', previous operator is %s",
XX			opname[opp->op]);
XX		    return (1);
XX		}
XX		/*
XX		 * Evaluate op1.
XX		 */
XX	    default:				/* Others:		*/
XX		opp--;				/* Unstack the operator	*/
XX#ifdef	DEBUG_EVAL
XX		printf("Stack before evaluation of %s\n", opname[op1]);
XX		dumpstack(opstack, opp, value, valp);
XX#endif
XX		valp = evaleval(valp, op1, skip);
XX#ifdef	DEBUG_EVAL
XX		printf("Stack after evaluation\n");
XX		dumpstack(opstack, opp, value, valp);
XX#endif
XX	    }					/* op1 switch end	*/
XX	}					/* Stack unwind loop	*/
XX}
XX
XXFILE_LOCAL int
XXevallex(skip)
XXint		skip;		/* TRUE if short-circuit evaluation	*/
XX/*
XX * Return next eval operator or value.  Called from eval().  It
XX * calls a special-purpose routines for 'char' strings and
XX * numeric values:
XX * evalchar	called to evaluate 'x'
XX * evalnum	called to evaluate numbers.
XX */
XX{
XX	register int	c, c1, t;
XX
XXagain:  do {					/* Collect the token	*/
XX	    c = skipws();
XX	    if ((c = macroid(c)) == EOF_CHAR || c == '\n') {
XX		unget();
XX		return (OP_EOE);		/* End of expression	*/
XX	    }
XX	} while ((t = type[c]) == LET && catenate());
XX	if (t == INV) {				/* Total nonsense	*/
XX	    if (!skip) {
XX		if (isascii(c) && isprint(c))
XX		    cierror("illegal character '%c' in #if", c);
XX		else
XX		    cierror("illegal character (%d decimal) in #if", c);
XX	    }
XX	    return (OP_FAIL);
XX	}
XX	else if (t == QUO) {			/* ' or "		*/
XX	    if (c == '\'') {			/* Character constant	*/
XX		evalue = evalchar(skip);	/* Somewhat messy	*/
XX#ifdef	DEBUG_EVAL
XX		printf("evalchar returns %d.\n", evalue);
XX#endif
XX		return (DIG);			/* Return a value	*/
XX	    }
XX	    cerror("Can't use a string in an #if", NULLST);
XX	    return (OP_FAIL);
XX	}
XX	else if (t == LET) {			/* ID must be a macro	*/
XX	    if (streq(token, "defined")) {	/* Or defined name	*/
XX		c1 = c = skipws();
XX		if (c == '(')			/* Allow defined(name)	*/
XX		    c = skipws();
XX		if (type[c] == LET) {
XX		    evalue = (lookid(c) != NULL);
XX		    if (c1 != '('		/* Need to balance	*/
XX		     || skipws() == ')')	/* Did we balance?	*/
XX			return (DIG);		/* Parsed ok		*/
XX		}
XX		cerror("Bad #if ... defined() syntax", NULLST);
XX		return (OP_FAIL);
XX	    }
XX	    else if (streq(token, "sizeof"))	/* New sizeof hackery	*/
XX		return (dosizeof());		/* Gets own routine	*/
XX	    /*
XX	     * The Draft ANSI C Standard says that an undefined symbol
XX	     * in an #if has the value zero.  We are a bit pickier,
XX	     * warning except where the programmer was careful to write
XX	     * 		#if defined(foo) ? foo : 0
XX	     */
XX#ifdef VERBOSE
XX	     if (!skip)
XX  		cwarn("undefined symbol \"%s\" in #if, 0 used", token);
XX#endif
XX	    evalue = 0;
XX	    return (DIG);
XX	}
XX	else if (t == DIG) {			/* Numbers are harder	*/
XX	    evalue = evalnum(c);
XX#ifdef	DEBUG_EVAL
XX	    printf("evalnum returns %d.\n", evalue);
XX#endif
XX	}
XX	else if (strchr("!=<>&|\\", c) != NULL) {
XX	    /*
XX	     * Process a possible multi-byte lexeme.
XX	     */
XX	    c1 = cget();			/* Peek at next char	*/
XX	    switch (c) {
XX	    case '!':
XX		if (c1 == '=')
XX		    return (OP_NE);
XX		break;
XX
XX	    case '=':
XX		if (c1 != '=') {		/* Can't say a=b in #if	*/
XX		    unget();
XX		    cerror("= not allowed in #if", NULLST);
XX		    return (OP_FAIL);
XX		}
XX		return (OP_EQ);
XX
XX	    case '>':
XX	    case '<':
XX		if (c1 == c)
XX		    return ((c == '<') ? OP_ASL : OP_ASR);
XX		else if (c1 == '=')
XX		    return ((c == '<') ? OP_LE  : OP_GE);
XX		break;
XX
XX	    case '|':
XX	    case '&':
XX		if (c1 == c)
XX		    return ((c == '|') ? OP_ORO : OP_ANA);
XX		break;
XX
XX	    case '\\':
XX		if (c1 == '\n')			/* Multi-line if	*/
XX		    goto again;
XX		cerror("Unexpected \\ in #if", NULLST);
XX		return (OP_FAIL);
XX	    }
XX	    unget();
XX	}
XX	return (t);
XX}
XX
XXFILE_LOCAL int
XXdosizeof()
XX/*
XX * Process the sizeof (basic type) operation in an #if string.
XX * Sets evalue to the size and returns
XX *	DIG		success
XX *	OP_FAIL		bad parse or something.
XX */
XX{
XX	register int	c;
XX	register TYPES	*tp;
XX	register SIZES	*sizp;
XX	register short	*testp;
XX	short		typecode;
XX
XX	if ((c = skipws()) != '(')
XX	    goto nogood;
XX	/*
XX	 * Scan off the tokens.
XX	 */
XX	typecode = 0;
XX	while ((c = skipws())) {
XX	    if ((c = macroid(c)) == EOF_CHAR || c == '\n')
XX		goto nogood;			/* End of line is a bug	*/
XX	    else if (c == '(') {		/* thing (*)() func ptr	*/
XX		if (skipws() == '*'
XX		 && skipws() == ')') {		/* We found (*)		*/
XX		    if (skipws() != '(')	/* Let () be optional	*/
XX			unget();
XX		    else if (skipws() != ')')
XX			goto nogood;
XX		    typecode |= T_FPTR;		/* Function pointer	*/
XX		}
XX		else {				/* Junk is a bug	*/
XX		    goto nogood;
XX		}
XX	    }
XX	    else if (type[c] != LET)		/* Exit if not a type	*/
XX		break;
XX	    else if (!catenate()) {		/* Maybe combine tokens	*/
XX		/*
XX		 * Look for this unexpandable token in basic_types.
XX		 * The code accepts "int long" as well as "long int"
XX		 * which is a minor bug as bugs go (and one shared with
XX		 * a lot of C compilers).
XX		 */
XX		for (tp = basic_types; tp->name != NULLST; tp++) {
XX		    if (streq(token, tp->name))
XX			break;
XX		}
XX		if (tp->name == NULLST) {
XX		    cerror("#if sizeof, unknown type \"%s\"", token);
XX		    return (OP_FAIL);
XX		}
XX		typecode |= tp->type;		/* Or in the type bit	*/
XX	    }
XX	}
XX	/*
XX	 * We are at the end of the type scan.  Chew off '*' if necessary.
XX	 */
XX	if (c == '*') {
XX	    typecode |= T_PTR;
XX	    c = skipws();
XX	}
XX	if (c == ')') {				/* Last syntax check	*/
XX	    for (testp = test_table; *testp != 0; testp++) {
XX		if (!bittest(typecode & *testp)) {
XX		    cerror("#if ... sizeof: illegal type combination", NULLST);
XX		    return (OP_FAIL);
XX		}
XX	    }
XX	    /*
XX	     * We assume that all function pointers are the same size:
XX	     *		sizeof (int (*)()) == sizeof (float (*)())
XX	     * We assume that signed and unsigned don't change the size:
XX	     *		sizeof (signed int) == (sizeof unsigned int)
XX	     */
XX	    if ((typecode & T_FPTR) != 0)	/* Function pointer	*/
XX		typecode = T_FPTR | T_PTR;
XX	    else {				/* Var or var * datum	*/
XX		typecode &= ~(T_SIGNED | T_UNSIGNED);
XX		if ((typecode & (T_SHORT | T_LONG)) != 0)
XX		    typecode &= ~T_INT;
XX	    }
XX	    if ((typecode & ~T_PTR) == 0) {
XX		cerror("#if sizeof() error, no type specified", NULLST);
XX		return (OP_FAIL);
XX	    }
XX	    /*
XX	     * Exactly one bit (and possibly T_PTR) may be set.
XX	     */
XX	    for (sizp = size_table; sizp->bits != 0; sizp++) {
XX		if ((typecode & ~T_PTR) == sizp->bits) {
XX		    evalue = ((typecode & T_PTR) != 0)
XX			? sizp->psize : sizp->size;
XX		    return (DIG);
XX		}
XX	    }					/* We shouldn't fail	*/
XX	    cierror("#if ... sizeof: bug, unknown type code 0x%x", typecode);
XX	    return (OP_FAIL);
XX	}
XX
XXnogood:	unget();
XX	cerror("#if ... sizeof() syntax error", NULLST);
XX	return (OP_FAIL);
XX}
XX
XXFILE_LOCAL int
XXbittest(value)
XX/*
XX * TRUE if value is zero or exactly one bit is set in value.
XX */
XX{
XX#if (4096 & ~(-4096)) == 0
XX	return ((value & ~(-value)) == 0);
XX#else
XX	/*
XX	 * Do it the hard way (for non 2's complement machines)
XX	 */
XX	return (value == 0 || value ^ (value - 1) == (value * 2 - 1));
XX#endif
XX}
XX
XXFILE_LOCAL int
XXevalnum(c)
XXregister int	c;
XX/*
XX * Expand number for #if lexical analysis.  Note: evalnum recognizes
XX * the unsigned suffix, but only returns a signed int value.
XX */
XX{
XX	register int	value;
XX	register int	base;
XX	register int	c1;
XX
XX	if (c != '0')
XX	    base = 10;
XX	else if ((c = cget()) == 'x' || c == 'X') {
XX		base = 16;
XX		c = cget();
XX	}
XX	else base = 8;
XX	value = 0;
XX	for (;;) {
XX	    c1 = c;
XX	    if (isascii(c) && isupper(c1))
XX		c1 = tolower(c1);
XX	    if (c1 >= 'a')
XX		c1 -= ('a' - 10);
XX	    else c1 -= '0';
XX	    if (c1 < 0 || c1 >= base)
XX		break;
XX	    value *= base;
XX	    value += c1;
XX	    c = cget();
XX	}
XX	if (c == 'u' || c == 'U')	/* Unsigned nonsense		*/
XX	    c = cget();
XX	unget();
XX	return (value);
XX}
XX
XXFILE_LOCAL int
XXevalchar(skip)
XXint		skip;		/* TRUE if short-circuit evaluation	*/
XX/*
XX * Get a character constant
XX */
XX{
XX	register int	c;
XX	register int	value;
XX	register int	count;
XX
XX	instring = TRUE;
XX	if ((c = cget()) == '\\') {
XX	    switch ((c = cget())) {
XX	    case 'a':				/* New in Standard	*/
XX#if ('a' == '\a' || '\a' == ALERT)
XX		value = ALERT;			/* Use predefined value	*/
XX#else
XX		value = '\a';			/* Use compiler's value	*/
XX#endif
XX		break;
XX
XX	    case 'b':
XX		value = '\b';
XX		break;
XX
XX	    case 'f':
XX		value = '\f';
XX		break;
XX
XX	    case 'n':
XX		value = '\n';
XX		break;
XX
XX	    case 'r':
XX		value = '\r';
XX		break;
XX
XX	    case 't':
XX		value = '\t';
XX		break;
XX
XX	    case 'v':				/* New in Standard	*/
XX#if ('v' == '\v' || '\v' == VT)
XX		value = VT;			/* Use predefined value	*/
XX#else
XX		value = '\v';			/* Use compiler's value	*/
XX#endif
XX		break;
XX
XX	    case 'x':				/* '\xFF'		*/
XX		count = 3;
XX		value = 0;
XX		while ((((c = get()) >= '0' && c <= '9')
XX		     || (c >= 'a' && c <= 'f')
XX		     || (c >= 'A' && c <= 'F'))
XX		    && (--count >= 0)) {
XX			value *= 16;
XX			value += (c <= '9') ? (c - '0') : ((c & 0xF) + 9);
XX		}
XX		unget();
XX		break;
XX
XX	    default:
XX		if (c >= '0' && c <= '7') {
XX		    count = 3;
XX		    value = 0;
XX		    while (c >= '0' && c <= '7' && --count >= 0) {
XX			value *= 8;
XX			value += (c - '0');
XX			c = get();
XX		    }
XX		    unget();
XX		}
XX		else value = c;
XX		break;
XX	    }
XX	}
XX	else if (c == '\'')
XX	    value = 0;
XX	else value = c;
XX	/*
XX	 * We warn on multi-byte constants and try to hack
XX	 * (big|little)endian machines.
XX	 */
XX#if BIG_ENDIAN
XX	count = 0;
XX#endif
XX	while ((c = get()) != '\'' && c != EOF_CHAR && c != '\n') {
XX	    if (!skip)
XX		ciwarn("multi-byte constant '%c' isn't portable", c);
XX#if BIG_ENDIAN
XX	    count += BITS_CHAR;
XX	    value += (c << count);
XX#else
XX	    value <<= BITS_CHAR;
XX	    value += c;
XX#endif
XX	}
XX	instring = FALSE;
XX	return (value);
XX}
XX
XXFILE_LOCAL int *
XXevaleval(valp, op, skip)
XXregister int	*valp;
XXint		op;
XXint		skip;		/* TRUE if short-circuit evaluation	*/
XX/*
XX * Apply the argument operator to the data on the value stack.
XX * One or two values are popped from the value stack and the result
XX * is pushed onto the value stack.
XX *
XX * OP_COL is a special case.
XX *
XX * evaleval() returns the new pointer to the top of the value stack.
XX */
XX{
XX	register int	v1, v2;
XX
XX	if (isbinary(op))
XX	    v2 = *--valp;
XX	v1 = *--valp;
XX#ifdef	DEBUG_EVAL
XX	printf("%s op %s", (isbinary(op)) ? "binary" : "unary",
XX	    opname[op]);
XX	if (isbinary(op))
XX	    printf(", v2 = %d.", v2);
XX	printf(", v1 = %d.\n", v1);
XX#endif
XX	switch (op) {
XX	case OP_EOE:
XX	     break;
XX
XX	case OP_ADD:
XX	    v1 += v2;
XX	    break;
XX
XX	case OP_SUB:
XX	    v1 -= v2;
XX	    break;
XX
XX	case OP_MUL:
XX	    v1 *= v2;
XX	    break;
XX
XX	case OP_DIV:
XX	case OP_MOD:
XX	    if (v2 == 0) {
XX		if (!skip) {
XX		    cwarn("%s by zero in #if, zero result assumed",
XX			(op == OP_DIV) ? "divide" : "mod");
XX		}
XX		v1 = 0;
XX	    }
XX	    else if (op == OP_DIV)
XX		v1 /= v2;
XX	    else
XX		v1 %= v2;
XX	    break;
XX
XX	case OP_ASL:
XX	    v1 <<= v2;
XX	    break;
XX
XX	case OP_ASR:
XX	    v1 >>= v2;
XX	    break;
XX
XX	case OP_AND:
XX	    v1 &= v2;
XX	    break;
XX
XX	case OP_OR:
XX	    v1 |= v2;
XX	    break;
XX
XX	case OP_XOR:
XX	    v1 ^= v2;
XX	    break;
XX
XX	case OP_EQ:
XX	    v1 = (v1 == v2);
XX	    break;
XX
XX	case OP_NE:
XX	    v1 = (v1 != v2);
XX	    break;
XX
XX	case OP_LT:
XX	    v1 = (v1 < v2);
XX	    break;
XX
XX	case OP_LE:
XX	    v1 = (v1 <= v2);
XX	    break;
XX
XX	case OP_GE:
XX	    v1 = (v1 >= v2);
XX	    break;
XX
XX	case OP_GT:
XX	    v1 = (v1 > v2);
XX	    break;
XX
XX	case OP_ANA:
XX	    v1 = (v1 && v2);
XX	    break;
XX
XX	case OP_ORO:
XX	    v1 = (v1 || v2);
XX	    break;
XX
XX	case OP_COL:
XX	    /*
XX	     * v1 has the "true" value, v2 the "false" value.
XX	     * The top of the value stack has the test.
XX	     */
XX	    v1 = (*--valp) ? v1 : v2;
XX	    break;
XX
XX	case OP_NEG:
XX	    v1 = (-v1);
XX	    break;
XX
XX	case OP_PLU:
XX	    break;
XX
XX	case OP_COM:
XX	    v1 = ~v1;
XX	    break;
XX
XX	case OP_NOT:
XX	    v1 = !v1;
XX	    break;
XX
XX	default:
XX	    cierror("#if bug, operand = %d.", op);
XX	    v1 = 0;
XX	}
XX	*valp++ = v1;
XX	return (valp);
XX}
XX
XX#ifdef	DEBUG_EVAL
XXdumpstack(opstack, opp, value, valp)
XXOPTAB		opstack[NEXP];	/* Operand stack		*/
XXregister OPTAB	*opp;		/* Operator stack		*/
XXint		value[NEXP];	/* Value stack			*/
XXregister int	*valp;		/* -> value vector		*/
XX{
XX	printf("index op prec skip name -- op stack at %s", infile->bptr);
XX	while (opp > opstack) {
XX	    printf(" [%2d] %2d  %03o    %d %s\n", opp - opstack,
XX		opp->op, opp->prec, opp->skip, opname[opp->op]);
XX	    opp--;
XX	}
XX	while (--valp >= value) {
XX	    printf("value[%d] = %d\n", (valp - value), *valp);
XX	}
XX}
XX#endif
XX
XEND-of-cpp5.c
Xecho x - cpp6.c
Xsed 's/^X//' >cpp6.c << 'END-of-cpp6.c'
XX/*
XX *			    C P P 6 . C
XX *		S u p p o r t   R o u t i n e s
XX *
XX * Edit History
XX * 25-May-84 MM		Added 8-bit support to type table.
XX * 30-May-84 ARF	sharp() should output filename in quotes
XX * 02-Aug-84 MM		Newline and #line hacking.  sharp() now in cpp1.c
XX * 31-Aug-84 MM		USENET net.sources release
XX * 11-Sep-84 ado/MM	Keepcomments, also line number pathological
XX * 12-Sep-84 ado/MM	bug if comment changes to space and we unget later.
XX * 03-Oct-84 gkr/MM	Fixed scannumber bug for '.e' (as in struct.element).
XX * 04-Oct-84 MM		Added ungetstring() for token concatenation
XX * 08-Oct-84 MM		Yet another attack on number scanning
XX * 31-Oct-84 ado	Parameterized $ in identifiers
XX *  2-Nov-84 MM		Token concatenation is messier than I thought
XX *  6-Dec-84 MM		\<nl> is everywhere invisible.
XX */
XX
XX#include	<stdio.h>
XX#include	<ctype.h>
XX#include	"cppdef.h"
XX#include	"cpp.h"
XX
XX/*
XX * skipnl()	skips over input text to the end of the line.
XX * skipws()	skips over "whitespace" (spaces or tabs), but
XX *		not skip over the end of the line.  It skips over
XX *		TOK_SEP, however (though that shouldn't happen).
XX * scanid()	reads the next token (C identifier) into token[].
XX *		The caller has already read the first character of
XX *		the identifier.  Unlike macroid(), the token is
XX *		never expanded.
XX * macroid()	reads the next token (C identifier) into token[].
XX *		If it is a #defined macro, it is expanded, and
XX *		macroid() returns TRUE, otherwise, FALSE.
XX * catenate()	Does the dirty work of token concatenation, TRUE if it did.
XX * scanstring()	Reads a string from the input stream, calling
XX *		a user-supplied function for each character.
XX *		This function may be output() to write the
XX *		string to the output file, or save() to save
XX *		the string in the work buffer.
XX * scannumber()	Reads a C numeric constant from the input stream,
XX *		calling the user-supplied function for each
XX *		character.  (output() or save() as noted above.)
XX * save()	Save one character in the work[] buffer.
XX * savestring()	Saves a string in malloc() memory.
XX * getfile()	Initialize a new FILEINFO structure, called when
XX *		#include opens a new file, or a macro is to be
XX *		expanded.
XX * getmem()	Get a specified number of bytes from malloc memory.
XX * output()	Write one character to stdout (calling putchar) --
XX *		implemented as a function so its address may be
XX *		passed to scanstring() and scannumber().
XX * lookid()	Scans the next token (identifier) from the input
XX *		stream.  Looks for it in the #defined symbol table.
XX *		Returns a pointer to the definition, if found, or NULL
XX *		if not present.  The identifier is stored in token[].
XX * defnedel()	Define enter/delete subroutine.  Updates the
XX *		symbol table.
XX * get()	Read the next byte from the current input stream,
XX *		handling end of (macro/file) input and embedded
XX *		comments appropriately.  Note that the global
XX *		instring is -- essentially -- a parameter to get().
XX * cget()	Like get(), but skip over TOK_SEP.
XX * unget()	Push last gotten character back on the input stream.
XX * cerror(), cwarn(), cfatal(), cierror(), ciwarn()
XX *		These routines format an print messages to the user.
XX *		cerror & cwarn take a format and a single string argument.
XX *		cierror & ciwarn take a format and a single int (char) argument.
XX *		cfatal takes a format and a single string argument.
XX */
XX
XX/*
XX * This table must be rewritten for a non-Ascii machine.
XX *
XX * Note that several "non-visible" characters have special meaning:
XX * Hex 1D DEF_MAGIC -- a flag to prevent #define recursion.
XX * Hex 1E TOK_SEP   -- a delimiter for token concatenation
XX * Hex 1F COM_SEP   -- a zero-width whitespace for comment concatenation
XX */
XX#if TOK_SEP != 0x1E || COM_SEP != 0x1F || DEF_MAGIC != 0x1D
XX	<< error type table isn't correct >>
XX#endif
XX
XX#if OK_DOLLAR
XX#define	DOL	LET
XX#else
XX#define	DOL	000
XX#endif
XX
XXchar type[256] = {		/* Character type codes    Hex		*/
XX   END,   000,   000,   000,   000,   000,   000,   000, /* 00		*/
XX   000,   SPA,   000,   000,   000,   000,   000,   000, /* 08		*/
XX   000,   000,   000,   000,   000,   000,   000,   000, /* 10		*/
XX   000,   000,   000,   000,   000,   LET,   000,   SPA, /* 18		*/
XX   SPA,OP_NOT,   QUO,   000,   DOL,OP_MOD,OP_AND,   QUO, /* 20  !"#$%&'	*/
XXOP_LPA,OP_RPA,OP_MUL,OP_ADD,   000,OP_SUB,   DOT,OP_DIV, /* 28 ()*+,-./	*/
XX   DIG,   DIG,   DIG,   DIG,   DIG,   DIG,   DIG,   DIG, /* 30 01234567	*/
XX   DIG,   DIG,OP_COL,   000, OP_LT, OP_EQ, OP_GT,OP_QUE, /* 38 89:;<=>?	*/
XX   000,   LET,   LET,   LET,   LET,   LET,   LET,   LET, /* 40 @ABCDEFG	*/
XX   LET,   LET,   LET,   LET,   LET,   LET,   LET,   LET, /* 48 HIJKLMNO	*/
XX   LET,   LET,   LET,   LET,   LET,   LET,   LET,   LET, /* 50 PQRSTUVW	*/
XX   LET,   LET,   LET,   000,   BSH,   000,OP_XOR,   LET, /* 58 XYZ[\]^_	*/
XX   000,   LET,   LET,   LET,   LET,   LET,   LET,   LET, /* 60 `abcdefg	*/
XX   LET,   LET,   LET,   LET,   LET,   LET,   LET,   LET, /* 68 hijklmno	*/
XX   LET,   LET,   LET,   LET,   LET,   LET,   LET,   LET, /* 70 pqrstuvw	*/
XX   LET,   LET,   LET,   000, OP_OR,   000,OP_NOT,   000, /* 78 xyz{|}~	*/
XX   000,   000,   000,   000,   000,   000,   000,   000, /*   80 .. FF	*/
XX   000,   000,   000,   000,   000,   000,   000,   000, /*   80 .. FF	*/
XX   000,   000,   000,   000,   000,   000,   000,   000, /*   80 .. FF	*/
XX   000,   000,   000,   000,   000,   000,   000,   000, /*   80 .. FF	*/
XX   000,   000,   000,   000,   000,   000,   000,   000, /*   80 .. FF	*/
XX   000,   000,   000,   000,   000,   000,   000,   000, /*   80 .. FF	*/
XX   000,   000,   000,   000,   000,   000,   000,   000, /*   80 .. FF	*/
XX   000,   000,   000,   000,   000,   000,   000,   000, /*   80 .. FF	*/
XX};
XX
XXskipnl()
XX/*
XX * Skip to the end of the current input line.
XX */
XX{
XX	register int		c;
XX
XX	do {				/* Skip to newline	*/
XX	    c = get();
XX	} while (c != '\n' && c != EOF_CHAR);
XX}
XX
XXint
XXskipws()
XX/*
XX * Skip over whitespace
XX */
XX{
XX	register int		c;
XX
XX	do {				/* Skip whitespace	*/
XX	    c = get();
XX#if COMMENT_INVISIBLE
XX	} while (type[c] == SPA || c == COM_SEP);
XX#else
XX	} while (type[c] == SPA);
XX#endif
XX	return (c);
XX}
XX
XXscanid(c)
XXregister int	c;				/* First char of id	*/
XX/*
XX * Get the next token (an id) into the token buffer.
XX * Note: this code is duplicated in lookid().
XX * Change one, change both.
XX */
XX{
XX	register char	*bp;
XX
XX	if (c == DEF_MAGIC)			/* Eat the magic token	*/
XX	    c = get();				/* undefiner.		*/
XX	bp = token;
XX	do {
XX	    if (bp < &token[IDMAX])		/* token dim is IDMAX+1	*/
XX		*bp++ = c;
XX	    c = get();
XX	} while (type[c] == LET || type[c] == DIG);
XX	unget();
XX	*bp = EOS;
XX}
XX
XXint
XXmacroid(c)
XXregister int		c;
XX/*
XX * If c is a letter, scan the id.  if it's #defined, expand it and scan
XX * the next character and try again.
XX *
XX * Else, return the character.  If type[c] is a LET, the token is in token.
XX */
XX{
XX	register DEFBUF	*dp;
XX
XX	if (infile != NULL && infile->fp != NULL)
XX	    recursion = 0;
XX	while (type[c] == LET && (dp = lookid(c)) != NULL) {
XX	    expand(dp);
XX	    c = get();
XX	}
XX	return (c);
XX}
XX
XXint
XXcatenate()
XX/*
XX * A token was just read (via macroid).
XX * If the next character is TOK_SEP, concatenate the next token
XX * return TRUE -- which should recall macroid after refreshing
XX * macroid's argument.  If it is not TOK_SEP, unget() the character
XX * and return FALSE.
XX */
XX{
XX	register int		c;
XX	register char		*token1;
XX
XX#if OK_CONCAT
XX	if (get() != TOK_SEP) {			/* Token concatenation	*/
XX	    unget();
XX	    return (FALSE);
XX	}
XX	else {
XX	    token1 = savestring(token);		/* Save first token	*/
XX	    c = macroid(get());			/* Scan next token	*/
XX	    switch(type[c]) {			/* What was it?		*/
XX	    case LET:				/* An identifier, ...	*/
XX		if (strlen(token1) + strlen(token) >= NWORK)
XX		    cfatal("work buffer overflow doing %s #", token1);
XX		sprintf(work, "%s%s", token1, token);
XX		break;
XX
XX	    case DIG:				/* A digit string	*/
XX		strcpy(work, token1);
XX		workp = work + strlen(work);
XX		do {
XX		    save(c);
XX		} while ((c = get()) != TOK_SEP);
XX		/*
XX		 * The trailing TOK_SEP is no longer needed.
XX		 */
XX		save(EOS);
XX		break;
XX
XX	    default:				/* An error, ...	*/
XX		if (isprint(c))
XX		    cierror("Strange character '%c' after #", c);
XX		else
XX		    cierror("Strange character (%d.) after #", c);
XX		strcpy(work, token1);
XX		unget();
XX		break;
XX	    }
XX	    /*
XX	     * work has the concatenated token and token1 has
XX	     * the first token (no longer needed).  Unget the
XX	     * new (concatenated) token after freeing token1.
XX	     * Finally, setup to read the new token.
XX	     */
XX	    free(token1);			/* Free up memory	*/
XX	    ungetstring(work);			/* Unget the new thing,	*/
XX	    return (TRUE);
XX	}
XX#else
XX	return (FALSE);				/* Not supported	*/
XX#endif
XX}
XX
XXint
XXscanstring(delim, outfun)
XXregister int	delim;			/* ' or "			*/
XXint		(*outfun)();		/* Output function		*/
XX/*
XX * Scan off a string.  Warning if terminated by newline or EOF.
XX * outfun() outputs the character -- to a buffer if in a macro.
XX * TRUE if ok, FALSE if error.
XX */
XX{
XX	register int		c;
XX
XX	instring = TRUE;		/* Don't strip comments		*/
XX	(*outfun)(delim);
XX	while ((c = get()) != delim
XX	     && c != '\n'
XX	     && c != EOF_CHAR) {
XX	    (*outfun)(c);
XX	    if (c == '\\')
XX		(*outfun)(get());
XX	}
XX	instring = FALSE;
XX	if (c == delim) {
XX	    (*outfun)(c);
XX	    return (TRUE);
XX	}
XX	else {
XX	    cerror("Unterminated string", NULLST);
XX	    unget();
XX	    return (FALSE);
XX	}
XX}
XX
XXscannumber(c, outfun)
XXregister int	c;				/* First char of number	*/
XXregister int	(*outfun)();			/* Output/store func	*/
XX/*
XX * Process a number.  We know that c is from 0 to 9 or dot.
XX * Algorithm from Dave Conroy's Decus C.
XX */
XX{
XX	register int	radix;			/* 8, 10, or 16		*/
XX	int		expseen;		/* 'e' seen in floater	*/
XX	int		signseen;		/* '+' or '-' seen	*/
XX	int		octal89;		/* For bad octal test	*/
XX	int		dotflag;		/* TRUE if '.' was seen	*/
XX
XX	expseen = FALSE;			/* No exponent seen yet	*/
XX	signseen = TRUE;			/* No +/- allowed yet	*/
XX	octal89 = FALSE;			/* No bad octal yet	*/
XX	radix = 10;				/* Assume decimal	*/
XX	if ((dotflag = (c == '.')) != FALSE) {	/* . something?		*/
XX	    (*outfun)('.');			/* Always out the dot	*/
XX	    if (type[(c = get())] != DIG) {	/* If not a float numb,	*/
XX		unget();			/* Rescan strange char	*/
XX		return;				/* All done for now	*/
XX	    }
XX	}					/* End of float test	*/
XX	else if (c == '0') {			/* Octal or hex?	*/
XX	    (*outfun)(c);			/* Stuff initial zero	*/
XX	    radix = 8;				/* Assume it's octal	*/
XX	    c = get();				/* Look for an 'x'	*/
XX	    if (c == 'x' || c == 'X') {		/* Did we get one?	*/
XX		radix = 16;			/* Remember new radix	*/
XX		(*outfun)(c);			/* Stuff the 'x'	*/
XX		c = get();			/* Get next character	*/
XX	    }
XX	}
XX	for (;;) {				/* Process curr. char.	*/
XX	    /*
XX	     * Note that this algorithm accepts "012e4" and "03.4"
XX	     * as legitimate floating-point numbers.
XX	     */
XX	    if (radix != 16 && (c == 'e' || c == 'E')) {
XX		if (expseen)			/* Already saw 'E'?	*/
XX		    break;			/* Exit loop, bad nbr.	*/
XX		expseen = TRUE;			/* Set exponent seen	*/
XX		signseen = FALSE;		/* We can read '+' now	*/
XX		radix = 10;			/* Decimal exponent	*/
XX	    }
XX	    else if (radix != 16 && c == '.') {
XX		if (dotflag)			/* Saw dot already?	*/
XX		    break;			/* Exit loop, two dots	*/
XX		dotflag = TRUE;			/* Remember the dot	*/
XX		radix = 10;			/* Decimal fraction	*/
XX	    }
XX	    else if (c == '+' || c == '-') {	/* 1.0e+10		*/
XX		if (signseen)			/* Sign in wrong place?	*/
XX		    break;			/* Exit loop, not nbr.	*/
XX		/* signseen = TRUE; */		/* Remember we saw it	*/
XX	    }
XX	    else {				/* Check the digit	*/
XX		switch (c) {
XX		case '8': case '9':		/* Sometimes wrong	*/
XX		    octal89 = TRUE;		/* Do check later	*/
XX		case '0': case '1': case '2': case '3':
XX		case '4': case '5': case '6': case '7':
XX		    break;			/* Always ok		*/
XX
XX		case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':
XX		case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':
XX		    if (radix == 16)		/* Alpha's are ok only 	*/
XX			break;			/* if reading hex.	*/
XX		default:			/* At number end	*/
XX		    goto done;			/* Break from for loop	*/
XX		}				/* End of switch	*/
XX	    }					/* End general case	*/
XX	    (*outfun)(c);			/* Accept the character	*/
XX	    signseen = TRUE;			/* Don't read sign now	*/
XX	    c = get();				/* Read another char	*/
XX	}					/* End of scan loop	*/
XX	/*
XX	 * When we break out of the scan loop, c contains the first
XX	 * character (maybe) not in the number.  If the number is an
XX	 * integer, allow a trailing 'L' for long and/or a trailing 'U'
XX	 * for unsigned.  If not those, push the trailing character back
XX	 * on the input stream.  Floating point numbers accept a trailing
XX	 * 'L' for "long double".
XX	 */
XXdone:	if (dotflag || expseen) {		/* Floating point?	*/
XX	    if (c == 'l' || c == 'L') {
XX		(*outfun)(c);
XX		c = get();			/* Ungotten later	*/
XX	    }
XX	}
XX	else {					/* Else it's an integer	*/
XX	    /*
XX	     * We know that dotflag and expseen are both zero, now:
XX	     * dotflag signals "saw 'L'", and
XX	     * expseen signals "saw 'U'".
XX	     */
XX	    for (;;) {
XX		switch (c) {
XX		case 'l':
XX		case 'L':
XX		    if (dotflag)
XX			goto nomore;
XX		    dotflag = TRUE;
XX		    break;
XX
XX		case 'u':
XX		case 'U':
XX		    if (expseen)
XX			goto nomore;
XX		    expseen = TRUE;
XX		    break;
XX
XX		default:
XX		    goto nomore;
XX		}
XX		(*outfun)(c);			/* Got 'L' or 'U'.	*/
XX		c = get();			/* Look at next, too.	*/
XX	    }
XX	}
XXnomore:	unget();				/* Not part of a number	*/
XX	if (octal89 && radix == 8)
XX	    cwarn("Illegal digit in octal number", NULLST);
XX}
XX
XXsave(c)
XXregister int	c;
XX{
XX	if (workp >= &work[NWORK])
XX	    cfatal("Work buffer overflow", NULLST);
XX	else *workp++ = c;
XX}
XX
XXchar *
XXsavestring(text)
XXchar		*text;
XX/*
XX * Store a string into free memory.
XX */
XX{
XX	register char	*result;
XX
XX	result = getmem(strlen(text) + 1);
XX	strcpy(result, text);
XX	return (result);
XX}
XX
XXFILEINFO	*
XXgetfile(bufsize, name)
XXint		bufsize;		/* Line or define buffer size	*/
XXchar		*name;			/* File or macro name string	*/
XX/*
XX * Common FILEINFO buffer initialization for a new file or macro.
XX */
XX{
XX	register FILEINFO	*file;
XX	register int		size;
XX
XX	size = strlen(name);			/* File/macro name	*/
XX	file = (FILEINFO *) getmem(sizeof (FILEINFO) + bufsize + size);
XX	file->parent = infile;			/* Chain files together	*/
XX	file->fp = NULL;			/* No file yet		*/
XX	file->filename = savestring(name);	/* Save file/macro name	*/
XX	file->progname = NULL;			/* No #line seen yet	*/
XX	file->unrecur = 0;			/* No macro fixup	*/
XX	file->bptr = file->buffer;		/* Initialize line ptr	*/
XX	file->buffer[0] = EOS;			/* Force first read	*/
XX	file->line = 0;				/* (Not used just yet)	*/
XX	if (infile != NULL)			/* If #include file	*/
XX	    infile->line = line;		/* Save current line	*/
XX	infile = file;				/* New current file	*/
XX	line = 1;				/* Note first line	*/
XX	return (file);				/* All done.		*/
XX}
XX
XXchar *
XXgetmem(size)
XXint		size;
XX/*
XX * Get a block of free memory.
XX */
XX{
XX	register char	*result;
XX	extern char	*malloc();
XX
XX	if ((result = malloc((unsigned) size)) == NULL)
XX	    cfatal("Out of memory", NULLST);
XX	return (result);
XX}
XX
XX/*
XX *			C P P   S y m b o l   T a b l e s
XX */
XX
XX/*
XX * SBSIZE defines the number of hash-table slots for the symbol table.
XX * It must be a power of 2.
XX */
XX#ifndef	SBSIZE
XX#define	SBSIZE	64
XX#endif
XX#define	SBMASK	(SBSIZE - 1)
XX#if (SBSIZE ^ SBMASK) != ((SBSIZE * 2) - 1)
XX	<< error, SBSIZE must be a power of 2 >>
XX#endif
XX
XXstatic DEFBUF	*symtab[SBSIZE];	/* Symbol table queue headers	*/
XX
XXDEFBUF *
XXlookid(c)
XXint	c;				/* First character of token	*/
XX/*
XX * Look for the next token in the symbol table.  Returns token in "token".
XX * If found, returns the table pointer;  Else returns NULL.
XX */
XX{
XX	register int		nhash;
XX	register DEFBUF		*dp;
XX	register char		*np;
XX	int			temp;
XX	int			isrecurse;	/* For #define foo foo	*/
XX
XX	np = token;
XX	nhash = 0;
XX	if ((isrecurse = (c == DEF_MAGIC)))	/* If recursive macro	*/
XX	    c = get();				/* hack, skip DEF_MAGIC	*/
XX	do {
XX	    if (np < &token[IDMAX]) {		/* token dim is IDMAX+1	*/
XX		*np++ = c;			/* Store token byte	*/
XX		nhash += c;			/* Update hash value	*/
XX	    }
XX	    c = get();				/* And get another byte	*/
XX	} while (type[c] == LET || type[c] == DIG);
XX	unget();				/* Rescan terminator	*/
XX	*np = EOS;				/* Terminate token	*/
XX	if (isrecurse)				/* Recursive definition	*/
XX	    return (NULL);			/* undefined just now	*/
XX	nhash += (np - token);			/* Fix hash value	*/
XX	dp = symtab[nhash & SBMASK];		/* Starting bucket	*/
XX	while (dp != (DEFBUF *) NULL) {		/* Search symbol table	*/
XX	    if (dp->hash == nhash		/* Fast precheck	*/
XX	     && (temp = strcmp(dp->name, token)) >= 0)
XX		break;
XX	    dp = dp->link;			/* Nope, try next one	*/
XX	}
XX	return ((temp == 0) ? dp : NULL);
XX}
XX
XXDEFBUF *
XXdefendel(name, delete)
XXchar		*name;
XXint		delete;			/* TRUE to delete a symbol	*/
XX/*
XX * Enter this name in the lookup table (delete = FALSE)
XX * or delete this name (delete = TRUE).
XX * Returns a pointer to the define block (delete = FALSE)
XX * Returns NULL if the symbol wasn't defined (delete = TRUE).
XX */
XX{
XX	register DEFBUF		*dp;
XX	register DEFBUF		**prevp;
XX	register char		*np;
XX	int			nhash;
XX	int			temp;
XX	int			size;
XX
XX	for (nhash = 0, np = name; *np != EOS;)
XX	    nhash += *np++;
XX	size = (np - name);
XX	nhash += size;
XX	prevp = &symtab[nhash & SBMASK];
XX	while ((dp = *prevp) != (DEFBUF *) NULL) {
XX	    if (dp->hash == nhash
XX	     && (temp = strcmp(dp->name, name)) >= 0) {
XX		if (temp > 0)
XX		    dp = NULL;			/* Not found		*/
XX		else {
XX		    *prevp = dp->link;		/* Found, unlink and	*/
XX		    if (dp->repl != NULL)	/* Free the replacement	*/
XX			free(dp->repl);		/* if any, and then	*/
XX		    free((char *) dp);		/* Free the symbol	*/
XX		}
XX		break;
XX	    }
XX	    prevp = &dp->link;
XX	}
XX	if (!delete) {
XX	    dp = (DEFBUF *) getmem(sizeof (DEFBUF) + size);
XX	    dp->link = *prevp;
XX	    *prevp = dp;
XX	    dp->hash = nhash;
XX	    dp->repl = NULL;
XX	    dp->nargs = 0;
XX	    strcpy(dp->name, name);
XX	}
XX	return (dp);
XX}
XX
XX#if DEBUG
XX
XXdumpdef(why)
XXchar		*why;
XX{
XX	register DEFBUF		*dp;
XX	register DEFBUF		**syp;
XX
XX	printf("CPP symbol table dump %s\n", why);
XX	for (syp = symtab; syp < &symtab[SBSIZE]; syp++) {
XX	    if ((dp = *syp) != (DEFBUF *) NULL) {
XX		printf("symtab[%d]\n", (syp - symtab));
XX		do {
XX		    dumpadef((char *) NULL, dp);
XX		} while ((dp = dp->link) != (DEFBUF *) NULL);
XX	    }
XX	}
XX}
XX
XXdumpadef(why, dp)
XXchar		*why;			/* Notation			*/
XXregister DEFBUF	*dp;
XX{
XX	register char		*cp;
XX	register int		c;
XX
XX	printf(" \"%s\" [%d]", dp->name, dp->nargs);
XX	if (why != NULL)
XX	    printf(" (%s)", why);
XX	if (dp->repl != NULL) {
XX	    printf(" => ");
XX	    for (cp = dp->repl; (c = *cp++ & 0xFF) != EOS;) {
XX		if (c >= MAC_PARM && c <= (MAC_PARM + PAR_MAC))
XX		    printf("<%d>", c - MAC_PARM);
XX		else if (isprint(c) || c == '\n' || c == '\t')
XX		    putchar(c);
XX		else if (c < ' ')
XX		    printf("<^%c>", c + '@');
XX		else
XX		    printf("<\\0%o>", c);
XX	    }
XX	}
XX	else {
XX	    printf(", no replacement.");
XX	}
XX	putchar('\n');
XX}
XX#endif
XX
XX/*
XX *			G E T
XX */
XX
XXint
XXget()
XX/*
XX * Return the next character from a macro or the current file.
XX * Handle end of file from #include files.
XX */
XX{
XX	register int		c;
XX	register FILEINFO	*file;
XX	register int		popped;		/* Recursion fixup	*/
XX
XX	popped = 0;
XXget_from_file:
XX	if ((file = infile) == NULL)
XX	    return (EOF_CHAR);
XXnewline:
XX#if 0
XX	printf("get(%s), recursion %d, line %d, bptr = %d, buffer \"%s\"\n",
XX	    file->filename, recursion, line,
XX	    file->bptr - file->buffer, file->buffer);
XX#endif
XX	/*
XX	 * Read a character from the current input line or macro.
XX	 * At EOS, either finish the current macro (freeing temp.
XX	 * storage) or read another line from the current input file.
XX	 * At EOF, exit the current file (#include) or, at EOF from
XX	 * the cpp input file, return EOF_CHAR to finish processing.
XX	 */
XX	if ((c = *file->bptr++ & 0xFF) == EOS) {
XX	    /*
XX	     * Nothing in current line or macro.  Get next line (if
XX	     * input from a file), or do end of file/macro processing.
XX	     * In the latter case, jump back to restart from the top.
XX	     */
XX	    if (file->fp == NULL) {		/* NULL if macro	*/
XX		popped++;
XX		recursion -= file->unrecur;
XX		if (recursion < 0)
XX		    recursion = 0;
XX		infile = file->parent;		/* Unwind file chain	*/
XX	    }
XX	    else {				/* Else get from a file	*/
XX		if ((file->bptr = fgets(file->buffer, NBUFF, file->fp))
XX			!= NULL) {
XX#if DEBUG
XX		    if (debug > 1) {		/* Dump it to stdout	*/
XX			printf("\n#line %d (%s), %s",
XX			    line, file->filename, file->buffer);
XX		    }
XX#endif
XX		    goto newline;		/* process the line	*/
XX		}
XX		else {
XX		    fclose(file->fp);		/* Close finished file	*/
XX		    if ((infile = file->parent) != NULL) {
XX			/*
XX			 * There is an "ungotten" newline in the current
XX			 * infile buffer (set there by doinclude() in
XX			 * cpp1.c).  Thus, we know that the mainline code
XX			 * is skipping over blank lines and will do a
XX			 * #line at its convenience.
XX			 */
XX			wrongline = TRUE;	/* Need a #line now	*/
XX		    }
XX		}
XX	    }
XX	    /*
XX	     * Free up space used by the (finished) file or macro and
XX	     * restart input from the parent file/macro, if any.
XX	     */
XX	    free(file->filename);		/* Free name and	*/
XX	    if (file->progname != NULL)		/* if a #line was seen,	*/
XX		free(file->progname);		/* free it, too.	*/
XX	    free((char *) file);		/* Free file space	*/
XX	    if (infile == NULL)			/* If at end of file	*/
XX		return (EOF_CHAR);		/* Return end of file	*/
XX	    line = infile->line; 		/* Reset line number	*/
XX	    goto get_from_file;			/* Get from the top.	*/
XX	}
XX	/*
XX	 * Common processing for the new character.
XX	 */
XX	if (c == DEF_MAGIC && file->fp != NULL)	/* Don't allow delete	*/
XX	    goto newline;			/* from a file		*/
XX	if (file->parent != NULL) {		/* Macro or #include	*/
XX	    if (popped != 0)
XX		file->parent->unrecur += popped;
XX	    else {
XX		recursion -= file->parent->unrecur;
XX		if (recursion < 0)
XX		    recursion = 0;
XX		file->parent->unrecur = 0;
XX	    }
XX	}
XX	if (c == '\n')				/* Maintain current	*/
XX	    ++line;				/* line counter		*/
XX	if (instring)				/* Strings just return	*/
XX	    return (c);				/* the character.	*/
XX	else if (c == '/') {			/* Comment?		*/
XX	    instring = TRUE;			/* So get() won't loop	*/
XX	    if ((c = get()) != '*') {		/* Next byte '*'?	*/
XX		instring = FALSE;		/* Nope, no comment	*/
XX		unget();			/* Push the char. back	*/
XX		return ('/');			/* Return the slash	*/
XX	    }
XX	    if (keepcomments) {			/* If writing comments	*/
XX		putchar('/');			/* Write out the	*/
XX		putchar('*');			/*   initializer	*/
XX	    }
XX	    for (;;) {				/* Eat a comment	*/
XX		c = get();
XXtest:		if (keepcomments && c != EOF_CHAR)
XX		    cput(c);
XX		switch (c) {
XX		case EOF_CHAR:
XX		    cerror("EOF in comment", NULLST);
XX		    return (EOF_CHAR);
XX
XX		case '/':
XX		    if ((c = get()) != '*')	/* Don't let comments	*/
XX			goto test;		/* Nest.		*/
XX#ifdef VERBOSE
XX		    cwarn("Nested comments", NULLST);
XX#endif
XX						/* Fall into * stuff	*/
XX		case '*':
XX		    if ((c = get()) != '/')	/* If comment doesn't	*/
XX			goto test;		/* end, look at next	*/
XX		    instring = FALSE;		/* End of comment,	*/
XX		    if (keepcomments) {		/* Put out the comment	*/
XX			cput(c);		/* terminator, too	*/
XX		    }
XX		    /*
XX		     * A comment is syntactically "whitespace" --
XX		     * however, there are certain strange sequences
XX		     * such as
XX		     *		#define foo(x)	(something)
XX		     *			foo|* comment *|(123)
XX		     *       these are '/' ^           ^
XX		     * where just returning space (or COM_SEP) will cause
XX		     * problems.  This can be "fixed" by overwriting the
XX		     * '/' in the input line buffer with ' ' (or COM_SEP)
XX		     * but that may mess up an error message.
XX		     * So, we peek ahead -- if the next character is
XX		     * "whitespace" we just get another character, if not,
XX		     * we modify the buffer.  All in the name of purity.
XX		     */
XX		    if (*file->bptr == '\n'
XX		     || type[*file->bptr & 0xFF] == SPA)
XX			goto newline;
XX#if COMMENT_INVISIBLE
XX		    /*
XX		     * Return magic (old-fashioned) syntactic space.
XX		     */
XX		    return ((file->bptr[-1] = COM_SEP));
XX#else
XX		    return ((file->bptr[-1] = ' '));
XX#endif
XX
XX		case '\n':			/* we'll need a #line	*/
XX		    if (!keepcomments)
XX			wrongline = TRUE;	/* later...		*/
XX		default:			/* Anything else is	*/
XX		    break;			/* Just a character	*/
XX		}				/* End switch		*/
XX	    }					/* End comment loop	*/
XX	}					/* End if in comment	*/
XX	else if (!inmacro && c == '\\') {	/* If backslash, peek 	*/
XX	    if ((c = get()) == '\n') {		/* for a <nl>.  If so,	*/
XX		wrongline = TRUE;
XX		goto newline;
XX	    }
XX	    else {				/* Backslash anything	*/
XX		unget();			/* Get it later		*/
XX		return ('\\');			/* Return the backslash	*/
XX	    }
XX	}
XX	else if (c == '\f' || c == VT)		/* Form Feed, Vertical	*/
XX	    c = ' ';				/* Tab are whitespace	*/
XX	return (c);				/* Just return the char	*/
XX}
XX
XXunget()
XX/*
XX * Backup the pointer to reread the last character.  Fatal error
XX * (code bug) if we backup too far.  unget() may be called,
XX * without problems, at end of file.  Only one character may
XX * be ungotten.  If you need to unget more, call ungetstring().
XX */
XX{
XX	register FILEINFO	*file;
XX
XX	if ((file = infile) == NULL)
XX	    return;			/* Unget after EOF		*/
XX	if (--file->bptr < file->buffer)
XX	    cfatal("Too much pushback", NULLST);
XX	if (*file->bptr == '\n')	/* Ungetting a newline?		*/
XX	    --line;			/* Unget the line number, too	*/
XX}
XX
XXungetstring(text)
XXchar		*text;
XX/*
XX * Push a string back on the input stream.  This is done by treating
XX * the text as if it were a macro.
XX */
XX{
XX	register FILEINFO	*file;
XX	extern FILEINFO		*getfile();
XX
XX	file = getfile(strlen(text) + 1, "");
XX	strcpy(file->buffer, text);
XX}
XX
XXint
XXcget()
XX/*
XX * Get one character, absorb "funny space" after comments or
XX * token concatenation
XX */
XX{
XX	register int	c;
XX
XX	do {
XX	    c = get();
XX#if COMMENT_INVISIBLE
XX	} while (c == TOK_SEP || c == COM_SEP);
XX#else
XX	} while (c == TOK_SEP);
XX#endif
XX	return (c);
XX}
XX
XX/*
XX * Error messages and other hacks.  The first byte of severity
XX * is 'S' for string arguments and 'I' for int arguments.  This
XX * is needed for portability with machines that have int's that
XX * are shorter than  char *'s.
XX */
XX
XXstatic
XXdomsg(severity, format, arg)
XXchar		*severity;		/* "Error", "Warning", "Fatal"	*/
XXchar		*format;		/* Format for the error message	*/
XXchar		*arg;			/* Something for the message	*/
XX/*
XX * Print filenames, macro names, and line numbers for error messages.
XX */
XX{
XX	register char		*tp;
XX	register FILEINFO	*file;
XX
XX	fprintf(stderr, "%sline %d, %s: ", MSG_PREFIX, line, &severity[1]);
XX	if (*severity == 'S')
XX	    fprintf(stderr, format, arg);
XX	else
XX	    fprintf(stderr, format, (int) arg);
XX	putc('\n', stderr);
XX	if ((file = infile) == NULL)
XX	    return;				/* At end of file	*/
XX	if (file->fp != NULL) {
XX	    tp = file->buffer;			/* Print current file	*/
XX	    fprintf(stderr, "%s", tp);		/* name, making sure	*/
XX	    if (tp[strlen(tp) - 1] != '\n')	/* there's a newline	*/
XX		putc('\n', stderr);
XX	}
XX	while ((file = file->parent) != NULL) {	/* Print #includes, too	*/
XX	    if (file->fp == NULL)
XX		fprintf(stderr, "from macro %s\n", file->filename);
XX	    else {
XX		tp = file->buffer;
XX		fprintf(stderr, "from file %s, line %d:\n%s",
XX		    (file->progname != NULL)
XX			? file->progname : file->filename,
XX		    file->line, tp);
XX		if (tp[strlen(tp) - 1] != '\n')
XX		    putc('\n', stderr);
XX	    }
XX	}
XX}
XX
XXcerror(format, sarg)
XXchar		*format;
XXchar		*sarg;		/* Single string argument		*/
XX/*
XX * Print a normal error message, string argument.
XX */
XX{
XX	domsg("SError", format, sarg);
XX	errors++;
XX}
XX
XXcierror(format, narg)
XXchar		*format;
XXint		narg;		/* Single numeric argument		*/
XX/*
XX * Print a normal error message, numeric argument.
XX */
XX{
XX	domsg("IError", format, (char *) narg);
XX	errors++;
XX}
XX
XXcfatal(format, sarg)
XXchar		*format;
XXchar		*sarg;			/* Single string argument	*/
XX/*
XX * A real disaster
XX */
XX{
XX	domsg("SFatal error", format, sarg);
XX	exit(IO_ERROR);
XX}
XX
XXcwarn(format, sarg)
XXchar		*format;
XXchar		*sarg;			/* Single string argument	*/
XX/*
XX * A non-fatal error, string argument.
XX */
XX{
XX	domsg("SWarning", format, sarg);
XX}
XX
XXciwarn(format, narg)
XXchar		*format;
XXint		narg;			/* Single numeric argument	*/
XX/*
XX * A non-fatal error, numeric argument.
XX */
XX{
XX	domsg("IWarning", format, (char *) narg);
XX}
XX
XX
XX
XEND-of-cpp6.c
Xexit
X
END_OF_FILE
if test 51837 -ne `wc -c <'sys/unix/cpp3.shr'`; then
    echo shar: \"'sys/unix/cpp3.shr'\" unpacked with wrong size!
fi
# end of 'sys/unix/cpp3.shr'
fi
echo shar: End of archive 8 \(of 108\).
cp /dev/null ark8isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \
21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \
41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 \
61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 \
81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 \
101 102 103 104 105 106 107 108 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 108 archives.
    echo "Now execute 'rebuild.sh'"
    rm -f ark10[0-8]isdone ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
