Path: uunet!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v16i053:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Part45/108
Message-ID: <4347@master.CNA.TEK.COM>
Date: 30 Jan 93 01:13:52 GMT
Sender: news@master.CNA.TEK.COM
Lines: 1770
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1602

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 16, Issue 53
Archive-name: nethack31/Part45
Supersedes: nethack3p9: Volume 10, Issue 46-102
Environment: Amiga, Atari, Mac, MS-DOS, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 45 (of 108)."
# Contents:  src/muse.c sys/amiga/Install.ami
# Wrapped by billr@saab on Wed Jan 27 16:09:04 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'src/muse.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/muse.c'\"
else
echo shar: Extracting \"'src/muse.c'\" \(37553 characters\)
sed "s/^X//" >'src/muse.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)muse.c	3.1	93/01/03	*/
X/* Monster item usage routine.  Copyright (C) 1990 by Ken Arromdee */
X/* NetHack may be freely redistributed.  See license for details.  */
X
X#include "hack.h"
X
X#ifdef MUSE
X
Xextern int monstr[];
X
Xboolean m_using = FALSE;
X
X/* Let monsters use magic items.  Arbitrary assumptions: Monsters only use
X * scrolls when they can see, monsters know when wands have 0 charges, monsters
X * cannot recognize if items are cursed are not, monsters which are confused
X * don't know not to read scrolls, etc....
X */
X
Xstatic int FDECL(precheck, (struct monst *,struct obj *));
Xstatic void FDECL(mzapmsg, (struct monst *,struct obj *,BOOLEAN_P));
Xstatic void FDECL(mreadmsg, (struct monst *,struct obj *));
Xstatic void FDECL(mquaffmsg, (struct monst *,struct obj *));
Xstatic int FDECL(mbhitm, (struct monst *,struct obj *));
Xstatic void FDECL(mbhit,
X	(struct monst *,int,int FDECL((*),(MONST_P,OBJ_P)),
X	int FDECL((*),(OBJ_P,OBJ_P)),struct obj *));
Xstatic void FDECL(you_aggravate, (struct monst *));
X
Xstatic struct musable {
X	struct obj *offensive;
X	struct obj *defensive;
X	struct obj *misc;
X	int has_offense, has_defense, has_misc;
X	/* =0, no capability; otherwise, different numbers.
X	 * If it's an object, the object is also set (it's 0 otherwise).
X	 */
X} m;
Xstatic int trapx, trapy;
Xstatic boolean zap_oseen;
X	/* for wands which use mbhitm and are zapped at players.  We usually
X	 * want an oseen local to the function, but this is impossible since the
X	 * function mbhitm has to be compatible with the normal zap routines,
X	 * and those routines don't remember who zapped the wand.
X	 */
X
X/* Any preliminary checks which may result in the monster being unable to use
X * the item.  Returns 0 if nothing happened, 2 if the monster can't do anything
X * (i.e. it teleported) and 1 if it's dead.
X */
Xstatic int
Xprecheck(mon, obj)
Xstruct monst *mon;
Xstruct obj *obj;
X{
X	boolean vis = cansee(mon->mx, mon->my);
X
X	if (!obj) return 0;
X	if (obj->oclass == POTION_CLASS) {
X	    coord cc;
X	    static const char *empty = "The potion turns out to be empty.";
X	    const char * potion_descr ;
X	    struct monst *mtmp;
X
X	    potion_descr = OBJ_DESCR(objects[obj->otyp]);
X	    if (!strcmp(potion_descr, "milky") && !rn2(13)) {
X		if (!enexto(&cc, mon->mx, mon->my, &mons[PM_GHOST])) return 0;
X		mquaffmsg(mon, obj);
X		m_useup(mon, obj);
X		mtmp = makemon(&mons[PM_GHOST], cc.x, cc.y);
X		if (!mtmp) {
X		    if (vis) pline(empty);
X		} else {
X		    if (vis) {
X			pline("As %s opens the bottle, an enormous %s emerges!",
X			   mon_nam(mon),
X			   Hallucination ? rndmonnam() : (const char *)"ghost");
X			pline("%s is frightened to death, and unable to move.",
X				Monnam(mon));
X		    }
X		    mon->mcanmove = 0;
X		    mon->mfrozen = 3;
X		}
X		return 2;
X	    }
X	    if (!strcmp(potion_descr, "smoky") && !rn2(13)) {
X		if (!enexto(&cc, mon->mx, mon->my, &mons[PM_DJINNI])) return 0;
X		mquaffmsg(mon, obj);
X		m_useup(mon, obj);
X		mtmp = makemon(&mons[PM_DJINNI], cc.x, cc.y);
X		if (!mtmp) {
X		    if (vis) pline(empty);
X		} else {
X		    if (vis)
X			pline("In a cloud of smoke, %s emerges!",
X							a_monnam(mtmp));
X		    pline("%s speaks.", vis ? Monnam(mtmp) : "Something");
X		/* I suspect few players will be upset that monsters */
X		/* can't wish for wands of death here.... */
X		    if (rn2(2)) {
X			verbalize("You freed me!");
X			mtmp->mpeaceful = 1;
X			set_malign(mtmp);
X		    } else {
X			verbalize("It is about time.");
X			if (vis) pline("%s vanishes.", Monnam(mtmp));
X			mongone(mtmp);
X		    }
X		}
X		return 2;
X	    }
X	}
X	if (obj->oclass == WAND_CLASS && obj->cursed && !rn2(100)) {
X	    int dam = d(obj->spe+2, 6);
X
X#ifdef SOUNDS
X	    if (flags.soundok)
X#endif
X				{
X		if (vis) pline("%s zaps %s, which suddenly explodes!",
X			Monnam(mon), an(xname(obj)));
X		else You("hear a zap and an explosion in the distance.");
X	    }
X	    m_useup(mon, obj);
X	    if (mon->mhp <= dam) {
X		monkilled(mon, "", AD_RBRE);
X		return 1;
X	    }
X	    else mon->mhp -= dam;
X	    m.has_defense = m.has_offense = m.has_misc = 0;
X	    /* Only one needed to be set to 0 but the others are harmless */
X	}
X	return 0;
X}
X
Xstatic void
Xmzapmsg(mtmp, otmp, self)
Xstruct monst *mtmp;
Xstruct obj *otmp;
Xboolean self;
X{
X	if (!cansee(mtmp->mx, mtmp->my)) {
X#ifdef SOUNDS
X		if (flags.soundok)
X#endif
X			You("hear a distant zap.");
X	} else if (self)
X		pline("%s zaps %sself with %s!",
X			Monnam(mtmp),
X			gender(mtmp)==2 ? "it" : gender(mtmp) ? "her" : "him",
X			doname(otmp));
X	else {
X		pline("%s zaps %s!", Monnam(mtmp), an(xname(otmp)));
X		stop_occupation();
X	}
X}
X
Xstatic void
Xmreadmsg(mtmp, otmp)
Xstruct monst *mtmp;
Xstruct obj *otmp;
X{
X	boolean vis = (cansee(mtmp->mx, mtmp->my));
X#ifdef SOUNDS
X	if (flags.soundok)
X#endif
X		otmp->dknown = 1;
X	if (!vis) {
X#ifdef SOUNDS
X		if (flags.soundok)
X#endif
X		    You("hear %s reading %s.",
X			an(Hallucination ? rndmonnam() : mtmp->data->mname),
X			singular(otmp, doname));
X	} else pline("%s reads %s!", Monnam(mtmp), singular(otmp,doname));
X	if (mtmp->mconf
X#ifdef SOUNDS
X		&& (vis || flags.soundok)
X#endif
X					)
X		pline("Being confused, %s mispronounces the magic words...",
X			vis ? mon_nam(mtmp) : gender(mtmp)==2 ? "it" :
X			gender(mtmp) ? "he" : "she");
X}
X
Xstatic void
Xmquaffmsg(mtmp, otmp)
Xstruct monst *mtmp;
Xstruct obj *otmp;
X{
X	if (cansee(mtmp->mx, mtmp->my)) {
X		otmp->dknown = 1;
X		pline("%s drinks %s!", Monnam(mtmp), singular(otmp, doname));
X	} else
X#ifdef SOUNDS
X		if (flags.soundok)
X#endif
X			You("hear a chugging sound.");
X}
X
X/* Defines for various types of stuff.  The order in which monsters prefer
X * to use them is determined by the order of the code logic, not the
X * numerical order in which they are defined.
X */
X#define MUSE_SCR_TELEPORTATION 1
X#define MUSE_WAN_TELEPORTATION_SELF 2
X#define MUSE_POT_HEALING 3
X#define MUSE_POT_EXTRA_HEALING 4
X#define MUSE_WAN_DIGGING 5
X#define MUSE_TRAPDOOR 6
X#define MUSE_TELEPORT_TRAP 7
X#define MUSE_UPSTAIRS 8
X#define MUSE_DOWNSTAIRS 9
X#define MUSE_WAN_CREATE_MONSTER 10
X#define MUSE_SCR_CREATE_MONSTER 11
X#define MUSE_UP_LADDER 12
X#define MUSE_DN_LADDER 13
X#define MUSE_SSTAIRS 14
X#define MUSE_WAN_TELEPORTATION 15
X#ifdef ARMY
X# define MUSE_BUGLE 16
X#endif
X/*
X#define MUSE_INNATE_TPT 9999
X * We cannot use this.  Since monsters get unlimited teleportation, if they
X * were allowed to teleport at will you could never catch them.  Instead,
X * assume they only teleport at random times, despite the inconsistency that if
X * you polymorph into one you teleport at will.
X */
X
X/* Select a defensive item/action for a monster.  Returns TRUE iff one is
X * found.
X */
Xboolean
Xfind_defensive(mtmp)
Xstruct monst *mtmp;
X{
X	register struct obj *obj;
X	struct trap *t;
X	int x=mtmp->mx, y=mtmp->my;
X	boolean stuck = (mtmp == u.ustuck);
X	boolean immobile = (mtmp->data->mmove == 0);
X
X	if (mtmp->mpeaceful || is_animal(mtmp->data) || mindless(mtmp->data))
X		return 0;
X	if (u.uswallow && stuck) return 0;
X	if(dist2(x, y, mtmp->mux, mtmp->muy) > 25)
X		return 0;
X	if(mtmp->mhp >= mtmp->mhpmax ||
X			(mtmp->mhp >= 10 && mtmp->mhp*5 >= mtmp->mhpmax))
X		return 0;
X
X	m.defensive = (struct obj *)0;
X	m.has_defense = 0;
X
X	if (levl[x][y].typ == STAIRS && !stuck && !immobile) {
X		if (x == xdnstair && y == ydnstair)
X			m.has_defense = MUSE_DOWNSTAIRS;
X		if (x == xupstair && y == yupstair && ledger_no(&u.uz) != 1)
X	/* Unfair to let the monsters leave the dungeon with the Amulet */
X	/* (or go to the endlevel since you also need it, to get there) */
X			m.has_defense = MUSE_UPSTAIRS;
X	} else if (levl[x][y].typ == LADDER && !stuck && !immobile) {
X		if (x == xupladder && y == yupladder)
X			m.has_defense = MUSE_UP_LADDER;
X		if (x == xdnladder && y == ydnladder)
X			m.has_defense = MUSE_DN_LADDER;
X	} else if (sstairs.sx &&
X		   sstairs.sx == mtmp->mx && sstairs.sy == mtmp->my) {
X		m.has_defense = MUSE_SSTAIRS;
X	} else if (!stuck && !immobile) {
X	/* Note: trapdoors take precedence over teleport traps. */
X		int xx, yy;
X
X		for(xx = x-1; xx <= x+1; xx++) for(yy = y-1; yy <= y+1; yy++)
X		if (isok(xx,yy))
X		if (xx != u.ux && yy != u.uy)
X		if (mtmp->data != &mons[PM_GRID_BUG] || xx == x || yy == y)
X		if ((xx==x && yy==y) || !level.monsters[xx][yy])
X		if ((t = t_at(xx,yy)) != 0) {
X			if (t->ttyp == TRAPDOOR
X				&& !is_floater(mtmp->data)
X				&& !mtmp->isshk && !mtmp->isgd
X				&& !mtmp->ispriest
X				&& Can_fall_thru(&u.uz)
X						) {
X				trapx = xx;
X				trapy = yy;
X				m.has_defense = MUSE_TRAPDOOR;
X			} else if (t->ttyp == TELEP_TRAP && m.has_defense != MUSE_TRAPDOOR) {
X				trapx = xx;
X				trapy = yy;
X				m.has_defense = MUSE_TELEPORT_TRAP;
X			}
X		}
X	}
X
X	if (nohands(mtmp->data))	/* can't use objects */
X		goto botm;
X
X#ifdef ARMY
X	if (is_mercenary(mtmp->data) && (obj = m_carrying(mtmp, BUGLE))) {
X		int xx, yy;
X		struct monst *mon;
X
X		/* Distance is arbitrary.  What we really want to do is
X		 * have the soldier play the bugle when it sees or
X		 * remembers soldiers nearby...
X		 */
X		for(xx = x-3; xx <= x+3; xx++) for(yy = y-3; yy <= y+3; yy++)
X		if (isok(xx,yy))
X		if ((mon = m_at(xx,yy)) && is_mercenary(mon->data) &&
X				mon->data != &mons[PM_GUARD] &&
X				(mon->msleep || (!mon->mcanmove))) {
X			m.defensive = obj;
X			m.has_defense = MUSE_BUGLE;
X		}
X	}
X#endif
X	if (m.has_defense == MUSE_UPSTAIRS ||
X			m.has_defense == MUSE_DOWNSTAIRS ||
X			m.has_defense == MUSE_UP_LADDER ||
X			m.has_defense == MUSE_DN_LADDER ||
X			m.has_defense == MUSE_SSTAIRS ||
X#ifdef ARMY
X			m.has_defense == MUSE_BUGLE ||
X#endif
X			m.has_defense == MUSE_TRAPDOOR)
X		goto botm;
X#define nomore(x) if(m.has_defense==x) continue;
X	for (obj = mtmp->minvent; obj; obj = obj->nobj) {
X		/* nomore(MUSE_WAN_DIGGING); */
X		if (m.has_defense == MUSE_WAN_DIGGING) break;
X		if (obj->otyp == WAN_DIGGING && obj->spe > 0 && !stuck
X		    && !mtmp->isshk && !mtmp->isgd && !mtmp->ispriest
X		    && !is_floater(mtmp->data)
X#ifdef MULDGN
X		    && !Is_knox(&u.uz)
X#endif
X		    && !In_endgame(&u.uz)) {
X			m.defensive = obj;
X			m.has_defense = MUSE_WAN_DIGGING;
X		}
X		nomore(MUSE_TELEPORT_TRAP);
X		nomore(MUSE_WAN_TELEPORTATION_SELF);
X		nomore(MUSE_WAN_TELEPORTATION);
X		if(obj->otyp == WAN_TELEPORTATION && obj->spe > 0) {
X			m.defensive = obj;
X			m.has_defense = (mon_has_amulet(mtmp))
X				? MUSE_WAN_TELEPORTATION
X				: MUSE_WAN_TELEPORTATION_SELF;
X		}
X		nomore(MUSE_SCR_TELEPORTATION);
X		if(obj->otyp == SCR_TELEPORTATION && mtmp->mcansee
X		   && haseyes(mtmp->data)
X		   && (!obj->cursed ||
X		       (!mtmp->isshk && !mtmp->isgd && !mtmp->ispriest))) {
X			m.defensive = obj;
X			m.has_defense = MUSE_SCR_TELEPORTATION;
X		}
X		nomore(MUSE_POT_EXTRA_HEALING);
X		if(obj->otyp == POT_EXTRA_HEALING) {
X			m.defensive = obj;
X			m.has_defense = MUSE_POT_EXTRA_HEALING;
X		}
X		nomore(MUSE_WAN_CREATE_MONSTER);
X		if(obj->otyp == WAN_CREATE_MONSTER && obj->spe > 0) {
X			m.defensive = obj;
X			m.has_defense = MUSE_WAN_CREATE_MONSTER;
X		}
X		nomore(MUSE_POT_HEALING);
X		if(obj->otyp == POT_HEALING) {
X			m.defensive = obj;
X			m.has_defense = MUSE_POT_HEALING;
X		}
X		nomore(MUSE_SCR_CREATE_MONSTER);
X		if(obj->otyp == SCR_CREATE_MONSTER) {
X			m.defensive = obj;
X			m.has_defense = MUSE_SCR_CREATE_MONSTER;
X		}
X	}
Xbotm:	return !!m.has_defense;
X#undef nomore
X}
X
X/* Perform a defensive action for a monster.  Must be called immediately
X * after find_defensive().  Return values are 0: did something, 1: died,
X * 2: did something and can't attack again (i.e. teleported).
X */
Xint
Xuse_defensive(mtmp)
Xstruct monst *mtmp;
X{
X	int i;
X	struct obj *otmp = m.defensive;
X	boolean vis = cansee(mtmp->mx, mtmp->my);
X	boolean vismon = canseemon(mtmp);
X	boolean oseen = otmp && (otmp->oclass == SCROLL_CLASS || vis);
X
X	if ((i = precheck(mtmp, otmp)) != 0) return i;
X	switch(m.has_defense) {
X#ifdef ARMY
X	case MUSE_BUGLE:
X		if (canseemon(mtmp))
X			pline("%s plays %s!", Monnam(mtmp), doname(otmp));
X		else if (flags.soundok)
X			You("hear the sound of a bugle!");
X		awaken_soldiers();
X		return 2;
X#endif
X	case MUSE_WAN_TELEPORTATION_SELF:
X		mzapmsg(mtmp, otmp, TRUE);
X		otmp->spe--;
X		if (oseen) makeknown(WAN_TELEPORTATION);
Xmon_tele:
X		if(level.flags.noteleport) {
X		    if (vismon)
X		      pline("A mysterious force prevents %s from teleporting!",
X			mon_nam(mtmp));
X		    return 2;
X		}
X		if((/*mon_has_amulet(mtmp)||*/ Is_wiz1_level(&u.uz) ||
X		      Is_wiz2_level(&u.uz) || Is_wiz3_level(&u.uz))
X								&& !rn2(3)) {
X		    if (vismon)
X			pline("%s seems disoriented for a moment.",
X				Monnam(mtmp));
X		    return 2;
X		}
X		rloc(mtmp);
X		return 2;
X	case MUSE_WAN_TELEPORTATION:
X		zap_oseen = oseen;
X		mzapmsg(mtmp, otmp, FALSE);
X		otmp->spe--;
X		m_using = TRUE;
X		mbhit(mtmp,rn1(8,6),mbhitm,bhito,otmp);
X		m_using = FALSE;
X		return 2;
X	case MUSE_SCR_TELEPORTATION:
X	    {
X		int obj_is_cursed = otmp->cursed;
X
X		mreadmsg(mtmp, otmp);
X		m_useup(mtmp, otmp);	/* otmp might be free'ed */
X		if (oseen) makeknown(SCR_TELEPORTATION);
X		if (obj_is_cursed) {
X			if (mon_has_amulet(mtmp) || In_endgame(&u.uz)) {
X			    if (vismon)
X				pline("%s seems very disoriented for a moment.",
X					Monnam(mtmp));
X			    return 2;
X			}
X			if (Is_botlevel(&u.uz)) goto mon_tele;
X			else {
X			    int nlev;
X			    d_level flev;
X
X			    if (rn2(5)) nlev = rnd((int)depth(&u.uz) + 3);
X			    else {
X				pline("%s shudders for a moment.",
X							Monnam(mtmp));
X				return 2; 
X			    }
X			    if (nlev == depth(&u.uz)) {
X				if (u.uz.dlevel == 1) nlev++;
X				else if (In_hell(&u.uz)) nlev--;
X				else nlev++;
X			    }
X			    get_level(&flev, nlev);
X			    migrate_to_level(mtmp, ledger_no(&flev), 0);
X			}
X		} else goto mon_tele;
X		return 2;
X	    }
X	case MUSE_WAN_DIGGING:
X		mzapmsg(mtmp, otmp, FALSE);
X		otmp->spe--;
X		if (oseen) makeknown(WAN_DIGGING);
X		if(IS_FURNITURE(levl[mtmp->mx][mtmp->my].typ)
X		   || (sstairs.sx && sstairs.sx == mtmp->mx &&
X				sstairs.sy == mtmp->my)) {
X			pline("The digging ray is ineffective.");
X			return 2;
X		}
X		if (!Can_dig_down(&u.uz)) {
X		    if(canseemon(mtmp))
X			pline("The floor here is too hard to dig in.");
X		    return 2;
X		}
X		seetrap(maketrap(mtmp->mx, mtmp->my, TRAPDOOR));
X		if (vis) {
X			pline("%s's made a hole in the floor.", Monnam(mtmp));
X			pline("%s falls through...", Monnam(mtmp));
X		} else
X# ifdef SOUNDS
X			if (flags.soundok)
X# endif
X			You("hear something crash through the floor.");
X		/* we made sure that there is a level for mtmp to go to */
X		migrate_to_level(mtmp, ledger_no(&u.uz)+1, 0);
X		return 2;
X	case MUSE_WAN_CREATE_MONSTER:
X	    {	coord cc;
X		struct permonst *pm=rndmonst();
X
X		if (!enexto(&cc, mtmp->mx, mtmp->my, pm)) return 0;
X		mzapmsg(mtmp, otmp, FALSE);
X		otmp->spe--;
X		if (oseen) makeknown(WAN_CREATE_MONSTER);
X		(void) makemon(pm, cc.x, cc.y);
X		return 2;
X	    }
X	case MUSE_SCR_CREATE_MONSTER:
X	    {	coord cc;
X		struct permonst *pm=rndmonst();
X		int cnt = 1;
X
X		if (!rn2(73)) cnt += rnd(4);
X		if (mtmp->mconf || otmp->cursed) cnt += 12;
X		mreadmsg(mtmp, otmp);
X		while(cnt--) {
X			struct monst *mon;
X
X			if (!enexto(&cc, mtmp->mx, mtmp->my, pm)) continue;
X			mon = makemon(mtmp->mconf ? &mons[PM_ACID_BLOB]
X				: rndmonst(), cc.x, cc.y);
X			if (mon) newsym(mon->mx,mon->my);
X		}
X		if (oseen && !objects[SCR_CREATE_MONSTER].oc_name_known
X			  && !objects[SCR_CREATE_MONSTER].oc_uname)
X			docall(otmp); /* not makeknown(); be consistent */
X		m_useup(mtmp, otmp);
X		return 2;
X	    }
X	case MUSE_TRAPDOOR:
X		/* trapdoors on "bottom" levels of dungeons are rock-drop
X		 * trapdoors, not holes in the floor.  We check here for
X		 * safety.
X		 */
X		if (Is_botlevel(&u.uz)) return 0;
X		if (vis) pline("%s %s into a trapdoor!", Monnam(mtmp),
X			makeplural(locomotion(mtmp->data, "jump")));
X		seetrap(t_at(trapx,trapy));
X
X		/*  don't use rloc_to() because worm tails must "move" */
X		remove_monster(mtmp->mx, mtmp->my);
X		newsym(mtmp->mx, mtmp->my);	/* update old location */
X		place_monster(mtmp, trapx, trapy);
X		if (mtmp->wormno) worm_move(mtmp);
X		newsym(trapx, trapy);
X
X		migrate_to_level(mtmp, ledger_no(&u.uz)+1, 0);
X		return 2;
X	case MUSE_UPSTAIRS:
X		/* Monsters without amulets escape the dungeon and are
X		 * gone for good when they leave up the up stairs.
X		 * Monsters with amulets would reach the endlevel,
X		 * which we cannot allow since that would leave the
X		 * player stranded.
X		 */
X		if (ledger_no(&u.uz) == 1) {
X			if (mon_has_special(mtmp))
X				return 0;
X			if (vismon) pline("%s escapes the dungeon!",
X				Monnam(mtmp));
X			mongone(mtmp);
X			return 2;
X		}
X		if (vismon) pline("%s escapes upstairs!", Monnam(mtmp));
X		migrate_to_level(mtmp, ledger_no(&u.uz)-1, 2);
X		return 2;
X	case MUSE_DOWNSTAIRS:
X		if (vismon) pline("%s escapes downstairs!", Monnam(mtmp));
X		migrate_to_level(mtmp, ledger_no(&u.uz)+1, 1);
X		return 2;
X	case MUSE_UP_LADDER:
X		if (vismon) pline("%s escapes up the ladder!", Monnam(mtmp));
X		migrate_to_level(mtmp, ledger_no(&u.uz)-1, 4);
X		return 2;
X	case MUSE_DN_LADDER:
X		if (vismon) pline("%s escapes down the ladder!", Monnam(mtmp));
X		migrate_to_level(mtmp, ledger_no(&u.uz)+1, 3);
X		return 2;
X	case MUSE_SSTAIRS:
X		/* the stairs leading up from the 1st level are */
X		/* regular stairs, not sstairs.			*/
X		if (sstairs.up) {
X			if (vismon)
X			    pline("%s escapes upstairs!", Monnam(mtmp));
X			if(Inhell) {
X			    migrate_to_level(mtmp,
X					 ledger_no(&sstairs.tolev), 0);
X			    return 2;
X			}
X		} else	if (vismon)
X		    pline("%s escapes downstairs!", Monnam(mtmp));
X		migrate_to_level(mtmp, ledger_no(&sstairs.tolev), 5);
X		return 2;
X	case MUSE_TELEPORT_TRAP:
X		if (vis) pline("%s %s onto a teleport trap!", Monnam(mtmp),
X			makeplural(locomotion(mtmp->data, "jump")));
X		seetrap(t_at(trapx,trapy));
X
X		/*  don't use rloc_to() because worm tails must "move" */
X		remove_monster(mtmp->mx, mtmp->my);
X		newsym(mtmp->mx, mtmp->my);	/* update old location */
X		place_monster(mtmp, trapx, trapy);
X		if (mtmp->wormno) worm_move(mtmp);
X		newsym(trapx, trapy);
X
X		goto mon_tele;
X	case MUSE_POT_HEALING:
X		mquaffmsg(mtmp, otmp);
X		i = d(5,2) + 5 * !!bcsign(otmp);
X		mtmp->mhp += i;
X		if (mtmp->mhp > mtmp->mhpmax) mtmp->mhp = ++mtmp->mhpmax;
X		if (!otmp->cursed) mtmp->mcansee = 1;
X		if (vismon) pline("%s begins to look better.", Monnam(mtmp));
X		if (oseen) makeknown(POT_HEALING);
X		m_useup(mtmp, otmp);
X		return 2;
X	case MUSE_POT_EXTRA_HEALING:
X		mquaffmsg(mtmp, otmp);
X		i = d(5,4) + 5 * !!bcsign(otmp);
X		mtmp->mhp += i;
X		if (mtmp->mhp > mtmp->mhpmax)
X			mtmp->mhp = (mtmp->mhpmax += (otmp->blessed ? 5 : 2));
X		mtmp->mcansee = 1;
X		if (vismon) pline("%s looks much better.", Monnam(mtmp));
X		if (oseen) makeknown(POT_EXTRA_HEALING);
X		m_useup(mtmp, otmp);
X		return 2;
X	case 0: return 0; /* i.e. an exploded wand */
X	default: impossible("%s wanted to perform action %d?", Monnam(mtmp),
X			m.has_defense);
X		break;
X	}
X	return 0;
X}
X
Xint
Xrnd_defensive_item(mtmp)
Xstruct monst *mtmp;
X{
X	struct permonst *pm = mtmp->data;
X	int difficulty = monstr[(monsndx(pm))];
X
X	if(is_animal(pm) || attacktype(pm, AT_EXPL) || mindless(mtmp->data)
X			|| pm->mlet == S_GHOST
X# ifdef KOPS
X			|| pm->mlet == S_KOP
X# endif
X		) return 0;
X	switch (rn2(8 + (difficulty > 3) + (difficulty > 6) +
X				(difficulty > 8))) {
X		case 0: case 1:
X			return SCR_TELEPORTATION;
X		case 2: return SCR_CREATE_MONSTER;
X		case 3: case 4:
X			return POT_HEALING;
X		case 5: return POT_EXTRA_HEALING;
X		case 6: case 9:
X			return WAN_TELEPORTATION;
X		case 7: if (is_floater(pm) || mtmp->isshk || mtmp->isgd
X						|| mtmp->ispriest
X									)
X				return 0;
X			else
X				return WAN_DIGGING;
X		case 8: case 10:
X			return WAN_CREATE_MONSTER;
X	}
X	/*NOTREACHED*/
X	return 0;
X}
X
X#define MUSE_WAN_DEATH 1
X#define MUSE_WAN_SLEEP 2
X#define MUSE_WAN_FIRE 3
X#define MUSE_WAN_COLD 4
X#define MUSE_WAN_LIGHTNING 5
X#define MUSE_WAN_MAGIC_MISSILE 6
X#define MUSE_WAN_STRIKING 7
X#define MUSE_SCR_FIRE 8
X#define MUSE_POT_PARALYSIS 9
X#define MUSE_POT_BLINDNESS 10
X#define MUSE_POT_CONFUSION 11
X
X/* Select an offensive item/action for a monster.  Returns TRUE iff one is
X * found.
X */
Xboolean
Xfind_offensive(mtmp)
Xstruct monst *mtmp;
X{
X	register struct obj *obj;
X	boolean ranged_stuff = lined_up(mtmp);
X
X	m.offensive = (struct obj *)0;
X	m.has_offense = 0;
X	if (mtmp->mpeaceful || is_animal(mtmp->data) ||
X				mindless(mtmp->data) || nohands(mtmp->data))
X		return 0;
X	if (u.uswallow) return 0;
X	if (in_your_sanctuary(mtmp->mx, mtmp->my)) return 0;
X
X	if (!ranged_stuff) return 0;
X#define nomore(x) if(m.has_offense==x) continue;
X	for(obj=mtmp->minvent; obj; obj=obj->nobj) {
X		/* nomore(MUSE_WAN_DEATH); */
X		if (m.has_defense == WAN_DEATH) break;
X		if(obj->otyp == WAN_DEATH && obj->spe > 0) {
X			m.offensive = obj;
X			m.has_offense = MUSE_WAN_DEATH;
X		}
X		nomore(MUSE_WAN_SLEEP);
X		if(obj->otyp == WAN_SLEEP && obj->spe > 0 && multi >= 0) {
X			m.offensive = obj;
X			m.has_offense = MUSE_WAN_SLEEP;
X		}
X		nomore(MUSE_WAN_FIRE);
X		if(obj->otyp == WAN_FIRE && obj->spe > 0) {
X			m.offensive = obj;
X			m.has_offense = MUSE_WAN_FIRE;
X		}
X		nomore(MUSE_WAN_COLD);
X		if(obj->otyp == WAN_COLD && obj->spe > 0) {
X			m.offensive = obj;
X			m.has_offense = MUSE_WAN_COLD;
X		}
X		nomore(MUSE_WAN_LIGHTNING);
X		if(obj->otyp == WAN_LIGHTNING && obj->spe > 0) {
X			m.offensive = obj;
X			m.has_offense = MUSE_WAN_LIGHTNING;
X		}
X		nomore(MUSE_WAN_MAGIC_MISSILE);
X		if(obj->otyp == WAN_MAGIC_MISSILE && obj->spe > 0) {
X			m.offensive = obj;
X			m.has_offense = MUSE_WAN_MAGIC_MISSILE;
X		}
X		nomore(MUSE_WAN_STRIKING);
X		if(obj->otyp == WAN_STRIKING && obj->spe > 0) {
X			m.offensive = obj;
X			m.has_offense = MUSE_WAN_STRIKING;
X		}
X		nomore(MUSE_POT_PARALYSIS);
X		if(obj->otyp == POT_PARALYSIS && multi >= 0) {
X			m.offensive = obj;
X			m.has_offense = MUSE_POT_PARALYSIS;
X		}
X		nomore(MUSE_POT_BLINDNESS);
X		if(obj->otyp == POT_BLINDNESS) {
X			m.offensive = obj;
X			m.has_offense = MUSE_POT_BLINDNESS;
X		}
X		nomore(MUSE_POT_CONFUSION);
X		if(obj->otyp == POT_CONFUSION) {
X			m.offensive = obj;
X			m.has_offense = MUSE_POT_CONFUSION;
X		}
X#if 0
X		nomore(MUSE_SCR_FIRE);
X		/* even more restrictive than ranged_stuff */
X		if(obj->otyp == SCR_FIRE && resists_fire(mtmp->data)
X		   && distu(mtmp->mx,mtmp->my)==1
X		   && mtmp->mcansee && haseyes(mtmp->data)) {
X			m.offensive = obj;
X			m.has_offense = MUSE_SCR_FIRE;
X		}
X#endif
X	}
X	return !!m.has_offense;
X#undef nomore
X}
X
Xstatic int
Xmbhitm(mtmp, otmp)
Xregister struct monst *mtmp;
Xregister struct obj *otmp;
X{
X	int tmp;
X
X	if (mtmp != &youmonst) {
X		mtmp->msleep = 0;
X		if (mtmp->m_ap_type) seemimic(mtmp);
X	}
X	switch(otmp->otyp) {
X	case WAN_STRIKING:
X		if (mtmp == &youmonst) {
X			if (zap_oseen) makeknown(WAN_STRIKING);
X			if (rnd(20) < 10 + u.uac) {
X				pline("The wand hits you!");
X				tmp = d(2,12);
X				if(Half_spell_damage) tmp = (tmp+1) / 2;
X				losehp(tmp, "wand", KILLED_BY_AN);
X			} else pline("The wand misses you.");
X			stop_occupation();
X			nomul(0);
X		} else if (rnd(20) < 10+find_mac(mtmp)) {
X			tmp = d(2,12);
X			if(Half_spell_damage) tmp = (tmp+1) / 2;
X			hit("wand", mtmp, exclam(tmp));
X			(void) resist(mtmp, otmp->oclass, tmp, TELL);
X			if (cansee(mtmp->mx, mtmp->my) && zap_oseen)
X				makeknown(WAN_STRIKING);
X		} else {
X			miss("wand", mtmp);
X			if (cansee(mtmp->mx, mtmp->my) && zap_oseen)
X				makeknown(WAN_STRIKING);
X		}
X		break;
X	case WAN_TELEPORTATION:
X		if (mtmp == &youmonst) {
X			if (zap_oseen) makeknown(WAN_TELEPORTATION);
X			tele();
X		} else {
X			/* for consistency with zap.c, don't identify */
X			if (mtmp->ispriest &&
X				*in_rooms(mtmp->mx, mtmp->my, TEMPLE)) {
X			    if (cansee(mtmp->mx, mtmp->my))
X				pline("%s resists the magic!", Monnam(mtmp));
X			    mtmp->msleep = 0;
X			    if(mtmp->m_ap_type) seemimic(mtmp);
X			} else
X			    rloc(mtmp);
X		}
X		break;
X	case WAN_CANCELLATION:
X	case SPE_CANCELLATION:
X		cancel_monst(mtmp, otmp, FALSE, TRUE, FALSE);
X		break;
X	}
X	return 0;
X}
X
X/* A modified bhit() for monsters.  Based on bhit() in zap.c.  Unlike
X * buzz(), bhit() doesn't take into account the possibility of a monster
X * zapping you, so we need a special function for it.  (Unless someone wants
X * to merge the two functions...)
X */
Xstatic void
Xmbhit(mon,range,fhitm,fhito,obj)
Xstruct monst *mon;			/* monster shooting the wand */
Xregister int range;			/* direction and range */
Xint FDECL((*fhitm),(MONST_P,OBJ_P));
Xint FDECL((*fhito),(OBJ_P,OBJ_P));	/* fns called when mon/obj hit */
Xstruct obj *obj;			/* 2nd arg to fhitm/fhito */
X{
X	register struct monst *mtmp;
X	register struct obj *otmp;
X	register uchar typ;
X	int ddx, ddy;
X
X	bhitpos.x = mon->mx;
X	bhitpos.y = mon->my;
X	ddx = sgn(mon->mux - mon->mx);
X	ddy = sgn(mon->muy - mon->my);
X
X	while(range-- > 0) {
X		int x,y;
X
X		bhitpos.x += ddx;
X		bhitpos.y += ddy;
X		x = bhitpos.x; y = bhitpos.y;
X		if (find_drawbridge(&x,&y))
X		    switch (obj->otyp) {
X			case WAN_STRIKING:
X			    destroy_drawbridge(x,y);
X		    }
X		if(bhitpos.x==u.ux && bhitpos.y==u.uy) {
X			(*fhitm)(&youmonst, obj);
X			range -= 3;
X		} else if(MON_AT(bhitpos.x, bhitpos.y)){
X			mtmp = m_at(bhitpos.x,bhitpos.y);
X			(*fhitm)(mtmp, obj);
X			range -= 3;
X		}
X		/* modified by GAN to hit all objects */
X		if(fhito){
X		    int hitanything = 0;
X		    register struct obj *next_obj;
X
X		    for(otmp = level.objects[bhitpos.x][bhitpos.y];
X							otmp; otmp = next_obj) {
X			/* Fix for polymorph bug, Tim Wright */
X			next_obj = otmp->nexthere;
X			hitanything += (*fhito)(otmp, obj);
X		    }
X		    if(hitanything)	range--;
X		}
X		typ = levl[bhitpos.x][bhitpos.y].typ;
X		if(IS_DOOR(typ) || typ == SDOOR) {
X		    switch (obj->otyp) {
X			case WAN_STRIKING:
X			    if (doorlock(obj, bhitpos.x, bhitpos.y))
X				makeknown(obj->otyp);
X			    break;
X		    }
X		}
X		if(!ZAP_POS(typ) || (IS_DOOR(typ) &&
X		   (levl[bhitpos.x][bhitpos.y].doormask & (D_LOCKED | D_CLOSED)))
X		  ) {
X			bhitpos.x -= ddx;
X			bhitpos.y -= ddy;
X			break;
X		}
X	}
X}
X
X/* Perform an offensive action for a monster.  Must be called immediately
X * after find_offensive().  Return values are same as use_defensive().
X */
Xint
Xuse_offensive(mtmp)
Xstruct monst *mtmp;
X{
X	int i;
X	struct obj *otmp = m.offensive;
X	boolean vis = cansee(mtmp->mx, mtmp->my);
X	boolean oseen = otmp && (otmp->oclass == SCROLL_CLASS || vis);
X
X	if ((i = precheck(mtmp, otmp)) != 0) return i;
X	switch(m.has_offense) {
X	case MUSE_WAN_DEATH:
X	case MUSE_WAN_SLEEP:
X	case MUSE_WAN_FIRE:
X	case MUSE_WAN_COLD:
X	case MUSE_WAN_LIGHTNING:
X	case MUSE_WAN_MAGIC_MISSILE:
X		mzapmsg(mtmp, otmp, FALSE);
X		otmp->spe--;
X		if (oseen) makeknown(otmp->otyp);
X		m_using = TRUE;
X		buzz((int)(-30 - (otmp->otyp - WAN_MAGIC_MISSILE)),
X			(otmp->otyp == WAN_MAGIC_MISSILE) ? 2 : 6,
X			mtmp->mx, mtmp->my,
X			sgn(mtmp->mux-mtmp->mx), sgn(mtmp->muy-mtmp->my));
X		m_using = FALSE;
X		return (mtmp->mhp <= 0) ? 1 : 2;
X	case MUSE_WAN_TELEPORTATION:
X	case MUSE_WAN_STRIKING:
X		zap_oseen = oseen;
X		mzapmsg(mtmp, otmp, FALSE);
X		otmp->spe--;
X		m_using = TRUE;
X		mbhit(mtmp,rn1(8,6),mbhitm,bhito,otmp);
X		m_using = FALSE;
X		return 2;
X#if 0
X	case MUSE_SCR_FIRE:
X		mreadmsg(mtmp, otmp);
X		if (mtmp->mconf) {
X			if (vis)
X			    pline("Oh, what a pretty fire!");
X		} else {
X			struct monst *mtmp2;
X			int num;
X
X			if (vis)
X			    pline("The scroll erupts in a tower of flame!");
X			shieldeff(mtmp->mx, mtmp->my);
X			pline("%s is uninjured.", Monnam(mtmp));
X			(void) destroy_mitem(mtmp, SCROLL_CLASS, AD_FIRE);
X			(void) destroy_mitem(mtmp, SPBOOK_CLASS, AD_FIRE);
X			(void) destroy_mitem(mtmp, POTION_CLASS, AD_FIRE);
X			num = (2*(rn1(3, 3) + 2 * bcsign(otmp)) + 1)/3;
X			if (Fire_resistance)
X			    You("are not affected.");
X			if (Half_spell_damage) num = (num+1) / 2;
X			else losehp(num, "scroll of fire", KILLED_BY_AN);
X			for(mtmp2 = fmon; mtmp2; mtmp2 = mtmp2->nmon) {
X			   if(mtmp == mtmp2) continue;
X			   if(dist2(mtmp2->mx,mtmp2->my,mtmp->mx,mtmp->my) < 3){
X				if (resists_fire(mtmp2->data)) continue;
X				mtmp2->mhp -= num;
X				if(resists_cold(mtmp2->data))
X				    mtmp2->mhp -= 3*num;
X				if(mtmp2->mhp < 1) {
X				    mondied(mtmp2);
X				    break;
X				}
X			    }
X			}
X		}
X		return 2;
X#endif
X	case MUSE_POT_PARALYSIS:
X	case MUSE_POT_BLINDNESS:
X	case MUSE_POT_CONFUSION:
X		/* Note: this setting of dknown doesn't suffice.  A monster
X		 * which is out of sight might throw and it hits something _in_
X		 * sight, a problem not existing with wands because wand rays
X		 * are not objects.  Also set dknown in mthrowu.c.
X		 */
X		if (cansee(mtmp->mx, mtmp->my)) {
X			otmp->dknown = 1;
X			pline("%s hurls %s!", Monnam(mtmp),
X						singular(otmp, doname));
X		}
X		m_throw(mtmp, mtmp->mx, mtmp->my, sgn(mtmp->mux-mtmp->mx),
X			sgn(mtmp->muy-mtmp->my),
X			distmin(mtmp->mx,mtmp->my,mtmp->mux,mtmp->muy), otmp);
X		return 2;
X	case 0: return 0; /* i.e. an exploded wand */
X	default: impossible("%s wanted to perform action %d?", Monnam(mtmp),
X			m.has_offense);
X		break;
X	}
X	return 0;
X}
X
Xint
Xrnd_offensive_item(mtmp)
Xstruct monst *mtmp;
X{
X	struct permonst *pm = mtmp->data;
X	int difficulty = monstr[(monsndx(pm))];
X
X	if(is_animal(pm) || attacktype(pm, AT_EXPL) || mindless(mtmp->data)
X			|| pm->mlet == S_GHOST
X# ifdef KOPS
X			|| pm->mlet == S_KOP
X# endif
X		) return 0;
X	if (difficulty > 7 && !rn2(35)) return WAN_DEATH;
X	switch (rn2(7 - (difficulty < 4) + 4 * (difficulty > 6))) {
X		case 0: case 1:
X			return WAN_STRIKING;
X		case 2: return POT_CONFUSION;
X		case 3: return POT_BLINDNESS;
X		case 4: return POT_PARALYSIS;
X		case 5: case 6:
X			return WAN_MAGIC_MISSILE;
X		case 7: return WAN_SLEEP;
X		case 8: return WAN_FIRE;
X		case 9: return WAN_COLD;
X		case 10: return WAN_LIGHTNING;
X	}
X	/*NOTREACHED*/
X	return 0;
X}
X
X#define MUSE_POT_GAIN_LEVEL 1
X#define MUSE_WAN_MAKE_INVISIBLE 2
X#define MUSE_POT_INVISIBILITY 3
X#define MUSE_POLY_TRAP 4
X#define MUSE_WAN_POLYMORPH 5
X#define MUSE_POT_SPEED 6
X#define MUSE_WAN_SPEED_MONSTER 7
Xboolean
Xfind_misc(mtmp)
Xstruct monst *mtmp;
X{
X	register struct obj *obj;
X	int x=mtmp->mx, y=mtmp->my;
X#ifdef POLYSELF
X	struct trap *t;
X	int xx, yy;
X	boolean immobile = (mtmp->data->mmove == 0);
X#endif
X	boolean stuck = (mtmp == u.ustuck);
X
X	m.misc = (struct obj *)0;
X	m.has_misc = 0;
X	if (is_animal(mtmp->data) || mindless(mtmp->data))
X		return 0;
X	if (u.uswallow && stuck) return 0;
X
X	/* We arbitrarily limit to times when a player is nearby for the
X	 * same reason as Junior Pac-Man doesn't have energizers eaten until
X	 * you can see them...
X	 */
X	if(dist2(x, y, mtmp->mux, mtmp->muy) > 36)
X		return 0;
X
X#ifdef POLYSELF
X	if (!stuck && !immobile &&
X			!mtmp->cham && monstr[(monsndx(mtmp->data))] < 6)
X	  for(xx = x-1; xx <= x+1; xx++)
X	    for(yy = y-1; yy <= y+1; yy++)
X		if (isok(xx,yy) && (xx != u.ux || yy != u.uy))
X		    if (mtmp->data != &mons[PM_GRID_BUG] || xx == x || yy == y)
X			if (/* (xx==x && yy==y) || */ !level.monsters[xx][yy])
X			    if ((t = t_at(xx,yy)) != 0) {
X				if (t->ttyp == POLY_TRAP) {
X				    trapx = xx;
X				    trapy = yy;
X				    m.has_misc = MUSE_POLY_TRAP;
X				    return TRUE;
X				}
X			    }
X#endif
X	if (nohands(mtmp->data))
X		return 0;
X
X#define nomore(x) if(m.has_misc==x) continue;
X	for(obj=mtmp->minvent; obj; obj=obj->nobj) {
X		/* Monsters shouldn't recognize cursed items; this kludge is */
X		/* necessary to prevent serious problems though... */
X		if(obj->otyp == POT_GAIN_LEVEL && (!obj->cursed ||
X			    (!mtmp->isgd && !mtmp->isshk && !mtmp->ispriest))) {
X			m.misc = obj;
X			m.has_misc = MUSE_POT_GAIN_LEVEL;
X		}
X		/* Note: peaceful/tame monsters won't make themselves
X		 * invisible unless you can see them.  Not really right, but...
X		 */
X		nomore(MUSE_WAN_MAKE_INVISIBLE);
X		if(obj->otyp == WAN_MAKE_INVISIBLE && obj->spe > 0 &&
X		     !mtmp->minvis && (!mtmp->mpeaceful || See_invisible)
X			&& (mtmp->data != &mons[PM_MEDUSA] || mtmp->mcan)) {
X			m.misc = obj;
X			m.has_misc = MUSE_WAN_MAKE_INVISIBLE;
X		}
X		nomore(MUSE_POT_INVISIBILITY);
X		if(obj->otyp == POT_INVISIBILITY &&
X		     !mtmp->minvis && (!mtmp->mpeaceful || See_invisible)) {
X			m.misc = obj;
X			m.has_misc = MUSE_POT_INVISIBILITY;
X		}
X		nomore(MUSE_WAN_SPEED_MONSTER);
X		if(obj->otyp == WAN_SPEED_MONSTER && obj->spe > 0
X				&& mtmp->mspeed != MFAST && !mtmp->isgd) {
X			m.misc = obj;
X			m.has_misc = MUSE_WAN_SPEED_MONSTER;
X		}
X		nomore(MUSE_POT_SPEED);
X		if(obj->otyp == POT_SPEED && mtmp->mspeed != MFAST
X							&& !mtmp->isgd) {
X			m.misc = obj;
X			m.has_misc = MUSE_POT_SPEED;
X		}
X		nomore(MUSE_WAN_POLYMORPH);
X		if(obj->otyp == WAN_POLYMORPH && !mtmp->cham
X				&& monstr[(monsndx(mtmp->data))] < 6) {
X			m.misc = obj;
X			m.has_misc = MUSE_WAN_POLYMORPH;
X		}
X	}
X	return !!m.has_misc;
X#undef nomore
X}
X
Xint
Xuse_misc(mtmp)
Xstruct monst *mtmp;
X{
X	int i;
X	struct obj *otmp = m.misc;
X	boolean vis = cansee(mtmp->mx, mtmp->my);
X	boolean vismon = canseemon(mtmp);
X	boolean oseen = otmp && (otmp->oclass == SCROLL_CLASS || vis);
X
X	if ((i = precheck(mtmp, otmp)) != 0) return i;
X	switch(m.has_misc) {
X	case MUSE_POT_GAIN_LEVEL:
X		mquaffmsg(mtmp, otmp);
X		if (otmp->cursed) {
X		    if (Can_rise_up(&u.uz)) {
X			register int tolev = depth(&u.uz)-1;
X			d_level tolevel;
X
X			get_level(&tolevel, tolev);
X			/* insurance against future changes... */
X			if(on_level(&tolevel, &u.uz)) goto skipmsg;
X			if (vismon) {
X			    pline("%s rises up, through the ceiling!",
X				Monnam(mtmp));
X			    if(!objects[POT_GAIN_LEVEL].oc_name_known
X			      && !objects[POT_GAIN_LEVEL].oc_uname)
X				docall(otmp);
X			}
X			m_useup(mtmp, otmp);
X			migrate_to_level(mtmp, ledger_no(&tolevel), 0);
X			return 2;
X		    } else {
Xskipmsg:
X			if (vismon) {
X			    pline("%s looks uneasy.", Monnam(mtmp));
X			    if(!objects[POT_GAIN_LEVEL].oc_name_known
X			      && !objects[POT_GAIN_LEVEL].oc_uname)
X				docall(otmp);
X			}
X			m_useup(mtmp, otmp);
X			return 2;
X		    }
X		}
X		if (vismon) pline("%s seems more experienced.", Monnam(mtmp));
X		i = rnd(8);
X		if (oseen) makeknown(POT_GAIN_LEVEL);
X		m_useup(mtmp, otmp);
X		if (!grow_up(mtmp,(struct monst *)0)) return 1;
X			/* grew into genocided monster */
X		mtmp->mhp += i;
X		mtmp->mhpmax += i;
X		return 2;
X	case MUSE_WAN_MAKE_INVISIBLE:
X		mzapmsg(mtmp, otmp, TRUE);
X		otmp->spe--;
X		mtmp->minvis = 1;
X		newsym(mtmp->mx,mtmp->my);
X		if (mtmp->wormno) see_wsegs(mtmp);
X		return 2;
X	case MUSE_POT_INVISIBILITY:
X		mquaffmsg(mtmp, otmp);
X		if (vis) pline("Gee, all of a sudden %s can't see %sself.",
X			mon_nam(mtmp),
X			humanoid(mtmp->data) ? (mtmp->female ? "her" : "him")
X					     : "it");
X		if (oseen) makeknown(POT_INVISIBILITY);
X		mtmp->minvis = 1;
X		newsym(mtmp->mx,mtmp->my);
X		if (mtmp->wormno) see_wsegs(mtmp);
X		if (otmp->cursed) {
X			mtmp->minvis = 0;
X			pline("For some reason, %s presence is known to you.",
X				s_suffix(mon_nam(mtmp)));
X			you_aggravate(mtmp);
X			mtmp->minvis = 1;
X			newsym(mtmp->mx,mtmp->my);
X		}
X		m_useup(mtmp, otmp);
X		return 2;
X	case MUSE_WAN_SPEED_MONSTER:
X		mzapmsg(mtmp, otmp, TRUE);
X		otmp->spe--;
X		if (mtmp->mspeed == MSLOW) mtmp->mspeed = 0;
X		else mtmp->mspeed = MFAST;
X		return 2;
X	case MUSE_POT_SPEED:
X		mquaffmsg(mtmp, otmp);
X		if (vismon) pline("%s is suddenly moving much faster.",
X			Monnam(mtmp));
X		if (oseen) makeknown(POT_SPEED);
X		if (mtmp->mspeed == MSLOW) mtmp->mspeed = 0;
X		else mtmp->mspeed = MFAST;
X		m_useup(mtmp, otmp);
X		return 2;
X	case MUSE_WAN_POLYMORPH:
X		mzapmsg(mtmp, otmp, TRUE);
X		otmp->spe--;
X		(void) newcham(mtmp, rndmonst());
X		if (oseen) makeknown(WAN_POLYMORPH);
X		return 2;
X#ifdef POLYSELF
X	case MUSE_POLY_TRAP:
X		if (vismon)
X		    pline("%s deliberately goes onto a polymorph trap!",
X			  Monnam(mtmp));
X		seetrap(t_at(trapx,trapy));
X
X		/*  don't use rloc() due to worms */
X		remove_monster(mtmp->mx, mtmp->my);
X		newsym(mtmp->mx, mtmp->my);
X		place_monster(mtmp, trapx, trapy);
X		if (mtmp->wormno) worm_move(mtmp);
X		newsym(trapx, trapy);
X
X		(void) newcham(mtmp, (struct permonst *)0);
X		return 2;
X#endif
X	case 0: return 0; /* i.e. an exploded wand */
X	default: impossible("%s wanted to perform action %d?", Monnam(mtmp),
X			m.has_misc);
X		break;
X	}
X	return 0;
X}
X
Xstatic void
Xyou_aggravate(mtmp)
Xstruct monst *mtmp;
X{
X	cls();
X	show_glyph(mtmp->mx, mtmp->my, mon_to_glyph(mtmp));
X	display_self();
X	You("feel aggravated at %s.", mon_nam(mtmp));
X	display_nhwindow(WIN_MAP, TRUE);
X	docrt();
X	if (unconscious()) {
X		multi = -1;
X		nomovemsg =
X		      "Aggravated, you are jolted into full consciousness.";
X	}
X}
X
Xint
Xrnd_misc_item(mtmp)
Xstruct monst *mtmp;
X{
X	struct permonst *pm = mtmp->data;
X	int difficulty = monstr[(monsndx(pm))];
X
X	if(is_animal(pm) || attacktype(pm, AT_EXPL) || mindless(mtmp->data)
X			|| pm->mlet == S_GHOST
X# ifdef KOPS
X			|| pm->mlet == S_KOP
X# endif
X		) return 0;
X	/* Unlike other rnd_item functions, we only allow _weak_ monsters
X	 * to have this item; after all, the item will be used to strengthen
X	 * the monster and strong monsters won't use it at all...
X	 */
X	if (difficulty < 6 && !rn2(30)) return WAN_POLYMORPH;
X
X	switch (rn2(7)) {
X		case 0: case 1:
X			if (mtmp->isgd) return 0;
X			return POT_SPEED;
X		case 2:
X			if (mtmp->mpeaceful && !See_invisible) return 0;
X			return WAN_MAKE_INVISIBLE;
X		case 3:
X			if (mtmp->mpeaceful && !See_invisible) return 0;
X			return POT_INVISIBILITY;
X		case 4:
X			if (mtmp->isgd) return 0;
X			return WAN_SPEED_MONSTER;
X		case 5: case 6:
X			return POT_GAIN_LEVEL;
X	}
X	/*NOTREACHED*/
X	return 0;
X}
X
Xboolean
Xsearches_for_item(mon, obj)
Xstruct monst *mon;
Xstruct obj *obj;
X{
X	int typ = obj->otyp;
X
X	if (is_animal(mon->data) || mindless(mon->data)) return FALSE;
X	return((obj->oclass == WAND_CLASS && objects[typ].oc_dir == RAY)
X		|| typ == WAN_STRIKING
X		|| (!mon->minvis &&
X			(typ == WAN_MAKE_INVISIBLE || typ == POT_INVISIBILITY))
X		|| (mon->mspeed != MFAST &&
X			(typ == WAN_SPEED_MONSTER || typ == POT_SPEED))
X		|| typ == POT_HEALING
X		|| typ == POT_EXTRA_HEALING
X		|| typ == POT_GAIN_LEVEL
X		|| (monstr[monsndx(mon->data)] < 6 && typ == WAN_POLYMORPH)
X		|| (!is_floater(mon->data) && typ == WAN_DIGGING)
X		|| typ == WAN_TELEPORTATION
X		|| typ == SCR_TELEPORTATION
X		|| typ == WAN_CREATE_MONSTER
X		|| typ == SCR_CREATE_MONSTER
X		|| typ == POT_PARALYSIS
X		|| typ == POT_BLINDNESS
X		|| typ == POT_CONFUSION
X		|| (typ == PICK_AXE && needspick(mon->data))
X	);
X}
X#endif
X
X/*muse.c*/
END_OF_FILE
if test 37553 -ne `wc -c <'src/muse.c'`; then
    echo shar: \"'src/muse.c'\" unpacked with wrong size!
fi
# end of 'src/muse.c'
fi
if test -f 'sys/amiga/Install.ami' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/amiga/Install.ami'\"
else
echo shar: Extracting \"'sys/amiga/Install.ami'\" \(16547 characters\)
sed "s/^X//" >'sys/amiga/Install.ami' <<'END_OF_FILE'
X
X	  Using, Compiling, and Installing Amiga NetHack 3.1
X      (or Everything You Never Wanted to Know Before NetHacking)
X
X	     Last Revision: 12 January 1993 for NetHack 3.1
X
X
XI. Introduction
X
XI.A. Overview
X    Welcome to Amiga NetHack!  If this is your first visit to our fair
X    city, you are in for an amazing and dangerous journey; if you have
X    visited us before, beware! the city has changed in many strange and
X    subtle ways; it has also grown quite a bit.  This missive brings to
X    light those mundane tasks which must be dealt with before beginning
X    your journey; for those of you who are faced with the task of
X    installing the pre-fabricated version of our town, section III
X    (Installing Amiga NetHack 3.1) will guide you through the task at
X    hand.  If you are ready to visit, the local visitors guide is in
X    section II (Using Amiga NetHack 3.1); please also see the general
X    guide packaged separately (the file GuideBook).  Finally, for those
X    brave souls among you who prefer to scratch-build your own models,
X    your guidance is in section IV (Compiling Amiga NetHack 3.1).
X    
X    To all our visitors, a hearty Welcome! - and please be careful.
X
X    [Those responsible for the previous paragraphs have been sacked.  The
X    documentation has been completed at great expense in a more traditional
X    style. -- The Management]
X
XI.B. Getting Help
X    If you have questions about strategy, weapons, or monsters, the best
X    place to go for help is the Usenet newsgroup rec.games.hack.  If you
X    have problems with installation or think you have found a bug in
X    the game, please report it by electronic mail to the development
X    group at nethack-bugs@linc.cis.upenn.edu, where it will be routed
X    to the appropriate person.  Include your configuration, the version of
X    NetHack you are playing, and as much specific information as possible.
X    As NetHack runs on many different machines, be sure to mention that
X    you are playing the Amiga version.  Finally, if you are having trouble
X    compiling NetHack, you may use the same address, or, for compiler
X    specific problems, send mail to:
X    	Greg Olson (golson@sundown.sun.com)  for Manx
X    	Ken Lorber (keni@oasys.dt.navy.mil) for SAS/C, or
X    	Richard Addison (addison@pollux.usc.edu) for either.
X    We do not currently have a contact for the DICE port.
X
XI.C. Credits
X    Olaf Seibert first ported NetHack 2.3 and 3.0 to the Amiga.  Richard
X    Addison, Jochen Erwied, Mark Gooderum, Ken Lorber, Greg Olson, Mike
X    Passaretti, and Gregg Wonderly polished and extended the 3.0 and 3.1
X    ports.
X
X
XII. Using Amiga NetHack 3.1
X
XII.A. Sources of Information
X    Where to go depends on what you want to find out.  If you want to find
X    out about distributing NetHack, read the license (in NetHack:license or
X    type ?i during the game).  For an introduction to NetHack, read the
X    GuideBook file.  Finally, for information during the game on all kinds
X    of things, type ? and select from the menu.
X
XII.B. The Amiga NetHack WorkBench Front End
X    The Amiga NetHack Front End looks more or less like a WorkBench
X    Drawer - and acts the same way.  Games start with double clicks and
X    menus provide more detailed control of games and defaults.  On-line
X    help is available - just press the help key.
X
X    Just as with WorkBench itself, options for games are set using the Info
X    menu item to modify Tooltypes.  Most common options can be set more 
X    easily using buttons available via Info also.
X
X    You can adjust the following using the ToolTypes from the Info command:
X
X	* OPTIONS=<options> - Options as available in the NetHack.cnf file.
X
X	* HACKDIR=<directory> - Set NetHack working directory to be this
X	  directory.
X
X	* LEVELS=<levels> - Intermediate level saving device/directory.
X
X	* PATH=<path> - To search for files such as rumors, help, etc.
X
X	* CMDLINE=<args> - Arguments as passed on the CLI command line.
X	  Note:  only the following flags are valid: n, X, D, and r.
X
X	* SCORE <options> - Display the record of scores.  Options as
X	  available on the CLI command line after a -s flag.
X
X    Note that the NetHack.cnf file is read first, then the ToolTypes.  This
X    means that the options specified in the NetHack.cnf act as defaults
X    which can be overridden by an individual's personal icon's ToolTypes.
X    Thus the system oriented entries (HACKDIR, LEVELS, and PATH) should
X    generally be set only in NetHack.cnf.  NetHack.cnf should have default
X    values for OPTIONS, which will generally be overridden by ToolTypes
X    entries.
X
X    Also, there is one additional option that may be specified in the
X    NetHack.cnf file or on an OPTIONS line: flush.  When enabled, flush
X    discards all characters in the queue except the first, which limits
X    typeahead accidents.  The default setting is noflush.
X
X    Usually, most of the confusing options will be set in the NetHack.cnf
X    file once when the game is installed and can be ignored after that.
X
XII.C. The Amiga NetHack CLI Front End
X    The CLI Front End provides the standard Unix-like command line interface
X    to NetHack.  Unlike the Unix front end however, the CLI front end will
X    ask if you want to play again before exiting.  See the ManPage file for
X    the standard Unix flags for NetHack.  In addition to those flags, Amiga
X    NetHack accepts flags -l to force non-interlaced mode and -L to force
X    interlaced mode.
X
X
XIII. Installing Amiga NetHack 3.1
X
XIII.A. General Installation
X    Installation should be easy - basically it consists of putting files
X    where they belong and adding assigns to your startup.  If you are
X    installing from the official binary distribution, simply unpacking
X    each archive in the appropriate directory will put the files in the
X    places they belong (note that the archives may have been split
X    for distribution).  If you are installing from source, most of this
X    work will be done by the time the build is finished.
X
X    IF YOU ALREADY HAVE A PREVIOUS VERSION INSTALLED YOU MUST DELETE THE
X    OLD SAVE AND BONES FILES - THEY WILL NOT WORK!
X
XWill NetHack fit on your machine?
X    NetHack 3.1 is large.  NetHack 3.1 is very large.  You will need:
X    > Amiga 500, 1000, 2000, 2500, or 3000.  The A600, A1200, and A4000
X      should work, but have not been tested.
X    > WorkBench 1.3 or 2.04.  WorkBench 1.2 will NOT work; we will NOT
X      be fixing that.  WorkBench 2.1 and 3.0 should work but have not been
X      tested.
X    > At least 2 meg of RAM.  NetHack will NOT run in 1 meg.
X    > Mass storage: NetHack will run on one floppy - but it won't be nice.
X      Two floppies are almost enough.  A hard drive with over 3 meg of
X      free space is recommended.
X
XFind space for the files
X    Floppy installation:
X	Format four disks named:
X	    NetHack
X	    HackExe
X	    NHsave
X	    NHlevels
X    Hard Disk installation:
X    	cd to wherever you want to install NetHack
X	makedir NetHack
X	makedir NetHack/save
X	makedir NetHack/levels
X	In s:User-Sequence (under 2.0 or later) or s:Startup (under 1.3),
X	assign NetHack: to the NetHack directory you created above.
X	assign HackExe: to the same directory.
XInstall the files
X    Unpack the archives in the directories or onto the disks (you can
X    tell what to unpack where by the file names).  Use the table in the
X    next section to see where things should end up.  Be sure that the
X    file 8 ends up in NetHack:hack/8.
X
XConfiguration
X    Using your favorite text editor, edit NetHack:NetHack.cnf to match
X    your system.  Check HackExe:NetHack.dir and be sure that the paths
X    are correct.  The HackWB program uses several standard Amiga programs
X    that must be installed in their standard places: c:copy, c:rename.
X
XIII.B. File Location Table
X    NetHack:
X	A-filla.lev	A-fillb.lev	A-goal.lev	A-locate.lev
X	A-start.lev	air.lev		asmodeus.lev	astral.lev
X	B-filla.lev	B-fillb.lev	B-goal.lev	B-locate.lev
X	B-start.lev	baalz.lev	bigroom.lev	C-filla.lev
X	C-fillb.lev	C-goal.lev	C-locate.lev	C-start.lev
X	castle.lev	cmdhelp		data		default.icon
X	dungeon		E-filla.lev	E-fillb.lev	E-goal.lev
X	E-locate.lev	E-start.lev	earth.lev	fakewiz1.lev
X	fakewiz2.lev	fire.lev	Guidebook	Guidebook.info
X	H-filla.lev	H-fillb.lev	H-goal.lev	H-locate.lev
X	H-start.lev	hack/8		hack.font	HackWB
X	HackWB.info	HackCli		help		hh
X	history		juiblex.lev	K-filla.lev	K-fillb.lev
X	K-goal.lev	K-locate.lev	K-start.lev	knox.lev
X	license		logfile		ManPage		ManPage.info
X	medusa-1.lev	medusa-2.lev	minefill.lev	minetown.lev
X	mine_end.lev	NetHack.cnf	NetHack.c01	NetHack.d00
X	news		NewGame.info	opthelp		options
X	oracle.lev	oracles		orcus.lev	P-filla.lev
X	P-fillb.lev	P-goal.lev	P-locate.lev	P-start.lev
X	perm		quest.dat	R-filla.lev	R-fillb.lev
X	R-goal.lev	R-locate.lev	R-start.lev	ReadMe
X	ReadMe.info	record		recover		rumors
X	S-filla.lev	S-fillb.lev	S-goal.lev	S-locate.lev
X	S-start.lev	sanctum.lev	T-filla.lev	T-fillb.lev
X	T-goal.lev	T-locate.lev	T-start.lev	tower1.lev
X	tower2.lev	tower3.lev	V-filla.lev	V-fillb.lev
X	V-goal.lev	V-locate.lev	V-start.lev	valley.lev
X	W-filla.lev	W-fillb.lev	W-goal.lev	W-locate.lev
X	W-start.lev	water.lev	wizard1.lev	wizard2.lev
X	wizard3.lev	wizhelp
X
X    HackExe:
X	NetHack.dir
X	NetHack.c00
X
X
XIV. Compiling Amiga NetHack 3.1
X
XIV.A. Compilation Overview
X    Compiling NetHack is not very hard - basically you do a little
X    configuration and start make.  It does, however, require a good amount
X    of disk space - almost 7 meg (and subject to change; more if you are
X    not doing the simple compile - more on that later).  It also needs a
X    good bit of memory.
X
XIV.B. Basic Compilation
X    NetHack can be built with SAS/C version 5.10b, Manx/Aztec version 5,
X    or the registered version of DICE.  The "official" compiler for NetHack 3.1
X    patchlevel 0 is SAS/C 5.10b - we expect to be moving to SAS/C version 6.2
X    after it is released (6.0 was not available soon enough to gain our
X    confidence for releasing binaries based on it).  The game will compile
X    under SAS/C 6.x with small changes.
X
XIV.B.1. Introduction to Compiling NetHack
X    Before doing any compilation, read the README files distributed
X    with the source.  These should familiarize you with the source tree
X    layout, and what files are shared with what computers.  Generally,
X    everything in the sys/amiga directory is used exclusively by the Amiga.
X
X    The makefile (Makefile.ami) is set up to depend upon certain assignments,
X    providing the developer with a fairly flexible environment.  See
X    makefile.ami for assignment assumptions.
X
X    Edit config.h to your liking and system configuration.  The following
X    need to be checked:
X
X	UNIX - undef
X	MACROCPATH - undef
X	HACKDIR - define as "NetHack:"
X
X    For SAS/C 6.x, in config.h, make sure that '#define NEARDATA' is used
X    and not '#define NEARDATA __near'.  The v5 compiler recognizes a
X    different syntax than the v6 compiler for this construct. You will
X    need to build without __near for now to get around this problem.
X
X    At this point, you're almost ready to begin a compile.  Read VERY
X    CAREFULLY through the Makefile to familiarize yourself with which
X    assignments are assumed.  Otherwise, you're going to get something
X    like "Insert NHS: in any drive." requestors.  You will need the
X    programs uudecode, flex, and bison.  Be sure the p bit is set in
X    the permissions for ifchange.  The first thing Makefile.ami does
X    is build a program called 'makedefs', which handles a variety of
X    data file generation, and a pair of programs called 'lev_comp' and
X    'dgn_comp' which compile the special levels.  Makedefs will then be
X    run to create a few files, followed by an alphabetically sorted
X    compilation of the entire source tree.  This compilation process
X    will compile selected files from the Amiga:, Share:, and NHS:
X    directories.  If all goes well, all of the  objects will be linked
X    together to form a binary.  After building the main binary, a make
X    install will build the auxiliary files including help files, special
X    levels, icons, and the font files and will put these files into their
X    final positions.  The first make run should be done in OBJ: and the
X    make install should be done in NetHack:; for both runs, the makefile
X    is Amiga:Makefile.ami.
X
X    For SAS/C 6.x: in Makefile.ami, comment out the SAS5 macros and
X    uncomment the SAS6 macros.
X
X    Note that not all the source is simple C code.  If you are modifying
X    lev_comp or dgn_comp you may need bison and/or flex (depending on what
X    modifications you are making).  If you wish to modify the Intuition
X    windows in HackWB, the (uuencoded) PowerWindows files are provided.  You
X    do not need any of these tools to simply build NetHack - all the C output
X    files are provided in the source distribution.  Also, the ifchange
X    script requires a version of diff that produces standard Unix format
X    context diffs for proper operation - the version shipped with SASC
X    is not sufficient.
X
X    If you do not have bison and flex, copy the files from Share:.  The
X    include files go in incl: and the C files go in util:.  If the compile
X    fails due to prototype errors for malloc and realloc, try deleting
X    the first line of lev_comp.c and dgn_comp.c.
X
XIV.B.2. Compiling NetHack with SAS/C version 5
X
X    NOTE WELL - Amiga NetHack will be dropping support for SAS/C version 5
X    and moving to SAS/C version 6 almost immediately.  Upgrade now!  You
X    have been warned.
X
X    This version of NetHack was developed with SAS/C 5.10b and SAS/C 6.1.
X    Earlier versions of the compiler are known to cause problems - don't
X    use them.
X
X    A couple of notes and warnings from the SAS/C users on the team:
X
X	* Included in the SAS/C port is code for generating a SnapShot.tb
X	  file upon catching various internal disasters.  That is why the
X	  -d1 flag is in the makefile.  This adds about 270K to the disk
X	  image, but it does not increase the run time memory requirements.
X          (But note that this is not useful for split binaries - see below.)
X
X	* The 5.10b optimizer does not produce correct code for NetHack.
X
X	* There are a large number of warnings under SAS/C, which are
X	  harmless.
X
X	* Some versions of flex produce #line statements with the file name
X	  in quotes: version 5.10b doesn't like this.  For some reason lc tries
X	  to access this file, which results in a bogus requestor for "Util:
X	  (yes, there is one quote mark in front of Util:) - select cancel
X	  and ignore the problem or add -L to the FLEX definition in
X	  Makefile.ami.  SAS says that this will be fixed in 6.0.
X
XIV.B.3. Compiling NetHack with SAS/C version 6
X    Very simliar to compiling under version 5 except all the command lines
X    are different - see the Makefile.  Also, see the note above about
X    NEARDATA.
X
XIV.B.4. Compiling NetHack with Manx/Aztec version 5
X    The Manx port has not been tested recently and is probably broken.  We
X    expect to have it back in shape soon but we welcome context diffs.  As
X    of the last check, NetHack required version 5.0B of the compiler.  
X
XIV.B.5	Compiling NetHack with the registered version of DICE
X    The DICE port was complete at one point but has not been tested in
X    several months - it probably will not work as is.  We welcome context
X    diffs (or volunteers) to fix it.
X
XIV.C. Advanced Compilation
X    As mentioned above, NetHack is very large.  There are several
X    techniques under development by the Amiga NetHack Team for dealing
X    with the situation.  As they are completed, they will be documented
X    here.  Before attempting any of them, you MUST do a "normal" build
X    as documented above; the techniques described below require the
X    auxiliary files from a normal build to form a complete NetHack
X    installation.
X
XIV.C.1 Splitter
X    Splitter addresses two problems with NetHack: first, the long startup
X    time of the game, and second, the size of the binary (which will not fit
X    on a single disk).  See the file split/split.doc for information on
X    splitter.  The normal install target in Makefile.ami will build the
X    split version of NetHack as part of the normal install process; the
X    front ends will run from either the normal version (HackExe:NetHack) or,
X    preferably, from the split version (NetHack.c#?  NetHack.d#?) - the
X    decision is based on the presence (or absence) of HackExe:NetHack.dir.
X    Note that the contents of NetHack.dir after a build will generally not
X    be the correct contents for a floppy based system.
X   
END_OF_FILE
if test 16547 -ne `wc -c <'sys/amiga/Install.ami'`; then
    echo shar: \"'sys/amiga/Install.ami'\" unpacked with wrong size!
fi
# end of 'sys/amiga/Install.ami'
fi
echo shar: End of archive 45 \(of 108\).
cp /dev/null ark45isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \
21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \
41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 \
61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 \
81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 \
101 102 103 104 105 106 107 108 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 108 archives.
    echo "Now execute 'rebuild.sh'"
    rm -f ark10[0-8]isdone ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
