Path: uunet!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v16i076:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Part68/108
Message-ID: <4379@master.CNA.TEK.COM>
Date: 1 Feb 93 19:51:36 GMT
Sender: news@master.CNA.TEK.COM
Lines: 1882
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1626

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 16, Issue 76
Archive-name: nethack31/Part68
Supersedes: nethack3p9: Volume 10, Issue 46-102
Environment: Amiga, Atari, Mac, MS-DOS, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 68 (of 108)."
# Contents:  dat/rumors.tru src/rect.c src/zap.c1
# Wrapped by billr@saab on Wed Jan 27 16:09:13 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'dat/rumors.tru' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dat/rumors.tru'\"
else
echo shar: Extracting \"'dat/rumors.tru'\" \(19319 characters\)
sed "s/^X//" >'dat/rumors.tru' <<'END_OF_FILE'
XA blindfold can be very useful if you're telepathic.
XA candelabrum affixed with seven candles shows the way with a magical light.
XA crystal plate mail will not rust.
XA katana might slice a worm in two.
XA magic vomit pump could be useful for gourmands.
XA nymph knows how to unlock chains.
XA potion of blindness lets you see invisible things.
XA priest can get the gods to listen easily.
XA priest can go to hell just like the rest of us.
XA priestess and a virgin you might be, but that unicorn won't care.
XA ring of conflict is a bad thing if there is a nurse in the room.
XA short sword is not as good as a long sword.
XA succubus will go farther than a nymph.
XAcid blobs should be attacked bare-handed.
XAffairs with nymphs are often very expensive.
XAfraid of nymphs?  Wear a ring of adornment.
XAfraid of your valuables being stolen?  Carry more junk!
XAlways be aware of the phase of the moon!
XAlways sweep the floor before engraving important messages.
XAmulets are hard to make.  Even for a wand of wishing.
XAn elven cloak protects against magic.
XAn umber hulk can be a confusing sight.
XAsking about monsters may be very useful.
XAttack long worms from the rear -- that is so much safer!
XAttacking an eel where there is none is usually a fatal mistake!
XBashing monsters with a bow is not such a good idea.
XBe careful!  The Wizard may plan an ambush!
XBe nice to a nurse:  Put away your weapon and take off your clothes.
XBeing digested is a painfully slow process.
XBlank scrolls make more interesting reading.
XBlind?  Catch a floating eye!
XBooksellers never read scrolls; they might get carried away.
XConcise conquest:  Control, confuse, conjure, condemn.
XDilithium crystals are rare indeed.
XDogs are attracted by the smell of tripe.
XDogs are superstitious; they never step on cursed items.
XDogs of ghosts aren't angry, just hungry.
XDon't bother about money:  only leprechauns and shopkeepers are interested.
XDon't forget!  Large dogs are MUCH harder to kill than little dogs.
XDon't mess with shopkeepers, or you'll get the Guild after you.
XDragons never whip their children; they wouldn't feel it!
XEat your carrots.  They're good for your eyes.
XEating a freezing sphere is like eating a yeti.
XEating a killer bee is like eating a scorpion.
XEating a tengu is like eating a nymph.
XEating a wraith is a rewarding experience!
XEating unpaid leprechauns may be advantageous.
XElbereth has quite a reputation around these parts.
XElf has extra speed.
XElven cloaks cannot rust.
XEver fought with an enchanted tooth?
XEver tried reading while confused?
XEver tried to put a troll into a large box?
XEver wondered why one would want to dip something in a potion?
XExpensive cameras have penetrating flash lights.
XExtra staircases lead to extra levels.
XFiery letters might deter monsters.
XGems are too precious to be thrown away carelessly.
XGetting hungry?  Stop wearing rings!
XGods expect the best from their priesthood.
XGods look down their noses at demigods.
XHandle your flasks carefully -- there might be a ghost inside!
XHoly water has many uses.
XHunger is a confusing experience for a dog!
XI once knew a hacker who ate too fast and choked to death.
XI smell a maze of twisty little passages.
XI wish I never wished a wand of wishing.  (Wishful thinking.)
XI wouldn't advise playing catch with a giant.
XI'm watching you.  -- The Wizard of Yendor
XIce boxes keep your food fresh.
XIf you are being punished, it's done with a deadly weapon.
XIf you kill the Wizard, you get promoted to demi-god.
XIf you need a wand of digging, kindly ask the minotaur.
XIf you want a sex change, you must get it before the game.
XIf you want to hit, use a dagger.
XIf you want to rob a shop, train your dog.
XIf you're lost, try buying a map next time you're in a shop.
XInside a shop you better take a look at the price tags before buying anything.
XIt is bad manners to use a wand in a shop.
XIt is dangerous to visit a graveyard at midnight.
XIt is not always a good idea to whistle for your dog.
XIt is rumored that the Wizard has hired some help.
XIt might be a good idea to offer the unicorn a ruby.
XIt would be peculiarly sad were your dog turned to stone.
XKeep your armors away from rust.
XKeep your weaponry away from acids.
XKill a unicorn of your color and you kill your luck.
XLeather is waterproof.  Ever see a cow with an umbrella?
XLeprechauns are the most skilled cutpurses in this dungeon.
XLizard corpses protect against cockatrices.
XMost monsters can't swim.
XMusic hath charms to affect the stubborn drawbridge.
XMusic hath charms to soothe the savage beast.
XNever attack a guard.
XNever ride a long worm.
XNever use your best weapon to engrave a curse.
XNo easy fighting with a heavy load!
XNurses are accustomed to touch naked persons:  they don't harm them.
XNymphs can unlink more than your chain mail.
XOnce your little dog will be a big dog, and you will be proud of it.
XOpening a tin is difficult, especially when you attempt it bare handed!
XOrcs and killer bees share their lifestyle.
XOrcs do not procreate in dark rooms.
XPlain nymphs are harmless.
XPlaying AD&D may be helpful.
XPlaying Gauntlet might be enlightening in some situations.
XPlaying billiards pays when you are in a shop.
XPolymorphing a shopkeeper might make you safer.
XPolymorphing your dog probably makes you safer.
XPotions don't usually mix, but sometimes...
XPsst!  It's done with mirrors!
XPut on a ring of teleportation:  it will take you away from onslaught.
XRays aren't boomerangs, of course, but still...
XRead the manual before entering the cave -- you might get killed otherwise.
XReading Herbert might be enlightening in one case.
XReading Tolkien might help you.
XReading scrolls after drinking booze can give confusing results.
XRust monsters love water.  There are potions they hate, however.
XShopkeepers accept credit cards, as long as you pay cash.
XShopkeepers can spot a tourist a mile away with those Hawaiian shirts.
XShopkeepers can't read, so what use is engraving in a shop?
XShopkeepers can't swim.
XShopkeepers can't tell identical twins apart.
XShopkeepers have incredible patience.
XShopkeepers might raise their prices for tourists.
XShopkeepers value money more than revenge.
XSome monsters can be tamed.  I once saw a hacker with a tame dragon!
XSomeone's been spiking the pits!
XSometimes monsters are more likely to fight each other than attack you.
XSpinach, carrot, and a melon -- a meal fit for a nurse!
XTainted meat is even more sickening than poison!
XTelepathy is just a trick:  once you know how to do it, it's easy.
XThe darker the warning, the more dire the danger.
XThe Leprechaun Gold Tru$t is no division of the Magic Memory Vault.
XThe Wizard finds death to be quite an experience.
XThe best equipment for your work is, of course, the most expensive.
XThe gods don't appreciate pesky priesthood.
XThe moon is not the only heavenly body to influence this game.
XThe orc swings his two handed sword named Elfrist at you.  You die...
XThe secret of wands of Nothing Happens:  try again!
XThere has always been something mystical about mirrors.
XThere is a Mastermind deep in the dungeon.
XThere is a big treasure hidden in the zoo!
XThere is more magic in this cave than meets the eye.
XThere is no harm in praising a large dog.
XThere is nothing like eating a mimic.
XThey say a gelatinous cube can paralyze you...
XThey say that Juiblex is afraid of a wand of digging.
XThey say that Medusa would like to put you on a pedestal.
XThey say that Vlad lives!!! ... in the mazes.
XThey say that `Elbereth' is often written about.
XThey say that a bag of holding can't hold everything.
XThey say that a blessed tin of quasit meat is a quick meal.
XThey say that a cat avoids traps.
XThey say that a cave spider will occasionally eat cave spider eggs.
XThey say that a clever wizard can have stats:  18/** 24 18 24 24 24.
XThey say that a clove of garlic makes a good talisman if handled right.
XThey say that a cursed scroll of teleportation could land you in trouble.
XThey say that a diamond is another kind of luck stone.
XThey say that a dog can be trained to fetch objects.
XThey say that a gelatinous cube makes a healthy breakfast.
XThey say that a giant gets strong by eating right, try it!
XThey say that a grid bug won't hit you when you cross it.
XThey say that a lembas wafer is a very light snack.
XThey say that a loadstone has a strange attraction and is not bad luck.
XThey say that a lock pick by any other name is still a lock pick.
XThey say that a lucky amulet will block poisoned arrows.
XThey say that a mirror will freeze a floating eye but you can still see it.
XThey say that a neutral character would get either Fire or Frost Brand.
XThey say that a polymorph trap is magic and magic protection prevents it.
XThey say that a potion of healing can cancel a potion of sickness.
XThey say that a potion of monster detection sometimes works both ways.
XThey say that a sink looks different from high above the floor.
XThey say that a summoned demon could improve your game.
XThey say that a tin of wraith meat is a rare dining experience.
XThey say that a unicorn might bring you luck.
XThey say that a wand of cancellation is like a wand of polymorph.
XThey say that a wand of locking can close more than just doors.
XThey say that a wand of polymorph can change your game.
XThey say that a wizard is even more powerful the second time around.
XThey say that a xorn knows of no obstacles when pursuing you.
XThey say that abusing a credit card could shock you sooner or later.
XThey say that amulets, like most things, can be deadly or life saving.
XThey say that an altar can identify blessings.
XThey say that an ooze will bite your boots and a rockmole will eat them.
XThey say that an unlucky hacker was once killed by an exploding tin.
XThey say that antique dealers are always interested in precious stones.
XThey say that booze can be diluted but not cancelled.
XThey say that by listening carefully, you can hear a secret door!
XThey say that carrots and carrot juice may improve your vision.
XThey say that cave spiders are not considered expensive health food.
XThey say that demigods must leave behind their prized earthly possessions.
XThey say that disturbing a djinni can be a costly mistake.
XThey say that dragon scales can be quite enchanting.
XThey say that dropping coins into a fountain will not grant you a wish.
XThey say that dwarves lawfully mind their own business.
XThey say that eating a bat corpse will make you batty, for awhile.
XThey say that eating a cram ration is a smart move.
XThey say that eating blue jelly is cool if you don't fight the feeling.
XThey say that escaping a dungeon is only the beginning of the end.
XThey say that feeling an unexpected draft of air is sort of a breakthrough.
XThey say that finding a cursed gray stone is always bad luck.
XThey say that for a good time engrave `Elbereth'.
XThey say that gaining a level is an experience that can raise your sights.
XThey say that garter snake meat rarely tastes good but it's still healthy.
XThey say that gauntlets of dexterity have a hidden enchanted touch.
XThey say that going to heaven is just another way of escaping the dungeon.
XThey say that golden nagas are law-abiding denizens as long as you are too.
XThey say that gremlins can make you feel cooler than you are now.
XThey say that grid bugs only exist in a strictly Cartesian sense.
XThey say that hackers often feel jumpy about eating nymphs.
XThey say that having polymorph control won't shock you.
XThey say that hell hath no fury like Medusa scorned.
XThey say that if it's hard getting your food down another bite could kill.
XThey say that if you don't wear glasses why bother with carrots?
XThey say that if you notice a loose board beneath you, don't step on it.
XThey say that if you start at the bottom the only place to go is up.
XThey say that if you teleport to heaven you're presumed to be dead already.
XThey say that in a shop you can be charged for old charges.
XThey say that in lighter moments you could think of ways to pass a stone.
XThey say that in the dungeon breaking a mirror can be seven years bad luck.
XThey say that in the dungeon you don't usually have any luck at all.
XThey say that in time a blessed luckstone can make your god happy.
XThey say that it is easier to kill the Wizard than to make him stand still.
XThey say that it only takes 1 zorkmid to meet the Kops.
XThey say that it's a blast when you mix the right potions together.
XThey say that it's not blind luck if you catch a glimpse of Medusa.
XThey say that killing a shopkeeper brings bad luck.
XThey say that monsters never step on a scare monster scroll.
XThey say that most monsters find flute recitals extremely boring.
XThey say that mummy corpses are not well preserved.
XThey say that naturally a wand of wishing would be heavily guarded.
XThey say that no one notices the junk underneath a boulder.
XThey say that nobody expects a unicorn horn to rust.
XThey say that nobody knows if an explorer can live forever.  Do you?
XThey say that nothing can change the fact that some potions contain a djinni.
XThey say that nothing can change the fact that some potions contain a ghost.
XThey say that nymphs always fall for rock'n'roll, try it!
XThey say that once an Olog-Hai is canned it never shows its face again.
XThey say that once upon a time xans would never scratch your boots.
XThey say that only an experienced wizard can do the tengu shuffle.
XThey say that only chaotics can kill shopkeepers and get away with it.
XThey say that playing a horn really bad is really good.
XThey say that rubbing a glowing potion does not make it a magic lamp.
XThey say that scalpels become dull because they're not athames.
XThey say that shopkeepers don't like pick-axes.
XThey say that shopkeepers don't mind you bringing your pets in the shop.
XThey say that shopkeepers don't usually mind if you sneak into a shop.
XThey say that shopkeepers often have a large amount of money in their purses.
XThey say that shopkeepers often remember things that you might forget.
XThey say that sinks and armor don't mix, take your cloak off now!
XThey say that sinks run hot and cold and many flavors in between.
XThey say that snake charmers aren't charismatic, just musical.
XThey say that soldiers are always prepared and usually protected.
XThey say that some eggs could hatch in your pack, lucky or not.
XThey say that some fire ants will make you a hot meal.
XThey say that some horns play hot music and others are too cool for words.
XThey say that some humanoids are nonetheless quite human.
XThey say that some shopkeepers consider gems to be family heirlooms.
XThey say that some shopkeepers recognize gems but they won't tell you.
XThey say that some stones are much much heavier than others.
XThey say that some yetis are full of hot air.
XThey say that something very special would be in a well-protected place.
XThey say that speed boots aren't fast enough to let you walk on water.
XThey say that teleport traps are the devil's work.
XThey say that tengus don't wear rings, why should you?
XThey say that tengus never steal gold although they would be good at it.
XThey say that that which was stolen once can be stolen again, ask any nymph.
XThey say that the Delphic Oracle knows that lizard corpses aren't confusing.
XThey say that the Hand of Elbereth can hold up your prayers.
XThey say that the Leprechaun King is rich as Croesus.
XThey say that the Wizard of Yendor is schizophrenic and suicidal.
XThey say that the experienced character knows how to convert an altar.
XThey say that the gods are happy when they drop objects at your feet.
XThey say that the idea of invisible Nazguls has a certain ring to it.
XThey say that the lady of the lake now lives in a fountain somewhere.
XThey say that the local shopkeeper frowns upon the rude tourist.
XThey say that the only door to the vampire's tower is on its lowest level.
XThey say that the only good djinni is a grateful djinni.
XThey say that the road through hell is a one-way street.
XThey say that the road to hell begins with Medusa.
XThey say that the thing about genocide is that it works both ways.
XThey say that the unicorn horn rule is if it ain't broke then don't fix it.
XThey say that the view from a fog cloud is really very moving.
XThey say that the walls in shops are made of extra hard material.
XThey say that there are at least 15 ways to lose a pair of levitation boots.
XThey say that throwing glass gems is the same as throwing rocks.
XThey say that trespassing a boulder is probably beneath you.
XThey say that unicorns are fond of precious gems.
XThey say that prayer at an altar can sometimes make the water there holy.
XThey say that what goes down the drain might come back up.
XThey say that wielded, a long sword named Fire Brand makes you feel cooler.
XThey say that wielded, a long sword named Frost Brand makes you hot stuff.
XThey say that wiping its face is impossible for a floating eye.
XThey say that with a floating eye you could see in the dark.
XThey say that you are lucky if you can get a unicorn to catch a ruby.
XThey say that you are what you eat.
XThey say that you can find named weapons at an altar if you're lucky.
XThey say that you can safely touch cockatrices eggs but why bother?
XThey say that you can't break an amulet of reflection.
XThey say that you don't always get what you wish for.
XThey say that you might find broken smoky potions in the morgue.
XThey say that you should always be prepared for a final challenge.
XThey say that you should ask a dwarf to let you into a locked shop.
XThey say that you should pray for divine inspiration.
XThey say that you should religiously give your gold away.
XThey say that you will never get healthy by eating geckos.
XThey say that zapping yourself with a wand of undead turning is stupid.
XThey say the Wizard's castle is booby-trapped!
XThey say the gods get angry if you pray too much.
XThey say the shopkeepers are insured by Croesus himself!
XThey say there is a powerful magic item hidden in a castle deep down!
XThose who wield a cockatrice corpse have a rocky road ahead of them.
XThrowing food at a wild dog might tame him.
XTo a full belly all food is bad.
XTrolls are described as rubbery:  they keep bouncing back.
XTry the fall-back end-run play against ghosts.
XTry using your magic marker on wet scrolls.
XValkyries come from the north, and have commensurate abilities.
XVampires hate garlic.
XVault guards never disturb their Lords.
XVisitors are requested not to apply genocide to shopkeepers.
XWarning:  people who eat red dragons can go to hell!
XWatch out, the Wizard might come back.
XWater traps have no effect on dragons.
XWhat is a cockatrice going to eat when it gets hungry?
XWhere do you think all those demons come from?  From hell, of course.
XWhere do you think hell is located?  It must be deep, deep down.
XWhy do you suppose they call them MAGIC markers?
XWhy would anybody in his sane mind engrave "Elbereth"?
XWishing too much may bring you too little.
XYou can't leave a shop through the back door:  there ain't one!
XYou may discover a fine spirit inside a potion bottle.
XYou may want to dip into a potion of bottled blessings.
XYou might be able to bribe a demon lord.
XYou might trick a shopkeeper if you're invisible.
XYou should certainly learn about quantum mechanics.
XYou're going into the morgue at midnight???
XYour dog knows what to eat; maybe you should take lessons.
XZap yourself and see what happens...
XZapping a wand of undead turning might bring your dog back to life.
END_OF_FILE
if test 19319 -ne `wc -c <'dat/rumors.tru'`; then
    echo shar: \"'dat/rumors.tru'\" unpacked with wrong size!
fi
# end of 'dat/rumors.tru'
fi
if test -f 'src/rect.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/rect.c'\"
else
echo shar: Extracting \"'src/rect.c'\" \(3667 characters\)
sed "s/^X//" >'src/rect.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)rect.c	3.1	90/22/02 */
X/* Copyright (c) 1990 by Jean-Christophe Collet	 */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include "hack.h"
X
Xint FDECL(get_rect_ind, (NhRect *));
X
Xstatic boolean FDECL(intersect, (NhRect *,NhRect *,NhRect *));
X
X    /* 
X     * In this file, we will handle the various rectangle functions we
X     * need for room generation.
X     */
X
X#define	MAXRECT	50
X#define XLIM	4
X#define YLIM	3
X
Xstatic NhRect rect[MAXRECT+1];
Xstatic int rect_cnt;
X
X/* 
X * Initialisation of internal structures. Should be called for every
X * new level to be build...
X */
X
Xvoid
Xinit_rect()
X{
X	rect_cnt = 1;
X	rect[0].lx = rect[0].ly = 0;
X	rect[0].hx = COLNO - 1;
X	rect[0].hy = ROWNO - 1;
X}
X
X/* 
X * Search Index of one precise NhRect.
X * 
X */
X
Xint
Xget_rect_ind(r)
XNhRect *r;
X{
X	register NhRect *rectp;
X	register int lx, ly, hx, hy;
X	register int i;
X
X	lx = r->lx; ly = r->ly;
X	hx = r->hx; hy = r->hy;
X	for (i=0,rectp = &rect[0];i<rect_cnt;i++,rectp++)
X	    if ( lx == rectp->lx && ly == rectp->ly &&
X		 hx == rectp->hx && hy == rectp->hy)
X		return i;
X	return -1;
X}
X
X/* 
X * Search a free rectangle that include the one given in arg
X */
X
XNhRect *
Xget_rect(r)
XNhRect *r;
X{
X	register NhRect *rectp;
X	register int lx, ly, hx, hy;
X	register int i;
X
X	lx = r->lx; ly = r->ly;
X	hx = r->hx; hy = r->hy;
X	for (i=0,rectp = &rect[0];i<rect_cnt;i++,rectp++)
X	    if ( lx >= rectp->lx && ly >= rectp->ly &&
X		 hx <= rectp->hx && hy <= rectp->hy)
X		return rectp;
X	return 0;
X}
X
X/* 
X * Get some random NhRect from the list.
X */
X
XNhRect *
Xrnd_rect()
X{
X	    return rect_cnt > 0 ? &rect[rn2(rect_cnt)] : 0;
X}
X
X/* 
X * Search intersection between two rectangles (r1 & r2).
X * return TRUE if intersection exist and put it in r3.
X * otherwise returns FALSE
X */
X
Xstatic boolean
Xintersect(r1, r2, r3)
XNhRect *r1, *r2, *r3;
X{
X	if (r2->lx > r1->hx || r2->ly > r1->hy ||
X	    r2->hx < r1->lx || r2->hy < r1->ly)
X	    return FALSE;
X
X	r3->lx = (r2->lx > r1->lx ? r2->lx : r1->lx);
X	r3->ly = (r2->ly > r1->ly ? r2->ly : r1->ly);
X	r3->hx = (r2->hx > r1->hx ? r1->hx : r2->hx);
X	r3->hy = (r2->hy > r1->hy ? r1->hy : r2->hy);
X
X	if (r3->lx > r3->hx || r3->ly > r3->hy)
X	    return FALSE;
X	return TRUE;
X}
X
X/* 
X * Remove a rectangle from the list of free NhRect.
X */
X
Xvoid
Xremove_rect(r)
XNhRect *r;
X{
X	int ind;
X
X	ind = get_rect_ind(r);
X	if ( ind >=0 )
X	    rect[ind] = rect[--rect_cnt];
X}
X
X/* 
X * Add a NhRect to the list.
X */
X
Xvoid
Xadd_rect(r)
XNhRect *r;
X{
X	if (rect_cnt >= MAXRECT) {
X#ifdef WIZARD
X		if (wizard) pline("MAXRECT may be too small.");
X#endif
X		return;
X	}
X	/* Check that this NhRect is not included in another one */
X	if (get_rect(r))
X	    return;
X	rect[rect_cnt] = *r;
X	rect_cnt++;
X}
X
X/* 
X * Okay, here we have two rectangles (r1 & r2).
X * r1 was already in the list and r2 is included in r1.
X * What we want is to allocate r2, that is split r1 into smaller rectangles
X * then remove it.
X */
X
Xvoid
Xsplit_rects(r1, r2)
XNhRect *r1, *r2;
X{
X	NhRect r, old_r;
X	int i;
X
X	old_r = *r1;
X	remove_rect(r1);
X
X	/* Walk down since rect_cnt & rect[] will change... */
X	for (i=rect_cnt-1; i>=0; i--)
X	    if (intersect(&rect[i], r2, &r))
X		split_rects(&rect[i], &r);
X	
X	if (r2->ly - old_r.ly-1 > (old_r.hy < ROWNO - 1 ? 2*YLIM : YLIM+1)+4) {
X		r = old_r;
X		r.hy = r2->ly - 2;
X		add_rect(&r);
X	}
X	if (r2->lx - old_r.lx-1 > (old_r.hx < COLNO - 1 ? 2*XLIM : XLIM+1)+4) {
X		r = old_r;
X		r.hx = r2->lx - 2;
X		add_rect(&r);
X	}
X	if (old_r.hy - r2->hy-1 > (old_r.ly > 0 ? 2*YLIM : YLIM+1)+4) {
X		r = old_r;
X		r.ly = r2->hy + 2;
X		add_rect(&r);
X	}
X	if (old_r.hx - r2->hx-1 > (old_r.lx > 0 ? 2*XLIM : XLIM+1)+4) {
X		r = old_r;
X		r.lx = r2->hx + 2;
X		add_rect(&r);
X	}
X}
X
X/*rect.c*/
END_OF_FILE
if test 3667 -ne `wc -c <'src/rect.c'`; then
    echo shar: \"'src/rect.c'\" unpacked with wrong size!
fi
# end of 'src/rect.c'
fi
if test -f 'src/zap.c1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/zap.c1'\"
else
echo shar: Extracting \"'src/zap.c1'\" \(31925 characters\)
sed "s/^X//" >'src/zap.c1' <<'END_OF_FILE'
X/*	SCCS Id: @(#)zap.c	3.1	92/10/21	*/
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include "hack.h"
X
X/* Disintegration rays have special treatment; corpses are never left.
X * But the routine which calculates the damage is separate from the routine
X * which kills the monster.  The damage routine returns this cookie to
X * indicate that the monster should be disintegrated.
X */
X#define MAGIC_COOKIE 1000
X
Xstatic boolean NEARDATA obj_zapped;
Xstatic int NEARDATA poly_zapped;
X
X#ifdef MUSE
X/* kludge to use mondied instead of killed */
Xextern boolean m_using;
X#endif
X
Xstatic boolean FDECL(obj_resists, (struct obj *));
Xstatic boolean FDECL(obj_shudders, (struct obj *));
Xstatic void FDECL(polyuse,(struct obj*, int, int));
Xstatic void FDECL(do_osshock, (struct obj *));
Xstatic void FDECL(create_polymon, (struct obj *));
Xstatic int FDECL(burn_floor_paper,(int,int));
Xstatic void FDECL(cancel_item,(struct obj *));
Xstatic int FDECL(bhitm, (struct monst *,struct obj *));
X#ifndef MUSE
XSTATIC_PTR int FDECL(bhito,(struct obj *,struct obj *));
X#endif
XSTATIC_PTR int FDECL(bhitpile,(struct obj *,int (*)(OBJ_P,OBJ_P),int,int));
Xstatic void FDECL(backfire,(struct obj *));
Xstatic int FDECL(zhit,(struct monst *,int,int));
X
X#define ZT_MAGIC_MISSILE	(AD_MAGM-1)
X#define ZT_FIRE			(AD_FIRE-1)
X#define ZT_COLD			(AD_COLD-1)
X#define ZT_SLEEP		(AD_SLEE-1)
X#define ZT_DEATH		(AD_DISN-1)	/* or disintegration */
X#define ZT_LIGHTNING		(AD_ELEC-1)
X#define ZT_POISON_GAS		(AD_DRST-1)
X#define ZT_ACID			(AD_ACID-1)
X/* 8 and 9 are currently unassigned */
X
X#define ZT_WAND(x)		(x)
X#define ZT_SPELL(x)		(10+(x))
X#define ZT_BREATH(x)	(20+(x))
X
Xconst char *fl[]= {
X	"magic missile",	/* Wands must be 0-9 */
X	"bolt of fire",
X	"bolt of cold",
X	"sleep ray",
X	"death ray",
X	"bolt of lightning",
X	"",
X	"",
X	"",
X	"",
X
X	"magic missile",	/* Spell equivalents must be 10-19 */
X	"fireball",
X	"cone of cold",
X	"sleep ray",
X	"finger of death",
X	"bolt of lightning",
X	"",
X	"",
X	"",
X	"",
X
X	"blast of missiles",	/* Dragon breath equivalents 20-29*/
X	"blast of fire",
X	"blast of frost",
X	"blast of sleep gas",
X	"blast of disintegration",
X	"blast of lightning",
X	"blast of poison gas",
X	"blast of acid",
X	"",
X	""
X};
X
X
X/* Routines for IMMEDIATE wands and spells. */
X/* bhitm: monster mtmp was hit by the effect of wand or spell otmp */
Xstatic int
Xbhitm(mtmp, otmp)
Xregister struct monst *mtmp;
Xregister struct obj *otmp;
X{
X	register boolean wake = FALSE;
X#ifdef MULDGN
X	boolean dbldam = (pl_character[0] == 'K') && u.uhave.questart;
X#endif
X	register int dmg;
X
X	switch(otmp->otyp) {
X	case WAN_STRIKING:
X	case SPE_FORCE_BOLT:
X		wake = TRUE;
X		if (u.uswallow || rnd(20) < 10 + find_mac(mtmp)) {
X			dmg = d(2,12);
X#ifdef MULDGN
X			if(dbldam) dmg *= 2;
X#endif
X			hit((otmp->otyp == WAN_STRIKING) ? "wand" :
X						"spell", mtmp, exclam(dmg));
X			(void) resist(mtmp, otmp->oclass, dmg, TELL);
X		} else miss((otmp->otyp == WAN_STRIKING) ? "wand" :
X						"spell", mtmp);
X		makeknown(otmp->otyp);
X		break;
X	case WAN_SLOW_MONSTER:
X	case SPE_SLOW_MONSTER:
X		wake = TRUE;
X		if (!resist(mtmp, otmp->oclass, 0, NOTELL)) {
X			if (mtmp->mspeed == MFAST) mtmp->mspeed = 0;
X			else mtmp->mspeed = MSLOW;
X			if (u.uswallow && (mtmp == u.ustuck) &&
X			    is_whirly(mtmp->data)) {
X				You("disrupt %s!", mon_nam(mtmp));
X				pline("A huge hole opens up...");
X				expels(mtmp, mtmp->data, TRUE);
X			}
X		}
X		break;
X	case WAN_SPEED_MONSTER:
X		if (!resist(mtmp, otmp->oclass, 0, NOTELL))
X			if (mtmp->mspeed == MSLOW) mtmp->mspeed = 0;
X			else mtmp->mspeed = MFAST;
X		wake = TRUE;
X		break;
X	case WAN_UNDEAD_TURNING:
X	case SPE_TURN_UNDEAD:
X		if (is_undead(mtmp->data)) {
X			dmg = rnd(8);
X#ifdef MULDGN
X			if(dbldam) dmg *= 2;
X#endif
X			if(!resist(mtmp, otmp->oclass, dmg, NOTELL))
X				mtmp->mflee = TRUE;
X			wake = TRUE;
X		}
X		break;
X	case WAN_POLYMORPH:
X	case SPE_POLYMORPH:
X		wake = TRUE;
X		if(!resist(mtmp, otmp->oclass, 0, NOTELL)) {
X		    if (!rn2(25)) {
X			if (canseemon(mtmp)) {
X			    pline("%s shudders!", Monnam(mtmp));
X			    makeknown(otmp->otyp);
X			}
X			/* no corpse after system shock */
X			xkilled(mtmp, 3);
X		    }
X		    else if (newcham(mtmp, (struct permonst *)0) )
X			if (!Hallucination && (!Blind || sensemon(mtmp)))
X			    makeknown(otmp->otyp);
X		}
X		break;
X	case WAN_CANCELLATION:
X	case SPE_CANCELLATION:
X		wake = TRUE;
X		cancel_monst(mtmp, otmp, TRUE, TRUE, FALSE);
X		break;
X	case WAN_TELEPORTATION:
X	case SPE_TELEPORT_AWAY:
X		if(mtmp->ispriest && *in_rooms(mtmp->mx, mtmp->my, TEMPLE)) {
X		    pline("%s resists your magic!", Monnam(mtmp));
X		    wake = TRUE;
X		    break;
X		}
X		wake = TRUE;
X		if(mtmp->isshk) rloc_shk(mtmp);
X		else rloc(mtmp);
X		break;
X	case WAN_MAKE_INVISIBLE:
X		mtmp->minvis = TRUE;
X		newsym(mtmp->mx,mtmp->my);	/* make monster disappear */
X		if (mtmp->wormno) see_wsegs(mtmp); /* and tail too */
X		wake = TRUE;
X		break;
X	case WAN_NOTHING:
X		break;
X	case WAN_PROBING:
X		makeknown(otmp->otyp);
X		mstatusline(mtmp);
X		break;
X	case WAN_OPENING:
X		if(u.uswallow && mtmp == u.ustuck) {
X			if (is_animal(mtmp->data)) {
X				if (Blind) pline("Its mouth opens!");
X				else pline("%s opens its mouth!", Monnam(mtmp));
X			}
X			expels(mtmp, mtmp->data, TRUE);
X			break;
X		}
X	case WAN_LOCKING:
X	case SPE_KNOCK:
X	case SPE_WIZARD_LOCK:
X		break;
X	default:
X		impossible("What an interesting effect (%u)", otmp->otyp);
X	}
X	if(wake) {
X	    if(mtmp->mhp > 0) {
X		wakeup(mtmp);
X		m_respond(mtmp);
X		if(mtmp->isshk && !*u.ushops) hot_pursuit(mtmp);
X	    } else if(mtmp->m_ap_type)
X		seemimic(mtmp); /* might unblock if mimicing a boulder/door */
X	}
X	return 0;
X}
X
Xstruct monst *
Xrevive(obj,ininv)
Xregister struct obj *obj;
Xboolean ininv;
X{
X	register struct monst *mtmp = (struct monst *)0;
X
X	if(obj->otyp == CORPSE) {
X		int montype = obj->corpsenm;
X		int x = ininv ? u.ux : obj->ox;
X		int y = ininv ? u.uy : obj->oy;
X
X		if (cant_create(&montype)) { /* will make zombie instead */
X			mtmp = makemon(&mons[PM_HUMAN_ZOMBIE], x, y);
X			if (mtmp) {
X				mtmp->mhp = mtmp->mhpmax = 100;
X				mtmp->mspeed = MFAST;
X			}
X		} else {
X			struct obj *otmp;
X#if defined(ARMY) && !defined(MUSE)
X			if (is_mercenary(&mons[montype]))
X				montype = PM_UNARMORED_SOLDIER;
X#endif
X			mtmp = makemon(&mons[montype], x, y);
X			if (mtmp) {
X				/* Monster retains its name */
X				if (obj->onamelth)
X					mtmp = christen_monst(mtmp, ONAME(obj));
X				/* No inventory for newly revived monsters */
X				while ((otmp = (mtmp->minvent)) != 0) {
X					mtmp->minvent = otmp->nobj;
X					dealloc_obj(otmp);
X				}
X			}
X		}
X		if (mtmp && obj->oeaten)
X			mtmp->mhp = eaten_stat(mtmp->mhp, obj);
X		if (ininv) useup(obj);
X		else {
X			/* not useupf(), which charges */
X			if (obj->quan > 1L) obj->quan--;
X			else delobj(obj);
X		}
X		if (x != u.ux || y != u.uy || Invisible)
X			newsym(x, y);
X	}
X	return mtmp;
X}
X
Xstatic const char NEARDATA charged_objs[] = { WAND_CLASS, WEAPON_CLASS, ARMOR_CLASS, 0 };
X
X/* cancel obj, possibly carried by you or a monster */
Xstatic void
Xcancel_item(obj)
Xregister struct obj *obj;
X{
X	boolean	u_ring = (obj == uleft) || (obj == uright);
X
X	switch(obj->otyp) {
X		case RIN_GAIN_STRENGTH:
X			if ((obj->owornmask & W_RING) && u_ring) {
X				ABON(A_STR) -= obj->spe;
X				flags.botl = 1;
X			}
X			break;
X		case RIN_ADORNMENT:
X			if ((obj->owornmask & W_RING) && u_ring) {
X				ABON(A_CHA) -= obj->spe;
X				flags.botl = 1;
X			}
X			break;
X		case RIN_INCREASE_DAMAGE:
X			if ((obj->owornmask & W_RING) && u_ring)
X				u.udaminc -= obj->spe;
X			break;
X		case GAUNTLETS_OF_DEXTERITY:
X			if ((obj->owornmask & W_ARMG) && (obj == uarmg)) {
X				ABON(A_DEX) -= obj->spe;
X				flags.botl = 1;
X			}
X			break;
X		case HELM_OF_BRILLIANCE:
X			if ((obj->owornmask & W_ARMH) && (obj == uarmh)) {
X				ABON(A_INT) -= obj->spe;
X				ABON(A_WIS) -= obj->spe;
X				flags.botl = 1;
X			}
X			break;
X		/* case RIN_PROTECTION: /* not needed */
X	}
X	if(obj->spe &&
X	  !(obj->otyp == WAN_CANCELLATION || /* can't cancel cancellation */
X	    obj->otyp == TIN || obj->otyp == EGG ||
X	    obj->otyp == STATUE ||
X	    obj->otyp == MAGIC_LAMP ||
X#ifdef MAIL
X	    obj->otyp == SCR_MAIL ||
X#endif
X#ifdef TUTTI_FRUTTI
X	    obj->otyp == SLIME_MOLD ||
X#endif
X	    obj->otyp == SKELETON_KEY ||
X	    obj->otyp == LARGE_BOX || obj->otyp == CHEST))
X		obj->spe = (obj->oclass == WAND_CLASS) ? -1 : 0;
X
X	if (obj->otyp == OIL_LAMP || obj->otyp == BRASS_LANTERN
X	    || Is_candle(obj) || obj->otyp == CANDELABRUM_OF_INVOCATION) {
X
X	    /* reducing a candle's age to 0 is */
X	    /* the same as destroying it.      */
X	    if (!Is_candle(obj)) obj->age = 0;
X
X	    /* reducing a candelabrum age to 0 */
X	    /* is the same as de-candling it.  */
X	    if(obj->otyp == CANDELABRUM_OF_INVOCATION) obj->spe = 0;
X
X	    obj->lamplit = 0;
X	    check_lamps();
X	}
X
X	if (obj->oclass == SCROLL_CLASS
X#ifdef MAIL
X	    && obj->otyp != SCR_MAIL
X#endif
X	   )
X	    obj->otyp = SCR_BLANK_PAPER;
X
X	if (obj->oclass == SPBOOK_CLASS && obj->otyp != SPE_BOOK_OF_THE_DEAD)
X	    obj->otyp = SPE_BLANK_PAPER;
X
X	if (obj->oclass == POTION_CLASS && obj->otyp != POT_BOOZE)
X	    obj->otyp = (obj->otyp==POT_SICKNESS || obj->otyp==POT_SEE_INVISIBLE || obj->otyp==POT_FRUIT_JUICE) ? POT_FRUIT_JUICE : POT_WATER;
X	    /* sickness is "biologically contaminated" fruit juice; cancel it
X	     * and it just becomes fruit juice... whereas see invisible
X	     * tastes like "enchanted" fruit juice, it similarly cancels.
X	     */
X	unbless(obj);
X	uncurse(obj);
X}
X
Xstatic boolean
Xobj_resists(obj)
Xstruct obj *obj;
X{
X	if (obj->otyp == AMULET_OF_YENDOR ||
X	    obj->otyp == SPE_BOOK_OF_THE_DEAD ||
X	    obj->otyp == CANDELABRUM_OF_INVOCATION ||
X	    obj->otyp == BELL_OF_OPENING ||
X	    (obj->otyp == CORPSE && is_rider(&mons[obj->corpsenm]))) {
X		return TRUE;
X	} else {
X		int chance = rn2(20);
X		/* artifacts resist 95% of the time; normal objects 5% */
X		return (obj->oartifact ? !!chance : !chance);
X	}
X}
X
Xstatic boolean
Xobj_shudders(obj)
Xstruct obj *obj;
X{
X	int	zap_odds;
X
X	if (obj->oclass == WAND_CLASS)
X		zap_odds = 3;	/* half-life = 2 zaps */
X	else if (obj->cursed)
X		zap_odds = 3;	/* half-life = 2 zaps */
X	else if (obj->blessed)
X		zap_odds = 12;	/* half-life = 8 zaps */
X	else
X		zap_odds = 8;	/* half-life = 6 zaps */
X
X	/* adjust for "large" quantities of identical things */
X	if(obj->quan > 4L) zap_odds /= 2;
X
X	return (! rn2(zap_odds));
X}
X
X/* Use up at least minwt number of things made of material mat.
X * There's also a chance that other stuff will be used up.  Finally,
X * there's a random factor here to keep from always using the stuff
X * at the top of the pile.
X */
Xstatic void
Xpolyuse(objhdr, mat, minwt)
X    struct obj *objhdr;
X    int mat, minwt;
X{
X    register struct obj *otmp, *otmp2;
X
X    for(otmp = objhdr; minwt > 0 && otmp; otmp = otmp2) {
X	otmp2 = otmp->nexthere;
X	if((objects[otmp->otyp].oc_material == mat) == (rn2(minwt+1) != 0)) {
X	    /* appropriately add damage to bill */
X	    if (costly_spot(otmp->ox, otmp->oy))
X		if (*u.ushops)
X			addtobill(otmp, FALSE, FALSE, FALSE);
X		else
X			(void)stolen_value(otmp, 
X					   otmp->ox, otmp->oy, FALSE, FALSE);
X	    minwt -= (int)otmp->quan;
X	    delobj(otmp);
X	}
X    }
X}
X
X/*
X * Polymorph some of the stuff in this pile into a monster, preferably
X * a golem of some sort.
X */
Xstatic void
Xcreate_polymon(obj)
X    struct obj *obj;
X{
X	struct permonst *mdat = (struct permonst *)0;
X	struct monst *mtmp;
X	int pm_index;
X
X	/* no golems if you zap only one object -- not enough stuff */
X	if(!obj || (!obj->nexthere && obj->quan == 1L)) return;
X
X	/* some of these choices are arbitrary */
X	switch(poly_zapped) {
X	case IRON:
X	case METAL:
X	case MITHRIL:
X	    pm_index = PM_IRON_GOLEM;
X	    break;
X	case COPPER:
X	case SILVER:
X	case GOLD:
X	case PLATINUM:
X	case GEMSTONE:
X	case GLASS:
X	case MINERAL:
X	    pm_index = rn2(2) ? PM_STONE_GOLEM : PM_CLAY_GOLEM;
X	    break;
X	case 0:
X	    /* there is no flesh type, but all food is type 0, so we use it */
X	    pm_index = PM_FLESH_GOLEM;
X	    break;
X	case WOOD:
X	    pm_index = PM_WOOD_GOLEM;
X	    break;
X	case LEATHER:
X	    pm_index = PM_LEATHER_GOLEM;
X	    break;
X	case CLOTH:
X	    pm_index = PM_ROPE_GOLEM;
X	    break;
X	default:
X	    /* if all else fails... */
X	    pm_index = PM_STRAW_GOLEM;
X	    break;
X	}
X
X	if (! (mons[pm_index].geno & G_GENOD))
X		mdat = &mons[pm_index];
X
X	mtmp = makemon(mdat, obj->ox, obj->oy);
X	polyuse(obj, poly_zapped, (int)mons[pm_index].cwt);
X
X	if(!Blind && mtmp) {
X	    pline("Some objects in the pile merge.");
X	    pline("%s rises from the pile!", Amonnam(mtmp));
X	}
X}
X
Xstatic void
Xdo_osshock(obj)
Xstruct obj *obj;
X{
X	long i;
X	obj_zapped = TRUE;
X
X	if(poly_zapped < 0) {
X	    /* some may metamorphosize */
X	    for(i=obj->quan; i; i--)
X		if (! rn2(Luck + 45)) {
X		    poly_zapped = objects[obj->otyp].oc_material;
X		    break;
X		}
X	}
X
X	/* if quan > 1 then some will survive intact */
X	if (obj->quan > 1L) {
X		struct obj *obj2;
X
X		obj2 = splitobj(obj, (long)rnd((int)obj->quan - 1));
X		move_object(obj2, obj->ox, obj->oy);
X	}
X
X	/* appropriately add damage to bill */
X	if (costly_spot(obj->ox, obj->oy))
X		if (*u.ushops)
X			addtobill(obj, FALSE, FALSE, FALSE);
X		else
X			(void)stolen_value(obj, 
X					   obj->ox, obj->oy, FALSE, FALSE);
X
X	/* zap the object */
X	delobj(obj);
X}
X
X#ifndef MUSE
XSTATIC_PTR
X#endif
Xint
Xbhito(obj, otmp)	/* object obj was hit by the effect of wand otmp */
Xregister struct obj *obj, *otmp;	/* returns TRUE if sth was done */
X{
X	register int res = 1;
X	struct obj *otmp2;
X
X	if(obj == uball || obj == uchain)
X		res = 0;
X	else
X	switch(otmp->otyp) {
X	case WAN_POLYMORPH:
X	case SPE_POLYMORPH:
X		if (obj_resists(obj)) {
X		    res = 0;
X		    break;
X		} else if (obj_shudders(obj)) {
X		    if (cansee(obj->ox, obj->oy))
X			makeknown(otmp->otyp);
X		    do_osshock(obj);
X		    break;
X		}
X
X		/* preserve symbol and quantity */
X		otmp2 = mkobj_at(obj->oclass, obj->ox, obj->oy, FALSE);
X		otmp2->quan = obj->quan;
X		/* preserve the shopkeepers (lack of) interest */
X		otmp2->no_charge = obj->no_charge;
X#ifdef MAIL
X		/* You can't send yourself 100 mail messages and then
X		 * polymorph them into useful scrolls
X		 */
X		if (obj->otyp == SCR_MAIL) {
X			otmp2->otyp = SCR_MAIL;
X			otmp2->spe = 1;
X		}
X#endif
X
X		/* avoid abusing eggs laid by you */
X		if (obj->otyp == EGG && obj->spe) {
X			otmp2->otyp = EGG;
X			otmp2->spe = 1;
X			otmp2->corpsenm = random_monster();
X			while (!lays_eggs(&mons[otmp2->corpsenm]))
X				otmp2->corpsenm = random_monster();
X		}
X
X		/* keep special fields (including charges on wands) */
X		if (index(charged_objs, otmp2->oclass)) otmp2->spe = obj->spe;
X
X		otmp2->cursed = obj->cursed;
X		otmp2->blessed = obj->blessed;
X		otmp2->oeroded = obj->oeroded;
X		otmp2->oerodeproof = obj->oerodeproof;
X
X		/* Keep chest/box traps and poisoned ammo if we may */
X		if (obj->otrapped && Is_box(otmp2))
X			otmp2->otrapped = TRUE;
X		if (obj->opoisoned &&
X		    (otmp2->oclass == WEAPON_CLASS && otmp2->otyp <= SHURIKEN))
X			otmp2->opoisoned = TRUE;
X
X		if (obj->otyp == CORPSE) {
X		/* turn crocodile corpses into shoes */
X		    if (obj->corpsenm == PM_CROCODILE) {
X			otmp2->otyp = LOW_BOOTS;
X			otmp2->oclass = ARMOR_CLASS;
X			otmp2->spe = 0;
X			otmp2->oerodeproof = TRUE;
X			otmp2->quan = 1L;
X			otmp2->cursed = FALSE;
X		    }
X		}
X
X		/* no box contents --KAA */
X		if (Is_container(otmp2) || otmp2->otyp == STATUE)
X			delete_contents(otmp2);
X
X		/* 'n' merged objects may be fused into 1 object */
X		if (otmp2->quan > 1L &&
X			(!objects[otmp2->otyp].oc_merge ||
X				otmp2->quan > (long)rn2(1000)))
X			otmp2->quan = 1L;
X
X		if(otmp2->otyp == MAGIC_LAMP) otmp2->otyp = OIL_LAMP;
X
X		while(otmp2->otyp == WAN_WISHING ||
X					    otmp2->otyp == WAN_POLYMORPH)
X			otmp2->otyp = rnd_class(WAN_LIGHT, WAN_LIGHTNING);
X
X		/* update the weight */
X		otmp2->owt = weight(otmp2);
X
X		if(costly_spot(obj->ox, obj->oy)) {
X		    register struct monst *shkp =
X		          shop_keeper(*in_rooms(obj->ox, obj->oy, SHOPBASE));
X
X		    if ((!obj->no_charge ||
X			 (Is_container(obj) &&
X			    (contained_cost(obj, shkp, 0L, FALSE) != 0L)))
X		       && inhishop(shkp)) {
X		        if(shkp->mpeaceful) {
X			    if(*u.ushops && *in_rooms(u.ux, u.uy, 0) ==
X			            *in_rooms(shkp->mx, shkp->my, 0) &&
X			            !costly_spot(u.ux, u.uy))
X				make_angry_shk(shkp, obj->ox, obj->oy);
X			    else {
X			        pline("%s gets angry!", Monnam(shkp));
X				hot_pursuit(shkp);
X			    }
X			} else Norep("%s is furious!", Monnam(shkp));
X		    }
X		}
X		delobj(obj);
X		break;
X	case WAN_STRIKING:
X	case SPE_FORCE_BOLT:
X		if (obj->otyp == BOULDER)
X			fracture_rock(obj);
X		else if (obj->otyp == STATUE)
X			(void) break_statue(obj);
X		else
X			res = 0;
X		makeknown(otmp->otyp);
X		break;
X	case WAN_CANCELLATION:
X	case SPE_CANCELLATION:
X		cancel_item(obj);
X		break;
X	case WAN_TELEPORTATION:
X	case SPE_TELEPORT_AWAY:
X		rloco(obj);
X		break;
X	case WAN_MAKE_INVISIBLE:
X		obj->oinvis = TRUE;
X		newsym(obj->ox,obj->oy);	/* make object disappear */
X		break;
X	case WAN_UNDEAD_TURNING:
X	case SPE_TURN_UNDEAD:
X		res = !!revive(obj,FALSE);
X		break;
X	case WAN_OPENING:
X	case SPE_KNOCK:
X		/* Zap it at the chain, not the ball */
X		if (obj == uchain) {
X			unpunish();
X			res = 1;
X			makeknown(obj->otyp);
X			break;
X		}
X		/* fall through */
X	case WAN_LOCKING:
X	case SPE_WIZARD_LOCK:
X		if(Is_box(obj))
X			res = boxlock(obj, otmp);
X		else
X			res = 0;
X		if (res /* && obj->oclass == WAND_CLASS */)
X			makeknown(obj->otyp);
X		break;
X	case WAN_SLOW_MONSTER:		/* no effect on objects */
X	case SPE_SLOW_MONSTER:
X	case WAN_SPEED_MONSTER:
X	case WAN_NOTHING:
X	case WAN_PROBING:
X		res = 0;
X		break;
X	default:
X		impossible("What an interesting effect (%u)", otmp->otyp);
X	}
X	return(res);
X}
X
XSTATIC_PTR
Xint
Xbhitpile(obj,fhito,tx,ty)
X    register struct obj *obj;	/* returns nonzero of something was hit */
X    int FDECL((*fhito), (OBJ_P, OBJ_P));
X    int tx, ty;
X{
X    int hitanything = 0;
X    register struct obj *otmp, *next_obj = (struct obj *)0;
X
X    /* modified by GAN to hit all objects */
X    /* pre-reverse the polymorph pile,  -dave- 3/90 */
X    poly_zapped = -1;
X    if(obj->otyp == SPE_POLYMORPH || obj->otyp == WAN_POLYMORPH) {
X	otmp = level.objects[tx][ty];
X	level.objects[tx][ty] = next_obj;
X	while(otmp) {
X	    next_obj = otmp->nexthere;
X	    otmp->nexthere = level.objects[tx][ty];
X	    level.objects[tx][ty] = otmp;
X	    otmp = next_obj;
X	}
X    }
X    for(otmp = level.objects[tx][ty]; otmp; otmp = next_obj) {
X	/* Fix for polymorph bug, Tim Wright */
X	next_obj = otmp->nexthere;
X	hitanything += (*fhito)(otmp, obj);
X    }
X    if(poly_zapped >= 0)
X	create_polymon(level.objects[tx][ty]);
X
X    return hitanything;
X}
X
X/*
X * zappable - returns 1 if zap is available, 0 otherwise.
X *	      it removes a charge from the wand if zappable.
X * added by GAN 11/03/86
X */
Xint
Xzappable(wand)
Xregister struct obj *wand;
X{
X	if(wand->spe < 0 || (wand->spe == 0 && rn2(121)))
X		return 0;
X	if(wand->spe == 0)
X		You("wrest one more spell from the worn-out wand.");
X	wand->spe--;
X	return 1;
X}
X
X/*
X * zapnodir - zaps a NODIR wand/spell.
X * added by GAN 11/03/86
X */
Xvoid
Xzapnodir(obj)
Xregister struct obj *obj;
X{
X	switch(obj->otyp) {
X		case WAN_LIGHT:
X		case SPE_LIGHT:
X			litroom(TRUE,obj);
X			break;
X		case WAN_SECRET_DOOR_DETECTION:
X		case SPE_DETECT_UNSEEN:
X			if(!findit()) return;
X			break;
X		case WAN_CREATE_MONSTER:
X			{ register int cnt = 1;
X			if(!rn2(23)) cnt += rn2(7) + 1;
X			while(cnt--)
X			    (void) makemon((struct permonst *) 0, u.ux, u.uy);
X			}
X			break;
X		case WAN_WISHING:
X			if(Luck + rn2(5) < 0) {
X				pline("Unfortunately, nothing happens.");
X				break;
X			}
X			makewish();
X			break;
X	}
X	if (!objects[obj->otyp].oc_name_known &&
X	    (!Blind || obj->otyp == WAN_WISHING)) {
X			makeknown(obj->otyp);
X			more_experienced(0,10);
X	}
X}
X
Xstatic void
Xbackfire(otmp)
X
X	register struct obj * otmp;
X{
X	pline("%s suddenly explodes!", The(xname(otmp)));
X	losehp(d(otmp->spe+2,6), "exploding wand", KILLED_BY_AN);
X	useup(otmp);
X}
X
Xstatic const char NEARDATA zap_syms[] = { WAND_CLASS, 0 };
X
Xint
Xdozap()
X{
X	register struct obj *obj;
X	int	damage;
X
X	if(check_capacity(NULL)) return(0);
X	obj = getobj(zap_syms, "zap");
X	if(!obj) return(0);
X
X	check_unpaid(obj);
X
X	/* zappable addition done by GAN 11/03/86 */
X	if(!zappable(obj)) pline(nothing_happens);
X	else if(obj->cursed && !rn2(100)) {
X		backfire(obj);	/* the wand blows up in your face! */
X		exercise(A_STR, FALSE);
X		return(1);
X	} else if(!(objects[obj->otyp].oc_dir == NODIR) && !getdir(NULL)) {
X		if (!Blind)
X		    pline("%s glows and fades.", The(xname(obj)));
X		/* make him pay for knowing !NODIR */
X	} else if(!u.dx && !u.dy && !u.dz && !(objects[obj->otyp].oc_dir == NODIR)) {
X	    if((damage = zapyourself(obj)))
X		losehp(damage, self_pronoun("zapped %sself with a wand", "him"),
X			NO_KILLER_PREFIX);
X	} else {
X		weffects(obj);
X	}
X	if (obj->spe < 0) {
X	    pline ("%s %sturns to dust.",
X		   The(xname(obj)), Blind ? "" : "glows violently, then ");
X	    useup(obj);
X	}
X	return(1);
X}
X
Xint
Xzapyourself(obj)
X	register struct obj	*obj;
X{
X	int	damage = 0;
X
X	switch(obj->otyp) {
X		case WAN_STRIKING:
X		case SPE_FORCE_BOLT:
X		    if(Antimagic) {
X			shieldeff(u.ux, u.uy);
X			pline("Boing!");
X		    } else {
X			You("magically bash yourself!");
X			damage=d(8,6);
X			exercise(A_STR, FALSE);
X		    }
X		    makeknown(obj->otyp);
X		    break;
X		case WAN_LIGHTNING:
X		    makeknown(WAN_LIGHTNING);
X		    if (!Shock_resistance) {
X			pline("Idiot!  You've shocked yourself!");
X			damage = d(12,6);
X			exercise(A_CON, FALSE);
X		    } else {
X			shieldeff(u.ux, u.uy);
X			You("zap yourself, but seem unharmed.");
X#ifdef POLYSELF
X			ugolemeffects(AD_ELEC, d(12,6));
X#endif
X		    }
X		    destroy_item(WAND_CLASS, AD_ELEC);
X		    destroy_item(RING_CLASS, AD_ELEC);
X		    if(!Blind) {
X			    You("are blinded by the flash!");
X			    make_blinded((long)rnd(100),FALSE);
X		    }
X		    break;
X		case SPE_FIREBALL:
X		    You("explode a fireball on top of yourself!");
X		    explode(u.ux, u.uy, 11, d(6,6), WAND_CLASS);
X		    break;
X		case WAN_FIRE:
X		    makeknown(WAN_FIRE);
X		case FIRE_HORN:
X		    pline("You've set light to yourself!");
X		    if (Fire_resistance) {
X			shieldeff(u.ux, u.uy);
X			You("feel mildly hot.");
X#ifdef POLYSELF
X			ugolemeffects(AD_FIRE, d(12,6));
X#endif
X		    } else
X			damage = d(12,6);
X		    destroy_item(SCROLL_CLASS, AD_FIRE);
X		    destroy_item(POTION_CLASS, AD_FIRE);
X		    destroy_item(SPBOOK_CLASS, AD_FIRE);
X		    break;
X		case WAN_COLD:
X		    makeknown(WAN_COLD);
X		case SPE_CONE_OF_COLD:
X		case FROST_HORN:
X		    if (Cold_resistance) {
X			shieldeff(u.ux, u.uy);
X			You("feel mildly chilly.");
X#ifdef POLYSELF
X			ugolemeffects(AD_COLD, d(12,6));
X#endif
X		    } else {
X			You("imitate a popsicle!");
X			damage = d(12,6);
X		    }
X		    destroy_item(POTION_CLASS, AD_COLD);
X		    break;
X		case WAN_MAGIC_MISSILE:
X		    makeknown(WAN_MAGIC_MISSILE);
X		case SPE_MAGIC_MISSILE:
X		    if(Antimagic) {
X			shieldeff(u.ux, u.uy);
X			pline("The missiles bounce!");
X		    } else {
X			damage = d(4,6);
X			pline("Idiot!  You've shot yourself!");
X		    }
X		    break;
X		case WAN_POLYMORPH:
X#ifdef POLYSELF
X		    makeknown(WAN_POLYMORPH);
X#endif
X		case SPE_POLYMORPH:
X#ifdef POLYSELF
X		    polyself();
X#else
X		    newman();
X#endif
X		    break;
X		case WAN_CANCELLATION:
X		case SPE_CANCELLATION:
X		    cancel_monst(&youmonst, obj, TRUE, FALSE, TRUE);
X		    break;
X	       case WAN_MAKE_INVISIBLE: {
X		    /* have to test before changing HInvis but must change
X		     * HInvis before doing newsym().
X		     */
X		    int msg = (!Blind && !Invis && !See_invisible);
X
X		    HInvis |= FROMOUTSIDE;
X		    if (msg) {
X			makeknown(WAN_MAKE_INVISIBLE);
X			newsym(u.ux, u.uy);
X			pline(Hallucination ?
X			 "Far out, man!  You can see right through yourself!" :
X			 "Gee!  All of a sudden, you can't see yourself.");
X		    }
X		    break;
X		}
X	       case WAN_SPEED_MONSTER:
X		    if (!(Fast & INTRINSIC)) {
X			You("seem to be moving faster.");
X			makeknown(WAN_SPEED_MONSTER);
X			exercise(A_DEX, TRUE);
X		    }
X		    Fast |= FROMOUTSIDE;
X		    break;
X	       case WAN_SLEEP:
X		    makeknown(WAN_SLEEP);
X		case SPE_SLEEP:
X		    if(Sleep_resistance) {
X			shieldeff(u.ux, u.uy);
X			You("don't feel sleepy!");
X		    } else {
X			pline("The sleep ray hits you!");
X			nomul(-rn2(50));
X			u.usleep = 1;
X			nomovemsg = "You wake up.";
X		    }
X		    break;
X		case WAN_SLOW_MONSTER:
X		case SPE_SLOW_MONSTER:
X		    if(Fast & (TIMEOUT | INTRINSIC)) {
X			Fast &= ~(TIMEOUT | INTRINSIC);
X			You("seem to be moving slower.");
X			exercise(A_DEX, FALSE);
X		    }
X		    break;
X		case WAN_TELEPORTATION:
X		case SPE_TELEPORT_AWAY:
X		    tele();
X		    break;
X		case WAN_DEATH:
X		case SPE_FINGER_OF_DEATH:
X#ifdef POLYSELF
X		    if (is_undead(uasmon)) {
X			pline((obj->otyp == WAN_DEATH) ?
X			  "The wand shoots an apparently harmless beam at you."
X			  : "You seem no deader than before.");
X			break;
X		    }
X#endif
X		    killer_format = NO_KILLER_PREFIX;
X		    killer = self_pronoun("shot %sself with a death ray","him");
X		    You("irradiate yourself with pure energy!");
X		    You("die.");
X		    makeknown(WAN_DEATH);
X			/* They might survive with an amulet of life saving */
X		    done(DIED);
X		    break;
X		case SPE_TURN_UNDEAD:
X		case WAN_UNDEAD_TURNING:
X#ifdef POLYSELF
X		    if (is_undead(uasmon)) {
X			You("feel frightened and %sstunned.",
X			     Stunned ? "even more " : "");
X			make_stunned(HStun + rnd(30), FALSE);
X		    }
X#endif
X		    break;
X		case SPE_DIG:
X		case SPE_DETECT_UNSEEN:
X		case WAN_DIGGING:
X		case WAN_NOTHING:
X		case WAN_OPENING:
X		case WAN_LOCKING:
X		case SPE_KNOCK:
X		case SPE_WIZARD_LOCK:
X		    break;
X		case WAN_PROBING:
X		    makeknown(WAN_PROBING);
X		    ustatusline();
X		    break;
X		default: impossible("object %d used?",obj->otyp);
X	}
X	return(damage);
X}
X
X/*
X * cancel a monster (possibly the hero).  inventory is cancelled only
X * if the monster is zapping itself directly, since otherwise the
X * effect is too strong.  currently non-hero monsters do not zap
X * themselves with cancellation.
X */
Xvoid
Xcancel_monst(mdef, obj, youattack, allow_cancel_kill, self_cancel)
Xregister struct monst	*mdef;
Xregister struct obj	*obj;
Xboolean			youattack, allow_cancel_kill, self_cancel;
X{
X	boolean	youdefend = (mdef == &youmonst);
X	static const char writing_vanishes[] =
X				"Some writing vanishes from %s head!";
X	static const char your[] = "your";	/* should be extern */
X
X	if (youdefend ? (!youattack && Antimagic)
X		      : resist(mdef, obj->oclass, 0, NOTELL))
X		return;		/* resisted cancellation */
X
X	if (self_cancel) {	/* 1st cancel inventory */
X	    struct obj *otmp;
X
X	    for (otmp = (youdefend ? invent : mdef->minvent);
X			    otmp; otmp = otmp->nobj)
X		cancel_item(otmp);
X	    if (youdefend) {
X		flags.botl = 1;	/* potential AC change */
X		find_ac();
X	    }
X	}
X
X	/* now handle special cases */
X	if (youdefend) {
X#ifdef POLYSELF
X	    if (u.mtimedone) {
X		if ((u.umonnum == PM_CLAY_GOLEM) && !Blind)
X		    pline(writing_vanishes, your);
X		rehumanize();
X	    }
X#endif
X	} else {
X	    mdef->mcan = TRUE;
X
X	    if (is_were(mdef->data) && mdef->data->mlet != S_HUMAN)
X		were_change(mdef);
X
X	    if (mdef->data == &mons[PM_CLAY_GOLEM]) {
X		if (canseemon(mdef))
X		    pline(writing_vanishes, s_suffix(mon_nam(mdef)));
X
X		if (allow_cancel_kill) {
X		    if (youattack)
X			killed(mdef);
X		    else
X			monkilled(mdef, "", AD_SPEL);
X		}
X	    }
X	}
X}
X
X/* called for various wand and spell effects - M. Stephenson */
Xvoid
Xweffects(obj)
Xregister struct	obj	*obj;
X{
X	xchar zx,zy;
X
X	exercise(A_WIS, TRUE);
X	if(objects[obj->otyp].oc_dir == IMMEDIATE) {
X	    obj_zapped = FALSE;
X
X	    if(u.uswallow)	(void)bhitm(u.ustuck, obj);
X	    else if(u.dz) {
X		if(u.dz > 0) {
X		    if(levl[u.ux][u.uy].typ == DRAWBRIDGE_DOWN &&
X		       (obj->otyp == WAN_LOCKING
X			   || obj->otyp == SPE_WIZARD_LOCK))
X				close_drawbridge(u.ux, u.uy);
X		    else
X			(void) bhitpile(obj, bhito, u.ux, u.uy);
X		}
X	    } else (void) bhit(u.dx,u.dy,rn1(8,6),ZAPPED_WAND,bhitm,bhito,obj);
X
X	    /* give a clue if obj_zapped */
X	    if (obj_zapped)
X		You("feel shuddering vibrations.");
X
X	} else if(objects[obj->otyp].oc_dir == NODIR) {
X		zapnodir(obj);
X	} else {
X	    switch(obj->otyp) {
X		case WAN_DIGGING:
X		case SPE_DIG:
X			/* Original effect (approximately):
X			 * from CORR: dig until we pierce a wall
X			 * from ROOM: piece wall and dig until we reach
X			 * an ACCESSIBLE place.
X			 * Currently: dig for digdepth positions;
X			 * also down on request of Lennart Augustsson.
X			 */
X		    {   register struct rm *room;
X			register int digdepth; 
X			register boolean shopdoor, shopwall;
X
X			shopdoor = shopwall = FALSE;
X			if(u.uswallow) {
X				register struct monst *mtmp = u.ustuck;
X
X				if (!is_whirly(mtmp->data)) {
X					if (is_animal(mtmp->data))
X					    You("pierce %s stomach wall!",
X				  	 	    s_suffix(mon_nam(mtmp)));
X					mtmp->mhp = 1;	/* almost dead */
X					expels(mtmp, mtmp->data,
X					       !is_animal(mtmp->data));
X				}
X				break;
X			}
X			if(u.dz) {
X			    if(!Is_airlevel(&u.uz) && !Is_waterlevel(&u.uz) &&
X			       !Underwater) {
X				if(u.dz < 0 || On_stairs(u.ux, u.uy)) {
X				    if(On_stairs(u.ux, u.uy))
X					pline(
X			"The beam bounces off the %s and hits the ceiling.",
X					      (u.ux == xdnladder ||
X					       u.ux == xupladder) ?
X					      "ladder" : "stairs");
X				    You("loosen a rock from the ceiling.");
X				    pline("It falls on your %s!",
X					  body_part(HEAD));
X				    losehp(1, "falling rock", KILLED_BY_AN);
X				    (void) mksobj_at((int)ROCK, u.ux, u.uy, FALSE);
X				    stackobj(fobj);
X				    if(Invisible) newsym(u.ux, u.uy);
X				} else {
X				    dighole();
X				}
X			    }
X			    break;
X			}
X			zx = u.ux+u.dx;
X			zy = u.uy+u.dy;
X			digdepth = 8 + rn2(18);
X			tmp_at(DISP_BEAM, cmap_to_glyph(S_digbeam));
X			while(--digdepth >= 0) {
X			    if(!isok(zx,zy)) break;
X			    room = &levl[zx][zy];
X			    tmp_at(zx,zy);
X			    delay_output();	/* wait a little bit */
X			    if(level.flags.is_maze_lev &&
X			                    !Is_earthlevel(&u.uz)) {
X				if(IS_WALL(room->typ)) {
X				    if(!(room->diggable & W_NONDIGGABLE)) {
X					if(*in_rooms(zx,zy,SHOPBASE)) { 
X					    add_damage(zx, zy, 200L);
X					    shopwall = TRUE;
X					}
X					room->typ = ROOM;
X					unblock_point(zx,zy); /* vision */
X				    } else if(!Blind)
X					pline("The wall glows then fades.");
X				    break;
X				}
X				if(room->typ == STONE) {
X				    if(!(room->diggable & W_NONDIGGABLE)) {
X					room->typ = CORR;
X					unblock_point(zx,zy); /* vision */
X				    }else if (!Blind && !Is_airlevel(&u.uz))
X					pline("The rock glows then fades.");
X				    break;
X				}
X			    } else if(IS_ROCK(room->typ)) {
X				if(may_dig(zx,zy)) {
X				    if(IS_WALL(room->typ) ||
X				       room->typ == SDOOR) {
X					if(*in_rooms(zx,zy,SHOPBASE)) {
X					    add_damage(zx, zy, 200L);
X					    shopwall = TRUE;
X					}
X					if (level.flags.is_cavernous_lev) {
X					    room->typ = CORR;
X					} else {
X					    room->typ = DOOR;
X					    room->doormask = D_NODOOR;
X					}
X					digdepth -= 2;
X				    } else {
X					room->typ = CORR;
X					digdepth--;
X				    }
X				    unblock_point(zx,zy); /* vision */
X				} else
X				    break;
X			    } else if(closed_door(zx, zy)) {
X				if(*in_rooms(zx,zy,SHOPBASE)) {
X				    shopdoor = TRUE;
X				    add_damage(zx, zy, 400L);
X				}
X				room->doormask = D_NODOOR;
X				unblock_point(zx,zy); /* vision */
X				digdepth -= 2;
X			    }
X			    zx += u.dx;
X			    zy += u.dy;
X			} /* while */
X			tmp_at(DISP_END,0);	/* closing call */
X			if(shopdoor || shopwall)
X			    pay_for_damage(shopdoor? "destroy" : "dig into");
X			break;
X		    }
X		default:
X			if((int) obj->otyp >= SPE_MAGIC_MISSILE &&
X				(int) obj->otyp <= SPE_FINGER_OF_DEATH) {
X
X			    buzz((int) obj->otyp - SPE_MAGIC_MISSILE + 10,
X				 (int)u.ulevel / 2 + 1, u.ux, u.uy, u.dx, u.dy);
X
X			} else if((int) obj->otyp >= WAN_MAGIC_MISSILE &&
X					(int) obj->otyp <= WAN_LIGHTNING) {
X
X			    buzz((int) obj->otyp - WAN_MAGIC_MISSILE,
X				(obj->otyp == WAN_MAGIC_MISSILE) ? 2 : 6,
X				 u.ux, u.uy, u.dx, u.dy);
X			} else
X			    impossible("weffects: unexpected spell or wand");
X			break;
X		}
X		if(!objects[obj->otyp].oc_name_known) {
X			makeknown(obj->otyp);
X			more_experienced(0,10);
X		}
X	}
X	return;
X}
X
END_OF_FILE
if test 31925 -ne `wc -c <'src/zap.c1'`; then
    echo shar: \"'src/zap.c1'\" unpacked with wrong size!
fi
# end of 'src/zap.c1'
fi
echo shar: End of archive 68 \(of 108\).
cp /dev/null ark68isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \
21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \
41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 \
61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 \
81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 \
101 102 103 104 105 106 107 108 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 108 archives.
    echo "Now execute 'rebuild.sh'"
    rm -f ark10[0-8]isdone ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
