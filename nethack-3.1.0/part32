Path: uunet!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v16i032:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Part32/108
Message-ID: <4320@master.CNA.TEK.COM>
Date: 29 Jan 93 20:46:35 GMT
Sender: news@master.CNA.TEK.COM
Lines: 1731
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1589

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 16, Issue 32
Archive-name: nethack31/Part32
Supersedes: nethack3p9: Volume 10, Issue 46-102
Environment: Amiga, Atari, Mac, MS-DOS, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 32 (of 108)."
# Contents:  sys/mac/News sys/msdos/MakeGCC.src sys/share/lev_yacc.c1
# Wrapped by billr@saab on Wed Jan 27 16:08:58 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'sys/mac/News' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/mac/News'\"
else
echo shar: Extracting \"'sys/mac/News'\" \(364 characters\)
sed "s/^X//" >'sys/mac/News' <<'END_OF_FILE'
XWelcome to NetHack 3.1 for the Macintosh    (1/93)
X
XThis game is brought to you by Jon Watte, Hao-Yang Wang and the rest
Xof the Macintosh Team (Mike Engber, David Hairston, Jonathan Handler,
XTim Lennan, Rob Menke, Chris Russo and Andy Swanson).
X
XBug reports, suggestions, comments, etc., should be e-mailed to the
XInternet address: nethack-bugs@linc.cis.upenn.edu
END_OF_FILE
if test 364 -ne `wc -c <'sys/mac/News'`; then
    echo shar: \"'sys/mac/News'\" unpacked with wrong size!
fi
# end of 'sys/mac/News'
fi
if test -f 'sys/msdos/MakeGCC.src' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/msdos/MakeGCC.src'\"
else
echo shar: Extracting \"'sys/msdos/MakeGCC.src'\" \(12579 characters\)
sed "s/^X//" >'sys/msdos/MakeGCC.src' <<'END_OF_FILE'
X#       SCCS Id: @(#)MakeGCC.src       3.1     93/01/05
X#	Copyright (c) NetHack PC Development Team 1992, 1993.
X#       PC NetHack 3.1 Src Makefile for djgpp 1.09 and ndmake 4.5
X#
X#       For questions read the Install.dos file included with
X#       the distribution.
X#
X#       Kevin D Smolkowski, Kevins@ori.org
X
X#
X#   Programs
X#   gcc and go32 dos extender
X
X
XCC       = gcc
XSTUB     = stub.exe         # Can either be stub.exe or go32.exe
XSTUBPATH = f:\djgpp\bin\    # Must be complete path with trailing '\'
XLINK     = gcc
X
X#
X#  Set the gamedir according to your preference.  It must be present prior
X#  to compilation.
X
XGAME    = nethack                 # Game Name
XGAMEDIR = c:\games\nethack        # Game directory
X
X#
X#  Flags.
X#
X
X# Debugging
X#CFLAGS = -pg -c -I../include
X#LFLAGS = -pg
X
XCFLAGS = -c -O -I../include
XLFLAGS =
X
X#
X# Special libraries
XLIBS = -lpc
X
X#
X#  Source directories.    Makedefs hardcodes these, don't change them.
X#
X
XINCL = ..\include   # NetHack include files
XDAT  = ..\dat       # NetHack data files
XDOC  = ..\doc       # NetHack documentation files
XUTIL = ..\util      # Utility source
XSRC  = ..\src       # Main source
XSYS  = ..\sys\share # Shared system files
XMSYS = ..\sys\msdos # Msdos specific files
XWIN  = ..\win\tty   # Character terminal files
XGAMEFILE = $(GAMEDIR)\$(GAME).exe # whole thing
X
X#
X#  The default make target (so just typing 'make' is useful).
X#
X
Xdefault : $(GAMEFILE)
X
X#
X#  If TERMLIB is defined in pcconf.c, comment out the upper line and
X#  uncomment the lower.  Note that you must build the termc library
X#  and place it in djgpp's lib directory.  See termcap.zip for details
X
X#TERMLIB =
XTERMLIB = -ltermc
X
XLIBRARIES = $(LIBS) $(TERMLIB)
X
X######################################################################
X#
X#  Nothing below this line should have to be changed.
X#
X#  Other things that have to be reconfigured are in
X#       config.h, pccconf.h and possibly system.h.
X#
X
X#       This line should not be deleted.
X
X#
X#  Make Rules.
X#
X
X.SUFFIXES:  .exe .o .c .y .l
X
X.c.o:
X        $(CC) $(CFLAGS) -o$*.o $*.c
X
X
X#
X#  Object files for the game itself.
X#
X
XVOBJ01 = allmain.o  alloc.o    apply.o    artifact.o  attrib.o
XVOBJ02 = ball.o     bones.o    botl.o     cmd.o      dbridge.o
XVOBJ03 = decl.o     detect.o   display.o  do.o       do_name.o
XVOBJ04 = do_wear.o  dog.o      dogmove.o  dokick.o   dothrow.o
XVOBJ05 = drawing.o  dungeon.o  eat.o      end.o      engrave.o
XVOBJ06 = exper.o    explode.o  extralev.o files.o    fountain.o
XVOBJ07 = getline.o  hack.o     hacklib.o  invent.o   lock.o
XVOBJ08 = mail.o     main.o     makemon.o  mcastu.o   mhitm.o
XVOBJ09 = mhitu.o    minion.o   mkmap.o    mklev.o    mkmaze.o
XVOBJ10 = mkobj.o    mkroom.o   mon.o      mondata.o  monmove.o
XVOBJ11 = monst.o    monstr.o   mplayer.o  mthrowu.o  muse.o
XVOBJ12 = music.o    o_init.o   objects.o  objnam.o   options.o
XVOBJ13 = pickup.o   pline.o    polyself.o potion.o   quest.o
XVOBJ14 = questpgr.o pager.o    pray.o     priest.o   read.o
XVOBJ15 = rect.o     restore.o  rip.o      rnd.o      rumors.o
XVOBJ16 = save.o     shk.o      shknam.o   sit.o      sounds.o
XVOBJ17 = sp_lev.o   spell.o    steal.o    termcap.o  timeout.o
XVOBJ18 = topl.o     topten.o   track.o    trap.o     u_init.o
XVOBJ19 = uhitm.o    vault.o    vision.o   vis_tab.o  weapon.o
XVOBJ20 = were.o     wield.o    windows.o  wintty.o   wizard.o
XVOBJ21 = worm.o     worn.o     write.o    zap.o
X
XSOBJ    = msdos.o    sys.o      tty.o      unix.o
X
XVVOBJ  = version.o
X
X
XVOBJ   = $(VOBJ01) $(VOBJ02) $(VOBJ03) $(VOBJ04) $(VOBJ05) \
X         $(VOBJ06) $(VOBJ07) $(VOBJ08) $(VOBJ09) $(VOBJ10) \
X         $(VOBJ11) $(VOBJ12) $(VOBJ13) $(VOBJ14) $(VOBJ15) \
X         $(VOBJ16) $(VOBJ17) $(VOBJ18) $(VOBJ19) $(VOBJ20) \
X         $(VOBJ21)
X
XALLOBJ =     $(VOBJ) $(VVOBJ) $(SOBJ)
X
XDGN_FILE_H = $(INCL)\align.h    $(INCL)\dgn_file.h
XDUNGEON_H  = $(INCL)\align.h    $(INCL)\dungeon.h
XEMIN_H     = $(DUNGEON_H)       $(INCL)\emin.h
XEPRI_H     = $(DUNGEON_H)       $(INCL)\align.h     $(INCL)\epri.h
XESHK_H     = $(DUNGEON_H)       $(INCL)\eshk.h
XMONDATA_H  = $(INCL)\align.h    $(INCL)\mondata.h
XMONST_H    = $(INCL)\align.h    $(INCL)\monst.h
XPERMONST_H = $(INCL)\monattk.h  $(INCL)\monflag.h   $(INCL)\align.h   \
X             $(INCL)\permonst.h
XRM_H       = $(INCL)\align.h    $(INCL)\rm.h
XSP_LEV_H   = $(INCL)\align.h    $(INCL)\sp_lev.h
XVAULT_H    = $(DUNGEON_H)       $(INCL)\vault.h
XYOUPROP_H  = $(PERMONST_H)      $(MONDATA_H)        $(INCL)\prop.h    \
X             $(INCL)\pm.h       $(INCL)\youprop.h
XYOU_H      = $(MONST_H)         $(YOUPROP_H)        $(INCL)\align.h   \
X             $(INCL)\attrib.h   $(INCL)\you.h
XDISPLAY_H  = $(MONDATA_H)       $(INCL)\vision.h    $(INCL)\display.h
XPCCONF_H   = $(INCL)\micro.h    $(INCL)\system.h    $(INCL)\pcconf.h
XCONFIG_H   = $(GLOBAL_H)        $(INCL)\tradstdc.h  $(INCL)\config.h
XDECL_H     = $(YOU_H)           $(INCL)\spell.h     $(INCL)\color.h   \
X             $(INCL)\obj.h      $(INCL)\onames.h    $(INCL)\pm.h      \
X             $(INCL)\decl.h
XGLOBAL_H   = $(PCCONF_H)        $(INCL)\coord.h     $(INCL)\global.h
XHACK_H     = $(CONFIG_H)        $(DUNGEON_H)        $(DECL_H)         \
X             $(DISPLAY_H)       $(INCL)\monsym.h    $(INCL)\mkroom.h  \
X             $(INCL)\objclass.h $(INCL)\trap.h      $(INCL)\flag.h    \
X             $(RM_H)            $(INCL)\vision.h    $(INCL)\wintype.h \
X             $(INCL)\engrave.h  $(INCL)\rect.h      $(INCL)\extern.h \
X             $(INCL)\trampoli.h $(INCL)\hack.h
X
X
X
X
X#
X#  The default target.
X#
X
Xall :     $(GAMEFILE) install.tag
X    @echo Done.
X
Xinstall: install.tag
X
Xinstall.tag:    $(GAMEFILE) $(DAT)\sp_lev.tag
X    copy $(SYS)\termcap       $(GAMEDIR)
X    copy $(DAT)\*.?           $(GAMEDIR)
X    copy $(DAT)\*.dat         $(GAMEDIR)
X    copy $(DAT)\*.lev         $(GAMEDIR)
X    copy $(SYS)\NetHack.cnf   $(GAMEDIR)
X    copy $(UTIL)\recover.exe  $(GAMEDIR)
X    del   $(GAMEDIR)\makefile
X    echo install done > install.tag
X
X#
X#  The main target.
X#
X$(GAMEFILE) : $(GAME).res  $(UTIL)\utility.tag
X    $(CC) $(LFLAGS) @$(GAME).res $(LIBRARIES)
X    copy /b $(STUBPATH)$(STUB) + a.out $(GAMEFILE)
X#    del a.out
X
X$(GAME).res : $(ALLOBJ)
X    @echo $(VOBJ01) > $@
X    @echo $(VOBJ02) >> $@
X    @echo $(VOBJ03) >> $@
X    @echo $(VOBJ04) >> $@
X    @echo $(VOBJ05) >> $@
X    @echo $(VOBJ06) >> $@
X    @echo $(VOBJ07) >> $@
X    @echo $(VOBJ08) >> $@
X    @echo $(VOBJ09) >> $@
X    @echo $(VOBJ10) >> $@
X    @echo $(VOBJ11) >> $@
X    @echo $(VOBJ12) >> $@
X    @echo $(VOBJ13) >> $@
X    @echo $(VOBJ14) >> $@
X    @echo $(VOBJ15) >> $@
X    @echo $(VOBJ16) >> $@
X    @echo $(VOBJ17) >> $@
X    @echo $(VOBJ18) >> $@
X    @echo $(VOBJ19) >> $@
X    @echo $(VOBJ20) >> $@
X    @echo $(VOBJ21) >> $@
X    @echo $(SOBJ)   >> $@
X    @echo $(VVOBJ)  >> $@
X
X#
X#  The following include files depend on makedefs to be created.
X#
X#  date.h should be remade every time any of the source or include
X#  files is modified.
X#
X
X$(INCL)\date.h : $(VOBJ)
X    $(UTIL)\makedefs -v
X
X$(INCL)\onames.h :
X    $(UTIL)\makedefs -o
X
X$(INCL)\pm.h :
X    $(UTIL)\makedefs -p
X
X$(INCL)\trap.h :
X    $(UTIL)\makedefs -t
X
X#
X#       System specific modules
X#
X#             Ndmake doesn't like unix style / directory specs and
X#             djgcc doesn't like dos style directory specs.  So we
X#             get to copy stuff where we might need it.   Fun eh?
X#
X
Xmain.o:  $(HACK_H) $(SYS)\pcmain.c
X    copy $(SYS)\pcmain.c .
X    $(CC) $(CFLAGS) -omain.o pcmain.c
X
Xtty.o:   $(HACK_H) $(INCL)\wintty.h $(SYS)\pctty.c
X    copy $(SYS)\pctty.c .
X    $(CC) $(CFLAGS) -otty.o  pctty.c
X
Xunix.o:  $(SYS)\pcunix.c $(HACK_H)
X    copy $(SYS)\pcunix.c .
X    $(CC) $(CFLAGS) -ounix.o pcunix.c
X
Xsys.o : $(SYS)\pcsys.c $(HACK_H)
X    copy $(SYS)\pcsys.c .
X    $(CC) $(CFLAGS) -o$*.o pcsys.c
X
Xmsdos.o : $(HACK_H)  $(MSYS)\msdos.c
X    copy $(MSYS)\msdos.c .
X    $(CC) $(CFLAGS) -o$*.o $*.c
X
X
X# some other files requiring movement
X
Xgetline.o : $(WIN)\getline.c
X    copy $(WIN)\getline.c .
X    $(CC) $(CFLAGS) -o$*.o $*.c
X
Xtermcap.o : $(CONFIG_H) $(WIN)\termcap.c
X    copy $(WIN)\termcap.c .
X    $(CC) $(CFLAGS) -o$*.o $*.c
X
Xtopl.o : $(CONFIG_H) $(WIN)\topl.c
X    copy $(WIN)\topl.c .
X    $(CC) $(CFLAGS) -o$*.o $*.c
X
Xwintty.o : $(CONFIG_H) $(WIN)\wintty.c
X    copy $(WIN)\wintty.c .
X    $(CC) $(CFLAGS) -o$*.o $*.c
X
X#
X#  Housekeeping.
X#
X
Xclean :
X    -del *.o
X
Xspotless : clean
X    -del $(INCL)\date.h
X    -del $(INCL)\onames.h
X    -del $(INCL)\pm.h
X    -del $(INCL)\vis_tab.h
X    -del vis_tab.c
X    -del $(UTIL)\makedefs.exe
X    -del $(UTIL)\lev_comp.exe
X    -del $(UTIL)\dgn_comp.exe
X    -del $(UTIL)\*.res
X    -del $(UTIL)\*.def
X    -del $(UTIL)\*.map
X    -del $(DAT)\data
X    -del $(DAT)\rumors
X    -del $(UTIL)\guideboo.dvi
X
X# dependencies
Xallmain.o     : $(HACK_H)
Xalloc.o       : $(CONFIG_H)
Xapply.o       : $(HACK_H)
Xartifact.o    : $(HACK_H)       $(INCL)\artifact.h
Xattrib.o      : $(HACK_H)
Xbones.o       : $(HACK_H)
Xbotl.o        : $(HACK_H)
Xcmd.o         : $(HACK_H)       $(INCL)\func_tab.h
Xdbridge.o     : $(HACK_H)
Xdecl.o        : $(HACK_H)       $(INCL)\quest.h
Xdetect.o      : $(HACK_H)
Xdisplay.o     : $(HACK_H)
Xdo.o          : $(HACK_H)       $(INCL)\lev.h
Xdo_name.o     : $(HACK_H)
Xdo_wear.o     : $(HACK_H)
Xdog.o         : $(HACK_H)       $(INCL)\edog.h
Xdogmove.o     : $(HACK_H)       $(INCL)\mfndpos.h   $(INCL)\edog.h
Xdokick.o      : $(HACK_H)       $(ESHK_H)
Xdothrow.o     : $(HACK_H)
Xdrawing.o     : $(HACK_H)       $(INCL)\termcap.h
Xdungeon.o     : $(HACK_H)       $(DGN_FILE_H)
Xeat.o         : $(HACK_H)
Xend.o         : $(HACK_H)       $(ESHK_H)
Xengrave.o     : $(HACK_H)       $(INCL)\lev.h
Xexper.o       : $(HACK_H)
Xexplode.o     : $(HACK_H)
Xextralev.o    : $(HACK_H)
Xfiles.o       : $(HACK_H)
Xfountain.o    : $(HACK_H)
Xgetline.o     : $(HACK_H)
Xhack.o        : $(HACK_H)
Xinvent.o      : $(HACK_H)
Xlock.o        : $(HACK_H)
Xmail.o        : $(HACK_H)
Xhacklib.o     : $(HACK_H)
Xmain.o        : $(HACK_H)
Xmakemon.o     : $(HACK_H)
Xmcastu.o      : $(HACK_H)
Xmhitm.o       : $(HACK_H)
Xmhitu.o       : $(HACK_H)
Xminion.o      : $(HACK_H)
Xmklev.o       : $(HACK_H)
Xmkmap.o       : $(HACK_H)
Xmkmaze.o      : $(HACK_H)
Xmkobj.o       : $(HACK_H)
Xmkroom.o      : $(HACK_H)
Xmon.o         : $(HACK_H)
Xmondata.o     : $(HACK_H)
Xmonmove.o     : $(HACK_H)       $(INCL)\mfndpos.h   $(INCL)\artifact.h
Xmonst.o       : $(CONFIG_H)     $(PERMONST_H)       $(INCL)\monsym.h     \
X                $(ESHK_H)       $(VAULT_H)          $(INCL)\color.h      \
X                $(EPRI_H)
Xmonstr.o      : $(CONFIG_H)
Xmplayer.o     : $(HACK_H)
Xmthrowu.o     : $(HACK_H)
Xmuse.o        : $(HACK_H)
Xmusic.o       : $(HACK_H)
Xo_init.o      : $(HACK_H)
Xobjects.o     : $(CONFIG_H)     $(INCL)\obj.h       $(INCL)\objclass.h   \
X                $(INCL)\prop.h  $(INCL)\color.h
Xobjects.o     : $(HACK_H)
Xobjnam.o      : $(HACK_H)
Xoptions.o     : $(HACK_H)       $(INCL)\termcap.h
Xmsdos.o       : $(HACK_H)
Xpager.o       : $(HACK_H)
Xpickup.o      : $(HACK_H)
Xpline.o       : $(HACK_H)     $(EPRI_H)
Xpolyself.o    : $(HACK_H)
Xpotion.o      : $(HACK_H)
Xpriest.o      : $(HACK_H)     $(INCL)\mfndpos.h   $(ESHK_H) \
X                $(EPRI_H)     $(EMIN_H)
Xquest.o       : $(HACK_H)     $(INCL)\quest.h     $(INCL)\qtext.h
Xquestpgr.o    : $(HACK_H)     $(INCL)\quest.h     $(INCL)\qtext.h
Xpray.o        : $(HACK_H)
Xpriest.o      : $(HACK_H)
Xread.o        : $(HACK_H)
Xrect.o        : $(HACK_H)
Xrestore.o     : $(HACK_H)     $(INCL)\lev.h       $(INCL)\quest.h
Xrip.o         : $(HACK_H)
Xrnd.o         : $(HACK_H)
Xrumors.o      : $(HACK_H)
Xsave.o        : $(HACK_H)     $(INCL)\lev.h       $(INCL)\quest.h
Xsearch.o      : $(HACK_H)     $(INCL)\artifact.h
Xshk.o         : $(HACK_H)
Xshknam.o      : $(HACK_H)     $(ESHK_H)
Xsit.o         : $(HACK_H)
Xsounds.o      : $(HACK_H)     $(INCL)\edog.h      $(ESHK_H)
Xsp_lev.o      : $(HACK_H)
Xspell.o       : $(HACK_H)
Xsteal.o       : $(HACK_H)
Xsys.o         : $(HACK_H)
Xtermcap.o     : $(HACK_H)
Xtimeout.o     : $(HACK_H)
Xtopl.o        : $(HACK_H)
Xtopten.o      : $(HACK_H)
Xtrack.o       : $(HACK_H)
Xtrap.o        : $(HACK_H)     $(INCL)\edog.h
Xtty.o         : $(HACK_H)
Xu_init.o      : $(HACK_H)
Xuhitm.o       : $(HACK_H)
Xunix.o        : $(HACK_H)
Xvault.o       : $(HACK_H)     $(INCL)\vault.h
Xversion.o     : $(HACK_H)     $(INCL)\date.h      $(INCL)\patchlev.h
Xvision.o      : $(HACK_H)     $(INCL)\vis_tab.h
Xvis_tab.o     : $(HACK_H)
Xweapon.o      : $(HACK_H)
Xwere.o        : $(HACK_H)
Xwield.o       : $(HACK_H)
Xwindows.o     : $(HACK_H)
Xwintty.o      : $(HACK_H)
Xwizard.o      : $(HACK_H)
Xworm.o        : $(HACK_H)     $(INCL)\lev.h
Xworn.o        : $(HACK_H)
Xwrite.o       : $(HACK_H)
Xzap.o         : $(HACK_H)
END_OF_FILE
if test 12579 -ne `wc -c <'sys/msdos/MakeGCC.src'`; then
    echo shar: \"'sys/msdos/MakeGCC.src'\" unpacked with wrong size!
fi
# end of 'sys/msdos/MakeGCC.src'
fi
if test -f 'sys/share/lev_yacc.c1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/share/lev_yacc.c1'\"
else
echo shar: Extracting \"'sys/share/lev_yacc.c1'\" \(42090 characters\)
sed "s/^X//" >'sys/share/lev_yacc.c1' <<'END_OF_FILE'
Xextern char *malloc(), *realloc();
X
X# line 2 "lev_comp.y"
X/*	SCCS Id: @(#)lev_comp.c	3.1	92/07/12	*/
X/*	Copyright (c) 1989 by Jean-Christophe Collet */
X/* NetHack may be freely redistributed.  See license for details. */
X
X/*
X * This file contains the Level Compiler code
X * It may handle special mazes & special room-levels
X */
X
X/* In case we're using bison in AIX.  This definition must be
X * placed before any other C-language construct in the file
X * excluding comments and preprocessor directives (thanks IBM
X * for this wonderful feature...).
X *
X * Note: some cpps barf on this 'undefined control' (#pragma).
X * Addition of the leading space seems to prevent barfage for now,
X * and AIX will still see the directive in its non-standard locale.
X */
X
X#ifdef _AIX
X #pragma alloca		/* keep leading space! */
X#endif
X
X#include "hack.h"
X#include "sp_lev.h"
X#ifndef O_WRONLY
X# include <fcntl.h>
X#endif
X#ifndef O_CREAT	/* some older BSD systems do not define O_CREAT in <fcntl.h> */
X# include <sys/file.h>
X#endif
X#ifndef O_BINARY	/* used for micros, no-op for others */
X# define O_BINARY 0
X#endif
X
X#ifdef MICRO
X# define OMASK FCMASK
X#else
X# define OMASK 0644
X#endif
X
X#define MAX_REGISTERS	10
X#define ERR		(-1)
X
X#define New(type)		(type *) alloc(sizeof(type))
X#define NewTab(type, size)	(type **) alloc(sizeof(type *) * size)
X
X#ifdef MICRO
X# undef exit
Xextern void FDECL(exit, (int));
X#endif
X
Xextern void FDECL(yyerror, (char *));
Xextern void FDECL(yywarning, (char *));
Xextern int NDECL(yylex);
Xint NDECL(yyparse);
X
Xextern char *FDECL(dup_string,(char *));
Xextern int FDECL(get_floor_type, (CHAR_P));
Xextern int FDECL(get_room_type, (char *));
Xextern int FDECL(get_trap_type, (char *));
Xextern int FDECL(get_monster_id, (char *, CHAR_P));
Xextern int FDECL(get_object_id, (char *));
Xextern boolean FDECL(check_monster_char, (CHAR_P));
Xextern boolean FDECL(check_object_char, (CHAR_P));
Xextern char FDECL(what_map_char, (CHAR_P));
Xextern void FDECL(scan_map, (char *));
Xextern void NDECL(wallify_map);
Xextern boolean NDECL(check_subrooms);
Xextern void FDECL(check_coord, (int, int, char *));
Xextern void NDECL(store_part);
Xextern void NDECL(store_room);
Xextern void FDECL(write_maze, (int, specialmaze *));
Xextern void FDECL(write_lev, (int, splev *));
Xextern void FDECL(free_rooms, (room **, int));
X
Xstatic struct reg {
X	int x1, y1;
X	int x2, y2;
X}		current_region;
X
Xstatic struct coord {
X	int x;
X	int y;
X}		current_coord, current_align;
X
Xstatic struct size {
X	int height;
X	int width;
X}		current_size;
X
Xchar tmpmessage[256];
Xaltar *tmpaltar[256];
Xlad *tmplad[256];
Xstair *tmpstair[256];
Xdigpos *tmpdig[256];
Xchar *tmpmap[ROWNO];
Xregion *tmpreg[256];
Xlev_region *tmplreg[32];
Xdoor *tmpdoor[256];
Xroom_door *tmprdoor[256];
Xtrap *tmptrap[256];
Xmonster *tmpmonst[256];
Xobject *tmpobj[256];
Xdrawbridge *tmpdb[256];
Xwalk *tmpwalk[256];
Xgold *tmpgold[256];
Xfountain *tmpfountain[256];
Xsink *tmpsink[256];
Xpool *tmppool[256];
Xengraving *tmpengraving[256];
Xmazepart *tmppart[10];
Xroom *tmproom[MAXNROFROOMS*2];
Xcorridor *tmpcor[256];
X
Xstatic specialmaze maze;
Xstatic splev special_lev;
Xstatic lev_init init_lev;
X
Xstatic char olist[MAX_REGISTERS], mlist[MAX_REGISTERS];
Xstatic struct coord plist[MAX_REGISTERS];
X
Xint n_olist = 0, n_mlist = 0, n_plist = 0;
X
Xunsigned int nlreg = 0, nreg = 0, ndoor = 0, ntrap = 0, nmons = 0, nobj = 0;
Xunsigned int ndb = 0, nwalk = 0, npart = 0, ndig = 0, nlad = 0, nstair = 0;
Xunsigned int naltar = 0, ncorridor = 0, nrooms = 0, ngold = 0, nengraving = 0;
Xunsigned int nfountain = 0, npool = 0, nsink = 0;
X
Xstatic unsigned long lev_flags = 0;
X
Xunsigned int max_x_map, max_y_map;
X
Xstatic xchar in_room;
X
Xextern int fatal_error;
Xextern int want_warnings;
Xextern char* fname;
X
X
X# line 143 "lev_comp.y"
Xtypedef union 
X{
X	int	i;
X	char*	map;
X	struct {
X		xchar room;
X		xchar wall;
X		xchar door;
X	} corpos;
X} YYSTYPE;
X# define CHAR 257
X# define INTEGER 258
X# define BOOLEAN 259
X# define MESSAGE_ID 260
X# define MAZE_ID 261
X# define LEVEL_ID 262
X# define LEV_INIT_ID 263
X# define GEOMETRY_ID 264
X# define NOMAP_ID 265
X# define OBJECT_ID 266
X# define MONSTER_ID 267
X# define TRAP_ID 268
X# define DOOR_ID 269
X# define DRAWBRIDGE_ID 270
X# define MAZEWALK_ID 271
X# define WALLIFY_ID 272
X# define REGION_ID 273
X# define FILLING 274
X# define RANDOM_OBJECTS_ID 275
X# define RANDOM_MONSTERS_ID 276
X# define RANDOM_PLACES_ID 277
X# define ALTAR_ID 278
X# define LADDER_ID 279
X# define STAIR_ID 280
X# define NON_DIGGABLE_ID 281
X# define ROOM_ID 282
X# define PORTAL_ID 283
X# define TELEPRT_ID 284
X# define BRANCH_ID 285
X# define LEV 286
X# define CHANCE_ID 287
X# define CORRIDOR_ID 288
X# define GOLD_ID 289
X# define ENGRAVING_ID 290
X# define FOUNTAIN_ID 291
X# define POOL_ID 292
X# define SINK_ID 293
X# define NONE 294
X# define RAND_CORRIDOR_ID 295
X# define DOOR_STATE 296
X# define LIGHT_STATE 297
X# define CURSE_TYPE 298
X# define ENGRAVING_TYPE 299
X# define DIRECTION 300
X# define RANDOM_TYPE 301
X# define O_REGISTER 302
X# define M_REGISTER 303
X# define P_REGISTER 304
X# define A_REGISTER 305
X# define ALIGNMENT 306
X# define LEFT_OR_RIGHT 307
X# define CENTER 308
X# define TOP_OR_BOT 309
X# define ALTAR_TYPE 310
X# define UP_OR_DOWN 311
X# define SUBROOM_ID 312
X# define NAME_ID 313
X# define FLAGS_ID 314
X# define FLAG_TYPE 315
X# define MON_ATTITUDE 316
X# define MON_ALERTNESS 317
X# define MON_APPEARANCE 318
X# define STRING 319
X# define MAP_ID 320
X#define yyclearin yychar = -1
X#define yyerrok yyerrflag = 0
Xextern int yychar;
Xextern int yyerrflag;
X#ifndef YYMAXDEPTH
X#define YYMAXDEPTH 150
X#endif
XYYSTYPE yylval, yyval;
X# define YYERRCODE 256
X
X# line 1528 "lev_comp.y"
X
Xint yyexca[] ={
X-1, 1,
X	0, -1,
X	-2, 0,
X-1, 176,
X	44, 98,
X	-2, 97,
X	};
X# define YYNPROD 212
X# define YYLAST 483
Xint yyact[]={
X
X   154,   447,   304,   428,   180,   376,    67,   394,   218,   153,
X   205,    47,   455,   307,   249,    20,    22,   308,   305,    21,
X   103,   102,   105,   149,   155,    49,    28,    12,   434,   435,
X   437,    21,   112,   424,   152,   289,   423,   454,   285,   210,
X    60,   148,    21,   117,   118,   113,   151,   150,    55,    56,
X   410,   385,   364,    21,   421,    60,    21,    21,   310,   297,
X   219,   363,   222,   182,   181,   448,   178,   147,    68,    69,
X    61,   307,   377,   373,   132,   308,   305,   129,   370,   371,
X   395,   206,   392,   250,   245,    61,   207,   251,   326,   323,
X   231,   156,   103,   102,   105,   104,   106,   114,   115,   107,
X   313,    43,   314,   347,   112,   116,   108,   119,   449,   109,
X   110,   111,   309,   293,    74,   117,   118,   113,   197,   126,
X   199,   202,   204,   396,   393,   217,   246,    64,    66,    65,
X   238,   212,   175,   232,   407,    36,    34,    17,     8,     9,
X    25,   443,   440,   277,   183,    44,   442,   239,   432,   426,
X   409,   403,   402,   400,   384,   365,   359,   352,   350,   338,
X   335,   209,   316,   299,   294,   290,   286,   279,   266,   262,
X   211,   243,   236,   132,   129,    70,   226,   227,   228,   229,
X    39,   233,   130,   220,   131,   390,   127,   333,   242,   128,
X   331,   329,   343,   260,   256,   254,   146,   145,   144,   247,
X   248,   141,   140,    78,   192,   139,   138,   137,   191,   252,
X   190,   189,   188,   187,   184,   173,   172,   171,   170,   169,
X   168,   167,   166,   165,   164,   223,   224,   225,   163,   162,
X   161,   160,   159,   158,   157,   122,   121,   120,    81,    80,
X    76,    75,    48,    38,    26,    18,    15,    14,    54,   345,
X   452,   439,   357,   177,   284,   438,   288,   429,   427,    98,
X   100,    99,   425,    79,    94,    93,   291,   292,    86,    84,
X    83,   420,   417,   414,   408,   406,   295,   401,   398,   397,
X   389,   386,   311,   383,   379,   375,   368,   367,   360,   358,
X   357,   321,   351,   349,   348,   344,   342,   337,   334,   332,
X   330,   328,   320,   317,   303,   179,    77,   174,   221,   302,
X   301,   300,   298,   296,   282,   281,   280,   278,   276,   275,
X   274,   273,   272,   214,   271,   270,   215,   214,   263,   261,
X   215,   259,   346,   378,   374,   258,   257,   353,   255,   354,
X   253,   237,   196,   355,   356,   366,   216,   194,   201,   327,
X   324,   193,   186,   185,   124,   123,    50,   234,    40,   336,
X    30,   387,   339,   340,   341,   319,   451,   445,   444,   241,
X   441,   221,   240,   418,   415,   411,   345,    27,   178,   265,
X   399,   239,   217,    31,    16,    11,    23,     2,   213,   269,
X   388,    10,   361,    13,   268,   267,   264,   405,    19,   381,
X   419,   404,   416,   380,   413,   412,    29,   177,   315,   318,
X   101,    37,    97,    96,    95,    92,    45,    91,    51,   430,
X   431,   433,    90,   436,    89,    88,    87,    85,    82,   235,
X   176,    63,    35,    62,    46,    33,    32,   143,   446,   142,
X   136,   450,   135,   134,   133,   372,   322,   325,    59,    58,
X   125,    73,    72,    57,    53,    24,    71,    52,    41,     5,
X     4,     3,     1,   453,   287,   283,     7,     6,   203,   200,
X   198,   195,   382,   312,   230,   422,   244,   391,   369,    42,
X   306,   362,   208 };
Xint yypact[]={
X
X  -123, -1000, -1000,  -123, -1000, -1000,  -287,  -287,   189,   188,
X -1000,  -126,   187,  -126,  -300,  -300,  -120,   186,  -289,  -120,
X   316, -1000, -1000,  -129,  -120,   185,   -77, -1000,   314, -1000,
X  -156, -1000,  -129, -1000, -1000,  -309,   184, -1000,  -294,   312,
X  -289,  -227, -1000, -1000, -1000, -1000,  -148, -1000,  -239, -1000,
X   -82, -1000,  -181, -1000, -1000,   183,   182,  -242, -1000, -1000,
X   181,   180,  -174, -1000,   179,   178,   177,   311, -1000, -1000,
X   310, -1000, -1000,  -169, -1000,   -83,   -84, -1000,  -246,  -246,
X  -277,  -277, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
X -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
X -1000, -1000,   176,   175,   174,   173,   172,   171,   170,   166,
X   165,   164,   163,   162,   161, -1000,   160,   159,   158,   157,
X   -83,   338,   -84,  -245,  -115, -1000,   156, -1000,   309, -1000,
X -1000,   308, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
X -1000, -1000, -1000, -1000, -1000, -1000, -1000,   155,   154,   153,
X   152,   150,   146,   307, -1000, -1000,   303,  -183,  -180,  -215,
X  -262,    26,   342,    22,    85,    85,    85,    26,    26,    26,
X    26,  -168,    26,   342, -1000, -1000, -1000, -1000,   -86, -1000,
X -1000, -1000, -1000,   297,   341,   -83,   -84,  -300,   -87,  -175,
X    26,    26,    26,  -214,  -214,   296, -1000, -1000, -1000,   104,
X   294, -1000, -1000, -1000,   103,   292, -1000, -1000,   291, -1000,
X -1000,   287, -1000, -1000, -1000,   102,   285,   -89,   284, -1000,
X -1000,   339,   -90, -1000, -1000, -1000,   281, -1000,   280,   278,
X   277, -1000, -1000,   276, -1000,   275,   274,  -116,   273,   -91,
X -1000, -1000, -1000, -1000,   272, -1000, -1000, -1000, -1000,   271,
X -1000, -1000,   270,  -263,   -92,  -266,   -93,    26,    26,  -187,
X   -94,  -214,   269,  -252,   268,   -95,   267,   266,   265,   260,
X  -230,  -188,  -253,    26,  -199,   338,   -96,   259,   107,   258,
X  -215,    49,    48,   257, -1000, -1000,    98,   256, -1000, -1000,
X    97, -1000, -1000,   255,    94,   254,   -98, -1000,    85,   253,
X   -99,    85,    85,    85,   252, -1000, -1000, -1000,   101, -1000,
X -1000, -1000,   251, -1000, -1000, -1000,   335,  -214, -1000, -1000,
X  -197,   250,   249,  -100, -1000,   248,  -101, -1000,    26, -1000,
X    26, -1000,  -215, -1000,  -277,   246,   245,  -102,   208,   244,
X -1000, -1000,  -249,  -103,  -300, -1000,   243,   242,  -222,    33,
X   241,    32,   240, -1000, -1000, -1000,   239,  -104,  -260,   237,
X  -300,   236, -1000, -1000, -1000,    92, -1000,  -177,  -178,   235,
X -1000, -1000,   234,  -239, -1000,  -105,   233,  -106, -1000,  -107,
X -1000,   231, -1000,  -140,   230, -1000,  -108, -1000, -1000,  -261,
X -1000, -1000, -1000, -1000,   334, -1000, -1000,  -178,    32,   229,
X   333,  -300,   228,   332,   227, -1000,  -265,   218,  -109,   214,
X -1000, -1000, -1000,   213,  -245, -1000,   213,  -110, -1000, -1000,
X  -288,   211,   207, -1000, -1000,  -117,   329,  -112, -1000,  -118,
X   327, -1000,   326, -1000, -1000, -1000, -1000,  -300,  -193,  -193,
X -1000, -1000,   325, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
X   206, -1000,  -282, -1000, -1000, -1000 };
Xint yypgo[]={
X
X     0,     6,     4,   482,     9,    10,    14,     2,   481,   480,
X     3,   479,     7,   478,   477,   476,   475,     1,   474,   473,
X   385,   377,   472,    60,   384,   184,   471,   470,   189,   469,
X   468,     0,   467,   466,   465,   464,   463,   130,   462,   387,
X   461,   460,   459,   386,   383,   458,   457,   456,   455,   454,
X   186,   182,   248,   453,   452,   451,   450,   449,   203,   448,
X   447,     5,   446,   445,   444,   443,   442,   440,   207,   206,
X   205,   202,   201,   439,   437,   198,   197,   196,   436,   435,
X   434,   433,   432,   431,   132,   430,   429,   428,   427,   426,
X   425,   424,   422,   417,   415,   414,   413,   412,   410,     8,
X   403,   401,   400,   399,   397,   396,   395,   394,   392,   390,
X   389,   183,   131,   388 };
Xint yyr1[]={
X
X     0,    38,    38,    39,    39,    40,    40,    41,    42,    33,
X    24,    24,    14,    14,    20,    20,    21,    21,    43,    43,
X    48,    45,    45,    49,    49,    46,    46,    52,    52,    47,
X    47,    54,    55,    55,    56,    56,    37,    53,    53,    59,
X    57,    10,    10,    62,    62,    60,    60,    63,    63,    61,
X    61,    58,    58,    64,    64,    64,    64,    64,    64,    64,
X    64,    64,    64,    64,    64,    64,    65,    66,    67,    15,
X    15,    13,    13,    12,    12,    32,    11,    11,    44,    44,
X    78,    79,    79,    82,     1,     1,     2,     2,    80,    80,
X    83,    83,    83,    50,    50,    51,    51,    84,    86,    84,
X    81,    81,    87,    87,    87,    87,    87,    87,    87,    87,
X    87,    87,    87,    87,    87,    87,    87,    87,    87,    87,
X    87,   100,    68,   101,   101,   102,   102,   102,   102,   102,
X   103,    69,   104,   104,   104,    16,    16,    17,    17,    88,
X    70,    89,    95,    96,    97,    77,   105,    91,   106,    92,
X   107,   108,    93,   110,    94,   109,   109,    23,    23,    72,
X    73,    74,    98,    90,    71,    75,    76,    26,    26,    26,
X    29,    29,    29,    34,    34,    35,    35,     3,     3,     4,
X     4,    22,    22,    22,    99,    99,    99,     5,     5,     6,
X     6,     7,     7,     7,     8,     8,   113,    30,    27,     9,
X    85,    25,    28,    31,    36,    36,    18,    18,    19,    19,
X   112,   111 };
Xint yyr2[]={
X
X     0,     0,     2,     2,     4,     2,     2,    11,    15,     7,
X     1,    27,     2,     2,     1,     7,     3,     7,     0,     4,
X     7,     0,     4,     7,     7,     1,     2,     2,     4,     2,
X     2,     3,     0,     4,    11,    11,    15,     5,     5,    25,
X    25,     1,     5,    11,     3,    11,     3,    11,     3,    11,
X     3,     0,     4,     2,     2,     2,     2,     2,     2,     2,
X     2,     2,     2,     2,     2,     2,     7,     7,    19,     2,
X     2,     2,     2,     2,     2,    11,     3,     3,     2,     4,
X     7,     3,     5,    11,     2,     2,     2,     2,     0,     4,
X     7,     7,     7,     3,     7,     3,     7,     3,     1,     8,
X     0,     4,     2,     2,     2,     2,     2,     2,     2,     2,
X     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
X     2,     1,    19,     0,     4,     5,     5,     5,     5,     7,
X     1,    19,     1,     9,    13,     2,     2,     2,     3,    11,
X    11,    15,    11,     3,    11,    11,     1,    17,     1,    17,
X     1,     1,    17,     1,    13,     1,     5,     3,    21,     7,
X     7,     7,     7,    17,    15,    11,    15,     2,     3,     2,
X     2,     3,     2,     2,     3,     2,     3,     3,     2,     3,
X     2,     1,     5,     9,     2,     2,     3,     2,     2,     2,
X     2,     2,     2,     3,     2,     2,     9,     9,     9,     9,
X     2,     3,     3,     2,     2,     3,     2,     2,     2,     2,
X    11,    19 };
Xint yychk[]={
X
X -1000,   -38,   -39,   -40,   -41,   -42,   -32,   -33,   261,   262,
X   -39,   -20,   314,   -20,    58,    58,   -24,   263,    58,   -24,
X   -31,   319,   -31,   -43,   -48,   260,    58,   -21,   315,   -43,
X    44,   -44,   -78,   -79,   265,   -82,   264,   -43,    58,   257,
X    44,   -45,   -11,   257,   301,   -44,   -80,   320,    58,   319,
X    44,   -21,   -46,   -49,   -52,   275,   276,   -53,   -57,   -59,
X   282,   312,   -81,   -83,   275,   277,   276,    -1,   307,   308,
X   257,   -47,   -54,   -55,   295,    58,    58,   -52,   -58,   -58,
X    58,    58,   -87,   -68,   -69,   -88,   -70,   -89,   -90,   -91,
X   -92,   -93,   -94,   -71,   -72,   -95,   -96,   -97,   -77,   -75,
X   -76,   -98,   267,   266,   269,   268,   270,   273,   280,   283,
X   284,   285,   278,   291,   271,   272,   279,   289,   290,   281,
X    58,    58,    58,    44,    44,   -56,   288,   -50,   -28,   257,
X   -51,   -25,   257,   -64,   -65,   -66,   -67,   -68,   -69,   -70,
X   -71,   -72,   -73,   -74,   -75,   -76,   -77,   313,   287,   269,
X   293,   292,   280,    -4,   -31,   301,    -4,    58,    58,    58,
X    58,    58,    58,    58,    58,    58,    58,    58,    58,    58,
X    58,    58,    58,    58,   -50,   -84,   -85,  -112,    40,   -51,
X    -2,   309,   308,   259,    58,    44,    44,    58,    58,    58,
X    58,    58,    58,    44,    44,   -26,   -25,   301,   -27,   303,
X   -29,   -28,   301,   -30,   302,    -5,   296,   301,    -3,   -31,
X   301,   -99,  -112,  -113,   301,   304,  -111,    40,   -99,   -23,
X  -111,   286,    40,   -23,   -23,   -23,   -99,   -99,   -99,   -99,
X   -18,   258,   301,   -99,  -111,   -86,   258,    44,   -37,    40,
X   -50,   -51,   -31,   258,   -15,   259,   301,   -99,   -99,    -6,
X   297,   301,    -6,    44,    91,    44,    91,    44,    44,    44,
X    91,    44,   258,    44,  -105,    40,   258,  -106,  -107,  -110,
X    44,    44,    44,    44,    44,    44,    44,   259,    44,   258,
X    44,    44,    44,   -34,   -31,   301,   258,   -35,   -31,   301,
X   258,   -99,   -99,   300,   258,    -6,    44,   311,    44,   258,
X    44,    44,    44,    44,    -7,   306,    -9,   301,   305,   300,
X   311,   -99,   -19,   299,   301,   -84,   258,    44,   -37,   258,
X    44,    -5,   -62,    40,   301,   -60,    40,   301,    44,    93,
X    44,    93,    44,    93,    44,   258,   -23,    44,   258,   -23,
X   -23,   -23,    44,    91,    44,    41,    -6,   300,    44,    44,
X   258,    44,   258,   -99,   -99,    -5,    -4,    44,    44,   258,
X    44,  -108,    -8,   310,   301,   258,   -31,    44,    44,   -13,
X   300,   301,   -63,    40,   301,    44,   -61,    40,   301,    44,
X  -100,  -103,   -22,    44,   258,   311,    44,   -31,  -109,    44,
X    93,   -14,   259,   301,   -12,   258,   301,    44,    44,    -1,
X   258,    44,   258,   258,  -101,  -104,    44,   274,    44,   258,
X   311,    41,   -12,   -61,    44,    41,   -31,    44,    41,  -102,
X    44,   319,   -16,   301,   298,    44,   258,    44,   -10,    44,
X    -2,   -10,   258,   -31,   316,   317,    -7,   318,    44,    44,
X   259,    41,   258,   259,    41,    41,   -31,   -17,   258,   301,
X   -17,    41,    44,   -36,   319,   294 };
Xint yydef[]={
X
X     1,    -2,     2,     3,     5,     6,    14,    14,     0,     0,
X     4,    10,     0,    10,     0,     0,    18,     0,     0,    18,
X     0,   203,     9,     0,    18,     0,     0,    15,    16,    21,
X     0,     7,    78,    88,    81,     0,     0,    19,     0,     0,
X     0,    25,    75,    76,    77,    79,   100,    82,     0,    20,
X     0,    17,    32,    22,    26,     0,     0,    27,    51,    51,
X     0,     0,    80,    89,     0,     0,     0,     0,    84,    85,
X     0,     8,    29,    30,    31,     0,     0,    28,    37,    38,
X     0,     0,   101,   102,   103,   104,   105,   106,   107,   108,
X   109,   110,   111,   112,   113,   114,   115,   116,   117,   118,
X   119,   120,     0,     0,     0,     0,     0,     0,     0,     0,
X     0,     0,     0,     0,     0,   143,     0,     0,     0,     0,
X     0,     0,     0,     0,     0,    33,     0,    23,    93,   202,
X    24,    95,   201,    52,    53,    54,    55,    56,    57,    58,
X    59,    60,    61,    62,    63,    64,    65,     0,     0,     0,
X     0,     0,     0,     0,   179,   180,     0,     0,     0,     0,
X     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
X     0,     0,     0,     0,    90,    91,    -2,   200,     0,    92,
X    83,    86,    87,     0,     0,     0,     0,     0,     0,     0,
X     0,     0,     0,     0,     0,     0,   167,   168,   169,     0,
X     0,   170,   171,   172,     0,     0,   187,   188,     0,   177,
X   178,     0,   184,   185,   186,     0,     0,     0,     0,   146,
X   157,     0,     0,   148,   150,   153,     0,   159,     0,     0,
X     0,   206,   207,     0,   162,     0,     0,     0,     0,     0,
X    94,    96,    66,    67,     0,    69,    70,   160,   161,     0,
X   189,   190,     0,     0,     0,     0,     0,     0,     0,     0,
X     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
X     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
X     0,     0,     0,     0,   173,   174,     0,     0,   175,   176,
X     0,   139,   140,     0,     0,     0,     0,   145,     0,     0,
X     0,     0,     0,     0,     0,   191,   192,   193,     0,   142,
X   144,   165,     0,   208,   209,    99,     0,     0,    34,    35,
X     0,     0,     0,     0,    44,     0,     0,    46,     0,   198,
X     0,   197,     0,   196,     0,     0,     0,     0,     0,     0,
X   151,   154,     0,     0,     0,   210,     0,     0,     0,     0,
X     0,     0,     0,   121,   130,   141,   181,     0,     0,     0,
X     0,   155,   164,   194,   195,     0,   166,     0,     0,     0,
X    71,    72,     0,     0,    48,     0,     0,     0,    50,     0,
X   123,   132,   163,     0,     0,   147,     0,   149,   152,     0,
X   199,    11,    12,    13,     0,    73,    74,     0,     0,     0,
X     0,     0,     0,     0,   122,   131,     0,   182,     0,     0,
X   156,    36,    68,    41,     0,    43,    41,     0,    45,   124,
X     0,     0,     0,   135,   136,     0,     0,     0,    40,     0,
X     0,    39,     0,   125,   126,   127,   128,     0,     0,     0,
X   183,   211,     0,    42,    47,    49,   129,   133,   137,   138,
X     0,   158,     0,   134,   204,   205 };
Xtypedef struct { char *t_name; int t_val; } yytoktype;
X#ifndef YYDEBUG
X#	define YYDEBUG	0	/* don't allow debugging */
X#endif
X
X#if YYDEBUG
X
Xyytoktype yytoks[] =
X{
X	"CHAR",	257,
X	"INTEGER",	258,
X	"BOOLEAN",	259,
X	"MESSAGE_ID",	260,
X	"MAZE_ID",	261,
X	"LEVEL_ID",	262,
X	"LEV_INIT_ID",	263,
X	"GEOMETRY_ID",	264,
X	"NOMAP_ID",	265,
X	"OBJECT_ID",	266,
X	"MONSTER_ID",	267,
X	"TRAP_ID",	268,
X	"DOOR_ID",	269,
X	"DRAWBRIDGE_ID",	270,
X	"MAZEWALK_ID",	271,
X	"WALLIFY_ID",	272,
X	"REGION_ID",	273,
X	"FILLING",	274,
X	"RANDOM_OBJECTS_ID",	275,
X	"RANDOM_MONSTERS_ID",	276,
X	"RANDOM_PLACES_ID",	277,
X	"ALTAR_ID",	278,
X	"LADDER_ID",	279,
X	"STAIR_ID",	280,
X	"NON_DIGGABLE_ID",	281,
X	"ROOM_ID",	282,
X	"PORTAL_ID",	283,
X	"TELEPRT_ID",	284,
X	"BRANCH_ID",	285,
X	"LEV",	286,
X	"CHANCE_ID",	287,
X	"CORRIDOR_ID",	288,
X	"GOLD_ID",	289,
X	"ENGRAVING_ID",	290,
X	"FOUNTAIN_ID",	291,
X	"POOL_ID",	292,
X	"SINK_ID",	293,
X	"NONE",	294,
X	"RAND_CORRIDOR_ID",	295,
X	"DOOR_STATE",	296,
X	"LIGHT_STATE",	297,
X	"CURSE_TYPE",	298,
X	"ENGRAVING_TYPE",	299,
X	"DIRECTION",	300,
X	"RANDOM_TYPE",	301,
X	"O_REGISTER",	302,
X	"M_REGISTER",	303,
X	"P_REGISTER",	304,
X	"A_REGISTER",	305,
X	"ALIGNMENT",	306,
X	"LEFT_OR_RIGHT",	307,
X	"CENTER",	308,
X	"TOP_OR_BOT",	309,
X	"ALTAR_TYPE",	310,
X	"UP_OR_DOWN",	311,
X	"SUBROOM_ID",	312,
X	"NAME_ID",	313,
X	"FLAGS_ID",	314,
X	"FLAG_TYPE",	315,
X	"MON_ATTITUDE",	316,
X	"MON_ALERTNESS",	317,
X	"MON_APPEARANCE",	318,
X	",",	44,
X	":",	58,
X	"(",	40,
X	")",	41,
X	"[",	91,
X	"]",	93,
X	"STRING",	319,
X	"MAP_ID",	320,
X	"-unknown-",	-1	/* ends search */
X};
X
Xchar * yyreds[] =
X{
X	"-no such reduction-",
X	"file : /* empty */",
X	"file : levels",
X	"levels : level",
X	"levels : level levels",
X	"level : maze_level",
X	"level : room_level",
X	"maze_level : maze_def flags lev_init messages regions",
X	"room_level : level_def flags lev_init messages rreg_init rooms corridors_def",
X	"level_def : LEVEL_ID ':' string",
X	"lev_init : /* empty */",
X	"lev_init : LEV_INIT_ID ':' CHAR ',' CHAR ',' BOOLEAN ',' BOOLEAN ',' light_state ',' walled",
X	"walled : BOOLEAN",
X	"walled : RANDOM_TYPE",
X	"flags : /* empty */",
X	"flags : FLAGS_ID ':' flag_list",
X	"flag_list : FLAG_TYPE",
X	"flag_list : FLAG_TYPE ',' flag_list",
X	"messages : /* empty */",
X	"messages : message messages",
X	"message : MESSAGE_ID ':' STRING",
X	"rreg_init : /* empty */",
X	"rreg_init : rreg_init init_rreg",
X	"init_rreg : RANDOM_OBJECTS_ID ':' object_list",
X	"init_rreg : RANDOM_MONSTERS_ID ':' monster_list",
X	"rooms : /* empty */",
X	"rooms : roomlist",
X	"roomlist : aroom",
X	"roomlist : aroom roomlist",
X	"corridors_def : random_corridors",
X	"corridors_def : corridors",
X	"random_corridors : RAND_CORRIDOR_ID",
X	"corridors : /* empty */",
X	"corridors : corridors corridor",
X	"corridor : CORRIDOR_ID ':' corr_spec ',' corr_spec",
X	"corridor : CORRIDOR_ID ':' corr_spec ',' INTEGER",
X	"corr_spec : '(' INTEGER ',' DIRECTION ',' door_pos ')'",
X	"aroom : room_def room_details",
X	"aroom : subroom_def room_details",
X	"subroom_def : SUBROOM_ID ':' room_type ',' light_state ',' subroom_pos ',' room_size ',' string roomfill",
X	"room_def : ROOM_ID ':' room_type ',' light_state ',' room_pos ',' room_align ',' room_size roomfill",
X	"roomfill : /* empty */",
X	"roomfill : ',' BOOLEAN",
X	"room_pos : '(' INTEGER ',' INTEGER ')'",
X	"room_pos : RANDOM_TYPE",
X	"subroom_pos : '(' INTEGER ',' INTEGER ')'",
X	"subroom_pos : RANDOM_TYPE",
X	"room_align : '(' h_justif ',' v_justif ')'",
X	"room_align : RANDOM_TYPE",
X	"room_size : '(' INTEGER ',' INTEGER ')'",
X	"room_size : RANDOM_TYPE",
X	"room_details : /* empty */",
X	"room_details : room_details room_detail",
X	"room_detail : room_name",
X	"room_detail : room_chance",
X	"room_detail : room_door",
X	"room_detail : monster_detail",
X	"room_detail : object_detail",
X	"room_detail : trap_detail",
X	"room_detail : altar_detail",
X	"room_detail : fountain_detail",
X	"room_detail : sink_detail",
X	"room_detail : pool_detail",
X	"room_detail : gold_detail",
X	"room_detail : engraving_detail",
X	"room_detail : stair_detail",
X	"room_name : NAME_ID ':' string",
X	"room_chance : CHANCE_ID ':' INTEGER",
X	"room_door : DOOR_ID ':' secret ',' door_state ',' door_wall ',' door_pos",
X	"secret : BOOLEAN",
X	"secret : RANDOM_TYPE",
X	"door_wall : DIRECTION",
X	"door_wall : RANDOM_TYPE",
X	"door_pos : INTEGER",
X	"door_pos : RANDOM_TYPE",
X	"maze_def : MAZE_ID ':' string ',' filling",
X	"filling : CHAR",
X	"filling : RANDOM_TYPE",
X	"regions : aregion",
X	"regions : aregion regions",
X	"aregion : map_definition reg_init map_details",
X	"map_definition : NOMAP_ID",
X	"map_definition : map_geometry MAP_ID",
X	"map_geometry : GEOMETRY_ID ':' h_justif ',' v_justif",
X	"h_justif : LEFT_OR_RIGHT",
X	"h_justif : CENTER",
X	"v_justif : TOP_OR_BOT",
X	"v_justif : CENTER",
X	"reg_init : /* empty */",
X	"reg_init : reg_init init_reg",
X	"init_reg : RANDOM_OBJECTS_ID ':' object_list",
X	"init_reg : RANDOM_PLACES_ID ':' place_list",
X	"init_reg : RANDOM_MONSTERS_ID ':' monster_list",
X	"object_list : object",
X	"object_list : object ',' object_list",
X	"monster_list : monster",
X	"monster_list : monster ',' monster_list",
X	"place_list : place",
X	"place_list : place",
X	"place_list : place ',' place_list",
X	"map_details : /* empty */",
X	"map_details : map_details map_detail",
X	"map_detail : monster_detail",
X	"map_detail : object_detail",
X	"map_detail : door_detail",
X	"map_detail : trap_detail",
X	"map_detail : drawbridge_detail",
X	"map_detail : region_detail",
X	"map_detail : stair_region",
X	"map_detail : portal_region",
X	"map_detail : teleprt_region",
X	"map_detail : branch_region",
X	"map_detail : altar_detail",
X	"map_detail : fountain_detail",
X	"map_detail : mazewalk_detail",
X	"map_detail : wallify_detail",
X	"map_detail : ladder_detail",
X	"map_detail : stair_detail",
X	"map_detail : gold_detail",
X	"map_detail : engraving_detail",
X	"map_detail : diggable_detail",
X	"monster_detail : MONSTER_ID ':' monster_c ',' m_name ',' coordinate",
X	"monster_detail : MONSTER_ID ':' monster_c ',' m_name ',' coordinate monster_infos",
X	"monster_infos : /* empty */",
X	"monster_infos : monster_infos monster_info",
X	"monster_info : ',' string",
X	"monster_info : ',' MON_ATTITUDE",
X	"monster_info : ',' MON_ALERTNESS",
X	"monster_info : ',' alignment",
X	"monster_info : ',' MON_APPEARANCE string",
X	"object_detail : OBJECT_ID ':' object_c ',' o_name ',' coordinate",
X	"object_detail : OBJECT_ID ':' object_c ',' o_name ',' coordinate object_infos",
X	"object_infos : /* empty */",
X	"object_infos : ',' STRING ',' enchantment",
X	"object_infos : ',' curse_state ',' enchantment ',' art_name",
X	"curse_state : RANDOM_TYPE",
X	"curse_state : CURSE_TYPE",
X	"enchantment : INTEGER",
X	"enchantment : RANDOM_TYPE",
X	"door_detail : DOOR_ID ':' door_state ',' coordinate",
X	"trap_detail : TRAP_ID ':' trap_name ',' coordinate",
X	"drawbridge_detail : DRAWBRIDGE_ID ':' coordinate ',' DIRECTION ',' door_state",
X	"mazewalk_detail : MAZEWALK_ID ':' coordinate ',' DIRECTION",
X	"wallify_detail : WALLIFY_ID",
X	"ladder_detail : LADDER_ID ':' coordinate ',' UP_OR_DOWN",
X	"stair_detail : STAIR_ID ':' coordinate ',' UP_OR_DOWN",
X	"stair_region : STAIR_ID ':' lev_region",
X	"stair_region : STAIR_ID ':' lev_region ',' lev_region ',' UP_OR_DOWN",
X	"portal_region : PORTAL_ID ':' lev_region",
X	"portal_region : PORTAL_ID ':' lev_region ',' lev_region ',' string",
X	"teleprt_region : TELEPRT_ID ':' lev_region",
X	"teleprt_region : TELEPRT_ID ':' lev_region ',' lev_region",
X	"teleprt_region : TELEPRT_ID ':' lev_region ',' lev_region teleprt_detail",
X	"branch_region : BRANCH_ID ':' lev_region",
X	"branch_region : BRANCH_ID ':' lev_region ',' lev_region",
X	"teleprt_detail : /* empty */",
X	"teleprt_detail : ',' UP_OR_DOWN",
X	"lev_region : region",
X	"lev_region : LEV '(' INTEGER ',' INTEGER ',' INTEGER ',' INTEGER ')'",
X	"fountain_detail : FOUNTAIN_ID ':' coordinate",
X	"sink_detail : SINK_ID ':' coordinate",
X	"pool_detail : POOL_ID ':' coordinate",
X	"diggable_detail : NON_DIGGABLE_ID ':' region",
X	"region_detail : REGION_ID ':' region ',' light_state ',' room_type prefilled",
X	"altar_detail : ALTAR_ID ':' coordinate ',' alignment ',' altar_type",
X	"gold_detail : GOLD_ID ':' amount ',' coordinate",
X	"engraving_detail : ENGRAVING_ID ':' coordinate ',' engraving_type ',' string",
X	"monster_c : monster",
X	"monster_c : RANDOM_TYPE",
X	"monster_c : m_register",
X	"object_c : object",
X	"object_c : RANDOM_TYPE",
X	"object_c : o_register",
X	"m_name : string",
X	"m_name : RANDOM_TYPE",
X	"o_name : string",
X	"o_name : RANDOM_TYPE",
X	"trap_name : string",
X	"trap_name : RANDOM_TYPE",
X	"room_type : string",
X	"room_type : RANDOM_TYPE",
X	"prefilled : /* empty */",
X	"prefilled : ',' FILLING",
X	"prefilled : ',' FILLING ',' BOOLEAN",
X	"coordinate : coord",
X	"coordinate : p_register",
X	"coordinate : RANDOM_TYPE",
X	"door_state : DOOR_STATE",
X	"door_state : RANDOM_TYPE",
X	"light_state : LIGHT_STATE",
X	"light_state : RANDOM_TYPE",
X	"alignment : ALIGNMENT",
X	"alignment : a_register",
X	"alignment : RANDOM_TYPE",
X	"altar_type : ALTAR_TYPE",
X	"altar_type : RANDOM_TYPE",
X	"p_register : P_REGISTER '[' INTEGER ']'",
X	"o_register : O_REGISTER '[' INTEGER ']'",
X	"m_register : M_REGISTER '[' INTEGER ']'",
X	"a_register : A_REGISTER '[' INTEGER ']'",
X	"place : coord",
X	"monster : CHAR",
X	"object : CHAR",
X	"string : STRING",
X	"art_name : STRING",
X	"art_name : NONE",
X	"amount : INTEGER",
X	"amount : RANDOM_TYPE",
X	"engraving_type : ENGRAVING_TYPE",
X	"engraving_type : RANDOM_TYPE",
X	"coord : '(' INTEGER ',' INTEGER ')'",
X	"region : '(' INTEGER ',' INTEGER ',' INTEGER ',' INTEGER ')'",
X};
X#endif /* YYDEBUG */
X#line 1 "/usr/lib/yaccpar"
X/*	@(#)yaccpar 1.10 89/04/04 SMI; from S5R3 1.10	*/
X
X/*
X** Skeleton parser driver for yacc output
X*/
X
X/*
X** yacc user known macros and defines
X*/
X#define YYERROR		goto yyerrlab
X#define YYACCEPT	{ free(yys); free(yyv); return(0); }
X#define YYABORT		{ free(yys); free(yyv); return(1); }
X#define YYBACKUP( newtoken, newvalue )\
X{\
X	if ( yychar >= 0 || ( yyr2[ yytmp ] >> 1 ) != 1 )\
X	{\
X		yyerror( "syntax error - cannot backup" );\
X		goto yyerrlab;\
X	}\
X	yychar = newtoken;\
X	yystate = *yyps;\
X	yylval = newvalue;\
X	goto yynewstate;\
X}
X#define YYRECOVERING()	(!!yyerrflag)
X#ifndef YYDEBUG
X#	define YYDEBUG	1	/* make debugging available */
X#endif
X
X/*
X** user known globals
X*/
Xint yydebug;			/* set to 1 to get debugging */
X
X/*
X** driver internal defines
X*/
X#define YYFLAG		(-1000)
X
X/*
X** static variables used by the parser
X*/
Xstatic YYSTYPE *yyv;			/* value stack */
Xstatic int *yys;			/* state stack */
X
Xstatic YYSTYPE *yypv;			/* top of value stack */
Xstatic int *yyps;			/* top of state stack */
X
Xstatic int yystate;			/* current state */
Xstatic int yytmp;			/* extra var (lasts between blocks) */
X
Xint yynerrs;			/* number of errors */
X
Xint yyerrflag;			/* error recovery flag */
Xint yychar;			/* current input token number */
X
X
X/*
X** yyparse - return 0 if worked, 1 if syntax error not recovered from
X*/
Xint
Xyyparse()
X{
X	register YYSTYPE *yypvt;	/* top of value stack for $vars */
X	unsigned yymaxdepth = YYMAXDEPTH;
X
X	/*
X	** Initialize externals - yyparse may be called more than once
X	*/
X	yyv = (YYSTYPE*)malloc(yymaxdepth*sizeof(YYSTYPE));
X	yys = (int*)malloc(yymaxdepth*sizeof(int));
X	if (!yyv || !yys)
X	{
X		yyerror( "out of memory" );
X		return(1);
X	}
X	yypv = &yyv[-1];
X	yyps = &yys[-1];
X	yystate = 0;
X	yytmp = 0;
X	yynerrs = 0;
X	yyerrflag = 0;
X	yychar = -1;
X
X	goto yystack;
X	{
X		register YYSTYPE *yy_pv;	/* top of value stack */
X		register int *yy_ps;		/* top of state stack */
X		register int yy_state;		/* current state */
X		register int  yy_n;		/* internal state number info */
X
X		/*
X		** get globals into registers.
X		** branch to here only if YYBACKUP was called.
X		*/
X	yynewstate:
X		yy_pv = yypv;
X		yy_ps = yyps;
X		yy_state = yystate;
X		goto yy_newstate;
X
X		/*
X		** get globals into registers.
X		** either we just started, or we just finished a reduction
X		*/
X	yystack:
X		yy_pv = yypv;
X		yy_ps = yyps;
X		yy_state = yystate;
X
X		/*
X		** top of for (;;) loop while no reductions done
X		*/
X	yy_stack:
X		/*
X		** put a state and value onto the stacks
X		*/
X#if YYDEBUG
X		/*
X		** if debugging, look up token value in list of value vs.
X		** name pairs.  0 and negative (-1) are special values.
X		** Note: linear search is used since time is not a real
X		** consideration while debugging.
X		*/
X		if ( yydebug )
X		{
X			register int yy_i;
X
X			(void)printf( "State %d, token ", yy_state );
X			if ( yychar == 0 )
X				(void)printf( "end-of-file\n" );
X			else if ( yychar < 0 )
X				(void)printf( "-none-\n" );
X			else
X			{
X				for ( yy_i = 0; yytoks[yy_i].t_val >= 0;
X					yy_i++ )
X				{
X					if ( yytoks[yy_i].t_val == yychar )
X						break;
X				}
X				(void)printf( "%s\n", yytoks[yy_i].t_name );
X			}
X		}
X#endif /* YYDEBUG */
X		if ( ++yy_ps >= &yys[ yymaxdepth ] )	/* room on stack? */
X		{
X			/*
X			** reallocate and recover.  Note that pointers
X			** have to be reset, or bad things will happen
X			*/
X			int yyps_index = (yy_ps - yys);
X			int yypv_index = (yy_pv - yyv);
X			int yypvt_index = (yypvt - yyv);
X			yymaxdepth += YYMAXDEPTH;
X			yyv = (YYSTYPE*)realloc((char*)yyv,
X				yymaxdepth * sizeof(YYSTYPE));
X			yys = (int*)realloc((char*)yys,
X				yymaxdepth * sizeof(int));
X			if (!yyv || !yys)
X			{
X				yyerror( "yacc stack overflow" );
X				return(1);
X			}
X			yy_ps = yys + yyps_index;
X			yy_pv = yyv + yypv_index;
X			yypvt = yyv + yypvt_index;
X		}
X		*yy_ps = yy_state;
X		*++yy_pv = yyval;
X
X		/*
X		** we have a new state - find out what to do
X		*/
X	yy_newstate:
X		if ( ( yy_n = yypact[ yy_state ] ) <= YYFLAG )
X			goto yydefault;		/* simple state */
X#if YYDEBUG
X		/*
X		** if debugging, need to mark whether new token grabbed
X		*/
X		yytmp = yychar < 0;
X#endif
X		if ( ( yychar < 0 ) && ( ( yychar = yylex() ) < 0 ) )
X			yychar = 0;		/* reached EOF */
X#if YYDEBUG
X		if ( yydebug && yytmp )
X		{
X			register int yy_i;
X
X			(void)printf( "Received token " );
X			if ( yychar == 0 )
X				(void)printf( "end-of-file\n" );
X			else if ( yychar < 0 )
X				(void)printf( "-none-\n" );
X			else
X			{
X				for ( yy_i = 0; yytoks[yy_i].t_val >= 0;
X					yy_i++ )
X				{
X					if ( yytoks[yy_i].t_val == yychar )
X						break;
X				}
X				(void)printf( "%s\n", yytoks[yy_i].t_name );
X			}
X		}
X#endif /* YYDEBUG */
X		if ( ( ( yy_n += yychar ) < 0 ) || ( yy_n >= YYLAST ) )
X			goto yydefault;
X		if ( yychk[ yy_n = yyact[ yy_n ] ] == yychar )	/*valid shift*/
X		{
X			yychar = -1;
X			yyval = yylval;
X			yy_state = yy_n;
X			if ( yyerrflag > 0 )
X				yyerrflag--;
X			goto yy_stack;
X		}
X
X	yydefault:
X		if ( ( yy_n = yydef[ yy_state ] ) == -2 )
X		{
X#if YYDEBUG
X			yytmp = yychar < 0;
X#endif
X			if ( ( yychar < 0 ) && ( ( yychar = yylex() ) < 0 ) )
X				yychar = 0;		/* reached EOF */
X#if YYDEBUG
X			if ( yydebug && yytmp )
X			{
X				register int yy_i;
X
X				(void)printf( "Received token " );
X				if ( yychar == 0 )
X					(void)printf( "end-of-file\n" );
X				else if ( yychar < 0 )
X					(void)printf( "-none-\n" );
X				else
X				{
X					for ( yy_i = 0;
X						yytoks[yy_i].t_val >= 0;
X						yy_i++ )
X					{
X						if ( yytoks[yy_i].t_val
X							== yychar )
X						{
X							break;
X						}
X					}
X					(void)printf( "%s\n", yytoks[yy_i].t_name );
X				}
X			}
X#endif /* YYDEBUG */
X			/*
X			** look through exception table
X			*/
X			{
X				register int *yyxi = yyexca;
X
X				while ( ( *yyxi != -1 ) ||
X					( yyxi[1] != yy_state ) )
X				{
X					yyxi += 2;
X				}
X				while ( ( *(yyxi += 2) >= 0 ) &&
X					( *yyxi != yychar ) )
X					;
X				if ( ( yy_n = yyxi[1] ) < 0 )
X					YYACCEPT;
X			}
X		}
X
X		/*
X		** check for syntax error
X		*/
X		if ( yy_n == 0 )	/* have an error */
X		{
X			/* no worry about speed here! */
X			switch ( yyerrflag )
X			{
X			case 0:		/* new error */
X				yyerror( "syntax error" );
X				goto skip_init;
X			yyerrlab:
X				/*
X				** get globals into registers.
X				** we have a user generated syntax type error
X				*/
X				yy_pv = yypv;
X				yy_ps = yyps;
X				yy_state = yystate;
X				yynerrs++;
X			skip_init:
X			case 1:
X			case 2:		/* incompletely recovered error */
X					/* try again... */
X				yyerrflag = 3;
X				/*
X				** find state where "error" is a legal
X				** shift action
X				*/
X				while ( yy_ps >= yys )
X				{
X					yy_n = yypact[ *yy_ps ] + YYERRCODE;
X					if ( yy_n >= 0 && yy_n < YYLAST &&
X						yychk[yyact[yy_n]] == YYERRCODE)					{
X						/*
X						** simulate shift of "error"
X						*/
X						yy_state = yyact[ yy_n ];
X						goto yy_stack;
X					}
X					/*
X					** current state has no shift on
X					** "error", pop stack
X					*/
X#if YYDEBUG
X#	define _POP_ "Error recovery pops state %d, uncovers state %d\n"
X					if ( yydebug )
X						(void)printf( _POP_, *yy_ps,
X							yy_ps[-1] );
X#	undef _POP_
X#endif
X					yy_ps--;
X					yy_pv--;
X				}
X				/*
X				** there is no state on stack with "error" as
X				** a valid shift.  give up.
X				*/
X				YYABORT;
X			case 3:		/* no shift yet; eat a token */
X#if YYDEBUG
X				/*
X				** if debugging, look up token in list of
X				** pairs.  0 and negative shouldn't occur,
X				** but since timing doesn't matter when
X				** debugging, it doesn't hurt to leave the
X				** tests here.
X				*/
X				if ( yydebug )
X				{
X					register int yy_i;
X
X					(void)printf( "Error recovery discards " );
X					if ( yychar == 0 )
X						(void)printf( "token end-of-file\n" );
X					else if ( yychar < 0 )
X						(void)printf( "token -none-\n" );
X					else
X					{
X						for ( yy_i = 0;
X							yytoks[yy_i].t_val >= 0;
X							yy_i++ )
X						{
X							if ( yytoks[yy_i].t_val
X								== yychar )
X							{
X								break;
X							}
X						}
X						(void)printf( "token %s\n",
X							yytoks[yy_i].t_name );
X					}
X				}
X#endif /* YYDEBUG */
X				if ( yychar == 0 )	/* reached EOF. quit */
X					YYABORT;
X				yychar = -1;
X				goto yy_newstate;
X			}
X		}/* end if ( yy_n == 0 ) */
X		/*
X		** reduction by production yy_n
X		** put stack tops, etc. so things right after switch
X		*/
X#if YYDEBUG
X		/*
X		** if debugging, print the string that is the user's
X		** specification of the reduction which is just about
X		** to be done.
X		*/
X		if ( yydebug )
X			(void)printf( "Reduce by (%d) \"%s\"\n",
X				yy_n, yyreds[ yy_n ] );
X#endif
X		yytmp = yy_n;			/* value to switch over */
X		yypvt = yy_pv;			/* $vars top of value stack */
X		/*
X		** Look in goto table for next state
X		** Sorry about using yy_state here as temporary
X		** register variable, but why not, if it works...
X		** If yyr2[ yy_n ] doesn't have the low order bit
X		** set, then there is no action to be done for
X		** this reduction.  So, no saving & unsaving of
X		** registers done.  The only difference between the
X		** code just after the if and the body of the if is
X		** the goto yy_stack in the body.  This way the test
X		** can be made before the choice of what to do is needed.
X		*/
X		{
X			/* length of production doubled with extra bit */
X			register int yy_len = yyr2[ yy_n ];
X
X			if ( !( yy_len & 01 ) )
X			{
X				yy_len >>= 1;
X				yyval = ( yy_pv -= yy_len )[1];	/* $$ = $1 */
X				yy_state = yypgo[ yy_n = yyr1[ yy_n ] ] +
X					*( yy_ps -= yy_len ) + 1;
X				if ( yy_state >= YYLAST ||
X					yychk[ yy_state =
X					yyact[ yy_state ] ] != -yy_n )
X				{
X					yy_state = yyact[ yypgo[ yy_n ] ];
X				}
X				goto yy_stack;
X			}
X			yy_len >>= 1;
X			yyval = ( yy_pv -= yy_len )[1];	/* $$ = $1 */
X			yy_state = yypgo[ yy_n = yyr1[ yy_n ] ] +
X				*( yy_ps -= yy_len ) + 1;
X			if ( yy_state >= YYLAST ||
X				yychk[ yy_state = yyact[ yy_state ] ] != -yy_n )
X			{
X				yy_state = yyact[ yypgo[ yy_n ] ];
X			}
X		}
X					/* save until reenter driver code */
X		yystate = yy_state;
X		yyps = yy_ps;
X		yypv = yy_pv;
X	}
END_OF_FILE
if test 42090 -ne `wc -c <'sys/share/lev_yacc.c1'`; then
    echo shar: \"'sys/share/lev_yacc.c1'\" unpacked with wrong size!
fi
# end of 'sys/share/lev_yacc.c1'
fi
echo shar: End of archive 32 \(of 108\).
cp /dev/null ark32isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \
21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \
41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 \
61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 \
81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 \
101 102 103 104 105 106 107 108 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 108 archives.
    echo "Now execute 'rebuild.sh'"
    rm -f ark10[0-8]isdone ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
