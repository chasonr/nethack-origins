Path: uunet!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v16i092:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Part84/108
Message-ID: <4455@master.CNA.TEK.COM>
Date: 5 Feb 93 19:21:45 GMT
Sender: news@master.CNA.TEK.COM
Lines: 1761
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1643

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 16, Issue 92
Archive-name: nethack31/Part84
Supersedes: nethack3p9: Volume 10, Issue 46-102
Environment: Amiga, Atari, Mac, MS-DOS, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 84 (of 108)."
# Contents:  include/spell.h sys/msdos/Install.dos sys/msdos/ovlmgr.doc
#   sys/share/dgn_lex.c
# Wrapped by billr@saab on Wed Jan 27 16:09:20 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'include/spell.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/spell.h'\"
else
echo shar: Extracting \"'include/spell.h'\" \(326 characters\)
sed "s/^X//" >'include/spell.h' <<'END_OF_FILE'
X/*	SCCS Id: @(#)spell.h	3.1	90/22/02	*/
X/* Copyright 1986, M. Stephenson				  */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#ifndef SPELL_H
X#define SPELL_H
X
Xstruct spell {
X	int	sp_id;			/* spell id */
X	int	sp_lev;			/* power level */
X	int	sp_uses;		/* uses left to spell */
X};
X
X#endif /* SPELL_H */
END_OF_FILE
if test 326 -ne `wc -c <'include/spell.h'`; then
    echo shar: \"'include/spell.h'\" unpacked with wrong size!
fi
# end of 'include/spell.h'
fi
if test -f 'sys/msdos/Install.dos' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/msdos/Install.dos'\"
else
echo shar: Extracting \"'sys/msdos/Install.dos'\" \(18184 characters\)
sed "s/^X//" >'sys/msdos/Install.dos' <<'END_OF_FILE'
X	SCCS Id: @(#)Install.dos	 3.1		93/01/06
X
X        Copyright (c) NetHack PC Development Team 1990 - 1993.
X        NetHack may be freely redistributed.  See license for details.
X	    ======================================================
X            Instructions for compiling and installing
X                 NetHack 3.1 on an MS-DOS system
X	    ======================================================
X                 (or, How to make PC NetHack 3.1)
X                    Last revision: Jan 6, 1993
X
XCredit for a runnable full PC NetHack 3.1 goes to the PC Development team
Xof Norm Meluch, Kevin Smolkowski, Paul Winner and Steve VanDevender who
Xbuilt on the work of Pierre Martineau, Stephen Spackman, Steve Creps,
XMike Threepoint and Don Kneller.
X
XI.  Dispelling the Myths:
X
X    Compiling NetHack is not as easy as it sounds, nor as hard as it looks,
X    however it will behoove you to read this entire file through before
X    beginning the task.
X
X    We have provided the proper makefiles for building NetHack using the
X    following compilers:
X
X    Microsoft C 6.0a
X    Microsoft C 7.0
X    DJGPP       1.9   (gcc version 2.2 for msdos,
X                       free from your local archive sites)
X
X    For specific details concerning each compiler, please see the
X    corresponding appendix.
X
X    All the makefiles were created for use with NDMAKE.  The make programs
X    provided by the various vendors all seem to lack necessary features.
X    NDMAKE is available free from your local archive site.
X
X    You may find it useful to obtain copies of lex (flex) and yacc (bison).
X    While not strictly necessary to compile nethack, they are required should
X    you desire to make any changes to the level and dungeon compilers.
X    Flex and Bison are included with the DJGPP distribution and are also
X    available on many archive sites.
X
XII. To compile your copy of NetHack on a MSDOS machine:
X    (or "just follow these few 'simple' steps outlined below.")
X
X1.  It almost goes without saying that you should make sure that your tools
X    are set up and running correctly.
X
X2.  Make sure all the NetHack files are in the appropriate directory
X    structure.  You should have a main directory with subdirectories
X    dat, doc, include, src, sys\share, sys\msdos, util and win\tty.
X    Other subdirectories may also be included in your distribution, but
X    they are not necessary for use with MSDOS.  You can delete them
X    to save space.  If you are using MSC7, the makefile will create
X    an additional directory src\o.
X
X    Check the file "Files" in your top level directory for an exact
X    listing of what file is in which directory.  In order for the
X    Makefiles to work, all the source files must be in the proper
X    locations.
X
X    If you downloaded or ftp'd the sources from a UNIX system, the lines
X    will probably end in UNIX-style newlines, instead of the carriage
X    return and line feed pairs used by DOS.  Some programs have trouble
X    with them, so you may need to convert them (with a utility like
X    Rahul Dhesi's "flip").  Also, every file should end with an empty
X    line, because both Microsoft C and MASM have a habit of ignoring the
X    last line of each file. 
X
X3.  The file termcap.uu is the fixed version of the Fred Fish termcap library.
X    You will need to run a uudecode utility on it to generate the file
X    termcap.zip.  termcap.zip contains several files of termcap routines.
X    Using them with NetHack involves very little knowledge of the UNIX concept
X    of a termcap database; mostly you need to know enough to set a TERM
X    environment variable.  You can unzip termcap.zip in the sys/msdos
X    directory, but if you are going to use it, it is probably better to
X    unzip a copy in a special directory and copy the library files to where
X    your linker can find them.
X
X    Makefiles are included should you want to build your own termcap
X    library file.  Makemsc.lib works with Microsoft C and generates
X    termcap.lib, Makegcc.lib works with DJGPP and generates libtermc.a.
X
X4.  ovlmgr.uu (MS-DOS overlay manager) is the uuencoded assembled
X    object module for the overlay manager used with Microsoft C 6.0
X    and older.  This file is provided in case you do not have an assembler
X    of your own.  You will need to run a uudecode utility on this file too,
X    to generate ovlmgr.obj.  If you want to use this, put the ovlmgr.obj
X    in the src directory; the makefile will access it when it needs it.
X
X5.  Go to the sys/msdos directory and run the setup.bat batch file
X    with either MSC or GCC as the argument.  The necessary Makefile
X    movements will be accomplished for you.  In addition, when used
X    with the MSC option, certain compiler options will be set.  Make
X    sure that you either run setup.bat each time you start compiling
X    or copy the line that starts "SET CL" into your autoexec.bat file.
X
X6.  Now go to the include subdirectory to check a couple of the header
X    files there.  Things *should* work as they are, but since you have
X    probably set up your system in some sort of custom configuration
X    it doesn't hurt to check out the following:
X
X    First check config.h according to the comments to match your system and
X    desired set of features.  Mostly you need to check the WIZARD option,
X    make sure the HACKDIR is set properly, and check TERMLIB and COMPRESS.
X
X    We've managed to enable all the special features.  You may include all
X    or as few of them as you wish.
X
X    Also check pcconf.h, which should not need much editing (if you are
X    including termcap.uu and random.c).  If you are not including these, you
X    will need to comment out TERMLIB and/or RANDOM.  If you are using
X    a Microsoft compiler you should make doubly certain that OVERLAY is
X    defined in pcconf.h, since otherwise things will compile properly but
X    very ugly things are likely to happen wherever function pointers
X    cross overlay boundaries - the linker is a little thick about that.
X
X    Commenting out the #define TERMLIB in pcconf.h to disable use of termcap
X    routines (relying on the ANSI_DEFAULT feature) will make your job a bit
X    easier.  However, you can compile with both TERMLIB and ANSI_DEFAULT
X    and simply not set your TERM variable if you do not wish to use the
X    termcap file settings.
X
X7.  If you want to change the high score list behavior, examine the top of
X    topten.c, in the src directory.  You may want to change the definitions of
X    PERSMAX, POINTSMIN, and ENTRYMAX.  I set POINTSMIN to 51 and ENTRYMAX to
X    50 to keep the size of the score list down.
X
X8.  Go to the src directory and edit the top of your Makefile.  Be sure the
X    directory you want the game installed (GAMEDIR) in actually exists.
X
X    If you elected not to use the high-quality BSD random number routines by
X    commenting out RANDOM in pcconf.h or tosconf.h, comment out (or set equal
X    to nothing) the RANDOM macro in your Makefile.
X
X    If you are recompiling after patching your sources, or if you got your
X    files from somewhere other than the official distribution, "touch
X    makedefs.c" to ensure that certain files (onames.h and pm.h) are remade,
X    lest potentially troublesome timestamps fool "make".
X
X9.  Now that everything is set up, go to the util directory and
X    run ndmake.  If you get any errors along the way then something
X    has not been set correctly.  Next do the same in the dat directory.
X    Finally, go to the src directory and "make install".  Depending on
X    your particular machine and compiler, you can either grab a cup
X    of coffee or go home for the day.  Your computer will be occupied
X    for a long time.  If all goes well, you will get an NetHack executable.
X
X10. Make sure the support files -- data, rumors, cmdhelp, opthelp, help, hh,
X    history, and license -- were copied to the game directory.  If not,
X    move them there from the dat directory yourself.  rumors. can be
X    created manually be entering "makedefs -r", data. by entering
X    "makedefs -d".
X
X    Make sure the files NetHack.cnf and termcap also made it to your game
X    directory.  If not, go to sys\share and copy NetHack.cnf and
X    termcap to your game directory.  Edit NetHack.cnf to reflect your
X    particular setup and personal preferences, by following the comments.
X
X    If you'll be running NetHack from a different subdirectory, you will
X    want to "set HACKDIR=c:\games\nethack" (or whatever drive and directory 
X    you want to use) now.  Add it to your autoexec.bat (in DOS), as you'll
X    be playing often.
X
X11. Play NetHack.  If it works, you're done!
X
X
XAppendix A - Microsoft C Compilers
X
X    You can compile NetHack using almost any version of Microsoft C later
X    than 5.1.  Versions 5.0 and earlier are broken in such a way that it
X    is impossible to use them.  Version 6.0 requires a patch available
X    from Microsoft; after applying you should have 6.0ax.  Version 7.0
X    works with or without the August 1992 patch.
X
X    Officially, support is no longer provided for MSC versions prior to
X    6.0ax.  NetHack v3.1 will compile with 5.1, but you will need to
X    make a lot of modifications to the makefiles in order to avoid heap
X    space problems.  We strongly recommend upgrading to 6.0ax if you
X    intend to recompile NetHack often.
X
X    One Makefile is used for all versions.  Version 7.0 takes advantage
X    of the CL environment variables to set the compiler flags, as they
X    exceed the MSDOS limitation of 128 characters on the command line.
X    Please read the Makefile carefully and select those options that
X    go with the compiler.  Also, remember to run setup.bat to set the
X    CL environment variable before you compile.
X
X    We use the following Makefiles:
X    MakeMSC.src  - src directory
X    MakeMSC.utl  - util directory
X    Makefile.dat - dat directory
X
X    The Makefile uses a structured break-up of the object modules so that
X    we can link heavily used functions together without actual source code
X    movement.  This has provided a great speed improvement for this release.
X    See the file sys\msdos\ovlmgr.doc for more information on this
X    structuring.
X
X  Microsoft C version 6.0:
X    The NetHack executable that you are about to get will be generated by an
X    overlay linker.  The beauty of this overlay linker beastie is that it will
X    create an executable that will function in much less memory than it would
X    "normally" take to run.  Do not be deceived.  The RAM requirement for the
X    overlay version is about 550k!  You can load the program in less RAM, but
X    you will begin to experience a serious amount of disk thrashing at 530k
X    or less.  Absolute minimum will probably be in the neighborhood of 380-400k.
X    You do not want to run the program like that!  The more free RAM you have
X    available for the program, the more smoothly it will run.
X
X    Microsoft's internal overlay management scheme was pretty useless prior
X    to version 7.0.  However, the sheer size of NetHack requires some sort
X    of overlay scheme.  The magic piece to this puzzle is a program called
X    ovlmgr.asm.  This is a replacement for the Microsoft (and we use the
X    term loosely) overlay manager.  This program has been enhanced since
X    its release in November 1989.  It will now allow NetHack to use EMS
X    memory if any is available.  Also, the overlay manager will now read
X    overlays out of files completely separate from the EXE.  This will
X    cut down on the size of files for NetHack making distribution to PCs
X    with low density disk drives much easier.
X
X    If you have a MASM compatible Assembler, you may want to enable the option
X    in the makefile to rebuild ovlmgr.obj, although a ready-made object file 
X    is provided for those of you without.  Before assembling ovlmgr, be sure
X    to read ovlmgr.doc as there are several options that you may or may not
X    wish to enable/disable.
X
X  Microsoft C version 7.0
X    Microsoft was finally able to come out with a workable overlay
X    linker in version 7.0.  Instead of linking in the custom overlay
X    manager, we just let Microsoft do the work.
X
XAppendix B - DJGPP Compiler (gcc ported to msdos)
X
X    If you have a 386 or better machine, you are in luck.  You can compile
X    NetHack without spending money on a compiler.  DJGPP is available free
X    from many archive sites.
X
X    Setting up DJGPP is more than adequately explained in the documentation
X    that comes with it.  Be sure to pick up the yacc and flex built with
X    DJGPP if you intend to do any modification of the special levels or
X    dungeon compilers.  They should be available at the same place you got
X    djgpp.
X
X    The executable version of NetHack built with DJGPP runs in protected mode
X    without overlays and is quite fast.  It cannot run under Microsoft
X    Windows.  See the DJGPP documentation for more details on particular
X    memory requirements.
X
X    Building with DJGPP is easy, just follow the steps outlined in the
X    main section.
X
XAppendix C - Borland C Compiler
X
X    NetHack will not compile at all with any version of Turbo C/C++.  It
X    has been made to compile with Borland C v2.0 after much work, but the
X    resulting binaries are far too slow to be playable.  It will not compile
X    with Borland C/C++ v3.0 - the bugs in that version of the compiler
X    related to the preprocessor make a total mess out of the macros that
X    the NetHack code is laced with.  We haven't had much luck at
X    compiling with v3.1 either.  If you successfully compile a playable
X    binary using any version of Borland's compiler we would love to
X    hear from you -- it would be a sure ticket to a position on the PC
X    Development team and all the fame and fortune that goes along with
X    it.  To get you started, here are a few hints.
X
X    0. This should almost go without saying, but if you just bought
X       Borland (or Turbo C) and you are thinking that compiling
X       NetHack would be a great way to learn C and your nifty new
X       compiler at the same time, you are either going to prove
X       yourself some kind of prodigy or get very frustrated and quit.
X
X    1. We left most of the __TURBOC__ defines in the code, some are
X       necessary, others are not, and a few are misleading depending
X       upon which compiler version you use as they relate to problems
X       with Borland compilers long since fixed.  We left them in to
X       provide some landmarks for future Borland hackers.
X
X    2. No makefiles are provided as nothing we have tried has really
X       worked.  Most of our attempts have started off using the
X       GCC makefiles.
X
X    3. Start off by working with the utility programs in the util
X       directory.  They are the smallest and will give you some
X       measure of success before you tackle the main code.  The
X       programs contained in util are necessary to build the
X       game so you will not be wasting your time.  Once you get
X       the utility program compiled, run the makefile in the dat
X       directory.  The utility programs you just compiled will attempt
X       to convert the raw data files into game readable form.  If you
X       get errors then something is wrong.
X
XAppendix D - Microsoft C Compiler Warnings
X
X    If you are using MSC for your compile with any of the /W levels set,
X    you can expect warnings.  The list below are those warnings that we
X    are aware of and our recommendation for dealing with them.  You can
X    use the warning disable pragma to ignore them if you wish.  (NOTE:
X    this is not a complete list of all warnings you might receive, only
X    those for which we feel we can safely provide guidance on.)
X
XC4131 (function:uses old-style declarator)
X    You should ignore this warning.  In order to make the source code as
X    portable as possible, only old-style declarators are used so that as
X    many compilers as possible can use the same code.
XC4706 (Assignment within conditional expression)
X    This is a perfectly valid construction.  These warnings have not
X    produced any problems.
XC4761 (Integral size mismatch in argument; conversion supplied)
X    These should be no problem.  Prototyping compilers will do the con-
X    version, and non-prototyping compilers will go through int anyway.
X
X
XNotes:
X
X1)  Save files and bones files from previous versions of NetHack will not
X    work with this NetHack.  Don't bother trying to keep them.  Record
X    (score) files from before 3.0 patchlevel 7 will almost work, but you need
X    to make one change manually to them:  At the end of each line is a word or
X    phrase specifying what killed the player.  Change the string to start with
X    the words "killed by", "killed by a", or "killed by an" (whichever is
X    appropriate).  If the death was petrification, it should read "petrified
X    by" instead of "killed by".  Don't change "starvation", "quit", "escaped",
X    or "ascended".
X
X2)  To install an update of NetHack after changing something, enter "make45l"
X    from the src directory.  If you add, delete, or reorder monsters or
X    objects, or you change the format of saved level files, delete any save
X    and bones files.  (Trying to use such files sometimes produces amusing
X    confusions on the game's part, but usually crashes.)
X
X    If you made changes to any of the level compiler software, you may have
X    to delete dgn_flex.c, dgn_yacc.c, lev_flex.c, and lev_yacc.c from the
X    util directory to ensure that they are remade.
X
X3)  During linking the Microsoft Overlay Linker will need temporary storage
X    space.  Make sure you have about a meg of free disk wherever you have
X    defined your temporary storage.
X
X4)  If you have comments or suggestions, feel free to drop any one of
X    us a line c/o nethack-bugs@linc.cis.upenn.edu.  From compuserve,
X    try INTERNET:nethack-bugs@linc.cis.upenn.edu.  Should you be
X    without email access, some of us can still be reached by lesser means:
X
X    For the west coast:
X      Kevin D Smolkowski
X      c/o OSLC
X      207 E 5th
X      Eugene, OR  97401
X
X    Compuserve users can also reach Paul Winner by sending compuserve mail
X    to 73207,226.  The NetHack binaries and sources can be found in the
X    GAMERS forum.
END_OF_FILE
if test 18184 -ne `wc -c <'sys/msdos/Install.dos'`; then
    echo shar: \"'sys/msdos/Install.dos'\" unpacked with wrong size!
fi
# end of 'sys/msdos/Install.dos'
fi
if test -f 'sys/msdos/ovlmgr.doc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/msdos/ovlmgr.doc'\"
else
echo shar: Extracting \"'sys/msdos/ovlmgr.doc'\" \(18111 characters\)
sed "s/^X//" >'sys/msdos/ovlmgr.doc' <<'END_OF_FILE'
X    SCCS Id: @(#)ovlmgr.doc		 3.1		91/02/02
X    Copyright (c) 1989, 1990, 1991, 1992, 1993 Pierre G Martineau and
X    Stephen P Spackman.  All Rights Reserved.
X    NetHack may be freely redistributed.  See license for details.
X		 ====================================
X		 Brief notes about ovlmgr.asm [v30a0]
X		 ====================================
X		       (revised 1991february02)
X
XOVLMGR.ASM is a multiple-residency overlay manager for use with the
XMicrosoft Overlay Linker.  It is functionally compatible with the one
Xin the MSC library _except_:
X
X- it usually accesses the disk less often and is a lot faster in some
X  applications.
X- it permits overlays to be stored in the .EXE file and/or in separate
X  .OVL files.
X- it has different tuning characteristics.
X- you must (of course) link OVLMGR.OBJ into the root overlay (that is,
X  outside any parentheses in the link command).
X
XSee also the notes below.
X
X	As with other Microsoft-compatible overlay handlers you must
Xbe *very* careful never to call a function in an overlay through a
Xpointer, unless the initiator of the call resides in the *same*
Xphysical overlay as the target (This is, of course, *not* the same
Xthing as the called function being declared static, since the static
Xdeclaration affects only the visibility of the name of the function,
Xnot the distribution of pointers to it.) (1).  Furthermore, setjmp()
Xand longjmp() are not supported.
X
X	Unlike the Microsoft system, most of the available memory is
Xused to hold overlays.	Care must be taken to ensure that enough space
Xis reserved for the C heap.  This can be accomplished through
Xinformation stored in the .EXE file (currently the minalloc parameter,
Xas described below).
X
X	Furthermore, expanded memory support (EMS) is now an integral
Xpart of the overlay manager.  LIM EMS versions 3.2 and 4.0 are
Xsupported.  Note that the page frame must be 4 pages long (64K bytes) to
Xbe able to operate correctly (most drivers allocate a 64K frame by
Xdefault).  The overlay manager will use as much EMS as is necessary in
X64K chunks, up to a limit of 16 chunks (1 Meg).  Both hardware and
Xsoftware EMS drivers have been tested and found to be completely
Xcompatible.
X
X	Starting with version 30a0, overlays are not restricted to
Xbeing stored in the main .EXE files (as they are with Microsoft's
Xoverlay manager).  Using the utility EXESMURF arbitrary contiguous
Xsequences of overlays can be unloaded into external overlay files.
XAlthough EXESMURF provides some flexibility in naming these files,
XOVLMGR presently only supports its default option, whereby the
Xoverlays of a programme PROGRAM.EXE must match the pattern
XPROGRAM?.OVL (if the basename had eight characters, as FILENAME.EXE,
Xthen the last character is replaced: FILENAM?.EXE) and reside in the
X*same* directory as the .EXE (not even a path search is performed).
XThis mechanism permits large applications to be represented with small
Xfiles, resulting in a slight performance improvement (due to less and
Xshorter disk seeking) and easier transfer with floppy disks, at the
Xcost of a heavier demand for file-handles.
X
X				~ * ~
X
X	OVLMGR.ASM currently has three assembly-time options, which are
Xspecified with the assembler's /D<symbol> option (or compatible).  They
Xare:
X
X	/DNOEMS   Disable EMS support.
X		  OVLMGR normally detects the presence of EMS memory
X		  and makes use of it whenever it is present.  This
X		  flag instructs ovlmgr to ignore EMS and operate only
X		  out of conventional memory.  It should be used when
X		  overlaying programmes which expect to use EMS
X		  themselves.
X
X	/Di386	  Use 80386-specific instruction sequences.
X		  Use of this flag will make ovlmgr perform better on
X		  machines with 80386 processors.  However, the
X		  resulting programme will not run at all on machines
X		  with less capable CPUs.  Use this option with
X		  caution, especially in the case of distribution
X		  code.
X
X	/DNOSPLIT Do not provide for external .OVL files.
X		  If this flag is NOT set, OVLMGR will look for
X		  overlays for the programme PROGRAM.EXE in all files
X		  matching the pattern PROGRAM?.OVL, as well as in the
X		  .EXE file itself.  This arrangement may be slightly
X		  faster and will result in more, smaller files, but
X		  is obviously less robust, since mismatched .OVL
X		  files can cause mayhem.  .OVL files can be generated
X		  with our EXESMURF .EXE file manipulation utility.
X
X				~ * ~
X
X	Although using the overlay manager is in essence much like using
XMicrosoft's, they operate on a slightly different principle, and tuning
Xfor them is rather different.  Technical part begins.
X
X	When overlay linking is requested (see your linker manual), the
XMS overlay linker changes all far calls into overlays from the (normal,
X8086) format:
X
X	offset	contents
X	------	--------
X	:0000	CALL
X	:0001	target-offset
X	:0003	target-segment
X
Xto this:
X	:0000	INT
X	:0001	int#	target-mod#
X	:0003	target-offset
X
X(note that here we are looking at the actual layout of the machine
Xcode, not at the assembly code as such) and relocates the code parts
Xof all the different overlays into the *same* physical area.  The
Xoverlaid code is all actually placed at the end of the .EXE file,
Xafter the 'normal' executable image, along with all its administrative
Xdata (fixups etc.).
X
X	When this altered 'call' is executed, of course, the interrupt
Xhandler int# is invoked.  Its job is to ensure that the target overlay
Xmodule is in memory (reading it from the tail of the .EXE file if it
Xisn't already loaded) and then transfer to the given offset within it,
X'faking up' the effect of the 'real' far call that would normally have
Xoccurred.  Something similar must be done when the call returns, to
Xensure that the thing being returned *into* is still (or is once more)
Xloaded.
X
X	The Microsoft linker, as we have said, relocates all the
Xoverlays to the same load address; and, in fact, it allocates am empty
Xblock of memory there that is at least as large as the largest
Xoverlay.  Into this area all the overlays are loaded without further
Xchange; thus, there can only ever be one overlay in memory at one
Xtime.  Transferring from one overlay to another causes one overlay to
Xreplace the other in the allocated overlay swap area.
X
X	Our overlay manager does not use the space allocated by the
Xlinker in the same way.  Rather, it allocates almost all of the memory
Xavailable from MS-DOS (including the original overlay area and any high
XDOS memory) as well as EMS memory if some is available and that option
Xis being used.	As overlays are needed, they are loaded wherever they
Xwill fit, and dynamically relocated to that address.  Thus, many more
Xthan one overlay may be loaded at any given time, greatly increasing
Xpotential performance.	Management of space is more or less according to
Xan LRU policy - once all of memory is full, the least recently used
Xoverlay is selected as the most likely candidate for replacement.
X
X	The implications of this difference are as follows:  while with
Xthe conventional (default) overlay manager, the best strategy is to
Xgroup object modules together in an overlay whenever they are known to
Xbe used in rapid succession, to make each overlay as big as possible
X(all things being equal) in order to take advantage of all available
Xmemory, and to make as few overlays as possible (to reduce the amount of
Xdisk access), the best strategy with our overlay manager is almost the
Xreverse.  Having a lot of small overlays will increase the amount of
Xuseful stuff that can be resident in memory at the same time; all of
Xmemory will automatically be employed; and there is no advantage at all
Xto uniformity of size (except perhaps in the unlikely case of *exact*
Xuniformity!).
X
X	Although ovlmgr allocates all available memory while it is
Xactive, you will find that the DOS exec() call works normally.	The
Xmemory that is allocated for administering the overlay system is freed
Xbefore the exec call is made and reallocated afterwards (we trap the DOS
Xfunction request vector to do this, which isn't very nice as a
Xprogramming practise but makes the existence of the overlay manager far
Xmore transparent).  There is, however, one circumstance under which this
Xcan be problematic:  if you use the exec() call to load a TSR
Xapplication, thereby causing memory that the overlay manager was using
Xto become unavailable, you may make it impossible for the overlaid
Xapplication to proceed.  This is because code that is nominally
X'running' (i.e. is currently on the stack) cannot be relocated and must
Xbe reloaded at the *same address* that previously held it.  If another
Xprocess now owns that area of memory, there is nothing we can do.  We
Xbelieve that this should not be a serious concern in normal use.
X
X				~ * ~
X
X	Since all available memory is potentially used by ovlmgr, there
Xis one additional concern in using it with C programmes:  the allocation
Xof sufficient space for the C heap (2).  While previous versions of
Xovlmgr.asm required the change of an internal constant and re-assembly
Xof ovlmgr to change the amount of space pre-allocated for this purpose,
Xthe current version uses the DOS minalloc parameter in the executable
Xfile to hold the size of the desired heap area.  This parameter can be
Xset at any time after the link process with either Microsoft's exemod
Xutility or with the supplied utility, exesmurf.
X
X				~ * ~
X
XNOTA BENE: This is an early version of the overlay manager, but by now
Xit should be fairly well debugged. If you are considering upgrading it
Xplease be aware that the following improvements are planned for the
Xnext version (though who knows when delivery will occur):
X
X      - compatible versions of setjmp() and longjmp()
X      - integral malloc() to eliminate the heap size guesswork
X      - support for swapped data areas (read-only and read/write)
X      - improved performance through dynamic link-loading (maybe)
X      - interlocking to permit floppy disk juggling use
X      - XMS support and improved EMS support
X      - support for divergent-functionality overlays (such as
X	  hardware-specific modules)
X      - enabling the overlay locking code
X      - more flexibility in naming and locating external overlay files
X      - Major code revamping
X
XSwap On!
X
X------------------------------------------------------------------------
XMESSAGES
X
XOVLMGR: EMS memory manager error.
X
X	An error occurred during an EMS access.  Either the hardware has
X	reported a bug, the software driver has detected an anomaly or
X	the page frame is not 64K bytes in length.
X
XOVLMGR: Executable or overlay header missing or damaged.
X
X	The end of a file was reached unexpectedly during
X	initialisation, while trying to locate the overlays.  This is a
X	very bad sign (though I am concerned that it might be triggered
X	spuriously by debug information or other non-executable tails on
X	files).
X
XOVLMGR: File I/O error.
X
X	An error occurred while trying to load an overlay.  We don't
X	want this.
X
XOVLMGR: Inaccessible EXE file. Can't load overlays.
X
X	For some reason ovlmgr could not locate or read the original
X	.EXE file in which the overlays reside.  This could be due to
X	your attempting to use a very old version of DOS,
X	an abject shortage of file handles, some strange event causing
X	the file to be deleted, a disk error, or the diskette that
X	contained the executable being removed.
X
XOVLMGR: Inaccessible OVL file. Can't load overlays.
X
X	An error was reported while attempting to open an .OVL file
X	which was expected (from its name) to contain external overlays.
X	The possible causes are similar to those of the previous
X	message.
X
XOVLMGR: Incomplete executable.  OVL files missing?
X
X	OVLMGR was unable to locate all of its overlays for some reason.
X	This could be due to I/O errors on the disk drive, but is more
X	likely caused by an external .OVL file not being present in the
X	same directory as the .EXE.
X
XOVLMGR: Incorrect DOS version. Must be 3.00 or later.
X
X	The current version of ovlmgr does not support versions of DOS
X	prior to 3.0 because of the difficulty of locating the
X	executable file (and hence the overlays) at runtime.
X
XOVLMGR: Internal memory allocation failure.
X
X	Either an internal error has occurred in ovlmgr or the
X	application programme, or some event has caused memory that
X	ovlmgr believed it could count on becoming unavailable.  A
X	typical example of the latter would be the result of
X	attempting to load a TSR while an overlaid application is
X	running.
X
XOVLMGR: Not enough free memory left to run this program.
X
X	Although DOS successfully loaded the programme, it proved
X	impossible to allocate enough additional contiguous memory to
X	load one or more of the overlays.  Either reduce the
X	RAM-loading of the application by reducing the size of either
X	the root or the largest overlays, or increase the amount of
X	memory available by unloading TSRs and/or simplifying your
X	CONFIG.SYS.
X
XOVLMGR: Unable to resolve overlay file names.
X
X	Apparently the name reported to OVLMGR as being that of the
X	executable file is ill-formed, and it is thus not possible to
X	intuit what external overlay files would be called.  It is
X	possible that this indicates that DOS has gone bonkers, but more
X	likely (I guess) that the .EXE was not invoked by DOS as we know
X	it.  Either way, you have entered the Twilight Zone....
X
X(xxxx:xxxx:xxxx:xxxx)
X
X	This is a diagnostic code composed of the following fields:
X		- error code
X		- version number
X		- available conventional memory
X		- EMS memory usage
X	Please note it in any bug reports or correspondence with the
X	development team.
X
X------------------------------------------------------------------------
XKNOWN BUGS
X
XThe present version cannot always be used as a direct replacement for
XMicrosoft's overlay manager (even granted the documented differences)
Xbecause the minimum size required for an overlaid programme to run is at
Xleast the size of the root plus TWICE the size of the largest overlay.
XIf a programme has previously had its overlay structure tuned to take
Xbest advantage of Microsoft overlays, this may well cause a problem.
XThe overlays themselves will need to be split up.
X
XWhen the MicroSoft linker discovers that an overlay as requested
Xcontains NO instructions at all (this can happen by mistake if you give
Xa source file that winds up holding only data declarations its own
Xoverlay), it does not emit an overlay record for it at all - there is
Xsimply a gap in the overlay sequence in the file.  The current version
Xof OVLMGR detects this as an error, since it assumes that such a gap
Xshould have been filled by an external .OVL file.  It is presently your
Xresponsibility to ensure that this does not occur.
X
XFiles containing overlays are kept open all the time the application
Xis running.  Particularly if multiple external .OVL files are used,
Xthis can result in less file handles being available to the user
Xprogramme than would otherwise be expected.
X
XALL files that match the pattern for potential overlay files are
Xopened, regardless of whether they actually contain overlays.
X
XThe names of external overlay files have a very restricted form, and
Xthey must reside in the same directory with the .EXE.  These
Xlimitations cause them to be useful for little else besides making
Xdistribution easier.
X
XTransfers between overlays are very slow in machine terms, even if both
Xoverlays happen to reside in memory at the time (still significantly
Xfaster than Microsoft's, though).  This means that overlay patterns
Xmust be chosen on the basis of more than just logical dependency.
X
XLocking overlays into memory is not really implemented even though
Xreading the source code might make you think it was.  Actually, reading
Xthe source code itself isn't very well implemented right now.  Comments
Xand stuff would help.  Yup, yup.
X
XDue to limitations in the LIM EMS standard (to 4.0), programmes that
Xthemselves use EMS memory cannot be overlaid with ovlmgr unless ovlmgr's
Xown EMS support is disabled.  This is accomplished by assembling with
Xthe /DNOEMS flag.
X
X------------------------------------------------------------------------
XBUG ALERT
X
XTo repeat a point made above, if you ever try to call a function in an
Xoverlay through a pointer, you *may* die with the Microsoft overlay
Xmanager.  If you ever try to call a function in an overlay through a
Xpointer, you *will* die with ours.  Nothing in an overlay ever ends up
Xin the same segment as the linker anticipated.	You have been warned!
X
X------------------------------------------------------------------------
XFOOTNOTES
X
X(1) This problem can be circumvented through the use of surrogate
X'trampoline' functions:  functions that reside in the root overlay and
Xsimply pass right through to the 'real', overlaid, implementations.
XThis can even be made transparent to the source code through the use
Xof the C macro preprocessor, with a locution of the form
X	#define foo(x) foo_(x)
Xvisible everywhere except at the actual definition point of the
Xtrampoline.  This method was implemented in NetHack 3.0, and remains today.
X
X(2) If you should get a message to the effect that NetHack can't
Xallocate 28000 and some bytes when entering a maze level, that
Xisn't our problem!  In all probability you forgot to rebuild your
Xspecial level files when you changed the compiler flags.  We got
Xthat one, too, at one point.  The same applies to similar messages when
Xreading bones files or saved games:  it is more likely that you forgot
Xto discard them after recompiling your game than that the memory
Xallowance is so greatly incorrect.
X
X----------------------------------------------------------------------
XNOTICE
X
XOVLMGR.ASM is brought to you by Pierre Martineau and Stephen Spackman.
XIt, and this document, are copyright.  They are, however, provided as
Xpart of NetHack and may be freely distributed as described in the
XNetHack license.
X
X----------------------------------------------------------------------
XStephen P Spackman			     stephen@tira.uchicago.edu
XPierre G Martineau		   pierre%ozrout.uucp@altitude.cam.org
X----------------------------------------------------------------------
X    Copyright (c) 1989, 1990 Pierre G Martineau and Stephen P Spackman
X    All Rights Reserved.
END_OF_FILE
if test 18111 -ne `wc -c <'sys/msdos/ovlmgr.doc'`; then
    echo shar: \"'sys/msdos/ovlmgr.doc'\" unpacked with wrong size!
fi
# end of 'sys/msdos/ovlmgr.doc'
fi
if test -f 'sys/share/dgn_lex.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/share/dgn_lex.c'\"
else
echo shar: Extracting \"'sys/share/dgn_lex.c'\" \(17477 characters\)
sed "s/^X//" >'sys/share/dgn_lex.c' <<'END_OF_FILE'
X# include "stdio.h"
X# define U(x) x
X# define NLSTATE yyprevious=YYNEWLINE
X# define BEGIN yybgin = yysvec + 1 +
X# define INITIAL 0
X# define YYLERR yysvec
X# define YYSTATE (yyestate-yysvec-1)
X# define YYOPTIM 1
X# define YYLMAX BUFSIZ
X# define output(c) putc(c,yyout)
X# define input() (((yytchar=yysptr>yysbuf?U(*--yysptr):getc(yyin))==10?(yylineno++,yytchar):yytchar)==EOF?0:yytchar)
X# define unput(c) {yytchar= (c);if(yytchar=='\n')yylineno--;*yysptr++=yytchar;}
X# define yymore() (yymorfg=1)
X# define ECHO fprintf(yyout, "%s",yytext)
X# define REJECT { nstr = yyreject(); goto yyfussy;}
Xint yyleng; extern char yytext[];
Xint yymorfg;
Xextern char *yysptr, yysbuf[];
Xint yytchar;
XFILE *yyin = {stdin}, *yyout = {stdout};
Xextern int yylineno;
Xstruct yysvf { 
X	struct yywork *yystoff;
X	struct yysvf *yyother;
X	int *yystops;};
Xstruct yysvf *yyestate;
Xextern struct yysvf yysvec[], *yybgin;
X/*	SCCS Id: @(#)dgn_lex.c	3.1	92/10/23	*/
X/*	Copyright (c) 1989 by Jean-Christophe Collet */
X/*	Copyright (c) 1990 by M. Stephenson	     */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#define DGN_COMP
X
X#include "config.h"
X#include "dgn_comp.h"
X#include "dgn_file.h"
X
Xlong *FDECL(alloc, (unsigned int));
X/*
X * Most of these don't exist in flex, yywrap is macro and
X * yyunput is properly declared in flex.skel.
X */
X#ifndef FLEX_SCANNER
Xint FDECL (yyback, (int *, int));
Xint NDECL (yylook);
Xint NDECL (yyinput);
Xint NDECL (yywrap);
Xint NDECL (yylex);
X	/* Traditional lexes let yyunput() and yyoutput() default to int;
X	 * newer ones may declare them as void since they don't return
X	 * values.  For even more fun, the lex supplied as part of the
X	 * newer unbundled compiler for SunOS 4.x adds the void declarations
X	 * (under __STDC__ or _cplusplus ifdefs -- otherwise they remain
X	 * int) while the bundled lex and the one with the older unbundled
X	 * compiler do not.  To detect this, we need help from outside --
X	 * sys/unix/Makefile.utl.
X	 */
X# if defined(NeXT) || defined(SVR4)
X#  define VOIDYYPUT
X# endif
X# if !defined(VOIDYYPUT)
X#  if defined(POSIX_TYPES) && !defined(BOS) && !defined(HISX)
X#   define VOIDYYPUT
X#  endif
X# endif
X# if !defined(VOIDYYPUT) && defined(WEIRD_LEX)
X#  if defined(SUNOS4) && defined(__STDC__) && (WEIRD_LEX != 0) 
X#   define VOIDYYPUT
X#  endif
X# endif
X# ifdef VOIDYYPUT
Xvoid FDECL (yyunput, (int));
Xvoid FDECL (yyoutput, (int));
X# else
Xint FDECL (yyunput, (int));
Xint FDECL (yyoutput, (int));
X# endif
X#endif	/* FLEX_SCANNER */
X
Xvoid FDECL (init_yyin, (FILE *));
Xvoid FDECL (init_yyout, (FILE *));
X
X#ifdef MICRO
X#undef exit
Xextern void FDECL(exit, (int));
X#endif
X
X/* this doesn't always get put in dgn_comp.h
X * (esp. when using older versions of bison)
X */
X
Xextern YYSTYPE yylval;
X
Xint line_number = 1;
X/*
X *	This is a hack required by Michael Hamel to get things
X *	working on the Mac.
X */
X#if defined(applec) && !defined(FLEX_SCANNER)
X#undef input
X#undef unput
X#define unput(c) { yytchar = (c); if (yytchar == 10) yylineno--; *yysptr++ = yytchar; }				  
X# ifndef YYNEWLINE
X# define YYNEWLINE 10
X# endif
X
Xchar
Xinput() {	/* Under MPW \n is chr(13)! Compensate for this. */
X
X	if (yysptr > yysbuf) return(*--yysptr);
X	else {
X		yytchar = getc(yyin);
X	 	if (yytchar == '\n') {
X		    yylineno++;
X		    return(YYNEWLINE);
X		}
X		if (yytchar == EOF) return(0);
X		else		    return(yytchar);
X	}
X}
X#endif	/* applec && !FLEX_SCANNER */
X
X# define YYNEWLINE 10
Xyylex(){
Xint nstr; extern int yyprevious;
Xwhile((nstr = yylook()) >= 0)
Xyyfussy: switch(nstr){
Xcase 0:
Xif(yywrap()) return(0); break;
Xcase 1:
X	return(A_DUNGEON);
Xbreak;
Xcase 2:
X	{ yylval.i=1; return(UP_OR_DOWN); }
Xbreak;
Xcase 3:
X	{ yylval.i=0; return(UP_OR_DOWN); }
Xbreak;
Xcase 4:
X	return(ENTRY);
Xbreak;
Xcase 5:
X	return(STAIR);
Xbreak;
Xcase 6:
X	return(NO_UP);
Xbreak;
Xcase 7:
X	return(NO_DOWN);
Xbreak;
Xcase 8:
X	return(PORTAL);
Xbreak;
Xcase 9:
Xreturn(PROTOFILE);
Xbreak;
Xcase 10:
Xreturn(DESCRIPTION);
Xbreak;
Xcase 11:
Xreturn(LEVELDESC);
Xbreak;
Xcase 12:
X      return(ALIGNMENT);
Xbreak;
Xcase 13:
X       return(LEVALIGN);
Xbreak;
Xcase 14:
X	{ yylval.i=TOWN ; return(DESCRIPTOR); }
Xbreak;
Xcase 15:
X	{ yylval.i=HELLISH ; return(DESCRIPTOR); }
Xbreak;
Xcase 16:
X{ yylval.i=MAZELIKE ; return(DESCRIPTOR); }
Xbreak;
Xcase 17:
X{ yylval.i=ROGUELIKE ; return(DESCRIPTOR); }
Xbreak;
Xcase 18:
X      { yylval.i=D_ALIGN_NONE ; return(DESCRIPTOR); }
Xbreak;
Xcase 19:
X        { yylval.i=D_ALIGN_NONE ; return(DESCRIPTOR); }
Xbreak;
Xcase 20:
X         { yylval.i=D_ALIGN_LAWFUL ; return(DESCRIPTOR); }
Xbreak;
Xcase 21:
X        { yylval.i=D_ALIGN_NEUTRAL ; return(DESCRIPTOR); }
Xbreak;
Xcase 22:
X        { yylval.i=D_ALIGN_CHAOTIC ; return(DESCRIPTOR); }
Xbreak;
Xcase 23:
X	return(BRANCH);
Xbreak;
Xcase 24:
Xreturn(CHBRANCH);
Xbreak;
Xcase 25:
X	return(LEVEL);
Xbreak;
Xcase 26:
Xreturn(RNDLEVEL);
Xbreak;
Xcase 27:
Xreturn(CHLEVEL);
Xbreak;
Xcase 28:
Xreturn(RNDCHLEVEL);
Xbreak;
Xcase 29:
X	{ yylval.i=atoi(yytext); return(INTEGER); }
Xbreak;
Xcase 30:
X{ yytext[yyleng-1] = 0; /* Discard the trailing \" */
X		  yylval.str = (char *) alloc(strlen(yytext+1)+1);
X		  strcpy(yylval.str, yytext+1); /* Discard the first \" */
X		  return(STRING); }
Xbreak;
Xcase 31:
X	{ line_number++; }
Xbreak;
Xcase 32:
X	{ line_number++; }
Xbreak;
Xcase 33:
X	;
Xbreak;
Xcase 34:
X	{ return yytext[0]; }
Xbreak;
Xcase -1:
Xbreak;
Xdefault:
Xfprintf(yyout,"bad switch yylook %d",nstr);
X} return(0); }
X/* end of yylex */
X
X/* routine to switch to another input file; needed for flex */
Xvoid init_yyin( input_f )
XFILE *input_f;
X{
X#ifdef FLEX_SCANNER
X	if (yyin)
X	    yyrestart(input_f);
X	else
X#endif
X	    yyin = input_f;
X}
X/* analogous routine (for completeness) */
Xvoid init_yyout( output_f )
XFILE *output_f;
X{
X	yyout = output_f;
X}
X
Xint yyvstop[] = {
X0,
X
X34,
X0,
X
X33,
X34,
X0,
X
X32,
X0,
X
X34,
X0,
X
X29,
X34,
X0,
X
X34,
X0,
X
X34,
X0,
X
X34,
X0,
X
X34,
X0,
X
X34,
X0,
X
X34,
X0,
X
X34,
X0,
X
X34,
X0,
X
X34,
X0,
X
X34,
X0,
X
X34,
X0,
X
X34,
X0,
X
X34,
X0,
X
X34,
X0,
X
X34,
X0,
X
X34,
X0,
X
X34,
X0,
X
X34,
X0,
X
X34,
X0,
X
X34,
X0,
X
X33,
X0,
X
X30,
X0,
X
X29,
X0,
X
X2,
X0,
X
X31,
X0,
X
X3,
X0,
X
X14,
X0,
X
X4,
X0,
X
X25,
X0,
X
X6,
X0,
X
X5,
X0,
X
X23,
X0,
X
X20,
X0,
X
X8,
X0,
X
X1,
X0,
X
X22,
X0,
X
X15,
X0,
X
X21,
X0,
X
X7,
X0,
X
X19,
X0,
X
X13,
X0,
X
X26,
X0,
X
X16,
X0,
X
X12,
X0,
X
X11,
X0,
X
X9,
X0,
X
X17,
X0,
X
X18,
X0,
X
X27,
X0,
X
X28,
X0,
X
X24,
X0,
X
X10,
X0,
X0};
X# define YYTYPE int
Xstruct yywork { YYTYPE verify, advance; } yycrank[] = {
X0,0,	0,0,	1,3,	0,0,	
X0,0,	0,0,	6,29,	0,0,	
X27,54,	0,0,	1,4,	1,5,	
X0,0,	4,28,	6,29,	6,29,	
X27,54,	27,55,	0,0,	0,0,	
X0,0,	0,0,	0,0,	0,0,	
X0,0,	0,0,	0,0,	0,0,	
X0,0,	0,0,	0,0,	0,0,	
X0,0,	0,0,	0,0,	1,6,	
X4,28,	0,0,	0,0,	6,30,	
X0,0,	27,54,	0,0,	0,0,	
X0,0,	0,0,	1,7,	0,0,	
X0,0,	0,0,	6,29,	0,0,	
X27,54,	0,0,	0,0,	0,0,	
X0,0,	2,27,	0,0,	0,0,	
X0,0,	0,0,	0,0,	0,0,	
X0,0,	0,0,	1,8,	1,9,	
X1,10,	1,11,	1,12,	13,38,	
X33,57,	10,34,	32,56,	34,58,	
X11,35,	1,13,	8,32,	12,37,	
X15,40,	1,14,	36,60,	1,15,	
X9,33,	14,39,	35,59,	2,8,	
X2,9,	2,10,	2,11,	2,12,	
X11,36,	37,61,	38,62,	39,63,	
X40,64,	0,0,	2,13,	19,44,	
X1,16,	1,17,	2,14,	18,43,	
X2,15,	1,18,	16,41,	20,45,	
X41,65,	1,19,	1,20,	1,21,	
X17,42,	1,22,	21,46,	1,23,	
X1,24,	1,25,	1,26,	22,48,	
X23,49,	2,16,	2,17,	24,50,	
X21,47,	25,51,	2,18,	26,52,	
X42,66,	26,53,	2,19,	2,20,	
X2,21,	43,67,	2,22,	44,68,	
X2,23,	2,24,	2,25,	2,26,	
X7,31,	45,69,	46,70,	7,31,	
X7,31,	7,31,	7,31,	7,31,	
X7,31,	7,31,	7,31,	7,31,	
X7,31,	47,71,	48,73,	47,72,	
X49,74,	50,75,	51,76,	52,77,	
X56,78,	57,79,	58,80,	59,81,	
X60,82,	61,83,	62,84,	63,86,	
X64,87,	65,89,	62,85,	66,90,	
X67,91,	68,92,	69,93,	70,94,	
X71,95,	64,88,	72,97,	73,98,	
X74,99,	75,100,	76,101,	77,102,	
X78,103,	79,104,	80,105,	81,106,	
X82,107,	83,108,	84,109,	85,110,	
X86,111,	71,96,	87,112,	88,113,	
X89,114,	91,115,	92,116,	93,117,	
X94,118,	95,119,	96,120,	97,121,	
X98,122,	99,123,	100,124,	102,125,	
X103,126,	104,127,	105,128,	106,130,	
X107,131,	109,132,	110,133,	111,134,	
X112,135,	113,136,	114,137,	115,138,	
X105,129,	116,139,	117,140,	118,141,	
X119,142,	121,143,	122,144,	123,145,	
X125,146,	126,147,	128,148,	129,149,	
X130,150,	131,151,	132,152,	133,153,	
X134,154,	135,155,	136,156,	137,157,	
X138,158,	140,159,	141,160,	142,161,	
X143,162,	145,163,	146,164,	147,165,	
X148,166,	149,167,	150,168,	152,169,	
X153,170,	154,171,	155,172,	156,173,	
X159,174,	163,175,	164,176,	165,177,	
X166,178,	167,179,	168,180,	170,181,	
X171,182,	172,183,	175,184,	176,185,	
X178,186,	179,187,	180,188,	183,189,	
X186,190,	188,191,	0,0,	0,0,	
X0,0};
Xstruct yysvf yysvec[] = {
X0,	0,	0,
Xyycrank+-1,	0,		0,	
Xyycrank+-22,	yysvec+1,	0,	
Xyycrank+0,	0,		yyvstop+1,
Xyycrank+4,	0,		yyvstop+3,
Xyycrank+0,	0,		yyvstop+6,
Xyycrank+-5,	0,		yyvstop+8,
Xyycrank+95,	0,		yyvstop+10,
Xyycrank+2,	0,		yyvstop+13,
Xyycrank+2,	0,		yyvstop+15,
Xyycrank+1,	0,		yyvstop+17,
Xyycrank+7,	0,		yyvstop+19,
Xyycrank+1,	0,		yyvstop+21,
Xyycrank+2,	0,		yyvstop+23,
Xyycrank+3,	0,		yyvstop+25,
Xyycrank+2,	0,		yyvstop+27,
Xyycrank+2,	0,		yyvstop+29,
Xyycrank+1,	0,		yyvstop+31,
Xyycrank+2,	0,		yyvstop+33,
Xyycrank+2,	0,		yyvstop+35,
Xyycrank+10,	0,		yyvstop+37,
Xyycrank+13,	0,		yyvstop+39,
Xyycrank+8,	0,		yyvstop+41,
Xyycrank+9,	0,		yyvstop+43,
Xyycrank+7,	0,		yyvstop+45,
Xyycrank+14,	0,		yyvstop+47,
Xyycrank+17,	0,		yyvstop+49,
Xyycrank+-7,	0,		yyvstop+51,
Xyycrank+0,	yysvec+4,	yyvstop+53,
Xyycrank+0,	yysvec+6,	0,	
Xyycrank+0,	0,		yyvstop+55,
Xyycrank+0,	yysvec+7,	yyvstop+57,
Xyycrank+1,	0,		0,	
Xyycrank+7,	0,		0,	
Xyycrank+10,	0,		0,	
Xyycrank+3,	0,		0,	
Xyycrank+4,	0,		0,	
Xyycrank+9,	0,		0,	
Xyycrank+8,	0,		0,	
Xyycrank+16,	0,		0,	
Xyycrank+28,	0,		0,	
Xyycrank+11,	0,		0,	
Xyycrank+9,	0,		0,	
Xyycrank+25,	0,		0,	
Xyycrank+16,	0,		0,	
Xyycrank+19,	0,		0,	
Xyycrank+25,	0,		0,	
Xyycrank+58,	0,		0,	
Xyycrank+40,	0,		0,	
Xyycrank+53,	0,		0,	
Xyycrank+60,	0,		0,	
Xyycrank+39,	0,		0,	
Xyycrank+62,	0,		0,	
Xyycrank+0,	0,		yyvstop+59,
Xyycrank+0,	yysvec+27,	0,	
Xyycrank+0,	0,		yyvstop+61,
Xyycrank+89,	0,		0,	
Xyycrank+83,	0,		0,	
Xyycrank+89,	0,		0,	
Xyycrank+96,	0,		0,	
Xyycrank+93,	0,		0,	
Xyycrank+83,	0,		0,	
Xyycrank+101,	0,		0,	
Xyycrank+83,	0,		0,	
Xyycrank+101,	0,		0,	
Xyycrank+58,	0,		0,	
Xyycrank+61,	0,		0,	
Xyycrank+64,	0,		0,	
Xyycrank+71,	0,		0,	
Xyycrank+73,	0,		0,	
Xyycrank+59,	0,		0,	
Xyycrank+76,	0,		0,	
Xyycrank+70,	0,		0,	
Xyycrank+63,	0,		0,	
Xyycrank+63,	0,		0,	
Xyycrank+76,	0,		0,	
Xyycrank+72,	0,		0,	
Xyycrank+75,	0,		0,	
Xyycrank+106,	0,		0,	
Xyycrank+118,	0,		0,	
Xyycrank+108,	0,		0,	
Xyycrank+105,	0,		0,	
Xyycrank+119,	0,		0,	
Xyycrank+100,	0,		0,	
Xyycrank+114,	0,		0,	
Xyycrank+115,	0,		0,	
Xyycrank+113,	0,		0,	
Xyycrank+122,	0,		0,	
Xyycrank+126,	0,		0,	
Xyycrank+80,	0,		0,	
Xyycrank+0,	0,		yyvstop+63,
Xyycrank+92,	0,		0,	
Xyycrank+81,	0,		0,	
Xyycrank+91,	0,		0,	
Xyycrank+86,	0,		0,	
Xyycrank+90,	0,		0,	
Xyycrank+90,	0,		0,	
Xyycrank+98,	0,		0,	
Xyycrank+107,	0,		0,	
Xyycrank+104,	0,		0,	
Xyycrank+92,	0,		0,	
Xyycrank+0,	0,		yyvstop+65,
Xyycrank+102,	0,		0,	
Xyycrank+131,	0,		0,	
Xyycrank+137,	0,		0,	
Xyycrank+144,	0,		0,	
Xyycrank+138,	0,		0,	
Xyycrank+133,	0,		0,	
Xyycrank+0,	0,		yyvstop+67,
Xyycrank+140,	0,		0,	
Xyycrank+146,	0,		yyvstop+69,
Xyycrank+145,	0,		0,	
Xyycrank+140,	0,		0,	
Xyycrank+131,	0,		0,	
Xyycrank+113,	0,		0,	
Xyycrank+104,	0,		0,	
Xyycrank+113,	0,		0,	
Xyycrank+117,	0,		0,	
Xyycrank+126,	0,		0,	
Xyycrank+105,	0,		0,	
Xyycrank+0,	0,		yyvstop+71,
Xyycrank+122,	0,		0,	
Xyycrank+118,	0,		0,	
Xyycrank+119,	0,		0,	
Xyycrank+0,	0,		yyvstop+73,
Xyycrank+125,	0,		0,	
Xyycrank+160,	0,		0,	
Xyycrank+0,	0,		yyvstop+75,
Xyycrank+148,	0,		0,	
Xyycrank+162,	0,		0,	
Xyycrank+152,	0,		0,	
Xyycrank+155,	0,		0,	
Xyycrank+163,	0,		0,	
Xyycrank+166,	0,		0,	
Xyycrank+163,	0,		0,	
Xyycrank+168,	0,		0,	
Xyycrank+169,	0,		0,	
Xyycrank+140,	0,		0,	
Xyycrank+136,	0,		0,	
Xyycrank+0,	0,		yyvstop+77,
Xyycrank+134,	0,		0,	
Xyycrank+134,	0,		0,	
Xyycrank+133,	0,		0,	
Xyycrank+134,	0,		0,	
Xyycrank+0,	0,		yyvstop+79,
Xyycrank+140,	0,		0,	
Xyycrank+136,	0,		0,	
Xyycrank+169,	0,		0,	
Xyycrank+183,	0,		0,	
Xyycrank+163,	0,		0,	
Xyycrank+166,	0,		0,	
Xyycrank+0,	0,		yyvstop+81,
Xyycrank+173,	0,		0,	
Xyycrank+169,	0,		0,	
Xyycrank+177,	0,		0,	
Xyycrank+168,	0,		0,	
Xyycrank+179,	0,		0,	
Xyycrank+0,	0,		yyvstop+83,
Xyycrank+0,	0,		yyvstop+85,
Xyycrank+155,	0,		0,	
Xyycrank+0,	0,		yyvstop+87,
Xyycrank+0,	0,		yyvstop+89,
Xyycrank+0,	0,		yyvstop+91,
Xyycrank+150,	0,		0,	
Xyycrank+157,	0,		0,	
Xyycrank+175,	0,		0,	
Xyycrank+182,	0,		0,	
Xyycrank+192,	0,		0,	
Xyycrank+189,	0,		0,	
Xyycrank+0,	0,		yyvstop+93,
Xyycrank+196,	0,		0,	
Xyycrank+195,	0,		0,	
Xyycrank+196,	0,		0,	
Xyycrank+0,	0,		yyvstop+95,
Xyycrank+0,	0,		yyvstop+97,
Xyycrank+165,	0,		0,	
Xyycrank+167,	0,		0,	
Xyycrank+0,	0,		yyvstop+99,
Xyycrank+201,	0,		0,	
Xyycrank+193,	0,		0,	
Xyycrank+191,	0,		0,	
Xyycrank+0,	0,		yyvstop+101,
Xyycrank+0,	0,		yyvstop+103,
Xyycrank+195,	0,		0,	
Xyycrank+0,	0,		yyvstop+105,
Xyycrank+0,	0,		yyvstop+107,
Xyycrank+200,	0,		0,	
Xyycrank+0,	0,		yyvstop+109,
Xyycrank+195,	0,		0,	
Xyycrank+0,	0,		yyvstop+111,
Xyycrank+0,	0,		yyvstop+113,
Xyycrank+0,	0,		yyvstop+115,
X0,	0,	0};
Xstruct yywork *yytop = yycrank+273;
Xstruct yysvf *yybgin = yysvec+1;
Xchar yymatch[] = {
X00  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
X01  ,011 ,012 ,01  ,01  ,01  ,01  ,01  ,
X01  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
X01  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
X011 ,01  ,'"' ,01  ,01  ,01  ,01  ,01  ,
X01  ,01  ,01  ,01  ,01  ,'-' ,01  ,01  ,
X'-' ,'-' ,'-' ,'-' ,'-' ,'-' ,'-' ,'-' ,
X'-' ,'-' ,01  ,01  ,01  ,01  ,01  ,01  ,
X01  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
X01  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
X01  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
X01  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
X01  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
X01  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
X01  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
X01  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
X0};
Xchar yyextra[] = {
X0,0,0,0,0,0,0,0,
X0,0,0,0,0,0,0,0,
X0,0,0,0,0,0,0,0,
X0,0,0,0,0,0,0,0,
X0,0,0,0,0,0,0,0,
X0};
X#ifndef lint
Xstatic	char ncform_sccsid[] = "@(#)ncform 1.6 88/02/08 SMI"; /* from S5R2 1.2 */
X#endif
X
Xint yylineno =1;
X# define YYU(x) x
X# define NLSTATE yyprevious=YYNEWLINE
Xchar yytext[YYLMAX];
Xstruct yysvf *yylstate [YYLMAX], **yylsp, **yyolsp;
Xchar yysbuf[YYLMAX];
Xchar *yysptr = yysbuf;
Xint *yyfnd;
Xextern struct yysvf *yyestate;
Xint yyprevious = YYNEWLINE;
Xyylook(){
X	register struct yysvf *yystate, **lsp;
X	register struct yywork *yyt;
X	struct yysvf *yyz;
X	int yych, yyfirst;
X	struct yywork *yyr;
X# ifdef LEXDEBUG
X	int debug;
X# endif
X	char *yylastch;
X	/* start off machines */
X# ifdef LEXDEBUG
X	debug = 0;
X# endif
X	yyfirst=1;
X	if (!yymorfg)
X		yylastch = yytext;
X	else {
X		yymorfg=0;
X		yylastch = yytext+yyleng;
X		}
X	for(;;){
X		lsp = yylstate;
X		yyestate = yystate = yybgin;
X		if (yyprevious==YYNEWLINE) yystate++;
X		for (;;){
X# ifdef LEXDEBUG
X			if(debug)fprintf(yyout,"state %d\n",yystate-yysvec-1);
X# endif
X			yyt = yystate->yystoff;
X			if(yyt == yycrank && !yyfirst){  /* may not be any transitions */
X				yyz = yystate->yyother;
X				if(yyz == 0)break;
X				if(yyz->yystoff == yycrank)break;
X				}
X			*yylastch++ = yych = input();
X			yyfirst=0;
X		tryagain:
X# ifdef LEXDEBUG
X			if(debug){
X				fprintf(yyout,"char ");
X				allprint(yych);
X				putchar('\n');
X				}
X# endif
X			yyr = yyt;
X			if ( (int)yyt > (int)yycrank){
X				yyt = yyr + yych;
X				if (yyt <= yytop && yyt->verify+yysvec == yystate){
X					if(yyt->advance+yysvec == YYLERR)	/* error transitions */
X						{unput(*--yylastch);break;}
X					*lsp++ = yystate = yyt->advance+yysvec;
X					goto contin;
X					}
X				}
X# ifdef YYOPTIM
X			else if((int)yyt < (int)yycrank) {		/* r < yycrank */
X				yyt = yyr = yycrank+(yycrank-yyt);
X# ifdef LEXDEBUG
X				if(debug)fprintf(yyout,"compressed state\n");
X# endif
X				yyt = yyt + yych;
X				if(yyt <= yytop && yyt->verify+yysvec == yystate){
X					if(yyt->advance+yysvec == YYLERR)	/* error transitions */
X						{unput(*--yylastch);break;}
X					*lsp++ = yystate = yyt->advance+yysvec;
X					goto contin;
X					}
X				yyt = yyr + YYU(yymatch[yych]);
X# ifdef LEXDEBUG
X				if(debug){
X					fprintf(yyout,"try fall back character ");
X					allprint(YYU(yymatch[yych]));
X					putchar('\n');
X					}
X# endif
X				if(yyt <= yytop && yyt->verify+yysvec == yystate){
X					if(yyt->advance+yysvec == YYLERR)	/* error transition */
X						{unput(*--yylastch);break;}
X					*lsp++ = yystate = yyt->advance+yysvec;
X					goto contin;
X					}
X				}
X			if ((yystate = yystate->yyother) && (yyt= yystate->yystoff) != yycrank){
X# ifdef LEXDEBUG
X				if(debug)fprintf(yyout,"fall back to state %d\n",yystate-yysvec-1);
X# endif
X				goto tryagain;
X				}
X# endif
X			else
X				{unput(*--yylastch);break;}
X		contin:
X# ifdef LEXDEBUG
X			if(debug){
X				fprintf(yyout,"state %d char ",yystate-yysvec-1);
X				allprint(yych);
X				putchar('\n');
X				}
X# endif
X			;
X			}
X# ifdef LEXDEBUG
X		if(debug){
X			fprintf(yyout,"stopped at %d with ",*(lsp-1)-yysvec-1);
X			allprint(yych);
X			putchar('\n');
X			}
X# endif
X		while (lsp-- > yylstate){
X			*yylastch-- = 0;
X			if (*lsp != 0 && (yyfnd= (*lsp)->yystops) && *yyfnd > 0){
X				yyolsp = lsp;
X				if(yyextra[*yyfnd]){		/* must backup */
X					while(yyback((*lsp)->yystops,-*yyfnd) != 1 && lsp > yylstate){
X						lsp--;
X						unput(*yylastch--);
X						}
X					}
X				yyprevious = YYU(*yylastch);
X				yylsp = lsp;
X				yyleng = yylastch-yytext+1;
X				yytext[yyleng] = 0;
X# ifdef LEXDEBUG
X				if(debug){
X					fprintf(yyout,"\nmatch ");
X					sprint(yytext);
X					fprintf(yyout," action %d\n",*yyfnd);
X					}
X# endif
X				return(*yyfnd++);
X				}
X			unput(*yylastch);
X			}
X		if (yytext[0] == 0  /* && feof(yyin) */)
X			{
X			yysptr=yysbuf;
X			return(0);
X			}
X		yyprevious = yytext[0] = input();
X		if (yyprevious>0)
X			output(yyprevious);
X		yylastch=yytext;
X# ifdef LEXDEBUG
X		if(debug)putchar('\n');
X# endif
X		}
X	}
Xyyback(p, m)
X	int *p;
X{
Xif (p==0) return(0);
Xwhile (*p)
X	{
X	if (*p++ == m)
X		return(1);
X	}
Xreturn(0);
X}
X	/* the following are only used in the lex library */
Xyyinput(){
X	return(input());
X	}
Xyyoutput(c)
X  int c; {
X	output(c);
X	}
Xyyunput(c)
X   int c; {
X	unput(c);
X	}
END_OF_FILE
if test 17477 -ne `wc -c <'sys/share/dgn_lex.c'`; then
    echo shar: \"'sys/share/dgn_lex.c'\" unpacked with wrong size!
fi
# end of 'sys/share/dgn_lex.c'
fi
echo shar: End of archive 84 \(of 108\).
cp /dev/null ark84isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \
21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \
41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 \
61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 \
81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 \
101 102 103 104 105 106 107 108 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 108 archives.
    echo "Now execute 'rebuild.sh'"
    rm -f ark10[0-8]isdone ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
