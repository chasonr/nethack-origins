Path: uunet!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v16i010:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Part10/108
Message-ID: <4293@master.CNA.TEK.COM>
Date: 28 Jan 93 19:12:05 GMT
Sender: news@master.CNA.TEK.COM
Lines: 2496
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1566

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 16, Issue 10
Archive-name: nethack31/Part10
Supersedes: nethack3p9: Volume 10, Issue 46-102
Environment: Amiga, Atari, Mac, MS-DOS, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 10 (of 108)."
# Contents:  src/objnam.c sys/amiga/char.c
# Wrapped by billr@saab on Wed Jan 27 16:08:48 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'src/objnam.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/objnam.c'\"
else
echo shar: Extracting \"'src/objnam.c'\" \(47782 characters\)
sed "s/^X//" >'src/objnam.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)objnam.c	3.1	92/12/13	*/
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include	"hack.h"
X
X/* "an uncursed partly eaten guardian naga hatchling corpse" */
X#define	PREFIX	50
X#define SCHAR_LIM 127
X
XSTATIC_DCL char *FDECL(strprepend,(char *,const char *));
X
Xstruct Jitem {
X	int item;
X	const char *name;
X};
X
X#ifndef OVLB
X
XSTATIC_DCL struct Jitem Japanese_items[];
X
X#else /* OVLB */
X
XSTATIC_OVL struct Jitem Japanese_items[] = {
X	{ SHORT_SWORD, "wakizashi" },
X	{ BROADSWORD, "ninja-to" },
X	{ GLAIVE, "naginata" },
X	{ LOCK_PICK, "osaku" },
X	{0, "" }
X};
X
X#endif /* OVLB */
X
XSTATIC_DCL const char *FDECL(Japanese_item_name,(int i));
X
X#ifdef OVL1
X
XSTATIC_OVL char *
Xstrprepend(s,pref)
Xregister char *s;
Xregister const char *pref; {
Xregister int i = strlen(pref);
X	if(i > PREFIX) {
X		pline("WARNING: prefix too short.");
X		return(s);
X	}
X	s -= i;
X	(void) strncpy(s, pref, i);	/* do not copy trailing 0 */
X	return(s);
X}
X
X#endif /* OVL1 */
X#ifdef OVLB
X
Xchar *
Xtypename(otyp)
Xregister int otyp;
X{
X#ifdef LINT	/* static char buf[BUFSZ]; */
Xchar buf[BUFSZ];
X#else
Xstatic char NEARDATA buf[BUFSZ];
X#endif
Xregister struct objclass *ocl = &objects[otyp];
Xregister const char *actualn = OBJ_NAME(*ocl);
Xregister const char *dn = OBJ_DESCR(*ocl);
Xregister const char *un = ocl->oc_uname;
Xregister int nn = ocl->oc_name_known;
X
X	if (pl_character[0] == 'S' && Japanese_item_name(otyp))
X		actualn = Japanese_item_name(otyp);
X	switch(ocl->oc_class) {
X	case GOLD_CLASS:
X		Strcpy(buf, "coin");
X		break;
X	case POTION_CLASS:
X		Strcpy(buf, "potion");
X		break;
X	case SCROLL_CLASS:
X		Strcpy(buf, "scroll");
X		break;
X	case WAND_CLASS:
X		Strcpy(buf, "wand");
X		break;
X	case SPBOOK_CLASS:
X		Strcpy(buf, "spellbook");
X		break;
X	case RING_CLASS:
X		Strcpy(buf, "ring");
X		break;
X	case AMULET_CLASS:
X		if(nn)
X			Strcpy(buf,actualn);
X		else
X			Strcpy(buf,"amulet");
X		if(un)
X			Sprintf(eos(buf)," called %s",un);
X		if(dn)
X			Sprintf(eos(buf)," (%s)",dn);
X		return(buf);
X	default:
X		if(nn) {
X			Strcpy(buf, actualn);
X			if(otyp >= TURQUOISE && otyp <= JADE)
X				Strcat(buf, " stone");
X			if(un)
X				Sprintf(eos(buf), " called %s", un);
X			if(dn)
X				Sprintf(eos(buf), " (%s)", dn);
X		} else {
X			Strcpy(buf, dn ? dn : actualn);
X			if(ocl->oc_class == GEM_CLASS) {
X				if (otyp == LOADSTONE || otyp == LUCKSTONE)
X					Strcat(buf, " stone");
X				else
X					Strcat(buf, " gem");
X			}
X			if(un)
X				Sprintf(eos(buf), " called %s", un);
X		}
X		return(buf);
X	}
X	/* here for ring/scroll/potion/wand */
X	if(nn)
X		Sprintf(eos(buf), " of %s", actualn);
X	if(un)
X		Sprintf(eos(buf), " called %s", un);
X	if(dn)
X		Sprintf(eos(buf), " (%s)", dn);
X	return(buf);
X}
X
Xboolean
Xobj_is_pname(obj)
Xregister struct obj *obj;
X{
X    return (obj->dknown && obj->known && obj->onamelth && obj->oartifact &&
X	    !objects[obj->otyp].oc_unique);
X}
X
X/* Give the name of an object seen at a distance.  Unlike xname/doname,
X * we don't want to set dknown if it's not set already.  The kludge used is
X * to temporarily set Blind so that xname() skips the dknown setting.  This
X * assumes that we don't want to do this too often; if this function becomes
X * frequently used, it'd probably be better to pass a parameter to xname()
X * or doname() instead.
X */
Xchar *
Xdistant_name(obj, func)
Xregister struct obj *obj;
Xchar *FDECL((*func), (OBJ_P));
X{
X	char *str;
X
X	long save_Blinded = Blinded;
X	Blinded = 1;
X	str = (*func)(obj);
X	Blinded = save_Blinded;
X	return str;
X}
X
X#endif /* OVLB */
X#ifdef OVL1
X
Xchar *
Xxname(obj)
Xregister struct obj *obj;
X{
X#ifdef LINT	/* lint may handle static decl poorly -- static char bufr[]; */
Xchar bufr[BUFSZ];
X#else
Xstatic char bufr[BUFSZ];
X#endif
Xregister char *buf = &(bufr[PREFIX]);	/* leave room for "17 -3 " */
Xregister int typ = obj->otyp;
Xregister int nn = objects[typ].oc_name_known;
Xregister const char *actualn = OBJ_NAME(objects[typ]);
Xregister const char *dn = OBJ_DESCR(objects[typ]);
Xregister const char *un = objects[typ].oc_uname;
X
X	if (pl_character[0] == 'S' && Japanese_item_name(typ))
X		actualn = Japanese_item_name(typ);
X
X	buf[0] = '\0';
X	if (!Blind) obj->dknown=1;
X	if (obj_is_pname(obj))
X	    goto nameit;
X	switch (obj->oclass) {
X	    case AMULET_CLASS:
X		if (!obj->dknown)
X			Strcpy(buf, "amulet");
X		else if (typ == FAKE_AMULET_OF_YENDOR)
X			/* each must be identified individually */
X			Strcpy(buf, obj->known ? actualn : dn);
X		else if (nn) /* should be true for the Amulet of Yendor */
X			Strcpy(buf, actualn);
X		else if (un)
X			Sprintf(buf,"amulet called %s", un);
X		else
X			Sprintf(buf,"%s amulet", dn);
X		break;
X	    case WEAPON_CLASS:
X		if (typ <= SHURIKEN && obj->opoisoned)
X			Strcpy(buf, "poisoned ");
X	    case VENOM_CLASS:
X	    case TOOL_CLASS:
X		if(un) {
X			/* un must come first here.  If it does not, they could
X			 * tell objects apart by seeing which ones refuse to
X			 * accept names.
X			 */
X			Sprintf(buf, "%s called %s",
X				nn ? actualn : dn, un);
X		} else if(nn)
X			Strcat(buf, actualn);
X		else
X			Strcat(buf, dn);
X		/* If we use an() here we'd have to remember never to use */
X		/* it whenever calling doname() or xname(). */
X		if (typ == FIGURINE)
X		    Sprintf(eos(buf), " of a%s %s",
X			index(vowels,*(mons[obj->corpsenm].mname)) ? "n" : "",
X			mons[obj->corpsenm].mname);
X		break;
X	    case ARMOR_CLASS:
X		/* depends on order of the dragon scales objects */
X		if (typ >= GRAY_DRAGON_SCALES && typ <= YELLOW_DRAGON_SCALES) {
X			Sprintf(buf, "set of %s", OBJ_NAME(objects[typ]));
X			break;
X		}
X		if(is_boots(obj) || is_gloves(obj)) Strcpy(buf,"pair of ");
X
X		if(nn)	Strcat(buf, actualn);
X		else if(un) {
X			if(is_boots(obj))
X				Strcat(buf,"boots");
X			else if(is_gloves(obj))
X				Strcat(buf,"gloves");
X			else if(is_cloak(obj))
X				Strcpy(buf,"cloak");
X			else if(is_helmet(obj))
X				Strcpy(buf,"helmet");
X			else if(is_shield(obj))
X				Strcpy(buf,"shield");
X			else
X				Strcpy(buf,"armor");
X			Strcat(buf, " called ");
X			Strcat(buf, un);
X		} else	Strcat(buf, dn);
X		break;
X	    case FOOD_CLASS:
X#ifdef TUTTI_FRUTTI
X		if (typ == SLIME_MOLD) {
X			register struct fruit *f;
X
X			for(f=ffruit; f; f = f->nextf) {
X				if(f->fid == obj->spe) {
X					Strcpy(buf, f->fname);
X					break;
X				}
X			}
X			if (!f) impossible("Bad fruit #%d?", obj->spe);
X			break;
X		}
X#endif
X		Strcpy(buf, actualn);
X		if (typ == TIN && obj->known) {
X		    if(obj->spe > 0)
X			Strcat(buf, " of spinach");
X		    else if (obj->corpsenm < 0)
X		        Strcpy(buf, "empty tin");
X		    else if (is_meaty(&mons[obj->corpsenm]))
X			Sprintf(eos(buf), " of %s meat", mons[obj->corpsenm].mname);
X		    else
X			Sprintf(eos(buf), " of %s", mons[obj->corpsenm].mname);
X		}
X		break;
X	    case GOLD_CLASS:
X	    case CHAIN_CLASS:
X		Strcpy(buf, actualn);
X		break;
X	    case ROCK_CLASS:
X		if (typ == STATUE)
X		    Sprintf(buf, "%s of %s%s", actualn,
X			type_is_pname(&mons[obj->corpsenm]) ? "" :
X			    (index(vowels,*(mons[obj->corpsenm].mname)) ?
X								"an " : "a "),
X			mons[obj->corpsenm].mname);
X		else Strcpy(buf, actualn);
X		break;
X	    case BALL_CLASS:
X		Sprintf(buf, "%sheavy iron ball",
X			(obj->owt > objects[typ].oc_weight) ? "very " : "");
X		break;
X	    case POTION_CLASS:
X		if(nn || un || !obj->dknown) {
X			Strcpy(buf, "potion");
X			if(!obj->dknown) break;
X			if(nn) {
X			    Strcat(buf, " of ");
X			    if (typ == POT_WATER &&
X				objects[POT_WATER].oc_name_known &&
X				(obj->bknown || pl_character[0] == 'P') &&
X				(obj->blessed || obj->cursed)) {
X				Strcat(buf, obj->blessed ? "holy " : "unholy ");
X			    }
X			    Strcat(buf, actualn);
X			} else {
X				Strcat(buf, " called ");
X				Strcat(buf, un);
X			}
X		} else {
X			Strcpy(buf, dn);
X			Strcat(buf, " potion");
X		}
X		break;
X	case SCROLL_CLASS:
X		Strcpy(buf, "scroll");
X		if(!obj->dknown) break;
X		if(nn) {
X			Strcat(buf, " of ");
X			Strcat(buf, actualn);
X		} else if(un) {
X			Strcat(buf, " called ");
X			Strcat(buf, un);
X		} else if (objects[typ].oc_magic) {
X			Strcat(buf, " labeled ");
X			Strcat(buf, dn);
X		} else {
X			Strcpy(buf, dn);
X			Strcat(buf, " scroll");
X		}
X		break;
X	case WAND_CLASS:
X		if(!obj->dknown)
X			Strcpy(buf, "wand");
X		else if(nn)
X			Sprintf(buf, "wand of %s", actualn);
X		else if(un)
X			Sprintf(buf, "wand called %s", un);
X		else
X			Sprintf(buf, "%s wand", dn);
X		break;
X	case SPBOOK_CLASS:
X		if (!obj->dknown) {
X			Strcpy(buf, "spellbook");
X		} else if (nn) {
X			if (typ != SPE_BOOK_OF_THE_DEAD)
X			    Strcpy(buf, "spellbook of ");
X			Strcat(buf, actualn);
X		} else if (un) {
X			Sprintf(buf, "spellbook called %s", un);
X		} else
X			Sprintf(buf, "%s spellbook", dn);
X		break;
X	case RING_CLASS:
X		if(!obj->dknown)
X			Strcpy(buf, "ring");
X		else if(nn)
X			Sprintf(buf, "ring of %s", actualn);
X		else if(un)
X			Sprintf(buf, "ring called %s", un);
X		else
X			Sprintf(buf, "%s ring", dn);
X		break;
X	case GEM_CLASS:
X		if(!obj->dknown) {
X			if (typ == ROCK || typ == LOADSTONE || typ == LUCKSTONE)
X				Strcpy(buf, "stone");
X			else
X				Strcpy(buf, "gem");
X			break;
X		}
X		if(!nn) {
X			const char *rock =
X			  (typ==LOADSTONE || typ==LUCKSTONE) ? "stone" : "gem";
X			if(un)	Sprintf(buf,"%s called %s", rock, un);
X			else	Sprintf(buf, "%s %s", dn, rock);
X			break;
X		}
X		Strcpy(buf, actualn);
X		if(typ >= TURQUOISE && typ <= JADE)
X			Strcat(buf, " stone");
X		break;
X	default:
X		Sprintf(buf,"glorkum %d %d %d", obj->oclass, typ, obj->spe);
X	}
X	if(obj->quan != 1L) Strcpy(buf, makeplural(buf));
X
X	if(obj->onamelth &&
X	   (!obj->oartifact || !objects[obj->otyp].oc_unique)) {
X		Strcat(buf, " named ");
X	    nameit:
X		Strcat(buf, ONAME(obj));
X	}
X	return(buf);
X}
X
X#endif /* OVL1 */
X#ifdef OVL0
X
Xchar *
Xdoname(obj)
Xregister struct obj *obj;
X{
X	boolean ispoisoned = FALSE;
X	char prefix[PREFIX];
X	char tmpbuf[PREFIX+1];
X	/* when we have to add something at the start of prefix instead of the
X	 * end (Strcat is used on the end)
X	 */
X	register char *bp = xname(obj);
X	/* When using xname, we want "poisoned arrow", and when using
X	 * doname, we want "poisoned +0 arrow".  This kludge is about the only
X	 * way to do it, at least until someone overhauls xname() and doname(),
X	 * combining both into one function taking a parameter.
X	 */
X	if (!strncmp(bp, "poisoned ", 9)) {
X		bp += 9;
X		ispoisoned = TRUE;
X	}
X
X	if(obj->quan != 1L)
X		Sprintf(prefix, "%ld ", obj->quan);
X	else if(obj_is_pname(obj)) {
X		if (!strncmpi(bp, "the ", 4))
X		    bp += 4;
X		Strcpy(prefix, "the ");
X	} else
X		Strcpy(prefix, "a ");
X	if((obj->bknown || pl_character[0] == 'P') &&
X	    (obj->otyp != POT_WATER || !objects[POT_WATER].oc_name_known
X		|| (!obj->cursed && !obj->blessed))) {
X	    /* allow 'blessed clear potion' if we don't know it's holy water;
X	     * always allow "uncursed potion of water"
X	     */
X	    if(obj->cursed)
X		Strcat(prefix, "cursed ");
X	    else if(obj->blessed)
X		Strcat(prefix, "blessed ");
X	    else if (((obj->oclass != ARMOR_CLASS
X			&& obj->oclass != WAND_CLASS
X			&& obj->oclass != WEAPON_CLASS
X			&& ((obj->oclass != TOOL_CLASS &&
X			     obj->oclass != RING_CLASS) ||
X			     !objects[obj->otyp].oc_charged))
X			    || !obj->known)
X		/* For items with charges or +/-, knowing the +/- means that
X		 * the item has been totally identified, and therefore there
X		 * is no doubt as to the object being uncursed if it's
X		 * not described as "blessed" or "cursed".
X		 *
X		 * If the +/- isn't known, "uncursed" must be printed to
X		 * avoid ambiguity between an item whose curse status is
X		 * unknown, and an item known to be uncursed.
X		 */
X#ifdef MAIL
X			&& obj->otyp != SCR_MAIL
X#endif
X			&& obj->otyp != FAKE_AMULET_OF_YENDOR
X			&& obj->otyp != AMULET_OF_YENDOR
X			&& pl_character[0] != 'P')
X		Strcat(prefix, "uncursed ");
X	}
X	if(obj->greased) Strcat(prefix, "greased ");
X	switch(obj->oclass) {
X	case AMULET_CLASS:
X		if(obj->otyp == FAKE_AMULET_OF_YENDOR ||
X		   obj->otyp == AMULET_OF_YENDOR)
X		    if(strncmp(bp, "cheap ", 6)) {
X			Strcpy(tmpbuf, "the ");
X			Strcat(tmpbuf, prefix+2); /* skip the "a " */
X			Strcpy(prefix, tmpbuf);
X		    }
X		if(obj->owornmask & W_AMUL)
X			Strcat(bp, " (being worn)");
X		break;
X	case WEAPON_CLASS:
X		if(ispoisoned)
X			Strcat(prefix, "poisoned ");
Xplus:
X		if (obj->oeroded) {
X			switch (obj->oeroded) {
X				case 2:	Strcat(prefix, "very "); break;
X				case 3:	Strcat(prefix, "thoroughly "); break;
X			}			
X			Strcat(prefix,
X			       is_rustprone(obj) ? "rusty " :
X			       is_corrodeable(obj) ? "corroded " :
X			       is_flammable(obj) ? "burnt " : "");
X		} else if (obj->rknown && obj->oerodeproof)
X			Strcat(prefix,
X			       is_rustprone(obj) ? "rustproof " :
X			       is_corrodeable(obj) ? "corrodeproof " :	/* "stainless"? */
X			       is_flammable(obj) ? "fireproof " : "");
X		if(obj->known) {
X			Strcat(prefix, sitoa(obj->spe));
X			Strcat(prefix, " ");
X		}
X		break;
X	case ARMOR_CLASS:
X		if(obj->owornmask & W_ARMOR)
X			Strcat(bp,
X#ifdef POLYSELF
X				(obj == uskin) ? " (embedded in your skin)" :
X#endif
X				" (being worn)");
X		goto plus;
X	case TOOL_CLASS:		/* temp. hack by GAN 11/18/86 */
X		if(obj->owornmask & W_TOOL) { /* blindfold */
X			Strcat(bp, " (being worn)");
X			break;
X		}
X#ifdef WALKIES
X		if(obj->otyp == LEASH && obj->leashmon != 0) {
X			Strcat(bp, " (in use)");
X			break;
X		}
X#endif
X		if(obj->otyp == PICK_AXE || obj->otyp == UNICORN_HORN)
X			goto plus;
X		if (Is_candle(obj) &&
X		    obj->age < 20L * (long)objects[obj->otyp].oc_cost)
X			Sprintf(eos(prefix), "partly used ");
X		if (obj->otyp == OIL_LAMP || obj->otyp == MAGIC_LAMP ||
X			obj->otyp == BRASS_LANTERN ||
X		    Is_candle(obj) || obj->otyp == CANDELABRUM_OF_INVOCATION) {
X			if(obj->lamplit)
X				Sprintf(eos(bp), " (lit)");
X			break;
X		}
X		if(!objects[obj->otyp].oc_charged) break;
X		/* if special tool, fall through to show charges */
X	case WAND_CLASS:
X		if(obj->known)
X			Sprintf(eos(bp), " (%d)", obj->spe);
X		break;
X	case RING_CLASS:
X		if(obj->owornmask & W_RINGR) Strcat(bp, " (on right ");
X		if(obj->owornmask & W_RINGL) Strcat(bp, " (on left ");
X		if(obj->owornmask & W_RING) {
X		    Strcat(bp, body_part(HAND));
X		    Strcat(bp, ")");
X		}
X		if(obj->known && objects[obj->otyp].oc_charged) {
X			Strcat(prefix, sitoa(obj->spe));
X			Strcat(prefix, " ");
X		}
X		break;
X	case FOOD_CLASS:
X		if (obj->oeaten)
X		    Strcat(prefix, "partly eaten ");
X		if (obj->otyp == CORPSE) {
X		    if (type_is_pname(&mons[obj->corpsenm])) {
X			Sprintf(prefix, "%s ",
X				s_suffix(mons[obj->corpsenm].mname));
X			if (obj->oeaten) Strcat(prefix, "partly eaten ");
X		    } else {
X			Strcat(prefix, mons[obj->corpsenm].mname);
X			Strcat(prefix, " ");
X		    }
X		} else if (obj->otyp == EGG && obj->known) {
X		    if (obj->corpsenm >= 0) {
X			Strcat(prefix, mons[obj->corpsenm].mname);
X			Strcat(prefix, " ");
X#ifdef POLYSELF
X			if (obj->spe)
X			    Strcat(bp, " (laid by you)");
X#endif
X		    }
X		}
X		break;
X	case BALL_CLASS:
X		if(obj->owornmask & W_BALL)
X			Strcat(bp, " (chained to you)");
X			break;
X	}
X
X	if((obj->owornmask & W_WEP) && !mrg_to_wielded) {
X		if (obj->quan != 1L)
X			Strcat(bp, " (wielded)");
X		else {
X			Strcat(bp, " (weapon in ");
X			Strcat(bp, body_part(HAND));
X			Strcat(bp, ")");
X		}
X	}
X	if(obj->unpaid)
X		Strcat(bp, " (unpaid)");
X	if (!strncmp(prefix, "a ", 2) &&
X			index(vowels, *(prefix+2) ? *(prefix+2) : *bp)
X			&& (*(prefix+2) || (strncmp(bp, "uranium", 7)
X				&& strncmp(bp, "unicorn", 7)))) {
X		Strcpy(tmpbuf, prefix);
X		Strcpy(prefix, "an ");
X		Strcpy(prefix+3, tmpbuf+2);
X	}
X	bp = strprepend(bp, prefix);
X	return(bp);
X}
X
X#endif /* OVL0 */
X#ifdef OVLB
X
X/*
X * Used if only one of a collection of objects is named (e.g. in eat.c).
X */
X
Xchar *
Xsingular(otmp, func)
Xregister struct obj *otmp;
Xchar *FDECL((*func), (OBJ_P));
X{
X	long savequan;
X	char *nam;
X
X	/* Note: using xname for corpses will not give the monster type */
X	if (otmp->otyp == CORPSE && func == xname) {
X		static char NEARDATA buf[31];
X
X		Sprintf(buf, "%s corpse", mons[otmp->corpsenm].mname);
X		return buf;
X	}
X	savequan = otmp->quan;
X	otmp->quan = 1L;
X	nam = (*func)(otmp);
X	otmp->quan = savequan;
X	return nam;
X}
X
Xchar *
Xan(str)
Xregister const char *str;
X{
X	static char NEARDATA buf[BUFSZ];
X
X	buf[0] = '\0';
X
X	if (strncmpi(str, "the ", 4) &&
X	    strcmp(str, "molten lava") &&
X	    strcmp(str, "ice"))
X	    	if (index(vowels, *str) &&
X		    strncmp(str, "useful", 6) &&
X		    strncmp(str, "unicorn", 7) &&
X		    strncmp(str, "uranium", 7))
X		    	Strcpy(buf, "an ");
X	    	else
X		    Strcpy(buf, "a ");
X
X	Strcat(buf, str);
X	return buf;
X}
X
Xchar *
XAn(str)
Xconst char *str;
X{
X	register char *tmp = an(str);
X	*tmp = highc(*tmp);
X	return tmp;
X}
X
X/*
X * Prepend "the" if necessary; assumes str is a subject derived from xname.
X * Use type_is_pname() for monster names, not the().  the() is idempotent.
X */
Xchar *
Xthe(str)
Xconst char *str;
X{
X	static char NEARDATA buf[BUFSZ];
X
X	if (!strncmpi(str, "the ", 4)) {
X	    buf[0] = lowc(*str);
X	    Strcpy(&buf[1], str+1);
X	    return buf;
X	} else if (*str < 'A' || *str > 'Z') {
X	    /* not a proper name, needs an article */
X	    Strcpy(buf, "the ");
X	} else {
X	    /* Probably a proper name, might not need an article */
X	    register char *tmp;
X
X	    buf[0] = 0;
X
X	    /* some objects have capitalized adjectives in their names */
X	    if(((tmp = rindex(str, ' ')) || (tmp = rindex(str, '-'))) &&
X	       (tmp[1] < 'A' || tmp[1] > 'Z'))
X		Strcpy(buf, "the ");
X	    else if (tmp && (tmp = index(str, ' ')) != NULL) {
X		/* it needs an article if the name contains "of" */
X		while(tmp && strncmp(++tmp, "of ", 3))
X		    tmp = index(tmp, ' ');
X		if (tmp) /* found an "of" */
X		    Strcpy(buf, "the ");
X	    }
X	}
X	Strcat(buf, str);
X
X	return buf;
X}
X
Xchar *
XThe(str)
Xconst char *str;
X{
X    register char *tmp = the(str);
X    *tmp = highc(*tmp);
X    return tmp;
X}
X
Xchar *
Xaobjnam(otmp,verb)
Xregister struct obj *otmp;
Xregister const char *verb;
X{
X	register char *bp = xname(otmp);
X	char prefix[PREFIX];
X
X	if(otmp->quan != 1L) {
X		Sprintf(prefix, "%ld ", otmp->quan);
X		bp = strprepend(bp, prefix);
X	}
X
X	if(verb) {
X		/* verb is given in plural (without trailing s) */
X		Strcat(bp, " ");
X		if(otmp->quan != 1L)
X			Strcat(bp, verb);
X		else if(!strcmp(verb, "are"))
X			Strcat(bp, "is");
X		else {
X			Strcat(bp, verb);
X			Strcat(bp, "s");
X		}
X	}
X	return(bp);
X}
X
Xchar *
XDoname2(obj)
Xregister struct obj *obj;
X{
X	register char *s = doname(obj);
X
X	if('a' <= *s && *s <= 'z') *s -= ('a' - 'A');
X	return(s);
X}
X
Xstatic const char *wrp[] = {
X	"wand", "ring", "potion", "scroll", "gem", "amulet",
X	"spellbook", "spell book",
X	/* for non-specific wishes */
X	"weapon", "armor", "tool", "food", "comestible",
X};
Xstatic const char wrpsym[] = {
X	WAND_CLASS, RING_CLASS, POTION_CLASS, SCROLL_CLASS, GEM_CLASS, 
X        AMULET_CLASS, SPBOOK_CLASS, SPBOOK_CLASS,
X	WEAPON_CLASS, ARMOR_CLASS, TOOL_CLASS, FOOD_CLASS, FOOD_CLASS
X};
X
X#endif /* OVLB */
X#ifdef OVL0
X
X/* Plural routine; chiefly used for user-defined fruits.  We have to try to
X * account for everything reasonable the player has; something unreasonable
X * can still break the code.  However, it's still a lot more accurate than
X * "just add an s at the end", which Rogue uses...
X *
X * Also used for plural monster names ("Wiped out all homunculi.")
X * and body parts.
X *
X * Also misused by muse.c to convert 1st person present verbs to 2nd person.
X */
Xchar *
Xmakeplural(oldstr)
Xconst char *oldstr;
X{
X	/* Note: cannot use strcmpi here -- it'd give MATZot, CAVEMeN,... */
X	register char *spot;
X	static char NEARDATA str[BUFSZ];
X	const char *excess;
X	int len;
X
X	while (*oldstr==' ') oldstr++;
X	if (!oldstr || !*oldstr) {
X		impossible("plural of null?");
X		Strcpy(str, "s");
X		return str;
X	}
X	Strcpy(str, oldstr);
X
X	/* Search for common compounds, ex. lump of royal jelly */
X	for(excess=(char *)0, spot=str; *spot; spot++) {
X		if (!strncmp(spot, " of ", 4)
X				|| !strncmp(spot, " labeled ", 9)
X				|| !strncmp(spot, " called ", 8)
X				|| !strncmp(spot, " named ", 7)
X				|| !strcmp(spot, " above") /* lurkers above */
X				|| !strncmp(spot, " versus ", 8)
X#ifdef TUTTI_FRUTTI
X				|| !strncmp(spot, " from ", 6)
X				|| !strncmp(spot, " in ", 4)
X				|| !strncmp(spot, " on ", 4)
X				|| !strncmp(spot, " a la ", 6)
X				|| !strncmp(spot, " with", 5)	/* " with "? */
X				|| !strncmp(spot, " de ", 4)
X				|| !strncmp(spot, " d'", 3)
X				|| !strncmp(spot, " du ", 4)
X#endif
X				) {
X			excess = oldstr + (int) (spot - str);
X			*spot = 0;
X			break;
X		}
X	}
X	spot--;
X	while (*spot==' ') spot--; /* Strip blanks from end */
X	*(spot+1) = 0;
X	/* Now spot is the last character of the string */
X
X	len = strlen(str);
X#ifdef TUTTI_FRUTTI
X	/* Single letters */
X	if (len==1 || !letter(*spot)) {
X		Strcpy(spot+1, "'s");
X		goto bottom;
X	}
X#endif
X
X	/* man/men ("Wiped out all cavemen.") */
X	if (len >= 3 && !strcmp(spot-2, "man") &&
X			(len<6 || strcmp(spot-5, "shaman")) &&
X			(len<5 || strcmp(spot-4, "human"))) {
X		*(spot-1) = 'e';
X		goto bottom;
X	}
X
X	/* tooth/teeth */
X	if (len >= 5 && !strcmp(spot-4, "tooth")) {
X		Strcpy(spot-3, "eeth");
X		goto bottom;
X	}
X
X	/* knife/knives, etc... */
X	if (!strcmp(spot-1, "fe"))
X		*(spot-1) = 'v';
X	else if (*spot == 'f')
X		if (index("lr", *(spot-1)) || index(vowels, *(spot-1)))
X			*spot = 'v';
X		else if (len >= 5 && !strncmp(spot-4, "staf", 4))
X			Strcpy(spot-1, "ve");
X
X	/* foot/feet (body part) */
X	if (len >= 4 && !strcmp(spot-3, "foot")) {
X		Strcpy(spot-2, "eet");
X		goto bottom;
X	}
X
X	/* ium/ia (mycelia, baluchitheria) */
X	if (len >= 3 && !strcmp(spot-2, "ium")) {
X		*(spot--) = (char)0;
X		*spot = 'a';
X		goto bottom;
X	}
X
X	/* algae, larvae, hyphae (another fungus part) */
X#ifdef TUTTI_FRUTTI
X	if ((len >= 4 && !strcmp(spot-3, "alga")) ||
X	    (len >= 5 &&
X	     (!strcmp(spot-4, "hypha") || !strcmp(spot-4, "larva"))))
X#else
X	if (len >= 5 && (!strcmp(spot-4, "hypha")))
X#endif
X	{
X		Strcpy(spot, "ae");
X		goto bottom;
X	}
X
X	/* fungus/fungi, homunculus/homunculi, but wumpuses */
X	if (!strcmp(spot-1, "us") && (len < 6 || strcmp(spot-5, "wumpus"))) {
X		*(spot--) = (char)0;
X		*spot = 'i';
X		goto bottom;
X	}
X
X	/* vortex/vortices */
X	if (len >= 6 && !strcmp(spot-3, "rtex")) {
X		Strcpy(spot-1, "ices");
X		goto bottom;
X	}
X
X	/* djinni/djinn (note: also efreeti/efreet) */
X	if (len >= 6 && !strcmp(spot-5, "djinni")) {
X		*spot = (char)0;
X		goto bottom;
X	}
X
X	/* mumak/mumakil */
X	if (len >= 5 && !strcmp(spot-4, "mumak")) {
X		Strcpy(spot, "il");
X		goto bottom;
X	}
X
X	/* same singular and plural */
X	/* note: also swine, trout, grouse */
X	if ((len >= 7 && !strcmp(spot-6, "samurai")) ||
X#ifdef TUTTI_FRUTTI
X	    (len >= 5 &&
X	     (!strcmp(spot-4, "manes") || !strcmp(spot-4, "sheep"))) ||
X	    (len >= 4 &&
X	     (!strcmp(spot-3, "fish") || !strcmp(spot-3, "tuna") ||
X	      !strcmp(spot-3, "deer")))
X#else
X	    (len >= 5 && !strcmp(spot-4, "manes"))
X#endif
X	    ) goto bottom;
X
X	/* sis/ses (nemesis) */
X	if (len >= 3 && !strcmp(spot-2, "sis")) {
X		*(spot-1) = 'e';
X		goto bottom;
X	}
X
X#ifdef TUTTI_FRUTTI
X	/* mouse/mice,louse/lice (not a monster, but possible in food names) */
X	if (len >= 5 && !strcmp(spot-3, "ouse") && index("MmLl", *(spot-4))) {
X		Strcpy(spot-3, "ice");
X		goto bottom;
X	}
X
X	/* matzoh/matzot, possible food name */
X	if (len >= 6 && (!strcmp(spot-5, "matzoh")
X					|| !strcmp(spot-5, "matzah"))) {
X		Strcpy(spot-1, "ot");
X		goto bottom;
X	}
X	if (len >= 5 && (!strcmp(spot-4, "matzo")
X					|| !strcmp(spot-5, "matza"))) {
X		Strcpy(spot, "ot");
X		goto bottom;
X	}
X
X	/* child/children (for wise guys who give their food funny names) */
X	if (len >= 5 && !strcmp(spot-4, "child")) {
X		Strcpy(spot, "dren");
X		goto bottom;
X	}
X
X	/* note: -eau/-eaux (gateau, bordeau...) */
X	/* note: ox/oxen, VAX/VAXen, goose/geese */
X#endif
X
X	/* Ends in z, x, s, ch, sh; add an "es" */
X	if (index("zxsv", *spot)
X			|| (len >= 2 && *spot=='h' && index("cs", *(spot-1)))
X#ifdef TUTTI_FRUTTI
X	/* Kludge to get "tomatoes" and "potatoes" right */
X			|| (len >= 4 && !strcmp(spot-2, "ato"))
X#endif
X									) {
X		Strcpy(spot+1, "es");
X		goto bottom;
X	}
X
X	/* Ends in y preceded by consonant (note: also "qu") change to "ies" */
X	if (*spot == 'y' &&
X	    (!index(vowels, *(spot-1)))) {
X		Strcpy(spot, "ies");
X		goto bottom;
X	}
X
X	/* Japanese words: plurals are the same as singlar */
X	if (len == 2 && !strcmp(str, "ya"))
X	    goto bottom;
X
X	/* Default: append an 's' */
X	Strcpy(spot+1, "s");
X
Xbottom:	if (excess) Strcpy(eos(str), excess);
X	return str;
X}
X
X#endif /* OVL0 */
X
Xstruct o_range {
X	const char *name, osym;
X	int  f_o_range, l_o_range;
X};
X
X#ifndef OVLB
X
XSTATIC_DCL const struct o_range o_ranges[];
X
X#else /* OVLB */
X
X/* wishable subranges of objects */
XSTATIC_OVL const struct o_range NEARDATA o_ranges[] = {
X	{ "bag",	TOOL_CLASS,   SACK,	      BAG_OF_TRICKS },
X	{ "candle",	TOOL_CLASS,   TALLOW_CANDLE,  WAX_CANDLE },
X	{ "horn",	TOOL_CLASS,   TOOLED_HORN,    HORN_OF_PLENTY },
X	{ "gloves",	ARMOR_CLASS,  LEATHER_GLOVES, GAUNTLETS_OF_DEXTERITY },
X	{ "gauntlets",	ARMOR_CLASS,  LEATHER_GLOVES, GAUNTLETS_OF_DEXTERITY },
X	{ "boots",	ARMOR_CLASS,  LOW_BOOTS,      LEVITATION_BOOTS },
X	{ "shoes",	ARMOR_CLASS,  LOW_BOOTS,      IRON_SHOES },
X	{ "cloak",	ARMOR_CLASS,  MUMMY_WRAPPING, CLOAK_OF_DISPLACEMENT },
X	{ "shield",	ARMOR_CLASS,  SMALL_SHIELD,   SHIELD_OF_REFLECTION },
X	{ "helm",	ARMOR_CLASS,  ELVEN_LEATHER_HELM, HELM_OF_TELEPATHY },
X	{ "dragon scales",
X			ARMOR_CLASS,  GRAY_DRAGON_SCALES, YELLOW_DRAGON_SCALES },
X	{ "dragon scale mail",
X			ARMOR_CLASS,  GRAY_DRAGON_SCALE_MAIL, YELLOW_DRAGON_SCALE_MAIL },
X	{ "sword",	WEAPON_CLASS, SHORT_SWORD,    KATANA },
X#ifdef WIZARD
X	{ "venom",	VENOM_CLASS,  BLINDING_VENOM, ACID_VENOM },
X#endif
X};
X
X#define BSTRCMP(base,ptr,string) ((ptr) < base || strcmp((ptr),string))
X#define BSTRCMPI(base,ptr,string) ((ptr) < base || strcmpi((ptr),string))
X#define BSTRNCMP(base,ptr,string,num) ((ptr)<base || strncmp((ptr),string,num))
X
X/*
X * Singularize a string the user typed in; this helps reduce the complexity
X * of readobjnam, and is also used in pager.c to singularize the string
X * for which help is sought.
X */
X
Xchar *
Xmakesingular(oldstr)
Xconst char *oldstr;
X{
X	register char *p, *bp;
X	static char NEARDATA str[BUFSZ];
X
X	if (!oldstr || !*oldstr) {
X		impossible("singular of null?");
X		str[0] = 0; return str;
X	}
X	Strcpy(str, oldstr);
X	bp = str;
X
X	while (*bp == ' ') bp++;
X	/* find "cloves of garlic", "worthless pieces of blue glass" */
X	if ((p = strstri(bp, "s of ")) != 0) {
X	    /* but don't singularize "gauntlets" */
X	    if (BSTRNCMP(bp, p-8, "gauntlet", 8))
X		while ((*p = *(p+1)) != 0) p++;
X	    return bp;
X	}
X
X	/* remove -s or -es (boxes) or -ies (rubies) */
X	p = eos(bp);
X	if (p >= bp+1 && p[-1] == 's') {
X		if (p >= bp+2 && p[-2] == 'e') {
X			if (p >= bp+3 && p[-3] == 'i') {
X				if(!BSTRCMP(bp, p-7, "cookies") ||
X				   !BSTRCMP(bp, p-4, "pies"))
X					goto mins;
X				Strcpy(p-3, "y");
X				return bp;
X			}
X
X			/* note: cloves / knives from clove / knife */
X			if(!BSTRCMP(bp, p-6, "knives")) {
X				Strcpy(p-3, "fe");
X				return bp;
X			}
X
X			if(!BSTRCMP(bp, p-6, "staves")) {
X				Strcpy(p-3, "ff");
X				return bp;
X			}
X
X			/* note: nurses, axes but boxes */
X			if(!BSTRCMP(bp, p-5, "boxes")) {
X				p[-2] = 0;
X				return bp;
X			}
X			if (!BSTRCMP(bp, p-6, "gloves") ||
X			    !BSTRCMP(bp, p-5, "shoes") ||
X			    !BSTRCMP(bp, p-6, "scales"))
X				return bp;
X		} else if (!BSTRCMP(bp, p-5, "boots") ||
X			   !BSTRCMP(bp, p-6, "tricks") ||
X			   !BSTRCMP(bp, p-9, "paralysis") ||
X			   !BSTRCMP(bp, p-5, "glass") ||
X			   !BSTRCMP(bp, p-4, "ness") ||
X			   !BSTRCMP(bp, p-14, "shape changers") ||
X			   !BSTRCMP(bp, p-15, "detect monsters") ||
X			   !BSTRCMPI(bp, p-11, "Aesculapius"))	/* staff */
X				return bp;
X	mins:
X		p[-1] = 0;
X	} else {
X		if(!BSTRCMP(bp, p-5, "teeth")) {
X			Strcpy(p-5, "tooth");
X			return bp;
X		}
X		/* here we cannot find the plural suffix */
X	}
X	return bp;
X}
X
X/* alternate spellings: extra space, space instead of hyphen, etc */
Xstruct alt_spellings {
X	const char *sp;
X	int ob;
X} spellings[] = {
X	{ "two handed sword", TWO_HANDED_SWORD },
X	{ "battle axe", BATTLE_AXE },
X	{ "lockpick", LOCK_PICK },
X	{ "pick axe", PICK_AXE },
X	{ "luck stone", LUCKSTONE },
X	{ "load stone", LOADSTONE },
X	{ "broad sword", BROADSWORD },
X	{ "elven broad sword", ELVEN_BROADSWORD },
X	{ "longsword", LONG_SWORD },
X	{ "shortsword", SHORT_SWORD },
X	{ "elven shortsword", ELVEN_SHORT_SWORD },
X	{ "dwarvish shortsword", DWARVISH_SHORT_SWORD },
X	{ "orcish shortsword", ORCISH_SHORT_SWORD },
X	{ "warhammer", WAR_HAMMER },
X	{ "grey dragon scale mail", GRAY_DRAGON_SCALE_MAIL },
X	{ "grey dragon scales", GRAY_DRAGON_SCALES },
X	{ "iron ball", HEAVY_IRON_BALL },
X	{ "stone", ROCK },
X	{ (const char *)0, 0 },
X};
X
X/* Return something wished for.  If not an object, return &zeroobj; if an error
X * (no matching object), return (struct obj *)0.  Giving readobjnam() a null
X * pointer skips the error return and creates a random object instead.
X */
Xstruct obj *
Xreadobjnam(bp)
Xregister char *bp;
X{
X	register char *p;
X	register int i;
X	register struct obj *otmp;
X	int cnt, spe, spesgn, typ, very;
X	int blessed, uncursed, iscursed, ispoisoned;
X	int eroded, erodeproof;
X	int halfeaten, mntmp, contents;
X	int islit, unlabeled;
X#ifdef TUTTI_FRUTTI
X	struct fruit *f;
X	int ftype = current_fruit;
X	char fruitbuf[BUFSZ];
X	/* We want to check for fruits last so that, for example, someone
X	 * who names their fruit "katana" and wishes for a katana gets a real
X	 * one.  But, we have to keep around the old buf since in the meantime
X	 * we have deleted "empty", "+6", etc...
X	 */
X#endif
X	char let;
X	char *un, *dn, *actualn;
X	const char *name=0;
X
X	cnt = spe = spesgn = typ = very = blessed = uncursed =
X		iscursed = ispoisoned = eroded = erodeproof = halfeaten =
X		islit = unlabeled = 0;
X	mntmp = -1;
X#define UNDEFINED 0
X#define EMPTY 1
X#define SPINACH 2
X	contents = UNDEFINED;
X	let = 0;
X	actualn = dn = un = 0;
X
X	/* first, remove extra whitespace they may have typed */
X	if (bp) {
X		char c, *p2;
X		boolean was_space = TRUE;
X
X		for (p = p2 = bp; (c = *p) != '\0'; p++) {
X		     /* if (c == '\t') c = ' '; */
X			if (c != ' ' || !was_space)  *p2++ = c;
X			was_space = (c == ' ');
X		}
X		if (was_space && p2 > bp)  p2--;
X		*p2 = '\0';
X	}
X
X	for(;;) {
X		register int l;
X
X		if (!bp || !*bp) goto any;
X		if (!strncmpi(bp, "an ", l=3) ||
X		    !strncmpi(bp, "a ", l=2)) {
X			cnt = 1;
X		} else if (!strncmpi(bp, "the ", l=4)) {
X			;	/* just increment `bp' by `l' below */
X		} else if (!cnt && digit(*bp)) {
X			cnt = atoi(bp);
X			while(digit(*bp)) bp++;
X			while(*bp == ' ') bp++;
X			l = 0;
X		} else if (!strncmpi(bp, "blessed ", l=8) ||
X			   !strncmpi(bp, "holy ", l=5)) {
X			blessed = 1;
X		} else if (!strncmpi(bp, "cursed ", l=7) ||
X			   !strncmpi(bp, "unholy ", l=7)) {
X			iscursed = 1;
X		} else if (!strncmpi(bp, "uncursed ", l=9)) {
X			uncursed = 1;
X		} else if (!strncmp(bp, "rustproof ", l=10) ||
X			   !strncmp(bp, "erodeproof ", l=11) ||
X			   !strncmp(bp, "corrodeproof ", l=13) ||
X			   !strncmp(bp, "fireproof ", l=10)) {
X			erodeproof = 1;
X		} else if (!strncmpi(bp,"lit ", l=4) ||
X			   !strncmpi(bp,"burning ", l=8)) {
X			islit = 1;
X		} else if (!strncmpi(bp,"unlit ", l=6) ||
X			   !strncmpi(bp,"extinguished ", l=13)) {
X			islit = 0;
X		/* "unlabeled" and "blank" are synonymous */
X		} else if (!strncmpi(bp,"unlabeled ", l=10) ||
X			   !strncmpi(bp,"unlabelled ", l=11) ||
X			   !strncmpi(bp,"blank ", l=6)) {
X			unlabeled = 1;
X		} else if (!strncmpi(bp, "very ", l=5)) {
X			very = 1;
X		} else if (!strncmpi(bp, "thoroughly ", l=11)) {
X			very = 2;
X		} else if (!strncmp(bp, "rusty ", l=6) ||
X			   !strncmp(bp, "rusted ", l=7) ||
X			   !strncmp(bp, "eroded ", l=7) ||
X			   !strncmp(bp, "corroded ", l=9) ||
X			   !strncmp(bp, "burnt ", l=6) ||
X			   !strncmp(bp, "burned ", l=7) ||
X			   !strncmp(bp, "rotted ", l=7)) {
X			eroded = 1 + very; very = 0;
X		} else if (!strncmpi(bp, "partly eaten ", l=13)) {
X			halfeaten = 1;
X		} else break;
X		bp += l;
X	}
X	if(!cnt) cnt = 1;		/* %% what with "gems" etc. ? */
X#ifdef TUTTI_FRUTTI
X	Strcpy(fruitbuf, bp);
X#endif
X	if(!strncmpi(bp, "empty ", 6)) {
X		contents = EMPTY;
X		bp += 6;
X	} else if(!strncmpi(bp, "poisoned ",9)) {
X		ispoisoned=1;
X		bp += 9;
X#ifdef WIZARD
X	} else if(wizard && !strncmpi(bp, "trapped ",8)) {
X		ispoisoned=1;
X		bp += 8;
X#endif
X	}
X	if (strlen(bp) > 1) {
X	    if (*bp == '+' || *bp == '-') {
X		spesgn = (*bp++ == '+') ? 1 : -1;
X		spe = atoi(bp);
X		while(digit(*bp)) bp++;
X		while(*bp == ' ') bp++;
X	    } else if ((p = rindex(bp, '(')) != 0) {
X		if (p > bp && p[-1] == ' ') p[-1] = 0;
X		else *p = 0;
X		p++;
X		if (!strcmpi(p, "lit)"))
X		    islit = 1;
X		else {
X		    spe = atoi(p);
X		    while(digit(*p)) p++;
X		    if (*p != ')') spe = 0;
X		    else {
X			spesgn = 1;
X			p++;
X			if (*p) Strcat(bp, p);
X		    }
X		}
X	    }
X	}
X/*
X   otmp->spe is type schar; so we don't want spe to be any bigger or smaller.
X   also, spe should always be positive  -- some cheaters may try to confuse
X   atoi()
X*/
X	if (spe < 0) {
X		spesgn = -1;	/* cheaters get what they deserve */
X		spe = abs(spe);
X	}
X	if (spe > SCHAR_LIM)
X		spe = SCHAR_LIM;
X
X	/* now we have the actual name, as delivered by xname, say
X		green potions called whisky
X		scrolls labeled "QWERTY"
X		egg
X		fortune cookies
X		very heavy iron ball named hoei
X		wand of wishing
X		elven cloak
X	*/
X	if ((p = strstri(bp, " named ")) != 0) {
X		*p = 0;
X		name = p+7;
X	}
X	if ((p = strstri(bp, " called ")) != 0) {
X		*p = 0;
X		un = p+8;
X		/* "helmet called telepathy" is not "helmet" (a specific type)
X		 * "shield called reflection" is not "shield" (a general type)
X		 */
X		for(i = 0; i < SIZE(o_ranges); i++)
X		    if(!strcmpi(bp, o_ranges[i].name)) {
X			let = o_ranges[i].osym;
X			goto srch;
X		    }
X	}
X	if ((p = strstri(bp, " labeled ")) != 0) {
X		*p = 0;
X		dn = p+9;
X	} else if ((p = strstri(bp, " labelled ")) != 0) {
X		*p = 0;
X		dn = p+10;
X	}
X	if ((p = strstri(bp, " of spinach")) != 0) {
X		*p = 0;
X		contents = SPINACH;
X	}
X
X	/* Skip over "pair of ", then jump to the singular since we don't
X	   need to convert "gloves" or "boots". */
X	if(cnt == 1 && !strncmpi(bp, "pair of ",8)) {
X		bp += 8;
X		cnt = 2;
X		goto sing;
X		/* cnt is ignored for armor and other non-stackable objects;
X		   DTRT for stackable objects */
X	} else if(cnt > 1 && !strncmpi(bp, "pairs of ",9)) {
X		bp += 9;
X		cnt *= 2;
X	} else if (!strncmpi(bp, "set of ",7)) {
X		bp += 7;
X	} else if (!strncmpi(bp, "sets of ",8)) {
X		bp += 8;
X	}
X
X	/*
X	 * Find corpse type using "of" (figurine of an orc, tin of orc meat)
X	 * Don't check if it's a wand or spellbook.
X	 * (avoid "wand/finger of death" confusion).
X	 */
X	if (!strstri(bp, "wand ")
X	 && !strstri(bp, "spellbook ")
X	 && !strstri(bp, "finger ")) {
X	    if ((p = strstri(bp, " of ")) != 0
X		&& (mntmp = name_to_mon(p+4)) >= 0)
X		*p = 0;
X	}
X	/* Find corpse type w/o "of" (red dragon scale mail, yeti corpse) */
X	if (strncmp(bp, "samurai sword", 13)) /* not the "samurai" monster! */
X	if (strncmp(bp, "wizard lock", 11)) /* not the "wizard" monster! */
X	if (strncmp(bp, "ninja-to", 8)) /* not the "ninja" rank */
X	if (mntmp < 0 && strlen(bp) > 2 && (mntmp = name_to_mon(bp)) >= 0) {
X		int mntmptoo, mntmplen;	/* double check for rank title */
X		char *obp = bp;
X		mntmptoo = title_to_mon(bp, (int *)0, &mntmplen);
X		bp += mntmp != mntmptoo ? strlen(mons[mntmp].mname) : mntmplen;
X		if (*bp == ' ') bp++;
X		else if (!strncmpi(bp, "s ", 2)) bp += 2;
X		else if (!strncmpi(bp, "es ", 3)) bp += 3;
X		else if (!*bp && !actualn && !dn && !un && !let) {
X		    /* no referent; they don't really mean a monster type */
X		    bp = obp;
X		    mntmp = -1;
X		}
X	}
X
X	/* first change to singular if necessary */
X	if (*bp) {
X		char *sng = makesingular(bp);
X		if (strcmp(bp, sng)) {
X			if (cnt == 1) cnt = 2;
X			Strcpy(bp, sng);
X		}
X	}
X
Xsing:
X	/* Alternate spellings (two-handed sword vs. two handed sword) */
X	{struct alt_spellings *as = spellings;
X		while(as->sp) {
X			if (!strcmpi(bp, as->sp)) {
X				typ = as->ob;
X				goto typfnd;
X			}
X			as++;
X		}
X	}
X
X	/* dragon scales - assumes order of dragons */
X	if(!strcmpi(bp, "scales") &&
X			mntmp >= PM_GRAY_DRAGON && mntmp <= PM_YELLOW_DRAGON) {
X		typ = GRAY_DRAGON_SCALES + mntmp - PM_GRAY_DRAGON;
X		mntmp = -1;	/* no monster */
X		goto typfnd;
X	}
X
X	if(!strcmpi(bp, "ring mail") ||	/* Note: ring mail is not a ring ! */
X	   !strcmpi(bp, "leather armor") || /* Prevent falling to 'armor'. */
X	   !strcmpi(bp, "studded leather armor")) {
X		let = ARMOR_CLASS;
X		actualn = bp;
X		goto srch;
X	}
X	if(!strcmpi(bp, "food ration")){
X		let = FOOD_CLASS;
X		actualn = bp;
X		goto srch;
X	}
X	p = eos(bp);
X	if(!BSTRCMPI(bp, p-10, "holy water")) {
X		typ = POT_WATER;
X		if ((p-bp) >= 12 && *(p-12) == 'u')
X			iscursed = 1; /* unholy water */
X		else blessed = 1;
X		goto typfnd;
X	}
X	if(unlabeled && !BSTRCMPI(bp, p-6, "scroll")) {
X		typ = SCR_BLANK_PAPER;
X		goto typfnd;
X	}
X	if(unlabeled && !BSTRCMPI(bp, p-9, "spellbook")) {
X		typ = SPE_BLANK_PAPER;
X		goto typfnd;
X	}
X#ifdef TOURIST
X	if (!BSTRCMPI(bp, p-5, "shirt")) {
X		typ = HAWAIIAN_SHIRT;
X		goto typfnd;
X	}
X#endif
X	/*
X	 * NOTE: Gold pieces are handled as objects nowadays, and therefore
X	 * this section should probably be reconsidered as well as the entire
X	 * gold/money concept.  Maybe we want to add other monetary units as
X	 * well in the future. (TH)
X	 */
X	if(!BSTRCMPI(bp, p-10, "gold piece") || !BSTRCMPI(bp, p-7, "zorkmid") ||
X	   !strcmpi(bp, "gold") || !strcmpi(bp, "money") || 
X	   !strcmpi(bp, "coin") || *bp == GOLD_SYM) {
X			if (cnt > 5000
X#ifdef WIZARD
X					&& !wizard
X#endif
X						) cnt=5000;
X		if (cnt < 1) cnt=1;
X		pline("%d gold piece%s.", cnt, plur(cnt));
X		u.ugold += cnt;
X		flags.botl=1;
X		return (&zeroobj);
X	}
X	if (strlen(bp) == 1 &&
X	   (i = def_char_to_objclass(*bp)) < MAXOCLASSES && i > ILLOBJ_CLASS) {
X		let = i;
X		goto any;
X	}
X	if(strncmpi(bp, "enchant ", 8) &&
X	   strncmpi(bp, "destroy ", 8) &&
X	   strncmpi(bp, "food detection", 14))
X	/* allow wishes for "enchant weapon" and "food detection" */
X	for(i = 0; i < sizeof(wrpsym); i++) {
X		register int j = strlen(wrp[i]);
X		if(!strncmpi(bp, wrp[i], j)){
X			let = wrpsym[i];
X			if(let != AMULET_CLASS) {
X			    bp += j;
X			    if(!strncmpi(bp, " of ", 4)) actualn = bp+4;
X			    /* else if(*bp) ?? */
X			} else
X			    actualn = bp;
X			goto srch;
X		}
X		if(!BSTRCMPI(bp, p-j, wrp[i])){
X			let = wrpsym[i];
X			p -= j;
X			*p = 0;
X			if(p > bp && p[-1] == ' ') p[-1] = 0;
X			actualn = dn = bp;
X			goto srch;
X		}
X	}
X	if (!BSTRCMPI(bp, p-6, " stone")) {
X		p[-6] = 0;
X		let = GEM_CLASS;
X		dn = actualn = bp;
X		goto srch;
X	} else if (!BSTRCMPI(bp, p-6, " glass") || !strcmpi(bp, "glass")) {
X		register char *g = bp;
X		if (strstri(g, "broken")) return (struct obj *)0;
X		if (!strncmpi(g, "worthless ", 10)) g += 10;
X		if (!strncmpi(g, "piece of ", 9)) g += 9;
X		if (!strncmpi(g, "colored ", 8)) g += 8;
X		if (!strcmpi(g, "glass")) {	/* choose random color */
X			/* white, blue, red, yellowish brown, green, violet */
X			typ = LAST_GEM + rnd(6);
X			if (objects[typ].oc_class == GEM_CLASS) goto typfnd;
X			else typ = 0;	/* somebody changed objects[]? punt */
X		} else if (g > bp) {	/* try to construct canonical form */
X			char tbuf[BUFSZ];
X			Strcpy(tbuf, "worthless piece of ");
X			Strcat(tbuf, g);  /* assume it starts with the color */
X			Strcpy(bp, tbuf);
X		}
X	}
X#ifdef WIZARD
X	/* Let wizards wish for traps --KAA */
X	if (wizard) {
X		int trap;
X		char *tname;
X
X		for (trap = NO_TRAP+1; trap < TRAPNUM; trap++) {
X			tname = index(traps[trap], ' ');
X			if (tname) {
X			    if (!strncmpi(tname+1, bp, strlen(tname+1))) {
X				/* avoid stupid mistakes */
X				if(trap == TRAPDOOR && !Can_fall_thru(&u.uz))
X				    trap = ROCKTRAP;
X
X				(void) maketrap(u.ux, u.uy, trap);
X				pline("A%s.", traps[trap]);
X				return(&zeroobj);
X			    }
X			}
X		}
X		/* or some other dungeon features -dlc */
X		p = eos(bp);
X		if(!BSTRCMP(bp, p-8, "fountain")) {
X			levl[u.ux][u.uy].typ = FOUNTAIN;
X			if(!strncmpi(bp, "magic ", 6))
X				levl[u.ux][u.uy].blessedftn = 1;
X			pline("A %sfountain.",
X			      levl[u.ux][u.uy].blessedftn ? "magic " : "");
X			newsym(u.ux, u.uy);
X			return(&zeroobj);
X		}
X		if(!BSTRCMP(bp, p-5, "altar")) {
X		    aligntyp al;
X
X		    levl[u.ux][u.uy].typ = ALTAR;
X		    if(!strncmpi(bp, "chaotic ", 8))
X			al = A_CHAOTIC;
X		    else if(!strncmpi(bp, "neutral ", 8))
X			al = A_NEUTRAL;
X		    else if(!strncmpi(bp, "lawful ", 7))
X			al = A_LAWFUL;
X		    else if(!strncmpi(bp, "unaligned ", 10))
X			al = A_NONE;
X		    else /* -1 - A_CHAOTIC, 0 - A_NEUTRAL, 1 - A_LAWFUL */
X			al = (!rn2(6)) ? A_NONE : rn2((int)A_LAWFUL+2) - 1;
X		    levl[u.ux][u.uy].altarmask = Align2amask( al );
X		    pline("%s altar.", An(align_str(al)));
X		    newsym(u.ux, u.uy);
X		    return(&zeroobj);
X		}
X	}
X#endif
X	for (i = 0; i < SIZE(o_ranges); i++)
X	    if(!strcmpi(bp, o_ranges[i].name)) {
X		typ = rnd_class(o_ranges[i].f_o_range, o_ranges[i].l_o_range);
X		goto typfnd;
X	    }
X
X	actualn = bp;
X	if (!dn) dn = actualn; /* ex. "skull cap" */
Xsrch:
X	/* check real names of gems first */
X	if(!let && actualn) {
X	    for(i = bases[letindex(GEM_CLASS)]; i <= LAST_GEM; i++) {
X		register const char *zn;
X
X		if((zn = OBJ_NAME(objects[i])) && !strcmpi(actualn, zn)) {
X		    typ = i;
X		    goto typfnd;
X		}
X	    }
X	}
X	i = 1;
X	if(let) i = bases[letindex(let)];
X	while(i <= NROFOBJECTS && (!let || objects[i].oc_class == let)){
X		register const char *zn;
X
X		if(actualn && (zn = OBJ_NAME(objects[i])) && !strcmpi(actualn, zn)) {
X			typ = i;
X			goto typfnd;
X		}
X		if(dn && (zn = OBJ_DESCR(objects[i])) && !strcmpi(dn, zn)) {
X			/* don't match extra descriptions (w/o real name) */
X			if (!OBJ_NAME(objects[i])) return (struct obj *)0;
X			typ = i;
X			goto typfnd;
X		}
X		if(un && (zn = objects[i].oc_uname) && !strcmpi(un, zn)) {
X			typ = i;
X			goto typfnd;
X		}
X		i++;
X	}
X	if (actualn) {
X		struct Jitem *j = Japanese_items;
X		while(j->item) {
X			if (actualn && !strcmpi(actualn, j->name)) {
X				typ = j->item;
X				goto typfnd;
X			}
X			j++;
X		}
X	}
X#ifdef TUTTI_FRUTTI
X	/* Note: not strncmpi.  2 fruits, one capital, one not, is possible. */
X	for(f=ffruit; f; f = f->nextf) {
X		char *f1 = f->fname, *f2 = makeplural(f->fname);
X
X		if(!strncmp(fruitbuf, f1, strlen(f1)) ||
X					!strncmp(fruitbuf, f2, strlen(f2))) {
X			typ = SLIME_MOLD;
X			ftype = f->fid;
X			goto typfnd;
X		}
X	}
X#endif
X	if (!strcmpi(bp, "spinach")) {
X		contents = SPINACH;
X		typ = TIN;
X		goto typfnd;
X	}
X
X	if(!let && actualn) {
X	    short objtyp;
X
X	    /* Perhaps it's an artifact specified by name, not type */
X	    name = artifact_name(actualn, &objtyp);
X	    if(name) {
X		typ = objtyp;
X		goto typfnd;
X	    }
X	}
X	if(!let) return((struct obj *)0);
Xany:
X	if(!let) let = wrpsym[rn2((int)sizeof(wrpsym))];
Xtypfnd:
X	if (typ) let = objects[typ].oc_class;
X
X	/* check for some objects that are not allowed */
X	if (typ && objects[typ].oc_unique
X#ifdef WIZARD
X	    && !wizard 
X	    /* should check flags.made_amulet, but it's not set anywhere */
X#endif
X	   )
X	    switch (typ) {
X		case AMULET_OF_YENDOR:
X		    typ = FAKE_AMULET_OF_YENDOR;
X		    break;
X		case CANDELABRUM_OF_INVOCATION:
X		    typ = rnd_class(TALLOW_CANDLE, WAX_CANDLE);
X		    break;
X		case BELL_OF_OPENING:
X		    typ = BELL;
X		    break;
X		case SPE_BOOK_OF_THE_DEAD:
X		    typ = SPE_BLANK_PAPER;
X		    break;
X	    }
X
X	/* venom isn't really an object and can't be wished for; but allow
X	 * wizards to wish for it since it's faster than polymorphing and
X	 * spitting.
X	 */
X	if(let == VENOM_CLASS)
X#ifdef WIZARD
X		if (!wizard)
X#endif
X			return((struct obj *)0);
X
X	if(typ) {
X		otmp = mksobj(typ, TRUE, FALSE);
X	} else {
X		otmp = mkobj(let, FALSE);
X		if (otmp) typ = otmp->otyp;
X	}
X
X	if(typ == OIL_LAMP || typ == MAGIC_LAMP || typ == BRASS_LANTERN)
X		otmp->lamplit = islit;
X
X	if(cnt > 0 && objects[typ].oc_merge && let != SPBOOK_CLASS && 
X		(cnt < rnd(6) ||
X#ifdef WIZARD
X		wizard ||
X#endif
X		 (cnt <= 20 &&
X		  ((let == WEAPON_CLASS && typ <= SHURIKEN) || (typ == ROCK)))))
X			otmp->quan = (long) cnt;
X
X#ifdef WIZARD
X	if (let == VENOM_CLASS) otmp->spe = 1;
X#endif
X
X	if (spesgn == 0) spe = otmp->spe;
X#ifdef WIZARD
X	else if (wizard) /* no alteration to spe */ ;
X#endif
X	else if (let == ARMOR_CLASS || let == WEAPON_CLASS || typ == PICK_AXE ||
X			typ == UNICORN_HORN ||
X			(let==RING_CLASS && objects[typ].oc_charged)) {
X		if(spe > rnd(5) && spe > otmp->spe) spe = 0;
X		if(spe > 2 && Luck < 0) spesgn = -1;
X	} else {
X		if (let == WAND_CLASS) {
X			if (spe > 1 && spesgn == -1) spe = 1;
X		} else {
X			if (spe > 0 && spesgn == -1) spe = 0;
X		}
X		if (spe > otmp->spe) spe = otmp->spe;
X	}
X
X	if (spesgn == -1) spe = -spe;
X
X	/* set otmp->spe.  This may, or may not, use spe... */
X	switch (typ) {
X		case TIN: if (contents==EMPTY) {
X				otmp->corpsenm = -1;
X				otmp->spe = 0;
X			} else if (contents==SPINACH) {
X				otmp->corpsenm = -1;
X				otmp->spe = 1;
X			}
X			break;
X#ifdef TUTTI_FRUTTI
X		case SLIME_MOLD: otmp->spe = ftype;
X			/* Fall through */
X#endif
X		case SKELETON_KEY: case CHEST: case LARGE_BOX:
X		case HEAVY_IRON_BALL: case IRON_CHAIN: case STATUE:
X			/* otmp->cobj already done in mksobj() */
X				break;
X#ifdef MAIL
X		case SCR_MAIL: otmp->spe = 1; break;
X#endif
X		case WAN_WISHING:
X#ifdef WIZARD
X			if (!wizard) {
X#endif
X				otmp->spe = (rn2(10) ? -1 : 0);
X				break;
X#ifdef WIZARD
X			}
X			/* fall through (twice), if wizard */
X#endif
X		case MAGIC_LAMP:
X#ifdef WIZARD
X			if (!wizard) {
X#endif
X				otmp->spe = 0;
X				break;
X#ifdef WIZARD
X			}
X			/* fall through, if wizard */
X#endif
X		default: otmp->spe = spe;
X	}
X
X	/* set otmp->corpsenm or dragon scale [mail] */
X	if (mntmp > -1) switch(typ) {
X		case TIN:
X			otmp->spe = 0; /* No spinach */
X		case CORPSE:
X			if (!(mons[mntmp].geno & (G_UNIQ | G_NOCORPSE)))
X				otmp->corpsenm = mntmp;
X			break;
X		case FIGURINE:
X			if (!(mons[mntmp].geno & G_UNIQ)
X			    && !is_human(&mons[mntmp]))
X				otmp->corpsenm = mntmp;
X			break;
X		case EGG: if (lays_eggs(&mons[mntmp]) || mntmp==PM_KILLER_BEE)
X				otmp->corpsenm = mntmp;
X			break;
X		case STATUE: otmp->corpsenm = mntmp;
X			break;
X		case SCALE_MAIL:
X			/* Dragon mail - depends on the order of objects */
X			/*		 & dragons.			 */
X	    		if (mntmp >= PM_GRAY_DRAGON &&
X						mntmp <= PM_YELLOW_DRAGON)
X			    otmp->otyp = GRAY_DRAGON_SCALE_MAIL +
X						    mntmp - PM_GRAY_DRAGON;
X			break;
X	}
X
X	/* set blessed/cursed -- setting the fields directly is safe
X	 * since weight() is called below and addinv() will take care
X	 * of luck */
X	if (iscursed) {
X		curse(otmp);
X	} else if (uncursed) {
X		otmp->blessed = 0;
X		otmp->cursed = (Luck < 0
X#ifdef WIZARD
X					 && !wizard
X#endif
X							);
X	} else if (blessed) {
X		otmp->blessed = (Luck >= 0
X#ifdef WIZARD
X					 || wizard
X#endif
X							);
X		otmp->cursed = (Luck < 0
X#ifdef WIZARD
X					 && !wizard
X#endif
X							);
X	} else if (spesgn < 0) {
X		curse(otmp);
X	}
X
X	/* set eroded */
X	if (eroded)
X		otmp->oeroded = eroded;
X
X	/* set erodeproof */
X	else if (erodeproof)
X		otmp->oerodeproof = (Luck >= 0
X#ifdef WIZARD
X					 || wizard
X#endif
X				    );
X
X	/* prevent wishing abuse */
X	if (
X#ifdef WIZARD
X		!wizard &&
X#endif
X			otmp->otyp == WAN_WISHING)
X		otmp->recharged = 1;
X
X	/* set poisoned */
X	if (ispoisoned) {
X	    if (let == WEAPON_CLASS && typ <= SHURIKEN)
X		otmp->opoisoned = (Luck >= 0);
X	    else if (Is_box(otmp))
X		otmp->otrapped = 1;
X	    else if (let == FOOD_CLASS)
X		/* try to taint by making it as old as possible */
X	    	otmp->age = 1L;
X	}
X
X	if (name) {
X		otmp = oname(otmp, name, 0);
X		if (otmp->oartifact) otmp->quan = 1L;
X	}
X	otmp->owt = weight(otmp);
X	if (very && otmp->otyp == HEAVY_IRON_BALL) otmp->owt += 160;
X	if (halfeaten && otmp->oclass == FOOD_CLASS) {
X		if (otmp->otyp == CORPSE)
X			otmp->oeaten = mons[otmp->corpsenm].cnutrit;
X		else otmp->oeaten = objects[otmp->otyp].oc_nutrition;
X		otmp->owt /= 2;
X		otmp->oeaten /= 2;
X		if (!otmp->owt) otmp->owt = 1;
X		if (!otmp->oeaten) otmp->oeaten = 1;
X	}
X	return(otmp);
X}
X
Xint
Xrnd_class(first,last)
Xint first,last;
X{
X	int i, x, sum=0;
X	for(i=first; i<=last; i++)
X		sum += objects[i].oc_prob;
X	if (!sum) /* all zero */
X		return first + rn2(last-first+1);
X	x = rnd(sum);
X	for(i=first; i<=last; i++)
X		if (objects[i].oc_prob && (x -= objects[i].oc_prob) <= 0)
X			return i;
X	return 0;
X}
X
XSTATIC_OVL const char *
XJapanese_item_name(i)
Xint i;
X{
X	struct Jitem *j = Japanese_items;
X
X	while(j->item) {
X		if (i == j->item)
X			return j->name;
X		j++;
X	}
X	return (const char *)0;
X}
X#endif /* OVLB */
X
X/*objnam.c*/
END_OF_FILE
if test 47782 -ne `wc -c <'src/objnam.c'`; then
    echo shar: \"'src/objnam.c'\" unpacked with wrong size!
fi
# end of 'src/objnam.c'
fi
if test -f 'sys/amiga/char.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/amiga/char.c'\"
else
echo shar: Extracting \"'sys/amiga/char.c'\" \(5759 characters\)
sed "s/^X//" >'sys/amiga/char.c' <<'END_OF_FILE'
XSHORT Type_BorderVectors1[] = {
X	0,0,
X	123,0,
X	123,11,
X	0,11,
X	0,0
X};
Xstruct Border Type_Border1 = {
X	-1,-1,
X	3,0,JAM1,
X	5,
X	Type_BorderVectors1,
X	NULL
X};
X
Xstruct IntuiText Type_IText1 = {
X	3,0,JAM2,
X	38,1,
X	NULL,
X	(UBYTE *)"Wizard",
X	NULL
X};
X
Xstruct Gadget Type_Gadget13 = {
X	NULL,
X	137,79,
X	122,10,
X	NULL,
X	RELVERIFY,
X	BOOLGADGET,
X	(APTR)&Type_Border1,
X	NULL,
X	&Type_IText1,
X	NULL,
X	NULL,
X	'W',
X	NULL
X};
X
XSHORT Type_BorderVectors2[] = {
X	0,0,
X	123,0,
X	123,11,
X	0,11,
X	0,0
X};
Xstruct Border Type_Border2 = {
X	-1,-1,
X	3,0,JAM1,
X	5,
X	Type_BorderVectors2,
X	NULL
X};
X
Xstruct IntuiText Type_IText2 = {
X	3,0,JAM2,
X	29,1,
X	NULL,
X	(UBYTE *)"Valkyrie",
X	NULL
X};
X
Xstruct Gadget Type_Gadget12 = {
X	&Type_Gadget13,
X	9,79,
X	122,10,
X	NULL,
X	RELVERIFY,
X	BOOLGADGET,
X	(APTR)&Type_Border2,
X	NULL,
X	&Type_IText2,
X	NULL,
X	NULL,
X	'V',
X	NULL
X};
X
XSHORT Type_BorderVectors3[] = {
X	0,0,
X	251,0,
X	251,11,
X	0,11,
X	0,0
X};
Xstruct Border Type_Border3 = {
X	-1,-1,
X	1,0,JAM1,
X	5,
X	Type_BorderVectors3,
X	NULL
X};
X
Xstruct IntuiText Type_IText3 = {
X	1,0,JAM2,
X	14,1,
X	NULL,
X	(UBYTE *)"Pick a Random Character Type",
X	NULL
X};
X
Xstruct Gadget Type_Gadget11 = {
X	&Type_Gadget12,
X	9,94,
X	250,10,
X	NULL,
X	RELVERIFY,
X	BOOLGADGET,
X	(APTR)&Type_Border3,
X	NULL,
X	&Type_IText3,
X	NULL,
X	NULL,
X	1,
X	NULL
X};
X
XSHORT Type_BorderVectors4[] = {
X	0,0,
X	123,0,
X	123,11,
X	0,11,
X	0,0
X};
Xstruct Border Type_Border4 = {
X	-1,-1,
X	3,0,JAM1,
X	5,
X	Type_BorderVectors4,
X	NULL
X};
X
Xstruct IntuiText Type_IText4 = {
X	3,0,JAM2,
X	33,1,
X	NULL,
X	(UBYTE *)"Samurai",
X	NULL
X};
X
Xstruct Gadget Type_Gadget10 = {
X	&Type_Gadget11,
X	9,66,
X	122,10,
X	NULL,
X	RELVERIFY,
X	BOOLGADGET,
X	(APTR)&Type_Border4,
X	NULL,
X	&Type_IText4,
X	NULL,
X	NULL,
X	'S',
X	NULL
X};
X
XSHORT Type_BorderVectors5[] = {
X	0,0,
X	123,0,
X	123,11,
X	0,11,
X	0,0
X};
Xstruct Border Type_Border5 = {
X	-1,-1,
X	3,0,JAM1,
X	5,
X	Type_BorderVectors5,
X	NULL
X};
X
Xstruct IntuiText Type_IText5 = {
X	3,0,JAM2,
X	34,1,
X	NULL,
X	(UBYTE *)"Tourist",
X	NULL
X};
X
Xstruct Gadget Type_Gadget9 = {
X	&Type_Gadget10,
X	137,66,
X	122,10,
X	NULL,
X	RELVERIFY,
X	BOOLGADGET,
X	(APTR)&Type_Border5,
X	NULL,
X	&Type_IText5,
X	NULL,
X	NULL,
X	'T',
X	NULL
X};
X
XSHORT Type_BorderVectors6[] = {
X	0,0,
X	123,0,
X	123,11,
X	0,11,
X	0,0
X};
Xstruct Border Type_Border6 = {
X	-1,-1,
X	3,0,JAM1,
X	5,
X	Type_BorderVectors6,
X	NULL
X};
X
Xstruct IntuiText Type_IText6 = {
X	3,0,JAM2,
X	40,1,
X	NULL,
X	(UBYTE *)"Rogue",
X	NULL
X};
X
Xstruct Gadget Type_Gadget8 = {
X	&Type_Gadget9,
X	137,53,
X	122,10,
X	NULL,
X	RELVERIFY,
X	BOOLGADGET,
X	(APTR)&Type_Border6,
X	NULL,
X	&Type_IText6,
X	NULL,
X	NULL,
X	'R',
X	NULL
X};
X
XSHORT Type_BorderVectors7[] = {
X	0,0,
X	123,0,
X	123,11,
X	0,11,
X	0,0
X};
Xstruct Border Type_Border7 = {
X	-1,-1,
X	3,0,JAM1,
X	5,
X	Type_BorderVectors7,
X	NULL
X};
X
Xstruct IntuiText Type_IText7 = {
X	3,0,JAM2,
X	36,1,
X	NULL,
X	(UBYTE *)"Priest",
X	NULL
X};
X
Xstruct Gadget Type_Gadget7 = {
X	&Type_Gadget8,
X	9,53,
X	122,10,
X	NULL,
X	RELVERIFY,
X	BOOLGADGET,
X	(APTR)&Type_Border7,
X	NULL,
X	&Type_IText7,
X	NULL,
X	NULL,
X	'P',
X	NULL
X};
X
XSHORT Type_BorderVectors8[] = {
X	0,0,
X	123,0,
X	123,11,
X	0,11,
X	0,0
X};
Xstruct Border Type_Border8 = {
X	-1,-1,
X	3,0,JAM1,
X	5,
X	Type_BorderVectors8,
X	NULL
X};
X
Xstruct IntuiText Type_IText8 = {
X	3,0,JAM2,
X	35,1,
X	NULL,
X	(UBYTE *)"Healer",
X	NULL
X};
X
Xstruct Gadget Type_Gadget6 = {
X	&Type_Gadget7,
X	9,40,
X	122,10,
X	NULL,
X	RELVERIFY,
X	BOOLGADGET,
X	(APTR)&Type_Border8,
X	NULL,
X	&Type_IText8,
X	NULL,
X	NULL,
X	'H',
X	NULL
X};
X
XSHORT Type_BorderVectors9[] = {
X	0,0,
X	123,0,
X	123,11,
X	0,11,
X	0,0
X};
Xstruct Border Type_Border9 = {
X	-1,-1,
X	3,0,JAM1,
X	5,
X	Type_BorderVectors9,
X	NULL
X};
X
Xstruct IntuiText Type_IText9 = {
X	3,0,JAM2,
X	33,1,
X	NULL,
X	(UBYTE *)"Caveman",
X	NULL
X};
X
Xstruct Gadget Type_Gadget5 = {
X	&Type_Gadget6,
X	9,27,
X	122,10,
X	NULL,
X	RELVERIFY,
X	BOOLGADGET,
X	(APTR)&Type_Border9,
X	NULL,
X	&Type_IText9,
X	NULL,
X	NULL,
X	'C',
X	NULL
X};
X
XSHORT Type_BorderVectors10[] = {
X	0,0,
X	123,0,
X	123,11,
X	0,11,
X	0,0
X};
Xstruct Border Type_Border10 = {
X	-1,-1,
X	3,0,JAM1,
X	5,
X	Type_BorderVectors10,
X	NULL
X};
X
Xstruct IntuiText Type_IText10 = {
X	3,0,JAM2,
X	16,1,
X	NULL,
X	(UBYTE *)"Archeologist",
X	NULL
X};
X
Xstruct Gadget Type_Gadget4 = {
X	&Type_Gadget5,
X	9,14,
X	122,10,
X	NULL,
X	RELVERIFY,
X	BOOLGADGET,
X	(APTR)&Type_Border10,
X	NULL,
X	&Type_IText10,
X	NULL,
X	NULL,
X	'A',
X	NULL
X};
X
XSHORT Type_BorderVectors11[] = {
X	0,0,
X	123,0,
X	123,11,
X	0,11,
X	0,0
X};
Xstruct Border Type_Border11 = {
X	-1,-1,
X	3,0,JAM1,
X	5,
X	Type_BorderVectors11,
X	NULL
X};
X
Xstruct IntuiText Type_IText11 = {
X	3,0,JAM2,
X	36,1,
X	NULL,
X	(UBYTE *)"Knight",
X	NULL
X};
X
Xstruct Gadget Type_Gadget3 = {
X	&Type_Gadget4,
X	137,40,
X	122,10,
X	NULL,
X	RELVERIFY,
X	BOOLGADGET,
X	(APTR)&Type_Border11,
X	NULL,
X	&Type_IText11,
X	NULL,
X	NULL,
X	'K',
X	NULL
X};
X
XSHORT Type_BorderVectors12[] = {
X	0,0,
X	123,0,
X	123,11,
X	0,11,
X	0,0
X};
Xstruct Border Type_Border12 = {
X	-1,-1,
X	3,0,JAM1,
X	5,
X	Type_BorderVectors12,
X	NULL
X};
X
Xstruct IntuiText Type_IText12 = {
X	3,0,JAM2,
X	48,1,
X	NULL,
X	(UBYTE *)"Elf",
X	NULL
X};
X
Xstruct Gadget Type_Gadget2 = {
X	&Type_Gadget3,
X	137,27,
X	122,10,
X	NULL,
X	RELVERIFY,
X	BOOLGADGET,
X	(APTR)&Type_Border12,
X	NULL,
X	&Type_IText12,
X	NULL,
X	NULL,
X	'E',
X	NULL
X};
X
XSHORT Type_BorderVectors13[] = {
X	0,0,
X	123,0,
X	123,11,
X	0,11,
X	0,0
X};
Xstruct Border Type_Border13 = {
X	-1,-1,
X	3,0,JAM1,
X	5,
X	Type_BorderVectors13,
X	NULL
X};
X
Xstruct IntuiText Type_IText13 = {
X	3,0,JAM2,
X	27,1,
X	NULL,
X	(UBYTE *)"Barbarian",
X	NULL
X};
X
Xstruct Gadget Type_Gadget1 = {
X	&Type_Gadget2,
X	137,14,
X	122,10,
X	NULL,
X	RELVERIFY,
X	BOOLGADGET,
X	(APTR)&Type_Border13,
X	NULL,
X	&Type_IText13,
X	NULL,
X	NULL,
X	'B',
X	NULL
X};
X
X#define Type_GadgetList1 Type_Gadget1
X
Xstruct NewWindow Type_NewWindowStructure1 = {
X	155,24,
X	267,108,
X	0,1,
X	GADGETUP+CLOSEWINDOW+VANILLAKEY,
X	WINDOWCLOSE+ACTIVATE+NOCAREREFRESH,
X	&Type_Gadget1,
X	NULL,
X	(UBYTE *)"Pick a Character",
X	NULL,
X	NULL,
X	5,5,
X	-1,-1,
X	CUSTOMSCREEN
X};
X
X
X/* end of PowerWindows source generation */
END_OF_FILE
if test 5759 -ne `wc -c <'sys/amiga/char.c'`; then
    echo shar: \"'sys/amiga/char.c'\" unpacked with wrong size!
fi
# end of 'sys/amiga/char.c'
fi
echo shar: End of archive 10 \(of 108\).
cp /dev/null ark10isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \
21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \
41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 \
61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 \
81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 \
101 102 103 104 105 106 107 108 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 108 archives.
    echo "Now execute 'rebuild.sh'"
    rm -f ark10[0-8]isdone ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
