Path: uunet!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v16i022:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Part22/108
Message-ID: <4310@master.CNA.TEK.COM>
Date: 29 Jan 93 20:44:07 GMT
Sender: news@master.CNA.TEK.COM
Lines: 2304
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1579

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 16, Issue 22
Archive-name: nethack31/Part22
Supersedes: nethack3p9: Volume 10, Issue 46-102
Environment: Amiga, Atari, Mac, MS-DOS, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 22 (of 108)."
# Contents:  sys/amiga/wb.c2 sys/vms/vmsbuild.com
# Wrapped by billr@saab on Wed Jan 27 16:08:54 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'sys/amiga/wb.c2' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/amiga/wb.c2'\"
else
echo shar: Extracting \"'sys/amiga/wb.c2'\" \(43875 characters\)
sed "s/^X//" >'sys/amiga/wb.c2' <<'END_OF_FILE'
Xvoid menu_config()
X{
X    register struct Window *cwin;
X    int done = 0, quit;
X    long class, code, qual;
X    register struct IntuiMessage *imsg;
X    struct IntuiText *ip;
X    register struct Gadget *gd;
X    static int once = 0;
X    int txtdiff = scrn->RastPort.TxHeight - 8;
X
X    strcpy( StrPath, options[ PATH_IDX ] );
X    strcpy( StrHackdir, options[ HACKDIR_IDX ] );
X    strcpy( StrPens, options[ PENS_IDX ] );
X    strcpy( StrLevels, options[ LEVELS_IDX ] );
X    strcpy( StrSave, options[ SAVE_IDX ] );
X
X    if( !once )
X    {
X	for( gd = Conf_NewWindowStructure4.FirstGadget;
X		    gd; gd = gd->NextGadget )
X	{
X	    switch( gd->GadgetID )
X	    {
X		case GADSTRPATH:
X		    /* Look for "Path:" string */
X		    for( ip = &Conf_IntuiTextList4;
X			    ip && *ip->IText != 'P'; )
X			ip = ip->NextText;
X		    gd->TopEdge += txtdiff;
X		    gd->Height += txtdiff;
X		    SetBorder( gd, -1 );
X		    break;
X		case GADSTRHACKDIR:
X		    /* Look for "Hackdir:" string */
X		    for( ip = &Conf_IntuiTextList4;
X			    ip && *ip->IText != 'H'; )
X			ip = ip->NextText;
X		    if( ip )
X			ip->TopEdge += txtdiff;
X		    gd->TopEdge += txtdiff*2;
X		    gd->Height += txtdiff;
X		    SetBorder( gd, -1 );
X		    break;
X		case GADSTRPENS:
X		    /* Look for "Pens:" string */
X		    for( ip = &Conf_IntuiTextList4; ip &&
X			!(*ip->IText == 'P' && ip->IText[1] == 'e'); )
X		    {
X			ip = ip->NextText;
X		    }
X		    if( ip )
X			ip->TopEdge += txtdiff*2;
X		    gd->TopEdge += txtdiff*3;
X		    gd->Height += txtdiff;
X		    SetBorder( gd, -1 );
X		    break;
X		case GADSTRLEVELS:
X		    /* Look for "Levels:" string */
X		    for( ip = &Conf_IntuiTextList4; ip && *ip->IText != 'L'; )
X			ip = ip->NextText;
X		    if( ip )
X			ip->TopEdge += txtdiff*3;
X		    gd->TopEdge += txtdiff*4;
X		    gd->Height += txtdiff;
X		    SetBorder( gd, -1 );
X		    break;
X		case GADSTRSAVE:
X		    /* Look for "Save Dir:" string */
X		    for( ip = &Conf_IntuiTextList4; ip && *ip->IText != 'S'; )
X			ip = ip->NextText;
X		    if( ip )
X			ip->TopEdge += txtdiff*4;
X		    gd->TopEdge += txtdiff*5;
X		    gd->Height += txtdiff;
X		    SetBorder( gd, -1 );
X		    break;
X		case GADCONFLOAD:
X		case GADCONFSAVE:
X		    gd->TopEdge += txtdiff*6;
X		    gd->Height += txtdiff;
X		    SetBorder( gd, -1 );
X		    break;
X		case GADCONFNAME:
X		    for( ip = &Conf_IntuiTextList4; ip && *ip->IText != 'C'; )
X			ip = ip->NextText;
X		    if( ip )
X			ip->TopEdge += txtdiff*6;
X		    gd->TopEdge += txtdiff*7;
X		    gd->Height += txtdiff;
X		    SetBorder( gd, -1 );
X		    break;
X
X		default:
X		    break;
X	    }
X	}
X	Conf_NewWindowStructure4.Height += txtdiff*8;
X	if( Conf_NewWindowStructure4.TopEdge +
X	    Conf_NewWindowStructure4.Height > scrn->Height )
X	{
X	    Conf_NewWindowStructure4.TopEdge -=
X		( Conf_NewWindowStructure4.TopEdge +
X		Conf_NewWindowStructure4.Height ) - scrn->Height + 1;
X	    if( Conf_NewWindowStructure4.TopEdge < 0 )
X	    {
X		Conf_NewWindowStructure4.TopEdge = 0;
X		Conf_NewWindowStructure4.Height = scrn->Height - 1;
X	    }
X	}
X	once = 1;
X    }
X
X    Conf_NewWindowStructure4.Screen = scrn;
X    if( ( cwin = MyOpenWindow( &Conf_NewWindowStructure4 ) ) == NULL )
X    {
X	errmsg( FLASH, "Can't create requester window" );
X	return;
X    }
X
X    PrintIText( cwin->RPort, &Conf_IntuiTextList4, 0, txtdiff );
X    while( !done )
X    {
X	WaitPort( cwin->UserPort );
X	while( ( imsg = (void *) GetMsg( cwin->UserPort ) ) != NULL )
X	{
X	    class = imsg->Class;
X	    code = imsg->Code;
X	    qual = imsg->Qualifier;
X	    gd = (struct Gadget *)imsg->IAddress;
X
X	    ReplyMsg( (struct Message *)imsg );
X
X	    switch( class )
X	    {
X		case VANILLAKEY:
X		    if( code == '\33' || (code == 'b' && (qual&AMIGALEFT)))
X		    {
X			done = 0;
X			quit = 1;
X		    }
X		    break;
X
X		case ACTIVEWINDOW:
X		    if( gd = FindGadget( cwin, NULL, GADCONFNAME ) )
X			ActivateGadget( gd, cwin, NULL );
X		    break;
X
X		case CLOSEWINDOW:
X		    done = 1;
X		    quit = 0;
X		    break;
X
X		case GADGETUP:
X		    switch( gd->GadgetID )
X		    {
X			case GADSTRPATH:
X			    if( gd = FindGadget( cwin, NULL,GADSTRHACKDIR) )
X				ActivateGadget( gd, cwin, NULL );
X			    break;
X			case GADSTRHACKDIR:
X			    if( gd = FindGadget( cwin, NULL,GADSTRPENS) )
X				ActivateGadget( gd, cwin, NULL );
X			    break;
X			case GADSTRPENS:
X			    if( gd = FindGadget( cwin, NULL,GADSTRLEVELS) )
X				ActivateGadget( gd, cwin, NULL );
X			    break;
X			case GADSTRLEVELS:
X			    if( gd = FindGadget( cwin, NULL, GADSTRSAVE ) )
X				ActivateGadget( gd, cwin, NULL );
X			    break;
X			case GADSTRSAVE:
X			    if( gd = FindGadget( cwin, NULL, GADCONFNAME ) )
X				ActivateGadget( gd, cwin, NULL );
X			    break;
X
X			case GADCONFLOAD: case GADCONFNAME:
X			    ReadConfig( );
X			    strcpy( StrPath, options[ PATH_IDX ] );
X			    strcpy( StrHackdir, options[ HACKDIR_IDX ] );
X			    strcpy( StrPens, options[ PENS_IDX ] );
X			    strcpy( StrLevels, options[ LEVELS_IDX ] );
X			    strcpy( StrSave, options[ SAVE_IDX ] );
X			    RefreshGList( cwin->FirstGadget, cwin, NULL, -1 );
X			    break;
X
X			case GADCONFSAVE:
X			    errmsg( FLASH, "Save not implemented" );
X			    break;
X
X			default:
X			    break;
X		    }
X		    break;
X	    }
X	}
X    }
X
X    setoneopt( PATH_IDX, StrPath );
X    PutOptions( curopts );
X    setoneopt( HACKDIR_IDX, StrHackdir );
X    setoneopt( PENS_IDX, StrPens );
X    setoneopt( LEVELS_IDX, StrLevels );
X    setoneopt( SAVE_IDX, StrSave );
X
X    SafeCloseWindow( cwin );
X
X    /* Display icons in possibly new save directory */
X
X    MapGadgets( R_DISK, 1 );
X}
X
Xvoid menu_editdef( gametype )
X    int gametype;
X{
X    register struct Window *cwin;
X    int done = 0;
X    USHORT mcode;
X    long class, qual, code;
X    register struct IntuiMessage *imsg;
X    register struct Gadget *gd;
X    char buf[ 100 ];
X    struct IntuiText *ip;
X    static int once = 0;
X    int txtdiff = scrn->RastPort.TxHeight - 8;
X    register GPTR gptr;
X
X    /* If gametype indicates an INFO request... */
X    if( gametype == GAME_FROM_INFO )
X    {
X	register char *t;
X
X	if( ( gptr = NeedGame() ) == NULL )
X	{
X	    errmsg( FLASH, "No Game selected to edit options for" );
X	    return;
X	}
X
X	strcpy( DefOutFile, gptr->name );
X	if( ( t = strrchr( DefOutFile, '.' ) ) &&
X		stricmp( t, ".sav" ) == 0 )
X	{
X	    *t = 0;
X	}
X	LoadDefaults( DefOutFile );
X    }
X    else /* if( gametype == GAME_FROM_DEFAULT ) */
X    {
X	/* Find the newgame gadget... */
X
X	for( gptr = windowgads; gptr; gptr = gptr->nextwgad )
X	{
X	    if( gptr->dobj->do_Gadget.GadgetID == GADNEWGAME )
X		break;
X	}
X
X	if( !gptr )
X	{
X	    errmsg( FLASH, "Can't find NewGame information" );
X	    return;
X	}
X
X	strcpy( DefOutFile, defgname );
X	LoadDefaults( DefOutFile );
X    }
X
X    /* Copy the defgame.* date into the Defs_ window gadgets */
X    CopyDefs2Gad();
X
X    /* Do one time window setup and initialization */
X
X    if( !once )
X    {
X	/* Rearrange the gadgets based on fonts text height */
X
X	for( gd = Defs_NewWindowStructure11.FirstGadget;
X		gd; gd = gd->NextGadget )
X	{
X	    if( gd->GadgetID != 0 )
X	    {
X		gd->TopEdge += txtdiff;
X		gd->Height += txtdiff;
X		switch( gd->GadgetID )
X		{
X		    case GADOUTFILE:
X			gd->TopEdge += txtdiff;
X			break;
X		    case GADDEFLOAD:
X		    case GADDEFSAVE:
X		    case GADEDOPTIONS:
X			gd->TopEdge += txtdiff * 3;
X			break;
X		    default:
X			if( ( gd->Flags & GADGHIGHBITS ) == GADGHNONE )
X			    gd->TopEdge += txtdiff * 2;
X			break;
X		}
X		SetBorder( gd, -1 );
X	    }
X	}
X
X	/* Move the text down as appropriate */
X
X	for( ip = &Defs_IntuiTextList11; ip; ip = ip->NextText )
X	{
X	    if( *ip->IText == 'C' )
X		ip->TopEdge += txtdiff * 2;
X	    else if( *ip->IText == 'O' )
X		ip->TopEdge += txtdiff;
X	}
X
X	/* Adjust the height of the window */
X	Defs_NewWindowStructure11.Height += txtdiff * 5;
X	++once;
X    }
X
X    Defs_NewWindowStructure11.Screen = scrn;
X
X    /* Set Correct title */
X    if( gametype == GAME_FROM_DEFAULT )
X	Defs_NewWindowStructure11.Title = "Edit Default Game Definition";
X    else if( gametype == GAME_FROM_INFO )
X	Defs_NewWindowStructure11.Title = "Edit Game Definition";
X    else
X    {
X	errmsg( FLASH, "Can't edit game of type %d", gametype );
X	return;
X    }
X
X    if( ( cwin = MyOpenWindow( &Defs_NewWindowStructure11 ) ) == NULL )
X    {
X	errmsg( FLASH, "Can't create requester window" );
X	return;
X    }
X
X    PrintIText( cwin->RPort, &Defs_IntuiTextList11, 0, txtdiff );
X    UpdateTypes( cwin );
X
X    /* Do Menu Layouts Based on FontHeight */
X    SetUpMenus( &Defs_MenuList11, scrn );
X    SetMenuStrip( cwin, &Defs_MenuList11 );
X
X    /* Process messages */
X    while( !done )
X    {
X	WaitPort( cwin->UserPort );
X	while( ( imsg = (void *) GetMsg( cwin->UserPort ) ) != NULL )
X	{
X	    mcode = imsg->Code;
X	    gd = (struct Gadget *)imsg->IAddress;
X	    qual = imsg->Qualifier;
X	    class = imsg->Class;
X	    code = imsg->Code;
X
X	    ReplyMsg( (struct Message *)imsg );
X
X	    switch( class )
X	    {
X		case VANILLAKEY:
X		    /* Escape or LEFT_AMIGA-b aborts the requester... */
X		    if( code == '\33' || (code == 'b' && (qual&AMIGALEFT)))
X		    {
X			done = 1;
X		    }
X		    break;
X
X		case ACTIVEWINDOW:
X		    if( gd = FindGadget( cwin, NULL, GADCHARNAME ) )
X			ActivateGadget( gd, cwin, NULL );
X		    break;
X
X		case MENUPICK:
X		    while( mcode != MENUNULL )
X		    {
X			switch(MENUNUM(mcode))
X			{
X			    case PLAYERMENU:
X				defgame.pltype = ITEMNUM( mcode );
X				UpdateTypes( cwin );
X				break;
X			}
X			mcode = ((struct MenuItem *)
X			    ItemAddress( &Defs_MenuList11,
X			    mcode))->NextSelect;
X		    }
X		    break;
X
X		case CLOSEWINDOW:
X		    CopyGad2Defs( );
X		    done = 1;
X		    break;
X
X		case GADGETUP:
X		    switch( gd->GadgetID )
X		    {
X			case GADEDOPTIONS:
X			    CopyOptions( curopts, gptr );
X			    if( EditOptions( curopts ) )
X				SetOptions( curopts, gptr );
X			    break;
X
X			case GADDEFSAVE:
X			    CopyGad2Defs( );
X			    sprintf( buf,
X				"Game definition saved in: %s", DefOutFile );
X			    errmsg( NO_FLASH, buf );
X			    SaveDefaults( DefOutFile );
X			    break;
X
X			case GADDEFLOAD:
X			    LoadDefaults( DefPlayerName );
X			    strcpy( DefOutFile, DefPlayerName );
X			    CopyDefs2Gad();
X			    UpdateTypes( cwin );
X			    sprintf( buf, "Game definition loaded from: %s",
X				DefPlayerName );
X			    errmsg( NO_FLASH, buf );
X			    break;
X
X			default:
X			    break;
X		    }
X		    break;
X	    }
X	}
X    }
X
X    SafeCloseWindow( cwin );
X}
X
Xvoid do_gadgetup( imsg )
X    register struct IntuiMessage *imsg;
X{
X    register struct Gadget *gd;
X    register unsigned long hid;
X    int ncol, pot;
X
X    gd = (struct Gadget *) imsg->IAddress;
X
X    switch( gd->GadgetID )
X    {
X	case GADSCROLL:
X	    hid = max( cols - vcols, 0 );
X	    pot = ( ( struct PropInfo * ) gd->SpecialInfo )->HorizPot;
X	    ncol = (hid * pot) / MAXPOT;
X	    if( ncol != curcol )
X	    {
X		curcol = ncol;
X		MapGadgets( R_SCROLL, 0 ); /* redisplay the icons */
X	    }
X	    break;
X    }
X}
X
Xvoid do_buttons( imsg )
X    register struct IntuiMessage *imsg;
X{
X    if( imsg->Code == SELECTDOWN || imsg->Code == SELECTUP )
X    {
X	if( lastgaddown )
X	{
X	    SetGadgetUP( &lastgaddown->dobj->do_Gadget );
X	    lastgaddown->secs = 0;
X	    lastgaddown->mics = 0;
X	}
X	lastgaddown = NULL;
X	ChgGameItems( &MenuList1, 0 );
X    }
X}
X
Xvoid do_gadgetdown( imsg )
X    register struct IntuiMessage *imsg;
X{
X    register GPTR gptr;
X    register struct Gadget *gd;
X
X    gd = (struct Gadget *) imsg->IAddress;
X
X    /* Don't do anything for these gadgets */
X
X    if( gd->GadgetID < GADNEWGAME )
X    {
X	return;
X    }
X
X    /* Check just to make sure we got it */
X
X    for( gptr = windowgads; gptr &&
X	gptr->dobj->do_Gadget.GadgetID != gd->GadgetID; )
X    {
X	gptr = gptr->nextwgad;
X    }
X
X    if( !gptr )
X    {
X	errmsg( FLASH, "Bad GadgetID for GadgetDOWN" );
X	return;
X    }
X
X    /* Fix the gadget images */
X
X    if( lastgaddown && &lastgaddown->dobj->do_Gadget != gd )
X    {
X	SetGadgetUP( &lastgaddown->dobj->do_Gadget );
X	gptr->secs = 0;
X	gptr->mics = 0;
X    }
X    SetGadgetDOWN( &((lastgaddown = gptr)->dobj->do_Gadget) );
X
X    /* Only allow game gadgets to be manipulated */
X
X    if( lastgaddown->dobj->do_Gadget.GadgetID == GADNEWGAME )
X	ChgNewGameItems( &MenuList1, 1 );
X    else
X	ChgGameItems( &MenuList1, 1 );
X
X    /* Check if this gadget has been double clicked */
X
X    if( DoubleClick( gptr->secs, gptr->mics, imsg->Seconds, imsg->Micros ) )
X    {
X	run_game( gptr );
X	gptr->secs = 0;
X	gptr->mics = 0;
X	return;
X    }
X
X    gptr->secs = imsg->Seconds;
X    gptr->mics = imsg->Micros;
X}
X
Xvoid menu_setopt()
X{
X    register GPTR gptr;
X
X    if( ( gptr = NeedGame() ) == NULL )
X	return;
X    CopyOptions( curopts, gptr );
X    if( EditOptions( curopts ) )
X	SetOptions( curopts, gptr );
X}
X
Xvoid menu_info()
X{
X    register struct IntuiMessage *imsg;
X    struct IntuiText *ip;
X    char *t;
X    register GPTR gptr;
X    register struct Gadget *gd;
X    register struct FileInfoBlock *finfo;
X    register struct Window *cwin;
X    register int i;
X    int done = 0, quit;
X    char **sp;
X    static int once = 0;
X    register BPTR lock;
X    long code, class, qual;
X    static struct IntuiText itext[ 4 ];
X    char commentstr[ 100 ], namestr[ 50 ];
X    int txtdiff = scrn->RastPort.TxHeight - 8;
X
X    if( ( gptr = NeedGame() ) == NULL )
X	return;
X
X    if( ( lock = Lock( GameName( gptr, NULL ), ACCESS_READ ) ) == NULL )
X    {
X	/* Can't get lock, reload and return */
X
X	errmsg( FLASH, "Can't Lock game save file: %s",
X		GameName( gptr, NULL ) );
X	MapGadgets( R_DISK, 1 );
X	return;
X    }
X
X    finfo = (struct FileInfoBlock *)xmalloc(sizeof(struct FileInfoBlock));
X    Examine( lock, finfo );
X    UnLock( lock );
X    strncpy( commentstr, finfo->fib_Comment, sizeof( finfo->fib_Comment ) );
X    commentstr[ sizeof( finfo->fib_Comment ) ] = 0;
X    free( finfo );
X
X    for( i = 0; i < 4; ++i )
X    {
X	itext[ i ].FrontPen = C_BLACK;
X	itext[ i ].BackPen = C_GREY;
X	itext[ i ].DrawMode = JAM2;
X	itext[ i ].TopEdge = 2;
X	itext[ i ].LeftEdge = 4;
X    }
X    ReallocTools( gptr, 0 );
X    sp = gptr->dobj->do_ToolTypes;
X
X    if( !once )
X    {
X	Info_Comment.TopEdge += txtdiff*2;
X	Info_Class.TopEdge += txtdiff;
X	Info_NewWindowStructure6.Height += txtdiff * 6;
X	for( gd = Info_NewWindowStructure6.FirstGadget;
X		gd; gd = gd->NextGadget )
X	{
X	    gd->TopEdge += txtdiff;
X	    if( gd->GadgetID != GADTOOLUP && gd->GadgetID != GADTOOLDOWN )
X		gd->Height += txtdiff;
X	    switch( gd->GadgetID )
X	    {
X		case 0:
X		    break;
X
X		case GADTOOLTYPES:
X		    gd->TopEdge += txtdiff*4;
X		    SetBorder( gd, -1 );
X		    break;
X
X		case GADDELTOOL:
X		    gd->TopEdge += txtdiff*3;
X		    SetBorder( gd, -1 );
X		    break;
X
X		case GADADDTOOL:
X		    gd->TopEdge += txtdiff*3;
X		    SetBorder( gd, -1 );
X		    break;
X
X		case GADTOOLUP:
X		    gd->TopEdge += txtdiff*4;
X		    gd->Flags &= ~GADGHIGHBITS;
X		    gd->Flags |= GADGIMAGE|GADGHIMAGE;
X		    gd->GadgetRender = (APTR)&up_selectimage;
X		    gd->SelectRender = (APTR)&up_renderimage;
X		    break;
X
X		case GADTOOLDOWN:
X		    gd->TopEdge += txtdiff*5;
X		    gd->Flags &= ~GADGHIGHBITS;
X		    gd->Flags |= GADGIMAGE|GADGHIMAGE;
X		    gd->GadgetRender = (APTR)&down_selectimage;
X		    gd->SelectRender = (APTR)&down_renderimage;
X		    break;
X
X		default:
X		    SetBorder( gd, -1 );
X	    }
X	}
X	for( ip = &Info_IntuiTextList6; ip; ip = ip->NextText )
X	{
X	    if( *ip->IText == 'C' )
X	    {
X		if( ip->IText[1] == 'o' )
X		    ip->TopEdge += 2*txtdiff;
X		else
X		    ip->TopEdge += txtdiff;
X	    }
X	    else if( *ip->IText == 'T' )
X		ip->TopEdge += 4*txtdiff;
X	}
X	++once;
X    }
X
X    gd = &Info_EditDef;
X    if( access( GameName( gptr, gptr->name ), 1 ) == 0 )
X	gd->Flags |= GADGDISABLED;
X    else
X	gd->Flags &= ~GADGDISABLED;
X
X    /* Put in the comment */
X
X    Info_Comment.GadgetText = &itext[ 0 ];
X    itext[ 0 ].IText = commentstr;
X
X    /* The players name */
X
X    Info_Player.GadgetText = &itext[ 1 ];
X    strncpy( namestr, ToolsEntry( gptr, "NAME" ), sizeof( namestr ) );
X    namestr[ sizeof( namestr ) - 1 ] = 0;
X    if( *namestr == 0 )
X    {
X	strncpy( namestr, gptr->name, sizeof( namestr ) );
X	namestr[ sizeof( namestr ) - 1 ] = 0;
X    }
X    if( ( t = strrchr( namestr, '.' ) ) && stricmp( t, ".sav" ) == 0 )
X	*t = 0;
X    itext[ 1 ].IText = namestr;
X
X    /* The character class of the player */
X
X    Info_Class.GadgetText = &itext[ 2 ];
X    itext[ 2 ].IText = ToolsEntry( gptr, "CHARACTER" );
X
X    /* If there are ToolTypes entries, put the first one into the gadget */
X
X    if( sp && *sp )
X	strcpy( StrTools, *sp );
X
X    if( IsEditEntry( StrTools, gptr ) )
X	Info_ToolTypes.Flags &= ~GADGDISABLED;
X    else
X	Info_ToolTypes.Flags |= GADGDISABLED;
X
X    Info_NewWindowStructure6.Screen = scrn;
X    if( ( cwin = MyOpenWindow( &Info_NewWindowStructure6 ) ) == NULL )
X    {
X	errmsg( FLASH, "Can't create info window" );
X	return;
X    }
X    PrintIText( cwin->RPort, &Info_IntuiTextList6, 0, txtdiff );
X
X    while( !done )
X    {
X	WaitPort( cwin->UserPort );
X	while( ( imsg = (void *) GetMsg( cwin->UserPort ) ) != NULL )
X	{
X	    class = imsg->Class;
X	    code = imsg->Code;
X	    qual = imsg->Qualifier;
X	    gd = (struct Gadget *)imsg->IAddress;
X
X	    ReplyMsg( (struct Message *)imsg );
X
X	    switch( class )
X	    {
X		case VANILLAKEY:
X		    if( code == '\33' || (code == 'b' && (qual&AMIGALEFT)) )
X		    {
X			done = 1;
X			quit = 0;
X		    }
X		    break;
X
X		case CLOSEWINDOW:
X		    if( sp )
X		    {
X			if( *sp )
X			    free( *sp );
X			*sp = strdup( StrTools );
X		    }
X		    done = 1;
X		    quit = 0;
X		    break;
X
X		case GADGETUP:
X		    switch( gd->GadgetID )
X		    {
X			case GADEDDEF:
X			    /* Put the game values into the defaults */
X
X			    Game2Defs( gptr );
X
X			    /* Put the options into the options array */
X
X			    CopyOptions( curopts, gptr );
X
X			    /* Edit the defaults */
X
X			    menu_editdef( GAME_FROM_INFO );
X
X			    /* Put the options back in */
X
X			    SetOptions( curopts, gptr );
X
X			    /* Move defaults to game */
X
X			    SetToolLine( gptr, "NAME", defgame.plname );
X			    SetToolLine( gptr, "CHARACTER",
X				defgame.pltype ?
X				players[ defgame.pltype ] : "" );
X			    itext[ 2 ].IText =
X				ToolsEntry( gptr, "CHARACTER" );
X			    strncpy( namestr, ToolsEntry( gptr, "NAME" ),
X				sizeof( namestr ) );
X			    namestr[ sizeof( namestr ) - 1 ] = 0;
X			    if( *namestr == 0 )
X			    {
X				strncpy( namestr, gptr->name, sizeof(namestr) );
X				namestr[ sizeof( namestr ) - 1 ] = 0;
X			    }
X			    if( ( t = strrchr( namestr, '.' ) ) &&
X				stricmp( t, ".sav" ) == 0 )
X			    {
X				*t = 0;
X			    }
X			    itext[ 1 ].IText = namestr;
X
X			    /* Make sure that the correct ToolTypes line
X			     * is displayed in the gadget.
X			     */
X
X			    strcpy( StrTools, *sp );
X			    UpdateInfoWin( cwin );
X			    break;
X
X			case GADADDTOOL:
X			    ReallocTools( gptr, 1 );
X			    sp = gptr->dobj->do_ToolTypes;
X			    for( i = 0; sp[ i ]; ++i )
X				;
X			    sp[i] = strdup( "" );
X			    sp[i+1] = NULL;
X			    itext[ 2 ].IText =
X				ToolsEntry( gptr, "CHARACTER" );
X			    *StrTools = 0;
X			    UpdateInfoWin( cwin );
X			    sp += i;
X			    break;
X
X			case GADDELTOOL:
X			    while( *sp = sp[1] )
X				++sp;
X			    sp = gptr->dobj->do_ToolTypes;
X			    strcpy( StrTools, *sp ? *sp : "" );
X			    UpdateInfoWin( cwin );
X			    break;
X
X			case GADTOOLTYPES:
X			    if( sp && *sp && CheckAndCopy( StrTools, *sp ) )
X			    {
X				if( *sp )
X				    free( *sp );
X				*sp = strdup( StrTools );
X			    }
X			    break;
X
X			case GADTOOLDOWN:
X			    if( sp && *sp && CheckAndCopy( StrTools, *sp ) )
X			    {
X				if( *sp )
X				    free( *sp );
X				*sp = strdup( StrTools );
X			    }
X			    if( sp != NULL && sp[1] != NULL )
X			    {
X				++sp;
X				strcpy( StrTools, *sp );
X				if( IsEditEntry( StrTools, gptr ) )
X				    Info_ToolTypes.Flags &= ~GADGDISABLED;
X				else
X				    Info_ToolTypes.Flags |= GADGDISABLED;
X			    }
X			    else
X			    {
X				if( sp && *sp )
X				    strcpy( StrTools, *sp );
X				DisplayBeep( NULL );
X			    }
X			    break;
X
X			case GADTOOLUP:
X			    if( sp && *sp && CheckAndCopy( StrTools, *sp ) )
X			    {
X				if( *sp )
X				    free( *sp );
X				*sp = strdup( StrTools );
X			    }
X			    if( sp && sp > gptr->dobj->do_ToolTypes )
X			    {
X				--sp;
X				strcpy( StrTools, *sp );
X				if( IsEditEntry( StrTools, gptr ) )
X				    Info_ToolTypes.Flags &= ~GADGDISABLED;
X				else
X				    Info_ToolTypes.Flags |= GADGDISABLED;
X			    }
X			    else
X			    {
X				DisplayBeep( NULL );
X			    }
X			    break;
X		    }
X		    RefreshGList( &Info_ToolTypes, cwin, NULL, 1 );
X		    break;
X	    }
X	}
X    }
X
X    SafeCloseWindow( cwin );
X}
X
Xstatic void
XUpdateInfoWin( cwin )
X    struct Window *cwin;
X{
X    SetAPen( cwin->RPort, 0 );
X    SetBPen( cwin->RPort, 0 );
X    SetDrMd( cwin->RPort, JAM2 );
X    RectFill( cwin->RPort,
X	Info_Class.LeftEdge,
X	Info_Class.TopEdge,
X	Info_Class.LeftEdge + Info_Class.Width-1,
X	Info_Class.TopEdge + Info_Class.Height-1 );
X    RectFill( cwin->RPort,
X	Info_Player.LeftEdge,
X	Info_Player.TopEdge,
X	Info_Player.LeftEdge + Info_Player.Width-1,
X	Info_Player.TopEdge + Info_Player.Height-1 );
X    RefreshGList( cwin->FirstGadget, cwin, NULL, -1 );
X}
X
Xvoid
Xerrmsg(int flash, char *str, ...)
X{
X    static char buf[ 200 ];
X    int wid;
X    va_list vp;
X
X    va_start( vp, str );
X
X    if( !win || !wbopen )
X    {
X	vprintf( str, vp );
X	va_end( vp );
X	return;
X    }
X    errup = 1;
X    wid = ( win->Width + Message.LeftEdge - win->BorderRight - 3 ) /
X		    win->RPort->TxWidth;
X    vsprintf( buf, str, vp );
X    va_end( vp );
X
X    SetAPen( win->RPort, 0 );
X    SetBPen( win->RPort, 0 );
X    SetDrMd( win->RPort, JAM2 );
X    RectFill( win->RPort, Message.LeftEdge, Message.TopEdge,
X	win->Width + Message.Width,
X	Message.TopEdge + Message.Height - 1 );
X
X    Message.GadgetText->IText = buf;
X    RefreshGList( &Message, win, 0, 1 );
X
X    if( flash == FLASH )
X	DisplayBeep( scrn );
X}
X
X/*
X * Issue an error message to the users window because it can not be done
X * any other way.
X */
X
Xvoid error( str )
X    register char *str;
X{
X    char s[ 50 ];
X    if( scrn ) ScreenToBack( scrn );
X    Delay( 10 );
X    fprintf( stderr, "%s\n", str );
X    fprintf( stderr, "Hit Return: " );
X    fflush( stderr );
X    gets( s );
X    if( scrn ) ScreenToFront( scrn );
X}
X
X/*
X * Make the gadget deselected
X */
X
Xvoid SetGadgetUP( gad )
X    register struct Gadget *gad;
X{
X    RemoveGadget( win, gad );
X    gad->Flags &= ~(SELECTED|GADGHIGHBITS);
X    gad->Flags |= GADGHIMAGE|GADGIMAGE;
X    gad->Activation |= TOGGLESELECT;
X    AddGadget( win, gad, 0 );
X    RefreshGList( gad, win, NULL, 1 );
X    RemoveGadget( win, gad );
X    gad->Flags &= ~(GADGHIGHBITS);
X    gad->Flags |= GADGHNONE;
X    gad->Activation &= ~TOGGLESELECT;
X    AddGadget( win, gad, 0 );
X}
X
X/*
X * Make the gadget selected
X */
X
Xvoid SetGadgetDOWN( gad )
X    register struct Gadget *gad;
X{
X    RemoveGadget( win, gad );
X    gad->Flags &= ~GADGHIGHBITS;
X    gad->Flags |= GADGHIMAGE|GADGIMAGE|SELECTED;
X    gad->Activation |= TOGGLESELECT;
X    AddGadget( win, gad, 0 );
X    RefreshGList( gad, win, NULL, 1 );
X    RemoveGadget( win, gad );
X    gad->Flags &= ~(GADGHIGHBITS);
X    gad->Flags |= GADGHNONE;
X    gad->Activation &= ~TOGGLESELECT;
X    AddGadget( win, gad, 0 );
X}
X
X/*
X * Generate a requester for a string value.
X */
X
Xint StrRequest( prompt, buff, val )
X    char *prompt, *buff, *val;
X{
X    struct Window *cwin;
X    struct IntuiMessage *imsg;
X    int done = 0, notcan = 1;
X    long class, code, qual;
X    struct Gadget *gd;
X    static int once = 0;
X    int txtdiff = scrn->RastPort.TxHeight - 8;
X
X    *StrString = 0;
X    if( val )
X	strcpy( StrString, val );
X    Str_NewWindowStructure5.Title = prompt;
X
X    if( !once )
X    {
X	for( gd = Str_NewWindowStructure5.FirstGadget;
X		    gd; gd = gd->NextGadget )
X	{
X	    if( gd->GadgetID != 0 )
X	    {
X		gd->TopEdge += txtdiff;
X		gd->Height += txtdiff;
X		SetBorder( gd, -1 );
X	    }
X	}
X	++once;
X	Str_NewWindowStructure5.Height += txtdiff * 2;
X    }
X
X    Str_NewWindowStructure5.Screen = scrn;
X    if( ( cwin = MyOpenWindow( &Str_NewWindowStructure5 ) ) == NULL )
X    {
X	errmsg( FLASH, "Can't create requester window" );
X	return( 0 );
X    }
X
X    while( !done )
X    {
X	WaitPort( cwin->UserPort );
X	while( ( imsg = (void *) GetMsg( cwin->UserPort ) ) != NULL )
X	{
X	    class = imsg->Class;
X	    code = imsg->Code;
X	    qual = imsg->Qualifier;
X	    gd = (struct Gadget *) imsg->IAddress;
X	    ReplyMsg( (struct Message *) imsg );
X	    switch( class )
X	    {
X		case ACTIVEWINDOW:
X		    ActivateGadget( &Str_String, cwin, NULL );
X		    break;
X
X		case GADGETUP:
X		    switch( gd->GadgetID )
X		    {
X			case GADSTRCANCEL:
X			    notcan = 0;
X			    done = 1;
X			    break;
X
X			default:
X			    strcpy( buff, StrString );
X			    done = 1;
X			    break;
X		    }
X		    break;
X
X		case CLOSEWINDOW:
X		    strcpy( buff, StrString );
X		    done = 1;
X		    break;
X
X		case VANILLAKEY:
X		    if( code == '\33' || code == 'b' && (qual&AMIGALEFT) )
X		    {
X			done = 1;
X			notcan = 0;
X		    }
X		    break;
X	    }
X	}
X    }
X
X    SafeCloseWindow( cwin );
X    return( notcan );
X}
X
X/*
X * Load a defaults file into global structures
X */
X
Xvoid LoadDefaults( player )
X    char *player;
X{
X    FILE *fp;
X    int i;
X    char fname[ 100 ];
X    char buf[ 200 ];
X	char *t;
X
X    sprintf( fname, "%s.def", player );
X
X    if( ( fp = fopen( fname, "r" ) ) == NULL )
X    {
X	errmsg( FLASH,
X	    "Can't open defaults, %s, in current directory", fname );
X	return;
X    }
X
X    while( fgets( buf, sizeof( buf ), fp ) != NULL )
X    {
X	if( *buf == '#' )
X	    continue;
X
X	if( ( t = strchr( buf, '\n' ) ) != NULL )
X	    *t = 0;
X	if( strnicmp( "PLAYER=", buf, 7 ) == 0 )
X	{
X	    if( defgame.plname )
X		free( defgame.plname );
X	    defgame.plname = strdup( buf + 7 );
X	}
X	else if( strnicmp( "PLAYERTYPE=", buf, 11 ) == 0 )
X	{
X	    for( i = 0; players[ i ]; ++i )
X	    {
X		if( strnicmp( &buf[11], players[ i ], 1 ) == 0 )
X		    break;
X	    }
X
X	    if( players[ i ] )
X		defgame.pltype = i;
X	    else
X		defgame.pltype = 0;
X	}
X	else if( strnicmp( "OPTIONS=", buf, 8 ) == 0 )
X	{
X	    errmsg( FLASH, "OPTIONS set by game configuration" );
X	    setoneopt( OPTIONS_IDX, buf+8 );
X	    defgame.options = strdup( buf + 8 );
X	}
X	else
X	    errmsg( FLASH, "Invalid line in defaults file" );
X    }
X    fclose( fp );
X}
X
X/*
X * Create a defaults file my the name given with all of the global
X * information currently set.
X */
X
Xvoid SaveDefaults( player )
X    char *player;
X{
X    FILE *fp;
X    char fname[ 100 ];
X    int err;
X
X    sprintf( fname, "%s.def", player );
X
X    if( ( fp = fopen( fname, "w" ) ) == NULL )
X    {
X	errmsg( FLASH, "Can't open defaults file: %s", fname );
X	return;
X    }
X
X    err = fprintf( fp, "PLAYER=%s\n", defgame.plname );
X    if( defgame.pltype )
X	err |= fprintf( fp, "PLAYERTYPE=%s\n", players[ defgame.pltype ] );
X    else
X	err |= fprintf( fp, "PLAYERTYPE=<RANDOM>\n" );
X
X    /* Get the options. */
X    PutOptions( curopts );
X
X    /* Put them in too */
X    err |= fprintf( fp, "OPTIONS=%s\n", options[ OPTIONS_IDX ] );
X    err |= fclose( fp );
X
X    if( err == EOF )
X	errmsg( FLASH, "Error writing out defaults for: %s", fname );
X}
X
X/*
X * Copy the defgame structure values into the Defs windows gadgets
X */
X
Xvoid CopyDefs2Gad()
X{
X    if( defgame.plname )
X	strcpy( DefPlayerName, defgame.plname );
X    else
X	*DefPlayerName = 0;
X
X    CheckOnly( &Defs_MenuList11, 0, defgame.pltype );
X
X    /* If there are default options fill them in, else reset
X     * to the real defaults.
X     */
X    if( defgame.options )
X	CopyOptionStr( curopts, defgame.options );
X    else
X	ZapOptions( curopts );
X}
X
X/*
X * Copy the Defs window gadgets into the defgame structure
X */
X
Xvoid CopyGad2Defs( )
X{
X    if( defgame.plname )
X	free( defgame.plname );
X    defgame.plname = strdup( DefPlayerName );
X
X    defgame.pltype = FindChecked( &Defs_MenuList11, 0 );
X}
X
X/*
X * Make sure that the correct character type is checked
X */
X
Xvoid UpdateTypes( cwin )
X    register struct Window *cwin;
X{
X    register struct RastPort *rp = cwin->RPort;
X
X    SetAPen( rp, 0 );
X    SetBPen( rp, 0 );
X    SetDrMd( rp, JAM2 );
X    RectFill( cwin->RPort,
X	Defs_PlayerType.LeftEdge+1,
X	Defs_PlayerType.TopEdge+1,
X	Defs_PlayerType.LeftEdge+Defs_PlayerType.Width-1,
X	Defs_PlayerType.TopEdge+Defs_PlayerType.Height-1 );
X
X    Defs_PlayerType.GadgetText->IText = players[ defgame.pltype ];
X    RefreshGList( &Defs_PlayerType, cwin, NULL, 1 );
X}
X
X/*
X * Ask the user if they really want to do something.
X */
X
XAsk( quest )
X    char *quest;
X{
X    register struct Window *qwin;
X    register struct Gadget *gd;
X    register struct IntuiMessage *imsg;
X    register int done = 0, quit = 1;
X    int txtdiff;
X    long class, code, qual;
X    static int once = 0;
X    static WORD areabuffer[ 80 ];
X    static USHORT apat[] = { 0x5555, 0xaaaa };
X    static struct AreaInfo areaInfo = { 0 };
X    PLANEPTR pp;
X    struct TmpRas tmpras;
X
X    Quest_NewWindowStructure2.Screen = scrn;
X    txtdiff = scrn->RastPort.TxHeight - 8;
X    if( !once )
X    {
X	Quest_IntuiTextList2.TopEdge += txtdiff;
X	Quest_Borders2.TopEdge += txtdiff;
X	Quest_NewWindowStructure2.Height += txtdiff * 2;
X	SetBorder( &Quest_Borders2, 3 );
X	Quest_Yes.TopEdge += txtdiff;
X	Quest_Yes.Height += txtdiff;
X	SetBorder( &Quest_Yes, -1 );
X	Quest_No.TopEdge += txtdiff;
X	Quest_No.Height += txtdiff;
X	SetBorder( &Quest_No, -1 );
X    }
X
X    memset( areabuffer, 0, sizeof( areabuffer ) );
X    if( ( qwin = MyOpenWindow( &Quest_NewWindowStructure2 ) ) == NULL )
X    {
X	errmsg( FLASH, "Can't create requester window" );
X	return( 1 );
X    }
X
X    pp = AllocRaster( qwin->Width, qwin->Height );
X    if( pp )
X    {
X	InitArea( &areaInfo, areabuffer, 160/5 );
X	qwin->RPort->AreaInfo = &areaInfo;
X
X	InitTmpRas( &tmpras, pp, RASSIZE( qwin->Width, qwin->Height ) );
X	qwin->RPort->TmpRas = &tmpras;
X
X	SetAPen( qwin->RPort, C_WHITE );
X	SetBPen( qwin->RPort, C_GREY );
X	SetDrMd( qwin->RPort, JAM2 );
X	SetAfPt( qwin->RPort, apat, 1 );
X
X	AreaMove( qwin->RPort, qwin->BorderLeft, qwin->BorderTop );
X	AreaDraw( qwin->RPort, qwin->Width-qwin->BorderRight, qwin->BorderTop );
X	AreaDraw( qwin->RPort, qwin->Width - qwin->BorderRight,
X		qwin->Height - qwin->BorderBottom );
X	AreaDraw( qwin->RPort, qwin->BorderLeft,
X		qwin->Height - qwin->BorderBottom );
X	AreaDraw( qwin->RPort, qwin->BorderLeft, qwin->BorderTop );
X	AreaEnd( qwin->RPort );
X
X	SetAPen( qwin->RPort, C_GREY );
X	SetBPen( qwin->RPort, C_GREY );
X	SetDrMd( qwin->RPort, JAM2 );
X	SetAfPt( qwin->RPort, NULL, 0 );
X
X	RectFill( qwin->RPort,
X		Quest_Borders2.LeftEdge,
X		Quest_Borders2.TopEdge,
X		Quest_Borders2.LeftEdge + Quest_Borders2.Width - 1,
X		Quest_Borders2.TopEdge + Quest_Borders2.Height - 1 );
X	RectFill( qwin->RPort,
X		Quest_No.LeftEdge,
X		Quest_No.TopEdge,
X		Quest_No.LeftEdge + Quest_No.Width - 1,
X		Quest_No.TopEdge + Quest_No.Height - 1 );
X	RectFill( qwin->RPort,
X		Quest_Yes.LeftEdge,
X		Quest_Yes.TopEdge,
X		Quest_Yes.LeftEdge + Quest_Yes.Width - 1,
X		Quest_Yes.TopEdge + Quest_Yes.Height - 1 );
X	RefreshGList( qwin->FirstGadget, qwin, NULL, -1 );
X    }
X
X    Quest_IntuiTextList2.LeftEdge = ( qwin->Width -
X	( qwin->RPort->TxWidth * strlen( quest ) ) ) / 2;
X    Quest_IntuiTextList2.IText = quest;
X    PrintIText( qwin->RPort, &Quest_IntuiTextList2, 0, 0 );
X    while( !done )
X    {
X	WaitPort( qwin->UserPort );
X	while( ( imsg = (void *) GetMsg( qwin->UserPort ) ) != NULL )
X	{
X	    class = imsg->Class;
X	    code = imsg->Code;
X	    qual = imsg->Qualifier;
X	    gd = (struct Gadget *)imsg->IAddress;
X
X	    ReplyMsg( (struct Message *)imsg );
X
X	    switch( class )
X	    {
X		case VANILLAKEY:
X		    if( imsg->Qualifier & AMIGALEFT )
X		    {
X			switch( imsg->Code )
X			{
X			    case 'v': done = 1; quit = 0; break;
X			    case '\33':
X			    case 'b': done = 1; quit = 1; break;
X			}
X		    }
X		    break;
X
X		case CLOSEWINDOW:
X		    done = 1; quit = 1; break;
X		    break;
X
X		case GADGETUP:
X		    switch( gd->GadgetID )
X		    {
X			case GADQUESTYES: done = 1; quit = 0; break;
X			case GADQUESTNO: done = 1; quit = 1; break;
X		    }
X		    break;
X	    }
X	}
X    }
X
X    if( pp )
X	FreeRaster( pp, qwin->Width, qwin->Height );
X    once = 1;
X    SafeCloseWindow( qwin );
X    return( quit == 0 );
X}
X
X/* Make sure that a game icon is selected and return the pointer to
X * the GPTR structure associated with it.
X */
X
XGPTR NeedGame()
X{
X    register GPTR gptr;
X
X    if( lastgaddown == NULL )
X    {
X	errmsg( FLASH, "Must select a game" );
X	return( NULL );
X    }
X
X    for( gptr = windowgads; gptr; gptr = gptr->nextwgad )
X    {
X	if( &gptr->dobj->do_Gadget == &lastgaddown->dobj->do_Gadget )
X	    break;
X    }
X
X    if( !gptr )
X    {
X	errmsg( FLASH, "BUG: invalid gadget selected for processing" );
X	return( NULL );
X    }
X    return( gptr );
X}
X
X/* Set menu items SELECT flag based on 'enable' */
X
Xvoid ChgGameItems( menup, enable )
X    struct Menu *menup;
X    int enable;
X{
X    struct MenuItem *ip;
X    int i;
X    int ino;
X
X    /* Make sure the 'Game' menu is there. */
X
X    if( !menup || !(menup = menup->NextMenu) || !( ip = menup->FirstItem ) )
X    {
X	errmsg( FLASH, "BUG: invalid menu to disable with" );
X	return;
X    }
X
X    /* Go through all items */
X
X    for( i = 0; ip; ip = ip->NextItem, ++i )
X    {
X	switch( i )
X	{
X	    case ITEM_INFO:
X	    case ITEM_SETCOMMENT:
X	    case ITEM_SETOPT:
X	    case ITEM_COPYOPT:
X	    case ITEM_DISCARD:
X	    case ITEM_RENAME:
X		ino = MENUITEMNO( 1,i,NOSUB );
X		if( enable )
X		    OnMenu( win, ino );
X		else
X		    OffMenu( win, ino );
X		break;
X	}
X    }
X}
X
X/* Set menu items SELECT flag based on 'enable' for NEWGAME gadget */
X
Xvoid ChgNewGameItems( menup, enable )
X    struct Menu *menup;
X    int enable;
X{
X    struct MenuItem *ip;
X    int i;
X    int ino;
X
X    /* Make sure the 'Game' menu is there. */
X
X    if( !menup || !(menup = menup->NextMenu) || !( ip = menup->FirstItem ) )
X    {
X	errmsg( FLASH, "BUG: invalid menu to disable with" );
X	return;
X    }
X
X    /* Go through all items */
X
X    for( i = 0; ip; ip = ip->NextItem, ++i )
X    {
X	switch( i )
X	{
X	    case ITEM_SETOPT:
X	    case ITEM_RENAME:
X	    case ITEM_DISCARD:
X	    case ITEM_COPYOPT:
X		ino = MENUITEMNO( 1,i,NOSUB );
X		OffMenu( win, ino );
X		break;
X
X	    case ITEM_INFO:
X	    case ITEM_SETCOMMENT:
X		ino = MENUITEMNO( 1,i,NOSUB );
X		if( enable )
X		    OnMenu( win, ino );
X		else
X		    OffMenu( win, ino );
X		break;
X	}
X    }
X}
X
X/* Edit the OPTIONS= line with a window.  The optr[] array is set up
X * for the editing already, and will be returned with the values
X * of the members changed based on the users input
X */
X
Xint EditOptions( optr )
X    OPTR optr;
X{
X    int done = 0, quit = 0;
X    register struct Window *cwin;
X    register struct IntuiMessage *imsg;
X    register struct Gadget *gd;
X    long code, class, qual;
X    struct IntuiText *ip;
X    static int once = 0;
X    int i;
X    int txtdiff = scrn->RastPort.TxHeight - 8;
X
X    if( !once )
X    {
X	if( gd = FindGadget( NULL, &Options_NewWindowStructure3, GADOCOLOR ))
X	{
X	    struct Gadget *g;
X	    for( g = Options_NewWindowStructure3.FirstGadget;
X			    g; g = g->NextGadget )
X	    {
X		if( g == gd )
X		    continue;
X		if( g->TopEdge == gd->TopEdge )
X		{
X		    g->Height += txtdiff;
X		}
X	    }
X	    gd->Height += txtdiff;
X	}
X
X	if( gd = FindGadget( NULL, &Options_NewWindowStructure3, GADOTIME ))
X	{
X	    struct Gadget *g;
X	    for( g = Options_NewWindowStructure3.FirstGadget;
X			    g; g = g->NextGadget )
X	    {
X		if( g == gd )
X		    continue;
X		if( g->TopEdge == gd->TopEdge )
X		{
X		    g->TopEdge += txtdiff;
X		    g->Height += txtdiff;
X		}
X	    }
X	    gd->TopEdge += txtdiff;
X	    gd->Height += txtdiff;
X	}
X
X	if( gd = FindGadget( NULL, &Options_NewWindowStructure3, GADOPICKUP ))
X	{
X	    struct Gadget *g;
X	    for( g = Options_NewWindowStructure3.FirstGadget; g; g = g->NextGadget )
X	    {
X		if( g == gd )
X		    continue;
X		if( g->TopEdge == gd->TopEdge )
X		{
X		    g->TopEdge += txtdiff*2;
X		    g->Height += txtdiff;
X		}
X	    }
X	    gd->TopEdge += txtdiff*2;
X	    gd->Height += txtdiff;
X	}
X
X	if( gd = FindGadget( NULL, &Options_NewWindowStructure3, GADOHILITEPET ))
X	{
X	    struct Gadget *g;
X	    for( g = Options_NewWindowStructure3.FirstGadget; g; g = g->NextGadget )
X	    {
X		if( g == gd )
X		    continue;
X		if( g->TopEdge == gd->TopEdge )
X		{
X		    g->TopEdge += txtdiff*3;
X		    g->Height += txtdiff;
X		}
X	    }
X	    gd->TopEdge += txtdiff*3;
X	    gd->Height += txtdiff;
X	}
X
X	if( gd = FindGadget( NULL, &Options_NewWindowStructure3, GADOPACKORDER ))
X	{
X	    gd->TopEdge += txtdiff*4;
X	    gd->Height += txtdiff;
X	}
X	if( gd = FindGadget( NULL, &Options_NewWindowStructure3, GADOCATNAME ))
X	{
X	    gd->TopEdge += txtdiff*5;
X	    gd->Height += txtdiff;
X	}
X	if( gd = FindGadget( NULL, &Options_NewWindowStructure3, GADODOGNAME ))
X	{
X	    gd->TopEdge += txtdiff*6;
X	    gd->Height += txtdiff;
X	}
X	if( gd = FindGadget( NULL, &Options_NewWindowStructure3, GADOFRUIT ))
X	{
X	    gd->TopEdge += txtdiff*7;
X	    gd->Height += txtdiff;
X	}
X	if( gd = FindGadget( NULL, &Options_NewWindowStructure3, GADOOBJECTS ))
X	{
X	    gd->TopEdge += txtdiff*8;
X	    gd->Height += txtdiff;
X	}
X	if( gd = FindGadget( NULL, &Options_NewWindowStructure3, GADOOKAY ))
X	{
X	    gd->TopEdge += txtdiff*9;
X	    gd->Height += txtdiff;
X	}
X	if( gd = FindGadget( NULL, &Options_NewWindowStructure3, GADOCANCEL ))
X	{
X	    gd->TopEdge += txtdiff*9;
X	    gd->Height += txtdiff;
X	}
X	Options_NewWindowStructure3.Height += txtdiff*11;
X	Options_NewWindowStructure3.TopEdge -= txtdiff*6;
X	if( Options_NewWindowStructure3.Height +
X	    Options_NewWindowStructure3.TopEdge >= scrn->Height )
X	{
X	    Options_NewWindowStructure3.TopEdge = scrn->Height -
X	    Options_NewWindowStructure3.Height - 1;
X	}
X	if( Options_NewWindowStructure3.TopEdge < 0 )
X	    Options_NewWindowStructure3.TopEdge = 0;
X	{
X	    if( Options_NewWindowStructure3.Height > scrn->Height )
X		Options_NewWindowStructure3.Height = scrn->Height;
X	}
X
X	/* Now that heights are correct, render borders */
X	for( gd = Options_NewWindowStructure3.FirstGadget;
X	    gd; gd = gd->NextGadget )
X	{
X	    if( gd->GadgetID != 0 )
X	    {
X		gd->TopEdge += txtdiff;
X		SetBorder( gd, -1 );
X	    }
X	}
X	for( ip = &Options_IntuiTextList3; ip; ip = ip->NextText )
X	{
X	    if( *ip->IText == 'P' )
X		ip->TopEdge += txtdiff * 5;
X	    else if( *ip->IText == 'C' )
X		ip->TopEdge += txtdiff * 6;
X	    else if( *ip->IText == 'D' )
X		ip->TopEdge += txtdiff * 7;
X	    else if( *ip->IText == 'F' )
X		ip->TopEdge += txtdiff * 8;
X	    else if( *ip->IText == 'O' )
X		ip->TopEdge += txtdiff * 9;
X	}
X	once = 1;
X    }
X
X    /* Set Gadgets based on options settings */
X
X    for( i = 0; optr[ i ].name; ++i )
X    {
X	if( gd = FindGadget( NULL, &Options_NewWindowStructure3, optr[i].id ))
X	{
X	    /* If string valued option, set string */
X	    if( optr[ i ].optstr )
X	    {
X		strcpy( Sbuff( gd ), optr[i].optstr );
X	    }
X	    else
X	    {
X		/* If binary option, set the gadget state */
X		if( optr[i].optval )
X		    gd->Flags |= SELECTED;
X		else
X		    gd->Flags &= ~SELECTED;
X	    }
X	}
X	else
X	{
X	    errmsg( FLASH, "Can't find gadget %d in options window",
X								optr[i].id);
X	}
X    }
X
X    Options_NewWindowStructure3.Screen = scrn;
X    if( ( cwin = MyOpenWindow( &Options_NewWindowStructure3 ) ) == NULL )
X    {
X	errmsg( FLASH, "Can't create requester window" );
X	return(0);
X    }
X    PrintIText( cwin->RPort, &Options_IntuiTextList3, 0, txtdiff );
X
X    while( !done )
X    {
X	WaitPort( cwin->UserPort );
X	while( ( imsg = (void *) GetMsg( cwin->UserPort ) ) != NULL )
X	{
X	    class = imsg->Class;
X	    code = imsg->Code;
X	    qual = imsg->Qualifier;
X	    gd = (struct Gadget *)imsg->IAddress;
X	    ReplyMsg( (struct Message *) imsg );
X	    switch( class )
X	    {
X		case ACTIVEWINDOW:
X		    ActivateGadget(
X			FindGadget( cwin, 0, GADOPACKORDER ), cwin, 0 );
X		    break;
X
X		case VANILLAKEY:
X		    if( code == '\33' )
X		    {
X			done = 1;
X			quit = 1;
X		    }
X		    else if( code == 'v' && (qual & AMIGALEFT) )
X			done = 1;
X		    else if( code == 'b' && (qual & AMIGALEFT) )
X		    {
X			done = 1;
X			quit = 1;
X		    }
X		    else
X		    {
X			switch( code )
X			{
X			    case 'p':
X			    case 'P':
X				ActivateGadget(
X				    FindGadget( cwin, 0, GADOPACKORDER ),
X				    cwin, 0 );
X				break;
X			    case 'c':
X			    case 'C':
X				ActivateGadget(
X				    FindGadget( cwin, 0, GADOCATNAME ),
X				    cwin, 0 );
X				break;
X			    case 'd':
X			    case 'D':
X				ActivateGadget(
X				    FindGadget( cwin, 0, GADODOGNAME ),
X				    cwin, 0 );
X				break;
X			    case 'f':
X			    case 'F':
X				ActivateGadget(
X				    FindGadget( cwin, 0, GADOFRUIT ),
X				    cwin, 0 );
X				break;
X			    case 'o':
X			    case 'O':
X				ActivateGadget(
X				    FindGadget( cwin, 0, GADOOBJECTS ),
X				    cwin, 0 );
X				break;
X			}
X		    }
X		    break;
X
X		case CLOSEWINDOW:
X		    done = 1;
X		    break;
X
X		case GADGETUP:
X		    switch( gd->GadgetID )
X		    {
X			case GADOPACKORDER:
X			    ActivateGadget(
X				FindGadget( cwin, 0, GADOCATNAME ),
X				cwin, 0 );
X			    break;
X
X			case GADOCATNAME:
X			    ActivateGadget(
X				FindGadget( cwin, 0, GADODOGNAME ),
X				cwin, 0 );
X			    break;
X
X			case GADODOGNAME:
X			    ActivateGadget(
X				FindGadget( cwin, 0, GADOFRUIT ),
X				cwin, 0 );
X			    break;
X
X			case GADOFRUIT:
X			    ActivateGadget(
X				FindGadget( cwin, 0, GADOOBJECTS ),
X				cwin, 0 );
X			    break;
X
X			case GADOOBJECTS:
X			    break;
X
X			case GADOOKAY:
X			    done = 1;
X			    break;
X
X			case GADOCANCEL:
X			    quit = 1;
X			    done = 1;
X			    break;
X
X			default:
X			    for( i = 0; optr[i].name; ++i )
X			    {
X				if( optr[i].id == gd->GadgetID )
X				    break;
X			    }
X
X			    if( optr[i].name )
X			    {
X				if( optr[ i ].optstr != NULL )
X				{
X				    if( optr[i].optstr && *optr[i].optstr )
X					free( optr[i].optstr );
X
X				    if( *Sbuff(gd) == 0 )
X				    {
X					optr[i].optstr = "";
X				    }
X				    else
X				    {
X					optr[i].optstr = strdup(Sbuff(gd));
X				    }
X				}
X				else
X				{
X				    optr[i].optval =
X					    ( gd->Flags & SELECTED ) != 0;
X				}
X			    }
X			    break;
X		    }
X		    break;
X	    }
X	}
X    }
X
X    SafeCloseWindow( cwin );
X    return( quit == 0 );
X}
X
X/*
X * Put options structure into a string and then make that the
X * options[ OPTIONS_IDX ] value
X */
X
Xvoid PutOptions( optr )
X    register OPTR optr;
X{
X    register struct Gadget *gd;
X    register int i, olen = 4096, rlen, didone;
X    register char *optbuf;
X
X    while( olen > 256 )
X    {
X	if( ( optbuf = xmalloc( olen ) ) != NULL )
X	{
X	    break;
X	}
X	olen /= 2;
X    }
X
X    if( optbuf == NULL )
X    {
X	errmsg( FLASH, "No memory left for options buffer" );
X	return;
X    }
X
X    /* Account for nul terminator */
X    *optbuf = 0;
X
X    for( i = 0; optr[i].name; ++i )
X    {
X	--olen;
X	didone = 0;
X	rlen = 0;
X	gd = FindGadget( 0, &Options_NewWindowStructure3, optr[i].id );
X
X	/* If name:value option */
X	if( optr[i].optstr != NULL )
X	{
X	    /* If gadget contains some text */
X	    if( gd && *Sbuff( gd ) )
X	    {
X		/* Free a previously allocated string */
X		if( optr[i].optstr && *optr[i].optstr )
X		    free( optr[i].optstr );
X
X		/* Store "" or save string away */
X		if( *Sbuff(gd) == 0 )
X		    optr[i].optstr = "";
X		else
X		    optr[i].optstr = strdup(Sbuff(gd));
X
X		rlen = strlen( optr[i].optstr ) + strlen( optr[i].name ) + 1;
X		if( rlen <= olen )
X		{
X		    sprintf( optbuf + strlen(optbuf), "%s:%s",
X			optr[i].name, optr[i].optstr );
X		}
X		didone = 1;
X	    }
X	}
X	else
X	{
X	    if( optr[i].optval != optr[i].defval )
X	    {
X		if( olen >= (rlen = strlen( optr[i].name ) +
X			(optr[i].optval == 0 ) ) )
X		{
X		    if( optr[i].optval == 0 )
X			strcat( optbuf, "!" );
X		    strcat( optbuf, optr[i].name );
X		}
X		didone = 1;
X	    }
X	}
X
X	if( rlen > olen )
X	{
X	    errmsg( FLASH, "Out of space for options" );
X	    break;
X	}
X	if( didone )
X	    strcat( optbuf, "," );
X    }
X
X    /* Remove trailing ',' */
X
X    if( *optbuf )
X	optbuf[ strlen( optbuf ) - 1 ] = 0;
X
X    setoneopt( OPTIONS_IDX, optbuf );
X    free( optbuf );
X}
X
Xvoid Game2Defs( gptr )
X    register GPTR gptr;
X{
X    register char *s;
X    register int i;
X
X    if( defgame.plname )
X	free( defgame.plname );
X    defgame.plname = strdup( ToolsEntry( gptr, "NAME" ) );
X
X    s = ToolsEntry( gptr, "CHARACTER" );
X    for( i = 0; players[ i ]; ++i )
X    {
X	if( strnicmp( s, players[ i ], strlen(s) ) == 0 )
X	    break;
X    }
X
X    if( players[ i ] )
X	defgame.pltype = i;
X    else
X	defgame.pltype = 0;
X
X    if( defgame.options )
X	free( defgame.options );
X    defgame.options = strdup( ToolsEntry( gptr, "OPTIONS" ) );
X}
END_OF_FILE
if test 43875 -ne `wc -c <'sys/amiga/wb.c2'`; then
    echo shar: \"'sys/amiga/wb.c2'\" unpacked with wrong size!
fi
# end of 'sys/amiga/wb.c2'
fi
if test -f 'sys/vms/vmsbuild.com' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/vms/vmsbuild.com'\"
else
echo shar: Extracting \"'sys/vms/vmsbuild.com'\" \(11318 characters\)
sed "s/^X//" >'sys/vms/vmsbuild.com' <<'END_OF_FILE'
X$ ! vms/vmsbuild.com -- compile and link NetHack 3.1 patchlevel 0	[pr]
X$ !
X$ ! usage:
X$ !   $ set default [.src]	!or [-.-.src] if starting from [.sys.vms]
X$ !   $ @[-.sys.vms]vmsbuild  [compiler-option]  [link-option]  [cc-switches]
X$ ! options:
X$ !	compiler-option :  either "VAXC" or "GNUC" or ""	!default VAXC
X$ !	link-option	:  either "SHARE[able]" or "LIB[rary]"	!default SHARE
X$ !	cc-switches	:  optional qualifiers for CC (such as "/noOpt/Debug")
X$ ! notes:
X$ !	If the symbol "CC" is defined, compiler-option is not used.
X$ !	The link-option refers to VAXCRTL (C Run-Time Library) handling;
X$ !	  to specify it while letting compiler-option default, use "" as
X$ !	  the compiler-option.
X$ !	To re-link without compiling, use "LINK" as special 'compiler-option';
X$ !	  to re-link with GNUC library, 'CC' must begin with "G" (or "g").
X$ !	Default wizard definition moved to include/vmsconf.h.
X$
X$	vaxc_ = "CC/NOLIST/OPTIMIZE=NOINLINE"	    !vaxc v3.x (2.x fixed below)
X$	gnuc_ = "GCC"
X$	gnulib = "gnu_cc:[000000]gcclib/Library"    !(not used w/ vaxc)
X$ ! common CC options (/obj=file doesn't work for GCC 1.36, use rename instead)
X$	c_c_  = "/INCLUDE=[-.INCLUDE]"
X$	veryold_vms = f$extract(1,1,f$getsyi("VERSION")).eqs."4" -
X		.and. f$extract(3,3,f$getsyi("VERSION")).lts."6"
X$	if veryold_vms then  c_c_ = c_c_ + "/DEFINE=(""VERYOLD_VMS"")"
X$ ! miscellaneous setup
X$	ivqual = %x00038240	!DCL-W-IVQUAL (used to check for ancient vaxc)
X$	abort := exit %x1000002A
X$	cur_dir  = f$environment("DEFAULT")
X$	vmsbuild = f$environment("PROCEDURE")
X$ ! validate first parameter
X$	p1 := 'p1'
X$	o_VAXC = 0	!(c_opt substring positions)
X$	o_GNUC = 5
X$	o_LINK = 10
X$	o_SPCL = 15
X$	c_opt = f$locate("|"+p1, "|VAXC|GNUC|LINK|SPECIAL|") !5
X$     if (c_opt/5)*5 .eq. c_opt then  goto p1_ok
X$	copy sys$input: sys$error:	!p1 usage
X%first arg is compiler option; it must be one of
X       "VAXC" -- use VAX C to compile everything
X   or  "GNUC" -- use GNU C to compile everything
X   or  "LINK" -- skip compilation, just relink nethack.exe
X   or  "SPEC[IAL]" -- just compile and link lev_comp.exe
X   or    ""   -- default operation (VAXC unless 'CC' is defined)
X
XNote: if a DCL symbol for CC is defined, "VAXC" and "GNUC" are no-ops.
X      If the symbol value begins with "G" (or "g"), then the GNU C
X      library will be included in all link operations.  Do not rebuild
X      lev_comp with "SPECIAL" unless you have a CC symbol setup with
X      the proper options.
X$	abort
X$p1_ok:
X$ ! validate second parameter
X$	p2 := 'p2'
X$	l_opt = f$locate("|"+p2, "|SHAREABLE|LIBRARY__|") !10
X$     if (l_opt/10)*10 .eq. l_opt then	goto p2_ok
X$	copy sys$input: sys$error:	!p2 usage
X%second arg is VAXCRTL handling; it must be one of
X       "SHAREABLE" -- link with SYS$SHARE:VAXCRTL.EXE/SHAREABLE
X   or   "LIBRARY"  -- link with SYS$LIBRARY:VAXCRTL.OLB/LIBRARY
X   or      ""      -- default operation (use shareable image)
X
XNote: for MicroVMS 4.x, "SHAREABLE" (which is the default) is required.
X$	abort
X$p2_ok:
X$ ! start from a known location -- [.sys.vms], then move to [-.-.src]
X$	set default 'f$parse(vmsbuild,,,"DIRECTORY")'
X$	set default [-.-.src]	!move to source directory
X$ ! compiler setup; if a symbol for "CC" is already defined it will be used
X$     if f$type(cc).eqs."STRING" then  goto got_cc
X$	cc = vaxc_			!assume "VAXC" requested or defaulted
X$	if c_opt.eq.o_GNUC then  goto chk_gcc !explicitly invoked w/ "GNUC" option
X$	if c_opt.ne.o_VAXC then  goto got_cc !"SPEC" or "LINK", skip compiler check
X$	! we want to prevent function inlining with vaxc v3.x (/opt=noinline)
X$	!   but we can't use noInline with v2.x, so need to determine version
X$	  set noOn
X$	  msgenv = f$environment("MESSAGE")
X$	  set message/noFacil/noSever/noIdent/noText
X$	  cc/noObject _NLA0:/Include=[]     !strip 'noinline' if error
X$	  sts = $status
X$	if sts then  goto reset_msg	!3.0 or later will check out OK
X$	! must be dealing with vaxc 2.x; ancient version (2.2 or earlier)
X$	!   can't handle /include='dir', needs c$include instead
X$	  cc = cc - "=NOINLINE" - ",NOINLINE" - "NOINLINE,"
X$	  if sts.ne.IVQUAL then  goto reset_msg
X$	    define/noLog c$include [-.INCLUDE]
X$	    c_c_ = "/DEFINE=(""ANCIENT_VAXC"")"
X$	    if veryold_vms then  c_c_ = c_c_ - ")" + ",""VERYOLD_VMS"")"
X$reset_msg:
X$	  set message 'msgenv'
X$	  set On
X$	  goto got_cc
X$ !
X$chk_gcc:
X$	cc = gnuc_
X$ ! old versions of gcc-vms don't have <varargs.h> or <stdarg.h> available
X$	  c_c_ = "/DEFINE=(""USE_OLDARGS"")"
X$	  if veryold_vms then  c_c_ = c_c_ - ")" + ",""VERYOLD_VMS"")"
X$	  if veryold_vms then  goto chk_gas	!avoid varargs & stdarg
X$	  if f$search("gnu_cc_include:[000000]varargs.h").nes."" then -
X		c_c_ = "/DEFINE=(""USE_VARARGS"")"
X$	  if f$search("gnu_cc_include:[000000]stdarg.h").nes."" then -
X		c_c_ = "/DEFINE=(""USE_STDARG"")"
X$chk_gas:
X$ ! test whether this version of gas handles the 'const' construct correctly
X$ gas_chk_tmp = "sys$scratch:gcc-gas-chk.tmp"
X$ if f$search(gas_chk_tmp).nes."" then  delete/noconfirm/nolog 'gas_chk_tmp';*
X$ gas_ok = 0	!assume bad
X$ on warning then goto skip_gas
X$ define/user/nolog sys$error 'gas_chk_tmp'
X$ mcr gnu_cc:[000000]gcc-as sys$input: -o _NLA0:
X$DECK
X.const
X.comm dummy,0
X.const
X.comm dummy,0
X$EOD
X$ gas_ok = 1	!assume good
X$ if f$search(gas_chk_tmp).eqs."" then  goto skip_gas
X$ ! if the error file is empty, gas can deal properly with const
X$  gas_ok = f$file_attrib(gas_chk_tmp,"EOF") .eq. 0
X$  delete/noconfirm/nolog 'gas_chk_tmp';*
X$skip_gas:
X$ on warning then continue
X$	  if .not.gas_ok then  c_c_ = c_c_ - ")" + ",""const="")"
X$	  c_c_ = "/INCLUDE=[-.INCLUDE]" + c_c_
X$ !
X$got_cc:
X$	cc = cc + c_c_			!append common qualifiers
X$	if p3.nes."" then  cc = cc + p3 !append optional user preferences
X$	g := 'f$extract(0,1,cc)'
X$	if g.nes."G" .and. c_opt.ne.o_GNUC then  gnulib = ""
X$	if g.eqs."G"  .or. c_opt.eq.o_GNUC then  gnulib = "," + gnulib
X$ ! linker setup; if a symbol for "LINK" is defined, we'll use it
X$	if f$type(link).nes."STRING" then  link = "LINK/NOMAP"
X$	if p4.nes."" then  link = link + p4 !append optional user preferences
X$	crtl = "sys$library:vaxcrtl.olb/Library"	!object library
X$     if l_opt.ne.0 then  goto crtl_ok
X$	crtl = "sys$disk:[-.src]crtl.opt/Options"	!shareable image
X$     if f$search("crtl.opt").nes."" then  goto crtl_ok !assume its right
X$	create sys$disk:[-.src]crtl.opt
Xsys$share:vaxcrtl.exe/Shareable
X$crtl_ok:
X$ ! final setup
X$	nethacklib = "[-.src]nethack.olb"
X$	milestone = "write sys$output f$fao("" !5%T "",0),"
X$     if c_opt.eq.o_LINK then  goto link  !"LINK" requested, skip compilation
X$	rename	 := rename/New_Vers
X$	touch	 := set file/Truncate
X$	makedefs := $sys$disk:[-.util]makedefs
X$	show symbol cc
X$	goto begin	!skip subroutines
X$!
X$compile_file:	!input via 'c_file'
X$	no_lib = ( f$extract(0,1,c_file) .eqs. "#" )
X$	if no_lib then	c_file = f$extract(1,255,c_file)
X$	c_name = f$edit(f$parse(c_file,,,"NAME"),"LOWERCASE")
X$	f_opts = ""	!options for this file
X$	if f$type('c_name'_options).nes."" then  f_opts = 'c_name'_options
X$	milestone " (",c_name,")"
X$	if f$search("''c_name'.obj").nes."" then  delete 'c_name'.obj;*
X$	cc 'f_opts' 'c_file'.c
X$	if .not.no_lib then  nh_obj_list == nh_obj_list + ",''c_name'.obj;0"
X$     return
X$!
X$compile_list:	!input via 'c_list'
X$	nh_obj_list == ""
X$	j = -1
X$ c_loop:
X$	j = j + 1
X$	c_file = f$element(j,",",c_list)  !get next file
X$	if c_file.nes."," then	gosub compile_file
X$	if c_file.nes."," then	goto c_loop
X$	nh_obj_list == f$extract(1,999,nh_obj_list)
X$	if nh_obj_list.nes."" then  libr/Obj 'nethacklib' 'nh_obj_list'/Replace
X$	if nh_obj_list.nes."" then  delete 'nh_obj_list'
X$	delete/symbol/global nh_obj_list
X$     return
X$!
X$begin:
X$!
X$! miscellaneous special source file setup
X$!
X$ if f$search("monst.c").eqs."" then  copy/Concat monst.c1+.c2 monst.c
X$ if f$search("random.c").eqs."" then  copy [-.sys.share]random.c []*.*
X$ if f$search("[-.util]lev_yacc.c").eqs."" then  @[-.sys.vms]spec_lev.com
X$!
X$! create object library
X$!
X$ libr/Obj 'nethacklib'/Create=(Block=3000,Hist=0)
X$ if f$search("''nethacklib';-1").nes."" then  purge 'nethacklib'
X$!
X$! compile and link makedefs, then nethack, finally lev_comp & dgn_comp.
X$!
X$ milestone "<compiling...>"
X$ c_list = "[-.sys.vms]vmsmisc,[]alloc,monst,objects"
X$     if c_opt.eq.o_SPCL then  c_list = c_list + ",decl,drawing"
X$ gosub compile_list
X$     if c_opt.eq.o_SPCL then  goto special !"SPECIAL" requested, skip main build
X$ set default [-.util]
X$ c_list = "#makedefs"
X$ gosub compile_list
X$ link makedefs.obj,'nethacklib'/Lib,'crtl''gnulib',sys$input:/Opt
Xidentification="makedefs 3.1.0"
X$ milestone "makedefs"
X$! create some build-time files
X$ makedefs -p	!pm.h
X$ makedefs -o	!onames.h
X$ makedefs -v	!date.h
X$ milestone " (*.h)"
X$ makedefs -m	!../src/monstr.c
X$ makedefs -z	!../src/vis_tab.c, ../include/vis_tab.h
X$ milestone " (*.c)"
X$ set default [-.src]
X$! compile most of the source files:
X$	gnutermcap_options = "/Define=(""bcopy(s,d,n)=memcpy(d,s,n)"",""exit=vms_exit"")"
X$	if c_opt.eq.o_GNUC then  gnutermcap_options = "/Define=(""exit=vms_exit"")"  !gcc
X$ c_list = "decl,version,[-.sys.vms]vmsmain,[-.sys.vms]vmsunix" -
X	+ ",[-.sys.vms]vmstty,[-.sys.vms]vmsmail,[-.sys.vms]vmsfiles" -
X	+ ",[]random"	!copied from [-.sys.share]
X$ gosub compile_list
X$ c_list = "[-.win.tty]getline,[-.win.tty]termcap" -
X	+ ",[-.win.tty]topl,[-.win.tty]wintty" -
X	+ ",[-.sys.vms]gnutparam,[-.sys.vms]gnutermcap"
X$ gosub compile_list
X$ c_list = "allmain,apply,artifact,attrib,ball,bones,botl,cmd,dbridge,detect" -
X	+ ",display,do,do_name,do_wear,dog,dogmove,dokick,dothrow,drawing" -
X	+ ",dungeon,eat,end,engrave,exper,explode,extralev,files,fountain"
X$ gosub compile_list
X$ c_list = "hack,hacklib,invent,lock,mail,makemon,mcastu,mhitm,mhitu" -
X	+ ",minion,mklev,mkmap,mkmaze,mkobj,mkroom,mon,mondata,monmove,monstr" -
X	+ ",mplayer,mthrowu,muse,music,o_init,objnam,options,pager,pickup"
X$ gosub compile_list
X$ c_list = "pline,polyself,potion,pray,priest,quest,questpgr,read" -
X	+ ",rect,restore,rip,rnd,rumors,save,shk,shknam,sit,sounds" -
X	+ ",sp_lev,spell,steal,timeout,topten,track,trap,u_init"
X$ gosub compile_list
X$ c_list = "uhitm,vault,vision,vis_tab,weapon,were,wield,windows" -
X	+ ",wizard,worm,worn,write,zap"
X$ gosub compile_list
X$!
X$link:
X$ milestone "<linking...>"
X$ link/Exe=nethack 'nethacklib'/Lib/Incl=(vmsmain),'crtl''gnulib',-
X	sys$input:/Opt
Xidentification="NetHack 3.1.0"
X$ milestone "NetHack"
X$     if c_opt.eq.o_LINK then  goto done	!"LINK" only
X$special:
X$!
X$! build special level and dungeon compilers
X$!
X$ set default [-.util]
X$ c_list = "#panic,#lev_main,#lev_yacc,#dgn_main,#dgn_yacc"
X$     if c_opt.eq.o_SPCL then  c_list = "[-.sys.vms]vmsfiles," + c_list
X$ gosub compile_list
X$ c_list = "#lev_lex,#dgn_lex"
X$ copy [-.sys.vms]lev_lex.h stdio.*/Prot=(s:rwd,o:rwd)
X$ gosub compile_list
X$ rename stdio.h lev_lex.*
X$ link/exe=lev_comp lev_main,lev_yacc,lev_lex,-
X	panic.obj,'nethacklib'/Lib,'crtl''gnulib',sys$input:/Opt
Xidentification="lev_comp 3.1.0"
X$ milestone "lev_comp"
X$ link/exe=dgn_comp dgn_main,dgn_yacc,dgn_lex,-
X	panic.obj,'nethacklib'/Lib,'crtl''gnulib',sys$input:/Opt
Xidentification="dgn_comp 3.1.0"
X$ milestone "dgn_comp"
X$!
X$ c_list = "#recover"
X$ gosub compile_list
X$ link/exe=[] recover.obj,'nethacklib'/Lib,'crtl''gnulib',sys$input:/Opt
Xidentification="recover 3.1.0"
X$ milestone "recover"
X$!
X$done:
X$	set default 'cur_dir'
X$ exit
END_OF_FILE
if test 11318 -ne `wc -c <'sys/vms/vmsbuild.com'`; then
    echo shar: \"'sys/vms/vmsbuild.com'\" unpacked with wrong size!
fi
# end of 'sys/vms/vmsbuild.com'
fi
echo shar: End of archive 22 \(of 108\).
cp /dev/null ark22isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \
21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \
41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 \
61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 \
81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 \
101 102 103 104 105 106 107 108 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 108 archives.
    echo "Now execute 'rebuild.sh'"
    rm -f ark10[0-8]isdone ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
