Path: uunet!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v16i097:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Part89/108
Message-ID: <4460@master.CNA.TEK.COM>
Date: 5 Feb 93 19:22:18 GMT
Sender: news@master.CNA.TEK.COM
Lines: 1856
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1648

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 16, Issue 97
Archive-name: nethack31/Part89
Supersedes: nethack3p9: Volume 10, Issue 46-102
Environment: Amiga, Atari, Mac, MS-DOS, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 89 (of 108)."
# Contents:  dat/Samurai.des include/trap.h src/fountain.c
#   sys/msdos/exesmurf.c sys/vms/gnutparam.c
# Wrapped by billr@saab on Wed Jan 27 16:09:23 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'dat/Samurai.des' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dat/Samurai.des'\"
else
echo shar: Extracting \"'dat/Samurai.des'\" \(13527 characters\)
sed "s/^X//" >'dat/Samurai.des' <<'END_OF_FILE'
X#	SCCS Id: @(#)Samurai.des	3.1	92/10/24
X#	Copyright (c) 1989 by Jean-Christophe Collet
X#	Copyright (c) 1991-92 by M. Stephenson, P. Winner
X# NetHack may be freely redistributed.  See license for details.
X#
X#	The "start" level for the quest.
X#
X#	Here you meet your (besieged) class leader, Lord Sato
X#	and receive your quest assignment.
X#
XMAZE: "S-start",' '
XFLAGS: noteleport,hardfloor
XGEOMETRY:center,center
XMAP
X..............................................................PP............
X...............................................................PP...........
X..........---------------------------------------------------...PPP.........
X..........|......|.........|...|..............|...|.........|....PPPPP......
X......... |......|.........S...|..............|...S.........|.....PPPP......
X..........|......|.........|---|..............|---|.........|.....PPP.......
X..........+......|.........+...-------++-------...+.........|......PP.......
X..........+......|.........|......................|.........|......PP.......
X......... |......---------------------++--------------------|........PP.....
X..........|.................................................|.........PP....
X..........|.................................................|...........PP..
X..........----------------------------------------...-------|............PP.
X..........................................|.................|.............PP
X.............. ................. .........|.................|..............P
X............. } ............... } ........|.................|...............
X.............. ........PP....... .........|.................|...............
X.....................PPP..................|.................|...............
X......................PP..................-------------------...............
X............................................................................
X............................................................................
XENDMAP
X# Random Monsters
XRANDOM_MONSTERS: 'd', 'I'
X# Dungeon Description
XREGION:(00,00,75,19),lit,"ordinary"
XREGION:(18,03,26,07),lit,"throne",unfilled
X# Portal arrival zone
XBRANCH:(62,12,70,17),(0,0,0,0)
X# Stairs
XSTAIR:(29,04),down
X# Doors
XDOOR:locked,(10,06)
XDOOR:locked,(10,07)
XDOOR:closed,(27,04)
XDOOR:closed,(27,06)
XDOOR:closed,(38,06)
XDOOR:locked,(38,08)
XDOOR:closed,(39,06)
XDOOR:locked,(39,08)
XDOOR:closed,(50,04)
XDOOR:closed,(50,06)
X# Lord Sato
XMONSTER:'@',"Lord Sato",(20,04)
X# The treasure of Lord Sato
XOBJECT:'(',"chest",(20,04)
X# ninja guards for the audience chamber
XMONSTER:'@',"ninja",(18,04)
XMONSTER:'@',"ninja",(18,05)
XMONSTER:'@',"ninja",(18,06)
XMONSTER:'@',"ninja",(18,07)
XMONSTER:'@',"ninja",(26,04)
XMONSTER:'@',"ninja",(26,05)
XMONSTER:'@',"ninja",(26,06)
XMONSTER:'@',"ninja",(26,07)
X# Non diggable walls
XNON_DIGGABLE:(00,00,75,19)
X# Random traps
XTRAP:random,random
XTRAP:random,random
XTRAP:random,random
XTRAP:random,random
XTRAP:random,random
XTRAP:random,random
X# Monsters on siege duty.
XMONSTER: '@',"ronin",(64,00),hostile
XMONSTER: 'd',"wolf",(65,01)
XMONSTER: '@',"ronin",(66,02),hostile
XMONSTER: '@',"ronin",(69,05),hostile
XMONSTER: '@',"ronin",(69,06),hostile
XMONSTER: 'd',"wolf",(69,07)
XMONSTER: '@',"ronin",(70,06),hostile
XMONSTER: '@',"ronin",(70,07),hostile
XMONSTER: '@',"ronin",(72,01),hostile
XMONSTER: 'd',"wolf",(75,09)
XMONSTER: '@',"ronin",(73,05),hostile
XMONSTER: '@',"ronin",(68,02),hostile
XMONSTER:'I',"stalker",random
X 
X#
X#	The "locate" level for the quest.
X#
X#	Here you have to invade the Shogun's Castle to go
X#	further towards your assigned quest.
X#
X
XMAZE: "S-locate",' '
XFLAGS: hardfloor
XGEOMETRY:center,center
XMAP
X............................................................................
X............................................................................
X........-----..................................................-----........
X........|...|..................................................|...|........
X........|...---..}..--+------------------------------+--..}..---...|........
X........|-|...|.....|...|....|....|....|....|....|.|...|.....|...|-|........
X..........|...-------...|....|....|....|....|....S.|...-------...|..........
X..........|-|.........------+----+-+-------+-+--------.........|-|..........
X............|..--------.|}........................}|.--------..|............
X............|..+........+..........................+........+..|............
X............|..+........+..........................+........+..|............
X............|..--------.|}........................}|.--------..|............
X..........|-|.........--------+-+-------+-+----+------.........|-|..........
X..........|...-------...|.S....|....|....|....|....|...-------...|..........
X........|-|...|.....|...|.|....|....|....|....|....|...|.....|...|-|........
X........|...---..}..--+------------------------------+--..}..---...|........
X........|...|..................................................|...|........
X........-----..................................................-----........
X............................................................................
X............................................................................
XENDMAP
X# Random Monsters
XRANDOM_MONSTERS: 'd', 'I'
X# Dungeon Description
XREGION:(00,00,75,19),lit,"ordinary"
X# Doors
XDOOR:locked,(22,04)
XDOOR:locked,(22,15)
XDOOR:locked,(53,04)
XDOOR:locked,(53,15)
XDOOR:locked,(49,06)
XDOOR:locked,(26,13)
XDOOR:locked,(28,07)
XDOOR:locked,(30,12)
XDOOR:locked,(33,07)
XDOOR:locked,(32,12)
XDOOR:locked,(35,07)
XDOOR:locked,(40,12)
XDOOR:locked,(43,07)
XDOOR:locked,(42,12)
XDOOR:locked,(45,07)
XDOOR:locked,(47,12)
XDOOR:closed,(15,09)
XDOOR:closed,(15,10)
XDOOR:closed,(24,09)
XDOOR:closed,(24,10)
XDOOR:closed,(51,09)
XDOOR:closed,(51,10)
XDOOR:closed,(60,09)
XDOOR:closed,(60,10)
X# Stairs
XSTAIR:(10,10),up
XSTAIR:(25,14),down
X# Non diggable walls
XNON_DIGGABLE:(00,00,75,19)
X# Objects
XOBJECT:'*',random,(25,05)
XOBJECT:'*',random,(26,05)
XOBJECT:'*',random,(27,05)
XOBJECT:'*',random,(28,05)
XOBJECT:'*',random,(25,06)
XOBJECT:'*',random,(26,06)
XOBJECT:'*',random,(27,06)
XOBJECT:'*',random,(28,06)
X#
XOBJECT:'[',random,(40,05)
XOBJECT:'[',random,(41,05)
XOBJECT:'[',random,(42,05)
XOBJECT:'[',random,(43,05)
XOBJECT:'[',random,(40,06)
XOBJECT:'[',random,(41,06)
XOBJECT:'[',random,(42,06)
XOBJECT:'[',random,(43,06)
X#
XOBJECT:')',random,(27,13)
XOBJECT:')',random,(28,13)
XOBJECT:')',random,(29,13)
XOBJECT:')',random,(30,13)
XOBJECT:')',random,(27,14)
XOBJECT:')',random,(28,14)
XOBJECT:')',random,(29,14)
XOBJECT:')',random,(30,14)
X#
XOBJECT:'(',random,(37,13)
XOBJECT:'(',random,(38,13)
XOBJECT:'(',random,(39,13)
XOBJECT:'(',random,(40,13)
XOBJECT:'(',random,(37,14)
XOBJECT:'(',random,(38,14)
XOBJECT:'(',random,(39,14)
XOBJECT:'(',random,(40,14)
X# Random traps
XTRAP:random,random
XTRAP:random,random
XTRAP:random,random
XTRAP:random,random
XTRAP:random,random
XTRAP:random,random
X# Random monsters.
XMONSTER:'@',"ronin",(15,05),hostile
XMONSTER:'@',"ronin",(16,05),hostile
XMONSTER:'d',"wolf",(17,05)
XMONSTER:'d',"wolf",(18,05)
XMONSTER:'@',"ronin",(19,05),hostile
XMONSTER:'d',"wolf",(15,14)
XMONSTER:'d',"wolf",(16,14)
XMONSTER:'@',"ronin",(17,14),hostile
XMONSTER:'@',"ronin",(18,14),hostile
XMONSTER:'d',"wolf",(56,05)
XMONSTER:'@',"ronin",(57,05),hostile
XMONSTER:'d',"wolf",(58,05)
XMONSTER:'d',"wolf",(59,05)
XMONSTER:'@',"ronin",(56,14),hostile
XMONSTER:'d',"wolf",(57,14)
XMONSTER:'@',"ronin",(58,14),hostile
XMONSTER:'d',random,(59,14)
XMONSTER:'d',"wolf",(60,14)
XMONSTER:'I',random,random
XMONSTER:'I',"stalker",random
XMONSTER:'I',"stalker",random
XMONSTER:'I',"stalker",random
XMONSTER:'I',"stalker",random
XMONSTER:'I',"stalker",random
XMONSTER:'I',"stalker",random
XMONSTER:'I',"stalker",random
XMONSTER:'I',random,random
X#	"guards" for the central courtyard.
XMONSTER:'@',"samurai",(30,05),hostile
XMONSTER:'@',"samurai",(31,05),hostile
XMONSTER:'@',"samurai",(32,05),hostile
XMONSTER:'@',"samurai",(32,14),hostile
XMONSTER:'@',"samurai",(33,14),hostile
XMONSTER:'@',"samurai",(34,14),hostile
X
X#
X#	The "goal" level for the quest.
X#
X#	Here you meet Takauji, your nemesis monster.  You have to
X#	defeat him in combat to gain the artifact you have been
X#	assigned to retrieve.
X#
X
XMAZE: "S-goal", ' '
XFLAGS: noteleport
XGEOMETRY:center,center
XMAP
X                                             
X           .......................           
X       ......---------.---------......       
X    ......----.................----......    
X   ....----.....-------------.....----....   
X  ....--.....----...........----.....--....  
X  ...||....---....---------....---....||...  
X  ...|....--....---.......---....--....|...  
X ....|...||...---...--+--...---...||...|.... 
X ....|...|....|....|-...-|....|....|...|.... 
X ....|...|....|....+.....+....|........|.... 
X ....|...|....|....|-...-|....|....|...|.... 
X ....|...||...---...--+--...---...||...|.... 
X  ...|....--....---.......---....--....|...  
X  ...||....---....----.----....---....||...  
X  ....--.....----...........----.....--....  
X   ....----.....-------------.....----....   
X    ......----.................----......    
X       ......-------------------......       
X           .......................           
XENDMAP
X# Random Monsters
XRANDOM_MONSTERS: 'd', 'I'
X# Dungeon Description
XREGION:(00,00,44,19),unlit,"ordinary"
X# Stairs
XSTAIR:(02,10),up
X# Non diggable walls
XNON_DIGGABLE:(00,00,44,19)
X# Objects
XOBJECT:')',"tsurugi",(22,10),blessed,0,"The Tsurugi of Muramasa"
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
X#
XTRAP:"board",(22,09)
XTRAP:"board",(24,10)
XTRAP:"board",(22,11)
X# Random traps
XTRAP:random,random
XTRAP:random,random
XTRAP:random,random
XTRAP:random,random
XTRAP:random,random
XTRAP:random,random
X# Random monsters.
XMONSTER:'@',"Ashikaga Takauji",(22,10)
XMONSTER:'@',"samurai",random,hostile
XMONSTER:'@',"samurai",random,hostile
XMONSTER:'@',"samurai",random,hostile
XMONSTER:'@',"samurai",random,hostile
XMONSTER:'@',"samurai",random,hostile
XMONSTER:'@',"ronin",random,hostile
XMONSTER:'@',"ronin",random,hostile
XMONSTER:'@',"ronin",random,hostile
XMONSTER:'@',"ronin",random,hostile
XMONSTER:'@',"ronin",random,hostile
XMONSTER:'d',"wolf",random
XMONSTER:'d',"wolf",random
XMONSTER:'d',"wolf",random
XMONSTER:'d',"wolf",random
XMONSTER:'d',random,random
XMONSTER:'d',random,random
XMONSTER:'I',"stalker",random
XMONSTER:'I',"stalker",random
XMONSTER:'I',"stalker",random
XMONSTER:'I',"stalker",random
XMONSTER:'I',"stalker",random
XMONSTER:'I',"stalker",random
XMONSTER:'I',"stalker",random
XMONSTER:'I',"stalker",random
XMONSTER:'I',random,random
X
X
X#
X#	The "fill" levels for the quest.
X#
X#	These levels are used to fill out any levels not occupied by specific
X#	levels as defined above. "filla" is the upper filler, between the
X#	start and locate levels, and "fillb" the lower between the locate
X#	and goal levels.
X#
X
XMAZE: "S-filla", ' '
XINIT_MAP: '.' , 'P', true, true, random, true
XNOMAP
X# Random Monsters
XRANDOM_MONSTERS: 'd', 'I'
X#
XSTAIR: random, up
XSTAIR: random, down
X#
XOBJECT: random, random, random
XOBJECT: random, random, random
XOBJECT: random, random, random
XOBJECT: random, random, random
XOBJECT: random, random, random
XOBJECT: random, random, random
XOBJECT: random, random, random
XOBJECT: random, random, random
XOBJECT: random, random, random
X#
XMONSTER: 'd', random, random
XMONSTER: 'd', "wolf", random
XMONSTER: 'd', "wolf", random
XMONSTER: 'd', "wolf", random
XMONSTER: 'd', "wolf", random
XMONSTER: 'd', "wolf", random
XMONSTER: 'I', "stalker", random
X#
XTRAP: random, random
XTRAP: random, random
XTRAP: random, random
XTRAP: random, random
X
XMAZE: "S-fillb", ' '
XGEOMETRY:center,center
XMAP
X-------------                                  -------------
X|...........|                                  |...........|
X|...-----...|----------------------------------|...-----...|
X|...|   |...|..................................|...|   |...|
X|...-----..........................................-----...|
X|...........|--S----------------------------S--|...........|
X----...--------.|..........................|.--------...----
X   |...|........+..........................+........|...|   
X   |...|........+..........................+........|...|   
X----...--------.|..........................|.--------...----
X|...........|--S----------------------------S--|...........|
X|...-----..........................................-----...|
X|...|   |...|..................................|...|   |...|
X|...-----...|----------------------------------|...-----...|
X|...........|                                  |...........|
X-------------                                  -------------
XENDMAP
XREGION:(00,00,59,15),unlit,"ordinary"
X# Random Monsters
X#RANDOM_MONSTERS: 'd', 'I'
X#
XSTAIR: random, up
XSTAIR: random, down
X#
XOBJECT: random, random, random
XOBJECT: random, random, random
XOBJECT: random, random, random
XOBJECT: random, random, random
XOBJECT: random, random, random
XOBJECT: random, random, random
XOBJECT: random, random, random
XOBJECT: random, random, random
XOBJECT: random, random, random
X#
XMONSTER: 'd', random, random
XMONSTER: 'd', "wolf", random
XMONSTER: 'd', "wolf", random
XMONSTER: 'd', "wolf", random
XMONSTER: 'd', "wolf", random
XMONSTER: 'I', "stalker", random
XMONSTER: 'I', "stalker", random
XMONSTER: 'I', "stalker", random
X#
XTRAP: random, random
XTRAP: random, random
XTRAP: random, random
XTRAP: random, random
END_OF_FILE
if test 13527 -ne `wc -c <'dat/Samurai.des'`; then
    echo shar: \"'dat/Samurai.des'\" unpacked with wrong size!
fi
# end of 'dat/Samurai.des'
fi
if test -f 'include/trap.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/trap.h'\"
else
echo shar: Extracting \"'include/trap.h'\" \(1140 characters\)
sed "s/^X//" >'include/trap.h' <<'END_OF_FILE'
X/*	SCCS Id: @(#)trap.h	3.1	92/09/28	*/
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X/* note: no longer manipulated by 'makedefs' */
X
X#ifndef TRAP_H
X#define TRAP_H
X
Xstruct trap {
X	struct trap *ntrap;
X	xchar tx,ty;
X	Bitfield(ttyp,5);
X	Bitfield(tseen,1);
X	Bitfield(once,1);
X	d_level dst;	/* destination for portals */
X};
X
Xextern struct trap *ftrap;
X#define newtrap()	(struct trap *) alloc(sizeof(struct trap))
X#define dealloc_trap(trap) free((genericptr_t) (trap))
X
X/* unconditional traps */
X#define NO_TRAP		0
X#define ARROW_TRAP	1
X#define DART_TRAP	2
X#define ROCKTRAP	3
X#define SQKY_BOARD	4
X#define BEAR_TRAP	5
X#define LANDMINE	6
X#define SLP_GAS_TRAP	7
X#define RUST_TRAP	8
X#define FIRE_TRAP	9
X#define PIT		10
X#define SPIKED_PIT	11
X#define TRAPDOOR	12
X#define TELEP_TRAP	13
X#define LEVEL_TELEP	14
X#define MAGIC_PORTAL    15
X#define WEB		16
X#define STATUE_TRAP	17
X#define MAGIC_TRAP	18
X#define ANTI_MAGIC	19
X
X/* conditional feature traps */
X#ifdef POLYSELF
X#define POLY_TRAP	20
X#define TRAPNUM	21
X#else
X#define TRAPNUM	20
X#endif
X
X#endif /* TRAP_H */
END_OF_FILE
if test 1140 -ne `wc -c <'include/trap.h'`; then
    echo shar: \"'include/trap.h'\" unpacked with wrong size!
fi
# end of 'include/trap.h'
fi
if test -f 'src/fountain.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/fountain.c'\"
else
echo shar: Extracting \"'src/fountain.c'\" \(13586 characters\)
sed "s/^X//" >'src/fountain.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)fountain.c	3.1	92/12/19	*/
X/*	Copyright Scott R. Turner, srt@ucla, 10/27/86 */
X/* NetHack may be freely redistributed.  See license for details. */
X
X/* Code for drinking from fountains. */
X
X#include "hack.h"
X
Xstatic void NDECL(dowatersnakes);
Xstatic void NDECL(dowaterdemon);
Xstatic void NDECL(dowaternymph);
XSTATIC_PTR void FDECL(gush, (int,int,genericptr_t));
Xstatic void NDECL(dofindgem);
X
Xstatic void
Xdowatersnakes() /* Fountain of snakes! */
X{
X    register int num = rn1(5,2);
X    struct monst *mtmp;
X
X    if (!(mons[PM_WATER_MOCCASIN].geno & (G_GENOD | G_EXTINCT))) {
X	if (!Blind)
X	    pline("An endless stream of %s pours forth!",
X		  Hallucination ? makeplural(rndmonnam()) : "snakes");
X	else
X	    You("hear something hissing!");
X	while(num-- > 0)
X	    if((mtmp = makemon(&mons[PM_WATER_MOCCASIN],u.ux,u.uy)) &&
X	       t_at(mtmp->mx, mtmp->my))
X		(void) mintrap(mtmp);
X    } else
X	pline("The fountain bubbles furiously for a moment, then calms.");
X}
X
Xstatic
Xvoid
Xdowaterdemon() /* Water demon */
X{
X	register struct monst *mtmp;
X
X	if(mons[PM_WATER_DEMON].geno & (G_GENOD | G_EXTINCT)) return;
X	if((mtmp = makemon(&mons[PM_WATER_DEMON],u.ux,u.uy))) {
X	    if (!Blind)
X		You("have unleashed %s!", a_monnam(mtmp));
X	    else
X		You("feel the presence of evil.");
X
X	/* Give those on low levels a (slightly) better chance of survival */
X	    if ( rnd(100) > (80 + level_difficulty())) {
X		pline("Grateful for %s release, %s grants you a wish!",
X			Blind ? "its" : "his", Blind ? "it" : "he" );
X		makewish();
X		mongone(mtmp);
X	    } else if (t_at(mtmp->mx, mtmp->my))
X		(void) mintrap(mtmp);
X	}
X}
X
Xstatic void
Xdowaternymph() /* Water Nymph */
X{
X	register struct monst *mtmp;
X
X	if(mons[PM_WATER_NYMPH].geno & (G_GENOD | G_EXTINCT)) return;
X	if((mtmp = makemon(&mons[PM_WATER_NYMPH],u.ux,u.uy))) {
X		if (!Blind)
X		   You("have attracted %s!", a_monnam(mtmp));
X		else
X		   You("hear a seductive voice.");
X		mtmp->msleep = 0;
X		if (t_at(mtmp->mx, mtmp->my))
X		    (void) mintrap(mtmp);
X	} else
X		if (!Blind)
X		   pline("A large bubble rises to the surface and pops.");
X		else
X		   You("hear a loud pop.");
X}
X
Xvoid
Xdogushforth(drinking) /* Gushing forth along LOS from (u.ux, u.uy) */
Xint drinking;
X{
X	int madepool = 0;
X
X	do_clear_area(u.ux, u.uy, 7, gush, (genericptr_t)&madepool);
X	if (!madepool)
X	    if (drinking)
X		Your("thirst is quenched.");
X	    else
X		pline("Water sprays all over you.");
X}
X
XSTATIC_PTR void
Xgush(x, y, poolcnt)
Xint x, y;
Xgenericptr_t poolcnt;
X{
X	register struct monst *mtmp;
X
X	if (((x+y)%2) || (x == u.ux && y == u.uy) ||
X	    (rn2(1 + distmin(u.ux, u.uy, x, y)))  ||
X	    (levl[x][y].typ != ROOM) || t_at(x,y) ||
X	    (sobj_at(BOULDER, x, y)) || nexttodoor(x, y))
X		return;
X
X	if (!((*(int *)poolcnt)++))
X	    pline("Water gushes forth from the overflowing fountain!");
X
X	/* Put a pool at x, y */
X
X	levl[x][y].typ = POOL;
X
X	if ((mtmp = m_at(x, y)) != 0)
X		(void) minwater(mtmp);
X	else
X		newsym(x,y);
X}
X
Xstatic void
Xdofindgem() /* Find a gem in the sparkling waters. */
X{
X	if (!Blind) You("spot a gem in the sparkling waters!");
X	(void) mksobj_at(rnd_class(DILITHIUM_CRYSTAL, LUCKSTONE-1),
X						u.ux, u.uy, FALSE);
X	levl[u.ux][u.uy].looted |= F_LOOTED;
X	newsym(u.ux, u.uy);
X	exercise(A_WIS, TRUE);			/* a discovery! */
X}
X
Xvoid
Xdryup(x,y)
Xxchar x, y;
X{
X	boolean isyou = (x == u.ux && y == u.uy);
X
X	if (IS_FOUNTAIN(levl[x][y].typ) &&
X	    (!rn2(3) || (levl[x][y].looted & F_WARNED))) {
X		s_level *slev = Is_special(&u.uz);
X		if(isyou && slev && slev->flags.town &&
X		   !(levl[x][y].looted & F_WARNED)) {
X			struct monst *mtmp;
X			levl[x][y].looted |= F_WARNED;
X			/* Warn about future fountain use. */
X			for(mtmp = fmon; mtmp; mtmp = mtmp->nmon) {
X			    if((mtmp->data == &mons[PM_WATCHMAN] ||
X				mtmp->data == &mons[PM_WATCH_CAPTAIN]) &&
X			       couldsee(mtmp->mx, mtmp->my) &&
X			       mtmp->mpeaceful) {
X				pline("%s yells:", Amonnam(mtmp));
X				verbalize("Hey, stop using that fountain!");
X				break;
X			    }
X			}
X			/* You can see or hear this effect */
X			if(!mtmp) pline("The waterflow reduces to a trickle.");
X			return;
X		}
X#ifdef WIZARD
X		if (isyou && wizard) {
X			if (yn("Dry up fountain?") == 'n')
X				return;
X		}
X#endif
X		if (cansee(x,y)) pline("The fountain dries up!");
X		levl[x][y].typ = ROOM;
X		levl[x][y].looted = 0;
X		levl[x][y].blessedftn = 0;
X		/* The location is seen if the hero/monster is invisible */
X		/* or felt if the hero is blind.			 */
X		newsym(x, y);
X		level.flags.nfountains--;
X		if(isyou && slev && slev->flags.town)
X		    (void) angry_guards(FALSE);
X	}
X}
X
Xvoid
Xdrinkfountain()
X{
X	/* What happens when you drink from a fountain? */
X	register boolean mgkftn = (levl[u.ux][u.uy].blessedftn == 1);
X	register int fate = rnd(30);
X
X	if (Levitation) {
X		You("are floating high above the fountain.");
X		return;
X	}
X
X	if (mgkftn && u.uluck >= 0 && fate >= 10) {
X		int i, ii, littleluck = (u.uluck < 4);
X
X		pline("Wow!  This makes you feel great!");
X		/* blessed restore ability */
X		for (ii = 0; ii < A_MAX; ii++)
X		    if (ABASE(ii) < AMAX(ii)) {
X			ABASE(ii) = AMAX(ii);
X			flags.botl = 1;
X		    }
X		/* gain ability, blessed if "natural" luck is high */
X		i = rn2(A_MAX);		/* start at a random attribute */
X		for (ii = 0; ii < A_MAX; ii++) {
X		    if (adjattrib(i, 1, littleluck ? -1 : 0) && littleluck)
X			break;
X		    if (++i >= A_MAX) i = 0;
X		}
X		display_nhwindow(WIN_MESSAGE, FALSE);
X		pline("A wisp of vapor escapes the fountain....");
X		exercise(A_WIS, TRUE);
X		levl[u.ux][u.uy].blessedftn = 0;
X		return;
X	}
X
X	if (fate < 10) {
X		pline("The cool draught refreshes you.");
X		u.uhunger += rnd(10); /* don't choke on water */
X		newuhs(FALSE);
X		if(mgkftn) return;
X	} else {
X	    switch (fate) {
X
X		case 19: /* Self-knowledge */
X
X			You("feel self-knowledgeable....");
X			display_nhwindow(WIN_MESSAGE, FALSE);
X			enlightenment(FALSE);
X			exercise(A_WIS, TRUE);
X			pline("The feeling subsides.");
X			break;
X
X		case 20: /* Foul water */
X
X			pline("The water is foul!  You gag and vomit.");
X			morehungry(rn1(20, 11));
X			vomit();
X			break;
X
X		case 21: /* Poisonous */
X
X			pline("The water is contaminated!");
X			if (Poison_resistance) {
X#ifdef TUTTI_FRUTTI
X	   pline("Perhaps it is runoff from the nearby %s farm.", pl_fruit);
X#else
X	   pline("Perhaps it is runoff from the nearby orange farm.");
X#endif
X			   losehp(rnd(4),"unrefrigerated sip of juice",
X				KILLED_BY_AN);
X			   break;
X			}
X			losestr(rn1(4,3));
X			losehp(rnd(10),"contaminated water", KILLED_BY);
X			exercise(A_CON, FALSE);
X			break;
X
X		case 22: /* Fountain of snakes! */
X
X			dowatersnakes();
X			break;
X
X		case 23: /* Water demon */
X			dowaterdemon();
X			break;
X
X		case 24: /* Curse an item */ {
X			register struct obj *obj;
X
X			pline("This water's no good!");
X			morehungry(rn1(20, 11));
X			exercise(A_CON, FALSE);
X			for(obj = invent; obj ; obj = obj->nobj)
X				if (!rn2(5))	curse(obj);
X			break;
X			}
X
X		case 25: /* See invisible */
X
X			You("see an image of someone stalking you.");
X			pline("But it disappears.");
X			HSee_invisible |= FROMOUTSIDE;
X			newsym(u.ux,u.uy);
X			exercise(A_WIS, TRUE);
X			break;
X
X		case 26: /* See Monsters */
X
X			(void) monster_detect((struct obj *)0, 0);
X			exercise(A_WIS, TRUE);
X			break;
X
X		case 27: /* Find a gem in the sparkling waters. */
X
X			if (!levl[u.ux][u.uy].looted) {
X				dofindgem();
X				break;
X			}
X
X		case 28: /* Water Nymph */
X
X			dowaternymph();
X			break;
X
X		case 29: /* Scare */ {
X			register struct monst *mtmp;
X
X			pline("This water gives you bad breath!");
X			for(mtmp = fmon; mtmp; mtmp = mtmp->nmon)
X				mtmp->mflee = 1;
X			}
X			break;
X
X		case 30: /* Gushing forth in this room */
X
X			dogushforth(TRUE);
X			break;
X
X		default:
X
X			pline("This tepid water is tasteless.");
X			break;
X	    }
X	}
X	dryup(u.ux, u.uy);
X}
X
Xvoid
Xdipfountain(obj)
Xregister struct obj *obj;
X{
X	if (Levitation) {
X		You("are floating high above the fountain.");
X		return;
X	}
X
X	/* Don't grant Excalibur when there's more than one object.  */
X	/* (quantity could be > 1 if merged daggers got polymorphed) */
X	if (obj->otyp == LONG_SWORD && obj->quan == 1L
X	    && u.ulevel >= 5 && !rn2(6)
X	    && !obj->oartifact
X	    && !exist_artifact(LONG_SWORD, artiname(ART_EXCALIBUR))) {
X		if (u.ualign.type != A_LAWFUL) {
X			/* Ha!  Trying to cheat her. */
X			pline("A freezing mist rises from the water and envelopes the sword.");
X			pline("The fountain disappears!");
X			curse(obj);
X			if (obj->spe > -6 && !rn2(3)) obj->spe--;
X			obj->oerodeproof = FALSE;
X			exercise(A_WIS, FALSE);
X		} else {
X			/* The lady of the lake acts! - Eric Backus */
X			/* Be *REAL* nice */
X	  pline("From the murky depths, a hand reaches up to bless the sword.");
X			pline("As the hand retreats, the fountain disappears!");
X			obj = oname(obj, artiname(ART_EXCALIBUR), 1);
X			bless(obj);
X			obj->oeroded = 0;
X			obj->oerodeproof = TRUE;
X			exercise(A_WIS, TRUE);
X		}
X		levl[u.ux][u.uy].typ = ROOM;
X		levl[u.ux][u.uy].looted = 0;
X		if(Invisible) newsym(u.ux, u.uy);
X		level.flags.nfountains--;
X		return;
X	} else (void) get_wet(obj);
X
X	switch (rnd(30)) {
X		case 16: /* Curse the item */
X			curse(obj);
X			break;
X		case 17:
X		case 18:
X		case 19:
X		case 20: /* Uncurse the item */
X			if(obj->cursed) {
X			    if (!Blind)
X				pline("The water glows for a moment.");
X			    uncurse(obj);
X			} else {
X			    pline("A feeling of loss comes over you.");
X			}
X			break;
X		case 21: /* Water Demon */
X			dowaterdemon();
X			break;
X		case 22: /* Water Nymph */
X			dowaternymph();
X			break;
X		case 23: /* an Endless Stream of Snakes */
X			dowatersnakes();
X			break;
X		case 24: /* Find a gem */
X			dofindgem();
X			break;
X		case 25: /* Water gushes forth */
X			dogushforth(FALSE);
X			break;
X		case 26: /* Strange feeling */
X			pline("A strange tingling runs up your %s.",
X							body_part(ARM));
X			break;
X		case 27: /* Strange feeling */
X			You("feel a sudden chill.");
X			break;
X		case 28: /* Strange feeling */
X			pline("An urge to take a bath overwhelms you.");
X			if (u.ugold > 10) {
X			    u.ugold -= somegold() / 10;
X			    You("lost some of your gold in the fountain!");
X			    levl[u.ux][u.uy].looted &= ~F_LOOTED;
X			    exercise(A_WIS, FALSE);
X			}
X			break;
X		case 29: /* You see coins */
X
X		/* We make fountains have more coins the closer you are to the
X		 * surface.  After all, there will have been more people going
X		 * by.	Just like a shopping mall!  Chris Woodbury  */
X
X		    mkgold((long)
X			(rnd((dunlevs_in_dungeon(&u.uz)-dunlev(&u.uz)+1)*2)+5),
X			u.ux, u.uy);
X		    if (!Blind)
X		pline("Far below you, you see coins glistening in the water.");
X		    exercise(A_WIS, TRUE);
X		    break;
X	}
X	dryup(u.ux, u.uy);
X}
X
X#ifdef SINKS
Xvoid
Xbreaksink(x,y)
Xint x, y;
X{
X    if(cansee(x,y) || (x == u.ux && y == u.uy))
X	pline("The pipes break!  Water spurts out!");
X    level.flags.nsinks--;
X    levl[x][y].doormask = 0;
X    levl[x][y].typ = FOUNTAIN;
X    level.flags.nfountains++;
X    newsym(x,y);
X}
X
Xvoid
Xdrinksink()
X{
X	if (Levitation) {
X		You("are floating high above the sink.");
X		return;
X	}
X	switch(rn2(20)) {
X		static struct obj NEARDATA *otmp;
X		case 0: You("take a sip of very cold water.");
X			break;
X		case 1: You("take a sip of very warm water.");
X			break;
X		case 2: You("take a sip of scalding hot water.");
X			if (Fire_resistance)
X				pline("It seems quite tasty.");
X			else losehp(rnd(6), "sipping boiling water", KILLED_BY);
X			break;
X		case 3: if (mons[PM_SEWER_RAT].geno & (G_GENOD | G_EXTINCT))
X				pline("The sink seems quite dirty.");
X			else {
X				static struct monst NEARDATA *mtmp;
X
X				mtmp = makemon(&mons[PM_SEWER_RAT], u.ux, u.uy);
X				pline("Eek!  There's %s in the sink!",
X					Blind ? "something squirmy" :
X					a_monnam(mtmp));
X			}
X			break;
X		case 4: do {
X				otmp = mkobj(POTION_CLASS,FALSE);
X				if (otmp->otyp == POT_WATER) {
X					obfree(otmp, (struct obj *)0);
X					otmp = (struct obj *) 0;
X				}
X			} while(!otmp);
X			otmp->cursed = otmp->blessed = 0;
X			if (Blind)
X				pline("The sink emits some odd liquid.");
X			else
X				pline("The sink emits a stream of %s water.",
X				    Hallucination ? hcolor() :
X				    OBJ_DESCR(objects[otmp->otyp]));
X			otmp->dknown = !(Blind || Hallucination);
X			otmp->quan++; /* Avoid panic upon useup() */
X			otmp->corpsenm = 1; /* kludge for docall() */
X			(void) dopotion(otmp);
X			obfree(otmp, (struct obj *)0);
X			break;
X		case 5: if (!(levl[u.ux][u.uy].looted & S_LRING)) {
X			    You("find a ring in the sink!");
X			    (void) mkobj_at(RING_CLASS, u.ux, u.uy, TRUE);
X			    levl[u.ux][u.uy].looted |= S_LRING;
X			    exercise(A_WIS, TRUE);
X			} else pline("Some dirty water backs up in the drain.");
X			break;
X		case 6: breaksink(u.ux,u.uy);
X			break;
X		case 7: pline("The water moves as though of its own will!");
X			if ((mons[PM_WATER_ELEMENTAL].geno & (G_GENOD | G_EXTINCT))
X			    || !makemon(&mons[PM_WATER_ELEMENTAL], u.ux, u.uy))
X				pline("But it quiets down.");
X			break;
X		case 8: pline("Yuk, this water tastes awful.");
X			more_experienced(1,0);
X			newexplevel();
X			break;
X		case 9: pline("Gaggg... this tastes like sewage!  You vomit.");
X			morehungry(rn1(30-ACURR(A_CON), 11));
X			vomit();
X			break;
X#ifdef POLYSELF
X		case 10: pline("This water contains toxic wastes!");
X			You("undergo a freakish metamorphosis!");
X			polyself();
X			break;
X#endif
X		/* more odd messages --JJB */
X		case 11: You("hear clanking from the pipes....");
X			break;
X		case 12: You("hear snatches of song from among the sewers....");
X			break;
X		case 19: if (Hallucination) {
X		   pline("From the murky drain, a hand reaches up... --oops--");
X				break;
X			}
X		default: You("take a sip of %s water.",
X			rn2(3) ? (rn2(2) ? "cold" : "warm") : "hot");
X	}
X}
X#endif /* SINKS */
X
X/*fountain.c*/
END_OF_FILE
if test 13586 -ne `wc -c <'src/fountain.c'`; then
    echo shar: \"'src/fountain.c'\" unpacked with wrong size!
fi
# end of 'src/fountain.c'
fi
if test -f 'sys/msdos/exesmurf.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/msdos/exesmurf.c'\"
else
echo shar: Extracting \"'sys/msdos/exesmurf.c'\" \(13628 characters\)
sed "s/^X//" >'sys/msdos/exesmurf.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)exesmurf.c	 3.1	 91/01/29			  */
X/* Copyright (c) Pierre Martineau and Stephen Spackman 1991, 1992, 1993.  */
X/* NetHack may be freely redistributed.  See license for details.	  */
X
X/******************************************************************************
X*                                                                             *
X*                         EXE header list and modify                          *
X*                                                                             *
X*                        by Pierre Martineau, 91/01/29                        *
X*                                                                             *
X*                                Version 1.2                                  *
X*                                                                             *
X>*****************************************************************************<
X* Modified (stephen@estragon.uchicago.edu):                                   *
X* 1990oct23 sps Overlay splitter-outer first cut                              *
X*        31     Error handling; some #defines                                 *
X*     nov01     /l                                                            *
X*   91jan29     Changed default overlay file names to conform to ovlmgr 30a0  *
X******************************************************************************/
X
X#include <string.h>
X#include <stdlib.h>
X#include <stdio.h>
X#include <math.h>
X
X/** parameters ***************************************************************/
X#define MAXFILENAME 128   /* Probably overkill - theoretical limit is 80     */
X#define NPARTS	    36	  /* Maximum # of overlay files (excluding root .EXE)*/
X#define COPYBUFSIZE 32768 /* Fair sized buffer for file copy                 */
X#define BAKEXT      ".BAK"/* Extension for .exe backups                      */
X#define OVLEXT      ".OVL"/* Default extension for overlay files             */
X/* #define MANYZEROES */  /* Old style default: foo00001.ovl, not foo0.ovl   */
X/*****************************************************************************/
X
X#define BOOLEAN int
X#define TRUE    1
X#define FALSE   0
X
Xint sstrccnt(register char const *s, register char c)
X  { int n = 0;
X
X    while (*s) if (*s++ == c) n++;
X    return n;
X  }
X
XFILE *wrkfile, *outfile;
Xlong min, max, stk;
XBOOLEAN listflg = FALSE;
XBOOLEAN verbose = FALSE;
XBOOLEAN minflg = FALSE;
XBOOLEAN maxflg = FALSE;
XBOOLEAN stkflg = FALSE;
X
Xint column = 0;
X
Xstruct exehdr {
Xunsigned signature;
Xunsigned mod512;
Xunsigned pages;
Xunsigned relocitems;
Xunsigned headerparas;
Xunsigned minalloc;
Xunsigned maxalloc;
Xunsigned ss;
Xunsigned sp;
Xunsigned checksum;
Xunsigned ip;
Xunsigned cs;
Xunsigned relocptr;
Xunsigned ovlnum;
X} exehdr_area;
X
Xmain(argc, argv)
Xint argc;
Xchar *argv[];
X{
Xchar *dot, *slash;
Xchar fname[MAXFILENAME], oname[MAXFILENAME], zname[MAXFILENAME];
Xchar *jname = NULL;
Xchar *args;
Xint i;
Xlong offset, oldstk;
Xunsigned nparts = 0, part = 0, partstart[NPARTS + 2];
X
X    printf("EXE list and modify V1.1s, by Pierre Martineau, 90/05/20.\n");
X    printf("This program may be freely distributed.\n");
X
X	if ((argc < 2) || (argc > NPARTS + 2)) {
X        usage();
X        return;
X    }
X
X/*  Process any remaining arguments  */
X
X    if (argc == 2) {
X        listflg = TRUE;
X        verbose = TRUE; /* ??? */
X    }
X    else {
X        i = 2;
X        while (argc-- > 2) {
X            args = argv[i];
X	    if ('0' <= args[0] && args[0] <= '9') { /* File split request */
X			if (nparts >= NPARTS) {
X			printf("\nToo many .OVL files requested (max. %d)\n", NPARTS);
X		    usage();
X		    return;
X		}
X		else if (!atoi(args)) {
X		    printf("\nCan't relocate the root overlay (#0)\n");
X		    usage();
X		    return;
X		}
X		else if (nparts && partstart[nparts - 1] >= atoi(args)) {
X		    printf("\nOverlay starts must be in ascending order\n");
X		    usage();
X		    return;
X		}
X		partstart[nparts++] = atoi(args);
X	    } else {
X		if ((args[0] != '-') && (args[0] != '/')) {
X		    printf("\nInvalid switch in paramater %s!\n", argv[i]);
X			usage();
X			return;
X		}
X		args++;
X		if (strnicmp(args, "min", 3) == 0) {
X		    args += 3;
X		    min = atol(args);
X		    minflg = TRUE;
X		}
X		else if (strnicmp(args, "max", 3) == 0) {
X		    args += 3;
X		    max = atol(args);
X		    maxflg = TRUE;
X		}
X		else if (strnicmp(args, "stk", 3) == 0) {
X		    args += 3;
X		    stk = atol(args);
X		    stkflg = TRUE;
X		}
X		else if (strnicmp(args, "v", 1) == 0) {
X		    listflg = TRUE;
X                    verbose = TRUE;
X                }
X                else if (strnicmp(args, "l", 1) == 0)
X                    listflg = TRUE;
X                else if (strnicmp(args, "p", 1) == 0) {
X                    args++;
X                    jname = args;
X                }
X		else {
X		    printf("\nInvalid paramater %s!\n", argv[i]);
X		    usage();
X		    return;
X		}
X            }
X            i++;
X        }
X    }
X
X/*  Extract filename from first argumemt  */
X
X    strcpy(fname, argv[1]);
X    dot = strrchr(fname, '.');
X    slash = strrchr(fname, '\\');
X    if ((dot == NULL) || (slash > dot))
X        strcat(fname, ".exe");
X
X    if (nparts) {
X	strcpy(oname,fname);
X	*strrchr(fname, '.') = '\0';
X	strcat(fname,BAKEXT);
X	if (!stricmp(oname,fname)) {
X	    printf(
X                "\nI refuse to split a file with extension "BAKEXT": %s\n",
X                oname
X            );
X	    return;
X	}
X        if (!jname || nparts > 1 && !sstrccnt(jname, '?')) {
X            char ext[5];
X            char *t;
X
X            if (!jname) {
X                strcpy(zname, oname);
X                *strrchr(zname, '.') = '\0';
X                strcpy(ext, OVLEXT);
X            } else {
X                if (strrchr(jname, '.') &&
X                     (!strrchr(jname, '\\') ||
X                         strrchr(jname, '.') > strrchr(jname, '\\')
X                     )
X                ) {
X                    strncpy(ext, strrchr(jname, '.'), sizeof(ext));
X                    ext[sizeof(ext) - 1] = '\0';
X                    strncpy(zname, jname, strrchr(jname, '.') - jname);
X                    zname[strrchr(jname, '.') - jname] = '\0';
X                } else {
X                    strcpy(zname, jname);
X                    strcpy(ext, OVLEXT);
X                }
X            }
X            t = strrchr(zname, '\\') ? strrchr(zname, '\\') + 1:
X                strrchr(zname, ':') ? strrchr(zname, ':') + 1:
X                zname;
X            if (strlen(t) >= 8)
X                t[7] = '\0';
X#if defined(MANYZEROES)
X	    while (strlen(t) < 8)
X#endif
X	      strcat(t, "?");
X            strcat(zname, ext);
X            jname = zname;
X        }
X	if (rename(oname,fname)) { /* This assumes oldname, newname.
X				      There's some confusion. OK for TC2.0 */
X	    printf("\nCouldn't rename (original) %s to %s\n", oname, fname);
X	    return;
X	}
X	if ((outfile = fopen(oname, "wb")) == NULL) {
X            printf("\nCouldn't create file %s\n",oname);
X            return;
X        }
X    }
X
X    if ((wrkfile = fopen(fname, "r+b")) == NULL) {
X        printf("\nCouldn't open file %s\n", fname);
X        return;
X    }
X
X    fread(&exehdr_area, sizeof (struct exehdr), 1, wrkfile);
X    if (exehdr_area.signature != 0x5a4d) {
X        printf("\nNot an EXE file!\n");
X        return;
X    }
X
X    while(!feof(wrkfile)) {
X        if (nparts) {
X	    if (exehdr_area.ovlnum == partstart[part]) {
X	         fclose(outfile);
X                 {
X                     int p = part + 1;
X                     strcpy(oname, jname);
X                     while (sstrccnt(oname, '?') > 1) {
X                         *strrchr(oname, '?') = '0' + p % 10;
X                         p /= 10;
X                     }
X                     *strchr(oname, '?') = (p > 9 ? 'a' - 10 : '0') + p;
X                 }
X                 part++;
X		 if ((outfile = fopen(oname, "wb")) == NULL) {
X                     printf("\nCan't open file %s\n", oname);
X                     return;
X                 }
X	    }
X            fwrite(&exehdr_area, sizeof (struct exehdr), 1, outfile);
X            if (ferror(outfile)) {
X                printf("\nWrite error while moving overlay header in %s\n", oname);
X                return;
X            }
X	}
X        if (listflg)
X            show_hdr();
X        else if (nparts)
X            printf("[overlay %d]\r", exehdr_area.ovlnum); /* Keep talking... */
X        if ((minflg || maxflg || stkflg) && (exehdr_area.ovlnum == 0) && (exehdr_area.signature == 0x5a4d)) {
X            if (minflg)
X                exehdr_area.minalloc = min;
X            if (maxflg)
X                exehdr_area.maxalloc = max;
X            if (stkflg) {
X                oldstk = exehdr_area.sp;
X                exehdr_area.sp = stk;
X                if (!minflg) {
X                    exehdr_area.minalloc += ((stk - oldstk) / 16);
X                    printf("\nAdjusting size of minalloc!\n");
X                }
X            }
X            fseek(nparts ? outfile : wrkfile, ftell(wrkfile) - sizeof (struct exehdr), SEEK_SET);
X            fwrite(&exehdr_area, sizeof (struct exehdr), 1, nparts ? outfile : wrkfile);
X            if (ferror(nparts ? outfile : wrkfile)) {
X                printf("Write error while trying to update header!\n");
X                fclose(nparts ? outfile : wrkfile);
X                return;
X            }
X        }
X        offset = exehdr_area.pages;
X        offset *= 512L;
X        offset -= sizeof(struct exehdr);
X        if (nparts) { /* Copy the stuff across */
X	    static char buffer[COPYBUFSIZE];
X	    while (offset > sizeof(buffer)) {
X	         fread(buffer, sizeof(buffer), 1, wrkfile);
X                 if (ferror(wrkfile)) {
X                     printf("\nRead error in overlay body\n");
X                     return;
X                 }
X		 fwrite(buffer, sizeof(buffer), 1, outfile);
X                 if (ferror(outfile)) {
X                     printf("\nWrite error moving overlay body, file %s\n", oname);
X                     return;
X                 }
X		 offset -= sizeof(buffer);
X	    }
X	    fread(buffer, (unsigned)offset, 1, wrkfile);
X            if (ferror(wrkfile)) {
X                printf("\nRead error in overlay body\n");
X                return;
X            }
X            fwrite(buffer, (unsigned)offset, 1, outfile);
X            if (ferror(outfile)) {
X                printf("\nWrite error moving overlay body, file %s\n", oname);
X                return;
X            }
X        } else fseek(wrkfile, offset, SEEK_CUR);
X        fread(&exehdr_area, sizeof (struct exehdr), 1, wrkfile);
X        if (ferror(wrkfile)) {
X            printf("Read error while trying to get a header!\n");
X            fclose(wrkfile);
X            return;
X        }
X    }
X    if (nparts) {
X        fclose(outfile);
X        if (!listflg) printf("                    \r");
X    }
X    fclose(wrkfile);
X    if (listflg && !verbose && column % 4) printf("\n");
X}
X
Xshow_hdr()
X{
Xlong lsize;
X
X    lsize = exehdr_area.pages;
X    if (exehdr_area.mod512 != 0)
X        lsize--;
X    lsize *= 512L;
X    lsize += exehdr_area.minalloc * 16;
X    lsize += exehdr_area.mod512;
X    lsize -= exehdr_area.headerparas * 16;
X
X    if (verbose) {
X        printf("\nOverlay: %d\n", exehdr_area.ovlnum);
X        printf("Size (512 byte pages)\t-%6x\t\t%6u\n", exehdr_area.pages, exehdr_area.pages);
X        printf("Remainder (last page)\t-%6x\t\t%6u\n", exehdr_area.mod512, exehdr_area.mod512);
X        printf("Header size (in paras)\t-%6x\t\t%6u\n", exehdr_area.headerparas, exehdr_area.headerparas);
X        printf("Minalloc (in paras)\t-%6x\t\t%6u\n", exehdr_area.minalloc, exehdr_area.minalloc);
X        printf("Maxalloc (in paras)\t-%6x\t\t%6u\n", exehdr_area.maxalloc, exehdr_area.maxalloc);
X        printf("Load size (in bytes)\t-%6lx\t\t%6lu\n", lsize, lsize);
X        printf("Relocation items\t-%6x\t\t%6u\n", exehdr_area.relocitems, exehdr_area.relocitems);
X        printf("Relocation table offset\t-%6x\t\t%6u\n", exehdr_area.relocptr, exehdr_area.relocptr);
X        printf("Checksum\t\t-%6x\t\t%6u\n", exehdr_area.checksum, exehdr_area.checksum);
X        printf("Initial CS:IP\t\t-  %04x:%04x\n", exehdr_area.cs, exehdr_area.ip);
X        printf("Initial SS:SP\t\t-  %04x:%04x\n", exehdr_area.ss, exehdr_area.sp);
X    } else {
X        if (!exehdr_area.ovlnum) {
X            printf("\nOverlay: %d\n", exehdr_area.ovlnum);
X            printf("Minalloc (in paras)\t-%6x\t\t%6u\n", exehdr_area.minalloc, exehdr_area.minalloc);
X            printf("Maxalloc (in paras)\t-%6x\t\t%6u\n", exehdr_area.maxalloc, exehdr_area.maxalloc);
X            printf("Stored size (in bytes)\t-%6lx\t\t%6lu\n", exehdr_area.pages * 512L, exehdr_area.pages * 512L);
X            printf("Load size (in bytes)\t-%6lx\t\t%6lu\n", lsize, lsize);
X            printf("Initial CS:IP, SS:SP\t-  %04x:%04x\t  %04x:%04x\n", exehdr_area.cs, exehdr_area.ip, exehdr_area.ss, exehdr_area.sp);
X	} else {
X	    static bis = 0;
X	    if (!bis++)
X                printf("\nOvl StrdSz LoadSz | Ovl StrdSz LoadSz | Ovl StrdSz LoadSz | Ovl StrdSz LoadSz\n");
X            printf("%3d:%6lu %6lu%s", exehdr_area.ovlnum, exehdr_area.pages * 512L, lsize, ++column % 4 ? " | " : "\n");
X        }
X    }
X}
X
Xusage()
X{
X    printf("\nUsage: exesmurf exe_file [/l] [/v] [/min#####] [/max#####] [/stk#####]\n");
X    printf("                [n1 n2...nn] [/p????????.???]\n");
X    printf("       where: min   = minalloc\n");
X    printf("              max   = maxalloc\n");
X    printf("              stk   = stack size\n");
X    printf("              ##### = decimal number of paragraphs\n");
X    printf("              ni    = overlay starting each new .OVL file, n1 < n2 <...< nn\n");
X    printf("              p     = DOS filename, maybe with ?s, for overlay files.\n");
X}
END_OF_FILE
if test 13628 -ne `wc -c <'sys/msdos/exesmurf.c'`; then
    echo shar: \"'sys/msdos/exesmurf.c'\" unpacked with wrong size!
fi
# end of 'sys/msdos/exesmurf.c'
fi
if test -f 'sys/vms/gnutparam.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/vms/gnutparam.c'\"
else
echo shar: Extracting \"'sys/vms/gnutparam.c'\" \(11344 characters\)
sed "s/^X//" >'sys/vms/gnutparam.c' <<'END_OF_FILE'
X/* Merge parameters into a termcap entry string.
X   Copyright (C) 1985, 1987 Free Software Foundation, Inc.
X
X
X		       NO WARRANTY
X
X  BECAUSE THIS PROGRAM IS LICENSED FREE OF CHARGE, WE PROVIDE ABSOLUTELY
XNO WARRANTY, TO THE EXTENT PERMITTED BY APPLICABLE STATE LAW.  EXCEPT
XWHEN OTHERWISE STATED IN WRITING, FREE SOFTWARE FOUNDATION, INC,
XRICHARD M. STALLMAN AND/OR OTHER PARTIES PROVIDE THIS PROGRAM "AS IS"
XWITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
XBUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
XFITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY
XAND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE PROGRAM PROVE
XDEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR
XCORRECTION.
X
X IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW WILL RICHARD M.
XSTALLMAN, THE FREE SOFTWARE FOUNDATION, INC., AND/OR ANY OTHER PARTY
XWHO MAY MODIFY AND REDISTRIBUTE THIS PROGRAM AS PERMITTED BELOW, BE
XLIABLE TO YOU FOR DAMAGES, INCLUDING ANY LOST PROFITS, LOST MONIES, OR
XOTHER SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
XUSE OR INABILITY TO USE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR
XDATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY THIRD PARTIES OR
XA FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS) THIS
XPROGRAM, EVEN IF YOU HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH
XDAMAGES, OR FOR ANY CLAIM BY ANY OTHER PARTY.
X
X		GENERAL PUBLIC LICENSE TO COPY
X
X  1. You may copy and distribute verbatim copies of this source file
Xas you receive it, in any medium, provided that you conspicuously and
Xappropriately publish on each copy a valid copyright notice "Copyright
X(C) 1986 Free Software Foundation, Inc."; and include following the
Xcopyright notice a verbatim copy of the above disclaimer of warranty
Xand of this License.  You may charge a distribution fee for the
Xphysical act of transferring a copy.
X
X  2. You may modify your copy or copies of this source file or
Xany portion of it, and copy and distribute such modifications under
Xthe terms of Paragraph 1 above, provided that you also do the following:
X
X    a) cause the modified files to carry prominent notices stating
X    that you changed the files and the date of any change; and
X
X    b) cause the whole of any work that you distribute or publish,
X    that in whole or in part contains or is a derivative of this
X    program or any part thereof, to be licensed at no charge to all
X    third parties on terms identical to those contained in this
X    License Agreement (except that you may choose to grant more extensive
X    warranty protection to some or all third parties, at your option).
X
X    c) You may charge a distribution fee for the physical act of
X    transferring a copy, and you may at your option offer warranty
X    protection in exchange for a fee.
X
XMere aggregation of another unrelated program with this program (or its
Xderivative) on a volume of a storage or distribution medium does not bring
Xthe other program under the scope of these terms.
X
X  3. You may copy and distribute this program (or a portion or derivative
Xof it, under Paragraph 2) in object code or executable form under the terms
Xof Paragraphs 1 and 2 above provided that you also do one of the following:
X
X    a) accompany it with the complete corresponding machine-readable
X    source code, which must be distributed under the terms of
X    Paragraphs 1 and 2 above; or,
X
X    b) accompany it with a written offer, valid for at least three
X    years, to give any third party free (except for a nominal
X    shipping charge) a complete machine-readable copy of the
X    corresponding source code, to be distributed under the terms of
X    Paragraphs 1 and 2 above; or,
X
X    c) accompany it with the information you received as to where the
X    corresponding source code may be obtained.  (This alternative is
X    allowed only for noncommercial distribution and only if you
X    received the program in object code or executable form alone.)
X
XFor an executable file, complete source code means all the source code for
Xall modules it contains; but, as a special exception, it need not include
Xsource code for modules which are standard libraries that accompany the
Xoperating system on which the executable file runs.
X
X  4. You may not copy, sublicense, distribute or transfer this program
Xexcept as expressly provided under this License Agreement.  Any attempt
Xotherwise to copy, sublicense, distribute or transfer this program is void and
Xyour rights to use the program under this License agreement shall be
Xautomatically terminated.  However, parties who have received computer
Xsoftware programs from you with this License Agreement will not have
Xtheir licenses terminated so long as such parties remain in full compliance.
X
X  5. If you wish to incorporate parts of this program into other free
Xprograms whose distribution conditions are different, write to the Free
XSoftware Foundation at 675 Mass Ave, Cambridge, MA 02139.  We have not yet
Xworked out a simple rule that can be stated here, but we will often permit
Xthis.  We will be guided by the two goals of preserving the free status of
Xall derivatives of our free software and of promoting the sharing and reuse of
Xsoftware.
X
X
XIn other words, you are welcome to use, share and improve this program.
XYou are forbidden to forbid anyone else to use, share and improve
Xwhat you give them.   Help stamp out software-hoarding!  */
X
X
X/* config.h may rename various library functions such as malloc.  */
X#ifdef emacs
X#include "config.h"
X#endif
X
X/* Assuming STRING is the value of a termcap string entry
X   containing `%' constructs to expand parameters,
X   merge in parameter values and store result in block OUTSTRING points to.
X   LEN is the length of OUTSTRING.  If more space is needed,
X   a block is allocated with `malloc'.
X
X   The value returned is the address of the resulting string.
X   This may be OUTSTRING or may be the address of a block got with `malloc'.
X   In the latter case, the caller must free the block.
X
X   The fourth and following args to tparam serve as the parameter values.  */
X
Xstatic char *tparam1 ();
X
X/* VARARGS 2 */
Xchar *
Xtparam (string, outstring, len, arg0, arg1, arg2, arg3)
X     char *string;
X     char *outstring;
X     int len;
X     int arg0, arg1, arg2, arg3;
X{
X#ifdef NO_ARG_ARRAY
X  int arg[4];
X  arg[0] = arg0;
X  arg[1] = arg1;
X  arg[2] = arg2;
X  arg[3] = arg3;
X  return tparam1 (string, outstring, len, 0, 0, arg);
X#else
X  return tparam1 (string, outstring, len, 0, 0, &arg0);
X#endif
X}
X
Xchar *BC;
Xchar *UP;
X
Xstatic char tgoto_buf[50];
X
Xchar *
Xtgoto (cm, hpos, vpos)
X     char *cm;
X     int hpos, vpos;
X{
X  int args[2];
X  if (!cm)
X    return 0;
X  args[0] = vpos;
X  args[1] = hpos;
X  return tparam1 (cm, tgoto_buf, 50, UP, BC, args);
X}
X
Xstatic char *
Xtparam1 (string, outstring, len, up, left, argp)
X     char *string;
X     char *outstring;
X     int len;
X     char *up, *left;
X     register int *argp;
X{
X  register int c;
X  register char *p = string;
X  register char *op = outstring;
X  char *outend;
X  int outlen = 0;
X
X  register int tem;
X  int *oargp = argp;
X  int doleft = 0;
X  int doup = 0;
X
X  outend = outstring + len;
X
X  while (1)
X    {
X      /* If the buffer might be too short, make it bigger.  */
X      if (op + 5 >= outend)
X	{
X	  register char *new;
X	  if (outlen == 0)
X	    {
X	      new = (char *) malloc (outlen = 40 + len);
X	      outend += 40;
X	    }
X	  else
X	    {
X	      outend += outlen;
X	      new = (char *) realloc (outstring, outlen *= 2);
X	    }
X	  op += new - outstring;
X	  outend += new - outstring;
X	  outstring = new;
X	}
X      if (!(c = *p++))
X	break;
X      if (c == '%')
X	{
X	  c = *p++;
X	  tem = *argp;
X	  switch (c)
X	    {
X	    case 'd':		/* %d means output in decimal */
X	      if (tem < 10)
X		goto onedigit;
X	      if (tem < 100)
X		goto twodigit;
X	    case '3':		/* %3 means output in decimal, 3 digits. */
X	      if (tem > 999)
X		{
X		  *op++ = tem / 1000 + '0';
X		  tem %= 1000;
X		}
X	      *op++ = tem / 100 + '0';
X	    case '2':		/* %2 means output in decimal, 2 digits. */
X	    twodigit:
X	      tem %= 100;
X	      *op++ = tem / 10 + '0';
X	    onedigit:
X	      *op++ = tem % 10 + '0';
X	      argp++;
X	      break;
X
X	    case 'C':
X	      /* For c-100: print quotient of value by 96, if nonzero,
X		 then do like %+ */
X	      if (tem >= 96)
X		{
X		  *op++ = tem / 96;
X		  tem %= 96;
X		}
X	    case '+':		/* %+x means add character code of char x */
X	      tem += *p++;
X	    case '.':		/* %. means output as character */
X	      if (left)
X		{
X		  /* If want to forbid output of 0 and \n and \t,
X		     and this is one of them, increment it.  */
X		  while (tem == 0 || tem == '\n' || tem == '\t')
X		    {
X		      tem++;
X		      if (argp == oargp)
X			doleft++, outend -= strlen (left);
X		      else
X			doup++, outend -= strlen (up);
X		    }
X		}
X	      *op++ = tem | 0200;
X	    case 'f':		/* %f means discard next arg */
X	      argp++;
X	      break;
X
X	    case 'b':		/* %b means back up one arg (and re-use it) */
X	      argp--;
X	      break;
X
X	    case 'r':		/* %r means interchange following two args */
X	      argp[0] = argp[1];
X	      argp[1] = tem;
X	      oargp++;
X	      break;
X
X	    case '>':		/* %>xy means if arg is > char code of x, */
X	      if (argp[0] > *p++) /* then add char code of y to the arg, */
X		argp[0] += *p;	/* and in any case don't output. */
X	      p++;		/* Leave the arg to be output later. */
X	      break;
X
X	    case 'a':		/* %a means arithmetic */
X	      /* Next character says what operation.
X		 Add or subtract either a constant or some other arg */
X	      /* First following character is + to add or - to subtract
X		 or = to assign.  */
X	      /* Next following char is 'p' and an arg spec
X		 (0100 plus position of that arg relative to this one)
X		 or 'c' and a constant stored in a character */
X	      tem = p[2] & 0177;
X	      if (p[1] == 'p')
X		tem = argp[tem - 0100];
X	      if (p[0] == '-')
X		argp[0] -= tem;
X	      else if (p[0] == '+')
X		argp[0] += tem;
X	      else if (p[0] == '*')
X		argp[0] *= tem;
X	      else if (p[0] == '/')
X		argp[0] /= tem;
X	      else
X		argp[0] = tem;
X
X	      p += 3;
X	      break;
X
X	    case 'i':		/* %i means add one to arg, */
X	      argp[0] ++;	/* and leave it to be output later. */
X	      argp[1] ++;	/* Increment the following arg, too!  */
X	      break;
X
X	    case '%':		/* %% means output %; no arg. */
X	      goto ordinary;
X
X	    case 'n':		/* %n means xor each of next two args with 140 */
X	      argp[0] ^= 0140;
X	      argp[1] ^= 0140;
X	      break;
X
X	    case 'm':		/* %m means xor each of next two args with 177 */
X	      argp[0] ^= 0177;
X	      argp[1] ^= 0177;
X	      break;
X
X	    case 'B':		/* %B means express arg as BCD char code. */
X	      argp[0] += 6 * (tem / 10);
X	      break;
X
X	    case 'D':		/* %D means weird Delta Data transformation */
X	      argp[0] -= 2 * (tem % 16);
X	      break;
X	    }
X	}
X      else
X	/* Ordinary character in the argument string.  */
X      ordinary:
X	*op++ = c;
X    }
X  *op = 0;
X  while (doleft-- > 0)
X    strcpy (op, left);
X  while (doup-- > 0)
X    strcpy (op, up);
X  return outstring;
X}
X
X#ifdef DEBUG
X
Xmain (argc, argv)
X     int argc;
X     char **argv;
X{
X  char buf[50];
X  int args[3];
X  args[0] = atoi (argv[2]);
X  args[1] = atoi (argv[3]);
X  args[2] = atoi (argv[4]);
X  tparam1 (argv[1], buf, "LEFT", "UP", args);
X  printf ("%s\n", buf);
X  return 0;
X}
X
X#endif /* DEBUG */
END_OF_FILE
if test 11344 -ne `wc -c <'sys/vms/gnutparam.c'`; then
    echo shar: \"'sys/vms/gnutparam.c'\" unpacked with wrong size!
fi
# end of 'sys/vms/gnutparam.c'
fi
echo shar: End of archive 89 \(of 108\).
cp /dev/null ark89isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \
21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \
41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 \
61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 \
81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 \
101 102 103 104 105 106 107 108 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 108 archives.
    echo "Now execute 'rebuild.sh'"
    rm -f ark10[0-8]isdone ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
