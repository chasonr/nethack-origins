Path: uunet!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v16i105:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Part97/108
Message-ID: <4470@master.CNA.TEK.COM>
Date: 5 Feb 93 22:03:12 GMT
Sender: news@master.CNA.TEK.COM
Lines: 2265
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1656

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 16, Issue 105
Archive-name: nethack31/Part97
Supersedes: nethack3p9: Volume 10, Issue 46-108
Environment: Amiga, Atari, Mac, MS-DOS, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 97 (of 108)."
# Contents:  doc/dgn_comp.6 include/macconf.h include/tradstdc.h
#   include/trampoli.h src/decl.c sys/unix/unixtty.c
#   sys/unix/unixunix.c
# Wrapped by billr@saab on Wed Jan 27 16:09:27 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'doc/dgn_comp.6' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/dgn_comp.6'\"
else
echo shar: Extracting \"'doc/dgn_comp.6'\" \(6956 characters\)
sed "s/^X//" >'doc/dgn_comp.6' <<'END_OF_FILE'
X.TH DGN_COMP 6 "1 May 1992"
X.UC 4
X.SH NAME
Xdgn_comp \- NetHack dungeon compiler
X.SH SYNOPSIS
X.B dgn_comp
X[
X.I file
X]
X.PP
XIf no arguments are given, it reads standard input.
X.SH DESCRIPTION
X.PP
X.I Dgn_comp
Xis a dungeon compiler for NetHack version 3.1 and higher.  It
Xtakes a description file as an argument and produces a dungeon "script" 
Xthat is to be loaded by NetHack at runtime.
X.PP
XThe purpose of this tool is to provide NetHack administrators and
Ximplementors with a convenient way to create a custom dungeon for the
Xgame, without having to recompile the entire world.
X.SH GRAMMAR
X.PP
XDUNGEON: 
X.B name
X.B bonesmarker
X(
X.B base
X,
X.B rand
X) [
X.B %age
X]
X.PP
Xwhere
X.B name
Xis the dungeon name,
X.B bonesmarker
Xis a letter for marking bones files, (
X.B base
X, 
X.B rand
X) is the number of levels, and
X.B %age
Xis its percentage chance of being generated (if absent, 100% chance).
X
XDESCRIPTION:
X.B tag
X.PP
Xwhere
X.B tag
Xis currently one of
X.BR HELLISH ,
X.BR MAZELIKE ,
Xor
X.BR ROGUELIKE .
X
XALIGNMENT | LEVALIGN: [
X.B lawful
X|
X.B neutral
X|
X.B chaotic
X|
X.B unaligned
X]
X.PP
Xgives the alignment of the dungeon/level (default is unaligned).
X
XENTRY:
X.B level
X.PP
Xthe dungeon entry point.  The dungeon connection attaches at this
Xlevel of the given dungeon.
XIf the value of
X.B level
Xis negative, the entry level is calculated from the bottom of the
Xdungeon, with -1 being the last level.
XIf this line is not present in a dungeon description, the entry level
Xdefaults to 1.
X
XPROTOFILE:
X.B name
X.PP
Xthe prototypical name for dungeon level files in this dungeon.
XFor example, the PROTOFILE name for the dungeon
X.I Vlad's Tower
Xis
X.IR tower .
X
XLEVEL:
X.B name
X.B bonesmarker
X@ (
X.B base
X,
X.B rand
X) [
X.B %age
X]
X.PP
Xwhere
X.B name
Xis the level name,
X.B bonesmarker
Xis a letter for marking bones files, (
X.B base
X, 
X.B rand
X) is the location and
X.B %age
Xis the generation percentage, as above.
X
XRNDLEVEL:
X.B name
X.B bonesmarker
X@ (
X.B base
X,
X.B rand
X)
X[
X.B %age
X]
X.B rndlevs
X.PP
Xwhere
X.B name
Xis the level name,
X.B bonesmarker
Xis a letter for marking bones files, (
X.B base
X, 
X.B rand
X) is the location,
X.B %age
Xis the generation percentage, as above, and
X.B rndlevs
Xis the number of similar levels available to choose from.
X
XCHAINLEVEL:
X.B name
X.B bonesmarker
X.B prev_name
X+ (
X.B base
X,
X.B rand
X) [
X.B %age
X]
X.PP
Xwhere
X.B name
Xis the level name,
X.B bonesmarker
Xis a letter for marking bones files,
X.B prev_name
Xis the name of a level defined previously, (
X.B base
X,
X.B rand
X) is the
X.I offset
Xfrom the level being chained from, and
X.B %age
Xis the generation percentage.
X
XRNDCHAINLEVEL:
X.B name
X.B bonesmarker
X.B prev_name
X+ (
X.B base
X,
X.B rand
X) [
X.B %age
X]
X.B rndlevs
X.PP
Xwhere
X.B name
Xis the level name,
X.B bonesmarker
Xis a letter for marking bones files,
X.B prev_name
Xis the name of a level defined previously, (
X.B base
X,
X.B rand
X) is the
X.I offset
Xfrom the level being chained from,
X.B %age
Xis the generation percentage, and
X.B rndlevs
Xis the number of similar levels available to choose from.
X
XBRANCH:
X.B name
X@ (
X.B base
X,
X.B rand
X) [
X.B stair
X|
X.B no_up
X|
X.B no_down
X|
X.B portal
X] [
X.B up
X|
X.B down
X]
X.PP
Xwhere
X.B name
Xis the name of the dungeon to branch to, and (
X.B base
X,
X.B rand
X) is the location of the branch.
XThe last two optional arguments are
Xthe branch type and branch direction.
XThe type of a branch can be a two-way stair connection,
Xa one-way stair connection, or a magic portal.
XA one-way stair is described by the types
X.B no_up
Xand
X.B no_down
Xwhich specify which stair direction is missing.
XThe default branch type is
X.BR stair .
XThe direction for a stair can be either up or down; direction is not
Xapplicable to portals.  The default direction is
X.BR down .
X
XCHAINBRANCH:
X.B name
X.B prev_name
X+ (
X.B base
X,
X.B rand
X) [
X.B stair
X|
X.B no_up
X|
X.B no_down
X|
X.B portal
X] [
X.B up
X|
X.B down
X]
X.PP
Xwhere
X.B name
Xis the name of the dungeon to branch to,
X.B prev_name
Xis the name of a previously defined
X.B level
Xand (
X.B base
X,
X.B rand
X) is the
X.I offset
Xfrom the level being chained from.
XThe optional branch type and direction are the same as described above.
X.SH GENERIC RULES
X.PP
XEach dungeon must have a unique
X.B bonesmarker ,
Xand each special level must have a
X.B bonesmarker
Xunique within its dungeon (letters may be reused in different dungeons).
XIf the
X.B bonesmarker
Xhas the special value "none", no bones files will be created for that
Xlevel or dungeon.
X.PP
XThe value
X.B base
Xmay be in the range of 1 to
X.B MAXLEVEL
X(as defined in
X.I global.h
X).
X.PP
XThe value
X.B rand
Xmay be in the range of -1 to
X.BR MAXLEVEL .
X.PP
XIf
X.B rand
Xis -1 it will be replaced with the value (num_dunlevs(dungeon) - base)
Xduring the load process (ie. from here to the end of the dungeon).
X.PP
XIf
X.B rand
Xis 0 the level is located absolutely at
X.BR base .
X.PP
XBranches don't have a probability.  Dungeons do.  If a dungeon fails
Xto be generated during load, all its levels and branches are skipped.
X.PP
XNo level or branch may be chained from a level with a percentage generation
Xprobability.  This is to prevent non-resolution during the load.
XIn addition, no branch may be made from a dungeon with a percentage
Xgeneration probability for the same reason.
X.PP
XAs a general rule using the dungeon compiler:
X.PP
XIf a dungeon has a
X.B protofile
Xname associated with it
X.RI ( eg.
X.BR tower )
Xthat file will be used.
X.PP
XIf a special level is present, it will override the above rule and
Xthe appropriate file will be loaded.
X.PP
XIf neither of the above are present, the standard generator will
Xtake over and make a "normal" level.
X.PP
XA level alignment, if present, will override
Xthe alignment of the dungeon that it exists within.
X.SH EXAMPLE
X.PP
XHere is the current syntax of the dungeon compiler's "language":
X
X.LP
X.nf
X.ta +8n +8n +8n
X#
X#	The dungeon description file for the "standard" original
X#	3.0 NetHack.
X#
XDUNGEON:	"The Dungeons of Doom" "D" (25, 5)
XLEVEL:		"rogue" "none" @ (15, 4)
XLEVEL:		"oracle" "none" @ (5, 7)
XLEVEL:		"bigroom" "B" @ (12, 3) 15
XLEVEL:		"medusa" "none" @ (20, 5)
XCHAINLEVEL:	"castle" "medusa" + (1, 4)
XCHAINBRANCH:	"Hell" "castle" + (0, 0) no_down
XBRANCH:		"The Astral Plane" @ (1, 0) no_down up
X
XDUNGEON:	"Hell" "H" (25, 5)
XDESCRIPTION:	mazelike
XDESCRIPTION:	hellish
XBRANCH:		"Vlad's Tower" @ (13, 5) up
XLEVEL:		"wizard" "none" @ (15, 10)
XLEVEL:		"fakewiz" "A" @ (5, 5)
XLEVEL:		"fakewiz" "B" @ (10, 5)
XLEVEL:		"fakewiz" "C" @ (15, 5)
XLEVEL:		"fakewiz" "D" @ (20, 5)
XLEVEL:		"fakewiz" "E" @ (25, 5)
X
XDUNGEON:	"Vlad's Tower" "T" (3, 0)
XPROTOFILE:	"tower"
XDESCRIPTION:	mazelike
XENTRY:		-1
X
XDUNGEON:	"The Astral Plane" "A" (1, 0)
XDESCRIPTION:	mazelike
XPROTOFILE:	"endgame"
X.fi
X.PP
X.I NOTES:
X.br
XLines beginning with '#' are considered comments.
X.br
XA special level must be explicitly aligned.  The alignment of the dungeon
Xit is in only applies to non-special levels within that dungeon.
X.SH AUTHOR
X.PP
XM. Stephenson (from the level compiler by Jean-Christophe Collet).
X.SH "SEE ALSO"
X.PP
Xlev_comp(6), nethack(6)
X.SH BUGS
X.PP
XProbably infinite.
END_OF_FILE
if test 6956 -ne `wc -c <'doc/dgn_comp.6'`; then
    echo shar: \"'doc/dgn_comp.6'\" unpacked with wrong size!
fi
# end of 'doc/dgn_comp.6'
fi
if test -f 'include/macconf.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/macconf.h'\"
else
echo shar: Extracting \"'include/macconf.h'\" \(7871 characters\)
sed "s/^X//" >'include/macconf.h' <<'END_OF_FILE'
X/*	SCCS Id: @(#)macconf.h	3.1	91/07/14	*/
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#ifdef MAC
X# ifndef MACCONF_H
X#  define MACCONF_H
X
X/*
X * Select your compiler...
X * This could probably be automagic later on - I believe there's
X * a unique symbol for MPW at least (it's "macintosh")
X */
X#  define MAC_MPW32		/* Headers, and for avoiding a bug */
X/* #  define MAC_THINKC5	/* Maybe supported now ... */
X
X#  define RANDOM
X#  define NO_SIGNAL	/* You wouldn't believe our signals ... */
X#  define FILENAME 256
X
X#  include "system.h"
X
Xtypedef long off_t ;
X
X/*
X * Try and keep the number of files here to an ABSOLUTE minimum !
X * include the relevant files in the relevant .c files instead !
X */
X#  include <segload.h>
X#  include <stdlib.h>
X#  include <windows.h>
X#  include <memory.h>
X#  include <quickdraw.h>
X#  include <events.h>
X#  include <controls.h>
X#  include <dialogs.h>
X#  include <fonts.h>
X
X/*
X * We could use the PSN under sys 7 here ...
X */
X#  define getpid() 1
X#  define getuid() 1
X#  define index strchr
X#  define rindex strrchr
X
X#  define Rand random
X
X#  define error progerror
X
X# if defined(VISION_TABLES) && defined(BRACES)
X#  undef BRACES
X# endif
X
X/*
X * macfile.c
X * MAC file I/O routines
X */
X
Xextern int maccreat ( const char * name , long fileType ) ;
Xextern int macopen ( const char * name , int flags , long fileType ) ;
Xextern int macclose ( int fd ) ;
Xextern int macread ( int fd , void * ptr , unsigned ) ;
Xextern int macwrite ( int fd , void * ptr , unsigned ) ;
Xextern long macseek ( int fd , long pos , short whence ) ;
X
X
X# if !defined(O_WRONLY)
X#  include <fcntl.h>
X# endif
X
X#if !defined(SPEC_LEV) && !defined(DGN_COMP)
X# define creat maccreat
X# define open macopen
X# define close macclose
X# define read macread
X# define write macwrite
X# define lseek macseek
X#endif
X
X# define TEXT_TYPE 'TEXT'
X# define LEVL_TYPE 'LEVL'
X# define BONE_TYPE 'BONE'
X# define SAVE_TYPE 'SAVE'
X# define PREF_TYPE 'PREF'
X# define DATA_TYPE 'DATA'
X# define MAC_CREATOR 'nh31' /* Registered with DTS ! */
X
Xtypedef struct macdirs {
X	Str32		dataName ;
X	short		dataRefNum ;
X	long		dataDirID ;
X
X	Str32		saveName ;
X	short		saveRefNum ;
X	long		saveDirID ;
X
X	Str32		levelName ;
X	short		levelRefNum ;
X	long		levelDirID ;
X} MacDirs ;
X
Xtypedef struct macflags {
X	Bitfield ( processes , 1 ) ;
X	Bitfield ( color , 1 ) ;
X	Bitfield ( folders , 1 ) ;
X	Bitfield ( tempMem , 1 ) ;
X	Bitfield ( help , 1 ) ;
X	Bitfield ( fsSpec , 1 ) ;
X	Bitfield ( trueType , 1 ) ;
X	Bitfield ( aux , 1 ) ;
X	Bitfield ( alias , 1 ) ;
X	Bitfield ( standardFile , 1 ) ;
X} MacFlags ;
X
Xextern MacDirs theDirs ;
Xextern MacFlags macFlags ;
X
X/*
X * Mac windows
X */
X#define NUM_MACWINDOWS 15
X#define TEXT_BLOCK 512L
X#define WIN_BASE_RES 128
X#define WIN_BASE_KIND 128
X#define NUM_MENU_ITEMS 60 /* We've run out of letters by then ... */
X#define CHAR_ENTER ((char)3)
X#define CHAR_BS ((char)8)
X#define CHAR_LF ((char)10)
X#define CHAR_CR ((char)13)
X#define CHAR_ESC ((char)27)
X#define CHAR_BLANK ((char)32)
X#define CHAR_DELETE ((char)127)
X
X#define MAC_GRAPHICS_ENV
X
X/* Window constants */
X#define kMapWindow 0
X#define kStatusWindow 1
X#define kMessageWindow 2
X#define kTextWindow 3
X#define kMenuWindow 4
X#define kLastWindowKind kMenuWindow
X
Xextern Boolean RetrievePosition ( short , short * , short * ) ;
Xextern Boolean RetrieveSize ( short , short , short , short * , short * ) ;
Xextern void SavePosition ( short , short , short ) ;
Xextern void SaveSize ( short , short , short ) ;
Xextern void SaveWindowPos ( WindowPtr ) ;
Xextern void SaveWindowSize ( WindowPtr ) ;
X
X/*
X * This determines the minimum logical line length in text windows
X * That is; even if physical width is less, this is where line breaks
X * go at the minimum. 350 is about right for score lines with a
X * geneva 10 pt font.
X */
X#define MIN_RIGHT 350
X
X#define NUM_CANCEL_ITEMS 10
X
Xtypedef struct NhWindow {
X	WindowPtr		theWindow ;
X	short			kind ;
X	void			( * keyFunc ) ( EventRecord * , WindowPtr ) ;
X	void			( * clickFunc ) ( EventRecord * , WindowPtr ) ;
X	void			( * updateFunc ) ( EventRecord * , WindowPtr ) ;
X	void			( * cursorFunc ) ( EventRecord * , WindowPtr , RgnHandle ) ;
X	Handle			windowText ;
X	long			windowTextLen ;
X	long			textBase ;
X	Point			cursor ;		/* In CHARS / LINES */
X	short			leading ;
X	short			charHeight ;
X	short			charWidth ;
X	short			fontNum ;
X	short			fontSize ;
X	short			lin ;			/* Used by menus */
X	short			wid ;			/* Used by menus */
X	char			itemChars [ NUM_MENU_ITEMS ] ;
X	char			cancelStr [ NUM_CANCEL_ITEMS ] ;
X	char			cancelChar ;
X	char			clear ;
X	char			cursorDrawn ;
X	short			scrollPos ;
X	ControlHandle	scrollBar ;
X} NhWindow ;
X
X#define NUM_STAT_ROWS 2
X#define NUM_ROWS 22
X#define NUM_COLS 81 /* We shouldn't use column 0 */
X
Xtypedef struct MapData {
X	char		map [ NUM_ROWS ] [ NUM_COLS ] ;
X} MapData ;
X
Xtypedef struct StatusData {
X	char		map [ NUM_STAT_ROWS ] [ NUM_COLS ] ;
X} StatusData ;
X
Xextern NhWindow * theWindows ;
X
Xextern struct window_procs mac_procs ;
X
Xextern short text_wind_font;
X#define set_text_wind_font(fnt) (text_wind_font = fnt)
X#define mono_font()	set_text_wind_font(monaco)
X#define normal_font()	set_text_wind_font(geneva)
X
X#define E extern
X
X/*
X * Define PORT_HELP to be the name of the port-specfic help file.
X * This file is included into the resource fork of the application. 
X */
X#define PORT_HELP "MacHelp"
X
XE void NDECL(port_help);
X
XE void NDECL(mac_init_nhwindows);
XE void NDECL(mac_player_selection);
XE void NDECL(mac_askname);
XE void NDECL(mac_get_nh_event) ;
XE void FDECL(mac_exit_nhwindows, (const char *));
XE void FDECL(mac_suspend_nhwindows, (const char *));
XE void NDECL(mac_resume_nhwindows);
XE winid FDECL(mac_create_nhwindow, (int));
XE void FDECL(mac_clear_nhwindow, (winid));
XE void FDECL(mac_display_nhwindow, (winid, BOOLEAN_P));
XE void FDECL(mac_destroy_nhwindow, (winid));
XE void FDECL(mac_curs, (winid,int,int));
XE void FDECL(mac_putstr, (winid, int, const char *));
XE void FDECL(mac_display_file, (const char *, BOOLEAN_P));
XE void FDECL(mac_start_menu, (winid));
XE void FDECL(mac_add_menu, (winid, CHAR_P, int, const char *));
XE void FDECL(mac_end_menu, (winid, CHAR_P, const char *, const char *));
XE char FDECL(mac_select_menu, (winid));
XE void NDECL(mac_update_inventory);
XE void NDECL(mac_mark_synch);
XE void NDECL(mac_wait_synch);
X#ifdef CLIPPING
XE void FDECL(mac_cliparound, (int, int));
X#endif
XE void FDECL(mac_print_glyph, (winid,XCHAR_P,XCHAR_P,int));
XE void FDECL(mac_raw_print, (const char *));
XE void FDECL(mac_raw_print_bold, (const char *));
XE int NDECL(mac_nhgetch);
XE int FDECL(mac_nh_poskey, (int *, int *, int *));
XE void NDECL(mac_nhbell);
XE int NDECL(mac_doprev_message);
XE char FDECL(mac_yn_function, (const char *, const char *, CHAR_P));
XE void FDECL(mac_getlin, (const char *,char *));
X#ifdef COM_COMPL
XE void FDECL(mac_get_ext_cmd, (char *));
X#endif /* COM_COMPL */
XE void FDECL(mac_number_pad, (int));
XE void NDECL(mac_delay_output);
X
X/* defined in macwin.c and exported for used in mmodal.c */
XE void		FDECL(HandleEvent, (EventRecord *));
X
X/* defined in mmodal.c */
XE DialogPtr FDECL(mv_get_new_dialog, (short));
XE void		FDECL(mv_close_dialog, (DialogPtr));
XE void		FDECL(mv_modal_dialog, (ModalFilterProcPtr, short *));
X
X#undef E
X
Xextern void DimMenuBar ( void ) ;
Xextern void UndimMenuBar ( void ) ;
Xextern int SanePositions ( void ) ;
X
X#define NHW_BASE 0
Xextern winid BASE_WINDOW , WIN_MAP , WIN_MESSAGE , WIN_INVEN , WIN_STATUS ;
X
Xextern Boolean itworked( short );
Xextern void mustwork( short );
Xextern void VDECL(progerror, (const char *,...));
Xextern void attemptingto( char *  );
Xextern void pushattemptingto( char *  );
Xextern void popattempt( void );
Xextern void UnloadAllSegments( void );
Xextern void InitSegMgmt( void * );
Xextern void IsResident ( void * );
Xextern void NotResident ( void * );
X
X# endif /* ! MACCONF_H */
X#endif /* MAC */
END_OF_FILE
if test 7871 -ne `wc -c <'include/macconf.h'`; then
    echo shar: \"'include/macconf.h'\" unpacked with wrong size!
fi
# end of 'include/macconf.h'
fi
if test -f 'include/tradstdc.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/tradstdc.h'\"
else
echo shar: Extracting \"'include/tradstdc.h'\" \(7712 characters\)
sed "s/^X//" >'include/tradstdc.h' <<'END_OF_FILE'
X/*	SCCS Id: @(#)tradstdc.h	3.1	92/04/01	*/
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#ifndef TRADSTDC_H
X#define TRADSTDC_H
X
X#if defined(DUMB) && !defined(NOVOID)
X#define NOVOID
X#endif
X
X#ifdef NOVOID
X#define void int
X#endif
X
X#if defined(__STDC__) && !defined(NOTSTDC)
X#define NHSTDC
X#endif
X
X#if defined(ultrix) && defined(__STDC__) && !defined(__LANGUAGE_C)
X/* Ultrix seems to be in a constant state of flux.  This check attempts to
X * set up ansi compatibility if it wasn't set up correctly by the compiler.
X */
X#ifdef mips
X#define __mips mips
X#endif
X
X#ifdef LANGUAGE_C
X#define __LANGUAGE_C LANGUAGE_C
X#endif
X
X#endif
X
X/*
X * ANSI X3J11 detection.
X * Makes substitutes for compatibility with the old C standard.
X */
X
X/* Decide how to handle variable parameter lists:
X * USE_STDARG means use the ANSI <stdarg.h> facilities (only ANSI compilers
X * should do this, and only if the library supports it).
X * USE_VARARGS means use the <varargs.h> facilities.  Again, this should only
X * be done if the library supports it.  ANSI is *not* required for this.
X * Otherwise, the kludgy old methods are used.
X * The defaults are USE_STDARG for ANSI compilers, and USE_OLDARGS for
X * others.
X */
X
X/* #define USE_VARARGS		/* use <varargs.h> instead of <stdarg.h> */
X/* #define USE_OLDARGS		/* don't use any variable argument facilites */
X
X#if defined(apollo)             /* Apollos have stdarg(3) but not stdarg.h */
X# define USE_VARARGS
X#endif
X
X#if defined(NHSTDC) || defined(ULTRIX_PROTO) || defined(MAC)
X# if !defined(USE_VARARGS) && !defined(USE_OLDARGS) && !defined(USE_STDARG)
X#   define USE_STDARG
X# endif
X#endif
X
X#ifdef NEED_VARARGS		/* only define these if necessary */
X#ifdef USE_STDARG
X# include <stdarg.h>
X# define VA_DECL(typ1,var1)	(typ1 var1, ...) { va_list the_args;
X# define VA_DECL2(typ1,var1,typ2,var2)	\
X	(typ1 var1, typ2 var2, ...) { va_list the_args;
X# define VA_INIT(var1,typ1)
X# define VA_NEXT(var1,typ1)	var1 = va_arg(the_args, typ1)
X# define VA_ARGS		the_args
X# define VA_START(x)		va_start(the_args, x)
X# define VA_END()		va_end(the_args)
X# if defined(ULTRIX_PROTO) && !defined(_VA_LIST_)
X#  define _VA_LIST_	/* prevents multiple def in stdio.h */
X# endif
X#else
X# ifdef USE_VARARGS
X#  include <varargs.h>
X#  define VA_DECL(typ1,var1)	(va_alist) va_dcl {\
X		va_list the_args; typ1 var1;
X#  define VA_DECL2(typ1,var1,typ2,var2)	(va_alist) va_dcl {\
X		va_list the_args; typ1 var1; typ2 var2;
X#  define VA_ARGS		the_args
X#  define VA_START(x)		va_start(the_args)
X#  define VA_INIT(var1,typ1)	var1 = va_arg(the_args, typ1)
X#  define VA_NEXT(var1,typ1)	var1 = va_arg(the_args,typ1)
X#  define VA_END()		va_end(the_args)
X# else
X#   define VA_ARGS	arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9
X#   define VA_DECL(typ1,var1)  (var1,VA_ARGS) typ1 var1; \
X	char *arg1,*arg2,*arg3,*arg4,*arg5,*arg6,*arg7,*arg8,*arg9; {
X#   define VA_DECL2(typ1,var1,typ2,var2)  (var1,var2,VA_ARGS) \
X	typ1 var1; typ2 var2;\
X	char *arg1,*arg2,*arg3,*arg4,*arg5,*arg6,*arg7,*arg8,*arg9; {
X#   define VA_START(x)
X#   define VA_INIT(var1,typ1)
X#   define VA_END()
X# endif
X#endif
X#endif /* NEED_VARARGS */
X
X#if defined(NHSTDC) || defined(MSDOS) || defined(MAC) || defined(ULTRIX_PROTO)
X
X/*
X * Used for robust ANSI parameter forward declarations:
X * int VDECL(sprintf, (char *, const char *, ...));
X *
X * NDECL() is used for functions with zero arguments;
X * FDECL() is used for functions with a fixed number of arguments;
X * VDECL() is used for functions with a variable number of arguments.
X * Separate macros are needed because ANSI will mix old-style declarations
X * with prototypes, except in the case of varargs, and the OVERLAY-specific
X * trampoli.* mechanism conflicts with the ANSI <<f(void)>> syntax.
X */
X
X# define NDECL(f)	f(void)	/* Must be overridden if OVERLAY set later */
X
X# define FDECL(f,p)	f p
X
X# if defined(MSDOS) || defined(USE_STDARG)
X#  define VDECL(f,p)	f p
X# else
X#  define VDECL(f,p)	f()
X# endif
X
X/* generic pointer, always a macro; genericptr_t is usually a typedef */
X# define genericptr	void *
X
X# if defined(__TURBOC__) || (defined(ULTRIX_PROTO) && !defined(__GNUC__)) || defined(OS2_CSET2)
X/* Cover for stupid Turbo C */
X/* And Ultrix on a DECstation with 2.0 compiler, which coredumps on
X *   typedef void * genericptr_t;
X *   extern void a(void(*)(int, genericptr_t));
X * Using the #define is OK for other compiler versions too.
X */
X/* And IBM CSet/2.  The redeclaration of free hoses the compile. */
X#  define genericptr_t	genericptr
X# else
X#  if !defined(NHSTDC) && !defined(MAC)
X#   define const
X#   define signed
X#   define volatile
X#  endif
X# endif
X
X# if !defined(LATTICE) && !defined(MAC)
X		/* Lattice can't even PARSE the const below! */
X		/* MPW can parse but expects an identifier, not a keyword... */
X#  if defined(ULTRIX_PROTO) && !defined(NHSTDC) && !defined(const)
X#  define const		/* the system header files are *not* __STDC__ */
X#  endif
X#  if defined(apollo) && !defined(const)
X#  define const         /* too much trouble with printf(char *format, ...) */
X#  endif                 /* instead of printf(const char *format, ...) etc. */
X# endif
X
X#else /* NHSTDC */	/* a "traditional" C  compiler */
X
X# define NDECL(f)	f()
X# define FDECL(f,p)	f()
X# define VDECL(f,p)	f()
X
X# if defined(AMIGA) || defined(HPUX) || defined(POSIX_TYPES) || defined(__DECC)
X#  define genericptr	void *
X# endif
X# ifndef genericptr
X#  define genericptr	char *
X# endif
X
X/*
X * Traditional C compilers don't have "signed", "const", or "volatile".
X */
X# define signed
X# define const
X# define volatile
X
X#endif /* NHSTDC */
X
X
X#ifndef genericptr_t
Xtypedef genericptr genericptr_t;	/* (void *) or (char *) */
X#endif
X
X
X/*
X * According to ANSI, prototypes for old-style declarations must widen the
X * arguments to int.  However, the MSDOS compilers accept shorter arguments
X * (char, short, etc.) in prototypes and do typechecking with them.  Therefore
X * this mess to allow the better typechecking while also allowing some
X * prototypes for the ANSI compilers so people quit trying to fix the
X * prototypes to match the standard and thus lose the typechecking.
X */
X#if defined(MSDOS) && !defined(__TURBOC__) && !defined(__GO32__)
X#define UNWIDENED_PROTOTYPES
X#endif
X#if defined(AMIGA) && !defined(AZTEC_50)
X#define UNWIDENED_PROTOTYPES
X#endif
X#if defined(MAC) && !defined(THINK_C)
X#define UNWIDENED_PROTOTYPES
X#endif
X
X#if defined(ULTRIX_PROTO) && defined(ULTRIX_CC20)
X#define UNWIDENED_PROTOTYPES
X#endif
X#if defined(apollo)
X#define UNWIDENED_PROTOTYPES
X#endif
X
X#ifndef UNWIDENED_PROTOTYPES
X# if defined(NHSTDC) || defined(__TURBOC__) || defined(ULTRIX_PROTO) || defined(THINK_C)
X# define WIDENED_PROTOTYPES
X# endif
X#endif
X
X#if defined(sgi) && !defined(__GNUC__)
X/*
X * As of IRIX 4.0.1, /bin/cc claims to be an ANSI compiler, but it thinks
X * it's impossible for a prototype to match an old-style definition with
X * unwidened argument types.  Thus, we have to turn off all NetHack
X * prototypes, and avoid declaring several system functions, since the system
X * include files have prototypes and the compiler also complains that
X * prototyped and unprototyped declarations don't match.
X */
X# undef NDECL
X# undef FDECL
X# undef VDECL
X# define NDECL(f)	f()
X# define FDECL(f,p)	f()
X# define VDECL(f,p)	f()
X#endif
X
X
X#ifdef __HC__	/* MetaWare High-C defaults to unsigned chars */
X# undef signed
X#endif
X
X
X/*
X * Allow gcc2 to check parameters of printf-like calls with -Wformat;
X * append this to a prototype declaration (see pline() in extern.h).
X */
X#ifdef __GNUC__
X# if __GNUC__ >= 2
X#define PRINTF_F(f,v) __attribute__ ((format (printf, f, v)))
X# endif
X#endif
X#ifndef PRINTF_F
X#define PRINTF_F(f,v)
X#endif
X
X#endif /* TRADSTDC_H */
END_OF_FILE
if test 7712 -ne `wc -c <'include/tradstdc.h'`; then
    echo shar: \"'include/tradstdc.h'\" unpacked with wrong size!
fi
# end of 'include/tradstdc.h'
fi
if test -f 'include/trampoli.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/trampoli.h'\"
else
echo shar: Extracting \"'include/trampoli.h'\" \(7978 characters\)
sed "s/^X//" >'include/trampoli.h' <<'END_OF_FILE'
X/*	SCCS Id: @(#)trampoli.h 	3.1	92/10/06	  */
X/* Copyright (c) 1989, by Norm Meluch and Stephen Spackman	  */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#ifndef TRAMPOLI_H
X#define TRAMPOLI_H
X
X#ifdef OVERLAY
X
X/* ### apply.c ### */
X#define dig()     dig_()
X#define doapply() doapply_()
X#define dojump()  dojump_()
X#define dorub()   dorub_()
X
X
X/* ### cmd.c ### */
X#define doextcmd()         doextcmd_()
X#define doextlist()        doextlist_()
X#ifdef POLYSELF
X#define domonability()     domonability_()
X#endif /* POLYSELF */
X#ifdef EXPLORE_MODE
X#define enter_explore_mode() enter_explore_mode_()
X#endif /* EXPLORE_MODE */
X#define doprev_message() doprev_message_()
X#define timed_occupation() timed_occupation_()
X#if defined(WIZARD) || defined(EXPLORE_MODE)
X#define wiz_attributes()   wiz_attributes_()
X#endif
X#ifdef WIZARD
X#define wiz_detect()       wiz_detect_()
X#define wiz_genesis()      wiz_genesis_()
X#define wiz_identify()     wiz_identify_()
X#define wiz_level_tele()   wiz_level_tele_()
X#define wiz_map()          wiz_map_()
X#define wiz_where()        wiz_where_()
X#define wiz_wish()         wiz_wish_()
X#endif
X
X/* ### display.c ### */
X#define doredraw() doredraw_()
X
X/* ### do.c ### */
X#define doddrop()  doddrop_()
X#define dodown()   dodown_()
X#define dodrop()   dodrop_()
X#define donull()   donull_()
X#define doup()     doup_()
X#define dowipe()   dowipe_()
X#define drop(x)    drop_(x)
X#define wipeoff()  wipeoff_()
X
X
X/* ### do_name.c ### */
X#define ddocall()  ddocall_()
X#define do_mname() do_mname_()
X
X
X/* ### do_wear.c ### */
X#define Armor_off()   Armor_off_()
X#define Boots_off()   Boots_off_()
X#define Gloves_off()  Gloves_off_()
X#define Helmet_off()  Helmet_off_()
X#define Armor_on()    Armor_on_()
X#define Boots_on()    Boots_on_()
X#define Gloves_on()   Gloves_on_()
X#define Helmet_on()   Helmet_on_()
X#define doddoremarm() doddoremarm_()
X#define doputon()     doputon_()
X#define doremring()   doremring_()
X#define dotakeoff()   dotakeoff_()
X#define dowear()      dowear_()
X#define select_off(x) select_off_(x)
X#define take_off()    take_off_()
X
X
X/* ### dogmove.c ### */
X#define wantdoor(x, y, dummy) wantdoor_(x, y, dummy)
X
X
X/* ### dokick.c ### */
X#define dokick() dokick_()
X
X
X/* ### dothrow.c ### */
X#define dothrow() dothrow_()
X
X
X/* ### eat.c ### */
X#define Hear_again() Hear_again_()
X#define eatmdone()   eatmdone_()
X#define doeat()      doeat_()
X#define eatfood()    eatfood_()
X#define opentin()    opentin_()
X#define unfaint()    unfaint_()
X
X
X/* ### end.c ### */
X#define done1()     done1_()
X#define done2()     done2_()
X#define hangup()    hangup_()
X#define done_intr() done_intr_()
X#if defined(UNIX) || defined (VMS)
X#define done_hangup() done_hangup_()
X#endif /* UNIX || VMS */
X
X
X/* ### engrave.c ### */
X#define doengrave() doengrave_()
X
X
X/* ### fountain.c ### */
X#define gush(x, y, poolcnt) gush_(x, y, poolcnt)
X
X
X/* ### hack.c ### */
X#define dopickup() dopickup_()
X#define identify(x) identify_(x)
X
X
X/* ### invent.c ### */
X#define ckunpaid(x)  ckunpaid_(x)
X#define ddoinv()     ddoinv_()
X#define dolook()     dolook_()
X#define dopramulet() dopramulet_()
X#define doprarm()    doprarm_()
X#define doprgold()   doprgold_()
X#define doprring()   doprring_()
X#define doprtool()   doprtool_()
X#define doprwep()    doprwep_()
X#define dotypeinv()  dotypeinv_()
X#define doorganize() doorganize_()
X
X
X/* ### ioctl.c ### */
X#ifdef UNIX
X# ifdef SUSPEND
X#define dosuspend() dosuspend_()
X# endif /* SUSPEND */
X#endif /* UNIX */
X
X
X/* ### lock.c ### */
X#define doclose()   doclose_()
X#define doforce()   doforce_()
X#define doopen()    doopen_()
X#define forcelock() forcelock_()
X#define picklock()  picklock_()
X
X
X/* ### mklev.c ### */
X#define do_comp(x, y)  comp_(x, y)
X
X
X/* ### mondata.c ### */
X/* See comment in trampoli.c before uncommenting canseemon. */
X/* #define canseemon(x)	canseemon_(x) */
X
X
X/* ### muse.c ### */
X#define mbhitm(x, y) mbhitm_(x, y)
X
X
X/* ### o_init.c ### */
X#define dodiscovered() dodiscovered_()
X
X
X/* ### objnam.c ### */
X#define doname(x)   doname_(x)
X#define xname(x)    xname_(x)
X
X
X/* ### options.c ### */
X#define doset()          doset_()
X#define dotogglepickup() dotogglepickup_()
X
X
X/* ### pager.c ### */
X#define dohelp()     dohelp_()
X#define dohistory()  dohistory_()
X#ifdef UNIX
X#define intruph()    intruph_()
X#endif /* UNIX */
X#define dowhatdoes() dowhatdoes_()
X#define dowhatis()   dowhatis_()
X#define doquickwhatis()   doquickwhatis_()
X
X
X/* ### pcsys.c ### */
X#ifdef SHELL
X#define dosh()       dosh_()
X#endif /* SHELL */
X
X
X/* ### pickup.c ### */
X#define ck_bag(x)        ck_bag_(x)
X#define doloot()         doloot_()
X#define in_container(x)  in_container_(x)
X#define out_container(x) out_container_(x)
X
X
X/* ### potion.c ### */
X#define dodrink() dodrink_()
X#define dodip()   dodip_()
X
X
X/* ### pray.c ### */
X#define doturn()      doturn_()
X#define dopray()      dopray_()
X#define prayer_done() prayer_done_()
X#define dosacrifice() dosacrifice_()
X
X
X/* ### read.c ### */
X#define doread()	   doread_()
X#define set_lit(x, y, val) set_lit_(x, y, val)
X
X
X/* ### save.c ### */
X#define dosave() dosave_()
X
X
X/* ### search.c ### */
X#define doidtrap()	     doidtrap_()
X#define dosearch()	     dosearch_()
X#define findone(zx, zy, num) findone_(zx, zy, num)
X#define openone(zx, zy, num) openone_(zx, zy, num)
X
X
X/* ### shk.c ### */
X#define dopay() dopay_()
X
X
X/* ### sit.c ### */
X#define dosit() dosit_()
X
X
X/* ### sounds.c ### */
X#define dotalk() dotalk_()
X
X
X/* ### spell.c ### */
X#define learn()    learn_()
X#define docast()   docast_()
X#define dovspell() dovspell_()
X
X
X/* ### steal.c ### */
X#define stealarm() stealarm_()
X
X
X/* ### trap.c ### */
X#define dotele()     dotele_()
X#define dountrap()   dountrap_()
X#define float_down() float_down_()
X
X
X/* ### version.c ### */
X#define doversion()    doversion_()
X#define doextversion() doextversion_()
X
X
X/* ### wield.c ### */
X#define dowield() dowield_()
X
X
X/* ### zap.c ### */
X#define bhitm(x, y) bhitm_(x, y)
X#define bhito(x, y) bhito_(x, y)
X#define dozap()     dozap_()
X
X
X/* ### getline.c ### */
X#define tty_getlin(x,y)			tty_getlin_(x,y)
X#ifdef COM_COMPL
X#define tty_get_ext_cmd(x)		tty_get_ext_cmd_(x)
X#endif /* COM_COMPL */
X
X
X/* ### termcap.c ### */
X#define tty_nhbell()			tty_nhbell_()
X#define tty_number_pad(x)		tty_number_pad_(x)
X#define tty_delay_output()		tty_delay_output_()
X#define tty_start_screen()		tty_start_screen_()
X#define tty_end_screen()		tty_end_screen_()
X
X
X/* ### topl.c ### */
X#define tty_doprev_message()		tty_doprev_message_()
X#define tty_yn_function(x,y,z)		tty_yn_function_(x,y,z)
X
X
X/* ### wintty.c ### */
X#define tty_init_nhwindows()		tty_init_nhwindows_()
X#define tty_player_selection()		tty_player_selection_()
X#define tty_askname()			tty_askname_()
X#define tty_get_nh_event()		tty_get_nh_event_()
X#define tty_exit_nhwindows(x)		tty_exit_nhwindows_(x)
X#define tty_suspend_nhwindows(x)	tty_suspend_nhwindows_(x)
X#define tty_resume_nhwindows()		tty_resume_nhwindows_()
X#define tty_create_nhwindow(x)		tty_create_nhwindow_(x)
X#define tty_clear_nhwindow(x)		tty_clear_nhwindow_(x)
X#define tty_display_nhwindow(x,y)	tty_display_nhwindow_(x,y)
X#define tty_destroy_nhwindow(x)		tty_destroy_nhwindow_(x)
X#define tty_curs(x,y,z)			tty_curs_(x,y,z)
X#define tty_putstr(x,y,z)		tty_putstr_(x,y,z)
X#define tty_display_file(x,y)		tty_display_file_(x,y)
X#define tty_start_menu(x)		tty_start_menu_(x)
X#define tty_add_menu(a,b,c,d)		tty_add_menu_(a,b,c,d)
X#define tty_end_menu(a,b,c,d)		tty_end_menu_(a,b,c,d)
X#define tty_select_menu(x)		tty_select_menu_(x)
X#define tty_update_inventory()		tty_update_inventory_()
X#define tty_mark_synch()		tty_mark_synch_()
X#define tty_wait_synch()		tty_wait_synch_()
X#ifdef CLIPPING
X#define tty_cliparound(x,y)		tty_cliparound_(x,y)
X#endif
X#define tty_print_glyph(a,b,c,d)	tty_print_glyph_(a,b,c,d)
X#define tty_raw_print(x)		tty_raw_print_(x)
X#define tty_raw_print_bold(x)		tty_raw_print_bold_(x)
X#define tty_nhgetch()			tty_nhgetch_()
X#define tty_nh_poskey(x,y,z)		tty_nh_poskey_(x,y,z)
X
X#endif /* OVERLAY */
X
X#endif /* TRAMPOLI_H */
END_OF_FILE
if test 7978 -ne `wc -c <'include/trampoli.h'`; then
    echo shar: \"'include/trampoli.h'\" unpacked with wrong size!
fi
# end of 'include/trampoli.h'
fi
if test -f 'src/decl.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/decl.c'\"
else
echo shar: Extracting \"'src/decl.c'\" \(7545 characters\)
sed "s/^X//" >'src/decl.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)decl.c	3.1	92/12/11	*/
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include	"hack.h"
X
Xint NDECL((*afternmv));
Xint NDECL((*occupation));
X
X/* from xxxmain.c */
Xconst char *hname = 0;		/* name of the game (argv[0] of main) */
Xint hackpid = 0;		/* current process id */
X#if defined(UNIX) || defined(VMS)
Xint locknum = 0;		/* max num of simultaneous users */
X#endif
X#ifdef DEF_PAGER
Xchar *catmore = 0;		/* default pager */
X#endif
X
Xint NEARDATA bases[MAXOCLASSES] = DUMMY;
X
Xint NEARDATA multi = 0;
Xint NEARDATA warnlevel = 0;		/* used by movemon and dochugw */
Xint NEARDATA nroom = 0;
Xint NEARDATA nsubroom = 0;
Xint NEARDATA occtime = 0;
X
Xint x_maze_max, y_maze_max;	/* initialized in main, used in mkmaze.c */
Xint otg_temp;			/* used by object_to_glyph() [otg] */
X
X#ifdef REDO
Xint NEARDATA in_doagain = 0;
X#endif
X
X/*
X *	The following structure will be initialized at startup time with
X *	the level numbers of some "important" things in the game.
X */
Xstruct dgn_topology dungeon_topology = {DUMMY};
X
X#ifdef MULDGN
X#include	"quest.h"
Xstruct q_score	quest_status = DUMMY;
X#endif
X
Xint NEARDATA smeq[MAXNROFROOMS+1] = DUMMY;
Xint NEARDATA doorindex = 0;
X
Xchar NEARDATA *save_cm = 0;
Xint NEARDATA killer_format = 0;
Xconst char NEARDATA *killer = 0;
Xconst char NEARDATA *nomovemsg = 0;
Xconst char NEARDATA nul[40] = DUMMY;		/* contains zeros */
Xchar NEARDATA plname[PL_NSIZ] = DUMMY;		/* player name */
Xchar NEARDATA pl_character[PL_CSIZ] = DUMMY;
X
X#ifdef TUTTI_FRUTTI
Xchar NEARDATA pl_fruit[PL_FSIZ] = DUMMY;
Xint NEARDATA current_fruit = 0;
Xstruct fruit NEARDATA *ffruit = (struct fruit *)0;
X#endif
X
Xchar NEARDATA tune[6] = DUMMY;
X
Xconst char NEARDATA *occtxt = DUMMY;
Xconst char NEARDATA quitchars[] = " \r\n\033";
Xconst char NEARDATA vowels[] = "aeiouAEIOU";
Xconst char NEARDATA ynchars[] = "yn";
Xconst char NEARDATA ynqchars[] = "ynq";
Xconst char NEARDATA ynaqchars[] = "ynaq";
Xconst char NEARDATA ynNaqchars[] = "yn#aq";
Xlong NEARDATA yn_number = 0L;
X
X#ifdef MICRO
Xchar hackdir[PATHLEN];		/* where rumors, help, record are */
Xchar levels[PATHLEN];		/* where levels are */
X#endif /* MICRO */
X
X#define INFOSIZE	MAXLEVEL * MAXDUNGEON
X
X#ifdef MFLOPPY
Xchar permbones[PATHLEN];	/* where permanent copy of bones go */
Xint ramdisk = FALSE;		/* whether to copy bones to levels or not */
Xint saveprompt = TRUE;
Xstruct finfo fileinfo[INFOSIZE];
Xconst char *alllevels = "levels.*";
Xconst char *allbones = "bones*.*";
X#else
Xboolean level_exists[INFOSIZE];
X#endif
X
X#undef INFOSIZE
X
X/* 'rogue'-like direction commands (cmd.c) */
Xconst char NEARDATA sdir[] = "hykulnjb><";
Xconst char NEARDATA ndir[] = "47896321><";	/* number pad mode */
Xconst schar NEARDATA xdir[10] = { -1,-1, 0, 1, 1, 1, 0,-1, 0, 0 };
Xconst schar NEARDATA ydir[10] = {  0,-1,-1,-1, 0, 1, 1, 1, 0, 0 };
Xconst schar zdir[10]	      = {  0, 0, 0, 0, 0, 0, 0, 0, 1,-1 };
X
Xschar NEARDATA tbx = 0, NEARDATA tby = 0;	/* mthrowu: target */
Xint NEARDATA dig_effort = 0;	/* effort expended on current pos */
Xd_level NEARDATA dig_level = { 0, 0 };
Xcoord NEARDATA dig_pos = DUMMY;
Xboolean NEARDATA dig_down = FALSE;
X
Xdungeon NEARDATA dungeons[MAXDUNGEON];	/* ini'ed by init_dungeon() */
Xs_level NEARDATA *sp_levchn;
Xint NEARDATA done_stopprint = 0;
Xint NEARDATA done_hup = 0;
Xstairway NEARDATA upstair = { 0, 0 }, NEARDATA dnstair = { 0, 0 };
Xstairway NEARDATA upladder = { 0, 0 }, NEARDATA dnladder = { 0, 0 };
Xstairway NEARDATA sstairs = { 0, 0 };
Xdest_area NEARDATA updest = { 0, 0, 0, 0, 0, 0, 0, 0 };
Xdest_area NEARDATA dndest = { 0, 0, 0, 0, 0, 0, 0, 0 };
Xcoord NEARDATA inv_pos = { 0, 0 };
X
Xboolean NEARDATA in_mklev = FALSE;
Xboolean	NEARDATA stoned = FALSE;	/* done to monsters hit by 'c' */
Xboolean	NEARDATA unweapon = FALSE;
Xboolean NEARDATA mrg_to_wielded = FALSE;
X			 /* weapon picked is merged with wielded one */
X
X#ifdef KOPS
Xboolean NEARDATA allow_kops = TRUE;
X#endif
X
Xcoord NEARDATA bhitpos = DUMMY;
Xcoord NEARDATA doors[DOORMAX] = {DUMMY};
X
Xstruct mkroom NEARDATA rooms[(MAXNROFROOMS+1)*2] = {DUMMY};
Xstruct mkroom* NEARDATA subrooms = &rooms[MAXNROFROOMS+1];
Xstruct mkroom *upstairs_room, *dnstairs_room, *sstairs_room;
X
Xdlevel_t level;		/* level map */
Xstruct trap *ftrap = (struct trap *)0;
Xstruct monst NEARDATA youmonst = DUMMY;
Xstruct flag NEARDATA flags = DUMMY;
Xstruct you NEARDATA u = DUMMY;
X
Xstruct obj NEARDATA *invent = (struct obj *)0, 
X        NEARDATA *uwep = (struct obj *)0, NEARDATA *uarm = (struct obj *)0,
X#ifdef TOURIST
X	NEARDATA *uarmu = (struct obj *)0, /* under-wear, so to speak */
X#endif
X#ifdef POLYSELF
X	NEARDATA *uskin = (struct obj *)0, /* dragon armor, if a dragon */
X#endif
X	NEARDATA *uarmc = (struct obj *)0, NEARDATA *uarmh = (struct obj *)0, 
X        NEARDATA *uarms = (struct obj *)0, NEARDATA *uarmg = (struct obj *)0,
X        NEARDATA *uarmf = (struct obj *)0, NEARDATA *uamul = (struct obj *)0,
X	NEARDATA *uright = (struct obj *)0,
X        NEARDATA *uleft = (struct obj *)0,
X        NEARDATA *ublindf = (struct obj *)0,
X	NEARDATA *uchain = (struct obj *)0,
X        NEARDATA *uball = (struct obj *)0;
X
X#ifdef TEXTCOLOR
X/*
X *  This must be the same order as used for buzz() in zap.c.
X */
Xconst int zapcolors[NUM_ZAP] = {
X    HI_ZAP,		/* 0 - missile */
X    ORANGE_COLORED,	/* 1 - fire */
X    WHITE,		/* 2 - frost */
X    HI_ZAP,		/* 3 - sleep */
X    BLACK,		/* 4 - death */
X    HI_ZAP,		/* 5 - lightning */
X    YELLOW,		/* 6 - poison gas */
X    GREEN,		/* 7 - acid */
X};
X#endif /* text color */
X
Xconst int shield_static[SHIELD_COUNT] = {
X    S_ss1, S_ss2, S_ss3, S_ss2, S_ss1, S_ss2, S_ss4,	/* 7 per row */
X    S_ss1, S_ss2, S_ss3, S_ss2, S_ss1, S_ss2, S_ss4,
X    S_ss1, S_ss2, S_ss3, S_ss2, S_ss1, S_ss2, S_ss4,
X};
X
Xstruct spell NEARDATA spl_book[MAXSPELL + 1] = {DUMMY};
X
Xlong NEARDATA moves = 1L, NEARDATA monstermoves = 1L;
X	 /* These diverge when player is Fast */
Xlong NEARDATA wailmsg = 0L;
X
X/* objects that are moving to another dungeon level */
Xstruct obj NEARDATA *migrating_objs = (struct obj *)0;
X/* objects not yet paid for */
Xstruct obj NEARDATA *billobjs = (struct obj *)0;
X
X/* used to zero all elements of a struct obj */
Xstruct obj NEARDATA zeroobj = DUMMY;
X
X/* originally from dog.c */
Xchar NEARDATA dogname[63] = DUMMY;
Xchar NEARDATA catname[63] = DUMMY;
Xchar preferred_pet;	/* '\0', 'c', 'd' */
X/* monsters that went down/up together with @ */
Xstruct monst NEARDATA *mydogs = (struct monst *)0;
X/* monsters that are moving to another dungeon level */
Xstruct monst NEARDATA *migrating_mons = (struct monst *)0;
X
Xstruct c_color_names NEARDATA c_color_names = {
X	"black", "amber", "golden",
X	"light blue", "red", "green",
X	"silver", "blue", "purple",
X	"white"
X};
X
Xstruct c_common_strings c_common_strings = {
X	"Nothing happens.",		"That's enough tries!",
X	"That is a silly thing to %s.",	"shudder for a moment."
X};
X
X/* Vision */
Xboolean	NEARDATA vision_full_recalc = 0;
Xchar	NEARDATA **viz_array = 0;/* used in cansee() and couldsee() macros */
X
X/* Global windowing data, defined here for multi-window-system support */
Xwinid NEARDATA WIN_MESSAGE = WIN_ERR, NEARDATA WIN_STATUS = WIN_ERR;
Xwinid NEARDATA WIN_MAP = WIN_ERR, NEARDATA WIN_INVEN = WIN_ERR;
Xchar toplines[BUFSZ];
X/* Windowing stuff that's really tty oriented, but present for all ports */
Xstruct tc_gbl_data tc_gbl_data = { 0,0, 0,0 };	/* AS,AE, LI,CO */
X
X#ifdef TOURIST
Xconst char NEARDATA *pl_classes = "ABCEHKPRSTVW";
X#else
Xconst char NEARDATA *pl_classes = "ABCEHKPRSVW";
X#endif
X
X/* dummy routine used to force linkage */
Xvoid
Xdecl_init()
X{
X    return;
X}
X
X/*decl.c*/
END_OF_FILE
if test 7545 -ne `wc -c <'src/decl.c'`; then
    echo shar: \"'src/decl.c'\" unpacked with wrong size!
fi
# end of 'src/decl.c'
fi
if test -f 'sys/unix/unixtty.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/unix/unixtty.c'\"
else
echo shar: Extracting \"'sys/unix/unixtty.c'\" \(7724 characters\)
sed "s/^X//" >'sys/unix/unixtty.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)unixtty.c	3.1	90/22/02
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X/* tty.c - (Unix) version */
X
X/* With thanks to the people who sent code for SYSV - hpscdi!jon,
X * arnold@ucsf-cgl, wcs@bo95b, cbcephus!pds and others.
X */
X
X#define NEED_VARARGS
X#include "hack.h"
X
X#ifdef TTY_GRAPHICS
X#include "wintty.h"
X#endif
X
X/*
X * The distinctions here are not BSD - rest but rather USG - rest, as
X * BSD still has the old sgttyb structure, but SYSV has termio. Thus:
X */
X#if (defined(BSD) || defined(ULTRIX)) && !defined(POSIX_TYPES)
X#define	V7
X#else
X#define USG
X#endif
X
X
X#ifdef USG
X
X# ifdef POSIX_TYPES
X#include	<termios.h>
X#include	<unistd.h>
X#define termstruct	termios
X# else
X#include	<termio.h>
X#  if defined(TCSETS) && !defined(AIX_31)
X#define termstruct	termios
X#  else
X#define termstruct	termio
X#  endif
X# endif /* POSIX_TYPES */
X#define kill_sym	c_cc[VKILL]
X#define erase_sym	c_cc[VERASE]
X#define intr_sym	c_cc[VINTR]
X# ifdef TAB3	/* not a POSIX flag, but some have it anyway */
X#define EXTABS		TAB3
X# else
X#define EXTABS		0
X# endif
X#define tabflgs		c_oflag
X#define echoflgs	c_lflag
X#define cbrkflgs	c_lflag
X#define CBRKMASK	ICANON
X#define CBRKON		! /* reverse condition */
X# ifdef POSIX_TYPES
X#define OSPEED(x)	(speednum(cfgetospeed(&x)))
X# else
X#  ifndef CBAUD
X# define CBAUD		_CBAUD /* for POSIX nitpickers (like RS/6000 cc) */
X#  endif
X#define OSPEED(x)	((x).c_cflag & CBAUD)
X# endif
X#define IS_7BIT(x)	((x).c_cflag & CS7)
X#define inputflags	c_iflag
X#define STRIPHI		ISTRIP
X# ifdef POSIX_TYPES
X#  define GTTY(x)	(tcgetattr(0, x))
X#  define STTY(x)	(tcsetattr(0, TCSADRAIN, x))
X# else
X#  if defined(TCSETS) && !defined(AIX_31)
X#   define GTTY(x)	(ioctl(0, TCGETS, x))
X#   define STTY(x)	(ioctl(0, TCSETSW, x))
X#  else
X#   define GTTY(x)	(ioctl(0, TCGETA, x))
X#   define STTY(x)	(ioctl(0, TCSETAW, x))
X#  endif
X# endif /* POSIX_TYPES */
X#define GTTY2(x)	1
X#define STTY2(x)	1
X# ifdef POSIX_TYPES
X#  ifdef BSD
X#   define nonesuch	_POSIX_VDISABLE
X#  else
X#   define nonesuch	(fpathconf(0, _PC_VDISABLE))
X#  endif
X# else
X#  define nonesuch	0
X# endif
X#define inittyb2	inittyb
X#define curttyb2	curttyb
X
X#else	/* V7 */
X
X#include	<sgtty.h>
X#define termstruct	sgttyb
X#define	kill_sym	sg_kill
X#define	erase_sym	sg_erase
X#define	intr_sym	t_intrc
X#define EXTABS		XTABS
X#define tabflgs		sg_flags
X#define echoflgs	sg_flags
X#define cbrkflgs	sg_flags
X#define CBRKMASK	CBREAK
X#define CBRKON		/* empty */
X#define inputflags	sg_flags	/* don't know how enabling meta bits */
X#define IS_7BIT(x)	(FALSE)
X#define STRIPHI		0		/* should actually be done on BSD */
X#define OSPEED(x)	(x).sg_ospeed
X#if defined(bsdi) || defined(__386BSD)
X# define GTTY(x)	(ioctl(0, TIOCGETP, (char *)x))
X# define STTY(x)	(ioctl(0, TIOCSETP, (char *)x))
X#else
X# define GTTY(x)	(gtty(0, x))
X# define STTY(x)	(stty(0, x))
X#endif
X#define GTTY2(x)	(ioctl(0, TIOCGETC, (char *)x))
X#define STTY2(x)	(ioctl(0, TIOCSETC, (char *)x))
X#define nonesuch	-1
Xstruct tchars inittyb2, curttyb2;
X
X#endif
X
X#if defined(TTY_GRAPHICS) && ((!defined(SYSV) && !defined(HPUX)) || defined(UNIXPC) || defined(SVR4))
X# ifndef LINT
Xextern			/* it is defined in libtermlib (libtermcap) */
X# endif
X	short ospeed;	/* terminal baudrate; set by gettty */
X#else
Xshort	ospeed = 0;	/* gets around "not defined" error message */
X#endif
X
X#if defined(POSIX_TYPES) && defined(BSD)
Xunsigned
X#endif
X	char erase_char, intr_char, kill_char;
Xstatic boolean settty_needed = FALSE;
Xstruct termstruct inittyb, curttyb;
X
X#ifdef POSIX_TYPES
Xstatic int
Xspeednum(speed)
Xspeed_t speed;
X{
X	switch (speed) {
X		case B0:	return 0;
X		case B50:	return 1;
X		case B75:	return 2;
X		case B110:	return 3;
X		case B134:	return 4;
X		case B150:	return 5;
X		case B200:	return 6;
X		case B300:	return 7;
X		case B600:	return 8;
X		case B1200:	return 9;
X		case B1800:	return 10;
X		case B2400:	return 11;
X		case B4800:	return 12;
X		case B9600:	return 13;
X		case B19200:	return 14;
X		case B38400:	return 15;
X	}
X
X	return 0;
X}
X#endif
X
Xstatic void
Xsetctty()
X{
X	if(STTY(&curttyb) < 0 || STTY2(&curttyb2) < 0)
X		perror("NetHack (setctty)");
X}
X
X/*
X * Get initial state of terminal, set ospeed (for termcap routines)
X * and switch off tab expansion if necessary.
X * Called by startup() in termcap.c and after returning from ! or ^Z
X */
Xvoid
Xgettty()
X{
X	if(GTTY(&inittyb) < 0 || GTTY2(&inittyb2) < 0)
X		perror("NetHack (gettty)");
X	curttyb = inittyb;
X	curttyb2 = inittyb2;
X	ospeed = OSPEED(inittyb);
X	erase_char = inittyb.erase_sym;
X	kill_char = inittyb.kill_sym;
X	intr_char = inittyb2.intr_sym;
X	getioctls();
X
X	/* do not expand tabs - they might be needed inside a cm sequence */
X	if(curttyb.tabflgs & EXTABS) {
X		curttyb.tabflgs &= ~EXTABS;
X		setctty();
X	}
X	settty_needed = TRUE;
X}
X
X/* reset terminal to original state */
Xvoid
Xsettty(s)
Xconst char *s;
X{
X	end_screen();
X	if(s) raw_print(s);
X	if(STTY(&inittyb) < 0 || STTY2(&inittyb2) < 0)
X		perror("NetHack (settty)");
X	flags.echo = (inittyb.echoflgs & ECHO) ? ON : OFF;
X	flags.cbreak = (CBRKON(inittyb.cbrkflgs & CBRKMASK)) ? ON : OFF;
X	curttyb.inputflags |= STRIPHI;
X	setioctls();
X}
X
Xvoid
Xsetftty()
X{
Xregister int ef = 0;			/* desired value of flags & ECHO */
X#ifdef LINT	/* cf = CBRKON(CBRKMASK); const expr to initialize is ok */
Xregister int cf = 0;
X#else
Xregister int cf = CBRKON(CBRKMASK);	/* desired value of flags & CBREAK */
X#endif
Xregister int change = 0;
X	flags.cbreak = ON;
X	flags.echo = OFF;
X	/* Should use (ECHO|CRMOD) here instead of ECHO */
X	if((curttyb.echoflgs & ECHO) != ef){
X		curttyb.echoflgs &= ~ECHO;
X/*		curttyb.echoflgs |= ef;					*/
X		change++;
X	}
X	if((curttyb.cbrkflgs & CBRKMASK) != cf){
X		curttyb.cbrkflgs &= ~CBRKMASK;
X		curttyb.cbrkflgs |= cf;
X#ifdef USG
X		/* be satisfied with one character; no timeout */
X		curttyb.c_cc[VMIN] = 1;		/* was VEOF */
X		curttyb.c_cc[VTIME] = 0;	/* was VEOL */
X# ifdef POSIX_JOB_CONTROL
X		/* turn off system suspend character
X		 * due to differences in structure layout, this has to be
X		 * here instead of in ioctl.c:getioctls() with the BSD
X		 * equivalent
X		 */
X#  ifdef VSUSP	/* real POSIX */
X		curttyb.c_cc[VSUSP] = nonesuch;
X#  else		/* other later SYSV */
X		curttyb.c_cc[VSWTCH] = nonesuch;
X#  endif
X# endif
X# ifdef VDSUSP /* SunOS Posix extensions */
X		curttyb.c_cc[VDSUSP] = nonesuch;
X# endif
X# ifdef VREPRINT
X		curttyb.c_cc[VREPRINT] = nonesuch;
X# endif
X# ifdef VDISCARD
X		curttyb.c_cc[VDISCARD] = nonesuch;
X# endif
X# ifdef VWERASE
X		curttyb.c_cc[VWERASE] = nonesuch;
X# endif
X# ifdef VLNEXT
X		curttyb.c_cc[VLNEXT] = nonesuch;
X# endif
X#endif
X		change++;
X	}
X	if(!IS_7BIT(inittyb)) curttyb.inputflags &=~ STRIPHI;
X	/* If an interrupt character is used, it will be overriden and
X	 * set to ^C.
X	 */
X	if(intr_char != nonesuch && curttyb2.intr_sym != '\003') {
X	    curttyb2.intr_sym = '\003';
X	    change++;
X	}
X
X	if(change) setctty();
X	start_screen();
X}
X
Xvoid
Xintron()		/* enable kbd interupts if enabled when game started */
X{
X#ifdef TTY_GRAPHICS
X	/* Ugly hack to keep from changing tty modes for non-tty games -dlc */
X	if (windowprocs.win_init_nhwindows == tty_init_nhwindows &&
X	    intr_char != nonesuch && curttyb2.intr_sym != '\003') {
X	    curttyb2.intr_sym = '\003';
X	    setctty();
X	}
X#endif
X}
X
Xvoid
Xintroff()		/* disable kbd interrupts if required*/
X{
X#ifdef TTY_GRAPHICS
X	/* Ugly hack to keep from changing tty modes for non-tty games -dlc */
X	if (windowprocs.win_init_nhwindows == tty_init_nhwindows &&
X	   curttyb2.intr_sym != nonesuch) {
X	    curttyb2.intr_sym = nonesuch;
X	    setctty();
X	}
X#endif
X}
X
X
X/* fatal error */
X/*VARARGS1*/
X
Xvoid
Xerror VA_DECL(const char *,s)
X	VA_START(s);
X	VA_INIT(s, const char *);
X	if(settty_needed)
X		settty(NULL);
X	Vprintf(s,VA_ARGS);
X	(void) putchar('\n');
X	VA_END();
X	exit(1);
X}
END_OF_FILE
if test 7724 -ne `wc -c <'sys/unix/unixtty.c'`; then
    echo shar: \"'sys/unix/unixtty.c'\" unpacked with wrong size!
fi
# end of 'sys/unix/unixtty.c'
fi
if test -f 'sys/unix/unixunix.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/unix/unixunix.c'\"
else
echo shar: Extracting \"'sys/unix/unixunix.c'\" \(7443 characters\)
sed "s/^X//" >'sys/unix/unixunix.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)unixunix.c	3.1	90/22/02
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X/* This file collects some Unix dependencies */
X
X#include "hack.h"	/* mainly for index() which depends on BSD */
X
X#include <errno.h>
X#include <sys/stat.h>
X#ifdef NO_FILE_LINKS
X#include <fcntl.h>
X#endif
X#include <signal.h>
X#if defined(BSD) || defined(ULTRIX)
X#include <sys/wait.h>
X#endif
X
Xstatic struct stat buf, hbuf;
X
Xvoid
Xgethdate(name) const char *name; {
X/* old version - for people short of space */
X/*
X/* register char *np;
X/*	if(stat(name, &hbuf))
X/*		error("Cannot get status of %s.",
X/*			(np = rindex(name, '/')) ? np+1 : name);
X/*
X/* version using PATH from: seismo!gregc@ucsf-cgl.ARPA (Greg Couch) */
X
X
X/*
X * The problem with   #include	<sys/param.h>   is that this include file
X * does not exist on all systems, and moreover, that it sometimes includes
X * <sys/types.h> again, so that the compiler sees these typedefs twice.
X */
X#define		MAXPATHLEN	1024
X
Xregister const char *np, *path;
Xchar filename[MAXPATHLEN+1];
X	if (index(name, '/') != NULL || (path = getenv("PATH")) == NULL)
X		path = "";
X
X	for (;;) {
X		if ((np = index(path, ':')) == NULL)
X			np = path + strlen(path);	/* point to end str */
X		if (np - path <= 1)			/* %% */
X			Strcpy(filename, name);
X		else {
X			(void) strncpy(filename, path, np - path);
X			filename[np - path] = '/';
X			Strcpy(filename + (np - path) + 1, name);
X		}
X		if (stat(filename, &hbuf) == 0)
X			return;
X		if (*np == '\0')
X			break;
X		path = np + 1;
X	}
X#if defined(BOS) && defined(NHSTDC)
X/*
X *	This one is really **STUPID**.  I don't know why it's happening
X *	as similar constructs work elsewhere, but...
X */
X	if((np = rindex(name, '/')))
X	     error("Cannot get status of %s.", np+1);
X	else error("Cannot get status of %s.", name);
X#else
X	error("Cannot get status of %s.",
X		(np = rindex(name, '/')) ? np+1 : name);
X#endif
X}
X
Xint
Xuptodate(fd)
Xint fd;
X{
X	if(fstat(fd, &buf)) {
X		pline("Cannot get status of saved level? ");
X		wait_synch();
X		return(0);
X	}
X	if(buf.st_mtime < hbuf.st_mtime) {
X		pline("Saved level is out of date. ");
X		wait_synch();
X		return(0);
X	}
X	return(1);
X}
X
X/* see whether we should throw away this xlock file */
Xstatic int
Xveryold(fd)
Xint fd;
X{
X	time_t date;
X
X	if(fstat(fd, &buf)) return(0);			/* cannot get status */
X#ifndef INSURANCE
X	if(buf.st_size != sizeof(int)) return(0);	/* not an xlock file */
X#endif
X#ifdef BSD
X	(void) time((long *)(&date));
X#else
X	(void) time(&date);
X#endif
X	if(date - buf.st_mtime < 3L*24L*60L*60L) {	/* recent */
X#ifndef NETWORK
X		extern int errno;
X#endif
X		int lockedpid;	/* should be the same size as hackpid */
X
X		if(read(fd, (genericptr_t)&lockedpid, sizeof(lockedpid)) !=
X			sizeof(lockedpid))
X			/* strange ... */
X			return(0);
X
X		/* From: Rick Adams <seismo!rick>
X		/* This will work on 4.1cbsd, 4.2bsd and system 3? & 5.
X		/* It will do nothing on V7 or 4.1bsd. */
X#ifndef NETWORK
X		/* It will do a VERY BAD THING if the playground is shared
X		   by more than one machine! -pem */
X  		if(!(kill(lockedpid, 0) == -1 && errno == ESRCH))
X#endif
X			return(0);
X	}
X	(void) close(fd);
X	return(1);
X}
X
Xstatic int
Xeraseoldlocks()
X{
X	register int i;
X
X	/* cannot use maxledgerno() here, because we need to find a lock name
X	 * before starting everything (including the dungeon initialization
X	 * that sets astral_level, needed for maxledgerno()) up
X	 */
X	for(i = 1; i <= MAXDUNGEON*MAXLEVEL + 1; i++) {
X		/* try to remove all */
X		set_levelfile_name(lock, i);
X		(void) unlink(lock);
X	}
X	set_levelfile_name(lock, 0);
X	if(unlink(lock)) return(0);			/* cannot remove it */
X	return(1);					/* success! */
X}
X
Xvoid
Xgetlock()
X{
X	extern int errno;
X	register int i = 0, fd, c;
X
X	/* idea from rpick%ucqais@uccba.uc.edu
X	 * prevent automated rerolling of characters
X	 * test input (fd0) so that tee'ing output to get a screen dump still
X	 * works
X	 * also incidentally prevents development of any hack-o-matic programs
X	 */
X	if (!isatty(0))
X		error("You must play from a terminal.");
X
X	/* we ignore QUIT and INT at this point */
X	if (!lock_file(HLOCK, 10)) {
X		wait_synch();
X		error("");
X	}
X
X	regularize(lock);
X	set_levelfile_name(lock, 0);
X
X	if(locknum) {
X		if(locknum > 25) locknum = 25;
X
X		do {
X			lock[0] = 'a' + i++;
X
X			if((fd = open(lock, 0)) == -1) {
X			    if(errno == ENOENT) goto gotlock; /* no such file */
X			    perror(lock);
X			    unlock_file(HLOCK);
X			    error("Cannot open %s", lock);
X			}
X
X			if(veryold(fd) /* closes fd if true */
X							&& eraseoldlocks())
X				goto gotlock;
X			(void) close(fd);
X		} while(i < locknum);
X
X		unlock_file(HLOCK);
X		error("Too many hacks running now.");
X	} else {
X		if((fd = open(lock, 0)) == -1) {
X			if(errno == ENOENT) goto gotlock;    /* no such file */
X			perror(lock);
X			unlock_file(HLOCK);
X			error("Cannot open %s", lock);
X		}
X
X		if(veryold(fd) /* closes fd if true */ && eraseoldlocks())
X			goto gotlock;
X		(void) close(fd);
X
X		if(flags.window_inited) {
X		    c = yn("There is already a game in progress under your name.  Destroy old game?");
X		} else {
X		    (void) printf("\nThere is already a game in progress under your name.");
X		    (void) printf("  Destroy old game? [yn] ");
X		    (void) fflush(stdout);
X		    c = getchar();
X		    (void) putchar(c);
X		    (void) fflush(stdout);
X		    while (getchar() != '\n') ; /* eat rest of line and newline */
X		}
X		if(c == 'y' || c == 'Y')
X			if(eraseoldlocks())
X				goto gotlock;
X			else {
X				unlock_file(HLOCK);
X				error("Couldn't destroy old game.");
X			}
X		else {
X			unlock_file(HLOCK);
X			error("");
X		}
X	}
X
Xgotlock:
X	fd = creat(lock, FCMASK);
X	unlock_file(HLOCK);
X	if(fd == -1) {
X		error("cannot creat lock file.");
X	} else {
X		if(write(fd, (genericptr_t) &hackpid, sizeof(hackpid))
X		    != sizeof(hackpid)){
X			error("cannot write lock");
X		}
X		if(close(fd) == -1) {
X			error("cannot close lock");
X		}
X	}
X}	
X
Xvoid
Xregularize(s)	/* normalize file name - we don't like .'s, /'s, spaces */
Xregister char *s;
X{
X	register char *lp;
X
X	while((lp=index(s, '.')) || (lp=index(s, '/')) || (lp=index(s,' ')))
X		*lp = '_';
X#if defined(SYSV) && !defined(AIX_31)
X	/* avoid problems with 14 character file name limit */
X# ifdef COMPRESS
X	if(strlen(s) > 10)
X		/* leave room for .e from error and .Z from compress
X		 * appended to save files */
X		s[10] = '\0';
X# else
X	if(strlen(s) > 11)
X		/* leave room for .nn appended to level files */
X		s[11] = '\0';
X# endif
X#endif
X}
X
X#ifdef SHELL
Xint
Xdosh()
X{
X	register char *str;
X	if(child(0)) {
X		if(str = getenv("SHELL"))
X			(void) execl(str, str, NULL);
X		else
X			(void) execl("/bin/sh", "sh", NULL);
X		raw_print("sh: cannot execute.");
X		exit(1);
X	}
X	return 0;
X}
X#endif /* SHELL /**/
X
X#if defined(SHELL) || defined(DEF_PAGER) || defined(DEF_MAILREADER)
Xint
Xchild(wt)
Xint wt;
X{
X	register int f;
X	suspend_nhwindows(NULL);	/* also calls end_screen() */
X	if((f = fork()) == 0){		/* child */
X		(void) setgid(getgid());
X		(void) setuid(getuid());
X#ifdef CHDIR
X		(void) chdir(getenv("HOME"));
X#endif
X		return(1);
X	}
X	if(f == -1) {	/* cannot fork */
X		pline("Fork failed.  Try again.");
X		return(0);
X	}
X	/* fork succeeded; wait for child to exit */
X	(void) signal(SIGINT,SIG_IGN);
X	(void) signal(SIGQUIT,SIG_IGN);
X	(void) wait( (int *) 0);
X	(void) signal(SIGINT, (SIG_RET_TYPE) done1);
X#ifdef WIZARD
X	if(wizard) (void) signal(SIGQUIT,SIG_DFL);
X#endif
X	if(wt) {
X		raw_print("");
X		wait_synch();
X	}
X	resume_nhwindows();
X	return(0);
X}
X#endif
END_OF_FILE
if test 7443 -ne `wc -c <'sys/unix/unixunix.c'`; then
    echo shar: \"'sys/unix/unixunix.c'\" unpacked with wrong size!
fi
# end of 'sys/unix/unixunix.c'
fi
echo shar: End of archive 97 \(of 108\).
cp /dev/null ark97isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \
21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \
41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 \
61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 \
81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 \
101 102 103 104 105 106 107 108 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 108 archives.
    echo "Now execute 'rebuild.sh'"
    rm -f ark10[0-8]isdone ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
