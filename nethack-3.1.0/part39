Path: uunet!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v16i047:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Part39/108
Message-ID: <4341@master.CNA.TEK.COM>
Date: 30 Jan 93 01:12:33 GMT
Sender: news@master.CNA.TEK.COM
Lines: 2494
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1596

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 16, Issue 47
Archive-name: nethack31/Part39
Supersedes: nethack3p9: Volume 10, Issue 46-102
Environment: Amiga, Atari, Mac, MS-DOS, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 39 (of 108)."
# Contents:  src/mthrowu.c sys/amiga/wb.c1
# Wrapped by billr@saab on Wed Jan 27 16:09:01 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'src/mthrowu.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/mthrowu.c'\"
else
echo shar: Extracting \"'src/mthrowu.c'\" \(15122 characters\)
sed "s/^X//" >'src/mthrowu.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)mthrowu.c	3.1	92/11/14	*/
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include	"hack.h"
X
XSTATIC_DCL void FDECL(drop_throw,(struct obj *,BOOLEAN_P,int,int));
X#ifndef MUSE
XSTATIC_DCL void FDECL(m_throw,(struct monst *,int,int,int,int,int,struct obj *));
X#endif
X
X#define URETREATING(x,y) (distmin(u.ux,u.uy,x,y) > distmin(u.ux0,u.uy0,x,y))
X
Xboolean FDECL(lined_up, (struct monst *));
X
X#ifndef OVLB
X
XSTATIC_DCL const char *breathwep[];
X
X#else /* OVLB */
X
X/*
X * Keep consistent with breath weapons in zap.c, and AD_* in monattk.h.
X */
XSTATIC_OVL const char NEARDATA *breathwep[] = {
X				"fragments",
X				"fire",
X				"frost",
X				"sleep gas",
X				"death",
X				"lightning",
X				"poison gas",
X				"acid",
X				"strange breath #8",
X				"strange breath #9"
X};
X
Xint
Xthitu(tlev, dam, obj, name)	/* u is hit by sth, but not a monster */
X	register int tlev, dam;
X	struct obj *obj;
X	register const char *name;
X{
X	const char *onm = (obj && obj_is_pname(obj)) ? the(name) : an(name);
X	boolean is_acid = (obj && obj->otyp == ACID_VENOM);
X
X	if(u.uac + tlev <= rnd(20)) {
X		if(Blind || !flags.verbose) pline("It misses.");
X		else You("are almost hit by %s!", onm);
X		return(0);
X	} else {
X		if(Blind || !flags.verbose) You("are hit!");
X		else You("are hit by %s!", onm);
X#ifdef POLYSELF
X		if (obj && objects[obj->otyp].oc_material == SILVER
X				&& hates_silver(uasmon)) {
X			dam += rnd(20);
X			pline("The silver sears your flesh!");
X			exercise(A_CON, FALSE);
X		}
X		if (is_acid && resists_acid(uasmon))
X			pline("It doesn't seem to hurt you.");
X		else {
X#endif
X			if (is_acid) pline("It burns!");
X			if (Half_physical_damage) dam = (dam+1) / 2;
X			losehp(dam, name, (obj && obj_is_pname(obj)) ?
X			       KILLED_BY : KILLED_BY_AN);
X			exercise(A_STR, FALSE);
X#ifdef POLYSELF
X		}
X#endif
X		return(1);
X	}
X}
X
X/* Be sure this corresponds with what happens to player-thrown objects in
X * dothrow.c (for consistency). --KAA
X */
X
XSTATIC_OVL void
Xdrop_throw(obj, ohit, x, y)
Xregister struct obj *obj;
Xboolean ohit;
Xint x,y;
X{
X	int create;
X	struct monst *mtmp;
X	struct trap *t;
X
X	if (obj->otyp == CREAM_PIE || obj->oclass == VENOM_CLASS)
X		create = 0;
X	else if (ohit &&
X		 ((obj->otyp >= ARROW && obj->otyp <= SHURIKEN) ||
X		  obj->otyp == ROCK))
X		create = !rn2(3);
X	else create = 1;
X	if (create && !((mtmp = m_at(x, y)) && (mtmp->mtrapped) && 
X			(t = t_at(x, y)) && ((t->ttyp == PIT) || 
X			(t->ttyp == SPIKED_PIT))) && 
X	    !flooreffects(obj,x,y,"fall")) { /* don't double-dip on damage */
X		place_object(obj, x, y);
X		obj->nobj = fobj;
X		fobj = obj;
X		stackobj(fobj);
X	} else obfree(obj, (struct obj*) 0);
X}
X
X#endif /* OVLB */
X#ifdef OVL1
X
X#ifndef MUSE
XSTATIC_OVL
X#endif
Xvoid
Xm_throw(mon, x, y, dx, dy, range, obj)
X	register struct monst *mon;
X	register int x,y,dx,dy,range;		/* direction and range */
X	register struct obj *obj;
X{
X	register struct monst *mtmp;
X	struct obj *singleobj;
X	char sym = obj->oclass;
X	int damage;
X	int hitu, blindinc=0;
X
X	bhitpos.x = x;
X	bhitpos.y = y;
X
X	singleobj = splitobj(obj, obj->quan - 1L);
X	/* splitobj leaves the new object in the chain (i.e. the monster's
X	 * inventory).  Remove it.  We can do this in 1 line, but it's highly
X	 * dependent on the fact that we know splitobj() places it immediately
X	 * after obj.
X	 */
X	obj->nobj = singleobj->nobj;
X	/* Get rid of object.  This cannot be done later on; what if the
X	 * player dies before then, leaving the monster with 0 daggers?
X	 * (This caused the infamous 2^32-1 orcish dagger bug).
X	 */
X	if (!obj->quan) {
X	    if(obj->oclass == VENOM_CLASS) {
X		/* venom is not in the monster's inventory chain */
X		dealloc_obj(obj);
X	    } else {
X#ifdef MUSE
X		/* not possibly_unwield, which checks the object's */
X		/* location, not its existence */
X		if (MON_WEP(mon) == obj)
X			MON_NOWEP(mon);
X#endif
X		m_useup(mon, obj);
X	    }
X	}
X
X	if (singleobj->cursed && (dx || dy) && !rn2(7)) {
X	    if(canseemon(mon) && flags.verbose) {
X		if((singleobj->oclass == WEAPON_CLASS ||
X						singleobj->oclass == GEM_CLASS)
X		   && objects[singleobj->otyp].w_propellor)
X		    pline("%s misfires!", Monnam(mon));
X		else
X		    pline("The %s slips as %s throws it!",
X			  xname(singleobj), mon_nam(mon));
X	    }
X	    dx = rn2(3)-1;
X	    dy = rn2(3)-1;
X	    /* pre-check validity of new direction */
X	    if((!dx && !dy)
X	       || !isok(bhitpos.x+dx,bhitpos.y+dy)
X	       /* missile hits the wall */
X	       || IS_WALL(levl[bhitpos.x+dx][bhitpos.y+dy].typ)
X	       || levl[bhitpos.x+dx][bhitpos.y+dy].typ == SDOOR
X	       || levl[bhitpos.x+dx][bhitpos.y+dy].typ == SCORR) {
X		drop_throw(singleobj, 0, bhitpos.x, bhitpos.y);
X		return;
X	    }
X	}
X
X	/* Note: drop_throw may destroy singleobj.  Since obj must be destroyed
X	 * early to avoid the dagger bug, anyone who modifies this code should
X	 * be careful not to use either one after it's been freed.
X	 */
X	if (sym) tmp_at(DISP_FLASH, obj_to_glyph(singleobj));
X	while(range-- > 0) { /* Actually the loop is always exited by break */
X		boolean vis;
X
X		bhitpos.x += dx;
X		bhitpos.y += dy;
X		vis = cansee(bhitpos.x, bhitpos.y);
X		if(MON_AT(bhitpos.x, bhitpos.y)) {
X		    boolean ismimic;
X
X		    mtmp = m_at(bhitpos.x,bhitpos.y);
X		    ismimic = mtmp->m_ap_type &&
X			mtmp->m_ap_type != M_AP_MONSTER;
X
X		    /* don't use distance/size modifiers since target was u */
X		    if(find_mac(mtmp) + 8 + singleobj->spe <= rnd(20)) {
X			if (!ismimic) {
X			    if (!vis) pline("It is missed.");
X			    else miss(distant_name(singleobj,xname), mtmp);
X			}
X			if (!range) { /* Last position; object drops */
X			    drop_throw(singleobj, 0, mtmp->mx, mtmp->my);
X			    break;
X			}
X#ifdef MUSE
X		    } else if (singleobj->oclass == POTION_CLASS) {
X			if (ismimic) seemimic(mtmp);
X			if (vis) singleobj->dknown = 1;
X			potionhit(mtmp, singleobj);
X			break;
X#endif
X		    } else {
X			damage = dmgval(singleobj, mtmp->data);
X			if (damage < 1) damage = 1;
X			if (singleobj->otyp==ACID_VENOM && resists_acid(mtmp->data))
X			    damage = 0;
X			if (ismimic) seemimic(mtmp);
X			if (!vis) pline("It is hit%s", exclam(damage));
X			else hit(distant_name(singleobj,xname),
X							mtmp,exclam(damage));
X			if (singleobj->opoisoned) {
X			    if (resists_poison(mtmp->data)) {
X				if (vis)
X				  pline("The poison doesn't seem to affect %s.",
X								mon_nam(mtmp));
X			    } else {
X				if (rn2(30)) damage += rnd(6);
X				else {
X				    if (vis)
X					pline("The poison was deadly...");
X				    damage = mtmp->mhp;
X				}
X			    }
X			}
X			if (objects[singleobj->otyp].oc_material == SILVER
X				&& hates_silver(mtmp->data)) {
X			    if (vis) pline("The silver sears %s's flesh!",
X				mon_nam(mtmp));
X			    else pline("Its flesh is seared!");
X			}
X			if (singleobj->otyp==ACID_VENOM && cansee(mtmp->mx,mtmp->my)){
X			    if (resists_acid(mtmp->data)) {
X				pline("%s is unaffected.", vis ? Monnam(mtmp)
X					: "It");
X				damage = 0;
X			    } else if (vis)
X				pline("The acid burns %s!", mon_nam(mtmp));
X			    else pline("It is burned!");
X			}
X			mtmp->mhp -= damage;
X			if(mtmp->mhp < 1) {
X			    pline("%s is %s!", vis ? Monnam(mtmp) : "It",
X			       (is_demon(mtmp->data) || 
X					is_undead(mtmp->data) || !vis) ?
X				 "destroyed" : "killed");
X			    mondied(mtmp);
X			}
X
X			if(((singleobj->otyp == CREAM_PIE) ||
X			    (singleobj->otyp == BLINDING_VENOM))
X			   && haseyes(mtmp->data)) {
X			    if (vis)
X				pline("%s is blinded by %s.",
X				      Monnam(mtmp), the(xname(singleobj)));
X			    if(mtmp->msleep) mtmp->msleep = 0;
X			    mtmp->mcansee = 0;
X			    {
X				register unsigned rnd_tmp = rnd(25) + 20;
X				if((mtmp->mblinded + rnd_tmp) > 127)
X					mtmp->mblinded = 127;
X				else mtmp->mblinded += rnd_tmp;
X			    }
X			}
X			drop_throw(singleobj, 1, bhitpos.x, bhitpos.y);
X			break;
X		    }
X		}
X		if (bhitpos.x == u.ux && bhitpos.y == u.uy) {
X			if (multi) nomul(0);
X
X#ifdef MUSE
X			if (singleobj->oclass == POTION_CLASS) {
X			    if (!Blind) singleobj->dknown = 1;
X			    potionhit(&youmonst, singleobj);
X			    break;
X			}
X#endif
X			switch(singleobj->otyp) {
X			    int dam, hitv;
X			    case CREAM_PIE:
X			    case BLINDING_VENOM:
X				hitu = thitu(8, 0, singleobj, xname(singleobj));
X				break;
X			    default:
X				dam = dmgval(singleobj, uasmon);
X				hitv = 3 - distmin(u.ux,u.uy, mon->mx,mon->my);
X				if (hitv < -4) hitv = -4;
X				if (is_elf(mon->data) &&
X				    objects[singleobj->otyp].w_propellor
X								== WP_BOW) {
X				    hitv++;
X#ifdef MUSE
X				    if (MON_WEP(mon) &&
X					MON_WEP(mon)->otyp == ELVEN_BOW)
X					hitv++;
X#endif
X				    if(singleobj->otyp == ELVEN_ARROW) dam++;
X				}
X#ifdef POLYSELF
X				if (bigmonst(uasmon)) hitv++;
X#endif
X				hitv += 8+singleobj->spe;
X
X				if (dam < 1) dam = 1;
X				hitu = thitu(hitv, dam,
X					singleobj, xname(singleobj));
X			}
X			if (hitu && singleobj->opoisoned)
X			    /* it's safe to call xname twice because it's the
X			       same object both times... */
X			    poisoned(xname(singleobj), A_STR, xname(singleobj), 10);
X			if(hitu && (singleobj->otyp == CREAM_PIE ||
X				     singleobj->otyp == BLINDING_VENOM)) {
X			    blindinc = rnd(25);
X			    if(singleobj->otyp == CREAM_PIE) {
X				if(!Blind) pline("Yecch!  You've been creamed.");
X				else	pline("There's something sticky all over your %s.", body_part(FACE));
X			    } else {	/* venom in the eyes */
X				if(Blindfolded) /* nothing */ ;
X				else if(!Blind) pline("The venom blinds you.");
X				else	Your("%s sting.",
X					makeplural(body_part(EYE)));
X			    }
X			}
X			stop_occupation();
X			if (hitu || !range) {
X			    drop_throw(singleobj, hitu, u.ux, u.uy);
X			    break;
X			}
X		} else if (!range	/* reached end of path */
X			/* missile hits edge of screen */
X			|| !isok(bhitpos.x+dx,bhitpos.y+dy)
X			/* missile hits the wall */
X			|| IS_WALL(levl[bhitpos.x+dx][bhitpos.y+dy].typ)
X			|| levl[bhitpos.x+dx][bhitpos.y+dy].typ == SDOOR
X			|| levl[bhitpos.x+dx][bhitpos.y+dy].typ == SCORR
X#ifdef SINKS
X			/* Thrown objects "sink" */
X			|| IS_SINK(levl[bhitpos.x][bhitpos.y].typ)
X#endif
X								) {
X		    drop_throw(singleobj, 0, bhitpos.x, bhitpos.y);
X		    break;
X		}
X		tmp_at(bhitpos.x, bhitpos.y);
X		delay_output();
X	}
X	tmp_at(bhitpos.x, bhitpos.y);
X	delay_output();
X	tmp_at(DISP_END, 0);
X	/* blindfold keeps substances out of your eyes */
X	if (blindinc && !Blindfolded) {
X		u.ucreamed += blindinc;
X		make_blinded(Blinded + blindinc,FALSE);
X	}
X}
X
X#endif /* OVL1 */
X#ifdef OVLB
X
X/* Remove an item from the monster's inventory.
X */
Xvoid
Xm_useup(mon, obj)
Xstruct monst *mon;
Xstruct obj *obj;
X{
X	struct obj *otmp, *prev;
X
X	if (obj->quan > 1L) {
X		obj->quan--;
X		return;
X	}
X	prev = ((struct obj *) 0);
X	for (otmp = mon->minvent; otmp; otmp = otmp->nobj) {
X		if (otmp == obj) {
X			if (prev)
X				prev->nobj = obj->nobj;
X			else
X				mon->minvent = obj->nobj;
X			dealloc_obj(obj);
X			break;
X		}
X		prev = otmp;
X	}
X}
X
X#endif /* OVLB */
X#ifdef OVL1
X
Xvoid
Xthrwmu(mtmp)	/* monster throws item at you */
Xregister struct monst *mtmp;
X{
X	struct obj *otmp;
X	register xchar x, y;
X
X	if(lined_up(mtmp)) {
X#ifdef MUSE
X	    if (mtmp->weapon_check == NEED_WEAPON || !MON_WEP(mtmp)) {
X		mtmp->weapon_check = NEED_RANGED_WEAPON;
X		/* mon_wield_item resets weapon_check as appropriate */
X		if(mon_wield_item(mtmp) != 0) return;
X	    }
X#endif
X	    if((otmp = select_rwep(mtmp))) {
X		/* If you are coming toward the monster, the monster
X		 * should try to soften you up with missiles.  If you are
X		 * going away, you are probably hurt or running.  Give
X		 * chase, but if you are getting too far away, throw.
X		 */
X		x = mtmp->mx;
X		y = mtmp->my;
X		if(!URETREATING(x,y) ||
X		   !rn2(BOLT_LIM-distmin(x,y,mtmp->mux,mtmp->muy)))
X		{
X		    const char *verb = "throws";
X
X		    if (otmp->otyp == ARROW
X			|| otmp->otyp == ELVEN_ARROW
X			|| otmp->otyp == ORCISH_ARROW
X			|| otmp->otyp == CROSSBOW_BOLT) verb = "shoots";
X		    if (canseemon(mtmp)) {
X			pline("%s %s %s!", Monnam(mtmp), verb,
X			      obj_is_pname(otmp) ?
X			      the(singular(otmp, xname)) :
X			      an(singular(otmp, xname)));
X		    }
X		    m_throw(mtmp, mtmp->mx, mtmp->my, sgn(tbx), sgn(tby), 
X			distmin(mtmp->mx,mtmp->my,mtmp->mux,mtmp->muy), otmp);
X		    nomul(0);
X		    return;
X		}
X	    }
X	}
X}
X
X#endif /* OVL1 */
X#ifdef OVLB
X
Xint
Xspitmu(mtmp, mattk)		/* monster spits substance at you */
Xregister struct monst *mtmp;
Xregister struct attack *mattk;
X{
X	register struct obj *otmp;
X
X	if(mtmp->mcan) {
X
X	    if(flags.soundok)
X		pline("A dry rattle comes from %s throat", 
X		                      s_suffix(mon_nam(mtmp)));
X	    return 0;
X	}
X	if(lined_up(mtmp)) {
X		switch (mattk->adtyp) {
X		    case AD_BLND:
X		    case AD_DRST:
X			otmp = mksobj(BLINDING_VENOM, TRUE, FALSE);
X			break;
X		    default:
X			impossible("bad attack type in spitmu");
X				/* fall through */
X		    case AD_ACID:
X			otmp = mksobj(ACID_VENOM, TRUE, FALSE);
X			break;
X		}
X		if(!rn2(BOLT_LIM-distmin(mtmp->mx,mtmp->my,mtmp->mux,mtmp->muy))) {
X		    if (canseemon(mtmp))
X			pline("%s spits venom!", Monnam(mtmp));
X		    m_throw(mtmp, mtmp->mx, mtmp->my, sgn(tbx), sgn(tby), 
X			distmin(mtmp->mx,mtmp->my,mtmp->mux,mtmp->muy), otmp);
X		    nomul(0);
X		    return 0;
X		}
X	}
X	return 0;
X}
X
X#endif /* OVLB */
X#ifdef OVL1
X
Xint
Xbreamu(mtmp, mattk)			/* monster breathes at you (ranged) */
X	register struct monst *mtmp;
X	register struct attack  *mattk;
X{
X	/* if new breath types are added, change AD_ACID to max type */
X	int typ = (mattk->adtyp == AD_RBRE) ? rnd(AD_ACID) : mattk->adtyp ;
X
X	if(lined_up(mtmp)) {
X
X	    if(mtmp->mcan) {
X		if(flags.soundok) {
X		    if(canseemon(mtmp))
X			pline("%s coughs.", Monnam(mtmp));
X		    else
X			You("hear a cough.");
X		}
X		return(0);
X	    }
X	    if(!mtmp->mspec_used && rn2(3)) {
X
X		if((typ >= AD_MAGM) && (typ <= AD_ACID)) {
X
X		    if(canseemon(mtmp))
X			pline("%s breathes %s!", Monnam(mtmp),
X			      breathwep[typ-1]);
X		    buzz((int) (-20 - (typ-1)), (int)mattk->damn,
X			 mtmp->mx, mtmp->my, sgn(tbx), sgn(tby));
X		    nomul(0);
X		    /* breath runs out sometimes. Also, give monster some
X		     * cunning; don't breath if the player fell asleep.
X		     */
X		    if(!rn2(3))
X			mtmp->mspec_used = 10+rn2(20);
X		    if(typ == AD_SLEE && !Sleep_resistance)
X			mtmp->mspec_used += rnd(20);
X		} else impossible("Breath weapon %d used", typ-1);
X	    }
X	}
X	return(1);
X}
X
Xboolean
Xlinedup(ax, ay, bx, by)
Xregister xchar ax, ay, bx, by;
X{
X	tbx = ax - bx;	/* These two values are set for use */
X	tby = ay - by;	/* after successful return.	    */
X
X	if((!tbx || !tby || abs(tbx) == abs(tby)) /* straight line or diagonal */
X	   && distmin(tbx, tby, 0, 0) < BOLT_LIM) {
X
X	    if(ax == u.ux && ay == u.uy) return couldsee(bx,by);
X	    else if(clear_path(ax,ay,bx,by)) return TRUE;
X	}
X	return FALSE;
X}
X
Xboolean
Xlined_up(mtmp)		/* is mtmp in position to use ranged attack? */
X	register struct monst *mtmp;
X{
X	return(linedup(mtmp->mux,mtmp->muy,mtmp->mx,mtmp->my));
X}
X
X#endif /* OVL1 */
X#ifdef OVL0
X
X/* Check if a monster is carrying a particular item.
X */
Xstruct obj *
Xm_carrying(mtmp, type)
Xstruct monst *mtmp;
Xint type;
X{
X	register struct obj *otmp;
X
X	for(otmp = mtmp->minvent; otmp; otmp = otmp->nobj)
X		if(otmp->otyp == type)
X			return(otmp);
X	return((struct obj *) 0);
X}
X
X#endif /* OVL0 */
X
X/*mthrowu.c*/
END_OF_FILE
if test 15122 -ne `wc -c <'src/mthrowu.c'`; then
    echo shar: \"'src/mthrowu.c'\" unpacked with wrong size!
fi
# end of 'src/mthrowu.c'
fi
if test -f 'sys/amiga/wb.c1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/amiga/wb.c1'\"
else
echo shar: Extracting \"'sys/amiga/wb.c1'\" \(39564 characters\)
sed "s/^X//" >'sys/amiga/wb.c1' <<'END_OF_FILE'
X/*    SCCS Id: @(#)wb.c     2.1   93/01/08			  */
X/*    Copyright (c) Kenneth Lorber, Bethesda Maryland, 1991	  */
X/*    Copyright (c) Gregg Wonderly, Naperville IL, 1992, 1993	  */
X/* NetHack may be freely redistributed.  See license for details. */
X
X/* Friendly Intuition interface for NetHack 3.1 on the Amiga */
X
X#ifdef AZTEC_C
X/* Aztec doesn't recognize __chip syntax */
X# define __chip
X#endif
X
X#include "Amiga:wbdefs.h"		/* Miscellany information */
X#ifdef  INTUI_NEW_LOOK
X#define NewWindow   ExtNewWindow
X#define NewScreen   ExtNewScreen
X#endif
X#include "Amiga:wbstruct.h"
X#include "Amiga:wbprotos.h"
X
X#include "Amiga:wbdata.c"		/* All structures and global data */
X#include "Amiga:wbwin.c"		/* Has static definitions */
X
X#define C_GREY  0
X#define C_BLACK 1
X#define C_WHITE 2
X#define C_BLUE  3
X
X#ifndef __SASC_60
Xextern char *sys_errlist[];
X#endif
Xextern int errno;
X
Xchar pubscreen[ 80 ] = { "HackWB" };
Xchar mytitle[ 80 ];
X
X#ifdef  INTUI_NEW_LOOK
Xint scrlocked = 0;
XUWORD scrnpens[] = { 0xffff };
X
Xstruct TagItem scrntags[] =
X{
X    (Tag)SA_Pens, (ULONG)scrnpens,
X    TAG_DONE, 0,
X    TAG_DONE, 0,
X    TAG_DONE, 0,
X    TAG_DONE, 0,
X    TAG_DONE, 0,
X    TAG_DONE, 0,
X    TAG_DONE, 0,
X};
X#endif
X
X#define SPLIT			/* use splitter, if available */
X#ifdef SPLIT
Xint running_split=0;		/* if 0, using normal LoadSeg/UnLoadSeg */
X#endif
X
X#ifdef AZTEC_C
Xextern char *strdup(char *);
X#endif
X
X#ifndef max
X# define max(a, b) ((a) > (b) ? (a) : (b))
X#endif
X#ifndef min
X# define min(x,y) ((x) < (y) ? (x) : (y))
X#endif
X
Xvoid diskobj_filter(struct DiskObject *);
Xstatic void UpdateInfoWin( struct Window *cwin );
XBPTR s_LoadSeg(char *);
Xvoid s_UnLoadSeg(void);
X
Xmain( argc, argv )
X    int argc;
X    struct WBStartup *argv;
X{
X    long mask, rmask;
X    struct WBStartup *wbs;
X    struct WBArg *wba;
X    GPTR gptr;
X    struct IntuiMessage *imsg;
X    struct IntuiMessage mimsg;
X    int i;
X
X    ZapOptions( curopts );
X    InitWB( argc, argv );
X    SetupWB( ); /* open window, build menus */
X    errmsg( NO_FLASH, "Welcome to NetHack Version 3.1!" );
X    CopyRight( );
X
X    ReadConfig( );
X    LoadDefaults( defgname );
X
X    /* Initially, no game selected so disable menu items */
X
X    ChgGameItems( &MenuList1, 0 );
X
X    MapGadgets( R_DISK, 1 ); /* Display the icons */
X
X    /* Wait till user quits */
X
X    while( !quit )
X    {
X	/* Wait for a message */
X
X	mask = ( 1L << dosport->mp_SigBit ) ;
X	if( wbopen )
X	    mask |= ( 1L << win->UserPort->mp_SigBit );
X
X	rmask = Wait( mask );
X
X	/* If displayed an error message before, clear it */
X
X	if( errup )
X	{
X	    errmsg( NO_FLASH, "" );
X	    errup = 0;
X	}
X
X	/* Process the messages on the port unless the workbench is
X	 * shutdown by a request to play a game.
X	 */
X
X	while( wbopen && ( imsg = ( struct IntuiMessage * )
X	    GetMsg( win->UserPort ) ) )
X	{
X	    /* Copy the message.  This does not guarantee that all
X	     * fields will still be valid, but appears to work
X	     * here.  Note that we have to reply to the message
X	     * before the workbench window is closed.
X	     */
X
X	    mimsg = *imsg;
X	    ReplyMsg( (struct Message *)imsg );
X
X	    switch( mimsg.Class )
X	    {
X	    case NEWSIZE:
X		((struct Border *) Message.GadgetRender)->XY[2] =
X		    win->Width - win->BorderLeft -
X		    win->BorderRight - 1;
X		RefreshGList( &Message, win, NULL, 1 );
X		MapGadgets( R_SCROLL, 1 ); /* redisplay the icons */
X#ifdef  INTUI_NEW_LOOK
X		if( IntuitionBase->LibNode.lib_Version >= 37 )
X		    RefreshWindowFrame( win );
X#endif
X		break;
X
X	    case MENUPICK:
X		do_menu( mimsg.Code );
X		break;
X
X	    case RAWKEY:
X		if( mimsg.Code == 0x5f )
X		{
X		    /* Pick the correct help message */
X
X		    if( lastgaddown == NULL )
X		    {
X			text_requester( &Help1_NewWindowStructure7,
X			    &Help1_IntuiTextList7 );
X		    }
X		    else
X		    {
X			text_requester( &Help2_NewWindowStructure8,
X			    &Help2_IntuiTextList8 );
X		    }
X		}
X		break;
X
X	    case CLOSEWINDOW:
X		if( Ask( "Ready to Quit?" ) )
X		    do_closewindow( );
X		break;
X
X	    case GADGETDOWN:
X		do_gadgetdown( &mimsg );
X		break;
X
X	    case GADGETUP:
X		do_gadgetup( &mimsg );
X		break;
X
X	    case DISKINSERTED:
X		MapGadgets( R_DISK, 1 );
X		break;
X
X	    case MOUSEBUTTONS:
X		do_buttons( &mimsg );
X		break;
X	    }
X	}
X
X	if( rmask & ( 1L << dosport->mp_SigBit ) )
X	{
X	    /* Get process termination messages */
X
X	    while( wbs = (struct WBStartup *) GetMsg( dosport ) )
X	    {
X		/* Find the game that has terminated */
X
X		for( gptr = gamehead; gptr && gptr->seglist != wbs->sm_Segment;)
X		    gptr = gptr->next;
X
X		/* Make sure it is there */
X
X		if( gptr )
X		{
X#ifdef SPLIT
X		    if(!running_split)
X#endif
X		    {
X			/* Unload the code */
X			UnLoadSeg( wbs->sm_Segment );
X		    }
X
X		    /* Free the startup message resources */
X		    wba = (struct WBArg *)
X			((long)wbs + sizeof( struct WBStartup ));
X		    for( i = 0; i < wbs->sm_NumArgs; ++i )
X		    {
X			FreeMem( wba[i].wa_Name,
X			    strlen( wba[i].wa_Name ) + 1 );
X			UnLock( wba[i].wa_Lock );
X		    }
X		    FreeMem( wbs, wbs->sm_Message.mn_Length );
X		    wbs = NULL;
X
X		    /* Say the game has completed */
X
X		    gptr->prc = NULL;
X		    gptr->active = 0;
X		    active_count--;
X		}
X	    }
X
X	    /* If the workbench was closed, open it back up */
X
X	    if( !wbopen )
X		SetupWB( );
X
X	    /* Reload to clear any deleted games */
X
X	    MapGadgets( R_DISK, 1 );
X	}
X    }
X    cleanup( 0 );
X}
X
Xvoid CopyRight( )
X{
X    extern char *copyright_text[];
X    int line;
X
X    SetDrMd( win->RPort, JAM2 );
X    SetAPen( win->RPort, C_WHITE );
X    SetBPen( win->RPort, C_GREY );
X
X    for(line=0;copyright_text[line];line++){
X	Move( win->RPort, ORIGINX+3, ORIGINY + win->RPort->TxBaseline +
X		(line*win->RPort->TxHeight));
X	if(copyright_text[line][0])
X	     RPText( win->RPort, copyright_text[line]);
X    }
X
X    Delay( 150 );
X    ClearWindow( win );
X}
X
X/*
X * Do the one time initialization things.
X */
X
Xvoid
XInitWB( argc, wbs )
X    int argc;
X    register struct WBStartup *wbs;
X{
X    register int c, i, j;
X    BPTR odir;
X    char *s, **tools, **argv;
X    register struct DiskObject *dobj;
X    register struct WBArg *wba;
X
X    /* Open Libraries */
X    GfxBase= (struct GfxBase *) OldOpenLibrary("graphics.library");
X    IconBase= OldOpenLibrary("icon.library");
X    DiskfontBase= (struct DiskfontBase *)OldOpenLibrary("diskfont.library");
X    IntuitionBase= (struct IntuitionBase *)OldOpenLibrary("intuition.library");
X
X    if(!GfxBase || !IconBase || !DiskfontBase || !IntuitionBase)
X    {
X	error("library open failed");
X	cleanup( 1 );
X    }
X
X    /* Get Port for replied WBStartup messages */
X
X    if( ( dosport = CreatePort( NULL, 0 ) ) == NULL )
X    {
X	error("failed to create dosport" );
X	cleanup( 1 );
X    }
X
X    /* If started from CLI */
X    if( argc != 0 )
X    {
X	argv = (char **)wbs;
X	for( i = 1; i < argc; ++i )
X	{
X	    if( argv[i][0] != '-' )
X		break;
X	    for( j = 1; c = argv[i][j]; ++j )
X	    {
X		switch( c )
X		{
X		case 'm':   /* Close screen and window during game to
X			     * save memory  */
X		    shutdown++;
X		    break;
X
X		case 'c':       /* Configuration to load */
X		    if( i + 1 < argc && argv[i][j+1] == 0 )
X		    {
X			strcpy( NetHackCnf, argv[ ++i ] );
X			goto nextargv;
X		    }
X		    else
X		    {
X			fprintf( stderr,
X			    "%s: missing config name after -c\n",
X			    argv[ 0 ] );
X			cleanup( 1 );
X		    }
X		    break;
X
X		case 'N':       /* Public screen name */
X		    if( i + 1 < argc && argv[i][j+1] == 0 )
X		    {
X			strcpy( pubscreen, argv[ ++i ] );
X			goto nextargv;
X		    }
X		    else
X		    {
X			fprintf( stderr,
X			    "%s: missing screen name after -N\n",
X			    argv[ 0 ] );
X			cleanup( 1 );
X		    }
X		    break;
X
X		case 'f':       /* Default game "player" */
X		    if( i + 1 < argc && argv[i][j+1] == 0 )
X		    {
X			strcpy( defgname, argv[ ++i ] );
X			goto nextargv;
X		    }
X		    else
X		    {
X			fprintf( stderr,
X			    "%s: missing name after -f\n",
X			    argv[ 0 ] );
X			    cleanup( 1 );
X		    }
X		    break;
X
X		default:
X		    fprintf( stderr, "%s: invalid option %c\n",
X			argv[0], c );
X		    fprintf( stderr,
X			"usage: %s [-m] [-f name] [-c name][ -N screen] \n",
X			argv[ 0 ] );
X		    cleanup( 1 );
X		}
X	    }
Xnextargv:;
X	}
X    }
X    else
X    {
X	/* Process icon's ToolTypes */
X
X	wba = wbs->sm_ArgList;
X	odir = CurrentDir( wba->wa_Lock );
X	if( dobj = GetDiskObject( wba->wa_Name ) )
X	{
X	    tools = (char **) dobj->do_ToolTypes;
X
X	    if( s = FindToolType( tools, "OPTIONS" ) )
X	    {
X		/* OPTIONS=SHUTDOWN will cause the screen to be closed
X		 * when a game is started
X		 */
X		if( MatchToolValue( s, "SHUTDOWN" ) )
X		    ++shutdown;
X	    }
X
X	    /* A different configuration file name */
X
X	    if( s = FindToolType( tools, "CONFIG" ) )
X	    {
X		strcpy( NetHackCnf, s );
X	    }
X
X	    /* A different set of defaults then 'wbdefaults.def' */
X
X	    if( s = FindToolType( tools, "DEFAULT" ) )
X	    {
X		strcpy( defgname, s );
X	    }
X
X	    /* A Public screen to open onto */
X
X	    if( s = FindToolType( tools, "SCREEN" ) )
X	    {
X		strcpy( pubscreen, s );
X	    }
X
X	    FreeDiskObject( dobj );
X	}
X	if( odir )
X	    CurrentDir( odir );
X    }
X}
X
X/*
X * Read a nethack.cnf like file and collect the configuration
X * information from it.
X */
Xvoid ReadConfig()
X{
X    register FILE *fp;
X    register char *buf, *t;
X
X    /* Use a dynamic buffer to limit stack use */
X
X    if( ( buf = xmalloc( 1024 ) ) == NULL )
X    {
X	error( "Can't alloc space to read config file" );
X	cleanup( 1 );
X    }
X
X    /* If the file is not there, can't load it */
X
X    if( ( fp = fopen( NetHackCnf, "r" ) ) == NULL )
X    {
X	errmsg( FLASH, "Can't load config file %s", NetHackCnf );
X	free( buf );
X	return;
X    }
X
X    /* Read the lines... */
X
X    while( fgets( buf, 1024, fp ) != NULL )
X    {
X	if( *buf == '#' )
X	    continue;
X
X	if( ( t = strchr( buf, '\n' ) ) != NULL )
X	    *t = 0;
X
X	if( strnicmp( buf, "PATH=", 5 ) == 0 )
X	{
X	    setoneopt( PATH_IDX, buf + 5 );
X	}
X	else if( strnicmp( buf, "PENS=", 4 ) == 0 )
X	{
X	    setoneopt( PENS_IDX, buf + 4 );
X	}
X	else if( strnicmp( buf, "OPTIONS=", 8 ) == 0 )
X	{
X	    setoneopt( OPTIONS_IDX, buf + 8 );
X	}
X	else if( strnicmp( buf, "HACKDIR=", 8 ) == 0 )
X	{
X	    setoneopt( HACKDIR_IDX, buf + 8 );
X	}
X	else if( strnicmp( buf, "LEVELS=", 7 ) == 0 )
X	{
X	    setoneopt( LEVELS_IDX, buf + 7 );
X	}
X	else if( strnicmp( buf, "SAVE=", 5 ) == 0 )
X	{
X	    setoneopt( SAVE_IDX, buf + 5 );
X	}
X	else
X	{
X	    /* We don't allow manipulation of the other information */
X	}
X    }
X    fclose( fp );
X    free( buf );
X}
X
X/* Close the workbench screen and window */
X
Xvoid CloseDownWB( )
X{
X    ((struct Process *)FindTask( NULL ))->pr_WindowPtr = (APTR)oldwin;
X
X    if( win && win->RPort->TmpRas )
X    {
X	FreeRaster( tmprasp, width, height );
X    }
X
X    if( win )
X	SafeCloseWindow( win );
X
X#ifdef  INTUI_NEW_LOOK
X    if( IntuitionBase->LibNode.lib_Version >= 37 )
X    {
X	while( !scrlocked && CloseScreen( scrn ) == FALSE )
X	{
X	    Ask("Close all vistor Windows to exit" );
X	}
X    }
X    else
X#endif
X    {
X	CloseScreen( scrn );
X    }
X    wbopen = 0;
X}
X
X/* Open the workbench screen and window. */
X
Xvoid SetupWB( )
X{
X    int cpyrwid, i;
X    int txtdiff;
X#ifdef  INTUI_NEW_LOOK
X    int pubopen = 0;
X#endif
X    static int once = 0;
X
X    scrlocked = 0;
X#ifdef  INTUI_NEW_LOOK
X    NewScreenStructure.Extension = scrntags;
X    NewScreenStructure.Type |= NS_EXTENDED;
X#endif
X
X    NewScreenStructure.Width = GfxBase->NormalDisplayColumns;
X    NewScreenStructure.Height = GfxBase->NormalDisplayRows;
X
X#ifdef  INTUI_NEW_LOOK
X    if( IntuitionBase->LibNode.lib_Version < 37 )
X    {
X#endif
X	if( ( scrn = OpenScreen( (void *)
X		&NewScreenStructure ) ) == NULL )
X	{
X	    error( "Can't create screen" );
X	    cleanup( 1 );
X	}
X
X	/* Only set the pens on the screen we open */
X	LoadRGB4( &scrn->ViewPort, Palette, PaletteColorCount );
X#ifdef  INTUI_NEW_LOOK
X    }
X    else
X    {
X	/* No tags beyond here yet */
X	scrntags[1].ti_Tag = TAG_DONE;
X
X	if( *pubscreen != 0 )
X	{
X	    if( ( scrn = LockPubScreen( pubscreen ) ) == 0 )
X	    {
X		scrntags[1].ti_Tag = SA_PubName;
X		scrntags[1].ti_Data = (ULONG) pubscreen;
X		scrntags[2].ti_Tag = TAG_DONE;
X		if( ( scrn = OpenScreen( (void *)
X		    &NewScreenStructure ) ) == NULL )
X		{
X		    error( "Can't create screen" );
X		    cleanup( 1 );
X		}
X		pubopen = 1;
X		scrlocked = 0;
X	    }
X	    else
X	    {
X		pubopen = 0;
X		scrlocked = 1;
X	    }
X	}
X	else
X	{
X	    if( ( scrn = LockPubScreen( NULL ) ) == 0 )
X	    {
X		error( "Can't lock Workbench screen" );
X		cleanup( 1 );
X	    }
X	    scrlocked = 1;
X	}
X    }
X#endif
X
X    cpyrwid = 0;
X    for( i = 0; copyright_text[i]; ++i )
X	cpyrwid = max(cpyrwid, strlen( copyright_text[i] ) );
X
X    /* 28 is magic for the width of the sizing gadget under 2.04 and
X     * later.
X     */
X    NewWindowStructure1.Width = (cpyrwid * scrn->RastPort.TxWidth) +
X	    scrn->WBorLeft + scrn->WBorRight + 28;
X
X    width = NewWindowStructure1.Width;
X
X    if( NewWindowStructure1.LeftEdge + width > scrn->Width )
X    {
X	if( width > scrn->Width )
X	{
X	    NewWindowStructure1.LeftEdge = 0;
X	    NewWindowStructure1.Width = scrn->Width;
X	}
X	else
X	{
X	    NewWindowStructure1.LeftEdge = (scrn->Width - width)/2;
X	}
X    }
X    height = NewWindowStructure1.Height;
X    NewWindowStructure1.Screen = scrn;
X
X    txtdiff = scrn->RastPort.TxHeight - 8;
X
X#ifdef  INTUI_NEW_LOOK
X    if( scrlocked )
X	strcpy( mytitle, "NetHack WB 3.1 - Select a GAME or press HELP" );
X    else
X	strcpy( mytitle, "Select a GAME or press HELP" );
X
X    NewWindowStructure1.Title = mytitle;
X    if( IntuitionBase->LibNode.lib_Version >= 37 )
X    {
X	((struct PropInfo *)Scroll.SpecialInfo)->Flags |= PROPNEWLOOK;
X    }
X#endif
X
X    if( !once )
X    {
X	((struct Border *) Message.GadgetRender)->XY[2] =
X		NewWindowStructure1.Width +
X		Message.Width - Message.LeftEdge;
X	Message.TopEdge = scrn->RastPort.TxHeight + scrn->WBorTop + 1;
X	Message.Height = scrn->RastPort.TxHeight + 3;
X	    ((struct Border *) Message.GadgetRender)->XY[1] =
X	    (((struct Border *) Message.GadgetRender)->XY[3] +=
X		scrn->RastPort.TxHeight - 6 );
X    }
X
X    if( ( win = MyOpenWindow( &NewWindowStructure1 ) ) == NULL )
X    {
X#ifdef  INTUI_NEW_LOOK
X	if( IntuitionBase->LibNode.lib_Version >= 37 )
X	{
X	    if( scrlocked )
X		UnlockPubScreen( NULL, scrn );
X	}
X#endif
X	error( "Can't create window" );
X	cleanup( 1 );
X    }
X#ifdef  INTUI_NEW_LOOK
X    if( IntuitionBase->LibNode.lib_Version >= 37 )
X    {
X	if( scrlocked )
X	    UnlockPubScreen( NULL, scrn );
X	else if( pubopen )
X	    PubScreenStatus( scrn, 0 );
X    }
X#endif
X
X    ((struct Border *) Message.GadgetRender)->XY[2] =
X	    win->Width - win->BorderLeft -
X		win->BorderRight - 1;
X
X    RefreshGList( &Message, win, NULL, 1 );
X#ifdef  INTUI_NEW_LOOK
X    if( IntuitionBase->LibNode.lib_Version >= 37 )
X	RefreshWindowFrame( win );
X#endif
X
X    oldwin = (struct Window *)((struct Process *)FindTask( NULL ))->pr_WindowPtr;
X    ((struct Process *)FindTask( NULL ))->pr_WindowPtr = (APTR)win;
X
X    if( ( tmprasp = (void *) AllocRaster( width, height ) ) == NULL )
X    {
X	win->RPort->TmpRas = NULL;
X	fprintf( stderr, "No Space for raster %d x %d\n", height, width );
X	cleanup( 1 );
X    }
X
X    InitTmpRas( &tmpras, tmprasp, RASSIZE( width, height ) );
X
X    win->RPort->TmpRas = &tmpras;
X
X    SetUpMenus( &MenuList1, scrn );
X    SetMenuStrip( win, &MenuList1 );
X    wbopen = 1;
X    once = 1;
X}
X
X/* Map the gadgets onto the screen at the correct location */
X
Xvoid MapGadgets( reason, update )
X    int reason;
X    int update;
X{
X    GPTR gptr;
X
X    /* Make sure that any down gadget is popped back up */
X
X    if( lastgaddown )
X	SetGadgetUP( &lastgaddown->dobj->do_Gadget );
X    lastgaddown = NULL;
X
X    /* Grey Menu Items, no Game icon will be selected */
X
X    ChgGameItems( &MenuList1, 0 );
X
X    /* Remove them first */
X
X    for( gptr = windowgads; gptr; gptr = gptr->nextwgad )
X    {
X	RemoveGadget( win, &gptr->dobj->do_Gadget );
X    }
X    windowgads = NULL;
X
X    /* Remove any non-existant games */
X
X    ClearDelGames( );
X
X    /* If disk changed, reload existing icons */
X
X    if( reason == R_DISK )
X    {
X	LoadIcons( );
X    }
X
X    /* Always move back to home unless we were scrolling */
X
X    if( reason != R_SCROLL )
X    {
X	curcol = 0;
X    }
X
X    /* Calculate locations and display gadgets */
X
X    CalcLocs( update );
X}
X
Xvoid ClearWindow( win )
X    struct Window *win;
X{
X    /* Clear the old gadgets from the window */
X
X    SetAPen( win->RPort, C_GREY );
X    SetOPen( win->RPort, C_GREY );
X    SetDrPt( win->RPort, 0xffff );
X    SetDrMd( win->RPort, JAM2 );
X
X    RectFill( win->RPort, ORIGINX, ORIGINY, CORNERX-1, CORNERY-1 );
X}
X
X/* Calculate the place for and attach the gadgets to the window */
X
Xvoid
XCalcLocs( update )
X    int update;
X{
X    register GPTR gptr;
X    register USHORT ox, oy, cx, cy;
X    int gadid = GADNEWGAME;
X    int addx = 0, sizex, sizey;
X
X    cols = vcols = 0;
X    scol = -1;
X
X    /* Upper left corner of window */
X
X    ox = ORIGINX;
X    oy = ORIGINY;
X
X    /* Lower right corner of window */
X
X    cx = CORNERX;
X
X    /* Account for text labels at the bottom by pulling the bottom up. */
X    cy = CORNERY - win->RPort->TxHeight - 3;
X
X    ClearWindow( win );
X
X    /* Map the current list */
X
X    for( gptr = gamehead; gptr; gptr = gptr->next )
X    {
X	/* If not to the horizontal offset yet, don't display */
X
X	sizex = GADWIDTH( &gptr->dobj->do_Gadget );
X	sizey = gptr->dobj->do_Gadget.Height;
X	addx = max( sizex, addx );
X
X	/* If the current column comes before the visible column... */
X	if( cols < curcol )
X	{
X	    oy += sizey + GADINCY + 3;
X	    if( gptr->next )
X	    {
X		if( oy + gptr->next->dobj->do_Gadget.Height + 3 >= cy )
X		{
X		    cols++;
X		    ox += addx + GADINCX;
X		    if( GADWIDTH( &gptr->next->dobj->do_Gadget ) >
X			gptr->next->dobj->do_Gadget.Width )
X		    {
X			ox += ( GADWIDTH( &gptr->next->dobj->do_Gadget ) -
X			gptr->next->dobj->do_Gadget.Width ) / 2 + 1;
X		    }
X		    oy = ORIGINY;
X		    addx = 0;
X		}
X	    }
X	    continue;
X	}
X
X	if( scol == -1 )
X	{
X	    ox = ORIGINX;
X	    scol = cols;
X	}
X
X	/* If visible, draw it */
X
X	if( ox + sizex + GADINCX < cx )
X	{
X	    /* Link to mapped gadgets list */
X
X	    gptr->nextwgad = windowgads;
X	    windowgads = gptr;
X
X	    /* Set screen locations, if text is longer, scoot the
X	     * gadget over to make room for it.
X	     */
X
X	    if( GADWIDTH( &gptr->dobj->do_Gadget ) >
X		    gptr->dobj->do_Gadget.Width )
X	    {
X		gptr->dobj->do_Gadget.LeftEdge = ox +
X		    ( GADWIDTH( &gptr->dobj->do_Gadget ) -
X			gptr->dobj->do_Gadget.Width ) / 2 + 1;
X	    }
X	    else
X		gptr->dobj->do_Gadget.LeftEdge = ox;
X	    addx = max( addx, GADWIDTH( &gptr->dobj->do_Gadget) );
X	    gptr->dobj->do_Gadget.TopEdge = oy;
X	    gptr->dobj->do_Gadget.GadgetID = gadid++;
X
X	    AddGadget( win, &gptr->dobj->do_Gadget, 0 );
X	}
X
X	/* Stack vertically first, then horizontally */
X
X	if( gptr->next )
X	{
X	    oy += sizey + GADINCY + 3;
X	    if( oy + gptr->next->dobj->do_Gadget.Height + 3 >= cy )
X	    {
X		ox += addx + GADINCX;
X		cols++;
X		if( ox + GADWIDTH( &gptr->next->dobj->do_Gadget) < cx )
X		    vcols++;
X		addx = 0;
X		oy = ORIGINY;
X	    }
X	}
X    }
X
X    /* Display all of the gadgets */
X
X    RefreshGList( win->FirstGadget, win, NULL, -1 );
X
X    /* Set up the slider if forcing a new position, otherwise
X     * the slider was probably moved and its position should be
X     * left where the user put it instead of jerking it around
X     */
X    if( update )
X	UpdatePropGad( win, &Scroll, vcols+1, cols+1, scol );
X}
X
X/* Open the indicated window and place the IntuiText list passed in that
X * window.  Then wait for the OKAY gadget to be clicked on.
X */
Xvoid text_requester( newwin, tlist )
X    register struct NewWindow *newwin;
X    struct IntuiText *tlist;
X{
X    register struct Window *win;
X    register struct IntuiMessage *imsg;
X    register struct Gadget *gd;
X    int done = 0;
X    int i;
X    long class;
X    struct NewWindow **aonce;
X    static struct NewWindow *once[ 6+1 ];
X    int lines[ 10 ], lcnt = 0, avone = -1;
X    register int txtdiff = scrn->RastPort.TxHeight - 8;
X
X    newwin->Screen = scrn;
X
X    for( i = 0; i < 6; ++i )
X    {
X	if( newwin == once[i] )
X	    break;
X	if( once[i] == 0 && avone == -1 )
X	    avone = i;
X    }
X    aonce = &once[avone];
X
X    /* If spacing not correct, fix it up now */
X    if( *aonce == NULL )
X    {
X	register struct IntuiText *ip = tlist;
X	for( ; ip; ip = ip->NextText )
X	{
X	    if( lcnt == 0 )
X		lines[ lcnt++ ] = ip->TopEdge;
X	    else
X	    {
X		register found = 0;
X		for( i = 0; i < lcnt; ++i )
X		{
X		    if( lines[ i ] > ip->TopEdge )
X			break;
X		    if( lines[ i ] == ip->TopEdge )
X		    {
X			found = 1;
X			break;
X		    }
X		}
X
X		if( !found )
X		{
X		    if( i < lcnt )
X		    {
X			int j;
X			for( j = lcnt; j > i; --j )
X			    lines[ j ] = lines[ j - 1 ];
X		    }
X		    lcnt++;
X		    lines[ i ] = ip->TopEdge;
X		}
X	    }
X	}
X
X	for( ip = tlist; ip; ip = ip->NextText )
X	{
X	    for( i = 0; i < lcnt; ++i )
X	    {
X		if( ip->TopEdge == lines[ i ] )
X		{
X		    ip->TopEdge += txtdiff*i;
X		    break;
X		}
X	    }
X	}
X
X	gd = FindGadget( NULL, newwin, GADHELPOKAY );
X	gd->TopEdge += (lcnt+1)*txtdiff;
X	gd->Height += txtdiff;
X	SetBorder( gd, -1 );
X	newwin->Height += txtdiff * (lcnt+2);
X	*aonce = newwin;
X    }
X
X    if( ( win = MyOpenWindow( newwin ) ) == NULL )
X    {
X	errmsg( FLASH, "Can't create window" );
X	return;
X    }
X
X    PrintIText( win->RPort, tlist, 0, txtdiff );
X
X    while( !done )
X    {
X	WaitPort( win->UserPort );
X	while( ( imsg = (struct IntuiMessage * )
X	    GetMsg( win->UserPort ) ) != NULL )
X	{
X	    class = imsg->Class;
X	    ReplyMsg( (struct Message *) imsg );
X	    switch( class )
X	    {
X		case CLOSEWINDOW: done = 1; break;
X		case VANILLAKEY: done = 1; break;
X		/* Should be GADHELPOKAY */
X		case GADGETUP: done = 1; break;
X	    }
X	}
X    }
X    SafeCloseWindow( win );
X}
X
X/* Scroll through a file which is passed by name */
X
Xvoid help_requester( file )
X    char *file;
X{
X    register struct Window *win;
X    register struct IntuiMessage *imsg;
X    register struct Gadget *gd;
X    FILE *fp;
X    int done = 0, line = 0, lines, topline, tlines, i;
X    static int once = 0, lastdown;
X    char buf[ 100 ];
X    long loff[ 100 ];
X    long class, code;
X    int txtdiff = scrn->RastPort.TxHeight - 8;
X
X    if( ( fp = fopen( file, "r" ) ) == NULL )
X    {
X#ifdef  __SASC_60
X	errmsg( FLASH, "Can't open %s: %s", file, strerror(errno) );
X#else
X	errmsg( FLASH, "Can't open %s: %s", file, sys_errlist[errno] );
X#endif
X	return;
X    }
X    for( tlines = 0; tlines < 100 ; ++tlines )
X    {
X	loff[ tlines ] = ftell( fp );
X	if( fgets( buf, sizeof( buf ), fp ) == NULL )
X	    break;
X    }
X
X    if( !once )
X    {
X	for( gd = Help3_NewWindowStructure10.FirstGadget;
X		    gd; gd = gd->NextGadget )
X	{
X	    if( gd->GadgetID != 0 )
X	    {
X		if( gd->GadgetID == GADHELPFRWD ||
X		    gd->GadgetID == GADHELPBKWD )
X		{
X		    gd->Height += txtdiff;
X		}
X		SetBorder( gd, -1 );
X	    }
X	}
X	once = 1;
X	Help3_NewWindowStructure10.Height += txtdiff;
X    }
X
X    Help3_NewWindowStructure10.Screen = scrn;
X    if( ( win = MyOpenWindow( &Help3_NewWindowStructure10 ) ) == NULL )
X    {
X	errmsg( FLASH, "Can't create requester window" );
X	fclose( fp );
X	return;
X    }
X    lines = ( (win->Height - win->BorderTop - 25 ) / win->RPort->TxHeight );
X    topline = win->BorderTop + win->RPort->TxBaseline + 2;
X    Move( win->RPort, win->BorderLeft, topline );
X
X    SetAPen( win->RPort, C_BLACK );
X    SetBPen( win->RPort, C_GREY );
X    SetDrMd( win->RPort, JAM2 );
X
X    for( i = 0; i < min( lines, tlines ); ++i )
X    {
X	getline( fp, loff, i, buf, sizeof( buf ) );
X	Move( win->RPort, win->BorderLeft + 2,
X	    topline + (i * win->RPort->TxHeight) );
X	Text( win->RPort, buf, strlen( buf )-1 );
X    }
X
X    while( !done )
X    {
X	WaitPort( win->UserPort );
X	while( ( imsg = (void *) GetMsg( win->UserPort ) ) != NULL )
X	{
X	    class = imsg->Class;
X	    code = imsg->Code;
X	    gd = (struct Gadget *)imsg->IAddress;
X
X	    ReplyMsg( (struct Message *) imsg );
X
X	    switch( class )
X	    {
X		case VANILLAKEY:
X		    if( code == 'u' || code == ('U'-64))
X		    {
X			goto bkwd;
X		    }
X		    else if( code == 'd' || code == ('D'-64))
X		    {
X			goto frwd;
X		    }
X		    else if( code == '\33' || code == 'q' )
X		    {
X			done = 1;
X		    }
X		    break;
X
X		case CLOSEWINDOW:
X		    done = 1;
X		    break;
X
X		case GADGETUP:
X		    lastdown = 0;
X		    break;
X
X		case GADGETDOWN:
X		    lastdown = gd->GadgetID;
X		    break;
X
X		case INTUITICKS:
X		    if( lastdown == GADHELPFRWD )
X		    {
X			frwd:
X			if( line + lines < tlines )
X			{
X			    line++;
X			    WaitTOF();
X			    ScrollRaster( win->RPort, 0,
X				win->RPort->TxHeight,
X				win->BorderLeft,
X				win->BorderTop + 2,
X				win->Width - win->BorderRight - 1,
X				win->BorderTop + 2 +
X				(lines*win->RPort->TxHeight) );
X			    getline( fp, loff, line + lines - 1,
X				buf, sizeof( buf ) );
X			    Move( win->RPort, win->BorderLeft + 2,
X				topline + ( ( lines - 1 ) *
X				win->RPort->TxHeight ) );
X			    WaitTOF();
X			    Text( win->RPort, buf, strlen( buf )-1 );
X			}
X			else
X			{
X			    /* EOF */
X			    DisplayBeep( scrn );
X			}
X		    }
X		    else if( lastdown == GADHELPBKWD )
X		    {
X			bkwd:
X			if( line > 0 )
X			{
X			    line--;
X			    WaitTOF();
X			    ScrollRaster( win->RPort, 0,
X				-win->RPort->TxHeight,
X				win->BorderLeft,
X				win->BorderTop + 2,
X				win->Width - win->BorderRight - 1,
X				win->BorderTop + 2 +
X				(lines*win->RPort->TxHeight) );
X			    getline( fp, loff, line, buf, sizeof( buf ) );
X			    Move( win->RPort, win->BorderLeft + 2, topline );
X			    WaitTOF();
X			    Text( win->RPort, buf, strlen( buf )-1 );
X			}
X			else
X			{
X			    DisplayBeep( scrn );
X			}
X		    }
X		    break;
X
X	    }
X	}
X    }
X    SafeCloseWindow( win );
X    fclose( fp );
X}
X
X/* Act on the menu item number passed */
X
Xvoid
Xdo_menu(mcode)
X    register int mcode;
X{
X    switch(MENUNUM(mcode))
X    {
X	case MENU_PROJECT:
X	    switch(ITEMNUM(mcode))
X	    {
X		case ITEM_HELP:
X		    help_requester( "NetHack:HackWB.hlp" );
X		    break;
X
X		case ITEM_ABOUT:
X		    text_requester( &About_NewWindowStructure9,
X			    &About_IntuiTextList9 );
X		    break;
X
X		case ITEM_SCORES:
X		    menu_scores( );
X		    break;
X
X		case ITEM_RECOVER:
X		    menu_recover( );
X		    break;
X
X		case ITEM_EDDEF:
X		    menu_editdef( GAME_FROM_DEFAULT );
X		    break;
X
X		case ITEM_CONFIG:
X		    menu_config( );
X		    break;
X
X		case ITEM_QUIT:
X		    quit = Ask( "Ready to Quit?" );
X		    break;
X
X	    }
X	    break;
X
X	case MENU_GAME:
X	    switch( ITEMNUM( mcode ) )
X	    {
X
X		case ITEM_INFO:
X		    menu_info( );
X		    break;
X
X		case ITEM_SETCOMMENT:
X		    menu_comment( );
X		    break;
X
X		case ITEM_SETOPT:
X		    menu_setopt( );
X		    break;
X
X		case ITEM_COPYOPT:
X		    menu_copyopt( );
X		    break;
X
X		case ITEM_DISCARD:
X		    menu_discard( );
X		    break;
X
X		case ITEM_RENAME:
X		    menu_rename( );
X		    break;
X	    }
X    }
X}
X
Xvoid
Xmenu_discard()
X{
X    register GPTR gptr;
X
X    if( ( gptr = NeedGame() ) == NULL )
X	return;
X
X    if( Ask("Discard Selected Game?") )
X    {
X	lastgaddown = NULL;
X	if( DeleteGame( gptr ) == 0 )
X	{
X	    errmsg( FLASH, "Discard may have failed for %s",
X		    GameName( gptr, NULL ) );
X	}
X
X	MapGadgets( R_DISK, 1 );
X    }
X}
X
Xvoid
Xrun_game( gptr )
X    register GPTR gptr;
X{
X    struct Task *ctask;
X    register struct MsgPort *proc = NULL;
X    char buf[ 100 ], *t;
X    char namebuf[ 100 ];
X    int once, tidx;
X
X    if( gptr->active )
X    {
X	errmsg( FLASH, "%s is already in progress", gptr->name );
X	return;
X    }
X
X    tidx = 0;
X
X    /* If newgame gadget, then check game name */
X
X    if( gptr->dobj->do_Gadget.GadgetID == GADNEWGAME )
X    {
X	    /*
X	    if currrent name in use, get new name
X	    */
X
X	if( !defgame.plname )
X	    defgame.plname = strdup( defgname );
X
X	/* Put options from gadgets into options[ OPTIONS_IDX ] */
X
X	PutOptions( curopts );
X
X	once = 0;
X	sprintf( buf, "%s/%s.sav", options[ SAVE_IDX ], defgame.plname );
X	while( access( buf, 0 ) == 0 )
X	{
X	    if( StrRequest( "Game Already Exists, Enter a New Name",
X		namebuf, once ? namebuf : defgame.plname ) == 0 )
X	    {
X		return;
X	    }
X	    once = 1;
X	    sprintf( buf, "%s/%s.sav", options[ SAVE_IDX ], namebuf );
X	}
X
X	/* Set new name to use, if done one at all */
X	if( once )
X	{
X	    if( defgame.plname ) free( defgame.plname );
X	    defgame.plname = strdup( namebuf );
X	}
X
X	    /* set defaults for this game from previous defaults. */
X	if( defgame.plname && stricmp( defgame.plname, "wbdefaults" ) )
X	    SetToolLine( gptr, "NAME", defgame.plname );
X	if( defgame.pltype )
X	    SetToolLine( gptr, "CHARACTER", players[ defgame.pltype ] );
X
X	gptr->gname = xmalloc( 20 + strlen( defgame.plname ) );
X    }
X    else
X    {
X	gptr->gname = xmalloc( 20 + strlen( gptr->name ) );
X    }
X
X    SetToolLine( gptr, "PATH", options[ PATH_IDX ] );
X    if( defgame.options )
X	SetToolLine( gptr, "OPTIONS", defgame.options );
X    else
X	SetToolLine( gptr, "OPTIONS", options[ OPTIONS_IDX ] );
X
X    /* Prefer a setting in the users data over the global one */
X    if( ( ( t = ToolsEntry( gptr, "PENS" ) ) == NULL || *t == 0 ) &&
X      ( ( t = ToolsEntry( gptr, "PEN" ) ) == NULL || *t == 0 ) )
X    {
X	t = options[ PENS_IDX ];
X    }
X    SetToolLine( gptr, "PENS", t );
X    SetToolLine( gptr, "HACKDIR", options[ HACKDIR_IDX ] );
X    SetToolLine( gptr, "LEVELS", options[ LEVELS_IDX ] );
X    SetToolLine( gptr, "SAVE", options[ SAVE_IDX ] );
X
X    gptr->wbs = AllocMem( sizeof( struct WBStartup ) +
X    ( sizeof( struct WBArg ) * 2 ), MEMF_PUBLIC | MEMF_CLEAR );
X
X    /* Check if we got everything */
X
X    if( !gptr->gname || !gptr->wbs )
X    {
X	fprintf( stderr, "Can't allocate memory\n" );
X	goto freemem;
X    }
X
X    /* Get the arguments structure space */
X
X    gptr->wba = ( struct WBArg * ) ((long)gptr->wbs +
X		sizeof( struct WBStartup ) );
X
X    /* Close down window and screen if requested */
X
X    if( shutdown )
X	CloseDownWB( );
X
X    /* Load the game into memory */
X#ifdef SPLIT
X    /* Which version do we run? */
X    {
X    char gi[80];
X
X    sprintf( gi, "%s.dir", GAMEIMAGE );
X    if( access( gi, 0 ) == 0 ){
X	gptr->seglist = (BPTR)s_LoadSeg( gi );
X	if( gptr->seglist ) running_split=1;
X    }else{
X	gptr->seglist = (BPTR)LoadSeg( GAMEIMAGE );
X    }
X    }
X#else
X    gptr->seglist = (BPTR)LoadSeg( GAMEIMAGE );
X#endif
X
X    if( gptr->seglist == NULL)
X    {
X	if( !wbopen )
X	    SetupWB( );
X	errmsg( FLASH, "Can't load %s", GAMEIMAGE );
X	goto freemem;
X    }
X    /* Build WBStartup from current game info */
X
X    /* Set the game name for the status command */
X
X    sprintf( gptr->gname, "NetHack 3.1 %s", gptr->name );
X
X    /* Create a process for the game to execute in */
X
X    ctask = FindTask( NULL );
X    proc = CreateProc( gptr->gname, ctask->tc_Node.ln_Pri,
X	gptr->seglist, GAMESTACK );
X
X    /* Check if the create failed */
X
X    if( proc == NULL )
X    {
X    fprintf(stderr, "Error creating process %d\n", IoErr() );
X#ifdef SPLIT
X	if(!running_split)
X#endif
X	    UnLoadSeg( gptr->seglist );
Xfreemem:
X    if( gptr->gname ) free( gptr->gname );
X    gptr->gname = NULL;
X
X    if( gptr->wbs ) FreeMem( gptr->wbs,
X	sizeof( struct WBStartup ) + sizeof( struct WBArg ) * 2 );
X    gptr->wbs = NULL;
X    if( !wbopen )
X	SetupWB( );
X    return;
X    }
X
X    /* Get the Process structure pointer */
X
X    gptr->prc = (struct Process *) (((long)proc) - sizeof( struct Task ));
X
X    /* Set the current directory */
X
X    gptr->prc->pr_CurrentDir=((struct Process *)FindTask(NULL))->pr_CurrentDir;
X
X    /* Fill in the startup message */
X
X    gptr->wbs->sm_Process = proc;
X    gptr->wbs->sm_Segment = gptr->seglist;
X    gptr->wbs->sm_NumArgs = 2;
X    gptr->wbs->sm_ToolWindow = "con:0/0/350/50/Amiga NetHack 3.1";
X    gptr->wbs->sm_ArgList = gptr->wba;
X
X    /* Fill in the args */
X
X    gptr->wba[0].wa_Name = Strdup( GAMEIMAGE );
X    gptr->wba[0].wa_Lock = Lock( dirname( GAMEIMAGE ), ACCESS_READ );
X
X    gptr->wba[1].wa_Name = Strdup( gptr->name );
X    gptr->wba[1].wa_Lock = Lock( gptr->dname, ACCESS_READ );
X
X    /* Write the updated tools types entries */
X
X    WriteDObj( gptr, gptr->wba[1].wa_Lock );
X
X    /* Set the message fields correctly */
X
X    gptr->wbs->sm_Message.mn_Node.ln_Type = NT_MESSAGE;
X    gptr->wbs->sm_Message.mn_Node.ln_Pri = 0;
X    gptr->wbs->sm_Message.mn_ReplyPort = dosport;
X    gptr->wbs->sm_Message.mn_Length =
X	sizeof( struct WBStartup ) + ( sizeof( struct WBArg ) * 2 );
X
X    /* mark game as in use */
X
X    active_count++;
X    gptr->active = 1;
X
X    /* Send the WB Startup message to let the game go... */
X
X    PutMsg( proc, &gptr->wbs->sm_Message );
X}
X
Xvoid CloseLibraries( )
X{
X    if( IntuitionBase )     CloseLibrary( (void *) IntuitionBase );
X    IntuitionBase = 0;
X    if( DiskfontBase )      CloseLibrary( (void *) DiskfontBase );
X    DiskfontBase = 0;
X    if( IconBase )          CloseLibrary(  IconBase );
X    IconBase = 0;
X    if( GfxBase )           CloseLibrary( (void *) GfxBase );
X    GfxBase = 0;
X}
X
Xvoid cleanup( code )
X    int code;
X{
X    if( active_count )
X    {
X	errmsg( FLASH, "There %s still %d game%s active...",
X		active_count > 1 ? "are" : "is",
X		active_count,
X		active_count > 1 ? "s" : "" );
X	return;
X    }
X
X    if( dosport ) DeletePort( dosport );
X    dosport = NULL;
X
X    CloseDownWB( );
X    CleanUpLists( );
X    CloseLibraries( );
X
X#ifdef SPLIT
X    if(running_split)s_UnLoadSeg();
X#endif
X    exit( code );
X}
X
XGPTR AllocGITEM( )
X{
X    register GPTR gptr;
X
X    if( gameavail )
X    {
X	gptr = gameavail;
X	gameavail = gameavail->next;
X    }
X    else
X    {
X	gptr = xmalloc( sizeof( GAMEITEM ) );
X    }
X
X    if( gptr )
X	memset( gptr, 0, sizeof( GAMEITEM ) );
X
X    return( gptr );
X}
X
Xvoid FreeGITEM( gptr )
X    register GPTR gptr;
X{
X    /* Free all of the pieces first */
X
X    if( gptr->talloc )
X	FreeTools( gptr );
X
X    if( gptr->dobj )
X	FreeDObj( gptr->dobj );
X
X    gptr->dobj = NULL;
X
X    if( gptr->name )
X	free( gptr->name );
X    gptr->name = NULL;
X
X    if( gptr->dname )
X	free( gptr->dname );
X    gptr->dname = NULL;
X
X    if( gptr->fname )
X	free( gptr->fname );
X    gptr->fname = NULL;
X
X    /* Connect it to free list */
X
X    gptr->next = gameavail;
X    gameavail = gptr;
X}
X
Xstruct DiskObject *AllocDObj( str )
X    register char *str;
X{
X    register struct DiskObject *doptr;
X    register char *t, *t1;
X
X    if( ( t = strrchr( str, '.' ) ) && stricmp( t, ".info" ) == 0 )
X    {
X	*t = 0;
X    }
X    else
X    {
X	t = NULL;
X    }
X
X    if( doptr = GetDiskObject( str ) )
X    {
X	struct IntuiText *ip;
X
X	diskobj_filter(doptr);  /* delete INTERNALCLI */
X
X	if( ip = xmalloc( sizeof( struct IntuiText ) ) )
X	{
X	    memset( ip, 0, sizeof( struct IntuiText ) );
X	    ip->FrontPen = C_BLACK;
X	    ip->DrawMode = JAM1;
X	    ip->LeftEdge = (doptr->do_Gadget.Width -
X		( strlen( str ) * win->RPort->TxWidth ))/2;
X	    ip->TopEdge = doptr->do_Gadget.Height;
X	    ip->IText = strdup( str );
X	    doptr->do_Gadget.GadgetText = ip;
X
X	    /* Trim any .sav off of the end. */
X
X	    if( ( t1 = strrchr( ip->IText, '.' ) ) &&
X		    stricmp( t1, ".sav" ) == 0 )
X	    {
X		*t1 = 0;
X		ip->LeftEdge += (2 * win->RPort->TxWidth);
X	    }
X	}
X    }
X    if( t ) *t = '.';
X
X    return( doptr );
X}
X
Xvoid LoadIcons( )
X{
X    register GPTR gptr, newgame;
X    register BPTR savedir;
X    register char *t;
X    register struct FileInfoBlock *finfo;
X    char buf[ 200 ];
X
X    /* Check if we can access the new save directory */
X
X    if( ( savedir = Lock( options[ SAVE_IDX ], ACCESS_READ ) ) == NULL )
X    {
X	errmsg( FLASH,
X		"Can't access save directory: %s", options[ SAVE_IDX ] );
X	return;
X    }
X
X    if( ( finfo = (struct FileInfoBlock *)
X		    xmalloc( sizeof( struct FileInfoBlock ) ) ) == NULL )
X    {
X	UnLock( savedir );
X	errmsg( FLASH, "Can't alloc memory" );
X	return;
X    }
X
X    if( newgame = gamehead )
X	gamehead = gamehead->next;
X
X    if( !Examine( savedir, finfo ) )
X    {
X	UnLock( savedir );
X	free( finfo );
X	errmsg( FLASH, "Can't Examine save directory" );
X	return;
X    }
X
X    /* Collect all of the entries */
X
X    while( ExNext( savedir, finfo ) )
X    {
X	/* If already got this game, continue */
X
X	if( gptr = FindGame( finfo->fib_FileName ) )
X	    continue;
X
X	/* Get just the ones we are interested in */
X
X	if( ( t = strrchr( finfo->fib_FileName, '.' ) ) == NULL ||
X		    stricmp( t, ".info" ) != 0 )
X	    continue;
X
X	if( t == finfo->fib_FileName )
X	    continue;
X
X	/* Get a gadget item */
X
X	if( gptr = GetWBIcon( savedir, options[ SAVE_IDX ], finfo ) )
X	{
X	    gptr->next = gamehead;
X	    gamehead = gptr;
X	}
X    }
X
X    /* Get the NewGame gadget */
X
X    UnLock( savedir );
X    if( newgame == NULL )
X    {
X	/* Pick up the new game if not there yet. */
X
X	sprintf( buf, "%sNewGame.info", options[ HACKDIR_IDX ] );
X	if( savedir = Lock( buf, ACCESS_READ ) )
X	{
X	    if( Examine( savedir, finfo ) )
X	    {
X		UnLock( savedir );
X		savedir = Lock( options[ HACKDIR_IDX ], ACCESS_READ );
X		if( gptr = GetWBIcon( savedir,
X			options[ HACKDIR_IDX ], finfo ) )
X		{
X		    gptr->next = gamehead;
X		    gamehead = gptr;
X		}
X	    }
X	    UnLock( savedir );
X	    free( finfo );
X	}
X	else
X	{
X	    errmsg( FLASH, "No access to %s", buf );
X	}
X    }
X    else
X    {
X	newgame->next = gamehead;
X	gamehead = newgame;
X    }
X}
X
Xvoid menu_recover()
X{
X    int execit = 1;
X    long class, code;
X    struct Gadget *gd, *lastact = 0;
X    int done = 0;
X    struct IntuiMessage *imsg;
X    struct Window *w;
X    static int once = 0;
X    int txtdiff = scrn->RastPort.TxHeight - 8;
X    struct IntuiText *ip;
X
X    if( !once )
X    {
X	for( gd = Rst_NewWindowStructure12.FirstGadget;
X		    gd; gd = gd->NextGadget )
X	{
X	    switch( gd->GadgetID )
X	    {
X		case GADRESTDIR:
X		    gd->TopEdge += txtdiff;
X		    gd->Height += txtdiff;
X		    SetBorder( gd, -1 );
X		    strcpy(RstDir,options[LEVELS_IDX]);
X		    break;
X		case GADRESTOLD:
X		    gd->TopEdge += txtdiff*2;
X		    gd->Height += txtdiff;
X		    SetBorder( gd, -1 );
X		    strcpy(RstOld,"levels");
X		    break;
X		case GADRESTNEW:
X		    gd->TopEdge += txtdiff*3;
X		    gd->Height += txtdiff;
X		    SetBorder( gd, -1 );
X		    break;
X		case GADRESTOKAY:
X		    gd->TopEdge += txtdiff*4;
X		    gd->Height += txtdiff;
X		    SetBorder( gd, -1 );
X		    break;
X		case GADRESTCAN:
X		    gd->TopEdge += txtdiff*4;
X		    gd->Height += txtdiff;
X		    SetBorder( gd, -1 );
X		    break;
X	    }
X	}
X	Rst_NewWindowStructure12.Height += txtdiff*5;
X	for( ip = &Rst_IntuiTextList12; ip; ip = ip->NextText )
X	{
X	    if( *ip->IText == 'O' )
X		ip->TopEdge += txtdiff;
X	    else if( *ip->IText == 'N' )
X		ip->TopEdge += txtdiff*2;
X	}
X	once = 1;
X    }
X
X    Rst_NewWindowStructure12.Screen = scrn;
X    if( ( w = MyOpenWindow( &Rst_NewWindowStructure12 ) ) == NULL )
X    {
X	errmsg( FLASH, "Can't create requester window" );
X	return;
X    }
X    PrintIText( w->RPort, &Rst_IntuiTextList12, 0, txtdiff );
X    lastact = FindGadget( w, NULL, GADRESTDIR );
X
X    while( !done )
X    {
X	WaitPort( w->UserPort );
X	while( imsg = (struct IntuiMessage *) GetMsg( w->UserPort ) )
X	{
X	    class = imsg->Class;
X	    code = imsg->Code;
X	    gd = (struct Gadget *)imsg->IAddress;
X	    ReplyMsg( (struct Message *) imsg );
X	    switch( class )
X	    {
X		case CLOSEWINDOW:
X		    done = 1;
X		    execit = 0;
X		    break;
X
X		case ACTIVEWINDOW:
X		    ActivateGadget( lastact, w, NULL );
X		    break;
X
X		case GADGETUP:
X		    if( gd->GadgetID == GADRESTOKAY )
X			done = 1;
X		    else if( gd->GadgetID == GADRESTCAN )
X		    {
X			execit = 0;
X			done = 1;
X		    }
X		    else if( gd->GadgetID == GADRESTDIR )
X		    {
X			if( gd = FindGadget( w, NULL, GADRESTOLD ) )
X			    ActivateGadget( lastact = gd, w, NULL );
X		    }
X		    else if( gd->GadgetID == GADRESTOLD )
X		    {
X			if( gd = FindGadget( w, NULL, GADRESTNEW ) )
X			    ActivateGadget( lastact = gd, w, NULL );
X		    }
X		    break;
X
X		case VANILLAKEY:
X		    if( code == '\33' )
X		    {
X			done = 1;
X			execit = 0;
X		    }
X		    break;
X	    }
X	}
X    }
X
X    SafeCloseWindow( w );
X
X    if( execit )
X    {
X	char buf[255];
X	sprintf( buf, "stack 65000\nNetHack:Recover -d %s %s", RstDir, RstOld );
X	Execute( buf, NULL, NULL );
X	MapGadgets( R_DISK, 1);
X    }
X}
X
END_OF_FILE
if test 39564 -ne `wc -c <'sys/amiga/wb.c1'`; then
    echo shar: \"'sys/amiga/wb.c1'\" unpacked with wrong size!
fi
# end of 'sys/amiga/wb.c1'
fi
echo shar: End of archive 39 \(of 108\).
cp /dev/null ark39isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \
21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \
41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 \
61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 \
81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 \
101 102 103 104 105 106 107 108 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 108 archives.
    echo "Now execute 'rebuild.sh'"
    rm -f ark10[0-8]isdone ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
