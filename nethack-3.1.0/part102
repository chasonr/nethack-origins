Path: uunet!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v16i110:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Part102/108
Message-ID: <4475@master.CNA.TEK.COM>
Date: 5 Feb 93 22:03:43 GMT
Sender: news@master.CNA.TEK.COM
Lines: 1817
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1661

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 16, Issue 110
Archive-name: nethack31/Part102
Supersedes: nethack3p9: Volume 10, Issue 46-108
Environment: Amiga, Atari, Mac, MS-DOS, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 102 (of 108)."
# Contents:  include/color.h include/dungeon.h include/objclass.h
#   include/patchlevel.h include/wintty.h src/exper.c
#   sys/amiga/wbdata.c sys/amiga/wbdefs.h sys/mac/NHrez.hqx
#   sys/msdos/exesmurf.doc win/X11/Window.c
# Wrapped by billr@saab on Wed Jan 27 16:09:30 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'include/color.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/color.h'\"
else
echo shar: Extracting \"'include/color.h'\" \(1467 characters\)
sed "s/^X//" >'include/color.h' <<'END_OF_FILE'
X/*	SCCS Id: @(#)color.h	3.1	92/02/02
X/* Copyright (c) Steve Linhart, Eric Raymond, 1989. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#ifndef COLOR_H
X#define COLOR_H
X
X/*
X * The color scheme used is tailored for an IBM PC.  It consists of the
X * standard 8 colors, folowed by their bright counterparts.  There are
X * exceptions, these are listed below.  Bright black doesn't mean very
X * much, so it is used as the "default" foreground color of the screen.
X */
X#define BLACK		0
X#define RED		1
X#define GREEN		2
X#define BROWN		3	/* on IBM, low-intensity yellow is brown */
X#define BLUE		4
X#define MAGENTA 	5
X#define CYAN		6
X#define GRAY		7	/* low-intensity white */
X#define NO_COLOR	8
X#define ORANGE_COLORED	9	/* "orange" conflicts with the object */
X#define BRIGHT_GREEN	10
X#define YELLOW		11
X#define BRIGHT_BLUE	12
X#define BRIGHT_MAGENTA  13
X#define BRIGHT_CYAN	14
X#define WHITE		15
X#define MAXCOLORS	16
X
X/* The "half-way" point for tty based color systems.  This is used in */
X/* the tty color setup code.  (IMHO, it should be removed - dean).    */
X#define BRIGHT		8
X
X/* these can be configured */
X#define HI_OBJ		MAGENTA
X#define HI_METAL	CYAN
X#define HI_COPPER	YELLOW
X#define HI_SILVER	GRAY
X#define HI_GOLD 	YELLOW
X#define HI_LEATHER	BROWN
X#define HI_CLOTH	BROWN
X#define HI_ORGANIC	BROWN
X#define HI_WOOD 	BROWN
X#define HI_PAPER	WHITE
X#define HI_GLASS	BRIGHT_CYAN
X#define HI_MINERAL	GRAY
X#define HI_ZAP		BRIGHT_BLUE
X
X#endif /* COLOR_H */
END_OF_FILE
if test 1467 -ne `wc -c <'include/color.h'`; then
    echo shar: \"'include/color.h'\" unpacked with wrong size!
fi
# end of 'include/color.h'
fi
if test -f 'include/dungeon.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/dungeon.h'\"
else
echo shar: Extracting \"'include/dungeon.h'\" \(5116 characters\)
sed "s/^X//" >'include/dungeon.h' <<'END_OF_FILE'
X/*	SCCS Id: @(#)dungeon.h	3.1	93/01/17	*/
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#ifndef DUNGEON_H
X#define DUNGEON_H
X
Xtypedef struct d_flags {	/* dungeon/level type flags */
X	Bitfield(town, 1);	/* is this a town? (levels only) */
X	Bitfield(hellish, 1);	/* is this part of hell? */
X	Bitfield(maze_like, 1);	/* is this a maze? */
X	Bitfield(rogue_like, 1); /* is this an old-fashioned presentation? */
X	Bitfield(align, 3);	/* dungeon alignment. */
X	Bitfield(unused, 1);	/* etc... */
X} d_flags;
X
X#include "align.h"
X
Xtypedef struct d_level {	/* basic dungeon level element */
X	xchar	dnum;		/* dungeon number */
X	xchar	dlevel;		/* level number */
X} d_level;
X
Xtypedef struct s_level {	/* special dungeon level element */
X	struct	s_level	*next;
X	d_level	dlevel;		/* dungeon & level numbers */
X	char	proto[15];	/* name of prototype file (eg. "tower") */
X	char    boneid;		/* character to id level in bones files */
X	uchar	rndlevs;	/* no. of randomly available similar levels */
X	d_flags	flags;		/* type flags */
X} s_level;
X
Xtypedef struct stairway {	/* basic stairway identifier */
X	xchar	sx, sy;		/* x / y location of the stair */
X	d_level	tolev;		/* where does it go */
X	char	up;		/* what type of stairway (up/down) */
X} stairway;
X
X/* level region types */
X#define LR_DOWNSTAIR 0
X#define LR_UPSTAIR 1
X#define LR_PORTAL 2
X#define LR_BRANCH 3
X#define LR_TELE 4
X#define LR_UPTELE 5
X#define LR_DOWNTELE 6
X
Xtypedef struct dest_area {	/* non-stairway level change indentifier */
X	xchar	lx, ly;		/* "lower" left corner (near [0,0]) */
X	xchar	hx, hy;		/* "upper" right corner (near [COLNO,ROWNO]) */
X	xchar	nlx, nly;	/* outline of invalid area */
X	xchar	nhx, nhy;	/* opposite corner of invalid area */
X} dest_area;
X
Xtypedef struct dungeon {	/* basic dungeon identifier */
X	char	dname[24];	/* name of the dungeon (eg. "Hell") */
X	char	proto[15];	/* name of prototype file (eg. "tower") */
X	char	boneid;		/* character to id dungeon in bones files */
X	d_flags	flags;		/* dungeon flags */
X	xchar	entry_lev;	/* entry level */
X	xchar	num_dunlevs;	/* number of levels in this dungeon */
X	xchar	dunlev_ureached; /* how deep you have been in this dungeon */
X	int	ledger_start,	/* the starting depth in "real" terms */
X		depth_start;	/* the starting depth in "logical" terms */
X} dungeon;
X
X/*
X * A branch structure defines the connection between two dungeons.  They
X * will be ordered by the dungeon number/level number of 'end1'.  Ties
X * are resolved by 'end2'.  'Type' uses 'end1' arbitrarily as the primary
X * point.
X */
Xtypedef struct branch {
X    struct branch *next;	/* next in the branch chain */
X    int		  id;		/* branch identifier */
X    int		  type;		/* type of branch */
X    d_level	  end1;		/* "primary" end point */
X    d_level	  end2;		/* other end point */
X    boolean	  end1_up;	/* does end1 go up? */
X} branch;
X
X/* branch types */
X#define BR_STAIR   0	/* "Regular" connection, 2 staircases. */
X#define BR_NO_END1 1	/* "Regular" connection.  However, no stair from  */
X			/*	end1 to end2.  There is a stair from end2 */
X			/*	to end1.				  */
X#define BR_NO_END2 2	/* "Regular" connection.  However, no stair from  */
X			/*	end2 to end1.  There is a stair from end1 */
X			/*	to end2.				  */
X#define BR_PORTAL  3	/* Connection by magic portals (traps) */
X
X
X/* A particular dungeon contains num_dunlevs d_levels with dlevel 1..
X * num_dunlevs.  Ledger_start and depth_start are bases that are added
X * to the dlevel of a particular d_level to get the effective ledger_no
X * and depth for that d_level.
X *
X * Ledger_no is a bookkeeping number that gives a unique identifier for a
X * particular d_level (for level.?? files, e.g.).
X *
X * Depth corresponds to the number of floors below the surface.
X */
X#define Is_astralevel(x)	(on_level(x, &astral_level))
X#define Is_earthlevel(x)	(on_level(x, &earth_level))
X#define Is_waterlevel(x)	(on_level(x, &water_level))
X#define Is_firelevel(x)		(on_level(x, &fire_level))
X#define Is_airlevel(x)		(on_level(x, &air_level))
X#define Is_medusa_level(x)	(on_level(x, &medusa_level))
X#define Is_oracle_level(x)	(on_level(x, &oracle_level))
X#define Is_valley(x)		(on_level(x, &valley_level))
X#define Is_asmo_level(x)	(on_level(x, &asmodeus_level))
X#define Is_baal_level(x)	(on_level(x, &baalzebub_level))
X#define Is_wiz1_level(x)	(on_level(x, &wiz1_level))
X#define Is_wiz2_level(x)	(on_level(x, &wiz2_level))
X#define Is_wiz3_level(x)	(on_level(x, &wiz3_level))
X#define Is_sanctum(x)		(on_level(x, &sanctum_level))
X#define Is_portal_level(x)	(on_level(x, &portal_level))
X#define Is_rogue_level(x)	(on_level(x, &rogue_level))
X#define Is_stronghold(x)	(on_level(x, &stronghold_level))
X#define Is_bigroom(x)		(on_level(x, &bigroom_level))
X#ifdef MULDGN
X#define Is_qstart(x)		(on_level(x, &qstart_level))
X#define Is_qlocate(x)		(on_level(x, &qlocate_level))
X#define Is_nemesis(x)		(on_level(x, &nemesis_level))
X#define Is_knox(x)		(on_level(x, &knox_level))
X#endif
X
X#define Inhell			In_hell(&u.uz)	/* now gehennom */
X#define In_endgame(x)		((x)->dnum == astral_level.dnum)
X
X#endif /* DUNGEON_H */
END_OF_FILE
if test 5116 -ne `wc -c <'include/dungeon.h'`; then
    echo shar: \"'include/dungeon.h'\" unpacked with wrong size!
fi
# end of 'include/dungeon.h'
fi
if test -f 'include/objclass.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/objclass.h'\"
else
echo shar: Extracting \"'include/objclass.h'\" \(5079 characters\)
sed "s/^X//" >'include/objclass.h' <<'END_OF_FILE'
X/*	SCCS Id: @(#)objclass.h	3.1	92/10/18	*/
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#ifndef OBJCLASS_H
X#define OBJCLASS_H
X
X/* definition of a class of objects */
X
Xstruct objclass {
X	short	oc_name_idx;		/* index of actual name */
X	short	oc_descr_idx;		/* description when name unknown */
X	char *	oc_uname;		/* called by user */
X	Bitfield(oc_name_known,1);
X	Bitfield(oc_merge,1);	/* merge otherwise equal objects */
X	Bitfield(oc_uses_known,1); /* obj->known affects full decription */
X				/* otherwise, obj->dknown and obj->bknown */
X				/* tell all, and obj->known should always */
X				/* be set for proper merging behavior */
X	Bitfield(oc_magic,1);	/* inherently magical object */
X	Bitfield(oc_charged,1);	/* may have +n or (n) charges */
X	Bitfield(oc_unique,1);	/* special one-of-a-kind object */
X	Bitfield(oc_big,1);
X#define oc_bimanual	oc_big	/* for weapons */
X#define oc_bulky	oc_big	/* for armor */
X
X	Bitfield(oc_dir,2);
X#define	NODIR		1
X#define	IMMEDIATE	2
X#define	RAY		3
X
X	Bitfield(oc_material,5);
X#define LIQUID		1	/* currently only for venom */
X#define WAX		2
X#define VEGGY		3	/* foodstuffs */
X#define FLESH		4	/*   ditto    */
X#define PAPER		5
X#define CLOTH		6
X#define LEATHER		7
X#define WOOD		8
X#define BONE		9
X#define DRAGON_HIDE	10	/* not leather! */
X#define IRON		11	/* Fe - includes steel */
X#define METAL		12	/* Sn, &c. */
X#define COPPER		13	/* Cu - includes brass */
X#define SILVER		14	/* Ag */
X#define GOLD		15	/* Au */
X#define PLATINUM	16	/* Pt */
X#define MITHRIL		17
X#define PLASTIC		18
X#define GLASS		19
X#define GEMSTONE	20
X#define MINERAL		21
X
X#define is_organic(otmp)	(objects[otmp->otyp].oc_material <= WOOD)
X#define is_metallic(otmp)	(objects[otmp->otyp].oc_material >= IRON && \
X				 objects[otmp->otyp].oc_material <= PLATINUM)
X#define is_corrodeable(otmp)	(objects[otmp->otyp].oc_material == COPPER)
X#define is_rustprone(otmp)	(objects[otmp->otyp].oc_material == IRON)
X
X	uchar	oc_oprop;		/* property (invis, &c.) conveyed */
X	char	oc_class;		/* object class */
X	schar	oc_delay;		/* delay when using such an object */
X#ifdef TEXTCOLOR
X	uchar	oc_color;		/* display color of the object */
X#endif /* TEXTCOLOR */
X	short	oc_prob;		/* probability, used in mkobj() */
X	unsigned short	oc_weight;	/* encumbrance (1 cn = 0.1 lb.) */
X	short	oc_cost;		/* base cost in shops */
X/* Check the AD&D rules!  The FIRST is small monster damage. */
X/* for weapons, and tools, rocks, and gems useful as weapons */
X	schar	oc_wsdam, oc_wldam;	/* max small/large monster damage */
X	schar	oc_oc1, oc_oc2;
X#define	oc_hitbon	oc_oc1		/* weapons: "to hit" bonus */
X#define w_propellor	oc_oc2		/* weapons: negative value = bow */
X#define WP_BOW		1
X#define WP_SLING	2
X#define WP_CROSSBOW	3
X
X#define	a_ac		oc_oc1	/* armor class, used in ARM_BONUS in do.c */
X#define	a_can		oc_oc2		/* armor: used in mhitu.c */
X#define oc_level	oc_oc2		/* books: spell level */
X
X	unsigned short	oc_nutrition;	/* food value */
X};
X
Xstruct objdescr {
X	const char *oc_name;		/* actual name */
X	const char *oc_descr;		/* description when name unknown */
X};
X
Xextern struct objclass NEARDATA objects[];
Xextern struct objdescr NEARDATA obj_descr[];
X
X/*
X * All objects have a class. Make sure that all classes have a corresponding
X * symbol below.
X */
X#define	RANDOM_CLASS	 0	/* used for generating random objects */
X#define	ILLOBJ_CLASS	 1
X#define	WEAPON_CLASS	 2
X#define	ARMOR_CLASS	 3
X#define	RING_CLASS	 4
X#define	AMULET_CLASS	 5
X#define	TOOL_CLASS	 6
X#define	FOOD_CLASS	 7
X#define	POTION_CLASS	 8
X#define	SCROLL_CLASS	 9
X#define	SPBOOK_CLASS	10	/* actually SPELL-book */
X#define	WAND_CLASS	11
X#define	GOLD_CLASS	12
X#define	GEM_CLASS	13
X#define	ROCK_CLASS	14
X#define	BALL_CLASS	15
X#define	CHAIN_CLASS	16
X#define	VENOM_CLASS	17
X#define MAXOCLASSES     18
X
X#define ALLOW_COUNT	(MAXOCLASSES+1)	/* Can be used in the object class */
X#define ALL_CLASSES	(MAXOCLASSES+2)	/* input to getobj().		   */
X#define ALLOW_NONE	(MAXOCLASSES+3)	/*				   */
X
X#if 0	/* moved to decl.h so that makedefs.c won't see them */
Xextern const char def_oc_syms[MAXOCLASSES];	/* default class symbols */
Xextern uchar oc_syms[MAXOCLASSES];		/* current class symbols */
X#endif
X
X/* Default definitions of all object-symbols (must match classes above). */
X
X#define	ILLOBJ_SYM	']'	/* should be same as S_MIMIC_DEF      */
X#define	WEAPON_SYM	')'
X#define	ARMOR_SYM	'['
X#define	RING_SYM	'='
X#define	AMULET_SYM	'"'
X#define	TOOL_SYM	'('
X#define	FOOD_SYM	'%'
X#define	POTION_SYM	'!'
X#define	SCROLL_SYM	'?'
X#define	SPBOOK_SYM	'+'
X#define	WAND_SYM	'/'
X#define	GOLD_SYM	'$'
X#define	GEM_SYM		'*'
X#define	ROCK_SYM	'`'
X#define	BALL_SYM	'0'
X#define	CHAIN_SYM	'_'
X#define	VENOM_SYM	'.'
X
X#ifdef TUTTI_FRUTTI
Xstruct fruit {
X	char fname[PL_FSIZ];
X	int fid;
X	struct fruit *nextf;
X};
X#define newfruit() (struct fruit *)alloc(sizeof(struct fruit))
X#define dealloc_fruit(rind) free((genericptr_t) (rind))
X#endif
X
X#define OBJ_NAME(obj)  (obj_descr[(obj).oc_name_idx].oc_name)
X#define OBJ_DESCR(obj) (obj_descr[(obj).oc_descr_idx].oc_descr)
X#endif /* OBJCLASS_H */
END_OF_FILE
if test 5079 -ne `wc -c <'include/objclass.h'`; then
    echo shar: \"'include/objclass.h'\" unpacked with wrong size!
fi
# end of 'include/objclass.h'
fi
if test -f 'include/patchlevel.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/patchlevel.h'\"
else
echo shar: Extracting \"'include/patchlevel.h'\" \(5118 characters\)
sed "s/^X//" >'include/patchlevel.h' <<'END_OF_FILE'
X/*
X *  Patch 1, July 31, 1989
X *  add support for Atari TOS (courtesy Eric Smith) and Andrew File System
X *	(courtesy Ralf Brown)
X *  include the uuencoded version of termcap.arc for the MSDOS versions that
X *	was included with 2.2 and 2.3
X *  make a number of simple changes to accommodate various compilers
X *  fix a handful of bugs, and do some code cleaning elsewhere
X *  add more instructions for new environments and things commonly done wrong
X */
X
X/*
X *  Patch 2, August 16, 1989
X *  add support for OS/2 (courtesy Timo Hakulinen)
X *  add a better makefile for MicroSoft C (courtesy Paul Gyugyi)
X *  more accomodation of compilers and preprocessors
X *  add better screen-size sensing
X *  expand color use for PCs and introduce it for SVR3 UNIX machines
X *  extend '/' to multiple identifications
X *  allow meta key to be used to invoke extended commands
X *  fix various minor bugs, and do further code cleaning
X */
X
X/*
X *  Patch 3, September 6, 1989
X *  add war hammers and revise object prices
X *  extend prototypes to ANSI compilers in addition to the previous MSDOS ones
X *  move object-on-floor references into functions in preparation for planned
X *	data structures to allow faster access and better colors
X *  fix some more bugs, and extend the portability of things added in earlier
X *	patches
X */
X
X/*
X *  Patch 4, September 27, 1989
X *  add support for VMS (courtesy David Gentzel)
X *  move monster-on-floor references into functions and implement the new
X *	lookup structure for both objects and monsters
X *  extend the definitions of objects and monsters to provide "living color"
X *	in the dungeon, instead of a single monster color
X *  ifdef varargs usage to satisfy ANSI compilers
X *  standardize on the color 'gray'
X *  assorted bug fixes
X */
X
X/*
X *  Patch 5, October 15, 1989
X *  add support for Macintosh OS (courtesy Johnny Lee)
X *  fix annoying dependency loop via new color.h file
X *  allow interruption while eating -- general handling of partially eaten food
X *  smarter treatment of iron balls (courtesy Kevin Darcy)
X *  a handful of other bug fixes
X */
X
X/*
X *  Patch 6, November 19, 1989
X *  add overlay support for MS-DOS (courtesy Pierre Martineau, Stephen
X *	Spackman, and Norm Meluch)
X *  refine Macintosh port
X *  different door states show as different symbols (courtesy Ari Huttunen)
X *  smarter drawbridges (courtesy Kevin Darcy)
X *  add CLIPPING and split INFERNO off HARD
X *  further refine eating code wrt picking up and resumption
X *  make first few levels easier, by adding :x monsters and increasing initial
X *	attribute points and hitting probability
X *  teach '/' about configurable symbols
X */
X
X/*
X *  Patch 7, February 19, 1990
X *  refine overlay support to handle portions of .c files through OVLx
X *	(courtesy above plus Kevin Smolkowski)
X *  update and extend Amiga port and documentation (courtesy Richard Addison,
X *	Jochen Erwied, Mark Gooderum, Ken Lorber, Greg Olson, Mike Passaretti,
X *	and Gregg Wonderly)
X *  refine and extend Macintosh port and documentation (courtesy Johnny Lee,
X *	Kevin Sitze, Michael Sokolov, Andy Swanson, Jon Watte, and Tom West)
X *  refine VMS documentation
X *  continuing ANSIfication, this time of const usage
X *  teach '/' about differences within monster classes
X *  smarter eating code (yet again), death messages, and treatment of
X *	non-animal monsters, monster unconsciousness, and naming
X *  extended version command to give compilation options
X *  and the usual bug fixes and hole plugs
X */
X
X/*
X *  Patch 8, June 3, 1990
X *  further debug and refine Macintosh port
X *  refine the overlay manager, rearrange the OVLx breakdown for better
X *	efficiency, rename the overlay macros, and split off the overlay
X *	instructions to Install.ovl
X *  introduce NEARDATA for better Amiga efficiency
X *  support for more VMS versions (courtesy Joshua Delahunty and Pat Rankin)
X *  more const fixes
X *  better support for common graphics (DEC VT and IBM)
X *  and a number of simple fixes and consistency extensions
X */
X
X/*
X *  Patch 9, June 26, 1990
X *  clear up some confusing documentation
X *  smooth some more rough edges in various ports
X *  and fix a couple more bugs
X */
X
X/*
X *  Patch 10, February 5, 1991
X *  extend overlay manager to multiple files for easier binary distribution
X *  allow for more system and compiler variance
X *  remove more small insects
X */
X
X/* #define PATCHLEVEL	10 */
X
X/* END Version 3.0, BEGIN Version 3.1 */
X
X/*
X *  NetHack 3.1, January 25, 1993
X *  many, many changes and bugfixes -- some of the highlights include:
X *  display rewrite using line-of-sight vision
X *  general window interface, with the ability to use multiple interfaces
X *	in the same executable
X *  intelligent monsters
X *  enhanced dungeon mythology
X *  branching dungeons with more special levels, quest dungeons, and
X *	multi-level endgame
X *  more artifacts and more uses for artifacts
X *  generalization to multiple shops with damage repair
X *  X11 interface
X *  ability to recover crashed games
X *  full rewrite of Macintosh port
X *  Amiga splitter
X *  directory rearrangement (dat, doc, sys, win, util)
X */
X
X#define PATCHLEVEL	0
END_OF_FILE
if test 5118 -ne `wc -c <'include/patchlevel.h'`; then
    echo shar: \"'include/patchlevel.h'\" unpacked with wrong size!
fi
# end of 'include/patchlevel.h'
fi
if test -f 'include/wintty.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/wintty.h'\"
else
echo shar: Extracting \"'include/wintty.h'\" \(5357 characters\)
sed "s/^X//" >'include/wintty.h' <<'END_OF_FILE'
X/*	SCCS Id: @(#)wintty.h	3.1	92/10/06		  */
X/* Copyright (c) David Cohrs, 1991,1992				  */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#ifndef WINTTY_H
X#define WINTTY_H
X
X#define E extern
X
X#ifndef WINDOW_STRUCTS
X#define WINDOW_STRUCTS
X
X/* descriptor for tty-based windows */
Xstruct WinDesc {
X    int flags;			/* window flags */
X    xchar type;			/* type of window */
X    boolean active;		/* true if window is active */
X    uchar offx, offy;		/* offset from topleft of display */
X    short rows, cols;		/* dimensions */
X    short curx, cury;		/* current cursor position */
X    short maxrow, maxcol;	/* the maximum size used -- for MENU wins */
X				/* maxcol is also used by WIN_MESSAGE for */
X				/* tracking the ^P command */
X    char **data;		/* window data [row][column] */
X    char *resp;			/* valid menu responses (for NHW_MENU) */
X    char *canresp;		/* cancel responses; 1st is the return value */
X    char *morestr;		/* string to display instead of default */
X};
X
X/* window flags */
X#define WIN_CANCELLED 1
X#define WIN_STOP 1		/* for NHW_MESSAGE; stops output */
X
X/* descriptor for tty-based displays -- all the per-display data */
Xstruct DisplayDesc {
X    uchar rows, cols;		/* width and height of tty display */
X    uchar curx, cury;		/* current cursor position on the screen */
X#ifdef TEXTCOLOR
X    int color;			/* current color */
X#endif
X    int attrs;			/* attributes in effect */
X    int toplin;			/* flag for topl stuff */
X    int rawprint;		/* number of raw_printed lines since synch */
X    int inmore;			/* non-zero if more() is active */
X    int inread;			/* non-zero if reading a character */
X    winid lastwin;		/* last window used for I/O */
X};
X
X#endif /* WINDOW_STRUCTS */
X
X#define MAXWIN 20		/* maximum number of windows, cop-out */
X
X/* tty dependent window types */
X#define NHW_BASE    6
X
Xextern struct window_procs tty_procs;
X
X/* port specific variable declarations */
Xextern winid BASE_WINDOW;
X
Xextern struct WinDesc *wins[MAXWIN];
X
Xextern struct DisplayDesc *ttyDisplay;	/* the tty display descriptor */
X
Xextern char morc;		/* last character typed to xwaitforspace */
Xextern char defmorestr[];	/* default --more-- prompt */
X
X/* port specific external function references */
X
X/* ### getline.c ### */
XE void FDECL(xwaitforspace, (const char *));
X
X/* ### termcap.c ### */
X
XE void FDECL(tty_startup,(int*, int*));
X#if defined(apollo)
X/* Apollos don't widen old-style function definitions properly -- they try to
X * be smart and use the prototype, or some such strangeness.  So we have to
X * define UNWIDENDED_PROTOTYPES (in tradstdc.h), which makes CHAR_P below a
X * char.  But the tputs termcap call was compiled as if xputc's argument
X * actually would be expanded.  So here, we have to make an exception. */
XE void FDECL(xputc, (int));
X#else
XE void FDECL(xputc, (CHAR_P));
X#endif
XE void FDECL(xputs, (const char *));
XE void NDECL(cl_end);
XE void NDECL(clear_screen);
XE void NDECL(home);
XE void NDECL(standoutbeg);
XE void NDECL(standoutend);
X# if 0
XE void NDECL(revbeg);
XE void NDECL(boldbeg);
XE void NDECL(blinkbeg);
XE void NDECL(dimbeg);
XE void NDECL(m_end);
X# endif
XE void NDECL(backsp);
XE void NDECL(graph_on);
XE void NDECL(graph_off);
XE void NDECL(cl_eos);
X
X/* ### topl.c ### */
X
XE void FDECL(addtopl, (const char *));
XE void NDECL(more);
XE void FDECL(update_topl, (const char *));
XE void FDECL(putsyms, (const char*));
X
X/* ### wintty.c ### */
X#ifdef CLIPPING
XE void NDECL(setclipped);
X#endif
XE void FDECL(docorner, (int, int));
XE void NDECL(end_glyphout);
XE void FDECL(g_putch, (UCHAR_P));
XE void NDECL(win_tty_init);
X
X/* external declarations */
XE void NDECL(tty_init_nhwindows);
XE void NDECL(tty_player_selection);
XE void NDECL(tty_askname);
XE void NDECL(tty_get_nh_event) ;
XE void FDECL(tty_exit_nhwindows, (const char *));
XE void FDECL(tty_suspend_nhwindows, (const char *));
XE void NDECL(tty_resume_nhwindows);
XE winid FDECL(tty_create_nhwindow, (int));
XE void FDECL(tty_clear_nhwindow, (winid));
XE void FDECL(tty_display_nhwindow, (winid, BOOLEAN_P));
XE void FDECL(tty_dismiss_nhwindow, (winid));
XE void FDECL(tty_destroy_nhwindow, (winid));
XE void FDECL(tty_curs, (winid,int,int));
XE void FDECL(tty_putstr, (winid, int, const char *));
XE void FDECL(tty_display_file, (const char *, BOOLEAN_P));
XE void FDECL(tty_start_menu, (winid));
XE void FDECL(tty_add_menu, (winid, CHAR_P, int, const char *));
XE void FDECL(tty_end_menu, (winid, CHAR_P, const char *, const char *));
XE char FDECL(tty_select_menu, (winid));
XE void NDECL(tty_update_inventory);
XE void NDECL(tty_mark_synch);
XE void NDECL(tty_wait_synch);
X#ifdef CLIPPING
XE void FDECL(tty_cliparound, (int, int));
X#endif
XE void FDECL(tty_print_glyph, (winid,XCHAR_P,XCHAR_P,int));
XE void FDECL(tty_raw_print, (const char *));
XE void FDECL(tty_raw_print_bold, (const char *));
XE int NDECL(tty_nhgetch);
XE int FDECL(tty_nh_poskey, (int *, int *, int *));
XE void NDECL(tty_nhbell);
XE int NDECL(tty_doprev_message);
XE char FDECL(tty_yn_function, (const char *, const char *, CHAR_P));
XE void FDECL(tty_getlin, (const char *,char *));
X#ifdef COM_COMPL
XE void FDECL(tty_get_ext_cmd, (char *));
X#endif /* COM_COMPL */
XE void FDECL(tty_number_pad, (int));
XE void NDECL(tty_delay_output);
X
X/* other defs that really should go away (they're tty specific) */
XE void NDECL(tty_start_screen);
XE void NDECL(tty_end_screen);
X
X#undef E
X
X#endif /* WINTTY_H */
END_OF_FILE
if test 5357 -ne `wc -c <'include/wintty.h'`; then
    echo shar: \"'include/wintty.h'\" unpacked with wrong size!
fi
# end of 'include/wintty.h'
fi
if test -f 'src/exper.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/exper.c'\"
else
echo shar: Extracting \"'src/exper.c'\" \(4843 characters\)
sed "s/^X//" >'src/exper.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)exper.c	3.1	90/22/02
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include "hack.h"
X
X#ifdef LINT
X#define	NEW_SCORING
X#endif
Xlong
Xnewuexp(lev)
Xregister unsigned lev;
X{
X#ifdef LINT	/* long conversion */
X	return(0L * lev);
X#else
X	if(lev < 10) return (10L*(1L << lev));
X	if(lev < 20) return (10000L*(1L << (lev-10)));
X	return (10000000L*(lev-19));
X#endif
X}
X
Xint
Xexperience(mtmp, nk)	/* return # of exp points for mtmp after nk killed */
X	register struct	monst *mtmp;
X	register int	nk;
X{
X	register struct permonst *ptr = mtmp->data;
X	int	i, tmp, tmp2;
X
X	tmp = 1 + mtmp->m_lev * mtmp->m_lev;
X
X/*	For higher ac values, give extra experience */
X	if((i = find_mac(mtmp)) < 3) tmp += (7 - i) * (i < 0) ? 2 : 1;
X
X/*	For very fast monsters, give extra experience */
X	if(ptr->mmove >= 12) tmp += (ptr->mmove >= 18) ? 5 : 3;
X
X/*	For each "special" attack type give extra experience */
X	for(i = 0; i < NATTK; i++) {
X
X	    tmp2 = ptr->mattk[i].aatyp;
X	    if(tmp2 > AT_BUTT) {
X
X		if(tmp2 == AT_WEAP) tmp += 5;
X		else if(tmp2 == AT_MAGC) tmp += 10;
X		else tmp += 3;
X	    }
X	}
X
X/*	For each "special" damage type give extra experience */
X	for(i = 0; i < NATTK; i++) {
X
X	    tmp2 = ptr->mattk[i].adtyp;
X	    if(tmp2 > AD_PHYS && tmp2 < AD_BLND) tmp += 2*mtmp->m_lev;
X	    else if((tmp2 == AD_DRLI) || (tmp2 == AD_STON)) tmp += 50;
X	    else if(tmp != AD_PHYS) tmp += mtmp->m_lev;
X		/* extra heavy damage bonus */
X	    if((int)(ptr->mattk[i].damd * ptr->mattk[i].damn) > 23)
X		tmp += mtmp->m_lev;
X	}
X
X/*	For certain "extra nasty" monsters, give even more */
X	if(extra_nasty(ptr)) tmp += (7*mtmp->m_lev);
X	if(ptr->mlet == S_EEL) tmp += 1000;
X
X/*	For higher level monsters, an additional bonus is given */
X	if(mtmp->m_lev > 8) tmp += 50;
X
X#ifdef NEW_SCORING
X	/* ------- recent addition: make nr of points decrease
X		   when this is not the first of this kind */
X	{ unsigned ul = u.ulevel;
X	  int ml = mtmp->m_lev;
X	/* points are given based on present and future level */
X	  if(ul < MAXULEV)
X	    for(tmp2 = 0; !tmp2 || ul + tmp2 <= ml; tmp2++)
X		if(u.uexp + 1 + (tmp + ((tmp2 <= 0) ? 0 : 4<<(tmp2-1)))/nk
X		    >= newuexp(ul) )
X			if(++ul == MAXULEV) break;
X
X	  tmp2 = ml - ul -1;
X	  tmp = (tmp + ((tmp2 < 0) ? 0 : 4<<tmp2))/nk;
X	  if(tmp <= 0) tmp = 1;
X	}
X	/* note: ul is not necessarily the future value of u.ulevel */
X	/* ------- end of recent valuation change ------- */
X#endif /* NEW_SCORING /**/
X
X#ifdef MAIL
X	/* Mail daemons put up no fight. */
X	if(mtmp->data == &mons[PM_MAIL_DAEMON]) tmp = 1;
X#endif
X
X	return(tmp);
X}
X
Xvoid
Xmore_experienced(exp, rexp)
X	register int exp, rexp;
X{
X	u.uexp += exp;
X	u.urexp += 4*exp + rexp;
X	if(exp
X#ifdef SCORE_ON_BOTL
X	   || flags.showscore
X#endif
X	   ) flags.botl = 1;
X	if(u.urexp >= ((pl_character[0] == 'W') ? 1000 : 2000))
X		flags.beginner = 0;
X}
X
Xvoid
Xlosexp() {	/* hit by drain life attack */
X
X	register int num;
X
X#ifdef POLYSELF
X	if(resists_drli(uasmon)) return;
X#endif
X
X	if(u.ulevel > 1) {
X		pline("Goodbye level %u.", u.ulevel--);
X		/* remove intrinsic abilities */
X		adjabil((int)u.ulevel+1, (int)u.ulevel);
X	} else
X		u.uhp = -1;
X	num = newhp();
X	u.uhp -= num;
X	u.uhpmax -= num;
X	num = rn1((int)u.ulevel/2+1, 2);		/* M. Stephenson */
X	u.uen -= num;
X	if (u.uen < 0)		u.uen = 0;
X	u.uenmax -= num;
X	if (u.uenmax < 0)	u.uenmax = 0;
X	u.uexp = newuexp(u.ulevel) - 1;
X	flags.botl = 1;
X}
X
X/*
X * Make experience gaining similar to AD&D(tm), whereby you can at most go
X * up by one level at a time, extra expr possibly helping you along.
X * After all, how much real experience does one get shooting a wand of death
X * at a dragon created with a wand of polymorph??
X */
Xvoid
Xnewexplevel() {
X
X	register int tmp;
X
X	if(u.ulevel < MAXULEV && u.uexp >= newuexp(u.ulevel)) {
X
X		u.ulevel++;
X		if (u.uexp >= newuexp(u.ulevel)) u.uexp = newuexp(u.ulevel) - 1;
X		pline("Welcome to experience level %u.", u.ulevel);
X		set_uasmon();	/* set up for the new level. */
X		/* give new intrinsics */
X		adjabil((int)u.ulevel-1, (int)u.ulevel);
X		tmp = newhp();
X		u.uhpmax += tmp;
X		u.uhp += tmp;
X		tmp = rn1((int)ACURR(A_WIS)/2+1, 2); /* M. Stephenson */
X		u.uenmax += tmp;
X		u.uen += tmp;
X		flags.botl = 1;
X	}
X}
X
Xvoid
Xpluslvl() {
X	register int num;
X
X	You("feel more experienced.");
X	num = newhp();
X	u.uhpmax += num;
X	u.uhp += num;
X	num = rn1((int)ACURR(A_WIS)/2+1, 2);	/* M. Stephenson */
X	u.uenmax += num;
X	u.uen += num;
X	if(u.ulevel < MAXULEV) {
X		u.uexp = newuexp(u.ulevel);
X		pline("Welcome to experience level %u.", ++u.ulevel);
X		adjabil((int)u.ulevel-1, (int)u.ulevel);
X	}
X	flags.botl = 1;
X}
X
Xlong
Xrndexp()
X{
X	register long minexp,maxexp;
X
X	if(u.ulevel == 1)
X		return rn2((int)newuexp(1));
X	else {
X		minexp = newuexp(u.ulevel - 1);
X		maxexp = newuexp(u.ulevel);
X		return(minexp + rn2((int)(maxexp - minexp)));
X	}
X}
X
X/*exper.c*/
END_OF_FILE
if test 4843 -ne `wc -c <'src/exper.c'`; then
    echo shar: \"'src/exper.c'\" unpacked with wrong size!
fi
# end of 'src/exper.c'
fi
if test -f 'sys/amiga/wbdata.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/amiga/wbdata.c'\"
else
echo shar: Extracting \"'sys/amiga/wbdata.c'\" \(5137 characters\)
sed "s/^X//" >'sys/amiga/wbdata.c' <<'END_OF_FILE'
X/*    SCCS Id: @(#)wbdata.c     3.1    93/01/08
X/* Copyright (c) Kenneth Lorber, Bethesda, Maryland, 1992, 1993.  */
X/* NetHack may be freely redistributed.  See license for details. */
X
Xstruct IntuitionBase *IntuitionBase;
Xstruct GfxBase *GfxBase;
Xstruct Library *IconBase;
Xstruct DiskfontBase *DiskfontBase;
Xstruct Screen *scrn;
Xstruct Window *oldwin;
Xchar *classes = "ABCEHKPRSTVW";
Xstruct TmpRas tmpras;
X
XDEFAULTS  defgame =
X{
X    PL_RANDOM,
X    NULL, NULL,
X};
X
XOPTIONS curopts[] =
X{
X    { 0, 1, "checkpoint", NULL, GADOCHKPOINT, },
X    { 0, 1, "color", NULL, GADOCOLOR, },
X    { 0, 1, "confirm", NULL, GADOCONFIRM, },
X    { 0, 1, "disclose", NULL, GADODISCLOSE, },
X    { 0, 0, "female", NULL, GADOFEMALE, },
X    { 0, 1, "fixinv", NULL, GADOFIXINV, },
X    { 0, 0, "flush", NULL, GADOFLUSH, },
X    { 0, 1, "help", NULL, GADOHELP, },
X    { 0, 1, "hilite_pet", NULL, GADOHILITEPET, },
X    { 0, 0, "ignintr", NULL, GADOIGNINTR, },
X    { 0, 1, "legacy", NULL, GADOLEGACY, },
X    { 0, 0, "lit_corridor", NULL, GADOLITCORRIDOR, },
X    { 0, 1, "news", NULL, GADONEWS, },
X    { 0, 0, "numberpad", NULL, GADONUMBERPAD, },
X    { 0, 1, "null", NULL, GADONULL, },
X    { 0, 1, "pickup", NULL, GADOPICKUP, },
X    { 0, 0, "rest_on_space", NULL, GADORESTONSPACE, },
X    { 0, 1, "safepet", NULL, GADOSAFEPET, },
X    { 0, 0, "showexp", NULL, GADOSHOWEXP, },
X    { 0, 0, "showscore", NULL, GADOSHOWSCORE, },
X    { 0, 1, "silent", NULL, GADOSILENT, },
X    { 0, 1, "sortpack", NULL, GADOSORTPACK, },
X    { 0, 1, "sound", NULL, GADOSOUND, },
X    { 0, 0, "standout", NULL, GADOSTANDOUT, },
X    { 0, 0, "time", NULL, GADOTIME, },
X    { 0, 1, "tombstone", NULL, GADOTOMBSTONE, },
X    { 0, 1, "verbose", NULL, GADOVERBOSE, },
X    { 0, 0, "asksave", NULL, GADOASKSAVE, },
X    { 0, 0, "packorder", "", GADOPACKORDER, },
X    { 0, 0, "dogname", "", GADODOGNAME, },
X    { 0, 0, "catname", "", GADOCATNAME, },
X    { 0, 0, "fruit", "", GADOFRUIT, },
X    { 0, 0, "objects", "", GADOOBJECTS, },
X    { 0, 0, NULL, NULL, -1 },
X};
X
Xchar *players[ ] =
X{
X    "Random",
X    "Archeologist",
X    "Barbarian",
X    "CaveMan",
X    "Elf",
X    "Healer",
X    "Knight",
X    "Priest",
X    "Rogue",
X    "Samurai",
X    "Tourist",
X    "Valkyrie",
X    "Wizard",
X    NULL,
X};
X
Xchar *options[ NUMIDX + 1 ] =
X{
X    "Nethack:",				/* PATH_IDX */
X    "",					/* OPTIONS_IDX */
X    "Nethack:",				/* HACKDIR_IDX */
X    "Nethack:levels",			/* LEVELS_IDX */
X    "Nethack:save",			/* SAVE_IDX */
X    "AAA,FFF,620,B08,181,C06,23E,D00",	/* PENS_IDX */
X
X    NULL,				/* Terminating option */
X};
X
XUSHORT __chip up_renderdata[] = {
X/* Plane 0 */
X   0xfff0,
X   0x8700,
X   0x8f80,
X   0xbfe0,
X   0x8000,
X
X/* Plane 1 */
X   0x0008,
X   0x0708,
X   0x0f88,
X   0x3fe8,
X   0x7ff8,
X
X};
X
Xstruct Image up_renderimage = {
X   0, 0,
X   13, 5, 2,
X   up_renderdata,
X   3,0,
X   NULL,
X};
X
XUSHORT __chip up_selectdata[] = {
X/* Plane 0 */
X   0x0008, 0x78f8, 0x7078, 0x4018, 0xfff8,
X/* Plane 1 */
X   0xfff0, 0xf8f0, 0xf070, 0xc010, 0x0000,
X};
X
Xstruct Image up_selectimage = {
X   0, 0,
X   13, 5, 2,
X   up_selectdata,
X   3,0,
X   NULL,
X};
X
XUSHORT __chip down_renderdata[] = {
X/* Plane 0 */
X   0xfff0,
X   0xbfe0,
X   0x8f80,
X   0x8700,
X   0x8000,
X
X/* Plane 1 */
X   0x0008,
X   0x3fe8,
X   0x0f88,
X   0x0708,
X   0x7ff8,
X
X};
X
Xstruct Image down_renderimage = {
X   0, 0,
X   13, 5, 2,
X   down_renderdata,
X   3,0,
X   NULL,
X};
X
XUSHORT __chip down_selectdata[] = {
X/* Plane 0 */
X   0x0008, 0x4018, 0x7078, 0x78f8, 0x7ff8,
X/* Plane 1 */
X   0xfff0, 0xc010, 0xf070, 0xf8f0, 0x8000,
X};
X
Xstruct Image down_selectimage = {
X   0, 0,
X   13, 5, 2,
X   down_selectdata,
X   3,0,
X   NULL,
X};
X
XUSHORT __chip leftimg[] =
X{
X    0x0380, 0x0000,
X    0x0f80, 0x0000,
X    0x3fff, 0xff00,
X    0xffff, 0xff00,
X    0x3fff, 0xff00,
X    0x0f80, 0x0000,
X    0x0380, 0x0000,
X};
X
XUSHORT __chip rightimg[] =
X{
X    0x0001, 0xc000,
X    0x0001, 0xf000,
X    0xffff, 0xfc00,
X    0xffff, 0xff00,
X    0xffff, 0xfc00,
X    0x0001, 0xf000,
X    0x0001, 0xc000,
X};
X
Xstruct Image leftarrow =
X{
X    0, 0,
X    24, 7, 1,
X    leftimg,
X    2, 0,
X    NULL,
X};
X
Xstruct Image rightarrow =
X{
X    0, 0,
X    24, 7, 1,
X    rightimg,
X    2, 0,
X    NULL,
X};
X
Xstruct Image dnleftarrow =
X{
X    0, 0,
X    24, 7, 1,
X    leftimg,
X    1, 0,
X    NULL,
X};
X
Xstruct Image dnrightarrow =
X{
X    0, 0,
X    24, 7, 1,
X    rightimg,
X    1, 0,
X    NULL,
X};
X
Xstruct MsgPort
X    *dosport;
X
XPLANEPTR
X    tmprasp;
X
XGPTR
X    lastgaddown,	/* Last game gadget user selected */
X    globgptr,
X    windowgads,		/* What is currently attached to the window */
X    gamehead,		/* Pointer to active games */
X    gameavail;		/* Pointer to available allocations */
X
Xint
X    wbopen = 0,		/* Is workbench open? */
X    shutdown = 0,	/* Close down workbench during game option */
X    errup = 0,		/* Error message on line */
X    cols = 0,		/* Total columns */
X    vcols = 0,		/* Columns visible */
X    scol = -1,		/* Starting column */
X    height,		/* Height of window */
X    width,		/* Width of window */
X    curcol = 0,		/* Offset to first display column */
X    active_count;	/* Number of games active */
X
Xchar
X    defgname[100] = "WBDefaults";
X
Xflag
X    quit=0;		/* time to cleanup */
X
Xstruct Window *win;	/* the window we create */
END_OF_FILE
if test 5137 -ne `wc -c <'sys/amiga/wbdata.c'`; then
    echo shar: \"'sys/amiga/wbdata.c'\" unpacked with wrong size!
fi
# end of 'sys/amiga/wbdata.c'
fi
if test -f 'sys/amiga/wbdefs.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/amiga/wbdefs.h'\"
else
echo shar: Extracting \"'sys/amiga/wbdefs.h'\" \(5037 characters\)
sed "s/^X//" >'sys/amiga/wbdefs.h' <<'END_OF_FILE'
X/*    SCCS Id: @(#)wbdefs.h     3.1    93/01/08
X/* Copyright (c) Kenneth Lorber, Bethesda, Maryland, 1992, 1993.  */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include <exec/types.h>
X#include <exec/memory.h>
X#include <graphics/gfxmacros.h>
X#include <graphics/gfxbase.h>
X#include <workbench/workbench.h>
X#include <workbench/startup.h>
X#include <intuition/intuition.h>
X#include <intuition/intuitionbase.h>
X
X#ifdef AZTEC_C
X#include <libraries/dosextens.h>
X#include <functions.h>
X#else
X#include <proto/exec.h>
X#include <proto/dos.h>
X#include <proto/intuition.h>
X#include <proto/icon.h>
X#include <proto/graphics.h>
X#endif
X
X#include <stdlib.h>
X#include <stdarg.h>
X#include <string.h>
X#include <ctype.h>
X#include <stdio.h>
X
X#ifdef  IDCMP_CLOSEWINDOW
X#define INTUI_NEW_LOOK  1
X#endif
X
X#define R_DISK		1   /* Refresh reasons */
X#define R_WINDOW	2
X#define R_SCROLL	3
X
X#define PLAYERMENU	0
X
X#define MENU_PROJECT	0   /* so we can shuffle them around easily */
X#define ITEM_HELP	0
X#define ITEM_ABOUT	1
X#define ITEM_SCORES	2
X#define ITEM_RECOVER	3
X/*#define ITEM_EDNEW        4*/
X#define ITEM_EDDEF	4
X#define ITEM_CONFIG	5
X#define ITEM_QUIT	6
X
X#define MENU_GAME	1
X#define ITEM_INFO	0
X#define ITEM_SETCOMMENT	1
X#define ITEM_SETOPT	2
X#define ITEM_COPYOPT	3
X#define ITEM_DISCARD	4
X#define ITEM_RENAME	5
X
X#define GADSCROLL	1   /* The scroll bar */
X#define GADNEWGAME	2   /* New Game requested */
X
X#define GADSCRLUP	3   /* Scroll Up Gadget */
X#define GADSCRLDOWN	4   /* Scroll Down Gadget */
X#define GADINFOSCRL	5   /* The scroll bar */
X
X#define GADQUESTYES	6
X#define GADQUESTNO	7
X
X#define GADCOMSTR	8
X
X#define GADCHARNAME	9
X#define GADOUTFILE	10
X#define GADCATNAME	11
X#define GADDOGNAME	12
X#define GADDEFLOAD	13
X#define GADDEFSAVE	14
X
X#define GADSTRSAVE	15
X#define GADSTRLEVELS	16
X#define GADSTRPATH	17
X#define GADSTRPENS	18
X#define GADSTRHACKDIR	19
X#define GADEDOPTIONS	20
X#define GADCONFSAVE	21
X#define GADCONFLOAD	22
X#define GADCONFNAME	23
X#define GADTOOLUP	24
X#define GADTOOLDOWN	25
X#define GADADDTOOL	26
X#define GADDELTOOL	27
X#define GADTOOLTYPES	28
X#define GADSTRCANCEL	29
X#define GADHELPOKAY	30
X#define GADHELPFRWD	31
X#define GADHELPBKWD	32
X#define GADEDDEF	33
X
X#define GADRESTDIR	34
X#define GADRESTOLD	35
X#define GADRESTNEW	36
X#define GADRESTCAN	37
X#define GADRESTOKAY	38
X
X/*
X *  Option gadgets GadgetID's
X */
X#define GADOCOLOR	101
X#define GADOCONFIRM	102
X#define GADODISCLOSE	103
X#define GADOFIXINV	104
X#define GADONULL	105
X#define GADOTIME	106
X#define GADONEWS	107
X#define GADOHELP	108
X#define GADOFLUSH	109
X#define GADORESTONSPACE	110
X#define GADOPICKUP	111
X#define GADOSOUND	112
X#define GADONUMBERPAD	113
X#define GADOSAFEPET	114
X#define GADOSILENT	115
X#define GADOTOMBSTONE	116
X#define GADOVERBOSE	117
X#define GADOSTANDOUT	118
X#define GADOSORTPACK	119
X#define GADOFEMALE	120
X#define GADOIGNINTR	121
X#define GADOPACKORDER	122
X#define GADODOGNAME	123
X#define GADOCATNAME	124
X#define GADOFRUIT	125
X#define GADOOBJECTS	126
X#define GADOASKSAVE	127
X#define GADOCANCEL	128
X#define GADOOKAY	129
X#define GADOCHKPOINT	130
X#define GADOHILITEPET	131
X#define GADOLEGACY	132
X#define GADOLITCORRIDOR	133
X#define GADOSHOWEXP	134
X#define GADOSHOWSCORE	135
X
X/* Definition of workbench size layout */
X
X#define ORIGINX ( win->BorderLeft + 5 )
X#define ORIGINY ( win->BorderTop + Message.Height + 5 )
X#define CORNERX ( win->Width - win->BorderRight )
X#define CORNERY ( win->Height - win->BorderBottom )
X
X/* String buffer in String Gadget */
X
X#define Sbuff(gd)	(((struct StringInfo*)((gd)->SpecialInfo))->Buffer)
X
X/* The string gadgets' buffers */
X
X#define StrPath		(Sbuff(&Conf_StrPath))
X#define StrOptions	(Sbuff(&Conf_StrOptions))
X#define StrHackdir	(Sbuff(&Conf_StrHackdir))
X#define StrPens		(Sbuff(&Conf_StrPens))
X#define StrLevels	(Sbuff(&Conf_StrLevels))
X#define StrSave		(Sbuff(&Conf_StrSave))
X#define NetHackCnf	(Sbuff(&Conf_ConfigName))
X
X#define RstDir		(Sbuff(&Rst_RestDir))
X#define RstOld		(Sbuff(&Rst_RestOld))
X#define RstNew		(Sbuff(&Rst_RestNew))
X
X#define DefPlayerName	(Sbuff(&Defs_PlayerName))
X#define DefOutFile	(Sbuff(&Defs_DefaultName))
X
X#define StrString	(Sbuff(&Str_String))
X
X#define StrTools	(Sbuff(&Info_ToolTypes))
X
X#define GAMEIMAGE	"HackExe:NetHack"
X#define GAMESTACK	50000
X
X#define PATH_IDX	0
X#define OPTIONS_IDX	1
X#define HACKDIR_IDX	2
X#define LEVELS_IDX	3
X#define SAVE_IDX	4
X#define PENS_IDX	5
X
X#define NUMIDX		6
X
X#define PL_RANDOM	0
X#define PL_ARCHEOLOGIST	1
X#define PL_BARBARIAN	2
X#define PL_CAVEMAN	3
X#define PL_ELF		4
X#define PL_HEALER	5
X#define PL_KNIGHT	6
X#define PL_PRIEST	7
X#define PL_ROGUE	8
X#define PL_SAMURAI	9
X#define PL_TOURIST	10
X#define PL_VALKYRIE	11
X#define PL_WIZARD	12
X
X#define MENUITEMNO( menu, itm, sitm ) FULLMENUNUM( menu, itm, sitm )
X#define GADWIDTH( gad )     max((gad)->Width, \
X		    strlen((gad)->GadgetText->IText) * win->RPort->TxWidth)
X
X/* Horizontal space between gadgets */
X#define GADINCX		10
X
X/* Vertical space between gadgets */
X#define GADINCY		(win->RPort->TxHeight + 1)
X
X#define NO_FLASH	0
X#define FLASH		1
X
X#define GAME_FROM_DEFAULT   0
X#define GAME_FROM_INFO      1
END_OF_FILE
if test 5037 -ne `wc -c <'sys/amiga/wbdefs.h'`; then
    echo shar: \"'sys/amiga/wbdefs.h'\" unpacked with wrong size!
fi
# end of 'sys/amiga/wbdefs.h'
fi
if test -f 'sys/mac/NHrez.hqx' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/mac/NHrez.hqx'\"
else
echo shar: Extracting \"'sys/mac/NHrez.hqx'\" \(4948 characters\)
sed "s/^X//" >'sys/mac/NHrez.hqx' <<'END_OF_FILE'
X(This file must be converted with BinHex 4.0)
X:#8jPG%KKBfXZFJ"849K869"6)!%!!!!-8`!!!Dc!(%P13da94%8J)NjPG%KKBfX
XZFR0bBb)l#3N*,bSJ689195`J68*"8L`J38a59#`J9dP14#`J5801)b`JCA4M)#S
X[$8P13da94%8J)P0[G@jNFbjbFh*M)MX*#3N[+L"*ER0dFR9YC@jdFb"KFb"cEQ3
XJFQ9cEh9bBf9c)#S[$3dMD@jME(9NC5!L9(P`CA-ZFL)0)fPZBfaeC'8J)P0jFe4
XjF'9c,R)L$50TEQ0XG@4P)#*#B@aXEfpZ9(P`CA-ZFL)*)#!J)#mU)%eKBb"bCA0
X[GA*MC5"dHA"P)'4PCQPZDA4TEfjc)#S[$3ebC@&N)#G849K8*b!S-6!`-#`L5'9
XXF#)T)!NJ*#46D'9XE#JL4'&d)LNJ)NKPE(!L1`ebC@&N)#G849K8*b!S-6!`-5`
XL9fPk5'9XF#)T)#3N8fKPE'`S)N4KG#)T)#*ADAT)C@a`)MX0FQ9KC#!R9%9B9#F
XJ+$%`-$)X)Np`G%KPE(!L+5!N*&0SC@aX+#*%BA3L+5!L6h"d5'9XF#)l$5mU$A*
XPB@3J*e4&@&3R)#Ja-$!c,#*$E@4)C@a`)LNJ*#46D'9XE#JL4'&d)LNJ)N0YC%K
XPE(!L1`dU,`ebC@&N)#G849K8*b!S-6!`0#`L6@&M5'9XF#)T)#3N8fKPE'`S)Ne
XKBd4TFL)T)#*0B@0)C@a`)MX0$A*PB@3J*e4&@&3R)#Ja-$!e,#*)5#)T)!NJ*#4
X6D'9XE#JL4'&d)LNJ)NK))MX0FQ9KC#!R9%9B9#FJ+$%`-$BX)NKTFh4[FRNL+5!
XN*&0SC@aX+#*%BA3L+5!L5'PcG'pbH5)l$A*PB@3J*e4&@&3R)#Ja-$!h,#*-D@0
XPER0P)LNJ*#46D'9XE#JL4'&d)LNJ)NaTBf9ZFf8L1`d0FQ9KC#!R9%9B9#FJ+$%
X`-$JX)NjPGh-L+3NJ*#46D'9XE#JL6@&M4'Pb)LNJ)NjPGh-L1`ebC@&N)#G849K
X8*b!S-6!`15`L6h"dD@pZFb)T)#3N8fKPE'`S)NpLDN4TFL)T)#*2F(4TEfjc)MX
X0$5mU$A*PB@3J*e4&@&3R)#Ja-$%`,#*5G@e[FR-L+5!J*#46D'9XE#JL6f*U4'P
Xb)LNJ)P*eE@pbFb)l$A*PB@3J*e4&@&3R)#Ja-$%a,#*%BA4K)LNJ)#!J*#46D'9
XXE#JL6f*U4'Pb)LNJ)N4KG'%L1`dU,`d0)f4PCQPZC5"V8fPREQ&dGA*P)#GZD$-
Xa*`N*,bSJ3A"`E'PMBA4TEfiJFfPREQ&dGA*P,#"bC@GTFh4PFQ9N)(GTG'JJ4&4
X6)#S[$3dMC'9QD@jP)'Y@CA*cD@pZ)#)c,M'R-5)*#5mU)%0SB@jRC5"SCA*P)'&
XZC#"LC@a[Gb!U,`d0FQ9cEh9bBf8J*hCPFR-R)#Ja+5"l$3N`H$!c,#!`H$!a,#"
XLCA4K,#!`H$!a,#"fCA*98b`*,bSJ9Q9bFfP[ELpcG@*fCA*cD@pZ,hYKE("SBAa
XLCA4KI(*PE'9KFf9p,f0[G@jdFRNJ+Lm0#@Y@CA*cD@pZ,!d*DeCPFR0TEfiJ)L#
XT)$%j1$8X)$%j1$BX)$%j1$FX)$%j1$JX)$%j1$NX)$%j16!X)$%j16%X)$%j16)
XJBRNJ8h4TBfKdD@jR)%eKG'KPE@&dDA0MD#"$C@jdFR9Y)'&ZC#"0,L"6G'9`D'9
XZFfpZ,L)0I6X0$A4jF'8JDe0TCfjKG(9bC5"KFb!R8e45)#Fl$A*PFfpeFQ0P)'Y
X6D@GZBA4eFQ8J+$!XF(9bCf9KBQaP+5!0)#"l)#*1CA4)B@0V)(BL)'Y@CA*cD@p
XZ)#)J)L"p1`d0FQ9cEh9bBf8J*dC548BR)#Ja-MJXF(9bCf9KBQaP+5!0Hb!R39"
X36#FX)$!X)#)L)(dl$3ebCA0[GA*MC5!R4P*&4LFJ+$%b15a`GA*RC@&LE'8T)!e
Xl)#G639C&*b`J-5`J)L)JI6X0$A*PFfpeFQ0P)#G'8N9'*b!S-6-`,("eFQGPB@*
XXC5NJ$AXJ*e"548BR,#!b,#!L)L"p1`d0FQ9cEh9bBf8J*d*14%`R)#Ja-MJXF(9
XbCf9KBQaP+5!0Hb!J)'Y6D@GZBA4eFQ8X$3N`,!d*Hb!R5801)bFX$3N*Hb!`,#!
Xa-$!`,!d*#5!J-5`J-6!`-5`0#3NJ)$)X)$%`-$)0#3Pp,!d*#3d*#5G'8N9'*b`
X0#3Pl)$!X)$%b1#`0#3NJ)$%X)$%b15`0#3NJ)$)X)$%c-!d*#Ad0#Ad0I6X0$A*
XPFfpeFQ0P)#G659T&*b!S,6%T)(X0#A*PFf9bGQ9N,!d*B@0MCA"d8h9cF'9ZC&*
XPFh9YC89fC@jdFb`0#A*PFf9bGQ9N,!d*Bf&Z3Q&MDfGbEh9ZC#`0#@4[CA0"Bh4
XTGQ&dC8pZ4NG6GfPdBfJX$3PLB@0VCh*[G@jN3@jN4QpbC@GbEh9ZC#`0#@4[ER4
X(CA4'FQpZG%0XD@0VFb`0#@PREQpbC8&`F%4TC@4&GQ9ZG(-X$3PTFc-b3QPd3fp
XYF'&dD@*XC5`0#@j[G%KTCfK-CACPE%9fC@jd3AGKFQ8X$3P[EQaj6'pMB@a)6%9
XfC@jdFb`0#@j[G&0dBA4TEfjPFRP"Gf&bC5`0#@4[ER49Ff98CAKd4@4TG&0PFRC
XTBf9c,!d*FQ9cCA*fC@3X$3PbCA0PFRCPC#`0#A*PFf9bGQ9N,!d*-6J`-#!U)$%
X`-M3X#3N[+L"bC@0[E@ePEQ4PC#!U,`d*-6-`-#!U)$%`-M3*#3N[+L"KBR0[E(9
XdC5"YD@jTEA9Y,#"dEb"LC5"NCA4PFQeTEQ9N)#S[$Adl$3d[+L"6HA0dC@dJ0b"
XSC@a`)'*KE'a[EfiJD@jQEh*YBA4TEfiJ+Lm0FQ9cEh9bBf8J*fKQC()R)#JY06B
Xj0L`JF(9bCf9KBQaP+5"l)!dJ)#!J)%KPE("0Ch*@CA*cD@pZ,#"SE84PCQ&eE(4
X2F(4TEfjc,#!`,#!`,#![+L"SC@&NCA)JD@jQEh*YBA4TEfiJ+LmJ$3NJ)#!JHb"
X)69088P*PFdPdC@dJHb![+L"eFf8J*e088L!R)(*PFfpeFQ0P)$)`-$!J+LmJ-M!
X`-#"p)!d*I5!0I6X0$A*PFfpeFQ0P)#G69&)J*b!S-M!`-#`JF(9bCf9KBQaP+5"
Xl)#mU)%KPE(!JE@9cFf&RC5"QEh)JBA"`)'PMEfiJ+Lm0)#!J)NjPG%KKBfXJGL)
XJDeCPFR0TEfiJ)PaZ9'KTFb"TFb"dD'8JCQ&YEh9c)%4eEQGPEfjc)'&ZC#"%FQ&
XREfjcULeXD@YP)'GKE@8JF'pbG'9N)(4[)(4SC5"0B@0TER4[FfJZ)L!0I6X0$A*
XPFfpeFQ0P)#G69&)J*bJY-6Bc16BX)("eFQGPB@*XC5NJH`N[+L"AD@aX)'*P)'0
X[F'PPC#"dEb"dD'8JFf&fC@3JCQPXC5iJ+Lm0#5*1CA4)B@0V)JN*#3N*#3N[+L"
X6C@8J5@jcD@4P)%eKBb"@55`JF'&RC5!j,6)a,JNJ+Lm0I6X0$3d[+L"0B@-JCA*
XbEh)JC'9MEf4PFb!k)$)`-$!J,5"PFR)M)'C[FL"MEfeYEfiJCA*bEh*c,L""C'3
XJH@peFL"QBAC[FQPdCA-JBQ9XEhFJ+Lm0$A*PFfpeFQ0P)#G69&)J*b!S-M!c0#N
XJHb!LG'KP)'4TFfXJDA-JCR9XE#)J)(dl$A*PFfpeFQ0P)#G69&)J*b!S-M!c0LN
XJHb!LG'KPFQ8JGf&c)'&Z)%N[6b"PFR*[FL)J)(dl$A*PFfpeFQ0P)#G69&)J*b!
XS-M!d-bNJHb!LB5"QD@aP)'Pc)'eTFh0TEQFL)#"p1`ebCA0[GA*MC5!R8e45)#F
XJ+$)`0$3T)(XJ)R4SC5"NDA0V)'Pc)(GbDA4P,A"bEh4PBh4PC#)J)(dl$A*PFfp
XeFQ0P)#G69&)J*b!S-M!d0bNJHb!LG'KP)'CTE'8JDA-JBR9cH5)J)(dl$A*PFfp
XeFQ0P)#G69&)J*b!S-M!d15NJHb!LG'KP)'CTE'8JDA-JB@abC@&NH5"[F'9Z)L!
XJI6X0FQ9cEh9bBf8J*e088L!R)#Jb-6!i+5"l)#*dD'9bC5"TFb"ZEh3JC@j[G@G
XS)'ePE@pbH5)J)(dl$A*PFfpeFQ0P)#G69&)J*b!S-M%j-LNJHb!LB5"bCA0[GA*
XMC5"TFb"YDA0cD@jR)L!JI6X0i9B!!!%!!!!"EJ!!!'i!!!!q6Pj1GBKRCA4dFQ&
XMD`!!!!3!!!d!"`CeG(*KBfX!"3%*6Q9d5'&MDbjb!J!!!&4&@&408&-J!3!!!!I
XX!!!!!!!!9%9B9%e38b!"!!!!"q`!!!!!!!!!!!!!!!!!!!!!!!#RL'6$!!!-8`!
X!!Da*6NF*-MBe$50NC@CTEQ8*8d05Ad&06N9658%*-MBf$50NC@CTEQ8*8d05AdC
X*8N8*-MBh$50NC@CTEQ8*8d05Ae"96NP65%e&6P3*-MBi$50NC@CTEQ8*8d05Ad0
X)39*(58j(#6)f13dMC'9QD@jP#90$8Pp#6%&15ep339"&8JNb!!!!5!!*6@pZB@0
X[!!"[G#"PH'9MGA4P)'%JC'PbC@0dEh*j,#!!"J!%!$`!*!'0!Md!2!!N!Bd#2DH
X*M3X!!!+L!!!$%3!!!M-"!!!!!"i!2!!N!Bd#23!m!#3"M3)p!!!#-`!!!!!!!!!
X!!!!!!!%!!!!"EJ!!!'i!!!!q!(ppb"-D!!!!(!!q!!"08&05!!%!#J2Yrrm!!!!
X!!!!!!!2`rrm!!!"-!)&j-)9G:
END_OF_FILE
if test 4948 -ne `wc -c <'sys/mac/NHrez.hqx'`; then
    echo shar: \"'sys/mac/NHrez.hqx'\" unpacked with wrong size!
fi
# end of 'sys/mac/NHrez.hqx'
fi
if test -f 'sys/msdos/exesmurf.doc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/msdos/exesmurf.doc'\"
else
echo shar: Extracting \"'sys/msdos/exesmurf.doc'\" \(5020 characters\)
sed "s/^X//" >'sys/msdos/exesmurf.doc' <<'END_OF_FILE'
X	SCCS Id: @(#)exesmurf.doc	 3.1		91/01/29
X        Copyright (c) Pierre Martineau and Stephen Spackman 1991, 1992, 1993.
X        NetHack may be freely redistributed.  See license for details.
X		     ============================
X		     PC NetHack Support Utilities
X		     ============================
X		     Last revision: 1991January29
X
XThis file contains documentation for the NetHack MS-DOS support
Xutility EXESMURF.EXE.  This utility examines and modifies the load
Xparameters of an .EXE file and can be used to split .OVL files off a
Xmonolithic overlaid executable using ovlmgr.
X
XEXESMURF
X--------
Xexesmurf FILENAME[.EXT] /v
Xexesmurf FILENAME[.EXT] /minN
Xexesmurf FILENAME[.EXT] /maxN
Xexesmurf FILENAME[.EXT] /l
Xexesmurf FILENAME[.EXT] N... [/pPATTERN]
X
XThe programme exesmurf is basically a reimplementation of Microsoft's
XEXEMOD utility.  However, this incarnation is one that is
X"overlay-aware" (as they say).  It will provide the user with
Xinformation about the executable and its overlays, and allow you to
Xmodify the executable's parameters and overlay locations.
X
XThis program is made available for all users who were not graced with a
Xrelease of EXEMOD in their Microsoft product, or who need the
Xadditional functionality it provides.
X
X/v.
XIf exesmurf is invoked with a filename as argument, optionally
Xfollowed by a /v, the filename's exeheader is listed for your viewing
Xpleasure, along with the headers of any Microsoft-format overlays the
Xfile may contain.  The listing is verbose; if there are many overlays
Xyou will want to redirect the output.  Note that the redundancy in the
Xoutput listing largely reflects redundancy in the file structure.
X
X/minN, /maxN, /stackN.
XExesmurf may also be used to modify the "minalloc", "maxalloc" and
X"stack" allocation parameters of the executable file.  This can be
Xaccomplished with the /min, /max, and /stack flags respectively.  Any
Xarguments to these flags should be *immediately* followed by a decimal
Xnumber N.  Note that this is inconsistent with the arguments to EXEMOD
Xwhich takes hex numbers, and *needs* a space between the flag and the
Xnumber.
X
X/l.
XThe /l option requests a version of the /v listing (see above) in
Xwhich the information about overlays is very much compressed; only
Xtheir decimal file and load sizes are given, in a multi-column format.
XThe resulting display will generally fit on a single screen.  This
Xturns out to be very useful when contemplating appropriate parameters
Xfor the overlay splitting operation described next.
X
XN... [/pPATTERN].
XThe overlay-unpacking function of exesmurf is invoked by following the
Xfilename argument by a sequence of decimal numbers.  Each of these
Xnumbers is an overlay number at which a new external overlay file is
Xto be started.  The main executable file will keep its old name after
Xthe overlays have been unloaded; the original input file will be
Xretained, with its extension changed to .BAK.  By default, the output
Xfiles will be derived from the input file name by appending a
Xdiscriminating character (in sequence, 0, 1, ..., 9, a, b, ..., z) to
Xthe basename and changing the extension to .OVL; but if the basename
Xis a full 8 characters long, the discriminating character will replace
Xthe last character instead.  This default is chosen for compatibility
Xwith ovlmgr.  The default may be overridden with the /p option, which
Xspecifies a file PATTERN - a file name, possibly complete with
Xextension, containing one or more ? characters (* is not allowed),
Xwhich will be replaced by discriminating characters.  If there is
Xexactly one questionmark, it will be replaced by a digit or letter in
Xthe sequence described above, but if more than one questionmark
Xappears a decimal numbering scheme is used instead.
X	Note that the numeric arguments are overlay numbers, not
Xindices, and they indicate the starting overlays of files.  This
Xpermits us to manipulate files in which (for some reason) the overlays
Xare not stored in ascending order, but it does mean that if a
Xmentioned overlay does not exist in the original file, no new overlay
Xfile will be started.  This is a realistic risk, since the Microsoft
Xlinker does not seem to generate overlays at all if there is no actual
Xcode generated into the segments in question.
X	Note further that this operation can be reversed with the DOS
Xcopy/b operation, always supposing that it works as documented in your
Xrelease of the operating system: the overlays are simply moved
Xpage-by-page to the external files.
X	No guarantees are made as to how this programme will behave if
Xthere is debug information or other strangeness stored after the last
Xoverlay in the file.
X
XWhenever exesmurf is invoked, the extension .EXE is assumed for the
Xfile if no extension is given.  Other extensions are probably only
Xmeaningful for examining overlay files.
X----------------------------------------------------------------------
XStephen P Spackman                       stephen@estragon.uchicago.edu
X----------------------------------------------------------------------
END_OF_FILE
if test 5020 -ne `wc -c <'sys/msdos/exesmurf.doc'`; then
    echo shar: \"'sys/msdos/exesmurf.doc'\" unpacked with wrong size!
fi
# end of 'sys/msdos/exesmurf.doc'
fi
if test -f 'win/X11/Window.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'win/X11/Window.c'\"
else
echo shar: Extracting \"'win/X11/Window.c'\" \(5183 characters\)
sed "s/^X//" >'win/X11/Window.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)Window.c	3.1	92/3/7
X/* Copyright (c) Dean Luick, 1992				  */
X/* NetHack may be freely redistributed.  See license for details. */
X
X/*
X * Data structures and support routines for the Window widget.  This is a
X * drawing canvas with 16 colors and one font.
X */
X#include <X11/IntrinsicP.h>
X#include <X11/StringDefs.h>
X#include "WindowP.h"
X
Xstatic XtResource resources[] = {
X#define offset(field) XtOffset(WindowWidget, window.field)
X    /* {name, class, type, size, offset, default_type, default_addr}, */
X    { XtNrows, XtCRows, XtRDimension, sizeof(Dimension),
X	  offset(rows), XtRImmediate, (XtPointer) 21},
X    { XtNcolumns, XtCColumns, XtRDimension, sizeof(Dimension),
X	  offset(columns), XtRImmediate, (XtPointer) 80},
X    { XtNforeground, XtCForeground, XtRPixel, sizeof(Pixel),
X	  offset(foreground), XtRString, XtDefaultForeground },
X
X    { XtNblack, XtCColor, XtRPixel, sizeof(Pixel),
X	  offset(black), XtRString, "black"},
X    { XtNred, XtCColor, XtRPixel, sizeof(Pixel),
X	  offset(red), XtRString, "red" },
X    { XtNgreen, XtCColor, XtRPixel, sizeof(Pixel),
X	  offset(green), XtRString, "pale green" },
X    { XtNbrown, XtCColor, XtRPixel, sizeof(Pixel),
X	  offset(brown), XtRString, "brown" },
X    { XtNblue, XtCColor, XtRPixel, sizeof(Pixel),
X	  offset(blue), XtRString, "blue" },
X    { XtNmagenta, XtCColor, XtRPixel, sizeof(Pixel),
X	  offset(magenta), XtRString, "magenta" },
X    { XtNcyan, XtCColor, XtRPixel, sizeof(Pixel),
X	  offset(cyan), XtRString, "light cyan" },
X    { XtNgray, XtCColor, XtRPixel, sizeof(Pixel),
X	  offset(gray), XtRString, "gray" },
X    { XtNorange, XtCColor, XtRPixel, sizeof(Pixel),
X	  offset(orange), XtRString, "orange" },
X    { XtNbright_green, XtCColor, XtRPixel, sizeof(Pixel),
X	  offset(bright_green), XtRString, "green" },
X    { XtNyellow, XtCColor, XtRPixel, sizeof(Pixel),
X	  offset(yellow), XtRString, "yellow" },
X    { XtNbright_blue, XtCColor, XtRPixel, sizeof(Pixel),
X	  offset(bright_blue), XtRString, "royal blue" },
X    { XtNbright_magenta, XtCColor, XtRPixel, sizeof(Pixel),
X	  offset(bright_magenta), XtRString, "violet" },
X    { XtNbright_cyan, XtCColor, XtRPixel, sizeof(Pixel),
X	  offset(bright_cyan), XtRString, "cyan" },
X    { XtNwhite, XtCColor, XtRPixel, sizeof(Pixel),
X	  offset(white), XtRString, "white" },
X
X    { XtNfont, XtCFont, XtRFontStruct, sizeof(XFontStruct *),
X	  offset(font), XtRString, XtDefaultFont },
X    { XtNexposeCallback, XtCCallback, XtRCallback, sizeof(XtCallbackList),
X	  offset(expose_callback), XtRCallback, NULL },
X    { XtNcallback, XtCCallback, XtRCallback, sizeof(XtCallbackList),
X	  offset(input_callback), XtRCallback, NULL },
X    { XtNresizeCallback, XtCCallback, XtRCallback, sizeof(XtCallbackList),
X	  offset(resize_callback), XtRCallback, NULL },
X#undef offset
X};
X
X/* ARGSUSED */
Xstatic void InputAction(w, event, params, num_params)
X    Widget   w;
X    XEvent   *event;
X    String   *params;		/* unused */
X    Cardinal *num_params;	/* unused */
X{
X    XtCallCallbacks(w, XtNcallback, (caddr_t) event);
X}
X
X/* ARGSUSED */
Xstatic void no_op(w, event, params, num_params)
X    Widget   w;			/* unused */
X    XEvent   *event;		/* unused */
X    String   *params;		/* unused */
X    Cardinal *num_params;	/* unused */
X{
X}
X
Xstatic XtActionsRec actions[] =
X{
X    {"input",	InputAction},
X    {"no-op",	no_op},
X};
X
Xstatic char translations[] =
X"<Key>:		input()	\n\
X <BtnDown>:	input() \
X";
X
X/* ARGSUSED */
Xstatic void Redisplay(w, event, region)
X    Widget w;
X    XEvent *event;	/* unused */
X    Region *region;
X{
X    XtCallCallbacks(w, XtNexposeCallback, (caddr_t) region);
X}
X
X/* ARGSUSED */
Xstatic void Resize(w)
X    Widget w;
X{
X    XtCallCallbacks(w, XtNresizeCallback, (caddr_t) NULL);
X}
X
X
XWindowClassRec windowClassRec = {
X  { /* core fields */
X    /* superclass		*/	(WidgetClass) &widgetClassRec,
X    /* class_name		*/	"Window",
X    /* widget_size		*/	sizeof(WindowRec),
X    /* class_initialize		*/	NULL,
X    /* class_part_initialize	*/	NULL,
X    /* class_inited		*/	FALSE,
X    /* initialize		*/	NULL,
X    /* initialize_hook		*/	NULL,
X    /* realize			*/	XtInheritRealize,
X    /* actions			*/	actions,
X    /* num_actions		*/	XtNumber(actions),
X    /* resources		*/	resources,
X    /* num_resources		*/	XtNumber(resources),
X    /* xrm_class		*/	NULLQUARK,
X    /* compress_motion		*/	TRUE,
X    /* compress_exposure	*/	TRUE,
X    /* compress_enterleave	*/	TRUE,
X    /* visible_interest		*/	FALSE,
X    /* destroy			*/	NULL,
X    /* resize			*/	Resize,
X    /* expose			*/	Redisplay,
X    /* set_values		*/	NULL,
X    /* set_values_hook		*/	NULL,
X    /* set_values_almost	*/	XtInheritSetValuesAlmost,
X    /* get_values_hook		*/	NULL,
X    /* accept_focus		*/	NULL,
X    /* version			*/	XtVersion,
X    /* callback_private		*/	NULL,
X    /* tm_table			*/	translations,
X    /* query_geometry		*/	XtInheritQueryGeometry,
X    /* display_accelerator	*/	XtInheritDisplayAccelerator,
X    /* extension		*/	NULL
X  },
X  { /* window fields */
X    /* empty			*/	0
X  }
X};
X
XWidgetClass windowWidgetClass = (WidgetClass)&windowClassRec;
X
XFont
XWindowFont(w) Widget w; { return ((WindowWidget)w)->window.font->fid; }
X
XXFontStruct *
XWindowFontStruct(w) Widget w; { return ((WindowWidget)w)->window.font; }
END_OF_FILE
if test 5183 -ne `wc -c <'win/X11/Window.c'`; then
    echo shar: \"'win/X11/Window.c'\" unpacked with wrong size!
fi
# end of 'win/X11/Window.c'
fi
echo shar: End of archive 102 \(of 108\).
cp /dev/null ark102isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \
21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \
41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 \
61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 \
81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 \
101 102 103 104 105 106 107 108 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 108 archives.
    echo "Now execute 'rebuild.sh'"
    rm -f ark10[0-8]isdone ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
