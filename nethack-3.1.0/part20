Path: uunet!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v16i020:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Part20/108
Message-ID: <4308@master.CNA.TEK.COM>
Date: 29 Jan 93 20:43:51 GMT
Sender: news@master.CNA.TEK.COM
Lines: 2308
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1577

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 16, Issue 20
Archive-name: nethack31/Part20
Supersedes: nethack3p9: Volume 10, Issue 46-102
Environment: Amiga, Atari, Mac, MS-DOS, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 20 (of 108)."
# Contents:  dat/Valkyrie.des sys/amiga/winami.c1
# Wrapped by billr@saab on Wed Jan 27 16:08:53 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'dat/Valkyrie.des' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dat/Valkyrie.des'\"
else
echo shar: Extracting \"'dat/Valkyrie.des'\" \(10123 characters\)
sed "s/^X//" >'dat/Valkyrie.des' <<'END_OF_FILE'
X#	SCCS Id: @(#)Valkyrie.des	3.1	91/09/30
X#	Copyright (c) 1989 by Jean-Christophe Collet
X#	Copyright (c) 1991-2 by M. Stephenson
X# NetHack may be freely redistributed.  See license for details.
X#
X#	The "start" level for the quest.
X#
X#	Here you meet your (besieged) class leader, the Norn,
X#	and receive your quest assignment.
X#
XMAZE: "V-start",' '
XFLAGS: noteleport,hardfloor
XGEOMETRY:center,center
XMAP
XIIIIIIPPPIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
XIIIIPPPPPIIIIIIII..IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...IIIIIIIIIIIIIIIIIIIII
XIIIIPLLPPIIIIIII..IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII..{..IIIIIIIIIIIIIIIIIIII
XIIIIPLPPIIIIIII..IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII.....IIIIIIPPPIIIIIIIIII
XIIIPPPPPIIIIII..IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII.IIIIIPPLPIIIIIIIIII
XIIIIPIIIIIIII..IIIIPPPIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII.IIIIIPLPPIIIIIIIIII
XIIIIIIIIIIII..IIIIIPLPPIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII..IIIIIPPPIIIIIIIIIII
XIIIIIIII.....IIIIIIPPPIIII|----------------|IIIIIPPPIII.IIIIIIIIIIIIIIIIIIII
XIIIIIII..III...IIIIIIIIIII|................|IIIIIPLPII..IIIIIIIIIIIIIIIIIIII
XIIIIII..IIIIII......IIIII.|................|.IIIIPPPII.IIIIIIIIIIIIIIIIIIIII
XIIIII..IIIIIIIIIIII.......+................+...IIIIIII.IIIIIIIIIIIIIIIIIIIII
XIIII..IIIIIIIII.....IIIII.|................|.I...IIIII.IIIIIIIIIIIIIIIIIIIII
XIII..IIIIIIIII..IIIIIIIIII|................|IIII.......IIIIIIIIIIIIIIIIIIIII
XIIII..IIIIIII..IIIIIIIIIII|----------------|IIIIIIIIII...IIIIIIIIIIIIIIIIIII
XIIIIII..IIII..IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIPPPPIIII...IIIIIIIIIIIIIIIII
XIIIIIII......IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIPLLPPIIIII...IIIIIIIIIIIIIII
XIIIIPPPIP...IIIIIIIIIIIPIIIIIIIIIIIIIIIIIIIIIIIIPPPPIIIIIIII...I......IIIIII
XIIIPPLPPIIIIIIIIIIIIIIPPPIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII.........IIIII
XIIIIPPPIIIIIIIIIIIIIIPPLPIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII.......IIIIII
XIIIIIIIIIIIIIIIIIIIIIIPPPIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
XENDMAP
X# Random Monsters
XRANDOM_MONSTERS: 'a', 'H'
X# Dungeon Description
XREGION:(00,00,75,19),lit,"ordinary"
XREGION:(27,08,42,12),lit,"ordinary"
X# Portal arrival point
XBRANCH:(66,17,66,17),(0,0,0,0)
X# Stairs
XSTAIR:(18,01),down
X# Doors
XDOOR:locked,(26,10)
XDOOR:locked,(43,10)
X# Norn
XMONSTER:'@',"Norn",(35,10)
X# The treasure of the Norn
XOBJECT:'(',"chest",(36,10)
X# valkyrie guards for the audience chamber
XMONSTER:'@',"warrior",(27,08)
XMONSTER:'@',"warrior",(27,09)
XMONSTER:'@',"warrior",(27,11)
XMONSTER:'@',"warrior",(27,12)
XMONSTER:'@',"warrior",(42,08)
XMONSTER:'@',"warrior",(42,09)
XMONSTER:'@',"warrior",(42,11)
XMONSTER:'@',"warrior",(42,12)
X# Non diggable walls
XNON_DIGGABLE:(26,07,43,13)
X# Random traps
XTRAP:"fire",random
XTRAP:"fire",random
XTRAP:"fire",random
XTRAP:"fire",random
XTRAP:"fire",random
XTRAP:"fire",random
X# Monsters on siege duty.
XMONSTER: 'a',"fire ant",(04,12)
XMONSTER: 'a',"fire ant",(08,08)
XMONSTER: 'a',"fire ant",(14,04)
XMONSTER: 'a',"fire ant",(17,11)
XMONSTER: 'a',"fire ant",(24,10)
XMONSTER: 'a',"fire ant",(45,10)
XMONSTER: 'a',"fire ant",(54,02)
XMONSTER: 'a',"fire ant",(55,07)
XMONSTER: 'a',"fire ant",(58,14)
XMONSTER: 'a',"fire ant",(63,17)
XMONSTER: 'H',"fire giant",(18,01),hostile
XMONSTER: 'H',"fire giant",(10,16),hostile
X 
X#
X#	The "locate" level for the quest.
X#
X#	Here you have to find the cave of Surtur to go
X#	further towards your assigned quest.
X#
X
XMAZE: "V-locate",' '
XFLAGS: hardfloor
XINIT_MAP: '.' , 'I' , true , true , lit , false
XGEOMETRY:center,center
XMAP
XPPPP....                      ....PPPPP.
XPLP...                          .PPLLLPP
XPPP    .......................    PPPLLP
X..   ............................   PPPP
X.  ...............................  ....
X  .................................   ..
X....................................   .
X  ...................................   
X.  ..................................  .
X..   ..............................   PP
X.PPP  ..........................     PLP
X.PLLP                             ..PLLP
X.PPPP..                         ....PPPP
XENDMAP
X# Random Monsters
XRANDOM_MONSTERS: 'a', 'H'
X# Dungeon Description
XREGION:(00,00,39,12),lit,"ordinary"
X# Stairs
XSTAIR:(48,14),up
XSTAIR:(20,06),down
X# Non diggable walls
XNON_DIGGABLE:(00,00,39,12)
X# Objects
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
X# Random traps
XTRAP:"fire",random
XTRAP:"fire",random
XTRAP:"fire",random
XTRAP:"fire",random
XTRAP:random,random
XTRAP:random,random
X# Random monsters.
XMONSTER:'a',"fire ant",random
XMONSTER:'a',"fire ant",random
XMONSTER:'a',"fire ant",random
XMONSTER:'a',"fire ant",random
XMONSTER:'a',"fire ant",random
XMONSTER:'a',"fire ant",random
XMONSTER:'a',"fire ant",random
XMONSTER:'a',"fire ant",random
XMONSTER:'a',"fire ant",random
XMONSTER:'a',"fire ant",random
XMONSTER:'a',"fire ant",random
XMONSTER:'a',"fire ant",random
XMONSTER:'a',"fire ant",random
XMONSTER:'a',"fire ant",random
XMONSTER:'a',"fire ant",random
XMONSTER:'a',"fire ant",random
XMONSTER:'a',"fire ant",random
XMONSTER:'a',random,random
XMONSTER:'H',random,random,hostile
XMONSTER:'H',"fire giant",random,hostile
XMONSTER:'H',"fire giant",random,hostile
XMONSTER:'H',"fire giant",random,hostile
XMONSTER:'H',"fire giant",random,hostile
XMONSTER:'H',"fire giant",random,hostile
XMONSTER:'H',"fire giant",random,hostile
XMONSTER:'H',"fire giant",random,hostile
XMONSTER:'H',random,random,hostile
X
X#
X#	The "goal" level for the quest.
X#
X#	Here you meet Lord Surtur your nemesis monster.  You have to
X#	defeat Lord Surtur in combat to gain the artifact you have
X#	been assigned to retrieve.
X#
X
XMAZE: "V-goal", 'L'
XINIT_MAP: '.' , 'L' , true , true , lit , false
XGEOMETRY:center,center
XMAP
X.L............................LLLLL
XLLL.........LLLLL.LLLLL.........LLL
X.LLL......LLLLLLLLLLLLLLL.......LL.
X.LLL.....LLL|---------|LLL.....L...
X..LL....LL|--.........--|LL.....LLL
X.......LL|-...LLLLLLL...-|LL.....L.
X.......LL|...LL.....LL...|LL.......
X......LL|-..LL.......LL..-|LL......
X......LL|.................|LL......
X......LL|-..LL.......LL..-|LL......
X.......LL|...LL.....LL...|LL.......
X.......LL|-...LLLLLLL...-|LL.......
X..L.....LL|--.........--|LL.....LL.
X..LL.....LLL|---------|LLL....LLLL.
X..LLL.....LLLLLLLLLLLLLLL...LLLLL..
X.LLLL.......LLLLL.LLLLL.....LLLL...
X..LL...............................
XENDMAP
X# Random Monsters
XRANDOM_MONSTERS: 'a', 'H'
X# Dungeon Description
XREGION:(00,00,34,16),lit,"ordinary"
X# Stairs
X# Note:  The up stairs are *intentionally* off of the map.
XSTAIR:(45,10),up
X# Non diggable walls
XNON_DIGGABLE:(00,00,34,16)
X# Drawbridges
XDRAWBRIDGE:(17,02),south,open
XDRAWBRIDGE:(17,14),north,open
X# Objects
XOBJECT:'(',"crystal ball",(17,08),blessed,0,"The Orb of Fate"
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
X# Random traps
XTRAP:"fire",random
XTRAP:"fire",random
XTRAP:"fire",random
XTRAP:"fire",random
XTRAP:random,random
XTRAP:random,random
X# Random monsters.
XMONSTER:'H',"Lord Surtur",(17,08)
XMONSTER:'a',"fire ant",random
XMONSTER:'a',"fire ant",random
XMONSTER:'a',"fire ant",random
XMONSTER:'a',"fire ant",random
XMONSTER:'a',random,random
XMONSTER:'a',random,random
XMONSTER:'H',"fire giant",(10,06),hostile
XMONSTER:'H',"fire giant",(10,07),hostile
XMONSTER:'H',"fire giant",(10,08),hostile
XMONSTER:'H',"fire giant",(10,09),hostile
XMONSTER:'H',"fire giant",(10,10),hostile
XMONSTER:'H',"fire giant",(24,06),hostile
XMONSTER:'H',"fire giant",(24,07),hostile
XMONSTER:'H',"fire giant",(24,08),hostile
XMONSTER:'H',"fire giant",(24,09),hostile
XMONSTER:'H',"fire giant",(24,10),hostile
XMONSTER:'H',"fire giant",random,hostile
XMONSTER:'H',"fire giant",random,hostile
XMONSTER:'H',random,random,hostile
X
X#
X#	The "fill" levels for the quest.
X#
X#	These levels are used to fill out any levels not occupied by specific
X#	levels as defined above. "filla" is the upper filler, between the
X#	start and locate levels, and "fillb" the lower between the locate
X#	and goal levels.
X#
X
XMAZE: "V-filla" , 'I'
XINIT_MAP: '.' , 'I' , true , true , lit, false
XNOMAP
X#
XSTAIR: random, up
XSTAIR: random, down
X#
XOBJECT: random, random, random
XOBJECT: random, random, random
XOBJECT: random, random, random
XOBJECT: random, random, random
XOBJECT: random, random, random
XOBJECT: random, random, random
XOBJECT: random, random, random
XOBJECT: random, random, random
XOBJECT: random, random, random
X#
XMONSTER: 'a', "fire ant", random
XMONSTER: 'a', "fire ant", random
XMONSTER: 'a', "fire ant", random
XMONSTER: 'a', "fire ant", random
XMONSTER: 'a', "fire ant", random
XMONSTER: 'a', random, random
XMONSTER: 'H', "fire giant", random, hostile
X#
XTRAP: random, random
XTRAP: random, random
XTRAP: random, random
XTRAP: random, random
XTRAP: random, random
XTRAP: random, random
XTRAP: random, random
X
XMAZE: "V-fillb" , 'L'
XINIT_MAP: '.' , 'L' , true , true , lit, false
XNOMAP
X#
XSTAIR: random, up
XSTAIR: random, down
X#
XOBJECT: random, random, random
XOBJECT: random, random, random
XOBJECT: random, random, random
XOBJECT: random, random, random
XOBJECT: random, random, random
XOBJECT: random, random, random
XOBJECT: random, random, random
XOBJECT: random, random, random
XOBJECT: random, random, random
XOBJECT: random, random, random
XOBJECT: random, random, random
X#
XMONSTER: 'a', "fire ant", random
XMONSTER: 'a', "fire ant", random
XMONSTER: 'a', "fire ant", random
XMONSTER: 'a', random, random
XMONSTER: 'H', "fire giant", random, hostile
XMONSTER: 'H', "fire giant", random, hostile
XMONSTER: 'H', "fire giant", random, hostile
X#
XTRAP: "fire", random
XTRAP: "fire", random
XTRAP: "fire", random
XTRAP: "fire", random
XTRAP: "fire", random
XTRAP: random, random
XTRAP: random, random
END_OF_FILE
if test 10123 -ne `wc -c <'dat/Valkyrie.des'`; then
    echo shar: \"'dat/Valkyrie.des'\" unpacked with wrong size!
fi
# end of 'dat/Valkyrie.des'
fi
if test -f 'sys/amiga/winami.c1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/amiga/winami.c1'\"
else
echo shar: Extracting \"'sys/amiga/winami.c1'\" \(45206 characters\)
sed "s/^X//" >'sys/amiga/winami.c1' <<'END_OF_FILE'
X/*    SCCS Id: @(#)winami.c    3.1    93/01/07 */
X/* Copyright (c) Gregg Wonderly, Naperville, Illinois,  1991,1992,1993. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include "hack.h"
X#include "wintype.h"
X#include "winami.h"
X#include "func_tab.h"
X
X#ifdef AMIGA_INTUITION
X
X/* These should probably not even be options, but, I will leave them
X * for now... GGW
X */
X
X/*#define   TOPL_GETLINE	/* Don't use a window for getlin() */
X/*#define   WINDOW_YN		/* Use a window for y/n questions */
X
X#include <exec/types.h>
X#include <exec/io.h>
X#include <exec/alerts.h>
X#include <exec/devices.h>
X#include <devices/console.h>
X#include <devices/conunit.h>
X#include <graphics/gfxbase.h>
X#include <intuition/intuition.h>
X#include <intuition/intuitionbase.h>
X#include <libraries/dosextens.h>
X#include <ctype.h>
X#undef  strcmpi
X#include <string.h>
X#include <errno.h>
X
X#ifdef  IDCMP_CLOSEWINDOW
X# define	INTUI_NEW_LOOK
X#endif
X
X#ifdef AZTEC_C
X#include <functions.h>
X#else
X#include <proto/dos.h>
X#include <proto/exec.h>
X#include <proto/console.h>
X#include <proto/diskfont.h>
X
X/* kludge - see amirip for why */
X#undef red
X#undef green
X#undef blue
X#include <proto/graphics.h>
X#ifndef __SASC_60
X#undef index
X# define index strchr
X#endif
X
X#include <proto/intuition.h>
X#endif
X
Xstatic void RandomWindow( char * );
X
X/* cw->data[x] contains 2 characters worth of special information.  These
X * characters are stored at the offsets as described here.
X */
X#define VATTR	  0	/* Video attribute is in this slot */
X#define SEL_ITEM  1	/* If this is a select item, slot is 1 else 0 */
X#define SOFF	  2	/* The string starts here.  */
X
X/* Nethack defines NULL as ((char *)0) which is very inconvienent... */
X#undef NULL
X#define NULL 0L
X
X/*
X * Versions we need of various libraries.  We can't use LIBRARY_VERSION
X * as defined in <exec/types.h> because some of the libraries we need
X * don't have that version number in the 1.2 ROM.
X */
X
X#define INTUITION_VERSION	33L
X#define GRAPHICS_VERSION	33L
X#define DISKFONT_VERSION	34L
X#define ICON_VERSION		34L
X
X/* These values are just sorta suggestions in use, but are minimum requirements
X * in reality...
X */
X#define WINDOWHEIGHT	192
X#define SCREENHEIGHT	200
X#define WIDTH		640
X
X/* This character is a solid block (cursor) in Hack.font */
X#define CURSOR_CHAR	0x90
X
X/* All we currently support is hack.font at 8x8... */
X#define FONTWIDTH	8
X#define FONTHEIGHT	8
X#define FONTBASELINE	8
X
X/* If Compiling with the "New Look", redefine these now */
X#ifdef  INTUI_NEW_LOOK
X#define NewWindow ExtNewWindow
X#define NewScreen ExtNewScreen
X#endif
X
X/* Get the prototypes for our files */
X#include "Amiga:winami.p"
X#include "Amiga:amiwind.p"
X#include "Amiga:amidos.p"
X
X/* Interface definition, for use by windows.c and winprocs.h to provide
X * the intuition interface for the amiga...
X */
Xstruct window_procs amii_procs =
X{
X    "amii",
X    amii_init_nhwindows,
X    amii_player_selection,
X    amii_askname,
X    amii_get_nh_event,
X    amii_exit_nhwindows,
X    amii_suspend_nhwindows,
X    amii_resume_nhwindows,
X    amii_create_nhwindow,
X    amii_clear_nhwindow,
X    amii_display_nhwindow,
X    amii_destroy_nhwindow,
X    amii_curs,
X    amii_putstr,
X    amii_display_file,
X    amii_start_menu,
X    amii_add_menu,
X    amii_end_menu,
X    amii_select_menu,
X    amii_update_inventory,
X    amii_mark_synch,
X    amii_wait_synch,
X#ifdef CLIPPING
X    amii_cliparound,
X#endif
X    amii_print_glyph,
X    amii_raw_print,
X    amii_raw_print_bold,
X    amii_nhgetch,
X    amii_nh_poskey,
X    amii_bell,
X    amii_doprev_message,
X    amii_yn_function,
X    amii_getlin,
X#ifdef COM_COMPL
X    amii_get_ext_cmd,
X#endif /* COM_COMPL */
X    amii_number_pad,
X    amii_delay_output,
X    /* other defs that really should go away (they're tty specific) */
X    amii_delay_output,
X    amii_delay_output,
X};
X
Xextern struct GfxBase *GfxBase;
Xextern struct Library *DiskfontBase;
Xextern struct IntuitionBase *IntuitionBase;
X
X/* All kinds of shared stuff */
Xextern struct TextAttr Hack80;
Xextern struct Screen *HackScreen;
Xextern struct Window *pr_WindowPtr;
Xextern struct Menu HackMenu[];
Xextern unsigned char KbdBuffered;
Xextern struct TextFont *HackFont;
Xextern struct IOStdReq ConsoleIO;
Xextern struct Library *ConsoleDevice;
Xextern struct MsgPort *HackPort;
Xextern char Initialized;
Xextern char toplines[BUFSZ];
X
Xchar morc;  /* the character typed in response to a --more-- prompt */
Xchar spaces[] =
X"                                                                           ";
Xextern winid WIN_MESSAGE;
Xextern winid WIN_MAP;
Xextern winid WIN_STATUS;
Xextern winid WIN_INVEN;
X
Xwinid WIN_BASE = WIN_ERR;
X
X/* Changed later during window/screen opens... */
Xint txwidth=FONTWIDTH, txheight=FONTHEIGHT, txbaseline = FONTBASELINE;
X
X/* If a 240 or more row screen is in front when we start, this will be
X * set to 1, and the windows will be given borders to allow them to be
X * arranged differently.  The Message window may eventually get a scroller...
X */
Xint bigscreen = 0;
X
Xstatic void outmore(struct WinDesc *);
Xstatic void outsubstr(struct WinDesc *,char *,int);
Xstatic void dismiss_nhwindow(winid);
X
X/* This gadget data is replicated for menu/text windows... */
Xstatic struct PropInfo PropScroll = { AUTOKNOB+FREEVERT,
X					0xffff,0xffff, 0xffff,0xffff, };
Xstatic struct Image Image1 = { 0,0, 7,102, 0, NULL, 0x0000,0x0000, NULL };
Xstatic struct Gadget MenuScroll = {
X    NULL, -15,10, 15,-19, GRELRIGHT|GRELHEIGHT,
X    RELVERIFY|FOLLOWMOUSE|RIGHTBORDER,
X    PROPGADGET, (APTR)&Image1, NULL, NULL, NULL, (APTR)&PropScroll,
X    1, NULL
X};
X
Xint wincnt=0;   /* # of nh windows opened */
X
X/* We advertise a public screen to allow some people to do other things
X * while they are playing...  like compiling...
X */
X
X#ifdef  INTUI_NEW_LOOK
Xstruct TagItem tags[] =
X{
X    { WA_PubScreenName, (ULONG)"NetHack", },
X    { TAG_DONE, 0, },
X};
X#endif
X
X/*
X * The default dimensions and status values for each window type.  The
X * data here is generally changed in create_nhwindow(), so beware that
X * what you see here may not be exactly what you get.
X */
Xstruct win_setup {
X    struct NewWindow newwin;
X    xchar offx,offy,maxrow,rows,maxcol,cols;	/* CHECK TYPES */
X} new_wins[] = {
X
X    /* First entry not used, types are based on 1 */
X    {{0}},
X
X    /* NHW_MESSAGE */
X    {{0,1,640,11,0xff,0xff,
X    RAWKEY,
X    BORDERLESS|ACTIVATE|SMART_REFRESH
X#ifdef  INTUI_NEW_LOOK
X    |WFLG_NW_EXTENDED
X#endif
X    ,
X    NULL,NULL,(UBYTE*)"Messages",NULL,NULL,-1,-1,0xffff,0xffff,CUSTOMSCREEN,
X#ifdef  INTUI_NEW_LOOK
X    tags,
X#endif
X    },
X    0,0,1,1,80,80},
X
X    /* NHW_STATUS */
X    {{0,181,640,24,0xff,0xff,RAWKEY|MENUPICK|DISKINSERTED,
X    BORDERLESS|ACTIVATE|SMART_REFRESH
X#ifdef  INTUI_NEW_LOOK
X    |WFLG_NW_EXTENDED
X#endif
X    ,
X    NULL,NULL,(UBYTE*)"Game Status",NULL,NULL,-1,-1,0xffff,0xffff,CUSTOMSCREEN,
X#ifdef  INTUI_NEW_LOOK
X    tags,
X#endif
X    },
X    0,0,2,2,78,78},
X
X    /* NHW_MAP */
X    {{0,0,WIDTH,WINDOWHEIGHT,0xff,0xff,
X    RAWKEY|MENUPICK|MOUSEBUTTONS|ACTIVEWINDOW
X#ifdef  INTUI_NEW_LOOK
X    |WFLG_NW_EXTENDED
X#endif
X    ,
X    BORDERLESS|ACTIVATE|SMART_REFRESH|BACKDROP,
X    NULL,NULL,(UBYTE*)"Dungeon Map",NULL,NULL,-1,-1,0xffff,0xffff,CUSTOMSCREEN,
X#ifdef  INTUI_NEW_LOOK
X    tags,
X#endif
X    },
X    0,0,22,22,80,80},
X
X    /* NHW_MENU */
X    {{400,10,10,10,80,30,
X    RAWKEY|MENUPICK|DISKINSERTED|MOUSEMOVE|MOUSEBUTTONS|
X    GADGETUP|GADGETDOWN|CLOSEWINDOW|VANILLAKEY|NEWSIZE
X#ifdef  INTUI_NEW_LOOK
X    |WFLG_NW_EXTENDED
X#endif
X    ,
X    WINDOWSIZING|WINDOWCLOSE|WINDOWDRAG|ACTIVATE|SMART_REFRESH,
X    &MenuScroll,NULL,(UBYTE*)"Pick an Item",
X    NULL,NULL,-1,-1,0xffff,0xffff,CUSTOMSCREEN,
X#ifdef  INTUI_NEW_LOOK
X    tags,
X#endif
X    },
X    0,0,1,1,22,78},
X
X    /* NHW_TEXT */
X    {{0,0,640,200,0xff,0xff,
X    RAWKEY|MENUPICK|DISKINSERTED|MOUSEMOVE|
X    GADGETUP|CLOSEWINDOW|VANILLAKEY|NEWSIZE
X#ifdef  INTUI_NEW_LOOK
X    |WFLG_NW_EXTENDED
X#endif
X    ,
X    WINDOWSIZING|WINDOWCLOSE|WINDOWDRAG|ACTIVATE|SMART_REFRESH,
X    &MenuScroll,NULL,(UBYTE*)NULL,NULL,NULL,-1,-1,0xffff,0xffff,CUSTOMSCREEN,
X#ifdef  INTUI_NEW_LOOK
X    tags,
X#endif
X    },
X    0,0,1,1,22,78},
X
X    /* NHW_BASE */
X    {{0,0,WIDTH,WINDOWHEIGHT,0xff,0xff,
X    RAWKEY|MENUPICK|MOUSEBUTTONS
X#ifdef  INTUI_NEW_LOOK
X    |WFLG_NW_EXTENDED
X#endif
X    ,
X    BORDERLESS|ACTIVATE|SMART_REFRESH|BACKDROP,
X    NULL,NULL,(UBYTE*)NULL,NULL,NULL,-1,-1,0xffff,0xffff,CUSTOMSCREEN,
X#ifdef  INTUI_NEW_LOOK
X    tags,
X#endif
X    },
X    0,0,22,22,80,80},
X};
X
X/* The physical screen information */
Xstruct DisplayDesc *amiIDisplay;
X
X/* The opened windows information */
Xstruct WinDesc *wins[MAXWIN + 1];
X
X/* The last Window event is stored here for reference. */
Xextern WEVENT lastevent;
X
Xstatic const char winpanicstr[]="Bad winid %d in %s()";
X#define         SIZEOF_DISKNAME 8
X
X/* The current color map */
Xunsigned short amii_curmap[] = {
X#define C_BLACK		0
X#define C_WHITE		1
X#define C_BROWN		2
X#define C_CYAN		3
X#define C_GREEN		4
X#define C_MAGENTA	5
X#define C_BLUE		6
X#define C_RED		7
X    0x0AAA, /* color #0 */
X    0x0FFF, /* color #1 */
X    0x0620, /* color #2 */
X    0x0B08, /* color #3 */
X    0x0181, /* color #4 */
X    0x0C06, /* color #5 */
X    0x023E, /* color #6 */
X    0x0D00  /* color #7 */
X};
X
X#ifdef  INTUI_NEW_LOOK
XUWORD scrnpens[] = {
X    C_BROWN,
X    C_BLACK,
X    C_WHITE,
X    C_WHITE,
X    C_BROWN,
X    C_CYAN,
X    C_BROWN,
X    C_BLACK,
X    C_RED,
X};
Xstruct TagItem scrntags[] =
X{
X    { SA_PubName, (ULONG)"NetHack" },
X    { SA_Pens, (ULONG)scrnpens },
X    { TAG_DONE, 0 },
X};
X#endif
X
Xstruct NewScreen NewHackScreen =
X{
X    0, 0, WIDTH, SCREENHEIGHT, DEPTH,
X    C_BLACK, C_WHITE,     /* DetailPen, BlockPen */
X    HIRES,
X    CUSTOMSCREEN
X#ifdef  INTUI_NEW_LOOK
X    |NS_EXTENDED
X#endif
X    ,
X    &Hack80,  /* Font */
X    (UBYTE *)" NetHack 3.1",
X    NULL,     /* Gadgets */
X    NULL,     /* CustomBitmap */
X#ifdef  INTUI_NEW_LOOK
X    scrntags,
X#endif
X};
X
X/* Make sure the user sees a text string when no windowing is available */
X
Xvoid
Xamii_raw_print(s)
X    register const char *s;
X{
X    if( !s )
X	return;
X    if(amiIDisplay)amiIDisplay->rawprint++;
X
X    if( Initialized == 0 && WIN_BASE == WIN_ERR )
X	    init_nhwindows();
X
X    if( WIN_MAP != WIN_ERR && wins[ WIN_MAP ] )
X	amii_putstr( WIN_MAP, 0, s );
X    else if( WIN_BASE != WIN_ERR && wins[ WIN_BASE ] )
X	amii_putstr( WIN_BASE, 0, s );
X    else {
X	printf("%s\n", s);
X	fflush(stdout);
X    }
X}
X
X/* Make sure the user sees a bold text string when no windowing
X * is available
X */
X
Xvoid
Xamii_raw_print_bold(s)
X    register const char *s;
X{
X    if( !s )
X	return;
X
X    if(amiIDisplay)amiIDisplay->rawprint++;
X
X    if( Initialized == 0 && WIN_BASE == WIN_ERR )
X	    init_nhwindows();
X
X    if( WIN_MAP != WIN_ERR && wins[ WIN_MAP ] )
X	amii_putstr( WIN_MAP, 1, s );
X    else if( WIN_BASE != WIN_ERR && wins[ WIN_BASE ] )
X	amii_putstr( WIN_BASE, 1, s );
X    else {
X	printf("\33[1m%s\33[0m\n",s);
X	fflush(stdout);
X    }
X}
X
X/* Start building the text for a menu */
Xvoid
Xamii_start_menu(window)
X    register winid window;
X{
X    register struct WinDesc *cw;
X
X    if(window == WIN_ERR || (cw = wins[window]) == NULL || cw->type != NHW_MENU)
X	panic(winpanicstr,window, "start_menu");
X
X    amii_clear_nhwindow(window);
X    if( cw->resp )
X	*cw->resp = 0;
X    cw->maxrow = cw->maxcol = 0;
X
X    return;
X}
X
X/* Add a string to a menu */
Xvoid
Xamii_add_menu(window,ch,attr,str)
X    register winid window;
X    register char ch;
X    register int attr;
X    register const char *str;
X{
X    register struct WinDesc *cw;
X    char tmpbuf[2];
X
X    if(str == NULL)return;
X
X    if(window == WIN_ERR || (cw = wins[window]) == NULL || cw->type != NHW_MENU)
X	panic(winpanicstr,window, "add_menu");
X
X    /* this should translate fonts if a title line */
X    amii_putstr(window, attr, str);
X
X    if( !cw->resp )
X	panic("No response buffer in add_menu()");
X
X    if( !cw->data )
X	panic("No data buffer in add_menu()");
X
X    if(ch != '\0')
X    {
X	tmpbuf[0]=ch;
X	tmpbuf[1]=0;
X	Strcat(cw->resp, tmpbuf);
X	cw->data[ cw->cury - 1 ][ SEL_ITEM ] = 1;
X    }
X    else
X    {
X	/* Use something as a place holder.  ^A is probably okay */
X
X	tmpbuf[0]=1;
X	tmpbuf[1]=0;
X	Strcat(cw->resp, tmpbuf);
X	cw->data[ cw->cury - 1 ][ SEL_ITEM ] = 0;
X    }
X}
X
X/* Done building a menu. */
X
Xvoid
Xamii_end_menu(window,cancel,str,morestr)
X    register winid window;
X    register char cancel;
X    register const char *str;
X    register const char *morestr;
X{
X    register struct WinDesc *cw;
X
X    if(window == WIN_ERR || (cw=wins[window]) == NULL || cw->type != NHW_MENU
X	  || cw->canresp)
X	panic(winpanicstr,window, "end_menu");
X
X    if(str)
X    {
X	cw->canresp = (char*) alloc(strlen(str)+2);
X	cw->canresp[0]=cancel;
X	Strcpy(&cw->canresp[1],str);
X
X	if( !cw->resp )
X	    panic("No response buffer in end_menu()");
X
X	strncat(cw->resp, str, 1);
X    }
X
X    if(morestr)
X    {
X	cw->morestr =(char *) alloc(strlen(morestr)+1);
X	Strcpy(cw->morestr, morestr);
X    }
X}
X
X/* Select something from the menu. */
X
Xchar
Xamii_select_menu(window)
X    register winid window;
X{
X    register struct WinDesc *cw;
X
X    if( window == WIN_ERR || ( cw=wins[window] ) == NULL ||
X	  cw->type != NHW_MENU )
X	panic(winpanicstr,window, "select_menu");
X
X    morc = 0;                       /* very ugly global variable */
X    amii_display_nhwindow(window,TRUE); /* this waits for input */
X    dismiss_nhwindow(window);       /* Now tear it down */
X    return morc;
X}
X
X/* Rebuild/update the inventory if the window is up.  This is currently
X * a noop for us because we always take any menu window off of the
X * screen by deleting it when the user makes a selection, or cancels
X * the menu.
X */
Xvoid
Xamii_update_inventory()
X{
X    register struct WinDesc *cw;
X
X    if( WIN_INVEN != WIN_ERR && ( cw = wins[ WIN_INVEN ] ) &&
X      cw->type == NHW_MENU && cw->win )
X    {
X	display_inventory( NULL, FALSE );
X	WindowToFront( cw->win );
X	ActivateWindow( cw->win );
X    }
X}
X
X/* Humm, doesn't really do anything useful */
X
Xvoid
Xamii_mark_synch()
X{
X    if(!amiIDisplay)
X	fflush(stderr);
X/* anything else?  do we need this much? */
X}
X
X/* Wait for everything to sync.  Nothing is asynchronous, so we just
X * ask for a key to be pressed.
X */
Xvoid
Xamii_wait_synch()
X{
X    if(!amiIDisplay || amiIDisplay->rawprint)
X    {
X	if(amiIDisplay) amiIDisplay->rawprint=0;
X    }
X    else
X    {
X	display_nhwindow(WIN_MAP,TRUE);
X	flush_glyph_buffer( wins[ WIN_MAP ]->win );
X    }
X}
X
X#ifdef CLIPPING
Xvoid
Xamii_setclipped()
X{
X    clipping = TRUE;
X    clipx=clipy=0;
X    clipxmax=CO;        /* WRONG */
X    clipymax=LI-5;      /* WRONG */
X}
X
Xvoid
Xamii_cliparound(x,y)
X    register int x,y;
X{
X/* pull this from wintty.c - LATER */
X}
X#endif
X
X/*
X * plname is filled either by an option (-u Player  or  -uPlayer) or
X * explicitly (by being the wizard) or by askname.
X * It may still contain a suffix denoting pl_character.
X * Always called after init_nhwindows() and before display_gamewindows().
X */
Xvoid
Xamii_askname()
X{
X    *plname = 0;
X    do {
X	getlin( "Who are you?", plname );
X    } while( strlen( plname ) == 0 );
X
X    if( *plname == '\33' )
X    {
X	clearlocks();
X	exit_nhwindows(NULL);
X	terminate(0);
X    }
X}
X
X#include "Amiga:char.c"
X
X/* Get the player selection character */
X
Xvoid
Xamii_player_selection()
X{
X    extern const char *roles[];
X    register struct Window *cwin;
X    register struct IntuiMessage *imsg;
X    register int aredone = 0;
X    register struct Gadget *gd;
X    static int once=0;
X    long class, code;
X    int i;
X
X    amii_clear_nhwindow( WIN_BASE );
X    if( *pl_character ){
X	pl_character[ 0 ] = toupper( pl_character[ 0 ] );
X	if( index( pl_classes, pl_character[ 0 ] ) )
X	    return;
X    }
X
X    if( !once ){
X	if( bigscreen ){
X	    Type_NewWindowStructure1.TopEdge =
X	      (HackScreen->Height/2) - (Type_NewWindowStructure1.Height/2);
X	}
X	for( gd = Type_NewWindowStructure1.FirstGadget; gd;
X	  gd = gd->NextGadget )
X	{
X	    if( gd->GadgetID != 0 )
X		SetBorder( gd );
X	}
X	once = 1;
X    }
X
X    Type_NewWindowStructure1.Screen = HackScreen;
X    if( ( cwin = OpenShWindow( (void *)&Type_NewWindowStructure1 ) ) == NULL )
X    {
X	return;
X    }
X
X    while( !aredone )
X    {
X	WaitPort( cwin->UserPort );
X	while( ( imsg = (void *) GetMsg( cwin->UserPort ) ) != NULL )
X	{
X	    class = imsg->Class;
X	    code = imsg->Code;
X	    gd = (struct Gadget *)imsg->IAddress;
X	    ReplyMsg( (struct Message *)imsg );
X
X	    switch( class )
X	    {
X	    case VANILLAKEY:
X		if( index( pl_classes, toupper( code ) ) )
X		{
X		    pl_character[0] = toupper( code );
X		    aredone = 1;
X		}
X		else if( code == ' ' || code == '\n' || code == '\r' )
X		{
X#ifdef  TOURIST
X		    strcpy( pl_character, roles[ rnd( 11 ) ] );
X#else
X		    strcpy( pl_character, roles[ rnd( 10 ) ] );
X#endif
X		    aredone = 1;
X		    amii_clear_nhwindow( WIN_BASE );
X		    CloseShWindow( cwin );
X		    RandomWindow( pl_character );
X		    return;
X		}
X		else if( code == 'q' || code == 'Q' )
X		{
X		CloseShWindow( cwin );
X		clearlocks();
X		exit_nhwindows(NULL);
X		terminate(0);
X		}
X		else
X		    DisplayBeep( NULL );
X		break;
X
X	    case GADGETUP:
X		switch( gd->GadgetID )
X		{
X		case 1: /* Random Character */
X#ifdef  TOURIST
X		    strcpy( pl_character, roles[ rnd( 11 ) ] );
X#else
X		    strcpy( pl_character, roles[ rnd( 10 ) ] );
X#endif
X		    amii_clear_nhwindow( WIN_BASE );
X		    CloseShWindow( cwin );
X		    RandomWindow( pl_character );
X		    return;
X
X		default:
X		    pl_character[0] = gd->GadgetID;
X		    break;
X		}
X		aredone = 1;
X		break;
X
X	    case CLOSEWINDOW:
X		CloseShWindow( cwin );
X		clearlocks();
X		exit_nhwindows(NULL);
X		terminate(0);
X		break;
X	    }
X	}
X    }
X    amii_clear_nhwindow( WIN_BASE );
X    CloseShWindow( cwin );
X}
X
X#ifndef KENI_S_WAY
X#include "Amiga:randwin.c"
X
Xstatic void
XRandomWindow( name )
X    char *name;
X{
X    struct MsgPort *tport;
X    struct timerequest *trq;
X    static int once = 0;
X    struct Gadget *gd;
X    struct Window *w;
X    struct IntuiMessage *imsg;
X    int ticks = 0, aredone = 0, timerdone = 0;
X    long mask, got;
X
X    tport = CreatePort( 0, 0 );
X    trq = (struct timerequest *)CreateExtIO( tport, sizeof( *trq ) );
X    if( tport == NULL || trq == NULL )
X    {
Xallocerr:
X	if( tport ) DeletePort( tport );
X	if( trq ) DeleteExtIO( (struct IORequest *)trq );
X	Delay( 8 * 50 );
X    }
X
X    if( OpenDevice( TIMERNAME, UNIT_VBLANK, (struct IORequest *)trq, 0L ) != 0 )
X	goto allocerr;
X
X    trq->tr_node.io_Command = TR_ADDREQUEST;
X    trq->tr_time.tv_secs = 8;
X    trq->tr_time.tv_micro = 0;
X
X    SendIO( (struct IORequest *)trq );
X
X    /* Place the name in the center of the screen */
X    Rnd_IText5.IText = name;
X    Rnd_IText6.LeftEdge = Rnd_IText4.LeftEdge +
X		(strlen(Rnd_IText4.IText)+1)*txwidth;
X    Rnd_NewWindowStructure1.Width = (
X	    (strlen( Rnd_IText2.IText )+1) * txwidth ) +
X	    HackScreen->WBorLeft + HackScreen->WBorRight;
X    Rnd_IText5.LeftEdge = (Rnd_NewWindowStructure1.Width -
X	    (strlen(name)*txwidth))/2;
X
X    gd = Rnd_NewWindowStructure1.FirstGadget;
X    gd->LeftEdge = (Rnd_NewWindowStructure1.Width - gd->Width)/2;
X	/* Chose correct modifier */
X    Rnd_IText6.IText = "a";
X    switch( *name )
X    {
X    case 'a': case 'e': case 'i': case 'o':
X    case 'u': case 'A': case 'E': case 'I':
X    case 'O': case 'U':
X	Rnd_IText6.IText = "an";
X	break;
X    }
X
X    if( !once )
X    {
X	if( bigscreen )
X	{
X	    Rnd_NewWindowStructure1.TopEdge =
X		(HackScreen->Height/2) - (Rnd_NewWindowStructure1.Height/2);
X	}
X	for( gd = Rnd_NewWindowStructure1.FirstGadget; gd; gd = gd->NextGadget )
X	{
X	    if( gd->GadgetID != 0 )
X		SetBorder( gd );
X	}
X	once = 1;
X    }
X
X    Rnd_NewWindowStructure1.Screen = HackScreen;
X    if( ( w = OpenShWindow( (void *)&Rnd_NewWindowStructure1 ) ) == NULL )
X    {
X	AbortIO( (struct IORequest *)trq );
X	WaitIO( (struct IORequest *)trq );
X	CloseDevice( (struct IORequest *)trq );
X	DeleteExtIO( (struct IORequest *) trq );
X	DeletePort( tport );
X	Delay( 50 * 8 );
X	return;
X    }
X    PrintIText( w->RPort, &Rnd_IntuiTextList1, 0, 0 );
X
X    mask = (1L << tport->mp_SigBit)|(1L << w->UserPort->mp_SigBit);
X    while( !aredone )
X    {
X	got = Wait( mask );
X	if( got & (1L << tport->mp_SigBit ) )
X	{
X	    aredone = 1;
X	    timerdone = 1;
X	    GetMsg( tport );
X	    CloseShWindow( w );
X	    w = NULL;
X        }
X        while( w && ( imsg = (struct IntuiMessage *) GetMsg( w->UserPort ) ) )
X        {
X	    switch( imsg->Class )
X	    {
X		/* Must be up for a little while... */
X	    case INACTIVEWINDOW:
X		if( ticks >= 40 )
X		    aredone = 1;
X		break;
X
X	    case INTUITICKS:
X		++ticks;
X		break;
X
X	    case GADGETUP:
X		aredone = 1;
X		break;
X	    }
X	    ReplyMsg( (struct Message *)imsg );
X        }
X    }
X
X    if( !timerdone )
X    {
X	AbortIO( (struct IORequest *)trq );
X	WaitIO( (struct IORequest *)trq );
X    }
X
X    CloseDevice( (struct IORequest *)trq );
X    DeleteExtIO( (struct IORequest *) trq );
X    DeletePort( tport );
X    if(w) CloseShWindow( w );
X}
X#endif
X
X/* this should probably not be needed (or be renamed)
Xvoid
Xflush_output(){} */
X
Xvoid
Xamii_destroy_nhwindow(win)      /* just hide */
X    register winid win;
X{
X    register struct WinDesc *cw;
X    register int i;
X
X    if( win == WIN_ERR || ( cw = wins[win] ) == NULL )
X    {
X	panic(winpanicstr,win,"destroy_nhwindow");
X    }
X
X    /* Tear down the Intuition stuff */
X    dismiss_nhwindow(win);
X
X    if( cw->data && cw->type == NHW_MESSAGE ||
X			    cw->type == NHW_MENU || cw->type == NHW_TEXT )
X    {
X	for( i = 0; i < cw->maxrow; ++i )
X	{
X	    if( cw->data[ i ] )
X		free( cw->data[ i ] );
X	}
X	free( cw->data );
X	cw->data = NULL;
X    }
X
X    if( cw->resp )
X	free( cw->resp );
X    cw->resp = NULL;
X
X    if( cw->canresp )
X	free( cw->canresp );
X    cw->canresp = NULL;
X
X    if( cw->morestr )
X	free( cw->morestr );
X    cw->morestr = NULL;
X
X    free( cw );
X    wins[win] = NULL;
X}
X
Xamii_create_nhwindow(type)
X    register int type;
X{
X    register struct Window *w = NULL;
X    register struct NewWindow *nw = NULL;
X    register struct WinDesc *wd = NULL;
X    struct Window *mapwin = NULL, *stwin = NULL, *msgwin = NULL;
X    register int newid;
X
X    if( WIN_STATUS != WIN_ERR && wins[ WIN_STATUS ] )
X	stwin = wins[ WIN_STATUS ]->win;
X
X    if( WIN_MESSAGE != WIN_ERR && wins[ WIN_MESSAGE ] )
X	msgwin = wins[ WIN_MESSAGE ]->win;
X
X    if( WIN_MAP != WIN_ERR && wins[ WIN_MAP ] )
X	mapwin = wins[ WIN_MAP ]->win;
X
X    /* Create Port anytime that we need it */
X
X    if( HackPort == NULL )
X    {
X	HackPort = CreatePort( NULL, 0 );
X	if( !HackPort )
X	    panic( "no memory for msg port" );
X    }
X
X    nw = &new_wins[ type ].newwin;
X    nw->Width = amiIDisplay->xpix;
X    nw->Screen = HackScreen;
X
X    if( type == NHW_MAP || type == NHW_BASE )
X    {
X	nw->DetailPen = C_WHITE;
X	nw->BlockPen = C_MAGENTA;
X	nw->TopEdge = 1;
X	nw->LeftEdge = 0;
X	nw->Height = amiIDisplay->ypix - nw->TopEdge;
X	if( bigscreen && type == NHW_MAP )
X	{
X	    int h;
X	    if( msgwin && stwin )
X	    {
X		h = (stwin->TopEdge - nw->TopEdge - 1) -
X				(msgwin->TopEdge + msgwin->Height + 1);
X		h = h - ( (22 * stwin->RPort->TxHeight) +
X				    stwin->BorderTop + stwin->BorderBottom );
X		/* h is now the available space excluding the map window so
X		 * divide by 2 and use it to space out the map window.
X		 */
X		if( h > 0 )
X		    h /= 2;
X		else
X		    h = 0;
X		nw->TopEdge = msgwin->TopEdge + msgwin->Height + 1 + h;
X		nw->Height = stwin->TopEdge + 1 - nw->TopEdge - h;
X	    }
X	    else
X	    {
X		h = amiIDisplay->ypix - (22 * FONTHEIGHT) - 12 - 10;
X		if( h > 0 )
X		{
X		    nw->TopEdge = h / 2;
X		    nw->Height = (22 * FONTHEIGHT) + 12 + 10;
X		}
X		else
X		{
X		    nw->Height -= 85;
X		    nw->TopEdge += 35;
X		}
X	    }
X	}
X    }
X    else if( type == NHW_STATUS )
X    {
X	nw->DetailPen = C_CYAN;
X	nw->BlockPen = C_CYAN;
X	if( WIN_MAP != WIN_ERR && wins[ WIN_MAP ] )
X	    w = wins[ WIN_MAP ]->win;
X	else if( WIN_BASE != WIN_ERR && wins[ WIN_BASE ] )
X	    w = wins[ WIN_BASE ]->win;
X	else
X	    panic( "No window to base STATUS location from" );
X
X	/* Status window is relative to bottom of WIN_BASE/WIN_MAP */
X
X	if( mapwin && bigscreen )
X	{
X	    nw->TopEdge = mapwin->TopEdge + mapwin->Height;
X	    nw->Height = amiIDisplay->ypix - nw->TopEdge - 1;
X	}
X	else
X	{
X	    /* Expand the height of window by borders */
X	    if( bigscreen )
X		nw->Height = (txheight * 2) + 17;
X
X	    nw->TopEdge = amiIDisplay->ypix - nw->Height;
X	    nw->LeftEdge = w->LeftEdge;
X	    if( nw->LeftEdge + nw->Width >= amiIDisplay->xpix )
X		nw->LeftEdge = 0;
X	    if( nw->Width >= amiIDisplay->xpix - nw->LeftEdge )
X		nw->Width = amiIDisplay->xpix - nw->LeftEdge;
X	}
X    }
X    else if( type == NHW_MESSAGE )
X    {
X	nw->DetailPen = C_RED;
X	nw->BlockPen = C_RED;
X	if( WIN_MAP != WIN_ERR && wins[ WIN_MAP ] )
X	    w = wins[ WIN_MAP ]->win;
X	else if( WIN_BASE != WIN_ERR && wins[ WIN_BASE ] )
X	    w = wins[ WIN_BASE ]->win;
X	else
X	    panic( "No window to base STATUS location from" );
X
X	nw->TopEdge = 1;
X	if( bigscreen )
X	{
X	    if( mapwin )
X	    {
X		nw->Height = mapwin->TopEdge - 2;
X	    }
X	    else
X	    {
X		nw->Height += 15;
X	    }
X	}
X    }
X    else
X    {
X	nw->DetailPen = C_WHITE;
X	nw->BlockPen = C_MAGENTA;
X    }
X
X    /* When Interlaced, there is "Room" for all this stuff */
X/* WRONG - still not enough space on MAP for right border */
X    if( bigscreen && type != NHW_BASE )
X    {
X	nw->Flags &= ~( BORDERLESS | BACKDROP );
X#if 1
X	nw->Flags |= ( WINDOWDRAG | WINDOWDEPTH );
X#else
X	nw->Flags |= ( WINDOWDRAG | WINDOWDEPTH | SIZEBRIGHT );
X	if( type == NHW_MAP )
X	    nw->Flags |= WINDOWSIZING;
X#endif
X    }
X    /* No titles on a hires only screen */
X    if( !bigscreen )
X	nw->Title = 0;
X
X    /* Don't open MENU or TEXT windows yet */
X
X    if( type == NHW_MENU || type == NHW_TEXT )
X	w = NULL;
X    else
X	w=OpenShWindow( (void *)nw );
X
X    if( w == NULL && type != NHW_MENU && type != NHW_TEXT )
X	panic("bad openwin %d",type);
X
X    /* Check for an empty slot */
X
X    for(newid = 0; newid<MAXWIN + 1; newid++)
X    {
X	if(wins[newid] == 0)
X	    break;
X    }
X
X    if(newid==MAXWIN+1)
X	panic("time to write re-alloc code\n");
X
X    /* Set wincnt accordingly */
X
X    if( newid > wincnt )
X	wincnt = newid;
X
X    /* Do common initialization */
X
X    wd = (struct WinDesc *)alloc(sizeof(struct WinDesc));
X    memset( wd, 0, sizeof( struct WinDesc ) );
X    wins[newid] = wd;
X
X    wd->newwin = NULL;
X    wd->win = w;
X    wd->type = type;
X    wd->flags = 0;
X    wd->active = FALSE;
X    wd->curx=wd->cury = 0;
X    wd->resp = wd->canresp = wd->morestr = 0;   /* CHECK THESE */
X    wd->offx = new_wins[type].offx;
X    wd->offy = new_wins[type].offy;
X    wd->maxrow = new_wins[type].maxrow;
X    wd->maxcol = new_wins[type].maxcol;
X
X    if( type != NHW_TEXT && type != NHW_MENU )
X    {
X	wd->rows = ( w->Height - w->BorderTop - w->BorderBottom ) /(txheight+1);
X	wd->cols = ( w->Width - w->BorderLeft - w->BorderRight ) / txwidth;
X    }
X
X    /* Okay, now do the individual type initialization */
X
X    switch(type)
X    {
X	/* History lines for MESSAGE windows are stored in cw->data[?].
X	 * maxcol and maxrow are used as cursors.  maxrow is the count
X	 * of the number of history lines stored.  maxcol is the cursor
X	 * to the last line that was displayed by ^P.
X	 */
X	case NHW_MESSAGE:
X	    if(flags.msg_history<20)flags.msg_history=20;
X	    if(flags.msg_history>200)flags.msg_history=200;
X	    flags.window_inited=TRUE;
X	    wd->data = (char **)alloc( flags.msg_history*sizeof( char * ) );
X	    memset( wd->data, 0, flags.msg_history * sizeof( char * ) );
X	    wd->maxrow = wd->maxcol = 0;
X	    /* Indicate that we have not positioned the cursor yet */
X	    wd->curx = -1;
X	    break;
X
X	    /* A MENU contains a list of lines in wd->data[?].  These
X	     * lines are created in amii_putstr() by reallocating the size
X	     * of wd->data to hold enough (char *)'s.  wd->rows is the
X	     * number of (char *)'s allocated.  wd->maxrow is the number
X	     * used.  wd->maxcol is used to track how wide the menu needs
X	     * to be.  wd->resp[x] contains the characters that correspond
X	     * to selecting wd->data[x].  wd->resp[x] corresponds to
X	     * wd->data[x] for any x. Elements of wd->data[?] that are not
X	     * valid selections have the corresponding element of
X	     * wd->resp[] set to a value of '\01';  i.e. a ^A which is
X	     * not currently a valid keystroke for responding to any
X	     * MENU or TEXT window.
X	     */
X	case NHW_MENU:
X	    wd->resp=(char*)alloc(256);
X	    wd->resp[0]=0;
X	    wd->rows = wd->maxrow = 0;
X	    wd->maxcol = 0;
X	    wd->data = NULL;
X	    break;
X
X	    /* See the explanation of MENU above.  Except, wd->resp[] is not
X	     * used for TEXT windows since there is no selection of a
X	     * a line performed/allowed.  The window is always full
X	     * screen width.
X	     */
X	case NHW_TEXT:
X	    wd->rows = wd->maxrow = 0;
X	    wd->maxcol = wd->cols = amiIDisplay->cols;
X	    wd->data = NULL;
X	    wd->morestr = NULL;
X	    break;
X
X	    /* The status window has only two lines.  These are stored in
X	     * wd->data[], and here we allocate the space for them.
X	     */
X	case NHW_STATUS:
X	    /* wd->cols is the number of characters which fit across the
X	     * screen.
X	     */
X	    wd->data=(char **)alloc(3*sizeof(char *));
X	    wd->data[0] = (char *)alloc(wd->cols + 10);
X	    wd->data[1] = (char *)alloc(wd->cols + 10);
X	    wd->data[2] = NULL;
X	    break;
X
X	    /* NHW_MAP does not use wd->data[] or the other text
X	     * manipulating members of the WinDesc structure.
X	     */
X	case NHW_MAP:
X	    SetMenuStrip(w, HackMenu);
X	    break;
X
X	    /* The base window must exist until CleanUp() deletes it. */
X	case NHW_BASE:
X	    /* Make our requesters come to our screen */
X	    {
X		register struct Process *myProcess =
X					(struct Process *) FindTask(NULL);
X		pr_WindowPtr = (struct Window *)(myProcess->pr_WindowPtr);
X		myProcess->pr_WindowPtr = (APTR) w;
X	    }
X
X	    /* Need this for RawKeyConvert() */
X
X	    ConsoleIO.io_Data = (APTR) w;
X	    ConsoleIO.io_Length = sizeof( struct Window * );
X	    ConsoleIO.io_Message.mn_ReplyPort = CreatePort(NULL, 0L);
X	    if( OpenDevice("console.device", 0L,
X				(struct IORequest *) &ConsoleIO, 0L) != 0)
X	    {
X		Abort(AG_OpenDev | AO_ConsoleDev);
X	    }
X
X	    ConsoleDevice = (struct Library *) ConsoleIO.io_Device;
X
X	    KbdBuffered = 0;
X
X#ifdef HACKFONT
X	    if( HackFont )
X		SetFont(w->RPort, HackFont);
X#endif
X	    txwidth = w->RPort->TxWidth;
X	    txheight = w->RPort->TxHeight;
X	    txbaseline = w->RPort->TxBaseline;
X	    break;
X
X	default:
X	    panic("bad create_nhwindow( %d )\n",type);
X	    return WIN_ERR;
X    }
X
X    return( newid );
X}
X
X/* Initialize the windowing environment */
X
Xvoid
Xamii_init_nhwindows()
X{
X    if (IntuitionBase)
X	panic( "init_nhwindow() called twice", 0 );
X
X    WIN_MESSAGE = WIN_ERR;
X    WIN_MAP = WIN_ERR;
X    WIN_STATUS = WIN_ERR;
X    WIN_INVEN = WIN_ERR;
X    WIN_BASE = WIN_ERR;
X
X    if ( (IntuitionBase = (struct IntuitionBase *)
X	    OpenLibrary("intuition.library", INTUITION_VERSION)) == NULL)
X    {
X	Abort(AG_OpenLib | AO_Intuition);
X    }
X
X    if ( (GfxBase = (struct GfxBase *)
X		OpenLibrary("graphics.library", GRAPHICS_VERSION)) == NULL)
X    {
X	Abort(AG_OpenLib | AO_GraphicsLib);
X    }
X
X#ifdef HACKFONT
X    /*
X     *  Force our own font to be loaded, if possible.
X     *  If we can open diskfont.library, but not our font, we can close
X     *  the diskfont.library again since it just wastes memory.
X     *  Even if we can open the font, we don't need the diskfont.library
X     *  anymore, since CloseFont is a graphics.library function.
X     */
X
X    if ((HackFont = OpenFont(&Hack80)) == NULL)
X    {
X	if (DiskfontBase =
X			OpenLibrary("diskfont.library", DISKFONT_VERSION))
X	{
X	    Hack80.ta_Name -= SIZEOF_DISKNAME;
X	    HackFont = OpenDiskFont(&Hack80);
X	    Hack80.ta_Name += SIZEOF_DISKNAME;
X	    CloseLibrary(DiskfontBase);
X	    DiskfontBase = NULL;
X	}
X    }
X#endif
X
X    amiIDisplay=(struct DisplayDesc *)alloc(sizeof(struct DisplayDesc));
X    memset( amiIDisplay, 0, sizeof( struct DisplayDesc ) );
X
X    /* Use Intuition sizes for overscan screens... */
X
X    amiIDisplay->ypix = GfxBase->NormalDisplayRows;
X    amiIDisplay->xpix = GfxBase->NormalDisplayColumns;
X
X    amiIDisplay->cols = amiIDisplay->xpix / FONTWIDTH;
X
X    amiIDisplay->toplin=0;
X    amiIDisplay->rawprint=0;
X    amiIDisplay->lastwin=0;
X
X    if( bigscreen == 0 )
X    {
X	if( ( GfxBase->ActiView->ViewPort->Modes & LACE ) == LACE )
X	{
X	    amiIDisplay->ypix *= 2;
X	    NewHackScreen.ViewModes |= LACE;
X	    bigscreen = 1;
X	}
X	else if( GfxBase->NormalDisplayRows >= 240 )
X	{
X	    bigscreen = 1;
X	}
X    }
X    else if( bigscreen == -1 )
X	bigscreen = 0;
X    else if( bigscreen )
X    {
X	/* If bigscreen requested and we don't have enough rows in
X	 * noninterlaced mode, switch to interlaced...
X	 */
X	if( GfxBase->NormalDisplayRows < 240 )
X	{
X	    amiIDisplay->ypix *= 2;
X	    NewHackScreen.ViewModes |= LACE;
X	}
X    }
X    amiIDisplay->rows = amiIDisplay->ypix / FONTHEIGHT;
X
X    /* This is the size screen we want to open, within reason... */
X
X    NewHackScreen.Width = max( WIDTH, amiIDisplay->xpix );
X    NewHackScreen.Height = max( SCREENHEIGHT, amiIDisplay->ypix );
X
X    if( ( HackScreen = OpenScreen( (void *)&NewHackScreen ) ) == NULL )
X	Abort( AN_OpenScreen & ~AT_DeadEnd );
X#ifdef  INTUI_NEW_LOOK
X    if( IntuitionBase->LibNode.lib_Version >= 37 )
X    {
X	PubScreenStatus( HackScreen, 0 );
X    }
X#endif
X
X#ifdef TEXTCOLOR
X    LoadRGB4(&HackScreen->ViewPort, amii_curmap, 1L << DEPTH );
X#endif
X
X    /* Display the copyright etc... */
X
X    if( WIN_BASE == WIN_ERR )
X	WIN_BASE = amii_create_nhwindow( NHW_BASE );
X    amii_clear_nhwindow( WIN_BASE );
X    amii_putstr( WIN_BASE, 0, "" );
X    amii_putstr( WIN_BASE, 0, "" );
X    amii_putstr( WIN_BASE, 0, "" );
X    amii_putstr( WIN_BASE, 0,
X      "NetHack, Copyright 1985, 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993.");
X    amii_putstr( WIN_BASE, 0,
X	"         By Stichting Mathematisch Centrum and M. Stephenson.");
X    amii_putstr( WIN_BASE, 0, "         See license for details.");
X    amii_putstr( WIN_BASE, 0, "");
X
X    Initialized = 1;
X}
X
X#ifdef COM_COMPL
X/* Read in an extended command - doing command line completion for
X * when enough characters have been entered to make a unique command.
X */
Xvoid
Xamii_get_ext_cmd(bufp)
Xregister char *bufp;
X{
X    register char *obufp = bufp;
X    register int c;
X    int com_index, oindex;
X    struct WinDesc *cw;
X    struct Window *w;
X    int colx;
X
X    if( WIN_MESSAGE == WIN_ERR || ( cw = wins[ WIN_MESSAGE ] ) == NULL )
X	panic(winpanicstr, WIN_MESSAGE, "get_ext_cmd");
X    amii_clear_nhwindow( NHW_MESSAGE );
X    pline("# ");
X    colx = 3;
X    w = cw->win;
X
X    while((c = WindowGetchar()) != EOF)
X    {
X	amii_curs( WIN_MESSAGE, colx, 0 );
X	if(c == '?' )
X	{
X	    int win, i, sel;
X	    char buf[ 100 ];
X
X	    win = amii_create_nhwindow( NHW_MENU );
X	    amii_start_menu( win );
X
X	    for( i = 0; extcmdlist[ i ].ef_txt != NULL; ++i )
X	    {
X		sprintf( buf, "%-10s - %s ",
X			 extcmdlist[ i ].ef_txt,
X			 extcmdlist[ i ].ef_desc );
X		amii_add_menu( win, extcmdlist[i].ef_txt[0], 0, buf );
X	    }
X
X	    amii_end_menu( win, i, "\33", NULL );
X	    sel = amii_select_menu( win );
X	    amii_destroy_nhwindow( win );
X
X	    if( sel == '\33' )
X	    {
X		*obufp = '\33';
X		obufp[ 1 ] = 0;
X	    }
X	    else
X	    {
X		for( i = 0; extcmdlist[ i ].ef_txt != NULL; ++i )
X		{
X		    if( sel == extcmdlist[i].ef_txt[0] )
X			break;
X		}
X
X		/* copy in the text */
X		amii_clear_nhwindow( WIN_MESSAGE );
X		strcpy( obufp, extcmdlist[ i ].ef_txt );
X		colx = 0;
X		pline( "# " );
X		pline( obufp );
X		bufp = obufp + 2;
X	    }
X	    return;
X	}
X	else if(c == '\033')
X	{
X	    *obufp = c;
X	    obufp[1] = 0;
X	    return;
X	}
X	else if(c == '\b')
X	{
X	    if(bufp != obufp)
X	    {
X		bufp--;
X		amii_curs( WIN_MESSAGE, --colx, 0);
X		Text( w->RPort, spaces, 1 );
X		amii_curs( WIN_MESSAGE, colx, 0);
X	    }
X	    else
X		DisplayBeep( NULL );
X	}
X	else if( c == '\n' || c == '\r' )
X	{
X	    *bufp = 0;
X	    return;
X	}
X	else if(' ' <= c && c < '\177')
X	{
X		/* avoid isprint() - some people don't have it
X		   ' ' is not always a printing char */
X	    *bufp = c;
X	    bufp[1] = 0;
X	    oindex = 0;
X	    com_index = -1;
X
X	    while(extcmdlist[oindex].ef_txt != NULL)
X	    {
X		if(!strncmpi(obufp, extcmdlist[oindex].ef_txt, strlen(obufp)))
X		{
X		    if(com_index == -1) /* No matches yet*/
X			com_index = oindex;
X		    else /* More than 1 match */
X			com_index = -2;
X		}
X		oindex++;
X	    }
X
X	    if(com_index >= 0 && *obufp )
X	    {
X		Strcpy(obufp, extcmdlist[com_index].ef_txt);
X		/* finish printing our string */
X		Text( w->RPort, bufp, strlen( bufp ) );
X		amii_curs( WIN_MESSAGE, colx += strlen( bufp ), 0);
X		bufp = obufp; /* reset it */
X		if(strlen(obufp) < BUFSZ-1 && strlen(obufp) < COLNO)
X		    bufp += strlen(obufp);
X	    }
X	    else
X	    {
X		Text( w->RPort, bufp, strlen( bufp ) );
X		amii_curs( WIN_MESSAGE, colx += strlen( bufp ), 0);
X		if(bufp-obufp < BUFSZ-1 && bufp-obufp < COLNO)
X		    bufp++;
X	    }
X	}
X	else if(c == ('X'-64) || c == '\177')
X	{
X	    colx = 0;
X	    amii_clear_nhwindow( WIN_MESSAGE );
X	    pline( "# " );
X	    bufp = obufp;
X	} else
X	    DisplayBeep( NULL );
X    }
X    *bufp = 0;
X    return;
X}
X#endif /* COM_COMPL */
X
X#ifdef WINDOW_YN
XSHORT Ask_BorderVectors1[] = { 0,0, 29,0, 29,11, 0,11, 0,0 };
Xstruct Border Ask_Border1 = { -1,-1, 3,0,JAM1, 5, Ask_BorderVectors1, NULL };
Xstruct IntuiText Ask_IText1 = { 3,0,JAM2, 2,1, NULL, "(?)", NULL };
X
Xstruct Gadget Ask_Gadget1 = {
X    NULL, 9,4, 28,10, NULL, RELVERIFY, BOOLGADGET, (APTR)&Ask_Border1,
X    NULL, &Ask_IText1, NULL, NULL, NULL, NULL
X};
X
X#define Ask_GadgetList1 Ask_Gadget1
X
Xstruct IntuiText Ask_IText2 = { 1,0,JAM2, 44,5, NULL, NULL, NULL };
X
X#define Ask_IntuiTextList1 Ask_IText2
X
Xstruct NewWindow Ask_Window = {
X    75,85, 524,18, 0,1, GADGETUP+VANILLAKEY, ACTIVATE+NOCAREREFRESH,
X    &Ask_Gadget1, NULL, NULL, NULL, NULL, 5,5, -1,-1, CUSTOMSCREEN
X};
X#endif
X
X/* Ask a question and get a response */
X
Xchar amii_yn_function( prompt, resp, def )
X    const char *prompt,*resp;
X    char def;
X{
X    char ch;
X#ifndef WINDOW_YN
X    char buf[ 80 ];
X
X    if( def && def!='q')
X    {
X	sprintf( buf, "%s [%c] ", prompt, def );
X	amii_addtopl( buf );
X    } else {
X	amii_addtopl( prompt );
X    }
X
X    cursor_on( WIN_MESSAGE );
X    do {
X	ch = WindowGetchar();
X	if( ch == '\33' )
X	    break;
X	else if( def && ( ch == '\n' || ch == '\r' ) )
X	{
X	    ch = def;
X	    break;
X	}
X    } while( resp && *resp && index( resp, ch ) == 0 );
X
X    cursor_off( WIN_MESSAGE );
X    if( ch == '\33' )
X    {
X	/*amii_addtopl( " you change your mind..." );*/
X	ch = 0;
X    }
X    /* Try this to make topl behave more appropriately? */
X    clear_nhwindow( WIN_MESSAGE );
X#else
X    struct Window *cwin;
X    struct IntuiMessage *imsg;
X    int aredone = 0, xcor;
X    struct Gadget *gd;
X    char buf[ 4 ];
X
X    *StrString = 0;
X
X    Ask_Window.Screen = HackScreen;
X    Ask_IText1.IText = buf;
X    Ask_IText2.IText = prompt;
X    if( def )
X    {
X	sprintf( buf, "[%c]", def );
X	Ask_Window.FirstGadget = &Ask_Gadget1;
X	Ask_IText2.LeftEdge = 44;
X    }
X    else
X    {
X	Ask_Window.FirstGadget = NULL;
X	Ask_IText2.LeftEdge = 9;
X    }
X
X    /* Use this RPort to get needed dimensions */
X
X    if( cwin = wins[WIN_MAP]->win )
X    {
X    Ask_IText1.LeftEdge =
X	(Ask_Gadget1.Width - cwin->BorderLeft - cwin->BorderRight) / 2;
X    Ask_Window.Width =
X	 Ask_IText2.LeftEdge + (5 + strlen( prompt )) * txwidth;
X    xcor = Ask_IText2.LeftEdge + (2 + strlen( prompt )) * txwidth;
X    }
X
X    if( ( cwin = OpenShWindow( (void *)&Ask_Window ) ) == NULL )
X	return( 0 );
X
X    PrintIText( cwin->RPort, &Ask_IntuiTextList1, 0, 0 );
X
X    while( !aredone )
X    {
X	WaitPort( cwin->UserPort );
X	while( ( imsg = (void *) GetMsg( cwin->UserPort ) ) != NULL )
X	{
X	    switch( imsg->Class )
X	    {
X		case VANILLAKEY:
X		    Move( cwin->RPort, xcor,
X			Ask_IText2.TopEdge + txheight - 1 );
X		    ch = imsg->Code;
X		    if( ch != '\33' )
X		    {
X			Text( cwin->RPort, &ch, 1 );
X			if( resp == NULL || *resp == 0 ||
X							index( resp, ch ) )
X			{
X			    aredone = 1;
X			    Delay( 45 );
X			}
X			else
X			    DisplayBeep( NULL );
X		    }
X		    else
X		    {
X			aredone = 1;
X		    }
X		    break;
X
X		case GADGETUP:
X		    gd = (struct Gadget *) imsg->IAddress;
X		    switch( gd->GadgetID )
X		    {
X			case 1:
X			    ch = def;
X			    aredone = 1;
X			    break;
X		    }
X		    break;
X	    }
X	    ReplyMsg( (struct Message *) imsg );
X	}
X    }
X
X    CloseShWindow( cwin );
X#endif
X    return( ch );
X}
X
X/* Add a line in the message window */
X
Xvoid
Xamii_addtopl(s)
X    const char *s;
X{
X    amii_putstr(WIN_MESSAGE,0,s);   /* is this right? */
X}
X
Xvoid
XTextSpaces( rp, nr )
X    struct RastPort *rp;
X    int nr;
X{
X    if( nr < 1 )
X	return;
X
X    while (nr > sizeof(spaces) - 1)
X    {
X	Text(rp, spaces, (long)sizeof(spaces) - 1);
X	nr -= sizeof(spaces) - 1;
X    }
X    if (nr > 0)
X	Text(rp, spaces, (long)nr);
X}
X
X/* Put a string into the indicated window using the indicated attribute */
X
Xvoid
Xamii_putstr(window,attr,str)
X    winid window;
X    int attr;
X    const char *str;
X{
X    struct Window *w;
X    register struct WinDesc *cw;
X    register char *ob;
X    int i, j, n0;
X
X    /* Always try to avoid a panic when there is no window */
X    if( window == WIN_ERR )
X    {
X	window = WIN_BASE;
X	if( window == WIN_ERR )
X	    window = WIN_BASE = amii_create_nhwindow( NHW_BASE );
X    }
X
X    if( window == WIN_ERR || ( cw = wins[window] ) == NULL )
X    {
X	/* tty does this differently - is this OK? */
X	flags.window_inited=0;
X	panic(winpanicstr,window, "putstr");
X    }
X
X    w = cw->win;
X
X    if(!str)return;
X    amiIDisplay->lastwin=window;    /* do we care??? */
X
X    /* NHW_MENU windows are not opened immediately, so check if we
X     * have the window pointer yet
X     */
X
X    if( w )
X    {
X	/* Force the drawing mode and pen colors */
X
X	SetDrMd( w->RPort, JAM2 );
X	if( cw->type == NHW_STATUS )
X	    SetAPen( w->RPort, attr ? C_BLUE : C_CYAN );
X	else if( cw->type == NHW_MESSAGE )
X	    SetAPen( w->RPort, attr ? C_RED : C_WHITE );
X	else
X	    SetAPen( w->RPort, attr ? C_WHITE : C_RED );
X	SetBPen( w->RPort, C_BLACK );
X    }
X    else if( cw->type != NHW_MENU && cw->type != NHW_TEXT )
X    {
X	panic( "NULL window pointer in putstr 2" );
X    }
X
X    /* Okay now do the work for each type */
X
X    switch(cw->type)
X    {
X#define MORE_FUDGE  10  /* 8 for --more--, 1 for preceeding sp, 1 for */
X		/* putstr pad */
X    case NHW_MESSAGE:
X	strncpy( toplines, str, sizeof( toplines ) );
X	toplines[ sizeof( toplines ) - 1 ] = 0;
X	    /* Needed for initial message to be visible */
X	if( cw->curx == -1 )
X	{
X	    amii_curs( WIN_MESSAGE, 1, 0 );
X	    cw->curx = 0;
X	}
X
X	if(strlen(str) >= (cw->cols-MORE_FUDGE))
X	{
X	    int i;
X	    char *p;
X
X	    while( strlen( str ) >= (cw->cols-MORE_FUDGE) )
X	    {
X		for(p=(&str[ cw->cols ])-MORE_FUDGE; !isspace(*p) && p != str;)
X		{
X		    --p;
X		}
X		if( p == str )
X		    p = &str[ cw->cols ];
X		outsubstr( cw, str, i = (long)p-(long)str );
X		cw->curx += i;
X		amii_cl_end( cw, cw->curx );
X		str = p+1;
X	    }
X	    if( *str )
X	    {
X		outsubstr( cw, str, i = strlen( str ) );
X		cw->curx += i;
X		amii_cl_end( cw, cw->curx );
X	    }
X	}
X	else
X	{
X	    outsubstr( cw, str, i = strlen( str ) );
X	    cw->curx += i;
X	    amii_cl_end( cw, cw->curx );
X	}
X
X	    /* If used all of history lines, move them down */
X
X	    if( cw->maxrow == flags.msg_history )
X	    {
X		if( cw->data[ 0 ] )
X		    free( cw->data[ 0 ] );
X		memcpy( cw->data, &cw->data[ 1 ],
X		    ( flags.msg_history - 1 ) * sizeof( char * ) );
X		cw->data[ flags.msg_history - 1 ] =
X				(char *) alloc( strlen( toplines ) + 1 );
X		strcpy( cw->data[ flags.msg_history - 1 ], toplines );
X	    }
X	    else
X	    {
X		/* Otherwise, allocate a new one and copy the line in */
X		cw->data[ cw->maxrow ] = (char *)
X					    alloc( strlen( toplines ) + 1 );
X		strcpy( cw->data[ cw->maxrow++ ], toplines );
X	    }
X	    cw->maxcol = cw->maxrow;
X	    break;
X
X    case NHW_STATUS:
X	if( cw->data[ cw->cury ] == NULL )
X	    panic( "NULL pointer for status window" );
X	ob = &cw->data[cw->cury][j = cw->curx];
X	if(flags.botlx) *ob = 0;
X
X	    /* Display when beam at top to avoid flicker... */
X	WaitTOF();
X	Text(w->RPort,str,strlen(str));
X	if( cw->cols > strlen( str ) )
X	    TextSpaces( w->RPort, cw->cols - strlen( str ) );
X
X	(void) strncpy(cw->data[cw->cury], str, cw->cols );
X	cw->data[cw->cury][cw->cols-1] = '\0'; /* null terminate */
X	cw->cury = (cw->cury+1) % 2;
X	cw->curx = 0;
X	break;
X
X    case NHW_MAP:
X    case NHW_BASE:
X	amii_curs(window, cw->curx+1, cw->cury);
X	Text(w->RPort,str,strlen(str));
X	cw->curx = 0;
X	    /* CR-LF is automatic in these windows */
X	cw->cury++;
X	break;
X
X    case NHW_MENU:
X    case NHW_TEXT:
X
X	/* always grows one at a time, but alloc 12 at a time */
X
X	if( cw->cury >= cw->rows || !cw->data ) {
X	    char **tmp;
X
X		/* Allocate 12 more rows */
X	    cw->rows += 12;
X	    tmp = (char**) alloc(sizeof(char*) * cw->rows);
X
X		/* Copy the old lines */
X	    for(i=0; i<cw->cury; i++)
X		tmp[i] = cw->data[i];
X
X	    if( cw->data )
X		free( cw->data );
X
X	    cw->data = tmp;
X
X		/* Null out the unused entries. */
X	    for(i=cw->cury; i<cw->rows; i++)
X		cw->data[i] = 0;
X	}
X
X	if( !cw->data )
X	    panic("no data storage");
X
X	    /* Shouldn't need to do this, but... */
X
X	if( cw->data && cw->data[cw->cury] )
X	    free( cw->data[cw->cury] );
X
X	n0 = strlen(str)+1;
X	cw->data[cw->cury] = (char*) alloc(n0+SOFF);
X
X	    /* avoid nuls, for convenience */
X	cw->data[cw->cury][VATTR] = attr+1;
X	cw->data[cw->cury][SEL_ITEM] = 0;
X	Strcpy( cw->data[cw->cury] + SOFF, str);
X
X	if(n0 > cw->maxcol) cw->maxcol = n0;
X	if(++cw->cury > cw->maxrow) cw->maxrow = cw->cury;
X	break;
X
X    default:
X	panic("Invalid or unset window type in putstr()");
X    }
X}
X
END_OF_FILE
if test 45206 -ne `wc -c <'sys/amiga/winami.c1'`; then
    echo shar: \"'sys/amiga/winami.c1'\" unpacked with wrong size!
fi
# end of 'sys/amiga/winami.c1'
fi
echo shar: End of archive 20 \(of 108\).
cp /dev/null ark20isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \
21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \
41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 \
61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 \
81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 \
101 102 103 104 105 106 107 108 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 108 archives.
    echo "Now execute 'rebuild.sh'"
    rm -f ark10[0-8]isdone ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
