Path: uunet!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v16i017:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Part17/108
Message-ID: <4300@master.CNA.TEK.COM>
Date: 28 Jan 93 19:14:08 GMT
Sender: news@master.CNA.TEK.COM
Lines: 2329
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1573

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 16, Issue 17
Archive-name: nethack31/Part17
Supersedes: nethack3p9: Volume 10, Issue 46-102
Environment: Amiga, Atari, Mac, MS-DOS, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 17 (of 108)."
# Contents:  src/steal.c util/makedefs.c
# Wrapped by billr@saab on Wed Jan 27 16:08:51 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'src/steal.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/steal.c'\"
else
echo shar: Extracting \"'src/steal.c'\" \(8343 characters\)
sed "s/^X//" >'src/steal.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)steal.c	3.1	92/10/14	*/
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include "hack.h"
X
XSTATIC_DCL int NDECL(stealarm);
X
X#ifdef OVLB
Xstatic const char * FDECL(equipname, (struct obj *));
X
Xstatic const char *
Xequipname(otmp)
X
X	register struct obj *otmp;
X{
X
X	return (
X#ifdef TOURIST
X		(otmp == uarmu) ? "shirt" :
X#endif
X		(otmp == uarmf) ? "boots" :
X		(otmp == uarms) ? "shield" :
X		(otmp == uarmg) ? "gloves" :
X		(otmp == uarmc) ? "cloak" :
X		(otmp == uarmh) ? "helmet" : "armor");
X}
X
Xlong		/* actually returns something that fits in an int */
Xsomegold(){
X#ifdef LINT	/* long conv. ok */
X	return(0L);
X#else
X	return (long)( (u.ugold < 100) ? u.ugold :
X		(u.ugold > 10000) ? rnd(10000) : rnd((int) u.ugold) );
X#endif
X}
X
Xvoid
Xstealgold(mtmp)
Xregister struct monst *mtmp;
X{
X	register struct obj *gold = g_at(u.ux, u.uy);
X	register long tmp;
X
X	if (gold && ( !u.ugold || gold->quan > u.ugold || !rn2(5))) {
X	    mtmp->mgold += gold->quan;
X	    delobj(gold);
X	    newsym(u.ux, u.uy);
X	    pline("%s quickly snatches some gold from between your %s!",
X		    Monnam(mtmp), makeplural(body_part(FOOT)));
X	    if(!u.ugold || !rn2(5)) {
X		rloc(mtmp);
X		mtmp->mflee = 1;
X	    }
X	} else if(u.ugold) {
X	    u.ugold -= (tmp = somegold());
X	    Your("purse feels lighter.");
X	    mtmp->mgold += tmp;
X	    rloc(mtmp);
X	    mtmp->mflee = 1;
X	    flags.botl = 1;
X	}
X}
X
X/* steal armor after you finish taking it off */
Xunsigned int stealoid;		/* object to be stolen */
Xunsigned int stealmid;		/* monster doing the stealing */
X
XSTATIC_OVL int
Xstealarm(){
X	register struct monst *mtmp;
X	register struct obj *otmp;
X
X	for(otmp = invent; otmp; otmp = otmp->nobj)
X	  if(otmp->o_id == stealoid) {
X	    for(mtmp = fmon; mtmp; mtmp = mtmp->nmon)
X	      if(mtmp->m_id == stealmid) {
X		  if(otmp->unpaid) 
X		       subfrombill(otmp, shop_keeper(*u.ushops));
X		  freeinv(otmp);
X		  pline("%s steals %s!", Monnam(mtmp), doname(otmp));
X		  mpickobj(mtmp,otmp);
X		  mtmp->mflee = 1;
X		  rloc(mtmp);
X		break;
X	      }
X	    break;
X	  }
X	stealoid = 0;
X	return 0;
X}
X
X/* Returns 1 when something was stolen (or at least, when N should flee now)
X * Returns -1 if the monster died in the attempt
X * Avoid stealing the object stealoid
X */
Xint
Xsteal(mtmp)
Xstruct monst *mtmp;
X{
X	register struct obj *otmp;
X	register int tmp;
X	register int named = 0;
X
X	/* the following is true if successful on first of two attacks. */
X	if(!monnear(mtmp, u.ux, u.uy)) return(0);
X
X	if(!invent
X#ifdef POLYSELF
X		   || (inv_cnt() == 1 && uskin)
X#endif
X						){
X	    /* Not even a thousand men in armor can strip a naked man. */
X	    if(Blind)
X	      pline("Somebody tries to rob you, but finds nothing to steal.");
X	    else
X	      pline("%s tries to rob you, but she finds nothing to steal!",
X		Monnam(mtmp));
X	    return(1);	/* let her flee */
X	}
X
X	if(Adornment & LEFT_RING) {
X	    otmp = uleft;
X	    goto gotobj;
X	} else if(Adornment & RIGHT_RING) {
X	    otmp = uright;
X	    goto gotobj;
X	}
X
X	tmp = 0;
X	for(otmp = invent; otmp; otmp = otmp->nobj)
X	    if((!uarm || otmp != uarmc)
X#ifdef POLYSELF
X					&& otmp != uskin
X#endif
X							)
X		tmp += ((otmp->owornmask &
X			(W_ARMOR | W_RING | W_AMUL | W_TOOL)) ? 5 : 1);
X	tmp = rn2(tmp);
X	for(otmp = invent; otmp; otmp = otmp->nobj)
X	    if((!uarm || otmp != uarmc)
X#ifdef POLYSELF
X					&& otmp != uskin
X#endif
X							)
X		if((tmp -= ((otmp->owornmask &
X			(W_ARMOR | W_RING | W_AMUL | W_TOOL)) ? 5 : 1)) < 0)
X			break;
X	if(!otmp) {
X		impossible("Steal fails!");
X		return(0);
X	}
X	/* can't steal gloves while wielding - so steal the wielded item. */
X	if (otmp == uarmg && uwep)
X	    otmp = uwep;
X	/* can't steal armor while wearing cloak - so steal the cloak. */
X	else if(otmp == uarm && uarmc) otmp = uarmc;
X#ifdef TOURIST
X	else if(otmp == uarmu && uarmc) otmp = uarmc;
X	else if(otmp == uarmu && uarm) otmp = uarm;
X#endif
Xgotobj:
X	if(otmp->o_id == stealoid) return(0);
X
X#ifdef WALKIES
X	if(otmp->otyp == LEASH && otmp->leashmon) o_unleash(otmp);
X#endif
X
X	if((otmp->owornmask & (W_ARMOR | W_RING | W_AMUL | W_TOOL))){
X		switch(otmp->oclass) {
X		case TOOL_CLASS:
X			Blindf_off(otmp);
X			break;
X		case AMULET_CLASS:
X			Amulet_off();
X			break;
X		case RING_CLASS:
X			Ring_gone(otmp);
X			break;
X		case ARMOR_CLASS:
X			/* Stop putting on armor which has been stolen. */
X			if (donning(otmp)) {
X			  cancel_don();
X			  if (otmp == uarm)  (void) Armor_off();
X			  /* else if (otmp == uarmc) (void) Cloak_off(); */
X			  else if (otmp == uarmf) (void) Boots_off();
X			  else if (otmp == uarmg) (void) Gloves_off();
X			  else if (otmp == uarmh) (void) Helmet_off();
X			  /* else if (otmp == uarms) (void) Shield_off(); */
X			  else setworn((struct obj *)0, otmp->owornmask & W_ARMOR);
X			  break;
X			}
X		    { int curssv = otmp->cursed;
X			otmp->cursed = 0;
X			stop_occupation();
X			if(flags.female)
X			    pline("%s charms you.  You gladly %s your %s.",
X				  Blind ? "She" : Monnam(mtmp),
X				  curssv ? "let her take" : "hand over",
X				  equipname(otmp));
X			else
X			    pline("%s seduces you and %s off your %s.",
X				  Blind ? "It" : Adjmonnam(mtmp, "beautiful"),
X				  curssv ? "helps you to take" : "you start taking",
X				  equipname(otmp));
X			named++;
X			/* the following is to set multi for later on */
X			nomul(-objects[otmp->otyp].oc_delay);
X
X			if (otmp == uarm)  (void) Armor_off();
X			else if (otmp == uarmc) (void) Cloak_off();
X			else if (otmp == uarmf) (void) Boots_off();
X			else if (otmp == uarmg) (void) Gloves_off();
X			else if (otmp == uarmh) (void) Helmet_off();
X			else if (otmp == uarms) (void) Shield_off();
X			else setworn((struct obj *)0, otmp->owornmask & W_ARMOR);
X			otmp->cursed = curssv;
X			if(multi < 0){
X				/*
X				multi = 0;
X				nomovemsg = 0;
X				afternmv = 0;
X				*/
X				stealoid = otmp->o_id;
X				stealmid = mtmp->m_id;
X				afternmv = stealarm;
X				return(0);
X			}
X			break;
X		    }
X		default:
X			impossible("Tried to steal a strange worn thing.");
X		}
X	}
X	else if(otmp == uwep) uwepgone();
X
X	if(otmp == uball) unpunish();
X
X	freeinv(otmp);
X	pline("%s stole %s.", named ? "She" : Monnam(mtmp), doname(otmp));
X	(void) snuff_candle(otmp);
X	mpickobj(mtmp,otmp);
X	if (otmp->otyp == CORPSE && otmp->corpsenm == PM_COCKATRICE
X	    && !resists_ston(mtmp->data)) {
X	    pline("%s turns to stone.", Monnam(mtmp));
X	    stoned = TRUE;
X	    xkilled(mtmp, 0);
X	    return -1;
X	}
X	return((multi < 0) ? 0 : 1);
X}
X
X#endif /* OVLB */
X#ifdef OVL1
X
Xvoid
Xmpickobj(mtmp,otmp)
Xregister struct monst *mtmp;
Xregister struct obj *otmp;
X{
X	otmp->nobj = mtmp->minvent;
X	mtmp->minvent = otmp;
X}
X
X#endif /* OVL1 */
X#ifdef OVLB
X
Xvoid
Xstealamulet(mtmp)
Xregister struct monst *mtmp;
X{
X	register struct obj *otmp;
X
X	for(otmp = invent; otmp; otmp = otmp->nobj) {
X	    if(otmp->otyp == AMULET_OF_YENDOR ||
X	       (otmp->otyp == FAKE_AMULET_OF_YENDOR && !mtmp->iswiz)) {
X		/* might be an imitation one */
X		setnotworn(otmp);
X		freeinv(otmp);
X		mpickobj(mtmp,otmp);
X		pline("%s stole %s!", Monnam(mtmp), doname(otmp));
X		if (can_teleport(mtmp->data)) rloc(mtmp);
X		return;
X	    }
X	}
X}
X
X#endif /* OVLB */
X#ifdef OVL0
X
X/* release the objects the killed animal was carrying */
Xvoid
Xrelobj(mtmp,show,is_pet)
Xregister struct monst *mtmp;
Xregister int show;
Xboolean is_pet;		/* If true, pet should keep wielded weapon */
X{
X	register struct obj *otmp, *otmp2;
X	register int omx = mtmp->mx, omy = mtmp->my;
X
X#ifdef MUSE
X	otmp2 = otmp = 0;
X	if (is_pet) {
X		sort_mwep(mtmp);
X		if ((otmp2 = MON_WEP(mtmp))) {
X			otmp = otmp2->nobj;
X			otmp2->nobj = 0;
X		}
X	}
X	if (!otmp2)
X#endif
X	{	otmp = mtmp->minvent;
X		mtmp->minvent = 0;
X	}
X
X	for (; otmp; otmp = otmp2) {
X#ifdef MUSE
X		if (otmp->owornmask) {
X			mtmp->misc_worn_check &= ~(otmp->owornmask);
X			otmp->owornmask = 0L;
X		}
X#endif
X		otmp2 = otmp->nobj;
X		if (is_pet && cansee(omx, omy) && flags.verbose)
X			pline("%s drops %s.", Monnam(mtmp),
X					distant_name(otmp, doname));
X		if (flooreffects(otmp, omx, omy, "fall")) continue;
X		place_object(otmp, omx, omy);
X		otmp->nobj = fobj;
X		fobj = otmp;
X		stackobj(fobj);
X	}
X	if (mtmp->mgold) {
X		register long g = mtmp->mgold;
X		mkgold(g, omx, omy);
X		if (is_pet && cansee(omx, omy) && flags.verbose)
X			pline("%s drops %ld gold piece%s.", Monnam(mtmp),
X				g, plur(g));
X		mtmp->mgold = 0L;
X	}
X	if (show & cansee(omx, omy))
X		newsym(omx, omy);
X}
X
X#endif /* OVL0 */
X
X/*steal.c*/
END_OF_FILE
if test 8343 -ne `wc -c <'src/steal.c'`; then
    echo shar: \"'src/steal.c'\" unpacked with wrong size!
fi
# end of 'src/steal.c'
fi
if test -f 'util/makedefs.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'util/makedefs.c'\"
else
echo shar: Extracting \"'util/makedefs.c'\" \(45073 characters\)
sed "s/^X//" >'util/makedefs.c' <<'END_OF_FILE'
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* Copyright (c) M. Stephenson, 1990, 1991.			  */
X/* Copyright (c) Dean Luick, 1990.				  */
X/* NetHack may be freely redistributed.  See license for details. */
X/* makedefs.c - NetHack version 3.1 */
X
X#define	MAKEDEFS_C	/* use to conditionally include file sections */
X/* #define DEBUG /* uncomment for debugging info */
X
X#include "config.h"
X#include "permonst.h"
X#include "objclass.h"
X#include "monsym.h"
X#include "artilist.h"
X
X#ifdef MAC
X# ifdef applec	/* Means the MPW compiler, I hope */
X#  define MPWTOOL
X#  include <CursorCtl.h>
X# else		/* MAC without MPWTOOL */
X#  define MACsansMPWTOOL
X# endif
X#include <string.h>
X#include <ctype.h>
X#endif /* MAC */
X
X#ifndef MPWTOOL
X# define SpinCursor(x)
X#endif
X
X#define Fprintf	(void) fprintf
X#define Fclose	(void) fclose
X#define Unlink	(void) unlink
X#if !defined(AMIGA) || defined(AZTEC_C)
X#define rewind(fp) fseek((fp),0L,SEEK_SET)	/* guarantee a return value */
X#endif
X
X#ifdef NULL
X#undef NULL
X#endif
X#define NULL	((char *)0)
X
X#if !defined(LINT) && !defined(GCC_WARN)
Xstatic	const char	SCCS_Id[] = "@(#)makedefs.c\t3.1\t93/01/20";
X#endif
X
X#ifdef MICRO
X# undef	exit
Xextern void FDECL(exit, (int));
X#endif
X
X#define WRMODE  "w+"
X#define RDMODE  "r"
X/* the quest.dat file is binary, while everything else is text... */
X#if defined(MICRO) && !defined(AMIGA)
X# define WRBMODE "w+b"
X#else
X# define WRBMODE "w+"
X#endif
X
X#ifndef SEEK_SET
X# define SEEK_SET 0
X#endif
X#ifndef SEEK_END
X# define SEEK_END 2
X#endif
X
X	/* names of files to be generated */
X#define DATE_FILE	"date.h"
X#define MONST_FILE	"pm.h"
X#define ONAME_FILE	"onames.h"
X#define OPTIONS_FILE	"options"
X#define ORACLE_FILE	"oracles"
X#define DATA_FILE	"data"
X#define RUMOR_FILE	"rumors"
X#define DGN_I_FILE	"dungeon.def"
X#define DGN_O_FILE	"dungeon.pdf"
X#define MON_STR_C	"monstr.c"
X#define QTXT_I_FILE	"quest.txt"
X#define QTXT_O_FILE	"quest.dat"
X#define VIS_TAB_H	"vis_tab.h"
X#define VIS_TAB_C	"vis_tab.c"
X	/* locations for those files */
X#ifdef AMIGA
X# define INCLUDE_TEMPLATE	"Incl:t.%s"
X# define SOURCE_TEMPLATE	"NHS:%s"
X# define DATA_TEMPLATE		"Dat:%s"
X#else
X# ifdef MAC
X#   define INCLUDE_TEMPLATE	":include:%s"
X#   define SOURCE_TEMPLATE	":src:%s"
X#   define DATA_TEMPLATE	":dat:%s"
X# else /* MAC */
X#   define INCLUDE_TEMPLATE	"../include/%s"
X#   define SOURCE_TEMPLATE	"../src/%s"
X#   define DATA_TEMPLATE	"../dat/%s"
X# endif /* MAC */
X#endif	/* AMIGA */
X
Xstatic const char
X    *Dont_Edit_Code =
X	"/* This source file is generated by 'makedefs'.  Do not edit. */\n",
X    *Dont_Edit_Data =
X	"#\tThis data file is generated by 'makedefs'.  Do not edit. \n";
X
X/* definitions used for vision tables */
X#define TEST_WIDTH  COLNO
X#define TEST_HEIGHT ROWNO
X#define BLOCK_WIDTH (TEST_WIDTH + 10)
X#define BLOCK_HEIGHT TEST_HEIGHT	/* don't need extra spaces */
X#define MAX_ROW (BLOCK_HEIGHT + TEST_HEIGHT)
X#define MAX_COL (BLOCK_WIDTH + TEST_WIDTH)
X/* Use this as an out-of-bound value in the close table.  */
X#define CLOSE_OFF_TABLE_STRING "99,"	/* for the close table */
X#define FAR_OFF_TABLE_STRING "0xff,"	/* for the far table */
X
X#define sign(z) ((z) < 0 ? -1 : ((z) ? 1 : 0))
X#ifdef VISION_TABLES
Xstatic char xclear[MAX_ROW][MAX_COL];
X#endif
X/*-end of vision defs-*/
X
Xstatic char	in_line[256], filename[30];
X
X#ifdef MACsansMPWTOOL
Xvoid FDECL(macstart, (void));
Xint FDECL(main, (void));
X#else
Xint FDECL(main, (int, char **));
X#endif
Xint FDECL(do_makedefs, (int, char **));
Xvoid NDECL(do_objs);
Xvoid NDECL(do_data);
Xvoid NDECL(do_dungeon);
Xvoid NDECL(do_date);
Xvoid NDECL(do_options);
Xvoid NDECL(do_monstr);
Xvoid NDECL(do_permonst);
Xvoid NDECL(do_questtxt);
Xvoid NDECL(do_rumors);
Xvoid NDECL(do_oracles);
Xvoid NDECL(do_vision);
X
Xextern void NDECL(monst_init);		/* monst.c */
Xextern void NDECL(objects_init);	/* objects.c */
X
Xstatic char *FDECL(xcrypt, (const char *));
Xstatic int FDECL(check_control, (char *));
Xstatic char *FDECL(without_control, (char *));
Xstatic boolean FDECL(d_filter, (char *));
Xstatic boolean FDECL(h_filter, (char *));
Xstatic boolean FDECL(ranged_attk,(struct permonst*));
Xstatic int FDECL(mstrength,(struct permonst *));
X
X#ifdef MULDGN
Xstatic boolean FDECL(qt_comment, (char *));
Xstatic boolean FDECL(qt_control, (char *));
Xstatic int FDECL(get_hdr, (CHAR_P));
Xstatic boolean FDECL(known_id, (CHAR_P));
Xstatic boolean FDECL(new_id, (CHAR_P));
Xstatic boolean FDECL(known_msg, (CHAR_P, char *));
Xstatic void FDECL(new_msg, (char *));
Xstatic void FDECL(do_qt_control, (char *));
Xstatic void FDECL(do_qt_text, (char *));
Xstatic void NDECL(adjust_qt_hdrs);
Xstatic void NDECL(put_qt_hdrs);
X#endif
X
X#ifdef VISION_TABLES
Xstatic void NDECL(H_close_gen);
Xstatic void NDECL(H_far_gen);
Xstatic void NDECL(C_close_gen);
Xstatic void NDECL(C_far_gen);
Xstatic int FDECL(clear_path, (int,int,int,int));
X#endif
X
Xchar * FDECL(tmpdup, (const char *));
Xchar * FDECL(limit, (char *,int));
X
X/* input, output, tmp */
X
XFILE	*ifp, *ofp, *tfp;
X
X#ifdef MACsansMPWTOOL
Xchar mac_opt;
X
Xvoid
Xmacstart()
X{
X	static char buf[100];
X	static char *ptr = NULL;
X
Xagain :
X	if (!ptr || !*ptr) {
X		Fprintf(stderr, "Options: otdemvpqrhz\n");
X		buf[0] = 0;
X		fgets(buf, 100, stdin);
X		ptr = buf;
X	}
X
X	do {
X		mac_opt = *ptr++;
X	} while (mac_opt && isspace(mac_opt));
X
X	if (!mac_opt) {
X		Fprintf(stderr, "Makedefs done.\n");
X		exit(0);
X	}
X}
X#endif /* MAC */
X
X
Xint
X#ifdef MACsansMPWTOOL
Xmain(void)
X{
X	int argc;
X	char **argv;
X#else /* ! MAC */
Xmain(argc, argv)
Xint	argc;
Xchar	*argv[];
X{
X#endif /* MAC */
X	/* Note:  these initializers don't do anything except guarantee that
X		we're linked properly.
X	*/
X	monst_init();
X	objects_init();
X
X#ifdef MACsansMPWTOOL
X	while (1) {
X		macstart();
X		do_makedefs(argc, argv);
X	}
X#else
X	if (do_makedefs(argc, argv))
X		exit(1);
X#endif
X#ifndef VMS
X	return 0;
X#else
X	return 1;       /* vms success */
X#endif /*VMS*/
X}
X
Xint
Xdo_makedefs(arrgc, arrgv)
Xint	arrgc;
Xchar	*arrgv[];
X{
X#ifdef MACsansMPWTOOL
X	if (1) {
X		Fprintf(stderr, "makedefs -%c\n", mac_opt);
X		switch (mac_opt) {
X#else /* !MAC */
X	if (arrgc == 2) {
X	    char *option = arrgv[1];
X	    switch (option[1]) {
X#endif /* MAC */
X		case 'o':
X		case 'O':	do_objs();
X				break;
X		case 't':			/* this may go away... */
X		case 'T':	Fprintf(stderr,	"`-t' option is obsolete.\n");
X				break;
X		case 'd':
X		case 'D':	do_data();
X				break;
X		case 'e':
X		case 'E':	do_dungeon();
X				break;
X		case 'm':
X		case 'M':	do_monstr();
X				break;
X		case 'v':
X		case 'V':	do_date();
X				do_options();
X				break;
X		case 'p':
X		case 'P':	do_permonst();
X				break;
X		case 'q':
X		case 'Q':	do_questtxt();
X				break;
X		case 'r':
X		case 'R':	do_rumors();
X				break;
X		case 'h':
X		case 'H':	do_oracles();
X				break;
X		case 'z':
X		case 'Z':	do_vision();
X				break;
X
X		default:
X				Fprintf(stderr,	"Unknown option '%c'.\n",
X#ifdef MACsansMPWTOOL
X					mac_opt
X#else /* MAC */
X					option[1]
X#endif /* MAC */
X					);
X				(void) fflush(stderr);
X				return(1);
X	    }
X	    return 0;
X	} else {
X	    Fprintf(stderr, "Bad arg count (%d).\n", arrgc-1);
X	    (void) fflush(stderr);
X	    return 1;
X	}
X}
X
X
X/* trivial text encryption routine which can't be broken with `tr' */
Xstatic
Xchar *xcrypt(str)
Xconst char *str;
X{				/* duplicated in src/hacklib.c */
X	static char buf[BUFSZ];
X	register const char *p;
X	register char *q;
X	register int bitmask;
X
X	for (bitmask = 1, p = str, q = buf; *p; q++) {
X		*q = *p++;
X		if (*q & (32|64)) *q ^= bitmask;
X		if ((bitmask <<= 1) >= 32) bitmask = 1;
X	}
X	*q = '\0';
X	return buf;
X}
X
Xvoid
Xdo_rumors()
X{
X	char	infile[30];
X	long	true_rumor_size;
X
X	Sprintf(filename, DATA_TEMPLATE, RUMOR_FILE);
X	if (!(ofp = fopen(filename, WRMODE))) {
X		perror(filename);
X		exit(1);
X	}
X	Fprintf(ofp,Dont_Edit_Data);
X
X	Strcat(strcpy(infile, filename), ".tru");
X	if (!(ifp = fopen(infile, RDMODE))) {
X		perror(infile);
X		Fclose(ofp);
X		Unlink(filename);	/* kill empty output file */
X		exit(1);
X	}
X
X	/* get size of true rumors file */
X#ifndef VMS
X	(void) fseek(ifp, 0L, SEEK_END);
X	true_rumor_size = ftell(ifp);
X#else
X	/* seek+tell is only valid for stream format files; since rumors.%%%
X	   might be in record format, count the actual data bytes instead.
X	 */
X	true_rumor_size = 0;
X	while (fgets(in_line,sizeof(in_line),ifp) != NULL)
X		true_rumor_size += strlen(in_line);	/* includes newline */
X#endif /* VMS */
X	Fprintf(ofp,"%06lx\n", true_rumor_size);
X	(void) fseek(ifp, 0L, SEEK_SET);
X
X	/* copy true rumors */
X	while(fgets(in_line,sizeof(in_line),ifp) != NULL)
X		(void) fputs(xcrypt(in_line), ofp);
X
X	Fclose(ifp);
X	Strcat(strcpy(infile, filename), ".fal");
X	if (!(ifp = fopen(infile, RDMODE))) {
X		perror(infile);
X		Fclose(ofp);
X		Unlink(filename);	/* kill incomplete output file */
X		exit(1);
X	}
X
X	/* copy false rumors */
X	while(fgets(in_line,sizeof(in_line),ifp) != NULL)
X		(void) fputs(xcrypt(in_line), ofp);
X
X	Fclose(ifp);
X	Fclose(ofp);
X	return;
X}
X
Xvoid
Xdo_date()
X{
X	long	clocktim;
X	char	cbuf[30], *c;
X
X	Sprintf(filename, INCLUDE_TEMPLATE, DATE_FILE);
X	if (!(ofp = fopen(filename, WRMODE))) {
X		perror(filename);
X		exit(1);
X	}
X	Fprintf(ofp,"/*\tSCCS Id: @(#)date.h\t3.1\t92/01/04 */\n\n");
X	Fprintf(ofp,Dont_Edit_Code);
X
X#ifdef KR1ED
X	(void) time(&clocktim);
X	Strcpy(cbuf, ctime(&clocktim));
X#else
X	(void) time((time_t *)&clocktim);
X	Strcpy(cbuf, ctime((time_t *)&clocktim));
X#endif
X	for(c = cbuf; *c != '\n'; c++);	*c = 0; /* strip off the '\n' */
X	Fprintf(ofp,"#define BUILD_DATE \"%s\"\n", cbuf);
X	Fprintf(ofp,"#define BUILD_TIME (%ldL)\n", clocktim);
X#ifdef AMIGA
X	{
X	struct tm *tm = localtime((time_t *) &clocktim);
X	Fprintf(ofp,"#ifdef AMIGA\n");
X	Fprintf(ofp,"const char amiga_version_string[] = ");
X	Fprintf(ofp,"\"\\0$VER: NetHack %s (%d.%d.%d)\";\n",VERSION,tm->tm_mday,
X		tm->tm_mon+1,tm->tm_year);
X	Fprintf(ofp,"#endif\n");
X	}
X#endif
X	Fclose(ofp);
X	return;
X}
X
Xstatic const char *build_opts[] = {
X#ifdef AMIGA_WBENCH
X		"Amiga WorkBench support",
X#endif
X#ifdef ANSI_DEFAULT
X		"ANSI default terminal",
X#endif
X#ifdef ARMY
X		"armies",
X#endif
X#ifdef TEXTCOLOR
X		"color",
X#endif
X#ifdef COM_COMPL
X		"command line completion",
X#endif
X#ifdef COMPRESS
X		"compress bones/level/save files",
X#endif
X#ifdef ELBERETH
X		"Elbereth",
X#endif
X#ifdef EXP_ON_BOTL
X		"experience points on bottom line",
X#endif
X#ifdef EXPLORE_MODE
X		"explore mode",
X#endif
X#ifdef WALLIFIED_MAZE
X		"fancy mazes",
X#endif
X#ifdef MFLOPPY
X		"floppy drive support",
X#endif
X#ifdef TUTTI_FRUTTI
X		"fruits",
X#endif
X#ifdef KOPS
X		"Keystone Kops",
X#endif
X#ifdef WALKIES
X		"leashes",
X#endif
X#ifdef LOGFILE
X		"log file",
X#endif
X#ifdef MAIL
X		"mail daemon",
X#endif
X#ifdef MUSE
X		"monster item use",
X#endif
X#ifdef GNUDOS
X		"MSDOS protected mode",
X#endif
X#ifdef NEWS
X		"news file",
X#endif
X#ifdef OVERLAY
X		"overlays",
X#endif
X#ifdef MULDGN
X		"quest dungeon",
X#endif
X#ifdef REDO
X		"redoing commands",
X#endif
X#ifdef REINCARNATION
X		"rogue level",
X#endif
X#ifdef SCORE_ON_BOTL
X		"score on bottom line",
X#endif
X#ifdef CLIPPING
X		"screen clipping",
X#endif
X#ifdef SEDUCE
X		"seduction",
X#endif
X#ifdef POLYSELF
X		"self-polymorphing",
X#endif
X#ifdef SHELL
X		"shell command",
X#endif
X#ifdef SINKS
X		"sinks",
X#endif
X#ifdef SOUNDS
X		"sounds",
X#endif
X#ifdef SUSPEND
X		"suspend command",
X#endif
X#ifdef TERMINFO
X		"terminal info library",
X#else
X# if defined(TERMLIB) || (!defined(MICRO) && defined(TTY_GRAPHICS))
X		"terminal capability library",
X# endif
X#endif
X#ifdef TOURIST
X		"tourists",
X#endif
X#ifdef VISION_TABLES
X		"vision tables",
X#endif
X#ifdef WIZARD
X		"wizard mode",
X#endif
X#ifdef ZEROCOMP
X		"zero-compressed save files",
X#endif
X		"basic NetHack features"
X	};
X
Xstatic const char *window_opts[] = {
X#ifdef TTY_GRAPHICS
X		"traditional tty-based graphics",
X#endif
X#ifdef X11_GRAPHICS
X		"X11",
X#endif
X#ifdef MAC
X		"Mac",
X#endif
X#ifdef AMIGA_INTUITION
X		"Amiga Intuition",
X#endif
X		NULL
X	};
X
Xvoid
Xdo_options()
X{
X	register int i, length;
X	register const char *str, *indent = "    ";
X
X	Sprintf(filename, DATA_TEMPLATE, OPTIONS_FILE);
X	if (!(ofp = fopen(filename, WRMODE))) {
X		perror(filename);
X		exit(1);
X	}
X     /* Fprintf(ofp,Dont_Edit_Data); */
X	Fprintf(ofp,"\nOptions compiled into this version of NetHack:\n");
X
X	length = COLNO + 1;	/* force 1st item onto new line */
X	for (i = 0; i < SIZE(build_opts); i++) {
X	    str = build_opts[i];
X	    if (length + strlen(str) > COLNO - 5)
X		Fprintf(ofp,"\n%s", indent),  length = strlen(indent);
X	    else
X		Fprintf(ofp," "),  length++;
X	    Fprintf(ofp,"%s", str),  length += strlen(str);
X	    Fprintf(ofp,(i < SIZE(build_opts) - 1) ? "," : "."),  length++;
X	}
X
X	Fprintf(ofp,"\n\nSupported windowing systems:\n");
X
X	length = COLNO + 1;	/* force 1st item onto new line */
X	for (i = 0; i < SIZE(window_opts) - 1; i++) {
X	    str = window_opts[i];
X	    if (length + strlen(str) > COLNO - 5)
X		Fprintf(ofp,"\n%s", indent),  length = strlen(indent);
X	    else
X		Fprintf(ofp," "),  length++;
X	    Fprintf(ofp,"%s", str),  length += strlen(str);
X	    Fprintf(ofp, ","),  length++;
X	}
X	Fprintf(ofp, "\n%swith a default of %s.", indent, DEFAULT_WINDOW_SYS);
X	Fprintf(ofp,"\n\n");
X
X	Fclose(ofp);
X	return;
X}
X
X/* routine to decide whether to discard something from data.base */
Xstatic boolean
Xd_filter(line)
X    char *line;
X{
X    if (*line == '#') return TRUE;	/* ignore comment lines */
X#ifndef ARMY
X  { static int ignore_army = 0;
X
X    switch (ignore_army) {
X      case 0:   if (!strcmp(line, "*soldier")) ignore_army = 1;
X		break;		/* 0 => not in army related data */
X      case 1:   if (*line <= ' ') ignore_army = 2;
X		break;		/* 1 => in army name list */
X      case 2:   if (*line > ' ')  ignore_army = 0;
X		break;		/* 2 => in army descriptive text */
X    }
X    if (ignore_army) return TRUE;
X  }
X#endif
X    return FALSE;
X}
X
X   /*
X    *
X	New format (v3.1) of 'data' file which allows much faster lookups [pr]
X"do not edit"		first record is a comment line
X01234567		hexadecimal formatted offset to text area
Xname-a			first name of interest
X123,4			offset to name's text, and number of lines for it
Xname-b			next name of interest
Xname-c			multiple names which share same description also
X456,7			share a single offset,count line
X.			sentinel to mark end of names
X789,0			dummy record containing offset,count of EOF
Xtext-a			4 lines of descriptive text for name-a
Xtext-a			at file position 0x01234567L + 123L
Xtext-a
Xtext-a
Xtext-b/text-c		7 lines of text for names-b and -c
Xtext-b/text-c		at fseek(0x01234567L + 456L)
X...
X    *
X    */
X
Xvoid
Xdo_data()
X{
X	char	infile[30], tempfile[30];
X	boolean ok;
X	long	txt_offset;
X	unsigned entry_cnt, line_cnt;
X
X	Sprintf(tempfile, DATA_TEMPLATE, "database.tmp");
X	Sprintf(filename, DATA_TEMPLATE, DATA_FILE);
X	Strcat(strcpy(infile, filename),
X#ifdef OS2
X		".bas"
X#else
X		".base"
X#endif
X		);
X	if (!(ifp = fopen(infile, RDMODE))) {		/* data.base */
X		perror(infile);
X		exit(1);
X	}
X	if (!(ofp = fopen(filename, WRMODE))) {		/* data */
X		perror(filename);
X		Fclose(ifp);
X		exit(1);
X	}
X	if (!(tfp = fopen(tempfile, WRMODE))) {		/* database.tmp */
X		perror(tempfile);
X		Fclose(ifp);
X		Fclose(ofp);
X		Unlink(filename);
X		exit(1);
X	}
X
X	/* output a dummy header record; we'll rewind and overwrite it later */
X	Fprintf(ofp, "%s%08lx\n", Dont_Edit_Data, 0L);
X
X	entry_cnt = line_cnt = 0;
X	/* read through the input file and split it into two sections */
X	while (fgets(in_line, sizeof in_line, ifp)) {
X	    if (d_filter(in_line)) continue;
X	    if (*in_line > ' ') {	/* got an entry name */
X		/* first finish previous entry */
X		if (line_cnt)  Fprintf(ofp, "%d\n", line_cnt),  line_cnt = 0;
X		/* output the entry name */
X		(void) fputs(in_line, ofp);
X		entry_cnt++;		/* update number of entries */
X	    } else if (entry_cnt) {	/* got some descriptive text */
X		/* update previous entry with current text offset */
X		if (!line_cnt)  Fprintf(ofp, "%ld,", ftell(tfp));
X		/* save the text line in the scratch file */
X		(void) fputs(in_line, tfp);
X		line_cnt++;		/* update line counter */
X	    }
X	}
X	/* output an end marker and then record the current position */
X	if (line_cnt)  Fprintf(ofp, "%d\n", line_cnt);
X	Fprintf(ofp, ".\n%ld,%d\n", ftell(tfp), 0);
X	txt_offset = ftell(ofp);
X	Fclose(ifp);		/* all done with original input file */
X
X	/* reprocess the scratch file; 1st format an error msg, just in case */
X	Sprintf(in_line, "rewind of \"%s\"", tempfile);
X	if (rewind(tfp) != 0)  goto dead_data;
X	/* copy all lines of text from the scratch file into the output file */
X	while (fgets(in_line, sizeof in_line, tfp))
X	    (void) fputs(in_line, ofp);
X
X	/* finished with scratch file */
X	Fclose(tfp);
X	Unlink(tempfile);	/* remove it */
X
X	/* update the first record of the output file; prepare error msg 1st */
X	Sprintf(in_line, "rewind of \"%s\"", filename);
X	ok = (rewind(ofp) == 0);
X	if (ok) {
X	   Sprintf(in_line, "header rewrite of \"%s\"", filename);
X	   ok = (fprintf(ofp, "%s%08lx\n", Dont_Edit_Data, txt_offset) >= 0);
X	}
X	if (!ok) {
Xdead_data:  perror(in_line);	/* report the problem */
X	    /* close and kill the aborted output file, then give up */
X	    Fclose(ofp);
X	    Unlink(filename);
X	    exit(1);
X	}
X
X	/* all done */
X	Fclose(ofp);
X
X	return;
X}
X
X/* routine to decide whether to discard something from oracles.txt */
Xstatic boolean
Xh_filter(line)
X    char *line;
X{
X    static boolean skip = FALSE;
X    char tag[sizeof in_line];
X
X    SpinCursor(3);
X
X    if (*line == '#') return TRUE;	/* ignore comment lines */
X    if (sscanf(line, "----- %s", tag) == 1) {
X	skip = FALSE;
X#ifndef SINKS
X	if (!strcmp(tag, "SINKS")) skip = TRUE;
X#endif
X#ifndef ELBERETH
X	if (!strcmp(tag, "ELBERETH")) skip = TRUE;
X#endif
X    } else if (skip && !strncmp(line, "-----", 5))
X	skip = FALSE;
X    return skip;
X}
X
Xstatic const char *special_oracle[] = {
X	"\"...it is rather disconcerting to be confronted with the",
X	"following theorem from [Baker, Gill, and Solovay, 1975].",
X	"",
X	"Theorem 7.18  There exist recursive languages A and B such that",
X	"  (1)  P(A) == NP(A), and",
X	"  (2)  P(B) != NP(B)",
X	"",
X	"This provides impressive evidence that the techniques that are",
X	"currently available will not suffice for proving that P != NP or          ",
X	"that P == NP.\"  [Garey and Johnson, p. 185.]"
X};
X
X/*
X   The oracle file consists of a "do not edit" comment, a decimal count N
X   and set of N+1 hexadecimal fseek offsets, followed by N multiple-line
X   records, separated by "---" lines.  The first oracle is a special case.
X   The input data contains just those multi-line records, separated by
X   "-----" lines.
X */
X
Xvoid
Xdo_oracles()
X{
X	char	infile[30], tempfile[30];
X	boolean in_oracle, ok;
X	long	txt_offset, offset, fpos;
X	unsigned oracle_cnt;
X	register int i;
X
X	Sprintf(tempfile, DATA_TEMPLATE, "oracles.tmp");
X	Sprintf(filename, DATA_TEMPLATE, ORACLE_FILE);
X	Strcat(strcpy(infile, filename), ".txt");
X	if (!(ifp = fopen(infile, RDMODE))) {
X		perror(infile);
X		exit(1);
X	}
X	if (!(ofp = fopen(filename, WRMODE))) {
X		perror(filename);
X		Fclose(ifp);
X		exit(1);
X	}
X	if (!(tfp = fopen(tempfile, WRMODE))) {		/* oracles.tmp */
X		perror(tempfile);
X		Fclose(ifp);
X		Fclose(ofp);
X		Unlink(filename);
X		exit(1);
X	}
X
X	/* output a dummy header record; we'll rewind and overwrite it later */
X	Fprintf(ofp, "%s%5d\n", Dont_Edit_Data, 0);
X
X	/* handle special oracle; it must come first */
X	(void) fputs("---\n", tfp);
X	Fprintf(ofp, "%05lx\n", ftell(tfp));  /* start pos of special oracle */
X	for (i = 0; i < SIZE(special_oracle); i++) {
X	    (void) fputs(xcrypt(special_oracle[i]), tfp);
X	    (void) fputc('\n', tfp);
X	}
X	SpinCursor(3);
X
X	oracle_cnt = 1;
X	(void) fputs("---\n", tfp);
X	Fprintf(ofp, "%05lx\n", ftell(tfp));	/* start pos of first oracle */
X	in_oracle = FALSE;
X
X	while (fgets(in_line, sizeof in_line, ifp)) {
X	    SpinCursor(3);
X
X	    if (h_filter(in_line)) continue;
X	    if (!strncmp(in_line, "-----", 5)) {
X		if (!in_oracle) continue;
X		in_oracle = FALSE;
X		oracle_cnt++;
X		(void) fputs("---\n", tfp);
X		Fprintf(ofp, "%05lx\n", ftell(tfp));
X		/* start pos of this oracle */
X	    } else {
X		in_oracle = TRUE;
X		(void) fputs(xcrypt(in_line), tfp);
X	    }
X	}
X
X	if (in_oracle) {	/* need to terminate last oracle */
X	    oracle_cnt++;
X	    (void) fputs("---\n", tfp);
X	    Fprintf(ofp, "%05lx\n", ftell(tfp));	/* eof position */
X	}
X
X	/* record the current position */
X	txt_offset = ftell(ofp);
X	Fclose(ifp);		/* all done with original input file */
X
X	/* reprocess the scratch file; 1st format an error msg, just in case */
X	Sprintf(in_line, "rewind of \"%s\"", tempfile);
X	if (rewind(tfp) != 0)  goto dead_data;
X	/* copy all lines of text from the scratch file into the output file */
X	while (fgets(in_line, sizeof in_line, tfp))
X	    (void) fputs(in_line, ofp);
X
X	/* finished with scratch file */
X	Fclose(tfp);
X	Unlink(tempfile);	/* remove it */
X
X	/* update the first record of the output file; prepare error msg 1st */
X	Sprintf(in_line, "rewind of \"%s\"", filename);
X	ok = (rewind(ofp) == 0);
X	if (ok) {
X	    Sprintf(in_line, "header rewrite of \"%s\"", filename);
X	    ok = (fprintf(ofp, "%s%5d\n", Dont_Edit_Data, (int)oracle_cnt) >=0);
X	}
X	if (ok) {
X	    Sprintf(in_line, "data rewrite of \"%s\"", filename);
X	    for (i = 0; i <= oracle_cnt; i++) {
X#ifndef VMS	/* alpha/vms v1.0; this fflush seems to confuse ftell */
X		if (!(ok = (fflush(ofp) == 0))) break;
X#endif
X		if (!(ok = (fpos = ftell(ofp)) >= 0)) break;
X		if (!(ok = (fseek(ofp, fpos, SEEK_SET) >= 0))) break;
X		if (!(ok = (fscanf(ofp, "%5lx", &offset) == 1))) break;
X		if (!(ok = (fseek(ofp, fpos, SEEK_SET) >= 0))) break;
X		if (!(ok = (fprintf(ofp, "%05lx\n", offset + txt_offset) >= 0)))
X		    break;
X	    }
X	}
X	if (!ok) {
Xdead_data:  perror(in_line);	/* report the problem */
X	    /* close and kill the aborted output file, then give up */
X	    Fclose(ofp);
X	    Unlink(filename);
X	    exit(1);
X	}
X
X	/* all done */
X	Fclose(ofp);
X
X	return;
X}
X
X
Xstatic	struct deflist {
X
X	const char	*defname;
X	boolean	true_or_false;
X} deflist[] = {
X#ifdef REINCARNATION
X	      {	"REINCARNATION", TRUE },
X#else
X	      {	"REINCARNATION", FALSE },
X#endif
X#ifdef MULDGN
X	      {	"MULDGN", TRUE },
X#else
X	      {	"MULDGN", FALSE },
X#endif
X	      { 0, 0 } };
X
Xstatic int
Xcheck_control(s)
X	char	*s;
X{
X	int	i;
X
X	if(s[0] != '%') return(-1);
X
X	for(i = 0; deflist[i].defname; i++)
X	    if(!strncmp(deflist[i].defname, s+1, sizeof(deflist[i].defname)))
X		return(i);
X
X	return(-1);
X}
X
Xstatic char *
Xwithout_control(s)
X	char *s;
X{
X	return(s + 1 + strlen(deflist[check_control(in_line)].defname));
X}
X
Xvoid
Xdo_dungeon()
X{
X	int rcnt = 0;
X
X	Sprintf(filename, DATA_TEMPLATE, DGN_I_FILE);
X	if (!(ifp = fopen(filename, RDMODE))) {
X		perror(filename);
X		exit(1);
X	}
X	Sprintf(filename, DATA_TEMPLATE, DGN_O_FILE);
X	if (!(ofp = fopen(filename, WRMODE))) {
X		perror(filename);
X		exit(1);
X	}
X	Fprintf(ofp,Dont_Edit_Data);
X
X	while(fgets(in_line,sizeof(in_line),ifp) != NULL) {
X
X	    SpinCursor(3);
X
X	    rcnt++;
X	    if(in_line[0] == '#') continue;	/* discard comments */
Xrecheck:
X	    if(in_line[0] == '%') {
X		int i = check_control(in_line);
X		if(i >= 0) {
X		    if(!deflist[i].true_or_false)  {
X			while(fgets(in_line,sizeof(in_line),ifp))
X			    if(check_control(in_line) != i) goto recheck;
X		    } else
X			(void) fputs(without_control(in_line),ofp);
X		} else {
X		    Fprintf(stderr, "Unknown control option '%s' in file %s at line %d.\n",
X			    in_line, DGN_I_FILE, rcnt);
X		    exit(1);
X		}
X	    } else
X		(void) fputs(in_line,ofp);
X	}
X	Fclose(ifp);
X	Fclose(ofp);
X
X	return;
X}
X
Xstatic boolean
Xranged_attk(ptr)	/* returns TRUE if monster can attack at range */
X	register struct permonst *ptr;
X{
X	register int	i, j;
X	register int atk_mask = (1<<AT_BREA) | (1<<AT_SPIT) | (1<<AT_GAZE);
X
X	for(i = 0; i < NATTK; i++) {
X	    if((j=ptr->mattk[i].aatyp) >= AT_WEAP || (atk_mask & (1<<j)))
X		return TRUE;
X	}
X
X	return(FALSE);
X}
X
X/* This routine is designed to return an integer value which represents
X * an approximation of monster strength.  It uses a similar method of
X * determination as "experience()" to arrive at the strength.
X */
Xstatic int
Xmstrength(ptr)
Xstruct permonst *ptr;
X{
X	int	i, tmp2, n, tmp = ptr->mlevel;
X
X	if(tmp > 49)		/* special fixed hp monster */
X	    tmp = 2*(tmp - 6) / 4;
X
X/*	For creation in groups */
X	n = (!!(ptr->geno & G_SGROUP));
X	n += (!!(ptr->geno & G_LGROUP)) << 1;
X
X/*	For ranged attacks */
X	if (ranged_attk(ptr)) n++;
X
X/*	For higher ac values */
X	n += (ptr->ac < 4);
X	n += (ptr->ac < 0);
X
X/*	For very fast monsters */
X	n += (ptr->mmove >= 18);
X
X/*	For each attack and "special" attack */
X	for(i = 0; i < NATTK; i++) {
X
X	    tmp2 = ptr->mattk[i].aatyp;
X	    n += (tmp2 > 0);
X	    n += (tmp2 == AT_MAGC);
X	    n += (tmp2 == AT_WEAP && (ptr->mflags2 & M2_STRONG));
X	}
X
X/*	For each "special" damage type */
X	for(i = 0; i < NATTK; i++) {
X
X	    tmp2 = ptr->mattk[i].adtyp;
X	    if((tmp2 == AD_DRLI) || (tmp2 == AD_STON) || (tmp2 == AD_DRST)
X			|| (tmp2 == AD_DRDX) || (tmp2 == AD_DRCO)
X#ifdef POLYSELF
X					|| (tmp2 == AD_WERE)
X#endif
X								) n += 2;
X	    else if (strcmp(ptr->mname, "grid bug")) n += (tmp2 != AD_PHYS);
X	    n += ((int) (ptr->mattk[i].damd * ptr->mattk[i].damn) > 23);
X	}
X
X/*	Leprechauns are special cases.  They have many hit dice so they
X	can hit and are hard to kill, but they don't really do much damage. */
X	if (!strcmp(ptr->mname, "leprechaun")) n -= 2;
X
X/*	Finally, adjust the monster level  0 <= n <= 24 (approx.) */
X	if(n == 0) tmp--;
X	else if(n >= 6) tmp += ( n / 2 );
X	else tmp += ( n / 3 + 1);
X
X	return((tmp >= 0) ? tmp : 0);
X}
X
Xvoid
Xdo_monstr()
X{
X    register struct permonst *ptr;
X    register int i, j;
X
X    /*
X     * create the source file, "monstr.c"
X     */
X    Sprintf(filename, SOURCE_TEMPLATE, MON_STR_C);
X    if (!(ofp = fopen(filename, WRMODE))) {
X	perror(filename);
X	exit(1);
X    }
X    Fprintf(ofp,Dont_Edit_Code);
X    Fprintf(ofp,"#include \"config.h\"\n");
X    Fprintf(ofp,"\nint monstr[] = {\n");
X    for (ptr = &mons[0], j = 0; ptr->mlet; ptr++) {
X
X	SpinCursor(3);
X
X	i = mstrength(ptr);
X	Fprintf(ofp,"%2d,%c", i, (++j & 15) ? ' ' : '\n');
X    }
X    /* might want to insert a final 0 entry here instead of just newline */
X    Fprintf(ofp,"%s};\n", (j & 15) ? "\n" : "");
X
X    Fprintf(ofp,"\nvoid NDECL(monstr_init);\n");
X    Fprintf(ofp,"\nvoid\n");
X    Fprintf(ofp,"monstr_init()\n");
X    Fprintf(ofp,"{\n");
X    Fprintf(ofp,"    return;\n");
X    Fprintf(ofp,"}\n");
X    Fprintf(ofp,"\n/*monstr.c*/\n");
X
X    Fclose(ofp);
X    return;
X}
X
Xvoid
Xdo_permonst()
X{
X	int	i;
X	char	*c, *nam;
X
X	Sprintf(filename, INCLUDE_TEMPLATE, MONST_FILE);
X	if (!(ofp = fopen(filename, WRMODE))) {
X		perror(filename);
X		exit(1);
X	}
X	Fprintf(ofp,"/*\tSCCS Id: @(#)pm.h\t3.1\t92/01/04 */\n\n");
X	Fprintf(ofp,Dont_Edit_Code);
X	Fprintf(ofp,"#ifndef PM_H\n#define PM_H\n");
X
X	for(i = 0; mons[i].mlet; i++) {
X
X		SpinCursor(3);
X
X		Fprintf(ofp,"\n#define\tPM_");
X		if (mons[i].mlet == S_HUMAN &&
X				!strncmp(mons[i].mname, "were", 4))
X		    Fprintf(ofp, "HUMAN_");
X		for (nam = c = tmpdup(mons[i].mname); *c; c++)
X		    if (*c >= 'a' && *c <= 'z') *c -= (char)('a' - 'A');
X		    else if (*c < 'A' || *c > 'Z') *c = '_';
X		Fprintf(ofp,"%s\t%d", nam, i);
X	}
X	Fprintf(ofp,"\n\n#define\tNUMMONS\t%d\n", i);
X	Fprintf(ofp,"\n#endif /* PM_H */\n");
X	Fclose(ofp);
X	return;
X}
X
X#ifdef MULDGN
X/*	Start of Quest text file processing. */
X#include "qtext.h"
X
Xstatic struct qthdr	qt_hdr;
Xstatic struct msghdr	msg_hdr[N_HDR];
Xstatic struct qtmsg	*curr_msg;
X
Xstatic int	qt_line;
X
Xstatic boolean	in_msg;
X#define	NO_MSG	1	/* strlen of a null line returned by fgets() */
X
Xstatic boolean
Xqt_comment(s)
X
X	char *s;
X{
X	if(s[0] == '#') return(TRUE);
X	return(!in_msg  && strlen(s) == NO_MSG);
X}
X
Xstatic boolean
Xqt_control(s)
X
X	char *s;
X{
X	return(s[0] == '%' && (s[1] == 'C' || s[1] == 'E'));
X}
X
Xstatic int
Xget_hdr(c)
X
X	char c;
X{
X	int	i;
X
X	for(i = 0; i < qt_hdr.n_hdr; i++)
X	    if(c == qt_hdr.id[i]) return (++i);
X
X	return(0);
X}
X
Xstatic boolean
Xknown_id(c)
X
X	char c;
X{
X	return(get_hdr(c) > 0);
X}
X
Xstatic boolean
Xnew_id(c)
X
X	char c;
X{
X	if(qt_hdr.n_hdr >= N_HDR) {
X
X	    Fprintf(stderr, OUT_OF_HEADERS, qt_line);
X	    return(FALSE);
X	}
X
X	qt_hdr.id[qt_hdr.n_hdr] = c;
X	msg_hdr[qt_hdr.n_hdr].n_msg = 0;
X	qt_hdr.offset[qt_hdr.n_hdr++] = 0L;
X	return(TRUE);
X}
X
Xstatic boolean
Xknown_msg(c, s)
X
X	char c, *s;
X{
X	int i = get_hdr(c) - 1,
X	    j, n = atoi(s);
X
X	for(j = 0; j < msg_hdr[i].n_msg; j++)
X	    if(msg_hdr[i].qt_msg[j].msgnum == n) return(TRUE);
X
X	return(FALSE);
X}
X
X
Xstatic void
Xnew_msg(s)
Xchar *s;
X{
X	struct	qtmsg	*qt_msg;
X	int	i = get_hdr(s[4]) - 1;
X
X	if(msg_hdr[i].n_msg >= N_MSG) {
X		Fprintf(stderr, OUT_OF_MESSAGES, qt_line);
X	} else {
X		qt_msg = &(msg_hdr[i].qt_msg[msg_hdr[i].n_msg++]);
X		qt_msg->msgnum = atoi(s+5);
X		qt_msg->delivery = s[2];
X		qt_msg->offset = qt_msg->size = 0L;
X
X		curr_msg = qt_msg;
X	}
X}
X
Xstatic void
Xdo_qt_control(s)
X
X	char *s;
X{
X	switch(s[1]) {
X
X	    case 'C':	if(in_msg) {
X			    Fprintf(stderr, CREC_IN_MSG, qt_line);
X			    break;
X			} else {
X			    in_msg = TRUE;
X			    if(!known_id(s[4]))
X				if(!new_id(s[4])) break;
X			    if(known_msg(s[4],&s[5]))
X				Fprintf(stderr, DUP_MSG, qt_line);
X			    else new_msg(s);
X			}
X			break;
X
X	    case 'E':	if(!in_msg) {
X			    Fprintf(stderr, END_NOT_IN_MSG, qt_line);
X			    break;
X			} else in_msg = FALSE;
X			break;
X
X	    default:	Fprintf(stderr, UNREC_CREC, qt_line);
X			break;
X	}
X}
X
Xstatic void
Xdo_qt_text(s)
X
X	char *s;
X{
X	curr_msg->size += strlen(s);
X}
X
Xstatic void
Xadjust_qt_hdrs() {
X
X	int	i, j;
X	long	count = 0L,
X		hdr_offset = sizeof(int) +
X			     (sizeof(char) + sizeof(long)) * qt_hdr.n_hdr;
X
X	for(i = 0; i < qt_hdr.n_hdr; i++) {
X
X	    qt_hdr.offset[i] = hdr_offset;
X	    hdr_offset += sizeof(int) + sizeof(struct qtmsg) * msg_hdr[i].n_msg;
X	}
X
X	for(i = 0; i < qt_hdr.n_hdr; i++)
X	    for(j = 0; j < msg_hdr[i].n_msg; j++) {
X
X		msg_hdr[i].qt_msg[j].offset = hdr_offset + count;
X		count += msg_hdr[i].qt_msg[j].size;
X	    }
X}
X
Xstatic void
Xput_qt_hdrs() {
X
X	int	i;
X
X	/*
X	 *	The main header record.
X	 */
X#ifdef DEBUG
X	Fprintf(stderr, "%ld: header info.\n", ftell(ofp));
X#endif
X	(void) fwrite(&(qt_hdr.n_hdr), sizeof(int), 1, ofp);
X	(void) fwrite(&(qt_hdr.id[0]), sizeof(char), qt_hdr.n_hdr, ofp);
X	(void) fwrite(&(qt_hdr.offset[0]), sizeof(long), qt_hdr.n_hdr, ofp);
X#ifdef DEBUG
X	for(i = 0; i < qt_hdr.n_hdr; i++)
X		Fprintf(stderr, "%c @ %ld, ", qt_hdr.id[i], qt_hdr.offset[i]);
X
X	Fprintf(stderr, "\n");
X#endif
X
X	/*
X	 *	The individual class headers.
X	 */
X	for(i = 0; i < qt_hdr.n_hdr; i++) {
X
X#ifdef DEBUG
X	    Fprintf(stderr, "%ld: %c header info.\n", ftell(ofp),
X		    qt_hdr.id[i]);
X#endif
X	    (void) fwrite(&(msg_hdr[i].n_msg), sizeof(int), 1, ofp);
X	    (void) fwrite(&(msg_hdr[i].qt_msg[0]), sizeof(struct qtmsg),
X		   msg_hdr[i].n_msg, ofp);
X#ifdef DEBUG
X	    { int j;
X	      for(j = 0; j < msg_hdr[i].n_msg; j++)
X		Fprintf(stderr, "msg %d @ %ld (%ld)\n",
X			msg_hdr[i].qt_msg[j].msgnum,
X			msg_hdr[i].qt_msg[j].offset,
X			msg_hdr[i].qt_msg[j].size);
X	    }
X#endif
X	}
X}
X
Xvoid
Xdo_questtxt()
X{
X	Sprintf(filename, DATA_TEMPLATE, QTXT_I_FILE);
X	if(!(ifp = fopen(filename, RDMODE))) {
X		perror(filename);
X		exit(1);
X	}
X
X	Sprintf(filename, DATA_TEMPLATE, QTXT_O_FILE);
X	if(!(ofp = fopen(filename, WRBMODE))) {
X		perror(filename);
X		Fclose(ifp);
X		exit(1);
X	}
X
X	qt_hdr.n_hdr = 0;
X	qt_line = 0;
X	in_msg = FALSE;
X
X	while(fgets(in_line, 80, ifp) != NULL) {
X
X	    SpinCursor (3);
X
X	    qt_line++;
X	    if(qt_control(in_line)) do_qt_control(in_line);
X	    else if(qt_comment(in_line)) continue;
X	    else		    do_qt_text(in_line);
X	}
X
X	(void) rewind(ifp);
X	in_msg = FALSE;
X	adjust_qt_hdrs(); put_qt_hdrs();
X	while(fgets(in_line, 80, ifp) != NULL) {
X
X		if(qt_control(in_line)) {
X		    in_msg = (in_line[1] == 'C');
X		    continue;
X		} else if(qt_comment(in_line)) continue;
X#ifdef DEBUG
X		Fprintf(stderr, "%ld: %s", ftell(stdout), in_line);
X#endif
X		(void) fputs(xcrypt(in_line), ofp);
X	}
X	Fclose(ifp);
X	Fclose(ofp);
X	return;
X}
X#else	/* not MULDGN */
X
Xvoid
Xdo_questtxt()
X{
X	Fprintf(stderr, "makedefs: `-q' option ignored.\n");
X	/* create an empty file to satisfy `make' */
X	Sprintf(filename, DATA_TEMPLATE, QTXT_O_FILE);
X	ofp = fopen(filename, WRBMODE);
X	Fclose(ofp);
X	return;
X}
X
X#endif /* MULDGN */
X
Xstatic	char	temp[32];
X
Xchar *
Xlimit(name,pref)	/* limit a name to 30 characters length */
Xchar	*name;
Xint	pref;
X{
X	(void) strncpy(temp, name, pref ? 26 : 30);
X	temp[pref ? 26 : 30] = 0;
X	return temp;
X}
X
Xvoid
Xdo_objs()
X{
X	int i, sum = 0;
X	char *c, *objnam;
X	int nspell = 0;
X	int prefix = 0;
X	char class = '\0';
X	boolean	sumerr = FALSE;
X
X	Sprintf(filename, INCLUDE_TEMPLATE, ONAME_FILE);
X	if (!(ofp = fopen(filename, WRMODE))) {
X		perror(filename);
X		exit(1);
X	}
X	Fprintf(ofp,"/*\tSCCS Id: @(#)onames.h\t3.1\t92/11/01 */\n\n");
X	Fprintf(ofp,Dont_Edit_Code);
X	Fprintf(ofp,"#ifndef ONAMES_H\n#define ONAMES_H\n\n");
X
X	for(i = 0; !i || objects[i].oc_class != ILLOBJ_CLASS; i++) {
X		SpinCursor(3);
X
X		objects[i].oc_name_idx = objects[i].oc_descr_idx = i;	/* init */
X		if (!(objnam = tmpdup(OBJ_NAME(objects[i])))) continue;
X
X		/* make sure probabilities add up to 1000 */
X		if(objects[i].oc_class != class) {
X			if (sum && sum != 1000) {
X			    Fprintf(stderr, "prob error for class %d (%d%%)",
X				    class, sum);
X			    (void) fflush(stderr);
X			    sumerr = TRUE;
X			}
X			class = objects[i].oc_class;
X			sum = 0;
X		}
X
X		for (c = objnam; *c; c++)
X		    if (*c >= 'a' && *c <= 'z') *c -= (char)('a' - 'A');
X		    else if (*c < 'A' || *c > 'Z') *c = '_';
X
X		switch (class) {
X		    case WAND_CLASS:
X			Fprintf(ofp,"#define\tWAN_"); prefix = 1; break;
X		    case RING_CLASS:
X			Fprintf(ofp,"#define\tRIN_"); prefix = 1; break;
X		    case POTION_CLASS:
X			Fprintf(ofp,"#define\tPOT_"); prefix = 1; break;
X		    case SPBOOK_CLASS:
X			Fprintf(ofp,"#define\tSPE_"); prefix = 1; nspell++; break;
X		    case SCROLL_CLASS:
X			Fprintf(ofp,"#define\tSCR_"); prefix = 1; break;
X		    case AMULET_CLASS:
X			/* avoid trouble with stupid C preprocessors */
X			Fprintf(ofp,"#define\t");
X			if(objects[i].oc_material == PLASTIC) {
X			    Fprintf(ofp,"FAKE_AMULET_OF_YENDOR\t%d\n", i);
X			    prefix = -1;
X			    break;
X			}
X			break;
X		    case GEM_CLASS:
X			/* avoid trouble with stupid C preprocessors */
X			if(objects[i].oc_material == GLASS) {
X			    Fprintf(ofp,"/* #define\t%s\t%d */\n",
X							objnam, i);
X			    prefix = -1;
X			    break;
X			}
X		    default:
X			Fprintf(ofp,"#define\t");
X		}
X		if (prefix >= 0)
X			Fprintf(ofp,"%s\t%d\n", limit(objnam, prefix), i);
X		prefix = 0;
X
X		sum += objects[i].oc_prob;
X	}
X
X	/* check last set of probabilities */
X	if (sum && sum != 1000) {
X	    Fprintf(stderr, "prob error for class %d (%d%%)", class, sum);
X	    (void) fflush(stderr);
X	    sumerr = TRUE;
X	}
X
X	Fprintf(ofp,"#define\tLAST_GEM\t(JADE)\n");
X	Fprintf(ofp,"#define\tMAXSPELL\t%d\n", nspell+1);
X	Fprintf(ofp,"#define\tNROFOBJECTS\t%d\n", i-1);
X
X	Fprintf(ofp, "\n/* Artifacts (unique objects) */\n\n");
X
X	for (i = 1; artifact_names[i]; i++) {
X		SpinCursor(3);
X
X		for (c = objnam = tmpdup(artifact_names[i]); *c; c++)
X		    if (*c >= 'a' && *c <= 'z') *c -= (char)('a' - 'A');
X		    else if (*c < 'A' || *c > 'Z') *c = '_';
X
X		if (!strncmp(objnam, "THE_", 4))
X			objnam += 4;
X#ifdef TOURIST
X		/* fudge _platinum_ YENDORIAN EXPRESS CARD */
X		if (!strncmp(objnam, "PLATINUM_", 9))
X			objnam += 9;
X#endif
X		Fprintf(ofp,"#define\tART_%s\t%d\n", limit(objnam, 1), i);
X	}
X
X	Fprintf(ofp, "#define\tNROFARTIFACTS\t%d\n", i-1);
X	Fprintf(ofp,"\n#endif /* ONAMES_H */\n");
X	Fclose(ofp);
X	if (sumerr) exit(1);
X	return;
X}
X
Xchar *
Xtmpdup(str)
Xconst char *str;
X{
X	static char buf[128];
X
X	if (!str) return (char *)0;
X	(void)strncpy(buf, str, 127);
X	return buf;
X}
X
X
X/*
X * macros used to control vision algorithms:
X *      VISION_TABLES => generate tables
X *      BRACES        => table elements should be enclosed in "{ }"
X */
X
Xvoid
Xdo_vision()
X{
X#ifdef VISION_TABLES
X    int i, j;
X
X    /* Everything is clear.  xclear may be malloc'ed.
X     * Block the upper left corner (BLOCK_HEIGHTxBLOCK_WIDTH)
X     */
X    for (i = 0; i < MAX_ROW; i++)
X	for (j = 0; j < MAX_COL; j++)
X	    if (i < BLOCK_HEIGHT && j < BLOCK_WIDTH)
X		xclear[i][j] = '\000';
X	    else
X		xclear[i][j] = '\001';
X#endif /* VISION_TABLES */
X
X    SpinCursor(3);
X
X    /*
X     * create the include file, "vis_tab.h"
X     */
X    Sprintf(filename, INCLUDE_TEMPLATE, VIS_TAB_H);
X    if (!(ofp = fopen(filename, WRMODE))) {
X	perror(filename);
X	exit(1);
X    }
X    Fprintf(ofp,Dont_Edit_Code);
X    Fprintf(ofp,"#ifdef VISION_TABLES\n");
X#ifdef VISION_TABLES
X    H_close_gen();
X    H_far_gen();
X#endif /* VISION_TABLES */
X    Fprintf(ofp,"\n#endif /* VISION_TABLES */\n");
X    Fclose(ofp);
X
X    SpinCursor(3);
X
X    /*
X     * create the source file, "vis_tab.c"
X     */
X    Sprintf(filename, SOURCE_TEMPLATE, VIS_TAB_C);
X    if (!(ofp = fopen(filename, WRMODE))) {
X	perror(filename);
X	Sprintf(filename, INCLUDE_TEMPLATE, VIS_TAB_H);
X	Unlink(filename);
X	exit(1);
X    }
X    Fprintf(ofp,Dont_Edit_Code);
X    Fprintf(ofp,"#include \"config.h\"\n");
X    Fprintf(ofp,"#ifdef VISION_TABLES\n");
X    Fprintf(ofp,"#include \"vis_tab.h\"\n");
X
X    SpinCursor(3);
X
X#ifdef VISION_TABLES
X    C_close_gen();
X    C_far_gen();
X    Fprintf(ofp,"\nvoid vis_tab_init() { return; }\n");
X#endif /* VISION_TABLES */
X
X    SpinCursor(3);
X
X    Fprintf(ofp,"\n#endif /* VISION_TABLES */\n");
X    Fprintf(ofp,"\n/*vis_tab.c*/\n");
X
X    Fclose(ofp);
X    return;
X}
X
X#ifdef VISION_TABLES
X
X/*--------------  vision tables  --------------*\
X *
X *  Generate the close and far tables.  This is done by setting up a
X *  fake dungeon and moving our source to different positions relative
X *  to a block and finding the first/last visible position.  The fake
X *  dungeon is all clear execpt for the upper left corner (BLOCK_HEIGHT
X *  by BLOCK_WIDTH) is blocked.  Then we move the source around relative
X *  to the corner of the block.  For each new position of the source
X *  we check positions on rows "kittycorner" from the source.  We check
X *  positions until they are either in sight or out of sight (depends on
X *  which table we are generating).  The picture below shows the setup
X *  for the generation of the close table.  The generation of the far
X *  table would switch the quadrants of the '@' and the "Check rows
X *  here".
X *
X *
X *  XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
X *  XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
X *  XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX,,,,,,,,, Check rows here ,,,,,,,,,,,,
X *  XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
X *  XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXB,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
X *  ...............................
X *  ...............................
X *  .........@.....................
X *  ...............................
X *
X *      Table generation figure (close_table).  The 'X's are blocked points.
X *      The 'B' is a special blocked point.  The '@' is the source.  The ','s
X *      are the target area.  The '.' are just open areas.
X *
X *
X *  Example usage of close_table[][][].
X *
X *  The table is as follows:
X *
X *      dy = |row of '@' - row of 'B'|  - 1
X *      dx = |col of '@' - col of 'B'|
X *
X *  The first indices are the deltas from the source '@' and the block 'B'.
X *  You must check for the value inside the abs value bars being zero.  If
X *  so then the block is on the same row and you don't need to do a table
X *  lookup.  The last value:
X *
X *      dcy = |row of block - row to be checked|
X *
X *  Is the value of the first visible spot on the check row from the
X *  block column.  So
X *
X *  first visible col = close_table[dy][dx][dcy] + col of 'B'
X *
X\*--------------  vision tables  --------------*/
X
Xstatic void
XH_close_gen()
X{
X    Fprintf(ofp,"\n/* Close */\n");
X    Fprintf(ofp,"#define CLOSE_MAX_SB_DY %2d\t/* |src row - block row| - 1\t*/\n",
X	    TEST_HEIGHT-1);
X    Fprintf(ofp,"#define CLOSE_MAX_SB_DX %2d\t/* |src col - block col|\t*/\n",
X	    TEST_WIDTH);
X    Fprintf(ofp,"#define CLOSE_MAX_BC_DY %2d\t/* |block row - check row|\t*/\n",
X	    TEST_HEIGHT);
X    Fprintf(ofp,"typedef struct {\n");
X    Fprintf(ofp,"    unsigned char close[CLOSE_MAX_SB_DX][CLOSE_MAX_BC_DY];\n");
X    Fprintf(ofp,"} close2d;\n");
X    Fprintf(ofp,"extern close2d close_table[CLOSE_MAX_SB_DY];\n");
X    return;
X}
X
Xstatic void
XH_far_gen()
X{
X    Fprintf(ofp,"\n/* Far */\n");
X    Fprintf(ofp,"#define FAR_MAX_SB_DY %2d\t/* |src row - block row|\t*/\n",
X	    TEST_HEIGHT);
X    Fprintf(ofp,"#define FAR_MAX_SB_DX %2d\t/* |src col - block col| - 1\t*/\n",
X	    TEST_WIDTH-1);
X    Fprintf(ofp,"#define FAR_MAX_BC_DY %2d\t/* |block row - check row| - 1\t*/\n",
X	    TEST_HEIGHT-1);
X    Fprintf(ofp,"typedef struct {\n");
X    Fprintf(ofp,"    unsigned char far_q[FAR_MAX_SB_DX][FAR_MAX_BC_DY];\n");
X    Fprintf(ofp,"} far2d;\n");
X    Fprintf(ofp,"extern far2d far_table[FAR_MAX_SB_DY];\n");
X    return;
X}
X
X# ifdef BRACES
X#  define L_BRACE "{"
X#  define R_BRACE "},"
X# else
X#  define L_BRACE ""
X#  define R_BRACE ""
X# endif /* BRACES */
X
Xstatic void
XC_close_gen()
X{
X    int i,dx,dy;
X    int src_row, src_col;	/* source */
X    int block_row, block_col;	/* block */
X    int this_row;
X    int no_more;
X
X    block_row = BLOCK_HEIGHT-1;
X    block_col = BLOCK_WIDTH-1;
X
X    Fprintf(ofp,"\n#ifndef FAR_TABLE_ONLY\n");
X    Fprintf(ofp,"\nclose2d close_table[CLOSE_MAX_SB_DY] = {\n");
X#ifndef no_vision_progress
X    Fprintf(stderr,"\nclose:");
X#endif
X
X    for (dy = 1; dy < TEST_HEIGHT; dy++) {
X	src_row = block_row + dy;
X	Fprintf(ofp,"/* DY = %2d (- 1)*/\n  {\n",dy);
X#ifndef no_vision_progress
X	Fprintf(stderr," %2d",dy),  (void)fflush(stderr);
X#endif
X	for (dx = 0; dx < TEST_WIDTH; dx++) {
X	    src_col = block_col - dx;
X	    Fprintf(ofp,"  /*%2d*/  %s",dx, L_BRACE);
X
X	    no_more = 0;
X	    for (this_row = 0; this_row < TEST_HEIGHT; this_row++) {
X		if (no_more) {
X		    Fprintf(ofp,CLOSE_OFF_TABLE_STRING);
X		    continue;
X		}
X
X		SpinCursor(3);
X
X		/* Find the first column that we can see. */
X		for (i = block_col+1; i < MAX_COL; i++) {
X
X		    if (clear_path(src_row,src_col,block_row-this_row,i))
X			break;
X		}
X
X		if (i == MAX_COL) no_more = 1;
X		Fprintf(ofp,"%2d,",i-block_col);
X	    }
X	    Fprintf(ofp,"%s\n", R_BRACE);
X	}
X	Fprintf(ofp,"  },\n");
X    }
X
X    Fprintf(ofp,"}; /* close_table[] */\n");		/* closing brace for table */
X    Fprintf(ofp,"#endif /* !FAR_TABLE_ONLY */\n");
X#ifndef no_vision_progress
X    Fprintf(stderr,"\n");
X#endif
X    return;
X}
X
Xstatic void
XC_far_gen()
X{
X    int i,dx,dy;
X    int src_row, src_col;	/* source */
X    int block_row, block_col;	/* block */
X    int this_row;
X
X    block_row = BLOCK_HEIGHT-1;
X    block_col = BLOCK_WIDTH-1;
X
X    Fprintf(ofp,"\n#ifndef CLOSE_TABLE_ONLY\n");
X    Fprintf(ofp,"\nfar2d far_table[FAR_MAX_SB_DY] = {\n");
X#ifndef no_vision_progress
X    Fprintf(stderr,"\n_far_:");
X#endif
X
X    for (dy = 0; dy < TEST_HEIGHT; dy++) {
X	src_row = block_row - dy;
X	Fprintf(ofp,"/* DY = %2d */\n  {\n",dy);
X#ifndef no_vision_progress
X	Fprintf(stderr," %2d",dy),  (void)fflush(stderr);
X#endif
X	for (dx = 1; dx < TEST_WIDTH; dx++) {
X	    src_col = block_col + dx;
X	    Fprintf(ofp,"  /*%2d(-1)*/ %s",dx, L_BRACE);
X
X	    for (this_row = block_row+1; this_row < block_row+TEST_HEIGHT;
X								this_row++) {
X		/* Find first col that we can see. */
X		for (i = 0; i <= block_col; i++) {
X
X		    SpinCursor(3);
X
X		    if (clear_path(src_row,src_col,this_row,i)) break;
X		}
X
X		if (block_col-i < 0)
X		    Fprintf(ofp,FAR_OFF_TABLE_STRING);
X		else
X		    Fprintf(ofp,"%2d,",block_col-i);
X	    }
X	    Fprintf(ofp,"%s\n", R_BRACE);
X	}
X	Fprintf(ofp,"  },\n");
X    }
X
X    Fprintf(ofp,"}; /* far_table[] */\n");	/* closing brace for table */
X    Fprintf(ofp,"#endif /* !CLOSE_TABLE_ONLY */\n");
X#ifndef no_vision_progress
X    Fprintf(stderr,"\n");
X#endif
X    return;
X}
X
X/*
X *  "Draw" a line from the hero to the given location.  Stop of we hit a
X *  wall.
X *
X *  Generalized integer Bresenham's algorithm (fast line drawing) for
X *  all quadrants.  From _Procedural Elements for Computer Graphics_, by
X *  David F. Rogers.  McGraw-Hill, 1985.
X *
X *  I have tried a little bit of optimization by pulling compares out of
X *  the inner loops.
X *
X *  NOTE:  This had better *not* be called from a position on the
X *  same row as the hero.
X */
Xstatic int
Xclear_path(you_row,you_col,y2,x2)
X    int you_row, you_col, y2, x2;
X{
X    int dx, dy, s1, s2;
X    register int i, error, x, y, dxs, dys;
X
X    x  = you_col;		y  = you_row;
X    dx = abs(x2-you_col);	dy = abs(y2-you_row);
X    s1 = sign(x2-you_col);	s2 = sign(y2-you_row);
X
X    if (s1 == 0) {	/* same column */
X	if (s2 == 1) {	/* below (larger y2 value) */
X	    for (i = you_row+1; i < y2; i++)
X		if (!xclear[i][you_col]) return 0;
X	} else {	/* above (smaller y2 value) */
X	    for (i = y2+1; i < you_row; i++)
X		if (!xclear[i][you_col]) return 0;
X	}
X	return 1;
X    }
X
X    /*
X     *  Lines at 0 and 90 degrees have been weeded out.
X     */
X    if (dy > dx) {
X	error = dx; dx = dy; dy = error;	/* swap the values */
X	dxs = dx << 1;		/* save the shifted values */
X	dys = dy << 1;
X	error = dys - dx;	/* NOTE: error is used as a temporary above */
X
X	for (i = 0; i < dx; i++) {
X	    if (!xclear[y][x]) return 0;	/* plot point */
X
X	    while (error >= 0) {
X		x += s1;
X		error -= dxs;
X	    }
X	    y += s2;
X	    error += dys;
X	}
X    } else {
X	dxs = dx << 1;		/* save the shifted values */
X	dys = dy << 1;
X	error = dys - dx;
X
X	for (i = 0; i < dx; i++) {
X	    if (!xclear[y][x]) return 0;	/* plot point */
X
X	    while (error >= 0) {
X		y += s2;
X		error -= dxs;
X	    }
X	    x += s1;
X	    error += dys;
X	}
X    }
X    return 1;
X}
X#endif /* VISION_TABLES */
X
X/*makedefs.c*/
END_OF_FILE
if test 45073 -ne `wc -c <'util/makedefs.c'`; then
    echo shar: \"'util/makedefs.c'\" unpacked with wrong size!
fi
# end of 'util/makedefs.c'
fi
echo shar: End of archive 17 \(of 108\).
cp /dev/null ark17isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \
21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \
41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 \
61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 \
81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 \
101 102 103 104 105 106 107 108 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 108 archives.
    echo "Now execute 'rebuild.sh'"
    rm -f ark10[0-8]isdone ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
