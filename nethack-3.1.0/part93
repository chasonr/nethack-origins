Path: uunet!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v16i101:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Part93/108
Message-ID: <4466@master.CNA.TEK.COM>
Date: 5 Feb 93 22:02:49 GMT
Sender: news@master.CNA.TEK.COM
Lines: 2211
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1652

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 16, Issue 101
Archive-name: nethack31/Part93
Supersedes: nethack3p9: Volume 10, Issue 46-108
Environment: Amiga, Atari, Mac, MS-DOS, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 93 (of 108)."
# Contents:  dat/cmdhelp include/rm.h src/bones.c
#   sys/amiga/splitter/loader.c sys/share/pcmain.c win/X11/wintext.c
# Wrapped by billr@saab on Wed Jan 27 16:09:25 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'dat/cmdhelp' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dat/cmdhelp'\"
else
echo shar: Extracting \"'dat/cmdhelp'\" \(4641 characters\)
sed "s/^X//" >'dat/cmdhelp' <<'END_OF_FILE'
X^       Show the type of a trap
X^[      Cancel command
X^A      Redo the previous command
X^C      Quit the game
X^D      Kick something (usually a door)
X^E      Search a room (available in debug mode only)
X^F      Map the level (available in debug mode only)
X^G      Create a monster (available in debug mode only)
X^I      Identify all items (available in debug mode only)
X^O      Show location of special levels (available in debug mode only)
X^P      Show previous message printed out
X^R      Redraw screen
X^T      Teleport around level
X^V      Teleport between levels (available in debug mode only)
X^W      Wish (available in debug mode only)
X^X      Show your intrinsic attributes (in debug or explore mode only)
X^Z      Suspend game (only if defined)
Xa       Apply (use) a tool
XA       Remove all Armor
Xb       Go southwest 1 space
XB       Go southwest until you are on top of something
X^B      Go southwest until you are near something
Xc       Close a door
XC       Call (name) a particular monster
Xd       Drop an item
XD       Drop specific item types
Xe       Eat something
XE       Engrave writing on the floor
Xg       Followed by direction, move until you are near something
XG       Followed by direction, same as control-direction
Xh       Go west 1 space
XH       Go west until you are on top of something
X^H      Go west until you are near something
Xi       Show your inventory
XI       Inventory specific item types
Xj       Go south 1 space (or if number_pad is on, jump to another location)
XJ       Go south until you are on top of something
X^J      Go south until you are near something
Xk       Go north 1 space (or if number_pad is on, kick something)
XK       Go north until you are on top of something
X^K      Go north until you are near something
Xl       Go east 1 space (or if number_pad is on, loot a box on the floor)
XL       Go east until you are on top of something
X^L      Go east until you are near something
Xm       Followed by direction, move without picking anything up
XM       Followed by direction, move a distance without picking anything up
Xn       Go southeast 1 space
XN       Go southeast until you are on something (if number_pad, name an object)
X^N      Go southeast until you are near something
Xo       Open a door
XO       Set options (O? explains options)
Xp       Pay your shopping bill
XP       Put on an accessory (ring, amulet, etc)
Xq       Quaff (drink) something
XQ       Quit the game
Xr       Read a scroll (or spell book, if defined)
XR       Remove an accessory (ring, amulet, etc)
Xs       Search for traps and secret doors
XS       Save the game
Xt       Throw something
XT       Take off one piece of armor
Xu       Go northeast 1 space (or if number_pad is on, untrap something)
XU       Go northeast until you are on top of something
X^U      Go northeast until you are near something
Xv       Show version
XV       Show long version and game history
Xw       Wield (put in use) a weapon
XW       Wear a piece of armor
Xx       List known spells (only if defined)
XX       Enter explore (discovery) mode (only if defined)
Xy       Go northwest 1 space
XY       Go northwest until you are on top of something
X^Y      Go northwest until you are near something
Xz       Zap a wand
XZ       Zap (cast) a spell (only if defined)
X<       Go up a staircase
X>       Go down a staircase
X/       Show what type of thing a symbol corresponds to
X?       Give a help message
X&       Tell what a command does
X!       Do a shell escape (only if defined)
X\       Show what object types have been discovered
X.       Rest one move while doing nothing
X        Rest one move while doing nothing (if rest_on_space option is on)
X:       Look at what is on the floor
X@       Toggle the pickup option on/off
X)       Show the weapon currently wielded
X[       Show the armor currently worn
X=       Show the ring(s) currently worn
X"       Show the amulet currently worn
X(       Show the tools currently in use
X$       Count your gold
X+       List known spells (only if defined)
X#       Perform an extended command
XM-a     Adjust inventory letters (the fixinv option must be on to do this)
XM-c     Talk to someone
XM-d     Dip an object into something
XM-f     Force a lock
XM-i     Invoke an object's special powers
XM-j     Jump to another location
XM-l     Loot a box on the floor
XM-m     Use a monster's special ability (only if defined)
XM-n     Name an item or type of object
XM-o     Offer a sacrifice to the gods
XM-p     Pray to the gods for help
XM-r     Rub a lamp
XM-s     Sit down
XM-t     Turn undead
XM-u     Untrap something (usually a trapped object)
XM-v     Print compile time options for this version of NetHack
XM-w     Wipe off your face
END_OF_FILE
if test 4641 -ne `wc -c <'dat/cmdhelp'`; then
    echo shar: \"'dat/cmdhelp'\" unpacked with wrong size!
fi
# end of 'dat/cmdhelp'
fi
if test -f 'include/rm.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/rm.h'\"
else
echo shar: Extracting \"'include/rm.h'\" \(10031 characters\)
sed "s/^X//" >'include/rm.h' <<'END_OF_FILE'
X/*	SCCS Id: @(#)rm.h	3.1	92/09/01		  */
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#ifndef RM_H
X#define RM_H
X
X/*
X * The dungeon presentation graphics code and data structures were rewritten
X * and generalized for NetHack's release 2 by Eric S. Raymond (eric@snark)
X * building on Don G. Kneller's MS-DOS implementation.  See drawing.c for
X * the code that permits the user to set the contents of the symbol structure.
X *
X * The door representation was changed by Ari Huttunen(ahuttune@niksula.hut.fi)
X */
X
X/*
X * TLCORNER	TDWALL		TRCORNER
X * +- 		-+- 		-+
X * |  		 |  	 	 |
X *
X * TRWALL	CROSSWALL	TLWALL		HWALL
X * |  		 |  		 |
X * +- 		-+- 		-+		---
X * |  		 |  		 |
X *
X * BLCORNER	TUWALL		BRCORNER	VWALL
X * |  		 |  		 |		|
X * +- 		-+- 		-+		|
X */
X
X/* Level location types */
X#define STONE		0
X#define VWALL		1
X#define HWALL		2
X#define TLCORNER	3
X#define TRCORNER	4
X#define BLCORNER	5
X#define BRCORNER	6
X#define CROSSWALL	7	/* For pretty mazes and special levels */
X#define TUWALL		8
X#define TDWALL		9
X#define TLWALL		10
X#define TRWALL		11
X#define DBWALL		12
X#define SDOOR		13
X#define SCORR		14
X#define POOL		15
X#define MOAT		16	/* pool that doesn't boil, adjust messages */
X#define WATER		17
X#define DRAWBRIDGE_UP	18
X#define LAVAPOOL	19
X#define DOOR		20
X#define CORR		21
X#define ROOM		22
X#define STAIRS		23
X#define LADDER		24
X#define FOUNTAIN	25
X#define THRONE		26
X#define SINK		27
X#define ALTAR		28
X#define ICE		29
X#define DRAWBRIDGE_DOWN	30
X#define AIR		31
X#define CLOUD		32
X
X#define INVALID_TYPE	127
X
X/*
X * Avoid using the level types in inequalities:
X * these types are subject to change.
X * Instead, use one of the macros below.
X */
X#define IS_WALL(typ)	((typ) && (typ) <= DBWALL)
X#define IS_STWALL(typ)	((typ) <= DBWALL)	/* STONE <= (typ) <= DBWALL */
X#define IS_ROCK(typ)	((typ) < POOL)		/* absolutely nonaccessible */
X#define IS_DOOR(typ)	((typ) == DOOR)
X#define ACCESSIBLE(typ)	((typ) >= DOOR)		/* good position */
X#define IS_ROOM(typ)	((typ) >= ROOM)		/* ROOM, STAIRS, furniture.. */
X#define ZAP_POS(typ)	((typ) >= POOL)
X#define SPACE_POS(typ)	((typ) > DOOR)
X#define IS_POOL(typ)	((typ) >= POOL && (typ) <= DRAWBRIDGE_UP)
X#define IS_THRONE(typ)	((typ) == THRONE)
X#define IS_FOUNTAIN(typ) ((typ) == FOUNTAIN)
X#define IS_SINK(typ)	((typ) == SINK)
X#define IS_ALTAR(typ)	((typ) == ALTAR)
X#define IS_DRAWBRIDGE(typ) ((typ) == DRAWBRIDGE_UP || (typ) == DRAWBRIDGE_DOWN)
X#define IS_FURNITURE(typ) ((typ) >= STAIRS && (typ) <= ALTAR)
X#define IS_AIR(typ)	((typ) == AIR || (typ) == CLOUD)
X#define IS_SOFT(typ)	((typ) == AIR || (typ) == CLOUD || IS_POOL(typ))
X
X/*
X * The screen symbols may be the default or defined at game startup time.
X * See drawing.c for defaults.
X * Note: {ibm|dec}_graphics[] arrays (also in drawing.c) must be kept in synch.
X */
X#define S_stone		0
X#define S_vwall		1
X#define S_hwall		2
X#define S_tlcorn	3
X#define S_trcorn	4
X#define S_blcorn	5
X#define S_brcorn	6
X#define S_crwall	7
X#define S_tuwall	8
X#define S_tdwall	9
X#define S_tlwall	10
X#define S_trwall	11
X#define S_ndoor		12
X#define S_vodoor	13
X#define S_hodoor	14
X#define S_vcdoor	15	/* closed door, vertical wall */
X#define S_hcdoor	16	/* closed door, horizontal wall */
X#define S_room		17
X#define S_corr		18
X#define S_litcorr	19
X#define S_upstair	20
X#define S_dnstair	21
X#define S_upladder	22
X#define S_dnladder	23
X#define S_trap		24
X#define S_web		25
X#define S_altar		26
X#define S_throne	27
X#define S_sink		28
X#define S_fountain	29
X#define S_pool		30
X#define S_ice		31
X#define S_lava		32
X#define S_vodbridge	33
X#define S_hodbridge	34
X#define S_vcdbridge	35	/* closed drawbridge, vertical wall */
X#define S_hcdbridge	36	/* closed drawbridge, horizontal wall */
X#define S_air		37
X#define S_cloud		38
X#define S_water		39
X#define S_vbeam		40	/* The 4 zap beam symbols.  Do NOT separate. */
X#define S_hbeam		41	/* To change order or add, see function     */
X#define S_lslant	42	/* zapdir_to_glyph() in display.c.	    */
X#define S_rslant	43
X#define S_digbeam	44	/* dig beam symbol */
X#define S_flashbeam	45	/* camera flash symbol */
X#define S_boomleft	46	/* thrown boomerang, open left, e.g ')'    */
X#define S_boomright	47	/* thrown boomerand, open right, e.g. '('  */
X#define S_ss1		48	/* 4 magic shield glyphs */
X#define S_ss2		49
X#define S_ss3		50
X#define S_ss4		51
X
X/* The 8 swallow symbols.  Do NOT separate.  To change order or add, see */
X/* the function swallow_to_glyph() in display.c.			 */
X#define S_sw_tl		52	/* swallow top left [1]			*/
X#define S_sw_tc		53	/* swallow top center [2]	Order:	*/
X#define S_sw_tr		54	/* swallow top right [3]		*/
X#define S_sw_ml		55	/* swallow middle left [4]	1 2 3	*/
X#define S_sw_mr		56	/* swallow middle right [6]	4 5 6	*/
X#define S_sw_bl		57	/* swallow bottom left [7]	7 8 9	*/
X#define S_sw_bc		58	/* swallow bottom center [8]		*/
X#define S_sw_br		59	/* swallow bottom right [9]		*/
X
X#define S_explode1	60	/* explosion top left			*/
X#define S_explode2	61	/* explosion top center			*/
X#define S_explode3	62	/* explosion top right		 Ex.	*/
X#define S_explode4	63	/* explosion middle left		*/
X#define S_explode5	64	/* explosion middle center	 /-\	*/
X#define S_explode6	65	/* explosion middle right	 |@|	*/
X#define S_explode7	66	/* explosion bottom left	 \-/	*/
X#define S_explode8	67	/* explosion bottom center		*/
X#define S_explode9	68	/* explosion bottom right		*/
X
X#define MAXPCHARS	69	/* maximum number of mapped characters */
X
Xstruct symdef {
X    uchar sym;
X    const char  *explanation;
X#ifdef TEXTCOLOR
X    uchar color;
X#endif
X};
X
Xextern const struct symdef defsyms[MAXPCHARS];	/* defaults */
Xextern uchar showsyms[MAXPCHARS];
X
X/*
X * Graphics sets for display symbols
X */
X#define ASCII_GRAPHICS	0	/* regular characters: '-', '+', &c */
X#define IBM_GRAPHICS	1	/* PC graphic characters */
X#define DEC_GRAPHICS	2	/* VT100 line drawing characters */
X#define MAC_GRAPHICS	3	/* Macintosh drawing characters */
X
X/*
X * The 5 possible states of doors
X */
X
X#define D_NODOOR	0
X#define D_BROKEN	1
X#define D_ISOPEN	2
X#define D_CLOSED	4
X#define D_LOCKED	8
X#define D_TRAPPED	16
X
X/*
X * The 3 possible alignments for altars
X */
X#ifndef ALIGN_H
X#include "align.h"		/* defines the "AM_" values */
X#endif
X
X/*
X * Some altars are considered as shrines, so we need a flag.
X */
X#define AM_SHRINE	8
X
X/*
X * Thrones should only be looted once.
X */
X#define T_LOOTED	1
X
X/*
X * Fountains have limits, and special warnings.
X */
X#define F_LOOTED	1
X#define F_WARNED	2
X
X/*
X * Sinks have 3 different types of loot that shouldn't be abused
X */
X#define S_LPUDDING	1
X#define S_LDWASHER	2
X#define S_LRING		4
X
X/*
X * The four directions for a DrawBridge.
X */
X#define DB_NORTH	0
X#define DB_SOUTH	1
X#define DB_EAST		2
X#define DB_WEST		3
X#define DB_DIR		3	/* mask for direction */
X
X/*
X * What's under a drawbridge.
X */
X#define DB_MOAT		0
X#define DB_LAVA		4
X#define DB_ICE		8
X#define DB_FLOOR	16
X#define DB_UNDER	28	/* mask for underneath */
X
X/*
X * Some walls may be non diggable.
X */
X#define W_DIGGABLE	0
X#define W_NONDIGGABLE	1
X#define W_REPAIRED	2
X
X/*
X * Ladders (in Vlad's tower) may be up or down.
X */
X#define LA_UP		1
X#define LA_DOWN		2
X
X/*
X * Room areas may be iced pools
X */
X#define ICED_POOL	8
X#define ICED_MOAT	16
X
X/*
X * The structure describing a coordinate position.
X * Before adding fields, remember that this will significantly affect
X * the size of temporary files and save files.
X */
Xstruct rm {
X	int glyph;		/* what the hero thinks is there */
X	schar typ;		/* what is really there */
X	Bitfield(seen,1);	/* speed hack for room walls on corridors */
X	Bitfield(lit,1);	/* speed hack for lit rooms */
X	Bitfield(flags,5);	/* extra information for typ */
X	Bitfield(horizontal,1);	/* wall/door/etc is horiz. (more typ info) */
X	Bitfield(waslit,1);	/* remember if a location was lit */
X	Bitfield(roomno,6);	/* room # for special rooms */
X	Bitfield(edge,1);	/* marks boundaries for special rooms*/
X};
X
X#define doormask	flags
X#define altarmask	flags
X#define diggable	flags
X#define ladder		flags
X#define drawbridgemask	flags
X#define looted		flags
X#define icedpool	flags
X
X#define blessedftn      horizontal  /* a fountain that grants attribs */
X
Xstruct damage {
X	struct damage *next;
X	long when, cost;
X	coord place;
X	schar typ;
X};
X
Xstruct levelflags {
X	uchar	nfountains;	/* Number of fountains on level */
X	uchar	nsinks;		/* Number of sinks on the level */
X	/* Several flags that give hints about what's on the level */
X	Bitfield(has_shop, 1);
X	Bitfield(has_vault, 1);
X	Bitfield(has_zoo, 1);
X	Bitfield(has_court, 1);
X	Bitfield(has_morgue, 1);
X	Bitfield(has_beehive, 1);
X#ifdef ARMY
X	Bitfield(has_barracks, 1);
X#endif
X	Bitfield(has_temple, 1);
X	Bitfield(has_swamp, 1);
X	Bitfield(noteleport,1);
X	Bitfield(hardfloor,1);
X	Bitfield(nommap,1);
X	Bitfield(hero_memory,1);	/* hero has memory */
X	Bitfield(shortsighted,1);	/* monsters are shortsighted */
X	Bitfield(is_maze_lev,1);
X	Bitfield(is_cavernous_lev,1);
X};
X
Xtypedef struct
X{
X    struct rm		locations[COLNO][ROWNO];
X#ifndef MICROPORT_BUG
X    struct obj		*objects[COLNO][ROWNO];
X    struct monst	*monsters[COLNO][ROWNO];
X#else
X    struct obj		*objects[1][ROWNO];
X    char		*yuk1[COLNO-1][ROWNO];
X    struct monst	*monsters[1][ROWNO];
X    char		*yuk2[COLNO-1][ROWNO];
X#endif
X    struct obj		*objlist;
X    struct monst	*monlist;
X    struct damage	*damagelist;
X    struct levelflags	flags;
X}
Xdlevel_t;
X
Xextern dlevel_t	level;	/* structure describing the current level */
X
X/*
X * Macros for compatibility with old code. Someday these will go away.
X */
X#define levl		level.locations
X#define fobj		level.objlist
X#define fmon		level.monlist
X
X#define OBJ_AT(x,y)	(level.objects[x][y] != (struct obj *)0)
X/*
X * Macros for encapsulation of level.monsters references.
X */
X#define MON_AT(x,y)	(level.monsters[x][y] != (struct monst *)0)
X#define place_monster(m,x,y)	((m)->mx=(x),(m)->my=(y),\
X				 level.monsters[(m)->mx][(m)->my]=(m))
X#define place_worm_seg(m,x,y)	level.monsters[x][y] = m
X#define remove_monster(x,y)	level.monsters[x][y] = (struct monst *)0
X#define m_at(x,y)		level.monsters[x][y]
X
X#endif /* RM_H */
END_OF_FILE
if test 10031 -ne `wc -c <'include/rm.h'`; then
    echo shar: \"'include/rm.h'\" unpacked with wrong size!
fi
# end of 'include/rm.h'
fi
if test -f 'src/bones.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/bones.c'\"
else
echo shar: Extracting \"'src/bones.c'\" \(9436 characters\)
sed "s/^X//" >'src/bones.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)bones.c	3.1	93/01/07	*/
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985,1993. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include "hack.h"
X#include "lev.h"
X
X#ifdef MFLOPPY
Xextern char bones[];	/* from files.c */
Xextern long bytes_counted;
X#endif
X
Xstatic boolean FDECL(no_bones_level, (d_level *));
X#ifdef TUTTI_FRUTTI
Xstatic void FDECL(goodfruit, (int));
X#endif
Xstatic void FDECL(resetobjs,(struct obj *,BOOLEAN_P));
Xstatic void FDECL(drop_upon_death, (struct monst *, struct obj *));
X
Xstatic boolean
Xno_bones_level(lev)
Xd_level *lev;
X{
X	extern d_level save_dlevel;		/* in do.c */
X	s_level *sptr;
X
X	if (ledger_no(&save_dlevel)) assign_level(lev, &save_dlevel);
X
X	return (((sptr = Is_special(lev)) && !sptr->boneid)
X		|| !dungeons[lev->dnum].boneid
X		   /* no bones on the last or multiway branch levels */
X		   /* in any dungeon (level 1 isn't multiway).       */
X		|| Is_botlevel(lev) || (Is_branchlev(lev) && lev->dlevel > 1)
X		   /* no bones in the invocation level               */
X		|| (In_hell(lev) && lev->dlevel == dunlevs_in_dungeon(lev) - 1)
X		);
X}
X
X#ifdef TUTTI_FRUTTI
Xstatic void
Xgoodfruit(id)
Xint id;
X{
X	register struct fruit *f;
X
X	for(f=ffruit; f; f=f->nextf) {
X		if(f->fid == -id) {
X			f->fid = id;
X			return;
X		}
X	}
X}
X#endif
X
Xstatic void
Xresetobjs(ochain,restore)
Xstruct obj *ochain;
Xboolean restore;
X{
X	struct obj *otmp;
X
X	for (otmp = ochain; otmp; otmp = otmp->nobj) {
X		if (otmp->cobj)
X		    resetobjs(otmp->cobj,restore);
X
X		if (((otmp->otyp != CORPSE || otmp->corpsenm < PM_ARCHEOLOGIST)
X			&& otmp->otyp != STATUE)
X			&& (!otmp->oartifact ||
X			    (exist_artifact(otmp->otyp,ONAME(otmp)) && restore))) {
X			otmp->oartifact = 0;
X			otmp->onamelth = 0;
X			*ONAME(otmp) = '\0';
X		} else if (otmp->oartifact && restore)
X			artifact_exists(otmp,ONAME(otmp),TRUE);
X		if (!restore) {
X			/* resetting the o_id's after getlev has carefully
X			 * created proper new ones via restobjchn is a Bad
X			 * Idea */
X			otmp->o_id = 0;
X			if(objects[otmp->otyp].oc_uses_known) otmp->known = 0;
X			otmp->dknown = otmp->bknown = 0;
X			otmp->rknown = 0;
X			otmp->invlet = 0;
X#ifdef TUTTI_FRUTTI
X			if(otmp->otyp == SLIME_MOLD) goodfruit(otmp->spe);
X#endif
X#ifdef MAIL
X			if (otmp->otyp == SCR_MAIL) otmp->spe = 1;
X#endif
X#ifdef POLYSELF
X			if (otmp->otyp == EGG) otmp->spe = 0;
X#endif
X			if(otmp->otyp == AMULET_OF_YENDOR) {
X				/* no longer the actual amulet */
X				otmp->otyp = FAKE_AMULET_OF_YENDOR;
X				curse(otmp);
X			}
X			if(otmp->otyp == CANDELABRUM_OF_INVOCATION) {
X			    if(otmp->spe > 0) { /* leave candles, if any */
X			        otmp->otyp = WAX_CANDLE;
X				otmp->age = 50L;  /* assume used */
X				otmp->quan = (long)otmp->spe;
X				otmp->lamplit = 0;
X				otmp->spe = 0;
X			    } else obfree(otmp, (struct obj *)0);
X			}
X			if(otmp->otyp == BELL_OF_OPENING) otmp->otyp = BELL;
X			if(otmp->otyp == SPE_BOOK_OF_THE_DEAD) {
X			    otmp->otyp = SPE_MAGIC_MISSILE +
X			                    rn2(SPE_BLANK_PAPER -
X						  SPE_MAGIC_MISSILE + 1);
X			    curse(otmp);
X			}
X		}
X	}			
X}
X
Xstatic void
Xdrop_upon_death(mtmp, cont)
Xstruct monst *mtmp;
Xstruct obj *cont;
X{
X	struct obj *otmp = invent;
X	while(otmp) {
X		otmp->owornmask = 0;
X		otmp->lamplit = 0;
X#ifdef TUTTI_FRUTTI
X		if(otmp->otyp == SLIME_MOLD) goodfruit(otmp->spe);
X#endif
X		if(rn2(5)) curse(otmp);
X		if(!mtmp && !cont) place_object(otmp, u.ux, u.uy);
X		if(!otmp->nobj) {
X			if (mtmp) {
X				otmp->nobj = mtmp->minvent;
X				mtmp->minvent = invent;
X			} else if (cont) {
X				otmp->nobj = cont->cobj;
X				cont->cobj = invent;
X			} else {
X				otmp->nobj = fobj;
X				fobj = invent;
X			}
X			invent = 0;	/* superfluous */
X			break;
X		}
X		otmp = otmp->nobj;
X	}
X	if(u.ugold) {
X		if (mtmp) mtmp->mgold = u.ugold;
X		else mkgold(u.ugold, u.ux, u.uy);
X	}
X}
X
X/* save bones and possessions of a deceased adventurer */
Xvoid
Xsavebones()
X{
X	register int fd, x, y;
X	register struct trap *ttmp;
X	register struct monst *mtmp, *mtmp2;
X#ifdef TUTTI_FRUTTI
X	struct fruit *f;
X#endif
X	char *bonesid;
X
X	if(ledger_no(&u.uz) <= 0 || ledger_no(&u.uz) > maxledgerno()) return;
X	if(no_bones_level(&u.uz)) return; /* no bones for specific levels */
X	if(!rn2(1 + (depth(&u.uz)>>2)) /* fewer ghosts on low levels */
X#ifdef WIZARD
X		&& !wizard
X#endif
X		) return;
X#ifdef EXPLORE_MODE
X	/* don't let multiple restarts generate multiple copies of objects
X	 * in bones files */
X	if(discover) return;
X#endif
X
X	fd = open_bonesfile(&u.uz, &bonesid);
X	if (fd >= 0) {
X		(void) close(fd);
X		compress_bonesfile();
X#ifdef WIZARD
X		if(wizard)
X			pline("Bones file already exists.");
X#endif
X		return;
X	}
X
X#ifdef WALKIES
X	unleash_all();
X#endif
X	/* in case these characters are not in their home bases */
X	mtmp2 = fmon;
X	while((mtmp = mtmp2)) {
X		mtmp2 = mtmp->nmon;
X		if(mtmp->iswiz || mtmp->data == &mons[PM_MEDUSA]) mongone(mtmp);
X	}
X#ifdef TUTTI_FRUTTI
X	/* mark all fruits as nonexistent; when we come to them we'll mark
X	 * them as existing (using goodfruit())
X	 */
X	for(f=ffruit; f; f=f->nextf) f->fid = -f->fid;
X#endif
X
X	/* check iron balls separately--maybe they're not carrying it */
X	if (uball) uball->owornmask = uchain->owornmask = 0;
X
X	/* dispose of your possessions, usually cursed */
X	if (u.ugrave_arise == -2) {
X		struct obj *otmp;
X
X		/* embed your possessions in your statue */
X		otmp = mk_named_object(STATUE,
X#ifdef POLYSELF
X					u.mtimedone ? uasmon :
X#endif
X					player_mon(), 
X					u.ux, u.uy, plname,
X					(int)strlen(plname));
X		if (!otmp) return;
X		drop_upon_death(mtmp = (struct monst *)0, otmp);
X	} else if (u.ugrave_arise == -1) {
X		/* drop everything */
X		drop_upon_death((struct monst *)0, (struct obj *)0);
X		/* trick makemon() into allowing monster creation
X		 * on your location
X		 */
X		in_mklev = TRUE;
X		mtmp = makemon(&mons[PM_GHOST], u.ux, u.uy);
X		in_mklev = FALSE;
X		if (!mtmp) return;
X		Strcpy((char *) mtmp->mextra, plname);
X	} else {
X		/* give your possessions to the monster you become */
X		in_mklev = TRUE;
X		mtmp = makemon(&mons[u.ugrave_arise], u.ux, u.uy);
X		in_mklev = FALSE;
X		if (!mtmp) return;
X		mtmp = christen_monst(mtmp, plname);
X		newsym(u.ux, u.uy);
X		Your("body rises from the dead as %s...",
X			an(mons[u.ugrave_arise].mname));
X		display_nhwindow(WIN_MESSAGE, FALSE);
X		drop_upon_death(mtmp, (struct obj *)0);
X#ifdef MUSE
X		m_dowear(mtmp, TRUE);
X#endif
X	}
X	if (mtmp) {
X		mtmp->m_lev = (u.ulevel ? u.ulevel : 1);
X		mtmp->mhp = mtmp->mhpmax = u.uhpmax;
X		mtmp->msleep = 1;
X	}
X	for(mtmp = fmon; mtmp; mtmp = mtmp->nmon) {
X		resetobjs(mtmp->minvent,FALSE);
X		mtmp->m_id = 0;
X		mtmp->mlstmv = 0L;
X		if(mtmp->mtame) mtmp->mtame = mtmp->mpeaceful = 0;
X	}
X	for(ttmp = ftrap; ttmp; ttmp = ttmp->ntrap) {
X	        if(ttmp->ttyp == MAGIC_PORTAL) deltrap(ttmp);
X		ttmp->tseen = 0;
X	}
X	resetobjs(fobj,FALSE);
X
X	/* Clear all memory from the level. */
X	for(x=0; x<COLNO; x++) for(y=0; y<ROWNO; y++) {
X	    levl[x][y].seen = levl[x][y].waslit = 0;
X	    levl[x][y].glyph = cmap_to_glyph(S_stone);
X	}
X
X	fd = create_bonesfile(&u.uz, &bonesid);
X	if(fd < 0) {
X#ifdef WIZARD
X		if(wizard)
X			pline("Cannot create bones file - create failed");
X#endif
X		return;
X	}
X
X	bufon(fd);
X#ifdef MFLOPPY  /* check whether there is room */
X	savelev(fd, ledger_no(&u.uz), COUNT_SAVE);
X# ifdef TUTTI_FRUTTI
X	/* this is in the opposite order from the real save, but savelev()
X	 * initializes bytes_counted to 0, so doing savefruitchn() first is
X	 * useless; the extra bflush() at the end of savelev() may increase
X	 * bytes_counted by a couple over what the real usage will be
X	 */
X	savefruitchn(fd, COUNT_SAVE);
X	bflush(fd);
X# endif
X	if (bytes_counted > freediskspace(bones)) {	/* not enough room */
X# ifdef WIZARD
X		if (wizard)
X			pline("Insufficient space to create bones file.");
X# endif
X		(void) close(fd);
X		delete_bonesfile(&u.uz);
X		return;
X	}
X	co_false();	/* make sure bonesid and savefruitchn get written */
X#endif /* MFLOPPY */
X
X	bwrite(fd, (genericptr_t) bonesid, 7);	/* DD.nnn */
X#ifdef TUTTI_FRUTTI
X	savefruitchn(fd, WRITE_SAVE | FREE_SAVE);
X#endif
X	savelev(fd, ledger_no(&u.uz), WRITE_SAVE | FREE_SAVE);
X	bclose(fd);
X	compress_bonesfile();
X}
X
Xint
Xgetbones()
X{
X	register int fd;
X	register int ok;
X	char *bonesid, oldbonesid[7];
X
X#ifdef EXPLORE_MODE
X	if(discover)		/* save bones files for real games */
X		return(0);
X#endif
X	/* wizard check added by GAN 02/05/87 */
X	if(rn2(3)	/* only once in three times do we find bones */
X#ifdef WIZARD
X		&& !wizard
X#endif
X		) return(0);
X	if(no_bones_level(&u.uz)) return(0);
X	fd = open_bonesfile(&u.uz, &bonesid);
X	if (fd < 0) return(0);
X
X	if((ok = uptodate(fd)) != 0){
X#ifdef WIZARD
X		if(wizard)  {
X			if(yn("Get bones?") == 'n') {
X				(void) close(fd);
X				compress_bonesfile();
X				return(0);
X			}
X		}
X#endif
X		minit();	/* ZEROCOMP */
X		mread(fd, (genericptr_t) oldbonesid, 7);	/* DD.nnn */
X		if (strcmp(bonesid, oldbonesid)) {
X#ifdef WIZARD
X			if (wizard) {
X				pline("This is bones level '%s', not '%s'!",
X					oldbonesid, bonesid);
X				ok = FALSE;	/* won't die of trickery */
X			}
X#endif
X			trickery();
X		} else {
X			register struct monst *mtmp;
X
X			getlev(fd, 0, 0, TRUE);
X
X			/* to correctly reset named artifacts on the level */
X			for(mtmp = fmon; mtmp; mtmp = mtmp->nmon)
X				resetobjs(mtmp->minvent,TRUE);
X			resetobjs(fobj,TRUE);
X		}
X	}
X	(void) close(fd);
X
X#ifdef WIZARD
X	if(wizard) {
X		if(yn("Unlink bones?") == 'n') {
X			compress_bonesfile();
X			return(ok);
X		}
X	}
X#endif
X	if (!delete_bonesfile(&u.uz)) {
X		pline("Cannot unlink bones.");
X		return(0);
X	}
X	return(ok);
X}
X
X/*bones.c*/
END_OF_FILE
if test 9436 -ne `wc -c <'src/bones.c'`; then
    echo shar: \"'src/bones.c'\" unpacked with wrong size!
fi
# end of 'src/bones.c'
fi
if test -f 'sys/amiga/splitter/loader.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/amiga/splitter/loader.c'\"
else
echo shar: Extracting \"'sys/amiga/splitter/loader.c'\" \(9595 characters\)
sed "s/^X//" >'sys/amiga/splitter/loader.c' <<'END_OF_FILE'
X/* 	SCCS Id: @(#)loader.c 3.1	93/01/08
X/*	Copyright (c) Kenneth Lorber, Bethesda, Maryland 1992, 1993 */
X/* NetHack may be freely redistributed.  See license for details. */
X
X/*
X * Amiga split binary runtime system
X */
X
X/*#define LDEBUG	 	/* turn on debugging I/O */
X#define SDEBUG		/* static primary array allocation */
X/*#define NOCLEAN		/* turn off $ovl_memchain code */
X/*#define NOSPLIT		/* debug: load an unsplit binary(run ONCE!)*/
X#define MULTI			/* real file reading code */
X/*#define PARANOID		/* check for refs off end that might be OK */
X#define CACHE			/* deal with cache flushing */
X
Xunsigned long xx;
Xlong *yy;
X
X#include "split.h"
X
X#ifdef SPLIT
X
X#include <stdio.h>		/* for spanic - should change */
X#include <exec/types.h>
X#include <exec/memory.h>
X#include <libraries/dosextens.h>
X#include <proto/dos.h>
X#include <proto/exec.h>
X#include <dos.h>			/* NOT libraries/dos.h! */
X#include "amiout.h"
X
X#include "multi.h"
X
X#define F_LOAD 0
X#define F_RELOAD 1
X
X#define HT(x)	((x) & ~MEM_OBJ_EXTEND)
X
Xvoid *$ovl_AllocMem(unsigned int);
Xvoid spanic(char *);			/* think about this!!!! */
Xvoid exit(int);
X
X#ifdef SDEBUG
Xunsigned long *$ovl_hunktable[500];	/* 223 as of 10/21/92 */
X#else
Xunsigned long *(*$ovl_hunktable)[];
Xint $ovl_hunktablesize;
X#endif
X
X#ifndef NOCLEAN
XBPTR $ovlmemchain=0;
X#endif
XBPTR ovlfile=0;
XBPTR fh;
XULONG database;
X
XBPTR s_LoadSeg(char *);
Xvoid s_UnLoadSeg(void);
XBPTR load_code(int,char *);
Xvoid load_data(int,char *);
Xunsigned long *load_hunk(BPTR,int,ULONG *);
X
X#ifdef MULTI
Xunion multiopts mo;
X	/* dump these after testing */
X#define Read MultiRead
X#define Close MultiClose
X#endif
X
XBPTR
Xs_LoadSeg(dir)
X	char *dir;
X	{
X	static BPTR base;
X	static char never=1;
X	if(never){
X#ifdef LDEBUG
X		fprintf(stderr,"s_LoadSeg waiting\n");
X		Delay(100);
X		fprintf(stderr,"going\n");
X#endif
X		base=load_code(F_LOAD,dir);
X#ifndef NOSPLIT
X		load_data(F_LOAD,dir);
X		never=0;
X#endif
X	}else{
X		load_data(F_RELOAD,dir);
X	}
X#ifdef LDEBUG
X	fprintf(stderr,"loadseg done! (waiting)\n");
X	getchar();
X#endif
X#ifdef CACHE
X	{
X	struct Library *eb=OpenLibrary("exec.library",36);
X	if(eb){
X		CacheClearU();
X		CloseLibrary(eb);
X	} else {
X		/* force a context switch and hope for the best */
X		Delay(1);
X	}
X	}
X#endif
X	return(base);
X}
X
XBPTR
Xload_code(dummy,dir)
X	int dummy;	/* always F_LOAD */
X	char *dir;	/* direction file */
X{
X	ULONG x;
X	ULONG *xp;
X	ULONG c,hc;
X	ULONG r;
X#ifdef MULTI
X	mo.r.mor_tag='C';
X	fh=MultiOpen(dir,MODE_OLDFILE,&mo);
X#else
X	fh=Open("s_NetHack.c00",MODE_OLDFILE);
X#endif
X	if(fh==0){
X		fprintf(stderr,"open failed %d\n",IoErr());
X		spanic("missing code file");
X	}
X	Read(fh,&x,4);	/* HUNK_HEADER */
X	Read(fh,&x,4);	/* 0 */
X	Read(fh,&hc,4);	/* table size */
X#ifdef LDEBUG
X	fprintf(stderr,"hunk count=%d\n",hc);
X#endif
X#ifndef SDEBUG
X	$ovl_hunktable= (long*(*)[])$ovl_AllocMem(hc*4);
X	$ovl_hunktablesize=hc*4;
X#endif
X#ifdef LDEBUG
X	fprintf(stderr,"table at %08x\n",$ovl_hunktable);
X#endif
X	Read(fh,&x,4);	/* F==0 */
X	Read(fh,&x,4);	/* L==size-1 */
X	for(c=0;c<hc;c++){
X		Read(fh,&x,4);
X#ifdef SDEBUG
X		xx=$ovl_hunktable[c]=$ovl_AllocMem(x*4);
X#else
X		xx=(*$ovl_hunktable)[c]=$ovl_AllocMem(x*4);
X#endif
X#ifdef LDEBUG
X		fprintf(stderr,"t[%d]=%08x, len=%08x\n",c,xx,((long*)xx)[-2]);
X#endif
X	}
X#ifdef LDEBUG
X	fprintf(stderr,"TABLE LOADED\n");Delay(50);
X#endif
X	for(c=0,xp=(unsigned long*)1;xp;c++){
X#ifdef LDEBUG
X# ifdef SDEBUG
X		yy=$ovl_hunktable[c];
X# else
X		yy=(*$ovl_hunktable)[c];
X# endif
X		fprintf(stderr,"loading hunk %d@%08x len=%08x\n",c,yy,yy[-2]);
X#endif
X#ifdef SDEBUG
X		xp=load_hunk(fh,dummy,$ovl_hunktable[c]);
X#else
X		xp=load_hunk(fh,dummy,(*$ovl_hunktable)[c]);
X#endif
X	}
X	database=c-1;	/* first hunk for use for data on each load */
X	Close(fh);
X#ifdef LDEBUG
X# ifdef SDEBUG
X	fprintf(stderr,"retval=%08x\n",$ovl_hunktable[0]);
X# else
X	fprintf(stderr,"retval=%08x\n",(*$ovl_hunktable)[0]);
X# endif
X#endif
X#ifdef SDEBUG
X	r= (unsigned long) $ovl_hunktable[0];		/* BPTR to seglist */
X#else
X	r= (unsigned long) (*$ovl_hunktable)[0];	/* BPTR to seglist */
X#endif
X	return (BPTR)(r>>2)-1;
X}
X
Xvoid
Xload_data(fl,dir)
X	int fl;
X	char *dir;
X{
X	int c;
X	unsigned long *x;
X#ifdef MULTI
X	mo.r.mor_tag='D';
X	fh=MultiOpen(dir,MODE_OLDFILE,&mo);
X#else
X	fh=Open("s_NetHack.d00",MODE_OLDFILE);
X#endif
X			/* doing it this way we don't need the hunk count */
X	for(c=database,x=(unsigned long*)1;x;c++){
X#ifdef SDEBUG
X		x=load_hunk(fh,fl,$ovl_hunktable[c]);
X#else
X		x=load_hunk(fh,fl,(*$ovl_hunktable)[c]);
X#endif
X	}
X#ifdef LDEBUG
X	fprintf(stderr,"end of load_data (waiting)\n");
X	getchar();
X#endif
X	Close(fh);
X}
X
Xunsigned long *
Xload_hunk(ovlfile,fl,lbase)
X	BPTR ovlfile;		/* AmigaDOS file handle */
X	int fl;
X	ULONG *lbase;
X{
X	unsigned long data[2];
X	unsigned long *where;
X	unsigned long reloc_type;
X
X#ifdef LDEBUG
X	{
X	int pos=Seek(ovlfile,0,0);
X	fprintf(stderr,"load_hunk (fpos=%08x) @%08x len=%08x(%08x)\n",pos,
X	lbase,lbase[-2],lbase[-2]/4);
X	}
X#endif
X	if(0==Read(ovlfile,data,sizeof(data))){
X#ifdef LDEBUG
X		fprintf(stderr,"getchar EOF\n");
X		getchar();
X#endif
X		return(0);	/* EOF */
X	}
X#ifdef LDEBUG
X	fprintf(stderr,"read type=%08x len=%08x(longs)\n",data[0],data[1]);
X#endif
X	if( HT(data[0])!=HUNK_CODE &&
X	    HT(data[0])!=HUNK_DATA &&
X	    HT(data[0])!=HUNK_BSS){
X		fprintf(stderr,"bad data=%08x\n",data[0]);
X		spanic("ovlfile cookie botch");
X	}
X	where=lbase;
X#if 0
X				/* clear memory if:
X				 * 1. not the first time (MEMF_CLEAR'd already)
X				 * 2. data or bss (just in case)
X				 * This is just a sanity check since these are
X				 * the only hunks we should be seeing on reload.
X				 */
X	if(fl==F_RELOAD && (HT(data[0])==HUNK_DATA || HT(data[0])==HUNK_BSS)
X#endif
X	{
X		ULONG *p=where;		/* clear memory block */
X		ULONG c=(where[-2]/4)-1;	/* (len includes ptr) */
X		if(!TypeOfMem(p))spanic("clearing bogus memory");
X		while(c--)*p++=0;	/* not memset - use longs for speed */
X	}
X
X	if(HT(data[0])==HUNK_DATA || HT(data[0])==HUNK_CODE){
X		xx=Read(ovlfile,where,data[1]*4);	/* load the block */
X		if(xx!=data[1]*4){
X			fprintf(stderr,"Read(%08x,%08x)->%08x\n",where,
X			  data[1]*4,xx);
X			spanic("out of data");
X		}
X	} else {
X#ifdef LDEBUG
X		fprintf(stderr,"BSS - no load\n");
X#endif
X	}
X			/* link/relocate as needed */
X			/* NB this could be done faster if we keep a buffer of
X			 * relocation information (instead of issuing 4 byte
X			 * Reads)
X			 */
X	xx=Read(ovlfile,&reloc_type,sizeof(reloc_type));
X	if(xx!=sizeof(reloc_type))spanic("lost reloc_type");
X	while(reloc_type!=HUNK_END){
X		unsigned long reloc_count;
X		unsigned long reloc_hunk;
X		unsigned long *base;
X		unsigned long reloc_offset;
X		if(reloc_type!=HUNK_RELOC32){
X			if(reloc_type==HUNK_END)continue;	/* and quit */
X			fprintf(stderr,"bad data %08x\n",reloc_type);
X			spanic("ovlfile reloc cookie botch");
X		}
X		xx=Read(ovlfile,&reloc_count,sizeof(reloc_count));
X		if(xx!=sizeof(reloc_count))spanic("lost reloc_count");
X		while(reloc_count){
X			xx=Read(ovlfile,&reloc_hunk,sizeof(reloc_hunk));
X			if(xx!=sizeof(reloc_count))spanic("lost reloc_hunk");
X#ifdef SDEBUG
X			base=$ovl_hunktable[reloc_hunk];
X#else
X			base=(*$ovl_hunktable)[reloc_hunk];
X#endif
X#ifdef LDEBUG
X			fprintf(stderr,"reloc #%d: hunk #%d@%08x\n",
X			  reloc_count,reloc_hunk,base);
X#endif
X			while(reloc_count--){
X				xx=Read(ovlfile,&reloc_offset,sizeof(long));
X				if(xx!=sizeof(reloc_count))
X					spanic("lost offset");
X				if(reloc_offset<0 || reloc_offset>where[-2]){
X					fprintf(stderr,"where[-2]==%08x\n",
X					  where[-2]);
X					spanic("offset out of hunk");
X				}
X				{
X				ULONG *p=(ULONG*)(((ULONG)where)+reloc_offset);
X#ifdef PARANOID
X/* NB - nasty violation of signed/unsigned here */
X				{
X				if(*p > base[-2])
X				  fprintf(stderr,
X				  "WARNING: offset points outside block\n");
X				}
X#endif
X#ifdef LDEBUG
X				fprintf(stderr,
X				  "reloc_offset=%08x where=%08x p=%08x\n",
X				  reloc_offset,where,p);
X				fprintf(stderr," current *p=%08x\n",*p);
X#endif
X				(*p)+=(unsigned long)base;
X#ifdef LDEBUG
X				fprintf(stderr," new *p=%08x\n",*p);
X#endif
X				}
X			}
X			xx=Read(ovlfile,&reloc_count,sizeof(reloc_count));
X			if(xx!=sizeof(reloc_count))spanic("lost reloc_count2");
X		}
X		xx=Read(ovlfile,&reloc_type,sizeof(reloc_type));
X		if(xx!=sizeof(reloc_count))spanic("lost reloc_type2");
X	}
X	return(where);			/* return execute start point */
X}
X
X/*
X	-2	len (bytes)
X	-1	next block
X	 0	data
X */
Xvoid *
X$ovl_AllocMem(len)
X	unsigned int len;
X	{
X	unsigned long *adr;
X	ULONG length=(len&0x0fffffff);
X				/* Always clear the memory.  On reload of
X				 * bss or data we have to do it manually */
X	adr=AllocMem(length+8,(6&(len>>29))|MEMF_CLEAR);
X	{
X		int type=6&(len>>29);
X		if(	type!=MEMF_CHIP &&
X			type!=MEMF_FAST &&
X			type!=MEMF_PUBLIC &&
X			type != 0
X		){
X			printf("%08x %08x* ",len,type);
X			spanic("bad memory type");
X		}
X	}
X	if(!adr)spanic("allocation failure");
X	adr[0]=length;
X#ifndef NOCLEAN
X	adr[1]=(unsigned long)$ovlmemchain;	/* list for freeing at end */
X	$ovlmemchain=((long)adr>>2)+1;	/* BPTR to next ptr */
X# ifdef LDEBUG
X	fprintf(stderr,"Alloc: adr[0]=%08x adr[1]=%08x\n",adr[0],adr[1]);
X# endif
X#endif
X	return adr+2;
X}
X
Xvoid
Xs_UnLoadSeg()
X{
X#ifndef NOCLEAN
X	BPTR p,p1;
X
X# ifdef LDEBUG
X	fprintf(stderr,"starting Free loop: ovlmemchain=%x\n",$ovlmemchain);
X# endif
X	for(p=$ovlmemchain;p;p=p1){
X		p1=*(BPTR *)BADDR(p);
X# ifdef LDEBUG
X		fprintf(stderr,"Free(%x,%x)\n",BADDR(p-1),
X		  (*(long *)BADDR(p-1))+8);
X# endif
X		FreeMem(BADDR(p-1),(*(long *)BADDR(p-1))+8);
X	}
X#endif
X#ifndef SDEBUG
X	FreeMem($ovl_hunktable,$ovl_hunktablesize);
X#endif
X	return;
X}
X
X/* this needs to be improved and integrated with wb.c */
Xvoid
Xspanic(s)
X	char *s;
X{
X	fprintf(stderr,"s_LoadSeg failed: %s\n",s);
X	getchar();
X	exit(1);
X}
X#endif /* SPLIT */
END_OF_FILE
if test 9595 -ne `wc -c <'sys/amiga/splitter/loader.c'`; then
    echo shar: \"'sys/amiga/splitter/loader.c'\" unpacked with wrong size!
fi
# end of 'sys/amiga/splitter/loader.c'
fi
if test -f 'sys/share/pcmain.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/share/pcmain.c'\"
else
echo shar: Extracting \"'sys/share/pcmain.c'\" \(9810 characters\)
sed "s/^X//" >'sys/share/pcmain.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)pcmain.c	3.1	92/12/04	*/
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X/* main.c - MSDOS, OS/2, ST, and Amiga NetHack */
X
X#include "hack.h"
X
X#ifndef NO_SIGNAL
X#include <signal.h>
X#endif
X
X#include <ctype.h>
X
X#if !defined(AMIGA) && !defined(GNUDOS)
X#include <sys\stat.h>
X#else
X# ifdef GNUDOS
X#include <sys/stat.h>
X# endif
X#endif
X
X#if !defined(LATTICE)
Xchar orgdir[PATHLEN];
X#endif
X
X#ifdef MFLOPPY
Xstruct finfo	zfinfo = ZFINFO;
Xint i;
X#endif /* MFLOPPY */
X
X#ifdef TOS
Xboolean run_from_desktop = TRUE;	/* should we pause before exiting?? */
X# ifdef __GNUC__
Xlong _stksize = 16*1024;
X# endif
X#endif
X
X#ifdef AMIGA
Xextern int bigscreen;
X#endif
X
Xstatic void FDECL(process_options,(int argc,char **argv));
X
Xint FDECL(main, (int,char **));
X
Xconst char *classes = "ABCEHKPRSTVW";
X
Xint
Xmain(argc,argv)
Xint argc;
Xchar *argv[];
X{
X	register int fd;
X	register char *dir;
X#ifdef TOS
X	long clock_time;
X	if (*argv[0]) {			/* only a CLI can give us argv[0] */
X		hname = argv[0];
X		run_from_desktop = FALSE;
X	} else
X#endif
X		hname = "NetHack";	/* used for syntax messages */
X
X	choose_windows(DEFAULT_WINDOW_SYS);
X
X#if !defined(AMIGA) && !defined(GNUDOS)
X	/* Save current directory and make sure it gets restored when
X	 * the game is exited.
X	 */
X	if (getcwd(orgdir, sizeof orgdir) == NULL)
X		error("NetHack: current directory path too long");
X# ifndef NO_SIGNAL
X	signal(SIGINT, (SIG_RET_TYPE) exit);	/* restore original directory */
X# endif
X#endif /* !AMIGA && !GNUDOS */
X
X	dir = getenv("NETHACKDIR");
X	if (dir == NULL)
X		dir = getenv("HACKDIR");
X	if (dir != NULL) {
X		Strcpy(hackdir, dir);
X#ifdef CHDIR
X		chdirx (dir, 1);
X#endif
X	}
X#if defined(AMIGA) && defined(CHDIR)
X	/*
X	 * If we're dealing with workbench, change the directory.  Otherwise
X	 * we could get "Insert disk in drive 0" messages. (Must be done
X	 * before initoptions())....
X	 */
X	if(argc == 0)
X		chdirx(HACKDIR, 1);
X#endif
X
X#ifdef MFLOPPY
X	/* zero "fileinfo" array to prevent crashes on level change */
X	for (i = 0 ; i <= MAXLEVEL; i++) {
X		fileinfo[i] = zfinfo;
X	}
X#endif /* MFLOPPY */
X#ifdef AMIGA
X	ami_argc=argc;
X	ami_argv=argv;
X#endif
X	initoptions();
X
X#if defined(TOS) && defined(TEXTCOLOR)
X	if (flags.BIOS && flags.use_color)
X		set_colors();
X#endif
X	if (!hackdir[0])
X#if !defined(LATTICE) && !defined(AMIGA)
X		Strcpy(hackdir, orgdir);
X#else
X		Strcpy(hackdir, HACKDIR);
X#endif
X	if(argc > 1) {
X	    if (!strncmp(argv[1], "-d", 2) && argv[1][2] != 'e') {
X		/* avoid matching "-dec" for DECgraphics; since the man page
X		 * says -d directory, hope nobody's using -desomething_else
X		 */
X		argc--;
X		argv++;
X		dir = argv[0]+2;
X		if(*dir == '=' || *dir == ':') dir++;
X		if(!*dir && argc > 1) {
X			argc--;
X			argv++;
X			dir = argv[0];
X		}
X		if(!*dir)
X		    error("Flag -d must be followed by a directory name.");
X		Strcpy(hackdir, dir);
X	    } else
X
X	/*
X	 * Now we know the directory containing 'record' and
X	 * may do a prscore().
X	 */
X	    if (!strncmp(argv[1], "-s", 2)) {
X#ifdef CHDIR
X		chdirx(hackdir,0);
X#endif
X		prscore(argc, argv);
X		exit(0);
X	    }
X	}
X
X	/*
X	 * It seems you really want to play.
X	 */
X	setrandom();
X
X#ifdef TOS
X	if (comp_times((long)time(&clock_time)))
X		error("Your clock is incorrectly set!");
X#endif
X	u.uhp = 1;	/* prevent RIP on early quits */
X	u.ux = 0;	/* prevent flush_screen() */
X
X	/*
X	 * Find the creation date of this game,
X	 * so as to avoid restoring outdated savefiles.
X	 */
X	/* gethdate(hname); */
X
X	/*
X	 * We cannot do chdir earlier, otherwise gethdate will fail.
X	 */
X#ifdef CHDIR
X	chdirx(hackdir,1);
X#endif
X
X	process_options(argc, argv);
X
X#ifdef AMIGA
X	ami_wbench_args();
X#endif
X	init_nhwindows();
X#ifdef MFLOPPY
X	set_lock_and_bones();
X# ifndef AMIGA
X	copybones(FROMPERM);
X# endif
X#endif
X#ifdef WIZARD
X	if (wizard)
X		Strcpy(plname, "wizard");
X	else
X#endif
X	if (!*plname)
X		askname();
X	plnamesuffix();		/* strip suffix from name; calls askname() */
X				/* again if suffix was whole name */
X				/* accepts any suffix */
X#ifndef MFLOPPY
X	Strcpy(lock,plname);
X	Strcat(lock,".99");
X	regularize(lock);	/* is this necessary? */
X#endif
X
X	/* set up level 0 file to keep game state in */
X	/* this will have to be expanded to something like the
X	 * UNIX/VMS getlock() to allow networked PCs in any case
X	 */
X	fd = create_levelfile(0);
X	if (fd < 0) {
X		raw_print("Cannot create lock file");
X	} else {
X		hackpid = 1;
X		write(fd, (genericptr_t) &hackpid, sizeof(hackpid));
X		close(fd);
X	}
X#ifdef MFLOPPY
X	    fileinfo[0].where = ACTIVE;
X#endif
X
X	/*
X	 * Initialisation of the boundaries of the mazes
X	 * Both boundaries have to be even.
X	 */
X
X	x_maze_max = COLNO-1;
X	if (x_maze_max % 2)
X		x_maze_max--;
X	y_maze_max = ROWNO-1;
X	if (y_maze_max % 2)
X		y_maze_max--;
X
X	/*
X	 *  Initialize the vision system.  This must be before mklev() on a
X	 *  new game or before a level restore on a saved game.
X	 */
X	vision_init();
X
X	display_gamewindows();
X
X	set_savefile_name();
X
X	if (
X#ifdef MFLOPPY
X# ifdef AMIGA
X	    (FromWBench || saveDiskPrompt(1)) &&
X# else
X	    saveDiskPrompt(1) &&
X# endif
X#endif /* MFLOPPY */
X	    ((fd = open_savefile()) >= 0) &&
X	   /* if not up-to-date, quietly unlink file via false condition */
X	   (uptodate(fd) || ((void)close(fd), delete_savefile()))) {
X#ifdef WIZARD
X		/* Since wizard is actually flags.debug, restoring might
X		 * overwrite it.
X		 */
X		boolean remember_wiz_mode = wizard;
X#endif
X#ifndef NO_SIGNAL
X		(void) signal(SIGINT, (SIG_RET_TYPE) done1);
X#endif
X#ifdef NEWS
X		if(flags.news) display_file(NEWS, FALSE);
X#endif
X		pline("Restoring save file...");
X		mark_synch();	/* flush output */
X
X		if(!dorecover(fd))
X			goto not_recovered;
X#ifdef WIZARD
X		if(!wizard && remember_wiz_mode) wizard = TRUE;
X#endif
X		pline("Hello %s, welcome back to NetHack!", plname);
X		check_special_room(FALSE);
X
X#ifdef EXPLORE_MODE
X		if (discover)
X			You("are in non-scoring discovery mode.");
X#endif
X#if defined(EXPLORE_MODE) || defined(WIZARD)
X		if (discover || wizard) {
X			if(yn("Do you want to keep the save file?") == 'n'){
X				(void) delete_savefile();
X			}
X#ifdef AMIGA
X			else
X				preserve_icon();
X#endif
X		}
X#endif
X		flags.move = 0;
X	} else {
Xnot_recovered:
X		player_selection();
X		newgame();
X		/* give welcome message before pickup messages */
X		pline("Hello %s, welcome to NetHack!", plname);
X#ifdef EXPLORE_MODE
X		if (discover)
X			You("are in non-scoring discovery mode.");
X#endif
X		flags.move = 0;
X		set_wear();
X		pickup(1);
X		read_engr_at(u.ux,u.uy);
X	}
X	
X	flags.moonphase = phase_of_the_moon();
X	if(flags.moonphase == FULL_MOON) {
X		You("are lucky!  Full moon tonight.");
X		change_luck(1);
X	} else if(flags.moonphase == NEW_MOON) {
X		pline("Be careful!  New moon tonight.");
X	}
X	if(flags.friday13 = friday_13th()) {
X		pline("Watch out!  Bad things can happen on Friday the 13th.");
X		change_luck(-1);
X	}
X
X	initrack();
X#ifndef NO_SIGNAL
X	(void) signal(SIGINT, SIG_IGN);
X#endif
X#ifdef OS2
X	gettty(); /* somehow ctrl-P gets turned back on during startup ... */
X#endif
X
X	moveloop();
X	return 0;
X}
X
Xstatic void
Xprocess_options(argc, argv)
Xint argc;
Xchar *argv[];
X{
X	/*
X	 * Process options.
X	 */
X	while(argc > 1 && argv[1][0] == '-'){
X		argv++;
X		argc--;
X		switch(argv[0][1]){
X#if defined(WIZARD) || defined(EXPLORE_MODE)
X# ifndef EXPLORE_MODE
X		case 'X':
X# endif
X		case 'D':
X# ifdef WIZARD
X			/* Must have "name" set correctly by NETHACK.CNF,
X			 * NETHACKOPTIONS, or -u
X			 * before this flag to enter wizard mode. */
X#  ifdef KR1ED
X			if(!strcmp(plname, WIZARD_NAME)) {
X#  else
X			if(!strcmp(plname, WIZARD)) {
X#  endif
X				wizard = TRUE;
X				break;
X			}
X			/* otherwise fall thru to discover */
X# endif
X# ifdef EXPLORE_MODE
X		case 'X':
X			discover = TRUE;
X# endif
X			break;
X#endif
X#ifdef NEWS
X		case 'n':
X			flags.news = FALSE;
X			break;
X#endif
X		case 'u':
X			if(argv[0][2])
X			  (void) strncpy(plname, argv[0]+2, sizeof(plname)-1);
X			else if(argc > 1) {
X			  argc--;
X			  argv++;
X			  (void) strncpy(plname, argv[0], sizeof(plname)-1);
X			} else
X				raw_print("Player name expected after -u");
X			break;
X#ifndef AMIGA
X		case 'I':
X		case 'i':
X			if (!strncmpi(argv[0]+1, "IBM", 3))
X				switch_graphics(IBM_GRAPHICS);
X			break;
X	    /*  case 'D': */
X		case 'd':
X			if (!strncmpi(argv[0]+1, "DEC", 3))
X				switch_graphics(DEC_GRAPHICS);
X			break;
X#endif
X#ifdef MFLOPPY
X# ifndef AMIGA
X		/* Player doesn't want to use a RAM disk
X		 */
X		case 'r':
X			ramdisk = FALSE;
X			break;
X# endif
X#endif
X#ifdef AMIGA
X			/* interlaced and non-interlaced screens */
X		case 'L':
X			bigscreen = 1;
X			break;
X		case 'l':
X			bigscreen = -1;
X			break;
X#endif
X		default:
X			if (index(classes, toupper(argv[0][1]))) {
X				/* allow -T for Tourist, etc. */
X				(void) strncpy(pl_character, argv[0]+1,
X					       sizeof(pl_character)-1);
X				break;
X			} else raw_printf("\nUnknown switch: %s", argv[0]);
X		case '?':
X		    (void) printf(
X			"\nUsage: %s [-d dir] -s [-[%s]] [maxrank] [name]...",
X			hname, classes);
X		    (void) printf("\n       or");
X		    (void) printf("\n       %s [-d dir] [-u name] [-[%s]]",
X			hname, classes);
X#if defined(WIZARD) || defined(EXPLORE_MODE)
X		    (void) printf(" [-[DX]]");
X#endif
X#ifdef NEWS
X		    (void) printf(" [-n]");
X#endif
X#ifdef MFLOPPY
X# ifndef AMIGA
X		    (void) printf(" [-r]");
X# endif
X#endif
X		    putchar('\n');
X		    exit(0);
X		}
X	}
X}
X
X#ifdef CHDIR
Xvoid
Xchdirx(dir, wr)
Xchar *dir;
Xboolean wr;
X{
X#ifdef AMIGA
X	static char thisdir[] = "";
X#else
X	static char thisdir[] = ".";
X#endif
X	if(dir && chdir(dir) < 0) {
X		error("Cannot chdir to %s.", dir);
X	}
X
X	/* Change the default drive as well.
X	 */
X#ifndef AMIGA
X	chdrive(dir);
X#endif
X
X	/* warn the player if we can't write the record file */
X	/* perhaps we should also test whether . is writable */
X	/* unfortunately the access system-call is worthless */
X	if (wr) check_recordfile(dir ? dir : thisdir);
X}
X#endif /* CHDIR */
X
X/*pcmain.c*/
END_OF_FILE
if test 9810 -ne `wc -c <'sys/share/pcmain.c'`; then
    echo shar: \"'sys/share/pcmain.c'\" unpacked with wrong size!
fi
# end of 'sys/share/pcmain.c'
fi
if test -f 'win/X11/wintext.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'win/X11/wintext.c'\"
else
echo shar: Extracting \"'win/X11/wintext.c'\" \(9488 characters\)
sed "s/^X//" >'win/X11/wintext.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)wintext.c	3.1	92/3/7
X/* Copyright (c) Dean Luick, 1992				  */
X/* NetHack may be freely redistributed.  See license for details. */
X
X/*
X * File for dealing with text windows.
X * 
X * 	+ No global functions.
X */
X#include <X11/Intrinsic.h>
X#include <X11/StringDefs.h>
X#include <X11/Shell.h>
X#include <X11/Xos.h>
X#include <X11/Xaw/AsciiText.h>
X#include <X11/Xaw/Cardinals.h>
X
X#include "hack.h"
X#include "winX.h"
X
X
X#define TRANSIENT_TEXT	/* text window is a transient window (no positioning) */
X
Xstatic const char text_translations[] =
X    "#override\n\
X     <BtnDown>: dismiss_text()\n\
X     <Key>: key_dismiss_text()";
X
X/*
X * Callback used for all text windows.  The window is poped down on any key
X * or button down event.  It is destroyed if the main nethack code is done
X * with it.
X */
X/*ARGSUSED*/
Xvoid
Xdismiss_text(w, event, params, num_params)
X    Widget w;
X    XEvent *event;
X    String *params;
X    Cardinal *num_params;
X{
X    struct xwindow *wp;
X    struct text_info_t *text_info;
X    Widget popup = XtParent(w);
X
X    wp = find_widget(w);
X    text_info = wp->text_information;
X
X    nh_XtPopdown(popup);
X
X    if (text_info->blocked) {
X	exit_x_event = TRUE;
X    } else if (text_info->destroy_on_ack) {
X	destroy_text_window(wp);
X    }
X}
X
X/* Dismiss when a non-modifier key pressed. */
Xvoid
Xkey_dismiss_text(w, event, params, num_params)
X    Widget w;
X    XEvent *event;
X    String *params;
X    Cardinal *num_params;
X{
X    char ch = key_event_to_char((XKeyEvent *) event);
X    if (ch) dismiss_text(w, event, params, num_params);
X}
X
X/* ARGSUSED */
Xvoid
Xadd_to_text_window(wp, attr, str)
X    struct xwindow *wp;
X    int attr;	/* currently unused */
X    const char *str;
X{
X    struct text_info_t *text_info = wp->text_information;
X    int width;
X
X    append_text_buffer(&text_info->text, str, FALSE);
X
X    /* Calculate text width and save longest line */
X    width = XTextWidth(text_info->fs, str, (int) strlen(str));
X    if (width > text_info->max_width)
X	text_info->max_width = width;
X}
X
Xvoid
Xdisplay_text_window(wp, blocking)
X    struct xwindow *wp;
X    boolean blocking;
X{
X    struct text_info_t *text_info;
X    Arg args[8];
X    Cardinal num_args;
X    Dimension width, height;
X    int nlines;
X
X    text_info = wp->text_information;
X    width  = text_info->max_width + text_info->extra_width;
X    text_info->blocked = blocking;
X    text_info->destroy_on_ack = FALSE;
X
X    /*
X     * Calculate the number of lines to use.  First, find the number of
X     * lines that would fit on the screen.  Next, remove four of these
X     * lines to give room for a possible window manager titlebar (some
X     * wm's put a titlebar on transient windows).  Make sure we have
X     * _some_ lines.  Finally, use the number of lines in the text if
X     * there are fewer than the max.
X     */
X    nlines = (XtScreen(wp->w)->height - text_info->extra_height) /
X			(text_info->fs->ascent + text_info->fs->descent);
X    nlines -= 4;
X    if (nlines <= 0) nlines = 1;
X
X    if (nlines > text_info->text.num_lines)
X	nlines = text_info->text.num_lines;
X
X    /* Font height is ascent + descent. */
X    height = (nlines * (text_info->fs->ascent + text_info->fs->descent))
X						    + text_info->extra_height;
X
X    num_args = 0;
X
X    if (nlines < text_info->text.num_lines) {
X	/* add on width of scrollbar.  Really should look this up,
X	 * but can't until the window is realized.  Chicken-and-egg problem.
X	 */
X	width += 20;
X    }
X
X    if (width > (Dimension) XtScreen(wp->w)->width) { /* too wide for screen */
X	/* Back off some amount - we really need to back off the scrollbar */
X	/* width plus some extra.					   */
X	width = XtScreen(wp->w)->width - 20;
X    }
X    XtSetArg(args[num_args], XtNstring, text_info->text.text);	num_args++;
X    XtSetArg(args[num_args], XtNwidth,  width);			num_args++;
X    XtSetArg(args[num_args], XtNheight, height);		num_args++;
X    XtSetValues(wp->w, args, num_args);
X
X#ifdef TRANSIENT_TEXT
X    XtRealizeWidget(wp->popup);
X    positionpopup(wp->popup);
X#endif
X
X    nh_XtPopup(wp->popup, XtGrabNone, wp->w);
X
X    /* Kludge alert.  Scrollbars are not sized correctly by the Text widget */
X    /* if added before the window is displayed, so do it afterward. */
X    num_args = 0;
X    if (nlines < text_info->text.num_lines) {	/* add vert scrollbar */
X	XtSetArg(args[num_args], XtNscrollVertical, XawtextScrollAlways);
X								num_args++;
X    }
X    if (width >= (Dimension) (XtScreen(wp->w)->width-20)) {	/* too wide */
X	XtSetArg(args[num_args], XtNscrollHorizontal, XawtextScrollAlways);
X								num_args++;
X    }
X    if (num_args) XtSetValues(wp->w, args, num_args);
X
X    /* We want the user to acknowlege. */
X    if (blocking) {
X	(void) x_event(EXIT_ON_EXIT);
X	nh_XtPopdown(wp->popup);
X    }
X}
X
X
Xvoid
Xcreate_text_window(wp)
X    struct xwindow *wp;
X{
X    struct text_info_t *text_info;
X    Arg args[8];
X    Cardinal num_args;
X    Position top_margin, bottom_margin, left_margin, right_margin;
X
X    wp->type = NHW_TEXT;
X
X    wp->text_information = text_info = 
X		    (struct text_info_t *) alloc(sizeof(struct text_info_t));
X
X    init_text_buffer(&text_info->text);
X    text_info->max_width      = 0;
X    text_info->extra_width    = 0;
X    text_info->extra_height   = 0;
X    text_info->blocked	      = FALSE;
X    text_info->destroy_on_ack = TRUE;	/* Ok to destroy before display */
X
X    num_args = 0;
X    XtSetArg(args[num_args], XtNallowShellResize, True); num_args++;
X
X#ifdef TRANSIENT_TEXT
X    wp->popup = XtCreatePopupShell("text", transientShellWidgetClass,
X				   toplevel, args, num_args);
X#else
X    wp->popup = XtCreatePopupShell("text", topLevelShellWidgetClass,
X				   toplevel, args, num_args);
X#endif
X
X    num_args = 0;
X    XtSetArg(args[num_args], XtNdisplayCaret, False);		num_args++;
X    XtSetArg(args[num_args], XtNresize, XawtextResizeBoth);	num_args++;
X    XtSetArg(args[num_args], XtNtranslations,
X		XtParseTranslationTable(text_translations));	num_args++;
X
X    wp->w = XtCreateManagedWidget(
X		killer && WIN_MAP == WIN_ERR ?
X				  "tombstone" : "text_text", /* name */
X		asciiTextWidgetClass,
X		wp->popup,		/* parent widget */
X		args,			/* set some values */
X		num_args);		/* number of values to set */
X
X    /* Get the font and margin information. */
X    num_args = 0;
X    XtSetArg(args[num_args], XtNfont,	      &text_info->fs); num_args++;
X    XtSetArg(args[num_args], XtNtopMargin,    &top_margin);    num_args++;
X    XtSetArg(args[num_args], XtNbottomMargin, &bottom_margin); num_args++;
X    XtSetArg(args[num_args], XtNleftMargin,   &left_margin);   num_args++;
X    XtSetArg(args[num_args], XtNrightMargin,  &right_margin);  num_args++;
X    XtGetValues(wp->w, args, num_args);
X
X    text_info->extra_width  = left_margin + right_margin;
X    text_info->extra_height = top_margin + bottom_margin;
X}
X
Xvoid
Xdestroy_text_window(wp)
X    struct xwindow *wp;
X{
X    /* Don't need to pop down, this only called from dismiss_text(). */
X
X    struct text_info_t *text_info = wp->text_information;
X
X    /*
X     * If the text window was blocked, then the user has already ACK'ed
X     * it and we are free to really destroy the window.  Otherwise, don't
X     * destroy until the user dismisses the window via a key or button
X     * press.
X     */
X    if (text_info->blocked || text_info->destroy_on_ack) {
X	XtDestroyWidget(wp->popup);
X	free_text_buffer(&text_info->text);
X	free((char *) text_info);
X	wp->type = NHW_NONE;	/* allow reuse */
X    } else {
X	text_info->destroy_on_ack = TRUE;	/* destroy on next ACK */
X    }
X}
X
X
X/* text buffer routines ---------------------------------------------------- */
X
X/* Append a line to the text buffer. */
Xvoid
Xappend_text_buffer(tb, str, concat)
X    struct text_buffer *tb;
X    const char *str;
X    boolean concat;
X{
X    char *copy;
X    int length;
X
X    if (!tb->text) panic("append_text_buffer:  null text buffer");
X
X    if (str) {
X    	length = strlen(str);
X    } else {
X	length = 0;
X    }
X
X    if (length + tb->text_last + 1 >= tb->text_size) {
X	/* we need to go to a bigger buffer! */
X#ifdef VERBOSE
X	printf("append_text_buffer: text buffer growing from %d to %d bytes\n",
X				tb->text_size, 2*tb->text_size);
X#endif
X	copy = (char *) alloc(tb->text_size*2);
X	(void) memcpy(copy, tb->text, tb->text_last);
X	free(tb->text);
X	tb->text = copy;
X	tb->text_size *= 2;
X    }
X
X    if (tb->num_lines) {	/* not first --- append a newline */
X	char appchar = '\n';
X
X	if(concat && !index("!.?'\")", tb->text[tb->text_last-1])) {
X	    appchar = ' ';
X	    tb->num_lines--; /* offset increment at end of function */
X	}
X
X	*(tb->text + tb->text_last) = appchar;
X	tb->text_last++;
X    }
X
X    if (str) {
X	(void) memcpy((tb->text+tb->text_last), str, length+1);
X	if(length) {
X	    /* Remove all newlines. Otherwise we have a confused line count. */
X	    copy = (tb->text+tb->text_last);
X	    while (copy = index(copy, '\n'))
X		*copy = ' ';
X	}
X
X	tb->text_last += length;
X    }
X    tb->text[tb->text_last] = '\0';
X    tb->num_lines++;
X}
X
X/* Initialize text buffer. */
Xvoid
Xinit_text_buffer(tb)
X    struct text_buffer *tb;
X{
X    tb->text	  = (char *) alloc(START_SIZE);
X    tb->text[0]   = '\0';
X    tb->text_size = START_SIZE;
X    tb->text_last = 0;
X    tb->num_lines = 0;
X}
X
X/* Empty the text buffer */
Xvoid
Xclear_text_buffer(tb)
X    struct text_buffer *tb;
X{
X    tb->text_last = 0;
X    tb->text[0]   = '\0';
X    tb->num_lines = 0;
X}
X
X/* Free up allocated memory. */
Xvoid
Xfree_text_buffer(tb)
X    struct text_buffer *tb;
X{
X    free(tb->text);
X    tb->text = (char *) 0;
X    tb->text_size = 0;
X    tb->text_last = 0;
X    tb->num_lines = 0;
X}
END_OF_FILE
if test 9488 -ne `wc -c <'win/X11/wintext.c'`; then
    echo shar: \"'win/X11/wintext.c'\" unpacked with wrong size!
fi
# end of 'win/X11/wintext.c'
fi
echo shar: End of archive 93 \(of 108\).
cp /dev/null ark93isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \
21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \
41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 \
61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 \
81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 \
101 102 103 104 105 106 107 108 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 108 archives.
    echo "Now execute 'rebuild.sh'"
    rm -f ark10[0-8]isdone ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
