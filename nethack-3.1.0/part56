Path: uunet!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v16i064:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Part56/108
Message-ID: <4367@master.CNA.TEK.COM>
Date: 1 Feb 93 19:44:00 GMT
Sender: news@master.CNA.TEK.COM
Lines: 2197
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1614

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 16, Issue 64
Archive-name: nethack31/Part56
Supersedes: nethack3p9: Volume 10, Issue 46-102
Environment: Amiga, Atari, Mac, MS-DOS, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 56 (of 108)."
# Contents:  include/wintype.h src/lock.c src/mhitu.c1
# Wrapped by billr@saab on Wed Jan 27 16:09:08 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'include/wintype.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/wintype.h'\"
else
echo shar: Extracting \"'include/wintype.h'\" \(753 characters\)
sed "s/^X//" >'include/wintype.h' <<'END_OF_FILE'
X/*	SCCS Id: @(#)wintype.h	3.1	91/07/03	*/
X/* Copyright (c) David Cohrs, 1991				  */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#ifndef WINTYPE_H
X#define WINTYPE_H
X
X/* window types */
X/* any additional port specific types should be defined in win*.h */
X#define NHW_MESSAGE 1
X#define NHW_STATUS  2
X#define NHW_MAP     3
X#define NHW_MENU    4
X#define NHW_TEXT    5
X
X/* attribute types for putstr; the same as the ANSI value, for convenience */
X#define ATR_NONE    0
X#define ATR_BOLD    1
X#define ATR_DIM     2
X#define ATR_ULINE   4
X#define ATR_BLINK   5
X#define ATR_INVERSE 7
X
X/* nh_poskey() modifier types */
X#define CLICK_1     1
X#define CLICK_2	    2
X
X/* invalid winid */
X#define WIN_ERR ((winid) -1)
X
X#endif /* WINTYPE_H */
END_OF_FILE
if test 753 -ne `wc -c <'include/wintype.h'`; then
    echo shar: \"'include/wintype.h'\" unpacked with wrong size!
fi
# end of 'include/wintype.h'
fi
if test -f 'src/lock.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/lock.c'\"
else
echo shar: Extracting \"'src/lock.c'\" \(19813 characters\)
sed "s/^X//" >'src/lock.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)lock.c	3.1	92/09/02
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include	"hack.h"
X
X#define CONTAINER_BITS 0	/* box options not [yet?] implemented */
X
XSTATIC_PTR int NDECL(picklock);
XSTATIC_PTR int NDECL(forcelock);
X
XSTATIC_VAR struct xlock_s {
X	int	door_or_box, picktyp;
X	struct rm  *door;
X	struct obj *box;
X	int chance, usedtime;
X} NEARDATA xlock;
X
X#ifdef OVLB
X
Xstatic boolean FDECL(obstructed,(int,int));
Xstatic void FDECL(chest_shatter_msg, (struct obj *));
X
Xboolean
Xpicking_at(x, y)
Xint x, y;
X{
X	return((occupation == picklock) && 
X	       xlock.door_or_box && (xlock.door == &levl[x][y])); 
X}
X
XSTATIC_PTR
Xint
Xpicklock()	/* try to open/close a lock */
X{
X
X	if(!xlock.door_or_box) {	/* box */
X
X	    if((xlock.box->ox != u.ux) || (xlock.box->oy != u.uy)) {
X		return((xlock.usedtime = 0));		/* you or it moved */
X	    }
X	} else {		/* door */
X	    if(xlock.door != &(levl[u.ux+u.dx][u.uy+u.dy])) {
X		return((xlock.usedtime = 0));		/* you moved */
X	    }
X	    switch (xlock.door->doormask) {
X		case D_NODOOR:
X		    pline("This doorway has no door.");
X		    return((xlock.usedtime = 0));
X		case D_ISOPEN:
X		    pline("Picking the lock of an open door is pointless.");
X		    return((xlock.usedtime = 0));
X		case D_BROKEN:
X		    pline("This door is broken.");
X		    return((xlock.usedtime = 0));
X	    }
X	}
X
X	if(xlock.usedtime++ >= 50
X#ifdef POLYSELF
X	   || nohands(uasmon)
X#endif
X	   ) {
X	    You("give up your attempt to %s the lock.",
X		  (xlock.door_or_box ? !(xlock.door->doormask & D_LOCKED) :
X		   !xlock.box->olocked) ? "lock" :
X		  ((xlock.picktyp == LOCK_PICK) ? "pick" : "open" ));
X
X	    exercise(A_DEX, TRUE);	/* even if you don't succeed */
X	    return((xlock.usedtime = 0));
X	}
X
X	if(rn2(100) > xlock.chance) return(1);		/* still busy */
X
X	if(xlock.door_or_box) {
X	    You("succeed in %sing the lock.",
X		  !(xlock.door->doormask & D_LOCKED) ? "lock" :
X		  ((xlock.picktyp == LOCK_PICK) ? "pick" : "open" ));
X	    if(xlock.door->doormask & D_TRAPPED) {
X		    b_trapped("door");
X		    xlock.door->doormask = D_NODOOR;
X		    unblock_point(u.ux+u.dx, u.uy+u.dy);
X		    newsym(u.ux+u.dx, u.uy+u.dy);
X	    } else if(xlock.door->doormask == D_LOCKED)
X		xlock.door->doormask = D_CLOSED;
X	    else xlock.door->doormask = D_LOCKED;
X	} else {
X	    You("succeed in %sing the lock.",
X		  (!xlock.box->olocked) ? "lock" :
X		  (xlock.picktyp == LOCK_PICK) ? "pick" : "open" );
X	    xlock.box->olocked = !xlock.box->olocked;
X	    if(xlock.box->otrapped)	
X		(void) chest_trap(xlock.box, FINGER, FALSE);
X	}
X	exercise(A_DEX, TRUE);
X	return((xlock.usedtime = 0));
X}
X
XSTATIC_PTR
Xint
Xforcelock()	/* try to force a locked chest */
X{
X
X	register struct obj *otmp, *otmp2;
X
X	if((xlock.box->ox != u.ux) || (xlock.box->oy != u.uy))
X		return((xlock.usedtime = 0));		/* you or it moved */
X
X	if(xlock.usedtime++ >= 50 || !uwep
X#ifdef POLYSELF
X	   || nohands(uasmon)
X#endif
X	   ) {
X	    You("give up your attempt to force the lock.");
X	    if(xlock.usedtime >= 50)		/* you made the effort */
X	      exercise((xlock.picktyp) ? A_DEX : A_STR, TRUE);
X	    return((xlock.usedtime = 0));
X	}
X
X	if(xlock.picktyp) {	/* blade */
X
X	    if(rn2(1000-(int)uwep->spe) > (992-(int)uwep->oeroded*10) && 
X	       !uwep->cursed) {
X		/* for a +0 weapon, probability that it survives an unsuccessful
X		 * attempt to force the lock is (.992)^50 = .67
X		 */
X		pline("%sour %s broke!",
X		      (uwep->quan > 1L) ? "One of y" : "Y", xname(uwep));
X		useup(uwep);
X		You("give up your attempt to force the lock.");
X		exercise(A_DEX, TRUE);
X		return((xlock.usedtime = 0));
X	    }
X	} else			/* blunt */
X	    wake_nearby();	/* due to hammering on the container */
X
X	if(rn2(100) > xlock.chance) return(1);		/* still busy */
X
X	You("succeed in forcing the lock.");
X	xlock.box->olocked = 0;
X	xlock.box->obroken = 1;
X	if(!xlock.picktyp && !rn2(3)) {
X	    register struct monst *shkp;
X	    long loss = 0L;
X
X#ifdef GCC_WARN
X	    shkp = (struct monst *) 0;
X#endif
X
X	    if(*u.ushops) shkp = shop_keeper(*u.ushops);
X
X	    pline("In fact, you've totally destroyed %s.",
X		  the(xname(xlock.box)));
X
X	    /* Put the contents on ground at the hero's feet. */
X	    for (otmp = xlock.box->cobj; otmp; otmp = otmp2) {
X		otmp2 = otmp->nobj;
X		if(!rn2(3) || otmp->oclass == POTION_CLASS) {
X		    chest_shatter_msg(otmp);
X		    if(*u.ushops && costly_spot(u.ux, u.uy))
X		        loss += stolen_value(otmp, u.ux, u.uy,
X					     (boolean)shkp->mpeaceful, TRUE);
X		    if (otmp->quan == 1L) {
X			obfree(otmp, (struct obj *) 0);
X			continue;
X		    }
X		    useup(otmp);
X		}
X		place_object(otmp,u.ux,u.uy);
X		otmp->nobj = fobj;
X		fobj = otmp;
X		stackobj(otmp);
X	    }
X	    xlock.box->cobj = (struct obj *) 0;	/* no contents */
X	    if(*u.ushops && costly_spot(u.ux, u.uy))
X		loss += stolen_value(otmp, u.ux, u.uy,
X					     (boolean)shkp->mpeaceful, TRUE);
X	    if(loss) You("owe %ld zorkmids for objects destroyed.", loss);
X	    delobj(xlock.box);
X	}
X	exercise((xlock.picktyp) ? A_DEX : A_STR, TRUE);
X	return((xlock.usedtime = 0));
X}
X
X#endif /* OVLB */
X#ifdef OVL0
X
Xvoid
Xreset_pick() { xlock.usedtime = 0; }
X
X#endif /* OVL0 */
X#ifdef OVLB
X
Xint
Xpick_lock(pick) /* pick a lock with a given object */
X	register struct	obj	*pick;
X{
X	register int x, y, picktyp, c, ch;
X	register struct rm	*door;
X	register struct obj	*otmp;
X	char qbuf[QBUFSZ];
X
X#ifdef GCC_WARN
X	ch = 0;		/* GCC myopia */
X#endif
X	picktyp = pick->otyp;
X	if(xlock.usedtime && picktyp == xlock.picktyp) {
X
X	    You("resume your attempt to %s the lock.",
X		  (xlock.door_or_box ? !(xlock.door->doormask & D_LOCKED) :
X		   !xlock.box->olocked) ? "lock" :
X		  ((xlock.picktyp == LOCK_PICK) ? "pick" : "open" ));
X
X	    set_occupation(picklock,
X			   (picktyp == LOCK_PICK) ? "picking the lock" :
X						    "opening the lock",  0);
X	    return(1);
X	}
X
X#ifdef POLYSELF
X	if(nohands(uasmon)) {
X		You("can't hold a %s - you have no hands!", xname(pick));
X		return(0);
X	}
X#endif
X	if((picktyp != LOCK_PICK &&
X#ifdef TOURIST
X	    picktyp != CREDIT_CARD &&
X#endif
X	    picktyp != SKELETON_KEY)) {
X		impossible("picking lock with object %d?", picktyp);
X		return(0);
X	}
X	if(!getdir(NULL)) return(0);
X
X	x = u.ux + u.dx;
X	y = u.uy + u.dy;
X	if((x == u.ux) && (y == u.uy)) { /* pick the lock on a container */
X	    c = 'n';			/* in case there are no boxes here */
X	    for(otmp = level.objects[x][y]; otmp; otmp = otmp->nexthere)
X		if (Is_box(otmp)) {
X		    const char *verb;
X		    boolean it = 0;
X#if CONTAINER_BITS
X		    if (!otmp->oclosed) {	/* it's open */
X			pline("There is %s here.", doname(otmp));
X			continue;
X		    }
X		    if (!otmp->lknown) verb = "work";
X		    else
X#endif
X			 if (otmp->obroken) verb = "fix";
X		    else if (!otmp->olocked) verb = "lock", it = 1;
X		    else if (picktyp != LOCK_PICK) verb = "unlock", it = 1;
X		    else verb = "pick";
X		    Sprintf(qbuf, "There is %s here, %s %s?",
X			    doname(otmp), verb, it ? "it" : "its lock");
X
X		    c = ynq(qbuf);
X		    if(c == 'q') return(0);
X		    if(c == 'n') continue;
X
X#if CONTAINER_BITS
X		    otmp->lknown = 1;
X#endif
X		    if (otmp->obroken) {
X			You("can't fix its broken lock with %s.", doname(pick));
X			return 0;
X		    }
X#ifdef TOURIST
X		    else if (picktyp == CREDIT_CARD && !otmp->olocked) {
X			/* credit cards are only good for unlocking */
X			You("can't do that with %s.", doname(pick));
X			return 0;
X		    }
X#endif
X		    switch(picktyp) {
X#ifdef TOURIST
X			case CREDIT_CARD:
X			    ch = ACURR(A_DEX)+(20*(pl_character[0] == 'R'));
X			    break;
X#endif
X			case LOCK_PICK:
X			    ch = 4*ACURR(A_DEX)+(25*(pl_character[0] == 'R'));
X			    break;
X			case SKELETON_KEY:
X			    ch = 75 + ACURR(A_DEX);
X			    break;
X			default:	ch = 0;
X		    }
X		    if(otmp->cursed) ch /= 2;
X
X		    xlock.door_or_box = 0;
X		    xlock.picktyp = picktyp;
X		    xlock.box = otmp;
X		    break;
X		}
X	    if(c != 'y')
X		return(0);		/* decided against all boxes */
X	} else {			/* pick the lock in a door */
X	    struct monst *mtmp;
X
X	    door = &levl[x][y];
X	    if ((mtmp = m_at(x, y)) && canseemon(mtmp)
X			&& mtmp->m_ap_type != M_AP_FURNITURE
X			&& mtmp->m_ap_type != M_AP_OBJECT) {
X#ifdef TOURIST
X		if (picktyp == CREDIT_CARD &&
X		    (mtmp->isshk || mtmp->data == &mons[PM_ORACLE]))
X		    verbalize("No checks, no credit, no problem.");
X		else
X#endif
X		    pline("I don't think %s would appreciate that.", mon_nam(mtmp));
X		return(0);
X	    }
X	    if(!IS_DOOR(door->typ)) {
X		if (is_drawbridge_wall(x,y) >= 0)
X		    You("%s no lock on the drawbridge.",
X				Blind ? "feel" : "see");
X		else
X		    You("%s no door there.",
X				Blind ? "feel" : "see");
X		return(0);
X	    }
X	    switch (door->doormask) {
X		case D_NODOOR:
X		    pline("This doorway has no door.");
X		    return(0);
X		case D_ISOPEN:
X		    pline("Picking the lock of an open door is pointless.");
X		    return(0);
X		case D_BROKEN:
X		    pline("This door is broken.");
X		    return(0);
X		default:
X#ifdef TOURIST
X		    /* credit cards are only good for unlocking */
X		    if(picktyp == CREDIT_CARD && !(door->doormask & D_LOCKED)) {
X			You("can't lock a door with a credit card.");
X			return(0);
X		    }
X#endif
X
X		    Sprintf(qbuf,"%sock it?",
X			(door->doormask & D_LOCKED) ? "Unl" : "L" );
X
X		    c = yn(qbuf);
X		    if(c == 'n') return(0);
X
X		    switch(picktyp) {
X#ifdef TOURIST
X			case CREDIT_CARD:
X			    ch = 2*ACURR(A_DEX)+(20*(pl_character[0] == 'R'));
X			    break;
X#endif
X			case LOCK_PICK:
X			    ch = 3*ACURR(A_DEX)+(30*(pl_character[0] == 'R'));
X			    break;
X			case SKELETON_KEY:
X			    ch = 70 + ACURR(A_DEX);
X			    break;
X			default:    ch = 0;
X		    }
X		    xlock.door_or_box = 1;
X		    xlock.door = door;
X	    }
X	}
X	flags.move = 0;
X	xlock.chance = ch;
X	xlock.picktyp = picktyp;
X	xlock.usedtime = 0;
X	set_occupation(picklock,
X		       (picktyp == LOCK_PICK) ? "picking the lock" :
X						"opening the lock",  0);
X	return(1);
X}
X
Xint
Xdoforce()		/* try to force a chest with your weapon */
X{
X	register struct obj *otmp;
X	register int c, picktyp;
X	char qbuf[QBUFSZ];
X
X	if(!uwep ||	/* proper type test */
X	   (uwep->oclass != WEAPON_CLASS && uwep->oclass != ROCK_CLASS &&
X						uwep->otyp != PICK_AXE) ||
X	   (uwep->otyp < BOOMERANG) ||
X	   (uwep->otyp > AKLYS && uwep->oclass != ROCK_CLASS &&
X						uwep->otyp != PICK_AXE)
X#ifdef KOPS
X	   || uwep->otyp == RUBBER_HOSE
X#endif
X	  ) {
X	    You("can't force anything without a %sweapon.",
X		  (uwep) ? "proper " : "");
X	    return(0);
X	}
X
X	picktyp = is_blade(uwep);
X	if(xlock.usedtime && xlock.box && picktyp == xlock.picktyp) {
X	    You("resume your attempt to force the lock.");
X	    set_occupation(forcelock, "forcing the lock", 0);
X	    return(1);
X	}
X
X	/* A lock is made only for the honest man, the thief will break it. */
X	xlock.box = (struct obj *)0;
X	for(otmp = level.objects[u.ux][u.uy]; otmp; otmp = otmp->nexthere)
X	    if(Is_box(otmp)) {
X#if CONTAINER_BITS
X		if (!otmp->oclosed) {	/* it's open */
X		    pline("There is %s here.", doname(otmp));
X		    continue;
X		}
X		if (otmp->obroken || (otmp->lknown && !otmp->olocked)) {
X#else
X		if (otmp->obroken || !otmp->olocked) {
X#endif
X		    pline("There is %s here, but its lock is already %s.",
X			  doname(otmp), otmp->obroken ? "broken" : "unlocked");
X		    continue;
X		}
X		Sprintf(qbuf,"There is %s here, force its lock?", doname(otmp));
X
X		c = ynq(qbuf);
X		if(c == 'q') return(0);
X		if(c == 'n') continue;
X
X#if CONTAINER_BITS
X		if (!otmp->olocked) {	/* lock-status wasn't known */
X		    pline("Well what'd'ya know?  It's already unlocked.");
X		    otmp->lknown = 1;
X		    return 0;
X		}
X#endif
X		if(picktyp)
X		    You("force your %s into a crack and pry.", xname(uwep));
X		else
X		    You("start bashing it with your %s.", xname(uwep));
X		xlock.box = otmp;
X		xlock.chance = objects[otmp->otyp].oc_wldam * 2;
X		xlock.picktyp = picktyp;
X		xlock.usedtime = 0;
X		break;
X	    }
X
X	if(xlock.box)	set_occupation(forcelock, "forcing the lock", 0);
X	else		You("decide not to force the issue.");
X	return(1);
X}
X
Xint
Xdoopen()		/* try to open a door */
X{
X	register int x, y;
X	register struct rm *door;
X	struct monst *mtmp;
X
X	if (u.utrap && u.utraptype == TT_PIT) {
X	    You("can't reach over the edge of the pit.");
X	    return 0;
X	}
X
X	if(!getdir(NULL)) return(0);
X
X	x = u.ux + u.dx;
X	y = u.uy + u.dy;
X	if((x == u.ux) && (y == u.uy)) return(0);
X
X	if ((mtmp = m_at(x,y))				&&
X		mtmp->m_ap_type == M_AP_FURNITURE	&&
X		(mtmp->mappearance == S_hcdoor ||
X			mtmp->mappearance == S_vcdoor)	&&
X		!Protection_from_shape_changers)	 {
X
X	    stumble_onto_mimic(mtmp);
X	    return(1);
X	}
X
X	door = &levl[x][y];
X
X	if(!IS_DOOR(door->typ)) {
X		if (is_db_wall(x,y)) {
X		    pline("There is no obvious way to open the drawbridge.");
X		    return(0);
X		}
X		You("%s no door there.",
X				Blind ? "feel" : "see");
X		return(0);
X	}
X
X	if(!(door->doormask & D_CLOSED)) {
X	  switch(door->doormask) {
X	     case D_BROKEN: pline("This door is broken."); break;
X	     case D_NODOOR: pline("This doorway has no door."); break;
X	     case D_ISOPEN: pline("This door is already open."); break;
X	     default:	    pline("This door is locked."); break;
X	  }
X	  return(0);
X	}
X
X#ifdef POLYSELF
X	if(verysmall(uasmon)) {
X	    pline("You're too small to pull the door open.");
X	    return(0);
X	}
X#endif
X	/* door is known to be CLOSED */
X	if (rnl(20) < (ACURRSTR+ACURR(A_DEX)+ACURR(A_CON))/3) {
X	    pline("The door opens.");
X	    if(door->doormask & D_TRAPPED) {
X		b_trapped("door");
X		door->doormask = D_NODOOR;
X	    } else
X		door->doormask = D_ISOPEN;
X	    if (Blind)
X		feel_location(x,y);	/* the hero knows she opened it  */
X	    else
X		newsym(x,y);
X	    unblock_point(x,y);		/* vision: new see through there */
X	} else {
X	    exercise(A_STR, TRUE);
X	    pline("The door resists!");
X	}
X
X	return(1);
X}
X
Xstatic
Xboolean
Xobstructed(x,y)
Xregister int x, y;
X{
X	register struct monst *mtmp = m_at(x, y);
X
X	if(mtmp && mtmp->m_ap_type != M_AP_FURNITURE) {
X		if (mtmp->m_ap_type == M_AP_OBJECT) goto objhere;
X		pline("%s stands in the way!", Blind ?
X			"Some creature" : Monnam(mtmp));
X		return(TRUE);
X	}
X	if (OBJ_AT(x, y)) {
Xobjhere:	pline("Something's in the way.");
X		return(TRUE);
X	}
X	return(FALSE);
X}
X
Xint
Xdoclose()		/* try to close a door */
X{
X	register int x, y;
X	register struct rm *door;
X	struct monst *mtmp;
X
X	if (u.utrap && u.utraptype == TT_PIT) {
X	    You("can't reach over the edge of the pit.");
X	    return 0;
X	}
X
X	if(!getdir(NULL)) return(0);
X
X	x = u.ux + u.dx;
X	y = u.uy + u.dy;
X	if((x == u.ux) && (y == u.uy)) {
X		You("are in the way!");
X		return(1);
X	}
X
X	if ((mtmp = m_at(x,y))				&&
X		mtmp->m_ap_type == M_AP_FURNITURE	&& 
X		(mtmp->mappearance == S_hcdoor ||
X			mtmp->mappearance == S_vcdoor)	&&
X		!Protection_from_shape_changers)	 {
X
X	    stumble_onto_mimic(mtmp);
X	    return(1);
X	}
X
X	door = &levl[x][y];
X
X	if(!IS_DOOR(door->typ)) {
X		if (door->typ == DRAWBRIDGE_DOWN)
X		    pline("There is no obvious way to close the drawbridge.");
X		else
X		    You("%s no door there.",
X				Blind ? "feel" : "see");
X		return(0);
X	}
X
X	if(door->doormask == D_NODOOR) {
X	    pline("This doorway has no door.");
X	    return(0);
X	}
X
X	if(obstructed(x, y)) return(0);
X
X	if(door->doormask == D_BROKEN) {
X	    pline("This door is broken.");
X	    return(0);
X	}
X
X	if(door->doormask & (D_CLOSED | D_LOCKED)) {
X	    pline("This door is already closed.");
X	    return(0);
X	}
X
X	if(door->doormask == D_ISOPEN) {
X#ifdef POLYSELF
X	    if(verysmall(uasmon)) {
X		 pline("You're too small to push the door closed.");
X		 return(0);
X 	    }
X#endif
X	    if (rn2(25) < (ACURRSTR+ACURR(A_DEX)+ACURR(A_CON))/3) {
X		pline("The door closes.");
X		door->doormask = D_CLOSED;
X		if (Blind)
X		    feel_location(x,y);	/* the hero knows she closed it */
X		else
X		    newsym(x,y);
X		block_point(x,y);	/* vision:  no longer see there */
X	    }
X	    else {
X	        exercise(A_STR, TRUE);
X	        pline("The door resists!");
X	    }
X	}
X
X	return(1);
X}
X
Xboolean			/* box obj was hit with spell effect otmp */
Xboxlock(obj, otmp)	/* returns true if something happened */
Xregister struct obj *obj, *otmp;	/* obj *is* a box */
X{
X	register boolean res = 0;
X
X	switch(otmp->otyp) {
X	case WAN_LOCKING:
X	case SPE_WIZARD_LOCK:
X	    if (!obj->olocked) {	/* lock it; fix if broken */
X		pline("Klunk!");
X#if CONTAINER_BITS
X		obj->lknown = 0;
X		obj->oclosed = 1;
X#endif
X		obj->olocked = 1;
X		obj->obroken = 0;
X		res = 1;
X	    } /* else already closed and locked */
X	    break;
X	case WAN_OPENING:
X	case SPE_KNOCK:
X	    if (obj->olocked) {		/* unlock; couldn't be broken */
X		pline("Klick!");
X#if CONTAINER_BITS
X		obj->lknown = 0;
X#endif
X		obj->olocked = 0;
X		res = 1;
X	    } else			/* silently fix if broken */
X		obj->obroken = 0;
X#if CONTAINER_BITS
X	    obj->oclosed = 0;		/* now open, unconditionally */
X#endif
X	    break;
X	}
X	return res;
X}
X
Xboolean			/* Door/secret door was hit with spell effect otmp */
Xdoorlock(otmp,x,y)	/* returns true if something happened */
Xregister struct obj *otmp;
Xint x, y;
X{
X	register struct rm *door = &levl[x][y];
X	boolean res = 1;
X	const char *msg = NULL;
X
X	if (door->typ == SDOOR) {
X	    if (otmp->otyp == WAN_OPENING || otmp->otyp == SPE_KNOCK) {
X		door->typ = DOOR;
X		door->doormask = D_CLOSED | (door->doormask & D_TRAPPED);
X		if (cansee(x,y)) pline("A section of the wall opens up!");
X		newsym(x,y);
X		return(1);
X	    } else
X		return(0);
X	}
X
X	switch(otmp->otyp) {
X	case WAN_LOCKING:
X	case SPE_WIZARD_LOCK:
X	    if (obstructed(x,y)) return 0;
X	    switch (door->doormask & ~D_TRAPPED) {
X	    case D_CLOSED:
X		msg = "The door locks!";
X		break;
X	    case D_ISOPEN:
X		msg = "The door swings shut, and locks!";
X		break;
X	    case D_BROKEN:
X		msg = "The broken door reassembles and locks!";
X		break;
X	    case D_NODOOR:
X		msg =
X		"A cloud of dust springs up and assembles itself into a door!";
X		break;
X	    default:
X		res = 0;
X		break;
X	    }
X	    block_point(x, y);
X	    door->doormask = D_LOCKED | (door->doormask & D_TRAPPED);
X	    newsym(x,y);
X	    break;
X	case WAN_OPENING:
X	case SPE_KNOCK:
X	    if (door->doormask & D_LOCKED) {
X		msg = "The door unlocks!";
X		door->doormask = D_CLOSED | (door->doormask & D_TRAPPED);
X	    } else res = 0;
X	    break;
X	case WAN_STRIKING:
X	case SPE_FORCE_BOLT:
X	    if (door->doormask & (D_LOCKED | D_CLOSED)) {
X		if (door->doormask & D_TRAPPED) {
X		    if (MON_AT(x, y))
X			(void) mb_trapped(m_at(x,y));
X		    else if (flags.verbose) {
X			if (cansee(x,y))
X			    pline("KABOOM!!  You see a door explode.");
X			else if (flags.soundok)
X			    You("hear a distant explosion.");
X		    }
X		    door->doormask = D_NODOOR;
X		    unblock_point(x,y);
X		    newsym(x,y);
X		    break;
X		}
X		door->doormask = D_BROKEN;
X		if (flags.verbose) {
X		    if (cansee(x,y))
X			pline("The door crashes open!");
X		    else if (flags.soundok)
X			You("hear a crashing sound.");
X		}
X		unblock_point(x,y);
X		newsym(x,y);
X	    } else res = 0;
X	    break;
X	default: impossible("magic (%d) attempted on door.", otmp->otyp);
X	    break;
X	}
X	if (msg && cansee(x,y)) pline(msg);
X	return res;
X}
X
Xstatic void
Xchest_shatter_msg(otmp)
Xstruct obj *otmp;
X{
X	const char *disposition, *article = (otmp->quan > 1L) ? "A" : "The";
X	char *thing;
X	long save_Blinded;
X
X	if (otmp->oclass == POTION_CLASS) {
X		You("%s a flask shatter!", Blind ? "hear" : "see");
X		potionbreathe(otmp);
X		return;
X	}
X	/* We have functions for distant and singular names, but not one */
X	/* which does _both_... */
X	save_Blinded = Blinded;
X	Blinded = 1;
X	thing = singular(otmp, xname);
X	Blinded = save_Blinded;
X	switch (objects[otmp->otyp].oc_material) {
X	case PAPER:	disposition = "is torn to shreds";
X		break;
X	case WAX:	disposition = "is crushed";
X		break;
X	case VEGGY:	disposition = "is pulped";
X		break;
X	case FLESH:	disposition = "is mashed";
X		break;
X	case GLASS:	disposition = "shatters";
X		break;
X	case WOOD:	disposition = "splinters to fragments";
X		break;
X	default:	disposition = "is destroyed";
X		break;
X	}
X	pline("%s %s %s!", article, thing, disposition);
X}
X
X#endif /* OVLB */
X
X/*lock.c*/
END_OF_FILE
if test 19813 -ne `wc -c <'src/lock.c'`; then
    echo shar: \"'src/lock.c'\" unpacked with wrong size!
fi
# end of 'src/lock.c'
fi
if test -f 'src/mhitu.c1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/mhitu.c1'\"
else
echo shar: Extracting \"'src/mhitu.c1'\" \(33906 characters\)
sed "s/^X//" >'src/mhitu.c1' <<'END_OF_FILE'
X/*	SCCS Id: @(#)mhitu.c	3.1	92/12/10	*/
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include "hack.h"
X#include "artifact.h"
X
XSTATIC_VAR struct obj NEARDATA *otmp;
X
X#ifdef POLYSELF
XSTATIC_DCL void FDECL(urustm, (struct monst *, struct obj *));
X# ifdef OVL1
Xstatic int FDECL(passiveum, (struct permonst *,struct monst *,struct attack *));
X# endif /* OVL1 */
X#endif /* POLYSELF */
X
X#ifdef OVLB
X# ifdef SEDUCE
Xstatic void FDECL(mayberem, (struct obj *, const char *));
X# endif
X#endif /* OVLB */
X
XSTATIC_DCL boolean FDECL(diseasemu, (struct permonst *));
XSTATIC_DCL int FDECL(hitmu, (struct monst *,struct attack *));
XSTATIC_DCL int FDECL(gulpmu, (struct monst *,struct attack *));
XSTATIC_DCL int FDECL(explmu, (struct monst *,struct attack *,BOOLEAN_P));
XSTATIC_DCL int FDECL(gazemu, (struct monst *,struct attack *));
XSTATIC_DCL void FDECL(missmu,(struct monst *,BOOLEAN_P,struct attack *));
XSTATIC_DCL void FDECL(mswings,(struct monst *,struct obj *));
XSTATIC_DCL void FDECL(wildmiss,(struct monst *));
X
XSTATIC_DCL void FDECL(hurtarmor,(struct permonst *,int));
XSTATIC_DCL void FDECL(hitmsg,(struct monst *,struct attack *));
X
X/* See comment in mhitm.c.  If we use this a lot it probably should be */
X/* changed to a parameter to mhitu. */
Xstatic int dieroll;
X
X#ifdef OVL1
X
X
XSTATIC_OVL void
Xhitmsg(mtmp, mattk)
Xregister struct monst *mtmp;
Xregister struct attack *mattk;
X{
X	int compat;
X
X	/* Note: if opposite gender, "seductively" */
X	/* If same gender, "engagingly" for nymph, normal msg for others */
X	if((compat = could_seduce(mtmp, &youmonst, mattk))
X			&& !mtmp->mcan && !mtmp->mspec_used) {
X	    	pline("%s %s you %s.", Monnam(mtmp),
X			Blind ? "talks to" : "smiles at",
X			compat == 2 ? "engagingly" : "seductively");
X	} else
X	    switch (mattk->aatyp) {
X		case AT_BITE:
X			pline("%s bites!", Monnam(mtmp));
X			break;
X		case AT_KICK:
X#ifdef POLYSELF
X			pline("%s kicks%c", Monnam(mtmp), thick_skinned(uasmon) ? '.' : '!');
X#else
X			pline("%s kicks!", Monnam(mtmp));
X#endif
X			break;
X		case AT_STNG:
X			pline("%s stings!", Monnam(mtmp));
X			break;
X		case AT_BUTT:
X			pline("%s butts!", Monnam(mtmp));
X			break;
X		case AT_TUCH:
X			pline("%s touches you!", Monnam(mtmp));
X			break;
X		case AT_TENT:
X			pline("%s tentacles suck you!", 
X				        s_suffix(Monnam(mtmp)));
X			break;
X		case AT_EXPL:
X			pline("%s explodes!", Monnam(mtmp));
X			break;
X		default:
X			pline("%s hits!", Monnam(mtmp));
X	    }
X}
X
XSTATIC_OVL void
Xmissmu(mtmp, nearmiss, mattk)		/* monster missed you */
Xregister struct monst *mtmp;
Xregister boolean nearmiss;
Xregister struct attack *mattk;
X{
X	if(could_seduce(mtmp, &youmonst, mattk) && !mtmp->mcan)
X	    pline("%s pretends to be friendly.", Monnam(mtmp));
X	else {
X	    if (!flags.verbose || !nearmiss)
X		pline("%s misses.", Monnam(mtmp));
X	    else
X		pline("%s just misses!", Monnam(mtmp));
X	}
X}
X
XSTATIC_OVL void
Xmswings(mtmp, otemp)		/* monster swings obj */
Xregister struct monst *mtmp;
Xregister struct obj *otemp;
X{
X	if (!flags.verbose || Blind || !mon_visible(mtmp) ||
X		otemp->oclass != WEAPON_CLASS) return;
X	pline("%s %s %s %s.", Monnam(mtmp),
X	      ((otemp->otyp >= SPEAR &&
X	        otemp->otyp <= LANCE) ||
X	       (otemp->otyp >= PARTISAN &&
X	        otemp->otyp <= SPETUM) ||
X	       otemp->otyp == TRIDENT) ? "thrusts" : "swings",
X	      !humanoid(mtmp->data) ? "its" : mtmp->female ? "her" : "his",
X	      xname(otemp));
X}
X
X#endif /* OVL1 */
X#ifdef OVLB
X
XSTATIC_OVL void
Xwildmiss(mtmp)		/* monster attacked your displaced image */
X	register struct monst *mtmp;
X{
X	int compat;
X
X	if (!flags.verbose) return;
X	if (!cansee(mtmp->mx, mtmp->my)) return;
X		/* maybe it's attacking an image around the corner? */
X
X	compat = could_seduce(mtmp, &youmonst, (struct attack *)0);
X		/* we really want to have the attack here to pass --
X		 * the previous code checked whether mtmp was a nymph,
X		 * which was not correct either since the attack type of
X		 * succubi/incubi varies with SEDUCE
X		 */
X
X	if(Invis && !perceives(mtmp->data)) {
X	    if(compat)
X		pline("%s tries to touch you and misses!", Monnam(mtmp));
X	    else
X		switch(rn2(3)) {
X		case 0: pline("%s %s wildly and misses!", Monnam(mtmp),
X			      nolimbs(mtmp->data) ? "lunges" : "swings");
X		    break;
X		case 1: pline("%s attacks a spot beside you.", Monnam(mtmp));
X		    break;
X		case 2: pline("%s strikes at %s!", Monnam(mtmp),
X				Underwater ? "empty water" : "thin air");
X		    break;
X		default:pline("%s %s wildly!", Monnam(mtmp),
X			      nolimbs(mtmp->data) ? "lunges" : "swings");
X		    break;
X		}
X	}
X	else if(Displaced) {
X	    if(compat)
X		pline("%s smiles %s at your %sdisplaced image...",
X			Monnam(mtmp),
X			compat == 2 ? "engagingly" : "seductively",
X			Invis ? "invisible " : "");
X	    else
X		pline("%s strikes at your %sdisplaced image and misses you!",
X			/* Note: if you're both invisible and displaced,
X			 * only monsters which see invisible will attack your
X			 * displaced image, since the displaced image is also
X			 * invisible.
X			 */
X			Monnam(mtmp),
X			Invis ? "invisible " : "");
X	}
X	/* monsters may miss especially on water level where
X	   bubbles shake the player here and there */
X	else if(Underwater) {
X	    if(compat)
X		pline("%s reaches towards your distorted image.",Monnam(mtmp));
X	    else
X		pline("%s is fooled by water reflections and misses!",Monnam(mtmp));
X	}
X	else impossible("%s attacks you without knowing your location?",
X		Monnam(mtmp));
X}
X
Xvoid
Xexpels(mtmp, mdat, message)
Xregister struct monst *mtmp;
Xregister struct permonst *mdat; /* if mtmp is polymorphed, mdat != mtmp->data */
Xboolean message;
X{
X	if (message) 
X		if (is_animal(mdat)) 
X			You("get regurgitated!");
X		else {
X			char blast[40];
X			register int i;
X
X			blast[0] = '\0';
X			for(i = 0; i < NATTK; i++)
X				if(mdat->mattk[i].aatyp == AT_ENGL) 
X					break;
X			if (mdat->mattk[i].aatyp != AT_ENGL)
X			      impossible("Swallower has no engulfing attack?"); 
X			else {
X				if (is_whirly(mdat)) {
X					switch (mdat->mattk[i].adtyp) {
X						case AD_ELEC:
X							Strcpy(blast, 
X						      " in a shower of sparks");
X							break;
X						case AD_COLD:
X							Strcpy(blast, 
X							" in a blast of frost");
X							break;
X					}
X				} else
X					Strcpy(blast, " with a squelch");
X				You("get expelled from %s%s!", 
X				    mon_nam(mtmp), blast);
X			}
X		}
X	unstuck(mtmp);	/* ball&chain returned in unstuck() */
X	mnexto(mtmp);
X	newsym(u.ux,u.uy);
X	spoteffects();
X	/* to cover for a case where mtmp is not in a next square */
X	if(um_dist(mtmp->mx,mtmp->my,1))
X		pline("Brrooaa...  You land hard at some distance.");
X}
X
X#endif /* OVLB */
X#ifdef OVL0
X
X/*
X * mattacku: monster attacks you
X *	returns 1 if monster dies (e.g. "yellow light"), 0 otherwise
X *	Note: if you're displaced or invisible the monster might attack the
X *		wrong position...
X *	Assumption: it's attacking you or an empty square; if there's another
X *		monster which it attacks by mistake, the caller had better
X *		take care of it...
X */
Xint
Xmattacku(mtmp)
X	register struct monst *mtmp;
X{
X	struct	attack	*mattk;
X	int	i, j, tmp, sum[NATTK];
X	struct	permonst *mdat = mtmp->data;
X	boolean ranged = (distu(mtmp->mx, mtmp->my) > 3);
X		/* Is it near you?  Affects your actions */
X	boolean range2 = !monnear(mtmp, mtmp->mux, mtmp->muy);
X		/* Does it think it's near you?  Affects its actions */
X	boolean foundyou = (mtmp->mux==u.ux && mtmp->muy==u.uy);
X		/* Is it attacking you or your image? */
X	boolean youseeit = canseemon(mtmp);
X		/* Might be attacking your image around the corner, or
X		 * invisible, or you might be blind....
X		 */
X
X	if(!ranged) nomul(0);
X	if(mtmp->mhp <= 0 || (Underwater && !is_swimmer(mtmp->data)))
X	    return(0);
X
X	/* If swallowed, can only be affected by u.ustuck */
X	if(u.uswallow) {
X	    if(mtmp != u.ustuck)
X		return(0);
X	    u.ustuck->mux = u.ux;
X	    u.ustuck->muy = u.uy;
X	    range2 = 0;
X	    foundyou = 1;
X	    if(u.uinvulnerable) return (0); /* stomachs can't hurt you! */
X	    /* This is not impossible! */
X	    /* If the swallowing monster changes into a monster
X	     * that is not capable of swallowing you, you get
X	     * regurgitated - dgk
X	     *
X	     * This code is obsolete: newcham() will handle this contingency 
X	     * as soon as it occurs in the course of a round. - kcd
X	     *
X	     * for(i = 0; i < NATTK; i++)
X	     *     if(mdat->mattk[i].aatyp == AT_ENGL) goto doattack;
X	     *
X	     * You("get regurgitated!");
X	     * regurgitates(mtmp);
X             * return(0);
X	     */
X	}
X/* doattack:		use commented out above */
X#ifdef POLYSELF
X	if (u.uundetected && !range2 && foundyou && !u.uswallow) {
X		u.uundetected = 0;
X		if (is_hider(uasmon)) {
X		    coord cc; /* maybe we need a unexto() function? */
X
X		    You("fall from the ceiling!");
X		    if (enexto(&cc, u.ux, u.uy, &playermon)) {
X			remove_monster(mtmp->mx, mtmp->my);
X			newsym(mtmp->mx,mtmp->my);
X			place_monster(mtmp, u.ux, u.uy);
X			if(mtmp->wormno) worm_move(mtmp);
X			teleds(cc.x, cc.y);
X			set_apparxy(mtmp);
X			newsym(u.ux,u.uy);
X		    } else {
X			pline("%s is killed by a falling %s (you)!",
X						Monnam(mtmp), uasmon->mname);
X			killed(mtmp);
X			newsym(u.ux,u.uy);
X			return(0);
X		    }
X		    if (u.usym != S_PIERCER)
X			return(0);	/* trappers don't attack */
X#ifdef MUSE
X		    if (which_armor(mtmp, WORN_HELMET)) {
X#else
X		    if (is_mercenary(mtmp->data) && m_carrying(mtmp,HELMET)) {
X#endif
X			Your("blow glances off %s helmet.", 
X			               s_suffix(mon_nam(mtmp)));
X		    } else {
X			if (3 + find_mac(mtmp) <= rnd(20)) {
X			    pline("%s is hit by a falling piercer (you)!",
X								Monnam(mtmp));
X			    if ((mtmp->mhp -= d(3,6)) < 1)
X				killed(mtmp);
X			} else
X			  pline("%s is almost hit by a falling piercer (you)!",
X								Monnam(mtmp));
X		    }
X		} else {
X		    if (!youseeit)
X			pline("It tries to move where you are hiding.");
X		    else {
X			/* Ugly kludge for eggs.  The message is phrased so as
X			 * to be directed at the monster, not the player,
X			 * which makes "laid by you" wrong.  For the
X			 * parallelism to work, we can't rephrase it, so we
X			 * zap the "laid by you" momentarily instead.
X			 */
X			struct obj *obj = level.objects[u.ux][u.uy];
X
X			if (obj) {
X			    int save_spe = obj->spe;
X			    if (obj->otyp == EGG) obj->spe = 0;
X	     pline("Wait, %s!  There's a %s named %s hiding under %s!",
X				mtmp->mnamelth ? (const char *)NAME(mtmp)
X					       : mtmp->data->mname,
X				uasmon->mname, plname,
X				doname(level.objects[u.ux][u.uy]));
X			    obj->spe = save_spe;
X			} else
X			    impossible("hiding under nothing?");
X		    }
X		    newsym(u.ux,u.uy);
X		}
X		return(0);
X	}
X	if (u.usym == S_MIMIC_DEF && !range2 && foundyou && !u.uswallow) {
X		if (!youseeit) pline("It gets stuck on you.");
X		    else pline("Wait, %s!  That's a %s named %s!",
X			mtmp->mnamelth ? (const char *)NAME(mtmp) : mtmp->data->mname,
X			uasmon->mname, plname);
X		u.ustuck = mtmp;
X		u.usym = S_MIMIC;
X		newsym(u.ux,u.uy);
X		return(0);
X	}
X#endif
X/*	Work out the armor class differential	*/
X	tmp = u.uac + 10;		/* tmp ~= 0 - 20 */
X/*	give people with Ac < -9 at least some vulnerability */
X/*	negative AC gives an actual AC of somewhere from -1 to the AC */
X	if (tmp < 10) tmp = 10 - rnd(10-tmp);
X	tmp += mtmp->m_lev;
X	if(multi < 0) tmp += 4;
X	if((Invis && !perceives(mdat)) || !mtmp->mcansee)
X		tmp -= 2;
X	if(mtmp->mtrapped) tmp -= 2;
X	if(tmp <= 0) tmp = 1;
X
X	/* make eels visible the moment they hit/miss us */
X	if(mdat->mlet == S_EEL && mtmp->minvis && cansee(mtmp->mx,mtmp->my)) {
X		mtmp->minvis = 0;
X		newsym(mtmp->mx,mtmp->my);
X	}
X
X/*	Special demon handling code */
X	if(!mtmp->cham && is_demon(mdat) && !range2
X	   && mtmp->data != &mons[PM_BALROG]
X	   && mtmp->data != &mons[PM_SUCCUBUS]
X	   && mtmp->data != &mons[PM_INCUBUS])
X	    if(!mtmp->mcan && !rn2(13))	msummon(mdat);
X
X/*	Special lycanthrope handling code */
X	if(!mtmp->cham && is_were(mdat) && !range2) {
X
X	    if(is_human(mdat)) {
X		if(!rn2(5 - (night() * 2)) && !mtmp->mcan) new_were(mtmp);
X	    } else if(!rn2(30) && !mtmp->mcan) new_were(mtmp);
X
X	    if(!rn2(10) && !mtmp->mcan) {
X		if(youseeit) {
X			pline("%s summons help!",youseeit ?
X				Monnam(mtmp) : "It");
X		} else
X			You("feel hemmed in.");
X		/* Technically wrong; we really should check if you can see the
X		 * help, but close enough...
X		 */
X		if (!were_summon(mdat,FALSE) && youseeit)
X		    pline("But none comes.");
X	    }
X	}
X
X	if(u.uinvulnerable) {
X	    /* monster's won't attack you */
X	    if(mtmp == u.ustuck)
X		pline("%s loosens its grip slightly.", Monnam(mtmp));
X	    else if(!range2) {
X		if(youseeit)
X		    pline("%s starts to attack you, but pulls back.",
X			  Monnam(mtmp));
X		else
X		    You("feel something move nearby.");
X	    }
X	    return (0);
X	}
X#ifdef MUSE
X	/* Unlike defensive stuff, don't let them use item _and_ attack. */
X	/* Exception:  Medusa; her gaze is automatic.  (We actually kludge
X	 * by permitting a full attack sequence, not just a gaze attack.)
X	 */
X	if(find_offensive(mtmp)) {
X		int foo = use_offensive(mtmp);
X
X		if (mtmp->data != &mons[PM_MEDUSA] && foo != 0) return(foo==1);
X	}
X#endif
X
X	for(i = 0; i < NATTK; i++) {
X
X	    sum[i] = 0;
X	    mattk = &(mdat->mattk[i]);
X	    if (u.uswallow && (mattk->aatyp != AT_ENGL))
X		continue;
X	    switch(mattk->aatyp) {
X		case AT_CLAW:	/* "hand to hand" attacks */
X		case AT_KICK:
X		case AT_BITE:
X		case AT_STNG:
X		case AT_TUCH:
X		case AT_BUTT:
X		case AT_TENT:
X			if(!range2) {
X			    if (foundyou) {
X				if(tmp > (j = rnd(20+i))) {
X#ifdef POLYSELF
X				    if (mattk->aatyp != AT_KICK ||
X					    !thick_skinned(uasmon))
X#endif
X					sum[i] = hitmu(mtmp, mattk);
X				} else
X				    missmu(mtmp, (tmp == j), mattk);
X			    } else
X				wildmiss(mtmp);
X			}
X			break;
X
X		case AT_HUGS:	/* automatic if prev two attacks succeed */
X			/* Note: if displaced, prev attacks never succeeded */
X			if((!range2 && i>=2 && sum[i-1] && sum[i-2])
X							|| mtmp == u.ustuck)
X				sum[i]= hitmu(mtmp, mattk);
X			break;
X
X		case AT_GAZE:	/* can affect you either ranged or not */
X			if (youseeit)
X			    /* not displaced around a corner so not visible */
X			    sum[i] = gazemu(mtmp, mattk);
X			/* if gazemu returns, the player isn't dead.
X			 * can't put this in gazemu() because youseeit might
X			 * not be set
X			 */
X			if(Reflecting && m_canseeu(mtmp) &&
X			   !mtmp->mcan && mtmp->data == &mons[PM_MEDUSA]) {
X			    if(!Blind) {
X				if(Reflecting & W_AMUL)
X				    makeknown(AMULET_OF_REFLECTION);
X				else
X				    makeknown(SHIELD_OF_REFLECTION);
X				pline("%s gaze is reflected by your %s.",
X				      s_suffix(Monnam(mtmp)),
X				      (Reflecting & W_AMUL) ?
X				      "medallion" : "shield");
X				pline("%s is turned to stone!", Monnam(mtmp));
X			    }
X			    stoned = TRUE;
X			    killed(mtmp);
X			    sum[i] = 2;
X			}
X			break;
X
X		case AT_EXPL:	/* automatic hit if next to, and aimed at you */
X			if(!range2) sum[i] = explmu(mtmp, mattk, foundyou);
X			break;
X
X		case AT_ENGL:
X			if (!range2) {
X			    if(foundyou) {
X				if(u.uswallow || tmp > (j = rnd(20+i))) {
X				    /* Force swallowing monster to be
X				     * displayed even when player is
X				     * moving away */
X				    flush_screen(1);
X				    sum[i] = gulpmu(mtmp, mattk);
X				} else {
X				    missmu(mtmp, (tmp == j), mattk);
X				}
X                           } else if (is_animal(mtmp->data))
X					pline("%s gulps some air!", youseeit ?
X					      Monnam(mtmp) : "It");
X				  else
X					if (youseeit)
X					 pline("%s lunges forward and recoils!",
X					       Monnam(mtmp));
X					else
X						You("hear a %s nearby.", 
X						    is_whirly(mtmp->data)? 
X						    "rushing noise" : 
X						    "splat");
X			}
X			break;
X		case AT_BREA:
X			if(range2) sum[i] = breamu(mtmp, mattk);
X			/* Note: breamu takes care of displacement */
X			break;
X		case AT_SPIT:
X			if(range2) sum[i] = spitmu(mtmp, mattk);
X			/* Note: spitmu takes care of displacement */
X			break;
X		case AT_WEAP:
X			if(range2) {
X#ifdef REINCARNATION
X				if (!Is_rogue_level(&u.uz))
X#endif
X					thrwmu(mtmp);
X			} else {
X#ifdef MUSE
X			    /* Rare but not impossible.  Normally the monster
X			     * wields when 2 spaces away, but it can be
X			     * teleported or whatever....
X			     */
X			    if (mtmp->weapon_check == NEED_WEAPON || !MON_WEP(mtmp)) {
X				mtmp->weapon_check = NEED_HTH_WEAPON;
X				/* mon_wield_item resets weapon_check as appropriate */
X				if (mon_wield_item(mtmp) != 0) break;
X			    }
X#endif
X			    if (foundyou) {
X				set_uasmon();
X#ifdef MUSE
X				otmp = MON_WEP(mtmp);
X#else
X				otmp = select_hwep(mtmp);
X#endif
X				if(otmp) {
X				    tmp += hitval(otmp, uasmon);
X				    mswings(mtmp, otmp);
X				}
X				if(tmp > (j = dieroll = rnd(20+i)))
X				    sum[i] = hitmu(mtmp, mattk);
X				else
X				    missmu(mtmp, (tmp == j), mattk);
X			    } else
X				wildmiss(mtmp);
X			}
X			break;
X		case AT_MAGC:
X			if (range2)
X			    sum[i] = buzzmu(mtmp, mattk);
X			else
X			    if (foundyou)
X				sum[i] = castmu(mtmp, mattk);
X			    else
X				pline("%s casts a spell at thin air!",
X					youseeit ? Monnam(mtmp) : "It");
X				/* Not totally right since castmu allows other
X				 * spells, such as the monster healing itself,
X				 * that should work even when not next to you--
X				 * but the previous code was just as wrong.
X				 * --KAA
X				 */
X			break;
X
X		default:		/* no attack */
X			break;
X	    }
X	    if(flags.botl) bot();
X	    if(sum[i] == 2)  return(1);  	/* attacker dead */
X	    if(sum[i] == 3) break;  /* attacker teleported, no more attacks */
X	    /* sum[i] == 1: successful attack */
X	    /* sum[i] == 0: unsuccessful attack */
X	}
X	return(0);
X}
X
X#endif /* OVL0 */
X#ifdef OVLB
X
X/*
X * helper function for some compilers that have trouble with hitmu
X */
X
XSTATIC_OVL void
Xhurtarmor(mdat, attk)
Xstruct permonst *mdat;
Xint attk;
X{
X	boolean getbronze, rusting;
X	int	hurt;
X
X	rusting = (attk == AD_RUST);
X	if (rusting) {
X		hurt = 1;
X		getbronze = (mdat == &mons[PM_BLACK_PUDDING] &&
X			     uarm && is_corrodeable(uarm));
X	}
X	else {
X		hurt=2;
X		getbronze = FALSE;
X	}
X	/* What the following code does: it keeps looping until it
X	 * finds a target for the rust monster.
X	 * Head, feet, etc... not covered by metal, or covered by
X	 * rusty metal, are not targets.  However, your body always
X	 * is, no matter what covers it.
X	 */
X	while (1) {
X	    switch(rn2(5)) {
X	    case 0:
X		if (!rust_dmg(uarmh, rusting ? "helmet" : "leather helmet",
X					 hurt, FALSE))
X			continue;
X		break;
X	    case 1:
X		if (uarmc) break;
X		/* Note the difference between break and continue;
X		 * break means it was hit and didn't rust; continue
X		 * means it wasn't a target and though it didn't rust
X		 * something else did.
X		 */
X		if (getbronze)
X		    (void)rust_dmg(uarm, "bronze armor", 3, TRUE);
X		else if (uarm)
X		    (void)rust_dmg(uarm, xname(uarm), hurt, TRUE);
X		break;
X	    case 2:
X		if (!rust_dmg(uarms, rusting ? "shield" : "wooden shield",
X					 hurt, FALSE))
X			continue;
X		break;
X	    case 3:
X		if (!rust_dmg(uarmg, rusting ? "metal gauntlets" : "gloves",
X					 hurt, FALSE))
X			continue;
X		break;
X	    case 4:
X		if (!rust_dmg(uarmf, rusting ? "metal boots" : "boots",
X					 hurt, FALSE))
X			continue;
X		break;
X	    }
X	    break; /* Out of while loop */
X	}
X}
X
X#endif /* OVLB */
X#ifdef OVL1
X
XSTATIC_OVL boolean
Xdiseasemu(mdat)
Xstruct permonst *mdat;
X{
X	if (defends(AD_DISE,uwep)
X#ifdef POLYSELF
X			|| u.usym == S_FUNGUS
X#endif
X						) {
X		You("feel a slight illness.");
X		return FALSE;
X	} else {
X		if (!Sick) You("feel very sick.");
X		exercise(A_CON, FALSE);
X		make_sick(Sick + (long)rn1(25-ACURR(A_CON),15),FALSE);
X		u.usick_cause = mdat->mname;
X		return TRUE;
X	}
X}
X
X/*
X * hitmu: monster hits you
X *	  returns 2 if monster dies (e.g. "yellow light"), 1 otherwise
X *	  3 if the monster lives but teleported/paralyzed, so it can't keep
X *	       attacking you
X */
XSTATIC_OVL int
Xhitmu(mtmp, mattk)
X	register struct monst *mtmp;
X	register struct attack  *mattk;
X{
X	register struct permonst *mdat = mtmp->data;
X	register int ctmp, ptmp;
X	int dmg, armpro;
X	char	 buf[BUFSZ];
X#ifdef POLYSELF
X	struct permonst *olduasmon = uasmon;
X	int res;
X#endif
X
X/*	If the monster is undetected & hits you.  You should know where
X *	the attack came from.
X */
X	if(mtmp->mundetected && hides_under(mdat)) {
X	    mtmp->mundetected = 0;
X	    if(!(Blind ? Telepat : (HTelepat & (WORN_HELMET|WORN_AMUL)))) {
X		register struct obj *obj;
X
X		if(OBJ_AT(mtmp->mx, mtmp->my)) {
X		    if((obj = level.objects[mtmp->mx][mtmp->my]) != 0)
X			pline("%s was hidden under %s!",
X				  Amonnam(mtmp), doname(obj));
X		}
X		newsym(mtmp->mx, mtmp->my);
X	    }
X	}
X
X/*	First determine the base damage done */
X	dmg = d((int)mattk->damn, (int)mattk->damd);
X	if(is_undead(mdat) && midnight())
X		dmg += d((int)mattk->damn, (int)mattk->damd); /* extra damage */
X
X/*	Next a cancellation factor	*/
X/*	Use ctmp when the cancellation factor takes into account certain
X *	armor's special magic protection.  Otherwise just use !mtmp->mcan.
X */
X	armpro = 0;
X	if (uarm && armpro < objects[uarm->otyp].a_can)
X		armpro = objects[uarm->otyp].a_can;
X	if (uarmc && armpro < objects[uarmc->otyp].a_can)
X		armpro = objects[uarmc->otyp].a_can;
X	ctmp = !mtmp->mcan && ((rn2(3) >= armpro) || !rn2(50));
X
X/*	Now, adjust damages via resistances or specific attacks */
X	switch(mattk->adtyp) {
X	    case AD_PHYS:
X		if(mattk->aatyp == AT_HUGS
X#ifdef POLYSELF
X					   && !sticks(uasmon)
X#endif
X								) {
X		    if(!u.ustuck && rn2(2)) {
X			u.ustuck = mtmp;
X			pline("%s grabs you!", Monnam(mtmp));
X		    } else if(u.ustuck == mtmp) {
X		        exercise(A_STR, FALSE);
X			You("are being %s.",
X			      (mtmp->data == &mons[PM_ROPE_GOLEM])
X			      ? "choked" : "crushed");
X		    }
X		} else {			  /* hand to hand weapon */
X		    if(mattk->aatyp == AT_WEAP && otmp) {
X			dmg += dmgval(otmp, uasmon);
X			if (dmg <= 0) dmg = 1;
X			if (!(otmp->oartifact &&
X				artifact_hit(mtmp, &youmonst, otmp, &dmg,dieroll)))
X			     hitmsg(mtmp, mattk);
X#ifdef POLYSELF
X			if (u.mh > 1 && u.mh > ((u.uac>0) ? dmg : dmg+u.uac) &&
X					(u.umonnum==PM_BLACK_PUDDING
X					|| u.umonnum==PM_BROWN_PUDDING)) {
X			    /* This redundancy necessary because you have to
X			     * take the damage _before_ being cloned.
X			     */
X			    if (u.uac < 0) dmg += u.uac;
X			    if (dmg < 1) dmg = 1;
X			    if (dmg > 1) exercise(A_STR, FALSE);
X			    u.mh -= dmg;
X			    flags.botl = 1;
X			    dmg = 0;
X			    if(cloneu())
X			    You("divide as %s hits you!",mon_nam(mtmp));
X			}
X			urustm(mtmp, otmp);
X#endif
X		    } else
X			hitmsg(mtmp, mattk);
X		}
X		break;
X	    case AD_DISE:
X		hitmsg(mtmp, mattk);
X		if (!diseasemu(mdat)) dmg = 0;
X		break;
X	    case AD_FIRE:
X		hitmsg(mtmp, mattk);
X		if(ctmp) {
X		    pline("You're on fire!");
X		    if (Fire_resistance) {
X			pline("The fire doesn't feel hot!");
X			dmg = 0;
X		    }
X		    if((int) mtmp->m_lev > rn2(20))
X			destroy_item(SCROLL_CLASS, AD_FIRE);
X		    if((int) mtmp->m_lev > rn2(20))
X			destroy_item(POTION_CLASS, AD_FIRE);
X		    if((int) mtmp->m_lev > rn2(25))
X			destroy_item(SPBOOK_CLASS, AD_FIRE);
X		} else dmg = 0;
X		break;
X	    case AD_COLD:
X		hitmsg(mtmp, mattk);
X		if(ctmp) {
X		    pline("You're covered in frost!");
X		    if (Cold_resistance) {
X			pline("The frost doesn't seem cold!");
X			dmg = 0;
X		    }
X		    if((int) mtmp->m_lev > rn2(20))
X			destroy_item(POTION_CLASS, AD_COLD);
X		} else dmg = 0;
X		break;
X	    case AD_ELEC:
X		hitmsg(mtmp, mattk);
X		if(ctmp) {
X		    You("get zapped!");
X		    if (Shock_resistance) {
X			pline("The zap doesn't shock you!");
X			dmg = 0;
X		    }
X		    if((int) mtmp->m_lev > rn2(20))
X			destroy_item(WAND_CLASS, AD_ELEC);
X		    if((int) mtmp->m_lev > rn2(20))
X			destroy_item(RING_CLASS, AD_ELEC);
X		} else dmg = 0;
X		break;
X	    case AD_SLEE:
X		hitmsg(mtmp, mattk);
X		if(ctmp && multi >= 0 && !rn2(5)) {
X		    if (Sleep_resistance) break;
X		    nomul(-rnd(10));
X		    u.usleep = 1;
X		    nomovemsg = "You wake up.";
X		    if (Blind)	You("are put to sleep!");
X		    else	You("are put to sleep by %s!",mon_nam(mtmp));
X		}
X		break;
X	    case AD_DRST:
X		ptmp = A_STR;
X		goto dopois;
X	    case AD_DRDX:
X		ptmp = A_DEX;
X		goto dopois;
X	    case AD_DRCO:
X		ptmp = A_CON;
Xdopois:
X		hitmsg(mtmp, mattk);
X		if(ctmp && !rn2(8)) {
X			Sprintf(buf, "%s %s",
X				!(canseemon(mtmp) || sensemon(mtmp)) ? "Its" :
X				Hallucination ? s_suffix(rndmonnam()) : 
X				                s_suffix(mdat->mname),
X				(mattk->aatyp == AT_BITE) ? "bite" : "sting");
X			poisoned(buf, ptmp, mdat->mname, 30);
X		}
X		break;
X	    case AD_DRIN:
X		hitmsg(mtmp, mattk);
X		if (defends(AD_DRIN, uwep)
X#ifdef POLYSELF
X					|| !has_head(uasmon)
X#endif
X								) {
X		    You("don't seem harmed.");
X		    break;
X		}
X		if (uarmh && rn2(8)) {
X		    Your("helmet blocks the attack to your head.");
X		    break;
X		}
X		if (Half_physical_damage) dmg = (dmg+1) / 2;
X		losehp(dmg, mon_nam(mtmp), KILLED_BY_AN);
X		Your("brain is eaten!");
X		/* No such thing as mindless players... */
X		if (ABASE(A_INT) <= ATTRMIN(A_INT)) {
X		    int lifesaved = 0;
X		    while(1) {
X			if (lifesaved)
X			    pline("Unfortunately your brain is still gone.");
X			else
X			    Your("last thought fades away.");
X			killer = "brainlessness";
X			killer_format = KILLED_BY;
X			done(DIED);
X			lifesaved = 1;
X#ifdef WIZARD
X			if (wizard) break;
X#endif
X		    }
X		}
X		(void) adjattrib(A_INT, -rnd(2), FALSE);
X		exercise(A_WIS, FALSE);
X		break;
X	    case AD_PLYS:
X		hitmsg(mtmp, mattk);
X		if(ctmp && multi >= 0 && !rn2(3)) {
X		    if (Blind)	You("are frozen!");
X		    else	You("are frozen by %s!", mon_nam(mtmp));
X		    nomul(-rnd(10));
X		    exercise(A_DEX, FALSE);
X		}
X		break;
X	    case AD_DRLI:
X		hitmsg(mtmp, mattk);
X		if (ctmp && !rn2(3)
X#ifdef POLYSELF
X		    && !resists_drli(uasmon)
X#endif
X		    && !defends(AD_DRLI, uwep)
X		    ) losexp();
X		break;
X	    case AD_LEGS:
X		{ register long side = rn2(2) ? RIGHT_SIDE : LEFT_SIDE;
X		  if (mtmp->mcan) {
X		    pline("%s nuzzles against your %s %s!", Monnam(mtmp),
X			  (side == RIGHT_SIDE) ? "right" : "left",
X			  body_part(LEG));
X		  } else {
X		    if (uarmf) {
X			pline("%s scratches your %s boot!", Monnam(mtmp),
X				(side == RIGHT_SIDE) ? "right" : "left");
X			break;
X		    }
X		    pline("%s pricks your %s %s!", Monnam(mtmp),
X			  (side == RIGHT_SIDE) ? "right" : "left",
X			  body_part(LEG));
X		    set_wounded_legs(side, rnd(60-ACURR(A_DEX)));
X		    exercise(A_STR, FALSE);
X		    exercise(A_DEX, FALSE);
X		  }
X		  break;
X		}
X	    case AD_STON:	/* at present only a cockatrice */
X		hitmsg(mtmp, mattk);
X		if(!rn2(3) && !Stoned) {
X		    if (mtmp->mcan) {
X			if (flags.soundok)
X			    You("hear a cough from %s!", mon_nam(mtmp));
X		    } else {
X			if (flags.soundok)
X			    You("hear %s hissing!", s_suffix(mon_nam(mtmp)));
X			if((!rn2(10) ||
X			    (flags.moonphase == NEW_MOON && !have_lizard()))
X#ifdef POLYSELF
X			    && !resists_ston(uasmon)
X			    && !(poly_when_stoned(uasmon) &&
X				 polymon(PM_STONE_GOLEM))
X#endif
X			    ) {
X				Stoned = 5;
X				return(1);
X				/* You("turn to stone..."); */
X				/* done_in_by(mtmp); */
X			}
X		    }
X		}
X		break;
X	    case AD_STCK:
X		hitmsg(mtmp, mattk);
X		if(ctmp && !u.ustuck
X#ifdef POLYSELF
X				     && !sticks(uasmon)
X#endif
X							) u.ustuck = mtmp;
X		break;
X	    case AD_WRAP:
X		if(ctmp
X#ifdef POLYSELF
X			&& !sticks(uasmon)
X#endif
X					  ) {
X		    if(!u.ustuck && !rn2(10)) {
X			pline("%s swings itself around you!", Monnam(mtmp));
X			u.ustuck = mtmp;
X		    } else if(u.ustuck == mtmp) {
X			if (is_pool(mtmp->mx,mtmp->my)
X#ifdef POLYSELF
X			    && !is_swimmer(uasmon)
X#endif
X			    && !Magical_breathing
X			   ) {
X			    pline("%s drowns you....", Monnam(mtmp));
X			    done(DROWNING);
X			} else if(mattk->aatyp == AT_HUGS)
X			    You("are being crushed.");
X		    } else {
X			dmg = 0;
X			if(flags.verbose)
X			    pline("%s brushes against your %s.", Monnam(mtmp),
X				   body_part(LEG));
X		    }
X		} else dmg = 0;
X		break;
X	    case AD_WERE:
X		hitmsg(mtmp, mattk);
X#ifdef POLYSELF
X		if (ctmp && !rn2(4) && u.ulycn == -1
X		    && !Protection_from_shape_changers
X		    && !defends(AD_WERE,uwep)) {
X		    You("feel feverish.");
X		    exercise(A_CON, FALSE);
X		    u.ulycn = monsndx(mdat);
X		}
X#endif
X		break;
X	    case AD_SGLD:
X		hitmsg(mtmp, mattk);
X#ifdef POLYSELF
X		if (u.usym == mdat->mlet) break;
X#endif
X		if(!mtmp->mcan) stealgold(mtmp);
X		break;
X
X	    case AD_SITM:	/* for now these are the same */
X	    case AD_SEDU:
X#ifdef POLYSELF
X		if (dmgtype(uasmon, AD_SEDU)
X#  ifdef SEDUCE
X			|| dmgtype(uasmon, AD_SSEX)
X#  endif
X						) {
X			if (mtmp->minvent)
X	pline("%s brags about the goods some dungeon explorer provided.",
X	Monnam(mtmp));
X			else
X	pline("%s makes some remarks about how difficult theft is lately.",
X	Monnam(mtmp));
X			rloc(mtmp);
X			return 3;
X		} else
X#endif
X		if(mtmp->mcan) {
X		    if (!Blind) {
X			pline("%s tries to %s you, but you seem %s.",
X			    Adjmonnam(mtmp, "plain"),
X			    flags.female ? "charm" : "seduce",
X			    flags.female ? "unaffected" : "uninterested");
X		    }
X		    if(rn2(3)) {
X			rloc(mtmp);
X			return 3;
X		    }
X		} else {
X		    switch (steal(mtmp)) {
X		      case -1:
X			return 2;
X		      case 0:
X			break;
X		      default:
X			rloc(mtmp);
X			mtmp->mflee = 1;
X			return 3;
X		    }
X		}
X		break;
X#ifdef SEDUCE
X	    case AD_SSEX:
X		if(could_seduce(mtmp, &youmonst, mattk) == 1
X			&& !mtmp->mcan)
X		    if (doseduce(mtmp))
X			return 3;
X		break;
X#endif
X	    case AD_SAMU:
X		hitmsg(mtmp, mattk);
X		/* when the Wiz hits, 1/20 steals the amulet */
X		if (!u.uhave.amulet) break;
X		if (!rn2(20)) stealamulet(mtmp);
X		break;
X
X	    case AD_TLPT:
X		hitmsg(mtmp, mattk);
X		if(ctmp) {
X		    if(flags.verbose)
X			Your("position suddenly seems very uncertain!");
X		    tele();
X		}
X		break;
X	    case AD_RUST:
X		hitmsg(mtmp, mattk);
X		if (mtmp->mcan) break;
X#if defined(POLYSELF)
X		if (u.umonnum == PM_IRON_GOLEM) {
X			You("rust!");
X			rehumanize();
X			break;
X		}
X#endif
X		hurtarmor(mdat, AD_RUST);
X		break;
X	    case AD_DCAY:
X		hitmsg(mtmp, mattk);
X		if (mtmp->mcan) break;
X#if defined(POLYSELF)
X		if (u.umonnum == PM_WOOD_GOLEM ||
X		    u.umonnum == PM_LEATHER_GOLEM) {
X			You("rot!");
X			rehumanize();
X			break;
X		}
X#endif
X		hurtarmor(mdat, AD_DCAY);
X		break;
X	    case AD_HEAL:
X		if(!uwep
X#ifdef TOURIST
X		   && !uarmu
X#endif
X		   && !uarm && !uarmh && !uarms && !uarmg && !uarmc && !uarmf) {
X		    pline("%s hits!  (I hope you don't mind.)", Monnam(mtmp));
X#ifdef POLYSELF
X			if (u.mtimedone) {
X				u.mh += rnd(7);
X				if(!rn2(7)) u.mhmax++;
X				if(u.mh > u.mhmax) u.mh = u.mhmax;
X				if(u.mh == u.mhmax && !rn2(50)) mongone(mtmp);
X			} else {
X#endif
X				u.uhp += rnd(7);
X				if(!rn2(7)) u.uhpmax++;
X				if(u.uhp > u.uhpmax) u.uhp = u.uhpmax;
X				if(u.uhp == u.uhpmax && !rn2(50)) mongone(mtmp);
X#ifdef POLYSELF
X			}
X#endif
X		        exercise(A_STR, TRUE);
X		        exercise(A_CON, TRUE);
X			flags.botl = 1;
X			if(!rn2(50)) rloc(mtmp);
X			dmg = 0;
X		} else
X		    if(pl_character[0] == 'H') {
X			    if (flags.soundok && !(moves % 5))
X				verbalize("Doc, I can't help you unless you cooperate.");
X			    dmg = 0;
X		    } else hitmsg(mtmp, mattk);
X		break;
X	    case AD_CURS:
X		hitmsg(mtmp, mattk);
X		if(!night() && mdat == &mons[PM_GREMLIN]) break;
X		if(!mtmp->mcan && !rn2(10)) {
X		    if (flags.soundok)
X			if (Blind) You("hear laughter.");
X			else       pline("%s chuckles.", Monnam(mtmp));
X#ifdef POLYSELF
X		    if (u.umonnum == PM_CLAY_GOLEM) {
X			pline("Some writing vanishes from your head!");
X			rehumanize();
X			break;
X		    }
X#endif
X		    attrcurse();
X		}
X		break;
X	    case AD_STUN:
X		hitmsg(mtmp, mattk);
X		if(!mtmp->mcan && !rn2(4)) {
X		    make_stunned(HStun + dmg, TRUE);
X		    dmg /= 2;
X		}
X		break;
X	    case AD_ACID:
X		hitmsg(mtmp, mattk);
X		if(!mtmp->mcan && !rn2(3))
X#ifdef POLYSELF
X		    if (resists_acid(uasmon)) {
X			pline("You're covered in acid, but it seems harmless.");
X			dmg = 0;
X		    } else
X#endif
X		      {
X			pline("You're covered in acid!	It burns!");
X			exercise(A_STR, FALSE);
X		      }
X		else		dmg = 0;
X		break;
X	    case AD_SLOW:
X		hitmsg(mtmp, mattk);
X		if(!ctmp && (Fast & (INTRINSIC|TIMEOUT)) &&
X					!defends(AD_SLOW, uwep) && !rn2(4)) {
X		    Fast &= ~(INTRINSIC|TIMEOUT);
X		    You("feel yourself slowing down.");
X		    exercise(A_DEX, FALSE);
X		}
X		break;
X	    case AD_DREN:
X		hitmsg(mtmp, mattk);
X		if(!ctmp && !rn2(4)) drain_en(dmg);
X		dmg = 0;
X		break;
X	    case AD_CONF:
X		hitmsg(mtmp, mattk);
X		if(!mtmp->mcan && !rn2(4) && !mtmp->mspec_used) {
X		    mtmp->mspec_used = mtmp->mspec_used + (dmg + rn2(6));
X		    if(Confusion)
X			 You("are getting even more confused.");
X		    else You("are getting confused.");
X		    make_confused(HConfusion + dmg, FALSE);
X		}
X		/* fall through to next case */
X	    case AD_DETH:
X		pline("%s reaches out with its deadly touch.", Monnam(mtmp));
X#ifdef POLYSELF
X		if (is_undead(uasmon)) {
X		    /* Still does normal damage */
X		    pline("Was that the touch of death?");
X		    break;
X		}
X#endif
X		if(!Antimagic && rn2(20) > 16)  {
X		    killer_format = KILLED_BY_AN;
X		    killer = "touch of death";
X		    done(DIED);
X		} else {
X		    if(!rn2(5)) {
X			if(Antimagic) shieldeff(u.ux, u.uy);
X			pline("Lucky for you, it didn't work!");
X			dmg = 0;
X		    } else You("feel your life force draining away...");
X		}
X		break;
X	    case AD_PEST:
X		pline("%s reaches out, and you feel fever and chills.",
X			Monnam(mtmp));
X		(void) diseasemu(mdat); /* plus the normal damage */
X		break;
X	    case AD_FAMN:
X		pline("%s reaches out, and your body shrivels.",
X			Monnam(mtmp));
X		exercise(A_CON, FALSE);
X		morehungry(rn1(40,40));
X		/* plus the normal damage */
X		break;
X	    default:	dmg = 0;
X			break;
X	}
X	if(u.uhp < 1) done_in_by(mtmp);
X
X/*	Negative armor class reduces damage done instead of fully protecting
X *	against hits.
X */
X	if (dmg && u.uac < 0) {
X		dmg -= rnd(-u.uac);
X		if (dmg < 1) dmg = 1;
X	}
X
X	if(dmg) {
X	    if(Half_physical_damage)
X		dmg = (dmg+1) / 2;
X#ifdef MULDGN
X	    else if(pl_character[0] == 'P' && uwep && is_quest_artifact(uwep)
X		    && is_undead(mtmp->data))
X		dmg = (dmg+1) / 2;
X#endif
X	    mdamageu(mtmp, dmg);
X	}
X
X#ifdef POLYSELF
X	res = passiveum(olduasmon, mtmp, mattk);
X	stop_occupation();
X	return res;
X#else
X	stop_occupation();
X	return 1;
X#endif
X}
X
X#endif /* OVL1 */
END_OF_FILE
if test 33906 -ne `wc -c <'src/mhitu.c1'`; then
    echo shar: \"'src/mhitu.c1'\" unpacked with wrong size!
fi
# end of 'src/mhitu.c1'
fi
echo shar: End of archive 56 \(of 108\).
cp /dev/null ark56isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \
21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \
41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 \
61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 \
81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 \
101 102 103 104 105 106 107 108 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 108 archives.
    echo "Now execute 'rebuild.sh'"
    rm -f ark10[0-8]isdone ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
