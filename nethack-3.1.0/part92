Path: uunet!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v16i100:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Part92/108
Message-ID: <4465@master.CNA.TEK.COM>
Date: 5 Feb 93 22:02:44 GMT
Sender: news@master.CNA.TEK.COM
Lines: 2409
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1651

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 16, Issue 100
Archive-name: nethack31/Part92
Supersedes: nethack3p9: Volume 10, Issue 46-108
Environment: Amiga, Atari, Mac, MS-DOS, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 92 (of 108)."
# Contents:  dat/tower.des doc/lev_comp.6 src/botl.c sys/amiga/amidos.c
#   sys/vms/vmsmain.c win/X11/winmenu.c
# Wrapped by billr@saab on Wed Jan 27 16:09:25 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'dat/tower.des' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dat/tower.des'\"
else
echo shar: Extracting \"'dat/tower.des'\" \(3290 characters\)
sed "s/^X//" >'dat/tower.des' <<'END_OF_FILE'
X#	SCCS Id: @(#)tower.des	3.1	90/02/26
X#	Copyright (c) 1989 by Jean-Christophe Collet
X# NetHack may be freely redistributed.  See license for details.
X#
X# Upper stage of Vlad's tower
XMAZE:"tower1",' '
XFLAGS: noteleport,hardfloor
XGEOMETRY:half-left,center
XMAP
X  --- --- ---  
X  |.| |.| |.|  
X---S---S---S---
X|.......+.+...|
X---+-----.-----
X  |...\.|.+.|  
X---+-----.-----
X|.......+.+...|
X---S---S---S---
X  |.| |.| |.|  
X  --- --- ---  
XENDMAP
XLADDER:(11,05),down
X# The lord and his court
XMONSTER:'V',"Vlad the Impaler",(06,05)
XMONSTER:'V',random,(03,09)
XMONSTER:'V',random,(07,09)
XMONSTER:'V',random,(11,09)
XMONSTER:'V',random,(03,01)
XMONSTER:'V',random,(07,01)
XMONSTER:'V',random,(11,01)
X# The doors
XDOOR:closed,(08,03)
XDOOR:closed,(10,03)
XDOOR:closed,(03,04)
XDOOR:locked,(10,05)
XDOOR:locked,(08,07)
XDOOR:locked,(10,07)
XDOOR:closed,(03,06)
X# treasures
XOBJECT:'(',"chest",(07,05)
XOBJECT:'(',"chest",(03,09)
XOBJECT:'(',"chest",(07,09)
XOBJECT:'(',"chest",(11,09)
XOBJECT:'(',"chest",(03,01)
XOBJECT:'(',"chest",(07,01)
XOBJECT:'(',"chest",(11,01)
X# We have to protect the tower against outside attacks
XNON_DIGGABLE:(00,00,14,10)
X
X
X# Intermediate stage of Vlad's tower
XMAZE:"tower2",' '
XFLAGS: noteleport,hardfloor
XGEOMETRY:half-left,center
XMAP
X  --- --- ---  
X  |.| |.| |.|  
X---S---S---S---
X|.S.........S.|
X---.------+----
X  |......|..|  
X--------.------
X|.S......+..S.|
X---S---S---S---
X  |.| |.| |.|  
X  --- --- ---  
XENDMAP
X# Random places are the 10 niches
XRANDOM_PLACES:(03,01),(07,01),(11,01),(01,03),(13,03),
X	      (01,07),(13,07),(03,09),(07,09),(11,09)
XLADDER:(11,05),up
XLADDER:(03,07),down
XDOOR:locked,(10,04)
XDOOR:locked,(09,07)
XMONSTER:'&',random,place[0]
XMONSTER:'&',random,place[1]
XMONSTER:'d',"hell hound pup",place[2]
XMONSTER:'d',"hell hound pup",place[3]
XMONSTER:'d',"winter wolf",place[4]
XOBJECT:'"',"amulet of life saving",place[5]
XOBJECT:'"',"amulet of strangulation",place[6]
XOBJECT:'[',"water walking boots",place[7]
XOBJECT:'[',"crystal plate mail",place[8]
XOBJECT:'+',"invisibility",place[9]
X# Walls in the tower are non diggable
XNON_DIGGABLE:(00,00,14,10)
X
X
X# Bottom most stage of Vlad's tower
XMAZE:"tower3",' '
XFLAGS: noteleport,hardfloor
XGEOMETRY:half-left,center
XMAP
X    --- --- ---  
X    |.| |.| |.|  
X  ---S---S---S---
X  |.S.........S.|
X-----.........-----
X|...|.........+...|
X|.---.........---.|
X|.|.S.........S.|.|
X|.---S---S---S---.|
X|...|.|.|.|.|.|...|
X---.---.---.---.---
X  |.............|  
X  ---------------  
XENDMAP
X# Random places are the 10 niches
XRANDOM_PLACES:(05,01),(09,01),(13,01),(03,03),(15,03),
X	      (03,07),(15,07),(05,09),(09,09),(13,09)
XBRANCH:(02,05,02,05),(00,00,00,00)
XLADDER:(05,07),up
X# Entry door is, of course, locked
XDOOR:locked,(14,05)
X# Let's put a dragon behind the door, just for the fun...
XMONSTER:'D',random,(13,05)
XMONSTER:random,random,(12,04)
XMONSTER:random,random,(12,06)
XMONSTER:random,random,random
XMONSTER:random,random,random
XMONSTER:random,random,random
XMONSTER:random,random,random
XMONSTER:random,random,random
XMONSTER:random,random,random
XOBJECT:')',"long sword",place[0]
XTRAP:random,place[0]
XOBJECT:'(',"lock pick",place[1]
XTRAP:random,place[1]
XOBJECT:'[',"elven cloak",place[2]
XTRAP:random,place[2]
XOBJECT:'(',"blindfold",place[3]
XTRAP:random,place[3]
X# Walls in the tower are non diggable
XNON_DIGGABLE:(00,00,18,12)
END_OF_FILE
if test 3290 -ne `wc -c <'dat/tower.des'`; then
    echo shar: \"'dat/tower.des'\" unpacked with wrong size!
fi
# end of 'dat/tower.des'
fi
if test -f 'doc/lev_comp.6' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/lev_comp.6'\"
else
echo shar: Extracting \"'doc/lev_comp.6'\" \(10188 characters\)
sed "s/^X//" >'doc/lev_comp.6' <<'END_OF_FILE'
X.TH LEV_COMP 6 "29 Dec 1992"
X.UC 4
X.SH NAME
Xlev_comp \- NetHack special levels compiler
X.SH SYNOPSIS
X.B lev_comp
X[
X.B \-w
X]
X[
X.I files
X]
X.PP
XIf no arguments are given, it reads standard input.
X.SH DESCRIPTION
X.PP
X.I Lev_comp
Xis a special level compiler for NetHack version 3.1 and higher.  It
Xtakes description files as arguments and produces level files that can
Xbe loaded by NetHack at runtime.
X.PP
XThe purpose of this tool is to provide NetHack administrators and
Ximplementors with a convenient way for adding special levels to the
Xgame, or modifying existing ones, without having to recompile the
Xentire world.
X.PP
XThe
X.B \-w
Xoption causes
X.I lev_comp
Xto perform extra checks on the level and display extra warnings, however
Xthese warnings are sometimes superfluous, so they are not normally displayed.
X
X.SH GRAMMAR
X.PP
X.LP
X.nf
X.ta +8n +8n +8n +8n
X
Xfile		: /* nothing */
X		| levels
X
Xlevels		: level
X		| level levels
X
Xlevel		: maze_level
X    		| room_level
X
Xmaze_level	: maze_def flags lev_init messages regions
X
Xroom_level	: level_def flags lev_init messages
X		  rreg_init rooms corridors_def
X
Xlevel_def	: "LEVEL" ':' string
X
Xlev_init	: /* nothing */
X		| "INIT_MAP" ':' fgtyp ',' bgtyp ',' smooth ','
X		  joined ',' light_state ',' walled
X
Xfgtyp		: CHAR /* a MAP map_contents character */
X
Xbgtyp		: CHAR /* a MAP map_contents character */
X
Xsmooth		: boolean
X
Xjoined		: boolean
X
Xwalled		: boolean | "random"
X
Xflags		: /* nothing */
X		| "FLAGS" ':' flag_list
X
Xflag_list	: flag_type
X		| flag_type ',' flag_list
X
Xflag_type	: "noteleport" | "hardfloor" | "nommap"  | "shortsighted"
X
Xmessages	: /* nothing */
X		| message messages
X
Xmessage		: "MESSAGE" ':' STRING
X
Xrreg_init	: /* nothing */
X		| rreg_init init_rreg
X
Xinit_rreg	: "RANDOM_OBJECTS" ':' object_list
X		| "RANDOM_MONSTERS" ':' monster_list
X
Xrooms		: /* nothing */
X		| roomlist
X
Xroomlist	: aroom
X		| aroom rooms
X
Xcorridors_def	: random_corridors
X		| corridors
X
Xrandom_corridors: "RANDOM_CORRIDOR"
X
Xcorridors	: /* nothing */
X		| corridors corridor
X
Xcorridor	: "CORRIDOR" ':' corr_spec ',' corr_spec
X		| "CORRIDOR" ':' corr_spec ',' INTEGER
X
Xcorr_spec	: '(' INTEGER ',' direction ',' door_pos ')'
X
Xdirection	: "north" | "south" | "east" | "west"
X
Xaroom		: room_def room_details
X		| subroom_def room_details
X
Xsubroom_def	: "SUBROOM" ':' room_type ',' light_state ','
X		  subroom_pos ',' room_size ',' string
X
Xroom_def	: "ROOM" ':' room_type ',' light_state ','
X		  room_pos ',' room_align ',' room_size
X
Xroom_pos	: '(' INTEGER ',' INTEGER ')'
X		| "random"
X
Xsubroom_pos	: '(' INTEGER ',' INTEGER ')'
X		| "random"
X
Xroom_align	: '(' h_justif ',' v_justif ')'
X		| "random"
X
Xroom_size	: '(' INTEGER ',' INTEGER ')'
X		| "random"
X
Xroom_details	: /* nothing */
X		| room_details room_detail
X
Xroom_detail	: room_name
X		| room_chance
X		| room_door
X		| monster_detail
X		| object_detail
X		| trap_detail
X		| altar_detail
X		| fountain_detail
X		| sink_detail
X		| pool_detail
X		| gold_detail
X		| engraving_detail
X		| stair_detail
X
Xroom_name	: "NAME" ':' string
X
Xroom_chance	: "CHANCE" ':' INTEGER
X
Xroom_door	: "DOOR" ':' secret ',' door_state ','
X		  door_wall ',' door_pos
X
Xsecret		: boolean
X		| "random"
X
Xdoor_wall	: direction
X		| "random"
X
Xdoor_pos	: INTEGER
X		| "random"
X
Xboolean		: "true" | "false"
X
Xmaze_def	: "MAZE" ':' string ',' filling
X
Xfilling		: CHAR
X		| "random"
Xregions 	: aregion
X		| aregion regions
X
Xaregion 	: map_definition reg_init map_details
X
Xmap_definition	: "NOMAP"
X		| map_geometry "MAP" map_contents "ENDMAP"
X
Xmap_geometry	: "GEOMETRY" ':' h_justif ',' v_justif
X
Xmap_contents	: /* see discussion below */
X
Xh_justif	: "left" | "half-left" | "right" | "half-right"
X		| "center"
X
Xv_justif	: "top" | "bottom"
X		| "center"
X
Xreg_init	: /* nothing */
X		| reg_init init_reg
X
Xinit_reg	: "RANDOM_OBJECTS" ':' object_list
X		| "RANDOM_PLACES" ':' place_list
X		| "RANDOM_MONSTERS" ':' monster_list
X
Xobject_list	: object
X		| object ',' object_list
X
Xmonster_list	: monster
X		| monster ',' monster_list
X
Xplace_list	: place
X		| place ',' place_list
X
Xmap_details	: /* nothing */
X		| map_details map_detail
X
Xmap_detail	: monster_detail
X		| object_detail
X		| door_detail
X		| trap_detail
X		| drawbridge_detail
X		| region_detail
X		| stair_region
X		| portal_region
X		| teleprt_region
X		| branch_region
X		| altar_detail
X		| fountain_detail
X		| mazewalk_detail
X                | wallify_detail
X		| ladder_detail
X		| stair_detail
X		| gold_detail
X		| engraving_detail
X		| diggable_detail
X
Xmonster_detail	: "MONSTER" ':' monster_c ',' m_name ',' coordinate
X		  monster_infos
X
Xmonster_infos	: /* nothing */
X		| monster_infos monster_info
X
Xmonster_info	: ',' string
X		| ',' mon_attitude
X		| ',' mon_alertness
X		| ',' alignment
X		| ',' "m_feature" string
X		| ',' "m_monster" string
X		| ',' "m_object" string
X
Xmon_attitude	: "peaceful" | "hostile"
X
Xmon_alertness	: "asleep" | "awake"
X
Xobject_detail	: "OBJECT" ':' object_c ',' o_name ',' coordinate
X		  object_infos
X
Xobject_infos	: /* nothing */
X		| ',' STRING ',' enchantment
X    		| ',' curse_state ',' enchantment ',' art_name
X
Xcurse_state	: "random"
X		| "blessed" | "uncursed" | "cursed"
X
Xenchantment	: INTEGER
X		| "random"
X
Xdoor_detail	: "DOOR" ':' door_state ',' coordinate
X
Xtrap_detail	: "TRAP" ':' trap_name ',' coordinate
X
Xdrawbridge_detail: "DRAWBRIDGE" ':' coordinate ','
X		  direction ',' door_state
X
Xmazewalk_detail	: "MAZEWALK" ':' coordinate ',' direction
X
Xwallify_detail	: "WALLIFY"
X
Xladder_detail	: "LADDER" ':' coordinate ',' up_or_down
X
Xstair_detail	: "STAIR" ':' coordinate ',' up_or_down
X
Xstair_region	: "STAIR" ':' lev_region ',' lev_region ',' up_or_down
X
Xup_or_down:	: "up" | "down"
X
Xportal_region	: "PORTAL" ':' lev_region ',' lev_region ',' string
X
Xteleprt_region	: "TELEPORT_REGION" ':' lev_region
X		  ',' lev_region teleprt_detail
X
Xbranch_region	: "BRANCH" ':' lev_region ',' lev_region
X
Xteleprt_detail	: /* empty */
X		| ',' up_or_down
X
Xlev_region	: region
X		| "levregion"
X		  '(' INTEGER ',' INTEGER ',' INTEGER ',' INTEGER ')'
X
Xfountain_detail	: "FOUNTAIN" ':' coordinate
X
Xsink_detail	: "SINK" ':' coordinate
X
Xpool_detail	: "POOL" ':' coordinate
X
Xdiggable_detail	: "NON_DIGGABLE" ':' region
X
Xregion_detail	: "REGION" ':' region ',' light_state ','
X		  room_type prefilled
X
Xaltar_detail	: "ALTAR" ':' coordinate ',' alignment ',' altar_type
X
Xgold_detail	: "GOLD" ':' amount ',' coordinate
X
Xengraving_detail: "ENGRAVING" ':' coordinate ','
X		  engraving_type ',' string
X
Xmonster_c	: monster
X		| "random"
X		| m_register
X
Xobject_c	: object
X		| "random"
X		| o_register
X
Xm_name		: string
X		| "random"
X
Xo_name		: string
X		| "random"
X
Xtrap_name	: string
X		| "random"
X
Xroom_type	: string
X		| "random"
X
Xprefilled	: /* empty */
X		| ',' filling
X		| ',' filling ',' irregular
X
Xfilling		: "filled" | "unfilled"
X
Xirregular	: boolean /* irregular shaped room around region */
X
Xcoordinate	: coord
X		| p_register
X		| "random"
X
Xdoor_state	: "open" | "closed" | "locked" | "nodoor" | "broken"
X		| "random"
X
Xlight_state	: "lit" | "unlit"
X		| "random"
X
Xalignment	: "noalign" | "law" | "neutral" | "chaos"
X		| a_register
X		| "random"
X
Xaltar_type	: "sanctum" | "shrine" | "altar"
X		| "random"
X
Xp_register	: "place" '[' INTEGER ']'
X
Xo_register	: "object" '[' INTEGER ']'
X
Xm_register	: "monster" '[' INTEGER ']'
X
Xa_register	: "align" '[' INTEGER ']'
X
Xplace		: coord
X
Xmonster 	: CHAR
X
Xobject		: CHAR
X
Xstring		: STRING
X
Xart_name	: STRING
X		| "none"
X
Xamount		: INTEGER
X		| "random"
X
Xengraving_type	: "dust" | "engrave" | "burn" | "mark"
X		| "random"
X
Xcoord		: '(' INTEGER ',' INTEGER ')'
X
Xregion		: '(' INTEGER ',' INTEGER ',' INTEGER ',' INTEGER ')'
X.fi
X.PP
X.I NOTE:
X.br
XLines beginning with '#' are considered comments.
X.PP
XThe contents of a "MAP" description of a maze is a rectangle showing the exact
Xlevel map that should be used for the given part of a maze.
XEach character in the map corresponds to a location on the screen.
XDifferent location types are denoted using different ASCII characters.
XThe following characters are recognized.
XTo give an idea of how these are used, see the EXAMPLE, below.
XThe maximum size of a map is normally 76 columns by 21 rows.
X.LP
X.nf
X.ta +8n +8n +8n
X\&'-'	horizontal wall
X\&'|'	vertical wall
X\&'+'	a doorway (state is specified in a DOOR declaration)
X\&'A'	open air
X\&'B'	boundary room location (for bounding unwalled irregular regions)
X\&'C'	cloudy air
X\&'I'	ice
X\&'S'	a secret door
X\&'{'	a fountain
X\&'\\'	a throne
X\&'K'	a sink (if SINKS is defined, else a room location)
X\&'}'	a part of a moat or other deep water
X\&'P'	a pool
X\&'L'	lava
X\&'#'	a corridor
X\&'.'	a normal room location (unlit unless lit in a REGION declaration)
X\&' '	stone
X.fi
X.SH EXAMPLE
X.PP
XHere is an example of a description file (a very simple one):
X.LP
X.nf
X.ta +8n +8n +8n
XMAZE : "fortress", random
XGEOMETRY : center , center
XMAP
X}}}}}}}}}
X}}}|-|}}}
X}}|-.-|}}
X}|-...-|}
X}|.....|}
X}|-...-|}
X}}|-.-|}}
X}}}|-|}}}
X}}}}}}}}}
XENDMAP
XMONSTER: '@', "Wizard of Yendor", (4,4)
XOBJECT: '"', "Amulet of Yendor", (4,4)
X# a hell hound flanking the Wiz on a random side
XRANDOM_PLACES: (4,3), (4,5), (3,4), (5,4)
XMONSTER: 'd', "hell hound", place[0]
X# a chest on another random side
XOBJECT: '(', "chest", place[1]
X# a random dragon somewhere
XMONSTER: 'D', random, random
X# a random trap in the EAST end
XTRAP: random, (6,4)
X# an electric eel below the SOUTH end
XMONSTER: ';', "electric eel", (4,8)
X# make the walls non-diggable
XNON_DIGGABLE: (0,0,8,8)
XTELEPORT_REGION: lev_region(0,0,79,20), (0,0,8,8)
X.fi
X.PP
XThis example will produce a file named "fortress" that can be integrated into
Xone of the numerous mazes of the game.
X.PP
XNote especially the final, TELEPORT_REGION specification.  This says
Xthat level teleports or other non-stairway arrivals on this level can
Xland anywhere on the level except the area of the map.  This shows the
Xuse of the ``lev_region'' prefix allowed in certain region specifications.
XNormally, regions apply only to the most recent MAP specification, but
Xwhen prefixed with ``lev_region'', one can refer to any area of the
Xlevel, regardless of the placement of the current MAP in the level.
X.SH AUTHOR
X.PP
XJean-Christophe Collet, David Cohrs.
X.SH "SEE ALSO"
X.PP
Xdgn_comp(6), nethack(6)
X.SH BUGS
X.PP
XProbably infinite.
XMost importantly, still needs additional bounds checking.
END_OF_FILE
if test 10188 -ne `wc -c <'doc/lev_comp.6'`; then
    echo shar: \"'doc/lev_comp.6'\" unpacked with wrong size!
fi
# end of 'doc/lev_comp.6'
fi
if test -f 'src/botl.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/botl.c'\"
else
echo shar: Extracting \"'src/botl.c'\" \(9881 characters\)
sed "s/^X//" >'src/botl.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)botl.c	3.1	93/01/17	*/
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include "hack.h"
X
X#ifdef OVL0
Xextern const char *hu_stat[];	/* defined in eat.c */
X
Xconst char *enc_stat[] = {
X	"",
X	"Burdened",
X	"Stressed",
X	"Strained",
X	"Overtaxed",
X	"Overloaded"
X};
X
Xstatic void NDECL(bot1);
Xstatic void NDECL(bot2);
X#endif /* OVL0 */
X
X/* 100 suffices for bot(); must be larger than COLNO */
X#if COLNO <= 80
X#define MAXCO 100
X#else
X#define MAXCO (COLNO+20)
X#endif
X
X#ifndef OVLB
XSTATIC_DCL int mrank_sz;
X#else /* OVLB */
XSTATIC_OVL int NEARDATA mrank_sz = 0; /* loaded by max_rank_sz (from u_init) */
X#endif /* OVLB */
X
Xstruct rank_title {
X    char const * const	m;	/* male title */
X    char const * const	f;	/* female title, or 0 if same as male */
X};
Xstruct class_ranks {
X    char		plclass, fill_;
X    short		mplayer_class;
X    struct rank_title	titles[9];
X};
X
XSTATIC_DCL const struct rank_title *FDECL(rank_array, (CHAR_P));
XSTATIC_DCL const char *NDECL(rank);
X
X#ifdef OVL1
X
X/* 9 pairs of ranks for each class */
X
Xstatic const
Xstruct class_ranks all_classes[] = {
X  {					'A',0,	PM_ARCHEOLOGIST, {
X	{"Digger",	0},
X	{"Field Worker",0},
X	{"Investigator",0},
X	{"Exhumer",	0},
X	{"Excavator",	0},
X	{"Spelunker",	0},
X	{"Speleologist",0},
X	{"Collector",	0},
X	{"Curator",	0}
X  } },
X  {					'B',0,	PM_BARBARIAN, {
X	{"Plunderer",	"Plunderess"},
X	{"Pillager",	0},
X	{"Bandit",	0},
X	{"Brigand",	0},
X	{"Raider",	0},
X	{"Reaver",	0},
X	{"Slayer",	0},
X	{"Chieftain",	"Chieftainess"},
X	{"Conqueror",	"Conqueress"}
X  } },
X  {					'C',0,	PM_CAVEMAN, {
X	{"Troglodyte",	0},
X	{"Aborigine",	0},
X	{"Wanderer",	0},
X	{"Vagrant",	0},
X	{"Wayfarer",	0},
X	{"Roamer",	0},
X	{"Nomad",	0},
X	{"Rover",	0},
X	{"Pioneer",	0}
X  } },
X  {					'E',0,	PM_ELF, {
X	{"Edhel",	"Elleth"},
X	{"Edhel",	"Elleth"},	/* elf-maid */
X	{"Ohtar",	"Ohtie"},	/* warrior */
X	{"Kano",			/* commander (Q.) ['a] */
X			"Kanie"}, /* educated guess, until further research- SAC */
X	{"Arandur",		  /* king's servant, minister (Q.) - guess */
X			"Aranduriel"},	/* educated guess */
X	{"Hir",		"Hiril"},	/* lord, lady (S.) ['ir] */
X	{"Aredhel",	"Arwen"},	/* noble elf, maiden (S.) */
X	{"Ernil",	"Elentariel"},	/* prince (S.), elf-maiden (Q.) */
X	{"Elentar",	"Elentari"}	/* Star-king, -queen (Q.) */
X  } },
X  {					'H',0,	PM_HEALER, {
X	{"Barber",	"Midwife"},
X	{"Leech",	0},
X	{"Embalmer",	0},
X	{"Dresser",	0},
X	{"Bone Setter",	0},
X	{"Herbalist",	0},
X	{"Apothecary",	0},
X	{"Physician",	0},
X	{"Chirurgeon",	0}
X  } },
X  {					'K',0,	PM_KNIGHT, {
X	{"Gallant",	0},
X	{"Esquire",	0},
X	{"Bachelor",	0},
X	{"Sergeant",	0},
X	{"Knight",	0},
X	{"Banneret",	0},
X	{"Chevalier",	0},
X	{"Seignieur",	0},
X	{"Paladin",	0}
X  } },
X  {					'P',0,	PM_PRIEST, {
X	{"Aspirant",	0},
X	{"Acolyte",	0},
X	{"Adept",	0},
X	{"Priest",	"Priestess"},
X	{"Curate",	0},
X	{"Canon",	"Canoness"},
X	{"Lama",	0},
X	{"Patriarch",	"Matriarch"},
X	{"High Priest", "High Priestess"}
X  } },
X  {					'R',0,	PM_ROGUE, {
X	{"Footpad",	0},
X	{"Cutpurse",	0},
X	{"Rogue",	0},
X	{"Pilferer",	0},
X	{"Robber",	0},
X	{"Burglar",	0},
X	{"Filcher",	0},
X	{"Magsman",	"Magswoman"},
X	{"Thief",	0}
X  } },
X  {					'S',0,	PM_SAMURAI, {
X	{"Hatamoto",	0},  /* Banner Knight */
X	{"Ronin",	0},  /* no allegiance */
X	{"Ninja",	0},  /* secret society */
X	{"Joshu",	0},  /* heads a castle */
X	{"Ryoshu",	0},  /* has a territory */
X	{"Kokushu",	0},  /* heads a province */
X	{"Daimyo",	0},  /* a samurai lord */
X	{"Kuge",	0},  /* Noble of the Court */
X	{"Shogun",	0}   /* supreme commander, warlord */
X  } },
X#ifdef TOURIST
X  {					'T',0,	PM_TOURIST, {
X	{"Rambler",	0},
X	{"Sightseer",	0},
X	{"Excursionist",0},
X	{"Peregrinator","Peregrinatrix"},
X	{"Traveler",	0},
X	{"Journeyer",	0},
X	{"Voyager",	0},
X	{"Explorer",	0},
X	{"Adventurer",	0}
X  } },
X#endif
X  {					'V',0,	PM_VALKYRIE, {
X	{"Stripling",	0},
X	{"Skirmisher",	0},
X	{"Fighter",	0},
X	{"Man-at-arms", "Woman-at-arms"},
X	{"Warrior",	0},
X	{"Swashbuckler",0},
X	{"Hero",	"Heroine"},
X	{"Champion",	0},
X	{"Lord",	"Lady"}
X  } },
X  {					'W',0,	PM_WIZARD, {
X	{"Evoker",	0},
X	{"Conjurer",	0},
X	{"Thaumaturge", 0},
X	{"Magician",	0},
X	{"Enchanter",	"Enchantress"},
X	{"Sorcerer",	"Sorceress"},
X	{"Necromancer", 0},
X	{"Wizard",	0},
X	{"Mage",	0}
X  } },
X};
X
XSTATIC_OVL const struct rank_title *
Xrank_array(pc)
Xchar pc;
X{
X	register int i;
X
X	for (i = 0; i < SIZE(all_classes); i++)
X	    if (all_classes[i].plclass == pc) return all_classes[i].titles;
X	return 0;
X}
X
X/* convert experience level (1..30) to rank index (0..8) */
Xint xlev_to_rank(xlev)
Xint xlev;
X{
X	return (xlev <= 2) ? 0 : (xlev <= 30) ? ((xlev + 2) / 4) : 8;
X}
X
X#if 0	/* not currently needed */
X/* convert rank index (0..8) to experience level (1..30) */
Xint rank_to_xlev(rank)
Xint rank;
X{
X	return (rank <= 0) ? 1 : (rank <= 8) ? ((rank * 4) - 2) : 30;
X}
X#endif
X
Xconst char *
Xrank_of(lev, pc, female)
Xregister unsigned lev;
Xchar pc;
Xboolean female;
X{
X	register int idx = xlev_to_rank((int)lev);
X	const struct rank_title *ranks = rank_array(pc);
X
X	if (ranks)
X	    return( female && ranks[idx].f ? ranks[idx].f : ranks[idx].m );
X	return(pl_character);
X}
X
XSTATIC_OVL const char *
Xrank()
X{
X	return(rank_of(u.ulevel, pl_character[0], flags.female));
X}
X
Xint
Xtitle_to_mon(str, rank_indx, title_length)
Xconst char *str;
Xint *rank_indx, *title_length;
X{
X	register int i, j;
X	register const struct rank_title *ttl;
X
X	for (i = 0; i < SIZE(all_classes); i++)
X	    for (j = 0; j < 9; j++) {
X		ttl = &all_classes[i].titles[j];
X		if (!strncmpi(ttl->m, str, strlen(ttl->m))) {
X		    if (rank_indx) *rank_indx = j;
X		    if (title_length) *title_length = strlen(ttl->m);
X		    return all_classes[i].mplayer_class;
X		} else if (ttl->f && !strncmpi(ttl->f, str, strlen(ttl->f))) {
X		    if (rank_indx) *rank_indx = j;
X		    if (title_length) *title_length = strlen(ttl->f);
X		    return all_classes[i].plclass == 'C' ? PM_CAVEWOMAN :
X			   all_classes[i].plclass == 'P' ? PM_PRIESTESS :
X			   all_classes[i].mplayer_class;
X		}
X	    }
X	return -1;	/* not found */
X}
X
X#endif /* OVL1 */
X#ifdef OVLB
X
Xvoid
Xmax_rank_sz()
X{
X	register int i, r, maxr = 0;
X	const struct rank_title *ranks = rank_array(pl_character[0]);
X
X	if (ranks) {
X	    for (i = 0; i < 9; i++) {
X		if ((r = strlen(ranks[i].m)) > maxr) maxr = r;
X		if (ranks[i].f)
X		    if ((r = strlen(ranks[i].f)) > maxr) maxr = r;
X	    }
X	    mrank_sz = maxr;
X	}
X	else mrank_sz = strlen(pl_character);
X}
X
X#endif /* OVLB */
X#ifdef OVL0
X
Xstatic void
Xbot1()
X{
X	char newbot1[MAXCO];
X	register char *nb;
X	register int i,j;
X
X	Strcpy(newbot1, plname);
X	if('a' <= newbot1[0] && newbot1[0] <= 'z') newbot1[0] += 'A'-'a';
X	newbot1[10] = 0;
X	Sprintf(nb = eos(newbot1)," the ");
X#ifdef POLYSELF
X	if (u.mtimedone) {
X		char mbot[BUFSZ];
X		int k = 0;
X
X		Strcpy(mbot, mons[u.umonnum].mname);
X		while(mbot[k] != 0) {
X		    if ((k == 0 || (k > 0 && mbot[k-1] == ' ')) &&
X					'a' <= mbot[k] && mbot[k] <= 'z')
X			mbot[k] += 'A' - 'a';
X		    k++;
X		}
X		Sprintf(nb = eos(nb), mbot);
X	} else
X		Sprintf(nb = eos(nb), rank());
X#else
X	Sprintf(nb = eos(nb), rank());
X#endif
X	Sprintf(nb = eos(nb),"  ");
X	i = mrank_sz + 15;
X	j = (nb + 2) - newbot1; /* aka strlen(newbot1) but less computation */
X	if((i - j) > 0)
X		Sprintf(nb = eos(nb),"%*s", i-j, " ");	/* pad with spaces */
X	if (ACURR(A_STR) > 18) {
X		if (ACURR(A_STR) > 118)
X		    Sprintf(nb = eos(nb),"St:%2d ",ACURR(A_STR)-100);
X		else if (ACURR(A_STR) < 118)
X		    Sprintf(nb = eos(nb), "St:18/%02d ",ACURR(A_STR)-18);
X		else
X		    Sprintf(nb = eos(nb),"St:18/** ");
X	} else
X		Sprintf(nb = eos(nb), "St:%-1d ",ACURR(A_STR));
X	Sprintf(nb = eos(nb),
X		"Dx:%-1d Co:%-1d In:%-1d Wi:%-1d Ch:%-1d",
X		ACURR(A_DEX), ACURR(A_CON), ACURR(A_INT), ACURR(A_WIS), ACURR(A_CHA));
X	Sprintf(nb = eos(nb), (u.ualign.type == A_CHAOTIC) ? "  Chaotic" :
X			(u.ualign.type == A_NEUTRAL) ? "  Neutral" : "  Lawful");
X#ifdef SCORE_ON_BOTL
X	if (flags.showscore) {
X	    int deepest = deepest_lev_reached(FALSE);
X	    long ugold = u.ugold + hidden_gold();
X
X	    if ((ugold -= u.ugold0) < 0L) ugold = 0L;
X	    Sprintf(nb = eos(nb), " S:%ld",
X		    ugold + u.urexp + (long)(50 * (deepest - 1))
X			  + (long)(deepest > 30 ? 10000 :
X				   deepest > 20 ? 1000*(deepest - 20) : 0));
X	}
X#endif
X	curs(WIN_STATUS, 1, 0);
X	putstr(WIN_STATUS, 0, newbot1);
X}
X
Xstatic void
Xbot2()
X{
X	char  newbot2[MAXCO];
X	register char *nb;
X	int hp, hpmax;
X	int cap = near_capacity();
X
X#ifdef POLYSELF
X	hp = u.mtimedone ? u.mh : u.uhp;
X	hpmax = u.mtimedone ? u.mhmax : u.uhpmax;
X#else
X	hp = u.uhp;
X	hpmax = u.uhpmax;
X#endif
X	if(hp < 0) hp = 0;
X/* TODO:	Add in dungeon name */
X#ifdef MULDGN
X	if(Is_knox(&u.uz)) Sprintf(newbot2, "%s ", dungeons[u.uz.dnum].dname);
X	else
X	if(In_quest(&u.uz)) Sprintf(newbot2, "Home %d ", dunlev(&u.uz));
X	else
X#endif
X	if(In_endgame(&u.uz))
X		Sprintf(newbot2,
X			Is_astralevel(&u.uz) ? "Astral Plane " : "End Game ");
X	else
X		Sprintf(newbot2, "Dlvl:%-2d ", depth(&u.uz));
X	Sprintf(nb = eos(newbot2),
X		"%c:%-2ld HP:%d(%d) Pw:%d(%d) AC:%-2d", oc_syms[GOLD_CLASS],
X		u.ugold, hp, hpmax, u.uen, u.uenmax, u.uac);
X#ifdef POLYSELF
X	if (u.mtimedone)
X		Sprintf(nb = eos(nb), " HD:%d", mons[u.umonnum].mlevel);
X	else
X#endif
X#ifdef EXP_ON_BOTL
X	if(flags.showexp)
X		Sprintf(nb = eos(nb), " Xp:%u/%-1ld", u.ulevel,u.uexp);
X	else
X#endif
X	Sprintf(nb = eos(nb), " Exp:%u", u.ulevel);
X	if(flags.time)
X	    Sprintf(nb = eos(nb), " T:%ld", moves);
X	if(strcmp(hu_stat[u.uhs], "        ")) {
X		Sprintf(nb = eos(nb), " ");
X		Strcat(newbot2, hu_stat[u.uhs]);
X	}
X	if(Confusion)	   Sprintf(nb = eos(nb), " Conf");
X	if(Sick)	   Sprintf(nb = eos(nb), " Sick");
X	if(Blind)	   Sprintf(nb = eos(nb), " Blind");
X	if(Stunned)	   Sprintf(nb = eos(nb), " Stun");
X	if(Hallucination)  Sprintf(nb = eos(nb), " Hallu");
X	if(cap > UNENCUMBERED)
X		Sprintf(nb = eos(nb), " %s", enc_stat[cap]);
X	curs(WIN_STATUS, 1, 1);
X	putstr(WIN_STATUS, 0, newbot2);
X}
X
Xvoid
Xbot()
X{
X	bot1();
X	bot2();
X	flags.botl = flags.botlx = 0;
X}
X
X#endif /* OVL0 */
X
X/*botl.c*/
END_OF_FILE
if test 9881 -ne `wc -c <'src/botl.c'`; then
    echo shar: \"'src/botl.c'\" unpacked with wrong size!
fi
# end of 'src/botl.c'
fi
if test -f 'sys/amiga/amidos.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/amiga/amidos.c'\"
else
echo shar: Extracting \"'sys/amiga/amidos.c'\" \(9824 characters\)
sed "s/^X//" >'sys/amiga/amidos.c' <<'END_OF_FILE'
X/*    SCCS Id: @(#)amidos.c     3.1    93/01/08
X/* Copyright (c) Olaf Seibert, Nijmegen, The Netherlands, 1988,1990.    */
X/* Copyright (c) Kenneth Lorber, Bethesda, Maryland, 1991, 1992, 1993.  */
X/* NetHack may be freely redistributed.  See license for details.	*/
X
X/*
X * An assortment of imitations of cheap plastic MSDOS and Unix functions.
X */
X
X#include "hack.h"
X#include "winami.h"
X
X/* Defined in config.h, let's undefine it here (static function below) */
X#undef strcmpi
X
X#include <libraries/dos.h>
X#include <exec/execbase.h>
X#include <intuition/intuition.h>
X
X#undef COUNT
X#ifdef LATTICE
X# include <proto/exec.h>
X# include <proto/dos.h>
X#endif
X
X#ifdef AZTEC_50
X# include <functions.h>
X# undef strcmpi
X#endif
X
X/* Prototypes */
X#include "Amiga:winami.p"
X#include "Amiga:amiwind.p"
X#include "Amiga:amidos.p"
X
Xextern char Initialized;
X
X#ifndef __SASC
Xint Enable_Abort = 0;   /* for stdio package */
X#endif
X
X/* Initial path, so we can find NetHack.cnf */
Xchar PATH[PATHLEN] = "Ram:;df0:;NetHack:";
X
Xstatic boolean record_exists(void);
X
Xvoid
Xflushout()
X{
X    (void) fflush(stdout);
X}
X
X#ifndef getuid
Xgetuid()
X{
X    return 1;
X}
X#endif
X
X#ifndef getlogin
Xchar *
Xgetlogin()
X{
X    return ((char *) NULL);
X}
X#endif
X
X#ifndef AZTEC_50
Xint
Xabs(x)
Xint x;
X{
X    return x < 0? -x: x;
X}
X#endif
X
X#ifdef SHELL
Xint
Xdosh()
X{
X    int i;
X    char buf[ 500 ];
X    extern struct ExecBase *SysBase;
X
X    /* Only under 2.0 and later ROMs do we have System() */
X    if( SysBase->LibNode.lib_Version >= 37 )
X    {
X	getlin("Enter CLI Command...", buf );
X	i = System( buf, NULL );
X    }
X    else
X    {
X	i = 0;
X	pline("No mysterious force prevented you from using multitasking.");
X    }
X    return i;
X}
X#endif /* SHELL */
X
X#ifdef MFLOPPY
X# include <ctype.h>
X
X# define Sprintf (void) sprintf
X
X#define EXTENSION   72
X
X/*
X *  This routine uses an approximation of the free bytes on a disk.
X *  How large a file you can actually write depends on the number of
X *  extension blocks you need for it.
X *  In each extenstion block there are maximum 72 pointers to blocks,
X *  so every 73 disk blocks have only 72 available for data.
X *  The (necessary) file header is also good for 72 data block pointers.
X */
X/* TODO: update this for FFS */
Xlong
Xfreediskspace(path)
Xchar *path;
X{
X    register long freeBytes = 0;
X    register struct InfoData *infoData; /* Remember... longword aligned */
X    char fileName[32];
X
X    /*
X     *  Find a valid path on the device of which we want the free space.
X     *  If there is a colon in the name, it is an absolute path
X     *  and all up to the colon is everything we need.
X     *  Remember slashes in a volume name are allowed!
X     *  If there is no colon, it is relative to the current directory,
X     *  so must be on the current device, so "" is enough...
X     */
X    {
X    register char *colon;
X
X    strncpy(fileName, path, sizeof(fileName) - 1);
X    fileName[31] = 0;
X    if (colon = index(fileName, ':'))
X	colon[1] = '\0';
X    else
X	fileName[0] = '\0';
X    }
X    {
X    BPTR fileLock;
X    infoData = (struct InfoData *) alloc(sizeof(struct InfoData));
X    if (fileLock = Lock(fileName, SHARED_LOCK)) {
X	if (Info(fileLock, infoData)) {
X		/* We got a kind of DOS volume, since we can Lock it. */
X		/* Calculate number of blocks available for new file */
X		/* Kludge for the ever-full VOID: (oops RAM:) device */
X	    if (infoData->id_UnitNumber == -1 &&
X	      infoData->id_NumBlocks == infoData->id_NumBlocksUsed) {
X		freeBytes = AvailMem(0L) - 64 * 1024L;
X		    /* Just a stupid guess at the */
X		    /* Ram-Handler overhead per block: */
X		freeBytes -= freeBytes/16;
X	    } else {
X		/* Normal kind of DOS file system device/volume */
X		freeBytes = infoData->id_NumBlocks - infoData->id_NumBlocksUsed;
X		freeBytes -= (freeBytes + EXTENSION) / (EXTENSION + 1);
X		freeBytes *= infoData->id_BytesPerBlock;
X	    }
X	    if (freeBytes < 0)
X		freeBytes = 0;
X	}
X	UnLock(fileLock);
X    }
X    free(infoData);
X    return freeBytes;
X    }
X}
X
X
Xlong
Xfilesize(file)
Xchar *file;
X{
X    register BPTR fileLock;
X    register struct FileInfoBlock *fileInfoBlock;
X    register long size = 0;
X
X    fileInfoBlock = (struct FileInfoBlock *)alloc(sizeof(struct FileInfoBlock));
X    if (fileLock = Lock(file, SHARED_LOCK)) {
X	if (Examine(fileLock, fileInfoBlock)) {
X	    size = fileInfoBlock->fib_Size;
X	}
X	UnLock(fileLock);
X    }
X    free(fileInfoBlock);
X    return size;
X}
X
Xvoid
Xeraseall(path, files)
Xconst char *path, *files;
X{
X    char buf[FILENAME];
X    short i;
X    BPTR fileLock, dirLock, dirLock2;
X    struct FileInfoBlock *fibp;
X    int chklen;
X#ifdef BETA
X    if(files != alllevels)panic("eraseall");
X#endif
X    chklen=(int)index(files,'*')-(int)files;
X
X    if (dirLock = Lock(path ,SHARED_LOCK)) {
X	dirLock2=DupLock(dirLock);
X	dirLock2= CurrentDir(dirLock2);
X	fibp=AllocMem(sizeof(struct FileInfoBlock),0);
X	if(fibp){
X	    if(Examine(dirLock,fibp)){
X		while(ExNext(dirLock,fibp)){
X		    if(!strncmp(fibp->fib_FileName,files,chklen)){
X			DeleteFile(fibp->fib_FileName);
X		    }
X		}
X	    }
X	    FreeMem(fibp,sizeof(struct FileInfoBlock));
X	}
X	UnLock(dirLock);
X	UnLock(CurrentDir(dirLock2));
X    }
X}
X
X/* This size makes that most files can be copied with two Read()/Write()s */
X
X#define COPYSIZE    4096
X
Xchar *CopyFile(from, to)
Xconst char *from, *to;
X{
X    register BPTR fromFile, toFile;
X    register char *buffer;
X    register long size;
X    char *error = NULL;
X
X    buffer = (char *) alloc(COPYSIZE);
X    if (fromFile = Open(from, MODE_OLDFILE)) {
X	if (toFile = Open(to, MODE_NEWFILE)) {
X	    while (size = Read(fromFile, buffer, (long)COPYSIZE)) {
X		if (size == -1){
X		    error = "Read error";
X		    break;
X		}
X		if (size != Write(toFile, buffer, size)) {
X		    error = "Write error";
X		    break;
X		}
X	    }
X	    Close(toFile);
X	} else
X	    error = "Cannot open destination";
X	Close(fromFile);
X    } else
X	error = "Cannot open source (this should not occur)";
X    free(buffer);
X    return error;
X}
X
X
X/* this should be replaced */
XsaveDiskPrompt(start)
X{
X    extern int saveprompt;
X    char buf[BUFSIZ], *bp;
X    BPTR fileLock;
X
X    if (saveprompt) {
X	    /* Don't prompt if you can find the save file */
X	if (fileLock = Lock(SAVEF, SHARED_LOCK)) {
X	    UnLock(fileLock);
X	    clear_nhwindow( WIN_BASE );
X	    return 1;
X	}
X	pline( "If save file is on a SAVE disk, put that disk in now." );
X	if( strlen( SAVEF ) > QBUFSZ - 25 - 22 )
X	    panic( "not enough buffer space for prompt" );
X	getlind("File name ?", buf, SAVEF);
X	clear_nhwindow( WIN_BASE );
X	if (!start && *buf == '\033')
X	    return 0;
X
X    /* Strip any whitespace. Also, if nothing was entered except
X     * whitespace, do not change the value of SAVEF.
X     */
X	for (bp = buf; *bp; bp++) {
X	    if (!isspace(*bp)) {
X	    strncpy(SAVEF, bp, PATHLEN);
X	    break;
X	    }
X	}
X    }
X    return 1;
X}
X
X/* Return 1 if the record file was found */
Xstatic boolean
Xrecord_exists()
X{
X    FILE *file;
X
X    if (file = fopenp(RECORD, "r")) {
X	fclose(file);
X	return TRUE;
X    }
X    return FALSE;
X}
X
X#ifdef MFLOPPY
X/*
X * Under MSDOS: Prompt for game disk, then check for record file.
X * For Amiga: do nothing, but called from restore.c
X */
Xvoid
XgameDiskPrompt(){}
X#endif
X
X/*
X * Add a slash to any name not ending in / or :.  There must
X * be room for the /.
X */
Xvoid
Xappend_slash(name)
Xchar *name;
X{
X    char *ptr;
X
X    if (!*name)return;
X
X    ptr = eos(name) - 1;
X    if (*ptr != '/' && *ptr != ':') {
X	*++ptr = '/';
X	*++ptr = '\0';
X    }
X}
X
X
Xvoid
Xgetreturn(str)
Xconst char *str;
X{
X    int ch;
X
X    raw_printf("Hit <RETURN> %s.", str);
X    while ((ch = nhgetch()) != '\n' && ch != '\r' )
X	continue;
X}
X
X/* Follow the PATH, trying to fopen the file.
X */
X#define PATHSEP    ';'
X
XFILE *
Xfopenp(name, mode)
Xregister const char *name, *mode;
X{
X    register char *bp, *pp, lastch;
X    register FILE *fp;
X    register BPTR theLock;
X    char buf[BUFSIZ];
X
X    /* Try the default directory first.  Then look along PATH.
X     */
X    strcpy(buf, name);
X    if (theLock = Lock(buf, SHARED_LOCK)) {
X	UnLock(theLock);
X	if (fp = fopen(buf, mode))
X	    return fp;
X    }
X    pp = PATH;
X    while (pp && *pp) {
X	bp = buf;
X	while (*pp && *pp != PATHSEP){
X	    if( bp > buf + BUFSIZ - 1 ) return( NULL );
X	    lastch = *bp++ = *pp++;
X	}
X	if (lastch != ':' && lastch != '/' && bp != buf)
X	    *bp++ = '/';
X	strcpy(bp, name);
X	if (theLock = Lock(buf, SHARED_LOCK)) {
X	    UnLock(theLock);
X	    if (fp = fopen(buf, mode)) return fp;
X	}
X	if (*pp)
X	    pp++;
X    }
X    return NULL;
X}
X#endif /* MFLOPPY */
X
X#ifdef CHDIR
X
X/*
X *  A not general-purpose directory changing routine.
X *  Assumes you want to return to the original directory eventually,
X *  by chdir()ing to orgdir.
X *  Assumes -1 is not a valid lock, since 0 is valid.
X */
X
X#define NO_LOCK     ((BPTR) -1)
X
Xchar orgdir[1];
Xstatic BPTR OrgDirLock = NO_LOCK;
X
Xchdir(dir)
Xchar *dir;
X{
X    if (dir == orgdir) {
X	    /* We want to go back to where we came from. */
X	if (OrgDirLock != NO_LOCK) {
X	    UnLock(CurrentDir(OrgDirLock));
X	    OrgDirLock = NO_LOCK;
X	}
X    } else {
X	    /*
X	     * Go to some new place. If still at the original
X	     * directory, save the FileLock.
X	     */
X	BPTR newDir;
X
X	if (newDir = Lock(dir, SHARED_LOCK)) {
X	    if (OrgDirLock == NO_LOCK) {
X		OrgDirLock = CurrentDir(newDir);
X	    } else {
X		UnLock(CurrentDir(newDir));
X	    }
X	} else {
X	    return -1;  /* Failed */
X	}
X    }
X    /* CurrentDir always succeeds if you have a lock */
X    return 0;
X}
X
X#endif /* CHDIR */
X
X/* Chdir back to original directory
X */
X#undef exit
Xvoid
Xmsexit(code)
X{
X#ifdef CHDIR
X    extern char orgdir[];
X#endif
X
X#ifdef CHDIR
X    chdir(orgdir);      /* chdir, not chdirx */
X#endif
X
X    CleanUp();
X    exit(code);
X}
X
Xint
Xuptodate(fd)
X{
X    return(1);
X}
X
Xvoid
Xregularize(s)    /* normalize file name - we don't like :'s or /'s */
Xregister char *s;
X{
X    register char *lp;
X
X    while((lp = index(s, ':')) || (lp = index(s, '/')))
X	*lp = '_';
X}
END_OF_FILE
if test 9824 -ne `wc -c <'sys/amiga/amidos.c'`; then
    echo shar: \"'sys/amiga/amidos.c'\" unpacked with wrong size!
fi
# end of 'sys/amiga/amidos.c'
fi
if test -f 'sys/vms/vmsmain.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/vms/vmsmain.c'\"
else
echo shar: Extracting \"'sys/vms/vmsmain.c'\" \(9878 characters\)
sed "s/^X//" >'sys/vms/vmsmain.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)vmsmain.c	3.1	93/01/24	*/
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X/* main.c - VMS NetHack */
X
X#include "hack.h"
X
X#include <signal.h>
X
Xstatic void NDECL(whoami);
Xstatic void FDECL(process_options, (int, char **));
Xstatic void NDECL(byebye);
X#ifndef SAVE_ON_FATAL_ERROR
X# ifndef __DECC
Xextern void FDECL(VAXC$ESTABLISH, (int (*)(genericptr_t,genericptr_t)));
X# endif
Xstatic int FDECL(vms_handler, (genericptr_t,genericptr_t));
X#include <ssdef.h>	/* system service status codes */
X#endif
X
Xint
Xmain(argc,argv)
Xint argc;
Xchar *argv[];
X{
X	register int fd;
X#ifdef CHDIR
X	register char *dir;
X#endif
X
X#ifdef SECURE	/* this should be the very first code executed */
X	privoff();
X	fflush((FILE *)0);	/* force stdio to init itself */
X	privon();
X#endif
X
X	atexit(byebye);
X	hname = argv[0];
X	gethdate(hname);		/* find executable's creation date */
X	hname = basename(hname);	/* name used in 'usage' type messages */
X	hackpid = getpid();
X	(void) umask(0);
X
X	choose_windows(DEFAULT_WINDOW_SYS);
X
X#ifdef CHDIR			/* otherwise no chdir() */
X	/*
X	 * See if we must change directory to the playground.
X	 * (Perhaps hack is installed with privs and playground is
X	 *  inaccessible for the player.)
X	 * The logical name HACKDIR is overridden by a
X	 *  -d command line option (must be the first option given)
X	 */
X	dir = getenv("NETHACKDIR");
X	if (!dir) dir = getenv("HACKDIR");
X#endif
X	if(argc > 1) {
X#ifdef CHDIR
X	    if (!strncmp(argv[1], "-d", 2) && argv[1][2] != 'e') {
X		/* avoid matching "-dec" for DECgraphics; since the man page
X		 * says -d directory, hope nobody's using -desomething_else
X		 */
X		argc--;
X		argv++;
X		dir = argv[0]+2;
X		if(*dir == '=' || *dir == ':') dir++;
X		if(!*dir && argc > 1) {
X			argc--;
X			argv++;
X			dir = argv[0];
X		}
X		if(!*dir)
X		    error("Flag -d must be followed by a directory name.");
X	    } else
X#endif /* CHDIR */
X
X	/*
X	 * Now we know the directory containing 'record' and
X	 * may do a prscore().
X	 */
X	    if (!strncmp(argv[1], "-s", 2)) {
X#ifdef CHDIR
X		chdirx(dir, FALSE);
X#endif
X		prscore(argc, argv);
X		exit(0);
X	    }
X	}
X
X#ifdef CHDIR
X	/* move to the playground directory; 'termcap' might be found there */
X	chdirx(dir, TRUE);
X#endif
X
X	initoptions();
X	init_nhwindows();
X	whoami();
X
X	/*
X	 * It seems you really want to play.
X	 */
X	setrandom();
X	u.uhp = 1;	/* prevent RIP on early quits */
X#ifndef SAVE_ON_FATAL_ERROR
X	/* used to clear hangup stuff while still giving standard traceback */
X	VAXC$ESTABLISH(vms_handler);
X#endif
X	(void) signal(SIGHUP, (SIG_RET_TYPE) hangup);
X
X	process_options(argc, argv);	/* command line options */
X
X#ifdef WIZARD
X	if (wizard)
X		Strcpy(plname, "wizard");
X	else
X#endif
X	if(!*plname || !strncmp(plname, "games", 4))
X		askname();
X	plnamesuffix();		/* strip suffix from name; calls askname() */
X				/* again if suffix was whole name */
X				/* accepts any suffix */
X#ifdef WIZARD
X	if(!wizard) {
X#endif
X		/*
X		 * check for multiple games under the same name
X		 * (if !locknum) or check max nr of players (otherwise)
X		 */
X		(void) signal(SIGQUIT,SIG_IGN);
X		(void) signal(SIGINT,SIG_IGN);
X		if(!locknum)
X			Sprintf(lock, "_%u%s", (unsigned)getuid(), plname);
X		getlock();
X#ifdef WIZARD
X	} else {
X		Sprintf(lock, "_%u%s", (unsigned)getuid(), plname);
X		getlock();
X	}
X#endif /* WIZARD */
X
X	/*
X	 * Initialisation of the boundaries of the mazes
X	 * Both boundaries have to be even.
X	 */
X
X	x_maze_max = COLNO-1;
X	if (x_maze_max % 2)
X		x_maze_max--;
X	y_maze_max = ROWNO-1;
X	if (y_maze_max % 2)
X		y_maze_max--;
X
X	/*
X	 *  Initialize the vision system.  This must be before mklev() on a
X	 *  new game or before a level restore on a saved game.
X	 */
X	vision_init();
X
X	display_gamewindows();
X
X	set_savefile_name();
X	if((fd = open_savefile()) >= 0 &&
X	   /* if not up-to-date, quietly unlink file via false condition */
X	   (uptodate(fd) || delete_savefile())) {
X#ifdef WIZARD
X		/* Since wizard is actually flags.debug, restoring might
X		 * overwrite it.
X		 */
X		boolean remember_wiz_mode = wizard;
X#endif
X		(void) chmod(SAVEF,0);	/* disallow parallel restores */
X		(void) signal(SIGINT, (SIG_RET_TYPE) done1);
X#ifdef NEWS
X		if(flags.news) display_file(NEWS, FALSE);
X#endif
X		pline("Restoring save file...");
X		mark_synch();	/* flush output */
X		if(!dorecover(fd))
X			goto not_recovered;
X#ifdef WIZARD
X		if(!wizard && remember_wiz_mode) wizard = TRUE;
X#endif
X		pline("Hello %s, welcome back to NetHack!", plname);
X		check_special_room(FALSE);
X#ifdef EXPLORE_MODE
X		if (discover)
X			You("are in non-scoring discovery mode.");
X#endif
X#if defined(EXPLORE_MODE) || defined(WIZARD)
X		if (discover || wizard) {
X			if (yn("Do you want to keep the save file?") == 'n')
X			    (void) delete_savefile();
X			else
X			    (void) chmod(SAVEF,FCMASK); /* back to readable */
X		}
X#endif
X		flags.move = 0;
X	} else {
Xnot_recovered:
X		player_selection();
X		newgame();
X		/* give welcome message before pickup messages */
X		pline("Hello %s, welcome to NetHack!", plname);
X#ifdef EXPLORE_MODE
X		if (discover)
X			You("are in non-scoring discovery mode.");
X#endif
X		flags.move = 0;
X		set_wear();
X		pickup(1);
X	}
X
X	flags.moonphase = phase_of_the_moon();
X	if(flags.moonphase == FULL_MOON) {
X		You("are lucky!  Full moon tonight.");
X		change_luck(1);
X	} else if(flags.moonphase == NEW_MOON) {
X		pline("Be careful!  New moon tonight.");
X	}
X	if ((flags.friday13 = friday_13th()) != 0) {
X		pline("Watch out!  Bad things can happen on Friday the 13th.");
X		change_luck(-1);
X	}
X
X	initrack();
X
X	moveloop();
X	return(0);
X}
X
Xstatic void
Xprocess_options(argc, argv)
Xint argc;
Xchar *argv[];
X{
X	/*
X	 * Process options.
X	 */
X	while(argc > 1 && argv[1][0] == '-'){
X		argv++;
X		argc--;
X		switch(argv[0][1]){
X#if defined(WIZARD) || defined(EXPLORE_MODE)
X# ifndef EXPLORE_MODE
X		case 'X':
X		case 'x':
X# endif
X		case 'D':
X# ifdef WIZARD
X			if(!strcmpi(getenv("USER"), WIZARD_NAME)) {
X				wizard = TRUE;
X				break;
X			}
X			/* otherwise fall thru to discover */
X# endif
X# ifdef EXPLORE_MODE
X		case 'X':
X		case 'x':
X			discover = TRUE;
X# endif
X			break;
X#endif
X#ifdef NEWS
X		case 'n':
X			flags.news = FALSE;
X			break;
X#endif
X		case 'u':
X			if(argv[0][2])
X			  (void) strncpy(plname, argv[0]+2, sizeof(plname)-1);
X			else if(argc > 1) {
X			  argc--;
X			  argv++;
X			  (void) strncpy(plname, argv[0], sizeof(plname)-1);
X			} else
X				raw_print("Player name expected after -u");
X			break;
X		case 'I':
X		case 'i':
X			if (!strncmpi(argv[0]+1, "IBM", 3))
X				switch_graphics(IBM_GRAPHICS);
X			break;
X	    /*  case 'D': */
X		case 'd':
X			if (!strncmpi(argv[0]+1, "DEC", 3))
X				switch_graphics(DEC_GRAPHICS);
X			break;
X		default:
X			/* allow -T for Tourist, etc. */
X			(void) strncpy(pl_character, argv[0]+1,
X				sizeof(pl_character)-1);
X
X			/* raw_printf("Unknown option: %s", *argv); */
X		}
X	}
X
X	if(argc > 1)
X		locknum = atoi(argv[1]);
X#ifdef MAX_NR_OF_PLAYERS
X	if(!locknum || locknum > MAX_NR_OF_PLAYERS)
X		locknum = MAX_NR_OF_PLAYERS;
X#endif
X}
X
X#ifdef CHDIR
Xvoid
Xchdirx(dir, wr)
Xchar *dir;
Xboolean wr;
X{
X# ifndef HACKDIR
X	static char *defdir = ".";
X# else
X	static char *defdir = HACKDIR;
X
X	if(dir == NULL)
X		dir = defdir;
X	else if (wr && !same_dir(HACKDIR, dir))
X		/* If we're playing anywhere other than HACKDIR, turn off any
X		   privs we may have been installed with. */
X		privoff();
X# endif
X
X	if(dir && chdir(dir) < 0) {
X		perror(dir);
X		error("Cannot chdir to %s.", dir);
X	}
X
X	/* warn the player if we can't write the record file */
X	if (wr) check_recordfile(dir);
X
X	defdir = dir;
X}
X#endif /* CHDIR */
X
Xstatic void
Xwhoami()
X{
X	/*
X	 * Who am i? Algorithm: 1. Use name as specified in NETHACKOPTIONS
X	 *			2. Use lowercase of $USER  (if 1. fails)
X	 * The resulting name is overridden by command line options.
X	 * If everything fails, or if the resulting name is some generic
X	 * account like "games" then eventually we'll ask him.
X	 * Note that we trust the user here; it is possible to play under
X	 * somebody else's name.
X	 */
X	register char *s;
X
X	if (!*plname && (s = getenv("USER")))
X		(void) lcase(strncpy(plname, s, sizeof(plname)-1));
X}
X
Xstatic void
Xbyebye()
X{
X    /*	Different versions of both VAX C and GNU C use different return types
X	for signal functions.  Return type 'int' along with the explicit casts
X	below satisfy the most combinations of compiler vs <signal.h>.
X     */
X    int (*hup)();
X#ifdef SHELL
X    extern unsigned long dosh_pid, mail_pid;
X    extern unsigned long FDECL(SYS$DELPRC,(unsigned long *,const genericptr_t));
X
X    /* clean up any subprocess we've spawned that may still be hanging around */
X    if (dosh_pid) (void) SYS$DELPRC(&dosh_pid, 0), dosh_pid = 0;
X    if (mail_pid) (void) SYS$DELPRC(&mail_pid, 0), mail_pid = 0;
X#endif
X
X    /* SIGHUP doesn't seem to do anything on VMS, so we fudge it here... */
X    hup = (int(*)()) signal(SIGHUP, SIG_IGN);
X    if (hup != (int(*)()) SIG_DFL && hup != (int(*)()) SIG_IGN)
X	(void) (*hup)();
X
X#ifdef CHDIR
X    (void) chdir(getenv("PATH"));
X#endif
X}
X
X#ifndef SAVE_ON_FATAL_ERROR
X/* Condition handler to prevent byebye's hangup simulation
X   from saving the game after a fatal error has occurred.  */
Xstatic int			/* should be `unsigned long', but the -*/
Xvms_handler(sigargs, mechargs)	/*+ prototype in <signal.h> is screwed */
Xgenericptr_t sigargs, mechargs;	/* [0] is argc, [1..argc] are the real args */
X{
X    extern boolean hu;		/* src/save.c */
X    unsigned long condition = ((unsigned long *)sigargs)[1];
X
X    if (condition == SS$_ACCVIO		/* access violation */
X     || (condition >= SS$_ASTFLT && condition <= SS$_TBIT)
X     || (condition >= SS$_ARTRES && condition <= SS$_INHCHME)) {
X	hu = TRUE;	/* pretend that hangup has already been attempted */
X# if defined(WIZARD) && !defined(BETA)
X	if (wizard)
X# endif /*WIZARD && !BETA*/
X# if defined(WIZARD) ||  defined(BETA)
X	    abort();	/* enter the debugger */
X# endif /*WIZARD || BETA*/
X    }
X    return SS$_RESIGNAL;
X}
X#endif
X
X/*vmsmain.c*/
END_OF_FILE
if test 9878 -ne `wc -c <'sys/vms/vmsmain.c'`; then
    echo shar: \"'sys/vms/vmsmain.c'\" unpacked with wrong size!
fi
# end of 'sys/vms/vmsmain.c'
fi
if test -f 'win/X11/winmenu.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'win/X11/winmenu.c'\"
else
echo shar: Extracting \"'win/X11/winmenu.c'\" \(9918 characters\)
sed "s/^X//" >'win/X11/winmenu.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)winmenu.c	3.1	92/3/7
X/* Copyright (c) Dean Luick, 1992				  */
X/* NetHack may be freely redistributed.  See license for details. */
X
X/*
X * File for creating menus.
X * 
X * 	+ Global functions: start_menu, add_menu, end_menu, select_menu
X */
X#include <X11/Intrinsic.h>
X#include <X11/StringDefs.h>
X#include <X11/Shell.h>
X#include <X11/Xaw/List.h>
X#include <X11/Xaw/Viewport.h>
X#include <X11/Xaw/Cardinals.h>
X
X#include "hack.h"
X#include "winX.h"
X
X
Xstatic void clear_old_menu();
Xstatic char *copy_of();
X
X#define check_menu(func_name)					\
X{								\
X    if (!menu_info->is_menu) {					\
X	impossible("%s:  called before start_menu", func_name);	\
X	return;							\
X    }								\
X}
X
Xstatic char menu_selected;	/* selected menu item */
Xstatic const char menu_translations[] =
X    "#override\n\
X     <Key>: menu_key()";
X
X/*
X * Menu callback.
X */
X/* ARGSUSED */
Xstatic void
Xmenu_select(w, client_data, call_data)
X    Widget w;
X    XtPointer client_data, call_data;
X{
X    XawListReturnStruct *lrs = (XawListReturnStruct *) call_data;
X    int i;
X    struct menu_info_t *menu_info;
X    struct menu_item *curr;
X    struct xwindow *wp;
X
X    wp = find_widget(w);
X    menu_info  = wp->menu_information;
X
X    for (i = 0, curr = menu_info->base; i < lrs->list_index; i++) {
X	if (!curr) panic("menu_select: out of menu items!");
X	curr = curr->next;
X    }
X
X    /* If we don't have a selector, try again. */
X    if (!curr->selector) {
X	XawListUnhighlight(w);	/* unhilight non-menu item */
X	X11_nhbell();
X	return;
X    }
X    menu_selected = curr->selector;
X
X    nh_XtPopdown(wp->popup);	/* this removes the event grab */
X    exit_x_event = TRUE;	/* exit our event handler */
X}
X
X/*
X * Called when we get a key press event on a menu window.
X */
X/* ARGSUSED */
Xvoid
Xmenu_key(w, event, params, num_params)
X    Widget w;
X    XEvent *event;
X    String *params;
X    Cardinal *num_params;
X{
X    struct menu_info_t *menu_info;
X    struct menu_item *curr;
X    struct xwindow *wp;
X    char ch;
X    int count;
X
X    wp = find_widget(w);
X    menu_info  = wp->menu_information;
X
X    ch = key_event_to_char((XKeyEvent *) event);
X
X    if (ch == '\0') {	/* don't accept nul char/modifier event */
X	/* don't beep */
X	return;
X    }
X
X    for (count = 0, curr = menu_info->base; curr; curr = curr->next, count++)
X	if (curr->selector == ch) break;
X
X    if (curr) {
X	XawListHighlight(w, count);	/* highlit item */
X	menu_selected = ch;
X    } else if (menu_info->other_valid && index(menu_info->other_valid, ch)) {
X	menu_selected = menu_info->other_response;
X    } else {
X	X11_nhbell();		/* no match */
X	return;
X    }
X
X    nh_XtPopdown(wp->popup);	/* this removes the event grab */
X    exit_x_event = TRUE;	/* exit our event handler */
X}
X
X
X/* Global functions ======================================================== */
X
Xvoid
XX11_start_menu(window)
X    winid window;
X{
X    struct xwindow *wp;
X    check_winid(window);
X
X    wp = &window_list[window];
X
X    if (wp->menu_information->is_menu) {
X	/* clear old menu and widgets (if any) */
X	clear_old_menu(wp);
X    } else {
X	wp->menu_information->is_menu = TRUE;
X    }
X}
X
Xvoid
XX11_add_menu(window, ch, attr, str)
X    winid window;
X    char ch;
X    int attr;
X    const char *str;
X{
X    struct menu_item *item;
X    struct menu_info_t *menu_info;
X
X    check_winid(window);
X    menu_info = window_list[window].menu_information;
X    check_menu("add_menu");
X
X    item = (struct menu_item *) alloc((unsigned)sizeof(struct menu_item));
X    item->next = (struct menu_item *) 0;
X    item->selector = ch;
X    item->attr = attr;
X    item->str = copy_of(str);
X
X    if (menu_info->last) {
X	menu_info->last->next = item;
X    } else {
X	menu_info->base = item;
X    }
X    menu_info->last = item;
X    menu_info->count++;
X}
X
Xvoid
XX11_end_menu(window, cancel_ch, cancel_str, morestr)
X    winid window;
X    char cancel_ch;
X    const char *cancel_str;
X    const char *morestr;
X{
X    struct menu_info_t *menu_info;
X    check_winid(window);
X    menu_info = window_list[window].menu_information;
X    check_menu("end_menu");
X
X    if(morestr && strlen(morestr))
X	X11_add_menu(window, 0, 0, morestr);
X    menu_info->other_valid = cancel_str;
X    menu_info->other_response = cancel_ch;
X    menu_info->query = morestr;
X}
X
Xchar
XX11_select_menu(window)
X    winid window;
X{
X    struct menu_item *curr;
X    struct xwindow *wp;
X    struct menu_info_t *menu_info;
X    Arg args[8];
X    Cardinal num_args;
X    String *ptr;
X    int i;
X    Widget viewport_widget;
X    Dimension pixel_height, top_margin, spacing;
X    XFontStruct *fs;
X
X    check_winid(window);
X    wp = &window_list[window];
X    menu_info = wp->menu_information;
X
X#if defined(LINT) || defined(GCC_WARN)
X    {
X	/* cannot use check_menu, since it doesn't return anything */
X	if (!menu_info->is_menu) {
X	    impossible("%s:  called before start_menu", "select_menu");
X	    return '\0';
X	}
X    }
X#else
X    check_menu("select_menu");
X#endif
X
X#ifdef VERBOSE
X    /* ********** */
X    if (menu_info->other_valid) {
X	char *cp;
X	printf("select_menu: other_valid = \"");
X	for (cp = menu_info->other_valid; *cp; cp++) {
X	    if (*cp < 32) {
X		printf("^%c", '@' + *cp);
X	    } else
X		printf("%c", *cp);
X	}
X	printf("\"\n");
X    } else {
X	printf("select_menu: other_valid = NULL\n");
X    }
X    if (menu_info->other_response < 32) {
X	printf("select_menu: other_response = '^%c'\n",
X				    '@' + menu_info->other_response);
X    } else {
X	printf("select_menu: other_response = '%c'\n",
X						menu_info->other_response);
X    }
X    if (menu_info->query) {
X	printf("select_menu: query = \"%s\"\n", menu_info->query);
X    } else {
X	printf("select_menu: query = NULL\n");
X    }
X    /* ********** */
X#endif
X
X    num_args = 0;
X    XtSetArg(args[num_args], XtNallowShellResize, True); num_args++;
X
X    wp->popup = XtCreatePopupShell("menu", transientShellWidgetClass,
X				   toplevel, args, num_args);
X
X    menu_info->list_pointer =
X	(String *) alloc((unsigned) (sizeof(String) * (menu_info->count+1)));
X    for (i = 0, ptr = menu_info->list_pointer, curr = menu_info->base;
X			i < menu_info->count; i++, ptr++, curr = curr->next) {
X	*ptr = (String) curr->str;
X    }
X    *ptr = (String) 0;
X
X    num_args = 0;
X    XtSetArg(args[num_args], XtNallowVert,      True);	       num_args++;
X
X    viewport_widget = XtCreateManagedWidget(
X		"menu_viewport",	/* name */
X		viewportWidgetClass,
X		wp->popup,		/* parent widget */
X		args, num_args);	/* values, and number of values */
X
X    num_args = 0;
X    XtSetArg(args[num_args], XtNforceColumns, True);		num_args++;
X    XtSetArg(args[num_args], XtNdefaultColumns, 1);		num_args++;
X    XtSetArg(args[num_args], XtNlist, menu_info->list_pointer);	num_args++;
X    XtSetArg(args[num_args], XtNtranslations,
X		XtParseTranslationTable(menu_translations));	num_args++;
X
X    wp->w = XtCreateManagedWidget(
X		"menu_list",		/* name */
X		listWidgetClass,
X		viewport_widget,	/* parent widget */
X		args,			/* set some values */
X		num_args);		/* number of values to set */
X
X    XtAddCallback(wp->w, XtNcallback, menu_select, (XtPointer) 0);
X
X    menu_info->valid_widgets = TRUE;
X
X    /* Get the font and margin information. */
X    num_args = 0;
X    XtSetArg(args[num_args], XtNfont,	      &fs);	 	num_args++;
X    XtSetArg(args[num_args], XtNinternalHeight, &top_margin);	num_args++;
X    XtSetArg(args[num_args], XtNrowSpacing,     &spacing);	num_args++;
X    XtGetValues(wp->w, args, num_args);
X
X    /* font height is ascent + descent */
X    pixel_height = top_margin +
X	((menu_info->count + 4) *
X	 (fs->max_bounds.ascent + fs->max_bounds.descent + spacing));
X
X    /* if viewport will be bigger than the screen, limit its height */
X    if ((Dimension) XtScreen(wp->w)->height <= pixel_height) {
X	pixel_height = XtScreen(wp->w)->height / 2;
X
X	num_args = 0;
X	XtSetArg(args[num_args], XtNheight, pixel_height); num_args++;
X	XtSetValues(viewport_widget, args, num_args);
X    }
X
X    XtRealizeWidget(wp->popup);	/* need to realize before we position */
X    positionpopup(wp->popup);
X
X    menu_selected = '\0';
X
X    nh_XtPopup(wp->popup, XtGrabExclusive, wp->w);
X    (void) x_event(EXIT_ON_EXIT);
X
X    return menu_selected;
X}
X
X/* End global functions ==================================================== */
X
Xstatic char *
Xcopy_of(s)
X    char *s;
X{
X    char *copy;
X    if (s) {
X	copy = (char *) alloc((unsigned) (strlen(s)+1));
X	Strcpy(copy,s);
X    } else {
X	copy = (char *) alloc((unsigned) 1);
X	*copy = '\0';
X    }
X
X    return copy;
X}
X
Xstatic void
Xclear_old_menu(wp)
X    struct xwindow *wp;
X{
X    struct menu_info_t *menu_info = wp->menu_information;
X
X    while (menu_info->base) {
X	menu_info->last = menu_info->base;
X	menu_info->base = menu_info->base->next;
X
X	free(menu_info->last->str);
X	free((char *)menu_info->last);
X    }
X    menu_info->last = (struct menu_item *) 0;
X    menu_info->other_valid = (char *) 0;
X    menu_info->other_response = '\0';
X    menu_info->query = (char *) 0;
X    menu_info->count = 0;
X
X    if (menu_info->valid_widgets) {
X	nh_XtPopdown(wp->popup);
X	XtDestroyWidget(wp->popup);
X	menu_info->valid_widgets = FALSE;
X	free((char *) menu_info->list_pointer);
X    }
X}
X
Xvoid
Xcreate_menu_window(wp)
X    struct xwindow *wp;
X{
X    struct menu_info_t *menu_info;
X
X    wp->type = NHW_MENU;
X
X    wp->menu_information = menu_info = 
X		    (struct menu_info_t *) alloc(sizeof(struct menu_info_t));
X
X    menu_info->base	      = (struct menu_item *) 0;
X    menu_info->last	      = (struct menu_item *) 0;
X    menu_info->query	      = (char *) 0;
X    menu_info->other_valid    = (char *) 0;
X    menu_info->other_response = '\0';
X    menu_info->count	      = 0;
X    menu_info->list_pointer   = (String *) 0;
X    menu_info->valid_widgets  = FALSE;
X    wp->w = wp->popup = (Widget) 0;
X    menu_info->is_menu	      = FALSE;
X}
X
Xvoid
Xdestroy_menu_window(wp)
X    struct xwindow *wp;
X{
X    /* printf("destroy_menu_window\n"); */
X
X    clear_old_menu(wp);		/* this will also destroy the widgets */
X    free((char *) wp->menu_information);
X
X    wp->type = NHW_NONE;	/* allow re-use */
X}
X
X
END_OF_FILE
if test 9918 -ne `wc -c <'win/X11/winmenu.c'`; then
    echo shar: \"'win/X11/winmenu.c'\" unpacked with wrong size!
fi
# end of 'win/X11/winmenu.c'
fi
echo shar: End of archive 92 \(of 108\).
cp /dev/null ark92isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \
21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \
41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 \
61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 \
81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 \
101 102 103 104 105 106 107 108 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 108 archives.
    echo "Now execute 'rebuild.sh'"
    rm -f ark10[0-8]isdone ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
