Path: uunet!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v16i054:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Part46/108
Message-ID: <4348@master.CNA.TEK.COM>
Date: 30 Jan 93 01:14:07 GMT
Sender: news@master.CNA.TEK.COM
Lines: 2284
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1603

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 16, Issue 54
Archive-name: nethack31/Part46
Supersedes: nethack3p9: Volume 10, Issue 46-102
Environment: Amiga, Atari, Mac, MS-DOS, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 46 (of 108)."
# Contents:  src/priest.c win/tty/wintty.c
# Wrapped by billr@saab on Wed Jan 27 16:09:04 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'src/priest.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/priest.c'\"
else
echo shar: Extracting \"'src/priest.c'\" \(16798 characters\)
sed "s/^X//" >'src/priest.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)priest.c	3.1	92/01/05
X/* Copyright (c) Izchak Miller, Steve Linhart, 1989. 		  */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include "hack.h"
X#include "mfndpos.h"
X#include "eshk.h"
X#include "epri.h"
X#include "emin.h"
X
X#ifdef OVLB
X
Xstatic boolean FDECL(histemple_at,(struct monst *,XCHAR_P,XCHAR_P));
Xstatic boolean FDECL(has_shrine,(struct monst *));
X
X/*
X * Move for priests and shopkeepers.  Called from shk_move() and pri_move().
X * Valid returns are  1: moved  0: didn't  -1: let m_move do it  -2: died.
X */
Xint
Xmove_special(mtmp,in_his_shop,appr,uondoor,avoid,omx,omy,gx,gy)
Xregister struct monst *mtmp;
Xboolean in_his_shop;
Xschar appr;
Xboolean uondoor,avoid;
Xregister xchar omx,omy,gx,gy;
X{
X	register xchar nx,ny,nix,niy;
X	register schar i;
X	schar chcnt,cnt;
X	coord poss[9];
X	long info[9];
X	long allowflags;
X	struct obj *ib = (struct obj *)0;
X
X	if(omx == gx && omy == gy)
X		return(0);
X	if(mtmp->mconf) {
X		avoid = FALSE;
X		appr = 0;
X	}
X
X	nix = omx;
X	niy = omy;
X	if (mtmp->isshk) allowflags = ALLOW_SSM;
X	else allowflags = ALLOW_SSM | ALLOW_SANCT;
X	if (passes_walls(mtmp->data)) allowflags |= (ALLOW_ROCK|ALLOW_WALL);
X	if (throws_rocks(mtmp->data)) allowflags |= ALLOW_ROCK;
X	if (tunnels(mtmp->data) &&
X		    (!needspick(mtmp->data) || m_carrying(mtmp, PICK_AXE)))
X		allowflags |= ALLOW_DIG;
X	if (!nohands(mtmp->data) && !verysmall(mtmp->data)) {
X		allowflags |= OPENDOOR;
X		if (m_carrying(mtmp, SKELETON_KEY)) allowflags |= BUSTDOOR;
X	}
X	if (is_giant(mtmp->data)) allowflags |= BUSTDOOR;
X	cnt = mfndpos(mtmp, poss, info, allowflags);
X
X	if(mtmp->isshk && avoid && uondoor) { /* perhaps we cannot avoid him */
X		for(i=0; i<cnt; i++)
X		    if(!(info[i] & NOTONL)) goto pick_move;
X		avoid = FALSE;
X	}
X
X#define	GDIST(x,y)	(dist2(x,y,gx,gy))
Xpick_move:
X	chcnt = 0;
X	for(i=0; i<cnt; i++) {
X		nx = poss[i].x;
X		ny = poss[i].y;
X		if(levl[nx][ny].typ == ROOM ||
X			(mtmp->ispriest &&
X			    levl[nx][ny].typ == ALTAR) ||
X			(mtmp->isshk &&
X			    (!in_his_shop || ESHK(mtmp)->following))) {
X		    if(avoid && (info[i] & NOTONL))
X			continue;
X		    if((!appr && !rn2(++chcnt)) ||
X			(appr && GDIST(nx,ny) < GDIST(nix,niy))) {
X			    nix = nx;
X			    niy = ny;
X		    }
X		}
X	}
X	if(mtmp->ispriest && avoid &&
X			nix == omx && niy == omy && onlineu(omx,omy)) {
X		/* might as well move closer as long it's going to stay
X		 * lined up */
X		avoid = FALSE;
X		goto pick_move;
X	}
X
X	if(nix != omx || niy != omy) {
X		remove_monster(omx, omy);
X		place_monster(mtmp, nix, niy);
X		newsym(nix,niy);
X		if (mtmp->isshk && !in_his_shop && inhishop(mtmp))
X		    check_special_room(FALSE);
X		if(ib) {
X			if (cansee(mtmp->mx,mtmp->my))
X			    pline("%s picks up %s.", Monnam(mtmp),
X				distant_name(ib,doname));
X			freeobj(ib);
X			mpickobj(mtmp, ib);
X		}
X		return(1);
X	}
X	return(0);
X}
X
X#endif /* OVLB */
X
X#ifdef OVL0
X
Xchar
Xtemple_occupied(array)
Xregister char *array;
X{
X	register char *ptr;
X
X	for (ptr = array; *ptr; ptr++)
X		if (rooms[*ptr - ROOMOFFSET].rtype == TEMPLE)
X			return(*ptr);
X	return('\0');
X}
X
X#endif /* OVL0 */
X#ifdef OVLB
X
Xstatic boolean
Xhistemple_at(priest, x, y)
Xregister struct monst *priest;
Xregister xchar x, y;
X{
X	return((EPRI(priest)->shroom == *in_rooms(x, y, TEMPLE)) &&
X	       on_level(&(EPRI(priest)->shrlevel), &u.uz));
X}
X
X/*
X * pri_move: return 1: moved  0: didn't  -1: let m_move do it  -2: died
X */
Xint
Xpri_move(priest)
Xregister struct monst *priest;
X{
X	register xchar gx,gy,omx,omy;
X	schar temple;
X	boolean avoid = TRUE;
X
X	omx = priest->mx;
X	omy = priest->my;
X
X	if(!histemple_at(priest, omx, omy)) return(-1);
X
X	temple = EPRI(priest)->shroom;
X
X	gx = EPRI(priest)->shrpos.x;
X	gy = EPRI(priest)->shrpos.y;
X
X	gx += rn1(3,-1);	/* mill around the altar */
X	gy += rn1(3,-1);
X
X	if(!priest->mpeaceful ||
X	   (Conflict && !resist(priest, RING_CLASS, 0, 0))) {
X		if(monnear(priest, u.ux, u.uy)) {
X			if(Displaced)
X				Your("displaced image doesn't fool %s!",
X					mon_nam(priest));
X			(void) mattacku(priest);
X			return(0);
X		} else if(index(u.urooms, temple)) {
X			/* chase player if inside temple & can see him */
X			if(priest->mcansee && m_canseeu(priest)) {
X				gx = u.ux;
X				gy = u.uy;
X			}
X			avoid = FALSE;
X		}
X	} else if(Invis) avoid = FALSE;
X
X	return(move_special(priest,FALSE,TRUE,FALSE,avoid,omx,omy,gx,gy));
X}
X
X/* exclusively for mktemple() */
Xvoid
Xpriestini(lvl, sroom, sx, sy, sanctum)
Xd_level	*lvl;
Xstruct mkroom *sroom;
Xint sx, sy;
Xboolean sanctum;   /* is it the seat of the high priest? */
X{
X	register struct monst *priest;
X	register struct obj *otmp;
X	register int cnt;
X
X	if(MON_AT(sx+1, sy))
X		rloc(m_at(sx+1, sy)); /* insurance */
X
X	if(priest = (sanctum ? makemon(&mons[PM_HIGH_PRIEST], sx+1, sy)
X			     : makemon(&mons[PM_ALIGNED_PRIEST], sx+1, sy))) {
X		EPRI(priest)->shroom = (sroom - rooms) + ROOMOFFSET;
X		EPRI(priest)->shralign = Amask2align(levl[sx][sy].altarmask);
X		EPRI(priest)->shrpos.x = sx;
X		EPRI(priest)->shrpos.y = sy;
X		assign_level(&(EPRI(priest)->shrlevel), lvl);
X		priest->mtrapseen = ~0;	/* traps are known */
X		priest->mpeaceful = 1;
X		priest->ispriest = 1;
X		priest->msleep = 0;
X		set_malign(priest); /* mpeaceful may have changed */
X
X		/* now his/her goodies... */
X		(void) mongets(priest, CHAIN_MAIL);
X		(void) mongets(priest, SMALL_SHIELD);
X#ifdef MUSE
X		m_dowear(priest, TRUE);
X#endif
X		priest->mgold = (long)rn1(10,20);
X		if(sanctum && EPRI(priest)->shralign == A_NONE &&
X		     on_level(&sanctum_level, &u.uz))
X			(void) mongets(priest, AMULET_OF_YENDOR);
X		/* Do NOT put the rest in m_initinv.    */
X		/* Priests created elsewhere than in a  */
X		/* temple should not carry these items, */
X		/* except for the mace.			*/
X		cnt = rn1(2,3);
X		while(cnt) {
X		    otmp = mkobj(SPBOOK_CLASS, FALSE);
X		    if(otmp) mpickobj(priest, otmp);
X		    cnt--;
X		}
X		if(p_coaligned(priest))
X		    (void) mongets(priest, rn2(2) ? CLOAK_OF_PROTECTION
X						  : CLOAK_OF_MAGIC_RESISTANCE);
X		else {
X		    if(!rn2(5))
X			otmp = mksobj(CLOAK_OF_MAGIC_RESISTANCE, TRUE, FALSE);
X		    else otmp = mksobj(CLOAK_OF_PROTECTION, TRUE, FALSE);
X		    if(otmp) {
X			if(!rn2(2)) curse(otmp);
X			mpickobj(priest, otmp);
X		    }
X		}
X
X		otmp = mksobj(MACE, FALSE, FALSE);
X		if(otmp) {
X		    otmp->spe = rnd(3);
X		    if(!rn2(2)) curse(otmp);
X		    mpickobj(priest, otmp);
X		}
X	}
X}
X
X/*
X * Specially aligned monsters are named specially.
X *	- aligned priests with ispriest and high priests have shrines
X *		they retain ispriest and epri when polymorphed
X *	- aligned priests without ispriest and Angels are roamers
X *		they retain isminion and access epri as emin when polymorphed
X *		(coaligned Angels are also created as minions, but they
X *		use the same naming convention)
X *	- minions do not have ispriest but have isminion and emin
X */
Xchar *
Xpriestname(mon)
Xregister struct monst *mon;
X{
X	static char NEARDATA pname[PL_NSIZ];
X
X	Strcpy(pname, "the ");
X	if (mon->minvis) Strcat(pname, "invisible ");
X	if (mon->ispriest || mon->data == &mons[PM_ALIGNED_PRIEST] ||
X					mon->data == &mons[PM_ANGEL]) {
X		/* use epri */
X		if (mon->mtame && mon->data == &mons[PM_ANGEL])
X			Strcat(pname, "guardian ");
X		if (mon->data != &mons[PM_ALIGNED_PRIEST] &&
X				mon->data != &mons[PM_HIGH_PRIEST]) {
X			Strcat(pname, mon->data->mname);
X			Strcat(pname, " ");
X		}
X		if (mon->data != &mons[PM_ANGEL]) {
X			if (!mon->ispriest && EPRI(mon)->renegade)
X				Strcat(pname, "renegade ");
X			if (mon->data == &mons[PM_HIGH_PRIEST])
X				Strcat(pname, "high ");
X			if (mon->female)
X				Strcat(pname, "priestess ");
X			else
X				Strcat(pname, "priest ");
X		}
X		Strcat(pname, "of ");
X		Strcat(pname, align_gname((int)EPRI(mon)->shralign));
X		return(pname);
X	}
X	/* use emin instead of epri */
X	Strcat(pname, mon->data->mname);
X	Strcat(pname, " of ");
X	Strcat(pname, align_gname(EMIN(mon)->min_align));
X	return(pname);
X}
X
Xboolean
Xp_coaligned(priest)
Xstruct monst *priest;
X{
X	return(u.ualign.type == ((int)EPRI(priest)->shralign));
X}
X
Xstatic boolean
Xhas_shrine(pri)
Xstruct monst *pri;
X{
X	struct rm *lev;
X
X	if(!pri)
X		return(FALSE);
X	lev = &levl[EPRI(pri)->shrpos.x][EPRI(pri)->shrpos.y];
X	if (!IS_ALTAR(lev->typ) || !(lev->altarmask & AM_SHRINE))
X		return(FALSE);
X	return(EPRI(pri)->shralign == Amask2align(lev->altarmask & ~AM_SHRINE));
X}
X
Xstruct monst *
Xfindpriest(roomno)
Xchar roomno;
X{
X	register struct monst *mtmp;
X	extern struct monst *fdmon; /* from mon.c */
X
X	for(mtmp = fmon; mtmp; mtmp = mtmp->nmon)
X	    if(mtmp->ispriest && (EPRI(mtmp)->shroom == roomno) &&
X	       histemple_at(mtmp,mtmp->mx,mtmp->my))
X		return(mtmp);
X	for(mtmp = fdmon; mtmp; mtmp = mtmp->nmon)
X	    if(mtmp->ispriest && (EPRI(mtmp)->shroom == roomno) &&
X	       histemple_at(mtmp,mtmp->mx,mtmp->my))
X		return(mtmp);
X	return (struct monst *)0;
X}
X
X/* called from check_special_room() when the player enters the temple room */
Xvoid
Xintemple(roomno)
Xregister int roomno;
X{
X	register struct monst *priest = findpriest((char)roomno);
X	boolean tended = (priest != (struct monst *)0);
X	boolean shrined = (tended && has_shrine(priest));
X	boolean sanctum = (tended && priest->data == &mons[PM_HIGH_PRIEST] &&
X			    (Is_sanctum(&u.uz) || In_endgame(&u.uz)));
X
X	if(!temple_occupied(u.urooms0)) {
X	    if(tended) {
X		pline("%s intones:",
X		      (!Blind ? Monnam(priest) : "A nearby voice"));
X		if(sanctum && Is_sanctum(&u.uz)) {
X		    if(priest->mpeaceful) {
X			  verbalize("Infidel, you entered Moloch's Sanctum!");
X			  verbalize("Be gone!");
X			  priest->mpeaceful = 0;
X			  set_malign(priest);
X		    } else
X		      verbalize("You desecrate this place by your presence!");
X		} else verbalize("Pilgrim, you enter a%s place!",
X			   !shrined ? " desecrated" :
X			   " sacred");
X		if(!sanctum) {
X		    /* !tended -> !shrined */
X		    if(!shrined || !p_coaligned(priest) ||
X						   u.ualign.record < -5)
X			You("have a%s forbidding feeling...",
X				(!shrined) ? "" : " strange");
X		    else You("experience a strange sense of peace.");
X		}
X	    } else {
X		switch(rn2(3)) {
X		  case 0: You("have an eerie feeling..."); break;
X		  case 1: You("feel like you are being watched."); break;
X		  default: pline("A shiver runs down your spine."); break;
X		}
X		if(!rn2(5)) {
X		    struct monst *mtmp;
X
X		    if(!(mtmp = makemon(&mons[PM_GHOST],u.ux,u.uy))) return;
X		    pline("An enormous ghost appears next to you!");
X		    mtmp->mpeaceful = 0;
X		    set_malign(mtmp);
X		    if(flags.verbose)
X			You("are frightened to death, and unable to move.");
X		    nomul(-3);
X		    nomovemsg = "You regain your composure.";
X	       }
X	   }
X       }
X}
X
Xvoid
Xpriest_talk(priest)
Xregister struct monst *priest;
X{
X	boolean coaligned = p_coaligned(priest);
X	boolean strayed = (u.ualign.record < 0);
X
X	if(priest->mflee || (!priest->ispriest && coaligned && strayed)) {
X	    pline("%s doesn't want anything to do with you!",
X				Monnam(priest));
X	    priest->mpeaceful = 0;
X	    return;
X	}
X
X	/* priests don't chat unless peaceful and in their own temple */
X	if(!histemple_at(priest,priest->mx,priest->my) ||
X		 !priest->mpeaceful || !priest->mcanmove || priest->msleep) {
X	    if(!priest->mcanmove || priest->msleep) {
X		pline("%s breaks out of %s reverie!",
X			humanoid(priest->data)
X				? (priest->female ? "her" : "his")
X				: "its",
X			Monnam(priest));
X		priest->mfrozen = priest->msleep = 0;
X		priest->mcanmove = 1;
X	    }
X	    priest->mpeaceful = 0;
X	    switch(rn2(3)) {
X		case 0:
X		   verbalize("Thou wouldst have words, eh?  I'll give thee a word or two!");
X		   break;
X		case 1:
X		   verbalize("Talk?  Here is what I have to say!");
X		   break;
X		default:
X		   verbalize("Pilgrim, I have lost mine desire to talk.");
X		   break;
X	    }
X	    return;
X	}
X
X	/* you desecrated the temple and now you want to chat? */
X	if(priest->mpeaceful && *in_rooms(priest->mx, priest->my, TEMPLE) &&
X		  !has_shrine(priest)) {
X	    verbalize("Begone!  Thou desecratest this holy place with thy presence.");
X	    priest->mpeaceful = 0;
X	    return;
X	}
X
X	if(!u.ugold) {
X	    if(coaligned && !strayed) {
X		if (priest->mgold > 0L) {
X		    /* Note: two bits is actually 25 cents.  Hmm. */
X		    pline("%s gives you %s for an ale.", Monnam(priest),
X			(priest->mgold == 1L) ? "one bit" : "two bits");
X		    if (priest->mgold > 1L)
X			u.ugold = 2L;
X		    else
X			u.ugold = 1L;
X		    priest->mgold -= u.ugold;
X		    flags.botl = 1;
X		} else
X		    pline("%s preaches the virtues of poverty.", Monnam(priest));
X		exercise(A_WIS, TRUE);
X	    } else
X		pline("%s is not interested.", Monnam(priest));
X	    return;
X	} else {
X	    long offer;
X
X	    pline("%s asks you for a contribution for the temple.",
X			Monnam(priest));
X	    if((offer = bribe(priest)) == 0) {
X		verbalize("Thou shalt regret thine action!");
X		if(coaligned) u.ualign.record--;
X	    } else if(offer < (u.ulevel * 200)) {
X		if(u.ugold > (offer * 2L)) verbalize("Cheapskate.");
X		else {
X		    verbalize("I thank thee for thy contribution.");
X		    /*  give player some token  */
X		    exercise(A_WIS, TRUE);
X		}
X	    } else if(offer < (u.ulevel * 400)) {
X		verbalize("Thou art indeed a pious individual.");
X		if(u.ugold < (offer * 2L)) {
X		    if(coaligned && u.ualign.record < -5) u.ualign.record++;
X		    verbalize("I bestow upon thee a blessing.");
X		    Clairvoyant += rn1(500,500);
X		}
X	    } else if(offer < (u.ulevel * 600)) {
X		verbalize("Thy devotion has been rewarded.");
X		if (!(Protection & INTRINSIC))  {
X			Protection |= FROMOUTSIDE;
X			if (!u.ublessed)  u.ublessed = rn1(3, 2);
X		} else u.ublessed++;
X	    } else {
X		verbalize("Thy selfless generosity is deeply appreciated.");
X		if(u.ugold < (offer * 2L) && coaligned) {
X		    if(strayed && (moves - u.ucleansed) > 5000L) {
X			u.ualign.record = 0; /* cleanse him */
X			u.ucleansed = moves;
X		    } else {
X			u.ualign.record += 2;
X		    }
X		}
X	    }
X	}
X}
X
Xstruct monst *
Xmk_roamer(ptr, alignment, x, y, peaceful)
Xregister struct permonst *ptr;
Xaligntyp alignment;
Xxchar x, y;
Xboolean peaceful;
X{
X	register struct monst *roamer;
X	register boolean coaligned = (u.ualign.type == alignment);
X
X	if (ptr != &mons[PM_ALIGNED_PRIEST] && ptr != &mons[PM_ANGEL])
X		return((struct monst *)0);
X	
X	if (MON_AT(x, y)) rloc(m_at(x, y));	/* insurance */
X
X	if (!(roamer = makemon(ptr, x, y)))
X		return((struct monst *)0);
X
X	EPRI(roamer)->shralign = alignment;
X	if (coaligned && !peaceful)
X		EPRI(roamer)->renegade = TRUE;
X	/* roamer->ispriest == FALSE naturally */
X	roamer->isminion = TRUE;	/* borrowing this bit */
X	roamer->mtrapseen = ~0;		/* traps are known */
X	roamer->mpeaceful = peaceful;
X	roamer->msleep = 0;
X	set_malign(roamer); /* peaceful may have changed */
X
X	/* MORE TO COME */
X	return(roamer);
X}
X
Xvoid
Xreset_hostility(roamer)
Xregister struct monst *roamer;
X{
X        if(!(roamer->isminion && (roamer->data == &mons[PM_ALIGNED_PRIEST] ||
X				  roamer->data == &mons[PM_ANGEL])))
X	        return;
X
X        if(EPRI(roamer)->shralign != u.ualign.type) {
X	    roamer->mpeaceful = roamer->mtame = 0;
X	    set_malign(roamer);
X	}
X	newsym(roamer->mx, roamer->my);
X}
X
Xboolean
Xin_your_sanctuary(x, y)
Xxchar x, y;
X{
X	register char roomno;
X	register struct monst *priest;
X
X	if ((u.ualign.record < -5) || !(roomno = temple_occupied(u.urooms)) ||
X	    (roomno != *in_rooms(x, y, TEMPLE)) ||
X	    !(priest = findpriest(roomno)))
X		return(FALSE);
X	return(has_shrine(priest) && p_coaligned(priest) && priest->mpeaceful);
X}
X
Xvoid
Xghod_hitsu(priest) 	/* when attacking "priest" in his temple */
Xstruct monst *priest;
X{
X	int x, y, ax, ay, roomno = (int)temple_occupied(u.urooms);
X	struct mkroom *troom;
X
X	if (!roomno || !has_shrine(priest))
X		return;
X
X	ax = x = EPRI(priest)->shrpos.x;
X	ay = y = EPRI(priest)->shrpos.y;
X	troom = &rooms[roomno - ROOMOFFSET];
X
X	if((u.ux == x && u.uy == y) || !linedup(u.ux, u.uy, x, y)) {
X	    if(IS_DOOR(levl[u.ux][u.uy].typ)) {
X
X		if(u.ux == troom->lx - 1) {
X		    x = troom->hx;
X		    y = u.uy;
X		} else if(u.ux == troom->hx + 1) {
X		    x = troom->lx;
X		    y = u.uy;
X		} else if(u.uy == troom->ly - 1) {
X		    x = u.ux;
X		    y = troom->hy;
X		} else if(u.uy == troom->hy + 1) {
X		    x = u.ux;
X		    y = troom->ly;
X		}
X	    } else {
X		switch(rn2(4)) {
X		case 0:  x = u.ux; y = troom->ly; break;
X		case 1:  x = u.ux; y = troom->hy; break;
X		case 2:  x = troom->lx; y = u.uy; break;
X		default: x = troom->hx; y = u.uy; break;
X		}
X	    }
X	    if(!linedup(u.ux, u.uy, x, y)) return;
X	}
X
X	switch(rn2(3)) {
X	case 0:
X	    pline("%s roars in anger:  \"Thou shalt suffer!\"",
X			a_gname_at(ax, ay));
X	    break;
X	case 1:
X	    pline("%s voice booms:  \"How darest thou harm my servant!\"",
X			s_suffix(a_gname_at(ax, ay)));
X	    break;
X	default:
X	    pline("%s roars:  \"Thou dost profane my shrine!\"",
X			a_gname_at(ax, ay));
X	    break;
X	}
X
X	buzz(-10-(AD_ELEC-1), 6, x, y, sgn(tbx), sgn(tby)); /* bolt of lightning */
X	exercise(A_WIS, FALSE);
X}
X
Xvoid
Xangry_priest()
X{
X	register struct monst *priest;
X
X	if(priest = findpriest(temple_occupied(u.urooms)))
X		wakeup(priest);
X}
X
X#endif /* OVLB */
X
X/*priest.c*/
END_OF_FILE
if test 16798 -ne `wc -c <'src/priest.c'`; then
    echo shar: \"'src/priest.c'\" unpacked with wrong size!
fi
# end of 'src/priest.c'
fi
if test -f 'win/tty/wintty.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'win/tty/wintty.c'\"
else
echo shar: Extracting \"'win/tty/wintty.c'\" \(36808 characters\)
sed "s/^X//" >'win/tty/wintty.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)wintty.c	3.1	92/10/21	*/
X/* Copyright (c) David Cohrs, 1991				  */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include "hack.h"
X#include "termcap.h"
X#include "wintty.h"
X#if (defined(BSD) || defined(ULTRIX) || defined(AIX_31) || defined(_BULL_SOURCE)) && defined(CLIPPING)
X#include <signal.h>
X#endif
X
X#define DEBUG
X
Xextern const char *roles[];	/* from u_init.c */
X
X/* Interface definition, for windows.c */
Xstruct window_procs tty_procs = {
X    "tty",
X    tty_init_nhwindows,
X    tty_player_selection,
X    tty_askname,
X    tty_get_nh_event,
X    tty_exit_nhwindows,
X    tty_suspend_nhwindows,
X    tty_resume_nhwindows,
X    tty_create_nhwindow,
X    tty_clear_nhwindow,
X    tty_display_nhwindow,
X    tty_destroy_nhwindow,
X    tty_curs,
X    tty_putstr,
X    tty_display_file,
X    tty_start_menu,
X    tty_add_menu,
X    tty_end_menu,
X    tty_select_menu,
X    tty_update_inventory,
X    tty_mark_synch,
X    tty_wait_synch,
X#ifdef CLIPPING
X    tty_cliparound,
X#endif
X    tty_print_glyph,
X    tty_raw_print,
X    tty_raw_print_bold,
X    tty_nhgetch,
X    tty_nh_poskey,
X    tty_nhbell,
X    tty_doprev_message,
X    tty_yn_function,
X    tty_getlin,
X#ifdef COM_COMPL
X    tty_get_ext_cmd,
X#endif /* COM_COMPL */
X    tty_number_pad,
X    tty_delay_output,
X    /* other defs that really should go away (they're tty specific) */
X    tty_start_screen,
X    tty_end_screen,
X};
X
Xstatic int maxwin = 0;			/* number of windows in use */
Xwinid BASE_WINDOW;
Xstruct WinDesc *wins[MAXWIN];
Xstruct DisplayDesc *ttyDisplay;	/* the tty display descriptor */
X
Xextern void FDECL(cmov, (int,int)); /* from termcap.c */
Xextern void FDECL(nocmov, (int,int)); /* from termcap.c */
X#if defined(UNIX) || defined(VMS)
Xstatic char obuf[BUFSIZ];	/* BUFSIZ is defined in stdio.h */
X#endif
X
Xstatic char winpanicstr[] = "Bad window id %d";
Xchar defmorestr[] = "--More--";
X
X#ifdef CLIPPING
Xstatic boolean clipping = FALSE;	/* clipping on? */
Xstatic int clipx = 0, clipy = 0, clipxmax = 0, clipymax = 0;
X#endif
X
X#ifdef ASCIIGRAPH
Xboolean GFlag = FALSE;
X#endif
X
X#ifdef MICRO
X#define getret() getreturn("to continue")
X#else
Xstatic void NDECL(getret);
X#endif
Xstatic void FDECL(dmore,(struct WinDesc *));
Xstatic char * FDECL(s_atr2str, (int));
Xstatic char * FDECL(e_atr2str, (int));
Xstatic const char * FDECL(compress_str, (const char *));
Xstatic void FDECL(tty_putsym, (winid, int, int, CHAR_P));
X
X#if defined(SIGWINCH) && defined(CLIPPING)
Xstatic void
Xwinch()
X{
X    int oldLI = LI, oldCO = CO, i;
X    register struct WinDesc *cw;
X
X    getwindowsz();
X    if((oldLI != LI || oldCO != CO) && ttyDisplay) {
X	ttyDisplay->rows = LI;
X	ttyDisplay->cols = CO;
X
X	cw = wins[BASE_WINDOW];
X	cw->rows = ttyDisplay->rows;
X	cw->cols = ttyDisplay->cols;
X
X	if(flags.window_inited) {
X	    cw = wins[WIN_MESSAGE];
X	    cw->curx = cw->cury = 0;
X
X	    tty_destroy_nhwindow(WIN_STATUS);
X	    WIN_STATUS = tty_create_nhwindow(NHW_STATUS);
X
X	    if(u.ux) {
X#ifdef CLIPPING
X		if(CO < COLNO || LI < ROWNO+3) {
X		    setclipped();
X		    tty_cliparound(u.ux, u.uy);
X		} else {
X		    clipping = FALSE;
X		    clipx = clipy = 0;
X		}
X#endif
X		i = ttyDisplay->toplin;
X		ttyDisplay->toplin = 0;
X		docrt();
X		bot();
X		ttyDisplay->toplin = i;
X		flush_screen(1);
X		if(i) {
X		    addtopl(toplines);
X		} else
X		    for(i=WIN_INVEN; i < MAXWIN; i++)
X			if(wins[i] && wins[i]->active) {
X			    /* cop-out */
X			    addtopl("Press Return to continue: ");
X			    break;
X			}
X		(void) fflush(stdout);
X		if(i < 2) flush_screen(1);
X	    }
X	}
X    }
X}
X#endif
X
Xvoid
Xtty_init_nhwindows()
X{
X    int wid, hgt;
X
X    /*
X     *  Remember tty modes, to be restored on exit.
X     *
X     *  gettty() must be called before tty_startup()
X     *    due to ordering of LI/CO settings
X     *  tty_startup() must be called before initoptions()
X     *    due to ordering of graphics settings
X     */
X#if defined(UNIX) || defined(VMS)
X    setbuf(stdout,obuf);
X#endif
X    gettty();
X
X    /* to port dependant tty setup */
X    tty_startup(&wid, &hgt);
X    setftty();			/* calls start_screen */
X
X    /* set up tty descriptor */
X    ttyDisplay = (struct DisplayDesc*) alloc(sizeof(struct DisplayDesc));
X    ttyDisplay->toplin = 0;
X    ttyDisplay->rows = hgt;
X    ttyDisplay->cols = wid;
X    ttyDisplay->curx = ttyDisplay->cury = 0;
X    ttyDisplay->inmore = ttyDisplay->inread = 0;
X#ifdef TEXTCOLOR
X    ttyDisplay->color = NO_COLOR;
X#endif
X    ttyDisplay->attrs = 0;
X
X    /* set up the default windows */
X    BASE_WINDOW = tty_create_nhwindow(NHW_BASE);
X    wins[BASE_WINDOW]->active = 1;
X
X    ttyDisplay->lastwin = WIN_ERR;
X
X#if defined(SIGWINCH) && defined(CLIPPING)
X    (void) signal(SIGWINCH, winch);
X#endif
X
X    tty_clear_nhwindow(BASE_WINDOW);
X
X    tty_putstr(BASE_WINDOW, 0, "");
X    tty_putstr(BASE_WINDOW, 0,
X	 "NetHack, Copyright 1985, 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993");
X    tty_putstr(BASE_WINDOW, 0,
X	 "         By Stichting Mathematisch Centrum and M. Stephenson.");
X    tty_putstr(BASE_WINDOW, 0, "         See license for details.");
X    tty_putstr(BASE_WINDOW, 0, "");
X    tty_display_nhwindow(BASE_WINDOW, FALSE);
X}
X
Xvoid
Xtty_player_selection()
X{
X    char pbuf[QBUFSZ];
X    char pick, pc;
X    int i, linecount;
X
X    linecount = wins[BASE_WINDOW]->cury+1;
X    if ((pc = highc(pl_character[0])) != 0) {
X	if(index(pl_classes, pc) != (char*) 0)
X	    goto got_suffix;
X	tty_putstr(BASE_WINDOW, 0, "");
X	Sprintf(pbuf, "Unknown role: %c", pc);
X	tty_putstr(BASE_WINDOW, 0, pbuf);
X	linecount += 2;
X	pl_character[0] = pc = 0;
X    }
X
X#define PICK_PROMPT "Shall I pick a character for you? [Y, N, or Q(quit)] "
X    tty_putstr(BASE_WINDOW, 0, "");
X    tty_putstr(BASE_WINDOW, 0, PICK_PROMPT);
X
X    while(!index("yYnNqQ", (pick = readchar())) && !index(quitchars, pick))
X	tty_nhbell();
X
X    pick = index(quitchars, pick) ? 'Y' : highc(pick);
X
X    tty_putsym(BASE_WINDOW, (int)strlen(PICK_PROMPT)+1, linecount, pick); /* echo */
X
X    if (pick == 'Q') {
X	clearlocks();
X	tty_exit_nhwindows(NULL);
X	terminate(0);
X    }
X
X    if (pick == 'Y') {
X	tty_putstr(BASE_WINDOW, 0, "");
X	goto beginner;
X    }
X
X    tty_curs(BASE_WINDOW, 1, linecount+2);
X    tty_putstr(BASE_WINDOW, 0, "What kind of character are you:");
X    tty_putstr(BASE_WINDOW, 0, "");
X    Sprintf(pbuf, " 	 %s,", An(roles[0]));
X    for(i = 1; roles[i]; i++) {
X	Sprintf(eos(pbuf), " %s", an(roles[i]));
X	if((((i + 1) % 4) == 0) && roles[i+1]) {
X	    Strcat(pbuf, ",");
X	    tty_putstr(BASE_WINDOW, 0, pbuf);
X	    linecount++;
X	    Strcpy(pbuf, "        ");
X	}
X	else if(roles[i+1] && roles[i+2])	Strcat(pbuf, ",");
X	if(roles[i+1] && !roles[i+2])	Strcat(pbuf, " or");
X    }
X    Strcat(pbuf ,"?");
X    tty_putstr(BASE_WINDOW, 0, pbuf);
X    Strcpy(pbuf, "         [");
X    for(i = 0; roles[i]; i++)
X	Sprintf(eos(pbuf), "%c,", pl_classes[i]);
X    Strcat(pbuf, " or Q] ");
X    tty_putstr(BASE_WINDOW, 0, pbuf);
X    linecount += 5;
X
X    while ((pc = readchar()) != 0) {
X	if ((pc = highc(pc)) == 'Q') {
X	    clearlocks();
X	    tty_exit_nhwindows(NULL);
X	    terminate(0);
X	}
X	if(index(pl_classes, pc) != (char *) 0) {
X	    tty_putsym(BASE_WINDOW, (int)strlen(pbuf)+1, linecount, pc); /* echo */
X	    tty_putstr(BASE_WINDOW, 0, "");
X	    tty_display_nhwindow(BASE_WINDOW, TRUE);
X	    break;
X	}
X	if(pc == '\n') {
X	    pc = 0;
X	    break;
X	}
X	tty_nhbell();
X    }
X
Xbeginner:
X    if(!pc) {
X	i = rn2((int)strlen(pl_classes));
X	pc = pl_classes[i];
X	tty_putstr(BASE_WINDOW, 0, "");
X	Sprintf(pbuf, "This game you will be %s.", an(roles[i]));
X	tty_putstr(BASE_WINDOW, 0, pbuf);
X	tty_putstr(BASE_WINDOW, 0, "");
X	tty_display_nhwindow(BASE_WINDOW, TRUE);
X	getret();
X    }
Xgot_suffix:
X
X    tty_clear_nhwindow(BASE_WINDOW);
X    pl_character[0] = pc;
X    return;
X}
X
X/*
X * plname is filled either by an option (-u Player  or  -uPlayer) or
X * explicitly (by being the wizard) or by askname.
X * It may still contain a suffix denoting pl_character.
X * Always called after init_nhwindows() and before display_gamewindows().
X */
Xvoid
Xtty_askname()
X{
X	register int c, ct;
X
X	tty_putstr(BASE_WINDOW, 0, "");
X	tty_putstr(BASE_WINDOW, 0, "Who are you? ");
X	tty_curs(BASE_WINDOW, 14, wins[BASE_WINDOW]->cury-1);
X	ct = 0;
X	while((c = tty_nhgetch()) != '\n') {
X		if(c == EOF) error("End of input\n");
X#ifndef VMS
X		/* some people get confused when their erase char is not ^H */
X		if(c == '\b') {
X			if(ct) {
X				ct--;
X# ifdef MICRO
X				msmsg("\b \b");
X# else
X				(void) putchar('\b');
X				(void) putchar(' ');
X				(void) putchar('\b');
X# endif
X			}
X			continue;
X		}
X#endif
X#if defined(UNIX) || defined(VMS)
X		if(c != '-')
X		if(c < 'A' || (c > 'Z' && c < 'a') || c > 'z') c = '_';
X#endif
X		if(ct < sizeof(plname)-1) {
X#if defined(MICRO)
X			msmsg("%c", c);
X#else
X			(void) putchar(c);
X#endif
X			plname[ct++] = c;
X		}
X	}
X	plname[ct] = 0;
X	tty_curs(BASE_WINDOW, 1, wins[BASE_WINDOW]->cury+1);
X	if(ct == 0) tty_askname();
X}
X
Xvoid
Xtty_get_nh_event()
X{
X#ifdef LINT
X    /*
X     * We should do absolutely nothing here - but lint
X     * complains about that, so we call donull().
X     */
X     (void) donull();
X#endif
X}
X
X#ifndef MICRO
Xstatic void
Xgetret()
X{
X	xputs("\n");
X	if(flags.standout)
X		standoutbeg();
X	xputs("Hit ");
X	xputs(flags.cbreak ? "space" : "return");
X	xputs(" to continue: ");
X	if(flags.standout)
X		standoutend();
X	xwaitforspace("");
X}
X#endif
X
Xvoid
Xtty_suspend_nhwindows(str)
X    const char *str;
X{
X    settty(str);		/* calls end_screen, perhaps raw_print */
X    if (!str) tty_raw_print("");	/* calls fflush(stdout) */
X}
X
Xvoid
Xtty_resume_nhwindows()
X{
X    gettty();
X    setftty();			/* calls start_screen */
X    docrt();
X}
X
Xvoid
Xtty_exit_nhwindows(str)
X    const char *str;
X{
X    winid i;
X
X    tty_suspend_nhwindows(str);
X    /* Just forget any windows existed, since we're about to exit anyway.
X     * Disable windows to avoid calls to window routines.
X     */
X    for(i=0; i<MAXWIN; i++)
X	if(i != BASE_WINDOW)
X	    wins[i] = 0;
X    flags.window_inited = 0;
X}
X
Xwinid
Xtty_create_nhwindow(type)
X    int type;
X{
X    struct WinDesc* newwin;
X    int i;
X    int newid;
X
X    if(maxwin == MAXWIN)
X	return WIN_ERR;
X
X    newwin = (struct WinDesc*) alloc(sizeof(struct WinDesc));
X    newwin->type = type;
X    newwin->flags = 0;
X    newwin->active = FALSE;
X    newwin->curx = newwin->cury = 0;
X    newwin->resp = newwin->canresp = newwin->morestr = 0;
X    switch(type) {
X    case NHW_BASE:
X	/* base window, used for absolute movement on the screen */
X	newwin->offx = newwin->offy = 0;
X	newwin->rows = ttyDisplay->rows;
X	newwin->cols = ttyDisplay->cols;
X	newwin->maxrow = newwin->maxcol = 0;
X	break;
X    case NHW_MESSAGE:
X	/* message window, 1 line long, very wide, top of screen */
X	newwin->offx = newwin->offy = 0;
X	/* sanity check */
X	if(flags.msg_history < 20) flags.msg_history = 20;
X	else if(flags.msg_history > 60) flags.msg_history = 60;
X	newwin->maxrow = newwin->rows = flags.msg_history;
X	newwin->maxcol = newwin->cols = 0;
X	break;
X    case NHW_STATUS:
X	/* status window, 2 lines long, full width, bottom of screen */
X	newwin->offx = 0;
X	newwin->offy = min((int)ttyDisplay->rows-2, ROWNO+1);
X	newwin->rows = newwin->maxrow = 2;
X	newwin->cols = newwin->maxcol = min(ttyDisplay->cols, COLNO);
X	break;
X    case NHW_MAP:
X	/* map window, ROWNO lines long, full width, below message window */
X	newwin->offx = 0;
X	newwin->offy = 1;
X	newwin->rows = ROWNO;
X	newwin->cols = COLNO;
X	newwin->maxrow = 0;	/* no buffering done -- let gbuf do it */
X	newwin->maxcol = 0;
X	break;
X    case NHW_MENU:
X	newwin->resp = (char*) alloc(256);
X	newwin->resp[0] = 0;
X    case NHW_TEXT:
X	/* inventory/menu window, variable length, full width, top of screen */
X	/* help window, the same, different semantics for display, etc */
X	newwin->offx = newwin->offy = 0;
X	newwin->rows = 0;
X	newwin->cols = ttyDisplay->cols;
X	newwin->maxrow = newwin->maxcol = 0;
X	break;
X   default:
X	panic("Tried to create window type %d\n", (int) type);
X	return WIN_ERR;
X    }
X
X    for(newid = 0; newid<MAXWIN; newid++) {
X	if(wins[newid] == 0) {
X	    wins[newid] = newwin;
X	    break;
X	}
X    }
X    if(newid == MAXWIN) {
X	panic("No window slots!");
X	return WIN_ERR;
X    }
X
X    if(newwin->maxrow) {
X	newwin->data = (char**) alloc(sizeof(char**) * newwin->maxrow);
X	if(newwin->maxcol) {
X	    for(i=0; i< newwin->maxrow; i++)
X		newwin->data[i] = (char*)alloc(sizeof(char*) * newwin->maxcol);
X	} else {
X	    for(i=0; i< newwin->maxrow; i++)
X		newwin->data[i] = 0;
X	}
X	if(newwin->type == NHW_MESSAGE)
X	    newwin->maxrow = 0;
X    } else
X	newwin->data = 0;
X
X    return newid;
X}
X
Xvoid
Xtty_clear_nhwindow(window)
X    winid window;
X{
X    register struct WinDesc *cw = 0;
X    int i;
X
X    if(window == WIN_ERR || (cw = wins[window]) == (struct WinDesc *) 0)
X	panic(winpanicstr,  window);
X    ttyDisplay->lastwin = window;
X
X    switch(cw->type) {
X    case NHW_MESSAGE:
X	if(ttyDisplay->toplin) {
X	    home();
X	    cl_end();
X	    if(cw->cury)
X		docorner(1, cw->cury+1);
X	    ttyDisplay->toplin = 0;
X	}
X	break;
X    case NHW_STATUS:
X	tty_curs(window, 1, 0);
X	cl_end();
X	tty_curs(window, 1, 1);
X	cl_end();
X	break;
X    case NHW_MAP:
X	/* cheap -- clear the whole thing and tell nethack to redraw botl */
X	flags.botlx = 1;
X	/* fall into ... */
X    case NHW_BASE:
X	clear_screen();
X	break;
X    case NHW_MENU:
X    case NHW_TEXT:
X	if(cw->active) {
X	    if(cw->offx == 0)
X		if(cw->offy) {
X		    tty_curs(window, 1, 0);
X		    cl_eos();
X		} else
X		    clear_screen();
X	    else
X		docorner((int)cw->offx, cw->maxrow+1);
X	}
X	for(i=0; i<cw->maxrow; i++)
X	    if(cw->data[i]) {
X		free((genericptr_t)cw->data[i]);
X		cw->data[i] = 0;
X	    }
X	cw->maxrow = cw->maxcol = 0;
X	if(cw->resp)
X	    cw->resp[0] = 0;
X	if(cw->canresp) {
X	    free((genericptr_t)cw->canresp);
X	    cw->canresp = 0;
X	}
X	if(cw->morestr) {
X	    free((genericptr_t)cw->morestr);
X	    cw->morestr = 0;
X	}
X	break;
X    }
X    cw->curx = cw->cury = 0;
X}
X
Xstatic void
Xdmore(cw)
X    register struct WinDesc *cw;
X{
X    const char *s = (cw->resp && *cw->resp) ? cw->resp : quitchars;
X    const char *prompt = cw->morestr ? cw->morestr : defmorestr;
X    if(cw->type == NHW_TEXT)
X	tty_curs(BASE_WINDOW, (int)ttyDisplay->curx+1, (int)ttyDisplay->cury);
X    else
X	tty_curs(BASE_WINDOW, (int)ttyDisplay->curx+2, (int)ttyDisplay->cury);
X    if(flags.standout)
X	standoutbeg();
X    xputs(prompt);
X    ttyDisplay->curx += strlen(prompt);
X    if(flags.standout)
X	standoutend();
X
X    xwaitforspace(s);
X}
X
X/*ARGSUSED*/
Xvoid
Xtty_display_nhwindow(window, blocking)
X    winid window;
X    boolean blocking;	/* with ttys, all windows are blocking */
X{
X    register struct WinDesc *cw = 0;
X    int i, n, attr;
X    register char *cp;
X
X    if(window == WIN_ERR || (cw = wins[window]) == (struct WinDesc *) 0)
X	panic(winpanicstr,  window);
X    if(cw->flags & WIN_CANCELLED)
X	return;
X    ttyDisplay->lastwin = window;
X    ttyDisplay->rawprint = 0;
X
X    switch(cw->type) {
X    case NHW_MESSAGE:
X	if(ttyDisplay->toplin == 1) {
X	    more();
X	    ttyDisplay->toplin = 1; /* more resets this */
X	    tty_clear_nhwindow(window);
X	} else
X	    ttyDisplay->toplin = 0;
X	cw->curx = cw->cury = 0;
X	if(!cw->active)
X	    flags.window_inited = TRUE;
X	break;
X    case NHW_MAP:
X	end_glyphout();
X	if(blocking) {
X	    if(!ttyDisplay->toplin) ttyDisplay->toplin = 1;
X	    tty_display_nhwindow(WIN_MESSAGE, TRUE);
X	    return;
X	}
X    case NHW_BASE:
X	(void) fflush(stdout);
X	break;
X    case NHW_TEXT:
X	cw->maxcol = ttyDisplay->cols; /* force full-screen mode */
X    case NHW_MENU:
X	cw->active = 1;
X	/* avoid converting to uchar before calculations are finished */
X	cw->offx = (uchar) (int)
X	    max((int) 10, (int) (ttyDisplay->cols - cw->maxcol - 1));
X	if(cw->type == NHW_MENU)
X	    cw->offy = 0;
X	if(ttyDisplay->toplin == 1)
X	    tty_display_nhwindow(WIN_MESSAGE, TRUE);
X	if(cw->offx == 10 || cw->maxrow >= (int) ttyDisplay->rows) {
X	    cw->offx = 0;
X	    if(cw->offy) {
X		tty_curs(window, 1, 0);
X		cl_eos();
X	    } else
X		clear_screen();
X	    ttyDisplay->toplin = 0;
X	} else
X	    tty_clear_nhwindow(WIN_MESSAGE);
X
X	for(n=0, i=0; i<cw->maxrow; i++) {
X	    if(!cw->offx && (n+cw->offy == ttyDisplay->rows-1)) {
X		tty_curs(window, 1, n);
X		cl_end();
X		dmore(cw);
X		if(morc) {
X		    if(!cw->canresp && (morc == '\033'))
X			cw->flags |= WIN_CANCELLED;
X		    else if(cw->canresp && index(&cw->canresp[1], morc)) {
X			morc = cw->canresp[0];
X			cw->flags |= WIN_CANCELLED;
X		    }
X		    break;
X		}
X		if(cw->offy) {
X		    tty_curs(window, 1, 0);
X		    cl_eos();
X		} else
X		    clear_screen();
X		n = 0;
X	    }
X	    tty_curs(window, 1, n++);
X	    if(cw->offx) cl_end();
X	    if(cw->data[i]) {
X		attr = cw->data[i][0]-1;
X		if(cw->type == NHW_MENU) {
X		    (void) putchar(' '); ++ttyDisplay->curx;
X		}
X		if(attr)
X		    xputs(s_atr2str(attr));
X		for(cp = &cw->data[i][1];
X		    *cp && (int)++ttyDisplay->curx < (int) ttyDisplay->cols; )
X			(void) putchar(*cp++);
X		if(attr)
X		    xputs(e_atr2str(attr));
X	    }
X	}
X	if(i == cw->maxrow) {
X	    if(cw->type == NHW_TEXT)
X		tty_curs(BASE_WINDOW, (int)cw->offx+1, (int)ttyDisplay->rows-1);
X	    else
X		tty_curs(BASE_WINDOW, (int)cw->offx+1, n);
X	    cl_end();
X	    dmore(cw);
X	    if(morc) {
X		if(!cw->canresp && (morc == '\033'))
X		    cw->flags |= WIN_CANCELLED;
X		else if(cw->canresp && index(&cw->canresp[1], morc)) {
X		    morc = cw->canresp[0];
X		    cw->flags |= WIN_CANCELLED;
X		}
X	    }
X	}
X	break;
X    }
X    cw->active = 1;
X}
X
Xvoid
Xtty_dismiss_nhwindow(window)
X    winid window;
X{
X    register struct WinDesc *cw = 0;
X
X    if(window == WIN_ERR || (cw = wins[window]) == (struct WinDesc *) 0)
X	panic(winpanicstr,  window);
X
X    switch(cw->type) {
X    case NHW_STATUS:
X    case NHW_BASE:
X    case NHW_MESSAGE:
X    case NHW_MAP:
X	/*
X	 * these should only get dismissed when the game is going away
X	 * or suspending
X	 */
X	tty_curs(BASE_WINDOW, 1, (int)ttyDisplay->rows-1);
X	cw->active = 0;
X	break;
X    case NHW_MENU:
X    case NHW_TEXT:
X	if(cw->active) {
X	    if(cw->offx == 0) {
X		if(cw->offy) {
X		    tty_curs(window, 1, 0);
X		    cl_eos();
X		} else
X		    docrt();
X	    } else {
X		docorner((int)cw->offx, cw->maxrow+1);
X	    }
X	    cw->active = 0;
X	}
X	break;
X    }
X    cw->flags = 0;
X}
X
Xvoid
Xtty_destroy_nhwindow(window)
X    winid window;
X{
X    register struct WinDesc *cw = 0;
X    int i;
X
X    if(window == WIN_ERR || (cw = wins[window]) == (struct WinDesc *) 0)
X	panic(winpanicstr,  window);
X
X    if(cw->active)
X	tty_dismiss_nhwindow(window);
X    if(cw->type == NHW_MESSAGE)
X	flags.window_inited = 0;
X    if(cw->type == NHW_MAP)
X	clear_screen();
X
X    if(cw->data) {
X	for(i=0; i<cw->rows; i++)
X	    if(cw->data[i])
X		free((genericptr_t)cw->data[i]);
X	free((genericptr_t)cw->data);
X    }
X    if(cw->resp)
X	free((genericptr_t)cw->resp);
X    if(cw->canresp)
X	free((genericptr_t)cw->canresp);
X    free((genericptr_t)cw);
X    wins[window] = 0;
X}
X
Xvoid
Xtty_curs(window, x, y)
Xwinid window;
Xregister int x, y;	/* not xchar: perhaps xchar is unsigned and
X			   curx-x would be unsigned as well */
X{
X    struct WinDesc *cw = 0;
X    int cx = ttyDisplay->curx;
X    int cy = ttyDisplay->cury;
X
X    if(window == WIN_ERR || (cw = wins[window]) == (struct WinDesc *) 0)
X	panic(winpanicstr,  window);
X    ttyDisplay->lastwin = window;
X
X    cw->curx = --x;	/* column 0 is never used */
X    cw->cury = y;
X#ifdef DEBUG
X    if(x<0 || y<0 || y >= cw->rows || x >= cw->cols) {
X	const char *s = "[unknown type]";
X	switch(cw->type) {
X	case NHW_MESSAGE: s = "[topl window]"; break;
X	case NHW_STATUS: s = "[status window]"; break;
X	case NHW_MAP: s = "[map window]"; break;
X	case NHW_MENU: s = "[corner window]"; break;
X	case NHW_TEXT: s = "[text window]"; break;
X	case NHW_BASE: s = "[base window]"; break;
X	}
X	impossible("bad curs positioning win %d %s (%d,%d)", window, s, x, y);
X	return;
X    }
X#endif
X    x += cw->offx;
X    y += cw->offy;
X
X#ifdef CLIPPING
X    if(clipping && window == WIN_MAP) {
X	x -= clipx;
X	y -= clipy;
X    }
X#endif
X
X    if (y == cy && x == cx)
X	return;
X
X    if(cw->type == NHW_MAP)
X	end_glyphout();
X
X    if(!ND && (cx != x || x <= 3)) { /* Extremely primitive */
X	cmov(x, y); /* bunker!wtm */
X	return;
X    }
X    if((cy -= y) < 0) cy = -cy;
X    if((cx -= x) < 0) cx = -cx;
X    if(cy <= 3 && cx <= 3)
X	nocmov(x, y);
X    else if((x <= 3 && cy <= 3) || (!CM && x < cx)) {
X	(void) putchar('\r');
X	ttyDisplay->curx = 0;
X	nocmov(x, y);
X    } else if(!CM) {
X	nocmov(x, y);
X    } else
X	cmov(x, y);
X
X    ttyDisplay->curx = x;
X    ttyDisplay->cury = y;
X}
X
Xstatic void
Xtty_putsym(window, x, y, ch)
X    winid window;
X    int x, y;
X    char ch;
X{
X    register struct WinDesc *cw = 0;
X
X    if(window == WIN_ERR || (cw = wins[window]) == (struct WinDesc *) 0)
X	panic(winpanicstr,  window);
X
X    switch(cw->type) {
X    case NHW_STATUS:
X    case NHW_MAP:
X    case NHW_BASE:
X	tty_curs(window, x, y);
X	(void) putchar(ch);
X	ttyDisplay->curx++;
X	cw->curx++;
X	break;
X    case NHW_MESSAGE:
X    case NHW_MENU:
X    case NHW_TEXT:
X	impossible("Can't putsym to window type %d", cw->type);
X	break;
X    }
X}
X
Xstatic char nulstr[] = "";
X
Xstatic char *
Xs_atr2str(n)
X    int n;
X{
X    switch(n) {
X    case ATR_ULINE:
X	if(US) return US;
X    case ATR_BOLD:
X    case ATR_BLINK:
X    case ATR_INVERSE:
X	return HI;
X    }
X    return nulstr;
X}
X
Xstatic char *
Xe_atr2str(n)
X    int n;
X{
X    switch(n) {
X    case ATR_ULINE:
X	if(UE) return UE;
X    case ATR_BOLD:
X    case ATR_BLINK:
X    case ATR_INVERSE:
X	return HE;
X    }
X    return nulstr;
X}
X
Xstatic const char*
Xcompress_str(str)
Xconst char *str;
X{
X    	static char cbuf[BUFSZ];
X	/* compress in case line too long */
X	if((int)strlen(str) >= CO) {
X		register const char *bp0 = str;
X		register char *bp1 = cbuf;
X
X		do {
X#ifdef CLIPPING
X			if(*bp0 != ' ' || bp0[1] != ' ')
X#else
X			if(*bp0 != ' ' || bp0[1] != ' ' || bp0[2] != ' ')
X#endif
X				*bp1++ = *bp0;
X		} while(*bp0++);
X	} else
X	    return str;
X	return cbuf;
X}
X
Xvoid
Xtty_putstr(window, attr, str)
X    winid window;
X    int attr;
X    const char *str;
X{
X    register struct WinDesc *cw = 0;
X    register char *ob;
X    register const char *nb;
X    register int i, j, n0;
X
X    /* Assume there's a real problem if the window is missing --
X     * probably a panic message
X     */
X    if(window == WIN_ERR || (cw = wins[window]) == (struct WinDesc *) 0) {
X	tty_raw_print(str);
X	return;
X    }
X
X    if(str == (const char*)NULL || (cw->flags & WIN_CANCELLED))
X	return;
X    if(cw->type != NHW_MESSAGE)
X	str = compress_str(str);
X
X    ttyDisplay->lastwin = window;
X
X    switch(cw->type) {
X    case NHW_MESSAGE:
X	/* really do this later */
X	update_topl(str);
X	break;
X
X    case NHW_STATUS:
X	ob = &cw->data[cw->cury][j = cw->curx];
X	if(flags.botlx) *ob = 0;
X	if(!cw->cury && (int)strlen(str) >= CO) {
X	    /* the characters before "St:" are unnecessary */
X	    nb = index(str, ':');
X	    if(nb && nb > str+2)
X		str = nb - 2;
X	}
X	nb = str;
X	for(i = cw->curx+1, n0 = cw->cols; i < n0; i++, nb++) {
X	    if(!*nb) {
X		if(*ob || flags.botlx) {
X		    /* last char printed may be in middle of line */
X		    tty_curs(WIN_STATUS, i, cw->cury);
X		    cl_end();
X		}
X		break;
X	    }
X	    if(*ob != *nb)
X		tty_putsym(WIN_STATUS, i, cw->cury, *nb);
X	    if(*ob) ob++;
X	}
X
X	(void) strncpy(&cw->data[cw->cury][j], str, cw->cols - j - 1);
X	cw->data[cw->cury][cw->cols-1] = '\0'; /* null terminate */
X	cw->cury = (cw->cury+1) % 2;
X	cw->curx = 0;
X	break;
X    case NHW_MAP:
X    case NHW_BASE:
X	tty_curs(window, cw->curx+1, cw->cury);
X	if(attr)
X	    xputs(s_atr2str(attr));
X	while(*str && (int) ttyDisplay->curx < (int) ttyDisplay->cols-1) {
X	    (void) putchar(*str++);
X	    ttyDisplay->curx++;
X	}
X	cw->curx = 0;
X	cw->cury++;
X	if(attr)
X	    xputs(e_atr2str(attr));
X	break;
X    case NHW_MENU:
X    case NHW_TEXT:
X	if(!(cw->resp && cw->resp[0]) && cw->cury == ttyDisplay->rows-1) {
X	    /* not a menu, so save memory and output 1 page at a time */
X	    cw->maxcol = ttyDisplay->cols; /* force full-screen mode */
X	    tty_display_nhwindow(window, TRUE);
X	    cw->maxrow = cw->cury = 0;
X	}
X	/* always grows one at a time, but alloc 12 at a time */
X	if(cw->cury >= cw->rows) {
X	    char **tmp;
X
X	    cw->rows += 12;
X	    tmp = (char**) alloc(sizeof(char*) * cw->rows);
X	    for(i=0; i<cw->maxrow; i++)
X		tmp[i] = cw->data[i];
X	    if(cw->data)
X		free((genericptr_t)cw->data);
X	    cw->data = tmp;
X
X	    for(i=cw->maxrow; i<cw->rows; i++)
X		cw->data[i] = 0;
X	}
X	if(cw->data[cw->cury])
X	    free((genericptr_t)cw->data[cw->cury]);
X	n0 = strlen(str)+1;
X	cw->data[cw->cury] = (char*) alloc(n0+1);
X	cw->data[cw->cury][0] = attr+1;	/* avoid nuls, for convenience */
X	Strcpy(&cw->data[cw->cury][1], str);
X
X	if(n0 > cw->maxcol)
X	    cw->maxcol = n0;
X	if(++cw->cury > cw->maxrow)
X	    cw->maxrow = cw->cury;
X	if(n0 > CO) {
X	    /* attempt to break the line */
X	    for(i = CO-1; i && str[i] != ' ';)
X		i--;
X	    if(i) {
X		cw->data[cw->cury-1][++i] = '\0';
X		tty_putstr(window, attr, &str[i]);
X	    }
X		
X	}
X	break;
X    }
X}
X
Xvoid
Xtty_display_file(fname, complain)
Xconst char *fname;
Xboolean complain;
X{
X#ifdef DEF_PAGER			/* this implies that UNIX is defined */
X    {
X	/* use external pager; this may give security problems */
X	register int fd = open(fname, 0);
X
X	if(fd < 0) {
X	    if(complain) pline("Cannot open %s.", fname);
X	    else docrt();
X	    return;
X	}
X	if(child(1)) {
X	    /* Now that child() does a setuid(getuid()) and a chdir(),
X	       we may not be able to open file fname anymore, so make
X	       it stdin. */
X	    (void) close(0);
X	    if(dup(fd)) {
X		if(complain) raw_printf("Cannot open %s as stdin.", fname);
X	    } else {
X		(void) execlp(catmore, "page", NULL);
X		if(complain) raw_printf("Cannot exec %s.", catmore);
X	    }
X	    if(complain) sleep(10); /* want to wait_synch() but stdin is gone */
X	    terminate(1);
X	}
X	(void) close(fd);
X    }
X#else
X    {
X	FILE *f;
X	char buf[BUFSZ];
X	char *cr;
X
X	tty_clear_nhwindow(WIN_MESSAGE);
X	f = fopen_datafile(fname, "r");
X	if (!f) {
X	    if(complain) {
X		home();  tty_mark_synch();  tty_raw_print("");
X		perror(fname);  tty_wait_synch();
X		pline("Cannot open \"%s\".", fname);
X	    } else if(u.ux) docrt();
X	} else {
X	    winid datawin = tty_create_nhwindow(NHW_TEXT);
X	    if(complain && CD) {
X		/* attempt to scroll text below map window if there's room */
X		wins[datawin]->offy = wins[WIN_STATUS]->offy+3;
X		if((int) wins[datawin]->offy + 12 > (int) ttyDisplay->rows)
X		    wins[datawin]->offy = 0;
X	    }
X	    while (fgets(buf, BUFSZ, f)) {
X		if ((cr = index(buf, '\n')) != 0) *cr = 0;
X		if (index(buf, '\t') != 0) (void) tabexpand(buf);
X		tty_putstr(datawin, 0, buf);
X		if(wins[datawin]->flags & WIN_CANCELLED)
X		    break;
X	    }
X	    tty_display_nhwindow(datawin, FALSE);
X	    tty_destroy_nhwindow(datawin);
X	    (void) fclose(f);
X	}
X    }
X#endif /* DEF_PAGER */
X}
X
Xvoid
Xtty_start_menu(window)
X    winid window;
X{
X    tty_clear_nhwindow(window);
X    return;
X}
X
X/*
X * Add a menu item.  window must be an NHW_MENU type,
X * ch is the value to return if this entry is selected.
X * attr are attributes to set for this line (like tty_putstr())
X * str is the value to display on this menu line
X */
Xvoid
Xtty_add_menu(window, ch, attr, str)
X    winid window;
X    char ch;
X    int attr;
X    const char *str;
X{
X    register struct WinDesc *cw = 0;
X    char tmpbuf[2];
X
X    if(str == (const char*)NULL)
X	return;
X
X    if(window == WIN_ERR || (cw = wins[window]) == (struct WinDesc *) 0
X       || cw->type != NHW_MENU)
X	panic(winpanicstr,  window);
X
X    tty_putstr(window, attr, str);
X    if(ch != '\0') {
X	tmpbuf[0] = ch;
X	tmpbuf[1] = 0;
X	Strcat(cw->resp, tmpbuf);
X    }
X}
X
X/*
X * End a menu in this window, window must a type NHW_MENU.
X * ch is the value to return if the menu is canceled,
X * str is a list of cancel characters (values that may be input)
X * morestr is a prompt to display, rather than the default.
X * str and morestr might be ignored by some ports.
X */
Xvoid
Xtty_end_menu(window, ch, str, morestr)
X    winid window;
X    char ch;
X    const char *str;
X    const char *morestr;
X{
X    register struct WinDesc *cw = 0;
X
X    if(window == WIN_ERR || (cw = wins[window]) == (struct WinDesc *) 0 ||
X       cw->type != NHW_MENU || cw->canresp)
X	panic(winpanicstr,  window);
X
X    if(str) {
X	cw->canresp = (char*) alloc(strlen(str)+2);
X	cw->canresp[0] = ch;			/* this could be NUL? */
X	Strcpy(&cw->canresp[1], str);
X	Strcat(cw->resp, str);
X    }
X    if(morestr) {
X	unsigned int len = strlen(morestr) + 1;
X	cw->morestr = (char*) alloc(len);
X	Strcpy(cw->morestr, morestr);
X	if(++len > cw->maxcol)	/* add one to avoid using the rtmost column */
X	    cw->maxcol = len;
X    }
X}
X
Xchar
Xtty_select_menu(window)
X    winid window;
X{
X    register struct WinDesc *cw = 0;
X
X    morc = 0;
X    if(window == WIN_ERR || (cw = wins[window]) == (struct WinDesc *) 0
X       || cw->type != NHW_MENU)
X	panic(winpanicstr,  window);
X    tty_display_nhwindow(window, TRUE);
X    tty_dismiss_nhwindow(window);
X
X    return morc;
X}
X
Xvoid
Xtty_update_inventory()
X{
X}
X
Xvoid
Xtty_mark_synch()
X{
X    (void) fflush(stdout);
X}
X
Xvoid
Xtty_wait_synch()
X{
X    /* we just need to make sure all windows are synch'd */
X    if(!ttyDisplay || ttyDisplay->rawprint) {
X	getret();
X	if(ttyDisplay) ttyDisplay->rawprint = 0;
X    } else {
X	tty_display_nhwindow(WIN_MAP, FALSE);
X	if(ttyDisplay->inmore) {
X	    addtopl("--More--");
X	    (void) fflush(stdout);
X	} else if(ttyDisplay->inread) {
X	    ttyDisplay->toplin = 3;
X	    /* do this twice; 1st time gets the Quit? message again */
X	    (void) tty_doprev_message();
X	    (void) tty_doprev_message();
X	    (void) fflush(stdout);
X	}
X    }
X}
X
Xvoid
Xdocorner(xmin, ymax)
X    register int xmin, ymax;
X{
X    register int y;
X    register struct WinDesc *cw = wins[WIN_MAP];
X
X    if (u.uswallow) {	/* Can be done more efficiently */
X	swallowed(1);
X	return;
X    }
X
X#if defined(SIGWINCH) && defined(CLIPPING)
X    if(ymax > LI) ymax = LI;		/* can happen if window gets smaller */
X#endif
X    for (y = 0; y < ymax; y++) {
X	tty_curs(BASE_WINDOW, xmin,y);	/* move cursor */
X	cl_end();			/* clear to end of line */
X#ifdef CLIPPING
X	if (y<(int) cw->offy || y+clipy > ROWNO) 
X		continue; /* only refresh board */
X	row_refresh(xmin+clipx-(int)cw->offx,COLNO-1,y+clipy-(int)cw->offy);
X#else
X	if (y<cw->offy || y > ROWNO) continue; /* only refresh board  */
X	row_refresh(xmin-(int)cw->offx,COLNO-1,y-(int)cw->offy);
X#endif
X    }
X
X    end_glyphout();
X    if (ymax >= (int) wins[WIN_STATUS]->offy) { 
X					/* we have wrecked the bottom line */
X	flags.botlx = 1;
X	bot();
X    }
X}
X
Xvoid
Xend_glyphout()
X{
X#ifdef ASCIIGRAPH
X    if (GFlag) {
X	GFlag = FALSE;
X	graph_off();
X    }
X#endif
X#ifdef TEXTCOLOR
X    if(ttyDisplay->color != NO_COLOR) {
X	xputs(HE);
X	ttyDisplay->color = NO_COLOR;
X    }
X#endif
X}
X
X#ifdef ASCIIGRAPH
Xvoid
Xg_putch(ch)
X    uchar ch;
X{
X    if (flags.IBMgraphics)
X	/* IBM-compatible displays don't need other stuff */
X	(void) putchar((char) ch);
X    else if (ch & 0x80) {
X	if (!GFlag) {
X	    graph_on();
X	    GFlag = TRUE;
X	}
X	(void) putchar((char) (ch ^ 0x80)); /* Strip 8th bit */
X    } else {
X	if (GFlag) {
X	    graph_off();
X	    GFlag = FALSE;
X	}
X	(void) putchar((char) ch);
X    }
X}
X
X#else
X
Xvoid
Xg_putch(ch)
X    uchar ch;
X{
X    (void) putchar((char)(ch));
X};
X
X#endif	/* ASCIIGRAPH */
X
X#ifdef CLIPPING
Xvoid
Xsetclipped()
X{
X	clipping = TRUE;
X	clipx = clipy = 0;
X	clipxmax = CO;
X	clipymax = LI - 3;
X}
X
Xvoid
Xtty_cliparound(x, y)
Xint x, y;
X{
X	int oldx = clipx, oldy = clipy;
X
X	if (!clipping) return;
X	if (x < clipx + 5) {
X		clipx = max(0, x - 20);
X		clipxmax = clipx + CO;
X	}
X	else if (x > clipxmax - 5) {
X		clipxmax = min(COLNO, clipxmax + 20);
X		clipx = clipxmax - CO;
X	}
X	if (y < clipy + 2) {
X		clipy = max(0, y - (clipymax - clipy) / 2);
X		clipymax = clipy + (LI - 3);
X	}
X	else if (y > clipymax - 2) {
X		clipymax = min(ROWNO, clipymax + (clipymax - clipy) / 2);
X		clipy = clipymax - (LI - 3);
X	}
X	if (clipx != oldx || clipy != oldy) {
X		(void) doredraw();
X	}
X}
X#endif /* CLIPPING */
X
X
X/*
X *  tty_print_glyph
X *
X *  Print the glyph to the output device.  Don't flush the output device.
X *
X *  Since this is only called from show_glyph(), it is assumed that the
X *  position and glyph are always correct (checked there)!
X */
Xvoid
Xtty_print_glyph(window, x, y, glyph)
X    winid window;
X    xchar x, y;
X    int glyph;
X{
X    uchar   ch;
X    register int offset;
X#ifdef TEXTCOLOR
X    int	    color;
X
X#define zap_color(n)  color = flags.use_color ? zapcolors[n] : NO_COLOR
X#define cmap_color(n) color = flags.use_color ? defsyms[n].color : NO_COLOR
X#define trap_color(n) color = flags.use_color ? \
X				(((n) == WEB) ? defsyms[S_web ].color  : \
X					        defsyms[S_trap].color) : \
X						NO_COLOR
X#define obj_color(n)  color = flags.use_color ? objects[n].oc_color : NO_COLOR
X#define mon_color(n)  color = flags.use_color ? mons[n].mcolor : NO_COLOR
X#define pet_color(n)  color = flags.use_color ? mons[n].mcolor :	      \
X				/* If no color, try to hilite pets; black  */ \
X				/* should be HI				   */ \
X    				((flags.hilite_pet && hilites[BLACK]) ?	      \
X							BLACK : NO_COLOR)
X# else /* no text color */
X
X#define zap_color(n)
X#define cmap_color(n)
X#define trap_color(n)
X#define obj_color(n)
X#define mon_color(n)
X#define pet_color(c)
X#endif
X
X#ifdef CLIPPING
X    if(clipping) {
X	if(x <= clipx || y < clipy || x >= clipxmax || y >= clipymax)
X	    return;
X    }
X#endif
X    /*
X     *  Map the glyph back to a character.
X     *
X     *  Warning:  For speed, this makes an assumption on the order of
X     *		  offsets.  The order is set in display.h.
X     */
X    if ((offset = (glyph - GLYPH_SWALLOW_OFF)) >= 0) {		/* swallow */
X	/* see swallow_to_glyph() in display.c */
X	ch = (uchar) showsyms[S_sw_tl + (offset & 0x7)];
X	mon_color(offset >> 3);
X    } else if ((offset = (glyph - GLYPH_ZAP_OFF)) >= 0) {	/* zap beam */
X	/* see zapdir_to_glyph() in display.c */
X	ch = showsyms[S_vbeam + (offset & 0x3)];
X	zap_color((offset >> 2));
X    } else if ((offset = (glyph - GLYPH_CMAP_OFF)) >= 0) {	/* cmap */
X	ch = showsyms[offset];
X	cmap_color(offset);
X    } else if ((offset = (glyph - GLYPH_TRAP_OFF)) >= 0) {	/* trap */
X	ch = (offset == WEB) ? showsyms[S_web] : showsyms[S_trap];
X	trap_color(offset);
X    } else if ((offset = (glyph - GLYPH_OBJ_OFF)) >= 0) {	/* object */
X	ch = oc_syms[objects[offset].oc_class];
X	obj_color(offset);
X    } else if ((offset = (glyph - GLYPH_BODY_OFF)) >= 0) {	/* a corpse */
X	ch = oc_syms[objects[CORPSE].oc_class];
X	mon_color(offset);
X    } else if ((offset = (glyph - GLYPH_PET_OFF)) >= 0) {	/* a pet */
X	ch = monsyms[mons[offset].mlet];
X	pet_color(offset);
X    } else {							/* a monster */
X	ch = monsyms[mons[glyph].mlet];
X	mon_color(glyph);
X    }
X
X    /* Move the cursor. */
X    tty_curs(window, x,y);
X
X    if (ul_hack && ch == '_') {		/* non-destructive underscore */
X	(void) putchar((char) ' ');
X	backsp();
X    }
X
X#ifdef TEXTCOLOR
X    /* Turn off color if no color defined, or rogue level. */
X#  ifdef REINCARNATION
X    if (hilites[color] == NULL || Is_rogue_level(&u.uz))
X#  else
X    if (hilites[color] == NULL)
X#  endif
X	color = NO_COLOR;
X
X    if (color != ttyDisplay->color) {
X	if(ttyDisplay->color != NO_COLOR)
X	    xputs(HE);
X	ttyDisplay->color = color;
X	if(color != NO_COLOR)
X	    xputs(hilites[color]);
X    }
X#endif
X    g_putch(ch);		/* print the character */
X    wins[window]->curx++;	/* one character over */
X    ttyDisplay->curx++;		/* the real cursor moved too */
X}
X
Xvoid
Xtty_raw_print(str)
X    const char *str;
X{
X    if(ttyDisplay) ttyDisplay->rawprint++;
X#ifdef MICRO
X    msmsg("%s\n", str);
X#else
X    puts(str); (void) fflush(stdout);
X#endif
X}
X
Xvoid
Xtty_raw_print_bold(str)
X    const char *str;
X{
X    if(ttyDisplay) ttyDisplay->rawprint++;
X    xputs(HI);
X#ifdef MICRO
X    msmsg("%s", str);
X#else
X    (void) fputs(str, stdout);
X#endif
X    xputs(HE);
X#ifdef MICRO
X    msmsg("\n");
X#else
X    puts("");
X    (void) fflush(stdout);
X#endif
X}
X
Xint
Xtty_nhgetch()
X{
X    int i;
X#ifdef UNIX
X    /* kludge alert: Some Unix variants return funny values if getc()
X     * is called, interrupted, and then called again.  There
X     * is non-reentrant code in the internal _filbuf() routine, called by
X     * getc().
X     */
X    static volatile int nesting = 0;
X    char nestbuf;
X#endif
X
X    (void) fflush(stdout);
X    /* Note: if raw_print() and wait_synch() get called to report terminal
X     * initialization problems, then wins[] and ttyDisplay might not be
X     * available yet.  Such problems will probably be fatal before we get
X     * here, but validate those pointers just in case...
X     */
X    if (WIN_MESSAGE != WIN_ERR && wins[WIN_MESSAGE])
X	    wins[WIN_MESSAGE]->flags &= ~WIN_STOP;
X#ifdef UNIX
X    i = ((++nesting == 1) ? tgetch() :
X	 (read(fileno(stdin), (genericptr_t)&nestbuf,1) == 1 ? (int)nestbuf :
X								EOF));
X    --nesting;
X#else
X    i = tgetch();
X#endif
X    if (!i) i = '\033'; /* map NUL to ESC since nethack doesn't expect NUL */
X    if (ttyDisplay && ttyDisplay->toplin == 1)
X	ttyDisplay->toplin = 2;
X    return i;
X}
X
X/*
X * return a key, or 0, in which case a mouse button was pressed
X * mouse events should be returned as character postitions in the map window.
X * Since normal tty's don't have mice, just return a key.
X */
X/*ARGSUSED*/
Xint
Xtty_nh_poskey(x, y, mod)
X    int *x, *y, *mod;
X{
X    return tty_nhgetch();
X}
X
Xvoid
Xwin_tty_init()
X{
X    return;
X}
X
X/*wintty.c*/
END_OF_FILE
if test 36808 -ne `wc -c <'win/tty/wintty.c'`; then
    echo shar: \"'win/tty/wintty.c'\" unpacked with wrong size!
fi
# end of 'win/tty/wintty.c'
fi
echo shar: End of archive 46 \(of 108\).
cp /dev/null ark46isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \
21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \
41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 \
61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 \
81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 \
101 102 103 104 105 106 107 108 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 108 archives.
    echo "Now execute 'rebuild.sh'"
    rm -f ark10[0-8]isdone ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
