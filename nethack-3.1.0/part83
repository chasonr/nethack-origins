Path: uunet!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v16i091:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Part83/108
Message-ID: <4454@master.CNA.TEK.COM>
Date: 5 Feb 93 19:21:38 GMT
Sender: news@master.CNA.TEK.COM
Lines: 2245
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1642

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 16, Issue 91
Archive-name: nethack31/Part83
Supersedes: nethack3p9: Volume 10, Issue 46-102
Environment: Amiga, Atari, Mac, MS-DOS, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 83 (of 108)."
# Contents:  src/do_name.c src/mkobj.c sys/amiga/amirip.c
# Wrapped by billr@saab on Wed Jan 27 16:09:20 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'src/do_name.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/do_name.c'\"
else
echo shar: Extracting \"'src/do_name.c'\" \(17999 characters\)
sed "s/^X//" >'src/do_name.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)do_name.c	3.1	92/12/29	*/
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include "hack.h"
X
X#ifdef OVLB
X
Xstatic void FDECL(do_oname, (struct obj *));
X
Xvoid
Xgetpos(cc,force,goal)
Xcoord	*cc;
Xboolean force;
Xconst char *goal;
X{
X    register int cx, cy, i, c;
X    int sidx, tx, ty;
X    int lastc, lastx, lasty;
X    const char *sdp = flags.num_pad ? ndir : sdir;
X
X    if(flags.verbose) pline("(For instructions type a ?)");
X    cx = cc->x;
X    cy = cc->y;
X    lastc = -1;
X    lastx = lasty = 0;
X#ifdef CLIPPING
X    cliparound(cx, cy);
X#endif
X    curs(WIN_MAP, cx,cy);
X    flush_screen(0);
X    while((c = nh_poskey(&tx, &ty, &sidx)) != '.') {
X        if(c == '\033') {
X            cc->x = -10;
X	    clear_nhwindow(WIN_MESSAGE);
X            return;
X        }
X	if(c == 0) {
X	    /* a mouse click event, just assign and return */
X	    cx = tx;
X	    cy = ty;
X	    break;
X	}
X	for(i=0; i<8; i++)
X	    if (sdp[i] == c) {
X		if (1 <= cx + xdir[i] && cx + xdir[i] < COLNO)
X		    cx += xdir[i];
X		if (0 <= cy + ydir[i] && cy + ydir[i] < ROWNO)
X		    cy += ydir[i];
X		goto nxtc;
X	    } else if (sdp[i] == lowc((char)c)) {
X		cx += xdir[i]*8;
X		cy += ydir[i]*8;
X		if(cx < 1) cx = 1;
X		if(cx > COLNO-1) cx = COLNO-1;
X		if(cy < 0) cy = 0;
X		if(cy > ROWNO-1) cy = ROWNO-1;
X		goto nxtc;
X	    }
X
X	if(c == '?'){
X	    char sbuf[80];
X	    winid tmpwin = create_nhwindow(NHW_MENU);
X	    Sprintf(sbuf, "Use [%s] to move the cursor to %s.",
X		  flags.num_pad ? "2468" : "hjkl", goal);
X	    putstr(tmpwin, 0, sbuf);
X	    putstr(tmpwin, 0,
X		   "Use [HJKL] to move the cursor 8 units at a time.");
X	    putstr(tmpwin, 0, "Or enter a background symbol (ex. <).");
X	    putstr(tmpwin, 0, "Type a . when you are at the right place.");
X	    if(!force)
X		putstr(tmpwin, 0, "Type Space or Escape when you're done.");
X	    putstr(tmpwin, 0, "");
X	    display_nhwindow(tmpwin, TRUE);
X	    destroy_nhwindow(tmpwin);
X	} else {
X	    if (!index(quitchars, c)) {
X		for(sidx = 1; sidx < sizeof(showsyms); sidx++)
X		    if(defsyms[sidx].sym == c) {
X			/* sidx = cmap_to_glyph(sidx); */
X			if(sidx != lastc) {
X			    lasty = 0;
X			    lastx = 1;
X			}
X			lastc = sidx;
X		    loopback:
X			for (ty = lasty; ty < ROWNO; ty++) {
X			    for (tx = lastx; tx < COLNO; tx++) {
X				if ((IS_POOL(levl[tx][ty].typ) ||
X				     IS_FURNITURE(levl[tx][ty].typ)) &&
X	 defsyms[sidx].sym == defsyms[glyph_to_cmap(levl[tx][ty].glyph)].sym) {
X				    cx = tx;
X				    lastx = tx+1;
X				    cy = ty;
X				    lasty = ty;
X				    goto nxtc;
X				}
X			    }
X			    lastx = 1;
X			}
X			if(lasty != 0) {
X			    lasty = 0;
X			    lastx = 1;
X			    goto loopback;
X			}
X			pline("Can't find dungeon feature '%c'", c);
X			goto nxtc;
X		    }
X
X		pline("Unknown direction: '%s' (%s).",
X		      visctrl((char)c),
X		      force ?
X		      flags.num_pad ? "use 2468 or ." :
X		      "use hjkl or ." :
X		      "aborted");
X	    }
X	    if(force) goto nxtc;
X	    pline("Done.");
X	    cc->x = -1;
X	    cc->y = 0;
X	    return;
X	}
X    nxtc:	;
X#ifdef CLIPPING
X	cliparound(cx, cy);
X#endif
X	curs(WIN_MAP,cx,cy);
X	flush_screen(0);
X    }
X    cc->x = cx;
X    cc->y = cy;
X    return;
X}
X
Xstruct monst *
Xchristen_monst(mtmp, name)
Xstruct monst *mtmp;
Xconst char *name;
X{
X	register int lth,i;
X	register struct monst *mtmp2;
X
X	/* dogname and catname are 63-character arrays; the generic naming
X	 * function do_mname() below also cut names off at 63 characters */
X	lth = strlen(name)+1;
X	if(lth > 63){
X		lth = 63;
X	}
X	mtmp2 = newmonst(mtmp->mxlth + lth);
X	*mtmp2 = *mtmp;
X	for(i=0; i<mtmp->mxlth; i++)
X		((char *) mtmp2->mextra)[i] = ((char *) mtmp->mextra)[i];
X	mtmp2->mnamelth = lth;
X	(void)strncpy(NAME(mtmp2), name, lth);
X	NAME(mtmp2)[lth-1] = 0;
X	replmon(mtmp,mtmp2);
X	return(mtmp2);
X}
X
Xint
Xdo_mname()
X{
X	char buf[BUFSZ];
X	coord cc;
X	register int cx,cy;
X	register struct monst *mtmp;
X	register char *curr;
X	boolean blank;
X	char qbuf[QBUFSZ];
X
X	if (Hallucination) {
X		You("would never recognize it anyway.");
X		return 0;
X	}
X	cc.x = u.ux;
X	cc.y = u.uy;
X	getpos(&cc, FALSE, "the monster you want to name");
X	cx = cc.x;
X	cy = cc.y;
X	if(cx < 0) return(0);
X	if (cx == u.ux && cy == u.uy) {
X		pline("This %s creature is called %s and cannot be renamed.",
X		ACURR(A_CHA) > 14 ?
X		(flags.female ? "beautiful" : "handsome") :
X		"ugly",
X		plname);
X		return(0);
X	}
X	mtmp = m_at(cx, cy);
X	if (!mtmp || (!sensemon(mtmp) &&
X			(!cansee(cx,cy) || mtmp->mundetected
X			|| mtmp->m_ap_type == M_AP_FURNITURE
X			|| mtmp->m_ap_type == M_AP_OBJECT
X			|| (mtmp->minvis && !See_invisible)))) {
X		pline("I see no monster there.");
X		return(0);
X	}
X	Sprintf(qbuf, "What do you want to call %s?", x_monnam(mtmp, 0,
X		(char *)0, 1));
X	getlin(qbuf,buf);
X	clear_nhwindow(WIN_MESSAGE);
X	if(!*buf || *buf == '\033') return(0);
X
X	/* unnames monster if all spaces */
X	for (curr = buf, blank = 1; *curr; blank = (*curr++ == ' '));
X	if(blank) *buf = '\0';
X
X 	if(type_is_pname(mtmp->data))
X 	    pline("%s doesn't like being called names!", Monnam(mtmp));
X	else (void) christen_monst(mtmp, buf);
X	return(0);
X}
X
X/*
X * This routine changes the address of obj. Be careful not to call it
X * when there might be pointers around in unknown places. For now: only
X * when obj is in the inventory.
X */
Xstatic
Xvoid
Xdo_oname(obj)
Xregister struct obj *obj;
X{
X	char buf[BUFSZ], qbuf[QBUFSZ];
X	register char *curr;
X
X	Sprintf(qbuf, "What do you want to name %s?", doname(obj));
X	getlin(qbuf, buf);
X	clear_nhwindow(WIN_MESSAGE);
X	if(!*buf || *buf == '\033')	return;
X
X	/* strip trailing spaces; unnames item if all spaces */
X	for (curr = eos(buf); curr > buf; )
X		if (*--curr == ' ') *curr = '\0'; else break;
X
X	if(obj->oartifact)
X		pline("The artifact seems to resist the attempt.");
X	else if (restrict_name(obj, buf) || exist_artifact(obj->otyp, buf)) {
X		int n = rn2((int)strlen(buf));
X		register char c1, c2;
X
X		c1 = lowc(buf[n]);
X		do c2 = 'a' + rn2('z'-'a'); while (c1 == c2);
X		buf[n] = (buf[n] == c1) ? c2 : highc(c2);  /* keep same case */
X		pline("While engraving your %s slips.", body_part(HAND));
X		display_nhwindow(WIN_MESSAGE, FALSE);
X		You("engrave: \"%s\".",buf);
X		(void)oname(obj, buf, 1);
X	}
X	else
X		(void)oname(obj, buf, 1);
X}
X
Xstruct obj *
Xoname(obj, buf, ininv)
Xregister struct obj *obj;
Xconst char	*buf;
Xregister int ininv;
X{
X	register struct obj *otmp, *otmp2;
X	register int	lth;
X
X	lth = *buf ? strlen(buf)+1 : 0;
X	if(lth > 63){
X		lth = 63;
X	}
X	/* if already properly named */
X	if(lth == obj->onamelth && (!lth || !strcmp(ONAME(obj),buf)))
X		return obj;
X
X	/* If named artifact exists in the game, do not create another.
X	 * Also trying to create an artifact shouldn't de-artifact
X	 * it (e.g. Excalibur from prayer). In this case the object
X	 * will retain its current name. */
X	if (obj->oartifact || exist_artifact(obj->otyp, buf))
X		return obj;
X
X	otmp2 = newobj(lth);
X	*otmp2 = *obj;	/* the cobj pointer is copied to otmp2 */
X	otmp2->onamelth = lth;
X	artifact_exists(otmp2, buf, TRUE);
X
X#ifdef __GNUC__
X	/* Avoid an old compiler bug (always gave empty name otherwise). */
X	if (buf) (void)donull();
X#endif
X	if(lth) {
X		(void)strncpy(ONAME(otmp2), buf, lth);
X		ONAME(otmp2)[lth-1] = 0;
X	}
X	if (obj->owornmask) {
X		/* Note: dying by burning in Hell causes problems if you
X		 * try doing this when owornmask isn't set.
X		 */
X		setworn((struct obj *)0, obj->owornmask);
X		setworn(otmp2, otmp2->owornmask);
X	}
X
X	if (ininv) {
X		/* do freeinv(obj); etc. by hand in order to preserve
X		   the position of this object in the inventory */
X		if(obj == invent) invent = otmp2;
X		else for(otmp = invent; ; otmp = otmp->nobj){
X			if(!otmp)
X				panic("oname: cannot find obj.");
X			if(otmp->nobj == obj){
X				otmp->nobj = otmp2;
X				break;
X			}
X		}
X	}
X	/* obfree(obj, otmp2);	/* now unnecessary: no pointers on bill */
X	dealloc_obj(obj);	/* let us hope nobody else saved a pointer */
X	return otmp2;
X}
X
Xstatic const char NEARDATA callable[] = {
X	SCROLL_CLASS, POTION_CLASS, WAND_CLASS, RING_CLASS, AMULET_CLASS,
X	GEM_CLASS, SPBOOK_CLASS, ARMOR_CLASS, TOOL_CLASS, 0 };
X
Xint
Xddocall()
X{
X	register struct obj *obj;
X#ifdef REDO
X	char	ch;
X#endif
X	char allow_all[2];
X
X	switch(
X#ifdef REDO
X		ch = 
X#endif
X		ynq("Name an individual object?")) {
X	case 'q':
X		break;
X	case 'y':
X#ifdef REDO
X		savech(ch);
X#endif
X		allow_all[0] = ALL_CLASSES; allow_all[1] = '\0';
X		obj = getobj(allow_all, "name");
X		if(obj) do_oname(obj);
X		break;
X	default :
X#ifdef REDO
X		savech(ch);
X#endif
X		obj = getobj(callable, "call");
X		if (obj) {
X			if (!obj->dknown) {
X				You("would never recognize another one.");
X				return 0;
X			}
X			docall(obj);
X		}
X		break;
X	}
X	return 0;
X}
X
Xvoid
Xdocall(obj)
Xregister struct obj *obj;
X{
X	char buf[BUFSZ], qbuf[QBUFSZ];
X	struct obj otemp;
X	register char **str1;
X	register char *str;
X	boolean blank;
X
X	if (!obj->dknown) return; /* probably blind */
X	otemp = *obj;
X	otemp.quan = 1L;
X	otemp.onamelth = 0;
X	if (objects[otemp.otyp].oc_class == POTION_CLASS && otemp.corpsenm) {
X		/* kludge, meaning it's sink water */
X		Sprintf(qbuf,"Call a stream of %s fluid:",
X				OBJ_DESCR(objects[otemp.otyp]));
X	} else
X		Sprintf(qbuf, "Call %s:", an(xname(&otemp)));
X	getlin(qbuf, buf);
X	clear_nhwindow(WIN_MESSAGE);
X	if(!*buf || *buf == '\033')
X		return;
X
X	/* clear old name */
X	str1 = &(objects[obj->otyp].oc_uname);
X	if(*str1) free((genericptr_t)*str1);
X
X	/* uncalls item if all spaces */
X	for (str = buf, blank = 1; *str; blank = (*str++ == ' '));
X	if(blank) *buf = '\0';
X	if (!*buf) {
X		if (*str1)	/* had name, so possibly remove from disco[] */
X			undiscover_object(obj->otyp),  *str1 = NULL;
X	} else {
X		*str1 = strcpy((char *) alloc((unsigned)strlen(buf)+1), buf);
X		discover_object(obj->otyp, FALSE); /* possibly add to disco[] */
X	}
X}
X
X#endif /*OVLB*/
X#ifdef OVL0
X
Xstatic const char *ghostnames[] = {
X	/* these names should have length < PL_NSIZ */
X	/* Capitalize the names for aesthetics -dgk */
X	"Adri", "Andries", "Andreas", "Bert", "David", "Dirk", "Emile",
X	"Frans", "Fred", "Greg", "Hether", "Jay", "John", "Jon", "Karnov",
X	"Kay", "Kenny", "Kevin", "Maud", "Michiel", "Mike", "Peter", "Robert",
X	"Ron", "Tom", "Wilmar", "Nick Danger", "Phoenix", "Jiro", "Mizue",
X	"Stephan", "Lance Braccus", "Shadowhawk"
X};
X
X/* Monster naming functions:
X * x_monnam is the generic monster-naming function.
X * mon_nam: the rust monster  it  the invisible orc  Fido
X * l_monnam:  rust monster    it  invisible orc      dog called fido
X * Monnam:    The rust monster    It  The invisible orc  Fido
X * Adjmonnam: The poor rust monster  It   The poor invisible orc  The poor Fido
X * Amonnam:   A rust monster      It  An invisible orc   Fido
X * a_monnam:  a rust monster      it  an invisible orc   Fido
X */
X
Xchar *
Xx_monnam(mtmp, article, adjective, called)
Xregister struct monst *mtmp;
X/* Articles:
X * 0: "the" in front of everything except names and "it"
X * 1: "the" in front of everything except "it"; looks bad for names unless you
X *    are also using an adjective.
X * 2: "a" in front of everything except "it".
X * 3: no article at all.
X */
Xint article, called;
Xconst char *adjective;
X{
X#ifdef LINT	/* static char buf[BUFSZ]; */
X	char buf[BUFSZ];
X#else
X	static char buf[BUFSZ];
X#endif
X	char *name = (mtmp->mnamelth && !Hallucination && !mtmp->isshk) ?
X	                          NAME(mtmp) : 0;
X	int force_the = (!Hallucination && mtmp->data ==
X		&mons[PM_WIZARD_OF_YENDOR]);
X
X	buf[0] = '\0';
X	if(mtmp->ispriest || mtmp->isminion) {
X		name = priestname(mtmp);
X		if (article == 3 && !strncmp(name, "the ", 4)) name += 4;
X		return name;
X	}
X	if(!canseemon(mtmp) && !sensemon(mtmp) &&
X					!(u.uswallow && mtmp == u.ustuck)) {
X	    if(!mtmp->wormno || (mtmp != m_at(bhitpos.x, bhitpos.y)) ||
X	       !(cansee(bhitpos.x, bhitpos.y) && mon_visible(mtmp))) {
X		Strcpy(buf, "it");
X		return (buf);
X	    }
X	}
X	if (mtmp->isshk) {
X		Strcpy(buf, shkname(mtmp));
X		if (mtmp->data == &mons[PM_SHOPKEEPER] && !mtmp->minvis)
X		    return(buf);
X		/* For normal shopkeepers, just 'Asidonhopo'.
X		 * For unusual ones, 'Asidonhopo the invisible shopkeeper'
X		 * or 'Asidonhopo the blue dragon'.
X		 */
X		Strcat(buf, " ");
X	}
X	if (force_the ||
X	       ((article == 1 || ((!name || called) && article == 0)) &&
X		   (Hallucination || !type_is_pname(mtmp->data))))
X		Strcat(buf, "the ");
X	if (adjective) {
X		Strcat(buf, adjective);
X		Strcat(buf, " ");
X	}
X	if (mtmp->minvis)
X		Strcat(buf, "invisible ");
X	if (name && !called) {
X		Strcat(buf, name);
X		goto bot_nam;
X	}
X	if (mtmp->data == &mons[PM_GHOST] && !Hallucination) {
X		register const char *gn = (const char *) mtmp->mextra;
X		if(!*gn) {		/* might also look in scorefile */
X		    gn = ghostnames[rn2(SIZE(ghostnames))];
X		    Strcpy((char *) mtmp->mextra, !rn2(5) ? 
X			                   (const char *)plname : gn);
X		}
X		Sprintf(buf, "%s ghost", s_suffix((char *) mtmp->mextra));
X	} else {
X	        if(Hallucination)
X		    Strcat(buf, rndmonnam());
X		else {
X		    if(is_mplayer(mtmp->data) && !In_endgame(&u.uz)) { 
X		        char pbuf[BUFSZ];
X	                Strcpy(pbuf, rank_of((unsigned)mtmp->m_lev,
X		                              highc(mtmp->data->mname[0]), 
X			                      (boolean)mtmp->female));
X			Strcat(buf, lcase(pbuf));
X		    } else
X		        Strcat(buf, mtmp->data->mname);
X		}
X	}
X	if(name) {
X		Strcat(buf, " called ");
X		Strcat(buf, NAME(mtmp));
X	}
Xbot_nam:
X	if (article == 2 && !force_the && (!name || called) &&
X	    (Hallucination || !type_is_pname(mtmp->data)))
X		return an(buf);
X	else
X		return(buf);
X}
X
X#endif /* OVL0 */
X#ifdef OVLB
X
Xchar *
Xl_monnam(mtmp)
Xregister struct monst *mtmp;
X{
X	return(x_monnam(mtmp, 3, (char *)0, 1));
X}
X
X#endif /* OVLB */
X#ifdef OVL0
X
Xchar *
Xmon_nam(mtmp)
Xregister struct monst *mtmp;
X{
X	return(x_monnam(mtmp, 0, (char *)0, 0));
X}
X
Xchar *
XMonnam(mtmp)
Xregister struct monst *mtmp;
X{
X	register char *bp = mon_nam(mtmp);
X
X	*bp = highc(*bp);
X	return(bp);
X}
X
X#endif /* OVL0 */
X#ifdef OVLB
X
Xchar *
XAdjmonnam(mtmp, adj)
Xregister struct monst *mtmp;
Xregister const char *adj;
X{
X	register char *bp = x_monnam(mtmp,1,adj,0);
X
X	*bp = highc(*bp);
X	return(bp);
X}
X
Xchar *
Xa_monnam(mtmp)
Xregister struct monst *mtmp;
X{
X	return x_monnam(mtmp, 2, (char *)0, 0);
X}
X
Xchar *
XAmonnam(mtmp)
Xregister struct monst *mtmp;
X{
X	register char *bp = a_monnam(mtmp);
X
X	*bp = highc(*bp);
X	return(bp);
X}
X
Xstatic const char NEARDATA *bogusmons[] = {
X	"jumbo shrimp", "giant pigmy", "gnu", "killer penguin", 
X	"giant cockroach", "giant slug", "maggot", "pterodactyl",
X	"tyrannosaurus rex", "basilisk", "beholder", "nightmare",
X	"efreeti", "marid", "rot grub", "bookworm", "doppelganger",
X	"shadow", "hologram", "jester", "attorney", "sleazoid",
X	"killer tomato", "amazon", "robot", "battlemech",
X	"rhinovirus", "harpy", "lion-dog", "rat-ant",
X						/* misc. */
X	"grue", "Christmas-tree monster", "luck sucker", "paskald",
X	"brogmoid", "dornbeast",		/* Quendor (Zork, &c.) */
X	"Ancient Multi-Hued Dragon", "Evil Iggy",
X						/* Moria */
X	"emu", "kestrel", "xeroc", "venus flytrap",
X						/* Rogue */
X	"creeping coins",			/* Wizardry */
X	"hydra", "siren",			/* Greek legend */
X	"killer bunny",				/* Monty Python */
X	"rodent of unusual size",		/* The Princess Bride */
X	"Smokey the bear",	/* "Only you can prevent forest fires!" */
X	"Luggage",				/* Discworld */
X	"Ent", 					/* Lord of the Rings */
X	"tangle tree", "nickelpede", "wiggle",	/* Xanth */
X	"white rabbit", "snark",		/* Lewis Carroll */
X	"pushmi-pullyu",			/* Dr. Doolittle */
X	"smurf",				/* The Smurfs */
X	"tribble", "Klingon", "Borg",		/* Star Trek */
X	"Ewok", 				/* Star Wars */
X	"Totoro",				/* Tonari no Totoro */
X	"ohmu", 				/* Nausicaa */
X	"Godzilla", "King Kong",		/* monster movies */
X	"earthquake beast",			/* old L of SH */
X	"Invid",				/* Robotech */
X	"Terminator",				/* The Terminator */
X	"boomer",				/* Bubblegum Crisis */
X	"Dalek",				/* Dr. Who ("Exterminate!") */
X	"microscopic space fleet", "Ravenous Bugblatter Beast of Traal",
X						/* HGttG */
X	"teenage mutant ninja turtle",		/* TMNT */
X	"samurai rabbit",			/* Usagi Yojimbo */
X	"aardvark",				/* Cerebus */
X	"Audrey II",				/* Little Shop of Horrors */
X	"witch doctor", "one-eyed one-horned flying purple people eater"
X						/* 50's rock 'n' roll */
X};
X
Xconst char *
Xrndmonnam() {  /* Random name of monster type, if hallucinating */
X	int name;
X
X	do {
X		name = rn2(PM_ARCHEOLOGIST + SIZE(bogusmons));
X		/* archeologist: 1 past last valid monster */
X	} while(name < PM_ARCHEOLOGIST &&
X	    (type_is_pname(&mons[name]) || (mons[name].geno & G_NOGEN)));
X	if (name >= PM_ARCHEOLOGIST) return bogusmons[name-PM_ARCHEOLOGIST];
X	return(mons[name].mname);
X}
X
X#ifdef OVL2
X
Xstatic const char NEARDATA *hcolors[] = {
X	"ultraviolet", "infrared", "bluish-orange",
X	"reddish-green", "dark white", "light black", "sky blue-pink",
X	"salty", "sweet", "sour", "bitter",
X	"striped", "spiral", "swirly", "plaid", "checkered", "argyle",
X	"paisley", "blotchy", "guernsey-spotted", "polka-dotted",
X	"square", "round", "triangular",
X	"cabernet", "sangria", "fuchsia", "wisteria",
X	"lemon-lime", "strawberry-banana", "peppermint",
X	"romantic", "incandescent"
X};
X
Xconst char *
Xhcolor()
X{
X	return hcolors[rn2(SIZE(hcolors))];
X}
X#endif /* OVL2 */
X
Xconst char *pronoun_pairs[][2] = {
X	{"him", "her"}, {"Him", "Her"}, {"his", "her"}, {"His", "Her"},
X	{"he", "she"}, {"He", "She"},
X	{0, 0}
X};
X
Xchar *
Xself_pronoun(str, pronoun)
Xconst char *str;
Xconst char *pronoun;
X{
X	static char NEARDATA buf[BUFSZ];
X	register int i;
X
X	for(i=0; pronoun_pairs[i][0]; i++) {
X		if(!strncmp(pronoun, pronoun_pairs[i][0], 3)) {
X			Sprintf(buf, str, pronoun_pairs[i][flags.female]);
X			return buf;
X		}
X	}
X	impossible("never heard of pronoun %s?", pronoun);
X	Sprintf(buf, str, pronoun_pairs[i][0]);
X	return buf;
X}
X
X#ifdef REINCARNATION
Xconst char *
Xroguename() /* Name of a Rogue player */
X{
X	char *i, *opts;
X
X	if(opts = getenv("ROGUEOPTS")) {
X		for(i=opts; *i; i++)
X			if (!strncmp("name=",i,5)) {
X				char *j;
X				if (j=index(i+5,','))
X					*j = (char)0;
X				return i+5;
X			}
X	}
X	return rn2(3) ? (rn2(2) ? "Michael Toy" : "Kenneth Arnold")
X		: "Glenn Wichman";
X}
X#endif
X
X#endif /* OVLB */
X
X/*do_name.c*/
END_OF_FILE
if test 17999 -ne `wc -c <'src/do_name.c'`; then
    echo shar: \"'src/do_name.c'\" unpacked with wrong size!
fi
# end of 'src/do_name.c'
fi
if test -f 'src/mkobj.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/mkobj.c'\"
else
echo shar: Extracting \"'src/mkobj.c'\" \(18051 characters\)
sed "s/^X//" >'src/mkobj.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)mkobj.c	3.1	93/01/17	*/
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include "hack.h"
X#include "artifact.h"
X#include "prop.h"
X
XSTATIC_DCL void FDECL(mkbox_cnts,(struct obj *));
X
Xstruct icp {
X    int  iprob; /* probability of an item type */
X    char ilet;	/* item class */
X};
X
X#ifdef OVL1
X
Xconst struct icp mkobjprobs[] = {
X{10, WEAPON_CLASS},
X{10, ARMOR_CLASS},
X{20, FOOD_CLASS},
X{ 8, TOOL_CLASS},
X{ 8, GEM_CLASS},
X{16, POTION_CLASS},
X{16, SCROLL_CLASS},
X{ 4, SPBOOK_CLASS},
X{ 4, WAND_CLASS},
X{ 3, RING_CLASS},
X{ 1, AMULET_CLASS}
X};
X
Xconst struct icp boxiprobs[] = {
X{18, GEM_CLASS},
X{15, FOOD_CLASS},
X{18, POTION_CLASS},
X{18, SCROLL_CLASS},
X{12, SPBOOK_CLASS},
X{ 7, GOLD_CLASS},
X{ 6, WAND_CLASS},
X{ 5, RING_CLASS},
X{ 1, AMULET_CLASS}
X};
X
X#ifdef REINCARNATION
Xconst struct icp rogueprobs[] = {
X{12, WEAPON_CLASS},
X{12, ARMOR_CLASS},
X{22, FOOD_CLASS},
X{22, POTION_CLASS},
X{22, SCROLL_CLASS},
X{ 5, WAND_CLASS},
X{ 5, RING_CLASS}
X};
X#endif
X
Xconst struct icp hellprobs[] = {
X{20, WEAPON_CLASS},
X{20, ARMOR_CLASS},
X{16, FOOD_CLASS},
X{12, TOOL_CLASS},
X{10, GEM_CLASS},
X{ 1, POTION_CLASS},
X{ 1, SCROLL_CLASS},
X{ 8, WAND_CLASS},
X{ 8, RING_CLASS},
X{ 4, AMULET_CLASS}
X};
X
Xstatic int NEARDATA mksx=0, NEARDATA mksy=0;
X
Xstruct obj *
Xmkobj_at(let,x,y, artif)
Xchar let;
Xint x,y;
Xboolean artif;
X{
X	register struct obj *otmp;
X
X	mksx = x; mksy = y;
X	/* We need to know the X, Y coordinates while creating the object,
X	 * to insure shop boxes are empty.
X	 * Yes, this is a horrible kludge...
X	 */
X	otmp = mkobj(let,artif);
X	otmp->nobj = fobj;
X	fobj = otmp;
X	place_object(otmp, x, y);
X	mksx = mksy = 0;
X	return(otmp);
X}
X
Xstruct obj *
Xmksobj_at(otyp,x,y,init)
Xint otyp,x,y;
Xboolean init;
X{
X	register struct obj *otmp;
X
X	mksx = x; mksy = y;
X	otmp = mksobj(otyp,init,TRUE);
X	otmp->nobj = fobj;
X	place_object(otmp, x, y);
X	mksx = mksy = 0;
X	return((fobj = otmp));
X}
X
Xstruct obj *
Xmkobj(let, artif)
Xchar let;
Xboolean artif;
X{
X	register int tprob, i, prob = rnd(1000);
X
X	if(let == RANDOM_CLASS) {
X		const struct icp *iprobs =
X#ifdef REINCARNATION
X				    (Is_rogue_level(&u.uz)) ?
X				    (const struct icp *)rogueprobs :
X#endif
X				    Inhell ? (const struct icp *)hellprobs :
X				    (const struct icp *)mkobjprobs;
X
X		for(tprob = rnd(100);
X		    (tprob -= iprobs->iprob) > 0;
X		    iprobs++);
X		let = iprobs->ilet;
X	}
X
X	i = bases[letindex(let)];
X	while((prob -= objects[i].oc_prob) > 0) i++;
X
X	if(objects[i].oc_class != let || !OBJ_NAME(objects[i]))
X		panic("probtype error, let=%c i=%d", let, i);
X
X	return(mksobj(i, TRUE, artif));
X}
X
XSTATIC_OVL void
Xmkbox_cnts(box)
X/* Note: does not check to see if it overloaded the box capacity; usually
X * possible only with corpses in ice boxes.
X */
Xstruct obj *box;
X{
X	register int n;
X	register struct obj *otmp, *gold = 0;
X
X	box->cobj = (struct obj *) 0;
X
X	switch(box->otyp) {
X		case ICE_BOX:		n = 20; break;
X		case CHEST:		n = 5; break;
X		case LARGE_BOX:		n = 3; break;
X		case SACK:
X		case OILSKIN_SACK:
X		case BAG_OF_HOLDING:	n = 1; break;
X		default:		n = 0; break;
X	}
X
X	for (n = rn2(n+1); n > 0; n--) {
X	    if (box->otyp == ICE_BOX) {
X		if (!(otmp = mksobj(CORPSE, TRUE, TRUE))) continue;
X		/* Note: setting age to 0 is correct.  Age has a different
X		 * from usual meaning for objects stored in ice boxes. -KAA
X		 */
X		otmp->age = 0L;
X	    } else {
X		register int tprob;
X		const struct icp *iprobs = boxiprobs;
X
X		for (tprob = rnd(100); (tprob -= iprobs->iprob) > 0; iprobs++)
X		    ;
X		if (!(otmp = mkobj(iprobs->ilet, TRUE))) continue;
X
X		/* handle a couple of special cases */
X		if (otmp->otyp == GOLD_PIECE) {
X		    /* 2.5 x level's usual amount; weight adjusted below */
X		    otmp->quan = (long)(rnd(level_difficulty()+2) * rnd(75));
X		    if (gold) {			/* gold already in this box */
X			gold->quan += otmp->quan;	/* merge */
X			dealloc_obj(otmp);	/* note: not yet in any chain */
X			continue;
X		    } else {
X			gold = otmp;		/* remember this object */
X		    }
X		} else while (otmp->otyp == ROCK) {
X		    otmp->otyp = rnd_class(DILITHIUM_CRYSTAL, LOADSTONE);
X		    if (otmp->quan > 2L) otmp->quan = 1L;
X		    otmp->owt = weight(otmp);
X		}
X		if (box->otyp == BAG_OF_HOLDING) {
X		    if (Is_mbag(otmp)) {
X			otmp->otyp = SACK;
X			otmp->spe = 0;
X			otmp->owt = weight(otmp);
X		    } else while (otmp->otyp == WAN_CANCELLATION)
X			    otmp->otyp = rnd_class(WAN_LIGHT, WAN_LIGHTNING);
X		}
X	    }
X	    otmp->nobj = box->cobj;
X	    box->cobj = otmp;
X	}
X	if (gold) gold->owt = weight(gold);	/* quantity was diddled */
X	return;
X}
X
Xint
Xrndmonnum()	/* select a random, common monster type */
X{
X	register struct permonst *ptr;
X	register int	i;
X
X	/* Plan A: get a level-appropriate common monster */
X	ptr = rndmonst();
X	if (ptr) return(monsndx(ptr));
X
X	/* Plan B: get any common monster */
X	do {
X	    ptr = &mons[(i = rn2(NUMMONS))];
X	} while((ptr->geno & G_NOGEN) || (!Inhell && (ptr->geno & G_HELL)));
X
X	return(i);
X}
X
X#endif /* OVL1 */
X#ifdef OVLB
Xconst char dknowns[] = { WAND_CLASS, RING_CLASS, POTION_CLASS, SCROLL_CLASS,
X			 GEM_CLASS, SPBOOK_CLASS, WEAPON_CLASS, 0};
X
X/*ARGSUSED*/
Xstruct obj *
Xmksobj(otyp, init, artif)
Xint otyp;
Xboolean init;
Xboolean artif;
X{
X	int tryct;
X	struct obj *otmp;
X	char let = objects[otyp].oc_class;
X
X	otmp = newobj(0);
X	*otmp = zeroobj;
X	otmp->age = monstermoves;
X	otmp->o_id = flags.ident++;
X	otmp->quan = 1L;
X	otmp->oclass = let;
X	otmp->otyp = otyp;
X	otmp->dknown = index(dknowns, let) ? 0 : 1;
X	if (!objects[otmp->otyp].oc_uses_known)
X		otmp->known = 1;
X	if (init) switch (let) {
X	case WEAPON_CLASS:
X		otmp->quan = (otmp->otyp <= SHURIKEN) ? (long) rn1(6,6) : 1L;
X		if(!rn2(11)) {
X			otmp->spe = rne(3);
X			otmp->blessed = rn2(2);
X		} else if(!rn2(10)) {
X			curse(otmp);
X			otmp->spe = -rne(3);
X		} else	blessorcurse(otmp, 10);
X
X		if (artif && !rn2(20))
X		    otmp = mk_artifact(otmp, (aligntyp)A_NONE);
X		break;
X	case FOOD_CLASS:
X	    otmp->oeaten = 0;
X	    switch(otmp->otyp) {
X		case CORPSE:
X		    /* overridden by mkcorpstat() */
X		    do otmp->corpsenm = rndmonnum();
X		    while (mons[otmp->corpsenm].geno & G_NOCORPSE);
X		    break;
X		case EGG:
X		    if(!rn2(3)) {		/* "live" eggs */
X			register struct permonst *ptr;
X			for(tryct = 0;
X			    (!(ptr = rndmonst()) ||
X			    (!lays_eggs(ptr) && ptr != &mons[PM_KILLER_BEE])) &&
X				tryct < 100;
X			    tryct++);
X			if(tryct < 100)	otmp->corpsenm = monsndx(ptr);
X			else		otmp->corpsenm = -1; /* empty */
X		    } else		otmp->corpsenm = -1; /* empty */
X		    break;
X		case TIN:
X		    if(!rn2(6)) {
X			otmp->spe = 1;		/* spinach */
X			otmp->corpsenm = -1;
X		    } else do {
X			otmp->corpsenm = rndmonnum();
X		    } while (mons[otmp->corpsenm].geno & G_NOCORPSE);
X		    blessorcurse(otmp, 10);
X		    break;
X#ifdef TUTTI_FRUTTI
X		case SLIME_MOLD:
X		    otmp->spe = current_fruit;
X		    break;
X#endif
X	    }
X	    if (otmp->otyp == CORPSE) break;
X	    /* fall into next case */
X
X	case GEM_CLASS:
X		if (otmp->otyp == LOADSTONE) curse(otmp);
X		else if (otmp->otyp == ROCK) otmp->quan = (long) rn1(6,6);
X		else if (otmp->otyp != LUCKSTONE && !rn2(6)) otmp->quan = 2L;
X		else otmp->quan = 1L;
X		break;
X	case TOOL_CLASS:
X	    switch(otmp->otyp) {
X		case TALLOW_CANDLE:
X		case WAX_CANDLE:	otmp->spe = 1;
X					otmp->age = 20L * /* 400 or 200 */
X					      (long)objects[otmp->otyp].oc_cost;
X					otmp->lamplit = 0;
X					otmp->quan = 1L +
X					      (long)(rn2(2) ? rn2(7) : 0);
X					blessorcurse(otmp, 5);
X					break;
X		case BRASS_LANTERN:
X		case OIL_LAMP:		otmp->spe = 1;
X					otmp->age = (long) rn1(500,1000);
X					otmp->lamplit = 0;
X					blessorcurse(otmp, 5);
X					break;
X		case MAGIC_LAMP:	otmp->spe = 1;
X					otmp->lamplit = 0;
X					blessorcurse(otmp, 2);
X					break;
X		case CHEST:
X		case LARGE_BOX:		otmp->olocked = !!(rn2(5));
X					otmp->otrapped = !(rn2(10));
X		case ICE_BOX:
X		case SACK:
X		case OILSKIN_SACK:
X		case BAG_OF_HOLDING:	mkbox_cnts(otmp);
X					break;
X		case MAGIC_MARKER:	otmp->spe = rn1(70,30);
X					break;
X		case CAN_OF_GREASE:	otmp->spe = rnd(25);
X					blessorcurse(otmp, 10);
X					break;
X		case CRYSTAL_BALL:	otmp->spe = rnd(5);
X					blessorcurse(otmp, 2);
X					break;
X		case HORN_OF_PLENTY:
X		case BAG_OF_TRICKS:	otmp->spe = rnd(20);
X					break;
X		case FIGURINE:	{	int tryct2 = 0;
X					do
X					    otmp->corpsenm = rndmonnum();
X					while(is_human(&mons[otmp->corpsenm])
X						&& tryct2++ < 30);
X					blessorcurse(otmp, 4);
X					break;
X				}
X		case BELL_OF_OPENING:   otmp->spe = 3;
X					break;
X		case MAGIC_FLUTE:
X		case MAGIC_HARP:
X		case FROST_HORN:
X		case FIRE_HORN:
X		case DRUM_OF_EARTHQUAKE:
X					otmp->spe = rn1(5,4);
X					break;
X	    }
X	    break;
X	case AMULET_CLASS:
X		if(rn2(10) && (otmp->otyp == AMULET_OF_STRANGULATION ||
X		   otmp->otyp == AMULET_OF_CHANGE ||
X		   otmp->otyp == AMULET_OF_RESTFUL_SLEEP)) {
X			curse(otmp);
X		} else	blessorcurse(otmp, 10);
X	case VENOM_CLASS:
X	case CHAIN_CLASS:
X	case BALL_CLASS:
X		break;
X	case POTION_CLASS:
X	case SCROLL_CLASS:
X#ifdef MAIL
X		if (otmp->otyp != SCR_MAIL)
X#endif
X			blessorcurse(otmp, 4);
X		break;
X	case SPBOOK_CLASS:
X		blessorcurse(otmp, 17);
X		break;
X	case ARMOR_CLASS:
X		if(rn2(10) && (otmp->otyp == FUMBLE_BOOTS ||
X		   otmp->otyp == LEVITATION_BOOTS ||
X		   otmp->otyp == HELM_OF_OPPOSITE_ALIGNMENT ||
X		   otmp->otyp == GAUNTLETS_OF_FUMBLING ||
X		   !rn2(11))) {
X			curse(otmp);
X			otmp->spe = -rne(3);
X		} else if(!rn2(10)) {
X			otmp->blessed = rn2(2);
X			otmp->spe = rne(3);
X		} else	blessorcurse(otmp, 10);
X		break;
X	case WAND_CLASS:
X		if(otmp->otyp == WAN_WISHING) otmp->spe = rnd(3); else
X		otmp->spe = rn1(5,
X			(objects[otmp->otyp].oc_dir == NODIR) ? 11 : 4);
X		blessorcurse(otmp, 17);
X		otmp->recharged = 0; /* used to control recharging */
X		break;
X	case RING_CLASS:
X		if(objects[otmp->otyp].oc_charged) {
X		    blessorcurse(otmp, 3);
X		    if(rn2(10)) {
X			if(rn2(10) && bcsign(otmp))
X			    otmp->spe = bcsign(otmp) * rne(3);
X			else otmp->spe = rn2(2) ? rne(3) : -rne(3);
X		    }
X		    /* make useless +0 rings much less common */
X		    if (otmp->spe == 0) otmp->spe = rn2(4) - rn2(3);
X		    /* negative rings are usually cursed */
X		    if (otmp->spe < 0 && rn2(5)) curse(otmp);
X		} else if(rn2(10) && (otmp->otyp == RIN_TELEPORTATION ||
X#ifdef POLYSELF
X			  otmp->otyp == RIN_POLYMORPH ||
X#endif
X			  otmp->otyp == RIN_AGGRAVATE_MONSTER ||
X			  otmp->otyp == RIN_HUNGER || !rn2(9))) {
X			curse(otmp);
X		}
X		break;
X	case ROCK_CLASS:
X		switch (otmp->otyp) {
X		    case STATUE:
X			if (rn2(level_difficulty()/2 + 10) > 10) {
X				struct obj *book;
X				book = mkobj(SPBOOK_CLASS,FALSE);
X				otmp->cobj = book;
X			}
X			/* overridden by mkcorpstat() */
X			otmp->corpsenm = rndmonnum();
X		}
X		break;
X	case GOLD_CLASS:
X		break;	/* do nothing */
X	default:
X		impossible("impossible mkobj %d, sym '%c'.", otmp->otyp, objects[otmp->otyp].oc_class);
X		return (struct obj *)0;
X	}
X	/* unique objects may have an associated artifact entry */
X	if (objects[otyp].oc_unique && !otmp->oartifact)
X	    otmp = mk_artifact(otmp, (aligntyp)A_NONE);
X	otmp->owt = weight(otmp);
X	return(otmp);
X}
X
Xvoid
Xbless(otmp)
Xregister struct obj *otmp;
X{
X	otmp->cursed = 0;
X	otmp->blessed = 1;
X	if (otmp->otyp == LUCKSTONE
X	    || (otmp->oartifact && spec_ability(otmp, SPFX_LUCK))) {
X	    int luckbon = stone_luck(TRUE);
X	    if(!luckbon && !carrying(LUCKSTONE)) u.moreluck = 0;
X	    else if (luckbon >= 0) u.moreluck = LUCKADD;
X	    else u.moreluck = -LUCKADD;
X	} else if (otmp->otyp == BAG_OF_HOLDING)
X	    otmp->owt = weight(otmp);
X	return;
X}
X
Xvoid
Xunbless(otmp)
Xregister struct obj *otmp;
X{
X	otmp->blessed = 0;
X	if (otmp->otyp == LUCKSTONE
X	    || (otmp->oartifact && spec_ability(otmp, SPFX_LUCK))) {
X	    int luckbon = stone_luck(TRUE);
X	    if (!luckbon && !carrying(LUCKSTONE)) u.moreluck = 0;
X	    else if (luckbon >= 0) u.moreluck = LUCKADD;
X	    else u.moreluck = -LUCKADD;
X	} else if (otmp->otyp == BAG_OF_HOLDING)
X	    otmp->owt = weight(otmp);
X}
X
Xvoid
Xcurse(otmp)
Xregister struct obj *otmp;
X{
X	otmp->blessed = 0;
X	otmp->cursed = 1;
X	if (otmp->otyp == LUCKSTONE
X	    || (otmp->oartifact && spec_ability(otmp, SPFX_LUCK))) {
X	    int luckbon = stone_luck(TRUE);
X	    if (!luckbon && !carrying(LUCKSTONE)) u.moreluck = 0;
X	    else if (luckbon >= 0) u.moreluck = LUCKADD;
X	    else u.moreluck = -LUCKADD;
X	} else if (otmp->otyp == BAG_OF_HOLDING)
X	    otmp->owt = weight(otmp);
X	return;
X}
X
Xvoid
Xuncurse(otmp)
Xregister struct obj *otmp;
X{
X	otmp->cursed = 0;
X	if (otmp->otyp == LUCKSTONE
X	    || (otmp->oartifact && spec_ability(otmp, SPFX_LUCK))) {
X	    int luckbon = stone_luck(TRUE);
X	    if (!luckbon && !carrying(LUCKSTONE)) u.moreluck = 0;
X	    else if (luckbon >= 0) u.moreluck = LUCKADD;
X	    else u.moreluck = -LUCKADD;
X	} else if (otmp->otyp == BAG_OF_HOLDING)
X		otmp->owt = weight(otmp);
X}
X
X#endif /* OVLB */
X#ifdef OVL1
Xvoid
Xblessorcurse(otmp, chance)
Xregister struct obj *otmp;
Xregister int chance;
X{
X	if(otmp->blessed || otmp->cursed) return;
X
X	if(!rn2(chance))
X	    if(!rn2(2)) {
X		curse(otmp);
X	    } else {
X		bless(otmp);
X	    }
X	return;
X}
X
X#endif /* OVL1 */
X#ifdef OVLB
X
Xint
Xbcsign(otmp)
Xregister struct obj *otmp;
X{
X	return(!!otmp->blessed - !!otmp->cursed);
X}
X
X#endif /* OVLB */
X#ifdef OVL0
X
X/*
X *  Calculate the weight of the given object.  This will recursively follow
X *  and calculate the weight of any containers.
X *
X *  Note:  It is possible to end up with an incorrect weight if some part
X *	   of the code messes with a contained object and doesn't update the
X *	   container's weight.
X */
Xint
Xweight(obj)
Xregister struct obj *obj;
X{
X	int wt = objects[obj->otyp].oc_weight;
X
X	if (Is_container(obj) || obj->otyp == STATUE) {
X		struct obj *contents;
X		register int cwt = 0;
X
X		if (obj->otyp == STATUE && obj->corpsenm > -1)
X		    wt = (int)obj->quan *
X			 ((int)mons[obj->corpsenm].cwt * 3 / 2);
X
X		for(contents=obj->cobj; contents; contents=contents->nobj)
X			cwt += weight(contents);
X		/*
X		 *  The weight of bags of holding is calculated as the weight
X		 *  of the bag plus the weight of the bag's contents modified
X		 *  as follows:
X		 *
X		 *	Bag status	Weight of contents
X		 *	----------	------------------
X		 *	cursed			2x
X		 *	blessed			x/4 + 1
X		 *	otherwise		x/2 + 1
X		 *
X		 *  The macro DELTA_CWT in pickup.c also implements these
X		 *  weight equations.
X		 *
X		 *  Note:  The above checks are performed in the given order.
X		 *	   this means that if an object is both blessed and
X		 *	   cursed (not supposed to happen), it will be treated
X		 *	   as cursed.
X		 */
X		if (obj->otyp == BAG_OF_HOLDING)
X		    cwt = obj->cursed ? (cwt * 2) :
X					(1 + (cwt / (obj->blessed ? 4 : 2)));
X
X		return wt + cwt;
X	}
X	if (obj->otyp == CORPSE && obj->corpsenm > -1)
X		return (int)obj->quan * mons[obj->corpsenm].cwt;
X	else if (obj->otyp == GOLD_PIECE)
X		return (int)((obj->quan + 500L) / 1000L);
X	return(wt ? wt*(int)obj->quan : ((int)obj->quan + 1)>>1);
X}
X
X#endif /* OVL0 */
X#ifdef OVLB
X
Xvoid
Xmkgold(amount, x, y)
Xlong amount;
Xint x, y;
X{
X    register struct obj *gold = g_at(x,y);
X
X    if (amount <= 0L) amount = (long)(1 + rnd(level_difficulty()+2) * rnd(30));
X    if (gold) {
X	gold->quan += amount;
X    } else {
X	gold = mksobj_at(GOLD_PIECE,x,y,TRUE);
X	gold->quan = amount;
X    }
X    gold->owt = weight(gold);
X}
X
X#endif /* OVLB */
X#ifdef OVL1
Xstruct obj *
Xmkcorpstat(objtype, ptr, x, y, init)
Xint objtype;	/* CORPSE or STATUE */
Xregister struct permonst *ptr;
Xint x, y;
Xboolean init;
X{
X	register struct obj *otmp;
X
X	if(objtype != CORPSE && objtype != STATUE)
X		impossible("making corpstat type %d", objtype);
X	otmp = mksobj_at(objtype, x, y, init);
X	if(otmp)  {
X		if(ptr)	otmp->corpsenm = monsndx(ptr);
X		else	otmp->corpsenm = rndmonnum();
X		otmp->owt = weight(otmp);
X	}
X	return(otmp);
X}
X
X#endif /* OVL1 */
X#ifdef OVLB
Xstruct obj *
Xmk_tt_object(objtype, x, y)
Xint objtype; /* CORPSE or STATUE */
Xregister int x, y;
X{
X	register struct obj *otmp;
X
X	/* player statues never contain books */
X	if ((otmp = mksobj_at(objtype,x,y,FALSE)) != 0)
X		otmp = tt_oname(otmp);
X	return(otmp);
X}
X
X/* make a new corpse or statue, uninitialized if a statue (i.e. no books) */
Xstruct obj *
Xmk_named_object(objtype, ptr, x, y, nm, lth)
Xint objtype; /* CORPSE or STATUE */
Xregister struct permonst *ptr;
Xint x, y;
Xchar * nm;
Xregister int lth;
X{
X	struct obj *otmp;
X
X	otmp = mkcorpstat(objtype,ptr,x,y,(objtype != STATUE));
X	if (lth > 0) {
X		/* Note: oname() is safe since otmp is first in both chains */
X		otmp = oname(otmp, nm, FALSE);
X		fobj = otmp;
X		level.objects[x][y] = otmp;
X		if (is_pool(x,y)) water_damage(otmp,TRUE);
X	}
X	return(otmp);
X}
X
Xboolean
Xis_flammable(otmp)
Xregister struct obj *otmp;
X{
X	int otyp = otmp->otyp;
X
X	if (objects[otyp].oc_oprop == FIRE_RES) return FALSE;
X
X	return((objects[otyp].oc_material == WOOD ||
X			objects[otyp].oc_material == 0));
X
X}
X
X#endif /* OVLB */
X#ifdef OVL1
X
X/*
X * These routines maintain the single-linked lists headed in level.objects[][]
X * and threaded through the nexthere fields in the object-instance structure.
X */
X
Xvoid
Xplace_object(otmp, x, y)
X/* put an object on top of the pile at the given location */
Xregister struct obj *otmp;
Xint x, y;
X{
X    register struct obj *otmp2 = level.objects[x][y];
X
X    if (otmp->otyp == BOULDER) block_point(x,y);	/* vision */
X
X    if (otmp2 && (otmp2->otyp == BOULDER)) {
X	otmp->nexthere = otmp2->nexthere;
X	otmp2->nexthere = otmp;
X    } else {
X	otmp->nexthere = otmp2;
X	level.objects[x][y] = otmp;
X    }
X    if (is_pool(x,y)) water_damage(otmp,TRUE);
X
X    /* set the new object's location */
X    otmp->ox = x;
X    otmp->oy = y;
X}
X
X#endif /* OVL1 */
X#ifdef OVLB
Xvoid
Xremove_object(otmp)
Xregister struct obj *otmp;
X{
X    register struct obj *odel;
X
X    if (otmp->otyp == BOULDER) unblock_point(otmp->ox,otmp->oy); /* vision */
X
X    if (otmp == level.objects[otmp->ox][otmp->oy])
X	level.objects[otmp->ox][otmp->oy] = otmp->nexthere;
X    else
X	for (odel = level.objects[otmp->ox][otmp->oy];
X						    odel; odel = odel->nexthere)
X	    if (odel->nexthere == otmp) {
X		odel->nexthere = otmp->nexthere;
X		break;
X	    }
X}
X
Xvoid
Xmove_object(otmp, x, y)
Xregister struct obj *otmp;
Xint x, y;
X{
X    remove_object(otmp);
X    place_object(otmp, x, y);
X}
X
X#endif /* OVLB */
X
X/*mkobj.c*/
END_OF_FILE
if test 18051 -ne `wc -c <'src/mkobj.c'`; then
    echo shar: \"'src/mkobj.c'\" unpacked with wrong size!
fi
# end of 'src/mkobj.c'
fi
if test -f 'sys/amiga/amirip.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/amiga/amirip.c'\"
else
echo shar: Extracting \"'sys/amiga/amirip.c'\" \(17141 characters\)
sed "s/^X//" >'sys/amiga/amirip.c' <<'END_OF_FILE'
X/*  SCCS Id: @(#)amirip.c   3.2 93/01/08
X/* Copyright (c) Kenneth Lorber, Bethesda, Maryland 1991, 1992, 1993. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include "hack.h"
X#include <exec/types.h>
X#include <exec/io.h>
X#include <exec/alerts.h>
X#include <exec/devices.h>
X#include <devices/console.h>
X#include <devices/conunit.h>
X#include <graphics/gfxbase.h>
X#include <graphics/gfxmacros.h>
X#include <intuition/intuition.h>
X#include <libraries/dosextens.h>
X#include <ctype.h>
X#include <string.h>
X#include "winami.h"
X
X#undef  NULL
X#define NULL    0
X
X#ifdef AZTEC_C
X# include <functions.h>
X#else
X# include <proto/dos.h>
X# include <proto/exec.h>
X# include <proto/console.h>
X# include <proto/diskfont.h>
X
X/* terrible kludge */
X/* this is why prototypes should have ONLY types in them! */
X# undef red
X# undef green
X# undef blue
X# undef index
X# include <proto/graphics.h>
X
X# include <proto/intuition.h>
X#endif /* AZTEC_C */
X
Xstatic void grass ( int x , int y );
Xstatic void strand ( int x , int y , int dir );
Xstatic void tomb_text ( char *p );
Xstatic void getret( void );
Xvoid draw_moon(int phase);
X
Xextern char *killed_by_prefix[];
Xstruct Window *ripwin;
X
X#define STONE_LINE_LEN 18   /* # chars that fit on one line
X			     * (note 1 ' ' border)
X			     */
X#define MOONSIZE    30
X
Xstatic struct stabstuff
X{
X    short x1,y0;
X}
Xstab[]=
X{
X    {0,0}, {0,1}, {0,2}, {1,3}, {2,4},
X    {3,5}, {5,6}, {7,7}, {9,8}, {11,9}
X};
X
Xstatic struct
X{
X    int x, y;	/* center of moon */
X}
Xmoon[]=
X{
X/* 0-7, left to right, 4 is full and just right of center
X0-3 hollow to left, 5-7 hollow to right (DONT GO OFF THE SCREEN EDGE!) */
X    { 50, 70, },
X    { 120, 60, },
X    { 190, 50, },
X    { 260, 40, },
X    { 330, 30, },
X    { 410, 40, },
X    { 480, 50, },
X    { 550, 60, },
X};
X
Xunsigned short dirtpat[ 7 ][ 3 ][ 8 ]=
X{
X{
X {0xb8a0, 0xc124, 0xa60f, 0x7894, 0x1152, 0x0ec1, 0x14c0, 0xa921, },
X {0x4611, 0x365b, 0x5030, 0x0460, 0x44a0, 0xd106, 0x0131, 0x4282, },
X {0xb9ee, 0xc9a4, 0xafcf, 0xfb9f, 0xbb5f, 0x2ef9, 0xfece, 0xbd7d, },
X},
X
X{
X {0x1258, 0x1015, 0xd430, 0x0488, 0x1402, 0x1040, 0x22e3, 0x8ce8, },
X {0x00a4, 0x818a, 0x2a45, 0x6255, 0x49a8, 0xe69a, 0x9118, 0x1215, },
X {0xff5b, 0x7e75, 0xd5ba, 0x9daa, 0xb657, 0x1965, 0x6ee7, 0xedea, },
X},
X
X{
X {0x9958, 0x0164, 0x80c8, 0xa660, 0x0412, 0x0025, 0x22ab, 0x2512, },
X {0x64a4, 0xb292, 0x5525, 0x489d, 0x73c0, 0x7e8a, 0x0514, 0xd2ad, },
X {0x9b5b, 0x4d6d, 0xaada, 0xb762, 0x8c3f, 0x8175, 0xfaeb, 0x2d52, },
X},
X
X{
X {0x8f41, 0xca1e, 0x29c2, 0xa4c0, 0x5481, 0x94d8, 0x9702, 0x0914, },
X {0x608c, 0x05c0, 0x4425, 0x1936, 0x2a3e, 0x4203, 0x4064, 0x54c0, },
X {0x9f73, 0xfa3f, 0xbbda, 0xe6c9, 0xd5c1, 0xbdfc, 0xbf9b, 0xab3f, },
X},
X
X{
X {0x4000, 0xd52b, 0x1010, 0x5008, 0x40c1, 0x4057, 0x014a, 0x606c, },
X {0xa900, 0x2810, 0x0a85, 0x8fc6, 0x3406, 0xbfa0, 0xf020, 0x9d10, },
X {0x56ff, 0xd7ef, 0xf57a, 0x7039, 0xcbf9, 0x405f, 0x0fdf, 0x62ef, },
X},
X
X{
X {0x8368, 0x0480, 0x900e, 0xf41f, 0x2e24, 0xfa03, 0x0397, 0x895c, },
X {0x5814, 0x1022, 0x4ca0, 0x0300, 0x0042, 0x0078, 0xf048, 0x6683, },
X {0xa7eb, 0xefdd, 0xb35f, 0xfcff, 0xffbd, 0xff87, 0x0fb7, 0x997c, },
X},
X
X{
X {0x4228, 0x0050, 0xa016, 0x42a3, 0x341c, 0x46a2, 0x23d3, 0x4001, },
X {0xb515, 0x6383, 0x13c8, 0x8d5c, 0x0822, 0x1149, 0x4400, 0x8728, },
X {0x4aea, 0x9c7c, 0xec37, 0x72a3, 0xf7dd, 0xeeb6, 0xbbff, 0x78d7, },
X},
X};
X
Xstatic USHORT stonepat[] =
X{
X    0x8242,
X    0x2421,
X    0x1888,
X    0x4112,
X    0x2444,
X    0x8218,
X    0x4181,
X    0x1824,
X};
X
Xstatic USHORT moundpat[] =
X{
X    0x5235,
X    0xd7c6,
X    0x1298,
X    0x34a7,
X    0x2736,
X    0x2c54,
X    0xdc93,
X    0xc551,
X};
X
X#define DEATH_LINE  10
X#define YEAR_LINE   15
X
Xstatic int horizon;
Xstatic struct RastPort *rp;
Xstatic unsigned char tomb_line;
X
Xextern struct DisplayDesc *amiIDisplay;
Xextern struct Screen *HackScreen;
Xextern unsigned short amii_curmap[];
Xextern int havelace;
X
X#undef  BLACK
X#undef  WHITE
X#undef  BROWN
X#undef  GREEN
X
X#define BLACK   0
X#define WHITE   1
X#define BROWN   2
X#define GREY    3
X#define GREEN   4
X#define DKGRN   5
X
Xstatic unsigned short zeropalette[] = {
X    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
X};
Xstatic unsigned short toppalette[] = {
X    0x0000, 0x0EEF, 0x0730, 0x0778, 0x0082, 0x0573, 0x0000, 0x0000,
X};
X
X#define AREA_SIZE   500
Xstatic WORD areabuffer[ AREA_SIZE ];
X
Xstatic struct NewWindow newwin =
X{
X    0,0,640,200,1,0,
X    MOUSEBUTTONS|VANILLAKEY|NOCAREREFRESH,
X    BORDERLESS|ACTIVATE|SMART_REFRESH,
X    NULL,NULL,(UBYTE*)NULL,NULL,NULL,-1,-1,-1,-1,CUSTOMSCREEN
X};
X
Xint wh; /* was local in outrip, but needed for SCALE macro */
X
X#define DEPTH ripwin->RPort->BitMap->Depth
X/*TODO: should use real algorithm to get circles */
X#define SCALE(x) ((wh<300)?(x):((x)*2))
X#define MOONSX  MOONSIZE
X#define MOONSY  ((SCALE(MOONSIZE)/2)-4)
X
Xvoid
Xdraw_moon(int phase)
X{
X    int x;
X    int off_c_x=MOONSX+10;	/* moon center x in srp */
X    int off_c_y=MOONSY;		/* moon center y in srp */
X    int blit_urhx=10;		/* upper right hand corner for blit */
X    int blit_urhy=0;
X    int blit_width=MOONSX*2;	/* sizes for blit */
X    int blit_height=MOONSY*2+1;	/* +1 - hmm (rounding? 0 base?)*/
X
X    /* set up scratch rastport */
X    struct BitMap sbm;
X    struct RastPort srp;
X    struct AreaInfo ainfo;
X    short abuf[5];
X    struct TmpRas atr;
X    PLANEPTR ap;
X
X    /*TODO: sizes here are bigger than needed */
X    InitBitMap(&sbm,DEPTH,MOONSIZE*4,MOONSIZE*2);
X    for(x=0;x<DEPTH;x++){
X	sbm.Planes[x]=(PLANEPTR)AllocRaster(MOONSIZE*2,MOONSIZE*4);
X	if(!sbm.Planes[x])goto free;
X    }
X    InitRastPort(&srp);
X    srp.BitMap=&sbm;
X    InitArea(&ainfo,abuf,2);
X    srp.AreaInfo= &ainfo;
X    ap=AllocRaster(320,200);
X    if(!ap)goto free;
X#ifdef AZTEC_C
X    /*
X     * Aztec, in their infinite wisdom, require a char * as the
X     * second argument.
X     */
X    InitTmpRas(&atr, (char *)ap, RASSIZE(320,200));
X#else
X    InitTmpRas(&atr,ap,RASSIZE(320,200));
X#endif
X    srp.TmpRas = &atr;
X    SetAfPt(rp,(UWORD *)NULL,0);
X    SetRast(&srp,BLACK);
X
X    switch(phase){
X    case 0: /* new moon - no image */
X	break;
X    case 1: /* waxing crescent */
X	SetAPen(&srp,WHITE);
X	AreaEllipse(&srp,off_c_x,off_c_y,MOONSX,MOONSY);
X	AreaEnd(&srp);
X	SetAPen(&srp,BLACK);
X	AreaEllipse(&srp,off_c_x+10,off_c_y,MOONSX,MOONSY);
X	AreaEnd(&srp);
X	break;
X
X    case 2: /* 1st quarter */
X	SetAPen(&srp,WHITE);
X	AreaEllipse(&srp,off_c_x,off_c_y,MOONSX,MOONSY);
X	AreaEnd(&srp);
X	SetAPen(&srp,BLACK);
X	RectFill(&srp,off_c_x,0,MOONSIZE*4-1,MOONSIZE*2-1);
X	break;
X    case 3: /* gibbous */
X	SetAPen(&srp,WHITE);
X	AreaEllipse(&srp,off_c_x,off_c_y,MOONSX,MOONSY);
X	AreaEnd(&srp);
X	SetAPen(&srp,BLACK);
X	RectFill(&srp,off_c_x,0,MOONSIZE*4-1,MOONSIZE*2-1);
X	SetAPen(&srp,WHITE);
X	AreaEllipse(&srp,off_c_x,off_c_y,MOONSX/2,MOONSY);
X	AreaEnd(&srp);
X	break;
X    case 4: /* full */
X	SetAPen(&srp,WHITE);
X	AreaEllipse(&srp,off_c_x,off_c_y,MOONSX,MOONSY);
X	AreaEnd(&srp);
X	break;
X    case 5: /* gibbous */
X	SetAPen(&srp,WHITE);
X	AreaEllipse(&srp,off_c_x,off_c_y,MOONSX,MOONSY);
X	AreaEnd(&srp);
X	SetAPen(&srp,BLACK);
X	RectFill(&srp,0,0,off_c_x,MOONSIZE*2-1);
X	SetAPen(&srp,WHITE);
X	AreaEllipse(&srp,off_c_x,off_c_y,MOONSX/2,MOONSY);
X	AreaEnd(&srp);
X	break;
X    case 6: /* last quarter */
X	SetAPen(&srp,WHITE);
X	AreaEllipse(&srp,off_c_x,off_c_y,MOONSX,MOONSY);
X	AreaEnd(&srp);
X	SetAPen(&srp,BLACK);
X	RectFill(&srp,0,0,off_c_x,MOONSIZE*4-1+10);
X	break;
X    case 7: /* waning crescent */
X	SetAPen(&srp,WHITE);
X	AreaEllipse(&srp,off_c_x,off_c_y,MOONSX,MOONSY);
X	AreaEnd(&srp);
X	SetAPen(&srp,BLACK);
X	AreaEllipse(&srp,off_c_x-10,off_c_y,MOONSX,MOONSY);
X	AreaEnd(&srp);
X	break;
X    }
X    /*move rastport into window (so that there are no stars "in" the moon)*/
X	/* draw black circle in window rport */
X    SetAPen(rp,BLACK);
X    AreaEllipse( rp, moon[phase].x,moon[phase].y,MOONSX,MOONSY);
X    AreaEnd(rp);
X
X    if(phase != 0){
X	/*move scratch to window: set all white, ignore black (in src)*/
X	ClipBlit(&srp,blit_urhx,blit_urhy,
X	  rp,moon[phase].x-(blit_width/2),moon[phase].y-(blit_height/2),
X	  blit_width,blit_height,0xe0);
X    }
X
Xfree:
X    for(x=0;x<DEPTH;x++)
X	if(sbm.Planes[x])
X	    FreeRaster(sbm.Planes[x],MOONSIZE*2,MOONSIZE*4);
X    if(ap)FreeRaster(ap,320,200);
X}
X#undef DEPTH
X
Xvoid
Xoutrip( how, tmpwin )
Xint how;
Xwinid tmpwin;
X{
X    int done, rtxth;
X    struct IntuiMessage *imsg;
X    struct AreaInfo areaInfo;
X    PLANEPTR planeptr;
X    struct TmpRas tmpRas;
X    int i;
X    register char *dpx;
X    char buf[ 200 ];
X    register int x;
X    int line, phase, c, offset, tw, ww;
X
X    /* Use the users display size */
X    newwin.Height = amiIDisplay->ypix - newwin.TopEdge;
X    newwin.Width = amiIDisplay->xpix;
X    newwin.Screen = HackScreen;
X
X    ripwin = OpenWindow( &newwin );
X    if( !ripwin ){
X	return;
X    }
X
X    rp= ripwin->RPort;
X    wh = ripwin->Height;
X    ww = ripwin->Width;
X    if( !( planeptr = AllocRaster( ww, wh ) ) )
X	return;
X
X#ifdef AZTEC_C
X    InitTmpRas( &tmpRas, (char *) planeptr, RASSIZE( ww, wh ) );
X#else
X    InitTmpRas( &tmpRas, planeptr, RASSIZE( ww, wh ) );
X#endif
X    rp->TmpRas = &tmpRas;
X
X    for( i = 0; i < AREA_SIZE; ++i )
X	areabuffer[ i ] = 0;
X    InitArea( &areaInfo, areabuffer, (AREA_SIZE*2)/5);
X    rp->AreaInfo = &areaInfo;
X
X    LoadRGB4( &HackScreen->ViewPort, zeropalette, 8L );
X
X    horizon=ripwin->Height*2/3;
X
X    /* sky */
X    SetDrMd(rp,JAM1);
X    SetAPen( rp, BLACK );
X    RectFill(rp,0,0,ripwin->Width,horizon);
X
X    /* ground */
X    SetDrMd( rp, JAM2 );
X    SetAfPt( rp, dirtpat[random()%7], -3 );
X    SetAPen( rp, 255 );
X    SetBPen( rp, 0 );
X    RectFill( rp, 0, horizon+1, ripwin->Width, ripwin->Height );
X    SetAfPt( rp, (UWORD *)NULL, 0 );
X
X    /* stars */
X    SetAPen(rp,WHITE);
X    for(c=d(30,40);c;c--)
X	WritePixel(rp,rn2(ripwin->Width),rn2(horizon));
X
X    /* moon (NB destroys area fill pattern) */
X    phase = phase_of_the_moon() % 8;
X    draw_moon(phase);
X
X    /* grass */
X    offset=(phase<4)?-1:1;
X    SetAPen(rp,GREEN);
X    for( x = 0; x < ripwin->Width; x+=10+rn2(10))
X	grass(x, horizon+5 );
X
X    /* fence - horizontal, then vertical, each with a moonlit side */
X    SetAPen(rp,GREY);
X    Move(rp,0,horizon-SCALE(20));
X    Draw(rp,ripwin->Width,horizon-SCALE(20));
X    Move(rp,0,horizon+30);
X    Draw(rp,ripwin->Width,horizon+30);
X
X    for(x=30;x<ripwin->Width;x+=50)
X    {
X	Move(rp,x,horizon-SCALE(25));
X	Draw(rp,x,horizon+35);
X	Move(rp,x-offset,horizon-SCALE(25));
X	Draw(rp,x-offset,horizon+35);
X	Move(rp,x-(2*offset),horizon-SCALE(25));
X	Draw(rp,x-(2*offset),horizon+35);
X    }
X
X
X    if(phase)SetAPen(rp,WHITE); /* no vertical white if no moon */
X    Move(rp,0,horizon-SCALE(20)-1);
X    Draw(rp,ripwin->Width,horizon-SCALE(20)-1);
X    Move(rp,0,horizon+29);
X    Draw(rp,ripwin->Width,horizon+29);
X
X    if(phase!=0 && phase!=4){
X	SetAPen(rp,WHITE);
X    } else {
X	SetAPen(rp,GREY);   /* no hor. white if no or full moon */
X    }
X    for(x=30;x<ripwin->Width;x+=50)
X    {
X	Move(rp,x+offset,horizon-SCALE(25));
X	Draw(rp,x+offset,horizon+35);
X	Move(rp,x+(2*offset),horizon-SCALE(25));
X	Draw(rp,x+(2*offset),horizon+35);
X    }
X
X    /* Put together death description */
X    switch (killer_format) {
X    default:
X	impossible("bad killer format?");
X    case KILLED_BY_AN:
X	Strcpy(buf, killed_by_prefix[how]);
X	Strcat(buf, an(killer));
X	break;
X    case KILLED_BY:
X	Strcpy(buf, killed_by_prefix[how]);
X	Strcat(buf, killer);
X	break;
X    case NO_KILLER_PREFIX:
X	Strcpy(buf, killer);
X	break;
X    }
X
X    tw = TextLength(rp,buf,STONE_LINE_LEN) + 40;
X
X    {
X	char *p=buf;
X	int x;
X	for(x=STONE_LINE_LEN;x;x--)*p++='W';
X	*p='\0';
X	tw = max( tw, TextLength(rp,buf,STONE_LINE_LEN) + 40 );
X    }
X
X    SetAPen( rp, phase ? BLACK : GREY );
X    SetBPen( rp, phase ? WHITE : BLACK );
X    SetDrMd( rp, JAM2 );
X    SetAfPt( rp, stonepat, 3 );
X
X    /* There are 5 lines of text on the stone. */
X    rtxth = ripwin->RPort->TxHeight * 5;
X
X    /* Do shadow ellipse on stone */
X    if( phase < 4 )
X	AreaEllipse(rp,ripwin->Width/2-3,horizon-rtxth,tw/2+3,tw/6);
X    else if( phase > 4 )
X	AreaEllipse(rp,ripwin->Width/2+3,horizon-rtxth,tw/2+3,tw/6);
X    else
X	AreaEllipse(rp,ripwin->Width/2,horizon-rtxth-2,tw/2+3,tw/6);
X    AreaEnd( rp );
X
X    /* Top ellipse on stone */
X    SetAPen( rp, BLACK );
X    SetBPen( rp, GREY );
X    AreaEllipse(rp,ripwin->Width/2,horizon-rtxth,tw/2,tw/6);
X    AreaEnd( rp );
X
X    /* Body of stone */
X    RectFill(rp,ripwin->Width/2-tw/2,horizon-rtxth,ripwin->Width/2+tw/2,
X      horizon-rtxth+15+(rp->TxHeight+1)*8);
X
X    SetAPen( rp, phase ? BROWN : GREY );
X    SetBPen( rp, phase ? GREY : BROWN );
X    SetAfPt( rp, stonepat, 3 );
X
X#if 0
X    AreaMove( rp, ripwin->Width/2-tw/2, horizon-rtxth+15+(rp->TxHeight+1)*8 );
X    AreaDraw( rp, ripwin->Width/2-tw/4, horizon-rtxth+((ripwin->Height > 200)
X      ? 55 : 35)+(rp->TxHeight+1)*8 );
X    AreaDraw( rp, ripwin->Width/2+tw, horizon-rtxth+((ripwin->Height > 200)
X      ? 55 : 35)+(rp->TxHeight+1)*8 );
X    AreaDraw( rp, ripwin->Width/2+tw/2, horizon-rtxth+15+(rp->TxHeight+1)*8 );
X    AreaEnd( rp );
X
X    SetAfPt( rp, stonepat, 3 );
X
X#endif
X    /* Draw shadow on correct side of stone */
X    SetAPen( rp, phase ? BLACK : GREY );
X    SetBPen( rp, phase ? WHITE : BLACK );
X    if( phase < 4 )
X    {
X	AreaMove( rp, ripwin->Width/2-tw/2-6, horizon-rtxth );
X	AreaDraw( rp, ripwin->Width/2-tw/2-6,
X	  horizon-rtxth+15+(rp->TxHeight+1)*8-4 );
X	AreaDraw( rp, ripwin->Width/2-tw/2-1,
X	  horizon-rtxth+15+(rp->TxHeight+1)*8 );
X	AreaDraw( rp, ripwin->Width/2-tw/2-1, horizon-rtxth );
X    }
X    else if( phase > 4 )
X    {
X	AreaMove( rp, ripwin->Width/2+tw/2+6, horizon-rtxth );
X	AreaDraw( rp, ripwin->Width/2+tw/2+6,
X	  horizon-rtxth+15+(rp->TxHeight+1)*8-4 );
X	AreaDraw( rp, ripwin->Width/2+tw/2+1,
X	  horizon-rtxth+15+(rp->TxHeight+1)*8 );
X	AreaDraw( rp, ripwin->Width/2+tw/2+1, horizon-rtxth );
X    }
X    AreaEnd( rp );
X
X    SetAfPt( rp, (UWORD *)NULL, 0 );
X    SetDrPt( rp, ~0 );
X
X    tomb_line=0;
X    SetBPen(rp,GREY);
X    SetDrMd(rp,JAM1);
X    tomb_text("REST");
X    tomb_text("IN");
X    tomb_text("PEACE");
X
X    /* Put name on stone */
X    Sprintf(buf, "%s", plname);
X    buf[STONE_LINE_LEN] = 0;
X    tomb_text(buf);
X
X    /* Put $ on stone */
X    Sprintf(buf, "%ld Au", u.ugold);
X    buf[STONE_LINE_LEN] = 0; /* It could be a *lot* of gold :-) */
X    tomb_text(buf);
X
X    /* Put together death description */
X    switch (killer_format) {
X    default:
X	impossible("bad killer format?");
X    case KILLED_BY_AN:
X	Strcpy(buf, killed_by_prefix[how]);
X	Strcat(buf, an(killer));
X	break;
X    case KILLED_BY:
X	Strcpy(buf, killed_by_prefix[how]);
X	Strcat(buf, killer);
X	break;
X    case NO_KILLER_PREFIX:
X	Strcpy(buf, killer);
X	break;
X    }
X
X    /* Put death type on stone */
X    for (line=DEATH_LINE, dpx = buf; line<YEAR_LINE; line++)
X    {
X	register int i,i0;
X	char tmpchar;
X
X	if ( (i0=strlen(dpx)) > STONE_LINE_LEN)
X	{
X	    for(i=STONE_LINE_LEN;((i0 > STONE_LINE_LEN) && i); i--)
X	    {
X		if(dpx[i] == ' ')
X		    i0 = i;
X	    }
X	    if(!i)
X		i0 = STONE_LINE_LEN;
X	}
X
X	tmpchar = dpx[i0];
X	dpx[i0] = 0;
X	tomb_text(dpx);
X
X	if (tmpchar != ' ')
X	{
X	    dpx[i0] = tmpchar;
X	    dpx= &dpx[i0];
X	}
X	else
X	{
X	    dpx= &dpx[i0+1];
X	}
X    }
X
X    /* Put year on stone */
X    Sprintf(buf, "%4d", getyear());
X    tomb_text(buf);
X
X    LoadRGB4( &HackScreen->ViewPort, toppalette, 8L );
X
X    done = 0;
X    while( !done )
X    {
X	WaitPort( ripwin->UserPort );
X	while( imsg = (struct IntuiMessage *)GetMsg(ripwin->UserPort) )
X	{
X	    switch( imsg->Class )
X	    {
X		case MOUSEBUTTONS:
X		case VANILLAKEY:
X		    done = 1;
X		    break;
X	    }
X	    ReplyMsg( (struct Message *)imsg );
X	}
X    }
X
X    if( planeptr ) FreeRaster( planeptr, ww, wh );
X    rp->TmpRas = NULL;
X    Forbid();
X    while( imsg = (struct IntuiMessage *)GetMsg( ripwin->UserPort ) )
X	ReplyMsg( (struct Message *)imsg );
X    CloseWindow( ripwin );
X    ripwin = NULL;
X    Permit();
X    LoadRGB4( &HackScreen->ViewPort, amii_curmap, 8L );
X}
X
Xstatic void grass(x,y)
Xregister int x,y;
X{
X    register int ct=rn2(5)+3;
X    register int c;
X    x-=2;
X    for(c=ct;c;c--)
X    {
X	strand(x,y,(c>ct/2)?1:-1);
X	x+=2;
X    }
X}
X
Xstatic void strand(x,y,dir)
X   register int x,y;
X   register int dir;    /* which way the wind blows :-) */
X{
X    register int i;
X    register struct RastPort *nrp = rp;
X    register struct stabstuff *st;
X    for(i=rn2(10);i>=0;i--)
X    {
X	st = &stab[i];
X	WritePixel(nrp,x+st->x1*dir,y-st->y0);
X    }
X}
X
Xstatic void tomb_text(p)
Xchar *p;
X{
X    char buf[STONE_LINE_LEN*2];
X    int l;
X    /*int i;*/
X
X    if( !*p )
X	return;
X    sprintf(buf," %s ",p);
X    l=TextLength(rp,buf,strlen(buf));
X    ++tomb_line;
X
X    SetAPen(rp,WHITE);
X    Move(rp,(ripwin->Width/2)-(l/2)-1, 
X      ((tomb_line-6)*(rp->TxHeight+1))+horizon);
X    Text(rp,buf,strlen(buf));
X
X    SetAPen(rp,WHITE);
X    Move(rp,(ripwin->Width/2)-(l/2)+1,
X      ((tomb_line-6)*(rp->TxHeight+1))+horizon);
X    Text(rp,buf,strlen(buf));
X
X    SetAPen(rp,WHITE);
X    Move(rp,(ripwin->Width/2)-(l/2),
X      ((tomb_line-6)*(rp->TxHeight+1))+horizon - 1);
X    Text(rp,buf,strlen(buf));
X
X    SetAPen(rp,WHITE);
X    Move(rp,(ripwin->Width/2)-(l/2),
X      ((tomb_line-6)*(rp->TxHeight+1))+horizon + 1);
X    Text(rp,buf,strlen(buf));
X
X    SetAPen(rp,BLACK);
X    Move(rp,(ripwin->Width/2)-(l/2),
X      ((tomb_line-6)*(rp->TxHeight+1))+horizon);
X    Text(rp,buf,strlen(buf));
X}
END_OF_FILE
if test 17141 -ne `wc -c <'sys/amiga/amirip.c'`; then
    echo shar: \"'sys/amiga/amirip.c'\" unpacked with wrong size!
fi
# end of 'sys/amiga/amirip.c'
fi
echo shar: End of archive 83 \(of 108\).
cp /dev/null ark83isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \
21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \
41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 \
61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 \
81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 \
101 102 103 104 105 106 107 108 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 108 archives.
    echo "Now execute 'rebuild.sh'"
    rm -f ark10[0-8]isdone ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
