Path: uunet!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v16i080:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Part72/108
Message-ID: <4443@master.CNA.TEK.COM>
Date: 5 Feb 93 19:19:41 GMT
Sender: news@master.CNA.TEK.COM
Lines: 2201
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1631

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 16, Issue 80
Archive-name: nethack31/Part72
Supersedes: nethack3p9: Volume 10, Issue 46-102
Environment: Amiga, Atari, Mac, MS-DOS, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 72 (of 108)."
# Contents:  dat/wizhelp src/engrave.c sys/share/lev_yacc.c2
# Wrapped by billr@saab on Wed Jan 27 16:09:15 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'dat/wizhelp' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dat/wizhelp'\"
else
echo shar: Extracting \"'dat/wizhelp'\" \(312 characters\)
sed "s/^X//" >'dat/wizhelp' <<'END_OF_FILE'
XDebug-Mode Quick Reference:
X
X^E  ==  detect secret doors and traps.
X^F  ==  do magic mapping.
X^G  ==  create monster.
X^I  ==  identify items in pack.
X^O  ==  tell locations of special levels.
X^T  ==  do intra-level teleport.
X^V  ==  do trans-level teleport.
X^W  ==  make wish.
X^X  ==  show intrinsic attributes.
END_OF_FILE
if test 312 -ne `wc -c <'dat/wizhelp'`; then
    echo shar: \"'dat/wizhelp'\" unpacked with wrong size!
fi
# end of 'dat/wizhelp'
fi
if test -f 'src/engrave.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/engrave.c'\"
else
echo shar: Extracting \"'src/engrave.c'\" \(23761 characters\)
sed "s/^X//" >'src/engrave.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)engrave.c	3.1	92/02/25	*/
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include "hack.h"
X#include "lev.h"
X#include <ctype.h>
X
XSTATIC_VAR struct engr NEARDATA *head_engr;
X
XSTATIC_DCL void FDECL(del_engr, (struct engr *));
X
X#ifdef OVLB
X/* random engravings */
Xconst char *random_mesg[] = {
X	"Elbereth", "ad ae?ar um",
X	"?la? ?as he??",
X	/* take-offs and other famous engravings */
X	"Owlbreath", "?ala??iel",
X	"?ilroy wa? h?re",
X	"A.S. ->", "<- A.S.", /* Journey to the Center of the Earth */
X	"Y?u won t get i? up ?he ste?s", /* Adventure */
X	"Lasc?ate o?ni sp?ranz? o vo? c?'en?rate", /* Inferno */
X	"Well Come", /* Prisoner */
X	"W? ap?l???ze for t?e inc?nve??e?ce", /* So Long... */
X	"S?e you n?xt Wed?esd?y", /* Thriller */
X	"Fo? a ?ood time c?ll 8?7-53?9",
X};
X
Xconst char *
Xrandom_engraving()
X{
X	char *rumor, *s;
X
X/* a random engraving may come from the "rumors" file, or from the
X   list above */
X	rumor = getrumor(0);
X	if (rn2(4) && *rumor) {
X		for (s = rumor; *s; s++)
X			if (!rn2(7) && *s != ' ') *s = '?';
X		if (s[-1] == '.') s[-1] = 0;
X		return (const char *)rumor;
X	}
X	else
X		return random_mesg[rn2(SIZE(random_mesg))];
X}
X#endif /* OVLB */
X#ifdef OVL0
X
Xstruct engr *
Xengr_at(x,y) register xchar x,y; {
Xregister struct engr *ep = head_engr;
X	while(ep) {
X		if(x == ep->engr_x && y == ep->engr_y)
X			return(ep);
X		ep = ep->nxt_engr;
X	}
X	return((struct engr *) 0);
X}
X
X#ifdef ELBERETH
Xint
Xsengr_at(s,x,y)
X	register const char *s;
X	register xchar x,y;
X{
X	register struct engr *ep = engr_at(x,y);
X	register char *t;
X	register int n;
X
X	if(ep && ep->engr_time <= moves) {
X		t = ep->engr_txt;
X/*
X		if(!strcmp(s,t)) return(1);
X*/
X		n = strlen(s);
X		while(*t) {
X			if(!strncmp(s,t,n)) return(1);
X			t++;
X		}
X	}
X	return(0);
X}
X#endif
X
X#endif /* OVL0 */
X#ifdef OVL2
X
Xvoid
Xu_wipe_engr(cnt)
Xregister int cnt;
X{
X	if(!u.uswallow && !Levitation)
X		wipe_engr_at(u.ux, u.uy, cnt);
X}
X
X#endif /* OVL2 */
X#ifdef OVL1
X
Xvoid
Xwipe_engr_at(x,y,cnt) register xchar x,y,cnt; {
Xregister struct engr *ep = engr_at(x,y);
Xregister int lth,pos;
Xchar ch;
X	if(ep){
X	    if(ep->engr_type != BURN) {
X		if(ep->engr_type != DUST && ep->engr_type != BLOOD) {
X			cnt = rn2(1 + 50/(cnt+1)) ? 0 : 1;
X		}
X		lth = strlen(ep->engr_txt);
X		if(lth && cnt > 0 ) {
X			while(cnt--) {
X				pos = rn2(lth);
X				if((ch = ep->engr_txt[pos]) == ' ')
X					continue;
X				ep->engr_txt[pos] = (ch != '?') ? '?' : ' ';
X			}
X		}
X		while(lth && ep->engr_txt[lth-1] == ' ')
X			ep->engr_txt[--lth] = 0;
X		while(ep->engr_txt[0] == ' ')
X			ep->engr_txt++;
X		if(!ep->engr_txt[0]) del_engr(ep);
X	    }
X	}
X}
X
X#endif /* OVL1 */
X#ifdef OVL2
X
Xvoid
Xread_engr_at(x,y)
Xregister int x,y;
X{
X	register struct engr *ep = engr_at(x,y);
X	register int	sensed = 0;
X
X	if(ep && ep->engr_txt[0]) {
X	    switch(ep->engr_type) {
X	    case DUST:
X		if(!Blind) {
X			sensed = 1;
X			pline("Something is written here in the dust.");
X		}
X		break;
X	    case ENGRAVE:
X		if(!Blind || !Levitation) {
X			sensed = 1;
X			pline("Something is engraved here on the floor.");
X		}
X		break;
X	    case BURN:
X		if(!Blind || !Levitation) {
X			sensed = 1;
X			pline("Some text has been burned into the floor here.");
X		}
X		break;
X	    case MARK:
X		if(!Blind) {
X			sensed = 1;
X			pline("There's some graffiti on the floor here.");
X		}
X		break;
X	    case BLOOD:
X		/* "It's a message!  Scrawled in blood!"
X		 * "What's it say?"
X		 * "It says... `See you next Wednesday.'" -- Thriller
X		 */
X		if(!Blind) {
X			sensed = 1;
X			You("see a message scrawled in blood here.");
X		}
X		break;
X	    default:
X		impossible("Something is written in a very strange way.");
X		sensed = 1;
X	    }
X	    if (sensed) {
X		You("%s: \"%s\".",
X		      (Blind) ? "feel the words" : "read",  ep->engr_txt);
X		if(flags.run > 1) nomul(0);
X	    }
X	}
X}
X
X#endif /* OVL2 */
X#ifdef OVLB
X
Xvoid
Xmake_engr_at(x,y,s,e_time,e_type)
Xregister int x,y;
Xregister const char *s;
Xregister long e_time;
Xregister xchar e_type;
X{
X	register struct engr *ep;
X
X	if(ep = engr_at(x,y))
X	    del_engr(ep);
X	ep = newengr(strlen(s) + 1);
X	ep->nxt_engr = head_engr;
X	head_engr = ep;
X	ep->engr_x = x;
X	ep->engr_y = y;
X	ep->engr_txt = (char *)(ep + 1);
X	Strcpy(ep->engr_txt, s);
X	if(strcmp(s, "Elbereth")) exercise(A_WIS, TRUE);
X	ep->engr_time = e_time;
X	ep->engr_type = e_type > 0 ? e_type : rnd(N_ENGRAVE);
X	ep->engr_lth = strlen(s) + 1;
X}
X
X/*
X *	freehand - returns true if player has a free hand
X */
Xint
Xfreehand()
X{
X	return(!uwep || !welded(uwep) ||
X	   (!bimanual(uwep) && (!uarms || !uarms->cursed)));
X/*	if ((uwep && bimanual(uwep)) ||
X	    (uwep && uarms))
X		return(0);
X	else
X		return(1);*/
X}
X
Xstatic const char NEARDATA styluses[] =
X	{ ALL_CLASSES, ALLOW_NONE, TOOL_CLASS, WEAPON_CLASS, WAND_CLASS,
X	  GEM_CLASS, RING_CLASS, 0 };
X
X/* Mohs' Hardness Scale:
X *  1 - Talc		 6 - Orthoclase
X *  2 - Gypsum		 7 - Quartz
X *  3 - Calcite		 8 - Topaz
X *  4 - Fluorite	 9 - Corundum
X *  5 - Apatite		10 - Diamond
X *
X * Since granite is a igneous rock hardness ~ 7, anything >= 8 should
X * probably be able to scratch the rock.
X * Devaluation of less hard gems is not easily possible because obj struct
X * does not contain individual oc_cost currently. 7/91
X *
X * dilithium  - ??			* jade	    -  5-6	(nephrite)
X * diamond    - 10			* turquoise -  5-6
X * ruby	      -  9	(corundum)	* opal	    -  5-6
X * sapphire   -  9	(corundum)	* iron	    -  4-5
X * topaz      -  8			* fluorite  -  4
X * emerald    -  7.5-8	(beryl)		* brass     -  3-4
X * aquamarine -  7.5-8	(beryl)		* gold	    -  2.5-3
X * garnet     -  7.25	(var. 6.5-8)	* silver    -  2.5-3
X * agate      -  7	(quartz)	* copper    -  2.5-3
X * amethyst   -  7	(quartz)	* amber     -  2-2.5
X * jasper     -  7	(quartz)	*	
X * onyx	      -  7 	(quartz)	* steel     -  5-8.5	(usu. weapon)
X * moonstone  -  6	(orthoclase)	*
X */
X
Xstatic const short NEARDATA hard_gems[] =
X	{ DIAMOND, RUBY, SAPPHIRE, TOPAZ, EMERALD, AQUAMARINE, GARNET, 0 };
X
Xstatic const char NEARDATA *hard_ring_names[] =
X	{"diamond", "ruby", "sapphire", "emerald", "topaz", ""};
X
X/* return 1 if action took 1 (or more) moves, 0 if error or aborted */
Xint
Xdoengrave()
X{
X	boolean dengr = FALSE;	/* TRUE if we wipe out the current engraving */
X	boolean doblind = FALSE;/* TRUE if engraving blinds the player */
X	boolean doknown = FALSE;/* TRUE if we identify the stylus */
X	boolean eow = FALSE;	/* TRUE if we are overwriting oep */
X	boolean jello = FALSE;	/* TRUE if we are engraving in slime */
X	boolean ptext = TRUE;	/* TRUE if we must prompt for engrave text */
X	boolean teleengr =FALSE;/* TRUE if we move the old engraving */
X	boolean zapwand = FALSE;/* TRUE if we remove a wand charge */
X	xchar type = DUST;	/* Type of engraving made */
X	char buf[BUFSZ];	/* Buffer for final/poly engraving text */
X	char ebuf[BUFSZ];	/* Buffer for initial engraving text */
X	char qbuf[QBUFSZ];	/* Buffer for query text */
X	const char *everb;	/* Present tense of engraving type */
X	const char *eloc;	/* Where the engraving is (ie dust/floor/...) */
X	const char *post_engr_text; /* Text displayed after engraving prompt */
X	register char *sp;	/* Place holder for space count of engr text */
X	register int len;	/* # of nonspace chars of new engraving text */
X	register int maxelen;	/* Max allowable length of new engraving text */
X	register int spct;	/* # of spaces in new engraving text */
X	register struct engr *oep = engr_at(u.ux,u.uy);
X				/* The current engraving */
X	register struct obj *otmp; /* Object selected with which to engrave */
X
X
X	multi = 0;		/* moves consumed */
X	nomovemsg = (char *)0;	/* occupation end message */
X
X	buf[0] = (char)0;
X	ebuf[0] = (char)0;
X	post_engr_text = (char *)0;
X	maxelen = BUFSZ - 1;
X
X	/* Can the adventurer engrave at all? */
X
X	if(u.uswallow) {
X		if (is_animal(u.ustuck->data)) {
X			pline("What would you write?  \"Jonah was here\"?");
X			return(0);
X		} else if (is_whirly(u.ustuck->data)) {
X			You("can't reach the ground.");
X			return(0);
X		} else 
X			jello = TRUE;
X    	} else if (is_lava(u.ux, u.uy)) {
X		You("can't write on the lava!");
X		return(0);
X	} else if (is_pool(u.ux,u.uy) || IS_FOUNTAIN(levl[u.ux][u.uy].typ)) {
X		You("can't write on the water!");
X		return(0);
X	}
X	if(Is_airlevel(&u.uz) || Is_waterlevel(&u.uz)/* in bubble */) {
X		You("can't write in thin air!");
X		return(0);
X	}
X#ifdef POLYSELF
X	if (cantwield(uasmon)) {
X		You("can't even hold anything!");
X		return(0);
X	}
X#endif
X	if (check_capacity(NULL)) return (0);
X
X	/* One may write with finger, or weapon, or wand, or..., or...
X	 * Edited by GAN 10/20/86 so as not to change weapon wielded.
X	 */
X
X	otmp = getobj(styluses, "write with");
X	if(!otmp) return(0);		/* otmp == zeroobj if fingers */
X
X	/* There's no reason you should be able to write with a wand
X	 * while both your hands are tied up.
X	 */
X	if (!freehand() && otmp != uwep && !otmp->owornmask) {
X		You("have no free %s to write with!", body_part(HAND));
X		return(0);
X	}
X
X	if (jello) {
X		You("tickle %s with your %s.", mon_nam(u.ustuck), 
X		    (otmp == &zeroobj) ? makeplural(body_part(FINGER)) :
X			xname(otmp));
X		Your("message dissolves...");
X		return(0);
X	}
X	if(Levitation && otmp->oclass != WAND_CLASS){		/* riv05!a3 */
X		You("can't reach the floor!");
X		return(0);
X	}
X
X	/* SPFX for items */
X
X	switch (otmp->oclass) {
X	    default:
X	    case AMULET_CLASS:
X	    case CHAIN_CLASS:
X	    case POTION_CLASS:
X	    case GOLD_CLASS:
X		break;
X
X	    case RING_CLASS:
X		/* "diamond" rings and others should work */
X		{
X		    register int i, j;
X
X		    for (i=0, j=strlen(hard_ring_names[i]); j; i++)
X			if ( !strncmp(hard_ring_names[i],
X			     OBJ_DESCR(objects[otmp->otyp]),
X			     j=strlen(hard_ring_names[i])) ) {
X			    type = ENGRAVE;
X			    break;
X			}
X		}
X		break;
X
X	    case GEM_CLASS:
X		/* diamonds & other gems should work */
X		{
X		    register int i;
X
X		    for (i=0; hard_gems[i]; i++)
X			if (otmp->otyp == hard_gems[i]) {
X			    type = ENGRAVE;
X			    break;
X			}
X		}
X		break;
X
X	    /* Objects too large to engrave with */
X	    case BALL_CLASS:
X	    case ROCK_CLASS:
X	    case ARMOR_CLASS:
X		You("can't engrave with such a large object!");
X		ptext = FALSE;
X		break;
X
X	    /* Objects too silly to engrave with */
X	    case FOOD_CLASS:
X	    case SCROLL_CLASS:
X	    case SPBOOK_CLASS:
X		Your("%s would get too dirty.", xname(otmp));
X		ptext = FALSE;
X		break;
X
X	    case RANDOM_CLASS:	/* This should mean fingers */
X		break;
X
X	    /* The charge is removed from the wand before prompting for
X	     * the engraving text, because all kinds of setup decisions
X	     * and pre-engraving messages are based upon knowing what type
X	     * of engraving the wand is going to do.  Also, the player
X	     * will have potentially seen "You wrest .." message, and
X	     * therefore will know they are using a charge.
X	     */
X	    case WAND_CLASS:
X		if (zappable(otmp)) {
X		    zapwand = TRUE;
X		    if (Levitation) ptext = FALSE;
X
X		    switch (otmp->otyp) {
X		    /* DUST wands */
X		    default:
X			break;
X
X			/* NODIR wands */
X		    case WAN_LIGHT:
X		    case WAN_SECRET_DOOR_DETECTION:
X		    case WAN_CREATE_MONSTER:
X		    case WAN_WISHING:
X	  		zapnodir(otmp);
X			break;
X
X			/* IMMEDIATE wands */
X	    		/* If wand is "IMMEDIATE", remember to effect the
X			 * previous engraving even if turning to dust.,
X			 */
X		    case WAN_STRIKING:
X			post_engr_text =
X			"The wand unsuccessfully fights your attempt to write!";
X			break;
X		    case WAN_SLOW_MONSTER:
X			if (!Blind)
X			   post_engr_text = "The bugs on the ground slow down!";
X			break;
X		    case WAN_SPEED_MONSTER:
X			if (!Blind)
X			   post_engr_text = "The bugs on the ground speed up!";
X			break;
X		    case WAN_POLYMORPH:
X			if(oep)  {
X			    if (!Blind) {
X				type = (xchar)0;	/* random */
X				Strcpy(buf,random_engraving());
X			    }
X			    dengr = TRUE;
X			}
X			break;
X		    case WAN_NOTHING:
X		    case WAN_UNDEAD_TURNING:
X		    case WAN_OPENING:
X		    case WAN_LOCKING:
X		    case WAN_PROBING:
X			break;
X
X			/* RAY wands */
X		    case WAN_MAGIC_MISSILE:
X			ptext = TRUE;
X			if (!Blind)
X			    post_engr_text =
X				"The ground is riddled by bullet holes!";
X			break;
X
X		    /* can't tell sleep from death - Eric Backus */
X		    case WAN_SLEEP:
X		    case WAN_DEATH:
X			if (!Blind)
X			    post_engr_text =
X				"The bugs on the ground stop moving!";
X			break;
X
X		    case WAN_COLD:
X			if (!Blind)
X			    post_engr_text =
X				"A few ice cubes drop from the wand.";
X			if(!oep || (oep->engr_type != BURN))
X			    break;
X		    case WAN_CANCELLATION:
X		    case WAN_MAKE_INVISIBLE:
X			if(oep) {
X			    if (!Blind)
X				pline("The engraving on the floor vanishes!");
X			    dengr = TRUE;
X			}
X			break;
X		    case WAN_TELEPORTATION:
X			if (oep) {
X			    if (!Blind)
X				pline("The engraving on the floor vanishes!");
X			    teleengr = TRUE;
X			}
X			break;
X
X		    /* type = ENGRAVE wands */
X		    case WAN_DIGGING:
X			ptext = TRUE;
X			type  = ENGRAVE;
X			if(!objects[otmp->otyp].oc_name_known) {
X	    		    if (flags.verbose)
X				pline("This %s is a wand of digging!",
X				xname(otmp));
X			    doknown = TRUE;
X			}
X			if (!Blind)
X			    post_engr_text = "Gravel flies up from the floor.";
X			else
X			    post_engr_text = "You hear drilling!";
X			break;
X
X		    /* type = BURN wands */
X		    case WAN_FIRE:
X			ptext = TRUE;
X			type  = BURN;
X			if(!objects[otmp->otyp].oc_name_known) {
X	    		if (flags.verbose)
X			    pline("This %s is a wand of fire!", xname(otmp));
X			    doknown = TRUE;
X			}
X			if (!Blind)
X			    post_engr_text = "Flames fly from the wand.";
X			else
X			    post_engr_text = "You feel the wand heat up.";
X			break;
X		    case WAN_LIGHTNING:
X			ptext = TRUE;
X			type  = BURN;
X			if(!objects[otmp->otyp].oc_name_known) {
X	    		    if (flags.verbose)
X				pline("This %s is a wand of lightning!",
X					xname(otmp));
X			    doknown = TRUE;
X			}
X			if (!Blind) {
X			    post_engr_text = "Lightning arcs from the wand.";
X			    doblind = TRUE;
X			} else
X			    post_engr_text = "You hear crackling!";
X			break;
X
X		    /* type = MARK wands */
X		    /* type = BLOOD wands */
X		    }
X		} else /* end if zappable */
X		    if (Levitation) {
X			You("can't reach the floor!");
X			return(0);
X		    }
X		break;
X
X	    case WEAPON_CLASS:
X		if(is_blade(otmp))
X		    if ((int)otmp->spe > -3)
X			type = ENGRAVE;
X		    else
X			Your("%s too dull for engraving.", aobjnam(otmp,"are"));
X		break;
X
X	    case TOOL_CLASS:
X		if(otmp == ublindf) {
X		    pline(
X		"That is a bit difficult to engrave with, don't you think?");
X		    return(0);
X		}
X		switch (otmp->otyp)  {
X		    case MAGIC_MARKER:
X			if (otmp->spe <= 0)
X			    Your("marker has dried out.");
X			else
X			    type = MARK;
X			break;
X		    case TOWEL:
X 			/* Can't really engrave with a towel */
X			ptext = FALSE;
X			if (oep)
X			    if ((oep->engr_type == DUST ) ||
X				(oep->engr_type == BLOOD) ||
X				(oep->engr_type == MARK )) {
X				if (!Blind)
X				    You("wipe out the message here.");
X				else
X				    Your("%s gets dusty.", xname(otmp));
X				dengr = TRUE;
X			    } else
X				Your("%s can't wipe out this engraving.",
X				     xname(otmp));
X			else
X			    Your("%s gets dusty.", xname(otmp));
X			break;
X		    default:
X			break;
X		}
X		break;
X
X	    case VENOM_CLASS:
X#ifdef WIZARD
X		if (wizard) {
X		    pline("Writing a poison pen letter??");
X		    break;
X		}
X#endif
X	    case ILLOBJ_CLASS:
X		impossible("You're engraving with an illegal object!");
X		break;
X	}
X
X	/* End of implement setup */
X
X	/* Identify stylus */
X	if (doknown) {
X	    makeknown(otmp->otyp);
X	    more_experienced(0,10);
X	}
X
X	if (teleengr) {
X	    register int tx,ty;
X
X	    do  {
X 		tx = rn1(COLNO-3,2);
X		ty = rn2(ROWNO);
X	    } while(!goodpos(tx,ty, (struct monst *)0, (struct permonst *)0));
X
X	    oep->engr_x = tx;
X	    oep->engr_y = ty;
X
X	    oep = (struct engr *)0;
X	}
X
X	if (dengr) {
X	    del_engr (oep);
X	    oep = (struct engr *)0;
X	}
X
X	/* Something has changed the engraving here */
X	if (*buf) {
X	    make_engr_at(u.ux, u.uy, buf, moves, type);
X	    pline("The engraving now reads: \"%s\".", buf);
X	    ptext = FALSE;
X	}
X
X	if (zapwand && (otmp->spe < 0)) {
X	    pline("%s %sturns to dust.",
X		  The(xname(otmp)), Blind ? "" : "glows violently, then ");
XYou("are not going to get anywhere trying to write in the dust with your dust.");
X	    useup(otmp);
X	    ptext = FALSE;
X	}
X
X	if (!ptext) {		/* Early exit for some implements. */
X	    if (Levitation && (otmp->oclass == WAND_CLASS))
X		You("can't reach the floor!");
X	    return(1);
X	}
X
X	/* Special effects should have deleted the current engraving (if
X	 * possible) by now.
X	 */
X
X	if (oep) {
X	    register char c = 'n';
X
X	    /* Give player the choice to add to engraving. */
X
X	    if ( (type == oep->engr_type) && (!Blind ||
X		 (oep->engr_type == BURN) || (oep->engr_type == ENGRAVE)) ) {
X	    	c = yn_function("Do you want to add to the current engraving?",
X				ynqchars, 'y');
X		if (c == 'q') {
X		    pline("Never mind.");
X		    return(0);
X		}
X	    }
X
X	    if (c == 'n' || Blind)
X
X		if( (oep->engr_type == DUST) || (oep->engr_type == BLOOD) ||
X		    (oep->engr_type == MARK) ) {
X		    if (!Blind) {
X			You("wipe out the message that was %s here.",
X			    ((oep->engr_type == DUST)  ? "written in the dust" :
X			    ((oep->engr_type == BLOOD) ? "scrawled in blood"   :
X							 "written")));
X			del_engr(oep);
X			oep = (struct engr *)0;
X		    } else
X		   /* Don't delete engr until after we *know* we're engraving */
X			eow = TRUE;
X		} else
X		    if ( (type == DUST) || (type == MARK) || (type == BLOOD) ) {
X			You(
X		       "cannot wipe out the message that is %s the floor here.",
X		            (oep->engr_type == BURN) ? "burned into" :
X			    "engraved in");
X			return(1);
X		    } else
X			if ( (type != oep->engr_type) || (c == 'n') ) {
X			    if (!Blind || !Levitation)
X				You("will overwrite the current message.");
X			    eow = TRUE;
X			}
X	}
X
X	switch(type){
X	    default:
X		everb = (oep && !eow ? "add to the weird writing on" :
X				       "write strangely on");
X		eloc  = "the floor";
X		break;
X	    case DUST:
X		everb = (oep && !eow ? "add to the writing in" :
X				       "write in");
X		eloc = "the dust";
X		break;
X	    case ENGRAVE:
X		everb = (oep && !eow ? "add to the engraving in" :
X				       "engrave in");
X		eloc = "the floor";
X		break;
X	    case BURN:
X		everb = (oep && !eow ? "add to the text burned into" :
X				       "burn into");
X		eloc = "the floor";
X		break;
X	    case MARK:
X		everb = (oep && !eow ? "add to the graffiti on" :
X				       "scribble on");
X		eloc = "the floor";
X		break;
X	    case BLOOD:
X		everb = (oep && !eow ? "add to the scrawl on" :
X				       "scrawl on");
X		eloc = "the floor";
X		break;
X	}
X
X	/* Tell adventurer what is going on */
X	if (otmp != &zeroobj)
X	    You("%s %s with %s.", everb, eloc, doname(otmp));
X	else
X	    You("%s %s with your %s.", everb, eloc,
X		makeplural(body_part(FINGER)));
X
X	/* Prompt for engraving! */
X	Sprintf(qbuf,"What do you want to %s %s here?", everb, eloc);
X	getlin(qbuf, ebuf);
X	clear_nhwindow(WIN_MESSAGE);
X
X	/* Mix up engraving if surface or state of mind is unsound.  */
X	/* Original kludge by stewr 870708.  modified by njm 910722. */
X	for (sp = ebuf; *sp; sp++)
X	    if ( ((type == DUST || type == BLOOD) && !rn2(25)) ||
X		 (Blind   && !rn2(9)) || (Confusion     && !rn2(12)) ||
X		 (Stunned && !rn2(4)) || (Hallucination && !rn2(1)) )
X		 *sp = '!' + rn2(93); /* ASCII-code only */
X
X	/* Count the actual # of chars engraved not including spaces */
X	len = strlen(ebuf);
X
X	for (sp = ebuf, spct = 0; *sp; sp++) if (isspace(*sp)) spct++;
X
X	if ( (len == spct) || index(ebuf, '\033') ) {
X	    if (zapwand) {
X		if (!Blind)
X		    pline("%s glows, then fades.", The(xname(otmp)));
X	    	return(1);
X	    } else {
X		pline("Never mind.");
X		return(0);
X	    }
X	}
X
X	len -= spct;
X
X	/* Previous engraving is overwritten */
X	if (eow) {
X	    del_engr(oep);
X	    oep = (struct engr *)0;
X	}
X
X	/* Figure out how long it took to engrave, and if player has
X	 * engraved too much.
X	 */
X	switch(type){
X	    default:
X		multi = -(len/10);
X		if (multi) nomovemsg = "You finish your weird engraving.";
X		break;
X	    case DUST:
X		multi = -(len/10);
X		if (multi) nomovemsg = "You finish writing in the dust.";
X		break;
X	    case ENGRAVE:
X		multi = -(len/10);
X		if ((otmp->oclass == WEAPON_CLASS) &&
X		    ((otmp->otyp != ATHAME) || otmp->cursed)) {
X		    multi = -len;
X		    maxelen = ((otmp->spe + 3) * 2) + 1;
X			/* -2 = 3, -1 = 5, 0 = 7, +1 = 9, +2 = 11
X			 * Note: this does not allow a +0 anything (except
X			 *	 an athame) to engrave "Elbereth" all at once.
X			 *	 However, you could now engrave "Elb", then
X			 *	 "ere", then "th".
X			 */
X		    Your("%s dull.", aobjnam(otmp, "get"));
X		    if (len > maxelen) {
X		    	multi = -maxelen;
X			otmp->spe = -3;
X		    } else
X			if (len > 1) otmp->spe -= len >> 1;
X			else otmp->spe -= 1; /* Prevent infinite engraving */
X		} else
X		    if ( (otmp->oclass == RING_CLASS) ||
X			 (otmp->oclass == GEM_CLASS) )
X			multi = -len;
X		if (multi) nomovemsg = "You finish engraving.";
X		break;
X	    case BURN:
X		multi = -(len/10);
X		if (multi)
X		    nomovemsg =
X			"You finish burning your message into the floor.";
X		break;
X	    case MARK:
X		multi = -(len/10);
X		if ((otmp->oclass == TOOL_CLASS) &&
X		    (otmp->otyp == MAGIC_MARKER)) {
X		    maxelen = (otmp->spe) * 2; /* one charge / 2 letters */
X		    if (len > maxelen) {
X			Your("marker dries out.");
X			otmp->spe = 0;
X			multi = -(maxelen/10);
X		    } else
X			if (len > 1) otmp->spe -= len >> 1;
X			else otmp->spe -= 1; /* Prevent infinite grafitti */
X		}
X		if (multi) nomovemsg = "You finish defacing the dungeon.";
X		break;
X	    case BLOOD:
X		multi = -(len/10);
X		if (multi) nomovemsg = "You finish scrawling.";
X		break;
X	}
X
X	/* Chop engraving down to size if necessary */
X	if (len > maxelen) {
X	    for (sp = ebuf; (maxelen && *sp); sp++)
X		if (!isspace(*sp)) maxelen--;
X	    if (!maxelen && *sp) {
X		*sp = (char)0;
X		if (multi) nomovemsg = "You cannot write any more.";
X		You("only are able to write \"%s\"", ebuf);
X	    }
X	}
X
X	/* Add to existing engraving */
X	if (oep) Strcpy(buf, oep->engr_txt);	
X
X	(void) strncat(buf, ebuf, (BUFSZ - (int)strlen(buf) - 1));
X
X	make_engr_at(u.ux, u.uy, buf, (moves - multi), type);
X
X	if (post_engr_text) pline(post_engr_text);
X
X	if (doblind) {
X	    You("are blinded by the flash!");
X	    make_blinded((long)rnd(50),FALSE);
X	}
X
X	return(1);
X}
X
Xvoid
Xsave_engravings(fd, mode)
Xint fd, mode;
X{
X	register struct engr *ep = head_engr;
X	register struct engr *ep2;
X#ifdef GCC_WARN
X	static long nulls[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
X#endif
X	while(ep) {
X	    ep2 = ep->nxt_engr;
X	    if(ep->engr_lth && ep->engr_txt[0]){
X		bwrite(fd, (genericptr_t)&(ep->engr_lth), sizeof(ep->engr_lth));
X		bwrite(fd, (genericptr_t)ep, sizeof(struct engr) + ep->engr_lth);
X	    }
X	    if (mode & FREE_SAVE)
X		dealloc_engr(ep);
X	    ep = ep2;
X	}
X
X#ifdef GCC_WARN
X	bwrite(fd, (genericptr_t)nulls, sizeof(unsigned));
X#else
X	bwrite(fd, (genericptr_t)nul, sizeof(unsigned));
X#endif
X
X	if (mode & FREE_SAVE)
X	    head_engr = 0;
X}
X
Xvoid
Xrest_engravings(fd) int fd; {
Xregister struct engr *ep;
Xunsigned lth;
X	head_engr = 0;
X	while(1) {
X		mread(fd, (genericptr_t) &lth, sizeof(unsigned));
X		if(lth == 0) return;
X		ep = newengr(lth);
X		mread(fd, (genericptr_t) ep, sizeof(struct engr) + lth);
X		ep->nxt_engr = head_engr;
X		head_engr = ep;
X		ep->engr_txt = (char *) (ep + 1);	/* Andreas Bormann */
X		/* mark as finished for bones levels -- no problem for
X		 * normal levels as the player must have finished engraving
X		 * to be able to move again */
X		ep->engr_time = moves;
X	}
X}
X
XSTATIC_OVL void
Xdel_engr(ep) register struct engr *ep; {
Xregister struct engr *ept;
X	if(ep == head_engr)
X		head_engr = ep->nxt_engr;
X	else {
X		for(ept = head_engr; ept; ept = ept->nxt_engr) {
X			if(ept->nxt_engr == ep) {
X				ept->nxt_engr = ep->nxt_engr;
X				goto fnd;
X			}
X		}
X		impossible("Error in del_engr?");
X		return;
X	fnd:	;
X	}
X	dealloc_engr(ep);
X}
X
X#endif /* OVLB */
X
X/*engrave.c*/
END_OF_FILE
if test 23761 -ne `wc -c <'src/engrave.c'`; then
    echo shar: \"'src/engrave.c'\" unpacked with wrong size!
fi
# end of 'src/engrave.c'
fi
if test -f 'sys/share/lev_yacc.c2' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/share/lev_yacc.c2'\"
else
echo shar: Extracting \"'sys/share/lev_yacc.c2'\" \(30244 characters\)
sed "s/^X//" >'sys/share/lev_yacc.c2' <<'END_OF_FILE'
X	/*
X	** code supplied by user is placed in this switch
X	*/
X	switch( yytmp )
X	{
X		
Xcase 7:
X# line 193 "lev_comp.y"
X{
X			  int fout, i;
X
X			if (fatal_error > 0) {
X				fprintf(stderr,
X			      "%s : %d errors detected. No output created!\n",
X					fname, fatal_error);
X			} else {
X				char lbuf[20];
X				Strcpy(lbuf, yypvt[-4].map);
X				Strcat(lbuf, LEV_EXT);
X#ifdef MAC_THINKC5
X				fout = open(lbuf, O_WRONLY|O_CREAT|O_BINARY);
X#else
X				fout = open(lbuf, O_WRONLY|O_CREAT|O_BINARY, OMASK);
X#endif
X				if (fout < 0) {
X					yyerror("Can't open output file!!");
X					exit(1);
X				}
X				maze.flags = yypvt[-3].i;
X				memcpy(&(maze.init_lev), &(init_lev),
X				       sizeof(lev_init));
X				maze.numpart = npart;
X				maze.parts = NewTab(mazepart, npart);
X				for(i=0;i<npart;i++)
X				    maze.parts[i] = tmppart[i];
X				write_maze(fout, &maze);
X				(void) close(fout);
X				npart = 0;
X			}
X		  } break;
Xcase 8:
X# line 228 "lev_comp.y"
X{
X			int fout, i;
X
X			if (fatal_error > 0) {
X			    fprintf(stderr,
X			      "%s : %d errors detected. No output created!\n",
X					fname, fatal_error);
X			} else {
X				char lbuf[20];
X				Strcpy(lbuf, yypvt[-6].map);
X				Strcat(lbuf, LEV_EXT);
X#ifdef MAC_THINKC5
X				fout = open(lbuf, O_WRONLY|O_CREAT|O_BINARY);
X#else
X				fout = open(lbuf, O_WRONLY|O_CREAT|O_BINARY, OMASK);
X#endif
X				if (fout < 0) {
X					yyerror("Can't open output file!!");
X					exit(1);
X				}
X				special_lev.flags = yypvt[-5].i;
X				memcpy(&(special_lev.init_lev), &(init_lev),
X				       sizeof(lev_init));
X				special_lev.nroom = nrooms;
X				special_lev.rooms = NewTab(room, nrooms);
X				for(i=0; i<nrooms; i++)
X				    special_lev.rooms[i] = tmproom[i];
X				special_lev.ncorr = ncorridor;
X				special_lev.corrs = NewTab(corridor, ncorridor);
X				for(i=0; i<ncorridor; i++)
X				    special_lev.corrs[i] = tmpcor[i];
X				if (check_subrooms())
X				    write_lev(fout, &special_lev);
X				free_rooms(special_lev.rooms,special_lev.nroom);
X				nrooms = 0;
X				ncorridor = 0;
X				(void) close(fout);
X			}
X		  } break;
Xcase 9:
X# line 270 "lev_comp.y"
X{
X			if (index(yypvt[-0].map, '.'))
X			    yyerror("Invalid dot ('.') in level name.");
X			if (strlen(yypvt[-0].map) > 8)
X			    yyerror("Level names limited to 8 characters.");
X			yyval.map = yypvt[-0].map;
X			special_lev.nrobjects = 0;
X			special_lev.nrmonst = 0;
X		  } break;
Xcase 10:
X# line 282 "lev_comp.y"
X{
X			init_lev.init_present = FALSE;
X			yyval.i = 0;
X		  } break;
Xcase 11:
X# line 287 "lev_comp.y"
X{
X			init_lev.init_present = TRUE;
X			if((init_lev.fg = what_map_char(yypvt[-10].i)) == INVALID_TYPE)
X			    yyerror("Invalid foreground type.");
X			if((init_lev.bg = what_map_char(yypvt[-8].i)) == INVALID_TYPE)
X			    yyerror("Invalid background type.");
X			init_lev.smoothed = yypvt[-6].i;
X			init_lev.joined = yypvt[-4].i;
X			init_lev.lit = yypvt[-2].i;
X			init_lev.walled = yypvt[-0].i;
X			yyval.i = 1;
X		  } break;
Xcase 14:
X# line 306 "lev_comp.y"
X{
X			yyval.i = 0;
X		  } break;
Xcase 15:
X# line 310 "lev_comp.y"
X{
X			yyval.i = lev_flags;
X		  } break;
Xcase 16:
X# line 316 "lev_comp.y"
X{
X			lev_flags |= yypvt[-0].i;
X		  } break;
Xcase 17:
X# line 320 "lev_comp.y"
X{
X			lev_flags |= yypvt[-0].i;
X		  } break;
Xcase 20:
X# line 330 "lev_comp.y"
X{
X			int i, j;
X
X			i = strlen(yypvt[-0].map) + 1;
X			j = tmpmessage[0] ? strlen(tmpmessage) : 0;
X			if(i+j > 255) {
X			   yyerror("Message string too long (>256 characters)");
X			} else {
X			    if(j) tmpmessage[j++] = '\n';
X			    strncpy(tmpmessage+j, yypvt[-0].map, i-1);
X			    tmpmessage[j+i-1] = 0;
X			}
X		  } break;
Xcase 23:
X# line 350 "lev_comp.y"
X{
X			if(special_lev.nrobjects) {
X			    yyerror("Object registers already initialized!");
X			} else {
X			    special_lev.nrobjects = n_olist;
X			    special_lev.robjects = (char *) alloc(n_olist);
X			    (void) memcpy((genericptr_t)special_lev.robjects,
X					  (genericptr_t)olist, n_olist);
X			}
X		  } break;
Xcase 24:
X# line 361 "lev_comp.y"
X{
X			if(special_lev.nrmonst) {
X			    yyerror("Monster registers already initialized!");
X			} else {
X			    special_lev.nrmonst = n_mlist;
X			    special_lev.rmonst = (char *) alloc(n_mlist);
X			    (void) memcpy((genericptr_t)special_lev.rmonst,
X					  (genericptr_t)mlist, n_mlist);
X			  }
X		  } break;
Xcase 25:
X# line 374 "lev_comp.y"
X{
X			tmproom[nrooms] = New(room);
X			(void) memset((genericptr_t) tmproom[nrooms], 0,
X					sizeof *tmproom[nrooms]);
X			tmproom[nrooms]->name = (char *) 0;
X			tmproom[nrooms]->parent = (char *) 0;
X			tmproom[nrooms]->rtype = 0;
X			tmproom[nrooms]->rlit = 0;
X			tmproom[nrooms]->xalign = ERR;
X			tmproom[nrooms]->yalign = ERR;
X			tmproom[nrooms]->x = 0;
X			tmproom[nrooms]->y = 0;
X			tmproom[nrooms]->w = 2;
X			tmproom[nrooms]->h = 2;
X			in_room = 1;
X		  } break;
Xcase 31:
X# line 402 "lev_comp.y"
X{
X			tmpcor[0] = New(corridor);
X			tmpcor[0]->src.room = -1;
X			ncorridor = 1;
X		  } break;
Xcase 34:
X# line 414 "lev_comp.y"
X{
X			tmpcor[ncorridor] = New(corridor);
X			tmpcor[ncorridor]->src.room = yypvt[-2].corpos.room;
X			tmpcor[ncorridor]->src.wall = yypvt[-2].corpos.wall;
X			tmpcor[ncorridor]->src.door = yypvt[-2].corpos.door;
X			tmpcor[ncorridor]->dest.room = yypvt[-0].corpos.room;
X			tmpcor[ncorridor]->dest.wall = yypvt[-0].corpos.wall;
X			tmpcor[ncorridor]->dest.door = yypvt[-0].corpos.door;
X			ncorridor++;
X		  } break;
Xcase 35:
X# line 425 "lev_comp.y"
X{
X			tmpcor[ncorridor]->src.room = yypvt[-2].corpos.room;
X			tmpcor[ncorridor]->src.wall = yypvt[-2].corpos.wall;
X			tmpcor[ncorridor]->src.door = yypvt[-2].corpos.door;
X			tmpcor[ncorridor]->dest.room = -1;
X			tmpcor[ncorridor]->dest.wall = yypvt[-0].i;
X			ncorridor++;
X		  } break;
Xcase 36:
X# line 436 "lev_comp.y"
X{
X			if (yypvt[-5].i >= nrooms)
X			    yyerror("Wrong room number!");
X			yyval.corpos.room = yypvt[-5].i;
X			yyval.corpos.wall = yypvt[-3].i;
X			yyval.corpos.door = yypvt[-1].i;
X		  } break;
Xcase 37:
X# line 446 "lev_comp.y"
X{
X			store_room();
X		  } break;
Xcase 38:
X# line 450 "lev_comp.y"
X{
X			store_room();
X		  } break;
Xcase 39:
X# line 456 "lev_comp.y"
X{
X			tmproom[nrooms] = New(room);
X			(void) memset((genericptr_t) tmproom[nrooms], 0,
X					sizeof *tmproom[nrooms]);
X			tmproom[nrooms]->parent = dup_string(yypvt[-1].map);
X			tmproom[nrooms]->name = (char *) 0;
X			tmproom[nrooms]->rtype = yypvt[-9].i;
X			tmproom[nrooms]->rlit = yypvt[-7].i;
X			tmproom[nrooms]->filled = yypvt[-0].i;
X			tmproom[nrooms]->xalign = ERR;
X			tmproom[nrooms]->yalign = ERR;
X			tmproom[nrooms]->x = current_coord.x;
X			tmproom[nrooms]->y = current_coord.y;
X			tmproom[nrooms]->w = current_size.width;
X			tmproom[nrooms]->h = current_size.height;
X			in_room = 1;
X		  } break;
Xcase 40:
X# line 476 "lev_comp.y"
X{
X			tmproom[nrooms] = New(room);
X			(void) memset((genericptr_t) tmproom[nrooms], 0,
X					sizeof *tmproom[nrooms]);
X			tmproom[nrooms]->name = (char *) 0;
X			tmproom[nrooms]->parent = (char *) 0;
X			tmproom[nrooms]->rtype = yypvt[-9].i;
X			tmproom[nrooms]->rlit = yypvt[-7].i;
X			tmproom[nrooms]->filled = yypvt[-0].i;
X			tmproom[nrooms]->xalign = current_align.x;
X			tmproom[nrooms]->yalign = current_align.y;
X			tmproom[nrooms]->x = current_coord.x;
X			tmproom[nrooms]->y = current_coord.y;
X			tmproom[nrooms]->w = current_size.width;
X			tmproom[nrooms]->h = current_size.height;
X			in_room = 1;
X		  } break;
Xcase 41:
X# line 496 "lev_comp.y"
X{
X			yyval.i = 1;
X		  } break;
Xcase 42:
X# line 500 "lev_comp.y"
X{
X			yyval.i = yypvt[-0].i;
X		  } break;
Xcase 43:
X# line 506 "lev_comp.y"
X{
X			if ( yypvt[-3].i < 1 || yypvt[-3].i > 5 ||
X			    yypvt[-1].i < 1 || yypvt[-1].i > 5 ) {
X			    yyerror("Room position should be between 1 & 5!");
X			} else {
X			    current_coord.x = yypvt[-3].i;
X			    current_coord.y = yypvt[-1].i;
X			}
X		  } break;
Xcase 44:
X# line 516 "lev_comp.y"
X{
X			current_coord.x = current_coord.y = ERR;
X		  } break;
Xcase 45:
X# line 522 "lev_comp.y"
X{
X			if ( yypvt[-3].i < 0 || yypvt[-1].i < 0) {
X			    yyerror("Invalid subroom position !");
X			} else {
X			    current_coord.x = yypvt[-3].i;
X			    current_coord.y = yypvt[-1].i;
X			}
X		  } break;
Xcase 46:
X# line 531 "lev_comp.y"
X{
X			current_coord.x = current_coord.y = ERR;
X		  } break;
Xcase 47:
X# line 537 "lev_comp.y"
X{
X			current_align.x = yypvt[-3].i;
X			current_align.y = yypvt[-1].i;
X		  } break;
Xcase 48:
X# line 542 "lev_comp.y"
X{
X			current_align.x = current_align.y = ERR;
X		  } break;
Xcase 49:
X# line 548 "lev_comp.y"
X{
X			current_size.width = yypvt[-3].i;
X			current_size.height = yypvt[-1].i;
X		  } break;
Xcase 50:
X# line 553 "lev_comp.y"
X{
X			current_size.height = current_size.width = ERR;
X		  } break;
Xcase 66:
X# line 578 "lev_comp.y"
X{
X			if (tmproom[nrooms]->name)
X			    yyerror("This room already has a name!");
X			else
X			    tmproom[nrooms]->name = dup_string(yypvt[-0].map);
X		  } break;
Xcase 67:
X# line 587 "lev_comp.y"
X{
X			if (tmproom[nrooms]->chance)
X			    yyerror("This room already assigned a chance!");
X			else if (tmproom[nrooms]->rtype == OROOM)
X			    yyerror("Only typed rooms can have a chance!");
X			else if (yypvt[-0].i < 1 || yypvt[-0].i > 99)
X			    yyerror("The chance is supposed to be precentile.");
X			else
X			    tmproom[nrooms]->chance = yypvt[-0].i;
X		   } break;
Xcase 68:
X# line 600 "lev_comp.y"
X{
X			/* ERR means random here */
X			if (yypvt[-2].i == ERR && yypvt[-0].i != ERR) {
X		     yyerror("If the door wall is random, so must be its pos!");
X			} else {
X			    tmprdoor[ndoor] = New(room_door);
X			    tmprdoor[ndoor]->secret = yypvt[-6].i;
X			    tmprdoor[ndoor]->mask = yypvt[-4].i;
X			    tmprdoor[ndoor]->wall = yypvt[-2].i;
X			    tmprdoor[ndoor]->pos = yypvt[-0].i;
X			    ndoor++;
X			}
X		  } break;
Xcase 75:
X# line 628 "lev_comp.y"
X{
X			maze.filling = yypvt[-0].i;
X			if (index(yypvt[-2].map, '.'))
X			    yyerror("Invalid dot ('.') in level name.");
X			if (strlen(yypvt[-2].map) > 8)
X			    yyerror("Level names limited to 8 characters.");
X			yyval.map = yypvt[-2].map;
X			in_room = 0;
X		  } break;
Xcase 76:
X# line 640 "lev_comp.y"
X{
X			yyval.i = get_floor_type((char)yypvt[-0].i);
X		  } break;
Xcase 77:
X# line 644 "lev_comp.y"
X{
X			yyval.i = -1;
X		  } break;
Xcase 80:
X# line 654 "lev_comp.y"
X{
X			store_part();
X		  } break;
Xcase 81:
X# line 660 "lev_comp.y"
X{
X			tmppart[npart] = New(mazepart);
X			tmppart[npart]->halign = 1;
X			tmppart[npart]->valign = 1;
X			tmppart[npart]->nrobjects = 0;
X			tmppart[npart]->nloc = 0;
X			tmppart[npart]->nrmonst = 0;
X			tmppart[npart]->xsize = 1;
X			tmppart[npart]->ysize = 1;
X			tmppart[npart]->map = (char **) alloc(sizeof(char *));
X			tmppart[npart]->map[0] = (char *) alloc(1);
X			tmppart[npart]->map[0][0] = STONE;
X			max_x_map = COLNO-1;
X			max_y_map = ROWNO;
X		  } break;
Xcase 82:
X# line 676 "lev_comp.y"
X{
X			tmppart[npart] = New(mazepart);
X			tmppart[npart]->halign = yypvt[-1].i % 10;
X			tmppart[npart]->valign = yypvt[-1].i / 10;
X			tmppart[npart]->nrobjects = 0;
X			tmppart[npart]->nloc = 0;
X			tmppart[npart]->nrmonst = 0;
X			scan_map(yypvt[-0].map);
X		  } break;
Xcase 83:
X# line 688 "lev_comp.y"
X{
X			yyval.i = yypvt[-2].i + (yypvt[-0].i * 10);
X		  } break;
Xcase 90:
X# line 706 "lev_comp.y"
X{
X			if (tmppart[npart]->nrobjects) {
X			    yyerror("Object registers already initialized!");
X			} else {
X			    tmppart[npart]->robjects = (char *)alloc(n_olist);
X			    (void) memcpy((genericptr_t)tmppart[npart]->robjects,
X					  (genericptr_t)olist, n_olist);
X			    tmppart[npart]->nrobjects = n_olist;
X			}
X		  } break;
Xcase 91:
X# line 717 "lev_comp.y"
X{
X			if (tmppart[npart]->nloc) {
X			    yyerror("Location registers already initialized!");
X			} else {
X			    register int i;
X			    tmppart[npart]->rloc_x = (char *) alloc(n_plist);
X			    tmppart[npart]->rloc_y = (char *) alloc(n_plist);
X			    for(i=0;i<n_plist;i++) {
X				tmppart[npart]->rloc_x[i] = plist[i].x;
X				tmppart[npart]->rloc_y[i] = plist[i].y;
X			    }
X			    tmppart[npart]->nloc = n_plist;
X			}
X		  } break;
Xcase 92:
X# line 732 "lev_comp.y"
X{
X			if (tmppart[npart]->nrmonst) {
X			    yyerror("Monster registers already initialized!");
X			} else {
X			    tmppart[npart]->rmonst = (char *) alloc(n_mlist);
X			    (void) memcpy((genericptr_t)tmppart[npart]->rmonst,
X					  (genericptr_t)mlist, n_mlist);
X			    tmppart[npart]->nrmonst = n_mlist;
X			}
X		  } break;
Xcase 93:
X# line 745 "lev_comp.y"
X{
X			if (n_olist < MAX_REGISTERS)
X			    olist[n_olist++] = yypvt[-0].i;
X			else
X			    yyerror("Object list too long!");
X		  } break;
Xcase 94:
X# line 752 "lev_comp.y"
X{
X			if (n_olist < MAX_REGISTERS)
X			    olist[n_olist++] = yypvt[-2].i;
X			else
X			    yyerror("Object list too long!");
X		  } break;
Xcase 95:
X# line 761 "lev_comp.y"
X{
X			if (n_mlist < MAX_REGISTERS)
X			    mlist[n_mlist++] = yypvt[-0].i;
X			else
X			    yyerror("Monster list too long!");
X		  } break;
Xcase 96:
X# line 768 "lev_comp.y"
X{
X			if (n_mlist < MAX_REGISTERS)
X			    mlist[n_mlist++] = yypvt[-2].i;
X			else
X			    yyerror("Monster list too long!");
X		  } break;
Xcase 97:
X# line 777 "lev_comp.y"
X{
X			if (n_plist < MAX_REGISTERS)
X			    plist[n_plist++] = current_coord;
X			else
X			    yyerror("Location list too long!");
X		  } break;
Xcase 98:
X# line 784 "lev_comp.y"
X{
X			if (n_plist < MAX_REGISTERS)
X			    plist[n_plist++] = current_coord;
X			else
X			    yyerror("Location list too long!");
X		  } break;
Xcase 121:
X# line 819 "lev_comp.y"
X{
X			tmpmonst[nmons] = New(monster);
X			tmpmonst[nmons]->x = current_coord.x;
X			tmpmonst[nmons]->y = current_coord.y;
X			tmpmonst[nmons]->class = yypvt[-4].i;
X			tmpmonst[nmons]->peaceful = -1; /* no override */
X			tmpmonst[nmons]->asleep = -1;
X			tmpmonst[nmons]->align = - MAX_REGISTERS - 2;
X			tmpmonst[nmons]->name = (char *) 0;
X			tmpmonst[nmons]->appear = 0;
X			tmpmonst[nmons]->appear_as = (char *) 0;
X			if (!in_room)
X			    check_coord(current_coord.x, current_coord.y,
X					"Monster");
X			if (!yypvt[-2].map)
X			    tmpmonst[nmons]->id = -1;
X			else {
X				int token = get_monster_id(yypvt[-2].map, (char) yypvt[-4].i);
X				if (token == ERR) {
X				    yywarning("Illegal monster name!  Making random monster.");
X				    tmpmonst[nmons]->id = -1;
X				} else
X				    tmpmonst[nmons]->id = token;
X			}
X		  } break;
Xcase 122:
X# line 845 "lev_comp.y"
X{
X			nmons++;
X		  } break;
Xcase 125:
X# line 855 "lev_comp.y"
X{
X			tmpmonst[nmons]->name = dup_string(yypvt[-0].map);
X		  } break;
Xcase 126:
X# line 859 "lev_comp.y"
X{
X			tmpmonst[nmons]->peaceful = yypvt[-0].i;
X		  } break;
Xcase 127:
X# line 863 "lev_comp.y"
X{
X			tmpmonst[nmons]->asleep = yypvt[-0].i;
X		  } break;
Xcase 128:
X# line 867 "lev_comp.y"
X{
X			tmpmonst[nmons]->align = yypvt[-0].i;
X		  } break;
Xcase 129:
X# line 871 "lev_comp.y"
X{
X			tmpmonst[nmons]->appear = yypvt[-1].i;
X			tmpmonst[nmons]->appear_as = dup_string(yypvt[-0].map);
X		  } break;
Xcase 130:
X# line 878 "lev_comp.y"
X{
X			tmpobj[nobj] = New(object);
X			tmpobj[nobj]->x = current_coord.x;
X			tmpobj[nobj]->y = current_coord.y;
X			tmpobj[nobj]->class = yypvt[-4].i;
X			tmpobj[nobj]->corpsenm = -1;	/* init as none */
X			tmpobj[nobj]->curse_state = -1;
X			tmpobj[nobj]->name = (char *) 0;
X			if (!in_room)
X			    check_coord(current_coord.x, current_coord.y,
X					"Object");
X			if (!yypvt[-2].map)
X			    tmpobj[nobj]->id = -1;
X			else {
X				int token = get_object_id(yypvt[-2].map);
X				if (token == ERR) {
X				    yywarning("Illegal object name!  Making random object.");
X				    tmpobj[nobj]->id = -1;
X				} else
X				    tmpobj[nobj]->id = token;
X			}
X		  } break;
Xcase 131:
X# line 901 "lev_comp.y"
X{
X			nobj++;
X		  } break;
Xcase 132:
X# line 907 "lev_comp.y"
X{
X			tmpobj[nobj]->spe = -127;
X		  } break;
Xcase 133:
X# line 911 "lev_comp.y"
X{
X			int token = get_monster_id(yypvt[-2].map, (char)0);
X			if (token == ERR)	/* "random" */
X			    tmpobj[nobj]->corpsenm = -2;
X			else
X			    tmpobj[nobj]->corpsenm = token;
X			tmpobj[nobj]->spe = yypvt[-0].i;
X		  } break;
Xcase 134:
X# line 920 "lev_comp.y"
X{
X			tmpobj[nobj]->curse_state = yypvt[-4].i;
X			tmpobj[nobj]->spe = yypvt[-2].i;
X			if (yypvt[-0].map)
X			    tmpobj[nobj]->name = dup_string(yypvt[-0].map);
X			else
X			    tmpobj[nobj]->name = (char *) 0;
X		  } break;
Xcase 138:
X# line 936 "lev_comp.y"
X{
X			yyval.i = -127;
X		  } break;
Xcase 139:
X# line 942 "lev_comp.y"
X{
X			tmpdoor[ndoor] = New(door);
X			tmpdoor[ndoor]->x = current_coord.x;
X			tmpdoor[ndoor]->y = current_coord.y;
X			tmpdoor[ndoor]->mask = yypvt[-2].i;
X			if(current_coord.x >= 0 && current_coord.y >= 0 &&
X			   tmpmap[current_coord.y][current_coord.x] != DOOR &&
X			   tmpmap[current_coord.y][current_coord.x] != SDOOR)
X			    yyerror("Door decl doesn't match the map");
X			ndoor++;
X		  } break;
Xcase 140:
X# line 956 "lev_comp.y"
X{
X			tmptrap[ntrap] = New(trap);
X			tmptrap[ntrap]->x = current_coord.x;
X			tmptrap[ntrap]->y = current_coord.y;
X			tmptrap[ntrap]->type = yypvt[-2].i;
X			if (!in_room)
X			    check_coord(current_coord.x, current_coord.y,
X					"Trap");
X			ntrap++;
X		  } break;
Xcase 141:
X# line 969 "lev_comp.y"
X{
X		        int x, y, dir;
X
X			tmpdb[ndb] = New(drawbridge);
X			x = tmpdb[ndb]->x = current_coord.x;
X			y = tmpdb[ndb]->y = current_coord.y;
X			/* convert dir from a DIRECTION to a DB_DIR */
X			dir = yypvt[-2].i;
X			switch(dir) {
X			case W_NORTH: dir = DB_NORTH; y--; break;
X			case W_SOUTH: dir = DB_SOUTH; y++; break;
X			case W_EAST:  dir = DB_EAST;  x++; break;
X			case W_WEST:  dir = DB_WEST;  x--; break;
X			default:
X			    yyerror("Invalid drawbridge direction");
X			    break;
X			}
X			tmpdb[ndb]->dir = dir;
X			if (current_coord.x >= 0 && current_coord.y >= 0 &&
X			    !IS_WALL(tmpmap[y][x])) {
X			    char ebuf[60];
X			    Sprintf(ebuf,
X				    "Wall needed for drawbridge (%02d, %02d)",
X				    current_coord.x, current_coord.y);
X			    yyerror(ebuf);
X			}
X
X			if ( yypvt[-0].i == D_ISOPEN )
X			    tmpdb[ndb]->db_open = 1;
X			else if ( yypvt[-0].i == D_CLOSED )
X			    tmpdb[ndb]->db_open = 0;
X			else
X			    yyerror("A drawbridge can only be open or closed!");
X			ndb++;
X		   } break;
Xcase 142:
X# line 1007 "lev_comp.y"
X{
X			tmpwalk[nwalk] = New(walk);
X			tmpwalk[nwalk]->x = current_coord.x;
X			tmpwalk[nwalk]->y = current_coord.y;
X			tmpwalk[nwalk]->dir = yypvt[-0].i;
X			nwalk++;
X		  } break;
Xcase 143:
X# line 1017 "lev_comp.y"
X{
X			wallify_map();
X		  } break;
Xcase 144:
X# line 1023 "lev_comp.y"
X{
X			tmplad[nlad] = New(lad);
X			tmplad[nlad]->x = current_coord.x;
X			tmplad[nlad]->y = current_coord.y;
X			tmplad[nlad]->up = yypvt[-0].i;
X			if (!in_room)
X			    check_coord(current_coord.x, current_coord.y,
X					"Ladder");
X			nlad++;
X		  } break;
Xcase 145:
X# line 1036 "lev_comp.y"
X{
X			tmpstair[nstair] = New(stair);
X			tmpstair[nstair]->x = current_coord.x;
X			tmpstair[nstair]->y = current_coord.y;
X			tmpstair[nstair]->up = yypvt[-0].i;
X			if (!in_room)
X			    check_coord(current_coord.x, current_coord.y,
X					"Stairway");
X			nstair++;
X		  } break;
Xcase 146:
X# line 1049 "lev_comp.y"
X{
X			tmplreg[nlreg] = New(lev_region);
X			tmplreg[nlreg]->in_islev = yypvt[-0].i;
X			tmplreg[nlreg]->inarea.x1 = current_region.x1;
X			tmplreg[nlreg]->inarea.y1 = current_region.y1;
X			tmplreg[nlreg]->inarea.x2 = current_region.x2;
X			tmplreg[nlreg]->inarea.y2 = current_region.y2;
X		  } break;
Xcase 147:
X# line 1058 "lev_comp.y"
X{
X			tmplreg[nlreg]->del_islev = yypvt[-2].i;
X			tmplreg[nlreg]->delarea.x1 = current_region.x1;
X			tmplreg[nlreg]->delarea.y1 = current_region.y1;
X			tmplreg[nlreg]->delarea.x2 = current_region.x2;
X			tmplreg[nlreg]->delarea.y2 = current_region.y2;
X			if(yypvt[-0].i)
X			    tmplreg[nlreg]->rtype = LR_UPSTAIR;
X			else
X			    tmplreg[nlreg]->rtype = LR_DOWNSTAIR;
X			tmplreg[nlreg]->rname = 0;
X			nlreg++;
X		  } break;
Xcase 148:
X# line 1074 "lev_comp.y"
X{
X			tmplreg[nlreg] = New(lev_region);
X			tmplreg[nlreg]->in_islev = yypvt[-0].i;
X			tmplreg[nlreg]->inarea.x1 = current_region.x1;
X			tmplreg[nlreg]->inarea.y1 = current_region.y1;
X			tmplreg[nlreg]->inarea.x2 = current_region.x2;
X			tmplreg[nlreg]->inarea.y2 = current_region.y2;
X		  } break;
Xcase 149:
X# line 1083 "lev_comp.y"
X{
X			tmplreg[nlreg]->del_islev = yypvt[-2].i;
X			tmplreg[nlreg]->delarea.x1 = current_region.x1;
X			tmplreg[nlreg]->delarea.y1 = current_region.y1;
X			tmplreg[nlreg]->delarea.x2 = current_region.x2;
X			tmplreg[nlreg]->delarea.y2 = current_region.y2;
X			tmplreg[nlreg]->rtype = LR_PORTAL;
X			tmplreg[nlreg]->rname = yypvt[-0].map;
X			nlreg++;
X		  } break;
Xcase 150:
X# line 1096 "lev_comp.y"
X{
X			tmplreg[nlreg] = New(lev_region);
X			tmplreg[nlreg]->in_islev = yypvt[-0].i;
X			tmplreg[nlreg]->inarea.x1 = current_region.x1;
X			tmplreg[nlreg]->inarea.y1 = current_region.y1;
X			tmplreg[nlreg]->inarea.x2 = current_region.x2;
X			tmplreg[nlreg]->inarea.y2 = current_region.y2;
X		  } break;
Xcase 151:
X# line 1105 "lev_comp.y"
X{
X			tmplreg[nlreg]->del_islev = yypvt[-0].i;
X			tmplreg[nlreg]->delarea.x1 = current_region.x1;
X			tmplreg[nlreg]->delarea.y1 = current_region.y1;
X			tmplreg[nlreg]->delarea.x2 = current_region.x2;
X			tmplreg[nlreg]->delarea.y2 = current_region.y2;
X		  } break;
Xcase 152:
X# line 1113 "lev_comp.y"
X{
X			switch(yypvt[-0].i) {
X			case -1: tmplreg[nlreg]->rtype = LR_TELE; break;
X			case 0: tmplreg[nlreg]->rtype = LR_DOWNTELE; break;
X			case 1: tmplreg[nlreg]->rtype = LR_UPTELE; break;
X			}
X			tmplreg[nlreg]->rname = 0;
X			nlreg++;
X		  } break;
Xcase 153:
X# line 1125 "lev_comp.y"
X{
X			tmplreg[nlreg] = New(lev_region);
X			tmplreg[nlreg]->in_islev = yypvt[-0].i;
X			tmplreg[nlreg]->inarea.x1 = current_region.x1;
X			tmplreg[nlreg]->inarea.y1 = current_region.y1;
X			tmplreg[nlreg]->inarea.x2 = current_region.x2;
X			tmplreg[nlreg]->inarea.y2 = current_region.y2;
X		  } break;
Xcase 154:
X# line 1134 "lev_comp.y"
X{
X			tmplreg[nlreg]->del_islev = yypvt[-0].i;
X			tmplreg[nlreg]->delarea.x1 = current_region.x1;
X			tmplreg[nlreg]->delarea.y1 = current_region.y1;
X			tmplreg[nlreg]->delarea.x2 = current_region.x2;
X			tmplreg[nlreg]->delarea.y2 = current_region.y2;
X			tmplreg[nlreg]->rtype = LR_BRANCH;
X			tmplreg[nlreg]->rname = 0;
X			nlreg++;
X		  } break;
Xcase 155:
X# line 1147 "lev_comp.y"
X{
X			yyval.i = -1;
X		  } break;
Xcase 156:
X# line 1151 "lev_comp.y"
X{
X			yyval.i = yypvt[-0].i;
X		  } break;
Xcase 157:
X# line 1157 "lev_comp.y"
X{
X			yyval.i = 0;
X		  } break;
Xcase 158:
X# line 1161 "lev_comp.y"
X{
X/* This series of if statements is a hack for MSC 5.1.  It seems that its
X   tiny little brain cannot compile if these are all one big if statement. */
X			if (yypvt[-7].i <= 0 || yypvt[-7].i >= COLNO)
X				yyerror("Region out of level range!");
X			else if (yypvt[-5].i < 0 || yypvt[-5].i >= ROWNO)
X				yyerror("Region out of level range!");
X			else if (yypvt[-3].i <= 0 || yypvt[-3].i >= COLNO)
X				yyerror("Region out of level range!");
X			else if (yypvt[-1].i < 0 || yypvt[-1].i >= ROWNO)
X				yyerror("Region out of level range!");
X			current_region.x1 = yypvt[-7].i;
X			current_region.y1 = yypvt[-5].i;
X			current_region.x2 = yypvt[-3].i;
X			current_region.y2 = yypvt[-1].i;
X			yyval.i = 1;
X		  } break;
Xcase 159:
X# line 1181 "lev_comp.y"
X{
X			tmpfountain[nfountain] = New(fountain);
X			tmpfountain[nfountain]->x = current_coord.x;
X			tmpfountain[nfountain]->y = current_coord.y;
X			if (!in_room)
X			    check_coord(current_coord.x, current_coord.y,
X					"Fountain");
X			nfountain++;
X		  } break;
Xcase 160:
X# line 1193 "lev_comp.y"
X{
X			tmpsink[nsink] = New(sink);
X			tmpsink[nsink]->x = current_coord.x;
X			tmpsink[nsink]->y = current_coord.y;
X			nsink++;
X		  } break;
Xcase 161:
X# line 1202 "lev_comp.y"
X{
X			tmppool[npool] = New(pool);
X			tmppool[npool]->x = current_coord.x;
X			tmppool[npool]->y = current_coord.y;
X			npool++;
X		  } break;
Xcase 162:
X# line 1211 "lev_comp.y"
X{
X			tmpdig[ndig] = New(digpos);
X			tmpdig[ndig]->x1 = current_region.x1;
X			tmpdig[ndig]->y1 = current_region.y1;
X			tmpdig[ndig]->x2 = current_region.x2;
X			tmpdig[ndig]->y2 = current_region.y2;
X			ndig++;
X		  } break;
Xcase 163:
X# line 1222 "lev_comp.y"
X{
X			tmpreg[nreg] = New(region);
X			tmpreg[nreg]->x1 = current_region.x1;
X			tmpreg[nreg]->y1 = current_region.y1;
X			tmpreg[nreg]->x2 = current_region.x2;
X			tmpreg[nreg]->y2 = current_region.y2;
X			tmpreg[nreg]->rlit = yypvt[-3].i;
X			tmpreg[nreg]->rtype = yypvt[-1].i;
X			if(yypvt[-0].i & 1) tmpreg[nreg]->rtype += MAXRTYPE+1;
X			tmpreg[nreg]->rirreg = ((yypvt[-0].i & 2) != 0);
X			if(current_region.x1 > current_region.x2 ||
X			   current_region.y1 > current_region.y2)
X			   yyerror("Region start > end!");
X			if(tmpreg[nreg]->rtype == VAULT &&
X			   (tmpreg[nreg]->rirreg ||
X			    (tmpreg[nreg]->x2 - tmpreg[nreg]->x1 != 1) ||
X			    (tmpreg[nreg]->y2 - tmpreg[nreg]->y1 != 1)))
X				yyerror("Vaults must be exactly 2x2!");
X			if(want_warnings && !tmpreg[nreg]->rirreg &&
X			   current_region.x1 > 0 && current_region.y1 > 0 &&
X			   current_region.x2 < max_x_map &&
X			   current_region.y2 < max_y_map) {
X			    /* check for walls in the room */
X			    char ebuf[60];
X			    register int x, y, nrock = 0;
X
X			    for(y=current_region.y1; y<=current_region.y2; y++)
X				for(x=current_region.x1;
X				    x<=current_region.x2; x++)
X				    if(IS_ROCK(tmpmap[y][x]) ||
X				       IS_DOOR(tmpmap[y][x])) nrock++;
X			    if(nrock) {
X				Sprintf(ebuf,
X					"Rock in room (%02d,%02d,%02d,%02d)?!",
X					current_region.x1, current_region.y1,
X					current_region.x2, current_region.y2);
X				yywarning(ebuf);
X			    }
X			    if (
X		!IS_ROCK(tmpmap[current_region.y1-1][current_region.x1-1]) ||
X		!IS_ROCK(tmpmap[current_region.y2+1][current_region.x1-1]) ||
X		!IS_ROCK(tmpmap[current_region.y1-1][current_region.x2+1]) ||
X		!IS_ROCK(tmpmap[current_region.y2+1][current_region.x2+1])) {
X				Sprintf(ebuf,
X				"NonRock edge in room (%02d,%02d,%02d,%02d)?!",
X					current_region.x1, current_region.y1,
X					current_region.x2, current_region.y2);
X				yywarning(ebuf);
X			    }
X			} else if(tmpreg[nreg]->rirreg &&
X		!IS_ROOM(tmpmap[current_region.y1][current_region.x1])) {
X			    char ebuf[60];
X			    Sprintf(ebuf,
X				    "Rock in irregular room (%02d,%02d)?!",
X				    current_region.x1, current_region.y1);
X			    yyerror(ebuf);
X			}
X			nreg++;
X		  } break;
Xcase 164:
X# line 1284 "lev_comp.y"
X{
X			tmpaltar[naltar] = New(altar);
X			tmpaltar[naltar]->x = current_coord.x;
X			tmpaltar[naltar]->y = current_coord.y;
X			tmpaltar[naltar]->align = yypvt[-2].i;
X			tmpaltar[naltar]->shrine = yypvt[-0].i;
X			if (!in_room)
X			    check_coord(current_coord.x, current_coord.y,
X					"Altar");
X			naltar++;
X		  } break;
Xcase 165:
X# line 1298 "lev_comp.y"
X{
X			tmpgold[ngold] = New(gold);
X			tmpgold[ngold]->x = current_coord.x;
X			tmpgold[ngold]->y = current_coord.y;
X			tmpgold[ngold]->amount = yypvt[-2].i;
X			if (!in_room)
X			    check_coord(current_coord.x, current_coord.y,
X					"Gold");
X			ngold++;
X		  } break;
Xcase 166:
X# line 1311 "lev_comp.y"
X{
X			tmpengraving[nengraving] = New(engraving);
X			tmpengraving[nengraving]->x = current_coord.x;
X			tmpengraving[nengraving]->y = current_coord.y;
X			tmpengraving[nengraving]->e.text = yypvt[-0].map;
X			tmpengraving[nengraving]->etype = yypvt[-2].i;
X			if (!in_room)
X			    check_coord(current_coord.x, current_coord.y,
X					"Engraving");
X			nengraving++;
X		  } break;
Xcase 168:
X# line 1326 "lev_comp.y"
X{
X			yyval.i = - MAX_REGISTERS - 1;
X		  } break;
Xcase 171:
X# line 1334 "lev_comp.y"
X{
X			yyval.i = - MAX_REGISTERS - 1;
X		  } break;
Xcase 174:
X# line 1342 "lev_comp.y"
X{
X			yyval.map = (char *) 0;
X		  } break;
Xcase 176:
X# line 1349 "lev_comp.y"
X{
X			yyval.map = (char *) 0;
X		  } break;
Xcase 177:
X# line 1355 "lev_comp.y"
X{
X			int token = get_trap_type(yypvt[-0].map);
X			if (token == ERR)
X				yyerror("Unknown trap type!");
X			yyval.i = token;
X		  } break;
Xcase 179:
X# line 1365 "lev_comp.y"
X{
X			int token = get_room_type(yypvt[-0].map);
X			if (token == ERR) {
X				yywarning("Unknown room type!  Making ordinary room...");
X				yyval.i = OROOM;
X			} else
X				yyval.i = token;
X		  } break;
Xcase 181:
X# line 1377 "lev_comp.y"
X{
X			yyval.i = 0;
X		  } break;
Xcase 182:
X# line 1381 "lev_comp.y"
X{
X			yyval.i = yypvt[-0].i;
X		  } break;
Xcase 183:
X# line 1385 "lev_comp.y"
X{
X			yyval.i = yypvt[-2].i + (yypvt[-0].i << 1);
X		  } break;
Xcase 186:
X# line 1393 "lev_comp.y"
X{
X			current_coord.x = current_coord.y = -MAX_REGISTERS-1;
X		  } break;
Xcase 193:
X# line 1409 "lev_comp.y"
X{
X			yyval.i = - MAX_REGISTERS - 1;
X		  } break;
Xcase 196:
X# line 1419 "lev_comp.y"
X{
X			if ( yypvt[-1].i >= MAX_REGISTERS )
X				yyerror("Register Index overflow!");
X			else
X				current_coord.x = current_coord.y = - yypvt[-1].i - 1;
X		  } break;
Xcase 197:
X# line 1428 "lev_comp.y"
X{
X			if ( yypvt[-1].i >= MAX_REGISTERS )
X				yyerror("Register Index overflow!");
X			else
X				yyval.i = - yypvt[-1].i - 1;
X		  } break;
Xcase 198:
X# line 1437 "lev_comp.y"
X{
X			if ( yypvt[-1].i >= MAX_REGISTERS )
X				yyerror("Register Index overflow!");
X			else
X				yyval.i = - yypvt[-1].i - 1;
X		  } break;
Xcase 199:
X# line 1446 "lev_comp.y"
X{
X			if ( yypvt[-1].i >= 3 )
X				yyerror("Register Index overflow!");
X			else
X				yyval.i = - yypvt[-1].i - 1;
X		  } break;
Xcase 201:
X# line 1458 "lev_comp.y"
X{
X			if (check_monster_char((char) yypvt[-0].i))
X				yyval.i = yypvt[-0].i ;
X			else {
X				yyerror("Unknown monster class!");
X				yyval.i = ERR;
X			}
X		  } break;
Xcase 202:
X# line 1469 "lev_comp.y"
X{
X			char c = yypvt[-0].i;
X			if (check_object_char(c))
X				yyval.i = c;
X			else {
X				yyerror("Unknown char class!");
X				yyval.i = ERR;
X			}
X		  } break;
Xcase 205:
X# line 1485 "lev_comp.y"
X{
X			yyval.map = (char *) 0;
X		  } break;
Xcase 210:
X# line 1499 "lev_comp.y"
X{
X			if (!in_room && !init_lev.init_present &&
X			    (yypvt[-3].i < 0 || yypvt[-3].i > max_x_map ||
X			     yypvt[-1].i < 0 || yypvt[-1].i > max_y_map))
X			    yyerror("Coordinates out of map range!");
X			current_coord.x = yypvt[-3].i;
X			current_coord.y = yypvt[-1].i;
X		  } break;
Xcase 211:
X# line 1510 "lev_comp.y"
X{
X/* This series of if statements is a hack for MSC 5.1.  It seems that its
X   tiny little brain cannot compile if these are all one big if statement. */
X			if (yypvt[-7].i < 0 || yypvt[-7].i > max_x_map)
X				yyerror("Region out of map range!");
X			else if (yypvt[-5].i < 0 || yypvt[-5].i > max_y_map)
X				yyerror("Region out of map range!");
X			else if (yypvt[-3].i < 0 || yypvt[-3].i > max_x_map)
X				yyerror("Region out of map range!");
X			else if (yypvt[-1].i < 0 || yypvt[-1].i > max_y_map)
X				yyerror("Region out of map range!");
X			current_region.x1 = yypvt[-7].i;
X			current_region.y1 = yypvt[-5].i;
X			current_region.x2 = yypvt[-3].i;
X			current_region.y2 = yypvt[-1].i;
X		  } break;
X	}
X	goto yystack;		/* reset registers in driver code */
X}
END_OF_FILE
if test 30244 -ne `wc -c <'sys/share/lev_yacc.c2'`; then
    echo shar: \"'sys/share/lev_yacc.c2'\" unpacked with wrong size!
fi
# end of 'sys/share/lev_yacc.c2'
fi
echo shar: End of archive 72 \(of 108\).
cp /dev/null ark72isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \
21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \
41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 \
61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 \
81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 \
101 102 103 104 105 106 107 108 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 108 archives.
    echo "Now execute 'rebuild.sh'"
    rm -f ark10[0-8]isdone ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
