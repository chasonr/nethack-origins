Path: uunet!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v16i098:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Part90/108
Message-ID: <4463@master.CNA.TEK.COM>
Date: 5 Feb 93 22:02:33 GMT
Sender: news@master.CNA.TEK.COM
Lines: 1958
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1649

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 16, Issue 98
Archive-name: nethack31/Part90
Supersedes: nethack3p9: Volume 10, Issue 46-102
Environment: Amiga, Atari, Mac, MS-DOS, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 90 (of 108)."
# Contents:  dat/Barb.des include/winX.h src/mondata.c
#   sys/mac/macmain.c sys/share/termcap
# Wrapped by billr@saab on Wed Jan 27 16:09:23 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'dat/Barb.des' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dat/Barb.des'\"
else
echo shar: Extracting \"'dat/Barb.des'\" \(13280 characters\)
sed "s/^X//" >'dat/Barb.des' <<'END_OF_FILE'
X#	SCCS Id: @(#)Barb.des	3.1	91/12/22
X#	Copyright (c) 1989 by Jean-Christophe Collet
X#	Copyright (c) 1991 by M. Stephenson
X# NetHack may be freely redistributed.  See license for details.
X#
X#	The "start" level for the quest.
X#
X#	Here you meet your (besieged) class leader, Pelias,
X#	and receive your quest assignment.
X#
XMAZE: "B-start",' '
XFLAGS: noteleport,hardfloor
XGEOMETRY:center,center
XMAP
X..................................PP........................................
X...................................PP.......................................
X...................................PP.......................................
X....................................PP......................................
X........--------------......-----....PPP....................................
X........|...S........|......+...|...PPP.....................................
X........|----........|......|...|....PP.....................................
X........|.\..........+......-----...........................................
X........|----........|...............PP.....................................
X........|...S........|...-----.......PPP....................................
X........--------------...+...|......PPPPP...................................
X.........................|...|.......PPP....................................
X...-----......-----......-----........PP....................................
X...|...+......|...+..--+--.............PP...................................
X...|...|......|...|..|...|..............PP..................................
X...-----......-----..|...|.............PPPP.................................
X.....................-----............PP..PP................................
X.....................................PP...PP................................
X....................................PP...PP.................................
X....................................PP....PP................................
XENDMAP
X# Random Monsters
XRANDOM_MONSTERS: 'O', 'T'
X# Dungeon Description
XREGION:(00,00,75,19),lit,"ordinary"
XREGION:(09,05,11,05),unlit,"ordinary"
XREGION:(09,07,11,07),lit,"ordinary"
XREGION:(09,09,11,09),unlit,"ordinary"
XREGION:(13,05,20,09),lit,"ordinary"
XREGION:(29,05,31,06),lit,"ordinary"
XREGION:(26,10,28,11),lit,"ordinary"
XREGION:(04,13,06,14),lit,"ordinary"
XREGION:(15,13,17,14),lit,"ordinary"
XREGION:(22,14,24,15),lit,"ordinary"
X# Stairs
XSTAIR:(09,09),down
X# Portal arrival point
XBRANCH:(62,02,62,02),(0,0,0,0)
X# Doors
XDOOR:locked,(12,05)
XDOOR:locked,(12,09)
XDOOR:closed,(21,07)
XDOOR:open,(07,13)
XDOOR:open,(18,13)
XDOOR:open,(23,13)
XDOOR:open,(25,10)
XDOOR:open,(28,05)
X# Elder
XMONSTER:'@',"Pelias",(10,07)
X# The treasure of Pelias
XOBJECT:'(',"chest",(09,05)
X# chieftain guards for the audience chamber
XMONSTER:'@',"chieftain",(10,05)
XMONSTER:'@',"chieftain",(10,09)
XMONSTER:'@',"chieftain",(11,05)
XMONSTER:'@',"chieftain",(11,09)
XMONSTER:'@',"chieftain",(14,05)
XMONSTER:'@',"chieftain",(14,09)
XMONSTER:'@',"chieftain",(16,05)
XMONSTER:'@',"chieftain",(16,09)
X# Non diggable walls
XNON_DIGGABLE:(00,00,75,19)
X# One trap to keep the ogres at bay.
XTRAP:"spiked pit",(37,07)
X# Eels in the river
XMONSTER:';',"giant eel",(36,01)
XMONSTER:';',"giant eel",(37,09)
XMONSTER:';',"giant eel",(38,15)
X# Monsters on siege duty.
XMONSTER:'O',"ogre",(40,08),hostile
XMONSTER:'O',"ogre",(41,06),hostile
XMONSTER:'O',"ogre",(41,07),hostile
XMONSTER:'O',"ogre",(41,08),hostile
XMONSTER:'O',"ogre",(41,09),hostile
XMONSTER:'O',"ogre",(41,10),hostile
XMONSTER:'O',"ogre",(42,06),hostile
XMONSTER:'O',"ogre",(42,07),hostile
XMONSTER:'O',"ogre",(42,08),hostile
XMONSTER:'O',"ogre",(42,09),hostile
XMONSTER:'O',"ogre",(42,10),hostile
X 
X#
X#	The "locate" level for the quest.
X#
X#	Here you have to infiltrate the Duali Oasis to go
X#	further towards your assigned quest.
X#
X
XMAZE: "B-locate",' '
XFLAGS: hardfloor
XGEOMETRY:center,center
XMAP
X..........PPP.........................................                      
X...........PP..........................................        .......      
X..........PP...........-----..........------------------     ..........     
X...........PP..........+...|..........|....S...........|..  ............    
X..........PPP..........|...|..........|-----...........|...  .............  
X...........PPP.........-----..........+....+...........|...  .............  
X..........PPPPPPPPP...................+....+...........S.................   
X........PPPPPPPPPPPPP.........-----...|-----...........|................    
X......PPPPPPPPPPPPPP..P.......+...|...|....S...........|          ...       
X.....PPPPPPP......P..PPPP.....|...|...------------------..         ...      
X....PPPPPPP.........PPPPPP....-----........................      ........   
X...PPPPPPP..........PPPPPPP..................................   ..........  
X....PPPPPPP........PPPPPPP....................................  ..........  
X.....PPPPP........PPPPPPP.........-----........................   ........  
X......PPP..PPPPPPPPPPPP...........+...|.........................    .....   
X..........PPPPPPPPPPP.............|...|.........................     ....   
X..........PPPPPPPPP...............-----.........................       .    
X..............PPP.................................................          
X...............PP....................................................       
X................PPP...................................................      
XENDMAP
X# Random Monsters
XRANDOM_MONSTERS: 'O', 'T'
X# Dungeon Description
XREGION:(00,00,75,19),lit,"ordinary"
XREGION:(24,03,26,04),unlit,"ordinary"
XREGION:(31,08,33,09),unlit,"ordinary"
XREGION:(35,14,37,15),unlit,"ordinary"
XREGION:(39,03,54,08),lit,"ordinary"
XREGION:(56,00,75,08),unlit,"ordinary"
XREGION:(64,09,75,16),unlit,"ordinary"
X# Doors
XDOOR:open,(23,03)
XDOOR:open,(30,08)
XDOOR:open,(34,14)
XDOOR:locked,(38,05)
XDOOR:locked,(38,06)
XDOOR:closed,(43,03)
XDOOR:closed,(43,05)
XDOOR:closed,(43,06)
XDOOR:closed,(43,08)
XDOOR:locked,(55,06)
X# Stairs
XSTAIR:(05,02),up
XSTAIR:(70,13),down
X# Objects
XOBJECT:random,random,(42,03)
XOBJECT:random,random,(42,03)
XOBJECT:random,random,(42,03)
XOBJECT:random,random,(41,03)
XOBJECT:random,random,(41,03)
XOBJECT:random,random,(41,03)
XOBJECT:random,random,(41,03)
XOBJECT:random,random,(41,08)
XOBJECT:random,random,(41,08)
XOBJECT:random,random,(42,08)
XOBJECT:random,random,(42,08)
XOBJECT:random,random,(42,08)
XOBJECT:random,random,(71,13)
XOBJECT:random,random,(71,13)
XOBJECT:random,random,(71,13)
X# Random traps
XTRAP:"spiked pit",(10,13)
XTRAP:"spiked pit",(21,07)
XTRAP:"spiked pit",(67,08)
XTRAP:"spiked pit",(68,09)
XTRAP:random,random
XTRAP:random,random
XTRAP:random,random
XTRAP:random,random
X# Random monsters.
XMONSTER:'O',"ogre",(12,09),hostile
XMONSTER:'O',"ogre",(18,11),hostile
XMONSTER:'O',"ogre",(45,05),hostile
XMONSTER:'O',"ogre",(45,06),hostile
XMONSTER:'O',"ogre",(47,05),hostile
XMONSTER:'O',"ogre",(46,05),hostile
XMONSTER:'O',"ogre",(56,03),hostile
XMONSTER:'O',"ogre",(56,04),hostile
XMONSTER:'O',"ogre",(56,05),hostile
XMONSTER:'O',"ogre",(56,06),hostile
XMONSTER:'O',"ogre",(57,03),hostile
XMONSTER:'O',"ogre",(57,04),hostile
XMONSTER:'O',"ogre",(57,05),hostile
XMONSTER:'O',"ogre",(57,06),hostile
XMONSTER:'O',"ogre",random,hostile
XMONSTER:'O',"ogre",random,hostile
XMONSTER:'O',"ogre",random,hostile
XMONSTER:'O',random,random,hostile
XMONSTER:'T',random,random,hostile
XMONSTER:'T',"rock troll",(46,06),hostile
XMONSTER:'T',"rock troll",(47,06),hostile
XMONSTER:'T',"rock troll",(56,07),hostile
XMONSTER:'T',"rock troll",(57,07),hostile
XMONSTER:'T',"rock troll",(70,13),hostile
XMONSTER:'T',"rock troll",random,hostile
XMONSTER:'T',"rock troll",random,hostile
XMONSTER:'T',random,random,hostile
X
X#
X#	The "goal" level for the quest.
X#
X#	Here you meet Thoth Amon, your nemesis monster.  You have to
X#	defeat Thoth Amon in combat to gain the artifact you have
X#	been assigned to retrieve.
X#
X
XMAZE: "B-goal", ' '
XGEOMETRY:center,center
XMAP
X                                                                            
X                               .............                                
X                             ..................                             
X        ....              .........................          ....           
X      .......          ..........................           .......         
X      ......             ........................          .......          
X      ..  ......................................             ..             
X       ..                 .....................             ..              
X        ..                 ..................              ..               
X         ..         ..S...S..............   ................                
X          ..                   ........                ...                  
X       .........                                         ..                 
X       ......  ..                                         ...  ....         
X      .. ...    ..                             ......       ........        
X   ....          .. ..................        ........       ......         
X  ......          ......................       ......         ..            
X   ....             ..................              ...........             
X                      ..............                                        
X                        ...........                                         
X                                                                            
XENDMAP
X# Random Monsters
XRANDOM_MONSTERS: 'O', 'T'
X# Dungeon Description
XREGION:(00,00,75,19),unlit,"ordinary"
X# Secret doors
XDOOR:locked,(22,09)
XDOOR:locked,(26,09)
X# Stairs
XSTAIR:(36,05),up
X# The altar.  Unattended.
XALTAR:(63,04),align[2],altar
XNON_DIGGABLE:(00,00,75,19)
X# Objects
XOBJECT:'*',"luckstone",(63,04),blessed,0,"The Heart of Ahriman"
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
X# Random traps
XTRAP:random,random
XTRAP:random,random
XTRAP:random,random
XTRAP:random,random
XTRAP:random,random
XTRAP:random,random
X# Random monsters.
XMONSTER:'@',"Thoth Amon",(63,04),hostile
XMONSTER:'O',"ogre",random,hostile
XMONSTER:'O',"ogre",random,hostile
XMONSTER:'O',"ogre",random,hostile
XMONSTER:'O',"ogre",random,hostile
XMONSTER:'O',"ogre",random,hostile
XMONSTER:'O',"ogre",random,hostile
XMONSTER:'O',"ogre",random,hostile
XMONSTER:'O',"ogre",random,hostile
XMONSTER:'O',"ogre",random,hostile
XMONSTER:'O',"ogre",random,hostile
XMONSTER:'O',"ogre",random,hostile
XMONSTER:'O',"ogre",random,hostile
XMONSTER:'O',"ogre",random,hostile
XMONSTER:'O',"ogre",random,hostile
XMONSTER:'O',"ogre",random,hostile
XMONSTER:'O',"ogre",random,hostile
XMONSTER:'O',random,random,hostile
XMONSTER:'O',random,random,hostile
XMONSTER:'T',"rock troll",random,hostile
XMONSTER:'T',"rock troll",random,hostile
XMONSTER:'T',"rock troll",random,hostile
XMONSTER:'T',"rock troll",random,hostile
XMONSTER:'T',"rock troll",random,hostile
XMONSTER:'T',"rock troll",random,hostile
XMONSTER:'T',"rock troll",random,hostile
XMONSTER:'T',"rock troll",random,hostile
XMONSTER:'T',random,random,hostile
XWALLIFY
X
X#
X#	The "fill" levels for the quest.
X#
X#	These levels are used to fill out any levels not occupied by specific
X#	levels as defined above. "filla" is the upper filler, between the
X#	start and locate levels, and "fillb" the lower between the locate
X#	and goal levels.
X#
X
XMAZE: "B-filla" , ' '
XINIT_MAP: '.' , '.' , true , true , unlit , false
XNOMAP
X# Random Monsters
XRANDOM_MONSTERS: 'O', 'T'
X#
XSTAIR: random, up
XSTAIR: random, down
X#
XOBJECT: random, random, random
XOBJECT: random, random, random
XOBJECT: random, random, random
XOBJECT: random, random, random
XOBJECT: random, random, random
XOBJECT: random, random, random
XOBJECT: random, random, random
XOBJECT: random, random, random
X#
XTRAP: random, random
XTRAP: random, random
XTRAP: random, random
XTRAP: random, random
X#
XMONSTER: 'O', "ogre", random, hostile
XMONSTER: 'O', "ogre", random, hostile
XMONSTER: 'O', random, random, hostile
XMONSTER: 'T', "rock troll", random, hostile
X
XMAZE: "B-fillb" , ' '
XINIT_MAP: '.' , ' ' , true , true , unlit , true
XNOMAP
X# Random Monsters
XRANDOM_MONSTERS: 'O', 'T'
X#
XSTAIR: random, up
XSTAIR: random, down
X#
XOBJECT: random, random, random
XOBJECT: random, random, random
XOBJECT: random, random, random
XOBJECT: random, random, random
XOBJECT: random, random, random
XOBJECT: random, random, random
XOBJECT: random, random, random
XOBJECT: random, random, random
XOBJECT: random, random, random
XOBJECT: random, random, random
XOBJECT: random, random, random
X#
XTRAP: random, random
XTRAP: random, random
XTRAP: random, random
XTRAP: random, random
X#
XMONSTER: 'O', "ogre", random, hostile
XMONSTER: 'O', "ogre", random, hostile
XMONSTER: 'O', "ogre", random, hostile
XMONSTER: 'O', "ogre", random, hostile
XMONSTER: 'O', "ogre", random, hostile
XMONSTER: 'O', "ogre", random, hostile
XMONSTER: 'O', "ogre", random, hostile
XMONSTER: 'O', random , random, hostile
XMONSTER: 'T', "rock troll", random, hostile
XMONSTER: 'T', "rock troll", random, hostile
XMONSTER: 'T', "rock troll", random, hostile
XMONSTER: 'T', random , random, hostile
END_OF_FILE
if test 13280 -ne `wc -c <'dat/Barb.des'`; then
    echo shar: \"'dat/Barb.des'\" unpacked with wrong size!
fi
# end of 'dat/Barb.des'
fi
if test -f 'include/winX.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/winX.h'\"
else
echo shar: Extracting \"'include/winX.h'\" \(11646 characters\)
sed "s/^X//" >'include/winX.h' <<'END_OF_FILE'
X/*	SCCS Id: @(#)winX.h	3.1	93/01/22		  */
X/* Copyright (c) Dean Luick, 1992				  */
X/* NetHack may be freely redistributed.  See license for details. */
X
X/*
X * Definitions for the X11 window-port.  See doc/window.doc for details on
X * the window interface.
X */
X#ifndef WINX_H
X#define WINX_H
X
X#ifndef E
X#define E extern
X#endif
X
X#if defined(BOS) || defined(NHSTDC)
X#define DIMENSION_P int
X#else
X# ifdef WIDENED_PROTOTYPES
X#define DIMENSION_P unsigned int
X# else
X#define DIMENSION_P Dimension
X# endif
X#endif
X
X/*
X * Generic text buffer.
X */
X#define START_SIZE 512	/* starting text buffer size */
Xstruct text_buffer {
X    char *text;
X    int  text_size;
X    int  text_last;
X    int  num_lines;
X};
X
X
X/*
X * Information specific to a map window.
X */
Xstruct map_info_t {
X    unsigned char   text[ROWNO][COLNO],	/* Actual displayed screen. */
X		    t_start[ROWNO],	/* Staring column for new info. */
X		    t_stop[ROWNO];	/* Ending column for new info. */
X    int		    char_width,		/* Saved font information so we can  */
X		    char_height,	/*   calculate the correct placement */
X		    char_ascent,	/*   of changes.		     */
X		    char_lbearing;
X    Dimension	    viewport_width,	/* Saved viewport size, so we can */
X		    viewport_height;	/*   clip to cursor on a resize.  */
X#ifdef TEXTCOLOR
X    unsigned char   colors[ROWNO][COLNO];	/* Color of each character. */
X    GC		    color_gcs[MAXCOLORS],	/* GC for each color */
X		    inv_color_gcs[MAXCOLORS];	/* GC for each inverse color */
X#define copy_gc     color_gcs[NO_COLOR]
X#define inv_copy_gc inv_color_gcs[NO_COLOR]
X#else
X    GC		    copy_gc,			/* Drawing GC */
X		    inv_copy_gc;		/* Inverse drawing GC */
X#endif
X};
X
X/*
X * Information specific to a message window.
X */
Xstruct line_element {
X    struct line_element *next;
X    char *line;			/* char buffer */
X    int  buf_length;		/* length of buffer */
X    int  str_length;		/* length of string in buffer */
X};
X
Xstruct mesg_info_t {
X    XFontStruct *fs;		/* Font for the window. */
X    int		num_lines;	/* line count */
X    struct line_element *head;	/* head of circular line queue */
X    struct line_element *last_pause;/* point to the line after the prev */
X				/*	bottom of screen */
X    struct line_element *last_pause_head;/* pointer to head of previous */
X				/* turn					*/
X    GC		gc;		/* GC for text drawing */
X    int         char_width,     /* Saved font information so we can  */
X		char_height,    /*   calculate the correct placement */
X		char_ascent,    /*   of changes.                     */
X		char_lbearing;
X    Dimension	viewport_width,	/* Saved viewport size, so we can adjust */
X		viewport_height;/*   the slider on a resize.		 */
X    Boolean	dirty;		/* Lines have been added to the window. */
X};
X
X/*
X * Information specific to a "text" status window.
X */
Xstruct status_info_t {
X    struct text_buffer text;	/* Just a text buffer. */
X};
X
X/*
X * Information specific to a menu window.  First a structure for each
X * menu entry, then the structure for each menu window.
X */
Xstruct menu_item {
X    struct menu_item *next;
X    char selector;		/* Char used to select this entry. */
X    int  attr;			/* Attribute for the line. */
X    char *str;			/* The text of the item. */
X};
X
Xstruct menu_info_t {
X    struct menu_item *base;	/* Starting pointer for item list. */
X    struct menu_item *last;	/* End pointer for item list. */
X    const char    *query;
X    const char    *other_valid;
X    char    other_response;
X    int     count;
X    String  *list_pointer;
X    boolean valid_widgets;
X    boolean is_menu;		/* Has been conformed to being a menu window. */
X};
X
X/*
X * Information specific to a text window.
X */
Xstruct text_info_t {
X    struct text_buffer text;
X    XFontStruct *fs;		/* Font for the text window. */
X    int		max_width;	/* Width of widest line so far. */
X    int		extra_width,	/* Sum of left and right border widths. */
X		extra_height;	/* Sum of top and bottom border widths. */
X    boolean	blocked;	/*  */
X    boolean	destroy_on_ack;	/* Destroy this window when acknowleged. */
X};
X
X
X/*
X * Basic window structure.
X */
Xstruct xwindow {
X    int	      type;		/* type of nethack window */
X    Widget    popup;		/* direct parent of widget w or viewport */
X    Widget    w;		/* the widget that does things */
X    Dimension pixel_width;	/* window size, in pixels */
X    Dimension pixel_height;
X    int	      prevx, cursx;	/* Cursor position, only used by    */
X    int       prevy, cursy;	/*   map and "plain" status windows.*/
X
X    union {
X	struct map_info_t    *Map_info;	    /* map window info */
X	struct mesg_info_t   *Mesg_info;    /* message window info */
X	struct status_info_t *Status_info;  /* status window info */
X	struct menu_info_t   *Menu_info;    /* menu window info */
X	struct text_info_t   *Text_info;    /* menu window info */
X    } Win_info;
X};
X
X/* Defines to use for the window information union. */
X#define map_information    Win_info.Map_info
X#define mesg_information   Win_info.Mesg_info
X#define status_information Win_info.Status_info
X#define menu_information   Win_info.Menu_info
X#define text_information   Win_info.Text_info
X
X
X#define MAX_WINDOWS 20		/* max number of open windows */
X
X#define NHW_NONE 0		/* Unallocated window type.  Must be 	*/
X				/* different from any other NHW_* type. */
X
X#define NO_CLICK 0		/* No click occured on the map window. Must */
X				/* be different than CLICK_1 and CLICK_2.   */
X
X#define DEFAULT_MESSAGE_WIDTH 60/* width in chars of the message window */
X
X#define DISPLAY_FILE_SIZE 35	/* Max number of lines in the default	*/
X				/* file display window.			*/
X
X#define MAX_KEY_STRING 64	/* String size for converting a keypress */
X				/* event into a character(s)		 */
X
X#define DEFAULT_LINES_DISPLAYED 12 /* # of lines displayed message window */
X#define MAX_HISTORY 60		/* max history saved on message window */
X
X
X/* Window variables (winX.c). */
XE struct xwindow window_list[MAX_WINDOWS];
XE XtAppContext   app_context;		/* context of application */
XE Widget	 toplevel;		/* toplevel widget */
XE boolean	 exit_x_event;		/* exit condition for event loop */
X#define EXIT_ON_KEY_PRESS	    0	/* valid values for exit_x_event */
X#define EXIT_ON_KEY_OR_BUTTON_PRESS 1
X#define EXIT_ON_EXIT		    2
X#define EXIT_ON_SENT_EVENT	    3
XE int click_x, click_y, click_button;
X
Xtypedef struct {
X    Boolean slow;
X    Boolean autofocus;
X    Boolean message_line;
X    String  icon;	/* name of desired icon */
X} AppResources;
X
XE AppResources appResources;
XE void (*input_func)();
X
Xextern struct window_procs X11_procs;
X
X/* Check for an invalid window id. */
X#define check_winid(window)					\
X	if ((window) < 0 || (window) >= MAX_WINDOWS) {		\
X	    panic("illegal windid [%d] in %s at line %d",	\
X		window, __FILE__, __LINE__);			\
X	}
X
X
X/* ### dialogs.c ### */
XE Widget FDECL(CreateDialog, (Widget, String, XtCallbackProc, XtCallbackProc));
XE void FDECL(SetDialogPrompt,(Widget, String));
XE String FDECL(GetDialogResponse,(Widget));
XE void FDECL(SetDialogResponse,(Widget, String));
XE void FDECL(positionpopup,(Widget));
X
X/* ### winX.c ### */
XE struct xwindow *FDECL(find_widget,(Widget));
XE char FDECL(key_event_to_char,(XKeyEvent*));
XE void FDECL(msgkey, (Widget, XtPointer, XEvent*));
XE void FDECL(nh_XtPopup, (Widget, int, Widget));
XE void FDECL(nh_XtPopdown, (Widget));
XE void NDECL(win_X11_init);
X
X/* ### winmesg.c ### */
XE void FDECL(set_message_height, (struct xwindow*, DIMENSION_P));
XE void FDECL(set_message_slider, (struct xwindow*));
XE void FDECL(create_message_window,(struct xwindow*, BOOLEAN_P, Widget));
XE void FDECL(destroy_message_window,(struct xwindow*));
XE void FDECL(display_message_window, (struct xwindow*));
XE void FDECL(append_message,(struct xwindow*, const char*));
XE void FDECL(set_last_pause, (struct xwindow*));
X
X/* ### winmap.c ### */
XE void FDECL(check_cursor_visibility,(struct xwindow*));
XE void FDECL(display_map_window,(struct xwindow*));
XE void FDECL(clear_map_window,(struct xwindow*));
XE void FDECL(extern_map_input,(XEvent*));
XE void FDECL(set_map_size,(struct xwindow*, DIMENSION_P, DIMENSION_P));
XE void FDECL(create_map_window,(struct xwindow*, BOOLEAN_P, Widget));
XE void FDECL(destroy_map_window,(struct xwindow*));
XE int  FDECL(x_event,(int));
X
X/* ### winmenu.c ### */
XE void FDECL(menu_key,(Widget, XEvent*, String*, Cardinal*));
XE void FDECL(create_menu_window,(struct xwindow*));
XE void FDECL(destroy_menu_window,(struct xwindow*));
X
X/* ### winmisc.c ### */
XE void FDECL(ps_key,(Widget, XEvent*, String*, Cardinal*)); /* player selection action */
XE void FDECL(ec_key,(Widget, XEvent*, String*, Cardinal*)); /* extended command action */
XE void NDECL(init_extended_commands_popup);
X
X/* ### winstatus.c ### */
XE void FDECL(create_status_window,(struct xwindow*, BOOLEAN_P, Widget));
XE void FDECL(destroy_status_window,(struct xwindow*));
XE void FDECL(adjust_status,(struct xwindow*, const char*));
XE void NDECL(null_out_status);
XE void NDECL(check_turn_events);
X
X/* ### wintext.c ### */
XE void FDECL(dismiss_text,(Widget, XEvent*, String*, Cardinal*));
XE void FDECL(key_dismiss_text,(Widget, XEvent*, String*, Cardinal*));
XE void FDECL(add_to_text_window,(struct xwindow*, int, const char*));
XE void FDECL(display_text_window,(struct xwindow*, BOOLEAN_P));
XE void FDECL(create_text_window,(struct xwindow*));
XE void FDECL(destroy_text_window,(struct xwindow*));
XE void FDECL(append_text_buffer,(struct text_buffer*, const char*, BOOLEAN_P));	/* text buffer routines */
XE void FDECL(init_text_buffer,(struct text_buffer*));
XE void FDECL(clear_text_buffer,(struct text_buffer*));
XE void FDECL(free_text_buffer,(struct text_buffer*));
X
X/* ### winval.c ### */
XE Widget FDECL(create_value,(Widget, const char*));
XE void   FDECL(set_name,(Widget, char*));
XE void   FDECL(set_name_width,(Widget, int));
XE int    FDECL(get_name_width,(Widget));
XE void   FDECL(set_value,(Widget, const char*));
XE void   FDECL(set_value_width,(Widget, int));
XE int    FDECL(get_value_width,(Widget));
XE void   FDECL(hilight_value,(Widget));
X
X/* external declarations */
XE void NDECL(X11_init_nhwindows);
XE void NDECL(X11_player_selection);
XE void NDECL(X11_askname);
XE void NDECL(X11_get_nh_event) ;
XE void FDECL(X11_exit_nhwindows, (const char *));
XE void FDECL(X11_suspend_nhwindows, (const char *));
XE void NDECL(X11_resume_nhwindows);
XE winid FDECL(X11_create_nhwindow, (int));
XE void FDECL(X11_clear_nhwindow, (winid));
XE void FDECL(X11_display_nhwindow, (winid, BOOLEAN_P));
XE void FDECL(X11_destroy_nhwindow, (winid));
XE void FDECL(X11_curs, (winid,int,int));
XE void FDECL(X11_putstr, (winid, int, const char *));
XE void FDECL(X11_display_file, (const char *, BOOLEAN_P));
XE void FDECL(X11_start_menu, (winid));
XE void FDECL(X11_add_menu, (winid, CHAR_P, int, const char *));
XE void FDECL(X11_end_menu, (winid, CHAR_P, const char *, const char *));
XE char FDECL(X11_select_menu, (winid));
XE void NDECL(X11_update_inventory);
XE void NDECL(X11_mark_synch);
XE void NDECL(X11_wait_synch);
X#ifdef CLIPPING
XE void FDECL(X11_cliparound, (int, int));
X#endif
XE void FDECL(X11_print_glyph, (winid,XCHAR_P,XCHAR_P,int));
XE void FDECL(X11_raw_print, (const char *));
XE void FDECL(X11_raw_print_bold, (const char *));
XE int NDECL(X11_nhgetch);
XE int FDECL(X11_nh_poskey, (int *, int *, int *));
XE void NDECL(X11_nhbell);
XE int NDECL(X11_doprev_message);
XE char FDECL(X11_yn_function, (const char *, const char *, CHAR_P));
XE void FDECL(X11_getlin, (const char *,char *));
X#ifdef COM_COMPL
XE void FDECL(X11_get_ext_cmd, (char *));
X#endif /* COM_COMPL */
XE void FDECL(X11_number_pad, (int));
XE void NDECL(X11_delay_output);
X
X/* other defs that really should go away (they're tty specific) */
XE void NDECL(X11_start_screen);
XE void NDECL(X11_end_screen);
X
X#endif /* WINX_H */
END_OF_FILE
if test 11646 -ne `wc -c <'include/winX.h'`; then
    echo shar: \"'include/winX.h'\" unpacked with wrong size!
fi
# end of 'include/winX.h'
fi
if test -f 'src/mondata.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/mondata.c'\"
else
echo shar: Extracting \"'src/mondata.c'\" \(10482 characters\)
sed "s/^X//" >'src/mondata.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)mondata.c	3.1	92/11/24	*/
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include "hack.h"
X#include "eshk.h"
X#include "epri.h"
X
X/*	These routines provide basic data for any type of monster. */
X
X#ifdef OVL0
X
Xboolean
Xattacktype(ptr, atyp)
X	register struct	permonst	*ptr;
X	register int atyp;
X{
X	int	i;
X
X	for(i = 0; i < NATTK; i++)
X	    if(ptr->mattk[i].aatyp == atyp) return(TRUE);
X
X	return(FALSE);
X}
X
X#endif /* OVL0 */
X#ifdef OVLB
X
Xboolean
Xpoly_when_stoned(ptr)
X    struct permonst *ptr;
X{
X    return (is_golem(ptr) && ptr != &mons[PM_STONE_GOLEM] &&
X	    !(mons[PM_STONE_GOLEM].geno & G_GENOD));	/* allow G_EXTINCT */
X}
X
Xboolean
Xresists_drli(ptr)	/* returns TRUE if monster is drain-life resistant */
X
X	register struct permonst *ptr;
X{
X	return(is_undead(ptr) || is_demon(ptr) || is_were(ptr));
X}
X
X#endif /* OVLB */
X#ifdef OVL0
X
Xboolean
Xranged_attk(ptr)	/* returns TRUE if monster can attack at range */
X	register struct permonst *ptr;
X{
X	register int	i, j;
X	register int atk_mask = (1<<AT_BREA) | (1<<AT_SPIT) | (1<<AT_GAZE);
X
X	/* was: (attacktype(ptr, AT_BREA) || attacktype(ptr, AT_WEAP) ||
X		attacktype(ptr, AT_SPIT) || attacktype(ptr, AT_GAZE) ||
X		attacktype(ptr, AT_MAGC));
X	   but that's too slow -dlc
X	 */
X	for(i = 0; i < NATTK; i++) {
X	    if((j=ptr->mattk[i].aatyp) >= AT_WEAP || (atk_mask & (1<<j)))
X		return TRUE;
X	}
X
X	return(FALSE);
X}
X
Xboolean
Xhates_silver(ptr)
Xregister struct permonst *ptr;
X/* returns TRUE if monster is especially affected by silver weapons */
X{
X	return (is_were(ptr) || ptr->mlet==S_VAMPIRE || is_demon(ptr) ||
X		ptr == &mons[PM_SHADE] ||
X		(ptr->mlet==S_IMP && ptr != &mons[PM_TENGU]));
X}
X
X#endif /* OVL0 */
X#ifdef OVL1
X
Xboolean
Xcan_track(ptr)		/* returns TRUE if monster can track well */
X	register struct permonst *ptr;
X{
X	if (uwep && uwep->oartifact == ART_EXCALIBUR)
X		return TRUE;
X	else
X		return(haseyes(ptr));
X}
X
X#endif /* OVL1 */
X#ifdef OVLB
X
X#if defined(POLYSELF) || defined(MUSE)
Xboolean
Xsliparm(ptr)	/* creature will slide out of armor */
X	register struct permonst *ptr;
X{
X	return is_whirly(ptr) || ptr->msize <= MZ_SMALL ||
X		ptr == &mons[PM_GHOST];
X}
X
Xboolean
Xbreakarm(ptr)	/* creature will break out of armor */
X	register struct permonst *ptr;
X{
X	return((bigmonst(ptr) || (ptr->msize > MZ_SMALL && !humanoid(ptr))
X	                || ptr == &mons[PM_MARILITH]) && !sliparm(ptr));
X	/* Marilith is about the only case of a monster which is otherwise
X	 * humanoid but cannot wear armor (too many arms).  Centaurs would
X	 * be another except that they are already accounted for by
X	 * bigmonst.
X	 */
X}
X#endif
X#endif /* OVLB */
X#ifdef OVL1
X
Xboolean
Xsticks(ptr)	/* creature sticks other creatures it hits */
X	register struct permonst *ptr;
X{
X	return(dmgtype(ptr,AD_STCK) || dmgtype(ptr,AD_WRAP) ||
X		attacktype(ptr,AT_HUGS));
X}
X
Xboolean
Xdmgtype(ptr, dtyp)
X	register struct	permonst	*ptr;
X	register int dtyp;
X{
X	int	i;
X
X	for(i = 0; i < NATTK; i++)
X	    if(ptr->mattk[i].adtyp == dtyp) return TRUE;
X
X	return FALSE;
X}
X
X/* returns the maximum damage a defender can do to the attacker via
X * a passive defense */
Xint
Xmax_passive_dmg(mdef, magr)
X    register struct monst *mdef, *magr;
X{
X    int	i, dmg = 0;
X    uchar adtyp;
X
X    for(i = 0; i < NATTK; i++)
X	if(mdef->data->mattk[i].aatyp == AT_NONE) {
X	    adtyp = mdef->data->mattk[i].adtyp;
X	    if((adtyp == AD_ACID && !resists_acid(magr->data)) ||
X		    (adtyp == AD_COLD && !resists_cold(magr->data)) ||
X		    (adtyp == AD_FIRE && !resists_fire(magr->data)) ||
X		    (adtyp == AD_ELEC && !resists_elec(magr->data))) {
X		dmg = mdef->data->mattk[i].damn;
X		if(!dmg) dmg = mdef->data->mlevel+1;
X		dmg *= mdef->data->mattk[i].damd;
X	    } else dmg = 0;
X
X	    return dmg;
X	}
X    return 0;
X}
X
X#endif /* OVL1 */
X#ifdef OVL0
X
Xint
Xmonsndx(ptr)		/* return an index into the mons array */
X	struct	permonst	*ptr;
X{
X	register int	i;
X
X	if(ptr == &playermon) return(-1);
X
X	i = (int)(ptr - &mons[0]);
X	if(i < 0 || i >= NUMMONS) {    
X	    panic("monsndx - could not index monster (%lx)", (long)ptr);
X	    return FALSE;		/* will not get here */
X	}
X
X	return(i);
X}
X
X#endif /* OVL0 */
X#ifdef OVL1
X
X
Xint
Xname_to_mon(str)
Xchar *str;
X{
X	/* Be careful.  We must check the entire string in case it was
X	 * something such as "ettin zombie corpse".  The calling routine
X	 * doesn't know about the "corpse" until the monster name has
X	 * already been taken off the front, so we have to be able to
X	 * read the name with extraneous stuff such as "corpse" stuck on
X	 * the end.
X	 * This causes a problem for names which prefix other names such
X	 * as "ettin" on "ettin zombie".  In this case we want the _longest_
X	 * name which exists.
X	 * This also permits plurals created by adding suffixes such as 's'
X	 * or 'es'.  Other plurals must still be handled explicitly.
X	 */
X	register int i;
X	register int mntmp = -1;
X	register char *s;
X	char buf[BUFSZ];
X	int len, slen;
X
X	Strcpy(buf, str);
X	str = buf;
X	if (!strncmp(str, "a ", 2)) str += 2;
X	else if (!strncmp(str, "an ", 3)) str += 3;
X
X	/* Some irregular plurals */
X	if (!strncmpi(str, "incubi", 6)) return PM_INCUBUS;
X	if (!strncmpi(str, "succubi", 7)) return PM_SUCCUBUS;
X	if (!strncmpi(str, "violet fungi", 12)) return PM_VIOLET_FUNGUS;
X	if (!strncmpi(str, "homunculi", 9)) return PM_HOMUNCULUS;
X	if (!strncmpi(str, "baluchitheria", 13)) return PM_BALUCHITHERIUM;
X	if (!strncmpi(str, "lurkers above", 13)) return PM_LURKER_ABOVE;
X	if (!strncmpi(str, "cavemen", 7)) return PM_CAVEMAN;
X	if (!strncmpi(str, "cavewomen", 9)) return PM_CAVEWOMAN;
X	if (!strncmpi(str, "zruties", 7)) return PM_ZRUTY;
X	if (!strncmpi(str, "djinn", 5)) return PM_DJINNI;
X	if (!strncmpi(str, "mumakil", 7)) return PM_MUMAK;
X	if ((s = strstri(str, "vortices")) != 0)
X	    Strcpy(s+4, "ex");
X	/* be careful with "ies"; "priest", "zombies" */
X	else if ((s = strstri(str, "jellies")) != 0 ||
X		 (s = strstri(str, "mummies")) != 0)
X	    Strcpy(s+4, "y");
X	/* luckily no monster names end in fe or ve with ves plurals */
X	else if ((s = strstri(str, "ves")) != 0)
X	    Strcpy(s, "f");
X
X	slen = strlen(str);
X	for (len = 0, i = 0; i < NUMMONS; i++) {
X	    register int m_i_len = strlen(mons[i].mname);
X	    if (m_i_len > len && !strncmpi(mons[i].mname, str, m_i_len)) {
X		if (m_i_len == slen) return i;	/* exact match */
X		else if (slen > m_i_len &&
X			(str[m_i_len] == ' ' ||
X			 !strcmpi(&str[m_i_len], "s") ||
X			 !strncmpi(&str[m_i_len], "s ", 2) ||
X			 !strcmpi(&str[m_i_len], "es") ||
X			 !strncmpi(&str[m_i_len], "es ", 3))) {
X		    mntmp = i;
X		    len = m_i_len;
X		}
X	    }
X	}
X	if (mntmp == -1) mntmp = title_to_mon(str, (int *)0, (int *)0);
X	return mntmp;
X}
X
X#endif /* OVL1 */
X#ifdef OVLB
X
X#ifdef POLYSELF
Xboolean
Xwebmaker(ptr)   /* creature can spin a web */
X	register struct permonst *ptr;
X{
X	return (ptr->mlet == S_SPIDER && ptr != &mons[PM_SCORPION]);
X}
X#endif
X
X#endif /* OVLB */
X#ifdef OVL2
X
X/* returns 3 values (0=male, 1=female, 2=none) */
Xint
Xgender(mtmp)
X	register struct monst *mtmp;
X{
X	if (is_neuter(mtmp->data)) return 2;
X	return mtmp->female;
X}
X
X#endif /* OVL2 */
X#ifdef OVLB
X
Xboolean
Xlevl_follower(mtmp)
Xregister struct monst *mtmp;
X{
X	return (mtmp->mtame || (mtmp->data->mflags2 & M2_STALK) || is_fshk(mtmp)
X		|| (mtmp->iswiz && !mon_has_amulet(mtmp)));
X}
X
Xstruct permonst *
Xplayer_mon()
X{
X	switch (pl_character[0]) {
X		case 'A': return &mons[PM_ARCHEOLOGIST];
X		case 'B': return &mons[PM_BARBARIAN];
X		case 'C': if (flags.female) return &mons[PM_CAVEWOMAN];
X			else return &mons[PM_CAVEMAN];
X		case 'E': return &mons[PM_ELF];
X		case 'H': return &mons[PM_HEALER];
X		case 'K': return &mons[PM_KNIGHT];
X		case 'P': if (flags.female) return &mons[PM_PRIESTESS];
X			else return &mons[PM_PRIEST];
X		case 'R': return &mons[PM_ROGUE];
X		case 'S': return &mons[PM_SAMURAI];
X#ifdef TOURIST
X		case 'T': return &mons[PM_TOURIST];
X#endif
X		case 'V': return &mons[PM_VALKYRIE];
X		case 'W': return &mons[PM_WIZARD];
X		default: impossible("what are you?");
X			return &mons[PM_HUMAN];
X	}
X}
X
Xconst int grownups[][2] = { {PM_LITTLE_DOG, PM_DOG}, {PM_DOG, PM_LARGE_DOG},
X	{PM_HELL_HOUND_PUP, PM_HELL_HOUND}, {PM_KITTEN, PM_HOUSECAT},
X	{PM_HOUSECAT, PM_LARGE_CAT}, {PM_BABY_GRAY_DRAGON, PM_GRAY_DRAGON},
X	{PM_KOBOLD, PM_LARGE_KOBOLD}, {PM_LARGE_KOBOLD, PM_KOBOLD_LORD},
X	{PM_GNOME, PM_GNOME_LORD}, {PM_GNOME_LORD, PM_GNOME_KING},
X	{PM_DWARF, PM_DWARF_LORD}, {PM_DWARF_LORD, PM_DWARF_KING},
X	{PM_SMALL_MIMIC, PM_LARGE_MIMIC}, {PM_LARGE_MIMIC, PM_GIANT_MIMIC},
X	{PM_BAT, PM_GIANT_BAT},
X	{PM_LICH, PM_DEMILICH}, {PM_DEMILICH, PM_MASTER_LICH},
X	{PM_OGRE, PM_OGRE_LORD}, {PM_OGRE_LORD, PM_OGRE_KING},
X	{PM_VAMPIRE, PM_VAMPIRE_LORD},
X	{PM_BABY_RED_DRAGON, PM_RED_DRAGON},
X	{PM_BABY_WHITE_DRAGON, PM_WHITE_DRAGON},
X	{PM_BABY_BLUE_DRAGON, PM_BLUE_DRAGON},
X	{PM_BABY_GREEN_DRAGON, PM_GREEN_DRAGON},
X	{PM_BABY_ORANGE_DRAGON, PM_ORANGE_DRAGON},
X	{PM_BABY_BLACK_DRAGON, PM_BLACK_DRAGON},
X	{PM_BABY_YELLOW_DRAGON, PM_YELLOW_DRAGON},
X	{PM_RED_NAGA_HATCHLING, PM_RED_NAGA},
X	{PM_BLACK_NAGA_HATCHLING, PM_BLACK_NAGA},
X	{PM_GOLDEN_NAGA_HATCHLING, PM_GOLDEN_NAGA},
X	{PM_GUARDIAN_NAGA_HATCHLING, PM_GUARDIAN_NAGA},
X	{PM_BABY_PURPLE_WORM, PM_PURPLE_WORM},
X	{PM_BABY_LONG_WORM, PM_LONG_WORM},
X#ifdef ARMY
X	{PM_SOLDIER, PM_SERGEANT},
X	{PM_SERGEANT, PM_LIEUTENANT},
X	{PM_LIEUTENANT, PM_CAPTAIN},
X#endif
X	{PM_WATCHMAN, PM_WATCH_CAPTAIN},
X	{PM_BABY_CROCODILE, PM_CROCODILE},
X	{-1,-1}
X};
X
Xint
Xlittle_to_big(montype)
Xint montype;
X{
X#ifndef AIXPS2_BUG
X	register int i;
X	
X	for(i=0; grownups[i][0] >= 0; i++)
X		if(montype == grownups[i][0]) return grownups[i][1];
X	return montype;
X#else
X/* AIX PS/2 C-compiler 1.1.1 optimizer does not like the above for loop,
X * and causes segmentation faults at runtime.  (The problem does not
X * occur if -O is not used.)
X * lehtonen@cs.Helsinki.FI (Tapio Lehtonen) 28031990
X */
X	int i;
X	int monvalue;
X
X	monvalue = montype;
X	for(i=0; grownups[i][0] >= 0; i++)
X		if(montype == grownups[i][0]) monvalue = grownups[i][1];
X	
X	return monvalue;
X#endif
X}
X
Xint
Xbig_to_little(montype)
Xint montype;
X{
X	register int i;
X	
X	for(i=0; grownups[i][0] >= 0; i++)
X		if(montype == grownups[i][1]) return grownups[i][0];
X	return montype;
X}
X
X
Xconst char *
Xlocomotion(ptr, def)
Xconst struct permonst *ptr;
Xconst char *def;
X{
X	return (
X		is_floater(ptr) ? (const char *)"float" :
X		is_flyer(ptr)   ? (const char *)"fly" :
X		slithy(ptr)     ? (const char *)"slither" :
X		amorphous(ptr)  ? (const char *)"ooze" :
X		nolimbs(ptr)    ? (const char *)"crawl" :
X		def
X	       );
X
X}
X
X#endif /* OVLB */
X
X/*mondata.c*/
END_OF_FILE
if test 10482 -ne `wc -c <'src/mondata.c'`; then
    echo shar: \"'src/mondata.c'\" unpacked with wrong size!
fi
# end of 'src/mondata.c'
fi
if test -f 'sys/mac/macmain.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/mac/macmain.c'\"
else
echo shar: Extracting \"'sys/mac/macmain.c'\" \(12965 characters\)
sed "s/^X//" >'sys/mac/macmain.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)macmain.c	3.1	92/12/04	*/
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X/* main.c - Mac NetHack */
X
X#include "hack.h"
X
X#include <OSUtils.h>
X#include <files.h>
X#include <Types.h>
X#ifdef MAC_MPW32
X#include <String.h>
X#include <Strings.h>
X#endif
X#ifdef MAC_THINKC5
X#include <pascal.h>
X#endif
X#include <Dialogs.h>
X#include <Packages.h>
X#include <ToolUtils.h>
X#include <Resources.h>
X#include <SysEqu.h>
X#include <Errors.h>
X
X#ifndef O_RDONLY
X#include <fcntl.h>
X#endif
X
Xint NDECL(main);
Xvoid NDECL(ListGUnloads);
X
Xstatic void NDECL(process_options);
Xstatic void NDECL(whoami);
X
Xextern char * PtoCstr ( unsigned char * ) ;
Xextern unsigned char * CtoPstr ( char * ) ;
Xvoid SetFrameItem ( DialogPtr , short , short ) ;
X
Xextern void NDECL ( finder_file_request ) ;
X// void NDECL( askname ) ;
X
Xextern void NDECL ( InitMac ) ;
X
Xint
Xmain ( void )
X{
X	register int fd;
X
X	windowprocs = mac_procs ;
X	InitMac ( ) ;
X
X	hname = "Mac Hack" ;
X	hackpid = getpid();
X
X	initoptions();
X	init_nhwindows();
X	whoami();
X
X	/*
X	 * It seems you really want to play.
X	 */
X	setrandom();
X	u.uhp = 1;	/* prevent RIP on early quits */
X
X	process_options ( ) ;	/* emulate command line options */
X	finder_file_request ( ) ;
X
X#ifdef WIZARD
X	if (wizard)
X		Strcpy(plname, "wizard");
X	else
X#endif
X	if(!*plname || !strncmp(plname, "player", 4)
X		    || !strncmp(plname, "games", 4))
X		askname();
X	plnamesuffix();		/* strip suffix from name; calls askname() */
X				/* again if suffix was whole name */
X				/* accepts any suffix */
X
X	Sprintf ( lock , "%d%s" , getuid ( ) , plname ) ;
X	getlock ( ) ;
X
X	/*
X	 * Initialisation of the boundaries of the mazes
X	 * Both boundaries have to be even.
X	 */
X
X	x_maze_max = COLNO-1;
X	if (x_maze_max % 2)
X		x_maze_max--;
X	y_maze_max = ROWNO-1;
X	if (y_maze_max % 2)
X		y_maze_max--;
X
X	/*
X	 *  Initialize the vision system.  This must be before mklev() on a
X	 *  new game or before a level restore on a saved game.
X	 */
X	vision_init();
X
X	display_gamewindows();
X
X	set_savefile_name();
X	uncompress(SAVEF);
X
X	if((fd = open_savefile()) >= 0 &&
X	   /* if not up-to-date, quietly delete file via false condition */
X	   (uptodate(fd) || delete_savefile())) {
X#ifdef WIZARD
X		/* Since wizard is actually flags.debug, restoring might
X		 * overwrite it.
X		 */
X		boolean remember_wiz_mode = wizard;
X#endif
X#ifdef NEWS
X		if(flags.news) display_file(NEWS, FALSE);
X#endif
X		pline("Restoring save file...");
X		mark_synch();	/* flush output */
X		if(!dorecover(fd))
X			goto not_recovered;
X#ifdef WIZARD
X		if(!wizard && remember_wiz_mode) wizard = TRUE;
X#endif
X		pline("Hello %s, welcome back to NetHack!", plname);
X		check_special_room(FALSE);
X
X#ifdef EXPLORE_MODE
X		if (discover)
X			You("are in non-scoring discovery mode.");
X#endif
X#if defined(EXPLORE_MODE) || defined(WIZARD)
X		if (discover || wizard) {
X			if(yn("Do you want to keep the save file?") == 'n')
X			    (void) delete_savefile();
X			else {
X			    compress(SAVEF);
X			}
X		}
X#endif
X		flags.move = 0;
X	} else {
Xnot_recovered:
X		player_selection();
X		newgame();
X		/* give welcome message before pickup messages */
X		pline("Hello %s, welcome to NetHack!", plname);
X#ifdef EXPLORE_MODE
X		if (discover)
X			You("are in non-scoring discovery mode.");
X#endif
X		flags.move = 0;
X		set_wear();
X		pickup(1);
X	}
X
X	flags.moonphase = phase_of_the_moon();
X	if(flags.moonphase == FULL_MOON) {
X		You("are lucky!  Full moon tonight.");
X		change_luck(1);
X	} else if(flags.moonphase == NEW_MOON) {
X		pline("Be careful!  New moon tonight.");
X	}
X	if(flags.friday13 = friday_13th()) {
X		pline("Watch out!  Bad things can happen on Friday the 13th.");
X		change_luck(-1);
X	}
X
X	initrack();
X
X	UndimMenuBar ( ) ; /* Yes, this is the place for it (!) */
X	
X	attemptingto("proceed");
X#if defined(MAC_MPW32) && !defined(MODEL_FAR)
X	UnloadAllSegments();						/* Do this before naming residents */
X	IsResident( (Ptr) display_nhwindow );		/* Sample resident segments */
X	IsResident( (Ptr) rhack );
X	IsResident( (Ptr) engr_at );
X	IsResident( (Ptr) movemon );
X	IsResident( (Ptr) attacktype ) ;
X	IsResident( (Ptr) mac_get_nh_event ) ;
X#endif
X	moveloop();
X	/*NOTREACHED*/
X	return 0;
X}
X
X
X/*
X * This filter handles the movable-modal dialog
X *
X */
Xstatic pascal Boolean
XDragFilter ( DialogPtr dp , EventRecord * event , short * item )
X{
X	WindowPtr wp ;
X	short code ;
X	Rect r ;
X
X/*
X *	Handle shortcut keys
X *	enter, return -> OK
X *	clear, escape, period -> Cancel
X *	all others are handled default
X *
X */
X
X	if ( event -> what == keyDown ) {
X
X		char c = event -> message & 0xff ;
X		unsigned char b = ( event -> message >> 8 ) & 0xff ;
X
X		switch ( c ) {
X
X		case 3 :	/* 3 == Enter */
X		case 10 :	/* Newline */
X		case 13 :	/* Return */
X			* item = 1 ;
X			return 1 ;
X
X		case '.' :	/* Cmd-period - we allow only period */
X		case 27 :	/* Escape */
X			* item = 2 ;
X			return 1 ;
X		}
X
X		switch ( b ) {
X
X		case 0x4c :	/* Enter */
X		case 0x24 :	/* Return */
X			* item = 1 ;
X			return 1 ;
X
X		case 0x35 :	/* Escape */
X		case 0x47 :	/* Clear */
X			* item = 2 ;
X			return 1 ;
X		}
X
X		return 0 ;
X	}
X
X/*
X *	OK, don't handle others
X *
X */
X
X	if ( event -> what != mouseDown ) {
X
X		return 0 ;
X	}
X	code = FindWindow ( event -> where , & wp ) ;
X	if ( wp != dp || code != inDrag ) {
X
X		return 0 ;
X	}
X	r = ( * GetGrayRgn ( ) ) -> rgnBBox ;
X	InsetRect ( & r , 3 , 3 ) ;
X
X	DragWindow ( wp , event -> where , & r ) ;
X	SaveWindowPos ( wp ) ;
X
X	event -> what = nullEvent ;
X	return 1 ;
X}
X
X
X/*
X * plname is filled either by an option (-u Player  or  -uPlayer) or
X * explicitly (by being the wizard) or by askname.
X * It may still contain a suffix denoting pl_character.
X */
Xvoid
Xmac_askname(void) /* Code taken from getlin */
X{
X	ControlHandle	ctrl ;
X	DialogPtr		promptDialog ;
X	short			itemHit , type ;
X	Rect			box ;
X	Str255			pasStr ;
X
X	/*
X	** Set the query line as parameter text.
X	*/
X
X	ParamText ( "\PWho are you?" , "\p" , "\p" , "\p" ) ;
X
X	promptDialog = GetNewDialog ( 130 , ( Ptr ) NULL , ( WindowPtr ) -1 ) ;
X	ShowWindow ( promptDialog ) ;
X
X	InitCursor ( ) ;
X	SetFrameItem ( promptDialog , 6 , 1 ) ;
X	do {
X
X		ModalDialog ( ( ModalFilterProcPtr ) DragFilter , & itemHit ) ;
X
X	} while ( ( itemHit != 1 ) && ( itemHit != 2 ) ) ;
X
X	if ( itemHit == 1 ) {
X
X		/*
X		** Get the text from the text edit item.
X		*/
X
X		GetDItem ( promptDialog , 4 , & type , ( Handle * ) & ctrl , & box ) ;
X		GetIText ( ( Handle ) ctrl , pasStr ) ;
X
X		/*
X		** Convert it to a 'C' string and copy it into the return value.
X		*/
X
X		PtoCstr ( pasStr ) ;
X		strcpy ( plname , ( char * ) pasStr ) ;
X
X	/*
X	 * Special check for debugging here
X	 *
X	 */
X#ifdef WIZARD
X		if ( ! strcmp ( plname , WIZARD ) ) {
X
X			flags . debug = 1 ;
X		}
X#endif
X
X	} else {
X
X		/*
X		** Okay, we didn't want to run
X		*/
X
X	/*	* ( short * ) DSErrCode = dsBadLaunch ; */
X		ExitToShell ( ) ;
X	}
X
X	DisposDialog ( promptDialog ) ;
X}
X
X
Xstatic void
Xprocess_options(void)
X{
X	int argc = 0 ;
X	char * foo [ ] = { "Mac Hack" , NULL } ;
X	char * * argv = foo ;
X	/*
X	 * Process options.
X	 */
X	while(argc > 1 && argv[1][0] == '-'){
X		argv++;
X		argc--;
X		switch(argv[0][1]){
X#if defined(WIZARD) || defined(EXPLORE_MODE)
X# ifndef EXPLORE_MODE
X		case 'X':
X# endif
X		case 'D':
X# ifdef WIZARD
X			wizard = TRUE ;
X			break ;
X# endif
X# ifdef EXPLORE_MODE
X		case 'X':
X			discover = TRUE;
X# endif
X			break;
X#endif
X#ifdef NEWS
X		case 'n':
X			flags.news = FALSE;
X			break;
X#endif
X		case 'u':
X			if(argv[0][2])
X			  (void) strncpy(plname, argv[0]+2, sizeof(plname)-1);
X			else if(argc > 1) {
X			  argc--;
X			  argv++;
X			  (void) strncpy(plname, argv[0], sizeof(plname)-1);
X			} else
X				raw_print("Player name expected after -u");
X			break;
X		case 'I':
X		case 'i':
X			if (!strncmpi(argv[0]+1, "IBM", 3))
X				switch_graphics(IBM_GRAPHICS);
X			break;
X	    /*  case 'D': */
X		case 'd':
X			if (!strncmpi(argv[0]+1, "DEC", 3))
X				switch_graphics(DEC_GRAPHICS);
X			break;
X		default:
X			/* allow -T for Tourist, etc. */
X			(void) strncpy(pl_character, argv[0]+1,
X				sizeof(pl_character)-1);
X
X			/* raw_print("Unknown option: %s", *argv); */
X		}
X	}
X}
X
X
Xstatic void
Xwhoami ( void )
X{
X	/*TODO*/
X	donull ( ) ;
X}
X
X
X/*------------------- UnloadAllSegments and support stuff --------------------------*/
X/* Derived from MacApp source */
X
Xtypedef Handle **HandleListHandle;
Xtypedef Boolean **BoolListHandle;
Xtypedef short *ShortPtr, **ShortHandle;
X
Xshort FDECL(GetSegNumber,(ShortPtr));
Xvoid FDECL(InitSegMgmt,(void *));
Xpascal long NDECL(GetA5);
Xpascal short NDECL(GetCurJTOffset);
Xvoid NDECL(UnloadAllSegments);
Xvoid FDECL(IsResident,(void *));
Xvoid FDECL(NotResident, (void *));
X
Xshort 			 pMaxSegNum = 0,		/* Highest segment number */
X	  			 gCodeRefNum;			/* rsrc refnum of the application */
XHandleListHandle gCodeSegs;				/* List of code seg handles */
XBoolListHandle   gIsResidentSeg;		/* Resident flags */
X
X#define kLoaded   0x4EF9				/* if loaded then a JMP instruction */
X#define	kUnLoaded 0x3F3C				/* if unloaded then a LoadSeg trap */
X										/* Note: probably incorrect for -model far! */
X
X/* #define TRACKSEGS /* Utility to print a trace of segment load frequencies. Add
X   a call to ListGUnloads into terminate() in end.c to use it */
X
X#ifdef TRACKSEGS
X
Xlong	  gUnloads[120];
Xchar	  gSegNames[120][16];
X
Xvoid ListGUnloads(void)
X{
X  int i;
X  FILE *f;
X  
X  f = fopen("unloads","r+");
X  fprintf(f,"%d calls to UnloadAllSegments\n\n",gUnloads[0]);
X  for (i=1; i<=pMaxSegNum; i++) {
X	 fprintf(f,"Unloaded %10s, segment %2d, %6d times\n",gSegNames[i],i,gUnloads[i]);
X  }
X  fclose(f);
X}
X
X#endif
X
Xshort GetSegNumber(ShortPtr aProc)
X/* Derives seg number from a procedure ptr */
X
X{
X	if (*aProc == kLoaded) 				/* loaded segment */
X		return(*--aProc);
X	else if (*aProc == kUnLoaded)  		/* unloaded segment */
X		return(*++aProc);
X	else {
X		progerror("GetSegNumber was not passed an jump table address");
X		return(1);
X	}
X}
X
Xvoid InitSegMgmt(void * mainSeg)
X/* Initialise a list of handles to all the CODE segments and mark the mainseg as resident */
X{
X	short 	i,
X			lastRsrc,
X			rsrcID,
X			oldResFile;
X	Handle  seg;
X	ResType rsrcType;
X	Str255  rsrcName;
X	 
X	gCodeRefNum = HomeResFile(GetResource('CODE', 1));	
X	oldResFile = CurResFile();
X	UseResFile(gCodeRefNum);
X	
X	/* Discover the highest CODE rsrc ID: be ready for noncontiguous IDs */
X	lastRsrc = Count1Resources('CODE');	
X	SetResLoad(false);
X	for (i=1; i<=lastRsrc; i++) 
X		if (seg = Get1IndResource('CODE', i)) {
X			GetResInfo(seg, &rsrcID, &rsrcType, rsrcName);
X			if (rsrcID > pMaxSegNum) pMaxSegNum = rsrcID;
X		}
X		
X	/* Make handles of appropriate size to keep flags/segment handles */
X	SetResLoad(true);  /* In case we fail */
X	gCodeSegs = (HandleListHandle) NewHandle((pMaxSegNum+1) * sizeof(Handle));	
X	mustwork(MemError());
X	gIsResidentSeg = (BoolListHandle) NewHandle((pMaxSegNum+1) * sizeof(Boolean));
X	mustwork(MemError());
X	SetResLoad(false);	
X
X	#ifdef TRACKSEGS
X	gUnloads[0]=0;
X	#endif
X	for (i=1; i<=pMaxSegNum; i++) {
X	   (*gIsResidentSeg)[i] = false;
X	   (*gCodeSegs)[i] = Get1Resource('CODE',i);   /* Will be NIL if it doesn't exist */
X	   #ifdef TRACKSEGS
X	   {  /* Go get the segment name and save it */
X	      short id;
X		  ResType rType;
X		  Str255 name;
X		  char *cptr;
X		  
X		  GetResInfo((*gCodeSegs)[i],&id,&rType,&name);
X		  if (name[0]>15) name[0]=15;
X		  cptr = p2cstr(&name);
X		  cptr = strcpy(&gSegNames[i], &name);
X		  gUnloads[i] = 0;
X	   }
X	   #endif
X	}
X	SetResLoad(true);	
X	(*gIsResidentSeg)[GetSegNumber((ShortPtr)mainSeg)] = true;	
X	UseResFile(oldResFile);
X}
X
X#ifdef MAC_MPW32
Xpascal long GetA5(void) = { 0x2E8D };					/* MOVE.L A5,(A7) */
Xpascal short GetCurJTOffset(void) = { 0x3EB8, 0x934 };   /* MOVE.W CurJTOffset,(SP) */
X#endif
X#ifdef MAC_THINKC5
Xpascal long GetA5(void) = { 0x2E8D };					/* MOVE.L A5,(A7) */
Xpascal short GetCurJTOffset(void) = { 0x3EB8, 0x934 };   /* MOVE.W CurJTOffset,(SP) */
X#endif
X
Xvoid UnloadAllSegments(void)
X{
X  short	 i,
X		 oldResFile;
X  Handle seg;
X  long	 jumpTablePtr;
X
X  jumpTablePtr = GetA5() + GetCurJTOffset();
X  oldResFile = CurResFile();
X  UseResFile(gCodeRefNum);
X#ifdef TRACKSEGS
X  gUnloads[0]++;
X#endif
X  for (i=1; i<=pMaxSegNum; i++)
X	  if (!(*gIsResidentSeg)[i]) {
X		  seg = (*gCodeSegs)[i];
X		  if ((seg != (Handle) nil) && (*seg != (Ptr) nil))  /* Check it exists and hasn't been purged */
X			  if (HGetState(seg) & 0x80)  {   /* Is it locked? => loaded */
X#ifdef TRACKSEGS
X				 gUnloads[i]++;
X#endif
X				 UnloadSeg( (void *) (jumpTablePtr + **(ShortHandle)seg + 2) );
X			  }
X	  }
X
X  UseResFile(oldResFile);
X}
X
Xvoid IsResident( void * routineaddr )
X/* We want to move this high up in the heap as it won't be shifted again, so... */
X{
X	int    segnum;
X	Handle theseg;
X	
X	segnum = GetSegNumber((ShortPtr)routineaddr);
X	theseg = (*gCodeSegs)[segnum];
X	UnloadSeg( routineaddr );
X	if (*theseg != nil) {
X	   MoveHHi( theseg );  /* If it has been purged we can't do this */
X	   HLock( theseg );
X	}
X	(*gIsResidentSeg)[segnum] = true;	
X}
X
Xvoid NotResident( void * routineaddr )
X{
X	(*gIsResidentSeg)[GetSegNumber((ShortPtr)routineaddr)] = false;	
X}
X
X/*macmain.c*/
END_OF_FILE
if test 12965 -ne `wc -c <'sys/mac/macmain.c'`; then
    echo shar: \"'sys/mac/macmain.c'\" unpacked with wrong size!
fi
# end of 'sys/mac/macmain.c'
fi
if test -f 'sys/share/termcap' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/share/termcap'\"
else
echo shar: Extracting \"'sys/share/termcap'\" \(5404 characters\)
sed "s/^X//" >'sys/share/termcap' <<'END_OF_FILE'
X#
X#	MS/PC-DOS ANSI.SYS termcap
X#
Xansi|color|ansi-color|ibm|ibmpc|ANSI.SYS color:\
X	:co#80:li#24:bs:pt:bl=^G:le=^H:do=^J:\
X	:cl=\E[H\E[2J:ce=\E[K:\
X	:ho=\E[H:cm=\E[%i%d;%dH:\
X	:up=\E[A:do=\E[B:le=\E[C:ri=\E[D:nd=\E[C:\
X	:ti=\E[0;44m:te=\E[0m:\
X	:so=\E[1;35;44m:se=\E[0;44m:\
X	:us=\E[1;31;44m:ue=\E[0;44m:\
X	:mb=\E[5m:md=\E[1m:me=\E[0;44m:
Xmono|ansi-mono|ANSI.SYS:\
X	:co#80:li#24:bs:pt:bl=^G:le=^H:do=^J:\
X	:cl=\E[H\E[2J:ce=\E[K:\
X	:ho=\E[H:cm=\E[%i%d;%dH:\
X	:up=\E[A:do=\E[B:le=\E[C:ri=\E[D:nd=\E[C:\
X	:so=\E[1m:se=\E[m:us=\E[4m:ue=\E[m:\
X	:mb=\E[5m:md=\E[1m:me=\E[m:
X#
X#	This is a termcap for NNANSI.SYS (New & Improved NANSI.SYS),
X#	a faster and more complete public domain replacement for
X#	ANSI.SYS, and two other ANSI.SYS replacements, NANSI.SYS and
X#	ZANSI.SYS.
X#
X#	NANSI and ZANSI support line insert (al) and delete (dl)
X#	and character insert (ic) and delete (dc) where ANSI.SYS
X#	does not.  NNANSI.SYS also supports clear to end of display
X#	(cd), does reverse video (mr) properly, and emulates SGR
X#	more fully, allowing correct end sequences for standout (se)
X#	and end of underline (ue).
X#
Xnnansi-mono|NNANSI.SYS:\
X	:co#80:li#25:bs:pt:bl=^G:le=^H:do=^J:\
X	:cl=\E[2J:cd=\E[J:ce=\E[K:\
X	:ho=\E[H:cm=\E[%i%d;%dH:\
X	:up=\E[A:do=\E[B:le=\E[C:ri=\E[D:nd=\E[C:\
X	:so=\E[1m:se=\E[2m:\
X	:us=\E[4m:ue=\E[24m:\
X	:mb=\E[5m:md=\E[1m:mh=\E[2m:mr=\E[7m:me=\E[m:\
X	:al=\E[L:dl=\E[M:ic=\E[@:dc=\E[P:
Xnnansi|NNANSI.SYS color:\
X	:co#80:li#25:bs:pt:bl=^G:le=^H:do=^J:\
X	:cl=\E[2J:cd=\E[J:ce=\E[K:\
X	:ho=\E[H:cm=\E[%i%d;%dH:\
X	:up=\E[A:do=\E[B:le=\E[C:ri=\E[D:nd=\E[C:\
X	:ti=\E[0;44m:te=\E[0m:\
X	:so=\E[1;35;44m:se=\E[2;37m:\
X	:us=\E[4m:ue=\E[24m:\
X	:mb=\E[5m:md=\E[1m:mh=\E[2m:mr=\E[7m:me=\E[0;44m:\
X	:al=\E[L:dl=\E[M:ic=\E[@:dc=\E[P:
Xnansi-mono|zansi-mono|N/ZANSI.SYS:\
X	:co#80:li#25:bs:pt:bl=^G:le=^H:do=^J:\
X	:cl=\E[2J:ce=\E[K:\
X	:ho=\E[H:cm=\E[%i%d;%dH:\
X	:up=\E[A:do=\E[B:le=\E[C:ri=\E[D:nd=\E[C:\
X	:ti=\E[0m:te=\E[0m:\
X	:so=\E[1;35m:se=\E[0m:\
X	:us=\E[1;31m:ue=\E[0m:\
X	:mb=\E[5m:md=\E[1m:mr=\E[7m:me=\E[m:\
X	:al=\E[L:dl=\E[M:ic=\E[@:dc=\E[P:
Xnansi|zansi|N/ZANSI.SYS color:\
X	:co#80:li#25:bs:pt:bl=^G:le=^H:do=^J:\
X	:cl=\E[2J:ce=\E[K:\
X	:ho=\E[H:cm=\E[%i%d;%dH:\
X	:up=\E[A:do=\E[B:le=\E[C:ri=\E[D:nd=\E[C:\
X	:ti=\E[0;44m:te=\E[0m:\
X	:so=\E[1;35;44m:se=\E[0;44m:\
X	:us=\E[1;31;44m:ue=\E[0;44m:\
X	:mb=\E[5m:md=\E[1m:mr=\E[7m:me=\E[0;44m:\
X	:al=\E[L:dl=\E[M:ic=\E[@:dc=\E[P:
X#
X# For ST NetHack:
X#       for VT100/200/&c in VT52 mode, add :ti=\E[?2l:
Xvt52|atari|DEC VT52:\
X	:co#80:li#24:bs:pt:bl=^G:le=^H:do=^J:\
X	:cl=\EH\EJ:ce=\EK:cd=\EJ:\
X	:ho=\EH:cm=\EY%+ %+ :\
X	:up=\EA:do=\EB:le=\EC:ri=\ED:nd=\EC:\
X	:ku=\EA:kd=\EB:kl=\EC:kr=\ED:kb=^H:\
X	:sr=\EI:as=\EF:ae=\EG:
X#
X# For Amiga or VMS NetHack:
X#       VT100 or clone without the advanced video option installed
Xvt100|amiga|vt100-80|vt100-noavo|DEC VT100:\
X	:co#80:li#24:bs:pt:am:mi:bl=^G:le=^H:do=^J:xo:vt#3:\
X	:cl=50\E[H\E[J:ce=3\E[K:cd=50\E[J:\
X	:ho=\E[H:cm=5\E[%i%d;%dH:cs=\E[%i%d;%dr:\
X	:up=\E[A:do=\E[B:le=\E[C:ri=\E[D:nd=\E[C:\
X	:UP=\E[%dA:DO=\E[%dB:LE=\E[%dC:RI=\E[%dD:\
X	:so=2\E[7m:se=2\E[m:us=2\E[4m:ue=2\E[m:\
X	:mb=2\E[5m:md=2\E[1m:mr=2\E[7m:me=2\E[m:\
X	:ti=4\E<\E(B\E)0:as=^N:ae=^O:\
X	:ks=\E[?1h\E=:ke=\E[?1l\E>:ku=\E[A:kd=\E[B:kl=\E[C:kr=\E[D:kb=^H:\
X	:kn#4:k1=\EOP:k2=\EOQ:k3=\EOR:k4=\EOS:\
X	:sc=\E7:ec=\E8:sr=5\EM:
X#
X# VT102 and up:
X#       includes VT100 with advanced video option
Xvt102|vt102-80|vt100-avo|DEC VT102:\
X	:im=\E[4h:ei=\E[4l:al=5\E[L:dl=5\E[M:dc=5\E[P:\
X	:AL=9\E[%dL:DL=9\E[%dM:tc=vt100:
Xvt200|vt200-80|vt220|vt240|vt241|VT200_Series:\
X	:ic=5\E[@:tc=vt102:
Xvt300|vt300-80|vt320|vt330|vt340|VT300_Series:\
X	:tc=vt200:
Xvt400|vt400-80|vt420|VT400_Series:\
X	:tc=vt300:
X# VAXstations (should have full entries with no delays and 8-bit CSI's)
XVWS|UIS:tc=vt200:
XDECterm:tc=vt300:
X#
X# Wide screen (magnifying glass not included;-)
X#       note: vt100 w/o AVO only supports 14 lines when in 132-column mode
Xvt132|vt100-132:vt102-132:\
X	:co#132:ti=9\E<\E(B\E)0\E[?3h:tc=vt102:
Xvt200-132|vt300-132:\
X	:co#132:ti=9\E<\E(B\E)0\E[?3h:tc=vt200:
X#
X#
X# For really complete ANSI emulations (FANSI-CONSOLE?):
X#
XAX|ANSI X3.64|full ANSI X3.64 (1977) standard:\
X	:co#80:li#24:bs:pt:am:mi:bl=^G:le=^H:\
X	:cl=\E[2J:ce=\E[K:cd=\E[J:\
X	:ho=\E[H:cm=\E[%i%d;%dH:cs=\E[%i%d;%dr:\
X	:up=\E[A:do=\E[B:le=\E[C:ri=\E[D:nd=\E[C:\
X	:UP=\E[%dA:DO=\E[%dB:LE=\E[%dC:RI=\E[%dD:\
X	:so=\E[7m:se=\E[m:us=\E[4m:ue=\E[m:\
X	:mb=\E[5m:md=\E[1m:mr=\E[7m:me=\E[m:as=^N:ae=^O:\
X	:ku=\E[A:kd=\E[B:kl=\E[C:kr=\E[D:kb=^H:\
X	:kn#4:k1=\EOP:k2=\EOQ:k3=\EOR:k4=\EOS:\
X	:im=\E[4h:ei=\E[4l:al=\E[L:dl=\E[M:ic=\E[@:dc=\E[P:sf=\ED:sr=\EM:
X#
X# Display hacker's tool
X#
Xdebug|debugging entry:\
X	:ae=<ae>:AL=<AL%d>:al=<al>:am:as=<as>:bl=<bl>:bs:bt=<bt>:bw:CC=<CC>:\
X	:cd=<cd>:ce=<ce>:ch=<ch%d>:cl=<cl>:cm=<cm%d,%d>:co#80:cr=<cr>:\
X	:cs=<cs%d,%d>:ct=<ct>:cv=<cv%d>:da:db:DC=<DC%d>:dc=<dc>:DL=<DL%d>:\
X	:dl=<dl>:dm=<dm>:DO=<DO%d>:do=<do>:ds=<ds>:ec=<ec%d>:ed=<ed>:ei=<ei>:\
X	:es:fs=<fs>:ho=<ho>:hs:IC=<IC%d>:ic=<ic>:im=<im>:ip=<ip>:is=<is>:\
X	:it#8:ke=<ke>:LE=<LE%d>:le=<le>:li#24:ll=<ll>:mb=<mb>:md=<md>:me=<me>:\
X	:mh=<mh>:mi:mk=<mk>:mm=<mm>:mo=<mo>:mp=<mp>:mr=<mr>:ms=<ms>:nd=<nd>:\
X	:nw=<nw>:pc=<pc>:pf=<pf>:pO=<pO%d>:po=<po>:ps=<ps>:rc=<rc>:RI=<RI%d>:\
X	:rp=<rp%.%d>:rs=<rs>:sc=<sc>:se=<se>:SF=<SF%d>:sf=<sf>:so=<so>:\
X	:SR=<SR%d>:sr=<sr>:st=<st>:ta=<ta>:te=<te>:ti=<ti>:uc=<uc>:ue=<ue>:\
X	:UP=<UP%d>:up=<up>:us=<us>:vb=<vb>:ve=<ve>:vi=<vi>:vs=<vs>:
X#
Xdumb:\
X	:am:bl=^G:co#80:do=^J:nl=^M^J:
END_OF_FILE
if test 5404 -ne `wc -c <'sys/share/termcap'`; then
    echo shar: \"'sys/share/termcap'\" unpacked with wrong size!
fi
# end of 'sys/share/termcap'
fi
echo shar: End of archive 90 \(of 108\).
cp /dev/null ark90isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \
21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \
41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 \
61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 \
81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 \
101 102 103 104 105 106 107 108 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 108 archives.
    echo "Now execute 'rebuild.sh'"
    rm -f ark10[0-8]isdone ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
