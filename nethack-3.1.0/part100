Path: uunet!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v16i108:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Part100/108
Message-ID: <4473@master.CNA.TEK.COM>
Date: 5 Feb 93 22:03:29 GMT
Sender: news@master.CNA.TEK.COM
Lines: 1573
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1659

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 16, Issue 108
Archive-name: nethack31/Part100
Supersedes: nethack3p9: Volume 10, Issue 46-108
Environment: Amiga, Atari, Mac, MS-DOS, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 100 (of 108)."
# Contents:  dat/opthelp doc/nethack.6 include/mondata.h include/you.h
#   sys/amiga/NewGame.uu sys/amiga/colorwin.c sys/unix/Makefile.utl
#   sys/vms/install.com win/X11/Install.X11
# Wrapped by billr@saab on Wed Jan 27 16:09:29 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'dat/opthelp' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dat/opthelp'\"
else
echo shar: Extracting \"'dat/opthelp'\" \(6596 characters\)
sed "s/^X//" >'dat/opthelp' <<'END_OF_FILE'
XBoolean options available in all versions (with default values in []):
X
Xconfirm        ask before hitting tame or peaceful monsters       [TRUE]
XDECgraphics    use DEC/VT line-drawing characters for the dungeon [FALSE]
Xdisclose       offer information at the end of the game           [TRUE]
X(fe)male       sex of the player (may only be set on startup)     [MALE]
Xfixinv         try to retain the same letter for the same object  [TRUE]
Xhelp           print all available info when using the / command  [TRUE]
XIBMgraphics    use IBM extended characters for the dungeon        [FALSE]
Xignintr        ignore interrupt signal, including breaks          [FALSE]
Xlegacy         print introductory message                         [TRUE]
Xlit_corridor   show a dark corridor as lit if in sight            [FALSE]
Xnull           allow nulls to be sent to your terminal            [TRUE]
X               try turning this option off (forcing NetHack to use its own
X               delay code) if moving objects seem to teleport across rooms
Xnumber_pad     use the number keys to move instead of yuhjklbn    [FALSE]
Xpickup         automatically pick up objects you move over        [TRUE]
Xrest_on_space  count the space bar as a rest character            [FALSE]
Xsafe_pet       prevent you from (knowingly) attacking your pet(s) [TRUE]
Xsilent         don't use your terminal's bell sound               [TRUE]
Xsortpack       group similar kinds of objects in inventory        [TRUE]
Xstandout       use standout mode for --More-- on messages         [FALSE]
Xtime           display elapsed game time, in moves                [FALSE]
Xtombstone      print tombstone when you die                       [TRUE]
Xverbose        print more commentary during the game              [TRUE]
X
X
XThere are further boolean options that exist in some versions of NetHack
X3.1.  (You can learn which options exist in your version by checking your
Xcurrent option setting, which is reached via the 'O' cmd.)
X
XBoolean option if INSURANCE was set at compile time:
Xcheckpoint save game state after each level change, for possible  [TRUE]
X           recovery after program crash
X
XBoolean option if NEWS was set at compile time:
Xnews       print any news from game administrator on startup      [TRUE]
X
XBoolean options if DGK was set at compile time:
XBIOS       allow the use of IBM ROM BIOS calls                    [FALSE]
Xrawio      allow the use of raw I/O (may only be set on startup)  [FALSE]
X
XBoolean option if EXP_ON_BOTL was set at compile time:
Xshowexp    display your accumulated experience points             [FALSE]
X
XBoolean option if SCORE_ON_BOTL was set at compile time:
Xshowscore  display your approximate accumulated score             [FALSE]
X
XBoolean options if TEXTCOLOR was set at compile time:
Xcolor      use different colors for objects on screen   [TRUE for micros]
Xhilite_pet if color is FALSE, display pets in a highlighted way   [FALSE]
X
XAny Boolean option can be negated by prefixing it with a '!' or 'no'.
X
X
XCompound options are written as option_name:option_value.
X
XCompound options which can be set during the game are:
X
Xfruit      the name of a fruit you enjoy eating  [slime mold]
X           (basically a whimsy which NetHack uses from time to time).
Xpackorder  a list of default symbols for kinds of objects that gives the
X           order in which your pack will be displayed  [")[%?+!=/(*`0_]
X           (If you specify only some kinds of items, the others from the
X           default order will be appended to the end.)
Xscores     the parts of the score list you wish to see when the game ends
X           You choose a combination of top scores, scores around the top
X           scores, and all of your own scores.  [!own/3 top/2 around]
X
XCompound options which may be set only on startup are:
X
Xcatname    the name of your first cat  [NONE]
Xdogname    the name of your first dog  [NONE]
Xgraphics   a list of symbols to be used in place of the default ones for
X           drawing the dungeon.
X           The symbols are subjected to a fair amount of processing, so
X           that you can use C-style escapes such as \n or \081 as well as
X           indicate control characters by ^x or meta characters by \Mx.
X           As usual, \ can force the next character to be taken literally.
X           Since many of the default symbols are overloaded, they are
X           given here by name instead of symbol, with some added notes:
X           stone                               (solid rock, normally ' ')
X           vwall hwall tlcorn trcorn blcorn brcorn      (room boundaries)
X           crwall tuwall tdwall tlwall trwall (wallified maze characters)
X           nodoor vodoor hodoor      (no, vertical, horizontal open door)
X           vcdoor hcdoor               (vertical, horizontal closed door)
X           room darkcorr litcorr upstair dnstair upladder dnladder
X           trap web altar throne sink fountain pool ice lava
X           vodbridge hodbridge     (vertical, horizontal open drawbridge)
X           vcdbridge hcdbridge   (vertical, horizontal closed drawbridge)
X           air cloud water
X           vbeam hbeam lslant rslant                  (generic zap beams)
X           digbeam flashbeam      (special beams for digging and cameras)
X           boomleft boomright                                (boomerangs)
X           ss1 ss2 ss3 ss4                           (shielding sequence)
X           sw_topl, sw_topm, sw_topr,                  (swallow, top row)
X           sw_midl, sw_midr,            (swallow, middle row [no center])
X           sw_botl, sw_botm, sw_botr                (swallow, bottom row)
X           extl extm extr                      (explosion matrix top row)
X           exml exmm exmr                   (explosion matrix middle row)
X           exbl exbm exbr                   (explosion matrix bottom row)
Xmonsters   like graphics, but for monster symbols
X           default:  abcdefghijklmnopqrstuvwxyz
X                     ABCDEFGHIJKLMNOPQRSTUVWXYZ@\ \\&;:~]
Xmsghistory number of top line messages to save [20]
Xname       the name of your character  [obtained by asking the system or
X           the player]
Xobjects    like graphics, but for object symbols
X           default:  ])[="(%!?+/$*`0_.
Xpettype    your preferred type of pet (cat or dog), if your character
X           class uses both types  [RANDOM]
Xwindowtype windowing system to be used  [depends on operating system]
X
X
XSome sample options lists are:
X!pickup,!tombstone,name:Gandalf,scores:own/3 top/2 around
Xfemale,nonews,dogname:Rover,graphics: |--------|||-\\/+.#.<><>\^\"_\\#{}
Xrest_on_space,!verbose
END_OF_FILE
if test 6596 -ne `wc -c <'dat/opthelp'`; then
    echo shar: \"'dat/opthelp'\" unpacked with wrong size!
fi
# end of 'dat/opthelp'
fi
if test -f 'doc/nethack.6' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/nethack.6'\"
else
echo shar: Extracting \"'doc/nethack.6'\" \(5923 characters\)
sed "s/^X//" >'doc/nethack.6' <<'END_OF_FILE'
X.TH NETHACK 6 "28 March 1989"
X.UC 4
X.SH NAME
Xnethack \- Exploring The Mazes of Menace
X.SH SYNOPSIS
X.B nethack
X[
X.B \-d
X.I directory
X]
X[
X.B \-n
X]
X[
X.B \-[ABCEHKPRSTVW]
X]
X[
X.B \-[DX]
X]
X[
X.B \-u
X.I playername
X]
X[
X.B \-dec
X]
X[
X.B \-ibm
X]
X.br
X.B nethack
X[
X.B \-d
X.I directory
X]
X.B \-s
X[
X.B \-[ABCEHKPRSTVW]
X]
X[
X.I playernames
X]
X.SH DESCRIPTION
X.PP
X.I NetHack
Xis a display oriented Dungeons & Dragons(tm) - like game.
XBoth display and command structure resemble rogue.
X.PP
XTo get started you really only need to know two commands.  The command
X.B ?
Xwill give you a list of the available commands (as well as other information)
Xand the command
X.B /
Xwill identify the things you see on the screen.
X.PP
XTo win the game (as opposed to merely playing to beat other people's high
Xscores) you must locate the Amulet of Yendor which is somewhere below
Xthe 20th level of the dungeon and get it out.
XNobody has achieved this yet; anybody who does will probably go down
Xin history as a hero among heros.
X.PP
XWhen the game ends, whether by your dying, quitting, or escaping
Xfrom the caves,
X.I NetHack
Xwill give you (a fragment of) the list of top scorers.
XThe scoring is based on many aspects of your behavior, but a rough estimate
Xis obtained by taking the amount of gold you've found in the cave plus four
Xtimes your (real) experience.
XPrecious stones may be worth a lot of gold when brought to the exit.
XThere is a 10% penalty for getting yourself killed.
X.PP
XThe environment variable NETHACKOPTIONS can be used to initialize many
Xrun-time options.
XThe ? command provides a description of these options and syntax.
X(The
X.B \-dec
Xand
X.B \-ibm
Xcommand line options are equivalent to the
X.B decgraphics
Xand
X.B ibmgraphics
Xrun-time options described there,
Xand are provided purely for convenience on systems
Xsupporting multiple types of terminals.)
X.PP
XThe
X.B \-u
X.I playername
Xoption supplies the answer to the question "Who are you?".
XIt overrides any name from NETHACKOPTIONS, HACKOPTIONS, USER, LOGNAME,
Xor getlogin(), which will otherwise be tried in order.
XIf none of these provides a useful name, the player will be asked for one.
XPlayer names (in conjunction with uids) are used to identify save files,
Xso you can have several saved games under different names.
XConversely, you must use the appropriate player name to restore a saved game.
X.PP
XA
X.I playername
Xsuffix or a separate option consisting of one of
X.B "\-A \-B \-C \-E \-H \-K \-P \-R \-S \-T \-V \-W"
Xcan be used to determine the character role.
X.PP
XThe
X.B \-s
Xoption alone will print out the list of your scores.
XIt may be followed by arguments
X.B "\-A \-B \-C \-E \-H \-K \-P \-R \-S \-T \-V \-W"
Xto print the
Xscores of Archeologists, Barbarians, Cave(wo)men, Elves, Healers, Knights,
XPriest(esse)s, Rogues, Samurai, Tourists, Valkyries, or Wizards.
XIt may also be followed by one or more player names to print the scores of the
Xplayers mentioned, or by 'all' to print out all scores.
X.PP
XThe
X.B \-n
Xoption suppresses printing of any news from the game administrator.
X.PP
XThe
X.B \-D
Xor
X.B \-X
Xoption will start the game in a special non-scoring discovery mode.
X.B \-D
Xwill, if the player is the game administrator, start in debugging (wizard)
Xmode instead.
X.PP
XThe
X.B \-d
Xoption, which must be the first argument if it appears,
Xsupplies a directory which is to serve as the playground.
XIt overrides the value from NETHACKDIR, HACKDIR,
Xor the directory specified by the game administrator during compilation
X(usually /usr/games/lib/nethackdir).
XThis option is usually only useful to the game administrator.
XThe playground must contain several auxiliary files such as help files,
Xthe list of top scorers, and a subdirectory
X.I save
Xwhere games are saved.
X.SH AUTHORS
X.PP
XJay Fenlason (+ Kenny Woodland, Mike Thome and Jon Payne) wrote the
Xoriginal hack, very much like rogue (but full of bugs).
X.PP
XAndries Brouwer continuously deformed their sources into an entirely
Xdifferent game.
X.PP
XMike Stephenson has continued the perversion of sources, adding various
Xwarped character classes and sadistic traps with the help of many strange
Xpeople who reside in that place between the worlds, the Usenet Zone.
XA number of these miscreants are immortalized in the historical
Xroll of dishonor and various other places.
X.PP
XThe resulting mess is now called NetHack, to denote its
Xdevelopment by the Usenet.  Andries Brouwer has made this request for the
Xdistinction, as he may eventually release a new version of his own.
X.SH FILES
X.PP
XAll files are in the playground, normally /usr/games/lib/nethackdir.
X.br
X.DT
X.ta \w'cmdhelp, opthelp, wizhelp\ \ \ 'u
Xnethack		The program itself.
X.br
Xdata, oracles, rumors	Data files used by NetHack.
X.br
Xoptions, quest.dat	More data files.
X.br
Xhelp, hh	Help data files.
X.br
Xcmdhelp, opthelp, wizhelp	More help data files.
X.br
X*.lev	Predefined special levels.
X.br
Xdungeon	Control file for special levels.
X.br
Xhistory	A short history of NetHack.
X.br
Xlicense	Rules governing redistribution.
X.br
Xrecord	The list of top scorers.
X.br
Xlogfile	An extended list of games
X.br
X	played.
X.br
Xxlock.nnn	Description of a dungeon level.
X.br
Xperm	Lock file for xlock.dd.
X.br
XbonesDD.nn	Descriptions of the ghost and
X.br
X	belongings of a deceased
X.br
X	adventurer.
X.br
Xsave	A subdirectory containing the
X.br
X	saved games.
X.SH ENVIRONMENT
X.DT
X.ta \w'HACKPAGER or PAGER\ \ \ 'u
XUSER or LOGNAME	Your login name.
X.br
XHOME		Your home directory.
X.br
XSHELL		Your shell.
X.br
XTERM		The type of your terminal.
X.br
XHACKPAGER or PAGER	Replacement for default pager.
X.br
XMAIL	Mailbox file.
X.br
XMAILREADER	Replacement for default reader
X.br
X	(probably /bin/mail or /usr/ucb/mail).
X.br
XNETHACKDIR	Playground.
X.br
XNETHACKOPTIONS	String predefining several NetHack
X.br
X	options.
X.br
X
XIn addition, SHOPTYPE is used in debugging (wizard) mode.
X.SH "SEE ALSO"
X.PP
Xdgn_comp(6), lev_comp(6), recover(6)
X.SH BUGS
X.PP
XProbably infinite.
X
X
X.PP
XDungeons & Dragons is a Trademark of TSR Inc.
END_OF_FILE
if test 5923 -ne `wc -c <'doc/nethack.6'`; then
    echo shar: \"'doc/nethack.6'\" unpacked with wrong size!
fi
# end of 'doc/nethack.6'
fi
if test -f 'include/mondata.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/mondata.h'\"
else
echo shar: Extracting \"'include/mondata.h'\" \(5910 characters\)
sed "s/^X//" >'include/mondata.h' <<'END_OF_FILE'
X/*	SCCS Id: @(#)mondata.h	3.1	92/11/26	*/
X/* Copyright (c) 1989 Mike Threepoint				  */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#ifndef MONDATA_H
X#define MONDATA_H
X
X#ifndef ALIGN_H
X#include "align.h"
X#endif
X
X#define verysmall(ptr)		((ptr)->msize < MZ_SMALL)
X#define bigmonst(ptr)		((ptr)->msize >= MZ_LARGE)
X
X#define resists_fire(ptr)	(((ptr)->mresists & MR_FIRE) != 0)
X#define resists_cold(ptr)	(((ptr)->mresists & MR_COLD) != 0)
X#define resists_sleep(ptr)	(((ptr)->mresists & MR_SLEEP) != 0)
X#define resists_disint(ptr)	(((ptr)->mresists & MR_DISINT) != 0)
X#define resists_elec(ptr)	(((ptr)->mresists & MR_ELEC) != 0)
X#define resists_poison(ptr)	(((ptr)->mresists & MR_POISON) != 0)
X#define resists_acid(ptr)	(((ptr)->mresists & MR_ACID) != 0)
X#define resists_ston(ptr)	(((ptr)->mresists & MR_STONE) != 0)
X
X#define is_flyer(ptr)		(((ptr)->mflags1 & M1_FLY) != 0L)
X#define is_floater(ptr)		((ptr)->mlet == S_EYE)
X#define is_clinger(ptr)		(((ptr)->mflags1 & M1_CLING) != 0L)
X#define is_swimmer(ptr)		(((ptr)->mflags1 & M1_SWIM) != 0L)
X#define magic_breathing(ptr)	(((ptr)->mflags1 & M1_AMPHIBIOUS) != 0L)
X#define passes_walls(ptr)	(((ptr)->mflags1 & M1_WALLWALK) != 0L)
X#define amorphous(ptr)		(((ptr)->mflags1 & M1_AMORPHOUS) != 0L)
X#define noncorporeal(ptr)	((ptr)->mlet == S_GHOST)
X#define tunnels(ptr)		(((ptr)->mflags1 & M1_TUNNEL) != 0L)
X#define needspick(ptr)		(((ptr)->mflags1 & M1_NEEDPICK) != 0L)
X#define hides_under(ptr)	(((ptr)->mflags1 & M1_CONCEAL) != 0L)
X#define is_hider(ptr)		(((ptr)->mflags1 & M1_HIDE) != 0L)
X#define haseyes(ptr)		(((ptr)->mflags1 & M1_NOEYES) == 0L)
X#define nohands(ptr)		(((ptr)->mflags1 & M1_NOHANDS) != 0L)
X#define nolimbs(ptr)		(((ptr)->mflags1 & M1_NOLIMBS) == M1_NOLIMBS)
X#define has_head(ptr)		(((ptr)->mflags1 & M1_NOHEAD) == 0L)
X#define is_whirly(ptr)		((ptr)->mlet == S_VORTEX || \
X				 (ptr) == &mons[PM_AIR_ELEMENTAL])
X#define mindless(ptr)		(((ptr)->mflags1 & M1_MINDLESS) != 0L)
X#define humanoid(ptr)		(((ptr)->mflags1 & M1_HUMANOID) != 0L)
X#define is_animal(ptr)		(((ptr)->mflags1 & M1_ANIMAL) != 0L)
X#define slithy(ptr)		(((ptr)->mflags1 & M1_SLITHY) != 0L)
X#define is_meaty(ptr)		(!amorphous(ptr) && \
X				 (ptr)->mlet != S_BLOB && \
X				 (ptr)->mlet != S_JELLY && \
X				 (ptr)->mlet != S_FUNGUS)
X#define is_wooden(ptr)		((ptr) == &mons[PM_WOOD_GOLEM])
X#define thick_skinned(ptr)	(((ptr)->mflags1 & M1_THICK_HIDE) != 0L)
X#define lays_eggs(ptr)		(((ptr)->mflags1 & M1_OVIPAROUS) != 0L)
X#define regenerates(ptr)	(((ptr)->mflags1 & M1_REGEN) != 0L)
X#define perceives(ptr)		(((ptr)->mflags1 & M1_SEE_INVIS) != 0L)
X#define can_teleport(ptr)	(((ptr)->mflags1 & M1_TPORT) != 0L)
X#define control_teleport(ptr)	(((ptr)->mflags1 & M1_TPORT_CNTRL) != 0L)
X#define telepathic(ptr)		((ptr) == &mons[PM_FLOATING_EYE] || \
X				 (ptr) == &mons[PM_MIND_FLAYER])
X#define is_armed(ptr)		attacktype(ptr, AT_WEAP)
X#define acidic(ptr)		(((ptr)->mflags1 & M1_ACID) != 0L)
X#define poisonous(ptr)		(((ptr)->mflags1 & M1_POIS) != 0L)
X#define carnivorous(ptr)	(((ptr)->mflags1 & M1_CARNIVORE) != 0L)
X#define herbivorous(ptr)	(((ptr)->mflags1 & M1_HERBIVORE) != 0L)
X#define metallivorous(ptr)	(((ptr)->mflags1 & M1_METALLIVORE) != 0L)
X#define polyok(ptr)		(((ptr)->mflags2 & M2_NOPOLY) == 0L)
X#define is_undead(ptr)		(((ptr)->mflags2 & M2_UNDEAD) != 0L)
X#define is_were(ptr)		(((ptr)->mflags2 & M2_WERE) != 0L)
X#define is_elf(ptr)		(((ptr)->mflags2 & M2_ELF) != 0L)
X#define is_dwarf(ptr)		(((ptr)->mflags2 & M2_DWARF) != 0L)
X#define is_giant(ptr)		(((ptr)->mflags2 & M2_GIANT) != 0L)
X#define is_golem(ptr)		((ptr)->mlet == S_GOLEM)
X#define is_domestic(ptr)	(((ptr)->mflags2 & M2_DOMESTIC) != 0L)
X#define is_orc(ptr)		(((ptr)->mflags2 & M2_ORC) != 0L)
X#define is_human(ptr)		(((ptr)->mflags2 & M2_HUMAN) != 0L)
X#define is_demon(ptr)		(((ptr)->mflags2 & M2_DEMON) != 0L)
X#define is_mercenary(ptr)	(((ptr)->mflags2 & M2_MERC) != 0L)
X#define is_male(ptr)		(((ptr)->mflags2 & M2_MALE) != 0L)
X#define is_female(ptr)		(((ptr)->mflags2 & M2_FEMALE) != 0L)
X#define is_neuter(ptr)		(((ptr)->mflags2 & M2_NEUTER) != 0L)
X#define is_wanderer(ptr)	(((ptr)->mflags2 & M2_WANDER) != 0L)
X#define always_hostile(ptr)	(((ptr)->mflags2 & M2_HOSTILE) != 0L)
X#define always_peaceful(ptr)	(((ptr)->mflags2 & M2_PEACEFUL) != 0L)
X#define extra_nasty(ptr)	(((ptr)->mflags2 & M2_NASTY) != 0L)
X#define strongmonst(ptr)	(((ptr)->mflags2 & M2_STRONG) != 0L)
X#  ifdef POLYSELF
X#define can_breathe(ptr)	attacktype(ptr, AT_BREA)
X#define cantwield(ptr)		(nohands(ptr) || verysmall(ptr))
X#define cantweararm(ptr)	(breakarm(ptr) || sliparm(ptr))
X#  endif /* POLYSELF */
X#define throws_rocks(ptr)	(((ptr)->mflags2 & M2_ROCKTHROW) != 0L)
X#define type_is_pname(ptr)	(((ptr)->mflags2 & M2_PNAME) != 0L)
X#define is_lord(ptr)		(((ptr)->mflags2 & M2_LORD) != 0L)
X#define is_prince(ptr)		(((ptr)->mflags2 & M2_PRINCE) != 0L)
X#define is_ndemon(ptr)		(is_demon(ptr) && \
X				 (((ptr)->mflags2 & (M2_LORD|M2_PRINCE)) == 0L))
X#define is_dlord(ptr)		(is_demon(ptr) && is_lord(ptr))
X#define is_dprince(ptr)		(is_demon(ptr) && is_prince(ptr))
X#define is_minion(ptr)		((ptr)->mflags2 & M2_MINION)
X#define is_lminion(ptr)		(is_minion(ptr) && \
X				 (ptr)->maligntyp >= A_COALIGNED)
X#define likes_gold(ptr)		(((ptr)->mflags2 & M2_GREEDY) != 0L)
X#define likes_gems(ptr)		(((ptr)->mflags2 & M2_JEWELS) != 0L)
X#define likes_objs(ptr)		(((ptr)->mflags2 & M2_COLLECT) != 0L || \
X				 is_armed(ptr))
X#define likes_magic(ptr)	(((ptr)->mflags2 & M2_MAGIC) != 0L)
X#define is_longworm(ptr)	(((ptr) == &mons[PM_BABY_LONG_WORM]) || \
X				 ((ptr) == &mons[PM_LONG_WORM]) || \
X				 ((ptr) == &mons[PM_LONG_WORM_TAIL]))
X#define is_covetous(ptr)	((ptr->mflags3 & M3_COVETOUS))
X#define is_mplayer(ptr)		(((ptr) >= &mons[PM_ARCHEOLOGIST]) && \
X				 ((ptr) <= &mons[PM_WIZARD]))
X#define is_rider(ptr)		((ptr) == &mons[PM_DEATH] || \
X				 (ptr) == &mons[PM_FAMINE] || \
X				 (ptr) == &mons[PM_PESTILENCE])
X#endif /* MONDATA_H */
END_OF_FILE
if test 5910 -ne `wc -c <'include/mondata.h'`; then
    echo shar: \"'include/mondata.h'\" unpacked with wrong size!
fi
# end of 'include/mondata.h'
fi
if test -f 'include/you.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/you.h'\"
else
echo shar: Extracting \"'include/you.h'\" \(6900 characters\)
sed "s/^X//" >'include/you.h' <<'END_OF_FILE'
X/*	SCCS Id: @(#)you.h	3.1	92/11/29	*/
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#ifndef YOU_H
X#define YOU_H
X
X#ifndef ALIGN_H
X#include "align.h"
X#endif
X#ifndef ATTRIB_H
X#include "attrib.h"
X#endif
X#ifndef MONST_H
X#include "monst.h"
X#endif
X#ifndef YOUPROP_H
X#include "youprop.h"
X#endif
X
Xstruct prop {
X
X#define TIMEOUT		007777	/* mask */
X
X#define LEFT_RING	W_RINGL	/* 010000L */
X#define RIGHT_RING	W_RINGR	/* 020000L */
X#define LEFT_SIDE	LEFT_RING
X#define RIGHT_SIDE	RIGHT_RING
X#define BOTH_SIDES	(LEFT_SIDE | RIGHT_SIDE)
X
X#define WORN_ARMOR	W_ARM	/* 040000L */
X#define WORN_CLOAK	W_ARMC	/* 0100000L */
X#define WORN_HELMET	W_ARMH	/* 0200000L */
X#define WORN_SHIELD	W_ARMS	/* 0400000L */
X#define WORN_GLOVES	W_ARMG	/* 01000000L */
X#define WORN_BOOTS	W_ARMF	/* 02000000L */
X#define WORN_AMUL	W_AMUL	/* 04000000L */
X#define WORN_BLINDF	W_TOOL	/* 010000000L */
X#ifdef TOURIST
X#define WORN_SHIRT	W_ARMU	/* 01000L */
X#endif
X
X/*
X * FROMEXPER is for a property gained by virtue of your experience level,
X * which will be lost if you lose that level; FROMOUTSIDE is one that is
X * gained in some other way (e.g., a throne, a prayer, or a corpse).
X * INTRINSIC is either FROMEXPER or FROMOUTSIDE
X */
X#define FROMOUTSIDE	0200000000L
X#define FROMEXPER	0400000000L
X#define INTRINSIC	(FROMOUTSIDE|FROMEXPER)
X
X	long p_flgs;
X	int NDECL((*p_tofn));	/* called after timeout */
X};
X
Xstruct u_have {
X	Bitfield(amulet,1);	/* carrying Amulet	*/
X	Bitfield(bell,1);	/* carrying Bell	*/
X	Bitfield(book,1);	/* carrying Book	*/
X	Bitfield(menorah,1);	/* carrying Candelabrum */
X#ifdef MULDGN
X	Bitfield(questart,1);	/* carrying the Quest Artifact */
X	Bitfield(unused,3);
X#else
X	Bitfield(unused,4);
X#endif
X};
X
Xstruct u_event {
X	Bitfield(minor_oracle,1);	/* received at least 1 cheap oracle */
X	Bitfield(major_oracle,1);	/*  "  expensive oracle */
X#ifdef MULDGN
X	Bitfield(qexpelled,1);		/* expelled from the Quest dungeon */
X	Bitfield(qcompleted,1);	    /* successfully completed the Quest task */
X#endif
X	Bitfield(uheard_tune,2);	/* if you heard the passtune */
X	Bitfield(uopened_dbridge,1);	/* if you open the drawbridge */
X	Bitfield(invoked,1);	    /* invoked the gate to the Sanctum level */
X
X	Bitfield(gehennom_entered,1);	/* entered Gehennom via Valley */
X#ifdef ELBERETH
X	Bitfield(uhand_of_elbereth,1);	/* if you become Hand of Elbereth */
X#endif
X	Bitfield(udemigod,1);		/* once you kill the wiz */
X};
X
X
Xstruct you {
X	xchar ux, uy;
X	schar dx, dy, dz;	/* direction of move (or zap or ... ) */
X	schar di;		/* direction of FF */
X	xchar ux0, uy0;		/* initial position FF */
X	d_level uz, uz0;	/* your level on this and the previous turn */
X	d_level utolev;		/* level monster teleported you to, or uz */
X	char utotype;		/* bitmask of goto_level() flags for utolev */
X	char usym;		/* usually '@' */
X	boolean umoved;		/* changed map location (post-move) */
X	int last_str_turn;	/* 0: none, 1: half turn, 2: full turn */
X				/* +: turn right, -: turn left */
X	unsigned ulevel;	/* 1 - MAXULEV */
X	unsigned utrap;		/* trap timeout */
X	unsigned utraptype;	/* defined if utrap nonzero */
X#define TT_BEARTRAP	0
X#define TT_PIT		1
X#define TT_WEB		2
X#define TT_LAVA		3
X#define TT_INFLOOR	4
X	char	urooms[5];	/* rooms (roomno + 3) occupied now */
X	char	urooms0[5];	/* ditto, for previous position */
X	char	uentered[5];	/* rooms (roomno + 3) entered this turn */
X	char	ushops[5];	/* shop rooms (roomno + 3) occupied now */
X	char	ushops0[5];	/* ditto, for previous position */
X	char	ushops_entered[5]; /* ditto, shops entered this turn */
X	char	ushops_left[5];	/* ditto, shops exited this turn */
X
X	int	 uhunger;	/* refd only in eat.c and shk.c */
X	unsigned uhs;		/* hunger state - see eat.c */
X
X	struct prop uprops[LAST_PROP+1];
X
X	unsigned umconf;
X	const char *usick_cause;
X/* For messages referring to hands, eyes, feet, etc... when polymorphed */
X#define ARM 0
X#define EYE 1
X#define FACE 2
X#define FINGER 3
X#define FINGERTIP 4
X#define FOOT 5
X#define HAND 6
X#define HANDED 7
X#define HEAD 8
X#define LEG 9
X#define LIGHT_HEADED 10
X#define NECK 11
X#define SPINE 12
X#define TOE 13
X
X	/* These ranges can never be more than MAX_RANGE (vision.h). */
X	int nv_range;			/* current night vision range */
X	int xray_range;			/* current xray vision range */
X
X	/*
X	 * These variables are valid globally only when punished and blind.
X	 */
X#define BC_BALL  0x01	/* bit mask for ball  in 'bc_felt' below */
X#define BC_CHAIN 0x02	/* bit mask for chain in 'bc_felt' below */
X	int bglyph;	/* glyph under the ball */
X	int cglyph;	/* glyph under the chain */
X	int bc_order;	/* ball & chain order [see bc_order() in trap.c] */
X	int bc_felt;	/* mask for ball/chain being felt */
X
X
X	/*
X	 * Player type monster (e.g. PM_VALKYRIE).  This is set in u_init
X	 * and never changed afterward.
X	 */
X	int umonster;
X#ifdef POLYSELF
X	int umonnum;				/* monster number or -1 */
X	int mh, mhmax, mtimedone;		/* for polymorph-self */
X	struct attribs	macurr,			/* for monster attribs */
X			mamax;			/* for monster attribs */
X	int ulycn;				/* lycanthrope type */
X#endif
X	unsigned ucreamed;
X	unsigned uswldtim;		/* time you have been swallowed */
X
X	Bitfield (uswallow,1);		/* true if swallowed */
X	Bitfield(uinwater,1);		/* if you're currently in water (only
X					   underwater possible currently) */
X#ifdef POLYSELF
X	Bitfield(uundetected,1);	/* if you're a hiding monster/piercer */
X	Bitfield(mfemale,1);		/* saved human value of flags.female */
X#endif
X	Bitfield(uinvulnerable,1);	/* you're invulnerable (praying) */
X	Bitfield(usleep,1);		/* you're sleeping */
X
X	unsigned udg_cnt;		/* how long you have been demigod */
X	struct u_event	uevent;		/* certain events have happened */
X	struct u_have	uhave;		/* you're carrying special objects */
X	struct attribs	acurr,		/* your current attributes (eg. str)*/
X			aexe,		/* for gain/loss via "exercise" */
X			abon,		/* your bonus attributes (eg. str) */
X			amax,		/* your max attributes (eg. str) */
X			atemp,		/* used for temporary loss/gain */
X			atime;		/* used for loss/gain countdown */
X	align	ualign;			/* character alignment */
X#define CONVERT		2
X	aligntyp ualignbase[CONVERT];	/* for ualign conversion record */
X	schar uluck, moreluck;		/* luck and luck bonus */
X#define LUCKADD		3	/* added value when carrying luck stone */
X#define Luck	(u.uluck + u.moreluck)
X#define LUCKMAX		10	/* on moonlit nights 11 */
X#define LUCKMIN		(-10)
X	schar	udaminc;
X	schar	uac;
X	int	uhp,uhpmax;
X	int	uen, uenmax;		/* magical energy - M. Stephenson */
X	int ugangr;			/* if the gods are angry at you */
X	int ublessed, ublesscnt;	/* blessing/duration from #pray */
X	long	ugold, ugold0;
X	long	uexp, urexp;
X	long	ucleansed;	/* to record moves when player was cleansed */
X	int uinvault;
X	struct monst *ustuck;
X	int ugrave_arise; /* you die and become something aside from a ghost */
X	int nr_killed[NUMMONS];		/* used for experience bookkeeping */
X};
X
X#endif	/* YOU_H */
END_OF_FILE
if test 6900 -ne `wc -c <'include/you.h'`; then
    echo shar: \"'include/you.h'\" unpacked with wrong size!
fi
# end of 'include/you.h'
fi
if test -f 'sys/amiga/NewGame.uu' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/amiga/NewGame.uu'\"
else
echo shar: Extracting \"'sys/amiga/NewGame.uu'\" \(2167 characters\)
sed "s/^X//" >'sys/amiga/NewGame.uu' <<'END_OF_FILE'
Xbegin 777 NewGame.info
XMXQ```0``````=@`^`%``(@`&`0L``0`DT>``)4KX``````````````````0`
XM```!!!@`)-O@`"69&(````"``````````````````)Q```````!0`"$``@`"
XM_0@#```````````````````!`````````````P````````````,`````````
XM```#`````````````P````````````,``!__@``````#``!U57```````P`!
XMJJJH``````,``5557``````#``:JJJH``````P`%??WU``````,`!OJ[^P``
XM```#``5O_=4``````P`&JJJK`````/L`!575U0'_[/_[``:OOJO_____XP`%
XM5554>^```!L#_JZJJT%4F*=3'\5UWO7224```S`&N^^K!EPE]TL"M55556K6
XMHL`#)6?___\#4Z^``SJG____X@`*E-,<D?____H#5*W3("L?___XR`<`<RO]
XM[___Z.ZGW#,H(8#___.`>H(#%"$#?__`+`!-BP!!&/@/0`,D0!,V"`P,<WQX
XM``9+*`%F`X!CG#F`ZW_________________________^P````````````,0!
XM\$`(`````$#`#X`$``0`@!``P#\``$`@`@"``,!^`$``((``@(#$?A__L```
XM`0``Q'_U57`!P````,(_JJJH8`@``0#`'5557`!`1```P`:JJJH!```"`,`5
XM`0`%`````0#$1H**"R$#!@``Q@4!`%4``"```,`6JJJK`>@.LP#$%455%1``
XM$P``P`:JHHH``````,$E5554``````#(!*JJJP``````P`4U`!4``````,`&
XMJ`BK``````#`!5555```````P`?___\``````,````````````#`````````
XM````P````````````,````````````#`````````````P````````````,``
XM``````````#`````````````P````````````(```````````````````%``
XM(0`"``1:T`,``````/_____________`````````````P````````````,``
XM``````````#`````````````P````````````,````````````#`````````
XM````P````````````,````````````#```/G@```````P`!^_>```````,``
XM]SOX``````#``:_]W```````P`>JJJX`````^,`%5=74`?_L__C`!J^^JW__
XM___@P`55551[X```&,-^KJJK0528IU#>!77>]=))0```\8:[[ZL&3"6W2,+5
XM5555:M8BP`#D1____P-`#H``^V?____"``J4T-U!____Z@,4K=#@*Q___\B(
XM!@!PZ]WH_\P([B?<,.@A@,$$<X!R``#4(`-$*T`D`$V(P$$8^`%``R1`$/8(
XM#`QS;'@`!DCH`68#@&.<.8#H@```````````````````````````````````
XM```#!`?X0`@`````0P`?_@0`!`"`$`,`/_\`0"`"`(`#`'__@``@@`"`@P1_
XM_X`````!``,$?_^```'````#`C__``!@"``!`P`?_@```$!$``,`!_/G@`$`
XM``(#`!!^_&`````!`P1`]PHX(0,&``,&`8$`7```(``#`!>JJJX!Z`ZS`P05
XM1544$``3``,`!JJBB@`````#`255550``````P@$JJJK````"`,`!34`%0``
XM```#``:H"*L```!``P`%5554`````(,`!____P`(`$`#````````$````P`0
XM``````!```,````````!```#`"```````````P```````````@,``P````!"
XM"``#`````````````P````````````,````````````#?____________P``
XM`!!(86-K17AE.DYE=$AA8VL`````%````!%(04-+1$E2/4YE=$AA8VLZ````
XM`!9,159%3%,]3F5T:&%C:SIL979E;',`````$E-!5D4]3F5T:&%C:SIS879E
X3``````Y0051(/4YE=$AA8VLZ`'9E
X`
Xend
END_OF_FILE
if test 2167 -ne `wc -c <'sys/amiga/NewGame.uu'`; then
    echo shar: \"'sys/amiga/NewGame.uu'\" unpacked with wrong size!
fi
# end of 'sys/amiga/NewGame.uu'
fi
if test -f 'sys/amiga/colorwin.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/amiga/colorwin.c'\"
else
echo shar: Extracting \"'sys/amiga/colorwin.c'\" \(6366 characters\)
sed "s/^X//" >'sys/amiga/colorwin.c' <<'END_OF_FILE'
X
XSHORT Col_BorderVectors1[] = {
X	0,0,
X	59,0,
X	59,12,
X	0,12,
X	0,0
X};
Xstruct Border Col_Border1 = {
X	-1,-1,	/* XY origin relative to container TopLeft */
X	3,0,JAM1,	/* front pen, back pen and drawmode */
X	5,	/* number of XY vectors */
X	Col_BorderVectors1,	/* pointer to XY vectors */
X	NULL	/* next border in list */
X};
X
Xstruct IntuiText Col_IText1 = {
X	3,0,JAM2,	/* front and back text pens, drawmode and fill byte */
X	13,1,	/* XY origin relative to container TopLeft */
X	NULL,	/* font pointer or NULL for default */
X	"Okay",	/* pointer to text */
X	NULL	/* next IntuiText structure */
X};
X
Xstruct Gadget Col_Okay = {
X	NULL,	/* next gadget */
X	8,65,	/* origin XY of hit box relative to window TopLeft */
X	58,11,	/* hit box width and height */
X	NULL,	/* gadget flags */
X	RELVERIFY,	/* activation flags */
X	BOOLGADGET,	/* gadget type flags */
X	(APTR)&Col_Border1,	/* gadget border or image to be rendered */
X	NULL,	/* alternate imagery for selection */
X	&Col_IText1,	/* first IntuiText structure */
X	NULL,	/* gadget mutual-exclude long word */
X	NULL,	/* SpecialInfo structure */
X	GADCOLOKAY,	/* user-definable data */
X	NULL	/* pointer to user-definable data */
X};
X
XSHORT Col_BorderVectors2[] = {
X	0,0,
X	59,0,
X	59,12,
X	0,12,
X	0,0
X};
Xstruct Border Col_Border2 = {
X	-1,-1,	/* XY origin relative to container TopLeft */
X	3,0,JAM1,	/* front pen, back pen and drawmode */
X	5,	/* number of XY vectors */
X	Col_BorderVectors2,	/* pointer to XY vectors */
X	NULL	/* next border in list */
X};
X
Xstruct IntuiText Col_IText2 = {
X	3,0,JAM2,	/* front and back text pens, drawmode and fill byte */
X	6,1,	/* XY origin relative to container TopLeft */
X	NULL,	/* font pointer or NULL for default */
X	"Cancel",	/* pointer to text */
X	NULL	/* next IntuiText structure */
X};
X
Xstruct Gadget Col_Cancel = {
X	&Col_Okay,	/* next gadget */
X	218,65,	/* origin XY of hit box relative to window TopLeft */
X	58,11,	/* hit box width and height */
X	NULL,	/* gadget flags */
X	RELVERIFY,	/* activation flags */
X	BOOLGADGET,	/* gadget type flags */
X	(APTR)&Col_Border2,	/* gadget border or image to be rendered */
X	NULL,	/* alternate imagery for selection */
X	&Col_IText2,	/* first IntuiText structure */
X	NULL,	/* gadget mutual-exclude long word */
X	NULL,	/* SpecialInfo structure */
X	GADCOLCANCEL,	/* user-definable data */
X	NULL	/* pointer to user-definable data */
X};
X
Xstruct PropInfo Col_Col_RedPenSInfo = {
X	AUTOKNOB+FREEHORIZ,	/* PropInfo flags */
X	0,0,	/* horizontal and vertical pot values */
X	-1,-1,	/* horizontal and vertical body values */
X};
X
Xstruct Image Col_Image1 = {
X	0,0,	/* XY origin relative to container TopLeft */
X	263,7,	/* Image width and height in pixels */
X	0,	/* number of bitplanes in Image */
X	NULL,	/* pointer to ImageData */
X	0x0000,0x0000,	/* PlanePick and PlaneOnOff */
X	NULL	/* next Image structure */
X};
X
Xstruct Gadget Col_RedPen = {
X	&Col_Cancel,	/* next gadget */
X	7,12,	/* origin XY of hit box relative to window TopLeft */
X	271,11,	/* hit box width and height */
X	NULL,	/* gadget flags */
X	RELVERIFY+GADGIMMEDIATE+FOLLOWMOUSE,	/* activation flags */
X	PROPGADGET,	/* gadget type flags */
X	(APTR)&Col_Image1,	/* gadget border or image to be rendered */
X	NULL,	/* alternate imagery for selection */
X	NULL,	/* first IntuiText structure */
X	NULL,	/* gadget mutual-exclude long word */
X	(APTR)&Col_Col_RedPenSInfo,	/* SpecialInfo structure */
X	GADREDPEN,	/* user-definable data */
X	NULL	/* pointer to user-definable data */
X};
X
Xstruct PropInfo Col_Col_GreenPenSInfo = {
X	AUTOKNOB+FREEHORIZ,	/* PropInfo flags */
X	0,0,	/* horizontal and vertical pot values */
X	-1,-1,	/* horizontal and vertical body values */
X};
X
Xstruct Image Col_Image2 = {
X	0,0,	/* XY origin relative to container TopLeft */
X	263,7,	/* Image width and height in pixels */
X	0,	/* number of bitplanes in Image */
X	NULL,	/* pointer to ImageData */
X	0x0000,0x0000,	/* PlanePick and PlaneOnOff */
X	NULL	/* next Image structure */
X};
X
Xstruct Gadget Col_GreenPen = {
X	&Col_RedPen,	/* next gadget */
X	7,24,	/* origin XY of hit box relative to window TopLeft */
X	271,11,	/* hit box width and height */
X	NULL,	/* gadget flags */
X	RELVERIFY+GADGIMMEDIATE+FOLLOWMOUSE,	/* activation flags */
X	PROPGADGET,	/* gadget type flags */
X	(APTR)&Col_Image2,	/* gadget border or image to be rendered */
X	NULL,	/* alternate imagery for selection */
X	NULL,	/* first IntuiText structure */
X	NULL,	/* gadget mutual-exclude long word */
X	(APTR)&Col_Col_GreenPenSInfo,	/* SpecialInfo structure */
X	GADGREENPEN,	/* user-definable data */
X	NULL	/* pointer to user-definable data */
X};
X
Xstruct PropInfo Col_Col_BluePenSInfo = {
X	AUTOKNOB+FREEHORIZ,	/* PropInfo flags */
X	0,0,	/* horizontal and vertical pot values */
X	-1,-1,	/* horizontal and vertical body values */
X};
X
Xstruct Image Col_Image3 = {
X	0,0,	/* XY origin relative to container TopLeft */
X	263,7,	/* Image width and height in pixels */
X	0,	/* number of bitplanes in Image */
X	NULL,	/* pointer to ImageData */
X	0x0000,0x0000,	/* PlanePick and PlaneOnOff */
X	NULL	/* next Image structure */
X};
X
Xstruct Gadget Col_BluePen = {
X	&Col_GreenPen,	/* next gadget */
X	7,36,	/* origin XY of hit box relative to window TopLeft */
X	271,11,	/* hit box width and height */
X	NULL,	/* gadget flags */
X	RELVERIFY+GADGIMMEDIATE+FOLLOWMOUSE,	/* activation flags */
X	PROPGADGET,	/* gadget type flags */
X	(APTR)&Col_Image3,	/* gadget border or image to be rendered */
X	NULL,	/* alternate imagery for selection */
X	NULL,	/* first IntuiText structure */
X	NULL,	/* gadget mutual-exclude long word */
X	(APTR)&Col_Col_BluePenSInfo,	/* SpecialInfo structure */
X	GADBLUEPEN,	/* user-definable data */
X	NULL	/* pointer to user-definable data */
X};
X
X#define Col_GadgetList1 Col_BluePen
X
Xstruct NewWindow Col_NewWindowStructure1 = {
X	175,45,	/* window XY origin relative to TopLeft of screen */
X	285,80,	/* window width and height */
X	0,1,	/* detail and block pens */
X	MOUSEBUTTONS+MOUSEMOVE+GADGETDOWN+GADGETUP+CLOSEWINDOW+VANILLAKEY+INTUITICKS,	/* IDCMP flags */
X	WINDOWDRAG+WINDOWDEPTH+WINDOWCLOSE+ACTIVATE+NOCAREREFRESH,	/* other window flags */
X	&Col_BluePen,	/* first gadget in gadget list */
X	NULL,	/* custom CHECKMARK imagery */
X	"Edit Screen Colors",	/* window title */
X	NULL,	/* custom screen pointer */
X	NULL,	/* custom bitmap */
X	5,5,	/* minimum width and height */
X	-1,-1,	/* maximum width and height */
X	CUSTOMSCREEN	/* destination screen type */
X};
X
X
X/* end of PowerWindows source generation */
END_OF_FILE
if test 6366 -ne `wc -c <'sys/amiga/colorwin.c'`; then
    echo shar: \"'sys/amiga/colorwin.c'\" unpacked with wrong size!
fi
# end of 'sys/amiga/colorwin.c'
fi
if test -f 'sys/unix/Makefile.utl' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/unix/Makefile.utl'\"
else
echo shar: Extracting \"'sys/unix/Makefile.utl'\" \(6899 characters\)
sed "s/^X//" >'sys/unix/Makefile.utl' <<'END_OF_FILE'
X#	Makefile for NetHack's utility programs.
X#	SCCS Id: @(#)Makefile.utl	3.1	92/11/01
X
X# if you are using gcc as your compiler,
X#	uncomment the CC definition below if it's not in your environment
X# CC = gcc
X#
X#	For Bull DPX/2 systems at B.O.S. 2.0 or higher use the following:
X#
X# CC = gcc -ansi -D_BULL_SOURCE -D_XOPEN_SOURCE -D_POSIX_SOURCE
X# 
X#	If you are using GCC 2.2.2 or higher on a DPX/2, just use:
X#
X# CC = gcc -ansi
X#
X# if your make doesn't define a default SHELL properly, you may need
X#    the line below (Atari users will need a bourne work-alike)
X# SHELL = /bin/sh
X
X# flags may have to be changed as required
X# flags for 286 Xenix:
X# CFLAGS = -Ml2t16 -O -LARGE -I../include
X# LFLAGS = -Ml -F 4000 -SEG 512
X
X# flags for 286 Microport SysV-AT
X# CFLAGS = -DDUMB -Ml -I../include
X# LFLAGS = -Ml
X
X# flags for Atari GCC
X# CFLAGS = -O -I../include
X# LFLAGS = -s
X
X# flags for Apollos using their native cc
X# (as long as it claims to be __STDC__ but isn't)
X# CFLAGS = -DAPOLLO -O -I../include
X
X# flags for AIX 3.1 cc on IBM RS/6000 to define
X# a suitable subset of standard libraries
X# (note that there is more info regarding the "-qchars=signed"
X# switch in file Install.unx note 8)
X# CFLAGS = -D_NO_PROTO -D_XOPEN_SOURCE -O -I../include -qchars=signed
X
X# flags for A/UX 2.01 using native cc or c89
X# gcc predefines AUX so that's not needed there
X# CFLAGS = -ZS -D_POSIX_SOURCE -O -I../include -DAUX
X
X# flags for debugging:
X# CFLAGS = -g -I../include
X
XCFLAGS = -g -I../include
XLFLAGS =
X 
X
X# yacc/lex programs to use to generate *_comp.h, *_lex.c, and *_yacc.c.
X# if, instead of yacc/lex you have bison/flex, comment/uncomment the following.
XYACC     = yacc
XLEX      = lex
X# YACC     = bison -y
X# LEX      = flex
X 
X# these are the names of the output files from YACC/LEX. Under MS-DOS
X# and similar systems, they may differ
XYTABC = y.tab.c
XYTABH = y.tab.h
XLEXYYC = lex.yy.c
X# YTABC = y_tab.c
X# YTABH = y_tab.h
X# LEXYYC = lexyy.c
X
X# Nothing below this line should have to be changed.
X
X# utility .c files
XMAKESRC = makedefs.c
XSPLEVSRC = lev_yacc.c lev_lex.c lev_main.c panic.c
XDGNCOMPSRC = dgn_yacc.c dgn_lex.c dgn_main.c
XUTILSRCS = $(MAKESRC) $(SPLEVSRC) $(DGNCOMPSRC)
X
X# object files for makedefs
XMAKEOBJS = makedefs.o ../src/monst.o ../src/objects.o
X
X# object files for special levels compiler
XSPLEVOBJS = lev_yacc.o lev_lex.o lev_main.o panic.o \
X	../src/alloc.o ../src/drawing.o ../src/decl.o \
X	../src/monst.o ../src/objects.o
X
X# object files for dungeon compiler
XDGNCOMPOBJS = dgn_yacc.o dgn_lex.o dgn_main.o panic.o ../src/alloc.o
X
X# object files for recovery utility
XRECOVOBJS = recover.o
X
X
X#	dependencies for makedefs
X#
Xmakedefs:	$(MAKEOBJS)
X	$(CC) $(LFLAGS) -o makedefs $(MAKEOBJS)
X
Xmakedefs.o:  ../include/config.h ../include/permonst.h ../include/objclass.h \
X		../include/monsym.h ../include/artilist.h ../include/qtext.h
X
X../include/onames.h: makedefs
X	./makedefs -o
X../include/pm.h: makedefs
X	./makedefs -p
X../src/monstr.c: makedefs
X	./makedefs -m
X../include/vis_tab.h: makedefs
X	./makedefs -z
X../src/vis_tab.c: makedefs
X	./makedefs -z
X
Xlintdefs:
X	@lint -axbh -I../include -DLINT $(MAKESRC) ../src/monst.c ../src/objects.c | sed '/_flsbuf/d'
X
X
X# the src Makefile is responsible for knowing when to call this, since
X# it knows all about the main src and include files
X../include/date.h::
X	./makedefs -v
X
X
X#	dependencies for lev_comp
X#
Xlev_comp:  $(SPLEVOBJS)
X	$(CC) $(LFLAGS) -o lev_comp $(SPLEVOBJS)
X
Xlev_yacc.o:  ../include/hack.h ../include/sp_lev.h
Xlev_main.o:  ../include/hack.h ../include/sp_lev.h ../include/termcap.h
Xpanic.o:     ../include/config.h
X
X# see lev_comp.l for WEIRD_LEX discussion
X# egrep returns failure if it doesn't find anything, so we have to go to
X# some trouble to check for $(CC) failures
Xlev_lex.o:   ../include/hack.h ../include/lev_comp.h ../include/sp_lev.h
X	-@rm lev_lex.o 2>/dev/null
X	@echo $(CC) -c $(CFLAGS) lev_lex.c
X	-@$(CC) -c $(CFLAGS) -DWEIRD_LEX=`egrep -c _cplusplus lev_lex.c` lev_lex.c
X	@test -r lev_lex.o
X
X../include/lev_comp.h: lev_yacc.c
X
Xlev_yacc.c: lev_comp.y
X	$(YACC) -d lev_comp.y
X	mv $(YTABC) lev_yacc.c
X	mv $(YTABH) ../include/lev_comp.h
X
Xlev_lex.c: lev_comp.l
X	$(LEX) lev_comp.l
X	mv $(LEXYYC) lev_lex.c
X
X# with all of extern.h's functions to complain about, we drown in
X# 'defined but not used' without -u
Xlintlev:
X	@lint -axhu -I../include -DLINT $(SPLEVSRC) ../src/alloc.c ../src/monst.c ../src/objects.c | sed '/_flsbuf/d'
X
X
X#	dependencies for dgn_comp
X#
Xdgn_comp:  $(DGNCOMPOBJS)
X	$(CC) $(LFLAGS) -o dgn_comp $(DGNCOMPOBJS)
X
Xdgn_yacc.o:  ../include/config.h ../include/dgn_file.h
Xdgn_main.o:  ../include/config.h
X
X# see dgn_comp.l for WEIRD_LEX discussion
X# egrep returns failure if it doesn't find anything, so we have to go to
X# some trouble to check for $(CC) failures
Xdgn_lex.o:   ../include/config.h ../include/dgn_comp.h ../include/dgn_file.h
X	-@rm dgn_lex.o 2>/dev/null
X	@echo $(CC) -c $(CFLAGS) dgn_lex.c
X	-@$(CC) -c $(CFLAGS) -DWEIRD_LEX=`egrep -c _cplusplus dgn_lex.c` dgn_lex.c
X	@test -r dgn_lex.o
X
X
X../include/dgn_comp.h: dgn_yacc.c
X
Xdgn_yacc.c: dgn_comp.y
X	$(YACC) -d dgn_comp.y
X	mv $(YTABC) dgn_yacc.c
X	mv $(YTABH) ../include/dgn_comp.h
X
Xdgn_lex.c: dgn_comp.l
X	$(LEX) dgn_comp.l
X	mv $(LEXYYC) dgn_lex.c
X
X# with all of extern.h's functions to complain about, we drown in
X# 'defined but not used' without -u
Xlintdgn:
X	@lint -axhu -I../include -DLINT $(DGNCOMPSRC) panic.c ../src/alloc.c | sed '/_flsbuf/d'
X
X
X#	dependencies for recover
X#
Xrecover: $(RECOVOBJS)
X	$(CC) $(LFLAGS) -o recover $(RECOVOBJS)
X
Xrecover.o: ../include/config.h
X
X
X
X# using dependencies like
X#	../src/foo::
X#		@( cd ../src ; $(MAKE) foo )
X# would always force foo to be up-to-date according to the src Makefile
X# when it's needed here.  unfortunately, some makes believe this syntax
X# means foo always changes, instead of foo should always be checked.
X# therefore, approximate via config.h dependencies, and hope that anybody
X# changing anything other than basic configuration also knows when not
X# to improvise things not in the instructions, like 'make makedefs' here
X# in util...
X
X# make sure object files from src are available when needed
X#
X../src/alloc.o: ../src/alloc.c ../include/config.h
X	@( cd ../src ; $(MAKE) alloc.o )
X../src/drawing.o: ../src/drawing.c ../include/config.h
X	@( cd ../src ; $(MAKE) drawing.o )
X../src/decl.o: ../src/decl.c ../include/config.h
X	@( cd ../src ; $(MAKE) decl.o )
X../src/monst.o: ../src/monst.c ../include/config.h
X	@( cd ../src ; $(MAKE) monst.o )
X../src/objects.o: ../src/objects.c ../include/config.h
X	@( cd ../src ; $(MAKE) objects.o )
X
X# make sure hack.h dependencies get transitive information
X../include/hack.h: ../include/config.h
X	@( cd ../src ; $(MAKE) ../include/hack.h )
X
Xtags: $(UTILSRCS)
X	@ctags -tw $(UTILSRCS)
X
Xclean:
X	rm -f *.o
X
Xspotless: clean
X	rm -f lev_lex.c lev_yacc.c dgn_lex.c dgn_yacc.c
X	rm -f ../include/lev_comp.h ../include/dgn_comp.h
X	rm -f makedefs lev_comp dgn_comp recover
END_OF_FILE
if test 6899 -ne `wc -c <'sys/unix/Makefile.utl'`; then
    echo shar: \"'sys/unix/Makefile.utl'\" unpacked with wrong size!
fi
# end of 'sys/unix/Makefile.utl'
fi
if test -f 'sys/vms/install.com' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/vms/install.com'\"
else
echo shar: Extracting \"'sys/vms/install.com'\" \(6535 characters\)
sed "s/^X//" >'sys/vms/install.com' <<'END_OF_FILE'
X$ ! vms/install.com -- set up nethack 'playground'
X$ !
X$ ! Use vmsbuild.com to create nethack.exe, makedefs, and lev_comp *first*.
X$ !
X$ ! Edit this file to define gamedir & gameuic, or else invoke it with two
X$ ! command line parameters, as in:
X$ !	@[.sys.vms]install "disk$users:[games.nethack]" "games"
X$ ! or	@[.sys.vms]install "[-.play]" "[40,1]"
X$ !
X$	! default location is old playground, default owner is installer
X$	gamedir = f$trnlnm("HACKDIR")	!location of playground
X$	gameuic = f$user()		!owner of playground
X$	! --- nothing below this line should need to be changed ---
X$	if p1.nes."" then  gamedir := 'p1'
X$	if p2.nes."" then  gameuic := 'p2'
X$
X$	! note: all filespecs contain some punctuation,
X$	!	to avoid inadvertent logical name interaction
X$	play_files = "PERM.,RECORD.,LOGFILE."
X$	help_files = "HELP.,HH.,CMDHELP.,WIZHELP.,OPTHELP.,HISTORY.,LICENSE."
X$	data_files = "DATA.,RUMORS.,ORACLES.,OPTIONS.,QUEST.DAT"
X$	guidebook  = "[.doc]Guidebook.txt"
X$	invoc_proc = "[.sys.vms]nethack.com"
X$	trmcp_file = "[.sys.share]termcap"
X$	spec_files = "AIR.LEV,ASMODEUS.LEV,ASTRAL.LEV,BAALZ.LEV,BIGROOM.LEV," -
X		   + "CASTLE.LEV,EARTH.LEV,FAKEWIZ%.LEV,FIRE.LEV," -
X		   + "JUIBLEX.LEV,KNOX.LEV,MEDUSA-%.LEV,MINEFILL.LEV," -
X		   + "MINETOWN.LEV,MINE_END.LEV,ORACLE.LEV,ORCUS.LEV," -
X		   + "SANCTUM.LEV,TOWER%.LEV,VALLEY.LEV,WATER.LEV,WIZARD%.LEV"
X$	spec_input = "bigroom.des castle.des endgame.des " -
X		   + "gehennom.des knox.des medusa.des mines.des " -
X		   + "oracle.des tower.des yendor.des"
X$	qstl_files = "%-GOAL.LEV,%-FILL%.LEV,%-LOCATE.LEV,%-START.LEV"
X$	qstl_input = "Arch.des Barb.des Caveman.des Elf.des " -
X		   + "Healer.des Knight.des Priest.des Rogue.des " -
X		   + "Samurai.des Tourist.des Wizard.des Valkyrie.des"
X$	dngn_files = "DUNGEON."
X$	dngn_input = "dungeon.pdf"
X$ makedefs := $sys$disk:[-.util]makedefs
X$ lev_comp := $sys$disk:[-.util]lev_comp
X$ dgn_comp := $sys$disk:[-.util]dgn_comp
X$ milestone = "write sys$output f$fao("" !5%T "",0),"
X$ if p3.nes."" then  milestone = "!"
X$!
X$! make sure we've got a playground location
X$ gamedir := 'gamedir'
X$ if gamedir.eqs."" then  gamedir = "[.play]"	!last ditch default
X$ gamedir = f$parse(gamedir,,,,"SYNTAX_ONLY") - ".;"
X$ if gamedir.eqs."" then  write sys$error "% must specify playground directory"
X$ if gamedir.eqs."" then  exit %x1000002C	!ss$_abort
X$
X$!
X$!	['p3' is used in Makefile.top]
X$ if p3.nes."" then  goto make_'p3'
X$
X$	milestone "<installation...>"
X$!
X$make_data:
X$	! start from a known location -- [.sys.vms]
X$	set default 'f$parse(f$environment("PROCEDURE"),,,"DIRECTORY")'
X$! generate miscellaneous data files
X$	set default [-.-.dat]	!move to data directory
X$	milestone "(data)"
X$ makedefs -d	!data.base -> data
X$	milestone "(rumors)"
X$ makedefs -r	!rumors.tru + rumors.fal -> rumors
X$	milestone "(oracles)"
X$ makedefs -h	!oracles.txt -> oracles
X$	milestone "(dungeon preprocess)"
X$ makedefs -e	!dungeon.def -> dungeon.pdf
X$	milestone "(quest text)"
X$ makedefs -q	!quest.txt -> quest.dat
X$	milestone "(special levels)"
X$ lev_comp 'spec_input' !special levels
X$	milestone "(quest levels)"
X$ lev_comp 'qstl_input' !quest levels
X$	milestone "(dungeon compile)"
X$ dgn_comp 'dngn_input' !dungeon database
X$	set default [-]		!move up
X$ if p3.nes."" then  exit
X$
X$!
X$! set up the playground and save directories
X$	milestone "(directories)"
X$make_directories:
X$	srctree = f$environment("DEFAULT")
X$	set default 'gamedir'
X$ if f$parse("[-]").eqs."" then  create/dir/log [-] !default owner & protection
X$ if f$parse("[]" ).eqs."" then - !needs to be world writable
X   create/directory/owner='gameuic'/prot=(s:rwe,o:rwe,g:rwe,w:rwe)/log []
X$ if f$search("SAVE.DIR;1").eqs."" then -
X   create/directory/owner='gameuic'/prot=(s:rwe,o:rwe,g:rwe,w:rwe)/log -
X	[.SAVE]/version_limit=2
X$	set default 'srctree'
X$ if p3.nes."" then  exit
X$!
X$! create empty writeable files -- logfile, scoreboard, multi-user access lock
X$	milestone "(writeable files)"
X$make_writeable_files:
X!-!$ create/owner='gameuic'/prot=(s:rwed,o:rwed,g:rwed,w:rwed) -
X!-!	'gamedir''play_files'
X$	i = 0
X$ploop: f = f$element(i,",",play_files)
X$	if f.eqs."," then  goto pdone
X$	i = i + 1
X$	f = gamedir + f
X$	if f$search(f).nes.""	!file already exists
X$	then	if f$file_attrib(f,"RFM").eqs."STMLF" then  goto ploop
X$		rename/new_vers 'f' *.old	!needs to be stream_lf
X$	endif
X$	create/fdl=sys$input:/owner='gameuic' 'f'/log
Xfile
X organization sequential
X protection (system:rwd,owner:rwd,group:rw,world:rw)
Xrecord
X format stream_lf
X$	goto ploop
X$pdone:
X$ if p3.nes."" then  exit
X$!
X$! copy over the remaining game files, then make them readonly
X$	milestone "(readonly files)"
X$make_readonly_files:
X$ copy/prot=(s:rwed,o:rwed,g:re,w:re) -
X	[.dat]'help_files','data_files','spec_files','qstl_files','dngn_files' -
X	'gamedir'*.*
X$ set file/owner='gameuic'/prot=(s:re,o:re) -
X	'gamedir''help_files','data_files','spec_files','qstl_files','dngn_files'
X$ if p3.nes."" then  exit
X$!
X$	milestone "(nethack.exe)"
X$make_executable:
X$ copy/prot=(s:rwed,o:rwed,g:re,w:re) [.src]nethack.exe 'gamedir'*.*
X$ set file/owner='gameuic'/prot=(s:re,o:re) 'gamedir'nethack.exe
X$ if p3.nes."" then  exit
X$!
X$! provide invocation procedure (if available)
X$make_procedure:
X$ if f$search(invoc_proc).eqs."" then  goto skip_dcl
X$ if f$search("''gamedir'nethack.com").nes."" then -
X    if f$cvtime(f$file_attr("''gamedir'nethack.com","RDT")) -
X      .ges. f$cvtime(f$file_attr(invoc_proc,"RDT")) then  goto skip_dcl
X$	milestone "(nethack.com)"
X$  copy/prot=(s:rwed,o:rwed,g:re,w:re) 'invoc_proc' 'gamedir'nethack.com
X$  set file/owner='gameuic'/prot=(s:re,o:re) 'gamedir'nethack.com
X$skip_dcl:
X$ if p3.nes."" then  exit
X$!
X$! provide plain-text Guidebook doc file (if available)
X$make_documentation:
X$ if f$search(guidebook).eqs."" then  goto skip_doc
X$	milestone "(Guidebook)"
X$  copy/prot=(s:rwed,o:rwed,g:re,w:re) 'guidebook' 'gamedir'Guidebook.doc
X$  set file/owner='gameuic'/prot=(s:re,o:re) 'gamedir'Guidebook.doc
X$skip_doc:
X$ if p3.nes."" then  exit
X$!
X$! provide last-resort termcap file (if available)
X$make_termcap:
X$ if f$search(trmcp_file).eqs."" then  goto skip_termcap
X$ if f$search("''gamedir'termcap").nes."" then  goto skip_termcap
X$	milestone "(termcap)"
X$  copy/prot=(s:rwed,o:rwed,g:re,w:re) 'trmcp_file' 'gamedir'termcap
X$  set file/owner='gameuic'/prot=(s:re,o:re) 'gamedir'termcap
X$skip_termcap:
X$ if p3.nes."" then  exit
X$!
X$! done
X$	milestone "<done>"
X$ define/nolog hackdir 'gamedir'
X$ write sys$output -
X    f$fao("!/ Nethack installation complete. !/ Playground is !AS !/",gamedir)
X$ exit
END_OF_FILE
if test 6535 -ne `wc -c <'sys/vms/install.com'`; then
    echo shar: \"'sys/vms/install.com'\" unpacked with wrong size!
fi
# end of 'sys/vms/install.com'
fi
if test -f 'win/X11/Install.X11' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'win/X11/Install.X11'\"
else
echo shar: Extracting \"'win/X11/Install.X11'\" \(5873 characters\)
sed "s/^X//" >'win/X11/Install.X11' <<'END_OF_FILE'
X
XThis is a first cut at an X11 window port for NetHack.  X11 offers enormous
Xpotential for NetHack, little of which is realized here.  If you have ideas
Xand extra time, feel free to send in improvements!
X
XThere are no explicit UNIX dependencies in this code, but it is only
Xknown to work under UNIX, using X11R4 or X11R5.  Other X11R4+ platforms
Xmay work as well, with some tweaking likely.  Follow WIN* in
Xsys/unix/Makefile.src for compilation hints.
X
XThe reason this uses the Athena widget set is that the Athena widgets come
Xfree from MIT (like X11).  Unfortunately, the companies that resell X11
X(value subtracted er, added software; yea, yea, that's the ticket) usually
Xdiscourage its use by either omitting the set or putting it on the
X"unsupported" portion of their tape.  If you do not have the Athena
Xwidgets, you may obtain them via anonymous ftp from export.lcs.mit.edu.
X
XTo use this code, define X11_GRAPHICS in include/config.h.  Add $(WINX11SRC),
X$(WINX11OBJ), and $(WINX11LIB) to WINSRC, WINOBJ, and WINLIB respectively
Xin src/Makefile.  This will give you an executable supporting both X11 and
Xtty windowing.
X
XIf you want special graphics symbols, you will also need to install one
Xor both of the included X11 fonts and use the symbol mappings found in
Xnethack.rc.  The fonts are found in nh10.bdf and ibm.bdf.  You first need
Xto convert the bdf files to whatever form your X11 server recognizes
X(usually using a command called bdftosnf, or on Ultrix systems, bdftopcf).
XThen run mkfontdir on the directory containing your font files (you might
Xwant to copy them to GAMEDIR, from the top Makefile, after you've done
X"make install").  If these commands aren't familiar, talk to your local
XX11 guru and read the man pages.  Finally, add that directory to your
Xfont search path (e.g. xset fp+ GAMEDIR, setting GAMEDIR to the value of
XGAMEDIR in the top Makefile).  Alternatively, you (assuming you are a
Xsystem administrator) can install the fonts in your standard X11 font
Xdirectory.  If you do not install the fonts in the standard X11 font
Xdirectory, all persons playing nethack must add that "xset fp+" command
Xto their .xinitrc file, or whatever file they execute when starting X11.
XAdding the "xset" command to the nethack.sh is also an alternative, though
Xit may clutter your X11 font search path after playing several games, so
Xthis method is not recommended.  See the note below for the alternative
Xinstallation procedure for Sun's OpenWindows.
X
XIf your X11 include files and libraries are not installed in a standard
Xplace (i.e. /usr/include/X11 and /usr/lib respectively) you will need to
Xprepend an appropriate -I<idirectory> parameter to CFLAGS and a
X-L<ldirectory> parameter to LFLAGS, setting <?directory> to the place to
Xfind the include and library files for X11.
X
XFinally, you should also install the NetHack.ad file in the normal X11
Xapplications defaults directory.  Alternatively, each person may append
Xthe contents of this file to their .Xdefaults file.  A second
Xalternative is copy NetHack.ad to GAMEDIR (from the top Makefile) and
Xadd a line to nethack.sh specifying this additional applications
Xdefaults directory:
X	XAPPLRESDIR=$HACKDIR; export XAPPLRESDIR
X
XTwo icon suggestions to the window manager are supported:  nh72 and nh56.
XData for them comes from source files nh72icon and nh56icon and they are
Xcompiled into the program via #include in winX.c.  Selection between them
Xis controlled by the "icon" resource in NetHack.ad; the default is nh72.
X
XSorry, an Imakefile is not included.  Unlike many X11 programs, X11
Xsupport is only a small, optional, part of nethack, and the Makefile is
Xneeded for systems that don't use X11.
X
XNotes for Sun's OpenWindows 3.x (2.x will not work):
X    1.	Define OPENWINBUG in include/unixconf.h.  Add -I/usr/openwin/include
X	to CFLAGS, -L/usr/openwin/lib to LFLAGS, and -lm to WINX11LIB in
X	src/Makefile.  (Naturally, if your OpenWindows is installed
X	elsewhere, adapt the two openwin paths.)  This will allow you
X	to create a game executable.
X
X    2.	Run the fonts through convertfont and run bldfamily on the directory.
X	The environment variable FONTPATH must include the directory the fonts
X	are in when NetHack is run.  For a personal installation, setting the
X	variable in your .profile or .login is the simplest thing.  For a
X	multi-user installation, add the lines
X		FONTPATH=$FONTPATH:$HACKDIR/fonts
X		export FONTPATH
X	near the top of sys/unix/nethack.sh (before installation), and put
X	the fonts and associated files in the "fonts" subdirectory of your
X	GAMEDIR from the top Makefile (after installation via 'make install').
X
X    3.  Something must still be done with the NetHack.ad file.  All three
X	of the possibilities mentioned for standard X11 should work, but
X	it may be simplest to use the second or third, paralleling your
X	FONTPATH choice.
X
X
XFile				Description
X---------	---------------------------------------------------------------
Xnethack.rc	- A sample configuration file for fonts nh10 and ibm.
Xnh10.bdf	- A modified version of the 10x20 standard font.
Xibm.bdf		- A modified version of one of the ibm (8x14) nethack font.
X		  Must be used in conjunction with NetHack.ad or nethack.rc.
Xnh32icon	- A 32x32 icon bitmap for use with window managers.
Xnh56icon	- A 56x56 icon bitmap for use with window managers.
Xnh72icon	- A 72x72 icon bitmap for use with window managers.
XNetHack.ad	- A sample .Xdefaults for a color screen.
X../../include/Window.h
X../../include/WindowP.h
XWindow.c	- A bare-bones widget that has 16 colors and a drawing canvas.
X../../include/winX.h
X		- Defines for the X window-port.
Xwin*.c		- Code for the X window-port
Xdialogs.c	- A better dialog widget.  Original code (modified slightly
X		  by Dean Luick) distributed under the X copyright by Tim
X		  Theisen.  This is from his Ghostview program (which is under
X		  the GNU public license, v2 or higher).
END_OF_FILE
if test 5873 -ne `wc -c <'win/X11/Install.X11'`; then
    echo shar: \"'win/X11/Install.X11'\" unpacked with wrong size!
fi
# end of 'win/X11/Install.X11'
fi
echo shar: End of archive 100 \(of 108\).
cp /dev/null ark100isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \
21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \
41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 \
61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 \
81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 \
101 102 103 104 105 106 107 108 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 108 archives.
    echo "Now execute 'rebuild.sh'"
    rm -f ark10[0-8]isdone ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
