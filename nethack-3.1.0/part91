Path: uunet!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v16i099:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Part91/108
Message-ID: <4464@master.CNA.TEK.COM>
Date: 5 Feb 93 22:02:38 GMT
Sender: news@master.CNA.TEK.COM
Lines: 2148
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1650

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 16, Issue 99
Archive-name: nethack31/Part91
Supersedes: nethack3p9: Volume 10, Issue 46-108
Environment: Amiga, Atari, Mac, MS-DOS, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 91 (of 108)."
# Contents:  dat/Priest.des src/mkmap.c sys/mac/macfile.c
#   sys/msdos/msdos.c sys/vms/nethack.com win/X11/dialogs.c
# Wrapped by billr@saab on Wed Jan 27 16:09:24 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'dat/Priest.des' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dat/Priest.des'\"
else
echo shar: Extracting \"'dat/Priest.des'\" \(10270 characters\)
sed "s/^X//" >'dat/Priest.des' <<'END_OF_FILE'
X#	SCCS Id: @(#)Priest.des	3.1	92/09/22
X#	Copyright (c) 1989 by Jean-Christophe Collet
X#	Copyright (c) 1991-2 by M. Stephenson
X# NetHack may be freely redistributed.  See license for details.
X#
X#	The "start" level for the quest.
X#
X#	Here you meet your (besieged) class leader, High Priest
X#	and receive your quest assignment.
X#
XMAZE: "P-start",' '
XFLAGS: noteleport,hardfloor
XGEOMETRY:center,center
XMAP
X............................................................................
X............................................................................
X............................................................................
X....................------------------------------------....................
X....................|................|.....|.....|.....|....................
X....................|..------------..|--+-----+-----+--|....................
X....................|..|..........|..|.................|....................
X....................|..|..........|..|+---+---+-----+--|....................
X..................---..|..........|......|...|...|.....|....................
X..................+....|..........+......|...|...|.....|....................
X..................+....|..........+......|...|...|.....|....................
X..................---..|..........|......|...|...|.....|....................
X....................|..|..........|..|+-----+---+---+--|....................
X....................|..|..........|..|.................|....................
X....................|..------------..|--+-----+-----+--|....................
X....................|................|.....|.....|.....|....................
X....................------------------------------------....................
X............................................................................
X............................................................................
X............................................................................
XENDMAP
X# Random Monsters
XRANDOM_MONSTERS: 'Z', 'W'
X# Dungeon Description
XREGION:(00,00,75,19),lit,"ordinary"
XREGION:(24,06,33,13),lit,"temple"
X# Portal arrival point
XBRANCH:(05,04,05,04),(0,0,0,0)
X# Stairs
XSTAIR:(52,09),down
X# Doors
XDOOR:locked,(18,09)
XDOOR:locked,(18,10)
XDOOR:closed,(34,09)
XDOOR:closed,(34,10)
XDOOR:closed,(40,05)
XDOOR:closed,(46,05)
XDOOR:closed,(52,05)
XDOOR:locked,(38,07)
XDOOR:closed,(42,07)
XDOOR:closed,(46,07)
XDOOR:closed,(52,07)
XDOOR:locked,(38,12)
XDOOR:closed,(44,12)
XDOOR:closed,(48,12)
XDOOR:closed,(52,12)
XDOOR:closed,(40,14)
XDOOR:closed,(46,14)
XDOOR:closed,(52,14)
X# Unattended Altar - unaligned due to conflict - player must align it.
XALTAR:(28,09),noalign,altar
X# High Priest
XMONSTER:'@',"Arch Priest",(28,10)
X# The treasure of High Priest
XOBJECT:'(',"chest",(27,10)
X# knight guards for the audience chamber
XMONSTER:'@',"acolyte",(32,07)
XMONSTER:'@',"acolyte",(32,08)
XMONSTER:'@',"acolyte",(32,11)
XMONSTER:'@',"acolyte",(32,12)
XMONSTER:'@',"acolyte",(33,07)
XMONSTER:'@',"acolyte",(33,08)
XMONSTER:'@',"acolyte",(33,11)
XMONSTER:'@',"acolyte",(33,12)
X# Non diggable walls
XNON_DIGGABLE:(00,00,75,19)
X# Random traps
XTRAP:"dart",(20,09)
XTRAP:"dart",(20,10)
XTRAP:random,random
XTRAP:random,random
XTRAP:random,random
XTRAP:random,random
X# Monsters on siege duty.
XMONSTER: 'Z',"human zombie",(37,01)
XMONSTER: 'Z',"human zombie",(37,18)
XMONSTER: 'Z',"human zombie",(03,03)
XMONSTER: 'Z',"human zombie",(65,04)
XMONSTER: 'Z',"human zombie",(12,11)
XMONSTER: 'Z',"human zombie",(60,12)
XMONSTER: 'Z',"human zombie",(14,08)
XMONSTER: 'Z',"human zombie",(55,00)
XMONSTER: 'Z',"human zombie",(18,18)
XMONSTER: 'Z',"human zombie",(59,10)
XMONSTER: 'Z',"human zombie",(13,09)
XMONSTER: 'Z',"human zombie",(01,17)
X 
X#
X#	The "locate" level for the quest.
X#
X#	Here you have to locate the Temple of Nalzok to go
X#	further towards your assigned quest.
X#
X
XMAZE: "P-locate",' '
XFLAGS: hardfloor
X# This is a kludge to init the level as a lit field.
XINIT_MAP: '.' , '.' , false , false , lit , false
XGEOMETRY:center,center
XMAP
X........................................
X........................................
X..........----------+----------.........
X..........|........|.|........|.........
X..........|........|.|........|.........
X..........|----.----.----.----|.........
X..........+...................+.........
X..........+...................+.........
X..........|----.----.----.----|.........
X..........|........|.|........|.........
X..........|........|.|........|.........
X..........----------+----------.........
X........................................
X........................................
XENDMAP
X# Random Monsters
XRANDOM_MONSTERS: 'Z', 'W'
X# Dungeon Description
XREGION:(00,00,09,13),unlit,"morgue"
XREGION:(09,00,30,01),unlit,"morgue"
XREGION:(09,12,30,13),unlit,"morgue"
XREGION:(31,00,39,13),unlit,"morgue"
XREGION:(11,03,29,10),lit,"temple",filled,true
X# The altar inside the temple
XALTAR:(20,07),noalign,shrine
XMONSTER:'@',"aligned priest",(20,07),noalign,hostile
X# Doors
XDOOR:locked,(10,06)
XDOOR:locked,(10,07)
XDOOR:locked,(20,02)
XDOOR:locked,(20,11)
XDOOR:locked,(30,06)
XDOOR:locked,(30,07)
X# Stairs
X# Note:  The up stairs are *intentionally* off of the map.
XSTAIR:(43,05),up
XSTAIR:(20,06),down
X# Non diggable walls
XNON_DIGGABLE:(10,02,30,13)
X# Objects (inside the antechambers).
XOBJECT:random,random,(14,03)
XOBJECT:random,random,(15,03)
XOBJECT:random,random,(16,03)
XOBJECT:random,random,(14,10)
XOBJECT:random,random,(15,10)
XOBJECT:random,random,(16,10)
XOBJECT:random,random,(17,10)
XOBJECT:random,random,(24,03)
XOBJECT:random,random,(25,03)
XOBJECT:random,random,(26,03)
XOBJECT:random,random,(27,03)
XOBJECT:random,random,(24,10)
XOBJECT:random,random,(25,10)
XOBJECT:random,random,(26,10)
XOBJECT:random,random,(27,10)
X# Random traps
XTRAP:random,(15,04)
XTRAP:random,(25,04)
XTRAP:random,(15,09)
XTRAP:random,(25,09)
XTRAP:random,random
XTRAP:random,random
X# No random monsters - the morgue generation will put them in.
X
X#
X#	The "goal" level for the quest.
X#
X#	Here you meet Nalzok your nemesis monster.  You have to
X#	defeat Nalzok in combat to gain the artifact you have
X#	been assigned to retrieve.
X#
X
XMAZE: "P-goal", ' '
XINIT_MAP: 'L' , '.' , false , false , unlit , false
XGEOMETRY:center,center
XMAP
X.L......L.LLL.......LL....
X.LLL.......L......LL......
XLL.LL.............L.LL....
X..........................
X......................LL..
X......................LLL.
XLL........................
X.LL.......................
X.LL................LL.L...
X..LL.....L.LL.......LLL...
X.........LLL.........L....
XENDMAP
X# Random Monsters
XRANDOM_MONSTERS: 'Z', 'W'
X# Dungeon Description
XREGION:(00,00,25,10),unlit,"ordinary"
X# Stairs
XSTAIR:(20,05),up
X# Objects
XOBJECT:'[',"helm of brilliance",(13,05),blessed,0,"The Mitre of Holiness"
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
X# Random traps
XTRAP:"fire",random
XTRAP:"fire",random
XTRAP:"fire",random
XTRAP:"fire",random
XTRAP:random,random
XTRAP:random,random
X# Random monsters.
XMONSTER:'&',"Nalzok",(13,05)
XMONSTER:'Z',"human zombie",random
XMONSTER:'Z',"human zombie",random
XMONSTER:'Z',"human zombie",random
XMONSTER:'Z',"human zombie",random
XMONSTER:'Z',"human zombie",random
XMONSTER:'Z',"human zombie",random
XMONSTER:'Z',"human zombie",random
XMONSTER:'Z',"human zombie",random
XMONSTER:'Z',"human zombie",random
XMONSTER:'Z',"human zombie",random
XMONSTER:'Z',"human zombie",random
XMONSTER:'Z',"human zombie",random
XMONSTER:'Z',"human zombie",random
XMONSTER:'Z',"human zombie",random
XMONSTER:'Z',"human zombie",random
XMONSTER:'Z',"human zombie",random
XMONSTER:'Z',random,random
XMONSTER:'Z',random,random
XMONSTER:'W',"wraith",random
XMONSTER:'W',"wraith",random
XMONSTER:'W',"wraith",random
XMONSTER:'W',"wraith",random
XMONSTER:'W',"wraith",random
XMONSTER:'W',"wraith",random
XMONSTER:'W',"wraith",random
XMONSTER:'W',"wraith",random
XMONSTER:'W',random,random
X
X#
X#	The "fill" levels for the quest.
X#
X#	These levels are used to fill out any levels not occupied by specific
X#	levels as defined above. "filla" is the upper filler, between the
X#	start and locate levels, and "fillb" the lower between the locate
X#	and goal levels.
X#
X
XLEVEL: "P-filla"
X# Random Monsters
XRANDOM_MONSTERS: 'Z', 'W'
X#
XROOM: "ordinary" , random, random, random, random
XSTAIR: random, up
XOBJECT: random,random,random
XMONSTER: 'Z', "human zombie", random
X
XROOM: "ordinary" , random, random, random, random
XOBJECT: random, random, random
XOBJECT: random,random,random
X
XROOM: "ordinary" , random, random, random, random
XOBJECT: random, random, random
XTRAP: random, random
XOBJECT: random,random,random
XMONSTER: 'Z', "human zombie", random
X
XROOM: "morgue" , random, random, random, random
XSTAIR: random, down
XOBJECT: random, random, random
XTRAP: random, random
X
XROOM: "ordinary" , random, random, random, random
XOBJECT: random, random, random
XOBJECT: random, random, random
XTRAP: random, random
XMONSTER: 'W', "wraith", random
X
XROOM: "morgue" , random, random, random, random
XOBJECT: random, random, random
XTRAP: random, random
X
XRANDOM_CORRIDORS
X
XLEVEL: "P-fillb"
X# Random Monsters
XRANDOM_MONSTERS: 'Z', 'W'
X#
XROOM: "ordinary" , random, random, random, random
XSTAIR: random, up
XOBJECT: random,random,random
XMONSTER: 'Z', "human zombie", random
XMONSTER: 'W', "wraith", random
X
XROOM: "morgue" , random, random, random, random
XOBJECT: random, random, random
XOBJECT: random, random, random
XOBJECT: random,random,random
X
XROOM: "ordinary" , random, random, random, random
XOBJECT: random, random, random
XTRAP: random, random
XOBJECT: random,random,random
XMONSTER: 'Z', "human zombie", random
XMONSTER: 'W', "wraith", random
X
XROOM: "morgue" , random, random, random, random
XSTAIR: random, down
XOBJECT: random, random, random
XOBJECT: random, random, random
XTRAP: random, random
X
XROOM: "ordinary" , random, random, random, random
XOBJECT: random, random, random
XOBJECT: random, random, random
XTRAP: random, random
XMONSTER: 'Z', "human zombie", random
XMONSTER: 'W', "wraith", random
X
XROOM: "morgue" , random, random, random, random
XOBJECT: random, random, random
XTRAP: random, random
X
XRANDOM_CORRIDORS
END_OF_FILE
if test 10270 -ne `wc -c <'dat/Priest.des'`; then
    echo shar: \"'dat/Priest.des'\" unpacked with wrong size!
fi
# end of 'dat/Priest.des'
fi
if test -f 'src/mkmap.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/mkmap.c'\"
else
echo shar: Extracting \"'src/mkmap.c'\" \(9999 characters\)
sed "s/^X//" >'src/mkmap.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)mkmap.c	3.1	92/07/15	*/
X/* Copyright (c) J. C. Collet, M. Stephenson and D. Cohrs, 1992   */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include "hack.h"
X#include "sp_lev.h"
X
X#define	HEIGHT	(ROWNO - 1)
X#define WIDTH	(COLNO - 2)
X
Xstatic void FDECL(init_map,(SCHAR_P));
Xstatic void FDECL(init_fill,(SCHAR_P,SCHAR_P));
Xstatic schar FDECL(get_map,(int,int,SCHAR_P));
Xstatic void FDECL(pass_one,(SCHAR_P,SCHAR_P));
Xstatic void FDECL(pass_two,(SCHAR_P,SCHAR_P));
Xstatic void FDECL(pass_three,(SCHAR_P,SCHAR_P));
Xstatic void NDECL(wallify_map);
Xstatic void FDECL(join_map,(SCHAR_P,SCHAR_P));
Xstatic void FDECL(finish_map,(SCHAR_P,SCHAR_P,XCHAR_P,XCHAR_P));
Xvoid FDECL(mkmap, (lev_init *));
X
Xchar *new_locations;
Xint min_rx, max_rx, min_ry, max_ry; /* rectangle bounds for regions */
Xstatic int n_loc_filled;
X
Xstatic void
Xinit_map(bg_typ)
X	schar	bg_typ;
X{
X	register int i,j;
X
X	for(i=1; i<COLNO; i++)
X	    for(j=0; j<ROWNO; j++)
X		levl[i][j].typ = bg_typ;
X}
X
Xstatic void
Xinit_fill(bg_typ, fg_typ)
X	schar	bg_typ, fg_typ;
X{
X	register int i,j;
X	long limit, count;
X
X	limit = (WIDTH * HEIGHT * 2) / 5;
X	count = 0;
X	while(count < limit) {
X	    i = rn1(WIDTH-1, 2);
X	    j = rnd(HEIGHT-1);
X	    if (levl[i][j].typ == bg_typ) {
X		levl[i][j].typ = fg_typ;
X		count++;
X	    }
X	}
X}
X
Xstatic schar
Xget_map(col,row, bg_typ)
X	int col,row;
X	schar	bg_typ;
X{
X	if (col <= 0 || row < 0 || col > WIDTH || row >= HEIGHT)
X		return bg_typ;
X	return levl[col][row].typ;
X}
X
Xstatic int dirs[16] = {
X    -1, -1 /**/, -1, 0 /**/, -1, 1 /**/,
X     0, -1 /**/,              0, 1 /**/,
X     1, -1 /**/,  1, 0 /**/,  1, 1};
X
Xstatic void
Xpass_one(bg_typ, fg_typ)
X	schar	bg_typ, fg_typ;
X{
X	register int i,j;
X	short count, dr;
X
X	for(i=2; i<=WIDTH; i++)
X	    for(j=1; j<HEIGHT; j++) {
X		for(count=0, dr=0; dr < 8; dr++)
X		    if(get_map(i+dirs[dr*2], j+dirs[(dr*2)+1], bg_typ)
X								== fg_typ)
X			count++;
X
X		switch(count) {
X		  case 0 : /* death */
X		  case 1 :
X		  case 2:
X			  levl[i][j].typ = bg_typ;
X			  break;
X		  case 5:
X		  case 6:
X		  case 7:
X		  case 8:
X			  levl[i][j].typ = fg_typ;
X			  break;
X		  default:
X			  break;
X		  }
X	    }
X}
X
X#define new_loc(i,j)	*(new_locations+ ((j)*(WIDTH+1)) + (i))
X
Xstatic void
Xpass_two(bg_typ, fg_typ)
X	schar	bg_typ, fg_typ;
X{
X	register int i,j;
X	short count, dr;
X
X	for(i=2; i<=WIDTH; i++)
X	    for(j=1; j<HEIGHT; j++) {
X		for(count=0, dr=0; dr < 8; dr++)
X		    if(get_map(i+dirs[dr*2], j+dirs[(dr*2)+1], bg_typ)
X								== fg_typ)
X			count++;
X		    if (count == 5)
X			new_loc(i,j) = bg_typ;
X		    else
X			new_loc(i,j) = get_map(i,j, bg_typ);
X	    }
X
X	for(i=2; i<=WIDTH; i++)
X	    for(j=1; j<HEIGHT; j++)
X		levl[i][j].typ = new_loc(i,j);
X}
X
Xstatic void
Xpass_three(bg_typ, fg_typ)
X	schar	bg_typ, fg_typ;
X{
X	register int i,j;
X	short count, dr;
X
X	for(i=2; i<=WIDTH; i++)
X	    for(j=1; j<HEIGHT; j++) {
X		for(count=0, dr=0; dr < 8; dr++)
X		    if(get_map(i+dirs[dr*2], j+dirs[(dr*2)+1], bg_typ)
X								== fg_typ)
X			count++;
X		if (count < 3)
X		    new_loc(i,j) = bg_typ;
X		else
X		    new_loc(i,j) = get_map(i,j, bg_typ);
X	    }
X
X	for(i=2; i<=WIDTH; i++)
X	    for(j=1; j<HEIGHT; j++)
X		levl[i][j].typ = new_loc(i,j);
X}
X
X/*
X * use a flooding algorithm to find all locations that should
X * have the same rm number as the current location.
X * if anyroom is TRUE, use IS_ROOM to check room membership instead of
X * exactly matching levl[sx][sy].typ and walls are included as well.
X */
Xvoid
Xflood_fill_rm(sx, sy, rmno, lit, anyroom)
X    int sx;
X    register int sy;
X    register int rmno;
X    boolean lit;
X    boolean anyroom;
X{
X    register int i;
X    int nx;
X    schar fg_typ = levl[sx][sy].typ;
X
X    /* back up to find leftmost uninitialized location */
X    while(sx > 0
X	  && (anyroom ? IS_ROOM(levl[sx][sy].typ) : levl[sx][sy].typ == fg_typ)
X	  && levl[sx][sy].roomno != rmno)
X	sx--;
X    sx++; /* compensate for extra decrement */
X
X    /* assume sx,sy is valid */
X    if(sx < min_rx) min_rx = sx;
X    if(sy < min_ry) min_ry = sy;
X
X    for(i=sx; i<=WIDTH && levl[i][sy].typ == fg_typ; i++) {
X	levl[i][sy].roomno = rmno;
X	levl[i][sy].lit = lit;
X	if(anyroom) {
X	    /* add walls to room as well */
X	    register int ii,jj;
X	    for(ii= (i == sx ? i-1 : i); ii <= i+1; ii++)
X		for(jj = sy-1; jj <= sy+1; jj++)
X		    if(isok(ii,jj) &&
X		       (IS_WALL(levl[ii][jj].typ) ||
X			IS_DOOR(levl[ii][jj].typ))) {
X			levl[ii][jj].edge = 1;
X			if(lit) levl[ii][jj].lit = lit;
X			if (levl[ii][jj].roomno != rmno)
X			    levl[ii][jj].roomno = SHARED;
X			else
X			    levl[ii][jj].roomno = rmno;
X		    }
X	}
X	n_loc_filled++;
X    }
X    nx = i;
X
X    if(isok(sx,sy-1))
X	for(i=sx; i<nx; i++)
X	    if(levl[i][sy-1].typ == fg_typ) {
X		if(levl[i][sy-1].roomno != rmno)
X		    flood_fill_rm(i,sy-1,rmno,lit,anyroom);
X	    } else {
X		if((i>sx || isok(i-1,sy-1)) &&
X		      levl[i-1][sy-1].typ == fg_typ) {
X		    if(levl[i-1][sy-1].roomno != rmno)
X			flood_fill_rm(i-1,sy-1,rmno,lit,anyroom);
X		}
X		if((i<nx-1 || isok(i+1,sy-1)) &&
X		      levl[i+1][sy-1].typ == fg_typ) {
X		    if(levl[i+1][sy-1].roomno != rmno)
X			flood_fill_rm(i+1,sy-1,rmno,lit,anyroom);
X		}
X	    }
X    if(isok(sx,sy+1))
X	for(i=sx; i<nx; i++)
X	    if(levl[i][sy+1].typ == fg_typ) {
X		if(levl[i][sy+1].roomno != rmno)
X		    flood_fill_rm(i,sy+1,rmno,lit,anyroom);
X	    } else {
X		if((i>sx || isok(i-1,sy+1)) &&
X		      levl[i-1][sy+1].typ == fg_typ) {
X		    if(levl[i-1][sy+1].roomno != rmno)
X			flood_fill_rm(i-1,sy+1,rmno,lit,anyroom);
X		}
X		if((i<nx-1 || isok(i+1,sy+1)) &&
X		      levl[i+1][sy+1].typ == fg_typ) {
X		    if(levl[i+1][sy+1].roomno != rmno)
X			flood_fill_rm(i+1,sy+1,rmno,lit,anyroom);
X		}
X	    }
X
X    if(nx > max_rx) max_rx = nx - 1; /* nx is just past valid region */
X    if(sy > max_ry) max_ry = sy;
X}
X
X/*
X *	If we have drawn a map without walls, this allows us to
X *	auto-magically wallify it.  Taken from lev_main.c.
X */
Xstatic void
Xwallify_map()
X{
X
X    int x, y, xx, yy;
X
X    for(x = 1; x < COLNO; x++)
X	for(y = 0; y < ROWNO; y++)
X	    if(levl[x][y].typ == STONE) {
X		for(yy = y - 1; yy <= y+1; yy++)
X		    for(xx = x - 1; xx <= x+1; xx++)
X			if(isok(xx,yy) && levl[xx][yy].typ == ROOM) {
X			    if(yy != y)	levl[x][y].typ = HWALL;
X			    else	levl[x][y].typ = VWALL;
X			}
X	    }
X}
X
Xstatic void
Xjoin_map(bg_typ, fg_typ)
X	schar	bg_typ, fg_typ;
X{
X    register struct mkroom *croom, *croom2;
X
X    register int i, j;
X    int sx, sy;
X    coord sm, em;
X
X    /* first, use flood filling to find all of the regions that need joining */
X    for(i=2; i<=WIDTH; i++)
X	for(j=1; j<HEIGHT; j++) {
X	    if(levl[i][j].typ == fg_typ && levl[i][j].roomno == NO_ROOM) {
X		min_rx = max_rx = i;
X		min_ry = max_ry = j;
X		n_loc_filled = 0;
X		flood_fill_rm(i,j,nroom+ROOMOFFSET,FALSE,FALSE);
X		if(n_loc_filled > 3) {
X		    add_room(min_rx, min_ry, max_rx, max_ry,
X			     FALSE, OROOM, TRUE);
X		    rooms[nroom-1].irregular = TRUE;
X		    if(nroom >= (MAXNROFROOMS*2))
X			goto joinm;
X		} else {
X		    /*
X		     * it's a tiny hole; erase it from the map to avoid
X		     * having the player end up here with no way out.
X		     */
X		    for(sx = min_rx; sx<=max_rx; sx++)
X			for(sy = min_ry; sy<=max_ry; sy++)
X			    if(levl[sx][sy].roomno == nroom+ROOMOFFSET) {
X				levl[sx][sy].typ = bg_typ;
X				levl[sx][sy].roomno = NO_ROOM;
X			    }
X		}
X	    }
X	}
X
Xjoinm:
X    /*
X     * Ok, now we can actually join the regions with fg_typ's.
X     * The rooms are already sorted due to the previous loop,
X     * so don't call sort_rooms(), which can screw up the roomno's
X     * validity in the levl structure.
X     */
X    for(croom = &rooms[0], croom2 = croom + 1; croom2 < &rooms[nroom]; ) {
X	/* pick random starting and end locations for "corridor" */
X	if(!somexy(croom, &sm) || !somexy(croom2, &em)) {
X	    /* ack! -- the level is going to be busted */
X	    /* arbitrarily pick centers of both rooms and hope for the best */
X	    impossible("No start/end room loc in join_map.");
X	    sm.x = croom->lx + ((croom->hx - croom->lx) / 2);
X	    sm.y = croom->ly + ((croom->hy - croom->ly) / 2);
X	    em.x = croom2->lx + ((croom2->hx - croom2->lx) / 2);
X	    em.y = croom2->ly + ((croom2->hy - croom2->ly) / 2);
X	}
X
X	(void) dig_corridor(sm, em, FALSE, fg_typ, bg_typ);
X
X	/* choose next region to join */
X	/* only increment croom if croom and croom2 are non-overlapping */
X	if(croom2->lx > croom->hx ||
X	   ((croom2->ly > croom->hy || croom2->hy < croom->ly) && rn2(3))) {
X	    croom = croom2;
X	}
X	croom2++; /* always increment the next room */
X    }
X}
X
Xstatic void
Xfinish_map(fg_typ, bg_typ, lit, walled)
X        schar	fg_typ, bg_typ;
X        boolean	lit, walled;
X{
X	int	i, j;
X
X	if(walled) wallify_map();
X
X	if(lit) {
X	    for(i=1; i<COLNO; i++)
X		for(j=0; j<ROWNO; j++)
X		    if((!IS_ROCK(fg_typ) && levl[i][j].typ == fg_typ) ||
X		       (!IS_ROCK(bg_typ) && levl[i][j].typ == bg_typ) ||
X			(walled && IS_WALL(levl[i][j].typ)))
X			levl[i][j].lit = TRUE;
X	    for(i = 0; i < nroom; i++)
X		rooms[i].rlit = 1;
X	}
X}
X
X#define	N_P1_ITER	1	/* tune map generation via this value */
X#define	N_P2_ITER	1	/* tune map generation via this value */
X#define	N_P3_ITER	2	/* tune map smoothing via this value */
X
Xvoid
Xmkmap(init_lev)
X
X	lev_init	*init_lev;
X{
X	schar	bg_typ = init_lev->bg,
X		fg_typ = init_lev->fg;
X	boolean smooth = init_lev->smoothed,
X                join = init_lev->joined;
X        xchar   lit = init_lev->lit,
X                walled = init_lev->walled;
X	int i;
X
X	if(lit < 0)
X	    lit = (rnd(1+abs(depth(&u.uz))) < 11 && rn2(77)) ? 1 : 0;
X
X	new_locations = (char *)alloc((WIDTH+1) * HEIGHT);
X
X	init_map(bg_typ);
X	init_fill(bg_typ, fg_typ);
X
X	for(i = 0; i < N_P1_ITER; i++)
X	    pass_one(bg_typ, fg_typ);
X
X	for(i = 0; i < N_P2_ITER; i++)
X	pass_two(bg_typ, fg_typ);
X
X	if(smooth)
X	    for(i = 0; i < N_P3_ITER; i++)
X		pass_three(bg_typ, fg_typ);
X
X	if(join)
X	    join_map(bg_typ, fg_typ);
X
X	finish_map(fg_typ, bg_typ, (boolean)lit, (boolean)walled);
X	/* a walled, joined level is cavernous, not mazelike -dlc */
X	if (walled && join) {
X	    level.flags.is_maze_lev = FALSE;
X	    level.flags.is_cavernous_lev = TRUE;
X	}
X	free(new_locations);
X}
END_OF_FILE
if test 9999 -ne `wc -c <'src/mkmap.c'`; then
    echo shar: \"'src/mkmap.c'\" unpacked with wrong size!
fi
# end of 'src/mkmap.c'
fi
if test -f 'sys/mac/macfile.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/mac/macfile.c'\"
else
echo shar: Extracting \"'sys/mac/macfile.c'\" \(10224 characters\)
sed "s/^X//" >'sys/mac/macfile.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)macfile.c	3.1	93/01/24		  */
X/* Copyright (c) Jon W{tte, Hao-Yang Wang, Jonathan Handler 1992. */
X/* NetHack may be freely redistributed.  See license for details. */
X/*
X * macfile.c
X * MAC file I/O routines
X */
X
X#include "hack.h"
X
X#include <files.h>
X#include <errors.h>
X#include <resources.h>
X#include <memory.h>
X#include <ToolUtils.h>
X
X/*
X * We should get the default dirID and volRefNum (from name) from prefs and
X * the situation at startup... For now, this will have to do.
X */
X
X
X/* The HandleFiles are resources built into the application which are treated
X   as read-only files: if we fail to open a file we look for a resource */
X   
X#define FIRST_HF 32000   /* file ID of first HandleFile */
X#define MAX_HF 6		 /* Max # of open HandleFiles */
X
X#define APP_NAME_RES_ID		(-16396)
X#define PLAYER_NAME_RES_ID	1001
X
Xint FDECL(maccreat,(const char *, long));
Xint FDECL(macopen,(const char *, int, long));
Xint FDECL(macclose,(int));
Xint FDECL(macread,(int, void *, unsigned));
Xint FDECL(macwrite,(int, void *, unsigned));
Xlong FDECL(macseek,(int, long, short));
X
Xstatic short FDECL(IsHandleFile,(int));
Xstatic int FDECL(OpenHandleFile,(const unsigned char *, long));
Xstatic int FDECL(CloseHandleFile,(int));
Xstatic int FDECL(ReadHandleFile,(int, void *, unsigned));
Xstatic long FDECL(SetHandleFilePos,(int, short, long));
Xstatic void FDECL(C2P,(const char *, unsigned char *));
X
Xtypedef struct handlefile {
X	long		type ;  /* Resource type */
X	short		id ;	/* Resource id */
X	long		mark ;  /* Current position */
X	long		size ;  /* total size */
X	Handle		data ;  /* The resource, purgeable */
X} HandleFile ;
X
XHandleFile theHandleFiles [ MAX_HF ] ;
X
Xstatic short
XIsHandleFile ( int fd )
X{
X	return (fd >= FIRST_HF) && 
X		   (fd < FIRST_HF + MAX_HF) && 
X		   (theHandleFiles[ fd - FIRST_HF ].data) ;
X}
X
X
Xstatic int
XOpenHandleFile ( const unsigned char * name , long fileType )
X{
X	int i ;
X	OSErr err;
X	Handle h ;
X	Str255 s ;
X
X	for ( i = 0 ; i < MAX_HF ; i ++ ) {
X		if ( theHandleFiles[i].data == 0L ) break ;
X	}
X	
X	if ( i >= MAX_HF ) {
X		error("Ran out of HandleFiles");
X		return -1 ;
X	}
X
X	h = GetNamedResource ( fileType , name ) ;
X	err = ResError();
X	if (err == resNotFound) return -1;  /* Don't complain, this might be normal */
X	if ( ! itworked(err) ) return -1;
X	
X	theHandleFiles[i].data = h;
X	theHandleFiles[i].size = GetHandleSize ( h ) ;
X	GetResInfo ( h, & theHandleFiles[i].id, ( void* ) & theHandleFiles[i].type, s ) ;
X	theHandleFiles[i].mark = 0L ;
X
X	HPurge( h ) ;
X	return(i + FIRST_HF);
X}
X
X
Xstatic int
XCloseHandleFile ( int fd )
X{
X	if ( ! IsHandleFile ( fd ) ) {
X	   error("CloseHandleFile: isn't a handle");
X	   return -1 ;
X	}
X	fd -= FIRST_HF ;
X	ReleaseResource ( theHandleFiles[fd].data ) ;
X	theHandleFiles[fd].data = 0L ;
X	return(0);
X}
X
X
Xstatic int
XReadHandleFile ( int fd , void * ptr , unsigned len )
X{
X	unsigned maxBytes ;
X	Handle h ;
X
X	if ( ! IsHandleFile ( fd ) ) return -1;
X	
X	fd -= FIRST_HF ;
X	maxBytes = theHandleFiles[fd].size - theHandleFiles[fd].mark ;
X	if ( len > maxBytes ) len = maxBytes ;
X	
X	h = theHandleFiles[fd].data ;
X	LoadResource ( h ) ;
X	if ( ! itworked(ResError()) ) return (-1);
X	
X	HLock(h);
X	BlockMove ( *h , ptr , len );
X	HUnlock(h);
X	theHandleFiles[fd].mark += len ;
X
X/*	comment("ReadHandleFile ",len); */
X	
X	return(len);
X}
X
X
Xstatic long
XSetHandleFilePos ( int fd , short whence , long pos )
X{
X	long curpos;
X	
X	if ( ! IsHandleFile ( fd ) ) return -1;
X	
X	fd -= FIRST_HF ;
X	
X	curpos = theHandleFiles [ fd ].mark;
X	switch ( whence ) {
X	case SEEK_CUR : 
X		curpos += pos ;
X		break ;
X	case SEEK_END : 
X		curpos = theHandleFiles[fd].size  - pos ;
X		break ;
X	default : /* set */
X		curpos = pos ;
X		break ;
X	}
X
X	if ( curpos < 0 ) curpos = 0 ;
X	
X	if ( curpos > theHandleFiles [ fd ].size ) curpos = theHandleFiles [ fd ].size ;
X	
X	theHandleFiles [ fd ].mark = curpos;
X	
X	return curpos ;
X}
X
X
Xstatic void
XC2P ( const char * c , unsigned char * p )
X{
X	long len = strlen ( c ) ;
X
X	if ( len > 255 ) len = 255 ;
X
X	p[0] = len & 0xff ;
X	while (*c) *++p = *c++;
X}
X
Xstatic void
XP2C ( const unsigned char * p , char * c )
X{
X	int idx = p[0];
X	c[idx] = '\0';
X	while (idx > 0) {
X		c[idx-1] = p[idx];
X		--idx;
X	}
X}
X
X
Xstatic void
Xreplace_resource(Handle new_res, ResType its_type, short its_id,
X				 Str255 its_name) {
X	Handle old_res;
X	SetResLoad(false);
X	old_res = Get1Resource(its_type, its_id);
X	SetResLoad(true);
X	if (old_res) {
X		RmveResource(old_res);
X		DisposHandle(old_res);
X	}
X
X	AddResource(new_res, its_type, its_id, its_name);
X}
X
X
Xint
Xmaccreat ( const char * name , long fileType )
X{
X	return macopen ( name , O_RDWR | O_CREAT | O_TRUNC , fileType ) ;
X}
X
X
Xint
Xmacopen ( const char * name , int flags , long fileType )
X{
X	short refNum ;
X	short perm ;
X	Str255 s ;
X
X	C2P ( name , s ) ;
X	if ( flags & O_CREAT ) {
X		if ( HCreate ( theDirs.dataRefNum , theDirs.dataDirID , s ,
X			MAC_CREATOR , fileType ) && ( flags & O_EXCL ) ) {
X			return -1 ;
X		}
X
X		if (fileType == SAVE_TYPE) {
X			short resRef;
X			HCreateResFile(theDirs.dataRefNum, theDirs.dataDirID, s);
X			resRef = HOpenResFile(theDirs.dataRefNum, theDirs.dataDirID, s,
X								  fsRdWrPerm);
X			if (resRef != -1) {
X				Handle name;
X				Str255 plnamep;
X
X				C2P(plname, plnamep);
X				name = (Handle)NewString(plnamep);
X				if (name)
X					replace_resource(name, 'STR ', PLAYER_NAME_RES_ID,
X									"\pPlayer Name");
X
X				/* The application name resource.  See IM VI, page 9-21. */
X				name = (Handle)GetString(APP_NAME_RES_ID);
X				if (name) {
X					DetachResource(name);
X					replace_resource(name, 'STR ', APP_NAME_RES_ID,
X									 "\pApplication Name");
X				}
X
X				CloseResFile(resRef);
X			}
X		}
X
X	}
X	/*
X	 * Here, we should check for file type, maybe a SFdialog if
X	 * we fail with default, etc. etc. Besides, we should use HOpen
X	 * and permissions.
X	 */
X	if ( ( flags & O_RDONLY ) == O_RDONLY ) {
X		perm = fsRdPerm ;
X	}
X	if ( ( flags & O_WRONLY ) == O_WRONLY ) {
X		perm = fsWrPerm ;
X	}
X	if ( ( flags & O_RDWR ) == O_RDWR ) {
X		perm = fsRdWrPerm ;
X	}
X	if ( HOpen ( theDirs.dataRefNum , theDirs.dataDirID , s ,
X		perm , & refNum ) ) {
X		return OpenHandleFile ( s , fileType ) ;
X	}
X	if ( flags & O_TRUNC ) {
X		if ( SetEOF ( refNum , 0L ) ) {
X			FSClose ( refNum ) ;
X			return -1 ;
X		}
X	}
X	return refNum ;
X}
X
X
Xint
Xmacclose ( int fd )
X{
X	if ( IsHandleFile ( fd ) ) {
X		CloseHandleFile ( fd ) ;
X	} else {
X		if ( FSClose ( fd ) ) {
X			return -1 ;
X		}
X		FlushVol ( NULL , theDirs . dataRefNum ) ;
X	}
X	return 0 ;
X}
X
X
Xint
Xmacread ( int fd , void * ptr , unsigned len )
X{
X	long amt = len;
X	
X	if ( IsHandleFile ( fd ) ) {
X
X		return ReadHandleFile ( fd , ptr , amt ) ;
X	} else {
X
X		short err = FSRead ( fd , & amt , ptr ) ;
X		if ( err == eofErr && len ) {
X
X			return amt ;
X		}
X		if  ( itworked ( err ) ) {
X
X			return ( amt ) ;
X
X		} else {
X
X			return -1 ;
X		}
X	}
X}
X
X
Xint
Xmacwrite ( int fd , void * ptr , unsigned len )
X{
X	long amt = len ;
X
X	if ( IsHandleFile ( fd ) ) return -1 ;
X	
X	if ( itworked( FSWrite ( fd , & amt , ptr ) ) ) return(amt) ;
X		else return(-1) ;
X}
X
X
Xlong
Xmacseek ( int fd , long where , short whence )
X{
X	short posMode ;
X	long curPos ;
X
X	if ( IsHandleFile ( fd ) ) {
X		return SetHandleFilePos ( fd , whence , where ) ;
X	}
X
X	switch ( whence ) {
X	default :
X		posMode = fsFromStart ;
X		break ;
X	case SEEK_CUR :
X		posMode = fsFromMark ;
X		break ;
X	case SEEK_END :
X		posMode = fsFromLEOF ;
X		break ;
X	}
X
X	if ( itworked( SetFPos ( fd , posMode, where ) )  &&
X	     itworked( GetFPos ( fd , &curPos )) )
X		    return(curPos);
X	   
X	return(-1);
X}
X
X
Xstatic OSErr
Xcopy_file(short src_vol, long src_dir, short dst_vol, long dst_dir,
X		  Str255 fName,
X		  pascal OSErr (*opener)(short vRefNum, long dirID,
X								 ConstStr255Param fileName,
X								 char permission, short *refNum)) {
X	short src_ref, dst_ref;
X	OSErr err = (*opener)(src_vol, src_dir, fName, fsRdPerm, &src_ref);
X	if (err == noErr) {
X		err = (*opener)(dst_vol, dst_dir, fName, fsWrPerm, &dst_ref);
X		if (err == noErr) {
X
X			long file_len;
X			err = GetEOF(src_ref, &file_len);
X			if (err == noErr) {
X				Handle buf;
X				long count = MaxBlock();
X				if (count > file_len)
X					count = file_len;
X
X				buf = NewHandle(count);
X				err = MemError();
X				if (err == noErr) {
X
X					while (count > 0) {
X						OSErr rd_err = FSRead(src_ref, &count, *buf);
X						err = FSWrite(dst_ref, &count, *buf);
X						if (err == noErr)
X							err = rd_err;
X						file_len -= count;
X					}
X					if (file_len == 0)
X						err = noErr;
X
X					DisposHandle(buf);
X
X				}
X			}
X			FSClose(dst_ref);
X		}
X		FSClose(src_ref);
X	}
X
X	return err;
X}
X
Xstatic void
Xforce_hdelete(short vol, long dir, Str255 fName) {
X	HRstFLock(vol, dir, fName);
X	HDelete  (vol, dir, fName);
X}
X
Xvoid
Xfinder_file_request(void) {
X	short finder_msg, file_count;
X	CountAppFiles(&finder_msg, &file_count);
X	if (finder_msg == appOpen && file_count == 1) {
X		OSErr	err;
X		AppFile src;
X		short	src_vol;
X		long	src_dir, nul = 0;
X		GetAppFiles(1, &src);
X		err = GetWDInfo(src.vRefNum, &src_vol, &src_dir, &nul);
X		if (err == noErr && src.fType == SAVE_TYPE) {
X
X			if ( src_vol != theDirs.dataRefNum ||
X				 src_dir != theDirs.dataDirID &&
X				 CatMove(src_vol, src_dir, src.fName,
X						 theDirs.dataDirID, "\p:") != noErr) {
X
X				HCreate(theDirs.dataRefNum, theDirs.dataDirID, src.fName,
X						MAC_CREATOR, SAVE_TYPE);
X				err = copy_file(src_vol, src_dir, theDirs.dataRefNum,
X								theDirs.dataDirID, src.fName, &HOpen); /* HOpenDF is only there under 7.0 */
X				if (err == noErr)
X					err = copy_file(src_vol, src_dir, theDirs.dataRefNum,
X									theDirs.dataDirID, src.fName, &HOpenRF);
X				if (err == noErr)
X					force_hdelete(src_vol, src_dir, src.fName);
X				else
X					HDelete(theDirs.dataRefNum, theDirs.dataDirID, src.fName);
X			}
X
X			if (err == noErr) {
X				short ref = HOpenResFile(theDirs.dataRefNum, theDirs.dataDirID,
X										 src.fName, fsRdPerm);
X				if (ref != -1) {
X					Handle name = Get1Resource('STR ', PLAYER_NAME_RES_ID);
X					if (name) {
X
X						Str255 save_f_p;
X						P2C(*(StringHandle)name, plname);
X						set_savefile_name();
X						C2P(SAVEF, save_f_p);
X						force_hdelete(theDirs.dataRefNum, theDirs.dataDirID,
X									  save_f_p);
X						if (HRename(theDirs.dataRefNum, theDirs.dataDirID,
X									src.fName, save_f_p) == noErr)
X							ClrAppFiles(1);
X
X					}
X					CloseResFile(ref);
X				}
X			}
X		}
X	}
X}
END_OF_FILE
if test 10224 -ne `wc -c <'sys/mac/macfile.c'`; then
    echo shar: \"'sys/mac/macfile.c'\" unpacked with wrong size!
fi
# end of 'sys/mac/macfile.c'
fi
if test -f 'sys/msdos/msdos.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/msdos/msdos.c'\"
else
echo shar: Extracting \"'sys/msdos/msdos.c'\" \(9955 characters\)
sed "s/^X//" >'sys/msdos/msdos.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)msdos.c	 3.1	 93/01/05		  */
X/* Copyright (c) NetHack PC Development Team 1990, 1991, 1992	  */
X/* NetHack may be freely redistributed.  See license for details. */
X
X/*
X *  MSDOS system functions.
X *  Many thanks to Don Kneller who originated the DOS port and
X *  contributed much to the cause.
X */
X
X#define NEED_VARARGS
X#include "hack.h"
X#ifdef MICRO
X#include "termcap.h"
X#endif
X
X#ifdef MSDOS
X
X#include <dos.h>
X#include <ctype.h>
X
X/*
X * MS-DOS functions
X */
X#define DIRECT_INPUT    0x07    /* Unfiltered Character Input Without Echo */
X#define FATINFO     0x1B    /* Get Default Drive Data */
X/* MS-DOS 2.0+: */
X#define GETDTA      0x2F    /* Get DTA Address */
X#define FREESPACE   0x36    /* Get Drive Allocation Info */
X#define GETSWITCHAR 0x3700  /* Get Switch Character */
X#define FINDFIRST   0x4E    /* Find First File */
X#define FINDNEXT    0x4F    /* Find Next File */
X#define SETFILETIME 0x5701  /* Set File Date & Time */
X/*
X * BIOS interrupts
X */
X#define KEYBRD_BIOS 0x16
X#define VIDEO_BIOS  0x10
X/*
X * Keyboard BIOS functions
X */
X#define READCHAR    0x00    /* Read Character from Keyboard */
X#define GETKEYFLAGS 0x02    /* Get Keyboard Flags */
X/*
X * Video BIOS functions
X */
X#define SETCURPOS   0x02    /* Set Cursor Position */
X#define GETMODE     0x0f    /* Get Video Mode */
X#define FONTINFO    0x1130  /* Get Font Info */
X
X
X#ifdef OVL0
X
X/* direct bios calls are used only when flags.BIOS is set */
X
Xstatic char NDECL(DOSgetch);
Xstatic char NDECL(BIOSgetch);
Xstatic char * NDECL(getdta);
Xstatic unsigned int FDECL(dos_ioctl, (int,int,unsigned));
X
Xint
Xtgetch()
X{
X	char ch;
X
X	/* BIOSgetch can use the numeric key pad on IBM compatibles. */
X	if (flags.BIOS)
X		ch = BIOSgetch();
X	else
X		ch = DOSgetch();
X	return ((ch == '\r') ? '\n' : ch);
X}
X
X
X
X/*
X *  Keyboard translation tables.
X */
X#define KEYPADLO	0x47
X#define KEYPADHI	0x53
X
X#define PADKEYS 	(KEYPADHI - KEYPADLO + 1)
X#define iskeypad(x)	(KEYPADLO <= (x) && (x) <= KEYPADHI)
X
X/*
X * Keypad keys are translated to the normal values below.
X * When flags.BIOS is active, shifted keypad keys are translated to the
X *    shift values below.
X */
Xstatic const struct pad {
X	char normal, shift, cntrl;
X} keypad[PADKEYS] = {
X			{'y', 'Y', C('y')},		/* 7 */
X			{'k', 'K', C('k')},		/* 8 */
X			{'u', 'U', C('u')},		/* 9 */
X			{'m', C('p'), C('p')},		/* - */
X			{'h', 'H', C('h')},		/* 4 */
X			{'g', 'g', 'g'},		/* 5 */
X			{'l', 'L', C('l')},		/* 6 */
X			{'p', 'P', C('p')},		/* + */
X			{'b', 'B', C('b')},		/* 1 */
X			{'j', 'J', C('j')},		/* 2 */
X			{'n', 'N', C('n')},		/* 3 */
X			{'i', 'I', C('i')},		/* Ins */
X			{'.', ':', ':'}			/* Del */
X}, numpad[PADKEYS] = {
X			{'7', M('7'), '7'},		/* 7 */
X			{'8', M('8'), '8'},		/* 8 */
X			{'9', M('9'), '9'},		/* 9 */
X			{'m', C('p'), C('p')},		/* - */
X			{'4', M('4'), '4'},		/* 4 */
X			{'g', 'G', 'g'},		/* 5 */
X			{'6', M('6'), '6'},		/* 6 */
X			{'p', 'P', C('p')},		/* + */
X			{'1', M('1'), '1'},		/* 1 */
X			{'2', M('2'), '2'},		/* 2 */
X			{'3', M('3'), '3'},		/* 3 */
X			{'i', 'I', C('i')},		/* Ins */
X			{'.', ':', ':'}			/* Del */
X};
X
X/*
X * Unlike Ctrl-letter, the Alt-letter keystrokes have no specific ASCII
X * meaning unless assigned one by a keyboard conversion table, so the
X * keyboard BIOS normally does not return a character code when Alt-letter
X * is pressed.	So, to interpret unassigned Alt-letters, we must use a
X * scan code table to translate the scan code into a letter, then set the
X * "meta" bit for it.  -3.
X */
X#define SCANLO		0x10
X#define SCANHI		0x32
X#define SCANKEYS	(SCANHI - SCANLO + 1)
X#define inmap(x)	(SCANLO <= (x) && (x) <= SCANHI)
X
Xstatic const char scanmap[SCANKEYS] = { 	/* ... */
X	'q','w','e','r','t','y','u','i','o','p','[',']', '\n',
X	0, 'a','s','d','f','g','h','j','k','l',';','\'', '`',
X	0, '\\', 'z','x','c','v','b','N','m' 	/* ... */
X};
X
X/*
X * BIOSgetch gets keys directly with a BIOS call.
X */
X#define SHIFT		(0x1 | 0x2)
X#define CTRL		0x4
X#define ALT		0x8
X
Xstatic char
XBIOSgetch()
X{
X	unsigned char scan, shift, ch;
X	const struct pad *kpad;
X
X	union REGS regs;
X
X	/* Get scan code.
X	 */
X	regs.h.ah = READCHAR;
X	int86(KEYBRD_BIOS, &regs, &regs);
X	ch = regs.h.al;
X	scan = regs.h.ah;
X	/* Get shift status.
X	 */
X	regs.h.ah = GETKEYFLAGS;
X	int86(KEYBRD_BIOS, &regs, &regs);
X	shift = regs.h.al;
X
X	/* Translate keypad keys */
X	if (iskeypad(scan)) {
X		kpad = flags.num_pad ? numpad : keypad;
X		if (shift & SHIFT)
X			ch = kpad[scan - KEYPADLO].shift;
X		else if (shift & CTRL)
X			ch = kpad[scan - KEYPADLO].cntrl;
X		else
X			ch = kpad[scan - KEYPADLO].normal;
X	}
X	/* Translate unassigned Alt-letters */
X	if ((shift & ALT) && !ch) {
X		if (inmap(scan))
X			ch = scanmap[scan - SCANLO];
X		return (isprint(ch) ? M(ch) : ch);
X	}
X	return ch;
X}
X
Xstatic char
XDOSgetch()
X{
X	union REGS regs;
X	char ch;
X	struct pad (*kpad)[PADKEYS];
X
X	regs.h.ah = DIRECT_INPUT;
X	intdos(&regs, &regs);
X	ch = regs.h.al;
X
X	/*
X	 * The extended codes for Alt-shifted letters, and unshifted keypad
X	 * and function keys, correspond to the scan codes.  So we can still
X	 * translate the unshifted cursor keys and Alt-letters.  -3.
X	 */
X	if (ch == 0) {		/* an extended key */
X		regs.h.ah = DIRECT_INPUT;
X		intdos(&regs, &regs);	/* get the extended key code */
X		ch = regs.h.al;
X
X		if (iskeypad(ch)) {	/* unshifted keypad keys */
X			kpad = (void *)(flags.num_pad ? numpad : keypad);
X			ch = (*kpad)[ch - KEYPADLO].normal;
X		} else if (inmap(ch)) { /* Alt-letters */
X			ch = scanmap[ch - SCANLO];
X			if (isprint(ch)) ch = M(ch);
X		} else ch = 0;		/* munch it */
X	}
X	return (ch);
X}
X
Xchar
Xswitchar()
X{
X	union REGS regs;
X
X	regs.x.ax = GETSWITCHAR;
X	intdos(&regs, &regs);
X	return regs.h.dl;
X}
X
Xlong
Xfreediskspace(path)
Xchar *path;
X{
X	union REGS regs;
X
X	regs.h.ah = FREESPACE;
X	if (path[0] && path[1] == ':')
X		regs.h.dl = (toupper(path[0]) - 'A') + 1;
X	else
X		regs.h.dl = 0;
X	intdos(&regs, &regs);
X	if (regs.x.ax == 0xFFFF)
X		return -1L;		/* bad drive number */
X	else
X		return ((long) regs.x.bx * regs.x.cx * regs.x.ax);
X}
X
X#ifndef __GO32__
X/*
X * Functions to get filenames using wildcards
X */
Xint
Xfindfirst(path)
Xchar *path;
X{
X	union REGS regs;
X	struct SREGS sregs;
X
X	regs.h.ah = FINDFIRST;
X	regs.x.cx = 0;		/* attribute: normal files */
X	regs.x.dx = FP_OFF(path);
X	sregs.ds = FP_SEG(path);
X	intdosx(&regs, &regs, &sregs);
X	return !regs.x.cflag;
X}
X
Xint
Xfindnext() {
X	union REGS regs;
X
X	regs.h.ah = FINDNEXT;
X	intdos(&regs, &regs);
X	return !regs.x.cflag;
X}
X
Xchar *
Xfoundfile_buffer()
X{
X	return (getdta() + 30);
X}
X
X
X/* Get disk transfer area */
Xstatic char *
Xgetdta()
X{
X	union REGS regs;
X	struct SREGS sregs;
X	char *ret;
X
X	regs.h.ah = GETDTA;
X	intdosx(&regs, &regs, &sregs);
X#   ifdef MK_FP
X	ret = MK_FP(sregs.es, regs.x.bx);
X#   else
X	FP_OFF(ret) = regs.x.bx;
X	FP_SEG(ret) = sregs.es;
X#   endif
X	return ret;
X}
X
Xlong
Xfilesize(file)
Xchar *file;
X{
X	char *dta;
X
X	if (findfirst(file)) {
X		dta = getdta();
X		return  (* (long *) (dta + 26));
X	} else
X		return -1L;
X}
X
X#endif /* __GO32__ */
X
X/*
X * Chdrive() changes the default drive.
X */
Xvoid
Xchdrive(str)
Xchar *str;
X{
X#  define SELECTDISK	0x0E
X	char *ptr;
X	union REGS inregs;
X	char drive;
X
X	if ((ptr = index(str, ':')) != NULL) {
X		drive = toupper(*(ptr - 1));
X		inregs.h.ah = SELECTDISK;
X		inregs.h.dl = drive - 'A';
X		intdos(&inregs, &inregs);
X	}
X	return;
X}
X
X
X/* Use the IOCTL DOS function call to change stdin and stdout to raw
X * mode.  For stdin, this prevents MSDOS from trapping ^P, thus
X * freeing us of ^P toggling 'echo to printer'.
X * Thanks to Mark Zbikowski (markz@microsoft.UUCP).
X */
X
X#define DEVICE		0x80
X#define RAW		0x20
X#define IOCTL		0x44
X#define STDIN		fileno(stdin)
X#define STDOUT		fileno(stdout)
X#define GETBITS		0
X#define SETBITS		1
X
Xstatic unsigned	int old_stdin, old_stdout;
X
Xvoid
Xdisable_ctrlP()
X{
X
X	if (!flags.rawio) return;
X
X    old_stdin = dos_ioctl(STDIN, GETBITS, 0);
X    old_stdout = dos_ioctl(STDOUT, GETBITS, 0);
X	if (old_stdin & DEVICE)
X        dos_ioctl(STDIN, SETBITS, old_stdin | RAW);
X	if (old_stdout & DEVICE)
X        dos_ioctl(STDOUT, SETBITS, old_stdout | RAW);
X	return;
X}
X
Xvoid
Xenable_ctrlP()
X{
X	if (!flags.rawio) return;
X	if (old_stdin)
X        (void) dos_ioctl(STDIN, SETBITS, old_stdin);
X	if (old_stdout)
X        (void) dos_ioctl(STDOUT, SETBITS, old_stdout);
X	return;
X}
X
Xstatic unsigned int
Xdos_ioctl(handle, mode, setvalue)
Xint handle, mode;
Xunsigned setvalue;
X{
X	union REGS regs;
X
X	regs.h.ah = IOCTL;
X	regs.h.al = mode;
X	regs.x.bx = handle;
X	regs.h.dl = setvalue;
X	regs.h.dh = 0;			/* Zero out dh */
X	intdos(&regs, &regs);
X	return (regs.x.dx);
X}
X
X#endif /* OVL0 */
X#ifdef OVLB
X
Xvoid
Xget_scr_size()
X{
X	union REGS regs;
X
X	if (!flags.BIOS) {		/* assume standard screen size */
X		CO = 80;
X		LI = 24;
X		return;
X	}
X
X	regs.x.ax = FONTINFO;
X	regs.x.bx = 0;			/* current ROM BIOS font */
X	regs.h.dl = 24;			/* default row count */
X					/* in case no EGA/MCGA/VGA */
X	int86(VIDEO_BIOS, &regs, &regs); /* Get Font Information */
X
X	/* MDA/CGA/PCjr ignore INT 10h, Function 11h, but since we
X	 * cleverly loaded up DL with the default, everything's fine.
X	 *
X	 * Otherwise, DL now contains rows - 1.  Also, CX contains the
X	 * points (bytes per character) and ES:BP points to the font
X	 * table.  -3.
X	 */
X
X	regs.h.ah = GETMODE;
X	int86(VIDEO_BIOS, &regs, &regs); /* Get Video Mode */
X
X	/* This goes back all the way to the original PC.  Completely
X	 * safe.  AH contains # of columns, AL contains display mode,
X	 * and BH contains the active display page.
X	 */
X
X	LI = regs.h.dl + 1;
X	CO = regs.h.ah;
X}
X
X#endif /* OVLB */
X#ifdef OVL0
X
Xvoid
Xgotoxy(x,y)
Xint x,y;
X{
X	union REGS regs;
X
X	x--; y--;			/* (0,0) is upper right corner */
X
X	regs.h.ah = SETCURPOS;
X	regs.h.bh = 0;			/* display page */
X	regs.h.dh = y;			/* row */
X	regs.h.dl = x;			/* column */
X	int86(VIDEO_BIOS, &regs, &regs); /* Set Cursor Position */
X
X	/* This, too, goes back all the way to the original PC.  If
X	 * we ever get so fancy as to swap display pages (i doubt it),
X	 * then we'll need to set BH appropriately.  This function
X	 * returns nothing.  -3.
X	 */
X}
X
X#endif /* OVL0 */
X
X#endif /* MSDOS */
END_OF_FILE
if test 9955 -ne `wc -c <'sys/msdos/msdos.c'`; then
    echo shar: \"'sys/msdos/msdos.c'\" unpacked with wrong size!
fi
# end of 'sys/msdos/msdos.c'
fi
if test -f 'sys/vms/nethack.com' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/vms/nethack.com'\"
else
echo shar: Extracting \"'sys/vms/nethack.com'\" \(2378 characters\)
sed "s/^X//" >'sys/vms/nethack.com' <<'END_OF_FILE'
X$! NetHack.Com -- sample command procedure for invoking NetHack  9-JAN-1993
X$ v = 'f$verify(0)'
X$!
X$!    Possible command line arguments include
X$!	"-uConan-B"	!play a barbarian named Conan
X$!	"-u" "Merlin-W" !play a wizard named Merlin (slight variant of above)
X$!	"-e" or "-E"	!play an elf with default name (from environment
X$!			! [ie, NETHACKOPTIONS logical name] or VMS username)
X$!	"-a" or "-A", "-b" or "-B", "-c" or "-C", ... !specify character type
X$!			!note: "-s" is ambiguous between "play as a samurai"
X$!			!   vs "show scoreboard", so use "-S" for the former
X$!	"-x" or "-X"	!play in 'explore' mode (practice for beginners)
X$!	"-D"		!play in 'wizard' mode (for debugging, available only
X$!			! to the username compiled into nethack.exe as WIZARD)
X$!	"-dec"		!turn on DECgraphics mode (VT100 line drawing, done
X$!			! automatically below if appropriate term attribs set)
X$!	"-d" dir-path	!specify an alternate playground directory (not
X$!			! recommended; define HACKDIR instead)
X$!
X$
X$!
X$! assume this command procedure has been placed in the playground directory;
X$!	 get its device:[directory]
X$	hackdir = f$parse("_._;0",f$environ("PROCEDURE")) - "_._;0"
X$!
X$! hackdir should point to the 'playground' directory
X$ if f$trnlnm("HACKDIR").eqs."" then  define hackdir 'hackdir'
X$!
X$! termcap is a text file defining terminal capabilities and escape sequences
X$ if f$trnlnm("TERMCAP").eqs."" then  define termcap hackdir:termcap
X$!
X! [ obsolete:  now handled within nethack itself ]
X! $! prior to VMS v6, the C Run-Time Library doesn't understand vt420 :-(
X! $	  TT$_VT400_Series = 113
X! $ if f$getdvi("TT:","DEVTYPE").eq.TT$_VT400_Series -
X!  .and. f$trnlnm("NETHACK_TERM").eqs."" then  define nethack_term "vt400"
X$!
X$! use the VT100 line drawing character set if possible
X$ graphics = ""
X$	usropt = f$trnlnm("NETHACKOPTIONS")
X$	if usropt.eqs."" then  usropt = f$trnlnm("HACKOPTIONS")
X$ if f$locate("DECG",f$edit(usropt,"UPCASE")) .ge. f$length(usropt) then -
X    if f$getdvi("TT:","TT_DECCRT") .and. f$getdvi("TT:","TT_ANSICRT") then -
X$	graphics = " -dec"	!select DECgraphics mode by default
X$!
X$! get input from the terminal, not from this .com file
X$ deassign sys$input
X$!
X$	nethack := $hackdir:nethack
X$	if p1.nes."-s" .and. p1.nes."-s all" then -
X		nethack = nethack + graphics
X$ nethack "''p1'" "''p2'" "''p3'" "''p4'" "''p5'" "''p6'" "''p7'" "''p8'"
X$!
END_OF_FILE
if test 2378 -ne `wc -c <'sys/vms/nethack.com'`; then
    echo shar: \"'sys/vms/nethack.com'\" unpacked with wrong size!
fi
# end of 'sys/vms/nethack.com'
fi
if test -f 'win/X11/dialogs.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'win/X11/dialogs.c'\"
else
echo shar: Extracting \"'win/X11/dialogs.c'\" \(9983 characters\)
sed "s/^X//" >'win/X11/dialogs.c' <<'END_OF_FILE'
X/*
X * Copyright 1991 University of Wisconsin-Madison
X *
X * Permission to use, copy, modify, distribute, and sell this software and its
X * documentation for any purpose is hereby granted without fee, provided that
X * the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation, and that the name of the University of Wisconsin-Madison not
X * be used in advertising or publicity pertaining to distribution of the
X * software without specific, written prior permission.  The University of
X * Wisconsin-Madison makes no representations about the suitability of this
X * software for any purpose.  It is provided "as is" without express or
X * implied warranty.
X *
X * THE UNIVERSITY OF WISCONSIN-MADISON DISCLAIMS ALL WARRANTIES WITH REGARD TO
X * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
X * FITNESS, IN NO EVENT SHALL THE UNIVERSITY OF WISCONSIN-MADISON BE LIABLE FOR
X * ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
X * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
X * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
X * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
X *
X * Author:  Tim Theisen             Department of Computer Sciences
X *          tim@cs.wisc.edu         University of Wisconsin-Madison
X *          uwvax!tim               1210 West Dayton Street
X *          (608)262-0438           Madison, WI   53706
X *
X *
X * Modified 12/91 by Dean Luick.  Tim graciously donated this piece of code
X * from his program ghostview, an X11 front end for ghostscript.
X *
X *    + Make the cancel button optional.
X *    + Put an #ifdef SPECIAL_CMAP around code to fix a colormap bug.
X *	We don't need it here.
X *    + Add the function positionpopup() from another part of ghostview
X *	to this code.
X */
X
X#include <X11/Intrinsic.h>
X#include <X11/StringDefs.h>
X#include <X11/Xos.h>
X#include <X11/Xaw/Cardinals.h>
X#include <X11/Xaw/Form.h>
X#include <X11/Xaw/Label.h>
X#include <X11/Xaw/AsciiText.h>
X#include <X11/Xaw/Command.h>
X
X#include "config.h"	/* #define for const for non __STDC__ compilers */
X
X/* ":" added to both translations below to allow limited redefining of
X * keysyms before testing for keysym values -- dlc */
Xstatic const char okay_accelerators[] =
X    "#override\n\
X     :<Key>Return: set() notify() unset()\n";
X
Xstatic const char cancel_accelerators[] =
X    "#override\n\
X     :<Key>Escape: set() notify() unset()\n\
X     :<Ctrl>[: set() notify() unset()\n";	/* for keyboards w/o an ESC */
X
X
X/* Create a dialog widget.  It is just a form widget with
X *	a label prompt
X *	a text response
X *	an okay button
X *	an optional cancel button
X */
XWidget
XCreateDialog(parent, name, okay_callback, cancel_callback)
X    Widget parent;
X    String name;
X    XtCallbackProc okay_callback;
X    XtCallbackProc cancel_callback;
X{
X    Widget form, prompt, response, okay, cancel;
X    Arg args[20];
X    Cardinal num_args;
X
X							num_args = 0;
X#ifdef SPECIAL_CMAP
X    if (special_cmap) {
X	XtSetArg(args[num_args], XtNbackground, white);	num_args++;
X    }
X#endif
X    form = XtCreateManagedWidget(name, formWidgetClass, parent, args, num_args);
X
X							num_args = 0;
X#ifdef SPECIAL_CMAP
X    if (special_cmap) {
X	XtSetArg(args[num_args], XtNforeground, black);	num_args++;
X	XtSetArg(args[num_args], XtNbackground, white);	num_args++;
X    }
X#endif
X    XtSetArg(args[num_args], XtNtop, XtChainTop);	num_args++;
X    XtSetArg(args[num_args], XtNbottom, XtChainTop);	num_args++;
X    XtSetArg(args[num_args], XtNleft, XtChainLeft);	num_args++;
X    XtSetArg(args[num_args], XtNright, XtChainLeft);	num_args++;
X    XtSetArg(args[num_args], XtNresizable, True);	num_args++;
X    XtSetArg(args[num_args], XtNborderWidth, 0);	num_args++;
X    prompt = XtCreateManagedWidget("prompt", labelWidgetClass,
X				   form, args, num_args);
X
X							num_args = 0;
X#ifdef SPECIAL_CMAP
X    if (special_cmap) {
X	XtSetArg(args[num_args], XtNforeground, black);	num_args++;
X	XtSetArg(args[num_args], XtNbackground, white);	num_args++;
X    }
X#endif
X    XtSetArg(args[num_args], XtNfromVert, prompt);	num_args++;
X    XtSetArg(args[num_args], XtNtop, XtChainTop);	num_args++;
X    XtSetArg(args[num_args], XtNbottom, XtChainTop);	num_args++;
X    XtSetArg(args[num_args], XtNleft, XtChainLeft);	num_args++;
X    XtSetArg(args[num_args], XtNright, XtChainLeft);	num_args++;
X    XtSetArg(args[num_args], XtNresizable, True);	num_args++;
X    XtSetArg(args[num_args], XtNeditType, XawtextEdit);	num_args++;
X    XtSetArg(args[num_args], XtNresize, XawtextResizeWidth);	num_args++;
X    XtSetArg(args[num_args], XtNstring, "");		num_args++;
X    response = XtCreateManagedWidget("response", asciiTextWidgetClass,
X				     form, args, num_args);
X
X							num_args = 0;
X#ifdef SPECIAL_CMAP
X    if (special_cmap) {
X	XtSetArg(args[num_args], XtNforeground, black);	num_args++;
X	XtSetArg(args[num_args], XtNbackground, white);	num_args++;
X    }
X#endif
X    XtSetArg(args[num_args], XtNfromVert, response);	num_args++;
X    XtSetArg(args[num_args], XtNtop, XtChainTop);	num_args++;
X    XtSetArg(args[num_args], XtNbottom, XtChainTop);	num_args++;
X    XtSetArg(args[num_args], XtNleft, XtChainLeft);	num_args++;
X    XtSetArg(args[num_args], XtNright, XtChainLeft);	num_args++;
X    XtSetArg(args[num_args], XtNresizable, True);	num_args++;
X    XtSetArg(args[num_args], XtNaccelerators,
X	     XtParseAcceleratorTable(okay_accelerators));	num_args++;
X    okay = XtCreateManagedWidget("okay", commandWidgetClass,
X				 form, args, num_args);
X    XtAddCallback(okay, XtNcallback, okay_callback, form);
X
X    /* Only create cancel button if there is a callback for it. */
X    if (cancel_callback) {
X								num_args = 0;
X#ifdef SPECIAL_CMAP
X	if (special_cmap) {
X	    XtSetArg(args[num_args], XtNforeground, black);	num_args++;
X	    XtSetArg(args[num_args], XtNbackground, white);	num_args++;
X	}
X#endif
X	XtSetArg(args[num_args], XtNfromVert, response);	num_args++;
X	XtSetArg(args[num_args], XtNfromHoriz, okay);		num_args++;
X	XtSetArg(args[num_args], XtNtop, XtChainTop);		num_args++;
X	XtSetArg(args[num_args], XtNbottom, XtChainTop);	num_args++;
X	XtSetArg(args[num_args], XtNleft, XtChainLeft);		num_args++;
X	XtSetArg(args[num_args], XtNright, XtChainLeft);	num_args++;
X	XtSetArg(args[num_args], XtNresizable, True);		num_args++;
X	XtSetArg(args[num_args], XtNaccelerators,
X	     XtParseAcceleratorTable(cancel_accelerators));	num_args++;
X	cancel = XtCreateManagedWidget("cancel", commandWidgetClass,
X				       form, args, num_args);
X	XtAddCallback(cancel, XtNcallback, cancel_callback, form);
X	XtInstallAccelerators(response, cancel);
X    }
X
X    XtInstallAccelerators(response, okay);
X    XtSetKeyboardFocus(form, response);
X
X    return form;
X}
X
X#if 0
X/* get the prompt from the dialog box.  Used a startup time to
X * save away the initial prompt */
XString
XGetDialogPrompt(w)
X    Widget w;
X{
X    Arg args[1];
X    Widget label;
X    String s;
X
X    label = XtNameToWidget(w, "prompt");
X    XtSetArg(args[0], XtNlabel, &s);
X    XtGetValues(label, args, ONE);
X    return XtNewString(s);
X}
X#endif
X
X/* set the prompt.  This is used to put error information in the prompt */
Xvoid
XSetDialogPrompt(w, newprompt)
X    Widget w;
X    String newprompt;
X{
X    Arg args[1];
X    Widget label;
X
X    label = XtNameToWidget(w, "prompt");
X    XtSetArg(args[0], XtNlabel, newprompt);
X    XtSetValues(label, args, ONE);
X}
X
X/* get what the user typed */
XString
XGetDialogResponse(w)
X    Widget w;
X{
X    Arg args[1];
X    Widget response;
X    String s;
X
X    response = XtNameToWidget(w, "response");
X    XtSetArg(args[0], XtNstring, &s);
X    XtGetValues(response, args, ONE);
X    return XtNewString(s);
X}
X
X/* set the default reponse */
Xvoid
XSetDialogResponse(w, s)
X    Widget w;
X    String s;
X{
X    Arg args[3];
X    Widget response;
X    XFontStruct *font;
X    Dimension width, leftMargin, rightMargin;
X
X    response = XtNameToWidget(w, "response");
X    XtSetArg(args[0], XtNfont, &font);
X    XtSetArg(args[1], XtNleftMargin, &leftMargin);
X    XtSetArg(args[2], XtNrightMargin, &rightMargin);
X    XtGetValues(response, args, THREE);
X    width = font->max_bounds.width * strlen(s) + leftMargin + rightMargin;
X
X    XtSetArg(args[0], XtNstring, s);
X    XtSetArg(args[1], XtNwidth, width);
X    XtSetValues(response, args, TWO);
X    XawTextSetInsertionPoint(response, strlen(s));
X}
X
X#if 0
X/* clear the response */
Xvoid
XClearDialogResponse(w)
X    Widget w;
X{
X    Arg args[2];
X    Widget response;
X
X    response = XtNameToWidget(w, "response");
X    XtSetArg(args[0], XtNstring, "");
X    XtSetArg(args[1], XtNwidth, 100);
X    XtSetValues(response, args, TWO);
X}
X#endif
X
X
X/* Not a part of the original dialogs.c from ghostview --------------------- */
X
X/* position popup window under the cursor */
Xvoid
Xpositionpopup(w)
X    Widget w;
X{
X    Arg args[3];
X    Cardinal num_args;
X    Dimension width, height, b_width;
X    int x, y, max_x, max_y;
X    Window root, child;
X    int dummyx, dummyy;
X    unsigned int dummymask;
X    extern Widget toplevel;
X
X    /* following line deals with a race condition w/brain-damaged WM's -dlc */
X    XtUnrealizeWidget(w);
X
X    XQueryPointer(XtDisplay(toplevel), XtWindow(toplevel), &root, &child,
X		  &x, &y, &dummyx, &dummyy, &dummymask);
X    num_args = 0;
X    XtSetArg(args[num_args], XtNwidth, &width); num_args++;
X    XtSetArg(args[num_args], XtNheight, &height); num_args++;
X    XtSetArg(args[num_args], XtNborderWidth, &b_width); num_args++;
X    XtGetValues(w, args, num_args);
X
X    width += 2 * b_width;
X    height += 2 * b_width;
X
X    x -= ( (Position) width/2 );
X    if (x < 0) x = 0;
X    if ( x > (max_x = (Position) (XtScreen(w)->width - width)) ) x = max_x;
X
X    y -= ( (Position) height/2 );
X    if (y < 0) y = 0;
X    if ( y > (max_y = (Position) (XtScreen(w)->height - height)) ) y = max_y;
X
X    num_args = 0;
X    XtSetArg(args[num_args], XtNx, x); num_args++;
X    XtSetArg(args[num_args], XtNy, y); num_args++;
X    XtSetValues(w, args, num_args);
X}
END_OF_FILE
if test 9983 -ne `wc -c <'win/X11/dialogs.c'`; then
    echo shar: \"'win/X11/dialogs.c'\" unpacked with wrong size!
fi
# end of 'win/X11/dialogs.c'
fi
echo shar: End of archive 91 \(of 108\).
cp /dev/null ark91isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \
21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \
41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 \
61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 \
81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 \
101 102 103 104 105 106 107 108 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 108 archives.
    echo "Now execute 'rebuild.sh'"
    rm -f ark10[0-8]isdone ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
