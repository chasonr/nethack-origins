Path: uunet!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v16i077:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Part69/108
Message-ID: <4380@master.CNA.TEK.COM>
Date: 1 Feb 93 19:51:51 GMT
Sender: news@master.CNA.TEK.COM
Lines: 1869
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1627

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 16, Issue 77
Archive-name: nethack31/Part69
Supersedes: nethack3p9: Volume 10, Issue 46-102
Environment: Amiga, Atari, Mac, MS-DOS, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 69 (of 108)."
# Contents:  src/monmove.c sys/msdos/MakeMSC.src
# Wrapped by billr@saab on Wed Jan 27 16:09:14 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'src/monmove.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/monmove.c'\"
else
echo shar: Extracting \"'src/monmove.c'\" \(30715 characters\)
sed "s/^X//" >'src/monmove.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)monmove.c	3.1	92/12/06	*/
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include "hack.h"
X#include "mfndpos.h"
X#include "artifact.h"
X
X#ifdef OVL0
X
Xstatic int FDECL(disturb,(struct monst *));
Xstatic void FDECL(distfleeck,(struct monst *,int *,int *,int *));
X
X#endif /* OVL0 */
X#ifdef OVL1
X
XSTATIC_OVL boolean FDECL(mdig_tunnel,(struct monst *));
X
X#endif /* OVL1 */
X#ifdef OVLB
X
Xboolean /* TRUE : mtmp died */
Xmb_trapped(mtmp)
Xregister struct monst *mtmp;
X{
X	if (flags.verbose) {
X	    if (cansee(mtmp->mx, mtmp->my))
X	       pline("KABOOM!!  You see a door explode.");
X	    else if (flags.soundok)
X               You("hear a distant explosion.");
X	}
X	mtmp->mstun = 1;
X	mtmp->mhp -= rnd(15);
X	if(mtmp->mhp <= 0) {
X		mondied(mtmp);
X		return(TRUE);
X	}
X	return(FALSE);
X}
X
X#endif /* OVLB */
X#ifdef OVL1
X
X/* Return TRUE if monster died, FALSE otherwise. */
XSTATIC_OVL boolean
Xmdig_tunnel(mtmp)
Xregister struct monst *mtmp;
X{
X	register struct rm *here;
X	register int pile;
X
X	here = &levl[mtmp->mx][mtmp->my];
X	if (here->typ == SDOOR) here->typ = DOOR;
X
X	/* Eats away door if present & closed or locked */
X	if(closed_door(mtmp->mx, mtmp->my)) {
X	    if (*in_rooms(mtmp->mx, mtmp->my, SHOPBASE))
X		add_damage(mtmp->mx, mtmp->my, 0L);
X	    unblock_point(mtmp->mx,mtmp->my);	/* vision */
X	    if(here->doormask & D_TRAPPED) {
X		here->doormask = D_NODOOR;
X		if(mb_trapped(mtmp)) {	/* mtmp is killed */
X		    newsym(mtmp->mx,mtmp->my);
X		    return TRUE;
X		}
X	    } else {
X		if(!rn2(3) && flags.verbose)	/* not too often.. */
X		    You("feel an unexpected draft of air.");
X		here->doormask = D_BROKEN;
X	    }
X	    newsym(mtmp->mx,mtmp->my);
X	    return FALSE;
X	} else
X	if (!IS_ROCK(here->typ)) /* no dig */
X	    return(FALSE);
X
X	/* Only rock and walls fall through to this point. */
X	if ((here->diggable & W_NONDIGGABLE)) {
X	    impossible("mdig_tunnel:  %s at (%d,%d) is undiggable",
X		       (IS_WALL(here->typ) ? "wall" : "stone"),
X		       (int) mtmp->mx, (int) mtmp->my);
X		return FALSE;	/* still alive */
X	}
X
X	if(IS_WALL(here->typ)) {
X	    if(flags.soundok && flags.verbose && !rn2(5))
X		You("hear the sound of crashing rock.");
X	    if (*in_rooms(mtmp->mx, mtmp->my, SHOPBASE))
X	    	add_damage(mtmp->mx, mtmp->my, 0L);
X	    if (level.flags.is_maze_lev) {
X		here->typ = ROOM;
X	    } else if (level.flags.is_cavernous_lev) {
X		here->typ = CORR;
X	    } else {
X		here->typ = DOOR;
X		here->doormask = D_NODOOR;
X	    }
X	} else	
X	    here->typ = CORR;
X
X	pile = rnd(12);
X	if(pile < 5)	/* leave behind some rocks? */
X		(void) mksobj_at((pile == 1)? BOULDER : ROCK, 
X				 mtmp->mx, mtmp->my, TRUE);
X	newsym(mtmp->mx,mtmp->my);
X	if(sobj_at(BOULDER, mtmp->mx, mtmp->my) == (struct obj *)0)
X	    unblock_point(mtmp->mx,mtmp->my);	/* vision */
X	return FALSE ;
X}
X
Xint
Xdochugw(mtmp)
X	register struct monst *mtmp;
X{
X	register int x = mtmp->mx;
X	register int y = mtmp->my;
X	register int rd = dochug(mtmp);
X	register int dd;
X
X	if(Warning && !rd && !mtmp->mpeaceful &&
X			(dd = distu(mtmp->mx,mtmp->my)) < distu(x,y) &&
X			dd < 100 && !canseemon(mtmp)) {
X	    /* Note: this assumes we only want to warn against the monster to
X	     * which the weapon does extra damage, as there is no "monster
X	     * which the weapon warns against" field.
X	     */
X	    if(spec_ability(uwep,SPFX_WARN) && spec_dbon(uwep,mtmp->data,1))
X		warnlevel = 100;
X	    else if ((int) (mtmp->m_lev / 4) > warnlevel)
X		warnlevel = (mtmp->m_lev / 4);
X	}
X	/* check whether hero notices monster and stops current activity */
X	if (occupation && !rd && !Confusion &&
X	    (!mtmp->mpeaceful || Hallucination) &&
X	    canseemon(mtmp) && !cansee(x,y) &&
X	    distu(mtmp->mx,mtmp->my) <= (BOLT_LIM+1)*(BOLT_LIM+1))
X		stop_occupation();
X
X	return(rd);
X}
X
X#endif /* OVL1 */
X#ifdef OVL2
X
Xboolean
Xonscary(x, y, mtmp)
Xint x, y;
Xstruct monst *mtmp;
X{
X	if (mtmp->isshk || mtmp->isgd || mtmp->iswiz || !mtmp->mcansee ||
X			is_lminion(mtmp->data) || is_rider(mtmp->data) ||
X			mtmp->data->mlet == S_HUMAN || mtmp->mpeaceful ||
X			mtmp->data == &mons[PM_MINOTAUR])
X		return(FALSE);
X	return(
X#ifdef ELBERETH
X		   sengr_at("Elbereth", x, y) ||
X#endif
X		    sobj_at(SCR_SCARE_MONSTER, x, y) != (struct obj *)0);
X}
X
X#endif /* OVL2 */
X#ifdef OVL0
X
X/*
X * Possibly awaken the given monster.  Return a 1 if the monster has been
X * jolted awake.
X */
Xstatic int
Xdisturb(mtmp)
X	register struct monst *mtmp;
X{
X	/*
X	 * + Ettins are hard to surprise.
X	 * + Nymphs, jabberwocks, and leprechauns do not easily wake up.
X	 *
X	 * Wake up if:
X	 *	in direct LOS						AND
X	 *	within 10 squares					AND
X	 *	not stealthy or (mon is an ettin and 9/10)		AND
X	 *	(mon is not a nymph, jabberwock, or leprechaun) or 1/50	AND
X	 *	Aggravate or mon is (dog or human) or
X	 *	    (1/7 and mon is not mimicing furniture or object)
X	 */
X	if(couldsee(mtmp->mx,mtmp->my) &&
X		distu(mtmp->mx,mtmp->my) <= 100 &&
X		(!Stealth || (mtmp->data == &mons[PM_ETTIN] && rn2(10))) &&
X		(!(mtmp->data->mlet == S_NYMPH
X			|| mtmp->data == &mons[PM_JABBERWOCK]
X			|| mtmp->data->mlet == S_LEPRECHAUN) || !rn2(50)) &&
X		(Aggravate_monster
X			|| (mtmp->data->mlet == S_DOG ||
X				mtmp->data->mlet == S_HUMAN)
X			|| (!rn2(7) && mtmp->m_ap_type != M_AP_FURNITURE &&
X				mtmp->m_ap_type != M_AP_OBJECT) )) {
X
X		mtmp->msleep = 0;
X		return(1);
X	}
X	return(0);
X}
X
Xstatic void
Xdistfleeck(mtmp,inrange,nearby,scared)
Xregister struct monst *mtmp;
Xint *inrange, *nearby, *scared;
X{
X	int seescaryx, seescaryy;
X
X	*inrange = (dist2(mtmp->mx, mtmp->my, mtmp->mux, mtmp->muy) <=
X							(BOLT_LIM * BOLT_LIM));
X	*nearby = *inrange && monnear(mtmp, mtmp->mux, mtmp->muy);
X
X	/* Note: if your image is displaced, the monster sees the Elbereth
X	 * at your displaced position, thus never attacking your displaced
X	 * position, but possibly attacking you by accident.  If you are
X	 * invisible, it sees the Elbereth at your real position, thus never
X	 * running into you by accident but possibly attacking the spot
X	 * where it guesses you are.
X	 */
X	if (Invis && !perceives(mtmp->data)) {
X		seescaryx = mtmp->mux;
X		seescaryy = mtmp->muy;
X	} else {
X		seescaryx = u.ux;
X		seescaryy = u.uy;
X	}
X	*scared = (*nearby && (onscary(seescaryx, seescaryy, mtmp) ||
X			       (!mtmp->mpeaceful &&
X				    in_your_sanctuary(mtmp->mx, mtmp->my))));
X
X	if(*scared && !mtmp->mflee) {
X#ifdef POLYSELF
X		if (!sticks(uasmon))
X#endif
X			unstuck(mtmp);	/* monster lets go when fleeing */
X		mtmp->mflee = 1;
X#ifdef STUPID
X		if (rn2(7))
X		    mtmp->mfleetim = rnd(10);
X		else
X		    mtmp->mfleetim = rnd(100);
X#else
X		mtmp->mfleetim = rnd(rn2(7) ? 10 : 100);
X#endif
X	}
X
X}
X
X/* returns 1 if monster died moving, 0 otherwise */
X/* The whole dochugw/m_move/distfleeck/mfndpos section is serious spaghetti
X * code. --KAA
X */
Xint
Xdochug(mtmp)
Xregister struct monst *mtmp;
X{
X	register struct permonst *mdat = mtmp->data;
X	register int tmp=0;
X	int inrange, nearby, scared;
X
X/*	Pre-movement adjustments	*/
X
X	if(mtmp->cham && !rn2(6))	/* polymorph chameleons */
X	    (void) newcham(mtmp, (struct permonst *)0);
X
X	/* regenerate monsters */
X	if (mtmp->mhp < mtmp->mhpmax && (!(moves%20) || regenerates(mdat)))
X		mtmp->mhp++;
X	if(mtmp->mspec_used) mtmp->mspec_used--;
X
X	/* polymorph lycanthropes */
X	were_change(mtmp);
X
X	/* check for waitmask status change */
X	if((mtmp->data->mflags3 & M3_WAITFORU) &&
X	   (m_canseeu(mtmp) || mtmp->mhp < mtmp->mhpmax))
X	    mtmp->data->mflags3 &= ~M3_WAITFORU;
X
X#ifdef MULDGN
X	/* update quest status flags */
X	quest_stat_check(mtmp);
X#endif
X
X	if(!mtmp->mcanmove || (mtmp->data->mflags3 & M3_WAITMASK)) {
X	    if (Hallucination) newsym(mtmp->mx,mtmp->my);
X#ifdef MULDGN
X	    if(mtmp->mcanmove && (mtmp->data->mflags3 & M3_CLOSE) &&
X	       !mtmp->msleep && monnear(mtmp, u.ux, u.uy))
X		quest_talk(mtmp);	/* give the leaders a chance to speak */
X#endif
X	    return(0);	/* other frozen monsters can't do anything */
X	}
X
X	/* there is a chance we will wake it */
X	if(mtmp->msleep && !disturb(mtmp)) {
X		if (Hallucination) newsym(mtmp->mx,mtmp->my);
X		return(0);
X	}
X
X	/* not frozen or sleeping: wipe out texts written in the dust */
X	wipe_engr_at(mtmp->mx, mtmp->my, 1);
X
X	/* confused monsters get unconfused with small probability */
X	if(mtmp->mconf && !rn2(50)) mtmp->mconf = 0;
X
X	/* stunned monsters get un-stunned with larger probability */
X	if(mtmp->mstun && !rn2(10)) mtmp->mstun = 0;
X
X	/* some monsters teleport */
X	if(mtmp->mflee && !rn2(40) && can_teleport(mdat) && !mtmp->iswiz) {
X		rloc(mtmp);
X		return(0);
X	}
X	if(mdat->msound == MS_SHRIEK && !um_dist(mtmp->mx, mtmp->my, 1))
X	    m_respond(mtmp);
X	if(mdat->mmove < rnd(6)) return(0);
X
X	/* fleeing monsters might regain courage */
X	if(mtmp->mflee && !mtmp->mfleetim
X	   && mtmp->mhp == mtmp->mhpmax && !rn2(25)) mtmp->mflee = 0;
X
X	set_apparxy(mtmp);
X	/* Must be done after you move and before the monster does.  The
X	 * set_apparxy() call in m_move() doesn't suffice since the variables
X	 * inrange, etc. all depend on stuff set by set_apparxy().
X	 */
X
X	/* Monsters that want to acquire things */
X	/* may teleport, so do it before inrange is set */
X	if(is_covetous(mtmp->data)) (void) tactics(mtmp);
X
X	/* check distance and scariness of attacks */
X	distfleeck(mtmp,&inrange,&nearby,&scared);
X
X#ifdef MUSE
X	if(find_defensive(mtmp)) {
X		if (use_defensive(mtmp) != 0)
X			return 1;
X	} else if(find_misc(mtmp)) {
X		if (use_misc(mtmp) != 0)
X			return 1;
X	}
X#endif
X
X	/* Demonic Blackmail! */
X	if(nearby && mdat->msound == MS_BRIBE &&
X	   mtmp->mpeaceful && !mtmp->mtame) {
X		if (mtmp->mux != u.ux || mtmp->muy != u.uy) {
X			pline("%s whispers something to thin air.",
X			    cansee(mtmp->mux, mtmp->muy) ? Monnam(mtmp) : "It");
X#ifdef POLYSELF
X			if (is_demon(uasmon)) rloc(mtmp);
X			  /* "Good hunting, brother" */
X			else {
X#endif
X			    mtmp->minvis = 0;
X			    /* Why?  For the same reason in real demon talk */
X			    pline("%s gets angry.", Amonnam(mtmp));
X			    mtmp->mpeaceful = 0;
X			    /* since no way is an image going to pay it off */
X#ifdef POLYSELF
X			}
X#endif
X		} else if(demon_talk(mtmp)) return(1);	/* you paid it off */
X	}
X
X	if (mdat == &mons[PM_MIND_FLAYER] && !rn2(20)) {
X		struct monst *m2, *nmon = (struct monst *)0;
X
X		if (canseemon(mtmp))
X			pline("%s concentrates.", Monnam(mtmp));
X		if (distu(mtmp->mx, mtmp->my) > BOLT_LIM * BOLT_LIM) {
X			You("sense a faint wave of psychic energy.");
X			goto toofar;
X		}
X		You("sense a wave of psychic energy pouring over you!");
X		if (mtmp->mpeaceful &&
X		    (!Conflict || resist(mtmp, RING_CLASS, 0, 0)))
X			pline("It seems quite soothing.");
X		else {
X			register boolean m_sen = sensemon(mtmp);
X
X			if (m_sen || (Telepat && rn2(2)) || !rn2(10)) {
X				int dmg;
X				pline("It locks in on your %s!",
X					m_sen ? "telepathy" :
X					Telepat ? "latent telepathy" : "mind");
X				dmg = rnd(15);
X				if (Half_spell_damage) dmg = (dmg+1) / 2;
X				losehp(dmg, "psychic blast", KILLED_BY_AN);
X			}
X		}
X		for(m2=fmon; m2; m2 = nmon) {
X			nmon = m2->nmon;
X			if (m2->mpeaceful != mtmp->mpeaceful) continue;
X			if (mindless(m2->data)) continue;
X			if (m2 == mtmp) continue;
X			if ((telepathic(m2->data) &&
X			    (rn2(2) || m2->mblinded)) || !rn2(10)) {
X				if (cansee(m2->mx, m2->my))
X				    pline("It locks in on %s.", mon_nam(m2));
X				m2->mhp -= rnd(15);
X				if (m2->mhp <= 0)
X				    monkilled(m2, "", AD_DRIN);
X			}
X		}
X	}
Xtoofar:
X#ifdef MUSE
X	/* If monster is nearby you, and has to wield a weapon, do so.   This
X	 * costs the monster a move, of course.
X	 */
X	if((!mtmp->mpeaceful || Conflict) && inrange &&
X	   dist2(mtmp->mx, mtmp->my, mtmp->mux, mtmp->muy) <= 8
X	   && attacktype(mdat, AT_WEAP)) {
X	    if (mtmp->weapon_check == NEED_WEAPON || !MON_WEP(mtmp)) {
X		mtmp->weapon_check = NEED_HTH_WEAPON;
X		if (mon_wield_item(mtmp) != 0) return(0);
X	    }
X	}
X#endif
X/*	Now the actual movement phase	*/
X
X	if(!nearby || mtmp->mflee || scared ||
X	   mtmp->mconf || mtmp->mstun || (mtmp->minvis && !rn2(3)) ||
X	   (mdat->mlet == S_LEPRECHAUN && !u.ugold && (mtmp->mgold || rn2(2))) ||
X	   (is_wanderer(mdat) && !rn2(4)) || (Conflict && !mtmp->iswiz) ||
X	   (!mtmp->mcansee && !rn2(4)) || mtmp->mpeaceful) {
X
X		tmp = m_move(mtmp, 0);
X		distfleeck(mtmp,&inrange,&nearby,&scared);	/* recalc */
X
X		switch (tmp) {
X
X		    case 0:	/* no movement, but it can still attack you */
X		    case 3:	/* absolutely no movement */
X				/* for pets, case 0 and 3 are equivalent */
X 			/* During hallucination, monster appearance should
X 			 * still change - even if it doesn't move.
X  			 */
X 			if(Hallucination) newsym(mtmp->mx,mtmp->my);
X 			break;
X 		    case 1:	/* monster moved */
X			/* Maybe it stepped on a trap and fell asleep... */
X			if(mtmp->msleep || !mtmp->mcanmove) return(0);
X 			if(!nearby && ranged_attk(mdat)) break;
X 			else if(mdat->mmove <= 12) {
X			    /* a monster that's digesting you can move at the
X			     * same time -dlc
X			     */
X			    if(u.uswallow && mtmp == u.ustuck)
X				return(mattacku(mtmp));
X			    return(0);
X			}
X 			break;
X 		    case 2:	/* monster died */
X 			return(1);
X 		}
X	}
X
X/*	Now, attack the player if possible - one attack set per monst	*/
X
X	if (!mtmp->mpeaceful ||
X	    (Conflict && !resist(mtmp, RING_CLASS, 0, 0))) {
X	    if(inrange && !noattacks(mdat) && u.uhp > 0 && !scared && tmp != 3)
X		if(mattacku(mtmp)) return(1); /* monster died (e.g. exploded) */
X
X	    if(mtmp->wormno) wormhitu(mtmp);
X	}
X#ifdef MULDGN
X	/* special speeches for quest monsters */
X	if(!mtmp->msleep && mtmp->mcanmove && nearby)
X		quest_talk(mtmp);
X	else
X#endif
X	    /* extra emotional attack for vile monsters */
X	    if(inrange && mtmp->data->msound == MS_CUSS && !mtmp->mpeaceful &&
X	       couldsee(mtmp->mx, mtmp->my) && !mtmp->minvis && !rn2(5))
X		cuss(mtmp);
X
X	/* extra movement for fast monsters */
X	if(mdat->mmove-12 > rnd(12)) tmp = m_move(mtmp, 1);
X	return(tmp == 2);
X}
X
Xstatic const char NEARDATA practical[] = { WEAPON_CLASS, ARMOR_CLASS, GEM_CLASS, FOOD_CLASS, 0 };
Xstatic const char NEARDATA magical[] = {
X	AMULET_CLASS, POTION_CLASS, SCROLL_CLASS, WAND_CLASS, RING_CLASS,
X	SPBOOK_CLASS, 0 };
Xstatic const char NEARDATA indigestion[] = { BALL_CLASS, ROCK_CLASS, 0 };
X
X#ifdef POLYSELF
Xboolean
Xitsstuck(mtmp)
Xregister struct monst *mtmp;
X{
X	if (sticks(uasmon) && mtmp==u.ustuck && !u.uswallow) {
X		pline("%s cannot escape from you!", Monnam(mtmp));
X		return(TRUE);
X	}
X	return(FALSE);
X}
X#endif
X
Xint
Xm_move(mtmp, after)
Xregister struct monst *mtmp;
Xregister int after;
X{
X	register int appr;
X	xchar gx,gy,nix,niy,chcnt;
X	int chi;	/* could be schar except for stupid Sun-2 compiler */
X	boolean likegold=0, likegems=0, likeobjs=0, likemagic=0, conceals=0;
X	boolean likerock=0, can_tunnel=0;
X	boolean can_open=0, can_unlock=0, doorbuster=0;
X#ifdef MUSE
X	boolean uses_items=0;
X#endif
X	struct permonst *ptr;
X	schar mmoved = 0;	/* not strictly nec.: chi >= 0 will do */
X	long info[9];
X	long flag;
X	int  omx = mtmp->mx, omy = mtmp->my;
X#ifdef MUSE
X	struct obj *mw_tmp;
X#endif
X
X	if(mtmp->mtrapped) {
X	    int i = mintrap(mtmp);
X	    if(i >= 2) { newsym(mtmp->mx,mtmp->my); return(2); }/* it died */
X	    if(i == 1) return(0);	/* still in trap, so didn't move */
X	}
X	ptr = mtmp->data; /* mintrap() can change mtmp->data -dlc */
X	if(hides_under(ptr) && OBJ_AT(mtmp->mx, mtmp->my) && rn2(10))
X	    return(0);		/* do not leave hiding place */
X	if(mtmp->meating) {
X	    mtmp->meating--;
X	    return(3);			/* still eating */
X	}
X
X	set_apparxy(mtmp);
X	/* where does mtmp think you are? */
X	/* Not necessary if m_move called from this file, but necessary in
X	 * other calls of m_move (ex. leprechauns dodging)
X	 */
X	can_tunnel = tunnels(ptr) &&
X#ifdef REINCARNATION
X	    !Is_rogue_level(&u.uz) &&
X#endif
X#ifdef MUSE
X		(!needspick(ptr) ||
X		 (m_carrying(mtmp, PICK_AXE) &&
X		  (mtmp->weapon_check != NO_WEAPON_WANTED ||
X		   !(mw_tmp = MON_WEP(mtmp)) || mw_tmp->otyp == PICK_AXE)));
X#else
X		(!needspick(ptr) || m_carrying(mtmp, PICK_AXE));
X#endif
X	can_open = !(nohands(ptr) || verysmall(ptr));
X	can_unlock = ((can_open && m_carrying(mtmp, SKELETON_KEY)) || mtmp->iswiz);
X	doorbuster = is_giant(ptr);
X	if(mtmp->wormno) goto not_special;
X	/* my dog gets special treatment */
X	if(mtmp->mtame) {
X	    mmoved = dog_move(mtmp, after);
X	    goto postmov;
X	}
X
X	/* likewise for shopkeeper */
X	if(mtmp->isshk) {
X	    mmoved = shk_move(mtmp);
X	    if(mmoved == -2) return(2);
X	    if(mmoved >= 0) goto postmov;
X	    mmoved = 0;		/* follow player outside shop */
X	}
X
X	/* and for the guard */
X	if(mtmp->isgd) {
X	    mmoved = gd_move(mtmp);
X	    if(mmoved == -2) return(2);
X	    if(mmoved >= 0) goto postmov;
X	    mmoved = 0;
X	}
X
X	/* and the acquisitive monsters get special treatment */
X	if(is_covetous(ptr)) {
X	    xchar tx = (xchar)((mtmp->mstrategy >> 16) & 0xff),
X		  ty = (xchar)((mtmp->mstrategy >> 8) & 0xff);
X	    struct monst *intruder = m_at(tx, ty);
X	    /*
X	     * if there's a monster on the object or in possesion of it,
X	     * attack it.
X	     */
X	    if((dist2(mtmp->mx, mtmp->my, tx, ty) < 2) &&
X	       intruder && (intruder != mtmp)) {
X
X		if(mattackm(mtmp, intruder) == 2) return(2);
X		mmoved = 1;
X	    } else mmoved = 0;
X	    goto postmov;
X	}
X
X	/* and for the priest */
X	if(mtmp->ispriest) {
X	    mmoved = pri_move(mtmp);
X	    if(mmoved == -2) return(2);
X	    if(mmoved >= 0) goto postmov;
X	    mmoved = 0;
X	}
X
X#ifdef MAIL
X	if(ptr == &mons[PM_MAIL_DAEMON]) {
X	    if(flags.soundok && canseemon(mtmp))
X		verbalize("I'm late!");
X	    mongone(mtmp);
X	    return(2);	    
X	}
X#endif
X
X	/* teleport if that lies in our nature */
X	if(ptr == &mons[PM_TENGU] && !rn2(5) && !mtmp->mcan) {
X	    if(mtmp->mhp < 7 || mtmp->mpeaceful || rn2(2))
X		rloc(mtmp);
X	    else
X		mnexto(mtmp);
X	    mmoved = 1;
X	    goto postmov;
X	}
Xnot_special:
X	if(u.uswallow && !mtmp->mflee && u.ustuck != mtmp) return(1);
X	appr = 1;
X	omx = mtmp->mx;
X	omy = mtmp->my;
X	gx = mtmp->mux;
X	gy = mtmp->muy;
X	if(mtmp->mflee) appr = -1;
X	if (mtmp->mconf || (u.uswallow && mtmp == u.ustuck))
X		appr = 0;
X	else {
X		boolean should_see = (couldsee(omx, omy) && 	
X  			  	      (levl[gx][gy].lit || 
X				       !levl[omx][omy].lit) &&
X				      (dist2(omx, omy, gx, gy) <= 36));
X
X		if (!mtmp->mcansee || 
X	    	    (should_see && Invis && !perceives(ptr)) || 
X#ifdef POLYSELF
X	            (u.usym == S_MIMIC_DEF) || u.uundetected ||
X#endif
X	            (mtmp->mpeaceful && !mtmp->isshk) ||  /* allow shks to follow */
X	            ((ptr->mlet == S_STALKER || ptr->mlet == S_BAT ||
X		      ptr->mlet == S_LIGHT) && !rn2(3)))
X			appr = 0;  
X	
X	    	if(monsndx(ptr) == PM_LEPRECHAUN && (appr == 1) && 
X	           (mtmp->mgold > u.ugold))
X			appr = -1;
X
X		if (!should_see && can_track(ptr)) {
X			register coord *cp;
X
X			cp = gettrack(omx,omy);
X			if (cp) {
X		    		gx = cp->x;
X		    		gy = cp->y;
X			}
X		}
X	}
X
X#ifdef REINCARNATION
X	if (!Is_rogue_level(&u.uz))
X#endif
X	{
X		register int pctload = (curr_mon_load(mtmp) * 100) /
X			max_mon_load(mtmp);
X
X		/* look for gold or jewels nearby */
X		likegold = (likes_gold(ptr) && pctload < 95);
X		likegems = (likes_gems(ptr) && pctload < 85);
X#ifdef MUSE
X		uses_items = (!mindless(ptr) && !is_animal(ptr)
X			&& pctload < 75);
X#endif
X		likeobjs = (likes_objs(ptr) && pctload < 75);
X		likemagic = (likes_magic(ptr) && pctload < 85);
X		likerock = (throws_rocks(ptr) && pctload < 50);
X		conceals = hides_under(ptr);
X	}
X
X#define SQSRCHRADIUS	5
X
X      { register int minr = SQSRCHRADIUS;	/* not too far away */
X	register struct obj *otmp;
X	register int xx, yy;
X	int oomx, oomy, lmx, lmy;
X
X	/* cut down the search radius if it thinks character is closer. */
X	if(distmin(mtmp->mux, mtmp->muy, omx, omy) < SQSRCHRADIUS &&
X	    !mtmp->mpeaceful) minr--;
X	/* guards shouldn't get too distracted */
X	if(!mtmp->mpeaceful && is_mercenary(ptr)) minr = 1;
X
X	if((likegold || likegems || likeobjs || likemagic || likerock || conceals)
X	      && (!*in_rooms(omx, omy, SHOPBASE) || (!rn2(25) && !mtmp->isshk))) {
X	look_for_obj:
X	    oomx = min(COLNO-1, omx+minr);
X	    oomy = min(ROWNO-1, omy+minr);
X	    lmx = max(1, omx-minr);
X	    lmy = max(0, omy-minr);
X	    for(otmp = fobj; otmp; otmp = otmp->nobj) {
X		xx = otmp->ox;
X		yy = otmp->oy;
X		if(xx >= lmx && xx <= oomx && yy >= lmy && yy <= oomy) {
X		    if(((likegold && otmp->otyp == GOLD_PIECE) ||
X		       (likeobjs && index(practical, otmp->oclass)) ||
X		       (likemagic && index(magical, otmp->oclass)) ||
X#ifdef MUSE
X		       (uses_items && searches_for_item(mtmp, otmp)) ||
X#endif
X		       (likerock && otmp->otyp == BOULDER) ||
X		       (likegems && otmp->oclass == GEM_CLASS &&
X			objects[otmp->otyp].oc_material != MINERAL) ||
X		       (conceals && !cansee(otmp->ox,otmp->oy)) ||
X		       (ptr == &mons[PM_GELATINOUS_CUBE] &&
X			!index(indigestion, otmp->oclass) &&
X			!(otmp->otyp == CORPSE &&
X			  otmp->corpsenm == PM_COCKATRICE))
X		      ) && touch_artifact(otmp,mtmp)) {
X			if(can_carry(mtmp,otmp) &&
X			   (throws_rocks(ptr) ||
X				!sobj_at(BOULDER,xx,yy)) &&
X			   (ptr->mlet != S_UNICORN ||
X			    objects[otmp->otyp].oc_material == GEMSTONE)) {
X			    minr = distmin(omx,omy,xx,yy);
X			    oomx = min(COLNO-1, omx+minr);
X			    oomy = min(ROWNO-1, omy+minr);
X			    lmx = max(1, omx-minr);
X			    lmy = max(0, omy-minr);
X			    gx = otmp->ox;
X			    gy = otmp->oy;
X			}
X		    }
X		}
X	    }
X	} else if(likegold) {
X	    /* don't try to pick up anything else, but use the same loop */
X#ifdef MUSE
X	    uses_items =
X#endif
X	    likegems = likeobjs = likemagic = likerock = conceals = 0;
X	    goto look_for_obj;
X	}
X
X	if(minr < SQSRCHRADIUS && appr == -1) {
X	    if(distmin(omx,omy,mtmp->mux,mtmp->muy) <= 3) {
X		gx = mtmp->mux;
X		gy = mtmp->muy;
X	    } else
X		appr = 1;
X	}
X      }
X	nix = omx;
X	niy = omy;
X	flag = ALLOW_TRAPS;
X	if (mtmp->mpeaceful && (!Conflict || resist(mtmp, RING_CLASS, 0, 0)))
X	    flag |= (ALLOW_SANCT | ALLOW_SSM);
X	else flag |= ALLOW_U;
X	if (ptr->mlet == S_UNICORN) flag |= NOTONL;
X	if (passes_walls(ptr)) flag |= (ALLOW_WALL | ALLOW_ROCK);
X	if (can_tunnel) flag |= ALLOW_DIG;
X	if (is_human(ptr) || ptr == &mons[PM_MINOTAUR]) flag |= ALLOW_SSM;
X	if (is_undead(ptr)) flag |= NOGARLIC;
X	if (throws_rocks(ptr)) flag |= ALLOW_ROCK;
X	if (can_open) flag |= OPENDOOR;
X	if (can_unlock) flag |= UNLOCKDOOR;
X	if (doorbuster) flag |= BUSTDOOR;
X	{
X	    register int i, j, nx, ny, nearer;
X	    int jcnt, cnt;
X	    int ndist, nidist;
X	    register coord *mtrk;
X	    coord poss[9];
X
X	    cnt = mfndpos(mtmp, poss, info, flag);
X	    chcnt = 0;
X	    jcnt = min(MTSZ, cnt-1);
X	    chi = -1;
X	    nidist = dist2(nix,niy,gx,gy);
X	    /* allow monsters be shortsighted on some levels for balance */
X	    if(!mtmp->mpeaceful && level.flags.shortsighted &&
X	       nidist > (couldsee(nix,niy) ? 144 : 36) && appr == 1) appr = 0;
X
X	    for(i=0; i < cnt; i++) {
X		nx = poss[i].x;
X		ny = poss[i].y;
X
X		if (appr != 0) {
X		    mtrk = &mtmp->mtrack[0];
X		    for(j=0; j < jcnt; mtrk++, j++)
X			if(nx == mtrk->x && ny == mtrk->y)
X			    if(rn2(4*(cnt-j)))
X				goto nxti;
X		}
X
X		nearer = ((ndist = dist2(nx,ny,gx,gy)) < nidist);
X
X		if((appr == 1 && nearer) || (appr == -1 && !nearer) ||
X		   (!appr && !rn2(++chcnt)) || !mmoved) {
X		    nix = nx;
X		    niy = ny;
X		    nidist = ndist;
X		    chi = i;
X		    mmoved = 1;
X		}
X	    nxti:	;
X	    }
X	}
X
X	if(mmoved) {
X	    register int j;
X#ifdef POLYSELF
X	    if (mmoved==1 && (u.ux != nix || u.uy != niy) && itsstuck(mtmp))
X		return(3);
X#endif
X#ifdef MUSE
X	    if (mmoved==1 && can_tunnel && needspick(ptr) &&
X		(!(mw_tmp = MON_WEP(mtmp)) || mw_tmp->otyp != PICK_AXE)) {
X		mtmp->weapon_check = NEED_PICK_AXE;
X		(void)mon_wield_item(mtmp);
X	    }
X#endif
X	    /* If ALLOW_U is set, either it's trying to attack you, or it
X	     * thinks it is.  In either case, attack this spot in preference to
X	     * all others.
X	     */
X	    if(info[chi] & ALLOW_U) {
X		nix = mtmp->mux;
X		niy = mtmp->muy;
X	    }
X	    if (nix == u.ux && niy == u.uy) {
X		mtmp->mux = u.ux;
X		mtmp->muy = u.uy;
X		return(0);
X	    }
X	    /* The monster may attack another based on 1 of 2 conditions:
X	     * 1 - It may be confused.
X	     * 2 - It may mistake the monster for your (displaced) image.
X	     * Pets get taken care of above and shouldn't reach this code.
X	     * Conflict gets handled even farther away (movemon()).
X	     */
X	    if((info[chi] & ALLOW_M) ||
X		   (nix == mtmp->mux && niy == mtmp->muy)) {
X		struct monst *mtmp2;
X		int stat;
X		mtmp2 = m_at(nix,niy);
X
X		stat = mattackm(mtmp, mtmp2);
X
X		if (stat & MM_AGR_DIED)		/* aggressor died */
X		    return 2;
X
X		if ((stat & MM_HIT) && !(stat & MM_DEF_DIED)  &&
X		    rn2(4) && mtmp2->mlstmv != monstermoves) {
X		    stat = mattackm(mtmp2, mtmp);	/* return attack */
X		    if (stat & MM_DEF_DIED)
X			return 2;
X		}
X		return 3;
X	    }
X
X	    remove_monster(omx, omy);
X	    place_monster(mtmp, nix, niy);
X	    for(j = MTSZ-1; j > 0; j--)
X		mtmp->mtrack[j] = mtmp->mtrack[j-1];
X	    mtmp->mtrack[0].x = omx;
X	    mtmp->mtrack[0].y = omy;
X	    /* Place a segment at the old position. */
X	    if (mtmp->wormno) worm_move(mtmp);
X	} else {
X	    if(ptr->mlet == S_UNICORN && rn2(2)) {
X		rloc(mtmp);
X		return(1);
X	    }
X	    if(mtmp->wormno) worm_nomove(mtmp);
X	}
Xpostmov:
X	if(mmoved == 1) {
X	    boolean canseeit = cansee(mtmp->mx, mtmp->my);
X	    boolean abstain = (mtmp->mpeaceful && !mtmp->mtame);
X
X	    newsym(omx,omy);		/* update the old position */
X	    if (mintrap(mtmp) >= 2) {
X		if(mtmp->mx) newsym(mtmp->mx,mtmp->my);
X		return(2);	/* it died */
X	    }
X	    ptr = mtmp->data;
X
X	    /* open a door, or crash through it, if you can */
X	    if(IS_DOOR(levl[mtmp->mx][mtmp->my].typ)
X		    && !passes_walls(ptr) /* doesn't need to open doors */
X		    && !can_tunnel /* taken care of below */
X		  ) {
X		struct rm *here = &levl[mtmp->mx][mtmp->my];
X		boolean btrapped = (here->doormask & D_TRAPPED);
X
X		if(here->doormask & (D_LOCKED|D_CLOSED) && amorphous(ptr)) {
X		    if (flags.verbose && canseeit)
X			pline("%s %ss under the door.", Monnam(mtmp),
X			      (ptr == &mons[PM_FOG_CLOUD] ||
X			       ptr == &mons[PM_YELLOW_LIGHT])
X			      ? "flow" : "ooze");
X		} else if(here->doormask & D_LOCKED && can_unlock) {
X		    if(btrapped) {
X			here->doormask = D_NODOOR;
X			newsym(mtmp->mx, mtmp->my);
X			unblock_point(mtmp->mx,mtmp->my); /* vision */
X			if(mb_trapped(mtmp)) return(2);
X		    } else {
X			if (flags.verbose) {
X			    if (canseeit)
X			      You("see a door being unlocked and opened.");
X			    else if (flags.soundok)
X			       You("hear a door being unlocked and opened.");
X		        }
X		        here->doormask = D_ISOPEN;
X			/* newsym(mtmp->mx, mtmp->my); */
X			unblock_point(mtmp->mx,mtmp->my); /* vision */
X		    }
X		} else if (here->doormask == D_CLOSED && can_open) {
X		    if(btrapped) {
X			here->doormask = D_NODOOR;
X			newsym(mtmp->mx, mtmp->my);
X			unblock_point(mtmp->mx,mtmp->my); /* vision */
X			if(mb_trapped(mtmp)) return(2);
X		    } else {
X		        if (flags.verbose) {
X			    if (canseeit)
X			         You("see a door being opened.");
X			    else if (flags.soundok)
X			         You("hear the sound of a door opening.");
X		        }
X		        here->doormask = D_ISOPEN;
X			/* newsym(mtmp->mx, mtmp->my); */  /* done below */
X			unblock_point(mtmp->mx,mtmp->my); /* vision */
X		    }
X		} else if (here->doormask & (D_LOCKED|D_CLOSED)) {
X		    /* mfndpos guarantees this must be a doorbuster */
X		    if(btrapped) {
X			here->doormask = D_NODOOR;
X			newsym(mtmp->mx, mtmp->my);
X			unblock_point(mtmp->mx,mtmp->my); /* vision */
X			if(mb_trapped(mtmp)) return(2);
X		    } else {
X		        if (flags.verbose) {
X			    if (canseeit)
X			        You("see a door crash open.");
X			    else if (flags.soundok)
X			        You("hear the sound of a door crashing open.");
X		        }
X		        if (here->doormask & D_LOCKED && !rn2(2))
X			        here->doormask = D_NODOOR;
X		        else here->doormask = D_BROKEN;
X			/* newsym(mtmp->mx, mtmp->my); */ /* done below */
X			unblock_point(mtmp->mx,mtmp->my); /* vision */
X		    }
X		}
X	    }
X
X	    /* possibly dig */
X	    if (can_tunnel && mdig_tunnel(mtmp))
X		    return(2);	/* mon died (position already updated) */
X
X	    /* set also in domove(), hack.c */
X	    if (u.uswallow && mtmp == u.ustuck &&
X					(mtmp->mx != omx || mtmp->my != omy)) {
X		/* If the monster moved, then update */
X		u.ux0 = u.ux;
X		u.uy0 = u.uy;
X		u.ux = mtmp->mx;
X		u.uy = mtmp->my;
X		swallowed(0);
X	    } else
X		newsym(mtmp->mx,mtmp->my);
X
X	    if(OBJ_AT(mtmp->mx, mtmp->my) && mtmp->mcanmove) {
X		/* Maybe a rock mole just ate some metal object */
X		if(metallivorous(ptr)) meatgold(mtmp);
X
X		if(g_at(mtmp->mx,mtmp->my) && likegold &&
X				    (!abstain || !rn2(10))) mpickgold(mtmp);
X
X		/* Maybe a cube ate just about anything */
X		if(ptr == &mons[PM_GELATINOUS_CUBE]) meatobj(mtmp);
X
X		if((!abstain || !rn2(10)) && 
X		   (!*in_rooms(mtmp->mx, mtmp->my, SHOPBASE) || !rn2(25))) {
X		    if(likeobjs) mpickstuff(mtmp, practical);
X		    if(likemagic) mpickstuff(mtmp, magical);
X		    if(likerock || likegems) mpickgems(mtmp);
X#ifdef MUSE
X		    if(uses_items) mpickstuff(mtmp, (char *)0);
X#endif
X		}
X
X		if(mtmp->minvis) {
X		    newsym(mtmp->mx, mtmp->my);
X		    if (mtmp->wormno) see_wsegs(mtmp);
X		}
X	    }
X
X	    if(hides_under(ptr)) {
X		mtmp->mundetected = OBJ_AT(mtmp->mx, mtmp->my);
X		newsym(mtmp->mx, mtmp->my);
X	    }
X	}
X	return(mmoved);
X}
X
X#endif /* OVL0 */
X#ifdef OVL2
X
Xboolean
Xclosed_door(x, y)
Xregister int x, y;
X{
X	return(IS_DOOR(levl[x][y].typ) &&
X			(levl[x][y].doormask & (D_LOCKED | D_CLOSED)));
X}
X
Xboolean
Xaccessible(x, y)
Xregister int x, y;
X{
X	return(ACCESSIBLE(levl[x][y].typ) && !closed_door(x, y));
X}
X
X#endif /* OVL2 */
X#ifdef OVL0
X
Xvoid
Xset_apparxy(mtmp)		/* where does mtmp think you are standing? */
X	register struct monst *mtmp;
X{
X#define notseen (Invis && !perceives(mtmp->data))
X/*	add cases as required.  eg. Displacement ... */
X	register int disp = (Underwater ? 3 : notseen ? 1 : Displaced ? 2 : 0);
X
X/* 	without something like the following, invis. and displ. are too */
X/*	powerful. */
X	register boolean gotu =
X		(notseen ? !rn2(3) : Displaced ? !rn2(4) : FALSE);
X
X/*	Monsters which know where you are don't suddenly forget, if you
X	didn't move away. */
X	if (mtmp->mux==u.ux && mtmp->muy==u.uy) gotu = 1;
X
X/* 	your dog follows your smell */
X	if(!disp || mtmp->mtame || gotu ||
X/* 	Monsters touching you know where you are */
X	   mtmp == u.ustuck ||
X/*	If invisible but not displaced, staying around gets you 'discovered' */
X	    (!Displaced && u.dx == 0 && u.dy == 0)) {
X		mtmp->mux = u.ux;
X		mtmp->muy = u.uy;
X	}
X	else do {
X		mtmp->mux = u.ux - disp + rn2(2*disp+1);
X		mtmp->muy = u.uy - disp + rn2(2*disp+1);
X	} while((mtmp->mux != u.ux || mtmp->muy != u.uy) &&
X	        ( (!passes_walls(mtmp->data) &&
X		      (!ACCESSIBLE(levl[mtmp->mux][mtmp->muy].typ) ||
X		       (closed_door(mtmp->mux, mtmp->muy) &&
X			!amorphous(mtmp->data)
X		       )
X		      )
X		  ) ||
X		  (disp==1 && mtmp->mux == mtmp->mx && mtmp->muy == mtmp->my)
X	        )
X	       );
X}
X
X#endif /* OVL0 */
X
X/*monmove.c*/
END_OF_FILE
if test 30715 -ne `wc -c <'src/monmove.c'`; then
    echo shar: \"'src/monmove.c'\" unpacked with wrong size!
fi
# end of 'src/monmove.c'
fi
if test -f 'sys/msdos/MakeMSC.src' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/msdos/MakeMSC.src'\"
else
echo shar: Extracting \"'sys/msdos/MakeMSC.src'\" \(23509 characters\)
sed "s/^X//" >'sys/msdos/MakeMSC.src' <<'END_OF_FILE'
X# SCCS Id: @(#)MakeMSC.src	3.1	93/01/18
X# Copyright (c) NetHack PC Development Team 1992, 1993
X# PC NetHack 3.1 Makefile for Microsoft(tm) "C" >= 6.0ax
X#
X# Nota Bene:	Before you get to here you should have already read
X# 		the Install.dos file located in the sys/msdos directory.
X
X# This Makefile supports two different overlay management schemes.
X# You must select either the one that supports Microsoft C
X# version 6 or version 7.  By default this Makefile is set up
X# for version 7 or greater.  Certain sections particular to
X# each compiler are marked either MSC7 or MSC6.  If you are
X# using Microsoft C version 7, make sure that all the MSC6
X# sections are commented out and pay particular attention
X# to all sections marked MSC7, uncommenting all the variables.
X# Do the same thing for MSC6 if you are using that version of
X# the compiler.
X#
X# MSC6 Notes:
X#	As it is set up, this makefile requires that exesmurf (the
X#	NetHack overlay-aware .exe header editor) be on your path or in the
X#	$(SRC) directory. If you wish to change the path or use Microsoft
X#	EXEMOD instead, see the symbols EXEPATCH and EXEFLAGS.
X#
X
X#
X# Game Installation Variables.
X# NOTE: Make sure GAMEDIR exists before make is started.
X#
X
XGAME	= NetHack
XGAMEDIR = c:\games\nethack
Xdefault: $(GAME)
X
X#
X#	Source code and data file directories.
X#
X
XDAT	= ..\dat
XINCL	= ..\include
XSRC	= .
XOBJ	= $(SRC)\o
XSYS	= ..\sys\msdos
XSSYS	= ..\sys\share
XUTL	= ..\util
XWIN	= ..\win\tty
X
X#
X#	Exe File Info.
X#	($(MAKE) macro is often predefined, so we use $(MAKEBIN) instead.)
X#
X
XASM	= masm		# Assembler
XCC	= cl		# Compiler
XLINK	= link		# Linker
XMAKEBIN = make45l	# Make Utility
X
X#
X# Make the necessary changes in *one* of the two sections below.
X#
X
X
X#### MSC7 Section Only #####
X# MSC7 Compiler Flags are set up in the setup.bat file using
X# the CL environment variable as the total lenth of the compiler
X# command line exceeds the MSDOS 128 character limit.
X#
XCFLAGS	= /c
XLFLAGS	= /noi /seg:512 /map /st:5120 /DYNAMIC:1100 /INFO
XOVLMUCKING =	# None required
XMSC6MUCK = 	# None required
X############################
X
X
X#### MSC6 Section Only #####
X#
X# First comment out the MSC7 section.  And uncomment much of what is below.
X#
X
X#
X# CC	There was a register bug, to be safe remove stack probes.
X# /Gt18 is currently about the largest value that keeps the initialised
X#	data segment below 64K (and keeps the linker happy).
X# /G2	286 or higher machines can use the /G2 CFLAG option for better
X#	performance.
X#
X#CFLAGS	= /AL /c /Os /Gs /Gt18 /Zp1 /W0 /I$(INCL)
X#LFLAGS	= /noi /seg:512 /map /st:4096
X#EXEPATCH = exesmurf	# Executable Massager
X#EXEFLAGS = /max4500 /min4500
X#OVLMUCKING = $(EXEPATCH) ovlmgr.obj
X#MSC6MUCK = msc6muck
X
X#
X# For Microsoft C version <= 6.00ax, we use a custom overlay
X# manager, which requires the lower line to be uncommented.
XOVLMGR	=
X#OVLMGR	= ovlmgr.obj
X
X#
X# Switch the following $(OBJ)\$(OVLMGR): lines if you don't have a
X# MASM compatible assembler.
X$(OBJ)\$(OVLMGR):
X# $(OBJ)\$(OVLMGR): ; copy $(SYS)\$(OVLMGR) $(OBJ)\$(OVLMGR)
X
X#
X# If you need to recompile ovlmgr.asm you may want to change
X# some of the flags.
XAFLAGS = /MX
X# /Di386	= Use 386 specific enhancements
X# /DNOEMS	= Do not use EMS memory
X# /DDEBUG	= Report memory usage on startup
X# /DNOSPLIT	= EXE file is not split out to OVL files
X
X#
X# Uncomment these sections.
X#
X#$(EXEPATCH): $(EXEPATCH).exe
X#$(EXEPATCH).exe: $(OBJ)\$(EXEPATCH).o
X#	$(LINK) $(OBJ)\$*.o, $*.exe;
X
X#
X#$(OBJ)\$(EXEPATCH).o: $(SYS)\$(EXEPATCH).c
X#	$(CC) /W0 /Fo$(OBJ)\$*.o $(SYS)\$*.c
X############################
X
X#
X#	Optional high-quality BSD random number generation routines
X#	(see pcconf.h).	Set to nothing if not used.
X#
X
XRANDOM	= $(OBJ)\random.o
X# RANDOM	=
X
X#
X# If TERMLIB is NOT #defined in the source, comment out the
X# lower line and uncomment the upper.  Make sure that TERMLIB
X# contains the full pathname to the termcap library.
X
X#TERMLIB =
XTERMLIB = $(SSYS)\termcap.lib
X
X#
X#	Nothing below this line should have to be changed.
X#
X
X#
X#	Make Roolz dude.
X#	Due to an NDMake inadequacy these must accord with a topological
X#	sort of the generated-from relation... output on the left, input
X#	on the right. Trust me.
X#
X
X.SUFFIXES: .exe .0 .0-1 .0-2 .0-3 .1 .1-2 .1-3 .1-b .2 .2-3 .2-b .3 .3-b .b \
X	   .o .c .y .l .obj .asm
X
X.c.o:
X	$(CC) $(CFLAGS) /Fo$(OBJ)\$*.o $*.c
X.c.0:
X	$(CC) $(CFLAGS) /DOVL0 /NT$*.0 /Fo$(OBJ)\$*.0 $*.c
X.c.0-1:
X	$(CC) $(CFLAGS) /DOVL0 /DOVL1 /NT$*.0-1 /Fo$(OBJ)\$*.0-1 $*.c
X.c.0-2:
X	$(CC) $(CFLAGS) /DOVL0 /DOVL1 /DOVL2 /NT$*.0-2 /Fo$(OBJ)\$*.0-2 $*.c
X.c.0-3:
X	$(CC) $(CFLAGS) /DOVL0 /DOVL1 /DOVL2 /DOVL3 /NT$*.0-3 /Fo$(OBJ)\$*.0-3 $*.c
X.c.1:
X	$(CC) $(CFLAGS) /DOVL1 /NT$*.1 /Fo$(OBJ)\$*.1 $*.c
X.c.1-2:
X	$(CC) $(CFLAGS) /DOVL1 /DOVL2 /NT$*.1-2 /Fo$(OBJ)\$*.1-2 $*.c
X.c.1-3:
X	$(CC) $(CFLAGS) /DOVL1 /DOVL2 /DOVL3 /NT$*.1-3 /Fo$(OBJ)\$*.1-3 $*.c
X.c.1-b:
X	$(CC) $(CFLAGS) /DOVL1 /DOVL2 /DOVL3 /DOVLB /NT$*.1-b /Fo$(OBJ)\$*.1-b $*.c
X.c.2:
X	$(CC) $(CFLAGS) /DOVL2 /NT$*.2 /Fo$(OBJ)\$*.2 $*.c
X.c.2-3:
X	$(CC) $(CFLAGS) /DOVL2 /DOVL3 /NT$*.2-3 /Fo$(OBJ)\$*.2-3 $*.c
X.c.2-b:
X	$(CC) $(CFLAGS) /DOVL2 /DOVL3 /DOVLB /NT$*.2-b /Fo$(OBJ)\$*.2-b $*.c
X.c.3:
X	$(CC) $(CFLAGS) /DOVL3 /NT$*.3 /Fo$(OBJ)\$*.3 $*.c
X.c.3-b:
X	$(CC) $(CFLAGS) /DOVL3 /DOVLB /NT$*.3-b /Fo$(OBJ)\$*.3-b $*.c
X.c.b:
X	$(CC) $(CFLAGS) /DOVLB /NT$*.b /Fo$(OBJ)\$*.b $*.c
X.asm.obj:
X	$(ASM) $(AFLAGS) $(SYS)\$*.asm, $(OBJ)\$*.obj ;
X
X#
X#	Header Objects.
X#
X
XCONFIG_H   = $(GLOBAL_H)	$(INCL)\tradstdc.h	$(INCL)\config.h
XDECL_H	   = $(YOU_H)		$(INCL)\spell.h		$(INCL)\color.h	\
X	     $(INCL)\obj.h	$(INCL)\onames.h	$(INCL)\pm.h \
X	     $(INCL)\decl.h
XDGN_FILE_H = $(INCL)\align.h	$(INCL)\dgn_file.h
XDISPLAY_H  = $(MONDATA_H)	$(INCL)\vision.h	$(INCL)\display.h
XDUNGEON_H  = $(INCL)\align.h	$(INCL)\dungeon.h
XEMIN_H	   = $(DUNGEON_H)	$(INCL)\emin.h
XEPRI_H	   = $(DUNGEON_H)	$(INCL)\align.h		$(INCL)\epri.h
XESHK_H	   = $(DUNGEON_H)	$(INCL)\eshk.h
XGLOBAL_H   = $(PCCONF_H)	$(INCL)\coord.h		$(INCL)\global.h
XHACK_H	   = $(CONFIG_H)	$(DUNGEON_H)		$(DECL_H) \
X	     $(DISPLAY_H)	$(INCL)\monsym.h	$(INCL)\mkroom.h \
X	     $(INCL)\objclass.h	$(INCL)\trap.h		$(INCL)\flag.h	\
X	     $(RM_H)		$(INCL)\vision.h	$(INCL)\wintype.h \
X	     $(INCL)\engrave.h	$(INCL)\rect.h \
X	     $(INCL)\trampoli.h	$(INCL)\hack.h
XMONDATA_H  = $(INCL)\align.h	$(INCL)\mondata.h
XMONST_H	   = $(INCL)\align.h	$(INCL)\monst.h
XPCCONF_H   = $(INCL)\micro.h	$(INCL)\system.h	$(INCL)\pcconf.h
XPERMONST_H = $(INCL)\monattk.h	$(INCL)\monflag.h	$(INCL)\align.h	\
X	     $(INCL)\permonst.h
XRM_H	   = $(INCL)\align.h	$(INCL)\rm.h
XSP_LEV_H   = $(INCL)\align.h	$(INCL)\sp_lev.h
XVAULT_H	   = $(DUNGEON_H)	$(INCL)\vault.h
XYOU_H	   = $(MONST_H)		$(YOUPROP_H)		$(INCL)\align.h	\
X	     $(INCL)\attrib.h	$(INCL)\you.h
XYOUPROP_H  = $(PERMONST_H)	$(MONDATA_H)		$(INCL)\prop.h	\
X	     $(INCL)\pm.h	$(INCL)\youprop.h
X
X#
X#	Overlay Objects.
X#
X
XROOT =	$(OBJ)\main.o $(OBJ)\msdos.0 $(OBJ)\dungeon.0 \
X	$(OBJ)\alloc.o $(OBJ)\random.o $(OBJ)\decl.o $(OBJ)\dbridge.0 \
X	$(OBJ)\objects.o $(OBJ)\invent.0 $(OBJ)\mkobj.0 $(OBJ)\mkroom.0 \
X	$(OBJ)\rnd.0 $(OBJ)\termcap.0 $(OBJ)\mondata.0 $(OBJ)\muse.o \
X	$(OBJ)\engrave.0 $(OBJ)\explode.o $(OBJ)\display.o $(OBJ)\vision.o \
X	$(OBJ)\attrib.0 $(OBJ)\rect.o $(OBJ)\vis_tab.o $(OBJ)\hacklib.0 \
X	$(OBJ)\monst.o $(OBJ)\hack.3 $(OBJ)\topl.0 $(OBJ)\trap.0 \
X	$(OBJ)\wintty.o $(OBJ)\monmove.0 $(OBJ)\dogmove.0
X
X# These could use to go in root, but are in OLV1 to make
X# the game loadable in under 512 free ram.
X# rhack and friends
XOVL01 = $(OBJ)\allmain.0 $(OBJ)\artifact.0 $(OBJ)\attrib.1 $(OBJ)\cmd.1 \
X	$(OBJ)\do.1 $(OBJ)\do.3 $(OBJ)\eat.0 $(OBJ)\engrave.2 \
X	$(OBJ)\getline.0-1 $(OBJ)\hack.1-2 \
X	$(OBJ)\botl.1 $(OBJ)\sounds.0 $(OBJ)\timeout.0 \
X	$(OBJ)\track.1 $(OBJ)\vault.0 $(OBJ)\wizard.0 $(OBJ)\hacklib.1
X# startup
XOVL02 = $(OBJ)\dungeon.1 $(OBJ)\files.o $(OBJ)\pcsys.o \
X	$(OBJ)\monstr.o $(OBJ)\msdos.b
X# main monster code
XOVL03 = $(OBJ)\cmd.0 $(OBJ)\engrave.1 $(OBJ)\mondata.1 \
X	$(OBJ)\mthrowu.0 $(OBJ)\priest.0 $(OBJ)\track.0 \
X	$(OBJ)\trap.1 $(OBJ)\were.0
X# monster movement
XOVL04 = $(OBJ)\mon.0-1 $(OBJ)\monmove.1
X# pet monster movement
XOVL05 = $(OBJ)\dog.1 $(OBJ)\dogmove.1-b
X# advanced monsters
XOVL06 = $(OBJ)\minion.o $(OBJ)\mcastu.o
XOVL07 = $(OBJ)\priest.1-b $(OBJ)\shk.1-b
XOVL08 = $(OBJ)\were.1-b
XOVL09 = $(OBJ)\wizard.1-b
XOVL10 = $(OBJ)\worm.o
X# 11-15 around the movement loop
X# domove and friends
XOVL11 = $(OBJ)\hack.0 $(OBJ)\apply.0 $(OBJ)\do_wear.1 $(OBJ)\lock.0 \
X	$(OBJ)\cmd.2
XOVL12 = $(OBJ)\detect.o
XOVL13 = $(OBJ)\attrib.2-b $(OBJ)\exper.o
XOVL14 = $(OBJ)\eat.1 $(OBJ)\invent.1
XOVL15 = $(OBJ)\makemon.0-2 $(OBJ)\mkobj.1
XOVL16 = $(OBJ)\makemon.b $(OBJ)\mplayer.o $(OBJ)\mkobj.2-b
XOVL17 = $(OBJ)\mhitm.1-b
XOVL18 = $(OBJ)\mthrowu.1
XOVL19 = $(OBJ)\mthrowu.2-b
XOVL20 = $(OBJ)\allmain.1 $(OBJ)\mhitm.0 $(OBJ)\mhitu.0-1 $(OBJ)\rnd.1 \
X	$(OBJ)\weapon.0-1
XOVL21 = $(OBJ)\mon.2-b
XOVL22 = $(OBJ)\artifact.1 $(OBJ)\uhitm.o $(OBJ)\weapon.2-b
XOVL23 = $(OBJ)\do_wear.0 $(OBJ)\mhitu.2-b
XOVL24 = $(OBJ)\steal.0-1
XOVL25 = $(OBJ)\monmove.2-b $(OBJ)\steal.2-b
XOVL26 = $(OBJ)\rnd.2-b
XOVL27 = $(OBJ)\do_wear.2 $(OBJ)\mondata.2 $(OBJ)\objnam.0-1 \
X	$(OBJ)\polyself.0-1
XOVL28 = $(OBJ)\do_name.0
XOVL29 = $(OBJ)\objnam.2-b $(OBJ)\hacklib.2-b
XOVL30 = $(OBJ)\pager.o
XOVL31 = $(OBJ)\botl.0
XOVL32 = $(OBJ)\botl.b $(OBJ)\topl.b $(OBJ)\termcap.1 $(OBJ)\windows.o
XOVL33 = $(OBJ)\topl.1-2
XOVL34 = $(OBJ)\pline.o
XOVL35 = $(OBJ)\termcap.2-b
XOVL36 = $(OBJ)\quest.o $(OBJ)\questpgr.o
XOVL37 = $(OBJ)\invent.b
XOVL38 = $(OBJ)\hack.b
XOVL39 = $(OBJ)\mondata.b $(OBJ)\timeout.1-b $(OBJ)\dog.b $(OBJ)\sounds.1-b
XOVL40 = $(OBJ)\do.0 $(OBJ)\invent.3
XOVL41 = $(OBJ)\cmd.b $(OBJ)\getline.2 $(OBJ)\write.o
XOVL42 = $(OBJ)\apply.2-b
XOVL43 = $(OBJ)\do.b $(OBJ)\drawing.o
XOVL44 = $(OBJ)\dokick.o
XOVL45 = $(OBJ)\dothrow.o
XOVL46 = $(OBJ)\eat.2-b
XOVL47 = $(OBJ)\invent.2 $(OBJ)\pickup.o
XOVL48 = $(OBJ)\lock.1-b
XOVL49 = $(OBJ)\polyself.2-b
XOVL50 = $(OBJ)\potion.o
XOVL51 = $(OBJ)\pray.o
XOVL52 = $(OBJ)\read.1-b $(OBJ)\spell.o
XOVL53 = $(OBJ)\ball.o
X# clothing stuff
XOVL54 = $(OBJ)\do_wear.b $(OBJ)\wield.o $(OBJ)\worn.o
X# Zappage
XOVL55 = $(OBJ)\zap.o
XOVL56 = $(OBJ)\dbridge.1-b
XOVL57 = $(OBJ)\trap.b
X# Unusual circumstances
XOVL58 = $(OBJ)\artifact.b $(OBJ)\do_name.1-b $(OBJ)\fountain.o $(OBJ)\music.o \
X	$(OBJ)\rumors.o $(OBJ)\sit.o $(OBJ)\vault.1-b
X# Uppers and Downers
XOVL59 = $(OBJ)\apply.1 $(OBJ)\bones.o $(OBJ)\mklev.o
XOVL60 = $(OBJ)\save.o $(OBJ)\restore.o
XOVL61 = $(OBJ)\mkmaze.o $(OBJ)\mkroom.1-b $(OBJ)\mkmap.o
X# Note: version.o is in OVL62, but in a special way.  See below.
XOVL62 = $(OBJ)\allmain.2-b $(OBJ)\end.o $(OBJ)\engrave.b \
X	$(OBJ)\o_init.o $(OBJ)\options.o $(OBJ)\rip.o \
X	$(OBJ)\shknam.o $(OBJ)\topten.o $(OBJ)\tty.o \
X	$(OBJ)\u_init.o $(OBJ)\unix.1-b
X# Levelling
XOVL63 = $(OBJ)\do.2 $(OBJ)\dog.2 $(OBJ)\extralev.o \
X	$(OBJ)\sp_lev.o $(OBJ)\track.2-b
X
X#
X#	Make Objects.
X#
X
XMOBJ = $(OVL01) $(OVL02) $(OVL03) $(OVL04) $(OVL05) $(OVL06) $(OVL07) $(OVL08)\
X       $(OVL09) $(OVL10) $(OVL11) $(OVL12) $(OVL13) $(OVL14) $(OVL15) $(OVL16)\
X       $(OVL17) $(OVL18) $(OVL19) $(OVL20) $(OVL21) $(OVL22) $(OVL23) $(OVL24)\
X       $(OVL25) $(OVL26) $(OVL27) $(OVL28) $(OVL29) $(OVL30) $(OVL31) $(OVL32)\
X       $(OVL33) $(OVL34) $(OVL35) $(OVL36) $(OVL37) $(OVL38) $(OVL39) $(OVL40)\
X       $(OVL41) $(OVL42) $(OVL43) $(OVL44) $(OVL45) $(OVL46) $(OVL47) $(OVL48)\
X       $(OVL49) $(OVL50) $(OVL51) $(OVL52) $(OVL53) $(OVL54) $(OVL55) $(OVL56)\
X       $(OVL57) $(OVL58) $(OVL59) $(OVL60) $(OVL61) $(OVL62) $(OVL63)
X
XVOBJ = $(ROOT)	$(MOBJ)
X
XHOBJ = $(VOBJ)	$(OBJ)\version.o
X
XOVERLAYS = ($(OVL01)) ($(OVL02)) ($(OVL03)) ($(OVL04)) ($(OVL05)) ($(OVL06)) \
X	   ($(OVL07)) ($(OVL08)) ($(OVL09)) ($(OVL10)) ($(OVL11)) ($(OVL12)) \
X	   ($(OVL13)) ($(OVL14)) ($(OVL15)) ($(OVL16)) ($(OVL17)) ($(OVL18)) \
X	   ($(OVL19)) ($(OVL20)) ($(OVL21)) ($(OVL22)) ($(OVL23)) ($(OVL24)) \
X	   ($(OVL25)) ($(OVL26)) ($(OVL27)) ($(OVL28)) ($(OVL29)) ($(OVL30)) \
X	   ($(OVL31)) ($(OVL32)) ($(OVL33)) ($(OVL34)) ($(OVL35)) ($(OVL36)) \
X	   ($(OVL37)) ($(OVL38)) ($(OVL39)) ($(OVL40)) ($(OVL41)) ($(OVL42)) \
X	   ($(OVL43)) ($(OVL44)) ($(OVL45)) ($(OVL46)) ($(OVL47)) ($(OVL48)) \
X	   ($(OVL49)) ($(OVL50)) ($(OVL51)) ($(OVL52)) ($(OVL53)) ($(OVL54)) \
X	   ($(OVL55)) ($(OVL56)) ($(OVL57)) ($(OVL58)) ($(OVL59)) ($(OVL60)) \
X	   ($(OVL61)) ($(OVL62)	$(OBJ)\version.o) ($(OVL63))
X
X#
X#	Primary make targets.
X#
X
XGAMEFILE = $(GAMEDIR)\$(GAME).exe
X
Xall: install
X
Xinstall: $(DAT)\sp_lev.tag	$(GAMEFILE)	$(MSC6MUCK)	install.tag
X	@echo Don't forget to check HACKDIR in $(GAMEDIR)\NetHack.cnf.
X	@echo Done.
X
Xinstall.tag: $(GAMEFILE) $(MSC6MUCK)
X	copy $(SSYS)\termcap		$(GAMEDIR)
X	copy $(DAT)\*.?			$(GAMEDIR)
X	copy $(DAT)\*.dat		$(GAMEDIR)
X	copy $(DAT)\*.lev		$(GAMEDIR)
X	copy $(SSYS)\NetHack.cnf	$(GAMEDIR)
X	copy $(UTL)\recover.exe		$(GAMEDIR)
X	del  $(GAMEDIR)\makefile
X	echo install done > install.tag
X
X$(GAME): $(GAMEFILE) $(MSC6MUCK)
X
X$(GAME).exe: $(GAMEFILE) $(MSC6MUCK)
X
X$(GAMEFILE): $(UTL)\utility.tag $(OBJ) $(OVLMUCKING) $(HOBJ)
X	@echo Loading....
X	$(LINK) $(LFLAGS) $(ROOT) $(OVERLAYS),$(GAMEFILE),$(GAME),$(TERMLIB);
X	@del $(GAMEDIR)\$(GAME).bak > NUL
X	@echo $(GAME) is up to date.
X
Xmsc6muck:
X	$(EXEPATCH) $(GAMEFILE) $(EXEFLAGS)
X	$(EXEPATCH) $(GAMEFILE) 1 40
X
X#
X#	Secondary Targets.
X#
X
Xclean:
X	del $(OBJ)\*.o
X	del $(OBJ)\*.0
X	del $(OBJ)\*.0-1
X	del $(OBJ)\*.0-2
X	del $(OBJ)\*.0-3
X	del $(OBJ)\*.1
X	del $(OBJ)\*.1-2
X	del $(OBJ)\*.1-3
X	del $(OBJ)\*.1-b
X	del $(OBJ)\*.2
X	del $(OBJ)\*.2-3
X	del $(OBJ)\*.2-b
X	del $(OBJ)\*.3
X	del $(OBJ)\*.3-b
X	del $(OBJ)\*.b
X	del $(OBJ)\*.obj
X	rmdir $(OBJ)
X
Xspotless: clean
X	del *.exe
X	del *.bak
X	del *.tag
X	del *.map
X	del *.obj
X	del *.lib
X	del *.txt
X
X$(OBJ):
X	if not exist $(OBJ)\*.* mkdir $(OBJ)
X
X#
X# I'm not too fond of using this `attrib .foo` command to stop make,
X# but I can't think of any better generic way to do it.
X# It works for DOS 3.3, 4.00, & 5.0.
X# If you find a better one please feel free to implement it.
X#
X$(UTL)\utility.tag: monst.c	alloc.c			objects.c \
X	$(UTL)\makedefs.c	$(UTL)\panic.c		$(UTL)\recover.c \
X	$(UTL)\dgn_main.c	$(UTL)\dgn_comp.l	$(UTL)\dgn_comp.y \
X	$(UTL)\lev_main.c	$(UTL)\lev_comp.l	$(UTL)\lev_comp.y \
X	$(HACK_H)
X	@echo You must first "$(MAKEBIN) all" in the $(UTL) directory.
X	@attrib .foo
X
X$(DAT)\sp_lev.tag: $(UTL)\utility.tag
X	@echo You must first "$(MAKEBIN) all" in the $(DAT) directory.
X	@attrib .foo
X
X#
X# Other dependencies
X#
X
X$(INCL)\date.h: $(VOBJ)
X	$(UTL)\makedefs -v
X
X#
X#	Overlay/PC source code dependencies.
X#
X
X#
X#	$(SYS) files.
X#
X
X$(OBJ)\msdos.0: $(HACK_H) $(INCL)\termcap.h $(SYS)\msdos.c
X	$(CC) $(CFLAGS) /DOVL0 /NT$*.0 /Fo$(OBJ)\$*.0 $(SYS)\$*.c
X
X$(OBJ)\msdos.b: $(HACK_H) $(INCL)\termcap.h $(SYS)\msdos.c
X	$(CC) $(CFLAGS) /DOVLB /NT$*.b /Fo$(OBJ)\$*.b $(SYS)\$*.c
X
X$(OBJ)\trampoli.o: $(HACK_H)	$(SYS)\trampoli.c
X	$(CC) $(CFLAGS) /Fo$(OBJ)\$*.o $(SYS)\$*.c
X
X#
X#	$(SSYS) files.
X#
X
X$(OBJ)\main.o: $(HACK_H)	$(SSYS)\pcmain.c
X	$(CC) $(CFLAGS) /Fo$(OBJ)\main.o $(SSYS)\pcmain.c
X
X$(OBJ)\pcsys.o:	$(HACK_H)	$(INCL)\wintty.h	$(SSYS)\pcsys.c
X	$(CC) $(CFLAGS) /Fo$(OBJ)\$*.o $(SSYS)\$*.c
X
X$(OBJ)\random.o: $(SSYS)\random.c
X	$(CC) $(CFLAGS) /Fo$(OBJ)\$*.o $(SSYS)\$*.c
X
X$(OBJ)\tty.o: $(HACK_H)		$(INCL)\wintty.h	$(SSYS)\pctty.c
X	$(CC) $(CFLAGS) /Fo$(OBJ)\tty.o	$(SSYS)\pctty.c
X
X$(OBJ)\unix.0: $(HACK_H)	$(SSYS)\pcunix.c
X	$(CC) $(CFLAGS) /DOVL0 /Fo$(OBJ)\unix.0 $(SSYS)\pcunix.c
X
X$(OBJ)\unix.1-b: $(HACK_H)	$(SSYS)\pcunix.c
X	$(CC) $(CFLAGS) /DOVL1 /DOVL2 /DOVL3 /DOVLB /Fo$(OBJ)\unix.1-b $(SSYS)\pcunix.c
X
X#
X#	$(WIN) files.
X#
X
X$(OBJ)\getline.0-1: $(HACK_H)	$(INCL)\wintty.h	$(INCL)\func_tab.h \
X	$(WIN)\getline.c
X	$(CC) $(CFLAGS) /DOVL0 /DOVL1 /NT$*.0-1 /Fo$(OBJ)\$*.0-1 $(WIN)\$*.c
X
X$(OBJ)\getline.2: $(HACK_H)	$(INCL)\wintty.h	$(INCL)\func_tab.h \
X	$(WIN)\getline.c
X	$(CC) $(CFLAGS) /DOVL2 /NT$*.2 /Fo$(OBJ)\$*.2 $(WIN)\$*.c
X
X$(OBJ)\getline.b: $(HACK_H)	$(INCL)\wintty.h	$(INCL)\func_tab.h \
X	$(WIN)\getline.c
X	$(CC) $(CFLAGS) /DOVLB /NT$*.b /Fo$(OBJ)\getline.b $(WIN)\$*.c
X
X$(OBJ)\termcap.0: $(HACK_H)	$(INCL)\wintty.h	$(INCL)\termcap.h \
X	$(WIN)\termcap.c
X	$(CC) $(CFLAGS) /DOVL0 /NT$*.0 /Fo$(OBJ)\$*.0 $(WIN)\$*.c
X
X$(OBJ)\termcap.1: $(HACK_H)	$(INCL)\wintty.h	$(INCL)\termcap.h \
X	$(WIN)\termcap.c
X	$(CC) $(CFLAGS) /DOVL1 /NT$*.1 /Fo$(OBJ)\$*.1 $(WIN)\$*.c
X
X$(OBJ)\termcap.2-b: $(HACK_H)	$(INCL)\wintty.h	$(INCL)\termcap.h \
X	$(WIN)\termcap.c
X	$(CC) $(CFLAGS) /DOVL2 /DOVLB /NT$*.2-b /Fo$(OBJ)\$*.2-b $(WIN)\$*.c
X
X$(OBJ)\topl.0: $(HACK_H)	$(INCL)\termcap.h	$(INCL)\wintty.h \
X	$(WIN)\topl.c
X	$(CC) $(CFLAGS) /DOVL0 /NT$*.0 /Fo$(OBJ)\$*.0 $(WIN)\$*.c
X
X$(OBJ)\topl.1-2: $(HACK_H)	$(INCL)\termcap.h	$(INCL)\wintty.h \
X	$(WIN)\topl.c
X	$(CC) $(CFLAGS) /DOVL1 /DOVL2 /NT$*.1-2 /Fo$(OBJ)\$*.1-2 $(WIN)\$*.c
X
X$(OBJ)\topl.b: $(HACK_H)	$(INCL)\termcap.h	$(INCL)\wintty.h \
X	$(WIN)\topl.c
X	$(CC) $(CFLAGS) /DOVLB /NT$*.b /Fo$(OBJ)\$*.b $(WIN)\$*.c
X
X$(OBJ)\wintty.o: $(HACK_H)	$(INCL)\wintty.h	$(INCL)\termcap.h \
X	$(WIN)\wintty.c
X	$(CC) $(CFLAGS) /DOVL0 /DOVL1 /DOVL2 /DOVLB /Fo$(OBJ)\$*.o $(WIN)\$*.c
X
X#
X#	$(SRC) files.
X#
X# DO NOT DELETE THIS LINE
X#
X
X$(OBJ)\allmain.0:	$(HACK_H)
X$(OBJ)\allmain.1:	$(HACK_H)
X$(OBJ)\allmain.2-b:	$(HACK_H)
X$(OBJ)\alloc.o:		$(CONFIG_H)
X$(OBJ)\apply.0:		$(HACK_H)	$(INCL)\edog.h
X$(OBJ)\apply.1:		$(HACK_H)	$(INCL)\edog.h
X$(OBJ)\apply.2-b:	$(HACK_H)	$(INCL)\edog.h
X$(OBJ)\artifact.0:	$(HACK_H)	$(INCL)\artifact.h  $(INCL)\artilist.h
X$(OBJ)\artifact.1:	$(HACK_H)	$(INCL)\artifact.h  $(INCL)\artilist.h
X$(OBJ)\artifact.2:	$(HACK_H)	$(INCL)\artifact.h  $(INCL)\artilist.h
X$(OBJ)\artifact.b:	$(HACK_H)	$(INCL)\artifact.h  $(INCL)\artilist.h
X$(OBJ)\attrib.0:	$(HACK_H)
X$(OBJ)\attrib.1:	$(HACK_H)
X$(OBJ)\attrib.2-b:	$(HACK_H)
X$(OBJ)\ball.o:		$(HACK_H)
X$(OBJ)\bones.o:		$(HACK_H)
X$(OBJ)\botl.0:		$(HACK_H)
X$(OBJ)\botl.1:		$(HACK_H)
X$(OBJ)\botl.2:		$(HACK_H)
X$(OBJ)\botl.b:		$(HACK_H)
X$(OBJ)\cmd.0:		$(HACK_H)	$(INCL)\func_tab.h
X$(OBJ)\cmd.1:		$(HACK_H)	$(INCL)\func_tab.h
X$(OBJ)\cmd.b:		$(HACK_H)	$(INCL)\func_tab.h
X$(OBJ)\dbridge.0:	$(HACK_H)
X$(OBJ)\dbridge.1-b:	$(HACK_H)
X$(OBJ)\decl.o:		$(HACK_H)	$(INCL)\quest.h
X$(OBJ)\detect.o:	$(HACK_H)	$(INCL)\artifact.h
X$(OBJ)\display.o:	$(HACK_H)
X$(OBJ)\do.0:		$(HACK_H)	$(INCL)\lev.h
X$(OBJ)\do.1:		$(HACK_H)	$(INCL)\lev.h
X$(OBJ)\do.2:		$(HACK_H)	$(INCL)\lev.h
X$(OBJ)\do.3:		$(HACK_H)	$(INCL)\lev.h
X$(OBJ)\do.b:		$(HACK_H)	$(INCL)\lev.h
X$(OBJ)\do_name.0:	$(HACK_H)
X$(OBJ)\do_name.1-b:	$(HACK_H)
X$(OBJ)\do_wear.0-1:	$(HACK_H)
X$(OBJ)\do_wear.2:	$(HACK_H)
X$(OBJ)\do_wear.b:	$(HACK_H)
X$(OBJ)\dog.0:		$(HACK_H)	$(INCL)\edog.h
X$(OBJ)\dog.1:		$(HACK_H)	$(INCL)\edog.h
X$(OBJ)\dog.2:		$(HACK_H)	$(INCL)\edog.h
X$(OBJ)\dog.b:		$(HACK_H)	$(INCL)\edog.h
X$(OBJ)\dogmove.0:	$(HACK_H)	$(INCL)\mfndpos.h	$(INCL)\edog.h
X$(OBJ)\dogmove.1-b:	$(HACK_H)	$(INCL)\mfndpos.h	$(INCL)\edog.h
X$(OBJ)\dokick.o:	$(HACK_H)	$(ESHK_H)
X$(OBJ)\dothrow.o:	$(HACK_H)
X$(OBJ)\drawing.o:	$(HACK_H)	$(INCL)\termcap.h
X$(OBJ)\dungeon.o:	$(HACK_H)	$(DGN_FILE_H)
X$(OBJ)\eat.0:		$(HACK_H)
X$(OBJ)\eat.1:		$(HACK_H)
X$(OBJ)\eat.2-b:		$(HACK_H)
X$(OBJ)\end.o:		$(HACK_H)	$(ESHK_H)
X$(OBJ)\engrave.0-1:	$(HACK_H)	$(INCL)\lev.h
X$(OBJ)\engrave.2:	$(HACK_H)	$(INCL)\lev.h
X$(OBJ)\engrave.b:	$(HACK_H)	$(INCL)\lev.h
X$(OBJ)\exper.o:		$(HACK_H)
X$(OBJ)\explode.o:	$(HACK_H)
X$(OBJ)\extralev.o:	$(HACK_H)
X$(OBJ)\files.o:		$(HACK_H)
X$(OBJ)\fountain.o:	$(HACK_H)
X$(OBJ)\hack.0:		$(HACK_H)
X$(OBJ)\hack.1:		$(HACK_H)
X$(OBJ)\hack.2:		$(HACK_H)
X$(OBJ)\hack.b:		$(HACK_H)
X$(OBJ)\hacklib.0:	$(HACK_H)
X$(OBJ)\hacklib.1:	$(HACK_H)
X$(OBJ)\hacklib.2-b:	$(HACK_H)
X$(OBJ)\invent.0:	$(HACK_H)	$(INCL)\artifact.h
X$(OBJ)\invent.1:	$(HACK_H)	$(INCL)\artifact.h
X$(OBJ)\invent.2:	$(HACK_H)	$(INCL)\artifact.h
X$(OBJ)\invent.3:	$(HACK_H)	$(INCL)\artifact.h
X$(OBJ)\invent.b:	$(HACK_H)	$(INCL)\artifact.h
X$(OBJ)\lock.0:		$(HACK_H)
X$(OBJ)\lock.1-b:	$(HACK_H)
X$(OBJ)\mail.0:		$(HACK_H)	$(INCL)\mail.h
X$(OBJ)\mail.1-b:	$(HACK_H)	$(INCL)\mail.h
X$(OBJ)\makemon.0-2:	$(HACK_H)	$(EPRI_H)	$(EMIN_H)
X$(OBJ)\makemon.b:	$(HACK_H)	$(EPRI_H)	$(EMIN_H)
X$(OBJ)\mcastu.o:	$(HACK_H)
X$(OBJ)\mhitm.0:		$(HACK_H)	$(INCL)\artifact.h	$(INCL)\edog.h
X$(OBJ)\mhitm.1-b:	$(HACK_H)	$(INCL)\artifact.h	$(INCL)\edog.h
X$(OBJ)\mhitu.0-1:	$(HACK_H)	$(INCL)\artifact.h	$(INCL)\edog.h
X$(OBJ)\mhitu.2-b:	$(HACK_H)	$(INCL)\artifact.h	$(INCL)\edog.h
X$(OBJ)\minion.o:	$(HACK_H)	$(EMIN_H)
X$(OBJ)\mklev.o:		$(HACK_H)
X$(OBJ)\mkmaze.o:	$(HACK_H)	$(SP_LEV_H)
X$(OBJ)\mkobj.0:		$(HACK_H)	$(INCL)\artifact.h	$(INCL)\prop.h
X$(OBJ)\mkobj.1:		$(HACK_H)	$(INCL)\artifact.h	$(INCL)\prop.h
X$(OBJ)\mkobj.2-b:	$(HACK_H)	$(INCL)\artifact.h	$(INCL)\prop.h
X$(OBJ)\mkroom.0:	$(HACK_H)
X$(OBJ)\mkroom.1-b:	$(HACK_H)
X$(OBJ)\mon.0-1:		$(HACK_H)	$(INCL)\mfndpos.h	$(INCL)\edog.h
X$(OBJ)\mon.2-b:		$(HACK_H)	$(INCL)\mfndpos.h	$(INCL)\edog.h
X$(OBJ)\mondata.0-1:	$(HACK_H)	$(ESHK_H)	$(EPRI_H)
X$(OBJ)\mondata.2:	$(HACK_H)	$(ESHK_H)	$(EPRI_H)
X$(OBJ)\mondata.b:	$(HACK_H)	$(ESHK_H)	$(EPRI_H)
X$(OBJ)\monmove.0-1:	$(HACK_H)	$(INCL)\mfndpos.h $(INCL)\artifact.h
X$(OBJ)\monmove.2-b:	$(HACK_H)	$(INCL)\mfndpos.h $(INCL)\artifact.h
X$(OBJ)\monst.o:		$(CONFIG_H)	$(PERMONST_H)	$(INCL)\monsym.h \
X			$(ESHK_H)	$(VAULT_H)	$(EPRI_H) \
X			$(INCL)\color.h
X$(OBJ)\monstr.o:	$(CONFIG_H)
X$(OBJ)\mplayer.o:	$(HACK_H)
X$(OBJ)\mthrowu.0:	$(HACK_H)
X$(OBJ)\mthrowu.1:	$(HACK_H)
X$(OBJ)\mthrowu.2-b:	$(HACK_H)
X$(OBJ)\muse.o:		$(HACK_H)
X$(OBJ)\music.o:		$(HACK_H)
X$(OBJ)\o_init.o:	$(HACK_H)
X$(OBJ)\objects.o:	$(CONFIG_H)	$(INCL)\obj.h	$(INCL)\objclass.h \
X			$(INCL)\prop.h	$(INCL)\color.h
X$(OBJ)\objnam.0-1:	$(HACK_H)
X$(OBJ)\objnam.2-b:	$(HACK_H)
X$(OBJ)\options.o:	$(HACK_H)	$(INCL)\termcap.h
X$(OBJ)\pager.o:		$(HACK_H)
X	$(CC) $(CFLAGS) /Od /Fo$(OBJ)\$*.o $*.c
X$(OBJ)\pickup.o:	$(HACK_H)
X$(OBJ)\pline.o:		$(HACK_H)	$(EPRI_H)
X$(OBJ)\polyself.0-1:	$(HACK_H)
X$(OBJ)\polyself.2-b:	$(HACK_H)
X$(OBJ)\potion.o:	$(HACK_H)
X$(OBJ)\pray.o:		$(HACK_H)	$(EPRI_H)
X$(OBJ)\priest.0:	$(HACK_H)	$(INCL)\mfndpos.h	$(ESHK_H) \
X			$(EPRI_H)	$(EMIN_H)
X$(OBJ)\priest.1-b:	$(HACK_H)	$(INCL)\mfndpos.h	$(ESHK_H) \
X			$(EPRI_H)	$(EMIN_H)
X$(OBJ)\quest.o:		$(HACK_H)	$(INCL)\quest.h	$(INCL)\qtext.h
X$(OBJ)\questpgr.o:	$(HACK_H)	$(INCL)\qtext.h
X$(OBJ)\read.0:		$(HACK_H)
X$(OBJ)\read.1-b:	$(HACK_H)
X$(OBJ)\rect.o:		$(HACK_H)
X$(OBJ)\restore.o:	$(HACK_H)	$(INCL)\lev.h	$(INCL)\termcap.h \
X			$(INCL)\quest.h
X$(OBJ)\rip.o:		$(HACK_H)
X$(OBJ)\rnd.0:		$(HACK_H)
X$(OBJ)\rnd.1:		$(HACK_H)
X$(OBJ)\rnd.2-b:		$(HACK_H)
X$(OBJ)\rumors.o:	$(HACK_H)
X$(OBJ)\save.o:		$(HACK_H)	$(INCL)\lev.h	$(INCL)\quest.h
X$(OBJ)\shk.0:		$(HACK_H)	$(ESHK_H)
X$(OBJ)\shk.1-b:		$(HACK_H)	$(ESHK_H)
X$(OBJ)\shknam.0:	$(HACK_H)	$(ESHK_H)
X$(OBJ)\shknam.1-b:	$(HACK_H)	$(ESHK_H)
X$(OBJ)\sit.o:		$(HACK_H)	$(INCL)\artifact.h
X$(OBJ)\sounds.0:	$(HACK_H)	$(INCL)\edog.h	$(ESHK_H)
X$(OBJ)\sounds.1-b:	$(HACK_H)	$(INCL)\edog.h	$(ESHK_H)
X$(OBJ)\sp_lev.o:	$(HACK_H)	$(SP_LEV_H)	$(INCL)\rect.h
X$(OBJ)\spell.o:		$(HACK_H)
X$(OBJ)\steal.0-1:	$(HACK_H)
X$(OBJ)\steal.2-b:	$(HACK_H)
X$(OBJ)\timeout.0:	$(HACK_H)
X$(OBJ)\timeout.1-b:	$(HACK_H)
X$(OBJ)\topten.o:	$(HACK_H)
X$(OBJ)\track.0:		$(HACK_H)
X$(OBJ)\track.1:		$(HACK_H)
X$(OBJ)\track.2-b:	$(HACK_H)
X$(OBJ)\trap.0-1:	$(HACK_H)	$(INCL)\edog.h
X$(OBJ)\trap.2:		$(HACK_H)	$(INCL)\edog.h
X$(OBJ)\trap.b:		$(HACK_H)	$(INCL)\edog.h
X$(OBJ)\u_init.o:	$(HACK_H)
X$(OBJ)\uhitm.o:		$(HACK_H)	$(INCL)\artifact.h
X$(OBJ)\vault.0:		$(HACK_H)	$(VAULT_H)
X$(OBJ)\vault.1-b:	$(HACK_H)	$(VAULT_H)
X$(OBJ)\version.o:	$(HACK_H)	$(INCL)\date.h	$(INCL)\patchlev.h
X$(OBJ)\vision.o:	$(HACK_H)	$(INCL)\vis_tab.h
X$(OBJ)\vis_tab.o:	$(HACK_H)	$(INCL)\vis_tab.h
X$(OBJ)\weapon.0-1:	$(HACK_H)
X$(OBJ)\weapon.2-b:	$(HACK_H)
X$(OBJ)\were.0:		$(HACK_H)
X$(OBJ)\were.1-b:	$(HACK_H)
X$(OBJ)\wield.o:		$(HACK_H)
X$(OBJ)\wizard.0:	$(HACK_H)	$(INCL)\qtext.h
X$(OBJ)\wizard.1-b:	$(HACK_H)	$(INCL)\qtext.h
X$(OBJ)\worm.o:		$(HACK_H)	$(INCL)\lev.h
X$(OBJ)\worn.o:		$(HACK_H)
X$(OBJ)\write.o:		$(HACK_H)
X$(OBJ)\zap.o:		$(HACK_H)
END_OF_FILE
if test 23509 -ne `wc -c <'sys/msdos/MakeMSC.src'`; then
    echo shar: \"'sys/msdos/MakeMSC.src'\" unpacked with wrong size!
fi
# end of 'sys/msdos/MakeMSC.src'
fi
echo shar: End of archive 69 \(of 108\).
cp /dev/null ark69isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \
21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \
41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 \
61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 \
81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 \
101 102 103 104 105 106 107 108 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 108 archives.
    echo "Now execute 'rebuild.sh'"
    rm -f ark10[0-8]isdone ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
