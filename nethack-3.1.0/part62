Path: uunet!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v16i070:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Part62/108
Message-ID: <4373@master.CNA.TEK.COM>
Date: 1 Feb 93 19:49:56 GMT
Sender: news@master.CNA.TEK.COM
Lines: 2113
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1620

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 16, Issue 70
Archive-name: nethack31/Part62
Supersedes: nethack3p9: Volume 10, Issue 46-102
Environment: Amiga, Atari, Mac, MS-DOS, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 62 (of 108)."
# Contents:  dat/gehennom.des include/os2conf.h src/sp_lev.c2
# Wrapped by billr@saab on Wed Jan 27 16:09:11 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'dat/gehennom.des' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dat/gehennom.des'\"
else
echo shar: Extracting \"'dat/gehennom.des'\" \(19835 characters\)
sed "s/^X//" >'dat/gehennom.des' <<'END_OF_FILE'
X#	SCCS Id: @(#)gehennom.des	3.1	91/12/27
X#	Copyright (c) 1989 by Jean-Christophe Collet
X#	Copyright (c) 1992 by M. Stephenson and Izchak Miller
X# NetHack may be freely redistributed.  See license for details.
X#
X
XMAZE: "valley", ' '
XFLAGS: hardfloor
XGEOMETRY:center,center
XMAP
X----------------------------------------------------------------------------
X|...S.|..|.....|  |.....-|      |................|   |...............| |...|
X|---|.|.--.---.|  |......--- ----..........-----.-----....---........---.-.|
X|   |.|.|..| |.| --........| |.............|   |.......---| |-...........--|
X|   |...S..| |.| |.......-----.......------|   |--------..---......------- |
X|----------- |.| |-......| |....|...-- |...-----................----       |
X|.....S....---.| |.......| |....|...|  |..............-----------          |
X|.....|.|......| |.....--- |......---  |....---.......|                    |
X|.....|.|------| |....--   --....-- |-------- ----....---------------      |
X|.....|--......---BBB-|     |...--  |.......|    |..................|      |
X|..........||........-|    --...|   |.......|    |...||.............|      |
X|.....|...-||-........------....|   |.......---- |...||.............--     |
X|.....|--......---...........--------..........| |.......---------...--    |
X|.....| |------| |--.......--|   |..B......----- -----....| |.|  |....---  |
X|.....| |......--| ------..| |----..B......|       |.--------.-- |-.....---|
X|------ |........|  |.|....| |.....----BBBB---------...........---.........|
X|       |........|  |...|..| |.....|  |-.............--------...........---|
X|       --.....-----------.| |....-----.....----------     |.........----  |
X|        |..|..B...........| |.|..........|.|              |.|........|    |
X----------------------------------------------------------------------------
XENDMAP
X# Dungeon Description
X# The shrine to Moloch.
XREGION:(01,06,05,14),lit,"temple"
X# The Morgues
XREGION:(19,01,24,08),unlit,"morgue",filled,true
XREGION:(09,14,16,18),unlit,"morgue",filled,true
XREGION:(37,09,43,14),unlit,"morgue",filled,true
X# Stairs
XSTAIR:(01,01),down
X# Branch location
XBRANCH:(66,17,66,17),(0,0,0,0)
X
X# Secret Doors
XDOOR:locked,(04,01)
XDOOR:locked,(08,04)
XDOOR:locked,(06,06)
X
X# The altar of Moloch.
XALTAR:(03,10),noalign,shrine
X
X# Non diggable walls - everywhere!
XNON_DIGGABLE:(00,00,75,19)
X
X# Objects
X# **LOTS** of dead bodies (all human).
X# note: no priest(esse)s - maybe Moloch has a *special*
X#       fate reserved for members of *that* class.
X#
XOBJECT:'%',"corpse",random,"archeologist",0
XOBJECT:'%',"corpse",random,"archeologist",0
XOBJECT:'%',"corpse",random,"barbarian",0
XOBJECT:'%',"corpse",random,"barbarian",0
XOBJECT:'%',"corpse",random,"caveman",0
XOBJECT:'%',"corpse",random,"cavewoman",0
XOBJECT:'%',"corpse",random,"healer",0
XOBJECT:'%',"corpse",random,"healer",0
XOBJECT:'%',"corpse",random,"knight",0
XOBJECT:'%',"corpse",random,"knight",0
XOBJECT:'%',"corpse",random,"rogue",0
XOBJECT:'%',"corpse",random,"rogue",0
XOBJECT:'%',"corpse",random,"samurai",0
XOBJECT:'%',"corpse",random,"samurai",0
XOBJECT:'%',"corpse",random,"tourist",0
XOBJECT:'%',"corpse",random,"tourist",0
XOBJECT:'%',"corpse",random,"valkyrie",0
XOBJECT:'%',"corpse",random,"valkyrie",0
XOBJECT:'%',"corpse",random,"wizard",0
XOBJECT:'%',"corpse",random,"wizard",0
X#
X# Some random weapons and armor.
X#
XOBJECT:'[',random,random
XOBJECT:'[',random,random
XOBJECT:'[',random,random
XOBJECT:'[',random,random
XOBJECT:')',random,random
XOBJECT:')',random,random
XOBJECT:')',random,random
XOBJECT:')',random,random
X#
X# Some random loot.
X#
XOBJECT:'*',"ruby",random
XOBJECT:'*',random,random
XOBJECT:'*',random,random
XOBJECT:'!',random,random
XOBJECT:'!',random,random
XOBJECT:'!',random,random
XOBJECT:'?',random,random
XOBJECT:'?',random,random
XOBJECT:'?',random,random
XOBJECT:'/',random,random
XOBJECT:'/',random,random
XOBJECT:'=',random,random
XOBJECT:'=',random,random
XOBJECT:'+',random,random
XOBJECT:'+',random,random
XOBJECT:'(',random,random
XOBJECT:'(',random,random
XOBJECT:'(',random,random
X
X# (Not so) Random traps.
XTRAP:"spiked pit", (05,02)
XTRAP:"spiked pit", (14,05)
XTRAP:"sleep gas", (03,01)
XTRAP:"board", (21,12)
XTRAP:"board", random
XTRAP:"dart", (60,01)
XTRAP:"dart", (26,17)
XTRAP:"anti magic", random
XTRAP:"anti magic", random
XTRAP:"magic", random
XTRAP:"magic", random
X
X# Random monsters.
X# The ghosts.
XMONSTER:' ',"ghost",random
XMONSTER:' ',"ghost",random
XMONSTER:' ',"ghost",random
XMONSTER:' ',"ghost",random
XMONSTER:' ',"ghost",random
XMONSTER:' ',"ghost",random
X# Add a few bats for atmosphere.
XMONSTER:'B',"vampire bat",random
XMONSTER:'B',"vampire bat",random
XMONSTER:'B',"vampire bat",random
X# And a lich for good measure.
XMONSTER:'L',random,random
X# Some undead nasties for good measure
XMONSTER:'V',random,random
XMONSTER:'V',random,random
XMONSTER:'V',random,random
XMONSTER:'Z',random,random
XMONSTER:'Z',random,random
XMONSTER:'Z',random,random
XMONSTER:'Z',random,random
XMONSTER:'M',random,random
XMONSTER:'M',random,random
XMONSTER:'M',random,random
XMONSTER:'M',random,random
X#
X# The Juiblex level
X#
XMAZE:"juiblex",' '
XFLAGS:noteleport
XINIT_MAP:'.','}',true,true,unlit,false
XGEOMETRY:center,center
XMAP
X..}}}}}.}}}}}.}}}}}.}}}}}.}}}}}.}}}}}.}}}}}.}}}}}..
X.}}}.}}}}}..}}}..}}}}}..}}}..}}}}}..}}}..}}}}}.}}}.
X}}}...}}..}}.}.}}.}}.}}}...}}}.}}}..}}}..}}}}...}}}
X.}}}.}}.}}}.}}.}}.}}...}}.}}.....}}.....}....}.}}}.
X..}}}..}}}.}}.}}.}}..}}.....}}.}}}.}}.}}}}}}}}}}}..
X.}}}..}}}}}.}}.}}.}}...}}}}}.....}}.}}}}}}.....}}}.
X}}}..}}...}}..}}.}}}.}}}...}}}.}}}.}.}}}}..P.P..}}}
X}}.}}}}...}}}}}.}...}}}..P..}}}.}.}}}.}}}}.....}}}}
X}.}}}}.}}.}..}.}}}}}}}..P.P..}}}.}}}.}}..}}...}}}}.
X.}}}}.}}}}....}}}}}.}}}..P..}}}.}}}}.}}..}}...}}}.}
X}}}}..}}.}}..}}}}...}}}}...}}}.}}}}}.}}}}.}}}}}}.}}
X}}}...}}...}}}..}}}}}}}}}}}}.....}}}}.}}...}..}.}}}
X.}}}..}}.}}}}....}}..}}}..}}.....}}}}.}}}.}....}}}.
X..}}}.}}}}..}}..}}..}}..}}..}}.}}}..}.}..}}}..}}}..
X.}}}.}}}}....}}}}..}}....}}}}}}}...}}}....}}}}.}}}.
X}}}...}}}....}}}..}}}....}}}..}}...}}}....}}}...}}}
X.}}}.}}}}}..}}}..}}}}}..}}}..}}}}}..}}}..}}}}}.}}}.
X..}}}}}.}}}}}.}}}}}.}}}}}.}}}}}.}}}}}.}}}}}.}}}}}..
XENDMAP
X# Random registers
XRANDOM_MONSTERS:'J','b','P','F'
XRANDOM_PLACES:(04,02),(46,02),(04,15),(46,15)
X# Dungeon description
XREGION:(00,00,50,17),unlit,"swamp"
XMAZEWALK:(00,09),west
XMAZEWALK:(50,08),east
XSTAIR:levregion(01,00,08,20),(0,0,50,17),down
XSTAIR:levregion(69,00,79,20),(0,0,50,17),up
XBRANCH:levregion(01,00,08,20),(0,0,50,17)
XTELEPORT_REGION:levregion(01,00,08,20),(0,0,50,17),up
XTELEPORT_REGION:levregion(69,00,79,20),(0,0,50,17),down
XFOUNTAIN:place[0]
XMONSTER:'m',"giant mimic",place[1],m_feature "fountain"
XMONSTER:'m',"giant mimic",place[2],m_feature "fountain"
XMONSTER:'m',"giant mimic",place[3],m_feature "fountain"
X# The demon of the swamp
XMONSTER:'&',"Juiblex",(25,08)
X# And a couple demons
XMONSTER:'i',"lemure",(43,08)
XMONSTER:'i',"lemure",(44,08)
XMONSTER:'i',"lemure",(45,08)
X# Some liquids and gems
XOBJECT:'*',random,(43,06)
XOBJECT:'*',random,(45,06)
XOBJECT:'!',random,(43,09)
XOBJECT:'!',random,(44,09)
XOBJECT:'!',random,(45,09)
X# And lots of blobby monsters
XMONSTER:monster[0],random,(25,06)
XMONSTER:monster[1],random,(24,07)
XMONSTER:monster[2],random,(26,07)
XMONSTER:monster[3],random,(23,08)
XMONSTER:monster[3],random,(27,08)
XMONSTER:monster[2],random,(24,09)
XMONSTER:monster[1],random,(26,09)
XMONSTER:monster[0],random,(25,10)
XMONSTER:'J',random,random
XMONSTER:'J',random,random
XMONSTER:'J',random,random
XMONSTER:'J',random,random
XMONSTER:'P',random,random
XMONSTER:'P',random,random
XMONSTER:'P',random,random
XMONSTER:'P',random,random
XMONSTER:'b',random,random
XMONSTER:'b',random,random
XMONSTER:'b',random,random
XMONSTER:'F',random,random
XMONSTER:'F',random,random
XMONSTER:'F',random,random
XMONSTER:'m',random,random
XMONSTER:'m',random,random
X# Some random objects
XOBJECT:'!',random,random
XOBJECT:'!',random,random
XOBJECT:'!',random,random
XOBJECT:'%',random,random
XOBJECT:'%',random,random
XOBJECT:'%',random,random
X# Some traps
XTRAP:"sleep gas",random
XTRAP:"sleep gas",random
XTRAP:"anti magic",random
XTRAP:"anti magic",random
XTRAP:"magic",random
XTRAP:"magic",random
X#
X# The Orcus Level
X#
XMAZE:"orcus",random
XFLAGS: noteleport,shortsighted
XGEOMETRY:right,center
X# A ghost town
XMAP
X.|....|....|....|..............|....|........
X.|....|....|....|..............|....|........
X.|....|....|....|--...-+-------|.............
X.|....|....|....|..............+.............
X.|.........|....|..............|....|........
X.--+-...-+----+--....-------...--------.+----
X.....................|.....|.................
X.....................|.....|.................
X.--+----....-+---....|.....|...----------+---
X.|....|....|....|....---+---...|......|......
X.|.........|....|..............|......|......
X.----...---------.....-----....+......|......
X.|........................|....|......|......
X.----------+-...--+--|....|....----------+---
X.|....|..............|....+....|.............
X.|....+.......|......|....|....|.............
X.|....|.......|......|....|....|.............
XENDMAP
XMAZEWALK:(00,06),west
X# Entire main area
XREGION:(01,00,44,16),unlit,"ordinary"
XSTAIR:(33,15),down
XSTAIR:levregion(01,00,12,20),levregion(20,01,70,20),up
XBRANCH:levregion(01,00,12,20),levregion(20,01,70,20)
XTELEPORT_REGION:levregion(01,00,12,20),levregion(20,01,70,20)
X# Wall "ruins"
XOBJECT:'`',"boulder",(19,02)
XOBJECT:'`',"boulder",(20,02)
XOBJECT:'`',"boulder",(21,02)
XOBJECT:'`',"boulder",(36,02)
XOBJECT:'`',"boulder",(36,03)
XOBJECT:'`',"boulder",(06,04)
XOBJECT:'`',"boulder",(05,05)
XOBJECT:'`',"boulder",(06,05)
XOBJECT:'`',"boulder",(07,05)
XOBJECT:'`',"boulder",(39,05)
XOBJECT:'`',"boulder",(08,08)
XOBJECT:'`',"boulder",(09,08)
XOBJECT:'`',"boulder",(10,08)
XOBJECT:'`',"boulder",(11,08)
XOBJECT:'`',"boulder",(06,10)
XOBJECT:'`',"boulder",(05,11)
XOBJECT:'`',"boulder",(06,11)
XOBJECT:'`',"boulder",(07,11)
XOBJECT:'`',"boulder",(21,11)
XOBJECT:'`',"boulder",(21,12)
XOBJECT:'`',"boulder",(13,13)
XOBJECT:'`',"boulder",(14,13)
XOBJECT:'`',"boulder",(15,13)
XOBJECT:'`',"boulder",(14,14)
X# Doors
XDOOR:closed,(23,02)
XDOOR:open,(31,03)
XDOOR:nodoor,(03,05)
XDOOR:closed,(09,05)
XDOOR:closed,(14,05)
XDOOR:closed,(40,05)
XDOOR:open,(03,08)
XDOOR:nodoor,(13,08)
XDOOR:open,(41,08)
XDOOR:closed,(24,09)
XDOOR:closed,(31,11)
XDOOR:open,(11,13)
XDOOR:closed,(18,13)
XDOOR:closed,(41,13)
XDOOR:open,(26,14)
XDOOR:closed,(06,15)
X# Special rooms
XALTAR:(24,07),noalign,sanctum
XREGION:(22,12,25,16),unlit,"morgue"
XREGION:(32,09,37,12),lit,"shop"
XREGION:(12,00,15,04),lit,"shop"
X# Some traps.
XTRAP:"spiked pit", random
XTRAP:"sleep gas", random
XTRAP:"anti magic", random
XTRAP:"fire", random
XTRAP:"fire", random
XTRAP:"fire", random
XTRAP:"magic", random
XTRAP:"magic", random
X# Some random objects
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
X# The resident nasty
XMONSTER:'&',"Orcus",(33,15)
X# And its preferred companions
XMONSTER:'Z',"human zombie",(32,15)
XMONSTER:' ',"shade",(32,14)
XMONSTER:' ',"shade",(32,16)
XMONSTER:'V',"vampire",(35,16)
XMONSTER:'V',"vampire",(35,14)
XMONSTER:'V',"vampire lord",(36,14)
XMONSTER:'V',"vampire lord",(36,15)
X# Randomly placed companions
XMONSTER:'Z',"skeleton",random
XMONSTER:'Z',"skeleton",random
XMONSTER:'Z',"skeleton",random
XMONSTER:'Z',"skeleton",random
XMONSTER:'Z',"skeleton",random
XMONSTER:' ',"shade",random
XMONSTER:' ',"shade",random
XMONSTER:' ',"shade",random
XMONSTER:' ',"shade",random
XMONSTER:'Z',"giant zombie",random
XMONSTER:'Z',"giant zombie",random
XMONSTER:'Z',"giant zombie",random
XMONSTER:'Z',"ettin zombie",random
XMONSTER:'Z',"ettin zombie",random
XMONSTER:'Z',"ettin zombie",random
XMONSTER:'Z',"human zombie",random
XMONSTER:'Z',"human zombie",random
XMONSTER:'Z',"human zombie",random
XMONSTER:'V',"vampire",random
XMONSTER:'V',"vampire",random
XMONSTER:'V',"vampire",random
XMONSTER:'V',"vampire lord",random
XMONSTER:'V',"vampire lord",random
X# A few more for the party
XMONSTER:random,random,random
XMONSTER:random,random,random
XMONSTER:random,random,random
XMONSTER:random,random,random
XMONSTER:random,random,random
X#
X# The Asmodeus Level
X#
XMAZE:"asmodeus",random
XFLAGS: noteleport
X# First part
XGEOMETRY:half-left,center
XMAP
X---------------------
X|.............|.....|
X|.............S.....|
X|---+------------...|
X|.....|.........|-+--
X|..---|.........|....
X|..|..S.........|....
X|..|..|.........|....
X|..|..|.........|-+--
X|..|..-----------...|
X|..S..........|.....|
X---------------------
XENDMAP
XSTAIR:levregion(01,00,6,20),levregion(6,1,70,16),up
XBRANCH:levregion(01,00,6,20),levregion(6,1,70,16)
XTELEPORT_REGION:levregion(01,00,6,20),levregion(6,1,70,16)
X
X# Doors
XDOOR:closed,(04,03)
XDOOR:locked,(18,04)
XDOOR:closed,(18,08)
X#
XSTAIR:(13,07),down
X# Non diggable walls
XNON_DIGGABLE:(00,00,20,11)
X# Entire main area
XREGION:(01,01,20,10),unlit,"ordinary"
X# The fellow in residence
XMONSTER:'&',"Asmodeus",(12,07)
X# Some random weapons and armor.
XOBJECT:'[',random,random
XOBJECT:'[',random,random
XOBJECT:')',random,random
XOBJECT:')',random,random
XOBJECT:'*',random,random
XOBJECT:'!',random,random
XOBJECT:'!',random,random
XOBJECT:'?',random,random
XOBJECT:'?',random,random
XOBJECT:'?',random,random
X# Some traps.
XTRAP:"spiked pit", (05,02)
XTRAP:"fire", (08,06)
XTRAP:"sleep gas", random
XTRAP:"anti magic", random
XTRAP:"fire", random
XTRAP:"magic", random
XTRAP:"magic", random
X# Random monsters.
XMONSTER:' ',"ghost",(11,07)
XMONSTER:'&',"horned devil",(10,05)
XMONSTER:'L',random,random
X# Some Vampires for good measure
XMONSTER:'V',random,random
XMONSTER:'V',random,random
XMONSTER:'V',random,random
X# Second part
XGEOMETRY:half-right,center
XMAP
X---------------------------------
X................................|
X................................+
X................................|
X---------------------------------
XENDMAP
XMAZEWALK:(32,02),east
X# Non diggable walls
XNON_DIGGABLE:(00,00,32,04)
XDOOR:closed,(32,02)
XMONSTER:'&',random,random
XMONSTER:'&',random,random
XMONSTER:'&',random,random
XTRAP:"anti magic", random
XTRAP:"fire", random
XTRAP:"magic", random
X
X#
X# The Baalzebub level
X#
XMAZE:"baalz",random
XFLAGS: noteleport
XGEOMETRY:right,center
XMAP
X-------------------------------------------------
X|                    ---               ----      
X|          ----      |   ------------  |         
X| ------      |  --------|..........|---         
X| |....|  -------|...........--------------      
X---....|--|..................S............|----  
X....--....S..----------------|............S...|  
X---....|--|..................|............|----  
X| |....|  -------|...........-----S--------      
X| ------      |  --------|..........|---         
X|          ----     |    ------------  |         
X|                   ---                ----      
X-------------------------------------------------
XENDMAP
XSTAIR:levregion(01,00,15,20),levregion(15,1,70,16),up
XBRANCH:levregion(01,00,15,20),levregion(15,1,70,16)
XTELEPORT_REGION:levregion(01,00,15,20),levregion(15,1,70,16)
XNON_DIGGABLE:(00,00,46,12)
XMAZEWALK:(00,06),west
XSTAIR:(44,06),down
X# The fellow in residence
XMONSTER:'&',"Baalzebub",(35,06)
X# Some random weapons and armor.
XOBJECT:'[',random,random
XOBJECT:'[',random,random
XOBJECT:')',random,random
XOBJECT:')',random,random
XOBJECT:'*',random,random
XOBJECT:'!',random,random
XOBJECT:'!',random,random
XOBJECT:'?',random,random
XOBJECT:'?',random,random
XOBJECT:'?',random,random
X# Some traps.
XTRAP:"spiked pit", random
XTRAP:"fire", random
XTRAP:"sleep gas", random
XTRAP:"anti magic", random
XTRAP:"fire", random
XTRAP:"magic", random
XTRAP:"magic", random
X# Random monsters.
XMONSTER:' ',"ghost",(37,07)
XMONSTER:'&',"horned devil",(32,05)
XMONSTER:'&',"barbed devil",(38,07)
XMONSTER:'L',random,random
X# Some Vampires for good measure
XMONSTER:'V',random,random
XMONSTER:'V',random,random
XMONSTER:'V',random,random
X#
X# The Sanctum Level
X#
XMAZE:"sanctum", ' '
XFLAGS: noteleport,hardfloor
XGEOMETRY:center,center
XMAP
X----------------------------------------------------------------------------
X|             --------------                                               |
X|             |............|             -------                           |
X|       -------............-----         |.....|                           |
X|       |......................|        --.....|            ---------      |
X|    ----......................---------|......----         |.......|      |
X|    |........---------..........|......+.........|     ------+---..|      |
X|  ---........|.......|..........--S----|.........|     |........|..|      |
X|  |..........|.......|.............|   |.........-------..----------      |
X|  |..........|.......|..........----   |..........|....|..|......|        |
X|  |..........|.......|..........|      --.......----+---S---S--..|        |
X|  |..........---------..........|       |.......|.............|..|        |
X|  ---...........................|       -----+-------S---------S---       |
X|    |...........................|          |...| |......|    |....|--     |
X|    ----.....................----          |...---....---  ---......|     |
X|       |.....................|             |..........|    |.....----     |
X|       -------...........-----             --...-------    |.....|        |
X|             |...........|                  |...|          |.....|        |
X|             -------------                  -----          -------        |
X----------------------------------------------------------------------------
XENDMAP
XREGION:(15,07,21,10),lit,"temple"
XALTAR:(18,08),noalign,sanctum
XREGION:(41,06,48,11),unlit,"morgue",filled,true
X# Non diggable walls
XNON_DIGGABLE:(00,00,75,19)
X# Doors
XDOOR:closed,(40,06)
XDOOR:locked,(62,06)
XDOOR:closed,(46,12)
XDOOR:closed,(53,10)
X# Surround the temple with fire
XTRAP:"fire",(13,05)
XTRAP:"fire",(14,05)
XTRAP:"fire",(15,05)
XTRAP:"fire",(16,05)
XTRAP:"fire",(17,05)
XTRAP:"fire",(18,05)
XTRAP:"fire",(19,05)
XTRAP:"fire",(20,05)
XTRAP:"fire",(21,05)
XTRAP:"fire",(22,05)
XTRAP:"fire",(23,05)
XTRAP:"fire",(13,12)
XTRAP:"fire",(14,12)
XTRAP:"fire",(15,12)
XTRAP:"fire",(16,12)
XTRAP:"fire",(17,12)
XTRAP:"fire",(18,12)
XTRAP:"fire",(19,12)
XTRAP:"fire",(20,12)
XTRAP:"fire",(21,12)
XTRAP:"fire",(22,12)
XTRAP:"fire",(23,12)
XTRAP:"fire",(13,06)
XTRAP:"fire",(13,07)
XTRAP:"fire",(13,08)
XTRAP:"fire",(13,09)
XTRAP:"fire",(13,10)
XTRAP:"fire",(13,11)
XTRAP:"fire",(23,06)
XTRAP:"fire",(23,07)
XTRAP:"fire",(23,08)
XTRAP:"fire",(23,09)
XTRAP:"fire",(23,10)
XTRAP:"fire",(23,11)
X# Some traps.
XTRAP:"spiked pit", random
XTRAP:"fire", random
XTRAP:"sleep gas", random
XTRAP:"anti magic", random
XTRAP:"fire", random
XTRAP:"magic", random
X# Some random objects
XOBJECT:'[',random,random
XOBJECT:'[',random,random
XOBJECT:'[',random,random
XOBJECT:'[',random,random
XOBJECT:')',random,random
XOBJECT:')',random,random
XOBJECT:'*',random,random
XOBJECT:'!',random,random
XOBJECT:'!',random,random
XOBJECT:'!',random,random
XOBJECT:'!',random,random
XOBJECT:'?',random,random
XOBJECT:'?',random,random
XOBJECT:'?',random,random
XOBJECT:'?',random,random
XOBJECT:'?',random,random
X# Some monsters.
XMONSTER:'&',"horned devil",(14,12),hostile
XMONSTER:'&',"barbed devil",(18,08),hostile
XMONSTER:'&',"erinyes",(10,04),hostile
XMONSTER:'&',"marilith",(15,04),hostile
XMONSTER:'&',"nalfeshnee",(27,08),hostile
X# Moloch's horde
XMONSTER:'@',"aligned priest",(20,03),noalign,hostile
XMONSTER:'@',"aligned priest",(15,04),noalign,hostile
XMONSTER:'@',"aligned priest",(11,05),noalign,hostile
XMONSTER:'@',"aligned priest",(11,07),noalign,hostile
XMONSTER:'@',"aligned priest",(11,09),noalign,hostile
XMONSTER:'@',"aligned priest",(11,12),noalign,hostile
XMONSTER:'@',"aligned priest",(15,13),noalign,hostile
XMONSTER:'@',"aligned priest",(17,13),noalign,hostile
XMONSTER:'@',"aligned priest",(21,13),noalign,hostile
X# A few nasties
XMONSTER:'L',random,random
XMONSTER:'L',random,random
XMONSTER:'V',random,random
XMONSTER:'V',random,random
XMONSTER:'V',random,random
XSTAIR:(63,15),up
END_OF_FILE
if test 19835 -ne `wc -c <'dat/gehennom.des'`; then
    echo shar: \"'dat/gehennom.des'\" unpacked with wrong size!
fi
# end of 'dat/gehennom.des'
fi
if test -f 'include/os2conf.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/os2conf.h'\"
else
echo shar: Extracting \"'include/os2conf.h'\" \(2442 characters\)
sed "s/^X//" >'include/os2conf.h' <<'END_OF_FILE'
X/*	SCCS Id: @(#)os2conf.h	3.1	93/01/18 */
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* Copyright (c) Timo Hakulinen, 1990, 1991, 1992, 1993. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#ifdef OS2
X#ifndef OS2CONF_H
X#define OS2CONF_H
X
X/*
X * Compiler configuration.  Compiler may be
X * selected either here or in Makefile.os2.
X */
X
X/* #define OS2_MSC		/* Microsoft C 5.1 and 6.0 */
X/* #define OS2_GCC		/* GCC emx 0.8f */
X/* #define OS2_CSET2		/* IBM C Set/2 (courtesy Jeff Urlwin) */
X
X/*
X * System configuration.
X */
X
X#define OS2_USESYSHEADERS	/* use compiler's own system headers */
X
X#if defined(OS2_GCC) || defined(OS2_CSET2)
X# define OS2_32BITAPI		/* enable for compilation in OS/2 2.0 */
X#endif
X
X/*
X * Other configurable options.  Generally no
X * reason to touch the defaults, I think.
X */
X
X#define MFLOPPY			/* floppy and ramdisk support */
X#define RANDOM			/* Berkeley random(3) */
X#define SHELL			/* shell escape */
X/* #define TERMLIB		/* use termcap file */
X#define ANSI_DEFAULT		/* allows NetHack to run without termcap file */
X#define TEXTCOLOR		/* allow color */
X
X/*
X * The remaining code shouldn't need modification.
X */
X
X#ifdef MSDOS
X# undef MSDOS			/* MSC autodefines this but we don't want it */
X#endif
X
X#ifndef MICRO
X# define MICRO			/* must be defined to allow some inclusions */
X#endif
X
X#if !defined(TERMLIB) && !defined(ANSI_DEFAULT)
X# define ANSI_DEFAULT	/* have to have one or the other */
X#endif
X
X#define PATHLEN 	260	/* maximum pathlength (HPFS) */
X#define FILENAME	260	/* maximum filename length (HPFS) */
X#ifndef MICRO_H
X#include "micro.h"		/* necessary externs for [os_name].c */
X#endif
X
X#ifdef MFLOPPY
X
X# define FROMPERM	1	/* for ramdisk use */
X# define TOPERM		2	/* - " - */
X# define ACTIVE		1
X# define SWAPPED	2
X
Xstruct finfo {
X	int  where;
X	long time;
X	long size;
X};
Xextern struct finfo fileinfo[];
X# define ZFINFO { 0, 0L, 0L }
X
X#endif /* MFLOPPY */
X
X#ifndef SYSTEM_H
X# include "system.h"
X#endif
X
X#define index	strchr
X#define rindex	strrchr
X
X#include <time.h>
X
X/* the high quality random number routines */
X
X#ifdef RANDOM
X# define Rand()	random()
X#else
X# define Rand()	rand()
X#endif
X
X/* file creation mask */
X
X#include <sys\types.h>
X#include <sys\stat.h>
X
X#define FCMASK	(S_IREAD | S_IWRITE)
X
X#include <fcntl.h>
X
X#define exit	msexit		/* do chdir first */
X
X#ifndef REDO
X# undef	Getchar
X# define Getchar nhgetch
X#endif
X
X#endif /* OS2CONF_H */
X#endif /* OS2 */
END_OF_FILE
if test 2442 -ne `wc -c <'include/os2conf.h'`; then
    echo shar: \"'include/os2conf.h'\" unpacked with wrong size!
fi
# end of 'include/os2conf.h'
fi
if test -f 'src/sp_lev.c2' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/sp_lev.c2'\"
else
echo shar: Extracting \"'src/sp_lev.c2'\" \(32785 characters\)
sed "s/^X//" >'src/sp_lev.c2' <<'END_OF_FILE'
X/*
X * Disgusting hack: since special levels have their rooms filled before
X * sorting the rooms, we have to re-arrange the speed values upstairs_room
X * and dnstairs_room after the rooms have been sorted.  On normal levels,
X * stairs don't get created until _after_ sorting takes place.
X */
Xstatic void
Xfix_stair_rooms()
X{
X    register i;
X    register struct mkroom 	*croom;
X
X    if(xdnstair &&
X       !((dnstairs_room->lx <= xdnstair && xdnstair <= dnstairs_room->hx) &&
X	 (dnstairs_room->ly <= ydnstair && ydnstair <= dnstairs_room->hy))) {
X	for(i=0; i < nroom; i++) {
X	    croom = &rooms[i];
X	    if((croom->lx <= xdnstair && xdnstair <= croom->hx) &&
X	       (croom->ly <= ydnstair && ydnstair <= croom->hy)) {
X		dnstairs_room = croom;
X		break;
X	    }
X	}
X	if(i == nroom)
X	    panic("Couldn't find dnstair room in fix_stair_rooms!");
X    }
X    if(xupstair &&
X       !((upstairs_room->lx <= xupstair && xupstair <= upstairs_room->hx) &&
X	 (upstairs_room->ly <= yupstair && yupstair <= upstairs_room->hy))) {
X	for(i=0; i < nroom; i++) {
X	    croom = &rooms[i];
X	    if((croom->lx <= xupstair && xupstair <= croom->hx) &&
X	       (croom->ly <= yupstair && yupstair <= croom->hy)) {
X		upstairs_room = croom;
X		break;
X	    }
X	}
X	if(i == nroom)
X	    panic("Couldn't find upstair room in fix_stair_rooms!");
X    }
X}
X
X/* 
X * Corridors always start from a door. But it can end anywhere...
X * Basically we search for door coordinates or for endpoints coordinates
X * (from a distance).
X */
X
Xstatic void
Xcreate_corridor(c)
Xcorridor	*c;
X{
X	coord org, dest;
X
X	if (c->src.room == -1) {
X		sort_rooms();
X		fix_stair_rooms();
X		makecorridors();
X		return;
X	}
X
X	if( !search_door(&rooms[c->src.room], &org.x, &org.y, c->src.wall,
X			 c->src.door))
X	    return;
X
X	if (c->dest.room != -1) {
X		if(!search_door(&rooms[c->dest.room], &dest.x, &dest.y,
X				c->dest.wall, c->dest.door))
X		    return;
X		switch(c->src.wall) {
X		      case W_NORTH: org.y--; break;
X		      case W_SOUTH: org.y++; break;
X		      case W_WEST:  org.x--; break;
X		      case W_EAST:  org.x++; break;
X		}
X		switch(c->dest.wall) {
X		      case W_NORTH: dest.y--; break;
X		      case W_SOUTH: dest.y++; break;
X		      case W_WEST:  dest.x--; break;
X		      case W_EAST:  dest.x++; break;
X		}
X		(void) dig_corridor(org, dest, FALSE, CORR, STONE);
X	}
X}
X
X
X/* 
X * Fill a room (shop, zoo, etc...) with appropriate stuff.
X */
X
Xvoid
Xfill_room(croom, prefilled)
Xstruct mkroom 	*croom;
Xboolean prefilled;
X{
X	if (!croom || croom->rtype == OROOM)
X	    return;
X
X	if(prefilled) {
X	    switch(croom->rtype) {
X	    case COURT:
X		level.flags.has_court = 1;
X		break;
X#ifdef ARMY
X	    case BARRACKS:
X		level.flags.has_barracks = 1;
X		break;
X#endif
X	    case ZOO:
X		level.flags.has_zoo = 1;
X		break;
X	    case MORGUE:
X		level.flags.has_morgue = 1;
X		break;
X	    case SWAMP:
X		level.flags.has_swamp = 1;
X		break;
X	    case BEEHIVE:
X		level.flags.has_beehive = 1;
X		break;
X	    }
X	    return;
X	}
X	/* Vault ? */
X	if (croom->rtype == VAULT) {
X		int x,y;
X		for (x=croom->lx;x<=croom->hx;x++)
X		    for (y=croom->ly;y<=croom->hy;y++)
X			mkgold((long)rn1(depth(&u.uz)*100, 51), x, y);
X		return;
X	}
X
X	/* Shop ? */
X	if (croom->rtype >= SHOPBASE) {
X		stock_room(croom->rtype - SHOPBASE, croom);
X		return;
X	}
X
X	/* Zoo ? */
X	switch (croom->rtype) {
X	      case COURT:
X	      case ZOO:
X	      case BEEHIVE:
X	      case MORGUE:
X	      case BARRACKS:
X		fill_zoo(croom);
X		break;
X	}
X}
X
Xstatic void
Xfree_rooms(ro, n)
Xroom **ro;
Xint n;
X{
X	short j;
X	room *r;
X	
X	while(n--) {
X		r = ro[n];
X		Free(r->name);
X		Free(r->parent);
X		if (j = r->ndoor) {
X			while(j--)
X			    Free(r->doors[j]);
X			Free(r->doors);
X		}
X		if (j = r->ntrap) {
X			while (j--)
X			    Free(r->traps[j]);
X			Free(r->traps);
X		}
X		if (j = r->nmonster) {
X			while (j--) {
X				Free(r->monsters[j]->name);
X				Free(r->monsters[j]->appear_as);
X				Free(r->monsters[j]);
X			}
X			Free(r->monsters);
X		}
X		if (j = r->nobject) {
X			while(j--) {
X				Free(r->objects[j]->name);
X				Free(r->objects[j]);
X			}
X			Free(r->objects);
X		}
X		if (j = r->nstair) {
X			while(j--)
X			    Free(r->stairs[j]);
X			Free(r->stairs);
X		}
X		if (j = r->naltar) {
X			while (j--)
X			    Free(r->altars[j]);
X			Free(r->altars);
X		}
X		if (j = r->ngold) {
X			while(j--)
X			    Free(r->golds[j]);
X			Free(r->golds);
X		}
X		if (j = r->nengraving) {
X			while(j--) {
X				Free(r->engravings[j]->e.text);
X				Free(r->engravings[j]);
X			}
X			Free(r->engravings);
X		}
X		if (j = r->nfountain) {
X			while(j--)
X			    Free(r->fountains[j]);
X			Free(r->fountains);
X		}
X		if (j = r->nsink) {
X			while(j--)
X			    Free(r->sinks[j]);
X			Free(r->sinks);
X		}
X		if (j = r->npool) {
X			while(j--)
X			    Free(r->pools[j]);
X			Free(r->pools);
X		}
X		Free(r);
X	}
X}
X
Xstatic void
Xbuild_room(r, pr)
Xroom *r, *pr;
X{
X	boolean okroom;
X	struct mkroom	*aroom;
X	short i;
X	xchar rtype = (!r->chance || rn2(100) < r->chance) ? r->rtype : OROOM;
X
X	if(pr) {
X		aroom = &subrooms[nsubroom];
X		okroom = create_subroom(pr->mkr, r->x, r->y, r->w, r->h,
X					rtype, r->rlit);
X	} else {
X		aroom = &rooms[nroom];
X		okroom = create_room(r->x, r->y, r->w, r->h, r->xalign,
X				     r->yalign, rtype, r->rlit);
X		r->mkr = aroom;
X	}
X
X	if (okroom) {
X		/* Create subrooms if necessary... */
X		for(i=0; i < r->nsubroom; i++)
X		    build_room(r->subrooms[i], r);
X		/* And now we can fill the room! */
X		
X		/* Priority to the stairs */
X
X		for(i=0; i <r->nstair; i++)
X		    create_stairs(r->stairs[i], aroom);
X
X		/* Then to the various elements (sinks, etc..) */
X		for(i = 0; i<r->nsink; i++)
X		    create_feature(r->sinks[i]->x, r->sinks[i]->y, aroom, SINK);
X		for(i = 0; i<r->npool; i++)
X		    create_feature(r->pools[i]->x, r->pools[i]->y, aroom, POOL);
X		for(i = 0; i<r->nfountain; i++)
X		    create_feature(r->fountains[i]->x, r->fountains[i]->y,
X				   aroom, FOUNTAIN);
X		for(i = 0; i<r->naltar; i++)
X		    create_altar(r->altars[i], aroom);
X		for(i = 0; i<r->ndoor; i++)
X		    create_door(r->doors[i], aroom);
X
X		/* The traps */
X		for(i = 0; i<r->ntrap; i++)
X		    create_trap(r->traps[i], aroom);
X
X		/* The monsters */
X		for(i = 0; i<r->nmonster; i++)
X		    create_monster(r->monsters[i], aroom);
X
X		/* The objects */
X		for(i = 0; i<r->nobject; i++)
X		    create_object(r->objects[i], aroom);
X
X		/* The gold piles */
X		for(i = 0; i<r->ngold; i++)
X		    create_gold(r->golds[i], aroom);
X
X		/* The engravings */
X		for(i = 0; i<r->nengraving; i++) {
X			schar xx, yy;
X
X			xx = r->engravings[i]->x;
X			yy = r->engravings[i]->y;
X			get_room_loc(&xx, &yy, aroom);
X			make_engr_at(xx, yy, r->engravings[i]->e.text,
X				     0L, r->engravings[i]->etype);
X		}
X#ifdef SPECIALIZATION
X		topologize(aroom,FALSE);		/* set roomno */
X#else
X		topologize(aroom);			/* set roomno */
X#endif
X		/* MRS - 07/04/91 - This is temporary but should result
X		 * in proper filling of shops, etc.
X		 * DLC - this can fail if corridors are added to this room
X		 * at a later point.  Currently no good way to fix this.
X		 */
X		if(aroom->rtype != OROOM && r->filled) fill_room(aroom, FALSE);
X	}
X}
X
X/*
X * set lighting in a region that will not become a room.
X */
Xstatic void
Xlight_region(tmpregion)
X    region  *tmpregion;
X{
X    register boolean litstate = tmpregion->rlit ? 1 : 0;
X    register int hiy = tmpregion->y2;
X    register int x, y;
X    register struct rm *lev;
X    int lowy = tmpregion->y1;
X    int lowx = tmpregion->x1, hix = tmpregion->x2;
X
X    if(litstate) {
X	/* adjust region size for walls, but only if lighted */
X	lowx = max(lowx-1,1);
X	hix = min(hix+1,COLNO-1);
X	lowy = max(lowy-1,0);
X	hiy = min(hiy+1, ROWNO-1);
X    }
X    for(x = lowx; x <= hix; x++) {
X	lev = &levl[x][lowy];
X	for(y = lowy; y <= hiy; y++)
X	    lev++->lit = litstate;
X    }
X}
X
X/* initialization common to all special levels */
Xstatic void
Xload_common_data(fd, typ)
XFILE *fd;
Xint typ;
X{
X	uchar	n;
X	long	lev_flags;
X	int	i;
X
X      {
X	aligntyp atmp;
X	/* shuffle 3 alignments; can't use sp_lev_shuffle() on aligntyp's */
X	i = rn2(3);   atmp=ralign[2]; ralign[2]=ralign[i]; ralign[i]=atmp;
X	if (rn2(2)) { atmp=ralign[1]; ralign[1]=ralign[0]; ralign[0]=atmp; }
X      }
X
X	level.flags.is_maze_lev = typ == SP_LEV_MAZE;
X
X	/* free up old level regions */
X	if(num_lregions) {
X		for(i=0; i<num_lregions; i++)
X			if(lregions[i].rname) Free(lregions[i].rname);
X		Free(lregions);
X		num_lregions = 0;
X	}
X	lregions = (lev_region *) 0;
X
X	/* Read the level initialization data */
X	Fread((genericptr_t) &init_lev, 1, sizeof(lev_init), fd);
X	if(init_lev.init_present) {
X	    if(init_lev.lit < 0)
X		init_lev.lit = rn2(2);
X	    mkmap(&init_lev);
X	}
X
X	/* Read the per level flags */
X	Fread((genericptr_t) &lev_flags, 1, sizeof(lev_flags), fd);
X	if (lev_flags & NOTELEPORT)
X	    level.flags.noteleport = 1;
X	if (lev_flags & HARDFLOOR)
X	    level.flags.hardfloor = 1;
X	if (lev_flags & NOMMAP)
X	    level.flags.nommap = 1;
X	if (lev_flags & SHORTSIGHTED)
X	    level.flags.shortsighted = 1;
X
X	/* Read message */
X	Fread((genericptr_t) &n, 1, sizeof(n), fd);
X	if (n) {
X	    lev_message = (char *) alloc(n + 1);
X	    Fread((genericptr_t) lev_message, 1, (int) n, fd);
X	    lev_message[n] = 0;
X	}
X}
X
Xstatic boolean
Xload_rooms(fd)
XFILE *fd;
X{
X	xchar		nrooms;
X	char		n;
X	short		size;
X	corridor	tmpcor;
X	room**		tmproom;
X	int		i, j, ncorr;
X
X	load_common_data(fd, SP_LEV_ROOMS);
X
X	Fread((genericptr_t) &n, 1, sizeof(n), fd); /* nrobjects */
X	if (n) {
X		Fread((genericptr_t)robjects, sizeof(*robjects), n, fd);
X		sp_lev_shuffle(robjects, (char *)0, (int)n);
X	}
X
X	Fread((genericptr_t) &n, 1, sizeof(n), fd); /* nrmonst */
X	if (n) {
X		Fread((genericptr_t)rmonst, sizeof(*rmonst), n, fd);
X		sp_lev_shuffle(rmonst, (char *)0, (int)n);
X	}
X
X	Fread((genericptr_t) &nrooms, 1, sizeof(nrooms), fd);
X						/* Number of rooms to read */
X	tmproom = NewTab(room,nrooms);
X	for (i=0;i<nrooms;i++) {
X		room *r;
X
X		r = tmproom[i] = New(room);
X
X		/* Let's see if this room has a name */
X		Fread((genericptr_t) &size, 1, sizeof(size), fd);
X		if (size > 0) {	/* Yup, it does! */
X			r->name = (char *) alloc(size + 1);
X			Fread((genericptr_t) r->name, 1, size, fd);
X			r->name[size] = 0;
X		} else
X		    r->name = (char *) 0;
X
X		/* Let's see if this room has a parent */
X		Fread((genericptr_t) &size, 1, sizeof(size), fd);
X		if (size > 0) {	/* Yup, it does! */
X			r->parent = (char *) alloc(size + 1);
X			Fread((genericptr_t) r->parent, 1, size, fd);
X			r->parent[size] = 0;
X		} else
X		    r->parent = (char *) 0;
X		
X		Fread((genericptr_t) &r->x, 1, sizeof(r->x), fd);
X					/* x pos on the grid (1-5) */
X		Fread((genericptr_t) &r->y, 1, sizeof(r->y), fd);
X					 /* y pos on the grid (1-5) */
X		Fread((genericptr_t) &r->w, 1, sizeof(r->w), fd);
X					 /* width of the room */
X		Fread((genericptr_t) &r->h, 1, sizeof(r->h), fd);
X					 /* height of the room */
X		Fread((genericptr_t) &r->xalign, 1, sizeof(r->xalign), fd);
X					 /* horizontal alignment */
X		Fread((genericptr_t) &r->yalign, 1, sizeof(r->yalign), fd);
X					 /* vertical alignment */
X		Fread((genericptr_t) &r->rtype, 1, sizeof(r->rtype), fd);
X					 /* type of room (zoo, shop, etc.) */
X		Fread((genericptr_t) &r->chance, 1, sizeof(r->chance), fd);
X					 /* chance of room being special. */
X		Fread((genericptr_t) &r->rlit, 1, sizeof(r->rlit), fd);
X					 /* lit or not ? */
X		Fread((genericptr_t) &r->filled, 1, sizeof(r->filled), fd);
X					 /* to be filled? */
X		r->nsubroom= 0;
X
X		/* read the doors */
X		Fread((genericptr_t) &r->ndoor, 1, sizeof(r->ndoor), fd);
X		if(n = r->ndoor)
X		    r->doors = NewTab(room_door, n);
X		while(n--) {
X			r->doors[n] = New(room_door);
X			Fread((genericptr_t) r->doors[n], 1,
X				sizeof(room_door), fd);
X		}
X
X		/* read the traps */
X		Fread((genericptr_t) &r->ntrap, 1, sizeof(r->ntrap), fd);
X		if(n = r->ntrap)
X		    r->traps = NewTab(trap, n);
X		while(n--) {
X			r->traps[n] = New(trap);
X			Fread((genericptr_t) r->traps[n], 1, sizeof(trap), fd);
X		}
X
X		/* read the monsters */
X		Fread((genericptr_t) &r->nmonster, 1, sizeof(r->nmonster), fd);
X		if(n = r->nmonster)
X		    r->monsters = NewTab(monster, n);
X		while(n--) {
X			r->monsters[n] = New(monster);
X			Fread((genericptr_t) r->monsters[n], 1,
X				sizeof(monster), fd);
X			Fread((genericptr_t) &size, sizeof(size), 1, fd);
X			if (size) {
X				r->monsters[n]->name= (char *) alloc(size + 1);
X				Fread((genericptr_t)r->monsters[n]->name,
X					1, size, fd);
X				r->monsters[n]->name[size] = 0;
X			} else
X				r->monsters[n]->name = (char *) 0;
X
X			Fread((genericptr_t) &size, sizeof(size), 1, fd);
X			if (size) {
X				r->monsters[n]->appear_as=
X						    (char *) alloc(size + 1);
X				Fread((genericptr_t)r->monsters[n]->appear_as,
X					1, size, fd);
X				r->monsters[n]->appear_as[size] = 0;
X			} else
X				r->monsters[n]->appear_as = (char *) 0;
X		 }
X
X		/* read the objects */
X		Fread((genericptr_t) &r->nobject, 1, sizeof(r->nobject), fd);
X		if(n = r->nobject)
X		    r->objects = NewTab(object, n);
X		while (n--) {
X			r->objects[n] = New(object);
X			Fread((genericptr_t) r->objects[n], 1,
X				sizeof(object), fd);
X			Fread((genericptr_t) &size, 1, sizeof(size), fd);
X			if (size) {
X				r->objects[n]->name = (char *) alloc(size + 1);
X				Fread((genericptr_t)r->objects[n]->name,
X					1, size, fd);
X				r->objects[n]->name[size] = 0;
X			} else
X			    r->objects[n]->name = (char *) 0;
X		}
X
X		/* read the stairs */
X		Fread((genericptr_t) &r->nstair, 1, sizeof(r->nstair), fd);
X		if (n = r->nstair)
X		    r->stairs = NewTab(stair, n);
X		while (n--) {
X			r->stairs[n] = New(stair);
X			Fread((genericptr_t) r->stairs[n], 1,
X				sizeof(stair), fd);
X		}
X
X		/* read the altars */
X		Fread((genericptr_t) &r->naltar, 1, sizeof(r->naltar), fd);
X		if (n = r->naltar)
X		    r->altars = NewTab(altar, n);
X		while (n--) {
X			r->altars[n] = New(altar);
X			Fread((genericptr_t) r->altars[n], 1,
X				sizeof(altar), fd);
X		}
X
X		/* read the gold piles */
X		Fread((genericptr_t) &r->ngold, 1, sizeof(r->ngold), fd);
X		if (n = r->ngold)
X		    r->golds = NewTab(gold, n);
X		while (n--) {
X			r->golds[n] = New(gold);
X			Fread((genericptr_t) r->golds[n], 1, sizeof(gold), fd);
X		}
X
X		/* read the engravings */
X		Fread((genericptr_t) &r->nengraving, 1,
X			sizeof(r->nengraving), fd);
X		if (n = r->nengraving)
X		    r->engravings = NewTab(engraving,n);
X		while(n--) {
X			r->engravings[n] = New(engraving);
X			Fread((genericptr_t) r->engravings[n],
X				1, sizeof *r->engravings[n], fd);
X			size = r->engravings[n]->e.length;
X			r->engravings[n]->e.text = (char *) alloc(size+1);
X			Fread((genericptr_t) r->engravings[n]->e.text,
X				1, size, fd);
X			r->engravings[n]->e.text[size] = '\0';
X		}
X
X		/* read the fountains */
X		Fread((genericptr_t) &r->nfountain, 1,
X			sizeof(r->nfountain), fd);
X		if (n = r->nfountain)
X		    r->fountains = NewTab(fountain, n);
X		while (n--) {
X			r->fountains[n] = New(fountain);
X			Fread((genericptr_t) r->fountains[n], 1,
X				sizeof(fountain), fd);
X		}
X
X		/* read the sinks */
X		Fread((genericptr_t) &r->nsink, 1, sizeof(r->nsink), fd);
X		if (n = r->nsink)
X		    r->sinks = NewTab(sink, n);
X		while (n--) {
X			r->sinks[n] = New(sink);
X			Fread((genericptr_t) r->sinks[n], 1, sizeof(sink), fd);
X		}
X
X		/* read the pools */
X		Fread((genericptr_t) &r->npool, 1, sizeof(r->npool), fd);
X		if (n = r->npool)
X		    r->pools = NewTab(pool,n);
X		while (n--) {
X			r->pools[n] = New(pool);
X			Fread((genericptr_t) r->pools[n], 1, sizeof(pool), fd);
X		}
X
X	}
X
X	/* Now that we have loaded all the rooms, search the
X	 * subrooms and create the links.
X	 */
X
X	for (i = 0; i<nrooms; i++)
X	    if (tmproom[i]->parent) {
X		    /* Search the parent room */
X		    for(j=0; j<nrooms; j++)
X			if (tmproom[j]->name && !strcmp(tmproom[j]->name,
X						       tmproom[i]->parent)) {
X				n = tmproom[j]->nsubroom++;
X				tmproom[j]->subrooms[n] = tmproom[i];
X				break;
X			}
X	    }
X
X	/* 
X	 * Create the rooms now...
X	 */
X
X	for (i=0; i < nrooms; i++)
X	    if(!tmproom[i]->parent)
X		build_room(tmproom[i], (room *) 0);
X
X	free_rooms(tmproom, nrooms);
X
X	/* read the corridors */
X
X	Fread((genericptr_t) &ncorr, sizeof(ncorr), 1, fd);
X	for (i=0; i<ncorr; i++) {
X		Fread((genericptr_t) &tmpcor, 1, sizeof(tmpcor), fd);
X		create_corridor(&tmpcor);
X	}
X
X	return TRUE;
X}
X
X/*
X * Select a random coordinate in the maze.
X *
X * We want a place not 'touched' by the loader.  That is, a place in
X * the maze outside every part of the special level.
X */
X
Xstatic void
Xmaze1xy(m)
Xcoord *m;
X{
X	do {
X		m->x = rn1(x_maze_max - 3, 3);
X		m->y = rn1(y_maze_max - 3, 3);
X	} while (!(m->x % 2) || !(m->y % 2) || Map[m->x][m->y]);
X}
X
X/* 
X * The Big Thing: special maze loader
X *
X * Could be cleaner, but it works.
X */
X
Xstatic boolean
Xload_maze(fd)
XFILE *fd;
X{
X    xchar   x, y, typ;
X    boolean prefilled;
X
X    char    n, numpart = 0;
X    xchar   nwalk = 0, nwalk_sav;
X    short   filling;
X    char    halign, valign;
X
X    int     xi, yi, dir;
X    coord   mm;
X    int     mapcount, mapcountmax, mapfact;
X
X    lev_region  tmplregion;
X    region  tmpregion;
X    door    tmpdoor;
X    trap    tmptrap;
X    monster tmpmons;
X    object  tmpobj;
X    drawbridge tmpdb;
X    walk    tmpwalk;
X    digpos  tmpdig;
X    lad     tmplad;
X    stair   tmpstair, prevstair;
X    altar   tmpaltar;
X    gold    tmpgold;
X    fountain tmpfountain;
X    engraving tmpengraving;
X    xchar   mustfill[(MAXNROFROOMS+1)*2];
X    struct trap *badtrap;
X    boolean has_bounds;
X
X    load_common_data(fd, SP_LEV_MAZE);
X
X    /* Initialize map */
X    Fread((genericptr_t) &filling, 1, sizeof(filling), fd);
X    if(!init_lev.init_present) /* don't init if mkmap() has been called */
X      for(x = 2; x <= x_maze_max; x++)
X	for(y = 0; y <= y_maze_max; y++)
X	    if (filling == -1) {
X#ifndef WALLIFIED_MAZE
X		    levl[x][y].typ = STONE;
X#else
X		    levl[x][y].typ =
X			(y < 2 || ((x % 2) && (y % 2))) ? STONE : HWALL;
X#endif
X		    Map[x][y] = 0;
X	    } else {
X		    levl[x][y].typ = filling;
X		    Map[x][y] = 0;
X	    }
X
X    /* Start reading the file */
X    Fread((genericptr_t) &numpart, 1, sizeof(numpart), fd);
X						/* Number of parts */
X    if (!numpart || numpart > 9)
X	panic("load_maze error: numpart = %d", (int) numpart);
X
X    while (numpart--) {
X	Fread((genericptr_t) &halign, 1, sizeof(halign), fd);
X					/* Horizontal alignment */
X	Fread((genericptr_t) &valign, 1, sizeof(valign), fd);
X					/* Vertical alignment */
X	Fread((genericptr_t) &xsize, 1, sizeof(xsize), fd);
X					/* size in X */
X	Fread((genericptr_t) &ysize, 1, sizeof(ysize), fd);
X					/* size in Y */
X	switch((int) halign) {
X	    case LEFT:	    xstart = 3; 				break;
X	    case H_LEFT:    xstart = 2+((x_maze_max-2-xsize)/4);	break;
X	    case CENTER:    xstart = 2+((x_maze_max-2-xsize)/2);	break;
X	    case H_RIGHT:   xstart = 2+((x_maze_max-2-xsize)*3/4);	break;
X	    case RIGHT:     xstart = x_maze_max-xsize-1;		break;
X	}
X	switch((int) valign) {
X	    case TOP:	    ystart = 3; 				break;
X	    case CENTER:    ystart = 2+((y_maze_max-2-ysize)/2);	break;
X	    case BOTTOM:    ystart = y_maze_max-ysize-1;		break;
X	}
X	if (!(xstart % 2)) xstart++;
X	if (!(ystart % 2)) ystart++;
X	if ((ystart < 0) || (ystart + ysize > ROWNO)) {
X	    /* try to move the start a bit */
X	    ystart += (ystart > 0) ? -2 : 2;
X	    if(ysize == ROWNO) ystart = 0;
X	    if(ystart < 0 || ystart + ysize > ROWNO)
X		panic("reading special level with ysize to large");
X	}
X
X	/*
X	 * If any CROSSWALLs are found, must change to ROOM after REGION's
X	 * are laid out.  CROSSWALLS are used to specify "invisible"
X	 * boundaries where DOOR syms look bad or aren't desirable.
X	 */
X	has_bounds = FALSE;
X
X	if(init_lev.init_present && xsize <= 1 && ysize <= 1) {
X	    xstart = 1;
X	    ystart = 0;
X	    xsize = COLNO-1;
X	    ysize = ROWNO;
X	} else {
X	    /* Load the map */
X	    for(y = ystart; y < ystart+ysize; y++)
X		for(x = xstart; x < xstart+xsize; x++) {
X		    levl[x][y].typ = (schar) fgetc(fd);
X		    levl[x][y].lit = FALSE;
X		    /*
X		     * Note: Even though levl[x][y].typ is type schar,
X		     *	 lev_comp.y saves it as type char. Since schar != char
X		     *	 all the time we must make this exception or hack
X		     *	 through lev_comp.y to fix.
X		     */
X
X		    /*
X		     *  Set secret doors to closed (why not trapped too?).  Set
X		     *  the horizontal bit.
X		     */
X		    if (levl[x][y].typ == SDOOR || IS_DOOR(levl[x][y].typ)) {
X			if(levl[x][y].typ == SDOOR)
X			    levl[x][y].doormask = D_CLOSED;
X			/*
X			 *  If there is a wall to the left that connects to a
X			 *  (secret) door, then it is horizontal.  This does
X			 *  not allow (secret) doors to be corners of rooms.
X			 */
X			if (x != xstart && (IS_WALL(levl[x-1][y].typ) ||
X					    levl[x-1][y].horizontal))
X			    levl[x][y].horizontal = 1;
X		    } else if(levl[x][y].typ == HWALL)
X			levl[x][y].horizontal = 1;
X		    else if(levl[x][y].typ == LAVAPOOL)
X			levl[x][y].lit = 1;
X		    else if(levl[x][y].typ == CROSSWALL)
X			has_bounds = TRUE;
X		    Map[x][y] = 1;
X		}
X	}
X
X	Fread((genericptr_t) &n, 1, sizeof(n), fd);
X						/* Number of level regions */
X	if(n) {
X	    if(num_lregions) {
X		/* realloc the lregion space to add the new ones */
X		/* don't really free it up until the whole level is done */
X		lev_region *newl = (lev_region *) alloc(sizeof(lev_region) *
X							(n+num_lregions));
X		(void) memcpy((genericptr_t)(newl+n), (genericptr_t)lregions,
X					sizeof(lev_region) * num_lregions);
X		Free(lregions);
X		num_lregions += n;
X		lregions = newl;
X	    } else {
X		num_lregions = n;
X		lregions = (lev_region *) alloc(sizeof(lev_region) * n);
X	    }
X	}
X
X	while(n--) {
X	    Fread((genericptr_t) &tmplregion, sizeof(tmplregion), 1, fd);
X	    if(tmplregion.rname) {
X		char len;
X
X		Fread((genericptr_t) &len, sizeof(len), 1, fd);
X		tmplregion.rname = (char *) alloc(len + 1);
X		Fread((genericptr_t) tmplregion.rname, len, 1, fd);
X		tmplregion.rname[len] = 0;
X	    }
X	    if(!tmplregion.in_islev) {
X		get_location(&tmplregion.inarea.x1, &tmplregion.inarea.y1,
X								DRY|WET);
X		get_location(&tmplregion.inarea.x2, &tmplregion.inarea.y2,
X								DRY|WET);
X	    }
X	    if(!tmplregion.del_islev) {
X		get_location(&tmplregion.delarea.x1, &tmplregion.delarea.y1,
X								DRY|WET);
X		get_location(&tmplregion.delarea.x2, &tmplregion.delarea.y2,
X								DRY|WET);
X	    }
X	    lregions[n] = tmplregion;
X	}
X
X	Fread((genericptr_t) &n, 1, sizeof(n), fd);
X						/* Random objects */
X	if(n) {
X		Fread((genericptr_t)robjects, sizeof(*robjects), (int) n, fd);
X		sp_lev_shuffle(robjects, (char *)0, (int)n);
X	}
X
X	Fread((genericptr_t) &n, 1, sizeof(n), fd);
X						/* Random locations */
X	if(n) {
X		Fread((genericptr_t)rloc_x, sizeof(*rloc_x), (int) n, fd);
X		Fread((genericptr_t)rloc_y, sizeof(*rloc_y), (int) n, fd);
X		sp_lev_shuffle(rloc_x, rloc_y, (int)n);
X	}
X
X	Fread((genericptr_t) &n, 1, sizeof(n), fd);
X						/* Random monsters */
X	if(n) {
X		Fread((genericptr_t)rmonst, sizeof(*rmonst), (int) n, fd);
X		sp_lev_shuffle(rmonst, (char *)0, (int)n);
X	}
X
X	Fread((genericptr_t) &n, 1, sizeof(n), fd);
X						/* Number of subrooms */
X
X	(void) memset((genericptr_t)mustfill, 0, sizeof(mustfill));
X
X	while(n--) {
X		register struct mkroom *troom;
X
X		Fread((genericptr_t)&tmpregion, 1, sizeof(tmpregion), fd);
X
X		if(tmpregion.rtype > MAXRTYPE) {
X		    tmpregion.rtype -= MAXRTYPE+1;
X		    prefilled = TRUE;
X		} else
X		    prefilled = FALSE;
X
X		if(tmpregion.rlit < 0)
X		    tmpregion.rlit = (rnd(1+abs(depth(&u.uz))) < 11 && rn2(77))
X			? TRUE : FALSE;
X
X		get_location(&tmpregion.x1, &tmpregion.y1, DRY|WET);
X		get_location(&tmpregion.x2, &tmpregion.y2, DRY|WET);
X
X		if (((tmpregion.rtype == OROOM) && !tmpregion.rirreg) ||
X		    (nroom >= MAXNROFROOMS)) {
X		    if(tmpregion.rtype != OROOM || tmpregion.rirreg)
X			impossible("Too many rooms on new level!");
X		    light_region(&tmpregion);
X		    continue;
X		}
X
X		troom = &rooms[nroom];
X
X		/* mark rooms that must be filled, but do it later */
X		if (tmpregion.rtype != OROOM)
X		    mustfill[nroom] = (prefilled ? 2 : 1);
X
X		if(tmpregion.rirreg) {
X		    min_rx = max_rx = tmpregion.x1;
X		    min_ry = max_ry = tmpregion.y1;
X		    flood_fill_rm(tmpregion.x1, tmpregion.y1,
X				  nroom+ROOMOFFSET, tmpregion.rlit, TRUE);
X		    add_room(min_rx, min_ry, max_rx, max_ry,
X			     FALSE, tmpregion.rtype, TRUE);
X		    troom->rlit = tmpregion.rlit;
X		    troom->irregular = TRUE;
X		} else {
X		    add_room(tmpregion.x1, tmpregion.y1,
X			     tmpregion.x2, tmpregion.y2,
X			     tmpregion.rlit, tmpregion.rtype, TRUE);
X#ifdef SPECIALIZATION
X		    topologize(troom,FALSE);		/* set roomno */
X#else
X		    topologize(troom);			/* set roomno */
X#endif
X		}
X	}
X
X	Fread((genericptr_t) &n, 1, sizeof(n), fd);
X						/* Number of doors */
X	while(n--) {
X		struct mkroom *croom = &rooms[0];
X
X		Fread((genericptr_t)&tmpdoor, 1, sizeof(tmpdoor), fd);
X
X		x = tmpdoor.x;	y = tmpdoor.y;
X		typ = tmpdoor.mask == -1 ? rnddoor() : tmpdoor.mask;
X
X		get_location(&x, &y, DRY);
X		if(levl[x][y].typ != SDOOR)
X			levl[x][y].typ = DOOR;
X		else {
X			if(typ < D_CLOSED)
X			    typ = D_CLOSED; /* force it to be closed */
X		}
X		levl[x][y].doormask = typ;
X
X		/* Now the complicated part, list it with each subroom */
X		/* The dog move and mail daemon routines use this */
X		while(croom->hx >= 0 && doorindex < DOORMAX) {
X		    if(croom->hx >= x-1 && croom->lx <= x+1 &&
X		       croom->hy >= y-1 && croom->ly <= y+1) {
X			/* Found it */
X			add_door(x, y, croom);
X		    }
X		    croom++;
X		}
X	}
X
X	/* now that we have rooms _and_ associated doors, fill the rooms */
X	for(n = 0; n < SIZE(mustfill); n++)
X	    if(mustfill[n])
X		fill_room(&rooms[n], (mustfill[n] == 2));
X
X	/* if special boundary syms (CROSSWALL) in map, remove them now */
X	if(has_bounds) {
X	    for(x = xstart; x < xstart+xsize; x++)
X		for(y = ystart; y < ystart+ysize; y++)
X		    if(levl[x][y].typ == CROSSWALL)
X			levl[x][y].typ = ROOM;
X	}
X
X	Fread((genericptr_t) &n, 1, sizeof(n), fd);
X						/* Number of traps */
X	while(n--) {
X		Fread((genericptr_t)&tmptrap, 1, sizeof(tmptrap), fd);
X
X		create_trap(&tmptrap, (struct mkroom *)0);
X	}
X
X	Fread((genericptr_t) &n, 1, sizeof(n), fd);
X						/* Number of monsters */
X	while(n--) {
X		short size;
X
X		Fread((genericptr_t) &tmpmons, 1, sizeof(tmpmons), fd);
X		Fread((genericptr_t) &size, 1, sizeof(size), fd);
X		if (size) {
X			tmpmons.name = (char *) alloc(size + 1);
X			Fread((genericptr_t) tmpmons.name, 1, size, fd);
X			tmpmons.name[size] = 0;
X		} else
X			tmpmons.name = (char *) 0;
X		Fread((genericptr_t) &size, 1, sizeof(size), fd);
X		if (size) {
X			tmpmons.appear_as = (char *) alloc(size + 1);
X			Fread((genericptr_t) tmpmons.appear_as, 1, size, fd);
X			tmpmons.appear_as[size] = 0;
X		} else
X			tmpmons.appear_as = (char *) 0;
X
X		create_monster(&tmpmons, (struct mkroom *)0);
X
X		if (tmpmons.name)
X			free((genericptr_t) tmpmons.name);
X		if (tmpmons.appear_as)
X			free((genericptr_t) tmpmons.appear_as);
X	}
X
X	Fread((genericptr_t) &n, 1, sizeof(n), fd);
X						/* Number of objects */
X	while(n--) {
X		short size;
X
X		Fread((genericptr_t) &tmpobj, 1, sizeof(object), fd);
X		Fread((genericptr_t) &size, 1, sizeof(size), fd);
X		if (size) {
X			tmpobj.name = (char *) alloc(size + 1);
X			Fread((genericptr_t) tmpobj.name, 1, size, fd);
X			tmpobj.name[size] = 0;
X		} else
X			tmpobj.name = (char *) 0;
X
X		create_object(&tmpobj, (struct mkroom *)0);
X
X		if (size)
X			free((genericptr_t) tmpobj.name);
X	}
X
X	Fread((genericptr_t) &n, 1, sizeof(n), fd);
X						/* Number of drawbridges */
X	while(n--) {
X		Fread((genericptr_t)&tmpdb, 1, sizeof(tmpdb), fd);
X
X		x = tmpdb.x;  y = tmpdb.y;
X		get_location(&x, &y, DRY|WET);
X
X		if (!create_drawbridge(x, y, tmpdb.dir, tmpdb.db_open))
X		    impossible("Cannot create drawbridge.");
X	}
X
X	Fread((genericptr_t) &n, 1, sizeof(n), fd);
X						/* Number of mazewalks */
X	while(n--) {
X		Fread((genericptr_t)&tmpwalk, 1, sizeof(tmpwalk), fd);
X
X		get_location(&tmpwalk.x, &tmpwalk.y, DRY|WET);
X
X		walklist[nwalk++] = tmpwalk;
X	}
X
X	Fread((genericptr_t) &n, 1, sizeof(n), fd);
X						/* Number of non_diggables */
X	while(n--) {
X		Fread((genericptr_t)&tmpdig, 1, sizeof(tmpdig), fd);
X
X		get_location(&tmpdig.x1, &tmpdig.y1, DRY|WET);
X		get_location(&tmpdig.x2, &tmpdig.y2, DRY|WET);
X
X		make_walls_nondiggable(tmpdig.x1, tmpdig.y1,
X				       tmpdig.x2, tmpdig.y2);
X	}
X
X	Fread((genericptr_t) &n, 1, sizeof(n), fd);
X						/* Number of ladders */
X	while(n--) {
X		Fread((genericptr_t)&tmplad, 1, sizeof(tmplad), fd);
X
X		x = tmplad.x;  y = tmplad.y;
X		get_location(&x, &y, DRY);
X
X		levl[x][y].typ = LADDER;
X		if (tmplad.up == 1) {
X			xupladder = x;	yupladder = y;
X			levl[x][y].ladder = LA_UP;
X		} else {
X			xdnladder = x;	ydnladder = y;
X			levl[x][y].ladder = LA_DOWN;
X		}
X	}
X
X	prevstair.x = prevstair.y = 0;
X	Fread((genericptr_t) &n, 1, sizeof(n), fd);
X						/* Number of stairs */
X	while(n--) {
X		Fread((genericptr_t)&tmpstair, 1, sizeof(tmpstair), fd);
X
X		xi = 0;
X		do {
X		    x = tmpstair.x;  y = tmpstair.y;
X		    get_location(&x, &y, DRY);
X		} while(prevstair.x && xi++ < 100 &&
X			distmin(x,y,prevstair.x,prevstair.y) <= 8);
X		if ((badtrap = t_at(x,y)) != 0) deltrap(badtrap);
X		mkstairs(x, y, (char)tmpstair.up, (struct mkroom *)0);
X		prevstair.x = x;
X		prevstair.y = y;
X	}
X
X	Fread((genericptr_t) &n, 1, sizeof(n), fd);
X						/* Number of altars */
X	while(n--) {
X		Fread((genericptr_t)&tmpaltar, 1, sizeof(tmpaltar), fd);
X
X		create_altar(&tmpaltar, (struct mkroom *)0);
X	}
X
X	Fread((genericptr_t) &n, 1, sizeof(n), fd);
X						/* Number of gold pile */
X	while (n--) {
X		Fread((genericptr_t)&tmpgold, 1, sizeof(tmpgold), fd);
X
X		create_gold(&tmpgold, (struct mkroom *)0);
X	}
X
X	Fread((genericptr_t) &n, 1, sizeof(n), fd);
X						/* Number of engravings */
X	while(n--) {
X		int size;
X		Fread((genericptr_t) &tmpengraving, 1,
X			sizeof(tmpengraving), fd);
X		size = tmpengraving.e.length;
X		tmpengraving.e.text = (char *) alloc(size+1);
X		Fread((genericptr_t) tmpengraving.e.text, 1, size, fd);
X		tmpengraving.e.text[size] = '\0';
X		
X		x = tmpengraving.x; y = tmpengraving.y;
X		get_location(&x, &y, DRY);
X		make_engr_at(x, y, tmpengraving.e.text, 0L, tmpengraving.etype);
X		free((genericptr_t) tmpengraving.e.text);
X	}
X
X	Fread((genericptr_t) &n, 1, sizeof(n), fd);
X						/* Number of fountains */
X	while (n--) {
X		Fread((genericptr_t)&tmpfountain, 1, sizeof(tmpfountain), fd);
X
X		create_feature(tmpfountain.x, tmpfountain.y,
X			       (struct mkroom *)0, FOUNTAIN);
X	}
X    }
X
X    nwalk_sav = nwalk;
X    while(nwalk--) {
X	    xi = walklist[nwalk].x;
X	    yi = walklist[nwalk].y;
X	    dir = walklist[nwalk].dir;
X
X	    move(&xi, &yi, dir);
X	    x = xi;
X	    y = yi;
X
X	    if(!IS_DOOR(levl[x][y].typ)) {
X#ifndef WALLIFIED_MAZE
X		levl[x][y].typ = CORR;
X#else
X		levl[x][y].typ = ROOM;
X#endif
X		levl[x][y].flags = 0;
X	    }
X
X	    /*
X	     * We must be sure that the parity of the coordinates for
X	     * walkfrom() is odd.  But we must also take into account
X	     * what direction was chosen.
X	     */
X	    if(!(x % 2)) {
X		if (dir == W_EAST)
X		    x++;
X		else
X		    x--;
X
X		/* no need for IS_DOOR check; out of map bounds */
X#ifndef WALLIFIED_MAZE
X		levl[x][y].typ = CORR;
X#else
X		levl[x][y].typ = ROOM;
X#endif
X		levl[x][y].flags = 0;
X	    }
X
X	    if (!(y % 2))
X		if (dir == W_SOUTH)
X		    y++;
X		else
X		    y--;
X
X	    walkfrom(x, y);
X    }
X    wallification(1, 0, COLNO-1, ROWNO-1);
X
X    /*
X     * If there's a significant portion of maze unused by the special level,
X     * we don't want it empty.
X     *
X     * Makes the number of traps, monsters, etc. proportional
X     * to the size of the maze.
X     */
X    mapcountmax = mapcount = (x_maze_max - 2) * (y_maze_max - 2);
X
X    for(x = 2; x < x_maze_max; x++)
X	for(y = 0; y < y_maze_max; y++)
X	    if(Map[x][y]) mapcount--;
X
X    if (nwalk_sav && (mapcount > (int) (mapcountmax / 10))) {
X	    mapfact = (int) ((mapcount * 100L) / mapcountmax);
X	    for(x = rnd((int) (20 * mapfact) / 100); x; x--) {
X		    maze1xy(&mm);
X		    (void) mkobj_at(rn2(2) ? GEM_CLASS : RANDOM_CLASS,
X							mm.x, mm.y, TRUE);
X	    }
X	    for(x = rnd((int) (12 * mapfact) / 100); x; x--) {
X		    maze1xy(&mm);
X		    (void) mksobj_at(BOULDER, mm.x, mm.y, TRUE);
X	    }
X	    maze1xy(&mm);
X	    (void) makemon(&mons[PM_MINOTAUR], mm.x, mm.y);
X	    for(x = rnd((int) (12 * mapfact) / 100); x; x--) {
X		    maze1xy(&mm);
X		    (void) makemon((struct permonst *) 0, mm.x, mm.y);
X	    }
X	    for(x = rn2((int) (15 * mapfact) / 100); x; x--) {
X		    maze1xy(&mm);
X		    mkgold(0L,mm.x,mm.y);
X	    }
X	    for(x = rn2((int) (15 * mapfact) / 100); x; x--) {
X		    int trytrap = rndtrap();
X
X		    maze1xy(&mm);
X		    if (is_pool(mm.x,mm.y)) continue;
X		    if (sobj_at(BOULDER, mm.x, mm.y))
X			while ((trytrap == PIT) || (trytrap == SPIKED_PIT)) 
X				trytrap = rndtrap();
X		    (void) maketrap(mm.x, mm.y, trytrap);
X	    }
X    }
X    return TRUE;
X}
X
X/*
X * General loader
X */
X
Xboolean
Xload_special(name)
Xconst char *name;
X{
X	FILE *fd;
X	boolean result;
X	char c;
X
X	fd = fopen_datafile(name, RDMODE);
X	if (!fd) return FALSE;
X
X	Fread((genericptr_t) &c, 1, sizeof(c), fd); /* c Header */
X
X	switch (c) {
X		case SP_LEV_ROOMS:
X		    result = load_rooms(fd);
X		    break;
X		case SP_LEV_MAZE:
X		    result = load_maze(fd);
X		    break;
X		default:	/* ??? */
X		    result = FALSE;
X	}
X	(void)fclose(fd);
X	return result;
X}
X
X/*sp_lev.c*/
END_OF_FILE
if test 32785 -ne `wc -c <'src/sp_lev.c2'`; then
    echo shar: \"'src/sp_lev.c2'\" unpacked with wrong size!
fi
# end of 'src/sp_lev.c2'
fi
echo shar: End of archive 62 \(of 108\).
cp /dev/null ark62isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \
21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \
41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 \
61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 \
81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 \
101 102 103 104 105 106 107 108 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 108 archives.
    echo "Now execute 'rebuild.sh'"
    rm -f ark10[0-8]isdone ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
