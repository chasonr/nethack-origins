Path: uunet!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v16i004:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Part04/108
Message-ID: <4287@master.CNA.TEK.COM>
Date: 28 Jan 93 19:10:40 GMT
Sender: news@master.CNA.TEK.COM
Lines: 1926
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1560

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 16, Issue 4
Archive-name: nethack31/Part04
Supersedes: nethack3p9: Volume 10, Issue 46-102
Environment: Amiga, Atari, Mac, MS-DOS, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 4 (of 108)."
# Contents:  include/extern.h sys/unix/Makefile.doc
# Wrapped by billr@saab on Wed Jan 27 16:08:46 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'include/extern.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/extern.h'\"
else
echo shar: Extracting \"'include/extern.h'\" \(53881 characters\)
sed "s/^X//" >'include/extern.h' <<'END_OF_FILE'
X/*	SCCS Id: @(#)extern.h	3.1	93/01/24	*/
X/* Copyright (c) Steve Creps, 1988.				  */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#ifndef EXTERN_H
X#define EXTERN_H
X
X#define E extern
X
X/* ### alloc.c ### */
X
XE long *FDECL(alloc, (unsigned int));
X
X#if !defined(MAKEDEFS_C) && !defined(LEV_LEX_C)
X
X/* ### allmain.c ### */
X
XE void NDECL(moveloop);
XE void NDECL(stop_occupation);
XE void NDECL(display_gamewindows);
XE void NDECL(newgame);
X
X/* ### amiwbench.c ### */
X
X#ifdef AMIGA
XE void NDECL(ami_wbench_init);
XE void NDECL(ami_wbench_args);
XE int FDECL(ami_wbench_getsave, (int));
XE void FDECL(ami_wbench_unlink, (char *));
XE int FDECL(ami_wbench_iconsize, (char *));
XE void FDECL(ami_wbench_iconwrite, (char *));
XE int FDECL(ami_wbench_badopt, (const char *));
XE void NDECL(ami_wbench_cleanup);
XE void FDECL(getlind, (const char *,char *,const char *));
X#endif /* AMIGA */
X
X/* ### apply.c ### */
X
X#ifdef OVERLAY
XE int NDECL(dig);
X#endif
XE int NDECL(doapply);
XE int NDECL(holetime);
XE void NDECL(dighole);
XE int NDECL(dorub);
XE int NDECL(dojump);
X#ifdef WALKIES
XE int NDECL(number_leashed);
XE void FDECL(o_unleash, (struct obj *));
XE void FDECL(m_unleash, (struct monst *));
XE void NDECL(unleash_all);
XE boolean NDECL(next_to_u);
XE struct obj *FDECL(get_mleash, (struct monst *));
XE void FDECL(check_leash, (XCHAR_P,XCHAR_P));
X#endif
XE boolean FDECL(um_dist, (XCHAR_P,XCHAR_P,XCHAR_P));
XE boolean FDECL(snuff_candle, (struct obj *));
XE boolean FDECL(snuff_lit, (struct obj *));
XE void NDECL(check_lamps);
XE void FDECL(use_unicorn_horn, (struct obj *));
X
X/* ### artifact.c ### */
X
XE void NDECL(init_artifacts);
XE void FDECL(save_artifacts, (int));
XE void FDECL(restore_artifacts, (int));
XE const char *FDECL(artiname, (int));
XE struct obj *FDECL(mk_artifact, (struct obj *,ALIGNTYP_P));
XE const char *FDECL(artifact_name, (const char *,short *));
XE boolean FDECL(exist_artifact, (int,const char *));
XE void FDECL(artifact_exists, (struct obj *,const char *,BOOLEAN_P));
XE int NDECL(nartifact_exist);
XE boolean FDECL(spec_ability, (struct obj *,unsigned));
XE boolean FDECL(restrict_name, (struct obj *,const char *));
XE boolean FDECL(defends, (int,struct obj *));
XE void FDECL(set_artifact_intrinsic, (struct obj *,BOOLEAN_P,long));
XE int FDECL(touch_artifact, (struct obj *,struct monst *));
XE int FDECL(spec_abon, (struct obj *,struct permonst *));
XE int FDECL(spec_dbon, (struct obj *,struct permonst *,int));
XE boolean FDECL(artifact_hit, (struct monst *,struct monst *,
X				struct obj *,int *,int));
XE int NDECL(doinvoke);
X
X/* ### attrib.c ### */
X
XE boolean FDECL(adjattrib, (int,int,int));
XE void FDECL(change_luck, (SCHAR_P));
XE int FDECL(stone_luck, (BOOLEAN_P));
XE void FDECL(gainstr, (struct obj *,int));
XE void FDECL(losestr, (int));
XE void NDECL(restore_attrib);
XE void FDECL(exercise, (int,BOOLEAN_P));
XE void NDECL(exerchk);
XE void FDECL(init_attr, (int));
XE void NDECL(redist_attr);
XE void FDECL(adjabil, (int,int));
XE int NDECL(newhp);
XE schar FDECL(acurr, (int));
XE schar NDECL(acurrstr);
XE void FDECL(adjalign, (int));
X
X/* ### ball.c ### */
X
XE void NDECL(ballfall);
XE void NDECL(placebc);
XE void NDECL(unplacebc);
XE int NDECL(bc_order);
XE void FDECL(set_bc, (int));
XE void FDECL(move_bc, (int,int,XCHAR_P,XCHAR_P,XCHAR_P,XCHAR_P));
XE boolean FDECL(drag_ball, (XCHAR_P,XCHAR_P,
X			    int *,xchar *,xchar *,xchar *,xchar *));
XE void FDECL(drop_ball, (XCHAR_P,XCHAR_P));
XE void NDECL(drag_down);
X
X/* ### bones.c ### */
X
XE void NDECL(savebones);
XE int NDECL(getbones);
X
X/* ### botl.c ### */
X
XE int FDECL(xlev_to_rank, (int));
XE int FDECL(title_to_mon, (const char *,int *,int *));
XE void NDECL(max_rank_sz);
XE const char *FDECL(rank_of, (unsigned,CHAR_P,BOOLEAN_P));
XE void NDECL(bot);
X
X/* ### cmd.c ### */
X
X#ifdef OVERLAY
XE int NDECL(doextcmd);
X#ifdef POLYSELF
XE int NDECL(domonability);
X#endif /* POLYSELF */
XE int NDECL(doprev_message);
XE int NDECL(timed_occupation);
X#if defined(WIZARD) || defined(EXPLORE_MODE)
XE int NDECL(wiz_attributes);
X#endif /* WIZARD */
X# ifdef EXPLORE_MODE
XE int NDECL(enter_explore_mode);
X# endif /* EXPLORE_MODE */
X#ifdef WIZARD
XE int NDECL(wiz_detect);
XE int NDECL(wiz_genesis);
XE int NDECL(wiz_identify);
XE int NDECL(wiz_level_tele);
XE int NDECL(wiz_map);
XE int NDECL(wiz_where);
XE int NDECL(wiz_wish);
X#endif /* WIZARD */
X#endif /* OVERLAY */
XE void NDECL(reset_occupations);
XE void FDECL(set_occupation, (int (*)(void),const char *,int));
X#ifdef REDO
XE char NDECL(pgetchar);
XE void FDECL(pushch, (CHAR_P));
XE void FDECL(savech, (CHAR_P));
X#endif
XE void FDECL(rhack, (char *));
XE int NDECL(doextlist);
XE void FDECL(enlightenment, (BOOLEAN_P));
XE int FDECL(xytod, (SCHAR_P,SCHAR_P));
X#ifdef WALKIES
XE void FDECL(dtoxy, (coord *,int));
X#endif
XE int FDECL(movecmd, (CHAR_P));
XE int FDECL(getdir, (const char *));
XE void NDECL(confdir);
XE int FDECL(isok, (int,int));
XE char NDECL(readchar);
X
X/* ### dbridge.c ### */
X
XE boolean FDECL(is_pool, (int,int));
XE boolean FDECL(is_lava, (int,int));
XE boolean FDECL(is_ice, (int,int));
XE int FDECL(is_drawbridge_wall, (int,int));
XE boolean FDECL(is_db_wall, (int,int));
XE boolean FDECL(find_drawbridge, (int *,int*));
XE boolean FDECL(create_drawbridge, (int,int,int,BOOLEAN_P));
XE void FDECL(open_drawbridge, (int,int));
XE void FDECL(close_drawbridge, (int,int));
XE void FDECL(destroy_drawbridge, (int,int));
X
X/* ### decl.c ### */
X
XE void NDECL(decl_init);
X
X/* ### detect.c ### */
X
XE struct obj *FDECL(o_in, (struct obj*,CHAR_P));
XE int FDECL(gold_detect, (struct obj *));
XE int FDECL(food_detect, (struct obj *));
XE int FDECL(object_detect, (struct obj *,int));
XE int FDECL(monster_detect, (struct obj *,int));
XE int FDECL(trap_detect, (struct obj *));
XE const char *FDECL(level_distance, (d_level *));
XE void FDECL(use_crystal_ball, (struct obj *));
XE void NDECL(do_mapping);
XE void NDECL(do_vicinity_map);
X#ifdef OVERLAY
XE void FDECL(findone, (int,int,genericptr_t));
XE void FDECL(openone, (int,int,genericptr_t));
X#endif /* OVERLAY */
XE int NDECL(findit);
XE int NDECL(openit);
XE int FDECL(dosearch0, (int));
XE int NDECL(dosearch);
X
X/* ### display.c ### */
X
X#ifdef INVISIBLE_OBJECTS
XE struct obj * FDECL(vobj_at, (XCHAR_P,XCHAR_P));
X#endif /* INVISIBLE_OBJECTS */
XE void FDECL(map_background, (XCHAR_P,XCHAR_P,int));
XE void FDECL(map_trap, (struct trap *,int));
XE void FDECL(map_object, (struct obj *,int));
XE void FDECL(unmap_object, (int,int));
XE void FDECL(feel_location, (XCHAR_P,XCHAR_P));
XE void FDECL(newsym, (XCHAR_P,XCHAR_P));
XE void FDECL(shieldeff, (XCHAR_P,XCHAR_P));
XE void FDECL(tmp_at, (int,int));
XE void FDECL(swallowed, (int));
XE void FDECL(under_water, (int));
XE void NDECL(see_monsters);
XE void NDECL(set_mimic_blocking);
XE void NDECL(see_objects);
XE void NDECL(curs_on_u);
XE int NDECL(doredraw);
XE void NDECL(docrt);
XE void FDECL(show_glyph, (XCHAR_P,XCHAR_P,int));
XE void NDECL(clear_glyph_buffer);
XE void FDECL(row_refresh, (int,int,int));
XE void NDECL(cls);
XE void FDECL(flush_screen, (int));
XE int FDECL(back_to_glyph, (XCHAR_P,XCHAR_P));
XE int FDECL(zapdir_to_glyph, (int,int,int));
XE int FDECL(glyph_at, (XCHAR_P,XCHAR_P));
X
X/* ### do.c ### */
X
X#ifdef OVERLAY
XE int FDECL(drop, (struct obj *));
XE int NDECL(wipeoff);
X#endif
XE int NDECL(dodrop);
XE boolean FDECL(boulder_hits_pool, (struct obj *,int,int,BOOLEAN_P));
XE boolean FDECL(flooreffects, (struct obj *,int,int,const char *));
XE void FDECL(doaltarobj, (struct obj *));
XE boolean FDECL(canletgo, (struct obj *,const char *));
XE void FDECL(dropx, (struct obj *));
XE void FDECL(dropy, (struct obj *));
XE int NDECL(doddrop);
XE int NDECL(dodown);
XE int NDECL(doup);
X#ifdef INSURANCE
XE void NDECL(save_currentstate);
X#endif
XE void FDECL(goto_level, (d_level *,BOOLEAN_P,BOOLEAN_P,BOOLEAN_P));
XE void NDECL(deferred_goto);
XE void FDECL(revive_corpse, (struct obj *,int,BOOLEAN_P));
XE void FDECL(remove_cadavers, (struct obj **));
XE int NDECL(donull);
XE int NDECL(dowipe);
XE struct obj *FDECL(splitobj, (struct obj *,long));
XE void FDECL(set_wounded_legs, (long,int));
XE void NDECL(heal_legs);
X
X/* ### do_name.c ### */
X
XE void FDECL(getpos, (coord *,BOOLEAN_P,const char *));
XE struct monst *FDECL(christen_monst, (struct monst *,const char *));
XE int NDECL(do_mname);
XE struct obj *FDECL(oname, (struct obj *,const char *,int));
XE int NDECL(ddocall);
XE void FDECL(docall, (struct obj *));
XE char *FDECL(x_monnam, (struct monst *,int,const char *,int));
XE char *FDECL(l_monnam, (struct monst *));
XE char *FDECL(mon_nam, (struct monst *));
XE char *FDECL(Monnam, (struct monst *));
XE char *FDECL(Adjmonnam, (struct monst *,const char *));
XE char *FDECL(Amonnam, (struct monst *));
XE char *FDECL(a_monnam, (struct monst *));
XE const char *NDECL(rndmonnam);
XE const char *NDECL(hcolor);
XE char *FDECL(self_pronoun, (const char *,const char *));
X#ifdef REINCARNATION
XE const char *NDECL(roguename);
X#endif
X
X/* ### do_wear.c ### */
X
X#ifdef OVERLAY
XE int NDECL(Armor_on);
XE int NDECL(Boots_on);
XE int NDECL(Gloves_on);
XE int NDECL(Helmet_on);
XE int FDECL(select_off, (struct obj *));
XE int NDECL(take_off);
X#endif
XE void FDECL(off_msg, (struct obj *));
XE boolean FDECL(is_helmet, (struct obj *));
XE boolean FDECL(is_gloves, (struct obj *));
XE boolean FDECL(is_boots, (struct obj *));
XE boolean FDECL(is_cloak, (struct obj *));
XE boolean FDECL(is_shield, (struct obj *));
XE void NDECL(set_wear);
XE boolean FDECL(donning, (struct obj *));
XE void NDECL(cancel_don);
XE int NDECL(Armor_off);
XE int NDECL(Armor_gone);
XE int NDECL(Helmet_off);
XE int NDECL(Gloves_off);
XE int NDECL(Boots_off);
XE int NDECL(Cloak_off);
XE int NDECL(Shield_off);
XE void NDECL(Amulet_off);
XE void FDECL(Ring_on, (struct obj *));
XE void FDECL(Ring_off, (struct obj *));
XE void FDECL(Ring_gone, (struct obj *));
XE void FDECL(Blindf_on, (struct obj *));
XE void FDECL(Blindf_off, (struct obj *));
XE int NDECL(dotakeoff);
XE int NDECL(doremring);
XE int FDECL(cursed, (struct obj *));
XE int FDECL(armoroff, (struct obj *));
XE int NDECL(dowear);
XE int NDECL(doputon);
XE void NDECL(find_ac);
XE void NDECL(glibr);
XE struct obj *NDECL(some_armor);
XE void FDECL(erode_armor, (BOOLEAN_P));
XE void NDECL(reset_remarm);
XE int NDECL(doddoremarm);
XE int FDECL(destroy_arm, (struct obj *));
XE void FDECL(adj_abon, (struct obj *,SCHAR_P));
X
X/* ### dog.c ### */
X
XE void FDECL(initedog, (struct monst *));
XE void FDECL(make_familiar, (struct obj *,XCHAR_P,XCHAR_P));
XE struct monst *NDECL(makedog);
XE void NDECL(losedogs);
XE void NDECL(keepdogs);
XE void FDECL(migrate_to_level, (struct monst *,XCHAR_P,XCHAR_P));
XE int FDECL(dogfood, (struct monst *,struct obj *));
XE struct monst *FDECL(tamedog, (struct monst *,struct obj *));
X
X/* ### dogmove.c ### */
X
XE int FDECL(dog_move, (struct monst *,int));
X#ifdef OVERLAY
XE void FDECL(wantdoor, (int,int,genericptr_t));
X#endif
X
X/* ### dokick.c ### */
X
XE boolean FDECL(ghitm, (struct monst *,struct obj *));
XE int NDECL(dokick);
XE boolean FDECL(ship_object, (struct obj *,XCHAR_P,XCHAR_P,BOOLEAN_P));
XE void NDECL(obj_delivery);
XE xchar FDECL(down_gate, (XCHAR_P,XCHAR_P));
XE void FDECL(impact_drop, (struct obj *,XCHAR_P,XCHAR_P,XCHAR_P));
X
X/* ### dothrow.c ### */
X
XE int NDECL(dothrow);
XE void FDECL(hurtle, (int,int,int));
XE int FDECL(throwit, (struct obj *));
XE int FDECL(thitmonst, (struct monst *,struct obj *));
XE int FDECL(breaks, (struct obj *,BOOLEAN_P));
X
X
X/* ### drawing.c ### */
X
XE int FDECL(def_char_to_objclass, (CHAR_P));
XE int FDECL(def_char_to_monclass, (CHAR_P));
XE void FDECL(assign_graphics, (uchar *,int));
XE void FDECL(switch_graphics, (int));
X#ifdef REINCARNATION
XE void FDECL(assign_rogue_graphics, (BOOLEAN_P));
X#endif
X
X
X/* ### dungeon.c ### */
X
XE void FDECL(save_dungeon, (int));
XE void FDECL(restore_dungeon, (int));
XE void FDECL(insert_branch, (branch *,BOOLEAN_P));
XE void NDECL(init_dungeons);
XE s_level *FDECL(find_level, (const char *));
XE s_level *FDECL(Is_special, (d_level *));
XE branch *FDECL(Is_branchlev, (d_level *));
XE xchar FDECL(ledger_no, (d_level *));
XE xchar NDECL(maxledgerno);
XE xchar FDECL(depth, (d_level *));
XE xchar FDECL(dunlev, (d_level *));
XE xchar FDECL(dunlevs_in_dungeon, (d_level *));
XE xchar FDECL(ledger_to_dnum, (XCHAR_P));
XE xchar FDECL(ledger_to_dlev, (XCHAR_P));
XE xchar FDECL(deepest_lev_reached, (BOOLEAN_P));
XE boolean FDECL(on_level, (d_level *,d_level *));
XE void FDECL(next_level, (BOOLEAN_P));
XE void FDECL(prev_level, (BOOLEAN_P));
XE void NDECL(u_on_sstairs);
XE void NDECL(u_on_upstairs);
XE void NDECL(u_on_dnstairs);
XE boolean FDECL(On_stairs, (XCHAR_P,XCHAR_P));
XE void FDECL(get_level, (d_level *,int));
XE boolean FDECL(Is_botlevel, (d_level *));
XE boolean FDECL(Can_fall_thru, (d_level *));
XE boolean FDECL(Can_dig_down, (d_level *));
XE boolean FDECL(Can_rise_up, (d_level *));
X#ifdef MULDGN
XE boolean FDECL(In_quest, (d_level *));
XE boolean FDECL(In_mines, (d_level *));
XE branch *FDECL(dungeon_branch, (const char *));
XE boolean FDECL(at_dgn_entrance, (const char *));
X#endif
XE boolean FDECL(In_hell, (d_level *));
XE boolean FDECL(In_tower, (d_level *));
XE void FDECL(goto_hell, (BOOLEAN_P,BOOLEAN_P));
XE void FDECL(assign_level, (d_level *,d_level *));
XE void FDECL(assign_rnd_level, (d_level *,d_level *,int));
XE int FDECL(induced_align, (int));
XE boolean FDECL(Invocation_lev, (d_level *));
XE xchar NDECL(level_difficulty);
X#ifdef WIZARD
XE void NDECL(print_dungeon);
X#endif
X
X/* ### eat.c ### */
X
X#ifdef OVERLAY
XE int NDECL(eatmdone);
XE int NDECL(eatfood);
XE int NDECL(opentin);
XE int NDECL(unfaint);
X#endif
X#ifdef POLYSELF
XE boolean FDECL(is_edible, (struct obj *));
X#endif
XE void NDECL(init_uhunger);
XE int NDECL(Hear_again);
XE void NDECL(reset_eat);
XE void FDECL(bill_dummy_object, (struct obj *));
XE int NDECL(doeat);
XE void NDECL(gethungry);
XE void FDECL(morehungry, (int));
XE void FDECL(lesshungry, (int));
XE boolean NDECL(is_fainted);
XE void NDECL(reset_faint);
X#if 0
XE void NDECL(sync_hunger);
X#endif
XE void FDECL(newuhs, (BOOLEAN_P));
XE struct obj *FDECL(floorfood, (const char *,BOOLEAN_P));
XE void NDECL(vomit);
XE int FDECL(eaten_stat, (int,struct obj *));
XE void FDECL(food_disappears, (struct obj *));
X
X/* ### end.c ### */
X
XE int NDECL(done1);
XE int NDECL(done2);
X#ifdef OVERLAY
XE int NDECL(done_intr);
X#endif
XE void FDECL(done_in_by, (struct monst *));
XE void VDECL(panic, (const char *,...)) PRINTF_F(1,2);
XE void FDECL(done, (int));
X#ifdef NOSAVEONHANGUP
XE void NDECL(hangup);
X#endif
XE void FDECL(container_contents, (struct obj *,BOOLEAN_P,BOOLEAN_P));
XE void FDECL(terminate, (int));
X
X/* ### engrave.c ### */
X
XE const char *NDECL(random_engraving);
X#ifdef ELBERETH
XE int FDECL(sengr_at, (const char *,XCHAR_P,XCHAR_P));
X#endif
XE struct engr *FDECL(engr_at, (XCHAR_P,XCHAR_P));
XE void FDECL(u_wipe_engr, (int));
XE void FDECL(wipe_engr_at, (XCHAR_P,XCHAR_P,XCHAR_P));
XE void FDECL(read_engr_at, (int,int));
XE void FDECL(make_engr_at, (int,int,const char *,long,XCHAR_P));
XE int NDECL(freehand);
XE int NDECL(doengrave);
XE void FDECL(save_engravings, (int,int));
XE void FDECL(rest_engravings, (int));
X
X/* ### exper.c ### */
X
XE long FDECL(newuexp, (unsigned));
XE int FDECL(experience, (struct monst *,int));
XE void FDECL(more_experienced, (int,int));
XE void NDECL(losexp);
XE void NDECL(newexplevel);
XE void NDECL(pluslvl);
XE long NDECL(rndexp);
X
X/* ### explode.c ### */
X
XE void FDECL(explode, (int,int,int,int,CHAR_P));
X
X/* ### extralev.c ### */
X
X#ifdef REINCARNATION
XE void NDECL(makeroguerooms);
XE void FDECL(corr, (int,int));
XE void NDECL(makerogueghost);
X#endif
X
X/* ### files.c ### */
X
XE FILE *FDECL(fopen_datafile, (const char *,const char *));
X#ifdef MFLOPPY
XE void NDECL(set_lock_and_bones);
X#endif
XE void FDECL(set_levelfile_name, (char *,int));
XE int FDECL(create_levelfile, (int));
XE int FDECL(open_levelfile, (int));
XE void FDECL(delete_levelfile, (int));
XE void NDECL(clearlocks);
XE int FDECL(create_bonesfile, (d_level*,char **));
XE int FDECL(open_bonesfile, (d_level*,char **));
XE int FDECL(delete_bonesfile, (d_level*));
XE void NDECL(compress_bonesfile);
XE void NDECL(set_savefile_name);
X#ifdef INSURANCE
XE void FDECL(save_savefile_name, (int));
X#endif
X#if defined(WIZARD) && !defined(MICRO)
XE void NDECL(set_error_savefile);
X#endif
XE int NDECL(create_savefile);
XE int NDECL(open_savefile);
XE int NDECL(delete_savefile);
XE void FDECL(compress, (const char *));
XE void FDECL(uncompress, (const char *));
XE boolean FDECL(lock_file, (const char *,int));
XE void FDECL(unlock_file, (const char *));
XE void FDECL(read_config_file, (const char *));
XE void FDECL(check_recordfile, (const char *));
X
X/* ### fountain.c ### */
X
XE void FDECL(dogushforth, (int));
X# ifdef OVERLAY
XE void FDECL(gush, (int,int,genericptr_t));
X# endif /* OVERLAY */
XE void FDECL(dryup, (XCHAR_P,XCHAR_P));
XE void NDECL(drinkfountain);
XE void FDECL(dipfountain, (struct obj *));
X#ifdef SINKS
XE void FDECL(breaksink, (int,int));
XE void NDECL(drinksink);
X#endif
X
X/* ### hack.c ### */
X
XE boolean FDECL(revive_nasty, (int,int,const char*));
XE void FDECL(movobj, (struct obj *,XCHAR_P,XCHAR_P));
XE boolean FDECL(may_dig, (XCHAR_P,XCHAR_P));
XE boolean FDECL(invocation_pos, (XCHAR_P,XCHAR_P));
XE void NDECL(domove);
XE void NDECL(spoteffects);
XE char *FDECL(in_rooms, (XCHAR_P,XCHAR_P,int));
XE void FDECL(check_special_room, (BOOLEAN_P));
XE int NDECL(dopickup);
XE void NDECL(lookaround);
XE int NDECL(monster_nearby);
XE void FDECL(nomul, (int));
XE void FDECL(losehp, (int,const char *,BOOLEAN_P));
XE int NDECL(weight_cap);
XE int NDECL(inv_weight);
XE int NDECL(near_capacity);
XE int NDECL(max_capacity);
XE boolean FDECL(check_capacity, (const char *));
XE int NDECL(inv_cnt);
XE int FDECL(identify, (struct obj *));
X
X/* ### hacklib.c ### */
X
XE boolean FDECL(digit, (CHAR_P));
XE boolean FDECL(letter, (CHAR_P));
XE char FDECL(highc, (CHAR_P));
XE char FDECL(lowc, (CHAR_P));
XE char *FDECL(lcase, (char *));
XE char *FDECL(eos, (char *));
XE char *FDECL(s_suffix, (const char *));
XE char *FDECL(xcrypt, (const char *));
XE boolean FDECL(onlyspace, (const char *));
XE char *FDECL(tabexpand, (char *));
XE char *FDECL(visctrl, (CHAR_P));
XE const char *FDECL(ordin, (int));
XE char *FDECL(sitoa, (int));
XE int FDECL(sgn, (int));
XE int FDECL(rounddiv, (long,int));
XE int FDECL(dist2, (int,int,int,int));
XE int FDECL(distmin, (int,int,int,int));
XE boolean FDECL(online2, (int,int,int,int));
XE boolean FDECL(pmatch, (const char *,const char *));
X#ifndef STRNCMPI
XE int FDECL(strncmpi, (const char *,const char *,int));
X#endif
X#ifndef STRSTRI
X# ifndef GCC_WARN
XE  char *FDECL(strstri, (const char *,const char *));
X# else
XE  char *FDECL(strstri, (char *,const char *));
X# endif
X#endif
XE void NDECL(setrandom);
XE int NDECL(getyear);
XE char *NDECL(get_date);
XE int NDECL(phase_of_the_moon);
XE boolean NDECL(friday_13th);
XE int NDECL(night);
XE int NDECL(midnight);
X
X/* ### invent.c ### */
X
X#ifdef OVERLAY
XE int FDECL(ckunpaid, (struct obj *));
X#endif
XE struct obj *FDECL(addinv, (struct obj *));
XE struct obj *FDECL(hold_another_object,
X			(struct obj *,const char *,const char *,const char *));
XE void FDECL(useup, (struct obj *));
XE void FDECL(freeinv, (struct obj *));
XE void FDECL(delallobj, (int,int));
XE void FDECL(delobj, (struct obj *));
XE void FDECL(freeobj, (struct obj *));
XE struct obj *FDECL(sobj_at, (int,int,int));
XE int FDECL(carried, (struct obj *));
XE struct obj *FDECL(carrying, (int));
XE boolean NDECL(have_lizard);
XE struct obj *FDECL(o_on, (unsigned int,struct obj *));
XE boolean FDECL(obj_here, (struct obj *,int,int));
XE struct obj *FDECL(g_at, (int,int));
XE struct obj *FDECL(mkgoldobj, (long));
XE struct obj *FDECL(getobj, (const char *,const char *));
XE int FDECL(ggetobj, (const char *,int (*)(OBJ_P),int));
XE int FDECL(askchain, (struct obj **,const char *,int,int (*)(OBJ_P),
X			int (*)(OBJ_P),int,const char *));
XE void FDECL(prinv, (const char *,struct obj *,long));
XE char *FDECL(xprname, (struct obj *,CHAR_P,BOOLEAN_P,long));
XE int NDECL(ddoinv);
XE char FDECL(display_inventory, (const char *,BOOLEAN_P));
XE int NDECL(dotypeinv);
XE int NDECL(dolook);
XE void FDECL(stackobj, (struct obj *));
XE int NDECL(doprgold);
XE int NDECL(doprwep);
XE int NDECL(doprarm);
XE int NDECL(doprring);
XE int NDECL(dopramulet);
XE int NDECL(doprtool);
XE void FDECL(useupf, (struct obj *));
XE char *FDECL(let_to_name, (CHAR_P,BOOLEAN_P));
XE void NDECL(reassign);
XE int NDECL(doorganize);
XE int FDECL(count_unpaid, (struct obj *));
X
X/* ### ioctl.c ### */
X
X#ifdef UNIX
XE void NDECL(getwindowsz);
XE void NDECL(getioctls);
XE void NDECL(setioctls);
X# ifdef SUSPEND
XE int NDECL(dosuspend);
X# endif /* SUSPEND */
X#endif /* UNIX */
X
X/* ### lock.c ### */
X
X#ifdef OVERLAY
XE int NDECL(forcelock);
XE int NDECL(picklock);
X#endif
XE boolean FDECL(picking_at, (int,int));
XE void NDECL(reset_pick);
XE int FDECL(pick_lock, (struct obj *));
XE int NDECL(doforce);
XE boolean FDECL(boxlock, (struct obj *,struct obj *));
XE boolean FDECL(doorlock, (struct obj *,int,int));
XE int NDECL(doopen);
XE int NDECL(doclose);
X
X#ifdef MAC
X
X/* ### macerrs.c ### */
X
XE void FDECL(comment, (char *,long));
XE void FDECL(showerror, (char *,const char *));
XE Boolean FDECL(itworked, (short));
XE void FDECL(mustwork, (short));
XE void FDECL(attemptingto, (char *));
XE void FDECL(pushattemptingto, (char *));
XE void NDECL(popattempt);
X
X/* ### macfile.c ### */
X
XE int FDECL(maccreat, (const char *,long));
XE int FDECL(macopen, (const char *,int,long));
XE int FDECL(macclose, (int));
XE int FDECL(macread, (int,void *,unsigned));
XE int FDECL(macwrite, (int,void *,unsigned));
XE long FDECL(macseek, (int,long,short));
X
X/* ### macmain.c ### */
X
XE void NDECL(UnloadAllSegments);
X
X/* ### macsnd.c ### */
X
XE void FDECL(mac_speaker, (struct obj *,char *));
X
X/* ### mactopl.c ### */
X
XE void FDECL(addtopl, (const char *));
XE void FDECL(update_topl, (const char *));
X
X/* ### macunix.c ### */
X
XE int FDECL(uptodate, (int));
XE void FDECL(regularize, (char *));
XE void NDECL(getlock);
X
X/* ### macwin.c ### */
X
XE void FDECL(addToKeyQueue, (int,Boolean));
X
X/* ### maccurs.c ### */
X
XE int FDECL(clickSector, (int,int,int,int));
X
X
X#endif /* MAC */
X
X/* ### mail.c ### */
X
X#ifdef MAIL
X# ifdef UNIX
XE void NDECL(getmailstatus);
X# endif
XE void NDECL(ckmailstatus);
XE void FDECL(readmail, (struct obj *));
X#endif /* MAIL */
X
X/* ### makemon.c ### */
X
XE struct monst *FDECL(makemon, (struct permonst *,int,int));
XE boolean FDECL(enexto, (coord *,XCHAR_P,XCHAR_P,struct permonst *));
XE int FDECL(goodpos, (int,int,struct monst *,struct permonst *));
XE void FDECL(rloc, (struct monst *));
XE void FDECL(rloc_to, (struct monst *,int,int));
XE void FDECL(rloc_shk, (struct monst *));
XE void FDECL(vloc, (struct monst *));
XE struct permonst *NDECL(rndmonst);
XE struct permonst *FDECL(mkclass, (CHAR_P,int));
XE int FDECL(adj_lev, (struct permonst *));
XE struct permonst *FDECL(grow_up, (struct monst *,struct monst *));
XE int FDECL(mongets, (struct monst *,int));
XE int FDECL(golemhp, (int));
XE boolean FDECL(peace_minded, (struct permonst *));
XE void FDECL(set_malign, (struct monst *));
XE void FDECL(set_mimic_sym, (struct monst *));
X
X/* ### mcastu.c ### */
X
XE int FDECL(castmu, (struct monst *,struct attack *));
XE int FDECL(buzzmu, (struct monst *,struct attack *));
X
X/* ### mhitm.c ### */
X
XE int FDECL(fightm, (struct monst *));
XE int FDECL(mattackm, (struct monst *,struct monst *));
XE int FDECL(noattacks, (struct permonst *));
X
X/* ### mhitu.c ### */
X
X#ifdef POLYSELF
XE struct monst *NDECL(cloneu);
X#endif
XE void FDECL(expels, (struct monst *,struct permonst *,BOOLEAN_P));
XE int FDECL(mattacku, (struct monst *));
XE void FDECL(mdamageu, (struct monst *,int));
XE int FDECL(could_seduce, (struct monst *,struct monst *,struct attack *));
X#ifdef SEDUCE
XE int FDECL(doseduce, (struct monst *));
X#endif
X
X/* ### minion.c ### */
X
XE void FDECL(msummon, (struct permonst *));
XE void FDECL(summon_minion, (ALIGNTYP_P,BOOLEAN_P));
XE int FDECL(demon_talk, (struct monst *));
XE long FDECL(bribe, (struct monst *));
XE int NDECL(dprince);
XE int NDECL(dlord);
XE int NDECL(llord);
XE int NDECL(ndemon);
XE int NDECL(lminion);
X
X/* ### mklev.c ### */
X
X#ifdef OVERLAY
XE int FDECL(do_comp, (genericptr_t,genericptr_t));
X#endif
XE void NDECL(sort_rooms);
XE void FDECL(add_room, (int,int,int,int,BOOLEAN_P,SCHAR_P,BOOLEAN_P));
XE void FDECL(add_subroom, (struct mkroom *,int,int,int,int,
X			   BOOLEAN_P,SCHAR_P,BOOLEAN_P));
XE void NDECL(makecorridors);
XE void FDECL(add_door, (int,int,struct mkroom *));
XE void NDECL(mklev);
X#ifdef SPECIALIZATION
XE void FDECL(topologize, (struct mkroom *,BOOLEAN_P));
X#else
XE void FDECL(topologize, (struct mkroom *));
X#endif
XE void FDECL(place_branch, (branch *,XCHAR_P,XCHAR_P));
XE boolean FDECL(occupied, (XCHAR_P,XCHAR_P));
XE int FDECL(okdoor, (XCHAR_P,XCHAR_P));
XE void FDECL(dodoor, (int,int,struct mkroom *));
XE void FDECL(mktrap, (int,int,struct mkroom *,coord*));
XE void FDECL(mkstairs, (XCHAR_P,XCHAR_P,CHAR_P,struct mkroom *));
XE void NDECL(mkinvokearea);
X
X/* ### mkmap.c ### */
X
Xvoid FDECL(flood_fill_rm, (int,int,int,BOOLEAN_P,BOOLEAN_P));
X
X/* ### mkmaze.c ### */
X
XE void FDECL(wallification, (int,int,int,int));
XE void FDECL(walkfrom, (int,int));
XE void FDECL(makemaz, (const char *));
XE void FDECL(move, (int *,int *,int));
XE void FDECL(mazexy, (coord *));
XE void NDECL(bound_digging);
XE void FDECL(mkportal, (XCHAR_P,XCHAR_P,XCHAR_P,XCHAR_P));
XE boolean FDECL(bad_location, (XCHAR_P,XCHAR_P,XCHAR_P,XCHAR_P,XCHAR_P,XCHAR_P));
XE void FDECL(place_lregion, (XCHAR_P,XCHAR_P,XCHAR_P,XCHAR_P,
X			     XCHAR_P,XCHAR_P,XCHAR_P,XCHAR_P,
X			     XCHAR_P,d_level *));
XE void NDECL(movebubbles);
XE void NDECL(water_friction);
XE void FDECL(save_waterlevel, (int));
XE void FDECL(restore_waterlevel, (int));
X
X/* ### mkobj.c ### */
X
XE struct obj *FDECL(mkobj_at, (CHAR_P,int,int,BOOLEAN_P));
XE struct obj *FDECL(mksobj_at, (int,int,int,BOOLEAN_P));
XE struct obj *FDECL(mkobj, (CHAR_P,BOOLEAN_P));
XE int NDECL(rndmonnum);
XE struct obj *FDECL(mksobj, (int,BOOLEAN_P,BOOLEAN_P));
XE int FDECL(weight, (struct obj *));
XE void FDECL(mkgold, (long,int,int));
XE struct obj *FDECL(mkcorpstat, (int,struct permonst *,int,int,BOOLEAN_P));
XE struct obj *FDECL(mk_tt_object, (int,int,int));
XE struct obj *FDECL(mk_named_object, (int,struct permonst *,int,int,char *,int));
XE void FDECL(bless, (struct obj *));
XE void FDECL(unbless, (struct obj *));
XE void FDECL(curse, (struct obj *));
XE void FDECL(uncurse, (struct obj *));
XE void FDECL(blessorcurse, (struct obj *,int));
XE boolean FDECL(is_flammable, (struct obj *));
XE void FDECL(place_object, (struct obj *,int,int));
XE void FDECL(move_object, (struct obj *,int,int));
XE void FDECL(remove_object, (struct obj *));
XE int FDECL(bcsign, (struct obj *));
X
X/* ### mkroom.c ### */
X
XE void FDECL(mkroom, (int));
XE void FDECL(fill_zoo, (struct mkroom *));
XE boolean FDECL(nexttodoor, (int,int));
XE boolean FDECL(has_dnstairs, (struct mkroom *));
XE boolean FDECL(has_upstairs, (struct mkroom *));
XE int FDECL(somex, (struct mkroom *));
XE int FDECL(somey, (struct mkroom *));
XE boolean FDECL(inside_room, (struct mkroom *,XCHAR_P,XCHAR_P));
XE boolean FDECL(somexy, (struct mkroom *,coord *));
XE void FDECL(mkundead, (coord *));
XE struct permonst *NDECL(courtmon);
XE void FDECL(save_rooms, (int));
XE void FDECL(rest_rooms, (int));
XE struct mkroom *FDECL(search_special, (SCHAR_P));
X
X/* ### mon.c ### */
X
XE int FDECL(minwater, (struct monst *));
XE void NDECL(movemon);
XE void FDECL(meatgold, (struct monst *));
XE void FDECL(meatobj, (struct monst *));
XE void FDECL(mpickgold, (struct monst *));
XE void FDECL(mpickgems, (struct monst *));
XE void FDECL(mpickstuff, (struct monst *,const char *));
XE int FDECL(curr_mon_load, (struct monst *));
XE int FDECL(max_mon_load, (struct monst *));
XE boolean FDECL(can_carry, (struct monst *,struct obj *));
XE int FDECL(mfndpos, (struct monst *,coord *,long *,long));
XE boolean FDECL(monnear, (struct monst *,int,int));
XE void FDECL(monfree, (struct monst *));
XE void FDECL(replmon, (struct monst *,struct monst *));
XE void FDECL(relmon, (struct monst *));
XE void FDECL(mondead, (struct monst *));
XE void FDECL(mondied, (struct monst *));
XE void FDECL(mongone, (struct monst *));
XE void FDECL(monstone, (struct monst *));
XE void FDECL(monkilled, (struct monst *,const char *,UCHAR_P));
XE void FDECL(unstuck, (struct monst *));
XE void FDECL(killed, (struct monst *));
XE void FDECL(xkilled, (struct monst *,int));
XE void FDECL(mon_to_stone, (struct monst*));
XE void FDECL(mnexto, (struct monst *));
XE boolean FDECL(mnearto, (struct monst *,XCHAR_P,XCHAR_P,BOOLEAN_P));
XE void FDECL(poisontell, (int));
XE void FDECL(poisoned, (const char *,int,const char *,int));
XE void FDECL(m_respond, (struct monst *));
XE void FDECL(setmangry, (struct monst *));
XE void FDECL(wakeup, (struct monst *));
XE void NDECL(wake_nearby);
XE void FDECL(seemimic, (struct monst *));
XE void NDECL(rescham);
XE void NDECL(restartcham);
XE int FDECL(newcham, (struct monst *,struct permonst *));
XE void FDECL(golemeffects, (struct monst *,int,int));
XE boolean FDECL(angry_guards, (BOOLEAN_P));
XE void NDECL(pacify_guards);
X
X/* ### mondata.c ### */
X
XE boolean FDECL(attacktype, (struct permonst *,int));
XE boolean FDECL(poly_when_stoned, (struct permonst *));
XE boolean FDECL(resists_drli, (struct permonst *));
XE boolean FDECL(ranged_attk, (struct permonst *));
XE boolean FDECL(hates_silver, (struct permonst *));
XE boolean FDECL(can_track, (struct permonst *));
X#ifdef POLYSELF
XE boolean FDECL(breakarm, (struct permonst *));
XE boolean FDECL(sliparm, (struct permonst *));
X#endif
XE boolean FDECL(sticks, (struct permonst *));
X/* E boolean FDECL(canseemon, (struct monst *)); */
XE boolean FDECL(dmgtype, (struct permonst *,int));
XE int FDECL(max_passive_dmg, (struct monst *,struct monst *));
XE int FDECL(monsndx, (struct permonst *));
XE int FDECL(name_to_mon, (char *));
X#ifdef POLYSELF
XE boolean FDECL(webmaker, (struct permonst *));
X#endif
XE int FDECL(gender, (struct monst *));
XE boolean FDECL(levl_follower, (struct monst *));
XE struct permonst *NDECL(player_mon);
XE int FDECL(little_to_big, (int));
XE int FDECL(big_to_little, (int));
XE const char *FDECL(locomotion, (const struct permonst *,const char *));
X
X/* ### monmove.c ### */
X
X# ifdef POLYSELF
XE boolean FDECL(itsstuck, (struct monst *));
X# endif
XE boolean FDECL(mb_trapped, (struct monst *));
XE int FDECL(dochugw, (struct monst *));
XE boolean FDECL(onscary, (int,int,struct monst *));
XE int FDECL(dochug, (struct monst *));
XE int FDECL(m_move, (struct monst *,int));
XE boolean FDECL(closed_door, (int,int));
XE boolean FDECL(accessible, (int,int));
XE void FDECL(set_apparxy, (struct monst *));
X
X/* ### monst.c ### */
X
XE void NDECL(monst_init);
X
X/* ### monstr.c ### */
X
XE void NDECL(monstr_init);
X
X/* ### mplayer.c ### */
X
XE struct monst *FDECL(mk_mplayer, (struct permonst *,XCHAR_P,
X				   XCHAR_P,BOOLEAN_P));
XE void FDECL(create_mplayers, (int,BOOLEAN_P));
XE void FDECL(mplayer_talk, (struct monst *));
X
X#ifdef MICRO
X
X/* ### msdos.c,os2.c,tos.c ### */
X
XE int NDECL(tgetch);
X#  ifndef TOS
XE char NDECL(switchar);
X#  endif
X# ifndef __GO32__
XE long FDECL(freediskspace, (char *));
XE int FDECL(findfirst, (char *));
XE int NDECL(findnext);
XE char *NDECL(foundfile_buffer);
XE long FDECL(filesize, (char *));
X# endif /* __GO32__ */
XE void FDECL(chdrive, (char *));
X# ifndef TOS
XE void NDECL(disable_ctrlP);
XE void NDECL(enable_ctrlP);
X# endif
X# if defined(MICRO) && !defined(AMIGA)
XE void NDECL(get_scr_size);
X#  ifndef TOS
XE void FDECL(gotoxy, (int,int));
X#  endif
X# endif
X# ifdef TOS
XE int FDECL(_copyfile, (char *,char *));
XE int NDECL(kbhit);
XE void NDECL(set_colors);
XE void NDECL(restore_colors);
X#  ifdef SUSPEND
XE int NDECL(dosuspend);
X#  endif
X# endif /* TOS */
X
X#endif /* MICRO */
X
X/* ### mthrowu.c ### */
X
XE int FDECL(thitu, (int,int,struct obj *,const char *));
XE void FDECL(thrwmu, (struct monst *));
XE int FDECL(spitmu, (struct monst *,struct attack *));
XE int FDECL(breamu, (struct monst *,struct attack *));
XE boolean FDECL(linedup, (XCHAR_P,XCHAR_P,XCHAR_P,XCHAR_P));
XE boolean FDECL(lined_up, (struct monst *));
XE struct obj *FDECL(m_carrying, (struct monst *,int));
XE void FDECL(m_useup, (struct monst *,struct obj *));
X#ifdef MUSE
XE void FDECL(m_throw, (struct monst *,int,int,int,int,int,struct obj *));
X#endif
X
X/* ### muse.c ### */
X
X#ifdef MUSE
XE boolean FDECL(find_defensive, (struct monst *));
XE int FDECL(use_defensive, (struct monst *));
XE int FDECL(rnd_defensive_item, (struct monst *));
XE boolean FDECL(find_offensive, (struct monst *));
XE int FDECL(use_offensive, (struct monst *));
XE int FDECL(rnd_offensive_item, (struct monst *));
XE boolean FDECL(find_misc, (struct monst *));
XE int FDECL(use_misc, (struct monst *));
XE int FDECL(rnd_misc_item, (struct monst *));
XE boolean FDECL(searches_for_item, (struct monst *,struct obj *));
X#endif
X
X/* ### music.c ### */
X
XE void NDECL(awaken_soldiers);
XE int FDECL(do_play_instrument, (struct obj *));
X
X/* ### o_init.c ### */
X
XE int FDECL(letindex, (CHAR_P));
XE void NDECL(init_objects);
XE int NDECL(find_skates);
XE void NDECL(oinit);
XE void FDECL(savenames, (int));
XE void FDECL(restnames, (int));
XE void FDECL(discover_object, (int,BOOLEAN_P));
XE void FDECL(undiscover_object, (int));
XE int NDECL(dodiscovered);
X
X/* ### objects.c ### */
X
XE void NDECL(objects_init);
X
X/* ### objnam.c ### */
X
XE char *FDECL(typename, (int));
XE boolean FDECL(obj_is_pname, (struct obj *));
XE char *FDECL(distant_name, (struct obj *,char *(*)(OBJ_P)));
XE char *FDECL(xname, (struct obj *));
XE char *FDECL(doname, (struct obj *));
XE char *FDECL(singular, (struct obj *,char *(*)(OBJ_P)));
XE char *FDECL(an, (const char *));
XE char *FDECL(An, (const char *));
XE char *FDECL(The, (const char *));
XE char *FDECL(the, (const char *));
XE char *FDECL(aobjnam, (struct obj *,const char *));
XE char *FDECL(Doname2, (struct obj *));
XE char *FDECL(makeplural, (const char *));
XE char *FDECL(makesingular, (const char *));
XE struct obj *FDECL(readobjnam, (char *));
XE int FDECL(rnd_class, (int,int));
X
X/* ### options.c ### */
X
XE void NDECL(initoptions);
XE void FDECL(parseoptions, (char *,BOOLEAN_P,BOOLEAN_P));
XE int NDECL(doset);
XE int NDECL(dotogglepickup);
XE void NDECL(option_help);
XE void FDECL(next_opt, (winid,const char *));
X#ifdef TUTTI_FRUTTI
XE int FDECL(fruitadd, (char *));
X#endif
X
X/* ### pager.c ### */
X
XE int NDECL(dowhatis);
XE int NDECL(doquickwhatis);
XE int NDECL(doidtrap);
XE int NDECL(dowhatdoes);
XE int NDECL(dohelp);
XE int NDECL(dohistory);
X
X/* ### pcmain.c ### */
X
X#if defined(MICRO)
X# ifdef CHDIR
XE void FDECL(chdirx, (char *,BOOLEAN_P));
X# endif /* CHDIR */
X#endif /* MICRO */
X
X/* ### pcsys.c ### */
X
X#ifdef MICRO
XE void NDECL(flushout);
XE int NDECL(dosh);
X# ifdef MFLOPPY
XE void FDECL(eraseall, (const char *,const char *));
XE void FDECL(copybones, (int));
XE void NDECL(playwoRAMdisk);
XE int FDECL(saveDiskPrompt, (int));
XE void NDECL(gameDiskPrompt);
X# endif
XE void FDECL(append_slash, (char *));
XE void FDECL(getreturn, (const char *));
XE void VDECL(msmsg, (const char *,...));
XE FILE *FDECL(fopenp, (const char *,const char *));
XE void FDECL(msexit, (int));
X#endif /* MICRO */
X
X/* ### pctty.c ### */
X
X#if defined(MICRO)
XE void NDECL(gettty);
XE void FDECL(settty, (const char *));
XE void NDECL(setftty);
XE void VDECL(error, (const char *,...));
X#endif /* MICRO */
X
X/* ### pcunix.c ### */
X
X#if defined(MICRO)
XE void FDECL(gethdate, (char *));
XE int FDECL(uptodate, (int));
XE void FDECL(regularize, (char *));
X#endif /* MICRO */
X
X/* ### pickup.c ### */
X
XE int FDECL(collect_obj_classes, (char *,struct obj *,BOOLEAN_P,BOOLEAN_P));
X#ifdef OVERLAY
XE int FDECL(ck_bag, (struct obj *));
XE int FDECL(in_container, (struct obj *));
XE int FDECL(out_container, (struct obj *));
X#endif
XE void FDECL(pickup, (int));
XE struct obj *FDECL(pick_obj, (struct obj *));
XE int NDECL(encumber_msg);
XE int NDECL(doloot);
XE int FDECL(use_container, (struct obj *,int));
X
X/* ### pline.c ### */
X
XE void VDECL(pline, (const char *,...)) PRINTF_F(1,2);
XE void VDECL(Norep, (const char *,...)) PRINTF_F(1,2);
XE void VDECL(You, (const char *,...)) PRINTF_F(1,2);
XE void VDECL(Your, (const char *,...)) PRINTF_F(1,2);
XE void VDECL(verbalize, (const char *,...)) PRINTF_F(1,2);
XE void VDECL(raw_printf, (const char *,...)) PRINTF_F(1,2);
XE void VDECL(impossible, (const char *,...)) PRINTF_F(1,2);
XE const char *FDECL(align_str, (ALIGNTYP_P));
XE void FDECL(mstatusline, (struct monst *));
XE void NDECL(ustatusline);
X
X/* ### polyself.c ### */
X
XE void NDECL(change_sex);
XE void NDECL(newman);
X#ifdef POLYSELF
XE void NDECL(polyself);
XE int FDECL(polymon, (int));
XE void NDECL(rehumanize);
XE int NDECL(dobreathe);
XE int NDECL(dospit);
XE int NDECL(doremove);
XE int NDECL(dospinweb);
XE int NDECL(dosummon);
XE int NDECL(doconfuse);
XE int NDECL(dohide);
XE int NDECL(domindblast);
X#endif
XE const char *FDECL(body_part, (int));
XE int NDECL(poly_gender);
X#ifdef POLYSELF
XE void FDECL(ugolemeffects, (int,int));
X#endif
X
X/* ### potion.c ### */
X
XE void FDECL(make_confused, (long,BOOLEAN_P));
XE void FDECL(make_stunned, (long,BOOLEAN_P));
XE void FDECL(make_blinded, (long,BOOLEAN_P));
XE void FDECL(make_sick, (long,BOOLEAN_P));
XE void FDECL(make_vomiting, (long,BOOLEAN_P));
XE void FDECL(make_hallucinated, (long,BOOLEAN_P,long));
XE int NDECL(dodrink);
XE int FDECL(dopotion, (struct obj *));
XE int FDECL(peffects, (struct obj *));
XE void FDECL(healup, (int,int,BOOLEAN_P,BOOLEAN_P));
XE void FDECL(strange_feeling, (struct obj *,const char *));
XE void FDECL(potionhit, (struct monst *,struct obj *));
XE void FDECL(potionbreathe, (struct obj *));
XE boolean FDECL(get_wet, (struct obj *));
XE int NDECL(dodip);
XE void FDECL(djinni_from_bottle, (struct obj *));
X
X/* ### pray.c ### */
X
X#ifdef OVERLAY
XE int NDECL(prayer_done);
X#endif
XE int NDECL(dosacrifice);
XE int NDECL(dopray);
XE const char *NDECL(u_gname);
XE int NDECL(doturn);
XE const char *NDECL(a_gname);
XE const char *FDECL(a_gname_at, (XCHAR_P x,XCHAR_P y));
XE const char *FDECL(align_gname, (ALIGNTYP_P));
XE void FDECL(altar_wrath, (int,int));
X
X
X/* ### priest.c ### */
X
XE int FDECL(move_special, (struct monst *,BOOLEAN_P,SCHAR_P,BOOLEAN_P,BOOLEAN_P,
X			   XCHAR_P,XCHAR_P,XCHAR_P,XCHAR_P));
XE char FDECL(temple_occupied, (char *));
XE int FDECL(pri_move, (struct monst *));
XE void FDECL(priestini, (d_level *,struct mkroom *,int,int,BOOLEAN_P));
XE char *FDECL(priestname, (struct monst *));
XE boolean FDECL(p_coaligned, (struct monst *));
XE struct monst *FDECL(findpriest, (CHAR_P));
XE void FDECL(intemple, (int));
XE void FDECL(priest_talk, (struct monst *));
XE struct monst *FDECL(mk_roamer, (struct permonst *,ALIGNTYP_P,
X				  XCHAR_P,XCHAR_P,BOOLEAN_P));
XE void FDECL(reset_hostility, (struct monst *));
XE boolean FDECL(in_your_sanctuary, (XCHAR_P,XCHAR_P));
XE void FDECL(ghod_hitsu, (struct monst *));
XE void NDECL(angry_priest);
X
X#ifdef MULDGN
X/* ### quest.c ### */
X
XE void NDECL(quest_init);
XE void NDECL(onquest);
XE void NDECL(nemdead);
XE void NDECL(artitouch);
XE boolean NDECL(ok_to_quest);
XE void FDECL(leader_speaks, (struct monst *));
XE void NDECL(nemesis_speaks);
XE void FDECL(quest_chat, (struct monst *));
XE void FDECL(quest_talk, (struct monst *));
XE void FDECL(quest_stat_check, (struct monst *));
X
X/* ### questpgr.c ### */
X
XE void NDECL(load_qtlist);
XE boolean FDECL(is_quest_artifact, (struct obj*));
XE void FDECL(com_pager, (int));
XE void FDECL(qt_pager, (int));
XE struct permonst *NDECL(qt_montype);
XE const char *NDECL(ldrname);
XE boolean NDECL(leaderless);
X#endif
X
X/* ### random.c ### */
X
X#if defined(RANDOM) && !defined(__GO32__) /* djgpp has its own random */
XE void FDECL(srandom, (unsigned));
XE char *FDECL(initstate, (unsigned,char *,int));
XE char *FDECL(setstate, (char *));
XE long NDECL(random);
X#endif /* RANDOM */
X
X/* ### read.c ### */
X
XE int NDECL(doread);
XE void FDECL(recharge, (struct obj *,int));
XE int FDECL(seffects, (struct obj *));
X#ifdef OVERLAY
XE void FDECL(set_lit, (int,int,genericptr_t));
X#endif /* OVERLAY */
XE void FDECL(litroom, (BOOLEAN_P,struct obj *));
XE void FDECL(do_genocide, (int));
XE void FDECL(punish, (struct obj *));
XE void NDECL(unpunish);
XE boolean FDECL(cant_create, (int *));
X#if defined(WIZARD) || defined(EXPLORE_MODE)
XE boolean NDECL(create_particular);
X#endif
X
X/* ### rect.c ### */
X
XE void NDECL(init_rect);
XE NhRect *FDECL(get_rect, (NhRect *));
XE NhRect *NDECL(rnd_rect);
XE void FDECL(remove_rect, (NhRect *));
XE void FDECL(add_rect, (NhRect *));
XE void FDECL(split_rects, (NhRect *,NhRect *));
X
X/* ### restore.c ### */
X
XE int FDECL(dorecover, (int));
XE void NDECL(trickery);
XE void FDECL(getlev, (int,int,XCHAR_P,BOOLEAN_P));
XE void NDECL(minit);
X#ifdef ZEROCOMP
XE int FDECL(mread, (int,genericptr_t,unsigned int));
X#else
XE void FDECL(mread, (int,genericptr_t,unsigned int));
X#endif
X
X/* ### rip.c ### */
X
XE void FDECL(outrip, (int,winid));
X
X/* ### rnd.c ### */
X
XE int FDECL(rn2, (int));
XE int FDECL(rnl, (int));
XE int FDECL(rnd, (int));
XE int FDECL(d, (int,int));
XE int FDECL(rne, (int));
XE int FDECL(rnz, (int));
X
X/* ### rumors.c ### */
X
XE char *FDECL(getrumor, (int));
XE void FDECL(outrumor, (int,BOOLEAN_P));
XE void FDECL(save_oracles, (int));
XE void FDECL(restore_oracles, (int));
XE int FDECL(doconsult, (struct monst *));
X
X/* ### save.c ### */
X
XE int NDECL(dosave);
X#ifndef NOSAVEONHANGUP
XE int NDECL(hangup);
X#endif /* NOSAVEONHANGUP */
XE int NDECL(dosave0);
X#ifdef INSURANCE
XE void NDECL(savestateinlock);
X#endif
X#ifdef MFLOPPY
XE boolean FDECL(savelev, (int,XCHAR_P,int));
XE boolean FDECL(swapin_file, (int));
XE void NDECL(co_false);
X#else
XE void FDECL(savelev, (int,XCHAR_P,int));
X#endif
XE void FDECL(bufon, (int));
XE void FDECL(bflush, (int));
XE void FDECL(bwrite, (int,genericptr_t,unsigned int));
XE void FDECL(bclose, (int));
X#ifdef TUTTI_FRUTTI
XE void FDECL(savefruitchn, (int,int));
X#endif
X
X/* ### shk.c ### */
X
XE char *FDECL(shkname, (struct monst *));
XE void FDECL(shkgone, (struct monst *));
XE void FDECL(set_residency, (struct monst *,BOOLEAN_P));
XE void FDECL(replshk, (struct monst *,struct monst *));
XE void FDECL(restshk, (struct monst *));
XE int FDECL(inhishop, (struct monst *));
X#ifdef SOUNDS
XE boolean FDECL(tended_shop, (struct mkroom *));
X#endif
XE struct monst *FDECL(shop_keeper, (CHAR_P));
XE void FDECL(delete_contents, (struct obj *));
XE void FDECL(obfree, (struct obj *,struct obj *));
XE int NDECL(dopay);
XE void FDECL(home_shk, (struct monst *,BOOLEAN_P));
XE void FDECL(hot_pursuit, (struct monst *));
XE void FDECL(make_happy_shk, (struct monst *,BOOLEAN_P));
XE void FDECL(make_angry_shk, (struct monst *,XCHAR_P,XCHAR_P));
XE boolean FDECL(paybill, (BOOLEAN_P));
XE void FDECL(u_left_shop, (char *,BOOLEAN_P));
XE void FDECL(u_entered_shop, (char *));
XE void FDECL(pay_for_damage, (const char *));
XE long FDECL(unpaid_cost, (struct obj *));
XE long FDECL(contained_cost, (struct obj *,struct monst *,long,BOOLEAN_P));
XE long FDECL(contained_gold, (struct obj *));
XE void FDECL(picked_container, (struct obj *));
XE void FDECL(addtobill, (struct obj *,BOOLEAN_P,BOOLEAN_P,BOOLEAN_P));
XE void FDECL(splitbill, (struct obj *,struct obj *));
XE void FDECL(subfrombill, (struct obj *,struct monst *));
XE long FDECL(stolen_value, (struct obj *,XCHAR_P,XCHAR_P,BOOLEAN_P,BOOLEAN_P));
XE void FDECL(sellobj_state, (BOOLEAN_P));
XE void FDECL(sellobj, (struct obj *,XCHAR_P,XCHAR_P));
XE int FDECL(doinvbill, (int));
XE int FDECL(shkcatch, (struct obj *,XCHAR_P,XCHAR_P));
XE void FDECL(add_damage, (XCHAR_P,XCHAR_P,long));
XE char FDECL(repair_damage, (struct monst *,struct damage *));
XE int FDECL(shk_move, (struct monst *));
XE boolean FDECL(is_fshk, (struct monst *));
XE void FDECL(shopdig, (int));
XE char FDECL(inside_shop, (XCHAR_P,XCHAR_P));
XE boolean FDECL(costly_spot, (XCHAR_P,XCHAR_P));
XE struct obj *FDECL(shop_object, (XCHAR_P,XCHAR_P));
XE void FDECL(price_quote, (struct obj *));
XE void FDECL(check_unpaid, (struct obj *));
XE void FDECL(costly_gold, (XCHAR_P,XCHAR_P,long));
XE boolean FDECL(block_door, (XCHAR_P,XCHAR_P));
XE boolean FDECL(block_entry, (XCHAR_P,XCHAR_P));
X
X/* ### shknam.c ### */
X
XE void FDECL(stock_room, (int,struct mkroom *));
XE boolean FDECL(saleable, (int,struct obj *));
XE int FDECL(get_shop_item, (int));
X
X/* ### sit.c ### */
X
XE void NDECL(take_gold);
XE int NDECL(dosit);
XE void NDECL(rndcurse);
XE void NDECL(attrcurse);
X
X/* ### sounds.c ### */
X
X#ifdef SOUNDS
XE void NDECL(dosounds);
XE void FDECL(growl, (struct monst *));
XE void FDECL(yelp, (struct monst *));
XE void FDECL(whimper, (struct monst *));
X#endif
XE int NDECL(dotalk);
X
X/* ### sp_lev.c ### */
X
XE boolean FDECL(check_room, (xchar *,xchar *,xchar *,xchar *,BOOLEAN_P));
XE boolean FDECL(create_room, (XCHAR_P,XCHAR_P,XCHAR_P,XCHAR_P,
X			      XCHAR_P,XCHAR_P,XCHAR_P,XCHAR_P));
XE void FDECL(create_secret_door, (struct mkroom *,XCHAR_P));
XE boolean FDECL(dig_corridor, (coord,coord,BOOLEAN_P,SCHAR_P,SCHAR_P));
XE void FDECL(fill_room, (struct mkroom *,BOOLEAN_P));
XE boolean FDECL(load_special, (const char *));
X
X/* ### spell.c ### */
X
X#ifdef OVERLAY
XE int NDECL(learn);
X#endif
XE int FDECL(study_book, (struct obj *));
XE int NDECL(docast);
XE int FDECL(spelleffects, (int,BOOLEAN_P));
XE void NDECL(losespells);
XE int NDECL(dovspell);
X
X/* ### steal.c ### */
X
X#ifdef OVERLAY
XE int NDECL(stealarm);
X#endif
XE long NDECL(somegold);
XE void FDECL(stealgold, (struct monst *));
XE int FDECL(steal, (struct monst *));
XE void FDECL(mpickobj, (struct monst *,struct obj *));
XE void FDECL(stealamulet, (struct monst *));
XE void FDECL(relobj, (struct monst *,int,BOOLEAN_P));
X
X/* ### timeout.c ### */
X
XE void NDECL(nh_timeout);
XE void NDECL(hatch_eggs);
XE void NDECL(burn_lamps);
XE void NDECL(do_storms);
X
X
X/* ### topten.c ### */
X
XE void FDECL(topten, (int));
XE void FDECL(prscore, (int,char **));
XE struct obj *FDECL(tt_oname, (struct obj *));
X
X/* ### track.c ### */
X
XE void NDECL(initrack);
XE void NDECL(settrack);
XE coord *FDECL(gettrack, (int,int));
X
X/* ### trap.c ### */
X
XE boolean FDECL(rust_dmg, (struct obj *,const char *,int,BOOLEAN_P));
XE void FDECL(grease_protect, (struct obj *,const char *,BOOLEAN_P));
XE struct trap *FDECL(maketrap, (int,int,int));
XE boolean NDECL(safe_teleds);
XE void FDECL(fall_through, (BOOLEAN_P));
XE void FDECL(dotrap, (struct trap *));
XE void FDECL(seetrap, (struct trap *));
XE int FDECL(mintrap, (struct monst *));
XE void FDECL(selftouch, (const char *));
XE void NDECL(float_up);
XE void FDECL(fill_pit, (int,int));
XE int NDECL(float_down);
XE void NDECL(tele);
XE void FDECL(teleds, (int,int));
XE int NDECL(dotele);
XE void NDECL(level_tele);
XE void FDECL(water_damage, (struct obj *,BOOLEAN_P));
XE boolean NDECL(drown);
XE void FDECL(drain_en, (int));
XE int NDECL(dountrap);
XE int FDECL(untrap, (BOOLEAN_P));
XE boolean FDECL(chest_trap, (struct obj *,int,BOOLEAN_P));
XE void FDECL(deltrap, (struct trap *));
XE struct trap *FDECL(t_at, (int,int));
XE void FDECL(b_trapped, (const char *));
XE boolean NDECL(unconscious);
XE boolean NDECL(lava_effects);
X
X/* ### u_init.c ### */
X
XE void NDECL(u_init);
XE void NDECL(plnamesuffix);
X
X/* ### uhitm.c ### */
X
XE struct monst *FDECL(clone_mon, (struct monst *));
XE boolean FDECL(special_case, (struct monst *));
XE schar FDECL(find_roll_to_hit, (struct monst *));
XE boolean FDECL(attack, (struct monst *));
XE boolean FDECL(hmon, (struct monst *,struct obj *,int));
X#ifdef POLYSELF
XE int FDECL(damageum, (struct monst *,struct attack *));
XE void FDECL(missum, (struct monst *,struct attack *));
X#endif
XE int FDECL(passive, (struct monst *,BOOLEAN_P,int,BOOLEAN_P));
XE void FDECL(stumble_onto_mimic, (struct monst *));
X
X#ifdef UNIX
X
X/* ### unixmain.c ### */
X# ifdef PORT_HELP
XE void NDECL(port_help);
X# endif
X
X/* ### unixtty.c ### */
X
XE void NDECL(gettty);
XE void FDECL(settty, (const char *));
XE void NDECL(setftty);
XE void NDECL(intron);
XE void NDECL(introff);
XE void VDECL(error, (const char *,...)) PRINTF_F(1,2);
X
X/* ### unixunix.c ### */
X
XE void FDECL(gethdate, (const char *));
XE int FDECL(uptodate, (int));
XE void NDECL(getlock);
XE void FDECL(regularize, (char *));
X# ifdef SHELL
XE int NDECL(dosh);
X# endif /* SHELL */
X# if defined(SHELL) || defined(DEF_PAGER) || defined(DEF_MAILREADER)
XE int FDECL(child, (int));
X# endif
X
X#endif /* UNIX */
X
X/* ### vault.c ### */
X
XE boolean FDECL(grddead, (struct monst *));
XE char FDECL(vault_occupied, (char *));
XE void NDECL(invault);
XE int FDECL(gd_move, (struct monst *));
XE void NDECL(paygd);
XE long NDECL(hidden_gold);
X#ifdef SOUNDS
XE boolean NDECL(gd_sound);
X#endif
X
X/* ### version.c ### */
X
XE int NDECL(doversion);
XE int NDECL(doextversion);
X#ifdef MICRO
XE boolean FDECL(comp_times, (long));
X#endif
X
X/* ### vis_tab.c ### */
X
X#ifdef VISION_TABLES
XE void NDECL(vis_tab_init);
X#endif
X
X/* ### vision.c ### */
X
XE void NDECL(vision_init);
XE int FDECL(does_block, (int,int,struct rm*));
XE void NDECL(vision_reset);
XE void FDECL(vision_recalc, (int));
XE void FDECL(block_point, (int,int));
XE void FDECL(unblock_point, (int,int));
XE boolean FDECL(clear_path, (int,int,int,int));
XE void FDECL(do_clear_area, (int,int,int,
X			     void (*)(int,int,genericptr_t),genericptr_t));
X
X#ifdef VMS
X
X/* ### vmsfiles.c ### */
X
XE int FDECL(vms_link, (const char *,const char *));
XE int FDECL(vms_unlink, (const char *));
XE int FDECL(vms_creat, (const char *,unsigned int));
XE int FDECL(vms_open, (const char *,int,unsigned int));
XE boolean FDECL(same_dir, (const char *,const char *));
XE int FDECL(c__translate, (int));
X
X/* ### vmsmail.c ### */
X
XE unsigned long NDECL(init_broadcast_trapping);
XE unsigned long NDECL(enable_broadcast_trapping);
XE unsigned long NDECL(disable_broadcast_trapping);
X# if 0
XE struct mail_info *NDECL(parse_next_broadcast);
X# endif /*0*/
X
X/* ### vmsmain.c ### */
X
XE int FDECL(main, (int, char **));
X# ifdef CHDIR
XE void FDECL(chdirx, (char *,BOOLEAN_P));
X# endif /* CHDIR */
X
X/* ### vmsmisc.c ### */
X
XE void NDECL(vms_abort);
XE void FDECL(vms_exit, (int));
X
X/* ### vmstty.c ### */
X
XE int NDECL(vms_getchar);
XE void NDECL(gettty);
XE void FDECL(settty, (const char *));
XE void FDECL(shuttty, (const char *));
XE void NDECL(setftty);
XE void NDECL(intron);
XE void NDECL(introff);
XE void VDECL(error, (const char *,...)) PRINTF_F(1,2);
X
X/* ### vmsunix.c ### */
X
XE void FDECL(gethdate, (const char *));
XE boolean FDECL(uptodate, (int));
XE void NDECL(getlock);
XE void FDECL(regularize, (char *));
XE int NDECL(vms_getuid);
XE char *FDECL(basename, (const char *));
XE boolean FDECL(file_is_stmlf, (int));
XE char *NDECL(verify_termcap);
X# if defined(CHDIR) || defined(SHELL) || defined(SECURE)
XE void NDECL(privoff);
XE void NDECL(privon);
X# endif
X# ifdef SHELL
XE int NDECL(dosh);
X# endif
X# if defined(SHELL) || defined(MAIL)
XE int FDECL(vms_doshell, (const char *,BOOLEAN_P));
X# endif
X# ifdef SUSPEND
XE int NDECL(dosuspend);
X# endif
X
X#endif /* VMS */
X
X/* ### weapon.c ### */
X
XE int FDECL(hitval, (struct obj *,struct permonst *));
XE int FDECL(dmgval, (struct obj *,struct permonst *));
XE void NDECL(set_uasmon);
XE struct obj *FDECL(select_rwep, (struct monst *));
XE struct obj *FDECL(select_hwep, (struct monst *));
X#ifdef MUSE
XE void FDECL(possibly_unwield, (struct monst *));
XE int FDECL(mon_wield_item, (struct monst *));
XE void FDECL(sort_mwep, (struct monst *));
X#endif
XE int NDECL(abon);
XE int NDECL(dbon);
X
X/* ### were.c ### */
X
XE void FDECL(were_change, (struct monst *));
XE void FDECL(new_were, (struct monst *));
XE boolean FDECL(were_summon, (struct permonst *,BOOLEAN_P));
X#ifdef POLYSELF
XE void NDECL(you_were);
X#endif /* POLYSELF */
X
X/* ### wield.c ### */
X
XE void FDECL(setuwep, (struct obj *));
XE void NDECL(uwepgone);
XE int NDECL(dowield);
XE void FDECL(erode_weapon, (BOOLEAN_P));
XE int FDECL(chwepon, (struct obj *,int));
XE int FDECL(welded, (struct obj *));
XE void FDECL(weldmsg, (struct obj *,BOOLEAN_P));
X
X/* ### windows.c ### */
X
XE void FDECL(choose_windows, (const char *));
X
X/* ### wizard.c ### */
X
XE void NDECL(amulet);
XE int FDECL(mon_has_amulet, (struct monst *));
XE int FDECL(mon_has_special, (struct monst *));
XE int FDECL(tactics, (struct monst *));
XE void NDECL(aggravate);
XE void NDECL(clonewiz);
XE void FDECL(nasty, (struct monst*));
XE void NDECL(resurrect);
XE void NDECL(intervene);
XE void FDECL(wizdead, (struct monst *));
XE void FDECL(cuss, (struct monst *));
X
X/* ### worm.c ### */
X
XE int NDECL(get_wormno);
XE void FDECL(initworm, (struct monst *,int));
XE void FDECL(worm_move, (struct monst *));
XE void FDECL(worm_nomove, (struct monst *));
XE void FDECL(wormgone, (struct monst *));
XE void FDECL(wormhitu, (struct monst *));
XE void FDECL(cutworm, (struct monst *,XCHAR_P,XCHAR_P,struct obj *));
XE void FDECL(see_wsegs, (struct monst *));
XE void FDECL(save_worm, (int,int));
XE void FDECL(rest_worm, (int));
XE void FDECL(place_wsegs, (struct monst *));
XE void FDECL(remove_worm, (struct monst *));
XE void FDECL(place_worm_tail_randomly, (struct monst *,XCHAR_P,XCHAR_P));
XE int FDECL(count_wsegs, (struct monst *));
X
X/* ### worn.c ### */
X
XE void FDECL(setworn, (struct obj *,long));
XE void FDECL(setnotworn, (struct obj *));
XE int FDECL(find_mac, (struct monst *));
XE void FDECL(m_dowear, (struct monst *,BOOLEAN_P));
XE struct obj *FDECL(which_armor, (struct monst *,long));
XE void FDECL(mon_break_armor, (struct monst *));
X
X/* ### write.c ### */
X
XE int FDECL(dowrite, (struct obj *));
X
X/* ### zap.c ### */
X
X#if defined(OVERLAY) || defined(MUSE)
XE int FDECL(bhito, (struct obj *,struct obj *));
X#endif
XE struct monst *FDECL(revive, (struct obj *,BOOLEAN_P));
XE int FDECL(zappable, (struct obj *));
XE void FDECL(zapnodir, (struct obj *));
XE int NDECL(dozap);
XE int FDECL(zapyourself, (struct obj *));
XE void FDECL(cancel_monst, (struct monst *,struct obj *,
X			    BOOLEAN_P,BOOLEAN_P,BOOLEAN_P));
XE void FDECL(weffects, (struct obj *));
XE const char *FDECL(exclam, (int force));
XE void FDECL(hit, (const char *,struct monst *,const char *));
XE void FDECL(miss, (const char *,struct monst *));
XE struct monst *FDECL(bhit, (int,int,int,int,int (*)(MONST_P,OBJ_P),
X			     int (*)(OBJ_P,OBJ_P),struct obj *));
XE struct monst *FDECL(boomhit, (int,int));
XE void FDECL(buzz, (int,int,XCHAR_P,XCHAR_P,int,int));
XE int FDECL(zap_over_floor, (XCHAR_P,XCHAR_P,int,boolean *));
XE void FDECL(rloco, (struct obj *));
XE void FDECL(fracture_rock, (struct obj *));
XE boolean FDECL(break_statue, (struct obj *));
XE void FDECL(destroy_item, (int,int));
XE int FDECL(destroy_mitem, (struct monst *,int,int));
XE int FDECL(resist, (struct monst *,CHAR_P,int,int));
XE void NDECL(makewish);
X
X#endif /* !MAKEDEFS_C && !LEV_LEX_C */
X
X#undef E
X
X#endif /* EXTERN_H */
END_OF_FILE
if test 53881 -ne `wc -c <'include/extern.h'`; then
    echo shar: \"'include/extern.h'\" unpacked with wrong size!
fi
# end of 'include/extern.h'
fi
if test -f 'sys/unix/Makefile.doc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/unix/Makefile.doc'\"
else
echo shar: Extracting \"'sys/unix/Makefile.doc'\" \(1440 characters\)
sed "s/^X//" >'sys/unix/Makefile.doc' <<'END_OF_FILE'
X#	NetHack Makefile.
X#	SCCS Id: @(#)Makefile.doc	3.1	90/05/28
X
XGUIDEBOOK = Guidebook		# regular ASCII file
X#GUIDEBOOK = Guidebook.ps	# PostScript file
X#GUIDEBOOK = Guidebook.dvi	# TeX device-independent file
X
X# the basic guidebook
XGuidebook:	Guidebook.mn
X	tbl tmac.n Guidebook.mn | nroff | col > Guidebook
X
X# Fancier output for those with ditroff, psdit and a PostScript printer.
XGuidebook.ps:	Guidebook.mn
X	tbl tmac.n Guidebook.mn | ditroff | psdit > Guidebook.ps
X
X# Guidebook.tex is the same as Guidebook.mn but formatted with LaTeX.
X# - The invocation command for LaTeX may vary in different installations.
X# - To print Guidebook.dvi you need to use a suitable dvi-driver.
XGuidebook.dvi:	Guidebook.tex
X	latex Guidebook.tex
X
X
XGAME	= nethack
XMANDIR	= /usr/man/man6
XMANEXT	= 6
X
X# manual installation for most BSD-style systems
XGAMEMANCREATE = cp nethack.6
XLEVMANCREATE = cp lev_comp.6
XDGNMANCREATE = cp dgn_comp.6
XRCVRMANCREATE = cp recover.6
X# manual installation for most SYSV-style systems
X# GAMEMANCREATE = nroff -man nethack.6 >
X# LEVMANCREATE = nroff -man lev_comp.6 >
X# DGNMANCREATE = nroff -man dgn_comp.6 >
X# RCVRMANCREATE = nroff -man recover.6 >
X
Xmanpages:
X	-$(GAMEMANCREATE) $(MANDIR)/$(GAME).$(MANEXT)
X	-$(LEVMANCREATE) $(MANDIR)/lev_comp.$(MANEXT)
X	-$(DGNMANCREATE) $(MANDIR)/dgn_comp.$(MANEXT)
X	-$(RCVRMANCREATE) $(MANDIR)/recover.$(MANEXT)
X
X
Xspotless:
X	-rm -f Guidebook Guidebook.ps Guidebook.dvi Guidebook.aux Guidebook.log
END_OF_FILE
if test 1440 -ne `wc -c <'sys/unix/Makefile.doc'`; then
    echo shar: \"'sys/unix/Makefile.doc'\" unpacked with wrong size!
fi
# end of 'sys/unix/Makefile.doc'
fi
echo shar: End of archive 4 \(of 108\).
cp /dev/null ark4isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \
21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \
41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 \
61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 \
81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 \
101 102 103 104 105 106 107 108 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 108 archives.
    echo "Now execute 'rebuild.sh'"
    rm -f ark10[0-8]isdone ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
