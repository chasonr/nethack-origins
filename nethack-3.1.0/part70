Path: uunet!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v16i078:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Part70/108
Message-ID: <4441@master.CNA.TEK.COM>
Date: 5 Feb 93 19:19:31 GMT
Sender: news@master.CNA.TEK.COM
Lines: 1947
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1629

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 16, Issue 78
Archive-name: nethack31/Part70
Supersedes: nethack3p9: Volume 10, Issue 46-107
Environment: Amiga, Atari, Mac, MS-DOS, OS2, Unix, VMS, X11

	[This really was posted before, but apparently never left our site.]

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 70 (of 108)."
# Contents:  src/potion.c sys/unix/Makefile.src
# Wrapped by billr@saab on Wed Jan 27 16:09:14 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'src/potion.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/potion.c'\"
else
echo shar: Extracting \"'src/potion.c'\" \(30380 characters\)
sed "s/^X//" >'src/potion.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)potion.c	3.1	92/12/10		  */
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include "hack.h"
X
X#ifdef OVLB
Xstatic void NDECL(ghost_from_bottle);
Xstatic boolean FDECL(neutralizes, (struct obj *,struct obj *));
X
Xstatic int NEARDATA nothing, NEARDATA unkn;
X#endif /* OVLB */
X
Xextern boolean notonhead;	/* for long worms */
X#ifdef OVLB
Xboolean notonhead = FALSE;
X#endif /* OVLB */
X
X#ifdef OVLB
X
Xstatic const char NEARDATA beverages[] = { POTION_CLASS, 0 };
X
Xvoid
Xmake_confused(xtime,talk)
Xlong xtime;
Xboolean talk;
X{
X	long old = HConfusion;
X
X	if (!xtime && old) {
X		if (talk) {
X			if (Hallucination) You("feel less trippy now.");
X			else		   You("feel less confused now.");
X		}
X		flags.botl = 1;
X	}
X	if (xtime && !old)
X		flags.botl = 1;
X	HConfusion = xtime;
X}
X
Xvoid
Xmake_stunned(xtime,talk)
Xlong xtime;
Xboolean talk;
X{
X	long old = HStun;
X
X	if (!xtime && old) {
X		if (talk) {
X			if (Hallucination) You("feel less wobbly now.");
X			else		   You("feel a bit steadier now.");
X		}
X		flags.botl = 1;
X	}
X	if (xtime && !old) {
X		if (talk)
X			You("stagger....");
X		flags.botl = 1;
X	}
X	HStun = xtime;
X}
X
Xvoid
Xmake_sick(xtime, talk)
Xlong xtime;
Xboolean talk;
X{
X	long old = Sick;
X
X#ifdef POLYSELF
X	if (xtime && u.usym == S_FUNGUS) return;
X#endif
X	if (!xtime && old) {
X		if (talk) pline("What a relief!");
X		flags.botl = 1;
X	}
X	if (!old && xtime) {
X		You("feel deathly sick.");
X		flags.botl = 1;
X	}
X	Sick = xtime;
X}
X
Xvoid
Xmake_vomiting(xtime, talk)
Xlong xtime;
Xboolean talk;
X{
X	long old = Vomiting;
X
X	if(!xtime && old)
X	    if(talk) You("feel much less nauseous now.");
X
X	Vomiting = xtime;
X}
X
X
Xvoid
Xmake_blinded(xtime, talk)
Xlong xtime;
Xboolean talk;
X{
X	long old = Blinded;
X	boolean changed = 0;
X
X	if (u.usleep) talk = FALSE;
X
X	if (!xtime && old && !Blindfolded
X#ifdef POLYSELF
X	    && haseyes(uasmon)
X#endif
X	    ) {
X	    if (talk) {
X		if (Hallucination)
X		    pline("Far out!  Everything is all cosmic again!");
X		else		   You("can see again.");
X	    }
X	    changed = TRUE;
X	}
X	if (xtime && !old && !Blindfolded
X#ifdef POLYSELF
X	    && haseyes(uasmon)
X#endif
X	    ) {
X	    if (talk) {
X		if (Hallucination) pline("Oh, bummer!  Everything is dark!  Help!");
X		else		   pline("A cloud of darkness falls upon you.");
X	    }
X	    changed = TRUE;
X
X	    /* Before the hero goes blind, set the ball&chain variables. */
X	    if (Punished) set_bc(0);
X	}
X	Blinded = xtime;
X	if (changed) {
X	    flags.botl = 1;
X	    vision_full_recalc = 1;
X	    if (Telepat) see_monsters();
X	}
X}
X
Xvoid
Xmake_hallucinated(xtime, talk, mask)
Xlong xtime;	/* nonzero if this is an attempt to turn on hallucination */
Xboolean talk;
Xlong mask;	/* nonzero if resistance status should change by mask */
X{
X	boolean changed = 0;
X#ifdef LINT
X	const char *message = 0;
X#else
X	const char *message;
X#endif
X
X	if (!xtime)
X	    message = "Everything looks SO boring now.";
X	else
X	    message = "Oh wow!  Everything seems so cosmic!";
X
X	if (mask) {
X	    if (HHallucination) changed = TRUE;
X
X	    if (!xtime) HHalluc_resistance |= mask;
X	    else HHalluc_resistance &= ~mask;
X	} else {
X	    if (!HHalluc_resistance && (!!HHallucination != !!xtime))
X		changed = TRUE;
X	    HHallucination = xtime;
X	}
X
X	if (changed) {
X	    if (u.uswallow) {
X		swallowed(0);	/* redraw swallow display */
X	    } else {
X		/* The see_* routines should be called *before* the pline. */
X		see_monsters();
X		see_objects();
X	    }
X	    flags.botl = 1;
X	    if (!Blind && talk) pline(message);
X	}
X}
X
Xstatic void
Xghost_from_bottle()
X{
X	struct monst *mtmp = makemon(&mons[PM_GHOST], u.ux, u.uy);
X
X	if (!mtmp) {
X		pline("This bottle turns out to be empty.");
X		return;
X	}
X	if (Blind) {
X		pline("As you open the bottle, something emerges.");
X		return;
X	}
X	pline("As you open the bottle, an enormous %s emerges!",
X		Hallucination ? rndmonnam() : (const char *)"ghost");
X	if(flags.verbose)
X	    You("are frightened to death, and unable to move.");
X	nomul(-3);
X	nomovemsg = "You regain your composure.";
X}
X
Xint
Xdodrink() {
X	register struct obj *otmp;
X	const char *potion_descr;
X
X	if (Strangled) {
X		pline("If you can't breathe air, how can you drink liquid?");
X		return 0;
X	}
X	/* Is there a fountain to drink from here? */
X	if (IS_FOUNTAIN(levl[u.ux][u.uy].typ) && !Levitation) {
X		if(yn("Drink from the fountain?") == 'y') {
X			drinkfountain();
X			return 1;
X		}
X	}
X#ifdef SINKS
X	/* Or a kitchen sink? */
X	if (IS_SINK(levl[u.ux][u.uy].typ)) {
X		if (yn("Drink from the sink?") == 'y') {
X			drinksink();
X			return 1;
X		}
X	}
X#endif
X
X	otmp = getobj(beverages, "drink");
X	if(!otmp) return(0);
X#ifndef NO_SIGNAL
X	otmp->in_use = TRUE;		/* you've opened the stopper */
X#endif
X	potion_descr = OBJ_DESCR(objects[otmp->otyp]);
X	if (potion_descr && !strcmp(potion_descr, "milky") && !rn2(13)) {
X		ghost_from_bottle();
X		useup(otmp);
X		return(1);
X	} else if (potion_descr && !strcmp(potion_descr, "smoky") && !rn2(13)) {
X		djinni_from_bottle(otmp);
X		useup(otmp);
X		return(1);
X	}
X	return dopotion(otmp);
X}
X
Xint
Xdopotion(otmp)
Xregister struct obj *otmp;
X{
X	int retval;
X
X	nothing = unkn = 0;
X	if((retval = peffects(otmp)) >= 0) return(retval);
X
X	if(nothing) {
X	    unkn++;
X	    You("have a %s feeling for a moment, then it passes.",
X		  Hallucination ? "normal" : "peculiar");
X	}
X	if(otmp->dknown && !objects[otmp->otyp].oc_name_known) {
X		if(!unkn) {
X			makeknown(otmp->otyp);
X			more_experienced(0,10);
X		} else if(!objects[otmp->otyp].oc_uname)
X			docall(otmp);
X	}
X	useup(otmp);
X	return(1);
X}
X
Xint
Xpeffects(otmp)
X	register struct obj	*otmp;
X{
X	register int i, ii, isdone;
X
X	switch(otmp->otyp){
X	case POT_RESTORE_ABILITY:
X	case SPE_RESTORE_ABILITY:
X		unkn++;
X		if(otmp->cursed) {
X		    pline("Ulch!  This makes you feel mediocre!");
X		    break;
X		} else {
X		    pline("Wow!  This makes you feel %s!",
X			  (otmp->blessed) ? "great" : "good");
X		    i = rn2(A_MAX);		/* start at a random point */
X		    for(isdone = ii = 0; !isdone && ii < A_MAX; ii++) {
X			if(ABASE(i) < AMAX(i)) {
X			    ABASE(i) = AMAX(i);
X			    /* only first found if not blessed */
X			    isdone = !(otmp->blessed);
X			    flags.botl = 1;
X			}
X			if(++i >= A_MAX) i = 0;
X		    }
X		    if((ABASE(A_STR) == AMAX(A_STR)) && (u.uhs >= 3))
X			losestr(1);		/* kludge - mrs */
X		}
X		break;
X	case POT_HALLUCINATION:
X		if (Hallucination || HHalluc_resistance) nothing++;
X		make_hallucinated(HHallucination +
X			  rn1(200, 600 - 300*bcsign(otmp)), TRUE, 0L);
X		break;
X	case POT_WATER:
X		if(!otmp->blessed && !otmp->cursed) {
X			pline("This tastes like %swater.",
X			      otmp->spe == -1 ? "impure " : "");
X			lesshungry(rnd(otmp->spe == -1 ? 3 : 10));
X			break;
X		}
X		unkn++;
X		if(
X#ifdef POLYSELF
X		   is_undead(uasmon) || is_demon(uasmon) ||
X#endif
X				u.ualign.type == A_CHAOTIC) {
X		    if(otmp->blessed) {
X			pline("This burns like acid!");
X			exercise(A_CON, FALSE);
X#ifdef POLYSELF
X			if (u.ulycn != -1) {
X				Your("affinity to %s disappears!",
X				     makeplural(mons[u.ulycn].mname));
X				if(uasmon == &mons[u.ulycn] && !Polymorph_control)
X					rehumanize();
X				u.ulycn = -1;
X			}
X#endif
X			losehp(d(2,6), "potion of holy water", KILLED_BY_AN);
X		    } else if(otmp->cursed) {
X			You("feel quite proud of yourself.");
X			healup(d(2,6),0,0,0);
X			exercise(A_CON, TRUE);
X		    }
X		} else
X		    if(otmp->blessed) {
X			You("feel full of awe.");
X			make_sick(0L,TRUE);
X			exercise(A_WIS, TRUE);
X			exercise(A_CON, TRUE);
X#ifdef POLYSELF
X			if (u.ulycn != -1) {
X				You("feel purified.");
X				if(uasmon == &mons[u.ulycn] && !Polymorph_control)
X					rehumanize();
X				u.ulycn = -1;
X			}
X#endif
X			/* make_confused(0L,TRUE); */
X		    } else {
X			if(u.ualign.type == A_LAWFUL) {
X			    pline("This burns like acid!");
X			    losehp(d(2,6), "potion of unholy water",
X				KILLED_BY_AN);
X			} else
X			    You("feel full of dread.");
X			exercise(A_CON, FALSE);
X		    }
X		break;
X	case POT_BOOZE:
X		unkn++;
X		pline("Ooph!  This tastes like %s!",
X		      Hallucination ? "furniture polish" : "liquid fire");
X		if (!otmp->blessed) make_confused(HConfusion + d(3,8),FALSE);
X		/* the whiskey makes us feel better */
X		if(u.uhp < u.uhpmax) losehp(-1, "", 0); /* can't kill you */
X		lesshungry(10 * (2 + bcsign(otmp)));
X		exercise(A_WIS, FALSE);
X		if(otmp->cursed) {
X			You("pass out.");
X			multi = -rnd(15);
X			nomovemsg = "You awake with a headache.";
X		}
X		break;
X	case POT_ENLIGHTENMENT:
X		if(otmp->cursed) {
X			unkn++;
X			You("have an uneasy feeling...");
X		} else {
X			if (otmp->blessed) {
X				(void) adjattrib(A_INT, 1, FALSE);
X				(void) adjattrib(A_WIS, 1, FALSE);
X			}
X			You("feel self-knowledgeable...");
X			display_nhwindow(WIN_MESSAGE, FALSE);
X			enlightenment(FALSE);
X			pline("The feeling subsides.");
X		}
X		exercise(A_WIS, !otmp->cursed);
X		break;
X	case POT_INVISIBILITY:
X	case SPE_INVISIBILITY:
X		if(Invisible || See_invisible) nothing++;
X		else {
X		     if(!Blind)
X		       pline(Hallucination ?
X			 "Far out, man!  You can see right through yourself!" :
X			 "Gee!  All of a sudden, you can't see yourself.");
X		     else
X		       You("feel rather airy."), unkn++;
X		}
X		if (otmp->blessed && !(HInvis & FROMOUTSIDE)) {
X			nothing = 0;
X			if(yn("Do you want the invisibility to be permanent?")
X			    == 'n')
X				HInvis += rn1(15,31);
X			else HInvis |= FROMOUTSIDE;
X		} else HInvis += rn1(15,31);
X		newsym(u.ux,u.uy);	/* update position */
X		if(otmp->cursed) {
X		    pline("For some reason, you feel your presence is known.");
X		    aggravate();
X		}
X		break;
X	case POT_SEE_INVISIBLE:
X		/* tastes like fruit juice in Rogue */
X	case POT_FRUIT_JUICE:
X		unkn++;
X		if(otmp->cursed)
X			pline("Yecch!  This tastes %s.",
X			  Hallucination ? "overripe" : "rotten"
X			 );
X		else pline (Hallucination ?
X#ifdef TUTTI_FRUTTI
X		   "This tastes like 10%% real %s juice all-natural beverage." :
X		   "This tastes like %s juice.", pl_fruit
X#else
X		   "This tastes like 10%% real fruit juice all-natural beverage." :
X		   "This tastes like fruit juice."
X#endif
X			    );
X		if (otmp->otyp == POT_FRUIT_JUICE) {
X			lesshungry(10 * (2 + bcsign(otmp)));
X			break;
X		}
X		if (!otmp->cursed) {
X			/* Tell them they can see again immediately, which
X			 * will help them identify the potion...
X			 */
X			make_blinded(0L,TRUE);
X		}
X		if (otmp->blessed)
X			HSee_invisible |= FROMOUTSIDE;
X		else
X			HSee_invisible += rn1(100,750);
X		set_mimic_blocking(); /* do special mimic handling */
X		see_monsters();	/* see invisible monsters */
X		newsym(u.ux,u.uy); /* see yourself! */
X		break;
X	case POT_PARALYSIS:
X		if(Levitation || Is_waterlevel(&u.uz))
X			You("are motionlessly suspended.");
X		else
X			Your("%s are frozen to the floor!",
X				makeplural(body_part(FOOT)));
X		nomul(-(rn1(10, 25 - 12*bcsign(otmp))));
X		exercise(A_DEX, FALSE);
X		break;
X	case POT_MONSTER_DETECTION:
X	case SPE_DETECT_MONSTERS:
X		if (monster_detect(otmp, 0))
X			return(1);		/* nothing detected */
X		exercise(A_WIS, TRUE);
X		break;
X	case POT_OBJECT_DETECTION:
X	case SPE_DETECT_TREASURE:
X		if (object_detect(otmp, 0))
X			return(1);		/* nothing detected */
X		exercise(A_WIS, TRUE);
X		break;
X	case POT_SICKNESS:
X		pline("Yecch!  This stuff tastes like poison.");
X		if (otmp->blessed) {
X#ifdef TUTTI_FRUTTI
X		pline("(But in fact it was mildly stale %s juice.)", pl_fruit);
X#else
X		pline("(But in fact it was mildly stale orange juice.)");
X#endif
X			if (pl_character[0] != 'H')
X				losehp(1, "mildly contaminated potion",
X					KILLED_BY_AN);
X		} else {
X		    if(Poison_resistance)
X#ifdef TUTTI_FRUTTI
X    pline("(But in fact it was biologically contaminated %s juice.)",pl_fruit);
X#else
X    pline("(But in fact it was biologically contaminated orange juice.)");
X#endif
X		    if (pl_character[0] == 'H')
X			pline("Fortunately, you have been immunized.");
X		    else {
X			int typ = rn2(A_MAX);
X			poisontell(typ);
X			(void) adjattrib(typ,
X					Poison_resistance ? -1 : -rn1(4,3),
X					TRUE);
X			if(!Poison_resistance)
X				losehp(rnd(10)+5*!!(otmp->cursed),
X				       "contaminated potion", KILLED_BY_AN);
X			exercise(A_CON, FALSE);
X		    }
X		}
X		if(Hallucination) {
X			You("are shocked back to your senses!");
X			make_hallucinated(0L,FALSE,0L);
X		}
X		break;
X	case POT_CONFUSION:
X		if(!Confusion)
X		    if (Hallucination) {
X			pline("What a trippy feeling!");
X			unkn++;
X		    } else
X			pline("Huh, What?  Where am I?");
X		else	nothing++;
X		make_confused(HConfusion + rn1(7,16-8*bcsign(otmp)),FALSE);
X		break;
X	case POT_GAIN_ABILITY:
X		if(otmp->cursed) {
X		    pline("Ulch!  That potion tasted foul!");
X		    unkn++;
X		} else {      /* If blessed, increase all; if not, try up to */
X		    int itmp; /* 6 times to find one which can be increased. */
X		    i = -1;		/* increment to 0 */
X		    for (ii = A_MAX; ii > 0; ii--) {
X			i = (otmp->blessed ? i + 1 : rn2(A_MAX));
X			/* only give "your X is already as high as it can get"
X			   message on last attempt (except blessed potions) */
X			itmp = (otmp->blessed || ii == 1) ? 0 : -1;
X			if (adjattrib(i, 1, itmp) && !otmp->blessed)
X			    break;
X		    }
X		}
X		break;
X	case POT_SPEED:
X		if(Wounded_legs && !otmp->cursed) {
X			heal_legs();
X			unkn++;
X			break;
X		}		/* and fall through */
X	case SPE_HASTE_SELF:
X		if(!(Fast & ~INTRINSIC)) /* wwf@doe.carleton.ca */
X			You("are suddenly moving %sfaster.",
X				Fast ? "" : "much ");
X		else {
X			Your("%s get new energy.",
X				makeplural(body_part(LEG)));
X			unkn++;
X		}
X		exercise(A_DEX, TRUE);
X		Fast += rn1(10,100+60*bcsign(otmp));
X		break;
X	case POT_BLINDNESS:
X		if(Blind) nothing++;
X		make_blinded(Blinded + rn1(200, 250-125*bcsign(otmp)), TRUE);
X		break;
X	case POT_GAIN_LEVEL:
X		if (otmp->cursed) {
X			unkn++;
X			/* they went up a level */
X			if((ledger_no(&u.uz) == 1 && u.uhave.amulet) ||
X						      Can_rise_up(&u.uz)) {
X			    const char *riseup = "rise up, through the ceiling!";
X			    if(ledger_no(&u.uz) == 1) {
X			        You(riseup);
X				goto_level(&earth_level, FALSE, FALSE, FALSE);
X			    } else {
X			        register int newlev = depth(&u.uz)-1;
X				d_level newlevel;
X
X				get_level(&newlevel, newlev);
X				if(on_level(&newlevel, &u.uz)) {
X				    pline("It tasted bad.");
X				    break;
X				} else You(riseup);
X				goto_level(&newlevel, FALSE, FALSE, FALSE);
X			    }
X			}
X			else You("have an uneasy feeling.");
X			break;
X		}
X		pluslvl();
X		if (otmp->blessed)
X			/* blessed potions place you at a random spot in the
X			 * middle of the new level instead of the low point
X			 */
X			u.uexp = rndexp();
X		break;
X	case POT_HEALING:
X		You("begin to feel better.");
X		healup(d(5,2) + 5 * bcsign(otmp),
X		       1, !!(otmp->blessed), !(otmp->cursed));
X		exercise(A_STR, TRUE);
X		break;
X	case POT_EXTRA_HEALING:
X		You("feel much better.");
X		healup(d(5,4) + 5 * bcsign(otmp),
X		       2+3*!!(otmp->blessed), !(otmp->cursed), 1);
X		make_hallucinated(0L,TRUE,0L);
X		exercise(A_STR, TRUE);
X		exercise(A_CON, TRUE);
X		break;
X	case POT_LEVITATION:
X	case SPE_LEVITATION:
X		if(!Levitation) {
X			/* kludge to ensure proper operation of float_up() */
X			HLevitation = 1;
X			float_up();
X			/* reverse kludge */
X			HLevitation = 0;
X			if (otmp->cursed && !Is_waterlevel(&u.uz)) {
X	if((u.ux != xupstair || u.uy != yupstair)
X	   && (u.ux != sstairs.sx || u.uy != sstairs.sy || !sstairs.up)
X	   && (!xupladder || u.ux != xupladder || u.uy != yupladder)
X	) {
X					You("hit your %s on the ceiling.",
X						body_part(HEAD));
X					losehp(uarmh ? 1 : rnd(10),
X						"colliding with the ceiling",
X						KILLED_BY);
X				} else (void) doup();
X			}
X		} else
X			nothing++;
X		if (otmp->blessed) {
X			char buf[BUFSZ];
X			int lmoves;
X
X			makeknown(POT_LEVITATION);
X			do {
X	getlin("How many moves do you wish to levitate for? [1-300]", buf);
X			    lmoves = (!*buf || *buf=='\033') ? 0 : atoi(buf);
X			} while (lmoves < 1 || lmoves > 300);
X			HLevitation += lmoves;
X		} else HLevitation += rnd(150);
X		u.uprops[LEVITATION].p_tofn = float_down;
X		break;
X	case POT_GAIN_ENERGY:			/* M. Stephenson */
X		{	register int	 num;
X			if(otmp->cursed)
X			    You("feel lackluster.");
X			else
X			    pline("Magical energies course through your body.");
X			num = rnd(5) + 5 * otmp->blessed + 1;
X			u.uenmax += (otmp->cursed) ? -num : num;
X			u.uen += (otmp->cursed) ? -num : num;
X			if(u.uenmax <= 0) u.uenmax = 0;
X			if(u.uen <= 0) u.uen = 0;
X			flags.botl = 1;
X			exercise(A_WIS, TRUE);
X		}
X		break;
X	default:
X		impossible("What a funny potion! (%u)", otmp->otyp);
X		return(0);
X	}
X	return(-1);
X}
X
Xvoid
Xhealup(nhp, nxtra, curesick, cureblind)
X	int	nhp, nxtra;
X	register boolean curesick, cureblind;
X{
X#ifdef POLYSELF
X	if (u.mtimedone && nhp) {
X		u.mh += nhp;
X		if (u.mh > u.mhmax) u.mh = (u.mhmax += nxtra);
X	}
X#endif
X	if(nhp)	{
X		u.uhp += nhp;
X		if(u.uhp > u.uhpmax)	u.uhp = (u.uhpmax += nxtra);
X	}
X	if(cureblind)	make_blinded(0L,TRUE);
X	if(curesick)	make_sick(0L,TRUE);
X	flags.botl = 1;
X	return;
X}
X
Xvoid
Xstrange_feeling(obj,txt)
Xregister struct obj *obj;
Xregister const char *txt;
X{
X	if(flags.beginner)
X		You("have a %s feeling for a moment, then it passes.",
X		Hallucination ? "normal" : "strange");
X	else
X		pline(txt);
X
X	if(!obj)	/* e.g., crystal ball finds no traps */
X		return;
X
X	if(obj->dknown && !objects[obj->otyp].oc_name_known &&
X						!objects[obj->otyp].oc_uname)
X		docall(obj);
X	useup(obj);
X}
X
Xconst char *bottlenames[] = {
X	"bottle", "phial", "flagon", "carafe", "flask", "jar", "vial"
X};
X
Xvoid
Xpotionhit(mon, obj)
Xregister struct monst *mon;
Xregister struct obj *obj;
X{
X	register const char *botlnam = bottlenames[rn2(SIZE(bottlenames))];
X	boolean distance, isyou = (mon == &youmonst);
X
X	if(isyou) {
X		distance = 0;
X		pline("The %s crashes on your %s and breaks into shards.",
X			botlnam, body_part(HEAD));
X		losehp(rnd(2), "thrown potion", KILLED_BY_AN);
X	} else {
X		distance = distu(mon->mx,mon->my);
X		if (!cansee(mon->mx,mon->my)) pline("Crash!");
X		else {
X		    char *mnam = mon_nam(mon);
X		    char buf[BUFSZ];
X
X		    if(has_head(mon->data)) {
X			Sprintf(buf, "%s %s",
X				s_suffix(mnam),
X				(notonhead ? "body" : "head"));
X		    } else {
X			Strcpy(buf, mnam);
X		    }
X		    pline("The %s crashes on %s and breaks into shards.",
X			   botlnam, buf);
X		}
X		if(rn2(5) && mon->mhp > 1)
X			mon->mhp--;
X	}
X
X	if (cansee(mon->mx,mon->my))
X		pline("%s evaporates.", The(xname(obj)));
X
X	if (!isyou) switch (obj->otyp) {
X
X	case POT_RESTORE_ABILITY:
X	case POT_GAIN_ABILITY:
X	case POT_HEALING:
X	case POT_EXTRA_HEALING:
X		if(mon->mhp < mon->mhpmax) {
X		    mon->mhp = mon->mhpmax;
X		    if (canseemon(mon))
X			pline("%s looks sound and hale again.", Monnam(mon));
X		}
X		break;
X	case POT_SICKNESS:
X		if((mon->mhpmax > 3) && !resist(mon, POTION_CLASS, 0, NOTELL))
X			mon->mhpmax /= 2;
X		if((mon->mhp > 2) && !resist(mon, POTION_CLASS, 0, NOTELL))
X			mon->mhp /= 2;
X		if (mon->mhp > mon->mhpmax) mon->mhp = mon->mhpmax;
X		if (canseemon(mon))
X		    pline("%s looks rather ill.", Monnam(mon));
X		break;
X	case POT_CONFUSION:
X	case POT_BOOZE:
X		if(!resist(mon, POTION_CLASS, 0, NOTELL))  mon->mconf = TRUE;
X		break;
X	case POT_INVISIBILITY:
X		mon->minvis = TRUE;
X		newsym(mon->mx,mon->my);
X		break;
X	case POT_PARALYSIS:
X		if (mon->mcanmove) {
X			mon->mcanmove = 0;
X			/* really should be rnd(5) for consistency with players
X			 * breathing potions, but...
X			 */
X			mon->mfrozen = rnd(25);
X		}
X		break;
X	case POT_SPEED:
X		if (mon->mspeed == MSLOW) mon->mspeed = 0;
X		else mon->mspeed = MFAST;
X		break;
X	case POT_BLINDNESS:
X		if(haseyes(mon->data)) {
X		    register int btmp = 64 + rn2(32) +
X			rn2(32) * !resist(mon, POTION_CLASS, 0, NOTELL);
X		    mon->mblinded |= btmp;
X		    mon->mcansee = 0;
X		}
X		break;
X	case POT_WATER:
X		if (is_undead(mon->data) || is_demon(mon->data)) {
X			if (obj->blessed) {
X				pline("%s shrieks in pain!", Monnam(mon));
X				mon->mhp -= d(2,6);
X				if (mon->mhp <1) killed(mon);
X			} else if (obj->cursed) {
X				if (canseemon(mon))
X				    pline("%s looks healthier.", Monnam(mon));
X				mon->mhp += d(2,6);
X				if (mon->mhp > mon->mhpmax)
X					mon->mhp = mon->mhpmax;
X			}
X		} else if(mon->data == &mons[PM_GREMLIN]) {
X			struct monst *mtmp2 = clone_mon(mon);
X
X			if (mtmp2) {
X				mtmp2->mhpmax = (mon->mhpmax /= 2);
X				if (canseemon(mon))
X					pline("%s multiplies.", Monnam(mon));
X			}
X		}
X		break;
X/*
X	case POT_GAIN_LEVEL:
X	case POT_LEVITATION:
X	case POT_FRUIT_JUICE:
X	case POT_MONSTER_DETECTION:
X	case POT_OBJECT_DETECTION:
X		break;
X*/
X	}
X	/* Note: potionbreathe() does its own docall() */
X	if (distance==0 || ((distance < 3) && rn2(5)))
X		potionbreathe(obj);
X	else if (obj->dknown && !objects[obj->otyp].oc_name_known &&
X		   !objects[obj->otyp].oc_uname && cansee(mon->mx,mon->my))
X		docall(obj);
X	if(*u.ushops && obj->unpaid) {
X	        register struct monst *shkp =
X			shop_keeper(*in_rooms(u.ux, u.uy, SHOPBASE));
X
X		if(!shkp)
X		    obj->unpaid = 0;
X		else {
X		    (void)stolen_value(obj, u.ux, u.uy,
X				 (boolean)shkp->mpeaceful, FALSE);
X		    subfrombill(obj, shkp);
X		}
X	}
X	obfree(obj, (struct obj *)0);
X}
X
Xvoid
Xpotionbreathe(obj)
Xregister struct obj *obj;
X{
X	register int i, ii, isdone;
X
X	switch(obj->otyp) {
X	case POT_RESTORE_ABILITY:
X	case POT_GAIN_ABILITY:
X		if(obj->cursed) {
X		    pline("Ulch!  That potion smells terrible!");
X		    break;
X		} else {
X		    i = rn2(A_MAX);		/* start at a random point */
X		    for(isdone = ii = 0; !isdone && ii < A_MAX; ii++) {
X			if(ABASE(i) < AMAX(i)) {
X			    ABASE(i)++;
X			    /* only first found if not blessed */
X			    isdone = !(obj->blessed);
X			    flags.botl = 1;
X			}
X			if(++i >= A_MAX) i = 0;
X		    }
X		}
X		break;
X	case POT_HEALING:
X	case POT_EXTRA_HEALING:
X		if(u.uhp < u.uhpmax) u.uhp++, flags.botl = 1;
X		exercise(A_STR, TRUE);
X		break;
X	case POT_SICKNESS:
X		if (pl_character[0] != 'H') {
X			if(u.uhp <= 5) u.uhp = 1; else u.uhp -= 5;
X			flags.botl = 1;
X			exercise(A_CON, FALSE);
X		}
X		break;
X	case POT_HALLUCINATION:
X		You("have a vision for a moment.");
X		break;
X	case POT_CONFUSION:
X	case POT_BOOZE:
X		if(!Confusion)
X			You("feel somewhat dizzy.");
X		make_confused(HConfusion + rnd(5),FALSE);
X		break;
X	case POT_INVISIBILITY:
X		if (!See_invisible && !Invis)
X			pline("For an instant you could see through yourself!");
X		break;
X	case POT_PARALYSIS:
X		pline("Something seems to be holding you.");
X		nomul(-rnd(5));
X		exercise(A_DEX, FALSE);
X		break;
X	case POT_SPEED:
X		Fast += rnd(5);
X		Your("knees seem more flexible now.");
X		exercise(A_DEX, TRUE);
X		break;
X	case POT_BLINDNESS:
X		if (!Blind && !u.usleep) pline("It suddenly gets dark.");
X		make_blinded(Blinded + rnd(5),FALSE);
X		break;
X	case POT_WATER:
X#ifdef POLYSELF
X		if(u.umonnum == PM_GREMLIN) {
X		    struct monst *mtmp;
X		    if(mtmp = cloneu()) {
X			mtmp->mhpmax = (u.mhmax /= 2);
X			You("multiply.");
X		    }
X		}
X#endif
X/*
X	case POT_GAIN_LEVEL:
X	case POT_LEVITATION:
X	case POT_FRUIT_JUICE:
X	case POT_MONSTER_DETECTION:
X	case POT_OBJECT_DETECTION:
X*/
X		break;
X	}
X	/* note: no obfree() */
X	if (obj->dknown && !objects[obj->otyp].oc_name_known &&
X						!objects[obj->otyp].oc_uname)
X		docall(obj);
X}
X
Xstatic boolean
Xneutralizes(o1, o2)
Xregister struct obj *o1, *o2;
X{
X	switch (o1->otyp) {
X		case POT_SICKNESS:
X		case POT_HALLUCINATION:
X		case POT_BLINDNESS:
X		case POT_CONFUSION:
X			if (o2->otyp == POT_HEALING ||
X			    o2->otyp == POT_EXTRA_HEALING)
X				return TRUE;
X		case POT_HEALING:
X		case POT_EXTRA_HEALING:
X		case UNICORN_HORN:
X			if (o2->otyp == POT_SICKNESS ||
X			    o2->otyp == POT_HALLUCINATION ||
X			    o2->otyp == POT_BLINDNESS ||
X			    o2->otyp == POT_CONFUSION)
X				return TRUE;
X	}
X
X	return FALSE;
X}
X
Xboolean
Xget_wet(obj)
Xregister struct obj *obj;
X/* returns TRUE if something happened (potion should be used up) */
X{
X        if(snuff_lit(obj)) return(TRUE);
X
X	if (obj->greased) {
X		grease_protect(obj,NULL,FALSE);
X		return(FALSE);
X	}
X	switch (obj->oclass) {
X	    case WEAPON_CLASS:
X		if (!obj->oerodeproof && is_rustprone(obj) &&
X		    (obj->oeroded < MAX_ERODE) && !rn2(10)) {
X			Your("%s some%s.", aobjnam(obj, "rust"),
X			     obj->oeroded ? " more" : "what");
X			obj->oeroded++;
X			return TRUE;
X		} else break;
X	    case POTION_CLASS:
X		if (obj->otyp == POT_WATER) return FALSE;
X		Your("%s.", aobjnam(obj,"dilute"));
X		if (obj->spe == -1) {
X			obj->spe = 0;
X			obj->blessed = obj->cursed = FALSE;
X			obj->otyp = POT_WATER;
X		} else obj->spe--;
X		return TRUE;
X	    case SCROLL_CLASS:
X		if (obj->otyp != SCR_BLANK_PAPER
X#ifdef MAIL
X		    && obj->otyp != SCR_MAIL
X#endif
X		    ) {
X			if (!Blind) {
X				boolean oq1 = obj->quan == 1L;
X				pline("The scroll%s fade%s.",
X					oq1 ? "" : "s",
X					oq1 ? "s" : "");
X			}
X			if(obj->unpaid) {
X			    subfrombill(obj, shop_keeper(*u.ushops));
X			    You("erase it, you pay for it.");
X			    bill_dummy_object(obj);
X			}
X			obj->otyp = SCR_BLANK_PAPER;
X			return TRUE;
X		} else break;
X	    case SPBOOK_CLASS:
X		if (obj->otyp != SPE_BLANK_PAPER) {
X
X			if (obj->otyp == SPE_BOOK_OF_THE_DEAD) {
X	pline("%s suddenly heats up; steam rises and it remains dry.",
X				The(xname(obj)));
X			} else {
X			    if (!Blind) {
X				    boolean oq1 = obj->quan == 1L;
X				    pline("The spellbook%s fade%s.",
X					oq1 ? "" : "s", oq1 ? "s" : "");
X			    }
X			    if(obj->unpaid) {
X			        subfrombill(obj, shop_keeper(*u.ushops));
X			        You("erase it, you pay for it.");
X			        bill_dummy_object(obj);
X			    }
X			    obj->otyp = SPE_BLANK_PAPER;
X			}
X			return TRUE;
X		}
X	}
X	Your("%s wet.", aobjnam(obj,"get"));
X	return FALSE;
X}
X
Xint
Xdodip()
X{
X	register struct obj *potion, *obj;
X	const char *tmp;
X	uchar here;
X	char allow_all[2];
X	char c;
X
X	allow_all[0] = ALL_CLASSES; allow_all[1] = '\0';
X	if(!(obj = getobj(allow_all, "dip")))
X		return(0);
X
X	here = levl[u.ux][u.uy].typ;
X	/* Is there a fountain to dip into here? */
X	if (IS_FOUNTAIN(here)) {
X		if(yn("Dip it into the fountain?") == 'y') {
X			dipfountain(obj);
X			return(1);
X		}
X	}
X        if (is_pool(u.ux,u.uy)) {
X		c = (here == POOL) ? yn("Dip it into the pool?")
X				   : yn("Dip it into the moat?");
X		if(c == 'y') {
X			(void) get_wet(obj);
X			return(1);
X		}
X	}
X
X	if(!(potion = getobj(beverages, "dip into")))
X		return(0);
X	if (potion == obj && potion->quan == 1L) {
X		pline("That is a potion bottle, not a Klein bottle!");
X		return 0;
X	}
X	if(potion->otyp == POT_WATER) {
X		if (potion->blessed) {
X			if (obj->cursed) {
X				if (!Blind)
X				    Your("%s %s.",
X					  aobjnam(obj, "softly glow"),
X					  Hallucination ? hcolor() : amber);
X				uncurse(obj);
X				obj->bknown=1;
X	poof:
X				if(!(objects[potion->otyp].oc_name_known) &&
X				   !(objects[potion->otyp].oc_uname))
X					docall(potion);
X				useup(potion);
X				return(1);
X			} else if(!obj->blessed) {
X				if (!Blind) {
X				    tmp = Hallucination ? hcolor() : light_blue;
X				    Your("%s with a%s %s aura.",
X					  aobjnam(obj, "softly glow"),
X					  index(vowels, *tmp) ? "n" : "", tmp);
X				}
X				bless(obj);
X				obj->bknown=1;
X				goto poof;
X			}
X		} else if (potion->cursed) {
X			if (obj->blessed) {
X				if (!Blind)
X				    Your("%s %s.", aobjnam(obj, "glow"),
X				     Hallucination ? hcolor() : (const char *)"brown");
X				unbless(obj);
X				obj->bknown=1;
X				goto poof;
X			} else if(!obj->cursed) {
X				if (!Blind) {
X				    tmp = Hallucination ? hcolor() : Black;
X				    Your("%s with a%s %s aura.",
X					  aobjnam(obj, "glow"),
X					  index(vowels, *tmp) ? "n" : "", tmp);
X				}
X				curse(obj);
X				obj->bknown=1;
X				goto poof;
X			}
X		} else
X			if (get_wet(obj))
X			    goto poof;
X	}
X	else if(obj->oclass == POTION_CLASS && obj->otyp != potion->otyp) {
X		/* Mixing potions is dangerous... */
X		pline("The potions mix...");
X		if (obj->cursed || !rn2(10)) {
X			pline("BOOM!  They explode!");
X			exercise(A_STR, FALSE);
X			potionbreathe(obj);
X			useup(obj);
X			useup(potion);
X			losehp(rnd(10), "alchemic blast", KILLED_BY_AN);
X			return(1);
X		}
X
X		obj->blessed = obj->cursed = obj->bknown = 0;
X		if (Blind) obj->dknown = 0;
X
X		switch (neutralizes(obj, potion) ||
X			obj->spe == -1 /* diluted */ ? 1 : rnd(8)) {
X			case 1:
X				obj->otyp = POT_WATER;
X				obj->blessed = obj->cursed = 0;
X				break;
X			case 2:
X			case 3:
X				obj->otyp = POT_SICKNESS;
X				break;
X			case 4:
X				{
X				  struct obj *otmp;
X				  otmp = mkobj(POTION_CLASS,FALSE);
X				  obj->otyp = otmp->otyp;
X				  obfree(otmp, (struct obj *)0);
X				}
X				break;
X			default:
X				if (!Blind)
X			    pline("The mixture glows brightly and evaporates.");
X				useup(obj);
X				useup(potion);
X				return(1);
X		}
X
X		if (obj->otyp == POT_WATER) {
X			obj->spe = 0; /* in case it was diluted before */
X			pline("The mixture bubbles violently%s.",
X				Blind ? "" : ", then clears");
X		} else {
X			obj->spe--; /* diluted */
X			if (!Blind) {
X				pline("The mixture looks %s.",
X					OBJ_DESCR(objects[obj->otyp]));
X				obj->dknown = TRUE;
X			}
X		}
X
X		useup(potion);
X		return(1);
X	}
X
X	if(obj->oclass == WEAPON_CLASS && obj->otyp <= SHURIKEN) {
X	    if(potion->otyp == POT_SICKNESS && !obj->opoisoned) {
X		char buf[BUFSZ];
X		Strcpy(buf, The(xname(potion)));
X		pline("%s form%s a coating on %s.",
X			buf, potion->quan == 1L ? "s" : "", the(xname(obj)));
X		obj->opoisoned = TRUE;
X		goto poof;
X	    } else if(obj->opoisoned &&
X		      (potion->otyp == POT_HEALING ||
X		       potion->otyp == POT_EXTRA_HEALING)) {
X		pline("A coating wears off %s.", the(xname(obj)));
X		obj->opoisoned = 0;
X		goto poof;
X	    }
X	}
X
X	if(obj->otyp == UNICORN_HORN && neutralizes(obj, potion)) {
X		/* with multiple merged potions, we should split off one and
X		   just clear it, but clearing them all together is easier */
X		boolean more_than_one = potion->quan > 1L;
X		pline("The potion%s clear%s.",
X			more_than_one ? "s" : "",
X			more_than_one ? "" : "s");
X		potion->otyp = POT_WATER;
X		potion->blessed = 0;
X		potion->cursed = 0;
X		potion->spe = 0;
X		return(1);
X	}
X
X	pline("Interesting...");
X	return(1);
X}
X
X
Xvoid
Xdjinni_from_bottle(obj)
Xregister struct obj *obj;
X{
X	register struct monst *mtmp;
X
X	if(!(mtmp = makemon(&mons[PM_DJINNI], u.ux, u.uy))){
X		pline("It turns out to be empty.");
X		return;
X	}
X
X	if (!Blind) {
X		pline("In a cloud of smoke, %s emerges!", a_monnam(mtmp));
X		pline("%s speaks.", Monnam(mtmp));
X	} else {
X		You("smell acrid fumes.");
X		pline("Something speaks.");
X	}
X
X	switch (obj->blessed ? 0 : obj->cursed ? 4 : rn2(5)) {
X	case 0 : verbalize("I am in your debt.  I will grant one wish!");
X		makewish();
X		mongone(mtmp);
X		break;
X	case 1 : verbalize("Thank you for freeing me!");
X		(void) tamedog(mtmp, (struct obj *)0);
X		break;
X	case 2 : verbalize("You freed me!");
X		mtmp->mpeaceful = TRUE;
X		set_malign(mtmp);
X		break;
X	case 3 : verbalize("It is about time!");
X		pline("%s vanishes.", Monnam(mtmp));
X		mongone(mtmp);
X		break;
X	default: verbalize("You disturbed me, fool!");
X		break;
X	}
X}
X
X#endif /* OVLB */
X
X/*potion.c*/
END_OF_FILE
if test 30380 -ne `wc -c <'src/potion.c'`; then
    echo shar: \"'src/potion.c'\" unpacked with wrong size!
fi
# end of 'src/potion.c'
fi
if test -f 'sys/unix/Makefile.src' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/unix/Makefile.src'\"
else
echo shar: Extracting \"'sys/unix/Makefile.src'\" \(23795 characters\)
sed "s/^X//" >'sys/unix/Makefile.src' <<'END_OF_FILE'
X#	NetHack Makefile.
X#	SCCS Id: @(#)Makefile.src	3.1	93/01/25
X
X# This makefile replaces the previous Makefile.unix, Makefile.xenix,
X# Makefile.3B2, Makefile.att, and Makefile.tos.
X# Set SYSTEM to one of:
X#	'Sysunix'	-- generic UNIX
X#	'Sys3B2'	-- AT&T 3B2, 3B5, etc.
X#	'Sysatt'	-- AT&T UNIXPC, 7300, 3B1
X#	'SysV-AT'	-- Microport 286 UNIX (put -DDUMB in CFLAGS)
X#	'Systos'	-- Atari
XSYSTEM = Sysunix
X
X#
X# Make sure that your bourne shell is specified here, as you have to spawn
X# some of the commands (eg. depend) in bourne shell for them to work.
X#
X# For Systos users compiling on the ST, you'll either need a bourne shell
X# clone or you'll need to do make depend, etc. by hand. In either case,
X# the line below probably needs changing
XSHELL=/bin/sh
X
X# Pick the SYSSRC and SYSOBJ lines corresponding to your desired operating
X# system.
X#
X# for UNIX systems
XSYSSRC = ../sys/unix/ioctl.c ../sys/unix/unixmain.c ../sys/unix/unixtty.c \
X	../sys/unix/unixunix.c
XSYSOBJ = ioctl.o unixmain.o unixtty.o unixunix.o
X#
X# for Systos
X# SYSSRC = ../sys/atari/tos.c ../sys/share/pcmain.c ../sys/share/pcsys.c \
X#	../sys/share/pctty.c ../sys/share/pcunix.c
X# SYSOBJ = tos.o pcmain.o pcsys.o pctty.o pcunix.o
X
X
X# if you are using gcc as your compiler:
X#	uncomment the CC definition below if it's not in your environment
X#	if you get setcgtty() warnings during execution, you are feeding gcc
X#		a non-ANSI <sys/ioctl.h> -- either run fixincludes on it or use
X#		-traditional in CFLAGS
X# CC = gcc
X#
X#	For Bull DPX/2 systems at B.O.S. 2.0 or higher use the following:
X#
X# CC = gcc -ansi -D_BULL_SOURCE -D_XOPEN_SOURCE -D_POSIX_SOURCE
X# 
X#	If you are using GCC 2.2.2 or higher on a DPX/2, just use:
X#
X# CC = gcc -ansi
X#
X# if you're debugging and want gcc to check as much as possible, use:
X# CC = gcc -W -Wimplicit -Wreturn-type -Wunused -Wformat -Wswitch -Wshadow -Wcast-qual -Wwrite-strings -DGCC_WARN
X
X# flags may have to be changed as required
X# flags for 286 Xenix:
X# CFLAGS = -Ml2t16 -O -LARGE -I../include
X# LFLAGS = -Ml -F 4000 -SEG 512
X
X# flags for 286 Microport SysV-AT
X# CFLAGS = -DDUMB -Ml -I../include
X# LFLAGS = -Ml
X
X# flags for Atari gcc
X# CFLAGS = -O -I../include
X# LFLAGS = -s
X
X# flags for AIX 3.1 cc on IBM RS/6000 to define
X# a suitable subset of standard libraries
X# (note that there is more info regarding the "-qchars=signed"
X# switch in file Install.unx note 8)
X# CFLAGS = -D_NO_PROTO -D_XOPEN_SOURCE -O -I../include -qchars=signed
X
X# flags for A/UX 2.01 using native cc or c89
X# gcc predefines AUX so that's not needed there
X# Remember to use -lcurses for WINLIB below !
X# CFLAGS = -ZS -D_POSIX_SOURCE -O -I../include -DAUX
X
X# flags for debugging:
X# CFLAGS = -g -I../include
X
XCFLAGS = -g -I../include
XLFLAGS =
X
X
X# Set the WINSRC, WINOBJ, and WINLIB lines to correspond to your desired
X# combination of windowing systems.  Also set windowing systems in config.h.
X#
X# files for a straight tty port using no native windowing system
XWINTTYSRC = ../win/tty/getline.c ../win/tty/termcap.c ../win/tty/topl.c \
X	../win/tty/wintty.c
XWINTTYOBJ = getline.o termcap.o topl.o wintty.o
X#
X# files for an X11 port
XWINX11SRC = ../win/X11/Window.c ../win/X11/dialogs.c ../win/X11/winX.c \
X	../win/X11/winmap.c  ../win/X11/winmenu.c ../win/X11/winmesg.c \
X	../win/X11/winmisc.c ../win/X11/winstat.c ../win/X11/wintext.c \
X	../win/X11/winval.c
XWINX11OBJ = Window.o dialogs.o winX.o winmap.o winmenu.o winmesg.o \
X	winmisc.o winstat.o wintext.o winval.o
X#
X# 
XWINSRC = $(WINTTYSRC)
XWINOBJ = $(WINTTYOBJ)
X
X# on some systems the termcap library is in -ltermcap or -lcurses
X# on 386 Xenix, the -ltermlib tputs() seems not to work; use -lcurses instead
X# Sysatt uses shared library in lieu of this option
X# Systos needs -lcurses16 if you use -mshort
X# AIX 3.1 on RS/6000 likes -lcurses if TERMINFO defined in config.h
X# and -ltermcap otherwise
X#
X# libraries for tty ports
X# WINTTYLIB = -ltermcap
X# WINTTYLIB = -lcurses
X# WINTTYLIB = -lcurses16
XWINTTYLIB = -ltermlib
X#
X# libraries for X11
XWINX11LIB = -lXaw -lXmu -lXext -lXt -lX11
X# WINX11LIB = -lXaw -lXmu -lXt -lX11
X#
X#
XWINLIB = $(WINTTYLIB)
X
X# any other strange libraries your system needs (for Sysunix only -- the more
X# specialized targets should already be right)
X#
X# on HP-UX, the malloc(3x) routines in libmalloc.a seem to align things
X# better than the malloc(3) ones in libc.a
X# LIBS = -lmalloc
X#
X# DPX/2's also use the malloc(3x) routines.  In addition, if you are building
X# for X11, you must include libinet.a.
X# LIBS = -lmalloc -linet
XLIBS =
X
X# make NetHack
XGAME     = nethack
X
X# if you defined RANDOM in unixconf.h/tosconf.h since your system did not come
X# with a reasonable random number generator
X# RANDOBJ = random.o
XRANDOBJ =
X
X
X
X# ----------------------------------------
X#
X# Nothing below this line should have to be changed.
X#
X# Other things that have to be reconfigured are in config.h,
X# {unixconf.h, pcconf.h, tosconf.h}, and possibly system.h
X
XMAKEDEFS = ../util/makedefs
X
X# all .c that are part of the main NetHack program and are not operating- or
X# windowing-system specific
XHACKCSRC = allmain.c alloc.c apply.c artifact.c attrib.c ball.c bones.c\
X	   botl.c cmd.c dbridge.c decl.c detect.c display.c do.c do_name.c\
X	   do_wear.c dog.c dogmove.c dokick.c dothrow.c drawing.c dungeon.c\
X	   eat.c end.c engrave.c exper.c explode.c extralev.c files.c\
X	   fountain.c hack.c hacklib.c invent.c lock.c mail.c makemon.c\
X	   mcastu.c mhitm.c mhitu.c minion.c mklev.c mkmap.c mkmaze.c\
X	   mkobj.c mkroom.c mon.c mondata.c monmove.c monst.c mplayer.c\
X	   mthrowu.c muse.c music.c o_init.c objects.c objnam.c options.c\
X	   pager.c pickup.c pline.c polyself.c potion.c pray.c priest.c\
X	   quest.c questpgr.c read.c rect.c restore.c rip.c rnd.c rumors.c\
X	   save.c shk.c shknam.c sit.c sounds.c sp_lev.c spell.c steal.c\
X	   timeout.c topten.c track.c trap.c u_init.c uhitm.c vault.c\
X	   version.c vision.c weapon.c were.c wield.c windows.c wizard.c\
X	   worm.c worn.c write.c zap.c
X
X# all operating-system-dependent .c (for dependencies and such)
XSYSCSRC = ../sys/atari/tos.c ../sys/share/pcmain.c ../sys/share/pcsys.c \
X	../sys/share/pctty.c ../sys/share/pcunix.c ../sys/share/random.c \
X	../sys/unix/ioctl.c ../sys/unix/unixmain.c ../sys/unix/unixtty.c \
X	../sys/unix/unixunix.c
X
X# all windowing-system-dependent .c (for dependencies and such)
XWINCSRC = $(WINTTYSRC) $(WINX11SRC)
X
X# .c files for this version (for date.h)
XVERSOURCES = $(HACKCSRC) $(SYSSRC) $(WINSRC) monstr.c vis_tab.c
X
X# .c files for all UNIX versions (for lint and tags)
XCSOURCES = $(HACKCSRC) $(SYSSRC) $(WINCSRC) monstr.c vis_tab.c
X
X
X# all .h files except date.h, onames.h, pm.h, and vis_tab.h which would
X# cause dependency loops if run through "make depend"
X# and dgn_comp.h, dgn_file.h, lev_comp.h, special level & dungeon files.
X#
XHACKINCL = align.h amiconf.h artifact.h artilist.h attrib.h color.h config.h\
X	   coord.h decl.h def_os2.h display.h dungeon.h edog.h emin.h engrave.h\
X	   epri.h eshk.h extern.h flag.h func_tab.h global.h hack.h lev.h\
X	   macconf.h mfndpos.h micro.h mkroom.h monattk.h mondata.h monflag.h\
X	   monst.h monsym.h obj.h objclass.h os2conf.h patchlevel.h pcconf.h\
X	   permonst.h prop.h rect.h rm.h sp_lev.h spell.h system.h termcap.h\
X	   tosconf.h tradstdc.h trampoli.h trap.h unixconf.h vault.h vision.h\
X	   vmsconf.h wintty.h winX.h winprocs.h wintype.h you.h youprop.h
X
XHSOURCES = $(HACKINCL) date.h onames.h pm.h vis_tab.h\
X		lev_comp.h dgn_comp.h dgn_file.h
X
X# the following .o's _must_ be made before any others (for makedefs)
XFIRSTOBJ = monst.o objects.o
X
XHOBJ = $(FIRSTOBJ) allmain.o alloc.o apply.o artifact.o attrib.o ball.o\
X	bones.o botl.o cmd.o dbridge.o decl.o detect.o display.o do.o\
X	do_name.o do_wear.o dog.o dogmove.o dokick.o dothrow.o drawing.o\
X	dungeon.o eat.o end.o engrave.o exper.o explode.o extralev.o\
X	files.o fountain.o hack.o hacklib.o invent.o lock.o mail.o\
X	makemon.o mcastu.o mhitm.o mhitu.o minion.o mklev.o mkmap.o\
X	mkmaze.o mkobj.o mkroom.o mon.o mondata.o monmove.o monstr.o\
X	mplayer.o mthrowu.o muse.o music.o o_init.o objnam.o options.o\
X	pager.o pickup.o pline.o polyself.o potion.o pray.o priest.o\
X	quest.o questpgr.o read.o rect.o restore.o rip.o rnd.o rumors.o\
X	save.o shk.o shknam.o sit.o sounds.o sp_lev.o spell.o steal.o\
X	timeout.o topten.o track.o trap.o u_init.o uhitm.o vault.o\
X	vision.o vis_tab.o weapon.o were.o wield.o windows.o wizard.o\
X	worm.o worn.o write.o zap.o\
X	$(RANDOBJ) $(SYSOBJ) $(WINOBJ) version.o
X# the .o files from the HACKCSRC, SYSSRC, and WINSRC lists
X
X$(GAME):	$(SYSTEM)
X	@echo "$(GAME) is up to date."
X
XSysunix:	$(HOBJ) Makefile
X	@echo "Loading ..."
X	@$(CC) $(LFLAGS) -o $(GAME) $(HOBJ) $(WINLIB) $(LIBS)
X	@touch Sysunix
X
XSys3B2:	$(HOBJ) Makefile
X	@echo "Loading ..."
X	@$(CC) $(LFLAGS) -o $(GAME) $(HOBJ) $(WINLIB) -lmalloc
X	@touch Sys3B2
X
XSysatt:	$(HOBJ) Makefile
X	@echo "Loading ..."
X	@$(LD) $(LFLAGS) /lib/crt0s.o /lib/shlib.ifile -o $(GAME) $(HOBJ)
X	@touch Sysatt
X
XSystos:	$(HOBJ) Makefile
X	@echo "Loading ..."
X	@$(CC) $(LFLAGS) -o $(GAME) $(HOBJ) $(WINLIB)
X	@touch Systos
X
XSysV-AT:	DUMB.Setup $(HOBJ) Makefile
X	@echo "Loading ..."
X	@$(CC) $(LFLAGS) -o $(GAME) $(HOBJ) $(WINLIB)
X	@touch SysV-AT
X
XDUMB.Setup:	../include/extern.h
X	cp ../include/extern.h ../include/extern.h.BAK 
X	cat ../include/extern.h | \
X		sed -e '/^E\ int\ /!b' \
X			-e '/[^;/ 	]$$/N' \
X			-e '/[(][*]occupation[)]/b' \
X			-e '/[(][*]afternmv[)]/b' \
X			-e '/float_down/b' \
X			-e '/done1/b' \
X			-e '/identify/b' \
X			-e '/Hear_again/b' \
X			-e '/hangup/b' \
X			-e 's/^\(.*\)$$/\/\* \1 \/\*\*\//' | \
X		sed -e '/^E\ void\ /!b' \
X			-e '/[^;/ 	]$$/N' \
X			-e 's/^\(.*\)$$/\/\* \1 \/\*\*\//' \
X				>../include/extern.DUMB 
X	cp ../include/extern.DUMB ../include/extern.h 
X	@touch DUMB.Setup
X
Xall:	$(GAME)
X
X
X#	dependencies for makedefs and its outputs, which the util
X#	Makefile is responsible for keeping up to date
X#
X
X# special rules, to force update of makedefs, real dependencies should be
X# below in the 'make depend' output.
Xmonst.o:
X	$(CC) $(CFLAGS) -c monst.c
X	@rm -f $(MAKEDEFS)
X
Xobjects.o:
X	$(CC) $(CFLAGS) -c objects.c
X	@rm -f $(MAKEDEFS)
X
X$(MAKEDEFS): ../util/makedefs.c  ../include/artilist.h
X	@( cd ../util ; $(MAKE) makedefs)
X
X../include/onames.h: $(MAKEDEFS)
X	@( cd ../util ; $(MAKE) ../include/onames.h )
X../include/pm.h: $(MAKEDEFS)
X	@( cd ../util ; $(MAKE) ../include/pm.h )
Xmonstr.c: $(MAKEDEFS)
X	@( cd ../util ; $(MAKE) ../src/monstr.c )
X../include/vis_tab.h: $(MAKEDEFS)
X	@( cd ../util ; $(MAKE) ../include/vis_tab.h )
Xvis_tab.c: $(MAKEDEFS)
X	@( cd ../util ; $(MAKE) ../src/vis_tab.c )
X
X#	date.h should be remade any time any of the source or include code
X#	is modified.  Unfortunately, this would make the contents of this
X#	file far more complex.  Since "hack.h" depends on most of the include
X#	files, we kludge around this by making date.h dependent on hack.h,
X#	even though it doesn't include this file.
X#
X#	hack.h depends on makedefs' output, so we know makedefs will be
X#	up to date before being executed
X../include/date.h:	$(VERSOURCES) ../include/hack.h
X	( cd ../util ; $(MAKE) ../include/date.h )
X
X
Xlint:
X# lint cannot have -p here because (i) capitals are meaningful:
X# [Ww]izard, (ii) identifiers may coincide in the first six places:
X# doweararm() versus dowearring().
X# _flsbuf comes from <stdio.h>, a bug in the system libraries.
X	@echo lint -axbh -DLINT ...
X	@lint -axbh -I../include -DLINT $(CSOURCES) | sed '/_flsbuf/d'
X
X
Xtags: $(CSOURCES)
X	@echo ctags -tw ...
X	@ctags -tw $(CSOURCES)
X	@( cd ../include ; ctags -tw $(HSOURCES) )
X	@( cd ../util ; $(MAKE) tags )
X
Xclean:
X	rm -f *.o
X
Xspotless: clean
X	rm -f a.out core $(GAME) Sys*
X	rm -f ../include/date.h ../include/onames.h ../include/pm.h
X	rm -f monstr.c ../include/vis_tab.h vis_tab.c
X
X
Xdepend:
X# For the moment we are lazy and disregard /usr/include files because
X# the sources contain them conditionally. Perhaps we should use cpp.
X#		( /bin/grep '^#[ 	]*include' $$i | sed -n \
X#			-e 's,<\(.*\)>,"/usr/include/\1",' \
X#
X# extern.h is ignored, even though its declared function types may affect the
X# compilation of all the .c files, since extern.h changes every time the
X# type of an external function does, and we would spend all our time recompiling
X# if we did not ignore it.  the risk is minimal, as lint should pick up any
X# calls to the modified function that were not modified accordingly.
X#
X# patchlev.h is the name MS-DOS uses to refer to patchlevel.h after it gets
X# through truncating the name, but it does not really exist
X#
X# theory of operation:
X#	for each file
X#		for each include line
X#			pick out filename from within ""
X#			delete unwanted names
X#			prepend ../include/
X#			squirrel away in hold space
X#		at end of file
X#			pick up hold space
X#			change newlines to spaces
X#			prepend file:
X#			change .c to .o
X#			add command if necessary
X#
X	for i in ${SYSCSRC} ${WINCSRC}; do \
X		( echo '#include ""' | cat - $$i | \
X		/bin/grep '^#[ 	]*include[ 	]*"' | sed -n \
X			-e 's/[^"]*"\([^"]*\)".*/\1/' \
X			-e 's/patchlev.h//' \
X			-e 's/.*\.h/..\/include\/&/' \
X			-e H \
X			-e '$$g' -e '$$s/\n/ /g' \
X			-e '$$s;.*;'$$i': '$$i'&;' \
X			-e '$$s;\.\./[^/]*/[^/]*/\([^.]*\)\.c;\1.o;' \
X			-e '$$s;.*;&\
X		$$(CC) $$(CFLAGS) -c '$$i';p' \
X			>> makedep); done
X	for i in ${HACKCSRC}; do \
X		( /bin/grep '^#[ 	]*include[ 	]*"' $$i | sed -n \
X			-e 's/[^"]*"\([^"]*\)".*/\1/' \
X			-e 's/patchlev.h//' \
X			-e 's/.*\.h/..\/include\/&/' \
X			-e H \
X			-e '$$g' -e '$$s/\n/ /g' \
X			-e '$$s/.*/'$$i': &/' \
X			-e '$$s/\.c:/.o:/p' \
X			>> makedep); done
X	for i in ${HACKINCL}; do \
X	    ( /bin/grep '^#[ 	]*include[ 	]*"' ../include/$$i | sed -n \
X			-e 's/[^"]*"\([^"]*\)".*/\1/' \
X			-e 's/extern.h//' \
X			-e 's/.*\.h/..\/include\/&/' \
X			-e H \
X			-e '$$g' -e '$$s/\n/ /g' \
X			-e '$$s/.*/..\/include\/'$$i': &\
X		touch ..\/include\/'$$i/p \
X			>> makedep); done
X	@echo '/^# DO NOT DELETE THIS LINE/+2,$$d' >eddep
X	@echo '$$r makedep' >>eddep
X	@echo 'w' >>eddep
X	@cp Makefile Makefile.bak
X	ed - Makefile < eddep
X	@rm -f eddep makedep
X	@echo '# DEPENDENCIES MUST END AT END OF FILE' >> Makefile
X	@echo '# IF YOU PUT STUFF HERE IT WILL GO AWAY' >> Makefile
X	@echo '# see make depend above' >> Makefile
X	- diff Makefile.bak Makefile
X	@rm -f Makefile.bak
X
X# DO NOT DELETE THIS LINE
X
Xtos.o: ../sys/atari/tos.c  ../include/hack.h ../include/termcap.h
X	$(CC) $(CFLAGS) -c ../sys/atari/tos.c
Xpcmain.o: ../sys/share/pcmain.c  ../include/hack.h
X	$(CC) $(CFLAGS) -c ../sys/share/pcmain.c
Xpcsys.o: ../sys/share/pcsys.c  ../include/hack.h ../include/wintty.h
X	$(CC) $(CFLAGS) -c ../sys/share/pcsys.c
Xpctty.o: ../sys/share/pctty.c  ../include/hack.h ../include/wintty.h
X	$(CC) $(CFLAGS) -c ../sys/share/pctty.c
Xpcunix.o: ../sys/share/pcunix.c  ../include/hack.h
X	$(CC) $(CFLAGS) -c ../sys/share/pcunix.c
Xrandom.o: ../sys/share/random.c  ../include/hack.h
X	$(CC) $(CFLAGS) -c ../sys/share/random.c
Xioctl.o: ../sys/unix/ioctl.c  ../include/hack.h ../include/termcap.h
X	$(CC) $(CFLAGS) -c ../sys/unix/ioctl.c
Xunixmain.o: ../sys/unix/unixmain.c  ../include/hack.h
X	$(CC) $(CFLAGS) -c ../sys/unix/unixmain.c
Xunixtty.o: ../sys/unix/unixtty.c  ../include/hack.h ../include/wintty.h
X	$(CC) $(CFLAGS) -c ../sys/unix/unixtty.c
Xunixunix.o: ../sys/unix/unixunix.c  ../include/hack.h
X	$(CC) $(CFLAGS) -c ../sys/unix/unixunix.c
Xgetline.o: ../win/tty/getline.c  ../include/hack.h ../include/wintty.h ../include/func_tab.h
X	$(CC) $(CFLAGS) -c ../win/tty/getline.c
Xtermcap.o: ../win/tty/termcap.c  ../include/hack.h ../include/wintty.h ../include/termcap.h
X	$(CC) $(CFLAGS) -c ../win/tty/termcap.c
Xtopl.o: ../win/tty/topl.c  ../include/hack.h ../include/termcap.h ../include/wintty.h
X	$(CC) $(CFLAGS) -c ../win/tty/topl.c
Xwintty.o: ../win/tty/wintty.c  ../include/hack.h ../include/termcap.h ../include/wintty.h
X	$(CC) $(CFLAGS) -c ../win/tty/wintty.c
XWindow.o: ../win/X11/Window.c  ../include/WindowP.h
X	$(CC) $(CFLAGS) -c ../win/X11/Window.c
Xdialogs.o: ../win/X11/dialogs.c  ../include/config.h
X	$(CC) $(CFLAGS) -c ../win/X11/dialogs.c
XwinX.o: ../win/X11/winX.c  ../include/hack.h ../include/winX.h \
X		../win/X11/nh72icon ../win/X11/nh56icon ../win/X11/nh32icon
X	$(CC) $(CFLAGS) -c ../win/X11/winX.c
Xwinmap.o: ../win/X11/winmap.c  ../include/Window.h ../include/hack.h ../include/winX.h
X	$(CC) $(CFLAGS) -c ../win/X11/winmap.c
Xwinmenu.o: ../win/X11/winmenu.c  ../include/hack.h ../include/winX.h
X	$(CC) $(CFLAGS) -c ../win/X11/winmenu.c
Xwinmesg.o: ../win/X11/winmesg.c  ../include/Window.h ../include/hack.h ../include/winX.h
X	$(CC) $(CFLAGS) -c ../win/X11/winmesg.c
Xwinmisc.o: ../win/X11/winmisc.c  ../include/hack.h ../include/func_tab.h ../include/winX.h
X	$(CC) $(CFLAGS) -c ../win/X11/winmisc.c
Xwinstat.o: ../win/X11/winstat.c  ../include/hack.h ../include/winX.h
X	$(CC) $(CFLAGS) -c ../win/X11/winstat.c
Xwintext.o: ../win/X11/wintext.c  ../include/hack.h ../include/winX.h
X	$(CC) $(CFLAGS) -c ../win/X11/wintext.c
Xwinval.o: ../win/X11/winval.c  ../include/config.h
X	$(CC) $(CFLAGS) -c ../win/X11/winval.c
Xallmain.o:  ../include/hack.h
Xalloc.o:  ../include/config.h
Xapply.o:  ../include/hack.h ../include/edog.h
Xartifact.o:  ../include/hack.h ../include/artifact.h ../include/artilist.h
Xattrib.o:  ../include/hack.h ../include/artifact.h
Xball.o:  ../include/hack.h
Xbones.o:  ../include/hack.h ../include/lev.h
Xbotl.o:  ../include/hack.h
Xcmd.o:  ../include/hack.h ../include/func_tab.h
Xdbridge.o:  ../include/hack.h
Xdecl.o:  ../include/hack.h ../include/quest.h
Xdetect.o:  ../include/hack.h ../include/artifact.h
Xdisplay.o:  ../include/hack.h
Xdo.o:  ../include/hack.h ../include/lev.h
Xdo_name.o:  ../include/hack.h
Xdo_wear.o:  ../include/hack.h
Xdog.o:  ../include/hack.h ../include/edog.h
Xdogmove.o:  ../include/hack.h ../include/mfndpos.h ../include/edog.h
Xdokick.o:  ../include/hack.h ../include/eshk.h
Xdothrow.o:  ../include/hack.h
Xdrawing.o:  ../include/hack.h ../include/termcap.h
Xdungeon.o:  ../include/hack.h ../include/dgn_file.h
Xeat.o:  ../include/hack.h
Xend.o:  ../include/hack.h ../include/eshk.h
Xengrave.o:  ../include/hack.h ../include/lev.h
Xexper.o:  ../include/hack.h
Xexplode.o:  ../include/hack.h
Xextralev.o:  ../include/hack.h
Xfiles.o:  ../include/hack.h
Xfountain.o:  ../include/hack.h
Xhack.o:  ../include/hack.h
Xhacklib.o:  ../include/hack.h
Xinvent.o:  ../include/hack.h ../include/artifact.h
Xlock.o:  ../include/hack.h
Xmail.o:  ../include/hack.h ../include/mail.h
Xmakemon.o:  ../include/hack.h ../include/epri.h ../include/emin.h
Xmcastu.o:  ../include/hack.h
Xmhitm.o:  ../include/hack.h ../include/artifact.h ../include/edog.h
Xmhitu.o:  ../include/hack.h ../include/artifact.h ../include/edog.h
Xminion.o:  ../include/hack.h ../include/emin.h ../include/epri.h
Xmklev.o:  ../include/hack.h
Xmkmap.o:  ../include/hack.h ../include/sp_lev.h
Xmkmaze.o:  ../include/hack.h ../include/sp_lev.h
Xmkobj.o:  ../include/hack.h ../include/artifact.h ../include/prop.h
Xmkroom.o:  ../include/hack.h
Xmon.o:  ../include/hack.h ../include/mfndpos.h ../include/edog.h
Xmondata.o:  ../include/hack.h ../include/eshk.h ../include/epri.h
Xmonmove.o:  ../include/hack.h ../include/mfndpos.h ../include/artifact.h
Xmonst.o:  ../include/config.h ../include/permonst.h ../include/monsym.h ../include/eshk.h \
X		../include/vault.h ../include/epri.h ../include/color.h
Xmplayer.o:  ../include/hack.h
Xmthrowu.o:  ../include/hack.h
Xmuse.o:  ../include/hack.h
Xmusic.o:  ../include/hack.h
Xo_init.o:  ../include/hack.h
Xobjects.o:  ../include/config.h ../include/obj.h ../include/objclass.h ../include/prop.h ../include/color.h objects.c
Xobjnam.o:  ../include/hack.h
Xoptions.o:  ../include/hack.h ../include/termcap.h
Xpager.o:  ../include/hack.h
Xpickup.o:  ../include/hack.h
Xpline.o:  ../include/hack.h ../include/epri.h
Xpolyself.o:  ../include/hack.h
Xpotion.o:  ../include/hack.h
Xpray.o:  ../include/hack.h ../include/epri.h
Xpriest.o:  ../include/hack.h ../include/mfndpos.h ../include/eshk.h ../include/epri.h ../include/emin.h
Xquest.o:  ../include/hack.h ../include/quest.h ../include/qtext.h
Xquestpgr.o:  ../include/hack.h ../include/qtext.h
Xread.o:  ../include/hack.h
Xrect.o:  ../include/hack.h
Xrestore.o:  ../include/hack.h ../include/lev.h ../include/termcap.h ../include/quest.h
Xrip.o:  ../include/hack.h
Xrnd.o:  ../include/hack.h
Xrumors.o:  ../include/hack.h
Xsave.o:  ../include/hack.h ../include/lev.h ../include/quest.h
Xshk.o:  ../include/hack.h ../include/eshk.h
Xshknam.o:  ../include/hack.h ../include/eshk.h
Xsit.o:  ../include/hack.h ../include/artifact.h
Xsounds.o:  ../include/hack.h ../include/edog.h ../include/eshk.h
Xsp_lev.o:  ../include/hack.h ../include/sp_lev.h ../include/rect.h
Xspell.o:  ../include/hack.h
Xsteal.o:  ../include/hack.h
Xtimeout.o:  ../include/hack.h
Xtopten.o:  ../include/hack.h
Xtrack.o:  ../include/hack.h
Xtrap.o:  ../include/hack.h
Xu_init.o:  ../include/hack.h
Xuhitm.o:  ../include/hack.h
Xvault.o:  ../include/hack.h ../include/vault.h
Xversion.o:  ../include/hack.h ../include/date.h  ../include/patchlevel.h
Xvision.o:  ../include/hack.h ../include/vis_tab.h
Xweapon.o:  ../include/hack.h
Xwere.o:  ../include/hack.h
Xwield.o:  ../include/hack.h
Xwindows.o:  ../include/hack.h ../include/wintty.h
Xwizard.o:  ../include/hack.h ../include/qtext.h
Xworm.o:  ../include/hack.h ../include/lev.h
Xworn.o:  ../include/hack.h
Xwrite.o:  ../include/hack.h
Xzap.o:  ../include/hack.h
X../include/amiconf.h:  ../include/micro.h ../include/pcconf.h
X	touch ../include/amiconf.h
X../include/config.h:  ../include/tradstdc.h ../include/global.h
X	touch ../include/config.h
X../include/decl.h:  ../include/quest.h ../include/spell.h ../include/color.h ../include/obj.h \
X		../include/you.h ../include/onames.h ../include/pm.h
X	touch ../include/decl.h
X../include/display.h:  ../include/vision.h ../include/mondata.h
X	touch ../include/display.h
X../include/dungeon.h:  ../include/align.h
X	touch ../include/dungeon.h
X../include/emin.h:  ../include/dungeon.h
X	touch ../include/emin.h
X../include/epri.h:  ../include/dungeon.h ../include/align.h
X	touch ../include/epri.h
X../include/eshk.h:  ../include/dungeon.h
X	touch ../include/eshk.h
X../include/global.h:  ../include/coord.h ../include/vmsconf.h ../include/unixconf.h \
X		../include/os2conf.h ../include/pcconf.h ../include/tosconf.h \
X		../include/amiconf.h ../include/macconf.h
X	touch ../include/global.h
X../include/hack.h:  ../include/config.h ../include/dungeon.h ../include/monsym.h \
X		../include/mkroom.h ../include/objclass.h ../include/decl.h \
X		../include/trap.h ../include/flag.h ../include/rm.h ../include/vision.h \
X		../include/display.h ../include/wintype.h ../include/engrave.h \
X		../include/rect.h  ../include/winprocs.h ../include/wintty.h ../include/trampoli.h
X	touch ../include/hack.h
X../include/macconf.h:  ../include/system.h
X	touch ../include/macconf.h
X../include/mondata.h:  ../include/align.h
X	touch ../include/mondata.h
X../include/monst.h:  ../include/align.h
X	touch ../include/monst.h
X../include/os2conf.h:  ../include/pcconf.h
X	touch ../include/os2conf.h
X../include/pcconf.h:  ../include/micro.h ../include/system.h
X	touch ../include/pcconf.h
X../include/permonst.h:  ../include/monattk.h ../include/monflag.h ../include/align.h
X	touch ../include/permonst.h
X../include/rm.h:  ../include/align.h
X	touch ../include/rm.h
X../include/sp_lev.h:  ../include/align.h
X	touch ../include/sp_lev.h
X../include/tosconf.h:  ../include/micro.h ../include/pcconf.h
X	touch ../include/tosconf.h
X../include/unixconf.h:  ../include/system.h
X	touch ../include/unixconf.h
X../include/vault.h:  ../include/dungeon.h
X	touch ../include/vault.h
X../include/vmsconf.h:  ../include/system.h
X	touch ../include/vmsconf.h
X../include/you.h:  ../include/align.h ../include/attrib.h ../include/monst.h ../include/youprop.h
X	touch ../include/you.h
X../include/youprop.h:  ../include/prop.h ../include/permonst.h ../include/mondata.h ../include/pm.h
X	touch ../include/youprop.h
X# DEPENDENCIES MUST END AT END OF FILE
X# IF YOU PUT STUFF HERE IT WILL GO AWAY
X# see make depend above
END_OF_FILE
if test 23795 -ne `wc -c <'sys/unix/Makefile.src'`; then
    echo shar: \"'sys/unix/Makefile.src'\" unpacked with wrong size!
fi
# end of 'sys/unix/Makefile.src'
fi
echo shar: End of archive 70 \(of 108\).
cp /dev/null ark70isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \
21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \
41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 \
61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 \
81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 \
101 102 103 104 105 106 107 108 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 108 archives.
    echo "Now execute 'rebuild.sh'"
    rm -f ark10[0-8]isdone ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
