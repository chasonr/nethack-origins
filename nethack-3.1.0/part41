Path: uunet!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v16i049:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Part41/108
Message-ID: <4343@master.CNA.TEK.COM>
Date: 30 Jan 93 01:12:57 GMT
Sender: news@master.CNA.TEK.COM
Lines: 2314
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1598

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 16, Issue 49
Archive-name: nethack31/Part41
Supersedes: nethack3p9: Volume 10, Issue 46-102
Environment: Amiga, Atari, Mac, MS-DOS, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 41 (of 108)."
# Contents:  src/do_wear.c src/spell.c
# Wrapped by billr@saab on Fri Jan 29 17:06:47 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'src/do_wear.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/do_wear.c'\"
else
echo shar: Extracting \"'src/do_wear.c'\" \(37991 characters\)
sed "s/^X//" >'src/do_wear.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)do_wear.c	3.1	92/12/13	*/
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include "hack.h"
X
X#ifdef OVLB
X
Xstatic int NEARDATA todelay;
X
X#endif /*OVLB */
X
X#ifndef OVLB
X
XSTATIC_DCL long takeoff_mask, taking_off;
X
X#else /* OVLB */
X
XSTATIC_OVL long NEARDATA takeoff_mask = 0L, NEARDATA taking_off = 0L;
X
Xstatic const long NEARDATA takeoff_order[] = { WORN_BLINDF, 1L, /* weapon */
X	WORN_SHIELD, WORN_GLOVES, LEFT_RING, RIGHT_RING, WORN_CLOAK,
X	WORN_HELMET, WORN_AMUL, WORN_ARMOR,
X#ifdef TOURIST
X	WORN_SHIRT,
X#endif
X	WORN_BOOTS, 0L };
X
Xstatic void FDECL(on_msg, (struct obj *));
XSTATIC_PTR int NDECL(Armor_on);
XSTATIC_PTR int NDECL(Boots_on);
Xstatic int NDECL(Cloak_on);
XSTATIC_PTR int NDECL(Helmet_on);
XSTATIC_PTR int NDECL(Gloves_on);
Xstatic void NDECL(Amulet_on);
Xstatic void FDECL(Ring_off_or_gone, (struct obj *, BOOLEAN_P));
XSTATIC_PTR int FDECL(select_off, (struct obj *));
Xstatic struct obj *NDECL(do_takeoff);
XSTATIC_PTR int NDECL(take_off);
Xstatic void FDECL(already_wearing, (const char*));
X
Xvoid
Xoff_msg(otmp) register struct obj *otmp; {
X	if(flags.verbose)
X	    You("were wearing %s.", doname(otmp));
X}
X
X/* for items that involve no delay */
Xstatic void
Xon_msg(otmp)
Xregister struct obj *otmp;
X{
X	if(flags.verbose)
X	    You("are now wearing %s.",
X		obj_is_pname(otmp) ? the(xname(otmp)) : an(xname(otmp)));
X}
X
X#endif /* OVLB */
X#ifdef OVL2
X
Xboolean
Xis_boots(otmp) register struct obj *otmp; {
X	return(otmp->otyp >= LOW_BOOTS &&
X		otmp->otyp <= LEVITATION_BOOTS);
X}
X
Xboolean
Xis_helmet(otmp) register struct obj *otmp; {
X	return(otmp->otyp >= ELVEN_LEATHER_HELM &&
X		otmp->otyp <= HELM_OF_TELEPATHY);
X}
X
X#endif /* OVLB */
X#ifdef OVL2
X
Xboolean
Xis_gloves(otmp) register struct obj *otmp; {
X	return(otmp->otyp >= LEATHER_GLOVES &&
X		otmp->otyp <= GAUNTLETS_OF_DEXTERITY);
X}
X
X#endif /* OVL2 */
X#ifdef OVLB
X
Xboolean
Xis_cloak(otmp) register struct obj *otmp; {
X	return(otmp->otyp >= MUMMY_WRAPPING &&
X		otmp->otyp <= CLOAK_OF_DISPLACEMENT);
X}
X
Xboolean
Xis_shield(otmp) register struct obj *otmp; {
X	return(otmp->otyp >= SMALL_SHIELD &&
X		otmp->otyp <= SHIELD_OF_REFLECTION);
X}
X
X/*
X * The Type_on() functions should be called *after* setworn().
X * The Type_off() functions call setworn() themselves.
X */
X
XSTATIC_PTR
Xint
XBoots_on() {
X    long oldprop = u.uprops[objects[uarmf->otyp].oc_oprop].p_flgs & ~WORN_BOOTS;
X
X    switch(uarmf->otyp) {
X	case LOW_BOOTS:
X	case IRON_SHOES:
X	case HIGH_BOOTS:
X	case JUMPING_BOOTS:
X		break;
X	case WATER_WALKING_BOOTS:
X		if (u.uinwater) spoteffects();
X		break;
X	case SPEED_BOOTS:
X		/* Speed boots are still better than intrinsic speed, */
X		/* though not better than potion speed */
X		if (!(oldprop & TIMEOUT)) {
X			makeknown(uarmf->otyp);
X			You("feel yourself speed up%s.",
X				oldprop ? " a bit more" : "");
X		}
X		break;
X	case ELVEN_BOOTS:
X		if (!oldprop) {
X			makeknown(uarmf->otyp);
X			You("walk very quietly.");
X		}
X		break;
X	case FUMBLE_BOOTS:
X		if (!(oldprop & ~TIMEOUT))
X			Fumbling += rnd(20);
X		break;
X	case LEVITATION_BOOTS:
X		if (!oldprop) {
X			makeknown(uarmf->otyp);
X			float_up();
X		}
X		break;
X	default: impossible("Unknown type of boots (%d)", uarmf->otyp);
X    }
X    return 0;
X}
X
Xint
XBoots_off() {
X    register struct obj *obj = uarmf;
X	/* For levitation, float_down() returns if Levitation, so we
X	 * must do a setworn() _before_ the levitation case.
X	 */
X    long oldprop = u.uprops[objects[uarmf->otyp].oc_oprop].p_flgs & ~WORN_BOOTS;
X
X    setworn((struct obj *)0, W_ARMF);
X    switch(obj->otyp) {
X	case SPEED_BOOTS:
X		if (!(oldprop & TIMEOUT)) {
X			makeknown(obj->otyp);
X			You("feel yourself slow down%s.",
X				oldprop ? " a bit" : "");
X		}
X		break;
X	case WATER_WALKING_BOOTS:
X		if(is_pool(u.ux,u.uy) && !Levitation
X#ifdef POLYSELF
X		    && !is_flyer(uasmon) && !is_clinger(uasmon)
X#endif
X		    ) {
X			makeknown(obj->otyp);
X			/* make boots known in case you survive the drowning */
X			spoteffects();
X		}
X		break;
X	case ELVEN_BOOTS:
X		if (!oldprop) {
X			makeknown(obj->otyp);
X			You("sure are noisy.");
X		}
X		break;
X	case FUMBLE_BOOTS:
X		if (!(oldprop & ~TIMEOUT))
X			Fumbling = 0;
X		break;
X	case LEVITATION_BOOTS:
X		if (!oldprop) {
X			(void) float_down();
X			makeknown(obj->otyp);
X		}
X		break;
X	case LOW_BOOTS:
X	case IRON_SHOES:
X	case HIGH_BOOTS:
X	case JUMPING_BOOTS:
X		break;
X	default: impossible("Unknown type of boots (%d)", obj->otyp);
X    }
X    return 0;
X}
X
Xstatic int
XCloak_on() {
X    long oldprop = u.uprops[objects[uarmc->otyp].oc_oprop].p_flgs & ~WORN_CLOAK;
X
X    switch(uarmc->otyp) {
X	case ELVEN_CLOAK:
X	case CLOAK_OF_PROTECTION:
X	case CLOAK_OF_DISPLACEMENT:
X		makeknown(uarmc->otyp);
X		break;
X	case MUMMY_WRAPPING:
X	case ORCISH_CLOAK:
X	case DWARVISH_CLOAK:
X	case CLOAK_OF_MAGIC_RESISTANCE:
X		break;
X	case CLOAK_OF_INVISIBILITY:
X		if (!oldprop && !See_invisible && !Blind) {
X			makeknown(uarmc->otyp);
X			newsym(u.ux,u.uy);
X			pline("Suddenly you cannot see yourself.");
X		}
X		break;
X	case OILSKIN_CLOAK:
X		pline("The %s fits very tightly.",xname(uarmc));
X		break;
X	default: impossible("Unknown type of cloak (%d)", uarmc->otyp);
X    }
X    return 0;
X}
X
Xint
XCloak_off() {
X    long oldprop = u.uprops[objects[uarmc->otyp].oc_oprop].p_flgs & ~WORN_CLOAK;
X
X    switch(uarmc->otyp) {
X	case MUMMY_WRAPPING:
X	case ELVEN_CLOAK:
X	case ORCISH_CLOAK:
X	case DWARVISH_CLOAK:
X	case CLOAK_OF_PROTECTION:
X	case CLOAK_OF_MAGIC_RESISTANCE:
X	case CLOAK_OF_DISPLACEMENT:
X	case OILSKIN_CLOAK:
X		break;
X	case CLOAK_OF_INVISIBILITY:
X		if (!oldprop && !See_invisible && !Blind) {
X			makeknown(uarmc->otyp);
X			setworn((struct obj *)0, W_ARMC);
X			newsym(u.ux,u.uy);
X			pline("Suddenly you can see yourself.");
X			return 0;
X		}
X		break;
X	default: impossible("Unknown type of cloak (%d)", uarmc->otyp);
X    }
X    setworn((struct obj *)0, W_ARMC);
X    return 0;
X}
X
XSTATIC_PTR
Xint
XHelmet_on()
X{
X    switch(uarmh->otyp) {
X	case FEDORA:
X	case HELMET:
X	case DENTED_POT:
X	case ELVEN_LEATHER_HELM:
X	case DWARVISH_IRON_HELM:
X	case ORCISH_HELM:
X	case HELM_OF_TELEPATHY:
X		break;
X	case HELM_OF_BRILLIANCE:
X		if (uarmh->spe) {
X			ABON(A_INT) += uarmh->spe;
X			ABON(A_WIS) += uarmh->spe;
X			flags.botl = 1;
X			makeknown(uarmh->otyp);
X		}
X		break;
X	case HELM_OF_OPPOSITE_ALIGNMENT:
X		if (u.ualign.type == A_NEUTRAL)
X		    u.ualign.type = rn2(2) ? A_CHAOTIC : A_LAWFUL;
X		else u.ualign.type = -(u.ualign.type);
X		makeknown(uarmh->otyp);
X		flags.botl = 1;
X		break;
X	default: impossible("Unknown type of helm (%d)", uarmh->otyp);
X    }
X    return 0;
X}
X
Xint
XHelmet_off()
X{
X    switch(uarmh->otyp) {
X	case FEDORA:
X	case HELMET:
X	case DENTED_POT:
X	case ELVEN_LEATHER_HELM:
X	case DWARVISH_IRON_HELM:
X	case ORCISH_HELM:
X		break;
X	case HELM_OF_TELEPATHY:
X		/* need to update ability before calling see_monsters() */
X		setworn((struct obj *)0, W_ARMH);
X		see_monsters();
X		return 0;
X	case HELM_OF_BRILLIANCE:
X		if (uarmh->spe) {
X			ABON(A_INT) -= uarmh->spe;
X			ABON(A_WIS) -= uarmh->spe;
X			flags.botl = 1;
X		}
X		break;
X	case HELM_OF_OPPOSITE_ALIGNMENT:
X		u.ualign.type = u.ualignbase[0];
X		flags.botl = 1;
X		break;
X	default: impossible("Unknown type of helm (%d)", uarmh->otyp);
X    }
X    setworn((struct obj *)0, W_ARMH);
X    return 0;
X}
X
XSTATIC_PTR
Xint
XGloves_on() {
X    long oldprop =
X	u.uprops[objects[uarmg->otyp].oc_oprop].p_flgs & ~(WORN_GLOVES | TIMEOUT);
X
X    switch(uarmg->otyp) {
X	case LEATHER_GLOVES:
X		break;
X	case GAUNTLETS_OF_FUMBLING:
X		if (!oldprop)
X			Fumbling += rnd(20);
X		break;
X	case GAUNTLETS_OF_POWER:
X		makeknown(uarmg->otyp);
X		flags.botl = 1; /* taken care of in attrib.c */
X		break;
X	case GAUNTLETS_OF_DEXTERITY:
X		if (uarmg->spe) makeknown(uarmg->otyp);
X		ABON(A_DEX) += uarmg->spe;
X		flags.botl = 1;
X		break;
X	default: impossible("Unknown type of gloves (%d)", uarmg->otyp);
X    }
X    return 0;
X}
X
Xint
XGloves_off() {
X    long oldprop =
X	u.uprops[objects[uarmg->otyp].oc_oprop].p_flgs & ~(WORN_GLOVES | TIMEOUT);
X
X    switch(uarmg->otyp) {
X	case LEATHER_GLOVES:
X		break;
X	case GAUNTLETS_OF_FUMBLING:
X		if (!oldprop)
X			Fumbling = 0;
X		break;
X	case GAUNTLETS_OF_POWER:
X		makeknown(uarmg->otyp);
X		flags.botl = 1; /* taken care of in attrib.c */
X		break;
X	case GAUNTLETS_OF_DEXTERITY:
X		if (uarmg->spe) makeknown(uarmg->otyp);
X		ABON(A_DEX) -= uarmg->spe;
X		flags.botl = 1;
X		break;
X	default: impossible("Unknown type of gloves (%d)", uarmg->otyp);
X    }
X    setworn((struct obj *)0, W_ARMG);
X    if (uwep && uwep->otyp == CORPSE && uwep->corpsenm == PM_COCKATRICE
X#ifdef POLYSELF
X	    && !(poly_when_stoned(uasmon) && polymon(PM_STONE_GOLEM))
X#endif
X							) {
X	/* Prevent wielding cockatrice when not wearing gloves */
X	You("wield the cockatrice corpse in your bare %s.",
X	    makeplural(body_part(HAND)));
X	You("turn to stone...");
X	killer_format = KILLED_BY_AN;
X	killer = "cockatrice corpse";
X	done(STONING);
X    }
X    return 0;
X}
X
X/*
Xstatic int
XShield_on() {
X    switch(uarms->otyp) {
X	case SMALL_SHIELD:
X	case ELVEN_SHIELD:
X	case URUK_HAI_SHIELD:
X	case ORCISH_SHIELD:
X	case DWARVISH_ROUNDSHIELD:
X	case LARGE_SHIELD:
X	case SHIELD_OF_REFLECTION:
X		break;
X	default: impossible("Unknown type of shield (%d)", uarms->otyp);
X    }
X    return 0;
X}
X*/
X
Xint
XShield_off() {
X/*
X    switch(uarms->otyp) {
X	case SMALL_SHIELD:
X	case ELVEN_SHIELD:
X	case URUK_HAI_SHIELD:
X	case ORCISH_SHIELD:
X	case DWARVISH_ROUNDSHIELD:
X	case LARGE_SHIELD:
X	case SHIELD_OF_REFLECTION:
X		break;
X	default: impossible("Unknown type of shield (%d)", uarms->otyp);
X    }
X*/
X    setworn((struct obj *)0, W_ARMS);
X    return 0;
X}
X
X/* This must be done in worn.c, because one of the possible intrinsics conferred
X * is fire resistance, and we have to immediately set HFire_resistance in worn.c
X * since worn.c will check it before returning.
X */
XSTATIC_PTR
Xint
XArmor_on()
X{
X    return 0;
X}
X
Xint
XArmor_off()
X{
X    setworn((struct obj *)0, W_ARM);
X    return 0;
X}
X
X/* The gone functions differ from the off functions in that if you die from
X * taking it off and have life saving, you still die.
X */
Xint
XArmor_gone()
X{
X    setnotworn(uarm);
X    return 0;
X}
X
Xstatic void
XAmulet_on()
X{
X    switch(uamul->otyp) {
X	case AMULET_OF_ESP:
X	case AMULET_OF_LIFE_SAVING:
X	case AMULET_VERSUS_POISON:
X	case AMULET_OF_REFLECTION:
X	case AMULET_OF_MAGICAL_BREATHING:
X	case FAKE_AMULET_OF_YENDOR:
X		break;
X	case AMULET_OF_CHANGE:
X		makeknown(AMULET_OF_CHANGE);
X		change_sex();
X		/* Don't use same message as polymorph */
X		You("are suddenly very %s!", flags.female ? "feminine"
X			: "masculine");
X		flags.botl = 1;
X		pline("The amulet disintegrates!");
X		useup(uamul);
X		break;
X	case AMULET_OF_STRANGULATION:
X		makeknown(AMULET_OF_STRANGULATION);
X		pline("It constricts your throat!");
X		Strangled = 6;
X		break;
X	case AMULET_OF_RESTFUL_SLEEP:
X		Sleeping = rnd(100);
X		break;
X	case AMULET_OF_YENDOR:
X		break;
X    }
X}
X
Xvoid
XAmulet_off()
X{
X    switch(uamul->otyp) {
X	case AMULET_OF_ESP:
X		/* need to update ability before calling see_monsters() */
X		setworn((struct obj *)0, W_AMUL);
X		see_monsters();
X		return;
X	case AMULET_OF_LIFE_SAVING:
X	case AMULET_VERSUS_POISON:
X	case AMULET_OF_REFLECTION:
X	case FAKE_AMULET_OF_YENDOR:
X		break;
X	case AMULET_OF_MAGICAL_BREATHING:
X		if (Underwater) {
X			You("suddenly inhale an unhealthy amount of water!");
X			/* Magical_breathing has to be set
X			   off before calling drown() */
X			setworn((struct obj *)0, W_AMUL);
X			(void) drown();
X			return;
X		}
X		break;
X	case AMULET_OF_CHANGE:
X		impossible("Wearing an amulet of change?");
X		break;
X	case AMULET_OF_STRANGULATION:
X		if (Strangled) {
X			You("can breathe more easily!");
X			Strangled = 0;
X		}
X		break;
X	case AMULET_OF_RESTFUL_SLEEP:
X		Sleeping = 0;
X		break;
X	case AMULET_OF_YENDOR:
X		break;
X    }
X    setworn((struct obj *)0, W_AMUL);
X}
X
Xvoid
XRing_on(obj)
Xregister struct obj *obj;
X{
X    long oldprop = u.uprops[objects[obj->otyp].oc_oprop].p_flgs & ~W_RING;
X
X    /* might put on two rings of the same type */
X    if((u.uprops[objects[obj->otyp].oc_oprop].p_flgs & W_RING) == W_RING)
X	oldprop = 1;
X
X    switch(obj->otyp){
X	case RIN_TELEPORTATION:
X	case RIN_REGENERATION:
X	case RIN_SEARCHING:
X	case RIN_STEALTH:
X	case RIN_HUNGER:
X	case RIN_AGGRAVATE_MONSTER:
X	case RIN_POISON_RESISTANCE:
X	case RIN_FIRE_RESISTANCE:
X	case RIN_COLD_RESISTANCE:
X	case RIN_SHOCK_RESISTANCE:
X	case RIN_CONFLICT:
X	case RIN_WARNING:
X	case RIN_TELEPORT_CONTROL:
X#ifdef POLYSELF
X	case RIN_POLYMORPH:
X	case RIN_POLYMORPH_CONTROL:
X#endif
X		break;
X	case RIN_SEE_INVISIBLE:
X		/* can now see invisible monsters */
X		set_mimic_blocking(); /* do special mimic handling */
X		see_monsters();
X
X		if (Invis && !oldprop
X#ifdef POLYSELF
X				&& !perceives(uasmon)
X#endif
X							&& !Blind) {
X			newsym(u.ux,u.uy);
X			pline("Suddenly you can see yourself.");
X			makeknown(RIN_SEE_INVISIBLE);
X		}
X		break;
X	case RIN_INVISIBILITY:
X		if (!oldprop && !See_invisible && !Blind) {
X			makeknown(RIN_INVISIBILITY);
X			newsym(u.ux,u.uy);
X			Your("body takes on a %s transparency...",
X				Hallucination ? "normal" : "strange");
X		}
X		break;
X	case RIN_ADORNMENT:
X		ABON(A_CHA) += obj->spe;
X		flags.botl = 1;
X		if (obj->spe || objects[RIN_ADORNMENT].oc_name_known) {
X			makeknown(RIN_ADORNMENT);
X			obj->known = TRUE;
X		}
X		break;
X	case RIN_LEVITATION:
X		if(!oldprop) {
X			float_up();
X			makeknown(RIN_LEVITATION);
X			obj->known = TRUE;
X		}
X		break;
X	case RIN_GAIN_STRENGTH:
X		ABON(A_STR) += obj->spe;
X		flags.botl = 1;
X		if (obj->spe || objects[RIN_GAIN_STRENGTH].oc_name_known) {
X			makeknown(RIN_GAIN_STRENGTH);
X			obj->known = TRUE;
X		}
X		break;
X	case RIN_INCREASE_DAMAGE:
X		u.udaminc += obj->spe;
X		break;
X	case RIN_PROTECTION_FROM_SHAPE_CHAN:
X		rescham();
X		break;
X	case RIN_PROTECTION:
X		flags.botl = 1;
X		if (obj->spe || objects[RIN_PROTECTION].oc_name_known) {
X			makeknown(RIN_PROTECTION);
X			obj->known = TRUE;
X		}
X		break;
X    }
X}
X
Xstatic void
XRing_off_or_gone(obj,gone)
Xregister struct obj *obj;
Xboolean gone;
X{
X    register long mask = obj->owornmask & W_RING;
X
X    if(!(u.uprops[objects[obj->otyp].oc_oprop].p_flgs & mask))
X	impossible("Strange... I didn't know you had that ring.");
X    if(gone) setnotworn(obj);
X    else setworn((struct obj *)0, obj->owornmask);
X    switch(obj->otyp) {
X	case RIN_TELEPORTATION:
X	case RIN_REGENERATION:
X	case RIN_SEARCHING:
X	case RIN_STEALTH:
X	case RIN_HUNGER:
X	case RIN_AGGRAVATE_MONSTER:
X	case RIN_POISON_RESISTANCE:
X	case RIN_FIRE_RESISTANCE:
X	case RIN_COLD_RESISTANCE:
X	case RIN_SHOCK_RESISTANCE:
X	case RIN_CONFLICT:
X	case RIN_WARNING:
X	case RIN_TELEPORT_CONTROL:
X#ifdef POLYSELF
X	case RIN_POLYMORPH:
X	case RIN_POLYMORPH_CONTROL:
X#endif
X		break;
X	case RIN_SEE_INVISIBLE:
X		/* Make invisible monsters go away */
X		if (!See_invisible) {
X		    set_mimic_blocking(); /* do special mimic handling */
X		    see_monsters();
X		}
X
X		if (Invisible && !Blind) {
X			newsym(u.ux,u.uy);
X			pline("Suddenly you cannot see yourself.");
X			makeknown(RIN_SEE_INVISIBLE);
X		}
X		break;
X	case RIN_INVISIBILITY:
X		if (!(Invisible & ~W_RING) && !See_invisible && !Blind) {
X			newsym(u.ux,u.uy);
X			Your("body seems to unfade...");
X			makeknown(RIN_INVISIBILITY);
X		}
X		break;
X	case RIN_ADORNMENT:
X		ABON(A_CHA) -= obj->spe;
X		flags.botl = 1;
X		break;
X	case RIN_LEVITATION:
X		(void) float_down();
X		if (!Levitation) makeknown(RIN_LEVITATION);
X		break;
X	case RIN_GAIN_STRENGTH:
X		ABON(A_STR) -= obj->spe;
X		flags.botl = 1;
X		break;
X	case RIN_INCREASE_DAMAGE:
X		u.udaminc -= obj->spe;
X		break;
X	case RIN_PROTECTION_FROM_SHAPE_CHAN:
X		/* If you're no longer protected, let the chameleons
X		 * change shape again -dgk
X		 */
X		restartcham();
X		break;
X    }
X}
X
Xvoid
XRing_off(obj)
Xstruct obj *obj;
X{
X	Ring_off_or_gone(obj,FALSE);
X}
X
Xvoid
XRing_gone(obj)
Xstruct obj *obj;
X{
X	Ring_off_or_gone(obj,TRUE);
X}
X
Xvoid
XBlindf_on(otmp)
Xregister struct obj *otmp;
X{
X	long already_blinded = Blinded;
X	setworn(otmp, W_TOOL);
X	if (otmp->otyp == TOWEL && flags.verbose)
X	    You("wrap %s around your %s.", an(xname(otmp)), body_part(HEAD));
X	on_msg(otmp);
X	if (!already_blinded) {
X	    if (Punished) set_bc(0);	/* Set ball&chain variables before */
X					/* the hero goes blind.		   */
X	    if (Telepat) see_monsters();/* sense monsters */
X	    vision_full_recalc = 1;	/* recalc vision limits */
X	    flags.botl = 1;
X	}
X}
X
Xvoid
XBlindf_off(otmp)
Xregister struct obj *otmp;
X{
X	setworn((struct obj *)0, otmp->owornmask);
X	off_msg(otmp);
X	if (!Blinded) {
X	    if (Telepat) see_monsters();/* no longer sense monsters */
X	    vision_full_recalc = 1;	/* recalc vision limits */
X	    flags.botl = 1;
X	} else
X	    You("still cannot see.");
X}
X
X/* called in main to set intrinsics of worn start-up items */
Xvoid
Xset_wear() {
X	if (uarm)  (void) Armor_on();
X	if (uarmc) (void) Cloak_on();
X	if (uarmf) (void) Boots_on();
X	if (uarmg) (void) Gloves_on();
X	if (uarmh) (void) Helmet_on();
X/*	if (uarms) (void) Shield_on(); */
X}
X
Xboolean
Xdonning(otmp)
Xregister struct obj *otmp;
X{
X    return (otmp == uarmf && (afternmv == Boots_on || afternmv == Boots_off))
X	|| (otmp == uarmh && (afternmv == Helmet_on || afternmv == Helmet_off))
X	|| (otmp == uarmg && (afternmv == Gloves_on || afternmv == Gloves_off))
X	|| (otmp == uarm && (afternmv == Armor_on || afternmv == Armor_off));
X}
X
Xvoid
Xcancel_don()
X{
X	/* the piece of armor we were donning/doffing has vanished, so stop
X	 * wasting time on it (and don't dereference it when donning would
X	 * otherwise finish)
X	 */
X	afternmv = 0;
X	nomovemsg = NULL;
X	multi = 0;
X}
X
Xstatic const char NEARDATA clothes[] = {ARMOR_CLASS, 0};
Xstatic const char NEARDATA accessories[] = {RING_CLASS, AMULET_CLASS, TOOL_CLASS, 0};
X
Xint
Xdotakeoff()
X{
X	register struct obj *otmp = (struct obj *)0;
X	int armorpieces = 0;
X
X#define MOREARM(x) if (x) { armorpieces++; otmp = x; }
X	MOREARM(uarmh);
X	MOREARM(uarms);
X	MOREARM(uarmg);
X	MOREARM(uarmf);
X	if (uarmc) {
X		armorpieces++;
X		otmp = uarmc;
X	} else if (uarm) {
X		armorpieces++;
X		otmp = uarm;
X#ifdef TOURIST
X	} else if (uarmu) {
X		armorpieces++;
X		otmp = uarmu;
X#endif
X	}
X	if (!armorpieces) {
X#ifdef POLYSELF
X		if (uskin)
X		    pline("The dragon scale mail is merged with your skin!");
X		else
X#endif
X		    pline("Not wearing any armor.");
X		return 0;
X	}
X	if (armorpieces > 1)
X		otmp = getobj(clothes, "take off");
X	if (otmp == 0) return(0);
X	if (!(otmp->owornmask & W_ARMOR)) {
X		You("are not wearing that.");
X		return(0);
X	}
X	if (((otmp == uarm) && (uarmc))
X#ifdef TOURIST
X				|| ((otmp == uarmu) && (uarmc || uarm))
X#endif
X								) {
X		You("can't take that off.");
X		return(0);
X	}
X	if(otmp == uarmg && welded(uwep)) {
X    You("seem unable to take off the gloves while holding your %s.",
X	  is_sword(uwep) ? "sword" : "weapon");
X		uwep->bknown = TRUE;
X		return(0);
X	}
X	if(otmp == uarmg && Glib) {
X    You("can't remove the slippery gloves with your slippery fingers.");
X		return(0);
X	}
X	if(otmp == uarmf && u.utrap && (u.utraptype == TT_BEARTRAP ||
X					u.utraptype == TT_INFLOOR)) { /* -3. */
X	    if(u.utraptype == TT_BEARTRAP)
X		pline("The bear trap prevents you from pulling your %s out.",
X		      body_part(FOOT));
X	    else
X		You("are stuck in the floor, and cannot pull your %s out.",
X		     makeplural(body_part(FOOT)));
X		return(0);
X	}
X	reset_remarm();			/* since you may change ordering */
X	(void) armoroff(otmp);
X	return(1);
X}
X
Xint
Xdoremring() {
X#ifdef GCC_WARN
X	register struct obj *otmp = (struct obj *)0;
X		/* suppress "may be used uninitialized" warning */
X#else
X	register struct obj *otmp;
X#endif
X	int Accessories = 0;
X
X#define MOREACC(x) if (x) { Accessories++; otmp = x; }
X	MOREACC(uleft);
X	MOREACC(uright);
X	MOREACC(uamul);
X	MOREACC(ublindf);
X
X	if(!Accessories) {
X		pline("Not wearing any accessories.");
X		return(0);
X	}
X	if (Accessories != 1) otmp = getobj(accessories, "take off");
X	if(!otmp) return(0);
X	if(!(otmp->owornmask & (W_RING | W_AMUL | W_TOOL))) {
X		You("are not wearing that.");
X		return(0);
X	}
X	if(cursed(otmp)) return(0);
X	if(otmp->oclass == RING_CLASS) {
X#ifdef POLYSELF
X		if (nolimbs(uasmon)) {
X			pline("It seems to be stuck.");
X			return(0);
X		}
X#endif
X		if (uarmg && uarmg->cursed) {
X			uarmg->bknown = TRUE;
XYou("seem unable to remove your ring without taking off your gloves.");
X			return(0);
X		}
X		if (welded(uwep) && bimanual(uwep)) {
X			uwep->bknown = TRUE;
XYou("seem unable to remove the ring while your hands hold your %s.",
X				is_sword(uwep) ? "sword" : "weapon");
X			return(0);
X		}
X		if (welded(uwep) && otmp==uright) {
X			uwep->bknown = TRUE;
XYou("seem unable to remove the ring while your right hand holds your %s.",
X				is_sword(uwep) ? "sword" : "weapon");
X			return(0);
X		}
X		/* Sometimes we want to give the off_msg before removing and
X		 * sometimes after; for instance, "you were wearing a moonstone
X		 * ring (on right hand)" is desired but "you were wearing a
X		 * square amulet (being worn)" is not because of the redundant
X		 * "being worn".
X		 */
X		off_msg(otmp);
X		Ring_off(otmp);
X	} else if(otmp->oclass == AMULET_CLASS) {
X		Amulet_off();
X		off_msg(otmp);
X	} else Blindf_off(otmp); /* does its own off_msg */
X	return(1);
X}
X
Xint
Xcursed(otmp) register struct obj *otmp; {
X	/* Curses, like chickens, come home to roost. */
X	if(otmp->cursed){
X		You("can't.  %s to be cursed.",
X			(is_boots(otmp) || is_gloves(otmp) || otmp->quan > 1L)
X			? "They seem" : "It seems");
X		otmp->bknown = TRUE;
X		return(1);
X	}
X	return(0);
X}
X
Xint
Xarmoroff(otmp) register struct obj *otmp; {
X	register int delay = -objects[otmp->otyp].oc_delay;
X
X	if(cursed(otmp)) return(0);
X	if(delay) {
X		nomul(delay);
X		if (is_helmet(otmp)) {
X			nomovemsg = "You finish taking off your helmet.";
X			afternmv = Helmet_off;
X		     }
X		else if (is_gloves(otmp)) {
X			nomovemsg = "You finish taking off your gloves.";
X			afternmv = Gloves_off;
X		     }
X		else if (is_boots(otmp)) {
X			nomovemsg = "You finish taking off your boots.";
X			afternmv = Boots_off;
X		     }
X		else {
X			nomovemsg = "You finish taking off your suit.";
X			afternmv = Armor_off;
X		}
X	} else {
X		/* Be warned!  We want off_msg after removing the item to
X		 * avoid "You were wearing ____ (being worn)."  However, an
X		 * item which grants fire resistance might cause some trouble
X		 * if removed in Hell and lifesaving puts it back on; in this
X		 * case the message will be printed at the wrong time (after
X		 * the messages saying you died and were lifesaved).  Luckily,
X		 * no cloak, shield, or fast-removable armor grants fire
X		 * resistance, so we can safely do the off_msg afterwards.
X		 * Rings do grant fire resistance, but for rings we want the
X		 * off_msg before removal anyway so there's no problem.  Take
X		 * care in adding armors granting fire resistance; this code
X		 * might need modification.
X		 */
X		if(is_cloak(otmp))
X			(void) Cloak_off();
X		else if(is_shield(otmp))
X			(void) Shield_off();
X		else setworn((struct obj *)0, otmp->owornmask & W_ARMOR);
X		off_msg(otmp);
X	}
X	takeoff_mask = taking_off = 0L;
X	return(1);
X}
X
Xstatic void
Xalready_wearing(cc)
Xconst char *cc;
X{
X	You("are already wearing %s", cc);
X}
X
Xint
Xdowear()
X{
X	register struct obj *otmp;
X	register int delay;
X	register int err = 0;
X	long mask = 0;
X
X#ifdef POLYSELF
X	/* cantweararm checks for suits of armor */
X	/* verysmall or nohands checks for shields, gloves, etc... */
X	if ((verysmall(uasmon) || nohands(uasmon))) {
X		pline("Don't even bother.");
X		return(0);
X	}
X#endif
X	otmp = getobj(clothes, "wear");
X	if(!otmp) return(0);
X#ifdef POLYSELF
X	if (cantweararm(uasmon) && !is_shield(otmp) &&
X			!is_helmet(otmp) && !is_gloves(otmp) &&
X			!is_boots(otmp)) {
X		pline("The %s will not fit on your body.",
X			is_cloak(otmp) ? "cloak" :
X# ifdef TOURIST
X			otmp->otyp == HAWAIIAN_SHIRT ? "shirt" :
X# endif
X			"suit");
X		return(0);
X	}
X#endif
X	if(otmp->owornmask & W_ARMOR) {
X		already_wearing("that!");
X		return(0);
X	}
X	if(is_helmet(otmp)) {
X		if(uarmh) {
X			already_wearing("a helmet.");
X			err++;
X		} else
X			mask = W_ARMH;
X	} else if(is_shield(otmp)){
X		if(uarms) {
X			already_wearing("a shield.");
X			err++;
X		}
X		if(uwep && bimanual(uwep)) {
X		    You("cannot wear a shield while wielding a two-handed %s.",
X			is_sword(uwep) ? "sword" :
X				uwep->otyp == BATTLE_AXE ? "axe" : "weapon");
X			err++;
X		}
X		if(!err) mask = W_ARMS;
X	} else if(is_boots(otmp)) {
X		   if(uarmf) {
X			already_wearing("boots.");
X			err++;
X		   } if (u.utrap && (u.utraptype == TT_BEARTRAP ||
X				     u.utraptype == TT_INFLOOR)) {
X		       if (u.utraptype == TT_BEARTRAP)
X			   Your("%s is trapped!", body_part(FOOT));
X		       else
X			   Your("%s are stuck in the floor!",
X				makeplural(body_part(FOOT)));
X		       err++;
X		   } else
X			mask = W_ARMF;
X	} else if(is_gloves(otmp)) {
X		if(uarmg) {
X			already_wearing("gloves.");
X			err++;
X		} else
X		if (welded(uwep)) {
X			You("cannot wear gloves over your %s.",
X			      is_sword(uwep) ? "sword" : "weapon");
X			err++;
X		} else
X			mask = W_ARMG;
X#ifdef TOURIST
X	} else if( otmp->otyp == HAWAIIAN_SHIRT ) {
X		if (uarm || uarmc || uarmu) {
X			if(uarmu)
X			   already_wearing("a shirt.");
X			else
X			   You("can't wear that over your %s.",
X				 (uarm && !uarmc) ? "armor" : "cloak");
X			err++;
X		} else
X			mask = W_ARMU;
X#endif
X	} else if(is_cloak(otmp)) {
X		if(uarmc) {
X			already_wearing("a cloak.");
X			err++;
X		} else
X			mask = W_ARMC;
X	} else {
X		if(uarmc) {
X			You("cannot wear armor over a cloak.");
X			err++;
X		} else if(uarm) {
X			already_wearing("some armor.");
X			err++;
X		}
X		if(!err) mask = W_ARM;
X	}
X/* Unnecessary since now only weapons and special items like pick-axes get
X * welded to your hand, not armor
X	if(welded(otmp)) {
X		if(!err++)
X			weldmsg(otmp, FALSE);
X	}
X */
X	if(err) return(0);
X
X	otmp->known = TRUE;
X	if(otmp == uwep)
X		setuwep((struct obj *)0);
X	setworn(otmp, mask);
X	delay = -objects[otmp->otyp].oc_delay;
X	if(delay){
X		nomul(delay);
X		if(is_boots(otmp)) afternmv = Boots_on;
X		if(is_helmet(otmp)) afternmv = Helmet_on;
X		if(is_gloves(otmp)) afternmv = Gloves_on;
X		if(otmp == uarm) afternmv = Armor_on;
X		nomovemsg = "You finish your dressing maneuver.";
X	} else {
X		if(is_cloak(otmp)) (void) Cloak_on();
X/*		if(is_shield(otmp)) (void) Shield_on(); */
X		on_msg(otmp);
X	}
X	takeoff_mask = taking_off = 0L;
X	return(1);
X}
X
Xint
Xdoputon() {
X	register struct obj *otmp;
X	long mask = 0L;
X
X	if(uleft && uright && uamul && ublindf) {
X#ifdef POLYSELF
X		Your("%s%s are full, and you're already wearing an amulet and a blindfold.",
X			humanoid(uasmon) ? "ring-" : "",
X			makeplural(body_part(FINGER)));
X#else
X		Your("ring-fingers are full, and you're already wearing an amulet and a blindfold.");
X#endif
X		return(0);
X	}
X	otmp = getobj(accessories, "wear");
X	if(!otmp) return(0);
X	if(otmp->owornmask & (W_RING | W_AMUL | W_TOOL)) {
X		already_wearing("that!");
X		return(0);
X	}
X	if(welded(otmp)) {
X		weldmsg(otmp, TRUE);
X		return(0);
X	}
X	if(otmp == uwep)
X		setuwep((struct obj *)0);
X	if(otmp->oclass == RING_CLASS) {
X#ifdef POLYSELF
X		if(nolimbs(uasmon)) {
X			You("cannot make the ring stick to your body.");
X			return(0);
X		}
X#endif
X		if(uleft && uright){
X#ifdef POLYSELF
X			pline("There are no more %s%s to fill.",
X				humanoid(uasmon) ? "ring-" : "",
X				makeplural(body_part(FINGER)));
X#else
X			pline("There are no more ring-fingers to fill.");
X#endif
X			return(0);
X		}
X		if(uleft) mask = RIGHT_RING;
X		else if(uright) mask = LEFT_RING;
X		else do {
X			char qbuf[QBUFSZ];
X			char answer;
X
X#ifdef POLYSELF
X			Sprintf(qbuf, "What %s%s, Right or Left?",
X				humanoid(uasmon) ? "ring-" : "",
X				body_part(FINGER));
X#else
X			Strcpy(qbuf, "What ring-finger, Right or Left?");
X#endif
X			if(!(answer = yn_function(qbuf, "rl", '\0')))
X				return(0);
X			switch(answer){
X			case 'l':
X			case 'L':
X				mask = LEFT_RING;
X				break;
X			case 'r':
X			case 'R':
X				mask = RIGHT_RING;
X				break;
X			}
X		} while(!mask);
X		if (uarmg && uarmg->cursed) {
X			uarmg->bknown = TRUE;
X		    You("cannot remove your gloves to put on the ring.");
X			return(0);
X		}
X		if (welded(uwep) && bimanual(uwep)) {
X			/* welded will set bknown */
X	    You("cannot free your weapon hands to put on the ring.");
X			return(0);
X		}
X		if (welded(uwep) && mask==RIGHT_RING) {
X			/* welded will set bknown */
X	    You("cannot free your weapon hand to put on the ring.");
X			return(0);
X		}
X		setworn(otmp, mask);
X		Ring_on(otmp);
X	} else if (otmp->oclass == AMULET_CLASS) {
X		if(uamul) {
X			already_wearing("an amulet.");
X			return(0);
X		}
X		setworn(otmp, W_AMUL);
X		if (otmp->otyp == AMULET_OF_CHANGE) {
X			Amulet_on();
X			/* Don't do a prinv() since the amulet is now gone */
X			return(1);
X		}
X		Amulet_on();
X	} else {	/* it's a blindfold */
X		if (ublindf) {
X			if (ublindf->otyp == TOWEL)
X				Your("%s is already covered by a towel.",
X					body_part(FACE));
X			else
X				already_wearing("a blindfold.");
X			return(0);
X		}
X		if (otmp->otyp != BLINDFOLD && otmp->otyp != TOWEL) {
X			You("can't wear that!");
X			return(0);
X		}
X		Blindf_on(otmp);
X		return(1);
X	}
X	prinv(NULL, otmp, 0L);
X	return(1);
X}
X
X#endif /* OVLB */
X
X#ifdef OVL0
X
Xvoid
Xfind_ac() {
X	register int uac = 10;
X#ifdef POLYSELF
X	if (u.mtimedone) uac = mons[u.umonnum].ac;
X#endif
X	if(uarm) uac -= ARM_BONUS(uarm);
X	if(uarmc) uac -= ARM_BONUS(uarmc);
X	if(uarmh) uac -= ARM_BONUS(uarmh);
X	if(uarmf) uac -= ARM_BONUS(uarmf);
X	if(uarms) uac -= ARM_BONUS(uarms);
X	if(uarmg) uac -= ARM_BONUS(uarmg);
X#ifdef TOURIST
X	if(uarmu) uac -= ARM_BONUS(uarmu);
X#endif
X	if(uleft && uleft->otyp == RIN_PROTECTION) uac -= uleft->spe;
X	if(uright && uright->otyp == RIN_PROTECTION) uac -= uright->spe;
X	if (Protection & INTRINSIC) uac -= u.ublessed;
X	if(uac != u.uac){
X		u.uac = uac;
X		flags.botl = 1;
X	}
X}
X
X#endif /* OVL0 */
X#ifdef OVLB
X
Xvoid
Xglibr()
X{
X	register struct obj *otmp;
X	int xfl = 0;
X	boolean leftfall, rightfall;
X
X	leftfall = (uleft && !uleft->cursed &&
X		    (!uwep || !welded(uwep) || !bimanual(uwep)));
X	rightfall = (uright && !uright->cursed && (!welded(uwep)));
X	if(!uarmg) if(leftfall || rightfall)
X#ifdef POLYSELF
X				if(!nolimbs(uasmon))
X#endif
X						{
X		/* changed so cursed rings don't fall off, GAN 10/30/86 */
X		Your("%s off your %s.",
X			(leftfall && rightfall) ? "rings slip" : "ring slips",
X			makeplural(body_part(FINGER)));
X		xfl++;
X		if(leftfall) {
X			otmp = uleft;
X			Ring_off(uleft);
X			dropx(otmp);
X		}
X		if(rightfall) {
X			otmp = uright;
X			Ring_off(uright);
X			dropx(otmp);
X		}
X	}
X	otmp = uwep;
X	if (otmp && !welded(otmp)) {
X		/* changed so cursed weapons don't fall, GAN 10/30/86 */
X		Your("%s %sslips from your %s.",
X			is_sword(otmp) ? "sword" :
X				makesingular(oclass_names[otmp->oclass]),
X			xfl ? "also " : "",
X			makeplural(body_part(HAND)));
X		setuwep((struct obj *)0);
X		dropx(otmp);
X	}
X}
X
Xstruct obj *
Xsome_armor(){
Xregister struct obj *otmph = (uarmc ? uarmc : uarm);
X	if(uarmh && (!otmph || !rn2(4))) otmph = uarmh;
X	if(uarmg && (!otmph || !rn2(4))) otmph = uarmg;
X	if(uarmf && (!otmph || !rn2(4))) otmph = uarmf;
X	if(uarms && (!otmph || !rn2(4))) otmph = uarms;
X#ifdef TOURIST
X	if(!uarm && !uarmc && uarmu && (!otmph || !rn2(4))) otmph = uarmu;
X#endif
X	return(otmph);
X}
X
Xvoid
Xerode_armor(acid_dmg)
Xboolean acid_dmg;
X{
Xregister struct obj *otmph = some_armor();
X
X	if (otmph && otmph != uarmf) {
X	    if (otmph->greased) {
X		grease_protect(otmph,NULL,FALSE);
X		return;
X	    }
X	    if (otmph->oerodeproof ||
X		(acid_dmg ? !is_corrodeable(otmph) : !is_rustprone(otmph))) {
X		if (flags.verbose || !(otmph->oerodeproof && otmph->rknown))
X			Your("%s not affected.", aobjnam(otmph, "are"));
X		if (otmph->oerodeproof) otmph->rknown = TRUE;
X		return;
X	    }
X	    if (otmph->oeroded < MAX_ERODE) {
X		Your("%s%s!", aobjnam(otmph, acid_dmg ? "corrode" : "rust"),
X			otmph->oeroded+1 == MAX_ERODE ? " completely" :
X			otmph->oeroded ? " further" : "");
X		otmph->oeroded++;
X		return;
X	    }
X	    if (flags.verbose)
X		Your("%s completely %s.",
X		     aobjnam(otmph, Blind ? "feel" : "look"),
X		     acid_dmg ? "corroded" : "rusty");
X	}
X}
X
XSTATIC_PTR
Xint
Xselect_off(otmp)
Xregister struct obj *otmp;
X{
X	if(!otmp) return(0);
X	if(cursed(otmp)) return(0);
X#ifdef POLYSELF
X	if(otmp->oclass==RING_CLASS && nolimbs(uasmon)) return(0);
X#endif
X	if(welded(uwep) && (otmp==uarmg || otmp==uright || (otmp==uleft
X			&& bimanual(uwep))))
X		return(0);
X	if(uarmg && uarmg->cursed && (otmp==uright || otmp==uleft)) {
X		uarmg->bknown = TRUE;
X		return(0);
X	}
X	if(otmp == uarmf && u.utrap && (u.utraptype == TT_BEARTRAP ||
X					u.utraptype == TT_INFLOOR)) {
X		return (0);
X	}
X	if((otmp==uarm
X#ifdef TOURIST
X			|| otmp==uarmu
X#endif
X					) && uarmc && uarmc->cursed) {
X		uarmc->bknown = TRUE;
X		return(0);
X	}
X#ifdef TOURIST
X	if(otmp==uarmu && uarm && uarm->cursed) {
X		uarm->bknown = TRUE;
X		return(0);
X	}
X#endif
X
X	if(otmp == uarm) takeoff_mask |= WORN_ARMOR;
X	else if(otmp == uarmc) takeoff_mask |= WORN_CLOAK;
X	else if(otmp == uarmf) takeoff_mask |= WORN_BOOTS;
X	else if(otmp == uarmg) takeoff_mask |= WORN_GLOVES;
X	else if(otmp == uarmh) takeoff_mask |= WORN_HELMET;
X	else if(otmp == uarms) takeoff_mask |= WORN_SHIELD;
X#ifdef TOURIST
X	else if(otmp == uarmu) takeoff_mask |= WORN_SHIRT;
X#endif
X	else if(otmp == uleft) takeoff_mask |= LEFT_RING;
X	else if(otmp == uright) takeoff_mask |= RIGHT_RING;
X	else if(otmp == uamul) takeoff_mask |= WORN_AMUL;
X	else if(otmp == ublindf) takeoff_mask |= WORN_BLINDF;
X	else if(otmp == uwep) takeoff_mask |= 1L;	/* WIELDED_WEAPON */
X
X	else impossible("select_off: %s???", doname(otmp));
X
X	return(0);
X}
X
Xstatic struct obj *
Xdo_takeoff() {
X
X	register struct obj *otmp = (struct obj *)0;
X
X	if (taking_off == 1L) { /* weapon */
X	  if(!cursed(uwep)) {
X	    setuwep((struct obj *) 0);
X	    You("are empty %s.", body_part(HANDED));
X	  }
X	} else if (taking_off ==  WORN_ARMOR) {
X	  otmp = uarm;
X	  if(!cursed(otmp)) (void) Armor_off();
X	} else if (taking_off == WORN_CLOAK) {
X	  otmp = uarmc;
X	  if(!cursed(otmp)) (void) Cloak_off();
X	} else if (taking_off == WORN_BOOTS) {
X	  otmp = uarmf;
X	  if(!cursed(otmp)) (void) Boots_off();
X	} else if (taking_off == WORN_GLOVES) {
X	  otmp = uarmg;
X	  if(!cursed(otmp)) (void) Gloves_off();
X	} else if (taking_off == WORN_HELMET) {
X	  otmp = uarmh;
X	  if(!cursed(otmp)) (void) Helmet_off();
X	} else if (taking_off == WORN_SHIELD) {
X	  otmp = uarms;
X	  if(!cursed(otmp)) (void) Shield_off();
X#ifdef TOURIST
X	} else if (taking_off == WORN_SHIRT) {
X	  otmp = uarmu;
X	  if(!cursed(otmp))
X	    setworn((struct obj *)0, uarmu->owornmask & W_ARMOR);
X#endif
X	} else if (taking_off == WORN_AMUL) {
X	  otmp = uamul;
X	  if(!cursed(otmp)) Amulet_off();
X	} else if (taking_off == LEFT_RING) {
X	  otmp = uleft;
X	  if(!cursed(otmp)) Ring_off(uleft);
X	} else if (taking_off == RIGHT_RING) {
X	  otmp = uright;
X	  if(!cursed(otmp)) Ring_off(uright);
X	} else if (taking_off == WORN_BLINDF) {
X	  if(!cursed(ublindf)) {
X	    setworn((struct obj *)0, ublindf->owornmask);
X	    if(!Blinded) make_blinded(1L,FALSE); /* See on next move */
X	    else	 You("still cannot see.");
X	  }
X	} else impossible("do_takeoff: taking off %lx", taking_off);
X
X	return(otmp);
X}
X
XSTATIC_PTR
Xint
Xtake_off() {
X
X	register int i;
X	register struct obj *otmp;
X
X	if(taking_off) {
X	    if(todelay > 0) {
X
X		todelay--;
X		return(1);	/* still busy */
X	    } else if((otmp = do_takeoff())) off_msg(otmp);
X
X	    takeoff_mask &= ~taking_off;
X	    taking_off = 0L;
X	}
X
X	for(i = 0; takeoff_order[i]; i++)
X	    if(takeoff_mask & takeoff_order[i]) {
X
X		taking_off = takeoff_order[i];
X		break;
X	    }
X
X	otmp = (struct obj *) 0;
X
X	if (taking_off == 0L) {
X	  You("finish disrobing.");
X	  return 0;
X	} else if (taking_off == 1L) {
X	  todelay = 1;
X	} else if (taking_off == WORN_ARMOR) {
X	  otmp = uarm;
X	} else if (taking_off == WORN_CLOAK) {
X	  otmp = uarmc;
X	} else if (taking_off == WORN_BOOTS) {
X	  otmp = uarmf;
X	} else if (taking_off == WORN_GLOVES) {
X	  otmp = uarmg;
X	} else if (taking_off == WORN_HELMET) {
X	  otmp = uarmh;
X	} else if (taking_off == WORN_SHIELD) {
X	  otmp = uarms;
X#ifdef TOURIST
X	} else if (taking_off == WORN_SHIRT) {
X	  otmp = uarmu;
X#endif
X	} else if (taking_off == WORN_AMUL) {
X	  todelay = 1;
X	} else if (taking_off == LEFT_RING) {
X	  todelay = 1;
X	} else if (taking_off == RIGHT_RING) {
X	  todelay = 1;
X	} else if (taking_off == WORN_BLINDF) {
X	  todelay = 2;
X	} else {
X	  impossible("take_off: taking off %lx", taking_off);
X	  return 0;	/* force done */
X	}
X
X	if(otmp) todelay = objects[otmp->otyp].oc_delay;
X	set_occupation(take_off, "disrobing", 0);
X	return(1);		/* get busy */
X}
X
X#endif /* OVLB */
X#ifdef OVL1
X
Xvoid
Xreset_remarm() { taking_off = takeoff_mask =0L; }
X
X#endif /* OVL1 */
X#ifdef OVLB
X
Xint
Xdoddoremarm() {
X
X	if(taking_off || takeoff_mask) {
X
X	    You("continue disrobing.");
X	    set_occupation(take_off, "disrobing", 0);
X	    return(take_off());
X	}
X
X	(void) ggetobj("take off", select_off, 0);
X	if(takeoff_mask) return(take_off());
X	else		 return(0);
X}
X
Xint
Xdestroy_arm(atmp)
Xregister struct obj *atmp;
X{
X	register struct obj *otmp;
X
X	if((otmp = uarmc) && (!atmp || atmp == uarmc)) {
X		Your("cloak crumbles and turns to dust!");
X		(void) Cloak_off();
X		useup(otmp);
X	} else if((otmp = uarm) && (!atmp || atmp == uarm)) {
X		/* may be disintegrated by spell or dragon breath... */
X		if (donning(otmp)) cancel_don();
X		Your("armor turns to dust and falls to the floor!");
X		(void) Armor_gone();
X		useup(otmp);
X#ifdef TOURIST
X	} else if((otmp = uarmu) && (!atmp || atmp == uarmu)) {
X		Your("shirt crumbles into tiny threads and falls apart!");
X		useup(otmp);
X#endif
X	} else if((otmp = uarmh) && (!atmp || atmp == uarmh)) {
X		if (donning(otmp)) cancel_don();
X		Your("helmet turns to dust and is blown away!");
X		(void) Helmet_off();
X		useup(otmp);
X	} else if((otmp = uarmg) && (!atmp || atmp == uarmg)) {
X		if (donning(otmp)) cancel_don();
X		Your("gloves vanish!");
X		(void) Gloves_off();
X		useup(otmp);
X		selftouch("You");
X	} else if((otmp = uarmf) && (!atmp || atmp == uarmf)) {
X		if (donning(otmp)) cancel_don();
X		Your("boots disintegrate!");
X		(void) Boots_off();
X		useup(otmp);
X	} else if((otmp =uarms) && (!atmp || atmp == uarms)) {
X		Your("shield crumbles away!");
X		(void) Shield_off();
X		useup(otmp);
X	} else	return(0);		/* could not destroy anything */
X
X	return(1);
X}
X
Xvoid
Xadj_abon(otmp, delta)
Xregister struct obj *otmp;
Xregister schar delta;
X{
X	if (uarmg && otmp->otyp == GAUNTLETS_OF_DEXTERITY) {
X		ABON(A_DEX) += (delta);
X		flags.botl = 1;
X	}
X	if (uarmh && otmp->otyp == HELM_OF_BRILLIANCE) {
X		ABON(A_INT) += (delta);
X		ABON(A_WIS) += (delta);
X		flags.botl = 1;
X	}
X}
X
X#endif /* OVLB */
X
X/*do_wear.c*/
END_OF_FILE
if test 37991 -ne `wc -c <'src/do_wear.c'`; then
    echo shar: \"'src/do_wear.c'\" unpacked with wrong size!
fi
# end of 'src/do_wear.c'
fi
if test -f 'src/spell.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/spell.c'\"
else
echo shar: Extracting \"'src/spell.c'\" \(15639 characters\)
sed "s/^X//" >'src/spell.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)spell.c	3.1	92/12/10
X/*	Copyright (c) M. Stephenson 1988			  */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include "hack.h"
X
Xstatic schar NEARDATA delay;		/* moves left for this spell */
Xstatic struct obj NEARDATA *book;	/* last/current book being xscribed */
X
X#define spelluses(spell)	spl_book[spell-1].sp_uses
X#define decrnuses(spell)	spl_book[spell-1].sp_uses--
X#define spellev(spell)		spl_book[spell-1].sp_lev
X#define spellname(spell)	OBJ_NAME(objects[spl_book[spell-1].sp_id])
X#define spellid(spell)		spl_book[spell-1].sp_id
X
Xstatic void FDECL(cursed_book, (int));
Xstatic void FDECL(deadbook, (struct obj *));
XSTATIC_PTR int NDECL(learn);
Xstatic int NDECL(getspell);
Xstatic char FDECL(spellet, (int));
Xstatic char NDECL(dospellmenu);
X
Xstatic void
Xcursed_book(lev)
X	register int	lev;
X{
X	switch(rn2(lev)) {
X	case 0:
X		You("feel a wrenching sensation.");
X		tele();		/* teleport him */
X		break;
X	case 1:
X		You("feel threatened.");
X		aggravate();
X		break;
X	case 2:
X		make_blinded(Blinded + rn1(100,250),TRUE);
X		break;
X	case 3:
X		take_gold();
X		break;
X	case 4:
X		pline("These runes were just too much to comprehend.");
X		make_confused(HConfusion + rn1(7,16),FALSE);
X		break;
X	case 5:
X		pline("The book was coated with contact poison!");
X		if (uarmg) {
X		    /* Note: at this writing, there are no corrodeable
X		     * gloves in the game.  If no one plans on adding
X		     * copper gauntlets, most of this could be removed. -3.
X		     */
X		    if (uarmg->oerodeproof || !is_corrodeable(uarmg)) {
X			Your("gloves seem unaffected.");
X		    } else if (uarmg->oeroded < MAX_ERODE) {
X			Your("gloves corrode%s!",
X			     uarmg->oeroded+1 == MAX_ERODE ? " completely" :
X			     uarmg->oeroded ? " further" : "");
X			uarmg->oeroded++;
X		    } else
X			Your("gloves %s completely corroded.",
X			     Blind ? "feel" : "look");
X		    break;
X		}
X		if(Poison_resistance) {
X		    losestr(rn1(1,2));
X		    losehp(rnd(6), "contact-poisoned spellbook", KILLED_BY_AN);
X		} else {
X		    losestr(rn1(4,3));
X		    losehp(rnd(10), "contact-poisoned spellbook", KILLED_BY_AN);
X		}
X		break;
X	case 6:
X		if(Antimagic) {
X		    shieldeff(u.ux, u.uy);
X		    pline("The book explodes, but you are unharmed!");
X		} else {
X		    pline("As you read the book, it explodes in your %s!",
X			body_part(FACE));
X		    losehp (2*rnd(10)+5, "exploding rune", KILLED_BY_AN);
X		}
X		break;
X	default:
X		rndcurse();
X		break;
X	}
X	return;
X}
X
X/* special effects for The Book of the Dead */
Xstatic void
Xdeadbook(book2)
Xstruct obj *book2;
X{
X    if(invocation_pos(u.ux, u.uy) && !On_stairs(u.ux, u.uy)) {
X	register struct obj *otmp;
X	register boolean arti1_primed = FALSE, arti2_primed = FALSE,
X			 arti_cursed = FALSE;
X
X	if(book2->cursed) {
X	    pline("The runes appear scrambled.  You can't read them!");
X	    return;
X	}
X
X	if(!u.uhave.bell || !u.uhave.menorah) {
X	    pline("A chill runs down your spine.");
X	    if(!u.uhave.bell) You("hear a faint chime...");
X	    if(!u.uhave.menorah) pline("Vlad's doppelganger is amused.");
X	    return;
X	}
X
X	for(otmp = invent; otmp; otmp = otmp->nobj) {
X	    if(otmp->otyp == CANDELABRUM_OF_INVOCATION &&
X	       otmp->spe == 7 && otmp->lamplit) {
X		if(!otmp->cursed) arti1_primed = TRUE;
X		else arti_cursed = TRUE;
X	    }
X	    if(otmp->otyp == BELL_OF_OPENING &&
X	       (moves - otmp->age) < 5L) { /* you rang it recently */
X		if(!otmp->cursed) arti2_primed = TRUE;
X		else arti_cursed = TRUE;
X	    }
X	}
X
X	if(arti_cursed) {
X	    pline("The invocation fails!");
X	    pline("At least one of your artifacts is cursed...");
X	} else if(arti1_primed && arti2_primed) {
X	    mkinvokearea();
X	    u.uevent.invoked = 1;
X	} else {	/* at least one artifact not prepared properly */
X	    You("have a feeling that something is amiss...");
X	    goto raise_dead;
X	}
X	return;
X    }
X
X    /* when not an invocation situation */
X    if(book2->cursed)
Xraise_dead:
X    {
X	register struct monst *mtmp;
X	coord mm;
X
X	You("raised the dead!");
X	mm.x = u.ux;
X	mm.y = u.uy;
X	mkundead(&mm);
X	if(!rn2(4))
X	    if(mtmp = makemon(&mons[PM_MASTER_LICH],u.ux,u.uy)) {
X		mtmp->mpeaceful = 0;
X		set_malign(mtmp);
X	    }
X    } else if(book2->blessed) {
X	register struct monst *mtmp, *mtmp2;
X
X	for(mtmp = fmon; mtmp; mtmp = mtmp2) {
X	    mtmp2 = mtmp->nmon;		/* tamedog() changes chain */
X	    if(is_undead(mtmp->data) && cansee(mtmp->mx, mtmp->my)) {
X		mtmp->mpeaceful = TRUE;
X		if(sgn(mtmp->data->maligntyp) == sgn(u.ualign.type)
X		   && distu(mtmp->mx, mtmp->my) < 4)
X		    if (mtmp->mtame)
X			mtmp->mtame++;
X		    else
X			(void) tamedog(mtmp, (struct obj *)0);
X		else mtmp->mflee = TRUE;
X	    }
X	}
X    } else {
X	switch(rn2(3)) {
X	case 0: 
X	    Your("ancestors are annoyed with you!"); 
X	    break;
X	case 1: 
X	    pline("The headstones in the cemetery begin to move!");
X	    break;
X	default:
X	    pline("Oh my!  Your name appears in the book!");
X	}
X    }
X    return;
X}
X
XSTATIC_PTR
Xint
Xlearn()
X{
X	register int	i;
X	register unsigned booktype;
X
X	if (delay) {	/* not if (delay++), so at end delay == 0 */
X		delay++;
X		return(1); /* still busy */
X	}
X	exercise(A_WIS, TRUE);		/* you're studying. */
X	booktype = book->otyp;
X	if(booktype == SPE_BOOK_OF_THE_DEAD) {
X	    deadbook(book);
X	    return(0);
X	}
X
X	for (i = 0; i < MAXSPELL; i++)  {
X		if (spl_book[i].sp_id == booktype)  {
X			if (book->spestudied >= rn1(1,8-spl_book[i].sp_lev)) {
X			    pline("This spellbook is too faint to be read anymore.");
X			    book->otyp = booktype = SPE_BLANK_PAPER;
X			    makeknown((int)booktype);
X			}
X			else if (spl_book[i].sp_uses < 11-spl_book[i].sp_lev) {
X			    Your("knowledge of that spell is keener.");
X			    spl_book[i].sp_uses += rn1(1,9-spl_book[i].sp_lev);
X			    book->spestudied++;
X			    exercise(A_WIS, TRUE);	/* extra study */
X			} else
X			    You("know that spell quite well already.");
X			break;
X		} else if (spl_book[i].sp_id == NO_SPELL)  {
X			spl_book[i].sp_id = booktype;
X			spl_book[i].sp_lev = objects[booktype].oc_level;
X			/* spells have 1 .. 9-level uses. */
X			/* ie 1 or 2 uses w/ most potent */
X			spl_book[i].sp_uses = rn1(1,9-spl_book[i].sp_lev);
X			book->spestudied++;
X			You("add the spell to your repertoire.");
X			makeknown((int)booktype);
X			break;
X		}
X	}
X	if (i == MAXSPELL) impossible("Too many spells memorized!");
X
X	if (book->cursed) {	/* maybe a demon cursed it */
X		cursed_book(objects[booktype].oc_level);
X	}
X        check_unpaid(book);
X	book = 0;
X	return(0);
X}
X
Xint
Xstudy_book(spellbook)
Xregister struct obj *spellbook;
X{
X	register int	 booktype = spellbook->otyp;
X	register boolean confused = (Confusion != 0);
X
X	if (delay && spellbook == book)
X		You("continue your efforts to memorize the spell.");
X	else {
X		switch(booktype)  {
X
X/* blank spellbook */
X	case SPE_BLANK_PAPER:
X		pline("This spellbook is all blank.");
X		makeknown(SPE_BLANK_PAPER);
X		return(1);
X/* level 1 spells */
X	case SPE_HEALING:
X	case SPE_DETECT_MONSTERS:
X	case SPE_FORCE_BOLT:
X	case SPE_LIGHT:
X	case SPE_SLEEP:
X	case SPE_KNOCK:
X/* level 2 spells */
X	case SPE_MAGIC_MISSILE:
X	case SPE_CONFUSE_MONSTER:
X	case SPE_SLOW_MONSTER:
X	case SPE_CURE_BLINDNESS:
X	case SPE_CREATE_MONSTER:
X	case SPE_DETECT_FOOD:
X	case SPE_WIZARD_LOCK:
X		delay = -objects[booktype].oc_delay;
X		break;
X/* level 3 spells */
X	case SPE_HASTE_SELF:
X	case SPE_CAUSE_FEAR:
X	case SPE_CURE_SICKNESS:
X	case SPE_DETECT_UNSEEN:
X	case SPE_EXTRA_HEALING:
X	case SPE_CHARM_MONSTER:
X	case SPE_CLAIRVOYANCE:
X/* level 4 spells */
X	case SPE_LEVITATION:
X	case SPE_RESTORE_ABILITY:
X	case SPE_INVISIBILITY:
X	case SPE_FIREBALL:
X	case SPE_DETECT_TREASURE:
X		delay = -(objects[booktype].oc_level - 1) * objects[booktype].oc_delay;
X		break;
X/* level 5 spells */
X	case SPE_REMOVE_CURSE:
X	case SPE_MAGIC_MAPPING:
X	case SPE_CONE_OF_COLD:
X	case SPE_IDENTIFY:
X	case SPE_DIG:
X/* level 6 spells */
X	case SPE_TURN_UNDEAD:
X	case SPE_POLYMORPH:
X	case SPE_CREATE_FAMILIAR:
X	case SPE_TELEPORT_AWAY:
X		delay = -objects[booktype].oc_level * objects[booktype].oc_delay;
X		break;
X/* level 7 spells */
X	case SPE_CANCELLATION:
X	case SPE_FINGER_OF_DEATH:
X	case SPE_BOOK_OF_THE_DEAD:
X		delay = -8 * objects[booktype].oc_delay;
X		break;
X/* impossible */
X	default:
X		impossible("Unknown spellbook, %d;", booktype);
X		return(0);
X	}
X
X		/* Books are often wiser than their readers (Rus.) */
X		if(!spellbook->blessed &&
X		        spellbook->otyp != SPE_BOOK_OF_THE_DEAD &&
X			(spellbook->cursed ||
X			    rn2(20) > (ACURR(A_INT) + 4 + (int)(u.ulevel/2)
X					- 2*objects[booktype].oc_level))) {
X			cursed_book(objects[booktype].oc_level);
X			nomul(delay);			/* study time */
X			delay = 0;
X			if(!rn2(3)) {
X				useup(spellbook);
X				pline("The spellbook crumbles to dust!");
X			}
X			return(1);
X		}
X		else if(confused) {
X			if(!rn2(3) && 
X			    spellbook->otyp != SPE_BOOK_OF_THE_DEAD) {
X				useup(spellbook);
X				pline("Being confused you have difficulties in controlling your actions.");
X				display_nhwindow(WIN_MESSAGE, FALSE);
X				You("accidentally tear the spellbook to pieces.");
X			}
X			else
X				You("find yourself reading the first line over and over again.");
X			nomul(delay);
X			delay = 0;
X			return(1);
X		}
X
X		You("begin to %s the runes.",
X		    spellbook->otyp == SPE_BOOK_OF_THE_DEAD ? "recite" :
X		    "memorize");
X	}
X
X	book = spellbook;
X	set_occupation(learn, "studying", 0);
X	return(1);
X}
X
Xstatic int
Xgetspell()
X{
X	register int	maxs, ilet, i;
X	char	 lets[BUFSZ], buf[BUFSZ], qbuf[QBUFSZ];
X
X	if (spl_book[0].sp_id == NO_SPELL)  {
X
X		You("don't know any spells right now.");
X		return(0);
X	} else  {
X
X	    for(maxs = 1; (maxs < MAXSPELL) && (spl_book[maxs].sp_id != NO_SPELL); maxs++);
X	    if (maxs >= MAXSPELL)  {
X
X		impossible("Too many spells memorized.");
X		return(0);
X	    }
X
X	    for(i = 0; (i < maxs) && (i < 26); buf[++i] = 0)  buf[i] = 'a' + i;
X	    for(i = 26; (i < maxs) && (i < 52); buf[++i] = 0) buf[i] = 'A' + i - 26;
X
X	    if (maxs == 1)  Strcpy(lets, "a");
X	    else if (maxs < 27)  Sprintf(lets, "a-%c", 'a' + maxs - 1);
X	    else if (maxs == 27)  Sprintf(lets, "a-z A");
X	    else Sprintf(lets, "a-z A-%c", 'A' + maxs - 27);
X	    for(;;)  {
X
X		Sprintf(qbuf, "Cast which spell? [%s ?]", lets);
X		if ((ilet = yn_function(qbuf, NULL, '\0')) == '?') {
X			ilet = dospellmenu();
X			if(!ilet)
X			    continue;
X		}
X		if (index(quitchars, ilet))
X			return(0);
X		else for(i = 0; buf[i] != 0; i++)
X		    if(ilet == buf[i])  return(++i);
X		You("don't know that spell.");
X	    }
X	}
X}
X
Xint
Xdocast()
X{
X	register int	 spell;
X
X	spell = getspell();
X	if (!spell) return(0);
X
X	return(spelleffects(spell,FALSE));
X}
X
Xint
Xspelleffects(spell,atme)
Xregister int spell;
Xboolean atme;
X{
X	register int energy, damage;
X	boolean confused = (Confusion != 0);
X	struct obj *pseudo;
X
X	/* note that trying to cast it decrements the # of uses,    */
X	/* even if the mage does not have enough food/energy to use */
X	/* the spell */
X	switch (spelluses(spell)) {
X		case 0:
X		    pline ("Curdled magical energy twists through you...");
X		    pline ("...you have overloaded and burned out this spell.");
X		    make_confused((long)spellev(spell) * 3, FALSE);
X		    return(0);
X		case 1:
X		    Your("nerves tingle warningly.");
X		    break;
X		case 2:
X		    pline ("This spell is starting to be over-used.");
X		    break;
X		default:
X		    break;
X	}
X	decrnuses(spell);
X	energy = spellev(spell) * 7 / 2 - 2;    /* 1 <= energy <= 22 */
X	if (u.uhunger <= 100 && spell != SPE_DETECT_FOOD) {
X		You("are too hungry to cast that spell.");
X		return(0);
X	} else if (ACURR(A_STR) < 6)  {
X		You("lack the strength to cast spells.");
X		return(0);
X	} else if(check_capacity(
X		"Your concentration falters while carrying so much stuff.")) {
X	    return (1);
X	}
X
X	if (u.uhave.amulet) {
X		You("feel the amulet draining your energy away.");
X		energy *= rnd(3);
X	}
X	if(energy > u.uen)  {
X		You("don't have enough energy to cast that spell.");
X		return(0);
X	} else {
X		if (spell != SPE_DETECT_FOOD)
X			morehungry(energy * 10);
X		u.uen -= energy;
X	}
X	flags.botl = 1;
X
X	if (confused ||
X	    ((int)(ACURR(A_INT) + Luck) - 3 * spellev(spell)) < 0) {
X
X		if (Hallucination)
X			pline("Far out... a light show!");
X		else	pline("The air around you crackles as you goof up.");
X		return(0);
X	}
X	exercise(A_WIS, TRUE);
X/*	pseudo is a temporary "false" object containing the spell stats. */
X	pseudo = mksobj(spellid(spell), FALSE, FALSE);
X	pseudo->blessed = pseudo->cursed = 0;
X	pseudo->quan = 20L;			/* do not let useup get it */
X	switch(pseudo->otyp)  {
X
X/* These spells are all duplicates of wand effects */
X	case SPE_FORCE_BOLT:
X	case SPE_SLEEP:
X	case SPE_MAGIC_MISSILE:
X	case SPE_KNOCK:
X	case SPE_SLOW_MONSTER:
X	case SPE_WIZARD_LOCK:
X	case SPE_FIREBALL:
X	case SPE_CONE_OF_COLD:
X	case SPE_DIG:
X	case SPE_TURN_UNDEAD:
X	case SPE_POLYMORPH:
X	case SPE_TELEPORT_AWAY:
X	case SPE_CANCELLATION:
X	case SPE_FINGER_OF_DEATH:
X	case SPE_LIGHT:
X	case SPE_DETECT_UNSEEN:
X		if (!(objects[pseudo->otyp].oc_dir == NODIR)) {
X			if (atme) u.dx = u.dy = u.dz = 0;
X			else (void) getdir(NULL);
X			if(!u.dx && !u.dy && !u.dz) {
X			    if((damage = zapyourself(pseudo)))
X				losehp(damage, 
X		self_pronoun("zapped %sself with a spell", "him"),
X					NO_KILLER_PREFIX);
X			} else	weffects(pseudo);
X		} else weffects(pseudo);
X		break;
X/* These are all duplicates of scroll effects */
X	case SPE_CONFUSE_MONSTER:
X	case SPE_DETECT_FOOD:
X	case SPE_CAUSE_FEAR:
X	case SPE_CHARM_MONSTER:
X	case SPE_REMOVE_CURSE:
X	case SPE_MAGIC_MAPPING:
X	case SPE_CREATE_MONSTER:
X	case SPE_IDENTIFY:
X		(void) seffects(pseudo);
X		break;
X	case SPE_HASTE_SELF:
X	case SPE_DETECT_TREASURE:
X	case SPE_DETECT_MONSTERS:
X	case SPE_LEVITATION:
X	case SPE_RESTORE_ABILITY:
X	case SPE_INVISIBILITY:
X		(void) peffects(pseudo);
X		break;
X	case SPE_HEALING:
X		You("feel a bit better.");
X		healup(rnd(8), 0, FALSE, FALSE);
X		break;
X	case SPE_CURE_BLINDNESS:
X		healup(0, 0, FALSE, TRUE);
X		break;
X	case SPE_CURE_SICKNESS:
X		if (Sick) You("are no longer ill.");
X		healup(0, 0, TRUE, FALSE);
X		break;
X	case SPE_EXTRA_HEALING:
X		You("feel a fair bit better.");
X		healup(d(2,8)+2, 0, FALSE, FALSE);
X		break;
X	case SPE_CREATE_FAMILIAR:
X		make_familiar((struct obj *)0, u.ux, u.uy);
X		break;
X	case SPE_CLAIRVOYANCE:
X		do_vicinity_map();
X		break;
X	default:
X		impossible("Unknown spell %d attempted.", spell);
X		obfree(pseudo, (struct obj *)0);
X		return(0);
X	}
X	obfree(pseudo, (struct obj *)0);	/* now, get rid of it */
X	return(1);
X}
X
Xvoid
Xlosespells() {
X	register boolean confused = (Confusion != 0);
X	register int	 n, nzap, i;
X
X	book = 0;
X	for(n = 0;(spl_book[n].sp_id != NO_SPELL) && (n < MAXSPELL); n++);
X	if (!n) return;
X	if (n < MAXSPELL) {
X		nzap = rnd(n);
X		if (nzap < n) nzap += confused;
X		for (i = 0; i < nzap; i++) {
X		    spl_book[n-i-1].sp_id = NO_SPELL;
X		    exercise(A_WIS, FALSE);	/* ouch! */
X		}
X	} else impossible("Too many spells memorized!");
X	return;
X}
X
Xstatic char
Xspellet(spl)
Xint spl;
X{
X	return (spl < 27) ? ('a' + spl - 1) : ('A' + spl - 27);
X}
X
Xint
Xdovspell()
X{
X    (void) dospellmenu();
X    return 0;
X}
X
Xstatic char
Xdospellmenu()
X{
X	winid tmpwin;
X	register int maxs, i;
X	char rval;
X	char     buf[BUFSZ];
X
X	if (spl_book[0].sp_id == NO_SPELL)  {
X
X		You("don't know any spells right now.");
X		return 0;
X	}
X
X	for(maxs = 1; (maxs < MAXSPELL) && (spl_book[maxs].sp_id != NO_SPELL); maxs++);
X	if (maxs >= MAXSPELL)  {
X
X		impossible("Too many spells memorized.");
X		return 0;
X	}
X	tmpwin = create_nhwindow(NHW_MENU);
X	start_menu(tmpwin);
X	add_menu(tmpwin, 0, 0, "Currently known spells:");
X	add_menu(tmpwin, 0, 0, "");
X
X	for(i = 1; i <= maxs; i++) {
X		Sprintf(buf, "%c %c %s (%d)",
X			spellet(i), (spelluses(i)) ? '-' : '*',
X			spellname(i), spellev(i));
X		add_menu(tmpwin, spellet(i), 0, buf);
X  	}
X	end_menu(tmpwin, '\0', "\033 ", NULL);
X	rval = select_menu(tmpwin);
X	destroy_nhwindow(tmpwin);
X
X	return rval;
X}
X
X/*spell.c*/
END_OF_FILE
if test 15639 -ne `wc -c <'src/spell.c'`; then
    echo shar: \"'src/spell.c'\" unpacked with wrong size!
fi
# end of 'src/spell.c'
fi
echo shar: End of archive 41 \(of 108\).
cp /dev/null ark41isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \
21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \
41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 \
61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 \
81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 \
101 102 103 104 105 106 107 108 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 108 archives.
    echo "Now execute 'rebuild.sh'"
    rm -f ark10[0-8]isdone ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
