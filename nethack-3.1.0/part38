Path: uunet!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v16i046:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Part38/108
Message-ID: <4340@master.CNA.TEK.COM>
Date: 30 Jan 93 01:12:17 GMT
Sender: news@master.CNA.TEK.COM
Lines: 2670
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1595

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 16, Issue 46
Archive-name: nethack31/Part38
Supersedes: nethack3p9: Volume 10, Issue 46-102
Environment: Amiga, Atari, Mac, MS-DOS, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 38 (of 108)."
# Contents:  sys/amiga/wbcli.c sys/msdos/trampoli.c
# Wrapped by billr@saab on Wed Jan 27 16:09:01 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'sys/amiga/wbcli.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/amiga/wbcli.c'\"
else
echo shar: Extracting \"'sys/amiga/wbcli.c'\" \(38406 characters\)
sed "s/^X//" >'sys/amiga/wbcli.c' <<'END_OF_FILE'
X/*    SCCS Id: @(#)wbcli.c  2.1   93/01/08			  */
X/*    Copyright (c) Kenneth Lorber, Bethesda, Maryland, 1991	  */
X/*    Copyright (c) Gregg Wonderly, Naperville, IL, 1992, 1993    */
X/* NetHack may be freely redistributed.  See license for details. */
X
X/* Friendly Intuition interface for NetHack 3.1 on the Amiga */
X
X/*
X * This file contains many routines common to the CLI and WB interfaces,
X * along with a few specific to each.  #defining CLI supports the CLI
X * interface; not #defining it supports (along with wb.c) the WB interface.
X */
X
X#include "Incl:date.h"          /* this gives us the version string */
X
X#ifdef AZTEC_C
X/* Aztec doesn't recognize __chip syntax */
X# define __chip
X#endif
X
X#include "Amiga:wbdefs.h"       /* Miscellany information */
X#ifdef  INTUI_NEW_LOOK
X#define NewWindow   ExtNewWindow
X#define NewScreen   ExtNewScreen
X#endif
X#include "Amiga:wbstruct.h"
X#include "Amiga:wbprotos.h"
X
X#ifdef CLI
X#include "Amiga:wbdata.c"       /* All structures and global data */
X
X#undef NetHackCnf
Xchar NetHackCnf[50]="NetHack:NetHack.cnf";
X#endif  /* CLI */
X
X#define C_GREY  0
X#define C_BLACK 1
X#define C_WHITE 2
X#define C_BLUE  3
X
X#ifndef __SASC_60
Xextern char *sys_errlist[];
X#endif
Xextern int errno;
X
X#define SPLIT           /* use splitter, if available */
X
Xvoid diskobj_filter(struct DiskObject *);
XBPTR s_LoadSeg(char *);
Xvoid s_UnLoadSeg(void);
X
X#ifdef CLI
Xchar *cnfsavedir="NetHack:save";    /* unless overridden in cnf file */
Xchar argline[255];  /* no overflow - bigger than ADOS will pass */
X
Xvoid WaitEOG(GPTR);
Xchar *eos(char *);
Xvoid condaddslash(char *);
X
X# ifdef SPLIT
Xint running_split=0;        /* if 0, using normal LoadSeg/UnLoadSeg */
X# endif
X#else
Xextern char *options[NUMIDX+1];
Xextern GPTR gamehead,gameavail;
Xextern DEFAULTS defgame;
Xextern struct Window *win;
X#endif  /* CLI */
X
X#ifdef AZTEC_C
Xextern char *strdup(char *);
X
X/*
X * Aztec has a strnicmp, but it doesn't work properly.
X *
X * Note: this came out of NHS:hacklib.c
X */
Xstatic char
Xlowc(c)         /* force 'c' into lowercase */
X    char c;
X{
X    return ('A' <= c && c <= 'Z') ? (c | 040) : c;
X}
X
Xint
Xstrnicmp(s1, s2, n)
X    register const char *s1, *s2;
X    register int n;
X{
X    register char t1, t2;
X
X    while (n--) {
X	if (!*s2) return (*s1 != 0);    /* s1 >= s2 */
X	else if (!*s1) return -1;   /* s1  < s2 */
X	t1 = lowc(*s1++);
X	t2 = lowc(*s2++);
X	if (t1 != t2) return (t1 > t2) ? 1 : -1;
X    }
X    return 0;               /* s1 == s2 */
X}
X#endif
X
X#ifndef max
X# define max(a, b) ((a) > (b) ? (a) : (b))
X#endif
X#ifndef min
X# define min(x,y) ((x) < (y) ? (x) : (y))
X#endif
X
Xchar *copyright_text[]={
X"NetHack, Copyright 1985, 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993.",
X"         By Stichting Mathematisch Centrum and M. Stephenson.",
X"         See license for details.",
X0
X};
X
X#ifdef CLI
X
Xmain( argc, wbs )
X    int argc;
X    struct WBStartup *wbs;
X{
X    GPTR gptr;
X    BPTR lc,lc2;
X    struct FileInfoBlock finfo;
X    char *name;
X    char namebuf[50];
X    char **argv=(char **)wbs;
X
X    ZapOptions( curopts );
X    InitWB( argc, (struct WBStartup *)argv );
X    errmsg( NO_FLASH, "Welcome to NetHack Version 3.1!\n" );
X    CopyRight( );
X
X    ReadConfig( );
X
X    /* Wait till user quits */
X
X    while( !quit )
X    {
X	char tbuf[8];
X	char *p=tbuf;
X	char *dirname=cnfsavedir;
X/* play a game */
X	{
X	    int c;
X	    argline[0]='\0';
X	    name="NewGame.info";        /* this will fail - it's in NetHack: */
X	    for(c=1;c<argc;c++){
X		/* slow but easy - not a critical path */
X		strcpy(eos(argline),argv[c]);
X		if(!strncmp(argv[c],"-u",2)){
X		    if(!strcmp(argv[c],"-u")){
X			name= argv[c+1];
X		    }else{
X			name= &argv[c][1];
X		    }
X		}
X		if(c<argc)strcpy(eos(argline)," ");
X	    }
X	    eos(argline)[-1]='\0';
X	}
X	strcpy(namebuf,cnfsavedir);
X	condaddslash(namebuf);
X	strcpy(eos(namebuf),name);
X	lc=Lock(namebuf,ACCESS_READ);
X	if(!lc){
X	    dirname="NetHack:";
X	    strcpy(namebuf,dirname);
X	    strcpy(eos(namebuf),"NewGame.info");
X	    lc=Lock(namebuf,ACCESS_READ);
X	    if(!lc){
X		errmsg(NO_FLASH,"can't find NewGame.info");
X		cleanup(1);
X	    }
X	}
X	Examine(lc,&finfo);
X	lc2=ParentDir(lc);
X	UnLock(lc);
X	gptr=GetWBIcon(lc2,dirname,&finfo);
X	UnLock(lc2);
X	run_game(gptr);
X
X/* wait for game to end */
X	WaitEOG(gptr);
X	FreeGITEM(gptr);
X/* ask about another? */
X	printf("Play again? [yn] ");
X	fgets(tbuf,sizeof(tbuf),stdin);
X	while(*p && isspace(*p))p++;
X	switch(*p){
X	case 'n':
X	case 'N':
X	    quit=1;
X	}
X    }
X    cleanup(0);
X}
X
X/* CLI */
X
Xvoid
XWaitEOG(target)
X    GPTR target;
X{
X    long mask, rmask;
X    struct WBStartup *wbs;
X    struct WBArg *wba;
X    int i;
X	/* Get a message */
X    while(1){
X	mask = ( 1L << dosport->mp_SigBit ) ;
X	rmask = Wait( mask );
X
X
X	if( rmask & ( 1L << dosport->mp_SigBit ) )
X	{
X	    /* Get process termination messages */
X
X	    while( wbs = (struct WBStartup *) GetMsg( dosport ) )
X	    {
X		/* Find the game that has terminated */
X
X		if(target->seglist == wbs->sm_Segment)
X		{
X#ifdef SPLIT
X		    if(!running_split)
X#endif
X		    /* Unload the code */
X		    UnLoadSeg( wbs->sm_Segment );
X		    /* Free the startup message resources */
X
X		    wba = (struct WBArg *)
X			((long)wbs + sizeof( struct WBStartup ));
X		    for( i = 0; i < wbs->sm_NumArgs; ++i )
X		    {
X			FreeMem( wba[i].wa_Name, strlen( wba[i].wa_Name ) + 1 );
X			UnLock( wba[i].wa_Lock );
X		    }
X		    FreeMem( wbs, wbs->sm_Message.mn_Length );
X		    wbs = NULL;
X
X		    return;
X		}
X	    }
X
X	}
X    }
X}
X
X/* CLI */
X
Xvoid CopyRight()
X{
X    int line;
X    for(line=0;copyright_text[line];line++){
X	printf("%s\n",copyright_text[line]);
X    }
X}
X
X/* CLI */
X
X/*
X * Do the one time initialization things.
X */
X
Xvoid
XInitWB( argc, wbs )
X    int argc;
X    register struct WBStartup *wbs;
X{
X
X    /* Open Libraries */
X    GfxBase= (struct GfxBase *) OldOpenLibrary("graphics.library");
X    IconBase= OldOpenLibrary("icon.library");
X    DiskfontBase= (struct DiskfontBase *)OldOpenLibrary("diskfont.library");
X    IntuitionBase= (struct IntuitionBase *)OldOpenLibrary("intuition.library");
X
X    if(!GfxBase || !IconBase || !DiskfontBase || !IntuitionBase)
X    {
X	error("library open failed");
X	cleanup( 1 );
X    }
X
X    /* Get Port for replied WBStartup messages */
X
X    if( ( dosport = CreatePort( NULL, 0 ) ) == NULL )
X    {
X	error("failed to create dosport" );
X	cleanup( 1 );
X    }
X
X    /* If started from CLI */
X    if( argc == 0 ){
X	printf("Run this program from CLI only.\n");
X	DisplayBeep(0);     /* could be more specific */
X	Delay(400);
X	cleanup(1);
X    }
X}
X
X/* CLI */
X
X/*
X * Read a nethack.cnf like file and collect the configuration
X * information from it.
X */
Xvoid ReadConfig()
X{
X    register FILE *fp;
X    register char *buf, *t;
X
X    /* Use a dynamic buffer to limit stack use */
X
X    if( ( buf = xmalloc( 1024 ) ) == NULL )
X    {
X	error( "Can't alloc space to read config file" );
X	cleanup( 1 );
X    }
X
X    /* If the file is not there, can't load it */
X
X    if( ( fp = fopen( NetHackCnf, "r" ) ) == NULL )
X    {
X	errmsg( FLASH, "Can't load config file %s", NetHackCnf );
X	free( buf );
X	return;
X    }
X
X    /* Read the lines... */
X
X    while( fgets( buf, 1024, fp ) != NULL )
X    {
X	if( *buf == '#' )
X	    continue;
X
X	if( ( t = strchr( buf, '\n' ) ) != NULL )
X	    *t = 0;
X
X	if( strnicmp( buf, "SAVE=", 5 ) == 0 )
X	{
X	    cnfsavedir=strdup(buf+5);
X	}
X	else
X	{
X	    /* We don't care about the rest */
X	}
X    }
X    fclose( fp );
X    free( buf );
X}
X
X/* CLI */
X
Xvoid
Xrun_game( gptr )
X    register GPTR gptr;
X{
X    struct Task *ctask;
X    register struct MsgPort *proc = NULL;
X    int tidx;
X
X    tidx = 0;
X
X    gptr->gname = xmalloc( 20 + strlen( gptr->name ) );
X
X    SetToolLine(gptr, "INTERNALCLI", argline);
X    gptr->wbs = AllocMem( sizeof( struct WBStartup ) +
X	( sizeof( struct WBArg ) * 2 ), MEMF_PUBLIC | MEMF_CLEAR );
X
X    /* Check if we got everything */
X
X    if( !gptr->gname || !gptr->wbs )
X    {
X	fprintf( stderr, "Can't allocate memory\n" );
X	goto freemem;
X    }
X
X    /* Get the arguments structure space */
X
X    gptr->wba = ( struct WBArg * ) ((long)gptr->wbs + 
X	sizeof( struct WBStartup ) );
X    /* Load the game into memory */
X#ifdef SPLIT
X	/* Which version do we run? */
X    {
X    char gi[80];
X    BPTR tmplock;
X
X    sprintf( gi, "%s.dir", GAMEIMAGE );
X    tmplock=Lock( gi, ACCESS_READ );
X    if( tmplock ){
X	UnLock( tmplock );
X	gptr->seglist = (BPTR)s_LoadSeg( gi );
X	if(gptr->seglist)running_split=1;
X    }else{
X	gptr->seglist = (BPTR)LoadSeg( GAMEIMAGE );
X    }
X    }
X#else
X    gptr->seglist = (BPTR)LoadSeg( GAMEIMAGE );
X#endif
X
X    if( gptr->seglist == NULL)
X    {
X	errmsg( FLASH, "Can't load %s", GAMEIMAGE );
X	goto freemem;
X    }
X
X    /* Set the game name for the status command */
X    sprintf( gptr->gname, "NetHack 3.1 %s", gptr->name );
X
X    /* Create a process for the game to execute in */
X    ctask = FindTask( NULL );
X    proc = CreateProc( gptr->gname, ctask->tc_Node.ln_Pri,
X		    gptr->seglist, GAMESTACK );
X
X    /* Check if the create failed */
X
X    if( proc == NULL )
X    {
X	fprintf(stderr, "Error creating process %d\n", IoErr() );
X#ifdef SPLIT
X	if(!running_split)
X#endif
X	    UnLoadSeg( gptr->seglist );
Xfreemem:
X	if( gptr->gname ) free( gptr->gname );
X	gptr->gname = NULL;
X
X	if( gptr->wbs ) FreeMem( gptr->wbs,
X	    sizeof( struct WBStartup ) + sizeof( struct WBArg ) * 2 );
X	gptr->wbs = NULL;
X	return;
X    }
X
X    /* Get the Process structure pointer */
X    gptr->prc = (struct Process *) (((long)proc) - sizeof( struct Task ));
X
X    /* Set the current directory */
X    gptr->prc->pr_CurrentDir=((struct Process *)FindTask(NULL))->pr_CurrentDir;
X
X    /* Fill in the startup message */
X    gptr->wbs->sm_Process = proc;
X    gptr->wbs->sm_Segment = gptr->seglist;
X    gptr->wbs->sm_NumArgs = 2;
X    gptr->wbs->sm_ToolWindow = "con:0/0/100/300/NetHack 3.1";
X    gptr->wbs->sm_ArgList = gptr->wba;
X
X    /* Fill in the args */
X
X    gptr->wba[0].wa_Name = Strdup( GAMEIMAGE );
X    gptr->wba[0].wa_Lock = Lock( dirname( GAMEIMAGE ), ACCESS_READ );
X
X    gptr->wba[1].wa_Name = Strdup( gptr->name );
X    gptr->wba[1].wa_Lock = Lock( gptr->dname, ACCESS_READ );
X
X    /* Write the updated tools types entries */
X
X    WriteDObj( gptr, gptr->wba[1].wa_Lock );
X
X    /* Set the message fields correctly */
X
X    gptr->wbs->sm_Message.mn_Node.ln_Type = NT_MESSAGE;
X    gptr->wbs->sm_Message.mn_Node.ln_Pri = 0;
X    gptr->wbs->sm_Message.mn_ReplyPort = dosport;
X    gptr->wbs->sm_Message.mn_Length =
X	sizeof( struct WBStartup ) + ( sizeof( struct WBArg ) * 2 );
X
X    /* Send the WB Startup message to let the game go... */
X
X    PutMsg( proc, &gptr->wbs->sm_Message );
X}
X
X#else   /* CLI */
X
Xvoid RPText( rp, s )
X    struct RastPort *rp;
X    register char *s;
X{
X    Text( rp, s, strlen( s ) );
X}
X
X/* !CLI */
X
Xvoid
XSetUpMenus( mp, scrn )
X    register struct Menu *mp;
X    register struct Screen *scrn;
X{
X    register struct MenuItem *mip;
X    register int i, leftoff = 0, horiz=0, len;
X    register int com, chk;
X
X    for( ; mp; mp = mp->NextMenu )
X    {
X	i = 0;
X	horiz = (scrn->RastPort.TxWidth*strlen(mp->MenuName))+16;
X	/*mp->LeftEdge = leftoff;*/
X	com = chk = 0;
X	for( mip = mp->FirstItem; mip; mip = mip->NextItem )
X	{
X	    if( mip->Flags & COMMSEQ )
X		com = scrn->RastPort.TxWidth * 6;
X	    if( mip->Flags & CHECKIT )
X		chk = scrn->RastPort.TxWidth * 3;
X	}
X	for( mip = mp->FirstItem; mip; mip = mip->NextItem )
X	{
X	    mip->Height = scrn->RastPort.TxHeight;
X	    mip->TopEdge = scrn->RastPort.TxHeight * i++;
X
X	    len = IntuiTextLength((struct IntuiText *)
X		    (mip->ItemFill))+8+com+chk;
X	    horiz = max( horiz,len );
X	}
X
X	for( mip = mp->FirstItem; mip; mip = mip->NextItem )
X	{
X	    mip->Width = horiz;
X	}
X	leftoff += horiz;
X    }
X}
X
X/* !CLI */
X
X/* Get a text line from the indicated file based on an array of per
X * line offsets.
X */
X
Xvoid getline( fp, offarr, which, buf, size )
X    FILE *fp;
X    long *offarr;
X    int which, size;
X    char *buf;
X{
X    fseek( fp, offarr[ which ], 0 );
X    fgets( buf, size, fp );
X}
X
X/* !CLI */
X
Xvoid
Xdo_closewindow()
X{
X    /*set close flag - cleanup must be done elsewhere*/
X    cleanup( 0 );
X}
X
X/* !CLI */
X
Xvoid
Xmenu_copyopt()
X{
X    GPTR gptr;
X    char newname[ 100 ], oldname[ 100 ], cmd[ 200 ];
X
X    if( ( gptr = NeedGame() ) == NULL )
X	return;
X
X    if( StrRequest( "Enter new player name", newname, gptr->fname ) == 0 )
X	return;
X
X    if( strcmp( newname, gptr->fname ) == 0 )
X    {
X	errmsg( FLASH, "Copying aborted, new name same as old" );
X	return;
X    }
X
X    strcpy( oldname, GameName( gptr, NULL ) );
X    strcpy( newname, GameName( gptr, newname ) );
X
X    sprintf( cmd, "c:copy \"%s\" \"%s\"", oldname, newname );
X    Execute( cmd, NULL, NULL );
X    MapGadgets( R_DISK, 1 );
X}
X
X/* !CLI */
X
Xvoid
Xmenu_rename()
X{
X    register GPTR gptr;
X    char newname[ 100 ], oldname[ 100 ], cmd[ 200 ], name[100], *t;
X
X    if( ( gptr = NeedGame() ) == NULL )
X	return;
X
X    strcpy( newname, gptr->name );
X    if( t = strrchr( newname, '.' ) )
X    {
X	if( strcmp( t, ".sav" ) == 0 )
X	    *t = 0;
X    }
X
X    if( StrRequest( "Enter New Name For Game", name, newname ) == 0)
X	return;
X
X    /* Name can only be this long to allow inclusion of appropriate suffix */
X    name[ 30 - strlen( ".sav.info " ) ] = '\0';
X
X    if( strcmp( name, newname ) == 0 )
X    {
X	errmsg( FLASH, "Rename aborted, name unchanged from %s", newname );
X	return;
X    }
X
X    strcat( name, ".sav" );
X
X    strcpy( oldname, GameName( gptr, NULL ) );
X
X    strcpy( newname, GameName( gptr, name ) );
X    strcat( newname, ".info" );
X
X    /* Rename icon file */
X    sprintf( cmd, "c:rename \"%s\" \"%s\"", oldname, newname );
X    Execute( cmd, NULL, NULL );
X
X    strcpy( oldname, GameName( gptr, gptr->name ) );
X
X    strcpy( newname, GameName( gptr, name ) );
X
X    /* Rename save file if it is actually there */
X    if( access( oldname, 0 ) == 0 )
X    {
X	sprintf( cmd, "c:rename \"%s\" \"%s\"", oldname, newname );
X	Execute( cmd, NULL, NULL );
X    }
X
X    MapGadgets( R_DISK, 1 );
X}
X
X#endif  /* CLI */
X
Xvoid CleanUpLists( )
X{
X    register GPTR gptr;
X
X    while( gptr = gamehead )
X    {
X	gamehead = gamehead->next;
X	FreeGITEM( gptr );
X    }
X
X    while( gptr = gameavail )
X    {
X	gameavail = gameavail->next;
X	free( gptr );
X    }
X}
X
X#ifndef CLI
X
Xvoid SafeCloseWindow( window )
X    register struct Window *window;
X{
X    register struct Message *msg;
X
X    if( !window )
X	return;
X
X    /* Remove any attached menu */
X
X    if( window->MenuStrip )
X    {
X	ClearMenuStrip( window );
X    }
X
X    Forbid();
X    while( window->UserPort != NULL &&
X	    ( msg = GetMsg( window->UserPort) ) != NULL )
X    {
X	ReplyMsg( msg );
X    }
X
X    CloseWindow( window );
X    Permit();
X}
X
X#else   /* CLI */
X
Xvoid CloseLibraries( )
X{
X    if( IntuitionBase )     CloseLibrary( (void *) IntuitionBase );
X    IntuitionBase = 0;
X    if( DiskfontBase )      CloseLibrary( (void *) DiskfontBase );
X    DiskfontBase = 0;
X    if( IconBase )          CloseLibrary(  IconBase );
X    IconBase = 0;
X    if( GfxBase )           CloseLibrary( (void *) GfxBase );
X    GfxBase = 0;
X}
X
X/* CLI */
X
Xvoid cleanup( code )
X    int code;
X{
X    if( dosport ) DeletePort( dosport );
X    dosport = NULL;
X
X    CleanUpLists( );
X    CloseLibraries( );
X
X#ifdef SPLIT
X    if(running_split){
X	s_UnLoadSeg();
X    }
X#endif
X    exit( code );
X}
X
X/* CLI */
X
XGPTR AllocGITEM( )
X{
X    register GPTR gptr;
X
X    if( gameavail )
X    {
X	gptr = gameavail;
X	gameavail = gameavail->next;
X    }
X    else
X    {
X	gptr = xmalloc( sizeof( GAMEITEM ) );
X    }
X
X    if( gptr )
X	memset( gptr, 0, sizeof( GAMEITEM ) );
X
X    return( gptr );
X}
X
X/* CLI */
X
Xvoid FreeGITEM( gptr )
X    register GPTR gptr;
X{
X    /* Free all of the pieces first */
X
X    if( gptr->talloc )
X	FreeTools( gptr );
X
X    if( gptr->dobj )
X	FreeDObj( gptr->dobj );
X
X    gptr->dobj = NULL;
X
X    if( gptr->name )
X	free( gptr->name );
X    gptr->name = NULL;
X
X    if( gptr->dname )
X	free( gptr->dname );
X    gptr->dname = NULL;
X
X    if( gptr->fname )
X	free( gptr->fname );
X    gptr->fname = NULL;
X
X    /* Connect it to free list */
X
X    gptr->next = gameavail;
X    gameavail = gptr;
X}
X
X/* CLI */
X
Xstruct DiskObject *AllocDObj( str )
X    register char *str;
X{
X    register struct DiskObject *doptr;
X    register char *t, *t1;
X
X    if( ( t = strrchr( str, '.' ) ) && stricmp( t, ".info" ) == 0 )
X    {
X	*t = 0;
X    } else {
X	t = NULL;
X    }
X
X    if( doptr = GetDiskObject( str ) )
X    {
X	struct IntuiText *ip;
X
X	diskobj_filter(doptr);  /* delete all but INTERNALCLI */
X
X	if( ip = xmalloc( sizeof( struct IntuiText ) ) )
X	{
X	    memset( ip, 0, sizeof( struct IntuiText ) );
X	    ip->FrontPen = C_BLACK;
X	    ip->DrawMode = JAM1;
X	    ip->IText = strdup( str );
X	    doptr->do_Gadget.GadgetText = ip;
X
X		/* Trim any .sav off of the end. */
X
X	    if( ( t1 = strrchr( ip->IText, '.' ) ) &&
X		stricmp( t1, ".sav" ) == 0 )
X	    {
X		*t1 = 0;
X		ip->LeftEdge = (2 * win->RPort->TxWidth);
X	    }
X        }
X    }
X    if( t ) *t = '.';
X
X    return( doptr );
X}
X
X#endif  /* CLI */
X
Xvoid FreeDObj( doptr )
X    register struct DiskObject *doptr;
X{
X    if( doptr->do_Gadget.GadgetText )
X    {
X	free( doptr->do_Gadget.GadgetText->IText );
X	free( doptr->do_Gadget.GadgetText );
X    }
X    doptr->do_Gadget.GadgetText = NULL;
X    FreeDiskObject( doptr );
X}
X
X#ifdef CLI
X#ifdef AZTEC_C
Xvoid errmsg(int flash, char *str, ...)
X#else
Xvoid errmsg( flash, str )
Xchar *str;
Xint flash;
X#endif
X{
X    va_list vp;
X
X    va_start( vp, str );
X
X/*  if( !win || !wbopen ) */
X    {
X	vprintf( str, vp );
X	va_end( vp );
X	return;
X    }
X
X}
X
X/* CLI */
X
X/*
X * Issue an error message to the users window because it can not be done
X * any other way.
X */
X
Xvoid error( str )
X    register char *str;
X{
X    char s[ 50 ];
X    if( scrn ) ScreenToBack( scrn );
X    Delay( 10 );
X    fprintf( stderr, "%s\n", str );
X    fprintf( stderr, "Hit Return: " );
X    fflush( stderr );
X    gets( s );
X    if( scrn ) ScreenToFront( scrn );
X}
X
X#else   /* CLI */
X
Xvoid menu_scores()
X{
X    register char buf1[50];
X    register char **oldtools;
X    register GPTR gptr;
X    int oldalloc;
X    extern GPTR windowgads;
X
X    if( StrRequest( "Scores for whom?", buf1, "all" ) != 0 )
X    {
X	for( gptr = windowgads; gptr; gptr = gptr->nextwgad )
X	{
X	    if( gptr->dobj->do_Gadget.GadgetID == GADNEWGAME )
X		break;
X	}
X
X	if( !gptr )
X	{
X	    errmsg( FLASH, "Can't find NewGame icon" );
X	    return;
X	}
X
X	/* Save current tools */
X	oldtools = gptr->dobj->do_ToolTypes;
X
X	/* Force a new tooltypes array to be allocated */
X	if( oldalloc = gptr->talloc )
X	{
X	    gptr->dobj->do_ToolTypes = gptr->otools;
X	    gptr->talloc = 0;
X	}
X
X	/* Add the scores entry */
X	    SetToolLine( gptr, "SCORES", *buf1 ? buf1 : "all" );
X
X	/* Get the scores */
X	run_game( gptr );
X
X	/* Free the tools which contain "SCORES=" */
X	FreeTools( gptr );
X
X	/* Restore the old tools.  When this game exits, the tools
X	 * will be written back out to disk to update things
X	 */
X	gptr->dobj->do_ToolTypes = oldtools;
X	gptr->talloc = oldalloc;
X	Delay( 100 );
X	UpdateGameIcon( gptr );
X    }
X}
X
X/* !CLI */
X
XCheckAndCopy( gadstr, origstr )
X    char *gadstr, *origstr;
X{
X    char *t;
X    int i;
X
X    if( t = strchr( gadstr, '=' ) )
X    {
X	i = t - gadstr;
X	/* Check for original string and don't allow one line to be replaced with
X	 * another.
X	 */
X	if( *origstr != 0 && strncmp( gadstr, origstr, i ) != 0 )
X	{
X	    strcpy( gadstr, origstr );
X	    DisplayBeep( NULL );
X	    return( 0 );
X	}
X    }
X    else
X    {
X	/* If added an equals, there wasn't one previously, so signal an error */
X	if( t = strchr( origstr, '=' ) )
X	{
X	    strcpy( gadstr, origstr );
X	    DisplayBeep( NULL );
X	    return( 0 );
X	}
X    }
X    return( 1 );
X}
X
X/* !CLI */
X
Xint IsEditEntry( str, gptr )
X    char *str;
X    register GPTR gptr;
X{
X    if( gptr->dobj->do_Gadget.GadgetID == GADNEWGAME )
X	return( 1 );
X    if( strncmp( str, "CHARACTER=", 10 ) == 0 )
X	return( 0 );
X    return( 1 );
X}
X
X/* !CLI */
X
Xvoid menu_comment( )
X{
X    register GPTR gptr;
X    struct FileInfoBlock *finfo;
X    BPTR lock;
X    char commentstr[ 100 ];
X
X    if( ( gptr = NeedGame() ) == NULL )
X	return;
X
X    if( ( lock = Lock( GameName( gptr, NULL ), ACCESS_READ ) ) == NULL )
X    {
X	/* Can't get lock, reload and return */
X
X	errmsg( FLASH, "Can't Lock game save file: %s",
X		    GameName( gptr, NULL ) );
X	MapGadgets( R_DISK, 1 );
X	return;
X    }
X
X    finfo = (struct FileInfoBlock *) xmalloc(sizeof(struct FileInfoBlock));
X    Examine( lock, finfo );
X    UnLock( lock );
X    strncpy( commentstr, finfo->fib_Comment, sizeof( finfo->fib_Comment ) );
X    commentstr[ sizeof( finfo->fib_Comment ) ] = 0;
X    free( finfo );
X
X    /* Set the correct size */
X    if( StrRequest( "Edit Comment as Desired",
X		commentstr, commentstr ) == 0 )
X    {
X	return;
X    }
X
X    SetComment( GameName( gptr, NULL ), commentstr );
X}
X
X/* !CLI */
X
X/*
X * Make the proportional gadget position match the values passed
X */
X
Xvoid UpdatePropGad( win, gad, vis, total, top )
X    struct Window *win;
X    struct Gadget *gad;
X    register long vis, total, top;
X{
X    register long hidden;
X    register int body, pot;
X
X    hidden = max( total-vis, 0 );
X
X    if( top > hidden )
X	top = hidden;
X
X    if( hidden > 0 )
X	body = (ULONG) (vis * MAXBODY) / total;
X    else
X	body = MAXBODY;
X
X    if( hidden > 0 )
X	pot = (top * MAXPOT) / hidden;
X    else
X	pot = 0;
X
X    NewModifyProp( gad, win, NULL,
X		AUTOKNOB|FREEHORIZ, pot, 0, body, MAXBODY, 1 );
X}
X
X#endif  /* CLI */
X
X/*
X * Allocate some memory
X */
X
Xvoid *xmalloc( nbytes )
X    unsigned nbytes;
X{
X    return( malloc( nbytes ) );
X}
X
X#ifndef CLI
X/*
X * Delete the game associated with the GAME structure passed
X */
X
Xint DeleteGame( gptr )
X    register GPTR gptr;
X{
X    register int err;
X
X    err = DeleteFile( GameName( gptr, gptr->name ) );
X    err += DeleteFile( GameName( gptr, NULL ) );
X    return( err );
X}
X#endif  /* CLI */
X
X/*
X * Look through the list of games for one named 'name'
X */
X
XGPTR FindGame( name )
X    char *name;
X{
X    register GPTR gptr;
X
X    for( gptr = gamehead; gptr; gptr = gptr->next )
X    {
X	if( stricmp( gptr->fname, name ) == 0 )
X	    break;
X    }
X
X    return( gptr );
X}
X/*
X * Set the option string indicated by idx to 'str'
X */
X
Xvoid setoneopt( idx, str )
X    int idx;
X    char *str;
X{
X    /* This space accumulates, but is recovered at process exit */
X
X    options[ idx ] = strdup( str );
X}
X
X/*
X * Get just the directory name of str
X */
X
Xchar *dirname( str )
X    char *str;
X{
X    static char buf[ 300 ];
X    char *t;
X
X    strncpy( buf, str, sizeof( buf ) );
X    buf[ sizeof( buf ) - 1 ] = 0;
X
X    if( (t = strrchr( buf, '/' ) ) == NULL ||
X		(t = strrchr( buf, ':' ) ) == NULL )
X    {
X	return( "/" );
X    }
X    *t = 0;
X    return( buf );
X}
X
X#ifndef CLI
X
X/*
X * Make sure that only itemno is checked in 'menu' off of menuptr
X */
X
Xvoid CheckOnly( menuptr, menu, itemno )
X    register struct Menu *menuptr;
X    register int menu, itemno;
X{
X    register struct MenuItem *ip;
X
X    while( menuptr && menu-- )
X	menuptr = menuptr->NextMenu;
X
X    if( menuptr )
X    {
X	for( ip = menuptr->FirstItem; ip && itemno; itemno--)
X	{
X	    ip->Flags &= ~CHECKED;
X	    ip = ip->NextItem;
X	}
X
X	if( ip )
X	{
X	    ip->Flags |= CHECKED;
X	    ip = ip->NextItem;
X	}
X
X	while( ip )
X	{
X	    ip->Flags &= ~CHECKED;
X	    ip = ip->NextItem;
X	}
X    }
X}
X
X/* !CLI */
X
Xint FindChecked( menuptr, menu )
X    register struct Menu *menuptr;
X    register int menu;
X{
X    register int itemno;
X    register struct MenuItem *ip;
X
X    while( menuptr && menu-- )
X	menuptr = menuptr->NextMenu;
X
X    if( menuptr )
X    {
X	for( itemno = 0, ip = menuptr->FirstItem; ip; ip = ip->NextItem )
X	{
X	    if( ip->Flags & CHECKED )
X		return( itemno );
X	    ++itemno;
X	}
X    }
X    return( 0 );
X}
X
X/* !CLI */
X
X/*
X * Create a file name based in the GAMEs directory.  If file is NULL,
X * the file name is the icon file.  Otherwise it is 'file'.
X */
X
Xchar *GameName( gptr, file )
X    GPTR gptr;
X    char *file;
X{
X    static char buf[200];
X
X    if( file == NULL )
X	file = gptr->fname;
X
X    if( strchr( "/:", gptr->dname[ strlen( gptr->dname ) - 1 ] ) )
X	sprintf( buf, "%s%s", gptr->dname, file );
X    else
X	sprintf( buf, "%s/%s", gptr->dname, file );
X    return( buf );
X}
X
X#endif  /* CLI */
X
X/*
X * Allocate a new GAME structure for the file passed and fill it in
X */
X
XGPTR GetWBIcon( lock, dir, finfo )
X    register BPTR lock;
X    register char *dir;
X    register struct FileInfoBlock *finfo;
X{
X    register BPTR odir;
X    register char *t;
X    register GPTR gptr;
X
X    if( ( gptr = AllocGITEM( ) ) == NULL )
X	goto noitems;
X
X    if( ( gptr->dname = strdup( dir ) ) == NULL )
X	goto outofmem;
X
X    if( ( gptr->fname = strdup( finfo->fib_FileName ) ) == NULL )
X	goto outofmem;
X
X    /* Strip the .info off. */
X    if( t = strrchr( finfo->fib_FileName, '.' ) )
X    {
X	if( stricmp( t, ".info" ) == 0 )
X	    *t = 0;
X	else
X	    t = NULL;
X    }
X
X    if( ( gptr->name = strdup( finfo->fib_FileName ) ) == NULL )
X	goto outofmem;
X
X    /* If removed .info, put it back */
X
X    if( t )
X	*t = '.';
X
X    /* Change to saved game directory */
X
X    odir = CurrentDir( lock );
X
X    /* Allocate a diskobj structure */
X
X    if( ( gptr->dobj = AllocDObj( finfo->fib_FileName ) ) == NULL )
X    {
X	(void) CurrentDir( odir );
Xoutofmem:
X	FreeGITEM( gptr );
X
X	if( gptr->fname )
X	    free( gptr->fname );
X	gptr->fname = NULL;
X
X	if( gptr->name )
X	    free( gptr->name );
X	gptr->name = NULL;
X
X	if( gptr->dname )
X	    free( gptr->dname );
X	gptr->dname = NULL;
X
Xnoitems:
X	errmsg( FLASH, "Can't get Disk Object: %s", finfo->fib_FileName );
X	return( NULL );
X    }
X    gptr->oflag = gptr->dobj->do_Gadget.Flags;
X    gptr->oact = gptr->dobj->do_Gadget.Activation;
X    gptr->dobj->do_Gadget.Activation |=
X	    ( RELVERIFY | GADGIMMEDIATE | FOLLOWMOUSE );
X    gptr->dobj->do_Gadget.Flags &= ~(GADGHIGHBITS);
X    gptr->dobj->do_Gadget.Flags |= GADGHNONE;
X
X    /* Make sure gptr->dobj->do_ToolTypes is not NULL */
X    ReallocTools( gptr, 0 );
X
X    (void) CurrentDir( odir );
X    return( gptr );
X}
X
X#ifndef CLI
X
X/*
X * Put a 3-D motif border around the gadget.  String gadgets or those
X * which do not have highlighting are rendered down.  Boolean gadgets
X * are rendered in the up position by default.
X */
X
Xvoid SetBorder( gd, val )
X    register struct Gadget *gd;
X    int val;
X{
X    register struct Border *bp;
X    register short *sp;
X    register int i;
X    int borders = 6;
X
X    /* Allocate two border structures one for up image and one for down
X     * image, plus vector arrays for the border lines.
X     */
X
X    if( gd->GadgetType == STRGADGET )
X	borders = 12;
X
X    if( ( bp = xmalloc( ( ( sizeof( struct Border ) * 2 ) +
X	    ( sizeof( short ) * borders ) ) * 2 ) ) == NULL )
X    {
X	return;
X    }
X
X    /* Remove any special rendering flags to avoid confusing intuition
X     */
X
X    gd->Flags &= ~(GADGHIGHBITS|GADGIMAGE|GRELWIDTH|
X		    GRELHEIGHT|GRELRIGHT|GRELBOTTOM);
X
X    sp = (short *)(bp + 4);
X    if( val == 0 || val == 2 ||
X	gd->GadgetType == STRGADGET || ( gd->GadgetType == BOOLGADGET &&
X		( gd->Flags & GADGHIGHBITS ) == GADGHNONE ) )
X    {
X	/* For a string gadget, we expand the border beyond the area where
X	 * the text will be entered.
X	 */
X
X	sp[0] = -1;
X	sp[1] = gd->Height - 1;
X	sp[2] = -1;
X	sp[3] = -1;
X	sp[4] = gd->Width - 1;
X	sp[5] = -1;
X
X	sp[6] = gd->Width + 1;
X	sp[7] = -2;
X	sp[8] = gd->Width + 1;
X	sp[9] = gd->Height + 1;
X	sp[10] = -2;
X	sp[11] = gd->Height + 1;
X
X	sp[12] = -2;
X	sp[13] = gd->Height;
X	sp[14] = -2;
X	sp[15] = -2;
X	sp[16] = gd->Width;
X	sp[17] = -2;
X	sp[18] = gd->Width;
X	sp[19] = gd->Height;
X	sp[20] = -2;
X	sp[21] = gd->Height;
X
X	for( i = 0; i < 3; ++i )
X	{
X	    bp[ i ].LeftEdge = bp[ i ].TopEdge = -1;
X	    if( val == 2 )
X		bp[ i ].FrontPen = ( i == 0 || i == 1 ) ? C_WHITE : C_BLACK;
X	    else
X		bp[ i ].FrontPen = ( i == 0 || i == 1 ) ? C_BLACK : C_WHITE;
X
X	    /* Have to use JAM2 so that the old colors disappear. */
X	    bp[ i ].BackPen = C_GREY;
X	    bp[ i ].DrawMode = JAM2;
X	    bp[ i ].Count = ( i == 0 || i == 1 ) ? 3 : 5;
X	    bp[ i ].XY = &sp[ i*6 ];
X	    bp[ i ].NextBorder = ( i == 2 ) ? NULL : &bp[ i + 1 ];
X	}
X
X	/* Set the up image */
X	gd->GadgetRender = (APTR) bp;
X
X	/* Same image for select image */
X	gd->SelectRender = (APTR) bp;
X
X	gd->LeftEdge++;
X	gd->TopEdge++;
X	gd->Flags |= GADGHCOMP;
X    }
X    else
X    {
X	/* Create the border vector values for up and left side, and
X	 * also the lower and right side.
X	 */
X
X	sp[0] = 0;
X	sp[1] = gd->Height;
X	sp[2] = 0;
X	sp[3] = 0;
X	sp[4] = gd->Width;
X	sp[5] = 0;
X
X	sp[6] = gd->Width;
X	sp[7] = 0;
X	sp[8] = gd->Width;
X	sp[9] = gd->Height;
X	sp[10] = 0;
X	sp[11] = gd->Height;
X
X	/* We are creating 4 sets of borders, the two sides of the
X	 * rectangle share the border vectors with the opposite image,
X	 * but specify different colors.
X	 */
X
X	for( i = 0; i < 4; ++i )
X	{
X	    bp[ i ].TopEdge = bp[ i ].LeftEdge = 0;
X
X	    /* A GADGHNONE is always down */
X
X	    if( val != 3 && gd->GadgetType == BOOLGADGET &&
X		( gd->Flags & GADGHIGHBITS ) != GADGHNONE )
X	    {
X		bp[ i ].FrontPen =
X		    ( i == 1 || i == 2 ) ? C_BLACK : C_WHITE;
X	    }
X	    else
X	    {
X		bp[ i ].FrontPen =
X		    ( i == 1 || i == 3 ) ? C_WHITE : C_BLACK;
X	    }
X
X	    /* Have to use JAM2 so that the old colors disappear. */
X	    bp[ i ].BackPen = C_GREY;
X	    bp[ i ].DrawMode = JAM2;
X	    bp[ i ].Count = 3;
X	    bp[ i ].XY = &sp[ 6 * ((i &1) != 0) ];
X	    bp[ i ].NextBorder =
X		( i == 1 || i == 3 ) ? NULL : &bp[ i + 1 ];
X	}
X
X	/* bp[0] and bp[1] two pieces for the up image */
X	gd->GadgetRender = (APTR) bp;
X
X	/* bp[2] and bp[3] two pieces for the down image */
X	gd->SelectRender = (APTR) (bp + 2);
X	gd->Flags |= GADGHIMAGE;
X    }
X}
X
X/* !CLI */
X
Xstruct Gadget *FindGadget( window, newwindow, id )
X    struct Window *window;
X    struct NewWindow *newwindow;
X    int id;
X{
X    struct Gadget *gd = NULL;
X
X    if( window )
X	gd = window->FirstGadget;
X    else if( newwindow )
X	gd = newwindow->FirstGadget;
X
X    while( gd )
X    {
X	if( gd->GadgetID == id )
X	    break;
X	gd = gd->NextGadget;
X    }
X
X    return( gd );
X}
X
X#endif  /* CLI */
X
X/*
X * Clear all previous values from passed options array
X */
Xvoid ZapOptions( optr )
X    OPTR optr;
X{
X    int i;
X
X    for( i = 0; optr[ i ].name; ++i )
X    {
X	if( optr[i].optstr )
X	{
X	    if( *optr[i].optstr )
X	    {
X		free( optr[i].optstr );
X		optr[i].optstr = "";
X	    }
X	}
X	else
X	{
X	    optr[i].optval = optr[i].defval;
X	}
X    }
X}
X
X#ifndef CLI
X
X/*
X * Copy Options from GAMES OPTIONS= tooltypes element to the gadgets
X */
Xvoid CopyOptions( optr, gptr )
X    OPTR optr;
X    GPTR gptr;
X{
X    char **sp;
X
X    for( sp = gptr->dobj->do_ToolTypes; *sp; ++sp )
X    {
X	if( strnicmp( *sp, "options=", 8 ) == 0 )
X	{
X	    break;
X	}
X    }
X
X    if( *sp == NULL )
X    {
X	errmsg( NO_FLASH, "Options not set for %s", gptr->name );
X	return;
X    }
X
X    CopyOptionStr( optr, *sp + 8 );
X}
X
X/* !CLI */
X
Xvoid CopyOptionStr( optr, str )
X    OPTR optr;
X    char *str;
X{
X    char *s, *t, buf[ 100 ];
X    int i, sidx, state = 0;
X    int done = 0;
X
X    ZapOptions( optr );
X    s = buf;
X    *buf = 0;
X    sidx = -1;
X
X    /* Start past the 'options=' part */
X    for( t = str; !done; ++t )
X    {
X	if( state == 0 && isspace( *t ) )
X	    continue;
X
X	/* If at end remember so... */
X	if( !*t )
X	    done = 1;
X
X	/* If looking for an option value */
X	if( state == 0 )
X	{
X	    /* If found string value... */
X	    if( *t == ':' )
X	    {
X		*s = 0;
X		state = 1;
X		sidx = -1;
X
X		/* Look for the particular named option */
X		for( i = 0; optr[i].name; ++i )
X		{
X		    if( stricmp( optr[i].name, buf ) == 0 )
X		    {
X			sidx = i;
X			break;
X		    }
X		}
X
X		/* Set buffer pointer */
X		*(s = buf) = 0;
X
X		if( sidx == -1 )
X		{
X		    errmsg( FLASH, "Invalid option name %s", buf );
X		    return;
X		}
X		if( !optr[i].optstr )
X		{
X		    errmsg( FLASH, "%s is not a string option", buf );
X		    return;
X		}
X		continue;
X	    }
X	}
X
X	/* If at end of string or comma and we have some text... */
X	if( !*t || *t == ',' && *buf )
X	{
X	    /* Mark end */
X	    *s = 0;
X
X	    /* If have collected string option value... */
X	    if( sidx != -1 )
X	    {
X		/* Free old string */
X		if( optr[sidx].optstr )
X		{
X		    if( *optr[sidx].optstr )
X			free( optr[sidx].optstr );
X		}
X
X		/* Store new string */
X		if( *buf )
X		    optr[sidx].optstr = strdup( buf );
X		else
X		    optr[sidx].optstr = "";
X		sidx = -1;
X	    }
X	    else
X	    {
X		/* Look for boolean option */
X		for( i = 0; optr[i].name; ++i )
X		{
X		    if( *buf == '!' )
X		    {
X			if( stricmp( optr[i].name, buf + 1 ) == 0 )
X			    break;
X		    }
X		    else
X		    {
X			if( stricmp( optr[i].name, buf ) == 0 )
X			    break;
X		    }
X		}
X
X		if( optr[i].name )
X		{
X		    optr[i].optval = *buf != '!';
X		}
X		else
X		{
X		    errmsg( FLASH, "Unrecognized option %s", buf );
X		    return;
X		}
X	    }
X	    *(s = buf) = 0;
X	    state = 0;
X	}
X	else
X	{
X	    if( *t == ',' )
X		*(s = buf) = 0;
X	    else
X		*s++ = *t;
X	}
X    }
X}
X
X/* !CLI */
X
X/*
X *  Set the GAMES OPTIONS tooltypes to the data in the Options windows
X *  gadgetry.
X */
Xvoid SetOptions( optr, gptr )
X    register OPTR optr;
X    register GPTR gptr;
X{
X    PutOptions( optr );
X    SetToolLine( gptr, "OPTIONS", options[ OPTIONS_IDX ] );
X    UpdateGameIcon( gptr );
X}
X
Xvoid
XUpdateGameIcon( gptr )
X    register GPTR gptr;
X{
X    register long lock;
X
X    if( lock = Lock( gptr->dname, ACCESS_READ ) )
X    {
X	/* Write out the DiskObject */
X
X	WriteDObj( gptr, lock );
X	UnLock( lock );
X    }
X    else
X    {
X	errmsg( FLASH, "Can't change directory to %s", gptr->dname );
X    }
X}
X
X#endif  /* CLI */
X
Xchar *ToolsEntry( gptr, name )
X    GPTR gptr;
X    char *name;
X{
X    char *str;
X
X    if( ! ( str = FindToolType( (char **) gptr->dobj->do_ToolTypes, name ) ) )
X	str = "";
X
X    return( str );
X}
X
X/* Reallocate the toolstype information into dynamic memory so that some
X * parts of it can be easily changed, but we can still do "FreeDiskObject"
X * later to clean up whatever "GetDiskObject" allocated.
X */
Xvoid ReallocTools( gptr, add )
X    GPTR gptr;
X    int add;
X{
X    int i, cnt;
X    char **sp, **tp;
X
X    for( cnt = 0, tp = gptr->dobj->do_ToolTypes; tp && *tp ; ++tp )
X	++cnt;
X
X    if( !tp )
X    {
X	/* If no tooltypes array, fudge something to start with */
X	if( sp = xmalloc( 2 * sizeof( char * ) ) )
X	{
X	    sp[0] = strdup("HACKDIR=NetHack:");
X	    sp[1] = NULL;
X	}
X    }
X    else if( sp = xmalloc( (cnt+1+add) * sizeof( char * ) ) )
X    {
X	for( i = 0, tp = gptr->dobj->do_ToolTypes;
X		    tp && *tp && i < cnt; ++tp )
X	{
X	    sp[i++] = strdup( *tp );
X	}
X
X	sp[i] = NULL;
X    }
X    gptr->otools = gptr->dobj->do_ToolTypes;
X    gptr->dobj->do_ToolTypes = sp;
X    gptr->toolcnt = cnt + 1;
X    gptr->talloc = 1;
X}
X
Xvoid FreeTools( gptr )
X    GPTR gptr;
X{
X    int i;
X    char **sp;
X
X    if( !gptr->talloc )
X	return;
X
X    for( i = 0, sp = gptr->dobj->do_ToolTypes; sp[i]; ++i )
X    {
X	free( sp[ i ] );
X	sp[ i ] = NULL;
X    }
X    free( sp );
X    gptr->dobj->do_ToolTypes = gptr->otools;
X    gptr->talloc = 0;
X}
X
Xvoid SetToolLine( gptr, name, value )
X    GPTR gptr;
X    char *name, *value;
X{
X    char **sp, **osp;
X    int i, len;
X
X    /* Realloc ToolTypes to be in memory we know how to manage */
X
X    if( gptr->talloc == 0 )
X	ReallocTools( gptr, 0 );
X
X    sp = gptr->dobj->do_ToolTypes;
X    len = strlen( name );
X
X    /* Find any previous definition */
X    for( i = 0; sp[i] && i < gptr->toolcnt - 1; ++i )
X    {
X	if( strnicmp( name, sp[i], len ) == 0 && sp[i][len] == '=' )
X	    break;
X    }
X
X    /* Free up the space, or allocate new space if not there */
X    if( sp[ i ] )
X	free( sp[ i ] );
X    else
X    {
X	/* Check for need to realloc */
X
X	if( i >= gptr->toolcnt - 1 )
X	{
X	    int j=i;
X	    osp = sp;
X	    sp = xmalloc( ( i + 2 ) * sizeof( char * ) );
X	    gptr->toolcnt = i + 2;
X	    sp[ i + 1 ] = NULL;
X	    while( j >= 0 )
X	    {
X		sp[ j ] = osp[ j ];
X		--j;
X	    }
X	    free( osp );
X	    /* i = gptr->toolcnt - 1; */
X	    gptr->dobj->do_ToolTypes = sp;
X	}
X	else
X	{
X	    sp[ i + 1 ] = NULL;
X	}
X    }
X
X    /* Set the string */
X
X    if( sp[ i ] = xmalloc( strlen (value) + strlen( name ) + 2 ) )
X	sprintf( sp[i], "%s=%s", name, value );
X    else
X    {
X	sp[ i ] = NULL;     /* redundant */
X	errmsg( FLASH, "Could not allocate string for value" );
X    }
X}
X
Xvoid WriteDObj( gptr, lock )
X    register GPTR gptr;
X    long lock;
X{
X    register long odir;
X    long flag, act;
X
X    /* Don't write gadget out as selected */
X
X    flag = gptr->dobj->do_Gadget.Flags;
X    act = gptr->dobj->do_Gadget.Activation;
X    gptr->dobj->do_Gadget.Flags = gptr->oflag;
X    gptr->dobj->do_Gadget.Activation = gptr->oact;
X    odir = CurrentDir( lock );
X
X    if( PutDiskObject( gptr->name, gptr->dobj ) == 0 )
X	errmsg( FLASH, "Could not write disk object values" );
X
X    gptr->dobj->do_Gadget.Flags = flag;
X    gptr->dobj->do_Gadget.Activation = act;
X
X    if( odir )
X	(void) CurrentDir( odir );
X}
X
Xchar *Strdup( str )
X    char *str;
X{
X    char *t;
X
X    if( t = AllocMem( strlen( str ) + 1, MEMF_PUBLIC ) )
X	strcpy( t, str );
X    return( t );
X}
X
X#ifdef CLI
X
Xchar *
Xeos(s)
X    char *s;
X{
X    while(*s)s++;
X    return s;
X}
X
X/* CLI */
X
Xvoid
Xcondaddslash(s)
X    char *s;
X{
X    s=eos(s);
X    switch(s[-1]){
X    case ':':
X    case '/':
X	break;
X    default:
X	s[0]='/';
X	s[1]='\0';
X	break;
X    }
X    return;
X}
X
X/* CLI */
X
X#if 0
X/* for debug only */
X#define BP __builtin_printf
Xdumptools(sp,i)
X    char **sp;
X    int i;
X{
X    int x;
X    BP("Dumptools: cnt=%d\n",i);
X    for(x=0;sp[x];x++)
X	BP("%d: '%s'\n",x,sp[x]);
X}
X#endif
X
X#else   /* CLI */
X
Xvoid ClearDelGames()
X{
X    register GPTR gptr, pgptr = NULL;
X
X    for( gptr = gamehead; gptr; )
X    {
X	/* Skip New Game */
X
X	if( gptr->fname == NULL )
X	{
X	    gptr = gptr->next;
X	    continue;
X	}
X
X	/* If gone, then remove structures */
X
X	if( access( GameName( gptr, NULL ), 0 ) == -1 )
X	{
X	    if( pgptr )
X		pgptr->next = gptr->next;
X	    else
X		gamehead = gptr->next;
X
X	    FreeGITEM( gptr );
X	    gptr = pgptr ? pgptr : gamehead;
X	}
X	else
X	{
X	    pgptr = gptr;
X	    gptr = gptr->next;
X	}
X    }
X}
X
X/* !CLI */
X
Xstruct TagItem tags[] =
X{
X    TAG_DONE, 0l,
X};
X
Xstruct Window *
XMyOpenWindow( nw )
X#ifdef  INTUI_NEW_LOOK
X    struct ExtNewWindow *nw;
X#else
X    struct NewWindow *nw;
X#endif
X{
X#ifdef  INTUI_NEW_LOOK
X    /*nw->Extension = tags;
X    nw->Flags = WFLG_NW_EXTENDED;*/
X#endif
X#undef  NewWindow
X    return( OpenWindow( (struct NewWindow *) nw ) );
X}
X
X#endif  /* CLI */
X
Xvoid
Xdiskobj_filter( dobj )
X    struct DiskObject *dobj;
X{
X    char **ta=dobj->do_ToolTypes;
X    int x;
X
X    /* if nothing there, just return. */
X    if( !ta )
X    	return;
X
X#ifdef CLI
X	/* kill everything except INTERNALCLI */
X
X    for(x=0;ta[x];x++){
X	if(!strncmp(ta[x],"INTERNALCLI=",12)){
X	    ta[0]=ta[x];
X	    ta[1]=0;
X	    return;
X	}
X    }
X    ta[0]=0;
X#else
X	/* kill INTERNALCLI */
X    for(x=0;ta[x];x++){
X        int offset=0;
X	while(ta[x+offset] && !strncmp(ta[x+offset],"INTERNALCLI=",12)){
X	    offset++;
X        }
X        ta[x]=ta[x+offset];
X    }
X#endif
X}
END_OF_FILE
if test 38406 -ne `wc -c <'sys/amiga/wbcli.c'`; then
    echo shar: \"'sys/amiga/wbcli.c'\" unpacked with wrong size!
fi
# end of 'sys/amiga/wbcli.c'
fi
if test -f 'sys/msdos/trampoli.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/msdos/trampoli.c'\"
else
echo shar: Extracting \"'sys/msdos/trampoli.c'\" \(15116 characters\)
sed "s/^X//" >'sys/msdos/trampoli.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)trampoli.c 	3.1	93/01/18	  */
X/* Copyright (c) 1989 - 1993 by Norm Meluch and Stephen Spackman  */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include "hack.h"
X
X/****************************************************************************/
X/*									    */
X/*	This file contains a series of definitions of "one liner"	    */
X/*	functions corresponding to *all* functions that NetHack calls	    */
X/*	via pointers.							    */
X/*	     IF ANY CALLS TO FUNCTIONS VIA POINTERS ARE ADDED		    */
X/*	     TO THE CODE, AN ENTRY FOR THE FUNCTION CALLED MUST		    */
X/*	     BE ADDED TO THIS FILE AND TO TRAMPOLI.H.			    */
X/*	This mess is necessary for the Microsoft Compiler implementation    */
X/*	of overlaid code (v5.1 - 6.0ax).				    */
X/*									    */
X/*	The original function (eg foo) has been #defined to be foo_	    */
X/*	via double inclusion of trampoli.h in hack.h, and		    */
X/*	now the definition of foo is placed in this file calling foo	    */
X/*	directly.  This module is _never_ placed in an overlay so	    */
X/*	calls via pointers to these functions will not cause difficulties.  */
X/*									    */
X/*	This leads to what could be called a "trampoline" effect, and	    */
X/*	hence the silly name for these files. :-)			    */
X/*									    */
X/****************************************************************************/
X
X#ifdef OVERLAY
X
X/* ### apply.c ### */
X#undef dig
X#undef doapply
X#undef dojump
X#undef dorub
X
Xint dig()     { return dig_();     }
Xint doapply() { return doapply_(); }
Xint dojump()  { return dojump_();  }
Xint dorub()   { return dorub_();   }
X
X
X/* ### cmd.c ### */
X#undef doextcmd
X#undef doextlist
X#undef doprev_message
X
X#ifdef POLYSELF
X#undef domonability
X#endif /* POLYSELF */
X
X#ifdef EXPLORE_MODE
X#undef enter_explore_mode
X
Xint enter_explore_mode() { return enter_explore_mode_(); }
X#endif
X
X#undef timed_occupation
X
X#if defined(WIZARD) || defined(EXPLORE_MODE)
X#undef wiz_attributes
X#endif
X
X#ifdef WIZARD
X#undef wiz_detect
X#undef wiz_genesis
X#undef wiz_identify
X#undef wiz_level_tele
X#undef wiz_map
X#undef wiz_where
X#undef wiz_wish
X#endif
X
Xint doextcmd()         { return doextcmd_();         }
Xint doextlist()        { return doextlist_();        }
Xint doprev_message()   { return doprev_message_();   }
X
X#ifdef POLYSELF
Xint domonability()     { return domonability_();     }
X#endif /* POLYSELF */
X
Xint timed_occupation() { return timed_occupation_(); }
X
X#if defined(WIZARD) || defined(EXPLORE_MODE)
Xint wiz_attributes()   { return wiz_attributes_();   }
X#endif
X
X#ifdef WIZARD
Xint wiz_detect()       { return wiz_detect_();       }
Xint wiz_genesis()      { return wiz_genesis_();      }
Xint wiz_identify()     { return wiz_identify_();     }
Xint wiz_level_tele()   { return wiz_level_tele_();   }
Xint wiz_map()          { return wiz_map_();          }
Xint wiz_where()        { return wiz_where_();        }
Xint wiz_wish()         { return wiz_wish_();         }
X#endif
X
X
X/* ### do.c ### */
X#undef doddrop
X#undef dodown
X#undef dodrop
X#undef donull
X#undef doup
X#undef dowipe
X#undef drop
X#undef wipeoff
X
Xint doddrop()             { return doddrop_(); }
Xint dodown()              { return dodown_();  }
Xint dodrop()              { return dodrop_();  }
Xint donull()              { return donull_();  }
Xint doup()                { return doup_();    }
Xint dowipe()              { return dowipe_();  }
Xint drop(obj)
Xregister struct obj *obj; { return drop_(obj); }
Xint wipeoff()             { return wipeoff_(); }
X
X
X/* ### do_name.c ### */
X#undef ddocall
X#undef do_mname
X
Xint ddocall()  { return ddocall_();  }
Xint do_mname() { return do_mname_(); } 
X
X
X/* ### do_wear.c ### */
X#undef Armor_off
X#undef Boots_off
X#undef Gloves_off
X#undef Helmet_off
X#undef Armor_on
X#undef Boots_on
X#undef Gloves_on
X#undef Helmet_on
X#undef doddoremarm
X#undef doputon
X#undef doremring
X#undef dotakeoff
X#undef dowear
X#undef select_off
X#undef take_off
X
Xint Armor_off()   { return Armor_off_();   }
Xint Boots_off()   { return Boots_off_();   }
Xint Gloves_off()  { return Gloves_off_();  }
Xint Helmet_off()  { return Helmet_off_();  }
Xint Armor_on()    { return Armor_on_();    }
Xint Boots_on()    { return Boots_on_();    }
Xint Gloves_on()   { return Gloves_on_();   }
Xint Helmet_on()   { return Helmet_on_();   }
Xint doddoremarm() { return doddoremarm_(); }
Xint doputon()     { return doputon_();     }
Xint doremring()   { return doremring_();   }
Xint dotakeoff()   { return dotakeoff_();   }
Xint dowear()      { return dowear_();      }
Xint select_off(otmp) struct obj *otmp; { return select_off_(otmp); }
Xint take_off()    { return take_off_();    }
X
X
X/* ### dogmove ### */
X#undef wantdoor
X
Xvoid wantdoor(x, y, dummy)
Xint x, y; genericptr_t dummy; { return wantdoor_(x, y, dummy); }
X
X
X/* ### dokick.c ### */
X#undef dokick
X
Xint dokick() { return dokick_(); }
X
X
X/* ### dothrow.c ### */
X#undef dothrow
X
Xint dothrow() { return dothrow_(); }
X
X
X/* ### eat.c ### */
X#undef Hear_again
X#undef eatmdone
X#undef doeat
X#undef eatfood
X#undef opentin
X#undef unfaint
X
Xint Hear_again()  { return Hear_again_(); }
Xint eatmdone()    { return eatmdone_();   }
Xint doeat()       { return doeat_();      }
Xint eatfood()     { return eatfood_();    }
Xint opentin()     { return opentin_();    }
Xint unfaint()     { return unfaint_();    }
X
X
X/* ### end.c ### */
X#undef done1
X#undef done2
X#undef hangup
X#undef done_intr
X
X#if defined(UNIX) || defined(VMS)
X#undef done_hangup
X#endif /* UNIX || VMS */
X
Xint done1()     { return done1_();     }
Xint done2()     { return done2_();     }
Xint hangup()    { return hangup_();    }
Xint done_intr() { return done_intr_(); }
X
X#if defined(UNIX) || defined(VMS)
Xint done_hangup() { return done_hangup_(); }
X#endif /* UNIX || VMS */
X
X
X/* ### engrave.c ### */
X#undef doengrave
X
Xint doengrave() { return doengrave_(); }
X
X
X/* ### fountain.c ### */
X#undef gush
X
Xvoid gush(x, y, poolcnt)
Xint x, y; genericptr_t poolcnt; { return gush_(x, y, poolcnt); }
X
X
X/* ### hack.c ### */
X#undef dopickup
X#undef identify
X
Xint dopickup() { return dopickup_(); }
Xint identify(otmp) struct obj *otmp; { return identify_(otmp); }
X
X
X/* ### invent.c ### */
X#undef ckunpaid
X#undef ddoinv
X#undef dolook
X#undef dopramulet
X#undef doprarm
X#undef doprgold
X#undef doprring
X#undef doprtool
X#undef doprwep
X#undef dotypeinv
X#undef doorganize
X
Xint ckunpaid(obj) struct obj *obj; { return ckunpaid_(obj); }
Xint ddoinv()     { return ddoinv_();     }
Xint dolook()     { return dolook_();     }
Xint dopramulet() { return dopramulet_(); }
Xint doprarm()    { return doprarm_();    }
Xint doprgold()   { return doprgold_();   }
Xint doprring()   { return doprring_();   }
Xint doprtool()   { return doprtool_();   }
Xint doprwep()    { return doprwep_();    }
Xint dotypeinv()  { return dotypeinv_();  }
Xint doorganize() { return doorganize_(); }
X
X
X/* ### ioctl.c ### */
X#ifdef UNIX
X# ifdef SUSPEND
X#undef dosuspend
X
Xint dosuspend() { return dosuspend_(); }
X# endif /* SUSPEND */
X#endif /* UNIX */
X
X
X/* ### lock.c ### */
X#undef doclose
X#undef doforce
X#undef doopen
X#undef forcelock
X#undef picklock
X
Xint doclose()   { return doclose_();   }
Xint doforce()   { return doforce_();   }
Xint doopen()    { return doopen_();    }
Xint forcelock() { return forcelock_(); }
Xint picklock()  { return picklock_();  }
X
X
X/* ### mklev.c ### */
X#undef do_comp
X
Xint do_comp(vx, vy) genericptr_t vx, vy;  { return comp_(vx, vy); }
X
X
X/* ### mondata.c ### */
X/* canseemon() is only called by a macro e_boolean.  If e_boolean ever does
X   become a function, this may need to return. */
X
X/* #undef canseemon */
X
X/* boolean canseemon(x) struct monst *x; { return canseemon_(x); } */
X
X
X/* ### muse.c ### */
X#undef mbhitm
X
Xint mbhitm(mtmp, otmp) struct monst *mtmp; struct obj *otmp;
X	{ return mbhitm_(mtmp, otmp); }
X
X
X/* ### o_init.c ### */
X#undef dodiscovered
X
Xint dodiscovered() { return dodiscovered_(); }
X
X
X/* ### objnam.c ### */
X#undef doname
X#undef xname
X
Xchar *doname(obj) struct obj *obj; { return doname_(obj); }
Xchar *xname(obj)  struct obj *obj; { return xname_(obj); }
X
X
X/* ### options.c ### */
X#undef doset
X#undef dotogglepickup
X
Xint doset()          { return doset_();         }
Xint dotogglepickup() { return dotogglepickup_(); }
X
X
X/* ### pager.c ### */
X#undef dohelp
X#undef dohistory
X#undef dowhatdoes
X#undef dowhatis
X#undef doquickwhatis
X
Xint dohelp()        { return dohelp_();        }
Xint dohistory()     { return dohistory_();     }
Xint dowhatdoes()    { return dowhatdoes_();    }
Xint dowhatis()      { return dowhatis_();      }
Xint doquickwhatis() { return doquickwhatis_(); }
X
X
X/* ### pcsys.c ### */
X#ifdef SHELL
X#undef dosh
X
Xint dosh()          { return dosh_();          }
X#endif /* SHELL */
X
X
X/* ### pickup.c ### */
X#undef ck_bag
X#undef doloot
X#undef in_container
X#undef out_container
X
Xint ck_bag(obj) struct obj *obj; { return ck_bag_(obj);  }
Xint doloot() { return doloot_(); }
Xint in_container(obj)  struct obj *obj; { return in_container_(obj); }
Xint out_container(obj) struct obj *obj; { return out_container_(obj); }
X
X
X/* ### potion.c ### */
X#undef dodrink
X#undef dodip
X
Xint dodrink() { return dodrink_(); }
Xint dodip()   { return dodip_();   }
X
X
X/* ### pray.c ### */
X#undef doturn
X#undef dopray
X#undef prayer_done
X#undef dosacrifice
X
Xint doturn()      { return doturn_();      }
Xint dopray()      { return dopray_();      }
Xint prayer_done() { return prayer_done_(); }
Xint dosacrifice() { return dosacrifice_(); }
X
X
X/* ### print.c ### */
X#undef doredraw
X
Xint doredraw()    { return doredraw_(); }
X
X
X/* ### read.c ### */
X#undef doread
X#undef set_lit
X
Xint doread()		    { return doread_(); }
Xvoid set_lit(x, y, val)
Xint x, y; genericptr_t val; { return set_lit_(x, y, val); }
X
X
X/* ### save.c ### */
X#undef dosave
X
Xint dosave() { return dosave_(); }
X
X
X/* ### search.c ### */
X#undef findone
X#undef openone
X#undef doidtrap
X#undef dosearch
X
Xvoid findone(zx, zy, num)
Xint zx, zy; genericptr_t num; { return findone_(zx, zy, num); }
Xvoid openone(zx, zy, num)
Xint zx, zy; genericptr_t num; { return openone_(zx, zy, num); }
Xint doidtrap()		      { return doidtrap_(); }
Xint dosearch()		      { return dosearch_(); }
X
X
X/* ### shk.c ### */
X#undef dopay
X
Xint dopay() { return dopay_(); }
X
X
X/* ### sit.c ### */
X#undef dosit
X
Xint dosit() { return dosit_(); }
X
X
X/* ### sounds.c ### */
X#undef dotalk
X
Xint dotalk() { return dotalk_(); }
X
X
X/* ### spell.c ### */
X#undef learn
X#undef docast
X#undef dovspell
X
Xint learn() { return learn_(); }
Xint docast()   { return docast_();   }
Xint dovspell() { return dovspell_(); }
X
X
X/* ### steal.c ### */
X#undef stealarm
X
Xint stealarm() { return stealarm_(); }
X
X
X/* ### trap.c ### */
X#undef dotele
X#undef dountrap
X#undef float_down
X
Xint dotele()     { return dotele_();     }
Xint dountrap()   { return dountrap_();   }
Xint float_down() { return float_down_(); }
X
X
X/* ### version.c ### */
X#undef doversion
X#undef doextversion
X
Xint doversion()    { return doversion_();    }
Xint doextversion() { return doextversion_(); }
X
X
X/* ### wield.c ### */
X#undef dowield
X
Xint dowield() { return dowield_(); }
X
X
X/* ### zap.c ### */
X#undef bhitm
X#undef bhito
X#undef dozap
X
Xint bhitm(mtmp, otmp) struct monst *mtmp; struct obj *otmp;
X	{ return bhitm_(mtmp, otmp); }
Xint bhito(obj, otmp) struct obj *obj, *otmp; { return bhito_(obj,  otmp); }
Xint dozap() { return dozap_(); }
X
X/* 
X * Window Implementation Specific Functions.
X */
X
X
X/* ### getline.c ### */
X#undef tty_getlin
X#ifdef COM_COMPL
X#undef tty_get_ext_cmd
X
Xvoid tty_get_ext_cmd(bufp)
X  char *bufp;			{ tty_get_ext_cmd_(bufp);	}
X#endif /* COM_COMPL */
Xvoid tty_getlin(query,bufp)
X  const char *query; char *bufp;{ tty_getlin_(query,bufp);	}
X
X
X/* ### termcap.c ### */
X#undef tty_nhbell
X#undef tty_number_pad
X#undef tty_delay_output
X#undef tty_start_screen
X#undef tty_end_screen
X
Xvoid tty_nhbell()		{ tty_nhbell_(); 		}
Xvoid tty_number_pad(state)
X  int state;			{ tty_number_pad_(state);	}
Xvoid tty_delay_output()		{ tty_delay_output_(); 		}
X/* other defs that really should go away (they're tty specific) */
Xvoid tty_start_screen()		{ tty_start_screen_(); 		}
Xvoid tty_end_screen()		{ tty_end_screen_(); 		}
X
X
X/* ### topl.c ### */
X#undef tty_doprev_message
X#undef tty_yn_function
X
Xint tty_doprev_message()	{ tty_doprev_message_(); 	}
Xchar tty_yn_function(query,resp,def)
X  const char *query, *resp; char def;
X				{ tty_yn_function_(query,resp,def); }
X
X
X/* ### wintty.c ### */
X#undef tty_init_nhwindows
X#undef tty_player_selection
X#undef tty_askname
X#undef tty_get_nh_event
X#undef tty_exit_nhwindows
X#undef tty_suspend_nhwindows
X#undef tty_resume_nhwindows
X#undef tty_create_nhwindow
X#undef tty_clear_nhwindow
X#undef tty_display_nhwindow
X#undef tty_destroy_nhwindow
X#undef tty_curs
X#undef tty_putstr
X#undef tty_display_file
X#undef tty_start_menu
X#undef tty_add_menu
X#undef tty_end_menu
X#undef tty_select_menu
X#undef tty_update_inventory
X#undef tty_mark_synch
X#undef tty_wait_synch
X#ifdef CLIPPING
X#undef tty_cliparound
X#endif
X#undef tty_print_glyph
X#undef tty_raw_print
X#undef tty_raw_print_bold
X#undef tty_nhgetch
X#undef tty_nh_poskey
X
Xvoid tty_init_nhwindows()	{ tty_init_nhwindows_();	}
Xvoid tty_player_selection()	{ tty_player_selection_(); 	}
Xvoid tty_askname()		{ tty_askname_(); 		}
Xvoid tty_get_nh_event()		{ tty_get_nh_event_(); 		}
Xvoid tty_exit_nhwindows(str)
X  const char *str;		{ tty_exit_nhwindows_(str);	}
Xvoid tty_suspend_nhwindows(str)
X  const char *str;		{ tty_suspend_nhwindows_(str);	}
Xvoid tty_resume_nhwindows()	{ tty_resume_nhwindows_(); 	}
Xwinid tty_create_nhwindow(type)
X  int type;			{ tty_create_nhwindow_(type);	}
Xvoid tty_clear_nhwindow(window)
X  winid window;			{ tty_clear_nhwindow_(window);	}
Xvoid tty_display_nhwindow(window, blocking)
X  winid window; boolean blocking;
X				{ tty_display_nhwindow_(window,blocking); }
Xvoid tty_destroy_nhwindow(window)
X  winid window;			{ tty_destroy_nhwindow_(window); }
Xvoid tty_curs(window,x,y)
X  winid window; int x,y;	{ tty_curs_(window,x,y);	}
Xvoid tty_putstr(window,attr,str)
X  winid window; int attr; const char *str;
X				{ tty_putstr_(window,attr,str); }
Xvoid tty_display_file(fname, complain)
X  const char *fname; boolean complain;
X				{ tty_display_file_(fname,complain); }
Xvoid tty_start_menu(window)
X  winid window;			{ tty_start_menu_(window);	}
Xvoid tty_add_menu(window,ch,attr,str)
X  winid window; char ch; int attr; const char *str;
X				{ tty_add_menu_(window,ch,attr,str); }
Xvoid tty_end_menu(window,ch,str,morestr)
X  winid window; char ch; const char *str, *morestr;
X				{ tty_end_menu_(window,ch,str,morestr);	}
Xchar tty_select_menu(window)
X  winid window;			{ tty_select_menu_(window);	}
Xvoid tty_update_inventory()	{ tty_update_inventory_(); 	}
Xvoid tty_mark_synch()		{ tty_mark_synch_(); 		}
Xvoid tty_wait_synch()		{ tty_wait_synch_(); 		}
X#ifdef CLIPPING
Xvoid tty_cliparound(x,y)
X  int x,y;			{ tty_cliparound_(x,y);		}
X#endif
Xvoid tty_print_glyph(window,x,y,glyph)
X  winid window; xchar x,y; int glyph;
X				{ tty_print_glyph_(window,x,y,glyph); }
Xvoid tty_raw_print(str)
X  const char *str;		{ tty_raw_print_(str); 		}
Xvoid tty_raw_print_bold(str)
X  const char *str;		{ tty_raw_print_bold_(str); 	}
Xint tty_nhgetch()		{ tty_nhgetch_(); 		}
Xint tty_nh_poskey(x,y,pos)
X  int *x,*y,*pos;		{ tty_nh_poskey_(x,y,pos);	}
X
X#endif /* OVERLAY */
END_OF_FILE
if test 15116 -ne `wc -c <'sys/msdos/trampoli.c'`; then
    echo shar: \"'sys/msdos/trampoli.c'\" unpacked with wrong size!
fi
# end of 'sys/msdos/trampoli.c'
fi
echo shar: End of archive 38 \(of 108\).
cp /dev/null ark38isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \
21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \
41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 \
61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 \
81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 \
101 102 103 104 105 106 107 108 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 108 archives.
    echo "Now execute 'rebuild.sh'"
    rm -f ark10[0-8]isdone ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
