Path: uunet!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v16i073:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Part65/108
Message-ID: <4376@master.CNA.TEK.COM>
Date: 1 Feb 93 19:50:58 GMT
Sender: news@master.CNA.TEK.COM
Lines: 2092
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1623

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 16, Issue 73
Archive-name: nethack31/Part65
Supersedes: nethack3p9: Volume 10, Issue 46-102
Environment: Amiga, Atari, Mac, MS-DOS, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 65 (of 108)."
# Contents:  dat/bigroom.des src/do.c src/drawing.c
# Wrapped by billr@saab on Wed Jan 27 16:09:12 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'dat/bigroom.des' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dat/bigroom.des'\"
else
echo shar: Extracting \"'dat/bigroom.des'\" \(3185 characters\)
sed "s/^X//" >'dat/bigroom.des' <<'END_OF_FILE'
X#	SCCS Id: @(#)bigroom.des	3.1	90/04/15
X#	Copyright (c) 1989 by Jean-Christophe Collet
X#	Copyright (c) 1990 by M. Stephenson
X# NetHack may be freely redistributed.  See license for details.
X#
X# This is the bigroom level :
X#
X
XMAZE:"bigroom",' '
XGEOMETRY:center,center
XMAP
X---------------------------------------------------------------------------
X|.........................................................................|
X|.........................................................................|
X|.........................................................................|
X|.........................................................................|
X|.........................................................................|
X|.........................................................................|
X|.........................................................................|
X|.........................................................................|
X|.........................................................................|
X|.........................................................................|
X|.........................................................................|
X|.........................................................................|
X|.........................................................................|
X|.........................................................................|
X|.........................................................................|
X|.........................................................................|
X---------------------------------------------------------------------------
XENDMAP
X# Dungeon Description
XREGION:(01,01,73,16),lit,"ordinary"
X# Stairs
XSTAIR:random,up
XSTAIR:random,down
X# Non diggable walls
XNON_DIGGABLE:(00,00,74,17)
X# Objects
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
X# Random traps
XTRAP:random,random
XTRAP:random,random
XTRAP:random,random
XTRAP:random,random
XTRAP:random,random
XTRAP:random,random
X# Random monsters.
XMONSTER:random,random,random
XMONSTER:random,random,random
XMONSTER:random,random,random
XMONSTER:random,random,random
XMONSTER:random,random,random
XMONSTER:random,random,random
XMONSTER:random,random,random
XMONSTER:random,random,random
XMONSTER:random,random,random
XMONSTER:random,random,random
XMONSTER:random,random,random
XMONSTER:random,random,random
XMONSTER:random,random,random
XMONSTER:random,random,random
XMONSTER:random,random,random
XMONSTER:random,random,random
XMONSTER:random,random,random
XMONSTER:random,random,random
XMONSTER:random,random,random
XMONSTER:random,random,random
XMONSTER:random,random,random
XMONSTER:random,random,random
XMONSTER:random,random,random
XMONSTER:random,random,random
XMONSTER:random,random,random
XMONSTER:random,random,random
XMONSTER:random,random,random
XMONSTER:random,random,random
END_OF_FILE
if test 3185 -ne `wc -c <'dat/bigroom.des'`; then
    echo shar: \"'dat/bigroom.des'\" unpacked with wrong size!
fi
# end of 'dat/bigroom.des'
fi
if test -f 'src/do.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/do.c'\"
else
echo shar: Extracting \"'src/do.c'\" \(31171 characters\)
sed "s/^X//" >'src/do.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)do.c	3.1	92/11/11	*/
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X/* Contains code for 'd', 'D' (drop), '>', '<' (up, down) */
X
X#include "hack.h"
X#include "lev.h"
X
X#include <errno.h>
X#ifdef _MSC_VER	/* MSC 6.0 defines errno quite differently */
X# if (_MSC_VER >= 600)
X#  define SKIP_ERRNO
X# endif
X#endif
X#ifndef SKIP_ERRNO
Xextern int errno;
X#endif
X
X#ifdef MFLOPPY
Xextern struct finfo fileinfo[];
X#else
Xextern boolean level_exists[];
X#endif
X
X#ifdef SINKS
X# ifdef OVLB
Xstatic void FDECL(trycall, (struct obj *));
X# endif /* OVLB */
XSTATIC_DCL void FDECL(dosinkring, (struct obj *));
X#endif /* SINKS */
X
XSTATIC_PTR int FDECL(drop, (struct obj *));
XSTATIC_PTR int NDECL(wipeoff);
X
X#ifdef OVL2
Xstatic int NDECL(currentlevel_rewrite);
X/* static boolean FDECL(badspot, (XCHAR_P,XCHAR_P)); */
X#endif
X
X#ifdef OVLB
X
Xstatic const char NEARDATA drop_types[] =
X	{ ALLOW_COUNT, GOLD_CLASS, ALL_CLASSES, 0 };
X
Xint
Xdodrop()
X{
X	int result;
X
X	if (*u.ushops) sellobj_state(TRUE);
X	result = drop(getobj(drop_types, "drop"));
X	if (*u.ushops) sellobj_state(FALSE);
X	reset_occupations();
X
X	return result;
X}
X
X#endif /* OVLB */
X#ifdef OVL0
X
X/* Called when a boulder is dropped, thrown, or pushed.  If it ends up
X * in a pool, it either fills the pool up or sinks away.  In either case, 
X * it's gone for good...  If the destination is not a pool, returns FALSE.
X */
Xboolean
Xboulder_hits_pool(otmp, rx, ry, pushing)
Xstruct obj *otmp;
Xregister int rx, ry;
Xboolean pushing;
X{
X	if (!otmp || otmp->otyp != BOULDER)
X	    impossible("Not a boulder?");
X	else if (!Is_waterlevel(&u.uz) && (is_pool(rx,ry) || is_lava(rx,ry))) {
X	    boolean lava = is_lava(rx,ry), fills_up;
X	    const char *what = lava ? "lava" : "water";
X	    schar ltyp = levl[rx][ry].typ;
X	    int chance = rn2(10);		/* water: 90%; lava: 10% */
X	    fills_up = lava ? chance == 0 : chance != 0;
X
X	    if (fills_up) {
X		if (ltyp == DRAWBRIDGE_UP) {
X		    levl[rx][ry].drawbridgemask &= ~DB_UNDER; /* clear lava */
X		    levl[rx][ry].drawbridgemask |= DB_FLOOR;
X		} else
X		    levl[rx][ry].typ = ROOM;
X
X		delallobj(rx, ry);
X		newsym(rx,ry);
X		if (pushing) {
X		    You("push %s into the %s.", the(xname(otmp)), what);
X		    if (flags.verbose && !Blind)
X			pline("Now you can cross it!");
X		    /* no splashing in this case */
X		}
X	    }
X	    if (!fills_up || !pushing) {	/* splashing occurs */
X		if (pushing ? !Blind : cansee(rx,ry))
X		    pline("There is a large splash as %s %s the %s.",
X			the(xname(otmp)), fills_up ? "fills" : "falls into",
X			lava ? "lava" : ltyp==POOL ? "pool" : "moat");
X		else if (flags.soundok)
X		    You("hear a%s splash.", lava ? " sizzling" : "");
X		wake_nearby();
X
X		if (fills_up && u.uinwater && distu(rx,ry) == 0) {
X		    You("find yourself on dry land again!");
X		    u.uinwater = 0;
X		} else if (lava && distu(rx,ry) <= 2) {
X		    You("are hit by molten lava%c",
X			Fire_resistance ? '.' : '!');
X		    losehp(d((Fire_resistance ? 1 : 3), 6),
X			   "molten lava", KILLED_BY);
X		} else if (!fills_up && flags.verbose &&
X			   (pushing ? !Blind : cansee(rx,ry)))
X		    pline("It sinks without a trace!");
X	    }
X
X	    /* boulder is now gone */
X	    if (pushing) delobj(otmp);
X	    else obfree(otmp, (struct obj *)0);
X	    return TRUE;
X	}
X	return FALSE;
X}
X
X/* Used for objects which sometimes do special things when dropped; must be
X * called with the object not in any chain.  Returns 1 if the object is
X * gone.
X */
Xboolean
Xflooreffects(obj,x,y,verb)
Xstruct obj *obj;
Xint x,y;
Xconst char *verb;
X{
X	struct trap *t;
X
X	if (obj->otyp == BOULDER && boulder_hits_pool(obj, x, y, FALSE))
X		return TRUE;
X	else if (obj->otyp == BOULDER && (t = t_at(x,y)) != 0 &&
X		 (t->ttyp==PIT || t->ttyp==SPIKED_PIT || t->ttyp==TRAPDOOR)) {
X		struct monst *mtmp;
X
X		delallobj(x, y);
X		if(!Can_fall_thru(&u.uz) && t->ttyp == TRAPDOOR)
X			return FALSE;
X		if (((mtmp = m_at(x, y)) && mtmp->mtrapped) ||
X		    (u.utrap && x==u.ux && y==u.uy)) {
X		    /* u.utrap = 0;     /* player remains trapped. See trap.c */
X		    if (*verb)
X			pline("The boulder %ss into the pit%s.", verb, 
X			      (mtmp)? "" : " with you");
X		    if (mtmp) {
X			if (!passes_walls(mtmp->data) && !throws_rocks(mtmp->data))
X				if (hmon(mtmp, obj, TRUE))
X					return FALSE; 	       /* still alive */
X				else
X					delallobj(x, y);  /* treasure, corpse */
X		    } else
X#ifdef POLYSELF
X		    	if (!passes_walls(uasmon) && !throws_rocks(uasmon))
X#endif
X			{
X			       losehp(rnd(15), "squished under a boulder",
X			       	      NO_KILLER_PREFIX);
X		    	       return FALSE;
X			}
X		}
X		if (*verb) {
X			if (Blind) {
X				if ((x == u.ux) && (y == u.uy))
X					You("hear a CRASH! beneath you.");
X				else
X					You("hear the boulder %s.", verb);
X			} else if (cansee(x, y)) {
X				pline("The boulder %sfills a %s.",
X				      t->tseen ? "" : "triggers and ",
X				      t->ttyp == TRAPDOOR ? 
X				      "trap door" : "pit");
X			}
X		}
X		deltrap(t);
X		obfree(obj, (struct obj *)0);
X		newsym(x,y);
X		return TRUE;
X	}
X	return FALSE;
X}
X
X#endif /* OVL0 */
X#ifdef OVLB
X
Xvoid
Xdoaltarobj(obj)  /* obj is an object dropped on an altar */
X	register struct obj *obj;
X{
X	if (Blind) return;
X	if (obj->blessed || obj->cursed) {
X		pline("There is %s flash as %s hit%s the altar.",
X		      an(Hallucination ? hcolor() :
X			 obj->blessed ? amber : Black),
X		      doname(obj),
X		      (obj->quan == 1L) ? "s" : "");
X		if (!Hallucination) obj->bknown = 1;
X	} else {
X		pline("%s land%s on the altar.", Doname2(obj),
X			(obj->quan == 1L) ? "s" : "");
X		if (obj->otyp != GOLD_PIECE)
X			obj->bknown = 1;
X	}
X}
X
X#ifdef SINKS
Xstatic
Xvoid
Xtrycall(obj)
Xregister struct obj *obj;
X{
X	if(!objects[obj->otyp].oc_name_known &&
X	   !objects[obj->otyp].oc_uname)
X	   docall(obj);
X}
X
XSTATIC_OVL
Xvoid
Xdosinkring(obj)  /* obj is a ring being dropped over a kitchen sink */
Xregister struct obj *obj;
X{
X	register struct obj *otmp,*otmp2;
X	register boolean ideed = TRUE;
X
X	You("drop %s down the drain.", doname(obj));
X	switch(obj->otyp) {	/* effects that can be noticed without eyes */
X	    case RIN_SEARCHING:
X		You("thought your %s got lost in the sink, but there it is!",
X			xname(obj));
X		dropx(obj);
X		trycall(obj);
X		return;
X	    case RIN_LEVITATION:
X		pline("The sink quivers upward for a moment.");
X		break;
X	    case RIN_POISON_RESISTANCE:
X#ifdef TUTTI_FRUTTI
X		You("smell rotten %s.", makeplural(pl_fruit));
X#else
X		You("smell rotten fruit.");
X#endif
X		break;
X	    case RIN_AGGRAVATE_MONSTER:
X		pline("Several flies buzz angrily around the sink.");
X		break;
X	    case RIN_SHOCK_RESISTANCE:
X		pline("Static electricity surrounds the sink.");
X		break;
X	    case RIN_CONFLICT:
X		You("hear loud noises coming from the drain.");
X		break;
X	    case RIN_GAIN_STRENGTH:
X		pline("The water flow seems %ser now.",
X			(obj->spe<0) ? "weak" : "strong");
X		break;
X	    case RIN_INCREASE_DAMAGE:
X		pline("The water's force seems %ser now.",
X			(obj->spe<0) ? "small" : "great");
X		break;
X	    default:
X		ideed = FALSE;
X		break;
X	}
X	if(!Blind && !ideed) {
X	    ideed = TRUE;
X	    switch(obj->otyp) {		/* effects that need eyes */
X		case RIN_ADORNMENT:
X		    pline("The faucets flash brightly for a moment.");
X		    break;
X		case RIN_REGENERATION:
X		    pline("The sink looks as good as new.");
X		    break;
X		case RIN_INVISIBILITY:
X		    You("don't see anything happen to the sink.");
X		    break;
X		case RIN_SEE_INVISIBLE:
X		    You("see some air in the sink.");
X		    break;
X		case RIN_STEALTH:
X		pline("The sink seems to blend into the floor for a moment.");
X		    break;
X		case RIN_HUNGER:
X		    ideed = FALSE;
X		    for(otmp = level.objects[u.ux][u.uy]; otmp; otmp = otmp2) {
X			otmp2 = otmp->nexthere;
X			if(otmp != uball && otmp != uchain) {
X			    pline("Suddenly, %s vanishes from the sink!",
X							doname(otmp));
X			    delobj(otmp);
X			    ideed = TRUE;
X			}
X		    }
X		    break;
X		case RIN_FIRE_RESISTANCE:
X		pline("The hot water faucet flashes brightly for a moment.");
X		    break;
X		case RIN_COLD_RESISTANCE:
X		pline("The cold water faucet flashes brightly for a moment.");
X		    break;
X		case RIN_PROTECTION_FROM_SHAPE_CHAN:
X		    pline("The sink looks nothing like a fountain.");
X		    break;
X		case RIN_PROTECTION:
X		    pline("The sink glows %s for a moment.",
X			    Hallucination ? hcolor() :
X			    (obj->spe<0) ? Black : silver);
X		    break;
X		case RIN_WARNING:
X		    pline("The sink glows %s for a moment.",
X			    Hallucination ? hcolor() : White);
X		    break;
X		case RIN_TELEPORTATION:
X		    pline("The sink momentarily vanishes.");
X		    break;
X		case RIN_TELEPORT_CONTROL:
X	    pline("The sink looks like it is being beamed aboard somewhere.");
X		    break;
X#ifdef POLYSELF
X		case RIN_POLYMORPH:
X		    pline("The sink momentarily looks like a fountain.");
X		    break;
X		case RIN_POLYMORPH_CONTROL:
X	pline("The sink momentarily looks like a regularly erupting geyser.");
X		    break;
X#endif
X	    }
X	}
X	if(ideed)
X	    trycall(obj);
X	else
X	    You("hear the ring bouncing down the drainpipe.");
X	if (!rn2(20)) {
X		pline("The sink backs up, leaving %s.", doname(obj));
X		dropx(obj);
X	}
X	else
X		useup(obj);
X}
X#endif
X
X#endif /* OVLB */
X#ifdef OVL0
X
X/* some common tests when trying to drop or throw items */
Xboolean
Xcanletgo(obj,word)
Xregister struct obj *obj;
Xregister const char *word;
X{
X	if(obj->owornmask & (W_ARMOR | W_RING | W_AMUL | W_TOOL)){
X	       if (*word)
X			Norep("You cannot %s something you are wearing.",word);
X		return(FALSE);
X	}
X	if (obj->otyp == LOADSTONE && obj->cursed) {
X		if (*word)
X			pline("For some reason, you cannot %s the stone%s!",
X				word, plur(obj->quan));
X		/* Kludge -- see invent.c */
X		if (obj->corpsenm) {
X			struct obj *otmp;
X
X			otmp = obj;
X			obj = obj->nobj;
X			obj->quan += otmp->quan;
X			obj->owt = weight(obj);
X			freeinv(otmp);
X			obfree(otmp, obj);
X		}
X		obj->bknown = 1;
X		return(FALSE);
X	}
X#ifdef WALKIES
X	if (obj->otyp == LEASH && obj->leashmon != 0) {
X	       if (*word)
X			pline ("The leash is tied around your %s.",
X					body_part(HAND));
X		return(FALSE);
X	}
X#endif
X	return(TRUE);
X}
X
XSTATIC_PTR
Xint
Xdrop(obj)
Xregister struct obj *obj;
X{
X	if(!obj) return(0);
X	if(!canletgo(obj,"drop"))
X		return(0);
X	if(obj == uwep) {
X		if(welded(uwep)) {
X			weldmsg(obj, FALSE);
X			return(0);
X		}
X		setuwep((struct obj *)0);
X		if(uwep) return 0; /* lifesaved and rewielded */
X	}
X#ifdef SINKS
X	if((obj->oclass == RING_CLASS) && IS_SINK(levl[u.ux][u.uy].typ)
X							&& !u.uswallow) {
X		dosinkring(obj);
X		return(1);
X	}
X#endif
X	if (IS_ALTAR(levl[u.ux][u.uy].typ) && !u.uswallow) {
X		doaltarobj(obj);	/* set bknown */
X	} else
X		if(flags.verbose) You("drop %s.", doname(obj));
X	dropx(obj);
X	return(1);
X}
X
X/* Called in several places - should not produce texts */
Xvoid
Xdropx(obj)
Xregister struct obj *obj;
X{
X	/* Money is *not* in our inventory */
X	if (obj->otyp != GOLD_PIECE) freeinv(obj);
X	(void) snuff_candle(obj);
X	if(!u.uswallow && obj != uball &&
X		          ship_object(obj, u.ux, u.uy, FALSE)) return;
X	dropy(obj);
X}
X
Xvoid
Xdropy(obj)
Xregister struct obj *obj;
X{
X	if (!u.uswallow && flooreffects(obj,u.ux,u.uy,"drop")) return;
X	if(obj->otyp == CRYSKNIFE)
X		obj->otyp = WORM_TOOTH;
X	/* uswallow check done by GAN 01/29/87 */
X	if(u.uswallow) {
X		if (obj->otyp == GOLD_PIECE) {
X		    u.ustuck->mgold += obj->quan;
X		    delobj(obj);
X		} else if (obj != uball) {	/* mon doesn't pick up ball */
X		    (void) snuff_candle(obj);   /* security. it's never lit */
X		    mpickobj(u.ustuck,obj);
X		}
X	} else  {
X		(void) snuff_candle(obj);
X		obj->nobj = fobj;
X		fobj = obj;
X		place_object(obj, u.ux, u.uy);
X		if (obj == uball)
X		    drop_ball(u.ux,u.uy);
X		else
X		    sellobj(obj, u.ux, u.uy);
X		stackobj(obj);
X		if(Blind && Levitation)
X		    map_object(obj, 0);
X		newsym(u.ux,u.uy);	/* remap location under self */
X	}
X}
X
X/* drop several things */
Xint
Xdoddrop()
X{
X	int result;
X
X	if (*u.ushops) sellobj_state(TRUE);
X	result = ggetobj("drop", drop, 0);
X	if (*u.ushops) sellobj_state(FALSE);
X	reset_occupations();
X
X	return result;
X}
X
X#endif /* OVL0 */
X#ifdef OVL2
X
X/* on a ladder, used in goto_level */
Xstatic boolean NEARDATA at_ladder = FALSE;
X
Xint
Xdodown()
X{
X	struct trap *trap = 0;
X
X	if( (u.ux != xdnstair || u.uy != ydnstair)
X	     && (!xdnladder || u.ux != xdnladder || u.uy != ydnladder)
X	     && (!sstairs.sx || u.ux != sstairs.sx || u.uy != sstairs.sy
X			|| sstairs.up)
X	  ) {
X		if (!(trap = t_at(u.ux,u.uy)) || trap->ttyp != TRAPDOOR
X			|| !Can_fall_thru(&u.uz) || !trap->tseen) {
X			You("can't go down here.");
X			return(0);
X		}
X	}
X	if(u.ustuck) {
X		You("are being held, and cannot go down.");
X		return(1);
X	}
X	if(Levitation) {
X		pline("You're floating high above the %s.",
X			levl[u.ux][u.uy].typ == STAIRS ? "stairs" :
X			levl[u.ux][u.uy].typ == LADDER ? "ladder" :
X			"trap door");
X		return(0);
X	}
X	if (on_level(&valley_level, &u.uz) && !u.uevent.gehennom_entered) {
X		You("are standing at the gate to Gehennom.");
X		pline("Unspeakable cruelty and harm lurk down there.");
X		if (yn("Are you sure you want to enter?") != 'y')
X		     return(0);
X		else pline("So be it.");
X		u.uevent.gehennom_entered = 1;	/* don't ask again */
X	}
X
X#ifdef WALKIES
X	if(!next_to_u()) {
X		You("are held back by your pet!");
X		return(0);
X	}
X#endif
X	if (trap)
X#ifdef POLYSELF
X		You("%s into the trap door.", locomotion(uasmon, "jump"));
X#else
X		You("jump into the trap door.");
X#endif
X	if (levl[u.ux][u.uy].typ == LADDER) at_ladder = TRUE;
X	next_level(!trap);
X	at_ladder = FALSE;
X	return(1);
X}
X
Xint
Xdoup()
X{
X	if( (u.ux != xupstair || u.uy != yupstair)
X	     && (!xupladder || u.ux != xupladder || u.uy != yupladder)
X	     && (!sstairs.sx || u.ux != sstairs.sx || u.uy != sstairs.sy
X			|| !sstairs.up)
X 	  ) {
X		You("can't go up here.");
X		return(0);
X	}
X	if(u.ustuck) {
X		You("are being held, and cannot go up.");
X		return(1);
X	}
X	if(near_capacity() > SLT_ENCUMBER) {
X		/* No levitation check; inv_weight() already allows for it */
X		Your("load is too heavy to climb the %s.",
X		      levl[u.ux][u.uy].typ == STAIRS ? "stairs" : "ladder");
X		return(1);
X	}
X	if(ledger_no(&u.uz) == 1) {
X		if (yn("Beware, there will be no return! Still climb?") != 'y')
X			return(0);
X	}
X#ifdef WALKIES
X	if(!next_to_u()) {
X		You("are held back by your pet!");
X		return(0);
X	}
X#endif
X	if (levl[u.ux][u.uy].typ == LADDER) at_ladder = TRUE;
X	prev_level(TRUE);
X	at_ladder = FALSE;
X	return(1);
X}
X
Xd_level save_dlevel = {0, 0};
X
X/* check that we can write out the current level */
Xstatic int
Xcurrentlevel_rewrite()
X{
X	register int fd;
X
X	fd = create_levelfile(ledger_no(&u.uz));
X
X	if(fd < 0) {
X		/*
X		 * This is not quite impossible: e.g., we may have
X		 * exceeded our quota. If that is the case then we
X		 * cannot leave this level, and cannot save either.
X		 * Another possibility is that the directory was not
X		 * writable.
X		 */
X		pline("Cannot create level file for level %d.",
X						ledger_no(&u.uz));
X		return -1;
X	}
X
X#ifdef MFLOPPY
X	if (!savelev(fd, ledger_no(&u.uz), COUNT_SAVE)) {
X		(void) close(fd);
X		delete_levelfile(ledger_no(&u.uz));
X		pline("NetHack is out of disk space for making levels!");
X		You("can save, quit, or continue playing.");
X		return -1;
X	}
X#endif
X	return fd;
X}
X
X#ifdef INSURANCE
Xvoid
Xsave_currentstate()
X{
X	int fd;
X
X	if (flags.ins_chkpt) {
X		/* write out just-attained level, with pets and everything */
X		fd = currentlevel_rewrite();
X		if(fd < 0) return;
X		bufon(fd);
X		savelev(fd,ledger_no(&u.uz), WRITE_SAVE);
X		bclose(fd);
X	}
X
X	/* write out non-level state */
X	savestateinlock();
X}
X#endif
X
X/*
Xstatic boolean
Xbadspot(x, y)
Xregister xchar x, y;
X{
X        return((levl[x][y].typ != ROOM && levl[x][y].typ != AIR &&
X		         levl[x][y].typ != CORR) || MON_AT(x, y));
X}
X*/
X
Xvoid
Xgoto_level(newlevel, at_stairs, falling, portal)
Xd_level *newlevel;
Xregister boolean at_stairs, falling, portal;
X{
X	register int fd;
X	register boolean up = (depth(newlevel) < depth(&u.uz));
X	register boolean newdungeon = (u.uz.dnum != newlevel->dnum);
X#ifdef REINCARNATION
X	int new = 0;	/* made a new level? */
X#endif
X
X	if(dunlev(newlevel) > dunlevs_in_dungeon(newlevel))
X	    	newlevel->dlevel = dunlevs_in_dungeon(newlevel);
X	if(newdungeon && In_endgame(newlevel)) { /* 1st Endgame Level !!! */
X	    	if(u.uhave.amulet) 
X		    assign_level(newlevel, &earth_level);
X	    	else return;
X	}
X	if(ledger_no(newlevel) <= 0)
X	    	done(ESCAPED);	/* in fact < 0 is impossible */
X	/* If you have the amulet and are trying to get out of Hell, going
X	 * up a set of stairs sometimes does some very strange things!
X	 */
X	if(Inhell && up && !newdungeon && u.uhave.amulet &&
X	   			(dunlev(&u.uz) < dunlevs_in_dungeon(&u.uz)-3)) {
X	    	if(!rn2(4)) {
X		    if(!u.ualign.type) {		    /* neutral */
X		        if(rn2(2)) assign_level(newlevel, &u.uz);
X		        else assign_rnd_level(newlevel, &u.uz, rnd(3));
X		    } else if(u.ualign.type == A_LAWFUL) {    /* lawful */
X			assign_rnd_level(newlevel, &u.uz, rnd(3));
X		    } else assign_level(newlevel, &u.uz); /* chaotic */
X	        }
X		pline("A mysterious force momentarily surrounds you...");
X	    	if(ledger_no(newlevel) < 1) assign_level(newlevel, &u.uz);
X	    	if(on_level(newlevel, &u.uz)) {
X		    (void) safe_teleds();
X#ifdef WALKIES
X		    (void) next_to_u();
X#endif
X		    return;
X		}
X	}
X#ifdef MULDGN
X/*	Prevent the player from going past the first quest level unless
X *	(s)he has been given the go-ahead by the leader.
X */
X	if(on_level(&u.uz, &qstart_level) && !newdungeon && !ok_to_quest()) {
X
X		pline("A mysterious force prevents you from descending.");
X		return;
X	}
X#endif
X	if(on_level(newlevel, &u.uz)) return;	      /* this can happen */
X
X	fd = currentlevel_rewrite();
X	if(fd < 0) return;
X
X	if (falling) /* assuming this is only trapdoor */
X	    impact_drop((struct obj *)0, u.ux, u.uy, newlevel->dlevel);
X
X	check_special_room(TRUE);		/* probably was a trap door */
X	if(Punished) unplacebc();
X	u.utrap = 0;				/* needed in level_tele */
X	fill_pit(u.ux, u.uy);
X	u.ustuck = 0;				/* idem */
X	u.uinwater = 0;
X	keepdogs();
X	if(u.uswallow)				/* idem */
X		u.uswldtim = u.uswallow = 0;
X	/*
X	 *  We no longer see anything on the level.  Make sure that this
X	 *  follows u.uswallow set to null since uswallow overrides all
X	 *  normal vision.
X	 */
X	vision_recalc(2);
X	bufon(fd);
X	savelev(fd,ledger_no(&u.uz), WRITE_SAVE | FREE_SAVE);
X	bclose(fd);
X
X#ifdef REINCARNATION
X	if (Is_rogue_level(newlevel) || Is_rogue_level(&u.uz))
X		assign_rogue_graphics(Is_rogue_level(newlevel));
X#endif
X	assign_level(&u.uz0, &u.uz);
X	assign_level(&u.uz, newlevel);
X	assign_level(&u.utolev, newlevel);
X	u.utotype = 0;
X	if(dunlev_reached(&u.uz) < dunlev(&u.uz))
X		dunlev_reached(&u.uz) = dunlev(&u.uz);
X
X	/* set default level change destination areas */
X	/* the special level code may override these */
X	(void) memset((genericptr_t) &updest, 0, sizeof updest);
X	(void) memset((genericptr_t) &dndest, 0, sizeof dndest);
X
X	if(In_endgame(&u.uz) ||
X#ifdef MFLOPPY
X	    /* If the level has no .where yet, it hasn't been made */
X	    !fileinfo[ledger_no(&u.uz)].where) {
X#else
X	    !level_exists[ledger_no(&u.uz)]) {
X#endif
X		mklev();
X#ifdef REINCARNATION
X		new = 1;	/* made the level */
X#endif
X	} else {
X		fd = open_levelfile(ledger_no(&u.uz));
X		if (fd < 0) {
X			pline("Cannot open file (#%d) for level %d (errno %d).",
X					ledger_no(&u.uz), depth(&u.uz), errno);
X			pline("Probably someone removed it.");
X			done(TRICKED);
X		}
X#ifdef ZEROCOMP
X		minit();
X#endif
X		getlev(fd, hackpid, ledger_no(&u.uz), FALSE);
X		(void) close(fd);
X	}
X#ifdef MULDGN
X	quest_init();	/* re-initialize */
X#endif
X
X	if(portal && !In_endgame(&u.uz)) {
X	    /* find the portal on the new level */
X	    register struct trap *ttrap;
X
X	    for(ttrap = ftrap; ttrap; ttrap = ttrap->ntrap)
X		if(ttrap->ttyp == MAGIC_PORTAL) break;
X
X	    if(ttrap) {
X		u.ux = ttrap->tx;
X		u.uy = ttrap->ty;
X	    } else panic("goto_level: no corresponding portal!");
X	} else if(at_stairs && !In_endgame(&u.uz)) {
X	    if(up) {
X		if(at_ladder) {
X		    u.ux = xdnladder;
X		    u.uy = ydnladder;
X		} else {
X		    if(newdungeon) {
X			if(Is_stronghold(&u.uz)) {
X			    register xchar x, y;
X
X			    do {
X				x = (COLNO - 2 - rnd(5));
X				y = rn1(ROWNO - 4, 3);
X			    } while(occupied(x, y) ||
X				    IS_WALL(levl[x][y].typ));
X			    u.ux = x;
X			    u.uy = y;
X			} else u_on_sstairs();
X		    } else u_on_dnstairs();
X		} 
X		/* Remove bug which crashes with */ 
X		/* levitation/punishment  KAA    */
X		if(Punished) {
X		    if(!Levitation)
X			pline("With great effort you climb the %s.",
X			      !at_ladder ? "stairs" : "ladder");
X		    placebc();
X		} 
X		if(at_ladder && (!Punished || Levitation))
X		    You("climb up the ladder.");
X	    } else { /* down */
X		if(at_ladder) {
X		    u.ux = xupladder;
X		    u.uy = yupladder;
X		} else {
X		    if(newdungeon) u_on_sstairs();
X		    else u_on_upstairs();
X		}
X		if(at_stairs && u.dz && !up &&
X		   ((near_capacity()>UNENCUMBERED) || Punished || Fumbling)) {
X		    You("fall down the %s.",
X			!at_ladder ? "stairs" : "ladder");
X		    if(Punished) {
X			drag_down();
X			if(carried(uball)) {
X			    if (uwep == uball)
X				setuwep((struct obj *)0);
X			    if (uwep != uball)
X				freeinv(uball);
X			}
X			placebc();
X		    } 
X		    losehp(rnd(3), "falling downstairs", KILLED_BY);
X		    selftouch("Falling, you");
X		} 
X		else if(at_ladder && u.dz)
X		    You("climb down the ladder.");
X	    }
X	} else { /* trap door or level_tele or In_endgame */
X	    if(up)
X		place_lregion(updest.lx, updest.ly,
X			      updest.hx, updest.hy,
X			      updest.nlx, updest.nly,
X			      updest.nhx, updest.nhy,
X			      LR_UPTELE, (d_level *) 0);
X	    else
X		place_lregion(dndest.lx, dndest.ly,
X			      dndest.hx, dndest.hy,
X			      dndest.nlx, dndest.nly,
X			      dndest.nhx, dndest.nhy,
X			      LR_DOWNTELE, (d_level *) 0);
X	    if(Punished) {
X		if(falling) ballfall();
X		placebc();
X	    }
X	    if(falling)
X		selftouch("Falling, you");
X	}
X
X	losedogs();
X	obj_delivery();
X	check_special_room(FALSE);
X
X	initrack();
X
X	if(MON_AT(u.ux, u.uy)) mnexto(m_at(u.ux, u.uy));
X	if(MON_AT(u.ux, u.uy)) {
X		impossible("mnexto failed (do.c)?");
X		rloc(m_at(u.ux, u.uy));
X	}
X	remove_cadavers(&fobj);	/* remove rotted meat (before seen) */
X
X	/* initial movement of bubbles just before vision_recalc */
X	if (Is_waterlevel(&u.uz))
X		movebubbles();
X
X	/* Reset the screen. */
X	vision_reset();		/* reset the blockages */
X	docrt();		/* does a full vision recalc */
X
X	/* In Nethack 3.1, Gehennom starts after the stronghold.  Moreover,
X	 * there are traps in the stronghold, that can send the player
X	 * to Gehennom (gnark, gnark)!  So we have to test here:
X	 */
X	if(!In_hell(&u.uz0) && Inhell) {
X            if(Is_valley(newlevel)) {
X		You("arrive at the Valley of the Dead...");
X	    	pline("There is a smell of burnt flesh and decay here.");
X#ifdef MICRO
X	    	display_nhwindow(WIN_MESSAGE, FALSE);
X#endif
X		pline("The sounds of groans and moans fill the air.");
X	    } else pline("It is hot here.  You smell smoke...");
X	}
X
X#ifdef REINCARNATION
X	/*
X	 *  Move all plines beyond the screen reset.
X	 */
X	if (new && Is_rogue_level(&u.uz))
X	 You("have entered what appears to be an older, more primitive world.");
X#endif
X	/* Final confrontation */
X	if (In_endgame(&u.uz) && newdungeon && u.uhave.amulet &&
X						   flags.no_of_wizards == 0)
X		resurrect();
X	if (newdungeon && In_tower(&u.uz))
X		pline("The heat and smoke are gone.");
X#ifdef MULDGN
X	if(!In_quest(&u.uz0) && at_dgn_entrance("The Quest") &&
X		!(u.uevent.qexpelled || u.uevent.qcompleted || leaderless()))
X	    com_pager(2);	/* the message from the leader */
X
X	if(Is_knox(&u.uz)) {
X	        register struct monst *mtmp;
X
X	        You("penetrated a high security area!");
X		pline("An alarm sounds!");
X		for(mtmp = fmon; mtmp; mtmp = mtmp->nmon) 
X		    if(mtmp->msleep) mtmp->msleep = 0;
X	}
X#endif /* MULDGN */
X	if(on_level(&u.uz, &astral_level)) {
X	        register struct monst *mtmp;
X
X	        /* reset monster hostility relative to player */
X		for(mtmp = fmon; mtmp; mtmp = mtmp->nmon) 
X		    reset_hostility(mtmp);
X
X		/* create some player-monsters */
X		create_mplayers(rn1(4, 3), TRUE);
X
X		/* create a guardian angel next to player, if worthy */
X		if (Conflict) {
X		    coord mm;
X		    int i = rnd(4);
X	pline("A voice booms: \"Thy desire for conflict shall be rewarded!\"");
X		    while(i--) {
X			mm.x = u.ux;
X			mm.y = u.uy;
X			if(enexto(&mm, mm.x, mm.y, &mons[PM_ANGEL]))
X			    (void) mk_roamer(&mons[PM_ANGEL], u.ualign.type,
X					     mm.x, mm.y, FALSE);
X		    }
X
X		} else if(u.ualign.record > 3) {
X		    coord mm;
X
X		pline("A voice whispers: \"Thou hast been worthy of me!\"");
X		    mm.x = u.ux;
X		    mm.y = u.uy;
X		    if(enexto(&mm, mm.x, mm.y, &mons[PM_ANGEL])) {
X			if((mtmp = mk_roamer(&mons[PM_ANGEL], u.ualign.type,
X					   mm.x, mm.y, TRUE)) != 0) {
X			     register struct obj *otmp =
X			                   mksobj(SILVER_SABER, FALSE, FALSE);
X
X			     if(!Blind)
X		                 pline("An angel appears near you.");
X			     else 
X		       You("feel the presence of a friendly angel near you.");
X			    /* guardian angel -- the one case mtame doesn't
X			     * imply an edog structure, so we don't want to
X			     * call tamedog().
X			     */
X			     mtmp->mtame = 10;
X			     /* make him strong enough vs. endgame foes */
X			     mtmp->m_lev = rn1(8,15);
X			     mtmp->mhp = mtmp->mhpmax = 
X				       d((int)mtmp->m_lev,10) + 30 + rnd(30);
X			     bless(otmp);
X			     otmp->spe = 7;
X			     mpickobj(mtmp, otmp);
X		        }
X		    }
X		}
X        }
X
X#ifdef MULDGN
X	onquest();
X#endif
X	assign_level(&u.uz0, &u.uz); /* reset u.uz0 */
X
X#ifdef INSURANCE
X	save_currentstate();
X#endif
X
X	if(!flags.nopick && OBJ_AT(u.ux, u.uy) &&
X	   (!is_pool(u.ux,u.uy) || Underwater))
X		pickup(1);
X	else read_engr_at(u.ux,u.uy);
X}
X
X/* handle something like portal ejection */
Xvoid
Xdeferred_goto()
X{
X	if (!on_level(&u.uz, &u.utolev)) {
X	    d_level dest;
X	    int typmask = u.utotype; /* save it; goto_level zeroes u.utotype */
X
X	    assign_level(&dest, &u.utolev);
X	    goto_level(&dest, !!(typmask&4), !!(typmask&2), !!(typmask&1));
X	    if (typmask & 0200) {	/* remove portal */
X		deltrap(t_at(u.ux, u.uy));
X		newsym(u.ux, u.uy);
X	    }
X	}
X}
X
X#endif /* OVL2 */
X#ifdef OVL3
X
Xvoid
Xrevive_corpse(corpse, odds, mark_as_old)    /* see remove_cadavers() */
Xregister struct obj *corpse;
Xint odds;
Xboolean mark_as_old;
X{
X    register struct monst *mtmp;
X
X    corpse->oldcorpse = mark_as_old;
X
X    /* odds == 0 is a special case meaning 'always revive' */
X    if (!odds || !rn2(odds)) {
X	if (carried(corpse)) {
X	    if (corpse == uwep) {
X		if ((mtmp = revive(corpse,TRUE)) != 0)
X		    pline("The %s%s %s writhes out of your grasp!",
X			(mtmp->mhp < mtmp->mhpmax) ? "bite-covered ":"",
X				mtmp->data->mname, xname(corpse));
X	    } else if ((mtmp = revive(corpse,TRUE)) != 0)
X		You("feel squirming in your backpack!");
X	} else {
X	    if ((mtmp = revive(corpse,FALSE)) && cansee(mtmp->mx,mtmp->my))
X		pline("%s rises from the dead!",
X		    (mtmp->mhp==mtmp->mhpmax) ? Monnam(mtmp)
X			: Adjmonnam(mtmp, "bite-covered"));
X	}
X    }
X}
X
X/*
X *  Remove old cadavers from any object chain.  Regenerate trolls
X *  thanks to KAA.  Follows containers (except ice boxes).
X */
X#define TAINT_AGE	50	/* min. limit for tainting.  see eat.c */
X#define ODDS_RV1	37	/* 1/37 odds for 50 moves = 75% revive */
X#define ODDS_RV2	2	/* special case 1/2 odds of reviving */
X
Xvoid
Xremove_cadavers(chain)
Xstruct obj **chain;
X{
X    register struct obj *obj, *nobj, *pobj = (struct obj *)0;
X    register long corpse_age;
X    boolean ininv = (*chain == invent);
X    boolean onfloor = (*chain == fobj);
X
X    for (obj = *chain; obj; obj = nobj) {
X	nobj = obj->nobj;
X
X	if (obj->otyp == CORPSE) {
X	    /* corpses laying on ice deteriorate more slowly */
X	    if (onfloor && obj->age < monstermoves &&
X		rn2(3) && is_ice(obj->ox, obj->oy)) obj->age++;
X	    corpse_age = monstermoves - obj->age;
X
X	    if (is_rider(&mons[obj->corpsenm]) && corpse_age >= 12) {
X		/* these always come back eventually */
X		/* riders can't be picked up, so no need to check onfloor */
X		revive_corpse(obj, 3, FALSE);
X	    } else if (mons[obj->corpsenm].mlet == S_TROLL && !obj->oldcorpse
X		       && !(mons[obj->corpsenm].geno & (G_GENOD | G_EXTINCT))
X		       && (onfloor || ininv)) {
X
X		/* the corpse has 50 moves, the lower limit for tainting,
X		 * to attempt re-animation.  if it is unsuccessful it is
X		 * marked to prevent further attempts.  if we leave the
X		 * level and return to old corpses that haven't been marked
X		 * they're given a one-shot chance to re-animate.
X		 */
X		if (corpse_age < TAINT_AGE)
X		    revive_corpse(obj, ODDS_RV1, FALSE);
X		else if (corpse_age == TAINT_AGE)
X		    revive_corpse(obj, ODDS_RV1, TRUE);
X		else revive_corpse(obj, ODDS_RV2, TRUE);
X
X	    } else if (obj->corpsenm != PM_LIZARD && (250 < corpse_age)) {
X		if(ininv)
X		    useup(obj);
X		else if(onfloor)
X		    delobj(obj);
X		else { /* in a container */
X		    if(pobj) pobj->nobj = nobj;
X		    else *chain = nobj;
X		    obfree(obj, (struct obj *) 0);
X		    obj = 0;
X		}
X	    }
X	} else if(obj->cobj && Is_container(obj) && obj->otyp != ICE_BOX)
X	    remove_cadavers(&obj->cobj);
X	/* pobj is only used for containers, which don't allow revive() -dlc */
X	if (obj) pobj = obj;
X    }
X}
X
Xint
Xdonull() {
X	return(1);	/* Do nothing, but let other things happen */
X}
X
X#endif /* OVL3 */
X#ifdef OVLB
X
XSTATIC_PTR int
Xwipeoff() {
X	if(u.ucreamed < 4)	u.ucreamed = 0;
X	else			u.ucreamed -= 4;
X	if (Blinded < 4)	Blinded = 0;
X	else			Blinded -= 4;
X	if (!Blinded) {
X		pline("You've got the glop off.");
X		u.ucreamed = 0;
X		Blinded = 1;
X		make_blinded(0L,TRUE);
X		return(0);
X	} else if (!u.ucreamed) {
X		Your("%s feels clean now.", body_part(FACE));
X		return(0);
X	}
X	return(1);		/* still busy */
X}
X
Xint
Xdowipe()
X{
X	if(u.ucreamed)  {
X		static char NEARDATA buf[39];
X
X		Sprintf(buf, "wiping off your %s", body_part(FACE));
X		set_occupation(wipeoff, buf, 0);
X		/* Not totally correct; what if they change back after now
X		 * but before they're finished wiping?
X		 */
X		return(1);
X	}
X	Your("%s is already clean.", body_part(FACE));
X	return(1);
X}
X
X#endif /* OVLB */
X#ifdef OVL1
X
X/* split obj so that it gets size num */
X/* remainder is put in the object structure delivered by this call */
Xstruct obj *
Xsplitobj(obj, num)
Xregister struct obj *obj;
Xregister long num;
X{
Xregister struct obj *otmp;
X	/* assert(0 < num && num < obj->quan); */
X	otmp = newobj(obj->onamelth);
X	*otmp = *obj;		/* copies whole structure */
X	otmp->o_id = flags.ident++;
X	obj->quan = num;
X	obj->owt = weight(obj);
X	otmp->quan -= num;
X	otmp->owt = weight(otmp);	/* -= obj->owt ? */
X	obj->nobj = obj->nexthere = otmp;
X	if (obj->onamelth)
X		(void)strncpy(ONAME(otmp), ONAME(obj), (int)obj->onamelth);
X	if(obj->unpaid) splitbill(obj,otmp);
X	return(otmp);
X}
X
X#endif /* OVL1 */
X#ifdef OVLB
X
Xvoid
Xset_wounded_legs(side, timex)
Xregister long side;
Xregister int timex;
X{
X	if(!Wounded_legs) {
X		ATEMP(A_DEX)--;
X		flags.botl = 1;
X	}
X
X	if(!Wounded_legs || (Wounded_legs & TIMEOUT))
X		Wounded_legs |= side + timex;
X	else
X		Wounded_legs |= side;
X}
X
Xvoid
Xheal_legs()
X{
X	if(Wounded_legs) {
X		if (ATEMP(A_DEX) < 0) {
X			ATEMP(A_DEX)++;
X			flags.botl = 1;
X		}
X
X		if((Wounded_legs & BOTH_SIDES) == BOTH_SIDES) {
X			Your("%s feel somewhat better.",
X				makeplural(body_part(LEG)));
X		} else {
X			Your("%s feels somewhat better.",
X				body_part(LEG));
X		}
X		Wounded_legs = 0;
X	}
X}
X
X#endif /* OVLB */
X
X/*do.c*/
END_OF_FILE
if test 31171 -ne `wc -c <'src/do.c'`; then
    echo shar: \"'src/do.c'\" unpacked with wrong size!
fi
# end of 'src/do.c'
fi
if test -f 'src/drawing.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/drawing.c'\"
else
echo shar: Extracting \"'src/drawing.c'\" \(19138 characters\)
sed "s/^X//" >'src/drawing.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)drawing.c	3.1	92/12/20	*/
X/* Copyright (c) NetHack Development Team 1992.			  */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include "hack.h"
X#include "termcap.h"
X
X/* Relevent header information in rm.h and objclass.h. */
X
X#ifdef C
X#undef C
X#endif
X
X#ifdef TEXTCOLOR
X#define C(n) n
X#else
X#define C(n)
X#endif
X
X#define g_FILLER(symbol) 0
X
Xuchar oc_syms[MAXOCLASSES] = DUMMY; /* the current object  display symbols */
Xuchar showsyms[MAXPCHARS]  = DUMMY; /* the current feature display symbols */
Xuchar monsyms[MAXMCLASSES] = DUMMY; /* the current monster display symbols */
X
X/* Default object class symbols.  See objclass.h. */
Xconst char def_oc_syms[MAXOCLASSES] = {
X/* 0*/	'\0',		/* placeholder for the "random class" */
X	ILLOBJ_SYM,
X	WEAPON_SYM,
X	ARMOR_SYM,
X	RING_SYM,
X/* 5*/	AMULET_SYM,
X	TOOL_SYM,
X	FOOD_SYM,
X	POTION_SYM,
X	SCROLL_SYM,
X/*10*/	SPBOOK_SYM,
X	WAND_SYM,
X	GOLD_SYM,
X	GEM_SYM,
X	ROCK_SYM,
X/*15*/	BALL_SYM,
X	CHAIN_SYM,
X	VENOM_SYM
X};
X
X/* Object descriptions.  Used in do_look(). */
Xconst char *objexplain[] = {	/* these match def_oc_syms, above */
X/* 0*/	0,
X	"strange object",
X	"weapon",
X	"suit or piece of armor",
X	"ring",
X/* 5*/	"amulet",
X	"useful item (pick-axe, key, lamp...)",
X	"piece of food",
X	"potion",
X	"scroll",
X/*10*/	"spell book",
X	"wand",
X	"pile of coins",
X	"gem or rock",
X	"boulder or statue",
X/*15*/	"iron ball",
X	"iron chain",
X	"splash of venom"
X};
X
X/* Object class names.  Used in object_detect(). */
Xconst char *oclass_names[] = {
X/* 0*/	0,
X	"illegal objects",
X	"weapons",
X	"armor",
X	"rings",
X/* 5*/	"amulets",
X	"tools",
X	"food",
X	"potions",
X	"scrolls",
X/*10*/	"spell books",
X	"wands",
X	"coins",
X	"rocks",
X	"large stones",
X/*15*/	"iron balls",
X	"chains",
X	"venoms"
X};
X
X/* Default monster class symbols.  See monsym.h. */
Xconst char def_monsyms[MAXMCLASSES] = {
X	'\0',		/* holder */
X	DEF_ANT,
X	DEF_BLOB,
X	DEF_COCKATRICE,
X	DEF_DOG,
X	DEF_EYE,
X	DEF_FELINE,
X	DEF_GREMLIN,
X	DEF_HUMANOID,
X	DEF_IMP,
X	DEF_JELLY,		/* 10 */
X	DEF_KOBOLD,
X	DEF_LEPRECHAUN,
X	DEF_MIMIC,
X	DEF_NYMPH,
X	DEF_ORC,
X	DEF_PIERCER,
X	DEF_QUADRUPED,
X	DEF_RODENT,
X	DEF_SPIDER,
X	DEF_TRAPPER,		/* 20 */
X	DEF_UNICORN,
X	DEF_VORTEX,
X	DEF_WORM,
X	DEF_XAN,
X	DEF_LIGHT,
X	DEF_ZRUTY,
X	DEF_ANGEL,
X	DEF_BAT,
X	DEF_CENTAUR,
X	DEF_DRAGON,		/* 30 */
X	DEF_ELEMENTAL,
X	DEF_FUNGUS,
X	DEF_GNOME,
X	DEF_GIANT,
X	DEF_STALKER,
X	DEF_JABBERWOCK,
X	DEF_KOP,
X	DEF_LICH,
X	DEF_MUMMY,
X	DEF_NAGA,		/* 40 */
X	DEF_OGRE,
X	DEF_PUDDING,
X	DEF_QUANTMECH,
X	DEF_RUSTMONST,
X	DEF_SNAKE,
X	DEF_TROLL,
X	DEF_UMBER,
X	DEF_VAMPIRE,
X	DEF_WRAITH,
X	DEF_XORN,		/* 50 */
X	DEF_YETI,
X	DEF_ZOMBIE,
X	DEF_HUMAN,
X	DEF_GHOST,
X	DEF_GOLEM,
X	DEF_DEMON,
X	DEF_EEL,
X	DEF_LIZARD,
X	DEF_WORM_TAIL,
X	DEF_MIMIC_DEF,		/* 60 */
X};
X
Xconst char *monexplain[MAXMCLASSES] = {
X    0,
X    "ant or other insect",	"blob",			"cockatrice",
X    "dog or other canine",	"eye or sphere",	"feline",
X    "gremlin",			"humanoid",		"imp or minor demon",
X    "jelly",			"kobold",		"leprechaun",
X    "mimic",			"nymph",		"orc",
X    "piercer",			"quadruped",		"rodent",
X    "spider",			"trapper or lurker above", "unicorn",
X    "vortex",		"worm", "xan or other mythical/fantastic insect",
X    "light",			"zruty",
X
X    "angelic being",		"bat",			"centaur",
X    "dragon",			"elemental",		"fungus or mold",
X    "gnome",			"giant humanoid",	"invisible stalker",
X    "jabberwock",		"Keystone Kop",		"lich",
X    "mummy",			"naga",			"ogre",
X    "pudding or ooze",		"quantum mechanic",	"rust monster",
X    "snake",			"troll",		"umber hulk",
X    "vampire",			"wraith",		"xorn",
X    "yeti, ape or other large beast", "zombie",
X
X    "human",			"ghost",		"golem",
X    "demon",			"sea monster",		"lizard",
X    "long worm tail",		"mimic"
X};
X
X/*
X *  Default screen symbols with explanations and colors.
X *  Note:  {ibm|dec|mac}_graphics[] arrays also depend on this symbol order.
X */
Xconst struct symdef defsyms[MAXPCHARS] = {
X/* 0*/	{' ', "dark part of a room",C(NO_COLOR)},	/* stone */
X	{'|', "wall",		C(GRAY)},	/* vwall */
X	{'-', "wall",		C(GRAY)},	/* hwall */
X	{'-', "wall",		C(GRAY)},	/* tlcorn */
X	{'-', "wall",		C(GRAY)},	/* trcorn */
X	{'-', "wall",		C(GRAY)},	/* blcorn */
X	{'-', "wall",		C(GRAY)},	/* brcorn */
X	{'-', "wall",		C(GRAY)},	/* crwall */
X	{'-', "wall",		C(GRAY)},	/* tuwall */
X	{'-', "wall",		C(GRAY)},	/* tdwall */
X/*10*/	{'|', "wall",		C(GRAY)},	/* tlwall */
X	{'|', "wall",		C(GRAY)},	/* trwall */
X	{'.', "doorway",	C(GRAY)},	/* ndoor */
X	{'-', "open door",	C(BROWN)},	/* vodoor */
X	{'|', "open door",	C(BROWN)},	/* hodoor */
X	{'+', "closed door",	C(BROWN)},	/* vcdoor */
X	{'+', "closed door",	C(BROWN)},	/* hcdoor */
X	{'.', "floor of a room",C(GRAY)},	/* room */
X	{'#', "corridor",	C(GRAY)},	/* dark corr */
X	{'#', "lit corridor",	C(GRAY)},	/* lit corr */
X/*20*/	{'<', "staircase up",	C(GRAY)},	/* upstair */
X	{'>', "staircase down",	C(GRAY)},	/* dnstair */
X	{'<', "ladder up",	C(BROWN)},	/* upladder */
X	{'>', "ladder down",	C(BROWN)},	/* dnladder */
X	{'^', "trap",		C(RED)},	/* trap */
X	{'"', "web",		C(GRAY)},	/* web */
X	{'_', "altar",		C(GRAY)},	/* altar */
X	{'\\', "opulent throne",C(HI_GOLD)},	/* throne */
X#ifdef SINKS
X	{'#', "sink",		C(GRAY)},	/* sink */
X#else
X	{'#', "",		C(GRAY)},	/* sink */
X#endif
X	{'{', "fountain",	C(BLUE)},	/* fountain */
X/*30*/	{'}', "water filled area",C(BLUE)},	/* pool */
X	{'.', "ice",		C(CYAN)},	/* ice */
X	{'}', "molten lava",	C(RED)},	/* lava */
X	{'.', "lowered drawbridge",C(BROWN)},	/* vodbridge */
X	{'.', "lowered drawbridge",C(BROWN)},	/* hodbridge */
X	{'#', "raised drawbridge",C(BROWN)},	/* vcdbridge */
X	{'#', "raised drawbridge",C(BROWN)},	/* hcdbridge */
X	{' ', "air filled area",C(CYAN)},	/* open air */
X	{'#', "cloud filled area",C(GRAY)},	/* part of a cloud */
X	{'}', "water filled area",C(BLUE)},	/* under water */
X/*40*/	{'|', "wall",		C(GRAY)},	/* vbeam */
X	{'-', "wall",		C(GRAY)},	/* hbeam */
X	{'\\',"wall",		C(GRAY)},	/* lslant */
X	{'/', "wall",		C(GRAY)},	/* rslant */
X	{'*', "",		C(WHITE)},	/* dig beam */
X	{'!', "",		C(WHITE)},	/* camera flash beam */
X	{')', "",		C(HI_METAL)},	/* boomerang open left */
X	{'(', "",		C(HI_METAL)},	/* boomerang open right */
X	{'0', "",		C(HI_ZAP)},	/* 4 magic shield symbols */
X	{'#', "",		C(HI_ZAP)},
X/*50*/	{'@', "",		C(HI_ZAP)},
X	{'*', "",		C(HI_ZAP)},
X	{'/', "",		C(GREEN)},	/* swallow top left	*/
X	{'-', "",		C(GREEN)},	/* swallow top center	*/
X	{'\\', "",		C(GREEN)},	/* swallow top right	*/
X	{'|', "",		C(GREEN)},	/* swallow middle left	*/
X	{'|', "",		C(GREEN)},	/* swallow middle right	*/
X	{'\\', "",		C(GREEN)},	/* swallow bottom left	*/
X	{'-', "",		C(GREEN)},	/* swallow bottom center*/
X	{'/', "",		C(GREEN)},	/* swallow bottom right	*/
X/*60*/	{'/', "",		C(ORANGE_COLORED)},/* explosion top left     */
X	{'-', "",		C(ORANGE_COLORED)},/* explosion top center   */
X	{'\\', "",		C(ORANGE_COLORED)},/* explosion top right    */
X	{'|', "",		C(ORANGE_COLORED)},/* explosion middle left  */
X	{' ', "",		C(ORANGE_COLORED)},/* explosion middle center*/
X	{'|', "",		C(ORANGE_COLORED)},/* explosion middle right */
X	{'\\', "",		C(ORANGE_COLORED)},/* explosion bottom left  */
X	{'-', "",		C(ORANGE_COLORED)},/* explosion bottom center*/
X	{'/', "",		C(ORANGE_COLORED)},/* explosion bottom right */
X/*
X *  Note: Additions to this array should be reflected in the
X *	  {ibm,dec,mac}_graphics[] arrays below.
X */
X};
X
X#undef C
X
X#ifdef ASCIIGRAPH
Xstatic uchar ibm_graphics[MAXPCHARS] = {
X/* 0*/	g_FILLER(S_stone),
X	0xb3,	/* S_vwall:	meta-3, vertical rule */
X	0xc4,	/* S_hwall:	meta-D, horizontal rule */
X	0xda,	/* S_tlcorn:	meta-Z, top left corner */
X	0xbf,	/* S_trcorn:	meta-?, top right corner */
X	0xc0,	/* S_blcorn:	meta-@, bottom left */
X	0xd9,	/* S_brcorn:	meta-Y, bottom right */
X	0xc5,	/* S_crwall:	meta-E, cross */
X	0xc1,	/* S_tuwall:	meta-A, T up */
X	0xc2,	/* S_tdwall:	meta-B, T down */
X/*10*/	0xb4,	/* S_tlwall:	meta-4, T left */
X	0xc3,	/* S_trwall:	meta-C, T right */
X	0xfa,	/* S_ndoor:	meta-z, centered dot */
X	0xfe,	/* S_vodoor:	meta-~, small centered square */
X	0xfe,	/* S_hodoor:	meta-~, small centered square */
X	g_FILLER(S_vcdoor),
X	g_FILLER(S_hcdoor),
X	0xfa,	/* S_room:	meta-z, centered dot */
X	0xb0,	/* S_corr:	meta-0, light shading */
X	0xb1,	/* S_litcorr:	meta-1, medium shading */
X/*20*/	g_FILLER(S_upstair),
X	g_FILLER(S_dnstair),
X	g_FILLER(S_upladder),
X	g_FILLER(S_dnladder),
X	g_FILLER(S_trap),
X	g_FILLER(S_web),
X	g_FILLER(S_altar),
X	g_FILLER(S_throne),
X	g_FILLER(S_sink),
X	0xf4,   /* S_fountain:  meta-t, integral top half */
X/*30*/	0xf7,	/* S_pool:	meta-w, approx. equals */
X	0xfa,	/* S_ice:	meta-z, centered dot */
X	0xf7,	/* S_lava:	meta-w, approx. equals */
X	0xfa,	/* S_vodbridge:	meta-z, centered dot */
X	0xfa,	/* S_hodbridge:	meta-z, centered dot */
X	g_FILLER(S_vcdbridge),
X	g_FILLER(S_hcdbridge),
X	g_FILLER(S_air),
X	g_FILLER(S_cloud),
X	0xf7,	/* S_water:	meta-w, approx. equals */
X/*40*/	0xb3,   /* S_vbeam:     meta-3, vertical rule */
X	0xc4,	/* S_hbeam:	meta-D, horizontal rule */
X	g_FILLER(S_lslant),
X	g_FILLER(S_rslant),
X	g_FILLER(S_digbeam),
X	g_FILLER(S_flashbeam),
X	g_FILLER(S_boomleft),
X	g_FILLER(S_boomright),
X	g_FILLER(S_ss1),
X	g_FILLER(S_ss2),
X/*50*/	g_FILLER(S_ss3),
X	g_FILLER(S_ss4),
X	g_FILLER(S_sw_tl),
X	g_FILLER(S_sw_tc),
X	g_FILLER(S_sw_tr),
X	0xb3,	/* S_sw_ml:	meta-3, vertical rule */
X	0xb3,	/* S_sw_mr:	meta-3, vertical rule */
X	g_FILLER(S_sw_bl),
X	g_FILLER(S_sw_bc),
X	g_FILLER(S_sw_br),
X/*60*/	g_FILLER(S_explode1),
X	g_FILLER(S_explode2),
X	g_FILLER(S_explode3),
X	0xb3,	/* S_explode4:	meta-3, vertical rule */
X	g_FILLER(S_explode5),
X	0xb3,	/* S_explode6:	meta-3, vertical rule */
X	g_FILLER(S_explode7),
X	g_FILLER(S_explode8),
X	g_FILLER(S_explode9)
X};
X#endif  /* ASCIIGRAPH */
X
X#ifdef TERMLIB
Xvoid NDECL((*decgraphics_mode_callback)) = 0;  /* set in tty_start_screen() */
X
Xstatic uchar dec_graphics[MAXPCHARS] = {
X/* 0*/	g_FILLER(S_stone),
X	0xf8,	/* S_vwall:	meta-x, vertical rule */
X	0xf1,	/* S_hwall:	meta-q, horizontal rule */
X	0xec,	/* S_tlcorn:	meta-l, top left corner */
X	0xeb,	/* S_trcorn:	meta-k, top right corner */
X	0xed,	/* S_blcorn:	meta-m, bottom left */
X	0xea,	/* S_brcorn:	meta-j, bottom right */
X	0xee,	/* S_crwall:	meta-n, cross */
X	0xf6,	/* S_tuwall:	meta-v, T up */
X	0xf7,	/* S_tdwall:	meta-w, T down */
X/*10*/	0xf5,	/* S_tlwall:	meta-u, T left */
X	0xf4,	/* S_trwall:	meta-t, T right */
X	0xfe,	/* S_ndoor:	meta-~, centered dot */
X	0xe1,	/* S_vodoor:	meta-a, solid block */
X	0xe1,	/* S_hodoor:	meta-a, solid block */
X	g_FILLER(S_vcdoor),
X	g_FILLER(S_hcdoor),
X	0xfe,	/* S_room:	meta-~, centered dot */
X	g_FILLER(S_corr),
X	g_FILLER(S_litcorr),
X/*20*/	g_FILLER(S_upstair),
X	g_FILLER(S_dnstair),
X	g_FILLER(S_upladder),
X	g_FILLER(S_dnladder),
X	g_FILLER(S_trap),
X	g_FILLER(S_web),	/* 0xbd, /* \E)3: meta-=, int'l currency */
X	g_FILLER(S_altar),	/* 0xc3, /* \E)3: meta-C, dagger */
X	g_FILLER(S_throne),
X	g_FILLER(S_sink),
X	g_FILLER(S_fountain),   /* 0xdb, /* \E)3: meta-[, integral top half */
X/*30*/	0xe0,	/* S_pool:	meta-\, diamond */
X	0xfe,	/* S_ice:	meta-~, centered dot */
X	0xe0,	/* S_lava:	meta-\, diamond */
X	0xfe,	/* S_vodbridge:	meta-~, centered dot */
X	0xfe,	/* S_hodbridge:	meta-~, centered dot */
X	g_FILLER(S_vcdbridge),
X	g_FILLER(S_hcdbridge),
X	g_FILLER(S_air),
X	g_FILLER(S_cloud),
X	0xe0,	/* S_water:	meta-\, diamond */
X/*40*/	0xf8,   /* S_vbeam:     meta-x, vertical rule */
X	0xf1,	/* S_hbeam:	meta-q, horizontal rule */
X	g_FILLER(S_lslant),
X	g_FILLER(S_rslant),
X	g_FILLER(S_digbeam),
X	g_FILLER(S_flashbeam),
X	g_FILLER(S_boomleft),
X	g_FILLER(S_boomright),
X	g_FILLER(S_ss1),
X	g_FILLER(S_ss2),
X/*50*/	g_FILLER(S_ss3),
X	g_FILLER(S_ss4),
X	g_FILLER(S_sw_tl),
X	0xef,	/* S_sw_tc:	meta-o, high horizontal line */
X	g_FILLER(S_sw_tr),
X	0xf8,	/* S_sw_ml:	meta-x, vertical rule */
X	0xf8,	/* S_sw_mr:	meta-x, vertical rule */
X	g_FILLER(S_sw_bl),
X	0xf3,	/* S_sw_bc:	meta-s, low horizontal line */
X	g_FILLER(S_sw_br),
X/*60*/	g_FILLER(S_explode1),
X	0xef,	/* S_explode2:	meta-o, high horizontal line */
X	g_FILLER(S_explode3),
X	0xf8,	/* S_explode4:	meta-x, vertical rule */
X	g_FILLER(S_explode5),
X	0xf8,	/* S_explode6:	meta-x, vertical rule */
X	g_FILLER(S_explode7),
X	0xf3,	/* S_explode8:	meta-s, low horizontal line */
X	g_FILLER(S_explode9)
X};
X#endif  /* TERMLIB */
X
X#ifdef MAC_GRAPHICS_ENV
Xstatic uchar mac_graphics[MAXPCHARS] = {
X/* 0*/	g_FILLER(S_stone),
X	0xba,	/* S_vwall */
X	0xcd,	/* S_hwall */
X	0xc9,	/* S_tlcorn */
X	0xbb,	/* S_trcorn */
X	0xc8,	/* S_blcorn */
X	0xbc,	/* S_brcorn */
X	0xce,	/* S_crwall */
X	0xca,	/* S_tuwall */
X	0xcb,	/* S_tdwall */
X/*10*/	0xb9,	/* S_tlwall */
X	0xcc,	/* S_trwall */
X	0xb0,	/* S_ndoor */
X	0xee,	/* S_vodoor */
X	0xee,	/* S_hodoor */
X	0xef,	/* S_vcdoor */
X	0xef,	/* S_hcdoor */
X	g_FILLER(S_Room),
X	0xB0,	/* S_corr */
X	g_FILLER(S_litcorr),
X/*20*/	g_FILLER(S_upstair),
X	g_FILLER(S_dnstair),
X	g_FILLER(S_upladder),
X	g_FILLER(S_dnladder),
X	g_FILLER(S_trap),
X	g_FILLER(S_web),
X	g_FILLER(S_altar),
X	g_FILLER(S_throne),
X	g_FILLER(S_sink),
X	g_FILLER(S_fountain),
X/*30*/	0xe0,
X	g_FILLER(S_ice),
X	g_FILLER(S_lava),
X	g_FILLER(S_vodbridge),
X	g_FILLER(S_hodbridge),
X	g_FILLER(S_vcdbridge),
X	g_FILLER(S_hcdbridge),
X	g_FILLER(S_air),
X	g_FILLER(S_cloud),
X	g_FILLER(S_water),
X/*40*/	g_FILLER(S_vbeam),
X	g_FILLER(S_hbeam),
X	g_FILLER(S_lslant),
X	g_FILLER(S_rslant),
X	g_FILLER(S_digbeam),
X	g_FILLER(S_flashbeam),
X	g_FILLER(S_boomleft),
X	g_FILLER(S_boomright),
X	g_FILLER(S_ss1),
X	g_FILLER(S_ss2),
X/*50*/	g_FILLER(S_ss3),
X	g_FILLER(S_ss4),
X	g_FILLER(S_sw_tl),
X	g_FILLER(S_sw_tc),
X	g_FILLER(S_sw_tr),
X	g_FILLER(S_sw_ml),
X	g_FILLER(S_sw_mr),
X	g_FILLER(S_sw_bl),
X	g_FILLER(S_sw_bc),
X	g_FILLER(S_sw_br),
X/*60*/	g_FILLER(S_explode1),
X	g_FILLER(S_explode2),
X	g_FILLER(S_explode3),
X	g_FILLER(S_explode4),
X	g_FILLER(S_explode5),
X	g_FILLER(S_explode6),
X	g_FILLER(S_explode7),
X	g_FILLER(S_explode8),
X	g_FILLER(S_explode9)
X};
X#endif  /* MAC_GRAPHICS_ENV */
X
X/*
X * Convert the given character to an object class.  If the character is not
X * recognized, then MAXOCLASSES is returned.  Used in invent.c, options.c,
X * pickup.c, sp_lev.c, and lev_main.c.
X */
Xint
Xdef_char_to_objclass(ch)
X    char ch;
X{
X    int i;
X    for (i = 1; i < MAXOCLASSES; i++)
X	if (ch == def_oc_syms[i]) break;
X    return i;
X}
X
X/*
X * Convert a character into a monster class.  This returns the _first_
X * match made.  If there are are no matches, return MAXMCLASSES.
X */
Xint
Xdef_char_to_monclass(ch)
X    char ch;
X{
X    int i;
X    for (i = 1; i < MAXMCLASSES; i++)
X	if (def_monsyms[i] == ch) break;
X    return i;
X}
X
Xvoid
Xassign_graphics(graph_chars, glth)
Xregister uchar *graph_chars;
Xregister int glth;
X{
X    register int i;
X
X    for (i = 0; i < MAXPCHARS; i++)
X	showsyms[i] = (((i < glth) && graph_chars[i]) ?
X		       graph_chars[i] : defsyms[i].sym);
X}
X
Xvoid
Xswitch_graphics(gr_set_flag)
Xint gr_set_flag;
X{
X    switch (gr_set_flag) {
X	default:
X	case ASCII_GRAPHICS:
X	    assign_graphics((uchar *)0, 0);
X	    break;
X#ifdef ASCIIGRAPH
X	case IBM_GRAPHICS:
X/*
X * Use the nice IBM Extended ASCII line-drawing characters (codepage 437).
X *
X * OS/2 defaults to a multilingual character set (codepage 850, corresponding
X * to the ISO 8859 character set.  We should probably do a VioSetCp() call to
X * set the codepage to 437.
X */
X	    flags.IBMgraphics = TRUE;
X	    flags.DECgraphics = FALSE;
X	    assign_graphics(ibm_graphics, SIZE(ibm_graphics));
X	    break;
X#endif /* ASCIIGRAPH */
X#ifdef TERMLIB
X	case DEC_GRAPHICS:
X/*
X * Use the VT100 line drawing character set.
X */
X	    flags.DECgraphics = TRUE;
X	    flags.IBMgraphics = FALSE;
X	    assign_graphics(dec_graphics, SIZE(dec_graphics));
X	    if (decgraphics_mode_callback) (*decgraphics_mode_callback)();
X	    break;
X#endif /* TERMLIB */
X#ifdef MAC_GRAPHICS_ENV
X	case MAC_GRAPHICS:
X	    assign_graphics(mac_graphics, SIZE(mac_graphics));
X	    break;
X#endif
X	}
X    return;
X}
X
X
X#ifdef REINCARNATION
X
X/*
X * saved display symbols for objects & features.
X */
Xstatic uchar save_oc_syms[MAXOCLASSES] = DUMMY;
Xstatic uchar save_showsyms[MAXPCHARS]  = DUMMY;
Xstatic uchar save_monsyms[MAXPCHARS]   = DUMMY;
X
Xstatic const uchar r_oc_syms[MAXOCLASSES] = {
X/* 0*/	'\0',
X	ILLOBJ_SYM,
X	WEAPON_SYM,
X	']',			/* armor */
X	RING_SYM,
X/* 5*/	',',			/* amulet */
X	TOOL_SYM,
X	':',			/* food */
X	POTION_SYM,
X	SCROLL_SYM,
X/*10*/	SPBOOK_SYM,
X	WAND_SYM,
X	GEM_SYM,		/* gold -- yes it's the same as gems */
X	GEM_SYM,
X	ROCK_SYM,
X/*15*/	BALL_SYM,
X	CHAIN_SYM,
X	VENOM_SYM
X};
X
X# ifdef ASCIIGRAPH
Xstatic const uchar IBM_r_oc_syms[MAXOCLASSES] = {	/* a la EPYX Rogue */
X/* 0*/	'\0',
X	ILLOBJ_SYM,
X	0x18,			/* weapon: up arrow */
X/*	0x0a, */ ARMOR_SYM,	/* armor:  Vert rect with o */
X/*	0x09, */ RING_SYM,	/* ring:   circle with arrow */
X/* 5*/	0x0c,			/* amulet: "female" symbol */
X	TOOL_SYM,
X	0x05,			/* food:   club (as in cards) */
X	0xad,			/* potion: upside down '!' */
X	0x0e,			/* scroll: musical note */
X/*10*/	SPBOOK_SYM,
X	0xe7,			/* wand:   greek tau */
X	0x0f,			/* gold:   yes it's the same as gems */
X	0x0f,			/* gems:   fancy '*' */
X	ROCK_SYM,
X/*15*/	BALL_SYM,
X	CHAIN_SYM,
X	VENOM_SYM
X};
X# endif /* ASCIIGRAPH */
X
Xvoid
Xassign_rogue_graphics(is_rlevel)
Xboolean is_rlevel;
X{
X    /* Adjust graphics display characters on Rogue levels */
X
X    if (is_rlevel) {
X	register int i;
X
X	(void) memcpy((genericptr_t)save_showsyms,
X		      (genericptr_t)showsyms, sizeof showsyms);
X	(void) memcpy((genericptr_t)save_oc_syms,
X		      (genericptr_t)oc_syms, sizeof oc_syms);
X	(void) memcpy((genericptr_t)save_monsyms,
X		      (genericptr_t)monsyms, sizeof monsyms);
X
X	/* Use a loop: char != uchar on some machines. */
X	for (i = 0; i < MAXMCLASSES; i++)
X	    monsyms[i] = def_monsyms[i];
X	for (i = 0; i < MAXPCHARS; i++)
X	    showsyms[i] = defsyms[i].sym;
X
X/*
X * Some day if these rogue showsyms get much more extensive than this,
X * we may want to create r_showsyms, and IBM_r_showsyms arrays to hold
X * all of this info and to simply initialize it via a for() loop like r_oc_syms.
X */
X
X# ifdef ASCIIGRAPH
X	if (!flags.IBMgraphics) {
X# endif
X	    showsyms[S_vodoor]  = showsyms[S_hodoor]  = showsyms[S_ndoor] = '+';
X	    showsyms[S_upstair] = showsyms[S_dnstair] = '%';
X# ifdef ASCIIGRAPH
X	} else {
X	    /* a la EPYX Rogue */
X	    showsyms[S_vwall]   = 0xba; /* all walls now use	*/
X	    showsyms[S_hwall]   = 0xcd; /* double line graphics	*/
X	    showsyms[S_tlcorn]  = 0xc9;
X	    showsyms[S_trcorn]  = 0xbb;
X	    showsyms[S_blcorn]  = 0xc8;
X	    showsyms[S_brcorn]  = 0xbc;
X	    showsyms[S_crwall]  = 0xce;
X	    showsyms[S_tuwall]  = 0xca;
X	    showsyms[S_tdwall]  = 0xcb;
X	    showsyms[S_trwall]  = 0xcc;
X	    showsyms[S_tlwall]  = 0xb9;
X	    showsyms[S_corr]    = 0xb1;
X	    showsyms[S_litcorr] = 0xb2;
X	    showsyms[S_upstair] = 0xf0; /* Greek Xi */
X	    showsyms[S_dnstair] = 0xf0;
X	    showsyms[S_trap]    = 0x04; /* diamond (cards) */
X	    showsyms[S_vodoor]  = 0xce;
X	    showsyms[S_hodoor]  = 0xce;
X	    showsyms[S_ndoor]   = 0xce;
X	}
X#endif /* ASCIIGRAPH */
X
X	for (i = 0; i < MAXOCLASSES; i++) {
X#ifdef ASCIIGRAPH
X	    if (flags.IBMgraphics)
X		oc_syms[i] = IBM_r_oc_syms[i];
X	    else
X#endif /* ASCIIGRAPH */
X		oc_syms[i] = r_oc_syms[i];
X	}
X
X    } else {
X	(void) memcpy((genericptr_t)showsyms,
X		      (genericptr_t)save_showsyms, sizeof showsyms);
X	(void) memcpy((genericptr_t)oc_syms,
X		      (genericptr_t)save_oc_syms, sizeof oc_syms);
X	(void) memcpy((genericptr_t)monsyms,
X		      (genericptr_t)save_monsyms, sizeof monsyms);
X    }
X}
X#endif /* REINCARNATION */
X
X/*drawing.c*/
END_OF_FILE
if test 19138 -ne `wc -c <'src/drawing.c'`; then
    echo shar: \"'src/drawing.c'\" unpacked with wrong size!
fi
# end of 'src/drawing.c'
fi
echo shar: End of archive 65 \(of 108\).
cp /dev/null ark65isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \
21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \
41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 \
61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 \
81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 \
101 102 103 104 105 106 107 108 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 108 archives.
    echo "Now execute 'rebuild.sh'"
    rm -f ark10[0-8]isdone ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
