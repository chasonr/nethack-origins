Path: uunet!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v16i102:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Part94/108
Message-ID: <4467@master.CNA.TEK.COM>
Date: 5 Feb 93 22:02:54 GMT
Sender: news@master.CNA.TEK.COM
Lines: 1844
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1653

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 16, Issue 102
Archive-name: nethack31/Part94
Supersedes: nethack3p9: Volume 10, Issue 46-108
Environment: Amiga, Atari, Mac, MS-DOS, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 94 (of 108)."
# Contents:  include/vmsconf.h src/o_init.c src/rumors.c
#   sys/msdos/ovlmgr.uu sys/unix/unixmain.c sys/vms/Makefile.utl
# Wrapped by billr@saab on Wed Jan 27 16:09:26 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'include/vmsconf.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/vmsconf.h'\"
else
echo shar: Extracting \"'include/vmsconf.h'\" \(6950 characters\)
sed "s/^X//" >'include/vmsconf.h' <<'END_OF_FILE'
X/*	SCCS Id: @(#)vmsconf.h	3.1	92/12/11	*/
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#ifdef VMS
X#ifndef VMSCONF_H
X#define VMSCONF_H
X
X/*
X * Edit these to choose values appropriate for your site.
X * WIZARD is the username allowed to use the debug option of nethack; no harm
X *   is done by leaving it as a username that doesn't exist at your site.
X * HACKDIR can be overridden at run-time with the logical name HACKDIR, as in
X *   $ define hackdir disk$users:[games.nethack]
X * Trailing NULs are present in the default values in order to make some
X *   extra room for patching longer values into an existing executable.
X */
X#define Local_WIZARD	"NHWIZARD\0\0\0\0"
X#define Local_HACKDIR	"DISK$USERS:[GAMES.NETHACK.3-1-0.PLAY]\0\0\0\0\0\0"
X
X/*
X * This section cleans up the stuff done in config.h so that it
X * shouldn't need to be modified.  It's conservative so that if
X * config.h is actually edited, the changes won't impact us.
X */
X#ifdef UNIX
X# undef UNIX
X#endif
X#ifdef HACKDIR
X# undef HACKDIR
X#endif
X#ifdef WIZARD
X# undef WIZARD
X#endif
X#ifdef WIZARD_NAME
X# undef WIZARD_NAME
X#endif
X#define HACKDIR Local_HACKDIR
X#ifndef KR1ED
X# define WIZARD Local_WIZARD
X# define WIZARD_NAME WIZARD
X#else
X# define WIZARD 1
X# define WIZARD_NAME Local_WIZARD
X#endif
X
X/* filenames require punctuation to avoid redirection via logical names */
X#undef RECORD
X#define RECORD	"record;1"	/* scoreboard file (retains high scores) */
X#undef LOGFILE
X#define LOGFILE	"logfile;0"	/* optional file (records all games) */
X
X#define HLOCK	"perm;1"	/* an empty file used for locking purposes */
X
X/* want compression--for level & save files--performed within NetHack itself */
X#ifdef COMPRESS
X# undef COMPRESS
X#endif
X#ifndef ZEROCOMP
X# define ZEROCOMP
X#endif
X
X/* vision algorithm */
X#ifdef VISION_TABLES
X# if defined(VAXC) && defined(BRACES)
X#  undef BRACES
X# endif
X# if defined(__GNUC__) && !defined(BRACES)
X#  define BRACES		/* put braces around rows of 2d arrays */
X# endif
X#else	/* not VISION_TABLES */
X# define MACRO_CPATH	/* use clear_path macro instead of function */
X#endif
X
X/*
X * If nethack.exe will be installed with privilege so that the playground
X * won't need to be left unprotected, define SECURE to suppress a couple
X * of file protection fixups (protection of bones files and ownership of
X * save files).
X */
X/* #define SECURE /**/
X
X/*
X * You may define TEXTCOLOR if your system has any terminals that recognize
X * ANSI color sequences of the form ``<ESCAPE>[#;#m'', where the first # is
X * a number between 40 and 47 represented background color, and the second
X * # is a number between 30 and 37 representing the foreground color.
X * GIGI terminals and DECterm windows on color VAXstations support these
X * color escape sequences, as do some 3rd party terminals and many micro
X * computers.
X */
X/* #define TEXTCOLOR /**/
X
X/*
X * If you define USE_QIO_INPUT, then you'll get raw characters from the
X * keyboard, not unlike those of the unix version of Nethack.  This will
X * allow you to use the Escape key in normal gameplay, and the appropriate
X * control characters in Wizard mode.  It will work most like the unix version.
X * It will also avoid "<interrupt>" being displayed when ^Y is pressed.
X *
X * Otherwise, the VMS SMG calls will be used.  These calls block use of
X * the escape key, as well as certain control keys, so gameplay is not
X * the same, although the differences are fairly negligible.  You must
X * then use a VTxxx function key or two <escape>s to give an ESC response.
X */
X#define USE_QIO_INPUT	/* use SYS$QIOW instead of SMG$READ_KEYSTROKE */
X
X/*
X * If you define MAIL, then NetHack will capture incoming broadcast
X * messages such as "New mail from so-and-so" and "Print job completed,"
X * and then deliver them to the player.  For mail and phone broadcasts
X * a scroll of mail will be created, which when read will cause NetHack
X * to prompt the player for a command to spawn in order to respond.  The
X * latter capability will not be available if SHELL is disabled below.
X * If you undefine MAIL, broadcasts will go straight to the terminal,
X * resulting in disruption of the screen display; use <ctrl/R> to redraw.
X */
X#define MAIL		/* enable broadcast trapping */
X
X/*
X * SHELL enables the player to 'escape' into a spawned subprocess via
X * the '!' command.  Logout or attach back to the parent to resume play.
X * If the player attaches back to NetHack, then a subsequent escape will
X * re-attach to the existing subprocess.  Any such subprocess left over
X * at game exit will be deleted by an exit handler.
X * SUSPEND enables someone running NetHack in a subprocess to reconnect
X * to the parent process with the <ctrl/Z> command; this is not very
X * close to Unix job control, but it's better than nothing.
X */
X#define SHELL		/* do not delete the '!' command */
X#define SUSPEND		/* don't delete the ^Z command, such as it is */
X
X#define RANDOM		/* use sys/share/random.c instead of vaxcrtl rand */
X
X#define FCMASK	0660	/* file creation mask */
X
X/*
X * The remainder of the file should not need to be changed.
X */
X
X#if defined(VAXC) && !defined(ANCIENT_VAXC)
X# ifdef volatile
X#  undef volatile
X# endif
X# ifdef const
X#  undef const
X# endif
X#endif
X
X#ifdef __DECC
X# define STRICT_REF_DEF	/* used in lev_main.c */
X#endif
X#ifdef STRICT_REF_DEF
X# define DEFINE_OSPEED
X#endif
X
X#ifndef alloca
X	/* bison generated foo_yacc.c might try to use alloca() */
X# ifdef __GNUC__
X#  define alloca __builtin_alloca
X# else
X#  define ALLOCA_HACK	/* used in util/panic.c */
X# endif
X#endif
X
X#include <time.h>
X#if 0	/* <file.h> is missing for old gcc versions; skip it to save time */
X#include <file.h>
X#else	/* values needed from missing include file */
X# define O_RDONLY 0
X# define O_WRONLY 1
X# define O_RDWR   2
X# define O_CREAT 0x200
X#endif
X
X#ifndef REDO
X# define Getchar nhgetch
X#endif
X#define tgetch vms_getchar
X
X#include "system.h"
X
X#define index	strchr
X#define rindex	strrchr
X
X/* Use the high quality random number routines. */
X#if defined(RANDOM)
X#define Rand()	random()
X#else
X#define Rand()	rand()
X#endif
X
X#ifndef __GNUC__
X#define bcopy(s,d,n)	memcpy((d),(s),(n))	/* vaxcrtl */
X#endif
X#define abort()		vms_abort()		/* vmsmisc.c */
X#define creat(f,m)	vms_creat(f,m)		/* vmsfiles.c */
X#define exit(sts)	vms_exit(sts)		/* vmsmisc.c */
X#define getuid()	vms_getuid()		/* vmsunix.c */
X#define link(f1,f2)	vms_link(f1,f2)		/* vmsfiles.c */
X#define open(f,k,m)	vms_open(f,k,m)		/* vmsfiles.c */
X/* #define unlink(f0)	vms_unlink(f0)		/* vmsfiles.c */
X#ifdef VERYOLD_VMS
X#define unlink(f0)	delete(f0)		/* vaxcrtl */
X#else
X#define unlink(f0)	remove(f0)		/* vaxcrtl, decc$shr */
X#endif
X#define C$$TRANSLATE(n)	c__translate(n)	/* vmsfiles.c */
X
X/* VMS global names are case insensitive... */
X#define An vms_an
X#define The vms_the
X
X/* used in several files which don't #include "extern.h" */
Xextern void FDECL(vms_exit, (int));
X
X#endif	/* VMSCONF_H */
X#endif	/* VMS */
END_OF_FILE
if test 6950 -ne `wc -c <'include/vmsconf.h'`; then
    echo shar: \"'include/vmsconf.h'\" unpacked with wrong size!
fi
# end of 'include/vmsconf.h'
fi
if test -f 'src/o_init.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/o_init.c'\"
else
echo shar: Extracting \"'src/o_init.c'\" \(9274 characters\)
sed "s/^X//" >'src/o_init.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)o_init.c	3.1	92/12/11	*/
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include	"hack.h"		/* for typedefs */
X
Xstatic void NDECL(setgemprobs);
Xstatic void FDECL(shuffle,(int,int,BOOLEAN_P));
Xstatic boolean FDECL(interesting_to_discover,(int));
X
X/* note that NROFOBJECTS is the number of legal objects, which does not count
X * the strange object and null object that take up positions 0 and NROFOBJECTS+1
X * in the objects array
X */
X#define TOTAL_OBJS	(NROFOBJECTS+2)
X
Xconst char obj_symbols[] = {
X	ILLOBJ_CLASS, AMULET_CLASS, GOLD_CLASS, FOOD_CLASS, WEAPON_CLASS,
X	TOOL_CLASS, BALL_CLASS, CHAIN_CLASS, ROCK_CLASS, ARMOR_CLASS,
X	POTION_CLASS, SCROLL_CLASS, WAND_CLASS,
X	SPBOOK_CLASS, RING_CLASS, GEM_CLASS, 0 };
X
Xstatic short NEARDATA disco[TOTAL_OBJS] = DUMMY;
X
Xint
Xletindex(acls) register char acls; {
Xregister int i = 0;
Xregister char ch;
X	while ((ch = obj_symbols[i++]) != 0)
X		if (ch == acls) return(i);
X	return(0);
X}
X
Xstatic void
Xsetgemprobs()
X{
X	register int j, first;
X	int lev = (ledger_no(&u.uz) > maxledgerno())
X				? maxledgerno() : ledger_no(&u.uz);
X
X	first = bases[letindex(GEM_CLASS)];
X
X	for(j = 0; j < 9-lev/3; j++)
X		objects[first+j].oc_prob = 0;
X	first += j;
X	if (first > LAST_GEM || objects[first].oc_class != GEM_CLASS ||
X	    OBJ_NAME(objects[first]) == NULL) {
X		raw_printf("Not enough gems? - first=%d j=%d LAST_GEM=%d",
X			first, j, LAST_GEM);
X		wait_synch();
X	    }
X	for (j = first; j <= LAST_GEM; j++)
X		objects[j].oc_prob = (184+j-first)/(LAST_GEM+1-first);
X}
X
X/* shuffle descriptions on objects o_low to o_high */
Xstatic void
Xshuffle(o_low, o_high, domaterial)
X	register int o_low, o_high;
X	register boolean domaterial;
X{
X	register int i, j;
X#ifdef TEXTCOLOR
X	int color;
X#endif /* TEXTCOLOR */
X	register short sw;
X
X	for (j=o_low; j <= o_high; j++) {
X		i = o_low + rn2(j+1-o_low);
X		sw = objects[j].oc_descr_idx;
X		objects[j].oc_descr_idx = objects[i].oc_descr_idx;
X		objects[i].oc_descr_idx = sw;
X#ifdef TEXTCOLOR
X		color = objects[j].oc_color;
X		objects[j].oc_color = objects[i].oc_color;
X		objects[i].oc_color = color;
X#endif /* TEXTCOLOR */
X		/* shuffle material */
X		if (domaterial) {
X			sw = objects[j].oc_material;
X			objects[j].oc_material = objects[i].oc_material;
X			objects[i].oc_material = sw;
X		}
X	}
X}
X
Xvoid
Xinit_objects(){
Xregister int i, j, first, last, sum, end;
Xregister char acls;
X#ifdef TEXTCOLOR
X# define COPY_OBJ_DESCR(o_dst,o_src) \
X			o_dst.oc_descr_idx = o_src.oc_descr_idx,\
X			o_dst.oc_color = o_src.oc_color
X#else
X# define COPY_OBJ_DESCR(o_dst,o_src) o_dst.oc_descr_idx = o_src.oc_descr_idx
X#endif
X
X	/* bug fix to prevent "initialization error" abort on Intel Xenix.
X	 * reported by mikew@semike
X	 */
X	for (i = 0; i < sizeof(obj_symbols); i++)
X		bases[i] = 0;
X	/* initialize object descriptions */
X	for (i = 0; i < TOTAL_OBJS; i++)
X		objects[i].oc_name_idx = objects[i].oc_descr_idx = i;
X	init_artifacts();
X	/* init base; if probs given check that they add up to 1000,
X	   otherwise compute probs; shuffle descriptions */
X	end = TOTAL_OBJS;
X	first = 0;
X	while( first < end ) {
X		acls = objects[first].oc_class;
X		last = first+1;
X		while (last < end && objects[last].oc_class == acls) last++;
X		i = letindex(acls);
X		if ((!i && acls != ILLOBJ_CLASS && acls != VENOM_CLASS) ||
X								bases[i] != 0)
X			error("initialization error for object class %d", acls);
X		bases[i] = first;
X
X		if (acls == GEM_CLASS) setgemprobs();
X	check:
X		sum = 0;
X		for(j = first; j < last; j++) sum += objects[j].oc_prob;
X		if(sum == 0) {
X			for(j = first; j < last; j++)
X			    objects[j].oc_prob = (1000+j-first)/(last-first);
X			goto check;
X		}
X		if(sum != 1000)
X			error("init-prob error for %d (%d%%)", acls, sum);
X
X		if (OBJ_DESCR(objects[first]) != NULL &&
X		   acls != TOOL_CLASS && acls != WEAPON_CLASS && acls != ARMOR_CLASS) {
X
X		    /* shuffle, also some additional descriptions */
X		    while (last < end && objects[last].oc_class == acls)
X			last++;
X		    j = last;
X		    if (acls == GEM_CLASS) {
X			if (rn2(2)) { /* change turquoise from green to blue? */
X			    COPY_OBJ_DESCR(objects[TURQUOISE],objects[SAPPHIRE]);
X			}
X			if (rn2(2)) { /* change aquamarine from green to blue? */
X			    COPY_OBJ_DESCR(objects[AQUAMARINE],objects[SAPPHIRE]);
X			}
X			switch (rn2(4)) { /* change fluorite from violet? */
X			    case 0:  break;
X			    case 1:	/* blue */
X				COPY_OBJ_DESCR(objects[FLUORITE],objects[SAPPHIRE]);
X				break;
X			    case 2:	/* white */
X				COPY_OBJ_DESCR(objects[FLUORITE],objects[DIAMOND]);
X				break;
X			    case 3:	/* green */
X				COPY_OBJ_DESCR(objects[FLUORITE],objects[EMERALD]);
X				break;
X			}
X		    } else {
X			if (acls == POTION_CLASS)
X			    j--;  /* only water has a fixed description */
X			else if (acls == AMULET_CLASS ||
X				 acls == SCROLL_CLASS ||
X				 acls == SPBOOK_CLASS)
X			    do { j--; }
X			    while (!objects[j].oc_magic || objects[j].oc_unique);
X			/* non-magical amulets, scrolls, and spellbooks
X			 * (ex. imitation Amulets, blank, scrolls of mail)
X			 * and one-of-a-kind magical artifacts at the end of
X			 * their class in objects[] have fixed descriptions.
X			 */
X			shuffle(first, --j, TRUE);
X		    }
X		}
X		first = last;
X	}
X
X	/* shuffle the helmets */
X	shuffle(HELMET, HELM_OF_TELEPATHY, FALSE);
X
X	/* shuffle the gloves */
X	shuffle(LEATHER_GLOVES, GAUNTLETS_OF_DEXTERITY, FALSE);
X
X	/* shuffle the cloaks */
X	shuffle(CLOAK_OF_PROTECTION, CLOAK_OF_DISPLACEMENT, FALSE);
X
X	/* shuffle the boots [if they change, update find_skates() below] */
X	shuffle(SPEED_BOOTS, LEVITATION_BOOTS, FALSE);
X}
X
X/* find the object index for snow boots; used [once] by slippery ice code */
Xint
Xfind_skates()
X{
X    register int i;
X    register const char *s;
X
X    for (i = SPEED_BOOTS; i <= LEVITATION_BOOTS; i++)
X	if ((s = OBJ_DESCR(objects[i])) != 0 && !strcmp(s, "snow boots"))
X	    return i;
X
X    impossible("snow boots not found?");
X    return -1;	/* not 0, or caller would try again each move */
X}
X
Xvoid
Xoinit()			/* level dependent initialization */
X{
X	setgemprobs();
X}
X
Xvoid
Xsavenames(fd)
Xregister int fd;
X{
X	register int i;
X	unsigned int len;
X
X	bwrite(fd, (genericptr_t)bases, MAXOCLASSES * sizeof *bases);
X	bwrite(fd, (genericptr_t)disco, sizeof disco);
X	bwrite(fd, (genericptr_t)objects, sizeof(struct objclass) * TOTAL_OBJS);
X	/* as long as we use only one version of Hack we
X	   need not save oc_name and oc_descr, but we must save
X	   oc_uname for all objects */
X	for(i=0; i < TOTAL_OBJS; i++) {
X		if(objects[i].oc_uname) {
X			len = strlen(objects[i].oc_uname)+1;
X			bwrite(fd, (genericptr_t)&len, sizeof len);
X			bwrite(fd, (genericptr_t)objects[i].oc_uname, len);
X		}
X	}
X}
X
Xvoid
Xrestnames(fd)
Xregister int fd;
X{
X	register int i;
X	unsigned int len;
X
X	mread(fd, (genericptr_t) bases, MAXOCLASSES * sizeof *bases);
X	mread(fd, (genericptr_t) disco, sizeof disco);
X	mread(fd, (genericptr_t) objects, sizeof(struct objclass) * TOTAL_OBJS);
X	for(i=0; i < TOTAL_OBJS; i++) {
X		if (objects[i].oc_uname) {
X			mread(fd, (genericptr_t) &len, sizeof len);
X			objects[i].oc_uname = (char *) alloc(len);
X			mread(fd, (genericptr_t)objects[i].oc_uname, len);
X		}
X	}
X}
X
Xvoid
Xdiscover_object(oindx, mark_as_known)
Xregister int oindx;
Xboolean mark_as_known;
X{
X    if (!objects[oindx].oc_name_known) {
X	register int dindx, acls = objects[oindx].oc_class;
X
X	/* Loop thru disco[] 'til we find the target (which may have been
X	   uname'd) or the next open slot; one or the other will be found
X	   before we reach the next class...
X	 */
X	for (dindx = bases[letindex(acls)]; disco[dindx] != 0; dindx++)
X	    if (disco[dindx] == oindx) break;
X	disco[dindx] = oindx;
X
X	if (mark_as_known) {
X	    objects[oindx].oc_name_known = 1;
X	    exercise(A_WIS, TRUE);
X	}
X    }
X}
X
X/* if a class name has been cleared, we may need to purge it from disco[] */
Xvoid
Xundiscover_object(oindx)
Xregister int oindx;
X{
X    if (!objects[oindx].oc_name_known) {
X	register int dindx, acls = objects[oindx].oc_class;
X	register boolean found = FALSE;
X
X	/* find the object; shift those behind it forward one slot */
X	for (dindx = bases[letindex(acls)];
X	      dindx <= NROFOBJECTS && disco[dindx] != 0
X		&& objects[dindx].oc_class == acls; dindx++)
X	    if (found)
X		disco[dindx-1] = disco[dindx];
X	    else if (disco[dindx] == oindx)
X		found = TRUE;
X
X	/* clear last slot */
X	if (found) disco[dindx-1] = 0;
X	else impossible("named object not in disco");
X    }
X}
X
Xstatic boolean
Xinteresting_to_discover(i)
Xregister int i;
X{
X    return objects[i].oc_uname != NULL ||
X		(objects[i].oc_name_known && OBJ_DESCR(objects[i]) != NULL);
X}
X
Xint
Xdodiscovered()				/* free after Robert Viduya */
X{
X    register int i, dis;
X    int	ct = 0;
X    char class = -1;
X    winid tmpwin;
X
X    tmpwin = create_nhwindow(NHW_MENU);
X    putstr(tmpwin, 0, "Discoveries");
X    putstr(tmpwin, 0, "");
X
X    for (i = 0; i <= NROFOBJECTS; i++) {
X	if ((dis = disco[i]) && interesting_to_discover(dis)) {
X	    ct++;
X	    if (objects[dis].oc_class != class) {
X		class = objects[dis].oc_class;
X		putstr(tmpwin, ATR_INVERSE, let_to_name(class, FALSE));
X	    }
X	    putstr(tmpwin, 0, typename(dis));
X	}
X    }
X    if (ct == 0) {
X	You("haven't discovered anything yet...");
X    } else
X	display_nhwindow(tmpwin, TRUE);
X    destroy_nhwindow(tmpwin);
X
X    return 0;
X}
X
X/*o_init.c*/
END_OF_FILE
if test 9274 -ne `wc -c <'src/o_init.c'`; then
    echo shar: \"'src/o_init.c'\" unpacked with wrong size!
fi
# end of 'src/o_init.c'
fi
if test -f 'src/rumors.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/rumors.c'\"
else
echo shar: Extracting \"'src/rumors.c'\" \(9099 characters\)
sed "s/^X//" >'src/rumors.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)rumors.c	3.1	92/12/05	*/
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include "hack.h"
X
X/*	[note: this comment is fairly old, but still accurate for 3.1]
X * Rumors have been entirely rewritten to speed up the access.  This is
X * essential when working from floppies.  Using fseek() the way that's done
X * here means rumors following longer rumors are output more often than those
X * following shorter rumors.  Also, you may see the same rumor more than once
X * in a particular game (although the odds are highly against it), but
X * this also happens with real fortune cookies.  -dgk
X */
X
X/*	3.1
X * The rumors file consists of a "do not edit" line, a hexadecimal number
X * giving the number of bytes of useful/true rumors, followed by those
X * true rumors (one per line), followed by the useless/false/misleading/cute
X * rumors (also one per line).  Number of bytes of untrue rumors is derived
X * via fseek(EOF)+ftell().
X *
X * The oracles file consists of a "do not edit" comment, a decimal count N
X * and set of N+1 hexadecimal fseek offsets, followed by N multiple-line
X * records, separated by "---" lines.  The first oracle is a special case,
X * and placed there by 'makedefs'.
X */
X
X#ifndef SEEK_SET
X# define SEEK_SET 0
X#endif
X#ifndef SEEK_CUR
X# define SEEK_CUR 1
X#endif
X#ifndef SEEK_END	/* aka SEEK_EOF */
X# define SEEK_END 2
X#endif
X
Xstatic void FDECL(init_rumors, (FILE *));
Xstatic void FDECL(init_oracles, (FILE *));
Xstatic void FDECL(outoracle, (BOOLEAN_P));
X
Xstatic long true_rumor_start,  true_rumor_size,  true_rumor_end,
X	    false_rumor_start, false_rumor_size, false_rumor_end;
Xstatic int oracle_flg = 0;  /* -1=>don't use, 0=>need init, 1=>init done */
Xstatic unsigned oracle_cnt = 0;
Xstatic long *oracle_loc = 0;
X
Xstatic void
Xinit_rumors(fp)
XFILE *fp;
X{
X	char line[BUFSZ];
X
X	(void) fgets(line, sizeof line, fp);	/* skip "don't edit" comment */
X	if (fscanf(fp, "%6lx\n", &true_rumor_size) == 1 &&
X	    true_rumor_size > 0L) {
X	    (void) fseek(fp, 0L, SEEK_CUR);
X	    true_rumor_start  = ftell(fp);
X	    true_rumor_end    = true_rumor_start + true_rumor_size;
X	    (void) fseek(fp, 0L, SEEK_END);
X	    false_rumor_end   = ftell(fp);
X	    false_rumor_start = true_rumor_end;	/* ok, so it's redundant... */
X	    false_rumor_size  = false_rumor_end - false_rumor_start;
X	} else
X	    true_rumor_size = -1L;	/* init failed */
X}
X
Xchar *
Xgetrumor(truth)
Xint truth; /* 1=true, -1=false, 0=either */
X{
X	static char rumor_buf[COLNO + 28];
X	FILE	*rumors;
X	long tidbit, beginning;
X	char	*endp, line[sizeof rumor_buf];
X
X	rumor_buf[0] = '\0';
X	if (true_rumor_size < 0L)	/* we couldn't open RUMORFILE */
X		return rumor_buf;
X
X	rumors = fopen_datafile(RUMORFILE, "r");
X
X	if (rumors) {
X		if (true_rumor_size == 0L) {	/* if this is 1st outrumor() */
X		    init_rumors(rumors);
X		    if (true_rumor_size < 0L) {	/* init failed */
X			Sprintf(rumor_buf, "Error reading \"%.80s\".",
X				RUMORFILE);
X			return rumor_buf;
X		    }
X		}
X		/*
X		 *	input:      1    0   -1
X		 *	 rn2 \ +1  2=T  1=T  0=F
X		 *	 adj./ +0  1=T  0=F -1=F
X		 */
X		switch (truth += rn2(2)) {
X		  case  2:	/*(might let a bogus input arg sneak thru)*/
X		  case  1:  beginning = true_rumor_start;
X			    tidbit = Rand() % true_rumor_size;
X			break;
X		  case  0:	/* once here, 0 => false rather than "either"*/
X		  case -1:  beginning = false_rumor_start;
X			    tidbit = Rand() % false_rumor_size;
X			break;
X		  default:
X			    impossible("strange truth value for rumor");
X			return strcpy(rumor_buf, "Oops...");
X		}
X		(void) fseek(rumors, beginning + tidbit, SEEK_SET);
X		(void) fgets(line, sizeof line, rumors);
X		if (!fgets(line, sizeof line, rumors) ||
X		    (truth > 0 && ftell(rumors) > true_rumor_end)) {
X			/* reached end of rumors -- go back to beginning */
X			(void) fseek(rumors, beginning, SEEK_SET);
X			(void) fgets(line, sizeof line, rumors);
X		}
X		if ((endp = index(line, '\n')) != 0) *endp = 0;
X		Strcat(rumor_buf, xcrypt(line));
X		(void) fclose(rumors);
X		exercise(A_WIS, (truth > 0));
X	} else {
X		pline("Can't open rumors file!");
X		true_rumor_size = -1;	/* don't try to open it again */
X	}
X	return rumor_buf;
X}
X
Xvoid
Xoutrumor(truth, cookie)
Xint truth; /* 1=true, -1=false, 0=either */
Xboolean cookie;
X{
X	static const char fortune_msg[] =
X		"This cookie has a scrap of paper inside.";
X	const char *line;
X
X	if (cookie && Blind) {
X		pline(fortune_msg);
X		pline("What a pity that you cannot read it!");
X		return;
X	}
X	line = getrumor(truth);
X	if (!*line)
X		line = "NetHack rumors file closed for renovation.";
X	if (cookie) {
X		pline(fortune_msg);
X		pline("It reads:");
X		pline("%s", line);
X	} else {	/* if the Oracle is the only alternative */
X		pline("True to her word, the Oracle %ssays: ",
X		(!rn2(4) ? "offhandedly " : (!rn2(3) ? "casually " :
X		(rn2(2) ? "nonchalantly " : ""))));
X		verbalize("%s", line);
X		exercise(A_WIS, TRUE);
X	}
X}
X
Xstatic void
Xinit_oracles(fp)
XFILE *fp;
X{
X	register int i;
X	char line[BUFSZ];
X	int cnt = 0;
X
X	/* this assumes we're only called once */
X	(void) fgets(line, sizeof line, fp);	/* skip "don't edit" comment */
X	if (fscanf(fp, "%5d", &cnt) == 1 && cnt > 0) {
X	    oracle_cnt = (unsigned) cnt;
X	    oracle_loc = (long *) alloc(cnt * sizeof (long));
X	    for (i = 0; i < cnt; i++)
X		(void) fscanf(fp, "%5lx", &oracle_loc[i]);
X	}
X	return;
X}
X
Xvoid
Xsave_oracles(fd)
Xint fd;
X{
X	bwrite(fd, (genericptr_t) &oracle_cnt, sizeof oracle_cnt);
X	if (oracle_cnt)
X	    bwrite(fd, (genericptr_t) oracle_loc, oracle_cnt * sizeof (long));
X}
X
Xvoid
Xrestore_oracles(fd)
Xint fd;
X{
X	mread(fd, (genericptr_t) &oracle_cnt, sizeof oracle_cnt);
X	if (oracle_cnt) {
X	    oracle_loc = (long *) alloc(oracle_cnt * sizeof (long));
X	    mread(fd, (genericptr_t) oracle_loc, oracle_cnt * sizeof (long));
X	    oracle_flg = 1;	/* no need to call init_oracles() */
X	}
X}
X
Xstatic void
Xoutoracle(special)
Xboolean special;
X{
X	char	line[COLNO];
X	char	*endp;
X	FILE	*oracles;
X	int oracle_idx;
X
X	if(oracle_flg < 0 ||			/* couldn't open ORACLEFILE */
X	   (oracle_flg > 0 && oracle_cnt == 0))	/* oracles already exhausted */
X		return;
X
X	oracles = fopen_datafile(ORACLEFILE, "r");
X
X	if (oracles) {
X		winid tmpwin;
X		if (oracle_flg == 0) {	/* if this is the first outoracle() */
X			init_oracles(oracles);
X			oracle_flg = 1;
X			if (oracle_cnt == 0) return;
X		}
X		/* oracle_loc[0] is the special oracle;		*/
X		/* oracle_loc[1..oracle_cnt-1] are normal ones	*/
X		if (oracle_cnt <= 1 && !special) return;  /*(shouldn't happen)*/
X		oracle_idx = special ? 0 : rnd((int) oracle_cnt - 1);
X		(void) fseek(oracles, oracle_loc[oracle_idx], SEEK_SET);
X		if (!special) oracle_loc[oracle_idx] = oracle_loc[--oracle_cnt];
X
X		tmpwin = create_nhwindow(NHW_TEXT);
X		putstr(tmpwin, 0, special ?
X		      "The Oracle scornfully takes all your money and says:" :
X		      "The Oracle meditates for a moment and then intones:");
X		putstr(tmpwin, 0, "");
X
X		while (fgets(line, COLNO, oracles) && strcmp(line,"---\n")) {
X			if ((endp = index(line, '\n')) != 0) *endp = 0;
X			putstr(tmpwin, 0, xcrypt(line));
X		}
X		display_nhwindow(tmpwin, TRUE);
X		destroy_nhwindow(tmpwin);
X		(void) fclose(oracles);
X	} else {
X		pline("Can't open oracles file!");
X		oracle_flg = -1;	/* don't try to open it again */
X	}
X}
X
Xint
Xdoconsult(oracl)
Xregister struct monst *oracl;
X{
X	int u_pay, minor_cost = 50, major_cost = 500 + 50 * u.ulevel;
X	int add_xpts;
X	char qbuf[QBUFSZ];
X
X	multi = 0;
X
X	if (!oracl) {
X		pline("There is no one here to consult.");
X		return 0;
X	} else if (!oracl->mpeaceful) {
X		pline("The Oracle is in no mood for consultations.");
X		return 0;
X	} else if (!u.ugold) {
X		You("have no money.");
X		return 0;
X	}
X
X	Sprintf(qbuf,
X		"\"Wilt thou settle for a minor consultation?\" (%d zorkmids)",
X		minor_cost);
X	switch (ynq(qbuf)) {
X	    default:
X	    case 'q':
X		return 0;
X	    case 'y':
X		if (u.ugold < (long)minor_cost) {
X		    You("don't even have enough money for that!");
X		    return 0;
X		}
X		u_pay = minor_cost;
X		break;
X	    case 'n':
X		if (u.ugold <= (long)minor_cost ||	/* don't even ask */
X		    (oracle_cnt == 1 || oracle_flg < 0)) return 0;
X		Sprintf(qbuf,
X			"\"Then dost thou desire a major one?\" (%d zorkmids)",
X			major_cost);
X		if (yn(qbuf) != 'y') return 0;
X		u_pay = (u.ugold < (long)major_cost ? (int)u.ugold
X						    : major_cost);
X		break;
X	}
X	u.ugold -= (long)u_pay;
X	oracl->mgold += (long)u_pay;
X	flags.botl = 1;
X	add_xpts = 0;	/* first oracle of each type gives experience points */
X	if (u_pay == minor_cost) {
X		outrumor(1, FALSE);
X		if (!u.uevent.minor_oracle)
X		    add_xpts = u_pay / (u.uevent.major_oracle ? 25 : 10);
X		    /* 5 pts if very 1st, or 2 pts if major already done */
X		u.uevent.minor_oracle = TRUE;
X	} else {
X		boolean cheapskate = u_pay < major_cost;
X		outoracle(cheapskate);
X		if (!cheapskate && !u.uevent.major_oracle)
X		    add_xpts = u_pay / (u.uevent.minor_oracle ? 25 : 10);
X		    /* ~100 pts if very 1st, ~40 pts if minor already done */
X		u.uevent.major_oracle = TRUE;
X		exercise(A_WIS, !cheapskate);
X	}
X	if (add_xpts) {
X		more_experienced(add_xpts, u_pay/50);
X		newexplevel();
X	}
X	return 1;
X}
X
X/*rumors.c*/
END_OF_FILE
if test 9099 -ne `wc -c <'src/rumors.c'`; then
    echo shar: \"'src/rumors.c'\" unpacked with wrong size!
fi
# end of 'src/rumors.c'
fi
if test -f 'sys/msdos/ovlmgr.uu' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/msdos/ovlmgr.uu'\"
else
echo shar: Extracting \"'sys/msdos/ovlmgr.uu'\" \(9351 characters\)
sed "s/^X//" >'sys/msdos/ovlmgr.uu' <<'END_OF_FILE'
Xbegin 644 ovlmgr.obj
XM@`P`"F]V;&UG<BYA<VUDEA4```904U!314<&3U9,5$),!$-/1$6%F`H`````,
XM`"P``@$!+I@*```````0``,!`4F8!P!HO1P$`0$:C$8`!R0D24Y43D\`"20DT
XM3U9,0D%310`*)"1-4$=33D]63``+)"1-4$=33D)!4T4`!B0D34%)3@`&)"1#O
XM1U-.``8D)$-/5DP`T9`0```#"20D3U9,24Y)5/D/`-^(!```H@'1H!0``@``0
XM`````````````````````$J@'``#`````````````/__________````````=
XM``!)H@\``Q@`#P`!``$````"__\CH`8``S8`__\CH@\``S@`$``!``$````"`
XM__\"H`8``U@```#_H@\``UH`$``!``$````"___@H!(``WH`__\`````````F
XM``````#3H`8``X@$``#+G`@`Q````P.*!`2B#P`#B@H0``$``0````+__Z:@V
XM!@`#J@H``*.B9@`#K`H!`````DU:`0````(```$````"```!`````@```0``B
XM``(```$````"```!`````@```0````(```$````"```!`````@```0````(`&
XM``$````"```!`````@```0````(``&ZB#@`#K`Q0``$``0````$`0J`(``/\8
XM#`````!-HDD``P`-%0`!``$````!``$````!``$````"```!`````@```0``5
XM``0`````"0`!``$````!``,``0`!`````0!6``$``0````$`=:``!`.`#0``=
XM``#__P```````````````````````````````````````$5-35A86%@P```$G
XM```S.#8@<W!E8VEF:6,@8V]D92!E;F%B;&5D+@T*)$-O;G9E;G1I;VYA;"!M0
XM96UO<GD@879A:6QA8FQE.B`D2"!P87)A9W)A<&AS+@T*)$5-4R!M96UO<GD@A
XM879A:6QA8FQE.B`D2"`Q-DLM<&%G97,N#0HD26YC;W)R96-T($1/4R!V97)S/
XM:6]N+B!-=7-T(&)E(#,N,#`@;W(@;&%T97(N)$EN86-C97-S:6)L92!%6$4@'
XM9FEL92X@0V%N)W0@;&]A9"!O=F5R;&%Y<RXD3F]T(&5N;W5G:"!F<F5E(&UE)
XM;6]R>2!L969T('1O(')U;B!T:&ES('!R;V=R86TN)$9I;&4@22]/(&5R<F]R+
XM+B1);G1E<FYA;"!M96UO<GD@86QL;V-A=&EO;B!F86EL=7)E+B1%35,@;65M0
XM;W)Y(&UA;F%G97(@97)R;W(N)$5X96-U=&%B;&4@;W(@;W9E<FQA>2!H96%DI
XM97(@;6ES<VEN9R!O<B!D86UA9V5D+B15;F%B;&4@=&\@<F5S;VQV92!O=F5RF
XM;&%Y(&9I;&4@;F%M97,N)$EN86-C97-S:6)L92!/5DP@9FEL92X@0V%N)W0@T
XM;&]A9"!O=F5R;&%Y<RXD26YC;VUP;&5T92!E>&5C=71A8FQE+B`@3U9,(&9IR
XM;&5S(&UI<W-I;F<_)%5N:VYO=VX@97)R;W(A)!M;,&T;6TL-"AM;2QM;,6U/F
XM5DQ-1U(Z&ULP;2`D&UM+#0H;6TL@("`@("`@("@D&UM+#0H;6TL')#\N3U9,1
XM`%!345)65U4>!OR,V`40`"ZC``"T,,TA/`-S!;`!Z0``CAX``+[__T:#/`!US
XM^H/&!.@``+0UL&?-(8S(CMB_"@"^``"Y"`#SIK``=0*P_RZB``!U$K1!S6<N+
XMB1X``+1"S6<NB1X``+@``"ZC``"X``".V(L>```NB1X``(L>```NB1X``+1(+
XMS2%S`^D``"ZC```NBPX``([`)L8&````)L8&````)L<&`````";'!@`````FA
XMQP8`````)L<&``#__R;'!@`````FQP8`````)L<&`````$#BOHS(CM@S[3/_V
XM,_;H```NH0``+@,&``".P(O.T>$FB`X``"ZA``#1X-'@T>#1X-'@+HL6```+[
XMTG0.T>K1ZM'JT>I"+2```\(N*P8``":C```N@SX```!T!CO'<@*+^"ZA``#1$
XMX-'@T>#1X":C```FB2X``"X#+@``B]6*SHKR,NTRTM'BT=&P`+1"S2$NBPX`*
XM`"ZA``!)`\&.P":*'@``@^,>@_L`=0LF@SX``&R<D`'$!@`#`R0.Q`@``P-2H
XM#L0*``,#?@[$#``#`Z\.Q`X``P._#L00``,#OP[$$@`#`^,.Q!0``P/]#L064
XM``,#+@_$&``#`U0/Q!H``P.`#\0<``,#JP_$'@`#`ZL/Q"```P.K#\0B``,#$
XMJP_&B@`#`X0`AI<``P-'&\:;``$!+`"&J@`#`S\:QKH``P.D#<;)``,#L`W&<
XMU``#`X8`QMT``P.L#<K@)@("QN0``P.``,KG)@<'QNTF!@;&\@`#`WX`QO8F?
XM!P?&^P`#`WP`AP0``P,)$L<(``,#-@#'#0`#`WP`QQ0$`@+'&@`"`@$`QR``"
XM`@("`,<G``("!`#'+@`"`@8`QS4``@((`,<\``(""@#'0P`"`@P`QTH``@(.*
XM`(=<``,#[QG'8``#`S8`QV4``P/&"L=P!`("QW0``P.P"L>#``,#K@K'F@`#@
XM`[0*QYX``@(,`,>C``,#Q@K'L``#`[0*Q[P``@(.`,?!``(""@#'Q@`#`[`*;
XMQ]\``P-\`,?C``,#-@#'[00"`L?Z``(""@"RH``$`WP1`'4#Z0``2.+C+J$`,
XM`"ZC``".P";&!@```";'!@(````FQP8$````)L<&!@```":)/@@``\<NHP``=
XM5RZ.!@``Z```)L<&``#__R:`)@``OU+H``!87PO`=05'.]=R+R['!@`````N.
XMQP8`````OP``+L<%__^#QP8NH0``+HD%+HD^``".P";&!@``H.L%L`/I``"X(
XM``".V*```#+DT>#1X"ZC``#H```NBPX``+@``([`C,B.V+L``+X``+\``":*,
XM!#+D`P8``(D%)HL'*P8``(E%`H/'!(/#`D;BX@<?75]>6EE;6.H`````+HDV\
XM```NC!X``%X?4%/\K#+DB]BM+J,``(O&+HLV``"#Q@8NC%S\+HE$_M'CT>.!N
XMPP``+HX?+HM'`BZ,'"Z)-@``+HLV``!&+HDV``")-@``+HLV``!T?XDV``#V'
XM!@``('1]_@8```,&```NHP``+HLV```NCAX``%M8G2[_'@``G"Z,'@``+HDV3
XM```NBS8``"Z.'/X.``"#[@8NCAPN_W0"+O]T!"Z)-@``+HLV``!&+HDV``")C
XM-@``+HLV``!T-XDV``#V!@``('0T+HLV```NCAX``,]&+HDV``#I``#V!@``D
XM0'0+4*$``.@``%CI``#H``#I``!&+HDV``#KP?8&``!`=`I0H0``Z```6.N[O
XMZ```Z[9045)35597'@:,V([`)H`^````=0HFH0``Z```ZP20Z```!0$`)J,`S
XM`([8)HL6``"*SHKR,NTRTM'BT=$FH0``45(#T(/1`+1"L``FBAX``(/C'BZ+2
XMGP``S2%R4#/2)HL.``#1X='AT>'1X;0_S2%R.UI9M$*P`":*'@``@^,>+HN?4
XM``#-(7(DN0`"N@``'HS(CMBT/\TA'W(2Z```!Q^`#@``(%]>75M:65C#L`3I2
XM``"^``"+[H'%``(NBTP&XUN,WRXK/@``+@-T&#OU<@/H```NBAQ&._5R`^@`&
XM`"Z*/$8[]7(#Z```+HH$1COU<@/H```NBB1&+@,&```#QX[8BP<N`P8``"X[-
XM!@``<@DN.P8``',"`\>)!^*PPU-15U4>!KD``KH``(S(CM@FBAX``(/C'BZ+4
XMGP``M#_-(7,#Z0``O@``!Q]=7UE;PU-14E9751XNCAX``#/`B]"+Z(O8+HL.:
XM``#VAP``@'4P]H<``$!U!_:'```@="(NBS8``"Z+/@``*[<``!N_```[UW(&M
XM=0H[QG,&B\:+UXOK@\,0XL0+[74%L`7I``#1[='MT>W1[8S8`\4?75]>6EE;;
XMPX#\2W0/@/Q,=`4N_RX``+``Z0``"L!U\E!14E-55E<&'BZ.!@``+HL.``"[B
XM$`!))O:'``!`=1<F]H<``"!T99P,`X0$``,#VQ#$"P`#`X``Q`\``P-8`,0W)
XM``,#@@#$/0`#`S8`A$```P.H&,1%``(""`#$3`0"`H11``,#$!C$800#`\1HC
XM``,#`@#$;0`#`XH$Q'D``P,V`,2!``,#B`3$B`0"`H20``,#1QO(DR8!`<28X
XM)@$!Q*(``P.J"H2E``,#31S$J@`#`WX`R*TF!`3$MB8$!,2Y)@,#Q+P``P.([
XM`,3%``,#-@#$S@`#`X``S.8F!07$[0`#`Q``Q/(``P,2`,4!``,#!`#%"``#S
XM`X@$Q1L``P.(`,4J``,#B`3%+P0#`\4U!`,#Q3D``@($`,4^``,#`@#%1``""
XM`@8`Q4@$`@+%3P`"`@$`Q5,``@("`,57``,#!@#%7``#`Q``Q6$``P,2`,5I4
XM``,#!`#%;P`#`Q(`Q70``P,0`,5Y``,#B`3%@``"`@$`Q9,``P.(!,68!`,#3
XMQ9X$`P/%H@`"`@0`Q:<``P,"`,6M``("!@#%L00"`L6Y``,#$`#%O@`#`Q(`:
XMQ<4``P,"`(7(``,#OA+%S`0"`L73``(""`"%U@`#`ST9A=H``P/)$H7=``,#8
XM?!.%X``#`\D2Q>8``P,"`,7L!`("Q?,``@((`(7V``,#/1F%_``#`WP3QA``H
XM`@(!`,87``("#`"&&@`#`Z06AB```P,6%L8G``("`@#&+@`"`@H`QCX``@(.Q
XM`,9.!`("QE8``P,8`,9A``("#`#&>@0"`L:"``,#&`#&C``#`ZP*AIL``P,M+
XM%,:A!`("AJ\``P-'&\:R``,#K`K&Q0`#`X``AM```P.8%(;;``,#F!2&Y@`#H
XM`Y@4AO$``P.8%,;Z``,#A`#'!0`#`X0`QPH``P.``,<1``,#@@#')@`#`ZP*,
XMQR\$`@+'-P`#`Q@`AT```P,H%,=#``,#K`K'5@`#`S8`QV,``P-\`,=G!`("&
XMQVX$`@+'=00"`L=]!`,#QX(``P,"`,>&``("!`#'B@`"`@8`AZ@``P-'&\?+%
XM``,##`"'T``#`T<;Q^(``P,V`,?G``,#?`#'\`0"`L?X!`(";J``!`-X%14FG
XMBX<``"T!`"X[!@``<@8F@*<``-^#PQ#BUB['!@``__\NH0``/?__=`Z.P":.<
XM!@0`)L<&`@```+D0`+X``"Z+!#W__W0+CL"T2<TA+L<$__^#Q@+BZ.@``(OLC
XM_W86G1\'7UY=6UI96"Z,%@``+HDF``#-(2Z.%@``+HLF``!045)35597!AZ+!
XM[)R/1A;H``#H```?!U]>75M:65C/)HL>``"#ZP&+TR8#%@``@\(!)J$``#W_;
XM_W00Z```)H`.``!`+J$``.M9D"ZA``#K4I".V#O8<PD[PG--Z```Z_$#!@@`P
XM.]AS-_8&```!=`?H```#!@@`.\)R)8S8B\LKR'02!N@``":`#@```>@``(S`Z
XMCM@')HL.``"#P0'K.I"A`@`+P'0"ZZFP!ND``";'!@``__\F@"8``+^+R(/!!
XM`>@``#O1<P_H```[T7,(Z```Z```Z^KK`9`&@`X```'H``!R"1Z,P([8Z```'
XM'P>,!@8`C-C#C-@#P8[`H0@`*\%V,(D."``FHP@`H0(`)J,"`(P&`@`FC!X$J
XM`";&!@```":A`@`+P'0*'H[8C`8$`!_XP_G#+J$``#/2ZQB0CMCV!@```74+)
XM.0X(`'(%BQ8(`,.A`@`+P'7EP_8&```!=!(&C@8&`":`)@``WR:`)@``OP?KS
XM)9".V(`F``#?]@8``$!T"X`F``"_H0``Z```H0``+0$`CMCK`9!2!H`F``#^J
XMH00`"\!T,H[`)O8&```!=2@F`P8(`(S:.]!U':$(`"8!!@@`H0(`)J,"``O`5
XM=`:.V(P&!`",P([8H0(`"\!T,([`)O8&```!=2:,V`,&"`",PCO"=1HFH0@`Q
XM`08(`":A`@"C`@`+P'0'CL`FC!X$`(`F``#^!UJ,V,-14U97'@8STBZA``".G
XMV*$"``O`=?>^``"_``"Y$`"T2+O__\TA@_L0<DFT2,TA<D,N.P8``'(T.]-SD
XM`HO3+HD$CL`FQ@8````FQP8"````)L<&!@```":,'@0`)HD>"`",!@(`@\8"]
XMCMCK!BZ)!8/'`N*KO@``N1``+HL$/?__=`N.P+1)S2$NQP3__X/&`N+H!Q]?&
XM7EM9PS/2+H`^``#_=`'#+L<&``#__[\``(O9N1``+HL%/?__=!'H```[PW-8D
XM@\<"XNR+RS/2PXO+NP0`M$-15P;-9P=?60KD=`,STL,NB14FB18``":`#@``6
XM0(O"Z```+J$``([8Q@8```#'!@(```#'!@0```#'!@8```"Z`!")%@@`PXO+@
XMCMZ+T"Z+!2:C```F@`X``$##+CL&``!U`<-34AX&Z```+J$``#/2,_:.V/8&:
XM```!=`V.!@8`)H`.``!@ZPR0H0@`.]!S!(O0C(N<G0'$!``"`@(`Q`P``P,X]
XM`,03!`("Q!X``P-Z`,0D``,#.`#$/0`#`S@`A%@``P.(',1L``,#%`#$<0`#:
XM`Q8`Q'@``P,4`,1]``,#%@"$CP`#`Q`8A)(``P--',2A``("`@#$JP`"`@P`#
XMQ+(``@((`(2Z``,#/1G$OP0"`L3$``,#A@#$RP`#`U@`A-L``P-/%X3O``,#;
XM3Q>%`P`#`^L6A0P``P./%\46``("#`"%*@`#`T<;Q2\``@((`,4V!`("A3\`?
XM`P,J%X5&``,#J!B%30`#`\@4A5```P-K%X5>``,#ZQ:%:``#`X\7Q;0``P-8U
XM`,7F!`("Q>P$`@+%]P0"`L7\!`("Q@,$`@+&!P`"`@@`A@H``P,]&<8-``("(
XM`@#&H@`#`U@`QJX``P,X`,:Q``,#B@K&RP`#`S8`QPP``P.*"L<U``,#L`W'J
XM/@`#`WH`QT,``P-:`(=3``,#/1G'?P`"`@@`QX0$`@*'B@`#`X,9QXX``P.&T
XM`,>\``(""`#'P00"`L?(``,#>@"'T@`#`X,9Q]8``P.&`,?L!`("0:!-`P-T`
XM&=ZA`@`+P'78B\(''UI;PP9345(NHP``B]"T1#+`,]M2S6=:"N1U3[1$L`&[!
XM`0!2S6=:"N1U0+1$L`*[`@!2S6=:"N1U,;1$L`.[`P#-9PKD=20NC@8``"Z+[
XM#@``,]LF]H<``$!T!B:`IP``WX/#$.+M6EE;!\.P!^D``+H``(O>T>,NBY\`=
XM`+D<`+0_S2%R,3O!=",]``!T`^LKD$:#_@]T'XO>T>,N@[\``/]T[BZ+GP``?
XM,^WKT"Z!/@``35IU!L.P"^D``+`(Z0``!K0OS2$NC`8``"Z)'@``'KH``(S(D
XMCMBT&LTA'[DH`(S+CL._``#SI;\``+``N5``_/*N@^E0]]F+V8/Y4'0'2T^#T
XM^P=^';!<_?*N_(O3*]%*N0``+HD>```NB18``(/Z#'X%L`GI``",R([8N@``F
XML`"T/<TA<P6P`ND``"ZC```N@SX```M_"B[_!@``+O\&``"_```N`SX``(/OE
XM!;X``+D&`/.DN0``N@``M$[-(7)'N0X`+HL6```N*18``%$NBQX``+\```/[=
XMO@``+HL.``#SI%FZ``"P`+0]S2%S".@``+`*ZR*0B]G1XRZ)AP``M$_-(7("-
XMXL8NBQ8``"Z.'@``M!K-(0?#,N10#A^+V-'C@<,``(L7@_K_=&12N@``M`G-L
XM(5JT"<TAM`FZ``#-(5A0Z```M`*R.LTAN*`PZ```M`*R.LTAN`"@+BL&``#H_
XM``"T`K(ZS2&^``"Y$``SP"Z#//]T"BX#!@``@\8"XO#H``"T`K(IS2&Z``"TQ
XM"<TAZ```+J$``#W__W0&CL"T2<TAN1``O@``+HL$/?__=`:.P+1)S2&#Q@+BV
XM[;D0`+X``"Z+%(/Z_W0$M$7-9X/&`N+ON0\`B]E+T>,NBY\``(/[_W0$M#[-7
XM(>+K6+1,S2%0AN#H``!8ZP&04-#HT.C0Z-#HZ```6.L!D%`D#P0P/#IR`@0'I
XM4HK0M`+-(5I8PQXSP([8+HLV``#ZBP0NHP``BT0"+J,``+@``(D$C$P"OH0`O
XMBP0NHP``BT0"+J,``+@``(D$C$P"^Q_#'C/`CMB^A`#Z+J$``#W__W0)B00NN
XMH0``B40"+HLV```NH0``/?__=`J)!"ZA``")1`+['\,PG/4!Q!4``P-Z`,15P
XM``,#-@#$6@`#`WP`Q&$$`@+$:00"`H1Y``,#1QO$?``#`ZP*Q(4``P,8`,2I!
XM``,#&`#$L0`#`Q@`Q+H``P.L"H3$``,#1QN$R0`#`T<;Q-,``P.`#<38``,#/
XM@@W$W``#`P`-Q.\``P.L#,3T``,#K`S%(@`#`_P,Q2<``P/^#(4Q``,#1QO%V
XM.``#`ZP,A44``P-'&\5)``,#&`#%3@`#`_X,Q58``P/\#,5;``,#_@S%7@`#"
XM`ZP,Q6,``P/\#,5I``,#\P_%=``#`ZP,Q8(``P/^#,6'``,#_`S%C0`#`_P,7
XMQ9```P.L#,65``,#'@W%F@`#`_X,Q:```P.L#(6K``,#'AS%N0`#`Q@`Q<8`3
XM`P."#<7+``,#@`W%W@`#`X0-Q>D``P.Z#\7W``,#UP^%_@`#`QX<A@H``P,>T
XM',88``,#-@"&&P`#`QX<QB0``P-:`,8T``,#K@V&/``#`QX<QD4``P/I#X9,U
XM``,#B!S&4``#`S8`QF$``P,X`,9Z``,#6@#&F``#`Q@`AJX``P,H'(:^``,#@
XM.!S&X0`#`ZH*QN@``P,(`,;O``,#"@#&\@`#`V82QP```P,,`,<'``,##@#'E
XM"@`#`SH5QQ\``P,,`,<J``,##@#',@`#`ZH*QS8``P,(`,=!``,#"@"8B@(`C
X"`'0`7
X``
Xend
Xsum -r/size 34565/9296 section (from "begin" to "end")
END_OF_FILE
if test 9351 -ne `wc -c <'sys/msdos/ovlmgr.uu'`; then
    echo shar: \"'sys/msdos/ovlmgr.uu'\" unpacked with wrong size!
fi
# end of 'sys/msdos/ovlmgr.uu'
fi
if test -f 'sys/unix/unixmain.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/unix/unixmain.c'\"
else
echo shar: Extracting \"'sys/unix/unixmain.c'\" \(9335 characters\)
sed "s/^X//" >'sys/unix/unixmain.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)unixmain.c	3.1	92/12/04	*/
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X/* main.c - Unix NetHack */
X
X#include "hack.h"
X
X#include <signal.h>
X#include <pwd.h>
X#ifndef O_RDONLY
X#include <fcntl.h>
X#endif
X
X#if !defined(_BULL_SOURCE) && !defined(sgi)
X# if defined(POSIX_TYPES) || defined(SVR4)
Xextern struct passwd *FDECL(getpwuid,(uid_t));
X# else
Xextern struct passwd *FDECL(getpwuid,(int));
X# endif
X#endif
Xextern struct passwd *FDECL(getpwnam,(const char *));
X#ifdef CHDIR
Xstatic void chdirx();
X#endif /* CHDIR */
Xstatic boolean whoami();
Xstatic void FDECL(process_options, (int, char **));
X
Xint
Xmain(argc,argv)
Xint argc;
Xchar *argv[];
X{
X	register int fd;
X#ifdef CHDIR
X	register char *dir;
X#endif
X	boolean exact_username;
X
X	hname = argv[0];
X	hackpid = getpid();
X	(void) umask(0);
X
X	choose_windows(DEFAULT_WINDOW_SYS);
X
X#ifdef CHDIR			/* otherwise no chdir() */
X	/*
X	 * See if we must change directory to the playground.
X	 * (Perhaps hack runs suid and playground is inaccessible
X	 *  for the player.)
X	 * The environment variable HACKDIR is overridden by a
X	 *  -d command line option (must be the first option given)
X	 */
X	dir = getenv("NETHACKDIR");
X	if (!dir) dir = getenv("HACKDIR");
X#endif
X	if(argc > 1) {
X#ifdef CHDIR
X	    if (!strncmp(argv[1], "-d", 2) && argv[1][2] != 'e') {
X		/* avoid matching "-dec" for DECgraphics; since the man page
X		 * says -d directory, hope nobody's using -desomething_else
X		 */
X		argc--;
X		argv++;
X		dir = argv[0]+2;
X		if(*dir == '=' || *dir == ':') dir++;
X		if(!*dir && argc > 1) {
X			argc--;
X			argv++;
X			dir = argv[0];
X		}
X		if(!*dir)
X		    error("Flag -d must be followed by a directory name.");
X	    } else
X#endif /* CHDIR /**/
X
X	/*
X	 * Now we know the directory containing 'record' and
X	 * may do a prscore().
X	 */
X	    if (!strncmp(argv[1], "-s", 2)) {
X#ifdef CHDIR
X		chdirx(dir,0);
X#endif
X		prscore(argc, argv);
X		exit(0);
X	    }
X	}
X
X	initoptions();
X	init_nhwindows();
X	exact_username = whoami();
X
X	/*
X	 * It seems you really want to play.
X	 */
X	setrandom();
X	u.uhp = 1;	/* prevent RIP on early quits */
X	(void) signal(SIGHUP, (SIG_RET_TYPE) hangup);
X#ifdef SIGXCPU
X	(void) signal(SIGXCPU, (SIG_RET_TYPE) hangup);
X#endif
X
X	/*
X	 * Find the creation date of this game,
X	 * so as to avoid restoring outdated savefiles.
X	 */
X	gethdate(hname);
X
X	/*
X	 * We cannot do chdir earlier, otherwise gethdate will fail.
X	 */
X#ifdef CHDIR
X	chdirx(dir,1);
X#endif
X
X	process_options(argc, argv);	/* command line options */
X
X#ifdef DEF_PAGER
X	if(!(catmore = getenv("HACKPAGER")) && !(catmore = getenv("PAGER")))
X		catmore = DEF_PAGER;
X#endif
X#ifdef MAIL
X	getmailstatus();
X#endif
X#ifdef WIZARD
X	if (wizard)
X		Strcpy(plname, "wizard");
X	else
X#endif
X	if(!*plname || !strncmp(plname, "player", 4)
X		    || !strncmp(plname, "games", 4)) {
X		exact_username = FALSE;
X		askname();
X	}
X	if (!exact_username) /* what if their LOGNAME looks suffixed-like? */
X		plnamesuffix();	/* strip suffix from name; calls askname() */
X				/* again if suffix was whole name */
X				/* accepts any suffix */
X#ifdef WIZARD
X	if(!wizard) {
X#endif
X		/*
X		 * check for multiple games under the same name
X		 * (if !locknum) or check max nr of players (otherwise)
X		 */
X		(void) signal(SIGQUIT,SIG_IGN);
X		(void) signal(SIGINT,SIG_IGN);
X		if(!locknum)
X			Sprintf(lock, "%d%s", (int)getuid(), plname);
X		getlock();
X#ifdef WIZARD
X	} else {
X		Sprintf(lock, "%d%s", (int)getuid(), plname);
X		getlock();
X	}
X#endif /* WIZARD /**/
X
X	/*
X	 * Initialisation of the boundaries of the mazes
X	 * Both boundaries have to be even.
X	 */
X
X	x_maze_max = COLNO-1;
X	if (x_maze_max % 2)
X		x_maze_max--;
X	y_maze_max = ROWNO-1;
X	if (y_maze_max % 2)
X		y_maze_max--;
X
X	/*
X	 *  Initialize the vision system.  This must be before mklev() on a
X	 *  new game or before a level restore on a saved game.
X	 */
X	vision_init();
X
X	display_gamewindows();
X
X	set_savefile_name();
X	uncompress(SAVEF);
X
X	if((fd = open_savefile()) >= 0 &&
X	   /* if not up-to-date, quietly delete file via false condition */
X	   (uptodate(fd) || delete_savefile())) {
X#ifdef WIZARD
X		/* Since wizard is actually flags.debug, restoring might
X		 * overwrite it.
X		 */
X		boolean remember_wiz_mode = wizard;
X#endif
X		(void) chmod(SAVEF,0);	/* disallow parallel restores */
X		(void) signal(SIGINT, (SIG_RET_TYPE) done1);
X#ifdef NEWS
X		if(flags.news) display_file(NEWS, FALSE);
X#endif
X		pline("Restoring save file...");
X		mark_synch();	/* flush output */
X		if(!dorecover(fd))
X			goto not_recovered;
X#ifdef WIZARD
X		if(!wizard && remember_wiz_mode) wizard = TRUE;
X#endif
X		pline("Hello %s, welcome back to NetHack!", plname);
X		check_special_room(FALSE);
X#ifdef EXPLORE_MODE
X		if (discover)
X			You("are in non-scoring discovery mode.");
X#endif
X#if defined(EXPLORE_MODE) || defined(WIZARD)
X		if (discover || wizard) {
X			if(yn("Do you want to keep the save file?") == 'n')
X			    (void) delete_savefile();
X			else {
X			    (void) chmod(SAVEF,FCMASK); /* back to readable */
X			    compress(SAVEF);
X			}
X		}
X#endif
X		flags.move = 0;
X	} else {
Xnot_recovered:
X		player_selection();
X		newgame();
X		/* give welcome message before pickup messages */
X		pline("Hello %s, welcome to NetHack!", plname);
X#ifdef EXPLORE_MODE
X		if (discover)
X			You("are in non-scoring discovery mode.");
X#endif
X		flags.move = 0;
X		set_wear();
X		pickup(1);
X	}
X
X	flags.moonphase = phase_of_the_moon();
X	if(flags.moonphase == FULL_MOON) {
X		You("are lucky!  Full moon tonight.");
X		change_luck(1);
X	} else if(flags.moonphase == NEW_MOON) {
X		pline("Be careful!  New moon tonight.");
X	}
X	if(flags.friday13 = friday_13th()) {
X		pline("Watch out!  Bad things can happen on Friday the 13th.");
X		change_luck(-1);
X	}
X
X	initrack();
X
X	moveloop();
X	return(0);
X}
X
Xstatic void
Xprocess_options(argc, argv)
Xint argc;
Xchar *argv[];
X{
X	/*
X	 * Process options.
X	 */
X	while(argc > 1 && argv[1][0] == '-'){
X		argv++;
X		argc--;
X		switch(argv[0][1]){
X#if defined(WIZARD) || defined(EXPLORE_MODE)
X# ifndef EXPLORE_MODE
X		case 'X':
X# endif
X		case 'D':
X# ifdef WIZARD
X			{
X			  char *user;
X			  int uid;
X			  struct passwd *pw = (struct passwd *)0;
X
X			  uid = getuid();
X			  user = getlogin();
X			  if (user) {
X			      pw = getpwnam(user);
X			      if (pw && (pw->pw_uid != uid)) pw = 0;
X			  }
X			  if (pw == 0) {
X			      user = getenv("USER");
X			      if (user) {
X				  pw = getpwnam(user);
X				  if (pw && (pw->pw_uid != uid)) pw = 0;
X			      }
X			      if (pw == 0) {
X				  pw = getpwuid(uid);
X			      }
X			  }
X			  if (pw && !strcmp(pw->pw_name,WIZARD)) {
X			      wizard = TRUE;
X			      break;
X			  }
X			}
X			/* otherwise fall thru to discover */
X# endif
X# ifdef EXPLORE_MODE
X		case 'X':
X			discover = TRUE;
X# endif
X			break;
X#endif
X#ifdef NEWS
X		case 'n':
X			flags.news = FALSE;
X			break;
X#endif
X		case 'u':
X			if(argv[0][2])
X			  (void) strncpy(plname, argv[0]+2, sizeof(plname)-1);
X			else if(argc > 1) {
X			  argc--;
X			  argv++;
X			  (void) strncpy(plname, argv[0], sizeof(plname)-1);
X			} else
X				raw_print("Player name expected after -u");
X			plnamesuffix();
X			break;
X		case 'I':
X		case 'i':
X			if (!strncmpi(argv[0]+1, "IBM", 3))
X				switch_graphics(IBM_GRAPHICS);
X			break;
X	    /*  case 'D': */
X		case 'd':
X			if (!strncmpi(argv[0]+1, "DEC", 3))
X				switch_graphics(DEC_GRAPHICS);
X			break;
X		default:
X			/* allow -T for Tourist, etc. */
X			(void) strncpy(pl_character, argv[0]+1,
X				sizeof(pl_character)-1);
X
X			/* raw_printf("Unknown option: %s", *argv); */
X		}
X	}
X
X	if(argc > 1)
X		locknum = atoi(argv[1]);
X#ifdef MAX_NR_OF_PLAYERS
X	if(!locknum || locknum > MAX_NR_OF_PLAYERS)
X		locknum = MAX_NR_OF_PLAYERS;
X#endif
X}
X
X#ifdef CHDIR
Xstatic void
Xchdirx(dir, wr)
Xconst char *dir;
Xboolean wr;
X{
X
X# ifdef SECURE
X	if(dir					/* User specified directory? */
X#  ifdef HACKDIR
X	       && strcmp(dir, HACKDIR)		/* and not the default? */
X#  endif
X		) {
X		(void) setgid(getgid());
X		(void) setuid(getuid());		/* Ron Wessels */
X	}
X# endif
X
X# ifdef HACKDIR
X	if(dir == NULL)
X		dir = HACKDIR;
X# endif
X
X	if(dir && chdir(dir) < 0) {
X		perror(dir);
X		error("Cannot chdir to %s.", dir);
X	}
X
X	/* warn the player if we can't write the record file */
X	/* perhaps we should also test whether . is writable */
X	/* unfortunately the access system-call is worthless */
X	if (wr) check_recordfile(dir);
X}
X#endif /* CHDIR /**/
X
Xstatic boolean
Xwhoami() {
X	/*
X	 * Who am i? Algorithm: 1. Use name as specified in NETHACKOPTIONS
X	 *			2. Use $USER or $LOGNAME	(if 1. fails)
X	 *			3. Use getlogin()		(if 2. fails)
X	 * The resulting name is overridden by command line options.
X	 * If everything fails, or if the resulting name is some generic
X	 * account like "games", "play", "player", "hack" then eventually
X	 * we'll ask him.
X	 * Note that we trust the user here; it is possible to play under
X	 * somebody else's name.
X	 */
X	register char *s;
X
X	if (*plname) return FALSE;
X	if(/* !*plname && */ (s = getenv("USER")))
X		(void) strncpy(plname, s, sizeof(plname)-1);
X	if(!*plname && (s = getenv("LOGNAME")))
X		(void) strncpy(plname, s, sizeof(plname)-1);
X	if(!*plname && (s = getlogin()))
X		(void) strncpy(plname, s, sizeof(plname)-1);
X	return TRUE;
X}
X
X#ifdef PORT_HELP
Xvoid
Xport_help()
X{
X    /*
X     * Display unix-specific help.   Just show contents of the helpfile
X     * named by PORT_HELP.
X     */
X    display_file(PORT_HELP, TRUE);
X}
X#endif
X
X/*unixmain.c*/
END_OF_FILE
if test 9335 -ne `wc -c <'sys/unix/unixmain.c'`; then
    echo shar: \"'sys/unix/unixmain.c'\" unpacked with wrong size!
fi
# end of 'sys/unix/unixmain.c'
fi
if test -f 'sys/vms/Makefile.utl' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/vms/Makefile.utl'\"
else
echo shar: Extracting \"'sys/vms/Makefile.utl'\" \(9299 characters\)
sed "s/^X//" >'sys/vms/Makefile.utl' <<'END_OF_FILE'
X#	NetHack Makefile (VMS) - for utility programs.
X#	SCCS Id: @(#)Makefile.utl	3.1	93/01/25
X
X#  Copy this file to [.util]Makefile. and then edit it as needed.
X#  Settings for CC and CFLAGS ought to match the ones used in [.src]Makefile.
X
XMAKE	= mms
XCD	= set default
XECHO	= write sys$output
XMOVE	= rename/New		# within save device only
XMUNG	= search/Exact/Match=NOR	# to strip bogus #module directives
XRUN	= mcr			# simplest way to pass command line args
XTOUCH	= append/New _NLA0:	# only one file per $(TOUCH)
X# source tree, relative to 'src' and 'util'
XDAT = [-.dat]
XINC = [-.include]
XSHR = [-.sys.share]
XSRC = [-.src]
XUTL = [-.util]
XVMS = [-.sys.vms]
X# targets, with enough punctuation to keep MCR and DELETE happy
XMAKEDEFS= $(UTL)makedefs.exe;
XLEVCOMP = $(UTL)lev_comp.exe;
XDGNCOMP = $(UTL)dgn_comp.exe;
XRECOVER = $(UTL)recover.exe;
X
X# if you are using gcc as your compiler,
X#	uncomment the CC definition below if it's not in your environment
X# CC = gcc
X
XCFLAGS	= /Include=$(INC)/noList
X#CFLAGS = /Stand=VAXC/Incl=$(INC)/noList	# DECC in VAXC mode
XLFLAGS	= /noMap
XLIBS	= $(SRC)crtl/Options			# run-time library(s) needed
XLINK	= link
X
X# If you don't have yacc, byacc, or bison or just don't want to run any of
X#	them, then make target "no_yacc" before trying to build lev_comp
X#	or dgn_comp.  You won't be able to modify *_comp.y though.
X# If you don't have lex or flex, then make target "no_lex" and leave
X#	*_comp.l alone.  $(VMS)lev_lex.h will be used to work-around some
X#	suspect code included in the distributed copies of *_lex.c.
X# If you do either of the above, the corresponding value of YACC and/or LEX
X#	below won't matter.
X#
X# Note:  VMS POSIX V1.1 lex and yacc generate code which contains an
X#	invalid #module directive; it order to prevent warnings for CC or
X#	choking by GCC, the SEARCH command is used in an attempt to strip
X#	then out.  Otherwise MMS would quit when making the affected targets.
X#	Each "munged" copy should be identical to its original if no #module
X#	directives are present.
X#
X# yacc/lex programs to use to generate *_comp.c, *_comp.h, and *_lex.c.
X# choose xxxOUT that matches xxx tool's output
XYACC	= bison /Define
XLEX	= flex
X#YACC	= yacc -d
X#LEX	= lex
X#YACC	= posix/Run posix$bin:yacc. "-d
X#LEX	= posix/Run posix$bin:lex. "
X# blank means foo.y -> foo_tab.c & foo_tab.h
XYACCOUT =		# bison
X#YACCOUT = ytab		# VMS POSIX
X#YACCOUT = y_tab	# DEC/Shell
XLEXOUT	= lexyy		# flex
X#LEXOUT  = lex_yy	# VMS POSIX
X
X# Nothing below this line should have to be changed.
X
X# linker options file
XLIBOPT	= $(SRC)crtl.opt;
X
X# utility .c files
XMAKESRC    = makedefs.c
XSPLEVSRC   = lev_yacc.c lev_lex.c lev_main.c
XDGNCOMPSRC = dgn_yacc.c dgn_lex.c dgn_main.c
XUTILSRCS   = $(MAKESRC) $(SPLEVSRC) $(DGNCOMPSRC) panic.c recover.c
X
X# object files for makedefs
XMAKEOBJS = makedefs.obj,$(SRC)monst.obj,$(SRC)objects.obj
XVMSMAKEOBJS = $(SRC)vmsmisc.obj
X
X# object files for special levels compiler
XSPLEVOBJS = lev_main.obj,lev_yacc.obj,lev_lex.obj,panic.obj,\
X	    $(SRC)alloc.obj,$(SRC)monst.obj,$(SRC)objects.obj,\
X	    $(SRC)decl.obj,$(SRC)drawing.obj
XVMSSPLEVOBJS = $(SRC)vmsmisc.obj,$(SRC)vmsfiles.obj
X
X# object files for dungeon compiler
XDGNCOMPOBJS = dgn_main.obj,dgn_yacc.obj,dgn_lex.obj,panic.obj,$(SRC)alloc.obj
XVMSDGNCOBJS = $(SRC)vmsmisc.obj
X
X# object files for recovery utility
XRECOVOBJS = recover.obj
XVMSRECOBJS = $(SRC)vmsmisc.obj,$(SRC)vmsfiles.obj
X
X
X#	fake target
Xdefault :
X      @ $(ECHO) "Oops!  No target(s) specified...."
X
Xall	: $(MAKEDEFS) $(LEVCOMP) $(DGNCOMP) $(RECOVER)
X      @ $(ECHO) "util is up to date."
X
X#	special targets for folks without yacc/bison and or lex/flex
Xno_yacc :
X	copy $(SHR)%%%_yacc.c $(UTL)
X	copy $(SHR)%%%_comp.h $(INC)
X      @ $(ECHO) "distributed yacc output (*_yacc.c) copied into place"
Xno_lex :
X	copy $(SHR)%%%_lex.c $(UTL)
X	copy $(VMS)lev_lex.h $(UTL)
X      @ $(ECHO) "distributed lex output (*_lex.c) copied into place"
X
X#	alternate target names for possible interactive use
Xmakedefs : $(MAKEDEFS)
X      @ $(ECHO) "makedefs is up to date."
Xlev_comp : $(LEVCOMP)
X      @ $(ECHO) "lev_comp is up to date."
Xdgn_comp : $(DGNCOMP)
X      @ $(ECHO) "dgn_comp is up to date."
Xrecover  : $(RECOVER)
X      @ $(ECHO) "recover is up to date."
X
X$(LIBOPT) : $(SRC)Makefile.;		# linker options file
X	$(CD) $(SRC)
X	$(MAKE)$(MAKEFLAGS) $(LIBOPT)
X      @ $(CD) $(UTL)
X
X#	dependencies for makedefs
X#
X$(MAKEDEFS) :	$(MAKEOBJS) $(VMSMAKEOBJS) $(LIBOPT)
X	$(LINK) $(LFLAGS) $(MAKEOBJS),$(VMSMAKEOBJS),$(LIBS)
X
Xmakedefs.obj :	$(INC)config.h $(INC)permonst.h $(INC)objclass.h \
X		$(INC)monsym.h $(INC)artilist.h $(INC)qtext.h \
X		$(INC)patchlevel.h
X	$(CC) $(CFLAGS) makedefs.c
X
X$(INC)onames.h	: $(MAKEDEFS)
X	$(RUN) $(MAKEDEFS) -o
X$(INC)pm.h	: $(MAKEDEFS)
X	$(RUN) $(MAKEDEFS) -p
X$(SRC)monstr.c	: $(MAKEDEFS)
X	$(RUN) $(MAKEDEFS) -m
X# both vis_tab.h and vis_tab.c are made at the same time by makedefs -z
X$(INC)vis_tab.h : $(SRC)vis_tab.c
X	$(TOUCH) $(INC)vis_tab.h
X$(SRC)vis_tab.c : $(MAKEDEFS)
X	$(RUN) $(MAKEDEFS) -z
X
X# the src Makefile is responsible for knowing when to call this, since
X# it knows all about the main src and include files
X$(INC)date.h :	$(MAKEDEFS)
X	$(RUN) $(MAKEDEFS) -v
X
X
X#	dependencies for lev_comp
X#
X$(LEVCOMP) : $(SPLEVOBJS) $(VMSSPLEVOBJS)	# $(LIBOPT)
X	$(LINK)/Exe=$(LEVCOMP) $(LFLAGS) $(SPLEVOBJS),$(VMSSPLEVOBJS),$(LIBS)
X
Xlev_yacc.obj : $(INC)hack.h $(INC)sp_lev.h lev_yacc.c
X	$(CC) $(CFLAGS) lev_yacc.c
Xlev_lex.obj  : $(INC)hack.h $(INC)lev_comp.h $(INC)sp_lev.h lev_lex.c
X	@ if f$search("lev_lex.h").nes."" then	$(MOVE) lev_lex.h stdio.h
X	$(CC) $(CFLAGS) lev_lex.c
X	@ if f$search("stdio.h").nes."" then  $(MOVE) stdio.h lev_lex.h
Xlev_main.obj : $(INC)hack.h $(INC)sp_lev.h $(INC)termcap.h lev_main.c
X	$(CC) $(CFLAGS) lev_main.c
Xpanic.obj    : $(INC)config.h
X	$(CC) $(CFLAGS) panic.c
X
X$(INC)lev_comp.h : lev_yacc.c
X	$(TOUCH) $(INC)lev_comp.h
X
Xlev_yacc.c : lev_comp.y
X	$(YACC) lev_comp.y
X	$(MUNG) 'f$parse("$(YACCOUT)","lev_comp_tab.c")' "#module" /Outp=lev_yacc.c
X	@ if f$search("''f$parse("$(YACCOUT)","lev_comp_tab.c")'").nes."" then \
X		delete 'f$parse("$(YACCOUT)","lev_comp_tab.c")'
X	$(MOVE) 'f$parse("$(YACCOUT)","lev_comp_tab.h")' $(INC)lev_comp.h
X
Xlev_lex.c : lev_comp.l
X	$(LEX) lev_comp.l
X	$(MUNG) 'f$parse("$(LEXOUT)","lev_comp_lex.c")' "#module" /Outp=lev_lex.c
X	@ if f$search("''f$parse("$(LEXOUT)","lev_comp_lex.c")'").nes."" then \
X		delete 'f$parse("$(LEXOUT)","lev_comp_lex.c")'
X
X
X#	dependencies for dgn_comp
X#
X$(DGNCOMP) : $(DGNCOMPOBJS) $(VMSDGNCOBJS)	# $(LIBOPT)
X	$(LINK)/Exe=$(DGNCOMP) $(LFLAGS) $(DGNCOMPOBJS),$(VMSDGNCOBJS),$(LIBS)
X
Xdgn_yacc.obj : $(INC)config.h $(INC)dgn_file.h dgn_yacc.c
X	$(CC) $(CFLAGS) dgn_yacc.c
Xdgn_lex.obj  : $(INC)config.h $(INC)dgn_comp.h $(INC)dgn_file.h dgn_lex.c
X	@ if f$search("lev_lex.h").nes."" then	$(MOVE) lev_lex.h stdio.h
X	$(CC) $(CFLAGS) dgn_lex.c
X	@ if f$search("stdio.h").nes."" then  $(MOVE) stdio.h lev_lex.h
Xdgn_main.obj : $(INC)config.h dgn_main.c
X	$(CC) $(CFLAGS) dgn_main.c
X
X$(INC)dgn_comp.h : dgn_yacc.c
X	$(TOUCH) $(INC)dgn_comp.h
X
Xdgn_yacc.c : dgn_comp.y
X	$(YACC) dgn_comp.y
X	$(MUNG) 'f$parse("$(YACCOUT)","dgn_comp_tab.c")' "#module" /Outp=dgn_yacc.c
X	@ if f$search("''f$parse("$(YACCOUT)","dgn_comp_tab.c")'").nes."" then \
X		delete 'f$parse("$(YACCOUT)","dgn_comp_tab.c")'
X	$(MOVE) 'f$parse("$(YACCOUT)","dgn_comp_tab.h")' $(INC)dgn_comp.h
X
Xdgn_lex.c : dgn_comp.l
X	$(LEX) dgn_comp.l
X	$(MUNG) 'f$parse("$(LEXOUT)","dgn_comp_lex.c")' "#module" /Outp=dgn_lex.c
X	@ if f$search("''f$parse("$(LEXOUT)","dgn_comp_lex.c")'").nes."" then \
X		delete 'f$parse("$(LEXOUT)","dgn_comp_lex.c")'
X
X
X#	dependencies for recover
X#
X$(RECOVER) : $(RECOVOBJS) $(VMSRECOBJS)		# $(LIBOPT)
X	$(LINK) $(LFLAGS) $(RECOVOBJS),$(VMSRECOBJS),$(LIBS)
X
Xrecover.obj : $(INC)config.h
X
X
X# make sure object files from src are available when needed
X#
X$(SRC)alloc.obj : $(SRC)alloc.c $(INC)config.h
X	$(CD) $(SRC)
X	$(MAKE)$(MAKEFLAGS) alloc.obj
X      @ $(CD) $(UTL)
X
X$(SRC)monst.obj : $(SRC)monst.c $(INC)config.h
X	$(CD) $(SRC)
X	$(MAKE)$(MAKEFLAGS) monst.obj
X      @ $(CD) $(UTL)
X
X$(SRC)objects.obj : $(SRC)objects.c $(INC)config.h
X	$(CD) $(SRC)
X	$(MAKE)$(MAKEFLAGS) objects.obj
X      @ $(CD) $(UTL)
X
X$(SRC)decl.obj : $(SRC)decl.c $(INC)hack.h
X	$(CD) $(SRC)
X	$(MAKE)$(MAKEFLAGS) decl.obj
X      @ $(CD) $(UTL)
X
X$(SRC)drawing.obj : $(SRC)drawing.c $(INC)hack.h
X	$(CD) $(SRC)
X	$(MAKE)$(MAKEFLAGS) drawing.obj
X      @ $(CD) $(UTL)
X
X# make sure hack.h dependencies get transitive information
X$(INC)hack.h : $(INC)config.h
X	$(CD) $(SRC)
X	$(MAKE)$(MAKEFLAGS) $(INC)hack.h
X      @ $(CD) $(UTL)
X
X# VMS specific dependencies
X$(SRC)vmsmisc.obj :	$(VMS)vmsmisc.c
X	$(CD) $(SRC)
X	$(MAKE)$(MAKEFLAGS) vmsmisc.obj
X      @ $(CD) $(UTL)
X
X$(SRC)vmsfiles.obj :	$(VMS)vmsfiles.c $(INC)config.h
X	$(CD) $(SRC)
X	$(MAKE)$(MAKEFLAGS) vmsfiles.obj
X      @ $(CD) $(UTL)
X
X
Xclean :
X      - if f$search("*.*;-1").nes."" then  purge
X      - if f$search("*.obj") .nes."" then  delete *.obj;
X
Xspotless :	clean
X      - if f$search("%%%_lex.c") .nes."" then  delete %%%_lex.c;
X      - if f$search("%%%_yacc.c").nes."" then  delete %%%_yacc.c;
X      - if f$search("$(INC)%%%_comp.h").nes."" then  delete $(INC)%%%_comp.h;
X      - if f$search("lev_lex.h") .nes."" then  delete lev_lex.h;
X      - if f$search("*tab.c")	 .nes."" then  delete *tab.c;
X      - if f$search("*.exe").nes."" then \
X delete $(MAKEDEFS),$(LEVCOMP),$(DGNCOMP),$(RECOVER)
END_OF_FILE
if test 9299 -ne `wc -c <'sys/vms/Makefile.utl'`; then
    echo shar: \"'sys/vms/Makefile.utl'\" unpacked with wrong size!
fi
# end of 'sys/vms/Makefile.utl'
fi
echo shar: End of archive 94 \(of 108\).
cp /dev/null ark94isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \
21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \
41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 \
61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 \
81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 \
101 102 103 104 105 106 107 108 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 108 archives.
    echo "Now execute 'rebuild.sh'"
    rm -f ark10[0-8]isdone ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
