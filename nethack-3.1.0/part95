Path: uunet!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v16i103:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Part95/108
Message-ID: <4468@master.CNA.TEK.COM>
Date: 5 Feb 93 22:03:01 GMT
Sender: news@master.CNA.TEK.COM
Lines: 2265
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1654

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 16, Issue 103
Archive-name: nethack31/Part95
Supersedes: nethack3p9: Volume 10, Issue 46-108
Environment: Amiga, Atari, Mac, MS-DOS, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 95 (of 108)."
# Contents:  Files include/display.h src/allmain.c src/mcastu.c
#   sys/mac/mactopl.c sys/share/pcsys.c
# Wrapped by billr@saab on Wed Jan 27 16:09:26 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'Files' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Files'\"
else
echo shar: Extracting \"'Files'\" \(9012 characters\)
sed "s/^X//" >'Files' <<'END_OF_FILE'
XThis is a listing of all files in a full NetHack 3.1 distribution, organized
Xin their standard manner on a UNIX system.  It indicates which files are
Xnecessary for which versions, so that you can tell which files may be deleted
Xfrom or not transferred to your system if you wish.
X
X
X(files in top directory)
XFiles           Porting         README
X
Xdat:
X(files for all versions)
XArch.des        Barb.des        Caveman.des     Elf.des         Healer.des
XKnight.des      Priest.des      Rogue.des       Samurai.des     Tourist.des
XValkyrie.des    Wizard.des      bigroom.des     castle.des      cmdhelp
Xdata.base       dungeon.def     endgame.des     gehennom.des    help
Xhh              history         knox.des        license         medusa.des
Xmines.des       opthelp         oracle.des      oracles.txt     quest.txt
Xrumors.fal      rumors.tru      tower.des       wizhelp         yendor.des
X
Xdoc:
X(files for all versions)
XGuidebook.mn    Guidebook.tex   Guidebook.txt   dgn_comp.6      lev_comp.6
Xnethack.6       recover.6       tmac.n          window.doc
X
Xinclude:
X(files for all versions)
Xalign.h         amiconf.h       artifact.h      artilist.h      attrib.h
Xcolor.h         config.h        coord.h         decl.h          def_os2.h
Xdgn_file.h      display.h       dungeon.h       edog.h          emin.h
Xengrave.h       epri.h          eshk.h          extern.h        flag.h
Xfunc_tab.h      global.h        hack.h          lev.h           macconf.h
Xmail.h          mfndpos.h       micro.h         mkroom.h        monattk.h
Xmondata.h       monflag.h       monst.h         monsym.h        obj.h
Xobjclass.h      os2conf.h       patchlevel.h    pcconf.h        permonst.h
Xprop.h          qtext.h         quest.h         rect.h          rm.h
Xsp_lev.h        spell.h         system.h        termcap.h       tosconf.h
Xtradstdc.h      trampoli.h      trap.h          unixconf.h      vault.h
Xvision.h        vmsconf.h       winami.h        winprocs.h      wintype.h
Xyou.h           youprop.h
X(file for tty versions)
Xwintty.h
X(files for X versions)
XWindow.h        WindowP.h       winX.h
X
Xsrc:
X(files for all versions)
Xallmain.c       alloc.c         apply.c         artifact.c      attrib.c
Xball.c          bones.c         botl.c          cmd.c           dbridge.c
Xdecl.c          detect.c        display.c       do.c            do_name.c
Xdo_wear.c       dog.c           dogmove.c       dokick.c        dothrow.c
Xdrawing.c       dungeon.c       eat.c           end.c           engrave.c
Xexper.c         explode.c       extralev.c      files.c         fountain.c
Xhack.c          hacklib.c       invent.c        lock.c          mail.c
Xmakemon.c       mcastu.c        mhitm.c         mhitu.c         minion.c
Xmklev.c         mkmap.c         mkmaze.c        mkobj.c         mkroom.c
Xmon.c           mondata.c       monmove.c       monst.c         mplayer.c
Xmthrowu.c       muse.c          music.c         o_init.c        objects.c
Xobjnam.c        options.c       pager.c         pickup.c        pline.c
Xpolyself.c      potion.c        pray.c          priest.c        quest.c
Xquestpgr.c      read.c          rect.c          restore.c       rip.c
Xrnd.c           rumors.c        save.c          shk.c           shknam.c
Xsit.c           sounds.c        sp_lev.c        spell.c         steal.c
Xtimeout.c       topten.c        track.c         trap.c          u_init.c
Xuhitm.c         vault.c         version.c       vision.c        weapon.c
Xwere.c          wield.c         windows.c       wizard.c        worm.c
Xworn.c          write.c         zap.c
X
Xsys/amiga:
X(files for Amiga version)
XHackWB.uu       Install.ami     Makefile.ami    NHinfo.uu       NetHack.cnf
XNewGame.uu      amidos.c        amidos.p        amifont.uu      amifont8.uu
Xamigst.c        amii.hlp        amimenu.c       amirip.c        amiwbench.c
Xamiwind.c       amiwind.p       ask.uu          char.c          charwin.uu
Xcolors.uu       colorwin.c      dflticon.uu     hackwb.hlp      ifchange
Xrandwin.c       randwin.uu      scroll.uu       string.uu       wb.c
Xwbcli.c         wbdata.c        wbdefs.h        wbprotos.h      wbstruct.h
Xwbwin.c         wbwin.uu        winami.c        winami.p
X
Xsys/amiga/splitter:
X(more files for Amiga version)
Xamiout.h        arg.c           arg.h           loader.c        multi.c
Xmulti.h         split.doc       split.h         splitter.c
X
Xsys/atari:
X(files for Atari version)
XInstall.tos     Makefile.utl    atari.cnf       atarifnt.uue    nethack.mnu
Xsetup.g         tos.c
X
Xsys/mac:
X(files for Macintosh version)
XInstall.mpw     MacHelp         NHmake.hqx      NHrez.hqx       NHrsrc.hqx
XNHsound.hqx     News            hack.h          maccurs.c       macerrs.c
Xmacfile.c       macmain.c       macsnd.c        mactopl.c       macunix.c
Xmacwin.c        mgetline.c      mhdump.c        mmodal.c        mstring.c
X
Xsys/msdos:
X(files for MSDOS versions)
XInstall.dos     MakeGCC.src     MakeGCC.utl     MakeMSC.src     MakeMSC.utl
XMakefile.dat    exesmurf.c      exesmurf.doc    maintovl.doc    msdos.c
Xovlmgr.asm      ovlmgr.doc      ovlmgr.uu       setup.bat       trampoli.c
X(files for running MSDOS binary under Windows)
Xnhico.uu        nhpif.uu
X
Xsys/os2:
X(files for OS/2 version)
XInstall.os2     Makefile.os2    nhpmico.uu      os2.c
X
Xsys/share:
X(files for MSDOS and OS/2 versions)
XMakefile.lib    NetHack.cnf     termcap.uu
X(file for MSDOS, OS/2, Amiga, and Atari versions)
Xpcmain.c
X(files for MSDOS, OS/2 and Atari versions)
Xpcsys.c         pctty.c         pcunix.c
X(Berkeley random number file, which may be included in any version)
Xrandom.c
X(file for MSDOS, OS/2 and VMS versions)
Xtermcap
X(lex/yacc output for special level and dungeon compilers)
Xdgn_comp.h      dgn_lex.c       dgn_yacc.c      lev_comp.h      lev_lex.c
Xlev_yacc.c
X
Xsys/unix:
X(files for UNIX versions)
XInstall.unx     Makefile.dat    Makefile.doc    Makefile.src    Makefile.top
XMakefile.utl    ioctl.c         nethack.sh      setup.sh        unixmain.c
Xunixtty.c       unixunix.c
X(files for replacement cpp, apparently only needed by some UNIX systems)
Xcpp1.shr        cpp2.shr        cpp3.shr
X(file for sound driver for 386 UNIX)
Xsnd86unx.shr
X
Xsys/vms:
X(files for VMS version)
XInstall.vms     Makefile.dat    Makefile.doc    Makefile.src    Makefile.top
XMakefile.utl    install.com     lev_lex.h       nethack.com     oldcrtl.c
Xspec_lev.com    vmsbuild.com    vmsfiles.c      vmsmail.c       vmsmain.c
Xvmsmisc.c       vmstty.c        vmsunix.c
X(GNU termcap files that support VMS version)
Xgnutermcap.c    gnutparam.c
X
Xutil:
X(files for all versions)
Xdgn_main.c      lev_main.c      makedefs.c      panic.c         recover.c
X(lex/yacc input for special level and dungeon compilers)
Xdgn_comp.l      dgn_comp.y      lev_comp.l      lev_comp.y
X
Xwin/tty:
X(files for tty versions)
Xgetline.c       termcap.c       topl.c          wintty.c
X
Xwin/X11:
X(files for X versions)
XInstall.X11     NetHack.ad      Window.c        dialogs.c       ibm.bdf
Xnethack.rc      nh10.bdf        nh32icon        nh56icon        nh72icon
XwinX.c          winmap.c        winmenu.c       winmesg.c       winmisc.c
Xwinstat.c       wintext.c       winval.c
X
X
X
XThis is a list of files produced by auxiliary programs.  They can all be
Xregenerated from the files in the distribution.
X
Xdat:
X(files generated by makedefs at playground creation time)
Xdata            dungeon.pdf     options         oracles         quest.dat
Xrumors
X(file generated by dgn_comp at playground creation time)
Xdungeon
X(files generated by lev_comp at playground creation time)
XA-filla.lev     A-fillb.lev     A-goal.lev      A-locate.lev    A-start.lev
XB-filla.lev     B-fillb.lev     B-goal.lev      B-locate.lev    B-start.lev
XC-filla.lev     C-fillb.lev     C-goal.lev      C-locate.lev    C-start.lev
XE-filla.lev     E-fillb.lev     E-goal.lev      E-locate.lev    E-start.lev
XH-filla.lev     H-fillb.lev     H-goal.lev      H-locate.lev    H-start.lev
XK-filla.lev     K-fillb.lev     K-goal.lev      K-locate.lev    K-start.lev
XP-filla.lev     P-fillb.lev     P-goal.lev      P-locate.lev    P-start.lev
XR-filla.lev     R-fillb.lev     R-goal.lev      R-locate.lev    R-start.lev
XS-filla.lev     S-fillb.lev     S-goal.lev      S-locate.lev    S-start.lev
XT-filla.lev     T-fillb.lev     T-goal.lev      T-locate.lev    T-start.lev
XV-filla.lev     V-fillb.lev     V-goal.lev      V-locate.lev    V-start.lev
XW-filla.lev     W-fillb.lev     W-goal.lev      W-locate.lev    W-start.lev
Xair.lev         asmodeus.lev    astral.lev      baalz.lev       bigroom.lev
Xcastle.lev      earth.lev       fakewiz1.lev    fakewiz2.lev    fire.lev
Xjuiblex.lev     knox.lev        medusa-1.lev    medusa-2.lev    mine_end.lev
Xminefill.lev    minetown.lev    oracle.lev      orcus.lev       sanctum.lev
Xtower1.lev      tower2.lev      tower3.lev      valley.lev      water.lev
Xwizard1.lev     wizard2.lev     wizard3.lev
X
Xinclude:
X(files generated by makedefs at compile time)
Xdate.h          onames.h        pm.h            vis_tab.h
X
Xsrc:
X(files generated by makedefs at compile time)
Xmonstr.c        vis_tab.c
END_OF_FILE
if test 9012 -ne `wc -c <'Files'`; then
    echo shar: \"'Files'\" unpacked with wrong size!
fi
# end of 'Files'
fi
if test -f 'include/display.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/display.h'\"
else
echo shar: Extracting \"'include/display.h'\" \(9078 characters\)
sed "s/^X//" >'include/display.h' <<'END_OF_FILE'
X/*	SCCS Id: @(#)display.h	3.1	92/07/11		  */
X/* Copyright (c) Dean Luick, with acknowledgements to Kevin Darcy */
X/* and Dave Cohrs, 1990.					  */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#ifndef DISPLAY_H
X#define DISPLAY_H
X
X#ifndef VISION_H
X#include "vision.h"
X#endif
X
X#ifndef MONDATA_H
X#include "mondata.h"	/* for mindless() */
X#endif
X
X#ifndef INVISIBLE_OBJECTS
X#define vobj_at(x,y) (level.objects[x][y])
X#endif
X
X/*
X * sensemon()
X *  
X * Returns true if the hero can sense the given monster.  This includes
X * monsters that are hiding or mimicing other monsters.
X */
X#define sensemon(mon) (		/* The hero can always sense a monster IF:  */\
X    (!mindless(mon->data)) &&	/* 1. the monster has a brain to sense AND  */\
X      ((Blind && Telepat) ||	/* 2a. hero is blind and telepathic OR      */\
X    				/* 2b. hero is wearing a telepathy inducing */\
X				/*	 object and in range		    */\
X      ((HTelepat & (WORN_HELMET|WORN_AMUL|W_ART)) &&			      \
X	(distu(mon->mx, mon->my) <= (BOLT_LIM * BOLT_LIM))))		      \
X)
X
X
X/*
X * mon_visible()
X *  
X * Returns true if the hero can see the monster.  It is assumed that the
X * hero can physically see the location of the monster.  The function
X * vobj_at() returns a pointer to an object that the hero can see there.
X */
X#define mon_visible(mon) (		/* The hero can see the monster	    */\
X					/* IF the monster		    */\
X    (!mon->minvis || See_invisible) &&	/* 1. is not invisible AND	    */\
X    (!mon->mundetected)			/* 2. not an undetected hider	    */\
X)
X
X
X/*
X * canseemon()
X *  
X * This is the globally used canseemon().  It is not called within the display
X * routines.
X */
X#define canseemon(mon) (cansee(mon->mx, mon->my) && mon_visible(mon))
X
X
X/*
X * canspotmon(mon)
X *
X * This is sensemon() or mon_visible() except that hiding under objects
X * is considered irrelevant for this special case.
X */
X#define canspotmon(mon)	\
X	(mon && (Blind ? sensemon(mon) : (!mon->minvis || See_invisible)))
X
X/*
X * is_safepet(mon)
X *
X * A special case check used in attack() and domove().  Placing the
X * definition here is convenient.
X */
X#define is_safepet(mon)	\
X	(mon && mon->mtame && canspotmon(mon) && flags.safe_dog \
X		&& !Confusion && !Hallucination && !Stunned)
X
X
X/*
X * canseeself()
X *  
X * This returns true if the hero can see her/himself.
X *
X * The u.uswallow check assumes that you can see yourself even if you are
X * invisible.  If not, then we don't need the check.
X */
X#ifdef POLYSELF
X#define canseeself()	(Blind || u.uswallow || (!Invisible && !u.uundetected))
X#else
X#define canseeself()	(Blind || u.uswallow || !Invisible)
X#endif
X
X
X/*
X * random_monster()
X * random_object()
X *  
X * Respectively return a random monster or object number.
X */
X#define random_monster() rn2(NUMMONS)
X#define random_object()  (rn2(NROFOBJECTS) + 1)
X
X
X/*
X * what_obj()
X * what_mon()
X *  
X * If hallucinating, choose a random object/monster, otherwise, use the one
X * given.
X */
X#define what_obj(obj)	(Hallucination ? random_object()  : obj)
X#define what_mon(mon)	(Hallucination ? random_monster() : mon)
X
X
X/*
X * covers_objects()
X * covers_traps()
X *  
X * These routines are true if what is really at the given location will
X * "cover" any objects or traps that might be there.
X */
X#define covers_objects(xx,yy)						      \
X    ((is_pool(xx,yy) && !Underwater) || (levl[xx][yy].typ == LAVAPOOL))
X
X#define covers_traps(xx,yy)	covers_objects(xx,yy)
X
X
X/*
X * tmp_at() control calls.
X */
X#define DISP_BEAM   (-1)  /* Keep all glyphs showing & clean up at end. */
X#define DISP_FLASH  (-2)  /* Clean up each glyph before displaying new one. */
X#define DISP_CHANGE (-3)  /* Change glyph. */
X#define DISP_END    (-4)  /* Clean up. */
X
X
X/* Total number of cmap indices in the sheild_static[] array. */
X#define SHIELD_COUNT 21
X
X
X/*
X *  display_self()
X *  
X *  Display the hero.  This has degenerated down to this.  Perhaps there is
X *  more needed here, but I can't think of any cases.
X */
X#ifdef POLYSELF
X#define display_self()						\
X    show_glyph(u.ux, u.uy,					\
X	u.usym == 0 ? objnum_to_glyph(GOLD_PIECE) :		\
X	monnum_to_glyph((u.umonnum < 0 ? u.umonster : u.umonnum)))
X#else
X#define display_self()						\
X    show_glyph(u.ux, u.uy,					\
X	u.usym == 0 ? objnum_to_glyph(GOLD_PIECE) :		\
X	monnum_to_glyph(u.umonster))
X#endif
X
X
X/*
X * A glyph is an abstraction that represents a _unique_ monster, object,
X * dungeon part, or effect.  The uniqueness is important.  For example,
X * It is not enough to have four (one for each "direction") zap beam glyphs,
X * we need a set of four for each beam type.  Why go to so much trouble?
X * Because it is possible that any given window dependent display driver
X * [print_glyph()] can produce something different for each type of glyph.
X * That is, a beam of cold and a beam of fire would not only be different
X * colors, but would also be represented by different symbols.
X *
X * Glyphs are grouped for easy accessibility:
X *
X * monster	Represents all the wild (not tame) monsters.  Count: NUMMONS.
X *
X * pet		Represents all of the tame monsters.  Count: NUMMONS
X *
X * corpse	One for each monster.  Count: NUMMONS
X *
X * object	One for each object.  Count: NROFOBJECTS+1 (we need the +1
X *		because NROFOBJECTS does not include the illegal object)
X *
X * trap		One for each trap type.  Count: TRAPNUM
X *
X * cmap		One for each entry in the character map.  The character map
X *		is the dungeon features and other miscellaneous things.
X *		Count: MAXPCHARS
X *
X * zap beam	A set of four (there are four directions) for each beam type.
X *		The beam type is shifted over 2 positions and the direction
X *		is stored in the lower 2 bits.  Count: NUM_ZAP << 2
X *
X * swallow	A set of eight for each monster.  The eight positions rep-
X *		resent those surrounding the hero.  The monster number is
X *		shifted over 3 positions and the swallow position is stored
X *		in the lower three bits.  Count: NUMMONS << 3
X *
X * The following are offsets used to convert to and from a glyph.
X */
X#define NUM_ZAP	8	/* number of zap beam types */
X
X#define GLYPH_MON_OFF  	  0
X#define GLYPH_PET_OFF 	  (NUMMONS        + GLYPH_MON_OFF)
X#define GLYPH_BODY_OFF 	  (NUMMONS        + GLYPH_PET_OFF)
X#define GLYPH_OBJ_OFF 	  (NUMMONS        + GLYPH_BODY_OFF)
X#define GLYPH_TRAP_OFF	  (NROFOBJECTS+1  + GLYPH_OBJ_OFF)
X#define GLYPH_CMAP_OFF	  (TRAPNUM        + GLYPH_TRAP_OFF)
X#define GLYPH_ZAP_OFF	  (MAXPCHARS      + GLYPH_CMAP_OFF)
X#define GLYPH_SWALLOW_OFF ((NUM_ZAP << 2) + GLYPH_ZAP_OFF)
X
X#define MAX_GLYPH 	  ((NUMMONS << 3) + GLYPH_SWALLOW_OFF)
X
X
X#define mon_to_glyph(mon) ((int) what_mon(monsndx((mon)->data))+GLYPH_MON_OFF)
X#define pet_to_glyph(mon) ((int) what_mon(monsndx((mon)->data))+GLYPH_PET_OFF)
X
X/* This has the unfortunate side effect of needing a global variable	*/
X/* to store a result. 'otg_temp' is defined and declared in decl.{ch}.	*/
X#define obj_to_glyph(obj)						      \
X    (Hallucination ?							      \
X	((otg_temp = random_object()) == CORPSE ?			      \
X	    random_monster() + GLYPH_BODY_OFF :				      \
X	    otg_temp + GLYPH_OBJ_OFF)	:				      \
X	((obj)->otyp == CORPSE ?					      \
X	    (int) (obj)->corpsenm + GLYPH_BODY_OFF :			      \
X	    (int) (obj)->otyp + GLYPH_OBJ_OFF))
X
X#define trap_to_glyph(trap)	((int) (trap)->ttyp + GLYPH_TRAP_OFF)
X#define cmap_to_glyph(cmap_idx)	((int) (cmap_idx)   + GLYPH_CMAP_OFF)
X
X/* Not affected by hallucination.  Gives a generic body for CORPSE */
X#define objnum_to_glyph(onum)	((int) (onum) + GLYPH_OBJ_OFF)
X#define monnum_to_glyph(mnum)	((int) (mnum) + GLYPH_MON_OFF)
X#define petnum_to_glyph(mnum)	((int) (mnum) + GLYPH_PET_OFF)
X
X
X/*
X * Change the given glyph into it's given type.  Note:
X *	1) Pets are animals and are converted to the proper monster number.
X *	2) Bodies are all mapped into the generic CORPSE object
X *	3) glyph_to_swallow() does not return a showsyms[] index, but an
X *	   offset from the first swallow symbol.
X *	4) These functions assume that the glyph type has already been
X *	   determined.  That is, you have checked it with a glyph_is_XXXX()
X *	   call.
X */
X#define glyph_to_mon(glyph)	((int) ((glyph) < GLYPH_PET_OFF ?	      \
X				glyph - GLYPH_MON_OFF : glyph - GLYPH_PET_OFF))
X#define glyph_to_obj(glyph)	((int) ((glyph) < GLYPH_OBJ_OFF ?	      \
X				CORPSE : (glyph) - GLYPH_OBJ_OFF))
X#define glyph_to_trap(glyph)	((int) (glyph) - GLYPH_TRAP_OFF)
X#define glyph_to_cmap(glyph)	((int) (glyph) - GLYPH_CMAP_OFF)
X#define glyph_to_swallow(glyph) (((glyph) - GLYPH_SWALLOW_OFF) & 0x7)
X
X/*
X * Return true if the given glyph is what we want.  Note that bodies are
X * considered objects.
X */
X#define glyph_is_monster(glyph)						      \
X    ((glyph) >= GLYPH_MON_OFF && (glyph) < GLYPH_BODY_OFF)
X#define glyph_is_object(glyph)						      \
X    ((glyph) >= GLYPH_BODY_OFF && (glyph) < GLYPH_TRAP_OFF)
X#define glyph_is_trap(glyph)						      \
X    ((glyph) >= GLYPH_TRAP_OFF && (glyph) < GLYPH_CMAP_OFF)
X#define glyph_is_cmap(glyph)						      \
X    ((glyph) >= GLYPH_CMAP_OFF && (glyph) < GLYPH_ZAP_OFF)
X#define glyph_is_swallow(glyph) \
X    ((glyph) >= GLYPH_SWALLOW_OFF && (glyph) < MAX_GLYPH)
X
X#endif /* DISPLAY_H */
END_OF_FILE
if test 9078 -ne `wc -c <'include/display.h'`; then
    echo shar: \"'include/display.h'\" unpacked with wrong size!
fi
# end of 'include/display.h'
fi
if test -f 'src/allmain.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/allmain.c'\"
else
echo shar: Extracting \"'src/allmain.c'\" \(8946 characters\)
sed "s/^X//" >'src/allmain.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)allmain.c	3.1	92/11/13	*/
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X/* various code that was replicated in *main.c */
X
X#include "hack.h"
X
X#ifndef NO_SIGNAL
X#include <signal.h>
X#endif
X
X#ifdef OVL0
X
Xvoid
Xmoveloop()
X{
X#ifdef MICRO
X	char ch;
X	int abort_lev;
X#endif
X	int moverate = 0;
X	boolean didmove = 0;
X
X	/* Note:  these initializers don't do anything except guarantee that
X		we're linked properly.
X	*/
X	decl_init();
X	monst_init();
X	monstr_init();	/* monster strengths */
X	objects_init();
X
X#ifdef MULDGN
X	quest_init();	/* set up dynamic quest data */
X#endif
X
X	(void) encumber_msg(); /* in case they auto-picked up something */
X
X	for(;;) {
X#ifdef CLIPPING
X		cliparound(u.ux, u.uy);
X#endif
X#if defined(MAC_MPW32) && !defined(MODEL_FAR)
X		UnloadAllSegments();  /* Marks non-resident segments as purgeable */
X#endif
X		get_nh_event();
X
X		didmove = flags.move;
X		if(flags.move) {	/* actual time passed */
X		    int wtcap;
X
X		    if (u.utotype) deferred_goto();
X		    wtcap = encumber_msg();
X
X#ifdef SOUNDS
X		    dosounds();
X#endif
X
X		    if(moverate <= 0) {
X			/* calculate how much time passed. */
X			int moveamt = 0;
X			if(Fast & ~INTRINSIC) moveamt = 6;
X			else if(Fast) moveamt = 8;
X			else moveamt = 12;
X
X			switch(wtcap) {
X			case UNENCUMBERED: break;
X			case SLT_ENCUMBER: moveamt = (moveamt * 4) / 3; break;
X			case MOD_ENCUMBER: moveamt *= 2; break;
X			case HVY_ENCUMBER: moveamt *= 4; break;
X			default: moveamt *= 12; break;
X			}
X			moverate += moveamt;
X			settrack();
X		    }
X
X		    if(moverate > 0) {
X			movemon();
X			/* a monster may have levteleported player -dlc */
X			if (u.utotype) deferred_goto();
X			if(!rn2(u.uevent.udemigod ? 25 :
X				(depth(&u.uz) >
X				 depth(&stronghold_level))
X				? 50 : 70))
X			    (void) makemon((struct permonst *)0, 0, 0);
X			++monstermoves;
X			remove_cadavers(&fobj);
X			remove_cadavers(&invent);
X			moverate -= 12;
X		    }
X		    if(Glib) glibr();
X		    nh_timeout();
X		    ++moves;
X		    if (u.ublesscnt)  u.ublesscnt--;
X		    if(flags.time) flags.botl = 1;
X#ifdef POLYSELF
X		    if (u.mtimedone && u.mh < u.mhmax) {
X			if (u.mh < 1) {
X			    rehumanize();
X			    moverate = 0;
X			} else if (Regeneration ||
X				 (wtcap < MOD_ENCUMBER && !(moves%20))) {
X			    flags.botl = 1;
X			    u.mh++;
X			}
X		    } else
X#endif
X		    if(u.uhp < u.uhpmax) {
X			if(u.ulevel > 9) {
X			    int heal;
X
X			    if(HRegeneration ||
X			       (!(moves%3) &&
X				(wtcap < MOD_ENCUMBER || !flags.mv))) {
X				flags.botl = 1;
X				if (ACURR(A_CON) <= 12) heal = 1;
X				else heal = rnd((int) ACURR(A_CON)-12);
X				if (heal > u.ulevel-9) heal = u.ulevel-9;
X				u.uhp += heal;
X				if(u.uhp > u.uhpmax)
X				    u.uhp = u.uhpmax;
X			    }
X			} else if(HRegeneration ||
X				  ((wtcap < MOD_ENCUMBER || !flags.mv) &&
X				   (!(moves%((MAXULEV+12)/(u.ulevel+2)+1))))) {
X			    flags.botl = 1;
X			    u.uhp++;
X			}
X		    }
X
X		    if (wtcap > MOD_ENCUMBER && flags.mv) {
X			if(!(wtcap < EXT_ENCUMBER ? moves%30 : moves%10)) {
X			    if(u.uhp > 1) {
X				u.uhp--;
X			    } else {
X				pline("You pass out from exertion!");
X				exercise(A_CON, FALSE);
X				nomul(-10);
X				u.usleep = 1;
X			    }
X			}
X		    }
X
X		    if ((u.uen < u.uenmax) &&
X			((wtcap < MOD_ENCUMBER &&
X			  (!(moves%((MAXULEV + 1 - u.ulevel) *
X				    (pl_character[0] == 'W' ? 3 : 4) / 2))))
X			 || Energy_regeneration)) {
X			u.uen +=
X			    rn1((int)(ACURR(A_WIS) + ACURR(A_INT)) / 10 + 1,1);
X			if (u.uen > u.uenmax)  u.uen = u.uenmax;
X			flags.botl = 1;
X		    }
X
X		    if(!u.uinvulnerable) {
X			if(Teleportation && !rn2(85)) tele();
X#ifdef POLYSELF
X			if(Polymorph && !rn2(100)) {
X			    if (multi >= 0) {
X				if (occupation)
X				    stop_occupation();
X				else
X				    nomul(0);
X			    }
X			    polyself();
X			    moverate = 0;
X			} else if (u.ulycn >= 0 && !rn2(80 - (20 * night()))) {
X			    if (multi >= 0) {
X				if (occupation)
X				    stop_occupation();
X				else
X				    nomul(0);
X			    }
X			    you_were();
X			    moverate = 0;
X			}
X#endif
X		    }
X
X		    if(Searching && multi >= 0) (void) dosearch0(1);
X		    do_storms();
X		    hatch_eggs();
X		    burn_lamps();
X		    gethungry();
X		    exerchk();
X		    invault();
X		    amulet();
X		    if (!rn2(40+(int)(ACURR(A_DEX)*3))) 
X			u_wipe_engr(rnd(3));
X		    if (u.uevent.udemigod && !u.uinvulnerable) {
X			if (u.udg_cnt) u.udg_cnt--;
X			if (!u.udg_cnt) {
X			    intervene();
X			    u.udg_cnt = rn1(200, 50);
X			}
X		    }
X		    restore_attrib();
X		    /* underwater and waterlevel vision are done here */
X		    if (Is_waterlevel(&u.uz))
X			movebubbles();
X		    else if (Underwater)
X			under_water(0);
X
X		}
X		if(multi < 0) {
X			if(!++multi){
X				pline(nomovemsg ? nomovemsg :
X					(const char *)"You can move again.");
X				nomovemsg = 0;
X				u.usleep = 0;
X				if(afternmv) (*afternmv)();
X				afternmv = 0;
X			}
X		}
X
X		find_ac();
X		if(!flags.mv || Blind) {
X		    /* redo monsters if hallu or wearing a helm of telepathy */
X		    if (Hallucination ||
X			(HTelepat & (WORN_HELMET|WORN_AMUL|W_ART)))
X			see_monsters();
X
X		    /* redo objects if hallucinating */
X		    if (Hallucination) see_objects();
X
X		    /* update swallowed display */
X		    if (Hallucination && u.uswallow) swallowed(0);
X
X		    if (vision_full_recalc) vision_recalc(0);	/* vision! */
X		}
X		if(flags.botl || flags.botlx) bot();
X
X		flags.move = 1;
X
X		if(multi >= 0 && occupation) {
X#ifdef MICRO
X			abort_lev = 0;
X			if (kbhit()) {
X				if ((ch = Getchar()) == ABORT)
X					abort_lev++;
X# ifdef REDO
X				else
X					pushch(ch);
X# endif /* REDO */
X			}
X			if (!abort_lev && (*occupation)() == 0)
X#else
X			if ((*occupation)() == 0)
X#endif
X				occupation = 0;
X			if(
X#ifdef MICRO
X			   abort_lev ||
X#endif
X			   monster_nearby()) {
X				stop_occupation();
X				reset_eat();
X			}
X#ifdef MICRO
X			if (!(++occtime % 7))
X				display_nhwindow(WIN_MAP, FALSE);
X#endif
X			continue;
X		}
X
X		if((u.uhave.amulet || Clairvoyant) && !In_endgame(&u.uz) &&
X						!(moves%15) && !rn2(2))
X			do_vicinity_map();
X
X		if(u.utrap && u.utraptype == TT_LAVA) {
X		    if(!is_lava(u.ux,u.uy))
X			u.utrap = 0;
X		    else {
X			u.utrap -= 1<<8;
X			if(u.utrap < 1<<8) {
X			    killer_format = KILLED_BY;
X			    killer = "molten lava";
X			    You("sink below the surface and suffocate.");
X			    done(DROWNING); /*whatever*/
X			} else if(didmove && !u.umoved) {
X			    Norep("You sink deeper into the lava.");
X			    u.utrap += rnd(4);
X			}
X		    }
X		}
X
X		u.umoved = FALSE;
X		if(!didmove || moverate <= 0) {
X		    if(multi > 0) {
X			lookaround();
X			if(!multi) {	/* lookaround may clear multi */
X				flags.move = 0;
X				continue;
X			}
X			if(flags.mv) {
X				if(multi < COLNO && !--multi)
X					flags.mv = flags.run = 0;
X				domove();
X			} else {
X				--multi;
X				rhack(save_cm);
X			}
X		    } else if(multi == 0) {
X#ifdef MAIL
X			ckmailstatus();
X#endif
X			rhack(NULL);
X		    }
X		}
X		if (vision_full_recalc) vision_recalc(0);	/* vision! */
X		if(multi && multi%7 == 0)
X			display_nhwindow(WIN_MAP, FALSE);
X	}
X}
X
X#endif /* OVL0 */
X#ifdef OVL1
X
Xvoid
Xstop_occupation()
X{
X	if(occupation) {
X		You("stop %s.", occtxt);
X		occupation = 0;
X/* fainting stops your occupation, there's no reason to sync.
X		sync_hunger();
X*/
X#ifdef REDO
X		nomul(0);
X		pushch(0);
X#endif
X	}
X}
X
X#endif /* OVL1 */
X#ifdef OVLB
X
Xvoid
Xdisplay_gamewindows()
X{
X    WIN_MESSAGE = create_nhwindow(NHW_MESSAGE);
X    WIN_STATUS = create_nhwindow(NHW_STATUS);
X    WIN_MAP = create_nhwindow(NHW_MAP);
X    WIN_INVEN = create_nhwindow(NHW_MENU);
X
X#ifdef MAC
X    /*
X     * This _is_ the right place for this - maybe we will
X     * have to split display_gamewindows into create_gamewindows
X     * and show_gamewindows to get rid of this ifdef...
X     */
X    SanePositions ( ) ;
X#endif
X
X    /*
X     * The mac port is not DEPENDENT on the order of these
X     * displays, but it looks a lot better this way...
X     */
X    display_nhwindow(WIN_STATUS, FALSE);
X    display_nhwindow(WIN_MESSAGE, FALSE);
X    display_nhwindow(WIN_MAP, FALSE);
X}
X
Xvoid
Xnewgame()
X{
X#ifdef MFLOPPY
X	gameDiskPrompt();
X#endif
X
X	fobj = invent = migrating_objs = (struct obj *)0;
X	fmon = migrating_mons = (struct monst *)0;
X	ftrap = 0;
X	flags.ident = 1;
X
X	if(wiz1_level.dlevel == 0) init_dungeons();
X	init_objects();
X	u_init();
X
X#ifndef NO_SIGNAL
X	(void) signal(SIGINT, (SIG_RET_TYPE) done1);
X#endif
X#ifdef NEWS
X	if(flags.news) display_file(NEWS, FALSE);
X#endif
X#ifdef MULDGN
X	load_qtlist();	/* load up the quest text info */
X	if(flags.legacy && moves == 1) com_pager(1);
X#endif
X	mklev();
X	u_on_upstairs();
X	check_special_room(FALSE);
X	vision_reset();		/* set up internals for level (after mklev) */
X
X	flags.botlx = 1;
X
X	/* Move the monster from under you or else
X	 * makedog() will fail when it calls makemon().
X	 * 			- ucsfcgl!kneller
X	 */
X	if(MON_AT(u.ux, u.uy)) mnexto(m_at(u.ux, u.uy));
X
X#ifdef CLIPPING
X	cliparound(u.ux, u.uy);
X#endif
X	(void) makedog();
X	docrt();
X
X#ifdef INSURANCE
X	save_currentstate();
X#endif
X	return;
X}
X
X#endif /* OVLB */
X
X/*allmain.c*/
END_OF_FILE
if test 8946 -ne `wc -c <'src/allmain.c'`; then
    echo shar: \"'src/allmain.c'\" unpacked with wrong size!
fi
# end of 'src/allmain.c'
fi
if test -f 'src/mcastu.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/mcastu.c'\"
else
echo shar: Extracting \"'src/mcastu.c'\" \(8760 characters\)
sed "s/^X//" >'src/mcastu.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)mcastu.c	3.1	90/09/21
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include	"hack.h"
X
X#ifdef OVL0
X
Xstatic void FDECL(cursetxt,(struct monst *));
Xconst char *spelltyp[] = {
X	"shower of missiles",
X	"fireball",
X	"sleep ray",
X	"cone of cold",
X	"finger of death",
X	"bolt of lightning",
X	"",
X	"",
X	"",
X	""
X};
X
Xstatic
Xvoid
Xcursetxt(mtmp)
X	register struct monst *mtmp;
X{
X	if(canseemon(mtmp)) {
X	    if ((Invis && !perceives(mtmp->data) &&
X				(mtmp->mux != u.ux || mtmp->muy != u.uy))
X#ifdef POLYSELF
X			|| u.usym == S_MIMIC_DEF || u.uundetected
X#endif
X									)
X		pline("%s points and curses in your general direction.",
X				Monnam(mtmp));
X	    else if (Displaced && (mtmp->mux != u.ux || mtmp->muy != u.uy))
X		pline("%s points and curses at your displaced image.",
X				Monnam(mtmp));
X	    else
X		pline("%s points at you, then curses.", Monnam(mtmp));
X	} else if((!(moves%4) || !rn2(4)) && flags.soundok) 
X		Norep("You hear a mumbled curse.");
X}
X
X#endif /* OVL0 */
X#ifdef OVLB
X
Xint
Xcastmu(mtmp, mattk)	/* monster casts spell at you */
X	register struct monst *mtmp;
X	register struct attack *mattk;
X{
X	int	dmg, ml = mtmp->m_lev;
X
X	if(mtmp->mcan || mtmp->mspec_used || !ml) {  /* could not attack */
X	    cursetxt(mtmp);
X	    return(0);
X	} else {
X	    nomul(0);
X	    if(rn2(ml*10) < (mtmp->mconf ? 100 : 20)) {	/* fumbled attack */
X		if(canseemon(mtmp)
X#ifdef SOUNDS
X				&& flags.soundok
X#endif
X							)
X		    pline("The air crackles around %s.", mon_nam(mtmp));
X		return(0);
X	    }
X	}
X/*
X *	As these are spells, the damage is related to the level
X *	of the monster casting the spell.
X */
X	if (mattk->damd)
X		dmg = d((int)((ml/3) + mattk->damn), (int)mattk->damd);
X	else dmg = d((int)((ml/3) + 1), 6);
X	if (Half_spell_damage) dmg = (dmg+1) / 2;
X
X	switch(mattk->adtyp)   {
X
X	    case AD_FIRE:
X		pline("You're enveloped in flames.");
X		if(Fire_resistance) {
X			shieldeff(u.ux, u.uy);
X			pline("But you resist the effects.");
X			dmg = 0;
X		}
X		break;
X	    case AD_COLD:
X		pline("You're covered in frost.");
X		if(Cold_resistance) {
X			shieldeff(u.ux, u.uy);
X			pline("But you resist the effects.");
X			dmg = 0;
X		}
X		break;
X	    case AD_MAGM:
X		You("are hit by a shower of missiles!");
X		if(Antimagic) {
X			shieldeff(u.ux, u.uy);
X			pline("The missiles bounce off!");
X			dmg = 0;
X		} else dmg = d((int)mtmp->m_lev/2 + 1,6);
X		break;
X	    case AD_SPEL:	/* random spell */
X
X		mtmp->mspec_used = 10 - mtmp->m_lev;
X		if (mtmp->mspec_used < 2) mtmp->mspec_used = 2;
X		switch(rn2((int)mtmp->m_lev)) {
X		    case 22:
X		    case 21:
X		    case 20:
X			pline("Oh no, %s's using the touch of death!",
X			      humanoid(mtmp->data)
X				  ? (mtmp->female ? "she" : "he")
X				  : "it"
X			     );
X#ifdef POLYSELF
X			if (is_undead(uasmon))
X			    You("seem no deader than before.");
X			else
X#endif
X			if (!Antimagic && rn2(ml) > 12) {
X
X			    if(Hallucination)
X				You("have an out of body experience.");
X			    else  {
X				killer_format = KILLED_BY_AN;
X				killer = "touch of death";
X				done(DIED);
X			    }
X			} else {
X				if(Antimagic) shieldeff(u.ux, u.uy);
X				pline("Lucky for you, it didn't work!");
X			}
X			dmg = 0;
X			break;
X		    case 19:
X		    case 18:
X			if(mtmp->iswiz && flags.no_of_wizards == 1) {
X				pline("Double Trouble...");
X				clonewiz();
X				dmg = 0;
X				break;
X			} /* else fall into the next case */
X		    case 17:
X		    case 16:
X		    case 15:
X			if(mtmp->iswiz)
X			    verbalize("Destroy the thief, my pets!");
X			nasty(mtmp);	/* summon something nasty */
X			/* fall into the next case */
X		    case 14:		/* aggravate all monsters */
X		    case 13:
X			aggravate();
X			dmg = 0;
X			break;
X		    case 12:		/* curse random items */
X		    case 11:
X		    case 10:
X			rndcurse();
X			dmg = 0;
X			break;
X		    case 9:
X		    case 8:		/* destroy armor */
X			if (Antimagic) {
X				shieldeff(u.ux, u.uy);
X				pline("A field of force surrounds you!");
X			} else if(!destroy_arm(some_armor()))
X				Your("skin itches.");
X			dmg = 0;
X			break;
X		    case 7:
X		    case 6:		/* drain strength */
X			if(Antimagic) {
X			    shieldeff(u.ux, u.uy);
X			    You("feel momentarily weakened.");
X			} else {
X			    You("suddenly feel weaker!");
X			    dmg = ml - 6;
X			    if(Half_spell_damage) dmg = (dmg+1) / 2;
X			    losestr(rnd(dmg));
X			    if(u.uhp < 1)
X				done_in_by(mtmp);
X			}
X			dmg = 0;
X			break;
X		    case 5:		/* make invisible if not */
X		    case 4:
X			if(!mtmp->minvis) {
X			    if(canseemon(mtmp) && !See_invisible)
X				pline("%s suddenly disappears!",
X				      Monnam(mtmp));
X			    mtmp->minvis = 1;
X			    newsym(mtmp->mx,mtmp->my);
X			    dmg = 0;
X			    break;
X			} /* else fall into the next case */
X		    case 3:		/* stun */
X			if(Antimagic) {
X			    shieldeff(u.ux, u.uy);
X			    if(!Stunned)
X				You("feel momentarily disoriented.");
X			    make_stunned(1L, FALSE);
X			} else {
X			    if (Stunned)
X				You("struggle to keep your balance.");
X			    else
X				You("reel....");
X			    dmg = d(ACURR(A_DEX) < 12 ? 6 : 4, 4);
X			    if(Half_spell_damage) dmg = (dmg+1) / 2;
X			    make_stunned(HStun + dmg, FALSE);
X			}
X			dmg = 0;
X			break;
X		    case 2:		/* haste self */
X			if(mtmp->mspeed == MSLOW)	mtmp->mspeed = 0;
X			else				mtmp->mspeed = MFAST;
X			dmg = 0;
X			break;
X		    case 1:		/* cure self */
X			if(mtmp->mhp < mtmp->mhpmax) {
X			    if((mtmp->mhp += rnd(8)) > mtmp->mhpmax)
X				mtmp->mhp = mtmp->mhpmax;
X			    dmg = 0;
X			    break;
X			} /* else fall through to default case */
X		    default:		/* psi bolt */
X			if(Antimagic) {
X			    shieldeff(u.ux, u.uy);
X			    You("get a slight %sache.",body_part(HEAD));
X			    dmg = 1;
X			} else {
X			    if (dmg <= 10)
X				Your("brain is on fire!");
X			    else Your("%s suddenly aches!", body_part(HEAD));
X			}
X			break;
X		}
X		break;
X		
X	    case AD_CLRC:	/* clerical spell */
X
X		mtmp->mspec_used = 10 - mtmp->m_lev;
X		if (mtmp->mspec_used < 2) mtmp->mspec_used = 2;
X		switch(rn2((int)mtmp->m_lev)) {
X		    /* Other ideas: lightning bolts, towers of flame,
X				    gush of water  -3. */
X
X		    default:		/* confuse */
X			if(Antimagic) {
X			    shieldeff(u.ux, u.uy);
X			    You("feel momentarily dizzy.");
X			} else {
X			    dmg = (int)mtmp->m_lev;
X			    if(Half_spell_damage) dmg = (dmg+1) / 2;
X			    make_confused(HConfusion + dmg, TRUE);
X			}
X			dmg = 0;
X			break;
X		    case 12:		/* curse random items */
X		    case 11:
X		    case 10:
X			rndcurse();
X			dmg = 0;
X			break;
X		    case 9:
X		    case 8:		/* insects */
X			/* Try for insects, and if there are none
X			   left, go for (sticks to) snakes.  -3. */
X			{
X			int i;
X			struct permonst *pm = mkclass(S_ANT,0);
X			struct monst *mtmp2;
X			char let = (pm ? S_ANT : S_SNAKE);
X  
X			for (i = 0; i <= (int) mtmp->m_lev; i++)
X			   if ((pm = mkclass(let,0)) &&
X					(mtmp2 = makemon(pm, u.ux, u.uy))) {
X				mtmp2->msleep = mtmp2->mpeaceful =
X					mtmp2->mtame = 0;
X				set_malign(mtmp2);
X			    }
X			}			
X			dmg = 0;
X			break;
X		    case 6:
X		    case 7:		/* blindness */
X			if (!Blinded) {
X			    pline("Scales cover your eyes!");
X			    make_blinded(Half_spell_damage ? 100L:200L, FALSE);
X			    dmg = 0;
X			    break;
X			}
X		    case 4:
X		    case 5:		/* wound */
X			if(Antimagic) {
X			    shieldeff(u.ux, u.uy);
X			    Your("skin itches badly for a moment.");
X			    dmg = 0;
X			} else {
X			    pline("Wounds appear on your body!");
X			    dmg = d(2,8) + 1;
X			    if (Half_spell_damage) dmg = (dmg+1) / 2;
X			}
X			break;
X		    case 3:		/* hold */
X			if(Antimagic) {
X			    shieldeff(u.ux, u.uy);
X			    if(multi >= 0)
X				You("stiffen briefly.");
X			    nomul(-1);
X		 	} else {
X			    if (multi >= 0)	
X			        You("are frozen in place!");
X			    dmg = 4 + (int)mtmp->m_lev;
X			    if (Half_spell_damage) dmg = (dmg+1) / 2;
X			    nomul(-dmg);
X			}
X			dmg = 0;
X			break;
X		    case 2:
X		    case 1:		/* cure self */
X			if(mtmp->mhp < mtmp->mhpmax) {
X			    if((mtmp->mhp += rnd(8)) > mtmp->mhpmax)
X				mtmp->mhp = mtmp->mhpmax;
X			    dmg = 0;
X			    break;
X			} /* else fall through to default case */
X		}
X	}
X	if(dmg) mdamageu(mtmp, dmg);
X	return(1);
X}
X
X#endif /* OVLB */
X#ifdef OVL0
X
Xint
Xbuzzmu(mtmp, mattk)		/* monster uses spell (ranged) */
X	register struct monst *mtmp;
X	register struct attack  *mattk;
X{
X	if(mtmp->mcan || mattk->adtyp > AD_SPC2) {
X	    cursetxt(mtmp);
X	    return(0);
X	}
X	if(lined_up(mtmp) && rn2(3)) {
X	    nomul(0);
X	    if(mattk->adtyp && (mattk->adtyp < 11)) { /* no cf unsigned >0 */
X		if(canseemon(mtmp))
X		    pline("%s zaps you with a %s!", Monnam(mtmp),
X			  spelltyp[mattk->adtyp-1]);
X		buzz((int) (-10 - (mattk->adtyp-1)), (int)mattk->damn,
X		     mtmp->mx, mtmp->my, sgn(tbx), sgn(tby));
X	    } else impossible("Monster spell %d cast", mattk->adtyp-1);
X	}
X	return(1);
X}
X
X#endif /* OVL0 */
X
X/*mcastu.c*/
END_OF_FILE
if test 8760 -ne `wc -c <'src/mcastu.c'`; then
    echo shar: \"'src/mcastu.c'\" unpacked with wrong size!
fi
# end of 'src/mcastu.c'
fi
if test -f 'sys/mac/mactopl.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/mac/mactopl.c'\"
else
echo shar: Extracting \"'sys/mac/mactopl.c'\" \(8925 characters\)
sed "s/^X//" >'sys/mac/mactopl.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)mactopl.c	3.1	91/07/23
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include "hack.h"
X#include <Dialogs.h>
X#include <OSUtils.h>
X#include <Packages.h>
X
X// int NDECL(mac_doprev_message);
X// char FDECL(yn_function,(const char *, const char *, CHAR_P));
X
Xint FDECL ( try_key_queue , ( char * ) ) ;
X
Xextern void SetFrameItem ( DialogPtr , short , short ) ;
Xextern void FlashButton ( DialogPtr , short ) ;
X
Xextern char * PtoCstr ( unsigned char * ) ;
Xextern unsigned char * CtoPstr ( char * ) ;
X
Xvoid FDECL ( enter_topl_mode , ( char * ) ) ;
Xvoid FDECL ( leave_topl_mode , ( char * ) ) ;
Xvoid FDECL ( topl_set_resp , ( char * , char ) ) ;
X
Xextern winid inSelect ;
Xextern short frame_corner ;
X
Xint
Xmac_doprev_message(void)
X{
X	NhWindow * aWin = & theWindows [ WIN_MESSAGE ] ;
X	char * start , * stop ;
X
X	if ( ! WIN_MESSAGE )
X		return 0 ;
X
X	stop = * aWin -> windowText ;
X	start = * aWin -> windowText + aWin -> textBase - 2 ;
X
X	while ( start > stop && * start != 10 && * start != 13 )
X		start -- ;
X
X	if ( start <= stop )
X		aWin -> textBase = 0L ;
X	else
X		aWin -> textBase = start - stop + 1 ;
X	if ( aWin -> textBase > aWin -> windowTextLen )
X		aWin -> textBase = aWin -> windowTextLen ;
X
X	display_nhwindow ( WIN_MESSAGE , FALSE ) ;
X	InvalRect ( & ( aWin -> theWindow -> portRect ) ) ;
X
X	return 0 ;
X}
X
X
Xchar
Xqueued_resp(char *resp)
X{
X	char buf[30];
X	if (try_key_queue(&buf)) {
X		if (!resp || strchr(resp, buf[0]))
X			return buf[0];
X		if (digit(buf[0]) && strchr(resp, '#')) {
X			yn_number = atoi(buf);
X			return '#';
X		}
X	}
X	return '\0';
X}
X
X
X#define YN_DLOG 133
X#define YNQ_DLOG 134
X#define YNAQ_DLOG 135
X#define YNNAQ_DLOG 136
X
Xstatic int yn_user_item [ ] = { 5 , 6 , 7 , 8 } ;
Xstatic short gEnterItem , gEscItem ;
Xstatic const char * gRespStr = NULL ;
Xstatic char gDef = 0 ;
Xstatic short dlogID ;
X
X
Xstatic void
XSetEnterItem ( DialogPtr dp , const short newEnterItem )
X{
X	short kind ;
X	Handle item ;
X	Rect r , r2 ;
X
X	if ( gEnterItem != newEnterItem ) {
X
X		GetDItem ( dp , gEnterItem , & kind , & item , & r2 ) ;
X		InsetRect ( & r2 , - 4 , - 4 ) ;
X		EraseRect ( & r2 ) ;
X		InvalRect ( & r2 ) ;
X
X		gEnterItem = newEnterItem ;
X
X		GetDItem ( dp , newEnterItem , & kind , & item , & r2 ) ;
X		frame_corner = kind == ctrlItem + btnCtrl ? 16 : 0 ;
X		InsetRect ( & r2 , - 4 , - 4 ) ;
X		InvalRect ( & r2 ) ;
X		r = r2 ;
X		GetDItem ( dp , yn_user_item [ dlogID - YN_DLOG ] , & kind , & item , & r2 ) ;
X		SetDItem ( dp , yn_user_item [ dlogID - YN_DLOG ] , kind , item , & r ) ;
X	}
X}
X
X
Xstatic void
Xdo_tabbing ( DialogPtr dp )
X{
X	SetEnterItem(dp, gEnterItem == 1 ? strlen(gRespStr) : gEnterItem - 1);
X}
X
X
Xstatic void
Xset_yn_number(DialogPtr dp)
X{
X	if (gRespStr && gRespStr[gEnterItem-1] == '#') {
X		short k;
X		Handle h;
X		Rect r;
X		Str255 s;
X		GetDItem(dp, gEnterItem, &k, &h, &r);
X		GetIText(h, s);
X		if (s[0])
X			StringToNum(s, &yn_number);
X	}
X}
X
X
Xpascal Boolean
XYNAQFilter ( DialogPtr dp , EventRecord * ev , short * itemHit )
X{
X	unsigned char code ;
X	char ch ;
X	char * re = gRespStr ;
X
X	if ( ev -> what != keyDown ) {
X
X		return 0 ;
X	}
X	code = ( ev -> message & 0xff00 ) >> 8 ;
X	ch = ev -> message & 0xff ;
X
X	switch ( code ) {
X
X	case 0x24 :
X	case 0x4c :
X		set_yn_number ( dp ) ;
X		* itemHit = gEnterItem ;
X		FlashButton ( dp , * itemHit ) ;
X		return 1 ;
X
X	case 0x35 :
X	case 0x47 :
X		* itemHit = gEscItem ;
X		FlashButton ( dp , * itemHit ) ;
X		return 1 ;
X
X	case 0x30 :
X		do_tabbing ( dp ) ;
X		return 0 ;
X	}
X	switch ( ch ) {
X
X	case '\r' :
X	case '\n' :
X	case ' ' :
X	case 3 :
X		set_yn_number ( dp ) ;
X		* itemHit = gEnterItem ;
X		FlashButton ( dp , * itemHit ) ;
X		return 1 ;
X
X	case 9 :
X		do_tabbing ( dp ) ;
X		return 0 ;
X
X	case 27 :
X		* itemHit = gEscItem ;
X		FlashButton ( dp , * itemHit ) ;
X		return 1 ;
X
X	case CHAR_BS :
X	case 28 : case 29 : case 30 : case 31 : /* the four arrow keys */
X	case '0' : case '1' : case '2' : case '3' : case '4' :
X	case '5' : case '6' : case '7' : case '8' : case '9' :
X	{	char * loc = strchr ( gRespStr , '#' ) ;
X		if ( loc ) {
X			SetEnterItem( dp , loc - gRespStr + 1 ) ;
X			return 0; /* Dialog Manager will then put this key into the text field. */
X		}
X	}
X	}
X
X	while ( * re ) {
X
X		if ( * re == ch ) {
X
X			* itemHit = ( re - gRespStr ) + 1 ;
X			FlashButton ( dp , * itemHit ) ;
X			return 1 ;
X		}
X		re ++ ;
X	}
X
X	nhbell ( ) ;
X	ev -> what = nullEvent ;
X	return 0 ;
X}
X
X
Xstatic char
Xdo_question_dialog ( char * query , int dlog , int defbut , char * resp )
X{
X	Str255 p ;
X	DialogPtr dp ;
X	short item ;
X
X	char c = queued_resp ( resp ) ;
X	if ( c )
X		return c ;
X
X	dlogID = dlog ;
X	strcpy ( p , query ) ;
X	ParamText ( CtoPstr ( p ) , NULL , NULL , NULL ) ;
X	dp = mv_get_new_dialog ( dlog ) ;
X	if ( ! dp ) {
X
X		return 0 ;
X	}
X	SetPort ( dp ) ;
X	ShowWindow ( dp ) ;
X
X	gEscItem = strlen ( resp ) ;
X	gEnterItem = defbut ;
X	gRespStr = resp ;
X
X	SetFrameItem ( dp , yn_user_item [ dlogID - YN_DLOG ] , gEnterItem ) ;
X
X	InitCursor ( ) ;
X	mv_modal_dialog ( YNAQFilter , & item ) ;
X	mv_close_dialog ( dp ) ;
X	return resp [ item - 1 ] ;
X}
X
X
Xpascal Boolean
XOneCharDLOGFilter ( DialogPtr dp , EventRecord * ev , short * item )
X{
X	char ch ;
X	short k ;
X	Handle h ;
X	Rect r ;
X	unsigned char com [ 2 ] ;
X
X	if ( ev -> what != keyDown ) {
X
X		return 0 ;
X	}
X	ch = ev -> message & 0xff ;
X
X	com [ 0 ] = 1 ;
X	com [ 1 ] = ch ;
X
X	if ( ch == 27 ) {
X
X		GetDItem ( dp , 4 , & k , & h , & r ) ;
X		SetIText ( h , com ) ;
X		* item = 2 ;
X		FlashButton ( dp , 2 ) ;
X		return 1 ;
X	}
X	if ( ! gRespStr || strchr ( gRespStr , ch ) ) {
X
X		GetDItem ( dp , 4 , & k , & h , & r ) ;
X		SetIText ( h , com ) ;
X		* item = 1 ;
X		FlashButton ( dp , 1 ) ;
X		return 1 ;
X	}
X	if ( ch == 10 || ch == 13 || ch == 3 || ch == 32 ) {
X
X		com [ 1 ] = gDef ;
X		GetDItem ( dp , 4 , & k , & h , & r ) ;
X		SetIText ( h , com ) ;
X		* item = 1 ;
X		FlashButton ( dp , 1 ) ;
X		return 1 ;
X	}
X	if ( ch > 32 && ch < 127 ) {
X
X		GetDItem ( dp , 4 , & k , & h , & r ) ;
X		SetIText ( h , com ) ;
X		* item = 1 ;
X		FlashButton ( dp , 1 ) ;
X		return 1 ;
X	}
X	nhbell ( ) ;
X	ev -> what = nullEvent ;
X	return 1 ;
X}
X
X
Xstatic char
Xgeneric_yn_function ( query , resp , def )
Xconst char * query , * resp ;
Xchar def ;
X{
X	DialogPtr dp ;
X	short k , item ;
X	Handle h ;
X	Rect r ;
X	unsigned char com [ 32 ] = { 1 , 27 } ; // margin for getitext
X	Str255 pQuery ;
X
X	char c = queued_resp ( resp ) ;
X	if ( c )
X		return c ;
X
X	dp = mv_get_new_dialog ( 137 ) ;
X	if ( ! dp ) {
X
X		return 0 ;
X	}
X	SetPort ( dp ) ;
X	ShowWindow ( dp ) ;
X	InitCursor ( ) ;
X	SetFrameItem ( dp , 6 , 1 ) ;
X	if ( def ) {
X
X		com [ 1 ] = def ;
X	}
X	strcpy ( ( char * ) pQuery , query ) ;
X	if ( resp && * resp ) {
X
X		strcat ( ( char * ) pQuery , " (" ) ;
X		strcat ( ( char * ) pQuery , resp ) ;
X		strcat ( ( char * ) pQuery , ")" ) ;
X	}
X	ParamText ( CtoPstr ( pQuery ) , NULL , NULL , NULL ) ;
X	GetDItem ( dp , 4 , & k , & h , & r ) ;
X	SetIText ( h , com ) ;
X	SelIText ( dp , 4 , 0 , 0x7fff ) ;
X	InitCursor ( ) ;
X	SetFrameItem ( dp , 6 , 1 ) ;
X	gRespStr = resp ;
X	gDef = def ;
X	do {
X
X		mv_modal_dialog ( OneCharDLOGFilter , & item ) ;
X
X	} while ( item != 1 && item != 2 ) ;
X	GetIText ( h , com ) ;
X
X	mv_close_dialog ( dp ) ;
X	if ( item == 2 || ! com [ 0 ] ) {
X
X		return 27 ; // escape
X	}
X	return com [ 1 ] ;
X}
X
X
Xstatic char
Xynaq_dialog ( query , resp , def )
Xconst char * query , * resp ;
Xchar def ;
X{
X	int dia = 0 ;
X
X	if ( resp ) {
X
X		if ( ! strcmp ( resp , ynchars ) ) {
X
X			dia = YN_DLOG ;
X		}
X		if ( ! strcmp ( resp , ynqchars ) ) {
X
X			dia = YNQ_DLOG ;
X		}
X		if ( ! strcmp ( resp , ynaqchars ) ) {
X
X			dia = YNAQ_DLOG ;
X		}
X		if ( ! strcmp ( resp , ynNaqchars ) ) {
X
X			dia = YNNAQ_DLOG ;
X		}
X	}
X	if ( ! dia ) {
X
X		return generic_yn_function ( query , resp , def ) ;
X	}
X
X	return do_question_dialog ( query , dia ,
X		( strchr ( resp , def ) - resp ) + 1 , resp ) ;
X}
X
X
Xchar
Xtopl_yn_function(query,resp, def)
Xconst char *query,*resp;
Xchar def;
X{
X	char buf[30];
X	char c = queued_resp(resp);
X	if (!c) {
X		enter_topl_mode(query);
X		topl_set_resp(resp, def);
X
X		do {
X			c = nhgetch();
X			if (c && resp && !strchr(resp, c)) {
X				nhbell();
X				c = '\0';
X			}
X		} while (!c);
X
X		topl_set_resp("", '\0');
X		leave_topl_mode(&buf);
X		if (c == '#')
X			yn_number = atoi(buf);
X	}
X	return c;
X}
X
X
Xchar
Xpopup_yn_function(query,resp, def)
Xconst char *query,*resp;
Xchar def;
X{
X	char ch [ 2 ] ;
X
X	if ( ch [ 0 ] = ynaq_dialog ( query , resp , def ) ) {
X
X		return ch [ 0 ] ;
X	}
X
X	return topl_yn_function(query, resp, def);
X}
X
X
Xchar
Xmac_yn_function(query,resp, def)
Xconst char *query,*resp;
Xchar def;
X/*
X *   Generic yes/no function. 'def' is the default (returned by space or
X *   return; 'esc' returns 'q', or 'n', or the default, depending on
X *   what's in the string. The 'query' string is printed before the user
X *   is asked about the string.
X *   If resp is NULL, any single character is accepted and returned.
X */
X{
X	if (flags.popup_dialog)
X		return popup_yn_function(query, resp, def);
X	else
X		return topl_yn_function(query, resp, def);
X}
X
X/*topl.c*/
END_OF_FILE
if test 8925 -ne `wc -c <'sys/mac/mactopl.c'`; then
    echo shar: \"'sys/mac/mactopl.c'\" unpacked with wrong size!
fi
# end of 'sys/mac/mactopl.c'
fi
if test -f 'sys/share/pcsys.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/share/pcsys.c'\"
else
echo shar: Extracting \"'sys/share/pcsys.c'\" \(8230 characters\)
sed "s/^X//" >'sys/share/pcsys.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)pcsys.c	3.1	93/01/01
X/* NetHack may be freely redistributed.  See license for details. */
X
X/*
X *  System related functions for MSDOS, OS/2 and TOS
X */
X
X#define NEED_VARARGS
X#include "hack.h"
X#include "wintty.h"
X
X#include <ctype.h>
X#include <fcntl.h>
X#ifndef __GO32__
X#include <process.h>
X#else
X#define P_WAIT          0
X#define P_NOWAIT        1
X#endif
X#ifdef TOS
X#include <osbind.h>
X#endif
X
Xstatic boolean NDECL(record_exists);
X#ifndef TOS
Xstatic boolean NDECL(comspec_exists);
X#endif
X
X# ifdef MICRO
X
Xvoid
Xflushout()
X{
X	(void) fflush(stdout);
X	return;
X}
X
Xstatic const char *COMSPEC = 
X#  ifdef TOS
X"SHELL";
X#  else
X"COMSPEC";
X#  endif
X
X#define getcomspec() getenv(COMSPEC)
X
X#  ifdef SHELL
Xint
Xdosh()
X{
X	extern char orgdir[];
X	char *comspec;
X
X	if (comspec = getcomspec()) {
X#   ifndef TOS	/* TOS has a variety of shells */
X		suspend_nhwindows("To return to NetHack, enter \"exit\" at the system prompt.\n");
X#   else
X		suspend_nhwindows((char *)0);
X#   endif /* TOS */
X		chdirx(orgdir, 0);
X		if (spawnl(P_WAIT, comspec, comspec, NULL) < 0) {
X			raw_printf("Can't spawn \"%s\"!", comspec);
X			getreturn("to continue");
X		}
X#   ifdef TOS
X/* Some shells (e.g. Gulam) turn the cursor off when they exit */
X		if (flags.BIOS)
X			(void)Cursconf(1, -1);
X#   endif
X		get_scr_size(); /* maybe the screen mode changed (TH) */
X		resume_nhwindows();
X		chdirx(hackdir, 0);
X	} else
X		pline("Can't find %s.",COMSPEC);
X	return 0;
X}
X#  endif /* SHELL */
X
X#  ifdef MFLOPPY
X
Xvoid
Xeraseall(path, files)
Xconst char *path, *files;
X{
X	char buf[PATHLEN];
X	char *foundfile;
X
X	foundfile = foundfile_buffer(); 
X        Sprintf(buf, "%s%s", path, files);
X	if (findfirst(buf))
X	    do {
X               Sprintf(buf, "%s%s", path, foundfile); 
X		(void) unlink(buf);
X	    } while (findnext());
X	return;
X}
X
X/*
X * Rewritten for version 3.3 to be faster
X */
Xvoid
Xcopybones(mode)
Xint mode;
X{
X	char from[PATHLEN], to[PATHLEN], last[13];
X	char *frompath, *topath;
X	char *foundfile;
X#  ifndef TOS
X	int status;
X	char copy[8], *comspec;
X	extern saveprompt;
X#  endif
X
X	if (!ramdisk)
X		return;
X
X	/* Find the name of the last file to be transferred
X	 */
X	frompath = (mode != TOPERM) ? permbones : levels;
X	foundfile = foundfile_buffer();
X	last[0] = '\0';
X	Sprintf(from, "%s%s", frompath, allbones);
X	topath = (mode == TOPERM) ? permbones : levels;
X#  ifdef TOS
X	eraseall(topath, allbones);
X#  endif
X	if (findfirst(from))
X		do {
X#  ifdef TOS
X			Sprintf(from, "%s%s", frompath, foundfile); 
X			Sprintf(to, "%s%s", topath, foundfile);
X			if (_copyfile(from, to))
X				goto error_copying;
X#  endif
X			Strcpy(last, foundfile);
X		} while (findnext());
X#  ifdef TOS
X	else
X		return;
X#  else
X	if (last[0]) {
X		Sprintf(copy, "%cC copy",switchar());
X
X		/* Remove any bones files in `to' directory.
X		 */
X		eraseall(topath, allbones);
X
X		/* Copy `from' to `to' */
X		Sprintf(to, "%s%s", topath, allbones);
X		comspec = getcomspec();
X		status =spawnl(P_WAIT, comspec, comspec, copy, from,
X			to, "> nul", NULL);
X	} else
X		return;
X#  endif /* TOS */
X
X	/* See if the last file got there.  If so, remove the ramdisk bones
X	 * files.
X	 */
X	Sprintf(to, "%s%s", topath, last);
X	if (findfirst(to)) {
X		if (mode == TOPERM)
X			eraseall(frompath, allbones);
X		return;
X	}
X
X#  ifdef TOS
Xerror_copying:
X#  endif
X	/* Last file didn't get there.
X	 */
X	Sprintf(to, "%s%s", topath, allbones);
X	msmsg("Can't copy \"%s\" to \"%s\" -- ", from, to);
X#  ifndef TOS
X	if (status < 0)
X	    msmsg("can't spawn \"%s\"!", comspec);
X	else
X#  endif
X	    msmsg((freediskspace(topath) < filesize(from)) ?
X            "insufficient disk space." : "bad path(s)?");
X	if (mode == TOPERM) {
X		msmsg("Bones will be left in \"%s\"\n",
X			*levels ? levels : hackdir);
X	} else {
X		/* Remove all bones files on the RAMdisk */
X		eraseall(levels, allbones);
X		playwoRAMdisk();
X	}
X	return;
X}
X
Xvoid
XplaywoRAMdisk()
X{
X	int c;
X
X	msmsg("Do you wish to play without a RAMdisk? [yn] (n)");
X
X	/* Set ramdisk false *before* exit-ing (because msexit calls
X	 * copybones)
X	 */
X	ramdisk = FALSE;
X	c = tgetch(); if (c == 'Y') c = 'y';
X	if (c != 'y') {
X		settty("Be seeing you...\n");
X		exit(0);
X	}
X	set_lock_and_bones();
X	return;
X}
X
Xint
XsaveDiskPrompt(start)
Xint start;
X{
X	extern saveprompt;
X	char buf[BUFSIZ], *bp;
X	char qbuf[QBUFSZ];
X
X	int fd;
X
X	if (saveprompt) {
X		/* Don't prompt if you can find the save file */
X		if ((fd = open_savefile()) >= 0) {
X			(void) close(fd);
X			return 1;
X		}
X		clear_nhwindow(WIN_MESSAGE);
X		pline("If save file is on a save disk, insert that disk now.");
X		mark_synch();
X		Sprintf(qbuf,"File name (default \"%s\"%s) ?", SAVEF,
X			start ? "" : ", <Esc> cancels save");
X		getlin(qbuf, buf);
X		clear_nhwindow(WIN_MESSAGE);
X		if (!start && *buf == '\033')
X			return 0;
X
X		/* Strip any whitespace. Also, if nothing was entered except
X		 * whitespace, do not change the value of SAVEF.
X		 */
X		for (bp = buf; *bp; bp++)
X			if (!isspace(*bp)) {
X				strncpy(SAVEF, bp, PATHLEN);
X				break;
X			}
X	}
X	return 1;
X}
X
X#endif /* MFLOPPY */
X
X/* Return 1 if the record file was found */
Xstatic boolean
Xrecord_exists()
X{
X	FILE *fp;
X
X	fp = fopen_datafile(RECORD, "r");
X	if (fp) {
X		fclose(fp);
X		return TRUE;
X	}
X	return FALSE;
X}
X
X#  ifdef TOS
X#define comspec_exists() 1
X#  else
X/* Return 1 if the comspec was found */
Xstatic boolean
Xcomspec_exists()
X{
X	int fd;
X	char *comspec;
X
X	if (comspec = getcomspec())
X		if ((fd = open(comspec, O_RDONLY)) >= 0) {
X			(void) close(fd);
X			return TRUE;
X		}
X	return FALSE;
X}
X# endif
X
X#ifdef MFLOPPY
X/* Prompt for game disk, then check for record file.
X */
Xvoid
XgameDiskPrompt()
X{
X	extern int saveprompt;
X
X	if (saveprompt) {
X		if (record_exists() && comspec_exists())
X			return;
X		(void) putchar('\n');
X		getreturn("when the game disk has been inserted");
X	}
X	if (comspec_exists() && record_exists())
X		return;
X
X	if (!comspec_exists())
X		msmsg("\n\nWARNING: can't find command processor \"%s\"!\n", getcomspec());
X        if (!record_exists())
X		msmsg("\n\nWARNING: can't find record file \"%s\"!\n", RECORD);
X	msmsg("If the game disk is not in, insert it now.\n");
X	getreturn("to continue");
X	return;
X}
X# endif
X# endif /* MFLOPPY */
X
X/*
X * Add a backslash to any name not ending in /, \ or :   There must
X * be room for the \
X */
Xvoid
Xappend_slash(name)
Xchar *name;
X{
X	char *ptr;
X
X	if (!*name)
X		return;
X	ptr = name + (strlen(name) - 1);
X	if (*ptr != '\\' && *ptr != '/' && *ptr != ':') {
X		*++ptr = '\\';
X		*++ptr = '\0';
X	}
X	return;
X}
X
Xvoid
Xgetreturn(str)
Xconst char *str;
X{
X# ifdef TOS
X	msmsg("Hit <Return> %s.", str);
X# else
X	msmsg("Hit <Enter> %s.", str);
X# endif
X	while (Getchar() != '\n') ;
X	return;
X}
X
Xvoid
Xmsmsg VA_DECL(const char *, fmt)
X	VA_START(fmt);
X	VA_INIT(fmt, const char *);
X	Vprintf(fmt, VA_ARGS);
X	flushout();
X	VA_END();
X	return;
X}
X
X/*
X * Follow the PATH, trying to fopen the file.
X */
X#  ifdef TOS
X#   ifdef __MINT__
X#define PATHSEP ':'
X#   else
X#define PATHSEP	','
X#   endif
X#  else
X#define PATHSEP	';'
X#  endif
X
XFILE *
Xfopenp(name, mode)
Xconst char *name, *mode;
X{
X	char buf[BUFSIZ], *bp, *pp, lastch = 0;
X	FILE *fp;
X
X	/* Try the default directory first.  Then look along PATH.
X	 */
X	Strcpy(buf, name);
X	if (fp = fopen(buf, mode))
X		return fp;
X	else {
X		pp = getenv("PATH");
X		while (pp && *pp) {
X			bp = buf;
X			while (*pp && *pp != PATHSEP)
X				lastch = *bp++ = *pp++;
X			if (lastch != '\\' && lastch != '/')
X				*bp++ = '\\';
X			Strcpy(bp, name);
X			if (fp = fopen(buf, mode))
X				return fp;
X			if (*pp)
X				pp++;
X		}
X	}
X#  ifdef OS2_CODEVIEW /* one more try for hackdir */
X	Strcpy(buf,hackdir);
X	append_slash(buf);
X	Strcat(buf,name);
X	if(fp = fopen(buf,mode))
X		return fp;
X#  endif
X	return (FILE *)0;
X}
X
X/* Chdir back to original directory
X */
X#undef exit
X# ifdef TOS
Xextern boolean run_from_desktop;	/* set in pcmain.c */
X# endif
X
Xvoid exit(int);
X
Xvoid
Xmsexit(code)
Xint code;
X{
X# ifdef CHDIR
X	extern char orgdir[];
X# endif
X
X	flushout();
X# ifndef TOS
X	enable_ctrlP();		/* in case this wasn't done */
X# endif
X# ifdef MFLOPPY
X	if (ramdisk) copybones(TOPERM);
X# endif
X# ifdef CHDIR
X	chdir(orgdir);		/* chdir, not chdirx */
X	chdrive(orgdir);
X# endif
X# ifdef TOS
X	if (run_from_desktop)
X	    getreturn("to continue"); /* so the user can read the score list */
X#  ifdef TEXTCOLOR
X	if (colors_changed)
X		restore_colors();
X#  endif
X# endif
X	exit(code);
X	return;
X}
END_OF_FILE
if test 8230 -ne `wc -c <'sys/share/pcsys.c'`; then
    echo shar: \"'sys/share/pcsys.c'\" unpacked with wrong size!
fi
# end of 'sys/share/pcsys.c'
fi
echo shar: End of archive 95 \(of 108\).
cp /dev/null ark95isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \
21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \
41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 \
61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 \
81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 \
101 102 103 104 105 106 107 108 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 108 archives.
    echo "Now execute 'rebuild.sh'"
    rm -f ark10[0-8]isdone ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
