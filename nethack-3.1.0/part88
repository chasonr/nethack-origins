Path: uunet!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v16i096:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Part88/108
Message-ID: <4459@master.CNA.TEK.COM>
Date: 5 Feb 93 19:22:12 GMT
Sender: news@master.CNA.TEK.COM
Lines: 2010
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1647

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 16, Issue 96
Archive-name: nethack31/Part88
Supersedes: nethack3p9: Volume 10, Issue 46-102
Environment: Amiga, Atari, Mac, MS-DOS, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 88 (of 108)."
# Contents:  dat/Caveman.des src/weapon.c sys/amiga/splitter/splitter.c
#   sys/share/random.c
# Wrapped by billr@saab on Wed Jan 27 16:09:22 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'dat/Caveman.des' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dat/Caveman.des'\"
else
echo shar: Extracting \"'dat/Caveman.des'\" \(11855 characters\)
sed "s/^X//" >'dat/Caveman.des' <<'END_OF_FILE'
X#	SCCS Id: @(#)Caveman.des	3.1	91/12/24
X#	Copyright (c) 1989 by Jean-Christophe Collet
X#	Copyright (c) 1991 by M. Stephenson
X# NetHack may be freely redistributed.  See license for details.
X#
X#	The "start" level for the quest.
X#
X#	Here you meet your (besieged) class leader, Shaman Karnov
X#	and receive your quest assignment.
X#
XMAZE: "C-start",' '
XFLAGS: noteleport,hardfloor
XGEOMETRY:center,center
XMAP
X                                                                            
X  ......     ..........................       ...        ....  ......       
X ......       ..........................     ........       ....    .....   
X  ..BB      .............................    .........            ....  ..  
X     ..    ......................              .......      ..     ....  .. 
X     ..     ....................                     ..  .......    ..  ... 
X   ..              S   BB                .....     .......   ....      .... 
X    ..        ...  .   ..               ........  ..     ..   ..       ...  
X     ..      ......     ..             ............       ..          ...   
X       .      ....       ..             ........           ..  ...........  
X  ...   ..     ..        .............                  ................... 
X .....   .....            ...............................      ...........  
X  .....B................            ...                               ...   
X  .....     .  ..........        .... .      ...  ..........           ...  
X   ...     ..          .............  ..    ...................        .... 
X          BB       ..   .........      BB    ...  ..........  ..   ...  ... 
X       ......    .....  B          ........         ..         .. ....  ... 
X     ..........  ..........         ..... ...      .....        ........    
X       ..  ...    .  .....         ....    ..       ...            ..       
X                                                                            
XENDMAP
X# Random Monsters
XRANDOM_MONSTERS: 'h', 'H'
X# Dungeon Description
XREGION:(00,00,75,19),unlit,"ordinary"
XREGION:(13,01,40,05),lit,"temple",unfilled,true
X# The occupied rooms.
XREGION:(02,01,08,03),lit,"ordinary",unfilled,true
XREGION:(01,11,06,14),lit,"ordinary",unfilled,true
XREGION:(13,08,18,10),lit,"ordinary",unfilled,true
XREGION:(05,17,14,18),lit,"ordinary",unfilled,true
XREGION:(17,16,23,18),lit,"ordinary",unfilled,true
XREGION:(35,16,44,18),lit,"ordinary",unfilled,true
X# Stairs
XSTAIR:(02,03),down
X# Portal arrival point
XBRANCH:(71,09,71,09),(0,0,0,0)
X# Doors
XDOOR:locked,(19,06)
X# The temple altar (this will force a priest(ess) to be created)
XALTAR:(36,02),law,shrine
X# Shaman Karnov
XMONSTER:'@',"Shaman Karnov",(35,02)
X# The treasure of Shaman Karnov
XOBJECT:'(',"chest",(34,02)
X# neanderthal guards for the audience chamber
XMONSTER:'@',"neanderthal",(20,03)
XMONSTER:'@',"neanderthal",(20,02)
XMONSTER:'@',"neanderthal",(20,01)
XMONSTER:'@',"neanderthal",(21,03)
XMONSTER:'@',"neanderthal",(21,02)
XMONSTER:'@',"neanderthal",(21,01)
XMONSTER:'@',"neanderthal",(22,01)
XMONSTER:'@',"neanderthal",(26,09)
X# Non diggable walls
XNON_DIGGABLE:(00,00,75,19)
X# Random traps
XTRAP:"pit",(47,11)
XTRAP:"pit",(57,10)
XTRAP:random,random
XTRAP:random,random
XTRAP:random,random
XTRAP:random,random
X# Monsters on siege duty (in the outer caves).
XMONSTER: 'h',"bugbear",(47,02),hostile
XMONSTER: 'h',"bugbear",(48,03),hostile
XMONSTER: 'h',"bugbear",(49,04),hostile
XMONSTER: 'h',"bugbear",(67,03),hostile
XMONSTER: 'h',"bugbear",(69,04),hostile
XMONSTER: 'h',"bugbear",(51,13),hostile
XMONSTER: 'h',"bugbear",(53,14),hostile
XMONSTER: 'h',"bugbear",(55,15),hostile
XMONSTER: 'h',"bugbear",(63,10),hostile
XMONSTER: 'h',"bugbear",(65,09),hostile
XMONSTER: 'h',"bugbear",(67,10),hostile
XMONSTER: 'h',"bugbear",(69,11),hostile
XWALLIFY
X 
X#
X#	The "locate" level for the quest.
X#
X#	Here you have to find the lair of Tiamat to go
X#	further towards your assigned quest.
X#
X
XMAZE: "C-locate",' '
XFLAGS: hardfloor
XGEOMETRY:center,center
XMAP
X                                                                            
X    .............                     ...........                           
X   ...............                   .............                          
X    .............                  ...............        ..........        
X     ...........                    .............      ...............      
X        ...                                    ...   ..................     
X         ...                ..........          ... ..................      
X          ...              ............          BBB...................     
X           ...              ..........          ......................      
X            .....                 ..      .....B........................    
X  ....       ...............      .    ........B..........................  
X ......     .. .............S..............         ..................      
X  ....     ..                ...........             ...............        
X     ..  ...                                    ....................        
X      ....                                      BB...................       
X         ..                 ..                 ..  ...............          
X          ..   .......     ....  .....  ....  ..     .......   S            
X           ............     ....... ..  .......       .....    ...  ....    
X               .......       .....   ......                      .......    
X                                                                            
XENDMAP
X# Random Monsters
XRANDOM_MONSTERS: 'h', 'H'
X# Dungeon Description
XREGION:(00,00,75,19),unlit,"ordinary"
XREGION:(52,06,73,15),lit,"ordinary",unfilled,true
X# Doors
XDOOR:locked,(28,11)
X# Stairs
XSTAIR:(04,03),up
XSTAIR:(73,10),down
X# Non diggable walls
XNON_DIGGABLE:(00,00,75,19)
X# Objects
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
X# Random traps
XTRAP:random,random
XTRAP:random,random
XTRAP:random,random
XTRAP:random,random
XTRAP:random,random
XTRAP:random,random
X# Random monsters.
XMONSTER:'h',"bugbear",(02,10),hostile
XMONSTER:'h',"bugbear",(03,11),hostile
XMONSTER:'h',"bugbear",(04,12),hostile
XMONSTER:'h',"bugbear",(02,11),hostile
XMONSTER:'h',"bugbear",(16,16),hostile
XMONSTER:'h',"bugbear",(17,17),hostile
XMONSTER:'h',"bugbear",(18,18),hostile
XMONSTER:'h',"bugbear",(19,16),hostile
XMONSTER:'h',"bugbear",(30,06),hostile
XMONSTER:'h',"bugbear",(31,07),hostile
XMONSTER:'h',"bugbear",(32,08),hostile
XMONSTER:'h',"bugbear",(33,06),hostile
XMONSTER:'h',"bugbear",(34,07),hostile
XMONSTER:'h',"bugbear",random,hostile
XMONSTER:'h',"bugbear",random,hostile
XMONSTER:'h',"bugbear",random,hostile
XMONSTER:'h',"bugbear",random,hostile
XMONSTER:'h',random,random,hostile
XMONSTER:'H',random,random,hostile
XMONSTER:'H',"hill giant",(03,12),hostile
XMONSTER:'H',"hill giant",(20,17),hostile
XMONSTER:'H',"hill giant",(35,08),hostile
XMONSTER:'H',"hill giant",random,hostile
XMONSTER:'H',"hill giant",random,hostile
XMONSTER:'H',"hill giant",random,hostile
XMONSTER:'H',"hill giant",random,hostile
XMONSTER:'H',random,random,hostile
XWALLIFY
X
X#
X#	The "goal" level for the quest.
X#
X#	Here you meet Tiamat your nemesis monster.  You have to
X#	defeat Tiamat in combat to gain the artifact you have
X#	been assigned to retrieve.
X#
X
XMAZE: "C-goal", ' '
XGEOMETRY:center,center
XMAP
X                                                                            
X                          .....................                             
X                         .......................                            
X                        .........................                           
X                       ...........................                          
X                      .............................                         
X                     ...............................                        
X                    .................................                       
X                   ...................................                      
X                  .....................................                     
X                 .......................................                    
X                  .....................................                     
X                   ...................................                      
X                    .................................                       
X                     ...............................                        
X                      .............................                         
X                       ...........................                          
X                        .........................                           
X                         .......................                            
X                                                                            
XENDMAP
X# Random Monsters
XRANDOM_MONSTERS: 'h', 'H'
X# Dungeon Description
XREGION:(00,00,75,19),lit,"ordinary"
X# Stairs
XSTAIR:random,up
X# Non diggable walls
XNON_DIGGABLE:(00,00,75,19)
X# Objects
XOBJECT:')',"quarterstaff",(23,10),blessed,0,"The Sceptre of Might"
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
X# monsters.
XMONSTER:'D',"Chromatic Dragon",(23,10),hostile
XWALLIFY
X
X#
X#	The "fill" levels for the quest.
X#
X#	These levels are used to fill out any levels not occupied by specific
X#	levels as defined above. "filla" is the upper filler, between the
X#	start and locate levels, and "fillb" the lower between the locate
X#	and goal levels.
X#
X
XMAZE: "C-filla" , ' '
XINIT_MAP: '.' , ' ' , true , true , random , true
XNOMAP
X# Random Monsters
XRANDOM_MONSTERS: 'h', 'H'
X#
XSTAIR: random, up
XSTAIR: random, down
X#
XOBJECT: random, random, random
XOBJECT: random, random, random
XOBJECT: random, random, random
XOBJECT: random, random, random
XOBJECT: random, random, random
XOBJECT: random, random, random
XOBJECT: random, random, random
X#
XTRAP: random, random
XTRAP: random, random
XTRAP: random, random
XTRAP: random, random
X#
XMONSTER: 'h', "bugbear", random, hostile
XMONSTER: 'h', "bugbear", random, hostile
XMONSTER: 'h', "bugbear", random, hostile
XMONSTER: 'h', "bugbear", random, hostile
XMONSTER: 'h', "bugbear", random, hostile
XMONSTER: 'h', random, random, hostile
XMONSTER: 'H', "hill giant", random, hostile
X
XMAZE: "C-fillb" , ' '
XINIT_MAP: '.' , ' ' , true , true , random , true
XNOMAP
X# Random Monsters
XRANDOM_MONSTERS: 'h', 'H'
X#
XSTAIR: random, up
XSTAIR: random, down
X#
XOBJECT: random, random, random
XOBJECT: random, random, random
XOBJECT: random, random, random
XOBJECT: random, random, random
XOBJECT: random, random, random
XOBJECT: random, random, random
XOBJECT: random, random, random
XOBJECT: random, random, random
XOBJECT: random, random, random
XOBJECT: random, random, random
XOBJECT: random, random, random
XOBJECT: random, random, random
X#
XTRAP: random, random
XTRAP: random, random
XTRAP: random, random
XTRAP: random, random
X#
XMONSTER: 'h', "bugbear", random, hostile
XMONSTER: 'h', "bugbear", random, hostile
XMONSTER: 'h', "bugbear", random, hostile
XMONSTER: 'h', "bugbear", random, hostile
XMONSTER: 'h', random, random, hostile
XMONSTER: 'h', random, random, hostile
XMONSTER: 'H', "hill giant", random, hostile
XMONSTER: 'H', "hill giant", random, hostile
END_OF_FILE
if test 11855 -ne `wc -c <'dat/Caveman.des'`; then
    echo shar: \"'dat/Caveman.des'\" unpacked with wrong size!
fi
# end of 'dat/Caveman.des'
fi
if test -f 'src/weapon.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/weapon.c'\"
else
echo shar: Extracting \"'src/weapon.c'\" \(14162 characters\)
sed "s/^X//" >'src/weapon.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)weapon.c	3.1	93/01/15	*/
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X/*
X *	This module contains code for calculation of "to hit" and damage
X *	bonuses for any given weapon used, as well as weapons selection
X *	code for monsters.
X */
X#include	"hack.h"
X
X#ifdef OVLB
X
Xstatic const char NEARDATA kebabable[] = { S_XORN, S_DRAGON, S_NAGA, S_GIANT, 0 };
X
X/*
X *	hitval returns an integer representing the "to hit" bonuses
X *	of "otmp" against the monster type "ptr".
X */
Xint
Xhitval(otmp, ptr)
Xstruct	obj *otmp;
Xstruct	permonst *ptr;
X{
X	int	tmp = 0;
X
X	if (otmp->oclass == WEAPON_CLASS ||
X	    otmp->otyp == PICK_AXE || otmp->otyp == UNICORN_HORN)
X		tmp += otmp->spe;
X
X/*	Put weapon specific "to hit" bonuses in below:		*/
X	tmp += objects[otmp->otyp].oc_hitbon;
X
X/*	Put weapon vs. monster type "to hit" bonuses in below:	*/
X
X	/* Blessed weapons used against undead or demons */
X	if(otmp->oclass == WEAPON_CLASS && otmp->blessed &&
X	   (is_demon(ptr) || is_undead(ptr))) tmp += 2;
X
X	if(otmp->otyp >= SPEAR && otmp->otyp <= JAVELIN &&
X	   index(kebabable, ptr->mlet)) tmp += 2;
X
X	/* Check specially named weapon "to hit" bonuses */
X	if (otmp->oartifact) tmp += spec_abon(otmp, ptr);
X	return tmp;
X}
X
X/*
X *	dmgval returns an integer representing the damage bonuses
X *	of "otmp" against the monster type "ptr".
X */
Xint
Xdmgval(otmp, ptr)
Xstruct	obj *otmp;
Xstruct	permonst *ptr;
X{
X	int	tmp = 0;
X
X	if(otmp->otyp == CREAM_PIE)	return(0);
X
X	if(ptr->msize >= MZ_HUMAN) {
X	    if(objects[otmp->otyp].oc_wldam)
X		tmp = rnd(objects[otmp->otyp].oc_wldam);
X	    switch (otmp->otyp) {
X		case CROSSBOW_BOLT:
X		case MORNING_STAR:
X		case PARTISAN:
X		case ELVEN_BROADSWORD:
X		case BROADSWORD:	tmp++; break;
X
X		case FLAIL:
X		case RANSEUR:
X		case VOULGE:		tmp += rnd(4); break;
X
X		case ACID_VENOM:
X		case HALBERD:
X		case SPETUM:		tmp += rnd(6); break;
X
X		case BATTLE_AXE:
X		case BARDICHE:
X		case TRIDENT:		tmp += d(2,4); break;
X
X		case TSURUGI:
X		case DWARVISH_MATTOCK:
X		case TWO_HANDED_SWORD:	tmp += d(2,6); break;
X	    }
X	} else {
X	    if(objects[otmp->otyp].oc_wsdam)
X		tmp = rnd(objects[otmp->otyp].oc_wsdam);
X	    switch (otmp->otyp) {
X		case CROSSBOW_BOLT:
X		case MACE:
X		case WAR_HAMMER:
X		case FLAIL:
X		case SPETUM:
X		case TRIDENT:		tmp++; break;
X
X		case BATTLE_AXE:
X		case BARDICHE:
X		case BILL_GUISARME:
X		case GUISARME:
X		case LUCERN_HAMMER:
X		case MORNING_STAR:
X		case RANSEUR:
X		case BROADSWORD:
X		case ELVEN_BROADSWORD:
X		case VOULGE:		tmp += rnd(4); break;
X
X		case ACID_VENOM:	tmp += rnd(6); break;
X	    }
X	}
X	if (otmp->oclass == WEAPON_CLASS || otmp->otyp == PICK_AXE
X						|| otmp->otyp == UNICORN_HORN)
X		tmp += otmp->spe;
X
X	tmp -= otmp->oeroded;
X
X	if (objects[otmp->otyp].oc_material <= LEATHER && thick_skinned(ptr))
X		/* thick skinned/scaled creatures don't feel it */
X		tmp = 0;
X	if (ptr == &mons[PM_SHADE] && objects[otmp->otyp].oc_material != SILVER)
X		tmp = 0;
X
X/*	Put weapon vs. monster type damage bonuses in below:	*/
X	if(otmp->oclass == WEAPON_CLASS) {
X	    if (otmp->blessed && (is_undead(ptr) || is_demon(ptr)))
X		tmp += rnd(4);
X	    if ((otmp->otyp == AXE || otmp->otyp == BATTLE_AXE)
X		&& is_wooden(ptr))
X		tmp += rnd(4);
X	    if (objects[otmp->otyp].oc_material == SILVER && hates_silver(ptr))
X		tmp += rnd(20);
X	}
X
X	return(tmp);
X}
X
Xvoid
Xset_uasmon()		/* update the "uasmon" structure */
X{
X#ifdef POLYSELF
X	if(u.umonnum >= 0) uasmon = &mons[u.umonnum];
X	else {
X#endif
X
X		uasmon = &playermon;
X		playermon.mlevel = u.ulevel;
X		playermon.ac = u.uac;
X		playermon.mr = (u.ulevel > 8) ? 5 * (u.ulevel-7) : u.ulevel;
X#ifdef POLYSELF
X	}
X#endif
X	return;
X}
X
X#endif /* OVLB */
X#ifdef OVL0
X
X#define	Oselect(x)	if((otmp = oselect(mtmp, x))) return(otmp);
X
Xstatic struct obj * FDECL(oselect, (struct monst *,int));
X
Xstatic struct obj *
Xoselect(mtmp, x)
Xstruct monst *mtmp;
Xint x;
X{
X	struct obj *otmp;
X
X	for(otmp=mtmp->minvent; otmp; otmp = otmp->nobj) {
X		if (otmp->otyp == x && touch_artifact(otmp,mtmp))
X			return otmp;
X	}
X	return (struct obj *)0;
X}
X
Xstatic const int NEARDATA rwep[] =
X	{ DWARVISH_SPEAR, ELVEN_SPEAR, SPEAR, ORCISH_SPEAR, JAVELIN,
X	  SHURIKEN, SILVER_ARROW, ELVEN_ARROW, ARROW, ORCISH_ARROW,
X	  CROSSBOW_BOLT, ELVEN_DAGGER, DAGGER, ORCISH_DAGGER, KNIFE, ROCK,
X	  LOADSTONE, LUCKSTONE, DART, /* BOOMERANG, */ CREAM_PIE
X	  /* note: CREAM_PIE should NOT be #ifdef KOPS */
X	  };
X
Xstatic struct obj *propellor;
X
Xstruct obj *
Xselect_rwep(mtmp)	/* select a ranged weapon for the monster */
Xregister struct monst *mtmp;
X{
X	register struct obj *otmp;
X	int i;
X
X#ifdef KOPS
X	char mlet = mtmp->data->mlet;
X#endif
X
X	propellor = &zeroobj;
X#ifdef KOPS
X	if(mlet == S_KOP)	/* pies are first choice for Kops */
X	    Oselect(CREAM_PIE);
X#endif
X	if(throws_rocks(mtmp->data))	/* ...boulders for giants */
X	    Oselect(BOULDER);
X	/*
X	 * other than these two specific cases, always select the
X	 * most potent ranged weapon to hand.
X	 */
X	for (i = 0; i < SIZE(rwep); i++) {
X	    int prop;
X
X	    propellor = &zeroobj;
X	    /* shooting gems from slings; this goes just before the darts */
X	    if (rwep[i]==DART && !likes_gems(mtmp->data)
X			&& (propellor = m_carrying(mtmp, SLING))) {
X		for(otmp=mtmp->minvent; otmp; otmp=otmp->nobj) {
X		    if(otmp->oclass==GEM_CLASS &&
X				(otmp->otyp != LOADSTONE || !otmp->cursed))
X			return(otmp);
X		}
X	    }
X	    prop = (objects[rwep[i]]).w_propellor;
X	    if (prop > 0) {
X		switch (prop) {
X		case WP_BOW:
X		  propellor = (oselect(mtmp, ELVEN_BOW));
X		  if (!propellor) propellor = (oselect(mtmp, BOW));
X		  if (!propellor) propellor = (oselect(mtmp, ORCISH_BOW));
X		  break;
X		case WP_SLING:
X		  propellor = (oselect(mtmp, SLING));
X		  break;
X		case WP_CROSSBOW:
X		  propellor = (oselect(mtmp, CROSSBOW));
X		}
X#ifdef MUSE
X		if ((otmp = MON_WEP(mtmp)) && otmp->cursed && otmp != propellor
X				&& mtmp->weapon_check == NO_WEAPON_WANTED)
X			propellor = 0;
X#endif
X	    }
X	    /* propellor = obj, propellor to use
X	     * propellor = &zeroobj, doesn't need a propellor
X	     * propellor = 0, needed one and didn't have one
X	     */
X	    if (propellor != 0) {
X		/* Note: cannot use m_carrying for loadstones, since it will
X		 * always select the first object of a type, and maybe the
X		 * monster is carrying two but only the first is unthrowable.
X		 */
X		if (rwep[i] != LOADSTONE) {
X#ifdef MUSE
X			/* Don't throw a cursed weapon-in-hand */
X			if ((otmp = oselect(mtmp, rwep[i]))
X			    && (!otmp->cursed || otmp != MON_WEP(mtmp)))
X				return(otmp);
X#else
X			Oselect(rwep[i]);
X#endif
X		} else for(otmp=mtmp->minvent; otmp; otmp=otmp->nobj) {
X		    if (otmp->otyp == LOADSTONE && !otmp->cursed)
X			return otmp;
X		}
X	    }
X	  }
X
X	/* failure */
X	return (struct obj *)0;
X}
X
X/* 0 = used by any monster; 1 = only used by strong monsters */
Xstatic const struct hwep { short otyp, big; } NEARDATA hwep[] = {
X	  {TSURUGI,1}, {RUNESWORD,0},
X	  {DWARVISH_MATTOCK,1}, {TWO_HANDED_SWORD,1}, {BATTLE_AXE,1},
X	  {KATANA,0}, {UNICORN_HORN,1}, {CRYSKNIFE,0},
X	  {TRIDENT,0}, {LONG_SWORD,0}, {ELVEN_BROADSWORD,0}, {BROADSWORD,0},
X	  {LUCERN_HAMMER,1}, {SCIMITAR,1}, {SILVER_SABER,0}, {HALBERD,1},
X	  {PARTISAN,1}, {LANCE,1}, {FAUCHARD,1}, {BILL_GUISARME,1},
X	  {BEC_DE_CORBIN,1}, {GUISARME,1}, {RANSEUR,1}, {SPETUM,1},
X	  {VOULGE,1}, {BARDICHE,0}, {MORNING_STAR,0}, {GLAIVE,0},
X	  {ELVEN_SHORT_SWORD,0}, {DWARVISH_SHORT_SWORD,0}, {SHORT_SWORD,0},
X	  {ORCISH_SHORT_SWORD,0}, {MACE,0}, {AXE,0}, {DWARVISH_SPEAR,0},
X	  {ELVEN_SPEAR,0}, {SPEAR,0}, {ORCISH_SPEAR,0}, {FLAIL,0},
X	  {QUARTERSTAFF,1}, {JAVELIN,0}, {AKLYS,0}, {CLUB,0}, {PICK_AXE,0},
X#ifdef KOPS
X	  {RUBBER_HOSE,0},
X#endif /* KOPS */
X	  {WAR_HAMMER,0}, {ELVEN_DAGGER,0}, {DAGGER,0}, {ORCISH_DAGGER,0},
X	  {ATHAME,0}, {SCALPEL,0}, {KNIFE,0}, {WORM_TOOTH,0}, {BULLWHIP,0}
X	};
X
Xstruct obj *
Xselect_hwep(mtmp)	/* select a hand to hand weapon for the monster */
Xregister struct monst *mtmp;
X{
X	register struct obj *otmp;
X	register int i;
X	register const struct hwep *hw;
X	boolean strong = strongmonst(mtmp->data);
X
X	if(is_giant(mtmp->data))	/* giants just love to use clubs */
X	    Oselect(CLUB);
X
X	/* only strong monsters can wield big (esp. long) weapons */
X	/* all monsters can wield the remaining weapons */
X	for (i = 0, hw = hwep; i < SIZE(hwep); i++, hw++)
X	    if ((strong || !hw->big) &&
X#ifdef MUSE
X	      (!objects[hw->otyp].oc_bimanual || !which_armor(mtmp, W_ARMS)) &&
X#endif
X	(objects[hw->otyp].oc_material != SILVER || !hates_silver(mtmp->data)))
X		Oselect(hw->otyp);
X
X	/* failure */
X	return (struct obj *)0;
X}
X
X#ifdef MUSE
X/* Called after polymorphing a monster, robbing it, etc....  Monsters
X * otherwise never unwield stuff on their own.  Shouldn't print messages.
X */
Xvoid
Xpossibly_unwield(mon)
Xregister struct monst *mon;
X{
X	register struct obj *obj;
X	struct obj *otmp, *backobj, *mw_tmp;
X
X	if (!(mw_tmp = MON_WEP(mon)))
X		return;
X	for(obj=mon->minvent; obj; obj=obj->nobj)
X		if (obj == mw_tmp) break;
X	if (!obj) { /* The weapon was stolen or destroyed */
X		MON_NOWEP(mon);
X		mon->weapon_check = NEED_WEAPON;
X		return;
X	}
X	if (!attacktype(mon->data, AT_WEAP)) {
X		MON_NOWEP(mon);
X		mon->weapon_check = NO_WEAPON_WANTED;
X		if (cansee(mon->mx, mon->my)) {
X			pline("%s drops %s.", Monnam(mon),
X				distant_name(obj, doname));
X		}
X		backobj = 0;
X		for(otmp = mon->minvent; otmp; otmp = otmp->nobj) {
X			/* flooreffects unnecessary, can't wield boulders */
X			if (otmp == obj) {
X				if (!backobj) mon->minvent = otmp->nobj;
X				else backobj->nobj = otmp->nobj;
X				place_object(otmp, mon->mx, mon->my);
X				otmp->nobj = fobj;
X				fobj = otmp;
X				stackobj(fobj);
X				if(cansee(mon->mx,mon->my))
X					newsym(mon->mx, mon->my);
X				break;
X			}
X			backobj = otmp;
X		}
X		return;
X	}
X	/* The remaining case where there is a change is where a monster
X	 * is polymorphed into a stronger/weaker monster with a different
X	 * choice of weapons.  This has no parallel for players.  It can
X	 * be handled by waiting until mon_wield_item is actually called.
X	 * Though the monster still wields the wrong weapon until then,
X	 * this is OK since the player can't see it.
X	 * Possible problem: big monster with big cursed weapon gets
X	 * polymorphed into little monster.  But it's not quite clear how to
X	 * handle this anyway....
X	 */
X	mon->weapon_check = NEED_WEAPON;
X	return;
X}
X
X/* Let a monster try to wield a weapon, based on mon->weapon_check.
X * Returns 1 if the monster took time to do it, 0 if it did not.
X */
Xint
Xmon_wield_item(mon)
Xregister struct monst *mon;
X{
X	struct obj *obj;
X
X	/* This case actually should never happen */
X	if (mon->weapon_check == NO_WEAPON_WANTED) return 0;
X
X	switch(mon->weapon_check) {
X		case NEED_HTH_WEAPON:
X			obj = select_hwep(mon);
X			break;
X		case NEED_RANGED_WEAPON:
X			(void)select_rwep(mon);
X			obj = propellor;
X			break;
X		case NEED_PICK_AXE:
X			obj = m_carrying(mon, PICK_AXE);
X			break;
X		default: impossible("weapon_check %d for %s?",
X				mon->weapon_check, mon_nam(mon));
X			return 0;
X	}
X	if (obj && obj != &zeroobj) {
X		struct obj *mw_tmp = MON_WEP(mon);
X		if (mw_tmp == obj) { /* already wielding it */
X			mon->weapon_check = NEED_WEAPON;
X			return 0;
X		}
X		/* Actually, this isn't necessary--as soon as the monster
X		 * wields the weapon, the weapon welds itself, so the monster
X		 * can know it's cursed and needn't even bother trying.
X		 * Still....
X		 */
X		if (mw_tmp && mw_tmp->cursed) {
X		    if (obj->otyp == PICK_AXE) {
X			if (canseemon(mon)) {
X			    pline("Since %s weapon %s welded to %s hand,",
X				s_suffix(mon_nam(mon)),
X				(mw_tmp->quan == 1L) ? "is" : "are",
X				humanoid(mon->data)
X					? (mon->female ? "her" : "his")
X					: "its");
X			    pline("%s cannot wield that %s.",
X				mon_nam(mon), xname(obj));
X			    mw_tmp->bknown = 1;
X			}
X		    } else {
X			if (canseemon(mon)) {
X			    pline("%s tries to wield %s.", Monnam(mon),
X				doname(obj));
X			    pline("%s %s %s welded to %s hand!",
X				s_suffix(Monnam(mon)), xname(mw_tmp),
X				(mw_tmp->quan == 1L) ? "is" : "are",
X				humanoid(mon->data)
X					? (mon->female ? "her" : "his")
X					: "its");
X			    mw_tmp->bknown = 1;
X			}
X		    }
X		    mon->weapon_check = NO_WEAPON_WANTED;
X		    return 1;
X		}
X		mon->mw = obj;		/* wield obj */
X		mon->weapon_check = NEED_WEAPON;
X		if (canseemon(mon)) {
X			pline("%s wields %s!", Monnam(mon), doname(obj));
X			if (obj->cursed) {
X				pline("%s %s to %s hand!",
X					The(xname(obj)),
X					(obj->quan == 1L) ? "welds itself"
X					    : "weld themselves",
X					s_suffix(mon_nam(mon)));
X				obj->bknown = 1;
X			}
X		}
X		return 1;
X	}
X	mon->weapon_check = NEED_WEAPON;
X	return 0;
X}
X
X/* rearrange a monster's inventory so that wielded weapon is first */
Xvoid
Xsort_mwep(mon)
Xstruct monst *mon;
X{
X	struct obj *otmp, *prev, *mw_tmp = MON_WEP(mon);
X
X	if (!mw_tmp) return;
X	for (otmp = mon->minvent, prev = 0; otmp; otmp = otmp->nobj) {
X		if (otmp == mw_tmp)  break;
X		prev = otmp;
X	}
X	if (!otmp) {
X		MON_NOWEP(mon);
X	} else if (prev) {
X		prev->nobj = otmp->nobj;
X		otmp->nobj = mon->minvent;
X		mon->minvent = otmp;
X	}
X}
X#endif
X
Xint
Xabon() {	/* attack bonus for strength & dexterity */
X	int	sbon;
X	register int	str = ACURR(A_STR), dex = ACURR(A_DEX);
X
X#ifdef POLYSELF
X	if (u.umonnum >= 0) return(adj_lev(&mons[u.umonnum])-3);
X#endif
X	if (str < 6) sbon = -2;
X	else if (str < 8) sbon = -1;
X	else if (str < 17) sbon = 0;
X	else if (str < 69) sbon = 1;	/* up to 18/50 */
X	else if (str < 118) sbon = 2;
X	else sbon = 3;
X/*
X *	Temporary kludge - make it a bit easier for a low level character
X *			   to hit until we tune the game a little better.
X */
X	sbon += (u.ulevel < 3) ? 1 : 0;
X
X	if (dex < 4) return(sbon-3);
X	else if (dex < 6) return(sbon-2);
X	else if (dex < 8) return(sbon-1);
X	else if (dex < 14) return(sbon);
X	else return(sbon + dex-14);
X}
X
X#endif /* OVL0 */
X#ifdef OVL1
X
Xint
Xdbon() {	/* damage bonus for strength */
X	register int	str = ACURR(A_STR);
X
X#ifdef POLYSELF
X	if (u.umonnum >= 0) return(0);
X#endif
X
X	if (str < 6) return(-1);
X	else if (str < 16) return(0);
X	else if (str < 18) return(1);
X	else if (str == 18) return(2);		/* up to 18 */
X	else if (str < 94) return(3);		/* up to 18/75 */
X	else if (str < 109) return(4);		/* up to 18/90 */
X	else if (str < 118) return(5);		/* up to 18/99 */
X	else return(6);
X}
X
X#endif /* OVL1 */
X
X/*weapon.c*/
END_OF_FILE
if test 14162 -ne `wc -c <'src/weapon.c'`; then
    echo shar: \"'src/weapon.c'\" unpacked with wrong size!
fi
# end of 'src/weapon.c'
fi
if test -f 'sys/amiga/splitter/splitter.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/amiga/splitter/splitter.c'\"
else
echo shar: Extracting \"'sys/amiga/splitter/splitter.c'\" \(13609 characters\)
sed "s/^X//" >'sys/amiga/splitter/splitter.c' <<'END_OF_FILE'
X/*    SCCS Id: @(#)splitter.c		3.1   93/01/08
X/*    Copyright (c) Kenneth Lorber, Bethesda, Maryland, 1992, 1993 */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#define SOUT	/* split output files */
X#define SPLITSIZE (800 * 1024)		/* somewhat < one floppy */
X
X#include <stdio.h>
X#include <stdlib.h>
X#include <string.h>
X#include <fcntl.h>
X
X#include <proto/exec.h>
X#include <exec/types.h>
X#include <exec/nodes.h>
X#include <exec/lists.h>
X
X#include "split.h"
X#include "amiout.h"
X#include "arg.h"
X
Xint main(int,char **);
X
Xchar *code_proto="%n.c%C";
Xchar *data_proto="%n.d%D";
Xchar *dir_proto="%n.dir";
X
Xchar trace[MAXTRACEVAR];		/* debugging info */
Xchar *basename;
Xint datacount;	/* for ssubst - should be replaced */
Xint codecount;
Xint data_file_count=0;	/* actual maxima */
Xint code_file_count=0;
Xstruct hheader hheader;
Xstruct shunk (*hlist)[];
Xchar buf[80];
Xint wsf_count;
X
Xmain(argc,argv)
X	int argc;
X	char **argv;
X{
X	int cur_arg;
X
X	arg_init("C:D:d:t:T",argc,argv);
X	while((cur_arg=arg_next())!=ARG_DONE){
X		switch(cur_arg){
X		case 'C':	/* code prototype */
X			code_proto=strdup(argarg);break;
X		case 'D':	/* data prototype */
X			data_proto=strdup(argarg);break;
X		case 'd':	/* directions prototype */
X			dir_proto=strdup(argarg);break;
X		case 't':	/* trace (debug) */
X			{
X			int dtype=0,dlevel=0;	/* rude defaults */
X			sscanf(argarg,"%d=%d",&dtype,&dlevel);
X			if(dtype<0 || dtype>=MAXTRACEVAR){
X				fprintf(stderr,"-t: bad trace num ignored\n");
X			}else{
X				trace[dtype]=dlevel?dlevel:1;
X			}
X			break;
X			}
X		case 'T':	/* trace everything */
X			{
X			int dtype;
X			for(dtype=0;dtype<MAXTRACEVAR;dtype++)trace[dtype]=255;
X			}
X			break;
X		default:
X			fprintf(stderr,"Unrecognized option.\n");
X			/* FALLTHROUGH */
X		case ARG_ERROR:
X			panic("Error processing arguments.");
X		case ARG_FREE:
X			basename=strdup(argarg);
X			read_load_file(basename);break;
X		}
X	}
X	renumber();
X	out_start(code_proto);
X	write_header();
X	write_code_file();
X	out_stop();
X	out_start(data_proto);
X	write_data_file();
X	out_stop();
X	write_dir_file();
X	exit(0);
X}
X
Xchar *
Xssubst(buf,pat)
X	char *buf;
X	const char *pat;
X{
X	char *buf1=buf;
X
X	while(*pat){
X		if(*pat!='%'){
X			*buf++=*pat++;
X		} else {
X			pat++;
X			switch(*pat++){
X			case '%': *buf++='%';break;
X			case 'n': strcpy(buf,basename);buf=eos(buf);break;
X			case 'D': sprintf(buf,"%02d",datacount);buf=eos(buf);
X				  break;
X			case 'C': sprintf(buf,"%02d",codecount);buf=eos(buf);
X				  break;
X			default:  panic("pattern substitution error");
X			}
X		}
X	}
X	*buf='\0';
X	return buf1;
X}
X
Xvoid
Xpanic(s)
X	char *s;
X{
X	fprintf(stderr,"\npanic: %s\n",s);
X	exit(1);
X}
X
Xchar *
Xeos(s)
X	char *s;
X{
X	while(*s)s++;
X	return s;
X}
X
X/* input routines */
X
X	/* macro for reading the next long.  If e==EOF_OK, caller MUST check
X	 * for EOF condition via hreadval or assure it can't occur */
Xstatic int hreadval=0;		/* macro internal temporary */
X#define EOF_OK	1
X#define EOF_BAD	0
X#define READLONG(e)	\
X	((4!=(hreadval=read(f->fd,&(READLONGx),4)))		\
X	?((0==hreadval && (e)					\
X		?0						\
X		:rderror()))					\
X	:READLONGx)
Xstatic long READLONGx;
X#define READSHORT(e)	\
X	((2!=(hreadval=read(f->fd,&(READSHORTx),2)))		\
X	?((0==hreadval && (e)					\
X		?0						\
X		:rderror()))					\
X	:READSHORTx)
Xstatic short READSHORTx;
X
X#define LONGLEN(x)	(strlen(x)+3 >>2)	/* # longs for a string */
X
Xvoid
Xread_load_file(name)
X	char *name;
X{
X	int t;
X	int hc;
X	file *f=NewFile(name);
X
X		/* read HUNK_HEADER */
X	t=READLONG(EOF_BAD);if(t!=HUNK_HEADER)panic("no HUNK_HEADER");
X	t=READLONG(EOF_BAD);if(t)while(t--)READLONG(EOF_BAD); /* eat any name */
X	hheader.hcount=READLONG(EOF_BAD);
X	hheader.first=READLONG(EOF_BAD);
X	hheader.last=READLONG(EOF_BAD);
X	if(hheader.hcount !=(hheader.last-hheader.first+1))panic("can't count");
X	hheader.sizes=calloc(hheader.hcount,sizeof(int*));
X	for(t=0;t<hheader.hcount;t++)
X		(*hheader.sizes)[t]=READLONG(EOF_BAD);
X
X	hlist=calloc(hheader.hcount,sizeof(struct shunk));
X	for(hc=0;hc<hheader.hcount;hc++){
X		struct shunk *th = &(*hlist)[hc];
X				/* read each hunk */
X		th->h=ReadHunk(f);
X	}
X	close(f->fd);
X}
X
X/* write routines */
X#define S_CODE	0
X#define S_DATA	1
X
Xvoid
Xwrite_header(){
X	int x;
X	int target=0;
X
X	owrite_long(HUNK_HEADER);
X	owrite_long(0);
X	owrite_long(hheader.hcount);
X	owrite_long(hheader.first);
X	owrite_long(hheader.last);
X
X	for(x=0;x<hheader.hcount;x++){
X		hunk *hp = (*hlist)[x].h;
X		if(hp->hunknum==target){
X			owrite_long((*hheader.sizes)[x]);
X			target++;
X		}
X	}
X	for(x=0;x<hheader.hcount;x++){
X		hunk *hp = (*hlist)[x].h;
X		if(hp->hunknum==target){
X			owrite_long((*hheader.sizes)[x]);
X			target++;
X		}
X	}
X	if(target!=hheader.hcount)panic("lost hunks?");
X}
X
Xvoid
Xwrite_code_file(){
X	code_file_count=write_split_file(S_CODE)-1;
X}
X
Xvoid
Xwrite_data_file(){
X	data_file_count=write_split_file(S_DATA)-1;
X}
X
Xvoid
Xwrite_dir_file(){
X	int x;
X	FILE *fp=fopen(ssubst(buf,dir_proto),"w");
X
X	/*fprintf(fp,"%d %d\n",code_file_count,data_file_count);*/
X	for(x=0;x<=code_file_count;x++){
X		codecount=x;
X		fprintf(fp,"C%s\n",ssubst(buf,code_proto));
X	}
X	for(x=0;x<=data_file_count;x++){
X		datacount=x;
X		fprintf(fp,"D%s\n",ssubst(buf,data_proto));
X	}
X	fclose(fp);
X}
X
X/* BUGFIX: 9/23/92: see HT() above */
X#define HT(x)	((x) & ~MEM_OBJ_EXTEND)
X
Xint
Xwrite_split_file(fl)
X	int fl;
X{
X	int hc;
X	for(hc=0;hc<hheader.hcount;hc++){
X		hunk *hp = (*hlist)[hc].h;
X		if(fl==S_CODE && HT(hp->rb->id)==HUNK_CODE){
X			wsf_hunk(hp);
X		} else if(fl==S_DATA && HT(hp->rb->id)==HUNK_DATA){
X			wsf_hunk(hp);
X		} else if(fl==S_DATA && HT(hp->rb->id)==HUNK_BSS){
X			wsf_hunk(hp);
X		}
X	}
X	return wsf_count;
X}
X
X/* BUGFIX: 9/23/92: see HT() below */
Xvoid
Xwsf_hunk(hp)
X	hunk *hp;
X{
X	listlist *el;
X
X	switch(HT(hp->rb->id)){
X	case HUNK_CODE:
X	case HUNK_DATA:
X		owrite(hp->rb->b,(2+hp->rb->b[1])*sizeof(long));
X		break;
X	case HUNK_BSS:
X		owrite(hp->rb->b,2*sizeof(long));
X		break;
X	default:panic("wsf_hunk: bad type");
X	}
X	foreach(el,&(hp->reloc),(listlist*)){
X		write_lreloc(hp,el);
X	}
X	owrite_long(HUNK_END);
X}
X
Xvoid
Xwrite_lreloc(hp,ll)
X	hunk *hp;listlist *ll;
X	{
X	block *bp;
X	owrite_long(HUNK_RELOC32);
X	foreach(bp,&(ll->list),(block*)){
X		owrite_long(bp->b[0]);
X		owrite_long(((*hlist)[bp->b[1]]).h->hunknum);
X		owrite(&(bp->b[2]),bp->b[0]*sizeof(long));
X	}
X	owrite_long(0);
X}
X
Xvoid
Xrenumber()
X{
X	int n;
X	n=renumber2(S_CODE,0);
X	renumber2(S_DATA,n);
X}
X
X/* BUGFIX 9/23/92: hp->rb->id must be wrapped with a bit stripper to ignore
X * memory type bits still in that longword.
X */
X
Xrenumber2(fl,n)
X	int fl;
X	int n;
X{
X	int hc;
X	for(hc=0;hc<hheader.hcount;hc++){
X		hunk *hp = (*hlist)[hc].h;
X		if(fl==S_CODE && HT(hp->rb->id)==HUNK_CODE){
X			hp->hunknum=n++;
X		} else if(fl==S_DATA && HT(hp->rb->id)==HUNK_DATA){
X			hp->hunknum=n++;
X		} else if(fl==S_DATA && HT(hp->rb->id)==HUNK_BSS){
X			hp->hunknum=n++;
X		}
X	}
X	return n;
X}
X
X/* output package */
X#ifndef SOUT
X/* NB - this version does NOT cope with multiple output files per type */
Xint ofile;
X
Xvoid
Xout_start(prot)
X	char *prot;
X{
X	datacount=codecount=0;
X	ofile=open(ssubst(buf,prot),O_WRONLY|O_CREAT|O_TRUNC);
X	if(ofile<0)panic("can't open output file");
X}
X
Xvoid
Xout_stop(){
X	close(ofile);
X}
X
Xvoid
Xowrite_long(literal)
X	long literal;
X{
X	long x=literal;
X	owrite(&x,sizeof(x));
X}
X
Xvoid
Xowrite(where,len)
X	void *where;
X	long len;
X{
X	write(ofile,where,len);
X}
X#else /* SOUT */
Xint ofile=0;
Xint osize;
Xchar *oprot;
Xvoid
Xout_start(prot)
X	char *prot;
X{
X	datacount=codecount=wsf_count=0;
X	oprot=prot;
X	new_file();
X}
X
Xvoid
Xout_stop(){
X	close(ofile);
X	ofile=0;
X}
X
Xvoid
Xowrite_long(literal)
X	long literal;
X{
X	long x=literal;
X	if((osize+sizeof(x))>SPLITSIZE)new_file();
X	owrite(&x,sizeof(x));
X	osize += sizeof(x);
X}
X
Xvoid
Xowrite(where,len)
X	void *where;
X	long len;
X{
X	if((osize+len)>SPLITSIZE)new_file();
X	write(ofile,where,len);
X	osize += len;
X}
X
Xvoid
Xnew_file(){
X	if(ofile)close(ofile);
X	ofile=open(ssubst(buf,oprot),O_WRONLY|O_CREAT|O_TRUNC);
X	if(ofile<0)panic("can't open output file");
X	wsf_count++,datacount++,codecount++;
X	osize=0;
X}
X#endif /* SOUT */
X
Xstruct Node *Head(l)
X	struct List *l;
X	{
X	if(!l)panic("Head(NULL)\n");
X	return l->lh_Head->ln_Succ?l->lh_Head:0;
X}
Xstruct Node *Tail(l)
X	struct List *l;
X{
X	if(!l)panic("Tail(NULL)\n");
X	return (l->lh_TailPred==(NODE_P)l)?0:l->lh_TailPred;
X}
Xstruct Node *Next(n)
X	struct Node *n;
X{
X	if(!n)printf("Warning: Next(NULL)\n");
X	return n?(n->ln_Succ->ln_Succ?n->ln_Succ:0):0;
X}
Xstruct Node *Prev(n)
X	struct Node *n;
X{
X	if(!n)printf("Warning: Prev(NULL)\n");
X	return n?(n->ln_Pred->ln_Pred?n->ln_Pred:0):0;
X}
Xstruct List *_fortemp;	/* scratch for foreach macro */
X
Xvoid
Xdump_after_read(struct List *root){
X    file *f;
X    foreach(f,root,(file *)){
X        punit *p;
X        printf("FILE '%s'\n",f->name);
X        foreach(p,&(f->punits),(punit *)){
X	    hunk *h;
X	    print_text_block("\tPUNIT %.*s\n",p->unit_header);
X	    if(p->libsize){
X		printf("\tlibsize=%08x\n",p->libsize);
X	    } else {
X		/* */
X	    }
X	    foreach(h,&(p->hunks),(hunk *)){
X		print_text_block("\t\tHUNK %.*s",h->name);
X		printf(" @%08x\n",h);
X		print_bin_block(h->rb);
X		printf("\t\t\tCode Reloc\n");
X		printf("\t\t\tData Reloc\n");
X		if(h->merge)printf("\t\t\tmerge(%08x)\n",h->merge);
X		if(h->hunkstart)printf("\t\t\thunkstart\n");
X		if(h->hunkchain)printf("\t\t\thunkchain\n");
X		if(h->hunkgone)printf("\t\t\thunkgone\n");
X		printf("\t\t\toverlay(%08x) hunknum(%08x) offset(%08x)\n",
X		  h->overlay,h->hunknum,h->hunkoffset);
X	    }
X        }
X    }
X}
X
Xvoid
Xprint_text_block(char *fmt,block *b){
X	if(!b){
X		printf(fmt,10,"(no block)");
X	} else {
X		if(b->sw){
X			printf(fmt,13,"(swapped out)");
X		} else {
X			if(!(b->b[1]) || !*(char*)&(b->b[2])){
X				printf(fmt,6,"(null)");
X			} else {
X				printf(fmt,b->b[1]*4,&(b->b[2]));
X			}
X		}
X	}
X}
X
Xvoid
Xprint_bin_block(block *b){
X	if(b->sw){
X		printf("\t\t\t(swapped out)\n");
X	} else {
X		printf("\t\t\tid1=%08x id2=%08x len=%08x\n",
X		  b->id,b->b[0],b->b[1]);
X	}
X}
X
X/*
X * read routines
X */
X
X/*
X * ReadSimpleBlock
X * If the given id is recognized as a simple block (id, length, data),
X * allocate and fill in a block structure.  Include the id in the block.
X */
Xblock *ReadSimpleBlock(f,id)
X	file *f;
X	long id;
X	{
X	long len;
X	long hid;
X	block *b;
X
X	hid=id & 0x0fffffff;
X	if(	hid !=HUNK_UNIT && hid != HUNK_NAME && hid != HUNK_CODE &&
X		hid != HUNK_DATA && hid != HUNK_BSS && hid != HUNK_DEBUG
X	  ){
X		printf("%08x\n",id);
X		panic("ReadSImpleBlock");
X	}
X
X	len=READLONG(EOF_BAD);
X	b=NewBlock();
X	b->id=id;
X	b->sw=0;
X	b->b=NewData((hid==HUNK_BSS)?2:len+2);
X	b->b[0]=id;
X	b->b[1]=len;
X	if(hid != HUNK_BSS)read(f->fd,&(b->b[2]),len*4);
X	return(b);
X}
X
X/*
X * TossSimpleBlock
X * Skip past something we don't need.
X */
Xint TossSimpleBlock(f)
X	file *f;
X	{
X	long len=READLONG(EOF_BAD);
X	if(len)if( lseek(f->fd,len*4,1) == -1)panic("Toss failed\n");
X	return(len);
X}
X
X/*
X * ReadHunk
X * Read an entire hunk, building lists of each block type in the given hunk
X * structure.  If we are listing, do the listing as we read so we can see
X * where things die if we hit a type code we don't recognize.
X */
Xhunk *ReadHunk(f)
X	file *f;
X	{
X	long id;
X	hunk *h=NewHunk();
X	while(1){
X		id=READLONG(EOF_OK);
X		switch(id & 0x0fffffff){	/* ignore memory type bits */
X		case 0: return 0;		/* EOF - not good test */
X		case HUNK_RELOC32:
X			LIST{printf("Reloc32:\n");}
X			ReadReloc(f,id,&h->reloc);break;
X		case HUNK_CODE:
X			h->rb=ReadSimpleBlock(f,id);
X			LIST{printf("Code size %d\n",block_size(h->rb)*4);};
X			break;
X		case HUNK_DATA:
X			h->rb=ReadSimpleBlock(f,id);
X			LIST{printf("Data size %d\n",block_size(h->rb)*4);};
X			break;
X		case HUNK_BSS:
X			h->rb=ReadSimpleBlock(f,id);
X			LIST{printf("Bss size %d\n",block_size(h->rb)*4);};
X			break;
X		case HUNK_SYMBOL:
X			while(TossSimpleBlock(f))READLONG(EOF_BAD);
X			LIST{printf("Symbols skipped\n");};
X			break;
X		case HUNK_DEBUG:
X			(void)TossSimpleBlock(f);
X			LIST{printf("Debug hunk skipped\n");};
X			break;
X		case HUNK_END:	LIST{printf("End of hunk\n");};return h;
X		case HUNK_BREAK:LIST{printf("End of overlay\n");};break;
X		default:
X			printf("Lost id=0x%x\n",id);exit(2);
X		}
X	}
X	return 0;
X}
X
X/*
X * ReadReloc
X * Read a relocation block and build a linked list of the sections.
X * If we are listing, do that now.
X */
Xvoid ReadReloc(f,id,ls)
X	file *f;
X	long id;
X	struct List *ls;
X	{
X	long len;
X	block *cur;
X	listlist *blist=NewListList();
X	AddTail(ls,blist);
X	blist->id=id;
X	len=READLONG(EOF_BAD);
X	while(len){
X		cur=NewBlock();
X		cur->b=NewData(len+2);
X		read(f->fd,&(cur->b[1]),len*4+4);
X		cur->b[0]=len;
X		LIST{printf("\thunk #%d - %d items\n",cur->b[1],len);}
X		AddTail(&blist->list,cur);
X		/*ReadLong(len);*/
X		len=READLONG(EOF_BAD);
X	}
X}
X
Xint rderror(){
X	panic("read error\n");
X	return 0;	/* just to make it quiet - NOTREACHED */
X}
X
Xlong block_size(blk)
X	block *blk;
X{
X	return(blk->b[1]);
X}
X
X/* Allocation routines - if this was C++ then this code would be buried in the
X * constructors.  Doing it this way means we can re-write the allocation later
X * to allocate things we'll need lots of in larger blocks to avoid the time and
X * space penalties of malloc. */
Xfile *NewFile(fname)
X	char *fname;
X	{
X	file *ret=calloc(sizeof(file),1);
X	NewList(&ret->punits);
X	ret->name=strdup(fname);
X	ret->fd= open(fname,O_RDONLY);
X	return(ret);
X}
X
Xpunit *NewPunit(){
X	punit *ret=calloc(sizeof(punit),1);
X	NewList(&ret->hunks);
X	return(ret);
X}
X
Xhunk *NewHunk(){
X	hunk *ret=calloc(sizeof(hunk),1);
X	NewList(&ret->reloc);
X	NewList(&ret->dreloc);
X	NewList(&ret->extsym);
X	ret->overlay=UNASSIGNED_HUNK;
X	return(ret);
X}
X
Xblock *NewBlock()
X	{
X	return calloc(sizeof(block),1);
X}
X
Xlistlist *NewListList(){
X	listlist *ret=calloc(sizeof(listlist),1);
X	NewList(&ret->list);
X	return(ret);
X}
X
Xlong *NewData(longs)
X	long longs;	
X	{
X	return(malloc(longs*4));
X}
END_OF_FILE
if test 13609 -ne `wc -c <'sys/amiga/splitter/splitter.c'`; then
    echo shar: \"'sys/amiga/splitter/splitter.c'\" unpacked with wrong size!
fi
# end of 'sys/amiga/splitter/splitter.c'
fi
if test -f 'sys/share/random.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/share/random.c'\"
else
echo shar: Extracting \"'sys/share/random.c'\" \(13686 characters\)
sed "s/^X//" >'sys/share/random.c' <<'END_OF_FILE'
X/*
X * Copyright (c) 1983 Regents of the University of California.
X * All rights reserved.
X *
X * Redistribution and use in source and binary forms are permitted
X * provided that the above copyright notice and this paragraph are
X * duplicated in all such forms and that any documentation,
X * advertising materials, and other materials related to such
X * distribution and use acknowledge that the software was developed
X * by the University of California, Berkeley.  The name of the
X * University may not be used to endorse or promote products derived
X * from this software without specific prior written permission.
X * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
X * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
X * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
X */
X
X/* Several minor changes were made for the NetHack distribution to satisfy
X * non-BSD compilers (by definition BSD compilers do not need to compile
X * this file for NetHack).  These changes consisted of:
X *	- changing the sccsid conditions to nested ifdefs from defined()s
X *	to accommodate stupid preprocessors
X *	- giving srandom() type void instead of allowing it to default to int
X *	- making the first return in initstate() return a value consistent
X *	with its type (instead of no value)
X *	- ANSI function prototyping in extern.h - therefore include hack.h
X *	instead of stdio.h and remove separate declaration of random() from
X *	the beginning of function srandom
X *	- moving sccsid after hack.h to allow precompiled headers, which
X *	means the defined()s would be ok again...
X *	- change fprintf(stderr, "x(%d)y\n", z) to impossible("x(%d)y", z)
X *	- remove useless variable `j' from srandom()
X */
X
X#include "hack.h"
X
X#ifdef LIBC_SCCS
X# ifndef lint
Xstatic char sccsid[] = "@(#)random.c	5.5 (Berkeley) 7/6/88";
X# endif
X#endif /* LIBC_SCCS and not lint */
X
X/*
X * random.c:
X * An improved random number generation package.  In addition to the standard
X * rand()/srand() like interface, this package also has a special state info
X * interface.  The initstate() routine is called with a seed, an array of
X * bytes, and a count of how many bytes are being passed in; this array is then
X * initialized to contain information for random number generation with that
X * much state information.  Good sizes for the amount of state information are
X * 32, 64, 128, and 256 bytes.  The state can be switched by calling the
X * setstate() routine with the same array as was initiallized with initstate().
X * By default, the package runs with 128 bytes of state information and
X * generates far better random numbers than a linear congruential generator.
X * If the amount of state information is less than 32 bytes, a simple linear
X * congruential R.N.G. is used.
X * Internally, the state information is treated as an array of longs; the
X * zeroeth element of the array is the type of R.N.G. being used (small
X * integer); the remainder of the array is the state information for the
X * R.N.G.  Thus, 32 bytes of state information will give 7 longs worth of
X * state information, which will allow a degree seven polynomial.  (Note: the 
X * zeroeth word of state information also has some other information stored
X * in it -- see setstate() for details).
X * The random number generation technique is a linear feedback shift register
X * approach, employing trinomials (since there are fewer terms to sum up that
X * way).  In this approach, the least significant bit of all the numbers in
X * the state table will act as a linear feedback shift register, and will have
X * period 2^deg - 1 (where deg is the degree of the polynomial being used,
X * assuming that the polynomial is irreducible and primitive).  The higher
X * order bits will have longer periods, since their values are also influenced
X * by pseudo-random carries out of the lower bits.  The total period of the
X * generator is approximately deg*(2**deg - 1); thus doubling the amount of
X * state information has a vast influence on the period of the generator.
X * Note: the deg*(2**deg - 1) is an approximation only good for large deg,
X * when the period of the shift register is the dominant factor.  With deg
X * equal to seven, the period is actually much longer than the 7*(2**7 - 1)
X * predicted by this formula.
X */
X
X
X
X/*
X * For each of the currently supported random number generators, we have a
X * break value on the amount of state information (you need at least this
X * many bytes of state info to support this random number generator), a degree
X * for the polynomial (actually a trinomial) that the R.N.G. is based on, and
X * the separation between the two lower order coefficients of the trinomial.
X */
X
X#define		TYPE_0		0		/* linear congruential */
X#define		BREAK_0		8
X#define		DEG_0		0
X#define		SEP_0		0
X
X#define		TYPE_1		1		/* x**7 + x**3 + 1 */
X#define		BREAK_1		32
X#define		DEG_1		7
X#define		SEP_1		3
X
X#define		TYPE_2		2		/* x**15 + x + 1 */
X#define		BREAK_2		64
X#define		DEG_2		15
X#define		SEP_2		1
X
X#define		TYPE_3		3		/* x**31 + x**3 + 1 */
X#define		BREAK_3		128
X#define		DEG_3		31
X#define		SEP_3		3
X
X#define		TYPE_4		4		/* x**63 + x + 1 */
X#define		BREAK_4		256
X#define		DEG_4		63
X#define		SEP_4		1
X
X
X/*
X * Array versions of the above information to make code run faster -- relies
X * on fact that TYPE_i == i.
X */
X
X#define		MAX_TYPES	5		/* max number of types above */
X
Xstatic  int		degrees[ MAX_TYPES ]	= { DEG_0, DEG_1, DEG_2,
X								DEG_3, DEG_4 };
X
Xstatic  int		seps[ MAX_TYPES ]	= { SEP_0, SEP_1, SEP_2,
X								SEP_3, SEP_4 };
X
X
X
X/*
X * Initially, everything is set up as if from :
X *		initstate( 1, &randtbl, 128 );
X * Note that this initialization takes advantage of the fact that srandom()
X * advances the front and rear pointers 10*rand_deg times, and hence the
X * rear pointer which starts at 0 will also end up at zero; thus the zeroeth
X * element of the state information, which contains info about the current
X * position of the rear pointer is just
X *	MAX_TYPES*(rptr - state) + TYPE_3 == TYPE_3.
X */
X
Xstatic  long		randtbl[ DEG_3 + 1 ]	= { TYPE_3,
X			    0x9a319039, 0x32d9c024, 0x9b663182, 0x5da1f342, 
X			    0xde3b81e0, 0xdf0a6fb5, 0xf103bc02, 0x48f340fb, 
X			    0x7449e56b, 0xbeb1dbb0, 0xab5c5918, 0x946554fd, 
X			    0x8c2e680f, 0xeb3d799f, 0xb11ee0b7, 0x2d436b86, 
X			    0xda672e2a, 0x1588ca88, 0xe369735d, 0x904f35f7, 
X			    0xd7158fd6, 0x6fa6f051, 0x616e6b96, 0xac94efdc, 
X			    0x36413f93, 0xc622c298, 0xf5a42ab8, 0x8a88d77b, 
X					0xf5ad9d0e, 0x8999220b, 0x27fb47b9 };
X
X/*
X * fptr and rptr are two pointers into the state info, a front and a rear
X * pointer.  These two pointers are always rand_sep places aparts, as they cycle
X * cyclically through the state information.  (Yes, this does mean we could get
X * away with just one pointer, but the code for random() is more efficient this
X * way).  The pointers are left positioned as they would be from the call
X *			initstate( 1, randtbl, 128 )
X * (The position of the rear pointer, rptr, is really 0 (as explained above
X * in the initialization of randtbl) because the state table pointer is set
X * to point to randtbl[1] (as explained below).
X */
X
Xstatic  long		*fptr			= &randtbl[ SEP_3 + 1 ];
Xstatic  long		*rptr			= &randtbl[ 1 ];
X
X
X
X/*
X * The following things are the pointer to the state information table,
X * the type of the current generator, the degree of the current polynomial
X * being used, and the separation between the two pointers.
X * Note that for efficiency of random(), we remember the first location of
X * the state information, not the zeroeth.  Hence it is valid to access
X * state[-1], which is used to store the type of the R.N.G.
X * Also, we remember the last location, since this is more efficient than
X * indexing every time to find the address of the last element to see if
X * the front and rear pointers have wrapped.
X */
X
Xstatic  long		*state			= &randtbl[ 1 ];
X
Xstatic  int		rand_type		= TYPE_3;
Xstatic  int		rand_deg		= DEG_3;
Xstatic  int		rand_sep		= SEP_3;
X
Xstatic  long		*end_ptr		= &randtbl[ DEG_3 + 1 ];
X
X
X
X/*
X * srandom:
X * Initialize the random number generator based on the given seed.  If the
X * type is the trivial no-state-information type, just remember the seed.
X * Otherwise, initializes state[] based on the given "seed" via a linear
X * congruential generator.  Then, the pointers are set to known locations
X * that are exactly rand_sep places apart.  Lastly, it cycles the state
X * information a given number of times to get rid of any initial dependencies
X * introduced by the L.C.R.N.G.
X * Note that the initialization of randtbl[] for default usage relies on
X * values produced by this routine.
X */
X
Xvoid
Xsrandom( x )
X
X    unsigned		x;
X{
X    	register  int		i;
X
X	if(  rand_type  ==  TYPE_0  )  {
X	    state[ 0 ] = x;
X	}
X	else  {
X	    state[ 0 ] = x;
X	    for( i = 1; i < rand_deg; i++ )  {
X		state[i] = 1103515245*state[i - 1] + 12345;
X	    }
X	    fptr = &state[ rand_sep ];
X	    rptr = &state[ 0 ];
X	    for( i = 0; i < 10*rand_deg; i++ )  random();
X	}
X}
X
X
X
X/*
X * initstate:
X * Initialize the state information in the given array of n bytes for
X * future random number generation.  Based on the number of bytes we
X * are given, and the break values for the different R.N.G.'s, we choose
X * the best (largest) one we can and set things up for it.  srandom() is
X * then called to initialize the state information.
X * Note that on return from srandom(), we set state[-1] to be the type
X * multiplexed with the current value of the rear pointer; this is so
X * successive calls to initstate() won't lose this information and will
X * be able to restart with setstate().
X * Note: the first thing we do is save the current state, if any, just like
X * setstate() so that it doesn't matter when initstate is called.
X * Returns a pointer to the old state.
X */
X
Xchar  *
Xinitstate( seed, arg_state, n )
X
X    unsigned		seed;			/* seed for R. N. G. */
X    char		*arg_state;		/* pointer to state array */
X    int			n;			/* # bytes of state info */
X{
X	register  char		*ostate		= (char *)( &state[ -1 ] );
X
X	if(  rand_type  ==  TYPE_0  )  state[ -1 ] = rand_type;
X	else  state[ -1 ] = MAX_TYPES*(rptr - state) + rand_type;
X	if(  n  <  BREAK_1  )  {
X	    if(  n  <  BREAK_0  )  {
X		impossible(
X "initstate: not enough state (%d bytes) with which to do jack; ignored.", n);
X		return (char *)0;
X	    }
X	    rand_type = TYPE_0;
X	    rand_deg = DEG_0;
X	    rand_sep = SEP_0;
X	}
X	else  {
X	    if(  n  <  BREAK_2  )  {
X		rand_type = TYPE_1;
X		rand_deg = DEG_1;
X		rand_sep = SEP_1;
X	    }
X	    else  {
X		if(  n  <  BREAK_3  )  {
X		    rand_type = TYPE_2;
X		    rand_deg = DEG_2;
X		    rand_sep = SEP_2;
X		}
X		else  {
X		    if(  n  <  BREAK_4  )  {
X			rand_type = TYPE_3;
X			rand_deg = DEG_3;
X			rand_sep = SEP_3;
X		    }
X		    else  {
X			rand_type = TYPE_4;
X			rand_deg = DEG_4;
X			rand_sep = SEP_4;
X		    }
X		}
X	    }
X	}
X	state = &(  ( (long *)arg_state )[1]  );	/* first location */
X	end_ptr = &state[ rand_deg ];	/* must set end_ptr before srandom */
X	srandom( seed );
X	if(  rand_type  ==  TYPE_0  )  state[ -1 ] = rand_type;
X	else  state[ -1 ] = MAX_TYPES*(rptr - state) + rand_type;
X	return( ostate );
X}
X
X
X
X/*
X * setstate:
X * Restore the state from the given state array.
X * Note: it is important that we also remember the locations of the pointers
X * in the current state information, and restore the locations of the pointers
X * from the old state information.  This is done by multiplexing the pointer
X * location into the zeroeth word of the state information.
X * Note that due to the order in which things are done, it is OK to call
X * setstate() with the same state as the current state.
X * Returns a pointer to the old state information.
X */
X
Xchar  *
Xsetstate( arg_state )
X
X    char		*arg_state;
X{
X	register  long		*new_state	= (long *)arg_state;
X	register  int		type		= new_state[0]%MAX_TYPES;
X	register  int		rear		= new_state[0]/MAX_TYPES;
X	char			*ostate		= (char *)( &state[ -1 ] );
X
X	if(  rand_type  ==  TYPE_0  )  state[ -1 ] = rand_type;
X	else  state[ -1 ] = MAX_TYPES*(rptr - state) + rand_type;
X	switch(  type  )  {
X	    case  TYPE_0:
X	    case  TYPE_1:
X	    case  TYPE_2:
X	    case  TYPE_3:
X	    case  TYPE_4:
X		rand_type = type;
X		rand_deg = degrees[ type ];
X		rand_sep = seps[ type ];
X		break;
X
X	    default:
X  impossible("setstate: state info has been munged (%d); not changed.", type);
X		break;
X	}
X	state = &new_state[ 1 ];
X	if(  rand_type  !=  TYPE_0  )  {
X	    rptr = &state[ rear ];
X	    fptr = &state[ (rear + rand_sep)%rand_deg ];
X	}
X	end_ptr = &state[ rand_deg ];		/* set end_ptr too */
X	return( ostate );
X}
X
X
X
X/*
X * random:
X * If we are using the trivial TYPE_0 R.N.G., just do the old linear
X * congruential bit.  Otherwise, we do our fancy trinomial stuff, which is the
X * same in all ther other cases due to all the global variables that have been
X * set up.  The basic operation is to add the number at the rear pointer into
X * the one at the front pointer.  Then both pointers are advanced to the next
X * location cyclically in the table.  The value returned is the sum generated,
X * reduced to 31 bits by throwing away the "least random" low bit.
X * Note: the code takes advantage of the fact that both the front and
X * rear pointers can't wrap on the same call by not testing the rear
X * pointer if the front one has wrapped.
X * Returns a 31-bit random number.
X */
X
Xlong
Xrandom()
X{
X	long		i;
X	
X	if(  rand_type  ==  TYPE_0  )  {
X	    i = state[0] = ( state[0]*1103515245 + 12345 )&0x7fffffff;
X	}
X	else  {
X	    *fptr += *rptr;
X	    i = (*fptr >> 1)&0x7fffffff;	/* chucking least random bit */
X	    if(  ++fptr  >=  end_ptr  )  {
X		fptr = state;
X		++rptr;
X	    }
X	    else  {
X		if(  ++rptr  >=  end_ptr  )  rptr = state;
X	    }
X	}
X	return( i );
X}
X
END_OF_FILE
if test 13686 -ne `wc -c <'sys/share/random.c'`; then
    echo shar: \"'sys/share/random.c'\" unpacked with wrong size!
fi
# end of 'sys/share/random.c'
fi
echo shar: End of archive 88 \(of 108\).
cp /dev/null ark88isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \
21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \
41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 \
61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 \
81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 \
101 102 103 104 105 106 107 108 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 108 archives.
    echo "Now execute 'rebuild.sh'"
    rm -f ark10[0-8]isdone ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
