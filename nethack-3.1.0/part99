Path: uunet!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v16i107:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Part99/108
Message-ID: <4472@master.CNA.TEK.COM>
Date: 5 Feb 93 22:03:23 GMT
Sender: news@master.CNA.TEK.COM
Lines: 1831
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1658

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 16, Issue 107
Archive-name: nethack31/Part99
Supersedes: nethack3p9: Volume 10, Issue 46-108
Environment: Amiga, Atari, Mac, MS-DOS, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 99 (of 108)."
# Contents:  Porting include/artilist.h include/monflag.h src/explode.c
#   sys/atari/atarifnt.uue sys/atari/tos.c sys/msdos/Makefile.dat
#   sys/os2/os2.c
# Wrapped by billr@saab on Wed Jan 27 16:09:29 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'Porting' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Porting'\"
else
echo shar: Extracting \"'Porting'\" \(7341 characters\)
sed "s/^X//" >'Porting' <<'END_OF_FILE'
X  NetHack Porting Guidelines		v 3.1			93-01-08
X
X
X     1.0	Introduction
X
X	This document goes through the steps required to port NetHack to a
Xnew machine.  The basic steps in porting the program are:
X
X	1.  Get the code onto your machine.  The parts of the current
X	    directory setup you definitely need include src (NetHack code
X	    shared by all systems), include (include files), util (code
X	    for utility programs), and dat (various data files).  The
X	    documentation in doc is strongly recommended.  You already
X	    have the files in the top directory since you're reading this
X	    one. :-)
X
X	    A full list of the distribution files and their associated
X	    OSes may be found in the top-level file "Files".
X
X	    If your machine uses an OS already supported, you need the sys
X	    subdirectory for that OS and possibly sys/share.  Otherwise,
X	    get the closest match (say sys/msdos for single-tasking OSes
X	    and sys/unix for multi-user OSes, along with sys/share, if
X	    nothing else comes to mind).  You may want others for
X	    comparison.
X
X	    If your machine uses a windowing system already supported,
X	    you need the win subdirectory for that system (or the
X	    appropriate sys subdirectory if the windowing system was
X	    previously considered restricted to one OS).
X
X	2.  Modify the appropriate include files to customize NetHack to
X	    your system.  You may need to add a new OS-specific "*conf.h"
X	    file (see unixconf.h, pcconf.h, tosconf.h, etc. as examples).
X
X	3.  If your machine uses a new OS instead of a variant of existing
X	    OSes, add a new sys subdirectory.  Add, if required, a OS-
X	    specific copy of "main.c", "tty.c" and "unix.c".  Possibly
X	    add an OS-specific library (see "msdos.c" and "tos.c" as
X	    examples) to provide functions NetHack wants and your OS lacks.
X
X	4.  If your machine uses a new windowing system, follow doc/window.doc
X	    carefully.  Put files implementing these routines in a win or
X	    sys subdirectory as appropriate.
X
X	5.  If your compilation environment isn't close to one already
X	    supported, try starting from the UNIX makefiles.  Modify the
X	    top level makefile and the src makefile as required.  Then run
X	    an initial compile.  You are bound to get some errors.  You
X	    should be able to fix them in a fairly simple fashion.  If
X	    things seem to be getting too complex, take a step back, and
X	    possibly send us some mail.  We might be able to help.
X
X	6.  Mail all of your fixes to us in a contextual form so that we can
X	    easily integrate them into the code.
X
X	One general rule of thumb exists.  Always add code.  Don't delete
Xsomebody else's code for yours -- it won't work on their machine if you do.
XAlways add your OS specific code inside #ifdef / #else / #endif constructs
Xso that it will be able to be folded back into the original code easily.
X
X
X     2.0	Include Files
X
X     2.1	config.h
X
X	The file "config.h" is a master configuration file that determines
Xthe basic features of the game, as well as many of the security options.
XIt is intended that end users configure the game by editing "config.h" and
Xan appropriate "*conf.h" file, so any #defines for individual preferences
Xshould be added to those files.  OS-specific #defines that are not intended
Xto be changed should also go in "*conf.h"; try to find the most appropriate
Xplace for other #defines.
X
X	The following sections may require modification:
X
X     -	Section 1:	OS and window system selection.
X			You may have to put a #define for your OS here.
X			If your OS is yet another UNIX variant, put the
X			#define in unixconf.h instead.
X			A unfortunately large amount of stuff shares
X			this section because the #definitions have to
X			be seen before *conf.h is reached.  Don't add
X			to this unless necessary.
X
X     -	Section 2:	Global parameters and filenames.
X			These will have to be customized to your system.
X
X     -	Section 3:	Type definitions and other compiler behavior.
X			These will have to be matched to your compiler.
X
X     2.2	global.h
X
X	This file defines things specific to NetHack that should not
Xrequire modification by an end user.  For a new port, you may have to add
Xautomatic inclusion of another auxiliary config file (*conf.h) which you
Xwrote for your system.
X
X     2.3	extern.h
X
X	If you create any new source modules or new functions in old modules,
Xyou must enter the names of the new external references (the functions defined
Xthere for external use) in this file.
X
X     2.4	system.h
X
X	This file contains references for all hooks into the OS (via the
Xstandard "C" libraries).  Depending on what your standard library looks like,
Xyou may have to put new entries into this file.
X
X
X     3.0	Source files
X
X	The first step in getting the game up is to get the "makedefs"
Xprogram running.  This program is used to create configuration-specific
Xfiles for the game.
X
X	Once "makedefs" has been built, the rest of the game can be compiled.
XYou may have to create an OS-specific module to handle things you want to
Xuse, like a mouse or a ram-disk.
X
X	The utility compilers "dgn_comp" and "lev_comp" may be a better
Xplace to start.  They also require "makedefs" but are independent of
X"nethack".  They are usually the last programs made, but since they are
Xmuch smaller they may be more tractable when first arguing with the include
Xfiles.  These programs create binary data files that "nethack" uses to
Xguide its dungeon creation.
X
X     3.1	Makefiles
X
X	This distribution provides makefiles for several kinds of systems.
XThere are joint makefiles for the various varieties of UNIX, makefiles for
XMSDOS, a makefile for Amigas, and so on.  You may have to create a new
Xmakefile for your specific machine.  You may even have to translate some
Xmakefiles into a form more congenial to your system.  If possible, however,
Xadd to one of those provided.
X
X     3.2	termcap.c
X
X	If your system wants to use tty windowing and it doesn't run off
Xof a termcap or terminfo database, you may have to put the appropriate
Xterminal control strings into termcap.c.  This has already been done for
XMSDOS, and these mods can be used as an example.  You can also consider
Xusing the termcap code from sys/share/termcap.uu or sys/vms/gnutermcap.c,
Xespecially if your system supports multiple kinds of terminals.
X
X     3.3	main.c
X
X	You may need to create a new "main.c" module.  If you do, call it
X[OS]main.c where the [OS] is replaced with the name of the OS you are porting
Xto.  This file contains the mainline module, which reads options from the
Xcommand line (or wherever) and processes them.  It also contains various
Xfunctions associated with game startup.
X
X     3.4	tty.c
X
X	You may need to create a new "tty.c" module.  If you do, call it
X[OS]tty.c where the [OS] is replaced with the name of the OS you are porting
Xto.  This file contains the routines that configure the terminal/console
Xfor raw I/O, etc.
X
X     3.5	unix.c
X
X	You may need to create a new "unix.c" module.  If you do, call it
X[OS]unix.c where the [OS] is replaced with the name of the OS you are porting
Xto.  This file contains some OS dependencies concerning time and filename
Xcreation.
X
X
X	An object of the NetHack development project is to get the game
Xworking on as many different types of hardware and under as many different
Xoperating systems as is practical.  Any assistance will be appreciated.
END_OF_FILE
if test 7341 -ne `wc -c <'Porting'`; then
    echo shar: \"'Porting'\" unpacked with wrong size!
fi
# end of 'Porting'
fi
if test -f 'include/artilist.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/artilist.h'\"
else
echo shar: Extracting \"'include/artilist.h'\" \(6932 characters\)
sed "s/^X//" >'include/artilist.h' <<'END_OF_FILE'
X/*	SCCS Id: @(#)artilist.h	3.1	92/12/13	*/
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#ifdef MAKEDEFS_C
X/* in makedefs.c, all we care about is the list of names */
X
X#define A(nam,typ,s1,s2,mt,atk,dfn,cry,inv,al,cl) nam
X
Xstatic const char *artifact_names[] = {
X#else
X/* in artifact.c, set up the actual artifact list structure */
X
X#define A(nam,typ,s1,s2,mt,atk,dfn,cry,inv,al,cl) \
X { typ, nam, s1, s2, mt, atk, dfn, cry, inv, al, cl }
X
X#define     NO_ATTK	{0,0,0,0}		/* no attack */
X#define     NO_DFNS	{0,0,0,0}		/* no defense */
X#define     NO_CARY	{0,0,0,0}		/* no carry effects */
X#define     DFNS(c)	{0,c,0,0}
X#define     CARY(c)	{0,c,0,0}
X#define     PHYS(a,b)	{0,AD_PHYS,a,b}		/* physical */
X#define     DRLI(a,b)	{0,AD_DRLI,a,b}		/* life drain */
X#define     COLD(a,b)	{0,AD_COLD,a,b}
X#define     FIRE(a,b)	{0,AD_FIRE,a,b}
X#define     ELEC(a,b)	{0,AD_ELEC,a,b}		/* electrical shock */
X#define     STUN(a,b)	{0,AD_STUN,a,b}		/* magical attack */
X
XSTATIC_OVL const struct artifact NEARDATA artilist[] = {
X#endif	/* MAKEDEFS_C */
X
X/*  dummy element #0, so that all interesting indices are non-zero */
XA("",				STRANGE_OBJECT,
X	0, 0, 0, NO_ATTK, NO_DFNS, NO_CARY, 0, A_NONE, 0 ),
X
XA("Excalibur",			LONG_SWORD,
X	(SPFX_NOGEN|SPFX_RESTR|SPFX_SEEK|SPFX_DEFN|SPFX_INTEL|SPFX_SEARCH),0,0,
X	PHYS(5,10),	DRLI(0,0),	NO_CARY,	0, A_LAWFUL,	'K' ),
X/*
X *	Stormbringer only has a 2 because it can drain a level,
X *	providing 8 more.
X */
XA("Stormbringer",		RUNESWORD,
X	(SPFX_RESTR|SPFX_ATTK|SPFX_DEFN|SPFX_INTEL|SPFX_DRLI), 0, 0,
X	DRLI(5,2),	DRLI(0,0),	NO_CARY,	0, A_CHAOTIC,	 0  ),
X/*
X *	Mjollnir will return to the hand of the wielder when thrown
X *	if the wielder is wearing Gauntlets of Power.
X */
XA("Mjollnir",			WAR_HAMMER,		/* Mjo:llnir */
X	(SPFX_RESTR|SPFX_ATTK),  0, 0,
X	ELEC(5,24),	NO_DFNS,	NO_CARY,	0, A_NEUTRAL,	'V' ),
X
XA("Cleaver",			BATTLE_AXE,
X	SPFX_RESTR, 0, 0,
X	PHYS(3,6),	NO_DFNS,	NO_CARY,	0, A_NEUTRAL,	'B' ),
X
XA("Grimtooth",			ORCISH_DAGGER,
X	SPFX_RESTR, 0, 0,
X	PHYS(2,6),	NO_DFNS,	NO_CARY,	0, A_CHAOTIC,	 0  ),
X
XA("Orcrist",			ELVEN_BROADSWORD,
X	SPFX_DFLAG2, 0, M2_ORC,
X	PHYS(5,0),	NO_DFNS,	NO_CARY,	0, A_LAWFUL,	'E' ),
X
XA("Sting",			ELVEN_DAGGER,
X	(SPFX_WARN|SPFX_DFLAG2), 0, M2_ORC,
X	PHYS(5,0),	NO_DFNS,	NO_CARY,	0, A_LAWFUL,	 0  ),
X/*
X *	Magicbane is a bit different!  Its magic fanfare
X *	unbalances victims in addition to doing some damage.
X */
XA("Magicbane",			ATHAME,
X	(SPFX_RESTR|SPFX_ATTK|SPFX_DEFN), 0, 0,
X	STUN(3,4),	DFNS(AD_MAGM),	NO_CARY,	0, A_NEUTRAL,	'W' ),
X
XA("Frost Brand",		LONG_SWORD,
X	(SPFX_RESTR|SPFX_ATTK|SPFX_DEFN), 0, 0,
X	COLD(5,0),	COLD(0,0),	NO_CARY,	0, A_NEUTRAL,	 0  ),
X
XA("Fire Brand",			LONG_SWORD,
X	(SPFX_RESTR|SPFX_ATTK|SPFX_DEFN), 0, 0,
X	FIRE(5,0),	FIRE(0,0),	NO_CARY,	0, A_NEUTRAL,	 0  ),
X
XA("Dragonbane",			BROADSWORD,
X	(SPFX_RESTR|SPFX_DCLAS), 0, S_DRAGON,
X	PHYS(5,0),	NO_DFNS,	NO_CARY,	0, A_NEUTRAL,	 0  ),
X
XA("Demonbane",			LONG_SWORD,
X	(SPFX_RESTR|SPFX_DFLAG2), 0, M2_DEMON,
X	PHYS(5,0),	NO_DFNS,	NO_CARY,	0, A_LAWFUL,	 0  ),
X
XA("Werebane",			SILVER_SABER,
X	(SPFX_RESTR|SPFX_DFLAG2), 0, M2_WERE,
X	PHYS(5,0),	NO_DFNS,	NO_CARY,	0, A_LAWFUL,	 0  ),
X
XA("Grayswandir",		SILVER_SABER,
X	(SPFX_RESTR|SPFX_HALRES), 0, 0,
X	PHYS(5,0),	NO_DFNS,	NO_CARY,	0, A_LAWFUL,	 0  ),
X
XA("Giantslayer",		LONG_SWORD,
X	(SPFX_RESTR|SPFX_DFLAG2), 0, M2_GIANT,
X	PHYS(5,0),	NO_DFNS,	NO_CARY,	0, A_NEUTRAL,	 0  ),
X
XA("Ogresmasher",		WAR_HAMMER,
X	(SPFX_RESTR|SPFX_DCLAS), 0, S_OGRE,
X	PHYS(5,0),	NO_DFNS,	NO_CARY,	0, A_LAWFUL,	 0  ),
X
XA("Trollsbane",			MORNING_STAR,
X	(SPFX_RESTR|SPFX_DCLAS), 0, S_TROLL,
X	PHYS(5,0),	NO_DFNS,	NO_CARY,	0, A_LAWFUL,	 0  ),
X/*
X *	Two problems:  1) doesn't let trolls regenerate heads,
X *	2) doesn't give unusual message for 2-headed monsters (but
X *	allowing those at all causes more problems than worth the effort).
X */
XA("Vorpal Blade",		LONG_SWORD,
X	(SPFX_RESTR|SPFX_BEHEAD), 0, 0,
X	PHYS(5,1),	NO_DFNS,	NO_CARY,	0, A_NEUTRAL,	 0  ),
X/*
X *	Ah, never shall I forget the cry,
X *		or the shriek that shrieked he,
X *	As I gnashed my teeth, and from my sheath
X *		I drew my Snickersnee!
X *			--Koko, Lord high executioner of Titipu
X *			  (From Sir W.S. Gilbert's "The Mikado")
X */
XA("Snickersnee",		KATANA,
X	SPFX_RESTR, 0, 0,
X	PHYS(0,8),	NO_DFNS,	NO_CARY,	0, A_LAWFUL,	'S' ),
X
XA("Sunsword",			LONG_SWORD,
X	(SPFX_RESTR|SPFX_DFLAG2), 0, M2_UNDEAD,
X	PHYS(5,0),	NO_DFNS,	NO_CARY,	0, A_LAWFUL,	 0  ),
X
X#ifdef MULDGN
X/*
X *	The artifacts for the quest dungeon, all self-willed.
X */
X
XA("The Orb of Detection",	CRYSTAL_BALL,
X	(SPFX_NOGEN|SPFX_RESTR|SPFX_INTEL), (SPFX_ESP|SPFX_HSPDAM), 0,
X	NO_ATTK,	NO_DFNS,	CARY(AD_MAGM),
X	INVIS,		A_LAWFUL,	'A' ),
X
XA("The Heart of Ahriman", LUCKSTONE,
X	(SPFX_NOGEN|SPFX_RESTR|SPFX_INTEL), SPFX_STLTH, 0,
X	NO_ATTK,	NO_DFNS,	NO_CARY,
X	LEVITATION,	A_NEUTRAL,	'B' ),
X
XA("The Sceptre of Might",	QUARTERSTAFF,
X	(SPFX_NOGEN|SPFX_RESTR|SPFX_INTEL|SPFX_DALIGN), 0, 0,
X	PHYS(0,0),	NO_DFNS,	CARY(AD_MAGM),
X	CONFLICT,	A_LAWFUL,	'C' ),
X
XA("The Palantir of Westernesse",	CRYSTAL_BALL,
X	(SPFX_NOGEN|SPFX_RESTR|SPFX_INTEL),
X		(SPFX_ESP|SPFX_REGEN|SPFX_HSPDAM), 0,
X	NO_ATTK,	NO_DFNS,	NO_CARY,
X	TAMING,		A_CHAOTIC,	'E' ),
X
XA("The Staff of Aesculapius",	QUARTERSTAFF,
X	(SPFX_NOGEN|SPFX_RESTR|SPFX_ATTK|SPFX_INTEL|SPFX_DRLI|SPFX_REGEN), 0,0,
X	DRLI(0,0),	NO_DFNS,	NO_CARY,
X	HEALING,	A_NEUTRAL,	'H' ),
X
XA("The Magic Mirror of Merlin",	MIRROR,
X	(SPFX_NOGEN|SPFX_RESTR|SPFX_SPEEK), SPFX_ESP, 0,
X	NO_ATTK,	NO_DFNS,	CARY(AD_MAGM),
X	0,		A_LAWFUL,	'K' ),
X
XA("The Mitre of Holiness",	HELM_OF_BRILLIANCE,
X	(SPFX_NOGEN|SPFX_RESTR|SPFX_DCLAS|SPFX_INTEL), 0, M2_UNDEAD,
X	NO_ATTK,	NO_DFNS,	CARY(AD_FIRE),
X	ENERGY_BOOST,	A_LAWFUL,	'P' ),
X
XA("The Master Key of Thievery", SKELETON_KEY,
X	(SPFX_NOGEN|SPFX_RESTR|SPFX_INTEL|SPFX_SPEEK),
X		(SPFX_WARN|SPFX_TCTRL|SPFX_HPHDAM), 0,
X	NO_ATTK,	NO_DFNS,	NO_CARY,
X	UNTRAP,		A_CHAOTIC,	'R' ),
X
XA("The Tsurugi of Muramasa",	TSURUGI,
X	(SPFX_NOGEN|SPFX_RESTR|SPFX_INTEL|SPFX_BEHEAD|SPFX_LUCK), 0, 0,
X	NO_ATTK,	NO_DFNS,	NO_CARY,
X	0,		A_LAWFUL,	'S' ),
X
X# ifdef TOURIST
XA("The Platinum Yendorian Express Card", CREDIT_CARD,
X	(SPFX_NOGEN|SPFX_RESTR|SPFX_INTEL|SPFX_DEFN),
X		(SPFX_ESP|SPFX_HSPDAM), 0,
X	NO_ATTK,	NO_DFNS,	CARY(AD_MAGM),
X	CHARGE_OBJ,	A_NEUTRAL,	'T' ),
X# endif
X
XA("The Orb of Fate",		CRYSTAL_BALL,
X	(SPFX_NOGEN|SPFX_RESTR|SPFX_INTEL|SPFX_LUCK),
X		(SPFX_WARN|SPFX_HSPDAM|SPFX_HPHDAM), 0,
X	NO_ATTK,	NO_DFNS,	NO_CARY,
X	LEV_TELE,	A_NEUTRAL,	'V' ),
X
XA("The Eye of the Aethiopica",	AMULET_OF_ESP,
X	(SPFX_NOGEN|SPFX_RESTR|SPFX_INTEL), (SPFX_EREGEN|SPFX_HSPDAM), 0,
X	NO_ATTK,	NO_DFNS,	CARY(AD_MAGM),
X	CREATE_PORTAL,	A_NEUTRAL,	'W' ),
X#endif	/* MULDGN */
X/*
X *  terminator; otyp must be zero
X */
XA(0, 0, 0, 0, 0, NO_ATTK, NO_DFNS, NO_CARY, 0, A_NONE, 0 )
X
X};	/* artilist[] (or artifact_names[]) */
X
X#undef	A
X
X#ifndef MAKEDEFS_C
X#undef	NO_ATTK
X#undef	NO_DFNS
X#undef	DFNS
X#undef	PHYS
X#undef	DRLI
X#undef	COLD
X#undef	FIRE
X#undef	ELEC
X#undef	STUN
X#endif
X
X/*artilist.h*/
END_OF_FILE
if test 6932 -ne `wc -c <'include/artilist.h'`; then
    echo shar: \"'include/artilist.h'\" unpacked with wrong size!
fi
# end of 'include/artilist.h'
fi
if test -f 'include/monflag.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/monflag.h'\"
else
echo shar: Extracting \"'include/monflag.h'\" \(7000 characters\)
sed "s/^X//" >'include/monflag.h' <<'END_OF_FILE'
X/*	SCCS Id: @(#)monflag.h	3.1	92/11/25	*/
X/* Copyright (c) 1989 Mike Threepoint				  */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#ifndef MONFLAG_H
X#define MONFLAG_H
X
X#define MS_SILENT	0	/* makes no sound */
X#define MS_SQEEK	1	/* squeaks, as a rodent */
X#define MS_SQAWK	2	/* squawks, as a bird */
X#define MS_HISS		3	/* hisses */
X#define MS_BUZZ		4	/* buzzes (killer bee) */
X#define MS_GRUNT	5	/* grunts (or speaks own language) */
X#define MS_GROWL	6	/* growls */
X#define MS_BARK		7	/* if full moon, may howl */
X#define MS_MEW		8	/* mews or hisses */
X#define MS_ROAR		9	/* roars */
X#define MS_NEIGH	10	/* neighs, as an equine */
X#define MS_WAIL		11	/* wails, as a tortured soul */
X#define MS_GURGLE	12	/* gurgles, as liquid or through saliva */
X#define MS_BURBLE	13	/* burbles (jabberwock) */
X#define MS_SHRIEK	15	/* wakes up others */
X#define MS_LAUGH	17	/* grins, smiles, giggles, and laughs */
X#define MS_MUMBLE	18	/* says something or other */
X#define MS_IMITATE	19	/* imitates others (leocrotta) */
X#define MS_SEDUCE	20	/* "Hello, sailor." (Nymphs) */
X#define MS_VAMPIRE	21	/* vampiric seduction, Vlad's exclamations */
X#define MS_ORC		MS_GRUNT	/* intelligent brutes */
X#define MS_BRIBE	25	/* asks for money, or berates you */
X#define MS_CUSS		26	/* berates (demons) or intimidates (Wiz) */
X#define MS_NURSE	27	/* "Take off your shirt, please." */
X#define MS_DJINNI	28	/* "Thank you for freeing me!" */
X#define MS_HUMANOID	29	/* generic traveling companion */
X#define MS_GUARD	30	/* "Please drop that gold and follow me." */
X#define MS_SELL		31	/* demand payment, complain about shoplifters */
X#define MS_ORACLE	32	/* do a consultation */
X#define MS_PRIEST	33	/* ask for contribution; do cleansing */
X#ifdef KOPS
X#define MS_ARREST	34	/* "Stop in the name of the law!" (Kops) */
X#endif
X#define MS_SOLDIER	35	/* army and watchmen expressions */
X#ifdef MULDGN
X#define MS_LEADER	36	/* your class leader */
X#define MS_NEMESIS	37	/* your nemesis */
X#define MS_GUARDIAN	38	/* your leader's guards */
X#endif
X#define MS_BONES	39	/* rattles bones (skeleton) */
X#define MS_DEATH	40	/* \				*/
X#define MS_PESTILENCE	41	/*  |- astral level special monsters */
X#define MS_FAMINE	42	/* /				*/
X
X
X#define MR_FIRE         0x01    /* resists fire */
X#define MR_COLD         0x02    /* resists cold */
X#define MR_SLEEP        0x04    /* resists sleep */
X#define MR_DISINT       0x08    /* resists disintegration */
X#define MR_ELEC         0x10    /* resists electricity */
X#define MR_POISON       0x20    /* resists poison */
X#define MR_ACID         0x40    /* resists acid */
X#define MR_STONE        0x80    /* resists petrification */
X/* other resistances: magic, sickness */
X/* other conveyances: teleport, teleport control, telepathy */
X
X
X#define M1_FLY		0x00000001L	/* can fly or float */
X#define M1_SWIM		0x00000002L	/* can traverse water */
X#define M1_AMORPHOUS	0x00000004L	/* can flow under doors */
X#define M1_WALLWALK	0x00000008L	/* can phase thru rock */
X#define M1_CLING	0x00000010L	/* can cling to ceiling */
X#define M1_TUNNEL	0x00000020L	/* can tunnel thru rock */
X#define M1_NEEDPICK	0x00000040L	/* needs pick to tunnel */
X#define M1_CONCEAL	0x00000080L	/* hides under objects */
X#define M1_HIDE		0x00000100L	/* mimics, blends in with ceiling */
X#define M1_AMPHIBIOUS	0x00000200L	/* can survive underwater */
X#define M1_BREATHLESS	0x00000200L	/* doesn't need to breathe */
X#define M1_NOEYES	0x00001000L	/* no eyes to gaze into or blind */
X#define M1_NOHANDS	0x00002000L	/* no hands to handle things */
X#define M1_NOLIMBS	0x00006000L	/* no arms/legs to kick/wear on */
X#define M1_NOHEAD	0x00008000L	/* no head to behead */
X#define M1_MINDLESS	0x00010000L	/* has no mind--golem, zombie, mold */
X#define M1_HUMANOID	0x00020000L	/* has humanoid head/arms/torso */
X#define M1_ANIMAL	0x00040000L	/* has animal body */
X#define M1_SLITHY	0x00080000L	/* has serpent body */
X#define M1_UNSOLID	0x00100000L	/* has no solid or liquid body */
X#define M1_THICK_HIDE	0x00200000L	/* has thick hide or scales */
X#define M1_OVIPAROUS	0x00400000L	/* can lay eggs */
X#define M1_REGEN	0x00800000L	/* regenerates hit points */
X#define M1_SEE_INVIS	0x01000000L	/* can see invisible creatures */
X#define M1_TPORT	0x02000000L	/* can teleport */
X#define M1_TPORT_CNTRL	0x04000000L	/* controls where it teleports to */
X#define M1_ACID		0x08000000L	/* acidic to eat */
X#define M1_POIS		0x10000000L	/* poisonous to eat */
X#define M1_CARNIVORE	0x20000000L	/* eats corpses */
X#define M1_HERBIVORE	0x40000000L	/* eats fruits */
X#define M1_OMNIVORE	0x60000000L	/* eats both */
X#define M1_METALLIVORE	0x80000000L	/* eats metal */
X
X#define M2_NOPOLY	0x00000001L	/* players mayn't poly into one */
X#define M2_UNDEAD	0x00000002L	/* is walking dead */
X#define M2_WERE		0x00000004L	/* is a lycanthrope */
X#define M2_ELF		0x00000008L	/* is an elf */
X#define M2_DWARF	0x00000010L	/* is a dwarf */
X#define M2_GIANT	0x00000020L	/* is a giant */
X#define M2_ORC		0x00000040L	/* is an orc */
X#define M2_HUMAN	0x00000080L	/* is a human */
X#define M2_DEMON	0x00000100L	/* is a demon */
X#define M2_MERC		0x00000200L	/* is a guard or soldier */
X#define M2_LORD		0x00000400L	/* is a lord to its kind */
X#define M2_PRINCE	0x00000800L	/* is an overlord to its kind */
X#define M2_MINION	0x00001000L	/* is a minion of a deity */
X#define M2_MALE		0x00010000L	/* always male */
X#define M2_FEMALE	0x00020000L	/* always female */
X#define M2_NEUTER	0x00040000L	/* neither male nor female */
X#define M2_PNAME	0x00080000L	/* monster name is a proper name */
X#define M2_HOSTILE	0x00100000L	/* always starts hostile */
X#define M2_PEACEFUL	0x00200000L	/* always starts peaceful */
X#define M2_DOMESTIC	0x00400000L	/* can be tamed by feeding */
X#define M2_WANDER	0x00800000L	/* wanders randomly */
X#define M2_STALK	0x01000000L	/* follows you to other levels */
X#define M2_NASTY	0x02000000L	/* extra-nasty monster (more xp) */
X#define M2_STRONG	0x04000000L	/* strong (or big) monster */
X#define M2_ROCKTHROW	0x08000000L	/* throws boulders */
X#define M2_GREEDY	0x10000000L	/* likes gold */
X#define M2_JEWELS	0x20000000L	/* likes gems */
X#define M2_COLLECT	0x40000000L	/* picks up weapons and food */
X#define M2_MAGIC	0x80000000L	/* picks up magic items */
X
X#define M3_WANTSAMUL	0x01		/* would like to steal the amulet */
X#define M3_WANTSBELL	0x02		/* wants the bell */
X#define M3_WANTSBOOK	0x04		/* wants the book */
X#define M3_WANTSCAND	0x08		/* wants the candelabrum */
X#ifdef MULDGN
X#define M3_WANTSARTI	0x10		/* wants the quest artifact */
X#endif
X#define M3_WAITFORU	0x40		/* waits to see you or get attacked */
X#define M3_CLOSE	0x80		/* lets you close unless attacked */
X
X#define M3_COVETOUS	0x1f		/* wants something */
X#define M3_WAITMASK	0xc0		/* waiting... */
X
X#define MZ_TINY		0		/* < 2' */
X#define MZ_SMALL	1		/* 2-4' */
X#define MZ_MEDIUM	2		/* 4-7' */
X#define MZ_HUMAN	MZ_MEDIUM	/* human-sized */
X#define MZ_LARGE	3		/* 7-12' */
X#define MZ_HUGE		4		/* 12-25' */
X#define MZ_GIGANTIC	7		/* off the scale */
X
X#endif /* MONFLAG_H */
END_OF_FILE
if test 7000 -ne `wc -c <'include/monflag.h'`; then
    echo shar: \"'include/monflag.h'\" unpacked with wrong size!
fi
# end of 'include/monflag.h'
fi
if test -f 'src/explode.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/explode.c'\"
else
echo shar: Extracting \"'src/explode.c'\" \(6827 characters\)
sed "s/^X//" >'src/explode.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)explode.c 3.1	90/11/06
X/*	Copyright (C) 1990 by Ken Arromdee */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include "hack.h"
X
X/* Note: Arrays are column first, while the screen is row first */
Xstatic int expl[3][3] = 
X{ S_explode1, S_explode4, S_explode7,
X  S_explode2, S_explode5, S_explode8,
X  S_explode3, S_explode6, S_explode9 };
X
X/* Note: I had to choose one of three possible kinds of "type" when writing
X * this function: a wand type (like in zap.c), an adtyp, or an object type.
X * Wand types get complex because they must be converted to adtyps for
X * determining such things as fire resistance.  Adtyps get complex in that
X * they don't supply enough information--was it a player or a monster that
X * did it, and with a wand, spell, or breath weapon?  Object types share both
X * these disadvantages....
X */
Xvoid
Xexplode(x, y, type, dam, olet)
Xint x, y;
Xint type; /* the same as in zap.c */
Xint dam;
Xchar olet;
X{
X	int i, j, k;
X	boolean starting = 1;
X	boolean visible, any_shield;
X	int uhurt = 0; /* 0=unhurt, 1=items damaged, 2=you and items damaged */
X	const char *str;
X	int idamres, idamnonres;
X	struct monst *mtmp;
X	uchar adtyp;
X	int explmask[3][3];
X		/* 0=normal explosion, 1=do shieldeff, 2=do nothing */
X	boolean shopdamage = FALSE;
X
X	switch(abs(type) % 10) {
X		default: impossible("explosion base type %d?", type); return;
X
X		case 1: str = (olet == SCROLL_CLASS ? "tower of flame" : "fireball"); adtyp = AD_FIRE; break;
X		/* case 3: str = "ball of cold"; adtyp = AD_COLD; break; */
X		/* case 5: str = "ball lightning"; adtyp = AD_ELEC; break; */
X		/* case 7: str = "acid ball"; adtyp = AD_ACID; break; */
X	}
X
X	any_shield = visible = FALSE;
X	for(i=0; i<3; i++) for(j=0; j<3; j++) {
X		if (!isok(i+x-1, j+y-1)) {
X			explmask[i][j] = 2;
X			continue;
X		}
X		if (i+x-1 == u.ux && j+y-1 == u.uy) {
X		    switch(adtyp) {
X			case AD_FIRE:
X				explmask[i][j] = Fire_resistance ? 1 : 0;
X				break;
X			/* case AD_COLD: */
X			/* case AD_ELEC: */
X			/* case AD_DISN: */
X			/* case AD_ACID: */
X			default:
X				impossible("explosion type %d?", adtyp);
X				explmask[i][j] = 0;
X				break;
X		    }
X		}
X		/* can be both you and mtmp if you're swallowed */
X		if (mtmp = m_at(i+x-1, j+y-1)) {
X		    switch(adtyp) {
X			case AD_FIRE:
X				explmask[i][j] = resists_fire(mtmp->data)
X					? 1 : 0;
X				break;
X			/* case AD_COLD: */
X			/* case AD_ELEC: */
X			/* case AD_DISN: */
X			/* case AD_ACID: */
X			default:
X				impossible("explosion type %d?", adtyp);
X				explmask[i][j] = 0;
X				break;
X		    }
X		} else if (i+x-1 != u.ux || j+j-1 != u.uy)
X		    explmask[i][j] = 0;
X
X		if (cansee(i+x-1, j+y-1)) visible = TRUE;
X		if (explmask[i][j] == 1) any_shield = TRUE;
X	}
X
X	if (visible) {
X		/* Start the explosion */
X		for(i=0; i<3; i++) for(j=0; j<3; j++) {
X			if (explmask[i][j] == 2) continue;
X			tmp_at(starting ? DISP_BEAM : DISP_CHANGE,
X					    cmap_to_glyph(expl[i][j]));
X			tmp_at(i+x-1, j+y-1);
X			starting = 0;
X		}
X		curs_on_u();	/* will flush screen and output */
X
X		if (any_shield) {	/* simulate a shield effect */
X		    for (k = 0; k < SHIELD_COUNT; k++) {
X			for(i=0; i<3; i++) for(j=0; j<3; j++) {
X			    if (explmask[i][j] == 1)
X				/*
X				 * Bypass tmp_at() and send the shield glyphs
X				 * directly to the buffered screen.  tmp_at()
X				 * will clean up the location for us later.
X				 */
X				show_glyph(i+x-1, j+y-1,
X					cmap_to_glyph(shield_static[k]));
X			}
X			curs_on_u();	/* will flush screen and output */
X			delay_output();
X		    }
X
X		    /* Cover last shield glyph with blast symbol. */
X		    for(i=0; i<3; i++) for(j=0; j<3; j++) {
X			if (explmask[i][j] == 1)
X			    show_glyph(i+x-1,j+y-1,cmap_to_glyph(expl[i][j]));
X		    }
X
X		} else {		/* delay a little bit. */
X		    delay_output();
X		    delay_output();
X		}
X
X	} else You("hear a blast.");
X
X
X	for(i=0; i<3; i++) for(j=0; j<3; j++) {
X		if (explmask[i][j] == 2) continue;
X		if (i+x-1 == u.ux && j+y-1 == u.uy)
X			uhurt = (explmask[i][j] == 1) ? 1 : 2;
X		idamres = idamnonres = 0;
X		(void)zap_over_floor((xchar)(i+x-1), (xchar)(j+y-1),
X				     type, &shopdamage);
X
X		mtmp = m_at(i+x-1, j+y-1);
X		if (!mtmp) continue;
X		if (u.uswallow && mtmp == u.ustuck) {
X			if (is_animal(u.ustuck->data))
X				pline("%s gets heartburn!",
X				      Monnam(u.ustuck));
X			else
X				pline("%s gets toasted slightly!",
X				      Monnam(u.ustuck));
X		} else
X		pline("%s is caught in the %s!",
X			cansee(i+x-1, j+y-1) ? Monnam(mtmp) : "It", str);
X
X		idamres += destroy_mitem(mtmp, SCROLL_CLASS, (int) adtyp);
X		idamres += destroy_mitem(mtmp, SPBOOK_CLASS, (int) adtyp);
X		/* Fire resistance protects monsters from burning scrolls, */
X		/* but not from exploding potions. */
X		idamnonres += destroy_mitem(mtmp, POTION_CLASS, (int) adtyp);
X/*
X		idamnonres += destroy_mitem(mtmp, WAND_CLASS, (int) adtyp);
X		idamnonres += destroy_mitem(mtmp, RING_CLASS, (int) adtyp);
X*/
X		if (explmask[i][j] == 1) {
X			golemeffects(mtmp, (int) adtyp, dam + idamres);
X			mtmp->mhp -= idamnonres;
X		} else {
X		/* call resist with 0 and do damage manually so 1) we can
X		 * get out the message before doing the damage, and 2) we can
X		 * call mondied, not killed, if it's not your blast
X		 */
X			int mdam = dam;
X
X			if (resist(mtmp, olet, 0, FALSE)) {
X				pline("%s resists the magical blast!",
X					cansee(i+x-1,j+y-1) ? Monnam(mtmp)
X					: "It");
X				mdam = dam/2;
X			}
X			if (mtmp == u.ustuck)
X				mdam *= 2;
X			if (resists_cold(mtmp->data) /* && adtyp == AD_FIRE */)
X				mdam *= 2;
X			mtmp->mhp -= mdam;
X			mtmp->mhp -= (idamres + idamnonres);
X		}
X		if (mtmp->mhp <= 0) {
X			if (type >= 0) killed(mtmp);
X			else mondied(mtmp);
X		}
X	}
X
X	if (visible) tmp_at(DISP_END, 0); /* clear the explosion */
X
X	/* Do your injury last */
X	if (uhurt) {
X	        if (type >= 0 && flags.verbose && olet != SCROLL_CLASS)
X			You("are caught in the %s!", str);
X		if (uhurt == 2) u.uhp -= dam;
X		if (u.uhp <= 0) {
X			char buf[BUFSZ];
X
X			if (type >= 0 && olet != SCROLL_CLASS) {
X			    killer_format = NO_KILLER_PREFIX;
X			    Sprintf(buf, "caught %sself in %s own %s.",
X				flags.female ? "her" : "him",
X				flags.female ? "her" : "his", str);
X			} else {
X			    killer_format = KILLED_BY;
X			    Strcpy(buf, str);
X			}
X			killer = buf;
X			/* done(adtyp == AD_FIRE ? BURNING : DIED); */
X			done(BURNING);
X		}
X		exercise(A_STR, FALSE);
X#if defined(POLYSELF)
X		ugolemeffects((int) adtyp, dam);
X#endif
X		destroy_item(SCROLL_CLASS, (int) adtyp);
X		destroy_item(SPBOOK_CLASS, (int) adtyp);
X		destroy_item(POTION_CLASS, (int) adtyp);
X/*
X		destroy_item(RING_CLASS, (int) adtyp);
X		destroy_item(WAND_CLASS, (int) adtyp);
X*/
X	}
X	if (shopdamage) {
X		pay_for_damage("burn away");
X/* (only if we ever add non-fire balls)
X		pay_for_damage(adtyp == AD_FIRE ? "burn away" :
X			       adtyp == AD_COLD ? "shatter" :
X			       adtyp == AD_DISN ? "disintegrate" : "destroy");
X*/
X	}
X}
X
X/*explode.c*/
END_OF_FILE
if test 6827 -ne `wc -c <'src/explode.c'`; then
    echo shar: \"'src/explode.c'\" unpacked with wrong size!
fi
# end of 'src/explode.c'
fi
if test -f 'sys/atari/atarifnt.uue' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/atari/atarifnt.uue'\"
else
echo shar: Extracting \"'sys/atari/atarifnt.uue'\" \(7164 characters\)
sed "s/^X//" >'sys/atari/atarifnt.uue' <<'END_OF_FILE'
Xtable
X !"#$%&'()*+,-./0123456789:;<=>?
X@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_
Xbegin 644 hackfnt.arc
XM&@A(04-+1DY4+E!21P  E!,  #\48JO>BQ\=   ,8#0  #" S4 ,! ! &@!Bz
XM8 "#D!2 > .  !Q_P%!5= 'D!0(GN10.X('EB9,Z1L+0"<,&1!DY<M[(T0$By
XMC9LY=<R823,F31DW=$"T*=-&9IX&"@8B.<<#APF*($8L&[@!CY*0 #8 ,J-@x
XM!+^!"1=J?;$ I$-.)@" 6 . 0;1U "B\!< A"3P< TPPP,//&"$0*RI" K *w
XM  (1 PP$&MA0$B B@4HJ"401@#<0.:@BD@((#P%8A,18&0<(QPX$!ISL R( v
XM0%(/ %0 H ' !XH!V HC&$%L8,$1P32#,>*5L<@-B,#H(!<(N' 8XIH'SYK<u
XM!(@ Y  Y=DX=#(:KFME N X-*_(1P#2_ <,WF7E$(!(#<@@@K;7W(!9 &R0Bt
XM, '%__P##@"R -*&#2XL\<TP5@E1Q L#D/5# 3\0X$00WGS%0%J=./-"9ED1s
XM\B%5<(R8%1UF 2" -!FVA4<"*O @$@8O4&AA$%P\D18>3.CQSX057EA26DQ\r
XMPP$/)REU#@XPB$ 1!G0 0$(: &!033IT8:&$"0KPY1<)0XR@#%5_4<F"$A"<q
XMX00#$  0A!D\,( " %( $( 9-,@)P!$JFL&"GE809 8)>O90D1D<"*$)%H((p
XM\1T&9O C)HDD(,.H$I#R \9 B%1Z::9HFB&+HHQ*\Q4@$&2 !" R (!$,"!Lo
XMB<0;",#!#S"!4 -(-<!H.6E6<)#PE9V:0"$(& 1(D<04@3 0@5IG&. L  G@n
XM.9D;[(#APK0@G$'!M-5J  8#W$8+KAD(,*OLM>P(L0$8"*1J 3#1,GNM,T),m
XM8$< (PQ#%1UHGB%!I5*81\>GD8;JCA"2@"  %H 4R0 ')RW% P@\ZO " !H l
XM>>.0 !1) ))U+(4#""D*H,^.3/PP0)!!@"PRQ76  @!Z5/%1,5,HZ_(//"#Dk
XMD3,#:   P3_2<!4"'[[!\8\Z8(@0]-!%(X"TTDP#,('34"N !!XJ.N$S("5-j
XMG14>)LS)@#4:4< V708,0A\>,3@X(80P0Z%CR-^,G"0D)$00%@$8 ("#0CD i
XMH9 +/!B@4 E@R- J) ;$PX.,"_&PD$(&M E) 0B(=+E"&Q0."08%@,(T'ZM_h
XMKA !"\P)">$ , W)#6UN"HD&#F PX.P&% X&!U4"L"D&8.C$0&W"(P^ 3@ Xg
XM()(!LTNN4 %@Z#Z Y &(!(,>>IC1N4A;C)[Y["3$-E D(N%#EPT#F>] UAY(f
XM#PD"A1M^^.?^>,\ '_YP1_<,@P<<I$X7 M"!#@2!"USH8G-@ T #L%$EG?C e
XM#&S @ &2]SH#\  #// # _S  3^8KP!-P0 ?>( '/_CA@GXP #/ 8 PXK1 ?d
XM/O"#3FIH!C]X@#UM@H/Q . XZ7F' <#87^\P (/XF8$!/# ##. 711C R8H?c
XM!( )I<@#*RX$ QXP P8<P(#9@>\@C&G(0L!G*"UB@ E,>"(?],"Z+YAO).@#b
XM !5:PSX9@0,$/O!! $PH(S^X@7A?[%__%@*!IOC  Q#P0=; 8(#>#80-68,!a
XM#/#0/Q#B@ ,X\(<Q B C!P !"*DS!O4&8 Q@ ,,8FU,<$><$J1YB$ ,,L*+Iz
XM$N,'#+APA"'<7/0   X_K-"%?/##0GHH0QKV<"'\<.$.=>)#]ASN<)MR'&R.y
XMF$2%',!TP6/B0'182PP03R?E7(@? ( /=(K1# ?! 9P\@('9P1&-:@%!_N"Xx
XM3@ LDG 04(8QC%&%.VJ. .E306O6N4YPQ& ,-A@ (;7H!OAE;IW]4Q$$_- 2w
XM"&RTDW!P0 8P@ $!$"%K>$!"_GA  A;00!?^L,8 Q/@ .* 2%*I<2"M?N3DAv
XM N  T*C@/\# !AR8$P=97(@!S"#/B8$!#DL5HSG]  <SF$.'9G #&):I06R u
XMP1UFF-T,:\E#!B / X<C7C:+MRD  ,-TW^0<29OX/(4TX'+KI"#EHMA%='+Nt
XMCB,8@>D(8(;N84-S QA(0 4AB"@85)WPI,(9W+A.6&3 !S:XX.ATTBHSB,&Ss
XM @ #;(QI!F/ @'7@,$8O/UDZ#/@ DTH1Y_-(8(XS2((?DAC ,'B0@%,V !8Yr
XM9:4K83D /LC2!6V"U% 98-3,[9(!3'TB![(759+BP _R%$98";#5F7;UJW8(q
XMZP#&NL,HFA4&&# (%%?H@P]*$@<,8$9Z+\<'2>9PFCV<JQAJJ;D$X$"=?@"#p
XM'0Z[3,CZP8IB; I?S9##_)D@+9F+8@_\@ UE)M9HRM"%+J+P WX< !P!ZO _o
XMSA&;,_# #KX$ "8:D%D^F.$?//B'&5 ,@7O8PPQ@.+ \^R($8V# &M9X92]!n
XM6;K:X>!P'T ">@<R#!(,(AC6X(<N#! )'B  "#CXK2 2J -=-% 0&O9#!',Pm
XMH%KR 0-PJ.< _L'0MHC1K#S@P[A"2%(A<H !VNAA\ECGAEX: !Y@\$=X%\*,l
XM-)?W@TQ,;T5RF,S/P9<;&/"',@^ 7^RB51[(ZZ$/9M?H ?QWICC^@S<L'%8#k
XMP("</KBN+9>:/Q:P  ,:@$4.^_P/;XA7L<H0A2H T.$'P"/$_/B'OZA0#A]Hj
XMX;IM.8 -;! ,/\#X'W9H+P0RP0T<\R.]805 HXS! TE(XI5:=$":?:DX1B(!i
XM#$@82"#.\61CX ,'5+;R0#J BX'PP76L<]Q"#E=!!J-9S6S68I7<@$L0&A.*h
XM/B#I@,AH#3/(V>%\Z+,& 6T-'4+3J#JQ!@CK20!C#&2IR;/EF_$1Z;!BKY;6g
XM,"\\P.@+'H2<>MP5KYIUPH<-V/I^8(!!G&,(J85$6XP'68@-L+%4-YAA&S>_f
XM<$!%(0M>\^,#^ #V/XRF@EJ8 \8R(L !,#L(9\?8#@Y@:B80(6=4,*"&,!"$e
XM'VKH[;ZX$)0D]4-K%@*-K]'U'(&HK37TH0M&=(*%'N! #CBQ95SH8"$(U(4.d
XM*GD >,P( /\PM3>JM/$9H1B7;#! +\4W$#B0\,<Z3%[VT&D KU;<EOC@ ,KGc
XMJF:/UP;'[GSSRAL^NZ>B/(H86+D'.$&"D&\ZYE\$,!_VT$Z<^P-2KNVY1'5(b
XM5QC((+ULN* =W+"-"NM0)'H0A2X  '41_RC8 $ !%7HQ#QGS "/?R&P.GVV a
XMI>+@'8C ,0K.+L5&L8%AMU4M6E5?.!^()*B?0P+#X%*2( ^2P B!P /X  $2z
XMD >>H$K L$JJI$I^  $/X#Y?!'D&8 .31U))-0"ZA'FLQGF&8VG<$'HX%G+?y
XM90Q&YV+8T#LZX0\?A%YF)1(HN'DC]V/;!08?%(/(9U2' WO*A#T6IF8N! ;_x
XM4'P)<&IBM'F0)44N9'08@ TVH$-VX ??8'WPM! *H N[YFO>)V+#  $JP $[w
XMH 4]A!' L&S)Q'X>Q 9F4&U@@ (8@':-@@+X!VYHUCL+D348  770P),Q0&Zv
XM8 _6@ W#0%4<P %QX @0*($&H$I/] 'L<#VVQ R4)U55HDM6%$-2)#XD13QIu
XM!@P[J()F,$,L"'O,$#QP(H-G58/+!'O>@4X,@ TZ6'LP>'Y5-%< ( 0ZD3RUt
XM-SLSAV/8@ UAA0 'AGSOM!!&!V#3X S0)UX#9HR;PX6,]5/@$(;!1F)4@ 'Ss
XMX ;#\ _^  _P@%G!\&(QUGZ*=F-S" -H5T.J8 9 )F3($SRV*$L\($0!V$7,r
XM90[&@ 4O9C04T(B/J%.1N%0"@!"6Z&*8"$KP5#B9QD0B9T5+)#T#(@[BI56Fq
XMB(J_J :K""D\ %9G%3PB\8LXYDMO)E\U5'NL&)(AA%[B- PF&8R$$XM@4(PFp
XMAU5=I$+*.#O21$D&H $8,'3;A9/5.  *,%"BLSEX!4\J\ ]7%8Y\0(XV\ >#o
XM "<RTGY,X'%B(&<H0%1_  +)Y [&Q >IM4Y?I%<CHT8HE#]\X [N  <\T"8,n
XM& :&@$"&ET")IP.?%Q8#D#^%TS^YA$;(HTP$,$('9D(D-2,ZA$P!UIAKMW9Zm
XMQ@?ZUTLUY$L>8 !@TS]#Z%IPP@#.P ,U9&$YY@&6R6"])$YL!@D+@%C45&M#l
XMF$.]] ?IY4LAA%7M%6#2\GRQ9ICB2$TBH0"LLY2)A5CI0P4OY&S_P ?\P \Vk
XM, 8Y-#KMQP:NQP:;X@\XT 5&PP-L,)<;Y7%%B FO8SH-T$3[,P!!( BKLYZUj
XMLT)&XY> "0!V0$1M!9$\Z$)Q<CDZ9U2[!$(.QT(!%D4FI%HUY'(V8 QG]D&"i
XMT(29N9FU45]?M%1QPFT%6E]@P <.D' +JGF\"  \L&D*X)H])&J(%4@>]$'_h
XM@#QPT%X?"CT>2DD8\ /YTUZ\P M_H)/!>3V(Y:$+D5"7LPQLQIS\$$C)))T&g
XM<)Y@X'C]DQZ>,P#P$$G@^47Z* $-X3D1X &8XP!-! E:JA KT$^V@SWZ=@#Kf
XMU#L#TA:<LSR0L%'7 P2ZHWEH.0 ?D)"O PCSP:4[:IQZM$Z)4%<!8@,<D![Fe
XM<P#E1@#S83L#\#MQ!0DG< %4H! .H$:1ZJ4H=3V4Y$VV<Z2<LS\08#LID*>8d
XM8P"A T\!8ACS83Y"J1!PYH$C-D@D18ZIPP<&P#H(ZCIXT'B"4T'%8U3B=CT"c
XM\$$A!$P3143&<SDJ!* O!"<@5Z%Q%D*5Y@% @ =-NE9J15)@H$2]HX\S9592b
XM!)&?&)'+(Z/=ZD5_R0&(X@%E1  T0!N?HY0;@ WKVAH \ <PL*Y/! !ZX$)Ya
XM\%@(]3K^ DTS@$@C@3D#(#WP1#S^)#H#<6>U(2-,M#R+>60#<601Q%*@E G"z
XMIEL\$*C D$H2Z$J1Z'%@<(&Q4T'1=TL.N4ON)UW4A4ZX!  (%D48U%UB9 #6y
XMZ0Z#5@!DI1/!XQV'DQYKU41MY1W>!$YJYAT.^Y"%\Y#/0U>%@P</"71?I -Fx
XM8 /H-3M8@ 7&.A#,(%\VP 99RP.M88M96R4!-0S#\ +\FE "D$,(("/PL '+w
XM-@,3Y0<VL $U!@ VT#]F !M5<CDV@ $04%6]M!!+) .P!0!LP 8,P+<D8 ]Ov
XM, S^D D&, T\8 '^\ T>JU,@.U L1(D35$'^0%3--1+/17#!$V?C@D[JI$%&u
XM)XM<I9F!9G'<15;FE6@&P8/L%6?OA7SLL$+U55]8Q4.%.P"8MH4C$3\>.IZ^t
XM1&&6R%<ZYW"<LU0B48R*"S_/$T(4M+PP@ /*T N]\*D$BU@CID<G, Z(LD[<s
XM\ !WX /,@)7/8P--D0GA90;^T+ULL$5F4$ /IT6Y5&1,(+$/D$'\-@SL%@SGr
XMP \\P B6"P'8L V_96_X)JO>\1^TI+@?)$0D%7#KA $H1BZ9EZ#^![-MP0!Jq
XMX'![%G%^!@=@<'HNMD*K]T&SXW$P '(Z@6 DE4'^8'*S6%KF18.>0 /)<SDGp
XMRH-P\FF7 P8VYYJ?<Z$JM)]1Y&(7Y%I\L&Q3N &7XP;4YPTD!4\8%@JEP'WXo
XMX&M2![,J4 =[\ ]5" #&\ >8I47/9@?FR@;4Q@=BD$&+"RDZQ U4<'K%6SIHn
XM23AL  /+ P#G, Q/-@SYD D/7('>\ ^_59"L=) NA!! 53R9!P,=6'D+$8*:m
XMMU16%#R;0U)])HLJ*+NI*&"95TNN2(.[=$')<V NBP>WR%T]*(_(-SL,0 /4l
XM9  ^T'XY%GR@Q@=_4'P(D'-5Q(H^=\.$O 8$QP8VL%1V8 =9>#E># %Z$ HAk
XMX6M05\9(0 7=@+[R.XYKZ -TRW[090SO@ PX-LAY+%[,T,<<]+!3" "M4B78j
XM@$D1)(B0FPGS, QP,(9IY@$9@ F2/(&L!@$$@%PBX0\,21?R)$X1:470]8EFi
XMA4L'9CSB99VF:)T\1%3N%))BY!TD:9,X!@-37)LKR5TMR5Y7FUAB$$4YUD,Fh
XMU%U&&&!&60 7=$60<FK*YP;ME7,,, P:][46AQO4J'0*T NM0)P>&F/G  ,Jg
XMX%I^, ;+R0_E> ?O*YU0M*!R"(=Y'$4DP XX8 V$.R.VR 0'H8\%0 (;BU3Gf
XM< X@, PXL'(;X("RFF]ZO4(>@*5DALD88 3SV:LDC % <)OYV45- ;..XQT7e
XMM$(M! ::): %"@8V "?)=YD^)  .*DD?VD42"I(5Z@,7FJ'8IGG9JD4(T%Z_d
XM][:40TU86**__*&^I$*2?3D[/1!2Q "&\ D8\*[MI4XW>GU<B+9.K:?("0##c
XM\ ?+^0_."3\3)2W;:P=RQ@;829O^B0>G=4%:)*6#M:5M68T$4(%MU8BJZJC[b
XMTP"ZHP-9P]:7"@D'X(<BL3\EW:GXI#L'L*, \  E30"GI-MP$IPN=-P]JKS+a
XM-!!3A[!WI*U@@ _IYE:-)!)@X#DEO0!DH -<< 9N4 =<P 9S5P!G, 9C\ 5Cz
XM\ 9M  <?_@5?, <K(0=T$ -S-S)?  =A( =S4 8U/G<#$ "<\ 4U?@;SN1#=y
XM(Q9PX.-R$.(B,>0#L %T@ 9A, 9KD%5TX (Z+@"X$.(C7N(G7N6XH.)B$ 8Wx
XM3A]B@0<JW@9A8!,#4>72\ 4+P1(V409*O@%\H.)E@ =I$"4J(A)63N)OP 9Rw
XM\ 5D$ 9^N35L/@!$4 1&$ 15$.> H.)H@.-P\.5^61 JSN(U'B4I7A1N\ : v
XM+N@B,0!%7@9T4.=XKN.4_A-VD 8QX09Q3@B53@=K, =IH =QC@A?\!)RL.EBu
XMON2,<.MV'B4+P>5?8.9H'NQZK@]?8!-WKN=Z#@^W'N@K 1;'$>IN0 :O$^>#t
XM(1(0$,T,@  Z@ +2H@ *X  (H  &H  0( .KQ !"8*)6P  ZP $0X #C3@$ s
X# !H r
X q
Xend
END_OF_FILE
if test 7164 -ne `wc -c <'sys/atari/atarifnt.uue'`; then
    echo shar: \"'sys/atari/atarifnt.uue'\" unpacked with wrong size!
fi
# end of 'sys/atari/atarifnt.uue'
fi
if test -f 'sys/atari/tos.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/atari/tos.c'\"
else
echo shar: Extracting \"'sys/atari/tos.c'\" \(6913 characters\)
sed "s/^X//" >'sys/atari/tos.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)tos.c	3.1	90/14/08
X/* NetHack may be freely redistributed.  See license for details. */
X
X/*
X *  TOS system functions.
X */
X
X#define NEED_VARARGS
X#include "hack.h"
X#include "termcap.h"
X
X#ifdef TOS
X
X# include <osbind.h>
X# ifndef WORD
X#  define WORD short		/* 16 bits -- redefine if necessary */
X# endif
X
X#include <ctype.h>
X
Xstatic char NDECL(DOSgetch);
Xstatic char NDECL(BIOSgetch);
Xstatic void NDECL(init_aline);
Xchar *_a_line;			/* for Line A variables */
X# ifdef TEXTCOLOR
Xboolean colors_changed = FALSE;
X# endif
X
Xint
Xtgetch()
X{
X	char ch;
X
X	/* BIOSgetch can use the numeric key pad on IBM compatibles. */
X	if (flags.BIOS)
X		ch = BIOSgetch();
X	else
X		ch = DOSgetch();
X	return ((ch == '\r') ? '\n' : ch);
X}
X
X/*
X *  Keyboard translation tables.
X */
X#define KEYPADLO	0x61
X#define KEYPADHI	0x71
X
X#define PADKEYS 	(KEYPADHI - KEYPADLO + 1)
X#define iskeypad(x)	(KEYPADLO <= (x) && (x) <= KEYPADHI)
X
X/*
X * Keypad keys are translated to the normal values below.
X * When flags.BIOS is active, shifted keypad keys are translated to the
X *    shift values below.
X */
Xstatic const struct pad {
X	char normal, shift, cntrl;
X} keypad[PADKEYS] = {
X			{C('['), 'Q', C('[')},		/* UNDO */
X			{'?', '/', '?'},		/* HELP */
X			{'(', 'a', '('},		/* ( */
X			{')', 'w', ')'},		/* ) */
X			{'/', '/', '/'},		/* / */
X			{C('p'), '$', C('p')},		/* * */
X			{'y', 'Y', C('y')},		/* 7 */
X			{'k', 'K', C('k')},		/* 8 */
X			{'u', 'U', C('u')},		/* 9 */
X			{'h', 'H', C('h')},		/* 4 */
X			{'.', '.', '.'},
X			{'l', 'L', C('l')},		/* 6 */
X			{'b', 'B', C('b')},		/* 1 */
X			{'j', 'J', C('j')},		/* 2 */
X			{'n', 'N', C('n')},		/* 3 */
X			{'i', 'I', C('i')},		/* Ins */
X			{'.', ':', ':'}			/* Del */
X}, numpad[PADKEYS] = {
X			{C('['), 'Q', C('[')}	,	/* UNDO */
X			{'?', '/', '?'},		/* HELP */
X			{'(', 'a', '('},		/* ( */
X			{')', 'w', ')'},		/* ) */
X			{'/', '/', '/'},		/* / */
X			{C('p'), '$', C('p')},		/* * */
X			{'7', M('7'), '7'},		/* 7 */
X			{'8', M('8'), '8'},		/* 8 */
X			{'9', M('9'), '9'},		/* 9 */
X			{'4', M('4'), '4'},		/* 4 */
X			{'.', '.', '.'},		/* 5 */
X			{'6', M('6'), '6'},		/* 6 */
X			{'1', M('1'), '1'},		/* 1 */
X			{'2', M('2'), '2'},		/* 2 */
X			{'3', M('3'), '3'},		/* 3 */
X			{'i', 'I', C('i')},		/* Ins */
X			{'.', ':', ':'}			/* Del */
X};
X
X/*
X * Unlike Ctrl-letter, the Alt-letter keystrokes have no specific ASCII
X * meaning unless assigned one by a keyboard conversion table, so the
X * keyboard BIOS normally does not return a character code when Alt-letter
X * is pressed.	So, to interpret unassigned Alt-letters, we must use a
X * scan code table to translate the scan code into a letter, then set the
X * "meta" bit for it.  -3.
X */
X#define SCANLO		0x10
X#define SCANHI		0x32
X#define SCANKEYS	(SCANHI - SCANLO + 1)
X#define inmap(x)	(SCANLO <= (x) && (x) <= SCANHI)
X
Xstatic const char scanmap[SCANKEYS] = { 	/* ... */
X	'q','w','e','r','t','y','u','i','o','p','[',']', '\n',
X	0, 'a','s','d','f','g','h','j','k','l',';','\'', '`',
X	0, '\\', 'z','x','c','v','b','N','m' 	/* ... */
X};
X
X/*
X * BIOSgetch gets keys directly with a BIOS call.
X */
X#define SHIFT		(0x1 | 0x2)
X#define CTRL		0x4
X#define ALT		0x8
X
Xstatic char
XBIOSgetch()
X{
X	unsigned char scan, shift, ch;
X	const struct pad *kpad;
X
X	long  x;
X
X	/* Get scan code.
X	 */
X	x = Crawcin();
X	ch = x & 0x0ff;
X	scan = (x & 0x00ff0000L) >> 16;
X	/* Get shift status.
X	 */
X	shift = Kbshift(-1);
X
X	/* Translate keypad keys */
X	if (iskeypad(scan)) {
X		kpad = flags.num_pad ? numpad : keypad;
X		if (shift & SHIFT)
X			ch = kpad[scan - KEYPADLO].shift;
X		else if (shift & CTRL)
X			ch = kpad[scan - KEYPADLO].cntrl;
X		else
X			ch = kpad[scan - KEYPADLO].normal;
X	}
X	/* Translate unassigned Alt-letters */
X	if ((shift & ALT) && !ch) {
X		if (inmap(scan))
X			ch = scanmap[scan - SCANLO];
X		return (isprint(ch) ? M(ch) : ch);
X	}
X	return ch;
X}
X
Xstatic char
XDOSgetch()
X{
X	return (Crawcin() & 0x007f);
X}
X
X
Xlong
Xfreediskspace(path)
Xchar *path;
X{
X	int drive = 0;
X	struct {
X		long freal; /*free allocation units*/
X		long total; /*total number of allocation units*/
X		long bps;   /*bytes per sector*/
X		long pspal; /*physical sectors per allocation unit*/
X	} freespace;
X	if (path[0] && path[1] == ':')
X		drive = (toupper(path[0]) - 'A') + 1;
X	if (Dfree(&freespace,drive)<0) return -1;
X	return freespace.freal*freespace.bps*freespace.pspal;
X}
X
X/*
X * Functions to get filenames using wildcards
X */
Xint
Xfindfirst(path)
Xchar *path;
X{
X	return (Fsfirst(path, 0) == 0);
X}
X
Xint
Xfindnext()
X{
X	return (Fsnext() == 0);
X}
X
Xchar *
Xfoundfile_buffer()
X{
X	return (char *)Fgetdta() + 30;
X}
X
Xlong
Xfilesize(file)
Xchar *file;
X{
X	if (findfirst(file))
X		return  (* (long *) ((char *)Fgetdta() + 26));
X	else
X		return -1L;
X}
X
X/*
X * Chdrive() changes the default drive.
X */
Xvoid
Xchdrive(str)
Xchar *str;
X{
X	char *ptr;
X	char drive;
X
X	if ((ptr = index(str, ':')) != NULL) {
X		drive = toupper(*(ptr - 1));
X		(void)Dsetdrv(drive - 'A');
X	}
X	return;
X}
X
X
Xvoid
Xget_scr_size()
X{
X	init_aline();
X	LI = (*((WORD  *)(_a_line + -42L))) + 1;
X	CO = (*((WORD  *)(_a_line + -44L))) + 1;
X}
X
X# define BIGBUF  8192
X
Xint
X_copyfile(from, to)
Xchar *from, *to;
X{
X	int fromfd, tofd, r;
X	char *buf;
X
X	if ((fromfd = open(from, O_RDONLY|O_BINARY, 0)) < 0)
X		return -1;
X	if ((tofd = open(to, O_WRONLY|O_CREAT|O_TRUNC|O_BINARY, FCMASK)) < 0)
X		return -1;
X	buf = (char *)alloc((size_t)BIGBUF);
X	while ( (r = read(fromfd, buf, BIGBUF)) > 0)
X		write(tofd, buf, r);
X	close(fromfd);
X	close(tofd);
X	free(buf);
X	return 0;	/* successful */
X}
X
Xint kbhit()
X{
X	return Cconis();
X}
X
Xstatic void
Xinit_aline()
X{
X# ifdef __GNUC__
X/* line A calls nuke registers d0-d2,a0-a2; not all compilers regard these
X   as scratch registers, though, so we save them
X */
X	asm(" moveml d0-d2/a0-a2, sp@-");
X	asm(" .word 0xa000; movel d0, __a_line");
X	asm(" moveml sp@+, d0-d2/a0-a2");
X# else
X	asm(" movem.l d0-d2/a0-a2, -(sp)");
X	asm(" .dc.w 0xa000");	/* tweak as necessary for your compiler */
X	asm(" move.l d0, __a_line");
X	asm(" movem.l (sp)+, d0-d2/a0-a2");
X# endif
X}
X
X# ifdef TEXTCOLOR
X/* used in termcap.c to decide how to set up the hilites */
Xunsigned long tos_numcolors = 2;
X
Xvoid
Xset_colors()
X{
X	if (!flags.BIOS)
X		return;
X	init_aline();
X	tos_numcolors = 1 << (((unsigned char *) _a_line)[1]);
X	if (tos_numcolors <= 2) {			/* mono */
X		flags.use_color = FALSE;
X		return;
X	} else {
X		colors_changed = TRUE;
X	}
X}
X
Xvoid
Xrestore_colors()
X{
X	colors_changed = FALSE;
X}
X# endif /* TEXTCOLOR */
X
X# ifdef SUSPEND
X
X#include	<signal.h>
X
X#   ifdef MINT
Xextern int __mint;
X#   endif
X
Xint
Xdosuspend() {
X#   ifdef MINT
X	extern int kill();
X	if (__mint == 0) {
X#   endif
X		pline("Sorry, it seems we have no SIGTSTP here.  Try ! or S.");
X#   ifdef MINT
X	}
X	else if(signal(SIGTSTP, SIG_IGN) == SIG_DFL) {
X		suspend_nhwindows(NULL);
X		(void) signal(SIGTSTP, SIG_DFL);
X		(void) kill(0, SIGTSTP);
X		get_scr_size();
X		resume_nhwindows();
X	} else {
X		pline("I don't think your shell has job control.");
X	}
X#   endif /* MINT */
X	return(0);
X}
X# endif /* SUSPEND */
X
X#endif /* TOS */
END_OF_FILE
if test 6913 -ne `wc -c <'sys/atari/tos.c'`; then
    echo shar: \"'sys/atari/tos.c'\" unpacked with wrong size!
fi
# end of 'sys/atari/tos.c'
fi
if test -f 'sys/msdos/Makefile.dat' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/msdos/Makefile.dat'\"
else
echo shar: Extracting \"'sys/msdos/Makefile.dat'\" \(3965 characters\)
sed "s/^X//" >'sys/msdos/Makefile.dat' <<'END_OF_FILE'
X#	SCCS Id: @(#)Makefile.dat  3.1   93/01/18
X#	Copyright (c) NetHack PC Development Team 1992, 1993.
X#	NetHack may be freely redistributed.  See license for details.
X#
X# PC NetHack 3.1 Data Files Makefile for NDMAKE and MSC >= 6.0ax
X# or DGJPP 1.9.
X
XDAT	= ..\dat
XINCL	= ..\include
XUTL	= ..\util
X
Xdefault: all
X
Xall:	$(DAT)\data	    $(DAT)\rumors	$(DAT)\dungeon \
X	$(DAT)\oracles	    $(DAT)\quest.dat	$(DAT)\sp_lev.tag
X
X$(UTL)\utility.tag: $(UTL)\*.c $(UTL)\*.l $(UTL)\*.y $(INCL)\*.h
X	@echo You must "make all" in $(UTL) first.
X	@attrib .foo
X
X$(DAT)\data: 	$(UTL)\utility.tag    $(DAT)\data.base
X	$(UTL)\makedefs -d
X
X$(DAT)\rumors:	$(UTL)\utility.tag    $(DAT)\rumors.tru   $(DAT)\rumors.fal
X	$(UTL)\makedefs -r
X
X$(DAT)\quest.dat: $(UTL)\utility.tag  $(DAT)\quest.txt
X	$(UTL)\makedefs -q
X
X$(DAT)\oracles:	$(UTL)\utility.tag    $(DAT)\oracles.txt
X	$(UTL)\makedefs -h
X
X#
X# Note: `options` should be created via date.h target in ..\src\makefile
X#
X$(DAT)\options: $(UTL)\utility.tag    $(INCL)\config.h    $(INCL)\pcconf.h
X	$(UTL)\makedefs -v
X
X$(DAT)\sp_lev.tag: $(UTL)\utility.tag $(DAT)\bigroom.des  $(DAT)\castle.des \
X	$(DAT)\endgame.des $(DAT)\gehennom.des $(DAT)\knox.des   \
X	$(DAT)\medusa.des  $(DAT)\oracle.des   $(DAT)\tower.des  \
X	$(DAT)\yendor.des  $(DAT)\arch.des     $(DAT)\barb.des   \
X	$(DAT)\caveman.des $(DAT)\elf.des      $(DAT)\healer.des \
X	$(DAT)\knight.des  $(DAT)\priest.des   $(DAT)\rogue.des  \
X	$(DAT)\samurai.des $(DAT)\tourist.des  $(DAT)\valkyrie.des \
X	$(DAT)\wizard.des
X	$(UTL)\lev_comp $(DAT)\bigroom.des
X	$(UTL)\lev_comp $(DAT)\castle.des
X	$(UTL)\lev_comp $(DAT)\endgame.des
X	$(UTL)\lev_comp $(DAT)\gehennom.des
X	$(UTL)\lev_comp $(DAT)\knox.des
X	$(UTL)\lev_comp $(DAT)\mines.des
X	$(UTL)\lev_comp $(DAT)\medusa.des
X	$(UTL)\lev_comp $(DAT)\oracle.des
X	$(UTL)\lev_comp $(DAT)\tower.des
X	$(UTL)\lev_comp $(DAT)\yendor.des
X	$(UTL)\lev_comp $(DAT)\arch.des
X	$(UTL)\lev_comp $(DAT)\barb.des
X	$(UTL)\lev_comp $(DAT)\caveman.des
X	$(UTL)\lev_comp $(DAT)\elf.des
X	$(UTL)\lev_comp $(DAT)\healer.des
X	$(UTL)\lev_comp $(DAT)\knight.des
X	$(UTL)\lev_comp $(DAT)\priest.des
X	$(UTL)\lev_comp $(DAT)\rogue.des
X	$(UTL)\lev_comp $(DAT)\samurai.des
X	$(UTL)\lev_comp $(DAT)\tourist.des
X	$(UTL)\lev_comp $(DAT)\valkyrie.des
X	$(UTL)\lev_comp $(DAT)\wizard.des
X	echo sp_levs done > $(DAT)\sp_lev.tag
X
X$(DAT)\dungeon:	$(UTL)\utility.tag  $(DAT)\dungeon.def
X	$(UTL)\makedefs -e
X	$(UTL)\dgn_comp $(DAT)\dungeon.pdf
X
Xclean: spotless
X
Xspotless:
X	if exist $(DAT)\?-fill?.lev	del $(DAT)\?-fill?.lev
X	if exist $(DAT)\?-goal.lev	del $(DAT)\?-goal.lev
X	if exist $(DAT)\?-locate.lev	del $(DAT)\?-locate
X	if exist $(DAT)\?-start.lev	del $(DAT)\?-start.lev
X	if exist $(DAT)\air.lev		del $(DAT)\air.lev
X	if exist $(DAT)\asmodeus.lev	del $(DAT)\asmodeus.lev
X	if exist $(DAT)\astral.lev	del $(DAT)\astral.lev
X	if exist $(DAT)\baalz.lev	del $(DAT)\baalz.lev
X	if exist $(DAT)\bigroom.lev	del $(DAT)\bigroom.lev
X	if exist $(DAT)\castle.lev	del $(DAT)\castle.lev
X	if exist $(DAT)\data		del $(DAT)\data
X	if exist $(DAT)\dungeon		del $(DAT)\dungeon
X	if exist $(DAT)\dungeon.pdf	del $(DAT)\dungeon.pdf
X	if exist $(DAT)\earth.lev	del $(DAT)\earth.lev
X	if exist $(DAT)\fakewiz?.lev	del $(DAT)\fakewiz?.lev
X	if exist $(DAT)\fire.lev	del $(DAT)\fire.lev
X	if exist $(DAT)\juiblex.lev	del $(DAT)\juiblex.lev
X	if exist $(DAT)\medusa-?.lev	del $(DAT)\medusa-?.lev
X	if exist $(DAT)\mine*.lev	del $(DAT)\mine*.lev
X	if exist $(DAT)\options		del $(DAT)\options
X	if exist $(DAT)\oracle.lev	del $(DAT)\oracle.lev
X	if exist $(DAT)\oracles		del $(DAT)\oracles
X	if exist $(DAT)\orcus.lev	del $(DAT)\orcus.lev
X	if exist $(DAT)\rumors		del $(DAT)\rumors
X	if exist $(DAT)\quest.dat	del $(DAT)\quest.dat
X	if exist $(DAT)\sanctum.lev	del $(DAT)\sanctum.lev
X	if exist $(DAT)\tower?.lev	del $(DAT)\tower?.lev
X	if exist $(DAT)\valley.lev	del $(DAT)\valley.lev
X	if exist $(DAT)\water.lev	del $(DAT)\water.lev
X	if exist $(DAT)\wizard?.lev	del $(DAT)\wizard?.lev
X	if exist $(DAT)\sp_lev.tag	del $(DAT)\sp_lev.tag
END_OF_FILE
if test 3965 -ne `wc -c <'sys/msdos/Makefile.dat'`; then
    echo shar: \"'sys/msdos/Makefile.dat'\" unpacked with wrong size!
fi
# end of 'sys/msdos/Makefile.dat'
fi
if test -f 'sys/os2/os2.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/os2/os2.c'\"
else
echo shar: Extracting \"'sys/os2/os2.c'\" \(6879 characters\)
sed "s/^X//" >'sys/os2/os2.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)os2.c	3.1	93/01/18 */
X/*	Copyright (c) Timo Hakulinen, 1990, 1991, 1992, 1993. */
X/*	NetHack may be freely redistributed.  See license for details. */
X
X/*
X *  OS/2 system functions.
X */
X
X#define NEED_VARARGS
X#include "hack.h"
X
X#ifdef OS2
X
X#include "termcap.h"
X
X/* OS/2 system definitions */
X
X#include "def_os2.h"
X
X#include <ctype.h>
X
Xstatic char NDECL(DOSgetch);
Xstatic char NDECL(BIOSgetch);
X
Xint
Xtgetch()
X{
X	char ch;
X
X	/* BIOSgetch can use the numeric key pad on IBM compatibles. */
X	if (flags.BIOS)
X		ch = BIOSgetch();
X	else
X		ch = DOSgetch();
X	return ((ch == '\r') ? '\n' : ch);
X}
X
X/*
X *  Keyboard translation tables.
X */
X#define KEYPADLO	0x47
X#define KEYPADHI	0x53
X
X#define PADKEYS 	(KEYPADHI - KEYPADLO + 1)
X#define iskeypad(x)	(KEYPADLO <= (x) && (x) <= KEYPADHI)
X
X/*
X * Keypad keys are translated to the normal values below.
X * When flags.BIOS is active, shifted keypad keys are translated to the
X *    shift values below.
X */
Xstatic const struct pad {
X	char normal, shift, cntrl;
X} keypad[PADKEYS] = {
X			{'y', 'Y', C('y')},		/* 7 */
X			{'k', 'K', C('k')},		/* 8 */
X			{'u', 'U', C('u')},		/* 9 */
X			{'m', C('p'), C('p')},		/* - */
X			{'h', 'H', C('h')},		/* 4 */
X			{'g', 'g', 'g'},		/* 5 */
X			{'l', 'L', C('l')},		/* 6 */
X			{'p', 'P', C('p')},		/* + */
X			{'b', 'B', C('b')},		/* 1 */
X			{'j', 'J', C('j')},		/* 2 */
X			{'n', 'N', C('n')},		/* 3 */
X			{'i', 'I', C('i')},		/* Ins */
X			{'.', ':', ':'}			/* Del */
X}, numpad[PADKEYS] = {
X			{'7', M('7'), '7'},		/* 7 */
X			{'8', M('8'), '8'},		/* 8 */
X			{'9', M('9'), '9'},		/* 9 */
X			{'m', C('p'), C('p')},		/* - */
X			{'4', M('4'), '4'},		/* 4 */
X			{'g', 'G', 'g'},		/* 5 */
X			{'6', M('6'), '6'},		/* 6 */
X			{'p', 'P', C('p')},		/* + */
X			{'1', M('1'), '1'},		/* 1 */
X			{'2', M('2'), '2'},		/* 2 */
X			{'3', M('3'), '3'},		/* 3 */
X			{'i', 'I', C('i')},		/* Ins */
X			{'.', ':', ':'}			/* Del */
X};
X
X/*
X * Unlike Ctrl-letter, the Alt-letter keystrokes have no specific ASCII
X * meaning unless assigned one by a keyboard conversion table, so the
X * keyboard BIOS normally does not return a character code when Alt-letter
X * is pressed.	So, to interpret unassigned Alt-letters, we must use a
X * scan code table to translate the scan code into a letter, then set the
X * "meta" bit for it.  -3.
X */
X#define SCANLO		0x10
X#define SCANHI		0x32
X#define SCANKEYS	(SCANHI - SCANLO + 1)
X#define inmap(x)	(SCANLO <= (x) && (x) <= SCANHI)
X
Xstatic const char scanmap[SCANKEYS] = { 	/* ... */
X	'q','w','e','r','t','y','u','i','o','p','[',']', '\n',
X	0, 'a','s','d','f','g','h','j','k','l',';','\'', '`',
X	0, '\\', 'z','x','c','v','b','N','m' 	/* ... */
X};
X
X/*
X * BIOSgetch emulates the MSDOS way of getting keys directly with a BIOS call.
X */
X#define SHIFT_KEY	(0x1 | 0x2)
X#define CTRL_KEY	0x4
X#define ALT_KEY		0x8
X
Xstatic char
XBIOSgetch()
X{
X	unsigned char scan, shift, ch;
X	const struct pad *kpad;
X
X	KBDKEYINFO CharData;
X	USHORT IOWait = 0;
X	HKBD KbdHandle = 0;
X
X	KbdCharIn(&CharData,IOWait,KbdHandle);
X	ch = CharData.chChar;
X	scan = CharData.chScan;
X	shift = CharData.fsState;
X
X	/* Translate keypad keys */
X	if (iskeypad(scan)) {
X		kpad = flags.num_pad ? numpad : keypad;
X		if (shift & SHIFT_KEY)
X			ch = kpad[scan - KEYPADLO].shift;
X		else if (shift & CTRL_KEY)
X			ch = kpad[scan - KEYPADLO].cntrl;
X		else
X			ch = kpad[scan - KEYPADLO].normal;
X	}
X	/* Translate unassigned Alt-letters */
X	if ((shift & ALT_KEY) && !ch) {
X		if (inmap(scan))
X			ch = scanmap[scan - SCANLO];
X		return (isprint(ch) ? M(ch) : ch);
X	}
X	return ch;
X}
X
Xstatic char
XDOSgetch()
X{
X	KBDKEYINFO CharData;
X	USHORT IOWait = 0;
X	HKBD KbdHandle = 0;
X
X	KbdCharIn(&CharData,IOWait,KbdHandle);
X	if (CharData.chChar == 0) {	/* an extended code -- not yet supported */
X		KbdCharIn(&CharData,IOWait,KbdHandle);	   /* eat the next character */
X		CharData.chChar = 0;		/* and return a 0 */
X	}
X	return (CharData.chChar);
X}
X
Xchar
Xswitchar()
X{
X	return '/';
X}
X
Xint
Xkbhit()
X{
X	KBDKEYINFO CharData;
X	HKBD KbdHandle = 0;
X
X	KbdPeek(&CharData,KbdHandle);
X	return (CharData.fbStatus & (1 << 6));
X}
X
Xlong
Xfreediskspace(path)
Xchar *path;
X{
X	FSALLOCATE FSInfoBuf;
X#ifdef OS2_32BITAPI
X	ULONG
X#else
X	USHORT
X#endif
X		DriveNumber, FSInfoLevel = 1, res;
X
X	if (path[0] && path[1] == ':')
X		DriveNumber = (toupper(path[0]) - 'A') + 1;
X	else
X		DriveNumber = 0;
X	res =
X#ifdef OS2_32BITAPI
X		DosQueryFSInfo(DriveNumber,FSInfoLevel,(PVOID)&FSInfoBuf,(ULONG)sizeof(FSInfoBuf));
X#else
X		DosQFSInfo(DriveNumber,FSInfoLevel,(PBYTE)&FSInfoBuf,(USHORT)sizeof(FSInfoBuf));
X#endif
X	if (res)
X		return -1L;		/* error */
X	else
X		return ((long) FSInfoBuf.cSectorUnit * FSInfoBuf.cUnitAvail *
X			       FSInfoBuf.cbSector);
X}
X
X/*
X * Functions to get filenames using wildcards
X */
X
X#ifdef OS2_32BITAPI
Xstatic FILEFINDBUF3 ResultBuf;
X#else
Xstatic FILEFINDBUF ResultBuf;
X#endif
Xstatic HDIR DirHandle;
X
Xint
Xfindfirst(path)
Xchar *path;
X{
X#ifdef OS2_32BITAPI
X	ULONG
X#else
X	USHORT
X#endif
X		res, SearchCount = 1;
X
X	DirHandle = 1;
X	res =
X#ifdef OS2_32BITAPI
X		DosFindFirst((PSZ)path,&DirHandle,0L,(PVOID)&ResultBuf,(ULONG)sizeof(ResultBuf),&SearchCount,1L);
X#else
X		DosFindFirst((PSZ)path,&DirHandle,0,&ResultBuf,(USHORT)sizeof(ResultBuf),&SearchCount,0L);
X#endif
X	return(!res);
X}
X
Xint
Xfindnext()
X{
X#ifdef OS2_32BITAPI
X	ULONG
X#else
X	USHORT
X#endif
X		res, SearchCount = 1;
X
X	res =
X#ifdef OS2_32BITAPI
X		DosFindNext(DirHandle,(PVOID)&ResultBuf,(ULONG)sizeof(ResultBuf),&SearchCount);
X#else
X		DosFindNext(DirHandle,&ResultBuf,(USHORT)sizeof(ResultBuf),&SearchCount);
X#endif
X	return(!res);
X}
X
Xchar *
Xfoundfile_buffer()
X{
X	return(ResultBuf.achName);
X}
X
Xlong
Xfilesize(file)
Xchar *file;
X{
X	if (findfirst(file)) {
X		return  (* (long *) (ResultBuf.cbFileAlloc));
X	} else
X		return -1L;
X}
X
X/*
X * Chdrive() changes the default drive.
X */
Xvoid
Xchdrive(str)
Xchar *str;
X{
X	char *ptr;
X	char drive;
X
X	if ((ptr = index(str, ':')) != NULL) {
X		drive = toupper(*(ptr - 1));
X#ifdef OS2_32BITAPI
X		DosSetDefaultDisk((ULONG)(drive - 'A' + 1));
X#else
X		DosSelectDisk((USHORT)(drive - 'A' + 1));
X#endif
X	}
X}
X
Xvoid
Xdisable_ctrlP()
X{
X	KBDINFO KbdInfo;
X	HKBD KbdHandle = 0;
X
X	if (!flags.rawio) return;
X	KbdInfo.cb = sizeof(KbdInfo);
X	KbdGetStatus(&KbdInfo,KbdHandle);
X	KbdInfo.fsMask &= 0xFFF7; /* ASCII off */
X	KbdInfo.fsMask |= 0x0004; /* BINARY on */
X	KbdSetStatus(&KbdInfo,KbdHandle);
X}
X
Xvoid
Xenable_ctrlP()
X{
X	KBDINFO KbdInfo;
X	HKBD KbdHandle = 0;
X
X	if (!flags.rawio) return;
X	KbdInfo.cb = sizeof(KbdInfo);
X	KbdGetStatus(&KbdInfo,KbdHandle);
X	KbdInfo.fsMask &= 0xFFFB; /* BINARY off */
X	KbdInfo.fsMask |= 0x0008; /* ASCII on */
X	KbdSetStatus(&KbdInfo,KbdHandle);
X}
X
Xvoid
Xget_scr_size()
X{
X	VIOMODEINFO ModeInfo;
X	HVIO VideoHandle = 0;
X
X	ModeInfo.cb = sizeof(ModeInfo);
X
X	(void) VioGetMode(&ModeInfo,VideoHandle);
X
X	CO = ModeInfo.col;
X	LI = ModeInfo.row;
X}
X
Xvoid
Xgotoxy(x,y)
Xint x,y;
X{
X	HVIO VideoHandle = 0;
X
X	x--; y--;			/* (0,0) is upper right corner */
X
X	(void) VioSetCurPos(x, y, VideoHandle);
X}
X
X#endif /* OS2 */
END_OF_FILE
if test 6879 -ne `wc -c <'sys/os2/os2.c'`; then
    echo shar: \"'sys/os2/os2.c'\" unpacked with wrong size!
fi
# end of 'sys/os2/os2.c'
fi
echo shar: End of archive 99 \(of 108\).
cp /dev/null ark99isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \
21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \
41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 \
61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 \
81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 \
101 102 103 104 105 106 107 108 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 108 archives.
    echo "Now execute 'rebuild.sh'"
    rm -f ark10[0-8]isdone ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
