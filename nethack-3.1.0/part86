Path: uunet!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v16i094:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Part86/108
Message-ID: <4457@master.CNA.TEK.COM>
Date: 5 Feb 93 19:21:58 GMT
Sender: news@master.CNA.TEK.COM
Lines: 2115
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1645

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 16, Issue 94
Archive-name: nethack31/Part86
Supersedes: nethack3p9: Volume 10, Issue 46-102
Environment: Amiga, Atari, Mac, MS-DOS, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 86 (of 108)."
# Contents:  dat/Tourist.des src/mkroom.c sys/amiga/wbprotos.h
#   util/dgn_comp.y
# Wrapped by billr@saab on Wed Jan 27 16:09:21 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'dat/Tourist.des' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dat/Tourist.des'\"
else
echo shar: Extracting \"'dat/Tourist.des'\" \(17107 characters\)
sed "s/^X//" >'dat/Tourist.des' <<'END_OF_FILE'
X#	SCCS Id: @(#)Tourist.des	3.1	92/09/26
X#	Copyright (c) 1989 by Jean-Christophe Collet
X#	Copyright (c) 1991,92 by M. Stephenson, P. Winner
X# NetHack may be freely redistributed.  See license for details.
X#
X#	The "start" level for the quest.
X#
X#	Here you meet your (besieged) class leader, Twoflower
X#	and receive your quest assignment.
X#
XMAZE: "T-start",' '
XFLAGS: noteleport,hardfloor
XGEOMETRY:center,center
XMAP
X.......}}....---------..-------------------------------------------------...
X........}}...|.......|..|.-------------------------------------------...|...
X.........}}..|.......|..|.|......|......|.............|......|......|...|...
X..........}}.|.......|..|.|......+......+.............+......+..\...|...|...
X...........}}}..........|.|......|......|.............|......|......|...|...
X.............}}.........|.|----S-|--S---|S----------S-|---S--|------|...|...
X..............}}}.......|...............................................|...
X................}}}.....----S------++--S----------S----------S-----------...
X..................}}...........    ..    ...................................
X......-------......}}}}........}}}}..}}}}..}}}}..}}}}.......................
X......|.....|.......}}}}}}..}}}}   ..   }}}}..}}}}..}}}.....................
X......|.....+...........}}}}}}........................}}}..}}}}..}}}..}}}...
X......|.....|...........................................}}}}..}}}..}}}}.}}}}
X......-------...............................................................
X............................................................................
X...-------......-------.....................................................
X...|.....|......|.....|.....................................................
X...|.....+......+.....|.....................................................
X...|.....|......|.....|.....................................................
X...-------......-------.....................................................
XENDMAP
X# Random Monsters
XRANDOM_MONSTERS: 's', 'C'
X# Dungeon Description
XREGION:(00,00,75,19),lit,"ordinary"
XREGION:(14,01,20,03),unlit,"morgue"
XREGION:(07,10,11,12),unlit,"ordinary"
XREGION:(04,16,08,18),unlit,"ordinary"
XREGION:(17,16,21,18),unlit,"ordinary"
XREGION:(27,02,32,04),unlit,"ordinary"
XREGION:(34,02,39,04),unlit,"ordinary"
XREGION:(41,02,53,04),unlit,"ordinary"
XREGION:(55,02,60,04),unlit,"ordinary"
XREGION:(62,02,67,04),lit,"ordinary"
X# Stairs
XSTAIR:(66,03),down
X# Portal arrival point
XBRANCH:(68,14,68,14),(0,0,0,0)
X# Non diggable walls
XNON_DIGGABLE:(00,00,75,19)
X# Doors
XDOOR:locked,(31,05)
XDOOR:locked,(36,05)
XDOOR:locked,(41,05)
XDOOR:locked,(52,05)
XDOOR:locked,(58,05)
XDOOR:locked,(28,07)
XDOOR:locked,(39,07)
XDOOR:locked,(50,07)
XDOOR:locked,(61,07)
XDOOR:closed,(33,03)
XDOOR:closed,(40,03)
XDOOR:closed,(54,03)
XDOOR:closed,(61,03)
XDOOR:open,(12,11)
XDOOR:open,(09,17)
XDOOR:open,(16,17)
XDOOR:locked,(35,07)
XDOOR:locked,(36,07)
X# Monsters on siege duty.
XMONSTER: 's',"giant spider",random
XMONSTER: 's',"giant spider",random
XMONSTER: 's',"giant spider",random
XMONSTER: 's',"giant spider",random
XMONSTER: 's',"giant spider",random
XMONSTER: 's',"giant spider",random
XMONSTER: 's',"giant spider",random
XMONSTER: 's',"giant spider",random
XMONSTER: 's',"giant spider",random
XMONSTER: 's',"giant spider",random
XMONSTER: 's',"giant spider",random
XMONSTER: 's',"giant spider",random
XMONSTER: 's',random,random
XMONSTER: 's',random,random
XMONSTER: 'C',"forest centaur",random
XMONSTER: 'C',"forest centaur",random
XMONSTER: 'C',"forest centaur",random
XMONSTER: 'C',"forest centaur",random
XMONSTER: 'C',"forest centaur",random
XMONSTER: 'C',"forest centaur",random
XMONSTER: 'C',"forest centaur",random
XMONSTER: 'C',"forest centaur",random
XMONSTER: 'C',random,random
X# Twoflower
XMONSTER:'@',"Twoflower",(64,03)
X# The treasure of Twoflower
XOBJECT:'(',"chest",(64,03)
X# guides for the audience chamber
XMONSTER:'@',"guide",(29,03)
XMONSTER:'@',"guide",(32,04)
XMONSTER:'@',"guide",(35,02)
XMONSTER:'@',"guide",(38,03)
XMONSTER:'@',"guide",(45,03)
XMONSTER:'@',"guide",(48,02)
XMONSTER:'@',"guide",(49,04)
XMONSTER:'@',"guide",(51,03)
XMONSTER:'@',"guide",(57,03)
XMONSTER:'@',"guide",(62,04)
XMONSTER:'@',"guide",(66,04)
X# path guards
XMONSTER:'@',"watchman",(35,08)
XMONSTER:'@',"watchman",(36,08)
X# river monsters
XMONSTER:';',"giant eel",(62,12)
XMONSTER:';',"giant eel",(47,10)
XMONSTER:';',"giant eel",(29,11)
XMONSTER:';',"kraken",(34,09)
XMONSTER:';',"kraken",(37,09)
X# Random traps
XTRAP:random,random
XTRAP:random,random
XTRAP:random,random
XTRAP:random,random
XTRAP:random,random
XTRAP:random,random
XTRAP:random,random
XTRAP:random,random
XTRAP:random,random
X
X#
X#	The "locate" level for the quest.
X#
X#	Here you have to find the Thieves' Guild Hall to go
X#	further towards your assigned quest.
X#
X
XMAZE: "T-locate",' '
XFLAGS: hardfloor
XGEOMETRY:center,center
XMAP
X----------------------------------------------------------------------------
X|....|......|..........|......|......|...|....|.....|......|...............|
X|....|......|.|------|.|......|......|.|.|....|..}..|......|.|----------|..|
X|....|--+----.|......|.|-S---+|+-----|.|.S....|.....|---+--|.|..........+..|
X|....|........|......|.|...|.........|.|------|..............|..........|-+|
X|....+...}}...+......|.|...|.|-----|.|..............|--+----------------|..|
X|----|........|------|.|---|.|.....|......|-----+-|.|.......|...........|--|
X|............................|.....|.|--+-|.......|.|.......|...........|..|
X|----|.....|-------------|...|--+--|.|....|.......|.|-----------+-------|..|
X|....+.....+.........S...|...........|....|-------|........................|
X|....|.....|.........|...|.|---------|....|.........|-------|.|----------|.|
X|....|.....|---------|---|.|......|..+....|-------|.|.......|.+......S.\.|.|
X|....|.....+.........S...|.|......|..|....|.......|.|.......|.|......|...|.|
X|-------|..|.........|---|.|+-------------------+-|.|.......+.|----------|.|
X|.......+..|---------|.........|.........|..........|.......|.|..........|.|
X|.......|..............|--+--|.|.........|.|----+-----------|.|..........|.|
X|---------+-|--+-----|-|.....|.|.........|.|........|.|.....+.|..........+.|
X|...........|........|.S.....|.|----+----|.|--------|.|.....|.|----------|.|
X|...........|........|.|.....|........................|.....|..............|
X----------------------------------------------------------------------------
XENDMAP
X# Random Monsters
XRANDOM_MONSTERS: 's'
X# Dungeon Description
XREGION:(00,00,75,19),lit,"ordinary"
XNON_DIGGABLE:(00,00,75,19)
X#
XREGION:(01,01,04,05),unlit,"morgue"
XREGION:(15,03,20,05),lit,"shop"
XREGION:(62,03,71,04),lit,"shop"
XREGION:(01,17,11,18),lit,"barracks"
XREGION:(12,09,20,10),lit,"barracks"
XREGION:(53,11,59,14),lit,"zoo"
XREGION:(63,14,72,16),lit,"barracks"
XREGION:(32,14,40,16),lit,"temple"
X#
XREGION:(06,01,11,02),random,"ordinary"
XREGION:(24,01,29,02),random,"ordinary"
XREGION:(31,01,36,02),random,"ordinary"
XREGION:(42,01,45,03),random,"ordinary"
XREGION:(53,01,58,02),random,"ordinary"
XREGION:(24,04,26,05),random,"ordinary"
XREGION:(30,06,34,07),random,"ordinary"
XREGION:(73,05,74,05),unlit,"ordinary"
XREGION:(01,09,04,12),random,"ordinary"
XREGION:(01,14,07,15),random,"ordinary"
XREGION:(12,12,20,13),random,"ordinary"
XREGION:(13,17,20,18),random,"ordinary"
XREGION:(22,09,24,10),random,"ordinary"
XREGION:(22,12,24,12),random,"ordinary"
XREGION:(24,16,28,18),random,"ordinary"
XREGION:(28,11,33,12),random,"ordinary"
XREGION:(35,11,36,12),lit,"ordinary"
XREGION:(38,08,41,12),random,"ordinary"
XREGION:(43,07,49,08),random,"ordinary"
XREGION:(43,12,49,12),random,"ordinary"
XREGION:(44,16,51,16),random,"ordinary"
XREGION:(53,06,59,07),random,"ordinary"
XREGION:(61,06,71,07),random,"ordinary"
XREGION:(55,16,59,18),random,"ordinary"
XREGION:(63,11,68,12),random,"ordinary"
XREGION:(70,11,72,12),random,"ordinary"
X# Stairs
XSTAIR:(10,04),up
XSTAIR:(73,05),down
X# Non diggable walls
XNON_DIGGABLE:(00,00,75,19)
XDOOR:closed,(05,05)
XDOOR:closed,(05,09)
XDOOR:closed,(08,14)
XDOOR:closed,(08,03)
XDOOR:closed,(11,09)
XDOOR:closed,(11,12)
XDOOR:closed,(10,16)
XDOOR:closed,(14,05)
XDOOR:closed,(15,16)
XDOOR:locked,(21,09)
XDOOR:locked,(21,12)
XDOOR:closed,(23,17)
XDOOR:closed,(25,03)
XDOOR:closed,(26,15)
XDOOR:closed,(29,03)
XDOOR:closed,(28,13)
XDOOR:closed,(31,03)
XDOOR:closed,(32,08)
XDOOR:closed,(37,11)
XDOOR:closed,(36,17)
XDOOR:locked,(41,03)
XDOOR:closed,(40,07)
XDOOR:closed,(48,06)
XDOOR:closed,(48,13)
XDOOR:closed,(48,15)
XDOOR:closed,(56,03)
XDOOR:closed,(55,05)
XDOOR:closed,(72,03)
XDOOR:locked,(74,04)
XDOOR:closed,(64,08)
XDOOR:closed,(62,11)
XDOOR:closed,(69,11)
XDOOR:closed,(60,13)
XDOOR:closed,(60,16)
XDOOR:closed,(73,16)
X
X# Objects
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
X# Toilet paper
XOBJECT:'?',"blank paper",(71,12)
XOBJECT:'?',"blank paper",(71,12)
X# Random traps
XTRAP:random,random
XTRAP:random,random
XTRAP:random,random
XTRAP:random,random
XTRAP:random,random
XTRAP:random,random
XTRAP:random,random
XTRAP:random,random
XTRAP:random,random
X# Random monsters.
XMONSTER:'s',"giant spider",random
XMONSTER:'s',"giant spider",random
XMONSTER:'s',"giant spider",random
XMONSTER:'s',"giant spider",random
XMONSTER:'s',"giant spider",random
XMONSTER:'s',"giant spider",random
XMONSTER:'s',"giant spider",random
XMONSTER:'s',"giant spider",random
XMONSTER:'s',"giant spider",random
XMONSTER:'s',"giant spider",random
XMONSTER:'s',"giant spider",random
XMONSTER:'s',"giant spider",random
XMONSTER:'s',"giant spider",random
XMONSTER:'s',"giant spider",random
XMONSTER:'s',"giant spider",random
XMONSTER:'s',"giant spider",random
XMONSTER:'s',random,random
XMONSTER:'s',random,random
X
X#
X#	The "goal" level for the quest.
X#
X#	Here you meet the Master of Thieves your nemesis monster.  You have to
X#	defeat the Master of Thieves in combat to gain the artifact you have
X#	been assigned to retrieve.
X#
X
XMAZE: "T-goal", ' '
XGEOMETRY:center,center
XMAP
X----------------------------------------------------------------------------
X|.........|.........|..........|..| |.................|........|........|..|
X|.........|.........|..........|..| |....--------.....|........|........|..|
X|------S--|--+-----------+------..| |....|......|.....|........|........|..|
X|.........|.......................| |....|......+.....--+-------------+--..|
X|.........|.......................| |....|......|..........................|
X|-S-----S-|......----------.......| |....|......|..........................|
X|..|..|...|......|........|.......| |....-----------.........----..........|
X|..+..+...|......|........|.......| |....|.........|.........|}}|..........|
X|..|..|...|......+........|.......| |....|.........+.........|}}|..........|
X|..|..|...|......|........|.......S.S....|.........|.........----..........|
X|---..----|......|........|.......| |....|.........|.......................|
X|.........+......|+--+--+-|.......| |....-----------.......................|
X|---..----|......|..|..|..|.......| |......................--------------..|
X|..|..|...|......----------.......| |......................+............|..|
X|..+..+...|.......................| |--.---...-----+-----..|............|..|
X|--|..----|--+-----------+------..| |.....|...|.........|..|------------|..|
X|..+..+...|.........|..........|..| |.....|...|.........|..+............|..|
X|..|..|...|.........|..........|..| |.....|...|.........|..|............|..|
X----------------------------------------------------------------------------
XENDMAP
X# Random Monsters
XRANDOM_MONSTERS: 's'
X# Dungeon Description
XREGION:(00,00,75,19),lit,"ordinary"
X# The Inn
XREGION:(01,01,09,02),lit,"ordinary"
XREGION:(01,04,09,05),lit,"barracks"
XREGION:(01,07,02,10),unlit,"ordinary"
XREGION:(07,07,09,10),unlit,"ordinary"
XREGION:(01,14,02,15),unlit,"ordinary"
XREGION:(07,14,09,15),unlit,"ordinary"
XREGION:(01,17,02,18),unlit,"ordinary"
XREGION:(07,17,09,18),unlit,"ordinary"
X#
XREGION:(11,01,19,02),unlit,"barracks"
XREGION:(21,01,30,02),unlit,"ordinary"
XREGION:(11,17,19,18),unlit,"barracks"
XREGION:(21,17,30,18),unlit,"ordinary"
X# Police Station
XREGION:(18,07,25,11),lit,"ordinary"
XREGION:(18,13,19,13),unlit,"ordinary"
XREGION:(21,13,22,13),unlit,"ordinary"
XREGION:(24,13,25,13),unlit,"ordinary"
X# The town itself
XREGION:(42,03,47,06),unlit,"ordinary"
XREGION:(42,08,50,11),unlit,"ordinary"
XREGION:(37,16,41,18),unlit,"morgue"
XREGION:(47,16,55,18),unlit,"ordinary"
XREGION:(55,01,62,03),unlit,"ordinary"
XREGION:(64,01,71,03),unlit,"ordinary"
XREGION:(60,14,71,15),lit,"shop"
XREGION:(60,17,71,18),lit,"shop"
X# Non diggable walls
XNON_DIGGABLE:(00,00,75,19)
X# Stairs
XSTAIR:(70,08),up
X# Doors
XDOOR:locked,(07,03)
XDOOR:locked,(02,06)
XDOOR:locked,(08,06)
XDOOR:closed,(03,08)
XDOOR:closed,(06,08)
XDOOR:open,(10,12)
XDOOR:closed,(03,15)
XDOOR:closed,(06,15)
XDOOR:closed,(03,17)
XDOOR:closed,(06,17)
XDOOR:closed,(13,03)
XDOOR:random,(25,03)
XDOOR:closed,(13,16)
XDOOR:random,(25,16)
XDOOR:locked,(17,09)
XDOOR:locked,(18,12)
XDOOR:locked,(21,12)
XDOOR:locked,(24,12)
XDOOR:locked,(34,10)
XDOOR:locked,(36,10)
XDOOR:random,(48,04)
XDOOR:random,(56,04)
XDOOR:random,(70,04)
XDOOR:random,(51,09)
XDOOR:random,(51,15)
XDOOR:open,(59,14)
XDOOR:open,(59,17)
X# Objects
XOBJECT:'(',"credit card",(04,01),blessed,0,"The Platinum Yendorian Express Card"
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
X# Random traps
XTRAP:random,random
XTRAP:random,random
XTRAP:random,random
XTRAP:random,random
XTRAP:random,random
XTRAP:random,random
X# Random monsters.
XMONSTER:'@',"Master of Thieves",(04,01),hostile
XMONSTER:'s',"giant spider",random
XMONSTER:'s',"giant spider",random
XMONSTER:'s',"giant spider",random
XMONSTER:'s',"giant spider",random
XMONSTER:'s',"giant spider",random
XMONSTER:'s',"giant spider",random
XMONSTER:'s',"giant spider",random
XMONSTER:'s',"giant spider",random
XMONSTER:'s',"giant spider",random
XMONSTER:'s',"giant spider",random
XMONSTER:'s',"giant spider",random
XMONSTER:'s',"giant spider",random
XMONSTER:'s',"giant spider",random
XMONSTER:'s',"giant spider",random
XMONSTER:'s',"giant spider",random
XMONSTER:'s',"giant spider",random
XMONSTER:'s',random,random
XMONSTER:'s',random,random
X# ladies of the evening
XMONSTER:'&',"succubus",(02,08)
XMONSTER:'&',"succubus",(08,08)
XMONSTER:'&',"incubus",(02,14)
XMONSTER:'&',"incubus",(08,14)
XMONSTER:'&',"incubus",(02,17)
XMONSTER:'&',"incubus",(08,17)
X# Police station (with drunken prisoners)
XMONSTER:'K',"Kop Kaptain",(24,09),hostile
XMONSTER:'K',"Kop Lieutenant",(20,09),hostile
XMONSTER:'K',"Kop Lieutenant",(22,11),hostile
XMONSTER:'K',"Kop Lieutenant",(22,07),hostile
XMONSTER:'K',"Keystone Kop",(19,07),hostile
XMONSTER:'K',"Keystone Kop",(19,08),hostile
XMONSTER:'K',"Keystone Kop",(22,09),hostile
XMONSTER:'K',"Keystone Kop",(24,11),hostile
XMONSTER:'K',"Keystone Kop",(19,11),hostile
XMONSTER:'@',"soldier",(19,13),hostile
XMONSTER:'@',"soldier",(21,13),hostile
XMONSTER:'@',"captain",(24,13),hostile
X#
XMONSTER:'@',"watchman",(33,10),hostile
X
XWALLIFY
X
X#
X#	The "fill" level for the quest.
X#
X#	This level is used to fill out any levels not occupied by specific
X#	levels as defined above.
X#
X
XMAZE: "T-filla" , ' '
XINIT_MAP: '.' , ' ', true, true, random, true
XNOMAP
X# Random Monsters
XRANDOM_MONSTERS: 's', 'C'
X#
XSTAIR: random, up
XSTAIR: random, down
X#
XOBJECT: random, random, random
XOBJECT: random, random, random
XOBJECT: random, random, random
XOBJECT: random, random, random
XOBJECT: random, random, random
XOBJECT: random, random, random
XOBJECT: random, random, random
X#
XTRAP: random, random
XTRAP: random, random
XTRAP: random, random
XTRAP: random, random
X#
XMONSTER: '@', "soldier", random, hostile
XMONSTER: '@', "soldier", random, hostile
XMONSTER: '@', "soldier", random, hostile
XMONSTER: '@', "soldier", random, hostile
XMONSTER: '@', "soldier", random, hostile
XMONSTER: 'H', random, random, hostile
XMONSTER: 'C', random, random, hostile
X
XMAZE: "T-fillb" , ' '
XINIT_MAP: '.' , ' ', true, true, random, true
XNOMAP
X# Random Monsters
XRANDOM_MONSTERS: 's', 'C'
X#
XSTAIR: random, up
XSTAIR: random, down
X#
XOBJECT: random, random, random
XOBJECT: random, random, random
XOBJECT: random, random, random
XOBJECT: random, random, random
XOBJECT: random, random, random
XOBJECT: random, random, random
XOBJECT: random, random, random
XOBJECT: random, random, random
XOBJECT: random, random, random
XOBJECT: random, random, random
XOBJECT: random, random, random
X#
XTRAP: random, random
XTRAP: random, random
XTRAP: random, random
XTRAP: random, random
X#
XMONSTER: '@', "soldier", random, hostile
XMONSTER: '@', "captain", random, hostile
XMONSTER: '@', "captain", random, hostile
XMONSTER: 'H', random, random, hostile
XMONSTER: 'H', random, random, hostile
XMONSTER: 'C', random, random, hostile
XMONSTER: 's', random, random
END_OF_FILE
if test 17107 -ne `wc -c <'dat/Tourist.des'`; then
    echo shar: \"'dat/Tourist.des'\" unpacked with wrong size!
fi
# end of 'dat/Tourist.des'
fi
if test -f 'src/mkroom.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/mkroom.c'\"
else
echo shar: Extracting \"'src/mkroom.c'\" \(16283 characters\)
sed "s/^X//" >'src/mkroom.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)mkroom.c	3.1	92/11/14	*/
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X/*
X * Entry points:
X *	mkroom() -- make and stock a room of a given type
X *	nexttodoor() -- return TRUE if adjacent to a door
X *	has_dnstairs() -- return TRUE if given room has a down staircase
X *	has_upstairs() -- return TRUE if given room has an up staircase
X *	courtmon() -- generate a court monster
X *	save_rooms() -- save rooms into file fd
X *	rest_rooms() -- restore rooms from file fd
X */
X
X#include "hack.h"
X
X#ifdef OVLB
Xstatic boolean FDECL(isbig, (struct mkroom *));
Xstatic struct mkroom * FDECL(pick_room,(BOOLEAN_P));
Xstatic void NDECL(mkshop), FDECL(mkzoo,(int)), NDECL(mkswamp);
Xstatic void NDECL(mktemple);
Xstatic coord * FDECL(shrine_pos, (int));
Xstatic struct permonst * NDECL(morguemon);
X#ifdef ARMY
Xstatic struct permonst * NDECL(squadmon);
X#endif
Xstatic void FDECL(save_room, (int,struct mkroom *));
Xstatic void FDECL(rest_room, (int,struct mkroom *));
X#endif /* OVLB */
X
X#define sq(x) ((x)*(x))
X
Xextern const struct shclass shtypes[];	/* defined in shknam.c */
X
X#ifdef OVLB
X
Xstatic boolean
Xisbig(sroom)
Xregister struct mkroom *sroom;
X{
X	register int area = (sroom->hx - sroom->lx + 1)
X			   * (sroom->hy - sroom->ly + 1);
X	return( area > 20 );
X}
X
Xvoid
Xmkroom(roomtype)
X/* make and stock a room of a given type */
Xint	roomtype;
X{
X    if (roomtype >= SHOPBASE)
X	mkshop();	/* someday, we should be able to specify shop type */
X    else switch(roomtype) {
X	case COURT:	mkzoo(COURT); break;
X	case ZOO:	mkzoo(ZOO); break;
X	case BEEHIVE:	mkzoo(BEEHIVE); break;
X	case MORGUE:	mkzoo(MORGUE); break;
X	case BARRACKS:	mkzoo(BARRACKS); break;
X	case SWAMP:	mkswamp(); break;
X	case TEMPLE:	mktemple(); break;
X	default:	impossible("Tried to make a room of type %d.", roomtype);
X    }
X}
X
Xstatic void
Xmkshop()
X{
X	register struct mkroom *sroom;
X	int i = -1;
X#ifdef WIZARD
X# ifdef GCC_WARN
X	register char *ep = (char *)0;
X# else
X	register char *ep;
X# endif
X
X	/* first determine shoptype */
X	if(wizard){
X		ep = getenv("SHOPTYPE");
X		if(ep){
X			if(*ep == 'z' || *ep == 'Z'){
X				mkzoo(ZOO);
X				return;
X			}
X			if(*ep == 'm' || *ep == 'M'){
X				mkzoo(MORGUE);
X				return;
X			}
X			if(*ep == 'b' || *ep == 'B'){
X				mkzoo(BEEHIVE);
X				return;
X			}
X			if(*ep == 't' || *ep == 'T' || *ep == '\\'){
X				mkzoo(COURT);
X				return;
X			}
X#ifdef ARMY
X			if(*ep == 's' || *ep == 'S'){
X				mkzoo(BARRACKS);
X				return;
X			}
X#endif /* ARMY */
X			if(*ep == '_'){
X				mktemple();
X				return;
X			}
X			if(*ep == '}'){
X				mkswamp();
X				return;
X			}
X			for(i=0; shtypes[i].name; i++)
X				if(*ep == def_oc_syms[shtypes[i].symb])
X				    goto gottype;
X			if(*ep == 'g' || *ep == 'G')
X				i = 0;
X			else
X				i = -1;
X		}
X	}
Xgottype:
X#endif
X	for(sroom = &rooms[0]; ; sroom++){
X		if(sroom->hx < 0) return;
X		if(sroom - rooms >= nroom) {
X			pline("rooms not closed by -1?");
X			return;
X		}
X		if(sroom->rtype != OROOM) continue;
X		if(has_dnstairs(sroom) || has_upstairs(sroom))
X			continue;
X		if(
X#ifdef WIZARD
X		   (wizard && ep && sroom->doorct != 0) ||
X#endif
X			sroom->doorct == 1) break;
X	}
X	if (!sroom->rlit) {
X		int x, y;
X
X		for(x = sroom->lx - 1; x <= sroom->hx + 1; x++)
X		for(y = sroom->ly - 1; y <= sroom->hy + 1; y++)
X			levl[x][y].lit = 1;
X		sroom->rlit = 1;
X	}
X
X	if(i < 0) {			/* shoptype not yet determined */
X	    register int j;
X
X	    /* pick a shop type at random */
X	    for (j = rnd(100), i = 0; (j -= shtypes[i].prob) > 0; i++)
X		continue;
X
X	    /* big rooms cannot be wand or book shops,
X	     * - so make them general stores
X	     */
X	    if(isbig(sroom) && (shtypes[i].symb == WAND_CLASS
X				|| shtypes[i].symb == SPBOOK_CLASS)) i = 0;
X	}
X	sroom->rtype = SHOPBASE + i;
X
X	/* set room bits before stocking the shop */
X#ifdef SPECIALIZATION
X	topologize(sroom, FALSE); /* doesn't matter - this is a special room */
X#else
X	topologize(sroom);
X#endif
X
X	/* stock the room with a shopkeeper and artifacts */
X	stock_room(i, sroom);
X}
X
Xstatic struct mkroom *
Xpick_room(strict)
Xregister boolean strict;
X/* pick an unused room, preferably with only one door */
X{
X	register struct mkroom *sroom;
X	register int i = nroom;
X
X	for(sroom = &rooms[rn2(nroom)]; i--; sroom++) {
X		if(sroom == &rooms[nroom])
X			sroom = &rooms[0];
X		if(sroom->hx < 0)
X			return (struct mkroom *)0;
X		if(sroom->rtype != OROOM)	continue;
X		if(!strict) {
X		    if(has_upstairs(sroom) || (has_dnstairs(sroom) && rn2(3)))
X			continue;
X		} else if(has_upstairs(sroom) || has_dnstairs(sroom))
X			continue;
X		if(sroom->doorct == 1 || !rn2(5)
X#ifdef WIZARD
X						|| wizard
X#endif
X							)
X			return sroom;
X	}
X	return (struct mkroom *)0;
X}
X
Xstatic void
Xmkzoo(type)
Xint type;
X{
X	register struct mkroom *sroom;
X
X	if ((sroom = pick_room(FALSE)) != 0) {
X		sroom->rtype = type;
X		fill_zoo(sroom);
X	}
X}
X
Xvoid
Xfill_zoo(sroom)
Xstruct mkroom *sroom;
X{
X	struct monst *mon;
X	register int sx,sy,i;
X	int sh, tx, ty, goldlim, type = sroom->rtype;
X	int rmno = (sroom - rooms) + ROOMOFFSET;
X	coord mm;
X
X#ifdef GCC_WARN
X	tx = ty = goldlim = 0;
X#endif
X
X	sh = sroom->fdoor;
X	switch(type) {
X	    case COURT:
X		if(level.flags.is_maze_lev) {
X		    for(tx = sroom->lx; tx <= sroom->hx; tx++)
X			for(ty = sroom->ly; ty <= sroom->hy; ty++)
X			    if(IS_THRONE(levl[tx][ty].typ))
X				goto throne_placed;
X		}
X		i = 100;
X		do {	/* don't place throne on top of stairs */
X			(void) somexy(sroom, &mm);
X			tx = mm.x; ty = mm.y;
X		} while (occupied((xchar)tx, (xchar)ty) && --i > 0);
X	    throne_placed:
X		/* TODO: try to ensure the enthroned monster is an M2_PRINCE */
X		break;
X	    case BEEHIVE:
X		tx = sroom->lx + (sroom->hx - sroom->lx + 1)/2;
X		ty = sroom->ly + (sroom->hy - sroom->ly + 1)/2;
X		if(sroom->irregular) {
X		    /* center might not be valid, so put queen elsewhere */
X		    if(levl[tx][ty].roomno != rmno || levl[tx][ty].edge) {
X			(void) somexy(sroom, &mm);
X			tx = mm.x; ty = mm.y;
X		    }
X		}
X		break;
X	    case ZOO:
X		goldlim = 500 * level_difficulty();
X		break;
X	}
X	for(sx = sroom->lx; sx <= sroom->hx; sx++)
X	    for(sy = sroom->ly; sy <= sroom->hy; sy++) {
X		if(sroom->irregular) {
X		    if(levl[sx][sy].roomno != rmno ||
X		       levl[sx][sy].edge ||
X			  (sroom->doorct &&
X			   distmin(sx, sy, doors[sh].x, doors[sh].y) <= 1))
X			continue;
X		} else if(!SPACE_POS(levl[sx][sy].typ) ||
X			  (sroom->doorct &&
X			   ((sx == sroom->lx && doors[sh].x == sx-1) ||
X			    (sx == sroom->hx && doors[sh].x == sx+1) ||
X			    (sy == sroom->ly && doors[sh].y == sy-1) ||
X			    (sy == sroom->hy && doors[sh].y == sy+1))))
X		    continue;
X		/* don't place monster on explicitly placed throne */
X		if(type == COURT && IS_THRONE(levl[sx][sy].typ))
X		    continue;
X		mon = makemon(
X		    (type == COURT) ? courtmon() :
X#ifdef ARMY
X		    (type == BARRACKS) ? squadmon() :
X#endif
X		    (type == MORGUE) ? morguemon() :
X		    (type == BEEHIVE) ?
X			(sx == tx && sy == ty ? &mons[PM_QUEEN_BEE] : 
X			 &mons[PM_KILLER_BEE]) :
X		    (struct permonst *) 0,
X		   sx, sy);
X		if(mon) {
X			mon->msleep = 1;
X			if (type==COURT && mon->mpeaceful) {
X				mon->mpeaceful = 0;
X				set_malign(mon);
X			}
X		}
X		switch(type) {
X		    case ZOO:
X			if(sroom->doorct)
X			    i = sq(dist2(sx,sy,doors[sh].x,doors[sh].y));
X			else
X			    i = goldlim;
X			if(i >= goldlim) i = 5*level_difficulty();
X			goldlim -= i;
X			mkgold((long) rn1(i, 10), sx, sy);
X			break;
X		    case MORGUE:
X			if(!rn2(5))
X			    (void) mk_tt_object(CORPSE, sx, sy);
X			if(!rn2(10))	/* lots of treasure buried with dead */
X			    (void) mksobj_at((rn2(3)) ? LARGE_BOX : CHEST,
X					     sx, sy, TRUE);
X			break;
X		    case BEEHIVE:
X			if(!rn2(3))
X			    (void) mksobj_at(LUMP_OF_ROYAL_JELLY, sx, sy, TRUE);
X			break;
X#ifdef ARMY
X		    case BARRACKS:
X			if(!rn2(20))	/* the payroll and some loot */
X			    (void) mksobj_at((rn2(3)) ? LARGE_BOX : CHEST,
X					     sx, sy, TRUE);
X			break;
X#endif
X		}
X	    }
X	switch (type) {
X	      case COURT:
X		  levl[tx][ty].typ = THRONE;
X		  (void) somexy(sroom, &mm);
X		  mkgold((long) rn1(50 * level_difficulty(),10), mm.x, mm.y);
X		  (void) mksobj_at(CHEST, mm.x, mm.y, TRUE); /* the royal coffers */
X		  level.flags.has_court = 1;
X		  break;
X#ifdef ARMY
X	      case BARRACKS:
X		  level.flags.has_barracks = 1;
X		  break;
X#endif
X	      case ZOO:
X		  level.flags.has_zoo = 1;
X		  break;
X	      case MORGUE:
X		  level.flags.has_morgue = 1;
X		  break;
X	      case SWAMP:
X		  level.flags.has_swamp = 1;
X		  break;
X	      case BEEHIVE:
X		  level.flags.has_beehive = 1;
X		  break;
X	}
X}
X
Xvoid
Xmkundead(mm)   /* make a swarm of undead around mm */
Xcoord *mm;
X{
X	register int cnt = (level_difficulty() + 1)/10 + rnd(5);
X	register struct permonst *mdat;
X
X	while(cnt--) {
X	      mdat = morguemon();
X	      if(enexto(mm, mm->x, mm->y, mdat))
X		   (void) makemon(mdat, mm->x, mm->y);
X	}
X}
X
Xstatic struct permonst *
Xmorguemon()
X{
X	register int i = rn2(100), hd = rn2(level_difficulty());
X
X	if(hd > 10 && i < 10)
X		return((Inhell || In_endgame(&u.uz)) ? 
X		                    mkclass(S_DEMON,0) : &mons[ndemon()]);
X	if(hd > 8 && i > 85)
X		return(mkclass(S_VAMPIRE,0));
X
X	return((i < 20) ? &mons[PM_GHOST]
X			: (i < 40) ? &mons[PM_WRAITH] : mkclass(S_ZOMBIE,0));
X}
X
Xstatic void
Xmkswamp()	/* Michiel Huisjes & Fred de Wilde */
X{
X	register struct mkroom *sroom;
X	register int sx,sy,i,eelct = 0;
X
X	for(i=0; i<5; i++) {		/* 5 tries */
X		sroom = &rooms[rn2(nroom)];
X		if(sroom->hx < 0 || sroom->rtype != OROOM ||
X		   has_upstairs(sroom) || has_dnstairs(sroom))
X			continue;
X
X		/* satisfied; make a swamp */
X		sroom->rtype = SWAMP;
X		for(sx = sroom->lx; sx <= sroom->hx; sx++)
X		for(sy = sroom->ly; sy <= sroom->hy; sy++)
X		if(!OBJ_AT(sx, sy) &&
X		   !MON_AT(sx, sy) && !t_at(sx,sy) && !nexttodoor(sx,sy)) {
X		    if((sx+sy)%2) {
X			levl[sx][sy].typ = POOL;
X			if(!eelct || !rn2(4)) {
X			    /* mkclass() won't do, as we might get kraken */
X			    (void) makemon(rn2(5) ? &mons[PM_GIANT_EEL]
X						  : &mons[PM_ELECTRIC_EEL],
X						sx, sy);
X			    eelct++;
X			}
X		    } else 
X			if(!rn2(4))	/* swamps tend to be moldy */
X			    (void) makemon(mkclass(S_FUNGUS,0), sx, sy);
X		}
X		level.flags.has_swamp = 1;
X	}
X}
X
Xstatic coord *
Xshrine_pos(roomno)
Xint roomno;
X{
X	static coord buf;
X	struct mkroom *troom = &rooms[roomno - ROOMOFFSET];
X
X	buf.x = troom->lx + ((troom->hx - troom->lx) / 2);
X	buf.y = troom->ly + ((troom->hy - troom->ly) / 2);
X	return(&buf);
X}
X
Xstatic void
Xmktemple()
X{
X	register struct mkroom *sroom;
X	coord *shrine_spot;
X	register struct rm *lev;
X
X	if(!(sroom = pick_room(TRUE))) return;
X
X	/* set up Priest and shrine */
X	sroom->rtype = TEMPLE;
X	/*
X	 * In temples, shrines are blessed altars
X	 * located in the center of the room
X	 */
X	shrine_spot = shrine_pos((sroom - rooms) + ROOMOFFSET);
X	lev = &levl[shrine_spot->x][shrine_spot->y];
X	lev->typ = ALTAR;
X	lev->altarmask = induced_align(80);
X	priestini(&u.uz, sroom, shrine_spot->x, shrine_spot->y, FALSE);
X 	lev->altarmask |= AM_SHRINE;
X	level.flags.has_temple = 1;
X}
X
Xboolean
Xnexttodoor(sx,sy)
Xregister int sx, sy;
X{
X	register int dx, dy;
X	register struct rm *lev;
X	for(dx = -1; dx <= 1; dx++) for(dy = -1; dy <= 1; dy++) {
X		if(!isok(sx+dx, sy+dy)) continue;
X		if(IS_DOOR((lev = &levl[sx+dx][sy+dy])->typ) ||
X		    lev->typ == SDOOR)
X			return(TRUE);
X	}
X	return(FALSE);
X}
X
Xboolean
Xhas_dnstairs(sroom)
Xregister struct mkroom *sroom;
X{
X	if (sroom == dnstairs_room)
X		return TRUE;
X	if (sstairs.sx && !sstairs.up)
X		return sroom == sstairs_room;
X	return FALSE;
X}
X
Xboolean
Xhas_upstairs(sroom)
Xregister struct mkroom *sroom;
X{
X	if (sroom == upstairs_room)
X		return TRUE;
X	if (sstairs.sx && sstairs.up)
X		return sroom == sstairs_room;
X	return FALSE;
X}
X
X#endif /* OVLB */
X#ifdef OVL0
X
Xint
Xsomex(croom)
Xregister struct mkroom *croom;
X{
X	return rn2(croom->hx-croom->lx+1) + croom->lx;
X}
X
Xint
Xsomey(croom)
Xregister struct mkroom *croom;
X{
X	return rn2(croom->hy-croom->ly+1) + croom->ly;
X}
X
Xboolean
Xinside_room(croom, x, y)
Xstruct mkroom *croom;
Xxchar x, y;
X{
X	return (x >= croom->lx-1 && x <= croom->hx+1 &&
X		y >= croom->ly-1 && y <= croom->hy+1);
X}
X
Xboolean
Xsomexy(croom, c)
Xstruct mkroom *croom;
Xcoord *c;
X{
X	int try_cnt = 0;
X	int i;
X
X	if (croom->irregular) {
X	    i = (croom - rooms) + ROOMOFFSET;
X
X	    while(try_cnt++ < 100) {
X		c->x = somex(croom);
X		c->y = somey(croom);
X		if(!levl[c->x][c->y].edge && levl[c->x][c->y].roomno == i)
X		    return TRUE;
X	    }
X	    /* try harder; exhaustively search until one is found */
X	    for(c->x = croom->lx; c->x <= croom->hx; c->x++)
X		for(c->y = croom->ly; c->y <= croom->hy; c->y++)
X		    if(!levl[c->x][c->y].edge && levl[c->x][c->y].roomno == i)
X			return TRUE;
X	    return FALSE;
X	}
X
X	if (!croom->nsubrooms) {
X		c->x = somex(croom);
X		c->y = somey(croom);
X		return TRUE;
X	}
X
X	/* Check that coords doesn't fall into a subroom or into a wall */
X
X	while(try_cnt++ < 100) {
X		c->x = somex(croom);
X		c->y = somey(croom);
X		if (IS_WALL(levl[c->x][c->y].typ))
X		    continue;
X		for(i=0 ; i<croom->nsubrooms;i++)
X		    if(inside_room(croom->sbrooms[i], c->x, c->y))
X			goto you_lose;
X		break;
Xyou_lose:	;
X	}
X	if (try_cnt >= 100)
X	    return FALSE;
X	return TRUE;
X}
X
X/* 
X * Search for a special room given its type (zoo, court, etc...)
X * 	Special values :
X * 		- ANY_SHOP
X * 		- ANY_TYPE
X */
X
Xstruct mkroom *
Xsearch_special(type)
Xschar type;
X{
X	register struct mkroom *croom;
X
X	for(croom = &rooms[0]; croom->hx >= 0; croom++)
X	    if((type == ANY_TYPE && croom->rtype != OROOM) ||
X	       (type == ANY_SHOP && croom->rtype >= SHOPBASE) ||
X	       croom->rtype == type)
X		return croom;
X	for(croom = &subrooms[0]; croom->hx >= 0; croom++)
X	    if((type == ANY_TYPE && croom->rtype != OROOM) ||
X	       (type == ANY_SHOP && croom->rtype >= SHOPBASE) ||
X	       croom->rtype == type)
X		return croom;
X	return (struct mkroom *) 0;
X}
X
X#endif /* OVL0 */
X#ifdef OVLB
X
Xstruct permonst *
Xcourtmon()
X{
X	int     i = rn2(60) + rn2(3*level_difficulty());
X	if (i > 100)		return(mkclass(S_DRAGON,0));
X	else if (i > 95)	return(mkclass(S_GIANT,0));
X	else if (i > 85)	return(mkclass(S_TROLL,0));
X	else if (i > 75)	return(mkclass(S_CENTAUR,0));
X	else if (i > 60)	return(mkclass(S_ORC,0));
X	else if (i > 45)	return(&mons[PM_BUGBEAR]);
X	else if (i > 30)	return(&mons[PM_HOBGOBLIN]);
X	else if (i > 15)	return(mkclass(S_GNOME,0));
X	else			return(mkclass(S_KOBOLD,0));
X}
X
X#ifdef ARMY
X#define	    NSTYPES	(PM_CAPTAIN-PM_SOLDIER+1)
X
Xstatic struct {
X    unsigned	pm;
X    unsigned	prob;
X} squadprob[NSTYPES] = {
X    {PM_SOLDIER, 80}, {PM_SERGEANT, 15}, {PM_LIEUTENANT, 4}, {PM_CAPTAIN, 1}
X};
X
Xstatic struct permonst *
Xsquadmon() {	    /* return soldier types. */
X
X	register struct permonst *ptr;
X	register int	i, cpro, sel_prob = rnd(80+level_difficulty());
X
X	for(cpro = i = 0; i < NSTYPES; i++)
X	    if((cpro += squadprob[i].prob) > sel_prob) {
X
X		ptr = &mons[squadprob[i].pm];
X		goto gotone;
X	    }
X	ptr = &mons[squadprob[rn2(NSTYPES)].pm];
Xgotone:
X	if(!(ptr->geno & (G_GENOD | G_EXTINCT)))  return(ptr);
X	else			    return((struct permonst *) 0);
X}
X#endif /* ARMY /* */
X
X/* 
X * save_room : A recursive function that saves a room and its subrooms 
X * (if any).
X */
X
Xstatic void
Xsave_room(fd, r)
Xint	fd;
Xstruct mkroom *r;
X{
X	short i;
X	/* 
X	 * Well, I really should write only useful informations instead
X	 * of writing the whole structure. That is I should not write
X	 * the subrooms pointers, but who cares ?
X	 */
X	bwrite(fd, (genericptr_t) r, sizeof(struct mkroom));
X	for(i=0; i<r->nsubrooms; i++)
X	    save_room(fd, r->sbrooms[i]);
X}
X
X/* 
X * save_rooms : Save all the rooms on disk!
X */
X
Xvoid
Xsave_rooms(fd)
Xint fd;
X{
X	short i;
X
X	/* First, write the number of rooms */
X	bwrite(fd, (genericptr_t) &nroom, sizeof(nroom));
X	for(i=0; i<nroom; i++)
X	    save_room(fd, &rooms[i]);
X}
X
Xstatic void
Xrest_room(fd, r)
Xint fd;
Xstruct mkroom *r;
X{
X	short i;
X
X	mread(fd, (genericptr_t) r, sizeof(struct mkroom));
X	for(i=0; i<r->nsubrooms; i++) {
X		r->sbrooms[i] = &subrooms[nsubroom];
X		rest_room(fd, &subrooms[nsubroom++]);
X	}
X}
X
X/* 
X * rest_rooms : That's for restore rooms. Read the rooms structure from
X * the disk.
X */
X
Xvoid
Xrest_rooms(fd)
Xint	fd;
X{
X	short i;
X
X	mread(fd, (genericptr_t) &nroom, sizeof(nroom));
X	nsubroom = 0;
X	for(i = 0; i<nroom; i++) {
X	    rest_room(fd, &rooms[i]);
X	    rooms[i].resident = (struct monst *)0;
X	}
X	rooms[nroom].hx = -1;		/* restore ending flags */
X	subrooms[nsubroom].hx = -1;
X}
X#endif /* OVLB */
X
X/*mkroom.c*/
END_OF_FILE
if test 16283 -ne `wc -c <'src/mkroom.c'`; then
    echo shar: \"'src/mkroom.c'\" unpacked with wrong size!
fi
# end of 'src/mkroom.c'
fi
if test -f 'sys/amiga/wbprotos.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/amiga/wbprotos.h'\"
else
echo shar: Extracting \"'sys/amiga/wbprotos.h'\" \(4036 characters\)
sed "s/^X//" >'sys/amiga/wbprotos.h' <<'END_OF_FILE'
X/*    SCCS Id: @(#)wbprotos.h   3.1    93/01/08
X/* Copyright (c) Kenneth Lorber, Bethesda, Maryland, 1992, 1993.  */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#ifdef __STDC__
X# define P(s) s
X#else
X# define P(s) ()
X#endif
X
X
X/* wb.c */
Xint main P(( int argc , struct WBStartup *argv ));
Xvoid CopyRight P(( void ));
Xvoid InitWB P(( int argc , struct WBStartup *wbs ));
Xvoid ReadConfig P(( void ));
Xvoid CloseDownWB P(( void ));
Xvoid SetupWB P(( void ));
Xvoid MapGadgets P(( int reason , int update ));
Xvoid ClearWindow P(( struct Window *win ));
Xvoid CalcLocs P(( int update ));
Xvoid text_requester P(( struct NewWindow *newwin , struct IntuiText *tlist ));
Xvoid getline P(( FILE *fp , long *offarr , int which , char *buf , int size ));
Xvoid help_requester P(( char *file ));
Xvoid do_closewindow P(( void ));
Xvoid do_menu P(( int mcode ));
Xvoid menu_discard P(( void ));
Xvoid menu_copyopt P(( void ));
Xvoid menu_rename P(( void ));
Xvoid run_game P(( GPTR gptr ));
Xvoid CleanUpLists P(( void ));
Xvoid CloseLibraries P(( void ));
Xvoid cleanup P(( int code ));
Xvoid SafeCloseWindow P(( struct Window *window ));
XGPTR AllocGITEM P(( void ));
Xvoid FreeGITEM P(( GPTR gptr ));
Xstruct DiskObject *AllocDObj P(( char *str ));
Xvoid FreeDObj P(( struct DiskObject *doptr ));
Xvoid LoadIcons P(( void ));
Xvoid menu_scores P(( void ));
Xvoid menu_recover P(( void ));
Xvoid menu_config P(( void ));
Xvoid menu_editdef P(( int newgame ));
Xvoid do_gadgetup P(( struct IntuiMessage *imsg ));
Xvoid do_buttons P(( struct IntuiMessage *imsg ));
Xvoid do_gadgetdown P(( struct IntuiMessage *imsg ));
Xint ask_request P(( char *str ));
Xvoid menu_setopt P(( void ));
Xvoid menu_info P(( void ));
Xint IsEditEntry P(( char *, GPTR ));
Xvoid menu_comment P(( void ));
Xvoid text_request P(( char *str , char *file ));
Xvoid errmsg P(( int flash , char *str, ... ));
Xvoid error P(( char *str ));
Xvoid SetGadgetUP P(( struct Gadget *gad ));
Xvoid SetGadgetDOWN P(( struct Gadget *gad ));
Xvoid UpdatePropGad P(( struct Window *win , struct Gadget *gad , long vis ,
X    long total , long top ));
Xvoid *xmalloc P(( unsigned nbytes ));
Xint DeleteGame P(( GPTR gptr ));
XGPTR FindGame P(( char *name ));
Xvoid setoneopt P(( int idx , char *str ));
Xchar *dirname P(( char *str ));
Xint StrRequest P(( char *prompt , char *buff , char *val ));
Xvoid LoadDefaults P(( char *player ));
Xvoid SaveDefaults P(( char *player ));
Xvoid CopyDefs2Gad P(( void ));
Xvoid CopyGad2Defs P(( void ));
Xvoid UpdateTypes P(( struct Window *cwin ));
Xvoid CheckOnly P(( struct Menu *menuptr , int menu , int itemno ));
Xint Ask P(( char *quest ));
Xchar *GameName P(( GPTR gptr , char *file ));
XGPTR GetWBIcon P(( BPTR lock , char *dir , struct FileInfoBlock *finfo ));
Xvoid SetBorder P(( struct Gadget *gd, int val ));
XGPTR NeedGame P(( void ));
Xvoid ChgGameItems P(( struct Menu *menup , int enable ));
Xvoid ChgNewGameItems P(( struct Menu *menup , int enable ));
Xint EditOptions P(( OPTR optr ));
Xstruct Gadget *FindGadget P(( struct Window *window ,
X    struct NewWindow *newwindow , int id ));
Xvoid ZapOptions P(( OPTR optr ));
Xvoid CopyOptions P(( OPTR optr , GPTR gptr ));
Xvoid CopyOptionStr P(( OPTR optr , char *str ));
Xvoid SetOptions P(( OPTR optr , GPTR gptr ));
Xvoid PutOptions P(( OPTR optr ));
Xchar *ToolsEntry P(( GPTR gptr , char *name ));
Xvoid ReallocTools P(( GPTR gptr, int ));
Xvoid FreeTools P(( GPTR gptr ));
Xvoid SetToolLine P(( GPTR gptr , char *name , char *value ));
Xvoid WriteDObj P(( GPTR gptr , long lock ));
Xvoid UpdateGameIcon P(( GPTR gptr ));
Xchar *Strdup P(( char *str ));
Xvoid Game2Defs P(( GPTR gptr ));
Xint CheckAndCopy P(( char *, char * ));
Xvoid ClearDelGames P(( void ));
Xint FindChecked P(( register struct Menu *menuptr, register int menu ));
Xvoid RPText P(( struct RastPort *rp, register char *s ));
X#ifdef  INTUI_NEW_LOOK
Xstruct Window *MyOpenWindow P(( struct ExtNewWindow *nw ));
X#else
Xstruct Window *MyOpenWindow P(( struct NewWindow *nw ));
X#endif
Xvoid SetUpMenus( register struct Menu *mp, register struct Screen *scrn );
X
X#undef P
END_OF_FILE
if test 4036 -ne `wc -c <'sys/amiga/wbprotos.h'`; then
    echo shar: \"'sys/amiga/wbprotos.h'\" unpacked with wrong size!
fi
# end of 'sys/amiga/wbprotos.h'
fi
if test -f 'util/dgn_comp.y' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'util/dgn_comp.y'\"
else
echo shar: Extracting \"'util/dgn_comp.y'\" \(16306 characters\)
sed "s/^X//" >'util/dgn_comp.y' <<'END_OF_FILE'
X%{
X/*	SCCS Id: @(#)dgn_comp.c	3.1	93/01/17	*/
X/*	Copyright (c) 1989 by Jean-Christophe Collet */
X/*	Copyright (c) 1990 by M. Stephenson				  */
X/* NetHack may be freely redistributed.  See license for details. */
X
X/*
X * This file contains the Dungeon Compiler code
X */
X
X/* In case we're using bison in AIX.  This definition must be
X * placed before any other C-language construct in the file
X * excluding comments and preprocessor directives (thanks IBM
X * for this wonderful feature...).
X *
X * Note: some cpps barf on this 'undefined control' (#pragma).
X * Addition of the leading space seems to prevent barfage for now,
X * and AIX will still see the directive in its non-standard locale.
X */
X
X#ifdef _AIX
X #pragma alloca		/* keep leading space! */
X#endif
X
X#include "config.h"
X#include "dgn_file.h"
X
Xvoid FDECL(yyerror, (char *));
Xvoid FDECL(yywarning, (char *));
Xint NDECL(yylex);
Xint NDECL(yyparse);
Xint FDECL(getchain, (char *));
Xint NDECL(check_dungeon);
Xint NDECL(check_branch);
Xint NDECL(check_level);
Xvoid NDECL(init_dungeon);
Xvoid NDECL(init_branch);
Xvoid NDECL(init_level);
Xvoid NDECL(output_dgn);
X
X#ifdef AMIGA
X# undef	printf
X#ifndef	LATTICE
X# define    memset(addr,val,len)    setmem(addr,len,val)
X#endif
X#endif
X
X#ifdef MICRO
X# undef exit
Xextern void FDECL(exit, (int));
X#endif
X
X#undef NULL
X
X#define ERR		(-1)
X
Xstatic struct couple couple;
Xstatic struct tmpdungeon tmpdungeon[MAXDUNGEON];
Xstatic struct tmplevel tmplevel[LEV_LIMIT];
Xstatic struct tmpbranch tmpbranch[BRANCH_LIMIT];
X
Xstatic int in_dungeon = 0, n_dgns = -1, n_levs = -1, n_brs = -1;
X
Xextern int fatal_error;
Xextern char* fname;
X
X%}
X
X%union
X{
X	int	i;
X	char*	str;
X}
X
X%token	<i>	INTEGER
X%token	<i>	A_DUNGEON BRANCH CHBRANCH LEVEL RNDLEVEL CHLEVEL RNDCHLEVEL
X%token	<i>	UP_OR_DOWN PROTOFILE DESCRIPTION DESCRIPTOR LEVELDESC
X%token	<i>	ALIGNMENT LEVALIGN ENTRY STAIR NO_UP NO_DOWN PORTAL
X%token	<str>	STRING
X%type   <i>	optional_int direction branch_type
X%start	file
X
X%%
Xfile		: /* nothing */
X		| dungeons
X		  {
X			output_dgn();
X		  }
X		;
X
Xdungeons	: dungeon
X		| dungeons dungeon
X		;
X
Xdungeon		: dungeonline
X		| dungeondesc
X		| branches
X		| levels
X		;
X
Xdungeonline	: A_DUNGEON ':' STRING STRING rcouple optional_int
X		  {
X			init_dungeon();
X			strcpy(tmpdungeon[n_dgns].name, $3);
X			if (!strcmp($4, "none"))
X				tmpdungeon[n_levs].boneschar = '\0';
X			else if ($4[1])
X				yyerror("Bones marker must be a single char, or \"none\"!");
X			else
X				tmpdungeon[n_dgns].boneschar = $4[0];
X			tmpdungeon[n_dgns].lev.base = couple.base;
X			tmpdungeon[n_dgns].lev.rand = couple.rand;
X			tmpdungeon[n_dgns].chance = $6;
X		  }
X		;
X
Xoptional_int	: /* nothing */
X		  {
X			$$ = 0;
X		  }
X		| INTEGER
X		  {
X			$$ = $1;
X		  }
X		;
X
Xdungeondesc	: entry
X		| descriptions
X		| prototype
X		;
X
Xentry		: ENTRY ':' INTEGER
X		  {
X			tmpdungeon[n_dgns].entry_lev = $3;
X		  }
X		;
X
Xdescriptions	: desc
X		;
X
Xdesc		: DESCRIPTION ':' DESCRIPTOR
X		  {
X			if($<i>3 <= TOWN || $<i>3 >= D_ALIGN_CHAOTIC)
X			    yyerror("Illegal description - ignoring!");
X			else
X			    tmpdungeon[n_dgns].flags |= $<i>3 ;
X		  }
X		| ALIGNMENT ':' DESCRIPTOR
X		  {
X			if($<i>3 && $<i>3 < D_ALIGN_CHAOTIC)
X			    yyerror("Illegal alignment - ignoring!");
X			else
X			    tmpdungeon[n_dgns].flags |= $<i>3 ;
X		  }
X		;
X
Xprototype	: PROTOFILE ':' STRING
X		  {
X			strcpy(tmpdungeon[n_dgns].protoname, $3);
X		  }
X		;
X
Xlevels		: level1
X		| level2
X		| levdesc
X		| chlevel1
X		| chlevel2
X		;
X
Xlevel1		: LEVEL ':' STRING STRING '@' acouple
X		  {
X			init_level();
X			strcpy(tmplevel[n_levs].name, $3);
X			if (!strcmp($4, "none"))
X				tmplevel[n_levs].boneschar = '\0';
X			else if ($4[1])
X				yyerror("Bones marker must be a single char, or \"none\"!");
X			else
X				tmplevel[n_levs].boneschar = $4[0];
X			tmplevel[n_levs].lev.base = couple.base;
X			tmplevel[n_levs].lev.rand = couple.rand;
X			tmpdungeon[n_dgns].levels++;
X		  }
X		| RNDLEVEL ':' STRING STRING '@' acouple INTEGER
X		  {
X			init_level();
X			strcpy(tmplevel[n_levs].name, $3);
X			if (!strcmp($4, "none"))
X				tmplevel[n_levs].boneschar = '\0';
X			else if ($4[1])
X				yyerror("Bones marker must be a single char, or \"none\"!");
X			else
X				tmplevel[n_levs].boneschar = $4[0];
X			tmplevel[n_levs].lev.base = couple.base;
X			tmplevel[n_levs].lev.rand = couple.rand;
X			tmplevel[n_levs].rndlevs = $7;
X			tmpdungeon[n_dgns].levels++;
X		  }
X		;
X
Xlevel2		: LEVEL ':' STRING STRING '@' acouple INTEGER
X		  {
X			init_level();
X			strcpy(tmplevel[n_levs].name, $3);
X			if (!strcmp($4, "none"))
X				tmplevel[n_levs].boneschar = '\0';
X			else if ($4[1])
X				yyerror("Bones marker must be a single char, or \"none\"!");
X			else
X				tmplevel[n_levs].boneschar = $4[0];
X			tmplevel[n_levs].lev.base = couple.base;
X			tmplevel[n_levs].lev.rand = couple.rand;
X			tmplevel[n_levs].chance = $7;
X			tmpdungeon[n_dgns].levels++;
X		  }
X		| RNDLEVEL ':' STRING STRING '@' acouple INTEGER INTEGER
X		  {
X			init_level();
X			strcpy(tmplevel[n_levs].name, $3);
X			if (!strcmp($4, "none"))
X				tmplevel[n_levs].boneschar = '\0';
X			else if ($4[1])
X				yyerror("Bones marker must be a single char, or \"none\"!");
X			else
X				tmplevel[n_levs].boneschar = $4[0];
X			tmplevel[n_levs].lev.base = couple.base;
X			tmplevel[n_levs].lev.rand = couple.rand;
X			tmplevel[n_levs].chance = $7;
X			tmplevel[n_levs].rndlevs = $8;
X			tmpdungeon[n_dgns].levels++;
X		  }
X		;
X
Xlevdesc		: LEVELDESC ':' DESCRIPTOR
X		  {
X			if($<i>3 >= D_ALIGN_CHAOTIC)
X			    yyerror("Illegal description - ignoring!");
X			else
X			    tmplevel[n_levs].flags |= $<i>3 ;
X		  }
X		| LEVALIGN ':' DESCRIPTOR
X		  {
X			if($<i>3 && $<i>3 < D_ALIGN_CHAOTIC)
X			    yyerror("Illegal alignment - ignoring!");
X			else
X			    tmplevel[n_levs].flags |= $<i>3 ;
X		  }
X		;
X
Xchlevel1	: CHLEVEL ':' STRING STRING STRING '+' rcouple
X		  {
X			init_level();
X			strcpy(tmplevel[n_levs].name, $3);
X			if (!strcmp($4, "none"))
X				tmplevel[n_levs].boneschar = '\0';
X			else if ($4[1])
X				yyerror("Bones marker must be a single char, or \"none\"!");
X			else
X				tmplevel[n_levs].boneschar = $4[0];
X			tmplevel[n_levs].chain = getchain($5);
X			tmplevel[n_levs].lev.base = couple.base;
X			tmplevel[n_levs].lev.rand = couple.rand;
X			if(!check_level()) n_levs--;
X			else tmpdungeon[n_dgns].levels++;
X		  }
X		| RNDCHLEVEL ':' STRING STRING STRING '+' rcouple INTEGER
X		  {
X			init_level();
X			strcpy(tmplevel[n_levs].name, $3);
X			if (!strcmp($4, "none"))
X				tmplevel[n_levs].boneschar = '\0';
X			else if ($4[1])
X				yyerror("Bones marker must be a single char, or \"none\"!");
X			else
X				tmplevel[n_levs].boneschar = $4[0];
X			tmplevel[n_levs].chain = getchain($5);
X			tmplevel[n_levs].lev.base = couple.base;
X			tmplevel[n_levs].lev.rand = couple.rand;
X			tmplevel[n_levs].rndlevs = $8;
X			if(!check_level()) n_levs--;
X			else tmpdungeon[n_dgns].levels++;
X		  }
X		;
X
Xchlevel2	: CHLEVEL ':' STRING STRING STRING '+' rcouple INTEGER
X		  {
X			init_level();
X			strcpy(tmplevel[n_levs].name, $3);
X			if (!strcmp($4, "none"))
X				tmplevel[n_levs].boneschar = '\0';
X			else if ($4[1])
X				yyerror("Bones marker must be a single char, or \"none\"!");
X			else
X				tmplevel[n_levs].boneschar = $4[0];
X			tmplevel[n_levs].chain = getchain($5);
X			tmplevel[n_levs].lev.base = couple.base;
X			tmplevel[n_levs].lev.rand = couple.rand;
X			tmplevel[n_levs].chance = $8;
X			if(!check_level()) n_levs--;
X			else tmpdungeon[n_dgns].levels++;
X		  }
X		| RNDCHLEVEL ':' STRING STRING STRING '+' rcouple INTEGER INTEGER
X		  {
X			init_level();
X			strcpy(tmplevel[n_levs].name, $3);
X			if (!strcmp($4, "none"))
X				tmplevel[n_levs].boneschar = '\0';
X			else if ($4[1])
X				yyerror("Bones marker must be a single char, or \"none\"!");
X			else
X				tmplevel[n_levs].boneschar = $4[0];
X			tmplevel[n_levs].chain = getchain($5);
X			tmplevel[n_levs].lev.base = couple.base;
X			tmplevel[n_levs].lev.rand = couple.rand;
X			tmplevel[n_levs].chance = $8;
X			tmplevel[n_levs].rndlevs = $9;
X			if(!check_level()) n_levs--;
X			else tmpdungeon[n_dgns].levels++;
X		  }
X		;
X
Xbranches	: branch
X		| chbranch
X		;
X
Xbranch		: BRANCH ':' STRING '@' acouple branch_type direction
X		  {
X			init_branch();
X			strcpy(tmpbranch[n_brs].name, $3);
X			tmpbranch[n_brs].lev.base = couple.base;
X			tmpbranch[n_brs].lev.rand = couple.rand;
X			tmpbranch[n_brs].type = $6;
X			tmpbranch[n_brs].up = $7;
X			if(!check_branch()) n_brs--;
X			else tmpdungeon[n_dgns].branches++;
X		  }
X		;
X
Xchbranch	: CHBRANCH ':' STRING STRING '+' rcouple branch_type direction
X		  {
X			init_branch();
X			strcpy(tmpbranch[n_brs].name, $3);
X			tmpbranch[n_brs].chain = getchain($4);
X			tmpbranch[n_brs].lev.base = couple.base;
X			tmpbranch[n_brs].lev.rand = couple.rand;
X			tmpbranch[n_brs].type = $7;
X			tmpbranch[n_brs].up = $8;
X			if(!check_branch()) n_brs--;
X			else tmpdungeon[n_dgns].branches++;
X		  }
X		;
X
Xbranch_type	: /* nothing */
X		  {
X			$$ = TBR_STAIR;	/* two way stair */
X		  }
X		| STAIR
X		  {
X			$$ = TBR_STAIR;	/* two way stair */
X		  }
X		| NO_UP
X		  {
X			$$ = TBR_NO_UP;	/* no up staircase */
X		  }
X		| NO_DOWN
X		  {
X			$$ = TBR_NO_DOWN;	/* no down staircase */
X		  }
X		| PORTAL
X		  {
X			$$ = TBR_PORTAL;	/* portal connection */
X		  }
X		;
X
Xdirection	: /* nothing */
X		  {
X			$$ = 0;	/* defaults to down */
X		  }
X		| UP_OR_DOWN
X		  {
X			$$ = $1;
X		  }
X		;
X
X/*
X *	acouple rules:
X *
X *	(base, range) where:
X *
X *	    base is either a positive or negative integer with a value
X *	    less than or equal to MAXLEVEL.
X *	    base > 0 indicates the base level.
X *	    base < 0 indicates reverse index (-1 == lowest level)
X *
X *	    range is the random component.
X *	    if range is zero, there is no random component.
X *	    if range is -1 the dungeon loader will randomize between
X *	    the base and the end of the dungeon.
X *	    during dungeon load, range is always *added* to the base,
X *	    therefore range + base(converted) must not exceed MAXLEVEL.
X */
Xacouple		: '(' INTEGER ',' INTEGER ')'
X		  {
X			if ($2 < -MAXLEVEL || $2 > MAXLEVEL) {
X			    yyerror("Abs base out of dlevel range - zeroing!");
X			    couple.base = couple.rand = 0;
X			} else if ($4 < -1 ||
X				(($2 < 0) ? (MAXLEVEL + $2 + $4 + 1) > MAXLEVEL :
X					($2 + $4) > MAXLEVEL)) {
X			    yyerror("Abs range out of dlevel range - zeroing!");
X			    couple.base = couple.rand = 0;
X			} else {
X			    couple.base = $2;
X			    couple.rand = $4;
X			}
X		  }
X		;
X
X/*
X *	rcouple rules:
X *
X *	(base, range) where:
X *
X *	    base is either a positive or negative integer with a value
X *	    less than or equal to MAXLEVEL.
X *	    base > 0 indicates a forward index.
X *	    base < 0 indicates a reverse index.
X *	    base == 0 indicates on the parent level.
X *
X *	    range is the random component.
X *	    if range is zero, there is no random component.
X *	    during dungeon load, range is always *added* to the base,
X *	    range + base(converted) may be very large.  The dungeon
X *	    loader will then correct to "between here and the top/bottom".
X *
X *	    There is no practical way of specifying "between here and the
X *	    nth / nth last level".
X */
Xrcouple		: '(' INTEGER ',' INTEGER ')'
X		  {
X			if ($2 < -MAXLEVEL || $2 > MAXLEVEL) {
X			    yyerror("Rel base out of dlevel range - zeroing!");
X			    couple.base = couple.rand = 0;
X			} else {
X			    couple.base = $2;
X			    couple.rand = $4;
X			}
X		  }
X		;
X%%
X
Xvoid
Xinit_dungeon()
X{
X	if(++n_dgns > MAXDUNGEON) {
X	    fprintf(stderr, "FATAL - Too many dungeons (limit: %d).\n",
X		    MAXDUNGEON);
X	    fprintf(stderr, "To increase the limit edit MAXDUNGEON in global.h\n");
X	    exit(1);
X	}
X
X	in_dungeon = 1;
X	tmpdungeon[n_dgns].lev.base = 0;
X	tmpdungeon[n_dgns].lev.rand = 0;
X	tmpdungeon[n_dgns].chance = 100;
X	strcpy(tmpdungeon[n_dgns].name, "");
X	strcpy(tmpdungeon[n_dgns].protoname, "");
X	tmpdungeon[n_dgns].flags = 0;
X	tmpdungeon[n_dgns].levels = 0;
X	tmpdungeon[n_dgns].branches = 0;
X	tmpdungeon[n_dgns].entry_lev = 0;
X}
X
Xvoid
Xinit_level()
X{
X	if(++n_levs > LEV_LIMIT) {
X
X		yyerror("FATAL - Too many special levels defined.");
X		exit(1);
X	}
X	tmplevel[n_levs].lev.base = 0;
X	tmplevel[n_levs].lev.rand = 0;
X	tmplevel[n_levs].chance = 100;
X	tmplevel[n_levs].rndlevs = 0;
X	tmplevel[n_levs].flags = 0;
X	strcpy(tmplevel[n_levs].name, "");
X	tmplevel[n_levs].chain = -1;
X}
X
Xvoid
Xinit_branch()
X{
X	if(++n_brs > BRANCH_LIMIT) {
X
X		yyerror("FATAL - Too many special levels defined.");
X		exit(1);
X	}
X	tmpbranch[n_brs].lev.base = 0;
X	tmpbranch[n_brs].lev.rand = 0;
X	strcpy(tmpbranch[n_brs].name, "");
X	tmpbranch[n_brs].chain = -1;
X}
X
Xint
Xgetchain(s)
X	char	*s;
X{
X	int i;
X
X	if(strlen(s)) {
X
X	    for(i = n_levs - tmpdungeon[n_dgns].levels + 1; i <= n_levs; i++)
X		if(!strcmp(tmplevel[i].name, s)) return i;
X
X	    yyerror("Can't locate the specified chain level.");
X	    return(-2);
X	}
X	return(-1);
X}
X
X/*
X *	Consistancy checking routines:
X *
X *	- A dungeon must have a unique name.
X *	- A dungeon must have a originating "branch" command
X *	  (except, of course, for the first dungeon).
X *	- A dungeon must have a proper depth (at least (1, 0)).
X */
X
Xint
Xcheck_dungeon()
X{
X	int i;
X
X	for(i = 0; i < n_dgns; i++)
X	    if(!strcmp(tmpdungeon[i].name, tmpdungeon[n_dgns].name)) {
X		yyerror("Duplicate dungeon name.");
X		return(0);
X	    }
X
X	if(n_dgns)
X	  for(i = 0; i < n_brs - tmpdungeon[n_dgns].branches; i++) {
X	    if(!strcmp(tmpbranch[i].name, tmpdungeon[n_dgns].name)) break;
X
X	    if(i >= n_brs - tmpdungeon[n_dgns].branches) {
X		yyerror("Dungeon cannot be reached.");
X		return(0);
X	    }
X	  }
X
X	if(tmpdungeon[n_dgns].lev.base <= 0 ||
X	   tmpdungeon[n_dgns].lev.rand < 0) {
X		yyerror("Invalid dungeon depth specified.");
X		return(0);
X	}
X	return(1);	/* OK */
X}
X
X/*
X *	- A level must have a unique level name.
X *	- If chained, the level used as reference for the chain
X *	  must be in this dungeon, must be previously defined, and
X *	  the level chained from must be "non-probabalistic" (ie.
X *	  have a 100% chance of existing).
X */
X
Xint
Xcheck_level()
X{
X	int i;
X
X	if(!in_dungeon) {
X		yyerror("Level defined outside of dungeon.");
X		return(0);
X	}
X
X	for(i = 0; i < n_levs; i++)
X	    if(!strcmp(tmplevel[i].name, tmplevel[n_levs].name)) {
X		yyerror("Duplicate level name.");
X		return(0);
X	    }
X
X	if(tmplevel[i].chain == -2) {
X		yyerror("Invaild level chain reference.");
X		return(0);
X	} else if(tmplevel[i].chain != -1) {	/* there is a chain */
X	    if(tmplevel[tmpbranch[i].chain].chance != 100) {
X		yyerror("Level cannot chain from a probabalistic level.");
X		return(0);
X	    } else if(tmplevel[i].chain == n_levs) {
X		yyerror("A level cannot chain to itself!");
X		return(0);
X	    }
X	}
X	return(1);	/* OK */
X}
X
X/*
X *	- A branch may not branch backwards - to avoid branch loops.
X *	- A branch name must be unique.
X *	  (ie. You can only have one entry point to each dungeon).
X *	- If chained, the level used as reference for the chain
X *	  must be in this dungeon, must be previously defined, and
X *	  the level chained from must be "non-probabalistic" (ie.
X *	  have a 100% chance of existing).
X */
X
Xint
Xcheck_branch()
X{
X	int i;
X
X	if(!in_dungeon) {
X		yyerror("Branch defined outside of dungeon.");
X		return(0);
X	}
X
X	for(i = 0; i < n_dgns; i++)
X	    if(!strcmp(tmpdungeon[i].name, tmpbranch[n_brs].name)) {
X
X		yyerror("Reverse branching not allowed.");
X		return(0);
X	    }
X
X	if(tmpbranch[i].chain == -2) {
X
X		yyerror("Invaild branch chain reference.");
X		return(0);
X	} else if(tmpbranch[i].chain != -1) {	/* it is chained */
X
X	    if(tmplevel[tmpbranch[i].chain].chance != 100) {
X		yyerror("Branch cannot chain from a probabalistic level.");
X		return(0);
X	    }
X	}
X	return(1);	/* OK */
X}
X
X/*
X *	Output the dungon definition into a file.
X *
X *	The file will have the following format:
X *
X *	[ number of dungeons ]
X *	[ first dungeon struct ]
X *	[ levels for the first dungeon ]
X *	  ...
X *	[ branches for the first dungeon ]
X *	  ...
X *	[ second dungeon struct ]
X *	  ...
X */
X
Xvoid
Xoutput_dgn()
X{
X	int	nd, cl = 0, nl = 0,
X		    cb = 0, nb = 0;
X
X	if(++n_dgns <= 0) {
X
X	    yyerror("FATAL - no dungeons were defined.");
X	    exit(1);
X	}
X
X	fwrite((char *)(&n_dgns), sizeof(int), 1, stdout);
X	for(nd = 0; nd < n_dgns; nd++) {
X
X	    fwrite((char *)&tmpdungeon[nd], sizeof(struct tmpdungeon), 1,
X								stdout);
X
X	    nl += tmpdungeon[nd].levels;
X	    for(; cl < nl; cl++)
X		fwrite((char *)&tmplevel[cl], sizeof(struct tmplevel), 1,
X								stdout);
X
X	    nb += tmpdungeon[nd].branches;
X	    for(; cb < nb; cb++)
X		fwrite((char *)&tmpbranch[cb], sizeof(struct tmpbranch), 1,
X								stdout);
X	}
X}
END_OF_FILE
if test 16306 -ne `wc -c <'util/dgn_comp.y'`; then
    echo shar: \"'util/dgn_comp.y'\" unpacked with wrong size!
fi
# end of 'util/dgn_comp.y'
fi
echo shar: End of archive 86 \(of 108\).
cp /dev/null ark86isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \
21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \
41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 \
61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 \
81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 \
101 102 103 104 105 106 107 108 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 108 archives.
    echo "Now execute 'rebuild.sh'"
    rm -f ark10[0-8]isdone ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
