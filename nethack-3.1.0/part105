Path: uunet!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v16i113:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Part105/108
Message-ID: <4478@master.CNA.TEK.COM>
Date: 5 Feb 93 22:04:01 GMT
Sender: news@master.CNA.TEK.COM
Lines: 1935
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1664

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 16, Issue 113
Archive-name: nethack31/Part105
Supersedes: nethack3p9: Volume 10, Issue 46-108
Environment: Amiga, Atari, Mac, MS-DOS, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 105 (of 108)."
# Contents:  doc/recover.6 include/Window.h include/amiconf.h
#   include/pcconf.h src/were.c sys/amiga/NetHack.cnf
#   sys/amiga/amifont8.uu sys/amiga/charwin.uu
#   sys/amiga/splitter/amiout.h sys/atari/atari.cnf sys/unix/ioctl.c
#   sys/vms/Makefile.dat sys/vms/spec_lev.com util/dgn_main.c
#   win/X11/NetHack.ad win/X11/winval.c
# Wrapped by billr@saab on Wed Jan 27 16:09:32 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'doc/recover.6' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/recover.6'\"
else
echo shar: Extracting \"'doc/recover.6'\" \(3631 characters\)
sed "s/^X//" >'doc/recover.6' <<'END_OF_FILE'
X.TH RECOVER 6 "9 January 1993"
X.UC 4
X.SH NAME
Xrecover \- recover a NetHack game interrupted by disaster
X.SH SYNOPSIS
X.B recover
X[
X.B \-d
X.I directory
X]
X.I "base1 base2" ...
X.SH DESCRIPTION
X.PP
XOccasionally, a NetHack game will be interrupted by disaster
Xwhen the game or the system crashes.
XPrior to NetHack v3.1, these games were lost because various information
Xlike the player's inventory was kept only in memory.
XNow, all pertinent information can be written out to disk,
Xso such games can be recovered at the point of the last level change.
X.PP
XThe
X.I base
Xoptions tell
X.I recover
Xwhich files to process.
XEach base option specifies recovery of a separate game.
X.PP
XThe
X.B \-d
Xoption, which must be the first argument if it appears,
Xsupplies a directory which is the NetHack playground.
XIt overrides the value from NETHACKDIR, HACKDIR, or the directory
Xspecified by the game administrator during compilation
X(usually /usr/games/lib/nethackdir).
X.PP
XFor recovery to be possible,
X.I nethack
Xmust have been compiled with the INSURANCE option, and the run-time option
X.I checkpoint
Xmust also have been on.
XNetHack normally writes out files for levels as the player leaves them,
Xso they will be ready for return visits.
XWhen checkpointing, NetHack also writes out the level entered and
Xthe current game state on every level change.
XThis naturally slows level changes down somewhat.
X.PP
XThe level file names are of the form base.nn, where nn is an internal
Xbookkeeping number for the level.
XThe file base.0 is used for game identity, locking, and, when checkpointing,
Xfor the game state.
XVarious OSes use different strategies for constructing the base name.
XMicrocomputers use the character name, possibly truncated and modified
Xto be a legal filename on that system.
XMulti-user systems use the (modified) character name prefixed
Xby a user number to avoid conflicts,
Xor "xlock" if the number of concurrent players is being limited.
XIt may be necessary to look in the playground to find the correct
Xbase name of the interrupted game.
X.I recover
Xwill transform these level files into a save file of the same name as
X.I nethack would have used.
X.PP
XSince
X.I recover
Xmust be able to read and delete files from the playground
Xand create files in the save directory,
Xit has interesting interactions with game security.
XGiving ordinary players access to
X.I recover
Xthrough setuid or setgid is tantamount to leaving the playground
Xworld-writable,
Xwith respect to both cheating and messing up other players.
XFor a single-user system, this of course does not change anything,
Xso some of the microcomputer ports install
X.I recover
Xby default.
X.PP
XFor a multi-user system,
Xthe game administrator may want to arrange for all .0 files in the
Xplayground to be fed to recover when the host machine boots,
Xand handle game crashes individually.
XIf the user population is sufficiently trustworthy,
X.I recover
Xcan be installed with the same permissions the
X.I nethack
Xexecutable has.
XIn either case,
X.I recover
Xis easily compiled from the distribution utility directory.
X.SH NOTES
X.PP
XLike
X.I nethack
Xitself,
X.I recover
Xwill overwrite existing savefiles of the same name.
XSavefiles created by
X.I recover
Xare uncompressed;
Xthey may be compressed afterwards if desired,
Xbut even a compression-using
X.I nethack
Xwill find them in the uncompressed form.
X.SH "SEE ALSO"
Xnethack(6)
X.SH BUGS
X.PP
X.I recover
Xmakes no attempt to find out if a base name specifies a game in progress.
XIf multiple machines share a playground, this would be impossible to
Xdetermine.
X.PP
X.I recover
Xshould be taught to use the nethack playground locking mechanism to
Xavoid conflicts.
END_OF_FILE
if test 3631 -ne `wc -c <'doc/recover.6'`; then
    echo shar: \"'doc/recover.6'\" unpacked with wrong size!
fi
# end of 'doc/recover.6'
fi
if test -f 'include/Window.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/Window.h'\"
else
echo shar: Extracting \"'include/Window.h'\" \(2851 characters\)
sed "s/^X//" >'include/Window.h' <<'END_OF_FILE'
X/*	SCCS Id: @(#)Window.h	3.1	92/3/7	*/
X/* Copyright (c) Dean Luick, 1992				  */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#ifndef _Window_h
X#define _Window_h
X
X/****************************************************************
X *
X * Window widget
X *
X ****************************************************************/
X
X/* Resources:
X
X Name		     Class		RepType		Default Value
X ----		     -----		-------		-------------
X background	     Background		Pixel		XtDefaultBackground
X border		     BorderColor	Pixel		XtDefaultForeground
X borderWidth	     BorderWidth	Dimension	1
X destroyCallback     Callback		Pointer		NULL
X height		     Height		Dimension	0
X mappedWhenManaged   MappedWhenManaged	Boolean		True
X sensitive	     Sensitive		Boolean		True
X width		     Width		Dimension	0
X x		     Position		Position	0
X y		     Position		Position	0
X
X rows		     Width		Dimension	21
X columns	     Height		Dimension	80
X foreground	     Color		Pixel		XtDefaultForeground
X
X black		     Color		Pixel		"black"
X red		     Color		Pixel		"red"
X green		     Color		Pixel		"pale green"
X brown		     Color		Pixel		"brown"
X blue		     Color		Pixel		"blue"
X magenta	     Color		Pixel		"magenta"
X cyan		     Color		Pixel		"light cyan"
X gray		     Color		Pixel		"gray"
X //no color//
X orange		     Color		Pixel		"orange"
X bright_green	     Color		Pixel		"green"
X yellow		     Color		Pixel		"yellow"
X bright_blue	     Color		Pixel		"royal blue"
X bright_magenta	     Color		Pixel		"violet"
X bright_cyan	     Color		Pixel		"cyan"
X white		     Color		Pixel		"white"
X
X font		     Font		XFontStruct*	XtDefaultFont
X exposeCallback	     Callback		Callback	NULL
X callback	     Callback		Callback	NULL
X resizeCallback	     Callback		Callback	NULL
X*/
X
X/* define any special resource names here that are not in <X11/StringDefs.h> */
X
X#define XtNrows			"rows"
X#define XtNcolumns		"columns"
X#define XtNblack		"black"
X#define XtNred			"red"
X#define XtNgreen		"green"
X#define XtNbrown		"brown"
X#define XtNblue			"blue"
X#define XtNmagenta		"magenta"
X#define XtNcyan			"cyan"
X#define XtNgray			"gray"
X#define XtNorange		"orange"
X#define XtNbright_green		"bright_green"
X#define XtNyellow		"yellow"
X#define XtNbright_blue		"bright_blue"
X#define XtNbright_magenta	"bright_magenta"
X#define XtNbright_cyan		"bright_cyan"
X#define XtNwhite		"white"
X#define XtNexposeCallback	"exposeCallback"
X#define XtNresizeCallback	"resizeCallback"
X
X
Xextern XFontStruct *WindowFontStruct(/* Widget */);
Xextern Font WindowFont(/* Widget */);
X
X#define XtCWindowResource "WindowResource"
X#define XtCRows			"Rows"
X#define XtCColumns		"Columns"
X
X/* declare specific WindowWidget class and instance datatypes */
X
Xtypedef struct _WindowClassRec	*WindowWidgetClass;
Xtypedef struct _WindowRec	*WindowWidget;
X
X/* declare the class constant */
X
Xextern WidgetClass windowWidgetClass;
X
X#endif /* _Window_h */
END_OF_FILE
if test 2851 -ne `wc -c <'include/Window.h'`; then
    echo shar: \"'include/Window.h'\" unpacked with wrong size!
fi
# end of 'include/Window.h'
fi
if test -f 'include/amiconf.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/amiconf.h'\"
else
echo shar: Extracting \"'include/amiconf.h'\" \(3146 characters\)
sed "s/^X//" >'include/amiconf.h' <<'END_OF_FILE'
X/*	SCCS Id: @(#)amiconf.h	3.1	93/01/17	*/
X/* Copyright (c) Kenneth Lorber, Bethesda, Maryland, 1990, 1991, 1992, 1993. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#ifndef AMICONF_H
X#define AMICONF_H
X
X#undef abs		/* avoid using macro form of abs */
X#undef min		/* this gets redefined */
X#undef max		/* this gets redefined */
X
X#include <time.h>	/* get time_t defined before use! */
X
X#ifdef LATTICE		/* since Lattice can prevent re-inclusion */
X# include <stdlib.h>	/* and other things, including builtins */
X#endif
X
X#ifdef AZTEC_50
X# include <stdlib.h>
X# define AZTEC_C_WORKAROUND /* Bug which turns up in sounds.c. Bummer... */
X# define NO_SIGNAL	/* 5.0 signal handling doesn't like SIGINT...   */
X#endif
X
X#ifdef LATTICE		/* Lattice defines DEBUG when you use -d1 which */
X# ifdef DEBUG		/* we need for useful SnapShots, but DEBUG is   */
X#  undef DEBUG		/* used in several files to turn on things we   */
X# endif			/* don't want (e.g. eat.c), so we get rid of    */
X#endif			/* DEBUG unless asked for in a particular file  */
X
X#ifdef _DCC
X# include <stdlib.h>
X# define _SIZE_T
X#endif
X
Xtypedef long off_t;
X
X#define MICRO		/* must be defined to allow some inclusions */
X
X#ifndef	__SASC_60
X# define O_BINARY	0
X#endif
X
X/* Compile in New Intuition look for 2.0 */
X#ifdef	IDCMP_CLOSEWINDOW
X# define	INTUI_NEW_LOOK	1
X#endif
X
X#define MFLOPPY         /* You'll probably want this; provides assistance
X			 * for typical personal computer configurations
X			 */
X#define RANDOM
X
Xextern void FDECL(exit, (int));
Xextern void NDECL(CleanUp);
Xextern void FDECL(Abort, (long));
Xextern int NDECL(getpid);
Xextern char *FDECL(CopyFile, (const char *, const char *));
Xextern int NDECL(WindowGetchar);
X
Xextern boolean FromWBench;	/* how were we run? */
Xextern int ami_argc;
Xextern char **ami_argv;
X
X#ifndef MICRO_H
X# include "micro.h"
X#endif
X
X#ifndef PCCONF_H
X# include "pcconf.h"     /* remainder of stuff is almost same as the PC */
X# undef	OVERLAY
X#endif
X
X#define remove(x)       unlink(x)
X
X#ifdef LATTICE
X#define FFLUSH(fp) _flsbf(-1, fp)    /* Was fflush */
X#endif
X
X#ifdef AZTEC_C
X#define FFLUSH(fp) flsh_(fp, -1)     /* Was fflush */
Xextern FILE *FDECL(freopen, (const char *, const char *, FILE *));
Xextern char *FDECL(gets, (char *));
X#endif
X
X#ifdef _DCC
X#define FFLUSH(fp) fflush(fp)
X#endif
X
X#define msmsg		raw_printf
X
X/*
X * If AZTEC_C  we can't use the long cpath in vision.c....
X */
X#ifdef AZTEC_C
X# undef MACRO_CPATH
X#endif
X
X/*
X *  (Possibly) configurable Amiga options:
X */
X
X#define TEXTCOLOR		/* Use colored monsters and objects */
X#define HACKFONT		/* Use special hack.font */
X#define SHELL			/* Have a shell escape command (!) */
X#define MAIL			/* Get mail at unexpected occasions */
X#define DEFAULT_ICON "NetHack:default.icon"	/* private icon */
X#define AMIFLUSH		/* toss typeahead (select flush in .cnf) */
X/*#define AMIGA_WINDOWED_CORNLINE /* Use windows for pager, inventory, etc */
X
X/* new window system options */
X#define AMIGA_INTUITION		/* high power graphics interface */
X
X#ifdef	TEXTCOLOR
X# define	DEPTH	3
X#else
X# define	DEPTH	2
X#endif
X
X#define PORT_HELP	"nethack:amii.hlp"
X
X#undef	TERMLIB
X
X#endif /* AMICONF_H */
END_OF_FILE
if test 3146 -ne `wc -c <'include/amiconf.h'`; then
    echo shar: \"'include/amiconf.h'\" unpacked with wrong size!
fi
# end of 'include/amiconf.h'
fi
if test -f 'include/pcconf.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/pcconf.h'\"
else
echo shar: Extracting \"'include/pcconf.h'\" \(2387 characters\)
sed "s/^X//" >'include/pcconf.h' <<'END_OF_FILE'
X/*	SCCS Id: @(#)pcconf.h	3.1	92/10/23	*/
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#ifndef PCCONF_H
X#define PCCONF_H
X
X#define MICRO		/* always define this! */
X
X#ifdef MSDOS		/* some of this material is MS-DOS specific */
X
X/*
X *  The following options are somewhat configurable depending on
X *  your compiler.
X *  __GO32__ is defined automatically by the djgpp port of gcc.
X *  Manually define MOVERLAY if you are using Microsoft C version 7
X *  or greater.
X */
X
X#if !defined (__GO32__) && !defined(__BORLANDC__) && !defined(AMIGA)
X#define OVERLAY         /* MS DOS overlay manager - PGM */
X/* #define MOVERLAY /* Microsoft's MOVE overlay system (MSC >= 7.0) */
X#endif
X
X
X#ifndef __GO32__
X#define MFLOPPY         /* Support for floppy drives and ramdisks by dgk */
X#define SHELL           /* via exec of COMMAND.COM */
X#endif
X
X# define TERMLIB        /* enable use of termcap file /etc/termcap */
X			/* or ./termcap for MSDOS (SAC) */
X			/* compile and link in Fred Fish's termcap library, */
X			/* enclosed in TERMCAP.ARC, to use this */
X
X#define ANSI_DEFAULT    /* allows NetHack to run without a ./termcap */
X
X#define RANDOM		/* have Berkeley random(3) */
X
X#endif /* MSDOS configuration stuff */
X
X
X#define PATHLEN		64	/* maximum pathlength */
X#define FILENAME	80	/* maximum filename length (conservative) */
X#ifndef MICRO_H
X#include "micro.h"      /* contains necessary externs for [os_name].c */
X#endif
X
X#ifdef MFLOPPY
X#define FROMPERM        1      /* for ramdisk use */
X#define TOPERM          2      /* for ramdisk use */
X#define ACTIVE          1
X#define SWAPPED         2
X
Xstruct finfo {
X	int	where;
X	long	time;
X	long	size;
X};
Xextern struct finfo fileinfo[];
X#define ZFINFO  { 0, 0L, 0L }
X
X#endif /* MFLOPPY */
X
X/*
X *  The remaining code shouldn't need modification.
X */
X
X#ifndef SYSTEM_H
X#include "system.h"
X#endif
X#define index	strchr
X#define rindex	strrchr
X
X#ifndef AMIGA
X#include <time.h>
X#endif
X
X#ifdef RANDOM
X/* Use the high quality random number routines. */
X#define Rand()	random()
X#else
X#define Rand()	rand()
X#endif
X
X#ifndef TOS
X#define FCMASK	0660	/* file creation mask */
X#endif
X
X#include <fcntl.h>
X
X#define exit	msexit		/* do chdir first */
X
X#ifndef REDO
X#undef	Getchar
X#define Getchar nhgetch
X#endif
X
X#ifdef MSDOS
X#  define TEXTCOLOR /* */
X#endif
X
X#endif /* PCCONF_H */
END_OF_FILE
if test 2387 -ne `wc -c <'include/pcconf.h'`; then
    echo shar: \"'include/pcconf.h'\" unpacked with wrong size!
fi
# end of 'include/pcconf.h'
fi
if test -f 'src/were.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/were.c'\"
else
echo shar: Extracting \"'src/were.c'\" \(3100 characters\)
sed "s/^X//" >'src/were.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)were.c	3.1	93/01/17	*/
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include "hack.h"
X
X#ifdef OVL0
X
Xvoid
Xwere_change(mon)
Xregister struct monst *mon;
X{
X	register int pm = monsndx(mon->data);
X
X	if(is_were(mon->data))
X	    if(is_human(mon->data)) {
X		if(Protection_from_shape_changers) return;
X		if(!rn2(50-(night()*20)) || flags.moonphase == FULL_MOON) {
X		    new_were(mon);
X		    if(mons[pm].msound == MS_BARK && flags.soundok)
X			You("hear a %s howling at the moon.",
X			    pm == PM_HUMAN_WEREJACKAL ? "jackal" : "wolf");
X		}
X	    } else if(!rn2(30) || Protection_from_shape_changers) new_were(mon);
X}
X
X#endif /* OVL0 */
X#ifdef OVLB
X
Xstatic int FDECL(counter_were,(int));
X
Xstatic int
Xcounter_were(pm)
Xint pm;
X{
X	switch(pm) {
X	    case PM_WEREWOLF:	      return(PM_HUMAN_WEREWOLF);
X	    case PM_HUMAN_WEREWOLF:   return(PM_WEREWOLF);
X	    case PM_WEREJACKAL:	      return(PM_HUMAN_WEREJACKAL);
X	    case PM_HUMAN_WEREJACKAL: return(PM_WEREJACKAL);
X	    case PM_WERERAT:	      return(PM_HUMAN_WERERAT);
X	    case PM_HUMAN_WERERAT:    return(PM_WERERAT);
X	    default:		      return(0);
X	}
X}
X
Xvoid
Xnew_were(mon)
Xregister struct monst *mon;
X{
X	register int pm;
X
X	pm = counter_were(monsndx(mon->data));
X	if(!pm) {
X	    impossible("unknown lycanthrope %s.", mon->data->mname);
X	    return;
X	}
X
X	if(canseemon(mon))
X	    pline("%s changes into a %s.", Monnam(mon),
X			Hallucination ? rndmonnam() :
X			is_human(&mons[pm]) ? "human" :
X			mons[pm].mname+4);
X
X	mon->data = &mons[pm];
X	if (mon->msleep || !mon->mcanmove) {
X	    /* transformation wakens and/or revitalizes */
X	    mon->msleep = 0;
X	    mon->mfrozen = 0;	/* not asleep or paralyzed */
X	    mon->mcanmove = 1;
X	}
X	/* regenerate by 1/4 of the lost hit points */
X	mon->mhp += (mon->mhpmax - mon->mhp) / 4;
X	newsym(mon->mx,mon->my);
X#ifdef MUSE
X	mon_break_armor(mon);
X	possibly_unwield(mon);
X#endif
X}
X
Xboolean
Xwere_summon(ptr,yours)	/* were-creature (even you) summons a horde */
Xregister struct permonst *ptr;
Xregister boolean yours;
X{
X	register int i, typ, pm = monsndx(ptr);
X	register struct monst *mtmp;
X	boolean success = FALSE;
X
X	if(Protection_from_shape_changers && !yours)
X		return FALSE;
X	for(i = rnd(5); i > 0; i--) {
X	   switch(pm) {
X
X		case PM_WERERAT:
X		case PM_HUMAN_WERERAT:
X			typ = rn2(3) ? PM_SEWER_RAT : rn2(3) ? PM_GIANT_RAT : PM_RABID_RAT ;
X			break;
X		case PM_WEREJACKAL:
X		case PM_HUMAN_WEREJACKAL:
X			typ = PM_JACKAL;
X			break;
X		case PM_WEREWOLF:
X		case PM_HUMAN_WEREWOLF:
X			typ = rn2(5) ? PM_WOLF : PM_WINTER_WOLF ;
X			break;
X		default:
X			continue;
X	    }
X	    mtmp = makemon(&mons[typ], u.ux, u.uy);
X	    if (mtmp) success = TRUE;
X	    if (yours && mtmp)
X		(void) tamedog(mtmp, (struct obj *) 0);
X	}
X	return success;
X}
X
X#ifdef POLYSELF
Xvoid
Xyou_were() {
X	char qbuf[80];
X	if(u.umonnum == u.ulycn) return;
X	if(Polymorph_control) {
X	    Sprintf(qbuf,"Do you want to change into a %s? ", mons[u.ulycn].mname+4);
X	    if(yn(qbuf) == 'n') return;
X	}
X	(void) polymon(u.ulycn);
X}
X#endif
X
X#endif /* OVLB */
X
X/*were.c*/
END_OF_FILE
if test 3100 -ne `wc -c <'src/were.c'`; then
    echo shar: \"'src/were.c'\" unpacked with wrong size!
fi
# end of 'src/were.c'
fi
if test -f 'sys/amiga/NetHack.cnf' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/amiga/NetHack.cnf'\"
else
echo shar: Extracting \"'sys/amiga/NetHack.cnf'\" \(3224 characters\)
sed "s/^X//" >'sys/amiga/NetHack.cnf' <<'END_OF_FILE'
X# A '#' at the beginning of a line means the rest of the line is a comment.
X
X# This configuration file is set up for two cases, a person with a hard
X# disk as drive DH0:, and 1 person with two floppy disks.  If several people
X# are to use it, don't specify "name" or personal prefences like "dogname"
X# or "packorder" in OPTIONS.
X
X# To change configuration, comment out the unwanted configurations, and
X# remove the comment from the configuration you want.
X
X# Some options to set personal preferences.  If several people are to
X# use it, options like these should not be set here - use the command line
X# (if playing from CLI) or ToolTypes (if playing from WorkBench)
X#OPTIONS=name:Janet-V,female,dogname:Fido,fruit:apricot
X#OPTIONS=packorder:")[%?+/=!(*0_`,scores:10t/2a,noverbose
X
X# Other general options
X#OPTIONS=time,rest_on_space,nopickup
X
X# The search path for files like record, help, opthelp, etc.
X#PATH=NetHack:
XPATH=NetHack:playground
X
X# My own setup
X#OPTIONS=name:Rhialto,catname:Killie,time,nopickup
X
X# A hard disk configuration.
X#
X#HACKDIR=DH0:/games/hack
X# The ";n" means don't prompt to insert a disk.
X#SAVE=;n
X#LEVELS=DH0:games/hack/bones
X#SAVE=DH0:/games/hack/bones;n
X
X# A development HD configuration
X#
X#HACKDIR=NetHack:
X#LEVELS=NetHack:levels
X#SAVE=NetHack:save;n
X
X# A 2-floppy, 2-megabyte configuration.
X#
X#HACKDIR=NetHack:
X#LEVELS=df1:
X#SAVE=df1:save
X
X# A minimal configuration
XHACKDIR=NetHack:
XLEVELS=Nethack:levels
XSAVE=Nethack:save
X
X# *** CHARACTER GRAPHICS ***
X#
X# The 69 GRAPHICS characters (0-68) are:
X#
X# stone,
X# walls: vertical, horizontal,
X#	 4 corners: top left, top right, bottom left, bottom right,
X#	 cross wall,
X#	 4 T walls: upward, downward, left, right,
X# doors: no door,
X#	 open doors: vertical, horizontal,
X#	 closed doors: vertical, horizontal,
X# floor,
X# corridors: unlit, lit,
X# stairs up, stairs down, ladder up, ladder down,
X# trap, web, altar, throne, sink, fountain, pool/moat, ice, lava,
X# lowered drawbridge: vertical, horizontal,
X# raised drawbridge: vertical, horizontal,
X# air, cloud, water,
X# 4 beams: vertical, horizontal, left slant, right slant,
X# digging beam, camera flash beam, left boomerang, right boomerang,
X# 4 magic shield display symbols,
X# 8 swallowed: top left/middle/right, mid left/right, bottom left/mid/right,
X# 9 explosion: [3 rows (top, middle, bottom) of 3 characters]
X#
X# If you specify fewer than 69 ASCII values, the remaining characters will be
X# set to their respective defaults:
X#	   ' '  |   -   -   -   -   -   -   -   -
X#           |   |   .   -   |   +   +   .   #   #
X#	    <   >   <   >   ^   "   _   \   #   {
X#	    }   .   }   .   .   #   #  ' '  #   }
X#	    |   -   \   /   *   !   )   (   0   #
X#	    @   *   /   -   \   |   |   \   -   /
X#	    /   -   \   |  ' '  |   \   -   /
X#
X# Note that the hack.font has special graphics characters from 192 on.
X
X# An example using the hack.font graphics character set:
XGRAPHICS = 032 192 193 194 195 196 197 198 216 214 \
X	   215 213 046 193 192 198 198 046 229 035 \
X	   060 062 060 062 094 034 095 092 035 123 \
X	   125 042 125 042 042 035 035 046 035 125 \
X	   192 193 092 047 042 033 123 125 064 038 \
X	   042 035 047 201 092 200 200 092 201 047 \
X	   230 234 231 236 212 237 232 235 233
END_OF_FILE
if test 3224 -ne `wc -c <'sys/amiga/NetHack.cnf'`; then
    echo shar: \"'sys/amiga/NetHack.cnf'\" unpacked with wrong size!
fi
# end of 'sys/amiga/NetHack.cnf'
fi
if test -f 'sys/amiga/amifont8.uu' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/amiga/amifont8.uu'\"
else
echo shar: Extracting \"'sys/amiga/amifont8.uu'\" \(3008 characters\)
sed "s/^X//" >'sys/amiga/amifont8.uu' <<'END_OF_FILE'
Xbegin 777 8
XM```#\P`````````!``````````````(-```#Z0```@UP_TYU```````````,
XM`````!H/@``!``````````````````````````````````````````!&140`
XM```````````,`````!H`````!\0`"`!```@`!@`!```@_P```&X`B```!*X`
XM```````````8;&P8`#@8##````````,\&#P\''X<?CP\```,`#`\?!C\//C^
XM_CQF?@[F\(+&./PX_#Q^9L/&P\/^/,`\$``8`.``#@`<`.`8!N`X````````
XM``@````````.&'!RS,'_9@```&9F9A@8````&!@8```8&&+`9@!F9A@`&!@`
XMJ!7!@Z+!J!4`/&QL/L9L&!@89A@````&9CAF9CQ@,&9F9A@8&``89L8\9F9L
XM9F9F9A@&9F#&YFQF;&9F6F;#QF;#QC!@##@`&`!@``8`-@!@``!@&```````
XM```8````````&!@8G#-C_V8```!F9F8\&````!@8&```&#QE8V8`9F88`!@8
XM`"/$`\`C+"O4`#P`_F#,:#`P##P8````#&X8!@9L?&`&9F88&#!^#`;>/&;`
XM9F!@P&88!FQ@[O;&9L9F<!AF9L8\9HPP,`QL``P\;#PV/#`[;#@&9AAF?#S<
XM/>P^/F9F8V-F?A@8&`#,-O]F_W_^9^;G/!@````8&!@``!AF8#9G_^;G&``8
XM&&QJ5B9D:3QIE@`8`&P\&'8`,`S_?@!^`!A^&!P<S`9\##P^``!@``8,WF9\
XMP&9X>,Y^&`9X8/[>QGS&?#@89F;6&#P8,!@,Q@``!G9F;F9X9G88!FP8=V9F
XM9F9V8!AF9FLV9DQP&`X`,QS_9@!@!F`&`&88_Q_X'_C_``#;PWX;8``&`!__
XM^/\`G#EKUO@KVEL`&`#^!C#<`#`,/!@````P=A@P!OX&9AAF!@``,``,&-Y^
XM9L!F8&#&9AAF;&+6SL9@QFP.&&8\_CP8,C`,#````!YF8&9^,&9F&`9X&&MF
XM9F9F9CP89F9K'&88&!@8`,P<_V8`8`9@!@!F&``8&```&```P]MF[&``!@`8
XM&!@`;&O6G#DK^#?L````;'QFS``8&&88&``88&889F8,9F889@P8&!A^&`#`
XMPV9F;&9@9F889F9FQL9L8&QF9AAF/.YF&&8P!@P```!F9F9F8#`\9A@&;!AC
XM9F9\/F`&&F8\-C8\,A@8&``S-O]F_V?F?_[GPQ@`&!@``!AS`&889C9GY^;_
XM&!@8```F9&I6/&FT+0`8`&P8QG8`##```!@`&,`\?GX\'CP\&#PX&!@,`#`8
XM>,/\//C^\#YF?CSF_L;&./`\XSP\/AC&PSS^/`,\````.SP\.SQXQN8\9N8\
XM8V8\8`;P?`P[&#9C&'X.&'``S&/_9@!F9@``9L,8`!@8```8G!@\&&9C9F9F
XM`!@8&````\`CQ"PC08(````````````````P```````````````````P````
XM````````````````````````!@````````````````#^`````````'P``#P`
XM`````/`'`````````'```````#/!_V8`9F8``&8`&``8&```&```&!@`P&9F
XM9@`8&!@``,&#J!7!HL&#````"``(``@`$``(`!@`"``@``@`*``(`#``"``X
XM``@`0``(`$@`"`!0``@`6``(`&``"`!H``@`<``(`'@`"`"```@`B``(`)``
XM"`"8``@`H``(`*@`"`"P``@`N``(`,``"`#(``@`T``(`-@`"`#@``@`Z``(
XM`/``"`#X``@!```(`0@`"`$0``@!&``(`2``"`$H``@!,``(`3@`"`%```@!
XM2``(`5``"`%8``@!8``(`6@`"`%P``@!>``(`8``"`&(``@!D``(`9@`"`&@
XM``@!J``(`;``"`&X``@!P``(`<@`"`'0``@!V``(`>``"`'H``@!\``(`?@`
XM"`(```@""``(`A``"`(8``@"(``(`B@`"`(P``@".``(`D``"`)(``@"4``(
XM`E@`"`)@``@":``(`G``"`)X``@"@``(`H@`"`*0``@"F``(`J``"`*H``@"
XML``(`K@`"`+```@"R``(`M``"`+8``@"X``(`N@`"`+P``@"^``(`P``"`,`
XM``@#```(`P``"`,```@#```(`P``"`,```@#```(`P``"`,```@#```(`P``
XM"`,```@#```(`P``"`,(``@#```(`P``"`,```@#```(`P``"`,```@#```(
XM`P``"`,```@#```(`P``"`,```@#```(`P``"`,```@#```(``@`"``0``@`
XM&``(`"``"``H``@`,``(`#@`"`!```@`2``(`%``"`!8``@`8``(`&@`"`!P
XM``@`>``(`(``"`"(``@`D``(`)@`"`"@``@`J``(`+``"`"X``@`P``(`,@`
XM"`#0``@`V``(`.``"`#H``@`\``(`/@`"`,0``@#&``(`R``"`,H``@#,``(
XM`S@`"`-```@#2``(`U``"`-8``@#8``(`V@`"`-P``@#>``(`X``"`.(``@#
XMD``(`Y@`"`.@``@#J``(`[``"`.X``@#P``(`\@`"`/0``@#```(`P``"`'8
XM``@!X``(`>@`"`'P``@!^``(`@``"`/8``@#X``(`^@`"`/P``@#^``(!```
XM"`0(``@$$``(!!@`"`0@``@$*``(!#``"`0X``@#```(`P``"`,```@#```(
XM`P``"`,```@#```(`P``"`,```@#```(`P``"`,```@#```(`M@`"`+@``@"
XMZ``(`O``"`+X``@````(``````/L````!``````````.````1````%P```!B
X(`````````_+X
X`
Xend
END_OF_FILE
if test 3008 -ne `wc -c <'sys/amiga/amifont8.uu'`; then
    echo shar: \"'sys/amiga/amifont8.uu'\" unpacked with wrong size!
fi
# end of 'sys/amiga/amifont8.uu'
fi
if test -f 'sys/amiga/charwin.uu' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/amiga/charwin.uu'\"
else
echo shar: Extracting \"'sys/amiga/charwin.uu'\" \(3696 characters\)
sed "s/^X//" >'sys/amiga/charwin.uu' <<'END_OF_FILE'
Xbegin 777 char.pw
XM4&]W97)7:6YD;W=S('8R+C5C(*DQ.3@W+"`Q.3@X(&)Y($E.3U9!5%)/3DE#
XM4RP@24Y#+B`@("`@("`@("`@("`@("`@("`@("`@```"K`````E```#\````
XM`0`````!``````=C:&%R+F,``"FPH``````"@`#(``,``8````\``````"3A
XM^````````````````@````$``````0`````!`````!@```#@X.#0<%#``(``
XML`#P`(!04/#P```````!``(0"``@`D``!0`%_____P``````````````````
XM```````````````-`"7D6```````!E1Y<&5?```!`)L`&`$+`&P`!0`%____
XM_P```!%0:6-K(&$@0VAA<F%C=&5R```IOK@`B0`.`'H`"@````,``0`IO(0`
XM`````"=*H`````````````$`*"8H_____P,```4`*;R4````````````>P``
XM`'L`"P````L```````````,``0``&P`!```````E\6@`````````"D)A<F)A
XM<FEA;@`````*`````0`EY:``)>@X`"7K0``G.C``)U7@`"=Z<`````$`````
XM`0`````!``````0G0B<``````0`````!```IP!``B0`;`'H`"@````,``0`I
XMON0``````"?8.`````````````(`*"9X_____P,```4`*;[T````````````
XM>P```'L`"P````L```````````,``0``,``!```````GVV``````````!$5L
XM9@`````*`````0`GW7``)^5@`"@$*``H(5``*"-0`"FRZ`````$``````0``
XM```!``````0G12<``````0`````!```IP&@`B0`H`'H`"@````,``0`IP#P`
XM`````"FS(`````````````,`*;S`_____P,```4`*<!,````````````>P``
XM`'L`"P````L```````````,``0``)``!```````IO+``````````!TMN:6=H
XM=``````*`````0`IO.@`*;\0`"F_(``IOS``*;]``"F_4`````$``````0``
XM```!``````0G2R<``````0`````!```IP8``"0`.`'H`"@````,``0`IP)0`
XM`````"G`P`````````````0`*<#X_____P,```4`*<"D````````````>P``
XM`'L`"P````L```````````,``0``$``!```````IP.``````````#4%R8VAE
XM;VQO9VES=``````*`````0`IP2``*<$P`"G!0``IP5``*<%@`"G!<`````$`
XM`````0`````!``````0G02<``````0`````!```IPI``"0`;`'H`"@````,`
XM`0`IP:P``````"G!V`````````````4`*<((_____P,```4`*<&\````````
XM````>P```'L`"P````L```````````,``0``(0`!```````IP?@`````````
XM"$-A=F5M86X`````"@````$`*<(P`"G"0``IPE``*<)@`"G"<``IPH`````!
XM``````$``````0`````$)T,G``````$``````0``*<.@``D`*`!Z``H````#
XM``$`*<*\```````IPN@````````````&`"G#&/____\#```%`"G"S```````
XM`````'L```![``L````+```````````#``$``",``0``````*<,(````````
XM``=(96%L97(`````"@````$`*<-``"G#4``IPV``*<-P`"G#@``IPY`````!
XM``````$``````0`````$)T@G``````$``````0``*<2P``D`-0!Z``H````#
XM``$`*</,```````IP_@````````````'`"G$*/____\#```%`"G#W```````
XM`````'L```![``L````+```````````#``$``"0``0``````*<08````````
XM``=0<FEE<W0`````"@````$`*<10`"G$8``IQ'``*<2``"G$D``IQ*`````!
XM``````$``````0`````$)U`G``````$``````0``*<7``(D`-0!Z``H````#
XM``$`*<3<```````IQ0@````````````(`"G%./____\#```%`"G$[```````
XM`````'L```![``L````+```````````#``$``"@``0``````*<4H````````
XM``92;V=U90`````*`````0`IQ6``*<5P`"G%@``IQ9``*<6@`"G%L`````$`
XM`````0`````!``````0G4B<``````0`````!```IQM``B0!"`'H`"@````,`
XM`0`IQ>P``````"G&&`````````````D`*<9(_____P,```4`*<7\````````
XM````>P```'L`"P````L```````````,``0``(@`!```````IQC@`````````
XM"%1O=7)I<W0`````"@````$`*<9P`"G&@``IQI``*<:@`"G&L``IQL`````!
XM``````$``````0`````$)U0G``````$``````0``*<?@``D`0@!Z``H````#
XM``$`*<;\```````IQR@````````````*`"G'6/____\#```%`"G'#```````
XM`````'L```![``L````+```````````#``$``"$``0``````*<=(````````
XM``A386UU<F%I``````H````!`"G'@``IQY``*<>@`"G'L``IQ\``*<?0````
XM`0`````!``````$`````!"=3)P`````!``````$``"G)"``)`%X`^@`*````
XM`P`!`"G(#```````*<@X```````````````IR(#_____`0``!0`IR!P`````
XM``````#[````^P`+````"P```````````0`!```.``$``````"G(6```````
XM```=4&EC:R!A(%)A;F1O;2!#:&%R86-T97(@5'EP90`````*`````0`IR*@`
XM*<BX`"G(R``IR-@`*<CH`"G(^`````$``````0`````!``````(Q``````$`
XM`````0``*<H@``D`3P!Z``H````#``$`*<DT```````IR6`````````````,
XM`"G)F/____\#```%`"G)1````````````'L```![``L````+```````````#
XM``$``!T``0``````*<F```````````E686QK>7)I90`````*`````0`IR<``
XM*<G0`"G)X``IR?``*<H``"G*$`````$``````0`````!``````0G5B<`````
XM`0`````!````````B0!/`'H`"@````,``0`IRDP``````"G*>```````````
XM``T`*<JH_____P,```4`*<I<````````````>P```'L`"P````L`````````
XM``,``0``)@`!```````IRI@`````````!U=I>F%R9``````*`````0`IRM``
XM*<K@`"G*\``IRP``*<L0`"G+(`````$``````0`````!``````0G5R<`````
X'`0`````!```I
X`
Xend
END_OF_FILE
if test 3696 -ne `wc -c <'sys/amiga/charwin.uu'`; then
    echo shar: \"'sys/amiga/charwin.uu'\" unpacked with wrong size!
fi
# end of 'sys/amiga/charwin.uu'
fi
if test -f 'sys/amiga/splitter/amiout.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/amiga/splitter/amiout.h'\"
else
echo shar: Extracting \"'sys/amiga/splitter/amiout.h'\" \(2842 characters\)
sed "s/^X//" >'sys/amiga/splitter/amiout.h' <<'END_OF_FILE'
X/*    SCCS Id: @(#)amiout.h		3.1   91/15/09
X/*    Copyright (c) Kenneth Lorber, Bethesda, Maryland, 1990	  */
X/* NetHack may be freely redistributed.  See license for details. */
X/* This version: $Revision: 1.2 $ */
X/* Last edit: $Date: 92/02/09 12:38:04 $ */
X
X/*
X * This is essentially a.out.h for the Amiga object and load file format,
X * as extended by Lattice (now SAS, then adopted by CBM, and extended again).
X */
X/* object file structure */
X	
X	/* these blocks are of the form: ID,N,N data longs */
X#define HUNK_UNIT	999
X#define HUNK_NAME	1000
X#define HUNK_DEBUG	1009
X	/* these blocks are of the form: ID,N*,N data longs. */
X	/* If (N* && 0xc0000000 == 0xc0000000) then an additional long appears*/
X#define HUNK_CODE	1001
X#define HUNK_DATA	1002
X#define HUNK_BSS	1003
X# define MEM_OBJ_ANY	 0
X# define MEM_OBJ_FAST	(1<<31)
X# define MEM_OBJ_CHIP	(1<<30)
X# define MEM_OBJ_EXTEND 0xc0000000
X	/* these blocks are of the form: ID, (N!=0,long,N data longs)*, 0 */
X#define HUNK_RELOC32	1004
X#define HUNK_RELOC16	1005
X#define HUNK_RELOC8	1006
X/*#define HUNK_RELOC32s ???		/* ADOS 2.0 */
X#define HUNK_DRELOC32	0x3f7		/* Lattice & ADOS 2.0 */
X#define HUNK_DRELOC16	0x3f8		/* Lattice & ADOS 2.0 */
X#define HUNK_DRELOC8	0x3f9		/* Lattice & ADOS 2.0 */
X	/* these blocks are of the form: ID,(symbol data unit)*,0 */
X#define HUNK_EXT	1007
X#define		EXT_SYMB	0	/* SDU format 0 */
X#define		EXT_DEF		1	/* SDU format 1 */
X#define		EXT_ABS		2	/* SDU format 1 */
X#define		EXT_RES		3	/* SDU format 1 */
X#define		EXT_REF32	129	/* SDU format 2 */
X#define		EXT_COMMON	130	/* SDU format 3 */
X#define		EXT_REF16	131	/* SDU format 2 */
X#define		EXT_REF8	132	/* SDU format 2 */
X#define		EXT_DREF32	133	/* ADOS 2.0 */
X#define		EXT_DREF16	0x86	/* SDU format 2 Lattice - data ref */
X#define		EXT_DREF8	135	/* ADOS 2.0 */
X#define	HUNK_SYMBOL	1008
X	/* these blocks are of the form: ID */
X#define HUNK_END	1010
X
X/* load file structure */
X	/* these blocks are of the form:
X	 * ID,(N!=0,X,X longs)*,0,SZ,first,last,last-first+1 sizes
X	 */
X#define HUNK_HEADER	1011
X	/* these blocks are of the form:
X	 * ID,SZ,M+2,M+1 longs of 0,overlay data table [(O+1)*8+M+1 longs]
X	 * where M=tree depth (root=0), O=# overlays-1 [zero base]
X	 */
X#define HUNK_OVERLAY	1013
X	/* these blocks are of the form: ID */
X#define HUNK_BREAK	1014
X
X/* link library structure */
X		/* NB - this is a Lattice extension.  It is perfectly
X		 * legal to concatenate .o files and call it a library.
X		 * Now adopted by ADOS 2.0
X		 */
X	/* these blocks are of the form:
X	 * ID, size in longs of the code/data/etc following
X	 */
X#define LIB_HUNK	1018
X	/* these blocks are of the form:
X	 * ID, size, 16-bit size of string table, string table, reloc info
X	 */
X#define LIB_INDEX	1019
X	/* the ADOS 2.0 book defines them this way -
X	 * it's wrong, right?
X	 */
X/* #define HUNK_LIB 1019 */
X/* #define HUNK_INDEX 1020 */
END_OF_FILE
if test 2842 -ne `wc -c <'sys/amiga/splitter/amiout.h'`; then
    echo shar: \"'sys/amiga/splitter/amiout.h'\" unpacked with wrong size!
fi
# end of 'sys/amiga/splitter/amiout.h'
fi
if test -f 'sys/atari/atari.cnf' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/atari/atari.cnf'\"
else
echo shar: Extracting \"'sys/atari/atari.cnf'\" \(3327 characters\)
sed "s/^X//" >'sys/atari/atari.cnf' <<'END_OF_FILE'
X# A '#' at the beginning of a line means the rest of the line is a comment.
X#
X# This configuration file is set up for two cases, for a hard disk
X# (as drive C:), and for one (double sided) floppy disk.
X#
X# To change the configuration, comment out the unwanted lines, and
X# uncomment the configuration you want.
X
X
X# *** OPTIONS ***
X#
X# If you want people to play NetHack over the modem, you should probably
X# uncomment the following line:
X#
X#OPTIONS=!BIOS,number_pad,nocolor
X#
X# Some options to set personal preferences.  Uncomment and change these to
X# suit your personal preference.  If several people are to use the same
X# configuration, options like these should not be set.
X#
X#OPTIONS=name:Janet-V,female,dogname:Fido,catname:Morris,fruit:apricot
X#OPTIONS=packorder:")[%?+/=!(*0_`,scores:10 top/2 around/own
X#
X#
X# Other general options.  You might also set "silent" so as not to attract
X# the boss's attention.
X#
XOPTIONS=BIOS,time,rest_on_space,nopickup
X
X# Color: if you have a color monitor and *don't* want colors, 
X# comment out the following line. (Mono users don't get color no matter what.)
X#
X#OPTIONS=nocolor
X
X# *** HARD DISK CONFIGURATION ***
X#
XHACKDIR=c:\nh31\games
X#
X#   LEVELS and SAVE default to HACKDIR
X#
XLEVELS=c:\nh31\games
X#   appending a ";n" to SAVE means don't prompt to insert a disk.
XSAVE=c:\nh31\games;n
X#
X# Using a ramdisk speeds things up.
X#
X# NOTE: the RAMDISK *must* be on a different drive from HACKDIR, LEVELS, and
X# SAVE. If you're already keeping your LEVELS on a ramdisk, the RAMDISK=
X# variable is redundant.
X#
X#RAMDISK=m:
X
X
X# *** 1-FLOPPY CONFIGURATION ***
X#
X#HACKDIR=a:
X#LEVELS=a:
X#SAVE=a:
X#RAMDISK=m:
X
X
X# *** CHARACTER GRAPHICS ***
X#
X# The 69 GRAPHICS characters (0-68) are:
X#
X# stone,
X# walls: vertical, horizontal,
X#	 4 corners: top left, top right, bottom left, bottom right,
X#	 cross wall,
X#	 4 T walls: upward, downward, left, right,
X# doors: no door,
X#	 open doors: vertical, horizontal,
X#	 closed doors: vertical, horizontal,
X# floor,
X# corridors: unlit, lit,
X# stairs up, stairs down, ladder up, ladder down,
X# trap, web, altar, throne, sink, fountain, pool/moat, ice, lava,
X# lowered drawbridge: vertical, horizontal,
X# raised drawbridge: vertical, horizontal,
X# air, cloud, water,
X# 4 beams: vertical, horizontal, left slant, right slant,
X# digging beam, camera flash beam, left boomerang, right boomerang,
X# 4 magic shield display symbols,
X# 8 swallowed: top left/middle/right, mid left/right, bottom left/mid/right,
X# 9 explosion: [3 rows (top, middle, bottom) of 3 characters]
X#
X# If you specify fewer than 69 ASCII values, the remaining characters will be
X# set to their respective defaults:
X#	   ' '  |   -   -   -   -   -   -   -   -
X#           |   |   .   -   |   +   +   .   #   #
X#	    <   >   <   >   ^   "   _   \   #   {
X#	    }   .   }   .   .   #   #  ' '  #   }
X#	    |   -   \   /   *   !   )   (   0   #
X#	    @   *   /   -   \   |   |   \   -   /
X#	    /   -   \   |  ' '  |   \   -   /
X#
X# An example using the hackfnt.prg font:
X#GRAPHICS= 032 217 218 194 195 192 193 216 197 196 \
X#	   199 198 202 201 201 200 200 202 203 203 \
X#	   210 211 212 213 207 206 209 208 205 204 \
X#	   214 202 214 042 042 215 215 046 035 214 \
X#	   058 045 092 047 042 033 041 040 048 035 \
X#	   064 042 194 218 195 217 217 192 218 193 \
X#	   047 045 092 058 032 058 092 045 047
END_OF_FILE
if test 3327 -ne `wc -c <'sys/atari/atari.cnf'`; then
    echo shar: \"'sys/atari/atari.cnf'\" unpacked with wrong size!
fi
# end of 'sys/atari/atari.cnf'
fi
if test -f 'sys/unix/ioctl.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/unix/ioctl.c'\"
else
echo shar: Extracting \"'sys/unix/ioctl.c'\" \(3582 characters\)
sed "s/^X//" >'sys/unix/ioctl.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)ioctl.c	3.1	90/22/02
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X/* This cannot be part of hack.tty.c (as it was earlier) since on some
X   systems (e.g. MUNIX) the include files <termio.h> and <sgtty.h>
X   define the same constants, and the C preprocessor complains. */
X
X#include "hack.h"
X
X#if defined(BSD_JOB_CONTROL) || defined(_BULL_SOURCE)
X# ifdef HPUX
X#include <bsdtty.h>
X# else
X#  if defined(AIX_31) && !defined(_ALL_SOURCE)
X#   define _ALL_SOURCE	/* causes struct winsize to be present */
X#  endif
X#  if defined(_BULL_SOURCE)
X#   include <termios.h>
Xstruct termios termio;
X#   undef TIMEOUT		/* defined in you.h and sys/tty.h */
X#   include <sys/tty.h>		/* define winsize */
X#   include <sys/ttold.h>	/* define struct ltchars */
X#   include <sys/bsdioctl.h>	/* define TIOGWINSZ */
X#  else
X#   include <sgtty.h>
X#  endif
X# endif
Xstruct ltchars ltchars;
Xstruct ltchars ltchars0 = { -1, -1, -1, -1, -1, -1 }; /* turn all off */
X#else
X
X# ifdef POSIX_TYPES
X#include <termios.h>
Xstruct termios termio;
X#  ifdef BSD
X#include <sys/ioctl.h>
X#  endif
X# else
X#include <termio.h>	/* also includes part of <sgtty.h> */
X#  if defined(TCSETS) && !defined(AIX_31)
Xstruct termios termio;
X#  else
Xstruct termio termio;
X#  endif
X# endif
X# ifdef AMIX
X#include <sys/ioctl.h>
X# endif /* AMIX */
X#endif
X
X#ifdef SUSPEND	/* BSD isn't alone anymore... */
X#include	<signal.h>
X#endif
X
X#if defined(TIOCGWINSZ) && (defined(BSD) || defined(ULTRIX) || defined(AIX_31) || defined(_BULL_SOURCE) || defined(SVR4))
X#define USE_WIN_IOCTL
X#include "termcap.h"	/* for LI and CO */
X#endif
X
X#ifdef AUX
Xvoid *
Xcatch_stp ( )
X{
X    signal ( SIGTSTP , SIG_DFL ) ;
X    dosuspend ( ) ;
X}
X#endif /* AUX */
X
X#ifdef USE_WIN_IOCTL
Xvoid
Xgetwindowsz()
X{
X    /*
X     * ttysize is found on Suns and BSD
X     * winsize is found on Suns, BSD, and Ultrix
X     */
X    struct winsize ttsz;
X
X    if (ioctl(fileno(stdin), (int)TIOCGWINSZ, (char *)&ttsz) != -1) {
X	/*
X	 * Use the kernel's values for lines and columns if it has
X	 * any idea.
X	 */
X	if (ttsz.ws_row)
X	    LI = ttsz.ws_row;
X	if (ttsz.ws_col)
X	    CO = ttsz.ws_col;
X    }
X}
X#endif
X
Xvoid
Xgetioctls()
X{
X#ifdef BSD_JOB_CONTROL
X	(void) ioctl(fileno(stdin), (int) TIOCGLTC, (char *) &ltchars);
X	(void) ioctl(fileno(stdin), (int) TIOCSLTC, (char *) &ltchars0);
X#else
X# ifdef POSIX_TYPES
X	(void) tcgetattr(fileno(stdin), &termio);
X# else
X#  if defined(TCSETS) && !defined(AIX_31)
X	(void) ioctl(fileno(stdin), (int) TCGETS, &termio);
X#  else
X	(void) ioctl(fileno(stdin), (int) TCGETA, &termio);
X#  endif
X# endif
X#endif
X#ifdef USE_WIN_IOCTL
X	getwindowsz();
X#endif
X#ifdef AUX
X	( void ) signal ( SIGTSTP , catch_stp ) ;
X#endif
X}
X
Xvoid
Xsetioctls()
X{
X#ifdef BSD_JOB_CONTROL
X	(void) ioctl(fileno(stdin), (int) TIOCSLTC, (char *) &ltchars);
X#else
X# ifdef POSIX_TYPES
X	(void) tcsetattr(fileno(stdin), TCSADRAIN, &termio);
X# else
X#  if defined(TCSETS) && !defined(AIX_31)
X	(void) ioctl(fileno(stdin), (int) TCSETSW, &termio);
X#  else
X	(void) ioctl(fileno(stdin), (int) TCSETAW, &termio);
X#  endif
X# endif
X#endif
X}
X
X#ifdef SUSPEND		/* Does not imply BSD */
Xint
Xdosuspend()
X{
X#ifdef SIGTSTP
X	if(signal(SIGTSTP, SIG_IGN) == SIG_DFL) {
X		suspend_nhwindows(NULL);
X		(void) signal(SIGTSTP, SIG_DFL);
X#ifdef AUX
X		( void ) kill ( 0 , SIGSTOP ) ;
X#else
X		(void) kill(0, SIGTSTP);
X#endif
X		resume_nhwindows();
X	} else {
X		pline("I don't think your shell has job control.");
X	}
X#else
X	pline("Sorry, it seems we have no SIGTSTP here.  Try ! or S.");
X#endif
X	return(0);
X}
X#endif /* SUSPEND */
END_OF_FILE
if test 3582 -ne `wc -c <'sys/unix/ioctl.c'`; then
    echo shar: \"'sys/unix/ioctl.c'\" unpacked with wrong size!
fi
# end of 'sys/unix/ioctl.c'
fi
if test -f 'sys/vms/Makefile.dat' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/vms/Makefile.dat'\"
else
echo shar: Extracting \"'sys/vms/Makefile.dat'\" \(3011 characters\)
sed "s/^X//" >'sys/vms/Makefile.dat' <<'END_OF_FILE'
X#	NetHack Makefile (VMS) - data files: special levels and other data.
X#	SCCS Id: @(#)Makefile.dat	3.1	93/01/06
X
X#  Copy this file to [.dat]Makefile.; no editing needed.
X
XMAKE	= mms
XCD	= set default
XECHO	= write sys$output
XNOOP	= !			# don't do anything
XRUN	= mcr			# simplest way to pass command line args
XTOUCH	= append/New _NLA0:	# only one file per $(TOUCH)
X# support directories, relative to each other and to 'src'
XDAT = [-.dat]
XUTL = [-.util]
X# utilities; must match Makefile.utl in spelling and punctuation
XMAKEDEFS = $(UTL)makedefs.exe;
XLEVCOMP  = $(UTL)lev_comp.exe;
XDGNCOMP  = $(UTL)dgn_comp.exe;
X
X# note: filespecs have enough punctuation to satisfy DELETE
XMARKERS = spec_levs.timestamp;,quest_levs.timestamp;
XVARDAT	= data.;,rumors.;,quest.dat;,oracles.;,options.;
XDUNGEON = dungeon.;
X# note: the level lists need to be space separated
XQUESTLEVS = Arch.des Barb.des Caveman.des Elf.des Healer.des Knight.des \
X	Priest.des Rogue.des Samurai.des Tourist.des Valkyrie.des Wizard.des
XSPECLEVS  = bigroom.des castle.des endgame.des gehennom.des knox.des \
X	medusa.des mines.des oracle.des tower.des yendor.des
X
Xall :	$(VARDAT) $(DUNGEON) $(MARKERS)
X      @ $(ECHO) "data files are up to date."
X
X# these are convenience targets for "manual" interactive use
Xspec_levs :	spev_levs.timestamp
X      @ $(ECHO) "special levels are up to date."
Xquest_levs :	quest_levs.timestamp
X      @ $(ECHO) "quest levels are up to date."
Xdungeon :	$(DUNGEON)
X      @ $(ECHO) "dungeon is up to date."
Xdata :		data.;
X      @ $(NOOP)
Xrumors :	rumors.;
X      @ $(NOOP)
Xquest.dat :	quest.dat;
X      @ $(NOOP)
Xoracles :	oracles.;
X      @ $(NOOP)
Xoptions :	options.;
X      @ $(NOOP)
X
X$(MAKEDEFS) :
X	$(CD) $(UTL)
X	$(MAKE)$(MAKEFLAGS) $(MAKEDEFS)
X      @ $(CD) $(DAT)
X
X$(DGNCOMP) :
X	$(CD) $(UTL)
X	$(MAKE)$(MAKEFLAGS) $(DGNCOMP)
X      @ $(CD) $(DAT)
X
X$(LEVCOMP) :
X	$(CD) $(UTL)
X	$(MAKE)$(MAKEFLAGS) $(LEVCOMP)
X      @ $(CD) $(DAT)
X
Xdata.; :	data.base $(MAKEDEFS)
X	$(RUN) $(MAKEDEFS) -d
X
Xrumors.; :	rumors.tru rumors.fal $(MAKEDEFS)
X	$(RUN) $(MAKEDEFS) -r
X
Xquest.dat; :	quest.txt $(MAKEDEFS)
X	$(RUN) $(MAKEDEFS) -q
X
Xoracles.; :	oracles.txt $(MAKEDEFS)
X	$(RUN) $(MAKEDEFS) -h
X
X# note: 'options' should have already been made when include/date.h was created
Xoptions.; :	$(MAKEDEFS)
X	$(RUN) $(MAKEDEFS) -v
X
Xspec_levs.timestamp; :	$(SPECLEVS) $(LEVCOMP)
X	$(RUN) $(LEVCOMP) $(SPECLEVS)
X	$(TOUCH) spec_levs.timestamp;
X
Xquest_levs.timestamp; : $(QUESTLEVS) $(LEVCOMP)
X	$(RUN) $(LEVCOMP) $(QUESTLEVS)
X	$(TOUCH) quest_levs.timestamp;
X
X$(DUNGEON) :	dungeon.def $(MAKEDEFS) $(DGNCOMP)
X	$(RUN) $(MAKEDEFS) -e		!dungeon.def -> dungeon.pdf
X	$(RUN) $(DGNCOMP) dungeon.pdf	!dungeon.pdr -> dungeon
X
Xclean :
X      - if f$search("*.*;-1").nes."" then  purge
X      - if f$search("dungeon.pdf").nes."" then	delete dungeon.pdf;
X      - if f$search("*.timestamp").nes."" then	delete $(MARKERS)
X      - delete $(VARDAT)
X
Xspotless :	clean
X      - if f$search("$(DUNGEON)").nes."" then  delete $(DUNGEON)
X      - if f$search("*.lev").nes."" then  delete *.lev;
END_OF_FILE
if test 3011 -ne `wc -c <'sys/vms/Makefile.dat'`; then
    echo shar: \"'sys/vms/Makefile.dat'\" unpacked with wrong size!
fi
# end of 'sys/vms/Makefile.dat'
fi
if test -f 'sys/vms/spec_lev.com' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/vms/spec_lev.com'\"
else
echo shar: Extracting \"'sys/vms/spec_lev.com'\" \(3015 characters\)
sed "s/^X//" >'sys/vms/spec_lev.com' <<'END_OF_FILE'
X$ ! sys/vms/spec_lev.com -- preprocess nethack's special level compiler code
X$ !
X$ ! This operation needs to be performed prior to executing vmsbuild.com.
X$ ! Process the scanning and parsing code for NetHack's special level
X$ ! and dungeon compilers.  *.l and *.y are converted into *'.c and *.h.
X$ !
X$
X$ ! setup yacc/bison and lex/flex;
X$ !	  (Uncomment the alternatives appropriate for your site;
X$ !	   if yacc and lex are not defined, the pre-processed files
X$ !	   distributed in sys/share will be copied and used.)
X$     ! yacc := bison /Define			!native bison (w/ DCL CLD)
X$     ! yacc := $bison$dir:bison -y -d		!'foreign' bison (w/o CLD)
X$     ! yacc := posix /Run/Input=nl: posix$bin:yacc. """-d 
X$     ! yacc := $shell$exe:yacc -d		!yacc from DECshell
X$     ! lex  := $flex$dir:flex			!flex
X$     ! lex  := posix /Run/Input=nl: posix$bin:lex. """
X$     ! lex  := $shell$exe:lex
X$ !	  (Nothing below this line should need to be changed.)
X$ ! additional setup
X$	rename	:= rename/New_Vers
X$	mung	:= call mung	! not to be confused with teco :-)
X$	delete	:= delete/noConfirm
X$	copy	:= copy/noConcat
X$	! start from a known location -- [.sys.vms], then move to [-.-.util]
X$	cur_dir = f$environment("DEFAULT")
X$	set default 'f$parse(f$environment("PROCEDURE"),,,"DIRECTORY")'
X$	set default [-.-.util]	!move to utility directory
X$
X$mung: subroutine
X$ ! kludge to strip bogus #module directives from POSIX-processed files
X$ !   in lieu of $ rename 'p1' 'p2'
X$	search/Exact/Match=NOR 'p1' "#module" /Output='p2'
X$	delete 'p1';*
X$ endsubroutine !mung
X$
X$ ! first some cleanup (to keep things safe for unknown yacc vs bison)
X$  if f$search("y_tab.%").nes."" then  delete y_tab.%;* !old yacc
X$  if f$search("ytab.%") .nes."" then  delete ytab.%;*	!VMS POSIX yacc
X$
X$ ! process lev_comp.y into lev_yacc.c and ../include/lev_comp.h
X$ if f$type(yacc).eqs."STRING"
X$ then
X$  yacc lev_comp.y
X$  if f$search("y_tab.%").nes."" then  rename y_tab.% lev_comp.*
X$  if f$search("ytab.%") .nes."" then  rename ytab.% lev_comp.*
X$ else		! use preprocessed files
X$  copy [-.sys.share]lev_yacc.c,lev_comp.h []lev_comp.*
X$ endif
X$  mung   lev_comp.c lev_yacc.c
X$  rename lev_comp.h [-.include]lev_comp.h
X$
X$ ! process lev_comp.l into lev_lex.c
X$ if f$type(lex).eqs."STRING"
X$ then
X$  lex lev_comp.l
X$ else		! use preprocessed file
X$  copy [-.sys.share]lev_lex.c []lex_yy.*
X$ endif
X$  mung   lex_yy.c lev_lex.c
X$
X$ ! process dgn_comp.y into dgn_yacc.c and ../include/dgn_comp.h
X$ if f$type(yacc).eqs."STRING"
X$ then
X$  yacc dgn_comp.y
X$  if f$search("y_tab.%").nes."" then  rename y_tab.% dgn_comp.*
X$  if f$search("ytab.%") .nes."" then  rename ytab.% dgn_comp.*
X$ else
X$  copy [-.sys.share]dgn_yacc.c,dgn_comp.h []dgn_comp.*
X$ endif
X$  mung   dgn_comp.c dgn_yacc.c
X$  rename dgn_comp.h [-.include]dgn_comp.h
X$
X$ ! process dgn_comp.l into dgn_lex.c
X$ if f$type(lex).eqs."STRING"
X$ then
X$  lex dgn_comp.l
X$ else
X$  copy [-.sys.share]dgn_lex.c []lex_yy.*
X$ endif
X$  mung   lex_yy.c dgn_lex.c
X$
X$ ! done
X$  set default 'cur_dir'
X$ exit
END_OF_FILE
if test 3015 -ne `wc -c <'sys/vms/spec_lev.com'`; then
    echo shar: \"'sys/vms/spec_lev.com'\" unpacked with wrong size!
fi
# end of 'sys/vms/spec_lev.com'
fi
if test -f 'util/dgn_main.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'util/dgn_main.c'\"
else
echo shar: Extracting \"'util/dgn_main.c'\" \(3203 characters\)
sed "s/^X//" >'util/dgn_main.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)dgn_main.c 3.1	92/03/10	*/
X/*	Copyright (c) 1989 by Jean-Christophe Collet	*/
X/*	Copyright (c) 1990 by M. Stephenson		*/
X/* NetHack may be freely redistributed.  See license for details. */
X
X/*
X * This file contains the main function for the parser
X * and some useful functions needed by yacc
X */
X
X#include "config.h"
X
X#ifdef MICRO
X# undef exit
X# ifndef AMIGA
Xextern void FDECL(exit, (int));
X# endif
X#endif
X
X#if defined(MICRO) && !defined(AMIGA)
X# define WRMODE "w+b"
X#else
X# define WRMODE "w+"
X#endif
X
X#ifdef MAC
X# ifdef applec
X#  define MPWTOOL
X#  include <CursorCtl.h>
X# endif
X#endif
X
X#ifndef MPWTOOL
X# define SpinCursor(x)
X#endif
X
X#define MAX_ERRORS	25
X
Xextern int line_number;
Xchar *fname = "(stdin)";
Xint fatal_error = 0;
X
Xint  FDECL (main, (int, char **));
Xint  NDECL (yyparse);
Xvoid FDECL (yyerror, (char *));
Xvoid FDECL (yywarning, (char *));
Xint  NDECL (yywrap);
Xvoid FDECL (init_yyin, (FILE *));
Xvoid FDECL (init_yyout, (FILE *));
X
X#ifdef AZTEC_36
XFILE *FDECL (freopen, (char *, char *, FILE *));
X#endif
X
Xint
Xmain(argc, argv)
Xint argc;
Xchar **argv;
X{
X	char	infile[64], outfile[64];
X	FILE	*fin, *fout;
X	int	i, len;
X#ifdef MAC_THINKC5
X	static char *mac_argv[] = {	"dgn_comp",	/* dummy argv[0] */
X				":dat:dungeon.pdf"
X				};
X
X	argc = SIZE(mac_argv);
X	argv = mac_argv;
X#endif
X
X	if (argc == 1) {	/* Read standard input */
X	    init_yyin(stdin);
X	    init_yyout(stdout);
X	    yyparse();
X	} else			/* Otherwise every argument is a filename */
X	    for(i=1; i<argc; i++) {
X		    fname = strcpy(infile, argv[i]);
X		    len = strlen(fname) - 4;	/* length excluding suffix */
X		    if (len < 0 || strncmp(".pdf", fname + len, 4)) {
X			fprintf(stderr,
X				"Error - file name \"%s\" in wrong format.\n",
X				fname);
X			continue;
X		    }
X#ifdef VMS	/* make sure to avoid possible interaction with logical name */
X		    len++;	/* retain "." as trailing punctuation */
X#endif
X		    (void) strncpy(outfile, infile, len);
X		    outfile[len] = '\0';
X
X		    fin = freopen(infile, "r", stdin);
X		    if (!fin) {
X			fprintf(stderr,"Can't open %s for input\n", infile);
X			perror(infile);
X			continue;
X		    }
X		    fout = freopen(outfile, WRMODE, stdout);
X		    if (!fout) {
X			fprintf(stderr,"Can't open %s for output\n", outfile);
X			perror(outfile);
X			continue;
X		    }
X		    init_yyin(fin);
X		    init_yyout(fout);
X		    yyparse();
X		    line_number = 1;
X		    fatal_error = 0;
X	    }
X#ifndef VMS
X	return 0;
X#else
X	return 1;       /* vms success */
X#endif /*VMS*/
X}
X
X/*
X * Each time the parser detects an error, it uses this function.
X * Here we take count of the errors. To continue farther than
X * MAX_ERRORS wouldn't be reasonable.
X */
X
Xvoid yyerror(s)
Xchar *s;
X{
X	fprintf(stderr,"%s : line %d : %s\n",fname,line_number, s);
X	if (++fatal_error > MAX_ERRORS) {
X		fprintf(stderr,"Too many errors, good bye!\n");
X		exit(1);
X	}
X}
X
X/*
X * Just display a warning (that is : a non fatal error)
X */
X
Xvoid yywarning(s)
Xchar *s;
X{
X	fprintf(stderr,"%s : line %d : WARNING : %s\n",fname,line_number,s);
X}
X
Xint yywrap()
X{
X	SpinCursor(3); /*	Don't know if this is a good place to put it ?
X						Is it called for our grammar ? Often enough ?
X						Too often ? -- h+ */
X       return 1;
X}
X
X/*dgn_main.c*/
END_OF_FILE
if test 3203 -ne `wc -c <'util/dgn_main.c'`; then
    echo shar: \"'util/dgn_main.c'\" unpacked with wrong size!
fi
# end of 'util/dgn_main.c'
fi
if test -f 'win/X11/NetHack.ad' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'win/X11/NetHack.ad'\"
else
echo shar: Extracting \"'win/X11/NetHack.ad'\" \(3353 characters\)
sed "s/^X//" >'win/X11/NetHack.ad' <<'END_OF_FILE'
X! The display_file and tombstone windows should use a fixed width font ---
X! the text they display is formatted for a tty terminal.  For the same
X! reason, you may also also want a fixed-width font for the menu and text
X! windows.  However, the formatting is not nearly as critical.
X!
XNetHack*font:				variable
XNetHack*display_file*font:		fixed
XNetHack*tombstone*font:			fixed
X!NetHack*menu*font:			fixed
X!NetHack*text*font:			fixed
XNetHack*map*font:			nh10
X
X! The icon to use; supported values are nh72, nh56, and nh32; nh72 is the
X! default.  Some window managers may not support the larger icon sizes.
X! It is not guaranteed that the window manager will honor the icon selection.
X!NetHack*icon: nh56
X!
X! If True, a popup for y/n questions is _not_ used.
X!NetHack*slow: True
X!
X! If True, the message window has a line that seperates old and new messages.
X!NetHack*message_line: True
X!
X! If True, force keyboard to attach to popup windows.  Some window managers
X! enforce a click-to-focus-keyboard policy (e.g. the DECwindows wm).  NetHack
X! has a lot of popups and is almost unplayable without some kind of autofocus.
X!NetHack*autofocus: True
X!
X! Specify the number of rows and columns of the map window.  The default
X! is the standard 80x21 window.  Note: this _does_not_ change nethack's
X! level size, only what you see of it.
X!NetHack*map*rows:	21
X!NetHack*map*columns:	80
X
X! Parts of the fancy status display.
X!
XNetHack*status_condition.borderWidth:	0
XNetHack*status_info*borderWidth:	0
X
X! Sample color screen entries.
X!
XNetHack*nethack.background: 	wheat
XNetHack*map*yellow:		gold
XNetHack*map*brown:		tan
XNetHack*map*grey:		grey85
XNetHack*map*foreground:		wheat
XNetHack*map*background:		grey40
X
XNetHack*fancy_status.background:	wheat
XNetHack*status_info*foreground:		Sienna
XNetHack*status_info*background:		wheat
XNetHack*status_info.background:		wheat
XNetHack*status_attributes*foreground:	black
XNetHack*status_attributes*background:	white
XNetHack*status_condition*foreground:	red
XNetHack*status_condition*background:	wheat
XNetHack*Scrollbar*foreground:		Sienna
XNetHack*Scrollbar*background:		wheat
X
XNetHack*player_selection*random.borderColor:	blue
XNetHack*player_selection*random.foreground:	blue
XNetHack*player_selection*quit.borderColor:	blue
XNetHack*player_selection*quit.foreground:	blue
XNetHack*player_selection*Command.borderColor:	red
XNetHack*player_selection*Command.foreground:	red
X
XNetHack*extended_commands*dismiss.borderColor:	blue
XNetHack*extended_commands*dismiss.foreground:	blue
XNetHack*extended_commands*help.borderColor:	blue
XNetHack*extended_commands*help.foreground:	blue
XNetHack*extended_commands*Command.borderColor:	red
XNetHack*extended_commands*Command.foreground:	red
X!
X!
X! The following are the default 15 colors that the nethack map uses.
X! If they don't look good on your screen, change them.
X!
X! The foreground color is used as "no color".
X!
X!NetHack*map*black:		"black"
X!NetHack*map*red:		"red"
X!NetHack*map*green:		"pale green"
X!NetHack*map*brown:		"brown"
X!NetHack*map*blue:		"blue"
X!NetHack*map*magenta:		"magenta"
X!NetHack*map*cyan:		"light cyan"
X!NetHack*map*gray:		"gray"
X!NetHack*map*orange:		"orange"
X!NetHack*map*bright_green:	"green"
X!NetHack*map*yellow:		"yellow"
X!NetHack*map*bright_blue:	"royal blue"
X!NetHack*map*bright_magenta:	"violet"
X!NetHack*map*bright_cyan:	"cyan"
X!NetHack*map*white:		"white"
END_OF_FILE
if test 3353 -ne `wc -c <'win/X11/NetHack.ad'`; then
    echo shar: \"'win/X11/NetHack.ad'\" unpacked with wrong size!
fi
# end of 'win/X11/NetHack.ad'
fi
if test -f 'win/X11/winval.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'win/X11/winval.c'\"
else
echo shar: Extracting \"'win/X11/winval.c'\" \(3531 characters\)
sed "s/^X//" >'win/X11/winval.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)winval.c	3.1	92/3/7
X/* Copyright (c) Dean Luick, 1992				  */
X/* NetHack may be freely redistributed.  See license for details. */
X
X/*
X * Routines that define a name-value label widget pair that fit inside a
X * form widget.
X */
X#include <stdio.h>
X#include <X11/Intrinsic.h>
X#include <X11/StringDefs.h>
X#include <X11/Xaw/Label.h>
X#include <X11/Xaw/Form.h>
X#include <X11/Xaw/Cardinals.h>
X
X#include "config.h"	/* #define for const for non __STDC__ compilers */
X
X#define NAME "name"
X#define VALUE "value"
X
X
XWidget
Xcreate_value(parent, name_value)
X    Widget parent;
X    const char *name_value;
X{
X    Widget form, name;
X    Arg args[8];
X    Cardinal num_args;
X
X    num_args = 0;
X    XtSetArg(args[num_args], XtNborderWidth, 0);		num_args++;
X    XtSetArg(args[num_args], XtNdefaultDistance, 0);		num_args++;
X    form = XtCreateManagedWidget(name_value,
X				formWidgetClass,
X				parent, args, num_args);
X
X    num_args = 0;
X    XtSetArg(args[num_args], XtNjustify, XtJustifyRight);	num_args++;
X    XtSetArg(args[num_args], XtNborderWidth, 0);		num_args++;
X    XtSetArg(args[num_args], XtNlabel, name_value);		num_args++;
X    XtSetArg(args[num_args], XtNinternalHeight, 0);		num_args++;
X    name = XtCreateManagedWidget(NAME,
X				labelWidgetClass,
X				form, args, num_args);
X
X    num_args = 0;
X    XtSetArg(args[num_args], XtNjustify, XtJustifyRight);	num_args++;
X    XtSetArg(args[num_args], XtNborderWidth, 0);		num_args++;
X    XtSetArg(args[num_args], XtNfromHoriz, name);		num_args++;
X    XtSetArg(args[num_args], XtNinternalHeight, 0);		num_args++;
X    (void) XtCreateManagedWidget(VALUE,
X				labelWidgetClass,
X				form, args, num_args);
X    return form;
X}
X
Xvoid
Xset_name(w, new_label)
X    Widget w;
X    char *new_label;
X{
X    Arg args[1];
X    Widget name;
X
X    name = XtNameToWidget(w, NAME);
X    XtSetArg(args[0], XtNlabel, new_label);
X    XtSetValues(name, args, ONE);
X}
X
Xvoid
Xset_name_width(w, new_width)
X    Widget w;
X    int new_width;
X{
X    Arg args[1];
X    Widget name;
X
X    name = XtNameToWidget(w, NAME);
X    XtSetArg(args[0], XtNwidth, new_width);
X    XtSetValues(name, args, ONE);
X}
X
Xint
Xget_name_width(w)
X    Widget w;
X{
X    Arg args[1];
X    Dimension width;
X    Widget name;
X
X    name = XtNameToWidget(w, NAME);
X    XtSetArg(args[0], XtNwidth, &width);
X    XtGetValues(name, args, ONE);
X    return (int) width;
X}
X
X
Xvoid
Xset_value(w, new_value)
X    Widget w;
X    const char *new_value;
X{
X    Arg args[1];
X    Widget val;
X    
X    val = XtNameToWidget(w, VALUE);
X    XtSetArg(args[0], XtNlabel, new_value);
X    XtSetValues(val, args, ONE);
X}
X
Xvoid
Xset_value_width(w, new_width)
X    Widget w;
X    int new_width;
X{
X    Arg args[1];
X    Widget val;
X    
X    val = XtNameToWidget(w, VALUE);
X    XtSetArg(args[0], XtNwidth, new_width);
X    XtSetValues(val, args, ONE);
X}
X
Xint
Xget_value_width(w)
X    Widget w;
X{
X    Arg args[1];
X    Widget val;
X    Dimension width;
X
X    val = XtNameToWidget(w, VALUE);
X    XtSetArg(args[0], XtNwidth, &width);
X    XtGetValues(val, args, ONE);
X    return (int) width;
X}
X
X/* Swap foreground and background colors (this is the best I can do with */
X/* a label widget, unless I can get some init hook in there).		 */
Xvoid
Xhilight_value(w)
X    Widget w;
X{
X    Arg args[2];
X    Widget val;
X    Pixel fg, bg;
X
X    val = XtNameToWidget(w, VALUE);
X    XtSetArg(args[0], XtNforeground, &fg);
X    XtSetArg(args[1], XtNbackground, &bg);
X    XtGetValues(val, args, TWO);
X
X    XtSetArg(args[0], XtNforeground, bg);
X    XtSetArg(args[1], XtNbackground, fg);
X    XtSetValues(val, args, TWO);
X}
X
END_OF_FILE
if test 3531 -ne `wc -c <'win/X11/winval.c'`; then
    echo shar: \"'win/X11/winval.c'\" unpacked with wrong size!
fi
# end of 'win/X11/winval.c'
fi
echo shar: End of archive 105 \(of 108\).
cp /dev/null ark105isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \
21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \
41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 \
61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 \
81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 \
101 102 103 104 105 106 107 108 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 108 archives.
    echo "Now execute 'rebuild.sh'"
    rm -f ark10[0-8]isdone ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
