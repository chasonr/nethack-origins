Path: uunet!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v16i084:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Part76/108
Message-ID: <4447@master.CNA.TEK.COM>
Date: 5 Feb 93 19:20:03 GMT
Sender: news@master.CNA.TEK.COM
Lines: 1433
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1635

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 16, Issue 84
Archive-name: nethack31/Part76
Supersedes: nethack3p9: Volume 10, Issue 46-102
Environment: Amiga, Atari, Mac, MS-DOS, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 76 (of 108)."
# Contents:  sys/vms/Install.vms win/X11/winstat.c
# Wrapped by billr@saab on Wed Jan 27 16:09:17 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'sys/vms/Install.vms' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/vms/Install.vms'\"
else
echo shar: Extracting \"'sys/vms/Install.vms'\" \(29376 characters\)
sed "s/^X//" >'sys/vms/Install.vms' <<'END_OF_FILE'
X               Instructions for Installing NetHack 3.1.0
X                           on a VMS system
X               =========================================
X
X0.  Please read this entire file before trying to build or install
X    NetHack, then read it again!
X
X1.  Building NetHack requires a C compiler (either VAX C, DEC C, or GNU C)
X    and VMS version V4.6 or later (but see note #11).  This release has
X    been tested on VAX/VMS V5.5-2, T6.0, and Alpha/VMS V1.0.  The build
X    procedure (vmsbuild.com) should not need to be modified; it accepts
X    an option for selecting VAXC vs GNUC, and it can detect different
X    versions of VAXC to use appropriate CC command qualifiers.  Versions
X    of VAXC earlier than V2.3 will produce many warning messages (about
X    150 per source file; over to 18,000 total!), but NetHack has been
X    verified to compile, link, and execute correctly when built with VAXC
X    V2.2 using vmsbuild.com.  There is also a set of Makefiles suitable
X    for use with MMS; they may or may not work with other make utilities.
X
X2.  Make sure all the NetHack files are in the appropriate directory
X    structure.  You should set up a directory--referred to as "top" below
X    and in some of the assorted files, but which may be a subdirectory--
X    that has these subdirectories
X        [.dat]          -- data files
X        [.doc]          -- documentation files
X        [.include]      -- C header files
X        [.src]          -- primary source files
X        [.sys]          -- parent for [.sys.*]
X        [.sys   .share] -- files shared by several ports, incl. VMS
X        [.sys   .vms]   -- VMS-specific source and support files
X        [.util]         -- sources for essential utility programs
X        [.win]          -- parent for [.win.*]
X        [.win   .tty]   -- "window" routines for ordinary terminals
X                           (including terminal windows on workstations)
X    The following subdirectories may be present, but are not useful for
X    building NetHack on VMS and are not required:
X        [.sys   .amiga] -- AmigaDOS
X        [.sys   .amiga   .splitter]
X        [.sys   .atari] -- Atari TOS
X        [.sys   .mac]   -- Macintosh
X        [.sys   .msdos] -- MSDOS for IBM PCs and compatibles
X        [.sys   .os2]   -- OS/2
X        [.sys   .unix]  -- guess :-)
X        [.win   .X11]   -- window routines for X-Windows; requires X11R4
X                           or later and MIT's Athena Widget set
X    You must arrange things in this structure or the supplied procedures
X    and instructions in this file will not work properly.  Several DCL
X    command files are present in the [.sys.vms] subdirectory and won't
X    work as intended if they're moved elsewhere.  The file called Files
X    in the top directory contains lists of everything that should be in
X    each subdirectory, including things that are constructed as NetHack
X    is being built.  If you obtain the NetHack distribution via the
X    "shar" packaging used for Usenet newsgroup comp.sources.games and its
X    archives, you may have to reconstruct several files that were split
X    for posting.  At the time of this writing, the list of files needing
X    such treatment is not known, so they can't be enumerated here or
X    handled automatically be the build procedures.
X
X3.  Prior to beginning compilation, go to the [.include] subdirectory and
X    edit vmsconf.h according to its comments.  You should set Local_WIZARD
X    and Local_HACKDIR to appropriate values, and you might want to define
X    TEXTCOLOR if you have any color VAXstations or color terminals which
X    handle ANSI-format escape sequences to set foreground and background
X    color for text characters.  (VT241/VT340 color graphics won't work.)
X    Other things which may be of interest are SECURE if you intend to
X    set up NetHack as an installed image which is granted privileges, and
X    SHELL which should be disabled if you intend to allow captive accounts
X    to run NetHack.  You may also want to edit file config.h, but that's
X    only necessary if you want or need to disable some of the game options.
X    The distributed copy of config.h will work successfully on VMS;
X    vmsconf.h has conditional code to deal with the UNIX-specific items.
X
X4.  If you have the programming utilities lex or flex and yacc or bison,
X    you may edit the procedure [.sys.vms]spec_lev.com and execute it to
X    process several source files for NetHack's special level and dungeon
X    compilers.  If you don't modify spec_lev.com, it will copy some
X    pre-processed versions of the appropriate files (dgn_lex.c, lev_lex.c,
X    dgn_yacc.c, lev_yacc.c, dgn_comp.h, and lev_comp.h) from [.sys.share]
X    into [.util]*.c and [.include]*.h.
X       $ @[.SYS.VMS]SPEC_LEV            ![OPTIONAL]
X    If you perform this step, do it prior to executing vmsbuild.com; if
X    you don't perform this step, vmsbuild.com will do so for you.
X
X5.  If you are using DEC C (not to be confused with Digital's VAX C) as
X    your compiler, you should create an empty file called CRTL.OPT in the
X    [.src] subdirectory.  This is a linker options file for accessing
X    the C run-time library.  If you don't create it, vmsbuild.com will
X    construct one suitable for linking with shareable VAXCRTL.  Programs
X    compiled with DEC C should link with DECC$SHR instead; no special
X    linker options are needed in that case and VAXCRTL should be avoided.
X    You should also create a DCL symbol for invoking CC that specifies
X    VAXC compatibility mode.
X       $ CC == "CC/Standard=VAXC"
X    You might also want to specify /noOptimize if you don't trust the V1
X    compiler's optimizer yet.  No other special qualifiers are needed.
X
X6.  To build NETHACK.EXE and its auxiliary programs, execute the
X    following DCL command:
X       $ @[.SYS.VMS]VMSBUILD    !defaults to VAXC unless symbol 'CC' exists
X    or $ @[.SYS.VMS]VMSBUILD "GNUC"
X    It can take quite a bit of time for a full build to complete.
X    vmsbuild.com will display some feedback as it executes; generally
X    this will be the name of each source file that's about to be compiled
X    or the name of the executable that has just been linked.
X
X7.  After compilation, it's time to perform installation.  Go back to
X    the top directory.  Either edit [.sys.vms]install.com to indicate
X    where you want everything to be installed, or specify the location
X    and "playground" owner on the command line.  Then execute either
X       $ @[.SYS.VMS]INSTALL
X    or $ @[.SYS.VMS]INSTALL location owner
X    where location is a device:[directory] specification and owner is
X    either a rights identifier or UIC.  If install.com is not modified
X    and if values aren't supplied on the command line, the default values
X    used are the translation of logical name HACKDIR, if any, or else
X    [.PLAY] (relative to the current directory), and the UIC for the
X    current process.  install.com will use the auxiliary programs
X    constructed by vmsbuild.com to process quite a few data files in the
X    [.dat] subdirectory.  Then it will create the playground directory,
X    if necessary, plus the associated [.save] subdirectory.  Next it will
X    copy the data files into the playground; this step can take a while.
X    Finally it will copy nethack.exe and a few additional support files.
X
X    After it completes, the files [.src]nethack.olb, [.src]nethack.exe,
X    [.util]*.obj, [.util]*_comp.exe, and [.util]makedefs.exe can be
X    deleted in order to save disk space if desired.  The other program,
X    [.util]recover.exe, should not be deleted unless you make a copy of
X    it somewhere--perhaps in the playground directory--first.  It can be
X    used to resurrect some games disrupted by system or program crash.
X
X8.  The file nethack.com which is copied to the playground directory can
X    be used to invoke NetHack, or nethack.exe can be run directly.  Most
X    of the command-line options specified in the Unix man-page (file
X    [.dat]nethack.6) are also applicable to VMS.  Some comments at the
X    beginning of nethack.com illustrate several of the options.  New
X    players should read the document file "Guidebook.txt" which will
X    be available in the playground directory.
X
X
XNotes:
X
X1.  Save files and bones files from previous versions will not work with
X    NetHack 3.1.0.  Don't bother trying to keep them.  Ditto for RECORD,
X    the scoreboard file.  One minor change of note is that the default
X    name for a player's character is now a lowercase copy of the username.
X
X2.  To specify user-preference options in your environment, define the
X    logical name NETHACKOPTIONS to have value of a quoted string
X    containing a comma separated list of option values.  The option names
X    are case-insensitive.
X       $ define nethackoptions "noPickup,Dog:Rover,Cat:Felix,DECgraphics"
X    One value you'll probably want to specify is "noLegacy" to turn off
X    the initial introductory passage.  The "checkpoint" option controls
X    whether or not enough data is saved to disk so that the set of level
X    files left behind after a crash contains sufficient information for
X    recover.exe to be able to construct a save file after the fact.  The
X    tradeoff for enabling checkpoint is that using it makes level changes
X    do more I/O and take longer.
X
X    If logical name or DCL symbol NETHACKOPTIONS is not defined, NetHack
X    will try HACKOPTIONS instead.  Regardless of whether or not either
X    is defined, it will also try to find a configuration file containing
X    additional option settings.  If the value of the translation of
X    NETHACKOPTIONS--or HACKOPTIONS--begins with an "@" character then the
X    rest of the translation is assumed to be the name of the configuration
X    file.  Otherwise, the following are tried:  file specified by logical
X    name NETHACKINI, file SYS$LOGIN:NETHACK.INI, and file HOME:NETHACK.CNF
X    (note that the C run-time library sets up the value of HOME to match
X    sys$login).  Syntax for the configuration file is essentially the same
X    as for NETHACKOPTIONS, but multiple lines can be used and comments can
X    be included by placing '#' in the first column.
X
X3.  Instead of using vmsbuild.com to compile and link everything, you can
X    use the set of Makefiles found in the vms subdirectory, provided you
X    have an appropriate and compatible make utility.  They've been tested
X    using Digital's MMS.  There are five of them, and the suffix or
X    filetype on their names indicates where they should be placed.
X       $ copy [.sys.vms]Makefile.top []Makefile.
X       $ copy [.sys.vms]Makefile.src [.src]Makefile.
X       $ copy [.sys.vms]Makefile.utl [.util]Makefile.
X       $ copy [.sys.vms]Makefile.dat [.dat]Makefile.
X       $ copy [.sys.vms]Makefile.doc [.doc]Makefile.
X    After doing that, edit [.src]Makefile and [.util]Makefile to specify
X    pertinent compiler options in CFLAGS, linker options in LFLAGS, and
X    libraries in LIBS and/or MORELIBS if the default values aren't right.
X    Be sure to make compatible compilation and linking settings in both
X    files.  While in there, edit [.util]Makefile to specify the appropriate
X    values for lex and yacc, _or_ move to that directory and use MMS or
X    make to build targets no_lex and no_yacc which will copy several
X    pre-processed files from [.sys.share] into [.util].  Finally, edit
X    Makefile in the top directory to specify values for GAMEDIR and
X    GAMEOWNER.  This top Makefile invokes [.sys.vms]install.com to do
X    much of the actual installation work, so if you want to make any
X    customizations or file protection changes, edit install.com to suit.
X    Also set MAKE in all of the Makefiles to the appropriate command if
X    not using MMS.
X
X    Once the Makefiles are tailored for your site, give the command
X       $ mms all,install
X    or $ make all install
X    To compile and install everything.  The object files compiled via
X    the Makefiles are left as individual .OBJ files rather than placed
X    into an object library (in contrast to step #7 above and note #12
X    below).  These Makefiles are provided on an as-is basis; vmsbuild.com
X    is the preferred way to compile because it's guaranteed to compile
X    and link everything.
X
X4.  VMS NetHack uses the termcap routines borrowed from GNU Emacs.  These
X    have been supplied for those who do not already have GNU Emacs, but
X    they are not properly a part of the NetHack distribution.  Since
X    these files (gnutermcap.c and gnutparam.c) bear the usual GNU license,
X    any executable made with these files is also under the GNU license,
X    which among other things means you must be prepared to distribute
X    all the source that went into the executable if you distribute the
X    executable.  See the GNU license in the files for further details.
X    Since NetHack itself has a very similar license, this should not be
X    an issue.
X
X5.  termcap is an ASCII data file containing descriptions of terminal
X    capabilities and the escape sequences that software must use to take
X    advantage of them.  If you do not already have a termcap file in use
X    on your system there is a small one in file [.SYS.SHARE]TERMCAP.  It
X    contains definitions for common Digital terminals, also suitable for
X    most clones and emulators.  This file is copied into the playground
X    by install.com, and NetHack will use it if it can't find any other
X    one.  NetHack uses the following sequence to attempt to locate the
X    termcap file:  translation of the logical name TERMCAP (used as-is),
X    file NETHACKDIR:TERMCAP, similar file HACKDIR:TERMCAP, GNU-Emacs file
X    EMACS_LIBRARY:[ETC]TERMCAP.DAT, file []TERMCAP, and lastly file
X    $TERMCAP (which most likely would be a logical name).  If NetHack
X    can't find the termcap file, or if the above search sequence finds a
X    different one than you'd prefer, then use the DCL ASSIGN or DEFINE
X    command to define a value for logical name TERMCAP.
X
X    NetHack also tries fairly hard to figure out what kind of terminal
X    you're using.  It checks for logical names (or symbols) NETHACK_TERM,
X    HACK_TERM, EMACS_TERM, and lastly TERM.  The last is set up by the
X    C run-time library and you cannot use a logical name or symbol for
X    it.  If all those fail, or if whichever one succeeds has a value of
X    "undefined" or "unknown" (which can happen under VMS V5.4-* and
X    V5.5-* for VT420 terminals), NetHack will query the VMS TERMTABLE
X    database used by the SMG library routines.  Whatever value NetHack
X    eventually comes up with needs to be the name of an entry in the
X    termcap file, otherwise a message about "Unknown terminal type" will
X    be printed and NetHack will exit.
X
X6.  If you want to use GEM C for cross-compiling from VAX/VMS to Alpha/VMS
X    or vice versa, you'll have to build in stages.  For the first pass,
X    use a value of CC appropriate for the host system, interactively
X    start vmsbuild.com as described in step #6 above, wait until it has
X    compiled and linked "makedefs", then use <ctrl/C> to interrupt it
X    (after the "12:34 makedefs" feedback message) so that it doesn't
X    waste any time compiling the rest of the code.  Consider that to be
X    stage 1.  For stage 2, go back to step #5, but set the symbol for
X    invoking CC to have a value similar to the following
X       $ CC == " GEMC/Standard=VAXC"
X    Note the leading space in the value; if that's not included, vmsbuild
X    will take the leading "G" as an indication that GCC is being used and
X    end up selecting some wrong options.  Also set up symbols for cross-
X    architecture access to the linker and librarian (these examples assume
X    building an AXP version from a VAX)
X       $ LINK == "LINK/Alpha"   !or LINK/VAX
X       $ LIBR == "LIBR/Alpha"   !or LIBR/VAX
X    Now re-do step #6, but specify "/noExe" as the 4th parameter to
X    vmsbuild.com.
X       $ @[.SYS.VMS]VMSBUILD "" "" "" "/noExe"
X    Note the three empty strings used as placeholders.  That's the end of
X    stage 2; everything will be compiled to object files but no executable
X    files will have been linked.  If you don't do things this way, a new
X    version of makedefs will be linked; but since it will be appropriate
X    for the target, vmsbuild's attempt to use it on the host will fail.
X    For stage 3, link nethack.exe using vmsbuild.com
X       $ @[.SYS.VMS]VMSBUILD "LINK"
X    Don't specify "/noExe" this time around or you'll just be wasting
X    your time and CPU cycles. ;-)  For stage 4, link all four of the
X    utility programs manually (there's no vmsbuild option for this).
X    Go to the [.util] subdirectory and issue these commands
X       $ LINK makedefs,[-.src]nethack/Lib
X       $ LINK/Exe=[]lev_comp lev_main,lev_yacc,lev_lex,panic,[-.src]nethack/Lib
X       $ LINK/Exe=[]dgn_comp dgn_main,dgn_yacc,dgn_lex,panic,[-.src]nethack/Lib
X       $ LINK recover,[-.src]nethack/Lib
X    Note that these commands are slightly simpler than the corresponding
X    ones used in vmsbuild.com; crtl.opt is expected to be empty (step #5
X    above) so omitted here, and the identification directive is optional.
X
X    The installation of the playground (step #7 above) must be done on
X    the target system but should need no special cross-architecture
X    contortions.
X
X7.  NetHack contains code which attempts to make it secure in case it's
X    installed with privileges (to allow the playground to be protected
X    against world write access).  This has only undergone limited testing,
X    so install NetHack with privileges at your own risk.  If you discover
X    any potential security holes, please let us know so that we can take
X    steps to correct the problem(s).  NetHack always includes filename
X    punctuation when accessing files, so that it should never be affected
X    by inadvertent or malicious logical name definitions, and it always
X    deactivates installed privileges prior to spawning a subprocess.
X
X    Note to end users:  "installing with privileges" is an option for
X    system managers who set up system-wide access to the game.  Since
X    CMKRNL privilege and modification of the system boot routines are
X    both required, it is not an option for ordinary users.  There are
X    no explicit instructions on how to do such an installation, because
X    only system managers who are already familiar with the process and
X    its potential security ramifications should even consider it.
X
X    The default setup by install.com assumes no privileges and uses
X    world-writeable files to allow arbitrary users to play.  This is
X    NOT secure and not advisable in any environment where there are
X    untrustworthy users, but works fine for many sites.  If you allow
X    users to run NetHack from captive accounts (VMS 5.1-* or earlier)
X    or from restricted accounts (5.2 and later), you should either make
X    sure that they do not have TMPMBX privilege or else disable NetHack's
X    ability to spawn an interactive subprocess.  To disable subprocesses,
X    disable the "!" (shell escape) command by commenting out the definition
X    of SHELL in vmsconf.h prior to building the program.  This necessity
X    may be removed in some future release, where NetHack will check for
X    captive accounts instead of spawning unconditionally.  Note that
X    disabling the SHELL command also prevents spawning MAIL when scrolls
X    of new mail are received.
X
X    In order for installed privileges to be used at all, the value of
X    HACKDIR (via Local_HACKDIR in vmsconf.h) compiled into the program
X    must correspond to the actual playground directory.  If logical name
X    HACKDIR (or NETHACKDIR) is used to override that value, installed
X    privileges will be deactivated unless its value corresponds to the
X    same device and directory as the internal value.  If that internal
X    value contains a logical name, only an executive-mode translation
X    will be honored; if there is no such translation, installed privs
X    will be deactivated.
X
X    To be able to install nethack.exe with privileges (SYSPRV or GRPPRV,
X    perhaps EXQUOTA, depending on site usage and needs), you'll need to
X    link it with debugging and tracebacks both disabled.  You can do this
X    by specifying an argument to vmsbuild.com when performing step #6
X    above; pass it "/noTrace/noDebug" as the 4th parameter.
X       $ @[.SYS.VMS]VMSBUILD "" "" "" "/noTrace/noDebug"
X    /Trace/noDebug is the linker's normal default.  If you've already
X    built NetHack, you can relink with tracebacks disabled by doing
X       $ @[.SYS.VMS]VMSBUILD "LINK" "" "" "/noTrace/noDebug"
X
X8.  If you can't or won't install nethack.exe with privileges and if you
X    don't have access to a privileged account yourself, then if you intend
X    to allow other users to access your copy of NetHack you should probably
X    place an ACL on the playground directory and its save subdirectory.
X    The access control list should contain a default protection ACE which
X    grants delete+control access to the playground owner (ie, your own
X    account if there's no special games account involved).  install.com
X    does not attempt to do this automatically at the present time.  After
X    executing install.com to create the playground directory, perform a
X    pair of commands similar to the following
X       $ SET ACL/ACL=(IDENT=your_id, OPTIONS=DEFAULT, ACCESS=R+W+E+D+C) -
X       $_ device:[playground's.parent.directory]playground.DIR
X       $ SET ACL/ACL=(IDENT=your_id, OPTIONS=DEFAULT, ACCESS=R+W+E+D+C) -
X       $_ device:[playground.directory]SAVE.DIR
X    The two commands use the same options, but SET ACL won't accept a
X    list of files to modify.  'your_id' should be the rights identifier
X    which corresponds to the account which should retain access to those
X    files; 'device:[playground's.parent.directory]' is the name of the
X    parent directory for the playground (ie, if your playground directory
X    is disk$foo:[me.games.nethack.play], then you want to specify
X    disk$foo:[me.games.nethack]play.dir on the SET ACL command), and
X    'device:[playground.directory]' is the playground itself.  Those ACLs
X    establish a default protection scheme such that every newly created
X    file in those directories will have an ACL attached to it, and the
X    attached ACL will grant 'your_id' full access to the corresponding
X    file.  That should allow you to clear away level files from aborted
X    games, and to delete old save files if necessary.  It will not enable
X    you to run recover.exe on behalf of other users, because you won't be
X    able to create files owned by them unless you have elevated privileges.
X
X9.  Many NetHack commands can be aborted by sending it the <escape>
X    character when it wants input.  This is displayed as ESC inside the
X    game.  Digital VK201 keyboards (used by VT2xx and VT3xx and older
X    VAXstations) and VK401 keyboards (used by VT4xx, newer VAXstations,
X    and DEC's X Terminals) do not have an <escape> key.  They may
X    transmit <escape> for the <F11> key if the terminal or emulator
X    window is set to operate in VT100 mode, or there may be a setup-type
X    option for making the <` | ~> key behave as <escape>.  If your
X    terminal does not have that, or if it's set to a mode where that
X    won't work, then just use <ctrl/[> instead.  (Press the "[" key while
X    holding down the "Ctrl" key, then release both; <escape> and <ctrl/[>
X    have the same ASCII code and are indistinguishable once they reach
X    the computer; note that VAXstations and X Terminals _can_ tell the
X    difference, but that won't matter for NetHack.)
X
X    VMS NetHack is configured to use the SYS$QIOW system service for
X    reading characters from the keyboard.  This allows ^C and ^Y (as well
X    as ^X and ^O for wizard mode debugging) to be used as commands without
X    being intercepted or interpreted by the terminal driver.  The code
X    which parses arrow and function keys is not perfect, and it's possible
X    to get strange results if you hold such keys down to just type too
X    quickly, particularly on slow multiplexor lines.  Those keys are
X    never needed in actual play, and most function keys are just treated
X    as <escape> for use in aborting partial commands.
X
X    VMS NetHack also still has code to use SMG$READ_KEYSTROKE instead.
X    That can be activated by modifying vmsconf.h and recompiling, but
X    it should never be necessary.  If you use it, you'll need to press
X    either <esc> or <ctrl/[> twice to abort partial commands, or else
X    press an arbitrary function key, such as <PF4>, once.
X
X    If SUSPEND is defined in vmsconf.h, <ctrl/Z> is used for that command.
X    Since Unix-style job control is not available, it's used for connecting
X    to the parent process if NetHack is running in a subprocess.  When not
X    in a subprocess, it doesn't do anything except give a message to the
X    effect that it's not doing anything....  The suspend command does not
X    save the current game; if you use ^Z to attach to your parent process,
X    be sure to remember to eventually reattach to the NetHack subprocess;
X    otherwise the game in progress won't get saved when you logout.
X
X10. NetHack optionally maintains a logfile which receives one line appended
X    to it whenever a game ends.  This can be disabled entirely by adding
X    an "#undef LOGFILE" directive to vmsconf.h prior to building the
X    program, or it can be disabled later by removing the file(s) LOGFILE.;*
X    from the playground directory.  If not disabled prior to compilation,
X    the logfile can be reinitialized by simply creating an empty file
X    named LOGFILE in the playground, but make sure that users are able
X    to write into it, or new entries will not be appended.
X
X11. Some attempt at support for VMS versions earlier than V4.6 has been
X    included, but no such obsolete system was available for testing it.
X    vmsbuild.com detects the need for the extra support routines and
X    arranges automatically for them to be compiled.  The reason that
X    special support is needed is that the C Run-Time Library (VAXCRTL)
X    underwent a major revision for VMS V4.6 and several routines which
X    NetHack utilizes were not available prior to that upgrade.
X
X12. vmsbuild.com collects almost all of the object files (xxx.OBJ) into
X    an object library (NETHACK.OLB) as it compiles the source files.
X    This should prevent the quota-exceeded problems from the linker
X    that some sites have reported for prior versions.  Note that if you
X    compile any source files manually, you'll need to replace those
X    modules in the object library prior to linking the program:
X       $ cc/include=[-.include] [-.sys.vms]vmstty   !for example
X       $ libr/obj []nethack vmstty                  !replace VMSTTY
X       $ @[-.sys.vms]vmsbuild LINK                  !re-link NETHACK.EXE
X    If you forget to replace the library entry, your newly compiled code
X    will not be included in the new executable image.
X
X13. To access "wizard mode"--intended for debugging purposes, not to
X    spoil the game with unlimited wishes--you must be running from the
X    username compiled into the game via Local_WIZARD in vmsconf.h, and
X    you must specify "-D" on the command line when invoking NetHack.
X    Note that it must be uppercase, and it must be in quotes to prevent
X    the C run-time library's program startup code from converting it into
X    lowercase.  Any character name will be ignored in favor of "wizard".
X
X14. Unless you have both Motif and the Athena Widget set from MIT, you
X    will not be able to use the X11 interface on VMS.  Even if you do
X    have both those things, such a configuration has not been tested and
X    there are no provisions for it in vmsbuild.com.  Makefile.src does
X    have the extra source files listed, but not the necessary libraries.
X
X    The X11 port will not compile and link with DECwindows, but it will
X    be able to display on a VMS DECwindows X server provided that it and
X    its Unix X client have a compatible transport between them (either
X    TCP/IP added to VMS or DECnet added to Unix) and session security
X    is set up appropriately.  You'll need to add the contents of file
X    [.win.X11]NetHack.ad into your DECW$USER_DEFAULTS:DECW$XDEFAULTS.DAT,
X    and modify some of the lines.  The DECwindows window manager does not
X    support having input focus automatically follow the pointer, so you
X    should uncomment the "NetHack*autofocus" resource line.  (For Motif
X    this may not be necessary, depending on customization options.)
X    Uncommenting the "NetHack*slow" line is highly recommended.  You'll
X    also need to set "NetHack*fonts: fixed" (rather than "variable"), and
X    either set the map font to "fixed" too or install the "nh10" font
X    that comes in file [.win.X11]nh10.bdf.  If NetHack warns that the map
X    font is variable, then something isn't set up properly.
X
X    After creating or modifying decw$xdefaults.dat, you must restart the
X    window manager in order for any changes to take effect; it's easiest
X    to just make the session manager quit and then log in again.
X
X15. There is no support for VMS POSIX in this release of NetHack.
X
X16. If necessary, send problem reports via e-mail to
X       "nethack-bugs@linc.cis.upenn.edu"  (numeric address 130.91.6.8).
X    Always include version information for NetHack, the operating system,
X    and the C compiler used.
X
X23-JAN-1993
END_OF_FILE
if test 29376 -ne `wc -c <'sys/vms/Install.vms'`; then
    echo shar: \"'sys/vms/Install.vms'\" unpacked with wrong size!
fi
# end of 'sys/vms/Install.vms'
fi
if test -f 'win/X11/winstat.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'win/X11/winstat.c'\"
else
echo shar: Extracting \"'win/X11/winstat.c'\" \(25001 characters\)
sed "s/^X//" >'win/X11/winstat.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)winstat.c	3.1	92/3/7
X/* Copyright (c) Dean Luick, 1992				  */
X/* NetHack may be freely redistributed.  See license for details. */
X
X/*
X * Status window routines.  This file supports both the "traditional"
X * tty status display and a "fancy" status display.  A tty status is
X * made if a popup window is requested, otherewise a fancy status is
X * made.  This code assumes that only one fancy status will ever be made.
X * Currently, only one status window (of any type) is _ever_ made.
X */
X#include <X11/Intrinsic.h>
X#include <X11/StringDefs.h>
X#include <X11/Shell.h>
X#include <X11/Xaw/AsciiText.h>
X#include <X11/Xaw/Cardinals.h>
X#include <X11/Xaw/Form.h>
X#include <X11/Xaw/Label.h>
X
X#include "hack.h"
X#include "winX.h"
X
Xextern const char *hu_stat[]; /* from eat.c */
Xextern const char *enc_stat[]; /* from botl.c */
X
Xstatic void update_fancy_status();
Xstatic Widget create_fancy_status();
X
Xvoid
Xcreate_status_window(wp, create_popup, parent)
X    struct xwindow *wp;			/* window pointer */
X    boolean create_popup;
X    Widget parent;
X{
X    XFontStruct *fs;
X    Arg args[8];
X    Cardinal num_args;
X    Position top_margin, bottom_margin, left_margin, right_margin;
X
X    wp->type = NHW_STATUS;
X
X    if (!create_popup) {
X	/*
X	 * If we are not creating a popup, then we must be the "main" status
X	 * window.
X	 */
X	if (!parent)
X	    panic("create_status_window: no parent for fancy status");
X	wp->status_information = 0;
X	wp->w = create_fancy_status(parent, (Widget) 0);
X	return;
X    }
X
X    wp->status_information =
X		(struct status_info_t *) alloc(sizeof(struct status_info_t));
X
X    init_text_buffer(&wp->status_information->text);
X
X    num_args = 0;
X    XtSetArg(args[num_args], XtNallowShellResize, False); num_args++;
X    XtSetArg(args[num_args], XtNinput, False);            num_args++;
X
X    wp->popup = parent = XtCreatePopupShell("status_popup",
X					topLevelShellWidgetClass,
X					toplevel, args, num_args);
X
X    num_args = 0;
X    XtSetArg(args[num_args], XtNdisplayCaret, False); num_args++;
X    XtSetArg(args[num_args], XtNscrollHorizontal,
X				    XawtextScrollWhenNeeded);	num_args++;
X    XtSetArg(args[num_args], XtNscrollVertical,
X				    XawtextScrollWhenNeeded);	num_args++;
X
X    wp->w = XtCreateManagedWidget(
X		"status",		/* name */
X		asciiTextWidgetClass,
X		parent,			/* parent widget */
X		args,			/* set some values */
X		num_args);		/* number of values to set */
X
X    /*
X     * Adjust the height and width of the message window so that it
X     * is two lines high and COLNO of the widest characters wide.
X     */
X
X    /* Get the font and margin information. */
X    num_args = 0;
X    XtSetArg(args[num_args], XtNfont,	      &fs);	       num_args++;
X    XtSetArg(args[num_args], XtNtopMargin,    &top_margin);    num_args++;
X    XtSetArg(args[num_args], XtNbottomMargin, &bottom_margin); num_args++;
X    XtSetArg(args[num_args], XtNleftMargin,   &left_margin);   num_args++;
X    XtSetArg(args[num_args], XtNrightMargin,  &right_margin);  num_args++;
X    XtGetValues(wp->w, args, num_args);
X
X    /* font height is ascent + descent */
X    wp->pixel_height = 2 * (fs->ascent + fs->descent) +
X						top_margin + bottom_margin;
X    wp->pixel_width  = COLNO * fs->max_bounds.width +
X						left_margin + right_margin;
X
X    /* Set the new width and height. */
X    num_args = 0;
X    XtSetArg(args[num_args], XtNwidth,  wp->pixel_width);  num_args++;
X    XtSetArg(args[num_args], XtNheight, wp->pixel_height); num_args++;
X    XtSetValues(wp->w, args, num_args);
X}
X
Xvoid
Xdestroy_status_window(wp)
X    struct xwindow *wp;
X{
X    /* If status_information is defined, then it a "text" status window. */
X    if (wp->status_information) {
X	nh_XtPopdown(wp->popup);
X	XtDestroyWidget(wp->popup);
X	free((char *) wp->status_information);
X    }
X    wp->type = NHW_NONE;
X}
X
X
X/*
X * This assumes several things:
X *	+ Status has only 2 lines
X *	+ That both lines are updated in succession in line order.
X *	+ We didn't set stringInPlace on the widget.
X */
Xvoid
Xadjust_status(wp, str)
X    struct xwindow *wp;
X    const char *str;
X{
X    Arg args[2];
X    Cardinal num_args;
X
X    if (!wp->status_information) {
X	update_fancy_status(wp);
X	return;
X    }
X
X    if (wp->cursy == 0) {
X	clear_text_buffer(&wp->status_information->text);
X	append_text_buffer(&wp->status_information->text, str, FALSE);
X	return;
X    }
X    append_text_buffer(&wp->status_information->text, str, FALSE);
X
X    /* Set new buffer as text. */
X    num_args = 0;
X    XtSetArg(args[num_args], XtNstring, wp->status_information->text.text);
X								    num_args++;
X    XtSetValues(wp->w, args, num_args);
X}
X
X
X/* Fancy Status -------------------------------------------------------------*/
Xstatic Widget init_info_form();
Xstatic Widget init_column();
Xstatic void set_widths();
Xstatic void get_widths();
Xstatic void create_widget();
Xstatic const char *width_string();
Xstatic void hilight_label();
Xstatic void update_val();
X
Xstatic int hilight_time = 1;	/* number of turns to hilight a changed value */
X
Xstruct X_status_value {
X    char    *name;		/* text name */
X    int     type;		/* status type */
X    Widget  w;			/* widget of name/value pair */
X    int     last_value;		/* value displayed */
X    int	    turn_count;		/* last time the value changed */
X    boolean set;		/* if hilighed */
X    boolean after_init;		/* don't hilight on first change (init) */
X};
X
X/* valid type values */
X#define SV_VALUE 0	/* displays a label:value pair */
X#define SV_LABEL 1	/* displays a changable label */
X#define SV_NAME  2	/* displays an unchangeable name */
X
X/*
X * Form entry storage indices.
X */
X#define F_STR	    0
X#define F_DEX	    1
X#define F_CON	    2
X#define F_INT	    3
X#define F_WIS	    4
X#define F_CHA	    5
X
X#define F_NAME      6
X#define F_DLEVEL    7
X#define F_GOLD      8
X#define F_HP        9
X#define F_MAXHP	   10
X#define F_POWER    11
X#define F_MAXPOWER 12
X#define F_AC	   13
X#define F_LEVEL    14
X#define F_EXP      15
X#define F_ALIGN	   16
X#define F_TIME     17
X
X#define F_HUNGER   18
X#define F_CONFUSED 19
X#define F_SICK	   20
X#define F_BLIND	   21
X#define F_STUNNED  22
X#define F_HALLU    23
X#define F_ENCUMBER 24
X
X#define NUM_STATS  25
X
X/*
X * Notes:
X * + Alignment needs a different init value, because -1 is an alignment.
X * + Blank value is 0 and should never change.
X */
Xstatic struct X_status_value shown_stats[NUM_STATS] = {
X    { "Strength",	SV_VALUE, (Widget) 0, -1, 0, FALSE, FALSE },	/* 0*/
X    { "Dexerity",	SV_VALUE, (Widget) 0, -1, 0, FALSE, FALSE },
X    { "Constitution",	SV_VALUE, (Widget) 0, -1, 0, FALSE, FALSE },
X    { "Intelligence",	SV_VALUE, (Widget) 0, -1, 0, FALSE, FALSE },
X    { "Wisdom",		SV_VALUE, (Widget) 0, -1, 0, FALSE, FALSE },
X    { "Charisma",	SV_VALUE, (Widget) 0, -1, 0, FALSE, FALSE },	/* 5*/
X
X    { "",		SV_LABEL, (Widget) 0, -1, 0, FALSE, FALSE }, /* name */
X    { "",		SV_LABEL, (Widget) 0, -1, 0, FALSE, FALSE }, /* dlvl */
X    { "Gold",		SV_VALUE, (Widget) 0, -1, 0, FALSE, FALSE },
X    { "Hit Points",	SV_VALUE, (Widget) 0, -1, 0, FALSE, FALSE },
X    { "Max HP",		SV_VALUE, (Widget) 0, -1, 0, FALSE, FALSE },	/*10*/
X    { "Power",		SV_VALUE, (Widget) 0, -1, 0, FALSE, FALSE },
X    { "Max Power",	SV_VALUE, (Widget) 0, -1, 0, FALSE, FALSE },
X    { "Armor Class",	SV_VALUE, (Widget) 0, -1, 0, FALSE, FALSE },
X    { "Level",		SV_VALUE, (Widget) 0, -1, 0, FALSE, FALSE },
X    { "Experience",	SV_VALUE, (Widget) 0, -1, 0, FALSE, FALSE },	/*15*/
X    { "Alignment",	SV_VALUE, (Widget) 0, -2, 0, FALSE, FALSE },
X    { "Time",		SV_VALUE, (Widget) 0, -2, 0, FALSE, FALSE },
X
X    { "",		SV_NAME,  (Widget) 0,  0, 0, FALSE, TRUE }, /* hunger*/
X    { "Confused",	SV_NAME,  (Widget) 0,  1, 0, FALSE, TRUE },
X    { "Sick",		SV_NAME,  (Widget) 0,  0, 0, FALSE, TRUE },	/*20*/
X    { "Blind",		SV_NAME,  (Widget) 0,  0, 0, FALSE, TRUE },
X    { "Stunned",	SV_NAME,  (Widget) 0,  0, 0, FALSE, TRUE },
X    { "Hallucinating",	SV_NAME,  (Widget) 0,  0, 0, FALSE, TRUE },
X    { "",		SV_NAME,  (Widget) 0,  0, 0, FALSE, TRUE }, /*encumbr*/
X
X};
X
X
X/*
X * Set all widget values to a null string.  This is used after all spacings
X * have been calculated so that when the window is popped up we don't get all
X * kinds of funny values being displayed.
X */
Xvoid
Xnull_out_status()
X{
X    int i;
X    struct X_status_value *sv;
X    Arg args[1];
X
X    for (i = 0, sv = shown_stats; i < NUM_STATS; i++, sv++) {
X	switch (sv->type) {
X	    case SV_VALUE:
X		set_value(sv->w, "");
X		break;
X
X	    case SV_LABEL:
X	    case SV_NAME:
X		XtSetArg(args[0], XtNlabel, "");
X		XtSetValues(sv->w, args, ONE);
X		break;
X
X	    default:
X		impossible("null_out_status: unknown type %d\n", sv->type);
X		break;
X	}
X    }
X}
X
X/* This is almost an exact duplicate of hilight_value() */
Xstatic void
Xhilight_label(w)
X    Widget w;	/* label widget */
X{
X    Arg args[2];
X    Pixel fg, bg;
X
X    XtSetArg(args[0], XtNforeground, &fg);
X    XtSetArg(args[1], XtNbackground, &bg);
X    XtGetValues(w, args, TWO);
X
X    XtSetArg(args[0], XtNforeground, bg);
X    XtSetArg(args[1], XtNbackground, fg);
X    XtSetValues(w, args, TWO);
X}
X
X
Xstatic void
Xupdate_val(attr_rec, new_value)
X    struct X_status_value *attr_rec;
X    long new_value;
X{
X    char buf[BUFSZ];
X    Arg args[4];
X
X    if (attr_rec->type == SV_LABEL) {
X
X	if (attr_rec == &shown_stats[F_NAME]) {
X
X	    Strcpy(buf, plname);
X	    if ('a' <= buf[0] && buf[0] <= 'z') buf[0] += 'A'-'a';
X	    Strcat(buf, " the ");
X#ifdef POLYSELF
X	    if (u.mtimedone) {
X		char mname[BUFSZ];
X		int k = 0;
X
X		Strcpy(mname, mons[u.umonnum].mname);
X		while(mname[k] != 0) {
X		    if ((k == 0 || (k > 0 && mname[k-1] == ' ')) &&
X					'a' <= mname[k] && mname[k] <= 'z')
X			    mname[k] += 'A' - 'a';
X		    k++;
X		}
X		Strcat(buf, mname);
X	    } else
X#endif
X		Strcat(buf, rank_of(u.ulevel, pl_character[0], flags.female));
X
X	} else if (attr_rec == &shown_stats[F_DLEVEL]) {
X	    if (In_endgame(&u.uz)) {
X		Strcpy(buf, (Is_astralevel(&u.uz) ? "Astral Plane":"End Game"));
X	    } else {
X		Strcpy(buf, dungeons[u.uz.dnum].dname);
X		Sprintf(eos(buf), ", level %d", depth(&u.uz));
X	    }
X	} else {
X	    impossible("update_val: unknown label type \"%s\"",
X							attr_rec->name);
X	    return;
X	}
X
X	if (strcmp(buf, attr_rec->name) == 0) return;	/* same */
X
X	/* Set the label. */
X	Strcpy(attr_rec->name, buf);
X	XtSetArg(args[0], XtNlabel, buf);
X	XtSetValues(attr_rec->w, args, ONE);
X
X    } else if (attr_rec->type == SV_NAME) {
X
X	if (attr_rec->last_value == new_value) return;	/* no change */
X
X	attr_rec->last_value = new_value;
X
X	/* special cases: hunger and encumbrance */
X	if (attr_rec == &shown_stats[F_HUNGER]) {
X	    XtSetArg(args[0], XtNlabel, hu_stat[new_value]);
X	} else if (attr_rec == &shown_stats[F_ENCUMBER]) {
X	    XtSetArg(args[0], XtNlabel, enc_stat[new_value]);
X	} else if (new_value) {
X	    XtSetArg(args[0], XtNlabel, attr_rec->name);
X	} else {
X	    XtSetArg(args[0], XtNlabel, "");
X	}
X	XtSetValues(attr_rec->w, args, ONE);
X
X    } else {	/* a value pair */
X	boolean force_update = FALSE;
X
X	/* special case: time can be enabled & disabled */
X	if (attr_rec == &shown_stats[F_TIME]) {
X	    static boolean flagtime = TRUE;
X
X	    if(flags.time && !flagtime) {
X		set_name(attr_rec->w, shown_stats[F_TIME].name);
X		force_update = TRUE;
X		flagtime = flags.time;
X	    } else if(!flags.time && flagtime) {
X		set_name(attr_rec->w, "");
X		set_value(attr_rec->w, "");
X		flagtime = flags.time;
X	    }
X	    if(!flagtime) return;
X	}
X#ifdef POLYSELF
X	/* special case: when polymorphed, show "HD", disable exp */
X	else if (attr_rec == &shown_stats[F_LEVEL]) {
X	    static boolean lev_was_poly = FALSE;
X
X	    if (u.mtimedone && !lev_was_poly) {
X		force_update = TRUE;
X		set_name(attr_rec->w, "HD");
X		lev_was_poly = TRUE;
X	    } else if (!u.mtimedone && lev_was_poly) {
X		force_update = TRUE;
X		set_name(attr_rec->w, shown_stats[F_LEVEL].name);
X		lev_was_poly = FALSE;
X	    }
X	} else if (attr_rec == &shown_stats[F_EXP]) {
X	    static boolean exp_was_poly = FALSE;
X
X	    if (u.mtimedone && !exp_was_poly) {
X		force_update = TRUE;
X		set_name(attr_rec->w, "");
X		set_value(attr_rec->w, "");
X		exp_was_poly = TRUE;
X	    } else if (!u.mtimedone && exp_was_poly) {
X		force_update = TRUE;
X		set_name(attr_rec->w, shown_stats[F_EXP].name);
X		exp_was_poly = FALSE;
X	    }
X	    if (u.mtimedone) return;	/* no display for exp when poly */
X	}
X#endif
X
X	if (attr_rec->last_value == new_value && !force_update)	/* same */
X	    return;
X
X	attr_rec->last_value = new_value;
X
X	/* Special cases: strength, alignment and "clear". */
X	if (attr_rec == &shown_stats[F_STR]) {
X	    if(new_value > 18) {
X		if (new_value > 118)
X		    Sprintf(buf,"%d", new_value-100);
X		else if(new_value < 118)
X		    Sprintf(buf, "18/%02d", new_value-18);
X		else
X		    Strcpy(buf, "18/**");
X	    } else {
X		Sprintf(buf, "%d", new_value);
X	    }
X	} else if (attr_rec == &shown_stats[F_ALIGN]) {
X
X	    Strcpy(buf, (new_value == A_CHAOTIC) ? "Chaotic" :
X			(new_value == A_NEUTRAL) ? "Neutral" :
X						   "Lawful"  );
X	} else {
X	    Sprintf(buf, "%d", new_value);
X	}
X	set_value(attr_rec->w, buf);
X    }
X
X    /*
X     * Now hilight the changed information.  Names, time and score don't
X     * hilight.  If first time, don't hilight.  If already lit, don't do
X     * it again.
X     */
X    if (attr_rec->type != SV_NAME && attr_rec != &shown_stats[F_TIME]) {
X	if (attr_rec->after_init) {
X	    if(!attr_rec->set) {
X		if (attr_rec->type == SV_LABEL)
X		    hilight_label(attr_rec->w);
X		else
X		    hilight_value(attr_rec->w);
X		attr_rec->set = TRUE;
X	    }
X	    attr_rec->turn_count = 0;
X	} else {
X	    attr_rec->after_init = TRUE;
X	}
X    }
X}
X
X/*
X * Update the displayed status.  The current code in botl.c updates
X * two lines of information.  Both lines are always updated one after
X * the other.  So only do our update when we update the second line.
X *
X * Information on the first line:
X *	name, attributes, alignment, score
X *
X * Not done: score
X *
X * Information on the second line:
X * 	dlvl, gold, hp, power, ac, {level & exp or HD **}
X * 	status (hunger, conf, halu, stun, sick, blind), time, encumbrance
X *
X * [**] HD is shown instead of level and exp if POLYSELF is defined and
X *	mtimedone is non-zero.
X */
Xstatic void
Xupdate_fancy_status(wp)
X    struct xwindow *wp;
X{
X    const struct X_status_value *sv;
X    long val;
X    int i;
X
X    if (wp->cursy != 0) return;	/* do a complete update when line 0 is done */
X
X#ifdef GCC_WARN
X    val = 0;
X#endif
X
X    for (i = 0, sv = shown_stats; i < NUM_STATS; i++, sv++) {
X	switch (i) {
X	    case F_STR:		val = (long) ACURR(A_STR); break;
X	    case F_DEX:		val = (long) ACURR(A_DEX); break;
X	    case F_CON:		val = (long) ACURR(A_CON); break;
X	    case F_INT:		val = (long) ACURR(A_INT); break;
X	    case F_WIS:		val = (long) ACURR(A_WIS); break;
X	    case F_CHA:		val = (long) ACURR(A_CHA); break;
X	    /*
X	     * Label stats.  With the exceptions of hunger and encumbrance,
X	     * these are either on or off.  Pleae leave the ternary operators
X	     * the way they are.  I want to specify 0 or 1, not a boolean.
X	     */
X	    case F_HUNGER:	val = (long) u.uhs;			break;
X	    case F_CONFUSED:	val = (long) Confusion     ? 1L : 0L;	break;
X	    case F_SICK:	val = (long) Sick	   ? 1L : 0L;	break;
X	    case F_BLIND:	val = (long) Blind	   ? 1L : 0L;	break;
X	    case F_STUNNED:	val = (long) Stunned	   ? 1L : 0L;	break;
X	    case F_HALLU:	val = (long) Hallucination ? 1L : 0L;	break;
X	    case F_ENCUMBER:	val = (long) near_capacity();		break;
X
X	    case F_NAME:	val = (long) 0L; break;	/* special */
X	    case F_DLEVEL:	val = (long) 0L; break;	/* special */
X	    case F_GOLD:	val = (long) u.ugold; break;
X#ifdef POLYSELF
X	    case F_HP:		val = (long) (u.mtimedone ?
X					      (u.mh  > 0 ? u.mh  : 0):
X					      (u.uhp > 0 ? u.uhp : 0)); break;
X	    case F_MAXHP:	val = (long) (u.mtimedone ? u.mhmax :
X							    u.uhpmax);  break;
X#else
X	    case F_HP:		val = (long) (u.uhp > 0 ? u.uhp : 0);	break;
X	    case F_MAXHP:	val = (long) u.uhpmax;	break;
X#endif
X	    case F_POWER:	val = (long) u.uen;	break;
X	    case F_MAXPOWER:	val = (long) u.uenmax;	break;
X	    case F_AC:		val = (long) u.uac;	break;
X#ifdef POLYSELF
X	    case F_LEVEL:	val = (long) (u.mtimedone ?
X						mons[u.umonnum].mlevel :
X						u.ulevel);		break;
X#else
X	    case F_LEVEL:	val = (long) u.ulevel;	break;
X#endif
X	    case F_EXP:		val = (long) u.uexp;	break;
X	    case F_ALIGN:	val = (long) u.ualign.type; break;
X	    case F_TIME:	val = flags.time ? (long) moves : 0L;	break;
X	    default:
X	    {
X		/*
X		 * There is a possible infinite loop that occurs with:
X		 *
X		 * 	impossible->pline->flush_screen->bot->bot{1,2}->
X		 * 	putstr->adjust_status->update_other->impossible
X		 *
X		 * Break out with this.
X		 */
X		static boolean active = FALSE;
X		if (!active) {
X		    active = TRUE;
X		    impossible("update_other: unknown shown value");
X		    active = FALSE;
X		}
X		break;
X	    }
X	}
X	update_val(sv, val);
X    }
X}
X
X/*
X * Turn off hilighted status values after a certain amount of turns.
X */
Xvoid
Xcheck_turn_events()
X{
X    int i;
X    struct X_status_value *sv;
X
X    for (sv = shown_stats, i = 0; i < NUM_STATS; i++, sv++) {
X	if (!sv->set) continue;
X
X	if (sv->turn_count++ >= hilight_time) {
X	    if (sv->type == SV_LABEL)
X		hilight_label(sv->w);
X	    else
X		hilight_value(sv->w);
X	    sv->set = FALSE;
X	}
X    }
X}
X
X/* Initialize alternate status ============================================= */
X
X/* Return a string for the initial width. */
Xstatic const char *
Xwidth_string(sv_index)
X    int sv_index;
X{
X    switch (sv_index) {
X	case F_STR:	return "018/**";
X	case F_DEX:
X	case F_CON:
X	case F_INT:
X	case F_WIS:
X	case F_CHA:	return "088";	/* all but str never get bigger */
X
X	case F_HUNGER:	return shown_stats[F_HUNGER].name;
X	case F_CONFUSED:return shown_stats[F_CONFUSED].name;
X	case F_SICK:	return shown_stats[F_SICK].name;
X	case F_BLIND:	return shown_stats[F_BLIND].name;
X	case F_STUNNED: return shown_stats[F_STUNNED].name;
X	case F_HALLU:	return shown_stats[F_HALLU].name;
X	case F_ENCUMBER:return shown_stats[F_ENCUMBER].name;
X
X	case F_NAME:
X	case F_DLEVEL:	return "";
X	case F_HP:
X	case F_MAXHP:	return "9999";
X	case F_POWER:
X	case F_MAXPOWER:return "999";
X	case F_AC:	return "-99";
X	case F_LEVEL:	return "99";
X	case F_GOLD:
X	case F_EXP:	return "4294967295";	/* max ulong */
X	case F_ALIGN:	return "Neutral";
X	case F_TIME:	return "4294967295";	/* max ulong */
X    }
X    impossible("width_string: unknown index %d\n", sv_index);
X    return "";
X}
X
Xstatic void
Xcreate_widget(parent, sv, sv_index)
X    Widget parent;
X    struct X_status_value *sv;
X    int sv_index;
X{
X    Arg args[4];
X    Cardinal num_args;
X
X    switch (sv->type) {
X	case SV_VALUE:
X	    sv->w = create_value(parent, sv->name);
X	    set_value(sv->w, width_string(sv_index));
X	    break;
X	case SV_LABEL:
X	    /* Labels get their own buffer. */
X	    sv->name = (char *) alloc(BUFSZ);
X	    sv->name[0] = '\0';
X
X	    num_args = 0;
X	    XtSetArg(args[num_args], XtNborderWidth, 0);	num_args++;
X	    XtSetArg(args[num_args], XtNinternalHeight, 0);	num_args++;
X	    sv->w = XtCreateManagedWidget(
X				sv_index == F_NAME ? "name" : "dlevel",
X				labelWidgetClass,
X				parent,
X				args, num_args);
X	    break;
X	case SV_NAME:
X	    num_args = 0;
X	    XtSetArg(args[num_args], XtNborderWidth, 0);	num_args++;
X	    XtSetArg(args[num_args], XtNinternalHeight, 0);	num_args++;
X	    sv->w = XtCreateManagedWidget(sv->name,
X					labelWidgetClass,
X					parent,
X					args, num_args);
X	    break;
X	default:
X	    panic("create_widget: unknown type %d", sv->type);
X    }
X}
X
X/*
X * Get current width of value.  width2p is only valid for SV_LABEL types.
X */
Xstatic void
Xget_widths(sv, width1p, width2p)
X    struct X_status_value *sv;
X    int *width1p, *width2p;
X{
X    Arg args[1];
X    Dimension width;
X
X    switch (sv->type) {
X	case SV_VALUE:
X	    *width1p = get_name_width(sv->w);
X	    *width2p = get_value_width(sv->w);
X	    break;
X	case SV_LABEL:
X	case SV_NAME:
X	    XtSetArg(args[0], XtNwidth, &width);
X	    XtGetValues(sv->w, args, ONE);
X	    *width1p = width;
X	    *width2p = 0;
X	    break;
X	default:
X	    panic("get_widths: unknown type %d", sv->type);
X    }
X}
X
Xstatic void
Xset_widths(sv, width1, width2)
X    struct X_status_value *sv;
X    int width1, width2;
X{
X    Arg args[1];
X
X    switch (sv->type) {
X	case SV_VALUE:
X	    set_name_width(sv->w, width1);
X	    set_value_width(sv->w, width2);
X	    break;
X	case SV_LABEL:
X	case SV_NAME:
X	    XtSetArg(args[0], XtNwidth, (width1+width2));
X	    XtSetValues(sv->w, args, ONE);
X	    break;
X	default:
X	    panic("set_widths: unknown type %d", sv->type);
X    }
X}
X
Xstatic Widget
Xinit_column(name, parent, top, left, col_indices)
X    char *name;
X    Widget parent, top, left;
X    int *col_indices;
X{
X    Widget form;
X    Arg args[4];
X    Cardinal num_args;
X    int max_width1, width1, max_width2, width2;
X    int *ip;
X    struct X_status_value *sv;
X
X    num_args = 0;
X    if (top != (Widget) 0) {
X	XtSetArg(args[num_args], XtNfromVert, top);		num_args++;
X    }
X    if (left != (Widget) 0) {
X	XtSetArg(args[num_args], XtNfromHoriz, left);	num_args++;
X    }
X    XtSetArg(args[num_args], XtNdefaultDistance, 0);	num_args++;
X    form = XtCreateManagedWidget(name,
X				formWidgetClass,
X				parent, args, num_args);
X
X    max_width1 = max_width2 = 0;
X    for (ip = col_indices; *ip >= 0; ip++) {
X	sv = &shown_stats[*ip];
X	create_widget(form, sv, *ip);	/* will set init width */
X	if (ip != col_indices) {	/* not first */
X	    num_args = 0;
X	    XtSetArg(args[num_args], XtNfromVert, shown_stats[*(ip-1)].w);
X								num_args++;
X	    XtSetValues(sv->w, args, num_args);
X	}
X	get_widths(sv, &width1, &width2);
X	if (width1 > max_width1) max_width1 = width1;
X	if (width2 > max_width2) max_width2 = width2;
X    }
X    for (ip = col_indices; *ip >= 0 ; ip++) {
X	set_widths(&shown_stats[*ip], max_width1, max_width2);
X    }
X
X    /* There is room behind the end marker for the two widths. */
X    *++ip = max_width1;
X    *++ip = max_width2;
X
X    return form;
X}
X
X/*
X * These are the orders of the displayed columns.  Change to suit.  The -1
X * indicates the end of the column.  The two numbers after that are used
X * to store widths that are calculated at run-time.
X */
Xstatic int attrib_indices[] = { F_STR,F_DEX,F_CON,F_INT,F_WIS,F_CHA, -1,0,0 };
Xstatic int status_indices[] = { F_HUNGER, F_CONFUSED, F_SICK, F_BLIND,
X				F_STUNNED, F_HALLU, F_ENCUMBER, -1,0,0 };
X
Xstatic int col2_indices[] = { F_MAXHP,F_ALIGN,F_TIME,F_EXP,F_MAXPOWER,-1,0,0 };
Xstatic int col1_indices[] = { F_HP, F_AC, F_GOLD, F_LEVEL, F_POWER,   -1,0,0 };
X
X
X/*
X * Produce a form that looks like the following:
X *
X *		   name
X *		  dlevel
X * col1_indices[0]	col2_indices[0]
X * col1_indices[1]	col2_indices[1]
X *    .		    .
X *    .		    .
X * col1_indices[n]	col2_indices[n]
X */
Xstatic Widget
Xinit_info_form(parent, top, left)
X    Widget parent, top, left;
X{
X    Widget form, col1;
X    struct X_status_value *sv_name, *sv_dlevel;
X    Arg args[6];
X    Cardinal num_args;
X    int total_width, *ip;
X
X    num_args = 0;
X    if (top != (Widget) 0) {
X	XtSetArg(args[num_args], XtNfromVert, top);	num_args++;
X    }
X    if (left != (Widget) 0) {
X	XtSetArg(args[num_args], XtNfromHoriz, left);	num_args++;
X    }
X    XtSetArg(args[num_args], XtNdefaultDistance, 0);	num_args++;
X    form = XtCreateManagedWidget("status_info",
X				formWidgetClass,
X				parent,
X				args, num_args);
X
X    /* top of form */
X    sv_name = &shown_stats[F_NAME];
X    create_widget(form, sv_name, F_NAME);
X
X    /* second */
X    sv_dlevel = &shown_stats[F_DLEVEL];
X    create_widget(form, sv_dlevel, F_DLEVEL);
X
X    num_args = 0;
X    XtSetArg(args[num_args], XtNfromVert, sv_name->w); 	num_args++;
X    XtSetValues(sv_dlevel->w, args, num_args);
X
X    /* two columns beneath */
X    col1 = init_column("name_col1", form, sv_dlevel->w,
X						(Widget) 0, col1_indices);
X    (void) init_column("name_col2", form, sv_dlevel->w,
X						      col1, col2_indices);
X
X    /* Add calculated widths. */
X    for (ip = col1_indices; *ip >= 0; ip++)
X	;	/* skip to end */
X    total_width = *++ip;
X    total_width += *++ip;
X    for (ip = col2_indices; *ip >= 0; ip++)
X	;	/* skip to end */
X    total_width += *++ip;
X    total_width += *++ip;
X
X    XtSetArg(args[0], XtNwidth, total_width);
X    XtSetValues(sv_name->w,   args, ONE);
X    XtSetArg(args[0], XtNwidth, total_width);
X    XtSetValues(sv_dlevel->w, args, ONE);
X
X    return form;
X}
X
X/*
X * Create the layout for the fancy status.  Return a form widget that
X * contains everything.
X */
Xstatic Widget
Xcreate_fancy_status(parent, top)
X    Widget parent, top;
X{
X    Widget form;	/* The form that surrounds everything. */
X    Widget w;
X    Arg args[6];
X    Cardinal num_args;
X
X    num_args = 0;
X    if (top != (Widget) 0) {
X	XtSetArg(args[num_args], XtNfromVert, top);	num_args++;
X    }
X    XtSetArg(args[num_args], XtNdefaultDistance, 0);	num_args++;
X    XtSetArg(args[num_args], XtNborderWidth, 0);	num_args++;
X    form = XtCreateManagedWidget("fancy_status",
X				formWidgetClass,
X				parent,
X				args, num_args);
X
X    w = init_info_form(form, (Widget) 0, (Widget) 0);
X    w =    init_column("status_attributes",form, (Widget) 0, w, attrib_indices);
X    (void) init_column("status_condition", form, (Widget) 0, w, status_indices);
X    return form;
X}
X
END_OF_FILE
if test 25001 -ne `wc -c <'win/X11/winstat.c'`; then
    echo shar: \"'win/X11/winstat.c'\" unpacked with wrong size!
fi
# end of 'win/X11/winstat.c'
fi
echo shar: End of archive 76 \(of 108\).
cp /dev/null ark76isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \
21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \
41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 \
61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 \
81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 \
101 102 103 104 105 106 107 108 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 108 archives.
    echo "Now execute 'rebuild.sh'"
    rm -f ark10[0-8]isdone ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
