Path: uunet!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v16i104:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Part96/108
Message-ID: <4469@master.CNA.TEK.COM>
Date: 5 Feb 93 22:03:06 GMT
Sender: news@master.CNA.TEK.COM
Lines: 1986
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1655

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 16, Issue 104
Archive-name: nethack31/Part96
Supersedes: nethack3p9: Volume 10, Issue 46-108
Environment: Amiga, Atari, Mac, MS-DOS, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 96 (of 108)."
# Contents:  dat/help include/decl.h src/extralev.c src/mplayer.c
#   src/wield.c sys/share/pcunix.c win/tty/topl.c
# Wrapped by billr@saab on Wed Jan 27 16:09:27 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'dat/help' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dat/help'\"
else
echo shar: Extracting \"'dat/help'\" \(8454 characters\)
sed "s/^X//" >'dat/help' <<'END_OF_FILE'
X        Welcome to NetHack!                ( description of version 3.1 )
X
X        NetHack is a Dungeons and Dragons like game where you (the adventurer)
Xdescend into the depths of the dungeon in search of the Amulet of Yendor
X(reputed to be hidden somewhere below the twentieth level).  You are
Xaccompanied by a dog or cat that can help you in many ways and can be trained
Xto do all sorts of things.  On the way you will find useful (or useless)
Xitems (quite possibly with magic properties), and assorted monsters.  You
Xattack a monster by trying to move into the space a monster is in (but often
Xit is much wiser to leave it alone).
X
X        Unlike most adventure games, which give you a verbal description of
Xyour location, NetHack gives you a visual image of the dungeon level you are
Xon.
X
X        NetHack uses the following symbols:
X
X        - and |  The walls of a room, also open doors.
X        .        The floor of a room or a doorway.
X        #        A corridor, a kitchen sink (if your dungeon has sinks), or
X                 a drawbridge.
X        >        A way to the next level.
X        <        A way to the previous level.
X        @        You (usually) or another human.
X        )        A weapon of some sort.
X        [        A suit or piece of armor.
X        %        A piece of food (not necessarily healthy).
X        /        A wand.
X        =        A ring.
X        ?        A scroll.
X        !        A potion.
X        (        Some other useful object (pick-axe, key, lamp...)
X        $        A pile of gold.
X        *        A gem or rock (possibly valuable, possibly worthless).
X        +        A closed door, or a spell book containing a spell
X                 you can learn.
X        ^        A trap (once you detect it).
X        "        An amulet, or a spider web.
X        0        An iron ball.
X        _        An altar, or an iron chain.
X        }        A pool of water or moat or a pool of lava.
X        {        A fountain.
X        \        An opulent throne.
X        `        A boulder or statue.
X        A to Z, a to z, and several others:  Monsters.
X
X                 You can find out what a character represents by typing
X                 '/' followed by the character, as in "/A", which will
X                 tell you that 'A' is an Ape.
X
X
Xy k u   7 8 9   Move commands:
X \|/     \|/            yuhjklbn: go one step in specified direction
Xh-.-l   4-.-6           YUHJKLBN: go in specified direction until you
X /|\     /|\                        hit a wall or run into something
Xb j n   1 2 3           g<dir>:   run in direction <dir> until something
X      numberpad                     interesting is seen
X                        G<dir>,   same, except a branching corridor isn't
X                        ^<dir>:     considered interesting
X                        m<dir>:   move without picking up objects
X                If the numberpad option is set, the number keys move instead.
X
XCommands:
X        NetHack knows the following commands:
X        ?       Help menu.
X        /       (followed by any symbol):  tell what this symbol represents.
X                You may choose to specify a location or give a symbol argument.
X        &       Tell what a command does.
X        <       Go up a staircase (if you are standing on it).
X        >       Go down a staircase (if you are standing on it).
X        .       Rest, do nothing for one turn.
X        a       Apply (use) an tool (pick-axe, key, lamp...)
X        A       Remove all armor.
X        ^A      Redo the previous command
X        c       Close a door.
X        C       Call (name) an individual monster.
X        d       Drop something.  d7a:  drop seven items of object a.
X        D       Drop several things.  In answer to the question
X                "What kinds of things do you want to drop? [!%= au]"
X                you should type zero or more object symbols possibly
X                followed by 'a' and/or 'u'.
X                Da - drop all objects, without asking for confirmation.
X                Du - drop only unpaid objects (when in a shop).
X                D%u - drop only unpaid food.
X        ^D      Kick (for doors, usually).
X        e       Eat food.
X        E       Engrave a message on the floor.
X                E- - write in the dust with your fingers.
X
X
X
X        i       Print your inventory.
X        I       Print selected parts of your inventory, as in
X                I* - list all gems in inventory.
X                Iu - list all unpaid items.
X                Ix - list all used up items that are on your shopping bill.
X                I$ - count your money.
X        o       Open a door.
X        O       Set options.  You will be asked to enter an option line.
X                If the line is empty, the current options are reported.
X                Descriptions of possible options and their formats can be
X                obtained by entering "?".  Options are usually set before
X                the game with a NETHACKOPTIONS environment variable, not
X                with the 'O' command.
X        p       Pay your shopping bill.
X        P       Put on an accessory (ring, amulet, etc).
X        ^P      Repeat last message (subsequent ^P's repeat earlier messages).
X        q       Drink (quaff) a potion.
X        Q       Quit the game.
X        r       Read a scroll or spell book.
X        R       Remove an accessory (ring, amulet, etc).
X        ^R      Redraw the screen.
X        s       Search for secret doors and traps around you.
X        S       Save the game.
X        t       Throw an object or shoot a projectile.
X        T       Take off armor.
X        ^T      Teleport, if you are able.
X        v       Prints the version number.
X        V       Prints a longer identification of the version, including the
X                history of the game.
X        w       Wield weapon.  w- means wield nothing, use bare hands.
X        W       Wear armor.
X        x       List the spells you know (same as '+').
X        X       Switch the game to explore (discovery) mode.
X        z       Zap a wand.
X        Z       Cast a spell.
X        ^Z      Suspend the game.
X        :       Look at what is here.
X        ;       Look at what is somewhere else.
X        ,       Pick up some things.
X        @       Toggle the pickup option.
X        ^       Ask for the type of a trap you found earlier.
X        )       Tell what weapon you are wielding.
X        [       Tell what armor you are wearing.
X        =       Tell what rings you are wearing.
X        "       Tell what amulet you are wearing.
X        (       Tell what tools you are using.
X        $       Count your gold pieces.
X        +       List the spells you know (same as 'x').
X        \       Show what types of objects have been discovered.
X        !       Escape to a shell.
X        #       Introduces one of the "extended" commands.  To get a list of
X                the commands you can use with "#" type "#?".  The extended
X                commands you can use depends upon what options the game was
X                compiled with, along with your class and what type of monster
X                you most closely resemble at a given moment.  If your keyboard
X                has a meta key (which, when pressed in combination with another
X                key, modifies it by setting the 'meta' (8th, or 'high') bit),
X                these extended commands can be invoked by meta-ing the first
X                letter of the command.
X
X        If the "number_pad" option is on, some additional letter commands
X        are available:
X
X        j       Jump to another location.
X        k       Kick (for doors, usually).
X        l       Loot a box on the floor.
X        n       Name an object or type of object.
X        u       Untrap a trapped object or door.
X
X        You can put a number before a command to repeat it that many times,
X        as in "40." or "20s.".  If you have the number_pad option set, you
X        must type 'n' to prefix the count, as in "n40." or "n20s".
X
X 
X        Some information is displayed on the bottom line.  You see your
X        attributes, your alignment, what dungeon level you are on, how many
X        hit points you have now (and will have when fully recovered), what
X        your armor class is (the lower the better), your experience level,
X        and the state of your stomach.  Optionally, you may or may not see
X        other information such as spell points, how much gold you have, etc.
X
X        Have Fun, and Happy Hacking!
END_OF_FILE
if test 8454 -ne `wc -c <'dat/help'`; then
    echo shar: \"'dat/help'\" unpacked with wrong size!
fi
# end of 'dat/help'
fi
if test -f 'include/decl.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/decl.h'\"
else
echo shar: Extracting \"'include/decl.h'\" \(8850 characters\)
sed "s/^X//" >'include/decl.h' <<'END_OF_FILE'
X/*	SCCS Id: @(#)decl.h	3.1	92/12/11	*/
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#ifndef DECL_H
X#define DECL_H
X
X#define E extern
X
XE int NDECL((*occupation));
XE int NDECL((*afternmv));
X
XE const char *hname;
XE int hackpid;
X#if defined(UNIX) || defined(VMS)
XE int locknum;
X#endif
X#ifdef DEF_PAGER
XE char *catmore;
X#endif	/* DEF_PAGER */
X
XE char SAVEF[];
X#ifdef MICRO
XE char SAVEP[];
X#endif
X
XE int NEARDATA bases[];
X
XE int NEARDATA multi;
XE int NEARDATA warnlevel;
XE int NEARDATA nroom;
XE int NEARDATA nsubroom;
XE int NEARDATA occtime;
X
XE int x_maze_max, y_maze_max;
XE int otg_temp;
X
X#ifdef REDO
XE int NEARDATA in_doagain;
X#endif
X
XE struct dgn_topology {	/* special dungeon levels for speed */
X    d_level	d_oracle_level;
X    d_level	d_bigroom_level;	/* unused */
X#ifdef REINCARNATION
X    d_level	d_rogue_level;
X#endif
X    d_level	d_medusa_level;
X    d_level	d_stronghold_level;
X    d_level	d_valley_level;
X    d_level	d_wiz1_level;
X    d_level	d_wiz2_level;
X    d_level	d_wiz3_level;
X    d_level     d_juiblex_level;
X    d_level     d_orcus_level;
X    d_level	d_baalzebub_level;	/* unused */
X    d_level	d_asmodeus_level;	/* unused */
X    d_level	d_portal_level;		/* only in goto_level() [do.c] */
X    d_level	d_sanctum_level;
X    d_level	d_earth_level;
X    d_level	d_water_level;
X    d_level	d_fire_level;
X    d_level	d_air_level;
X    d_level	d_astral_level;
X    xchar	d_tower_dnum;
X#ifdef MULDGN
X    xchar	d_mines_dnum, d_quest_dnum;
X    d_level	d_qstart_level, d_qlocate_level, d_nemesis_level;
X    d_level	d_knox_level;
X#endif
X} dungeon_topology;
X/* macros for accesing the dungeon levels by their old names */
X#define oracle_level		(dungeon_topology.d_oracle_level)
X#define bigroom_level		(dungeon_topology.d_bigroom_level)
X#ifdef REINCARNATION
X#define rogue_level		(dungeon_topology.d_rogue_level)
X#endif
X#define medusa_level		(dungeon_topology.d_medusa_level)
X#define stronghold_level	(dungeon_topology.d_stronghold_level)
X#define valley_level		(dungeon_topology.d_valley_level)
X#define wiz1_level		(dungeon_topology.d_wiz1_level)
X#define wiz2_level		(dungeon_topology.d_wiz2_level)
X#define wiz3_level		(dungeon_topology.d_wiz3_level)
X#define juiblex_level		(dungeon_topology.d_juiblex_level)
X#define orcus_level		(dungeon_topology.d_orcus_level)
X#define baalzebub_level		(dungeon_topology.d_baalzebub_level)
X#define asmodeus_level		(dungeon_topology.d_asmodeus_level)
X#define portal_level		(dungeon_topology.d_portal_level)
X#define sanctum_level		(dungeon_topology.d_sanctum_level)
X#define earth_level		(dungeon_topology.d_earth_level)
X#define water_level		(dungeon_topology.d_water_level)
X#define fire_level		(dungeon_topology.d_fire_level)
X#define air_level		(dungeon_topology.d_air_level)
X#define astral_level		(dungeon_topology.d_astral_level)
X#define tower_dnum		(dungeon_topology.d_tower_dnum)
X#ifdef MULDGN
X#define mines_dnum		(dungeon_topology.d_mines_dnum)
X#define quest_dnum		(dungeon_topology.d_quest_dnum)
X#define qstart_level		(dungeon_topology.d_qstart_level)
X#define qlocate_level		(dungeon_topology.d_qlocate_level)
X#define nemesis_level		(dungeon_topology.d_nemesis_level)
X#define knox_level		(dungeon_topology.d_knox_level)
X#endif
X
XE stairway NEARDATA dnstair, NEARDATA upstair; /* stairs up and down. */
X#define xdnstair	(dnstair.sx)
X#define ydnstair	(dnstair.sy)
X#define xupstair	(upstair.sx)
X#define yupstair	(upstair.sy)
X
XE stairway NEARDATA dnladder, NEARDATA upladder; /* ladders up and down. */
X#define xdnladder	(dnladder.sx)
X#define ydnladder	(dnladder.sy)
X#define xupladder	(upladder.sx)
X#define yupladder	(upladder.sy)
X
XE stairway NEARDATA sstairs;
X
XE dest_area NEARDATA updest, NEARDATA dndest; /* level-change dest. areas */
X
XE coord NEARDATA inv_pos;
XE dungeon NEARDATA dungeons[];
XE s_level NEARDATA *sp_levchn;
X#define dunlev_reached(x)	(dungeons[(x)->dnum].dunlev_ureached)
X
X#ifdef MULDGN
X#include "quest.h"
XE struct q_score 	quest_status;
X#endif
X
XE int NEARDATA done_stopprint;
XE int NEARDATA done_hup;
X
XE char NEARDATA pl_character[PL_CSIZ];
X#ifdef TUTTI_FRUTTI
XE char NEARDATA pl_fruit[PL_FSIZ];
XE int NEARDATA current_fruit;
XE struct fruit NEARDATA *ffruit;
X#endif
X
XE char NEARDATA tune[6];
X
XE const char NEARDATA quitchars[];
XE const char NEARDATA vowels[];
XE const char NEARDATA ynchars[];
XE const char NEARDATA ynqchars[];
XE const char NEARDATA ynaqchars[];
XE const char NEARDATA ynNaqchars[];
XE long NEARDATA yn_number;
XE int NEARDATA smeq[];
XE int NEARDATA doorindex;
XE char NEARDATA *save_cm;
X#define KILLED_BY_AN	 0
X#define KILLED_BY	 1
X#define NO_KILLER_PREFIX 2
XE int NEARDATA killer_format;
XE const char NEARDATA *killer;
XE const char *configfile;
XE char NEARDATA plname[PL_NSIZ];
XE char NEARDATA dogname[];
XE char NEARDATA catname[];
XE char preferred_pet;
XE const char NEARDATA *occtxt;		/* defined when occupation != NULL */
XE const char NEARDATA *nomovemsg;
XE const char NEARDATA nul[];
XE const char *traps[];
XE char lock[];
X
XE const char NEARDATA sdir[], NEARDATA ndir[];
XE const schar NEARDATA xdir[], NEARDATA ydir[], zdir[];
X
XE schar NEARDATA tbx, NEARDATA tby;		/* set in mthrowu.c */
XE int NEARDATA dig_effort;	/* apply.c, hack.c */
XE d_level NEARDATA dig_level;
XE coord NEARDATA dig_pos;
XE boolean NEARDATA dig_down;
X
XE long NEARDATA moves, NEARDATA monstermoves;
XE long NEARDATA wailmsg;
X
XE boolean NEARDATA in_mklev;
XE boolean NEARDATA stoned;
XE boolean NEARDATA unweapon;
XE boolean NEARDATA mrg_to_wielded;
X
X#ifdef KOPS
XE boolean NEARDATA allow_kops;
X#endif
X
XE const int shield_static[];
X
X#ifndef SPELLS_H
X#include "spell.h"
X#endif
XE struct spell NEARDATA spl_book[];	/* sized in decl.c */
X
X#ifdef TEXTCOLOR
X# ifndef COLOR_H
X#include "color.h"
X# endif
XE const int zapcolors[];
X#endif
X
XE const char def_oc_syms[MAXOCLASSES];	/* default class symbols */
XE uchar oc_syms[MAXOCLASSES];		/* current class symbols */
XE const char def_monsyms[MAXMCLASSES];	/* default class symbols */
XE uchar monsyms[MAXMCLASSES];		/* current class symbols */
X
X#ifndef OBJ_H
X#include "obj.h"
X#endif
X
XE struct obj NEARDATA *invent, NEARDATA *uarm, NEARDATA *uarmc,
X	NEARDATA *uarmh, NEARDATA *uarms, NEARDATA *uarmg, NEARDATA *uarmf,
X#ifdef TOURIST
X	NEARDATA *uarmu, /* under-wear, so to speak */
X#endif
X#ifdef POLYSELF
X	NEARDATA *uskin,
X#endif
X	NEARDATA *uamul, NEARDATA *uleft, NEARDATA *uright, NEARDATA *ublindf,
X	NEARDATA *uwep;
X
XE struct obj NEARDATA *uchain;	/* defined only when punished */
XE struct obj NEARDATA *uball;
XE struct obj NEARDATA *migrating_objs;
XE struct obj NEARDATA *billobjs;
XE struct obj NEARDATA zeroobj;		/* init'd and defined in decl.c */
X
X#ifndef YOU_H
X#include "you.h"
X#endif
X
XE struct you NEARDATA u;
X
X#ifndef ONAMES_H
X#include "onames.h"
X#endif
X#ifndef PM_H
X#include "pm.h"
X#endif
X
XE struct permonst NEARDATA playermon, NEARDATA *uasmon;
X					/* also decl'd extern in permonst.h */
X					/* init'd in monst.c */
X
XE struct monst NEARDATA youmonst;	/* init'd and defined in decl.c */
XE struct monst NEARDATA *mydogs, NEARDATA *migrating_mons;
X
XE struct c_color_names {
X    char const	*const c_black, *const c_amber, *const c_golden,
X		*const c_light_blue,*const c_red, *const c_green,
X		*const c_silver, *const c_blue, *const c_purple,
X		*const c_white;
X} NEARDATA c_color_names;
X#define Black		c_color_names.c_black
X#define amber		c_color_names.c_amber
X#define golden		c_color_names.c_golden
X#define light_blue	c_color_names.c_light_blue
X#define red		c_color_names.c_red
X#define green		c_color_names.c_green
X#define silver		c_color_names.c_silver
X#define blue		c_color_names.c_blue
X#define purple		c_color_names.c_purple
X#define White		c_color_names.c_white
X
XE struct c_common_strings {
X    char const	*const c_nothing_happens, *const c_thats_enough_tries,
X		*const c_silly_thing_to, *const c_shudder_for_moment;
X} c_common_strings;
X#define nothing_happens    c_common_strings.c_nothing_happens
X#define thats_enough_tries c_common_strings.c_thats_enough_tries
X#define silly_thing_to	   c_common_strings.c_silly_thing_to
X#define shudder_for_moment c_common_strings.c_shudder_for_moment
X
X/* Vision */
XE boolean NEARDATA vision_full_recalc;	/* TRUE if need vision recalc */
XE char NEARDATA **viz_array;	/* could see/in sight row pointers */
X
X/* Window system stuff */
XE winid NEARDATA WIN_MESSAGE, NEARDATA WIN_STATUS;
XE winid NEARDATA WIN_MAP, NEARDATA WIN_INVEN;
XE char toplines[];
X#ifndef TERMCAP_H
XE struct tc_gbl_data {	/* also declared in termcap.h */
X    char *tc_AS, *tc_AE;	/* graphics start and end (tty font swapping) */
X    int   tc_LI,  tc_CO;	/* lines and columns */
X} tc_gbl_data;
X#define AS tc_gbl_data.tc_AS
X#define AE tc_gbl_data.tc_AE
X#define LI tc_gbl_data.tc_LI
X#define CO tc_gbl_data.tc_CO
X#endif
X
X/* xxxexplain[] is in drawing.c */
XE const char *monexplain[], *objexplain[], *oclass_names[];
X
XE const char NEARDATA *pl_classes;
X
X#undef E
X
X#endif /* DECL_H */
END_OF_FILE
if test 8850 -ne `wc -c <'include/decl.h'`; then
    echo shar: \"'include/decl.h'\" unpacked with wrong size!
fi
# end of 'include/decl.h'
fi
if test -f 'src/extralev.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/extralev.c'\"
else
echo shar: Extracting \"'src/extralev.c'\" \(8664 characters\)
sed "s/^X//" >'src/extralev.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)extralev.c	3.1	92/05/27			*/
X/*	Copyright 1988, 1989 by Ken Arromdee				*/
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include "hack.h"
X
X#ifdef REINCARNATION
X
Xstruct rogueroom {
X	xchar rlx, rly;
X	xchar dx, dy;
X	boolean real;
X	uchar doortable;
X	int nroom; /* Only meaningful for "real" rooms */
X};
X#define UP 1
X#define DOWN 2
X#define LEFT 4
X#define RIGHT 8
X
Xstatic struct rogueroom NEARDATA r[3][3];
Xstatic void FDECL(roguejoin,(int,int,int,int,int));
Xstatic void FDECL(roguecorr,(int,int,int));
Xstatic void FDECL(miniwalk,(int,int));
X
Xstatic
Xvoid
Xroguejoin(x1,y1,x2,y2, horiz)
Xint x1,y1,x2,y2;
Xint horiz;
X{
X	register int x,y,middle;
X#ifndef MAX
X#define MAX(a,b) (((a) > (b)) ? (a) : (b))
X#endif
X#ifndef MIN
X#define MIN(a,b) (((a) < (b)) ? (a) : (b))
X#endif
X	if (horiz) {
X		middle = x1 + rn2(x2-x1+1);
X		for(x=MIN(x1,middle); x<=MAX(x1,middle); x++)
X			corr(x, y1);
X		for(y=MIN(y1,y2); y<=MAX(y1,y2); y++)
X			corr(middle,y);
X		for(x=MIN(middle,x2); x<=MAX(middle,x2); x++)
X			corr(x, y2);
X	} else {
X		middle = y1 + rn2(y2-y1+1);
X		for(y=MIN(y1,middle); y<=MAX(y1,middle); y++)
X			corr(x1, y);
X		for(x=MIN(x1,x2); x<=MAX(x1,x2); x++)
X			corr(x, middle);
X		for(y=MIN(middle,y2); y<=MAX(middle,y2); y++)
X			corr(x2,y);
X	}
X}
X
Xstatic
Xvoid
Xroguecorr(x, y, dir)
Xint x,y,dir;
X{
X	register int fromx, fromy, tox, toy;
X
X	if (dir==DOWN) {
X		r[x][y].doortable &= ~DOWN;
X		if (!r[x][y].real) {
X			fromx = r[x][y].rlx; fromy = r[x][y].rly;
X			fromx += 1 + 26*x; fromy += 7*y;
X		} else {
X			fromx = r[x][y].rlx + rn2(r[x][y].dx);
X			fromy = r[x][y].rly + r[x][y].dy;
X			fromx += 1 + 26*x; fromy += 7*y;
X			if (!IS_WALL(levl[fromx][fromy].typ))
X				impossible("down: no wall at %d,%d?",fromx,
X									fromy);
X			dodoor(fromx, fromy, &rooms[r[x][y].nroom]);
X			levl[fromx][fromy].doormask = D_NODOOR;
X			fromy++;
X		}
X		if(y >= 2) {
X			impossible("down door from %d,%d going nowhere?",x,y);
X			return;
X		}
X		y++;
X		r[x][y].doortable &= ~UP;
X		if (!r[x][y].real) {
X			tox = r[x][y].rlx; toy = r[x][y].rly;
X			tox += 1 + 26*x; toy += 7*y;
X		} else {
X			tox = r[x][y].rlx + rn2(r[x][y].dx);
X			toy = r[x][y].rly - 1;
X			tox += 1 + 26*x; toy += 7*y;
X			if (!IS_WALL(levl[tox][toy].typ))
X				impossible("up: no wall at %d,%d?",tox,toy);
X			dodoor(tox, toy, &rooms[r[x][y].nroom]);
X			levl[tox][toy].doormask = D_NODOOR;
X			toy--;
X		}
X		roguejoin(fromx, fromy, tox, toy, FALSE);
X		return;
X	} else if (dir == RIGHT) {
X		r[x][y].doortable &= ~RIGHT;
X		if (!r[x][y].real) {
X			fromx = r[x][y].rlx; fromy = r[x][y].rly;
X			fromx += 1 + 26*x; fromy += 7*y;
X		} else {
X			fromx = r[x][y].rlx + r[x][y].dx;
X			fromy = r[x][y].rly + rn2(r[x][y].dy);
X			fromx += 1 + 26*x; fromy += 7*y;
X			if (!IS_WALL(levl[fromx][fromy].typ))
X				impossible("down: no wall at %d,%d?",fromx,
X									fromy);
X			dodoor(fromx, fromy, &rooms[r[x][y].nroom]);
X			levl[fromx][fromy].doormask = D_NODOOR;
X			fromx++;
X		}
X		if(x >= 2) {
X			impossible("right door from %d,%d going nowhere?",x,y);
X			return;
X		}
X		x++;
X		r[x][y].doortable &= ~LEFT;
X		if (!r[x][y].real) {
X			tox = r[x][y].rlx; toy = r[x][y].rly;
X			tox += 1 + 26*x; toy += 7*y;
X		} else {
X			tox = r[x][y].rlx - 1;
X			toy = r[x][y].rly + rn2(r[x][y].dy);
X			tox += 1 + 26*x; toy += 7*y;
X			if (!IS_WALL(levl[tox][toy].typ))
X				impossible("left: no wall at %d,%d?",tox,toy);
X			dodoor(tox, toy, &rooms[r[x][y].nroom]);
X			levl[tox][toy].doormask = D_NODOOR;
X			tox--;
X		}
X		roguejoin(fromx, fromy, tox, toy, TRUE);
X		return;
X	} else impossible("corridor in direction %d?",dir);
X}
X			
X/* Modified walkfrom() from mkmaze.c */
Xstatic
Xvoid
Xminiwalk(x, y)
Xint x,y;
X{
X	register int q, dir;
X	int dirs[4];
X
X	while(1) {
X		q = 0;
X#define doorhere (r[x][y].doortable)
X		if (x>0 && (!(doorhere & LEFT)) &&
X					(!r[x-1][y].doortable || !rn2(10)))
X			dirs[q++] = 0;
X		if (x<2 && (!(doorhere & RIGHT)) &&
X					(!r[x+1][y].doortable || !rn2(10)))
X			dirs[q++] = 1;
X		if (y>0 && (!(doorhere & UP)) &&
X					(!r[x][y-1].doortable || !rn2(10)))
X			dirs[q++] = 2;
X		if (y<2 && (!(doorhere & DOWN)) &&
X					(!r[x][y+1].doortable || !rn2(10)))
X			dirs[q++] = 3;
X	/* Rogue levels aren't just 3 by 3 mazes; they have some extra
X	 * connections, thus that 1/10 chance
X	 */
X		if (!q) return;
X		dir = dirs[rn2(q)];
X		switch(dir) { /* Move in direction */
X			case 0: doorhere |= LEFT;
X				x--;
X				doorhere |= RIGHT;
X				break;
X			case 1: doorhere |= RIGHT;
X				x++;
X				doorhere |= LEFT;
X				break;
X			case 2: doorhere |= UP;
X				y--;
X				doorhere |= DOWN;
X				break;
X			case 3: doorhere |= DOWN;
X				y++;
X				doorhere |= UP;
X				break;
X		}
X		miniwalk(x,y);
X	}
X}
X
Xvoid
Xmakeroguerooms() {
X	register int x,y;
X	/* Rogue levels are structured 3 by 3, with each section containing
X	 * a room or an intersection.  The minimum width is 2 each way.
X	 * One difference between these and "real" Rogue levels: real Rogue
X	 * uses 24 rows and NetHack only 23.  So we cheat a bit by making the
X	 * second row of rooms not as deep.
X	 *
X	 * Each normal space has 6/7 rows and 25 columns in which a room may
X	 * actually be placed.  Walls go from rows 0-5/6 and columns 0-24.
X	 * Not counting walls, the room may go in
X	 * rows 1-5 and columns 1-23 (numbering starting at 0).  A room
X	 * coordinate of this type may be converted to a level coordinate
X	 * by adding 1+28*x to the column, and 7*y to the row.  (The 1
X	 * is because column 0 isn't used [we only use 1-78]).
X	 * Room height may be 2-4 (2-5 on last row), length 2-23 (not
X	 * counting walls)
X	 */
X#define here r[x][y]
X
X	nroom = 0;
X	for(y=0; y<3; y++) for(x=0; x<3; x++) {
X		/* Note: we want to insure at least 1 room.  So, if the
X		 * first 8 are all dummies, force the last to be a room.
X		 */
X		if (!rn2(5) && (nroom || (x<2 && y<2))) {
X			/* Arbitrary: dummy rooms may only go where real
X			 * ones do.
X			 */
X			here.real = FALSE;
X			here.rlx = rn1(22, 2);
X			here.rly = rn1((y==2)?4:3, 2);
X		} else {
X			here.real = TRUE;
X			here.dx = rn1(22, 2); /* 2-23 long, plus walls */
X			here.dy = rn1((y==2)?4:3, 2); /* 2-5 high, plus walls */
X
X			/* boundaries of room floor */
X			here.rlx = rnd(23 - here.dx + 1);
X			here.rly = rnd(((y==2) ? 5 : 4)- here.dy + 1);
X			nroom++;
X		}
X		here.doortable = 0;
X	}
X	miniwalk(rn2(3), rn2(3));
X	nroom = 0;
X	for(y=0; y<3; y++) for(x=0; x<3; x++) {
X		if (here.real) { /* Make a room */
X			int lowx, lowy, hix, hiy;
X
X			r[x][y].nroom = nroom;
X			smeq[nroom] = nroom;
X
X			lowx = 1 + 26*x + here.rlx;
X			lowy = 7*y + here.rly;
X			hix = 1 + 26*x + here.rlx + here.dx - 1;
X			hiy = 7*y + here.rly + here.dy - 1;
X			/* Strictly speaking, it should be lit only if above
X			 * level 10, but since Rogue rooms are only
X			 * encountered below level 10, use !rn2(7).
X			 */
X
X			add_room(lowx, lowy, hix, hiy, !rn2(7), OROOM, FALSE);
X		}
X	}
X
X	/* Now, add connecting corridors. */
X	for(y=0; y<3; y++) for(x=0; x<3; x++) {
X		if (here.doortable & DOWN)
X			roguecorr(x, y, DOWN);
X		if (here.doortable & RIGHT)
X			roguecorr(x, y, RIGHT);
X		if (here.doortable & LEFT)
X			impossible ("left end of %d, %d never connected?",x,y);
X		if (here.doortable & UP)
X			impossible ("up end of %d, %d never connected?",x,y);
X	}
X}
X
Xvoid
Xcorr(x,y)
Xint x, y;
X{
X	if (rn2(50)) {
X		levl[x][y].typ = CORR;
X	} else {
X		levl[x][y].typ = SCORR;
X	}
X}
X
Xvoid
Xmakerogueghost()
X{
X	register struct monst *ghost;
X	struct obj *ghostobj;
X	struct mkroom *croom;
X	int x,y;
X
X	if (!nroom) return; /* Should never happen */
X	croom = &rooms[rn2(nroom)];
X	x = somex(croom); y = somey(croom);
X	if (!(ghost = makemon(&mons[PM_GHOST], x, y)))
X		return;
X	ghost->msleep = 1;
X	Strcpy((char *)ghost->mextra, roguename());
X
X	if (rn2(4)) {
X		ghostobj = mksobj_at(FOOD_RATION,x,y,FALSE);
X		ghostobj->quan = (long) rnd(7);
X		ghostobj->owt = weight(ghostobj);
X	}
X	if (rn2(2)) {
X		ghostobj = mksobj_at(MACE,x,y,FALSE);
X		ghostobj->spe = rnd(3);
X		if (rn2(4)) curse(ghostobj);
X	} else {
X		ghostobj = mksobj_at(TWO_HANDED_SWORD,x,y,FALSE);
X		ghostobj->spe = rnd(5) - 2;
X		if (rn2(4)) curse(ghostobj);
X	}
X	ghostobj = mksobj_at(BOW,x,y,FALSE);
X	ghostobj->spe = 1;
X	if (rn2(4)) curse(ghostobj);
X
X	ghostobj = mksobj_at(ARROW,x,y,FALSE);
X	ghostobj->spe = 0;
X	ghostobj->quan = (long) rn1(10,25);
X	ghostobj->owt = weight(ghostobj);
X	if (rn2(4)) curse(ghostobj);
X
X	if (rn2(2)) {
X		ghostobj = mksobj_at(RING_MAIL,x,y,FALSE);
X		ghostobj->spe = rn2(3);
X		if (!rn2(3)) ghostobj->oerodeproof = TRUE;
X		if (rn2(4)) curse(ghostobj);
X	} else {
X		ghostobj = mksobj_at(PLATE_MAIL,x,y,FALSE);
X		ghostobj->spe = rnd(5) - 2;
X		if (!rn2(3)) ghostobj->oerodeproof = TRUE;
X		if (rn2(4)) curse(ghostobj);
X	}
X	if (rn2(2)) {
X		ghostobj = mksobj_at(FAKE_AMULET_OF_YENDOR,x,y,TRUE);
X		ghostobj->known = TRUE;
X	}
X}
X#endif /* REINCARNATION /**/
X
X/*extralev.c*/
END_OF_FILE
if test 8664 -ne `wc -c <'src/extralev.c'`; then
    echo shar: \"'src/extralev.c'\" unpacked with wrong size!
fi
# end of 'src/extralev.c'
fi
if test -f 'src/mplayer.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/mplayer.c'\"
else
echo shar: Extracting \"'src/mplayer.c'\" \(8151 characters\)
sed "s/^X//" >'src/mplayer.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)mplayer.c	3.1	92/10/28	*/
X/*	Copyright (c) Izchak Miller, 1992.			  */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include "hack.h"
X
Xstatic const char *NDECL(dev_name);
Xstatic void FDECL(get_mplname, (struct monst *, char *));
Xstatic void FDECL(mk_mplayer_armor, (struct monst *, int, int));
X
X/* These are the names of those who
X * contributed to the development of NetHack 3.1.
X *
X * Keep in alphabetical order within teams.
X * Same first name is entered once within each team.
X */
Xstatic const char *developers[] = {
X	/* devteam */
X	"Dave", "Dean", "Eric", "Izchak", "Janet", "Jessie",
X	"Ken", "Kevin", "Matt", "Mike", "Pat", "Steve", "Timo",
X	/* PC team */
X	"Bill", "Carl", "John", "Kevin", "Mike", "Norm", "Paul",
X	"Stephen", "Steve",
X	/* Amiga team */
X	"Greg", "Gregg", "Keni", "Mike", "Olaf", "Richard",
X	/* Mac team */
X	"David", "Johnny", "Jon", "Jonathan", "Michael", "Rob",
X	"Tim", "Wang",
X	/* OS/2 team */
X	"Timo",
X	/* Atari team */
X	"Eric",
X	/* VMS team */
X	"Joshua", "Pat",
X	""};
X
X
X/* return a randomly chosen developer name */
Xstatic const char *
Xdev_name() 
X{
X	register int i, m = 0, n = SIZE(developers);
X	register struct monst *mtmp;
X	register boolean match;
X
X	do {
X	    match = FALSE;
X	    i = rn2(n);
X	    for (mtmp = fmon; mtmp; mtmp = mtmp->nmon) { 
X		if(!is_mplayer(mtmp->data)) continue;
X		if(!strncmp(developers[i], NAME(mtmp),
X			               strlen(developers[i]))) {
X		    match = TRUE;
X		    break;
X	        }
X	    }
X	    m++;
X	} while (match && m < 100); /* m for insurance */
X
X	if (match) return NULL;
X	return(developers[i]);
X}
X
Xstatic void
Xget_mplname(mtmp, nam)
Xregister struct monst *mtmp;
Xchar *nam;
X{
X	boolean fmlkind = is_female(mtmp->data);
X	const char *devnam;
X
X	devnam = dev_name();
X	if (!devnam)
X	    Strcpy(nam, fmlkind ? "Eve" : "Adam");
X	else if (fmlkind && !!strcmp(devnam, "Janet"))
X	    Strcpy(nam, rn2(2) ? "Maud" : "Eve");
X	else Strcpy(nam, devnam);
X
X	if (fmlkind || !strcmp(nam, "Janet"))
X	    mtmp->female = 1;
X	else
X	    mtmp->female = 0;
X	Strcat(nam, " the ");
X	Strcat(nam, rank_of((unsigned)rn1(12, 20), 
X		       highc(mtmp->data->mname[0]), (boolean)mtmp->female));
X}
X
Xstatic void
Xmk_mplayer_armor(mon, range1, range2)
Xstruct monst *mon;
Xint range1, range2;
X{
X	struct obj *obj;
X
X	obj = mksobj(rnd_class(range1, range2), FALSE, FALSE);
X	if (!rn2(3)) obj->oerodeproof = 1;
X	if (!rn2(3)) curse(obj);
X	if (!rn2(3)) bless(obj);
X	/* Most players who get to the endgame who have cursed equipment
X	 * have it because the wizard or other monsters cursed it, so its
X	 * chances of having plusses is the same as usual....
X	 */
X	obj->spe = rn2(10) ? (rn2(3) ? rn2(5) : rn1(4,4)) : -rnd(3);
X	mpickobj(mon, obj);
X}
X
Xstruct monst *
Xmk_mplayer(ptr, x, y, special)
Xregister struct permonst *ptr;
Xxchar x, y;
Xregister boolean special;
X{
X	register struct monst *mtmp;
X	char nam[PL_NSIZ];
X
X	if(!is_mplayer(ptr)) 
X		return((struct monst *)0);
X
X	if(MON_AT(x, y))
X		rloc(m_at(x, y)); /* insurance */
X
X	if(!In_endgame(&u.uz)) special = FALSE;
X
X	if ((mtmp = makemon(ptr, x, y)) != 0) {
X	    int weapon, quan;
X	    struct obj *otmp;
X
X	    mtmp->m_lev = (special ? rn1(8,12) : rnd(16));
X	    mtmp->mhp = mtmp->mhpmax = (special ?
X	                      (d((int)mtmp->m_lev,10) + 30 + rnd(30)) :
X	                      (d((int)mtmp->m_lev,10) + 30));
X	    if(special) {
X	        get_mplname(mtmp, nam);
X	        mtmp = christen_monst(mtmp, nam);
X	    }
X	    mtmp->mpeaceful = 0;
X	    set_malign(mtmp); /* peaceful may have changed again */
X	    if(special && In_endgame(&u.uz))
X		/* that's why they are "stuck" in the endgame :-) */
X		(void)mongets(mtmp, FAKE_AMULET_OF_YENDOR);
X	    switch(monsndx(ptr)) {
X		case PM_ARCHEOLOGIST:
X		    weapon = BULLWHIP;
X		    break;
X		case PM_BARBARIAN:
X		    weapon = rn2(2) ? TWO_HANDED_SWORD : BATTLE_AXE;
X		    break;
X		case PM_CAVEMAN:
X		case PM_CAVEWOMAN:
X		    weapon = CLUB;
X		    break;
X		case PM_ELF:
X		    weapon = ELVEN_SHORT_SWORD;
X		    break;
X		case PM_HEALER:
X		    weapon = SCALPEL;
X		    break;
X		case PM_KNIGHT:
X		    weapon = LONG_SWORD;
X		    break;
X		case PM_PRIEST:
X		case PM_PRIESTESS:
X		    weapon = MACE;
X		    break;
X		case PM_ROGUE:
X		    weapon = SHORT_SWORD;
X		    break;
X		case PM_SAMURAI:
X		    weapon = KATANA;
X		    break;
X#ifdef TOURIST
X		case PM_TOURIST:
X		    weapon = 0;
X		    break;
X#endif
X		case PM_VALKYRIE:
X		    weapon = LONG_SWORD;
X		    break;
X		case PM_WIZARD:
X		    weapon = ATHAME;
X		    break;
X		default: impossible("bad mplayer monster");
X		    weapon = 0;
X		    break;
X	    }
X	    if (rn2(2) && weapon)
X		otmp = mksobj(weapon, TRUE, FALSE);
X	    else
X		otmp = mksobj(rn2(2) ? LONG_SWORD : 
X			      rnd_class(SPEAR, BULLWHIP), TRUE, FALSE);
X	    otmp->spe = (special ? rn1(5,4) : rn2(4));
X	    if (!rn2(3)) otmp->oerodeproof = 0;
X	    if(special) {
X	        /* probably the player got most artifacts anyway. */
X	        if(In_endgame(&u.uz) && rn2(2)) 
X		          otmp = mk_artifact(otmp, A_NONE);
X	        mpickobj(mtmp, otmp);
X	        if (!rn2(10))
X		    (void) mongets(mtmp, rn2(3) ? LUCKSTONE : LOADSTONE);
X	        if (rn2(8))
X	        mk_mplayer_armor(mtmp, ELVEN_LEATHER_HELM, HELM_OF_TELEPATHY);
X	        if (!rn2(3))
X		    mk_mplayer_armor(mtmp, GRAY_DRAGON_SCALE_MAIL,
X			YELLOW_DRAGON_SCALE_MAIL);
X	        else if (rn2(15))
X		    mk_mplayer_armor(mtmp, PLATE_MAIL, CHAIN_MAIL);
X	        if (rn2(8))
X		    mk_mplayer_armor(mtmp, ELVEN_SHIELD, 
X				               SHIELD_OF_REFLECTION);
X	        if (rn2(8))
X		    mk_mplayer_armor(mtmp, LEATHER_GLOVES, 
X				               GAUNTLETS_OF_DEXTERITY);
X	        if (rn2(8))
X		    mk_mplayer_armor(mtmp, LOW_BOOTS, LEVITATION_BOOTS);
X#ifdef MUSE
X	        /* Not clear what to do without MUSE. */
X	        m_dowear(mtmp, TRUE);
X#endif
X	        quan = rn2(3) ? rn2(3) : rn2(16);
X	        while(quan--)
X		    (void)mongets(mtmp, rnd_class(DILITHIUM_CRYSTAL, JADE));
X	        /* To get the gold "right" would mean a player can double his */
X	        /* gold supply by killing one mplayer.  Not good. */
X	        mtmp->mgold = rn2(1000);
X	        quan = rn2(10);
X	        while(quan--)
X		    mpickobj(mtmp, mkobj(RANDOM_CLASS, FALSE));
X	    }
X#ifdef MUSE
X	    quan = rnd(3);
X	    while(quan--)
X		(void)mongets(mtmp, rnd_offensive_item(mtmp));
X	    quan = rnd(3);
X	    while(quan--)
X		(void)mongets(mtmp, rnd_defensive_item(mtmp));
X	    quan = rnd(3);
X	    while(quan--)
X		(void)mongets(mtmp, rnd_misc_item(mtmp));
X#endif
X	}
X
X	return(mtmp);
X}
X
X/* create the indicated number (num) of monster-players,
X * randomly chosen, and in randomly chosen (free) locations
X * on the level.  If "special", the size of num should not
X * be bigger than the number of _non-repeated_ names in the
X * developers array, otherwise a bunch of Adams and Eves will
X * fill up the overflow.
X */
Xvoid
Xcreate_mplayers(num, special)
Xregister int num;
Xboolean special;
X{
X	register int pm, x, y;
X
X	while(num) {
X		int tryct = 0;
X
X		/* roll for character class */
X		pm = PM_ARCHEOLOGIST + rn2(PM_WIZARD - PM_ARCHEOLOGIST + 1);
X
X		/* roll for an available location */
X		do {
X		    x = rn1(COLNO-4, 2);
X		    y = rnd(ROWNO-2);
X		} while(!goodpos(x, y, (struct monst *)0, &mons[pm]) ||
X			 tryct++ >= 50);
X
X		/* if pos not found in 50 tries, don't bother to continue */
X		if(tryct > 50) return;
X
X		(void) mk_mplayer(&mons[pm], (xchar)x, (xchar)y, special);
X		num--;
X	}
X}
X
Xvoid
Xmplayer_talk(mtmp)
Xregister struct monst *mtmp;
X{
X	char pbuf[BUFSZ];
X
X	if(mtmp->mpeaceful) return; /* will drop to humanoid talk */
X
X	Strcpy(pbuf, "Talk? -- ");
X	if(pl_character[0] == highc(*mtmp->data->mname)) { /* same kind */
X	     switch(rn2(4)) {
X	       case 0: Strcat(pbuf, "I can't win, and neither will you!");
X		       break;
X	       case 1: Strcat(pbuf, "You don't deserve to win!");
X		       break;
X	       case 3: Strcat(pbuf, "Mine should be the honor, not yours!");
X		       break;
X	     }
X	} else {
X	     switch(rn2(4)) {
X	       case 0: Strcat(pbuf, "The low-life wants to talk, eh?");
X		       break;
X	       case 1: Strcat(pbuf, "Fight, scum!");
X		       break;
X	       case 3: Strcat(pbuf, "Here is what I have to say!");
X		       break;
X	     }
X	}
X	pline(pbuf);
X}
X
X/*mplayer.c*/
END_OF_FILE
if test 8151 -ne `wc -c <'src/mplayer.c'`; then
    echo shar: \"'src/mplayer.c'\" unpacked with wrong size!
fi
# end of 'src/mplayer.c'
fi
if test -f 'src/wield.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/wield.c'\"
else
echo shar: Extracting \"'src/wield.c'\" \(7935 characters\)
sed "s/^X//" >'src/wield.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)wield.c	3.1	92/12/10	*/
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include	"hack.h"
X
X/* elven weapons vibrate warningly when enchanted beyond a limit */
X#define is_elven_weapon(optr)	((optr)->otyp == ELVEN_ARROW\
X				|| (optr)->otyp == ELVEN_SPEAR\
X				|| (optr)->otyp == ELVEN_DAGGER\
X				|| (optr)->otyp == ELVEN_SHORT_SWORD\
X				|| (optr)->otyp == ELVEN_BROADSWORD\
X				|| (optr)->otyp == ELVEN_BOW)
X
X/* Note: setuwep() with a null obj, and uwepgone(), are NOT the same!  Sometimes
X * unwielding a weapon can kill you, and lifesaving will then put it back into
X * your hand.  If lifesaving is permitted to do this, use
X * setwuep((struct obj *)0); otherwise use uwepgone().
X */
Xvoid
Xsetuwep(obj)
Xregister struct obj *obj;
X{
X	setworn(obj, W_WEP);
X	/* Note: Explicitly wielding a pick-axe will not give a "bashing"
X	 * message.  Wielding one via 'a'pplying it will.
X	 */
X	if (obj)
X		unweapon = ((obj->otyp >= BOW || obj->otyp <= BOOMERANG) &&
X			obj->otyp != PICK_AXE && obj->otyp != UNICORN_HORN);
X	else
X		unweapon = TRUE;	/* for "bare hands" message */
X}
X
Xvoid
Xuwepgone()
X{
X	if (uwep) {
X		setnotworn(uwep);
X		unweapon = TRUE;
X	}
X}
X
Xstatic const char NEARDATA wield_objs[] =
X	{ ALL_CLASSES, ALLOW_NONE, WEAPON_CLASS, TOOL_CLASS, 0 };
X
Xint
Xdowield()
X{
X	register struct obj *wep;
X	register int res = 0;
X
X	multi = 0;
X#ifdef POLYSELF
X	if (cantwield(uasmon)) {
X		pline("Don't be ridiculous!");
X		return(0);
X	}
X#endif
X	if (!(wep = getobj(wield_objs, "wield"))) /* nothing */;
X	else if (uwep == wep)
X		You("are already wielding that!");
X	else if (welded(uwep))
X		weldmsg(uwep, TRUE);
X	else if (wep == &zeroobj) {
X	    if (uwep == 0)
X		You("are already empty %s.", body_part(HANDED));
X	    else  {
X	  	You("are empty %s.", body_part(HANDED));
X	  	setuwep((struct obj *) 0);
X	  	res++;
X	    }
X	} else if (!uarmg &&
X#ifdef POLYSELF
X		   !resists_ston(uasmon) &&
X#endif
X		   (wep->otyp == CORPSE && wep->corpsenm == PM_COCKATRICE)) {
X	    /* Prevent wielding cockatrice when not wearing gloves --KAA */
X	    You("wield the cockatrice corpse in your bare %s.",
X			makeplural(body_part(HAND)));
X# ifdef POLYSELF
X	    if (!(poly_when_stoned(uasmon) && polymon(PM_STONE_GOLEM)))
X# endif
X	    {
X		You("turn to stone...");
X		killer_format = KILLED_BY;
X		killer="touching a cockatrice corpse";
X		done(STONING);
X	    }
X	} else if (uarms && bimanual(wep))
X	    You("cannot wield a two-handed %s while wearing a shield.",
X		is_sword(wep) ? "sword" :
X		    wep->otyp == BATTLE_AXE ? "axe" : "weapon");
X	else if (wep->owornmask & (W_ARMOR | W_RING | W_AMUL | W_TOOL))
X		You("cannot wield that!");
X	else if (!wep->oartifact || touch_artifact(wep,&youmonst)) {
X		res++;
X		if (wep->cursed &&
X		    (wep->oclass == WEAPON_CLASS ||
X		     wep->otyp == HEAVY_IRON_BALL || wep->otyp == PICK_AXE ||
X		     wep->otyp == UNICORN_HORN || wep->otyp == TIN_OPENER)) {
X		    const char *tmp = xname(wep), *thestr = "The ";
X		    if (strncmp(tmp, thestr, 4) && !strncmp(The(tmp),thestr,4))
X			tmp = thestr;
X		    else tmp = "";
X		    pline("%s%s %s to your %s!",
X			tmp, aobjnam(wep, "weld"),
X			(wep->quan == 1L) ? "itself" : "themselves", /* a3 */
X			body_part(HAND));
X		    wep->bknown = TRUE;
X		} else {
X			/* The message must be printed before setuwep (since
X			 * you might die and be revived from changing weapons),
X			 * and the message must be before the death message and
X			 * Lifesaved rewielding.  Yet we want the message to
X			 * say "weapon in hand", thus this kludge.
X			 */
X			long dummy = wep->owornmask;
X			wep->owornmask |= W_WEP;
X			prinv(NULL, wep, 0L);
X			wep->owornmask = dummy;
X		}
X		setuwep(wep);
X	}
X	return(res);
X}
X
Xvoid
Xerode_weapon(acid_dmg)
Xboolean acid_dmg;
X/* Rust weapon, or corrode it if acid damage is called for */
X{
X	if(!uwep || uwep->oclass != WEAPON_CLASS) return;	/* %% */
X	if (uwep->greased) {
X		grease_protect(uwep,NULL,FALSE);
X	} else if(uwep->oerodeproof ||
X	   (acid_dmg ? !is_corrodeable(uwep) : !is_rustprone(uwep))) {
X		if (flags.verbose || !(uwep->oerodeproof && uwep->rknown))
X		    Your("%s not affected.", aobjnam(uwep, "are"));
X		if (uwep->oerodeproof) uwep->rknown = TRUE;
X	} else if (uwep->oeroded < MAX_ERODE) {
X		Your("%s%s!", aobjnam(uwep, acid_dmg ? "corrode" : "rust"),
X		     uwep->oeroded+1 == MAX_ERODE ? " completely" :
X		     uwep->oeroded ? " further" : "");
X		uwep->oeroded++;
X	} else
X		if (flags.verbose)
X		    Your("%s completely %s.",
X			 aobjnam(uwep, Blind ? "feel" : "look"),
X			 acid_dmg ? "corroded" : "rusty");
X}
X
Xint
Xchwepon(otmp, amount)
Xregister struct obj *otmp;
Xregister int amount;
X{
X	register const char *color = Hallucination ? hcolor() :
X				     (amount < 0) ? Black : blue;
X	register const char *xtime;
X
X	if(!uwep || (uwep->oclass != WEAPON_CLASS && uwep->otyp != PICK_AXE
X			&& uwep->otyp != UNICORN_HORN)) {
X		char buf[36];
X
X		Sprintf(buf, "Your %s %s.", makeplural(body_part(HAND)),
X			(amount >= 0) ? "twitch" : "itch");
X		strange_feeling(otmp, buf);
X		exercise(A_DEX, amount >= 0);
X		return(0);
X	}
X
X	if(uwep->otyp == WORM_TOOTH && amount >= 0) {
X		uwep->otyp = CRYSKNIFE;
X		Your("weapon seems sharper now.");
X		uwep->cursed = 0;
X		return(1);
X	}
X
X	if(uwep->otyp == CRYSKNIFE && amount < 0) {
X		uwep->otyp = WORM_TOOTH;
X		Your("weapon seems duller now.");
X		return(1);
X	}
X
X	if (amount < 0 && uwep->oartifact && restrict_name(uwep, ONAME(uwep))) {
X	    if (!Blind)
X		Your("%s %s.", aobjnam(uwep, "faintly glow"), color);
X	    return(1);
X	}
X	/* there is a (soft) upper and lower limit to uwep->spe */
X	if(((uwep->spe > 5 && amount >= 0) || (uwep->spe < -5 && amount < 0))
X								&& rn2(3)) {
X	    if (!Blind)
X	    Your("%s %s for a while and then evaporate%s.",
X		 aobjnam(uwep, "violently glow"), color,
X		 uwep->quan == 1L ? "s" : "");
X	    else
X		Your("%s.", aobjnam(uwep, "evaporate"));
X
X	    while(uwep)		/* let all of them disappear */
X				/* note: uwep->quan = 1 is nogood if unpaid */
X		useup(uwep);
X	    return(1);
X	}
X	if (!Blind) {
X	    xtime = (amount*amount == 1) ? "moment" : "while";
X	    Your("%s %s for a %s.",
X		 aobjnam(uwep, amount == 0 ? "violently glow" : "glow"),
X		 color, xtime);
X	}
X	uwep->spe += amount;
X	if(amount > 0) uwep->cursed = 0;
X
X	/*
X	 * Enchantment, which normally improves a weapon, has an
X	 * addition adverse reaction on Magicbane whose effects are
X	 * spe dependent.  Give an obscure clue here.
X	 */
X	if (uwep->oartifact == ART_MAGICBANE && uwep->spe >= 0) {
X		Your("right %s %sches!",
X			body_part(HAND),
X			(((amount > 1) && (uwep->spe > 1)) ? "flin" : "it"));
X	}
X
X	/* an elven magic clue, cookie@keebler */
X	if ((uwep->spe > 5)
X		&& (is_elven_weapon(uwep) || uwep->oartifact || !rn2(7)))
X	    Your("%s unexpectedly.",
X		aobjnam(uwep, "suddenly vibrate"));
X
X	return(1);
X}
X
Xint
Xwelded(obj)
Xregister struct obj *obj;
X{
X	if (obj && obj == uwep && obj->cursed &&
X		  (obj->oclass == WEAPON_CLASS ||
X		   obj->otyp == HEAVY_IRON_BALL ||
X		   obj->otyp == TIN_OPENER || obj->otyp == PICK_AXE ||
X		   obj->otyp == UNICORN_HORN))
X	{
X		obj->bknown = TRUE;
X		return 1;
X	}
X	return 0;
X}
X
X/* The reason for "specific" is historical; some parts of the code used
X * the object name and others just used "weapon"/"sword".  This function
X * replaced all of those.  Which one we use is really arbitrary.
X */
Xvoid
Xweldmsg(obj, specific)
Xregister struct obj *obj;
Xboolean specific;
X{
X	char buf[BUFSZ];
X
X	if (specific) {
X		long savewornmask = obj->owornmask;
X		obj->owornmask &= ~W_WEP;
X		Strcpy(buf, Doname2(obj));
X		obj->owornmask = savewornmask;
X	} else
X		Sprintf(buf, "Your %s%s",
X			is_sword(obj) ? "sword" : "weapon",
X			plur(obj->quan));
X	Strcat(buf, (obj->quan == 1L) ? " is" : " are");
X#ifdef POLYSELF
X	Sprintf(eos(buf), " welded to your %s!",
X		bimanual(obj) ? (const char *)makeplural(body_part(HAND)) : body_part(HAND));
X#else
X	Sprintf(eos(buf), " welded to your hand%s!",
X		bimanual(obj) ? "s" : "");
X#endif
X	pline(buf);
X}
X
X/*wield.c*/
END_OF_FILE
if test 7935 -ne `wc -c <'src/wield.c'`; then
    echo shar: \"'src/wield.c'\" unpacked with wrong size!
fi
# end of 'src/wield.c'
fi
if test -f 'sys/share/pcunix.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/share/pcunix.c'\"
else
echo shar: Extracting \"'sys/share/pcunix.c'\" \(2804 characters\)
sed "s/^X//" >'sys/share/pcunix.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)pcunix.c	3.1	90/22/02
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X/* This file collects some Unix dependencies; pager.c contains some more */
X
X#include "hack.h"
X
X#include	<sys/stat.h>
X
X#ifdef OVLB
X
Xstatic struct stat buf;
X# ifdef WANT_GETHDATE
Xstatic struct stat hbuf;
X# endif
X
Xvoid
Xgethdate(name)
Xchar *name;
X{
X# ifdef WANT_GETHDATE
X/* old version - for people short of space */
X/*
X/* register char *np;
X/*      if(stat(name, &hbuf))
X/*	      error("Cannot get status of %s.",
X/*		      (np = rindex(name, '/')) ? np+1 : name);
X/*
X/* version using PATH from: seismo!gregc@ucsf-cgl.ARPA (Greg Couch) */
X
X/*
X * The problem with   #include  <sys/param.h> is that this include file
X * does not exist on all systems, and moreover, that it sometimes includes
X * <sys/types.h> again, so that the compiler sees these typedefs twice.
X */
X#define	 MAXPATHLEN      1024
X
X    register char *np, *path;
X    char filename[MAXPATHLEN+1], *getenv();
X
X    if (index(name, '/') != NULL || (path = getenv("PATH")) == NULL)
X	path = "";
X
X    for (;;) {
X	if ((np = index(path, ':')) == NULL)
X	    np = path + strlen(path);       /* point to end str */
X	if (np - path <= 1)		     /* %% */
X	    Strcpy(filename, name);
X	else {
X	    (void) strncpy(filename, path, np - path);
X	    filename[np - path] = '/';
X	    Strcpy(filename + (np - path) + 1, name);
X	}
X	if (stat(filename, &hbuf) == 0)
X	    return;
X	if (*np == '\0')
X	path = "";
X	path = np + 1;
X    }
X    error("Cannot get status of %s.", (np = rindex(name, '/')) ? np+1 : name);
X# endif /* WANT_GETHDATE */
X}
X
Xint
Xuptodate(fd)
Xint fd;
X{
X# ifdef WANT_GETHDATE
X    if(fstat(fd, &buf)) {
X	pline("Cannot get status of saved level? ");
X	return(0);
X    }
X    if(buf.st_mtime < hbuf.st_mtime) {
X	pline("Saved level is out of date. ");
X	return(0);
X    }
X# else
X#  if defined(MICRO) && !defined(NO_FSTAT)
X    if(fstat(fd, &buf)) {
X	if(moves > 1) pline("Cannot get status of saved level? ");
X	else pline("Cannot get status of saved game");
X	return(0);
X    } 
X    if(comp_times(buf.st_mtime)) { 
X	if(moves > 1) pline("Saved level is out of date");
X	else pline("Saved game is out of date. ");
X	return(0);
X    }
X#  endif  /* MICRO /* */
X# endif /* WANT_GETHDATE */
X    return(1);
X}
X
Xvoid
Xregularize(s)
X/*
X * normalize file name - we don't like .'s, /'s, spaces, and
X * lots of other things
X */
Xregister char *s;
X{
X	register char *lp;
X
X	for (lp = s; *lp; lp++)
X		if (*lp <= ' ' || *lp == '"' || (*lp >= '*' && *lp <= ',') ||
X		    *lp == '.' || *lp == '/' || (*lp >= ':' && *lp <= '?') ||
X# ifdef OS2
X		    *lp == '&' || *lp == '(' || *lp == ')' ||
X# endif
X		    *lp == '|' || *lp >= 127 || (*lp >= '[' && *lp <= ']'))
X                        *lp = '_';
X}
X
X#endif /* OVLB */
END_OF_FILE
if test 2804 -ne `wc -c <'sys/share/pcunix.c'`; then
    echo shar: \"'sys/share/pcunix.c'\" unpacked with wrong size!
fi
# end of 'sys/share/pcunix.c'
fi
if test -f 'win/tty/topl.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'win/tty/topl.c'\"
else
echo shar: Extracting \"'win/tty/topl.c'\" \(7994 characters\)
sed "s/^X//" >'win/tty/topl.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)topl.c	3.1	90/09/21
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include "hack.h"
X#include "termcap.h"
X#include "wintty.h"
X#include <ctype.h>
X
XSTATIC_DCL void FDECL(redotoplin, (const char*));
XSTATIC_DCL void FDECL(topl_putsym, (CHAR_P));
XSTATIC_DCL void NDECL(remember_topl);
Xstatic void FDECL(removetopl, (int));
X
X#ifdef OVLB
X
Xint
Xtty_doprev_message()
X{
X    register struct WinDesc *cw = wins[WIN_MESSAGE];
X
X    if(cw->data[cw->maxcol])
X	redotoplin(cw->data[cw->maxcol]);
X    else if(cw->maxcol == cw->maxrow)
X	redotoplin(toplines);
X    cw->maxcol--;
X    if(cw->maxcol < 0) cw->maxcol = cw->rows-1;
X    if(!cw->data[cw->maxcol])
X	cw->maxcol = cw->maxrow;
X    return 0;
X}
X
X#endif /* OVLB */
X#ifdef OVL1
X
XSTATIC_OVL void
Xredotoplin(str)
X    const char *str;
X{
X	int otoplin = ttyDisplay->toplin;
X	home();
X	if(*str & 0x80) {
X		/* kludge for the / command, the only time we ever want a */
X		/* graphics character on the top line */
X		g_putch(*str++);
X		ttyDisplay->curx++;
X	}
X	end_glyphout();	/* in case message printed during graphics output */
X	putsyms(str);
X	cl_end();
X	ttyDisplay->toplin = 1;
X	if(ttyDisplay->cury && otoplin != 3)
X		more();
X}
X
XSTATIC_OVL void
Xremember_topl()
X{
X    register struct WinDesc *cw = wins[WIN_MESSAGE];
X
X    cw->data[cw->maxrow] = (char*) alloc(strlen(toplines)+1);
X    Strcpy(cw->data[cw->maxrow], toplines);
X    cw->maxcol = cw->maxrow = (cw->maxrow+1) % cw->rows;
X    if(cw->data[cw->maxrow]) {
X	free((genericptr_t)cw->data[cw->maxrow]);
X	cw->data[cw->maxrow] = 0;
X    }
X}
X
Xvoid
Xaddtopl(s)
Xconst char *s;
X{
X    register struct WinDesc *cw = wins[WIN_MESSAGE];
X
X    tty_curs(BASE_WINDOW,cw->curx+1,cw->cury);
X    if(cw->curx + (int)strlen(s) >= CO) topl_putsym('\n');
X    putsyms(s);
X    cl_end();
X    ttyDisplay->toplin = 1;
X}
X
X#endif /* OVL1 */
X#ifdef OVL2
X
Xvoid
Xmore()
X{
X    struct WinDesc *cw = wins[WIN_MESSAGE];
X
X    /* avoid recursion -- only happens from interrupts */
X    if(ttyDisplay->inmore++)
X	return;
X
X    if(ttyDisplay->toplin) {
X	tty_curs(BASE_WINDOW, cw->curx+1, cw->cury);
X	if(cw->curx >= CO - 8) topl_putsym('\n');
X    }
X
X    if(flags.standout)
X	standoutbeg();
X    putsyms(defmorestr);
X    if(flags.standout)
X	standoutend();
X
X    xwaitforspace("\033");
X
X    if(morc == '\033')
X	cw->flags |= WIN_STOP;
X
X    if(ttyDisplay->toplin && cw->cury) {
X	docorner(1, cw->cury+1);
X	cw->curx = cw->cury = 0;
X	home();
X    } else if(morc == '\033') {
X	cw->curx = cw->cury = 0;
X	home();
X	cl_end();
X    }
X    ttyDisplay->toplin = 0;
X    ttyDisplay->inmore = 0;
X}
X
Xvoid
Xupdate_topl(bp)
X	register const char *bp;
X{
X	register char *tl, *otl;
X	register int n0;
X	int notdied = 1;
X	struct WinDesc *cw = wins[WIN_MESSAGE];
X
X	/* If there is room on the line, print message on same line */
X	/* But messages like "You die..." deserve their own line */
X	n0 = strlen(bp);
X	if(ttyDisplay->toplin == 1 && cw->cury == 0 &&
X	    n0 + (int)strlen(toplines) + 3 < CO-8 &&  /* room for --More-- */
X	    (notdied = strncmp(bp, "You die", 7))) {
X		Strcat(toplines, "  ");
X		Strcat(toplines, bp);
X		cw->curx += 2;
X		if(!(cw->flags & WIN_STOP))
X		    addtopl(bp);
X		return;
X	} else if(!(cw->flags & WIN_STOP)) {
X	    if(ttyDisplay->toplin == 1) more();
X	    else if(cw->cury) {	/* for when flags.toplin == 2 && cury > 1 */
X		docorner(1, cw->cury+1); /* reset cury = 0 if redraw screen */
X		cw->curx = cw->cury = 0;/* from home--cls() & docorner(1,n) */
X	    }
X	}
X	remember_topl();
X	Strcpy(toplines, bp);
X	for(tl = toplines; n0 >= CO; ){
X	    otl = tl;
X	    for(tl+=CO-1; tl != otl && !isspace(*tl); --tl) ;
X	    if(tl == otl) {
X		/* Eek!  A huge token.  Try splitting after it. */
X		tl = index(otl, ' ');
X		if (!tl) break;    /* No choice but to spit it out whole. */
X	    }
X	    *tl++ = '\n';
X	    n0 = strlen(tl);
X	}
X	if(!notdied) cw->flags &= ~WIN_STOP;
X	if(!(cw->flags & WIN_STOP)) redotoplin(toplines);
X}
X
XSTATIC_OVL
Xvoid
Xtopl_putsym(c)
X    char c;
X{
X    register struct WinDesc *cw = wins[WIN_MESSAGE];
X
X    if(cw == (struct WinDesc *) 0) panic("Putsym window MESSAGE nonexistant");
X	
X    switch(c) {
X    case '\b':
X	if(ttyDisplay->curx == 0 && ttyDisplay->cury > 0)
X	    tty_curs(BASE_WINDOW, CO, (int)ttyDisplay->cury-1);
X	backsp();
X	ttyDisplay->curx--;
X	cw->curx = ttyDisplay->curx;
X	return;
X    case '\n':
X	cl_end();
X	ttyDisplay->curx = 0;
X	ttyDisplay->cury++;
X	cw->cury = ttyDisplay->cury;
X	break;
X    default:
X	if(ttyDisplay->curx == CO-1)
X	    topl_putsym('\n'); /* 1 <= curx <= CO; avoid CO */
X	ttyDisplay->curx++;
X    }
X    cw->curx = ttyDisplay->curx;
X    if(cw->curx == 0) cl_end();
X    (void) putchar(c);
X}
X
Xvoid
Xputsyms(str)
X    const char *str;
X{
X    while(*str)
X	topl_putsym(*str++);
X}
X
Xstatic void
Xremovetopl(n)
Xregister int n;
X{
X    /* assume addtopl() has been done, so ttyDisplay->toplin is already set */
X    while (n-- > 0) putsyms("\b \b");
X}
X
Xextern char erase_char;		/* from xxxtty.c; don't need kill_char */
X
Xchar
Xtty_yn_function(query,resp, def)
Xconst char *query,*resp;
Xchar def;
X/*
X *   Generic yes/no function. 'def' is the default (returned by space or
X *   return; 'esc' returns 'q', or 'n', or the default, depending on
X *   what's in the string. The 'query' string is printed before the user
X *   is asked about the string.
X *   If resp is NULL, any single character is accepted and returned.
X */
X{
X	register char q;
X	char rtmp[40];
X	boolean digit_ok, allow_num;
X	struct WinDesc *cw = wins[WIN_MESSAGE];
X	boolean doprev = 0;
X	char prompt[QBUFSZ];
X
X	if(ttyDisplay->toplin == 1 && !(cw->flags & WIN_STOP)) more();
X	cw->flags &= ~WIN_STOP;
X	ttyDisplay->toplin = 3; /* special prompt state */
X	ttyDisplay->inread++;
X	if(resp) {
X	    allow_num = (index(resp, '#') != 0);
X	    if(def)
X		Sprintf(prompt, "%s [%s] (%c) ", query, resp, def);
X	    else
X		Sprintf(prompt, "%s [%s] ", query, resp);
X	    pline("%s", prompt);
X	} else {
X	    pline("%s ", query);
X	    q = readchar();
X	    goto clean_up;
X	}
X
X	do {	/* loop until we get valid input */
X	    q = lowc(readchar());
X	    if (q == '\020') { /* ctrl-P */
X		if(!doprev) (void) tty_doprev_message(); /* need two initially */
X		(void) tty_doprev_message();
X		q = (char)0;
X		doprev = 1;
X		continue;
X	    } else if(doprev) {
X		tty_clear_nhwindow(WIN_MESSAGE);
X		cw->maxcol = cw->maxrow;
X		doprev = 0;
X		addtopl(prompt);
X		continue;
X	    }
X	    digit_ok = allow_num && digit(q);
X	    if (q == '\033') {
X		if (index(resp, 'q'))
X		    q = 'q';
X		else if (index(resp, 'n'))
X		    q = 'n';
X		else
X		    q = def;
X		break;
X	    } else if (index(quitchars, q)) {
X		q = def;
X		break;
X	    }
X	    if (!index(resp, q) && !digit_ok) {
X		tty_nhbell();
X		q = (char)0;
X	    } else if (q == '#' || digit_ok) {
X		char z, digit_string[2];
X		int n_len = 0;
X		long value = 0;
X		addtopl("#"),  n_len++;
X		digit_string[1] = '\0';
X		if (q != '#') {
X		    digit_string[0] = q;
X		    addtopl(digit_string),  n_len++;
X		    value = q - '0';
X		    q = '#';
X		}
X		do {	/* loop until we get a non-digit */
X		    z = lowc(readchar());
X		    if (digit(z)) {
X			value = (10 * value) + (z - '0');
X			if (value < 0) break;	/* overflow: try again */
X			digit_string[0] = z;
X			addtopl(digit_string),  n_len++;
X		    } else if (z == 'y' || index(quitchars, z)) {
X			if (z == '\033')  value = -1;	/* abort */
X			z = '\n';	/* break */
X		    } else if (z == erase_char || z == '\b') {
X			if (n_len <= 1) { value = -1;  break; }
X			else { value /= 10;  removetopl(1),  n_len--; }
X		    } else {
X			value = -1;	/* abort */
X			tty_nhbell();
X			break;
X		    }
X		} while (z != '\n');
X		if (value > 0) yn_number = value;
X		else if (value == 0) q = 'n';		/* 0 => "no" */
X		else {	/* remove number from top line, then try again */
X			removetopl(n_len),  n_len = 0;
X			q = '\0';
X		}
X	    }
X	} while(!q);
X
X	if (q != '#') {
X		Sprintf(rtmp, "%c", q);
X		addtopl(rtmp);
X	}
X    clean_up:
X	ttyDisplay->inread--;
X	ttyDisplay->toplin = 2;
X	if(wins[WIN_MESSAGE]->cury)
X	    tty_clear_nhwindow(WIN_MESSAGE);
X
X	return q;
X}
X
X#endif /* OVL2 */
X
X/*topl.c*/
END_OF_FILE
if test 7994 -ne `wc -c <'win/tty/topl.c'`; then
    echo shar: \"'win/tty/topl.c'\" unpacked with wrong size!
fi
# end of 'win/tty/topl.c'
fi
echo shar: End of archive 96 \(of 108\).
cp /dev/null ark96isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \
21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \
41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 \
61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 \
81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 \
101 102 103 104 105 106 107 108 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 108 archives.
    echo "Now execute 'rebuild.sh'"
    rm -f ark10[0-8]isdone ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
