Path: uunet!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v16i106:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Part98/108
Message-ID: <4471@master.CNA.TEK.COM>
Date: 5 Feb 93 22:03:18 GMT
Sender: news@master.CNA.TEK.COM
Lines: 2079
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1657

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 16, Issue 106
Archive-name: nethack31/Part98
Supersedes: nethack3p9: Volume 10, Issue 46-108
Environment: Amiga, Atari, Mac, MS-DOS, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 98 (of 108)."
# Contents:  dat/castle.des dat/medusa.des include/unixconf.h
#   sys/mac/mgetline.c sys/msdos/MakeGCC.utl sys/msdos/MakeMSC.utl
#   sys/os2/nhpmico.uu sys/vms/vmsfiles.c
# Wrapped by billr@saab on Wed Jan 27 16:09:28 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'dat/castle.des' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dat/castle.des'\"
else
echo shar: Extracting \"'dat/castle.des'\" \(7662 characters\)
sed "s/^X//" >'dat/castle.des' <<'END_OF_FILE'
X#	SCCS Id: @(#)castle.des	3.1	90/02/26
X#	Copyright (c) 1989 by Jean-Christophe Collet
X# NetHack may be freely redistributed.  See license for details.
X#
X# This is the stronghold level :
X# there are several ways to enter it :
X#	- opening the drawbridge (wand of opening, knock spell, playing
X#	  the appropriate tune)
X#
X#	- enter via the back entry (this suppose a ring of levitation, boots
X#	  of water walking, etc.)
X#
X# Note : If you don't play the right tune, you get indications like in the
X#	 MasterMind game...
X#
X# To motivate the player : there are 4 storerooms (armors, weapons, food and
X# gems) and a wand of wishing in one of the 4 towers...
X
XMAZE:"castle",random
XFLAGS: noteleport
XGEOMETRY:center,center
XMAP
X}}}}}}}}}.............................................}}}}}}}}}
X}-------}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}-------}
X}|.....|-----------------------------------------------|.....|}
X}|.....+...............................................+.....|}
X}-------------------------------+-----------------------------}
X}}}}}}|........|..........+...........|.......S.S.......|}}}}}}
X.....}|........|..........|...........|.......|.|.......|}.....
X.....}|........------------...........---------S---------}.....
X.....}|...{....+..........+.........\.S.................+......
X.....}|........------------...........---------S---------}.....
X.....}|........|..........|...........|.......|.|.......|}.....
X}}}}}}|........|..........+...........|.......S.S.......|}}}}}}
X}-------------------------------+-----------------------------}
X}|.....+...............................................+.....|}
X}|.....|-----------------------------------------------|.....|}
X}-------}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}-------}
X}}}}}}}}}.............................................}}}}}}}}}
XENDMAP
X
X# Random registers initialisation
XRANDOM_OBJECTS:'[',')','*','%'
XRANDOM_PLACES:(04,02),(58,02),(04,14),(58,14)
XRANDOM_MONSTERS:'L','N','E','H','M','O','R','T','X','Z'
X
XTELEPORT_REGION:levregion(01,00,10,20),(0,0,62,16),down
XTELEPORT_REGION:levregion(69,00,79,20),(0,0,62,16),up
XSTAIR:levregion(01,00,10,20),(0,0,62,16),up
X# Doors
XDOOR:closed,(07,03)
XDOOR:closed,(55,03)
XDOOR:locked,(32,04)
XDOOR:locked,(26,05)
XDOOR:locked,(46,05)
XDOOR:locked,(48,05)
XDOOR:locked,(47,07)
XDOOR:closed,(15,08)
XDOOR:closed,(26,08)
XDOOR:locked,(38,08)
XDOOR:locked,(56,08)
XDOOR:locked,(47,09)
XDOOR:locked,(26,11)
XDOOR:locked,(46,11)
XDOOR:locked,(48,11)
XDOOR:locked,(32,12)
XDOOR:closed,(07,13)
XDOOR:closed,(55,13)
X# The drawbridge
XDRAWBRIDGE:(05,08),east,closed
X# Storeroom number 1
XOBJECT:object[0],random,(39,05)
XOBJECT:object[0],random,(40,05)
XOBJECT:object[0],random,(41,05)
XOBJECT:object[0],random,(42,05)
XOBJECT:object[0],random,(43,05)
XOBJECT:object[0],random,(44,05)
XOBJECT:object[0],random,(45,05)
XOBJECT:object[0],random,(39,06)
XOBJECT:object[0],random,(40,06)
XOBJECT:object[0],random,(41,06)
XOBJECT:object[0],random,(42,06)
XOBJECT:object[0],random,(43,06)
XOBJECT:object[0],random,(44,06)
XOBJECT:object[0],random,(45,06)
X# Storeroom number 2
XOBJECT:object[1],random,(49,05)
XOBJECT:object[1],random,(50,05)
XOBJECT:object[1],random,(51,05)
XOBJECT:object[1],random,(52,05)
XOBJECT:object[1],random,(53,05)
XOBJECT:object[1],random,(54,05)
XOBJECT:object[1],random,(55,05)
XOBJECT:object[1],random,(49,06)
XOBJECT:object[1],random,(50,06)
XOBJECT:object[1],random,(51,06)
XOBJECT:object[1],random,(52,06)
XOBJECT:object[1],random,(53,06)
XOBJECT:object[1],random,(54,06)
XOBJECT:object[1],random,(55,06)
X# Storeroom number 3
XOBJECT:object[2],random,(39,10)
XOBJECT:object[2],random,(40,10)
XOBJECT:object[2],random,(41,10)
XOBJECT:object[2],random,(42,10)
XOBJECT:object[2],random,(43,10)
XOBJECT:object[2],random,(44,10)
XOBJECT:object[2],random,(45,10)
XOBJECT:object[2],random,(39,11)
XOBJECT:object[2],random,(40,11)
XOBJECT:object[2],random,(41,11)
XOBJECT:object[2],random,(42,11)
XOBJECT:object[2],random,(43,11)
XOBJECT:object[2],random,(44,11)
XOBJECT:object[2],random,(45,11)
X# Storeroom number 4
XOBJECT:object[3],random,(49,10)
XOBJECT:object[3],random,(50,10)
XOBJECT:object[3],random,(51,10)
XOBJECT:object[3],random,(52,10)
XOBJECT:object[3],random,(53,10)
XOBJECT:object[3],random,(54,10)
XOBJECT:object[3],random,(55,10)
XOBJECT:object[3],random,(49,11)
XOBJECT:object[3],random,(50,11)
XOBJECT:object[3],random,(51,11)
XOBJECT:object[3],random,(52,11)
XOBJECT:object[3],random,(53,11)
XOBJECT:object[3],random,(54,11)
XOBJECT:object[3],random,(55,11)
X# THE WAND OF WISHING in 1 of the 4 towers
XOBJECT:'/',"wishing",place[0]
X# Prevent monsters from eating it.  (@'s never eat objects)
XENGRAVING:place[0],burn,"Elbereth"
X# The treasure of the lord
XOBJECT:'(',"chest",(37,08)
X# Traps
XTRAP:"trapdoor",(40,08)
XTRAP:"trapdoor",(44,08)
XTRAP:"trapdoor",(48,08)
XTRAP:"trapdoor",(52,08)
XTRAP:"trapdoor",(55,08)
X# Soldiers guarding the entry hall
XMONSTER:'@',"soldier",(08,06)
XMONSTER:'@',"soldier",(09,05)
XMONSTER:'@',"soldier",(11,05)
XMONSTER:'@',"soldier",(12,06)
XMONSTER:'@',"soldier",(08,10)
XMONSTER:'@',"soldier",(09,11)
XMONSTER:'@',"soldier",(11,11)
XMONSTER:'@',"soldier",(12,10)
XMONSTER:'@',"lieutenant",(09,08)
X# Soldiers guarding the towers
XMONSTER:'@',"soldier",(03,02)
XMONSTER:'@',"soldier",(05,02)
XMONSTER:'@',"soldier",(57,02)
XMONSTER:'@',"soldier",(59,02)
XMONSTER:'@',"soldier",(03,14)
XMONSTER:'@',"soldier",(05,14)
XMONSTER:'@',"soldier",(57,14)
XMONSTER:'@',"soldier",(59,14)
X# The four dragons that are guarding the storerooms
XMONSTER:'D',random,(47,05)
XMONSTER:'D',random,(47,06)
XMONSTER:'D',random,(47,10)
XMONSTER:'D',random,(47,11)
X# Eels in the moat
XMONSTER:';',"giant eel",(05,07)
XMONSTER:';',"giant eel",(05,09)
XMONSTER:';',"giant eel",(57,07)
XMONSTER:';',"giant eel",(57,09)
X# The throne room and the court monsters
XMONSTER:monster[0],random,(27,05)
XMONSTER:monster[1],random,(30,05)
XMONSTER:monster[2],random,(33,05)
XMONSTER:monster[3],random,(36,05)
XMONSTER:monster[4],random,(28,06)
XMONSTER:monster[5],random,(31,06)
XMONSTER:monster[6],random,(34,06)
XMONSTER:monster[7],random,(37,06)
XMONSTER:monster[8],random,(27,07)
XMONSTER:monster[9],random,(30,07)
XMONSTER:monster[0],random,(33,07)
XMONSTER:monster[1],random,(36,07)
XMONSTER:monster[2],random,(28,08)
XMONSTER:monster[3],random,(31,08)
XMONSTER:monster[4],random,(34,08)
XMONSTER:monster[5],random,(27,09)
XMONSTER:monster[6],random,(30,09)
XMONSTER:monster[7],random,(33,09)
XMONSTER:monster[8],random,(36,09)
XMONSTER:monster[9],random,(28,10)
XMONSTER:monster[0],random,(31,10)
XMONSTER:monster[1],random,(34,10)
XMONSTER:monster[2],random,(37,10)
XMONSTER:monster[3],random,(27,11)
XMONSTER:monster[4],random,(30,11)
XMONSTER:monster[5],random,(33,11)
XMONSTER:monster[6],random,(36,11)
X# MazeWalks
XMAZEWALK:(00,10),west
XMAZEWALK:(62,06),east
X# Non diggable walls
XNON_DIGGABLE:(00,00,62,16)
X# Subrooms:
X#   Entire castle area
XREGION:(00,00,62,16),unlit,"ordinary"
X#   Courtyards
XREGION:(00,05,05,11),lit,"ordinary"
XREGION:(57,05,62,11),lit,"ordinary"
X#   Throne room
XREGION:(27,05,37,11),lit,"throne",unfilled
X#   Antechamber
XREGION:(07,05,14,11),lit,"ordinary"
X#   Storerooms
XREGION:(39,05,45,06),lit,"ordinary"
XREGION:(39,10,45,11),lit,"ordinary"
XREGION:(49,05,55,06),lit,"ordinary"
XREGION:(49,10,55,11),lit,"ordinary"
X#   Corners
XREGION:(02,02,06,03),lit,"ordinary"
XREGION:(56,02,60,03),lit,"ordinary"
XREGION:(02,13,06,14),lit,"ordinary"
XREGION:(56,13,60,14),lit,"ordinary"
X#   Barracks
XREGION:(16,05,25,06),lit,"barracks"
XREGION:(16,10,25,11),lit,"barracks"
X#   Hallways
XREGION:(08,03,54,03),unlit,"ordinary"
XREGION:(08,13,54,13),unlit,"ordinary"
XREGION:(16,08,25,08),unlit,"ordinary"
XREGION:(39,08,55,08),unlit,"ordinary"
X#   Storeroom alcoves
XREGION:(47,05,47,06),unlit,"ordinary"
XREGION:(47,10,47,11),unlit,"ordinary"
END_OF_FILE
if test 7662 -ne `wc -c <'dat/castle.des'`; then
    echo shar: \"'dat/castle.des'\" unpacked with wrong size!
fi
# end of 'dat/castle.des'
fi
if test -f 'dat/medusa.des' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dat/medusa.des'\"
else
echo shar: Extracting \"'dat/medusa.des'\" \(7452 characters\)
sed "s/^X//" >'dat/medusa.des' <<'END_OF_FILE'
X#       SCCS Id: @(#)medusa.des 3.1             91/10/30
X#	Copyright (c) 1989 by Jean-Christophe Collet
X#	Copyright (c) 1990, 1991 by M. Stephenson
X# NetHack may be freely redistributed.  See license for details.
X#
X# These are the Medusa's levels :
X#
X
XMAZE:"medusa-1",' '
XFLAGS: noteleport
XGEOMETRY:center,center
XMAP
X}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
X}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
X}}.}}}}}..}}}}}......}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}....}}}...}}}}}
X}...}}.....}}}}}....}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}...............}
X}....}}}}}}}}}}....}}}..}}}}}}}}}}}.......}}}}}}}}}}}}}}}}..}}.....}}}...}}
X}....}}}}}}}}.....}}}}..}}}}}}.................}}}}}}}}}}}.}}}}.....}}...}}
X}....}}}}}}}}}}}}.}}}}.}}}}}}.-----------------.}}}}}}}}}}}}}}}}}.........}
X}....}}}}}}}}}}}}}}}}}}.}}}...|...............S...}}}}}}}}}}}}}}}}}}}....}}
X}.....}.}}....}}}}}}}}}.}}....--------+--------....}}}}}}..}}}}}}}}}}}...}}
X}......}}}}..}}}}}}}}}}}}}........|.......|........}}}}}....}}}}}}}}}}}}}}}
X}.....}}}}}}}}}}}}}}}}}}}}........|.......|........}}}}}...}}}}}}}}}.}}}}}}
X}.....}}}}}}}}}}}}}}}}}}}}....--------+--------....}}}}}}.}.}}}}}}}}}}}}}}}
X}......}}}}}}}}}}}}}}}}}}}}...S...............|...}}}}}}}}}}}}}}}}}.}}}}}}}
X}.......}}}}}}}..}}}}}}}}}}}}.-----------------.}}}}}}}}}}}}}}}}}....}}}}}}
X}........}}.}}....}}}}}}}}}}}}.................}}}}}..}}}}}}}}}.......}}}}}
X}.......}}}}}}}......}}}}}}}}}}}}}}.......}}}}}}}}}.....}}}}}}...}}..}}}}}}
X}.....}}}}}}}}}}}.....}}}}}}}}}}}}}}}}}}}}}}.}}}}}}}..}}}}}}}}}}....}}}}}}}
X}}..}}}}}}}}}}}}}....}}}}}}}}}}}}}}}}}}}}}}...}}..}}}}}}}.}}.}}}}..}}}}}}}}
X}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
X}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
XENDMAP
X# Initialize Random Registers
XRANDOM_MONSTERS:';','S','g'
X# Dungeon Description
XREGION:(00,00,74,19),lit,"ordinary"
XREGION:(31,07,45,07),unlit,"ordinary"
XREGION:(35,09,41,10),lit,"ordinary"
XREGION:(31,12,45,12),unlit,"ordinary"
X# Teleport: down to up stairs island, up to Medusa's island
XTELEPORT_REGION:(01,01,05,17),(0,0,0,0),down
XTELEPORT_REGION:(26,04,50,15),(0,0,0,0),up
X# Stairs
XSTAIR:(05,14),up
XSTAIR:(35,10),down
X# Doors
XDOOR:closed,(46,07)
XDOOR:locked,(38,08)
XDOOR:locked,(38,11)
XDOOR:closed,(30,12)
X# Branch, not allowed inside Medusa's building.
XBRANCH:levregion(01,00,79,20),(30,06,46,13)
X# Non diggable walls
XNON_DIGGABLE:(30,06,46,13)
X# Objects
XOBJECT:'`',"statue",random
XOBJECT:'`',"statue",random
XOBJECT:'`',"statue",random
XOBJECT:'`',"statue",random
XOBJECT:'`',"statue",random
XOBJECT:'`',"statue",random
XOBJECT:'`',"statue",random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
X# Random traps
XTRAP:random,random
XTRAP:random,random
XTRAP:random,random
XTRAP:random,random
XTRAP:random,random
XTRAP:"board",(38,07)
XTRAP:"board",(38,12)
X# Random monsters
XMONSTER:'@',"Medusa",(36,10),asleep
XMONSTER:';',random,(11,06)
XMONSTER:';',random,(23,13)
XMONSTER:';',random,(29,02)
XMONSTER:';',random,(52,04)
XMONSTER:';',random,(64,11)
XMONSTER:'S',random,(38,07)
XMONSTER:'S',random,(38,12)
XMONSTER:random,random,random
XMONSTER:random,random,random
XMONSTER:random,random,random
XMONSTER:random,random,random
XMONSTER:random,random,random
XMONSTER:random,random,random
XMONSTER:random,random,random
XMONSTER:random,random,random
XMONSTER:random,random,random
XMONSTER:random,random,random
X
XMAZE:"medusa-2",' '
XFLAGS: noteleport
XGEOMETRY:center,center
XMAP
X}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
X}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
X}------}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}-------}}}}}}}}--------------}
X}|....|}}}}}}}}}..}.}}..}}}}}}}}}}}}}..}}}}}}-.....--}}}}}}}|............|}
X}|....|.}}}}}}}}}}}.}...}}..}}}}}}}}}}}}}}}}}---......}}}}}.|............|}
X}S....|.}}}}}}---}}}}}}}}}}}}}}}}}}}}}}}}}}---...|..-}}}}}}.S..----------|}
X}|....|.}}}}}}-...}}}}}}}}}.}}...}.}}}}.}}}......----}}}}}}.|............|}
X}|....|.}}}}}}-....--}}}}}}}}}}}}}}}}}}}}}}----...--}}}}}}}.|..--------+-|}
X}|....|.}}}}}}}......}}}}...}}}}}}.}}}}}}}}}}}---..---}}}}}.|..|..S...|..|}
X}|....|.}}}}}}-....-}}}}}}}------}}}}}}}}}}}}}}-...|.-}}}}}.|..|..|...|..|}
X}|....|.}}}}}}}}}---}}}}}}}........}}}}}}}}}}---.|....}}}}}.|..|..|...|..|}
X}|....|.}}}}}}}}}}}}}}}}}}-....|...-}}}}}}}}--...----.}}}}}.|..|..|...|..|}
X}|....|.}}}}}}..}}}}}}}}}}---..--------}}}}}-..---}}}}}}}}}.|..|..-------|}
X}|...}|...}}}.}}}}}}...}}}}}--..........}}}}..--}}}}}}}}}}}.|..|.........|}
X}|...}S...}}.}}}}}}}}}}}}}}}-..--------}}}}}}}}}}}}}}...}}}.|..--------..S}
X}|...}|...}}}}}}}..}}}}}}----..|....-}}}}}}}}}}}}}}}}}..}}}.|............|}
X}|....|}}}}}....}}}}..}}.-.......----}}......}}}}}}.......}}|............|}
X}------}}}}}}}}}}}}}}}}}}---------}}}}}}}}}}}}}}}}}}}}}}}}}}--------------}
X}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
X}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
XENDMAP
X# Initialize Random Registers
XRANDOM_MONSTERS:';','S','g'
X# Dungeon Description
XREGION:(00,00,74,19),lit,"ordinary"
XREGION:(02,03,05,16),unlit,"ordinary"
XREGION:(61,03,72,16),unlit,"ordinary",unfilled,true
XREGION:(71,08,72,11),unlit,"ordinary"
XREGION:(67,08,69,11),lit,"ordinary"
X# Teleport: down to up stairs island, up to Medusa's island
XTELEPORT_REGION:(02,03,05,16),(0,0,0,0),down
XTELEPORT_REGION:(61,03,72,16),(0,0,0,0),up
X# Stairs
XSTAIR:(04,09),up
XSTAIR:(68,10),down
X# Doors
XDOOR:locked,(71,07)
X# Branch, not allowed on Medusa's island.
XBRANCH:levregion(01,00,79,20),(59,01,73,17)
X# Non diggable walls
XNON_DIGGABLE:(01,02,06,17)
XNON_DIGGABLE:(60,02,73,17)
X# Objects
XOBJECT:'`',"statue",(64,08)
XOBJECT:'`',"statue",(65,08)
XOBJECT:'`',"statue",(64,09)
XOBJECT:'`',"statue",(65,09)
XOBJECT:'`',"statue",(64,10)
XOBJECT:'`',"statue",(65,10)
XOBJECT:'`',"statue",(64,11)
XOBJECT:'`',"statue",(65,11)
XOBJECT:'`',"boulder",(04,04)
XOBJECT:'/',random,(52,09)
XOBJECT:'`',"boulder",(52,09)
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
XOBJECT:random,random,random
X# Traps
XTRAP:"magic",(03,12)
XTRAP:random,random
XTRAP:random,random
XTRAP:random,random
XTRAP:random,random
X# Monsters.
XMONSTER:'@',"Medusa",(68,10),asleep
XMONSTER:'g',"gremlin",(02,14)
XMONSTER:'H',"titan",(02,05)
XMONSTER:';',"electric eel",(10,13)
XMONSTER:';',"electric eel",(11,13)
XMONSTER:';',"electric eel",(10,14)
XMONSTER:';',"electric eel",(11,14)
XMONSTER:';',"electric eel",(10,15)
XMONSTER:';',"electric eel",(11,15)
XMONSTER:''',"stone golem",(64,08),asleep
XMONSTER:''',"stone golem",(65,08),asleep
XMONSTER:''',"stone golem",(64,09),asleep
XMONSTER:''',"stone golem",(65,09),asleep
XMONSTER:'S',"cobra",(64,10),asleep
XMONSTER:'S',"cobra",(65,10),asleep
XMONSTER:'A',random,(72,08)
XMONSTER:'y',"yellow light",(72,11),asleep
XMONSTER:random,random,(17,07)
XMONSTER:random,random,(28,11)
XMONSTER:random,random,(32,13)
XMONSTER:random,random,(49,09)
XMONSTER:random,random,(48,07)
XMONSTER:random,random,(65,03)
XMONSTER:random,random,(70,04)
XMONSTER:random,random,(70,15)
XMONSTER:random,random,(65,16)
XMONSTER:random,random,random
XMONSTER:random,random,random
XMONSTER:random,random,random
XMONSTER:random,random,random
END_OF_FILE
if test 7452 -ne `wc -c <'dat/medusa.des'`; then
    echo shar: \"'dat/medusa.des'\" unpacked with wrong size!
fi
# end of 'dat/medusa.des'
fi
if test -f 'include/unixconf.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/unixconf.h'\"
else
echo shar: Extracting \"'include/unixconf.h'\" \(7669 characters\)
sed "s/^X//" >'include/unixconf.h' <<'END_OF_FILE'
X/*	SCCS Id: @(#)unixconf.h	3.1	90/22/02	*/
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#ifdef UNIX
X#ifndef UNIXCONF_H
X#define UNIXCONF_H
X
X/*
X * Some include files are in a different place under SYSV
X *	BSD		   SYSV
X * <sys/time.h>		<time.h>
X * <sgtty.h>		<termio.h>
X *
X * Some routines are called differently
X * index		strchr
X * rindex		strrchr
X *
X */
X
X/* define exactly one of the following four choices */
X#define BSD		/* define for 4.n BSD  */
X			/* also for relatives like SunOS and DG/UX */
X/* #define ULTRIX	/* define for Ultrix v3.0 or higher (but not lower) */
X			/* Use BSD for < v3.0 */
X			/* "ULTRIX" not to be confused with "ultrix" */
X/* #define SYSV		/* define for System V */
X/* #define HPUX		/* Hewlett-Packard's Unix, version 6.5 or higher */
X			/* use SYSV for < v6.5 */
X
X
X/* define any of the following that are appropriate */
X/* #define SVR4		/* use in addition to SYSV for System V Release 4 */
X#define NETWORK	/* if running on a networked system */
X			/* e.g. Suns sharing a playground through NFS */
X#define SUNOS4	/* SunOS 4.x */
X/* #define GENIX	/* Yet Another Unix Clone */
X/* #define HISX		/* Bull Unix for XPS Machines */
X/* #define BOS		/* Bull Open Software - Unix for DPX/2 Machines */
X/* #define UNIXPC	/* use in addition to SYSV for AT&T 7300/3B1 */
X/* #define AIX_31	/* In AIX 3.1 (IBM RS/6000) use BSD ioctl's to gain
X			   job control (note that AIX is SYSV otherwise) */
X/* #define TEXTCOLOR	/* Use System V r3.2 terminfo color support */
X			/* or ANSI color support on termcap systems */
X			/* or X11 color	*/
X/* #define POSIX_JOB_CONTROL	/* use System V POSIX job control */
X/* #define POSIX_TYPES	/* use POSIX types for system calls and termios */
X
X
X/* #define OPENWINBUG	/* avoid a problem using OpenWindows 3.0 for X11
X			   on SunOS 4.1.x, x>= 2 */
X/* #define PYRAMID_BUG	/* avoid a bug on the Pyramid */
X/* #define BSD_43_BUG	/* for real 4.3BSD cc's without schain botch fix */
X/* #define MICROPORT_BUG /* problems with large arrays in structs */
X/* #define MICROPORT_286_BUG /* Changes needed in termcap.c to get it to
X			   run with Microport Sys V/AT version 2.4.
X			   By Jay Maynard */
X/* #define AIXPS_2BUG	/* avoid a problem with little_to_big() optimization */
X
X/* #define RANDOM	/* if neither random/srandom nor lrand48/srand48
X			   is available from your system */
X
X/* #define SYSV386MUSIC	/* Play real music through speaker on systems with
X			   music driver installed */
X
X
X/*
X * The next two defines are intended mainly for the Andrew File System,
X * which does not allow hard links.  If NO_FILE_LINKS is defined, lock files
X * will be created in LOCKDIR using open() instead of in the playground using
X * link().
X *		Ralf Brown, 7/26/89 (from v2.3 hack of 10/10/88)
X */
X
X/* #define NO_FILE_LINKS	/* if no hard links */
X/* #define LOCKDIR "/usr/games/lib/nethackdir"	/* where to put locks */
X
X
X/*
X * Define DEF_PAGER as your default pager, e.g. "/bin/cat" or "/usr/ucb/more"
X * If defined, it can be overridden by the environment variable PAGER.
X * Hack will use its internal pager if DEF_PAGER is not defined.
X * (This might be preferable for security reasons.)
X * #define DEF_PAGER	".../mydir/mypager"
X */
X
X
X
X/*
X * Define PORT_HELP to be the name of the port-specfic help file.
X * This file is found in HACKDIR. 
X * Normally, you shouldn't need to change this.
X * There is currently no port-specific help for Unix systems.
X */
X/* #define PORT_HELP "Unixhelp" */
X
X/*
X * If you define MAIL, then the player will be notified of new mail
X * when it arrives.  If you also define DEF_MAILREADER then this will
X * be the default mail reader, and can be overridden by the environment
X * variable MAILREADER; otherwise an internal pager will be used.
X * A stat system call is done on the mailbox every MAILCKFREQ moves.
X */
X
X#define MAIL			/* Deliver mail during the game */
X
X/* The Andrew Message System does mail a little differently from normal
X * UNIX.  Mail is deposited in the user's own directory in ~/Mailbox
X * (another directory).  MAILBOX is the element that will be added on to
X * the user's home directory path to generate the Mailbox path - just in
X * case other Andrew sites do it differently from CMU.
X *
X *		dan lovinger
X *		dl2n+@andrew.cmu.edu (dec 19 1989)
X */
X
X/* #define AMS			/* use Andrew message system for mail */
X
X/* NO_MAILREADER is for kerberos authentcating filesystems where it is
X * essentially impossible to securely exec child processes, like mail
X * readers, when the game is running under a special token.
X *
X *             dan
X */
X
X/* #define NO_MAILREADER	/* have mail daemon just tell player of mail */
X
X#ifdef	MAIL
X# if defined(BSD) || defined(ULTRIX)
X#  ifdef AMS
X#define AMS_MAILBOX	"/Mailbox"
X#  else
X#define DEF_MAILREADER	"/usr/ucb/Mail"
X#  endif
X#else
X# if defined(SYSV) || defined(DGUX) || defined(HPUX)
X#  ifdef M_XENIX
X#define DEF_MAILREADER	"/usr/bin/mail"
X#  else
X#define DEF_MAILREADER	"/usr/bin/mailx"
X#  endif
X# else
X#define DEF_MAILREADER	"/bin/mail"
X# endif
X#endif
X
X#define MAILCKFREQ	50
X#endif	/* MAIL */
X
X
X
X#ifdef COMPRESS
X/* Some implementations of compress need a 'quiet' option.
X * If you've got one of these versions, put -q here.
X * You can also include any other strange options your compress needs.
X * If you have a normal compress, just leave it commented out.
X */
X/* #define COMPRESS_OPTIONS	"-q"	/* */
X#endif
X
X#define FCMASK	0660	/* file creation mask */
X
X
X/*
X * The remainder of the file should not need to be changed.
X */
X
X#ifdef _AUX_SOURCE
X# ifdef AUX /* gcc ? */
X#  define _SYSV_SOURCE
X#  define _BSD_SOURCE
X#else
X#  define AUX
X# endif
X#endif /* _AUX_SOURCE */
X
X/*
X * BSD/ULTRIX systems are normally the only ones that can suspend processes.
X * Suspending NetHack processes cleanly should be easy to add to other systems
X * that have SIGTSTP in the Berkeley sense.  Currently the only such systems
X * known to work are HPUX and AIX 3.1; other systems will probably require
X * tweaks to unixtty.c and ioctl.c.
X *
X * POSIX defines a slightly different type of job control, which should be
X * equivalent for NetHack's purposes.  POSIX_JOB_CONTROL should work on
X * various recent SYSV versions (with possibly tweaks to unixtty.c again).
X */
X#ifndef POSIX_JOB_CONTROL
X# if defined(BSD) || defined(ULTRIX) || defined(HPUX) || defined(AIX_31)
X#  define BSD_JOB_CONTROL
X# else
X#  if defined(SVR4)
X#   define POSIX_JOB_CONTROL
X#  endif
X# endif
X#endif
X#if defined(BSD_JOB_CONTROL) || defined(POSIX_JOB_CONTROL) || defined(AUX)
X#define SUSPEND		/* let ^Z suspend the game */
X#endif
X
X
X#if defined(BSD) || defined(ULTRIX)
X#include	<sys/time.h>
X#else
X#include	<time.h>
X#endif
X
X#define HLOCK	"perm"	/* an empty file used for locking purposes */
X
X#ifndef REDO
X#define Getchar nhgetch
X#endif
X#define tgetch getchar
X
X#define SHELL		/* do not delete the '!' command */
X
X#include "system.h"
X
X#if defined(BSD) || defined(ULTRIX)
X# if !defined(DGUX) && !defined(SUNOS4)
X#define memcpy(d, s, n)		bcopy(s, d, n)
X#define memcmp(s1, s2, n)	bcmp(s2, s1, n)
X# endif
X#else	/* therefore SYSV */
X#define index	strchr
X#define rindex	strrchr
X#endif
X
X/* A safety check for BOS and AUX */
X#if (defined(BOS) || defined(AUX)) && defined(NHSTDC)
X# if defined(VISION_TABLES) && defined(BRACES)
X#  undef BRACES
X# endif
X#endif
X
X/* Use the high quality random number routines. */
X#if defined(BSD) || defined(ULTRIX) || defined(RANDOM)
X#define Rand()	random()
X#else
X#define Rand()	lrand48()
X#endif
X
X#ifdef hc	/* older versions of the MetaWare High-C compiler define this */
X# ifdef __HC__
X#  undef __HC__
X# endif
X# define __HC__ hc
X# undef hc
X#endif
X
X#endif /* UNIXCONF_H */
X#endif /* UNIX */
END_OF_FILE
if test 7669 -ne `wc -c <'include/unixconf.h'`; then
    echo shar: \"'include/unixconf.h'\" unpacked with wrong size!
fi
# end of 'include/unixconf.h'
fi
if test -f 'sys/mac/mgetline.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/mac/mgetline.c'\"
else
echo shar: Extracting \"'sys/mac/mgetline.c'\" \(7071 characters\)
sed "s/^X//" >'sys/mac/mgetline.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)getline.c	3.1	90/22/02
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include "hack.h"
X#include "Dialogs.h"
X#ifdef THINK_C
X#include "pascal.h"
X#endif
X#include <Packages.h>
X
X// void FDECL(getlin,(const char *, char *));
X// void FDECL(get_ext_cmd,(char *));
Xint FDECL ( try_key_queue , ( char * ) ) ;
X
Xchar * FDECL ( PtoCstr , ( unsigned char * ) ) ;
Xunsigned char * FDECL ( CtoPstr , ( char * ) ) ;
Xvoid SetFrameItem ( DialogPtr , short , short ) ;
Xvoid FlashButton ( DialogPtr , short ) ;
X
Xvoid FDECL ( enter_topl_mode , ( char * ) ) ;
Xvoid FDECL ( leave_topl_mode , ( char * ) ) ;
XBoolean FDECL ( topl_key , ( unsigned char ) ) ;
XBoolean FDECL ( topl_ext_key , ( unsigned char ) ) ;
X
Xtypedef Boolean FDECL ( ( * key_func ) , ( unsigned char ) ) ;
X
X
Xint
Xget_line_from_key_queue ( char * bufp )
X{
X	* bufp = 0 ;
X	if ( try_key_queue ( bufp ) ) {
X
X		while ( * bufp ) {
X
X			if ( * bufp == 10 || * bufp == 13 ) {
X
X				* bufp = 0 ;
X			}
X			bufp ++ ;
X		}
X		return true ;
X	}
X	return false ;
X}
X
X
Xpascal Boolean
XgetlinFilter ( DialogPtr dp , EventRecord * ev , short * itemHit )
X{
X	if (ev->what == keyDown) {
X		int key = ev->message & keyCodeMask,
X			ch	= ev->message & charCodeMask;
X
X		if (ch == 0x1b || key == 0x3500 || key == 0x4700) {
X			*itemHit = 2;
X			FlashButton(dp, 2);
X			return true;
X
X		} else if (ch == CHAR_CR || ch == CHAR_ENTER) {
X			*itemHit = 1;
X			FlashButton(dp, 1);
X			return true;
X		}
X	}
X
X	return false;
X}
X
X
Xvoid
Xpopup_getlin(const char *query, char *bufp)
X{
X	ControlHandle	ctrl;
X	DialogPtr		promptDialog;
X	short			itemHit, type;
X	Rect			box;
X	Str255			pasStr;
X
X	if ( get_line_from_key_queue ( bufp ) )
X		return ;
X
X	/*
X	** Make a copy of the prompt string and convert the copy to a Pascal string.
X	*/
X	
X	strcpy((char *) pasStr, query);
X	CtoPstr((char *) pasStr);
X	
X	/*
X	** Set the query line as parameter text.
X	*/
X	
X	ParamText(pasStr, "\p", "\p", "\p");
X	
X	promptDialog = mv_get_new_dialog(130);
X	ShowWindow(promptDialog);
X
X	InitCursor ( ) ;
X	SetFrameItem ( promptDialog , 6 , 1 ) ;
X	do {
X		mv_modal_dialog(&getlinFilter, &itemHit);
X	} while ((itemHit != 1) && (itemHit != 2));
X	
X	if (itemHit != 2) {
X		/*
X		** Get the text from the text edit item.
X		*/
X		
X		GetDItem(promptDialog, 4, &type, (Handle *) &ctrl, &box);
X		GetIText((Handle) ctrl, pasStr);
X		
X		/*
X		** Convert it to a 'C' string and copy it into the return value.
X		*/
X		
X		PtoCstr(pasStr);
X		strcpy(bufp, (char *) pasStr);
X	} else {
X		/*
X		** Return a null-terminated string consisting of a single <ESC>.
X		*/
X		
X		bufp[0] = '\033';
X		bufp[1] = '\0';
X	}
X	
X	mv_close_dialog(promptDialog);
X}
X
X
Xvoid
Xtopl_getlin(const char *query, char *bufp, key_func key)
X{
X	int q_len = strlen(query);
X
X	if ( get_line_from_key_queue ( bufp ) )
X		return ;
X
X	enter_topl_mode(query);
X	while ((*key)(nhgetch())) ;
X	leave_topl_mode(bufp);
X}
X
X
X/*
X * Read a line closed with '\n' into the array char bufp[BUFSZ].
X * (The '\n' is not stored. The string is closed with a '\0'.)
X * Reading can be interrupted by an escape ('\033') - now the
X * resulting string is "\033".
X */
Xvoid
Xmac_getlin(const char *query, char *bufp)
X{
X	if (flags.popup_dialog)
X		popup_getlin(query, bufp);
X	else
X		topl_getlin(query, bufp, &topl_key);
X}
X
X
X#ifdef COM_COMPL
X
Xpascal Boolean
XExtendedCommandDialogFilter ( DialogPtr dp , EventRecord * ev , short * item )
X{
X	int ix ;
X	Handle h ;
X	Rect r ;
X	short k ;
X	Str255 s ;
X	unsigned char com [ 2 ] ;
X
X	if ( ev -> what != keyDown ) {
X
X		return 0 ;
X	}
X	com [ 0 ] = 1 ;
X	com [ 1 ] = ev -> message & 0xff ;
X
X	if ( com [ 1 ] == 10 || com [ 1 ] == 13 || com [ 1 ] == 32 ||
X		com [ 1 ] == 3 ) { // various "OK"
X
X		* item = 1 ;
X		FlashButton ( dp , 1 ) ;
X		return 1 ;
X	}
X	if ( com [ 1 ] == 27 || ( ev -> message & 0xff00 == 0x3500 ) ) { // escape
X
X		* item = 2 ;
X		FlashButton ( dp , 2 ) ;
X		return 1 ;
X	}
X	for ( ix = 3 ; ix ; ix ++ ) {
X
X		h = ( Handle ) NULL ;
X		k = 0 ;
X		GetDItem ( dp , ix , & k , & h , & r ) ;
X		if ( ! k || ! h ) {
X
X			return 0 ;
X		}
X		if ( k == 6 ) {	//	Radio Button Item
X
X			GetCTitle ( ( ControlHandle ) h , s ) ;
X			s [ 0 ] = 1 ;
X			if ( ! IUEqualString ( com , s ) ) {
X
X				* item = ix ;
X				return 1 ;
X			}
X		}
X	}
X/*NOTREACHED*/
X	return 0 ;
X}
X
X
Xvoid
Xpopup_get_ext_cmd(char *bufp)
X{
X	ControlHandle	ctrl;
X	DialogPtr		extendedDialog;
X	short			itemHit, type;
X	Rect			box;
X	char			*extendedCommand;
X
X	/*
X	** Default selection is the first item after the "Cancel" button.
X	*/
X	static lastItemSelected = 3;
X
X	if ( get_line_from_key_queue ( bufp ) )
X		return ;
X
X	extendedDialog = mv_get_new_dialog(131);
X	ShowWindow(extendedDialog);
X
X	/*
X	** Mark the default selection.
X	*/
X	
X	GetDItem(extendedDialog, lastItemSelected, &type, (Handle *) &ctrl, &box);
X	SetCtlValue(ctrl, 1);
X
X	InitCursor ( ) ;
X	SetFrameItem ( extendedDialog , 20 , 1 ) ;
X	do {
X		mv_modal_dialog((ModalFilterProcPtr) ExtendedCommandDialogFilter , &itemHit);
X		if ((itemHit != 1) && (itemHit != 2)) {
X			/*
X			** If OK and Cancel (items 1 and 2) weren't selected then a radio button 
X			** was pushed.  Unmark the previous selection.
X			*/
X			
X			GetDItem(extendedDialog, lastItemSelected, &type, (Handle *) &ctrl, &box);
X			SetCtlValue(ctrl, 0);
X			
X			/*
X			** Mark the current selection.
X			*/
X			
X			GetDItem(extendedDialog, itemHit, &type, (Handle *) &ctrl, &box);
X			SetCtlValue(ctrl, 1);
X
X			/*
X			** Save the item number for use later.
X			*/
X			
X			lastItemSelected = itemHit;
X		}
X	} while ((itemHit != 1) && (itemHit != 2));
X	
X	if (itemHit == 2) {
X		/*
X		** Return a null-terminated string consisting of a single <ESC>.
X		*/
X		
X		bufp[0] = '\033';
X		bufp[1] = '\0';
X	} else {
X		switch (lastItemSelected) {
X		case 3:
X			extendedCommand = "adjust";
X			break;
X		case 4:
X			extendedCommand = "chat";
X			break;
X		case 5:
X			extendedCommand = "dip";
X			break;
X		case 6:
X			extendedCommand = "force";
X			break;
X		case 7:
X			extendedCommand = "jump";
X			break;
X		case 8:
X			extendedCommand = "loot";
X			break;
X		case 9:
X			extendedCommand = "monster";
X			break;
X		case 10:
X			extendedCommand = "name";
X			break;
X		case 11:
X			extendedCommand = "offer";
X			break;
X		case 12:
X			extendedCommand = "pray";
X			break;
X		case 13:
X			extendedCommand = "rub";
X			break;
X		case 14:
X			extendedCommand = "sit";
X			break;
X		case 15:
X			extendedCommand = "turn";
X			break;
X		case 16:
X			extendedCommand = "untrap";
X			break;
X		case 17:
X			extendedCommand = "version";
X			break;
X		case 18:
X			extendedCommand = "window";
X			break;
X		case 19:
X			extendedCommand = "wipe";
X			break;
X		}
X		
X		/*
X		** Copy the text representing the last radio button selected into the buffer.
X		*/
X		
X		strcpy(bufp, extendedCommand);
X	}
X	
X	mv_close_dialog(extendedDialog);
X}
X
X
X/* Read in an extended command - doing command line completion for
X * when enough characters have been entered to make a unique command.
X * This is just a modified getlin().   -jsb
X */
Xvoid
Xmac_get_ext_cmd(char *bufp)
X{
X	if (flags.popup_dialog)
X		popup_get_ext_cmd(bufp);
X	else
X		topl_getlin("# ", bufp, &topl_ext_key);
X}
X
X#endif /* COM_COMPL /* */
X
X/* macgetline.c */
END_OF_FILE
if test 7071 -ne `wc -c <'sys/mac/mgetline.c'`; then
    echo shar: \"'sys/mac/mgetline.c'\" unpacked with wrong size!
fi
# end of 'sys/mac/mgetline.c'
fi
if test -f 'sys/msdos/MakeGCC.utl' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/msdos/MakeGCC.utl'\"
else
echo shar: Extracting \"'sys/msdos/MakeGCC.utl'\" \(7504 characters\)
sed "s/^X//" >'sys/msdos/MakeGCC.utl' <<'END_OF_FILE'
X#       SCCS Id: @(#)MakeGCC.utl               3.1     93/01/18
X#	Copyright (c) NetHack PC Development Team 1992, 1993.
X#       PC NetHack 3.1 Utilities Makefile for djgpp
X#       Gnu gcc compiler for msdos
X#
X#       For questios or comments:  Kevins@ori.org
X#
X#  In addition to your C compiler,
X#
X#  if you want to change   you will need a
X#  files with suffix   workalike for
X#         .y         yacc
X#         .l         lex
X#
X#       Note that flex (lex) and bison (yacc) are included with the
X#       djgpp distribution and work quite well.  This makefile assumes
X#        you have them installed correctly.
X
X#
X#  Executables.
X#       gcc and go32 dos extender
X
XCC      = gcc
XSTUB    = f:\djgpp\bin\stub.exe   # Protected mode stub for go32. Either
XLINK    = gcc                     # stub.exe or go32.exe
XMAKEBIN  = make
X
X#
X# Special libraries and how to link them in.
X
XLIBS = -lpc
X
X#
X#  Yacc/Lex ... if you got 'em.
X#
X
XYACC  = bison -y
XLEX   = flex
X
XYTABC  = y_tab.c
XYTABH  = y_tab.h
XLEXYYC   = lexyy.c
X
X#
X#  Flags.
X#
X
X# Debugging
X# CFLAGS = -g -c -I../include
X
XCFLAGS = -I../include -c
XLFLAGS =
X
X
X#
X#       Directories, gcc likes unix style directory specs
X#
X
XINCL    = ../include
XDAT     = ../dat
X
X# But we must use dos directory specs to find src files, so....
XSRC     = ..\src
XDINCL   = ..\include
X
Xdefault: all
X
X
X#############################################################################
X#
X# nothing below this line should have to be changed
X#
X
X#
X#  Utility Objects.
X#
X
XMAKESRC     = makedefs.c
X
XSPLEVSRC    = lev_yacc.c  lev_$(LEX).c   lev_main.c  panic.c
X
XDGNCOMPSRC  = dgn_yacc.c  dgn_$(LEX).c   dgn_main.c
X
XMAKEOBJS    = makedefs.o  monst.o        objects.o
X
XSPLEVOBJS   = lev_yacc.o  lev_$(LEX).o  lev_main.o  alloc.o     \
X              monst.o     objects.o     panic.o  \
X              drawing.o   decl.o
X
XDGNCOMPOBJS = dgn_yacc.o  dgn_$(LEX).o  dgn_main.o  alloc.o      \
X              panic.o
X
XRECOVOBJS   =  recover.o
X
X#
X#  Header Objects.
X#
X
XDGN_FILE_H = $(INCL)\align.h    $(INCL)\dgn_file.h
XDUNGEON_H  = $(INCL)\align.h    $(INCL)\dungeon.h
XEMIN_H     = $(DUNGEON_H)       $(INCL)\emin.h
XEPRI_H     = $(DUNGEON_H)       $(INCL)\align.h     $(INCL)\epri.h
XESHK_H     = $(DUNGEON_H)       $(INCL)\eshk.h
XMONDATA_H  = $(INCL)\align.h    $(INCL)\mondata.h
XMONST_H    = $(INCL)\align.h    $(INCL)\monst.h
XPERMONST_H = $(INCL)\monattk.h  $(INCL)\monflag.h   $(INCL)\align.h   \
X             $(INCL)\permonst.h
XRM_H       = $(INCL)\align.h    $(INCL)\rm.h
XSP_LEV_H   = $(INCL)\align.h    $(INCL)\sp_lev.h
XVAULT_H    = $(DUNGEON_H)       $(INCL)\vault.h
XYOUPROP_H  = $(PERMONST_H)      $(MONDATA_H)        $(INCL)\prop.h    \
X             $(INCL)\pm.h       $(INCL)\youprop.h
XYOU_H      = $(MONST_H)         $(YOUPROP_H)        $(INCL)\align.h   \
X             $(INCL)\attrib.h   $(INCL)\you.h
XDISPLAY_H  = $(MONDATA_H)       $(INCL)\vision.h    $(INCL)\display.h
XPCCONF_H   = $(INCL)\micro.h    $(INCL)\system.h    $(INCL)\pcconf.h
XCONFIG_H   = $(GLOBAL_H)        $(INCL)\tradstdc.h  $(INCL)\config.h
XDECL_H     = $(YOU_H)           $(INCL)\spell.h     $(INCL)\color.h   \
X             $(INCL)\obj.h      $(INCL)\onames.h    $(INCL)\pm.h      \
X             $(INCL)\decl.h
XGLOBAL_H   = $(PCCONF_H)        $(INCL)\coord.h     $(INCL)\global.h
XHACK_H     = $(CONFIG_H)        $(DUNGEON_H)        $(DECL_H)         \
X             $(DISPLAY_H)       $(INCL)\monsym.h    $(INCL)\mkroom.h  \
X             $(INCL)\objclass.h $(INCL)\trap.h      $(INCL)\flag.h    \
X             $(RM_H)            $(INCL)\vision.h    $(INCL)\wintype.h \
X             $(INCL)\engrave.h  $(INCL)\rect.h      $(INCL)\extern.h \
X             $(INCL)\trampoli.h $(INCL)\hack.h
X
X
X
X#
X#  Make Rules.
X#
X
X.SUFFIXES:  .exe .o .c .y .l
X
X.c.o:
X     $(CC) $(CFLAGS) -o$*.o $*.c
X
X#
X#  Primary Targets.
X#
Xall:   utility.tag
X
Xutility.tag: $(INCL)\trap.h    $(INCL)\onames.h        \
X             $(INCL)\pm.h      $(SRC)\monstr.c   $(SRC)\vis_tab.c  \
X             lev_comp.exe      dgn_comp.exe    recover.exe
X    echo utilities made > utility.tag
X
Xclean:
X    del *.o
X    del *.map
X
Xspotless: clean
X    if exist utility.tag       del utility.tag
X    if exist makedefs.exe      del makedefs.exe
X    if exist lev_comp.exe      del lev_comp.exe
X    if exist dgn_comp.exe      del dgn_comp.exe
X    if exist recover.exe       del recover.exe
X    if exist $(INCL)\date.h    del $(INCL)\date.h
X    if exist $(INCL)\onames.h  del $(INCL)\onames.h
X    if exist $(INCL)\pm.h      del $(INCL)\pm.h
X    if exist $(INCL)\vis_tab.h del $(INCL)\vis_tab.h
X    if exist $(SRC)\monstr.c   del $(SRC)\monstr.c
X    if exist $(SRC)\vis_tab.c  del $(SRC)\vis_tab.c
X
X#
X#  Secondary Targets.
X#
X
X$(INCL)\onames.h: makedefs.exe
X    .\makedefs -o
X
X$(INCL)\pm.h: makedefs.exe
X    .\makedefs -p
X
X$(SRC)\monstr.c: makedefs.exe
X    .\makedefs -m
X
X$(SRC)\vis_tab.h: makedefs.exe
X    .\makedefs -z
X
X$(SRC)\vis_tab.c: makedefs.exe
X    .\makedefs -z
X
X#
X#  Makedefs Stuff
X#
X
Xmakedefs.exe:  $(MAKEOBJS)
X    $(CC) $(LFLAGS) $(MAKEOBJS)
X    copy /b $(STUB)+a.out $*.exe
X    del a.out
X
Xmakedefs.o:  $(CONFIG_H)        $(PERMONST_H)      $(INCL)\objclass.h \
X             $(INCL)\monsym.h   $(INCL)\qtext.h
X
X#
X#  Level Compiler Dependencies
X#
X
Xlev_comp.exe:  $(SPLEVOBJS)
X    $(CC) $(LFLAGS) $(SPLEVOBJS)
X    copy /b $(STUB)+a.out $*.exe
X    del a.out
X
Xlev_yacc.o:  $(HACK_H)   $(SP_LEV_H)    lev_yacc.c
X    $(CC) $(CFLAGS) -o$*.o $*.c
X
X
Xlev_$(LEX).o:  $(HACK_H)   $(SP_LEV_H)    $(INCL)\lev_comp.h \
X               lev_$(LEX).c
X    $(CC) $(CFLAGS) -o$*.o $*.c
X
Xlev_main.o:  $(HACK_H)
X
X$(INCL)\lev_comp.h: lev_yacc.c
X
Xlev_yacc.c:  lev_comp.y
X    $(YACC) -d lev_comp.y
X    copy $(YTABC) lev_yacc.c
X    copy $(YTABH) $(DINCL)\lev_comp.h
X    del $(YTABC)
X    del $(YTABH)
X
X
Xlev_$(LEX).c:  lev_comp.l
X    $(LEX) lev_comp.l
X    copy $(LEXYYC) lev_$(LEX).c
X    del $(LEXYYC)
X
X
X#
X#  Dungeon Dependencies
X#
X
Xdgn_comp.exe:  $(DGNCOMPOBJS)
X    $(CC) $(LFLAGS) $(DGNCOMPOBJS)
X    copy /b $(STUB)+a.out $*.exe
X    del a.out
X
Xdgn_yacc.o:  $(HACK_H)   $(DGN_FILE_H)  dgn_yacc.c
X    $(CC) $(CFLAGS) -o$*.o $*.c
X
Xdgn_$(LEX).o:  $(HACK_H)   $(DGN_FILE_H)  $(INCL)\dgn_comp.h \
X               dgn_$(LEX).c
X    $(CC) $(CFLAGS) -o$*.o $*.c
X
Xdgn_main.o:  $(HACK_H)
X
X$(INCL)\dgn_comp.h:  dgn_yacc.c
X
Xdgn_yacc.c: dgn_comp.y
X    $(YACC) -d dgn_comp.y
X    copy $(YTABC) dgn_yacc.c
X    copy $(YTABH) $(DINCL)\dgn_comp.h
X    del $(YTABC)
X    del $(YTABH)
X
Xdgn_$(LEX).c:  dgn_comp.l
X    $(LEX) dgn_comp.l
X    copy $(LEXYYC) dgn_$(LEX).c
X    del $(LEXYYC)
X
X#
X#  Recover Utility
X#
X
Xrecover.exe:   $(RECOVOBJS)
X    $(CC) $(LFLAGS) $*.o
X    copy /b $(STUB)+a.out $*.exe
X    del a.out
X
Xrecover.o:   $(CONFIG_H) recover.c
X    $(CC) $(CFLAGS) -o$*.o $*.c
X
X#
X#  Other Dependencies.
X#
X
Xalloc.c: $(SRC)\$*.c
X    copy $(SRC)\$*.c .
X
Xalloc.o: $(CONFIG_H)     alloc.c
X    $(CC) $(CFLAGS) -o$*.o $*.c
X
Xdrawing.c: $(SRC)\$*.c
X    copy $(SRC)\$*.c .
X
Xdrawing.o: $(CONFIG_H) drawing.c
X    $(CC) $(CFLAGS) -o$*.o $*.c
X
Xdecl.c: $(SRC)\$*.c
X    copy $(SRC)\$*.c .
X
Xdecl.o: $(CONFIG_H) decl.c
X    $(CC) $(CFLAGS) -o$*.o $*.c
X
Xmonst.c: $(SRC)\$*.c
X    copy $(SRC)\$*.c .
X
Xmonst.o: $(CONFIG_H)         $(PERMONST_H)      $(ESHK_H)          \
X         $(EPRI_H)           $(VAULT_H)         $(INCL)\monsym.h   \
X         $(INCL)\color.h     monst.c
X    $(CC) $(CFLAGS) -o$*.o $*.c
X
Xobjects.c: $(SRC)\$*.c
X    copy $(SRC)\$*.c .
X
Xobjects.o: $(CONFIG_H)        $(INCL)\obj.h      $(INCL)\objclass.h \
X           $(INCL)\prop.h     $(INCL)\color.h    objects.c
X    $(CC) $(CFLAGS) -o$*.o $*.c
X
Xpanic.o:   $(CONFIG_H)
END_OF_FILE
if test 7504 -ne `wc -c <'sys/msdos/MakeGCC.utl'`; then
    echo shar: \"'sys/msdos/MakeGCC.utl'\" unpacked with wrong size!
fi
# end of 'sys/msdos/MakeGCC.utl'
fi
if test -f 'sys/msdos/MakeMSC.utl' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/msdos/MakeMSC.utl'\"
else
echo shar: Extracting \"'sys/msdos/MakeMSC.utl'\" \(7482 characters\)
sed "s/^X//" >'sys/msdos/MakeMSC.utl' <<'END_OF_FILE'
X#	SCCS Id: @(#)MakeMSC.utl	 3.1	 93/01/18
X# Copyright (c) NetHack PC Development Team 1992, 1993.
X# NetHack may be freely redistributed.  See license for details.
X#
X# PC NetHack 3.1 Utilities Source Code Makefile for Microsoft(tm) "C" >= 6.0ax
X#
X#	In addition to your C compiler,
X#
X#	if you want to change		you will need a
X#	files with suffix		workalike for
X#	       .y			    yacc
X#	       .l			    lex
X
X#
X#	Executables.
X#
X
XCC	= cl
XLINK	= link
XMAKEBIN	= make45l
X
X#
X#	Yacc/Lex ... if you got 'em.
X#	(Note: if you don't, leave the top pair uncommented.)
X#
X
XYACC	= yacc
XLEX	= lex
X# YACC	= bison -y
X# LEX	= flex
X
XYTABC	= y_tab.c
XYTABH	= y_tab.h
XLEXYYC	= lexyy.c
X
X#
X#	Flags.
X#
X
X#
X#	+ prepare for CodeView symbolic debugger.
X#
X
XCDFLAGS	=
X#CDFLAGS = /Zi
X
XLDFLAGS =
X#LDFLAGS = /CO
X
X#
X#	CC
X#
X
XCPPFLAGS = /E /AL /c /Os /Gs /Gt20 /Zp1 /W0 /I$(INCL) $(CDFLAGS)
XCFLAGS	 = /AL /c /Os /Gs /Gt20 /Zp1 /W0 /I$(INCL) $(CDFLAGS)
X
X#
X#	Link
X#
X
XLFLAGS	= /noi /seg:512 /map /st:5120 $(LDFLAGS)
X
X#
X#	Directories
X#
X
XINCL	= ..\include
XDAT	= ..\dat
XSRC	= ..\src
XOBJ	= $(SRC)\o
X
Xdefault: all
X#
X#	If you have yacc and lex programs and make any changes, comment
X#	out the upper two targets and uncomment the lower two.
X#
X
Xdo_yacc: yacc_msg
Xdo_lex:  lex_msg
X# do_yacc: yacc_act
X# do_lex:  lex_act
X
X#
X#	Optional C library specifier for those with non-standard
X#	libraries or a multiple-target library setup.
X#
X
X# CLIB	   = llibcer /nod
XCLIB	 =
X
X#############################################################################
X#
X# nothing below this line should have to be changed
X#
X
X#
X#	Utility Objects.
X#
X
XMAKESRC     =	makedefs.c
X
XSPLEVSRC    =   lev_yacc.c  lev_$(LEX).c  lev_main.c  panic.c
X
XDGNCOMPSRC  =   dgn_yacc.c  dgn_$(LEX).c  dgn_main.c
X
XMAKEOBJS    =	makedefs.o	  $(OBJ)\monst.o    $(OBJ)\objects.o
X
XSPLEVOBJS   =	lev_yacc.o	  lev_$(LEX).o	    lev_main.o \
X		$(OBJ)\alloc.o	  $(OBJ)\decl.o     $(OBJ)\drawing.o \
X		$(OBJ)\monst.o    $(OBJ)\objects.o  panic.o
X
XDGNCOMPOBJS =	dgn_yacc.o	  dgn_$(LEX).o	    dgn_main.o \
X		$(OBJ)\alloc.o	  panic.o
X
XRECOVOBJS   =	recover.o
X
X#
X#	Header Objects.
X#
X
XCONFIG_H   = $(GLOBAL_H)           $(INCL)\tradstdc.h $(INCL)\config.h
XDECL_H     = $(YOU_H)              $(INCL)\quest.h    $(INCL)\spell.h  \
X             $(INCL)\color.h       $(INCL)\obj.h      $(INCL)\onames.h \
X             $(INCL)\pm.h          $(INCL)\decl.h
XDGN_FILE_H = $(INCL)\align.h       $(INCL)\dgn_file.h
XDISPLAY_H  = $(MONDATA_H)          $(INCL)\vision.h   $(INCL)\display.h
XDUNGEON_H  = $(INCL)\align.h       $(INCL)\dungeon.h
XEMIN_H     = $(DUNGEON_H)          $(INCL)\emin.h
XEPRI_H     = $(DUNGEON_H)          $(INCL)\align.h    $(INCL)\epri.h
XESHK_H     = $(DUNGEON_H)          $(INCL)\eshk.h
XGLOBAL_H   = $(PCCONF_H)           $(INCL)\coord.h    $(INCL)\global.h
XHACK_H     = $(CONFIG_H)           $(DUNGEON_H)       $(DECL_H)          \
X             $(DISPLAY_H)          $(RM_H)            $(INCL)\monsym.h   \
X             $(INCL)\mkroom.h      $(INCL)\objclass.h $(INCL)\trap.h     \
X             $(INCL)\flag.h        $(INCL)\vision.h   $(INCL)\wintype.h  \
X             $(INCL)\engrave.h     $(INCL)\rect.h     $(INCL)\winprocs.h \
X             $(INCL)\trampoli.h    $(INCL)\hack.h
XMONDATA_H  = $(INCL)\align.h       $(INCL)\mondata.h
XMONST_H    = $(INCL)\align.h       $(INCL)\monst.h
XPCCONF_H   = $(INCL)\micro.h       $(INCL)\system.h   $(INCL)\pcconf.h
XPERMONST_H = $(INCL)\monattk.h     $(INCL)\monflag.h  $(INCL)\align.h \
X             $(INCL)\permonst.h
XRM_H       = $(INCL)\align.h       $(INCL)\rm.h
XSP_LEV_H   = $(INCL)\align.h       $(INCL)\sp_lev.h
XVAULT_H    = $(DUNGEON_H)          $(INCL)\vault.h
XYOU_H      = $(MONST_H)            $(YOUPROP_H)       $(INCL)\align.h \
X             $(INCL)\attrib.h      $(INCL)\you.h
XYOUPROP_H  = $(PERMONST_H)         $(MONDATA_H)       $(INCL)\prop.h \
X             $(INCL)\pm.h          $(INCL)\youprop.h
X
X#
X#	Make Rules.
X#
X
X.SUFFIXES:  .exe .o .c .y .l
X
X.c.o:
X	$(CC) $(CFLAGS) /Fo$*.o $*.c
X
X#
X#	Primary Targets.
X#
Xall:	utility.tag
X
Xutility.tag: $(OBJ)             $(INCL)\onames.h     $(INCL)\pm.h \
X             $(SRC)\monstr.c    $(SRC)\vis_tab.c     lev_comp.exe \
X             dgn_comp.exe       recover.exe
X             echo utilities made > utility.tag
X
X$(OBJ):
X	if not exist $(OBJ)\*.* mkdir $(OBJ)
X
Xclean:
X	del *.o
X	del *.map
X
Xspotless: clean
X	if exist utility.tag	   del utility.tag
X	if exist makedefs.exe	   del makedefs.exe
X	if exist lev_comp.exe	   del lev_comp.exe
X	if exist dgn_comp.exe	   del dgn_comp.exe
X	if exist recover.exe	   del recover.exe
X	if exist $(INCL)\date.h	   del $(INCL)\date.h
X	if exist $(INCL)\onames.h  del $(INCL)\onames.h
X	if exist $(INCL)\pm.h	   del $(INCL)\pm.h
X	if exist $(INCL)\vis_tab.h del $(INCL)\vis_tab.h
X	if exist $(SRC)\monstr.c   del $(SRC)\monstr.c
X	if exist $(SRC)\vis_tab.c  del $(SRC)\vis_tab.c
X
X#
X#	Secondary Targets.
X#
X
X$(INCL)\onames.h: makedefs.exe
X	.\makedefs -o
X
X$(INCL)\pm.h: makedefs.exe
X	.\makedefs -p
X
X$(SRC)\monstr.c: makedefs.exe
X	.\makedefs -m
X
X$(SRC)\vis_tab.h: makedefs.exe
X	.\makedefs -z
X
X$(SRC)\vis_tab.c: makedefs.exe
X	.\makedefs -z
X
X#
X#	Makedefs Stuff
X#
X
Xmakedefs.exe:	$(MAKEOBJS)
X	$(LINK) $(LFLAGS) $(MAKEOBJS), $*.exe,, $(CLIB);
X
Xmakedefs.o:	$(CONFIG_H)	    $(PERMONST_H)      $(INCL)\objclass.h \
X		$(INCL)\monsym.h    $(INCL)\qtext.h
X
X#
X#	Level Compiler Dependencies
X#
X
Xlev_comp.exe:	$(SPLEVOBJS)
X	$(LINK) $(LFLAGS) $(SPLEVOBJS),lev_comp.exe,, $(CLIB);
X
Xlev_yacc.o:	$(HACK_H)   $(SP_LEV_H)    lev_yacc.c
X	$(CC) $(CFLAGS) /Fo$*.o $*.c
X
Xlev_$(LEX).o:	$(HACK_H)   $(SP_LEV_H)    $(INCL)\lev_comp.h \
X		lev_$(LEX).c
X	$(CC) $(CFLAGS) /Fo$*.o $*.c
X
Xlev_main.o:	$(HACK_H)   $(SP_LEV_H)
X
X$(INCL)\lev_comp.h: lev_yacc.c
X
Xlev_yacc.c:	lev_comp.y
X	$(MAKEBIN) YY=lev do_yacc
X
Xlev_$(LEX).c:	lev_comp.l
X	$(MAKEBIN) YY=lev do_lex
X
X#
X#	Dungeon Dependencies
X#
X
Xdgn_comp.exe:	$(DGNCOMPOBJS)
X	$(LINK) $(LFLAGS) $(DGNCOMPOBJS),$*.exe,, $(CLIB);
X
Xdgn_yacc.o:	$(HACK_H)   $(DGN_FILE_H)  dgn_yacc.c
X	$(CC) $(CFLAGS) /Fo$*.o $*.c
X
Xdgn_$(LEX).o:	$(HACK_H)   $(DGN_FILE_H)  $(INCL)\dgn_comp.h \
X		dgn_$(LEX).c
X	$(CC) $(CFLAGS) /Fo$*.o $*.c
X
Xdgn_main.o:	$(HACK_H)
X
X$(INCL)\dgn_comp.h:	dgn_yacc.c
X
Xdgn_yacc.c: dgn_comp.y
X	$(MAKEBIN) YY=dgn do_yacc
X
Xdgn_$(LEX).c:  dgn_comp.l
X	$(MAKEBIN) YY=dgn do_lex
X
X#
X#	Yacc & Lex Magic.
X#
X
Xyacc_msg:
X	@echo $(YY)_comp.y has changed. To update $(YY)_yacc.c and $(YY)_comp.h run $(YACC).
X
Xyacc_act:
X	$(YACC) -d $(YY)_comp.y
X	copy $(YTABC) $(YY)_yacc.c
X	copy $(YTABH) $(INCL)\$(YY)_comp.h
X	del $(YTABC)
X	del $(YTABH)
X
Xlex_msg:
X	@echo $(YY)_comp.l has changed. To update $(YY)_$(LEX).c run $(LEX).
X
Xlex_act:
X	$(LEX) $(YY)_comp.l
X	copy $(LEXYYC) $(YY)_$(LEX).c
X	del $(LEXYYC)
X
X#
X#	Recover Utility
X#
X
Xrecover.exe:	$(RECOVOBJS)
X	$(LINK) $(LFLAGS) $*.o,$*.exe,, $(CLIB);
X
Xrecover.o:	$(CONFIG_H)	recover.c
X	$(CC) $(CFLAGS) /Fo$*.o $*.c
X
X#
X#	Other Dependencies.
X#
X
X$(OBJ)\alloc.o:	$(CONFIG_H)	$(SRC)\alloc.c
X	$(CC) $(CFLAGS) /Fo$(OBJ)\$*.o $(SRC)\$*.c
X
X$(OBJ)\decl.o:  $(HACK_H)       $(INCL)\quest.h   $(SRC)\decl.c
X	$(CC) $(CFLAGS) /Fo$(OBJ)\$*.o $(SRC)\$*.c
X
X$(OBJ)\drawing.o: $(HACK_H)     $(INCL)\termcap.h $(SRC)\drawing.c
X	$(CC) $(CFLAGS) /Fo$(OBJ)\$*.o $(SRC)\$*.c
X
X$(OBJ)\monst.o: $(CONFIG_H)	     $(PERMONST_H)	$(ESHK_H)	 \
X		$(EPRI_H)	     $(VAULT_H)		$(INCL)\monsym.h \
X		$(INCL)\color.h    $(SRC)\monst.c
X	$(CC) $(CFLAGS) /Fo$(OBJ)\$*.o $(SRC)\$*.c
X
X$(OBJ)\objects.o: $(CONFIG_H)	     $(INCL)\obj.h	$(INCL)\objclass.h \
X		  $(INCL)\prop.h     $(INCL)\color.h	$(SRC)\objects.c
X	$(CC) $(CFLAGS) /Fo$(OBJ)\$*.o $(SRC)\$*.c
X
Xpanic.o:	$(CONFIG_H)
END_OF_FILE
if test 7482 -ne `wc -c <'sys/msdos/MakeMSC.utl'`; then
    echo shar: \"'sys/msdos/MakeMSC.utl'\" unpacked with wrong size!
fi
# end of 'sys/msdos/MakeMSC.utl'
fi
if test -f 'sys/os2/nhpmico.uu' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/os2/nhpmico.uu'\"
else
echo shar: Extracting \"'sys/os2/nhpmico.uu'\" \(1273 characters\)
sed "s/^X//" >'sys/os2/nhpmico.uu' <<'END_OF_FILE'
Xbegin 644 nethack.ico
XM0D$H``````````````!#21H`````````>`````P````@`$```0`!`````/___
XM_T-)&@````````!X`0``#````"``(``!``0```````"``(```("`@```@`"`L
XM@(``@("`P,#```#_`/\``/___P``_P#___\`____````````````````````!
XM`````````````````````````````````````````````````````````````
XM`````````````````````````````````````````````````````````````
XM`````````````````````````````````````````````````````````````
XM`````````````````````````````````````````````````````````````
XM`````````````````````````````````````````````````````````````
XM`````````````````````/9F9F9F9F9F9F9F9F9F9F;_9F9F9F9F9F9F9F9F7
XM9F9F_XB(B(B(B(B(B(B(B(AF9O^(B(B(B(B(B(B(B(B(9F;_B(B(B(5558B("
XMB(B(B&9F_XB(B(@`506(B(B(B(AF9O^(B(B(```%B(B(B(B(9F;_B(A555``@
XM55B(B(B(B&9F_XB+N[NP#N-5B(B(B(AF9O^(N[N[`+[N-5B(B(B(9F;_B[N[E
XMN[N[[N-8B(B(B&9F_XN[N[N[N[[N4XB(B(AF9O^+N[N9F9N[[N,XB(B(9F;_)
XMB[NYF9F9N[[N,XB(B&9F_XN[F9F9F9N[[N,XB(AF9O^+N9F9F9F9NU[N,XB(<
XM9F;_B[F9F9F9F;M8[N,XB&9F_XNYF9F9F9F[6([N,XAF9O^+N9F9F9F9NUB(]
XM[N.(9F;_B[F9F9F9F;M8B([NB&9F_XN[F9F9F9N[6(B([HAF9O^+N[F9F9F[#
XMNUB(B(B(9F;_B[N[F9F;N[M8B(B(B&9F_XN[N[N[N[N[6(B(B(AF9O^+N[N[)
XMN[N[NXB(B(B(9F;_B[N(B(B(B[N(B(B(B&9F_XNXB(B(B(B[B(B(B(AF9O^(/
XMB(B(B(B(B(B(B(B(9F;_B(B(B(B(B(B(B(B(B&9F_XB(B(B(B(B(B(B(B(AFN
XA9O__________________]F;_____________________?
X``
Xend
END_OF_FILE
if test 1273 -ne `wc -c <'sys/os2/nhpmico.uu'`; then
    echo shar: \"'sys/os2/nhpmico.uu'\" unpacked with wrong size!
fi
# end of 'sys/os2/nhpmico.uu'
fi
if test -f 'sys/vms/vmsfiles.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/vms/vmsfiles.c'\"
else
echo shar: Extracting \"'sys/vms/vmsfiles.c'\" \(7059 characters\)
sed "s/^X//" >'sys/vms/vmsfiles.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)vmsfiles.c	3.1	93/01/20	*/
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X/*
X *  VMS-specific file manipulation routines to implement some missing
X *  routines or substitute for ones where we want behavior modification.
X */
X#include "config.h"
X
X#include <rms.h>
X#if 0
X#include <psldef.h>
X#else
X#define PSL$C_EXEC 1	/* executive mode, for priv'd logical name handling */
X#endif
X#ifndef C$$TRANSLATE	/* don't rely on VAXCRTL's internal routine */
X#include <errno.h>
X#define C$$TRANSLATE(status) (errno = EVMSERR,  vaxc$errno = (status))
X#else
Xint FDECL(c__translate, (int));
X#endif
Xextern unsigned long SYS$PARSE(), SYS$SEARCH(), SYS$ENTER(), SYS$REMOVE();
X
X#define vms_success(sts) ((sts)&1)		/* odd, */
X#define vms_failure(sts) (!vms_success(sts))	/* even */
X
X/* vms_link() -- create an additional directory for an existing file */
Xint vms_link(file, new)
Xconst char *file, *new;
X{
X    struct FAB fab;
X    struct NAM nam;
X    unsigned short fid[3];
X    char esa[NAM$C_MAXRSS];
X
X    fab = cc$rms_fab;	/* set block ID and length, zero the rest */
X    fab.fab$l_fop = FAB$M_OFP;
X    fab.fab$l_fna = (char *) file;
X    fab.fab$b_fns = strlen(file);
X    fab.fab$l_nam = &nam;
X    nam = cc$rms_nam;
X    nam.nam$l_esa = esa;
X    nam.nam$b_ess = sizeof esa;
X
X    if (vms_success(SYS$PARSE(&fab)) && vms_success(SYS$SEARCH(&fab))) {
X	fid[0] = nam.nam$w_fid[0];
X	fid[1] = nam.nam$w_fid[1];
X	fid[2] = nam.nam$w_fid[2];
X	fab.fab$l_fna = (char *) new;
X	fab.fab$b_fns = strlen(new);
X
X	if (vms_success(SYS$PARSE(&fab))) {
X	    nam.nam$w_fid[0] = fid[0];
X	    nam.nam$w_fid[1] = fid[1];
X	    nam.nam$w_fid[2] = fid[2];
X	    nam.nam$l_esa = nam.nam$l_name;
X	    nam.nam$b_esl = nam.nam$b_name + nam.nam$b_type + nam.nam$b_ver;
X
X	    (void) SYS$ENTER(&fab);
X	}
X    }
X
X    if (vms_failure(fab.fab$l_sts)) {
X	C$$TRANSLATE(fab.fab$l_sts);
X	return -1;
X    }
X    return 0;	/* success */
X}
X
X/*
X   vms_unlink() -- remove a directory entry for a file; should only be used
X   for files which have had extra directory entries added, not for deletion
X   (because the file won't be deleted, just made inaccessible!).
X */
Xint vms_unlink(file)
Xconst char *file;
X{
X    struct FAB fab;
X    struct NAM nam;
X    char esa[NAM$C_MAXRSS];
X
X    fab = cc$rms_fab;	/* set block ID and length, zero the rest */
X    fab.fab$l_fop = FAB$M_DLT;
X    fab.fab$l_fna = (char *) file;
X    fab.fab$b_fns = strlen(file);
X    fab.fab$l_nam = &nam;
X    nam = cc$rms_nam;
X    nam.nam$l_esa = esa;
X    nam.nam$b_ess = sizeof esa;
X
X    if (vms_failure(SYS$PARSE(&fab)) || vms_failure(SYS$REMOVE(&fab))) {
X	C$$TRANSLATE(fab.fab$l_sts);
X	return -1;
X    }
X    return 0;
X}
X
X/*
X   Substitute creat() routine -- if trying to create a specific version,
X   explicitly remove an existing file of the same name.  Since it's only
X   used when we expect exclusive access, add a couple RMS options for
X   optimization.  (Don't allow sharing--eliminates coordination overhead,
X   and use 32 block buffer for faster throughput; ~30% speedup measured.)
X */
X#undef creat
Xint vms_creat(file, mode)
Xconst char *file;
Xunsigned int mode;
X{
X    if (index(file, ';'))
X	(void) unlink(file);	/* assumes remove or delete, not vms_unlink */
X    return creat(file, mode, "shr=nil", "mbc=32");
X}
X
X/*
X   Similar substitute for open() -- can't disallow sharing, because we're
X   relying on deleting a file that we've got open, so must share it with
X   ourself!
X */
X#undef open
Xint vms_open(file, flags, mode)
Xconst char *file;
Xint flags;
Xunsigned int mode;
X{
X    return open(file, flags, mode, "mbc=32");
X}
X
X/*
X   Determine whether two strings contain the same directory name.
X   Used for deciding whether installed privileges should be disabled
X   when HACKDIR is defined in the environment (or specified via -d on
X   the command line).  This version doesn't handle Unix-style file specs.
X */
Xboolean
Xsame_dir(d1, d2)
Xconst char *d1, *d2;
X{
X    if (!d1 || !*d1 || !d2 || !*d2)
X	return FALSE;
X    else if (!strcmp(d1, d2))	/* strcmpi() would be better, but that leads */
X	return TRUE;		/* to linking problems for the utilities */
X    else {
X	struct FAB f1, f2;
X	struct NAM n1, n2;
X
X	f1 = f2 = cc$rms_fab;	/* initialize file access block */
X	n1 = n2 = cc$rms_nam;	/* initialize name block */
X	f1.fab$b_acmodes = PSL$C_EXEC << FAB$V_LNM_MODE;
X	f1.fab$b_fns = strlen( f1.fab$l_fna = (char *)d1 );
X	f2.fab$b_fns = strlen( f2.fab$l_fna = (char *)d2 );
X	f1.fab$l_nam = (genericptr_t)&n1;	/* link nam to fab */
X	f2.fab$l_nam = (genericptr_t)&n2;
X	n1.nam$b_nop = n2.nam$b_nop = NAM$M_NOCONCEAL; /* want true device name */
X
X	return (vms_success(SYS$PARSE(&f1)) && vms_success(SYS$PARSE(&f2))
X	     && n1.nam$t_dvi[0] == n2.nam$t_dvi[0]
X	     && !strncmp(&n1.nam$t_dvi[1], &n2.nam$t_dvi[1], n1.nam$t_dvi[0])
X	     && !memcmp((genericptr_t)n1.nam$w_did,
X			(genericptr_t)n2.nam$w_did,
X			sizeof n1.nam$w_did));	/*{ short nam$w_did[3]; }*/
X    }
X}
X
X
X/*
X * c__translate -- substitute for VAXCRTL routine C$$TRANSLATE.
X *
X *	Try to convert a VMS status code into its Unix equivalent,
X *	then set `errno' to that value; use EVMSERR if there's no
X *	appropriate translation; set `vaxc$errno' to the original
X *	status code regardless.
X *
X *	These translations match only a subset of VAXCRTL's lookup
X *	table, but work even if the severity has been adjusted or
X *	the inhibit-message bit has been set.
X */
X#include <errno.h>
X#include <ssdef.h>
X#include <rmsdef.h>
X/* #include <libdef.h> */
X/* #include <mthdef.h> */
X
X#define VALUE(U)	trans = U; break
X#define CASE1(V)	case (V >> 3)
X#define CASE2(V,W)	CASE1(V): CASE1(W)
X
Xint c__translate(code)
X    int code;
X{
X    register int trans;
X
X    switch ((code & 0x0FFFFFF8) >> 3) {	/* strip upper 4 and bottom 3 bits */
X	CASE2(RMS$_PRV,SS$_NOPRIV):
X				VALUE(EPERM);	/* not owner */
X	CASE2(RMS$_DNF,RMS$_DIR):
X	CASE2(RMS$_FNF,RMS$_FND):
X	CASE1(SS$_NOSUCHFILE):
X				VALUE(ENOENT);	/* no such file or directory */
X	CASE2(RMS$_IFI,RMS$_ISI):
X				VALUE(EIO);	/* i/o error */
X	CASE1(RMS$_DEV):
X	CASE2(SS$_NOSUCHDEV,SS$_DEVNOTMOUNT):
X				VALUE(ENXIO);	/* no such device or address codes */
X	CASE1(RMS$_DME):
X     /* CASE1(LIB$INSVIRMEM): */
X	CASE2(SS$_VASFULL,SS$_INSFWSL):
X				VALUE(ENOMEM);	/* not enough core */
X	CASE1(SS$_ACCVIO):
X				VALUE(EFAULT);	/* bad address */
X	CASE2(RMS$_DNR,SS$_DEVASSIGN):
X	CASE2(SS$_DEVALLOC,SS$_DEVALRALLOC):
X	CASE2(SS$_DEVMOUNT,SS$_DEVACTIVE):
X				VALUE(EBUSY);	/* mount device busy codes to name a few */
X	CASE2(RMS$_FEX,SS$_FILALRACC):
X				VALUE(EEXIST);	/* file exists */
X	CASE2(RMS$_IDR,SS$_BADIRECTORY):
X				VALUE(ENOTDIR);	/* not a directory */
X	CASE1(SS$_NOIOCHAN):
X				VALUE(EMFILE);	/* too many open files */
X	CASE1(RMS$_FUL):
X	CASE2(SS$_DEVICEFULL,SS$_EXDISKQUOTA):
X				VALUE(ENOSPC);	/* no space left on disk codes */
X	CASE2(RMS$_WLK,SS$_WRITLCK):
X				VALUE(EROFS);	/* read-only file system */
X	default:
X				VALUE(EVMSERR);
X    };
X
X    errno = trans;
X    vaxc$errno = code;
X    return code;	/* (not very useful) */
X}
X
X#undef VALUE
X#undef CASE1
X#undef CASE2
X
X/*vmsfiles.c*/
END_OF_FILE
if test 7059 -ne `wc -c <'sys/vms/vmsfiles.c'`; then
    echo shar: \"'sys/vms/vmsfiles.c'\" unpacked with wrong size!
fi
# end of 'sys/vms/vmsfiles.c'
fi
echo shar: End of archive 98 \(of 108\).
cp /dev/null ark98isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \
21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \
41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 \
61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 \
81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 \
101 102 103 104 105 106 107 108 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 108 archives.
    echo "Now execute 'rebuild.sh'"
    rm -f ark10[0-8]isdone ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
