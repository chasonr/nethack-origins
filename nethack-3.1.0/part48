Path: uunet!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v16i056:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Part48/108
Message-ID: <4350@master.CNA.TEK.COM>
Date: 30 Jan 93 01:14:39 GMT
Sender: news@master.CNA.TEK.COM
Lines: 2282
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1605

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 16, Issue 56
Archive-name: nethack31/Part48
Supersedes: nethack3p9: Volume 10, Issue 46-102
Environment: Amiga, Atari, Mac, MS-DOS, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 48 (of 108)."
# Contents:  sys/mac/macwin.c2 sys/vms/Makefile.src
# Wrapped by billr@saab on Wed Jan 27 16:09:05 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'sys/mac/macwin.c2' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/mac/macwin.c2'\"
else
echo shar: Extracting \"'sys/mac/macwin.c2'\" \(37726 characters\)
sed "s/^X//" >'sys/mac/macwin.c2' <<'END_OF_FILE'
Xstatic void
XmacClickMenu ( EventRecord * theEvent , WindowPtr theWindow )
X{
X	Point p ;
X	short hiRow = -1 , loRow = -1 ;
X	Rect r ;
X	NhWindow * aWin = ( NhWindow * ) GetWRefCon ( theWindow ) ;
X
X	r = theWindow -> portRect ;
X	if ( aWin -> scrollBar && ( * aWin -> scrollBar ) -> contrlVis ) {
X		short code ;
X		Point p = theEvent -> where ;
X		ControlHandle theBar ;
X
X		r . right -= SBARWIDTH ;
X		GlobalToLocal ( & p ) ;
X		code = FindControl ( p , theWindow , & theBar ) ;
X		if ( code ) {
X			DoScrollBar ( p , code , theBar , aWin , theWindow ) ;
X			return ;
X		}
X		if ( p . h >= r . right )
X			return ;
X	}
X	r . top = r . bottom = 0 ;
X	if ( inSelect != WIN_ERR ) {
X		do {
X			SystemTask ( ) ;
X			GetMouse ( & p ) ;
X			if ( p . h < theWindow -> portRect . left || p . h > theWindow ->
X				portRect . right || p . v < 0 || p . v > theWindow -> portRect .
X				bottom ) {
X				hiRow = -1 ;
X			} else {
X				hiRow = p . v / aWin -> charHeight ;
X				if ( hiRow >= aWin -> lin )
X					hiRow = -1 ;
X			}
X			if ( hiRow != loRow ) {
X				if ( loRow > -1 && aWin -> itemChars [ loRow + aWin ->
X					scrollPos ] ) {
X					r . top = loRow * aWin -> charHeight ;
X					r . bottom = ( loRow + 1 ) * aWin -> charHeight ;
X					InvertRect ( & r ) ;
X				}
X				loRow = hiRow ;
X				if ( loRow > -1 && aWin -> itemChars [ loRow + aWin ->
X					scrollPos ] ) {
X					r . top = loRow * aWin -> charHeight ;
X					r . bottom = ( loRow + 1 ) * aWin -> charHeight ;
X					InvertRect ( & r ) ;
X				}
X			}
X		} while ( StillDown ( ) ) ;
X		if ( loRow > -1 && aWin -> itemChars [ loRow + aWin -> scrollPos ] ) {
X			InvertRect ( & r ) ;
X			addToKeyQueue ( aWin -> itemChars [ loRow + aWin -> scrollPos ] , 1 ) ;
X		}
X	}
X}
X
X
Xstatic void
XmacClickText ( EventRecord * theEvent , WindowPtr theWindow )
X{
X	short hiRow = -1 , loRow = -1 ;
X	Rect r ;
X	NhWindow * aWin = ( NhWindow * ) GetWRefCon ( theWindow ) ;
X
X	r = theWindow -> portRect ;
X	if ( aWin -> scrollBar && ( * aWin -> scrollBar ) -> contrlVis ) {
X		short code ;
X		Point p = theEvent -> where ;
X		ControlHandle theBar ;
X
X		r . right -= SBARWIDTH ;
X		GlobalToLocal ( & p ) ;
X		code = FindControl ( p , theWindow , & theBar ) ;
X		if ( code ) {
X			DoScrollBar ( p , code , theBar , aWin , theWindow ) ;
X			return ;
X		}
X	}
X}
X
X
Xstatic void
XmacUpdateNull ( EventRecord * theEvent , WindowPtr theWindow )
X{
X	if ( ! theEvent || ! theWindow ) {
X		Debugger ( ) ;
X	}
X}
X
X
Xstatic void
Xdraw_growicon_vert_only(WindowPtr wind) {
X	GrafPtr org_port;
X	RgnHandle org_clip = NewRgn();
X	Rect r = wind->portRect;
X	r.left = r.right - SBARWIDTH;
X
X	GetPort(&org_port);
X	SetPort(wind);
X	GetClip(org_clip);
X	ClipRect(&r);
X	DrawGrowIcon(wind);
X	SetClip(org_clip);
X	DisposeRgn(org_clip);
X	SetPort(org_port);
X}
X
X
Xstatic void
XmacUpdateMessage ( EventRecord * theEvent , WindowPtr theWindow )
X{
X	RgnHandle org_clip = NewRgn(), clip = NewRgn();
X	Rect r = theWindow -> portRect ;
X	NhWindow * aWin = ( NhWindow * ) GetWRefCon ( theWindow ) ;
X	int l ;
X
X	if ( ! theEvent ) {
X		Debugger ( ) ;
X	}
X
X	GetClip(org_clip);
X
X	DrawGrowIcon(theWindow);
X
X	l = 0;
X	while (topl_resp[l]) {
X		StringPtr name;
X		unsigned char tmp[2];
X		FontInfo font;
X		Rect frame;
X		topl_resp_rect(l, &frame);
X		switch (topl_resp[l]) {
X			case 'y':
X				name = "\pyes";
X				break;
X			case 'n':
X				name = "\pno";
X				break;
X			case 'N':
X				name = "\pNone";
X				break;
X			case 'a':
X				name = "\pall";
X				break;
X			case 'q':
X				name = "\pquit";
X				break;
X			case CHAR_ANY:
X				name = "\pany key";
X				break;
X			default:
X				tmp[0] = 1;
X				tmp[1] = topl_resp[l];
X				name = &tmp;
X				break;
X		}
X		TextFont(geneva);
X		TextSize(9);
X		GetFontInfo(&font);
X		MoveTo((frame.left + frame.right  - StringWidth(name)) / 2,
X			   (frame.top  + frame.bottom + font.ascent-font.descent-font.leading-1) / 2);
X		DrawString(name);
X		PenNormal();
X		if (l == topl_def_idx)
X			PenSize(2, 2);
X		FrameRoundRect(&frame, 4, 4);
X		++l;
X	}
X
X	r . right -= SBARWIDTH + 2;
X	r . bottom -= SBARHEIGHT + 1;
X	/* Clip to the portrect - scrollbar/growicon *before* adjusting the rect
X		to be larger than the size of the window (!) */
X	RectRgn(clip, &r);
X	if ( r . right < MIN_RIGHT )
X		r . right = MIN_RIGHT ;
X
X	if (in_topl_mode()) {
X		RgnHandle topl_rgn = NewRgn();
X		Rect topl_r = r;
X		for (l = aWin->windowTextLen - 1; --l >= aWin->textBase; )
X			if ((*aWin->windowText)[l] == CHAR_CR)
X				topl_r.top += aWin->charHeight;
X		l = (*top_line)->destRect.right - (*top_line)->destRect.left;
X		(*top_line)->viewRect = topl_r;
X		(*top_line)->destRect = topl_r;
X		if (l != topl_r.right - topl_r.left)
X			TECalText(top_line);
X		TEUpdate(&topl_r, top_line);
X		RectRgn(topl_rgn, &topl_r);
X		DiffRgn(clip, topl_rgn, clip);
X		DisposeRgn(topl_rgn);
X	}
X
X	SectRgn(clip, org_clip, clip);
X	SetClip(clip);
X	DisposeRgn(clip);
X
X	TextFont ( aWin -> fontNum ) ;
X	TextSize ( aWin -> fontSize ) ;
X	HLock ( aWin -> windowText ) ;
X	TextBox ( * ( aWin -> windowText ) + aWin -> textBase , aWin ->
X		windowTextLen - aWin -> textBase , & r , teJustLeft ) ;
X	HUnlock ( aWin -> windowText ) ;
X
X	SetClip(org_clip);
X	DisposeRgn(org_clip);
X}
X
X
Xstatic void
XmacUpdateStatus ( EventRecord * theEvent , WindowPtr theWindow )
X{
X	NhWindow * nhw = ( NhWindow * ) GetWRefCon ( theWindow ) ;
X	int height = nhw -> charHeight ;
X	int leading = nhw -> leading ;
X	int i ;
X
X	if ( ! theEvent ) {
X		Debugger ( ) ;
X	}
X
X	TextFont ( nhw -> fontNum ) ;
X	TextSize ( nhw -> fontSize ) ;
X	HLock ( nhw -> windowText ) ;
X	for ( i = 0 ; i < NUM_STAT_ROWS ; i ++ ) {
X		MoveTo ( 0 , ( i + 1 ) * height - leading ) ;
X		DrawText ( ( ( StatusData * ) ( * nhw -> windowText ) ) -> map [ i ] ,
X			0 , NUM_COLS ) ;
X	}
X	HUnlock ( nhw -> windowText ) ;
X}
X
X
Xstatic void
XDrawMapCursor ( NhWindow * nhw )
X{
X	Rect r ;
X
X	/*
X	 * We only want a cursor in the map
X	 * window...
X	 */
X	if ( ! WIN_MAP || nhw - theWindows != WIN_MAP )
X		return ;
X
X	r . left = nhw -> cursor . h * nhw -> charWidth ;
X	r . right = ( nhw -> cursor . h + 1 ) * nhw -> charWidth ;
X	r . top = nhw -> cursor . v * nhw -> charHeight ;
X	r . bottom = ( nhw -> cursor . v + 1 ) * nhw -> charHeight ;
X	InvertRect ( & r ) ;
X	nhw -> cursorDrawn = 1 ;
X}
X
X
Xstatic void
XmacUpdateMap ( EventRecord * theEvent , WindowPtr theWindow )
X{
X	NhWindow * nhw = ( NhWindow * ) GetWRefCon ( theWindow ) ;
X	int height = nhw -> charHeight ;
X	int leading = nhw -> leading ;
X	int i ;
X
X	if ( ! theEvent ) {
X		Debugger ( ) ;
X	}
X
X	TextFont ( nhw -> fontNum ) ;
X	TextSize ( nhw -> fontSize ) ;
X	HLock ( nhw -> windowText ) ;
X	for ( i = 0 ; i < NUM_ROWS ; i ++ ) {
X		MoveTo ( 0 , ( i + 1 ) * height - leading ) ;
X		DrawText ( ( ( MapData * ) ( * nhw -> windowText ) ) -> map [ i ] ,
X			0 , NUM_COLS ) ;
X	}
X	HUnlock ( nhw -> windowText ) ;
X	if ( nhw -> cursorDrawn ) {
X		DrawMapCursor ( nhw ) ;
X	}
X}
X
X
Xstatic void
XmacUpdateMenu ( EventRecord * theEvent , WindowPtr theWindow )
X{
X	Rect r = theWindow -> portRect ;
X	Rect r2 = r ;
X	NhWindow * aWin = ( NhWindow * ) GetWRefCon ( theWindow ) ;
X	RgnHandle h ;
X	Boolean vis ;
X
X	if ( ! theEvent ) {
X		Debugger ( ) ;
X	}
X
X	draw_growicon_vert_only(theWindow);
X
X	r2 . left = r2 . right - SBARWIDTH ;
X	r2 . right += 1 ;
X	r2 . top -= 1 ;
X	vis = ( r2 . bottom > r2 . top + 50 ) ;
X	DrawControls ( theWindow ) ;
X
X	h = (RgnHandle) NULL ;
X	if ( vis && ( h = NewRgn ( ) ) ) {
X		RgnHandle tmp = NewRgn ( ) ;
X		if ( ! tmp ) {
X			DisposeRgn ( h ) ;
X			h = (RgnHandle) NULL ;
X		} else {
X			GetClip ( h ) ;
X			RectRgn ( tmp , & r2 ) ;
X			DiffRgn ( h , tmp , tmp ) ;
X			SetClip ( tmp ) ;
X			DisposeRgn ( tmp ) ;
X		}
X	}
X	if ( r . right < MIN_RIGHT )
X		r . right = MIN_RIGHT ;
X	r . top -= aWin -> scrollPos * aWin -> charHeight ;
X	HLock ( aWin -> windowText ) ;
X	TextBox ( * ( aWin -> windowText ) + aWin -> textBase , aWin ->
X		windowTextLen - aWin -> textBase , & r , teJustLeft ) ;
X	HUnlock ( aWin -> windowText ) ;
X	if ( h ) {
X		SetClip ( h ) ;
X		DisposeRgn ( h ) ;
X	}
X}
X
X
Xstatic void
XmacUpdateText ( EventRecord * theEvent , WindowPtr theWindow )
X{
X	Rect r = theWindow -> portRect ;
X	Rect r2 = r ;
X	NhWindow * aWin = ( NhWindow * ) GetWRefCon ( theWindow ) ;
X	RgnHandle h ;
X	Boolean vis ;
X
X	if ( ! theEvent ) {
X		Debugger ( ) ;
X	}
X
X	r2 . left = r2 . right - SBARWIDTH ;
X	r2 . right += 1 ;
X	r2 . top -= 1 ;
X	vis = ( r2 . bottom > r2 . top + 50 ) ;
X	DrawControls ( theWindow ) ;
X
X	h = (RgnHandle) NULL ;
X	if ( vis && ( h = NewRgn ( ) ) ) {
X		RgnHandle tmp = NewRgn ( ) ;
X		if ( ! tmp ) {
X			DisposeRgn ( h ) ;
X			h = (RgnHandle) NULL ;
X		} else {
X			GetClip ( h ) ;
X			RectRgn ( tmp , & r2 ) ;
X			DiffRgn ( h , tmp , tmp ) ;
X			SetClip ( tmp ) ;
X			DisposeRgn ( tmp ) ;
X		}
X	}
X	if ( r . right < MIN_RIGHT )
X		r . right = MIN_RIGHT ;
X	r . top -= aWin -> scrollPos * aWin -> charHeight ;
X	r . right -= SBARWIDTH;
X	HLock ( aWin -> windowText ) ;
X	TextBox ( * ( aWin -> windowText ) + aWin -> textBase , aWin ->
X		windowTextLen - aWin -> textBase , & r , teJustLeft ) ;
X	HUnlock ( aWin -> windowText ) ;
X	draw_growicon_vert_only(theWindow);
X	if ( h ) {
X		SetClip ( h ) ;
X		DisposeRgn ( h ) ;
X	}
X}
X
X
Xstatic void
XmacCursorNull ( EventRecord * theEvent , WindowPtr theWindow , RgnHandle mouseRgn )
X{
X	Rect r = { -1 , -1 , 2 , 2 } ;
X
X	InitCursor ( ) ;
X	OffsetRect ( & r , theEvent -> where . h , theEvent -> where . v ) ;
X	RectRgn ( mouseRgn , & r ) ;
X}
X
X
Xstatic void
XmacCursorMessage ( EventRecord * theEvent , WindowPtr theWindow , RgnHandle mouseRgn )
X{
X	Rect r = { -1 , -1 , 2 , 2 } ;
X
X	InitCursor ( ) ;
X	OffsetRect ( & r , theEvent -> where . h , theEvent -> where . v ) ;
X	RectRgn ( mouseRgn , & r ) ;
X}
X
X
Xstatic void
XmacCursorStatus ( EventRecord * theEvent , WindowPtr theWindow , RgnHandle mouseRgn )
X{
X	Rect r = { -1 , -1 , 2 , 2 } ;
X
X	InitCursor ( ) ;
X	OffsetRect ( & r , theEvent -> where . h , theEvent -> where . v ) ;
X	RectRgn ( mouseRgn , & r ) ;
X}
X
X
Xstatic void
XmacCursorMap ( EventRecord * theEvent , WindowPtr theWindow , RgnHandle mouseRgn )
X{
X	Point where ;
X	CursHandle ch ;
X	GrafPtr gp ;
X	NhWindow * nhw = ( NhWindow * ) GetWRefCon ( theWindow ) ;
X	Rect r = { 0 , 0 , 1 , 1 } ;
X
X	GetPort ( & gp ) ;
X	SetPort ( theWindow ) ;
X
X	where = theEvent -> where ;
X	GlobalToLocal ( & where ) ;
X	ch = GetCursor ( 512 + clickSector ( u . ux , u . uy , where . h / nhw -> charWidth ,
X		where . v / nhw -> charHeight ) ) ;
X	if ( ch ) {
X
X		HLock ( ( Handle ) ch ) ;
X		SetCursor ( * ch ) ;
X		ReleaseResource ( ( Handle ) ch ) ;
X
X	} else {
X
X		InitCursor ( ) ;
X	}
X	OffsetRect ( & r , theEvent -> where . h , theEvent -> where . v ) ;
X	RectRgn ( mouseRgn , & r ) ;
X
X	SetPort ( gp ) ;
X}
X
X
Xstatic void
XmacCursorMenu ( EventRecord * theEvent , WindowPtr theWindow , RgnHandle mouseRgn )
X{
X	Rect r = { -1 , -1 , 2 , 2 } ;
X
X	InitCursor ( ) ;
X	OffsetRect ( & r , theEvent -> where . h , theEvent -> where . v ) ;
X	RectRgn ( mouseRgn , & r ) ;
X}
X
X
Xstatic void
XmacCursorText ( EventRecord * theEvent , WindowPtr theWindow , RgnHandle mouseRgn )
X{
X	Rect r = { -1 , -1 , 2 , 2 } ;
X
X	InitCursor ( ) ;
X	OffsetRect ( & r , theEvent -> where . h , theEvent -> where . v ) ;
X	RectRgn ( mouseRgn , & r ) ;
X}
X
X
Xvoid
XUpdateMenus ( void )
X{
X	WindowPeek w = ( WindowPeek ) FrontWindow ( ) ;
X	Boolean enable = FALSE ;
X	int i ;
X
X	/* All menu items are OK, except the "edit" menu */
X
X	if ( w && w -> windowKind < 0 ) {
X		enable = TRUE ;
X	}
X	for ( i = 1 ; i < 7 ; i ++ ) {
X		if ( i == 2 )
X			continue ;
X		if ( enable ) {
X			EnableItem ( editMenu , i ) ;
X		} else {
X			DisableItem ( editMenu , i ) ;
X		}
X	}
X}
X
X
Xvoid
XDoMenu ( long choise )
X{
X	WindowPeek w = ( WindowPeek ) FrontWindow ( ) ;
X	short menu = choise >> 16 ;
X	short item = choise & 0xffff ;
X	int i ;
X	Str255 str ;
X
X	HiliteMenu ( menu ) ;
X
X	if ( menu == kHMHelpMenuID ) {
X		menu = 128 ;
X		item = 2 ;
X	}
X
X	if ( menu == 128 && item > 2 ) /* apple, DA */ {
X		GetItem ( appleMenu , item , str ) ;
X		OpenDeskAcc ( str ) ;
X	} else if ( menu == 130 ) /* edit */ {
X		SystemEdit ( item - 1 ) ;
X	} else {
X		GetIndString ( str , menu + 1 , item ) ;
X		if ( str [ 0 ] > QUEUE_LEN ) {
X			error ( "Too long command : menul %d item %d" , menu , item ) ;
X			str [ 0 ] = QUEUE_LEN ;
X		}
X		for ( i = 1 ; i <= str [ 0 ] ; i ++ ) {
X			addToKeyQueue ( str [ i ] , 0 ) ;
X		}
X	}
X
X	HiliteMenu ( 0 ) ;
X}
X
X
Xvoid
XHandleKey ( EventRecord * theEvent )
X{
X	WindowPtr theWindow = FrontWindow ( ) ;
X
X	if ( theEvent -> modifiers & cmdKey ) {
X		if ( theEvent -> message & 0xff == '.' ) {
X			int i ;
X/* Flush key queue */
X			for ( i = 0 ; i < QUEUE_LEN ; i ++ ) {
X				keyQueue [ i ] = 0 ;
X			}
X			theEvent -> message = '\033' ;
X			goto dispatchKey ;
X		} else {
X			UpdateMenus ( ) ;
X			DoMenu ( MenuKey ( theEvent -> message & 0xff ) ) ;
X		}
X	} else {
X
XdispatchKey :
X		if ( theWindow ) {
X			( ( NhWindow * ) GetWRefCon ( theWindow ) ) -> keyFunc ( theEvent ,
X				theWindow ) ;
X		} else {
X			GeneralKey ( theEvent , (WindowPtr) NULL ) ;
X		}
X	}
X}
X
X
Xvoid
XHandleClick ( EventRecord * theEvent )
X{
X	int code ;
X	unsigned long l ;
X	WindowPtr theWindow ;
X	Rect r = ( * GetGrayRgn ( ) ) -> rgnBBox ;
X	NhWindow * aWin ;
X
X	InsetRect ( & r , 4 , 4 ) ;
X
X	code = FindWindow ( theEvent -> where , & theWindow ) ;
X	aWin = ( NhWindow * ) GetWRefCon ( theWindow ) ;
X
X	if ( code != inContent ) {
X		InitCursor ( ) ;
X	} else {
X		aWin -> cursorFunc ( theEvent , theWindow , gMouseRgn ) ; /* Correct direction */
X	}
X	switch ( code ) {
X
X	case inContent :
X		if ( inSelect == WIN_ERR || aWin - theWindows == inSelect ) {
X			SelectWindow ( theWindow ) ;
X			SetPort ( theWindow ) ;
X			( ( NhWindow * ) GetWRefCon ( theWindow ) ) -> clickFunc ( theEvent ,
X				theWindow ) ;
X		} else {
X			nhbell ( ) ;
X		}
X		break ;
X
X	case inDrag :
X		if ( inSelect == WIN_ERR || aWin - theWindows == inSelect ) {
X			InitCursor ( ) ;
X			DragWindow ( theWindow , theEvent -> where , & r ) ;
X			SaveWindowPos ( theWindow ) ;
X		} else {
X			nhbell ( ) ;
X		}
X		break ;
X
X	case inGrow :
X		if ( inSelect == WIN_ERR || aWin - theWindows == inSelect ) {
X			InitCursor ( ) ;
X			SetRect ( & r , 80 , 2 * aWin -> charHeight + 1 , r . right ,
X				r . bottom ) ;
X			l = GrowWindow ( theWindow , theEvent -> where , & r ) ;
X			SizeWindow ( theWindow , l & 0xffff , l >> 16 , FALSE ) ;
X			SaveWindowSize ( theWindow ) ;
X			SetPort ( theWindow ) ;
X			InvalRect ( & ( theWindow -> portRect ) ) ;
X			if ( aWin -> scrollBar ) {
X				InvalScrollBar ( aWin ) ;
X			}
X		} else {
X			nhbell ( ) ;
X		}
X		break ;
X
X	case inGoAway :
X		if ( TrackGoAway ( theWindow , theEvent -> where ) ) {
X			if ( aWin - theWindows == BASE_WINDOW && ! flags . window_inited ) {
X				addToKeyQueue ( '\033' , 1 ) ;
X				break ;
X			} else {
X				HideWindow ( theWindow ) ;
X			}
X			if ( inSelect == WIN_ERR || aWin - theWindows != inSelect ) {
X				destroy_nhwindow ( aWin - theWindows ) ;
X			} else {
X				addToKeyQueue ( '\033' , 1 ) ;
X			}
X		}
X		break ;
X
X	case inMenuBar :
X		UpdateMenus ( ) ;
X		DoMenu ( MenuSelect ( theEvent -> where ) ) ;
X		break ;
X
X	case inSysWindow :
X		SystemClick( theEvent, theWindow ) ;
X		break ;
X
X	default :
X		break ;
X	}
X}
X
X
Xvoid
XHandleUpdate ( EventRecord * theEvent )
X{
X	WindowPtr theWindow = ( WindowPtr ) theEvent -> message ;
X
X	BeginUpdate ( theWindow ) ;
X	SetPort ( theWindow ) ;
X	EraseRect ( & ( theWindow -> portRect ) ) ;
X	( ( NhWindow * ) GetWRefCon ( theWindow ) ) -> updateFunc ( theEvent ,
X		theWindow ) ;
X	EndUpdate ( theWindow ) ;
X}
X
X
Xstatic void
XDoOsEvt ( EventRecord * theEvent )
X{
X	WindowPtr wp ;
X	short code ;
X
X	if ( ( theEvent -> message & 0xff000000 ) == 0xfa000000 ) { /* Mouse Moved */
X
X		code = FindWindow ( theEvent -> where , & wp ) ;
X		if ( code != inContent ) {
X
X			Rect r = { -1 , -1 , 2 , 2 } ;
X
X			InitCursor ( ) ;
X			OffsetRect ( & r , theEvent -> where . h , theEvent -> where . v ) ;
X			RectRgn ( gMouseRgn , & r ) ;
X
X		} else {
X
X			NhWindow * nhw = ( ( NhWindow * ) GetWRefCon ( wp ) ) ;
X			if ( nhw ) {
X				nhw -> cursorFunc ( theEvent , wp , gMouseRgn ) ;
X			}
X		}
X	} else {
X
X		/* Suspend/resume */
X	}
X}
X
X
Xvoid
XHandleEvent ( EventRecord * theEvent )
X{
X	switch ( theEvent -> what ) {
X	case autoKey :
X	case keyDown :
X		HandleKey ( theEvent ) ;
X		break ;
X	case updateEvt :
X		HandleUpdate ( theEvent ) ;
X		break ;
X	case mouseDown :
X		HandleClick ( theEvent ) ;
X		break ;
X	case diskEvt :
X		if ( ( theEvent -> message & 0xffff0000 ) != 0 ) {
X
X			Point p = { 150 , 150 } ;
X			( void ) DIBadMount ( p , theEvent -> message ) ;
X		}
X		break ;
X	case osEvt :
X		DoOsEvt ( theEvent ) ;
X		break ;
X	default :
X		if ( multi < 0 ) { // Get frozen, so stop repeating
X			int ix;
X			for ( ix = 0 ; ix < QUEUE_LEN ; ix ++ ) {
X				keyQueue [ ix ] = 0 ;
X			}
X			FlushEvents ( keyDownMask , 0 ) ;
X		}
X		/*
X		 * This somewhat elaborate hack is needed to make the menu
X		 * commands work right. They're also needed for fast typists.
X		 */
X		if ( keyQueue [ 0 ] && in_topl_mode() ) {
X			int i ;
X
X			theEvent -> what = keyDown ;
X			theEvent -> modifiers = 0 ;
X			theEvent -> message = keyQueue [ 0 ] ;
X
X/* extract from key queue */
X			for ( i = 0 ; i < QUEUE_LEN - 1 ; i ++ ) {
X				keyQueue [ i ] = keyQueue [ i + 1 ] ;
X			}
X			keyQueue [ i ] = 0 ;
X			SetPort ( theWindows [ WIN_MESSAGE ] . theWindow ) ;
X			theWindows [ WIN_MESSAGE ] . keyFunc ( theEvent ,
X				theWindows [ WIN_MESSAGE ] . theWindow ) ;
X		}
X		break ;
X	}
X}
X
X
Xlong doDawdle = 0L ;
X
Xvoid
XDimMenuBar ( void )
X{
X	DisableItem ( appleMenu , 0 ) ;
X	DisableItem ( fileMenu , 0 ) ;
X	DisableItem ( editMenu , 0 ) ;
X	DisableItem ( extendMenu , 0 ) ;
X	DisableItem ( miscMenu , 0 ) ;
X	DisableItem ( commandsMenu , 0 ) ;
X	DisableItem ( thingsMenu , 0 ) ;
X	DrawMenuBar ( ) ;
X}
X
X
Xvoid
XUndimMenuBar ( void )
X{
X	EnableItem ( appleMenu , 0 ) ;
X	EnableItem ( fileMenu , 0 ) ;
X	EnableItem ( editMenu , 0 ) ;
X	EnableItem ( extendMenu , 0 ) ;
X	EnableItem ( miscMenu , 0 ) ;
X	EnableItem ( commandsMenu , 0 ) ;
X	EnableItem ( thingsMenu , 0 ) ;
X	DrawMenuBar ( ) ;
X}
X
Xstatic int mBarDimmed = 0 ;
X
Xvoid
Xmac_get_nh_event( void )
X{
X	EventRecord anEvent ;
X
X	if ( ( inSelect != WIN_ERR || ! flags . window_inited || in_topl_mode() ) &&
X		! mBarDimmed ) {
X		DimMenuBar ( ) ;
X		mBarDimmed = 1 ;
X	} else if ( inSelect == WIN_ERR && flags . window_inited && mBarDimmed &&
X				! in_topl_mode() ) {
X		UndimMenuBar ( ) ;
X		mBarDimmed = 0 ;
X	}
X	/*
X	 * We want to take care of keys in the buffer as fast as
X	 * possible
X	 */
X	if ( keyQueue [ 0 ] ) {
X		doDawdle = 0L ;
X	}
X	if ( asyDSC ) {
X		SetPort ( asyDSC -> theWindow ) ;
X		DrawScrollbar ( asyDSC , asyDSC -> theWindow ) ;
X	}
X	if ( ! WaitNextEvent ( -1 , & anEvent , doDawdle , gMouseRgn ) ) {
X		anEvent . what = nullEvent ;
X	}
X	doDawdle = 0L ;
X	HandleEvent ( & anEvent ) ;
X
X	if (top_line && theWindows) {
X		WindowPeek win = (WindowPeek)theWindows[WIN_MESSAGE].theWindow;
X		if (win && win->visible)
X			TEIdle(top_line);
X	}
X}
X
X
Xint
Xmac_nhgetch( void )
X{
X	int ch ;
X	register int i ;
X
X	wait_synch ( ) ;
X
X	if ( flags . window_inited && ! theWindows [ WIN_MAP ] . cursorDrawn &&
X		theWindows [ WIN_MAP ] . theWindow ) {
X		SetPort ( theWindows [ WIN_MAP ] . theWindow ) ;
X		DrawMapCursor ( & theWindows [ WIN_MAP ] ) ;
X	}
X
X	if ( ! keyQueue [ 0 ] ) {
X		long total , contig ;
X		static char warn = 0 ;
X
X		PurgeSpace ( & total , & contig ) ;
X		if ( contig < 64000L || total < 256000L ) {
X			if ( ! warn ) {
X				DebugStr ( ( ConstStr255Param ) "\014Low Memory !" ) ;
X				warn = 1 ;
X			}
X		} else {
X			warn = 0 ;
X		}
X	}
X
X	do {
X		doDawdle = ( in_topl_mode() ? GetCaretTime ( ) : 120L ) ;
X		get_nh_event ( ) ;
X		ch = keyQueue [ 0 ] ;
X	} while ( ! ch ) ;
X
X	if ( ! gClickedToMove ) {
X		ObscureCursor ( ) ;
X	} else {
X		gClickedToMove = 0 ;
X	}
X	for ( i = 0 ; i < QUEUE_LEN - 1 ; i ++ ) {
X		keyQueue [ i ] = keyQueue [ i + 1 ] ;
X	}
X	keyQueue [ i ] = 0 ;
X
X#ifdef MAC_THINKC5
X	if (ch == '\r') ch = '\n';
X#endif
X
X	return ch ;
X}
X
X
Xvoid
Xmac_delay_output( void )
X{
X	long destTicks = TickCount ( ) + 1 ;
X
X	while ( TickCount ( ) < destTicks ) {
X		wait_synch ( ) ;
X	}
X}
X
X
Xvoid
Xmac_wait_synch( void )
X{
X	get_nh_event ( ) ;
X}
X
X
Xvoid
Xmac_mark_synch( void )
X{
X	get_nh_event ( ) ;
X}
X
X
Xvoid
Xmac_cliparound ( int x , int y )
X{
X	/* TODO */
X	if ( ! ( x * ( y + 1 ) ) ) {
X		Debugger ( ) ;
X	}
X}
X
X
Xvoid
Xmac_raw_print ( const char * str )
X{
X	/* Here and in mac_raw_print_bold I assume that once theWindows got
X	   allocated by mac_init_nhwindows we can safely do putstr on BASE_WINDOW,
X	   even after mac_exit_nhwindows is called or flags.window_inited is reset
X	   to zero.  Is this assumption correct? */
X	if ( theWindows ) {
X
X		ShowWindow ( theWindows [ BASE_WINDOW ] . theWindow ) ;
X		SelectWindow ( theWindows [ BASE_WINDOW ] . theWindow ) ;
X
X		putstr ( BASE_WINDOW , 0 , str ) ;
X
X	} else
X		showerror ( str , NULL ) ;
X}
X
X
Xvoid
Xmac_raw_print_bold ( const char * str )
X{
X	if ( theWindows ) {
X
X		ShowWindow ( theWindows [ BASE_WINDOW ] . theWindow ) ;
X		SelectWindow ( theWindows [ BASE_WINDOW ] . theWindow ) ;
X
X		putstr ( BASE_WINDOW , ATR_BOLD , str ) ;
X
X	} else {
X		nhbell ( ) ;
X		showerror ( str , NULL ) ;
X	}
X}
X
X
Xvoid
Xmac_exit_nhwindows ( const char * s )
X{
X	if ( s ) {
X		raw_print ( s ) ;
X		display_nhwindow ( BASE_WINDOW , TRUE ) ;
X	}
X
X	clear_nhwindow ( BASE_WINDOW ) ;
X	flags . window_inited = 0 ;
X	destroy_nhwindow ( WIN_MAP ) ;
X	destroy_nhwindow ( WIN_MESSAGE ) ;
X	destroy_nhwindow ( WIN_STATUS ) ;
X	destroy_nhwindow ( WIN_INVEN ) ;
X}
X
X
X/*
X * Don't forget to decrease in_putstr before returning...
X */
Xvoid
Xmac_putstr ( winid win , int attr , const char * str )
X{
X	long len , slen ;
X	NhWindow * aWin = & theWindows [ win ] ;
X	int kind ;
X	static char in_putstr = 0 ;
X	Rect r ;
X
X	if ( in_putstr > 3 ) {
X		DebugStr ( ( ConstStr255Param ) "\012Recursion!" ) ;
X		return ;
X	}
X	if ( win < 0 || win >= NUM_MACWINDOWS ) {
X		error ( "Invalid window %d (Max %d) in putstr." , win ,
X			NUM_MACWINDOWS , attr ) ;
X		return ;
X	}
X	if ( ! aWin -> theWindow ) {
X		error ( "Unallocated window %d in putstr." , win ) ;
X		return ;
X	}
X
X	in_putstr ++ ;
X	kind = ( ( WindowPeek ) ( aWin -> theWindow ) ) -> windowKind -
X		WIN_BASE_KIND ;
X
X	if ( kind == NHW_MAP || kind == NHW_STATUS ) {
X		short	h = ( NUM_COLS - aWin->cursor.h - strlen(str) );
X		/*
X		 * The "dungeon" window
X		 * putsym will call curs, so no updates necessary.
X		 */
X		while ( * str ) {
X			putsym ( win , aWin -> cursor . h , aWin -> cursor . v , * str ) ;
X			curs ( win , aWin -> cursor . h + 1 , aWin -> cursor . v ) ;
X			str ++ ;
X		}
X		h = (h < 0) ? 0 : h;
X		while( h-- ) {
X			putsym ( win , aWin -> cursor . h , aWin -> cursor . v , CHAR_BLANK ) ;
X			curs ( win , aWin -> cursor . h + 1 , aWin -> cursor . v ) ;
X		}
X	} else {
X		char * sr , * ds ;
X		/*
X		 * A "default" text window - uses TextBox
X		 * We just add the text, without attributes for now
X		 */
X		len = GetHandleSize ( aWin -> windowText ) ;
X		slen = strlen ( str ) ;
X		while ( aWin -> windowTextLen + slen + 1 > len ) {
X			len = ( len > 2048 ) ? ( len + 2048 ) : ( len * 2 ) ;
X			SetHandleSize ( aWin -> windowText , len ) ;
X			if ( MemError ( ) ) {
X				error ( "SetHandleSize (putstr)" ) ;
X				aWin -> windowTextLen = 0L ;
X				aWin -> textBase = 0 ;
X				aWin -> lin = 0 ;
X			}
X		}
X	
X		len = aWin -> windowTextLen ;
X		sr = (char *)str ;
X		ds = * ( aWin -> windowText ) + len ;
X		while ( * sr ) {
X			if ( * sr == CHAR_LF )
X				* ds = CHAR_CR ;
X			else
X				* ds = * sr ;
X			if ( * ds == CHAR_CR && kind != NHW_MENU ) {
X				aWin -> lin ++ ;
X			}
X			sr ++ ;
X			ds ++ ;
X		}
X		if ( slen > 1 ) {
X			( * ( aWin -> windowText ) ) [ len + slen ] = CHAR_CR ;
X			aWin -> windowTextLen += slen + 1 ;
X			aWin -> lin ++ ;
X		} else {
X			aWin -> windowTextLen += slen ;
X		}
X	
X		SetPort ( aWin -> theWindow ) ;
X		r = aWin -> theWindow -> portRect ;
X		if ( win && win == WIN_MESSAGE ) {
X			r . bottom -= SBARHEIGHT + 1 ;
X		}
X		InvalRect ( & r ) ;
X		aWin -> clear = 0 ;
X		if ( kind == NHW_MESSAGE ) {
X			char * ptr , * stop ;
X			long oldBase = aWin -> textBase ;
X			short lines = ( r . bottom - r . top ) / aWin -> charHeight - 1 ;
X
X			stop = * aWin -> windowText ;
X			ptr = stop + aWin -> windowTextLen - 1 ;
X			while ( lines >= 0 && -- ptr > stop ) {
X				if ( * ptr == CHAR_CR || * ptr == CHAR_LF )
X					lines -- ;
X			}
X			if ( ptr <= stop ) {
X				aWin -> textBase = 0L ;
X			} else {
X				aWin -> textBase = ptr - stop + 1 ;
X			}
X			if ( oldBase > aWin -> textBase ) {
X				aWin -> textBase = oldBase ;
X			}
X		}
X		if ( aWin -> scrollBar ) {
X			InvalScrollBar ( aWin ) ;
X		}
X	}
X	in_putstr -- ;
X}
X
X
Xvoid
Xputsym ( winid win , int x , int y , CHAR_P sym )
X{
X	NhWindow * aWin = & theWindows [ win ] ;
X	int kind = ( ( WindowPeek ) ( aWin -> theWindow ) ) -> windowKind
X		- WIN_BASE_KIND ;
X	Rect update ;
X
X	aWin -> clear = 0 ;
X	/*
X	 * We don't need to invalidate the old position or set the window,
X	 * since curs() will do that.
X	 */
X	curs ( win , x , y ) ;
X	x = aWin -> cursor . h ;
X	y = aWin -> cursor . v ;
X
X	if ( kind == NHW_MAP || kind == NHW_STATUS) {
X		switch ( sym ) {
X		case CHAR_LF :
X		case CHAR_CR :
X			curs ( win , 1 , y + 1 ) ;
X			break ;
X		case CHAR_BS :
X			if ( x ) {
X				curs ( win , x - 1 , y ) ;
X			}
X			break ;
X		default :
X			/*
X			 * Curs() takes care of getting cursor . v within range even for
X			 * the shorter status window - note; this assumes the status and
X			 * the map windows have the same width !
X			 */
X			update . top = y * aWin -> charHeight ;
X			update . bottom = ( y + 1 ) * aWin -> charHeight ;
X			update . left = x * aWin -> charWidth ;
X			update . right = ( x + 1 ) * aWin -> charWidth ;
X			EraseRect ( & update ) ;
X			MoveTo ( x * aWin -> charWidth , ( y + 1 ) * aWin -> charHeight -
X				aWin -> leading ) ;
X			( ( MapData * ) * aWin -> windowText ) -> map [ y ] [ x ] = sym ;
X			DrawChar ( sym ) ;
X			break ;
X		}
X	} else {
X		char ss [ 2 ] ;
X		ss [ 0 ] = sym ;
X		ss [ 1 ] = 0 ;
X		putstr ( win , 0 , ss ) ;
X	}
X}
X
X
Xvoid
Xmac_curs ( winid win , int x , int y )
X{
X	NhWindow * aWin = & theWindows [ win ] ;
X	int kind = ( ( WindowPeek ) ( aWin -> theWindow ) ) -> windowKind -
X		WIN_BASE_KIND ;
X
X	SetPort  ( aWin -> theWindow ) ;
X	if ( kind == NHW_MAP || kind == NHW_STATUS ) {
X		Rect update ;
X		if ( x >= NUM_COLS ) {
X			x = 1 ; y ++ ;
X		}
X		if ( y >= ( kind == NHW_STATUS ? NUM_STAT_ROWS : NUM_ROWS ) ) {
X			y = 0 ; x = 1 ;
X		}
X		if ( aWin -> cursorDrawn ) {
X			update . top = aWin -> cursor . v * aWin -> charHeight ;
X			update . bottom = ( aWin -> cursor . v + 1 ) * aWin -> charHeight ;
X			update . left = aWin -> cursor . h * aWin -> charWidth ;
X			update . right = ( aWin -> cursor . h + 1 ) * aWin -> charWidth ;
X			EraseRect ( & update ) ;
X			MoveTo ( aWin -> cursor . h * aWin -> charWidth , ( aWin ->
X				cursor . v + 1 ) * aWin -> charHeight - aWin -> leading ) ;
X			DrawChar ( ( ( MapData * ) * ( aWin -> windowText ) ) -> map
X				[ aWin -> cursor . v ] [ aWin -> cursor . h ] ) ;
X			aWin -> cursorDrawn = 0 ;
X		}
X	}
X	MoveTo ( x * aWin -> charWidth , ( y + 1 ) * aWin -> charHeight -
X		aWin -> leading ) ;
X	SetPt ( & ( aWin -> cursor ) , x , y ) ;
X}
X
X
X/*
X *  print_glyph
X *
X *  Print the glyph to the output device.  Don't flush the output device.
X *
X *  Since this is only called from show_glyph(), it is assumed that the
X *  position and glyph are always correct (checked there)!
X */
Xvoid
Xmac_print_glyph ( winid window , XCHAR_P x , XCHAR_P y , int glyph )
X{
X    unsigned int	ch;
X    register int	offset;
X
X#define zap_color(n)
X#define cmap_color(n)
X#define trap_color(n)
X#define obj_color(n)
X#define mon_color(n)
X#define pet_color(c)
X
X    /*
X     *  Map the glyph back to a character.
X     *
X     *  Warning:  For speed, this makes an assumption on the order of
X     *		  offsets.  The order is set in display.h.
X     */
X    if ((offset = (glyph - GLYPH_SWALLOW_OFF)) >= 0) {		/* swallow */
X
X		/* see swallow_to_glyph() in display.c */
X		ch = (uchar) showsyms[S_sw_tl + (offset & 0x7)];
X		mon_color(offset >> 3);
X
X    } else if ((offset = (glyph - GLYPH_ZAP_OFF)) >= 0) {	/* zap beam */
X
X		/* see zapdir_to_glyph() in display.c */
X		ch = showsyms[S_vbeam + (offset & 0x3)];
X		zap_color((offset >> 2));
X
X    } else if ((offset = (glyph - GLYPH_CMAP_OFF)) >= 0) {	/* cmap */
X
X		ch = showsyms[offset];
X		cmap_color(offset);
X
X    } else if ((offset = (glyph - GLYPH_TRAP_OFF)) >= 0) {	/* trap */
X
X		ch = (offset == WEB) ? showsyms[S_web] : showsyms[S_trap];
X		trap_color(offset);
X
X    } else if ((offset = (glyph - GLYPH_OBJ_OFF)) >= 0) {	/* object */
X
X		ch = oc_syms[objects[offset].oc_class];
X		obj_color(offset);
X
X    } else if ((offset = (glyph - GLYPH_BODY_OFF)) >= 0) {	/* a corpse */
X
X		ch = oc_syms[objects[CORPSE].oc_class];
X		mon_color(offset);
X
X    } else if ((offset = (glyph - GLYPH_PET_OFF)) >= 0) {	/* a pet */
X
X		ch = monsyms[mons[offset].mlet];
X		pet_color(offset);
X
X    } else {							/* a monster */
X
X		ch = monsyms[mons[glyph].mlet];
X		mon_color(glyph);
X    }
X
X	if ( ch > 255 ) {
X		error ( "cicn plotting is not supported." ) ;
X		/*
X		 * cicn plotting goes here
X		 */
X	} else {
X		/*
X		 * Print a char from the hack font.
X		 */
X		putsym ( window , x , y , ch ) ;
X	}
X}
X
X
Xint
Xmac_nh_poskey ( int * a , int * b , int * c )
X{
X	if ( ! a || ! b || ! c ) {
X		Debugger ( ) ;
X	}
X	return nhgetch ( ) ;
X}
X
X
Xvoid
Xmac_start_menu ( winid win )
X{
X	NhWindow * aWin = & theWindows [ win ] ;
X
X	HideWindow ( aWin -> theWindow ) ;
X	SetHandleSize ( aWin -> windowText , TEXT_BLOCK ) ;
X	aWin -> wid = 0 ;
X	aWin -> lin = 0 ;
X	clear_nhwindow ( win ) ;
X}
X
X
Xvoid
Xmac_add_menu ( winid win , CHAR_P menuChar , int attr , const char * str )
X{
X	long addSize ;
X	int newWid ;
X	NhWindow * aWin = & theWindows [ win ] ;
X
X	if ( ! str || aWin -> lin >= NUM_MENU_ITEMS )
X		return ;
X
X	SetPort ( aWin -> theWindow ) ;
X	aWin -> itemChars [ aWin -> lin ] = menuChar ;
X
X	addSize = strlen ( str ) ;
X	newWid = TextWidth ( str , 0 , addSize ) ;
X	if ( newWid > aWin -> wid )
X		aWin -> wid = newWid ;
X	putstr ( win , attr , str ) ;
X}
X
X
X/*
X * End a menu in this window, window must a type NHW_MENU.
X * ch is the value to return if the menu is canceled,
X * str is a list of cancel characters (values that may be input)
X * morestr is a prompt to display, rather than the default.
X * str and morestr might be ignored by some ports.
X */
Xvoid
Xmac_end_menu ( winid win , CHAR_P ch , const char * str , const char * morestr )
X{
X	unsigned char buf [ 256 ] ;
X	int len ;
X	NhWindow * aWin = & theWindows [ win ] ;
X
X	strncpy ( aWin -> cancelStr , str , NUM_CANCEL_ITEMS ) ;
X	aWin -> cancelStr [ NUM_CANCEL_ITEMS - 1 ] = 0 ;
X	aWin -> cancelChar = ch ;
X
X	buf [ 0 ] = 0 ;
X	if ( morestr ) {
X		strncpy ( (char *)& buf [ 1 ] , morestr , 255 ) ;
X		len = strlen ( morestr ) ;
X		if ( len > 255 )
X			buf [ 0 ] = 255 ;
X		else
X			buf [ 0 ] = len ;
X	}
X	SetWTitle ( aWin -> theWindow , buf ) ;
X}
X
X
Xchar
Xmac_select_menu ( winid win )
X{
X	short w , h ;
X	int c , l ;
X	WindowPtr theWin = theWindows [ win ] . theWindow ;
X	NhWindow * aWin = & theWindows [ win ] ;
X
X	inSelect = win ;
X
X	SetPort ( theWin ) ;
X	if ( aWin -> wid && aWin -> lin ) {
X		w = aWin -> wid + 16 ;
X		h = aWin -> lin * aWin -> charHeight ;
X		if ( w > 450 ) {
X			w = 450 ;
X		}
X		if ( h > 300 ) {
X			h = 300 ;
X		}
X		SizeWindow ( theWin , w , h , TRUE ) ;
X		if ( aWin -> scrollBar ) {
X			InvalScrollBar ( aWin ) ;
X		}
X	}
X	SelectWindow ( theWin ) ;
X	ShowWindow ( theWin ) ;
X	InvalRect ( & ( theWin -> portRect ) ) ;
X
X	do {
X		while ( ! ( c =  nhgetch ( ) ) ) ;
X		for ( l = 0 ; l < aWin -> lin ; l ++ ) {
X			if ( aWin -> itemChars [ l ] == c )
X				goto done ;
X		}
X		if ( ClosingWindowChar ( c ) ) {
X			c = aWin -> cancelChar ;
X		}
X	} while ( ! strchr ( aWin -> cancelStr , c ) &&
X		c != aWin -> cancelChar ) ;
X
Xdone :
X
X	HideWindow ( theWin ) ;
X
X	inSelect = WIN_ERR ;
X
X	return c ;
X}
X
X
Xvoid
Xmac_display_file ( name, complain )
Xconst char * name;
Xboolean	complain;
X{
X	long l ;
X	short refNum ;
X	Ptr buf ;
X	int win ;
X
X	if ( 0 > ( refNum = macopen ( name , O_RDONLY , TEXT_TYPE ) ) ) {
X		if (complain) error ( "Cannot open file %s." , name ) ;
X	} else {
X		l = macseek ( refNum , 0 , SEEK_END ) ;
X		( void ) macseek ( refNum , 0 , 0L ) ;
X		win = create_nhwindow ( NHW_TEXT ) ;
X		if ( win == WIN_ERR ) {
X			if (complain) error ( "Cannot make window." ) ;
X			goto out ;
X		}
X		buf = NewPtr(l+1);
X		if (buf)
X			l = macread(refNum, buf, l);
X		if (buf && l > 0) {
X			buf[l] = '\0';
X			putstr(win, 0, buf);
X			display_nhwindow(win, FALSE);
X		} else {
X			HideWindow(theWindows[win].theWindow);
X			destroy_nhwindow(win);
X		}
X		if (buf)
X			DisposPtr(buf);
Xout :
X		macclose ( refNum ) ;
X	}
X}
X
X
Xvoid
Xport_help ( )
X{
X	display_file ( PORT_HELP , TRUE ) ;
X}
X
X
Xshort frame_corner ;
X
X
Xstatic pascal void
XFrameItem ( DialogPtr dlog , short item )
X{
X	short k ;
X	Handle h ;
X	Rect r ;
X
X	GetDItem ( dlog , item , & k , & h , & r ) ;
X	PenSize ( 3 , 3 ) ;
X	FrameRoundRect ( & r , frame_corner , frame_corner ) ;
X	PenNormal ( ) ;
X}
X
X
Xvoid
XSetFrameItem ( DialogPtr dlog , short frame , short item )
X{
X	Rect r , r2 ;
X	short kind ;
X	Handle h ;
X
X	GetDItem ( dlog , item , & kind , & h , & r ) ;
X	InsetRect ( & r , -4 , -4 ) ;
X	r2 = r ;
X	GetDItem ( dlog , frame , & kind , & h , & r ) ;
X	SetDItem ( dlog , frame , kind , ( Handle ) FrameItem , & r2 ) ;
X	frame_corner = 16 ;
X}
X
X
X//	Flash a button (for instance OK if you press enter)
X//
Xvoid
XFlashButton ( DialogPtr dlog , short item )
X{
X	short k ;
X	Handle h ;
X	Rect r ;
X	long l ;
X
X	GetDItem ( dlog , item , & k , & h , &  r ) ;
X	if ( k == ctrlItem + btnCtrl ) {
X		HiliteControl ( ( ControlHandle ) h , 1 ) ;
X		Delay ( GetDblTime ( ) / 2 , & l ) ;
X		HiliteControl ( ( ControlHandle ) h , 0 ) ;
X	}
X}
X
X
Xpascal Boolean
XCharacterDialogFilter ( DialogPtr dp , EventRecord * ev , short * item )
X{
X	int ix ;
X	Handle h ;
X	Rect r ;
X	short k ;
X	Str255 s ;
X	unsigned char com [ 2 ] ;
X
X	if ( ev -> what == mouseDown ) {
X
X		int code ;
X		WindowPtr wp ;
X		Rect r ;
X
X		code = FindWindow ( ev -> where , & wp ) ;
X		if ( wp != dp || code != inDrag ) {
X	
X			return 0 ;
X		}
X		r = ( * GetGrayRgn ( ) ) -> rgnBBox ;
X		InsetRect ( & r , 3 , 3 ) ;
X	
X		DragWindow ( wp , ev -> where , & r ) ;
X		SaveWindowPos ( wp ) ;
X
X		ev -> what = nullEvent ;
X		return 1 ;
X	}
X	if ( ev -> what != keyDown ) {
X
X		return 0 ;
X	}
X	com [ 0 ] = 1 ;
X	com [ 1 ] = ev -> message & 0xff ;
X
X	if ( com [ 1 ] == 10 || com [ 1 ] == 13 || com [ 1 ] == 32 ||
X		com [ 1 ] == 3 ) { // various "OK"
X
X		* item = 1 ;
X		FlashButton ( dp , 1 ) ;
X		return 1 ;
X	}
X	if ( com [ 1 ] == 'Q' || com [ 1 ] == 'q' ||
X		 com [ 1 ] == 27 || ( ev -> message & 0xff00 == 0x3500 ) ) { // escape
X
X		* item = 2 ;
X		FlashButton ( dp , 2 ) ;
X		return 1 ;
X	}
X	for ( ix = 3 ; ix ; ix ++ ) {
X
X		h = ( Handle ) NULL ;
X		k = 0 ;
X		GetDItem ( dp , ix , & k , & h , & r ) ;
X		if ( ! k || ! h ) {
X
X			return 0 ;
X		}
X		if ( k == 6 ) { // Radio Button Item
X
X			GetCTitle ( ( ControlHandle ) h , s ) ;
X			s [ 0 ] = 1 ;
X			if ( ! IUEqualString ( com , s ) ) {
X
X				* item = ix ;
X				return 1 ;
X			}
X		}
X	}
X/*NOTREACHED*/
X	return 0 ;
X}
X
X
Xvoid
Xmac_player_selection ( void )
X{
X	ControlHandle	ctrl;
X	DialogPtr		characterDialog;
X	short			itemHit, lastItemSelected, type;
X	Rect			box;
X	
X	characterDialog = GetNewDialog(132, (Ptr) NULL, (WindowPtr) -1);
X	
X	/*
X	** Default selection is random, beginning at the first item after the "Cancel" button.
X	*/
X	
X	lastItemSelected = rn1(12, 3);
X
X	/*
X	** Mark the default selection.
X	*/
X	
X	GetDItem(characterDialog, lastItemSelected, &type, (Handle *) &ctrl, &box);
X	SetCtlValue(ctrl, 1);
X
X	InitCursor ( ) ;
X	SetFrameItem ( characterDialog , 15 , 1 ) ;
X	do {
X		ModalDialog((ModalFilterProcPtr) CharacterDialogFilter , &itemHit);
X		if ((itemHit != 1) && (itemHit != 2)) {
X			/*
X			** If OK and Cancel (items 1 and 2) weren't selected then a radio button 
X			** was pushed.  Unmark the previous selection.
X			*/
X			
X			GetDItem(characterDialog, lastItemSelected, &type, (Handle *) &ctrl, &box);
X			SetCtlValue(ctrl, 0);
X			
X			/*
X			** Mark the current selection.
X			*/
X			
X			GetDItem(characterDialog, itemHit, &type, (Handle *) &ctrl, &box);
X			SetCtlValue(ctrl, 1);
X
X			/*
X			** Save the item number for use later.
X			*/
X			
X			lastItemSelected = itemHit;
X		}
X	} while ((itemHit != 1) && (itemHit != 2));
X	
X	if (itemHit == 2) {
X
X		clearlocks();
X		ExitToShell();
X
X	} else {
X		switch (lastItemSelected) {
X		case 3:
X			pl_character [ 0 ] = 'A';
X			break;
X		case 4:
X			pl_character [ 0 ] = 'B';
X			break;
X		case 5:
X			pl_character [ 0 ] = 'C';
X			break;
X		case 6:
X			pl_character [ 0 ] = 'E';
X			break;
X		case 7:
X			pl_character [ 0 ] = 'H';
X			break;
X		case 8:
X			pl_character [ 0 ] = 'K';
X			break;
X		case 9:
X			pl_character [ 0 ] = 'P';
X			break;
X		case 10:
X			pl_character [ 0 ] = 'R';
X			break;
X		case 11:
X			pl_character [ 0 ] = 'S';
X			break;
X		case 12:
X			pl_character [ 0 ] = 'T';
X			break;
X		case 13:
X			pl_character [ 0 ] = 'V';
X			break;
X		case 14:
X			pl_character [ 0 ] = 'W';
X			break;
X		}
X	}
X	
X	DisposDialog(characterDialog);
X}
X
Xvoid
Xmac_update_inventory ( void )
X{
X}
X
X
Xvoid
Xmac_suspend_nhwindows ( const char * )
X{
X	/*	Can't relly do that :-)		*/
X}
X
X
Xvoid
Xmac_resume_nhwindows ( void )
X{
X	/*	Can't relly do that :-)		*/
X}
X
X
Xint
Xtry_key_queue ( char * bufp )
X{
X	if ( keyQueue [ 0 ] ) {
X
X		int ix , flag = 0 ;
X		for ( ix = 0 ; ix < QUEUE_LEN ; ix ++ ) {
X
X			if ( ! flag ) {
X
X				if ( ! ( bufp [ ix ] = keyQueue [ ix ] ) ) {
X
X					flag = 1 ;
X				}
X			}
X			keyQueue [ ix ] = 0 ;
X		}
X		if ( ! flag ) {
X
X			bufp [ ix ] = 0 ;
X		}
X		return 1 ;
X	}
X
X	return 0 ;
X}
X
X/* Interface definition, for windows.c */
Xstruct window_procs mac_procs = {
X    "mac",
X    mac_init_nhwindows,
X    mac_player_selection,
X    mac_askname,
X    mac_get_nh_event,
X    mac_exit_nhwindows,
X    mac_suspend_nhwindows,
X    mac_resume_nhwindows,
X    mac_create_nhwindow,
X    mac_clear_nhwindow,
X    mac_display_nhwindow,
X    mac_destroy_nhwindow,
X    mac_curs,
X    mac_putstr,
X    mac_display_file,
X    mac_start_menu,
X    mac_add_menu,
X    mac_end_menu,
X    mac_select_menu,
X    mac_update_inventory,
X    mac_mark_synch,
X    mac_wait_synch,
X#ifdef CLIPPING
X    mac_cliparound,
X#endif
X    mac_print_glyph,
X    mac_raw_print,
X    mac_raw_print_bold,
X    mac_nhgetch,
X    mac_nh_poskey,
X    mac_nhbell,
X    mac_doprev_message,
X    mac_yn_function,
X    mac_getlin,
X#ifdef COM_COMPL
X    mac_get_ext_cmd,
X#endif /* COM_COMPL */
X    mac_number_pad,
X    mac_delay_output,
X    /* other defs that really should go away (they're tty specific) */
X	0,	//    mac_start_screen,
X	0, //    mac_end_screen,
X} ;
X
X/*macwin.c*/
END_OF_FILE
if test 37726 -ne `wc -c <'sys/mac/macwin.c2'`; then
    echo shar: \"'sys/mac/macwin.c2'\" unpacked with wrong size!
fi
# end of 'sys/mac/macwin.c2'
fi
if test -f 'sys/vms/Makefile.src' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/vms/Makefile.src'\"
else
echo shar: Extracting \"'sys/vms/Makefile.src'\" \(17335 characters\)
sed "s/^X//" >'sys/vms/Makefile.src' <<'END_OF_FILE'
X#	NetHack Makefile (VMS) - for building nethack itself.
X#	SCCS Id: @(#)Makefile.src	3.1	93/01/25
X
X#  Copy this file to [.src]Makefile. and then edit it as needed.
X#  If you changed CC or CFLAGS, make similar changes in [.util]Makefile.
X#
X#  Note:  modifying this Makefile will cause crtl.opt to be rebuilt,
X#	which will trigger an update of makedefs, which will in turn
X#	result in a full build of just about _everything_.
X
XMAKE	= mms
XCD	= set default
XECHO	= write sys$output
XNOOP	= !
XRUN	= mcr
XTOUCH	= append/New _NLA0:	# only one file per $(TOUCH)
X# source tree, relative to 'src' and 'util'
XINC = [-.include]
XSHR = [-.sys.share]
XSRC = [-.src]
XTTY = [-.win.tty]
XUTL = [-.util]
XVMS = [-.sys.vms]
XX11 = [-.win.X11]
X
XMAKEFILE= $(SRC)Makefile.
X
X# if you are using gcc as your compiler:
X#	uncomment the CC definition below if it's not in your environment
X# CC = gcc
X
X# set option flags for C compiler and linker
X#
X#CFLAGS = /Debug/noOptimize/Include=$(INC)
XCFLAGS	= /Include=$(INC)/noList
X#CFLAGS = /Stand=VAXC/Incl=$(INC)/noList	# DECC in VAXC mode
X#LFLAGS = /Debug/Map/Cross_Ref			# for development
X#LFLAGS = /noTraceback/noMap			# for installing w/ privs
XLFLAGS	= /noMap
XLINK	= link
X
XLIBS	= sys$share:vaxcrtl.exe/Shareable
X#LIBS	=					# blank for DECC
XMORELIBS =
X# GCC needs an extra library
X#MORELIBS = gnu_cc:[000000]gcclib.olb/Library
X
X# Specific VMS object files
XSYSSRC = $(VMS)vmsmain.c,$(VMS)vmstty.c,$(VMS)vmsunix.c,\
X	$(VMS)vmsmisc.c,$(VMS)vmsfiles.c,$(VMS)vmsmail.c
XSYSOBJ = vmsmain.obj,vmstty.obj,vmsunix.obj,vmsfiles.obj,vmsmail.obj #,vmsmisc.obj
XLIBOPT = $(SRC)crtl.opt;
X
X# Choose if you need the GNU termcap routines
XTERMCAPSRC = $(VMS)gnutermcap.c $(VMS)gnutparam.c
XTERMCAPOBJ = ,gnutermcap.obj,gnutparam.obj
X
X# Set WINSRC and WINOBJ lines corresponding to your desired combination
X# of windowing systems.  Also set windowing systems in config.h.
X#
X# a straight tty port using no native windowing system
XWINTTYSRC = $(TTY)getline.c $(TTY)termcap.c $(TTY)topl.c $(TTY)wintty.c \
X	$(TERMCAPSRC)
XWINTTYOBJ = getline.obj,termcap.obj,topl.obj,wintty.obj $(TERMCAPOBJ)
X#
X# an X11 port (not supported under DECwindows)
XWINX11SRC = $(X11)Window.c $(X11)dialogs.c $(X11)winX.c $(X11)winmap.c \
X	$(X11)winmenu.c $(X11)winmesg.c $(X11)winmisc.c $(X11)winstat.c \
X	$(X11)wintext.c $(X11)winval.c
XWINX11OBJ = Window.obj,dialogs.obj,winX.obj,winmap.obj,winmenu.obj,\
X	winmesg.obj,winmisc.obj,winstat.obj,wintext.obj,winval.obj
X#
X#
XWINSRC = $(WINTTYSRC)
XWINOBJ = $(WINTTYOBJ)
X
X# make NetHack for VMS
XSYSTEM	= SysVMS.timestamp;
XGAME	= $(SRC)nethack.exe;
X
X# RANDOM is defined in vmsconf.h
XRANDOBJ = random.obj
X
X# ----------------------------------------
X#
X# Nothing below this line should have to be changed.
X#
X# Other things that have to be reconfigured are in vmsconf.h,
X# and config.h
X
X# note: no trailing whitespace (or comment) after version or patchlevel numbers
XVERSION  =3.1
XPATCHLVL =0
X
XMAKEDEFS = $(UTL)makedefs.exe;
X
X# all .c that are part of the main NetHack program and are not operating- or
X# windowing-system specific
XHACKCSRC = allmain.c alloc.c apply.c artifact.c attrib.c ball.c bones.c\
X	   botl.c cmd.c dbridge.c decl.c detect.c display.c do.c do_name.c\
X	   do_wear.c dog.c dogmove.c dokick.c dothrow.c drawing.c dungeon.c\
X	   eat.c end.c engrave.c exper.c explode.c extralev.c files.c\
X	   fountain.c hack.c hacklib.c invent.c lock.c mail.c makemon.c\
X	   mcastu.c mhitm.c mhitu.c minion.c mklev.c mkmap.c mkmaze.c\
X	   mkobj.c mkroom.c mon.c mondata.c monmove.c monst.c mplayer.c\
X	   mthrowu.c muse.c music.c o_init.c objects.c objnam.c options.c\
X	   pager.c pickup.c pline.c polyself.c potion.c pray.c priest.c\
X	   quest.c questpgr.c read.c rect.c restore.c rip.c rnd.c rumors.c\
X	   save.c shk.c shknam.c sit.c sounds.c sp_lev.c spell.c steal.c\
X	   timeout.c topten.c track.c trap.c u_init.c uhitm.c vault.c\
X	   version.c vision.c weapon.c were.c wield.c windows.c wizard.c\
X	   worm.c worn.c write.c zap.c
X
X# .c files for this version (for date.h)
XVERSOURCES = $(HACKCSRC) $(SYSSRC) $(WINSRC) monstr.c vis_tab.c
X
X# all .h files except date.h, onames.h, pm.h, and vis_tab.h which would
X# cause dependency loops if run through "make depend"
X# and dgn_comp.h, dgn_file.h, lev_comp.h, special level & dungeon files.
X#
XHACKINCL = align.h amiconf.h artifact.h artilist.h attrib.h color.h config.h\
X	   coord.h decl.h def_os2.h display.h dungeon.h edog.h emin.h engrave.h\
X	   epri.h eshk.h extern.h flag.h func_tab.h global.h hack.h lev.h\
X	   macconf.h mfndpos.h micro.h mkroom.h monattk.h mondata.h monflag.h\
X	   monst.h monsym.h obj.h objclass.h os2conf.h patchlevel.h pcconf.h\
X	   permonst.h prop.h rect.h rm.h sp_lev.h spell.h system.h termcap.h\
X	   tosconf.h tradstdc.h trampoli.h trap.h unixconf.h vault.h vision.h\
X	   vmsconf.h wintty.h winX.h winprocs.h wintype.h you.h youprop.h
X
X#HSOURCES = $(HACKINCL) date.h onames.h pm.h vis_tab.h\
X#		lev_comp.h dgn_comp.h dgn_file.h
X
X# the following .obj's should be made before any others (for makedefs)
XFIRSTOBJ = vmsmisc.obj,monst.obj,objects.obj
X
X# split up long list so that we can write pieces of it into nethack.opt
XHOBJ1 = allmain.obj,alloc.obj,apply.obj,artifact.obj,attrib.obj, \
X	ball.obj,bones.obj,botl.obj,cmd.obj,dbridge.obj,decl.obj, \
X	detect.obj,display.obj,do.obj,do_name.obj,do_wear.obj,dog.obj
XHOBJ2 = dogmove.obj,dokick.obj,dothrow.obj,drawing.obj,dungeon.obj, \
X	eat.obj,end.obj,engrave.obj,exper.obj,explode.obj,extralev.obj, \
X	files.obj,fountain.obj,hack.obj,hacklib.obj,invent.obj
XHOBJ3 = lock.obj,mail.obj,makemon.obj,mcastu.obj,mhitm.obj,mhitu.obj, \
X	minion.obj,mklev.obj,mkmap.obj,mkmaze.obj,mkobj.obj,mkroom.obj, \
X	mon.obj,mondata.obj,monmove.obj,monstr.obj,mplayer.obj
XHOBJ4 = mthrowu.obj,muse.obj,music.obj,o_init.obj,objnam.obj, \
X	options.obj,pager.obj,pickup.obj,pline.obj,polyself.obj, \
X	potion.obj,pray.obj,priest.obj,quest.obj,questpgr.obj,read.obj
XHOBJ5 = rect.obj,restore.obj,rip.obj,rnd.obj,rumors.obj,save.obj, \
X	shk.obj,shknam.obj,sit.obj,sounds.obj,sp_lev.obj,spell.obj, \
X	steal.obj,timeout.obj,topten.obj,track.obj,trap.obj,u_init.obj
XHOBJ6 = uhitm.obj,vault.obj,vision.obj,vis_tab.obj,weapon.obj,were.obj, \
X	wield.obj,windows.obj,wizard.obj,worm.obj,worn.obj,write.obj, \
X	zap.obj,version.obj
XHOBJ  = $(FIRSTOBJ) $(SYSOBJ) $(WINOBJ) $(RANDOBJ) \
X	$(HOBJ1) $(HOBJ2) $(HOBJ3) $(HOBJ4) $(HOBJ5) $(HOBJ6)
X
X# simpler target name
Xnethack : $(GAME)
X      @ $(ECHO) "nethack is up to date."
X
X$(GAME) :	$(SYSTEM)
X      @ $(NOOP)
X
X$(SYSTEM) :	$(LIBOPT) $(HOBJ) nethack.opt
X      @ $(ECHO) "Linking ..."
X	$(LINK)/Exe=$(GAME) $(LFLAGS) nethack.opt/Opt,$(LIBOPT)/Opt
X	$(TOUCH) $(SYSTEM)
X
Xall :	$(GAME)
X      @ $(ECHO) "nethack is up to date."
X
X# linker options file for nethack's object modules
Xnethack.opt :	$(MAKEFILE)	# this file
X	open/Write f nethack.opt
X	write f "! nethack.opt"
X      @ write f f$edit("$(SYSOBJ)","COLLAPSE")
X      @ write f f$edit("$(WINOBJ)","COLLAPSE")
X      @ write f f$edit("$(RANDOBJ)","COLLAPSE")
X      @ write f f$edit("$(FIRSTOBJ)","COLLAPSE")
X      @ write f f$edit("$(HOBJ1)","COLLAPSE")
X      @ write f f$edit("$(HOBJ2)","COLLAPSE")
X      @ write f f$edit("$(HOBJ3)","COLLAPSE")
X      @ write f f$edit("$(HOBJ4)","COLLAPSE")
X      @ write f f$edit("$(HOBJ5)","COLLAPSE")
X      @ write f f$edit("$(HOBJ6)","COLLAPSE")
X      @ write f "iosegment=128"
X	write f "identification=$(VERSION).$(PATCHLVL)"
X	close f
X
X# linker options file for run-time libraries, also used by $(UTL)Makefile
X$(LIBOPT) :	$(MAKEFILE)	# this file
X	open/Write f $(LIBOPT)
X	write f "! crtl.opt"
X	write f "$(LIBS)"
X	write f "$(MORELIBS)"
X	close f
X# simplified target name, for interactive convenience
Xcrtl.opt :	$(LIBOPT)
X      @ $(NOOP)
X
X#	dependencies for makedefs and its outputs, which the util
X#	Makefile is responsible for keeping up to date
X#
X
X# special rules, to force update of makedefs, real dependencies should be
X# below in the 'make depend' output.
Xmonst.obj :
X	$(CC) $(CFLAGS) monst.c
X     @- if f$search("$(MAKEDEFS)").nes."" then delete $(MAKEDEFS)
X
Xobjects.obj :
X	$(CC) $(CFLAGS) objects.c
X     @- if f$search("$(MAKEDEFS)").nes."" then delete $(MAKEDEFS)
X
X$(MAKEDEFS) :	$(FIRSTOBJ) $(UTL)makedefs.c $(INC)patchlevel.h \
X		$(INC)config.h $(INC)artilist.h $(INC)qtext.h  $(LIBOPT)
X	$(CD) $(UTL)
X	$(MAKE)$(MAKEFLAGS) $(MAKEDEFS)
X      @ $(CD) $(SRC)
X$(INC)onames.h : $(MAKEDEFS)
X	$(CD) $(UTL)
X	$(MAKE)$(MAKEFLAGS) $(INC)onames.h
X      @ $(CD) $(SRC)
X$(INC)pm.h :	$(MAKEDEFS)
X	$(CD) $(UTL)
X	$(MAKE)$(MAKEFLAGS) $(INC)pm.h
X      @ $(CD) $(SRC)
Xmonstr.c : $(MAKEDEFS)
X	$(CD) $(UTL)
X	$(MAKE)$(MAKEFLAGS) $(SRC)monstr.c
X      @ $(CD) $(SRC)
X# both vis_tab.h and vis_tab.c are made at the same time by makedefs
X$(INC)vis_tab.h : vis_tab.c
X	$(TOUCH) $(INC)vis_tab.h
Xvis_tab.c : $(MAKEDEFS)
X	$(CD) $(UTL)
X	$(MAKE)$(MAKEFLAGS) $(SRC)vis_tab.c
X      @ $(CD) $(SRC)
X
X#	date.h should be remade any time any of the source or include code
X#	is modified.  Unfortunately, this would make the contents of this
X#	file far more complex.	Since "hack.h" depends on most of the include
X#	files, we kludge around this by making date.h dependent on hack.h,
X#	even though it doesn't include this file.
X#
X#	hack.h depends on makedefs' output, so we know makedefs will be
X#	up to date before being executed; kill old date.h to force update
X$(INC)date.h :	$(VERSOURCES) $(INC)hack.h
X     @- if f$search("$(INC)date.h").nes."" then  delete $(INC)date.h;*
X	$(CD) $(UTL)
X	$(MAKE)$(MAKEFLAGS) $(INC)date.h
X      @ $(CD) $(SRC)
X
X#
Xvmsmain.obj :	$(VMS)vmsmain.c $(INC)hack.h
Xvmstty.obj :	$(VMS)vmstty.c $(INC)hack.h $(INC)wintty.h $(INC)termcap.h
Xvmsunix.obj :	$(VMS)vmsunix.c $(INC)hack.h $(INC)date.h
Xvmsmisc.obj :	$(VMS)vmsmisc.c $(VMS)oldcrtl.c
Xvmsfiles.obj :	$(VMS)vmsfiles.c $(INC)config.h
Xvmsmail.obj :	$(VMS)vmsmail.c $(INC)config.h $(INC)winprocs.h $(INC)mail.h
Xgnutermcap.obj : $(VMS)gnutermcap.c
Xgnutparam.obj : $(VMS)gnutparam.c
X
Xrandom.c :
X	copy $(SHR)random.c random.c
X
X#
X#	The following are rules for window dependencies.  The ones used
X#	depend on wich window system you are using.
X#
Xgetline.obj :	$(TTY)getline.c $(INC)hack.h $(INC)wintty.h $(INC)func_tab.h
Xtermcap.obj :	$(TTY)termcap.c $(INC)hack.h $(INC)wintty.h $(INC)termcap.h
Xtopl.obj :	$(TTY)topl.c $(INC)hack.h $(INC)termcap.h $(INC)wintty.h
Xwintty.obj :	$(TTY)wintty.c $(INC)hack.h $(INC)termcap.h $(INC)wintty.h
XWindow.obj :	$(X11)Window.c $(INC)WindowP.h
Xdialogs.obj :	$(X11)dialogs.c $(INC)config.h
XwinX.obj :	$(X11)winX.c $(INC)hack.h $(INC)winX.h \
X		$(X11)nh72icon $(X11)nh56icon $(X11)nh32icon
Xwinmap.obj :	$(X11)winmap.c $(INC)Window.h $(INC)hack.h $(INC)winX.h
Xwinmenu.obj :	$(X11)winmenu.c $(INC)hack.h $(INC)winX.h
Xwinmesg.obj :	$(X11)winmesg.c $(INC)hack.h $(INC)winX.h
Xwinmisc.obj :	$(X11)winmisc.c $(INC)hack.h $(INC)func_tab.h $(INC)winX.h
Xwinstat.obj :	$(X11)winstat.c $(INC)hack.h $(INC)winX.h
Xwintext.obj :	$(X11)wintext.c $(INC)hack.h $(INC)winX.h
Xwinval.obj :	$(X11)winval.c $(INC)config.h
X
X
Xclean :
X      - if f$search("*.*;-1")	  .nes."" then	purge
X      - if f$search("*.obj")	  .nes."" then	delete *.obj;
X      - if f$search("nethack.opt").nes."" then	delete nethack.opt;
X
Xspotless :	clean
X      - if f$search("$(LIBOPT)").nes."" then  delete $(LIBOPT)
X      - if f$search("$(SYSTEM)").nes."" then  delete $(SYSTEM)
X      - if f$search("$(GAME)")	.nes."" then  delete $(GAME)
X      - delete monstr.c;,vis_tab.c;,$(INC)vis_tab.h;,\
X $(INC)pm.h;,$(INC)onames.h;,$(INC)date.h;
X      - if f$search("random.c").nes."" then	delete random.c;
X      - if f$search("nethack.olb").nes."" then	delete nethack.olb;
X
X
X# semi-automatically generated dependencies
X
Xallmain.obj :	$(INC)hack.h
Xalloc.obj :	$(INC)config.h
Xapply.obj :	$(INC)hack.h $(INC)edog.h
Xartifact.obj :	$(INC)hack.h $(INC)artifact.h $(INC)artilist.h
Xattrib.obj :	$(INC)hack.h $(INC)artifact.h
Xball.obj :	$(INC)hack.h
Xbones.obj :	$(INC)hack.h $(INC)lev.h
Xbotl.obj :	$(INC)hack.h
Xcmd.obj :	$(INC)hack.h $(INC)func_tab.h
Xdbridge.obj :	$(INC)hack.h
Xdecl.obj :	$(INC)hack.h $(INC)quest.h
Xdetect.obj :	$(INC)hack.h $(INC)artifact.h
Xdisplay.obj :	$(INC)hack.h
Xdo.obj :	$(INC)hack.h $(INC)lev.h
Xdo_name.obj :	$(INC)hack.h
Xdo_wear.obj :	$(INC)hack.h
Xdog.obj :	$(INC)hack.h $(INC)edog.h
Xdogmove.obj :	$(INC)hack.h $(INC)mfndpos.h $(INC)edog.h
Xdokick.obj :	$(INC)hack.h $(INC)eshk.h
Xdothrow.obj :	$(INC)hack.h
Xdrawing.obj :	$(INC)hack.h $(INC)termcap.h
Xdungeon.obj :	$(INC)hack.h $(INC)dgn_file.h
Xeat.obj :	$(INC)hack.h
Xend.obj :	$(INC)hack.h $(INC)eshk.h
Xengrave.obj :	$(INC)hack.h $(INC)lev.h
Xexper.obj :	$(INC)hack.h
Xexplode.obj :	$(INC)hack.h
Xextralev.obj :	$(INC)hack.h
Xfiles.obj :	$(INC)hack.h
Xfountain.obj :	$(INC)hack.h
Xhack.obj :	$(INC)hack.h
Xhacklib.obj :	$(INC)hack.h
Xinvent.obj :	$(INC)hack.h $(INC)artifact.h
Xlock.obj :	$(INC)hack.h
Xmail.obj :	$(INC)hack.h $(INC)mail.h
Xmakemon.obj :	$(INC)hack.h $(INC)epri.h $(INC)emin.h
Xmcastu.obj :	$(INC)hack.h
Xmhitm.obj :	$(INC)hack.h $(INC)artifact.h $(INC)edog.h
Xmhitu.obj :	$(INC)hack.h $(INC)artifact.h $(INC)edog.h
Xminion.obj :	$(INC)hack.h $(INC)emin.h $(INC)epri.h
Xmklev.obj :	$(INC)hack.h
Xmkmap.obj :	$(INC)hack.h $(INC)sp_lev.h
Xmkmaze.obj :	$(INC)hack.h $(INC)sp_lev.h
Xmkobj.obj :	$(INC)hack.h $(INC)artifact.h $(INC)prop.h
Xmkroom.obj :	$(INC)hack.h
Xmon.obj :	$(INC)hack.h $(INC)mfndpos.h $(INC)edog.h
Xmondata.obj :	$(INC)hack.h $(INC)eshk.h $(INC)epri.h
Xmonmove.obj :	$(INC)hack.h $(INC)mfndpos.h $(INC)artifact.h
Xmonst.obj :	$(INC)config.h $(INC)permonst.h $(INC)monsym.h $(INC)eshk.h \
X		$(INC)vault.h $(INC)epri.h $(INC)color.h
Xmplayer.obj :	$(INC)hack.h
Xmthrowu.obj :	$(INC)hack.h
Xmuse.obj :	$(INC)hack.h
Xmusic.obj :	$(INC)hack.h
Xo_init.obj :	$(INC)hack.h
Xobjects.obj :	$(INC)config.h $(INC)obj.h $(INC)objclass.h $(INC)prop.h \
X		$(INC)color.h objects.c
Xobjnam.obj :	$(INC)hack.h
Xoptions.obj :	$(INC)hack.h $(INC)termcap.h
Xpager.obj :	$(INC)hack.h
Xpickup.obj :	$(INC)hack.h
Xpline.obj :	$(INC)hack.h $(INC)epri.h
Xpolyself.obj :	$(INC)hack.h
Xpotion.obj :	$(INC)hack.h
Xpray.obj :	$(INC)hack.h $(INC)epri.h
Xpriest.obj :	$(INC)hack.h $(INC)mfndpos.h $(INC)eshk.h $(INC)epri.h $(INC)emin.h
Xquest.obj :	$(INC)hack.h $(INC)quest.h $(INC)qtext.h
Xquestpgr.obj :	$(INC)hack.h $(INC)qtext.h
Xread.obj :	$(INC)hack.h
Xrect.obj :	$(INC)hack.h
Xrestore.obj :	$(INC)hack.h $(INC)lev.h $(INC)termcap.h $(INC)quest.h
Xrip.obj :	$(INC)hack.h
Xrnd.obj :	$(INC)hack.h
Xrumors.obj :	$(INC)hack.h
Xsave.obj :	$(INC)hack.h $(INC)lev.h $(INC)quest.h
Xshk.obj :	$(INC)hack.h $(INC)eshk.h
Xshknam.obj :	$(INC)hack.h $(INC)eshk.h
Xsit.obj :	$(INC)hack.h $(INC)artifact.h
Xsounds.obj :	$(INC)hack.h $(INC)edog.h $(INC)eshk.h
Xsp_lev.obj :	$(INC)hack.h $(INC)sp_lev.h $(INC)rect.h
Xspell.obj :	$(INC)hack.h
Xsteal.obj :	$(INC)hack.h
Xtimeout.obj :	$(INC)hack.h
Xtopten.obj :	$(INC)hack.h
Xtrack.obj :	$(INC)hack.h
Xtrap.obj :	$(INC)hack.h
Xu_init.obj :	$(INC)hack.h
Xuhitm.obj :	$(INC)hack.h
Xvault.obj :	$(INC)hack.h $(INC)vault.h
Xversion.obj :	$(INC)hack.h $(INC)date.h  $(INC)patchlevel.h
Xvision.obj :	$(INC)hack.h $(INC)vis_tab.h
Xweapon.obj :	$(INC)hack.h
Xwere.obj :	$(INC)hack.h
Xwield.obj :	$(INC)hack.h
Xwindows.obj :	$(INC)hack.h $(INC)wintty.h
Xwizard.obj :	$(INC)hack.h $(INC)qtext.h
Xworm.obj :	$(INC)hack.h $(INC)lev.h
Xworn.obj :	$(INC)hack.h
Xwrite.obj :	$(INC)hack.h
Xzap.obj :	$(INC)hack.h
X$(INC)amiconf.h :  $(INC)micro.h $(INC)pcconf.h
X			$(TOUCH) $(INC)amiconf.h
X$(INC)config.h :  $(INC)tradstdc.h $(INC)global.h
X			$(TOUCH) $(INC)config.h
X$(INC)decl.h :	$(INC)quest.h $(INC)spell.h $(INC)color.h $(INC)obj.h \
X		$(INC)you.h $(INC)onames.h $(INC)pm.h
X			$(TOUCH) $(INC)decl.h
X$(INC)display.h :  $(INC)vision.h $(INC)mondata.h
X			$(TOUCH) $(INC)display.h
X$(INC)dungeon.h :  $(INC)align.h
X			$(TOUCH) $(INC)dungeon.h
X$(INC)emin.h :	$(INC)dungeon.h
X			$(TOUCH) $(INC)emin.h
X$(INC)epri.h :	$(INC)dungeon.h $(INC)align.h
X			$(TOUCH) $(INC)epri.h
X$(INC)eshk.h :	$(INC)dungeon.h
X			$(TOUCH) $(INC)eshk.h
X# ignore the non-VMS configuration headers
X#$(INC)global.h :  $(INC)coord.h $(INC)vmsconf.h $(INC)unixconf.h $(INC)os2conf.h \
X#		   $(INC)pcconf.h $(INC)tosconf.h $(INC)amiconf.h $(INC)macconf.h
X$(INC)global.h :  $(INC)coord.h $(INC)vmsconf.h
X			$(TOUCH) $(INC)global.h
X$(INC)hack.h :	$(INC)config.h $(INC)dungeon.h $(INC)monsym.h $(INC)mkroom.h \
X		$(INC)objclass.h $(INC)decl.h $(INC)trap.h $(INC)flag.h \
X		$(INC)rm.h $(INC)vision.h $(INC)display.h $(INC)wintype.h \
X		$(INC)engrave.h $(INC)rect.h $(INC)winprocs.h $(INC)wintty.h \
X		$(INC)trampoli.h
X			$(TOUCH) $(INC)hack.h
X$(INC)macconf.h :  $(INC)system.h
X			$(TOUCH) $(INC)macconf.h
X$(INC)mondata.h :  $(INC)align.h
X			$(TOUCH) $(INC)mondata.h
X$(INC)monst.h :  $(INC)align.h
X			$(TOUCH) $(INC)monst.h
X$(INC)os2conf.h :  $(INC)pcconf.h
X			$(TOUCH) $(INC)os2conf.h
X$(INC)pcconf.h :  $(INC)micro.h $(INC)system.h
X			$(TOUCH) $(INC)pcconf.h
X$(INC)permonst.h :  $(INC)monattk.h $(INC)monflag.h $(INC)align.h
X			$(TOUCH) $(INC)permonst.h
X$(INC)rm.h :  $(INC)align.h
X			$(TOUCH) $(INC)rm.h
X$(INC)sp_lev.h :  $(INC)align.h
X			$(TOUCH) $(INC)sp_lev.h
X$(INC)tosconf.h :  $(INC)micro.h $(INC)pcconf.h
X			$(TOUCH) $(INC)tosconf.h
X$(INC)unixconf.h :  $(INC)system.h
X			$(TOUCH) $(INC)unixconf.h
X$(INC)vault.h :  $(INC)dungeon.h
X			$(TOUCH) $(INC)vault.h
X$(INC)vmsconf.h :  $(INC)system.h
X			$(TOUCH) $(INC)vmsconf.h
X$(INC)you.h :  $(INC)align.h $(INC)attrib.h $(INC)monst.h $(INC)youprop.h
X			$(TOUCH) $(INC)you.h
X$(INC)youprop.h :  $(INC)prop.h $(INC)permonst.h $(INC)mondata.h $(INC)pm.h
X			$(TOUCH) $(INC)youprop.h
X# eof
END_OF_FILE
if test 17335 -ne `wc -c <'sys/vms/Makefile.src'`; then
    echo shar: \"'sys/vms/Makefile.src'\" unpacked with wrong size!
fi
# end of 'sys/vms/Makefile.src'
fi
echo shar: End of archive 48 \(of 108\).
cp /dev/null ark48isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \
21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \
41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 \
61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 \
81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 \
101 102 103 104 105 106 107 108 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 108 archives.
    echo "Now execute 'rebuild.sh'"
    rm -f ark10[0-8]isdone ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
