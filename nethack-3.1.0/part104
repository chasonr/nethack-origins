Path: uunet!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v16i112:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Part104/108
Message-ID: <4477@master.CNA.TEK.COM>
Date: 5 Feb 93 22:03:55 GMT
Sender: news@master.CNA.TEK.COM
Lines: 2041
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1663

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 16, Issue 112
Archive-name: nethack31/Part104
Supersedes: nethack3p9: Volume 10, Issue 46-108
Environment: Amiga, Atari, Mac, MS-DOS, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 104 (of 108)."
# Contents:  include/def_os2.h include/hack.h include/mkroom.h
#   include/monattk.h include/monsym.h include/sp_lev.h
#   include/winprocs.h rebuild.sh sys/mac/MacHelp sys/mac/mmodal.c
#   sys/vms/Makefile.top util/dgn_comp.l win/X11/nh72icon
# Wrapped by billr@saab on Wed Jan 27 16:09:32 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'include/def_os2.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/def_os2.h'\"
else
echo shar: Extracting \"'include/def_os2.h'\" \(4248 characters\)
sed "s/^X//" >'include/def_os2.h' <<'END_OF_FILE'
X/*	SCCS Id: @(#)def_os2.h	3.1	93/01/19	*/
X/*	Copyright (c) Timo Hakulinen, 1990, 1991, 1992, 1993. */
X/*	NetHack may be freely redistributed.  See license for details. */
X
X/*
X *	Only a small portion of all OS/2 defines are needed, so the
X *	actual include files often need not be used.  In fact,
X *	including the full headers may stall the compile in DOS.
X */
X
X#ifdef OS2_USESYSHEADERS
X
X# define INCL_NOPMAPI
X# define INCL_DOSFILEMGR
X# define INCL_DOS
X# define INCL_SUB
X
X# include <os2.h>
X
X#else
X
Xtypedef char CHAR;
Xtypedef void VOID;
X
Xtypedef unsigned char UCHAR;
Xtypedef unsigned short USHORT;
Xtypedef unsigned int UINT;
Xtypedef unsigned long ULONG;
Xtypedef unsigned char BYTE;
X
X# ifdef OS2_32BITAPI
X
Xtypedef unsigned long SHANDLE;
Xtypedef USHORT HKBD;
Xtypedef USHORT HVIO;
X
X#  define CCHMAXPATHCOMP 256
X
X#  ifdef OS2_CSET2
X#   define API16 _Far16 _Pascal
X#   define DAT16
X#   define API32 _System
X#   define KbdGetStatus KBD16GETSTATUS
X#   define KbdSetStatus KBD16SETSTATUS
X#   define KbdCharIn    KBD16CHARIN
X#   define KbdPeek      KBD16PEEK
X#   define VioGetMode   VIO16GETMODE
X#   define VioSetCurPos VIO16SETCURPOS
X#  else
X#   define API16
X#   define DAT16
X#   define API32
X#  endif
X
X#  define DAT
X
X# else /* OS2_32BITAPI */
X
Xtypedef unsigned short SHANDLE;
Xtypedef SHANDLE HKBD;
Xtypedef SHANDLE HVIO;
X
X#  define CCHMAXPATHCOMP 13
X
X#  ifdef OS2_MSC
X#   define API16 pascal far
X#   define DAT16
X#  endif
X
X#  define DAT DAT16
X
X# endif /* OS2_32BITAPI */
X
Xtypedef USHORT * DAT16 PUSHORT;
Xtypedef BYTE * DAT16 PBYTE;
Xtypedef ULONG * DAT PULONG;
Xtypedef VOID * DAT PVOID;
X
Xtypedef SHANDLE HDIR;
Xtypedef HDIR * DAT PHDIR;
X
Xtypedef char * DAT16 PCH;
Xtypedef char * DAT PSZ;
X
X/* all supported compilers understand this */
X
X# pragma pack(2)
X
Xtypedef struct {
X	UCHAR  chChar;
X	UCHAR  chScan;
X	UCHAR  fbStatus;
X	UCHAR  bNlsShift;
X	USHORT fsState;
X	ULONG  time;
X} KBDKEYINFO;
X
Xtypedef KBDKEYINFO * DAT16 PKBDKEYINFO;
X
X/* File time and date types */
X
Xtypedef struct {
X	UINT twosecs : 5;
X	UINT minutes : 6;
X	UINT hours   : 5;
X} FTIME;
X
Xtypedef struct {
X	UINT day     : 5;
X	UINT month   : 4;
X	UINT year    : 7;
X} FDATE;
X
X# ifdef OS2_32BITAPI
X
Xtypedef struct {
X	ULONG oNextEntryOffset;
X	FDATE fdateCreation;
X	FTIME ftimeCreation;
X	FDATE fdateLastAccess;
X	FTIME ftimeLastAccess;
X	FDATE fdateLastWrite;
X	FTIME ftimeLastWrite;
X	ULONG cbFile;
X	ULONG cbFileAlloc;
X	ULONG attrFile;
X	UCHAR cchName;
X	CHAR  achName[CCHMAXPATHCOMP];
X} FILEFINDBUF3;
X
X# else
X
Xtypedef struct {
X	FDATE  fdateCreation;
X	FTIME  ftimeCreation;
X	FDATE  fdateLastAccess;
X	FTIME  ftimeLastAccess;
X	FDATE  fdateLastWrite;
X	FTIME  ftimeLastWrite;
X	ULONG  cbFile;
X	ULONG  cbFileAlloc;
X	USHORT attrFile;
X	UCHAR  cchName;
X	CHAR   achName[CCHMAXPATHCOMP];
X} FILEFINDBUF;
X
Xtypedef FILEFINDBUF * DAT16 PFILEFINDBUF;
X
X# endif /* OS2_32BITAPI */
X
Xtypedef struct {
X	ULONG  idFileSystem;
X	ULONG  cSectorUnit;
X	ULONG  cUnit;
X	ULONG  cUnitAvail;
X	USHORT cbSector;
X} FSALLOCATE;
X
Xtypedef struct {
X	USHORT cb;
X	USHORT fsMask;
X	USHORT chTurnAround;
X	USHORT fsInterim;
X	USHORT fsState;
X} KBDINFO;
X
Xtypedef KBDINFO * DAT16 PKBDINFO;
X
Xtypedef struct {
X	USHORT cb;
X	UCHAR  fbType;
X	UCHAR  color;
X	USHORT col;
X	USHORT row;
X	USHORT hres;
X	USHORT vres;
X	UCHAR  fmt_ID;
X	UCHAR  attrib;
X	ULONG  buf_addr;
X	ULONG  buf_length;
X	ULONG  full_length;
X	ULONG  partial_length;
X	PCH    ext_data_addr;
X} VIOMODEINFO;
X
Xtypedef VIOMODEINFO * DAT16 PVIOMODEINFO;
X
X# pragma pack()
X
X/* OS2 API functions */
X
XUSHORT API16 KbdGetStatus(PKBDINFO, HKBD);
XUSHORT API16 KbdSetStatus(PKBDINFO, HKBD);
XUSHORT API16 KbdCharIn(PKBDKEYINFO, USHORT, HKBD);
XUSHORT API16 KbdPeek(PKBDKEYINFO, HKBD);
X
XUSHORT API16 VioGetMode(PVIOMODEINFO, HVIO);
XUSHORT API16 VioSetCurPos(USHORT, USHORT, HVIO);
X
X# ifdef OS2_32BITAPI
XULONG API32 DosQueryFSInfo(ULONG, ULONG, PVOID, ULONG);
XULONG API32 DosFindFirst(PSZ, PHDIR, ULONG, PVOID, ULONG, PULONG, ULONG);
XULONG API32 DosFindNext(HDIR, PVOID, ULONG, PULONG);
XULONG API32 DosSetDefaultDisk(ULONG);
X# else
XUSHORT API16 DosQFSInfo(USHORT, USHORT, PBYTE, USHORT);
XUSHORT API16 DosFindFirst(PSZ, PHDIR, USHORT, PFILEFINDBUF, USHORT, PUSHORT, ULONG);
XUSHORT API16 DosFindNext(HDIR, PFILEFINDBUF, USHORT, PUSHORT);
XUSHORT API16 DosSelectDisk(USHORT);
X# endif /* OS2_32BITAPI */
X
X#endif /* OS2_USESYSHEADERS */
END_OF_FILE
if test 4248 -ne `wc -c <'include/def_os2.h'`; then
    echo shar: \"'include/def_os2.h'\" unpacked with wrong size!
fi
# end of 'include/def_os2.h'
fi
if test -f 'include/hack.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/hack.h'\"
else
echo shar: Extracting \"'include/hack.h'\" \(4264 characters\)
sed "s/^X//" >'include/hack.h' <<'END_OF_FILE'
X/*	SCCS Id: @(#)hack.h	3.1	93/01/15	*/
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#ifndef HACK_H
X#define HACK_H
X
X#ifndef CONFIG_H
X#include "config.h"
X#endif
X
X/*	For debugging beta code.	*/
X#ifdef BETA
X#define Dpline	pline
X#endif
X
X#define TELL		1
X#define NOTELL		0
X#define ON		1
X#define OFF		0
X#define BOLT_LIM    8	/* from this distance ranged attacks will be made */
X#define MAX_CARR_CAP	1000	/* so that boulders can be heavier */
X#ifndef __SASC_60
X#ifdef NULL
X#undef NULL
X#endif /* NULL */
X#define NULL  ((char *)0)
X#endif
X#define DUMMY { 0 }
X
X/* symbolic names for capacity levels */
X#define UNENCUMBERED	0
X#define SLT_ENCUMBER	1
X#define MOD_ENCUMBER	2
X#define HVY_ENCUMBER	3
X#define EXT_ENCUMBER	4
X#define OVERLOADED	5
X
X/* this is the way the game ends */
X/* if these are rearranged, the arrays in end.c will need to be changed */
X#define DIED		 0
X#define CHOKING		 1
X#define POISONING	 2
X#define STARVING	 3
X#define DROWNING	 4
X#define BURNING		 5
X#define CRUSHING	 6
X#define STONING		 7
X#define GENOCIDED	 8
X#define PANICKED	 9
X#define TRICKED		10
X#define QUIT		11
X#define ESCAPED		12
X#define ASCENDED	13
X
X#ifndef DUNGEON_H	/* includes align.h */
X#include "dungeon.h"
X#endif
X
X#ifndef MONSYM_H
X#include "monsym.h"
X#endif
X#ifndef MKROOM_H
X#include "mkroom.h"
X#endif
X#ifndef OBJCLASS_H
X#include "objclass.h"
X#endif
X
X#ifndef DECL_H
X#include "decl.h"
X#endif
X
Xextern coord bhitpos;	/* place where thrown weapon falls to the ground */
X
X/* types of calls to bhit() */
X#define ZAPPED_WAND	0
X#define THROWN_WEAPON	1
X#define KICKED_WEAPON	2
X#define FLASHED_LIGHT	3
X#define INVIS_BEAM	4
X
X#ifndef TRAP_H
X#include "trap.h"
X#endif
X#ifndef FLAG_H
X#include "flag.h"
X#endif
X
X#ifndef RM_H
X#include "rm.h"
X#endif
X
X#ifndef VISION_H
X#include "vision.h"
X#endif
X
X#ifndef DISPLAY_H
X#include  "display.h"
X#endif
X
X#ifndef WINTYPE_H
X#include  "wintype.h"
X#endif
X
X#ifndef ENGRAVE_H
X#include "engrave.h"
X#endif
X
X#ifndef RECT_H
X#include "rect.h"
X#endif
X
X#ifdef OVERLAY	/* This doesn't belong here, but we have little choice */
X#undef NDECL
X#define NDECL(f) f()
X#endif
X
X#ifndef EXTERN_H
X#include "extern.h"
X#endif
X
X#ifndef WINPROCS_H
X#include "winprocs.h"
X#endif
X
X#if defined(OVERLAY) && !defined(MOVERLAY)
X#include "wintty.h"
X#undef WINTTY_H
X
X#ifndef TRAMPOLI_H
X#include "trampoli.h"
X#endif
X
X#undef EXTERN_H
X#include "extern.h"
X#endif /* OVERLAY */
X
X#define NO_SPELL	0
X
X/*** some utility macros ***/
X#define yn(query) yn_function(query,ynchars, 'n')
X#define ynq(query) yn_function(query,ynqchars, 'q')
X#define ynaq(query) yn_function(query,ynaqchars, 'y')
X#define nyaq(query) yn_function(query,ynaqchars, 'n')
X#define nyNaq(query) yn_function(query,ynNaqchars, 'n')
X#define ynNaq(query) yn_function(query,ynNaqchars, 'y')
X
X#ifndef max
X#define max(a,b) ((a) > (b) ? (a) : (b))
X#endif
X#ifndef min
X#define min(x,y) ((x) < (y) ? (x) : (y))
X#endif
X#define plur(x)	(((x) == 1) ? "" : "s")
X
X#define ARM_BONUS(obj)	(objects[(obj)->otyp].a_ac + (obj)->spe \
X			 - min((int)(obj)->oeroded,objects[(obj)->otyp].a_ac))
X
X#define makeknown(x)	discover_object((x),TRUE)
X#define distu(xx,yy)	dist2((int)(xx),(int)(yy),(int)u.ux,(int)u.uy)
X#define onlineu(xx,yy)	online2((int)(xx),(int)(yy),(int)u.ux,(int)u.uy)
X
X#define rn1(x,y)	(rn2(x)+(y))
X
X#ifndef MUSE
X#define find_mac(m)	((m)->data->ac)
X#endif
X
X#if defined(MICRO)
X#define getuid() 1
X#define getlogin() (NULL)
X#endif /* MICRO */
X
X/* Macro for a few items that are only static if we're not overlaid.... */
X#if defined(OVERLAY)
X# define STATIC_PTR
X#else
X# define STATIC_PTR static
X#endif
X
X#if defined(OVERLAY)&&(defined(OVL0)||defined(OVL1)||defined(OVL2)||defined(OVL3)||defined(OVLB))
X# define STATIC_DCL extern
X# define STATIC_OVL
X# ifdef OVLB
X#  define STATIC_VAR
X# else
X#  define STATIC_VAR extern
X# endif
X
X#else	/* !OVERLAY || (!OVL0 && !OVL1 && !OVL2 && !OVL3 && !OVLB) */
X# define STATIC_DCL static
X# define STATIC_OVL static
X# define STATIC_VAR static
X
X/* If not compiling an overlay, compile everything. */
X# define OVL0	/* Highest priority */
X# define OVL1
X# define OVL2
X# define OVL3	/* Lowest specified priority */
X# define OVLB	/* The base overlay segment */
X#endif	/* OVERLAY && (OVL0 || OVL1 || OVL2 || OVL3 || OVLB) */
X
X#endif /* HACK_H */
END_OF_FILE
if test 4264 -ne `wc -c <'include/hack.h'`; then
    echo shar: \"'include/hack.h'\" unpacked with wrong size!
fi
# end of 'include/hack.h'
fi
if test -f 'include/mkroom.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/mkroom.h'\"
else
echo shar: Extracting \"'include/mkroom.h'\" \(3754 characters\)
sed "s/^X//" >'include/mkroom.h' <<'END_OF_FILE'
X/*	SCCS Id: @(#)mkroom.h	3.1	92/11/14	*/
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#ifndef MKROOM_H
X#define MKROOM_H
X
X/* mkroom.h - types and structures for room and shop initialization */
X
Xstruct mkroom {
X	schar lx,hx,ly,hy;	/* usually xchar, but hx may be -1 */
X	schar rtype;		/* Type of room (zoo, throne, etc...) */
X	schar rlit;		/* is the room lit ? */
X	schar doorct;		/* Door count */
X	schar fdoor;		/* Index for the first door of the room */
X	schar nsubrooms;	/* Number of subrooms */
X	boolean irregular;	/* true if room is non-rectangular */
X	struct mkroom *sbrooms[MAX_SUBROOMS];  /* Subrooms pointers */
X	struct monst *resident; /* priest/shopkeeper/guard for this room */
X};
X
Xstruct shclass {
X	const char *name;	/* name of the shop type */
X	char	symb;		/* this identifies the shop type */
X	int	prob;		/* the shop type probability in % */
X	schar	shdist;		/* object placement type */
X#define D_SCATTER	0	/* normal placement */
X#define D_SHOP		1	/* shop-like placement */
X#define D_TEMPLE	2	/* temple-like placement */
X	struct itp {
X	    int iprob;		/* probability of an item type */
X	    int itype;	/* item type: if >=0 a class, if < 0 a specific item */
X	} iprobs[5];
X	const char **shknms;	/* list of shopkeeper names for this type */
X};
X
Xextern struct mkroom rooms[(MAXNROFROOMS+1)*2];
Xextern struct mkroom* subrooms;
X/* the normal rooms on the current level are described in rooms[0..n] for
X * some n<MAXNROFROOMS
X * the vault, if any, is described by rooms[n+1]
X * the next rooms entry has hx -1 as a flag
X * there is at most one non-vault special room on a level
X */
X
Xextern struct mkroom *dnstairs_room, *upstairs_room, *sstairs_room;
X
Xextern coord doors[DOORMAX];
X
X/* values for rtype in the room definition structure */
X#define OROOM		 0	/* ordinary room */
X#define COURT		 2	/* contains a throne */
X#define SWAMP		 3	/* contains pools */
X#define VAULT		 4	/* contains piles of gold */
X#define BEEHIVE		 5	/* contains killer bees and royal jelly */
X#define MORGUE		 6	/* contains corpses, undead and ghosts */
X#define BARRACKS	 7	/* contains soldiers and their gear */
X#define ZOO		 8	/* floor covered with treasure and monsters */
X#define DELPHI		 9	/* contains Oracle and peripherals */
X#define TEMPLE		10	/* contains a shrine */
X#define SHOPBASE	11	/* everything above this is a shop */
X#define ARMORSHOP	12	/* specific shop defines for level compiler */
X#define SCROLLSHOP	13
X#define POTIONSHOP	14
X#define WEAPONSHOP	15
X#define FOODSHOP	16
X#define RINGSHOP	17
X#define WANDSHOP	18
X#define TOOLSHOP	19
X#define BOOKSHOP	20
X#define UNIQUESHOP	21	/* shops here & above not randomly gen'd. */
X#define CANDLESHOP	21
X#define MAXRTYPE	21	/* maximum valid room type */
X
X/* Special type for search_special() */
X#define ANY_TYPE	(-1)
X#define ANY_SHOP	(-2)
X
X#define NO_ROOM		0	/* indicates lack of room-occupancy */
X#define SHARED		1	/* indicates normal shared boundary */
X#define SHARED_PLUS	2	/* indicates shared boundary - extra adjacent-
X				 * square searching required */
X
X#define ROOMOFFSET	3	/*
X				 * (levl[x][y].roomno - ROOMOFFSET) gives
X				 * rooms[] index, for inside-squares and
X				 * non-shared boundaries.
X				 */
X
X#define IS_ROOM_PTR(x)		((x) >= rooms && (x) < rooms + MAXNROFROOMS)
X#define IS_ROOM_INDEX(x)	((x) >= 0 && (x) < MAXNROFROOMS)
X#define IS_SUBROOM_PTR(x)	((x) >= subrooms && \
X				 (x) < subrooms + MAXNROFROOMS)
X#define IS_SUBROOM_INDEX(x)	((x) > MAXNROFROOMS && (x) < (MAXNROFROOMS*2))
X#define ROOM_INDEX(x)		((x) - rooms)
X#define SUBROOM_INDEX(x)	((x) - subrooms)
X#define IS_LAST_ROOM_PTR(x)	(ROOM_INDEX(x) == nroom)
X#define IS_LAST_SUBROOM_PTR(x)	(!nsubroom || SUBROOM_INDEX(x) == nsubroom)
X
X#endif /* MKROOM_H */
END_OF_FILE
if test 3754 -ne `wc -c <'include/mkroom.h'`; then
    echo shar: \"'include/mkroom.h'\" unpacked with wrong size!
fi
# end of 'include/mkroom.h'
fi
if test -f 'include/monattk.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/monattk.h'\"
else
echo shar: Extracting \"'include/monattk.h'\" \(3739 characters\)
sed "s/^X//" >'include/monattk.h' <<'END_OF_FILE'
X/*	SCCS Id: @(#)monattk.h	3.1	90/22/02	*/
X/* NetHack may be freely redistributed.  See license for details. */
X/* Copyright 1988, M. Stephenson */
X
X#ifndef MONATTK_H
X#define MONATTK_H
X
X/*	Add new attack types below - ordering affects experience (exper.c).
X *	Attacks > AT_BUTT are worth extra experience.
X */
X#define AT_NONE		0		/* passive monster (ex. acid blob) */
X#define AT_CLAW		1		/* claw (punch, hit, etc.) */
X#define AT_BITE		2		/* bite */
X#define AT_KICK		3		/* kick */
X#define AT_BUTT		4		/* head butt (ex. a unicorn) */
X#define AT_TUCH		5		/* touches */
X#define AT_STNG		6		/* sting */
X#define AT_HUGS		7		/* crushing bearhug */
X#define AT_SPIT		10		/* spits substance - ranged */
X#define AT_ENGL		11		/* engulf (swallow or by a cloud) */
X#define AT_BREA		12		/* breath - ranged */
X#define AT_EXPL		13		/* explodes - proximity */
X#define AT_GAZE		14		/* gaze - ranged */
X#define AT_TENT		15		/* tentacles */
X
X#define AT_WEAP		254		/* uses weapon */
X#define AT_MAGC		255		/* uses magic spell(s) */
X
X/*	Add new damage types below.
X *
X *	Note that 1-10 correspond to the types of attack used in buzz().
X *	Please don't disturb the order unless you rewrite the buzz() code.
X */
X#define AD_PHYS		0		/* ordinary physical */
X#define AD_MAGM		1		/* magic missiles */
X#define AD_FIRE		2		/* fire damage */
X#define AD_COLD		3		/* frost damage */
X#define AD_SLEE		4		/* sleep ray */
X#define AD_DISN		5		/* disintegration (death ray) */
X#define AD_ELEC		6		/* shock damage */
X#define AD_DRST		7		/* drains str (poison) */
X#define AD_ACID		8		/* acid damage */
X#define AD_SPC1		9		/* for extension of buzz() */
X#define AD_SPC2		10		/* for extension of buzz() */
X#define AD_BLND		11		/* blinds (glowing eye) */
X#define AD_STUN		12		/* stuns */
X#define AD_SLOW		13		/* slows */
X#define AD_PLYS		14		/* paralyses */
X#define AD_DRLI		15		/* drains life levels (Vampire) */
X#define AD_DREN		16		/* drains magic energy */
X#define AD_LEGS		17		/* damages legs (xan) */
X#define AD_STON		18		/* petrifies (Medusa, Cockatrice) */
X#define AD_STCK		19		/* sticks to you (Mimic) */
X#define AD_SGLD		20		/* steals gold (Leppie) */
X#define AD_SITM		21		/* steals item (Nymphs) */
X#define AD_SEDU		22		/* seduces & steals multiple items */
X#define AD_TLPT		23		/* teleports you (Quantum Mech.) */
X#define AD_RUST		24		/* rusts armour (Rust Monster)*/
X#define AD_CONF		25		/* confuses (Umber Hulk) */
X#define AD_DGST		26		/* digests opponent (trapper, etc.) */
X#define AD_HEAL		27		/* heals opponent's wounds (nurse) */
X#define AD_WRAP		28		/* special "stick" for eels */
X#define AD_WERE		29		/* confers lycanthropy */
X#define AD_DRDX		30		/* drains dexterity (Quasit) */
X#define AD_DRCO		31		/* drains constitution */
X#define AD_DRIN		32		/* drains intelligence (mind flayer) */
X#define AD_DISE		33		/* confers diseases */
X#define AD_DCAY		34		/* decays organics (Brown pudding) */
X#define AD_SSEX		35		/* Succubus seduction (extended) */
X					/* If no SEDUCE then same as AD_SEDU */
X#define AD_DETH		36		/* for Death only */
X#define AD_PEST		37		/* for Pestilence only */
X#define AD_FAMN		38		/* for Famine only */
X
X#define AD_CLRC		240		/* random clerical spell */
X#define AD_SPEL		241		/* random magic spell */
X#define AD_RBRE		242		/* random breath weapon */
X
X#define AD_SAMU		252		/* hits, may steal Amulet (Wizard) */
X#define AD_CURS		253		/* random curse (ex. gremlin) */
X
X
X/*
X *  Monster to monster attacks.  When a monster attacks another (mattackm),
X *  any or all of the following can be returned.  See mattackm() for more
X *  details.
X */
X#define MM_MISS		0x0	/* aggressor missed */
X#define MM_HIT		0x1	/* aggressor hit defender */
X#define MM_DEF_DIED	0x2	/* defender died */
X#define MM_AGR_DIED	0x4	/* aggressor died */
X
X#endif /* MONATTK_H */
END_OF_FILE
if test 3739 -ne `wc -c <'include/monattk.h'`; then
    echo shar: \"'include/monattk.h'\" unpacked with wrong size!
fi
# end of 'include/monattk.h'
fi
if test -f 'include/monsym.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/monsym.h'\"
else
echo shar: Extracting \"'include/monsym.h'\" \(3968 characters\)
sed "s/^X//" >'include/monsym.h' <<'END_OF_FILE'
X/*	SCCS Id: @(#)monsym.h	3.1	92/10/18	*/
X/*	Monster symbols and creation information rev 1.0	  */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#ifndef MONSYM_H
X#define MONSYM_H
X
X/*
X * Monster classes.  Below, are the corresponding default characters for
X * them.  Monster class 0 is not used or defined so we can use it as a
X * NULL character.
X */
X#define S_ANT		1
X#define S_BLOB		2
X#define S_COCKATRICE	3
X#define S_DOG		4
X#define S_EYE		5
X#define S_FELINE	6
X#define S_GREMLIN	7
X#define S_HUMANOID	8
X#define S_IMP		9
X#define S_JELLY		10
X#define S_KOBOLD	11
X#define S_LEPRECHAUN	12
X#define S_MIMIC		13
X#define S_NYMPH		14
X#define S_ORC		15
X#define S_PIERCER	16
X#define S_QUADRUPED	17
X#define S_RODENT	18
X#define S_SPIDER	19
X#define S_TRAPPER	20
X#define S_UNICORN	21
X#define S_VORTEX	22
X#define S_WORM		23
X#define S_XAN		24
X#define S_LIGHT		25
X#define S_ZRUTY		26
X#define S_ANGEL		27
X#define S_BAT		28
X#define S_CENTAUR	29
X#define S_DRAGON	30
X#define S_ELEMENTAL	31
X#define S_FUNGUS	32
X#define S_GNOME		33
X#define S_GIANT		34
X#define S_STALKER	35
X#define S_JABBERWOCK	36
X#define S_KOP		37
X#define S_LICH		38
X#define S_MUMMY		39
X#define S_NAGA		40
X#define S_OGRE		41
X#define S_PUDDING	42
X#define S_QUANTMECH	43
X#define S_RUSTMONST	44
X#define S_SNAKE		45
X#define S_TROLL		46
X#define S_UMBER		47
X#define S_VAMPIRE	48
X#define S_WRAITH	49
X#define S_XORN		50
X#define S_YETI		51
X#define S_ZOMBIE	52
X#define S_HUMAN		53
X#define S_GHOST		54
X#define S_GOLEM		55
X#define S_DEMON		56
X#define S_EEL		57
X#define S_LIZARD	58
X
X#define S_WORM_TAIL	59
X#define S_MIMIC_DEF	60
X
X#define MAXMCLASSES 61	/* number of monster classes */
X
X#if 0	/* moved to decl.h so that makedefs.c won't see them */
Xextern const char def_monsyms[MAXMCLASSES];	/* default class symbols */
Xextern uchar monsyms[MAXMCLASSES];		/* current class symbols */
X#endif
X
X/*
X * Default characters for monsters.  These correspond to the monster classes
X * above.
X */
X#define DEF_ANT		'a'
X#define DEF_BLOB	'b'
X#define DEF_COCKATRICE	'c'
X#define DEF_DOG		'd'
X#define DEF_EYE		'e'
X#define DEF_FELINE	'f'
X#define DEF_GREMLIN	'g'
X#define DEF_HUMANOID	'h'
X#define DEF_IMP		'i'
X#define DEF_JELLY	'j'
X#define DEF_KOBOLD	'k'
X#define DEF_LEPRECHAUN	'l'
X#define DEF_MIMIC	'm'
X#define DEF_NYMPH	'n'
X#define DEF_ORC		'o'
X#define DEF_PIERCER	'p'
X#define DEF_QUADRUPED	'q'
X#define DEF_RODENT	'r'
X#define DEF_SPIDER	's'
X#define DEF_TRAPPER	't'
X#define DEF_UNICORN	'u'
X#define DEF_VORTEX	'v'
X#define DEF_WORM	'w'
X#define DEF_XAN		'x'
X#define DEF_LIGHT	'y'
X#define DEF_ZRUTY	'z'
X#define DEF_ANGEL	'A'
X#define DEF_BAT		'B'
X#define DEF_CENTAUR	'C'
X#define DEF_DRAGON	'D'
X#define DEF_ELEMENTAL	'E'
X#define DEF_FUNGUS	'F'
X#define DEF_GNOME	'G'
X#define DEF_GIANT	'H'
X#define DEF_STALKER	'I'
X#define DEF_JABBERWOCK	'J'
X#define DEF_KOP		'K'
X#define DEF_LICH	'L'
X#define DEF_MUMMY	'M'
X#define DEF_NAGA	'N'
X#define DEF_OGRE	'O'
X#define DEF_PUDDING	'P'
X#define DEF_QUANTMECH	'Q'
X#define DEF_RUSTMONST	'R'
X#define DEF_SNAKE	'S'
X#define DEF_TROLL	'T'
X#define DEF_UMBER	'U'
X#define DEF_VAMPIRE	'V'
X#define DEF_WRAITH	'W'
X#define DEF_XORN	'X'
X#define DEF_YETI	'Y'
X#define DEF_ZOMBIE	'Z'
X#define DEF_HUMAN	'@'
X#define DEF_GHOST	' '
X#define DEF_GOLEM	'\''
X#define DEF_DEMON	'&'
X#define DEF_EEL		';'
X#define DEF_LIZARD	':'
X
X#define DEF_WORM_TAIL	'~'
X#define DEF_MIMIC_DEF	']'
X
X
X#define G_UNIQ		0x1000		/* generated only once */
X#define G_NOHELL	0x0800		/* not generated in "hell" */
X#define G_HELL		0x0400		/* generated only in "hell" */
X#define G_NOGEN		0x0200		/* generated only specially */
X#define G_NOCORPSE	0x0100		/* no corpse left ever */
X#define G_SGROUP	0x0080		/* appear in small groups normally */
X#define G_LGROUP	0x0040		/* appear in large groups normally */
X#define G_GENO		0x0020		/* can be genocided */
X#define G_GENOD		0x0010		/* have been genocided */
X#define G_EXTINCT	0x0008		/* have been extinguished as
X					   population control */
X#define G_FREQ		0x0007		/* creation frequency mask */
X
X#endif /* MONSYM_H */
END_OF_FILE
if test 3968 -ne `wc -c <'include/monsym.h'`; then
    echo shar: \"'include/monsym.h'\" unpacked with wrong size!
fi
# end of 'include/monsym.h'
fi
if test -f 'include/sp_lev.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/sp_lev.h'\"
else
echo shar: Extracting \"'include/sp_lev.h'\" \(3894 characters\)
sed "s/^X//" >'include/sp_lev.h' <<'END_OF_FILE'
X/*	SCCS Id: @(#)sp_lev.h	3.1	92/04/19	*/
X/* Copyright (c) 1989 by Jean-Christophe Collet			  */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#ifndef SP_LEV_H
X#define SP_LEV_H
X
X    /* wall directions */
X#define W_NORTH     1
X#define W_SOUTH     2
X#define W_EAST	    4
X#define W_WEST	    8
X#define W_ANY	    (W_NORTH|W_SOUTH|W_EAST|W_WEST)
X
X    /* MAP limits */
X#define MAP_X_LIM  76
X#define MAP_Y_LIM  21
X
X    /* Per level flags */
X#define NOTELEPORT   1
X#define HARDFLOOR    2
X#define NOMMAP	     4
X#define SHORTSIGHTED 8
X
X    /* special level types */
X#define SP_LEV_ROOMS	1
X#define SP_LEV_MAZE	2
X
X/*
X * Structures manipulated by the special levels loader & compiler
X */
X
Xtypedef struct {
X	boolean	init_present;
X	char	fg, bg;
X	boolean	smoothed, joined;
X	xchar   lit, walled;
X} lev_init;
X
Xtypedef struct {
X	xchar x, y, mask;
X} door;
X
Xtypedef struct {
X	xchar wall, pos, secret, mask;
X} room_door;
X
Xtypedef struct {
X	xchar x, y, type;
X} trap;
X
Xtypedef struct {
X	xchar x, y, class, appear;
X	schar peaceful, asleep;
X	aligntyp	align;
X	short id;
X	char  *name;
X	char  *appear_as;
X} monster;
X
Xtypedef struct {
X	xchar x, y, class;
X	xchar curse_state;
X	short id;
X	short spe;
X	int   corpsenm;
X	char  *name;
X} object;
X
X#include "align.h"
X
Xtypedef struct {
X	xchar		x, y;
X	aligntyp	align;
X	xchar		shrine;
X} altar;
X
Xtypedef struct {
X	xchar x, y, dir, db_open;
X} drawbridge;
X
Xtypedef struct {
X	xchar x, y, dir;
X} walk;
X
Xtypedef struct {
X	xchar x1, y1, x2, y2;
X} digpos;
X
Xtypedef struct {
X	xchar x, y, up;
X} lad;
X
Xtypedef struct {
X	xchar x, y, up;
X} stair;
X
Xtypedef struct {
X	xchar x1, y1, x2, y2;
X	xchar rtype, rlit, rirreg;
X} region;
X
X/* values for rtype are defined in dungeon.h */
Xtypedef struct {
X	struct { xchar x1, y1, x2, y2; } inarea;
X	struct { xchar x1, y1, x2, y2; } delarea;
X	boolean in_islev, del_islev;
X	xchar rtype;
X	char *rname;
X} lev_region;
X
Xtypedef struct {
X	xchar x, y;
X	int   amount;
X} gold;
X
Xtypedef struct {
X	xchar x, y;
X    union {
X	int length;
X	char  *text;
X    } e;
X	xchar etype;
X} engraving;
X
Xtypedef struct {
X	xchar x,y;
X} fountain;
X
Xtypedef struct {
X	xchar x,y;
X} sink;
X
Xtypedef struct {
X	xchar x,y;
X} pool;
X
Xtypedef struct {
X	char halign, valign;
X	char xsize, ysize;
X	char **map;
X	char nrobjects;
X	char *robjects;
X	char nloc;
X	char *rloc_x;
X	char *rloc_y;
X	char nrmonst;
X	char *rmonst;
X	char nreg;
X	region **regions;
X	char nlreg;
X	lev_region **lregions;
X	char ndoor;
X	door **doors;
X	char ntrap;
X	trap **traps;
X	char nmonster;
X	monster **monsters;
X	char nobject;
X	object **objects;
X	char ndrawbridge;
X	drawbridge **drawbridges;
X	char nwalk;
X	walk **walks;
X	char ndig;
X	digpos **digs;
X	char nlad;
X	lad **lads;
X	char nstair;
X	stair **stairs;
X	char naltar;
X	altar **altars;
X	char ngold;
X	gold **golds;
X	char nengraving;
X	engraving **engravings;
X	char nfountain;
X	fountain **fountains;
X} mazepart;
X
Xtypedef struct {
X	long flags;
X	lev_init init_lev;
X	short filling;
X	char numpart;
X	mazepart **parts;
X} specialmaze;
X
Xtypedef struct _room {
X	char  *name;
X	char  *parent;
X	xchar x, y, w, h;
X	xchar xalign, yalign;
X	xchar rtype, chance, rlit, filled;
X	char ndoor;
X	room_door **doors;
X	char ntrap;
X	trap **traps;
X	char nmonster;
X	monster **monsters;
X	char nobject;
X	object **objects;
X	char naltar;
X	altar **altars;
X	char nstair;
X	stair **stairs;
X	char ngold;
X	gold **golds;
X	char nengraving;
X	engraving **engravings;
X	char nfountain;
X	fountain **fountains;
X	char nsink;
X	sink **sinks;
X	char npool;
X	pool **pools;
X	/* These three fields are only used when loading the level... */
X	int nsubroom;
X	struct _room *subrooms[MAX_SUBROOMS];
X	struct mkroom *mkr;
X} room;
X
Xtypedef struct {
X	struct {
X		xchar room;
X		xchar wall;
X		xchar door;
X	} src, dest;
X} corridor;
X
Xtypedef struct {
X	long flags;
X	lev_init init_lev;
X	char nrobjects;
X	char *robjects;
X	char nrmonst;
X	char *rmonst;
X	xchar nroom;
X	room **rooms;
X	xchar ncorr;
X	corridor **corrs;
X} splev;
X
X#endif /* SP_LEV_H */
END_OF_FILE
if test 3894 -ne `wc -c <'include/sp_lev.h'`; then
    echo shar: \"'include/sp_lev.h'\" unpacked with wrong size!
fi
# end of 'include/sp_lev.h'
fi
if test -f 'include/winprocs.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/winprocs.h'\"
else
echo shar: Extracting \"'include/winprocs.h'\" \(4257 characters\)
sed "s/^X//" >'include/winprocs.h' <<'END_OF_FILE'
X/*	SCCS Id: @(#)winprocs.h	3.1	92/09/19	*/
X/* Copyright (c) David Cohrs, 1992				  */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#ifndef WINPROCS_H
X#define WINPROCS_H
X
Xstruct window_procs {
X    const char *name;
X    void NDECL((*win_init_nhwindows));
X    void NDECL((*win_player_selection));
X    void NDECL((*win_askname));
X    void NDECL((*win_get_nh_event)) ;
X    void FDECL((*win_exit_nhwindows), (const char *));
X    void FDECL((*win_suspend_nhwindows), (const char *));
X    void NDECL((*win_resume_nhwindows));
X    winid FDECL((*win_create_nhwindow), (int));
X    void FDECL((*win_clear_nhwindow), (winid));
X    void FDECL((*win_display_nhwindow), (winid, BOOLEAN_P));
X    void FDECL((*win_destroy_nhwindow), (winid));
X    void FDECL((*win_curs), (winid,int,int));
X    void FDECL((*win_putstr), (winid, int, const char *));
X    void FDECL((*win_display_file), (const char *, BOOLEAN_P));
X    void FDECL((*win_start_menu), (winid));
X    void FDECL((*win_add_menu), (winid, CHAR_P, int, const char *));
X    void FDECL((*win_end_menu), (winid, CHAR_P, const char *, const char *));
X    char FDECL((*win_select_menu), (winid));
X    void NDECL((*win_update_inventory));
X    void NDECL((*win_mark_synch));
X    void NDECL((*win_wait_synch));
X#ifdef CLIPPING
X    void FDECL((*win_cliparound), (int, int));
X#endif
X    void FDECL((*win_print_glyph), (winid,XCHAR_P,XCHAR_P,int));
X    void FDECL((*win_raw_print), (const char *));
X    void FDECL((*win_raw_print_bold), (const char *));
X    int NDECL((*win_nhgetch));
X    int FDECL((*win_nh_poskey), (int *, int *, int *));
X    void NDECL((*win_nhbell));
X    int NDECL((*win_doprev_message));
X    char FDECL((*win_yn_function), (const char *, const char *, CHAR_P));
X    void FDECL((*win_getlin), (const char *,char *));
X#ifdef COM_COMPL
X    void FDECL((*win_get_ext_cmd), (char *));
X#endif /* COM_COMPL */
X    void FDECL((*win_number_pad), (int));
X    void NDECL((*win_delay_output));
X
X    /* other defs that really should go away (they're tty specific) */
X    void NDECL((*win_start_screen));
X    void NDECL((*win_end_screen));
X};
X
Xextern struct window_procs NEARDATA windowprocs;
X
X/*
X * If you wish to only support one window system and not use procedure
X * pointers, add the appropriate #ifdef below.
X */
X
X#define init_nhwindows (*windowprocs.win_init_nhwindows)
X#define player_selection (*windowprocs.win_player_selection)
X#define askname (*windowprocs.win_askname)
X#define get_nh_event (*windowprocs.win_get_nh_event)
X#define exit_nhwindows (*windowprocs.win_exit_nhwindows)
X#define suspend_nhwindows (*windowprocs.win_suspend_nhwindows)
X#define resume_nhwindows (*windowprocs.win_resume_nhwindows)
X#define create_nhwindow (*windowprocs.win_create_nhwindow)
X#define clear_nhwindow (*windowprocs.win_clear_nhwindow)
X#define display_nhwindow (*windowprocs.win_display_nhwindow)
X#define destroy_nhwindow (*windowprocs.win_destroy_nhwindow)
X#define curs (*windowprocs.win_curs)
X#define putstr (*windowprocs.win_putstr)
X#define display_file (*windowprocs.win_display_file)
X#define start_menu (*windowprocs.win_start_menu)
X#define add_menu (*windowprocs.win_add_menu)
X#define end_menu (*windowprocs.win_end_menu)
X#define select_menu (*windowprocs.win_select_menu)
X#define update_inventory (*windowprocs.win_update_inventory)
X#define mark_synch (*windowprocs.win_mark_synch)
X#define wait_synch (*windowprocs.win_wait_synch)
X#ifdef CLIPPING
X#define cliparound (*windowprocs.win_cliparound)
X#endif
X#define print_glyph (*windowprocs.win_print_glyph)
X#define raw_print (*windowprocs.win_raw_print)
X#define raw_print_bold (*windowprocs.win_raw_print_bold)
X#define nhgetch (*windowprocs.win_nhgetch)
X#define nh_poskey (*windowprocs.win_nh_poskey)
X#define nhbell (*windowprocs.win_nhbell)
X#define nh_doprev_message (*windowprocs.win_doprev_message)
X#define yn_function (*windowprocs.win_yn_function)
X#define getlin (*windowprocs.win_getlin)
X#ifdef COM_COMPL
X#define get_ext_cmd (*windowprocs.win_get_ext_cmd)
X#endif
X#define number_pad (*windowprocs.win_number_pad)
X#define delay_output (*windowprocs.win_delay_output)
X
X/* other defs that really should go away (they're tty specific) */
X#define start_screen (*windowprocs.win_start_screen)
X#define end_screen (*windowprocs.win_end_screen)
X
X#endif
END_OF_FILE
if test 4257 -ne `wc -c <'include/winprocs.h'`; then
    echo shar: \"'include/winprocs.h'\" unpacked with wrong size!
fi
# end of 'include/winprocs.h'
fi
if test -f 'rebuild.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rebuild.sh'\"
else
echo shar: Extracting \"'rebuild.sh'\" \(2806 characters\)
sed "s/^X//" >'rebuild.sh' <<'END_OF_FILE'
X#!/bin/sh
X#
X# small sh script to concatenate the files that were split for posting
X#
XTOP=`pwd`
XDAT=$TOP/dat
XDOC=$TOP/doc
XSRC=$TOP/src
XAMIGA=$TOP/sys/amiga
XMAC=$TOP/sys/mac
XSHARE=$TOP/sys/share
X
X# dat
Xcd $DAT
Xcat quest.tx1 quest.tx2 > quest.txt
Xif test -f quest.txt
Xthen echo "'quest.txt' made"; rm quest.tx1 quest.tx2
Xelse echo "'quest.txt' not made - do cat by hand"
Xfi
Xcd $TOP
X
X# doc
Xcd $DOC
Xcat Guidebook.te1 Guidebook.te2 > Guidebook.tex
Xcat Guidebook.uu1 Guidebook.uu2 | uudecode
Xif test -f Guidebook.tex
Xthen echo "'Guidebook.tex' made"; rm Guidebook.te1 Guidebook.te2
Xelse echo "'Guidebook.tex' not made - do cat by hand"
Xfi
Xif test -f Guidebook.txt
Xthen echo "'Guidebook.txt' made"; rm Guidebook.uu1 Guidebook.uu2
Xelse echo "'Guidebook.txt' not made - do cat and uudecode by hand"
Xfi
Xcd $TOP
X
X# src
Xcd $SRC
Xcat mhitu.c1 mhitu.c2 > mhitu.c
Xcat monst.c1 monst.c2 monst.c3 > monst.c
Xcat shk.c1 shk.c2 > shk.c
Xcat sp_lev.c1 sp_lev.c2 > sp_lev.c
Xcat trap.c1 trap.c2 > trap.c
Xcat vision.c1 vision.c2 > vision.c
Xcat zap.c1 zap.c2 > zap.c
Xif test -f mhitu.c
Xthen echo "'mhitu.c' made"; rm mhitu.c1 mhitu.c2
Xelse echo "'mhitu.c' not made - do cat by hand"
Xfi
Xif test -f monst.c
Xthen echo "'monst.c' made"; rm monst.c1 monst.c2 monst.c3
Xelse echo "'monst.c' not made - do cat by hand"
Xfi
Xif test -f shk.c
Xthen echo "'shk.c' made"; rm shk.c1 shk.c2
Xelse echo "'shk.c' not made - do cat by hand"
Xfi
Xif test -f sp_lev.c
Xthen echo "'sp_lev.c' made"; rm sp_lev.c1 sp_lev.c2
Xelse echo "'sp_lev.c' not made - do cat by hand"
Xfi
Xif test -f trap.c
Xthen echo "'trap.c' made"; rm trap.c1 trap.c2
Xelse echo "'trap.c' not made - do cat by hand"
Xfi
Xif test -f vision.c
Xthen echo "'vision.c' made"; rm vision.c1 vision.c2
Xelse echo "'vision.c' not made - do cat by hand"
Xfi
Xif test -f zap.c
Xthen echo "'zap.c' made"; rm zap.c1 zap.c2
Xelse echo "'zap.c' not made - do cat by hand"
Xfi
Xcd $TOP
X
X# amiga
Xcd $AMIGA
Xcat wb.c1 wb.c2 > wb.c
Xcat winami.c1 winami.c2 > winami.c
Xif test -f wb.c
Xthen echo "'wb.c' made"; rm wb.c1 wb.c2
Xelse echo "'wb.c' not made - do cat by hand"
Xfi
Xif test -f winami.c
Xthen echo "'winami.c' made"; rm winami.c1 winami.c2
Xelse echo "'winami.c' not made - do cat by hand"
Xfi
Xcd $TOP
X
X# mac
Xcd $MAC
Xcat NHsound.hq1 NHsound.hq2 NHsound.hq3 NHsound.hq4 > NHsound.hqx
Xcat macwin.c1 macwin.c2 > macwin.c
Xif test -f NHsound.hqx
Xthen echo "'NHsound.hqx' made"; rm NHsound.hq1 NHsound.hq2 NHsound.hq3 NHsound.hq4
Xelse echo "'NHsound.hqx' not made - do cat by hand"
Xfi
Xif test -f macwin.c
Xthen echo "'macwin.c' made"; rm macwin.c1 macwin.c2
Xelse echo "'macwin.c' not made - do cat by hand"
Xfi
Xcd $TOP
X
X# share
Xcd $SHARE
Xcat lev_yacc.c1 lev_yacc.c2 > lev_yacc.c
Xif test -f lev_yacc.c
Xthen echo "'lev_yacc.c' made"; rm lev_yacc.c1 lev_yacc.c2
Xelse echo "'lev_yacc.c' not made - do cat by hand"
Xfi
Xcd $TOP
X
Xexit 0
END_OF_FILE
if test 2806 -ne `wc -c <'rebuild.sh'`; then
    echo shar: \"'rebuild.sh'\" unpacked with wrong size!
fi
chmod +x 'rebuild.sh'
# end of 'rebuild.sh'
fi
if test -f 'sys/mac/MacHelp' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/mac/MacHelp'\"
else
echo shar: Extracting \"'sys/mac/MacHelp'\" \(4355 characters\)
sed "s/^X//" >'sys/mac/MacHelp' <<'END_OF_FILE'
X            Macintosh-specific help file for NetHack 3.1
X
XThe following are options, features, or concerns specific to the
XMacintosh port of NetHack 3.1.  Bug reports, suggestions, comments,
Xand so on, should be addressed to:
X
XTo: nethack-bugs@linc.cis.upenn.edu
XSubject: Mac NetHack 3.1
X
XPlease include your machine-type, system software version and other
Xrelevant information (i.e. system extensions, monitor, accelerators
Xand so on).
X
X
X=== Configuration of a playground
X    NetHack 3.1 is packaged in a Dungeon Folder which includes:
X    NetHack - the application file itself.
X    NetHack Defaults - text file for default option settings.
X    miscellaneous text files - Record and logfile.  logfile
X        will be created if it doesn't exist.
X    various special level files (with a ".lev" suffix).
X    various help and other utility NetHack documents.
X
X    During play another file type appears:
X    player level files (labelled "iName.n", i is a constant number,
X        Name is the player name and n is the dungeon level).
X
X    Two other types of files will appear in the Dungeon Folder
X        as a result of playing NetHack:
X    bones files (of previously deceased players).
X    saved games (labelled "save/iName", i is a number, same as above,
X        and Name is the player name).
X
X    The following files or file types may be thrown away:
X    logfile - if it becomes too large.  A new one will be generated.
X    player level files _not_ belonging to a game in progress.
X        Alternatively, these files may be processed by a utility
X        application, Recover (not included in this distribution).
X    Old bones files and saved games.
X
X=== Resuming a saved game
X    Double-click (or open) the desired saved game file or open NetHack
X        and answer the "Who are you?" dialog with the player name of
X        the saved game in the Dungeon Folder.
X
X=== Windows
X    Dungeon Map, Message and Status are the essential windows used
X        for play.  As needed, Info windows are generated and may be
X        dismissed (clicking the close box or hitting the space bar
X        when that window is frontmost) at any time.  Special inventory
X        and list windows also appear in the front from time to time
X        and are dismissed by hitting the space bar (or Return or
X        Enter keys).  Hitting the ESCape key will dismiss a window
X        without scrolling to the end.
X
X    The Extended command "Window Cleanup" may be used to restore the
X        the startup sizes and locations of the essential windows.  The
X        window positions are saved in a file labelled "NetHack Windows"
X        in the appropriate preferences folder.
X
X=== Default options
X    The following options are specific to the Macintosh port:
X    MACgraphics  - use enhanced dungeon map symbols [TRUE]
X    large_font   - use 12 point font instead of 9 point font [FALSE]
X    popup_dialog - use real dialogs for question prompts [FALSE]
X
X    large_font is currently a pre-game option and has no effect
X        after the Dungeon Map, Message and Status windows are created.
X
X    Default options may be set by editing the NetHack Defaults text
X        file (possibly using TeachText or your favorite editor).
X        Unix(tm)-style notation is used, as in:
X    OPTIONS=name:Arnold,time,!tombstone
X
X    See option help (?f or ?g) for more details.
X
X=== Movement by mouse
X    The shape (direction) of the cursor over the Dungeon Map window,
X    typically, indicates the direction that you desire to move in when
X    the mouse is clicked.  Modifier keys affect mouse-movement in the
X    same way that they affect keyboard movement.  Clicking on yourself
X    means rest one turn and Shift-clicking on yourself means "open door"
X    in the subsequently indicated direction.
X
X=== Sounds
X    Real sounds (resources) have been added for various instruments.
X    The option "silent" [FALSE] controls whether or not a sound will
X    be heard when an instrument is applied.
X
X=== Debugging-Mode
X    Open NetHack and answer "wizard" to the "Who are you?" dialog.
X    The debug-mode (wizard-mode) commands are then listed in the
X    help menu, ?k.
X
X    WARNING: This mode is only intended for developers and others
X    interested in characterizing bugs.  Using this mode for other
X    purposes will have confusing results and may significantly
X    decrease your enjoyment of the game!
END_OF_FILE
if test 4355 -ne `wc -c <'sys/mac/MacHelp'`; then
    echo shar: \"'sys/mac/MacHelp'\" unpacked with wrong size!
fi
# end of 'sys/mac/MacHelp'
fi
if test -f 'sys/mac/mmodal.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/mac/mmodal.c'\"
else
echo shar: Extracting \"'sys/mac/mmodal.c'\" \(3856 characters\)
sed "s/^X//" >'sys/mac/mmodal.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)mmodal.c	3.1	93/01/24		  */
X/* Copyright (c) Jon W{tte, Hao-Yang Wang, Jonathan Handler 1992. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include "hack.h"
X#include <OSUtils.h>
X
Xvoid FlashButton ( DialogPtr , short ) ;
Xvoid trans_num_keys ( EventRecord * ) ;
X
X#define MAX_MV_DIALOGS 20
Xstatic int old_dialog_count = 0;
Xstatic struct {
X	short	  id;
X	Boolean   init_visible;
X	DialogPtr dialog;
X} old_dialog[MAX_MV_DIALOGS];
X
X/* Instead of calling GetNewDialog everytime, just call
X   SelectWindow/ShowWindow for the old dialog to remember its location.
X*/
X/*
X *	Unfortunately, this does not work, as it doesn't handle old text
X *	in edit text boxes, and not ParamText parameters either.
X *
X */
XDialogPtr
Xmv_get_new_dialog(short dialogID)
X{
X	DialogPtr dialog;
X	int d_idx = old_dialog_count;
X	Rect oldRect ;
X	Boolean hadOld = 0 ;
X
X	old_dialog[0].id = dialogID;
X	while (old_dialog[d_idx].id != dialogID)
X		--d_idx;
X
X/*
X *	This routine modified so that the old dialog is
X *	disposed, and the new one read in after we remember
X *	the old dialog's position.
X *
X *	This takes care of strange default strings and ParamTexts
X *
X */
X
X	if ( d_idx ) {
X
X		dialog = old_dialog [ d_idx ] . dialog ;
X		oldRect = dialog -> portBits . bounds ;
X		DisposeDialog ( dialog ) ;
X		old_dialog [ d_idx ] . dialog = ( DialogPtr ) NULL ;
X		hadOld = 1 ;
X
X	} else {
X
X		d_idx = ++ old_dialog_count ;
X	}
X
X	dialog = GetNewDialog(dialogID, nil, (WindowPtr)-1);
X	if (dialog) {
X
X		if ( hadOld ) {
X
X			MoveWindow ( dialog , - oldRect . left , - oldRect . top , FALSE ) ;
X		}
X		old_dialog[d_idx].id = dialogID;
X		old_dialog[d_idx].init_visible
X			= ((WindowPeek)dialog)->visible;
X		old_dialog[d_idx].dialog = dialog;
X	}
X	return dialog;
X}
X
X/* Instead of actually closing the dialog, just hide it so its location
X   is remembered. */
Xvoid mv_close_dialog(DialogPtr dialog) {
X	HideWindow(dialog);
X}
X
X/* This routine is stolen/borrowed from HandleClick (macwin.c).  See the
X   comments in mv_modal_dialog for more information. */
Xvoid
Xmv_handle_click ( EventRecord * theEvent )
X{
X	int code ;
X	WindowPtr theWindow ;
X	Rect r = ( * GetGrayRgn ( ) ) -> rgnBBox ;
X
X	InsetRect ( & r , 4 , 4 ) ;
X	InitCursor ( ) ;
X
X	code = FindWindow ( theEvent -> where , & theWindow ) ;
X
X	switch ( code ) {
X
X	case inContent :
X		if ( theWindow != FrontWindow ( ) ) {
X			nhbell ( ) ;
X		}
X		break ;
X
X	case inDrag :
X		InitCursor ( ) ;
X		DragWindow ( theWindow , theEvent -> where , & r ) ;
X		SaveWindowPos ( theWindow ) ;
X		break ;
X
X	default :
X		HandleEvent ( theEvent ) ;
X	}
X}
X
Xvoid
Xmv_modal_dialog(ModalFilterProcPtr filterProc, short *itemHit)
X{
X	GrafPtr org_port;
X	GetPort(&org_port);
X
X	for (;;) {
X		DialogPtr dialog = FrontWindow();
X		EventRecord evt;
X
X		WaitNextEvent(everyEvent, &evt, GetCaretTime(), nil);
X
X		if (evt.what == keyDown)
X			if (evt.modifiers & cmdKey) {
X				if ((evt.message & charCodeMask) == '.') {
X					/* 0x351b is the key code and character code of the esc key. */
X					evt.message = 0x351b;
X					evt.modifiers &= ~cmdKey;
X				}
X			} else
X				trans_num_keys(&evt);
X
X		if (filterProc) {
X			if ((*filterProc)(dialog, &evt, itemHit))
X				break;
X		} else if (evt.what == keyDown) {
X			char ch = evt.message & charCodeMask;
X			if (ch == CHAR_CR || ch == CHAR_ENTER) {
X				*itemHit = ok;
X				FlashButton(dialog, ok);
X				break;
X			}
X		}
X
X		if (IsDialogEvent(&evt)) {
X			DialogPtr dont_care;
X			if (DialogSelect(&evt, &dont_care, itemHit))
X				break;
X
X		/* The following part is problemmatic: (1) Calling HandleEvent
X		   here may cause some re-entrance problem (seems ok, but I am
X		   not sure). (2) It is ugly to treat mouseDown events as a
X		   special case.  If we can just say "else HandleEvent(&evt);"
X		   here it will be better. */
X		} else if (evt.what == mouseDown)
X				mv_handle_click(&evt);
X			else
X				HandleEvent(&evt);
X
X		SetPort(org_port);
X	}
X}
END_OF_FILE
if test 3856 -ne `wc -c <'sys/mac/mmodal.c'`; then
    echo shar: \"'sys/mac/mmodal.c'\" unpacked with wrong size!
fi
# end of 'sys/mac/mmodal.c'
fi
if test -f 'sys/vms/Makefile.top' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/vms/Makefile.top'\"
else
echo shar: Extracting \"'sys/vms/Makefile.top'\" \(4301 characters\)
sed "s/^X//" >'sys/vms/Makefile.top' <<'END_OF_FILE'
X#	NetHack Makefile (VMS) - top level for making & installing everything.
X#	SCCS Id: @(#)Makefile.top	3.1	93/01/06
X
X#  Copy this file to <top>Makefile.; edit the appropriate values for
X#  GAMEDIR ("playground" location) and GAMEOWNER (UIC or identifier
X#  for the owner of playground files).
X
X#	usage:	mms all,install
X
XMAKE	= mms
XCD	= set default
XECHO	= write sys$output
XEXEC	= @
XNOOP	= !			# don't do anything
XTOUCH	= set file/truncate	# multiple files per $(TOUCH), but no creation
X# support directories, relative to 'top'
XDAT = [.dat]
XDOC = [.doc]
XSRC = [.src]
XTOP = [-]	# relative to the others
XUTL = [.util]
XVMS = [.sys.vms]
X
XGAMEDIR =			# defaults to [.play]
XGAMEOWNER =			# defaults to installer's UIC
X# these are the distributed values in [.include]vmsconf.h
X#GAMEDIR = DISK$USERS:[GAMES.NETHACK.3-1-0.PLAY]
X#GAMEOWNER = NHWIZARD
X
X# just about everything, except installation
Xall :	program utilities data documentation
X      @ $(ECHO) "all code and data is now up to date."
X
Xprogram :
X	$(CD) $(SRC)
X	$(MAKE)$(MAKEFLAGS) all
X      @ $(CD) $(TOP)
Xutilities :
X	$(CD) $(UTL)
X	$(MAKE)$(MAKEFLAGS) all
X      @ $(CD) $(TOP)
Xdata :
X	$(CD) $(DAT)
X	$(MAKE)$(MAKEFLAGS) all
X      @ $(CD) $(TOP)
Xdocumentation :
X	$(CD) $(DOC)
X	$(MAKE)$(MAKEFLAGS) all
X      @ $(CD) $(TOP)
X
Xinstall :	make_directories create_writeable_files update
X      @ $(ECHO) "installation is now complete."
X
X# assume there're no active games in progress
Xupdate	:	place_readonly_files place_executable place_vms_support
X      @ open/Write f tmp-update.com;
X      @ write f "$ set noon"
X      @ write f "$ if p1.eqs."""" then  p1 = f$trnlnm(""HACKDIR"")"
X      @ write f "$ if p1.eqs."""" then  p1 = ""[.play]"""
X      @ write f "$ old_default = f$environ(""DEFAULT"")"
X      @ write f "$ set default 'p1'"
X      @ write f\
X "$ if f$search(""*.*;-2"").nes."""" then  set file/prot=(s:rwed,o:rwed) *.*;-2"
X      @ write f\
X "$ if f$search(""*.*;-1"").nes."""" then  set file/prot=(s:rwed,o:rwed) *.*;-1"
X      @ write f "$ if f$search(""*.*;-1"").nes."""" then  purge"
X      @ write f "$ if f$search(""bones*.*"").nes."""" then  $(TOUCH) bones*.*"
X      @ write f "$ if f$search(""[.save]*"").nes."""" then  $(TOUCH) [.save]*"
X      @ write f "$ set default 'old_default'"
X      @ write f "$ exit"
X      @ close f
X      - $(EXEC)tmp-update.com; $(GAMEDIR)  !purge old version, touch save files
X      @ delete tmp-update.com;
X      @ $(ECHO) "playground files updated."
X
XGuidebook :
X	$(CD) $(DOC)
X	$(MAKE)$(MAKEFLAGS) Guidebook
X      @ $(CD) $(TOP)
Xmanpages :
X	$(CD) $(DOC)
X	$(MAKE)$(MAKEFLAGS) manpages
X      @ $(CD) $(TOP)
X
Xmake_directories :
X	$(EXEC)$(VMS)install.com "$(GAMEDIR)" "$(GAMEOWNER)" directories
X
Xcreate_writeable_files :
X	$(EXEC)$(VMS)install.com "$(GAMEDIR)" "$(GAMEOWNER)" writeable_files
X
Xplace_readonly_files :
X	$(EXEC)$(VMS)install.com "$(GAMEDIR)" "$(GAMEOWNER)" readonly_files
X
Xplace_executable :
X	$(EXEC)$(VMS)install.com "$(GAMEDIR)" "$(GAMEOWNER)" executable
X
Xplace_vms_support :
X	$(EXEC)$(VMS)install.com "$(GAMEDIR)" "$(GAMEOWNER)" termcap
X	$(EXEC)$(VMS)install.com "$(GAMEDIR)" "$(GAMEOWNER)" procedure
X	$(EXEC)$(VMS)install.com "$(GAMEDIR)" "$(GAMEOWNER)" documentation
X
X
X# 'make no_tools' should be done first if you don't have the appropriate
X# tools to process the parser and scanner for the special level and
X# dungeon compilers; doing so will copy distributed, pre-processed files
X# from [.sys.share] to [.util].  If you _do_ have the tools, be sure to
X# edit [.util]Makefile so that it uses the right ones.
Xno_tools :
X	$(CD) $(UTL)
X	$(MAKE)$(MAKEFLAGS) no_yacc
X	$(MAKE)$(MAKEFLAGS) no_lex
X      @ $(CD) $(TOP)
X
X
X# 'make clean' removes all the .obj files, but leaves around all the executables
X# and compiled data files.
Xclean :
X	$(CD) $(SRC)
X      - $(MAKE)$(MAKEFLAGS) clean
X      @ $(CD) $(TOP)
X	$(CD) $(UTL)
X      - $(MAKE)$(MAKEFLAGS) clean
X      @ $(CD) $(TOP)
X
X# 'make spotless' returns the source tree to near-distribution condition.
X# it removes .obj files, executables, and compiled data files.
Xspotless :
X	$(CD) $(SRC)
X      - $(MAKE)$(MAKEFLAGS) spotless
X      @ $(CD) $(TOP)
X	$(CD) $(UTL)
X      - $(MAKE)$(MAKEFLAGS) spotless
X      @ $(CD) $(TOP)
X	$(CD) $(DAT)
X      - $(MAKE)$(MAKEFLAGS) spotless
X      @ $(CD) $(TOP)
X	$(CD) $(DOC)
X      - $(MAKE)$(MAKEFLAGS) spotless
X      @ $(CD) $(TOP)
END_OF_FILE
if test 4301 -ne `wc -c <'sys/vms/Makefile.top'`; then
    echo shar: \"'sys/vms/Makefile.top'\" unpacked with wrong size!
fi
# end of 'sys/vms/Makefile.top'
fi
if test -f 'util/dgn_comp.l' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'util/dgn_comp.l'\"
else
echo shar: Extracting \"'util/dgn_comp.l'\" \(4261 characters\)
sed "s/^X//" >'util/dgn_comp.l' <<'END_OF_FILE'
X%{
X/*	SCCS Id: @(#)dgn_lex.c	3.1	92/10/23	*/
X/*	Copyright (c) 1989 by Jean-Christophe Collet */
X/*	Copyright (c) 1990 by M. Stephenson	     */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#define DGN_COMP
X
X#include "config.h"
X#include "dgn_comp.h"
X#include "dgn_file.h"
X
Xlong *FDECL(alloc, (unsigned int));
X/*
X * Most of these don't exist in flex, yywrap is macro and
X * yyunput is properly declared in flex.skel.
X */
X#ifndef FLEX_SCANNER
Xint FDECL (yyback, (int *, int));
Xint NDECL (yylook);
Xint NDECL (yyinput);
Xint NDECL (yywrap);
Xint NDECL (yylex);
X	/* Traditional lexes let yyunput() and yyoutput() default to int;
X	 * newer ones may declare them as void since they don't return
X	 * values.  For even more fun, the lex supplied as part of the
X	 * newer unbundled compiler for SunOS 4.x adds the void declarations
X	 * (under __STDC__ or _cplusplus ifdefs -- otherwise they remain
X	 * int) while the bundled lex and the one with the older unbundled
X	 * compiler do not.  To detect this, we need help from outside --
X	 * sys/unix/Makefile.utl.
X	 */
X# if defined(NeXT) || defined(SVR4)
X#  define VOIDYYPUT
X# endif
X# if !defined(VOIDYYPUT)
X#  if defined(POSIX_TYPES) && !defined(BOS) && !defined(HISX)
X#   define VOIDYYPUT
X#  endif
X# endif
X# if !defined(VOIDYYPUT) && defined(WEIRD_LEX)
X#  if defined(SUNOS4) && defined(__STDC__) && (WEIRD_LEX != 0) 
X#   define VOIDYYPUT
X#  endif
X# endif
X# ifdef VOIDYYPUT
Xvoid FDECL (yyunput, (int));
Xvoid FDECL (yyoutput, (int));
X# else
Xint FDECL (yyunput, (int));
Xint FDECL (yyoutput, (int));
X# endif
X#endif	/* FLEX_SCANNER */
X
Xvoid FDECL (init_yyin, (FILE *));
Xvoid FDECL (init_yyout, (FILE *));
X
X#ifdef MICRO
X#undef exit
Xextern void FDECL(exit, (int));
X#endif
X
X/* this doesn't always get put in dgn_comp.h
X * (esp. when using older versions of bison)
X */
X
Xextern YYSTYPE yylval;
X
Xint line_number = 1;
X/*
X *	This is a hack required by Michael Hamel to get things
X *	working on the Mac.
X */
X#if defined(applec) && !defined(FLEX_SCANNER)
X#undef input
X#undef unput
X#define unput(c) { yytchar = (c); if (yytchar == 10) yylineno--; *yysptr++ = yytchar; }				  
X# ifndef YYNEWLINE
X# define YYNEWLINE 10
X# endif
X
Xchar
Xinput() {	/* Under MPW \n is chr(13)! Compensate for this. */
X
X	if (yysptr > yysbuf) return(*--yysptr);
X	else {
X		yytchar = getc(yyin);
X	 	if (yytchar == '\n') {
X		    yylineno++;
X		    return(YYNEWLINE);
X		}
X		if (yytchar == EOF) return(0);
X		else		    return(yytchar);
X	}
X}
X#endif	/* applec && !FLEX_SCANNER */
X
X%}
X%%
XDUNGEON		return(A_DUNGEON);
Xup		{ yylval.i=1; return(UP_OR_DOWN); }
Xdown		{ yylval.i=0; return(UP_OR_DOWN); }
XENTRY		return(ENTRY);
Xstair		return(STAIR);
Xno_up		return(NO_UP);
Xno_down		return(NO_DOWN);
Xportal		return(PORTAL);
XPROTOFILE	return(PROTOFILE);
XDESCRIPTION	return(DESCRIPTION);
XLEVELDESC	return(LEVELDESC);
XALIGNMENT       return(ALIGNMENT);
XLEVALIGN        return(LEVALIGN);
Xtown		{ yylval.i=TOWN ; return(DESCRIPTOR); }
Xhellish		{ yylval.i=HELLISH ; return(DESCRIPTOR); }
Xmazelike	{ yylval.i=MAZELIKE ; return(DESCRIPTOR); }
Xroguelike	{ yylval.i=ROGUELIKE ; return(DESCRIPTOR); }
Xunaligned       { yylval.i=D_ALIGN_NONE ; return(DESCRIPTOR); }
Xnoalign         { yylval.i=D_ALIGN_NONE ; return(DESCRIPTOR); }
Xlawful          { yylval.i=D_ALIGN_LAWFUL ; return(DESCRIPTOR); }
Xneutral         { yylval.i=D_ALIGN_NEUTRAL ; return(DESCRIPTOR); }
Xchaotic         { yylval.i=D_ALIGN_CHAOTIC ; return(DESCRIPTOR); }
XBRANCH		return(BRANCH);
XCHAINBRANCH	return(CHBRANCH);
XLEVEL		return(LEVEL);
XRNDLEVEL	return(RNDLEVEL);
XCHAINLEVEL	return(CHLEVEL);
XRNDCHLEVEL	return(RNDCHLEVEL);
X[-0-9]+		{ yylval.i=atoi(yytext); return(INTEGER); }
X\"[^"]*\"	{ yytext[yyleng-1] = 0; /* Discard the trailing \" */
X		  yylval.str = (char *) alloc(strlen(yytext+1)+1);
X		  strcpy(yylval.str, yytext+1); /* Discard the first \" */
X		  return(STRING); }
X^#.*\n		{ line_number++; }
X\n		{ line_number++; }
X[ \t]+		;	/* skip trailing tabs & spaces */
X.		{ return yytext[0]; }
X%%
X
X/* routine to switch to another input file; needed for flex */
Xvoid init_yyin( input_f )
XFILE *input_f;
X{
X#ifdef FLEX_SCANNER
X	if (yyin)
X	    yyrestart(input_f);
X	else
X#endif
X	    yyin = input_f;
X}
X/* analogous routine (for completeness) */
Xvoid init_yyout( output_f )
XFILE *output_f;
X{
X	yyout = output_f;
X}
X
END_OF_FILE
if test 4261 -ne `wc -c <'util/dgn_comp.l'`; then
    echo shar: \"'util/dgn_comp.l'\" unpacked with wrong size!
fi
# end of 'util/dgn_comp.l'
fi
if test -f 'win/X11/nh72icon' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'win/X11/nh72icon'\"
else
echo shar: Extracting \"'win/X11/nh72icon'\" \(4333 characters\)
sed "s/^X//" >'win/X11/nh72icon' <<'END_OF_FILE'
X/*	SCCS Id: @(#)nh72icon	3.1	93/01/21			*/
X/*	Copyright (c) 1993 by M. Stephenson				*/
X/* NetHack may be freely redistributed.  See license for details.	*/
X
X/*	72x72 X11 icon for NetHack.					*/
X
X#define nh72icon_width 72
X#define nh72icon_height 72
Xstatic char nh72icon_bits[] = {
X   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
X   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
X   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
X   0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x07, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0xe0, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0,
X   0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x07, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x07, 0x00, 0x08, 0x00, 0x00, 0x00,
X   0x10, 0x00, 0xe0, 0x07, 0x00, 0x18, 0x00, 0x00, 0x00, 0x18, 0x00, 0xe0,
X   0x07, 0x00, 0x78, 0x00, 0x00, 0x00, 0x1e, 0x00, 0xe0, 0x07, 0x3e, 0xc8,
X   0x07, 0x00, 0xf8, 0x13, 0x7c, 0xe0, 0x07, 0x22, 0x08, 0xfc, 0xc1, 0x0f,
X   0x10, 0x44, 0xe0, 0x07, 0x36, 0x08, 0x00, 0x7f, 0x00, 0x10, 0x6c, 0xe0,
X   0x07, 0x1c, 0x08, 0x00, 0x00, 0x00, 0x10, 0x38, 0xe0, 0x07, 0x14, 0x08,
X   0x00, 0x00, 0x00, 0x10, 0x28, 0xe0, 0x07, 0x1c, 0x08, 0x00, 0x00, 0x00,
X   0x10, 0x38, 0xe0, 0x07, 0x14, 0x08, 0x00, 0x00, 0x00, 0x10, 0x28, 0xe0,
X   0x07, 0x1c, 0x08, 0x00, 0x00, 0x00, 0x10, 0x38, 0xe0, 0x07, 0x14, 0x08,
X   0x00, 0x00, 0x00, 0x10, 0x28, 0xe0, 0x87, 0xff, 0x08, 0x10, 0x00, 0x10,
X   0x10, 0xff, 0xe1, 0xc7, 0xff, 0x09, 0x38, 0x10, 0x38, 0x90, 0xff, 0xe3,
X   0x47, 0x1c, 0x09, 0x78, 0x38, 0x3c, 0x90, 0x38, 0xe2, 0x07, 0x1c, 0x08,
X   0xfc, 0x39, 0x7f, 0x10, 0x38, 0xe0, 0x07, 0x1c, 0x08, 0xfc, 0xbb, 0x7f,
X   0x10, 0x38, 0xe0, 0x07, 0x1c, 0x08, 0xfe, 0xff, 0xff, 0x10, 0x38, 0xe0,
X   0x07, 0x1c, 0x08, 0xfe, 0xff, 0xff, 0x10, 0x38, 0xe0, 0x07, 0x1c, 0x08,
X   0xfe, 0xff, 0xff, 0x10, 0x38, 0xe0, 0x07, 0x1c, 0x08, 0xfe, 0xff, 0xff,
X   0x10, 0x38, 0xe0, 0x07, 0x1c, 0x08, 0xfe, 0xff, 0xff, 0x10, 0x38, 0xe0,
X   0x07, 0x1c, 0x08, 0xfc, 0xbb, 0x7f, 0x10, 0x38, 0xe0, 0x07, 0x1c, 0x08,
X   0xfc, 0x39, 0x7f, 0x10, 0x38, 0xe0, 0x07, 0x1c, 0x08, 0x78, 0x38, 0x3c,
X   0x10, 0x38, 0xe0, 0x07, 0x1c, 0x08, 0x38, 0x38, 0x38, 0x10, 0x38, 0xe0,
X   0x07, 0x1c, 0x08, 0x10, 0x38, 0x10, 0x10, 0x38, 0xe0, 0x07, 0x1c, 0x08,
X   0x00, 0x38, 0x00, 0x10, 0x38, 0xe0, 0x07, 0x1c, 0x08, 0x00, 0x38, 0x00,
X   0x10, 0x38, 0xe0, 0x07, 0x1c, 0x08, 0x00, 0x38, 0x00, 0x10, 0x38, 0xe0,
X   0x07, 0x1c, 0x08, 0x00, 0x38, 0x00, 0x10, 0x38, 0xe0, 0x07, 0x1c, 0x08,
X   0x00, 0x38, 0x00, 0x10, 0x38, 0xe0, 0x07, 0x1c, 0x08, 0x00, 0x38, 0x00,
X   0x10, 0x38, 0xe0, 0x07, 0x1c, 0x08, 0x00, 0x38, 0x00, 0x10, 0x38, 0xe0,
X   0x07, 0x1c, 0x08, 0x00, 0x38, 0x00, 0x10, 0x38, 0xe0, 0x07, 0x1c, 0x08,
X   0x00, 0x28, 0x00, 0x10, 0x38, 0xe0, 0x07, 0x1c, 0x08, 0x00, 0x38, 0x00,
X   0x10, 0x38, 0xe0, 0x07, 0x08, 0x18, 0x00, 0x28, 0x00, 0x10, 0x10, 0xe0,
X   0x07, 0x08, 0x30, 0x00, 0x38, 0x00, 0x18, 0x10, 0xe0, 0x07, 0x00, 0x60,
X   0x00, 0x28, 0x00, 0x0c, 0x00, 0xe0, 0x07, 0x00, 0xc0, 0x00, 0x38, 0x00,
X   0x06, 0x00, 0xe0, 0x07, 0x00, 0x80, 0x01, 0x28, 0x00, 0x03, 0x00, 0xe0,
X   0x07, 0x00, 0x00, 0x03, 0x38, 0x80, 0x01, 0x00, 0xe0, 0x07, 0x00, 0x00,
X   0x06, 0x6c, 0xc0, 0x00, 0x10, 0xe0, 0x07, 0x08, 0x00, 0x0c, 0x44, 0x60,
X   0x00, 0x92, 0xe0, 0x07, 0x49, 0x00, 0x18, 0x7c, 0x30, 0x00, 0x6c, 0xe0,
X   0x07, 0x36, 0x00, 0x30, 0x00, 0x18, 0x00, 0x44, 0xe0, 0x07, 0x22, 0x00,
X   0x60, 0x00, 0x0c, 0x00, 0x83, 0xe1, 0x87, 0xc1, 0x00, 0xc0, 0x00, 0x06,
X   0x00, 0x44, 0xe0, 0x07, 0x22, 0x00, 0x80, 0x01, 0x03, 0x00, 0x6c, 0xe0,
X   0x07, 0x36, 0x00, 0x00, 0x83, 0x01, 0x00, 0x92, 0xe0, 0x07, 0x49, 0x00,
X   0x00, 0xfe, 0x00, 0x00, 0x10, 0xe0, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0xe0, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0,
X   0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x07, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0xe0, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0,
X   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
X   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
X   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
END_OF_FILE
if test 4333 -ne `wc -c <'win/X11/nh72icon'`; then
    echo shar: \"'win/X11/nh72icon'\" unpacked with wrong size!
fi
# end of 'win/X11/nh72icon'
fi
echo shar: End of archive 104 \(of 108\).
cp /dev/null ark104isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \
21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \
41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 \
61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 \
81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 \
101 102 103 104 105 106 107 108 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 108 archives.
    echo "Now execute 'rebuild.sh'"
    rm -f ark10[0-8]isdone ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
