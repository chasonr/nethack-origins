Path: uunet!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v16i087:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Part79/108
Message-ID: <4450@master.CNA.TEK.COM>
Date: 5 Feb 93 19:20:21 GMT
Sender: news@master.CNA.TEK.COM
Lines: 2165
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1638

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 16, Issue 87
Archive-name: nethack31/Part79
Supersedes: nethack3p9: Volume 10, Issue 46-102
Environment: Amiga, Atari, Mac, MS-DOS, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 79 (of 108)."
# Contents:  include/dgn_file.h src/detect.c src/mhitm.c
# Wrapped by billr@saab on Wed Jan 27 16:09:18 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'include/dgn_file.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/dgn_file.h'\"
else
echo shar: Extracting \"'include/dgn_file.h'\" \(1606 characters\)
sed "s/^X//" >'include/dgn_file.h' <<'END_OF_FILE'
X/*	SCCS Id: @(#)dgn_file.h	3.1	93/01/17	*/
X/* Copyright (c) 1989 by M. Stephenson				  */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#ifndef DGN_FILE_H
X#define DGN_FILE_H
X
X#include "align.h"
X
X/*
X * Structures manipulated by the dungeon loader & compiler
X */
X
Xstruct	couple {
X	short	base, rand;
X};
X
Xstruct tmpdungeon {
X	char	name[24],
X		protoname[24];
X	struct	couple	lev;
X	int	flags,
X		chance,
X		levels,
X		branches,
X		entry_lev;		/* entry level for this dungeon */
X	char	boneschar;
X};
X
Xstruct tmplevel {
X	char	name[24];
X	struct	couple	lev;
X	int	chance, rndlevs, chain, flags;
X	char	boneschar;
X};
X
Xstruct tmpbranch {
X	char	name[24];	/* destination dungeon name */
X	struct	couple	lev;
X	int	chain;		/* index into tmplevel array (chained branch)*/
X	int	type;		/* branch type (see below) */
X	int	up;		/* branch is up or down */
X};
X
X/*
X *	Values for type for tmpbranch structure.
X */
X#define TBR_STAIR   0	/* connection with both ends having a staircase */
X#define TBR_NO_UP   1	/* connection with no up staircase */
X#define TBR_NO_DOWN 2	/* connection with no down staircase */
X#define TBR_PORTAL  3	/* portal connection */
X
X/*
X *	Flags that map into the dungeon flags bitfields.
X */
X#define TOWN		  1	/* levels only */
X#define HELLISH		  2
X#define MAZELIKE	  4
X#define ROGUELIKE	  8
X
X#define D_ALIGN_NONE	0
X#define D_ALIGN_CHAOTIC	(AM_CHAOTIC << 4)
X#define D_ALIGN_NEUTRAL	(AM_NEUTRAL << 4)
X#define D_ALIGN_LAWFUL	(AM_LAWFUL << 4)
X
X#define D_ALIGN_MASK	0x70
X
X/*
X *	Max number of prototype levels and branches.
X */
X#define LEV_LIMIT	50
X#define BRANCH_LIMIT	20
X
X#endif /* DGN_FILE_H */
END_OF_FILE
if test 1606 -ne `wc -c <'include/dgn_file.h'`; then
    echo shar: \"'include/dgn_file.h'\" unpacked with wrong size!
fi
# end of 'include/dgn_file.h'
fi
if test -f 'src/detect.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/detect.c'\"
else
echo shar: Extracting \"'src/detect.c'\" \(24671 characters\)
sed "s/^X//" >'src/detect.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)detect.c	3.1	92/12/16	*/
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X/*
X * Detection routines, including crystal ball, magic mapping, and search
X * command.
X */
X
X#include "hack.h"
X#include "artifact.h"
X
Xextern boolean known;	/* from read.c */
X
Xstatic boolean FDECL(check_map_spot, (int,int,CHAR_P));
Xstatic boolean FDECL(clear_stale_map, (CHAR_P));
Xstatic void FDECL(sense_trap, (struct trap *,XCHAR_P,XCHAR_P,int));
Xstatic void FDECL(show_map_spot, (int,int));
XSTATIC_PTR void FDECL(findone,(int,int,genericptr_t));
XSTATIC_PTR void FDECL(openone,(int,int,genericptr_t));
X
X/* Recursively search obj for an object in class oclass and return 1st found */
Xstruct obj *
Xo_in(obj, oclass)
Xstruct obj* obj;
Xchar oclass;
X{
X    register struct obj* otmp;
X    struct obj *temp;
X
X    if (obj->oclass == oclass) return obj;
X
X    if (Is_container(obj)) {
X	for (otmp = obj->cobj; otmp; otmp = otmp->nobj)
X	    if (otmp->oclass == oclass) return otmp;
X	    else if (Is_container(otmp) && (temp = o_in(otmp, oclass)))
X		return temp;
X    }
X    return (struct obj *) 0;
X}
X
X/* Check whether the location has an outdated object displayed on it. */
Xstatic boolean
Xcheck_map_spot(x, y, oclass)
Xint x, y;
Xregister char oclass;
X{
X	register struct rm *lev;
X	register struct obj *otmp;
X	register struct monst *mtmp;
X
X	lev = &levl[x][y];
X	if (glyph_is_object(lev->glyph)) {
X	    /* there's some object shown here */
X	    if (oclass == ALL_CLASSES) {
X		return !(level.objects[x][y] ||     /* stale if nothing here */
X			    ((mtmp = m_at(x,y)) != 0 &&
X				(mtmp->mgold || mtmp->minvent)));
X	    } else if (objects[glyph_to_obj(lev->glyph)].oc_class == oclass) {
X		/* the object shown here is of interest */
X		for (otmp = level.objects[x][y]; otmp; otmp = otmp->nexthere)
X		    if (o_in(otmp, oclass)) return FALSE;
X		/* didn't find it; perhaps a monster is carrying it */
X		if ((mtmp = m_at(x,y)) != 0) {
X		    if (oclass == GOLD_CLASS && mtmp->mgold)
X			return FALSE;
X		    else for (otmp = mtmp->minvent; otmp; otmp = otmp->nobj)
X			    if (o_in(otmp, oclass)) return FALSE;
X		}
X		/* detection indicates removal of this object from the map */
X		return TRUE;
X	    }
X	}
X	return FALSE;
X}
X
X/*
X   When doing detection, remove stale data from the map display (corpses
X   rotted away, objects carried away by monsters, etc) so that it won't
X   reappear after the detection has completed.  Return true if noticeable
X   change occurs.
X */
Xstatic boolean
Xclear_stale_map(oclass)
Xregister char oclass;
X{
X	register int zx, zy;
X	register boolean change_made = FALSE;
X
X	for (zx = 1; zx < COLNO; zx++)
X	    for (zy = 0; zy < ROWNO; zy++)
X		if (check_map_spot(zx, zy, oclass)) {
X		    unmap_object(zx, zy);
X		    change_made = TRUE;
X		}
X
X	return change_made;
X}
X
X/* look for gold, on the floor or in monsters' possession */
Xint
Xgold_detect(sobj)
Xregister struct obj *sobj;
X{
X    register struct obj *obj;
X    register struct monst *mtmp;
X    int uw = u.uinwater;
X    struct obj *temp;
X    boolean stale;
X
X    known = stale = clear_stale_map(GOLD_CLASS);
X
X    /* look for gold carried by monsters (might be in a container) */
X    for (mtmp = fmon; mtmp; mtmp = mtmp->nmon)
X	if (mtmp->mgold) {
X	    known = TRUE;
X	    goto outgoldmap;	/* skip further searching */
X	} else for (obj = mtmp->minvent; obj; obj = obj->nobj)
X	    if (o_in(obj, GOLD_CLASS)) {
X		known = TRUE;
X		goto outgoldmap;	/* skip further searching */
X	    }
X
X    /* look for gold objects */
X    for (obj = fobj; obj; obj = obj->nobj)
X	if (o_in(obj, GOLD_CLASS)) {
X	    known = TRUE;
X	    if (obj->ox != u.ux || obj->oy != u.uy) goto outgoldmap;
X	}
X
X    if (!known) {
X	/* no gold found */
X	if (sobj) strange_feeling(sobj, "You feel materially poor.");
X	return(1);
X    }
X    /* only under me - no separate display required */
X    if (stale) docrt();
X    You("notice some gold between your %s.", makeplural(body_part(FOOT)));
X    return(0);
X
Xoutgoldmap:
X    cls();
X
X    u.uinwater = 0;
X    /* Discover gold locations. */
X    for (obj = fobj; obj; obj = obj->nobj)
X	if ((temp = o_in(obj, GOLD_CLASS))) {
X	    if (temp != obj) {
X		temp->ox = obj->ox;
X		temp->oy = obj->oy;
X	    }
X	    map_object(temp,1);
X	}
X    for (mtmp = fmon; mtmp; mtmp = mtmp->nmon)
X	if (mtmp->mgold) {
X	    struct obj gold;
X
X	    gold.otyp = GOLD_PIECE;
X	    gold.ox = mtmp->mx;
X	    gold.oy = mtmp->my;
X	    map_object(&gold,1);
X	} else for (obj = mtmp->minvent; obj; obj = obj->nobj)
X	    if ((temp = o_in(obj, GOLD_CLASS))) {
X		temp->ox = mtmp->mx;
X		temp->oy = mtmp->my;
X		map_object(temp,1);
X		break;
X	    }
X
X    newsym(u.ux,u.uy);
X    You("feel very greedy, and sense gold!");
X    exercise(A_WIS, TRUE);
X    display_nhwindow(WIN_MAP, TRUE);
X    docrt();
X    u.uinwater = uw;
X    if (Underwater) under_water(2);
X    return(0);
X}
X
X/* returns 1 if nothing was detected		*/
X/* returns 0 if something was detected		*/
Xint
Xfood_detect(sobj)
Xregister struct obj	*sobj;
X{
X    register struct obj *obj;
X    register struct monst *mtmp;
X    register int ct = 0, ctu = 0;
X    boolean confused = (Confusion || (sobj && sobj->cursed)), stale;
X    char oclass = confused ? POTION_CLASS : FOOD_CLASS;
X    const char *what = confused ? "something" : "food";
X    int uw = u.uinwater;
X
X    stale = clear_stale_map(oclass);
X
X    for (obj = fobj; obj; obj = obj->nobj)
X	if (o_in(obj, oclass)) {
X	    if (obj->ox == u.ux && obj->oy == u.uy) ctu++;
X	    else ct++;
X	}
X    for (mtmp = fmon; mtmp && !ct; mtmp = mtmp->nmon)
X	for (obj = mtmp->minvent; obj; obj = obj->nobj)
X	    if (o_in(obj, oclass)) {
X		ct++;
X		break;
X	    }
X
X    if (!ct && !ctu) {
X	known = stale && !confused;
X	if (stale) {
X	    docrt();
X	    You("sense lack of %s nearby.", what);
X	} else if (sobj)
X	    strange_feeling(sobj, "Your nose twitches.");
X	return !stale;
X    } else if (!ct) {
X	known = TRUE;
X	You("%s %s nearby.", sobj ? "smell" : "sense", what);
X    } else {
X	struct obj *temp;
X	known = TRUE;
X	cls();
X	u.uinwater = 0;
X	for (obj = fobj; obj; obj = obj->nobj)
X	    if ((temp = o_in(obj, oclass)) != 0) {
X		if (temp != obj) {
X		    temp->ox = obj->ox;
X		    temp->oy = obj->oy;
X		}
X		map_object(temp,1);
X	    }
X	for (mtmp = fmon; mtmp; mtmp = mtmp->nmon)
X	    for (obj = mtmp->minvent; obj; obj = obj->nobj)
X		if ((temp = o_in(obj, oclass)) != 0) {
X		    temp->ox = mtmp->mx;
X		    temp->oy = mtmp->my;
X		    map_object(temp,1);
X		    break;	/* skip rest of this monster's inventory */
X		}
X	newsym(u.ux,u.uy);
X	if (sobj) Your("nose tingles and you smell %s.", what);
X	else You("sense %s.", what);
X	display_nhwindow(WIN_MAP, TRUE);
X	exercise(A_WIS, TRUE);
X	docrt();
X	u.uinwater = uw;
X	if (Underwater) under_water(2);
X    }
X    return(0);
X}
X
X/*
X * Used for scrolls, potions, and crystal balls.  Returns:
X *
X *	1 - nothing was detected
X *	0 - something was detected
X */
Xint
Xobject_detect(detector, class)
Xstruct obj	*detector;	/* object doing the detecting */
Xint		class;		/* an object class, 0 for all */
X{
X    register int x, y;
X    int is_cursed = (detector && detector->cursed);
X    int ct = 0, ctu = 0;
X    register struct obj *obj, *otmp = (struct obj *)0;
X    register struct monst *mtmp;
X    int uw = u.uinwater;
X    const char *stuff;
X
X    if (class < 0 || class >= MAXOCLASSES) {
X	impossible("object_detect:  illegal class %d", class);
X	class = 0;
X    }
X
X    if (Hallucination || (Confusion && class == SCROLL_CLASS))
X	stuff = "something";
X    else
X	stuff = class ? oclass_names[class] : "objects";
X
X    for (obj = fobj; obj && !ct; obj = obj->nobj)
X	if (!class || o_in(obj, class)) {
X	    if (obj->ox == u.ux && obj->oy == u.uy) ctu++;
X	    else ct++;
X	}
X
X    if (!ct)
X	for (mtmp = fmon; mtmp && !ct; mtmp = mtmp->nmon) {
X	    if (!class && mtmp->minvent) {
X		ct++;
X		break;
X	    }
X
X	    for (obj = mtmp->minvent; obj; obj = obj->nobj)
X		if (o_in(obj, class)) {
X		    ct++;
X		    break;
X		}
X
X	    if ((is_cursed && mtmp->m_ap_type == M_AP_OBJECT &&
X		(!class || class == objects[mtmp->mappearance].oc_class)) ||
X		(mtmp->mgold && (!class || class == GOLD_CLASS))) {
X		ct++;
X		break;
X	    }
X	}
X
X    if (!clear_stale_map(!class ? ALL_CLASSES : class) && !ct) {
X	if (!ctu) {
X	    if (detector)
X		strange_feeling(detector, "You feel a lack of something.");
X	    return 1;
X	}
X
X	You("sense %s nearby.", stuff);
X	return 0;
X    }
X
X    cls();
X
X    u.uinwater = 0;
X    /*
X     * If we are mapping all objects, map only the top object of a pile or
X     * the first object in a monster's inventory.  Otherwise, go looking
X     * for a matching object class and display the first one encountered
X     * at each location.
X     */
X    for (x = 1; x < COLNO; x++)
X	for (y = 0; y < ROWNO; y++)
X	    for (obj = level.objects[x][y]; obj; obj = obj->nexthere)
X		if (!class || (otmp = o_in(obj, class))) {
X		    if (class) {
X			if (otmp != obj) {
X			    otmp->ox = obj->ox;
X			    otmp->oy = obj->oy;
X			}
X			map_object(otmp, 1);
X		    } else
X			map_object(obj, 1);
X		    break;
X		}
X
X    /* Objects in the monster's inventory override floor objects. */
X    for (mtmp = fmon ; mtmp ; mtmp = mtmp->nmon) {
X	for (obj = mtmp->minvent; obj; obj = obj->nobj)
X	    if (!class || (otmp = o_in(obj, class))) {
X		if (!class) otmp = obj;
X		otmp->ox = mtmp->mx;		/* at monster location */
X		otmp->oy = mtmp->my;
X		map_object(otmp, 1);
X		break;
X	    }
X
X
X	/* Allow a mimic to override the detected objects it is carrying. */
X	if (is_cursed && mtmp->m_ap_type == M_AP_OBJECT &&
X		(!class || class == objects[mtmp->mappearance].oc_class)) {
X	    struct obj temp;
X
X	    temp.otyp = mtmp->mappearance;	/* needed for obj_to_glyph() */
X	    temp.ox = mtmp->mx;
X	    temp.oy = mtmp->my;
X	    temp.corpsenm = PM_TENGU;		/* if mimicing a corpse */
X	    map_object(&temp, 1);
X	} else if (mtmp->mgold && (!class || class == GOLD_CLASS)) {
X	    struct obj gold;
X
X	    gold.otyp = GOLD_PIECE;
X	    gold.ox = mtmp->mx;
X	    gold.oy = mtmp->my;
X	    map_object(&gold, 1);
X	}
X    }
X
X    newsym(u.ux,u.uy);
X    You("detect the %s of %s.", ct ? "presence" : "absence", stuff);
X    display_nhwindow(WIN_MAP, TRUE);
X    /*
X     * What are we going to do when the hero does an object detect while blind
X     * and the detected object covers a known pool?
X     */
X    docrt();	/* this will correctly reset vision */
X
X    u.uinwater = uw;
X    if (Underwater) under_water(2);
X    return 0;
X}
X
X/*
X * Used by: crystal balls, potions, fountains
X *
X * Returns 1 if nothing was detected.
X * Returns 0 if something was detected.
X */
Xint
Xmonster_detect(otmp, mclass)
Xregister struct obj *otmp;	/* detecting object (if any) */
Xint		    mclass;	/* monster class, 0 for all */
X{
X    register struct monst *mtmp;
X
X    if (!fmon) {
X	if (otmp)
X	    strange_feeling(otmp, Hallucination ?
X			    "You get the heebie jeebies." :
X			    "You feel threatened.");
X	return 1;
X    } else {
X	int woken = FALSE;
X
X	cls();
X	for (mtmp = fmon; mtmp; mtmp = mtmp->nmon) {
X	    if (!mclass || mtmp->data->mlet == mclass)
X	    if (mtmp->mx > 0)
X		show_glyph(mtmp->mx,mtmp->my,mon_to_glyph(mtmp));
X	    if (otmp && otmp->cursed &&
X		(mtmp->msleep || !mtmp->mcanmove)) {
X		mtmp->msleep = mtmp->mfrozen = 0;
X		mtmp->mcanmove = 1;
X		woken = TRUE;
X	    }
X	}
X	display_self();
X	You("sense the presence of monsters.");
X	if (woken)
X	    pline("Monsters sense the presence of you.");
X	display_nhwindow(WIN_MAP, TRUE);
X	docrt();
X	if (Underwater) under_water(2);
X    }
X    return 0;
X}
X
Xstatic void
Xsense_trap(trap, x, y, src_cursed)
Xstruct trap *trap;
Xxchar	    x, y;
Xint	    src_cursed;
X{
X    if (Hallucination || src_cursed) {
X	struct obj obj;			/* fake object */
X	if (trap) {
X	    obj.ox = trap->tx;
X	    obj.oy = trap->ty;
X	} else {
X	    obj.ox = x;
X	    obj.oy = y;
X	}
X	obj.otyp = (src_cursed) ? GOLD_PIECE : random_object();
X	obj.corpsenm = random_monster();	/* if otyp == CORPSE */
X	map_object(&obj,1);
X    } else if (trap) {
X	map_trap(trap,1);
X	trap->tseen = 1;
X    } else {
X	struct trap temp_trap;		/* fake trap */
X	temp_trap.tx = x;
X	temp_trap.ty = y;
X	temp_trap.ttyp = BEAR_TRAP;	/* some kind of trap */
X	map_trap(&temp_trap,1);
X    }
X
X}
X
X/* the detections are pulled out so they can	*/
X/* also be used in the crystal ball routine	*/
X/* returns 1 if nothing was detected		*/
X/* returns 0 if something was detected		*/
Xint
Xtrap_detect(sobj)
Xregister struct obj *sobj;
X/* sobj is null if crystal ball, *scroll if gold detection scroll */
X{
X    register struct trap *ttmp;
X    register struct obj *obj;
X    register int door;
X    int uw = u.uinwater;
X    boolean found = FALSE;
X    coord cc;
X
X    for (ttmp = ftrap; ttmp; ttmp = ttmp->ntrap) {
X	if (ttmp->tx != u.ux || ttmp->ty != u.uy)
X	    goto outtrapmap;
X	else found = TRUE;
X    }
X    for (obj = fobj; obj; obj = obj->nobj) {
X	if ((obj->otyp==LARGE_BOX || obj->otyp==CHEST) && obj->otrapped)
X	    if (obj->ox != u.ux || obj->oy != u.uy)
X		goto outtrapmap;
X	    else found = TRUE;
X    }
X    for (door = 0; door <= doorindex; door++) {
X	cc = doors[door];
X	if (levl[cc.x][cc.y].doormask & D_TRAPPED)
X	    if (cc.x != u.ux || cc.x != u.uy)
X		goto outtrapmap;
X	    else found = TRUE;
X    }
X    if (!found) {
X	char buf[42];
X	Sprintf(buf, "Your %s stop itching.", makeplural(body_part(TOE)));
X	strange_feeling(sobj,buf);
X	return(1);
X    }
X    /* traps exist, but only under me - no separate display required */
X    Your("%s itch.", makeplural(body_part(TOE)));
X    return(0);
Xouttrapmap:
X    cls();
X
X    u.uinwater = 0;
X    for (ttmp = ftrap; ttmp; ttmp = ttmp->ntrap)
X	sense_trap(ttmp, 0, 0, sobj && sobj->cursed);
X
X    for (obj = fobj; obj; obj = obj->nobj)
X	if ((obj->otyp==LARGE_BOX || obj->otyp==CHEST) && obj->otrapped)
X	sense_trap((struct trap *)0, obj->ox, obj->oy, sobj && sobj->cursed);
X
X    for (door = 0; door <= doorindex; door++) {
X	cc = doors[door];
X	if (levl[cc.x][cc.y].doormask & D_TRAPPED)
X	sense_trap((struct trap *)0, cc.x, cc.y, sobj && sobj->cursed);
X    }
X
X    newsym(u.ux,u.uy);
X    You("feel %s.", sobj && sobj->cursed ? "very greedy" : "entrapped");
X    display_nhwindow(WIN_MAP, TRUE);
X    docrt();
X    u.uinwater = uw;
X    if (Underwater) under_water(2);
X    return(0);
X}
X
Xconst char *
Xlevel_distance(where)
Xd_level *where;
X{
X    register xchar ll = depth(&u.uz) - depth(where);
X    register boolean indun = (u.uz.dnum == where->dnum);
X
X    if (ll < 0) {
X    	if (ll < (-8 - rn2(3)))
X	    if (!indun)	return "far away";
X	    else	return "far below";
X	else if (ll < -1)
X	    if (!indun)	return "away below you";
X	    else	return "below you";
X	else
X	    if (!indun)	return "in the distance";
X	    else	return "just below";
X    } else if (ll > 0) {
X	if (ll > (8 + rn2(3)))
X	    if (!indun)	return "far away";
X	    else	return "far above";
X	else if (ll > 1)
X	    if (!indun)	return "away above you";
X	    else	return "above you";
X	else
X	    if (!indun)	return "in the distance";
X	    else	return "just above";
X    } else
X	    if (!indun)	return "in the distance";
X	    else	return "near you";
X}
X
Xstatic struct {
X    const char *what;
X    d_level *where;
X} level_detects[] = {
X  { "Delphi", &oracle_level },
X  { "Medusa's lair", &medusa_level },
X  { "a castle", &stronghold_level },
X  { "the Wizard of Yendor's tower", &wiz1_level },
X};
X
Xvoid
Xuse_crystal_ball(obj)
Xstruct obj *obj;
X{
X    char ch;
X    int oops;
X    const char *bname = xname(obj);
X
X    if (Blind) {
X	pline("Too bad you can't see %s", the(bname));
X	return;
X    }
X    oops = (rnd(20) > ACURR(A_INT) || obj->cursed);
X    if (oops && (obj->spe > 0)) {
X	switch(rnd(5)) {
X	case 1 : pline("%s is too much to comprehend!", The(bname));
X	    break;
X	case 2 : pline("%s confuses you!", The(bname));
X	    make_confused(HConfusion + rnd(100),FALSE);
X	    break;
X	case 3 : pline("%s damages your vision!", The(bname));
X	    make_blinded(Blinded + rnd(100),FALSE);
X	    break;
X	case 4 : pline("%s zaps your mind!", The(bname));
X	    make_hallucinated(HHallucination + rnd(100),FALSE,0L);
X	    break;
X	case 5 : pline("%s explodes!", The(bname));
X	    useup(obj);
X	    losehp(rnd(30), "exploding crystal ball", KILLED_BY_AN);
X	    break;
X	}
X	obj->spe--;
X	return;
X    }
X
X    if (Hallucination) {
X	if (!obj->spe) {
X	    pline("All you see is funky %s haze.", hcolor());
X	} else {
X	    switch(rnd(6)) {
X	    case 1 : You("grok some groovy globs of incandescent lava.");
X		break;
X	    case 2 : pline("Whoa!  Psychedelic colors, %s!",
X			   poly_gender() == 1 ? "babe" : "dude");
X		break;
X	    case 3 : pline("The crystal pulses with sinister %s light!", hcolor());
X		break;
X	    case 4 : You("see goldfish swimming above fluorescent rocks.");
X		break;
X	    case 5 : You("see tiny snowflakes spinning around a miniature farmhouse.");
X		break;
X	    default: pline("Oh wow... like a kaleidoscope!");
X		break;
X	    }
X	    obj->spe--;
X	}
X	return;
X    }
X
X    /* read a single character */
X    if (flags.verbose) You("may look for an object or monster symbol.");
X    ch = yn_function("What do you look for?", NULL, '\0');
X    if (index(quitchars,ch)) {
X	if (flags.verbose) pline("Never mind.");
X	return;
X    }
X    You("peer into %s", the(bname));
X    nomul(-rnd(10));
X    nomovemsg = "";
X    if (obj->spe <= 0)
X	pline("The vision is unclear.");
X    else {
X	int class;
X	int ret = 0;
X
X	makeknown(CRYSTAL_BALL);
X	obj->spe--;
X
X	if ((class = def_char_to_objclass(ch)) != MAXOCLASSES)
X		ret = object_detect((struct obj *)0, class);
X	else if ((class = def_char_to_monclass(ch)) != MAXMCLASSES)
X		ret = monster_detect((struct obj *)0, class);
X	else switch(ch) {
X		case '^':
X		    ret = trap_detect((struct obj *)0);
X		    break;
X		default:
X		    {
X		    short i = rn2(SIZE(level_detects));
X		    You("see %s, %s.",
X			level_detects[i].what,
X			level_distance(level_detects[i].where));
X		    }
X		    ret = 1;
X		    break;
X	}
X
X	if (!ret)
X	    if (!rn2(100))  /* make them nervous */
X		You("see the Wizard of Yendor gazing out at you.");
X		else pline("The vision is unclear.");
X    }
X    return;
X}
X
Xstatic void
Xshow_map_spot(x, y)
Xregister int x, y;
X{
X    register struct rm *lev;
X
X    if (Confusion && rn2(7)) return;
X    lev = &levl[x][y];
X
X    if (IS_WALL(lev->typ) || lev->typ == SDOOR)
X	lev->seen = 1;		/* We have seen all the walls. */
X
X    /* Secret corridors are found, but not secret doors. */
X    if (lev->typ == SCORR) {
X	lev->typ = CORR;
X	unblock_point(x,y);
X    }
X
X    /* if not a room and we don't remember an object or trap there, map it */
X    if (lev->typ != ROOM  &&
X		!(glyph_is_object(lev->glyph) || glyph_is_trap(lev->glyph))) {
X	if (level.flags.hero_memory) {
X	    map_background(x,y,0);
X	    newsym(x,y);		/* show it, if not blocked */
X	} else {
X	    map_background(x,y,1);	/* display it */
X	}
X    }
X}
X
Xvoid
Xdo_mapping()
X{
X    register int zx, zy;
X    int uw = u.uinwater;
X
X    u.uinwater = 0;
X    for (zx = 1; zx < COLNO; zx++)
X	for (zy = 0; zy < ROWNO; zy++)
X	    show_map_spot(zx, zy);
X    exercise(A_WIS, TRUE);
X    u.uinwater = uw;
X    if (!level.flags.hero_memory || Underwater) {
X	flush_screen(1);			/* flush temp screen */
X	display_nhwindow(WIN_MAP, TRUE);	/* wait */
X	docrt();
X    }
X}
X
Xvoid
Xdo_vicinity_map()
X{
X    register int zx, zy;
X    int lo_y = (u.uy-5 < 0 ? 0 : u.uy-5),
X	hi_y = (u.uy+6 > ROWNO ? ROWNO : u.uy+6),
X	lo_x = (u.ux-9 < 1 ? 1 : u.ux-9),	/* avoid column 0 */
X	hi_x = (u.ux+10 > COLNO ? COLNO : u.ux+10);
X
X    for (zx = lo_x; zx < hi_x; zx++)
X	for (zy = lo_y; zy < hi_y; zy++)
X	    show_map_spot(zx, zy);
X
X    if (!level.flags.hero_memory || Underwater) {
X	flush_screen(1);			/* flush temp screen */
X	display_nhwindow(WIN_MAP, TRUE);	/* wait */
X	docrt();
X    }
X}
X
X
XSTATIC_PTR void
Xfindone(zx,zy,num)
Xint zx,zy;
Xgenericptr_t num;
X{
X	register struct trap *ttmp;
X	register struct monst *mtmp;
X
X	if(levl[zx][zy].typ == SDOOR) {
X		levl[zx][zy].typ = DOOR;
X		newsym(zx, zy);
X		(*(int*)num)++;
X	} else if(levl[zx][zy].typ == SCORR) {
X		levl[zx][zy].typ = CORR;
X		newsym(zx, zy);
X		(*(int*)num)++;
X	} else if ((ttmp = t_at(zx, zy)) != 0) {
X		if(!ttmp->tseen && ttmp->ttyp != STATUE_TRAP) {
X			ttmp->tseen = 1;
X			newsym(zx,zy);
X			(*(int*)num)++;
X		}
X	} else if ((mtmp = m_at(zx, zy)) != 0) {
X		if(mtmp->m_ap_type) {
X			seemimic(mtmp);
X			(*(int*)num)++;
X		}
X		if (mtmp->mundetected && is_hider(mtmp->data)) {
X			mtmp->mundetected = 0;
X			newsym(zx, zy);
X			(*(int*)num)++;
X		}
X	}
X}
X
XSTATIC_PTR void
Xopenone(zx,zy,num)
Xint zx,zy;
Xgenericptr_t num;
X{
X	register struct trap *ttmp;
X	register struct obj *otmp;
X
X	if(OBJ_AT(zx, zy)) {
X		for(otmp = level.objects[zx][zy];
X				otmp; otmp = otmp->nexthere) {
X		    if(Is_box(otmp) && otmp->olocked) {
X			otmp->olocked = 0;
X			(*(int*)num)++;
X		    }
X		}
X		/* let it fall to the next cases. could be on trap. */
X	}
X	if(levl[zx][zy].typ == SDOOR || (levl[zx][zy].typ == DOOR &&
X		      (levl[zx][zy].doormask & (D_CLOSED|D_LOCKED)))) {
X		if(levl[zx][zy].typ == SDOOR)
X		    levl[zx][zy].typ = DOOR;
X		if(levl[zx][zy].doormask & D_TRAPPED) {
X		    if(distu(zx, zy) < 3) b_trapped("door");
X		    else Norep("You %s an explosion!",
X				cansee(zx, zy) ? "see" :
X				   (flags.soundok ? "hear" :
X						"feel the shock of"));
X		    levl[zx][zy].doormask = D_NODOOR;
X		} else
X		    levl[zx][zy].doormask = D_ISOPEN;
X		newsym(zx, zy);
X		(*(int*)num)++;
X	} else if(levl[zx][zy].typ == SCORR) {
X		levl[zx][zy].typ = CORR;
X		newsym(zx, zy);
X		(*(int*)num)++;
X	} else if ((ttmp = t_at(zx, zy)) != 0) {
X		if (!ttmp->tseen && ttmp->ttyp != STATUE_TRAP) {
X		    ttmp->tseen = 1;
X		    newsym(zx,zy);
X		    (*(int*)num)++;
X		}
X	} else if (find_drawbridge(&zx, &zy)) {
X		/* make sure it isn't an open drawbridge */
X		open_drawbridge(zx, zy);
X		(*(int*)num)++;
X	}
X}
X
Xint
Xfindit()	/* returns number of things found */
X{
X	int num = 0;
X
X	if(u.uswallow) return(0);
X	do_clear_area(u.ux, u.uy, BOLT_LIM, findone, (genericptr_t) &num);
X	return(num);
X}
X
Xint
Xopenit()	/* returns number of things found and opened */
X{
X	int num = 0;
X
X	if(u.uswallow) {
X		if (is_animal(u.ustuck->data)) {
X			if (Blind) pline("Its mouth opens!");
X			else pline("%s opens its mouth!", Monnam(u.ustuck));
X		}
X		expels(u.ustuck, u.ustuck->data, TRUE);
X		return(-1);
X	}
X
X	do_clear_area(u.ux, u.uy, BOLT_LIM, openone, (genericptr_t) &num);
X	return(num);
X}
X
Xint
Xdosearch0(aflag)
Xregister int aflag;
X{
X#ifdef GCC_BUG
X/* some versions of gcc seriously muck up nested loops. if you get strange
X   crashes while searching in a version compiled with gcc, try putting
X   #define GCC_BUG in *conf.h (or adding -DGCC_BUG to CFLAGS in the
X   makefile).
X */
X	volatile xchar x, y;
X#else
X	register xchar x, y;
X#endif
X	register struct trap *trap;
X	register struct monst *mtmp;
X	register struct obj *otmp;
X
X	if(u.uswallow) {
X		if (!aflag)
X			pline("What are you looking for?  The exit?");
X	} else {
X	    int fund = (uwep && uwep->oartifact &&
X		    spec_ability(uwep, SPFX_SEARCH)) ?
X			((uwep->spe > 5) ? 5 : uwep->spe) : 0;
X	    for(x = u.ux-1; x < u.ux+2; x++)
X	      for(y = u.uy-1; y < u.uy+2; y++) {
X		if(!isok(x,y)) continue;
X		if(x != u.ux || y != u.uy) {
X		    if (Blind && !aflag) feel_location(x,y);
X		    if(levl[x][y].typ == SDOOR) {
X			if(rnl(7-fund)) continue;
X			levl[x][y].typ = DOOR;
X			exercise(A_WIS, TRUE);
X			nomul(0);
X			if (Blind && !aflag)
X			    feel_location(x,y);	/* make sure it shows up */
X			else
X			    newsym(x,y);
X		    } else if(levl[x][y].typ == SCORR) {
X			if(rnl(7-fund)) continue;
X			levl[x][y].typ = CORR;
X			unblock_point(x,y);	/* vision */
X			exercise(A_WIS, TRUE);
X			nomul(0);
X			newsym(x,y);
X		    } else {
X		/* Be careful not to find anything in an SCORR or SDOOR */
X			if(!aflag && (mtmp = m_at(x, y))) {
X			    if(mtmp->m_ap_type) {
X				seemimic(mtmp);
X				exercise(A_WIS, TRUE);
X				if (!canseemon(mtmp) && !sensemon(mtmp))
X				    You("feel an invisible monster!");
X				else
X				    You("find %s.", a_monnam(mtmp));
X				return(1);
X			    }
X			    if(mtmp->mundetected && is_hider(mtmp->data)) {
X				mtmp->mundetected = 0;
X				newsym(x,y);
X				exercise(A_WIS, TRUE);
X				if (!canseemon(mtmp) && !sensemon(mtmp))
X				    You("feel an invisible monster!");
X				else
X				    You("find %s.", a_monnam(mtmp));
X				return(1);
X			    }
X			}
X
X			if ((trap = t_at(x,y)) && !trap->tseen && !rnl(8)) {
X			    nomul(0);
X
X			    if (trap->ttyp == STATUE_TRAP) {
X				if ((otmp = sobj_at(STATUE, x, y)) != 0) {
X				    mtmp = makemon(&mons[otmp->corpsenm], x, y);
X				    if (mtmp)
X					You("find %s posing as a statue.",
X						  a_monnam(mtmp));
X				    delobj(otmp);
X				    exercise(A_WIS, TRUE);
X				    if(Blind)
X					feel_location(x,y);
X				    else
X					newsym(x, y);
X				}
X				deltrap(trap);
X				return(1);
X			    } else {
X				You("find a%s.", traps[Hallucination ?
X					    rn1(TRAPNUM-3, 2) : trap->ttyp ]);
X				trap->tseen = 1;
X				exercise(A_WIS, TRUE);
X				if(Blind)
X				    feel_location(x,y);
X				else
X				    newsym(x,y);
X			    }
X			}
X		    }
X		}
X	    }
X	}
X	return(1);
X}
X
Xint
Xdosearch()
X{
X	return(dosearch0(0));
X}
X
X/*detect.c*/
END_OF_FILE
if test 24671 -ne `wc -c <'src/detect.c'`; then
    echo shar: \"'src/detect.c'\" unpacked with wrong size!
fi
# end of 'src/detect.c'
fi
if test -f 'src/mhitm.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/mhitm.c'\"
else
echo shar: Extracting \"'src/mhitm.c'\" \(27122 characters\)
sed "s/^X//" >'src/mhitm.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)mhitm.c	3.1	92/12/10	*/
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include "hack.h"
X#include "artifact.h"
X#include "edog.h"
X
X#ifdef OVLB
X
Xstatic boolean NEARDATA vis, NEARDATA far_noise;
Xstatic long NEARDATA noisetime;
Xstatic struct obj NEARDATA *otmp;
X
Xstatic void FDECL(mrustm, (struct monst *, struct monst *, struct obj *));
Xstatic int FDECL(hitmm, (struct monst *,struct monst *,struct attack *));
Xstatic int FDECL(gazemm, (struct monst *,struct monst *,struct attack *));
Xstatic int FDECL(gulpmm, (struct monst *,struct monst *,struct attack *));
Xstatic int FDECL(explmm, (struct monst *,struct monst *,struct attack *));
Xstatic int FDECL(mdamagem, (struct monst *,struct monst *,struct attack *));
Xstatic void FDECL(mswingsm, (struct monst *, struct monst *, struct obj *));
Xstatic void FDECL(noises,(struct monst *,struct attack *));
Xstatic void FDECL(missmm,(struct monst *,struct monst *,struct attack *));
Xstatic int FDECL(passivemm, (struct monst *, struct monst *, BOOLEAN_P, int));
X
X/* Needed for the special case of monsters wielding vorpal blades (rare).
X * If we use this a lot it should probably be a parameter to mdamagem()
X * instead of a global variable.
X */
Xstatic int dieroll;
X
Xstatic void
Xnoises(magr, mattk)
X	register struct monst *magr;
X	register struct	attack *mattk;
X{
X	boolean farq = (distu(magr->mx, magr->my) > 15);
X
X	if(flags.soundok && (farq != far_noise || moves-noisetime > 10)) {
X		far_noise = farq;
X		noisetime = moves;
X		You("hear %s%s.",
X			(mattk->aatyp == AT_EXPL) ? "an explosion" : "some noises",
X			farq ? " in the distance" : "");
X	}
X}
X
Xstatic
Xvoid
Xmissmm(magr, mdef, mattk)
X	register struct monst *magr, *mdef;
X	struct attack *mattk;
X{
X	const char *fmt;
X	char buf[BUFSZ];
X
X	if (vis) {
X		if (mdef->m_ap_type) seemimic(mdef);
X		if (magr->m_ap_type) seemimic(magr);
X		fmt = (could_seduce(magr,mdef,mattk) && !magr->mcan) ?
X			"%s pretends to be friendly to" : "%s misses";
X		Sprintf(buf, fmt, Monnam(magr));
X		pline("%s %s.", buf, mon_nam(mdef));
X	} else  noises(magr, mattk);
X}
X
X/*
X *  fightm()  -- fight some other monster
X *
X *  Returns:
X *	0 - Monster did nothing.
X *	1 - If the monster made an attack.  The monster might have died.
X *
X *  There is an exception to the above.  If mtmp has the hero swallowed,
X *  then we report that the monster did nothing so it will continue to
X *  digest the hero.
X */
Xint
Xfightm(mtmp)		/* have monsters fight each other */
X	register struct monst *mtmp;
X{
X	register struct monst *mon, *nmon;
X	int result, has_u_swallowed;
X#ifdef LINT
X	nmon = 0;
X#endif
X	/* perhaps the monster will resist Conflict */
X	if(resist(mtmp, RING_CLASS, 0, 0))
X	    return(0);
X#ifdef POLYSELF
X	if(u.ustuck == mtmp) {
X	    /* perhaps we're holding it... */
X	    if(itsstuck(mtmp))
X		return(0);
X	}
X#endif
X	has_u_swallowed = (u.uswallow && (mtmp == u.ustuck));
X
X	for(mon = fmon; mon; mon = nmon) {
X	    nmon = mon->nmon;
X	    if(nmon == mtmp) nmon = mtmp->nmon;
X	    if(mon != mtmp) {
X		if(monnear(mtmp,mon->mx,mon->my)) {
X		    if(!u.uswallow && (mtmp == u.ustuck)) {
X			if(!rn2(4)) {
X			    pline("%s releases you!", Monnam(mtmp));
X			    u.ustuck = 0;
X			} else
X			    break;
X		    }
X
X		    /* mtmp can be killed */
X		    bhitpos.x = mon->mx;
X		    bhitpos.y = mon->my;
X		    result = mattackm(mtmp,mon);
X
X		    if (result & MM_AGR_DIED) return 1;	/* mtmp died */
X		    /*
X		     *  If mtmp has the hero swallowed, lie and say there
X		     *  was no attack (this allows mtmp to digest the hero).
X		     */
X		    if (has_u_swallowed) return 0;
X
X		    return ((result & MM_HIT) ? 1 : 0);
X		}
X	    }
X	}
X	return 0;
X}
X
X/*
X * mattackm() -- a monster attacks another monster.
X *
X * This function returns a result bitfield:
X *	   
X *	    --------- agressor died
X *	   /  ------- defender died
X *	  /  /  ----- defender was hit
X *	 /  /  /
X *	x  x  x
X *
X *	0x4	MM_AGR_DIED
X *	0x2	MM_DEF_DIED
X *	0x1	MM_HIT
X *	0x0	MM_MISS
X *
X * Each successive attack has a lower probability of hitting.  Some rely on the
X * success of previous attacks.  ** this doen't seem to be implemented -dl **
X *
X * In the case of exploding monsters, the monster dies as well.
X */
Xint
Xmattackm(magr, mdef)
X    register struct monst *magr,*mdef;
X{
X    int		    i,		/* loop counter */
X		    tmp,	/* amour class difference */
X		    strike,	/* hit this attack */
X		    attk,	/* attack attempted this time */
X		    struck = 0,	/* hit at least once */
X		    res[NATTK];	/* results of all attacks */
X    struct attack   *mattk;
X    struct permonst *pa, *pd;
X
X    if (!magr || !mdef) return(MM_MISS);		/* mike@genat */
X    pa = magr->data; pd = mdef->data;
X    if (!magr->mcanmove) return(MM_MISS);		/* riv05!a3 */
X
X    /* Grid bugs cannot attack at an angle. */
X    if (pa == &mons[PM_GRID_BUG] && magr->mx != mdef->mx
X						&& magr->my != mdef->my)
X	return(MM_MISS);
X
X    /* Calculate the armour class differential. */
X    tmp = find_mac(mdef) + magr->m_lev;
X    if (mdef->mconf || !mdef->mcanmove || mdef->msleep){
X	tmp += 4;
X	if (mdef->msleep) mdef->msleep = 0;
X    }
X
X    /* undetect monsters become un-hidden if they are attacked */
X    if (mdef->mundetected) {
X	mdef->mundetected = 0;
X	newsym(mdef->mx, mdef->my);
X	if(canseemon(mdef))
X	    pline("Suddenly, you notice %s.", a_monnam(mdef));
X    }
X
X    /* Elves hate orcs. */
X    if (is_elf(pa) && is_orc(pd)) tmp++;
X
X
X    /* Set up the visibility of action */
X    vis = (cansee(magr->mx,magr->my) && cansee(mdef->mx,mdef->my));
X
X    /*	Set flag indicating monster has moved this turn.  Necessary since a
X     *	monster might get an attack out of sequence (i.e. before its move) in
X     *	some cases, in which case this still counts as its move for the round
X     *	and it shouldn't move again.
X     */
X    magr->mlstmv = monstermoves;
X
X    /* Now perform all attacks for the monster. */
X    for (i = 0; i < NATTK; i++) {
X	res[i] = MM_MISS;
X	mattk = &(pa->mattk[i]);
X	otmp = (struct obj *)0;
X	attk = 1;
X	switch (mattk->aatyp) {
X	    case AT_WEAP:		/* "hand to hand" attacks */
X#ifdef MUSE
X		if (magr->weapon_check == NEED_WEAPON || !MON_WEP(magr)) {
X			magr->weapon_check = NEED_HTH_WEAPON;
X			if (mon_wield_item(magr) != 0) return 0;
X		}
X		otmp = MON_WEP(magr);
X#else
X		otmp = select_hwep(magr);
X#endif
X		if (otmp) {
X		    if (vis) mswingsm(magr, mdef, otmp);
X		    tmp += hitval(otmp, pd);
X		}
X		/* fall through */
X	    case AT_CLAW:
X	    case AT_KICK:
X	    case AT_BITE:
X	    case AT_STNG:
X	    case AT_TUCH:
X	    case AT_BUTT:
X	    case AT_TENT:
X		dieroll = rnd(20 + i);
X		strike = (tmp > dieroll);
X		if (strike)
X		    res[i] = hitmm(magr, mdef, mattk);
X		else
X		    missmm(magr, mdef, mattk);
X		break;
X
X	    case AT_HUGS:	/* automatic if prev two attacks succeed */
X		strike = (i >= 2 && res[i-1] == MM_HIT && res[i-2] == MM_HIT);
X		if (strike)
X		    res[i] = hitmm(magr, mdef, mattk);
X
X		break;
X
X	    case AT_GAZE:
X		strike = 0;	/* will not wake up a sleeper */
X		res[i] = gazemm(magr, mdef, mattk);
X		break;
X
X	    case AT_EXPL:
X		strike = 1;	/* automatic hit */
X		res[i] = explmm(magr, mdef, mattk);
X		break;
X
X	    case AT_ENGL:
X		/* Engulfing attacks are directed at the hero if
X		 * possible. -dlc
X		 */
X		if (u.uswallow && magr == u.ustuck)
X		    strike = 0;
X		else {
X		    if ((strike = (tmp > rnd(20+i))))
X			res[i] = gulpmm(magr, mdef, mattk);
X		    else
X			missmm(magr, mdef, mattk);
X		}
X		break;
X
X	    default:		/* no attack */
X		strike = 0;
X		attk = 0;
X		break;
X	}
X
X	if (attk && !(res[i] & MM_AGR_DIED))
X	    res[i] = passivemm(magr, mdef, strike, res[i] & MM_DEF_DIED);
X
X	if (res[i] & MM_DEF_DIED) return res[i];
X
X	/*
X	 *  Wake up the defender.  NOTE:  this must follow the check
X	 *  to see if the defender died.  We don't want to modify
X	 *  unallocated monsters!
X	 */
X	if (strike) mdef->msleep = 0;
X
X	if (res[i] & MM_AGR_DIED)  return res[i];
X	/* return if aggressor can no longer attack */
X	if (!magr->mcanmove || magr->msleep) return res[i];
X	if (res[i] & MM_HIT) struck = 1;	/* at least one hit */
X    }
X
X    return(struck ? MM_HIT : MM_MISS);
X}
X
X/* Returns the result of mdamagem(). */
Xstatic int
Xhitmm(magr, mdef, mattk)
X	register struct monst *magr,*mdef;
X	struct	attack *mattk;
X{
X	if(vis){
X		int compat;
X		char buf[BUFSZ];
X
X		if(mdef->m_ap_type) seemimic(mdef);
X		if(magr->m_ap_type) seemimic(magr);
X		if((compat = could_seduce(magr,mdef,mattk)) && !magr->mcan) {
X			Sprintf(buf, "%s %s", Monnam(magr),
X				mdef->mcansee ? "smiles at" : "talks to");
X			pline("%s %s %s.", buf, mon_nam(mdef),
X				compat == 2 ?
X					"engagingly" : "seductively");
X		} else {
X		    char magr_name[BUFSZ];
X
X		    Strcpy(magr_name, Monnam(magr));
X		    switch (mattk->aatyp) {
X			case AT_BITE:
X				Sprintf(buf,"%s bites", magr_name);
X				break;
X			case AT_STNG:
X				Sprintf(buf,"%s stings", magr_name);
X				break;
X			case AT_BUTT:
X				Sprintf(buf,"%s butts", magr_name);
X				break;
X			case AT_TUCH:
X				Sprintf(buf,"%s touches", magr_name);
X				break;
X			case AT_TENT:
X				Sprintf(buf, "%s tentacles suck",
X					s_suffix(magr_name));
X				break;
X			case AT_HUGS:
X				if (magr != u.ustuck) {
X				    Sprintf(buf,"%s squeezes", magr_name);
X				    break;
X				}
X			default:
X				Sprintf(buf,"%s hits", magr_name);
X		    }
X		}
X		pline("%s %s.", buf, mon_nam(mdef));
X	} else  noises(magr, mattk);
X	return(mdamagem(magr, mdef, mattk));
X}
X
X/* Returns the same values as mdamagem(). */
Xstatic int
Xgazemm(magr, mdef, mattk)
X	register struct monst *magr, *mdef;
X	struct attack *mattk;
X{
X	char buf[BUFSZ];
X
X	if(vis) {
X		Sprintf(buf,"%s gazes at", Monnam(magr));
X		pline("%s %s.", buf, mon_nam(mdef));
X	}
X
X	if (!mdef->mcansee || mdef->msleep) {
X	    if(vis) pline("but nothing happens.");
X	    return(MM_MISS);
X	}
X
X	return(mdamagem(magr, mdef, mattk));
X}
X
X/* Returns the same values as mattackm(). */
Xstatic int
Xgulpmm(magr, mdef, mattk)
X	register struct monst *magr, *mdef;
X	register struct	attack *mattk;
X{
X	xchar	ax, ay, dx, dy;
X	int	status;
X	char buf[BUFSZ];
X
X	if (mdef->data->msize >= MZ_HUGE) return MM_MISS;
X
X	if (vis) {
X		Sprintf(buf,"%s swallows", Monnam(magr));
X		pline("%s %s.", buf, mon_nam(mdef));
X	}
X
X	/*
X	 *  All of this maniuplation is needed to keep the display correct.
X	 *  There is a flush at the next pline().
X	 */
X	ax = magr->mx;
X	ay = magr->my;
X	dx = mdef->mx;
X	dy = mdef->my;
X	/*
X	 *  Leave the defender in the monster chain at it's current position,
X	 *  but don't leave it on the screen.  Move the agressor to the def-
X	 *  ender's position.
X	 */
X	remove_monster(ax, ay);
X	place_monster(magr, dx, dy);
X	newsym(ax,ay);			/* erase old position */
X	newsym(dx,dy);			/* update new position */
X
X	status = mdamagem(magr, mdef, mattk);
X
X	if ((status & MM_AGR_DIED) && (status & MM_DEF_DIED)) {
X	    ;					/* both died -- do nothing  */
X	}
X	else if (status & MM_DEF_DIED) {	/* defender died */
X	    /*
X	     *  Note:  remove_monster() was called in relmon(), wiping out
X	     *  magr from level.monsters[mdef->mx][mdef->my].  We need to
X	     *  put it back and display it.	-kd
X	     */
X	    place_monster(magr, dx, dy);
X	    newsym(dx, dy);
X	}
X	else if (status & MM_AGR_DIED) {	/* agressor died */
X	    place_monster(mdef, dx, dy);
X	    newsym(dx, dy);
X	}
X	else {					/* both alive, put them back */
X	    if (cansee(dx, dy))
X		pline("%s is regurgitated!", Monnam(mdef));
X
X	    place_monster(magr, ax, ay);
X	    place_monster(mdef, dx, dy);
X	    newsym(ax, ay);
X	    newsym(dx, dy);
X	}
X
X	return status;
X}
X
Xstatic int
Xexplmm(magr, mdef, mattk)
X	register struct monst *magr, *mdef;
X	register struct	attack *mattk;
X{
X	int result, was_tame;
X
X	if(cansee(magr->mx, magr->my))
X		pline("%s explodes!", Monnam(magr));
X	else	noises(magr, mattk);
X
X	was_tame = magr->mtame;
X	result = mdamagem(magr, mdef, mattk);
X
X	/* The attacker could have died . . */
X	if (was_tame)
X	    You("have a sad feeling for a moment, then it passes.");
X
X	/* Kill off agressor if it didn't die. */
X	if (!(result & MM_AGR_DIED)) {
X	    mondead(magr);
X	    result |= MM_AGR_DIED;
X	}
X
X	return result;
X}
X
Xstatic const char psf[] =
X	"have a peculiarly sad feeling for a moment, then it passes.";
X
X/*
X *  See comment at top of mattackm(), for return values.
X */
Xstatic int
Xmdamagem(magr, mdef, mattk)
X	register struct monst	*magr, *mdef;
X	register struct attack	*mattk;
X{
X	struct	permonst *pa = magr->data, *pd = mdef->data;
X	int	tmp = d((int)mattk->damn,(int)mattk->damd);
X	char buf[BUFSZ];
X
X	if (pd == &mons[PM_COCKATRICE] && !resists_ston(pa) &&
X	   (mattk->aatyp != AT_WEAP || !otmp) &&
X	   (mattk->aatyp != AT_GAZE && mattk->aatyp != AT_EXPL) &&
X#ifdef MUSE
X	   (!which_armor(magr, W_ARMG))) {
X#else
X	   (!is_mercenary(pa) || !m_carrying(magr, LEATHER_GLOVES))) {
X	   /* Note: other monsters may carry gloves, only soldiers have them */
X	   /* as their "armor" and can be said to wear them */
X#endif
X		if (poly_when_stoned(pa)) {
X		    mon_to_stone(magr);
X		    return MM_HIT; /* no damage during the polymorph */
X		}
X		if (vis) pline("%s turns to stone!", Monnam(magr));
X		else if (magr->mtame) You(psf);
X		monstone(magr);
X		return MM_AGR_DIED;
X	}
X
X	switch(mattk->adtyp) {
X	    case AD_DGST:
X		if(flags.verbose && flags.soundok) verbalize("Burrrrp!");
X		tmp = mdef->mhp;
X		break;
X	    case AD_STUN:
X		if (magr->mcan) break;
X		if(vis) pline("%s staggers for a moment.", Monnam(mdef));
X		mdef->mstun = 1;
X		/* fall through */
X	    case AD_WERE:
X	    case AD_HEAL:
X	    case AD_LEGS:
X	    case AD_PHYS:
X		if (mattk->aatyp == AT_KICK && thick_skinned(pd))
X			tmp = 0;
X		else if(mattk->aatyp == AT_WEAP) {
X		    if(otmp) {
X			tmp += dmgval(otmp, pd);
X			if (otmp->oartifact) {
X			    (void)artifact_hit(magr,mdef, otmp, &tmp, dieroll);
X			    if (mdef->mhp <= 0)
X				return (MM_DEF_DIED |
X					(grow_up(magr,mdef) ? 0 : MM_AGR_DIED));
X			}
X			if (tmp)
X				mrustm(magr, mdef, otmp);
X		    }
X		}
X		break;
X	    case AD_FIRE:
X		if (magr->mcan) {
X		    tmp = 0;
X		    break;
X		}
X		if(vis) pline("%s is on fire!", Monnam(mdef));
X		tmp += destroy_mitem(mdef, SCROLL_CLASS, AD_FIRE);
X		tmp += destroy_mitem(mdef, SPBOOK_CLASS, AD_FIRE);
X		if(resists_fire(pd)) {
X		    if (vis)
X			pline("The fire doesn't seem to burn %s!",
X								mon_nam(mdef));
X		    shieldeff(mdef->mx, mdef->my);
X		    golemeffects(mdef, AD_FIRE, tmp);
X		    tmp = 0;
X		}
X		/* only potions damage resistant players in destroy_item */
X		tmp += destroy_mitem(mdef, POTION_CLASS, AD_FIRE);
X		break;
X	    case AD_COLD:
X		if (magr->mcan) {
X		    tmp = 0;
X		    break;
X		}
X		if(vis) pline("%s is covered in frost!", Monnam(mdef));
X		if(resists_cold(pd)) {
X		    if (vis)
X			pline("The frost doesn't seem to chill %s!",
X								mon_nam(mdef));
X		    shieldeff(mdef->mx, mdef->my);
X		    golemeffects(mdef, AD_COLD, tmp);
X		    tmp = 0;
X		}
X		tmp += destroy_mitem(mdef, POTION_CLASS, AD_COLD);
X		break;
X	    case AD_ELEC:
X		if (magr->mcan) {
X		    tmp = 0;
X		    break;
X		}
X		if(vis) pline("%s gets zapped!", Monnam(mdef));
X		tmp += destroy_mitem(mdef, WAND_CLASS, AD_ELEC);
X		if(resists_elec(pd)) {
X		    if (vis) pline("The zap doesn't shock %s!", mon_nam(mdef));
X		    shieldeff(mdef->mx, mdef->my);
X		    golemeffects(mdef, AD_ELEC, tmp);
X		    tmp = 0;
X		}
X		/* only rings damage resistant players in destroy_item */
X		tmp += destroy_mitem(mdef, RING_CLASS, AD_ELEC);
X		break;
X	    case AD_ACID:
X		if (magr->mcan) {
X		    tmp = 0;
X		    break;
X		}
X		if(resists_acid(pd)) {
X		    if (vis)
X			pline("%s is covered in acid, but it seems harmless.",
X							Monnam(mdef));
X		    tmp = 0;
X		} else if (vis) {
X		    pline("%s is covered in acid!", Monnam(mdef));
X		    pline("It burns %s!", mon_nam(mdef));
X		}
X		break;
X	    case AD_RUST:
X		if (!magr->mcan && pd == &mons[PM_IRON_GOLEM]) {
X			if (vis) pline("%s falls to pieces!", Monnam(mdef));
X			else if(mdef->mtame)
X			     pline("May %s rust in peace.", mon_nam(mdef));
X			mondied(mdef);
X			return (MM_DEF_DIED | (grow_up(magr,mdef) ?
X							0 : MM_AGR_DIED));
X		}
X		tmp = 0;
X		break;
X	    case AD_DCAY:
X		if (!magr->mcan && (pd == &mons[PM_WOOD_GOLEM] ||
X		    pd == &mons[PM_LEATHER_GOLEM])) {
X			if (vis) pline("%s falls to pieces!", Monnam(mdef));
X			else if(mdef->mtame)
X			     pline("May %s rot in peace.", mon_nam(mdef));
X			mondied(mdef);
X			return (MM_DEF_DIED | (grow_up(magr,mdef) ?
X							0 : MM_AGR_DIED));
X		}
X		tmp = 0;
X		break;
X	    case AD_STON:
X		if(poly_when_stoned(pd)) {
X		    mon_to_stone(mdef);
X		    tmp = 0;
X		    break;
X		}
X		if(!resists_ston(pd)) {
X			if(vis) pline("%s turns to stone!", Monnam(mdef));
X			else if(mdef->mtame) You(psf);
X			monstone(mdef);
X			return (MM_DEF_DIED | (grow_up(magr,mdef) ?
X							0 : MM_AGR_DIED));
X		}
X		tmp = 0;	/* no damage if this fails */
X		break;
X	    case AD_TLPT:
X		if(!magr->mcan && tmp < mdef->mhp) {
X		    rloc(mdef);
X		    if(vis && !cansee(mdef->mx, mdef->my))
X			pline("%s suddenly disappears!", Monnam(mdef));
X		}
X		break;
X	    case AD_SLEE:
X		if(!resists_sleep(pd) && !magr->mcan && !mdef->msleep
X							&& mdef->mcanmove) {
X		    if (vis) {
X			Strcpy(buf, Monnam(mdef));
X			pline("%s is put to sleep by %s.", buf, mon_nam(magr));
X		    }
X		    mdef->mcanmove = 0;
X		    mdef->mfrozen = rnd(10);
X		}
X		break;
X	    case AD_PLYS:
X		if(!magr->mcan && mdef->mcanmove) {
X		    if (vis) {
X			Strcpy(buf, Monnam(mdef));
X			pline("%s is frozen by %s.", buf, mon_nam(magr));
X		    }
X		    mdef->mcanmove = 0;
X		    mdef->mfrozen = rnd(10);
X		}
X		break;
X	    case AD_SLOW:
X		if(!magr->mcan && vis && mdef->mspeed != MSLOW) {
X		    if (vis) pline("%s slows down.", Monnam(mdef));
X		    if (mdef->mspeed == MFAST) mdef->mspeed = 0;
X		    else mdef->mspeed = MSLOW;
X		}
X		break;
X	    case AD_CONF:
X		/* Since confusing another monster doesn't have a real time
X		 * limit, setting spec_used would not really be right (though
X		 * we still should check for it).
X		 */
X		if (!magr->mcan && vis && !mdef->mconf && !magr->mspec_used) {
X		    pline("%s looks confused.", Monnam(mdef));
X		    mdef->mconf = 1;
X		}
X		break;
X	    case AD_BLND:
X		if (!magr->mcan && haseyes(pd)) {
X		    register unsigned rnd_tmp;
X
X		    if (vis && mdef->mcansee)
X			pline("%s is blinded.", Monnam(mdef));
X		    rnd_tmp = d((int)mattk->damn, (int)mattk->damd);
X		    if ((rnd_tmp += mdef->mblinded) > 127) rnd_tmp = 127;
X		    mdef->mblinded = rnd_tmp;
X		    mdef->mcansee = 0;
X		}
X		tmp = 0;
X		break;
X	    case AD_CURS:
X		if (!night() && (pa == &mons[PM_GREMLIN])) break;
X		if (!magr->mcan && !rn2(10)) {
X		    if (is_were(pd) && pd->mlet != S_HUMAN)
X			were_change(mdef);
X		    if (pd == &mons[PM_CLAY_GOLEM]) {
X			    if (vis) {
X				pline("Some writing vanishes from %s head!",
X				    s_suffix(mon_nam(mdef)));
X				pline("%s dies!", Monnam(mdef));
X			    }
X			    else if (mdef->mtame)
X	You("have a strangely sad feeling for a moment, then it passes.");
X			    mondied(mdef);
X			    return (MM_DEF_DIED | (grow_up(magr,mdef) ?
X							0 : MM_AGR_DIED));
X		      }
X		    mdef->mcan = 1;
X		    if (flags.soundok) {
X			    if (!vis) You("hear laughter.");
X			    else pline("%s chuckles.", Monnam(magr));
X		    }
X		}
X		break;
X	    case AD_SGLD:
X		tmp = 0;
X		if (magr->mcan || !mdef->mgold) break;
X		/* technically incorrect; no check for stealing gold from
X		 * between mdef's feet...
X		 */
X		magr->mgold += mdef->mgold;
X		mdef->mgold = 0;
X		if (vis) {
X			Strcpy(buf, Monnam(magr));
X			pline("%s steals some gold from %s.", buf,
X								mon_nam(mdef));
X		}
X		break;
X	    case AD_DRLI:
X		if(rn2(2) && !resists_drli(pd)) {
X			tmp = d(2,6);
X			if (vis)
X			    pline("%s suddenly seems weaker!", Monnam(mdef));
X			mdef->mhpmax -= tmp;
X			if (mdef->m_lev == 0)
X				tmp = mdef->mhp;
X			else mdef->m_lev--;
X			/* Automatic kill if drained past level 0 */
X		}
X		break;
X#ifdef SEDUCE
X	    case AD_SSEX:
X#endif
X	    case AD_SITM:	/* for now these are the same */
X	    case AD_SEDU:
X		if (!magr->mcan && mdef->minvent) {
X		   	otmp = mdef->minvent;
X			mdef->minvent = otmp->nobj;
X			otmp->nobj = magr->minvent;
X			magr->minvent = otmp;
X			if (vis) {
X				Strcpy(buf, Monnam(magr));
X				pline("%s steals %s from %s!", buf,
X						doname(otmp), mon_nam(mdef));
X			}
X#ifdef MUSE
X			possibly_unwield(mdef);
X			if (otmp->owornmask) {
X				mdef->misc_worn_check &= ~otmp->owornmask;
X				otmp->owornmask = 0;
X			}
X#endif
X		}
X		tmp = 0;
X		break;
X	    case AD_DRST:
X	    case AD_DRDX:
X	    case AD_DRCO:
X		if (!magr->mcan && !rn2(8)) {
X		    if (vis)
X			pline("%s %s was poisoned!", s_suffix(Monnam(magr)),
X				mattk->aatyp==AT_BITE ? "bite" : "sting");
X		    if (resists_poison(pd)) {
X			if (vis)
X			    pline("The poison doesn't seem to affect %s.",
X				mon_nam(mdef));
X		    } else {
X			if (rn2(10)) tmp += rn1(10,6);
X			else {
X			    if (vis) pline("The poison was deadly...");
X			    tmp = mdef->mhp;
X			}
X		    }
X		}
X		break;
X	    case AD_DRIN:
X		if (!has_head(pd)) {
X		    if (vis) pline("%s doesn't seem harmed.", Monnam(mdef));
X		    tmp = 0;
X		    break;
X		}
X#ifdef MUSE
X		if ((mdef->misc_worn_check & W_ARMH) && rn2(8)) {
X		    if (vis) {
X			Strcpy(buf, s_suffix(Monnam(mdef)));
X			pline("%s helmet blocks %s attack to his head.",
X				buf, s_suffix(mon_nam(magr)));
X		    }
X		    break;
X		}
X#endif
X		if (vis) pline("%s brain is eaten!", s_suffix(Monnam(mdef)));
X		if (mindless(pd)) {
X		    if (vis) pline("%s doesn't notice.", Monnam(mdef));
X		    break;
X		}
X		tmp += rnd(10); /* fakery, since monsters lack INT scores */
X		if (magr->mtame && !magr->isminion) {
X		    EDOG(magr)->hungrytime += rnd(60);
X		    magr->mconf = 0;
X		}
X		if (tmp >= mdef->mhp && vis)
X		    pline("%s last thought fades away...", 
X			          s_suffix(Monnam(mdef)));
X		break;
X	    case AD_STCK:
X	    case AD_WRAP: /* monsters cannot grab one another, it's too hard */
X		break;
X	    default:	tmp = 0;
X			break;
X	}
X	if(!tmp) return(MM_MISS);
X
X	if((mdef->mhp -= tmp) < 1) {
X	    if (m_at(mdef->mx, mdef->my) == magr) {  /* see gulpmm() */
X		remove_monster(mdef->mx, mdef->my);
X		place_monster(mdef, mdef->mx, mdef->my);
X	    }
X	    monkilled(mdef, "", mattk->adtyp);
X	    return (MM_DEF_DIED | (grow_up(magr,mdef) ? 0 : MM_AGR_DIED));
X	}
X	return(MM_HIT);
X}
X
X#endif /* OVLB */
X
X
X#ifdef OVL0
X
Xint
Xnoattacks(ptr)			/* returns 1 if monster doesn't attack */
X	struct	permonst *ptr;
X{
X	int i;
X
X	for(i = 0; i < NATTK; i++)
X		if(ptr->mattk[i].aatyp) return(0);
X
X	return(1);
X}
X
X#endif /* OVL0 */
X#ifdef OVLB
X
Xstatic void
Xmrustm(magr, mdef, obj)
Xregister struct monst *magr, *mdef;
Xregister struct obj *obj;
X{
X	if (!magr || !mdef || !obj) return; /* just in case */
X	if (mdef->data == &mons[PM_RUST_MONSTER] && !mdef->mcan &&
X	    is_rustprone(obj) && obj->oeroded < MAX_ERODE) {
X		if (obj->greased || obj->oerodeproof || (obj->blessed && rn2(3))) {
X		    if (cansee(mdef->mx, mdef->my) && flags.verbose)
X			pline("%s weapon is not affected.", 
X			                 s_suffix(Monnam(magr)));
X		    if (obj->greased && !rn2(2)) obj->greased = 0;
X		} else {
X		    if (cansee(mdef->mx, mdef->my)) {
X			pline("%s %s%s!", s_suffix(Monnam(magr)),
X			      aobjnam(obj, "rust"),
X			      obj->oeroded ? " further" : "");
X		    }
X		    obj->oeroded++;
X		}
X	}
X}
X
Xstatic void
Xmswingsm(magr, mdef, otemp)
Xregister struct monst *magr, *mdef;
Xregister struct obj *otemp;
X{
X	char buf[BUFSZ];
X	Strcpy(buf, mon_nam(mdef));
X	if (!flags.verbose || Blind || otemp->oclass != WEAPON_CLASS) return;
X	pline("%s %s %s %s at %s.", Monnam(magr),
X	      ((otemp->otyp >= SPEAR &&
X	        otemp->otyp <= LANCE) ||
X	       (otemp->otyp >= PARTISAN &&
X	        otemp->otyp <= SPETUM) ||
X	       otemp->otyp == TRIDENT) ? "thrusts" : "swings",
X	      humanoid(magr->data) ? (magr->female ? "her" : "his") : "its",
X	      xname(otemp), buf);
X}
X
X/*
X * Passive responses by defenders.  Does not replicate responses already
X * handled above.  Returns same values as mattackm.
X */
Xstatic int
Xpassivemm(magr,mdef,mhit,mdead)
Xregister struct monst *magr, *mdef;
Xboolean mhit;
Xint mdead;
X{
X	register struct permonst *mddat = mdef->data;
X	register struct permonst *madat = magr->data;
X	char buf[BUFSZ];
X	int i, tmp;
X
X	for(i = 0; ; i++) {
X	    if(i >= NATTK) return (mdead | mhit); /* no passive attacks */
X	    if(mddat->mattk[i].aatyp == AT_NONE) break;
X	}
X	if (mddat->mattk[i].damn)
X	    tmp = d((int)mddat->mattk[i].damn, 
X                                    (int)mddat->mattk[i].damd);
X	else if(mddat->mattk[i].damd)
X	    tmp = d((int)mddat->mlevel+1, (int)mddat->mattk[i].damd);
X	else
X	    tmp = 0;
X
X	/* These affect the enemy even if defender killed */
X	switch(mddat->mattk[i].adtyp) {
X	    case AD_ACID:
X		if (mhit && !rn2(2)) {
X		    Strcpy(buf, Monnam(magr));
X		    if(canseemon(magr))
X			pline("%s is splashed by %s acid!",
X			      buf, s_suffix(mon_nam(mdef)));
X		    if(resists_acid(madat)) {
X			if(canseemon(magr))
X			    pline("%s is not affected.", Monnam(magr));
X			tmp = 0;
X		    }
X		} else tmp = 0;
X		goto assess_dmg;
X	    default:
X		break;
X	}
X	if (mdead || mdef->mcan) return (mdead|mhit);
X
X	/* These affect the enemy only if defender is still alive */
X	if (rn2(3)) switch(mddat->mattk[i].adtyp) {
X	    case AD_PLYS: /* Floating eye */
X		if (mddat == &mons[PM_FLOATING_EYE]) {
X		    if (magr->mcansee && haseyes(madat) && mdef->mcansee &&
X			(perceives(madat) || !mdef->minvis)) {
X			Strcpy(buf, Monnam(magr));
X			if(canseemon(magr))
X			    pline("%s is frozen by %s gaze!",
X				  buf, s_suffix(mon_nam(mdef)));
X			magr->mcanmove = 0;
X			magr->mfrozen = tmp;
X			return (mdead|mhit);
X		    }
X		} else { /* gelatinous cube */
X		    Strcpy(buf, Monnam(magr));
X		    if(canseemon(magr))
X			pline("%s is frozen by %s.", buf, mon_nam(mdef));
X		    magr->mcanmove = 0;
X		    magr->mfrozen = tmp;
X		    return (mdead|mhit);
X		}
X		return 1;
X	    case AD_COLD:
X		if (resists_cold(madat)) {
X		    if (canseemon(magr)) {
X			pline("%s is mildly chilly.", Monnam(magr));
X			golemeffects(magr, AD_COLD, tmp);
X			tmp = 0;
X			break;
X		    }
X		}
X		if(canseemon(magr))
X		    pline("%s is suddenly very cold!", Monnam(magr));
X		mdef->mhp += tmp / 2;
X		if (mdef->mhpmax < mdef->mhp) mdef->mhpmax = mdef->mhp;
X		if (mdef->mhpmax > ((int) (mdef->m_lev+1) * 8)) {
X		    register struct monst *mtmp;
X
X		    if ((mtmp = clone_mon(mdef)) != 0) {
X			mtmp->mhpmax = mdef->mhpmax /= 2;
X			if(canseemon(magr)) {
X			    Strcpy(buf, Monnam(mdef));
X			    pline("%s multiplies from %s heat!",
X				    buf, s_suffix(mon_nam(magr)));
X			}
X		    }
X		}
X		break;
X	    case AD_STUN:
X		if (!magr->mstun) {
X		    magr->mstun = 1;
X		    if (canseemon(magr))
X			pline("%s staggers....", Monnam(magr));
X		}
X		tmp = 0;
X		break;
X	    case AD_FIRE:
X		if (resists_fire(madat)) {
X		    if (canseemon(magr)) {
X			pline("%s is mildly warmed.", Monnam(magr));
X			golemeffects(magr, AD_FIRE, tmp);
X			tmp = 0;
X			break;
X		    }
X		}
X		if(canseemon(magr))
X		    pline("%s is suddenly very hot!", Monnam(magr));
X		break;
X	    case AD_ELEC:
X		if (resists_elec(madat)) {
X		    if (canseemon(magr)) {
X			pline("%s is mildly tingled.", Monnam(magr));
X			golemeffects(magr, AD_ELEC, tmp);
X			tmp = 0;
X			break;
X		    }
X		}
X		if(canseemon(magr))
X		    pline("%s is jolted with electricity!", Monnam(magr));
X		break;
X	    default: tmp = 0;
X		break;
X	}
X	else tmp = 0;
X
X    assess_dmg:
X	if((magr->mhp -= tmp) <= 0) {
X		monkilled(magr,"",mddat->mattk[i].adtyp);
X		return (mdead | mhit | MM_AGR_DIED);
X	}
X	return (mdead | mhit);
X}
X
X#endif /* OVLB */
X
X/*mhitm.c*/
END_OF_FILE
if test 27122 -ne `wc -c <'src/mhitm.c'`; then
    echo shar: \"'src/mhitm.c'\" unpacked with wrong size!
fi
# end of 'src/mhitm.c'
fi
echo shar: End of archive 79 \(of 108\).
cp /dev/null ark79isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \
21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \
41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 \
61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 \
81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 \
101 102 103 104 105 106 107 108 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 108 archives.
    echo "Now execute 'rebuild.sh'"
    rm -f ark10[0-8]isdone ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
