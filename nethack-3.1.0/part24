Path: uunet!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v16i024:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Part24/108
Message-ID: <4312@master.CNA.TEK.COM>
Date: 29 Jan 93 20:44:32 GMT
Sender: news@master.CNA.TEK.COM
Lines: 2457
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1581

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 16, Issue 24
Archive-name: nethack31/Part24
Supersedes: nethack3p9: Volume 10, Issue 46-102
Environment: Amiga, Atari, Mac, MS-DOS, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 24 (of 108)."
# Contents:  sys/amiga/winami.c2 win/X11/winmisc.c
# Wrapped by billr@saab on Wed Jan 27 16:08:55 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'sys/amiga/winami.c2' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/amiga/winami.c2'\"
else
echo shar: Extracting \"'sys/amiga/winami.c2'\" \(42959 characters\)
sed "s/^X//" >'sys/amiga/winami.c2' <<'END_OF_FILE'
Xstatic void
Xoutmore( cw )
X    register struct WinDesc *cw;
X{
X    struct Window *w = cw->win;
X
X    Text( w->RPort, " --more--", 9 );
X	/* Allow mouse clicks to clean --more-- */
X    WindowGetevent( );
X    amii_curs( WIN_MESSAGE, 1, 0 );
X    cw->curx = 0;
X    amii_cl_end( cw, cw->curx );
X}
X
Xstatic void
Xoutsubstr( cw, str, len )
X    register struct WinDesc *cw;
X    char *str;
X    int len;
X{
X    struct Window *w = cw->win;
X
X    if( cw->curx )
X    {
X	/* Check if this string and --more-- fit, if not,
X	 * then put out --more-- and wait for a key.
X	 */
X	if( (len + MORE_FUDGE ) + cw->curx >= cw->cols )
X	{
X	    outmore( cw );
X	}
X	else
X	{
X	    /* Otherwise, move and put out a blank separator */
X	    Text( w->RPort, spaces, 1 );
X	    cw->curx += 1;
X	}
X    }
X
X    Text(w->RPort,str,len);
X}
X
X/* Put a graphics character onto the screen */
X
Xvoid
Xamii_putsym( st, i, y, c )
X    winid st;
X    int i, y;
X    CHAR_P c;
X{
X    char buf[ 2 ];
X    amii_curs( st, i, y );
X    buf[ 0 ] = c;
X    buf[ 1 ] = 0;
X    amii_putstr( st, 0, buf );
X}
X
X/* Clear the indicated window */
X
Xvoid
Xamii_clear_nhwindow(win)
X    register winid win;
X{
X    register struct WinDesc *cw;
X    register struct Window *w;
X
X    if( win == WIN_ERR || ( cw = wins[win] ) == NULL )
X	panic( winpanicstr, win, "clear_nhwindow" );
X
X    if( w = cw->win )
X	SetDrMd( w->RPort, JAM2);
X
X    cursor_off( win );
X
X    /* should be: clear the rastport, reset x,y etc */
X
X    if( cw->type == NHW_MENU || cw->type == NHW_TEXT )
X    {
X    /* Window might not be opened yet */
X
X	if( w )
X	{
X	    SetAPen( w->RPort, 0 );
X	    SetBPen( w->RPort, 0 );
X	    RectFill( w->RPort, w->BorderLeft, w->BorderTop,
X	      w->Width - w->BorderRight-1,
X	      w->Height - w->BorderBottom-1 );
X	    SetAPen( w->RPort, 1 );
X	}
X    }
X    else if( w )
X    {
X	if( cw->type == NHW_MESSAGE )
X	{
X	    amii_curs( win, 1, 0 );
X	    TextSpaces( w->RPort, cw->cols );
X	}
X	else
X	{
X	    SetAPen( w->RPort, 0 );
X	    SetBPen( w->RPort, 0 );
X	    RectFill( w->RPort, w->BorderLeft, w->BorderTop,
X	      w->Width - w->BorderRight-1,
X	      w->Height - w->BorderBottom-1 );
X	    SetAPen( w->RPort, 1 );
X	}
X    }
X
X    cw->curx = cw->cury = 0;
X    amii_curs( win, 1, 0 );
X}
X
X/* Dismiss the window from the screen */
X
Xstatic void
Xdismiss_nhwindow(win)
X    register winid win;
X{
X    register struct Window *w;
X    register struct WinDesc *cw;
X
X    if( win == WIN_ERR || ( cw = wins[win] ) == NULL )
X    {
X	panic(winpanicstr,win, "dismiss_nhwindow");
X    }
X
X    w = cw->win;
X
X    if( w )
X    {
X	/* Map Window has this stuff attached to it. */
X	if( win == WIN_MAP )
X	    ClearMenuStrip( w );
X
X	/* Close the window? */
X
X	CloseShWindow( w );
X	cw->win = NULL;
X
X	if( cw->newwin )
X	    FreeNewWindow( (void *)cw->newwin );
X	cw->newwin = NULL;
X    }
X
X    if( cw->canresp )
X	free( cw->canresp );
X    cw->canresp = NULL;
X
X    if( cw->morestr )
X	free( cw->morestr );
X    cw->morestr = NULL;
X
X    cw->maxrow = cw->maxcol = 0;
X}
X
Xvoid
Xamii_exit_nhwindows(str)
X    const char *str;
X{
X    /* Seems strange to have to do this... but we need the BASE window
X     * left behind...
X     */
X    kill_nhwindows( 0 );
X    if( str ) raw_print( str );
X}
X
Xamii_nh_poskey(x, y, mod)
X    int*x, *y, *mod;
X{
X    struct WinDesc *cw;
X    WETYPE type;
X    struct RastPort *rp;
X    struct Window *w;
X
X    if( WIN_MAP != WIN_ERR && (cw = wins[ WIN_MAP ]) && ( w = cw->win ) )
X	cursor_on( WIN_MAP );
X    else
X	panic( "no MAP window opened for nh_poskey\n" );
X
X    rp = w->RPort;
X    while( 1 )
X    {
X	type = WindowGetevent( );
X	if( type == WEMOUSE )
X	{
X	    *mod = CLICK_1;
X	    if( lastevent.u.mouse.qual )
X		*mod = 0;
X
X	    /* X coordinates are 1 based, Y are zero based. */
X	    *x = ( (lastevent.u.mouse.x - w->BorderLeft) / txwidth ) + 1;
X	    *y = ( ( lastevent.u.mouse.y - w->BorderTop-txbaseline ) /
X			txheight );
X	    return( 0 );
X	}
X	else if( type == WEKEY )
X	{
X	    lastevent.type = WEUNK;
X	    return( lastevent.u.key );
X	}
X    }
X}
X
Xint
Xamii_nhgetch()
X{
X    int ch;
X
X    if( WIN_MAP != WIN_ERR && wins[ WIN_MAP ] )
X	cursor_on( WIN_MAP );
X    ch = WindowGetchar();
X    return( ch );
X}
X
Xvoid
Xamii_get_nh_event()
X{
X    /* nothing now - later I have no idea.  Is this just a Mac hook? */
X}
X
Xvoid
Xamii_remember_topl()
X{
X    /* ignore for now.  I think this will be done automatically by
X     * the code writing to the message window, but I could be wrong.
X     */
X}
X
Xint
Xamii_doprev_message()
X{
X    struct WinDesc *cw;
X    struct Window *w;
X    char *str;
X
X    if( WIN_MESSAGE == WIN_ERR ||
X	    ( cw = wins[ WIN_MESSAGE ] ) == NULL || ( w = cw->win ) == NULL )
X    {
X	panic(winpanicstr,WIN_MESSAGE, "doprev_message");
X    }
X
X    if( --cw->maxcol < 0 )
X    {
X	cw->maxcol = 0;
X	DisplayBeep( NULL );
X	str = "No more history saved...";
X    }
X    else
X	str = cw->data[ cw->maxcol ];
X
X    amii_cl_end(cw, 0);
X    amii_curs( WIN_MESSAGE, 1, 0 );
X    Text(w->RPort,str,strlen(str));
X    cw->curx = cw->cols + 1;
X
X    return( 0 );
X}
X
Xvoid
Xamii_display_nhwindow(win,blocking)
X    winid win;
X    boolean blocking;
X{
X    int i;
X    static int lastwin = -1;
X    struct Window *w;
X    struct WinDesc *cw;
X
X    if( !Initialized )
X	return;
X    lastwin = win;
X
X    if( win == WIN_ERR || ( cw = wins[win] ) == NULL )
X	panic(winpanicstr,win,"display_nhwindow");
X
X    if( cw->type == NHW_MAP || cw->type == NHW_STATUS ||
X						cw->type == NHW_MESSAGE )
X    {
X	return;
X    }
X
X    if(cw->type==NHW_MESSAGE)
X	flags.window_inited=TRUE;
X
X    /* should be:
X	if type != map, WindowToFront
X	if type == map && autoshow, unblock area around cursor
X	    (or something like that)
X     */
X
X    w = cw->win;
X    if( w )
X    {
X	WindowToFront( w );
X	ActivateWindow( w );
X    }
X
X    if( blocking && WIN_MAP != WIN_ERR && wins[ WIN_MAP ] )
X    {
X	flush_glyph_buffer( wins[ WIN_MAP ]->win );
X    }
X
X    if( cw->type == NHW_MENU || cw->type == NHW_TEXT )
X    {
X	DoMenuScroll( win, blocking );
X    }
X    else if( cw->type==NHW_MAP )
X    {
X	end_glyphout( win );
X	for( i = 0; i < MAXWIN; ++i )
X	{
X	    if( cw = wins[i] )
X	    {
X		if( cw->type == NHW_STATUS || cw->type == NHW_MESSAGE )
X		{
X		    if( cw->win )
X		    {
X			WindowToFront(cw->win);
X		    }
X		}
X	    }
X	}
X
X	/* Do more if it is time... */
X	if( blocking == TRUE )
X	    outmore( wins[ win ] );
X    }
X}
X
Xvoid
Xamii_display_file(fn, complain)
Xconst char *fn;
Xboolean complain;
X{
X    register struct WinDesc *cw;
X    register int win;
X    register FILE *fp;
X    register char *t;
X    register char buf[ 200 ];
X
X    if( fn == NULL )
X	panic("NULL file name in display_file()");
X
X    if( ( fp = fopen( fn, "r" ) ) == NULL )
X    {
X	if (complain) {
X	    sprintf( buf, "Can't display %s: %s", fn,
X#ifdef  __SASC_60
X			__sys_errlist[ errno ]
X#else
X			sys_errlist[ errno ]
X#endif
X			);
X	    amii_addtopl( buf );
X	}
X	return;
X    }
X    win = amii_create_nhwindow( NHW_TEXT );
X
X    /* Set window title to file name */
X    if( cw = wins[ win ] )
X	cw->morestr = fn;
X
X    while( fgets( buf, sizeof( buf ), fp ) != NULL )
X    {
X	if( t = index( buf, '\n' ) )
X	    *t = 0;
X	amii_putstr( win, 0, buf );
X    }
X    fclose( fp );
X
X    /* If there were lines in the file, display those lines */
X
X    if( wins[ win ]->cury > 0 )
X	amii_display_nhwindow( win, TRUE );
X
X    amii_destroy_nhwindow( win );
X}
X
Xvoid
Xamii_curs(window, x, y)
Xwinid window;
Xregister int x, y;  /* not xchar: perhaps xchar is unsigned and
X	       curx-x would be unsigned as well */
X{
X    register struct WinDesc *cw;
X    register struct Window *w;
X    register struct RastPort *rp;
X
X    if( window == WIN_ERR || ( cw = wins[window] ) == NULL )
X	panic(winpanicstr,  window, "curs");
X    if( (w = cw->win) == NULL )
X    {
X	if( cw->type == NHW_MENU || cw->type == NHW_TEXT )
X	    return;
X	else
X	    panic( "No window open yet in curs() for winid %d\n", window );
X    }
X    amiIDisplay->lastwin = window;
X
X    /* Make sure x is within bounds */
X    if( x > 0 )
X	--x;    /* column 0 is never used */
X    else
X	x = 0;
X
X    cw->curx = x;
X    cw->cury = y;
X#ifdef DEBUG
X    if(x<0 || y<0 || y >= cw->rows || x >= cw->cols)
X    {
X	char *s = "[unknown type]";
X	switch(cw->type)
X	{
X	    case NHW_MESSAGE: s = "[topl window]"; break;
X	    case NHW_STATUS: s = "[status window]"; break;
X	    case NHW_MAP: s = "[map window]"; break;
X	    case NHW_MENU: s = "[menu window]"; break;
X	    case NHW_TEXT: s = "[text window]"; break;
X	}
X	impossible("bad curs positioning win %d %s (%d,%d)", window, s, x, y);
X	return;
X    }
X#endif
X    x += cw->offx;
X    y += cw->offy;
X
X#ifdef CLIPPING
X    if(clipping && window == WIN_MAP)
X    {
X	x -= clipx;
X	y -= clipy;
X    }
X#endif
X
X    /* Output all saved output before doing cursor movements for MAP */
X
X    if( cw->type == NHW_MAP )
X	flush_glyph_buffer( w );
X
X    /* Actually do it */
X
X    rp = w->RPort;
X    if( cw->type == NHW_MENU || cw->type == NHW_TEXT )
X    {
X	Move( rp, (x * txwidth) + w->BorderLeft + 3,
X	    (y*(txheight+1) ) + w->RPort->TxBaseline + w->BorderTop + 1 );
X    }
X    else if( cw->type == NHW_MAP || cw->type == NHW_BASE )
X    {
X	/* These coordinate calculations must be synced with those
X	 * in flush_glyph_buffer() in amiwind.c.  curs_on_u() will
X	 * use this code, all other drawing occurs through the glyph
X	 * code.  In order for the cursor to appear on top of the hero,
X	 * the code must compute X,Y in the same manner relative to
X	 * the RastPort coordinates.
X	 */
X	Move( rp, (x * txwidth) + w->BorderLeft,
X		    w->BorderTop + ( (y + 1) * txheight ) + txbaseline + 1 );
X    }
X    else if( cw->type == NHW_MESSAGE )
X    {
X	Move( rp, (x * txwidth) + w->BorderLeft + 2,
X					    w->BorderTop + txbaseline + 3 );
X    }
X    else
X    {
X	Move( rp, (x * txwidth) + w->BorderLeft + 2,
X			    (y*txheight) + w->BorderTop + txbaseline + 2 );
X    }
X}
X
X/*
X *  print_glyph
X *
X *  Print the glyph to the output device.  Don't flush the output device.
X *
X *  Since this is only called from show_glyph(), it is assumed that the
X *  position and glyph are always correct (checked there)!
X */
X
Xvoid
Xamii_print_glyph(win,x,y,glyph)
X    winid win;
X    xchar x,y;
X    int glyph;
X{
X    struct WinDesc *cw;
X    uchar   ch;
X    register int offset;
X#ifdef TEXTCOLOR
X    int     color;
X    extern int zapcolors[];
X
X    if( win == WIN_ERR || (cw=wins[win]) == NULL || cw->type != NHW_MAP)
X	panic(winpanicstr,win,"print_glyph");
X
X#define zap_color(n)  color = flags.use_color ? zapcolors[n] : NO_COLOR
X#define cmap_color(n) color = flags.use_color ? defsyms[n].color : NO_COLOR
X#define trap_color(n) color = flags.use_color ? \
X		(((n) == WEB) ? defsyms[S_web ].color  : \
X			    defsyms[S_trap].color) : \
X			NO_COLOR
X#define obj_color(n)  color = flags.use_color ? objects[n].oc_color : NO_COLOR
X#define mon_color(n)  color = flags.use_color ? mons[n].mcolor : NO_COLOR
X#define pet_color(n)  color = flags.use_color ? mons[n].mcolor :          \
X		/* If no color, try to hilite pets; black  */ \
X		/* should be HI                */ \
X		    ((flags.hilite_pet) ? BLACK : NO_COLOR)
X
X# else /* no text color */
X
X#define zap_color(n)
X#define cmap_color(n)
X#define trap_color(n)
X#define obj_color(n)
X#define mon_color(n)
X#define pet_color(n)
X
X#endif
X
X    /*
X     *  Map the glyph back to a character.
X     *
X     *  Warning:  For speed, this makes an assumption on the order of
X     *        offsets.  The order is set in display.h.
X     */
X    if ((offset = (glyph - GLYPH_SWALLOW_OFF)) >= 0) {  /* swallow */
X	/* see swallow_to_glyph()in display.c */
X	ch = (uchar) showsyms[S_sw_tl + (offset & 0x7)];
X	mon_color(offset >> 3);
X    } else if ((offset = (glyph - GLYPH_ZAP_OFF)) >= 0) {       /* zap beam */
X	ch = showsyms[S_vbeam + (offset & 0x3)];
X	zap_color((offset >> 2));
X    } else if( ( offset = (glyph - GLYPH_CMAP_OFF) ) >= 0 ) {   /* cmap */
X	ch = showsyms[offset];
X	cmap_color(offset);
X    } else if ( ( offset = (glyph - GLYPH_TRAP_OFF) ) >= 0 ) {  /* trap */
X	ch = (offset == WEB) ? showsyms[S_web] : showsyms[S_trap];
X	trap_color(offset);
X    } else if( ( offset = (glyph - GLYPH_OBJ_OFF) ) >= 0 ) {    /* object */
X	ch = oc_syms[objects[offset].oc_class];
X	obj_color(offset);
X    } else if ((offset = (glyph - GLYPH_BODY_OFF)) >= 0) {  /* a corpse */
X	ch = oc_syms[objects[CORPSE].oc_class];
X	mon_color(offset);
X    } else if ((offset = (glyph - GLYPH_PET_OFF)) >= 0) {   /* a pet */
X	ch = (uchar) monsyms[mons[offset].mlet];
X	pet_color(offset);
X    } else /*if( glyph_is_monster(glyph) )*/ {      /* a monster */
X	ch = (uchar) monsyms[mons[glyph].mlet];
X	mon_color(glyph);
X    }
X
X    /* Move the cursor. */
X#ifdef CLIPPING
X    if (!win_curs(x, y)) return;
X#else
X    amii_curs(win,x,y+2);
X#endif
X
X#ifdef TEXTCOLOR
X    /* Turn off color if rogue level. */
X# ifdef REINCARNATION
X    if (Is_rogue_level(&u.uz))
X	color = NO_COLOR;
X#  endif
X
X    amiga_print_glyph(win,color,ch);
X#else
X    g_putch(ch);    /* print the character */
X#endif
X    cw->curx++;     /* one character over */
X}
X
Xvoid
XDoMenuScroll( win, blocking )
X    int win, blocking;
X{
X    register struct Window *w;
X    register struct NewWindow *nw;
X    struct PropInfo *pip;
X    register struct WinDesc *cw;
X    struct IntuiMessage *imsg;
X    struct Gadget *gd;
X    register int wheight, xsize, ysize, aredone = 0;
X    register int txwd, txh;
X    long mics, secs, class, code;
X    long oldmics = 0, oldsecs = 0;
X    int aidx, oidx, topidx, hidden;
X    char *t;
X    SHORT mx, my;
X    char title[ 100 ];
X    int dosize = 1;
X    struct Screen *scrn = HackScreen;
X
X    if( win == WIN_ERR || ( cw = wins[ win ] ) == NULL )
X	panic(winpanicstr,win,"DoMenuScroll");
X
X    /* Check to see if we should open the window, should usually need to */
X
X    txwd = txwidth;
X    txh = txheight + 1; /* +1 for interline space */
X    w = cw->win;
X    if( w == NULL )
X    {
X	/* Humm, there is only so much... */
X	if( scrn )
X	     xsize = scrn->WBorLeft + scrn->WBorRight + MenuScroll.Width + 2;
X	else
X	     xsize = 5 + 5 + MenuScroll.Width + 2;
X	xsize += (txwd * cw->maxcol);
X	if( xsize > amiIDisplay->xpix )
X	    xsize = amiIDisplay->xpix;
X
X	    /* If next row not off window, use it, else use the bottom */
X
X	ysize = ( txh * cw->maxrow ) +          /* The text space */
X	  HackScreen->WBorTop + txheight + 1 +    /* Top border */
X	  HackScreen->WBorBottom + 1;     /* The bottom border */
X	if( ysize > amiIDisplay->ypix )
X	    ysize = amiIDisplay->ypix;
X
X	/* Adjust the size of the menu scroll gadget */
X
X	nw = (void *)DupNewWindow( (void *)(&new_wins[ cw->type ].newwin) );
X	cw->newwin = (void *)nw;
X	if( nw == NULL )
X	    panic("No NewWindow Allocated" );
X
X	nw->Screen = HackScreen;
X
X	if( win == WIN_INVEN ){
X	    sprintf( title, "%s the %s's Inventory", plname, pl_character );
X	    nw->Title = title;
X	}
X	else if( cw->morestr )
X	    nw->Title = cw->morestr;
X
X	/* Adjust the window coordinates and size now that we know
X	 * how many items are to be displayed.
X	 */
X
X	nw->Width = xsize;
X	nw->Height = ysize;
X	nw->TopEdge = 0;
X	if( cw->type == NHW_TEXT && ysize < amiIDisplay->ypix )
X	    nw->TopEdge += ( amiIDisplay->ypix - ysize ) / 2;
X	nw->LeftEdge = amiIDisplay->xpix - xsize;
X	if( cw->type == NHW_TEXT && xsize < amiIDisplay->xpix )
X	    nw->LeftEdge -= ( amiIDisplay->xpix - xsize ) / 2;
X
X
X	/* Now, open the window */
X	w = cw->win = OpenShWindow( (void *)nw );
X
X	if( w == NULL )	panic("No Window Opened For Menu" );
X    }
X
X    /* Find the scroll gadget */
X
X    for( gd = w->FirstGadget; gd && gd->GadgetID != 1; gd = gd->NextGadget )
X	continue;
X
X    if( !gd ) panic("Can't find scroll gadget" );
X
X    wheight = ( w->Height - w->BorderTop - w->BorderBottom ) / txh;
X    cw->cols = ( w->Width - w->BorderLeft - w->BorderRight
X	    /* + MenuScroll.Width*/ ) / txwd;
X    morc = 0;
X    oidx = -1;
X    topidx = 0;
X
X    /* Make the prop gadget the right size and place */
X
X    DisplayData( win, topidx, -1 );
X
X    SetPropInfo( w, gd, wheight, cw->maxrow, topidx );
X    oldsecs = oldmics = 0;
X
X    while( !aredone )
X    {
X	/* Process window messages */
X
X	WaitPort( w->UserPort );
X	while( imsg = (struct IntuiMessage * ) GetMsg( w->UserPort ) )
X	{
X	    class = imsg->Class;
X	    code = imsg->Code;
X	    mics = imsg->Micros;
X	    secs = imsg->Seconds;
X	    gd = (struct Gadget *) imsg->IAddress;
X	    mx = imsg->MouseX;
X	    my = imsg->MouseY;
X
X	    /* Only do our window or VANILLAKEY from other windows */
X
X	    if( imsg->IDCMPWindow != w && class != VANILLAKEY &&
X							class != RAWKEY )
X	    {
X		ReplyMsg( (struct Message *) imsg );
X		continue;
X	    }
X
X	    /* Do DeadKeyConvert() stuff if RAWKEY... */
X	    if( class == RAWKEY )
X	    {
X		class = VANILLAKEY;
X		code = ConvertKey( imsg );
X	    }
X	    ReplyMsg( (struct Message *) imsg );
X
X	    switch( class )
X	    {
X		case NEWSIZE:
X		    /* Ignore every other newsize, no action needed */
X
X		    if( !dosize )
X		    {
X			dosize = 1;
X			break;
X		    }
X
X		    /* Find the gadget */
X
X		    for( gd = w->FirstGadget; gd && gd->GadgetID != 1; )
X			gd = gd->NextGadget;
X
X		    if( !gd )
X			panic("Can't find scroll gadget" );
X
X		    wheight = ( w->Height - w->BorderTop -
X						w->BorderBottom - 1) / txh;
X		    cw->cols = ( w->Width -
X				w->BorderLeft - w->BorderRight ) / txwd;
X		    if( wheight < 2 )
X			wheight = 2;
X
X		    /* Make the prop gadget the right size and place */
X
X		    DisplayData( win, topidx, oidx );
X		    SetPropInfo( w, gd, wheight, cw->maxrow, topidx );
X
X		    /* Force the window to a text line boundry <= to
X		     * what the user dragged it to.  This eliminates
X		     * having to clean things up on the bottom edge.
X		     */
X
X		    SizeWindow( w, 0, ( wheight * txh) +
X			    w->BorderTop + w->BorderBottom + 1 - w->Height );
X
X		    /* Don't do next NEWSIZE, we caused it */
X		    dosize = 0;
X		    oldsecs = oldmics = 0;
X		    break;
X
X		case VANILLAKEY:
X#define CTRL(x)     ((x)-'@')
X		    if( code == CTRL('D') || code == CTRL('U') )
X		    {
X			int endcnt, i;
X
X			for( gd = w->FirstGadget; gd && gd->GadgetID != 1; )
X			    gd = gd->NextGadget;
X
X			if( !gd )
X			    panic("Can't find scroll gadget" );
X
X			endcnt = wheight / 2;
X			if( endcnt == 0 )
X			    endcnt = 1;
X
X			for( i = 0; i < endcnt; ++i )
X			{
X			    if( code == CTRL('D') )
X			    {
X				if( topidx + wheight < cw->maxrow )
X				    ++topidx;
X				else
X				    break;
X			    }
X			    else
X			    {
X				if( topidx > 0 )
X				    --topidx;
X				else
X				    break;
X			    }
X
X			    /* Make prop gadget the right size and place */
X
X			    DisplayData( win, topidx, oidx );
X			    SetPropInfo( w,gd, wheight, cw->maxrow, topidx );
X			}
X			oldsecs = oldmics = 0;
X		    }
X		    else if( code == '\b' )
X		    {
X			for( gd = w->FirstGadget; gd && gd->GadgetID != 1; )
X			    gd = gd->NextGadget;
X
X			if( !gd )
X			    panic("Can't find scroll gadget" );
X
X			if( topidx - wheight - 2 < 0 )
X			{
X			    topidx = 0;
X			}
X			else
X			{
X			    topidx -= wheight - 2;
X			}
X			DisplayData( win, topidx, oidx );
X			SetPropInfo( w, gd, wheight, cw->maxrow, topidx );
X			oldsecs = oldmics = 0;
X		    }
X		    else if( code == ' ' )
X		    {
X			for( gd = w->FirstGadget; gd && gd->GadgetID != 1; )
X			    gd = gd->NextGadget;
X
X			if( !gd )
X			    panic("Can't find scroll gadget" );
X
X			if( topidx + wheight >= cw->maxrow )
X			{
X			    morc = 0;
X			    aredone = 1;
X			}
X			else
X			{
X			    /*  If there are still lines to be seen */
X
X			    if( cw->maxrow > topidx + wheight )
X			    {
X				if( wheight > 2 )
X				    topidx += wheight - 2;
X				else
X				    ++topidx;
X				DisplayData( win, topidx, oidx );
X				SetPropInfo( w, gd, wheight,
X						    cw->maxrow, topidx );
X			    }
X			    oldsecs = oldmics = 0;
X			}
X		    }
X		    else if( code == '\n' || code == '\r' )
X		    {
X			for( gd = w->FirstGadget; gd && gd->GadgetID != 1; )
X			    gd = gd->NextGadget;
X
X			if( !gd )
X			    panic("Can't find scroll gadget" );
X
X			/* If all line displayed, we are done */
X
X			if( topidx + wheight >= cw->maxrow )
X			{
X			    morc = 0;
X			    aredone = 1;
X			}
X			else
X			{
X			    /*  If there are still lines to be seen */
X
X			    if( cw->maxrow > topidx + 1 )
X			    {
X				++topidx;
X				DisplayData( win, topidx, oidx );
X				SetPropInfo( w, gd, wheight,
X						    cw->maxrow, topidx );
X			    }
X			    oldsecs = oldmics = 0;
X			}
X		    }
X		    else if( cw->resp && index( cw->resp, code ) )
X		    {
X			morc = code;
X			aredone = 1;
X		    }
X		    else if( code == '\33' || code == 'q' || code == 'Q' )
X		    {
X			morc = '\33';
X			aredone = 1;
X		    }
X		    break;
X
X		case CLOSEWINDOW:
X		    aredone = 1;
X		    morc = '\33';
X		    break;
X
X		case GADGETUP:
X		    break;
X
X		case MOUSEMOVE:
X		    for( gd = w->FirstGadget; gd && gd->GadgetID != 1; )
X			gd = gd->NextGadget;
X
X		    pip = (struct PropInfo *)gd->SpecialInfo;
X		    hidden = max( cw->maxrow - wheight, 0 );
X		    aidx = (((ULONG)hidden * pip->VertPot) + (MAXPOT/2)) >> 16;
X		    if( aidx != topidx )
X			DisplayData( win, topidx = aidx, oidx );
X		    break;
X
X		case MOUSEBUTTONS:
X		    if( ( code == SELECTUP || code == SELECTDOWN ) &&
X						    cw->type == NHW_MENU )
X		    {
X			/* Which one is the mouse pointing at? */
X
X			aidx = (( (my - w->TopEdge) - w->BorderTop + 1 ) /
X							txh) + topidx;
X
X			/* If different lines, don't select double click */
X
X			if( aidx != oidx )
X			{
X			    oldsecs = 0;
X			    oldmics = 0;
X			}
X
X			/* If releasing, check for double click */
X
X			if( code == SELECTUP )
X			{
X			    if( aidx == oidx )
X			    {
X				if( DoubleClick( oldsecs,
X						    oldmics, secs, mics ) )
X				{
X				    morc = cw->resp[ aidx ];
X				    aredone = 1;
X				}
X				oldsecs = secs;
X				oldmics = mics;
X			    }
X			}
X			else if( aidx < cw->maxrow && code == SELECTDOWN )
X			{
X			    /* Remove old highlighting if visible */
X
X			    if( oidx > topidx && oidx - topidx < wheight )
X			    {
X				t = cw->data[ oidx ] + SOFF;
X				amii_curs( win, 1, oidx - topidx );
X				SetDrMd( w->RPort, JAM2 );
X				SetAPen( w->RPort, C_WHITE );
X				SetBPen( w->RPort, C_BLACK );
X				Text( w->RPort, t, strlen( t ) );
X				oidx = -1;
X			    }
X
X			    t = cw->data[ aidx ];
X			    if( t[ SEL_ITEM ] == 1 )
X			    {
X				oidx = aidx;
X
X				amii_curs( win, 1, aidx - topidx );
X				SetDrMd( w->RPort, JAM2 );
X				SetAPen( w->RPort, C_BLUE );
X				SetBPen( w->RPort, C_WHITE );
X				t += SOFF;
X				Text( w->RPort, t, strlen( t ) );
X			    }
X			    else
X			    {
X				DisplayBeep( NULL );
X				oldsecs = 0;
X				oldmics = 0;
X			    }
X			}
X		    }
X		    else
X		    {
X			DisplayBeep( NULL );
X		    }
X		    break;
X	    }
X	}
X    }
X}
X
Xvoid
XDisplayData( win, start, where )
X    int win;
X    int start;
X    int where;
X{
X    register struct WinDesc *cw;
X    register struct Window *w;
X    register int i, len, wheight;
X    int col = -1;
X
X    if( win == WIN_ERR || !(cw = wins[win]) || !( w = cw->win ) )
X    {
X	panic( winpanicstr, win, "No Window in DisplayData" );
X    }
X
X    SetDrMd( w->RPort, JAM2 );
X    wheight = ( w->Height - w->BorderTop - w->BorderBottom ) / ( txheight + 1 );
X
X    for( i = start; i < start + wheight; ++i )
X    {
X	amii_curs( win, 1, i - start );
X
X	if( where == i )
X	{
X	    if( col != 1 )
X	    {
X		SetAPen( w->RPort, C_BLUE );
X		SetBPen( w->RPort, C_WHITE );
X		col = 1;
X	    }
X	}
X	else if( col != 2 )
X	{
X	    SetAPen( w->RPort, C_WHITE );
X	    SetBPen( w->RPort, C_BLACK );
X	    col = 2;
X	}
X
X	/* Next line out, truncate if too long */
X
X	len = 0;
X	if( i < cw->maxrow )
X	{
X	    register char *t;
X
X	    t = cw->data[ i ] + SOFF;
X	    len = strlen( t );
X	    if( len > cw->cols )
X		len = cw->cols;
X	    Text( w->RPort, t, len );
X	}
X	amii_cl_end( cw, len );
X    }
X    return;
X}
X
Xvoid SetPropInfo( win, gad, vis, total, top )
X    register struct Window *win;
X    register struct Gadget *gad;
X    register long vis, total, top;
X{
X    register long hidden;
X    register int body, pot;
X
X    hidden = max( total-vis, 0 );
X
X    /* Force the last section to be just to the bottom */
X
X    if( top > hidden )
X	top = hidden;
X
X    /* Scale the body position. */
X    /* 2 lines overlap */
X
X    if( hidden > 0 && total != 0 )
X	body = (ULONG) ((vis - 2) * MAXBODY) / (total - 2);
X    else
X	body = MAXBODY;
X
X    if( hidden > 0 )
X	pot = (ULONG) (top * MAXPOT) / hidden;
X    else
X	pot = 0;
X
X    NewModifyProp( gad, win, NULL,
X			    AUTOKNOB|FREEVERT, 0, pot, MAXBODY, body, 1 );
X}
X
Xvoid
Xkill_nhwindows( all )
X    register int all;
X{
X    register int i;
X    register struct WinDesc *cw;
X
X    /* Foreach open window in all of wins[], CloseShWindow, free memory */
X
X    for( i = 0; i < MAXWIN; ++i )
X    {
X	if( (cw = wins[ i ]) && (cw->type != NHW_BASE || all) )
X	{
X	    CloseShWindow( cw->win );
X	    free( cw );
X	    wins[ i ] = NULL;
X	}
X    }
X}
X
Xvoid
Xamii_cl_end( cw, i )
X    register struct WinDesc *cw;
X    register int i;
X{
X    register struct Window *w = cw->win;
X    register int oy, ox;
X
X    if( !w )
X	panic("NULL window pointer in amii_cl_end()");
X
X    oy = w->RPort->cp_y;
X    ox = w->RPort->cp_x;
X
X    TextSpaces( w->RPort, cw->cols - i );
X
X    Move( w->RPort, ox, oy );
X}
X
Xvoid cursor_off( window )
X    winid window;
X{
X    register struct WinDesc *cw;
X    register struct Window *w;
X    register struct RastPort *rp;
X    int curx, cury;
X    long dmode;
X    short apen, bpen;
X    unsigned char ch;
X
X    if( window == WIN_ERR || ( cw = wins[window] ) == NULL )
X    {
X	/* tty does this differently - is this OK? */
X	flags.window_inited=0;
X	panic(winpanicstr,window, "cursor_off");
X    }
X
X    if( !(cw->flags & FLMAP_CURSUP ) )
X	return;
X    w = cw->win;
X
X    if( !w )
X	return;
X
X    cw->flags &= ~FLMAP_CURSUP;
X    rp = w->RPort;
X
X    /* Save the current information */
X    curx = rp->cp_x;
X    cury = rp->cp_y;
X    dmode = rp->DrawMode;
X    apen = rp->FgPen;
X    bpen = rp->BgPen;
X    SetAPen( rp, cw->curs_apen );
X    SetBPen( rp, cw->curs_bpen );
X    SetDrMd( rp, COMPLEMENT );
X
X    ch = CURSOR_CHAR;
X    Move( rp, cw->cursx, cw->cursy );
X    Text( rp, &ch, 1 );
X
X    /* Put back the other stuff */
X
X    Move( rp, curx, cury );
X    SetDrMd( rp, dmode );
X    SetAPen( rp, apen );
X    SetBPen( rp, bpen );
X}
X
Xvoid cursor_on( window )
X    winid window;
X{
X    register struct WinDesc *cw;
X    register struct Window *w;
X    register struct RastPort *rp;
X    unsigned char ch;
X    long dmode;
X    short apen, bpen;
X
X    if( window == WIN_ERR || ( cw = wins[window] ) == NULL )
X    {
X	/* tty does this differently - is this OK? */
X	flags.window_inited=0;
X	panic(winpanicstr,window, "cursor_on");
X    }
X
X    if( (cw->flags & FLMAP_CURSUP ) )
X	cursor_off( window );
X
X    w = cw->win;
X
X    if( !w )
X	return;
X
X    cw->flags |= FLMAP_CURSUP;
X    rp = w->RPort;
X
X    /* Save the current information */
X
X    cw->cursx = rp->cp_x;
X    cw->cursy = rp->cp_y;
X    apen = rp->FgPen;
X    bpen = rp->BgPen;
X    dmode = rp->DrawMode;
X    ch = CURSOR_CHAR;
X
X    /* Draw in complement mode. The cursor body will be C_WHITE */
X
X    cw->curs_apen = C_WHITE;
X    cw->curs_bpen = C_WHITE;
X    SetAPen( rp, cw->curs_apen );
X    SetBPen( rp, cw->curs_bpen );
X    SetDrMd( rp, COMPLEMENT );
X    Move( rp, cw->cursx, cw->cursy );
X    Text( rp, &ch, 1 );
X    Move( rp, cw->cursx, cw->cursy );
X
X    SetDrMd( rp, dmode );
X    SetAPen( rp, apen );
X    SetBPen( rp, bpen );
X}
X
Xvoid
Xamii_getret()
X{
X    register int c;
X
X    raw_print( "" );
X    raw_print( "Press Return..." );
X
X    c = 0;
X
X    while( c != '\n' && c != '\r' )
X    {
X	if( HackPort )
X	    c = WindowGetchar();
X	else
X	    c = getchar();
X    }
X    return;
X}
X
XUBYTE UNDOBUFFER[300];
XSHORT BorderVectors1[] = { 0,0, 57,0, 57,11, 0,11, 0,0 };
Xstruct Border Border1 = { -1,-1, 3,0,JAM1, 5, BorderVectors1, NULL };
Xstruct IntuiText IText1 = { 3,0,JAM2, 4,1, NULL, (UBYTE *)"Cancel", NULL };
Xstruct Gadget Gadget2 = {
X    NULL, 9,15, 56,10, NULL, RELVERIFY, BOOLGADGET, (APTR)&Border1,
X    NULL, &IText1, NULL, NULL, 1, NULL
X};
XUBYTE StrStringSIBuff[300];
Xstruct StringInfo StrStringSInfo = {
X    StrStringSIBuff, UNDOBUFFER, 0, 300, 0, 0,0,0,0,0, 0, 0, NULL
X};
XSHORT BorderVectors2[] = { 0,0, 439,0, 439,11, 0,11, 0,0 };
Xstruct Border Border2 = { -1,-1, 3,0,JAM1, 5, BorderVectors2, NULL };
Xstruct Gadget String = {
X    &Gadget2, 77,15, 438,10, NULL, RELVERIFY+STRINGCENTER, STRGADGET,
X    (APTR)&Border2, NULL, NULL, NULL, (APTR)&StrStringSInfo, 2, NULL
X};
X
X#define StrString \
X   ((char *)(((struct StringInfo *)(String.SpecialInfo))->Buffer))
X
Xstruct NewWindow StrWindow = {
X    57,74, 526,31, 0,1, GADGETUP+CLOSEWINDOW+ACTIVEWINDOW+VANILLAKEY,
X    WINDOWDRAG+WINDOWDEPTH+WINDOWCLOSE+ACTIVATE+NOCAREREFRESH,
X    &String, NULL, NULL, NULL, NULL, 5,5, 0xffff,0xffff, CUSTOMSCREEN
X};
X
X/* Generate a requester for a string value. */
X
Xvoid amii_getlin(prompt,bufp)
X    const char *prompt;
X    char *bufp;
X{
X    getlind(prompt,bufp,0);
X}
X
X/* and with default */
Xvoid getlind(prompt,bufp, dflt)
X    const char *prompt;
X    char *bufp;
X    const char *dflt;
X{
X#ifndef TOPL_GETLINE
X    register struct Window *cwin;
X    register struct IntuiMessage *imsg;
X    register long class, code, qual;
X    register int aredone = 0;
X    register struct Gadget *gd;
X    static int once;
X
X    *StrString = 0;
X    if( dflt )
X	strcpy( StrString, dflt );
X    StrWindow.Title = (UBYTE *)prompt;
X    StrWindow.Screen = HackScreen;
X
X    if( !once )
X    {
X	if( bigscreen )
X	    StrWindow.TopEdge = (HackScreen->Height/2) - (StrWindow.Height/2);
X	SetBorder( &String );
X	SetBorder( &Gadget2 );
X	once = 1;
X    }
X
X    if( ( cwin = OpenWindow( (void *)&StrWindow ) ) == NULL )
X    {
X	return;
X    }
X
X    while( !aredone )
X    {
X	WaitPort( cwin->UserPort );
X	while( ( imsg = (void *) GetMsg( cwin->UserPort ) ) != NULL )
X	{
X	    class = imsg->Class;
X	    code = imsg->Code;
X	    qual = imsg->Qualifier;
X	    gd = (struct Gadget *) imsg->IAddress;
X
X	    switch( class )
X	    {
X		case VANILLAKEY:
X		    if( code == '\033' && (qual &
X			    (IEQUALIFIER_LALT|IEQUALIFIER_RALT|
X			    IEQUALIFIER_LCOMMAND|IEQUALIFIER_RCOMMAND) ) == 0 )
X		    {
X			if( bufp )
X			{
X			    bufp[0]='\033';
X			    bufp[1]=0;
X			}
X			aredone = 1;
X		    }
X		    else
X		    {
X			ActivateGadget( &String, cwin, NULL );
X		    }
X		    break;
X
X		case ACTIVEWINDOW:
X		    ActivateGadget( &String, cwin, NULL );
X		    break;
X
X		case GADGETUP:
X		    switch( gd->GadgetID )
X		    {
X			case 2:
X			    aredone = 1;
X			    if( bufp )
X				strcpy( bufp, StrString );
X			    break;
X
X			case 1:
X			    if( bufp )
X			    {
X				bufp[0]='\033';
X				bufp[1]=0;
X			    }
X			    aredone = 1;
X			    break;
X		    }
X		    break;
X
X		case CLOSEWINDOW:
X		    if( bufp )
X			strcpy( bufp, StrString );
X		    aredone = 1;
X		    break;
X	    }
X	    ReplyMsg( (struct Message *) imsg );
X	}
X    }
X
X    CloseWindow( cwin );
X#else
X    struct WinDesc *cw;
X    struct Window *w;
X    int colx, ocolx, c;
X    char *obufp;
X
X    amii_clear_nhwindow( WIN_MESSAGE );
X    amii_putstr( WIN_MESSAGE, 0, prompt );
X    cw = wins[ WIN_MESSAGE ];
X    w = cw->win;
X    ocolx = colx = strlen( prompt ) + 1;
X
X    obufp = bufp;
X    while((c = WindowGetchar()) != EOF)
X    {
X	amii_curs( WIN_MESSAGE, colx, 0 );
X	if(c == '\033')
X	{
X	    *obufp = c;
X	    obufp[1] = 0;
X	    return;
X	}
X	else if(c == '\b')
X	{
X	    if(bufp != obufp)
X	    {
X		bufp--;
X		amii_curs( WIN_MESSAGE, --colx, 0);
X		Text( w->RPort, "\177 ", 2 );
X		amii_curs( WIN_MESSAGE, colx, 0);
X	    }
X	    else
X		DisplayBeep( NULL );
X	}
X	else if( c == '\n' || c == '\r' )
X	{
X	    *bufp = 0;
X	    return;
X	}
X	else if(' ' <= c && c < '\177')
X	{
X		/* avoid isprint() - some people don't have it
X		   ' ' is not always a printing char */
X	    *bufp = c;
X	    bufp[1] = 0;
X
X	    Text( w->RPort, bufp, 1 );
X	    Text( w->RPort, "\177", 1 );
X	    if(bufp-obufp < BUFSZ-1 && bufp-obufp < COLNO)
X	    {
X		colx++;
X		bufp++;
X	    }
X	}
X	else if(c == ('X'-64) || c == '\177')
X	{
X	    amii_curs( WIN_MESSAGE, ocolx, 0 );
X	    Text( w->RPort,
X		"                                                            ",
X		colx - ocolx );
X	    amii_curs( WIN_MESSAGE, colx = ocolx, 0 );
X	} else
X	    DisplayBeep( NULL );
X    }
X    *bufp = 0;
X#endif
X}
X
Xvoid amii_suspend_nhwindows( str )
X    char *str;
X{
X    if( HackScreen )
X	ScreenToBack( HackScreen );
X}
X
Xvoid amii_resume_nhwindows()
X{
X    if( HackScreen )
X	ScreenToFront( HackScreen );
X}
X
Xvoid amii_bell()
X{
X    DisplayBeep( NULL );
X}
X
X#define GADBLUEPEN      2
X#define GADREDPEN       3
X#define GADGREENPEN     4
X#define GADCOLOKAY      5
X#define GADCOLCANCEL    6
X
X#include "colorwin.c"
X
Xvoid
XEditColor()
X{
X    int i, done = 0, okay = 0;
X    long code, qual, class;
X    register struct Gadget *gd, *dgad;
X    register struct Window *nw;
X    register struct IntuiMessage *imsg;
X    register struct PropInfo *pip;
X    register struct Screen *scrn;
X    long aidx;
X    int msx, msy;
X    int curcol = 0, drag = 0;
X    int bxorx, bxory, bxxlen, bxylen;
X    UWORD colors[ 1L << DEPTH ];
X    static int once = 0;
X
X    bxylen = Col_NewWindowStructure1.Height -
X			    ( Col_BluePen.TopEdge + Col_BluePen.Height + 6 );
X    bxxlen = Col_BluePen.Width;
X    bxorx = Col_BluePen.LeftEdge;
X    bxory = Col_BluePen.TopEdge + Col_BluePen.Height + 2;
X    scrn = HackScreen;
X
X    if( !once )
X    {
X	SetBorder( &Col_Okay );
X	SetBorder( &Col_Cancel );
X	once = 1;
X    }
X
X    for( i = 0; i < (1L << DEPTH); ++i )
X    {
X	colors[ i ] = GetRGB4( scrn->ViewPort.ColorMap, i );
X    }
X
X    Col_NewWindowStructure1.Screen = scrn;
X#ifdef  INTUI_NEW_LOOK
X    if( IntuitionBase->LibNode.lib_Version >= 37 )
X    {
X	((struct PropInfo *)Col_BluePen.SpecialInfo)->Flags |= PROPNEWLOOK;
X	((struct PropInfo *)Col_RedPen.SpecialInfo)->Flags |=  PROPNEWLOOK;
X	((struct PropInfo *)Col_GreenPen.SpecialInfo)->Flags |= PROPNEWLOOK;
X    }
X#endif
X    nw = OpenWindow( (void *)&Col_NewWindowStructure1 );
X
X    DrawCol( nw, curcol, colors );
X    while( !done )
X    {
X	WaitPort( nw->UserPort );
X
X	while( imsg = (struct IntuiMessage * )GetMsg( nw->UserPort ) )
X	{
X	    gd = (struct Gadget *)imsg->IAddress;
X	    code = imsg->Code;
X	    class = imsg->Class;
X	    qual = imsg->Qualifier;
X	    msx = imsg->MouseX;
X	    msy = imsg->MouseY;
X
X	    ReplyMsg( (struct Message *)imsg );
X
X	    switch( class )
X	    {
X		case VANILLAKEY:
X		    if( code == 'v' && qual == AMIGALEFT )
X			okay = done = 1;
X		    else if( code == 'b' && qual == AMIGALEFT )
X			okay = 0, done = 1;
X		    else if( code == 'o' || code == 'O' )
X			okay = done = 1;
X		    else if( code == 'c' || code == 'C' )
X			okay = 0, done = 1;
X		    break;
X
X		case CLOSEWINDOW:
X		    done = 1;
X		    break;
X
X		case GADGETUP:
X		    drag = 0;
X		    if( gd->GadgetID == GADREDPEN ||
X					    gd->GadgetID == GADBLUEPEN ||
X						gd->GadgetID == GADGREENPEN )
X		    {
X			pip = (struct PropInfo *)gd->SpecialInfo;
X			aidx = pip->HorizPot / (MAXPOT/15);
X			aidx = aidx;
X			if( gd->GadgetID == GADREDPEN )
X			{
X			    colors[ curcol ] =
X				( colors[ curcol ] & ~0xf00 ) | (aidx << 8);
X			    LoadRGB4( &scrn->ViewPort, colors, 1l << DEPTH );
X			}
X			else if( gd->GadgetID == GADBLUEPEN )
X			{
X			    colors[ curcol ] =
X					( colors[ curcol ] & ~0xf ) | aidx;
X			    LoadRGB4( &scrn->ViewPort, colors, 1l << DEPTH );
X			}
X			else if( gd->GadgetID == GADGREENPEN )
X			{
X			    colors[ curcol ] =
X				( colors[ curcol ] & ~0x0f0 ) | (aidx << 4);
X			    LoadRGB4( &scrn->ViewPort, colors, 1l << DEPTH );
X			}
X			DispCol( nw, curcol, colors );
X		    }
X		    else if( gd->GadgetID == GADCOLOKAY )
X		    {
X			done = 1;
X			okay = 1;
X		    }
X		    else if( gd->GadgetID == GADCOLCANCEL )
X		    {
X			done = 1;
X			okay = 0;
X		    }
X		    break;
X
X		case GADGETDOWN:
X		    drag = 1;
X		    dgad = gd;
X		    break;
X
X		case MOUSEMOVE:
X		    if( !drag )
X			break;
X		    pip = (struct PropInfo *)dgad->SpecialInfo;
X		    aidx = pip->HorizPot / (MAXPOT/15);
X		    aidx = aidx;
X		    if( dgad->GadgetID == GADREDPEN )
X		    {
X			colors[ curcol ] =
X				( colors[ curcol ] & ~0xf00 ) | (aidx << 8);
X			LoadRGB4( &scrn->ViewPort, colors, 1l << DEPTH );
X		    }
X		    else if( dgad->GadgetID == GADBLUEPEN )
X		    {
X			colors[ curcol ] = ( colors[ curcol ] & ~0xf ) | aidx;
X			LoadRGB4( &scrn->ViewPort, colors, 1l << DEPTH );
X		    }
X		    else if( dgad->GadgetID == GADGREENPEN )
X		    {
X			colors[ curcol ] =
X				( colors[ curcol ] & ~0x0f0 ) | (aidx << 4);
X			LoadRGB4( &scrn->ViewPort, colors, 1l << DEPTH );
X		    }
X		    DispCol( nw, curcol, colors );
X		    break;
X
X		case MOUSEBUTTONS:
X		    if( code == SELECTDOWN )
X		    {
X			if( msy > bxory && msy < bxory + bxylen - 1 &&
X				msx > bxorx && msx < bxorx + bxxlen - 1 )
X			{
X			    curcol = ( msx - bxorx )/(bxxlen / (1l << DEPTH));
X			    DrawCol( nw, curcol, colors );
X			}
X		    }
X		    break;
X	    }
X	}
X    }
X
X    if( okay )
X    {
X	for( i = 0; i < ( 1L << DEPTH ); ++i )
X	    amii_curmap[ i ] = colors[ i ];
X    }
X
X    LoadRGB4( &scrn->ViewPort, amii_curmap, 1L << DEPTH );
X    CloseWindow( nw );
X}
X
X/* The colornames, and the default values for the pens */
Xstatic struct
X{
X    char *name, *defval;
X} colnames[] =
X{
X    "Black","(aaa)",
X    "White","(fff)",
X    "Brown","(620)",
X    "Cyan","(b08)",
X    "Green","(181)",
X    "Magenta","(c06)",
X    "Blue","(23e)",
X    "Red","(d00)",
X};
X
Xvoid
XDrawCol( w, idx, colors )
X    struct Window *w;
X    int idx;
X    UWORD *colors;
X{
X    int bxorx, bxory, bxxlen, bxylen;
X    int i, incx, incy, r, g, b;
X    long flags;
X
X    bxylen = Col_NewWindowStructure1.Height - Col_Okay.Height - 4 -
X		    ( Col_BluePen.TopEdge + Col_BluePen.Height + 6 );
X    bxxlen = Col_BluePen.Width;
X    bxorx = Col_BluePen.LeftEdge;
X    bxory = Col_BluePen.TopEdge + Col_BluePen.Height + 2;
X
X    incx = bxxlen / (1L << DEPTH);
X    incy = bxylen - 2;
X
X    SetAPen( w->RPort, 1 );
X    SetBPen( w->RPort, 0 );
X    SetDrMd( w->RPort, JAM2 );
X    RectFill( w->RPort, bxorx, bxory, bxorx + bxxlen - 1, bxory + bxylen );
X    SetAPen( w->RPort, 0 );
X    RectFill( w->RPort, bxorx+2, bxory+1,
X				    bxorx + bxxlen - 4, bxory + bxylen - 1);
X
X    for( i = 0; i < (1L << DEPTH); ++i )
X    {
X	if( i == idx )
X	    SetAPen( w->RPort, 1 );
X	else
X	    SetAPen( w->RPort, 0 );
X	SetBPen( w->RPort, 0 );
X	SetDrMd( w->RPort, JAM2 );
X	RectFill( w->RPort, bxorx + 3 + (i*incx)+1, bxory + 2,
X				    bxorx + ((i+1)*incx)-2, bxory+bxylen - 2);
X
X	SetAPen( w->RPort, 0 );
X	SetBPen( w->RPort, 0 );
X	SetDrMd( w->RPort, JAM2 );
X	RectFill( w->RPort, bxorx + 3 + (i*incx)+2, bxory + 3,
X				    bxorx + ((i+1)*incx)-4, bxory+bxylen - 3);
X
X	SetAPen( w->RPort, i );
X	SetBPen( w->RPort, 0 );
X	SetDrMd( w->RPort, JAM2 );
X	RectFill( w->RPort, bxorx + 3 +(i*incx)+4, bxory + 4,
X				    bxorx + ((i+1)*incx)-6, bxory+bxylen - 4 );
X    }
X
X    DispCol( w, idx, colors );
X
X    r = (colors[ idx ] & 0xf00) >> 8;
X    g = (colors[ idx ] & 0x0f0) >> 4;
X    b = colors[ idx ] & 0x00f;
X
X    flags = AUTOKNOB|FREEHORIZ;
X#ifdef  INTUI_NEW_LOOK
X    if( IntuitionBase->LibNode.lib_Version >= 37 )
X    {
X	flags |= PROPNEWLOOK;
X    }
X#endif
X    NewModifyProp( &Col_RedPen, w, NULL, flags, (r * MAXPOT ) / 15, 0,
X							    MAXPOT/15, 0, 1 );
X    NewModifyProp( &Col_GreenPen, w, NULL, flags, (g * MAXPOT ) / 15, 0,
X							    MAXPOT/15, 0, 1 );
X    NewModifyProp( &Col_BluePen, w, NULL, flags, (b * MAXPOT ) / 15, 0,
X							    MAXPOT/15, 0, 1 );
X}
X
Xvoid
XDispCol( w, idx, colors )
X    struct Window *w;
X    int idx;
X    UWORD *colors;
X{
X    char buf[ 50 ];
X
X    Move( w->RPort, Col_Okay.LeftEdge + Col_Okay.Width +
X	txwidth, Col_Cancel.TopEdge + txbaseline + 2 );
X    sprintf( buf, "%s=%03x %s%s", colnames[idx].name, colors[idx],
X	colnames[idx].defval,
X	"        "+strlen(colnames[idx].name)+1 );
X    SetAPen( w->RPort, C_WHITE );
X    SetBPen( w->RPort, 0 );
X    SetDrMd( w->RPort, JAM2 );
X    Text( w->RPort, buf, strlen( buf ) );
X}
X
Xvoid
Xamii_setpens()
X{
X    /* If the pens are set in NetHack.cnf, we can get called before
X     * HackScreen has been opened...
X     */
X    if( HackScreen != NULL )
X    {
X	LoadRGB4( &HackScreen->ViewPort, amii_curmap, 1L << DEPTH );
X    }
X}
X
X/* Put a 3-D motif border around the gadget.  String gadgets or those
X * which do not have highlighting are rendered down.  Boolean gadgets
X * are rendered in the up position by default.
X */
X
Xvoid
XSetBorder( gd )
X    register struct Gadget *gd;
X{
X    register struct Border *bp;
X    register short *sp;
X    register int i, inc = -1, dec = -1;
X    int borders = 6;
X
X    /* Allocate two border structures one for up image and one for down
X     * image, plus vector arrays for the border lines.
X     */
X
X    if( gd->GadgetType == STRGADGET )
X	borders = 12;
X
X    if( ( bp = (struct Border *)alloc( ( ( sizeof( struct Border ) * 2 ) +
X			( sizeof( short ) * borders ) ) * 2 ) ) == NULL )
X    {
X	return;
X    }
X
X    /* For a string gadget, we expand the border beyond the area where
X     * the text will be entered.
X     */
X
X    /* Remove any special rendering flags to avoid confusing intuition
X     */
X
X    gd->Flags &= ~(GADGHIGHBITS|GADGIMAGE);
X
X    sp = (short *)(bp + 4);
X    if( gd->GadgetType == STRGADGET || ( gd->GadgetType == BOOLGADGET &&
X			    ( gd->Flags & GADGHIGHBITS ) == GADGHNONE ) )
X    {
X	sp[0] = -1;
X	sp[1] = gd->Height - 1;
X	sp[2] = -1;
X	sp[3] = -1;
X	sp[4] = gd->Width - 1;
X	sp[5] = -1;
X
X	sp[6] = gd->Width + 1;
X	sp[7] = -2;
X	sp[8] = gd->Width + 1;
X	sp[9] = gd->Height + 1;
X	sp[10] = -2;
X	sp[11] = gd->Height + 1;
X
X	sp[12] = -2;
X	sp[13] = gd->Height;
X	sp[14] = -2;
X	sp[15] = -2;
X	sp[16] = gd->Width;
X	sp[17] = -2;
X	sp[18] = gd->Width;
X	sp[19] = gd->Height;
X	sp[20] = -2;
X	sp[21] = gd->Height;
X
X	for( i = 0; i < 3; ++i )
X	{
X	    bp[ i ].LeftEdge = bp[ i ].TopEdge = -1;
X	    bp[ i ].FrontPen = ( i == 0 || i == 1 ) ? C_BROWN : C_WHITE;
X
X	    /* Have to use JAM2 so that the old colors disappear. */
X	    bp[ i ].BackPen = C_BLACK;
X	    bp[ i ].DrawMode = JAM2;
X	    bp[ i ].Count = ( i == 0 || i == 1 ) ? 3 : 5;
X	    bp[ i ].XY = &sp[ i*6 ];
X	    bp[ i ].NextBorder = ( i == 2 ) ? NULL : &bp[ i + 1 ];
X	}
X
X	/* bp[0] and bp[1] two pieces for the up image */
X	gd->GadgetRender = (APTR) bp;
X
X	/* No image change for select */
X	gd->SelectRender = (APTR) bp;
X
X	gd->LeftEdge++;
X	gd->TopEdge++;
X	gd->Flags |= GADGHCOMP;
X    }
X    else
X    {
X	/* Create the border vector values for up and left side, and
X	 * also the lower and right side.
X	 */
X
X	sp[0] = dec;
X	sp[1] = gd->Height + inc;
X	sp[2] = dec;
X	sp[3] = dec;
X	sp[4] = gd->Width + inc;
X	sp[5] = dec;
X
X	sp[6] = gd->Width + inc;
X	sp[7] = dec;
X	sp[8] = gd->Width + inc;
X	sp[9] = gd->Height + inc;
X	sp[10] = dec;
X	sp[11] = gd->Height + inc;
X
X	/* We are creating 4 sets of borders, the two sides of the
X	 * rectangle share the border vectors with the opposite image,
X	 * but specify different colors.
X	 */
X
X	for( i = 0; i < 4; ++i )
X	{
X	    bp[ i ].TopEdge = bp[ i ].LeftEdge = 0;
X
X	    /* A GADGHNONE is always down */
X
X	    if( gd->GadgetType == BOOLGADGET &&
X			    ( gd->Flags & GADGHIGHBITS ) != GADGHNONE )
X	    {
X		bp[ i ].FrontPen =
X			    ( i == 1 || i == 2 ) ? C_BROWN : C_WHITE;
X	    }
X	    else
X	    {
X		bp[ i ].FrontPen =
X			    ( i == 1 || i == 3 ) ? C_WHITE : C_BROWN;
X	    }
X
X	    /* Have to use JAM2 so that the old colors disappear. */
X	    bp[ i ].BackPen = C_BLACK;
X	    bp[ i ].DrawMode = JAM2;
X	    bp[ i ].Count = 3;
X	    bp[ i ].XY = &sp[ 6 * ((i &1) != 0) ];
X	    bp[ i ].NextBorder =
X			    ( i == 1 || i == 3 ) ? NULL : &bp[ i + 1 ];
X	}
X
X	/* bp[0] and bp[1] two pieces for the up image */
X	gd->GadgetRender = (APTR) bp;
X
X	/* bp[2] and bp[3] two pieces for the down image */
X	gd->SelectRender = (APTR) (bp + 2);
X	gd->Flags |= GADGHIMAGE;
X    }
X}
X
X#ifdef  PORT_HELP
Xvoid
Xport_help()
X{
X    display_file( PORT_HELP, 1 );
X}
X#endif
X
X#endif /* AMIGA_INTUITION */
END_OF_FILE
if test 42959 -ne `wc -c <'sys/amiga/winami.c2'`; then
    echo shar: \"'sys/amiga/winami.c2'\" unpacked with wrong size!
fi
# end of 'sys/amiga/winami.c2'
fi
if test -f 'win/X11/winmisc.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'win/X11/winmisc.c'\"
else
echo shar: Extracting \"'win/X11/winmisc.c'\" \(11918 characters\)
sed "s/^X//" >'win/X11/winmisc.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)winmisc.c	3.1	92/10/21	*/
X/* Copyright (c) Dean Luick, 1992				  */
X/* NetHack may be freely redistributed.  See license for details. */
X
X/*
X * Misc. popup windows: player selection and extended commands.
X * 
X * 	+ Global functions: player_selection() and get_ext_cmd().
X */
X#include <X11/Intrinsic.h>
X#include <X11/StringDefs.h>
X#include <X11/Shell.h>
X#include <X11/Xaw/Command.h>
X#include <X11/Xaw/Form.h>
X#include <X11/Xaw/Label.h>
X#include <X11/Xaw/Cardinals.h>
X#include <X11/Xos.h>	/* for index() */
X
X#include "hack.h"
X#include "func_tab.h"
X#include "winX.h"
X
Xextern const char *roles[];	/* from u_init.c */
X
Xstatic Widget extended_command_popup;
Xstatic Widget extended_command_form;
Xstatic int extended_command_selected;	/* index of the selected command; */
Xstatic int ps_selected;			/* index of selected role */
X#define PS_RANDOM (-50)
X#define PS_QUIT   (-75)
X
Xstatic const char extended_command_translations[] =
X    "#override\n\
X     <Key>: ec_key()";
X
Xstatic const char player_select_translations[] =
X    "#override\n\
X     <Key>: ps_key()";
X
X
Xstatic Widget make_menu();
X
X
X/* Player Selection -------------------------------------------------------- */
X/* ARGSUSED */
Xstatic void
Xps_quit(w, client_data, call_data)
X    Widget w;
X    XtPointer client_data, call_data;
X{
X    ps_selected = PS_QUIT;
X    exit_x_event = TRUE;		/* leave event loop */
X}
X
X/* ARGSUSED */
Xstatic void
Xps_random(w, client_data, call_data)
X    Widget w;
X    XtPointer client_data, call_data;
X{
X    ps_selected = PS_RANDOM;
X    exit_x_event = TRUE;		/* leave event loop */
X}
X
X/* ARGSUSED */
Xstatic void
Xps_select(w, client_data, call_data)
X    Widget w;
X    XtPointer client_data, call_data;
X{
X    ps_selected = (int) client_data;
X    exit_x_event = TRUE;		/* leave event loop */
X}
X
X/* ARGSUSED */
Xvoid
Xps_key(w, event, params, num_params)
X    Widget w;
X    XEvent *event;
X    String *params;
X    Cardinal *num_params;
X{
X    char ch, *mark;
X
X    ch = key_event_to_char((XKeyEvent *) event);
X    if (ch == '\0') {	/* don't accept nul char/modifier event */
X	/* don't beep */
X	return;
X    }
X    mark = index(pl_classes, highc(ch));
X    if (!mark) {
X	X11_nhbell();		/* no such class */
X	return;
X    }
X    ps_selected = mark - pl_classes;
X    exit_x_event = TRUE;
X}
X
X
X/* Global functions ========================================================= */
Xvoid
XX11_player_selection()
X{
X    char buf[QBUFSZ];
X    char pc;
X    int num_roles;
X    Widget popup, player_form;
X
X    if ((pc = highc(pl_character[0])) != 0) {
X	if (index(pl_classes, pc)) goto got_suffix;
X	pl_character[0] = pc = 0;
X    }
X
X    for (num_roles = 0; roles[num_roles]; num_roles++)
X	;	/* do nothing */
X
X    popup = make_menu("player_selection", "Choose a Role",
X		player_select_translations,
X		"quit", ps_quit,
X		"random", ps_random,
X		num_roles, roles, ps_select, &player_form);
X
X    ps_selected = 0;
X    positionpopup(popup);
X    nh_XtPopup(popup, XtGrabExclusive, player_form);
X
X    /* The callbacks will enable the event loop exit. */
X    (void) x_event(EXIT_ON_EXIT);
X
X    nh_XtPopdown(popup);
X    XtDestroyWidget(popup);
X
X    if (ps_selected == PS_QUIT) {
X	clearlocks();
X	X11_exit_nhwindows(NULL);
X	terminate(0);
X    }
X
X    if (ps_selected == PS_RANDOM) {
X	winid tmpwin;
X
X	ps_selected = rn2(strlen(pl_classes));
X	pc = pl_classes[ps_selected];
X	Sprintf(buf, "This game you will be %s.", an(roles[ps_selected]));
X
X	tmpwin = X11_create_nhwindow(NHW_TEXT);
X	X11_putstr(tmpwin, 0, "");
X	X11_putstr(tmpwin, 0, buf);
X	X11_putstr(tmpwin, 0, "");
X	X11_display_nhwindow(tmpwin, TRUE);
X	X11_destroy_nhwindow(tmpwin);
X
X    } else if (ps_selected < 0 || ps_selected >= num_roles) {
X	panic("player_selection: bad select value %d\n", ps_selected);
X    } else {
X	pc = pl_classes[ps_selected];
X    }
X
Xgot_suffix:
X    pl_character[0] = pc;
X}
X
X
Xvoid
XX11_get_ext_cmd(input)
X    char *input;
X{
X    extended_command_selected = -1;		/* reset selected value */
X
X    positionpopup(extended_command_popup);	/* center on cursor */
X    nh_XtPopup(extended_command_popup, XtGrabExclusive, extended_command_form);
X
X    /* The callbacks will enable the event loop exit. */
X    (void) x_event(EXIT_ON_EXIT);
X
X    if (extended_command_selected < 0)
X	*input = '\0';
X    else
X	Strcpy(input, extcmdlist[extended_command_selected].ef_txt);
X}
X
X/* End global functions ===================================================== */
X
X/* Extended Command -------------------------------------------------------- */
X/* ARGSUSED */
Xstatic void
Xextend_select(w, client_data, call_data)
X    Widget w;
X    XtPointer client_data, call_data;
X{
X    extended_command_selected = (int) client_data;
X    nh_XtPopdown(extended_command_popup);
X    exit_x_event = TRUE;		/* leave event loop */
X}
X
X/* ARGSUSED */
Xstatic void
Xextend_dismiss(w, client_data, call_data)
X    Widget w;
X    XtPointer client_data, call_data;
X{
X    extended_command_selected = -1;	/* dismiss */
X    nh_XtPopdown(extended_command_popup);
X    exit_x_event = TRUE;		/* leave event loop */
X}
X
X/* ARGSUSED */
Xstatic void
Xextend_help(w, client_data, call_data)
X    Widget w;
X    XtPointer client_data, call_data;
X{
X    /* We might need to make it known that we already have one listed. */
X    (void) doextlist();
X}
X
X/* ARGSUSED */
Xvoid
Xec_key(w, event, params, num_params)
X    Widget w;
X    XEvent *event;
X    String *params;
X    Cardinal *num_params;
X{
X    char ch;
X    int i, mark;
X
X    ch = key_event_to_char((XKeyEvent *) event);
X
X    if (ch == '\0') {	/* don't accept nul char/modifier event */
X	/* don't beep */
X	return;
X    }
X    if (index(quitchars, ch)) {
X	extended_command_selected = -1;	/* dismiss */
X	goto ec_key_done;
X    }
X
X    /*
X     * Note: this depends on the fact that the help option "?" is known
X     * to be last and not counted.
X     */
X    for (mark = -1, i = 0; extcmdlist[i].ef_txt; i++) {
X	if (extcmdlist[i].ef_txt[0] == '?') continue;
X
X	if (ch == extcmdlist[i].ef_txt[0]) {
X	    if (mark != -1) {
X		X11_nhbell(); /* another command with the same first letter */
X		return;
X	    }
X	    mark = i;
X	}
X    }
X    if (mark == -1) {
X	X11_nhbell();
X	return;
X    }
X
X    /*
X     * It would be nice if we could set the selected command before
X     * we pop the window down....  Maybe when I figure out how to do
X     * it.
X     */
X    extended_command_selected = mark;
Xec_key_done:
X    nh_XtPopdown(extended_command_popup);
X    exit_x_event = TRUE;		/* leave event loop */
X}
X
X/*
X * Use our own home-brewed version menu because simpleMenu is designed to
X * be used from a menubox.
X */
Xvoid
Xinit_extended_commands_popup()
X{
X    int i, num_commands;
X    const char **command_list;
X
X    /* count commands */
X    for (num_commands = 0; extcmdlist[num_commands].ef_txt; num_commands++)
X	;	/* do nothing */
X
X    /* If the last entry is "help", don't use it. */
X    if (strcmp(extcmdlist[num_commands-1].ef_txt, "?") == 0)
X	--num_commands;
X
X    command_list = (const char **) alloc(num_commands * sizeof(char *));
X
X    for (i = 0; i < num_commands; i++)
X	command_list[i] = extcmdlist[i].ef_txt;
X
X    extended_command_popup = make_menu("extended_commands",
X				"Extended Commands",
X				extended_command_translations,
X				"dismiss", extend_dismiss,
X				"help", extend_help,
X				num_commands, command_list, extend_select,
X				&extended_command_form);
X
X    free((char *)command_list);
X}
X
X/* ------------------------------------------------------------------------- */
X
X/*
X * Create a popup widget of the following form:
X * 
X *		      popup_label
X *		----------- ------------
X * 		|left_name| |right_name|
X *		----------- ------------
X *		------------------------
X *		|	name1	       |
X *		------------------------
X *		------------------------
X *		|	name2	       |
X *		------------------------
X *			  .
X *			  .
X *		------------------------
X *		|	nameN	       |
X *		------------------------
X */
Xstatic Widget
Xmake_menu(popup_name, popup_label, popup_translations,
X		left_name, left_callback,
X		right_name, right_callback,
X		num_names, widget_names, name_callback, formp)
X    char	   *popup_name;
X    char	   *popup_label;
X    String	   popup_translations;
X    char	   *left_name;
X    XtCallbackProc left_callback;
X    char	   *right_name;
X    XtCallbackProc right_callback;
X    int		   num_names;
X    char	   **widget_names;
X    XtCallbackProc name_callback;
X    Widget	   *formp;	/* return */
X{
X    Widget popup, form, label, above, left, right;
X    Widget *commands, *curr;
X    int i;
X    Arg args[8];
X    Cardinal num_args;
X    Dimension width, max_width;
X    int distance, skip;
X
X
X    commands = (Widget *) alloc(num_names * sizeof(Widget));
X
X
X    num_args = 0;
X    XtSetArg(args[num_args], XtNallowShellResize, True);	num_args++;
X
X    popup = XtCreatePopupShell(popup_name,
X				transientShellWidgetClass,
X				toplevel, args, num_args);
X
X    num_args = 0;
X    XtSetArg(args[num_args], XtNtranslations,
X		XtParseTranslationTable(popup_translations));	num_args++;
X    *formp = form = XtCreateManagedWidget("menuform",
X				formWidgetClass,
X				popup,
X				args, num_args);
X
X    /* Get the default distance between objects in the form widget. */
X    num_args = 0;
X    XtSetArg(args[num_args], XtNdefaultDistance, &distance);	num_args++;
X    XtGetValues(form, args, num_args);
X
X    /*
X     * Create the label.
X     */
X    num_args = 0;
X    XtSetArg(args[num_args], XtNborderWidth, 0);	num_args++;
X    label = XtCreateManagedWidget(popup_label,
X				labelWidgetClass,
X				form,
X				args, num_args);
X
X    /*
X     * Create the left button.
X     */
X    num_args = 0;
X    XtSetArg(args[num_args], XtNfromVert, label);		num_args++;
X/*
X    XtSetArg(args[num_args], XtNshapeStyle,
X				XmuShapeRoundedRectangle);	num_args++;
X*/
X    left = XtCreateManagedWidget(left_name,
X		    commandWidgetClass,
X		    form,
X		    args, num_args);
X    XtAddCallback(left, XtNcallback, left_callback, (XtPointer) 0);
X    skip = 3*distance;	/* triple the spacing */
X    if(!skip) skip = 3;
X
X    /*
X     * Create right button.
X     */
X    num_args = 0;
X    XtSetArg(args[num_args], XtNfromHoriz, left);		num_args++;
X    XtSetArg(args[num_args], XtNfromVert, label);		num_args++;
X/*
X    XtSetArg(args[num_args], XtNshapeStyle,
X				XmuShapeRoundedRectangle);	num_args++;
X*/
X    right = XtCreateManagedWidget(right_name,
X		    commandWidgetClass,
X		    form,
X		    args, num_args);
X    XtAddCallback(right, XtNcallback, right_callback, (XtPointer) 0);
X
X
X    /*
X     * Create and place the command widgets.
X     */
X    for (i = 0, above = left, curr = commands; i < num_names;
X					i++, above = *curr, curr++) {
X	num_args = 0;
X	XtSetArg(args[num_args], XtNfromVert, above);	num_args++;
X	if (i == 0) {
X	    /* if first, we are farther apart */
X	    XtSetArg(args[num_args], XtNvertDistance, skip);	num_args++;
X	}
X
X	*curr = XtCreateManagedWidget(widget_names[i],
X		    commandWidgetClass,
X		    form,
X		    args, num_args);
X	XtAddCallback(*curr, XtNcallback, name_callback, (XtPointer) i);
X    }
X
X    /*
X     * Now find the largest width.  Start with the width dismiss + help
X     * buttons, since they are adjacent.
X     */
X    XtSetArg(args[0], XtNwidth, &max_width);
X    XtGetValues(left, args, ONE);
X    XtSetArg(args[0], XtNwidth, &width);
X    XtGetValues(right, args, ONE);
X    max_width = max_width + width + distance;
X
X    /* Next, the title. */
X    XtSetArg(args[0], XtNwidth, &width);
X    XtGetValues(label, args, ONE);
X    if (width > max_width) max_width = width;
X
X    /* Finally, the commands. */
X    for (i = 0, curr = commands; i < num_names; i++, curr++) {
X	XtSetArg(args[0], XtNwidth, &width);
X	XtGetValues(*curr, args, ONE);
X	if (width > max_width) max_width = width;
X    }
X
X    /*
X     * Finally, set all of the single line widgets to the largest width.
X     */
X    XtSetArg(args[0], XtNwidth, max_width);
X    XtSetValues(label, args, ONE);
X
X    for (i = 0, curr = commands; i < num_names; i++, curr++) {
X	XtSetArg(args[0], XtNwidth, max_width);
X	XtSetValues(*curr, args, ONE);
X    }
X
X    free((char *) commands);
X
X    XtRealizeWidget(popup);
X
X    return popup;
X}
END_OF_FILE
if test 11918 -ne `wc -c <'win/X11/winmisc.c'`; then
    echo shar: \"'win/X11/winmisc.c'\" unpacked with wrong size!
fi
# end of 'win/X11/winmisc.c'
fi
echo shar: End of archive 24 \(of 108\).
cp /dev/null ark24isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \
21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \
41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 \
61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 \
81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 \
101 102 103 104 105 106 107 108 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 108 archives.
    echo "Now execute 'rebuild.sh'"
    rm -f ark10[0-8]isdone ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
