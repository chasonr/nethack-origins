Path: uunet!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v16i083:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Part75/108
Message-ID: <4446@master.CNA.TEK.COM>
Date: 5 Feb 93 19:19:57 GMT
Sender: news@master.CNA.TEK.COM
Lines: 1642
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1634

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 16, Issue 83
Archive-name: nethack31/Part75
Supersedes: nethack3p9: Volume 10, Issue 46-102
Environment: Amiga, Atari, Mac, MS-DOS, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 75 (of 108)."
# Contents:  dat/data.base win/X11/winmap.c
# Wrapped by billr@saab on Wed Jan 27 16:09:16 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'dat/data.base' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dat/data.base'\"
else
echo shar: Extracting \"'dat/data.base'\" \(25887 characters\)
sed "s/^X//" >'dat/data.base' <<'END_OF_FILE'
X#	NetHack data file - version 3.1a
X#	The demons are all listed first because makedefs used to have to give
X#	them special handling for #ifndef INFERNO; it doesn't matter any more.
Xbalrog
X		...  It came to the edge of the fire and the light  faded as
X		if a  cloud had  bent over it.  Then  with a rush it  leaped
X		the fissure.  The flames roared up to greet it, and wreathed
X		about  it; and a black smoke swirled in the air. Its stream-
X		ing  mane kindled,  and blazed behind it.  In its right hand
X		was a  blade like a stabbing tongue of fire;  in its left it
X		held a whip of many thongs.
X		'Ai, ai!'  wailed Legolas. 'A Balrog!  A Balrog is come!'
X			   [ The Fellowship of the Ring, by J.R.R. Tolkien ]
Xhorned devil
X		Horned devils lack any real special abilities,  though  they
X		are quite difficult to kill.
Xincubus
Xsuccubus
X		The incubus and succubus are male and female versions of the
X		same  demon, one who lies with a human for its own purposes,
X		usually to the detriment of the mortals who  are  unwise  in
X		their dealings with them.
Xerinyes
X		These female-seeming devils  attack hand to hand  and poison
X		their unwary victims as well.
Xmarilith
X		The marilith, a type V demon, has a torso shaped  like  that
X		of  a human female, and the lower body of a great snake.  It
X		has multiple arms, and can freely attack with all  of  them.
X		Since it is intelligent enough to use weapons, this means it
X		can cause great damage.
Xbarbed devil
X		Barbed devils lack any real special abilities,  though  they
X		are quite difficult to kill.
Xvrock
X		The vrock is one of the weaker forms of demon, being only  a
X		type  I.   It  resembles a cross between a human being and a
X		vulture and does physical damage by biting and by using  the
X		claws on both its arms and feet.
Xhezrou
X		``Hezrou'' is the common name for the type II demon.  It  is
X		among the weaker of demons, but still quite formidable.
Xbone devil
X		Bone devils attack with weapons and with a great hooked tail
X		which causes a loss of strength to those they sting.
Xnalfeshnee
X		Not only do these demons, which are of type IV, do  physical
X		damage  with  their  claws and bite, but they are capable of
X		using magic as well.
Xice devil
X		Ice devils  are  large  semi-insectoid  creatures,  who  are
X		equally  at home in the fires of Hell and the cold of Limbo,
X		and who can cause the traveller to feel the latter with just
X		a touch of their tail.
Xpit fiend
X		Pit fiends are among the more powerful of devils, capable of
X		attacking  twice with weapons as well as grabbing and crush-
X		ing the life out of  those  unwary  enough  to  enter  their
X		domains.
Xjuiblex
Xjubilex
X		Little is known about the Faceless Lord,  even  the  correct
X		spelling  of  his name.  He does not have a physical form as
X		we know it, and those who have peered into his  realm  claim
X		he  is  a  slime-like  creature who swallows other creatures
X		alive, spits acidic secretions, and causes  disease  in  his
X		victims which can be almost instantly fatal.
Xyeenoghu
X		Yeenoghu, the demon lord of gnolls,  still  exists  although
X		all his followers have been wiped off the face of the earth.
X		He casts magic projectiles at those close to him, and a mere
X		gaze  into  his  piercing  eyes  may  hopelessly confuse the
X		battle-weary adventurer.
Xorcus
X		Orcus, Prince of the Undead, has a rams head  and  a  poison
X		stinger.   He is most feared, though, for his powerful magic
X		abilities.  His wand causes death to those he chooses.
Xgeryon
X		Geryon is an arch-devil sometimes  called  the  Wild  Beast,
X		attacking  with  his claws and poison sting.  His ranking in
X		Hell is rumored to be quite low.
Xdispater
X		Dispater is an arch-devil who rules the city of Dis.  He  is
X		a powerful mage.
Xbaalzebub
X		Baalzebub has been known as the lord of the flies.  His bite
X		drips  poison,  and a mere glance into his eyes can stun the
X		hapless invader of his realm.
Xasmodeus
X		It is said that Asmodeus is the overlord over all  of  hell.
X		His  appearance,  unlike  many  other  demons and devils, is
X		human apart from his horns and tail.  He  can  freeze  flesh
X		with a touch.
Xdemogorgon
X		Demogorgon, the prince of demons, wallows in filth  and  can
X		spread  a quickly fatal illness to his victims while rending
X		them.  He is a mighty spellcaster, and he can drain the life
X		of mortals with a touch of his tail.
Xathame
X		The  consecrated ritual knife of  a Wiccan  initiate (one of
X		four  basic  tools,  together  with the  wand,  chalice  and
X		pentacle).   Traditionally, the  athame  is  a double-edged,
X		black-handled,  cross-hilted   dagger  of  between  six  and
X		eighteen inches length.
X*centaur
X		Of all the monsters put together by  the  Greek  imagination
X		the  Centaurs (Kentauroi) constituted a class in themselves.
X		Despite a strong streak  of  sensuality  in  their  make-up,
X		their  normal  behaviour  was  moral, and they took a kindly
X		thought of man's welfare. The attempted outrage of Nessos on
X		Deianeira,  and  that  of the whole tribe of Centaurs on the
X		Lapith women,  are more than offset  by the  hospitality  of
X		Pholos and  by  the  wisdom of Cheiron,  physician, prophet,
X		lyrist,  and the instructor of Achilles.  Further,  the Cen-
X		taurs  were  peculiar in that their nature, which united the
X		body of a horse with the trunk and head of a  man,  involved
X		an  unthinkable  duplication  of  vital organs and important
X		members.  So grotesque a combination seems almost  un-Greek.
X		These  strange creatures  were said to live in the caves and
X		clefts of the mountains, myths associating  them  especially
X		with the hills of Thessaly and the range of Erymanthos.
X			     [ Mythology of all races, Vol. 1, pp. 270-271 ]
Xcockatrice
X		Once in a great while, when the positions of the  stars  are
X		just right, a seven-year-old rooster will lay an egg.  Then,
X		along will come a snake, to coil around the egg, or a  toad,
X		to  squat  upon  the  egg, keeping it warm and helping it to
X		hatch.  When it hatches, out comes a creature called  basil-
X		isk, or cockatrice, the most deadly of all creatures. A sin-
X		gle glance from its yellow, piercing toad's eyes  will  kill
X		both man  and beast.  Its power of destruction is said to be
X		so great that sometimes simply to hear its  hiss  can  prove
X		fatal.  Its  breath is so venomous  that it causes all vege-
X		tation to wither.
X	
X		There is, however, one  creature  which  can  withstand  the
X		basilisk's deadly gaze, and this is the weasel. No one knows
X		why this is so, but although the fierce weasel can slay  the
X		basilisk, it will itself be killed in the struggle.  Perhaps
X		the weasel knows the basilisk's fatal weakness:  if it  ever
X		sees  its own reflection in a mirror it will perish instant-
X		ly.  But even a dead basilisk is dangerous, for  it is  said
X		that merely touching its lifeless body can cause a person to
X		sicken and die.
X		[ Mythical Beasts by Deirdre Headon (The Leprechaun Library)
X		  and other sources ]
X*dragon
X		In the West  the dragon was  the  natural  enemy   of   man.
X		Although  preferring  to live in bleak and desolate regions,
X		whenever it was seen among men it left in its wake a   trail
X		of   destruction   and disease. Yet any attempt to slay this
X		beast was a perilous undertaking. For the dragon's assailant
X		had  to  contend not  only  with clouds of  sulphurous fumes
X		pouring from its fire-breathing nostrils, but also with  the
X		thrashings  of  its  tail,  the  most   deadly  part  of its
X		serpent-like body.
X		[Mythical Beasts by Deirdre Headon (The Leprechaun Library)]
X*elemental
X		Elementals are manifestations of the  basic  nature  of  the
X		universe.   There  are four known forms of elementals:  air,
X		fire, water, and earth.  Some mystics  have  postulated  the
X		necessity  for  a fifth type, the spirit elemental, but none
X		have ever been encountered, at least on this  plane  of  ex-
X		istence.
X*giant
Xgiant humanoid
X		Giants have always walked the earth, though they are rare in
X		these times.  They range in size from  little over nine feet
X		to a towering twenty feet or more.  The larger ones use huge
X		boulders as weapons, hurling them over large distances.  All
X		types of giants share a love for men  -  roasted, boiled, or
X		fried.  Their table manners are legendary.
Xgnome*
Xgnomish wizard
X		...  And then a gnome came by,  carrying a bundle,   an  old
X		fellow three times  as large as an imp  and wearing  clothes
X		of a sort, especially a hat.  And he was  clearly   just  as
X		frightened   as  the  imps  though  he could not go so fast.
X		Ramon Alonzo saw that there must be some great trouble  that
X		was  vexing  magical  things;   and,  since gnomes speak the
X		language of men, and will answer if spoken  to  gently,   he
X		raised  his  hat,   and  asked  of the gnome  his name.  The
X		gnome did not  stop  his  hasty  shuffle  a  moment   as  he
X		answered 'Alaraba' and grabbed the rim of his hat but forgot
X		to doff it.
X		'What is the trouble, Alaraba?' said Ramon Alonzo.
X		'White magic. Run!' said the gnome ...
X				[ The Charwoman's Shadow, by Lord Dunsany. ]
Xgold
Xgold piece
X		A metal of characteristic yellow colour, the  most  precious
X		metal  used as a common commercial medium of exchange.  Sym-
X		bol, Au; at.  no. 79; at. wt. 197.2.  It is the most  malle-
X		able  and  ductile  of  all metals, and very heavy (sp. gr.,
X		19.3).  It is quite unalterable by heat, moisture, and  most
X		corrosive  agents,  and therefore well suited for its use in
X		coin and jewelry.
X				[ Webster's New International Dictionary
X				  of the English Language, Second Edition ]
X*golem
X		These creatures, not quite living but not  really  nonliving
X		either,   are   created from inanimate materials by powerful
X		mages or priests.
Xgremlin
X		The  gremlin is a highly  intelligent and  completely   evil
X		creature.   It lives to torment  other creatures and will go
X		to great lengths to inflict pain or cause injury.
Xgrid bug
X		These  electrically based creatures are  not native  to this
X		universe.  They  appear to come from a world  whose  laws of
X		motion are radically different from ours.
Xhobbit
X		Hobbits  are  an unobtrusive  but very ancient people,  more
X		numerous formerly than they are today;  for they love  peace
X		and quiet and good tilled earth:  a  well-ordered and  well-
X		farmed countryside  was their favourite haunt.  They  do not
X		and  did  not  understand  or like machines more complicated
X		than a forge-bellows, a water-mill, or a handloom,  although
X		they  were skillful with tools.  Even  in ancient days  they
X		were, as a rule, shy of "the Big Folk", as they call us, and
X		now they avoid us with dismay and are becoming hard to find.
X			   [ The Fellowship of the Ring, by J.R.R. Tolkien ]
Xhobgoblin
X		Hobgoblin. Used by the  Puritans  and  in  later  times  for
X		wicked  goblin  spirits,  as in Bunyan's 'Hobgoblin nor foul
X		friend', but its more correct use is for the friendly  spir-
X		its  of  the brownie type.  In 'A midsummer night's dream' a
X		fairy says to Shakespeare's Puck:
X		        Those that Hobgoblin call you, and sweet Puck,
X		        You do their work, and they shall have good luck:
X		        Are you not he?
X		and obviously Puck would not wish to be called  a  hobgoblin
X		if that was an ill-omened word.
X		Hobgoblins are on the whole, good-humoured and ready  to  be
X		helpful,  but fond of practical joking, and like most of the
X		fairies rather nasty people to annoy. Boggarts hover on  the
X		verge of hobgoblindom.  Bogles are just over the edge.
X		One Hob mentioned by Henderson, was Hob Headless who haunted
X		the  road  between Hurworth and Neasham, but could not cross
X		the little river Kent, which flowed into the  Tess.  He  was
X		exorcised  and  laid under a large stone by the roadside for
X		ninety-nine years and a day. If anyone was so unwary  as  to
X		sit  on  that stone, he would be unable to quit it for ever.
X		The ninety-nine years is nearly up, so trouble may  soon  be
X		heard of on the road between Hurworth and Neasham.
X		             [ Katharine Briggs, A  dictionary  of Fairies ]
Xhumanoid
X		Humanoids  are all approximately  the size of a human,   and
X		may  be  mistaken for one  at a distance.  They  are usually
X		of a tribal  nature, and will  fiercely defend their  lairs.
X		Usually   hostile, they  may even band  together to raid and
X		pillage human settlements.
Xhuman
Xarcheologist
Xbarbarian
Xcave*man
Xelf
Xhealer
Xknight
X*priest*
Xrogue
Xsamurai
Xtourist
Xvalkyrie
Xwizard
X		These strange creatures live mostly on the  surface  of  the
X		earth, gathering together in societies of various forms, but
X		occasionally a stray will descend into the depths and commit
X		mayhem  among  the  dungeon  residents who, naturally, often
X		resent the intrusion of such beasts.  They  are  capable  of
X		using  weapons  and  magic,  and it is even rumored that the
X		Wizard of Yendor is a member of this species.
Ximp
X		 ... imps ... little creatures of two feet high  that  could
X		gambol and jump prodigiously; ...
X				 [ The Charwoman's Shadow, by Lord Dunsany ]
X	
X		An 'imp' is an off-shoot or cutting.  Thus an 'ymp tree' was
X		a grafted tree, or one grown from a cutting, not from seed.
X		'Imp' properly means a small devil, an off-shoot  of  Satan,
X		but  the distinction between goblins or bogles and imps from
X		hell is hard to make, and many in the  Celtic  countries  as
X		well as the English Puritans regarded all fairies as devils.
X		The fairies of tradition often hover  uneasily  between  the
X		ghostly and the diabolic state.
X			       [ Katharine Briggs, A Dictionary of Fairies ]
Xjabberwock
Xvorpal*
X		"Beware the Jabberwock, my son!
X		  The jaws that bite, the claws that catch!
X		Beware the Jubjub bird, and shun
X		  The frumious Bandersnatch!"
X		
X		He took his vorpal sword in hand;
X		  Long time the manxome foe he sought --
X		So rested he by the Tumtum tree,
X		  And stood awhile in thought.
X		
X		And, as in uffish thought he stood,
X		  The Jabberwock, with eyes of flame,
X		Came whiffling through the tulgey wood,
X		  And burbled as it came!
X					[ Jabberwocky, by Lewis Carroll ]
Xkatana
X		Also  known  as the  samurai  sword, the katana  is  a long,
X		single-edged  sword  with slightly curved  blade.   Its long
X		handle is designed to allow it to be wielded with either one
X		or two hands.
X*kobold*
X		The race of kobolds are reputed to be an artificial creation
X		of a master wizard (demi-god?).  They are about 3' tall with
X		a vaguely dog-like face.  They bear a violent dislike of the
X		Elven race, and  will go out  of their way to  cause trouble
X		for Elves at any time.
Xleprechaun
X		The Irish Leprechaun is the Faeries' shoemaker and is  known
X		under  various names  in different parts of Ireland:  Cluri-
X		caune in Cork, Lurican in Kerry, Lurikeen in Kildare and Lu-
X		rigadaun  in  Tipperary.  Although he works for the Faeries,
X		the Leprechaun is not of the same species.  He is small, has
X		dark  skin  and wears strange clothes.  His nature has some-
X		thing of the manic-depressive about it:  first he  is  quite
X		happy, whistling merrily as he nails a sole on to a shoe;  a
X		few minutes later, he is sullen and  morose,  drunk  on  his
X		home-made heather ale.  The Leprechaun's two great loves are
X		tobacco and whiskey, and he is a first-rate con-man,  impos-
X		sible  to  out-fox.  No  one, no matter how clever, has ever
X		managed to cheat him out of his hidden pot of  gold  or  his
X		magic shilling.  At the last minute he always thinks of some
X		way to divert his captor's attention  and  vanishes  in  the
X		twinkling  of  an eye.
X				     [ A Field Guide to the Little People
X				       by Nancy Arrowsmith & George Moorse ]
Xleocrotta
Xleu*otta
X		...the leucrocotta, a wild beast of extraordinary swiftness,
X		the size of the wild ass, with the legs of a Stag, the neck,
X		tail, and breast of a lion,  the head of a badger,  a cloven
X		hoof, the mouth slit up as far as the ears,  and one contin-
X		uous bone  instead of  teeth;  it is said,  too,  that  this
X		animal can imitate the human voice.
X			       [ Curious Creatures in Zoology, John Ashton ]
X*lich
X		Once in a great  while, an evil master wizard or priest will
X		manage through use of great magics to extend his or her life
X		far beyond the normal  span of a human.  The usual effect of
X		this is to transform the human, over time, into an undead of
X		great magical power.  A Lich  hates life in any form; even a
X		touch from one of these  creatures will cause a numbing cold
X		in the victim.  They all possess the capability to use magic.
Xmedusa
X		This hideous  creature from  ancient Greek myth was the doom
X		of many a valiant adventurer.  It is said that one gaze from
X		its eyes  could turn a man to stone.  One bite from the nest
X		of  snakes which  crown its head could  cause instant death.
X		The only  way to kill this  monstrosity is to turn its  gaze
X		back upon itself.
Xmind flayer
X		This creature has a humanoid  body, but has tentacles around
X		its covered mouth and only three long fingers  on each hand.
X		Mind flayers are  telepathic, and love to devour intelligent
X		beings, especially humans.  If they hit their victim  with a
X		tentacle,  the mind flayer  will  slowly  drain  it  of  all
X		intelligence, eventually killing the victim.
Xmithril*
X		_Mithril_!   All folk  desired it.  It could be  beaten like
X		copper, and polished like glass;  and the Dwarves could make
X		of it  a metal,  light and yet harder  than tempered  steel.
X		Its beauty was like to that of common silver, but the beauty
X		of _mithril_ did not tarnish  or grow dim.
X			   [ The Fellowship of the Ring, by J.R.R. Tolkien ]
Xmumak*
X		... the Mumak of Harad was indeed  a beast of vast bulk, and
X		the like of him  does not walk now in Middle-Earth;  his kin
X		that live still in latter days are but memories of his girth
X		and  majesty.   On he came, ... his great legs  like  trees,
X		enormous sail-like ears spread out, long snout upraised like
X		a huge serpent  about to strike,  his small red eyes raging.
X		His upturned hornlike tusks ... dripped with blood.
X				       [ The Two Towers, by J.R.R. Tolkien ]
X*naga*
X		The naga is a mystical creature with the body of a snake and
X		the head of a man or woman.  They will fiercely  protect the
X		territory they consider their own.  Some nagas can be forced
X		to serve as a guardian by a spell caster of great power.
X*ooze
X*pudding
X		These giant amoeboid creatures look like nothing  more  than
X		puddles  of  slime,  but they both live and move, feeding on
X		metal or wood as well as the occasional dungeon explorer  to
X		supplement their diet.
Xorcrist
X		The  Great Goblin  gave a truly awful howl of  rage when  he
X		looked  at  it,  and  all his soldiers  gnashed their teeth,
X		clashed their shields,  and stamped.  They knew the sword at
X		once.  It had killed hundreds of goblins in  its time,  when
X		the  fair elves of Gondolin hunted them in the hills or  did
X		battle  before  their  walls.  They  had called it  Orcrist,
X		Goblin-cleaver, but the goblins called it simply Biter. They
X		hated it and hated worse any one that carried it.
X					   [ The Hobbit, by J.R.R. Tolkien ]
Xosaku
X		The osaku is a small tool for picking locks.
Xpiercer
X		Ye Piercer doth look like unto  a  stalactyte,  and  hangeth
X		from  the  roofs of caves and caverns.  Unto the height of a
X		man, and thicker than a man's thigh do  they  grow,  and  in
X		groups  do they hang.  If a creature doth pass beneath them,
X		they will by its heat and noise perceive it, and  fall  upon
X		it  to kill and devour it, though in any other way they move
X		but exceeding slow.
X						   [ the Bestiary of Xygag ]
Xquantum mechanic
X		These creatures are not native to this universe;  they  seem
X		to have strangely derived powers, and unknown motives.
Xquadruped
X		The woodlands and other regions  are inhabited by multitudes
X		of four-legged creatures  which cannot be simply classified.
X		They might not have fiery breath  or deadly stings,  but ad-
X		venturers  have  nevertheless  met their end  numerous times
X		due to the claws, hooves, or bites of such animals.
Xrust monster
X		These strange creatures live on a   diet  of  metals.   They
X		will  turn  a  suit  of  armour into so much useless  rusted
X		scrap in no time at all.
Xsasquatch
X		An ape-like humanoid  native to densely forested  mountains,
X		the sasquatch is  also known as "bigfoot".   Normally benign
X		are rarely seen,  this creature is reputed to be  a relative
X		of the ferocious yeti.
Xsnickersnee
X		Ah, never shall I forget the cry, 
X		    or the shriek that shrieked he,
X		As I gnashed my teeth, and from my sheath
X		    I drew my Snickersnee!
X		--Koko, Lord high executioner of Titipu
X				     [ The Mikado, by Sir W.S. Gilbert ]
X*soldier
Xsergeant
Xlieutenant
Xcaptain
X		The soldiers  of Yendor are  well-trained in the art of war,
X		many  trained by  the Wizard himself.  Some say the soldiers
X		are explorers  who were  unfortunate enough  to be captured,
X		and  put under the Wizard's spell.  Those who have  survived
X		encounters  with  soldiers   say  they  travel  together  in
X		platoons,  and are fierce fighters.  Because of the  load of
X		their  combat gear,  however,  one can usually run away from
X		them, and doing so is considered a wise thing.
Xtengu
X		The tengu was the  most  troublesome  creature  of  Japanese
X		legend.   Part  bird  and part man, with red beak for a nose
X		and flashing eyes, the tengu was notorious for  stirring  up
X		feuds  and  prolonging  enmity between families. Indeed, the
X		belligerent tengus were supposed to have  been  man's  first
X		instructors in the use of arms.
X		[Mythical Beasts by Deirdre Headon (The Leprechaun Library)]
Xtsurugi
X		The tsurugi,  also known  as  the long samurai sword,  is an
X		extremely  sharp,  two-handed blade favored  by the samurai.
X		It  is made of hardened steel,  and is manufactured  using a
X		special  process, causing it  to never rust.  The tsurugi is
X		rumored  to  be  so  sharp  that  it  can  occasionally  cut
X		opponents in half!
X*unicorn
Xunicorn horn
X		Men have always sought the elusive unicorn, for  the  single
X		twisted  horn  which projected from its forehead was thought
X		to be a powerful talisman.  It was said that the unicorn had
X		simply  to  dip  the tip of its horn in a muddy pool for the
X		water to become pure.  Men also believed that to  drink from
X		this horn was a protection against all sickness, and that if
X		the horn was ground to a powder it would act as an  antidote
X		to all poisons.  Less than 200 years ago in France, the horn
X		of a unicorn was used in a ceremony to test the  royal  food
X		for poison.
X	
X		Although only the size of a small horse, the  unicorn  is  a
X		very  fierce  beast,  capable  of killing an elephant with a
X		single thrust from its horn.  Its  fleetness  of  foot  also
X		makes  this solitary creature difficult to capture. However,
X		it can be tamed and captured by a maiden. Made gentle by the
X		sight  of a virgin, the unicorn can be lured to lay its head
X		in her lap, and in this docile mood, the maiden  may  secure
X		it with a golden rope.
X		[Mythical Beasts by Deirdre Headon (The Leprechaun Library)]
Xwakizashi
X		The samurai  warrior  traditionally  wears  two  swords; the
X		wakizashi is the shorter of the two.  See also katana.
X*long worm
Xworm tooth
Xcrysknife
X		[The crysknife] is manufactured in two forms from teeth tak-
X		en  from dead sandworms.  The two forms are "fixed" and "un-
X		fixed." An unfixed  knife  requires  proximity  to  a  human
X		body's  electrical  field  to prevent disintegration.  Fixed
X		knives are treated for storage.  All are about  20  centime-
X		ters long.
X						  [ Dune, by Frank Herbert ]
Xwizard of yendor
X		No  one knows how old this mighty wizard is,  or from whence
X		he came.  It is known that,  having lived a span far greater
X		than any normal man's, he grew weary of lesser mortals;  and
X		so, spurning all human company,  he forsook the dwellings of
X		men  and  went to live in the depths of the  Earth.  He took
X		with him the mystical artifact, the Amulet of Yendor,  which
X		is said to hold great power indeed. Many have sought to find
X		the  wizard and  his treasure,  but none have found  him and
X		lived to tell the tale.  Woe be to the incautious adventurer
X		who disturbs this mighty sorcerer!
Xxan
X		They sent their friend the mosquito [xan] ahead of  them  to
X		find  out  what lay ahead.  "Since you are the one who sucks
X		the blood of men walking along paths," they told the mosqui-
X		to,  "go  and  sting the men of Xibalba."  The mosquito flew
X		down the dark road to the Underworld.  Entering the house of
X		the Lords of Death, he stung the first person that he saw...
X	
X		The mosquito stung this man as well, and when he yelled, the
X		man  next  to him asked, "Gathered Blood, what's wrong?"  So
X		he flew along the row stinging all the seated men  until  he
X		knew the names of all twelve.
X				[ Popul Vuh, as translated by Ralph Nelson ]
Xya
X		The arrow  of  choice of the samurai,  ya  are  made of very
X		straight bamboo, and are  tipped  with hardened steel.
Xyeti
X		An ape-like humanoid  native to inaccessible  mountain tops,
X		the yeti is also known as "the abominable snowman".  Whether
X		or not the title "man" is appropriate remains unknown.
Xyumi
X		The samurai is highly  trained  with a special type  of bow,
X		the yumi.  Like the  ya, the yumi  is  made of bamboo.  With
X		the yumi-ya, the bow and arrow, the samurai is an  extremely
X		accurate and deadly warrior.
X*zombie
X		The zombi...  is a soulless human corpse,  still  dead,  but
X		taken	from  the  grave  and  endowed	by  sorcery  with  a
X		mechanical semblance of life, --  it is a dead body which is
X		made to walk and act and move as if it were alive.
X							  [ W. B. Seabrook ]
Xzruty
X		The zruty are  wild and gigantic beings,  living in the wil-
X		dernesses of the Tatra mountains.
END_OF_FILE
if test 25887 -ne `wc -c <'dat/data.base'`; then
    echo shar: \"'dat/data.base'\" unpacked with wrong size!
fi
# end of 'dat/data.base'
fi
if test -f 'win/X11/winmap.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'win/X11/winmap.c'\"
else
echo shar: Extracting \"'win/X11/winmap.c'\" \(28534 characters\)
sed "s/^X//" >'win/X11/winmap.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)winmap.c	3.1	92/04/30		  */
X/* Copyright (c) Dean Luick, 1992				  */
X/* NetHack may be freely redistributed.  See license for details. */
X
X/*
X * This file contains:
X *	+ global functions print_glyph() and cliparound()
X * 	+ the map window routines
X *	+ the char and pointer input routines
X *
X * Notes:
X *	+ We don't really have a good way to get the compiled ROWNO and 
X *	  COLNO as defaults.  They are hardwired to the current "correct"
X *	  values in the Window widget.  I am _not_ in favor of including
X *	  some nethack include file for Window.c.
X */
X#include <X11/Intrinsic.h>
X#include <X11/StringDefs.h>
X#include <X11/Shell.h>
X#include <X11/Xaw/Cardinals.h>
X#include <X11/Xaw/Scrollbar.h>
X#include <X11/Xaw/Viewport.h>
X#include "Window.h"	/* map widget declarations */
X
X#include "hack.h"
X#include "winX.h"
X
X/* Define these if you really want a lot of junk on your screen. */
X/* #define VERBOSE		/* print various info & events as they happen */
X/* #define VERBOSE_UPDATE	/* print screen update bounds */
X/* #define VERBOSE_INPUT	/* print input events */
X
Xstatic void set_button_values();
Xstatic void map_check_size_change();
Xstatic void map_update();
Xstatic void map_exposed();
Xstatic void map_input();
Xstatic void set_gc();
Xstatic void get_gc();
Xstatic void get_char_info();
Xstatic void display_cursor();
X
X/* Global functions ======================================================== */
X
Xvoid
XX11_print_glyph(window, x, y, glyph)
X    winid window;
X    xchar x, y;
X    int glyph;
X{
X    uchar	      ch;
X    register int      offset;
X    struct map_info_t *map_info;
X    register unsigned char *ch_ptr;
X#ifdef TEXTCOLOR
X    int     color;
X    register unsigned char *co_ptr;
X
X#define zap_color(n)  color = zapcolors[n]
X#define cmap_color(n) color = defsyms[n].color
X#define trap_color(n) color = (n == WEB) ? defsyms[S_web ].color : \
X					   defsyms[S_trap].color
X#define obj_color(n)  color = objects[n].oc_color
X#define mon_color(n)  color = mons[n].mcolor
X#define pet_color(n)  color = mons[n].mcolor
X
X# else /* no text color */
X
X#define zap_color(n)
X#define cmap_color(n)
X#define trap_color(n)
X#define obj_color(n)
X#define mon_color(n)
X#define pet_color(n)
X#endif
X
X    check_winid(window);
X    if (window_list[window].type != NHW_MAP) {
X	impossible("print_glyph: can (currently) only print to map windows");
X	return;
X    }
X    map_info = window_list[window].map_information;
X
X    /*
X     *  Map the glyph back to a character.
X     *
X     *  Warning:  For speed, this makes an assumption on the order of
X     *            offsets.  The order is set in display.h.
X     */
X    if ((offset = (glyph - GLYPH_SWALLOW_OFF)) >= 0) {		/* swallow */
X	/* see swallow_to_glyph() in display.c */
X	ch = (uchar) showsyms[S_sw_tl + (offset & 0x7)];
X	mon_color(offset >> 3);
X    } else if ((offset = (glyph - GLYPH_ZAP_OFF)) >= 0) {	/* zap beam */
X	/* see zapdir_to_glyph() in display.c */
X	ch = showsyms[S_vbeam + (offset & 0x3)];
X	zap_color((offset >> 2));
X    } else if ((offset = (glyph - GLYPH_CMAP_OFF)) >= 0) {	/* cmap */
X	ch = showsyms[offset];
X	cmap_color(offset);
X    } else if ((offset = (glyph - GLYPH_TRAP_OFF)) >= 0) {	/* trap */
X	ch = (offset == WEB) ? showsyms[S_web] : showsyms[S_trap];
X	trap_color(offset);
X    } else if ((offset = (glyph - GLYPH_OBJ_OFF)) >= 0) {	/* object */
X	ch = oc_syms[objects[offset].oc_class];
X	obj_color(offset);
X    } else if ((offset = (glyph - GLYPH_BODY_OFF)) >= 0) {	/* a corpse */
X	ch = oc_syms[objects[CORPSE].oc_class];
X	mon_color(offset);
X    } else if ((offset = (glyph - GLYPH_PET_OFF)) >= 0) {	/* a pet */
X	ch = monsyms[mons[offset].mlet];
X	pet_color(offset);
X    } else {							/* a monster */
X	ch = monsyms[mons[glyph].mlet];
X	mon_color(glyph);
X    }
X
X    /* Only update if we need to. */
X    ch_ptr = &map_info->text[y][x];
X
X#ifdef TEXTCOLOR
X    co_ptr = &map_info->colors[y][x];
X    if (*ch_ptr != ch || *co_ptr != color)
X#else
X    if (*ch_ptr != ch)
X#endif
X    {
X	*ch_ptr = ch;
X#ifdef TEXTCOLOR
X	*co_ptr = color;
X#endif
X	/* update row bbox */
X	if ((uchar) x < map_info->t_start[y]) map_info->t_start[y] = x;
X	if ((uchar) x > map_info->t_stop[y])  map_info->t_stop[y]  = x;
X    }
X
X#undef zap_color
X#undef cmap_color
X#undef trap_color
X#undef obj_color
X#undef mon_color
X#undef pet_color
X}
X
X#ifdef CLIPPING
X/*
X * The is the tty clip call.  Since X can resize at any time, we can't depend
X * on this being defined.
X */
X/*ARGSUSED*/
Xvoid X11_cliparound(x, y) int x, y; { }
X#endif /* CLIPPING */
X
X/* End global functions ==================================================== */
X
X
X/*
X * Make sure the map's cursor is always visible.
X */
Xvoid
Xcheck_cursor_visibility(wp)
X    struct xwindow *wp;
X{
X    Arg arg[2];
X    Widget viewport, horiz_sb, vert_sb;
X    float top, shown, cursor_middle;
X    Boolean do_call, adjusted = False;
X#ifdef VERBOSE
X    char *s;
X#endif
X
X    viewport = XtParent(wp->w);
X    horiz_sb = XtNameToWidget(viewport, "horizontal");
X    vert_sb  = XtNameToWidget(viewport, "vertical");
X
X#define V_BORDER 0.1		/* if this far from vert edge, shift */
X#define H_BORDER 0.0625		/* if this from from horiz edge, shift */
X
X#define H_DELTA 0.25		/* distance of horiz shift */
X				/* vert shift is half of curr distance */
X/* The V_DELTA is 1/2 the value of shown. */
X
X    if (horiz_sb) {
X	XtSetArg(arg[0], XtNshown,	&shown);
X	XtSetArg(arg[1], XtNtopOfThumb, &top);
X	XtGetValues(horiz_sb, arg, TWO);
X
X	cursor_middle = (((float) wp->cursx) + 0.5) / (float) COLNO;
X	do_call = True;
X
X#ifdef VERBOSE
X	if (cursor_middle < top) {
X	    s = " outside left";
X	} else if (cursor_middle < top + H_BORDER) {
X	    s = " close to left";
X	} else if (cursor_middle > (top + shown)) {
X	    s = " outside right";
X	} else if (cursor_middle > (top + shown - H_BORDER)) {
X	    s = " close to right";
X	} else {
X	    s = "";
X	}
X	printf("Horiz: shown = %3.2f, top = %3.2f%s", shown, top, s);
X#endif
X
X	if (cursor_middle < top) {
X	    top = cursor_middle - H_DELTA;
X	    if (top < 0.0) top = 0;
X	} else if (cursor_middle < top + H_BORDER) {
X	    top -= H_DELTA;
X	    if (top < 0.0) top = 0.0;
X	} else if (cursor_middle > (top + shown)) {
X	    top = cursor_middle + H_DELTA;
X	    if (top + shown > 1.0) top = 1.0 - shown;
X	} else if (cursor_middle > (top + shown - H_BORDER)) {
X	    top += H_DELTA;
X	    if (top + shown > 1.0) top = 1.0 - shown;
X	} else {
X	    do_call = False;
X	}
X
X	if (do_call) {
X	    XtCallCallbacks(horiz_sb, XtNjumpProc, &top);
X	    adjusted = True;
X	}
X    }
X
X    if (vert_sb) {
X	XtSetArg(arg[0], XtNshown,      &shown);
X	XtSetArg(arg[1], XtNtopOfThumb, &top);
X	XtGetValues(vert_sb, arg, TWO);
X
X	cursor_middle = (((float) wp->cursy) + 0.5) / (float) ROWNO;
X	do_call = True;
X
X#ifdef VERBOSE
X	if (cursor_middle < top) {
X	    s = " above top";
X	} else if (cursor_middle < top + V_BORDER) {
X	    s = " close to top";
X	} else if (cursor_middle > (top + shown)) {
X	    s = " below bottom";
X	} else if (cursor_middle > (top + shown - V_BORDER)) {
X	    s = " close to bottom";
X	} else {
X	    s = "";
X	}
X	printf("%sVert: shown = %3.2f, top = %3.2f%s",
X				    horiz_sb ? ";  " : "", shown, top, s);
X#endif
X
X	if (cursor_middle < top) {
X	    top = cursor_middle - (shown / 2.0);
X	    if (top < 0.0) top = 0;
X	} else if (cursor_middle < top + V_BORDER) {
X	    top -= shown / 2.0;
X	    if (top < 0.0) top = 0;
X	} else if (cursor_middle > (top + shown)) {
X	    top = cursor_middle - (shown / 2.0);
X	    if (top < 0.0) top = 0;
X	    if (top + shown > 1.0) top = 1.0 - shown;
X	} else if (cursor_middle > (top + shown - V_BORDER)) {
X	    top += shown / 2.0;
X	    if (top + shown > 1.0) top = 1.0 - shown;
X	} else {
X	    do_call = False;
X	}
X
X	if (do_call) {
X	    XtCallCallbacks(vert_sb, XtNjumpProc, &top);
X	    adjusted = True;
X	}
X    }
X
X    /* make sure cursor is displayed during dowhatis.. */
X    if (adjusted) display_cursor(wp);
X
X#ifdef VERBOSE
X    if (horiz_sb || vert_sb) printf("\n");
X#endif
X}
X
X
X/*
X * Check to see if the viewport has grown smaller.  If so, then we want to make
X * sure that the cursor is still on the screen.  We do this to keep the cursor
X * on the screen when the user resizes the nethack window.
X */
Xstatic void
Xmap_check_size_change(wp)
X    struct xwindow *wp;
X{
X    struct map_info_t *map_info = wp->map_information;
X    Arg arg[2];
X    Dimension new_width, new_height;
X    Widget viewport;
X
X    viewport = XtParent(wp->w);
X
X    XtSetArg(arg[0], XtNwidth,  &new_width);
X    XtSetArg(arg[1], XtNheight, &new_height);
X    XtGetValues(viewport, arg, TWO);
X
X    /* Only do cursor check if new size is smaller. */
X    if (new_width < map_info->viewport_width
X		    || new_height < map_info->viewport_height) {
X	check_cursor_visibility(wp);
X    }
X
X    map_info->viewport_width = new_width;
X    map_info->viewport_height = new_height;
X}
X
X/*
X * Fill in parameters "regular" and "inverse" with newly created GCs.
X * Using the given background pixel and the foreground pixel optained
X * by querying the widget with the resource name.
X */
Xstatic void
Xset_gc(w, font, resource_name, bgpixel, regular, inverse)
X    Widget w;
X    Font font;
X    char *resource_name;
X    Pixel bgpixel;
X    GC   *regular, *inverse;
X{
X    XGCValues values;
X    XtGCMask mask = GCFunction | GCForeground | GCBackground | GCFont;
X    Pixel curpixel;
X    Arg arg[1];
X
X    XtSetArg(arg[0], resource_name, &curpixel);
X    XtGetValues(w, arg, ONE);
X
X    values.foreground = curpixel;
X    values.background = bgpixel;
X    values.function   = GXcopy;
X    values.font	      = font;
X    *regular = XtGetGC(w, mask, &values);
X    values.foreground = bgpixel;
X    values.background = curpixel;
X    values.function   = GXcopy;
X    values.font	      = font;
X    *inverse = XtGetGC(w, mask, &values);
X}
X
X/*
X * Create the GC's for each color.
X *
X * I'm not sure if it is a good idea to have a GC for each color (and
X * inverse). It might be faster to just modify the foreground and
X * background colors on the current GC as needed.
X */
Xstatic void
Xget_gc(wp, font)
X    struct xwindow *wp;
X    Font font;
X{
X    struct map_info_t *map_info = wp->map_information;
X    Pixel bgpixel;
X    Arg arg[1];
X
X    /* Get background pixel. */
X    XtSetArg(arg[0], XtNbackground, &bgpixel);
X    XtGetValues(wp->w, arg, ONE);
X
X#ifdef TEXTCOLOR
X#define set_color_gc(nh_color, resource_name)			\
X	    set_gc(wp->w, font, resource_name, bgpixel,		\
X		    &map_info->color_gcs[nh_color],		\
X		    &map_info->inv_color_gcs[nh_color]);
X
X    set_color_gc(BLACK,		 XtNblack);
X    set_color_gc(RED,		 XtNred);
X    set_color_gc(GREEN,		 XtNgreen);
X    set_color_gc(BROWN,		 XtNbrown);
X    set_color_gc(BLUE,		 XtNblue);
X    set_color_gc(MAGENTA,	 XtNmagenta);
X    set_color_gc(CYAN,		 XtNcyan);
X    set_color_gc(GRAY,		 XtNgray);
X    set_color_gc(NO_COLOR,	 XtNforeground);
X    set_color_gc(ORANGE_COLORED, XtNorange);
X    set_color_gc(BRIGHT_GREEN,	 XtNbright_green);
X    set_color_gc(YELLOW,	 XtNyellow);
X    set_color_gc(BRIGHT_BLUE,	 XtNbright_blue);
X    set_color_gc(BRIGHT_MAGENTA, XtNbright_magenta);
X    set_color_gc(BRIGHT_CYAN,	 XtNbright_cyan);
X    set_color_gc(WHITE,		 XtNwhite);
X#else
X    set_gc(wp->w, font, XtNforeground, bgpixel,
X				&map_info->copy_gc, &map_info->inv_copy_gc);
X#endif
X}
X
X
X/*
X * Display the cursor on the map window.
X */
Xstatic void
Xdisplay_cursor(wp)
X    struct xwindow *wp;
X{
X    /* Redisplay the cursor location inverted. */
X    map_update(wp, wp->cursy, wp->cursy, wp->cursx, wp->cursx, TRUE);
X}
X
X
X/*
X * Check if there are any changed characters.  If so, then plaster them on
X * the screen.
X */
Xvoid
Xdisplay_map_window(wp)
X    struct xwindow *wp;
X{
X    register int row;
X    struct map_info_t *map_info = wp->map_information;
X
X    /*
X     * If the previous cursor position is not the same as the current
X     * cursor position, then update the old cursor position.
X     */
X    if (wp->prevx != wp->cursx || wp->prevy != wp->cursy) {
X	register unsigned int x = wp->prevx, y = wp->prevy;
X	if (x < map_info->t_start[y]) map_info->t_start[y] = x;
X	if (x > map_info->t_stop[y])  map_info->t_stop[y]  = x;
X    }
X
X    for (row = 0; row < ROWNO; row++) {
X	if (map_info->t_start[row] <= map_info->t_stop[row]) {
X	    map_update(wp, row, row,
X			(int) map_info->t_start[row],
X			(int) map_info->t_stop[row], FALSE);
X	    map_info->t_start[row] = COLNO-1;
X	    map_info->t_stop[row] = 0;
X	}
X    }
X    display_cursor(wp);
X    wp->prevx = wp->cursx;	/* adjust old cursor position */
X    wp->prevy = wp->cursy;
X}
X
X/*
X * Fill the saved screen characters with the "clear" character, and reset
X * all colors to the neutral color.  Flush out everything by resetting the
X * "new" bounds and calling display_map_window().
X */
Xvoid
Xclear_map_window(wp)
X    struct xwindow *wp;
X{
X    struct map_info_t *map_info = wp->map_information;
X
X    /* Fill with spaces, and update */
X    (void) memset((genericptr_t) map_info->text, ' ',
X			sizeof(map_info->text));
X    (void) memset((genericptr_t) map_info->t_start, (char) 0,
X			sizeof(map_info->t_start));
X    (void) memset((genericptr_t) map_info->t_stop, (char) COLNO-1,
X			sizeof(map_info->t_stop));
X#ifdef TEXTCOLOR
X    (void) memset((genericptr_t) map_info->colors, NO_COLOR,
X			sizeof(map_info->colors));
X#endif
X    display_map_window(wp);
X}
X
X/*
X * Retreive the font associated with the map window and save attributes
X * that are used when updating it.
X */
Xstatic void
Xget_char_info(wp)
X    struct xwindow *wp;
X{
X    XFontStruct *fs;
X
X    fs = WindowFontStruct(wp->w);
X    wp->map_information->char_width    = fs->max_bounds.width;
X    wp->map_information->char_height   = fs->max_bounds.ascent +
X						fs->max_bounds.descent;
X    wp->map_information->char_ascent   = fs->max_bounds.ascent;
X    wp->map_information->char_lbearing = -fs->min_bounds.lbearing;
X
X#ifdef VERBOSE
X    printf("Font information:\n");
X    printf("fid = %d, direction = %d\n", fs->fid, fs->direction);
X    printf("first = %d, last = %d\n",
X			fs->min_char_or_byte2, fs->max_char_or_byte2);
X    printf("all chars exist? %s\n", fs->all_chars_exist?"yes":"no");
X    printf("min_bounds:lb=%d rb=%d width=%d asc=%d des=%d attr=%d\n",
X		fs->min_bounds.lbearing, fs->min_bounds.rbearing,
X		fs->min_bounds.width, fs->min_bounds.ascent,
X		fs->min_bounds.descent, fs->min_bounds.attributes);
X    printf("max_bounds:lb=%d rb=%d width=%d asc=%d des=%d attr=%d\n",
X		fs->max_bounds.lbearing, fs->max_bounds.rbearing,
X		fs->max_bounds.width, fs->max_bounds.ascent,
X		fs->max_bounds.descent, fs->max_bounds.attributes);
X    printf("per_char = 0x%x\n", fs->per_char);
X    printf("Text: (max) width = %d, height = %d\n",
X	    wp->map_information->char_width, wp->map_information->char_height);
X#endif
X
X    if (fs->min_bounds.width != fs->max_bounds.width)
X	X11_raw_print("Warning:  map font is not monospaced!");
X}
X
X/*
X * keyhit buffer
X */
X#define INBUF_SIZE 64
Xint inbuf[INBUF_SIZE];
Xint incount = 0;
Xint inptr = 0;	/* points to valid data */
X
X
Xvoid
Xextern_map_input(event)
X    XEvent *event;
X{
X    if(event->type == KeyPress)
X	map_input(window_list[WIN_MAP].w, (XtPointer) 0, (XtPointer) event);
X}
X
X/*
X * Keyboard and button event handler for map window.
X */
X/* ARGSUSED */
Xstatic void
Xmap_input(w, client_data, call_data)
X    Widget w;
X    XtPointer client_data, call_data;
X{
X    XEvent *event = (XEvent *) call_data;
X    XKeyEvent *key;
X    XButtonEvent *button;
X    int i, nbytes;
X    char c;
X    char keystring[MAX_KEY_STRING];
X
X    switch (event->type) {
X	case ButtonPress:
X	    button = (XButtonEvent *) event;
X#ifdef VERBOSE_INPUT
X	    printf("button press\n");
X#endif
X	    set_button_values(w, button->x, button->y, button->button);
X	    break;
X	case KeyPress:
X#ifdef VERBOSE_INPUT
X	    printf("key: ");
X#endif
X	    if(appResources.slow && input_func) {
X		(*input_func)(w, event, NULL, NULL);
X		break;
X	    }
X
X	    /*
X	     * Don't use key_event_to_char() because we want to be able
X	     * to allow keys mapped to multiple characters.
X	     */
X	    key = (XKeyEvent *) event;
X	    nbytes = XLookupString(key, keystring, MAX_KEY_STRING, NULL, NULL);
X	    /* Modifier keys return a zero length string when pressed. */
X	    if (nbytes) {
X#ifdef VERBOSE_INPUT
X		printf("\"");
X#endif
X		for (i = 0; i < nbytes; i++) {
X		    c = keystring[i];
X
X		    if (incount < INBUF_SIZE) {
X			inbuf[(inptr+incount)%INBUF_SIZE] =
X			    ((int) c) + ((key->state & Mod1Mask) ? 0x80 : 0);
X			incount++;
X		    } else {
X			X11_nhbell();
X		    }
X#ifdef VERBOSE_INPUT
X		    /*
X		     * Assume that mod1 is really the meta key.
X		     */
X		    if (key->state & Mod1Mask)	/* meta will print as M<c> */
X			(void) putchar('M');
X		    if (c < ' ') {		/* ctrl will print as ^<c> */
X			(void) putchar('^');
X			c += '@';
X		    }
X		    (void) putchar(c);
X#endif
X		}
X#ifdef VERBOSE_INPUT
X		printf("\" [%d bytes]\n", nbytes);
X#endif
X	    }
X	    break;
X
X	default:
X	    impossible("unexpected X event, type = %d\n", (int) event->type);
X	    break;
X    }
X}
X
Xstatic void
Xset_button_values(w, x, y, button)
X    Widget w;
X    int x;
X    int y;
X    unsigned int button;
X{
X    struct xwindow *wp;
X    struct map_info_t *map_info;
X
X    wp = find_widget(w);
X    map_info = wp->map_information;
X
X    click_x = x / map_info->char_width;
X    click_y = y / map_info->char_height;
X
X    /* The values can be out of range if the map window has been resized */
X    /* to be larger than the max size.					 */
X    if (click_x >= COLNO) click_x = COLNO-1;
X    if (click_y >= ROWNO) click_x = ROWNO-1;
X
X    /* Map all buttons but the first to the second click */
X    click_button = (button == Button1) ? CLICK_1 : CLICK_2;
X}
X
X/*
X * Map window expose callback.
X */
Xstatic void
Xmap_exposed(w, event)
X    Widget w;
X    XExposeEvent *event;
X{
X    int x, y;
X    struct xwindow *wp;
X    struct map_info_t *map_info;
X    unsigned width, height;
X    int start_row, stop_row, start_col, stop_col;
X
X    if (!XtIsRealized(w)) return;
X
X    wp = find_widget(w);
X    map_info = wp->map_information;
X    /*
X     * The map is sent an expose event when the viewport resizes.  Make sure
X     * that the cursor is still in the viewport after the resize.
X     */
X    map_check_size_change(wp);
X
X    if (event) {		/* called from button-event */
X	x      = event->x;
X	y      = event->y;
X	width  = event->width;
X	height = event->height;
X    } else {
X	x     = 0;
X	y     = 0;
X	width = wp->pixel_width;
X	height= wp->pixel_height;
X    }
X    /*
X     * Convert pixels into INCLUSIVE text rows and columns.
X     */
X    start_row = y / map_info->char_height;
X    stop_row = start_row + (height / map_info->char_height) +
X			(((height % map_info->char_height) == 0) ? 0 : 1) - 1;
X
X    start_col = x / map_info->char_width;
X    stop_col = start_col + (width / map_info->char_width) +
X			(((width % map_info->char_width) == 0) ? 0 : 1) - 1;
X
X#ifdef VERBOSE
X    printf("map_exposed: x = %d, y = %d, width = %d, height = %d\n",
X						    x, y, width, height);
X#endif
X
X    /* Out of range values are possible if the map window is resized to be */
X    /* bigger than the largest expected value.				   */
X    if (stop_row >= ROWNO) stop_row = ROWNO-1;
X    if (stop_col >= COLNO) stop_col = COLNO-1;
X
X    map_update(wp, start_row, stop_row, start_col, stop_col, FALSE);
X    display_cursor(wp);		/* make sure cursor shows up */
X}
X
X/*
X * Do the actual work of the putting characters onto our X window.  This
X * is called from the expose event routine, the display window (flush)
X * routine, and the display cursor routine.  The later is a kludge that
X * involves the inverted parameter of this function.  A better solution
X * would be to double the color count, with any color above MAXCOLORS
X * being inverted.
X *
X * This works for rectangular regions (this includes one line rectangles).
X * The start and stop columns are *inclusive*.
X */
Xstatic void
Xmap_update(wp, start_row, stop_row, start_col, stop_col, inverted)
X    struct xwindow *wp;
X    int start_row, stop_row, start_col, stop_col;
X    boolean inverted;
X{
X    int win_start_row, win_start_col;
X    struct map_info_t *map_info = wp->map_information;
X    int row;
X    register int count;
X
X    if (start_row < 0 || stop_row >= ROWNO) {
X	impossible("map_update:  bad row range %d-%d\n", start_row, stop_row);
X	return;
X    }
X    if (start_col < 0 || stop_col >=COLNO) {
X	impossible("map_update:  bad col range %d-%d\n", start_col, stop_col);
X	return;
X    }
X
X#ifdef VERBOSE_UPDATE
X    printf("update: [0x%x] %d %d %d %d\n", 
X		(int) wp->w, start_row, stop_row, start_col, stop_col);
X#endif
X    win_start_row = start_row;
X    win_start_col = start_col;
X
X#ifdef TEXTCOLOR
X    if (flags.use_color) {
X	register char *c_ptr;
X	char *t_ptr;
X	int cur_col, color, win_ystart;
X
X	for (row = start_row; row <= stop_row; row++) {
X	    win_ystart = map_info->char_ascent +
X				    (row * map_info->char_height);
X
X	    t_ptr = (char *) &(map_info->text[row][start_col]);
X	    c_ptr = (char *) &(map_info->colors[row][start_col]);
X	    cur_col = start_col;
X	    while (cur_col <= stop_col) {
X		color = *c_ptr++;
X		count = 1;
X		while ((cur_col + count) <= stop_col && *c_ptr == color) {
X		    count++;
X		    c_ptr++;
X		}
X
X		XDrawImageString(XtDisplay(wp->w), XtWindow(wp->w),
X		    inverted ? map_info->inv_color_gcs[color] :
X			       map_info->color_gcs[color],
X		    map_info->char_lbearing + (map_info->char_width * cur_col),
X		    win_ystart,
X		    t_ptr, count);
X
X		/* move text pointer and column count */
X		t_ptr += count;
X		cur_col += count;
X	    } /* col loop */
X	} /* row loop */
X    } else
X#endif /* TEXTCOLOR */
X    {
X	int win_row, win_xstart;
X
X	/* We always start at the same x window position and have	*/
X	/* the same character count.					*/
X	win_xstart = map_info->char_lbearing +
X				    (win_start_col * map_info->char_width);
X	count = stop_col - start_col + 1;
X
X	for (row = start_row, win_row = win_start_row;
X					row <= stop_row; row++, win_row++) {
X
X	    XDrawImageString(XtDisplay(wp->w), XtWindow(wp->w),
X		inverted ? map_info->inv_copy_gc : map_info->copy_gc,
X		win_xstart,
X		map_info->char_ascent + (win_row * map_info->char_height),
X		(char *) &(map_info->text[row][start_col]), count);
X	}
X    }
X}
X
X/* Adjust the number of rows and columns on the given map window */
Xvoid
Xset_map_size(wp, cols, rows)
X    struct xwindow *wp;
X    Dimension cols, rows;
X{
X    Arg args[4];
X    Cardinal num_args;
X
X    wp->pixel_width  = wp->map_information->char_width  * cols;
X    wp->pixel_height = wp->map_information->char_height * rows;
X
X    num_args = 0;
X    XtSetArg(args[num_args], XtNwidth, wp->pixel_width);   num_args++;
X    XtSetArg(args[num_args], XtNheight, wp->pixel_height); num_args++;
X    XtSetValues(wp->w, args, num_args);
X}
X
X/*
X * The map window creation routine.
X */
Xvoid
Xcreate_map_window(wp, create_popup, parent)
X    struct xwindow *wp;
X    boolean create_popup;	/* parent is a popup shell that we create */
X    Widget parent;
X{
X    struct map_info_t *map_info;	/* map info pointer */
X    Widget map, viewport;
X    Arg args[10];
X    Cardinal num_args;
X    Dimension rows, columns;
X
X    wp->type = NHW_MAP;
X
X    map_info = wp->map_information =
X			(struct map_info_t *) alloc(sizeof(struct map_info_t));
X
X    map_info->viewport_width = map_info->viewport_height = 0;
X    (void) memset((genericptr_t) map_info->text, ' ', sizeof(map_info->text));
X    (void) memset((genericptr_t) map_info->t_start, (char) COLNO,
X			sizeof(map_info->t_start));
X    (void) memset((genericptr_t) map_info->t_stop, (char) 0,
X			sizeof(map_info->t_stop));
X#ifdef TEXTCOLOR
X    (void) memset((genericptr_t) map_info->colors, NO_COLOR,
X			sizeof(map_info->colors));
X#endif
X
X    if (create_popup) {
X	/*
X	 * Create a popup that accepts key and button events.
X	 */
X	num_args = 0;
X	XtSetArg(args[num_args], XtNinput, False);            num_args++;
X
X	wp->popup = parent = XtCreatePopupShell("nethack",
X					topLevelShellWidgetClass,
X				       toplevel, args, num_args);
X    }
X
X    num_args = 0;
X    XtSetArg(args[num_args], XtNallowHoriz, True);	num_args++;
X    XtSetArg(args[num_args], XtNallowVert,  True);	num_args++;
X    /* XtSetArg(args[num_args], XtNforceBars,  True);	num_args++; */
X    XtSetArg(args[num_args], XtNuseBottom,  True);	num_args++;
X    viewport = XtCreateManagedWidget(
X			"map_viewport",		/* name */
X			viewportWidgetClass,	/* widget class from Window.h */
X			parent,			/* parent widget */
X			args,			/* set some values */
X			num_args);		/* number of values to set */
X
X    /*
X     * Create a map window.  We need to set the width and height to some
X     * value when we create it.  We will change it to the value we want
X     * later
X     */
X    num_args = 0;
X    XtSetArg(args[num_args], XtNwidth,  100); num_args++;
X    XtSetArg(args[num_args], XtNheight, 100); num_args++;
X
X    wp->w = map = XtCreateManagedWidget(
X		"map",			/* name */
X		windowWidgetClass,	/* widget class from Window.h */
X		viewport,		/* parent widget */
X		args,			/* set some values */
X		num_args);		/* number of values to set */
X
X    XtAddCallback(map, XtNcallback,	  map_input,      (XtPointer) 0);
X    XtAddCallback(map, XtNexposeCallback, map_exposed, (XtPointer) 0);
X
X    get_char_info(wp);
X    get_gc(wp, WindowFont(map));
X
X    /*
X     * Initially, set the map widget to be the size specified by the
X     * widget rows and columns resources.  We need to do this to
X     * correctly set the viewport window size.  After the viewport is
X     * realized, then the map can resize to its normal size.
X     */
X    num_args = 0;
X    XtSetArg(args[num_args], XtNrows,    &rows);	num_args++;
X    XtSetArg(args[num_args], XtNcolumns, &columns);	num_args++;
X    XtGetValues(wp->w, args, num_args);
X
X    /* Don't bother with windows larger than ROWNOxCOLNO. */
X    if (columns > COLNO) columns = COLNO;
X    if (rows    > ROWNO) rows = ROWNO;
X
X    set_map_size(wp, columns, rows);
X
X    /*
X     * If we have created our own popup, then realize it so that the
X     * viewport is also realized.  Then resize the map window.
X     */
X    if (create_popup) {
X	XtRealizeWidget(wp->popup);
X	set_map_size(wp, COLNO, ROWNO);
X    }
X}
X
X/*
X * Destroy this map window.
X */
Xvoid
Xdestroy_map_window(wp)
X    struct xwindow *wp;
X{
X    struct map_info_t *map_info = wp->map_information;
X#ifdef TEXTCOLOR
X    int i;
X#endif
X
X    if (wp->popup) {
X	nh_XtPopdown(wp->popup);
X
X	/* Free allocated GCs. */
X#ifdef TEXTCOLOR
X	for (i = 0; i < MAXCOLORS; i++) {
X	    XtReleaseGC(wp->w, map_info->color_gcs[i]);
X	    XtReleaseGC(wp->w, map_info->inv_color_gcs[i]);
X	}
X#else
X	XtReleaseGC(wp->w, map_info->copy_gc);
X	XtReleaseGC(wp->w, map_info->inv_copy_gc);
X#endif
X
X	/* Free malloc'ed space. */
X	free((char *) map_info);
X
X	/* Destroy map widget. */
X	XtDestroyWidget(wp->popup);
X    }
X
X    wp->type = NHW_NONE;	/* allow re-use */
X}
X
X
X
Xboolean exit_x_event;	/* exit condition for the event loop */
X/*******
Xpkey(k)
X    int k;
X{
X    printf("key = '%s%c'\n", (k<32) ? "^":"", (k<32) ? '@'+k : k);
X}
X******/
X
X/*
X * Main X event loop.  Here we accept and dispatch X events.  We only exit
X * under certain circumstances.
X */
Xint
Xx_event(exit_condition)
X    int exit_condition;
X{
X    XEvent  event;
X    int     retval;
X    boolean keep_going = TRUE;
X
X#ifdef GCC_WARN
X    retval = 0;
X#endif
X
X    click_button = NO_CLICK;	/* reset click exit condition */
X    exit_x_event = FALSE;	/* reset callback exit condition */
X
X    /*
X     * Loop until we get a sent event, callback exit, or are accepting key
X     * press and button press events and we receive one.
X     */
X    if((exit_condition == EXIT_ON_KEY_PRESS ||
X	exit_condition == EXIT_ON_KEY_OR_BUTTON_PRESS) && incount)
X	goto try_test;
X
X    do {
X	XtAppNextEvent(app_context, &event);
X	XtDispatchEvent(&event);
X
X	/* See if we can exit. */
X    try_test:
X	switch (exit_condition) {
X	    case EXIT_ON_SENT_EVENT: {
X		XAnyEvent *any = (XAnyEvent *) &event;
X		if (any->send_event) {
X		    retval = 0;
X		    keep_going = FALSE;
X		}
X		break;
X	    }
X	    case EXIT_ON_EXIT:
X		if (exit_x_event) {
X		    incount = 0;
X		    retval = 0;
X		    keep_going = FALSE;
X		}
X		break;
X	    case EXIT_ON_KEY_PRESS:
X		if (incount != 0) {
X		    /* get first pressed key */
X		    --incount;
X		    retval = inbuf[inptr];
X		    inptr = (inptr+1) % INBUF_SIZE;
X		    /* pkey(retval); */
X		    keep_going = FALSE;
X		}
X		break;
X	    case EXIT_ON_KEY_OR_BUTTON_PRESS:
X		if (incount != 0 || click_button != NO_CLICK) {
X		    if (click_button != NO_CLICK) {	/* button press */
X			/* click values are already set */
X			retval = 0;
X		    } else {				/* key press */
X			/* get first pressed key */
X			--incount;
X			retval = inbuf[inptr];
X			inptr = (inptr+1) % INBUF_SIZE;
X			/* pkey(retval); */
X		    }
X		    keep_going = FALSE;
X		}
X		break;
X	    default:
X		panic("x_event: unknown exit condition %d\n", exit_condition);
X		break;
X	}
X    } while (keep_going);
X
X    return retval;
X}
X
X/*winmap.c*/
END_OF_FILE
if test 28534 -ne `wc -c <'win/X11/winmap.c'`; then
    echo shar: \"'win/X11/winmap.c'\" unpacked with wrong size!
fi
# end of 'win/X11/winmap.c'
fi
echo shar: End of archive 75 \(of 108\).
cp /dev/null ark75isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \
21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \
41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 \
61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 \
81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 \
101 102 103 104 105 106 107 108 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 108 archives.
    echo "Now execute 'rebuild.sh'"
    rm -f ark10[0-8]isdone ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
