Path: uunet!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v16i109:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Part101/108
Message-ID: <4474@master.CNA.TEK.COM>
Date: 5 Feb 93 22:03:36 GMT
Sender: news@master.CNA.TEK.COM
Lines: 2221
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1660

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 16, Issue 109
Archive-name: nethack31/Part101
Supersedes: nethack3p9: Volume 10, Issue 46-108
Environment: Amiga, Atari, Mac, MS-DOS, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 101 (of 108)."
# Contents:  dat/oracles.txt src/minion.c src/pline.c
#   sys/amiga/splitter/arg.c sys/amiga/splitter/split.h
#   sys/amiga/winami.p sys/atari/Makefile.utl sys/mac/maccurs.c
#   sys/vms/oldcrtl.c util/recover.c
# Wrapped by billr@saab on Wed Jan 27 16:09:30 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'dat/oracles.txt' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dat/oracles.txt'\"
else
echo shar: Extracting \"'dat/oracles.txt'\" \(5623 characters\)
sed "s/^X//" >'dat/oracles.txt' <<'END_OF_FILE'
X-----
XIf thy wand hath run out of charges, thou mayst zap it again and again; though
Xnaught will happen at first, verily, thy persistence shall be rewarded, as
Xone last charge may yet be wrested from it!
X-----
XThough the shopkeepers be wary, thieves have nevertheless stolen much by using
Xtheir digging wands to hasten exits through the pavement.
X-----
XIf thou hast had trouble with rust on thy armor or weapons, thou shouldst
Xknow that thou canst prevent this by, while in a confused state, reading the
Xmagical parchments which normally are used to cause their enchantment.
X-----
XBehold the cockatrice, whose diminutive stature belies its hidden might.  The
Xcockatrice can petrify any ordinary being it contacts--save those wise
Xadventurers who eat a dead lizard or blob of acid when they feel themselves
Xslowly turning to stone.
X-----
XWhile some wayfarers rely on finding finished armour in the dungeon, the
Xresourceful consider dragon scales as truly enchanting raw material and
Xrealize that dragon scale mail is an excellent investment.
X-----
XIt is well known among travelers that extra-healing draughts may clear thy
Xsenses when thou art addled by hallucinations.  But never forget, the lowly
Xpotion which makes one sick may be used for the same purpose.
X-----
XWhile the consumption of lizard flesh or water beloved of the gods may
Xstraighten thy head after confusion, the application of the horn of a
Xcreature of utmost purity can alleviate many other afflictions as well.
X-----
XIf thou wishest to travel quickly between distant levels, thou must be
Xable to control thy teleports, and be confused, and read the scroll
Xwhich usually teleports thyself around on the level.  Daring adventurers
Xhave also performed the same feat sans need for scrolls or potions by
Xstepping on the correct type of trap.
X-----
XAlmost all adventurers who come this way hope to pass the dread Medusa.  To
Xdo this, the best advice is to keep thine eyes blindfolded and to cause the
Xcreature to espy its own reflection in a mirror.
X-----
XAnd where it is written "ad aerarium", diligent searching will often reveal
Xthe way to a trap which sends one to the Magic Memory Vault, where the riches
Xof Croesus are stored; however, escaping from the vault with its gold is much
Xharder than getting in.
X-----
XIt is well known that wily shopkeepers doth raise their prices whene'er they
Xespy the garish apparel of the approaching tourist or the countenance of a
Xdisfavored patron.  They favor the gentle of manner and the fair of face.
XThe boor may expect unprofitable transactions.
X----- SINKS
XThe cliche of the kitchen sink swallowing any unfortunate rings that contact
Xits pernicious surface reflecteth greater truth than many homilies, yet
Xeven so, few hath developed the skill to identify enchanted rings by the
Xtransfigurations effected upon the voracious device's frame.
X-----
XThe meat of enchanted creatures will ofttimes convey magical properties
Xunto the consumer.  A fresh corpse of floating eye doth fetch a high
Xprice among wizards for its utility in conferring Telepathy, by which
Xthe sightless may locate surrounding minds.
X-----
XThe detection of blessings and curses is in the domain of the gods.  They will
Xmake this information available to mortals who request it at their places of
Xworship, or elsewhere for those mortals who devote themselves to the service
Xof the gods.
X-----
XAt times, the gods may favor worthy supplicants with named blades whose
Xpowers echo throughout legend.  Learned wayfarers can reproduce blades of
Xelven lineage, hated of the orcs, without the need for such intervention.
X-----
XAdventurers searching for Medusa or the Wizard of Yendor needst not wait until
Xtheir dungeon level corresponds with their enemies' to know their location.
XEat a floating eye, blind thyself, and use a mirror in thine own direction,
Xand provided thou art lucky, thou shalt know the approximate locations of
Xthine enemies.
X-----
XThere are many stories of a mighty amulet, the origins of which are said
Xto be ancient Yendor.  This amulet doth have awesome power, and the gods
Xdesireth it greatly.  Mortals mayst tap only portions of its terrible
Xabilities.  The stories tell of mortals seeing what their eyes cannot
Xsee and seeking places of magical transportation, while having this
Xamulet in their possession.  Others say a mortal must wear the amulet to
Xobtain these powers.  But verily, such power comes at great cost, to
Xpreserve the balance.
X-----
XIt is said that thou mayst gain entry to Moloch's sanctuary, if thou
Xdarest, from a place where the ground vibrates in the deepest depths of
XGehennom.  Thou needs must have the aid of three magical items.  The
Xpure sound of a silver bell shall announce thee.  The terrible runes,
Xread from Moloch's book, shall cause the earth to tremble mightily.  The
Xlight of an enchanted candelabrum shall show thee the way.
X-----
XIn the nethermost recesses of the dungeon, there standeth a castle, wherein
Xlayeth a wand of wishes.  If thou wouldst gain entry, bear with thee an
Xinstrument of music, for the drawbridge may be charmed down with the proper
Xmelody.  What notes comprise it only the gods know, but a musical mastermind
Xmay yet succeed by witful improvization.  However, the less perspicacious are
Xnot without recourse, should they be prepared to circumambulate the castle to
Xthe postern.
X----- ELBERETH
XThe name of Elbereth may strike fear into the hearts of thine enemies, if
Xthou doest write it upon the ground at thy feet.  If thou maintain the utmost
Xcalm, thy safety will be aided greatly, but beware lest thy clumsy feet scuff
Xthe inscription, cancelling its potence.
X-----
END_OF_FILE
if test 5623 -ne `wc -c <'dat/oracles.txt'`; then
    echo shar: \"'dat/oracles.txt'\" unpacked with wrong size!
fi
# end of 'dat/oracles.txt'
fi
if test -f 'src/minion.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/minion.c'\"
else
echo shar: Extracting \"'src/minion.c'\" \(5321 characters\)
sed "s/^X//" >'src/minion.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)minion.c	3.1	92/11/01	*/
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include "hack.h"
X#include "emin.h"
X#include "epri.h"
X
Xvoid
Xmsummon(ptr)		/* ptr summons a monster */
X	register struct permonst *ptr;
X{
X	register int dtype = 0, cnt = 0;
X
X	if(is_dprince(ptr) || (ptr == &mons[PM_WIZARD_OF_YENDOR])) {
X
X	    dtype = (!rn2(20)) ? dprince() : (!rn2(4)) ? dlord() : ndemon();
X	    cnt = (!rn2(4) && !is_dprince(&mons[dtype])) ? 2 : 1;
X
X	} else if(is_dlord(ptr)) {
X
X	    dtype = (!rn2(50)) ? dprince() : (!rn2(20)) ? dlord() : ndemon();
X	    cnt = (!rn2(4) && is_ndemon(&mons[dtype])) ? 2 : 1;
X
X	} else if(is_ndemon(ptr)) {
X
X	    dtype = (!rn2(20)) ? dlord() : (!rn2(6)) ? ndemon() : monsndx(ptr);
X	    cnt = 1;
X	} else if(is_lminion(ptr)) {
X
X	    dtype = (is_lord(ptr) && !rn2(20)) ? llord() :
X		     (is_lord(ptr) || !rn2(6)) ? lminion() : monsndx(ptr);
X	    cnt = (!rn2(4) && !is_lord(&mons[dtype])) ? 2 : 1;
X
X	}
X
X	if(!dtype) return;
X
X	while(cnt > 0) {
X
X	    (void)makemon(&mons[dtype], u.ux, u.uy);
X	    cnt--;
X	}
X	return;
X}
X
Xvoid
Xsummon_minion(alignment, talk)
X    aligntyp alignment;
X    boolean talk;
X{
X    register struct monst *mon;
X    int mnum;
X
X    switch(alignment) {
X    case A_LAWFUL: {
X	mnum = lminion();
X	break;
X    }
X    case A_NEUTRAL: {
X	mnum = PM_AIR_ELEMENTAL + rn2(4);
X	break;
X    }
X    case A_CHAOTIC:
X	mnum = ndemon();
X	break;
X    default:
X	impossible("unaligned player?");
X	mnum = ndemon();
X	break;
X    }
X    if(mons[mnum].pxlth == 0) {
X	struct permonst *pm = &mons[mnum];
X	pm->pxlth = sizeof(struct emin);
X	mon = makemon(pm, u.ux, u.uy);
X	pm->pxlth = 0;
X	if(mon) {
X	    mon->isminion = TRUE;
X	    EMIN(mon)->min_align = alignment;
X	}
X    } else if (mnum == PM_ANGEL) {
X	mon = makemon(&mons[mnum], u.ux, u.uy);
X	if (mon) {
X	    mon->isminion = TRUE;
X	    EPRI(mon)->shralign = alignment;	/* always A_LAWFUL here */
X	}
X    } else
X	mon = makemon(&mons[mnum], u.ux, u.uy);
X    if(mon) {
X	if(talk) {
X	    pline("The voice of %s booms:", align_gname(alignment));
X	    verbalize("Thou shalt pay for thy indiscretion!");
X	    if(!Blind)
X		pline("%s appears before you.", Amonnam(mon));
X	}
X	mon->mpeaceful = FALSE;
X	/* don't call set_malign(); player was naughty */
X    }
X}
X
X#define	Athome	(Inhell && !mtmp->cham)
X
Xint
Xdemon_talk(mtmp)		/* returns 1 if it won't attack. */
Xregister struct monst *mtmp;
X{
X	long	demand, offer;
X
X	if(uwep && uwep->oartifact == ART_EXCALIBUR) {
X	    pline("%s looks very angry.", Amonnam(mtmp));
X	    mtmp->mpeaceful = mtmp->mtame = 0;
X	    newsym(mtmp->mx, mtmp->my);
X	    return 0;
X	}
X
X	/* Slight advantage given. */
X	if(is_dprince(mtmp->data) && mtmp->minvis) {
X	    mtmp->minvis = 0;
X	    if (!Blind) pline("%s appears before you.", Amonnam(mtmp));
X	    newsym(mtmp->mx,mtmp->my);
X	}
X	if(u.usym == S_DEMON) {	/* Won't blackmail their own. */
X
X	    pline("%s says, \"Good hunting, %s.\" and vanishes.",
X		  Amonnam(mtmp), flags.female ? "Sister" : "Brother");
X	    rloc(mtmp);
X	    return(1);
X	}
X	demand = (u.ugold * (rnd(80) + 20 * Athome)) / 100;
X	if(!demand)  		/* you have no gold */
X	    return mtmp->mpeaceful = 0;
X	else {
X
X	    pline("%s demands %ld zorkmid%s for safe passage.",
X		  Amonnam(mtmp), demand, plur(demand));
X
X	    if((offer = bribe(mtmp)) >= demand) {
X		pline("%s vanishes, laughing about cowardly mortals.",
X		      Amonnam(mtmp));
X	    } else {
X		if((long)rnd(40) > (demand - offer)) {
X		    pline("%s scowls at you menacingly, then vanishes.",
X			  Amonnam(mtmp));
X		} else {
X		    pline("%s gets angry...", Amonnam(mtmp));
X		    return mtmp->mpeaceful = 0;
X		}
X	    }
X	}
X	mongone(mtmp);
X	return(1);
X}
X
Xlong
Xbribe(mtmp)
Xstruct monst *mtmp;
X{
X	char buf[80];
X	long offer;
X
X	getlin("How much will you offer?", buf);
X	(void) sscanf(buf, "%ld", &offer);
X
X/*Michael Paddon -- fix for negative offer to monster*/	/*JAR880815 - */
X 	if(offer < 0L) {
X 		You("try to shortchange %s, but fumble.", 
X 			mon_nam(mtmp));
X 		offer = 0L;
X 	} else if(offer == 0L) {
X		You("refuse.");
X 	} else if(offer >= u.ugold) {
X		You("give %s all your gold.", mon_nam(mtmp));
X		offer = u.ugold;
X	} else You("give %s %ld zorkmid%s.", mon_nam(mtmp), offer,
X		   plur(offer));
X
X	u.ugold -= offer;
X	mtmp->mgold += offer;
X	flags.botl = 1;
X	return(offer);
X}
X
Xint
Xdprince() {
X	int	tryct, pm;
X
X	for(tryct = 0; tryct < 20; tryct++) {
X	    pm = rn1(PM_DEMOGORGON + 1 - PM_ORCUS, PM_ORCUS);
X	    if(!(mons[pm].geno & (G_GENOD | G_EXTINCT)))
X		return(pm);
X	}
X	return(dlord());	/* approximate */
X}
X
Xint
Xdlord()
X{
X	int	tryct, pm;
X
X	for(tryct = 0; tryct < 20; tryct++) {
X	    pm = rn1(PM_YEENOGHU + 1 - PM_JUIBLEX, PM_JUIBLEX);
X	    if(!(mons[pm].geno & (G_GENOD | G_EXTINCT)))
X		return(pm);
X	}
X	return(ndemon());	/* approximate */
X}
X
X/* create lawful (good) lord */
Xint
Xllord()
X{
X	if(!(mons[PM_ARCHON].geno & (G_GENOD | G_EXTINCT)))
X		return(PM_ARCHON);
X
X	return(lminion());	/* approximate */
X}
X
Xint
Xlminion()
X{
X	int	tryct;
X	struct	permonst *ptr;
X
X	for(tryct = 0; tryct < 20; tryct++)
X	    if((ptr = mkclass(S_ANGEL,0)) && !is_lord(ptr))
X		return(monsndx(ptr));
X
X	return(0);
X}
X
Xint
Xndemon()
X{
X	int	tryct;
X	struct	permonst *ptr;
X
X	for (tryct = 0; tryct < 20; tryct++) {
X	    ptr = mkclass(S_DEMON, 0);
X	    if (is_ndemon(ptr))
X		return(monsndx(ptr));
X	}
X
X	return(0);
X}
X
X/*minion.c*/
END_OF_FILE
if test 5321 -ne `wc -c <'src/minion.c'`; then
    echo shar: \"'src/minion.c'\" unpacked with wrong size!
fi
# end of 'src/minion.c'
fi
if test -f 'src/pline.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/pline.c'\"
else
echo shar: Extracting \"'src/pline.c'\" \(5430 characters\)
sed "s/^X//" >'src/pline.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)pline.c	3.1	92/11/20	*/
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#define NEED_VARARGS /* Uses ... */	/* comment line for pre-compiled headers */
X#include "hack.h"
X#include "epri.h"
X
X#ifndef OVLB
XSTATIC_DCL boolean no_repeat;
X#else /* OVLB */
XSTATIC_OVL boolean no_repeat = FALSE;
X#endif /* OVLB */
X
X#ifdef OVLB
Xstatic char *FDECL(You_buf, (int));
X
X/*VARARGS1*/
X/* Note that these declarations rely on knowledge of the internals
X * of the variable argument handling stuff in "tradstdc.h"
X */
X
X#if defined(USE_STDARG) || defined(USE_VARARGS)
Xstatic void FDECL(vpline, (const char *, va_list));
X
Xvoid
Xpline VA_DECL(const char *, line)
X	VA_START(line);
X	VA_INIT(line, char *);
X	vpline(line, VA_ARGS);
X	VA_END();
X}
X
X# ifdef USE_STDARG
Xstatic void
Xvpline(const char *line, va_list the_args) {
X# else
Xstatic void
Xvpline(line, the_args) const char *line; va_list the_args; {
X# endif
X
X#else	/* USE_STDARG | USE_VARARG */
X
X#define vpline pline
X
Xvoid
Xpline VA_DECL(const char *, line)
X#endif	/* USE_STDARG | USE_VARARG */
X
X	char pbuf[BUFSZ];
X/* Do NOT use VA_START and VA_END in here... see above */
X
X	if(!line || !*line) return;
X	if(!index(line, '%'))
X	    Strcpy(pbuf,line);
X	else
X	    Vsprintf(pbuf,line,VA_ARGS);
X	if(!flags.window_inited) {
X	    raw_print(pbuf);
X	    return;
X	}
X#ifndef MAC
X	if(no_repeat && !strcmp(pbuf, toplines))
X	    return;
X#endif /* MAC */
X	if (vision_full_recalc) vision_recalc(0);
X	if (u.ux) flush_screen(1);		/* %% */
X	putstr(WIN_MESSAGE, 0, pbuf);
X}
X
X/*VARARGS1*/
Xvoid
XNorep VA_DECL(const char *, line)
X	VA_START(line);
X	VA_INIT(line, const char *);
X	no_repeat = TRUE;
X	vpline(line, VA_ARGS);
X	no_repeat = FALSE;
X	VA_END();
X	return;
X}
X
X/* work buffer for You(), Your(), and verbalize() */
Xstatic char *you_buf = 0;
Xstatic int you_buf_siz = 0;
X
Xstatic char *
XYou_buf(siz) int siz; {
X	if (siz > you_buf_siz) {
X		if (you_buf_siz > 0) free((genericptr_t) you_buf);
X		you_buf_siz = siz + 10;
X		you_buf = (char *) alloc((unsigned) you_buf_siz);
X	}
X	return you_buf;
X}
X
X/*VARARGS1*/
Xvoid
XYou VA_DECL(const char *, line)
X	char *tmp;
X	VA_START(line);
X	VA_INIT(line, const char *);
X	tmp = You_buf((int)strlen(line) + 5);
X	Strcpy(tmp, "You ");
X	Strcat(tmp, line);
X	vpline(tmp, VA_ARGS);
X	VA_END();
X}
X
X/*VARARGS1*/
Xvoid
XYour VA_DECL(const char *,line)
X	char *tmp;
X	VA_START(line);
X	VA_INIT(line, const char *);
X	tmp = You_buf((int)strlen(line) + 6);
X	Strcpy(tmp, "Your ");
X	Strcat(tmp, line);
X	vpline(tmp, VA_ARGS);
X	VA_END();
X}
X
X/*VARARGS1*/
Xvoid
Xverbalize VA_DECL(const char *,line)
X	char *tmp;
X	if (!flags.soundok) return;
X	VA_START(line);
X	VA_INIT(line, const char *);
X	tmp = You_buf((int)strlen(line) + 3);
X	Strcpy(tmp, "\"");
X	Strcat(tmp, line);
X	Strcat(tmp, "\"");
X	vpline(tmp, VA_ARGS);
X	VA_END();
X}
X
X/*VARARGS1*/
X/* Note that these declarations rely on knowledge of the internals
X * of the variable argument handling stuff in "tradstdc.h"
X */
X
X#if defined(USE_STDARG) || defined(USE_VARARGS)
Xstatic void FDECL(vraw_printf,(const char *,va_list));
X
Xvoid
Xraw_printf VA_DECL(const char *, line)
X	VA_START(line);
X	VA_INIT(line, char *);
X	vraw_printf(line, VA_ARGS);
X	VA_END();
X}
X
X# ifdef USE_STDARG
Xstatic void
Xvraw_printf(const char *line, va_list the_args) {
X# else
Xstatic void
Xvraw_printf(line, the_args) const char *line; va_list the_args; {
X# endif
X
X#else  /* USE_STDARG | USE_VARARG */
X
Xvoid
Xraw_printf VA_DECL(const char *, line)
X#endif
X/* Do NOT use VA_START and VA_END in here... see above */
X
X	if(!index(line, '%'))
X	    raw_print(line);
X	else {
X	    char pbuf[BUFSZ];
X	    Vsprintf(pbuf,line,VA_ARGS);
X	    raw_print(pbuf);
X	}
X}
X
X
X/*VARARGS1*/
Xvoid
Ximpossible VA_DECL(const char *, s)
X	VA_START(s);
X	VA_INIT(s, const char *);
X	vpline(s,VA_ARGS);
X	pline("Program in disorder - perhaps you'd better Quit.");
X	VA_END();
X}
X
Xconst char *
Xalign_str(alignment)
X    aligntyp alignment;
X{
X    switch ((int)alignment) {
X	case A_CHAOTIC: return "chaotic";
X	case A_NEUTRAL: return "neutral";
X	case A_LAWFUL:	return "lawful";
X	case A_NONE:	return "unaligned";
X    }
X    return "unknown";
X}
X
Xvoid
Xmstatusline(mtmp)
Xregister struct monst *mtmp;
X{
X	aligntyp alignment;
X
X	if (mtmp->ispriest || mtmp->data == &mons[PM_ALIGNED_PRIEST]
X				|| mtmp->data == &mons[PM_ANGEL])
X		alignment = EPRI(mtmp)->shralign;
X	else
X		alignment = mtmp->data->maligntyp;
X
X	alignment = (alignment > 0) ? A_LAWFUL :
X		(alignment < 0) ? A_CHAOTIC :
X		A_NEUTRAL;
X	pline("Status of %s (%s):  Level %d  Gold %lu  HP %d(%d) AC %d%s%s",
X		mon_nam(mtmp),
X		align_str(alignment),
X		mtmp->m_lev,
X		mtmp->mgold,
X		mtmp->mhp,
X		mtmp->mhpmax,
X		find_mac(mtmp),
X		mtmp->mcan ? ", cancelled" : "" ,
X		mtmp->mtame ? ", tame" : "");
X}
X
Xvoid
Xustatusline()
X{
X	pline("Status of %s (%s%s):  Level %d  Gold %lu  HP %d(%d)  AC %d",
X		plname,
X		    (u.ualign.record >= 20) ? "piously " :
X		    (u.ualign.record > 13) ? "devoutly " :
X		    (u.ualign.record > 8) ? "fervently " :
X		    (u.ualign.record > 3) ? "stridently " :
X		    (u.ualign.record == 3) ? "" :
X		    (u.ualign.record >= 1) ? "haltingly " :
X		    (u.ualign.record == 0) ? "nominally " :
X					    "insufficiently ",
X		align_str(u.ualign.type),
X# ifdef POLYSELF
X		u.mtimedone ? mons[u.umonnum].mlevel : u.ulevel,
X		u.ugold,
X		u.mtimedone ? u.mh : u.uhp,
X		u.mtimedone ? u.mhmax : u.uhpmax,
X# else
X		u.ulevel,
X		u.ugold,
X		u.uhp,
X		u.uhpmax,
X# endif
X		u.uac);
X}
X
X#endif /* OVLB */
X
X/*pline.c*/
END_OF_FILE
if test 5430 -ne `wc -c <'src/pline.c'`; then
    echo shar: \"'src/pline.c'\" unpacked with wrong size!
fi
# end of 'src/pline.c'
fi
if test -f 'sys/amiga/splitter/arg.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/amiga/splitter/arg.c'\"
else
echo shar: Extracting \"'sys/amiga/splitter/arg.c'\" \(5283 characters\)
sed "s/^X//" >'sys/amiga/splitter/arg.c' <<'END_OF_FILE'
X/*    SCCS Id: @(#)arg.c		3.1   93/01/08
X/*    Copyright (c) Kenneth Lorber, Bethesda, Maryland, 1992, 1993 */
X/* NetHack may be freely redistributed.  See license for details. */
X
X/*
X * arg.c - semi-generic argument parser
X */
X#include <exec/types.h>
X#include <exec/lists.h>
X#include <proto/exec.h>
X#include <stdio.h>
X#include <stdlib.h>
X#include <ctype.h>
X#include <string.h>
X#include "arg.h"
X
Xstatic char *a_desc;
Xstatic int a_argc;
Xstatic char **a_argv;
Xstatic int a_apos;
Xstatic char more=0;
Xstatic char *argp;
X
Xstatic char *arg_fillbuf(void);
X/*static char *splitline(struct fentry *); L505 bug? see below */
Xstatic char *splitline2(char *);
X
Xchar *argarg;
X
X#ifndef ARGLEN
X#define ARGLEN 134		/* longest line we can deal with */
X#endif
X
Xstatic struct List flist;	/* stack of files to read from */
Xstruct fentry {			/* structures on that stack */
X	struct Node node;
X	FILE *fp;
X	char *ptr;
X	char buf[ARGLEN];
X};
X
Xstatic char *splitline(struct fentry *); /* L505 bug? can't be above def  */
X
X#define ListHead(x) ((x).lh_Head)
X#define ListEmpty(x) (!(x).lh_Head->ln_Succ)
X
X/*
X * arg_init(description string, argc, argv)
X * Called by user to initialize system - must be called before calling
X * other entry points.  desc is getopt(3) style description string; argc and
X * argv are the arguments to main().
X */
Xvoid arg_init(char *desc,int argc,char *argv[]){
X	a_desc=desc;
X	a_argc=argc;
X	a_argv=argv;
X	a_apos=0;
X	NewList(&flist);
X}
X
X/*
X * arg_next(void)
X * Called by user to return each argument.  See arg.h for exceptional return
X * values - normally returns the argument flag found; if a flag takes an
X * argument, the argument is returned in argarg.
X * An argument beginning with @ is taken to be a file name from which to read
X * further arguments - such files are held on a stack and read as found, then
X * the previous file (or the command line) is continued.
X * In an argument file, the following are recognized:
X * #  as the first character of a line only, causes the line to be ignored
X * @  recursively read arguments from another file
X * \n embedded newline
X * \r embedded carriage return
X * \f embedded formfeed
X * \b embedded backspace
X * \  literal next character (except above)
X * "  start/end double quoted string
X * '  start/end single quoted string
X */
Xint arg_next(){
X	char *cp;
X	char key;
X
X	if(!more){				/* anything still buffered? */
X		if(!(argp=arg_fillbuf())){	/* nothing more */
X			argarg=0;		/* be neat */
X			return(ARG_DONE);
X		}
X	}
X	if(more ||(*argp=='-' && argp++)){
X		for(cp=a_desc;*cp;cp++){
X			if(*cp== *argp){
X				key=*argp++;
X				if(*++cp==':'){
X					if(*argp){
X						argarg=argp;
X					}else{
X						argarg=arg_fillbuf();
X						if(!argarg)return(ARG_ERROR);
X					}
X					more=0;
X				}else{
X					argarg=0; /* doesn't take an arg */
X					more= *argp;
X				}
X				return((int) key);
X			}
X		}
X		return(ARG_ERROR);	/* no such option */
X	}else{
X		argarg=argp;
X		more=0;
X		return(ARG_FREE);
X	}
X}
X
Xstatic char *arg_fillbuf(){
X	char *p,*nlp;;
X
X	if(ListEmpty(flist)){
X		if(++a_apos>a_argc)return(0);
X		p=a_argv[a_apos];
X	}else{
X		struct fentry *f=(struct fentry *)ListHead(flist);
X		if(!f->ptr){
X			do{
X				if(!fgets(f->buf,ARGLEN,f->fp)){
X					if(ferror(f->fp)){
X						fprintf(stderr,
X							"I/O error on @file\n");
X						return(0);
X					}
X					fclose(f->fp);
X					RemHead(&flist);
X					free(f);
X					return(arg_fillbuf());
X				}
X			}while(f->buf[0]=='#');	/* comment */
X			if(nlp=strchr(f->buf,'\n'))*nlp='\0';
X		}
X		p=splitline(f);
X		if(p== (char *)-1)return(0);		/* error */
X		if(!p)return(arg_fillbuf());	/* skip blank line */
X	}
X	if(p && *p=='@'){
X		struct fentry *f=calloc(sizeof(struct fentry),1);
X		f->fp=fopen(++p,"r");
X		if(!(f->fp)){
X			fprintf(stderr,"Can't open @file '%s'\n",p);
X			free(f);
X			return(0);
X		}
X		AddHead(&flist,(struct Node *)f);
X		return(arg_fillbuf());
X	}
X	return(p);
X}
X
Xstatic char *splitline(struct fentry *f){
X	char *out=(f->ptr?f->ptr:f->buf);
X	char *ret;
X	while(*out && isspace(*out))out++;
X	if(!*out)return(0);	/* blank line or spaces at end */
X	ret=out;
X	while(*out && !isspace(*out)){
X		switch(*out){
X		case '\\':
X		case '\"':
X		case '\'':
X			out=splitline2(out);
X			if(!out)return((char *)-1);	/* error */
X			break;
X		default:
X			out++;
X			break;
X		}
X	}
X	if(!*out){
X		f->ptr=0;	/* this was last arg on current line */
X	}else{
X		*out='\0';
X		f->ptr= ++out;
X		if(!(*f->ptr))f->ptr=0;
X	}
X	return ret;
X}
X
Xstatic char *splitline2(char *p){
X	char *out=p;
X	char c;
X	char dq=0,sq=0;
X	while(*p){
X		switch(c= *p++){
X		case '\\':
X			switch(c= *p++){
X			case 'n':	*out++='\n';break;
X			case 'r':	*out++='\r';break;
X			case 'f':	*out++='\f';break;
X			case 'b':	*out++='\b';break;
X			case 0:		p--;break;
X			default:	*out++=c;break;
X			}
X			break;
X		case '\"':	if(sq){
X					*out++=c;
X				}else{
X					dq=1-dq;
X				}
X				break;
X		case '\'':	if(dq){
X					*out++=c;
X				}else{
X					sq=1-sq;
X				}
X				break;
X		case ' ':	if(!sq && !dq){*out=0;return(p-1);}
X				*out++=' ';
X				break;
X		default:	*out++=c;break;
X		}
X	}
X	if(sq ||dq){
X		fprintf(stderr,"Warning - quote error in @file\n");
X		return((char *)-1);
X	}
X	*out=0;
X	return(p);
X}
X
X#ifdef DEBUG_ARG
Xmain(int argc,char *argv[]){
X	int x=0;
X	arg_init(getenv("test_arg"),argc,argv);
X	do{
X		x=arg_next();
X		printf("r=%d (%d)'%s'\n",x,argarg,argarg);
X	}while(x >= 0);
X}
X#endif /* DEBUG_ARG */
END_OF_FILE
if test 5283 -ne `wc -c <'sys/amiga/splitter/arg.c'`; then
    echo shar: \"'sys/amiga/splitter/arg.c'\" unpacked with wrong size!
fi
# end of 'sys/amiga/splitter/arg.c'
fi
if test -f 'sys/amiga/splitter/split.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/amiga/splitter/split.h'\"
else
echo shar: Extracting \"'sys/amiga/splitter/split.h'\" \(5777 characters\)
sed "s/^X//" >'sys/amiga/splitter/split.h' <<'END_OF_FILE'
X/*    SCCS Id: @(#)split.h		3.1   93/01/08
X/*    Copyright (c) Kenneth Lorber, Bethesda, Maryland, 1992, 1993	  */
X/* NetHack may be freely redistributed.  See license for details. */
X
X/*
X * split.h
X * Common definitions for binary file splitting and loading of split files.
X */
X
X#define SVER	1	/* Basic file splitting capability */
X/*#define SVER	2	/* */
X/*#define SVER	3	/* */
X
X/* Nothing below this line should need to be modified. */
X
X#ifndef SVER
X __SPLIT_H__SVER_MUST_BE_DEFINED
X#endif
X
X#if SVER >= 2
X	/* enable options */
X#endif
X
X/* internal structures, etc */
X
X#include <exec/types.h>
X#include <exec/lists.h>
X#include <proto/exec.h>
X/*#include "ldextern.h"*/
X
X		/* one for each file we need something from */
Xstruct file_ {
X	struct MinNode	node;		/* linkage */
X	struct List	punits;		/* program units we need */
X	int		fd;		/* fd (-1 if not open) */
X	char *		name;		/* open(2)'able name */
X};
Xtypedef struct file_ file;
X
X		/* one for each program unit we need to load */
Xstruct punit_ {
X	struct MinNode	node;		/* linkage */
X	int		libsize;	/* 0 if normal, libsize if library */
X	struct block_ *	unit_header;
X	struct List	hunks;		/* hunks in this program unit */
X};
Xtypedef struct punit_ punit;
X
X		/* one for each hunk we need to load */
Xstruct hunk_ {
X	struct MinNode	node;		/* linkage */
X	struct List	reloc;		/* reloc8,16,32 */
X	struct List	dreloc;		/* drelec8,16,32 */
X	struct block_ *	rb;		/* ONE relocatable block */
X	struct block_ *	name;		/* max ONE name */
X	struct List	extsym;		/* external symbol entries */
X	struct punit_ * punit;		/* back pointer */
X	struct hunk_  * merge;		/* 0 if lone or last section, else next
X					 * part in this (merged by name) hunk */
X	struct hunk_  * jmptab;		/* alv's live here, if any do. If so,
X					 * it's at the end of the chain */
X	int	hunkstart:1;	/* lone hunk or start of a chain */
X	int	hunkchain:1;	/* allocated to a chain */
X	int	hunkgone:1;	/* hunk has been written */
X	long	overlay;	/* 0 if root node */
X	long 	hunknum;	/* in output file */
X	long	hunkoffset;	/* 0 unless not at start of chain */
X};
Xtypedef struct hunk_ hunk;
X#define UNASSIGNED_HUNK	0x7ffffff0
X
Xstruct block_ {
X	struct MinNode	node;	/* linkage */
X	struct swap_ *sw;	/* if !0, where to reload from disk */
X	int id;			/* if used */
X	long *b;		/* if !0, block of raw data (else swapped) */
X				/* (this should be replaced with a union) */
X};
Xtypedef struct block_ block;
X
X		/* This is used to keep memory usage down.  We don't read in
X		 * the actual data until we are writing the output file. */
Xstruct swap_ {
X	file *f;
X	long pos;
X	long len;			/* in longs */
X};
Xtypedef struct swap_ swap;
X
X		/* When we need a list of lists. */
Xstruct listlist_ {
X	struct MinNode	node;		/* linkage */
X	int 		id;
X	struct List	list;
X};
Xtypedef struct listlist_ listlist;
X
Xtypedef char flag;			/* TRUE or FALSE only */
X
X/* tracing system */
X#define MAXTRACEVAR	7
Xextern char trace[MAXTRACEVAR];
X#define LIST		if(trace[0])		/* -t0=1 */
X#define HASHSTAT	if(trace[1])		/* -t1=1 */
X#define HASHTBL		if(trace[1]>1)		/* -t1=2 */
X#define NAME		if(trace[2])		/* -t2=1 */
X#define OUT		if(trace[3])		/* -t3=1 */
X#define PROC		if(trace[4])		/* -t4=1 */
X#define LIB		if(trace[5])		/* -t5=1 */
X#define VLIB		if(trace[5]>1)		/* -t5=2 */
X#define OVER		if(trace[6])		/* -t6=1 */
X
X/* name_ (symbol table) system */
X#define HSIZE	128		/* MUST be power of two */
X#define HMASK	(HSIZE-1)
X
Xstruct nentry_ {		/* a name entry */
X	struct MinNode	next;	/* next ref or def in bucket */
X	struct hunk_ *defh;	/* hunk where defined, else 0 */
X	long defo;		/* offset value of definition */
X	char *name;		/* name */
X	short len;		/* len of name */
X	unsigned refflag:1;	/* just for input_check */
X	unsigned linkvar:1;	/* linker variable */
X	unsigned inroot:1;	/* forced into root node */
X};
Xtypedef struct nentry_ nentry;
X
X/* hunk numbers in the overlay file start at this value: */
X#define OVRHUNK_BASE 0x40000000
X#define OVRHUNK_MASK 0x0fffffff
X
X/* Lists */
X#define LIST_P struct List *
X#define NODE_P struct Node *
X
Xstruct Node *Head(struct List *);
Xstruct Node *Tail(struct List *);
Xstruct Node *Next(struct Node *);
Xstruct Node *Prev(struct Node *);
X
Xextern flag read_any_bss;
Xextern flag overlaying;
X
Xextern struct List *_fortemp;
X#define foreach(n,lp,t)	_fortemp=(struct List *)(lp);if(_fortemp)	\
X			for(n= t Head(_fortemp);n;			\
X			  n= t Next((struct Node *)(n)))
X
X/* privates for splitter */
X
X/* structs */
Xstruct hheader {
X	int hcount;		/* table size */
X	int first;		/* first hunk # */
X	int last;		/* last hunk # */
X	int (*sizes)[];		/* size of each hunk */
X};
Xstruct shunk {
X	struct hunk_ *h;		/* linker hunk info */
X};
X
X/* externs */
Xextern char *ssubst(char *,const char *);
Xextern void panic(char *);
Xextern char *eos(char *);
Xextern void read_load_file(char *);
Xextern void write_code_file(void);
Xextern void write_data_file(void);
Xextern void write_dir_file(void);
Xextern int write_split_file(int);
Xextern void write_lreloc(struct hunk_ *,struct listlist_ *);
Xextern void wsf_hunk(struct hunk_ *);
Xextern void renumber(void);
Xextern int renumber2(int,int);
Xextern void write_header(void);
Xextern void owrite(void*,long);
Xextern void owrite_long(long);
Xextern void out_start(char *);
Xextern void out_stop(void);
Xextern void new_file(void);
X
Xvoid print_text_block(char *,struct block_ *);
Xvoid print_bin_block(struct block_ *);
Xstruct file_ *NewFile(char *);
Xstruct punit_ *NewPunit(void);
Xstruct hunk_ *NewHunk(void);
Xstruct listlist_ *NewListList(void);
Xstruct block_ *NewBlock(void);
Xlong *NewData(long);
Xint rderror(void);	/* should be void, but needs return val for ?: */
Xstruct block_ *ReadSimpleBlock(struct file_ *,int);
Xint TossSimpleBlock(struct file_ *);
Xstruct hunk_ *ReadHunk(struct file_ *);
Xvoid ReadReloc(struct file_ *,long,struct List *);
Xlong block_size(struct block_ *);
END_OF_FILE
if test 5777 -ne `wc -c <'sys/amiga/splitter/split.h'`; then
    echo shar: \"'sys/amiga/splitter/split.h'\" unpacked with wrong size!
fi
# end of 'sys/amiga/splitter/split.h'
fi
if test -f 'sys/amiga/winami.p' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/amiga/winami.p'\"
else
echo shar: Extracting \"'sys/amiga/winami.p'\" \(2515 characters\)
sed "s/^X//" >'sys/amiga/winami.p' <<'END_OF_FILE'
X/*    SCCS Id: @(#)winami.p	3.1 93/01/08			 */
X/*    Copyright (c) Gregg Wonderly, Naperville, IL, 1992, 1993	 */
X/* NetHack may be freely redistributed. See license for details. */
X/* winami.c */
Xvoid FDECL(amii_raw_print, (const char *));
Xvoid FDECL(amii_raw_print_bold, (const char *));
Xvoid FDECL(amii_start_menu, (winid ));
Xvoid FDECL(amii_add_menu, (winid  , char  , int  , const char *));
Xvoid FDECL(amii_end_menu, (winid  , char  , const char * , const char *));
Xchar FDECL(amii_select_menu, (winid ));
Xvoid NDECL(amii_update_inventory );
Xvoid NDECL(amii_mark_synch );
Xvoid NDECL(amii_wait_synch );
Xvoid NDECL(amii_setclipped );
Xvoid FDECL(amii_cliparound, (int  , int ));
Xvoid NDECL(amii_askname );
Xvoid NDECL(amii_player_selection );
Xvoid NDECL(flush_output );
Xvoid FDECL(amii_destroy_nhwindow, (winid ));
Xint FDECL(amii_create_nhwindow, (int ));
Xvoid NDECL(amii_init_nhwindows );
Xvoid FDECL(amii_get_ext_cmd, (char *));
Xchar FDECL(amii_yn_function, (const char * , const char * , char ));
Xvoid FDECL(amii_addtopl, (const char *));
Xvoid FDECL(TextSpaces, (struct RastPort * , int ));
Xvoid FDECL(amii_putstr, (winid  , int  , const char *));
Xvoid FDECL(amii_putsym, (winid  , int  , int  , CHAR_P ));
Xvoid FDECL(amii_clear_nhwindow, (winid ));
Xvoid FDECL(amii_exit_nhwindows, (const char *));
Xint FDECL(amii_nh_poskey, (int * , int * , int *));
Xint NDECL(amii_nhgetch );
Xvoid NDECL(amii_get_nh_event );
Xvoid NDECL(amii_remember_topl );
Xint NDECL(amii_doprev_message );
Xvoid FDECL(amii_display_nhwindow, (winid  , boolean ));
Xvoid FDECL(amii_display_file, (const char * , boolean ));
Xvoid FDECL(amii_curs, (winid  , int  , int ));
Xvoid FDECL(amii_print_glyph, (winid  , xchar  , xchar  , int ));
Xvoid FDECL(DoMenuScroll, (int  , int ));
Xvoid FDECL(DisplayData, (int  , int  , int ));
Xvoid FDECL(SetPropInfo, (struct Window * , struct Gadget * , long  , long  , long ));
Xvoid FDECL(kill_nhwindows, (int ));
Xvoid FDECL(amii_cl_end, (struct WinDesc * , int ));
Xvoid FDECL(cursor_off, (winid ));
Xvoid FDECL(cursor_on, (winid ));
Xvoid NDECL(amii_getret );
Xvoid FDECL(amii_getlin, (const char * , char *));
Xvoid FDECL(getlind, (const char * , char * , const char *));
Xvoid FDECL(amii_suspend_nhwindows, (char * ));
Xvoid NDECL(amii_resume_nhwindows);
Xvoid NDECL(amii_bell);
Xvoid NDECL(EditColor);
Xvoid FDECL(DrawCol, ( struct Window *, int, UWORD * ) );
Xvoid FDECL( DispCol, ( struct Window *w, int idx, UWORD * ) );
Xvoid NDECL( amii_setpens );
Xvoid FDECL( SetBorder, (struct Gadget *) );
Xvoid NDECL( port_help );
END_OF_FILE
if test 2515 -ne `wc -c <'sys/amiga/winami.p'`; then
    echo shar: \"'sys/amiga/winami.p'\" unpacked with wrong size!
fi
# end of 'sys/amiga/winami.p'
fi
if test -f 'sys/atari/Makefile.utl' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/atari/Makefile.utl'\"
else
echo shar: Extracting \"'sys/atari/Makefile.utl'\" \(5437 characters\)
sed "s/^X//" >'sys/atari/Makefile.utl' <<'END_OF_FILE'
X#	Makefile for NetHack's utility programs.
X#	Atari specific version
X
X# if your make doesn't define a default SHELL properly, you may need
X#    the line below (Atari users will need a bourne work-alike)
X# SHELL = /bin/sh
X
X# flags may have to be changed as required
X# flags for 286 Xenix:
X# CFLAGS = -Ml2t16 -O -LARGE -I../include
X# LFLAGS = -Ml -F 4000 -SEG 512
X
X# flags for 286 Microport SysV-AT
X# CFLAGS = -DDUMB -Ml -I../include
X# LFLAGS = -Ml
X
X# flags for Atari GCC
XCFLAGS = -O -I../include
XLFLAGS =
X
X# flags for debugging:
X# CFLAGS = -g -I../include
X
X 
X
X# yacc/lex programs to use to generate *_comp.h, *_lex.c, and *_yacc.c.
X# if, instead of yacc/lex you have bison/flex, comment/uncomment the following.
X# YACC     = yacc
X# LEX      = lex
XYACC     = bison -y
XLEX      = flex
X 
X# these are the names of the output files from YACC/LEX. Under MS-DOS
X# and similar systems, they may differ
X# YTABC = y.tab.c
X# YTABH = y.tab.h
X# LEXYYC = lex.yy.c
XYTABC = y_tab.c
XYTABH = y_tab.h
XLEXYYC = lexyy.c
X
X# Nothing below this line should have to be changed.
X
X# utility .c files
XMAKESRC = makedefs.c
XSPLEVSRC = lev_yacc.c lev_lex.c lev_main.c panic.c
XDGNCOMPSRC = dgn_yacc.c dgn_lex.c dgn_main.c
XUTILSRCS = $(MAKESRC) $(SPLEVSRC) $(DGNCOMPSRC)
X
X# object files for makedefs
XMAKEOBJS = makedefs.o ../src/monst.o ../src/objects.o
X
X# object files for special levels compiler
XSPLEVOBJS = lev_yacc.o lev_lex.o lev_main.o panic.o \
X	../src/alloc.o ../src/drawing.o ../src/decl.o \
X	../src/monst.o ../src/objects.o
X
X# object files for dungeon compiler
XDGNCOMPOBJS = dgn_yacc.o dgn_lex.o dgn_main.o panic.o ../src/alloc.o
X
X# object files for recovery utility
XRECOVOBJS = recover.o
X
X
X#	dependencies for makedefs
X#
Xmakedefs:	$(MAKEOBJS)
X	$(CC) $(LFLAGS) -o makedefs $(MAKEOBJS)
X
Xmakedefs.o:  ../include/config.h ../include/permonst.h ../include/objclass.h \
X		../include/monsym.h ../include/artilist.h ../include/qtext.h \
X		../include/patchlevel.h
X
X../include/onames.h: makedefs
X	./makedefs -o
X../include/pm.h: makedefs
X	./makedefs -p
X../src/monstr.c: makedefs
X	./makedefs -m
X../include/vis_tab.h: makedefs
X	./makedefs -z
X../src/vis_tab.c: makedefs
X	./makedefs -z
X
Xlintdefs:
X	@lint -axbh -I../include -DLINT $(MAKESRC) ../src/monst.c ../src/objects.c | sed '/_flsbuf/d'
X
X
X# the src Makefile is responsible for knowing when to call this, since
X# it knows all about the main src and include files
X../include/date.h::
X	./makedefs -v
X
X
X#	dependencies for lev_comp
X#
Xlev_comp:  $(SPLEVOBJS)
X	$(CC) $(LFLAGS) -o lev_comp $(SPLEVOBJS)
X
Xlev_yacc.o:  ../include/hack.h ../include/sp_lev.h
Xlev_main.o:  ../include/hack.h ../include/sp_lev.h ../include/termcap.h
Xpanic.o:     ../include/config.h
X
Xlev_lex.o:   ../include/hack.h ../include/lev_comp.h ../include/sp_lev.h lev_lex.c
X	$(CC) -c $(CFLAGS) lev_lex.c
X
X../include/lev_comp.h: lev_yacc.c
X
Xlev_yacc.c: lev_comp.y
X	$(YACC) -d lev_comp.y
X	mv $(YTABC) lev_yacc.c
X	mv $(YTABH) ../include/lev_comp.h
X
Xlev_lex.c: lev_comp.l
X	$(LEX) lev_comp.l
X	mv $(LEXYYC) lev_lex.c
X
X# with all of extern.h's functions to complain about, we drown in
X# 'defined but not used' without -u
Xlintlev:
X	@lint -axhu -I../include -DLINT $(SPLEVSRC) ../src/alloc.c ../src/monst.c ../src/objects.c | sed '/_flsbuf/d'
X
X
X#	dependencies for dgn_comp
X#
Xdgn_comp:  $(DGNCOMPOBJS)
X	$(CC) $(LFLAGS) -o dgn_comp $(DGNCOMPOBJS)
X
Xdgn_yacc.o:  ../include/config.h ../include/dgn_file.h
Xdgn_main.o:  ../include/config.h
X
Xdgn_lex.o:   ../include/config.h ../include/dgn_comp.h ../include/dgn_file.h dgn_lex.c
X	$(CC) -c $(CFLAGS)  dgn_lex.c
X
X
X../include/dgn_comp.h: dgn_yacc.c
X
Xdgn_yacc.c: dgn_comp.y
X	$(YACC) -d dgn_comp.y
X	mv $(YTABC) dgn_yacc.c
X	mv $(YTABH) ../include/dgn_comp.h
X
Xdgn_lex.c: dgn_comp.l
X	$(LEX) dgn_comp.l
X	mv $(LEXYYC) dgn_lex.c
X
X# with all of extern.h's functions to complain about, we drown in
X# 'defined but not used' without -u
Xlintdgn:
X	@lint -axhu -I../include -DLINT $(DGNCOMPSRC) panic.c ../src/alloc.c | sed '/_flsbuf/d'
X
X
X#	dependencies for recover
X#
Xrecover: $(RECOVOBJS)
X	$(CC) $(LFLAGS) -o recover $(RECOVOBJS)
X
Xrecover.o: ../include/config.h
X
X
X
X# using dependencies like
X#	../src/foo::
X#		@( cd ../src ; $(MAKE) foo )
X# would always force foo to be up-to-date according to the src Makefile
X# when it's needed here.  unfortunately, some makes believe this syntax
X# means foo always changes, instead of foo should always be checked.
X# therefore, approximate via config.h dependencies, and hope that anybody
X# changing anything other than basic configuration also knows when not
X# to improvise things not in the instructions, like 'make makedefs' here
X# in util...
X
X# make sure object files from src are available when needed
X#
X../src/alloc.o: ../src/alloc.c ../include/config.h
X	@( cd ../src ; $(MAKE) alloc.o )
X../src/drawing.o: ../src/drawing.c ../include/config.h
X	@( cd ../src ; $(MAKE) drawing.o )
X../src/decl.o: ../src/decl.c ../include/config.h
X	@( cd ../src ; $(MAKE) decl.o )
X../src/monst.o: ../src/monst.c ../include/config.h
X	@( cd ../src ; $(MAKE) monst.o )
X../src/objects.o: ../src/objects.c ../include/config.h
X	@( cd ../src ; $(MAKE) objects.o )
X
X# make sure hack.h dependencies get transitive information
X../include/hack.h: ../include/config.h
X	@( cd ../src ; $(MAKE) ../include/hack.h )
X
Xtags: $(UTILSRCS)
X	@ctags -tw $(UTILSRCS)
X
Xclean:
X	rm -f *.o
X
Xspotless: clean
X	rm -f lev_lex.c lev_yacc.c dgn_lex.c dgn_yacc.c
X	rm -f ../include/lev_comp.h ../include/dgn_comp.h
X	rm -f makedefs lev_comp dgn_comp recover
END_OF_FILE
if test 5437 -ne `wc -c <'sys/atari/Makefile.utl'`; then
    echo shar: \"'sys/atari/Makefile.utl'\" unpacked with wrong size!
fi
# end of 'sys/atari/Makefile.utl'
fi
if test -f 'sys/mac/maccurs.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/mac/maccurs.c'\"
else
echo shar: Extracting \"'sys/mac/maccurs.c'\" \(5462 characters\)
sed "s/^X//" >'sys/mac/maccurs.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)maccurs.c	3.1	93/01/24		  */
X/* Copyright (c) Jon W{tte, 1992.				  */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include "hack.h"
X
X#include <Folders.h>
X#include <Windows.h>
X#include <ToolUtils.h>
X#include <Resources.h>
X#include <Memory.h>
X#include <Files.h>
X
X#define DIV_FACTOR 3
X
Xstatic Boolean winFileInit = 0 ;
Xstatic unsigned char winFileName [ 32 ] ;
Xstatic long winFileDir ;
Xstatic short winFileVol ;
Xstatic Handle winFileContents = NULL ;
X
Xtypedef struct WinPosSave {
X	short			validPos ;
X	short			validSize ;
X	short			top ;
X	short			left ;
X	short			height ;
X	short			width ;
X} WinPosSave ;
X
Xstatic WinPosSave savePos [ kLastWindowKind + 1 ] ;
Xstatic WinPosSave usePos [ kLastWindowKind + 1 ] ;
X
X
X
Xstatic void
XInitWinFile ( void )
X{
X	StringHandle sh ;
X	long len ;
X	short ref = 0 ;
X
X	if ( winFileInit ) {
X		return ;
X	}
X/* We trust the glue. If there's an error, store in game dir. */
X	if ( FindFolder ( kOnSystemDisk , kPreferencesFolderType , kCreateFolder ,
X		& winFileVol , & winFileDir ) ) {
X		winFileVol = 0 ;
X		winFileDir = 0 ;
X	}
X	sh = GetString ( 128 ) ;
X	if ( sh && * sh ) {
X		BlockMove ( * sh , winFileName , * * sh + 1 ) ;
X		ReleaseResource ( sh ) ;
X	} else {
X		BlockMove ( "\PNetHack Windows" , winFileName , 16 ) ;
X	}
X	if ( HOpen ( winFileVol , winFileDir , winFileName , fsRdPerm , & ref ) ) {
X		return ;
X	}
X	len = sizeof ( savePos ) ;
X	if ( ! FSRead ( ref , & len , savePos ) ) {
X		winFileInit = 1 ;
X	}
X	BlockMove ( savePos , usePos , sizeof ( savePos ) ) ;
X	FSClose ( ref ) ;
X}
X
X
Xstatic void
XFlushWinFile ( void )
X{
X	short ref ;
X	long len ;
X
X	if ( ! winFileInit ) {
X		if ( ! winFileName [ 0 ] ) {
X			return ;
X		}
X		HCreate ( winFileVol , winFileDir , winFileName , MAC_CREATOR , PREF_TYPE ) ;
X		HCreateResFile ( winFileVol , winFileDir , winFileName ) ;
X	}
X	if ( HOpen ( winFileVol , winFileDir , winFileName , fsWrPerm , & ref ) ) {
X		return ;
X	}
X	winFileInit = 1 ;
X	len = sizeof ( savePos ) ;
X	( void ) FSWrite ( ref , & len , savePos ) ; /* Don't care about error */
X	FSClose ( ref ) ;
X}
X
X
Xint
XclickSector ( int x , int y , int toX , int toY )
X{
X	Boolean isDown = 0 ;
X	Boolean isLeft = 0 ;
X	Boolean inHoriz = 0 ;
X	Boolean inVert = 0 ;
X
X	if ( toX == x && toY == y ) {
X
X		return 0 ; /* On the same spot */
X	}
X
X	if ( abs ( toY - y ) <= abs ( toX - x ) / DIV_FACTOR ) {
X
X		inHoriz = 1 ;
X	}
X	if ( abs ( toX - x ) <= abs ( toY - y ) / DIV_FACTOR ) {
X
X		inVert = 1 ;
X	}
X	if ( toY > y ) {
X
X		isDown = 1 ;
X	}
X	if ( toX < x ) {
X
X		isLeft = 1 ;
X	}
X
X	if ( inHoriz ) {
X
X		if ( isLeft ) {
X
X			return 7 ;
X		}
X		return 3 ;
X	}
X	if ( inVert ) {
X
X		if ( isDown ) {
X
X			return 5 ;
X		}
X		return 1 ;
X	}
X	if ( isDown ) {
X
X		if ( isLeft ) {
X
X			return 6 ;
X		}
X		return 4 ;
X
X	} else {
X
X		if ( isLeft ) {
X
X			return 8 ;
X		}
X		return 2 ;
X	}
X}
X
X
X
X
XBoolean
XRetrievePosition ( short kind , short * top , short * left )
X{
X	Point p ;
X
X	InitWinFile ( ) ;
X	if ( kind < 0 || kind > kLastWindowKind ) {
X		return 0 ;
X	}
X	if ( ! usePos [ kind ] . validPos ) {
X		return 0 ;
X	}
X	* top = usePos [ kind ] . top ;
X	* left = usePos [ kind ] . left ;
X	p . h = * left ;
X	p . v = * top ;
X	return PtInRgn ( p , GetGrayRgn ( ) ) ;
X}
X
X
XBoolean
XRetrieveSize ( short kind , short top , short left , short * height , short * width )
X{
X	Point p ;
X
X	InitWinFile ( ) ;
X	if ( kind < 0 || kind > kLastWindowKind ) {
X		return 0 ;
X	}
X	if ( ! usePos [ kind ] . validSize ) {
X		return 0 ;
X	}
X	* width = usePos [ kind ] . width ;
X	* height = usePos [ kind ] . height ;
X	p . h = left + * width ;
X	p . v = top + * height ;
X	return PtInRgn ( p , GetGrayRgn ( ) ) ;
X}
X
X
Xvoid
XSavePosition ( short kind , short top , short left )
X{
X	InitWinFile ( ) ;
X	if ( kind < 0 || kind > kLastWindowKind ) {
X		return ;
X	}
X	savePos [ kind ] . validPos = 1 ;
X	savePos [ kind ] . top = top ;
X	savePos [ kind ] . left = left ;
X	FlushWinFile ( ) ;
X}
X
X
Xvoid
XSaveSize ( short kind , short height , short width )
X{
X	InitWinFile ( ) ;
X	if ( kind < 0 || kind > kLastWindowKind ) {
X		return ;
X	}
X	savePos [ kind ] . validSize = 1 ;
X	savePos [ kind ] . width = width ;
X	savePos [ kind ] . height = height ;
X	FlushWinFile ( ) ;
X}
X
X
Xstatic short
XGetWinKind ( WindowPtr win )
X{
X	short kind ;
X	NhWindow * nhw = GetWRefCon ( win ) ;
X
X	if ( ! nhw || ( ( ( long ) nhw ) & 1 ) || nhw -> theWindow != win ) {
X		return -1 ;
X	}
X	kind = nhw -> kind ;
X	if ( kind < 0 || kind > NHW_TEXT ) {
X		return -1 ;
X	}
X	switch ( kind ) {
X	case NHW_MAP :
X		kind = kMapWindow ;
X		break ;
X	case NHW_STATUS :
X		kind = kStatusWindow ;
X		break ;
X	case NHW_MESSAGE :
X		kind = kMessageWindow ;
X		break ;
X	case NHW_MENU :
X		kind = kMenuWindow ;
X		break ;
X	default :
X		kind = kTextWindow ;
X		break ;
X	}
X
X	return kind ;
X}
X
X
XBoolean
XRetrieveWinPos ( WindowPtr win , short * top , short * left )
X{
X	short kind ;
X
X	kind = GetWinKind ( win ) ;
X	if ( kind < 0 || kind > kLastWindowKind ) {
X		return 0 ;
X	}
X	return RetrievePosition ( kind , top , left ) ;
X}
X
X
Xvoid
XSaveWindowPos ( WindowPtr win )
X{
X	short kind ;
X	GrafPtr gp ;
X	Point p = { 0 , 0 } ;
X
X	kind = GetWinKind ( win ) ;
X	if ( kind < 0 || kind > kLastWindowKind ) {
X		return ;
X	}
X	GetPort ( & gp ) ;
X	SetPort ( win ) ;
X	LocalToGlobal ( & p ) ;
X	SetPort ( gp ) ;
X	SavePosition ( kind , p . v , p . h ) ;
X}
X
X
Xvoid
XSaveWindowSize ( WindowPtr win )
X{
X	short kind , width , height ;
X
X	kind = GetWinKind ( win ) ;
X	width = win -> portRect . right - win -> portRect . left ;
X	height = win -> portRect . bottom - win -> portRect . top ;
X	SaveSize ( kind , height , width ) ;
X}
END_OF_FILE
if test 5462 -ne `wc -c <'sys/mac/maccurs.c'`; then
    echo shar: \"'sys/mac/maccurs.c'\" unpacked with wrong size!
fi
# end of 'sys/mac/maccurs.c'
fi
if test -f 'sys/vms/oldcrtl.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/vms/oldcrtl.c'\"
else
echo shar: Extracting \"'sys/vms/oldcrtl.c'\" \(5550 characters\)
sed "s/^X//" >'sys/vms/oldcrtl.c' <<'END_OF_FILE'
X/*       SCCS Id: @(#)oldcrtl.c   3.1      90/05/24
X/*   	 Pat Rankin  May'90                                       */
X/* VMS NetHack support, not needed for vms 4.6,4.7,or 5.x.        */
X
X#ifdef VERYOLD_VMS
X/*
X * The following routines are used by NetHack but were not available
X * from the C Run-Time Library (VAXCRTL) prior to VMS V4.6.
X *
X *      atexit, memcmp, memcpy, qsort, rename, vprintf, vsprintf
X *
X * Most of them are implemented here, but others will have to be worked
X * around in another fashion [such as '#define USE_OLDARGS' (even though
X * <varargs.h> is available) to avoid the need for vprintf & vsprintf].
X *
X */
X#define REG register
X#define const
X
X#ifndef SUPPRESS_MEM_FUNCS
X/* note: hand optimized for VAX (hardware pre-decrement & post-increment) */
X
X/* void *memset(void *, int, size_t) -- fill chunk of memory.
X*/
Xchar *memset( dst, fil, cnt )
XREG char *dst;
XREG char  fil;
XREG int   cnt;
X{
X    char *dst_p = dst;
X    while ( --cnt >= 0 )
X	*dst++ = fil;
X    return dst_p;
X}
X
X/* void *memcpy(void *, const void *, size_t) -- copy chunk of memory.
X*/
Xchar *memcpy( dst, src, cnt )
XREG char       *dst;
XREG const char *src;
XREG int		cnt;
X{
X    char *dst_p = dst;
X    while ( --cnt >= 0 )
X	*dst++ = *src++;
X    return dst_p;
X}
X
X/* void *memmove(void *, const void *, size_t) -- copy possibly overlapping mem.
X*/
Xchar *memmove( dst, src, cnt )
XREG char       *dst;
XREG const char *src;
XREG int		cnt;
X{
X    char *dst_p = dst;
X    if ( src == dst || cnt <= 0 ) {
X	;       /* do nothing */
X    } else if ( dst < src || dst >= src + cnt ) {
X	while ( --cnt >= 0 )
X	    *dst++ = *src++;
X    } else {    /* work backwards */
X	dst += cnt,  src += cnt;
X	while ( --cnt >= 0 )
X	    *--dst = *--src;
X    }
X    return dst_p;
X}
X
X/* void *memchr(const void *, int, size_t) -- search for a byte.
X*/
Xchar *memchr( buf, byt, len )
XREG const char *buf;
XREG char		byt;
XREG int		len;
X{
X    while ( --len >= 0 )
X	if ( *buf++ == byt )    /* found */
X	    return (char *)--buf;
X    return (char *)0;       /* not found */
X}
X
X/* int memcmp(const void *, const void *, size_t) -- compare two chunks.
X*/
Xint memcmp( buf1, buf2, len )
XREG const char *buf1;
XREG const char *buf2;
XREG int		len;
X{
X    while ( --len >= 0 )
X	if ( *buf1++ != *buf2++ )
X	    return (*--buf1 - *--buf2);
X    return 0;   /* buffers matched */
X}
X#endif /*!SUPPRESS_MEM_FUNCS*/
X
X
X#ifndef SUPPRESS_ATEXIT
X/* int atexit(void (*)(void)) -- register an exit handler.
X*/
X#define MAX_EXIT_FUNCS 32       /* arbitrary (32 matches VAX C v3.x docs) */
Xstruct _ex_hndlr { long reserved, (*routine)(), arg_count, *arg1_addr; };
Xstatic int ex_cnt = 0;          /* number of handlers registered so far */
Xstatic struct { long dummy_arg; struct _ex_hndlr handler;   /*(black box)*/
X       } ex_data[MAX_EXIT_FUNCS];       /* static handler data */
X
Xint atexit( function )
X    int (*function)();          /* note: actually gets called with 1 arg */
X{
X    if ( ex_cnt < MAX_EXIT_FUNCS ) {
X	ex_data[ex_cnt].dummy_arg = 0;  /* ultimately receives exit reason */
X	ex_data[ex_cnt].handler.reserved  = 0;
X	ex_data[ex_cnt].handler.routine   = (long (*)()) function;
X	ex_data[ex_cnt].handler.arg_count = 1;          /*(required)*/
X	ex_data[ex_cnt].handler.arg1_addr = &ex_data[ex_cnt].dummy_arg;
X	SYS$DCLEXH( &ex_data[ex_cnt].handler);  /* declare exit handler */
X	return ++ex_cnt;        /*(non-zero)*/
X    } else
X	return 0;
X}
X#endif /*!SUPPRESS_ATEXIT*/
X
X
X#ifndef SUPPRESS_RENAME
X/* int rename(const char *, const char *) -- rename a file (on same device).
X*/
X#ifndef EVMSERR
X#include <errno.h>
X#define C$$TRANSLATE(status)    (errno = EVMSERR,  vaxc$errno = (status))
X#endif
X
Xint rename( old_name, new_name )
X    const char *old_name;
X    const char *new_name;
X{
X    struct _dsc { int len; const char *adr; } old_dsc, new_dsc;
X    unsigned long status, LIB$RENAME_FILE();
X
X    /* put strings into descriptors and call run-time library routine */
X    old_dsc.len = strlen( old_dsc.adr = old_name );
X    new_dsc.len = strlen( new_dsc.adr = new_name );
X    status = LIB$RENAME_FILE( &old_dsc, &new_dsc);  /* omit optional args */
X    if ( !(status & 1) ) {      /* even => failure */
X	C$$TRANSLATE(status);
X	return -1;
X    } else                      /*  odd => success */
X	return 0;
X}
X#endif /*!SUPPRESS_RENAME*/
X
X
X#ifndef SUPPRESS_QSORT
X/* void qsort(void *, size_t, size_t, int (*)()) -- sort arbitrary collection.
X*/
Xvoid qsort( base, count, size, compare )
X    char *base;
X    int   count;
XREG int   size;
X    int (*compare)();
X{
XREG int   i, cmp;
XREG char *next, *prev, *tmp = 0;
X    char  wrk_buf[512], *malloc();      /* assume no alloca() available */
X
X    /* just use a shuffle sort (tradeoff between efficiency & simplicity) */
X    /*  [Optimal if already sorted; worst case when initially reversed.]  */
X    for ( next = base, i = 1;  i < count;  i++ ) {
X	prev = next,  next += size;             /* increment front pointer */
X	if ( (cmp = (*compare)( next, prev)) < 0 ) {
X	    /* found element out of order; move other(s) up then re-insert it */
X	    if ( !tmp )  tmp = (size > sizeof wrk_buf ? malloc(size) : wrk_buf);
X	    memcpy( tmp, next, size);           /* save smaller element */
X	    while ( cmp < 0 ) {
X		memcpy( prev + size, prev, size);   /* move larger elem. up */
X		prev -= size;                   /* decrement back pointer */
X		cmp = (prev >= base ? (*compare)( tmp, prev) : 0);
X	    }
X	    memcpy( prev + size, tmp, size);    /* restore small element */
X	}
X    }
X    if ( tmp != 0 && tmp != wrk_buf )  free(tmp);
X    return;
X}
X#endif /*!SUPPRESS_QSORT*/
X
X#endif /*VERYOLD_VMS*/
END_OF_FILE
if test 5550 -ne `wc -c <'sys/vms/oldcrtl.c'`; then
    echo shar: \"'sys/vms/oldcrtl.c'\" unpacked with wrong size!
fi
# end of 'sys/vms/oldcrtl.c'
fi
if test -f 'util/recover.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'util/recover.c'\"
else
echo shar: Extracting \"'util/recover.c'\" \(5503 characters\)
sed "s/^X//" >'util/recover.c' <<'END_OF_FILE'
X/* recover.c - NetHack version 3.1 */
X
X/*
X *  Utility for reconstructing NetHack save file from a set of individual
X *  level files.  Requires that the `checkpoint' option be enabled at the
X *  time NetHack creates those level files.
X */
X#include "config.h"
X#if !defined(O_WRONLY) && !defined(LSC) && !defined(AZTEC_C)
X#include <fcntl.h>
X#endif
X
X#ifndef VMS
X# ifdef exit
X#  undef exit
X# endif
X#ifdef MICRO
Xextern void FDECL(exit, (int));
X#endif
X#else	/* VMS */
Xextern int FDECL(vms_creat, (const char *,unsigned));
Xextern int FDECL(vms_open, (const char *,int,unsigned));
X#endif	/* VMS */
X
Xint FDECL(restore_savefile, (char *));
Xvoid FDECL(set_levelfile_name, (int));
Xint FDECL(open_levelfile, (int));
Xint FDECL(create_savefile, (char *));
Xvoid FDECL(copy_bytes, (int,int));
X
X#ifdef UNIX
X#define SAVESIZE	(PL_NSIZ + 13)	/* save/99999player.e */
X#else
X# ifdef VMS
X#define SAVESIZE	(PL_NSIZ + 22)	/* [.save]<uid>player.e;1 */
X# else
X#define SAVESIZE	FILENAME	/* from macconf.h or pcconf.h */
X# endif
X#endif
X
Xchar savename[SAVESIZE]; /* holds relative path of save file from playground */
X
X
Xint
Xmain(argc, argv)
Xint argc;
Xchar *argv[];
X{
X	int argno;
X	char *dir = (char *)0;
X
X	if (argc == 1 || (argc == 2 && !strcmp(argv[1], "-"))) {
X		(void) fprintf(stderr,
X				"Usage: %s [-d directory] base1 base2 ...\n",
X				argv[0]);
X		exit(1);
X	}
X
X	argno = 1;
X	if (!strncmp(argv[argno], "-d", 2)) {
X		dir = argv[argno]+2;
X		if (*dir == '=' || *dir == ':') dir++;
X		if (!*dir && argc > argno) {
X			argno++;
X			dir = argv[argno];
X		}
X		if (!*dir) {
X		    (void) fprintf(stderr,
X			"%s: flag -d must be followed by a directory name.\n",
X			argv[0]);
X		    exit(1);
X		}
X		argno++;
X	}
X
X	if (!dir) dir = getenv("NETHACKDIR");
X	if (!dir) dir = getenv("HACKDIR");
X#if defined(SECURE) && !defined(VMS)
X	if (dir
X# ifdef HACKDIR
X		&& strcmp(dir, HACKDIR)
X# endif
X		) {
X		(void) setgid(getgid());
X		(void) setuid(getuid());
X	}
X#endif	/* SECURE && !VMS */
X
X#ifdef HACKDIR
X	if (!dir) dir = HACKDIR;
X#endif
X
X	if (dir && chdir(dir) < 0) {
X		(void) fprintf(stderr, "%s: cannot chdir to %s.\n",
X				argv[0], dir);
X		exit(1);
X	}
X
X	while (argc > argno) {
X		(void) restore_savefile(argv[argno]);
X		argno++;
X	}
X#ifndef VMS
X	return 0;
X#else
X	return 1;       /* vms success */
X#endif /*VMS*/
X}
X
Xstatic char lock[256];
X
Xvoid
Xset_levelfile_name(lev)
Xint lev;
X{
X	char *tf;
X
X	tf = rindex(lock, '.');
X	if (!tf) {
X		tf = lock;
X		while (*tf) tf++;
X	}
X#ifdef VMS
X	(void) sprintf(tf, ".%d;1", lev);
X#else
X	(void) sprintf(tf, ".%d", lev);
X#endif
X}
X
Xint
Xopen_levelfile(lev)
Xint lev;
X{
X	int fd;
X
X	set_levelfile_name(lev);
X#ifdef MICRO
X	fd = open(lock, O_RDONLY | O_BINARY);
X#else
X	fd = open(lock, O_RDONLY, 0);
X#endif
X	return fd;
X}
X
Xint
Xcreate_savefile(savename)
Xchar *savename;
X{
X	int fd;
X
X#ifdef MICRO
X	fd = open(savename, O_WRONLY | O_BINARY | O_CREAT | O_TRUNC, FCMASK);
X#else
X	fd = creat(savename, FCMASK);
X#endif
X	return fd;
X}
X
Xvoid
Xcopy_bytes(ifd, ofd)
Xint ifd, ofd;
X{
X	char buf[BUFSIZ];
X	int nfrom, nto;
X
X	do {
X		nfrom = read(ifd, buf, BUFSIZ);
X		nto = write(ofd, buf, nfrom);
X		if (nto != nfrom) {
X			(void) fprintf(stderr, "file copy failed!\n");
X			exit(1);
X		}
X	} while (nfrom == BUFSIZ);
X}
X
Xint
Xrestore_savefile(basename)
Xchar *basename;
X{
X	int gfd, lfd, sfd;
X	int lev, savelev, hpid;
X	xchar levc;
X
X	/* level 0 file contains:
X	 *	pid of creating process (ignored here)
X	 *	level number for current level of save file
X	 *	name of save file nethack would have created
X	 *	and game state
X	 */
X	(void) strcpy(lock, basename);
X	gfd = open_levelfile(0);
X	if (gfd < 0) {
X	    (void) fprintf(stderr, "Cannot open level 0 for %s.\n", basename);
X	    return(-1);
X	}
X	(void) read(gfd, (genericptr_t) &hpid, sizeof(hpid));
X	if (read(gfd, (genericptr_t) &savelev, sizeof(savelev))
X							!= sizeof(savelev)) {
X	    (void) fprintf(stderr,
X	    "Checkpointing was not in effect for %s -- recovery impossible.\n",
X		basename);
X	    (void) close(gfd);
X	    return(-1);
X	}
X	(void) read(gfd, (genericptr_t) savename, sizeof(savename));
X
X	/* save file should contain:
X	 *	current level (including pets)
X	 *	(non-level-based) game state
X	 *	other levels
X	 */
X	sfd = create_savefile(savename);
X	if (sfd < 0) {
X	    (void) fprintf(stderr, "Cannot create savefile %s.\n", savename);
X	    (void) close(gfd);
X	    return(-1);
X	}
X
X	lfd = open_levelfile(savelev);
X	if (lfd < 0) {
X	    (void) fprintf(stderr, "Cannot open level of save for %s.\n",
X				basename);
X	    (void) close(gfd);
X	    (void) close(sfd);
X	    return(-1);
X	}
X
X	copy_bytes(lfd, sfd);
X	(void) close(lfd);
X	(void) unlink(lock);
X
X	copy_bytes(gfd, sfd);
X	(void) close(gfd);
X	set_levelfile_name(0);
X	(void) unlink(lock);
X
X	for (lev = 1; lev < 256; lev++) {
X		/* level numbers are kept in xchars in save.c, so the
X		 * maximum level number (for the endlevel) must be < 256
X		 */
X		if (lev != savelev) {
X			lfd = open_levelfile(lev);
X			if (lfd >= 0) {
X				/* any or all of these may not exist */
X				levc = (xchar) lev;
X				write(sfd, (genericptr_t) &levc, sizeof(levc));
X				copy_bytes(lfd, sfd);
X				(void) close(lfd);
X				(void) unlink(lock);
X			}
X		}
X	}
X
X	(void) close(sfd);
X
X#ifdef AMIGA
X			/* we need to create an icon for the saved game
X			 * or HackWB won't notice the file.
X			 */
X	{
X	char iconfile[FILENAME];
X	int in, out;
X
X	sprintf(iconfile,"%s.info",savename);
X	in=open("NetHack:default.icon",O_RDONLY);
X	out=open(iconfile,O_WRONLY | O_TRUNC | O_CREAT);
X	if(in > -1 && out > -1){
X		copy_bytes(in,out);
X	}
X	if(in > -1)close(in);
X	if(out > -1)close(out);
X	}
X#endif
X	return(0);
X}
X
X/*recover.c*/
END_OF_FILE
if test 5503 -ne `wc -c <'util/recover.c'`; then
    echo shar: \"'util/recover.c'\" unpacked with wrong size!
fi
# end of 'util/recover.c'
fi
echo shar: End of archive 101 \(of 108\).
cp /dev/null ark101isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \
21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \
41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 \
61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 \
81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 \
101 102 103 104 105 106 107 108 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 108 archives.
    echo "Now execute 'rebuild.sh'"
    rm -f ark10[0-8]isdone ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
