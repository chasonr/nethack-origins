Path: uunet!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v16i045:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Part37/108
Message-ID: <4339@master.CNA.TEK.COM>
Date: 30 Jan 93 01:12:05 GMT
Sender: news@master.CNA.TEK.COM
Lines: 2264
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1594

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 16, Issue 45
Archive-name: nethack31/Part37
Supersedes: nethack3p9: Volume 10, Issue 46-102
Environment: Amiga, Atari, Mac, MS-DOS, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 37 (of 108)."
# Contents:  src/mail.c sys/mac/macwin.c1
# Wrapped by billr@saab on Wed Jan 27 16:09:00 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'src/mail.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/mail.c'\"
else
echo shar: Extracting \"'src/mail.c'\" \(14946 characters\)
sed "s/^X//" >'src/mail.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)mail.c	3.1	92/11/14	*/
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include "hack.h"
X
X#ifdef MAIL
X#include "mail.h"
X/*
X * Notify user when new mail has arrived.  Idea by Merlyn Leroy.
X *
X * The mail daemon can move with less than usual restraint.  It can:
X *	- move diagonally from a door
X *	- use secret and closed doors
X *	- run through a monster ("Gangway!", etc.)
X *	- run over pools & traps
X *
X * Possible extensions:
X *	- Open the file MAIL and do fstat instead of stat for efficiency.
X *	  (But sh uses stat, so this cannot be too bad.)
X *	- Examine the mail and produce a scroll of mail named "From somebody".
X *	- Invoke MAILREADER in such a way that only this single letter is read.
X *	- Do something to the text when the scroll is enchanted or cancelled.
X *	- Make the daemon always appear at a stairwell, and have it find a
X *	  path to the hero.
X *
X * Note by Olaf Seibert: On the Amiga, we usually don't get mail.  So we go
X *			 through most of the effects at 'random' moments.
X */
X
Xstatic boolean FDECL(md_start,(coord *));
Xstatic boolean FDECL(md_stop,(coord *, coord *));
Xstatic boolean FDECL(md_rush,(struct monst *,int,int));
Xstatic void FDECL(newmail, (struct mail_info *));
X
Xextern char *viz_rmin, *viz_rmax;	/* line-of-sight limits (vision.c) */
X
X#ifdef OVL0
X
X# if !defined(UNIX) && !defined(VMS)
Xint mustgetmail = -1;
X# endif
X
X#endif /* OVL0 */
X#ifdef OVLB
X
X# ifdef UNIX
X#  include <sys/stat.h>
X#  include <pwd.h>
X/* DON'T trust all Unices to declare getpwuid() in <pwd.h> */
X#  if !defined(_BULL_SOURCE) && !defined(sgi)
X/* DO trust all SVR4 to typedef uid_t in <sys/types.h> (probably to a long) */
X#   if defined(POSIX_TYPES) || defined(SVR4)
Xextern struct passwd *FDECL(getpwuid,(uid_t));
X#   else 
Xextern struct passwd *FDECL(getpwuid,(int));
X#   endif
X#  endif
Xstatic struct stat omstat,nmstat;
Xstatic char *mailbox = NULL;
Xstatic long laststattime;
X
X# ifdef AMS				/* Just a placeholder for AMS */
X#   define MAILPATH "/dev/null"
X# else
X#  if defined(BSD) || defined(ULTRIX)
X#   define MAILPATH "/usr/spool/mail/"
X#  endif
X#  if defined(SYSV) || defined(HPUX)
X#   define MAILPATH "/usr/mail/"
X#  endif
X# endif /* AMS */
X
Xvoid
Xgetmailstatus()
X{
X	if(!mailbox && !(mailbox = getenv("MAIL"))) {
X#  ifdef MAILPATH
X#   ifdef AMS
X	        struct passwd ppasswd;
X
X		(void) memcpy(&ppasswd, getpwuid(getuid()), sizeof(struct passwd));
X		if (ppasswd.pw_dir) {
X		     mailbox = (char *) alloc((unsigned) strlen(ppasswd.pw_dir)+sizeof(AMS_MAILBOX));
X		     Strcpy(mailbox, ppasswd.pw_dir);
X		     Strcat(mailbox, AMS_MAILBOX);
X		} else
X		  return;
X#   else
X		mailbox = (char *) alloc(sizeof(MAILPATH)+8);
X		Strcpy(mailbox, MAILPATH);
X		Strcat(mailbox, getpwuid(getuid())->pw_name);
X#  endif /* AMS */
X#  else
X		return;
X#  endif
X	}
X	if(stat(mailbox, &omstat)){
X#  ifdef PERMANENT_MAILBOX
X		pline("Cannot get status of MAIL=\"%s\".", mailbox);
X		mailbox = 0;
X#  else
X		omstat.st_mtime = 0;
X#  endif
X	}
X}
X# endif /* UNIX */
X
X/*
X * Pick coordinates for a starting position for the mail daemon.  Called
X * from newmail() and newphone().
X */
Xstatic boolean
Xmd_start(startp)
X    coord *startp;
X{
X    coord testcc;	/* scratch coordinates */
X    int row;		/* current row we are checking */
X    int lax;		/* if TRUE, pick a position in sight. */
X    int dd;		/* distance to current point */
X    int max_distance;	/* max distance found so far */
X
X    /*
X     * If blind and not telepathic, then it doesn't matter what we pick ---
X     * the hero is not going to see it anyway.  So pick a nearby position.
X     */
X    if (Blind && !Telepat) {
X	if (!enexto(startp, u.ux, u.uy, (struct permonst *) 0))
X	    return FALSE;	/* no good posiitons */
X	return TRUE;
X    }
X
X    /*
X     * Arrive at an up or down stairwell if it is in line of sight from the
X     * hero.
X     */
X    if (couldsee(upstair.sx, upstair.sy)) {
X	startp->x = upstair.sx;
X	startp->y = upstair.sy;
X	return TRUE;
X    }
X    if (couldsee(dnstair.sx, dnstair.sy)) {
X	startp->x = dnstair.sx;
X	startp->y = dnstair.sy;
X	return TRUE;
X    }
X
X    /*
X     * Try to pick a location out of sight next to the farthest position away
X     * from the hero.  If this fails, try again, just picking the farthest
X     * position that could be seen.  What we really ought to be doing is
X     * finding a path from a stairwell...
X     *
X     * The arrays viz_rmin[] and viz_rmax[] are set even when blind.  These
X     * are the LOS limits for each row.
X     */
X    lax = 0;	/* be picky */
X    max_distance = -1;
Xretry:
X    for (row = 0; row < ROWNO; row++) {
X	if (viz_rmin[row] < viz_rmax[row]) {
X	    /* There are valid positions on this row. */
X	    dd = distu(viz_rmin[row],row);
X	    if (dd > max_distance) {
X		if (lax) {
X		    max_distance = dd;
X		    startp->y = row;
X		    startp->x = viz_rmin[row];
X		    
X		} else if (enexto(&testcc, (xchar)viz_rmin[row], row,
X						(struct permonst *) 0) &&
X			   !cansee(testcc.x, testcc.y) &&
X			   couldsee(testcc.x, testcc.y)) {
X		    max_distance = dd;
X		    *startp = testcc;
X		}
X	    }
X	    dd = distu(viz_rmax[row],row);
X	    if (dd > max_distance) {
X		if (lax) {
X		    max_distance = dd;
X		    startp->y = row;
X		    startp->x = viz_rmax[row];
X		    
X		} else if (enexto(&testcc, (xchar)viz_rmax[row], row,
X						(struct permonst *) 0) &&
X			   !cansee(testcc.x,testcc.y) &&
X			   couldsee(testcc.x, testcc.y)) {
X
X		    max_distance = dd;
X		    *startp = testcc;
X		}
X	    }
X	}
X    }
X
X    if (max_distance < 0) {
X	if (!lax) {
X	    lax = 1;		/* just find a position */
X	    goto retry;
X	}
X	return FALSE;
X    }
X
X    return TRUE;
X}
X
X/*
X * Try to choose a stopping point as near as possible to the starting
X * position while still adjacent to the hero.  If all else fails, try
X * enexto().  Use enexto() as a last resort because enexto() chooses
X * its point randomly, which is not what we want.
X */
Xstatic boolean
Xmd_stop(stopp, startp)
X    coord *stopp;	/* stopping position (we fill it in) */
X    coord *startp;	/* starting positon (read only) */
X{
X    int x, y, distance, min_distance = -1;
X
X    for (x = u.ux-1; x <= u.ux+1; x++)
X	for (y = u.uy-1; y <= u.uy+1; y++) {
X	    if (!isok(x, y) || (x == u.ux && y == u.uy)) continue;
X
X	    if (ACCESSIBLE(levl[x][y].typ) && !MON_AT(x,y)) {
X		distance = dist2(x,y,startp->x,startp->y);
X		if (min_distance < 0 || distance < min_distance ||
X			(distance == min_distance && rn2(2))) {
X		    stopp->x = x;
X		    stopp->y = y;
X		    min_distance = distance;
X		}
X	    }
X	}
X
X    /* If we didn't find a good spot, try enexto(). */
X    if (min_distance < 0 &&
X		!enexto(stopp, u.ux, u.uy, &mons[PM_MAIL_DAEMON]))
X	return FALSE;
X
X    return TRUE;
X}
X
X/* Let the mail daemon have a larger vocabulary. */
Xstatic const char NEARDATA *mail_text[] = {
X    "Gangway!",
X    "Look out!",
X    "Pardon me!"
X};
X#define md_exclamations()	(mail_text[rn2(3)])
X
X/*
X * Make the mail daemon run through the dungeon.  The daemon will run over
X * any monsters that are in its path, but will replace them later.  Return
X * FALSE if the md gets stuck in a position where there is a monster.  Return
X * TRUE otherwise.
X */
Xstatic boolean
Xmd_rush(md,tx,ty)
X    struct monst *md;
X    register int tx, ty;		/* destination of mail daemon */
X{
X    struct monst *mon;			/* displaced monster */
X    register int dx, dy;		/* direction counters */
X    int fx = md->mx, fy = md->my;	/* current location */
X    int nfx = fx, nfy = fy,		/* new location */ 
X	d1, d2;				/* shortest distances */
X
X    /*
X     * It is possible that the monster at (fx,fy) is not the md when:
X     * the md rushed the hero and failed, and is now starting back.
X     */
X    if (m_at(fx, fy) == md) {
X	remove_monster(fx, fy);		/* pick up from orig position */
X	newsym(fx, fy);
X    }
X
X    /*
X     * At the beginning and exit of this loop, md is not placed in the
X     * dungeon.
X     */
X    while (1) {
X	/* Find a good location next to (fx,fy) closest to (tx,ty). */
X	d1 = dist2(fx,fy,tx,ty);
X	for (dx = -1; dx <= 1; dx++) for(dy = -1; dy <= 1; dy++)
X	    if ((dx || dy) && isok(fx+dx,fy+dy) && 
X				       !IS_STWALL(levl[fx+dx][fy+dy].typ)) {
X		d2 = dist2(fx+dx,fy+dy,tx,ty);
X		if (d2 < d1) {
X		    d1 = d2;
X		    nfx = fx+dx;
X		    nfy = fy+dy;
X		}
X	    }
X
X	/* Break if the md couldn't find a new position. */
X	if (nfx == fx && nfy == fy) break;
X
X	fx = nfx;			/* this is our new position */
X	fy = nfy;
X
X	/* Break if the md reaches its destination. */
X	if (fx == tx && fy == ty) break;
X
X	if ((mon = m_at(fx,fy)) != 0)	/* save monster at this position */
X	    verbalize(md_exclamations());
X	else if (fx == u.ux && fy == u.uy)
X	    verbalize("Excuse me.");
X
X	place_monster(md,fx,fy);	/* put md down */
X	newsym(fx,fy);			/* see it */
X	flush_screen(0);		/* make sure md shows up */
X	delay_output();			/* wait a little bit */
X
X	/* Remove md from the dungeon.  Restore original mon, if necessary. */
X	if (mon) {
X	    if ((mon->mx != fx) || (mon->my != fy))
X		place_worm_seg(mon, fx, fy);
X	    else
X		place_monster(mon, fx, fy);
X	} else
X	    remove_monster(fx, fy);
X	newsym(fx,fy);
X    }
X
X    /*
X     * Check for a monster at our stopping position (this is possible, but
X     * very unlikely).  If one exists, then have the md leave in disgust.
X     */
X    if ((mon = m_at(fx, fy)) != 0) {
X	place_monster(md, fx, fy);	/* display md with text below */
X	newsym(fx, fy);
X	verbalize("This place's too crowded.  I'm outta here.");
X
X	if ((mon->mx != fx) || (mon->my != fy))	/* put mon back */
X	    place_worm_seg(mon, fx, fy);
X	else
X	    place_monster(mon, fx, fy);
X
X	newsym(fx, fy);
X	return FALSE;
X    }
X
X    place_monster(md, fx, fy);	/* place at final spot */
X    newsym(fx, fy);
X    flush_screen(0);
X    delay_output();			/* wait a little bit */
X
X    return TRUE;
X}
X
X/* Deliver a scroll of mail. */
X/*ARGSUSED*/
Xstatic void
Xnewmail(info)
Xstruct mail_info *info;
X{
X    struct monst *md;
X    coord start, stop;
X    boolean message_seen = FALSE;
X
X    /* Try to find good starting and stopping places. */
X    if (!md_start(&start) || !md_stop(&stop,&start)) goto give_up;
X
X    /* Make the daemon.  Have it rush towards the hero. */
X    if (!(md = makemon(&mons[PM_MAIL_DAEMON], start.x, start.y))) goto give_up;
X    if (!md_rush(md, stop.x, stop.y)) goto go_back;
X
X    message_seen = TRUE;
X# ifdef NO_MAILREADER
X    verbalize("Hello, %s!  You have some mail in the outside world.", plname);
X# else
X    verbalize("Hello, %s!  %s.", plname, info->display_txt);
X
X    if (info->message_typ) {
X	struct obj *obj = mksobj(SCR_MAIL, FALSE, FALSE);
X	if (distu(md->mx,md->my) > 2)
X	    verbalize("Catch!");
X	display_nhwindow(WIN_MESSAGE, FALSE);
X	if (info->object_nam) {
X	    obj = oname(obj, info->object_nam, FALSE);
X	    if (info->response_cmd) {	/*(hide extension of the obj name)*/
X		int namelth = info->response_cmd - info->object_nam - 1;
X		if ( namelth <= 0 || namelth >= (int) obj->onamelth )
X		    impossible("mail delivery screwed up");
X		else
X		    *(ONAME(obj) + namelth) = '\0';
X		/* Note: renaming object will discard the hidden command. */
X	    }
X	}
X	obj = hold_another_object(obj, "Oops!",
X				  (const char *)0, (const char *)0);
X    }
X# endif /* NO_MAILREADER */
X
X    /* zip back to starting location */
Xgo_back:
X    (void) md_rush(md, start.x, start.y);
X    mongone(md);
X    /* deliver some classes of messages even if no daemon ever shows up */
Xgive_up:
X    if (!message_seen && info->message_typ == MSG_OTHER)
X	pline("Hark!  \"%s.\"", info->display_txt);
X}
X
X#endif /* OVLB */
X
X# if !defined(UNIX) && !defined(VMS)
X
X#ifdef OVL0
X
Xvoid
Xckmailstatus()
X{
X	if (u.uswallow) return;
X	if (mustgetmail < 0) {
X#ifdef AMIGA
X	    mustgetmail=(moves<2000)?(100+rn2(2000)):(2000+rn2(3000));
X#endif
X	    return;
X	}
X	if (--mustgetmail <= 0) {
X		static struct mail_info
X			deliver = {MSG_MAIL,"I have some mail for you",0,0};
X		newmail(&deliver);
X		mustgetmail = -1;
X	}
X}
X
X#endif /* OVL0 */
X#ifdef OVLB
X
X/*ARGSUSED*/
Xvoid
Xreadmail(otmp)
Xstruct obj *otmp;
X{
X#ifdef AMIGA
X	char *junk[]={
X	"It reads:  \"Please disregard previous letter.\"",
X	"It reads:  \"Welcome to NetHack 3.1!\"",
X	"It reads:  \"Only Amiga makes it possible.\"",
X	"It reads:  \"CATS have all the answers.\"",
X	"It reads:  \"Report bugs to nethack-bugs@linc.cis.upenn.edu\""
X	};
X
X	pline(junk[rn2(SIZE(junk))]);
X#else
X	pline("It reads:  \"Please disregard previous letter.\"");
X#endif
X}
X
X#endif /* OVLB */
X
X# endif /* !UNIX && !VMS */
X
X# ifdef UNIX
X
X#ifdef OVL0
X
Xvoid
Xckmailstatus()
X{
X	if(!mailbox || u.uswallow
X#  ifdef MAILCKFREQ
X		    || moves < laststattime + MAILCKFREQ
X#  endif
X							)
X		return;
X
X	laststattime = moves;
X	if(stat(mailbox, &nmstat)){
X#  ifdef PERMANENT_MAILBOX
X		pline("Cannot get status of MAIL=\"%s\" anymore.", mailbox);
X		mailbox = 0;
X#  else
X		nmstat.st_mtime = 0;
X#  endif
X	} else if(nmstat.st_mtime > omstat.st_mtime) {
X		if(nmstat.st_size) {
X			static struct mail_info
X			    deliver = {MSG_MAIL,"I have some mail for you",0,0};
X			newmail(&deliver);
X		}
X		getmailstatus();	/* might be too late ... */
X	}
X}
X
X#endif /* OVL0 */
X
X#ifdef OVLB
X
X/*ARGSUSED*/
Xvoid
Xreadmail(otmp)
Xstruct obj *otmp;
X{
X#  ifdef DEF_MAILREADER			/* This implies that UNIX is defined */
X	register const char *mr = 0;
X
X	display_nhwindow(WIN_MESSAGE, FALSE);
X	if(!(mr = getenv("MAILREADER")))
X		mr = DEF_MAILREADER;
X
X	if(child(1)){
X		(void) execl(mr, mr, NULL);
X		terminate(1);
X	}
X#  else
X#   ifndef AMS  			/* AMS mailboxes are directories */
X	display_file(mailbox, TRUE);
X#   endif /* AMS */
X#  endif /* DEF_MAILREADER */
X
X	/* get new stat; not entirely correct: there is a small time
X	   window where we do not see new mail */
X	getmailstatus();
X}
X
X#endif /* OVLB */
X
X# endif /* UNIX */
X
X# ifdef VMS
X
X#ifdef OVL0
X
Xvolatile int broadcasts = 0;
X
Xvoid
Xckmailstatus()
X{
X    struct mail_info *brdcst, *parse_next_broadcast();
X
X    if(u.uswallow) return;
X
X    while (broadcasts > 0) {	/* process all trapped broadcasts [until] */
X	broadcasts--;
X	if ((brdcst = parse_next_broadcast()) != 0) {
X	    newmail(brdcst);
X	    break;		/* only handle one real message at a time */
X	}
X    }
X}
X
X#endif /* OVL0 */
X
X#ifdef OVLB
X
Xvoid
Xreadmail(otmp)
Xstruct obj *otmp;
X{
X#  ifdef SHELL	/* can't access mail reader without spawning subprocess */
X    char *p, *cmd, buf[BUFSZ], qbuf[BUFSZ];
X
X    /* there should be a command hidden beyond the object name */
X    p = otmp->onamelth ? ONAME(otmp) : "";
X    cmd = (strlen(p) + 1 < otmp->onamelth) ? eos(p) + 1 : (char *) 0;
X    if (!cmd || !*cmd) cmd = "SPAWN";
X
X    Sprintf(qbuf, "System command (%s)", cmd);
X    getlin(qbuf, buf);
X    clear_nhwindow(WIN_MESSAGE);
X    if (*buf != '\033') {
X	for (p = eos(buf); p > buf; *p = '\0')
X	    if (*--p != ' ') break;	/* strip trailing spaces */
X	if (*buf) cmd = buf;		/* use user entered command */
X	if (!strcmpi(cmd, "SPAWN") || !strcmp(cmd, "!"))
X	    cmd = (char *) 0;		/* interactive escape */
X
X	vms_doshell(cmd, TRUE);
X	(void) sleep(1);
X    }
X#  endif /* SHELL */
X}
X
X#endif /* OVLB */
X
X# endif /* VMS */
X
X#endif /* MAIL */
X
X/*mail.c*/
END_OF_FILE
if test 14946 -ne `wc -c <'src/mail.c'`; then
    echo shar: \"'src/mail.c'\" unpacked with wrong size!
fi
# end of 'src/mail.c'
fi
if test -f 'sys/mac/macwin.c1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/mac/macwin.c1'\"
else
echo shar: Extracting \"'sys/mac/macwin.c1'\" \(39944 characters\)
sed "s/^X//" >'sys/mac/macwin.c1' <<'END_OF_FILE'
X/*	SCCS Id: @(#)macwin.c	3.1	93/01/24		  */
X/* Copyright (c) Jon W{tte, Hao-Yang Wang, Jonathan Handler 1992. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X/*
X * macwin.c
X */
X
X/*
X * I have to quote X11R5:
X *
X *  "If you think you know what this code is doing, you're probably wrong.
X *   Here be serious and nasty dragons."
X *
X * h+ 92-09-26
X */
X
X#include "hack.h"
X#include "func_tab.h"
X
X#include <osutils.h>
X#include <dialogs.h>
X#include <textedit.h>
X#include <menus.h>
X#ifndef MAC_THINKC5
X#include <sysequ.h>
X#endif
X#include <resources.h>
X#include <desk.h>
X#include <gestaltequ.h>
X#include <balloons.h>
X#include <toolutils.h>
X#include <script.h>
X#include <OSEvents.h>
X#include <Packages.h>
X#include <Sound.h>
X#include <DiskInit.h>
X
XNhWindow * theWindows = (NhWindow *) NULL ;
X
X/*
X * Some useful #defines for the scroll bar width and height
X */
X#define		SBARWIDTH	15
X#define		SBARHEIGHT	14
X
X/*
X * We put a TE on the message window for the "top line" queries.
X * top_line is the TE that holds both the query and the user's
X * response.  The first topl_query_len characters in top_line are
X * the query, the rests are the response.  topl_resp is the valid
X * response to a yn query, while topl_resp[topl_def_idx] is the
X * default response to a yn query.
X */
XTEHandle top_line = nil;
Xint		 topl_query_len;
Xint		 topl_def_idx = -1;
Xchar	 topl_resp[10] = "";
X
X#define CHAR_ANY '\n'
X
X/*
X * inSelect means we have a menu window up for selection or
X * something similar. It makes the window with win number ==
X * inSelect a movable modal (unfortunately without the border)
X * and clicking the close box forces an ESC into the key
X * buffer. Don't forget to set inSelect to WIN_ERR when you're
X * done...
X */
Xwinid inSelect = WIN_ERR ;
X
X/*
X * The key queue - contains 0 for unused or an ascii value.
X * When getting keys, take the first value and shift the
X * queue, shifting in a 0.
X */
X#define QUEUE_LEN 24
Xstatic int keyQueue [ QUEUE_LEN ] ;
X
XBoolean gClickedToMove = 0 ; /* For ObscureCursor */
X
X
X/*
X * Add key to input queue, force means replace last if full
X */
Xvoid
XaddToKeyQueue ( int ch , Boolean force )
X{
X	int i ;
X
X	for ( i = 0 ; i < QUEUE_LEN ; i ++ ) {
X
X		if ( ! keyQueue [ i ] ) {
X
X			keyQueue [ i ] = ch ;
X			return ;
X		}
X	}
X	if ( force ) {
X
X		keyQueue [ QUEUE_LEN - 1 ] = ch ;
X	}
X}
X
X
X/*
X * Cursor movement
X */
XRgnHandle gMouseRgn = NULL ;
X
X/*
X * _Gestalt madness - we rely heavily on the _Gestalt glue, since we
X * don't check for the trap...
X */
XMacFlags macFlags ;
X
X/*
X * Async flag for keeping track of scrollbars...
X * Used by InvalScrollBar ( )
X */
Xstatic NhWindow * asyDSC = (NhWindow *) NULL ;
X
X/*
X * The font to be used in the text window
X */
Xshort text_wind_font = geneva;
X
X/*
X * Whether to adjust the height of a text window according to its contents
X */
Xboolean full_screen = FALSE;
X
Xchar macPad = 1 ;
X
XHandle mBar ;
XMenuHandle appleMenu ;
XMenuHandle fileMenu ;
XMenuHandle editMenu ;
XMenuHandle extendMenu ;
XMenuHandle miscMenu ;
XMenuHandle helpMenu ;
XMenuHandle commandsMenu ;
XMenuHandle thingsMenu ;
X
X#define NHW_BASE 0
Xwinid BASE_WINDOW ; // Was: , WIN_MAP , WIN_MESSAGE , WIN_INVEN , WIN_STATUS ;
X
Xvoid NDECL(port_help);
X
Xint NDECL(SanePositions);
XBoolean FDECL(RetrieveWinPos, (WindowPtr,short *,short *));
Xvoid NDECL ( InitMac ) ;
Xvoid NDECL(InitRes);
Xvoid FDECL(GeneralKey, ( EventRecord * theEvent , WindowPtr theWindow ));
Xvoid FDECL(HandleKey, ( EventRecord * theEvent ));
Xvoid FDECL(HandleClick, ( EventRecord * theEvent ));
Xvoid FDECL(HandleUpdate, ( EventRecord * theEvent ));
Xvoid FDECL(HandleEvent, ( EventRecord * theEvent ));
Xvoid NDECL(DimMenuBar);
Xvoid NDECL(UndimMenuBar);
Xint FDECL(filter_scroll_key,(const int, NhWindow *));
X
Xvoid SetFrameItem ( DialogPtr , short , short ) ;
Xvoid FlashButton ( DialogPtr , short ) ;
X
Xvoid trans_num_keys ( EventRecord * ) ;
X
X#ifndef MAC_THINKC5
X/*
X * Why aren't these declared when including hack.h - I thought
X * they were...
X */
Xvoid FDECL(putsym, ( winid win , int x , int y , CHAR_P sym ));
X#endif
X
X#define NUM_FUNCS 6
Xstatic void FDECL(macKeyNull, ( EventRecord * , WindowPtr )) ;
Xstatic void FDECL(macKeyMessage, ( EventRecord * , WindowPtr )) ;
Xstatic void FDECL(macKeyStatus, ( EventRecord * , WindowPtr )) ;
Xstatic void FDECL(macKeyMap, ( EventRecord * , WindowPtr )) ;
Xstatic void FDECL(macKeyMenu, ( EventRecord * , WindowPtr )) ;
Xstatic void FDECL(macKeyText, ( EventRecord * , WindowPtr )) ;
X
Xstatic void FDECL(macClickNull, ( EventRecord * , WindowPtr )) ;
Xstatic void FDECL(macClickMessage, ( EventRecord * , WindowPtr )) ;
Xstatic void FDECL(macClickStatus, ( EventRecord * , WindowPtr )) ;
Xstatic void FDECL(macClickMap, ( EventRecord * , WindowPtr )) ;
Xstatic void FDECL(macClickMenu, ( EventRecord * , WindowPtr )) ;
Xstatic void FDECL(macClickText, ( EventRecord * , WindowPtr )) ;
X
Xstatic void FDECL(macUpdateNull, ( EventRecord * , WindowPtr )) ;
Xstatic void FDECL(macUpdateMessage, ( EventRecord * , WindowPtr )) ;
Xstatic void FDECL(macUpdateStatus, ( EventRecord * , WindowPtr )) ;
Xstatic void FDECL(macUpdateMap, ( EventRecord * , WindowPtr )) ;
Xstatic void FDECL(macUpdateMenu, ( EventRecord * , WindowPtr )) ;
Xstatic void FDECL(macUpdateText, ( EventRecord * , WindowPtr )) ;
X
Xstatic void FDECL(macCursorNull, ( EventRecord * , WindowPtr , RgnHandle )) ;
Xstatic void FDECL(macCursorMessage, ( EventRecord * , WindowPtr , RgnHandle )) ;
Xstatic void FDECL(macCursorStatus, ( EventRecord * , WindowPtr , RgnHandle )) ;
Xstatic void FDECL(macCursorMap, ( EventRecord * , WindowPtr , RgnHandle )) ;
Xstatic void FDECL(macCursorMenu, ( EventRecord * , WindowPtr , RgnHandle )) ;
Xstatic void FDECL(macCursorText, ( EventRecord * , WindowPtr , RgnHandle )) ;
X
Xstatic void NDECL(UpdateMenus);
Xstatic void FDECL(DoMenu, (long choise));
X
Xstatic void FDECL (DrawScrollbar, ( NhWindow * , WindowPtr ));
Xstatic void FDECL (InvalScrollBar, ( NhWindow * ));
Xstatic void FDECL(DrawMapCursor,(NhWindow *));
Xstatic void FDECL(DoScrollBar,(Point, short, ControlHandle, NhWindow *, WindowPtr));
Xstatic pascal void FDECL(Up, (ControlHandle, short));
Xstatic pascal void FDECL(Down,(ControlHandle, short));
X
Xtypedef void ( * CbFunc ) ( EventRecord * , WindowPtr ) ;
Xtypedef void ( * CbCursFunc ) ( EventRecord * , WindowPtr , RgnHandle ) ;
X
XCbFunc winKeyFuncs [ NUM_FUNCS ] = {
X	macKeyNull , macKeyMessage , macKeyStatus , macKeyMap , macKeyMenu , macKeyText
X} ;
X
XCbFunc winClickFuncs [ NUM_FUNCS ] = {
X	macClickNull , macClickMessage , macClickStatus , macClickMap , macClickMenu ,
X	macClickText
X} ;
X
XCbFunc winUpdateFuncs [ NUM_FUNCS ] = {
X	macUpdateNull , macUpdateMessage , macUpdateStatus , macUpdateMap ,
X	macUpdateMenu , macUpdateText
X} ;
X
XCbCursFunc winCursorFuncs [ NUM_FUNCS ] = {
X	macCursorNull , macCursorMessage , macCursorStatus , macCursorMap ,
X	macCursorMenu , macCursorText
X} ;
X
X#ifdef applec
X  extern void _DataInit();
X  /* This routine is part of the MPW runtime library. This external
X	 reference to it is done so that we can unload its segment, %A5Init,
X	 and recover c 250K of memory */
X#endif
X
X
Xvoid
XInitMac( void )
X{
X	int i ;
X	long l ;
X
X#ifdef applec
X	UnloadSeg((Ptr) _DataInit);
X#endif
X
X	SetApplLimit ( 
X					( void * ) 
X					( 
X					( ( long ) GetApplLimit() ) - 40 * 1024L 
X					) 
X				 ) ;
X	MaxApplZone ( ) ;
X	for ( i = 0 ; i < 5 ; i ++ )
X		MoreMasters ( ) ;
X
X	InitGraf ( & qd . thePort ) ;
X	InitFonts ( ) ;
X	InitWindows ( ) ;
X	InitMenus ( ) ;
X	InitDialogs ( ( ResumeProcPtr ) 0L ) ;
X	TEInit ( ) ;
X	InitSegMgmt( itworked );	/* itworked is always in the main segment */
X	
X	attemptingto("start up");
X	
X	if ( Gestalt ( gestaltOSAttr , & l ) ) {
X		macFlags . processes = 0 ;
X		macFlags . tempMem = 0 ;
X	} else {
X		macFlags . processes = ( l & ( 1 << gestaltLaunchControl ) ) ? 1 : 0 ;
X		macFlags . tempMem = ( l & ( 1 << gestaltRealTempMemory ) ) ? 1 : 0 ;
X	}
X	if ( Gestalt ( gestaltQuickdrawVersion , & l ) ) {
X		macFlags . color = 0 ;
X	} else {
X		macFlags . color = ( l >= gestalt8BitQD ) ? 1 : 0 ;
X	}
X	if ( Gestalt ( gestaltFindFolderAttr , & l ) ) {
X		macFlags . folders = 0 ;
X	} else {
X		macFlags . folders = ( l & ( 1 << gestaltFindFolderPresent ) ) ? 1 : 0 ;
X	}
X	if ( Gestalt ( gestaltHelpMgrAttr , & l ) ) {
X		macFlags . help = 0 ;
X	} else {
X		macFlags . help = ( l & ( 1 << gestaltHelpMgrPresent ) ) ? 1 : 0 ;
X	}
X	if ( Gestalt ( gestaltFSAttr , & l ) ) {
X		macFlags . fsSpec = 0 ;
X	} else {
X		macFlags . fsSpec = ( l & ( 1 << gestaltHasFSSpecCalls ) ) ? 1 : 0 ;
X	}
X	if ( Gestalt ( gestaltFontMgrAttr , & l ) ) {
X		macFlags . trueType = 0 ;
X	} else {
X		macFlags . trueType = ( l & ( 1 << gestaltOutlineFonts ) ) ? 1 : 0 ;
X	}
X	if ( Gestalt ( gestaltAUXVersion , & l ) ) {
X		macFlags . aux = 0 ;
X	} else {
X		macFlags . aux = ( l >= 0x200 ) ? 1 : 0 ;
X	}
X	if ( Gestalt ( gestaltAliasMgrAttr , & l ) ) {
X		macFlags . alias = 0 ;
X	} else {
X		macFlags . alias = ( l & ( 1 << gestaltAliasMgrPresent ) ) ? 1 : 0 ;
X	}
X	if ( Gestalt ( gestaltStandardFileAttr , & l ) ) {
X		macFlags . standardFile = 0 ;
X	} else {
X		macFlags . standardFile = ( l & ( 1 << gestaltStandardFile58 ) ) ? 1 : 0 ;
X	}
X
X	gMouseRgn = NewRgn ( ) ;
X}
X
X
X#define MAX_HEIGHT 200
X#define MIN_HEIGHT 50
X#define MIN_WIDTH 300
X
X/*
X * This function could be overloaded with any amount of
X * intelligence...
X */
Xint
XSanePositions ( void )
X{
X	short mainTop , mainLeft , mainWidth , mainHeight ;
X	short statTop , statLeft , statWidth , statHeight ;
X	short mesgTop , mesgLeft , mesgWidth , mesgHeight ;
X	short left , top , width , height ;
X	short ix , numText = 0 , numMenu = 0 ;
X	Rect screenArea ;
X	WindowPtr theWindow ;
X	NhWindow * nhWin ;
X
X	screenArea = qd . thePort -> portBits . bounds ;
X	OffsetRect ( & screenArea , - screenArea . left , - screenArea . top ) ;
X
X/* Map Window */
X	nhWin = theWindows + WIN_MAP ;
X	theWindow = nhWin -> theWindow ;
X
X	height = nhWin -> charHeight * NUM_ROWS ;
X	width = nhWin -> charWidth * NUM_COLS ;
X
X	if ( ! RetrievePosition ( kMapWindow , & top , & left ) ) {
X		top = GetMBarHeight ( ) * 2 ;
X		left = ( screenArea . right - width ) / 2 ;
X	}
X
X	mainTop = top ;
X	mainLeft = left ;
X	mainHeight = height ;
X	mainWidth = width ;
X
X/* Status Window */
X	nhWin = theWindows + WIN_STATUS ;
X	theWindow = nhWin -> theWindow ;
X
X	height = nhWin -> charHeight * NUM_STAT_ROWS ;
X
X	if ( ! RetrievePosition ( kStatusWindow , & top , & left ) ) {
X		top = mainTop + mainHeight + 2 ;
X		left = mainLeft ;
X	}
X
X	if ( top + height > screenArea . bottom ) {
X		top = screenArea . bottom - height ;
X		left += 20 ; /* Edge to the right so we can read it */
X	}
X	statTop = top ;
X	statLeft = left ;
X	statHeight = height ;
X	statWidth = width ;
X
X/* Message Window */
X	nhWin = theWindows + WIN_MESSAGE ;
X	theWindow = nhWin -> theWindow ;
X
X	if ( ! RetrievePosition ( kMessageWindow , & top , & left ) ) {
X		top = statTop + statHeight + 20 ;
X		left = statLeft ;
X	}
X
X	if ( ! RetrieveSize ( kMessageWindow , top , left , & height , & width ) ) {
X		height = screenArea . bottom - top - 2 ;
X		if ( height > MAX_HEIGHT ) {
X			height = MAX_HEIGHT ;
X		} else if ( height < MIN_HEIGHT ) {
X			height = MIN_HEIGHT ;
X			width = MIN_WIDTH ;
X			left = screenArea . right - width ;
X			top = screenArea . bottom - MIN_HEIGHT ;
X		}
X	}
X	mesgTop = top ;
X	mesgLeft = left ;
X	mesgHeight = height ;
X	mesgWidth = width ;
X
X/* Move these windows */
X	MoveWindow ( theWindows [ WIN_STATUS ] . theWindow , statLeft , statTop , 1 ) ;
X	SizeWindow ( theWindows [ WIN_STATUS ] . theWindow , statWidth , statHeight , 1 ) ;
X	MoveWindow ( theWindows [ WIN_MESSAGE ] . theWindow , mesgLeft , mesgTop , 1 ) ;
X	SizeWindow ( theWindows [ WIN_MESSAGE ] . theWindow , mesgWidth , mesgHeight , 1 ) ;
X	MoveWindow ( theWindows [ WIN_MAP ] . theWindow , mainLeft , mainTop , 1 ) ;
X	SizeWindow ( theWindows [ WIN_MAP ] . theWindow , mainWidth , mainHeight , 1 ) ;
X
X/* Handle other windows */
X	for ( ix = 0 ; ix < NUM_MACWINDOWS ; ix ++ ) {
X		if ( ix != WIN_STATUS && ix != WIN_MESSAGE && ix != WIN_MAP ) {
X			if ( theWindow = theWindows [ ix ] . theWindow ) {
X				if ( ( ( WindowPeek ) theWindow ) -> visible ) {
X					if ( theWindows [ ix ] . kind == NHW_MENU ) {
X						if ( ! RetrievePosition ( kMenuWindow , & top , & left ) ) {
X							top = GetMBarHeight ( ) * 2 ;
X							left = 2 ;
X						}
X						top += ( numMenu * GetMBarHeight ( ) ) ;
X						while ( top > screenArea . bottom - MIN_HEIGHT ) {
X							top -= ( screenArea . bottom - GetMBarHeight ( ) * 2 ) ;
X							left += 20 ;
X						}
X						numMenu ++ ;
X						MoveWindow ( theWindow , left , top , 1 ) ;
X					} else {
X						if ( ! RetrievePosition ( kTextWindow , & top , & left ) ) {
X							top = GetMBarHeight ( ) * 2 ;
X							left = screenArea . right - 3 ;
X						}
X						top += ( numText * GetMBarHeight ( ) ) ;
X						while ( top > screenArea . bottom - MIN_HEIGHT ) {
X							top -= ( screenArea . bottom - GetMBarHeight ( ) * 2 ) ;
X							left -= 20 ;
X						}
X						numText ++ ;
X						MoveWindow ( theWindow , left - ( theWindow -> portRect . right -
X							theWindow -> portRect . left ) , top , 1 ) ;
X					}
X				}
X			}
X		}
X	}
X
X	InitCursor ( ) ;
X
X	return 0 ;
X}
X
X
Xwinid
Xmac_create_nhwindow ( int type )
X{
X	int i ;
X	Rect siz ;
X	NhWindow * aWin ;
X
X	if ( type < NHW_BASE || type > NHW_TEXT ) {
X		error ( "Invalid window type %d in create_nhwindow." , type ) ;
X		return WIN_ERR ;
X	}
X
X	for ( i = 0 ; i < NUM_MACWINDOWS ; i ++ ) {
X		if ( ! theWindows [ i ] . theWindow )
X			break ;
X	}
X	if ( i >= NUM_MACWINDOWS ) {
X		for ( i = 0 ; i < NUM_MACWINDOWS ; i ++ ) {
X			WindowPeek w = ( WindowPeek ) theWindows [ i ] . theWindow ;
X			if ( w -> visible || i == WIN_INVEN || ( w -> windowKind
X				!= NHW_MENU && w -> windowKind != NHW_TEXT ) )
X				continue ;
X			error ( "The window list is getting full, freeing unnecessary window (%d)..." ,
X				i ) ;
X			destroy_nhwindow ( i ) ;
X			goto got1 ;
X		}
X		error ( "Out of window ids in create_nhwindow ! (Max = %d)" ,
X			NUM_MACWINDOWS ) ;
X		return WIN_ERR ;
X	}
X
Xgot1 :
X	aWin = & theWindows [ i ] ;
X	aWin -> theWindow = GetNewWindow ( WIN_BASE_RES + type ,
X		( WindowPtr ) 0L , ( WindowPtr ) -1L ) ;
X	( ( WindowPeek ) aWin -> theWindow ) -> windowKind = WIN_BASE_KIND
X		+ type ;
X	aWin -> windowTextLen = 0L ;
X	aWin -> textBase = 0L ;
X	aWin -> clear = 0 ; /* Yes, we need to inval the area on a clear */
X	aWin -> scrollBar = (ControlHandle) NULL ;
X	switch ( type ) {
X	case NHW_MAP :
X		if ( ! ( aWin -> windowText = NewHandle
X			( sizeof ( MapData ) ) ) ) {
X			error ( "NewHandle failed in create_nhwindow (%ld bytes)" ,
X				( long ) sizeof ( MapData ) ) ;
X			DisposeWindow ( aWin -> theWindow ) ;
X			aWin -> theWindow = (WindowPtr) NULL ;
X			return WIN_ERR ;
X		}
X		break ;
X	case NHW_STATUS :
X		if ( ! ( aWin -> windowText = NewHandle
X			( sizeof ( StatusData ) ) ) ) {
X			error ( "NewHandle failed in create_nhwindow (%ld bytes)" ,
X				( long ) sizeof ( StatusData ) ) ;
X			DisposeWindow ( aWin -> theWindow ) ;
X			aWin -> theWindow = (WindowPtr) NULL ;
X			return WIN_ERR ;
X		}
X		break ;
X	default :
X		if ( ! ( aWin -> windowText = NewHandle ( TEXT_BLOCK ) ) ) {
X			error ( "NewHandle failed in create_nhwindow (%ld bytes)" ,
X				( long ) TEXT_BLOCK ) ;
X			DisposeWindow ( aWin -> theWindow ) ;
X			aWin -> theWindow = (WindowPtr) NULL ;
X			return WIN_ERR ;
X		}
X		break ;
X	}
X
X	clear_nhwindow ( i ) ;
X
X/*HARDCODED*/
X
X	SetPort ( aWin -> theWindow ) ;
X	PenPat ( &qd . black ) ;
X
X	switch ( type ) {
X		case NHW_MAP :
X		case NHW_STATUS :
X			GetFNum ( "\pHackFont", & aWin -> fontNum ) ;
X			aWin -> fontSize = flags.large_font ? 12 : 9 ;
X			break ;
X		case NHW_MESSAGE :
X			GetFNum ( "\pPSHackFont", & aWin -> fontNum ) ;
X			aWin -> fontSize = flags.large_font ? 12 : 9 ;
X			break ;
X		default:
X			aWin -> fontNum = text_wind_font ;
X			aWin -> fontSize = 9 ;
X	}
X
X	TextFont ( aWin -> fontNum ) ; 
X	TextSize ( aWin -> fontSize ) ;
X
X	if (type == NHW_MESSAGE && !top_line) {
X		const Rect out_of_scr = { 10000, 10000, 10100, 10100 };
X		TextFace(bold);
X		top_line = TENew(&out_of_scr, &out_of_scr);
X		TEActivate(top_line);
X		TextFace(normal);
X	}
X
X	{
X		FontInfo fi ;
X		GetFontInfo ( & fi ) ;
X		aWin -> leading = fi . leading / 2 + fi . descent ;
X		aWin -> charHeight = fi . ascent + fi . descent + fi . leading ;
X		aWin -> charWidth = fi . widMax ;
X	}
X	SetPt ( & ( theWindows [ i ] . cursor ) , 0 , 0 ) ;
X
X	aWin -> kind = type ;
X	aWin -> keyFunc = winKeyFuncs [ type ] ;
X	aWin -> clickFunc = winClickFuncs [ type ] ;
X	aWin -> updateFunc = winUpdateFuncs [ type ] ;
X	aWin -> cursorFunc = winCursorFuncs [ type ] ;
X	SetWRefCon ( aWin -> theWindow , ( long ) aWin ) ;
X
X	SetRect ( & siz , 0 , 0 , aWin -> charWidth * NUM_COLS ,
X		aWin -> charHeight * NUM_ROWS ) ;
X	switch ( type ) {
X	case NHW_MAP :
X		OffsetRect ( & siz , 50 , 50 ) ;
X		break ;
X	case NHW_BASE :
X		OffsetRect ( & siz , 20 , 10 ) ;
X		break ;
X	default :
X		siz = aWin -> theWindow -> portRect ;
X		OffsetRect ( & siz , 30 + rn2 ( 20 ) , 250 + rn2 ( 50 ) ) ;
X		break ;
X	}
X	SizeWindow ( aWin -> theWindow , siz . right - siz . left ,
X		siz . bottom - siz . top , FALSE ) ;
X	MoveWindow ( aWin -> theWindow , siz . left , siz . top , FALSE ) ;
X
X	if ( type == NHW_MENU || type == NHW_TEXT ) {
X		Rect r = siz ;
X		Boolean bool ;
X		OffsetRect ( & r , - r . left , - r . top ) ;
X		r . left = r . right - SBARWIDTH ;
X		r . bottom -= SBARHEIGHT ;
X		r . top -= 1 ;
X		r . right += 1 ;
X		bool = ( r . bottom > r . top + 50 ) ;
X		aWin -> scrollBar = NewControl ( aWin -> theWindow , & r , (StringPtr)"" ,
X			bool , 0 , 0 , 0 , 16 , 0L ) ;
X	}
X	aWin -> scrollPos = 0 ;
X	aWin -> cursorDrawn = 0 ;
X
X	return i ;
X}
X
X
Xvoid
XInitRes ( void )
X{
X	Str255 str ;
X
X	mBar = GetNewMBar ( 128 ) ;
X	mustwork(ResError());
X	SetMenuBar ( mBar ) ;
X	
X	appleMenu = GetMHandle ( 128 ) ;
X	mustwork(ResError());
X	AppendMenu ( appleMenu , ( ConstStr255Param ) "\002(-" ) ;
X	AddResMenu ( appleMenu , 'DRVR' ) ;
X
X	fileMenu = GetMHandle ( 129 ) ;
X	mustwork(ResError());
X	editMenu = GetMHandle ( 130 ) ;
X	mustwork(ResError());
X	extendMenu = GetMHandle ( 131 ) ;
X	mustwork(ResError());
X	miscMenu = GetMHandle ( 132 ) ;
X	mustwork(ResError());
X	commandsMenu = GetMHandle ( 133 ) ;
X	mustwork ( ResError ( ) ) ;
X	thingsMenu = GetMHandle ( 134 ) ;
X	mustwork ( ResError ( ) ) ;
X
X	if ( macFlags . help ) {
X		if ( HMGetHelpMenuHandle ( & helpMenu ) ) {
X			helpMenu = (MenuHandle) NULL ;
X		}
X	}
X	if ( helpMenu ) {
X		GetIndString ( str , 128 , 1 ) ;
X		AppendMenu ( helpMenu , str ) ;
X	} else AppendMenu ( appleMenu , str ) ;
X	
X	DrawMenuBar ( ) ;
X
X	return ;
X}
X
X
Xvoid
Xmac_init_nhwindows ( void )
X{
X	int i ;
X
X	InitRes ( ) ;
X
X	theWindows = ( NhWindow * ) NewPtr ( NUM_MACWINDOWS *
X		sizeof ( NhWindow ) ) ;
X	mustwork(MemError());
X
X	for ( i = 0 ; i < NUM_MACWINDOWS ; i ++ ) {
X		theWindows [ i ] . theWindow = (WindowPtr) NULL ;
X	}
X	for ( i = 0 ; i < QUEUE_LEN ; i ++ ) {
X		keyQueue [ i ] = 0 ;
X	}
X
X	BASE_WINDOW = create_nhwindow ( NHW_TEXT ) ;
X    clear_nhwindow(BASE_WINDOW);
X    putstr(BASE_WINDOW, 0, "");
X    putstr(BASE_WINDOW, 0,
X	  "NetHack, Copyright 1985, 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993");
X    putstr(BASE_WINDOW, 0,
X	  "         By Stichting Mathematisch Centrum and M. Stephenson.");
X    putstr(BASE_WINDOW, 0, "         See license for details.");
X    putstr(BASE_WINDOW, 0, "  ");
X    display_nhwindow(BASE_WINDOW, FALSE);
X
X	flags . window_inited = 1 ;
X	DimMenuBar ( ) ;
X}
X
X
Xvoid
Xmac_nhbell ( void )
X{
X	Handle h ;
X
X	if ( h = GetNamedResource ( 'snd ' , "\PNetHack Bell" ) ) {
X
X		HLock ( h ) ;
X		SndPlay ( ( SndChannelPtr ) NULL , h , 0 ) ;
X		ReleaseResource ( h ) ;
X
X	} else {
X
X		SysBeep ( 30 ) ;
X	}
X}
X
X
Xstatic void
XDrawScrollbar ( NhWindow * aWin , WindowPtr theWindow )
X{
X	Rect r2 = theWindow -> portRect ;
X	Rect r = r2 ;
X	Boolean vis ;
X	short val ;
X
X	if ( ! aWin -> scrollBar ) {
X		return ;
X	}
X
X	r2 . left = r2 . right - SBARWIDTH ;
X	r2 . bottom -= SBARHEIGHT ;
X	r2 . right += 1 ;
X	r2 . top -= 1 ;
X	MoveControl ( aWin -> scrollBar , r2 . left , r2 . top ) ;
X	SizeControl ( aWin -> scrollBar , r2 . right - r2 . left ,
X		r2 . bottom - r2 . top ) ;
X	vis = ( r2 . bottom > r2 . top + 50 ) ;
X	if ( vis && ! ( * aWin -> scrollBar ) -> contrlVis ) {
X		ShowControl ( aWin -> scrollBar ) ;
X	} else if ( ! vis && ( * aWin -> scrollBar ) -> contrlVis ) {
X		HideControl ( aWin -> scrollBar ) ;
X	}
X	if ( aWin -> lin ) {
X		short max = aWin -> lin - ( r . bottom - r . top ) / aWin ->
X			charHeight ;
X		if ( max < 0 ) max = 0 ;
X		SetCtlMax ( aWin -> scrollBar , max ) ;
X		if ( max ) HiliteControl ( aWin -> scrollBar , 0 ) ;
X		else HiliteControl ( aWin -> scrollBar , 255 ) ;
X	} else {
X		HiliteControl ( aWin -> scrollBar , 255 ) ;
X	}
X	val = GetCtlValue ( aWin -> scrollBar ) ;
X	if ( val != aWin -> scrollPos ) {
X		InvalRect ( & ( theWindow -> portRect ) ) ;
X		aWin -> scrollPos = val ;
X	}
X	if ( aWin == asyDSC ) {
X		asyDSC = (NhWindow *) NULL ;
X	}
X}
X
X
Xstatic void
XInvalScrollBar ( NhWindow * aWin )
X{
X	if ( asyDSC && asyDSC != aWin ) {
X		SetPort ( asyDSC -> theWindow ) ;
X		DrawScrollbar ( asyDSC , asyDSC -> theWindow ) ;
X	}
X	asyDSC = aWin ;
X}
X
X
Xvoid
Xmac_clear_nhwindow ( winid win )
X{
X	long l ;
X	register char * start , * stop ;
X	WindowPtr theWindow ;
X	NhWindow * aWin = & theWindows [ win ] ;
X
X	if ( win < 0 || win >= NUM_MACWINDOWS ) {
X		error ( "Invalid window %d in clear_nhwindow." , win ) ;
X		return ;
X	}
X	if ( aWin -> clear )
X		return ;
X	theWindow = aWin -> theWindow ;
X	if ( ! theWindow ) {
X		error ( "Unallocated window %d in clear_nhwindow." , win ) ;
X		return ;
X	}
X	SetPort ( theWindow ) ;
X	InvalRect ( & ( theWindow -> portRect ) ) ;
X	switch ( ( ( WindowPeek ) theWindow ) -> windowKind - WIN_BASE_KIND ) {
X	case NHW_MAP :
X		stop = ( char * ) ( ( MapData * ) ( * aWin -> windowText ) )
X			-> map ;
X		start = stop + NUM_COLS * NUM_ROWS ;
X		while ( start > stop ) * -- start = CHAR_BLANK ;
X		break ;
X	case NHW_STATUS :
X		stop = ( char * ) ( ( StatusData * ) ( * aWin -> windowText ) )
X			-> map ;
X		start = stop + NUM_COLS * NUM_STAT_ROWS ;
X		while ( start > stop ) * -- start = CHAR_BLANK ;
X		break ;
X	case NHW_MESSAGE :
X		l = GetHandleSize ( aWin -> windowText ) ;
X		if ( l > TEXT_BLOCK * 2 ) {
X			BlockMove ( * aWin -> windowText + TEXT_BLOCK ,
X				* aWin -> windowText , l - TEXT_BLOCK ) ;
X			SetHandleSize ( aWin -> windowText , l - TEXT_BLOCK ) ;
X			aWin -> windowTextLen -= TEXT_BLOCK ;
X			if ( aWin -> windowTextLen < 0 ) {
X				aWin -> windowTextLen = 0 ;
X			}
X		}
X#if 1
X		aWin->textBase = aWin->windowTextLen;
X#else
X		stop = * aWin -> windowText ;
X		start = stop + aWin -> windowTextLen - 1 ;
X		while ( -- start > stop ) {
X			if ( * start == CHAR_CR || * start == CHAR_LF )
X				break ;
X		}
X		if ( start > stop ) {
X			aWin -> textBase = start - stop + 1 ;
X		} else {
X			aWin -> textBase = 0L ;
X		}
X#endif
X		break ;
X	default :
X		SetHandleSize ( aWin -> windowText , TEXT_BLOCK ) ;
X		aWin -> windowTextLen = 0L ;
X		aWin -> lin = 0 ;
X		aWin -> wid = 0 ;
X		aWin -> scrollPos = 0 ;
X		aWin -> textBase = 0L ;
X		if ( aWin -> scrollBar ) {
X			SetCtlMax ( aWin -> scrollBar , 0 ) ;
X			InvalScrollBar ( aWin ) ;
X		}
X		break ;
X	}
X	SetPt ( & ( aWin -> cursor ) , 0 , 0 ) ;
X	aWin -> clear = 1 ;
X	aWin -> cursorDrawn = 0 ;
X}
X
X
XBoolean
XClosingWindowChar(const int c) {
X	return  c == CHAR_ESC || c == CHAR_BLANK || c == CHAR_LF || c == CHAR_CR ;
X}
X
X
X#define BTN_IND 2
X#define BTN_W	40
X#define BTN_H	(SBARHEIGHT-2)
X
Xstatic void
Xtopl_resp_rect(int resp_idx, Rect *r)
X{
X	r->left	  = (BTN_IND + BTN_W) * resp_idx + BTN_IND;
X	r->right  = r->left + BTN_W;
X	r->bottom = theWindows[WIN_MESSAGE].theWindow->portRect.bottom - 1;
X	r->top	  = r->bottom - BTN_H;
X}
X
X
XBoolean
Xin_topl_mode(void)
X{
X	return top_line &&
X		   (*top_line)->viewRect.left < theWindows[WIN_MESSAGE].theWindow->portRect.right;
X}
X
X
Xvoid
Xenter_topl_mode(char *query)
X{
X	if (!top_line || in_topl_mode())
X		Debugger();
X	(*top_line)->viewRect.left = 0;
X
X	topl_query_len = strlen(query);
X	(*top_line)->selStart = topl_query_len;
X	(*top_line)->selEnd	  = topl_query_len;
X	PtrToXHand(query, (*top_line)->hText, topl_query_len);
X	TECalText(top_line);
X
X	display_nhwindow(WIN_MESSAGE, FALSE);
X	putstr(WIN_MESSAGE, ATR_BOLD, query);
X}
X
X
Xvoid
Xleave_topl_mode(char *answer)
X{
X	int ans_len = (*top_line)->teLength - topl_query_len;
X	NhWindow *aWin = theWindows + WIN_MESSAGE;
X	char tmp[3] = "  ";
X
X	if (!in_topl_mode())
X		Debugger();
X	(*top_line)->viewRect.left += 10000;
X
X	BlockMove(*(*top_line)->hText + topl_query_len, answer, ans_len);
X	answer[ans_len] = '\0';
X
X	if ( aWin -> windowTextLen > 0 &&
X		 ( * aWin -> windowText ) [ aWin -> windowTextLen - 1 ] == CHAR_CR ) {
X		-- aWin -> windowTextLen ;
X		-- aWin -> lin ;
X	}
X	if (strlen(answer) <= 1) {
X		if (answer[0]) tmp[0] = answer[0];
X		putstr(WIN_MESSAGE, ATR_BOLD, tmp);
X	} else
X		putstr(WIN_MESSAGE, ATR_BOLD, answer);
X}
X
X/*
X * TESetSelect flushes out all the pending key strokes.  I hate it.
X */
Xstatic void
Xtopl_set_select(short selStart, short selEnd)
X{
X	TEDeactivate(top_line);
X	(*top_line)->selStart = selStart;
X	(*top_line)->selEnd	  = selEnd;
X	TEActivate(top_line);
X}
X
X
Xstatic void
Xtopl_replace(char *new_ans)
X{
X	topl_set_select(topl_query_len, (*top_line)->teLength);
X	TEDelete(top_line);
X	TEInsert(new_ans, strlen(new_ans), top_line);
X}
X
X
XBoolean
Xtopl_key(unsigned char ch)
X{
X	switch (ch) {
X		case CHAR_ESC:
X			topl_replace("\x1b");
X			return false;
X		case CHAR_ENTER: case CHAR_CR: case CHAR_LF:
X			return false;
X
X		case 0x1f & 'P':
X			nh_doprev_message();
X			return true;
X		case '\x1e'/* up arrow */:
X			topl_set_select(topl_query_len, topl_query_len);
X			return true;
X		case CHAR_BS: case '\x1c'/* left arrow */:
X			if ((*top_line)->selEnd > topl_query_len)
X				TEKey(ch, top_line);
X			return true;
X		default:
X			TEKey(ch, top_line);
X			return true;
X	}
X}
X
X
XBoolean
Xtopl_ext_key(unsigned char ch)
X{
X	switch (ch) {
X		case CHAR_ESC:
X			topl_replace("\x1b");
X			return false;
X		case CHAR_ENTER: case CHAR_CR: case CHAR_LF:
X			return false;
X
X		case 0x1f & 'P':
X			nh_doprev_message();
X			return true;
X		case CHAR_BS:
X			topl_replace("");
X			return true;
X		default: {
X			int com_index = -1, oindex = 0;
X			TEInsert(&ch, 1, top_line);
X			while(extcmdlist[oindex].ef_txt != NULL){
X				if(!strncmpi(*(*top_line)->hText + topl_query_len,
X							 extcmdlist[oindex].ef_txt,
X							 (*top_line)->teLength - topl_query_len))
X					if(com_index == -1) /* No matches yet*/
X					    com_index = oindex;
X					else /* More than 1 match */
X					    com_index = -2;
X				oindex++;
X			}
X			if(com_index >= 0)
X				topl_replace(extcmdlist[com_index].ef_txt);
X			return true;
X		}
X	}
X}
X
X
Xvoid
Xtopl_flash_resp(int resp_idx)
X{
X	long dont_care;
X	Rect frame;
X	SetPort(theWindows[WIN_MESSAGE].theWindow);
X	topl_resp_rect(resp_idx, &frame);
X	InsetRect(&frame, 1, 1);
X	InvertRect(&frame);
X	Delay(GetDblTime() / 2, &dont_care);
X	InvertRect(&frame);
X}
X
X
Xvoid
Xtopl_set_def(int new_def_idx)
X{
X	Rect frame;
X	SetPort(theWindows[WIN_MESSAGE].theWindow);
X	topl_resp_rect(topl_def_idx, &frame);
X	InvalRect(&frame);
X	topl_def_idx = new_def_idx;
X	topl_resp_rect(new_def_idx, &frame);
X	InvalRect(&frame);
X}
X
X
Xvoid
Xtopl_set_resp(char *resp, char def)
X{
X	char *loc;
X	Rect frame;
X	int r_len, r_len1;
X
X	if (!resp) {
X		static char any_str[2] = { CHAR_ANY, '\0' };
X		resp = any_str;
X		def = CHAR_ANY;
X	}
X
X	r_len1 = strlen(resp);
X	r_len  = strlen(topl_resp);
X	if (r_len < r_len1)
X		r_len = r_len1;
X	topl_resp_rect(0, &frame);
X	frame.right = (BTN_IND + BTN_W) * r_len;
X	InvalRect(&frame);
X
X	strcpy(topl_resp, resp);
X	loc = strchr (resp, def);
X	topl_def_idx = loc ? loc - resp : -1;
X}
X
X
Xstatic char
Xtopl_resp_key(char ch)
X{
X	if (strlen(topl_resp) > 0) {
X		char *loc = strchr(topl_resp, ch);
X
X		if (!loc)
X			if (ch == '\x9'/* tab */) {
X				topl_set_def(topl_def_idx <= 0 ? strlen(topl_resp)-1 : topl_def_idx-1);
X				ch = '\0';
X
X			} else if (ch == CHAR_ESC) {
X				loc = strchr(topl_resp, 'q');
X				if (!loc) {
X					loc = strchr(topl_resp, 'n');
X					if (!loc && topl_def_idx >= 0)
X						loc = topl_resp + topl_def_idx;
X				}
X
X			} else if (ch == (0x1f & 'P')) {
X				nh_doprev_message();
X				ch = '\0';
X
X			} else if (topl_def_idx >= 0) {
X				if ( ch == CHAR_ENTER || ch == CHAR_CR || ch == CHAR_LF ||
X					 ch == CHAR_BLANK || topl_resp[topl_def_idx] == CHAR_ANY )
X					loc = topl_resp + topl_def_idx;
X
X				else if (strchr(topl_resp, '#')) {
X					if (digit(ch)) {
X						topl_set_def(strchr(topl_resp, '#') - topl_resp);
X						TEKey(ch, top_line);
X						ch = '\0';
X
X					} else if (topl_resp[topl_def_idx] == '#')
X						if (ch == '\x1e'/* up arrow */) {
X							topl_set_select(topl_query_len, topl_query_len);
X							ch = '\0';
X						} else if (ch == '\x1d'/* right arrow */ ||
X								   ch == '\x1f'/* down arrow */ ||
X								   (ch == CHAR_BS || ch == '\x1c'/* left arrow */) &&
X										(*top_line)->selEnd > topl_query_len) {
X							TEKey(ch, top_line);
X							ch = '\0';
X						}
X				}
X			}
X
X		if (loc) {
X			topl_flash_resp(loc - topl_resp);
X			if (*loc != CHAR_ANY)
X				ch = *loc;
X			TEKey(ch, top_line);
X		}
X	}
X
X	return ch;
X}
X
X
X/*
X * display/select/update the window.
X * If f is true, this window should be "modal" - don't return
X * until presumed seen.
X */
Xvoid
Xmac_display_nhwindow ( winid win , BOOLEAN_P f )
X{
X	WindowPtr theWindow ;
X	NhWindow * aWin = & theWindows [ win ] ;
X
X	if ( win < 0 || win >= NUM_MACWINDOWS ) {
X		error ( "Invalid window %d in display_nhwindow." , win ) ;
X		return ;
X	}
X	theWindow = aWin -> theWindow ;
X	if ( ! theWindow ) {
X		error ( "Unallocated window %d in display_nhwindow." , win ) ;
X		return ;
X	}
X
X	if ( f && inSelect == WIN_ERR && ( win == BASE_WINDOW || win == WIN_MESSAGE ) ) {
X		if ( win == WIN_MESSAGE )
X			topl_set_resp ( NULL , 0 ) ;
X		/* The following piece of code prevents the "-- More --" prompt to be on a new
X		   line by itself.  I comment it out because the result looks ugly to me. */
X#ifdef 0
X		if ( aWin -> windowTextLen > 0 &&
X			 ( * aWin -> windowText ) [ aWin -> windowTextLen - 1 ] == CHAR_CR ) {
X			-- aWin -> windowTextLen ;
X			-- aWin -> lin ;
X		}
X#endif
X		putstr ( win , ATR_INVERSE , "-- More --" ) ;
X	}
X
X	if ( ! ( ( WindowPeek ) theWindow ) -> visible ) {
X		const Rect scr_r   = (*GetGrayRgn())->rgnBBox,
X				   win_ind = { 20, 2, 3, 3 };
X		const Point scr_sz = { scr_r.bottom - scr_r.top, scr_r.right - scr_r.left },
X					wp_sz  = { theWindow->portRect.bottom - theWindow->portRect.top,
X							   theWindow->portRect.right  - theWindow->portRect.left };
X		const short max_h = scr_sz.v - win_ind.top	- win_ind.bottom,
X					max_w = scr_sz.h - win_ind.left - win_ind.right;
X		const char cr = CHAR_CR;
X
X		long line_start = 0, line_end;
X		short w = wp_sz.h,
X			  h = full_screen ? aWin->lin * aWin->charHeight : wp_sz.v;
X		Point pos = { theWindow->portRect.top, theWindow->portRect.left };
X		SetPort(theWindow);
X		LocalToGlobal(&pos);
X
X		HLock(aWin->windowText);
X		while (line_start < aWin->windowTextLen) {
X			short line_w;
X			line_end = Munger(aWin->windowText, line_start, &cr, 1, nil, 0);
X			if (line_end < 0)
X				line_end = aWin->windowTextLen;
X			line_w = TextWidth(*aWin->windowText, line_start, line_end - line_start) +
X					 (SBARWIDTH + 2);
X			if (w < line_w)
X				w = line_w;
X			line_start = line_end + 1;
X		}
X		HUnlock(aWin->windowText);
X
X		if (h > max_h) h = max_h;
X		if (w > max_w) w = max_w;
X		SizeWindow(theWindow, w, h, FALSE);
X
X		if ( ! ( ( WindowPeek ) theWindow ) -> visible ) {
X			short top , left ;
X			if ( ! RetrieveWinPos ( theWindow , & top , & left ) ) {
X				if (pos.v + h + win_ind.bottom > scr_r.bottom)
X					pos.v = scr_r.bottom - h - win_ind.bottom;
X				if (pos.h + w + win_ind.right  > scr_r.right)
X					pos.h = scr_r.right	 - w - win_ind.right;
X				top = pos . v ;
X				left = pos . h ;
X			}
X			MoveWindow(theWindow, left, top, FALSE);
X		}
X
X		SelectWindow ( theWindow ) ;
X		ShowWindow ( theWindow ) ;
X	}
X
X	SetPort ( theWindow ) ;
X	if ( aWin -> scrollBar ) {
X		InvalScrollBar ( aWin ) ;
X	}
X
X	if ( f && inSelect == WIN_ERR ) {
X		int ch ;
X
X		inSelect = win ;
X		do {
X			ch = nhgetch ( ) ;
X		} while ( ! ClosingWindowChar ( ch ) ) ;
X		inSelect = WIN_ERR ;
X
X		if ( win == WIN_MESSAGE )
X			topl_set_resp ( "" , '\0' ) ;
X		else
X			HideWindow ( theWindow ) ;
X
X	} else {
X		wait_synch ( ) ;
X	}
X}
X
X
Xvoid
Xmac_destroy_nhwindow ( winid win )
X{
X	WindowPtr theWindow ;
X	NhWindow * aWin = & theWindows [ win ] ;
X	int kind , visible ;
X
X	if ( win < 0 || win >= NUM_MACWINDOWS ) {
X		if ( flags . window_inited )
X			error ( "Invalid window number %d (Max %d) in destroy_nhwindow." ,
X				win , NUM_MACWINDOWS ) ;
X		return ;
X	}
X	theWindow = aWin -> theWindow ;
X	if ( ! theWindow ) {
X		error ( "Not allocated window number %d in destroy_nhwindow." ,
X			win ) ;
X		return ;
X	}
X
X	/*
X	 * Check special windows.
X	 * The base window should never go away.
X	 * The other "standard" windows should not go away
X	 * unless we've exitted nhwindows.
X	 */
X	if ( win == BASE_WINDOW ) {
X		return ;
X	}
X	if ( win == WIN_INVEN || win == WIN_STATUS || win == WIN_MAP ||
X		win == WIN_MESSAGE ) {
X		if ( flags . window_inited ) {
X			if ( flags . tombstone && killer ) {
X				/* Prepare for the coming of the tombstone window. */
X				mono_font ( ) ;
X				full_screen = TRUE ;
X			}
X			return ;
X		}
X	}
X
X	kind = ( ( WindowPeek ) theWindow ) -> windowKind - WIN_BASE_KIND ;
X	visible = ( ( WindowPeek ) theWindow ) -> visible ;
X
X	if ( ! visible || ( kind != NHW_MENU && kind != NHW_TEXT ) ) {
X		DisposeWindow ( theWindow ) ;
X		if ( aWin -> windowText ) {
X			DisposHandle ( aWin -> windowText ) ;
X		}
X		aWin -> theWindow = (WindowPtr) NULL ;
X		aWin -> windowText = (Handle) NULL ;
X	}
X}
X
X
Xvoid
Xmac_number_pad ( int pad )
X{
X	macPad = pad ;
X}
X
X
Xvoid
Xtrans_num_keys(EventRecord *theEvent)
X{
X	if (macPad) {
X		Handle h = GetResource('Nump', theEvent->modifiers & shiftKey ? 129 : 128);
X		if (h) {
X			short *ab = (short *)*h;
X			int i = ab[0];
X			while (i) {
X				if ((theEvent->message & keyCodeMask) == (ab[i] & keyCodeMask)) {
X					theEvent->message = ab[i];
X					break;
X				}
X				--i;
X			}
X		}
X	}
X}
X
X
X/*
X * Note; theWindow may very well be NULL here, since keyDown may call
X * it when theres no window !!!
X */
Xvoid
XGeneralKey ( EventRecord * theEvent , WindowPtr theWindow )
X{
X	int i ;
X
X	trans_num_keys ( theEvent ) ;
X
X	addToKeyQueue ( topl_resp_key ( theEvent -> message & 0xff ) , 1 ) ;
X}
X
X
Xstatic void
XmacKeyNull ( EventRecord * theEvent , WindowPtr theWindow )
X{
X	GeneralKey ( theEvent , theWindow ) ;
X}
X
X
Xstatic void
XmacKeyMessage ( EventRecord * theEvent , WindowPtr theWindow )
X{
X	GeneralKey ( theEvent , theWindow ) ;
X}
X
X
Xstatic void
XmacKeyStatus ( EventRecord * theEvent , WindowPtr theWindow )
X{
X	GeneralKey ( theEvent , theWindow ) ;
X}
X
X
Xstatic void
XmacKeyMap ( EventRecord * theEvent , WindowPtr theWindow )
X{
X	GeneralKey ( theEvent , theWindow ) ;
X}
X
X
Xstatic void
XmacKeyMenu ( EventRecord * theEvent , WindowPtr theWindow )
X{
X	if ( filter_scroll_key ( theEvent -> message & 0xff ,
X		( NhWindow * ) GetWRefCon ( theWindow ) ) ) {
X		GeneralKey ( theEvent , theWindow ) ;
X	}
X}
X
X
Xstatic void
XmacKeyText ( EventRecord * theEvent , WindowPtr theWindow )
X{
X	char c = filter_scroll_key ( theEvent -> message & 0xff ,
X								 ( NhWindow * ) GetWRefCon ( theWindow ) ) ;
X	if ( c )
X		if ( inSelect == WIN_ERR && ClosingWindowChar ( c ) ) {
X			HideWindow ( theWindow ) ;
X			destroy_nhwindow ( ( NhWindow * ) GetWRefCon ( theWindow ) - theWindows ) ;
X		} else {
X			GeneralKey ( theEvent , theWindow ) ;
X		}
X}
X
X
Xstatic void
XmacClickNull ( EventRecord * theEvent , WindowPtr theWindow )
X{
X	if ( ! theEvent || ! theWindow ) {
X		Debugger ( ) ;
X	}
X}
X
X
Xstatic void
XmacClickMessage ( EventRecord * theEvent , WindowPtr theWindow )
X{
X	int r_idx = 0;
X	Point mouse = theEvent->where;
X	GlobalToLocal(&mouse);
X	while (topl_resp[r_idx]) {
X		Rect frame;
X		topl_resp_rect(r_idx, &frame);
X		InsetRect(&frame, 1, 1);
X		if (PtInRect(mouse, &frame)) {
X
X			Boolean in_btn = true;
X			InvertRect(&frame);
X			while (WaitMouseUp()) {
X				SystemTask();
X				GetMouse(&mouse);
X				if (PtInRect(mouse, &frame) != in_btn) {
X					in_btn = !in_btn;
X					InvertRect(&frame);
X				}
X			}
X			if (in_btn) {
X				InvertRect(&frame);
X				addToKeyQueue ( topl_resp [ r_idx ] , 1 ) ;
X			}
X			return;
X
X		}
X		++r_idx;
X	}
X}
X
X
Xstatic void
XmacClickStatus ( EventRecord * theEvent , WindowPtr theWindow )
X{
X	if ( ! theEvent || ! theWindow ) {
X		Debugger ( ) ;
X	}
X}
X
X
Xstatic void
XmacClickMap ( EventRecord * theEvent , WindowPtr theWindow )
X{
X	if ( ! theEvent || ! theWindow ) {
X		Debugger ( ) ;
X	}
X	{
X		NhWindow * nhw = ( NhWindow * ) GetWRefCon ( theWindow ) ;
X		Point where ;
X		short posX , posY ;
X		short sector ;
X		char theDirectionChar [ 18 ] = {
X			' ' , 'k' , 'u' , 'l' , 'n' , 'j' , 'b' , 'h' , 'y' ,
X			'o' , 'K' , 'U' , 'L' , 'N' , 'J' , 'B' , 'H' , 'Y' ,
X		} ;
X
X		where = theEvent -> where ;
X		GlobalToLocal ( & where ) ;
X		posX = where . h / nhw -> charWidth ;
X		posY = where . v / nhw -> charHeight ;
X
X	/* 0 is ON, 1 is top, then clockwise */
X		sector = clickSector ( u . ux , u . uy , posX , posY ) ;
X		if ( theEvent -> modifiers & shiftKey ) {
X			sector += 9 ;
X		}
X		addToKeyQueue ( theDirectionChar [ sector ] , 0 ) ;
X
X		gClickedToMove = 1 ;
X	}
X}
X
Xstatic amtToScroll = 0 ;
Xstatic NhWindow * winToScroll = (NhWindow *) NULL ;
X
Xstatic pascal void
XUp ( ControlHandle theBar , short part )
X{
X	EventRecord fake ;
X	short now = GetCtlValue ( theBar ) ;
X	short min = GetCtlMin ( theBar ) ;
X	Rect r ;
X	RgnHandle rgn = NewRgn ( ) ;
X
X	if ( ! part ) {
X		return ;
X	}
X
X	if ( now - min < amtToScroll ) {
X		amtToScroll = now - min ;
X	}
X	if ( ! amtToScroll ) {
X		return ;
X	}
X	SetCtlValue ( theBar , now - amtToScroll ) ;
X	winToScroll -> scrollPos = now - amtToScroll ;
X	r = winToScroll -> theWindow -> portRect ;
X	r . right -= 15 ;
X	ScrollRect ( & r , 0 , amtToScroll * winToScroll -> charHeight , rgn ) ;
X	if ( rgn ) {
X		InvalRgn ( rgn ) ;
X		r . top = r . bottom - 16 ;
X		r . left = r . right ;
X		r . right += 15 ;
X		InvalRect ( & r ) ;
X		BeginUpdate ( winToScroll -> theWindow ) ;
X	}
X	winToScroll -> updateFunc  ( & fake , winToScroll -> theWindow ) ;
X	if ( rgn ) {
X		EndUpdate ( winToScroll -> theWindow ) ;
X		DisposeRgn ( rgn ) ;
X	}
X}
X
X
Xstatic pascal void
XDown ( ControlHandle theBar , short part )
X{
X	EventRecord fake ;
X	short now = GetCtlValue ( theBar ) ;
X	short max = GetCtlMax ( theBar ) ;
X	Rect r ;
X	RgnHandle rgn = NewRgn ( ) ;
X
X	if ( ! part ) {
X		return ;
X	}
X
X	if ( max - now < amtToScroll ) {
X		amtToScroll = max - now ;
X	}
X	if ( ! amtToScroll ) {
X		return ;
X	}
X	SetCtlValue ( theBar , now + amtToScroll ) ;
X	winToScroll -> scrollPos = now + amtToScroll ;
X	r = winToScroll -> theWindow -> portRect ;
X	r . right -= 15 ;
X	ScrollRect ( & r , 0 , - amtToScroll * winToScroll -> charHeight , rgn ) ; 
X	if ( rgn ) {
X		InvalRgn ( rgn ) ;
X		r . top = r . bottom - 16 ;
X		r . left = r . right ;
X		r . right += 15 ;
X		InvalRect ( & r ) ;
X		BeginUpdate ( winToScroll -> theWindow ) ;
X	}
X	winToScroll -> updateFunc  ( & fake , winToScroll -> theWindow ) ;
X	if ( rgn ) {
X		EndUpdate ( winToScroll -> theWindow ) ;
X		DisposeRgn ( rgn ) ;
X	}
X}
X
X
Xstatic void
XDoScrollBar ( Point p , short code , ControlHandle theBar , NhWindow * aWin ,
X	WindowPtr theWindow )
X{
X	pascal void ( * func ) ( ControlHandle , short ) = 0 ;
X
X	winToScroll = aWin ;
X	switch ( code ) {
X	case inUpButton :
X		func = Up ;
X		amtToScroll = 1 ;
X		break ;
X	case inDownButton :
X		func = Down ;
X		amtToScroll = 1 ;
X		break ;
X	case inPageUp :
X		func = Up ;
X		amtToScroll = ( theWindow -> portRect . bottom - theWindow ->
X			portRect . top ) / aWin -> charHeight ;
X		break ;
X	case inPageDown :
X		func = Down ;
X		amtToScroll = ( theWindow -> portRect . bottom - theWindow ->
X			portRect . top ) / aWin -> charHeight ;
X		break ;
X	default :
X		break ;
X	}
X
X	( void ) TrackControl ( theBar , p , ( ProcPtr ) func );
X	if ( ! func ) {
X		if ( aWin -> scrollPos != GetCtlValue ( theBar ) ) {
X			aWin -> scrollPos = GetCtlValue ( theBar ) ;
X			InvalRect ( & ( theWindow -> portRect ) ) ;
X		}
X	}
X}
X
X
Xint
Xfilter_scroll_key(const int ch, NhWindow *aWin)
X{
X	if (aWin->scrollBar && GetCtlValue(aWin->scrollBar) < GetCtlMax(aWin->scrollBar)) {
X		winToScroll = aWin;
X		SetPort(aWin->theWindow);
X		if (ch == CHAR_BLANK) {
X			amtToScroll = ( aWin->theWindow->portRect.bottom
X						  - aWin->theWindow->portRect.top ) / aWin->charHeight;
X			Down(aWin->scrollBar, inPageDown);
X			return 0;
X		}
X		if (ch == CHAR_CR || ch == CHAR_LF) {
X			amtToScroll = 1;
X			Down(aWin->scrollBar, inDownButton);
X			return 0;
X		}
X	}
X	return ch;
X}
X
X
END_OF_FILE
if test 39944 -ne `wc -c <'sys/mac/macwin.c1'`; then
    echo shar: \"'sys/mac/macwin.c1'\" unpacked with wrong size!
fi
# end of 'sys/mac/macwin.c1'
fi
echo shar: End of archive 37 \(of 108\).
cp /dev/null ark37isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \
21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \
41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 \
61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 \
81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 \
101 102 103 104 105 106 107 108 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 108 archives.
    echo "Now execute 'rebuild.sh'"
    rm -f ark10[0-8]isdone ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
