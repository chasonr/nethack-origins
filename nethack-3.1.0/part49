Path: uunet!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v16i057:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Part49/108
Message-ID: <4351@master.CNA.TEK.COM>
Date: 30 Jan 93 01:14:55 GMT
Sender: news@master.CNA.TEK.COM
Lines: 2072
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1606

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 16, Issue 57
Archive-name: nethack31/Part49
Supersedes: nethack3p9: Volume 10, Issue 46-102
Environment: Amiga, Atari, Mac, MS-DOS, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 49 (of 108)."
# Contents:  src/sounds.c sys/os2/Makefile.os2
# Wrapped by billr@saab on Wed Jan 27 16:09:05 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'src/sounds.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/sounds.c'\"
else
echo shar: Extracting \"'src/sounds.c'\" \(17245 characters\)
sed "s/^X//" >'src/sounds.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)sounds.c	3.1	92/07/07
X/* 	Copyright (c) 1989 Janet Walz, Mike Threepoint */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include "hack.h"
X#include "edog.h"
X
X#ifdef OVLB
X
Xstatic int FDECL(domonnoise,(struct monst *));
Xstatic int NDECL(dochat);
X
X#endif /* OVLB */
X
X#ifdef SOUNDS
X
X#ifdef OVL0
X
Xvoid
Xdosounds()
X{
X    register xchar hallu;
X    register struct mkroom *sroom;
X    register int vx, vy;
X#if defined(AMIGA) && defined(AZTEC_C_WORKAROUND)
X    int xx;
X#endif
X
X    hallu = Hallucination ? 1 : 0;
X
X    if(!flags.soundok || u.uswallow || Underwater) return;
X
X    if (level.flags.nfountains && !rn2(400))
X	switch (rn2(3)+hallu) {
X	    case 0:
X		You("hear bubbling water.");
X		break;
X	    case 1:
X		You("hear water falling on coins.");
X		break;
X	    case 2:
X		You("hear the splashing of a naiad.");
X		break;
X	    case 3:
X		You("hear a soda fountain!");
X		break;
X	}
X    if (level.flags.nsinks && !rn2(300))
X	switch (rn2(2)+hallu) {
X	    case 0:
X		You("hear a slow drip.");
X		break;
X	    case 1:
X		You("hear a gurgling noise.");
X		break;
X	    case 2:
X		You("hear dishes being washed!");
X		break;
X	}
X
X    if (level.flags.has_court && !rn2(200)) {
X	switch (rn2(3)+hallu) {
X	    case 0:
X		You("hear the tones of courtly conversation.");
X		break;
X	    case 1:
X		You("hear a sceptre being pounded in judgment.");
X		break;
X	    case 2:
X		pline("Someone just shouted \"Off with %s head!\"",
X		    flags.female ? "her" : "his");
X		break;
X	    case 3:
X		You("hear Queen Beruthiel's cats!");
X		break;
X	}
X	return;
X    }
X    if (level.flags.has_swamp && !rn2(200)) {
X	switch (rn2(2)+hallu) {
X	    case 0:
X		You("hear mosquitoes!");
X		break;
X	    case 1:
X		You("smell marsh gas!");	/* so it's a smell...*/
X		break;
X	    case 2:
X		You("hear Donald Duck!");
X		break;
X	}
X	return;
X    }
X    if (level.flags.has_vault && !rn2(200)) {
X	if (!(sroom = search_special(VAULT))) {
X	    /* strange ... */
X	    level.flags.has_vault = 0;
X	    return;
X	}
X	if(gd_sound())
X	    switch (rn2(2)+hallu) {
X		case 1: {
X		    boolean gold_in_vault = FALSE;
X
X		    for (vx = sroom->lx;vx <= sroom->hx; vx++)
X			for (vy = sroom->ly; vy <= sroom->hy; vy++)
X			    if (g_at(vx, vy))
X				gold_in_vault = TRUE;
X#if defined(AMIGA) && defined(AZTEC_C_WORKAROUND)
X		    /* Bug in aztec assembler here. Workaround below */
X		    xx = ROOM_INDEX(sroom) + ROOMOFFSET;
X		    xx = (xx != vault_occupied(u.urooms));
X		    if(xx)
X#else
X		    if (vault_occupied(u.urooms) != 
X			 (ROOM_INDEX(sroom) + ROOMOFFSET))
X#endif /* AZTEC_C_WORKAROUND */
X		    {
X			if (gold_in_vault)
X			    You(!hallu ? "hear someone counting money." :
X				"hear the quarterback calling the play.");
X			else
X			    You("hear someone searching.");
X			break;
X		    }
X		    /* fall into... (yes, even for hallucination) */
X		}
X		case 0:
X		    You("hear the footsteps of a guard on patrol.");
X		    break;
X		case 2:
X		    You("hear Ebenezer Scrooge!");
X		    break;
X	    }
X	return;
X    }
X    if (level.flags.has_beehive && !rn2(200)) {
X	switch (rn2(2)+hallu) {
X	    case 0:
X		You("hear a low buzzing.");
X		break;
X	    case 1:
X		You("hear an angry drone.");
X		break;
X	    case 2:
X		You("hear bees in your %sbonnet!",
X		    uarmh ? "" : "(nonexistent) ");
X		break;
X	}
X	return;
X    }
X    if (level.flags.has_morgue && !rn2(200)) {
X	switch (rn2(2)+hallu) {
X	    case 0:
X		You("suddenly realize it is unnaturally quiet.");
X		break;
X	    case 1:
X		pline("The hair on the back of your %s stands up.",
X			body_part(NECK));
X		break;
X	    case 2:
X		pline("The hair on your %s seems to stand up.",
X			body_part(HEAD));
X		break;
X	}
X	return;
X    }
X#ifdef ARMY
X    if (level.flags.has_barracks && !rn2(200)) {
X	switch (rn2(3)+hallu) {
X	    case 0:
X		You("hear blades being honed.");
X		break;
X	    case 1:
X		You("hear loud snoring.");
X		break;
X	    case 2:
X		You("hear dice being thrown.");
X		break;
X	    case 3:
X		You("hear General MacArthur!");
X		break;
X	}
X	return;
X    }
X#endif /* ARMY */
X    if (level.flags.has_zoo && !rn2(200)) {
X	switch (rn2(2)+hallu) {
X	    case 0:
X	You("hear a sound reminding you of an elephant stepping on a peanut.");
X		break;
X	    case 1:
X		You("hear a sound reminding you of a trained seal.");
X		break;
X	    case 2:
X		You("hear Doctor Doolittle!");
X		break;
X	}
X	return;
X    }
X    if (level.flags.has_shop && !rn2(200)) {
X	if (!(sroom = search_special(ANY_SHOP))) {
X	    /* strange... */
X	    level.flags.has_shop = 0;
X	    return;
X	}
X        if(tended_shop(sroom) && 
X	   !index(u.ushops, ROOM_INDEX(sroom) + ROOMOFFSET))
X	    switch (rn2(2)+hallu) {
X		case 0:
X		    You("hear someone cursing shoplifters.");
X		    break;
X		case 1:
X		    You("hear the chime of a cash register.");
X		    break;
X		case 2:
X		    You("hear Neiman and Marcus arguing!");
X		    break;
X	    }
X        return;
X    }
X}
X
X#endif /* OVL0 */
X#ifdef OVLB
X
X#include "eshk.h"
X
Xvoid
Xgrowl(mtmp)
Xregister struct monst *mtmp;
X{
X    if (mtmp->msleep || !mtmp->mcanmove) return;
X    /* presumably nearness and soundok checks have already been made */
X    switch (mtmp->data->msound) {
X	case MS_SILENT:
X	    break;
X	case MS_MEW:
X	case MS_HISS:
X	    pline("%s hisses!", Monnam(mtmp));
X	    break;
X	case MS_BARK:
X	case MS_GROWL:
X	    pline("%s growls!", Monnam(mtmp));
X	    break;
X	case MS_ROAR:
X	    pline("%s roars!", Monnam(mtmp));
X	    break;
X	case MS_BUZZ:
X	    pline("%s buzzes!", Monnam(mtmp));
X	    break;
X	case MS_SQEEK:
X	    pline("%s squeals!", Monnam(mtmp));
X	    break;
X	case MS_SQAWK:
X	    pline("%s screeches!", Monnam(mtmp));
X	    break;
X	case MS_NEIGH:
X	    pline("%s neighs!", Monnam(mtmp));
X	    break;
X	case MS_WAIL:
X	    pline("%s wails!", Monnam(mtmp));
X	    break;
X    }
X}
X
Xvoid
Xyelp(mtmp)
Xregister struct monst *mtmp;
X/* the sounds of mistreated pets */
X{
X    if (mtmp->msleep || !mtmp->mcanmove) return;
X    /* presumably nearness and soundok checks have already been made */
X    switch (mtmp->data->msound) {
X	case MS_MEW:
X	    pline("%s yowls!", Monnam(mtmp));
X	    break;
X	case MS_BARK:
X	case MS_GROWL:
X	    pline("%s yelps!", Monnam(mtmp));
X	    break;
X	case MS_ROAR:
X	    pline("%s snarls!", Monnam(mtmp));
X	    break;
X	case MS_SQEEK:
X	    pline("%s squeals!", Monnam(mtmp));
X	    break;
X	case MS_SQAWK:
X	    pline("%s screaks!", Monnam(mtmp));
X	    break;
X	case MS_WAIL:
X	    pline("%s wails!", Monnam(mtmp));
X	    break;
X    }
X}
X
Xvoid
Xwhimper(mtmp)
Xregister struct monst *mtmp;
X/* the sounds of distressed pets */
X{
X    if (mtmp->msleep || !mtmp->mcanmove) return;
X    /* presumably nearness and soundok checks have already been made */
X    switch (mtmp->data->msound) {
X	case MS_MEW:
X	case MS_GROWL:
X	    pline("%s whimpers.", Monnam(mtmp));
X	    break;
X	case MS_BARK:
X	    pline("%s whines.", Monnam(mtmp));
X	    break;
X	case MS_SQEEK:
X	    pline("%s squeals.", Monnam(mtmp));
X	    break;
X    }
X}
X
X#endif /* OVLB */
X
X#endif /* SOUNDS */
X
X#ifdef OVLB
X
Xstatic int
Xdomonnoise(mtmp)
Xregister struct monst *mtmp;
X{
X    /* presumably nearness and sleep checks have already been made */
X    if (!flags.soundok) return(0);
X    switch (mtmp->data->msound) {
X	case MS_ORACLE:
X	    return doconsult(mtmp);
X	case MS_PRIEST:
X	    priest_talk(mtmp);
X	    break;
X#ifdef SOUNDS
X	case MS_SILENT:
X	    break;
X	case MS_SQEEK:
X	    pline("%s squeaks.", Monnam(mtmp));
X	    break;
X	case MS_SQAWK:
X	    pline("%s squawks.", Monnam(mtmp));
X	    break;
X	case MS_MEW:
X	    if (mtmp->mtame) {
X		if (mtmp->mconf || mtmp->mflee || mtmp->mtrapped || 
X		    moves > EDOG(mtmp)->hungrytime || mtmp->mtame < 5)
X		    pline("%s yowls.", Monnam(mtmp));
X		else if (EDOG(mtmp)->hungrytime > moves + 1000)
X		    pline("%s purrs.", Monnam(mtmp));
X		else
X		    pline("%s mews.", Monnam(mtmp));
X	    }
X	case MS_HISS:
X	    if (!mtmp->mpeaceful)
X		pline("%s hisses!", Monnam(mtmp));
X	    break;
X	case MS_BUZZ:
X	    if (!mtmp->mpeaceful)
X		pline("%s buzzes angrily.", Monnam(mtmp));
X	    break;
X	case MS_GRUNT:
X	    pline("%s grunts.", Monnam(mtmp));
X	    break;
X	case MS_BARK:
X	    if (flags.moonphase == FULL_MOON && night()) {
X		pline("%s howls.", Monnam(mtmp));
X		break;
X	    } else if (mtmp->mpeaceful) {
X		if (mtmp->mtame &&
X		    (mtmp->mconf || mtmp->mflee || mtmp->mtrapped ||
X		     moves > EDOG(mtmp)->hungrytime || mtmp->mtame < 5))
X		    pline("%s whines.", Monnam(mtmp));
X		else if (EDOG(mtmp)->hungrytime > moves + 1000)
X		    pline("%s yips.", Monnam(mtmp));
X		else
X		    pline("%s barks.", Monnam(mtmp));
X		break;
X	    }
X	case MS_GROWL:
X	    if (!mtmp->mpeaceful)
X		pline("%s growls!", Monnam(mtmp));
X	    break;
X	case MS_ROAR:
X	    if (!mtmp->mpeaceful)
X		pline("%s roars!", Monnam(mtmp));
X	    break;
X	case MS_NEIGH:
X	    pline("%s neighs.", Monnam(mtmp));
X	    break;
X	case MS_WAIL:
X	    pline("%s wails mournfully.", Monnam(mtmp));
X	    break;
X	case MS_GURGLE:
X	    pline("%s gurgles.", Monnam(mtmp));
X	    break;
X	case MS_BURBLE:
X	    pline("%s burbles.", Monnam(mtmp));
X	    break;
X	case MS_SHRIEK:
X	    pline("%s shrieks.", Monnam(mtmp));
X	    aggravate();
X	    break;
X	case MS_IMITATE:
X	    pline("%s imitates you.", Monnam(mtmp));
X	    break;
X	case MS_DJINNI:
X	    if (mtmp->mtame) verbalize("Thank you for freeing me!");
X	    else if (mtmp->mpeaceful) verbalize("I'm free!");
X	    else verbalize("This will teach you not to disturb me!");
X	    break;
X	case MS_MUMBLE:
X	    pline("%s mumbles incomprehensibly.", Monnam(mtmp));
X	    break;
X#ifdef MULDGN
X	case MS_LEADER:
X	case MS_NEMESIS:
X	case MS_GUARDIAN:
X	    quest_chat(mtmp);
X	    break;
X#endif
X	case MS_BONES:
X	    pline("%s rattles noisily.", Monnam(mtmp));
X	    You("freeze momentarily.");
X	    nomul(-2);
X	    break;
X	case MS_HUMANOID:
X	    if(In_endgame(&u.uz) && is_mplayer(mtmp->data))
X	        mplayer_talk(mtmp);
X	    /* Generic humanoid behaviour. */
X	    if (!mtmp->mpeaceful) break;
X	    if (mtmp->mflee)
X		pline("%s wants nothing to do with you.", Monnam(mtmp));
X	    else if (mtmp->mhp < mtmp->mhpmax/4)
X		pline("%s moans.", Monnam(mtmp));
X	    else if (mtmp->mconf || mtmp->mstun)
X		verbalize(!rn2(3) ? "Huh?" : rn2(2) ? "What?" : "Eh?");
X	    else if (!mtmp->mcansee)
X		verbalize("I can't see!");
X	    else if (mtmp->mtrapped)
X		verbalize("I'm trapped!");
X	    else if (mtmp->mhp < mtmp->mhpmax/2)
X		pline("%s asks for a potion of healing.", Monnam(mtmp));
X	    /* Specific monster's interests */
X	    else if (is_elf(mtmp->data))
X		pline("%s curses orcs.", Monnam(mtmp));
X	    else if (is_dwarf(mtmp->data))
X		pline("%s talks about mining.", Monnam(mtmp));
X	    else if (likes_magic(mtmp->data))
X		pline("%s talks about spellcraft.", Monnam(mtmp));
X	    else if (carnivorous(mtmp->data))
X		pline("%s discusses what kinds of meat are safe to eat.", Monnam(mtmp));
X	    else switch (monsndx(mtmp->data)){
X		case PM_HOBBIT:
X		    if (mtmp->mhpmax - mtmp->mhp >= 10)
Xpline("%s complains about unpleasant dungeon conditions.", Monnam(mtmp));
X		    else
X		    	pline("%s asks you about the One Ring.", Monnam(mtmp));
X		    break;
X		case PM_ARCHEOLOGIST:
Xpline("%s describes a recent article in \"Spelunker Today\" magazine.", Monnam(mtmp));
X		    break;
X		case PM_TOURIST:
X		    verbalize("Aloha.");
X		    break;
X		default:
X		    pline("%s discusses dungeon exploration.", Monnam(mtmp));
X	    }
X	    break;
X	case MS_SEDUCE:
X# ifdef SEDUCE
X	    if (mtmp->data->mlet != S_NYMPH &&
X		could_seduce(mtmp, &youmonst, (struct attack *)0) == 1) {
X			(void) doseduce(mtmp);
X			break;
X	    }
X	    switch ((poly_gender() != mtmp->female) ? rn2(3) : 0) {
X# else
X	    switch ((poly_gender() == 0) ? rn2(3) : 0) {
X# endif
X		case 2:
X			verbalize("Hello, sailor.");
X			break;
X		case 1:
X			pline("%s comes on to you.", Monnam(mtmp));
X			break;
X		default:
X			pline("%s cajoles you.", Monnam(mtmp));
X	    }
X	    break;
X# ifdef KOPS
X	case MS_ARREST:
X	    if (mtmp->mpeaceful)
X		verbalize("Just the facts, %s.",
X		      flags.female ? "Ma'am" : "Sir");
X	    else switch (rn2(3)) {
X		case 1:
X		    verbalize("Anything you say can be used against you.");
X		    break;
X		case 2:
X		    verbalize("You're under arrest!");
X		    break;
X		default:
X		    verbalize("Stop in the name of the Law!");
X	    }
X	    break;
X# endif
X	case MS_LAUGH:
X	    switch (rn2(4)) {
X		case 1:
X		    pline("%s giggles.", Monnam(mtmp));
X		    break;
X		case 2:
X		    pline("%s chuckles.", Monnam(mtmp));
X		    break;
X		case 3:
X		    pline("%s snickers.", Monnam(mtmp));
X		    break;
X		default:
X		    pline("%s laughs.", Monnam(mtmp));
X	    }
X	    break;
X	case MS_BRIBE:
X	    if (mtmp->mpeaceful && !mtmp->mtame) {
X		(void) demon_talk(mtmp);
X		break;
X	    }
X	    /* fall through */
X	case MS_CUSS:
X	    if (!mtmp->mpeaceful)
X		cuss(mtmp);
X	    break;
X	case MS_GUARD:
X	    if (u.ugold)
X		verbalize("Please drop that gold and follow me.");
X	    else
X		verbalize("Please follow me.");
X	    break;
X	case MS_NURSE:
X	    if (uwep)
X		verbalize("Put that weapon away before you hurt someone!");
X	    else if (uarmc || uarm || uarmh || uarms || uarmg || uarmf)
X		if (pl_character[0] == 'H')
X		    verbalize("Doc, I can't help you unless you cooperate.");
X		else
X		    verbalize("Please undress so I can examine you.");
X# ifdef TOURIST
X	    else if (uarmu)
X		verbalize("Take off your shirt, please.");
X# endif
X	    else verbalize("Relax, this won't hurt a bit.");
X	    break;
X	case MS_SELL: /* pitch, pay, total */
X	    if (ANGRY(mtmp))
X		pline("%s mentions how much %s dislikes %s customers.",
X			ESHK(mtmp)->shknam,
X			mtmp->female ? "she" : "he",
X			ESHK(mtmp)->robbed ? "non-paying" : "rude");
X	    else if (ESHK(mtmp)->following)
X		if (strncmp(ESHK(mtmp)->customer, plname, PL_NSIZ)) {
X		    verbalize("Hello %s!  I was looking for %s.",
X			    plname, ESHK(mtmp)->customer);
X		    ESHK(mtmp)->following = 0;
X		} else {
X		    verbalize("Hello %s!  Didn't you forget to pay?",
X			    plname);
X		}
X	    else if (ESHK(mtmp)->robbed)
X		pline("%s complains about a recent robbery.", ESHK(mtmp)->shknam);
X	    else if (ESHK(mtmp)->billct)
X		pline("%s reminds you that you haven't paid yet.", ESHK(mtmp)->shknam);
X	    else if (mtmp->mgold < 50)
X		pline("%s complains that business is bad.", ESHK(mtmp)->shknam);
X	    else if (mtmp->mgold > 4000)
X		pline("%s says that business is good.", ESHK(mtmp)->shknam);
X	    else
X		pline("%s talks about the problem of shoplifters.", ESHK(mtmp)->shknam);
X	    break;
X	case MS_SOLDIER:
X	    if (!mtmp->mpeaceful)
X	    switch (rn2(3)) {
X		case 2:
X		    verbalize("Resistance is useless!");
X		    break;
X		case 1:
X		    verbalize("You're dog meat!");
X		    break;
X		default:
X		    verbalize("Surrender!");
X	    } else
X	    switch (rn2(3)) {
X		case 2:
X		    verbalize("What lousy pay we're getting here!");
X		    break;
X		case 1:
X		    verbalize("The food's not fit for Orcs!");
X		    break;
X		default:
X		    verbalize("My feet hurt, I've been on them all day!");
X	    }
X	    break;
X	case MS_DEATH:
X	    pline("%s is busy reading a copy of Sandman #9.", Monnam(mtmp));
X	    break;
X	case MS_PESTILENCE:
X	case MS_FAMINE:
X	    verbalize("Who do you think you are, War?");
X	    break;
X#endif /* SOUNDS */
X    }
X    return(1);
X}
X
X
Xint
Xdotalk()
X{
X    int result;
X    boolean save_soundok = flags.soundok;
X    flags.soundok = 1;	/* always allow sounds while chatting */
X    result = dochat();
X    flags.soundok = save_soundok;
X    return result;
X}
X
Xstatic int
Xdochat()
X{
X    register struct monst *mtmp;
X    register int tx,ty;
X    struct obj *otmp;
X
X#ifdef POLYSELF
X    if (uasmon->msound == MS_SILENT) {
X	Your("current form seems unable to speak.");
X	return(0);
X    }
X#endif
X    if (Strangled) {
X	You("can't speak.  You're choking!");
X	return(0);
X    }
X    if (u.uswallow) {
X	pline("They won't hear you out there.");
X	return(0);
X    }
X    if (Underwater) {
X	pline("All you can utter is a mouthful of air bubbles.");
X	return(0);
X    }
X
X    if (!Blind && (otmp = shop_object(u.ux, u.uy)) != (struct obj *)0) {
X	/* standing on something in a shop and chatting causes the shopkeeper
X	   to describe the price(s).  This can inhibit other chatting inside
X	   a shop, but that shouldn't matter much.  shop_object() returns an
X	   object iff inside a shop and the shopkeeper is present and willing
X	   (not angry) and able (not asleep) to speak and the position contains
X	   any objects other than just gold.
X	*/
X	price_quote(otmp);
X	return(1);
X    }
X
X    (void) getdir("Talk to whom? [in what direction]");
X
X    if (u.dz) {
X	pline("They won't hear you %s there.", u.dz < 0 ? "up" : "down");
X	return(0);
X    }
X
X    if (u.dx == 0 && u.dy == 0) {
X/*
X * Let's not include this.  It raises all sorts of questions: can you wear
X * 2 helmets, 2 amulets, 3 pairs of gloves or 6 rings as a marilith,
X * etc...  --KAA
X#ifdef POLYSELF
X	if (u.umonnum == PM_ETTIN) {
X	    You("discover that your other head makes boring conversation.");
X	    return(1);
X	}
X#endif
X*/
X	pline("Talking to yourself is a bad habit for a dungeoneer.");
X	return(0);
X    }
X
X    tx = u.ux+u.dx; ty = u.uy+u.dy;
X    mtmp = m_at(tx, ty);
X    if ((Blind && !Telepat) || !mtmp || mtmp->mundetected ||
X		mtmp->m_ap_type == M_AP_FURNITURE ||
X		mtmp->m_ap_type == M_AP_OBJECT) {
X	pline("I see nobody there.");
X	return(0);
X    }
X    if (!mtmp->mcanmove || mtmp->msleep) {
X	pline("%s seems not to notice you.", Monnam(mtmp));
X	return(0);
X    }
X
X    if (mtmp->mtame && mtmp->meating) {
X	pline("%s is eating noisily.", Monnam(mtmp));
X	return (0);
X    }
X
X    return domonnoise(mtmp);
X}
X
X#endif /* OVLB */
X
X/*sounds.c*/
END_OF_FILE
if test 17245 -ne `wc -c <'src/sounds.c'`; then
    echo shar: \"'src/sounds.c'\" unpacked with wrong size!
fi
# end of 'src/sounds.c'
fi
if test -f 'sys/os2/Makefile.os2' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/os2/Makefile.os2'\"
else
echo shar: Extracting \"'sys/os2/Makefile.os2'\" \(37463 characters\)
sed "s/^X//" >'sys/os2/Makefile.os2' <<'END_OF_FILE'
X#	SCCS Id: @(#)Makefile.os2	3.1	93/01/24
X#	OS/2 NetHack 3.1 Makefile for OS/2 versions 1.x and 2.x
X#	Copyright (C) 1990, 1991, 1992, 1993 Timo Hakulinen
X#
X#	Supported compilers: Microsoft C 5.1 and 6.0A, GCC emx 0.8f,
X#	IBM C Set/2 1.00 with Toolkit/2 2.00.
X#
X#	NDMAKE ver 4.5, Microsoft/IBM NMAKE, or Dennis Vadura's DMAKE is
X#	required; old MS-MAKE will not work.  To enable the appropriate
X#	make utility, uncomment the respective make-specific macros.  If
X#	you plan to cross-compile in DOS, your best bet is NDMAKE, since
X#	it requires less memory than NMAKE.  To compile in OS/2 use NMAKE,
X#	DMAKE or something compatible.  Remember to set $(RLIBS) to real mode
X#	libraries if cross-compiling in DOS, and to protected mode libraries
X#	for compilation in OS/2.
X#
X#	Copy this file into $(SRC) directory, rename it to "makefile"
X#	(important, many targets rely on it), compile and link inside
X#	$(SRC).  If required, termcap library can be built from termcap
X#	sources using makefile.lib in "sys\share" directory.
X#
X#	"MSC" in this makefile refers to Microsoft C 5.1 and 6.0A.
X#	Whenever the distinction is significant, it is indicated.
X#
X#	"GCC" refers to GCC emx 0.8f only.  No other ports of
X#	GCC are supported.
X#
X#	"CSet/2" is the IBM 32 bit C compiler for OS/2 2.0.  CSet/2
X#	support courtesy Jeff Urlwin (jurlwin@gandalf.umcs.maine.edu).
X#
X#	"OMF" is short for "Object Module Format" and refers to the
X#	standard OS/2 object format, which e.g. link386 uses.  MSC and
X#	CSet/2 always produce OMF object files, and GCC can be instructed
X#	to produce them with proper switches (see below).
X#
X#	"a.out" refers to Unix object file format, which is used by GCC
X#	in its default compilation mode.  These object files must be
X#	linked using GCC's own linker to produce a proper OS/2 executable.
X#	GDB debugger shipped with GCC can only be used with a.out object
X#	format.
X#
X#	Note that the default setup in this makefile is my personal setup,
X#	which you will have to adapt to your configuration.
X#
X
X#
X#	Compiler and linker selection.
X#
X
XCC	= cl		# MSC
X#CC	= gcc		# GCC
X#CC	= icc		# CSet/2
X
XLINK	= link		# MSC
X#LINK	= link386	# GCC OMF, CSet/2
X
X#
X#	Make syntax peculiarities.
X#
X#	Enable the uppermost eight lines for NDMAKE, the middle eight
X#	for NMAKE (MSC, CSet/2), and the lowermost eight for DMAKE.
X#
X
X#MAKEB	= ndmake	# Executable name
X#CMD	=		# Command processor name if required
X#AB	= $*.c		# Base name of the target in target action
X#CB	= $*.c		#               - " -               dependent
X#B	= (		# Command line begin in shell one-liners
X#E	= )		#   - " -      end   - " -
X#S	= ;		# Command separator  - " -
X#P	= %		# Literal percent sign
XMAKEB	= nmake
XCMD	=
XAB	= $(@B).c
XCB	= $$(@B).c
XB	= (
XE	= )
XS	= &
XP	= %%
X#MAKEB	= dmake
X#CMD	= cmd /C
X#AB	= $(@:B).c
X#CB	= $$(@:B).c
X#B	= $(CMD) "
X#E	= "
X#S	= &
X#P	= %
X
X#
X#	Most makes execute actions automatically inside a subshell,
X#	which makes even the shell internals work ok.  This applies
X#	for NDMAKE and NMAKE.  DMAKE wants it spelled out for it.
X#
X
XECHO	= $(CMD) @echo
XRM	= $(CMD) del
XCP	= $(CMD) copy
X
X#
X#	For those of us who have these on PC.
X#
X
X#YACC	= yacc
X#LEX	= lex
XYACC	= bison -y
XLEX	= flex
X
X#
X#	For extracting NetHack icon.
X#
X
XUUDECODE = uudecode
X
X#
X#	For people with TeX and LaTeX.
X#
X
XLATEX	= latex
X
X#
X#	Standard file naming for LEX and YACC output may vary in PC
X#	installations.  These three are probably the most generally used
X#	names.
X#
X
XYTABC	= y_tab.c
XYTABH	= y_tab.h
XLEXYYC	= lexyy.c
X
X#
X#	Source tree base directory.
X#
X
XNHSRC	= \nh31
X
X#
X#	Source directories.  Makedefs hardcodes these, don't change them.
X#
X
XINCL	= $(NHSRC)\include	# NetHack include files
XDAT	= $(NHSRC)\dat		# NetHack data files
XDOC	= $(NHSRC)\doc		# NetHack documentation files
XUTIL	= $(NHSRC)\util		# Utility source
XSRC	= $(NHSRC)\src		# Main source
XWIN	= $(NHSRC)\win\tty	# Window system specific source
XSYS	= $(NHSRC)\sys\os2	# System specific source
XSSYS	= $(NHSRC)\sys\share	# Shared system files
X
X#
X#	Modifiable directories.  Set these according to your setup and
X#	preferences.  They must all be present prior to compilation.
X#	OBJ, TEMP and GAMEDIR should all preferably be separate and,
X#	in particular, not the same as any of the source directories.
X#	Note that DMAKE may dislike drive designators in paths because
X#	it misinterprets the colon as being part of a make rule.  In this
X#	case, all directories have to reside in the same drive.
X#
X
XOBJ	= \tmp\obj		# Object files
XTEMP	= \tmp\bin		# Temporary files during make process
XGAMEDIR = \games\nh31		# Game directory
XPLIBP	= d:\c6\lib		# Protected mode C libraries
XRLIBP	= d:\c6\lib		# Possible real mode C libraries
X
XTLIBP	= \toolkt20\os2lib	# CSet/2 Toolkit libpath (OS2386.LIB)
X
X#
X#	The game name and description.
X#
X
XGAME	= nethack
XGAMEDES = "NetHack 3.1"
X
X#
X#	The uppermost two lines for MSC, the middle two for GCC, and
X#	the lowermost two for CSet/2.
X#
X#	MSC: compile only, compiler id, large memory model, optimization level,
X#	remove stack probes, 80286 instruction set, dedicated datasegment for
X#	items >= 10 bytes, pack structures on 1 byte boundaries, generate code
X#	for 8087 coprocessor, compiler warning level, include file path, invoke
X#	large model compiler, debug flags, ANSI conformance.
X#
X#	GCC: compile only, compiler id, object format selection, warnings,
X#	include file path, ANSI conformance.
X#
X#	CSet/2: compile only, compiler id, migration lib, remove stack probes,
X#	force intra 64K alignment for data, force optlink linkage on function
X#	calls, warning level, include files, ANSI conformance.
X#
X
XCFLAGS	= /c /DOS2_MSC /AL /O /Gs /G2 /Gt10 /Zp1 /FPi $(WARN) /I$(INCL) $(BIGC) $(CDFLAGS) $(STDC)
XO	= /Fo
X#CFLAGS	= -c -DOS2_GCC $(GCCO) $(WARN) -I$(INCL) $(CDFLAGS) $(STDC)
X#O	= -o
X#CFLAGS	= /c /DOS2_CSET2 /Sm /Gs /Gt+ /Mp $(WARN) /I$(INCL) $(CDFLAGS) $(STDC)
X#O	= /Fo
X
X#
X#	Compiler warning levels.  These are really for development, so
X#	they are commented out in general distribution to save the user
X#	from masses of benign warnings.  If any problems arise, however,
X#	they may help in finding the trouble.
X#
X#	MSC: warning level 3 is highest in 5.1, second highest in 6.0.
X#	Cries a lot, but for no real cause.  Warning level 0 for distribution.
X#
X#	GCC: max. reasonable GCC warning levels.  Can't use -Wall, because then
X#	it would whine about all the zillions of unused declarations etc.
X#	Even with these switch you'll get a lot of warnings, but they should
X#	all be benign.
X#
X#	CSet/2: warning level 3.  The second optional parameter gives
X#	lots of extra warnings.
X#
X
XWARN	= /W0 #/W3		# MSC
X#WARN	= #-W -Wimplicit -Wreturn-type -Wunused -Wformat -Wswitch -Wshadow -Wcast-qual -Wwrite-strings -DGCC_WARN # GCC
X#WARN	= #/W3 #/Kbper	# CSet/2
X
X#
X#	GCC object format selection.  Upper line for standard OS/2 OMF
X#	object format, lower for Unix style a.out format.
X#
X
X#GCCO	= -Zomf -Zsys	# GCC OMF
XGCCO	=		# GCC a.out
X
X#
X#	MSC 5.1 needs the large model first pass of the compiler.
X#	Not needed for later versions.
X#
X
XBIGC	=
X#BIGC	= /B1 d:\binb\c1l.exe	# MSC 5.1
X
X#
X#	Unset CL to avoid troubles with conflicting switches in MSC 6.0.
X#
X
XCL	=
X
X#
X#	MSC, CSet/2: don't ignore case in symbols, no default lib search, stack
X#	8KB, allow max 1024 segments in program.
X#
X#	GCC: likes a big stack.
X#
X
XLFLAGS	= /noig /nod /stack:8192 /seg:1024 $(LDFLAGS)	# MSC, CSet/2
X#LFLAGS	= /noig /stack:40000				# GCC
X
X#
X#	Prepare for a debugger.
X#
X
XCDFLAGS =
XLDFLAGS =
X#CDFLAGS = /Zi		# CodeView (MSC)
X#LDFLAGS = /CO		# - " -
X#CDFLAGS = -g		# GDB (GCC a.out)
X#LDFLAGS = -g		# - " -
X#CDFLAGS = /Ti+		# IPMD (CSet/2)
X#LDFLAGS = /CO		# - " -
X
X#
X#	How to produce the most ANSI-like environment.
X#
X
X#STDC	=		# MSC 5.1
XSTDC	= /D__STDC__	# MSC 6.0, CSet/2
X#STDC	= -ansi		# GCC
X
X#
X#	Possible system object files required during linking.
X#
X
XSYSOBJ	=			# MSC, GCC a.out, CSet/2
X#SYSOBJ	= $(PLIBP)\crt0.obj	# GCC OMF
X
X#
X#	Compiler library selection.  Change if necessary.
X#
X#	MSC: Protected mode C libraries for 8087 emulator,
X#	OS/2 API entry points.
X#
X#	GCC OMF: C standard lib, extra GCC lib, static system lib,
X#	OS/2 API entry points.
X#
X#	GCC a.out: extra GCC lib, C standard lib, extra GCC lib (again),
X#	OS/2 API entry points.
X#
X#	CSet/2: C standard libraries, OS/2 API entry points.
X#
X
X#PLIBS	= $(PLIBP)\llibcep $(PLIBP)\doscalls	# MSC 5.1
XPLIBS	= $(PLIBP)\llibcep $(PLIBP)\os2		# MSC 6.0
X#PLIBS	= $(PLIBP)\libc $(PLIBP)\libgcc $(PLIBP)\libsys $(PLIBP)\libos2	# GCC OMF
X#PLIBS	= -lgcc -lc -lgcc -los2			# GCC a.out (defining -lgcc twice is required)
X#PLIBS	= $(PLIBP)\dde4sbs.lib $(PLIBP)\dde4sbm.lib $(TLIBP)\os2386.lib # CSet/2
X
X#
X#	C libraries used by makedefs, lev_comp and dgn_comp (change if
X#	necessary).  If compilation is done in DOS, enable the upper line
X#	possibly setting the library name to something else, if in OS/2,
X#	enable the lower line (protected mode libraries).
X#
X
X#RLIBS	= $(RLIBP)\llibcer
XRLIBS	= $(PLIBS)
X
X#
X#	Default compilation skeletons.	The uppermost six are for
X#	MSC and CSet/2 and the lowermost six for GCC.
X#
X
XSRCCC	= $(CC) $(CFLAGS) $(O)$@ $(SRC)\$(AB)
XUTILCC	= $(CC) $(CFLAGS) $(O)$@ $(UTIL)\$(AB)
XSYSCC	= $(CC) $(CFLAGS) $(O)$@ $(SYS)\$(AB)
XSSYSCC	= $(CC) $(CFLAGS) $(O)$@ $(SSYS)\$(AB)
XPSYSCC	= $(CC) $(CFLAGS) $(O)$@ $(SSYS)\pc$(AB)
XWINCC	= $(CC) $(CFLAGS) $(O)$@ $(WIN)\$(AB)
X#SRCCC	= $(CC) $(CFLAGS) $(O) $@ $(AB)
X#UTILCC	= $(B) cd $(UTIL) $(S) $(CC) $(CFLAGS) $(O) $@ $(AB) $(E)
X#SYSCC	= $(B) cd $(SYS) $(S) $(CC) $(CFLAGS) $(O) $@ $(AB) $(E)
X#SSYSCC	= $(B) cd $(SSYS) $(S) $(CC) $(CFLAGS) $(O) $@ $(AB) $(E)
X#PSYSCC	= $(B) cd $(SSYS) $(S) $(CC) $(CFLAGS) $(O) $@ pc$(AB) $(E)
X#WINCC	= $(B) cd $(WIN) $(S) $(CC) $(CFLAGS) $(O) $@ $(AB) $(E)
X
X#
X#	Default linker skeletons.  Upper four lines for everything
X#	that uses standard OS/2 object format (MSC, CSet/2, GCC OMF),
X#	lower four for GCC a.out format.
X#
X
XGAMELN	= $(LINK) @$(TEMP)\$(GAME).rsp
XMKDFLN	= $(LINK) @$(TEMP)\makedefs.rsp
XLEVCLN	= $(LINK) @$(TEMP)\lev_comp.rsp
XDGNCLN	= $(LINK) @$(TEMP)\dgn_comp.rsp
XRCVRLN	= $(LINK) @$(TEMP)\recover.rsp
X#GAMELN	= $(CC) $(LDFLAGS) -o $(GAMEDIR)\$(GAME).exe $(TEMP)\$(GAMEDEF) $(SYSOBJ) $(HOBJ) $(PLIBS) $(TERMLIB)
X#MKDFLN	= $(CC) $(LDFLAGS) -o $(TEMP)\makedefs.exe $(TEMP)\$(MKDFDEF) $(SYSOBJ) $(MAKEOBJS) $(PLIBS)
X#LEVCLN	= $(CC) $(LDFLAGS) -o $(TEMP)\lev_comp.exe $(TEMP)\$(LEVCDEF) $(SYSOBJ) $(SPLEVOBJS) $(PLIBS)
X#DGNCLN	= $(CC) $(LDFLAGS) -o $(TEMP)\dgn_comp.exe $(TEMP)\$(DGNCDEF) $(SYSOBJ) $(DGNCOMPOBJS) $(PLIBS)
X#RCVRLN	= $(CC) $(LDFLAGS) -o $(GAMEDIR)\recover.exe $(TEMP)\$(RCVRDEF) $(SYSOBJ) $(RECOVOBJS) $(PLIBS)
X
X#
X#	OS/2 module definition files for NetHack,
X#	makedefs, dgn_comp, lev_comp, recover.
X#
X
XGAMEDEF	= $(GAME).def
XMKDFDEF	= makedefs.def
XLEVCDEF	= lev_comp.def
XDGNCDEF	= dgn_comp.def
XRCVRDEF	= recover.def
X
X#
X#	For compilation in DOS, enable the lower three lines and
X#	disable the upper three.
X#
X
XMKDFMD	= $(TEMP)\$(MKDFDEF)
XLEVCMD	= $(TEMP)\$(LEVCDEF)
XDGNCMD	= $(TEMP)\$(DGNCDEF)
X#MKDFMD	=
X#LEVCMD	=
X#DGNCMD	=
X
X#
X#	Optional high-quality BSD random number generation routines
X#	(see os2conf.h).  Set to nothing if not used.
X#
X
XRANDOM	= $(OBJ)\random.o
X#RANDOM	=
X
X#
X#	If TERMLIB is defined in os2conf.h, comment out the upper line and
X#	uncomment the lower.  If the termcap-library doesn't exist, use
X#	sys\share\makefile.lib to build it.
X#
X
XTERMLIB =
X#TERMLIB = termlib.lib
X
X#
X#	Short / long file name selection for FAT and HPFS.
X#	Only two files need consideration.
X#
X
XGUIDEBOO = Guideboo	# FAT
XPATCHLEV = patchlev	# - " -
X#GUIDEBOO = Guidebook	# HPFS
X#PATCHLEV = patchlevel	# - " -
X
X
X#
X#	If you have LaTeX and want to create the NetHack Guidebook in TeX
X#	device-independent file format, comment out the upper line and
X#	uncomment the lower.
X#
X
XGUIDE	=
X#GUIDE	= $(TEMP)\$(GUIDEBOO).dvi
X
X#
X#	Set WINOBJ lines corresponding to your desired combination
X#	of windowing systems.  Also set windowing systems in config.h.
X#
X#	A straight tty port using no native windowing system is the
X#	only choice for now.
X
XWINOBJ = $(OBJ)\getline.o $(OBJ)\termcap.o $(OBJ)\topl.o $(OBJ)\wintty.o
X
X#
X#	The default make target, so just typing 'make' is useful.
X#	Has to be the first target in the makefile.
X#
X
Xdefault : all
X
X#
X#	If you have yacc and lex programs and make any changes, uncomment
X#	the lowermost two lines and uncomment the others.  If you make
X#	changes to the .y and .l files but prefer to process the files
X#	separately elsewhere, activate the middle two lines, so your changes
X#	don't get overwritten.
X#
X
X#do_yacc : yacc_cpy	# use pre-generated files
X#do_lex :  lex_cpy	#	- " -
X#do_yacc : yacc_msg	# show message if changed
X#do_lex :  lex_msg	#	- " -
Xdo_yacc : yacc_act	# re-process files
Xdo_lex :  lex_act	#	- " -
X
X#
X#	If you don't have uudecode program, use the upper line.
X#	If you still want the icon, you'll have to extract the
X#	file manually somewhere else.
X#
X
X#do_icon : icon_msg	# show message if changed
Xdo_icon : icon_act	# extract icon file
X
X#
X#	If you don't want to generate nethack.cmd, use the upper line.
X#	This could be the case, e.g., if you use different shell than
X#	the standard cmd.exe.
X#
X
X#do_cmd : cmd_msg	# show message
Xdo_cmd : cmd_act	# generate nethack.cmd
X
X######################################################################
X#
X#	Nothing below this line should have to be changed.
X#
X#	Other things that have to be reconfigured are in
X#	config.h, os2conf.h and possibly system.h.
X#
X
X#
X#	The game filename.
X#
X
XGAMEFILE = $(GAMEDIR)\$(GAME).exe
X
X#
X#	Object files for makedefs.
X#
X
XMAKEOBJS = $(OBJ)\makedefs.o $(OBJ)\monst.o $(OBJ)\objects.o
X
X#
X#	Object files for special levels compiler.
X#
X
XSOBJ01	= $(OBJ)\lev_yacc.o $(OBJ)\lev_lex.o $(OBJ)\lev_main.o $(OBJ)\alloc.o
XSOBJ02	= $(OBJ)\monst.o $(OBJ)\objects.o $(OBJ)\panic.o $(OBJ)\decl.o
XSOBJ03	= $(OBJ)\drawing.o
X
XSPLEVOBJS = $(SOBJ01) $(SOBJ02) $(SOBJ03)
X
X#
X#	Object files for dungeon compiler.
X#
X
XDOBJ01	= $(OBJ)\dgn_yacc.o $(OBJ)\dgn_lex.o $(OBJ)\dgn_main.o
XDOBJ02	= $(OBJ)\panic.o $(OBJ)\alloc.o
X
XDGNCOMPOBJS = $(DOBJ01) $(DOBJ02)
X
X#
X#	Object files for recovery utility.
X#
X
XRECOVOBJS = $(OBJ)\recover.o
X
X#
X#	Object files for the game itself.
X#
X
XVOBJ01 = $(OBJ)\allmain.o  $(OBJ)\alloc.o    $(OBJ)\apply.o    $(OBJ)\artifact.o
XVOBJ02 = $(OBJ)\attrib.o   $(OBJ)\ball.o     $(OBJ)\bones.o    $(OBJ)\botl.o
XVOBJ03 = $(OBJ)\cmd.o      $(OBJ)\dbridge.o  $(OBJ)\decl.o     $(OBJ)\detect.o
XVOBJ04 = $(OBJ)\display.o  $(OBJ)\do.o       $(OBJ)\do_name.o  $(OBJ)\do_wear.o
XVOBJ05 = $(OBJ)\dog.o      $(OBJ)\dogmove.o  $(OBJ)\dokick.o   $(OBJ)\dothrow.o
XVOBJ06 = $(OBJ)\drawing.o  $(OBJ)\dungeon.o  $(OBJ)\eat.o      $(OBJ)\end.o
XVOBJ07 = $(OBJ)\engrave.o  $(OBJ)\exper.o    $(OBJ)\explode.o  $(OBJ)\extralev.o
XVOBJ08 = $(OBJ)\files.o    $(OBJ)\fountain.o $(OBJ)\hack.o     $(OBJ)\hacklib.o
XVOBJ09 = $(OBJ)\invent.o   $(OBJ)\lock.o     $(OBJ)\mail.o     $(OBJ)\main.o
XVOBJ10 = $(OBJ)\makemon.o  $(OBJ)\mcastu.o   $(OBJ)\mhitm.o    $(OBJ)\mhitu.o
XVOBJ11 = $(OBJ)\minion.o   $(OBJ)\mklev.o    $(OBJ)\mkmap.o    $(OBJ)\mkmaze.o
XVOBJ12 = $(OBJ)\mkobj.o    $(OBJ)\mkroom.o   $(OBJ)\mon.o      $(OBJ)\mondata.o
XVOBJ13 = $(OBJ)\monmove.o  $(OBJ)\monst.o    $(OBJ)\monstr.o   $(OBJ)\mplayer.o
XVOBJ14 = $(OBJ)\mthrowu.o  $(OBJ)\muse.o     $(OBJ)\music.o    $(OBJ)\o_init.o
XVOBJ15 = $(OBJ)\objects.o  $(OBJ)\objnam.o   $(OBJ)\options.o  $(OBJ)\os2.o
XVOBJ16 = $(OBJ)\pager.o    $(OBJ)\pcsys.o    $(OBJ)\pickup.o   $(OBJ)\pline.o
XVOBJ17 = $(OBJ)\polyself.o $(OBJ)\potion.o   $(OBJ)\pray.o     $(OBJ)\priest.o
XVOBJ18 = $(OBJ)\quest.o    $(OBJ)\questpgr.o $(OBJ)\read.o     $(OBJ)\rect.o
XVOBJ19 = $(OBJ)\restore.o  $(OBJ)\rip.o      $(OBJ)\rnd.o      $(OBJ)\rumors.o
XVOBJ20 = $(OBJ)\save.o     $(OBJ)\shk.o      $(OBJ)\shknam.o   $(OBJ)\sit.o
XVOBJ21 = $(OBJ)\sounds.o   $(OBJ)\sp_lev.o   $(OBJ)\spell.o    $(OBJ)\steal.o
XVOBJ22 = $(OBJ)\timeout.o  $(OBJ)\topten.o   $(OBJ)\track.o    $(OBJ)\trap.o
XVOBJ23 = $(OBJ)\tty.o      $(OBJ)\u_init.o   $(OBJ)\uhitm.o    $(OBJ)\unix.o
XVOBJ24 = $(OBJ)\vault.o    $(OBJ)\vision.o   $(OBJ)\vis_tab.o  $(OBJ)\weapon.o
XVOBJ25 = $(OBJ)\were.o     $(OBJ)\wield.o    $(OBJ)\windows.o  $(OBJ)\wizard.o
XVOBJ26 = $(OBJ)\worm.o     $(OBJ)\worn.o     $(OBJ)\write.o    $(OBJ)\zap.o
XVOBJ27 = $(WINOBJ)
XVOBJ28 = $(RANDOM)
XHHOBJ  = $(OBJ)\version.o
X
XVOBJ =	$(VOBJ01) $(VOBJ02) $(VOBJ03) $(VOBJ04) $(VOBJ05) $(VOBJ06) $(VOBJ07) \
X	$(VOBJ08) $(VOBJ09) $(VOBJ10) $(VOBJ11) $(VOBJ12) $(VOBJ13) $(VOBJ14) \
X	$(VOBJ15) $(VOBJ16) $(VOBJ17) $(VOBJ18) $(VOBJ19) $(VOBJ20) $(VOBJ21) \
X	$(VOBJ22) $(VOBJ23) $(VOBJ24) $(VOBJ25) $(VOBJ26) $(VOBJ27) $(VOBJ28)
XHOBJ =	$(VOBJ) $(HHOBJ)
X
XEXTERN_H   = #$(INCL)\extern.h
XOS2CONF_H  = $(INCL)\os2conf.h $(INCL)\micro.h $(INCL)\system.h $(EXTERN_H)
XGLOBAL_H   = $(INCL)\global.h $(INCL)\coord.h $(OS2CONF_H)
XCONFIG_H   = $(INCL)\config.h $(INCL)\tradstdc.h $(GLOBAL_H)
XTRAP_H	   = $(INCL)\trap.h
XPERMONST_H = $(INCL)\permonst.h $(INCL)\monattk.h $(INCL)\monflag.h
XYOU_H	   = $(INCL)\you.h $(INCL)\attrib.h $(PERMONST_H) $(INCL)\mondata.h \
X	     $(INCL)\monst.h $(INCL)\youprop.h $(INCL)\prop.h $(INCL)\pm.h
XDECL_H	   = $(INCL)\decl.h $(INCL)\spell.h $(INCL)\obj.h $(YOU_H) \
X	     $(INCL)\onames.h $(INCL)\color.h
XHACK_H	   = $(CONFIG_H) $(DECL_H) $(INCL)\monsym.h $(INCL)\mkroom.h \
X	     $(INCL)\objclass.h $(TRAP_H) $(INCL)\engrave.h $(INCL)\flag.h \
X	     $(INCL)\rm.h $(INCL)\dungeon.h $(INCL)\hack.h $(INCL)\display.h \
X	     $(INCL)\vision.h $(INCL)\wintty.h $(INCL)\wintype.h $(INCL)\align.h \
X	     $(INCL)\winprocs.h
X
X#
X#	The default target.
X#
X
Xall :	makedefs dgn_comp lev_comp recover $(GAME) dat $(GUIDE)
X	$(ECHO) Done.
X
X#
X#	Definition file creation.
X#
X
X$(TEMP)\$(GAMEDEF) :
X	$(MAKEB) DD_NAME=$(GAME) DD_DESC=$(GAMEDES) DD_TARG=$@ do_def
X$(TEMP)\$(MKDFDEF) :
X	$(MAKEB) DD_NAME=makedefs DD_DESC="Definitions compiler" DD_TARG=$@ do_def
X$(TEMP)\$(DGNCDEF) :
X	$(MAKEB) DD_NAME=dgn_comp DD_DESC="Dungeon compiler" DD_TARG=$@ do_def
X$(TEMP)\$(LEVCDEF) :
X	$(MAKEB) DD_NAME=lev_comp DD_DESC="Level compiler" DD_TARG=$@ do_def
X$(TEMP)\$(RCVRDEF) :
X	$(MAKEB) DD_NAME=recover DD_DESC="Recovery utility" DD_TARG=$@ do_def
X
Xdo_def :
X	$(ECHO) NAME $(DD_NAME) WINDOWCOMPAT> $(DD_TARG)
X	$(ECHO) DESCRIPTION '$(DD_DESC)'>> $(DD_TARG)
X	$(ECHO) PROTMODE>> $(DD_TARG)
X	$(ECHO) EXETYPE OS2>> $(DD_TARG)
X
X#
X#	The main target.
X#
X
X$(GAME) : $(GAMEDIR)\$(GAME).exe
X$(GAME).exe : $(GAMEDIR)\$(GAME).exe
X$(GAMEDIR)\$(GAME).exe : $(TEMP)\$(GAME).rsp
X	$(GAMELN)
X
X$(TEMP)\$(GAME).rsp : $(HOBJ) $(TEMP)\$(GAMEDEF)
X	$(ECHO) $(SYSOBJ) $(VOBJ01) +> $@
X	$(ECHO) $(VOBJ02) +>> $@
X	$(ECHO) $(VOBJ03) +>> $@
X	$(ECHO) $(VOBJ04) +>> $@
X	$(ECHO) $(VOBJ05) +>> $@
X	$(ECHO) $(VOBJ06) +>> $@
X	$(ECHO) $(VOBJ07) +>> $@
X	$(ECHO) $(VOBJ08) +>> $@
X	$(ECHO) $(VOBJ09) +>> $@
X	$(ECHO) $(VOBJ10) +>> $@
X	$(ECHO) $(VOBJ11) +>> $@
X	$(ECHO) $(VOBJ12) +>> $@
X	$(ECHO) $(VOBJ13) +>> $@
X	$(ECHO) $(VOBJ14) +>> $@
X	$(ECHO) $(VOBJ15) +>> $@
X	$(ECHO) $(VOBJ16) +>> $@
X	$(ECHO) $(VOBJ17) +>> $@
X	$(ECHO) $(VOBJ18) +>> $@
X	$(ECHO) $(VOBJ19) +>> $@
X	$(ECHO) $(VOBJ20) +>> $@
X	$(ECHO) $(VOBJ21) +>> $@
X	$(ECHO) $(VOBJ22) +>> $@
X	$(ECHO) $(VOBJ23) +>> $@
X	$(ECHO) $(VOBJ24) +>> $@
X	$(ECHO) $(VOBJ25) +>> $@
X	$(ECHO) $(VOBJ26) +>> $@
X	$(ECHO) $(VOBJ27) +>> $@
X	$(ECHO) $(VOBJ28) +>> $@
X	$(ECHO) $(HHOBJ)>> $@
X	$(ECHO) $(GAMEDIR)\$(GAME).exe>> $@
X	$(ECHO) $(TEMP)\$(GAME)>> $@
X	$(ECHO) $(PLIBS) $(TERMLIB)>> $@
X	$(ECHO) $(TEMP)\$(GAMEDEF) $(LFLAGS);>> $@
X
X#
X#	Targets for makedefs.
X#
X
Xmakedefs : $(TEMP)\makedefs.exe
X$(TEMP)\makedefs.exe : $(TEMP)\makedefs.rsp
X	$(MKDFLN)
X
X$(TEMP)\makedefs.rsp : $(MAKEOBJS) $(TEMP)\$(MKDFDEF)
X	$(ECHO) $(SYSOBJ) $(MAKEOBJS)> $@
X	$(ECHO) $(TEMP)\makedefs.exe>> $@
X	$(ECHO) nul>> $@
X	$(ECHO) $(RLIBS)>> $@
X	$(ECHO) $(MKDFMD) $(LFLAGS);>> $@
X
X$(OBJ)\makedefs.o : $(UTIL)\$(CB) $(CONFIG_H) $(INCL)\permonst.h $(INCL)\objclass.h \
X		    $(INCL)\monsym.h $(INCL)\artilist.h $(INCL)\qtext.h
X	$(UTILCC)
X
X#
X#	Targets for the special levels compiler.
X#
X
Xlev_comp : $(TEMP)\lev_comp.exe
X$(TEMP)\lev_comp.exe : $(TEMP)\lev_comp.rsp
X	$(LEVCLN)
X
X$(TEMP)\lev_comp.rsp : $(SPLEVOBJS) $(TEMP)\$(LEVCDEF)
X	$(ECHO) $(SYSOBJ) $(SOBJ01) +> $@
X	$(ECHO) $(SOBJ02) +>> $@
X	$(ECHO) $(SOBJ03)>> $@
X	$(ECHO) $(TEMP)\lev_comp.exe>> $@
X	$(ECHO) nul>> $@
X	$(ECHO) $(RLIBS)>> $@
X	$(ECHO) $(LEVCMD) $(LFLAGS);>> $@
X
X$(OBJ)\lev_yacc.o : $(UTIL)\$(CB) $(HACK_H) $(INCL)\sp_lev.h
X	$(UTILCC)
X$(OBJ)\lev_lex.o  : $(UTIL)\$(CB) $(HACK_H) $(INCL)\sp_lev.h $(INCL)\lev_comp.h
X	$(UTILCC)
X$(OBJ)\lev_main.o : $(UTIL)\$(CB) $(HACK_H) $(INCL)\sp_lev.h $(INCL)\termcap.h
X	$(UTILCC)
X
X$(UTIL)\lev_yacc.c : $(UTIL)\lev_comp.y
X	$(MAKEB) YY=lev do_yacc
X
X$(UTIL)\lev_lex.c  : $(UTIL)\lev_comp.l
X	$(MAKEB) YY=lev do_lex
X
X#
X#	Targets for the dungeon compiler.
X#
X
Xdgn_comp : $(TEMP)\dgn_comp.exe
X$(TEMP)\dgn_comp.exe : $(TEMP)\dgn_comp.rsp
X	$(DGNCLN)
X
X$(TEMP)\dgn_comp.rsp : $(DGNCOMPOBJS) $(TEMP)\$(DGNCDEF)
X	$(ECHO) $(SYSOBJ) $(DOBJ01) +> $@
X	$(ECHO) $(DOBJ02)>> $@
X	$(ECHO) $(TEMP)\dgn_comp.exe>> $@
X	$(ECHO) nul>> $@
X	$(ECHO) $(RLIBS)>> $@
X	$(ECHO) $(DGNCMD) $(LFLAGS);>> $@
X
X$(OBJ)\dgn_yacc.o : $(UTIL)\$(CB) $(CONFIG_H) $(INCL)\dgn_file.h
X	$(UTILCC)
X$(OBJ)\dgn_lex.o  : $(UTIL)\$(CB) $(CONFIG_H) $(INCL)\dgn_comp.h $(INCL)\dgn_file.h
X	$(UTILCC)
X$(OBJ)\dgn_main.o : $(UTIL)\$(CB) $(CONFIG_H)
X	$(UTILCC)
X
X$(UTIL)\dgn_yacc.c : $(UTIL)\dgn_comp.y
X	$(MAKEB) YY=dgn do_yacc
X
X$(UTIL)\dgn_lex.c  : $(UTIL)\dgn_comp.l
X	$(MAKEB) YY=dgn do_lex
X
X#
X#	For both lev_comp and dgn_comp.
X#
X
X$(OBJ)\panic.o : $(UTIL)\$(CB) $(CONFIG_H)
X	$(UTILCC)
X
X#
X#	Yacc and Lex targets.
X#
X
Xyacc_cpy :
X	$(CP) $(SSYS)\$(YY)_yacc.c $(UTIL)
X	$(CP) $(SSYS)\$(YY)_comp.h $(INCL)
X
Xyacc_msg :
X	$(ECHO) $(YY)_comp.y has changed. To update $(YY)_yacc.c and $(YY)_comp.h run $(YACC).
X
Xyacc_act :
X	$(YACC) -d $(UTIL)\$(YY)_comp.y
X	$(CP) $(YTABC) $(UTIL)\$(YY)_yacc.c
X	$(CP) $(YTABH) $(INCL)\$(YY)_comp.h
X	$(RM) $(YTABC)
X	$(RM) $(YTABH)
X
Xlex_cpy :
X	$(CP) $(SSYS)\$(YY)_lex.c $(UTIL)
X
Xlex_msg :
X	$(ECHO) $(YY)_comp.l has changed. To update $(YY)_lex.c run $(LEX).
X
Xlex_act :
X	$(LEX) $(UTIL)\$(YY)_comp.l
X	$(CP) $(LEXYYC) $(UTIL)\$(YY)_lex.c
X	$(RM) $(LEXYYC)
X
X#
X#	Targets for the recovery utility.
X#
X
Xrecover : $(GAMEDIR)\recover.exe
X$(GAMEDIR)\recover.exe : $(TEMP)\recover.rsp
X	$(RCVRLN)
X
X$(TEMP)\recover.rsp : $(RECOVOBJS) $(TEMP)\$(RCVRDEF)
X	$(ECHO) $(SYSOBJ) $(RECOVOBJS)> $@
X	$(ECHO) $(GAMEDIR)\recover.exe>> $@
X	$(ECHO) nul>> $@
X	$(ECHO) $(PLIBS)>> $@
X	$(ECHO) $(TEMP)\$(RCVRDEF) $(LFLAGS);>> $@
X
X$(OBJ)\recover.o : $(UTIL)\$(CB) $(CONFIG_H)
X	$(UTILCC)
X
X#
X#	The following files depend on makedefs to be created.
X#
X#	date.h should be remade every time any of the source or include
X#	files is modified.
X#
X
X$(INCL)\date.h : $(VOBJ) $(TEMP)\makedefs.exe
X	$(TEMP)\makedefs -v
X	$(CP) $(DAT)\options $(GAMEDIR)
X	$(RM) $(DAT)\options
X
X$(INCL)\onames.h : $(TEMP)\makedefs.exe
X	$(TEMP)\makedefs -o
X
X$(INCL)\pm.h : $(TEMP)\makedefs.exe
X	$(TEMP)\makedefs -p
X
Xmonstr.c : $(TEMP)\makedefs.exe
X	$(TEMP)\makedefs -m
X
X$(OBJ)\monstr.o : $(CB)
X	$(SRCCC)
X
X$(GAMEDIR)\data : $(DAT)\data.bas $(TEMP)\makedefs.exe
X	$(TEMP)\makedefs -d
X	$(CP) $(DAT)\data $(GAMEDIR)
X	$(RM) $(DAT)\data
X
X$(GAMEDIR)\rumors : $(DAT)\rumors.tru $(DAT)\rumors.fal $(TEMP)\makedefs.exe
X	$(TEMP)\makedefs -r
X	$(CP) $(DAT)\rumors $(GAMEDIR)
X	$(RM) $(DAT)\rumors
X
X$(GAMEDIR)\oracles : $(DAT)\oracles.txt $(TEMP)\makedefs.exe
X	$(TEMP)\makedefs -h
X	$(CP) $(DAT)\oracles $(GAMEDIR)
X	$(RM) $(DAT)\oracles
X
X$(GAMEDIR)\quest.dat : $(DAT)\quest.txt $(TEMP)\makedefs.exe
X	$(TEMP)\makedefs -q
X	$(CP) $(DAT)\quest.dat $(GAMEDIR)
X	$(RM) $(DAT)\quest.dat
X
X#
X#	Vision tables for algorithm D.
X#
X
Xvis_tab.c : $(INCL)\vis_tab.h
X$(INCL)\vis_tab.h : $(TEMP)\makedefs.exe
X	$(TEMP)\makedefs -z
X
X$(OBJ)\vis_tab.o : $(CB)
X	$(SRCCC)
X
X#
X#	The following programs vary depending on what OS you are using.
X#
X
X$(OBJ)\main.o : $(SSYS)\pc$(CB) $(HACK_H)
X	$(PSYSCC)
X$(OBJ)\tty.o  : $(SSYS)\pc$(CB) $(HACK_H) $(INCL)\func_tab.h
X	$(PSYSCC)
X$(OBJ)\unix.o : $(SSYS)\pc$(CB) $(HACK_H)
X	$(PSYSCC)
X
X#
X#	Other system specific modules.
X#
X
X$(OBJ)\os2.o   : $(SYS)\$(CB) $(HACK_H) $(INCL)\termcap.h $(INCL)\def_os2.h
X	$(SYSCC)
X$(OBJ)\pcsys.o : $(SSYS)\$(CB) $(HACK_H)
X	$(SSYSCC)
X
X#
X#	Berkeley random(3) routines.
X#
X
X$(OBJ)\random.o : $(SSYS)\$(CB)
X	$(SSYSCC)
X
X#
X#	Window source.
X#
X
X$(OBJ)\getline.o : $(WIN)\$(CB) $(HACK_H) $(INCL)\func_tab.h
X	$(WINCC)
X$(OBJ)\termcap.o : $(WIN)\$(CB) $(HACK_H) $(INCL)\termcap.h
X	$(WINCC)
X$(OBJ)\topl.o    : $(WIN)\$(CB) $(HACK_H) $(INCL)\termcap.h
X	$(WINCC)
X$(OBJ)\wintty.o  : $(WIN)\$(CB) $(HACK_H) $(INCL)\termcap.h
X	$(WINCC)
X
X#
X#	Secondary targets.
X#
X
Xdat :	spec_lev help_fil $(GAMEDIR)\dungeon $(GAMEDIR)\data $(GAMEDIR)\rumors \
X	$(GAMEDIR)\oracles $(GAMEDIR)\quest.dat	$(GAMEDIR)\$(GAME).ico \
X	$(GAMEDIR)\$(GAME).cmd $(GAMEDIR)\nethack.cnf
X
Xhelp_fil : $(GAMEDIR)\cmdhelp $(GAMEDIR)\help $(GAMEDIR)\hh $(GAMEDIR)\history \
X	$(GAMEDIR)\license $(GAMEDIR)\opthelp $(GAMEDIR)\wizhelp
X
X$(GAMEDIR)\cmdhelp : $(DAT)\cmdhelp
X	$(CP) $(DAT)\cmdhelp $(GAMEDIR)
X$(GAMEDIR)\help : $(DAT)\help
X	$(CP) $(DAT)\help $(GAMEDIR)
X$(GAMEDIR)\hh : $(DAT)\hh
X	$(CP) $(DAT)\hh $(GAMEDIR)
X$(GAMEDIR)\history : $(DAT)\history
X	$(CP) $(DAT)\history $(GAMEDIR)
X$(GAMEDIR)\license : $(DAT)\license
X	$(CP) $(DAT)\license $(GAMEDIR)
X$(GAMEDIR)\opthelp : $(DAT)\opthelp
X	$(CP) $(DAT)\opthelp $(GAMEDIR)
X$(GAMEDIR)\wizhelp : $(DAT)\wizhelp
X	$(CP) $(DAT)\wizhelp $(GAMEDIR)
X
X$(GAMEDIR)\dungeon : $(DAT)\dungeon.def $(TEMP)\makedefs.exe $(TEMP)\dgn_comp.exe
X	$(TEMP)\makedefs -e
X	$(TEMP)\dgn_comp $(DAT)\dungeon.pdf
X	$(CP) $(DAT)\dungeon $(GAMEDIR)
X	$(RM) $(DAT)\dungeon.pdf
X	$(RM) $(DAT)\dungeon
X
XAFILES = $(GAMEDIR)\A-goal.lev
XBFILES = $(GAMEDIR)\B-goal.lev
XCFILES = $(GAMEDIR)\C-goal.lev
XEFILES = $(GAMEDIR)\E-goal.lev
XHFILES = $(GAMEDIR)\H-goal.lev
XKFILES = $(GAMEDIR)\K-goal.lev
XPFILES = $(GAMEDIR)\P-goal.lev
XRFILES = $(GAMEDIR)\R-goal.lev
XSFILES = $(GAMEDIR)\S-goal.lev
XTFILES = $(GAMEDIR)\T-goal.lev
XVFILES = $(GAMEDIR)\V-goal.lev
XWFILES = $(GAMEDIR)\W-goal.lev
X
XXFILES = $(AFILES) $(BFILES) $(CFILES) $(EFILES) $(HFILES) $(KFILES) \
X	 $(PFILES) $(RFILES) $(SFILES) $(TFILES) $(VFILES) $(WFILES)
X
Xspec_lev : $(GAMEDIR)\astral.lev $(GAMEDIR)\bigroom.lev $(GAMEDIR)\castle.lev \
X	   $(GAMEDIR)\knox.lev $(GAMEDIR)\medusa-1.lev $(GAMEDIR)\mine_end.lev \
X	   $(GAMEDIR)\oracle.lev $(GAMEDIR)\tower1.lev $(GAMEDIR)\valley.lev \
X	   $(GAMEDIR)\wizard1.lev $(XFILES)
X
X#	Single special level files
X
X$(GAMEDIR)\bigroom.lev : $(DAT)\bigroom.des $(TEMP)\lev_comp.exe
X	$(MAKEB) LF=bigroom do_slev
X$(GAMEDIR)\castle.lev : $(DAT)\castle.des $(TEMP)\lev_comp.exe
X	$(MAKEB) LF=castle do_slev
X$(GAMEDIR)\knox.lev : $(DAT)\knox.des $(TEMP)\lev_comp.exe
X	$(MAKEB) LF=knox do_slev
X$(GAMEDIR)\oracle.lev : $(DAT)\oracle.des $(TEMP)\lev_comp.exe
X	$(MAKEB) LF=oracle do_slev
X
Xdo_slev :
X	$(TEMP)\lev_comp $(DAT)\$(LF).des
X	$(CP) $(LF).lev $(GAMEDIR)
X	$(RM) $(LF).lev
X
X#	Multiple special level files
X
X$(GAMEDIR)\astral.lev : $(DAT)\endgame.des $(TEMP)\lev_comp.exe
X	$(TEMP)\lev_comp $(DAT)\endgame.des
X	$(CP) air.lev $(GAMEDIR)
X	$(CP) astral.lev $(GAMEDIR)
X	$(CP) earth.lev $(GAMEDIR)
X	$(CP) fire.lev $(GAMEDIR)
X	$(CP) water.lev $(GAMEDIR)
X	$(RM) air.lev
X	$(RM) astral.lev
X	$(RM) earth.lev
X	$(RM) fire.lev
X	$(RM) water.lev
X
X$(GAMEDIR)\medusa-1.lev : $(DAT)\medusa.des $(TEMP)\lev_comp.exe
X	$(TEMP)\lev_comp $(DAT)\medusa.des
X	$(CP) medusa-?.lev $(GAMEDIR)
X	$(RM) medusa-?.lev
X
X$(GAMEDIR)\mine_end.lev : $(DAT)\mines.des $(TEMP)\lev_comp.exe
X	$(TEMP)\lev_comp $(DAT)\mines.des
X	$(CP) mine_end.lev $(GAMEDIR)
X	$(CP) minefill.lev $(GAMEDIR)
X	$(CP) minetown.lev $(GAMEDIR)
X	$(RM) mine_end.lev
X	$(RM) minefill.lev
X	$(RM) minetown.lev
X
X$(GAMEDIR)\tower1.lev : $(DAT)\tower.des $(TEMP)\lev_comp.exe
X	$(TEMP)\lev_comp $(DAT)\tower.des
X	$(CP) tower?.lev $(GAMEDIR)
X	$(RM) tower?.lev
X
X$(GAMEDIR)\valley.lev : $(DAT)\gehennom.des $(TEMP)\lev_comp.exe
X	$(TEMP)\lev_comp $(DAT)\gehennom.des
X	$(CP) asmodeus.lev $(GAMEDIR)
X	$(CP) baalz.lev $(GAMEDIR)
X	$(CP) juiblex.lev $(GAMEDIR)
X	$(CP) orcus.lev $(GAMEDIR)
X	$(CP) sanctum.lev $(GAMEDIR)
X	$(CP) valley.lev $(GAMEDIR)
X	$(RM) asmodeus.lev
X	$(RM) baalz.lev
X	$(RM) juiblex.lev
X	$(RM) orcus.lev
X	$(RM) sanctum.lev
X	$(RM) valley.lev
X
X$(GAMEDIR)\wizard1.lev : $(DAT)\yendor.des $(TEMP)\lev_comp.exe
X	$(TEMP)\lev_comp $(DAT)\yendor.des
X	$(CP) wizard?.lev $(GAMEDIR)
X	$(CP) fakewiz?.lev $(GAMEDIR)
X	$(RM) wizard?.lev
X	$(RM) fakewiz?.lev
X
X#	Quest dungeons
X
X$(AFILES) : $(DAT)\Arch.des $(TEMP)\lev_comp.exe
X	$(MAKEB) QQ=A QF=Arch do_quest
X$(BFILES) : $(DAT)\Barb.des $(TEMP)\lev_comp.exe
X	$(MAKEB) QQ=B QF=Barb do_quest
X$(CFILES) : $(DAT)\Caveman.des $(TEMP)\lev_comp.exe
X	$(MAKEB) QQ=C QF=Caveman do_quest
X$(EFILES) : $(DAT)\Elf.des $(TEMP)\lev_comp.exe
X	$(MAKEB) QQ=E QF=Elf do_quest
X$(HFILES) : $(DAT)\Healer.des $(TEMP)\lev_comp.exe
X	$(MAKEB) QQ=H QF=Healer do_quest
X$(KFILES) : $(DAT)\Knight.des $(TEMP)\lev_comp.exe
X	$(MAKEB) QQ=K QF=Knight do_quest
X$(PFILES) : $(DAT)\Priest.des $(TEMP)\lev_comp.exe
X	$(MAKEB) QQ=P QF=Priest do_quest
X$(RFILES) : $(DAT)\Rogue.des $(TEMP)\lev_comp.exe
X	$(MAKEB) QQ=R QF=Rogue do_quest
X$(SFILES) : $(DAT)\Samurai.des $(TEMP)\lev_comp.exe
X	$(MAKEB) QQ=S QF=Samurai do_quest
X$(TFILES) : $(DAT)\Tourist.des $(TEMP)\lev_comp.exe
X	$(MAKEB) QQ=T QF=Tourist do_quest
X$(VFILES) : $(DAT)\Valkyrie.des $(TEMP)\lev_comp.exe
X	$(MAKEB) QQ=V QF=Valkyrie do_quest
X$(WFILES) : $(DAT)\Wizard.des $(TEMP)\lev_comp.exe
X	$(MAKEB) QQ=W QF=Wizard do_quest
X
Xdo_quest :
X	$(TEMP)\lev_comp $(DAT)\$(QF).des
X	$(CP) $(QQ)-goal.lev $(GAMEDIR)
X	$(CP) $(QQ)-fill?.lev $(GAMEDIR)
X	$(CP) $(QQ)-locate.lev $(GAMEDIR)
X	$(CP) $(QQ)-start.lev $(GAMEDIR)
X	$(RM) $(QQ)-goal.lev
X	$(RM) $(QQ)-fill?.lev
X	$(RM) $(QQ)-locate.lev
X	$(RM) $(QQ)-start.lev
X
X#
X#	NetHack icon for Presentation Manager.
X#
X
X$(GAMEDIR)\$(GAME).ico : $(SYS)\nhpmico.uu
X	$(MAKEB) do_icon
X
Xicon_msg :
X	$(ECHO) Icon file not extracted.  Extract manually if required.
X
Xicon_act :
X	$(UUDECODE) $(SYS)\nhpmico.uu
X	$(CP) nethack.ico $(GAMEDIR)\$(GAME).ico
X	$(RM) nethack.ico
X
X#
X#	NetHack command file to use with Presentation Manager.
X#
X
X$(GAMEDIR)\$(GAME).cmd :
X	$(MAKEB) CMDF=$@ do_cmd
X
Xcmd_msg :
X	$(ECHO) Command file not created.  Create manually if required.
X
Xcmd_act :
X	$(ECHO) @echo off> $(CMDF)
X	$(ECHO) REM Command file for starting nethack.exe from PM/WPS Desktop>> $(CMDF)
X	$(ECHO) $(GAME).exe $(P)1 $(P)2 $(P)3 $(P)4 $(P)5 $(P)6 $(P)7>> $(CMDF)
X	$(ECHO) pause>> $(CMDF)
X
X#
X#	NetHack configuration file.  Will not overwrite an existing file.
X#
X
X$(GAMEDIR)\nethack.cnf :
X	$(CP) $(SSYS)\nethack.cnf $(GAMEDIR)
X
X#
X#	Documentation.
X#
X
X$(TEMP)\$(GUIDEBOO).dvi : $(DOC)\$(GUIDEBOO).tex
X	$(LATEX) $(DOC)\$(GUIDEBOO).tex
X	$(CP) $(GUIDEBOO).dvi $(TEMP)
X	$(CP) $(GUIDEBOO).aux $(TEMP)
X	$(CP) $(GUIDEBOO).log $(TEMP)
X	$(RM) $(GUIDEBOO).dvi
X	$(RM) $(GUIDEBOO).aux
X	$(RM) $(GUIDEBOO).log
X
X#
X#	Housekeeping.
X#
X
Xclean :
X	-$(RM) $(OBJ)\*.o
X
Xspotless : clean
X	-$(RM) $(INCL)\date.h
X	-$(RM) $(INCL)\onames.h
X	-$(RM) $(INCL)\pm.h
X	-$(RM) $(INCL)\vis_tab.h
X	-$(RM) vis_tab.c
X	-$(RM) monstr.c
X	-$(RM) *.lev
X	-$(RM) nethack.ico
X	-$(RM) $(TEMP)\makedefs.exe
X	-$(RM) $(TEMP)\lev_comp.exe
X	-$(RM) $(TEMP)\dgn_comp.exe
X	-$(RM) $(TEMP)\*.rsp
X	-$(RM) $(TEMP)\*.def
X	-$(RM) $(TEMP)\*.map
X	-$(RM) $(TEMP)\$(GUIDEBOO).dvi
X	-$(RM) $(TEMP)\$(GUIDEBOO).aux
X	-$(RM) $(TEMP)\$(GUIDEBOO).log
X
X#
X#	Main source.
X#
X#	Default rules are sooo difficult for so many make
X#	programs that we do this the most straightforward way.
X#
X
X$(OBJ)\allmain.o  : $(SRC)\$(CB) $(HACK_H)
X	$(SRCCC)
X$(OBJ)\alloc.o    : $(SRC)\$(CB) $(CONFIG_H)
X	$(SRCCC)
X$(OBJ)\apply.o    : $(SRC)\$(CB) $(HACK_H) $(INCL)\edog.h
X	$(SRCCC)
X$(OBJ)\artifact.o : $(SRC)\$(CB) $(HACK_H) $(INCL)\artifact.h $(INCL)\artilist.h
X	$(SRCCC)
X$(OBJ)\attrib.o   : $(SRC)\$(CB) $(HACK_H) $(INCL)\artifact.h
X	$(SRCCC)
X$(OBJ)\ball.o     : $(SRC)\$(CB) $(HACK_H)
X	$(SRCCC)
X$(OBJ)\bones.o    : $(SRC)\$(CB) $(HACK_H) $(INCL)\lev.h
X	$(SRCCC)
X$(OBJ)\botl.o     : $(SRC)\$(CB) $(HACK_H)
X	$(SRCCC)
X$(OBJ)\cmd.o      : $(SRC)\$(CB) $(HACK_H) $(INCL)\func_tab.h
X	$(SRCCC)
X$(OBJ)\dbridge.o  : $(SRC)\$(CB) $(HACK_H)
X	$(SRCCC)
X$(OBJ)\decl.o     : $(SRC)\$(CB) $(HACK_H) $(INCL)\quest.h
X	$(SRCCC)
X$(OBJ)\detect.o   : $(SRC)\$(CB) $(HACK_H) $(INCL)\artifact.h
X	$(SRCCC)
X$(OBJ)\display.o  : $(SRC)\$(CB) $(HACK_H)
X	$(SRCCC)
X$(OBJ)\do.o       : $(SRC)\$(CB) $(HACK_H) $(INCL)\lev.h
X	$(SRCCC)
X$(OBJ)\do_name.o  : $(SRC)\$(CB) $(HACK_H)
X	$(SRCCC)
X$(OBJ)\do_wear.o  : $(SRC)\$(CB) $(HACK_H)
X	$(SRCCC)
X$(OBJ)\dog.o      : $(SRC)\$(CB) $(HACK_H) $(INCL)\edog.h
X	$(SRCCC)
X$(OBJ)\dogmove.o  : $(SRC)\$(CB) $(HACK_H) $(INCL)\mfndpos.h $(INCL)\edog.h
X	$(SRCCC)
X$(OBJ)\dokick.o   : $(SRC)\$(CB) $(HACK_H) $(INCL)\eshk.h
X	$(SRCCC)
X$(OBJ)\dothrow.o  : $(SRC)\$(CB) $(HACK_H)
X	$(SRCCC)
X$(OBJ)\drawing.o  : $(SRC)\$(CB) $(HACK_H) $(INCL)\termcap.h
X	$(SRCCC)
X$(OBJ)\dungeon.o  : $(SRC)\$(CB) $(HACK_H) $(INCL)\dgn_file.h
X	$(SRCCC)
X$(OBJ)\eat.o      : $(SRC)\$(CB) $(HACK_H)
X	$(SRCCC)
X$(OBJ)\end.o      : $(SRC)\$(CB) $(HACK_H) $(INCL)\eshk.h
X	$(SRCCC)
X$(OBJ)\engrave.o  : $(SRC)\$(CB) $(HACK_H) $(INCL)\lev.h
X	$(SRCCC)
X$(OBJ)\exper.o    : $(SRC)\$(CB) $(HACK_H)
X	$(SRCCC)
X$(OBJ)\explode.o  : $(SRC)\$(CB) $(HACK_H)
X	$(SRCCC)
X$(OBJ)\extralev.o : $(SRC)\$(CB) $(HACK_H)
X	$(SRCCC)
X$(OBJ)\files.o    : $(SRC)\$(CB) $(HACK_H)
X	$(SRCCC)
X$(OBJ)\fountain.o : $(SRC)\$(CB) $(HACK_H)
X	$(SRCCC)
X$(OBJ)\hack.o     : $(SRC)\$(CB) $(HACK_H)
X	$(SRCCC)
X$(OBJ)\hacklib.o  : $(SRC)\$(CB) $(HACK_H)
X	$(SRCCC)
X$(OBJ)\invent.o   : $(SRC)\$(CB) $(HACK_H) $(INCL)\artifact.h
X	$(SRCCC)
X$(OBJ)\lock.o     : $(SRC)\$(CB) $(HACK_H)
X	$(SRCCC)
X$(OBJ)\makemon.o  : $(SRC)\$(CB) $(HACK_H) $(INCL)\epri.h $(INCL)\emin.h
X	$(SRCCC)
X$(OBJ)\mail.o     : $(SRC)\$(CB) $(HACK_H) $(INCL)\mail.h
X	$(SRCCC)
X$(OBJ)\mcastu.o   : $(SRC)\$(CB) $(HACK_H)
X	$(SRCCC)
X$(OBJ)\mhitm.o    : $(SRC)\$(CB) $(HACK_H) $(INCL)\artifact.h $(INCL)\edog.h
X	$(SRCCC)
X$(OBJ)\mhitu.o    : $(SRC)\$(CB) $(HACK_H) $(INCL)\artifact.h $(INCL)\edog.h
X	$(SRCCC)
X$(OBJ)\minion.o   : $(SRC)\$(CB) $(HACK_H) $(INCL)\emin.h $(INCL)\epri.h
X	$(SRCCC)
X$(OBJ)\mklev.o    : $(SRC)\$(CB) $(HACK_H)
X	$(SRCCC)
X$(OBJ)\mkmap.o    : $(SRC)\$(CB) $(HACK_H) $(INCL)\sp_lev.h
X	$(SRCCC)
X$(OBJ)\mkmaze.o   : $(SRC)\$(CB) $(HACK_H) $(INCL)\sp_lev.h
X	$(SRCCC)
X$(OBJ)\mkobj.o    : $(SRC)\$(CB) $(HACK_H) $(INCL)\artifact.h
X	$(SRCCC)
X$(OBJ)\mkroom.o   : $(SRC)\$(CB) $(HACK_H)
X	$(SRCCC)
X$(OBJ)\mon.o      : $(SRC)\$(CB) $(HACK_H) $(INCL)\mfndpos.h $(INCL)\edog.h
X	$(SRCCC)
X$(OBJ)\mondata.o  : $(SRC)\$(CB) $(HACK_H) $(INCL)\eshk.h $(INCL)\epri.h
X	$(SRCCC)
X$(OBJ)\monmove.o  : $(SRC)\$(CB) $(HACK_H) $(INCL)\mfndpos.h $(INCL)\artifact.h
X	$(SRCCC)
X$(OBJ)\monst.o    : $(SRC)\$(CB) $(CONFIG_H) $(PERMONST_H) $(INCL)\monsym.h $(INCL)\eshk.h $(INCL)\vault.h $(INCL)\epri.h $(INCL)\color.h
X	$(SRCCC)
X$(OBJ)\mplayer.o  : $(SRC)\$(CB) $(HACK_H)
X	$(SRCCC)
X$(OBJ)\mthrowu.o  : $(SRC)\$(CB) $(HACK_H)
X	$(SRCCC)
X$(OBJ)\muse.o     : $(SRC)\$(CB) $(HACK_H)
X	$(SRCCC)
X$(OBJ)\music.o    : $(SRC)\$(CB) $(HACK_H)
X	$(SRCCC)
X$(OBJ)\o_init.o   : $(SRC)\$(CB) $(HACK_H)
X	$(SRCCC)
X$(OBJ)\objects.o  : $(SRC)\$(CB) $(CONFIG_H) $(INCL)\obj.h $(INCL)\objclass.h $(INCL)\prop.h $(INCL)\color.h
X	$(SRCCC)
X$(OBJ)\objnam.o   : $(SRC)\$(CB) $(HACK_H)
X	$(SRCCC)
X$(OBJ)\options.o  : $(SRC)\$(CB) $(HACK_H) $(INCL)\termcap.h
X	$(SRCCC)
X$(OBJ)\pager.o    : $(SRC)\$(CB) $(HACK_H)
X	$(SRCCC)
X$(OBJ)\pickup.o   : $(SRC)\$(CB) $(HACK_H)
X	$(SRCCC)
X$(OBJ)\pline.o    : $(SRC)\$(CB) $(HACK_H) $(INCL)\epri.h
X	$(SRCCC)
X$(OBJ)\polyself.o : $(SRC)\$(CB) $(HACK_H)
X	$(SRCCC)
X$(OBJ)\potion.o   : $(SRC)\$(CB) $(HACK_H)
X	$(SRCCC)
X$(OBJ)\pray.o     : $(SRC)\$(CB) $(HACK_H) $(INCL)\epri.h
X	$(SRCCC)
X$(OBJ)\priest.o   : $(SRC)\$(CB) $(HACK_H) $(INCL)\mfndpos.h $(INCL)\eshk.h $(INCL)\epri.h $(INCL)\emin.h
X	$(SRCCC)
X$(OBJ)\quest.o    : $(SRC)\$(CB) $(HACK_H) $(INCL)\quest.h $(INCL)\qtext.h
X	$(SRCCC)
X$(OBJ)\questpgr.o : $(SRC)\$(CB) $(HACK_H) $(INCL)\qtext.h
X	$(SRCCC)
X$(OBJ)\read.o     : $(SRC)\$(CB) $(HACK_H)
X	$(SRCCC)
X$(OBJ)\rect.o     : $(SRC)\$(CB) $(HACK_H)
X	$(SRCCC)
X$(OBJ)\restore.o  : $(SRC)\$(CB) $(HACK_H) $(INCL)\lev.h $(INCL)\termcap.h $(INCL)\quest.h
X	$(SRCCC)
X$(OBJ)\rip.o      : $(SRC)\$(CB) $(HACK_H)
X	$(SRCCC)
X$(OBJ)\rnd.o      : $(SRC)\$(CB) $(HACK_H)
X	$(SRCCC)
X$(OBJ)\rumors.o   : $(SRC)\$(CB) $(HACK_H)
X	$(SRCCC)
X$(OBJ)\save.o     : $(SRC)\$(CB) $(HACK_H) $(INCL)\lev.h $(INCL)\quest.h
X	$(SRCCC)
X$(OBJ)\shk.o      : $(SRC)\$(CB) $(HACK_H) $(INCL)\eshk.h
X	$(SRCCC)
X$(OBJ)\shknam.o   : $(SRC)\$(CB) $(HACK_H) $(INCL)\eshk.h
X	$(SRCCC)
X$(OBJ)\sit.o      : $(SRC)\$(CB) $(HACK_H) $(INCL)\artifact.h
X	$(SRCCC)
X$(OBJ)\sounds.o   : $(SRC)\$(CB) $(HACK_H) $(INCL)\edog.h $(INCL)\eshk.h
X	$(SRCCC)
X$(OBJ)\sp_lev.o   : $(SRC)\$(CB) $(HACK_H) $(INCL)\sp_lev.h $(INCL)\rect.h
X	$(SRCCC)
X$(OBJ)\spell.o    : $(SRC)\$(CB) $(HACK_H)
X	$(SRCCC)
X$(OBJ)\steal.o    : $(SRC)\$(CB) $(HACK_H)
X	$(SRCCC)
X$(OBJ)\timeout.o  : $(SRC)\$(CB) $(HACK_H)
X	$(SRCCC)
X$(OBJ)\topten.o   : $(SRC)\$(CB) $(HACK_H)
X	$(SRCCC)
X$(OBJ)\track.o    : $(SRC)\$(CB) $(HACK_H)
X	$(SRCCC)
X$(OBJ)\trap.o     : $(SRC)\$(CB) $(HACK_H)
X	$(SRCCC)
X$(OBJ)\u_init.o   : $(SRC)\$(CB) $(HACK_H)
X	$(SRCCC)
X$(OBJ)\uhitm.o    : $(SRC)\$(CB) $(HACK_H)
X	$(SRCCC)
X$(OBJ)\vault.o    : $(SRC)\$(CB) $(HACK_H) $(INCL)\vault.h
X	$(SRCCC)
X$(OBJ)\version.o  : $(SRC)\$(CB) $(HACK_H) $(INCL)\date.h $(INCL)\$(PATCHLEV).h
X	$(SRCCC)
X$(OBJ)\vision.o   : $(SRC)\$(CB) $(HACK_H) $(INCL)\vis_tab.h
X	$(SRCCC)
X$(OBJ)\weapon.o   : $(SRC)\$(CB) $(HACK_H)
X	$(SRCCC)
X$(OBJ)\were.o     : $(SRC)\$(CB) $(HACK_H)
X	$(SRCCC)
X$(OBJ)\wield.o    : $(SRC)\$(CB) $(HACK_H)
X	$(SRCCC)
X$(OBJ)\windows.o  : $(SRC)\$(CB) $(HACK_H)
X	$(SRCCC)
X$(OBJ)\wizard.o   : $(SRC)\$(CB) $(HACK_H) $(INCL)\qtext.h
X	$(SRCCC)
X$(OBJ)\worm.o     : $(SRC)\$(CB) $(HACK_H) $(INCL)\lev.h
X	$(SRCCC)
X$(OBJ)\worn.o     : $(SRC)\$(CB) $(HACK_H)
X	$(SRCCC)
X$(OBJ)\write.o    : $(SRC)\$(CB) $(HACK_H)
X	$(SRCCC)
X$(OBJ)\zap.o      : $(SRC)\$(CB) $(HACK_H)
X	$(SRCCC)
END_OF_FILE
if test 37463 -ne `wc -c <'sys/os2/Makefile.os2'`; then
    echo shar: \"'sys/os2/Makefile.os2'\" unpacked with wrong size!
fi
# end of 'sys/os2/Makefile.os2'
fi
echo shar: End of archive 49 \(of 108\).
cp /dev/null ark49isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \
21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \
41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 \
61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 \
81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 \
101 102 103 104 105 106 107 108 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 108 archives.
    echo "Now execute 'rebuild.sh'"
    rm -f ark10[0-8]isdone ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
