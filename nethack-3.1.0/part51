Path: uunet!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v16i059:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Part51/108
Message-ID: <4362@master.CNA.TEK.COM>
Date: 1 Feb 93 19:42:49 GMT
Sender: news@master.CNA.TEK.COM
Lines: 2770
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1609

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 16, Issue 59
Archive-name: nethack31/Part51
Supersedes: nethack3p9: Volume 10, Issue 46-102
Environment: Amiga, Atari, Mac, MS-DOS, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 51 (of 108)."
# Contents:  src/attrib.c sys/share/lev_lex.c
# Wrapped by billr@saab on Wed Jan 27 16:09:06 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'src/attrib.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/attrib.c'\"
else
echo shar: Extracting \"'src/attrib.c'\" \(17826 characters\)
sed "s/^X//" >'src/attrib.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)attrib.c	3.1	92/10/26	*/
X/*	Copyright 1988, 1989, 1990, 1992, M. Stephenson		  */
X/* NetHack may be freely redistributed.  See license for details. */
X
X/*  attribute modification routines. */
X
X#include "hack.h"
X#include "artifact.h"
X
X/* #define	DEBUG	/* uncomment for debugging info */
X
X#ifdef OVLB
X
X	/* part of the output on gain or loss of attribute */
Xstatic
Xconst char	*plusattr[] = {
X	"strong", "smart", "wise", "agile", "tough", "charismatic"
X},
X		*minusattr[] = {
X	"weak", "stupid", "foolish", "clumsy", "vulnerable", "ugly"
X};
X
X	/* maximum and minimum values for the attributes */
Xstruct attribs	attrmax = {
X	118, 18, 18, 18, 18, 18
X},
X		attrmin = {
X	3, 3, 3, 3, 3, 3
X};
X
Xstatic
Xconst struct innate {
X	schar	ulevel;
X	long	*ability;
X	const char *gainstr, *losestr;
X}	a_abil[] = { {	 1, &(Stealth), "", "" },
X		     {   1, &(Fast), "", "" },
X		     {  10, &(Searching), "perceptive", "" },
X		     {	 0, 0, 0, 0 } },
X
X	b_abil[] = { {	 1, &(HPoison_resistance), "", "" },
X		     {   7, &(Fast), "quick", "slow" },
X		     {  15, &(Stealth), "stealthy", "" },
X		     {	 0, 0, 0, 0 } },
X
X	c_abil[] = { {	 7, &(Fast), "quick", "slow" },
X		     {	15, &(Warning), "sensitive", "" },
X		     {	 0, 0, 0, 0 } },
X
X	e_abil[] = { {   1, &(Fast), "", "" },
X		     {	 1, &(HSee_invisible), "", "" },
X		     {	 1, &(Searching), "", "" },
X		     {	 1, &(HSleep_resistance), "", "" },
X		     {	 0, 0, 0, 0 } },
X
X	h_abil[] = { {	 1, &(HPoison_resistance), "", "" },
X		     {	15, &(Warning), "sensitive", "" },
X		     {	 0, 0, 0, 0 } },
X
X	k_abil[] = { {	 7, &(Fast), "quick", "slow" },
X		     {	 0, 0, 0, 0 } },
X
X	p_abil[] = { {	15, &(Warning), "sensitive", "" },
X		     {  20, &(HFire_resistance), "cool", "warmer" },
X		     {	 0, 0, 0, 0 } },
X
X	r_abil[] = { {	 1, &(Stealth), "", ""  },
X		     {  10, &(Searching), "perceptive", "" },
X		     {	 0, 0, 0, 0 } },
X
X	s_abil[] = { {	 1, &(Fast), "", "" },
X		     {  15, &(Stealth), "stealthy", "" },
X		     {	 0, 0, 0, 0 } },
X
X	t_abil[] = { {	10, &(Searching), "perceptive", "" },
X		     {	20, &(HPoison_resistance), "hardy", "" },
X		     {	 0, 0, 0, 0 } },
X
X	v_abil[] = { {	 1, &(HCold_resistance), "", "" },
X		     {	 1, &(Stealth), "", "" },
X		     {   7, &(Fast), "quick", "slow" },
X		     {	 0, 0, 0, 0 } },
X
X	w_abil[] = { {	15, &(Warning), "sensitive", "" },
X		     {  17, &(HTeleport_control), "controlled","uncontrolled" },
X		     {	 0, 0, 0, 0 } };
X
Xstatic
Xconst struct clattr {
X	struct	attribs	base, cldist;
X 	align	align;
X	schar	shp, hd, xlev, ndx;
X/* According to AD&D, HD for some classes (ex. Wizard) should be smaller
X * (4-sided for wizards).  But this is not AD&D, and using the AD&D
X * rule here produces an unplayable character.  This I have used a minimum
X * of an 10-sided hit die for everything.  Another AD&D change: wizards get
X * a minimum strength of 6 since without one you can't teleport or cast
X * spells. --KAA
X */
X	const struct	innate *abil;
X}	a_attr = { {	 7, 10, 10,  7,  7,  7 },  /* Archeologist */
X		   {	20, 20, 20, 10, 20, 10 },
X		    { A_LAWFUL, 10 },  13, 10, 14,  2, a_abil },
X
X	b_attr = { {	16,  7,  7, 15, 16,  6 },  /* Barbarian */
X		   {	30,  6,  7, 20, 30,  7 },
X		    { A_NEUTRAL, 10 }, 16, 12, 10,  3, b_abil },
X
X	c_attr = { {	10,  7,  7,  7,  8,  6 },  /* Caveman (fighter) */
X		   {	30,  6,  7, 20, 30,  7 },
X		     { A_LAWFUL, 0 },  16, 10, 10,  3, c_abil },
X
X/*
X	e_attr = { {	13, 13, 14,  6, 14,  6 },
X */
X	e_attr = { {	13, 13, 13,  9, 13,  7 },  /* Elf (ranger) */
X		   {	30, 10, 10, 20, 20, 10 },
X		    { A_CHAOTIC, 10 },  15, 10, 11,  2, e_abil },
X
X	h_attr = { {	 7,  7, 13,  7, 11, 16 },  /* Healer (druid) */
X		   {	15, 20, 20, 15, 25, 10 },
X		    { A_NEUTRAL, 10 },  13, 10, 20,  2, h_abil },
X
X	k_attr = { {	13,  7, 14,  8, 10, 17 },  /* Knight (paladin) */
X		   {	20, 15, 15, 10, 20, 10 },
X		    { A_LAWFUL, 10 },  16, 10, 10,  3, k_abil },
X
X	p_attr = { {	 7,  7, 10,  7,  7,  7 },  /* Priest (cleric) */
X		   {	15, 10, 30, 15, 20, 10 },
X		    { A_NEUTRAL, 0 },  14, 10, 10,  2, p_abil },
X
X	r_attr = { {	 7,  7,  7, 10,  7,  6 },  /* Rogue (thief) */
X		   {	20, 10, 10, 30, 20, 10 },
X		    { A_CHAOTIC, 10 }, 12, 10, 11,  2, r_abil },
X
X	s_attr = { {	10,  8,  7, 10, 17,  6 },  /* Samurai (fighter/thief) */
X		   {	30, 10, 10, 30, 14, 10 },
X		    { A_LAWFUL, 10 },  15, 10, 11,  2, s_abil },
X
X#ifdef TOURIST
X	t_attr = { {	 7, 10,  6,  7,  7, 10 },  /* Tourist */
X		   {	15, 10, 10, 15, 30, 20 },
X		    { A_NEUTRAL, 0 },  10, 10, 14,  1, t_abil },
X#endif
X
X	v_attr = { {	10,  7,  7,  7, 10,  7 },  /* Valkyrie (fighter) */
X		   {	30,  6,  7, 20, 30,  7 },
X		    { A_NEUTRAL, 0 },  16, 10, 10,  3, v_abil },
X
X	w_attr = { {	 7, 10,  7,  7,  7,  7 },  /* Wizard (magic-user) */
X		   {	10, 30, 10, 20, 20, 10 },
X		    { A_NEUTRAL, 0 },  12, 10, 12,  1, w_abil },
X
X	X_attr = { {	 3,  3,  3,  3,  3,  3 },
X		   {	20, 15, 15, 15, 20, 15 },
X		    { A_NEUTRAL, 0 },  12, 10, 14,  1,  0 };
X
Xstatic long next_check = 600L;	/* arbitrary first setting */
Xstatic const struct clattr NEARDATA *NDECL(clx);
Xstatic void NDECL(init_align);
Xstatic void NDECL(exerper);
X
X/* adjust an attribute; return TRUE if change is made, FALSE otherwise */
Xboolean
Xadjattrib(ndx, incr, msgflg)
X	int	ndx, incr;
X	int	msgflg;	    /* positive => no message, zero => message, and */
X{			    /* negative => conditional (msg if change made) */
X	if (!incr) return FALSE;
X
X	if (incr > 0) {
X	    if ((AMAX(ndx) >= ATTRMAX(ndx)) && (ACURR(ndx) >= AMAX(ndx))) {
X		if (msgflg == 0 && flags.verbose)
X		    pline("You're already as %s as you can get.",
X			  plusattr[ndx]);
X		ABASE(ndx) = AMAX(ndx) = ATTRMAX(ndx); /* just in case */
X		return FALSE;
X	    }
X
X	    ABASE(ndx) += incr;
X	    if(ABASE(ndx) > AMAX(ndx)) {
X		incr = ABASE(ndx) - AMAX(ndx);
X		AMAX(ndx) += incr;
X		if(AMAX(ndx) > ATTRMAX(ndx))
X		    AMAX(ndx) = ATTRMAX(ndx);
X		ABASE(ndx) = AMAX(ndx);
X	    }
X	} else {
X	    if (ABASE(ndx) <= ATTRMIN(ndx)) {
X		if (msgflg == 0 && flags.verbose)
X		    pline("You're already as %s as you can get.",
X			  minusattr[ndx]);
X		ABASE(ndx) = ATTRMIN(ndx); /* just in case */
X		return FALSE;
X	    }
X
X	    ABASE(ndx) += incr;
X	    if(ABASE(ndx) < ATTRMIN(ndx)) {
X		incr = ABASE(ndx) - ATTRMIN(ndx);
X		ABASE(ndx) = ATTRMIN(ndx);
X		AMAX(ndx) += incr;
X		if(AMAX(ndx) < ATTRMIN(ndx))
X		    AMAX(ndx) = ATTRMIN(ndx);
X	    }
X	}
X	if (msgflg <= 0)
X	    You("feel %s%s!",
X		  (incr > 1 || incr < -1) ? "very ": "",
X		  (incr > 0) ? plusattr[ndx] : minusattr[ndx]);
X	flags.botl = 1;
X	return TRUE;
X}
X
Xvoid
Xgainstr(otmp, incr)
X	register struct obj *otmp;
X	register int incr;
X{
X	int num = 1;
X
X	if(incr) num = incr;
X	else {
X	    if(ABASE(A_STR) < 18) num = (rn2(4) ? 1 : rnd(6) );
X	    else if (ABASE(A_STR) < 103) num = rnd(10);
X	}
X	(void) adjattrib(A_STR, (otmp && otmp->cursed) ? -num : num, TRUE);
X}
X
Xvoid
Xlosestr(num)	/* may kill you; cause may be poison or monster like 'a' */
X	register int num;
X{
X	int ustr = ABASE(A_STR) - num;
X
X	while(ustr < 3) {
X		ustr++;
X		num--;
X		u.uhp -= 6;
X		u.uhpmax -= 6;
X	}
X	(void) adjattrib(A_STR, -num, TRUE);
X}
X
Xvoid
Xchange_luck(n)
X	register schar n;
X{
X	u.uluck += n;
X	if (u.uluck < 0 && u.uluck < LUCKMIN)	u.uluck = LUCKMIN;
X	if (u.uluck > 0 && u.uluck > LUCKMAX)	u.uluck = LUCKMAX;
X}
X
Xint
Xstone_luck(parameter)
Xboolean parameter; /* So I can't think up of a good name.  So sue me. --KAA */
X{
X	register struct obj *otmp;
X	register long bonchance = 0;
X
X	for(otmp = invent; otmp; otmp=otmp->nobj)
X	    if (otmp->otyp == LUCKSTONE
X		|| (otmp->oartifact && spec_ability(otmp, SPFX_LUCK))) {
X		if (otmp->cursed) bonchance -= otmp->quan;
X		else if (otmp->blessed) bonchance += otmp->quan;
X		else if (parameter) bonchance += otmp->quan;
X	    }
X
X	return sgn((int)bonchance);
X}
X
X#endif /* OVLB */
X#ifdef OVL1
X
Xvoid
Xrestore_attrib() {
X
X	int	i;
X
X	for(i = 0; i < A_MAX; i++) {	/* all temporary losses/gains */
X
X	   if(ATEMP(i) && ATIME(i)) {
X		if(!(--(ATIME(i)))) { /* countdown for change */
X		    ATEMP(i) += ATEMP(i) > 0 ? -1 : 1;
X
X		    if(ATEMP(i)) /* reset timer */
X			ATIME(i) = 100 / ACURR(A_CON);
X		}
X	    }
X	}
X}
X
X#endif /* OVL1 */
X#ifdef OVLB
X
X#define AVAL	50		/* tune value for exercise gains */
X
Xvoid
Xexercise(i, inc_or_dec)
Xint	i;
Xboolean	inc_or_dec;
X{
X#ifdef DEBUG
X	pline("Exercise:");
X#endif
X	if (i == A_INT || i == A_CHA) return;	/* can't exercise these */
X
X#ifdef POLYSELF
X	/* no physical exercise while polymorphed; the body's temporary */
X	if (u.umonnum >= 0 && i != A_WIS) return;
X#endif
X	if(abs(AEXE(i)) < AVAL) {
X		/*
X		 *	Law of diminishing returns (Part I):
X		 *
X		 *	Gain is harder at higher attribute values.
X		 *	79% at "3" --> 0% at "18"
X		 *	Loss is even at all levels (50%).
X		 *
X		 *	Note: *YES* ACURR is the right one to use.
X		 */
X		AEXE(i) += (inc_or_dec) ? (rn2(19) > ACURR(i)) : -rn2(2);
X#ifdef DEBUG
X		pline("%s, %s AEXE = %d",
X			(i == A_STR) ? "Str" : (i == A_WIS) ? "Wis" :
X			(i == A_DEX) ? "Dex" : "Con",
X			(inc_or_dec) ? "inc" : "dec", AEXE(i));
X#endif
X	}
X}
X
X/* hunger values - from eat.c */
X#define SATIATED	0
X#define NOT_HUNGRY	1
X#define HUNGRY		2
X#define WEAK		3
X#define FAINTING	4
X#define FAINTED		5
X#define STARVED		6
X
Xstatic void
Xexerper()
X{
X	if(!(moves % 10)) {
X		/* Hunger Checks */
X
X		int hs = (u.uhunger > 1000) ? SATIATED :
X			 (u.uhunger > 150) ? NOT_HUNGRY :
X			 (u.uhunger > 50) ? HUNGRY :
X			 (u.uhunger > 0) ? WEAK : FAINTING;
X
X#ifdef DEBUG
X		pline("exerper: Hunger checks");
X#endif
X		switch (hs) {
X		    case SATIATED:	exercise(A_DEX, FALSE); break;
X		    case NOT_HUNGRY:	exercise(A_CON, TRUE); break;
X		    case WEAK:		exercise(A_STR, FALSE); break;
X		    case FAINTING:
X		    case FAINTED:	exercise(A_CON, FALSE); break;
X		}
X
X		/* Encumberance Checks */
X#ifdef DEBUG
X		pline("exerper: Encumber checks");
X#endif
X		switch (near_capacity()) {
X		    case MOD_ENCUMBER:	exercise(A_STR, TRUE); break;
X		    case HVY_ENCUMBER:	exercise(A_STR, TRUE);
X					exercise(A_DEX, FALSE); break;
X		    case EXT_ENCUMBER:	exercise(A_DEX, FALSE);
X					exercise(A_CON, FALSE); break;
X		}
X
X	}
X
X	/* status checks */
X	if(!(moves % 5)) {
X#ifdef DEBUG
X		pline("exerper: Status checks");
X#endif
X		if(Clairvoyant)		exercise(A_WIS, TRUE);
X		if(HRegeneration)	exercise(A_STR, TRUE);
X
X		if(Sick || Vomiting)			exercise(A_CON, FALSE);
X		if(Confusion || Hallucination)		exercise(A_WIS, FALSE);
X		if(Wounded_legs || Fumbling || HStun)	exercise(A_DEX, FALSE);
X	}
X}
X
Xvoid
Xexerchk()
X{
X	int	i, mod_val;
X
X	/*	Check out the periodic accumulations */
X	exerper();
X
X#ifdef DEBUG
X	if(moves >= next_check)
X		pline("exerchk: ready to test. multi = %d.", multi);
X#endif
X	/*	Are we ready for a test?	*/
X	if(moves >= next_check && !multi) {
X#ifdef DEBUG
X	    pline("exerchk: testing.");
X#endif
X	    /*
X	     *	Law of diminishing returns (Part II):
X	     *
X	     *	The effects of "exercise" and "abuse" wear
X	     *	off over time.  Even if you *don't* get an
X	     *	increase/decrease, you lose some of the
X	     *	accumulated effects.
X	     */
X	    for(i = 0; i < A_MAX; AEXE(i++) /= 2) {
X
X		if(ABASE(i) >= 18 || !AEXE(i)) continue;
X		if(i == A_INT || i == A_CHA) continue;/* can't exercise these */
X
X#ifdef DEBUG
X		pline("exerchk: testing %s (%d).",
X			(i == A_STR) ? "Str" : (i == A_WIS) ? "Wis" :
X			(i == A_DEX) ? "Dex" : "Con", AEXE(i));
X#endif
X		/*
X		 *	Law of diminishing returns (Part III):
X		 *
X		 *	You don't *always* gain by exercising.
X		 *	[MRS 92/10/28 - Treat Wisdom specially for balance.]
X		 */
X		if(rn2(AVAL) > ((i != A_WIS) ? abs(AEXE(i)*2/3) : abs(AEXE(i))))
X		    continue;
X		mod_val = sgn(AEXE(i));
X
X#ifdef DEBUG
X		pline("exerchk: changing %d.", i);
X#endif
X		if(adjattrib(i, mod_val, -1)) {
X#ifdef DEBUG
X		    pline("exerchk: changed %d.", i);
X#endif
X		    /* if you actually changed an attrib - zero accumulation */
X		    AEXE(i) = 0;
X		    /* then print an explanation */
X		    switch(i) {
X		    case A_STR: You((mod_val >0) ?
X				    "must have been exercising." :
X				    "must have been abusing your body.");
X				break;
X		    case A_WIS: You((mod_val >0) ?
X				    "must have been very observant." :
X				    "must not have been paying attention.");
X				break;
X		    case A_DEX: You((mod_val >0) ?
X				    "must have been working on your reflexes." :
X				    "haven't been working on reflexes lately.");
X				break;
X		    case A_CON: You((mod_val >0) ?
X				    "must be leading a healthy life-style." :
X				    "must not have been watching your health.");
X				break;
X		    }
X		}
X	    }
X	    next_check += rn1(200,800);
X#ifdef DEBUG
X	    pline("exerchk: next check at %ld.", next_check);
X#endif
X	}
X}
X
Xstatic const struct	clattr *
Xclx()  {
X
X	register const struct	clattr	*attr;
X
X	switch	(pl_character[0]) {
X
X	    case 'A':	attr = &a_attr;
X			break;
X	    case 'B':	attr = &b_attr;
X			break;
X	    case 'C':	attr = &c_attr;
X			break;
X	    case 'E':	attr = &e_attr;
X			break;
X	    case 'H':	attr = &h_attr;
X			break;
X	    case 'K':	attr = &k_attr;
X			break;
X	    case 'P':	attr = &p_attr;
X			break;
X	    case 'R':	attr = &r_attr;
X			break;
X	    case 'S':	attr = &s_attr;
X			break;
X#ifdef TOURIST
X	    case 'T':	attr = &t_attr;
X			break;
X#endif
X	    case 'V':	attr = &v_attr;
X			break;
X	    case 'W':	attr = &w_attr;
X			break;
X	    default:	/* unknown type */
X			attr = &X_attr;
X			break;
X	}
X	return(attr);
X}
X
Xstatic void
Xinit_align() {	/* called from newhp if u.ulevel is 0 */
X
X	register const struct	clattr	*attr = clx();
X
X	u.ualign = attr->align;
X	/* there should be priests of every stripe */
X	if(pl_character[0] == 'P')
X	     u.ualign.type = (rn2(2)) ? attr->align.type : (rn2(2)) ? 1 : -1;
X	else u.ualign.type = attr->align.type;
X}
X
Xvoid
Xinit_attr(np)
X	register int	np;
X{
X	register int	i, x, tryct;
X	register const struct	clattr	*attr = clx();
X
X	for(i = 0; i < A_MAX; i++) {
X
X	    ABASE(i) = AMAX(i) = attr->base.a[i];
X	    ATEMP(i) = ATIME(i) = 0;
X	    np -= attr->base.a[i];
X	}
X
X	tryct = 0;
X	while(np > 0 && tryct < 100) {
X
X	    x = rn2(100);
X	    for (i = 0; (i < A_MAX) && ((x -= attr->cldist.a[i]) > 0); i++) ;
X	    if(i >= A_MAX) continue; /* impossible */
X
X	    if(ABASE(i) >= ATTRMAX(i)) {
X
X		tryct++;
X		continue;
X	    }
X	    tryct = 0;
X	    ABASE(i)++;
X	    AMAX(i)++;
X	    np--;
X	}
X
X	tryct = 0;
X	while(np < 0 && tryct < 100) {		/* for redistribution */
X
X	    x = rn2(100);
X	    for (i = 0; (i < A_MAX) && ((x -= attr->cldist.a[i]) > 0); i++) ;
X	    if(i >= A_MAX) continue; /* impossible */
X
X	    if(ABASE(i) <= ATTRMIN(i)) {
X
X		tryct++;
X		continue;
X	    }
X	    tryct = 0;
X	    ABASE(i)--;
X	    AMAX(i)--;
X	    np++;
X	}
X}
X
Xvoid
Xredist_attr() {
X
X	register int i, tmp;
X
X	for(i = 0; i < A_MAX; i++) {
X	    if (i==A_INT || i==A_WIS) continue;
X		/* Polymorphing doesn't change your mind */
X	    tmp = AMAX(i);
X	    AMAX(i) += (rn2(5)-2);
X	    if (AMAX(i) > ATTRMAX(i)) AMAX(i) = ATTRMAX(i);
X	    if (AMAX(i) < ATTRMIN(i)) AMAX(i) = ATTRMIN(i);
X	    ABASE(i) = ABASE(i) * AMAX(i) / tmp;
X	    /* ABASE(i) > ATTRMAX(i) is impossible */
X	    if (ABASE(i) < ATTRMIN(i)) ABASE(i) = ATTRMIN(i);
X	}
X}
X
Xvoid
Xadjabil(oldlevel,newlevel)
Xint oldlevel, newlevel;
X{
X	register const struct clattr	*attr = clx();
X#ifdef GCC_WARN
X	/* this is the "right" definition */
X	register const struct innate	*abil = attr->abil;
X#else
X	/* this one satisfies more compilers */
X	register struct innate	*abil = (struct innate *)attr->abil;
X#endif
X
X	if(abil) {
X	    for(; abil->ability; abil++) {
X		if(oldlevel < abil->ulevel && newlevel >= abil->ulevel) {
X			/* Abilities gained at level 1 can never be lost
X			 * via level loss, only via means that remove _any_
X			 * sort of ability.  A "gain" of such an ability from
X			 * an outside source is devoid of meaning, so we set
X			 * FROMOUTSIDE to avoid such gains.
X			 */
X			if (abil->ulevel == 1)
X				*(abil->ability) |= (FROMEXPER|FROMOUTSIDE);
X			else
X				*(abil->ability) |= FROMEXPER;
X			if(!(*(abil->ability) & FROMOUTSIDE)) {
X			    if(*(abil->gainstr))
X				You("feel %s!", abil->gainstr);
X			}
X		} else if (oldlevel >= abil->ulevel && newlevel < abil->ulevel) {
X			*(abil->ability) &= ~FROMEXPER;
X			if((*(abil->ability) & INTRINSIC)) {
X			    if(*(abil->losestr))
X				You("feel %s!", abil->losestr);
X			    else if(*(abil->gainstr))
X				You("feel less %s!", abil->gainstr);
X			}
X		}
X	    }
X	}
X}
X
Xint
Xnewhp() {
X	register const struct clattr	*attr = clx();
X	int	hp, conplus;
X
X	if(u.ulevel == 0) {
X
X		hp = attr->shp;
X		init_align();	/* initialize alignment stuff */
X		return hp;
X	} else {
X
X	    if(u.ulevel < attr->xlev)
X		hp = rnd(attr->hd);
X	    else
X		hp = attr->ndx;
X	}
X
X	switch(ACURR(A_CON)) {
X		case	3:	conplus = -2; break;
X		case	4:
X		case	5:
X		case	6:	conplus = -1; break;
X		case	15:
X		case	16:	conplus = 1; break;
X		case	17:	conplus = 2; break;
X		case	18:	conplus = 3; break;
X		default:	conplus = 0;
X	}
X	hp += conplus;
X	return((hp <= 0) ? 1 : hp);
X}
X
X#endif /* OVLB */
X#ifdef OVL0
X
Xschar
Xacurr(x)
Xint x;
X{ 
X	register int tmp = (u.abon.a[x] + u.atemp.a[x] + u.acurr.a[x]);
X
X	if (x == A_STR) {
X		if (uarmg && uarmg->otyp == GAUNTLETS_OF_POWER) return(125);
X		else return((tmp >= 125) ? 125 : (tmp <= 3) ? 3 : tmp);
X	} 
X#ifdef POLYSELF
X	else if(x == A_CHA) {
X		if (tmp < 18 && (u.usym == S_NYMPH ||
X		    u.umonnum==PM_SUCCUBUS || u.umonnum == PM_INCUBUS))
X		    return 18;
X	}
X#endif
X	return((tmp >= 25) ? 25 : (tmp <= 3) ? 3 : tmp);
X}
X
Xschar
Xacurrstr()
X/* condense clumsy ACURR(A_STR) value into value that fits into game formulas
X */
X{
X	register int str = ACURR(A_STR);
X
X	if (str <= 18) return str;
X	if (str <= 121) return (19 + str / 50); /* map to 19-21 */
X	else return str - 100;
X}
X
X#endif /* OVL0 */
X#ifdef OVL2
X
X/* avoid possible problems with alignment overflow, and provide a centralized
X * location for any future alignment limits
X */
Xvoid
Xadjalign(n)
Xregister int n;
X{
X	register int newalign = u.ualign.record + n;
X
X	if(n < 0) {
X		if(newalign < u.ualign.record)
X			u.ualign.record = newalign;
X	} else
X		if(newalign > u.ualign.record) {
X			u.ualign.record = newalign;
X			if(u.ualign.record > ALIGNLIM)
X				u.ualign.record = ALIGNLIM;
X		}
X}
X
X#endif /* OVL2 */
X
X/*attrib.c*/
END_OF_FILE
if test 17826 -ne `wc -c <'src/attrib.c'`; then
    echo shar: \"'src/attrib.c'\" unpacked with wrong size!
fi
# end of 'src/attrib.c'
fi
if test -f 'sys/share/lev_lex.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/share/lev_lex.c'\"
else
echo shar: Extracting \"'sys/share/lev_lex.c'\" \(35705 characters\)
sed "s/^X//" >'sys/share/lev_lex.c' <<'END_OF_FILE'
X# include "stdio.h"
X# define U(x) x
X# define NLSTATE yyprevious=YYNEWLINE
X# define BEGIN yybgin = yysvec + 1 +
X# define INITIAL 0
X# define YYLERR yysvec
X# define YYSTATE (yyestate-yysvec-1)
X# define YYOPTIM 1
X# define YYLMAX BUFSIZ
X# define output(c) putc(c,yyout)
X# define input() (((yytchar=yysptr>yysbuf?U(*--yysptr):getc(yyin))==10?(yylineno++,yytchar):yytchar)==EOF?0:yytchar)
X# define unput(c) {yytchar= (c);if(yytchar=='\n')yylineno--;*yysptr++=yytchar;}
X# define yymore() (yymorfg=1)
X# define ECHO fprintf(yyout, "%s",yytext)
X# define REJECT { nstr = yyreject(); goto yyfussy;}
Xint yyleng; extern char yytext[];
Xint yymorfg;
Xextern char *yysptr, yysbuf[];
Xint yytchar;
XFILE *yyin = {stdin}, *yyout = {stdout};
Xextern int yylineno;
Xstruct yysvf { 
X	struct yywork *yystoff;
X	struct yysvf *yyother;
X	int *yystops;};
Xstruct yysvf *yyestate;
Xextern struct yysvf yysvec[], *yybgin;
X/*	SCCS Id: @(#)lev_lex.c	3.1	92/07/12	*/
X/*	Copyright (c) 1989 by Jean-Christophe Collet */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#define LEV_LEX_C
X
X#include "hack.h"
X#include "lev_comp.h"
X#include "sp_lev.h"
X
X/* Most of these don't exist in flex, yywrap is macro and
X * yyunput is properly declared in flex.skel.
X */
X#ifndef FLEX_SCANNER
Xint FDECL (yyback, (int *, int));
Xint NDECL (yylook);
Xint NDECL (yyinput);
Xint NDECL (yywrap);
Xint NDECL (yylex);
X	/* Traditional lexes let yyunput() and yyoutput() default to int;
X	 * newer ones may declare them as void since they don't return
X	 * values.  For even more fun, the lex supplied as part of the
X	 * newer unbundled compiler for SunOS 4.x adds the void declarations
X	 * (under __STDC__ or _cplusplus ifdefs -- otherwise they remain
X	 * int) while the bundled lex and the one with the older unbundled
X	 * compiler do not.  To detect this, we need help from outside --
X	 * sys/unix/Makefile.utl.
X	 */
X# if defined(NeXT) || defined(SVR4)
X#  define VOIDYYPUT
X# endif
X# if !defined(VOIDYYPUT)
X#  if defined(POSIX_TYPES) && !defined(BOS) && !defined(HISX)
X#   define VOIDYYPUT
X#  endif
X# endif
X# if !defined(VOIDYYPUT) && defined(WEIRD_LEX)
X#  if defined(SUNOS4) && defined(__STDC__) && (WEIRD_LEX != 0) 
X#   define VOIDYYPUT
X#  endif
X# endif
X# ifdef VOIDYYPUT
Xvoid FDECL (yyunput, (int));
Xvoid FDECL (yyoutput, (int));
X# else
Xint FDECL (yyunput, (int));
Xint FDECL (yyoutput, (int));
X# endif
X#endif	/* FLEX_SCANNER */
X
Xvoid FDECL (init_yyin, (FILE *));
Xvoid FDECL (init_yyout, (FILE *));
X
X#ifdef MICRO
X#undef exit
Xextern void FDECL(exit, (int));
X#endif
X
X/* this doesn't always get put in lev_comp.h
X * (esp. when using older versions of bison)
X */
X
Xextern YYSTYPE yylval;
X
Xint line_number = 1, colon_line_number = 1;
X
X/* This is *** UGLY *** but I can't think a better way to do it
X * I really need a huge buffer to scan maps...
X */
X
X#undef YYLMAX
X#define YYLMAX	2048
X
X/*
X *	This is a hack required by Michael Hamel to get things
X *	working on the Mac.
X */
X#if defined(applec) && !defined(FLEX_SCANNER)
X#undef input
X#undef unput
X#define unput(c) { yytchar = (c); if (yytchar == 10) yylineno--; *yysptr++ = yytchar; }
X# ifndef YYNEWLINE
X# define YYNEWLINE 10
X# endif
X
Xchar
Xinput() {	/* Under MPW \n is chr(13)! Compensate for this. */
X
X	if (yysptr > yysbuf) return(*--yysptr);
X	else {
X		yytchar = getc(yyin);
X		if (yytchar == '\n') {
X		    yylineno++;
X		    return(YYNEWLINE);
X		}
X		if (yytchar == EOF) return(0);
X		else		    return(yytchar);
X	}
X}
X#endif	/* applec && !FLEX_SCANNER */
X
X# define MAPC 2
X# define YYNEWLINE 10
Xyylex(){
Xint nstr; extern int yyprevious;
Xwhile((nstr = yylook()) >= 0)
Xyyfussy: switch(nstr){
Xcase 0:
Xif(yywrap()) return(0); break;
Xcase 1:
X{
X#ifdef FLEX_SCANNER
X		  /*
X		   * There is a bug in Flex 2.3 patch level < 6
X		   * (absent in previous versions)
X		   * that results in the following behaviour :
X		   * Once you enter an yymore(), you never exit from it.
X		   * This should do the trick!
X		   */
X		  extern int yy_more_len;
X
X		  yy_more_len = 0;
X#endif
X		  BEGIN(INITIAL);
X		  yylval.map = (char *) alloc(yyleng-5);
X		  strncpy(yylval.map, yytext,yyleng-6);
X		  yylval.map[yyleng-6] = 0;
X		  return MAP_ID;
X		}
Xbreak;
Xcase 2:
X{ line_number++; yymore(); }
Xbreak;
Xcase 3:
X	{ line_number++; }
Xbreak;
Xcase 4:
X	{ colon_line_number = line_number; return ':'; }
Xbreak;
Xcase 5:
X	return MESSAGE_ID;
Xbreak;
Xcase 6:
X	return MAZE_ID;
Xbreak;
Xcase 7:
X	return NOMAP_ID;
Xbreak;
Xcase 8:
X	return LEVEL_ID;
Xbreak;
Xcase 9:
Xreturn LEV_INIT_ID;
Xbreak;
Xcase 10:
X	return FLAGS_ID;
Xbreak;
Xcase 11:
Xreturn GEOMETRY_ID;
Xbreak;
Xcase 12:
X	{ BEGIN(MAPC); line_number++; }
Xbreak;
Xcase 13:
X	return OBJECT_ID;
Xbreak;
Xcase 14:
X	return MONSTER_ID;
Xbreak;
Xcase 15:
X	return TRAP_ID;
Xbreak;
Xcase 16:
X	return DOOR_ID;
Xbreak;
Xcase 17:
Xreturn DRAWBRIDGE_ID;
Xbreak;
Xcase 18:
Xreturn MAZEWALK_ID;
Xbreak;
Xcase 19:
X	return WALLIFY_ID;
Xbreak;
Xcase 20:
X	return REGION_ID;
Xbreak;
Xcase 21:
Xreturn RANDOM_OBJECTS_ID;
Xbreak;
Xcase 22:
Xreturn RANDOM_MONSTERS_ID;
Xbreak;
Xcase 23:
Xreturn RANDOM_PLACES_ID;
Xbreak;
Xcase 24:
X	return ALTAR_ID;
Xbreak;
Xcase 25:
X	return LADDER_ID;
Xbreak;
Xcase 26:
X	return STAIR_ID;
Xbreak;
Xcase 27:
X	return PORTAL_ID;
Xbreak;
Xcase 28:
Xreturn TELEPRT_ID;
Xbreak;
Xcase 29:
X	return BRANCH_ID;
Xbreak;
Xcase 30:
Xreturn FOUNTAIN_ID;
Xbreak;
Xcase 31:
X	return SINK_ID;
Xbreak;
Xcase 32:
X	return POOL_ID;
Xbreak;
Xcase 33:
Xreturn NON_DIGGABLE_ID;
Xbreak;
Xcase 34:
X	return ROOM_ID;
Xbreak;
Xcase 35:
X	return SUBROOM_ID;
Xbreak;
Xcase 36:
Xreturn RAND_CORRIDOR_ID;
Xbreak;
Xcase 37:
Xreturn CORRIDOR_ID;
Xbreak;
Xcase 38:
X	return GOLD_ID;
Xbreak;
Xcase 39:
Xreturn ENGRAVING_ID;
Xbreak;
Xcase 40:
X	return NAME_ID;
Xbreak;
Xcase 41:
X	return CHANCE_ID;
Xbreak;
Xcase 42:
Xreturn LEV;
Xbreak;
Xcase 43:
X	{ yylval.i=D_ISOPEN; return DOOR_STATE; }
Xbreak;
Xcase 44:
X	{ yylval.i=D_CLOSED; return DOOR_STATE; }
Xbreak;
Xcase 45:
X	{ yylval.i=D_LOCKED; return DOOR_STATE; }
Xbreak;
Xcase 46:
X	{ yylval.i=D_NODOOR; return DOOR_STATE; }
Xbreak;
Xcase 47:
X	{ yylval.i=D_BROKEN; return DOOR_STATE; }
Xbreak;
Xcase 48:
X	{ yylval.i=W_NORTH; return DIRECTION; }
Xbreak;
Xcase 49:
X	{ yylval.i=W_EAST; return DIRECTION; }
Xbreak;
Xcase 50:
X	{ yylval.i=W_SOUTH; return DIRECTION; }
Xbreak;
Xcase 51:
X	{ yylval.i=W_WEST; return DIRECTION; }
Xbreak;
Xcase 52:
X	{ yylval.i = -1; return RANDOM_TYPE; }
Xbreak;
Xcase 53:
X	{ yylval.i = -2; return NONE; }
Xbreak;
Xcase 54:
X	return O_REGISTER;
Xbreak;
Xcase 55:
X	return M_REGISTER;
Xbreak;
Xcase 56:
X	return P_REGISTER;
Xbreak;
Xcase 57:
X	return A_REGISTER;
Xbreak;
Xcase 58:
X	{ yylval.i=1; return LEFT_OR_RIGHT; }
Xbreak;
Xcase 59:
X{ yylval.i=2; return LEFT_OR_RIGHT; }
Xbreak;
Xcase 60:
X	{ yylval.i=3; return CENTER; }
Xbreak;
Xcase 61:
X{ yylval.i=4; return LEFT_OR_RIGHT; }
Xbreak;
Xcase 62:
X	{ yylval.i=5; return LEFT_OR_RIGHT; }
Xbreak;
Xcase 63:
X	{ yylval.i=1; return TOP_OR_BOT; }
Xbreak;
Xcase 64:
X	{ yylval.i=5; return TOP_OR_BOT; }
Xbreak;
Xcase 65:
X	{ yylval.i=1; return LIGHT_STATE; }
Xbreak;
Xcase 66:
X	{ yylval.i=0; return LIGHT_STATE; }
Xbreak;
Xcase 67:
X	{ yylval.i=0; return FILLING; }
Xbreak;
Xcase 68:
X{ yylval.i=1; return FILLING; }
Xbreak;
Xcase 69:
X	{ yylval.i= AM_NONE; return ALIGNMENT; }
Xbreak;
Xcase 70:
X	{ yylval.i= AM_LAWFUL; return ALIGNMENT; }
Xbreak;
Xcase 71:
X	{ yylval.i= AM_NEUTRAL; return ALIGNMENT; }
Xbreak;
Xcase 72:
X	{ yylval.i= AM_CHAOTIC; return ALIGNMENT; }
Xbreak;
Xcase 73:
X{ yylval.i=1; return MON_ATTITUDE; }
Xbreak;
Xcase 74:
X	{ yylval.i=0; return MON_ATTITUDE; }
Xbreak;
Xcase 75:
X	{ yylval.i=1; return MON_ALERTNESS; }
Xbreak;
Xcase 76:
X	{ yylval.i=0; return MON_ALERTNESS; }
Xbreak;
Xcase 77:
X{ yylval.i= M_AP_FURNITURE; return MON_APPEARANCE; }
Xbreak;
Xcase 78:
X{ yylval.i= M_AP_MONSTER;   return MON_APPEARANCE; }
Xbreak;
Xcase 79:
X{ yylval.i= M_AP_OBJECT;    return MON_APPEARANCE; }
Xbreak;
Xcase 80:
X	{ yylval.i=2; return ALTAR_TYPE; }
Xbreak;
Xcase 81:
X	{ yylval.i=1; return ALTAR_TYPE; }
Xbreak;
Xcase 82:
X	{ yylval.i=0; return ALTAR_TYPE; }
Xbreak;
Xcase 83:
X	{ yylval.i=1; return UP_OR_DOWN; }
Xbreak;
Xcase 84:
X	{ yylval.i=0; return UP_OR_DOWN; }
Xbreak;
Xcase 85:
X	{ yylval.i=0; return BOOLEAN; }
Xbreak;
Xcase 86:
X	{ yylval.i=1; return BOOLEAN; }
Xbreak;
Xcase 87:
X	{ yylval.i=DUST; return ENGRAVING_TYPE; }
Xbreak;
Xcase 88:
X	{ yylval.i=ENGRAVE; return ENGRAVING_TYPE; }
Xbreak;
Xcase 89:
X	{ yylval.i=BURN; return ENGRAVING_TYPE; }
Xbreak;
Xcase 90:
X	{ yylval.i=MARK; return ENGRAVING_TYPE; }
Xbreak;
Xcase 91:
X	{ yylval.i=1; return CURSE_TYPE; }
Xbreak;
Xcase 92:
X{ yylval.i=2; return CURSE_TYPE; }
Xbreak;
Xcase 93:
X	{ yylval.i=3; return CURSE_TYPE; }
Xbreak;
Xcase 94:
X{ yylval.i=NOTELEPORT; return FLAG_TYPE; }
Xbreak;
Xcase 95:
X{ yylval.i=HARDFLOOR; return FLAG_TYPE; }
Xbreak;
Xcase 96:
X	{ yylval.i=NOMMAP; return FLAG_TYPE; }
Xbreak;
Xcase 97:
X{ yylval.i=SHORTSIGHTED; return FLAG_TYPE; }
Xbreak;
Xcase 98:
X{ yylval.i=atoi(yytext); return INTEGER; }
Xbreak;
Xcase 99:
X{ yytext[yyleng-1] = 0; /* Discard the trailing \" */
X		  yylval.map = (char *) alloc(strlen(yytext+1)+1);
X		  strcpy(yylval.map, yytext+1); /* Discard the first \" */
X		  return STRING; }
Xbreak;
Xcase 100:
X	{ line_number++; }
Xbreak;
Xcase 101:
X	;
Xbreak;
Xcase 102:
X	{ yylval.i = yytext[1]; return CHAR; }
Xbreak;
Xcase 103:
X	{ return yytext[0]; }
Xbreak;
Xcase -1:
Xbreak;
Xdefault:
Xfprintf(yyout,"bad switch yylook %d",nstr);
X} return(0); }
X/* end of yylex */
X#ifdef	AMIGA
Xlong *alloc(n)
X	unsigned n;
X{
X	return ((long *)malloc (n));
X}
X#endif
X
X/* routine to switch to another input file; needed for flex */
Xvoid init_yyin( input_f )
XFILE *input_f;
X{
X#ifdef FLEX_SCANNER
X	if (yyin)
X	    yyrestart(input_f);
X	else
X#endif
X	    yyin = input_f;
X}
X/* analogous routine (for completeness) */
Xvoid init_yyout( output_f )
XFILE *output_f;
X{
X	yyout = output_f;
X}
X
Xint yyvstop[] = {
X0,
X
X103,
X0,
X
X101,
X103,
X0,
X
X100,
X0,
X
X103,
X0,
X
X103,
X0,
X
X103,
X0,
X
X98,
X103,
X0,
X
X4,
X103,
X0,
X
X103,
X0,
X
X103,
X0,
X
X103,
X0,
X
X103,
X0,
X
X103,
X0,
X
X103,
X0,
X
X103,
X0,
X
X103,
X0,
X
X103,
X0,
X
X103,
X0,
X
X103,
X0,
X
X103,
X0,
X
X103,
X0,
X
X103,
X0,
X
X103,
X0,
X
X103,
X0,
X
X103,
X0,
X
X103,
X0,
X
X103,
X0,
X
X103,
X0,
X
X103,
X0,
X
X103,
X0,
X
X103,
X0,
X
X103,
X0,
X
X103,
X0,
X
X103,
X0,
X
X103,
X0,
X
X103,
X0,
X
X103,
X0,
X
X103,
X0,
X
X103,
X0,
X
X103,
X0,
X
X103,
X0,
X
X103,
X0,
X
X103,
X0,
X
X103,
X0,
X
X2,
X100,
X0,
X
X101,
X103,
X0,
X
X103,
X0,
X
X103,
X0,
X
X103,
X0,
X
X103,
X0,
X
X103,
X0,
X
X103,
X0,
X
X103,
X0,
X
X103,
X0,
X
X103,
X0,
X
X103,
X0,
X
X103,
X0,
X
X103,
X0,
X
X101,
X0,
X
X99,
X0,
X
X98,
X0,
X
X83,
X0,
X
X3,
X0,
X
X2,
X0,
X
X101,
X0,
X
X2,
X3,
X0,
X
X102,
X0,
X
X70,
X0,
X
X65,
X0,
X
X63,
X0,
X
X16,
X0,
X
X38,
X0,
X
X6,
X0,
X
X40,
X0,
X
X32,
X0,
X
X34,
X0,
X
X31,
X0,
X
X15,
X0,
X
X89,
X0,
X
X84,
X0,
X
X87,
X0,
X
X49,
X0,
X
X58,
X0,
X
X90,
X0,
X
X53,
X0,
X
X43,
X0,
X
X86,
X0,
X
X51,
X0,
X
X12,
X0,
X
X24,
X0,
X
X10,
X0,
X
X8,
X0,
X
X7,
X0,
X
X26,
X0,
X
X57,
X0,
X
X82,
X0,
X
X76,
X0,
X
X72,
X0,
X
X85,
X0,
X
X48,
X0,
X
X56,
X0,
X
X62,
X0,
X
X50,
X0,
X
X66,
X0,
X
X29,
X0,
X
X41,
X0,
X
X25,
X0,
X
X13,
X0,
X
X27,
X0,
X
X20,
X0,
X
X75,
X0,
X
X64,
X0,
X
X47,
X0,
X
X60,
X0,
X
X44,
X0,
X
X93,
X0,
X
X67,
X0,
X
X45,
X0,
X
X46,
X0,
X
X96,
X0,
X
X54,
X0,
X
X52,
X0,
X
X81,
X0,
X
X1,
X0,
X
X5,
X0,
X
X14,
X0,
X
X35,
X0,
X
X19,
X0,
X
X91,
X0,
X
X88,
X0,
X
X74,
X0,
X
X55,
X0,
X
X71,
X0,
X
X69,
X0,
X
X80,
X0,
X
X37,
X0,
X
X30,
X0,
X
X11,
X0,
X
X9,
X0,
X
X18,
X0,
X
X79,
X0,
X
X73,
X0,
X
X92,
X0,
X
X68,
X0,
X
X39,
X0,
X
X59,
X0,
X
X95,
X0,
X
X42,
X0,
X
X77,
X0,
X
X78,
X0,
X
X17,
X0,
X
X61,
X0,
X
X94,
X0,
X
X33,
X0,
X
X97,
X0,
X
X23,
X0,
X
X21,
X0,
X
X22,
X0,
X
X28,
X0,
X
X36,
X0,
X0};
X# define YYTYPE int
Xstruct yywork { YYTYPE verify, advance; } yycrank[] = {
X0,0,	0,0,	1,5,	0,0,	
X0,0,	0,0,	0,0,	0,0,	
X8,64,	0,0,	1,6,	1,7,	
X0,0,	0,0,	6,63,	0,0,	
X8,64,	8,64,	0,0,	0,0,	
X0,0,	0,0,	0,0,	0,0,	
X0,0,	0,0,	0,0,	0,0,	
X0,0,	0,0,	0,0,	0,0,	
X0,0,	1,6,	0,0,	1,8,	
X1,5,	6,63,	0,0,	8,64,	
X1,9,	8,65,	8,64,	0,0,	
X1,10,	0,0,	0,0,	0,0,	
X0,0,	1,11,	8,64,	0,0,	
X0,0,	0,0,	0,0,	8,64,	
X0,0,	0,0,	0,0,	1,12,	
X0,0,	0,0,	0,0,	0,0,	
X0,0,	0,0,	1,13,	1,14,	
X1,15,	1,16,	1,17,	1,18,	
X1,19,	24,87,	1,20,	29,97,	
X0,0,	1,21,	1,22,	1,23,	
X1,24,	1,25,	13,68,	1,26,	
X1,27,	1,28,	14,69,	15,70,	
X1,29,	16,72,	17,74,	20,79,	
X16,73,	18,75,	15,71,	25,88,	
X18,76,	19,77,	1,30,	1,31,	
X1,32,	1,33,	1,34,	1,35,	
X21,80,	1,36,	48,142,	19,78,	
X21,81,	1,37,	1,38,	1,39,	
X1,40,	1,41,	23,85,	1,42,	
X1,43,	1,44,	1,45,	2,47,	
X1,46,	33,109,	41,128,	2,9,	
X45,137,	46,139,	45,138,	33,110,	
X23,86,	41,129,	2,5,	10,67,	
X10,67,	10,67,	10,67,	10,67,	
X10,67,	10,67,	10,67,	10,67,	
X10,67,	53,146,	2,12,	28,95,	
X22,82,	54,69,	56,147,	57,79,	
X22,83,	2,13,	2,14,	2,15,	
X2,16,	2,17,	2,18,	2,19,	
X28,96,	2,20,	22,84,	2,5,	
X2,21,	2,48,	2,23,	2,24,	
X2,25,	26,89,	2,26,	2,27,	
X2,28,	26,90,	35,113,	2,29,	
X44,135,	59,88,	61,150,	44,136,	
X2,5,	34,111,	35,114,	26,91,	
X30,98,	2,30,	2,31,	2,32,	
X2,33,	2,34,	2,35,	30,99,	
X2,36,	3,49,	34,112,	30,100,	
X2,37,	2,38,	2,39,	2,40,	
X2,41,	66,153,	2,42,	2,43,	
X2,44,	2,45,	39,124,	2,46,	
X27,92,	36,115,	55,70,	2,5,	
X2,5,	2,5,	68,154,	3,50,	
X39,125,	55,71,	3,51,	27,93,	
X27,94,	31,101,	3,9,	36,116,	
X31,102,	37,117,	3,52,	31,103,	
X32,105,	37,118,	31,104,	32,106,	
X40,126,	37,119,	42,130,	32,107,	
X58,148,	69,155,	70,156,	37,120,	
X58,81,	3,12,	42,131,	71,157,	
X32,108,	72,158,	40,127,	73,159,	
X3,53,	3,54,	3,55,	3,16,	
X3,56,	3,18,	3,19,	38,121,	
X3,57,	38,122,	74,160,	3,58,	
X3,22,	3,23,	3,24,	3,59,	
X60,149,	3,26,	3,60,	3,28,	
X75,161,	76,162,	3,61,	38,123,	
X43,132,	77,163,	78,164,	60,93,	
X60,94,	79,165,	80,166,	43,133,	
X3,30,	3,31,	3,32,	3,33,	
X3,34,	3,35,	43,134,	3,36,	
X81,167,	82,168,	83,169,	3,37,	
X3,38,	3,39,	3,40,	3,41,	
X4,5,	3,42,	3,43,	3,44,	
X3,45,	84,170,	3,46,	62,151,	
X4,6,	4,49,	52,67,	52,67,	
X52,67,	52,67,	52,67,	52,67,	
X52,67,	52,67,	52,67,	52,67,	
X85,171,	86,172,	86,173,	87,174,	
X88,175,	89,177,	90,178,	88,176,	
X91,179,	62,152,	92,180,	4,50,	
X62,152,	4,8,	4,62,	93,181,	
X94,182,	95,183,	4,9,	96,184,	
X62,152,	97,185,	4,52,	98,186,	
X99,188,	4,51,	100,189,	4,11,	
X101,190,	102,191,	103,192,	104,193,	
X105,194,	106,195,	98,187,	107,196,	
X108,197,	4,12,	109,198,	110,199,	
X111,200,	112,201,	113,202,	114,203,	
X4,53,	4,54,	4,55,	4,16,	
X4,56,	4,18,	4,19,	116,206,	
X4,57,	117,207,	4,51,	4,58,	
X4,48,	4,23,	4,24,	4,59,	
X119,210,	4,26,	4,60,	4,28,	
X115,204,	120,211,	4,61,	122,215,	
X118,208,	123,216,	115,205,	4,51,	
X124,217,	126,224,	127,225,	128,226,	
X4,30,	4,31,	4,32,	4,33,	
X4,34,	4,35,	129,227,	4,36,	
X118,209,	130,228,	131,229,	4,37,	
X4,38,	4,39,	4,40,	4,41,	
X9,66,	4,42,	4,43,	4,44,	
X4,45,	132,230,	4,46,	47,140,	
X9,66,	9,0,	4,51,	4,51,	
X4,51,	134,233,	135,234,	47,140,	
X47,141,	121,212,	133,231,	136,235,	
X139,239,	133,232,	50,63,	50,143,	
X121,213,	142,240,	121,214,	137,236,	
X146,154,	147,241,	137,237,	9,66,	
X147,160,	9,66,	9,66,	142,168,	
X137,238,	148,166,	47,140,	149,180,	
X47,140,	47,140,	9,66,	150,242,	
X154,243,	50,144,	155,244,	9,66,	
X50,145,	47,140,	152,151,	156,245,	
X125,218,	157,246,	47,140,	125,219,	
X50,145,	158,247,	50,145,	50,145,	
X159,248,	160,249,	51,143,	161,250,	
X125,220,	125,221,	162,251,	163,252,	
X164,253,	125,222,	165,254,	125,223,	
X152,152,	166,255,	167,256,	152,152,	
X168,257,	169,258,	50,145,	50,145,	
X50,145,	170,259,	171,260,	152,152,	
X51,145,	172,261,	50,145,	51,145,	
X50,145,	50,145,	173,262,	174,263,	
X175,264,	50,145,	176,265,	51,145,	
X50,145,	51,145,	51,145,	177,266,	
X50,145,	178,267,	179,268,	180,269,	
X181,270,	50,145,	182,271,	183,272,	
X184,273,	185,274,	186,275,	187,276,	
X188,277,	189,278,	190,279,	191,280,	
X192,281,	51,145,	51,145,	51,145,	
X193,282,	194,283,	195,284,	196,285,	
X197,286,	51,145,	198,287,	51,145,	
X51,145,	199,288,	200,289,	201,290,	
X51,145,	202,291,	203,292,	51,145,	
X50,145,	50,145,	50,145,	51,145,	
X204,293,	205,294,	206,295,	208,296,	
X51,145,	209,297,	211,298,	212,299,	
X213,300,	214,301,	215,302,	216,303,	
X217,304,	218,305,	219,306,	220,307,	
X221,308,	222,309,	223,310,	224,311,	
X225,312,	226,313,	227,314,	228,315,	
X229,316,	230,317,	231,318,	232,319,	
X233,320,	235,321,	236,322,	237,323,	
X238,324,	239,325,	240,326,	51,145,	
X51,145,	51,145,	241,327,	242,328,	
X243,329,	244,330,	245,331,	246,332,	
X248,333,	249,334,	250,335,	251,336,	
X252,337,	254,338,	255,339,	256,340,	
X257,341,	258,342,	259,343,	261,344,	
X262,345,	263,346,	265,347,	266,348,	
X267,349,	270,350,	271,351,	272,352,	
X274,353,	275,354,	276,355,	277,356,	
X278,357,	279,358,	280,359,	281,360,	
X283,361,	284,362,	285,363,	286,364,	
X290,365,	291,366,	292,367,	293,368,	
X294,369,	295,370,	297,371,	298,372,	
X299,373,	300,374,	301,375,	303,376,	
X304,377,	305,378,	306,379,	307,380,	
X309,381,	310,382,	311,383,	313,384,	
X314,385,	315,386,	316,387,	317,388,	
X318,389,	319,390,	320,391,	322,392,	
X323,393,	324,394,	327,395,	328,396,	
X330,397,	331,398,	332,399,	333,400,	
X334,401,	336,402,	337,403,	338,404,	
X339,405,	341,406,	342,407,	343,408,	
X345,409,	346,410,	347,411,	348,412,	
X349,413,	351,414,	352,415,	353,416,	
X356,417,	358,418,	359,419,	360,420,	
X361,421,	363,422,	364,423,	365,424,	
X367,425,	368,426,	369,428,	370,429,	
X371,430,	372,431,	373,432,	368,427,	
X374,433,	375,434,	376,435,	377,436,	
X378,437,	379,438,	380,439,	382,440,	
X383,441,	384,442,	386,443,	388,444,	
X389,445,	390,446,	392,447,	393,448,	
X395,449,	396,416,	399,450,	400,451,	
X401,452,	402,453,	403,454,	404,455,	
X406,456,	407,457,	408,458,	409,459,	
X412,460,	414,461,	415,462,	416,463,	
X418,464,	424,465,	426,466,	427,467,	
X428,468,	429,469,	430,470,	432,471,	
X433,472,	434,473,	435,474,	436,475,	
X437,476,	440,477,	442,478,	444,479,	
X445,480,	447,481,	448,482,	450,483,	
X451,484,	452,485,	453,486,	454,487,	
X455,488,	456,489,	459,490,	460,491,	
X462,495,	466,496,	467,497,	468,498,	
X470,499,	471,500,	472,501,	473,502,	
X477,503,	460,492,	478,504,	460,493,	
X460,494,	480,505,	481,506,	482,507,	
X484,508,	485,509,	490,510,	491,511,	
X492,512,	493,513,	494,514,	495,515,	
X496,516,	497,517,	498,518,	499,519,	
X500,520,	501,521,	503,522,	505,523,	
X508,524,	510,525,	511,526,	512,527,	
X513,528,	514,529,	515,530,	517,531,	
X522,532,	523,533,	525,534,	526,535,	
X527,536,	528,537,	529,538,	530,539,	
X533,540,	534,541,	535,542,	536,543,	
X537,544,	538,545,	539,546,	540,547,	
X542,548,	543,549,	544,550,	545,551,	
X546,552,	548,553,	549,554,	550,555,	
X552,556,	553,557,	554,558,	556,559,	
X557,560,	0,0,	0,0,	0,0,	
X0,0};
Xstruct yysvf yysvec[] = {
X0,	0,	0,
Xyycrank+-1,	0,		0,	
Xyycrank+-84,	yysvec+1,	0,	
Xyycrank+-179,	yysvec+1,	0,	
Xyycrank+-291,	0,		0,	
Xyycrank+0,	0,		yyvstop+1,
Xyycrank+5,	0,		yyvstop+3,
Xyycrank+0,	0,		yyvstop+6,
Xyycrank+-7,	0,		yyvstop+8,
Xyycrank+-403,	0,		yyvstop+10,
Xyycrank+83,	0,		yyvstop+12,
Xyycrank+0,	yysvec+10,	yyvstop+14,
Xyycrank+0,	0,		yyvstop+17,
Xyycrank+6,	0,		yyvstop+20,
Xyycrank+4,	0,		yyvstop+22,
Xyycrank+15,	0,		yyvstop+24,
Xyycrank+10,	0,		yyvstop+26,
Xyycrank+12,	0,		yyvstop+28,
Xyycrank+17,	0,		yyvstop+30,
Xyycrank+28,	0,		yyvstop+32,
Xyycrank+13,	0,		yyvstop+34,
Xyycrank+39,	0,		yyvstop+36,
Xyycrank+79,	0,		yyvstop+38,
Xyycrank+49,	0,		yyvstop+40,
Xyycrank+7,	0,		yyvstop+42,
Xyycrank+16,	0,		yyvstop+44,
Xyycrank+100,	0,		yyvstop+46,
Xyycrank+131,	0,		yyvstop+48,
Xyycrank+74,	0,		yyvstop+50,
Xyycrank+10,	0,		yyvstop+52,
Xyycrank+72,	0,		yyvstop+54,
Xyycrank+109,	0,		yyvstop+56,
Xyycrank+123,	0,		yyvstop+58,
Xyycrank+10,	0,		yyvstop+60,
Xyycrank+80,	0,		yyvstop+62,
Xyycrank+73,	0,		yyvstop+64,
Xyycrank+108,	0,		yyvstop+66,
Xyycrank+124,	0,		yyvstop+68,
Xyycrank+156,	0,		yyvstop+70,
Xyycrank+101,	0,		yyvstop+72,
Xyycrank+130,	0,		yyvstop+74,
Xyycrank+21,	0,		yyvstop+76,
Xyycrank+133,	0,		yyvstop+78,
Xyycrank+171,	0,		yyvstop+80,
Xyycrank+61,	0,		yyvstop+82,
Xyycrank+14,	0,		yyvstop+84,
Xyycrank+24,	0,		yyvstop+86,
Xyycrank+-410,	0,		yyvstop+88,
Xyycrank+41,	yysvec+22,	yyvstop+90,
Xyycrank+0,	0,		yyvstop+92,
Xyycrank+417,	0,		yyvstop+95,
Xyycrank+456,	0,		yyvstop+98,
Xyycrank+254,	yysvec+51,	yyvstop+100,
Xyycrank+65,	yysvec+51,	yyvstop+102,
Xyycrank+63,	yysvec+51,	yyvstop+104,
Xyycrank+134,	yysvec+51,	yyvstop+106,
Xyycrank+68,	0,		yyvstop+108,
Xyycrank+69,	yysvec+51,	yyvstop+110,
Xyycrank+167,	yysvec+51,	yyvstop+112,
Xyycrank+94,	yysvec+51,	yyvstop+114,
Xyycrank+187,	yysvec+51,	yyvstop+116,
Xyycrank+109,	yysvec+51,	yyvstop+118,
Xyycrank+-289,	yysvec+47,	yyvstop+120,
Xyycrank+0,	yysvec+6,	yyvstop+122,
Xyycrank+0,	yysvec+8,	0,	
Xyycrank+0,	0,		yyvstop+124,
Xyycrank+158,	0,		0,	
Xyycrank+0,	yysvec+10,	yyvstop+126,
Xyycrank+126,	0,		0,	
Xyycrank+168,	0,		0,	
Xyycrank+169,	0,		0,	
Xyycrank+157,	0,		0,	
Xyycrank+162,	0,		0,	
Xyycrank+178,	0,		0,	
Xyycrank+183,	0,		0,	
Xyycrank+199,	0,		0,	
Xyycrank+180,	0,		0,	
Xyycrank+190,	0,		0,	
Xyycrank+194,	0,		0,	
Xyycrank+200,	0,		0,	
Xyycrank+206,	0,		0,	
Xyycrank+198,	0,		0,	
Xyycrank+195,	0,		0,	
Xyycrank+203,	0,		0,	
Xyycrank+219,	0,		0,	
Xyycrank+235,	0,		0,	
Xyycrank+236,	0,		0,	
Xyycrank+241,	0,		0,	
Xyycrank+237,	0,		0,	
Xyycrank+239,	0,		0,	
Xyycrank+247,	0,		0,	
Xyycrank+241,	0,		0,	
Xyycrank+244,	0,		0,	
Xyycrank+262,	0,		0,	
Xyycrank+262,	0,		0,	
Xyycrank+253,	0,		0,	
Xyycrank+266,	0,		0,	
Xyycrank+257,	0,		0,	
Xyycrank+230,	0,		0,	
Xyycrank+228,	0,		0,	
Xyycrank+241,	0,		0,	
Xyycrank+239,	0,		0,	
Xyycrank+225,	0,		0,	
Xyycrank+231,	0,		0,	
Xyycrank+229,	0,		0,	
Xyycrank+234,	0,		0,	
Xyycrank+248,	0,		0,	
Xyycrank+236,	0,		0,	
Xyycrank+234,	0,		0,	
Xyycrank+231,	0,		0,	
Xyycrank+236,	0,		0,	
Xyycrank+237,	0,		0,	
Xyycrank+250,	0,		0,	
Xyycrank+246,	0,		0,	
Xyycrank+247,	0,		0,	
Xyycrank+268,	0,		0,	
Xyycrank+248,	0,		0,	
Xyycrank+246,	0,		0,	
Xyycrank+278,	0,		0,	
Xyycrank+256,	0,		0,	
Xyycrank+278,	0,		0,	
Xyycrank+319,	0,		0,	
Xyycrank+265,	0,		0,	
Xyycrank+271,	0,		0,	
Xyycrank+267,	0,		0,	
Xyycrank+359,	0,		0,	
Xyycrank+279,	0,		0,	
Xyycrank+285,	0,		0,	
Xyycrank+290,	0,		0,	
Xyycrank+297,	0,		0,	
Xyycrank+287,	0,		0,	
Xyycrank+295,	0,		0,	
Xyycrank+299,	0,		0,	
Xyycrank+311,	0,		0,	
Xyycrank+300,	0,		0,	
Xyycrank+306,	0,		0,	
Xyycrank+306,	0,		0,	
Xyycrank+332,	0,		0,	
Xyycrank+0,	0,		yyvstop+128,
Xyycrank+309,	0,		0,	
Xyycrank+0,	yysvec+47,	0,	
Xyycrank+0,	0,		yyvstop+130,
Xyycrank+349,	0,		0,	
Xyycrank+0,	0,		yyvstop+132,
Xyycrank+0,	yysvec+50,	yyvstop+134,
Xyycrank+0,	yysvec+51,	0,	
Xyycrank+348,	yysvec+51,	0,	
Xyycrank+365,	0,		0,	
Xyycrank+373,	yysvec+51,	0,	
Xyycrank+365,	yysvec+51,	0,	
Xyycrank+371,	yysvec+51,	0,	
Xyycrank+0,	0,		yyvstop+136,
Xyycrank+-444,	yysvec+47,	0,	
Xyycrank+0,	0,		yyvstop+139,
Xyycrank+383,	0,		0,	
Xyycrank+372,	0,		0,	
Xyycrank+377,	0,		0,	
Xyycrank+375,	0,		0,	
Xyycrank+379,	0,		0,	
Xyycrank+377,	0,		0,	
Xyycrank+383,	0,		0,	
Xyycrank+396,	0,		0,	
Xyycrank+392,	0,		0,	
Xyycrank+394,	0,		0,	
Xyycrank+404,	0,		0,	
Xyycrank+390,	0,		0,	
Xyycrank+409,	0,		0,	
Xyycrank+409,	0,		0,	
Xyycrank+411,	0,		0,	
Xyycrank+398,	0,		0,	
Xyycrank+402,	0,		0,	
Xyycrank+417,	0,		0,	
Xyycrank+424,	0,		0,	
Xyycrank+399,	0,		0,	
Xyycrank+426,	0,		0,	
Xyycrank+420,	0,		0,	
Xyycrank+414,	0,		0,	
Xyycrank+435,	0,		0,	
Xyycrank+432,	0,		0,	
Xyycrank+429,	0,		0,	
Xyycrank+432,	0,		0,	
Xyycrank+435,	0,		0,	
Xyycrank+428,	0,		0,	
Xyycrank+442,	0,		0,	
Xyycrank+432,	0,		0,	
Xyycrank+437,	0,		0,	
Xyycrank+411,	0,		0,	
Xyycrank+418,	0,		0,	
Xyycrank+415,	0,		0,	
Xyycrank+410,	0,		0,	
Xyycrank+403,	0,		0,	
Xyycrank+403,	0,		0,	
Xyycrank+413,	0,		0,	
Xyycrank+414,	0,		0,	
Xyycrank+409,	0,		0,	
Xyycrank+415,	0,		0,	
Xyycrank+412,	0,		0,	
Xyycrank+413,	0,		0,	
Xyycrank+420,	0,		0,	
Xyycrank+417,	0,		0,	
Xyycrank+418,	0,		0,	
Xyycrank+421,	0,		0,	
Xyycrank+422,	0,		0,	
Xyycrank+430,	0,		0,	
Xyycrank+442,	0,		0,	
Xyycrank+445,	0,		0,	
Xyycrank+430,	0,		0,	
Xyycrank+0,	0,		yyvstop+141,
Xyycrank+431,	0,		0,	
Xyycrank+435,	0,		0,	
Xyycrank+0,	0,		yyvstop+143,
Xyycrank+443,	0,		0,	
Xyycrank+450,	0,		0,	
Xyycrank+441,	0,		0,	
Xyycrank+455,	0,		0,	
Xyycrank+447,	0,		0,	
Xyycrank+440,	0,		0,	
Xyycrank+440,	0,		0,	
Xyycrank+449,	0,		0,	
Xyycrank+447,	0,		0,	
Xyycrank+450,	0,		0,	
Xyycrank+459,	0,		0,	
Xyycrank+445,	0,		0,	
Xyycrank+461,	0,		0,	
Xyycrank+462,	0,		0,	
Xyycrank+454,	0,		0,	
Xyycrank+466,	0,		0,	
Xyycrank+467,	0,		0,	
Xyycrank+467,	0,		0,	
Xyycrank+464,	0,		0,	
Xyycrank+470,	0,		0,	
Xyycrank+456,	0,		0,	
Xyycrank+466,	0,		0,	
Xyycrank+456,	0,		0,	
Xyycrank+0,	0,		yyvstop+145,
Xyycrank+472,	0,		0,	
Xyycrank+457,	0,		0,	
Xyycrank+470,	0,		0,	
Xyycrank+471,	0,		0,	
Xyycrank+461,	0,		0,	
Xyycrank+568,	0,		0,	
Xyycrank+505,	0,		0,	
Xyycrank+507,	yysvec+51,	0,	
Xyycrank+502,	0,		0,	
Xyycrank+518,	0,		0,	
Xyycrank+519,	0,		0,	
Xyycrank+514,	0,		0,	
Xyycrank+0,	0,		yyvstop+147,
Xyycrank+522,	0,		0,	
Xyycrank+524,	0,		0,	
Xyycrank+507,	0,		0,	
Xyycrank+507,	0,		0,	
Xyycrank+523,	0,		0,	
Xyycrank+0,	0,		yyvstop+149,
Xyycrank+498,	0,		0,	
Xyycrank+525,	0,		0,	
Xyycrank+519,	0,		0,	
Xyycrank+509,	0,		yyvstop+151,
Xyycrank+532,	0,		0,	
Xyycrank+514,	0,		0,	
Xyycrank+0,	0,		yyvstop+153,
Xyycrank+519,	0,		0,	
Xyycrank+532,	0,		0,	
Xyycrank+534,	0,		0,	
Xyycrank+0,	0,		yyvstop+155,
Xyycrank+537,	0,		0,	
Xyycrank+524,	0,		0,	
Xyycrank+525,	0,		0,	
Xyycrank+0,	0,		yyvstop+157,
Xyycrank+0,	0,		yyvstop+159,
Xyycrank+523,	0,		0,	
Xyycrank+527,	0,		0,	
Xyycrank+527,	0,		0,	
Xyycrank+0,	0,		yyvstop+161,
Xyycrank+535,	0,		0,	
Xyycrank+499,	0,		0,	
Xyycrank+496,	0,		0,	
Xyycrank+510,	0,		0,	
Xyycrank+511,	0,		0,	
Xyycrank+498,	0,		0,	
Xyycrank+503,	0,		0,	
Xyycrank+514,	0,		0,	
Xyycrank+0,	0,		yyvstop+163,
Xyycrank+515,	0,		0,	
Xyycrank+502,	0,		0,	
Xyycrank+517,	0,		0,	
Xyycrank+518,	0,		0,	
Xyycrank+0,	0,		yyvstop+165,
Xyycrank+0,	0,		yyvstop+167,
Xyycrank+0,	0,		yyvstop+169,
Xyycrank+523,	0,		0,	
Xyycrank+520,	0,		0,	
Xyycrank+521,	0,		0,	
Xyycrank+578,	0,		0,	
Xyycrank+522,	0,		0,	
Xyycrank+520,	0,		0,	
Xyycrank+0,	0,		yyvstop+171,
Xyycrank+525,	0,		0,	
Xyycrank+526,	0,		0,	
Xyycrank+531,	0,		0,	
Xyycrank+519,	0,		0,	
Xyycrank+524,	0,		0,	
Xyycrank+0,	0,		yyvstop+173,
Xyycrank+515,	0,		0,	
Xyycrank+518,	0,		0,	
Xyycrank+528,	0,		0,	
Xyycrank+523,	0,		0,	
Xyycrank+538,	0,		0,	
Xyycrank+0,	0,		yyvstop+175,
Xyycrank+532,	0,		0,	
Xyycrank+529,	0,		0,	
Xyycrank+539,	0,		0,	
Xyycrank+0,	0,		yyvstop+177,
Xyycrank+538,	0,		0,	
Xyycrank+539,	0,		0,	
Xyycrank+530,	0,		0,	
Xyycrank+526,	0,		0,	
Xyycrank+527,	0,		0,	
Xyycrank+528,	0,		0,	
Xyycrank+535,	0,		0,	
Xyycrank+542,	0,		0,	
Xyycrank+0,	0,		yyvstop+179,
Xyycrank+533,	0,		0,	
Xyycrank+540,	0,		0,	
Xyycrank+533,	0,		0,	
Xyycrank+0,	0,		yyvstop+181,
Xyycrank+0,	0,		yyvstop+183,
Xyycrank+585,	0,		0,	
Xyycrank+578,	yysvec+51,	0,	
Xyycrank+0,	0,		yyvstop+185,
Xyycrank+580,	0,		0,	
Xyycrank+584,	0,		0,	
Xyycrank+586,	0,		0,	
Xyycrank+573,	0,		0,	
Xyycrank+570,	0,		0,	
Xyycrank+0,	0,		yyvstop+187,
Xyycrank+592,	0,		0,	
Xyycrank+574,	0,		0,	
Xyycrank+582,	0,		0,	
Xyycrank+578,	0,		0,	
Xyycrank+0,	0,		yyvstop+189,
Xyycrank+596,	0,		0,	
Xyycrank+591,	0,		0,	
Xyycrank+594,	0,		0,	
Xyycrank+0,	0,		yyvstop+191,
Xyycrank+591,	0,		0,	
Xyycrank+581,	0,		0,	
Xyycrank+590,	0,		0,	
Xyycrank+590,	0,		0,	
Xyycrank+590,	0,		0,	
Xyycrank+0,	0,		yyvstop+193,
Xyycrank+590,	0,		0,	
Xyycrank+591,	0,		0,	
Xyycrank+601,	0,		0,	
Xyycrank+0,	0,		yyvstop+195,
Xyycrank+0,	0,		yyvstop+197,
Xyycrank+560,	0,		0,	
Xyycrank+0,	0,		yyvstop+199,
Xyycrank+572,	0,		0,	
Xyycrank+565,	0,		0,	
Xyycrank+565,	0,		0,	
Xyycrank+562,	0,		0,	
Xyycrank+0,	0,		yyvstop+201,
Xyycrank+577,	0,		0,	
Xyycrank+578,	0,		0,	
Xyycrank+561,	0,		0,	
Xyycrank+0,	0,		yyvstop+203,
Xyycrank+580,	0,		0,	
Xyycrank+573,	0,		0,	
Xyycrank+574,	0,		0,	
Xyycrank+575,	0,		0,	
Xyycrank+581,	0,		0,	
Xyycrank+585,	0,		0,	
Xyycrank+570,	0,		0,	
Xyycrank+573,	0,		0,	
Xyycrank+588,	0,		0,	
Xyycrank+589,	0,		0,	
Xyycrank+594,	0,		0,	
Xyycrank+589,	0,		0,	
Xyycrank+579,	0,		0,	
Xyycrank+582,	0,		0,	
Xyycrank+0,	0,		yyvstop+205,
Xyycrank+594,	0,		0,	
Xyycrank+580,	0,		0,	
Xyycrank+595,	0,		0,	
Xyycrank+0,	0,		yyvstop+207,
Xyycrank+589,	0,		0,	
Xyycrank+0,	0,		yyvstop+209,
Xyycrank+582,	0,		0,	
Xyycrank+585,	0,		0,	
Xyycrank+600,	0,		0,	
Xyycrank+0,	0,		yyvstop+211,
Xyycrank+587,	0,		0,	
Xyycrank+595,	0,		0,	
Xyycrank+0,	0,		yyvstop+213,
Xyycrank+624,	0,		0,	
Xyycrank+635,	yysvec+51,	0,	
Xyycrank+0,	0,		yyvstop+215,
Xyycrank+0,	0,		yyvstop+217,
Xyycrank+627,	0,		0,	
Xyycrank+634,	0,		0,	
Xyycrank+635,	0,		0,	
Xyycrank+636,	0,		0,	
Xyycrank+628,	0,		0,	
Xyycrank+646,	0,		0,	
Xyycrank+0,	0,		yyvstop+219,
Xyycrank+636,	0,		0,	
Xyycrank+644,	0,		0,	
Xyycrank+632,	0,		0,	
Xyycrank+644,	0,		0,	
Xyycrank+0,	0,		yyvstop+221,
Xyycrank+0,	0,		yyvstop+223,
Xyycrank+621,	0,		0,	
Xyycrank+0,	0,		yyvstop+225,
Xyycrank+640,	0,		0,	
Xyycrank+636,	0,		0,	
Xyycrank+630,	0,		0,	
Xyycrank+0,	0,		yyvstop+227,
Xyycrank+620,	0,		0,	
Xyycrank+0,	0,		yyvstop+229,
Xyycrank+0,	0,		yyvstop+231,
Xyycrank+0,	0,		yyvstop+233,
Xyycrank+0,	0,		yyvstop+235,
Xyycrank+0,	0,		yyvstop+237,
Xyycrank+620,	0,		0,	
Xyycrank+0,	0,		yyvstop+239,
Xyycrank+621,	0,		0,	
Xyycrank+618,	0,		0,	
Xyycrank+613,	0,		0,	
Xyycrank+624,	0,		0,	
Xyycrank+621,	0,		0,	
Xyycrank+0,	0,		yyvstop+241,
Xyycrank+610,	0,		0,	
Xyycrank+612,	0,		0,	
Xyycrank+630,	0,		0,	
Xyycrank+616,	0,		0,	
Xyycrank+623,	0,		0,	
Xyycrank+622,	0,		0,	
Xyycrank+0,	0,		yyvstop+243,
Xyycrank+0,	0,		yyvstop+245,
Xyycrank+621,	0,		0,	
Xyycrank+0,	0,		yyvstop+247,
Xyycrank+617,	0,		0,	
Xyycrank+0,	0,		yyvstop+249,
Xyycrank+626,	0,		0,	
Xyycrank+631,	0,		0,	
Xyycrank+0,	0,		yyvstop+251,
Xyycrank+636,	0,		0,	
Xyycrank+637,	0,		0,	
Xyycrank+0,	0,		yyvstop+253,
Xyycrank+657,	0,		0,	
Xyycrank+672,	0,		0,	
Xyycrank+663,	0,		0,	
Xyycrank+664,	0,		0,	
Xyycrank+654,	0,		0,	
Xyycrank+664,	0,		0,	
Xyycrank+670,	0,		0,	
Xyycrank+0,	0,		yyvstop+255,
Xyycrank+0,	0,		yyvstop+257,
Xyycrank+675,	0,		0,	
Xyycrank+680,	0,		0,	
Xyycrank+0,	0,		yyvstop+259,
Xyycrank+664,	0,		0,	
Xyycrank+0,	0,		yyvstop+261,
Xyycrank+0,	0,		yyvstop+263,
Xyycrank+0,	0,		yyvstop+265,
Xyycrank+647,	0,		0,	
Xyycrank+647,	0,		0,	
Xyycrank+640,	0,		0,	
Xyycrank+0,	0,		yyvstop+267,
Xyycrank+641,	0,		0,	
Xyycrank+639,	0,		0,	
Xyycrank+653,	0,		0,	
Xyycrank+639,	0,		0,	
Xyycrank+0,	0,		yyvstop+269,
Xyycrank+0,	0,		yyvstop+271,
Xyycrank+0,	0,		yyvstop+273,
Xyycrank+645,	0,		0,	
Xyycrank+650,	0,		0,	
Xyycrank+0,	0,		yyvstop+275,
Xyycrank+658,	0,		0,	
Xyycrank+662,	0,		0,	
Xyycrank+663,	0,		0,	
Xyycrank+0,	0,		yyvstop+277,
Xyycrank+693,	0,		0,	
Xyycrank+694,	0,		0,	
Xyycrank+0,	0,		yyvstop+279,
Xyycrank+0,	0,		yyvstop+281,
Xyycrank+0,	0,		yyvstop+283,
Xyycrank+0,	0,		yyvstop+285,
Xyycrank+701,	0,		0,	
Xyycrank+688,	0,		0,	
Xyycrank+689,	0,		0,	
Xyycrank+703,	0,		0,	
Xyycrank+694,	0,		0,	
Xyycrank+676,	0,		0,	
Xyycrank+656,	0,		0,	
Xyycrank+669,	0,		0,	
Xyycrank+660,	0,		0,	
Xyycrank+665,	0,		0,	
Xyycrank+675,	0,		0,	
Xyycrank+663,	0,		0,	
Xyycrank+0,	0,		yyvstop+287,
Xyycrank+664,	0,		0,	
Xyycrank+0,	0,		yyvstop+289,
Xyycrank+675,	0,		0,	
Xyycrank+0,	0,		yyvstop+291,
Xyycrank+0,	0,		yyvstop+293,
Xyycrank+711,	0,		0,	
Xyycrank+0,	0,		yyvstop+295,
Xyycrank+715,	0,		0,	
Xyycrank+700,	0,		0,	
Xyycrank+705,	0,		0,	
Xyycrank+710,	0,		0,	
Xyycrank+720,	0,		0,	
Xyycrank+704,	0,		0,	
Xyycrank+0,	0,		yyvstop+297,
Xyycrank+671,	0,		0,	
Xyycrank+0,	0,		yyvstop+299,
Xyycrank+0,	0,		yyvstop+301,
Xyycrank+0,	0,		yyvstop+303,
Xyycrank+0,	0,		yyvstop+305,
Xyycrank+672,	0,		0,	
Xyycrank+673,	0,		0,	
Xyycrank+0,	0,		yyvstop+307,
Xyycrank+714,	0,		0,	
Xyycrank+709,	0,		0,	
Xyycrank+709,	0,		0,	
Xyycrank+724,	0,		0,	
Xyycrank+727,	0,		0,	
Xyycrank+726,	0,		0,	
Xyycrank+0,	0,		yyvstop+309,
Xyycrank+0,	0,		yyvstop+311,
Xyycrank+695,	0,		0,	
Xyycrank+728,	0,		0,	
Xyycrank+725,	0,		0,	
Xyycrank+715,	0,		0,	
Xyycrank+733,	0,		0,	
Xyycrank+732,	0,		0,	
Xyycrank+731,	0,		0,	
Xyycrank+703,	0,		0,	
Xyycrank+0,	0,		yyvstop+313,
Xyycrank+736,	0,		0,	
Xyycrank+736,	0,		0,	
Xyycrank+722,	0,		0,	
Xyycrank+724,	0,		0,	
Xyycrank+735,	0,		0,	
Xyycrank+0,	0,		yyvstop+315,
Xyycrank+730,	0,		0,	
Xyycrank+728,	0,		0,	
Xyycrank+728,	0,		0,	
Xyycrank+0,	0,		yyvstop+317,
Xyycrank+733,	0,		0,	
Xyycrank+731,	0,		0,	
Xyycrank+731,	0,		0,	
Xyycrank+0,	0,		yyvstop+319,
Xyycrank+737,	0,		0,	
Xyycrank+733,	0,		0,	
Xyycrank+0,	0,		yyvstop+321,
Xyycrank+0,	0,		yyvstop+323,
Xyycrank+0,	0,		yyvstop+325,
X0,	0,	0};
Xstruct yywork *yytop = yycrank+816;
Xstruct yysvf *yybgin = yysvec+1;
Xchar yymatch[] = {
X00  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
X01  ,011 ,012 ,01  ,01  ,01  ,01  ,01  ,
X01  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
X01  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
X040 ,01  ,'"' ,'#' ,01  ,01  ,01  ,01  ,
X01  ,01  ,01  ,'+' ,01  ,'+' ,'#' ,01  ,
X'0' ,'0' ,'0' ,'0' ,'0' ,'0' ,'0' ,'0' ,
X'0' ,'0' ,01  ,01  ,01  ,01  ,01  ,01  ,
X01  ,'#' ,'#' ,'#' ,01  ,01  ,01  ,01  ,
X01  ,'#' ,01  ,'#' ,'#' ,01  ,01  ,01  ,
X'#' ,01  ,01  ,'#' ,01  ,01  ,01  ,'#' ,
X01  ,01  ,01  ,01  ,'#' ,01  ,01  ,01  ,
X01  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
X01  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
X01  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
X01  ,01  ,01  ,'#' ,'#' ,'#' ,01  ,01  ,
X0};
Xchar yyextra[] = {
X0,0,0,0,0,0,0,0,
X0,0,0,0,0,0,0,0,
X0,0,0,0,0,0,0,0,
X0,0,0,0,0,0,0,0,
X0,0,0,0,0,0,0,0,
X0,0,0,0,0,0,0,0,
X0,0,0,0,0,0,0,0,
X0,0,0,0,0,0,0,0,
X0,0,0,0,0,0,0,0,
X0,0,0,0,0,0,0,0,
X0,0,0,0,0,0,0,0,
X0,0,0,0,0,0,0,0,
X0,0,0,0,0,0,0,0,
X0};
X#ifndef lint
Xstatic	char ncform_sccsid[] = "@(#)ncform 1.6 88/02/08 SMI"; /* from S5R2 1.2 */
X#endif
X
Xint yylineno =1;
X# define YYU(x) x
X# define NLSTATE yyprevious=YYNEWLINE
Xchar yytext[YYLMAX];
Xstruct yysvf *yylstate [YYLMAX], **yylsp, **yyolsp;
Xchar yysbuf[YYLMAX];
Xchar *yysptr = yysbuf;
Xint *yyfnd;
Xextern struct yysvf *yyestate;
Xint yyprevious = YYNEWLINE;
Xyylook(){
X	register struct yysvf *yystate, **lsp;
X	register struct yywork *yyt;
X	struct yysvf *yyz;
X	int yych, yyfirst;
X	struct yywork *yyr;
X# ifdef LEXDEBUG
X	int debug;
X# endif
X	char *yylastch;
X	/* start off machines */
X# ifdef LEXDEBUG
X	debug = 0;
X# endif
X	yyfirst=1;
X	if (!yymorfg)
X		yylastch = yytext;
X	else {
X		yymorfg=0;
X		yylastch = yytext+yyleng;
X		}
X	for(;;){
X		lsp = yylstate;
X		yyestate = yystate = yybgin;
X		if (yyprevious==YYNEWLINE) yystate++;
X		for (;;){
X# ifdef LEXDEBUG
X			if(debug)fprintf(yyout,"state %d\n",yystate-yysvec-1);
X# endif
X			yyt = yystate->yystoff;
X			if(yyt == yycrank && !yyfirst){  /* may not be any transitions */
X				yyz = yystate->yyother;
X				if(yyz == 0)break;
X				if(yyz->yystoff == yycrank)break;
X				}
X			*yylastch++ = yych = input();
X			yyfirst=0;
X		tryagain:
X# ifdef LEXDEBUG
X			if(debug){
X				fprintf(yyout,"char ");
X				allprint(yych);
X				putchar('\n');
X				}
X# endif
X			yyr = yyt;
X			if ( (int)yyt > (int)yycrank){
X				yyt = yyr + yych;
X				if (yyt <= yytop && yyt->verify+yysvec == yystate){
X					if(yyt->advance+yysvec == YYLERR)	/* error transitions */
X						{unput(*--yylastch);break;}
X					*lsp++ = yystate = yyt->advance+yysvec;
X					goto contin;
X					}
X				}
X# ifdef YYOPTIM
X			else if((int)yyt < (int)yycrank) {		/* r < yycrank */
X				yyt = yyr = yycrank+(yycrank-yyt);
X# ifdef LEXDEBUG
X				if(debug)fprintf(yyout,"compressed state\n");
X# endif
X				yyt = yyt + yych;
X				if(yyt <= yytop && yyt->verify+yysvec == yystate){
X					if(yyt->advance+yysvec == YYLERR)	/* error transitions */
X						{unput(*--yylastch);break;}
X					*lsp++ = yystate = yyt->advance+yysvec;
X					goto contin;
X					}
X				yyt = yyr + YYU(yymatch[yych]);
X# ifdef LEXDEBUG
X				if(debug){
X					fprintf(yyout,"try fall back character ");
X					allprint(YYU(yymatch[yych]));
X					putchar('\n');
X					}
X# endif
X				if(yyt <= yytop && yyt->verify+yysvec == yystate){
X					if(yyt->advance+yysvec == YYLERR)	/* error transition */
X						{unput(*--yylastch);break;}
X					*lsp++ = yystate = yyt->advance+yysvec;
X					goto contin;
X					}
X				}
X			if ((yystate = yystate->yyother) && (yyt= yystate->yystoff) != yycrank){
X# ifdef LEXDEBUG
X				if(debug)fprintf(yyout,"fall back to state %d\n",yystate-yysvec-1);
X# endif
X				goto tryagain;
X				}
X# endif
X			else
X				{unput(*--yylastch);break;}
X		contin:
X# ifdef LEXDEBUG
X			if(debug){
X				fprintf(yyout,"state %d char ",yystate-yysvec-1);
X				allprint(yych);
X				putchar('\n');
X				}
X# endif
X			;
X			}
X# ifdef LEXDEBUG
X		if(debug){
X			fprintf(yyout,"stopped at %d with ",*(lsp-1)-yysvec-1);
X			allprint(yych);
X			putchar('\n');
X			}
X# endif
X		while (lsp-- > yylstate){
X			*yylastch-- = 0;
X			if (*lsp != 0 && (yyfnd= (*lsp)->yystops) && *yyfnd > 0){
X				yyolsp = lsp;
X				if(yyextra[*yyfnd]){		/* must backup */
X					while(yyback((*lsp)->yystops,-*yyfnd) != 1 && lsp > yylstate){
X						lsp--;
X						unput(*yylastch--);
X						}
X					}
X				yyprevious = YYU(*yylastch);
X				yylsp = lsp;
X				yyleng = yylastch-yytext+1;
X				yytext[yyleng] = 0;
X# ifdef LEXDEBUG
X				if(debug){
X					fprintf(yyout,"\nmatch ");
X					sprint(yytext);
X					fprintf(yyout," action %d\n",*yyfnd);
X					}
X# endif
X				return(*yyfnd++);
X				}
X			unput(*yylastch);
X			}
X		if (yytext[0] == 0  /* && feof(yyin) */)
X			{
X			yysptr=yysbuf;
X			return(0);
X			}
X		yyprevious = yytext[0] = input();
X		if (yyprevious>0)
X			output(yyprevious);
X		yylastch=yytext;
X# ifdef LEXDEBUG
X		if(debug)putchar('\n');
X# endif
X		}
X	}
Xyyback(p, m)
X	int *p;
X{
Xif (p==0) return(0);
Xwhile (*p)
X	{
X	if (*p++ == m)
X		return(1);
X	}
Xreturn(0);
X}
X	/* the following are only used in the lex library */
Xyyinput(){
X	return(input());
X	}
Xyyoutput(c)
X  int c; {
X	output(c);
X	}
Xyyunput(c)
X   int c; {
X	unput(c);
X	}
END_OF_FILE
if test 35705 -ne `wc -c <'sys/share/lev_lex.c'`; then
    echo shar: \"'sys/share/lev_lex.c'\" unpacked with wrong size!
fi
# end of 'sys/share/lev_lex.c'
fi
echo shar: End of archive 51 \(of 108\).
cp /dev/null ark51isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \
21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \
41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 \
61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 \
81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 \
101 102 103 104 105 106 107 108 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 108 archives.
    echo "Now execute 'rebuild.sh'"
    rm -f ark10[0-8]isdone ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
