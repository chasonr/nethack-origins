Path: uunet!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v16i072:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Part64/108
Message-ID: <4375@master.CNA.TEK.COM>
Date: 1 Feb 93 19:50:22 GMT
Sender: news@master.CNA.TEK.COM
Lines: 2388
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1622

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 16, Issue 72
Archive-name: nethack31/Part64
Supersedes: nethack3p9: Volume 10, Issue 46-102
Environment: Amiga, Atari, Mac, MS-DOS, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 64 (of 108)."
# Contents:  src/dbridge.c util/lev_main.c
# Wrapped by billr@saab on Wed Jan 27 16:09:12 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'src/dbridge.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/dbridge.c'\"
else
echo shar: Extracting \"'src/dbridge.c'\" \(22283 characters\)
sed "s/^X//" >'src/dbridge.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)dbridge.c	3.1	92/10/24	*/
X/*	Copyright (c) 1989 by Jean-Christophe Collet */
X/* NetHack may be freely redistributed.  See license for details. */
X
X/*
X * This file contains the drawbridge manipulation (create, open, close,
X * destroy).
X *
X * Added comprehensive monster-handling, and the "entity" structure to 
X * deal with players as well. - 11/89
X */
X
X#include "hack.h"
X
X#ifdef OVLB
Xstatic void FDECL(get_wall_for_db, (int *, int *));
Xstatic struct entity *FDECL(e_at, (int, int));
Xstatic void FDECL(m_to_e, (struct monst *, XCHAR_P, XCHAR_P, struct entity *));
Xstatic void FDECL(u_to_e, (struct entity *));
Xstatic void FDECL(set_entity, (int, int, struct entity *));
Xstatic char *FDECL(e_nam, (struct entity *));
X#ifdef D_DEBUG
Xstatic char *FDECL(Enam, (struct entity *)); /* unused */
X#endif
Xstatic char *FDECL(E_phrase, (struct entity *, const char *));
Xstatic boolean FDECL(e_survives_at, (struct entity *, int, int));
Xstatic void FDECL(e_died, (struct entity *, int, int));
Xstatic boolean FDECL(automiss, (struct entity *));
Xstatic boolean FDECL(e_missed, (struct entity *, BOOLEAN_P));
Xstatic boolean FDECL(e_jumps, (struct entity *));
Xstatic void FDECL(do_entity, (struct entity *));
X#endif /* OVLB */
X
X#ifdef OVL0
X
Xboolean
Xis_pool(x,y)
Xint x,y;
X{
X       register schar ltyp = levl[x][y].typ;
X       if(ltyp == POOL || ltyp == MOAT || ltyp == WATER) return TRUE;
X       if(ltyp == DRAWBRIDGE_UP &&
X               (levl[x][y].drawbridgemask & DB_UNDER) == DB_MOAT) return TRUE;
X       return FALSE;
X}
X
Xboolean
Xis_lava(x,y)
Xint x,y;
X{
X       register schar ltyp = levl[x][y].typ;
X       if(ltyp == LAVAPOOL ||
X	  (ltyp == DRAWBRIDGE_UP &&
X	   (levl[x][y].drawbridgemask & DB_UNDER) == DB_LAVA)) return TRUE;
X       return FALSE;
X}
X
Xboolean
Xis_ice(x,y)
Xint x,y;
X{
X	register schar ltyp = levl[x][y].typ;
X	if (ltyp == ICE ||
X	    (ltyp == DRAWBRIDGE_UP &&
X		(levl[x][y].drawbridgemask & DB_UNDER) == DB_ICE)) return TRUE;
X	return FALSE;
X}
X
X#endif /* OVL0 */
X
X#ifdef OVL1
X
X/* 
X * We want to know whether a wall (or a door) is the portcullis (passageway)
X * of an eventual drawbridge.
X *
X * Return value:  the direction of the drawbridge.
X */
X
Xint
Xis_drawbridge_wall(x,y)
Xint x,y;
X{
X	struct rm *lev;
X
X	lev = &levl[x][y];
X	if (lev->typ != DOOR && lev->typ != DBWALL)
X		return (-1);
X
X	if (IS_DRAWBRIDGE(levl[x+1][y].typ) &&
X	    (levl[x+1][y].drawbridgemask & DB_DIR) == DB_WEST)
X		return (DB_WEST);
X	if (IS_DRAWBRIDGE(levl[x-1][y].typ) && 
X	    (levl[x-1][y].drawbridgemask & DB_DIR) == DB_EAST)
X		return (DB_EAST);
X	if (IS_DRAWBRIDGE(levl[x][y-1].typ) && 
X	    (levl[x][y-1].drawbridgemask & DB_DIR) == DB_SOUTH)
X		return (DB_SOUTH);
X	if (IS_DRAWBRIDGE(levl[x][y+1].typ) && 
X	    (levl[x][y+1].drawbridgemask & DB_DIR) == DB_NORTH)
X		return (DB_NORTH);
X
X	return (-1);
X}
X
X/*
X * Use is_db_wall where you want to verify that a
X * drawbridge "wall" is UP in the location x, y
X * (instead of UP or DOWN, as with is_drawbridge_wall). 
X */ 
Xboolean
Xis_db_wall(x,y)
Xint x,y;
X{
X	return( levl[x][y].typ == DBWALL );
X}
X
X
X/*
X * Return true with x,y pointing to the drawbridge if x,y initially indicate
X * a drawbridge or drawbridge wall.
X */
Xboolean
Xfind_drawbridge(x,y)
Xint *x,*y;
X{
X	int dir;
X
X	if (IS_DRAWBRIDGE(levl[*x][*y].typ))
X		return TRUE;
X	dir = is_drawbridge_wall(*x,*y);
X	if (dir >= 0) {
X		switch(dir) {
X			case DB_NORTH: (*y)++; break;
X			case DB_SOUTH: (*y)--; break;
X			case DB_EAST:  (*x)--; break;
X			case DB_WEST:  (*x)++; break;
X		}
X		return TRUE;
X	}
X	return FALSE;
X}
X
X#endif /* OVL1 */
X#ifdef OVLB
X
X/* 
X * Find the drawbridge wall associated with a drawbridge.
X */
Xstatic void
Xget_wall_for_db(x,y)
Xint *x,*y;
X{
X	switch (levl[*x][*y].drawbridgemask & DB_DIR) {
X		case DB_NORTH: (*y)--; break;
X		case DB_SOUTH: (*y)++; break;
X		case DB_EAST:  (*x)++; break;
X		case DB_WEST:  (*x)--; break;
X	}
X}
X
X/*
X * Creation of a drawbridge at pos x,y.
X *     dir is the direction.
X *     flag must be put to TRUE if we want the drawbridge to be opened.
X */
X
Xboolean
Xcreate_drawbridge(x,y,dir,flag)
Xint x,y,dir;
Xboolean flag;
X{
X	int x2,y2;
X	boolean horiz;
X	boolean lava = levl[x][y].typ == LAVAPOOL; /* assume initialized map */
X
X	x2 = x; y2 = y;
X	switch(dir) {
X		case DB_NORTH:
X			horiz = TRUE;
X			y2--;
X			break;
X		case DB_SOUTH:
X			horiz = TRUE;
X			y2++;
X			break;
X		case DB_EAST:
X			horiz = FALSE;
X			x2++;
X			break;
X		default:
X			impossible("bad direction in create_drawbridge");
X			/* fall through */
X		case DB_WEST:
X			horiz = FALSE;
X			x2--;
X			break;
X	}
X	if (!IS_WALL(levl[x2][y2].typ))
X		return(FALSE);
X	if (flag) {             /* We want the bridge open */
X		levl[x][y].typ = DRAWBRIDGE_DOWN;
X		levl[x2][y2].typ = DOOR;
X		levl[x2][y2].doormask = D_NODOOR;
X	} else {
X		levl[x][y].typ = DRAWBRIDGE_UP;
X		levl[x2][y2].typ = DBWALL;
X		/* Drawbridges are non-diggable. */
X		levl[x2][y2].diggable = W_NONDIGGABLE;
X	}
X	levl[x][y].horizontal = !horiz;
X	levl[x2][y2].horizontal = horiz;
X	levl[x][y].drawbridgemask = dir;
X	if(lava) levl[x][y].drawbridgemask |= DB_LAVA;
X	return(TRUE);           
X}
X
Xstruct entity {
X	struct monst *emon;	  /* youmonst for the player */
X	struct permonst *edata;   /* must be non-zero for record to be valid */
X	int ex, ey;
X};
X
X#define ENTITIES 2
X
Xstatic struct entity NEARDATA occupants[ENTITIES];
X
Xstatic
Xstruct entity *
Xe_at(x, y)
Xint x, y;
X{
X	int entitycnt;
X	
X	for (entitycnt = 0; entitycnt < ENTITIES; entitycnt++)
X		if ((occupants[entitycnt].edata) && 
X		    (occupants[entitycnt].ex == x) &&
X		    (occupants[entitycnt].ey == y))
X			break;
X#ifdef D_DEBUG
X	pline("entitycnt = %d", entitycnt);
X	wait_synch();
X#endif
X	return((entitycnt == ENTITIES)? 
X	       (struct entity *)0 : &(occupants[entitycnt]));
X}
X
Xstatic void
Xm_to_e(mtmp, x, y, etmp)
Xstruct monst *mtmp;
Xxchar x, y;
Xstruct entity *etmp;
X{
X	etmp->emon = mtmp;
X	if (mtmp) {
X		etmp->ex = x;
X		etmp->ey = y;
X		if (mtmp->wormno && (x != mtmp->mx || y != mtmp->my))
X			etmp->edata = &mons[PM_LONG_WORM_TAIL];
X		else
X			etmp->edata = mtmp->data;
X	} else
X		etmp->edata = (struct permonst *)0;
X}
X
Xstatic void
Xu_to_e(etmp)
Xstruct entity *etmp;
X{
X	etmp->emon = &youmonst;
X	etmp->ex = u.ux;
X	etmp->ey = u.uy;
X	etmp->edata = uasmon;
X}
X
Xstatic void
Xset_entity(x, y, etmp)
Xint x, y;
Xstruct entity *etmp;
X{
X	if ((x == u.ux) && (y == u.uy))
X		u_to_e(etmp);
X	else
X		if (MON_AT(x, y))
X			m_to_e(m_at(x, y), x, y, etmp);
X		else
X			etmp->edata = (struct permonst *)0;
X}
X
X#define is_u(etmp) (etmp->emon == &youmonst)
X#define e_canseemon(etmp) (is_u(etmp) ? (boolean)TRUE : canseemon(etmp->emon)) 
X
X/*
X * e_strg is a utility routine which is not actually in use anywhere, since 
X * the specialized routines below suffice for all current purposes. 
X */
X
X/* #define e_strg(etmp, func) (is_u(etmp)? (char *)0 : func(etmp->emon)) */
X
Xstatic char *
Xe_nam(etmp)
Xstruct entity *etmp;
X{
X	return(is_u(etmp)? "you" : mon_nam(etmp->emon));
X}
X
X#ifdef D_DEBUG
X/*
X * Enam is another unused utility routine:  E_phrase is preferable.
X */
X
Xstatic char *
XEnam(etmp)
Xstruct entity *etmp;
X{
X	return(is_u(etmp)? "You" : Monnam(etmp->emon));
X}
X#endif /* D_DEBUG */
X
X/*
X * Generates capitalized entity name, makes 2nd -> 3rd person conversion on 
X * verb, where necessary.
X */
X
Xstatic char *
XE_phrase(etmp, verb)
Xstruct entity *etmp;
Xconst char *verb;
X{
X	static char wholebuf[80];
X	char verbbuf[30];
X
X	if (is_u(etmp)) 
X		Strcpy(wholebuf, "You");
X	else
X		Strcpy(wholebuf, Monnam(etmp->emon));
X	if (!*verb)
X		return(wholebuf);
X	Strcat(wholebuf, " ");
X	verbbuf[0] = '\0';
X	if (is_u(etmp)) 
X		Strcpy(verbbuf, verb);
X	else {
X		if (!strcmp(verb, "are"))
X			Strcpy(verbbuf, "is");
X		if (!strcmp(verb, "have"))
X			Strcpy(verbbuf, "has");
X		if (!verbbuf[0]) {
X			Strcpy(verbbuf, verb);
X			switch (verbbuf[strlen(verbbuf) - 1]) {
X				case 'y':
X					verbbuf[strlen(verbbuf) - 1] = '\0';
X					Strcat(verbbuf, "ies");
X					break;
X				case 'h':
X				case 'o':
X				case 's':
X					Strcat(verbbuf, "es");
X					break;
X				default:
X					Strcat(verbbuf, "s");
X					break;
X			}
X		}
X	}
X	Strcat(wholebuf, verbbuf);
X	return(wholebuf);
X}
X
X/*
X * Simple-minded "can it be here?" routine
X */
X
Xstatic boolean
Xe_survives_at(etmp, x, y)
Xstruct entity *etmp;
Xint x, y;
X{
X	if (noncorporeal(etmp->edata))
X		return(TRUE);
X	if (is_pool(x, y))
X		return((is_u(etmp) && (Wwalking || Magical_breathing || Levitation)) ||
X		       is_swimmer(etmp->edata) || is_flyer(etmp->edata) ||
X		       is_floater(etmp->edata));
X	/* must force call to lava_effects in e_died if is_u */
X	if (is_lava(x, y))
X		return(is_u(etmp) ? !!Levitation : resists_fire(etmp->edata));
X	if (is_db_wall(x, y))
X		return(passes_walls(etmp->edata));
X	return(TRUE);
X}
X
Xstatic void
Xe_died(etmp, dest, how)
Xstruct entity *etmp;
Xint dest, how;
X{
X	if (is_u(etmp)) {
X		if (how == DROWNING)
X			(void) drown();
X		if (how == BURNING)
X			(void) lava_effects();
X		else {
X			coord xy;
X
X			killer_format = KILLED_BY_AN;
X			killer = "falling drawbridge";
X			done(how);
X			/* So, you didn't die */
X			if (!e_survives_at(etmp, etmp->ex, etmp->ey)) {
X			    if (enexto(&xy, etmp->ex, etmp->ey,
X							    etmp->edata)) {
X				pline("A %s force teleports you away...",
X				      Hallucination ? "normal" : "strange");
X				teleds(xy.x, xy.y);
X			    }
X			    /* otherwise on top of the drawbridge is the
X			     * only viable spot in the dungeon, so stay there
X			     */
X			}
X		}
X	} else {
X		xkilled(etmp->emon, dest);
X		etmp->edata = (struct permonst *)0;	
X	}
X}
X
X
X/*
X * These are never directly affected by a bridge or portcullis.
X */
X
Xstatic boolean
Xautomiss(etmp)
Xstruct entity *etmp;
X{
X	return(passes_walls(etmp->edata) || noncorporeal(etmp->edata));
X}
X
X/*
X * Does falling drawbridge or portcullis miss etmp?
X */
X
Xstatic boolean
Xe_missed(etmp, chunks)
Xstruct entity *etmp;
Xboolean chunks;
X{
X	int misses;
X
X#ifdef D_DEBUG
X	if (chunks)
X		pline("Do chunks miss?");
X#endif
X	if (automiss(etmp))
X		return(TRUE);	
X
X	if (is_flyer(etmp->edata) && 
X	    (is_u(etmp)? !Sleeping : 
X	     (etmp->emon->mcanmove && !etmp->emon->msleep)))
X						 /* flying requires mobility */
X		misses = 5;	/* out of 8 */	
X	else
X		if (is_floater(etmp->edata) ||
X		    (is_u(etmp) && Levitation))	 /* doesn't require mobility */
X			misses = 3;
X		else
X			if (chunks && is_pool(etmp->ex, etmp->ey))
X				misses = 2; 		    /* sitting ducks */
X			else
X				misses = 0;	  
X
X	if (is_db_wall(etmp->ex, etmp->ey))
X		misses -= 3;				    /* less airspace */
X
X#ifdef D_DEBUG
X	pline("Miss chance = %d (out of 8)", misses);
X#endif
X
X	return((misses >= rnd(8))? TRUE : FALSE);
X}
X
X/*
X * Can etmp jump from death?
X */ 
X
Xstatic boolean
Xe_jumps(etmp)
Xstruct entity *etmp;
X{
X	int tmp = 4; 		/* out of 10 */
X
X	if (is_u(etmp)? (Sleeping || Fumbling) : 
X		        (!etmp->emon->mcanmove || etmp->emon->msleep || 
X			 !etmp->edata->mmove   || etmp->emon->wormno))
X		return(FALSE);
X
X	if (is_u(etmp)? Confusion : etmp->emon->mconf)
X		tmp -= 2;
X
X	if (is_u(etmp)? Stunned : etmp->emon->mstun)
X		tmp -= 3;
X
X	if (is_db_wall(etmp->ex, etmp->ey))
X		tmp -= 2;			    /* less room to maneuver */
X	
X#ifdef D_DEBUG
X	pline("%s to jump (%d chances in 10)", E_phrase(etmp, "try"), tmp);
X#endif
X	return((tmp >= rnd(10))? TRUE : FALSE);
X}
X
Xstatic void
Xdo_entity(etmp)
Xstruct entity *etmp;
X{
X	int newx, newy, at_portcullis, oldx, oldy;
X	boolean must_jump = FALSE, relocates = FALSE, e_inview;
X	struct rm *crm;
X
X	if (!etmp->edata)
X		return;
X
X	e_inview = e_canseemon(etmp);
X
X	oldx = etmp->ex;
X	oldy = etmp->ey;
X
X	at_portcullis = is_db_wall(oldx, oldy);
X
X	crm = &levl[oldx][oldy];
X
X	if (automiss(etmp) && e_survives_at(etmp, oldx, oldy)) {
X		char edifice[20];
X
X		if (e_inview) {
X			*edifice = '\0';
X			if ((crm->typ == DRAWBRIDGE_DOWN) ||
X		    	    (crm->typ == DRAWBRIDGE_UP))
X				Strcpy(edifice, "drawbridge");
X			else
X     				if (at_portcullis) 
X					Strcpy(edifice, "portcullis");
X			if (*edifice)
X				pline("The %s passes through %s!", edifice, 
X			      	      e_nam(etmp));			
X		}
X		return;
X	}
X	if (e_missed(etmp, FALSE)) { 
X		if (at_portcullis)
X			pline("The portcullis misses %s!",
X			      e_nam(etmp));
X#ifdef D_DEBUG
X		else
X			pline("The drawbridge misses %s!", 
X			      e_nam(etmp));
X#endif
X		if (e_survives_at(etmp, oldx, oldy)) 
X			return;
X		else {
X#ifdef D_DEBUG
X			pline("Mon can't survive here");
X#endif
X			if (at_portcullis)
X				must_jump = TRUE;
X			else
X				relocates = TRUE; /* just ride drawbridge in */
X		}
X	} else {
X		if (crm->typ == DRAWBRIDGE_DOWN) {
X			pline("%s crushed underneath the drawbridge.",
X		      	      E_phrase(etmp, "are"));	   	  /* no jump */
X			e_died(etmp, e_inview? 3 : 2, CRUSHING);/* no corpse */
X			return;   /* Note: Beyond this point, we know we're  */
X		}                 /* not at an opened drawbridge, since all  */
X		must_jump = TRUE; /* *missable* creatures survive on the     */
X	}			  /* square, and all the unmissed ones die.  */
X	if (must_jump) {
X	    if (at_portcullis) {
X		if (e_jumps(etmp)) {
X		    relocates = TRUE;
X#ifdef D_DEBUG
X		    pline("Jump succeeds!");
X#endif
X		} else {
X		    if (e_inview)
X			pline("%s crushed by the falling portcullis!",
X			      E_phrase(etmp, "are"));
X		    else if (flags.soundok)
X			You("hear a crushing sound.");
X		    e_died(etmp, e_inview? 3 : 2, CRUSHING);
X		    /* no corpse */
X		    return;
X		}
X	    } else { /* tries to jump off bridge to original square */
X		relocates = !e_jumps(etmp); 
X#ifdef D_DEBUG
X		pline("Jump %s!", (relocates)? "fails" : "succeeds");
X#endif
X	    }
X	}
X
X/*
X * Here's where we try to do relocation.  Assumes that etmp is not arriving
X * at the portcullis square while the drawbridge is falling, since this square
X * would be inaccessible (i.e. etmp started on drawbridge square) or 
X * unnecessary (i.e. etmp started here) in such a situation.
X */
X#ifdef D_DEBUG
X	pline("Doing relocation.");
X#endif
X	newx = oldx;
X	newy = oldy;
X	(void)find_drawbridge(&newx, &newy);
X	if ((newx == oldx) && (newy == oldy))
X		get_wall_for_db(&newx, &newy);
X#ifdef D_DEBUG
X	pline("Checking new square for occupancy.");
X#endif
X	if (relocates && (e_at(newx, newy))) { 
X
X/* 
X * Standoff problem:  one or both entities must die, and/or both switch 
X * places.  Avoid infinite recursion by checking first whether the other 
X * entity is staying put.  Clean up if we happen to move/die in recursion.
X */
X		struct entity *other;
X
X		other = e_at(newx, newy);
X#ifdef D_DEBUG
X		pline("New square is occupied by %s", e_nam(other));
X#endif
X		if (e_survives_at(other, newx, newy) && automiss(other)) {
X			relocates = FALSE;     	      /* "other" won't budge */
X#ifdef D_DEBUG
X			pline("%s suicide.", E_phrase(etmp, "commit"));
X#endif
X		} else {
X
X#ifdef D_DEBUG
X			pline("Handling %s", e_nam(other));
X#endif
X			while ((e_at(newx, newy)) && 
X			       (e_at(newx, newy) != etmp))
X		       		do_entity(other);
X#ifdef D_DEBUG
X			pline("Checking existence of %s", e_nam(etmp));
X			wait_synch();
X#endif
X			if (e_at(oldx, oldy) != etmp) {
X#ifdef D_DEBUG
X			    pline("%s moved or died in recursion somewhere",
X				  E_phrase(etmp, "have"));
X			    wait_synch();
X#endif
X			    return;
X			}
X		}
X	}
X	if (relocates && !e_at(newx, newy)) {/* if e_at() entity = worm tail */
X#ifdef D_DEBUG
X		pline("Moving %s", e_nam(etmp));
X#endif
X		if (!is_u(etmp)) {
X			remove_monster(etmp->ex, etmp->ey);
X			place_monster(etmp->emon, newx, newy);
X		} else {
X			u.ux = newx;
X			u.uy = newy;
X		}
X		etmp->ex = newx;
X		etmp->ey = newy;
X		e_inview = e_canseemon(etmp);
X	}
X#ifdef D_DEBUG
X	pline("Final disposition of %s", e_nam(etmp));
X	wait_synch();
X#endif
X	if (is_db_wall(etmp->ex, etmp->ey)) {
X#ifdef D_DEBUG
X		pline("%s in portcullis chamber", E_phrase(etmp, "are"));
X		wait_synch();
X#endif
X		if (e_inview) {
X			if (is_u(etmp)) {
X				You("tumble towards the closed portcullis!"); 
X				if (automiss(etmp))
X					You("pass through it!");
X				else
X					pline("The drawbridge closes in...");
X			} else
X				pline("%s behind the drawbridge.",
X		      	      	      E_phrase(etmp, "disappear"));
X		}
X		if (!e_survives_at(etmp, etmp->ex, etmp->ey)) {
X			killer_format = KILLED_BY_AN;
X			killer = "closing drawbridge";
X			e_died(etmp, 0, CRUSHING); 	       /* no message */
X			return;
X		}
X#ifdef D_DEBUG
X		pline("%s in here", E_phrase(etmp, "survive"));
X#endif
X	} else {
X#ifdef D_DEBUG
X		pline("%s on drawbridge square", E_phrase(etmp, "are"));
X#endif
X		if (is_pool(etmp->ex, etmp->ey) && !e_inview)
X			if (flags.soundok)
X				You("hear a splash.");
X		if (e_survives_at(etmp, etmp->ex, etmp->ey)) {
X			if (e_inview && !is_flyer(etmp->edata) &&
X			    !is_floater(etmp->edata))
X				pline("%s from the bridge.",
X		      	      	      E_phrase(etmp, "fall"));	
X			return;	
X		}
X#ifdef D_DEBUG
X		pline("%s cannot survive on the drawbridge square",Enam(etmp));
X#endif
X		if (is_pool(etmp->ex, etmp->ey) || is_lava(etmp->ex, etmp->ey))
X		    if (e_inview && !is_u(etmp)) {
X			/* drown() will supply msgs if nec. */
X			boolean lava = is_lava(etmp->ex, etmp->ey);
X
X			if (Hallucination)
X			    pline("%s the %s and disappears.",
X				  E_phrase(etmp, "drink"),
X				  lava ? "lava" : "moat");
X			else
X			    pline("%s into the %s.",
X				  E_phrase(etmp, "fall"),
X				  lava ? "lava" : "moat");
X		    }
X		killer_format = NO_KILLER_PREFIX;
X		killer = "fell from a drawbridge";
X		e_died(etmp, e_inview ? 3 : 2,      /* CRUSHING is arbitrary */
X		       (is_pool(etmp->ex, etmp->ey)) ? DROWNING :
X		       (is_lava(etmp->ex, etmp->ey)) ? BURNING :
X						       CRUSHING); /*no corpse*/
X		return;
X	}
X}
X
X/*
X * Close the drawbridge located at x,y
X */
X
Xvoid
Xclose_drawbridge(x,y)
Xint x,y;
X{
X	register struct rm *lev1, *lev2;
X	int x2, y2;
X
X	lev1 = &levl[x][y];
X	if (lev1->typ != DRAWBRIDGE_DOWN) return;
X	x2 = x; y2 = y;
X	get_wall_for_db(&x2,&y2);
X	if (cansee(x,y))  /* change msgs if you are a w-walker at portcullis */
X		You("see a drawbridge %s up!", 
X		    ((u.ux == x2) && (u.uy == y2))? "coming" : "going");
X	lev1->typ = DRAWBRIDGE_UP;
X	lev2 = &levl[x2][y2];
X	lev2->typ = DBWALL;
X	switch (lev1->drawbridgemask & DB_DIR) {
X		case DB_NORTH:
X		case DB_SOUTH:
X			lev2->horizontal = TRUE;
X			break;
X		case DB_WEST:
X		case DB_EAST:
X			lev2->horizontal = FALSE;
X			break;
X	}
X	lev2->diggable = W_NONDIGGABLE;
X	set_entity(x, y, &(occupants[0]));
X	set_entity(x2, y2, &(occupants[1]));
X	do_entity(&(occupants[0]));		/* Do set_entity after first */
X	set_entity(x2, y2, &(occupants[1]));	/* do_entity for worm tail */
X	do_entity(&(occupants[1]));
X	if(OBJ_AT(x,y) && flags.soundok)
X	    You("hear smashing and crushing.");
X	(void) revive_nasty(x,y,NULL);
X	(void) revive_nasty(x2,y2,NULL);
X	delallobj(x, y);
X	newsym(x, y);
X	delallobj(x2, y2);
X	newsym(x2, y2);
X	block_point(x2,y2);	/* vision */
X}
X
X/* 
X * Open the drawbridge located at x,y
X */
X
Xvoid
Xopen_drawbridge(x,y)
Xint x,y;
X{
X	register struct rm *lev1, *lev2;
X	int x2, y2;
X
X	lev1 = &levl[x][y];
X	if (lev1->typ != DRAWBRIDGE_UP) return;
X	x2 = x; y2 = y;
X	get_wall_for_db(&x2,&y2);
X	if (cansee(x,y))  /* change msgs if you are a w-walker at portcullis */
X		You("see a drawbridge %s down!",
X		    ((x2 == u.ux) && (y2 == u.uy))? "going" : "coming");
X	lev1->typ = DRAWBRIDGE_DOWN;
X	lev2 = &levl[x2][y2];
X	lev2->typ = DOOR;
X	lev2->doormask = D_NODOOR;
X	set_entity(x, y, &(occupants[0]));
X	set_entity(x2, y2, &(occupants[1]));
X	do_entity(&(occupants[0]));		/* do set_entity after first */
X	set_entity(x2, y2, &(occupants[1]));	/* do_entity for worm tails */
X	do_entity(&(occupants[1]));
X	spoteffects();  /* if underwater, hero is now on solid ground */
X	(void) revive_nasty(x,y,NULL);
X	delallobj(x, y);
X	newsym(x, y);
X	newsym(x2, y2);
X	unblock_point(x2,y2);	/* vision */
X	if (Is_stronghold(&u.uz)) u.uevent.uopened_dbridge = TRUE;
X}
X
X/*
X * Let's destroy the drawbridge located at x,y
X */
X
Xvoid
Xdestroy_drawbridge(x,y)
Xint x,y;
X{
X	register struct rm *lev1, *lev2;
X	int x2, y2;
X	boolean e_inview;
X	struct entity *etmp1 = &(occupants[0]), *etmp2 = &(occupants[1]);
X
X	lev1 = &levl[x][y];
X	if (!IS_DRAWBRIDGE(lev1->typ))
X		return;
X	x2 = x; y2 = y;
X	get_wall_for_db(&x2,&y2);
X	lev2 = &levl[x2][y2];
X	if ((lev1->drawbridgemask & DB_UNDER) == DB_MOAT ||
X	    (lev1->drawbridgemask & DB_UNDER) == DB_LAVA) {
X		struct obj *otmp;
X		boolean lava = (lev1->drawbridgemask & DB_UNDER) == DB_LAVA;
X		if (lev1->typ == DRAWBRIDGE_UP) {
X			if (cansee(x2,y2))
X			    pline("The portcullis of the drawbridge falls into the %s!",
X				  lava ? "lava" : "moat");
X			else if (flags.soundok)
X				You("hear a loud *SPLASH*!");
X		} else {
X			if (cansee(x,y))
X			    pline("The drawbridge collapses into the %s!",
X				  lava ? "lava" : "moat");
X			else if (flags.soundok)
X				You("hear a loud *SPLASH*!");
X		}
X		lev1->typ = lava ? LAVAPOOL : MOAT;
X		lev1->drawbridgemask = 0;
X		if(otmp = sobj_at(BOULDER,x,y)) {
X		    freeobj(otmp);
X		    (void) flooreffects(otmp,x,y,"fall");
X		}
X	} else {
X		if (cansee(x,y))
X			pline("The drawbridge disintegrates!");
X		else
X			You("hear a loud *CRASH*!");
X		lev1->typ =
X			((lev1->drawbridgemask & DB_ICE) ? ICE : ROOM);
X		lev1->icedpool =
X			((lev1->drawbridgemask & DB_ICE) ? ICED_MOAT : 0);
X	}
X	wake_nearby();
X	lev2->typ = DOOR;
X	lev2->doormask = D_NODOOR;
X	newsym(x,y);
X	newsym(x2,y2);
X	if (!does_block(x2,y2,lev2)) unblock_point(x2,y2);	/* vision */
X	if (Is_stronghold(&u.uz)) u.uevent.uopened_dbridge = TRUE;
X
X	set_entity(x2, y2, etmp2); /* currently only automissers can be here */
X	if (etmp2->edata) {
X		e_inview = e_canseemon(etmp2);
X		if (!automiss(etmp2)) {
X			if (e_inview)
X				pline("%s blown apart by flying debris.",
X			      	      E_phrase(etmp2, "are"));
X			killer_format = KILLED_BY_AN;
X			killer = "exploding drawbridge";
X			e_died(etmp2, e_inview? 3 : 2, CRUSHING); /*no corpse*/
X		}	     /* nothing which is vulnerable can survive this */
X	}
X	set_entity(x, y, etmp1);
X	if (etmp1->edata) {
X		e_inview = e_canseemon(etmp1);
X		if (e_missed(etmp1, TRUE)) {
X#ifdef D_DEBUG
X			pline("%s spared!", E_phrase(etmp1, "are"));
X#endif
X		} else {
X			if (e_inview) {
X			    if (!is_u(etmp1) && Hallucination)
X				pline("%s into some heavy metal",
X				      E_phrase(etmp1, "get"));
X			    else
X				pline("%s hit by a huge chunk of metal!",
X				      E_phrase(etmp1, "are"));
X			} else {
X			    if (flags.soundok && !is_u(etmp1) && !is_pool(x,y))
X				You("hear a crushing sound");
X#ifdef D_DEBUG
X			    else
X				pline("%s from shrapnel", 
X				      E_phrase(etmp1, "die"));
X#endif
X			}
X			killer_format = KILLED_BY_AN;
X			killer = "collapsing drawbridge";
X			e_died(etmp1, e_inview? 3 : 2, CRUSHING); /*no corpse*/
X			if(lev1->typ == MOAT) do_entity(etmp1);
X		}
X	}
X}
X
X
X#endif /* OVLB */
X
X/*dbridge.c*/
END_OF_FILE
if test 22283 -ne `wc -c <'src/dbridge.c'`; then
    echo shar: \"'src/dbridge.c'\" unpacked with wrong size!
fi
# end of 'src/dbridge.c'
fi
if test -f 'util/lev_main.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'util/lev_main.c'\"
else
echo shar: Extracting \"'util/lev_main.c'\" \(31210 characters\)
sed "s/^X//" >'util/lev_main.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)lev_main.c	3.1	92/12/11	*/
X/*	Copyright (c) 1989 by Jean-Christophe Collet */
X/* NetHack may be freely redistributed.  See license for details. */
X
X/*
X * This file contains the main function for the parser
X * and some useful functions needed by yacc
X */
X
X#include "hack.h"
X#include "sp_lev.h"
X#ifdef STRICT_REF_DEF
X#include "termcap.h"
X#endif
X
X#ifdef MAC
X# ifdef applec
X#  define MPWTOOL
X#  include <CursorCtl.h>
X# endif
X#endif
X
X#ifndef MPWTOOL
X# define SpinCursor(x)
X#endif
X
X#ifndef O_WRONLY
X# include <fcntl.h>
X#endif
X#ifndef O_CREAT	/* some older BSD systems do not define O_CREAT in <fcntl.h> */
X# include <sys/file.h>
X#endif
X#ifndef O_BINARY	/* used for micros, no-op for others */
X# define O_BINARY 0
X#endif
X
X#define NEWLINE	10	/* under Mac MPW C '\n' is 13 so don't use it. */
X
X#define ERR		(-1)
X
X#define NewTab(type, size)	(type **) alloc(sizeof(type *) * size)
X#define Free(ptr)		if(ptr) free((genericptr_t) (ptr))
X#define Write(fd, item, size)	(void) write(fd, (genericptr_t)(item), size)
X
X#ifdef MICRO
X# undef exit
X# ifndef AMIGA
Xextern void FDECL(exit, (int));
X# endif
X#endif
X
X#define MAX_ERRORS	25
X
Xextern int  NDECL (yyparse);
Xextern void FDECL (init_yyin, (FILE *));
Xextern void FDECL (init_yyout, (FILE *));
X
Xint  FDECL (main, (int, char **));
Xvoid FDECL (yyerror, (char *));
Xvoid FDECL (yywarning, (char *));
Xint  NDECL (yywrap);
Xchar *FDECL(dup_string,(const char *));
Xint FDECL(get_floor_type, (CHAR_P));
Xint FDECL(get_room_type, (char *));
Xint FDECL(get_trap_type, (char *));
Xint FDECL(get_monster_id, (char *, CHAR_P));
Xint FDECL(get_object_id, (char *));
Xboolean FDECL(check_monster_char, (CHAR_P));
Xboolean FDECL(check_object_char, (CHAR_P));
Xchar FDECL(what_map_char, (CHAR_P));
Xvoid FDECL(scan_map, (char *));
Xvoid NDECL(wallify_map);
Xboolean NDECL(check_subrooms);
Xvoid FDECL(check_coord, (int, int, char *));
Xvoid NDECL(store_part);
Xvoid NDECL(store_room);
Xstatic void FDECL(write_common_data, (int,int,lev_init *,long));
Xvoid FDECL(write_maze, (int, specialmaze *));
Xvoid FDECL(write_lev, (int, splev *));
Xvoid FDECL(free_rooms, (room **, int));
X
Xstatic struct {
X	const char *name;
X	short type;
X} trap_types[TRAPNUM] = {
X	{ "arrow",	ARROW_TRAP },
X	{ "dart",	DART_TRAP },
X	{ "falling rock", ROCKTRAP },
X	{ "board",	SQKY_BOARD },
X	{ "bear",	BEAR_TRAP },
X	{ "land mine",	LANDMINE },
X	{ "sleep gas",	SLP_GAS_TRAP },
X	{ "rust",	RUST_TRAP },
X	{ "fire",	FIRE_TRAP },
X	{ "pit",	PIT },
X	{ "spiked pit",	SPIKED_PIT },
X	{ "trapdoor",	TRAPDOOR },
X	{ "teleport",	TELEP_TRAP },
X	{ "level teleport", LEVEL_TELEP },
X	{ "magic portal",   MAGIC_PORTAL },
X	{ "web",	WEB },
X	{ "statue",	STATUE_TRAP },
X	{ "magic",	MAGIC_TRAP },
X	{ "anti magic",	ANTI_MAGIC },
X#ifdef POLYSELF
X	{ "polymorph",	POLY_TRAP },
X#endif
X	{ 0, 0 }
X};
X
Xstatic struct {
X	char *name;
X	int type;
X} room_types[] = {
X	/* for historical reasons, room types are not contiguous numbers */
X	/* (type 1 is skipped) */
X	{ "ordinary",	 OROOM },
X	{ "throne",	 COURT },
X	{ "swamp",	 SWAMP },
X	{ "vault",	 VAULT },
X	{ "beehive",	 BEEHIVE },
X	{ "morgue",	 MORGUE },
X#ifdef ARMY
X	{ "barracks",	 BARRACKS },
X#endif
X	{ "zoo",	 ZOO },
X	{ "delphi",	 DELPHI },
X	{ "temple",	 TEMPLE },
X	{ "shop",	 SHOPBASE },
X	{ "armor shop",	 ARMORSHOP },
X	{ "scroll shop", SCROLLSHOP },
X	{ "potion shop", POTIONSHOP },
X	{ "weapon shop", WEAPONSHOP },
X	{ "food shop",	 FOODSHOP },
X	{ "ring shop",	 RINGSHOP },
X	{ "wand shop",	 WANDSHOP },
X	{ "tool shop",	 TOOLSHOP },
X	{ "book shop",	 BOOKSHOP },
X	{ "candle shop", CANDLESHOP },
X	{ 0, 0 }
X};
X
Xchar *fname = "(stdin)";
Xint fatal_error = 0;
Xint want_warnings = 0;
X
X/* Flex 2.3 bug work around */
Xint yy_more_len = 0;
X
Xextern char tmpmessage[];
Xextern altar *tmpaltar[];
Xextern lad *tmplad[];
Xextern stair *tmpstair[];
Xextern digpos *tmpdig[];
Xextern char *tmpmap[];
Xextern region *tmpreg[];
Xextern lev_region *tmplreg[];
Xextern door *tmpdoor[];
Xextern room_door *tmprdoor[];
Xextern trap *tmptrap[];
Xextern monster *tmpmonst[];
Xextern object *tmpobj[];
Xextern drawbridge *tmpdb[];
Xextern walk *tmpwalk[];
Xextern gold *tmpgold[];
Xextern fountain *tmpfountain[];
Xextern sink *tmpsink[];
Xextern pool *tmppool[];
Xextern engraving *tmpengraving[];
Xextern mazepart *tmppart[];
Xextern room *tmproom[];
Xextern corridor *tmpcor[];
X
Xextern int n_olist, n_mlist, n_plist;
X
Xextern unsigned int nlreg, nreg, ndoor, ntrap, nmons, nobj;
Xextern unsigned int ndb, nwalk, npart, ndig, nlad, nstair;
Xextern unsigned int naltar, ncorridor, nrooms, ngold, nengraving;
Xextern unsigned int nfountain, npool, nsink;
X
Xextern unsigned int max_x_map, max_y_map;
X
Xextern int line_number, colon_line_number;
X
Xint
Xmain(argc, argv)
Xint argc;
Xchar **argv;
X{
X	FILE *fin;
X	int i;
X#ifdef MAC_THINKC5
X	static char *mac_argv[] = {	"lev_comp",	/* dummy argv[0] */
X				":dat:Arch.des",
X				":dat:Barb.des",
X				":dat:Caveman.des",
X				":dat:Elf.des",
X				":dat:Healer.des",
X				":dat:Knight.des",
X				":dat:Priest.des",
X				":dat:Rogue.des",
X				":dat:Samurai.des",
X				":dat:Tourist.des",
X				":dat:Valkyrie.des",
X				":dat:Wizard.des",
X				":dat:bigroom.des",
X				":dat:castle.des",
X				":dat:endgame.des",
X				":dat:gehennom.des",
X				":dat:knox.des",
X				":dat:medusa.des",
X				":dat:mines.des",
X				":dat:oracle.des",
X				":dat:tower.des",
X				":dat:yendor.des"
X				};
X
X	argc = SIZE(mac_argv);
X	argv = mac_argv;
X#endif
X	/* Note:  these initializers don't do anything except guarantee that
X		we're linked properly.
X	*/
X	monst_init();
X	objects_init();
X	decl_init();
X
X	init_yyout(stdout);
X	if (argc == 1) {		/* Read standard input */
X	    init_yyin(stdin);
X	    yyparse();
X	} else {			/* Otherwise every argument is a filename */
X	    for(i=1; i<argc; i++) {
X		    fname = argv[i];
X		    if(!strcmp(fname, "-w")) {
X			want_warnings++;
X			continue;
X		    }
X		    fin = freopen(fname, "r", stdin);
X		    if (!fin) {
X			(void) fprintf(stderr,"Can't open \"%s\" for input.\n",
X						fname);
X			perror(fname);
X		    } else {
X			init_yyin(fin);
X			yyparse();
X		    }
X		    line_number = 1;
X		    fatal_error = 0;
X	    }
X	}
X#ifndef VMS
X	return 0;
X#else
X	return 1;       /* vms success */
X#endif /*VMS*/
X}
X
X/*
X * Each time the parser detects an error, it uses this function.
X * Here we take count of the errors. To continue farther than
X * MAX_ERRORS wouldn't be reasonable.
X * Assume that explicit calls from lev_comp.y have the 1st letter
X * capitalized, to allow printing of the line containing the start of
X * the current declaration, instead of the beginning of the next declaration.
X */
X
Xvoid
Xyyerror(s)
Xchar *s;
X{
X	(void) fprintf(stderr, "%s: line %d : %s\n", fname,
X		(*s >= 'A' && *s <= 'Z') ? colon_line_number : line_number, s);
X	if (++fatal_error > MAX_ERRORS) {
X		(void) fprintf(stderr,"Too many errors, good bye!\n");
X		exit(1);
X	}
X}
X
X/*
X * Just display a warning (that is : a non fatal error)
X */
X
Xvoid
Xyywarning(s)
Xchar *s;
X{
X	(void) fprintf(stderr, "%s: line %d : WARNING : %s\n",
X				fname, colon_line_number, s);
X}
X
Xint
Xyywrap()
X{
X	return 1;
X}
X
X/*
X * Duplicate a string.
X */
X
Xchar *
Xdup_string(s)
Xconst char *s;
X{
X	char *news;
X
X	if (!s)
X	    return (char *) 0;
X	news = (char *) alloc(strlen(s)+1);
X	Strcpy(news, s);
X	return news;
X}
X
X/*
X * Find the type of floor, knowing its char representation.
X */
X
Xint
Xget_floor_type(c)
Xchar c;
X{
X	int val;
X
X	SpinCursor(3);
X	val = what_map_char(c);
X	if(val == INVALID_TYPE) {
X	    val = ERR;
X	    yywarning("Invalid fill character in MAZE declaration");
X	}
X	return val;
X}
X
X/*
X * Find the type of a room in the table, knowing its name.
X */
X
Xint
Xget_room_type(s)
Xchar *s;
X{
X	register int i;
X
X	SpinCursor(3);
X	for(i=0; room_types[i].name; i++)
X	    if (!strcmp(s, room_types[i].name))
X		return ((int) room_types[i].type);
X	return ERR;
X}
X
X/*
X * Find the type of a trap in the table, knowing its name.
X */
X
Xint
Xget_trap_type(s)
Xchar *s;
X{
X	register int i;
X
X	SpinCursor(3);
X	for(i=0; i < TRAPNUM - 1; i++)
X	    if(!strcmp(s,trap_types[i].name))
X		return((int)trap_types[i].type);
X	return ERR;
X}
X
X/*
X * Find the index of a monster in the table, knowing its name.
X */
Xint
Xget_monster_id(s, c)
Xchar *s;
Xchar c;
X{
X	register int i, class;
X
X	SpinCursor(3);
X	class = def_char_to_monclass(c);
X	if (c && class == MAXMCLASSES) return ERR;
X
X	for(i = 0; i < NUMMONS; i++)
X	    if(!strncmp(s, mons[i].mname, strlen(mons[i].mname))
X	       && (!c || class == mons[i].mlet))
X		return i;
X	return ERR;
X}
X
X/*
X * Find the index of an object in the table, knowing its name.
X */
Xint
Xget_object_id(s)
Xchar *s;
X{
X	register int i;
X	register const char *objname;
X
X	SpinCursor(3);
X	for (i=0; i<=NROFOBJECTS; i++)
X	    if ((objname = obj_descr[i].oc_name)
X	       && !strncmp(s, objname, strlen(objname)))
X		return i;
X	return ERR;
X}
X
X/*
X * Is the character 'c' a valid monster class ?
X */
Xboolean
Xcheck_monster_char(c)
Xchar c;
X{
X	return (def_char_to_monclass(c) != MAXMCLASSES);
X}
X
X/*
X * Is the character 'c' a valid object class ?
X */
Xboolean
Xcheck_object_char(c)
Xchar c;
X{
X	return (def_char_to_objclass(c) != MAXOCLASSES);
X}
X
Xchar
Xwhat_map_char(c)
X
X     char	c;
X{
X	SpinCursor(3);
X	switch(c) {
X		  case ' '  : return(STONE);
X		  case '#'  : return(CORR);
X		  case '.'  : return(ROOM);
X		  case '-'  : return(HWALL);
X		  case '|'  : return(VWALL);
X		  case '+'  : return(DOOR);
X		  case 'A'  : return(AIR);
X		  case 'B'  : return(CROSSWALL); /* hack: boundary location */
X		  case 'C'  : return(CLOUD);
X		  case 'S'  : return(SDOOR);
X		  case '{'  : return(FOUNTAIN);
X		  case '\\' : return(THRONE);
X		  case 'K'  :
X#ifdef SINKS
X		      return(SINK);
X#else
X		      yywarning("Sinks are not allowed in this version!  Ignoring...");
X		      return(ROOM);
X#endif
X		  case '}'  : return(MOAT);
X		  case 'P'  : return(POOL);
X		  case 'L'  : return(LAVAPOOL);
X		  case 'I'  : return(ICE);
X		  case 'W'  : return(WATER);
X	    }
X	return(INVALID_TYPE);
X}
X
X/*
X * Yep! LEX gives us the map in a raw mode.
X * Just analyze it here.
X */
X
Xvoid
Xscan_map(map)
Xchar *map;
X{
X	register int i, len;
X	register char *s1, *s2;
X	int max_len = 0;
X	int max_hig = 0;
X	char msg[256];
X
X	/* First : find the max width of the map */
X
X	s1 = map;
X	while (s1 && *s1) {
X		s2 = index(s1, NEWLINE);
X		if (s2) {
X			if (s2-s1 > max_len)
X			    max_len = s2-s1;
X			s1 = s2 + 1;
X		} else {
X			if (strlen(s1) > max_len)
X			    max_len = strlen(s1);
X			s1 = (char *) 0;
X		}
X	}
X
X	/* Then parse it now */
X
X	while (map && *map) {
X		tmpmap[max_hig] = (char *) alloc(max_len);
X		s1 = index(map, NEWLINE);
X		if (s1) {
X			len = s1 - map;
X			s1++;
X		} else {
X			len = strlen(map);
X			s1 = map + len;
X		}
X		for(i=0; i<len; i++)
X		  if((tmpmap[max_hig][i] = what_map_char(map[i])) == INVALID_TYPE) {
X		      Sprintf(msg,
X			 "Invalid character @ (%d, %d) - replacing with stone",
X			      max_hig, i);
X		      yywarning(msg);
X		      tmpmap[max_hig][i] = STONE;
X		    }
X		while(i < max_len)
X		    tmpmap[max_hig][i++] = STONE;
X		map = s1;
X		max_hig++;
X	}
X
X	/* Memorize boundaries */
X
X	max_x_map = max_len - 1;
X	max_y_map = max_hig - 1;
X
X	/* Store the map into the mazepart structure */
X
X	if(max_len > MAP_X_LIM || max_hig > MAP_Y_LIM) {
X	    Sprintf(msg, "Map too large! (max %d x %d)", MAP_X_LIM, MAP_Y_LIM);
X	    yyerror(msg);
X	}
X
X	tmppart[npart]->xsize = max_len;
X	tmppart[npart]->ysize = max_hig;
X	tmppart[npart]->map = (char **) alloc(max_hig*sizeof(char *));
X	for(i = 0; i< max_hig; i++)
X	    tmppart[npart]->map[i] = tmpmap[i];
X}
X
X/*
X *	If we have drawn a map without walls, this allows us to
X *	auto-magically wallify it.
X */
X#define Map_point(x,y) *(tmppart[npart]->map[y] + x)
X#define Valid_point(x,y) ((x >= 0 && x <= max_x_map) && \
X			  (y >= 0 && y <= max_y_map))
Xvoid
Xwallify_map()
X{
X
X	int x, y, xx, yy;
X
X	for(y = 0; y <= max_y_map; y++) {
X	  SpinCursor(3);
X	  for(x = 0; x <= max_x_map; x++)
X
X	    if(Map_point(x,y) == STONE) {
X
X	      for(yy = y - 1; yy <= y+1 && Map_point(x,y) == STONE; yy++)
X		for(xx = x - 1; xx <= x+1 && Map_point(x,y) == STONE; xx++)
X
X		  if(Valid_point(xx,yy) &&
X		     (IS_ROOM(Map_point(xx,yy)) ||
X		      Map_point(xx,yy) == CROSSWALL)) {
X
X		    if(yy != y)	Map_point(x,y) = HWALL;
X		    else	Map_point(x,y) = VWALL;
X		  }
X	    }
X	}
X}
X
X/*
X * We need to check the subrooms apartenance to an existing room.
X */
X
Xboolean
Xcheck_subrooms()
X{
X	short i,j;
X	boolean found, ok = TRUE;
X	char msg[256];
X
X	for (i = 0; i < nrooms; i++)
X	    if (tmproom[i]->parent) {
X		    found = FALSE;
X		    for(j = 0; j < nrooms; j++)
X			if (tmproom[j]->name && !strcmp(tmproom[i]->parent,
X							tmproom[j]->name)) {
X				found = TRUE;
X				break;
X			}
X		    if (!found) {
X			    Sprintf(msg,"Subroom error : parent room '%s' not found!", tmproom[i]->parent);
X			    yyerror(msg);
X			    ok = FALSE;
X		    }
X	    }
X	return ok;
X}
X
X/*
X * Check that coordinates (x,y) are roomlike locations.
X * Print warning "str" if they aren't.
X */
X
Xvoid
Xcheck_coord(x, y, str)
Xint x, y;
Xchar *str;
X{
X    char ebuf[60];
X
X    if (x >= 0 && y >= 0 && x <= max_x_map && y <= max_y_map &&
X	(IS_ROCK(tmpmap[y][x]) || IS_DOOR(tmpmap[y][x]))) {
X	Sprintf(ebuf, "%s placed in wall at (%02d,%02d)?!", str, x, y);
X	yywarning(ebuf);
X    }
X}
X
X/*
X * Here we want to store the maze part we just got.
X */
X
Xvoid
Xstore_part()
X{
X	register int i;
X
X	/* Ok, We got the whole part, now we store it. */
X
X	/* The Regions */
X
X	if ((tmppart[npart]->nreg = nreg) != 0) {
X		tmppart[npart]->regions = NewTab(region, nreg);
X		for(i=0;i<nreg;i++)
X		    tmppart[npart]->regions[i] = tmpreg[i];
X	}
X	nreg = 0;
X
X	/* The Level Regions */
X
X	if ((tmppart[npart]->nlreg = nlreg) != 0) {
X		tmppart[npart]->lregions = NewTab(lev_region, nlreg);
X		for(i=0;i<nlreg;i++)
X		    tmppart[npart]->lregions[i] = tmplreg[i];
X	}
X	nlreg = 0;
X
X	/* the doors */
X
X	if ((tmppart[npart]->ndoor = ndoor) != 0) {
X		tmppart[npart]->doors = NewTab(door, ndoor);
X		for(i=0;i<ndoor;i++)
X		    tmppart[npart]->doors[i] = tmpdoor[i];
X	}
X	ndoor = 0;
X
X	/* the traps */
X
X	if ((tmppart[npart]->ntrap = ntrap) != 0) {
X		tmppart[npart]->traps = NewTab(trap, ntrap);
X		for(i=0;i<ntrap;i++)
X		    tmppart[npart]->traps[i] = tmptrap[i];
X	}
X	ntrap = 0;
X
X	/* the monsters */
X
X	if ((tmppart[npart]->nmonster = nmons) != 0) {
X		tmppart[npart]->monsters = NewTab(monster, nmons);
X		for(i=0;i<nmons;i++)
X		    tmppart[npart]->monsters[i] = tmpmonst[i];
X	}
X	nmons = 0;
X
X	/* the objects */
X
X	if ((tmppart[npart]->nobject = nobj) != 0) {
X		tmppart[npart]->objects = NewTab(object, nobj);
X		for(i=0;i<nobj;i++)
X		    tmppart[npart]->objects[i] = tmpobj[i];
X	}
X	nobj = 0;
X
X	/* the drawbridges */
X
X	if ((tmppart[npart]->ndrawbridge = ndb) != 0) {
X		tmppart[npart]->drawbridges = NewTab(drawbridge, ndb);
X		for(i=0;i<ndb;i++)
X		    tmppart[npart]->drawbridges[i] = tmpdb[i];
X	}
X	ndb = 0;
X
X	/* The walkmaze directives */
X
X	if ((tmppart[npart]->nwalk = nwalk) != 0) {
X		tmppart[npart]->walks = NewTab(walk, nwalk);
X		for(i=0;i<nwalk;i++)
X		    tmppart[npart]->walks[i] = tmpwalk[i];
X	}
X	nwalk = 0;
X
X	/* The non_diggable directives */
X
X	if ((tmppart[npart]->ndig = ndig) != 0) {
X		tmppart[npart]->digs = NewTab(digpos, ndig);
X		for(i=0;i<ndig;i++)
X		    tmppart[npart]->digs[i] = tmpdig[i];
X	}
X	ndig = 0;
X
X	/* The ladders */
X
X	if ((tmppart[npart]->nlad = nlad) != 0) {
X		tmppart[npart]->lads = NewTab(lad, nlad);
X		for(i=0;i<nlad;i++)
X		    tmppart[npart]->lads[i] = tmplad[i];
X	}
X	nlad = 0;
X
X	/* The stairs */
X
X	if ((tmppart[npart]->nstair = nstair) != 0) {
X		tmppart[npart]->stairs = NewTab(stair, nstair);
X		for(i=0;i<nstair;i++)
X		    tmppart[npart]->stairs[i] = tmpstair[i];
X	}
X	nstair = 0;
X
X	/* The altars */
X	if ((tmppart[npart]->naltar = naltar) != 0) {
X		tmppart[npart]->altars = NewTab(altar, naltar);
X		for(i=0;i<naltar;i++)
X		    tmppart[npart]->altars[i] = tmpaltar[i];
X	}
X	naltar = 0;
X
X	/* The gold piles */
X
X	if ((tmppart[npart]->ngold = ngold) != 0) {
X		tmppart[npart]->golds = NewTab(gold, ngold);
X		for(i=0;i<ngold;i++)
X		    tmppart[npart]->golds[i] = tmpgold[i];
X	}
X	ngold = 0;
X
X	/* The engravings */
X
X	if ((tmppart[npart]->nengraving = nengraving) != 0) {
X		tmppart[npart]->engravings = NewTab(engraving, nengraving);
X		for(i=0;i<nengraving;i++)
X		    tmppart[npart]->engravings[i] = tmpengraving[i];
X	}
X	nengraving = 0;
X
X	/* The fountains */
X
X	if ((tmppart[npart]->nfountain = nfountain) != 0) {
X		tmppart[npart]->fountains = NewTab(fountain, nfountain);
X		for(i=0;i<nfountain;i++)
X		    tmppart[npart]->fountains[i] = tmpfountain[i];
X	}
X	nfountain = 0;
X
X	npart++;
X	n_plist = n_mlist = n_olist = 0;
X}
X
X/*
X * Here we want to store the room part we just got.
X */
X
Xvoid
Xstore_room()
X{
X	register int i;
X
X	/* Ok, We got the whole room, now we store it. */
X
X	/* the doors */
X
X	if ((tmproom[nrooms]->ndoor = ndoor) != 0) {
X		tmproom[nrooms]->doors = NewTab(room_door, ndoor);
X		for(i=0;i<ndoor;i++)
X		    tmproom[nrooms]->doors[i] = tmprdoor[i];
X	}
X	ndoor = 0;
X
X	/* the traps */
X
X	if ((tmproom[nrooms]->ntrap = ntrap) != 0) {
X		tmproom[nrooms]->traps = NewTab(trap, ntrap);
X		for(i=0;i<ntrap;i++)
X		    tmproom[nrooms]->traps[i] = tmptrap[i];
X	}
X	ntrap = 0;
X
X	/* the monsters */
X
X	if ((tmproom[nrooms]->nmonster = nmons) != 0) {
X		tmproom[nrooms]->monsters = NewTab(monster, nmons);
X		for(i=0;i<nmons;i++)
X		    tmproom[nrooms]->monsters[i] = tmpmonst[i];
X	}
X	nmons = 0;
X
X	/* the objects */
X
X	if ((tmproom[nrooms]->nobject = nobj) != 0) {
X		tmproom[nrooms]->objects = NewTab(object, nobj);
X		for(i=0;i<nobj;i++)
X		    tmproom[nrooms]->objects[i] = tmpobj[i];
X	}
X	nobj = 0;
X
X	/* The stairs */
X
X	if ((tmproom[nrooms]->nstair = nstair) != 0) {
X		tmproom[nrooms]->stairs = NewTab(stair, nstair);
X		for(i=0;i<nstair;i++)
X		    tmproom[nrooms]->stairs[i] = tmpstair[i];
X	}
X	nstair = 0;
X
X	/* The altars */
X	if ((tmproom[nrooms]->naltar = naltar) != 0) {
X		tmproom[nrooms]->altars = NewTab(altar, naltar);
X		for(i=0;i<naltar;i++)
X		    tmproom[nrooms]->altars[i] = tmpaltar[i];
X	}
X	naltar = 0;
X
X	/* The gold piles */
X
X	if ((tmproom[nrooms]->ngold = ngold) != 0) {
X		tmproom[nrooms]->golds = NewTab(gold, ngold);
X		for(i=0;i<ngold;i++)
X		    tmproom[nrooms]->golds[i] = tmpgold[i];
X	}
X	ngold = 0;
X
X	/* The engravings */
X
X	if ((tmproom[nrooms]->nengraving = nengraving) != 0) {
X		tmproom[nrooms]->engravings = NewTab(engraving, nengraving);
X		for(i=0;i<nengraving;i++)
X		    tmproom[nrooms]->engravings[i] = tmpengraving[i];
X	}
X	nengraving = 0;
X
X	/* The fountains */
X
X	if ((tmproom[nrooms]->nfountain = nfountain) != 0) {
X		tmproom[nrooms]->fountains = NewTab(fountain, nfountain);
X		for(i=0;i<nfountain;i++)
X		    tmproom[nrooms]->fountains[i] = tmpfountain[i];
X	}
X	nfountain = 0;
X
X	/* The sinks */
X
X	if ((tmproom[nrooms]->nsink = nsink) != 0) {
X		tmproom[nrooms]->sinks = NewTab(sink, nsink);
X		for(i=0;i<nsink;i++)
X		    tmproom[nrooms]->sinks[i] = tmpsink[i];
X	}
X	nsink = 0;
X
X	/* The pools */
X
X	if ((tmproom[nrooms]->npool = npool) != 0) {
X		tmproom[nrooms]->pools = NewTab(pool, npool);
X		for(i=0;i<npool;i++)
X		    tmproom[nrooms]->pools[i] = tmppool[i];
X	}
X	npool = 0;
X
X	nrooms++;
X}
X
X/* some info common to all special levels */
Xstatic void
Xwrite_common_data(fd, typ, init, flgs)
Xint fd, typ;
Xlev_init *init;
Xlong flgs;
X{
X	char c;
X	uchar len;
X
X	c = typ;
X	Write(fd, &c, sizeof(c));	/* 1 byte header */
X	Write(fd, init, sizeof(lev_init));
X	Write(fd, &flgs, sizeof flgs);
X
X	len = strlen(tmpmessage);
X	Write(fd, &len, sizeof len);
X	if (len) Write(fd, tmpmessage, (int) len);
X	tmpmessage[0] = '\0';
X}
X
X/*
X * Here we write the structure of the maze in the specified file (fd).
X * Also, we have to free the memory allocated via alloc()
X */
X
Xvoid
Xwrite_maze(fd, maze)
Xint fd;
Xspecialmaze *maze;
X{
X	short i,j;
X	mazepart *pt;
X
X	write_common_data(fd, SP_LEV_MAZE, &(maze->init_lev), maze->flags);
X
X	Write(fd, &(maze->filling), sizeof(maze->filling));
X	Write(fd, &(maze->numpart), sizeof(maze->numpart));
X					 /* Number of parts */
X	for(i=0;i<maze->numpart;i++) {
X	    pt = maze->parts[i];
X
X	    /* First, write the map */
X
X	    Write(fd, &(pt->halign), sizeof(pt->halign));
X	    Write(fd, &(pt->valign), sizeof(pt->valign));
X	    Write(fd, &(pt->xsize), sizeof(pt->xsize));
X	    Write(fd, &(pt->ysize), sizeof(pt->ysize));
X	    for(j=0;j<pt->ysize;j++) {
X		if(!maze->init_lev.init_present ||
X		   pt->xsize > 1 || pt->ysize > 1)
X		    Write(fd, pt->map[j], sizeof(*(pt->map[j])) * pt->xsize);
X		Free(pt->map[j]);
X	    }
X	    Free(pt->map);
X
X	    /* level region stuff */
X	    Write(fd, &(pt->nlreg), sizeof(pt->nlreg));
X	    for(j=0;j<pt->nlreg;j++) {
X		    Write(fd, pt->lregions[j], sizeof(lev_region));
X		    if(pt->lregions[j]->rname) {
X			    char c = strlen(pt->lregions[j]->rname);
X			    Write(fd, &c, sizeof(c));
X			    Write(fd, pt->lregions[j]->rname, (int)c);
X		    }
X		    Free(pt->lregions[j]);
X	    }
X	    if(pt->nlreg > 0)
X		    Free(pt->lregions);
X
X	    /* The random registers */
X	    Write(fd, &(pt->nrobjects), sizeof(pt->nrobjects));
X	    if(pt->nrobjects) {
X		    Write(fd, pt->robjects, pt->nrobjects);
X		    Free(pt->robjects);
X	    }
X	    Write(fd, &(pt->nloc), sizeof(pt->nloc));
X	    if(pt->nloc) {
X		    Write(fd, pt->rloc_x, pt->nloc);
X		    Write(fd, pt->rloc_y, pt->nloc);
X		    Free(pt->rloc_x);
X		    Free(pt->rloc_y);
X	    }
X	    Write(fd, &(pt->nrmonst), sizeof(pt->nrmonst));
X	    if(pt->nrmonst) {
X		    Write(fd, pt->rmonst, pt->nrmonst);
X		    Free(pt->rmonst);
X	    }
X
X	    /* subrooms */
X	    Write(fd, &(pt->nreg), sizeof(pt->nreg));
X	    for(j=0;j<pt->nreg;j++) {
X		    Write(fd, pt->regions[j], sizeof(region));
X		    Free(pt->regions[j]);
X	    }
X	    if(pt->nreg > 0)
X		    Free(pt->regions);
X
X	    /* the doors */
X	    Write(fd, &(pt->ndoor), sizeof(pt->ndoor));
X	    for(j=0;j<pt->ndoor;j++) {
X		    Write(fd, pt->doors[j], sizeof(door));
X		    Free(pt->doors[j]);
X	    }
X	    if (pt->ndoor > 0)
X		    Free(pt->doors);
X
X	    /* The traps */
X	    Write(fd, &(pt->ntrap), sizeof(pt->ntrap));
X	    for(j=0;j<pt->ntrap;j++) {
X		    Write(fd, pt->traps[j], sizeof(trap));
X		    Free(pt->traps[j]);
X	    }
X	    if (pt->ntrap)
X		    Free(pt->traps);
X
X	    /* The monsters */
X	    Write(fd, &(pt->nmonster), sizeof(pt->nmonster));
X	    for(j=0;j<pt->nmonster;j++) {
X		    short size;
X		    monster *m = pt->monsters[j];
X		    Write(fd, m, sizeof(monster));
X		    size = m->name ? strlen(m->name) : 0;
X		    Write(fd, &size, sizeof(size));
X		    if (size) {
X			    Write(fd, m->name, size);
X			    Free(m->name);
X		    }
X		    size = m->appear_as ? strlen(m->appear_as) : 0;
X		    Write(fd, &size, sizeof(size));
X		    if (size) {
X			    Write(fd, m->appear_as, size);
X			    Free(m->appear_as);
X		    }
X		    Free(pt->monsters[j]);
X	    }
X	    if (pt->nmonster > 0)
X		    Free(pt->monsters);
X
X	    /* The objects */
X	    Write(fd, &(pt->nobject), sizeof(pt->nobject));
X	    for(j=0;j<pt->nobject;j++) {
X		    short size;
X		    object *o = pt->objects[j];
X		    Write(fd, o, sizeof(object));
X		    size = o->name ? strlen(o->name) : 0;
X		    Write(fd, &size, sizeof(size));
X		    if (size) {
X			    Write(fd, o->name, size);
X			    Free(o->name);
X		    }
X		    Free(pt->objects[j]);
X	    }
X	    if(pt->nobject > 0)
X		    Free(pt->objects);
X
X	    /* The drawbridges */
X	    Write(fd, &(pt->ndrawbridge), sizeof(pt->ndrawbridge));
X	    for(j=0;j<pt->ndrawbridge;j++) {
X		    Write(fd, pt->drawbridges[j], sizeof(drawbridge));
X		    Free(pt->drawbridges[j]);
X	    }
X	    if(pt->ndrawbridge > 0)
X		    Free(pt->drawbridges);
X
X	    /* The mazewalk directives */
X	    Write(fd, &(pt->nwalk), sizeof(pt->nwalk));
X	    for(j=0; j<pt->nwalk; j++) {
X		    Write(fd, pt->walks[j], sizeof(walk));
X		    Free(pt->walks[j]);
X	    }
X	    if (pt->nwalk > 0)
X		    Free(pt->walks);
X
X	    /* The non_diggable directives */
X	    Write(fd, &(pt->ndig), sizeof(pt->ndig));
X	    for(j=0;j<pt->ndig;j++) {
X		    Write(fd, pt->digs[j], sizeof(digpos));
X		    Free(pt->digs[j]);
X	    }
X	    if (pt->ndig > 0)
X		    Free(pt->digs);
X
X	    /* The ladders */
X	    Write(fd, &(pt->nlad), sizeof(pt->nlad));
X	    for(j=0;j<pt->nlad;j++) {
X		    Write(fd, pt->lads[j], sizeof(lad));
X		    Free(pt->lads[j]);
X	    }
X	    if (pt->nlad > 0)
X		    Free(pt->lads);
X
X	    /* The stairs */
X	    Write(fd, &(pt->nstair), sizeof(pt->nstair));
X	    for(j=0;j<pt->nstair;j++) {
X		    Write(fd, pt->stairs[j], sizeof(stair));
X		    Free(pt->stairs[j]);
X	    }
X	    if (pt->nstair > 0)
X		    Free(pt->stairs);
X
X	    /* The altars */
X	    Write(fd, &(pt->naltar), sizeof(pt->naltar));
X	    for(j=0;j<pt->naltar;j++) {
X		    Write(fd, pt->altars[j], sizeof(altar));
X		    Free(pt->altars[j]);
X	    }
X	    if (pt->naltar > 0)
X		    Free(pt->altars);
X
X	    /* The gold piles */
X	    Write(fd, &(pt->ngold), sizeof(pt->naltar));
X	    for(j=0;j<pt->ngold;j++) {
X		    Write(fd, pt->golds[j], sizeof(gold));
X		    Free(pt->golds[j]);
X	    }
X	    if (pt->ngold > 0)
X		    Free(pt->golds);
X
X	    /* The engravings */
X	    Write(fd, &(pt->nengraving), sizeof(pt->nengraving));
X	    for(j=0;j<pt->nengraving;j++) {
X		    char *txt;
X		    int size;
X		    txt = pt->engravings[j]->e.text;
X		    size = pt->engravings[j]->e.length = strlen(txt);
X		    Write(fd, pt->engravings[j], sizeof *pt->engravings[j]);
X		    Write(fd, txt, size);
X		    Free(txt);
X		    Free(pt->engravings[j]);
X	    }
X	    if (pt->nengraving > 0)
X		    Free(pt->engravings);
X
X	    /* The fountains */
X	    Write(fd, &(pt->nfountain), sizeof(pt->nfountain));
X	    for(j=0;j<pt->nfountain;j++) {
X		Write(fd, pt->fountains[j], sizeof(fountain));
X		Free(pt->fountains[j]);
X	    }
X	    if (pt->nfountain > 0)
X		    Free(pt->fountains);
X
X	    Free(pt);
X	}
X}
X
X/*
X * Here we write the structure of the room level in the specified file (fd).
X */
X
Xvoid
Xwrite_lev(fd, lev)
Xint fd;
Xsplev *lev;
X{
X	short i,j, size;
X	room *pt;
X
X	write_common_data(fd, SP_LEV_ROOMS, &(lev->init_lev), lev->flags);
X
X	/* Random registers */
X
X	Write(fd, &lev->nrobjects, sizeof(lev->nrobjects));
X	if (lev->nrobjects) {
X		Write(fd, lev->robjects, lev->nrobjects);
X		Free (lev->robjects);
X	}
X	Write(fd, &lev->nrmonst, sizeof(lev->nrmonst));
X	if (lev->nrmonst) {
X		Write(fd, lev->rmonst, lev->nrmonst);
X		Free (lev->rmonst);
X	}
X
X	Write(fd, &(lev->nroom), sizeof(lev->nroom));
X							/* Number of rooms */
X	for(i=0;i<lev->nroom;i++) {
X		pt = lev->rooms[i];
X
X		/* Room characteristics */
X
X		if (pt->name)
X			size = strlen(pt->name);
X		else
X			size = 0;
X		Write(fd, &size, sizeof(size));
X		if (size)
X			Write(fd, pt->name, size);
X
X		if (pt->parent)
X			size = strlen(pt->parent);
X		else
X			size = 0;
X		Write(fd, &size, sizeof(size));
X		if (size)
X			Write(fd, pt->parent, size);
X
X		Write(fd, &(pt->x), sizeof(pt->x));
X		Write(fd, &(pt->y), sizeof(pt->y));
X		Write(fd, &(pt->w), sizeof(pt->w));
X		Write(fd, &(pt->h), sizeof(pt->h));
X		Write(fd, &(pt->xalign), sizeof(pt->xalign));
X		Write(fd, &(pt->yalign), sizeof(pt->yalign));
X		Write(fd, &(pt->rtype), sizeof(pt->rtype));
X		Write(fd, &(pt->chance), sizeof(pt->chance));
X		Write(fd, &(pt->rlit), sizeof(pt->rlit));
X		Write(fd, &(pt->filled), sizeof(pt->filled));
X
X		/* the doors */
X		Write(fd, &(pt->ndoor), sizeof(pt->ndoor));
X		for(j=0;j<pt->ndoor;j++)
X			Write(fd, pt->doors[j], sizeof(room_door));
X		/* The traps */
X		Write(fd, &(pt->ntrap), sizeof(pt->ntrap));
X		for(j=0;j<pt->ntrap;j++)
X			Write(fd, pt->traps[j], sizeof(trap));
X
X		/* The monsters */
X		Write(fd, &(pt->nmonster), sizeof(pt->nmonster));
X		for(j=0;j<pt->nmonster;j++) {
X			monster *m = pt->monsters[j];
X			Write(fd, m, sizeof(monster));
X			size = m->name ? strlen(m->name) : 0;
X			Write(fd, &size, sizeof(size));
X			if (size)
X				Write(fd, m->name, size);
X			size = m->appear_as ? strlen(m->appear_as) : 0;
X			Write(fd, &size, sizeof(size));
X			if (size)
X				Write(fd, m->appear_as, size);
X		}
X
X		/* The objects */
X		Write(fd, &(pt->nobject), sizeof(pt->nobject));
X		for(j=0;j<pt->nobject;j++) {
X			object *o = pt->objects[j];
X			Write(fd, o, sizeof(object));
X			size = o->name ? strlen(o->name) : 0;
X			Write(fd, &size, sizeof(size));
X			if (size)
X				Write(fd,  o->name, size);
X		}
X
X		/* The stairs */
X		Write(fd, &(pt->nstair), sizeof(pt->nstair));
X		for(j=0;j<pt->nstair;j++)
X			Write(fd, pt->stairs[j], sizeof(stair));
X
X		/* The altars */
X		Write(fd, &(pt->naltar), sizeof(pt->naltar));
X		for(j=0;j<pt->naltar;j++)
X			Write(fd, pt->altars[j], sizeof(altar));
X
X		/* The gold piles */
X		Write(fd, &(pt->ngold), sizeof(pt->ngold));
X		for(j=0;j<pt->ngold;j++)
X			Write(fd, pt->golds[j], sizeof(gold));
X
X		/* The engravings */
X		Write(fd, &(pt->nengraving), sizeof(pt->nengraving));
X		for(j=0;j<pt->nengraving;j++) {
X			char *txt;
X			txt = pt->engravings[j]->e.text;
X			size = pt->engravings[j]->e.length = strlen(txt);
X			Write(fd, pt->engravings[j],
X			      sizeof *pt->engravings[j]);
X			Write(fd, txt, size);
X		}
X
X		/* The fountains */
X		Write(fd, &(pt->nfountain), sizeof(pt->nfountain));
X		for(j=0;j<pt->nfountain;j++)
X			Write(fd, pt->fountains[j], sizeof(fountain));
X
X		/* The sinks */
X		Write(fd, &(pt->nsink), sizeof(pt->nsink));
X		for(j=0;j<pt->nsink;j++)
X			Write(fd, pt->sinks[j], sizeof(sink));
X
X		/* The pools */
X		Write(fd, &(pt->npool), sizeof(pt->npool));
X		for(j=0;j<pt->npool;j++)
X			Write(fd, pt->pools[j], sizeof(pool));
X	}
X
X	/* The corridors */
X	Write(fd, &ncorridor, sizeof(ncorridor));
X	for (i=0; i<ncorridor; i++) {
X		Write(fd, tmpcor[i], sizeof(corridor));
X		Free(tmpcor[i]);
X	}
X	ncorridor = 0;
X}
X
Xvoid
Xfree_rooms(ro, n)
Xroom **ro;
Xint n;
X{
X	short j;
X	room *r;
X
X	while(n--) {
X		r = ro[n];
X		Free(r->name);
X		Free(r->parent);
X		if ((j = r->ndoor) != 0) {
X			while(j--)
X				Free(r->doors[j]);
X			Free(r->doors);
X		}
X		if ((j = r->ntrap) != 0) {
X			while (j--)
X				Free(r->traps[j]);
X			Free(r->traps);
X		}
X		if ((j = r->nmonster) != 0) {
X			while (j--) {
X				Free(r->monsters[j]->name);
X				Free(r->monsters[j]->appear_as);
X				Free(r->monsters[j]);
X			}
X			Free(r->monsters);
X		}
X		if ((j = r->nobject) != 0) {
X			while(j--) {
X				Free(r->objects[j]->name);
X				Free(r->objects[j]);
X			}
X			Free(r->objects);
X		}
X		if ((j = r->nstair) != 0) {
X			while(j--)
X				Free(r->stairs[j]);
X			Free(r->stairs);
X		}
X		if ((j = r->naltar) != 0) {
X			while (j--)
X				Free(r->altars[j]);
X			Free(r->altars);
X		}
X		if ((j = r->ngold) != 0) {
X			while(j--)
X				Free(r->golds[j]);
X			Free(r->golds);
X		}
X		if ((j = r->nengraving) != 0) {
X			while(j--) {
X				Free(r->engravings[j]->e.text);
X				Free(r->engravings[j]);
X			}
X			Free(r->engravings);
X		}
X		if ((j = r->nfountain) != 0) {
X			while(j--)
X				Free(r->fountains[j]);
X			Free(r->fountains);
X		}
X		if ((j = r->nsink) != 0) {
X			while(j--)
X				Free(r->sinks[j]);
X			Free(r->sinks);
X		}
X		if ((j = r->npool) != 0) {
X			while(j--)
X				Free(r->pools[j]);
X			Free(r->pools);
X		}
X		Free(r);
X	}
X}
X
X#ifdef STRICT_REF_DEF
X/*
X * Any globals declared in hack.h and descendents which aren't defined
X * in the modules linked into lev_comp should be defined here.  These
X * definitions can be dummies:  their sizes shouldn't matter as long as
X * as their types are correct; actual values are irrelevant.
X */
X#define ARBITRARY_SIZE 1
X/* attrib.c */
Xstruct attribs attrmax, attrmin;
X/* files.c */
Xconst char *configfile;
Xchar lock[ARBITRARY_SIZE];
Xchar SAVEF[ARBITRARY_SIZE];
X# ifdef MICRO
Xchar SAVEP[ARBITRARY_SIZE];
X# endif
X/* termcap.c */
Xstruct tc_lcl_data tc_lcl_data;
X# ifdef TEXTCOLOR
X#  ifdef TOS
Xconst char *hilites[MAXCOLORS];
X#  else
Xchar NEARDATA *hilites[MAXCOLORS];
X#  endif
X# endif
X/* trap.c */
Xconst char *traps[TRAPNUM];
X/* window.c */
Xstruct window_procs windowprocs;
X/* xxxtty.c */
X# ifdef DEFINE_OSPEED
Xshort ospeed;
X# endif
X#endif	/* STRICT_REF_DEF */
X
X/*lev_main.c*/
END_OF_FILE
if test 31210 -ne `wc -c <'util/lev_main.c'`; then
    echo shar: \"'util/lev_main.c'\" unpacked with wrong size!
fi
# end of 'util/lev_main.c'
fi
echo shar: End of archive 64 \(of 108\).
cp /dev/null ark64isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \
21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \
41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 \
61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 \
81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 \
101 102 103 104 105 106 107 108 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 108 archives.
    echo "Now execute 'rebuild.sh'"
    rm -f ark10[0-8]isdone ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
