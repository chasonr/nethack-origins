Path: uunet!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v16i012:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Part12/108
Message-ID: <4295@master.CNA.TEK.COM>
Date: 28 Jan 93 19:12:46 GMT
Sender: news@master.CNA.TEK.COM
Lines: 2180
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1568

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 16, Issue 12
Archive-name: nethack31/Part12
Supersedes: nethack3p9: Volume 10, Issue 46-102
Environment: Amiga, Atari, Mac, MS-DOS, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 12 (of 108)."
# Contents:  include/global.h src/eat.c sys/mac/mhdump.c
# Wrapped by billr@saab on Wed Jan 27 16:08:49 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'include/global.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/global.h'\"
else
echo shar: Extracting \"'include/global.h'\" \(6136 characters\)
sed "s/^X//" >'include/global.h' <<'END_OF_FILE'
X/*	SCCS Id: @(#)global.h	3.1	92/01/04	*/
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#ifndef GLOBAL_H
X#define GLOBAL_H
X
X#include <stdio.h>
X
X
X/*#define BETA		/* if a beta-test copy  [MRS] */
X#define VERSION "3.1"	/* version number. */
X
X/*
X * Files expected to exist in the playground directory.
X */
X
X#define RECORD		"record"  /* a file containing list of topscorers */
X#define HELP		"help"	  /* a file containing command descriptions */
X#define SHELP		"hh"		/* abbreviated form of the same */
X#define DEBUGHELP	"wizhelp"	/* a file containing debug mode cmds */
X#define RUMORFILE	"rumors"	/* a file with fortune cookies */
X#define ORACLEFILE	"oracles"	/* a file with oracular information */
X#define DATAFILE	"data"	/* a file giving the meaning of symbols used */
X#define CMDHELPFILE	"cmdhelp"	/* file telling what commands do */
X#define HISTORY		"history"	/* a file giving nethack's history */
X#define LICENSE		"license"	/* file with license information */
X#define OPTIONFILE	"opthelp"	/* a file explaining runtime options */
X#define OPTIONS_USED	"options"	/* compile-time options, for #version */
X
X#define LEV_EXT	".lev"		/* extension for special level files */
X
X
X/* Assorted definitions that may depend on selections in config.h. */
X
X/*
X * for DUMB preprocessor and compiler, e.g., cpp and pcc supplied
X * with Microport SysV/AT, which have small symbol tables;
X * DUMB if needed is defined in CFLAGS
X */
X#ifdef DUMB
X#ifdef BITFIELDS
X#undef BITFIELDS
X#endif
X#ifndef STUPID
X#define STUPID
X#endif
X#endif	/* DUMB */
X
X/*
X * type xchar: small integers in the range 0 - 127, usually coordinates
X * although they are nonnegative they must not be declared unsigned
X * since otherwise comparisons with signed quantities are done incorrectly
X */
Xtypedef schar	xchar;
Xtypedef xchar	boolean;		/* 0 or 1 */
X
X#ifndef TRUE		/* defined in some systems' native include files */
X#define TRUE	((boolean)1)
X#define FALSE	((boolean)0)
X#endif
X
X#ifndef STRNCMPI
X# define strcmpi(a,b) strncmpi((a),(b),-1)
X#endif
X
X/* comment out to test effects of each #define -- these will probably
X * disappear eventually
X */
X#ifdef INTERNAL_COMP
X# define RLECOMP	/* run-length compression of levl array - JLee */
X# define ZEROCOMP	/* zero-run compression of everything - Olaf Seibert */
X#endif
X
X/* #define SPECIALIZATION	/* do "specialized" version of new topology */
X
X
X#ifdef BITFIELDS
X#define Bitfield(x,n)	unsigned x:n
X#else
X#define Bitfield(x,n)	uchar x
X#endif
X
X#ifdef UNWIDENED_PROTOTYPES
X# define CHAR_P char
X# define SCHAR_P schar
X# define UCHAR_P uchar
X# define XCHAR_P xchar
X# define SHORT_P short
X# define BOOLEAN_P boolean
X# define ALIGNTYP_P aligntyp
X#else
X# ifdef WIDENED_PROTOTYPES
X#  define CHAR_P int
X#  define SCHAR_P int
X#  define UCHAR_P int
X#  define XCHAR_P int
X#  define SHORT_P int
X#  define BOOLEAN_P int
X#  define ALIGNTYP_P int
X# endif
X#endif
X#if defined(ULTRIX_PROTO) && !defined(__GNUC__)
X/* The ultrix 2.0 and 2.1 compilers (on Ultrix 4.0 and 4.2 respectively) can't
X * handle "struct obj *" constructs in prototypes.  Their bugs are different,
X * but both seem to work if we put "void*" in the prototype instead.  This
X * gives us minimal prototype checking but avoids the compiler bugs.
X *
X * OBJ_P and MONST_P should _only_ be used for declaring function pointers.
X */
X#define OBJ_P void*
X#define MONST_P void*
X#else
X#define OBJ_P struct obj*
X#define MONST_P struct monst*
X#endif
X
X#define SIZE(x)	(int)(sizeof(x) / sizeof(x[0]))
X
Xtypedef int winid;		/* a window identifier */
X
X/* A limit for some NetHack int variables.  It need not, and for comparable
X * scoring should not, depend on the actual limit on integers for a
X * particular machine, although it is set to the minimum required maximum
X * signed integer for C (2^15 -1).
X */
X#define LARGEST_INT	32767
X
X
X#ifdef REDO
X#define Getchar pgetchar
X#endif
X
X/*
X * Automatic inclusions for the subsidiary files.
X * Please don't change the order.  It does matter.
X */
X
X#ifndef COORD_H
X#include "coord.h"
X#endif
X
X#if defined(VMS) && !defined(VMSCONF_H)
X# include "vmsconf.h"
X#endif
X
X#if defined(UNIX) && !defined(UNIXCONF_H)
X# include "unixconf.h"
X#endif
X
X#if defined(OS2) && !defined(OS2CONF_H)
X# include "os2conf.h"
X#endif
X
X#if defined(MSDOS) && !defined(PCCONF_H)
X# include "pcconf.h"
X#endif
X
X#if defined(TOS) && !defined(TOSCONF_H)
X# include "tosconf.h"
X#endif
X
X#if defined(AMIGA) && !defined(AMICONF_H)
X# include "amiconf.h"
X#endif
X
X#if defined(MAC) && ! defined(MACCONF_H)
X# include "macconf.h"
X#endif
X
X/* Displayable name of this port; don't redefine if defined in *conf.h */
X#ifndef PORT_ID
X# ifdef AMIGA
X#  define PORT_ID	"Amiga"
X# endif
X# ifdef MAC
X#  define PORT_ID	"Mac"
X# endif
X# ifdef MSDOS
X#  define PORT_ID	"PC"
X# endif
X# ifdef OS2
X#  define PORT_ID	"OS/2"
X# endif
X# ifdef TOS
X#  define PORT_ID	"ST"
X# endif
X# ifdef UNIX
X#  define PORT_ID	"Unix"
X# endif
X# ifdef VMS
X#  define PORT_ID	"VMS"
X# endif
X#endif
X
X/*
X * Configurable internal parameters.
X *
X * Please be very careful if you are going to change one of these.  Any
X * changes in these parameters, unless properly done, can render the
X * executable inoperative.
X */
X
X/* size of terminal screen is (at least) (ROWNO+3) by COLNO */
X#define COLNO	80
X#define ROWNO	21
X
X#define MAXNROFROOMS	20	/* max number of rooms per level */
X#define MAX_SUBROOMS	16	/* max # of subrooms in a given room */
X#define DOORMAX		120	/* max number of doors per level */
X
X#define BUFSZ		256	/* for getlin buffers */
X#define QBUFSZ		128	/* for building question text */
X
X#define PL_NSIZ		32	/* name of player, ghost, shopkeeper */
X#define PL_CSIZ		20	/* sizeof pl_character */
X#define PL_FSIZ		32	/* fruit name */
X
X#define MAXDUNGEON	10	/* current maximum number of dungeons */
X#define MAXLEVEL	30	/* max number of levels in one dungeon */
X#define MAXSTAIRS	1	/* max # of special stairways in a dungeon */
X#define ALIGNWEIGHT	4	/* generation weight of alignment */
X
X#define MAXULEV		30	/* max character experience level */
X
X#define MAXMONNO	120	/* geno monst after this number killed */
X#define MHPMAX		500	/* maximum monster hp */
X
X#endif /* GLOBAL_H */
END_OF_FILE
if test 6136 -ne `wc -c <'include/global.h'`; then
    echo shar: \"'include/global.h'\" unpacked with wrong size!
fi
# end of 'include/global.h'
fi
if test -f 'src/eat.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/eat.c'\"
else
echo shar: Extracting \"'src/eat.c'\" \(47298 characters\)
sed "s/^X//" >'src/eat.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)eat.c	3.1	92/12/06	*/
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include	"hack.h"
X/*#define DEBUG		/* uncomment to enable new eat code debugging */
X
X#ifdef DEBUG
X# ifdef WIZARD
X#define debugpline	if (wizard) pline
X# else
X#define debugpline	pline
X# endif
X#endif
X
XSTATIC_PTR int NDECL(eatmdone);
XSTATIC_PTR int NDECL(eatfood);
XSTATIC_PTR int NDECL(opentin);
XSTATIC_PTR int NDECL(unfaint);
X
X#ifdef OVLB
Xstatic void FDECL(choke, (struct obj *));
Xstatic void NDECL(recalc_wt);
Xstatic struct obj *FDECL(touchfood, (struct obj *));
Xstatic void NDECL(do_reset_eat);
Xstatic void FDECL(done_eating, (BOOLEAN_P));
Xstatic void FDECL(cprefx, (int));
Xstatic int FDECL(intrinsic_possible, (int,struct permonst *));
Xstatic void FDECL(givit, (int,struct permonst *));
Xstatic void FDECL(cpostfx, (int));
Xstatic void FDECL(start_tin, (struct obj *));
Xstatic int FDECL(eatcorpse, (struct obj *));
Xstatic void FDECL(start_eating, (struct obj *));
Xstatic void FDECL(fprefx, (struct obj *));
Xstatic void FDECL(fpostfx, (struct obj *));
Xstatic int NDECL(bite);
X
X#ifdef POLYSELF
Xstatic int FDECL(rottenfood, (struct obj *));
Xstatic void NDECL(eatspecial);
Xstatic void FDECL(eatring, (struct obj *));
Xstatic const char * FDECL(foodword, (struct obj *));
X#else
Xstatic int NDECL(rottenfood);
X#endif /* POLYSELF */
X
Xchar corpsename[60];
Xchar msgbuf[BUFSZ];
X
X#endif /* OVLB */
X
X/* hunger texts used on bottom line (each 8 chars long) */
X#define SATIATED	0
X#define NOT_HUNGRY	1
X#define HUNGRY		2
X#define WEAK		3
X#define FAINTING	4
X#define FAINTED		5
X#define STARVED		6
X
X#ifdef OVLB
X
Xconst char *hu_stat[] = {
X	"Satiated",
X	"        ",
X	"Hungry  ",
X	"Weak    ",
X	"Fainting",
X	"Fainted ",
X	"Starved "
X};
X
X#endif /* OVLB */
X
X#ifndef OVLB
X
XSTATIC_DCL const char NEARDATA comestibles[];
X#ifdef POLYSELF
XSTATIC_OVL const char NEARDATA allobj[];
X#endif /* POLYSELF */
X
X#else
X
XSTATIC_OVL const char NEARDATA comestibles[] = { FOOD_CLASS, 0 };
X
X#ifdef POLYSELF
X/* Gold must come first for getobj(). */
XSTATIC_OVL const char NEARDATA allobj[] = {
X	GOLD_CLASS, WEAPON_CLASS, ARMOR_CLASS, POTION_CLASS, SCROLL_CLASS,
X	WAND_CLASS, RING_CLASS, AMULET_CLASS, FOOD_CLASS, TOOL_CLASS,
X	GEM_CLASS, ROCK_CLASS, BALL_CLASS, CHAIN_CLASS, SPBOOK_CLASS, 0 };
X#endif /* POLYSELF */
X
X#endif /* OVLB */
X#ifdef OVL1
X# ifdef POLYSELF
X
Xboolean
Xis_edible(obj)
Xregister struct obj *obj;
X{
X	if (metallivorous(uasmon) && is_metallic(obj))
X		return TRUE;
X	if (u.umonnum == PM_GELATINOUS_CUBE && is_organic(obj))
X		return TRUE;
X	return !!index(comestibles, obj->oclass);
X}
X# endif /* POLYSELF */
X#endif /* OVL1 */
X#ifdef OVLB
X
Xvoid
Xinit_uhunger(){
X	u.uhunger = 900;
X	u.uhs = NOT_HUNGRY;
X}
X
Xstatic const struct { const char *txt; int nut; } tintxts[] = {
X	{"deep fried",	 60},
X	{"pickled",	 40},
X	{"soup made from", 20},
X	{"pureed",	500},
X	{"rotten",	-50},
X	{"homemade",	 50},
X	{"", 0}
X};
X#define	TTSZ	SIZE(tintxts)
X
Xstatic struct {
X	struct	obj *tin;
X	int	usedtime, reqtime;
X} NEARDATA tin;
X
Xstatic struct {
X	struct	obj *piece;	/* the thing being eaten, or last thing that
X				 * was partially eaten, unless that thing was
X				 * a tin, which uses the tin structure above */
X	int	usedtime,	/* turns spent eating */
X		reqtime;	/* turns required to eat */
X	int	nmod;		/* coded nutrition per turn */
X	Bitfield(canchoke,1);	/* was satiated at beginning */
X	Bitfield(fullwarn,1);	/* have warned about being full */
X	Bitfield(eating,1);	/* victual currently being eaten */
X	Bitfield(doreset,1);	/* stop eating at end of turn */
X} NEARDATA victual;
X
XSTATIC_PTR
Xint
Xeatmdone() {		/* called after mimicing is over */
X	u.usym =
X#ifdef POLYSELF
X		u.mtimedone ? uasmon->mlet :
X#endif
X		S_HUMAN;
X	newsym(u.ux,u.uy);
X	return 0;
X}
X
X/* Created by GAN 01/28/87
X * Amended by AKP 09/22/87: if not hard, don't choke, just vomit.
X * Amended by 3.  06/12/89: if not hard, sometimes choke anyway, to keep risk.
X *		  11/10/89: if hard, rarely vomit anyway, for slim chance.
X */
X/*ARGSUSED*/
Xstatic void
Xchoke(food)	/* To a full belly all food is bad. (It.) */
X	register struct obj *food;
X{
X	/* only happens if you were satiated */
X	if(u.uhs != SATIATED) return;
X
X	if (pl_character[0] == 'K' && u.ualign.type == A_LAWFUL)
X		u.ualign.record--;	/* gluttony is unchivalrous */
X
X	if (!rn2(20)) {
X		You("stuff yourself and then vomit voluminously.");
X		morehungry(1000);	/* you just got *very* sick! */
X		vomit();
X	} else {
X		killer_format = KILLED_BY_AN;
X		/*
X		 * Note all "killer"s below read "Choked on %s" on the
X		 * high score list & tombstone.  So plan accordingly.
X		 */
X		if(food) {
X#ifdef POLYSELF
X			You("choke over your %s.", foodword(food));
X			if (food->oclass == GOLD_CLASS) {
X				killer_format = KILLED_BY;
X				killer = "eating too rich a meal";
X			} else {
X#else
X				You("choke over your food.");
X#endif
X				killer = singular(food, xname);
X#ifdef POLYSELF
X			}
X#endif
X		} else {
X			You("choke over it.");
X			killer = "quick snack";
X		}
X		You("die...");
X		done(CHOKING);
X	}
X}
X
Xstatic void
Xrecalc_wt() {	/* modify object wt. depending on time spent consuming it */
X	register struct obj *piece = victual.piece;
X
X#ifdef DEBUG
X	debugpline("Old weight = %d", piece->owt);
X	debugpline("Used time = %d, Req'd time = %d",
X		victual.usedtime, victual.reqtime);
X#endif
X	/* weight(piece) = weight of full item */
X	if(victual.usedtime)
X	    piece->owt = eaten_stat(weight(piece), piece);
X#ifdef DEBUG
X	debugpline("New weight = %d", piece->owt);
X#endif
X}
X
Xvoid
Xreset_eat() {		/* called when eating interrupted by an event */
X
X    /* we only set a flag here - the actual reset process is done after
X     * the round is spent eating.
X     */
X	if(victual.eating && !victual.doreset) {
X#ifdef DEBUG
X	    debugpline("reset_eat...");
X#endif
X	    victual.doreset = TRUE;
X	}
X	return;
X}
X
Xvoid
Xbill_dummy_object(otmp)
Xregister struct obj *otmp;
X{
X	/* Create a dummy duplicate to put on bill.  The duplicate exists
X	 * only in the billobjs chain.  This function is used when a store
X	 * object is being altered, and a copy of the original is needed
X	 * for billing purposes.
X	 */
X	register struct obj *dummy;
X
X	if(otmp->unpaid)
X		subfrombill(otmp, shop_keeper(*u.ushops));
X	dummy = newobj(otmp->onamelth);
X	*dummy = *otmp;
X	dummy->o_id = flags.ident++;
X	dummy->owt = weight(dummy);
X	if(otmp->onamelth)
X		(void)strncpy(ONAME(dummy),ONAME(otmp), (int)otmp->onamelth);
X	if(Is_candle(dummy)) dummy->lamplit = 0;
X	addtobill(dummy, FALSE, TRUE, TRUE);
X}
X
Xstatic struct obj *
Xtouchfood(otmp)
Xregister struct obj *otmp;
X{
X	if (otmp->quan > 1L) {
X	    if(!carried(otmp))
X		(void) splitobj(otmp, 1L);
X	    else
X		otmp = splitobj(otmp, otmp->quan - 1L);
X#ifdef DEBUG
X	    debugpline("split object,");
X#endif
X	}
X
X	if (!otmp->oeaten) {
X	    if(((!carried(otmp) && costly_spot(otmp->ox, otmp->oy) &&
X		 saleable(rooms[*u.ushops-ROOMOFFSET].rtype-SHOPBASE, otmp))
X		 || otmp->unpaid) &&
X		 (otmp->otyp == CORPSE || objects[otmp->otyp].oc_delay > 1)) {
X		/* create a dummy duplicate to put on bill */
X		You("bite it, you bought it!");
X		bill_dummy_object(otmp);
X	    }
X	    otmp->oeaten = (otmp->otyp == CORPSE ?
X				(int)mons[otmp->corpsenm].cnutrit :
X				objects[otmp->otyp].oc_nutrition);
X	}
X
X	if (carried(otmp)) {
X	    freeinv(otmp);
X	    if(inv_cnt() >= 52)
X		dropy(otmp);
X	    else
X		otmp = addinv(otmp); /* unlikely but a merge is possible */
X	}
X	return(otmp);
X}
X
X/* When food decays, in the middle of your meal, we don't want to dereference
X * any dangling pointers, so set it to null (which should still trigger
X * do_reset_eat() at the beginning of eatfood()) and check for null pointers
X * in do_reset_eat().
X */
Xvoid
Xfood_disappears(obj)
Xregister struct obj *obj;
X{
X	if (obj == victual.piece) victual.piece = (struct obj *)0;
X}
X
Xstatic void
Xdo_reset_eat() {
X
X#ifdef DEBUG
X	debugpline("do_reset_eat...");
X#endif
X	if (victual.piece) {
X		victual.piece = touchfood(victual.piece);
X		recalc_wt();
X	}
X	victual.fullwarn = victual.eating = victual.doreset = FALSE;
X	/* Do not set canchoke to FALSE; if we continue eating the same object
X	 * we need to know if canchoke was set when they started eating it the
X	 * previous time.  And if we don't continue eating the same object
X	 * canchoke always gets recalculated anyway.
X	 */
X	stop_occupation();
X}
X
XSTATIC_PTR
Xint
Xeatfood() {		/* called each move during eating process */
X	if(!carried(victual.piece) && !obj_here(victual.piece, u.ux, u.uy)) {
X		/* maybe it was stolen? */
X		do_reset_eat();
X		return(0);
X	}
X	if(!victual.eating) return(0);
X
X	if(++victual.usedtime < victual.reqtime) {
X	    if(bite()) return(0);
X	    return(1);	/* still busy */
X	} else {	/* done */
X	    done_eating(TRUE);
X	    return(0);
X	}
X}
X
Xstatic void
Xdone_eating(message)
Xboolean message;
X{
X#ifndef NO_SIGNAL
X	victual.piece->in_use = TRUE;
X#endif
X	if (nomovemsg) {
X		if (message) pline(nomovemsg);
X		nomovemsg = 0;
X	} else if (message)
X		You("finish eating %s.", the(singular(victual.piece, xname)));
X
X	if(victual.piece->otyp == CORPSE)
X		cpostfx(victual.piece->corpsenm);
X	else
X		fpostfx(victual.piece);
X
X	if (carried(victual.piece)) useup(victual.piece);
X	else useupf(victual.piece);
X	victual.piece = (struct obj *) 0;
X	victual.fullwarn = victual.eating = victual.doreset = FALSE;
X}
X
Xstatic void
Xcprefx(pm)
Xregister int pm;
X{
X	if ((pl_character[0]=='E') ? is_elf(&mons[pm]) : is_human(&mons[pm])) {
X		You("cannibal!  You will regret this!");
X		Aggravate_monster |= FROMOUTSIDE;
X	}
X
X	switch(pm) {
X	    case PM_LITTLE_DOG:
X	    case PM_DOG:
X	    case PM_LARGE_DOG:
X	    case PM_KITTEN:
X	    case PM_HOUSECAT:
X	    case PM_LARGE_CAT:
X		You("feel that eating the %s was a bad idea.", mons[pm].mname);
X		Aggravate_monster |= FROMOUTSIDE;
X		break;
X	    case PM_COCKATRICE:
X	    case PM_MEDUSA:
X#ifdef POLYSELF
X		if(!resists_ston(uasmon))
X		    if(!(poly_when_stoned(uasmon) && polymon(PM_STONE_GOLEM)))
X#endif
X			{
X			char *cruft;	/* killer is const char * */
X			killer_format = KILLED_BY;
X			killer = cruft = (char *)  /* sizeof "s" includes \0 */
X					alloc((unsigned) strlen(mons[pm].mname)
X						+ sizeof " meat");
X			Sprintf(cruft, "%s meat", mons[pm].mname);
X			You("turn to stone.");
X			done(STONING);
X			}
X			break;
X	    case PM_LIZARD:
X		/* Relief from cockatrices -dgk */
X		if (Stoned) {
X			Stoned = 0;
X			You("feel limber!");
X		}
X		break;
X	    case PM_DEATH:
X	    case PM_PESTILENCE:
X	    case PM_FAMINE:
X		{ char buf[BUFSZ];
X		    pline("Eating that is instantly fatal.");
X		    Sprintf(buf, "unwisely ate the body of %s",
X			    mons[pm].mname);
X		    killer = buf;
X		    killer_format = NO_KILLER_PREFIX;
X		    done(DIED);
X		    /* It so happens that since we know these monsters */
X		    /* cannot appear in tins, victual.piece will always */
X		    /* be what we want, which is not generally true. */
X		    revive_corpse(victual.piece, 0, FALSE);
X		    return;
X		}
X	    default:
X		if(acidic(&mons[pm]) && Stoned) {
X		    pline("What a pity - you just destroyed a future piece of art!");
X		    Stoned = 0;
X		}
X	}
X	return;
X}
X
X
X/*
X * If you add an intrinsic that can be gotten by eating a monster, add it
X * to intrinsic_possible() and givit().  (It must already be in prop.h to
X * be an intrinsic property.)
X * It would be very easy to make the intrinsics not try to give you one
X * that you already had by checking to see if you have it in
X * intrinsic_possible() instead of givit().
X */
X
X/* intrinsic_possible() returns TRUE iff a monster can give an intrinsic. */
Xstatic int
Xintrinsic_possible(type, ptr)
Xint type;
Xregister struct permonst *ptr;
X{
X	switch (type) {
X	    case FIRE_RES:
X#ifdef DEBUG
X		if (ptr->mconveys & MR_FIRE) {
X			debugpline("can get fire resistance");
X			return(TRUE);
X		} else  return(FALSE);
X#else
X		return(ptr->mconveys & MR_FIRE);
X#endif
X	    case SLEEP_RES:
X#ifdef DEBUG
X		if (ptr->mconveys & MR_SLEEP) {
X			debugpline("can get sleep resistance");
X			return(TRUE);
X		} else  return(FALSE);
X#else
X		return(ptr->mconveys & MR_SLEEP);
X#endif
X	    case COLD_RES:
X#ifdef DEBUG
X		if (ptr->mconveys & MR_COLD) {
X			debugpline("can get cold resistance");
X			return(TRUE);
X		} else  return(FALSE);
X#else
X		return(ptr->mconveys & MR_COLD);
X#endif
X	    case DISINT_RES:
X#ifdef DEBUG
X		if (ptr->mconveys & MR_DISINT) {
X			debugpline("can get disintegration resistance");
X			return(TRUE);
X		} else  return(FALSE);
X#else
X		return(ptr->mconveys & MR_DISINT);
X#endif
X	    case SHOCK_RES:	/* shock (electricity) resistance */
X#ifdef DEBUG
X		if (ptr->mconveys & MR_ELEC) {
X			debugpline("can get shock resistance");
X			return(TRUE);
X		} else  return(FALSE);
X#else
X		return(ptr->mconveys & MR_ELEC);
X#endif
X	    case POISON_RES:
X#ifdef DEBUG
X		if (ptr->mconveys & MR_POISON) {
X			debugpline("can get poison resistance");
X			return(TRUE);
X		} else  return(FALSE);
X#else
X		return(ptr->mconveys & MR_POISON);
X#endif
X	    case TELEPORT:
X#ifdef DEBUG
X		if (can_teleport(ptr)) {
X			debugpline("can get teleport");
X			return(TRUE);
X		} else  return(FALSE);
X#else
X		return(can_teleport(ptr));
X#endif
X	    case TELEPORT_CONTROL:
X#ifdef DEBUG
X		if (control_teleport(ptr)) {
X			debugpline("can get teleport control");
X			return(TRUE);
X		} else  return(FALSE);
X#else
X		return(control_teleport(ptr));
X#endif
X	    case TELEPAT:
X#ifdef DEBUG
X		if (telepathic(ptr)) {
X			debugpline("can get telepathy");
X			return(TRUE);
X		} else  return(FALSE);
X#else
X		return(telepathic(ptr));
X#endif
X	    default:
X		return(FALSE);
X	}
X	/*NOTREACHED*/
X}
X
X/* givit() tries to give you an intrinsic based on the monster's level
X * and what type of intrinsic it is trying to give you.
X */
Xstatic void
Xgivit(type, ptr)
Xint type;
Xregister struct permonst *ptr;
X{
X	register int chance;
X
X#ifdef DEBUG
X	debugpline("Attempting to give intrinsic %d", type);
X#endif
X	/* some intrinsics are easier to get than others */
X	switch (type) {
X		case POISON_RES:
X			if ((ptr == &mons[PM_KILLER_BEE] ||
X					ptr == &mons[PM_SCORPION]) && !rn2(4))
X				chance = 1;
X			else
X				chance = 15;
X			break;
X		case TELEPORT:
X			chance = 10;
X			break;
X		case TELEPORT_CONTROL:
X			chance = 12;
X			break;
X		case TELEPAT:
X			chance = 1;
X			break;
X		default:
X			chance = 15;
X			break;
X	}
X
X	if (ptr->mlevel <= rn2(chance))
X		return;		/* failed die roll */
X
X	switch (type) {
X	    case FIRE_RES:
X#ifdef DEBUG
X		debugpline("Trying to give fire resistance");
X#endif
X		if(!(HFire_resistance & FROMOUTSIDE)) {
X			You("feel a momentary chill.");
X			HFire_resistance |= FROMOUTSIDE;
X		}
X		break;
X	    case SLEEP_RES:
X#ifdef DEBUG
X		debugpline("Trying to give sleep resistance");
X#endif
X		if(!(HSleep_resistance & FROMOUTSIDE)) {
X			You("feel wide awake.");
X			HSleep_resistance |= FROMOUTSIDE;
X		}
X		break;
X	    case COLD_RES:
X#ifdef DEBUG
X		debugpline("Trying to give cold resistance");
X#endif
X		if(!(HCold_resistance & FROMOUTSIDE)) {
X			You("feel full of hot air.");
X			HCold_resistance |= FROMOUTSIDE;
X		}
X		break;
X	    case DISINT_RES:
X#ifdef DEBUG
X		debugpline("Trying to give disintegration resistance");
X#endif
X		if(!(HDisint_resistance & FROMOUTSIDE)) {
X			You("feel very firm.");
X			HDisint_resistance |= FROMOUTSIDE;
X		}
X		break;
X	    case SHOCK_RES:	/* shock (electricity) resistance */
X#ifdef DEBUG
X		debugpline("Trying to give shock resistance");
X#endif
X		if(!(HShock_resistance & FROMOUTSIDE)) {
X			Your("health currently feels amplified!");
X			HShock_resistance |= FROMOUTSIDE;
X		}
X		break;
X	    case POISON_RES:
X#ifdef DEBUG
X		debugpline("Trying to give poison resistance");
X#endif
X		if(!(HPoison_resistance & FROMOUTSIDE)) {
X			You("feel healthy.");
X			HPoison_resistance |= FROMOUTSIDE;
X		}
X		break;
X	    case TELEPORT:
X#ifdef DEBUG
X		debugpline("Trying to give teleport");
X#endif
X		if(!(HTeleportation & FROMOUTSIDE)) {
X			You("feel very jumpy.");
X			HTeleportation |= FROMOUTSIDE;
X		}
X		break;
X	    case TELEPORT_CONTROL:
X#ifdef DEBUG
X		debugpline("Trying to give teleport control");
X#endif
X		if(!(HTeleport_control & FROMOUTSIDE)) {
X			You("feel in control of yourself.");
X			HTeleport_control |= FROMOUTSIDE;
X		}
X		break;
X	    case TELEPAT:
X#ifdef DEBUG
X		debugpline("Trying to give telepathy");
X#endif
X		if(!(HTelepat & FROMOUTSIDE)) {
X			You("feel a %s mental acuity.",
X				Hallucination ? "normal" : "strange");
X			HTelepat |= FROMOUTSIDE;
X			/* If blind, make sure monsters show up. */
X			if (Blind) see_monsters();
X		}
X		break;
X	    default:
X#ifdef DEBUG
X		debugpline("Tried to give an impossible intrinsic");
X#endif
X		break;
X	}
X}
X
Xstatic void
Xcpostfx(pm)		/* called after completely consuming a corpse */
Xregister int pm;
X{
X	register int tmp = 0;
X
X	switch(pm) {
X	    case PM_WRAITH:
X		pluslvl();
X		break;
X#ifdef POLYSELF
X	    case PM_HUMAN_WERERAT:
X		u.ulycn = PM_WERERAT;
X		break;
X	    case PM_HUMAN_WEREJACKAL:
X		u.ulycn = PM_WEREJACKAL;
X		break;
X	    case PM_HUMAN_WEREWOLF:
X		u.ulycn = PM_WEREWOLF;
X		break;
X#endif
X	    case PM_NURSE:
X		u.uhp = u.uhpmax;
X		flags.botl = 1;
X		break;
X	    case PM_STALKER:
X		if(!Invis) {
X			HInvis = rn1(100, 50);
X			if(!See_invisible)
X				newsym(u.ux, u.uy);
X		} else {
X			register long oldprop = See_invisible;
X			if (!(HInvis & INTRINSIC)) You("feel hidden!");
X			HInvis |= FROMOUTSIDE;
X			HSee_invisible |= FROMOUTSIDE;
X			if (!oldprop)
X				newsym(u.ux, u.uy);
X		}
X		/* fall into next case */
X	    case PM_YELLOW_LIGHT:
X		/* fall into next case */
X	    case PM_GIANT_BAT:
X		make_stunned(HStun + 30,FALSE);
X		/* fall into next case */
X	    case PM_BAT:
X		make_stunned(HStun + 30,FALSE);
X		break;
X	    case PM_GIANT_MIMIC:
X		tmp += 10;
X		/* fall into next case */
X	    case PM_LARGE_MIMIC:
X		tmp += 20;
X		/* fall into next case */
X	    case PM_SMALL_MIMIC:
X		tmp += 20;
X		if(u.usym == S_HUMAN) {
X		    You("cannot resist the temptation to mimic a pile of gold.");
X		    nomul(-tmp);
X		    afternmv = eatmdone;
X		    if (pl_character[0]=='E')
X			nomovemsg = "You now again prefer mimicking an elf.";
X		    else
X			nomovemsg = "You now again prefer mimicking a human.";
X		    u.usym = 0; /* hack! no monster sym 0; use for gold */
X		    newsym(u.ux,u.uy);
X		}
X		break;
X	    case PM_QUANTUM_MECHANIC:
X		Your("velocity suddenly seems very uncertain!");
X		if (Fast & INTRINSIC) {
X			Fast &= ~INTRINSIC;
X			You("seem slower.");
X		} else {
X			Fast |= FROMOUTSIDE;
X			You("seem faster.");
X		}
X		break;
X	    case PM_LIZARD:
X		if (HStun > 2)  make_stunned(2L,FALSE);
X		if (HConfusion > 2)  make_confused(2L,FALSE);
X		break;
X	    case PM_CHAMELEON:
X		You("feel a change coming over you.");
X#ifdef POLYSELF
X		polyself();
X#else
X		newman();
X#endif
X		break;
X	    case PM_MIND_FLAYER:
X		if (ABASE(A_INT) < ATTRMAX(A_INT)) {
X			if (!rn2(2)) {
X				pline("Yum! That was real brain food!");
X				(void) adjattrib(A_INT, 1, FALSE);
X				break;	/* don't give them telepathy, too */
X			}
X		}
X		else {
X			pline("For some reason, that tasted bland.");
X		}
X		/* fall through to default case */
X	    default: {
X		register struct permonst *ptr = &mons[pm];
X		int i, count;
X
X		if(dmgtype(ptr, AD_STUN) || pm==PM_VIOLET_FUNGUS) {
X			pline ("Oh wow!  Great stuff!");
X			make_hallucinated(HHallucination + 200,FALSE,0L);
X		}
X		/* prevent polymorph abuse by killing/eating your offspring */
X		if(pm >= PM_BABY_GRAY_DRAGON && pm <= PM_BABY_YELLOW_DRAGON)
X			return;
X		if(is_giant(ptr)) gainstr((struct obj *)0, 0);
X
X		/* Check the monster for all of the intrinsics.  If this
X		 * monster can give more than one, pick one to try to give
X		 * from among all it can give.
X		 *
X		 * If a monster can give 4 intrinsics then you have
X		 * a 1/1 * 1/2 * 2/3 * 3/4 = 1/4 chance of getting the first,
X		 * a 1/2 * 2/3 * 3/4 = 1/4 chance of getting the second,
X		 * a 1/3 * 3/4 = 1/4 chance of getting the third,
X		 * and a 1/4 chance of getting the fourth.
X		 *
X		 * And now a proof by induction:
X		 * it works for 1 intrinsic (1 in 1 of getting it)
X		 * for 2 you have a 1 in 2 chance of getting the second,
X		 *	otherwise you keep the first
X		 * for 3 you have a 1 in 3 chance of getting the third,
X		 *	otherwise you keep the first or the second
X		 * for n+1 you have a 1 in n+1 chance of getting the (n+1)st,
X		 *	otherwise you keep the previous one.
X		 * Elliott Kleinrock, October 5, 1990
X		 */
X
X		 count = 0;	/* number of possible intrinsics */
X		 tmp = 0;	/* which one we will try to give */
X		 for (i = 1; i <= LAST_PROP; i++) {
X			if (intrinsic_possible(i, ptr)) {
X				count++;
X				/* a 1 in count chance of replacing the old
X				 * one with this one, and a count-1 in count
X				 * chance of keeping the old one.  (note
X				 * that 1 in 1 and 0 in 1 are what we want
X				 * for the first one
X				 */
X				if (!rn2(count)) {
X#ifdef DEBUG
X					debugpline("Intrinsic %d replacing %d",
X								i, tmp);
X#endif
X					tmp = i;
X				}
X			}
X		 }
X
X		 /* if any found try to give them one */
X		 if (count) givit(tmp, ptr);
X	    }
X	    break;
X	}
X	return;
X}
X
XSTATIC_PTR
Xint
Xopentin()		/* called during each move whilst opening a tin */
X{
X	register int r;
X
X	if(!carried(tin.tin) && !obj_here(tin.tin, u.ux, u.uy))
X					/* perhaps it was stolen? */
X		return(0);		/* %% probably we should use tinoid */
X	if(tin.usedtime++ >= 50) {
X		You("give up your attempt to open the tin.");
X		return(0);
X	}
X	if(tin.usedtime < tin.reqtime)
X		return(1);		/* still busy */
X	if(tin.tin->cursed && tin.tin->spe != -1 && !rn2(8)) {
X		b_trapped("tin");
X		goto use_me;
X	}
X	You("succeed in opening the tin.");
X	if(tin.tin->spe != 1) {
X	    if(tin.tin->corpsenm == -1) {
X		pline("It turns out to be empty.");
X		tin.tin->dknown = tin.tin->known = TRUE;
X		goto use_me;
X	    }
X	    r = tin.tin->cursed ? 4 :		/* Always rotten if cursed */
X		    (tin.tin->spe == -1) ? 5 :	/* "homemade" if player made */
X			rn2(TTSZ-1);		/* else take your pick */
X	    pline("It smells like %s.", makeplural(
X		  Hallucination ? rndmonnam() : mons[tin.tin->corpsenm].mname));
X	    if (yn("Eat it?") == 'n') {
X		if (!Hallucination) tin.tin->dknown = tin.tin->known = TRUE;
X		if (flags.verbose) You("discard the open tin.");
X		goto use_me;
X	    }
X	    You("consume %s %s.", tintxts[r].txt,
X			mons[tin.tin->corpsenm].mname);
X	    tin.tin->dknown = tin.tin->known = TRUE;
X	    cprefx(tin.tin->corpsenm); cpostfx(tin.tin->corpsenm);
X
X	    /* check for vomiting added by GAN 01/16/87 */
X	    if(tintxts[r].nut < 0) make_vomiting((long)rn1(15,10), FALSE);
X	    else lesshungry(tintxts[r].nut);
X
X	    if(r == 0) {			/* Deep Fried */
X		Glib = rnd(15);
X		pline("Eating deep fried food made your %s very slippery.",
X			makeplural(body_part(FINGER)));
X	    }
X	} else {
X	    if (tin.tin->cursed)
X		pline("It contains some decaying %s substance.",
X			Hallucination ? hcolor() : green);
X	    else
X		pline("It contains spinach.");
X
X	    if (yn("Eat it?") == 'n') {
X		if (!Hallucination && !tin.tin->cursed)
X		    tin.tin->dknown = tin.tin->known = TRUE;
X		if (flags.verbose)
X		    You("discard the open tin.");
X		goto use_me;
X	    }
X	    if (!tin.tin->cursed)
X		pline("This makes you feel like %s!",
X		      Hallucination ? "Swee'pea" : "Popeye");
X	    lesshungry(600);
X	    gainstr(tin.tin, 0);
X	}
X	tin.tin->dknown = tin.tin->known = TRUE;
Xuse_me:
X	if (carried(tin.tin)) useup(tin.tin);
X	else useupf(tin.tin);
X	tin.tin = (struct obj *) 0;
X	return(0);
X}
X
Xstatic void
Xstart_tin(otmp)		/* called when starting to open a tin */
X	register struct obj *otmp;
X{
X	register int tmp;
X
X#ifdef POLYSELF
X	if (metallivorous(uasmon)) {
X		You("bite right into the metal tin....");
X		tmp = 1;
X	} else
X#endif
X	if (otmp->blessed) {
X		pline("The tin opens like magic!");
X		tmp = 1;
X	} else if(uwep) {
X		switch(uwep->otyp) {
X		case TIN_OPENER:
X			tmp = 1;
X			break;
X		case DAGGER:
X		case ELVEN_DAGGER:
X		case ORCISH_DAGGER:
X		case ATHAME:
X		case CRYSKNIFE:
X			tmp = 3;
X			break;
X		case PICK_AXE:
X		case AXE:
X			tmp = 6;
X			break;
X		default:
X			goto no_opener;
X		}
X		pline("Using your %s you try to open the tin.",
X			aobjnam(uwep, NULL));
X	} else {
Xno_opener:
X		pline("It is not so easy to open this tin.");
X		if(Glib) {
X			pline("The tin slips out of your hands.");
X			if(otmp->quan > 1L) {
X				register struct obj *obj;
X				obj = splitobj(otmp, 1L);
X				if(otmp == uwep) setuwep(obj);
X			}
X			if (carried(otmp)) dropx(otmp);
X			else stackobj(otmp);
X			return;
X		}
X		tmp = rn1(1 + 500/((int)(ACURR(A_DEX) + ACURRSTR)), 10);
X	}
X	tin.reqtime = tmp;
X	tin.usedtime = 0;
X	tin.tin = otmp;
X	set_occupation(opentin, "opening the tin", 0);
X	return;
X}
X
Xint
XHear_again() {		/* called when waking up after fainting */
X	flags.soundok = 1;
X	return 0;
X}
X
Xstatic int
X#ifdef POLYSELF
Xrottenfood(obj)
Xstruct obj *obj;
X#else
Xrottenfood()
X#endif
X{		/* called on the "first bite" of rotten food */
X#ifdef POLYSELF
X	pline("Blecch!  Rotten %s!", foodword(obj));
X#else
X	pline("Blecch!  Rotten food!");
X#endif
X	if(!rn2(4)) {
X		if (Hallucination) You("feel rather trippy.");
X		else You("feel rather %s.", body_part(LIGHT_HEADED));
X		make_confused(HConfusion + d(2,4),FALSE);
X	} else if(!rn2(4) && !Blind) {
X		pline("Everything suddenly goes dark.");
X		make_blinded((long)d(2,10),FALSE);
X	} else if(!rn2(3)) {
X		if(Blind)
X		  pline("The world spins and you slap against the floor.");
X		else
X		  pline("The world spins and goes dark.");
X		flags.soundok = 0;
X		nomul(-rnd(10));
X		nomovemsg = "You are conscious again.";
X		afternmv = Hear_again;
X		return(1);
X	}
X	return(0);
X}
X
Xstatic int
Xeatcorpse(otmp)		/* called when a corpse is selected as food */
X	register struct obj *otmp;
X{
X	register const char *cname = mons[otmp->corpsenm].mname;
X	register int tp, rotted = 0;
X
X	tp = 0;
X
X	if(otmp->corpsenm != PM_LIZARD) {
X#ifndef LINT	/* problem if more than 320K moves before try to eat */
X		rotted = (monstermoves - otmp->age)/((long)(10 + rn2(20)));
X#endif
X
X		if(otmp->cursed) rotted += 2;
X		else if (otmp->blessed) rotted -= 2;
X	}
X
X	if(otmp->corpsenm != PM_ACID_BLOB && (rotted > 5)) {
X		pline("Ulch - that %s was tainted!",
X		      mons[otmp->corpsenm].mlet == S_FUNGUS ? "fungoid vegetation" :
X		      is_meaty(&mons[otmp->corpsenm]) ? "meat" : "protoplasm");
X#ifdef POLYSELF
X		if (u.usym == S_FUNGUS)
X			pline("It doesn't seem at all sickening, though...");
X		else {
X#endif
X			make_sick((long) rn1(10, 10),FALSE);
X			Sprintf(corpsename, "rotted %s corpse", cname);
X			u.usick_cause = (const char *)corpsename;
X			flags.botl = 1;
X#ifdef POLYSELF
X		}
X#endif
X		if (carried(otmp)) useup(otmp);
X		else useupf(otmp);
X		return(1);
X	} else if(acidic(&mons[otmp->corpsenm])
X#ifdef POLYSELF
X		  && !resists_acid(uasmon)
X#endif
X		 ) {
X		tp++;
X		You("have a very bad case of stomach acid.");
X		losehp(rnd(15), "acidic corpse", KILLED_BY_AN);
X	} else if(poisonous(&mons[otmp->corpsenm]) && rn2(5)) {
X		tp++;
X		pline("Ecch - that must have been poisonous!");
X		if(!Poison_resistance) {
X			losestr(rnd(4));
X			losehp(rnd(15), "poisonous corpse", KILLED_BY_AN);
X		} else	You("seem unaffected by the poison.");
X	/* now any corpse left too long will make you mildly ill */
X	} else if(((rotted > 5) || ((rotted > 3) && rn2(5)))
X#ifdef POLYSELF
X		&& u.usym != S_FUNGUS
X#endif
X							){
X		tp++;
X		You("feel%s sick.", (Sick) ? " very" : "");
X		losehp(rnd(8), "cadaver", KILLED_BY_AN);
X	}
X	if(!tp && otmp->corpsenm != PM_LIZARD && (otmp->orotten || !rn2(7))) {
X#ifdef POLYSELF
X	    if(rottenfood(otmp)) {
X#else
X	    if(rottenfood()) {
X#endif
X		otmp->orotten = TRUE;
X		(void)touchfood(otmp);
X		return(1);
X	    }
X	    otmp->oeaten >>= 2;
X	} else {
X#ifdef POLYSELF
X	    pline("This %s corpse %s!", cname,
X		(carnivorous(uasmon) && !herbivorous(uasmon))
X		? "is delicious" : "tastes terrible");
X#else
X	    pline("This %s corpse tastes terrible!", cname);
X#endif
X	}
X
X	/* delay is weight dependent */
X	victual.reqtime = 3 + (mons[otmp->corpsenm].cwt >> 6);
X	return(0);
X}
X
Xstatic void
Xstart_eating(otmp)		/* called as you start to eat */
X	register struct obj *otmp;
X{
X#ifdef DEBUG
X	debugpline("start_eating: %lx (victual = %lx)", otmp, victual.piece);
X	debugpline("reqtime = %d", victual.reqtime);
X	debugpline("(original reqtime = %d)", objects[otmp->otyp].oc_delay);
X	debugpline("nmod = %d", victual.nmod);
X	debugpline("oeaten = %d", otmp->oeaten);
X#endif
X	victual.fullwarn = victual.doreset = FALSE;
X	victual.eating = TRUE;
X
X	if (otmp->otyp == CORPSE) {
X	    cprefx(victual.piece->corpsenm);
X	    if (!victual.piece && victual.eating) do_reset_eat();
X	    if (victual.eating == FALSE) return; /* died and lifesaved */
X	}
X
X	if (bite()) return;
X
X	if(++victual.usedtime >= victual.reqtime) {
X	    /* print "finish eating" message if they just resumed -dlc */
X	    done_eating(victual.reqtime > 1 ? TRUE : FALSE);
X	    return;
X	}
X
X	Sprintf(msgbuf, "eating %s", the(singular(otmp, xname)));
X	set_occupation(eatfood, msgbuf, 0);
X}
X
X
Xstatic void
Xfprefx(otmp)		/* called on "first bite" of (non-corpse) food */
X
X	register struct obj *otmp;
X{
X	switch(otmp->otyp) {
X
X	    case FOOD_RATION:
X		if(u.uhunger <= 200)
X		    if (Hallucination) pline("Oh wow, like, superior, man!");
X		    else	       pline("That food really hit the spot!");
X		else if(u.uhunger <= 700) pline("That satiated your stomach!");
X		break;
X	    case TRIPE_RATION:
X#ifdef POLYSELF
X		if (carnivorous(uasmon) && !humanoid(uasmon))
X		    pline("That tripe ration was surprisingly good!");
X		else {
X#endif
X		    pline("Yak - dog food!");
X		    more_experienced(1,0);
X		    flags.botl = 1;
X#ifdef POLYSELF
X		}
X#endif
X		if(rn2(2)
X#ifdef POLYSELF
X			&& (!carnivorous(uasmon) || humanoid(uasmon))
X#endif
X						) {
X			make_vomiting((long)rn1(victual.reqtime, 14), FALSE);
X		}
X		break;
X#ifdef POLYSELF
X	    case CLOVE_OF_GARLIC:
X		if (is_undead(uasmon)) {
X			make_vomiting((long)rn1(victual.reqtime, 5), FALSE);
X			break;
X		}
X		/* Fall through otherwise */
X#endif
X	    default:
X#ifdef TUTTI_FRUTTI
X		if (otmp->otyp==SLIME_MOLD && !otmp->cursed
X			&& otmp->spe == current_fruit)
X		    pline("My, that was a yummy %s!", singular(otmp, xname));
X		else
X#endif
X#ifdef UNIX
X		if (otmp->otyp == APPLE || otmp->otyp == PEAR) {
X		    if (!Hallucination) pline("Core dumped.");
X		    else {
X/* This is based on an old Usenet joke, a fake a.out manual page */
X			int x = rnd(100);
X			if (x <= 75)
X			    pline("Segmentation fault -- core dumped.");
X			else if (x <= 99)
X			    pline("Bus error -- core dumped.");
X			else pline("Yo' mama -- core dumped.");
X		    }
X		} else
X#endif
X		    pline("This %s is %s!", singular(otmp, xname),
X		      otmp->cursed ? (Hallucination ? "grody" : "terrible"):
X		      Hallucination ? "gnarly" :
X			(otmp->otyp==CRAM_RATION ? "bland" : "delicious"));
X		break;
X	}
X}
X
X#ifdef POLYSELF
Xstatic void
Xeatring(otmp)
Xstruct obj *otmp;
X{
X	int typ = otmp->otyp;
X	int oldprop;
X
X	/* Note: rings are not so common that this is unbalancing.  (How */
X	/* often do you even _find_ 3 rings of polymorph in a game? */
X	oldprop = !!(u.uprops[objects[typ].oc_oprop].p_flgs);
X	otmp->known = otmp->dknown = 1; /* by taste */
X	if (!rn2(3)) switch (otmp->otyp) {
X	    case RIN_AGGRAVATE_MONSTER:
X	    case RIN_WARNING:
X	    case RIN_POISON_RESISTANCE:
X	    case RIN_FIRE_RESISTANCE:
X	    case RIN_COLD_RESISTANCE:
X	    case RIN_SHOCK_RESISTANCE:
X	    case RIN_TELEPORTATION:
X	    case RIN_TELEPORT_CONTROL:
X	    case RIN_SEE_INVISIBLE:
X	    case RIN_PROTECTION_FROM_SHAPE_CHAN:
X	    case RIN_SEARCHING:
X	    case RIN_STEALTH:
X	    case RIN_INVISIBILITY:
X	    case RIN_CONFLICT:
X	    case RIN_POLYMORPH:
X	    case RIN_POLYMORPH_CONTROL:
X	    case RIN_REGENERATION: /* Probably stupid. */
X	    case RIN_HUNGER: /* Stupid. */
X	    case RIN_LEVITATION: /* Stupid. */
X		if (!(u.uprops[objects[typ].oc_oprop].p_flgs & FROMOUTSIDE))
X		    pline("Magic spreads through your body as you digest the ring.");
X		u.uprops[objects[typ].oc_oprop].p_flgs |= FROMOUTSIDE;
X		if (typ == RIN_SEE_INVISIBLE) {
X		    set_mimic_blocking();
X		    see_monsters();
X		    if (Invis && !oldprop
X#ifdef POLYSELF
X				&& !perceives(uasmon)
X#endif
X							&& !Blind) {
X			newsym(u.ux,u.uy);
X			pline("Suddenly you can see yourself.");
X			makeknown(typ);
X		    }
X		} else if (typ == RIN_INVISIBILITY) {
X		    if (!oldprop && !See_invisible && !Blind) {
X			newsym(u.ux,u.uy);
X			Your("body takes on a %s transparency...",
X				Hallucination ? "normal" : "strange");
X			makeknown(typ);
X		    }
X		} else if (typ == RIN_PROTECTION_FROM_SHAPE_CHAN)
X		    rescham();
X		else if (typ == RIN_LEVITATION) {
X		    if (!Levitation) {
X			float_up();
X			makeknown(typ);
X		    }
X		}
X		break;
X	    case RIN_ADORNMENT:
X		if (adjattrib(A_CHA, otmp->spe, -1))
X		    makeknown(typ);
X		break;
X	    case RIN_GAIN_STRENGTH:
X	    case RIN_INCREASE_DAMAGE: /* Any better ideas? */
X		if (adjattrib(A_STR, otmp->spe, -1))
X		    makeknown(typ);
X		break;
X	    case RIN_PROTECTION:
X		Protection |= FROMOUTSIDE;
X		u.ublessed += otmp->spe;
X		flags.botl = 1;
X		break;
X	}
X}
X
Xstatic void
Xeatspecial() /* called after eating non-food */
X{
X	register struct obj *otmp = victual.piece;
X
X	lesshungry(victual.nmod);
X	victual.piece = (struct obj *)0;
X	victual.eating = 0;
X	if (otmp->oclass == GOLD_CLASS) {
X		dealloc_obj(otmp);
X		return;
X	}
X	if (otmp->oclass == POTION_CLASS) {
X		otmp->quan++; /* dopotion() does a useup() */
X		(void)dopotion(otmp);
X	}
X	if (otmp->oclass == RING_CLASS)
X		eatring(otmp);
X	if (otmp == uball) unpunish();
X	if (otmp == uchain) unpunish(); /* but no useup() */
X	else if (carried(otmp)) useup(otmp);
X	else useupf(otmp);
X}
X
X/* NOTE: the order of these words exactly corresponds to the
X   order of oc_material values #define'd in objclass.h. */
Xstatic const char *foodwords[] = {
X	"meal", "liquid", "wax", "food", "meat",
X	"paper", "cloth", "leather", "wood", "bone", "scale",
X	"metal", "metal", "metal", "silver", "gold", "platinum", "mithril",
X	"plastic", "glass", "rich food", "stone"
X};
X
Xstatic const char *
Xfoodword(otmp)
Xregister struct obj *otmp;
X{
X	if (otmp->oclass == FOOD_CLASS) return "food";
X	if (otmp->oclass == GEM_CLASS &&
X	    objects[otmp->otyp].oc_material == GLASS &&
X	    otmp->dknown)
X		makeknown(otmp->otyp);
X	return foodwords[objects[otmp->otyp].oc_material];
X}
X#endif
X
Xstatic void
Xfpostfx(otmp)		/* called after consuming (non-corpse) food */
X
X	register struct obj *otmp;
X{
X	switch(otmp->otyp) {
X#ifdef POLYSELF
X	    case SPRIG_OF_WOLFSBANE:
X		if (u.ulycn != -1) {
X		    u.ulycn = -1;
X		    You("feel purified.");
X		    if(uasmon == &mons[u.ulycn] && !Polymorph_control)
X			rehumanize();
X		}
X		break;
X#endif
X	    case CARROT:
X		make_blinded(0L,TRUE);
X		break;
X	    case FORTUNE_COOKIE:
X		outrumor(bcsign(otmp), TRUE);
X		break;
X	    case LUMP_OF_ROYAL_JELLY:
X		/* This stuff seems to be VERY healthy! */
X		gainstr(otmp, 1);
X		u.uhp += (otmp->cursed) ? -rnd(20) : rnd(20);
X		if(u.uhp > u.uhpmax) {
X			if(!rn2(17)) u.uhpmax++;
X			u.uhp = u.uhpmax;
X		} else if(u.uhp <= 0) {
X			killer_format = KILLED_BY_AN;
X			killer = "rotten lump of royal jelly";
X			done(POISONING);
X		}
X		if(!otmp->cursed) heal_legs();
X		break;
X	    case EGG:
X		if(otmp->corpsenm == PM_COCKATRICE) {
X#ifdef POLYSELF
X		    if(!resists_ston(uasmon))
X			if(!poly_when_stoned(uasmon) ||
X			   !polymon(PM_STONE_GOLEM))
X		    {
X#endif
X			if (!Stoned) Stoned = 5;
X			killer_format = KILLED_BY_AN;
X			killer = "cockatrice egg";
X#ifdef POLYSELF
X		    }
X#endif
X		}
X		break;
X	}
X	return;
X}
X
Xint
Xdoeat()		/* generic "eat" command funtion (see cmd.c) */
X{
X	register struct obj *otmp;
X	int basenutrit;			/* nutrition of full item */
X
X	if (Strangled) {
X		pline("If you can't breathe air, how can you consume solids?");
X		return 0;
X	}
X	if (!(otmp = floorfood("eat", 0))) return 0;
X	if (check_capacity(NULL)) return 0;
X#ifdef POLYSELF
X	/* We have to make non-foods take no time to eat, unless we want to
X	 * do ridiculous amounts of coding to deal with partly eaten plate
X	 * mails, players who polymorph back to human in the middle of their
X	 * metallic meal, etc....
X	 */
X	if (!is_edible(otmp)) {
X	    You("cannot eat that!");
X	    return 0;
X	}
X	if (otmp->oclass != FOOD_CLASS) {
X	    victual.reqtime = 1;
X	    victual.piece = otmp;
X		/* Don't split it, we don't need to if it's 1 move */
X	    victual.usedtime = 0;
X	    victual.canchoke = (u.uhs == SATIATED);
X		/* Note: gold weighs 1 pt. for each 1000 pieces (see */
X		/* pickup.c) so gold and non-gold is consistent. */
X	    if (otmp->oclass == GOLD_CLASS)
X		basenutrit = ((otmp->quan > 200000L) ? 2000
X			: (int)(otmp->quan/100L));
X	    else basenutrit = objects[otmp->otyp].oc_nutrition;
X	    victual.nmod = basenutrit;
X	    victual.eating = TRUE; /* needed for lesshungry() */
X
X	    if (otmp->cursed)
X		(void) rottenfood(otmp);
X
X	    if (otmp->oclass == WEAPON_CLASS && otmp->opoisoned) {
X		pline("Ecch - that must have been poisonous!");
X		if(!Poison_resistance) {
X		    losestr(rnd(4));
X		    losehp(rnd(15), xname(otmp), KILLED_BY_AN);
X		} else
X		    You("seem unaffected by the poison.");
X	    } else if (!otmp->cursed)
X		pline("This %s is delicious!",
X		      otmp->oclass == GOLD_CLASS ? foodword(otmp) :
X		      singular(otmp, xname));
X	    eatspecial();
X	    return 1;
X	}
X#endif
X
X	if(otmp == victual.piece) {
X	/* If they weren't able to choke, they don't suddenly become able to
X	 * choke just because they were interrupted.  On the other hand, if
X	 * they were able to choke before, if they lost food it's possible
X	 * they shouldn't be able to choke now.
X	 */
X	    if (u.uhs != SATIATED) victual.canchoke = FALSE;
X	    if(!carried(victual.piece)) {
X		if(victual.piece->quan > 1L)
X			(void) splitobj(victual.piece, 1L);
X	    }
X	    You("resume your meal.");
X	    start_eating(victual.piece);
X	    return(1);
X	}
X
X	/* nothing in progress - so try to find something. */
X	/* tins are a special case */
X	if(otmp->otyp == TIN) {
X	    start_tin(otmp);
X	    return(1);
X	}
X
X	victual.piece = otmp = touchfood(otmp);
X	victual.usedtime = 0;
X
X	/* Now we need to calculate delay and nutritional info.
X	 * The base nutrition calculated here and in eatcorpse() accounts
X	 * for normal vs. rotten food.  The reqtime and nutrit values are
X	 * then adjusted in accordance with the amount of food left.
X	 */
X	if(otmp->otyp == CORPSE) {
X	    if(eatcorpse(otmp)) return(1);
X	    /* else eatcorpse sets up reqtime and oeaten */
X	} else {
X	    victual.reqtime = objects[otmp->otyp].oc_delay;
X	    if (otmp->otyp != FORTUNE_COOKIE &&
X		(otmp->cursed ||
X		 (((monstermoves - otmp->age) > (int) otmp->blessed ? 50:30) &&
X		(otmp->orotten || !rn2(7))))) {
X
X#ifdef POLYSELF
X		if(rottenfood(otmp)) {
X#else
X		if(rottenfood()) {
X#endif
X		    otmp->orotten = TRUE;
X		    return(1);
X		}
X		otmp->oeaten >>= 1;
X	    } else fprefx(otmp);
X	}
X
X	/* re-calc the nutrition */
X	if (otmp->otyp == CORPSE) basenutrit = mons[otmp->corpsenm].cnutrit;
X	else basenutrit = objects[otmp->otyp].oc_nutrition;
X
X#ifdef DEBUG
X	debugpline("before rounddiv: victual.reqtime == %d", victual.reqtime);
X	debugpline("oeaten == %d, basenutrit == %d", otmp->oeaten, basenutrit);
X#endif
X	victual.reqtime = (basenutrit == 0 ? 0 :
X		rounddiv(victual.reqtime * (long)otmp->oeaten, basenutrit));
X#ifdef DEBUG
X	debugpline("after rounddiv: victual.reqtime == %d", victual.reqtime);
X#endif
X	/* calculate the modulo value (nutrit. units per round eating)
X	 * note: this isn't exact - you actually lose a little nutrition
X	 *	 due to this method.
X	 * TODO: add in a "remainder" value to be given at the end of the
X	 *	 meal.
X	 */
X	if(victual.reqtime == 0)
X	    /* possible if most has been eaten before */
X	    victual.nmod = 0;
X	else if (otmp->oeaten > victual.reqtime)
X	    victual.nmod = -(otmp->oeaten / victual.reqtime);
X	else
X	    victual.nmod = victual.reqtime % otmp->oeaten;
X	victual.canchoke = (u.uhs == SATIATED);
X
X	start_eating(otmp);
X	return(1);
X}
X
X/* Take a single bite from a piece of food, checking for choking and
X * modifying usedtime.  Returns 1 if they choked and survived, 0 otherwise.
X */
Xstatic int
Xbite()
X{
X	if(victual.canchoke && u.uhunger >= 2000) {
X		choke(victual.piece);
X		return 1;
X	}
X	if (victual.doreset) {
X		do_reset_eat();
X		return 0;
X	}
X	if(victual.nmod < 0) {
X		lesshungry(-victual.nmod);
X		victual.piece->oeaten -= -victual.nmod;
X	} else if(victual.nmod > 0 && (victual.usedtime % victual.nmod)) {
X		lesshungry(1);
X		victual.piece->oeaten--;
X	}
X	recalc_wt();
X	return 0;
X}
X
X#endif /* OVLB */
X#ifdef OVL0
X
Xvoid
Xgethungry()	/* as time goes by - called by moveloop() and domove() */
X{
X	if (u.uinvulnerable) return;	/* you don't feel hungrier */
X
X	if ((!u.usleep || !rn2(10))	/* slow metabolic rate while asleep */
X		&& (carnivorous(uasmon) || herbivorous(uasmon)))
X	    u.uhunger--;		/* ordinary food consumption */
X
X	if (moves % 2) {	/* odd turns */
X	    /* Regeneration uses up food, unless due to an artifact */
X	    if ((HRegeneration & (~W_ART)) &&
X		(HRegeneration != W_WEP || !uwep->oartifact)) u.uhunger--;
X	    if (near_capacity() > SLT_ENCUMBER) u.uhunger--;
X	} else {		/* even turns */
X	    if (Hunger) u.uhunger--;
X	    /* Conflict uses up food too */
X	    if ((Conflict & (~W_ARTI))) u.uhunger--;
X	    /* +0 charged rings don't do anything, so don't affect hunger */
X	    switch (moves % 20) {	/* note: use even cases only */
X	     case  4: if (uleft &&
X			  (uleft->spe || !objects[uleft->otyp].oc_charged))
X			    u.uhunger--;
X		    break;
X	     case  8: if (uamul) u.uhunger--;
X		    break;
X	     case 12: if (uright &&
X			  (uright->spe || !objects[uright->otyp].oc_charged))
X			    u.uhunger--;
X		    break;
X	     case 16: if (u.uhave.amulet) u.uhunger--;
X		    break;
X	     default: break;
X	    }
X	}
X	newuhs(TRUE);
X}
X
X#endif /* OVL0 */
X#ifdef OVLB
X
Xvoid
Xmorehungry(num)	/* called after vomiting and after performing feats of magic */
Xregister int num;
X{
X	u.uhunger -= num;
X	newuhs(TRUE);
X}
X
X
Xvoid
Xlesshungry(num)	/* called after eating (and after drinking fruit juice) */
Xregister int num;
X{
X#ifdef DEBUG
X	debugpline("lesshungry(%d)", num);
X#endif
X	u.uhunger += num;
X	if(u.uhunger >= 2000) {
X	    if (!victual.eating || victual.canchoke)
X		if (victual.eating) {
X			choke(victual.piece);
X			reset_eat();
X		} else
X		if (tin.tin)
X			choke(tin.tin);
X		else
X			choke((struct obj *) 0);
X		/* no reset_eat(); it was a non-food such as juice */
X	} else {
X	    /* Have lesshungry() report when you're nearly full so all eating
X	     * warns when you're about to choke.
X	     */
X	    if (u.uhunger >= 1500) {
X	      if(!victual.eating || (victual.eating && !victual.fullwarn)) {
X		pline("You're having a hard time getting all of it down.");
X		nomovemsg = "You're finally finished.";
X		if(!victual.eating)
X		    multi = -2;
X		else {
X		    victual.fullwarn = TRUE;
X		    if (victual.canchoke &&
X			/* a one-gulp food will not survive a stop */
X				objects[victual.piece->otyp].oc_delay > 1) {
X			if(yn("Stop eating?") == 'y')
X			{
X				reset_eat();
X				nomovemsg = NULL;
X			}
X		    }
X		}
X	      }
X	    }
X	}
X	newuhs(FALSE);
X}
X
XSTATIC_PTR
Xint
Xunfaint() {
X	(void) Hear_again();
X	if(u.uhs > FAINTING)
X		u.uhs = FAINTING;
X	stop_occupation();
X	flags.botl = 1;
X	return 0;
X}
X
X#endif /* OVLB */
X#ifdef OVL0
X
Xboolean
Xis_fainted() {
X	return(u.uhs == FAINTED);
X}
X
Xvoid
Xreset_faint() {	/* call when a faint must be prematurely terminated */
X	if(is_fainted()) nomul(0);
X}
X
X#if 0
Xvoid
Xsync_hunger() {
X
X	if(is_fainted()) {
X
X		flags.soundok = 0;
X		nomul(-10+(u.uhunger/10));
X		nomovemsg = "You regain consciousness.";
X		afternmv = unfaint;
X	}
X}
X#endif
X
Xvoid
Xnewuhs(incr)		/* compute and comment on your (new?) hunger status */
X	boolean incr;
X{
X	register int newhs, h = u.uhunger;
X
X	newhs = (h > 1000) ? SATIATED :
X		(h > 150) ? NOT_HUNGRY :
X		(h > 50) ? HUNGRY :
X		(h > 0) ? WEAK : FAINTING;
X
X	if(newhs == FAINTING) {
X		if(is_fainted()) newhs = FAINTED;
X		if(u.uhs <= WEAK || rn2(20-u.uhunger/10) >= 19) {
X			if(!is_fainted() && multi >= 0 /* %% */) {
X				/* stop what you're doing, then faint */
X				stop_occupation();
X				You("faint from lack of food.");
X				flags.soundok = 0;
X				nomul(-10+(u.uhunger/10));
X				nomovemsg = "You regain consciousness.";
X				afternmv = unfaint;
X				newhs = FAINTED;
X			}
X		} else
X		if(u.uhunger < -(int)(200 + 20*ACURR(A_CON))) {
X			u.uhs = STARVED;
X			flags.botl = 1;
X			bot();
X			You("die from starvation.");
X			killer_format = KILLED_BY;
X			killer = "starvation";
X			done(STARVING);
X			/* if we return, we lifesaved, and that calls newuhs */
X			return;
X		}
X	}
X
X	if(newhs != u.uhs) {
X		if(newhs >= WEAK && u.uhs < WEAK)
X			losestr(1);	/* this may kill you -- see below */
X		else if(newhs < WEAK && u.uhs >= WEAK)
X			losestr(-1);
X		switch(newhs){
X		case HUNGRY:
X			if (Hallucination) {
X			    pline((!incr) ?
X				"You now have a lesser case of the munchies." :
X				"You are getting the munchies.");
X			} else
X			    You((!incr) ? "only feel hungry now." :
X				  (u.uhunger < 145) ? "feel hungry." :
X				   "are beginning to feel hungry.");
X			if (incr && occupation &&
X			    (occupation != eatfood && occupation != opentin))
X			    stop_occupation();
X			break;
X		case WEAK:
X			if (Hallucination)
X			    pline((!incr) ?
X				  "You still have the munchies." :
X      "The munchies are interfering with your motor capabilities.");
X			else
X			    You((!incr) ? "feel weak now." :
X				  (u.uhunger < 45) ? "feel weak." :
X				   "are beginning to feel weak.");
X			if (incr && occupation &&
X			    (occupation != eatfood && occupation != opentin))
X			    stop_occupation();
X			break;
X		}
X		u.uhs = newhs;
X		flags.botl = 1;
X		if(u.uhp < 1) {
X			You("die from hunger and exhaustion.");
X			killer_format = KILLED_BY;
X			killer = "exhaustion";
X			done(STARVING);
X			return;
X		}
X	}
X}
X
X#endif /* OVL0 */
X#ifdef OVLB
X
X/* Returns an object representing food.  Object may be either on floor or
X * in inventory.
X */
Xstruct obj *
Xfloorfood(verb,corpseonly)	/* get food from floor or pack */
X	const char *verb;
X	boolean corpseonly;
X{
X	register struct obj *otmp;
X	char qbuf[QBUFSZ];
X	char c;
X#ifdef POLYSELF
X	struct obj *gold = g_at(u.ux, u.uy);
X	boolean feeding = (!strcmp(verb, "eat"));
X
X	if (feeding && gold && metallivorous(uasmon)) {
X	    if (gold->quan == 1L)
X		Sprintf(qbuf, "There is 1 gold piece here; eat it?");
X	    else Sprintf(qbuf, "There are %ld gold pieces here; eat them?",
X								gold->quan);
X	    if (yn(qbuf) == 'y') {
X		/* tricky, because gold isn't a real object -dlc */
X		freeobj(gold);
X		return gold;
X	    }
X	}
X#endif
X	/* Is there some food (probably a heavy corpse) here on the ground? */
X	if (!(Levitation && !Is_airlevel(&u.uz)  && !Is_waterlevel(&u.uz))
X	    && !u.uswallow) {
X	    for(otmp = level.objects[u.ux][u.uy]; otmp; otmp = otmp->nexthere) {
X		if(corpseonly ? otmp->otyp==CORPSE :
X#ifdef POLYSELF
X		    feeding ? (otmp->oclass != GOLD_CLASS && is_edible(otmp)) :
X#endif
X						otmp->oclass==FOOD_CLASS) {
X			Sprintf(qbuf, "There %s %s here; %s %s?",
X				(otmp->quan == 1L) ? "is" : "are",
X				doname(otmp), verb,
X				(otmp->quan == 1L) ? "it" : "one");
X			if((c = yn_function(qbuf,ynqchars,'n')) == 'y')
X				return(otmp);
X			else if(c == 'q')
X				return((struct obj *) 0);
X		}
X	    }
X	}
X#ifdef POLYSELF
X	/* We cannot use ALL_CLASSES since that causes getobj() to skip its
X	 * "ugly checks" and we need to check for inedible items.
X	 */
X	return getobj(feeding ? (const char *)allobj :
X				(const char *)comestibles, verb);
X#else
X	return getobj(comestibles, verb);
X#endif
X}
X
X/* Side effects of vomiting */
X/* added nomul (MRS) - it makes sense, you're too busy being sick! */
X/* TO DO: regurgitate swallowed monsters when poly'd */
Xvoid
Xvomit() {		/* A good idea from David Neves */
X	make_sick(0L,TRUE);
X	nomul(-2);
X}
X
Xint
Xeaten_stat(base, obj)
Xregister int base;
Xregister struct obj *obj;
X{
X	long uneaten_amt, full_amount;
X
X	uneaten_amt = (long)obj->oeaten;
X	full_amount = (obj->otyp == CORPSE) ? (long)mons[obj->corpsenm].cnutrit
X					: (long)objects[obj->otyp].oc_nutrition;
X
X	base = (int)(full_amount ? (long)base * uneaten_amt / full_amount : 0L);
X	return (base < 1) ? 1 : base;
X}
X
X#endif /* OVLB */
X
X/*eat.c*/
END_OF_FILE
if test 47298 -ne `wc -c <'src/eat.c'`; then
    echo shar: \"'src/eat.c'\" unpacked with wrong size!
fi
# end of 'src/eat.c'
fi
if test -f 'sys/mac/mhdump.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/mac/mhdump.c'\"
else
echo shar: Extracting \"'sys/mac/mhdump.c'\" \(127 characters\)
sed "s/^X//" >'sys/mac/mhdump.c' <<'END_OF_FILE'
X/* Dump file creator for MPW */
X
X#define NEED_VARARGS
X
X#include ":Include:hack.h"
X
X#pragma dump ":Obj:hack.hdump"
X
X
Xdummy() {}
END_OF_FILE
if test 127 -ne `wc -c <'sys/mac/mhdump.c'`; then
    echo shar: \"'sys/mac/mhdump.c'\" unpacked with wrong size!
fi
# end of 'sys/mac/mhdump.c'
fi
echo shar: End of archive 12 \(of 108\).
cp /dev/null ark12isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \
21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \
41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 \
61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 \
81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 \
101 102 103 104 105 106 107 108 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 108 archives.
    echo "Now execute 'rebuild.sh'"
    rm -f ark10[0-8]isdone ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
