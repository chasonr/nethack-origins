Path: uunet!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v16i003:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Part03/108
Message-ID: <4286@master.CNA.TEK.COM>
Date: 28 Jan 93 19:10:29 GMT
Sender: news@master.CNA.TEK.COM
Lines: 2215
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1559

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 16, Issue 3
Archive-name: nethack31/Part03
Supersedes: nethack3p9: Volume 10, Issue 46-102
Environment: Amiga, Atari, Mac, MS-DOS, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 3 (of 108)."
# Contents:  include/attrib.h src/apply.c
# Wrapped by billr@saab on Wed Jan 27 16:08:46 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'include/attrib.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/attrib.h'\"
else
echo shar: Extracting \"'include/attrib.h'\" \(992 characters\)
sed "s/^X//" >'include/attrib.h' <<'END_OF_FILE'
X/*	SCCS Id: @(#)attrib.h	3.1	90/22/02	*/
X/* Copyright 1988, Mike Stephenson				  */
X/* NetHack may be freely redistributed.  See license for details. */
X
X/*	attrib.h - Header file for character class processing. */
X
X#ifndef ATTRIB_H
X#define ATTRIB_H
X
X#define A_STR	0
X#define A_INT	1
X#define A_WIS	2
X#define A_DEX	3
X#define A_CON	4
X#define A_CHA	5
X
X#define A_MAX	6	/* used in rn2() selection of attrib */
X
X#define ABASE(x)	(u.acurr.a[x])
X#define ABON(x)		(u.abon.a[x])
X#define AEXE(x)		(u.aexe.a[x])
X#define ACURR(x)	(acurr(x))
X#define ACURRSTR	(acurrstr())
X/* should be: */
X/* #define ACURR(x) (ABON(x) + ATEMP(x) + (u.umonnum == -1) ? ABASE(x) : MBASE(x)) */
X#define MCURR(x)	(u.macurr.a[x])
X#define AMAX(x)		(u.amax.a[x])
X#define MMAX(x)		(u.mamax.a[x])
X
X#define ATEMP(x)	(u.atemp.a[x])
X#define ATIME(x)	(u.atime.a[x])
X
Xstruct	attribs {
X	schar	a[A_MAX];
X};
X
Xextern struct attribs attrmax, attrmin;
X
X#define ATTRMAX(x) (attrmax.a[x])
X#define ATTRMIN(x) (attrmin.a[x])
X
X#endif /* ATTRIB_H */
END_OF_FILE
if test 992 -ne `wc -c <'include/attrib.h'`; then
    echo shar: \"'include/attrib.h'\" unpacked with wrong size!
fi
# end of 'include/attrib.h'
fi
if test -f 'src/apply.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/apply.c'\"
else
echo shar: Extracting \"'src/apply.c'\" \(52659 characters\)
sed "s/^X//" >'src/apply.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)apply.c	3.1	92/12/10		  */
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include "hack.h"
X#include "edog.h"
X
X#ifdef OVLB
X
Xstatic const char NEARDATA tools[] = { TOOL_CLASS, 0 };
X
Xstatic boolean NEARDATA did_dig_msg;
X
X#ifdef TOURIST
Xstatic int FDECL(use_camera, (struct obj *));
X#endif
Xstatic int FDECL(use_towel, (struct obj *));
Xstatic void FDECL(use_stethoscope, (struct obj *));
Xstatic void FDECL(use_whistle, (struct obj *));
Xstatic void FDECL(use_magic_whistle, (struct obj *));
X#ifdef WALKIES
Xstatic void FDECL(use_leash, (struct obj *));
X#endif
XSTATIC_DCL int NDECL(dig);
X#ifdef OVLB
XSTATIC_DCL schar FDECL(fillholetyp, (int, int));
X#endif
Xstatic boolean FDECL(wield_tool, (struct obj *));
Xstatic int FDECL(use_pick_axe, (struct obj *));
Xstatic int FDECL(use_mirror, (struct obj *));
Xstatic void FDECL(use_bell, (struct obj *));
Xstatic void FDECL(use_candelabrum, (struct obj *));
Xstatic void FDECL(use_candle, (struct obj *));
Xstatic void FDECL(use_lamp, (struct obj *));
Xstatic void FDECL(use_tinning_kit, (struct obj *));
Xstatic void FDECL(use_figurine, (struct obj *));
Xstatic void FDECL(use_grease, (struct obj *));
Xstatic boolean NDECL(rm_waslit);
Xstatic void FDECL(mkcavepos, (XCHAR_P,XCHAR_P,int,BOOLEAN_P,BOOLEAN_P));
Xstatic void FDECL(mkcavearea, (BOOLEAN_P));
X
X#ifdef TOURIST
Xstatic int
Xuse_camera(obj)
X	struct obj *obj;
X{
X	register struct monst *mtmp;
X
X	if(Underwater) {
X		pline("Using your camera underwater voids the warranty.");
X		return(0);
X	}
X	if(!getdir(NULL)) return(0);
X	if(u.uswallow) {
X		You("take a picture of %s's %s.", mon_nam(u.ustuck),
X		    is_animal(u.ustuck->data) ? "stomach" : "interior");
X	} else if(obj->cursed && !rn2(2)) goto blindu;
X	else if(u.dz) {
X		You("take a picture of the %s.",
X			(u.dz > 0) ? "floor" : "ceiling");
X	} else if(!u.dx && !u.dy) {
Xblindu:
X		if(!Blind) {
X			You("are blinded by the flash!");
X			make_blinded((long)rnd(25),FALSE);
X		}
X	} else if(mtmp = bhit(u.dx,u.dy,COLNO,FLASHED_LIGHT,
X						(int(*)())0,(int(*)())0,obj)) {
X		if(mtmp->msleep) {
X		    mtmp->msleep = 0;
X		    if(cansee(mtmp->mx,mtmp->my))
X			pline("The flash awakens %s.", mon_nam(mtmp)); /* a3 */
X		} else if (mtmp->data->mlet != S_LIGHT)
X		    if((mtmp->mcansee && haseyes(mtmp->data))
X		       || mtmp->mblinded) {
X			register int tmp = distu(mtmp->mx,mtmp->my);
X			register int tmp2;
X
X			if(cansee(mtmp->mx,mtmp->my))
X			    pline("%s is blinded by the flash!", Monnam(mtmp));
X			if(mtmp->data == &mons[PM_GREMLIN]) {
X			    /* Rule #1: Keep them out of the light. */
X			    pline("%s cries out in pain!", Monnam(mtmp));
X			    if (mtmp->mhp > 1) mtmp->mhp--;
X			}
X			setmangry(mtmp);
X			if(tmp < 9 && !mtmp->isshk && rn2(4)) {
X				mtmp->mflee = 1;
X				if(rn2(4)) mtmp->mfleetim = rnd(100);
X			}
X			mtmp->mcansee = 0;
X			if(tmp < 3) {
X				mtmp->mblinded = 0;
X			} else {
X				tmp2 = mtmp->mblinded;
X				tmp2 += rnd(1 + 50/tmp);
X				if(tmp2 > 127) tmp2 = 127;
X				mtmp->mblinded = tmp2;
X			}
X		    }
X	}
X	return 1;
X}
X#endif
X
Xstatic int
Xuse_towel(obj)
X	struct obj *obj;
X{
X	if(!freehand()) {
X		You("have no free %s!", body_part(HAND));
X		return 0;
X	} else if (obj->owornmask) {
X		You("can't use it while you're wearing it!");
X		return 0;
X	} else if (obj->cursed) {
X		long old;
X		switch (rn2(3)) {
X		case 2:
X		    old = Glib;
X		    Glib += rn1(10, 3);
X		    Your("%s are %s!", makeplural(body_part(HAND)),
X			(old ? "filthier than ever" : "now slimy"));
X		    return 1;
X		case 1:
X		    if (!Blindfolded) {
X			old = u.ucreamed;
X			u.ucreamed += rn1(10, 3);
X			pline("Yecch! Your %s %s gunk on it!", body_part(FACE),
X			      (old ? "has more" : "now has"));
X			make_blinded(Blinded + (long)u.ucreamed - old, TRUE);
X		    } else {
X			if (ublindf->cursed) {
X			    You("pushed your blindfold %s.",
X				rn2(2) ? "cock-eyed" : "crooked");
X			} else {
X			    You("pushed your blindfold off.");
X			    Blindf_off(ublindf);
X			    dropx(ublindf);
X			}
X		    }
X		    return 1;
X		case 0:
X		    break;
X		}
X	}
X
X	if (Glib) {
X		Glib = 0;
X		You("wipe off your %s.", makeplural(body_part(HAND)));
X		return 1;
X	} else if(u.ucreamed) {
X		Blinded -= u.ucreamed;
X		u.ucreamed = 0;
X
X		if (!Blinded) {
X			pline("You've got the glop off.");
X			Blinded = 1;
X			make_blinded(0L,TRUE);
X		} else {
X			Your("%s feels clean now.", body_part(FACE));
X		}
X		return 1;
X	}
X
X	Your("%s and %s are already clean.", 
X		body_part(FACE), makeplural(body_part(HAND)));
X
X	return 0;
X}
X
Xstatic char hollow_str[] = "hear a hollow sound!  This must be a secret %s!";
X
X/* Strictly speaking it makes no sense for usage of a stethoscope to
X   not take any time; however, unless it did, the stethoscope would be
X   almost useless. */
Xstatic void
Xuse_stethoscope(obj)
X	register struct obj *obj;
X{
X	register struct monst *mtmp;
X	register struct rm *lev;
X	register int rx, ry;
X
X	if(!freehand()) {
X		You("have no free %s!", body_part(HAND));
X		return;
X	}
X	if (!getdir(NULL)) return;
X	if (u.uswallow && (u.dx || u.dy || u.dz)) {
X		mstatusline(u.ustuck);
X		return;
X	} else if (u.dz) {
X		if (Underwater)
X		    You("hear faint splashing.");
X		else if (u.dz < 0 || Levitation)
X		    You("can't reach the %s!", u.dz<0 ? "ceiling" : "floor");
X		else if (Is_stronghold(&u.uz))
X		    You("hear the crackling of hellfire.");
X		else
X		    pline("The floor seems healthy enough.");
X		return;
X	} else if (obj->cursed && !rn2(2)) {
X		You("hear your heart beat.");
X		return;
X	}
X	if (Stunned || (Confusion && !rn2(5))) confdir();
X	if (!u.dx && !u.dy) {
X		ustatusline();
X		return;
X	}
X	rx = u.ux + u.dx; ry = u.uy + u.dy;
X	if (!isok(rx,ry)) {
X		You("hear a faint typing noise.");
X		return;
X	}
X	if(mtmp = m_at(rx,ry)) {
X		mstatusline(mtmp);
X		if (mtmp->mundetected) {
X			mtmp->mundetected = 0;
X			if (cansee(rx,ry)) newsym(mtmp->my,mtmp->my);
X		}
X		return;
X	}
X	lev = &levl[rx][ry];
X	switch(lev->typ) {
X	case SDOOR:
X		You(hollow_str, "door");
X		lev->typ = DOOR;
X		newsym(rx,ry);
X		return;
X	case SCORR:
X		You(hollow_str, "passage");
X		lev->typ = CORR;
X		newsym(rx,ry);
X		return;
X	}
X	You("hear nothing special.");
X}
X
Xstatic char whistle_str[] = "produce a %s whistling sound.";
X
X/*ARGSUSED*/
Xstatic void
Xuse_whistle(obj)
Xstruct obj *obj;
X{
X	You(whistle_str, "high");
X	wake_nearby();
X}
X
Xstatic void
Xuse_magic_whistle(obj)
Xstruct obj *obj;
X{
X	register struct monst *mtmp;
X
X	if(obj->cursed && !rn2(2)) {
X		You("produce a high-pitched humming noise.");
X		wake_nearby();
X	} else {
X		makeknown(MAGIC_WHISTLE);
X		You(whistle_str, Hallucination ? "normal" : "strange");
X		for(mtmp = fmon; mtmp; mtmp = mtmp->nmon)
X			if(mtmp->mtame) mnexto(mtmp);
X	}
X}
X
Xboolean
Xum_dist(x,y,n)
Xregister xchar x, y, n;
X{
X	return(abs(u.ux - x) > n  || abs(u.uy - y) > n);
X}
X
X#endif /* OVLB */
X
X#ifdef WALKIES
X#define MAXLEASHED	2
X
X#ifdef OVLB
X
Xint
Xnumber_leashed()
X{
X	register int i = 0;
X	register struct obj *obj;
X
X	for(obj = invent; obj; obj = obj->nobj)
X		if(obj->otyp == LEASH && obj->leashmon != 0) i++;
X	return(i);
X}
X
Xvoid
Xo_unleash(otmp) 	/* otmp is about to be destroyed or stolen */
Xregister struct obj *otmp;
X{
X	register struct monst *mtmp;
X
X	for(mtmp = fmon; mtmp; mtmp = mtmp->nmon)
X		if(mtmp->m_id == (unsigned)otmp->leashmon)
X			mtmp->mleashed = 0;
X	otmp->leashmon = 0;
X}
X
Xvoid
Xm_unleash(mtmp) 	/* mtmp is about to die, or become untame */
Xregister struct monst *mtmp;
X{
X	register struct obj *otmp;
X
X	for(otmp = invent; otmp; otmp = otmp->nobj)
X		if(otmp->otyp == LEASH &&
X				otmp->leashmon == (int)mtmp->m_id)
X			otmp->leashmon = 0;
X	mtmp->mleashed = 0;
X}
X
Xvoid
Xunleash_all()		/* player is about to die (for bones) */
X{
X	register struct obj *otmp;
X	register struct monst *mtmp;
X
X	for(otmp = invent; otmp; otmp = otmp->nobj)
X		if(otmp->otyp == LEASH) otmp->leashmon = 0;
X	for(mtmp = fmon; mtmp; mtmp = mtmp->nmon)
X		if(mtmp->mtame) mtmp->mleashed = 0;
X}
X
X/* ARGSUSED */
Xstatic void
Xuse_leash(obj)
Xstruct obj *obj;
X{
X	register int x, y;
X	register struct monst *mtmp;
X	int spotmon;
X
X	if(!obj->leashmon && number_leashed() >= MAXLEASHED) {
X		You("can't leash additional pets.");
X		return;
X	}
X
X	if(!getdir(NULL)) return;
X
X	x = u.ux + u.dx;
X	y = u.uy + u.dy;
X
X	if((x == u.ux) && (y == u.uy)) {
X		pline("Leash yourself?  Very funny...");
X		return;
X	}
X
X	if(!(mtmp = m_at(x, y))) {
X		pline("There is no creature here.");
X		return;
X	}
X
X	spotmon = canseemon(mtmp) || sensemon(mtmp);
X
X	if(!mtmp->mtame) {
X	    if(!spotmon)
X		pline("There is no creature here.");
X	    else
X		pline("%s is not %s!", Monnam(mtmp), (!obj->leashmon) ?
X				"leashable" : "leashed");
X	    return;
X	}
X	if(!obj->leashmon) {
X		if(mtmp->mleashed) {
X			pline("This %s is already leashed!",
X			      spotmon ? l_monnam(mtmp) : "monster");
X			return;
X		}
X		You("slip the leash around %s%s.",
X		    spotmon ? "your " : "", l_monnam(mtmp));
X		mtmp->mleashed = 1;
X		obj->leashmon = (int)mtmp->m_id;
X		if(mtmp->msleep)  mtmp->msleep = 0;
X		return;
X	}
X	if(obj->leashmon != (int)mtmp->m_id) {
X		pline("This leash is not attached to that creature!");
X		return;
X	} else {
X		if(obj->cursed) {
X			pline("The leash wouldn't come off!");
X			return;
X		}
X		mtmp->mleashed = 0;
X		obj->leashmon = 0;
X		You("remove the leash from %s%s.",
X		    spotmon ? "your " : "", l_monnam(mtmp));
X	}
X	return;
X}
X
X#endif /* OVLB */
X#ifdef OVL1
X
Xboolean
Xnext_to_u()
X{
X	register struct monst *mtmp;
X	register struct obj *otmp;
X
X	for(mtmp = fmon; mtmp; mtmp = mtmp->nmon)
X		if(mtmp->mleashed) {
X			if (distu(mtmp->mx,mtmp->my) > 2) mnexto(mtmp);
X			if (distu(mtmp->mx,mtmp->my) > 2) {
X			    for(otmp = invent; otmp; otmp = otmp->nobj)
X				if(otmp->otyp == LEASH &&
X					otmp->leashmon == (int)mtmp->m_id) {
X				    if(otmp->cursed) return(FALSE);
X				    You("feel %s leash go slack.",
X					(number_leashed() > 1) ? "a" : "the");
X				    mtmp->mleashed = 0;
X				    otmp->leashmon = 0;
X				}
X			}
X		}
X	return(TRUE);
X}
X
X#endif /* OVL1 */
X#ifdef OVLB
Xstruct obj *
Xget_mleash(mtmp) 	/* assuming mtmp->mleashed has been checked */
Xregister struct monst *mtmp;
X{
X	register struct obj *otmp;
X
X	otmp = invent;
X	while(otmp) {
X		if(otmp->otyp == LEASH && otmp->leashmon == (int)mtmp->m_id)
X			return(otmp);
X		otmp = otmp->nobj;
X	}
X	return((struct obj *)0);
X}
X#endif /* OVLB */
X
X#endif /* WALKIES */
X#ifdef OVL0
X
X#ifdef WALKIES
Xvoid
Xcheck_leash(x, y)
Xregister xchar x, y;
X{
X	register struct obj *otmp;
X	register struct monst *mtmp = fmon;
X
X	for(otmp = invent; otmp; otmp = otmp->nobj)
X	    if(otmp->otyp == LEASH && otmp->leashmon != 0) {
X		while(mtmp) {
X		    if((int)mtmp->m_id == otmp->leashmon &&
X			    (dist2(u.ux,u.uy,mtmp->mx,mtmp->my) >
X				dist2(x,y,mtmp->mx,mtmp->my))
X			) {
X			if(otmp->cursed) {
X			    if(um_dist(mtmp->mx, mtmp->my, 5)) {
X				pline("%s chokes to death!",Monnam(mtmp));
X				mondied(mtmp);
X			    } else
X				if(um_dist(mtmp->mx, mtmp->my, 3))
X					pline("%s chokes on the leash!",
X						Monnam(mtmp));
X			} else {
X			    if(um_dist(mtmp->mx, mtmp->my, 5)) {
X				pline("%s's leash snaps loose!",Monnam(mtmp));
X				m_unleash(mtmp);
X			    } else {
X				if(um_dist(mtmp->mx, mtmp->my, 3)) {
X				    You("pull on the leash.");
X# ifdef SOUNDS
X				    if (mtmp->data->msound != MS_SILENT)
X				    switch(rn2(3)) {
X					case 0:  growl(mtmp);	break;
X					case 1:  yelp(mtmp);	break;
X					default: whimper(mtmp); break;
X				    }
X# endif
X				}
X			    }
X			}
X		    }
X		    mtmp = mtmp->nmon;
X		}
X	    }
X}
X
X#endif /* WALKIES */
X
X#endif /* OVL0 */
X#ifdef OVLB
X
Xstatic boolean
Xrm_waslit() {
X    register xchar x, y;
X
X    if(levl[u.ux][u.uy].typ == ROOM && levl[u.ux][u.uy].waslit) 
X        return(TRUE);
X    for(x = u.ux-2; x < u.ux+3; x++)
X        for(y = u.uy-1; y < u.uy+2; y++)
X	    if(isok(x,y) && levl[x][y].waslit) return(TRUE);
X    return(FALSE);
X}
X
X/* Change level topology.  Messes with vision tables and ignores things like
X * boulders in the name of a nice effect.  Vision will get fixed up again
X * immediately after the effect is complete.
X */
Xstatic void
Xmkcavepos(x, y, dist, waslit, rockit)
X    xchar x,y;
X    int dist;
X    boolean waslit, rockit;
X{
X    register struct rm *lev;
X
X    if(!isok(x,y)) return;
X    lev = &levl[x][y];
X
X    if(rockit) {
X        register struct monst *mtmp;
X
X        if(IS_ROCK(lev->typ)) return;
X	if(t_at(x, y)) return; /* don't cover the portal */
X	if(mtmp = m_at(x, y)) /* make sure crucial monsters survive */
X	    if(!passes_walls(mtmp->data)) rloc(mtmp);
X    } else if(lev->typ == ROOM) return;
X
X    unblock_point(x,y);	/* make sure vision knows this location is open */
X
X    /* fake out saved state */
X    lev->seen = FALSE;
X    lev->doormask = 0;
X    if(dist < 3) lev->lit = (rockit ? FALSE : TRUE);
X    if(waslit) lev->waslit = (rockit ? FALSE : TRUE);
X    lev->horizontal = FALSE;
X    viz_array[y][x] = (dist < 3 ) ?
X	(IN_SIGHT|COULD_SEE) : /* short-circuit vision recalc */
X	COULD_SEE;
X    lev->typ = (rockit ? STONE : ROOM);
X    if(dist >= 3)
X	impossible("mkcavepos called with dist %d", dist);
X    if(Blind)
X	feel_location(x, y);
X    else newsym(x,y);
X}
X
Xstatic void
Xmkcavearea(rockit)
Xregister boolean rockit;
X{
X    int dist;
X    xchar xmin = u.ux, xmax = u.ux;
X    xchar ymin = u.uy, ymax = u.uy;
X    register xchar i;
X    register boolean waslit = rm_waslit();
X
X    if(rockit) pline("Crash!  The ceiling collapses around you!");
X    else pline("A mysterious force %s cave around you!",
X	     (levl[u.ux][u.uy].typ == CORR) ? "creates a" : "extends the");
X    display_nhwindow(WIN_MESSAGE, TRUE);
X
X    for(dist = 1; dist <= 2; dist++) {
X	xmin--; xmax++;
X
X	/* top and bottom */
X	if(dist < 2) { /* the area is wider that it is high */
X	    ymin--; ymax++;
X	    for(i = xmin+1; i < xmax; i++) {
X		mkcavepos(i, ymin, dist, waslit, rockit);
X		mkcavepos(i, ymax, dist, waslit, rockit);
X	    }
X	}
X
X	/* left and right */
X	for(i = ymin; i <= ymax; i++) {
X	    mkcavepos(xmin, i, dist, waslit, rockit);
X	    mkcavepos(xmax, i, dist, waslit, rockit);
X	}
X
X	flush_screen(1);	/* make sure the new glyphs shows up */
X	delay_output();
X    }
X
X    if(!rockit && levl[u.ux][u.uy].typ == CORR) {
X        levl[u.ux][u.uy].typ = ROOM;
X	if(waslit) levl[u.ux][u.uy].waslit = TRUE;
X	newsym(u.ux, u.uy); /* in case player is invisible */
X    }
X
X    vision_full_recalc = 1;	/* everything changed */
X}
X
XSTATIC_OVL int
Xdig()
X{
X	register struct rm *lev;
X	register xchar dpx = dig_pos.x, dpy = dig_pos.y;
X
X	lev = &levl[dpx][dpy];
X	/* perhaps a nymph stole your pick-axe while you were busy digging */
X	/* or perhaps you teleported away */
X	if(u.uswallow || !uwep || uwep->otyp != PICK_AXE ||
X	    !on_level(&dig_level, &u.uz) ||
X	    ((dig_down && (dpx != u.ux || dpy != u.uy)) ||
X	     (!dig_down && distu(dpx,dpy) > 2)))
X		return(0);
X	if (dig_down) {
X	    if(On_stairs(u.ux, u.uy)) {
X		if(u.ux == xdnladder || u.ux == xupladder)
X		     pline("The ladder resists your effort.");
X		else pline("The stairs here are too hard to dig in.");
X		return(0);
X	    }
X	    if(IS_THRONE(levl[u.ux][u.uy].typ)) {
X		pline("The throne here is too hard to break apart.");
X		return (0);
X	    }
X	    if(IS_ALTAR(levl[u.ux][u.uy].typ)) {
X		pline("The altar here is too hard to break apart.");
X		return (0);
X	    }
X	    if(t_at(dpx, dpy) && !Can_dig_down(&u.uz)) {
X		pline("The floor here is too hard to dig in.");
X		return(0);
X	    }
X	    if(sobj_at(BOULDER, dpx, dpy)) {
X		pline("There is not enough room here to dig.");
X		return(0);
X	    }
X	    if(Is_airlevel(&u.uz)) {
X		You("cannot dig in thin air.");
X		return(0);
X	    }
X	    if(Is_waterlevel(&u.uz)) {
X		pline("The water splashes and subsides.");
X		return(0);
X	    }
X	} else /* !dig_down */
X	    if(IS_ROCK(lev->typ) && !may_dig(dpx,dpy)) {
X		pline("This wall is too hard to dig into.");
X		return(0);
X	    }
X	if(Fumbling && !rn2(3)) {
X		switch(rn2(3)) {
X		case 0:  if(!welded(uwep)) {
X			     You("fumble and drop your %s.", xname(uwep));
X			     dropx(uwep);
X			     setuwep((struct obj *)0);
X			 } else {
X			     pline("Ouch!  Your %s bounces and hits you!",
X				xname(uwep));
X			     set_wounded_legs(RIGHT_SIDE, 5 + rnd(5));
X			 }
X			 break;
X		case 1:  pline("Bang!  You hit with the broad side of %s!",
X			       the(xname(uwep)));
X			 break;
X		default: Your("swing misses its mark."); 
X			 break;
X		}
X		return(0);
X	}
X	dig_effort += 10 + abon() + uwep->spe - uwep->oeroded + rn2(5);
X	if(dig_down) {
X		register struct trap *ttmp;
X
X		if(dig_effort > 250) {
X			dighole();
X			dig_level.dnum = 0;
X			dig_level.dlevel = -1;
X			return(0);	/* done with digging */
X		}
X
X		if (dig_effort <= 50)
X			return(1);
X
X		if ((ttmp = t_at(dpx,dpy)) &&
X		    ((ttmp->ttyp == PIT) || (ttmp->ttyp == SPIKED_PIT) ||
X		     (ttmp->ttyp == TRAPDOOR)))
X			return(1);
X
X		if (IS_ALTAR(lev->typ)) {
X			altar_wrath(dpx, dpy);
X			angry_priest();
X		}
X
X		ttmp = maketrap(dpx,dpy,PIT);
X		ttmp->tseen = 1;
X		if(Invisible) newsym(ttmp->tx,ttmp->ty);
X		You("have dug a pit.");
X		u.utrap = rn1(4,2);
X		u.utraptype = TT_PIT;
X		vision_full_recalc = 1;	/* vision limits change */
X		dig_level.dnum = 0;
X		dig_level.dlevel = -1;
X		return(0);
X	} 
X	if(dig_effort > 100) {
X		register const char *digtxt, *dmgtxt = (const char*) 0;
X		register struct obj *obj;
X		register boolean shopedge = *in_rooms(dpx, dpy, SHOPBASE);
X
X		if(obj = sobj_at(STATUE, dpx, dpy)) {
X			if (break_statue(obj))
X				digtxt = "The statue shatters.";
X			else
X				/* it was a statue trap; break_statue()
X				 * printed a message and updated the screen
X				 */
X				digtxt = NULL;
X		} else if(obj = sobj_at(BOULDER, dpx, dpy)) {
X			fracture_rock(obj);
X			digtxt = "The boulder falls apart.";
X		} else if(!lev->typ || lev->typ == SCORR) {
X		        if(Is_earthlevel(&u.uz)) {
X			    if(uwep->blessed && !rn2(3)) {
X			        mkcavearea(FALSE);
X				goto cleanup;
X			    } else if((uwep->cursed && !rn2(4)) || 
X				          (!uwep->blessed && !rn2(6))) {
X			        mkcavearea(TRUE);
X			        goto cleanup;
X			    }
X			}
X			lev->typ = CORR;
X			digtxt = "You succeeded in cutting away some rock.";
X		} else if(IS_WALL(lev->typ)) {
X			if(shopedge) {
X		    	    add_damage(dpx, dpy, 10L * ACURRSTR);
X			    dmgtxt = "dig into";
X			}
X		        if (level.flags.is_maze_lev) {
X			    lev->typ = ROOM;
X		        } else if (level.flags.is_cavernous_lev) {
X			    lev->typ = CORR;
X			} else {
X			    lev->typ = DOOR;
X			    lev->doormask = D_NODOOR;
X			}
X			digtxt = "You just made an opening in the wall.";
X		} else if(lev->typ == SDOOR) {
X			lev->typ = DOOR;
X			digtxt = "You just broke through a secret door.";
X			if(!(lev->doormask & D_TRAPPED))
X				lev->doormask = D_BROKEN;
X		} else if(closed_door(dpx, dpy)) {
X			digtxt = "You just broke a hole through the door.";
X			if(shopedge) {
X		    	    add_damage(dpx, dpy, 400L);
X			    dmgtxt = "break";
X			}
X			if(!(lev->doormask & D_TRAPPED))
X				lev->doormask = D_BROKEN;
X		} else return(0); /* statue or boulder got taken */
X
X		unblock_point(dpx,dpy);	/* vision:  can see through */
X		if(Blind)
X		    feel_location(dpx, dpy);
X		else
X		    newsym(dpx, dpy);
X		if(digtxt) pline(digtxt);	/* after newsym */
X		if(dmgtxt)
X		    pay_for_damage(dmgtxt);
X
X		if(Is_earthlevel(&u.uz) && !rn2(3)) {
X		    register struct monst *mtmp;
X
X		    switch(rn2(2)) {
X		      case 0: 
X		        mtmp = makemon(&mons[PM_EARTH_ELEMENTAL], dpx, dpy);
X			break;
X		      default: 
X			mtmp = makemon(&mons[PM_XORN], dpx, dpy); 
X			break;
X		    }
X		    if(mtmp) pline("The debris of your dig comes alive!");
X		}
X		if(IS_DOOR(lev->typ) && (lev->doormask & D_TRAPPED)) {
X			b_trapped("door");
X			lev->doormask = D_NODOOR;
X			newsym(dpx, dpy);
X		}
Xcleanup:
X		dig_level.dnum = 0;
X		dig_level.dlevel = -1;
X		return(0);
X	} else {
X		if(IS_WALL(lev->typ) || closed_door(dpx, dpy)) {
X		    if(*in_rooms(dpx, dpy, SHOPBASE)) {
X			pline("This %s seems too hard to dig into.",
X			      IS_DOOR(lev->typ) ? "door" : "wall");
X			return(0);
X		    }
X		} else if (!IS_ROCK(lev->typ) && !sobj_at(STATUE, dpx, dpy)
X				&& !sobj_at(BOULDER, dpx, dpy))
X			return(0); /* statue or boulder got taken */
X		if(!did_dig_msg) {
X		    You("hit the %s with all your might.",
X			sobj_at(STATUE, dpx, dpy) ? "statue" :
X			sobj_at(BOULDER, dpx, dpy) ? "boulder" :
X			IS_DOOR(lev->typ) ? "door" : "rock");
X		    did_dig_msg = TRUE;
X		}
X	}
X	return(1);
X}
X
X/* When will hole be finished? Very rough indication used by shopkeeper. */
Xint
Xholetime() {
X	if(occupation != dig || !*u.ushops) return(-1);
X	return((250 - dig_effort)/20);
X}
X
X/* Return typ of liquid to fill a hole with, or ROOM, if no liquid nearby */
XSTATIC_OVL
Xschar
Xfillholetyp(x,y)
Xint x, y;
X{
X    register int x1, y1;
X
X    for(x1 = max(1,x-1); x1<=min(x+1,COLNO-1); x1++)
X	for(y1 = max(0,y-1); y1<=min(y+1,ROWNO-1); y1++)
X	    if(levl[x1][y1].typ == MOAT || levl[x1][y1].typ == LAVAPOOL)
X		return levl[x1][y1].typ;
X
X    return ROOM;
X}
X
Xvoid
Xdighole()
X{
X	register struct trap *ttmp = t_at(u.ux, u.uy);
X	struct rm *lev = &levl[u.ux][u.uy];
X	struct obj *boulder_here;
X	boolean nohole = !Can_dig_down(&u.uz);
X
X	if(ttmp && nohole) {
X		pline("The floor here seems too hard to dig in.");
X	} else {
X		d_level	newlevel;
X
X		if (is_pool(u.ux, u.uy) || is_lava(u.ux, u.uy)) {
X		    pline(
X		       "The %s sloshes furiously for a moment, then subsides.",
X			  is_lava(u.ux, u.uy) ? "lava" : "water");
X		    return;
X		}
X		if (lev->typ == DRAWBRIDGE_DOWN) {
X			destroy_drawbridge(u.ux,u.uy);
X			return;
X		} else if (boulder_here = sobj_at(BOULDER, u.ux, u.uy)) {
X			if (ttmp && ((ttmp->ttyp == PIT) || 
X			 	     (ttmp->ttyp == SPIKED_PIT))) {
X				pline("The boulder settles into the pit.");
X				ttmp->ttyp = PIT; 	 /* crush spikes */
X			} else {
X				/*
X				 * digging makes a hole, but the boulder
X				 * immediately fills it.  Final outcome:
X				 * no hole, no boulder.
X				 */
X				pline("KADOOM! The boulder falls in!");
X
X				/* destroy traps that emanate from the floor */
X				/* some of these are arbitrary -dlc */
X				if (ttmp && ((ttmp->ttyp == SQKY_BOARD) ||
X					     (ttmp->ttyp == BEAR_TRAP) ||
X					     (ttmp->ttyp == LANDMINE) ||
X					     (ttmp->ttyp == FIRE_TRAP) ||
X					     (ttmp->ttyp == TRAPDOOR) ||
X					     (ttmp->ttyp == TELEP_TRAP) ||
X					     (ttmp->ttyp == LEVEL_TELEP) ||
X					     (ttmp->ttyp == WEB) ||
X					     (ttmp->ttyp == MAGIC_TRAP) ||
X					     (ttmp->ttyp == ANTI_MAGIC))) {
X					deltrap(ttmp);
X					u.utrap = 0;
X					u.utraptype = 0;
X				}
X			}
X			delobj(boulder_here);
X			return;
X		}
X		if (lev->typ == DRAWBRIDGE_UP) {
X			/* must be floor or ice, other cases handled above */
X			/* dig "pit" and let fluid flow in (if possible) */
X			schar typ = fillholetyp(u.ux,u.uy);
X
X			if(typ == ROOM) {
X			    if(lev->drawbridgemask & DB_ICE)
X				typ = MOAT;
X			    else {
X				/*
X				 * We can't dig a pit here since that will
X				 * destroy the drawbridge.  The following is
X				 * a cop-out. --dlc
X				 */
X				pline("The floor here seems too hard to dig in.");
X				return;
X			    }
X			}
X
X		    	lev->drawbridgemask &= DB_DIR;
X			if(typ == LAVAPOOL) lev->drawbridgemask |= DB_LAVA;
X			newsym(u.ux,u.uy);
X
X			pline("As you dig a pit, it fills with %s!",
X			      typ == LAVAPOOL ? "lava" : "water");
X			if(!Levitation
X#ifdef POLYSELF
X			   && !is_flyer(uasmon)
X#endif
X	    					) {
X			    if (typ == LAVAPOOL)
X				(void) lava_effects();
X			    else if(!Wwalking)
X				(void) drown();
X			}
X			return;
X		} else if (lev->typ == ICE) {
X			/* assume we can remove most of the ice by drilling
X			 * without melting it or allowing neighboring water
X			 * to flow in.
X			 */
X			lev->typ = ROOM;
X		} else if (IS_FOUNTAIN(lev->typ)) {
X			dogushforth(FALSE);
X			dryup(u.ux,u.uy);
X			return;
X#ifdef SINKS
X		} else if (IS_SINK(lev->typ)) {
X			breaksink(u.ux, u.uy);
X			return;
X#endif
X		/* the following two are here for the wand of digging */
X		} else if(IS_THRONE(levl[u.ux][u.uy].typ)) {
X			pline("The throne here is too hard to break apart.");
X			return;
X		} else if(IS_ALTAR(levl[u.ux][u.uy].typ)) {
X			pline("The altar here is too hard to break apart.");
X			return;
X		} else if(ttmp) {
X			ttmp->ttyp = TRAPDOOR;
X		} else if(nohole) {
X			/* can't make a trapdoor, so make a pit */
X			ttmp = maketrap(u.ux, u.uy, PIT);
X		} else
X			ttmp = maketrap(u.ux, u.uy, TRAPDOOR);
X		ttmp->tseen = 1;
X		if(Invisible) newsym(ttmp->tx,ttmp->ty);
X		if(ttmp->ttyp == PIT) {
X		    You("have dug a pit.");
X		    if(!Levitation) {
X			u.utrap = rn1(4,2);
X			u.utraptype = TT_PIT;
X			vision_full_recalc = 1;	/* vision limits change */
X		    } else
X			u.utrap = 0;
X		    return;
X		} 
X		pline("You've made a hole in the floor.");
X
X		/* floor objects get a chance of falling down.
X		 * the case where the hero does NOT fall down
X		 * is treated here.  the case where the hero
X		 * does fall down is treated in goto_level().
X		 */
X		if(OBJ_AT(u.ux, u.uy) && (u.ustuck || Levitation 
X#ifdef WALKIES
X			                     || !next_to_u()
X#endif
X					  ))
X		    impact_drop((struct obj *)0, u.ux, u.uy, 0);
X
X		if (*u.ushops)
X		    add_damage(u.ux, u.uy, 0L);
X		if(!u.ustuck && !Levitation) {			/* KAA */
X			if(*u.ushops)
X				shopdig(1);
X#ifdef WALKIES
X			if(!next_to_u())
X			    You("are jerked back by your pet!");
X			else
X#endif
X			{
X			    You("fall through...");
X
X			    /* the checks above must ensure that   */
X			    /* the destination level exists and is */
X			    /* in the present dungeon.		   */
X
X			    newlevel.dnum = u.uz.dnum;
X			    newlevel.dlevel = u.uz.dlevel + 1;
X			    goto_level(&newlevel, FALSE, TRUE, FALSE);
X			}
X		}
X	}
X}
X
Xstatic boolean
Xwield_tool(obj)
Xstruct obj *obj;
X{
X	if(welded(uwep)) {
X		/* Andreas Bormann - ihnp4!decvax!mcvax!unido!ab */
X		if(flags.verbose) {
X			pline("Since your weapon is welded to your %s,",
X				bimanual(uwep) ?
X				(const char *)makeplural(body_part(HAND))
X				: body_part(HAND));
X			pline("you cannot wield that %s.", xname(obj));
X		}
X		return(FALSE);
X	}
X# ifdef POLYSELF
X	if(cantwield(uasmon)) {
X		You("can't hold it strongly enough.");
X		return(FALSE);
X	}
X# endif
X	unweapon = TRUE;
X	You("now wield %s.", doname(obj));
X	setuwep(obj);
X	if (uwep != obj) return(FALSE); /* rewielded old object after dying */
X	return(TRUE);
X}
X
Xstatic int
Xuse_pick_axe(obj)
Xstruct obj *obj;
X{
X	char dirsyms[12];
X	char qbuf[QBUFSZ];
X	register char *dsp = dirsyms;
X	register const char *sdp = flags.num_pad ? ndir : sdir;
X	register struct rm *lev;
X	register int rx, ry, res = 0;
X	register boolean isclosedoor;
X
X	if(obj != uwep)
X	    if (!wield_tool(obj)) return(0);
X	    else res = 1;
X
X	while(*sdp) {
X		(void) movecmd(*sdp);	/* sets u.dx and u.dy and u.dz */
X		rx = u.ux + u.dx;
X		ry = u.uy + u.dy;
X		if(u.dz > 0 || (u.dz == 0 && isok(rx, ry) &&
X		    (IS_ROCK(levl[rx][ry].typ)
X		    || sobj_at(STATUE, rx, ry)
X		    || sobj_at(BOULDER, rx, ry))))
X			*dsp++ = *sdp;
X		sdp++;
X	}
X	*dsp = 0;
X	Sprintf(qbuf, "In what direction do you want to dig? [%s]", dirsyms);
X	if(!getdir(qbuf))
X		return(res);
X	if(u.uswallow && attack(u.ustuck)) /* return(1) */;
X	else if(Underwater) {
X		pline("Turbulence torpedoes your digging attempts.");
X	} else if(u.dz < 0) {
X		if(Levitation)
X			You("don't have enough leverage.");
X		else
X			You("cannot reach the ceiling.");
X	} else if(!u.dx && !u.dy && !u.dz) {
X		char buf[BUFSZ];
X		int dam;
X
X		dam = rnd(2) + dbon() + obj->spe;
X		if (dam <= 0) dam = 1;
X		You("hit yourself with your own pick-axe.");
X		/* self_pronoun() won't work twice in a sentence */
X		Strcpy(buf, self_pronoun("killed %sself with %%s own pick-axe",
X			"him"));
X		losehp(dam, self_pronoun(buf, "his"), NO_KILLER_PREFIX);
X		flags.botl=1;
X		return(1);
X	} else if(u.dz == 0) {
X		if(Stunned || (Confusion && !rn2(5))) confdir();
X		rx = u.ux + u.dx;
X		ry = u.uy + u.dy;
X		if(!isok(rx, ry)) {
X			pline("Clash!");
X			return(1);
X		}
X		lev = &levl[rx][ry];
X		if(MON_AT(rx, ry) && attack(m_at(rx, ry)))
X			return(1);
X		isclosedoor = closed_door(rx, ry);
X		if(!IS_ROCK(lev->typ)
X		     && !isclosedoor
X		     && !sobj_at(STATUE, rx, ry)
X		     && !sobj_at(BOULDER, rx, ry)) {
X			/* ACCESSIBLE or POOL */
X			You("swing your %s through thin air.",
X				aobjnam(obj, NULL));
X		} else {
X			if(dig_pos.x != rx || dig_pos.y != ry
X			    || !on_level(&dig_level, &u.uz) || dig_down) {
X				dig_down = FALSE;
X				dig_pos.x = rx;
X				dig_pos.y = ry;
X				assign_level(&dig_level, &u.uz);
X				dig_effort = 0;
X			    	You("start %s.",
X				   sobj_at(STATUE, rx, ry) ?
X						"chipping the statue" :
X				   sobj_at(BOULDER, rx, ry) ?
X						"hitting the boulder" :
X				   isclosedoor ? "chopping at the door" :
X						"digging");
X			} else
X				You("continue %s.",
X				   sobj_at(STATUE, rx, ry) ?
X						"chipping the statue" :
X				   sobj_at(BOULDER, rx, ry) ?
X						"hitting the boulder" :
X				   isclosedoor ? "chopping at the door" :
X						"digging");
X			did_dig_msg = FALSE;
X			set_occupation(dig, "digging", 0);
X		}
X	} else if (Is_airlevel(&u.uz) || Is_waterlevel(&u.uz)) {
X		/* it must be air -- water checked above */
X		You("swing your %s through thin air.", aobjnam(obj, NULL));
X	} else if(Levitation) {
X		You("cannot reach the floor.");
X	} else if (is_pool(u.ux, u.uy)) {
X		/* Monsters which swim also happen not to be able to dig */
X		You("cannot stay underwater long enough.");
X	} else {
X		if(dig_pos.x != u.ux || dig_pos.y != u.uy
X		    || !on_level(&dig_level, &u.uz) || !dig_down) {
X			dig_down = TRUE;
X			dig_pos.x = u.ux;
X			dig_pos.y = u.uy;
X			assign_level(&dig_level, &u.uz);
X			dig_effort = 0;
X			You("start digging in the floor.");
X			if(*u.ushops)
X				shopdig(0);
X		} else
X			You("continue digging in the floor.");
X		did_dig_msg = FALSE;
X		set_occupation(dig, "digging", 0);
X	}
X	return(1);
X}
X
X#define WEAK	3	/* from eat.c */
X
Xstatic char look_str[] = "look %s.";
X
Xstatic int
Xuse_mirror(obj)
Xstruct obj *obj;
X{
X	register struct monst *mtmp;
X	register char mlet;
X	boolean vis;
X
X	if(!getdir(NULL)) return 0;
X	if(obj->cursed && !rn2(2)) {
X		if (!Blind)
X			pline("The mirror fogs up and doesn't reflect!");
X		return 1;
X	}
X	if(!u.dx && !u.dy && !u.dz) {
X		if(!Blind && !Invisible) {
X#ifdef POLYSELF
X		    if(u.umonnum == PM_FLOATING_EYE) {
X			pline(Hallucination ?
X			      "Yow!  The mirror stared back at you!" :
X			      "Yikes!  You've frozen yourself!");
X			nomul(-rnd((MAXULEV+6) - (int)u.ulevel));
X		    } else if (u.usym == S_VAMPIRE)
X			You("don't seem to reflect anything.");
X		    else if(u.umonnum == PM_UMBER_HULK) {
X			pline("Huh?  That doesn't look like you!");
X			make_confused(HConfusion + d(3,4),FALSE);
X		    } else
X#endif
X			   if (Hallucination) You(look_str, hcolor());
X		    else if (Sick)
X			You(look_str, "peaked");
X		    else if (u.uhs >= WEAK)
X			You(look_str, "undernourished");
X		    else You("look as %s as ever.",
X				ACURR(A_CHA) > 14 ?
X				(poly_gender()==1 ? "beautiful" : "handsome") :
X				"ugly");
X		} else {
X			You("can't see your %s %s.",
X				ACURR(A_CHA) > 14 ?
X				(poly_gender()==1 ? "beautiful" : "handsome") :
X				"ugly",
X				body_part(FACE));
X		}
X		return 1;
X	}
X	if(u.uswallow) {
X		if (!Blind) You("reflect %s's %s.", mon_nam(u.ustuck),
X		    is_animal(u.ustuck->data)? "stomach" : "interior");
X		return 1;
X	}
X	if(Underwater) {
X		You("offer the fish a chance to do some makeup.");
X		return 1;
X	}
X	if(u.dz) {
X		if (!Blind)
X		    You("reflect the %s.", (u.dz > 0) ? "floor" : "ceiling");
X		return 1;
X	}
X	if(!(mtmp = bhit(u.dx,u.dy,COLNO,INVIS_BEAM,
X					(int(*)())0,(int(*)())0,obj)) ||
X	   !haseyes(mtmp->data))
X		return 1;
X
X	vis = canseemon(mtmp);
X	mlet = mtmp->data->mlet;
X	if(mtmp->msleep) {
X		if (vis)
X		    pline ("%s is tired and doesn't look at your mirror.",
X			    Monnam(mtmp));
X	} else if (!mtmp->mcansee) {
X	    if (vis)
X		pline("%s can't see anything at the moment.", Monnam(mtmp));
X	/* some monsters do special things */
X	} else if (mlet == S_VAMPIRE || mlet == S_GHOST) {
X	    if (vis)
X		pline ("%s doesn't seem to reflect anything.", Monnam(mtmp));
X	} else if(!mtmp->mcan && mtmp->data == &mons[PM_MEDUSA]) {
X		if (vis)
X			pline("%s is turned to stone!", Monnam(mtmp));
X		stoned = TRUE;
X		killed(mtmp);
X	} else if(!mtmp->mcan && !mtmp->minvis &&
X					mtmp->data == &mons[PM_FLOATING_EYE]) {
X		int tmp = d((int)mtmp->m_lev, (int)mtmp->data->mattk[0].damd);
X		if (!rn2(4)) tmp = 120;
X	/* Note: floating eyes cannot use their abilities while invisible,
X	 * but Medusa and umber hulks can.
X	 */
X		if (vis)
X			pline("%s is frozen by its reflection.",Monnam(mtmp));
X		else You("hear something stop moving.");
X		mtmp->mcanmove = 0;
X		if ( (int) mtmp->mfrozen + tmp > 127)
X			mtmp->mfrozen = 127;
X		else mtmp->mfrozen += tmp;
X	} else if(!mtmp->mcan && mtmp->data == &mons[PM_UMBER_HULK]) {
X		if (vis)
X			pline ("%s has confused itself!", Monnam(mtmp));
X	    	mtmp->mconf = 1;
X	} else if(!mtmp->mcan && !mtmp->minvis && (mlet == S_NYMPH
X			             || mtmp->data==&mons[PM_SUCCUBUS])) {
X		if (vis) {
X	    	    pline ("%s looks beautiful in your mirror.",Monnam(mtmp));
X	    	    pline ("She decides to take it!");
X		} else pline ("It steals your mirror!");
X		setnotworn(obj); /* in case mirror was wielded */
X	    	freeinv(obj);
X	    	mpickobj(mtmp,obj);
X	    	rloc(mtmp);
X	} else if (mlet != S_UNICORN && !humanoid(mtmp->data) &&
X			(!mtmp->minvis || perceives(mtmp->data)) && rn2(5)) {
X		if (vis)
X			pline ("%s is frightened by its reflection.",
X				Monnam(mtmp));
X		mtmp->mflee = 1;
X		mtmp->mfleetim += d(2,4);
X	} else if (!Blind) {
X		if (mtmp->minvis && !See_invisible)
X		    ;
X		else if ((mtmp->minvis && !perceives(mtmp->data))
X			 || !haseyes(mtmp->data))
X		    pline("%s doesn't seem to be aware of its reflection.",
X			Monnam(mtmp));
X		else
X		    pline("%s doesn't seem to mind %s reflection.",
X			Monnam(mtmp),
X			humanoid(mtmp->data) ? (mtmp->female ? "her" : "his")
X						: "its");
X	}
X	return 1;
X}
X
Xstatic void
Xuse_bell(obj)
Xregister struct obj *obj;
X{
X	You("ring %s.", the(xname(obj)));
X
X	if(Underwater) {
X	    pline("But it sounds kind of muffled.");
X	    return;
X	}
X        if(obj->otyp == BELL) {
X	    if(u.uswallow) {
X	        pline(nothing_happens);
X		return;
X	    }
X	    if(obj->cursed && !rn2(3)) {
X	        register struct monst *mtmp;
X
X		if(mtmp = makemon(&mons[PM_WOOD_NYMPH], u.ux, u.uy))
X		   You("summon %s!", a_monnam(mtmp));
X	    }
X	    wake_nearby();
X	    return;
X	}
X
X	/* bell of opening */
X	if(u.uswallow && !obj->blessed) {
X	    pline(nothing_happens);
X	    return;
X	}
X        if(obj->cursed) {
X	    coord mm;
X	    mm.x = u.ux;
X	    mm.y = u.uy;
X	    mkundead(&mm);
Xcursed_bell:
X	    wake_nearby();
X	    if(obj->spe > 0) obj->spe--;
X	    return;
X	}
X	if(invocation_pos(u.ux, u.uy) && 
X	             !On_stairs(u.ux, u.uy) && !u.uswallow) {
X	    pline("%s emits an unnerving high-pitched sound...",
X		                                          The(xname(obj)));
X	    obj->age = moves;
X	    if(obj->spe > 0) obj->spe--;
X	    wake_nearby();
X	    obj->known = 1;
X	    return;
X	}
X	if(obj->blessed) {
X	    if(obj->spe > 0) {
X	        register int cnt = openit();
X		if(cnt == -1) return; /* was swallowed */
X		switch(cnt) {
X		  case 0:  pline(nothing_happens); break;
X		  case 1:  pline("Something opens..."); break;
X	          default: pline("Things open around you..."); break;
X	        }
X		if(cnt > 0) obj->known = 1;
X		obj->spe--;
X	    } else pline(nothing_happens);
X	} else {  /* uncursed */
X	    if(obj->spe > 0) {
X	        register int cnt = findit();
X		if(cnt == 0) pline(nothing_happens);
X		else obj->known = 1;
X	        obj->spe--;
X	    } else {
X	        if(!rn2(3)) goto cursed_bell;
X		else pline(nothing_happens);
X	    }
X        }
X}
X
Xstatic void
Xuse_candelabrum(obj)
Xregister struct obj *obj;
X{
X	if(Underwater) {
X		You("can't make fire under water.");
X		return;
X	}
X	if(obj->lamplit) {
X		You("snuff the candle%s out.", obj->spe > 1 ? "s" : "");
X		obj->lamplit = 0;
X		check_lamps();
X		return;
X	}
X	if(obj->spe <= 0) {
X		pline("This %s has no candles.", xname(obj));
X		return;
X	}
X	if(u.uswallow || obj->cursed) {
X		pline("The candle%s flicker%s on for a moment, then die%s.", 
X			obj->spe > 1 ? "s" : "",
X			obj->spe > 1 ? "" : "s",
X			obj->spe > 1 ? "" : "s");
X	        return;
X	} 
X        if(obj->spe < 7) {
X	        pline("There %s only %d candle%s in %s.",
X		       obj->spe == 1 ? "is" : "are", 
X		       obj->spe,
X		       obj->spe > 1 ? "s" : "",
X		       the(xname(obj)));
X		pline("%s lit.  %s emits a dim light.",
X		       obj->spe == 1 ? "It is" : "They are", The(xname(obj)));
X	} else {
X		pline("%s's candles burn%s", The(xname(obj)),
X			(Blind ? "." : " brightly!"));
X	}
X	if (!invocation_pos(u.ux, u.uy)) {
X		pline("The candle%s being rapidly consumed!",
X			(obj->spe > 1 ? "s are" : " is"));
X		obj->age /= 2;
X	} else {
X	        if(obj->spe == 7)
X	            pline("%s glows with a strange light!", The(xname(obj)));
X		obj->known = 1;
X	}
X	obj->lamplit = 1;
X	check_lamps();
X}
X
Xstatic void
Xuse_candle(obj)
Xregister struct obj *obj;
X{
X
X	register struct obj *otmp;
X	char qbuf[QBUFSZ];
X
X	if(obj->lamplit) {
X	        use_lamp(obj);
X		return;
X	}
X
X	if(u.uswallow) {
X	        You("don't have enough elbow-room to maneuver.");
X		return;
X	}
X	if(Underwater) {
X		pline("Sorry, fire and water don't mix.");
X		return;
X	}
X
X	for(otmp = invent; otmp; otmp = otmp->nobj) {
X		if(otmp->otyp == CANDELABRUM_OF_INVOCATION && otmp->spe < 7)
X			break;
X	}
X	if(!otmp || otmp->spe == 7) {
X		use_lamp(obj);
X		return;
X	}
X
X	Sprintf(qbuf, "Attach %s", the(xname(obj)));
X	Sprintf(eos(qbuf), " to %s?", the(xname(otmp)));
X	if(yn(qbuf) == 'n') {
X		You("try to light %s...", the(xname(obj)));
X		use_lamp(obj);
X		return;
X	} else {
X		register long needed = 7L - (long)otmp->spe;
X
X		You("attach %ld%s candle%s to %s.", 
X			obj->quan >= needed ? needed : obj->quan,
X			!otmp->spe ? "" : " more",
X			(needed > 1L && obj->quan > 1L) ? "s" : "",
X			the(xname(otmp)));
X		if(otmp->lamplit) 
X			pline("The new candle%s magically ignite%s!",
X			    (needed > 1L && obj->quan > 1L) ? "s" : "",
X			    (needed > 1L && obj->quan > 1L) ? "" : "s");
X		if(obj->unpaid) 
X			You("use %s, you bought %s!",
X			    (needed > 1L && obj->quan > 1L) ? "them" : "it",
X			    (needed > 1L && obj->quan > 1L) ? "them" : "it");
X		if(!otmp->spe || otmp->age > obj->age)
X			otmp->age = obj->age;
X		if(obj->quan > needed) {
X		    if(obj->unpaid) {
X			/* this is a hack, until we re-write the billing */
X			/* code to accommodate such cases directly. IM*/
X			register long delta = obj->quan - needed;
X
X			subfrombill(obj, shop_keeper(*u.ushops));
X			obj->quan = needed;
X			addtobill(obj, TRUE, FALSE, TRUE);
X			bill_dummy_object(obj);
X			obj->quan = delta;
X			addtobill(obj, TRUE, FALSE, TRUE);
X		     } else {
X			obj->quan -= needed;
X		     }
X		     otmp->spe += (int)needed;
X		} else {
X		    otmp->spe += (int)obj->quan;
X		    freeinv(obj);
X		    obfree(obj, (struct obj *)0);
X		}
X		if(needed < 7L && otmp->spe == 7)
X		    pline("%s has now seven%s candles attached.",
X			The(xname(otmp)), otmp->lamplit ? " lit" : "");
X	}
X}
X
Xboolean
Xsnuff_candle(otmp)  /* call in drop, throw, and put in box, etc. */
Xregister struct obj *otmp;
X{
X	register boolean candle = Is_candle(otmp);
X
X	if ((candle || otmp->otyp == CANDELABRUM_OF_INVOCATION) &&
X		otmp->lamplit) {
X	    register boolean many = candle ? otmp->quan > 1L : otmp->spe > 1;
X	    pline("The %scandle%s flame%s extinguished.",
X		  (candle ? "" : "candelabrum's "),
X		  (many ? "s'" : "'s"), (many ? "s are" : " is"));
X	   otmp->lamplit = 0;
X	   check_lamps();
X	   return(TRUE);
X	}
X	return(FALSE);
X}
X
Xboolean
Xsnuff_lit(obj)
Xstruct obj *obj;
X{
X	if(obj->lamplit) {
X		if(obj->otyp == OIL_LAMP || obj->otyp == MAGIC_LAMP ||
X				obj->otyp == BRASS_LANTERN) {
X			Your("lamp is now off.");
X			obj->lamplit = 0;
X			check_lamps();
X			return(TRUE);
X		} 
X
X		if(snuff_candle(obj)) return(TRUE);
X	}
X
X	return(FALSE);
X}
X
Xstatic void
Xuse_lamp(obj)
Xstruct obj *obj;
X{
X	if(Underwater) {
X		pline("This is not a diving lamp.");
X		return;
X	}
X	if(obj->lamplit) {
X		if(obj->otyp == OIL_LAMP || obj->otyp == MAGIC_LAMP ||
X				obj->otyp == BRASS_LANTERN)
X		    Your("lamp is now off.");
X		else
X		    You("snuff out %s.", the(xname(obj)));
X		obj->lamplit = 0;
X		check_lamps();
X		return;
X	}
X	if (!Is_candle(obj) && obj->spe <= 0) {
X		if (obj->otyp == BRASS_LANTERN)
X			Your("lamp has run out of power.");
X		else pline("This %s has no oil.", xname(obj));
X		return;
X	}
X	if(obj->cursed && !rn2(2))
X		pline("%s flicker%s on for a moment, then die%s.", 
X		       The(xname(obj)),
X		       obj->quan > 1L ? "" : "s",
X		       obj->quan > 1L ? "" : "s");
X	else {
X		if(obj->otyp == OIL_LAMP || obj->otyp == MAGIC_LAMP ||
X				obj->otyp == BRASS_LANTERN)
X		    Your("lamp is now on.");
X		else
X		    pline("%s%s flame%s burn%s%s", The(xname(obj)),
X		        obj->quan > 1L ? "'" : "'s",
X		        obj->quan > 1L ? "s" : "",
X		        obj->quan > 1L ? "" : "s",
X			Blind ? "." : " brightly!");
X		obj->lamplit = 1;
X		check_lamps();
X		if (obj->unpaid && Is_candle(obj) &&
X			obj->age == 20L * (long)objects[obj->otyp].oc_cost) {
X		    const char *it_them = obj->quan > 1L ? "them" : "it";
X		    You("use %s, you've bought %s!", it_them, it_them);
X		    bill_dummy_object(obj);
X		}
X	}
X}
X
Xvoid
Xcheck_lamps()
X{
X	register struct obj *obj;
X	int lamps = 0;
X
X	for(obj = invent; obj; obj = obj->nobj)
X		if (obj->lamplit) {
X			lamps++;
X			break;
X		}
X
X	if (lamps && u.nv_range == 1) {
X		u.nv_range = 3;
X		vision_full_recalc = 1;
X	} else if (!lamps && u.nv_range == 3) {
X		u.nv_range = 1;
X		vision_full_recalc = 1;
X	}
X}
X
Xstatic const char NEARDATA cuddly[] = { TOOL_CLASS, 0 };
X
Xint
Xdorub()
X{
X	struct obj *obj = getobj(cuddly, "rub");
X
X	if(!obj || (obj != uwep && !wield_tool(obj))) return 0;
X
X	/* now uwep is obj */
X	if (uwep->otyp == MAGIC_LAMP) {
X	    if (uwep->spe > 0 && !rn2(3)) {
X		djinni_from_bottle(uwep);
X		makeknown(MAGIC_LAMP);
X		uwep->otyp = OIL_LAMP;
X		uwep->spe = 1; /* for safety */
X		uwep->age = rn1(500,1000);
X	    } else if (rn2(2) && !Blind)
X		You("see a puff of smoke.");
X	    else pline(nothing_happens);
X	} else if (obj->otyp == BRASS_LANTERN) {
X	    /* message from Adventure */
X	    pline("Rubbing the electric lamp is not particularly rewarding.");
X	    pline("Anyway, nothing exciting happens.");
X	} else pline(nothing_happens);
X	return 1;
X}
X
Xint
Xdojump()
X{
X	coord cc;
X	register struct monst *mtmp;
X	if (!Jumping || Levitation) {
X		You("can't jump very far.");
X		return 0;
X	} else if (u.uswallow) {
X		pline("You've got to be kidding!");
X		return 0;
X	} else if (u.uinwater) {
X		pline("This calls for swimming, not jumping!");
X		return 0;
X	} else if (u.ustuck) {
X		You("cannot escape from %s!", mon_nam(u.ustuck));
X		return 0;
X	} else if (near_capacity() > UNENCUMBERED) {
X		You("are carrying too much to jump!");
X		return 0;
X	} else if (u.uhunger <= 100 || ACURR(A_STR) < 6) {
X		You("lack the strength to jump!");
X		return 0;
X	}
X	pline("Where do you want to jump?");
X	cc.x = u.ux;
X	cc.y = u.uy;
X	getpos(&cc, TRUE, "the desired position");
X        if(cc.x == -10) return 0; /* user pressed esc */
X	if (!(Jumping & ~INTRINSIC) && distu(cc.x, cc.y) != 5) {
X		pline("Illegal move!");
X		return 0;
X	} else if (distu(cc.x, cc.y) > 9) {
X		pline("Too far!");
X		return 0;
X	} else if (!cansee(cc.x, cc.y)) {
X		You("cannot see where to land!");
X		return 0;
X	} else if (mtmp = m_at(cc.x, cc.y)) {
X		You("cannot trample %s!", mon_nam(mtmp));
X		return 0;
X	} else if (!isok(cc.x, cc.y) ||
X#ifdef POLYSELF
X		(IS_ROCK(levl[cc.x][cc.y].typ) && !passes_walls(uasmon)) ||
X#else
X		IS_ROCK(levl[cc.x][cc.y].typ) ||
X#endif
X		sobj_at(BOULDER, cc.x, cc.x) ) {
X			You("cannot jump there!");
X			return 0;
X	} else {
X	    if(u.utrap)
X		switch(u.utraptype) {
X		case TT_BEARTRAP: {
X		    register long side = rn2(3) ? LEFT_SIDE : RIGHT_SIDE;
X		    You("rip yourself out of the bear trap!  Ouch!");
X		    losehp(rnd(10), "jumping out of a bear trap", KILLED_BY);
X		    set_wounded_legs(side, rn1(1000,500));
X		    break;
X		  }
X		case TT_PIT:
X		    You("leap from the pit!");
X		    break;
X		case TT_WEB:
X		    You("tear the web apart as you pull yourself free!");
X		    deltrap(t_at(u.ux,u.uy));
X		    break;
X		case TT_LAVA:
X		    You("pull yourself above the lava!");
X		    u.utrap = 0;
X		    return 1;
X		case TT_INFLOOR:
X		    You("strain your %s, but are still stuck in the floor.",
X			makeplural(body_part(LEG)));
X		    set_wounded_legs(LEFT_SIDE, rn1(10, 11));
X		    set_wounded_legs(RIGHT_SIDE, rn1(10, 11));
X		    return 1;
X		}
X
X	    teleds(cc.x, cc.y);
X	    nomul(-1);
X	    nomovemsg = "";
X	    morehungry(rnd(25));
X	    return 1;
X	}
X}
X
Xstatic void
Xuse_tinning_kit(obj)
Xregister struct obj *obj;
X{
X	register struct obj *corpse, *can;
X
X	/* This takes only 1 move.  If this is to be changed to take many
X	 * moves, we've got to deal with decaying corpses...
X	 */
X	if (!(corpse = floorfood("can", 1))) return;
X	if (corpse->oeaten) {
X		You("cannot tin something which is partly eaten.");
X		return;
X	}
X	if ((corpse->corpsenm == PM_COCKATRICE)
X#ifdef POLYSELF
X		&& !resists_ston(uasmon)
X#endif
X		&& !uarmg) {
Xpline("Tinning a cockatrice corpse without gloves was not a very wise move...");
X#if defined(POLYSELF)
X/* this will have to change if more monsters can poly */
X		if(!(poly_when_stoned(uasmon) && polymon(PM_STONE_GOLEM)))
X#endif
X	    {
X		You("turn to stone...");
X		killer_format = KILLED_BY;
X		killer = "trying to tin a cockatrice without gloves";
X		done(STONING);
X	    }
X	}
X	if (mons[corpse->corpsenm].cnutrit == 0) {
X		You("can't tin something that insubstantial!");
X		return;
X	}
X	if (is_rider(&mons[corpse->corpsenm])) {
X		revive_corpse(corpse, 0, FALSE);
X		verbalize("Yes....  But War does not preserve its enemies...");
X		return;
X	}
X	if(can = mksobj(TIN, FALSE, FALSE)) {
X	    can->corpsenm = corpse->corpsenm;
X	    can->cursed = obj->cursed;
X	    can->blessed = obj->blessed;
X	    can->owt = weight(can);
X	    can->known = 1;
X	    can->spe = -1;  /* Mark tinned tins. No spinach allowed... */
X	    can = hold_another_object(can, "You make, but cannot pick up, %s.",
X				      doname(can), (const char *)0);
X	    if (carried(corpse)) useup(corpse);
X	    else useupf(corpse);
X	} else impossible("Tinning failed.");
X}
X
Xvoid
Xuse_unicorn_horn(obj)
Xstruct obj *obj;
X{
X	boolean blessed = (obj && obj->blessed);
X	boolean did_something = FALSE;
X
X	if (obj && obj->cursed) {
X		switch (rn2(6)) {
X		    static char buf[BUFSZ];
X		    case 0: make_sick(Sick ? 1L : (long) rn1(20, 20), TRUE);
X			    Strcpy(buf, xname(obj));
X			    u.usick_cause = (const char *)buf;
X			    break;
X		    case 1: make_blinded(Blinded + (long) rnd(100), TRUE);
X			    break;
X		    case 2: if (!Confusion)
X				You("suddenly feel %s.",
X					Hallucination ? "trippy" : "confused");
X			    make_confused(HConfusion + (long) rnd(100), TRUE);
X			    break;
X		    case 3: make_stunned(HStun + (long) rnd(100), TRUE);
X			    break;
X		    case 4: (void) adjattrib(rn2(6), -1, FALSE);
X			    break;
X		    case 5: make_hallucinated(HHallucination + (long) rnd(100),
X				TRUE, 0L);
X			    break;
X		}
X		return;
X	}
X		
X	if (Sick) {
X		make_sick(0L, TRUE);
X		did_something++;
X	}
X	if (Blinded > (long)(u.ucreamed+1) && (!did_something || blessed)) {
X		make_blinded(u.ucreamed ? (long)(u.ucreamed+1) : 0L, TRUE);
X		did_something++;
X	}
X	if (Hallucination && (!did_something || blessed)) {
X		make_hallucinated(0L, TRUE, 0L);
X		did_something++;
X	}
X	if (Vomiting && (!did_something || blessed)) {
X		make_vomiting(0L, TRUE);
X		did_something++;
X	}
X	if (HConfusion && (!did_something || blessed)) {
X		make_confused(0L, TRUE);
X		did_something++;
X	}
X	if (HStun && (!did_something || blessed)) {
X		make_stunned(0L, TRUE);
X		did_something++;
X	}
X	if (!did_something || blessed) {
X		register int j;
X		int did_stat = 0;
X		int i = rn2(A_MAX);
X		for(j=0; j<A_MAX; j++) {
X			/* don't recover strength lost while hungry */
X			if ((blessed || j==i) &&
X				((j != A_STR || u.uhs < WEAK)
X				? (ABASE(i) < AMAX(i))
X				: (ABASE(A_STR) < (AMAX(A_STR) - 1)))) {
X				did_something++;
X				/* They may have to use it several times... */
X				if (!did_stat) {
X					did_stat++;
X					pline("This makes you feel good!");
X				}
X				ABASE(i)++;
X				flags.botl = 1;
X			}
X		}
X	}
X	if (!did_something) pline(nothing_happens);
X}
X
Xstatic void
Xuse_figurine(obj)
Xregister struct obj *obj;
X{
X	xchar x, y;
X
X	if(!getdir(NULL)) {
X		flags.move = multi = 0;
X		return;
X	}
X	x = u.ux + u.dx; y = u.uy + u.dy;
X	if (!isok(x,y)) {
X		You("can't seem to put the figurine there.");
X		return;
X	}
X	if (IS_ROCK(levl[x][y].typ) && !passes_walls(&mons[obj->corpsenm])) {
X		You("can't place a figurine in solid rock!");
X		return;
X	}
X	if (sobj_at(BOULDER,x,y) && !passes_walls(&mons[obj->corpsenm])
X			&& !throws_rocks(&mons[obj->corpsenm])) {
X		You("can't fit the figurine on the boulder.");
X		return;
X	}
X	You("%s and it transforms.",
X	    (u.dx||u.dy) ? "set the figurine besides you" :
X	    (Is_airlevel(&u.uz) || Is_waterlevel(&u.uz)) ?
X		"release the figurine" :
X	    (u.dz < 0 ?
X		"toss the figurine into the air" :
X		"set the figurine on the ground"));
X	make_familiar(obj, u.ux+u.dx, u.uy+u.dy);
X	useup(obj);
X}
X
Xstatic void
Xuse_grease(obj)
Xstruct obj *obj;
X{
X	struct obj *otmp;
X
X	if (obj->spe > 0) {
X		char allow_all[2];
X		if (obj->cursed && !rn2(2)) {
X			pline("The %s slips from your fingers!",xname(obj));
X			dropx(obj);
X			obj->spe -= 1;
X			return;
X		}
X		allow_all[0] = ALL_CLASSES; allow_all[1] = '\0';
X		otmp = getobj(allow_all,"grease");
X		if (otmp) {
X			You("cover your %s with a thick layer of grease.",xname(otmp));
X			otmp->greased = 1;
X			obj->spe -= 1;
X		}
X	}
X}
X
Xint
Xdoapply()
X{
X	register struct obj *obj;
X	register int res = 1;
X
X	if(check_capacity(NULL)) return (0);
X	obj = getobj(tools, "use or apply");
X	if(!obj) return 0;
X
X	check_unpaid(obj);
X
X	switch(obj->otyp){
X	case BLINDFOLD:
X		if (obj == ublindf) {
X		    if(cursed(obj)) break;
X		    else Blindf_off(obj);
X		} 
X		else if (!ublindf) Blindf_on(obj);
X		else You("are already %s", ublindf->otyp == TOWEL ?
X			 "covered by a towel." : "wearing a blindfold!");
X		break;
X	case LARGE_BOX:
X	case CHEST:
X	case ICE_BOX:
X	case SACK:
X	case BAG_OF_HOLDING:
X	case OILSKIN_SACK:
X		res = use_container(obj, 1); 
X		break;
X	case BAG_OF_TRICKS:
X		if(obj->spe > 0) {
X			register int cnt = 1;
X
X			obj->spe -= 1;
X			if(!rn2(23)) cnt += rn2(7) + 1;
X			while(cnt--)
X			    (void) makemon((struct permonst *) 0, u.ux, u.uy);
X			makeknown(BAG_OF_TRICKS);
X		} else
X			pline(nothing_happens);
X		break;
X	case CAN_OF_GREASE:
X		use_grease(obj);
X		break;
X	case LOCK_PICK:
X#ifdef TOURIST
X	case CREDIT_CARD:
X#endif
X	case SKELETON_KEY:
X		(void) pick_lock(obj);
X		break;
X	case PICK_AXE:
X		res = use_pick_axe(obj);
X		break;
X	case TINNING_KIT:
X		use_tinning_kit(obj);
X		break;
X#ifdef WALKIES
X	case LEASH:
X		use_leash(obj);
X		break;
X#endif
X	case MAGIC_WHISTLE:
X		use_magic_whistle(obj);
X		break;
X	case TIN_WHISTLE:
X		use_whistle(obj);
X		break;
X	case STETHOSCOPE:
X		res = 0;
X		use_stethoscope(obj);
X		break;
X	case MIRROR:
X		res = use_mirror(obj);
X		break;
X	case BELL:
X	case BELL_OF_OPENING:
X	        use_bell(obj);
X		break;
X	case CANDELABRUM_OF_INVOCATION:
X		use_candelabrum(obj);
X		break;
X	case WAX_CANDLE:
X	case TALLOW_CANDLE:
X		use_candle(obj);
X		break;
X	case OIL_LAMP:
X	case MAGIC_LAMP:
X	case BRASS_LANTERN:
X		use_lamp(obj);
X		break;
X#ifdef TOURIST
X	case EXPENSIVE_CAMERA:
X		res = use_camera(obj); 
X		break;
X#endif
X	case TOWEL:
X		res = use_towel(obj); 
X		break;
X	case CRYSTAL_BALL:
X		use_crystal_ball(obj);
X		break;
X	case MAGIC_MARKER:
X		res = dowrite(obj);
X		break;
X	case TIN_OPENER:
X		if(!carrying(TIN)) {
X			You("have no tin to open.");
X			goto xit;
X		}
X		You("cannot open a tin without eating or discarding its contents.");
X		if(flags.verbose)
X			pline("In order to eat, use the 'e' command.");
X		if(obj != uwep)
X    pline("Opening the tin will be much easier if you wield the tin opener.");
X		goto xit;
X
X	case FIGURINE:
X		use_figurine(obj);
X		break;
X	case UNICORN_HORN:
X		use_unicorn_horn(obj);
X		break;
X	case WOODEN_FLUTE:
X	case MAGIC_FLUTE:
X	case TOOLED_HORN:
X	case FROST_HORN:
X	case FIRE_HORN:
X	case WOODEN_HARP:
X	case MAGIC_HARP:
X	case BUGLE:
X	case LEATHER_DRUM:
X	case DRUM_OF_EARTHQUAKE:
X		res = do_play_instrument(obj);
X		break;
X	case HORN_OF_PLENTY:
X		if (obj->spe > 0) {
X		    struct obj *otmp;
X		    const char *what;
X
X#ifdef MAC
X			char melody [ 3 ] = { 0 , 0 , 0 } ;
X			melody [ 0 ] = rn2 ( 8 ) + 'A' ;
X			melody [ 1 ] = rn2 ( 8 ) + 'A' ;
X			mac_speaker ( obj , & melody ) ;
X#endif
X
X		    obj->spe -= 1;
X		    if (!rn2(13)) {
X			otmp = mkobj(POTION_CLASS, FALSE);
X			if (objects[otmp->otyp].oc_magic) do {
X			    otmp->otyp = rnd_class(POT_BOOZE, POT_WATER);
X			} while (otmp->otyp == POT_SICKNESS);
X			what = "A potion";
X		    } else {
X			otmp = mkobj(FOOD_CLASS, FALSE);
X			if (otmp->otyp == FOOD_RATION && !rn2(7))
X			    otmp->otyp = LUMP_OF_ROYAL_JELLY;
X			what = "Some food";
X		    }
X		    pline("%s spills out.", what);
X		    otmp->blessed = obj->blessed;
X		    otmp->cursed = obj->cursed;
X		    otmp->owt = weight(otmp);
X		    otmp = hold_another_object(otmp, u.uswallow ?
X					       "Oops!  %s away from you!" :
X					       "Oops!  %s to the floor!",
X					       The(aobjnam(otmp, "slip")),
X					       (const char *)0);
X		    makeknown(HORN_OF_PLENTY);
X		} else
X		    pline(nothing_happens);
X		break;
X	default:
X		pline("Sorry, I don't know how to use that.");
X	xit:
X		nomul(0);
X		return 0;
X	}
X	nomul(0);
X	return res;
X}
X
X#endif /* OVLB */
X
X/*apply.c*/
END_OF_FILE
if test 52659 -ne `wc -c <'src/apply.c'`; then
    echo shar: \"'src/apply.c'\" unpacked with wrong size!
fi
# end of 'src/apply.c'
fi
echo shar: End of archive 3 \(of 108\).
cp /dev/null ark3isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \
21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \
41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 \
61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 \
81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 \
101 102 103 104 105 106 107 108 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 108 archives.
    echo "Now execute 'rebuild.sh'"
    rm -f ark10[0-8]isdone ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
