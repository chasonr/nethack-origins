Relay-Version: version B 2.10 5/3/83; site utzoo.UUCP
Posting-Version: version B 2.10.1 6/24/83 (MC840302); site mcvax.UUCP
Path: utzoo!linus!philabs!cmcl2!seismo!mcvax!aeb
From: aeb@mcvax.UUCP (Andries Brouwer)
Newsgroups: net.sources.games
Subject: Hack version 1.0.3
Message-ID: <770@mcvax.UUCP>
Date: Tue, 23-Jul-85 16:24:17 EDT
Article-I.D.: mcvax.770
Posted: Tue Jul 23 16:24:17 1985
Date-Received: Thu, 25-Jul-85 01:07:09 EDT
Reply-To: aeb@mcvax.UUCP (Andries Brouwer)
Organization: CWI, Amsterdam
Lines: 2845

Below follows an edscript converting the pure uncontaminated Hack 1.0.2
sources into the sources for Hack version 1.0.2. Chaos will result if
you apply this script to modified sources! Most of you will have
edited config.h and perhaps Makefile, so the proper thing to do might be
to make a diff describing the changes made by you to these files,
and then applying this diff (either by hand or using patch) to the
newer versions. You might also want to see what the differences are
between the old and new config.h (so that you can define e.g.
NOWAITINCLUDE or PYRAMID_BUG when appropriate).
This version has been satisfactorily used on a 3B2 running System V.
It is somewhat larger than the previous version,
and people with a 256K micro might want to
#ifdef out some of the more wasteful changes. [Mail me your experiences -
I would like to keep a uniform source for as much hardware as possible.]
If your C compiler or loader is stupid enough to look only at the first
7 characters of identifiers then you might want to watch out for
corrode_armor/corrode_weapon, done_in_by/done_intr, lastwarnlev/lastwarntime,
ltchars/ltchars0, monster_nearby/monstersym, standoutbeg/standoutend,
stoned_dialogue/stoned_texts.
If it looks only at 6 chars then you'll need some mechanical identifier
replacer. You are also in trouble if your C preprocessor is shortsighted.
The next time that I post full sources I'll try to do something about
the long identifiers, and also rename the files so that hack.apply.c
becomes apply.c etc. - some filesystems do not accept two dots in a filename.
Other known problems are: not all C compilers know about bit fields,
functions returning structures and switch statements with cases that are
long integers.

Save your previous version of hack until this one has run satisfactorily
for some time. The record files are compatible, the bones & save files
are not. Some people will have to expand tabs to spaces in the data or help
files.

I'll soon be in Denmark, and remain there for 11 months; probably this
means that I won't see netnews for a while, so you'll have to mail me
in case you have problems or suggestions for improvements, and don't
expect an immediate reply.
#---------- cut here -------------------------------------------------------
echo Make sure that you have the original, unmodified 1.0.2 sources here.
echo This ed-script will convert them to Hack version 1.0.3.
echo Editing Makefile ; ed Makefile << '-*-END-*-'
161c
hack.rumors.o:  hack.h
.
94a

.
93a
clean:
	rm -f *.o
.
92a
#	cp hack.6 /usr/man/man6
.
84,85c
# the distribution directory also contains the empty files perm and record.
.
57a
all:	$(GAME) lint
	@echo "Done."

.
38a
DISTR = $(SOURCES) $(AUX) READ_ME Makefile date.h hack.onames.h

.
w
q
-*-END-*-
echo Editing READ_ME ; ed READ_ME << '-*-END-*-'
55c
1. If it didnt exist already, introduce a loginname `play' .
.
w
q
-*-END-*-
echo Editing config.h ; ed config.h << '-*-END-*-'
35a
#define	HLOCK	"perm"	/* an empty file used for locking purposes */
#define LLOCK	"safelock"	/* link to previous */
.
26a
/* #define PYRAMID_BUG */	/* avoid a bug on the Pyramid */
/* #define NOWAITINCLUDE */	/* neither <wait.h> nor <sys/wait.h> exists */
.
2c
/* config.h - version 1.0.3 */
.
w
q
-*-END-*-
echo Editing data ; ed data << '-*-END-*-'
223a
~	the tail of a long worm
.
221,222c
w	a long worm;
.
28a
;	a giant eel
.
14c
%%      a piece of food
.
1c
	Hack & Quest data file - version 1.0.3
.
w
q
-*-END-*-
echo Editing date.h ; ed date.h << '-*-END-*-'
2c
char datestring[] = "Tue Jul 23 1985";
.
w
q
-*-END-*-
echo Editing def.flag.h ; ed def.flag.h << '-*-END-*-'
18a
	unsigned invlet_constant:1;	/* let objects keep their
					   inventory symbol */
.
5a
	unsigned debug:1;	/* in debugging mode */
#define	wizard	flags.debug
.
2c
/* def.flag.h - version 1.0.3 */
.
w
q
-*-END-*-
echo Editing def.mkroom.h ; ed def.mkroom.h << '-*-END-*-'
15c
/* various values of rtype */
.
5c
	schar lx,hx,ly,hy;	/* usually xchar, but hx may be -1 */
.
2c
/* def.mkroom.h - version 1.0.3 */
.
w
q
-*-END-*-
echo Editing def.obj.h ; ed def.obj.h << '-*-END-*-'
16a
	char invlet;
.
2c
/* def.obj.h - version 1.0.3 */
.
w
q
-*-END-*-
echo Editing def.objclass.h ; ed def.objclass.h << '-*-END-*-'
19c
#define	a_ac		oc_oc1	/* for armors - only used in ARM_BONUS */
#define ARM_BONUS(obj)	((10 - objects[obj->otyp].a_ac) + obj->spe)
.
2c
/* def.objclass.h - version 1.0.3 */
.
w
q
-*-END-*-
echo Editing def.objects.h ; ed def.objects.h << '-*-END-*-'
186d
184d
4c
/* objects have letter " % ) ( 0 _ ` [ ! ? / = * */
.
2c
/* def.objects.h - version 1.0.3 */
.
w
q
-*-END-*-
echo Editing hack.Decl.c ; ed hack.Decl.c << '-*-END-*-'
9,12c
boolean in_mklev, restoring;
.
7c
char lock[PL_NSIZ+4] = "1lock";	/* long enough for login name .99 */
.
2c
/* hack.Decl.c - version 1.0.3 */
.
w
q
-*-END-*-
echo Editing hack.apply.c ; ed hack.apply.c << '-*-END-*-'
396a
			if(inshop())
				shopdig(0);
.
328a
		if(uwep && uwep->cursed) {
			/* Andreas Bormann - ihnp4!decvax!mcvax!unido!ab */
			pline("Since your weapon is welded to your hand,");
			pline("you cannot use that pick-axe.");
			return(0);
		}
.
306a
			if(inshop())
				shopdig(1);
.
292a
/* When will hole be finished? Very rough indication used by shopkeeper. */
holetime() {
	return( (occupation == dig) ? (250 - dig_effort)/20 : -1);
}

.
72,73c
			if(cansee(mtmp->mx,mtmp->my))
			  pline("%s is blinded by the flash!", Monnam(mtmp));
.
38a
	xit:
.
36c
		use_whistle(obj);
		break;

	case CAN_OPENER:
		if(!carrying(TIN)) {
			pline("You have no can to open.");
			goto xit;
		}
		pline("You cannot open a tin without eating its contents.");
		pline("In order to eat, use the 'e' command.");
		if(obj != uwep)
    pline("Opening the tin will be much easier if you wield the can-opener.");
		goto xit;

.
28c
		res = use_pick_axe(obj);
		break;

.
2c
/* hack.apply.c - version 1.0.3 */
.
w
q
-*-END-*-
echo Editing hack.bones.c ; ed hack.bones.c << '-*-END-*-'
80,81c
#ifdef WIZARD
	if(!wizard)	/* duvel!frans: don't remove bones while debugging */
#endif WiZARD
	    if(unlink(bones) < 0){
		pline("Cannot unlink %s .", bones);
.
62a
		otmp->known = 0;
		otmp->invlet = 0;
		if(otmp->olet == AMULET_SYM && !otmp->spe) {
			otmp->spe = -1;      /* no longer the actual amulet */
			otmp->cursed = 1;    /* flag as gotten from a ghost */
		}
	}
.
61c
	for(otmp = fobj; otmp; otmp = otmp->nobj) {
		otmp->o_id = 0;
	     /* otmp->o_cnt_id = 0; - superfluous */
.
51a
		mtmp->m_id = 0;
.
35,36d
31d
18c
	if(dlevel <= 0 || dlevel > MAXLEVEL) return;
.
2c
/* hack.bones.c - version 1.0.3 */
.
w
q
-*-END-*-
echo Editing hack.c ; ed hack.c << '-*-END-*-'
792a
}

long
newuexp()
{
	return(10*(1L << (u.ulevel-1)));
.
774,777c
register int carrcap;
	if(Levitation)			/* pugh@cornell */
		carrcap = MAX_CARR_CAP;
	else {
		carrcap = 5*(((u.ustr > 18) ? 20 : u.ustr) + u.ulevel);
		if(carrcap > MAX_CARR_CAP) carrcap = MAX_CARR_CAP;
		if(Wounded_legs & LEFT_SIDE) carrcap -= 10;
		if(Wounded_legs & RIGHT_SIDE) carrcap -= 10;
	}
.
767c
	u.uexp = newuexp();
.
758a
	extern long newuexp();
.
632,637d
571a
			!mtmp->mfroz && !mtmp->msleep &&  /* aplvax!jcn */
.
519c
			if(x == u.ux+u.dx && y == u.uy+u.dy) goto stop;
.
450c
		if(Invisible) newsym(u.ux,u.uy);
.
403,406d
371a
		/* do not pick up uchain */
		if(Punished && obj == uchain)
			continue;

.
360c
			if(obj->ox == u.ux && obj->oy == u.uy)
				if(!Punished || obj != uchain)
					ct++;
.
352c
		if(Invisible) newsym(u.ux,u.uy);
.
260,266c
	if(tmpr->typ == POOL && !Levitation)
		drown();	/* not necessarily fatal */

.
195c
			if(Invisible) newsym(u.ux+u.dx, u.uy+u.dy);
.
86,87c
	u_wipe_engr(rnd(5));

.
2c
/* hack.c - version 1.0.3 */
.
w
q
-*-END-*-
echo Editing hack.cmd.c ; ed hack.cmd.c << '-*-END-*-'
180c
	  pline("Unknown command '%s'.", expcmd);
.
160c
			res = (*(tlist->f_funct))();
.
85a
	"pray", dopray,
.
12c
doup(), dodown(), done1(), donull(), dothrow(), doextcmd(), dodip(), dopray();
.
2c
/* hack.cmd.c - version 1.0.3 */
.
w
q
-*-END-*-
echo Editing hack.do.c ; ed hack.do.c << '-*-END-*-'
451a
}

set_wounded_legs(side, timex)
register long side;
register int timex;
{
	if(!Wounded_legs || (Wounded_legs & TIMEOUT))
		Wounded_legs |= side + timex;
	else
		Wounded_legs |= side;
}

heal_legs()
{
	if(Wounded_legs) {
		if((Wounded_legs & BOTH_SIDES) == BOTH_SIDES)
			pline("Your legs feel somewhat better.");
		else
			pline("Your leg feels somewhat better.");
		Wounded_legs = 0;
	}
.
407c
			    set_wounded_legs(side, 500+rn2(1000));
.
374a
			    if(u.uluck > LUCKMAX)	/* dan@ut-ngp */
				u.uluck = LUCKMAX;
.
257c
			pline("Your weapon is welded to your hand.");
.
254a

	u_wipe_engr(2);

.
252c
		pline("You can't throw something you are wearing.");
.
239a
dopray() {
	nomovemsg = "You finished your prayer.";
	nomul(-3);
	return(1);
}

.
194c
				pline("... and are hit by the iron ball.");
.
190c
			pline("You fall down the stairs.");	/* %% */
.
182,183c
		if(Punished && !Levitation){
			pline("With great effort you climb the stairs.");
.
166c
			pline("Cannot open %s .", lock);
.
123a
	if(newlevel > MAXLEVEL) newlevel = MAXLEVEL;	/* strange ... */
.
107c
	if(!Levitation && inv_weight() + 5 > 0) {
.
68c
	if(Invisible) newsym(u.ux,u.uy);
.
30c
			if(Invisible) newsym(u.ux, u.uy);
.
12a
extern char *nomovemsg;
.
2c
/* hack.do.c - version 1.0.3 */
.
w
q
-*-END-*-
echo Editing hack.do_name.c ; ed hack.do_name.c << '-*-END-*-'
181,182c
	"adri", "andries", "andreas", "bert", "david", "dirk", "emile",
	"frans", "fred", "greg", "hether", "jay", "john", "jon", "kay",
	"kenny", "maud", "michiel", "mike", "peter", "robert", "ron",
.
31c
			pline("Unknown direction: '%s' (%s).",
.
2c
/* hack.do_name.c - version 1.0.3 */
.
w
q
-*-END-*-
echo Editing hack.do_wear.c ; ed hack.do_wear.c << '-*-END-*-'
250d
229a
	case RIN_FIRE_RESISTANCE:
		/* Bad luck if the player is in hell... --jgm */
		if (!Fire_resistance && dlevel >= 30) {
			pline("The flames of Hell burn you to a crisp.");
			killer = "stupidity in hell";
			done("burned");
		}
		break;
.
173a
	if(otmp == uwep && uwep->cursed) {
		pline("%s is welded to your hand.", Doname(uwep));
		return(0);
	}
.
141a
	if(otmp == uwep && uwep->cursed) {
		if(!err++)
			pline("%s is welded to your hand.", Doname(uwep));
	}
.
54a
		case '?':
			(void) doprring();
			/* might look at morc here %% */
.
45c
		pline("What ring, Right or Left? [ rl?]");
.
28a
	if( otmp == uarmg && uwep && uwep->cursed ) {	/* myers@uwmacc */
 pline("You seem not able to take off the gloves while holding your weapon.");
		return(0);
	}
.
7a
extern char *Doname();
.
2c
/* hack.do_wear.c - version 1.0.3 */
.
w
q
-*-END-*-
echo Editing hack.dog.c ; ed hack.dog.c << '-*-END-*-'
387c
		mtmp->isshk || mtmp->isgd || index(" &@12", mtmp->data->mlet))
.
304,305c
			if(edog->hungrytime < moves)
			    edog->hungrytime = moves;
			edog->hungrytime +=
			    5*obj->quan * objects[obj->otyp].nutrition;
.
152a
			edog->dropdist = udist;		/* hpscdi!jon */
			edog->droptime = moves;
.
145a
	/* maybe we tamed him while being swallowed --jgm */
	if(!udist) return(0);

.
138c
		pline("You have a sad feeling for a moment, then it passes.");
.
136c
			pline("%s dies from hunger.", Monnam(mtmp));
.
131c
			pline("%s is confused from hunger.", Monnam(mtmp));
.
57c
	    if(dist(mtmp->mx,mtmp->my) < 3 && follower(mtmp)
		&& !mtmp->msleep && !mtmp->mfroz) {
.
36a
	/* they will appear on the next level @ goes to, even if he goes up! */
.
2c
/* hack.dog.c - version 1.0.3 */
.
w
q
-*-END-*-
echo Editing hack.eat.c ; ed hack.eat.c << '-*-END-*-'
419a
		/* NOTREACHED */
	case 'a':
	  if(Stoned) {
	      pline("What a pity - you just destroyed a future piece of art!");
	      tp++;
	      Stoned = 0;
	  }
	  break;
.
390,392c
		if(!Invis) {
			Invis = 50+rn2(100);
			if(!See_invisible)
				newsym(u.ux, u.uy);
		} else {
			Invis |= INTRINSIC;
			See_invisible |= INTRINSIC;
		}
.
350c
	if(let != 'a' && moves > otmp->age + 50 + rn2(100)) {
.
257,259c
	if(moves % 2) {
		if(Regeneration) u.uhunger--;
		if(Hunger) u.uhunger--;
		/* a3:  if(Hunger & LEFT_RING) u.uhunger--;
			if(Hunger & RIGHT_RING) u.uhunger--;
		   etc. */
	}
	if(moves % 20 == 0) {			/* jimt@asgb */
		if(uleft) u.uhunger--;
		if(uright) u.uhunger--;
	}
.
237,238c
				if(u.uhp > u.uhpmax) {
					if(!rn2(17)) u.uhpmax++;
					u.uhp = u.uhpmax;
				}
				heal_legs();
.
206a
				if(Sick) {
					Sick = 0;	/* David Neves */
					pline("What a relief!");
				}
.
133c
			pline("Using your %s you try to open the tin.",
.
107,108c
				otmp = addinv(otmp);
				addtobill(otmp);
.
10c
extern struct obj *splitobj(), *addinv();
.
2c
/* hack.eat.c - version 1.0.3 */
.
w
q
-*-END-*-
echo Editing hack.end.c ; ed hack.end.c << '-*-END-*-'
582a
			outwithit:
.
575a
#ifdef PERS_IS_UID
		if(!playerct && t1->uid == uid)
			goto outwithit;
		else
#endif PERS_IS_UID
.
567c
		  printf("Call is: %s -s [playernames]\n", hname);
		}
.
564,565c
		if(playerct < 1) printf("you.\n");
		else {
		  if(playerct > 1) printf("any of ");
		  for(i=0; i<playerct; i++)
.
548a
#ifdef PERS_IS_UID
	  if(!playerct && t1->uid == uid)
		flg++;
	  else
#endif PERS_IS_UID
.
533a
#endif PERS_IS_UID
.
528a
#ifdef PERS_IS_UID
		uid = getuid();
		playerct = 0;
#else
.
512a
#ifdef PERS_IS_UID
	int uid = -1;
#else
	char *player0;
#endif PERS_IS_UID
.
498d
463,464d
459c
	for(x = maxdlevel; x >= 0; x--) {
.
396,397c
	  if(!strncmp(t1->death,"quit",4)) {
	    quit = TRUE;
	    if(t1->maxhp < 3*t1->hp && t1->maxlvl < 4)
	  	Sprintf(eos(linebuf), "cravenly gave up");
	    else
		Sprintf(eos(linebuf), "quit");
	  }
.
94,95c
#ifdef WIZARD
	    if(!wizard)
#endif WIZARD
		savebones();
.
69a
		if(u.uhpmax < 0) u.uhpmax = 100;	/* arbitrary */
.
2c
/* hack.end.c - version 1.0.3 */
.
w
q
-*-END-*-
echo Editing hack.engrave.c ; ed hack.engrave.c << '-*-END-*-'
197c
	case ENGRAVE:		/* here otmp != 0 */
.
148a
		if(!otmp)
			type = DUST;
		else
.
145,146c
			if(uwep && uwep->cursed) {
			    /* Andreas Bormann */
			    pline("Since your weapon is welded to your hand,");
			    pline("you use the %s.", aobjnam(uwep, (char *) 0));
			    otmp = uwep;
			} else {
			    if(!otmp)
				pline("You are now empty-handed.");
			    else if(otmp->cursed)
				pline("The %s %s to your hand!",
				    aobjnam(otmp, "weld"),
				    (otmp->quan == 1) ? "itself" : "themselves");
			    else
				pline("You now wield %s.", doname(otmp));
			    setuwep(otmp);
			}
.
143a
		/* first wield otmp */
.
134,140c

	if(otmp == &zeroobj)
		otmp = 0;
	if(otmp->otyp == WAN_FIRE && otmp->spe) {
.
49a
u_wipe_engr(cnt)
register int cnt;
{
	if(!u.uswallow && !Levitation)
		wipe_engr_at(u.ux, u.uy, cnt);
}

.
2c
/* hack.engrave.c - version 1.0.3 */
.
w
q
-*-END-*-
echo Editing hack.fight.c ; ed hack.fight.c << '-*-END-*-'
347c
	      if(!rn2(500)) if((int)u.uluck > LUCKMIN) u.uluck--;
.
340c
	if(malive && mdat->mlet == 'E' && canseemon(mtmp)
.
252a
	u_wipe_engr(3);   /* andrew@orca: prevent unlimited pick-axe attacks */

.
231c
	if(u.umconf && !thrown) {
.
228,229d
223,226c
	if(!hittxt) {
		if(thrown)
			/* this assumes that we cannot throw plural things */
			hit( xname(obj)  /* or: objects[obj->otyp].oc_name */,
				mon, exclam(tmp) );
		else if(Blind)
			pline("You hit it.");
		else
			pline("You hit %s%s", monnam(mon), exclam(tmp));
.
183a
				hittxt = TRUE;
.
180c
			pline("You hit %s with the cockatrice corpse.",
.
140c
			pline("You hit the cockatrice with your bare hands.");
.
135a
	boolean hittxt = FALSE;
.
2c
/* hack.fight.c - version 1.0.3 */
.
w
q
-*-END-*-
echo Editing hack.h ; ed hack.h << '-*-END-*-'
159a
#define	MAXLEVEL	40
.
115c
	struct prop uprops[LAST_RING+10];
.
111a
#define STONED		(LAST_RING+9)		/* not a ring */
#define Stoned		u.uprops[STONED].p_flgs
.
101a
#define Invisible	(Invis && !See_invisible)
.
82c
	unsigned ulevel:4;	/* 1 - 14 */
.
78a
#define	LUCKMAX		10	/* on moonlit nights 11 */
#define	LUCKMIN		(-10)
.
42,44d
2c
/* hack.h - version 1.0.3 */
.
w
q
-*-END-*-
echo Editing hack.invent.c ; ed hack.invent.c << '-*-END-*-'
686,687c
	  (index("%*?!", obj->olet) ||
	    (obj->known == otmp->known &&
		(obj->olet == WEAPON_SYM && obj->otyp < BOOMERANG)))) {
.
682,684c
	if(obj->otyp == otmp->otyp &&
	  obj->unpaid == otmp->unpaid &&
	  obj->spe == otmp->spe &&
	  obj->dknown == otmp->dknown &&
.
637d
631a

.
628a
	if(Blind) {
	    pline("You try to feel what is lying here on the floor.");
	    if(Levitation) {				/* ab@unido */
		pline("You cannot reach the floor!");
		return(1);
	    }
	}
.
607,610c
	    if(!flags.invlet_constant) if(++ilet > 'z') ilet = 'A';
.
604a
	    if(flags.invlet_constant) ilet = otmp->invlet;
.
542c
	    if(!flags.invlet_constant) if(++ilet > 'z') ilet = 'A';
.
539,540c
		    cornline(1, xprname(otmp, ilet));
		    any[ct++] = ilet;
.
537a
	    if(flags.invlet_constant) ilet = otmp->invlet;
.
508c
	(void) sprintf(li, "%c - %s.",
		flags.invlet_constant ? obj->invlet : let,
		doname(obj));
.
492c
	return(otmp ? ilet : NOINVSYM);
.
489a
	if(flags.invlet_constant)
		return(obj->invlet);
	ilet = 'a';
.
488c
	register char ilet;
.
484c
obj_to_let(obj)	/* should of course only be called for things in invent */
.
333,335c
		if(flags.invlet_constant) {
			for(otmp = invent; otmp; otmp = otmp->nobj)
				if(otmp->invlet == ilet) break;
		} else {
			if(ilet >= 'A' && ilet <= 'Z') ilet += 'z'-'A'+1;
			ilet -= 'a';
			for(otmp = invent; otmp && ilet;
					ilet--, otmp = otmp->nobj) ;
		}
.
265c
	    }
	    if(ilet == 'z') ilet = 'A'; else ilet++;
.
252,263c
	    if(!*let || index(let, otmp->olet)) {
		bp[foo++] = flags.invlet_constant ? otmp->invlet : ilet;

		/* ugly check: remove inappropriate things */
		if((!strcmp(word, "take off") &&
		    !(otmp->owornmask & (W_ARMOR - W_ARM2)))
		|| (!strcmp(word, "wear") &&
		    (otmp->owornmask & (W_ARMOR | W_RING)))
		|| (!strcmp(word, "wield") &&
		    (otmp->owornmask & W_WEP))) {
			foo--;
			foox++;
.
248c
	if(bp > buf && bp[-1] == '-') *bp++ = ' ';
.
220,224c
/*
 * getobj returns:
 *	struct obj *xxx:	object to do something with.
 *	(struct obj *) 0	error return: no object.
 *	&zeroobj		explicitly no object (as in w-).
 */
.
48c

	if(obj == invent)
		invent = invent->nobj;
.
46c
freeinv(obj)
register struct obj *obj;
{
.
29a

	if(flags.invlet_constant) {
		assigninvlet(obj);
		/*
		 * The ordering of the chain is nowhere significant
		 * so in case you prefer some other order than the
		 * historical one, change the code below.
		 */
		if(otmp) {	/* find proper place in chain */
			otmp->nobj = 0;
			if((invent->invlet ^ 040) > (obj->invlet ^ 040)) {
				obj->nobj = invent;
				invent = obj;
			} else
			for(otmp = invent; ; otmp = otmp->nobj) {
			    if(!otmp->nobj ||
				(otmp->nobj->invlet ^ 040) > (obj->invlet ^ 040)){
				obj->nobj = otmp->nobj;
				otmp->nobj = obj;
				break;
			    }
			}
		}
	}

.
28d
24,25c
			break;
.
20,21c

	/* merge or attach to end of chain */
	if(!invent) {
		invent = obj;
		otmp = 0;
	} else
	for(otmp = invent; /* otmp */; otmp = otmp->nobj) {
		if(merged(otmp, obj, 0))
			return(otmp);
.
18c
addinv(obj)
register struct obj *obj;
{
.
16a
#define	NOINVSYM	'#'

static int lastinvnr = 51;	/* 0 ... 51 */
static
assigninvlet(otmp)
register struct obj *otmp;
{
	boolean inuse[52];
	register int i;
	register struct obj *obj;

	for(i = 0; i < 52; i++) inuse[i] = FALSE;
	for(obj = invent; obj; obj = obj->nobj) if(obj != otmp) {
		i = obj->invlet;
		if('a' <= i && i <= 'z') inuse[i - 'a'] = TRUE; else
		if('A' <= i && i <= 'Z') inuse[i - 'A' + 26] = TRUE;
		if(i == otmp->invlet) otmp->invlet = 0;
	}
	if((i = otmp->invlet) &&
	    (('a' <= i && i <= 'z') || ('A' <= i && i <= 'Z')))
		return;
	for(i = lastinvnr+1; i != lastinvnr; i++) {
		if(i == 52) { i = -1; continue; }
		if(!inuse[i]) break;
	}
	otmp->invlet = (inuse[i] ? NOINVSYM :
			(i < 26) ? ('a'+i) : ('A'+i-26));
	lastinvnr = i;
}

.
13d
10a

.
2c
/* hack.invent.c - version 1.0.3 */
.
w
q
-*-END-*-
echo Editing hack.lev.c ; ed hack.lev.c << '-*-END-*-'
265,266c
		pline("Read %d instead of %u bytes.\n", rlen, len);
		if(restoring) {
			(void) unlink(SAVEF);
			error("Error restoring old game.");
		}
		panic("Error reading level file.");
.
262c
	register int rlen;
	extern boolean restoring;

.
34c
	if(lev >= 0 && lev <= MAXLEVEL)
.
21,22c
boolean level_exists[MAXLEVEL+1];
.
10a
extern char SAVEF[];
.
2c
/* hack.lev.c - version 1.0.3 */
.
w
q
-*-END-*-
echo Editing hack.main.c ; ed hack.main.c << '-*-END-*-'
493c
	pline("Program in disorder - perhaps you'd better Quit.");
.
456,460c
	while(*tf && *tf != '.') tf++;
	(void) sprintf(tf, ".%d", foo);
.
402,448d
240a
	regularize(SAVEF+5);		/* avoid . or / in name */
.
208c
		getlock();	/* sets lock if locknum != 0 */
.
32d
27c
int locknum;				/* max num of players */
.
25d
6d
2c
/* hack.main.c - version 1.0.3 */
.
w
q
-*-END-*-
echo Editing hack.mhitu.c ; ed hack.mhitu.c << '-*-END-*-'
340c
	if((Invis && mtmp->data->mlet != 'I') || !mtmp->mcansee) tmp -= 2;
.
317a
	nomul(0);
.
291c
		  set_wounded_legs(side, rnd(50));
.
208c
		if(hitu(mtmp,rnd(6)) && tmp &&	/* hits with both paws */
.
154c
		if(ctmp && multi >= 0 && !rn2(3)) {
.
115,116c
				Stoned = 5;
				/* pline("You get turned to stone!"); */
				/* done_in_by(mtmp); */
.
104a
		    }
.
102a
		    if(Poison_resistance)
			pline("The sting doesn't seem to affect you.");
		    else {
.
52a
	if(mdat->mlet == 'c' && Stoned)
		return(0);

.
29c
				/* "notreached": not return(1); */
.
2c
/* hack.mhitu.c - version 1.0.3 */
.
w
q
-*-END-*-
echo Editing hack.mklev.c ; ed hack.mklev.c << '-*-END-*-'
650,651c
		    mksobj_at(SCR_TELEPORTATION, xx, yy+dy);
		    if(!rn2(3)) (void) mkobj_at(0, xx, yy+dy);
.
648c
		    dosdoor(xx, yy, aroom, rn2(5) ? SDOOR : DOOR);
.
643c
		dosdoor(xx, yy, aroom, SDOOR);
.
641c
		    make_engr_at(xx, yy-dy, "ad ae?ar um");
.
601c
	register int ct = rnd(nroom/2 + 1);
.
380c
				pline("Strange area [%d,%d] in maker().",x,y);
.
346c
		levl[x][y].scrsym = '+';
.
343a
	if(!IS_WALL(levl[x][y].typ))	/* avoid SDOORs with '+' as scrsym */
		type = DOOR;
.
309c
/* see whether it is allowable to create a door at [x,y] */
.
49a
	oinit();	/* assign level dependent obj probabilities */

.
2c
/* hack.mklev.c - version 1.0.3 */
.
w
q
-*-END-*-
echo Editing hack.mkobj.c ; ed hack.mkobj.c << '-*-END-*-'
2c
/* hack.mkobj.c - version 1.0.3 */
.
w
q
-*-END-*-
echo Editing hack.mkshop.c ; ed hack.mkshop.c << '-*-END-*-'
90c
		pline("Room at (%d,%d),(%d,%d).", sroom->lx, sroom->ly,
.
2c
/* hack.mkshop.c - version 1.0.3 */
.
w
q
-*-END-*-
echo Editing hack.mon.c ; ed hack.mon.c << '-*-END-*-'
726c
		if(cansee(x,y))
			atl(x,y,obj2->olet);
.
720c
	if(!letter(tmp) || (!index("mw", tmp) && !rn2(3))) tmp = 0;
.
695c
	while(u.ulevel < 14 && u.uexp >= newuexp()){
.
662a
	if((int)u.uluck < LUCKMIN) u.uluck = LUCKMIN;
.
634,635c
	register int tmp,tmp2,nk,x,y;
	register struct permonst *mdat = mtmp->data;
	extern long newuexp();

.
579a
	if(u.ustuck == mtmp) u.ustuck = mtmp2;
.
283a
not_special:
.
239a
#ifndef NOWORM
	if(mtmp->wormno)
		goto not_special;
#endif NOWORM

.
231a
	if(mtmp->mfroz || mtmp->msleep)
		return(0);
.
207,210c
	if(!index("Ea", mdat->mlet) && nearby &&
	 !mtmp->mpeaceful && u.uhp > 0 && !scared) {
.
198d
195a
		(mtmp->minvis && !rn2(3)) ||
.
194c

	/* fleeing monsters might regain courage */
	if(mtmp->mflee && !mtmp->mfleetim
	    && mtmp->mhp == mtmp->mhpmax && !rn2(25))
		mtmp->mflee = 0;

	nearby = (dist(mtmp->mx, mtmp->my) < 3);
	scared = (nearby && (sengr_at("Elbereth", u.ux, u.uy) ||
			sobj_at(SCR_SCARE_MONSTER, u.ux, u.uy)));
	if(scared && !mtmp->mflee) {
		mtmp->mflee = 1;
		mtmp->mfleetim = (rn2(7) ? rnd(10) : rnd(100));
	}

	if(!nearby ||
		mtmp->mflee ||
.
154c
	register tmp, nearby, scared;
.
130a
	/* flags.botlx = 1;		/* should we show status line ? */
.
2c
/* hack.mon.c - version 1.0.3 */
.
w
q
-*-END-*-
echo Editing hack.o_init.c ; ed hack.o_init.c << '-*-END-*-'
80a
}

setgemprobs()
{
	register int j,first;
	extern xchar dlevel;

	first = bases[letindex(GEM_SYM)];

	for(j = 0; j < 9-dlevel/3; j++)
		objects[first+j].oc_prob = 0;
	first += j;
	if(first >= LAST_GEM || first >= SIZE(objects) ||
	    objects[first].oc_olet != GEM_SYM ||
	    objects[first].oc_name == NULL)
		printf("Not enough gems? - first=%d j=%d LAST_GEM=%d\n",
			first, j, LAST_GEM);
	for(j = first; j < LAST_GEM; j++)
		objects[j].oc_prob = (20+j-first)/(LAST_GEM-first);
}

oinit()			/* level dependent initialization */
{
	setgemprobs();
.
47a
		if(let == GEM_SYM)
			setgemprobs();
	check:
.
35,46d
2c
/* hack.o_init.c - version 1.0.3 */
.
w
q
-*-END-*-
echo Editing hack.options.c ; ed hack.options.c << '-*-END-*-'
75a
		return;
	}

	if(!strncmp(opts,"fixinv",4)) {
		if(from_env)
			flags.invlet_constant = !negated;
		else
			pline("The fixinvlet option must be in HACKOPTIONS.");
.
15a
	flags.invlet_constant = TRUE;
.
2c
/* hack.options.c - version 1.0.3 */
.
w
q
-*-END-*-
echo Editing hack.pager.c ; ed hack.pager.c << '-*-END-*-'
351a
#endif NOWAITINCLUDE
.
346a
#ifdef NOWAITINCLUDE
union wait {		/* used only for the cast  (union wait *) 0  */
	int w_status;
	struct {
		unsigned short w_Termsig:7;
		unsigned short w_Coredump:1;
		unsigned short w_Retcode:8;
	} w_T;
};

#else

.
297c
		extern char *catmore;
.
226a
	    if(flags.toplin == 1) more();	/* ab@unido */
	    remember_topl();

.
46a
			(void) fclose(fp); 	/* kopper@psuvax1 */
.
45a
					return(0);
				}
.
44c
				if(readchar() == 'y') {
.
41c
			pline(buf);
.
2c
/* hack.pager.c - version 1.0.3 */
.
w
q
-*-END-*-
echo Editing hack.potion.c ; ed hack.potion.c << '-*-END-*-'
364a
}

ghost_from_bottle(){
	extern struct permonst pm_ghost;
	register struct monst *mtmp;

	if(!(mtmp = makemon(PM_GHOST,u.ux,u.uy))){
		pline("This bottle turns out to be empty.");
		return;
	}
	mnexto(mtmp);
	pline("As you open the bottle, an enormous ghost emerges!");
	pline("You are frightened to death, and unable to move.");
	nomul(-3);
.
361c
			if(obj->spe < 7) obj->spe++;	/* %% */
.
233a
		/* perhaps 'E' and 'a' have no head? */
.
197,198c
	if(u.ulevel < 14) {
		extern long newuexp();

		u.uexp = newuexp()+1;
		pline("Welcome to experience level %u.", ++u.ulevel);
	}
.
184a
use_it:
.
128,132c
			heal_legs();
.
109c
		losehp(rnd(10), "contaminated potion");
.
38c
		if(Invis || See_invisible)
.
15a
	if(!strcmp(objects[otmp->otyp].oc_descr, "smoky") && !rn2(13)) {
		ghost_from_bottle();
		goto use_it;
	}
.
7a
extern struct monst *makemon();
.
2c
/* hack.potion.c - version 1.0.3 */
.
w
q
-*-END-*-
echo Editing hack.pri.c ; ed hack.pri.c << '-*-END-*-'
462,468c
vism_at(x,y)
register x,y;
{
	register struct monst *mtmp;

	return((x == u.ux && y == u.uy && !Invisible)
			? 1 :
	       (mtmp = m_at(x,y))
			? ((Blind && Telepat) || canseemon(mtmp)) :
		0);
.
389,392c
	if(!vism_at(x,y)) {
.
385d
289c
	if(x == u.ux && y == u.uy && (!Invisible)) {
.
264c
	if(Invisible) {
.
260c
	if(u.udispl && (Invisible || u.udisx != u.ux || u.udisy != u.uy))
.
229a

	seemons();	/* reset old positions */
	for(mtmp = fmon; mtmp; mtmp = mtmp->nmon)
	    if(mtmp->mx >= xmin && mtmp->my < ymax)
		mtmp->mdispl = 0;
	seemons();	/* force new positions to be shown */

.
225a
	register struct monst *mtmp;

.
204,207c
		mtmp->mdispl = 0;
	seemons();	/* force new positions to be shown */
/* This nonsense should disappear soon --------------------------------- */
.
200,202c
	seemons();	/* reset old positions */
.
194c

/* Some ridiculous code to get display of @ and monsters (almost) right */
	if(!Invisible) {
.
187a
	register struct monst *mtmp;
.
175c
	if(!Invisible) at(u.ux,u.uy,u.usym);
.
2c
/* hack.pri.c - version 1.0.3 */
.
w
q
-*-END-*-
echo Editing hack.read.c ; ed hack.read.c << '-*-END-*-'
517a
}

/* Test whether we may genocide all monsters with symbol  ch  */
monstersym(ch)				/* arnold@ucsfcgl */
register char ch;
{
	register struct permonst *mp;
	extern struct permonst pm_eel;

	/*
	 * can't genocide certain monsters
	 */
	if (index("12 &:", ch))
		return FALSE;

	if (ch == pm_eel.mlet)
		return TRUE;
	for (mp = mons; mp < &mons[CMNUM+2]; mp++)
		if (mp->mlet == ch)
			return TRUE;
	return FALSE;
.
467c
			pline("Nothing Happens.");
.
192c
		} while(strlen(buf) != 1 || !monstersym(*buf));
.
2c
/* hack.read.c - version 1.0.3 */
.
w
q
-*-END-*-
echo Editing hack.rumors.c ; ed hack.rumors.c << '-*-END-*-'
5,6c
#include	"hack.h"		/* for RUMORFILE and BSD (index) */
#define	CHARSZ	8			/* number of bits in a char */
.
2c
/* hack.rumors.c - version 1.0.3 */
.
w
q
-*-END-*-
echo Editing hack.save.c ; ed hack.save.c << '-*-END-*-'
216a
		if(!mtmp->m_id)
			mtmp->m_id = flags.ident++;
.
182a
		if(!otmp->o_id) otmp->o_id = flags.ident++;
.
161a
	restoring = FALSE;
.
106a
		restoring = FALSE;
.
94a
	restoring = TRUE;
.
93a
	extern boolean restoring;
.
80,83c
	glo(dlevel);
	(void) unlink(lock);	/* get rid of current level --jgm */
	glo(0);
	(void) unlink(lock);
.
42a
	if(flags.moonphase == FULL_MOON)	/* ut-sally!fletcher */
		u.uluck--;			/* and unido!ab */
.
40a
		(void) unlink(SAVEF);		/* ab@unido */
.
2c
/* hack.save.c - version 1.0.3 */
.
w
q
-*-END-*-
echo Editing hack.search.c ; ed hack.search.c << '-*-END-*-'
96,97c
doidtrap() {
.
56a
	if(u.uswallow)
		pline("What are you looking for? The exit?");
	else
.
2c
/* hack.search.c - version 1.0.3 */
.
w
q
-*-END-*-
echo Editing hack.shk.c ; ed hack.shk.c << '-*-END-*-'
920a
}

/* He is digging in the shop. */
shopdig(fall)
register int fall;
{
    if(!fall) {
	if(u.utraptype == TT_PIT)
	    pline("\"Be careful, sir, or you might fall through the floor.\"");
	else
	    pline("\"Please, do not damage the floor here.\"");
    } else if(dist(shopkeeper->mx, shopkeeper->my) < 3) {
	register struct obj *obj, *obj2;

	pline("%s grabs your backpack!", shkname(shopkeeper));
	for(obj = invent; obj; obj = obj2) {
		obj2 = obj->nobj;
		if(obj->owornmask) continue;
		freeinv(obj);
		obj->nobj = shopkeeper->minvent;
		shopkeeper->minvent = obj;
		if(obj->unpaid)
			subfrombill(obj);
	}
    }
.
797c
	if(ESHK(shkp)->following || ((z = holetime()) >= 0 && z*z <= udist)){
.
756a
	int z;
.
694,695c
		ac = ARM_BONUS(obj);
		if(ac <= -10)		/* probably impossible */
			ac = -9;
		tmp = 100 + ac*ac*rnd(10+ac);
.
663c
register int tmp, ac;
.
649a
	    }
.
643a
		obj->quan = oquan;		/* restore value */
.
642a
		obj->quan = uquan;		/* cheat doname */
.
635,641c
		oquan = obj->quan;
		uquan = (bp->useup ? bp->bquan : bp->bquan - oquan);
		thisused = bp->price * uquan;
.
631,633c
	for(bp = bill; bp - bill < ESHK(shopkeeper)->billct; bp++) {
	    obj = bp_to_obj(bp);
	    if(!obj) {
		impossible("Bad shopkeeper administration.");
		goto quit;
	    }
	    if(bp->useup || bp->bquan > obj->quan) {
		register int cnt, oquan, uquan;
.
615,616c
		for(bp = bill; bp - bill < ESHK(shopkeeper)->billct; bp++)
		    if(bp->useup ||
		      ((obj = bp_to_obj(bp)) && obj->quan < bp->bquan))
.
606c
	register struct bill_x *bp;
.
496c
	  ) return;
.
493,494c
	if(!inshop() ||
	(u.ux == ESHK(shopkeeper)->shk.x && u.uy == ESHK(shopkeeper)->shk.y) ||
	(u.ux == ESHK(shopkeeper)->shd.x && u.uy == ESHK(shopkeeper)->shd.y) ||
.
489a
/* find obj on one of the lists */
struct obj *
bp_to_obj(bp)
register struct bill_x *bp;
{
	register struct obj *obj;
	register struct monst *mtmp;
	register unsigned id = bp->bo_id;

	if(bp->useup)
		obj = o_on(id, billobjs);
	else if(!(obj = o_on(id, invent)) &&
		!(obj = o_on(id, fobj)) &&
		!(obj = o_on(id, fcobj))) {
		    for(mtmp = fmon; mtmp; mtmp = mtmp->nmon)
			if(obj = o_on(id, mtmp->minvent))
			    break;
		    for(mtmp = fallen_down; mtmp; mtmp = mtmp->nmon)
			if(obj = o_on(id, mtmp->minvent))
			    break;
		}
	return(obj);
}

.
473c
	if(shlevel == dlevel && shopkeeper && ESHK(shopkeeper)->billct){
.
464c
			else pline("Error in shopkeeper administration.");
.
422,434c
	obj = bp_to_obj(bp);

.
381c
			if(strncmp(ESHK(shkp)->customer, plname, PL_NSIZ)
			   || rn2(3)){
.
236c
		/* billobjs = 0; -- this is wrong if we save in a shop */
		/* (and it is harmless to have too many things in billobjs) */
.
189a

.
186a
	    } else if(inroom(shopkeeper->mx, shopkeeper->my) != roomno) {
		u.uinshop = 0;
.
35c
extern struct obj *o_on(), *bp_to_obj();
.
2c
/* hack.shk.c - version 1.0.3 */
.
w
q
-*-END-*-
echo Editing hack.steal.c ; ed hack.steal.c << '-*-END-*-'
18c
		if(Invisible) newsym(u.ux, u.uy);
.
2c
/* hack.steal.c - version 1.0.3 */
.
w
q
-*-END-*-
echo Editing hack.termcap.c ; ed hack.termcap.c << '-*-END-*-'
261c
		curs(cx, cy);
.
241c
			cmov(curx, cury);
.
234a

		/* cbosgd!cbcephus!pds for SYS V R2 */
		/* is this terminfo, or what? */
		/* tputs("$<50>", 1, xputc); */

.
199c
		curs(1, 1);	/* using UP ... */
.
197c
		xputs(tgoto(CM, 0, 0));
.
183c
		curs(cx, cy);
.
164c
	(void) fputc(c, stdout);
.
158c
	xputs(tgoto(CM, x-1, y-1));
.
155,156c
cmov(x, y)
register x, y;
.
142a
		if(!ND) cmov(x, y); else	/* bah */
			/* should instead print what is there already */
.
133c
			cmov(x, y);
.
124c
			curs(x, y);
.
121c
			cmov(x, y);
.
112c
nocmov(x, y)
.
109c
		cmov(x, y);
.
107c
		nocmov(x, y);
.
105c
		nocmov(x, y);
.
101c
		nocmov(x, y);
.
99a
	if(!ND && (curx != x || x <= 3)) {	/* Extremely primitive */
		cmov(x, y);			/* bunker!wtm */
		return;
	}
.
93,94c
curs(x, y)
register int x, y;	/* not xchar: perhaps xchar is unsigned and
.
72c
	CD = tgetstr("cd", &tbufptr);
.
68,69c
	SO = tgetstr("so", &tbufptr);
	SE = tgetstr("se", &tbufptr);
.
61,62c
	XD = tgetstr("xd", &tbufptr);
/* not: 		XD = tgetstr("do", &tbufptr); */
	if(!(CM = tgetstr("cm", &tbufptr))) {
.
51,56c
	if(!(CL = tgetstr("cl", &tbufptr)))
		error("Hack needs CL.");
	ND = tgetstr("nd", &tbufptr);
	if(tgetflag("os"))
		error("Hack can't have OS.");
	CE = tgetstr("ce", &tbufptr);
	UP = tgetstr("up", &tbufptr);
.
39c
	if(!(BC = tgetstr("bc", &tbufptr))) {	
.
37c
	if(pc = tgetstr("pc", &tbufptr))
.
35c
	if(tgetent(tptr, term) < 1)
.
33c
	if(!strncmp(term, "5620", 4))
.
2c
/* hack.termcap.c - version 1.0.3 */
.
w
q
-*-END-*-
echo Editing hack.timeout.c ; ed hack.timeout.c << '-*-END-*-'
31a
}

/* He is being petrified - dialogue by inmet!tower */
char *stoned_texts[] = {
	"You are slowing down.",		/* 5 */
	"Your limbs are stiffening.",		/* 4 */
	"Your limbs have turned to stone.",	/* 3 */
	"You have turned to stone.",		/* 2 */
	"You are a statue."			/* 1 */
};

stoned_dialogue()
{
	register long i = (Stoned & TIMEOUT);

	if(i > 0 && i <= SIZE(stoned_texts))
		pline(stoned_texts[SIZE(stoned_texts) - i]);
	if(i == 5)
		Fast = 0;
	if(i == 3)
		nomul(-3);
.
29a
			break;
		case WOUNDED_LEGS:
			heal_legs();
			break;
.
24c
			pline("You can see again.");
.
21c
			pline("You feel less confused now.");
.
18c
			pline("You feel yourself slowing down.");
.
16c
			break;
.
13c
			pline("You die because of food poisoning.");
.
11a
		case STONED:
			killer = "cockatrice";
			done("died");
			break;
.
7a
	if(Stoned) stoned_dialogue();
.
2c
/* hack.timeout.c - version 1.0.3 */
.
w
q
-*-END-*-
echo Editing hack.trap.c ; ed hack.trap.c << '-*-END-*-'
418,420c

	goto_level(newlevel, FALSE); /* calls done("escaped") if newlevel==0 */
}

drown()
{
	pline("You fall into a pool!");
	pline("You can't swim!");
	if(rn2(3) < u.uluck+2) {
		/* most scrolls become unreadable */
		register struct obj *obj;

		for(obj = invent; obj; obj = obj->nobj)
			if(obj->olet == SCROLL_SYM && rn2(12) > u.uluck)
				obj->otyp = SCR_BLANK_PAPER;
		/* we should perhaps merge these scrolls ? */

		pline("You attempt a teleport spell.");	/* utcsri!carroll */
		(void) dotele();
		if(levl[u.ux][u.uy].typ != POOL) return;
	}
	pline("You drown ...");
	killer = "pool of water";
	done("drowned");
.
393c
	    if(newlevel > MAXLEVEL) newlevel = MAXLEVEL;
.
385c
	    } while(!digit(buf[0]) && (buf[0] != '-' || !digit(buf[1])));
.
375,376d
315a
	if(levl[nux][nuy].typ == POOL && !Levitation)
		drown();
.
165c
			/* there should be a mtmp/data -> floating */
			if(!index("EywBfk'& ", mtmp->data->mlet)) { /* ab */
.
82c
			    losehp(uarmh ? 2 : d(2,10),"falling rock");
			    mksobj_at(ROCK, u.ux, u.uy);
			    fobj->quan = 1;
			    stackobj(fobj);
			    if(Invisible) newsym(u.ux, u.uy);
.
2c
/* hack.trap.c - version 1.0.3 */
.
w
q
-*-END-*-
echo Editing hack.tty.c ; ed hack.tty.c << '-*-END-*-'
236d
226c
	     noteof:	;
	}
#else
		end_of_input();
#endif NR_OF_EOFS
	if(flags.toplin == 1)
		flags.toplin = 2;
.
224a
#ifdef NR_OF_EOFS
	{ /*
	   * Some SYSV systems seem to return EOFs for various reasons
	   * (?like when one hits break or for interrupted systemcalls?),
	   * and we must see several before we quit.
	   */
		register int cnt = NR_OF_EOFS;
		while (cnt--) {
		    clearerr(stdin);	/* omit if clearerr is undefined */
		    if((sym = getchar()) != EOF) goto noteof;
		}
.
222a

.
203,204d
193,196c
	if(!Invisible) curs_on_u(); else home();
	while((foo = readchar()) >= '0' && foo <= '9')
		multi = 10*multi+foo-'0';
.
181c
		bell();
.
172,174c
	while((c = readchar()) != '\n') {
.
169d
145,150d
139c
	cgetret("");
.
132a
		} else if(c == kill_char || c == '\177') { /* Robert Viduya */
				/* this test last - @ might be the kill_char */
			while(bufp != obufp) {
				bufp--;
				putstr("\b \b");
			}
.
122,127c
		} else if(' ' <= c && c < '\177') {
				/* avoid isprint() - some people don't have it
				   ' ' is not always a printing char */
.
89a

/* fatal error */
/*VARARGS1*/
error(s,x,y) char *s; {
	if(settty_needed)
		settty((char *) 0);
	printf(s,x,y);
	putchar('\n');
	exit(1);
}

.
79,81c
	if((curttyb.cbrkflgs & CBRKMASK) != cf){
		curttyb.cbrkflgs &= ~CBRKMASK;
		curttyb.cbrkflgs |= cf;
#ifdef USG
		/* be satisfied with one character; no timeout */
		curttyb.c_cc[VMIN] = 1;		/* was VEOF */
		curttyb.c_cc[VTIME] = 0;	/* was VEOL */
#endif USG
.
74,76c
	if((curttyb.echoflgs & ECHO) != ef){
		curttyb.echoflgs &= ~ECHO;
/*		curttyb.echoflgs |= ef;					*/
.
66,72d
63a
register int ef = 0;			/* desired value of flags & ECHO */
register int cf = CBRKON(CBRKMASK);	/* desired value of flags & CBREAK */
register int change = 0;
.
59c
	if(STTY(&curttyb) < 0)
		perror("Hack (setctty)");
.
51,54c
	if(STTY(&inittyb) < 0)
		perror("Hack (settty)");
	flags.echo = (inittyb.echoflgs & ECHO) ? ON : OFF;
	flags.cbreak = (CBRKON(inittyb.cbrkflgs & CBRKMASK)) ? ON : OFF;
.
35,44d
28,29c
	if(curttyb.tabflgs & EXTABS) {
		curttyb.tabflgs &= ~EXTABS;
.
20,24c
	if(GTTY(&inittyb) < 0)
		perror("Hack (gettty)");
	curttyb = inittyb;
	ospeed = OSPEED(inittyb);
	erase_char = inittyb.erase_sym;
	kill_char = inittyb.kill_sym;
.
12a
struct termstruct inittyb, curttyb;
.
11c
static char erase_char, kill_char;
.
9c
#endif USG

.
7c
#define termstruct	sgttyb
#define	kill_sym	sg_kill
#define	erase_sym	sg_erase
#define EXTABS		XTABS
#define tabflgs		sg_flags
#define echoflgs	sg_flags
#define cbrkflgs	sg_flags
#define CBRKMASK	CBREAK
#define CBRKON		/* empty */
#define OSPEED(x)	(x).sg_ospeed
#define GTTY(x)		(gtty(0, x))
#define STTY(x)		(stty(0, x))
.
5a

/*
 * The distinctions here are not BSD - rest but rather USG - rest, as
 * BSD still has the old sgttyb structure, but SYSV has termio. Thus:
 */
#ifdef BSD
#define	V7
#else
#define USG
#endif BSD

/*
 * Some systems may have getchar() return EOF for various reasons, and
 * we should not quit before seeing at least NR_OF_EOFS consecutive EOFs.
 */
#ifndef BSD
#define	NR_OF_EOFS	20
#endif BSD


#ifdef USG

#include	<termio.h>
#define termstruct	termio
#define kill_sym	c_cc[VKILL]
#define erase_sym	c_cc[VERASE]
#define EXTABS		TAB3
#define tabflgs		c_oflag
#define echoflgs	c_lflag
#define cbrkflgs	c_lflag
#define CBRKMASK	ICANON
#define CBRKON		! /* reverse condition */
#define OSPEED(x)	((x).c_cflag & CBAUD)
#define GTTY(x)		(ioctl(0, TCGETA, x))
#define STTY(x)		(ioctl(0, TCSETA, x))	/* TCSETAF? TCSETAW? */

#else	/* V7 */

.
2c
/* hack.tty.c - version 1.0.3 */
/* With thanks to the people who sent code for SYSV - hpscdi!jon,
   arnold@ucsf-cgl, wcs@bo95b, cbcephus!pds and others. */
.
w
q
-*-END-*-
echo Editing hack.u_init.c ; ed hack.u_init.c << '-*-END-*-'
294a
#else
		if(trop->trquan) {		/* check if zero first */
			--trop->trquan;
			if(trop->trquan)
				continue;	/* make a similar object */
		}
#endif PYRAMID_BUG
.
293a
#ifndef PYRAMID_BUG
.
2c
/* hack.u_init.c - version 1.0.3 */
.
w
q
-*-END-*-
echo Editing hack.unix.c ; ed hack.unix.c << '-*-END-*-'
306a

regularize(s)	/* normalize file name - we don't like ..'s or /'s */
register char *s;
{
	register char *lp;

	while((lp = index(s, '.')) || (lp = index(s, '/')))
		*lp = '_';
}
.
200c
	} else if(nmstat.st_mtime > omstat.st_mtime) {
.
198c
		nmstat.st_mtime = 0;
.
180c
		omstat.st_mtime = 0;
.
134a
getlock()
{
	extern int errno, hackpid, locknum;
	register int i = 0, fd;

	(void) fflush(stdout);

	/* we ignore QUIT and INT at this point */
	if (link(HLOCK, LLOCK) == -1) {
		register int errnosv = errno;

		perror(HLOCK);
		printf("Cannot link %s to %s\n", LLOCK, HLOCK);
		switch(errnosv) {
		case ENOENT:
		    printf("Perhaps there is no (empty) file %s ?\n", HLOCK);
		    break;
		case EACCES:
		    printf("It seems you don't have write permission here.\n");
		    break;
		case EEXIST:
		    printf("(Try again or rm %s.)\n", LLOCK);
		    break;
		default:
		    printf("I don't know what is wrong.");
		}
		getret();
		error("");
		/*NOTREACHED*/
	}

	regularize(lock);
	glo(0);
	if(locknum > 25) locknum = 25;

	do {
		if(locknum) lock[0] = 'a' + i++;

		if((fd = open(lock, 0)) == -1) {
			if(errno == ENOENT) goto gotlock;    /* no such file */
			perror(lock);
			(void) unlink(LLOCK);
			error("Cannot open %s", lock);
		}

		if(veryold(fd))	/* if true, this closes fd and unlinks lock */
			goto gotlock;
		(void) close(fd);
	} while(i < locknum);

	(void) unlink(LLOCK);
	error(locknum ? "Too many hacks running now."
		      : "There is a game in progress under your name.");
gotlock:
	fd = creat(lock, FMASK);
	if(unlink(LLOCK) == -1)
		error("Cannot unlink %s.", LLOCK);
	if(fd == -1) {
		error("cannot creat lock file.");
	} else {
		if(write(fd, (char *) &hackpid, sizeof(hackpid))
		    != sizeof(hackpid)){
			error("cannot write lock");
		}
		if(close(fd) == -1) {
			error("cannot close lock");
		}
	}
}	

.
133d
125c
	for(i = 1; i <= MAXLEVEL; i++) {		/* try to remove all */
.
123c
	if(date - buf.st_mtime < 3L*24L*60L*60L) {	/* recent */
		extern int errno;
		int lockedpid;	/* should be the same size as hackpid */

		if(read(fd, (char *)&lockedpid, sizeof(lockedpid)) !=
			sizeof(lockedpid))
			/* strange ... */
			return(0);

		/* From: Rick Adams <seismo!rick>
		/* This will work on 4.1cbsd, 4.2bsd and system 3? & 5.
		/* It will do nothing on V7 or 4.1bsd. */
		if(!(kill(lockedpid, 0) == -1 && errno == ESRCH))
			return(0);
	}
.
115c
/* see whether we should throw away this xlock file */
.
108c
	if(buf.st_mtime < hbuf.st_mtime) {
.
97,100c
/* old version - for people short of space */
/*
/* register char *np;
/*	if(stat(name, &hbuf))
/*		error("Cannot get status of %s.",
/*			(np = rindex(name, '/')) ? np+1 : name);
/*
/* version using PATH from: seismo!gregc@ucsf-cgl.ARPA (Greg Couch) */


/*
 * The problem with   #include	<sys/param.h>   is that this include file
 * does not exist on all systems, and moreover, that it sometimes includes
 * <sys/types.h> again, so that the compiler sees these typedefs twice.
 */
#define		MAXPATHLEN	1024

register char *np, *path;
char filename[MAXPATHLEN+1];
	if (index(name, '/') != NULL || (path = getenv("PATH")) == NULL)
		path = "";

	for (;;) {
		if ((np = index(path, ':')) == NULL)
			np = path + strlen(path);	/* point to end str */
		if (np - path <= 1)			/* %% */
			(void) strcpy(filename, name);
		else {
			(void) strncpy(filename, path, np - path);
			filename[np - path] = '/';
			(void) strcpy(filename + (np - path) + 1, name);
		}
		if (stat(filename, &hbuf) == 0)
			return;
		if (*np == '\0')
			break;
		path = np + 1;
	}
	error("Cannot get status of %s.",
		(np = rindex(name, '/')) ? np+1 : name);
.
71,73c
	diy = lt->tm_yday;
.
61,64d
14a
#include <stdio.h>
#include <errno.h>
.
2c
/* hack.unix.c - version 1.0.3 */
.
w
q
-*-END-*-
echo Editing hack.version.c ; ed hack.version.c << '-*-END-*-'
7c
	pline("%s 1.0.3 - last edit %s.", (
.
2c
/* hack.version.c - version 1.0.3 */
/* $Header: hack.version.c,v 1.5 85/05/09 00:40:41 aeb Exp $ */
.
w
q
-*-END-*-
echo Editing hack.wield.c ; ed hack.wield.c << '-*-END-*-'
85c
	    while(uwep)		/* let all of them disappear */
				/* note: uwep->quan = 1 is nogood if unpaid */
	        useup(uwep);
.
38,39c
		if(uwep->cursed)
		    pline("The %s %s to your hand!",
			aobjnam(uwep, "weld"),
			(uwep->quan == 1) ? "itself" : "themselves"); /* a3 */
.
2c
/* hack.wield.c - version 1.0.3 */
.
w
q
-*-END-*-
echo Editing hack.wizard.c ; ed hack.wizard.c << '-*-END-*-'
24c
	    if(mtmp->data->mlet == '1' && mtmp->msleep && !rn2(40))
.
2c
/* hack.wizard.c - version 1.0.3 */
.
w
q
-*-END-*-
echo Editing hack.zap.c ; ed hack.zap.c << '-*-END-*-'
614a
}

burn_scrolls()
{
	register struct obj *obj, *obj2;
	register int cnt = 0;

	for(obj = invent; obj; obj = obj2) {
		obj2 = obj->nobj;
		if(obj->olet == SCROLL_SYM) {
			cnt++;
			useup(obj);
		}
	}
	if(cnt > 1) {
		pline("Your scrolls catch fire!");
		losehp(cnt, "burning scrolls");
	} else if(cnt) {
		pline("Your scroll catches fire!");
		losehp(1, "burning scroll");
	}
.
485a
					if(!rn2(3))
						burn_scrolls();
.
203a
				mksobj_at(ROCK, u.ux, u.uy);
				fobj->quan = 1;
				stackobj(fobj);
				if(Invisible) newsym(u.ux, u.uy);
.
129c
		pline("Nothing Happens.");
.
2c
/* hack.zap.c - version 1.0.3 */
.
w
q
-*-END-*-
echo Editing help ; ed help << '-*-END-*-'
125,126c
	(the lower the better), your strength, experience level and the
	state of your stomach.
.
114c
		Usually one will not want to use the 'O' command, but instead
.
107c
		rest_on_space, fixinvlet, beginner, male, female.
.
77a
	\	tell what has been discovered.
.
1c
	Welcome to HACK!		   ( description of version 1.0.3 )
.
w
q
-*-END-*-
echo Editing hh ; ed hh << '-*-END-*-'
22a
^T	teleport teleport
.
20a
#		introduces a long command; not really implemented
.
w
q
-*-END-*-
echo Editing rumors ; ed rumors << '-*-END-*-'
324a
Zapping a wand of undead turning might bring your dog back to life.
.
313a
You have to outwit a Sphynx or pay her.
You may get rich selling letters, but beware of being blackmailed!
.
311a
You die...
.
308a
You can get a genuine Amulet of Yendor by doing the following:  -- more --
You can't get rid of a cursed plate mail with a can-opener.
.
303a
Wishing too much may bring you too little.
.
299a
Who should ever have thought one could live from eating fog clouds?
Why a "2" for the postman? Well, how many times does he ring?
Why should one ever throw an egg to a cockatrice?
.
297a
When you have a key, you don't have to wait for the guard.
When you have seen one killer bee, you have seen them all.
When your dog follows you through a trap door, don't hit it!
.
293c
What do you think would be the use of a two handed sword called "Orcrist" ?
.
291a
What a pity, you cannot read it!
.
289a
Want a hint? Zap a wand of make invisible on your weapon!
Want fun? Throw a potion in a pool and go swimming!
Want to conserve your dead corpses? Go to the tin factory!
Wanted: shopkeepers. Send a scroll of mail to: Mage of Yendor/Level 35/Dungeon.
Warning: end of file 'fortunes' reached.
Warning: people who eat dragons can go to hell!!
.
286a
Vault guards never disturb their Lords.
.
283a
Ulch, that meat was painted.
.
278a
To reach heaven, escape the dungeon while wearing a ring of levitation.
.
273a
This dungeon is restroom equipped (for your convenience).
This fortune cookie is property of Fortune Cookies, Inc.
This is not a fortune.
.
270a
They say that you can't take your pick-axe into a shop.
.
265a
They say that the walls in shops are made of extra hard material.
.
245a
They say a gelatinous cube can paralyse you...
They say that Elven cloaks absorb enchantments.
.
244a
There is nothing like eating a Mimic.
.
234a
There are better information sources than fortune cookies.
.
232a
The proof of the quivering blob is in the eating thereof.
.
231a
The moon is not the only heavenly body to influence this game.
.
230a
The key to this game is that there are no keys.
.
224a
The "pray" command is not yet implemented.
.
223a
Taming a postman may cause a system security violation.
Taming is a gradual process of excercising and rewarding.
Telepathy is just a trick: once you know how to do it, it's easy.
.
221a
Surprise your dog with an acid blob!
Tainted meat is even more sickening than poison!
.
217a
Sorry, no fortune this time. Better luck next cookie!
Spare your scrolls of make-edible until it's really necessary!
.
216a
Some potions are quite mind-expanding.
Some questions Sphynxes ask just *don't* have any answers.
Sometimes "mu" is the answer.
.
215a
Some Balrogs don't attack if you offer them a ring.
Some mazes (especially small ones) have no solutions, says man 6 maze.
.
214a
Shopkeepers sometimes die from old age.
Sleeping may increase your strength.
.
213a
Shopkeepers are vegetarians: they only eat Swedes.
Shopkeepers can't read, so what use is engraving in a shop?
Shopkeepers can't swim.
Shopkeepers have incredible patience.
.
212a
Selling and rebuying a wand will recharge it.
.
207a
Reward your doggie with a giant Bat.
Ropes are made from the long, blond hairs of dead Nymphs.
Row (3x) that boat gently down the stream, Charon (4x), death is but a dream.
Running is good for your legs.
Rust monsters love water. There are potions they hate, however.
.
201a
Rays aren't boomerangs, of course, but still...
.
199a
Punishment is a thing you call over yourself. So why complain?
.
193a
Orcs and killer bees share their lifestyle.
.
185a
Only cave-women can catch a unicorn. And then only with a golden rope.
.
183a
Only a Nymph knows how to unlock chains.
Only a dragon will never get a cold from a wand of cold.
Only a real dummy would ever call his sword 'Elbereth'.
.
178a
Nymphs are blondes. Are you a gentleman?
Nymphs are very pleased when you call them by their real name: Lorelei.
Offering a unicorn a worthless piece of glass might prove to be fatal!
Old hackers never die: young ones do.
Old trees sometimes fall without a warning!
Once your little dog will be a big dog, and you will be proud of it.
One can even choke in a fortune cookie!
.
177a
Nurses are accustomed to touch naked persons: they don't harm them.
Nurses prefer undressed hackers.
.
173a
No easy fighting with a heavy load!
No level contains two shops. The maze is no level. So...
No part of this fortune may be reproduced, stored in a retrieval system, ...
.
169a
Never swim with a camera: there's nothing to take pictures of.
.
160a
Never drop a crysknife! No, never even unwield it, until...
.
158a
Need money? Sell your corpses to a tin factory.
.
154a
Most monsters can't swim.
.
150a
Meet yourself! Commit suicide and type "hack"
Meeting your own ghost decreases your luck considerably!
Memory flaw - core dumped.
.
147a
Looking for a monster -- use a staff of monster summoning.
.
146a
Let's face it: this time you're not going to win.
Let's have a party, drink a lot of booze.
.
143a
Leather armour cannot rust.
.
139a
Killer bees keep appearing till you kill their queen.
.
131a
It's easy to overlook a monster in a wood.
.
130a
It's bad luck to drown a postman.
.
129a
It would be peculiarly sad were your dog turned to stone.
.
127a
It is said that purple worms and trappers fill the same niche.
.
124a
It furthers one to see the great man.
.
123a
In total, there are eight sorts of shops.
Increase mindpower: Tame your own ghost!
.
122a
In a way, a scorpion is like a snake.
.
119a
If your ghost kills a player, it increases your score.
.
115a
If you want to genocide nurses, genocide @'s.
.
107a
If you are being punished, it's done with a deadly weapon.
.
106a
If "nothing happens", something *has* happened anyway!!
If a chameleon mimics a mace, it really mimics a Mimic mimicking a mace.
.
103a
I guess you have never hit a postman with an Amulet of Yendor yet...
.
102a
Hungry? Wear an amulet!
.
100a
Humans use walking canes when they grow old.
Hunger is a confusing experience for a dog!
.
99a
Hissing is a sound I hate.
.
97a
Handle your flasks carefully - there might be a ghost inside!
.
93a
Gold is a heavy metal.
.
92a
Ghosts always empty the fridge.
Ghosts are visible because they don't leave a trace.
Giant beetles make giant holes in giant trees!
.
81a
Expensive cameras have penetrating flashlights.
.
80a
Every level contains a shop; only the entrance is often hidden.
.
78a
Ever wondered why one would want to dip something in a potion?
.
76a
Ever fought with an enchanted tooth?
Ever heard hissing outside? I *knew* you hadn't!
Ever seen a leocrotta dancing the tengu?
Ever slept in the arms of a homunculus?
Ever tamed a shopkeeper?
Ever tried digging through a Vault Guard?
Ever tried enchanting a rope?
.
73a
Eels hide under mud. Use a unicorn to clear the water and make them visible.
Elven cloaks cannot rust.
.
72a
Eating a Wraith is a rewarding experience!
Eating a freezing sphere is like eating a yeti.
Eating a killer bee is like eating a scorpion.
Eating a tengu is like eating a Nymph.
.
64a
Don't play hack at your work, your boss might hit you!
Don't swim with weapons or armour: they might rust!
.
63a
Don't eat too much: you might start hiccoughing!
.
61a
Dogs of ghosts aren't angry, just hungry.
.
59a
Dogs are attracted by the smell of tripe.
.
56a
Did you know worms had teeth?
Didn't you forget to pay?
Didn't you forget to pay?
.
52a
Dark gems are just coloured glass.
Dark room? Just flash often with your camera.
Dark room? Your chance to develop your photographs!
Dark rooms are not *completely* dark: just wait and let your eyes adjust...
.
50a
Changing your suit without dropping your sword? You must be kidding!
.
49c
Booksellers never read scrolls; it might carry them too far away.
.
45a
Beware: there's always a chance that your wand explodes as you try to zap it!
.
35a
Be nice to a nurse: put away your weapon and take off your clothes.
Being digested is a painfully slow process.
.
34c
Be careful when the moon is in its last quarter.
.
31a
Attacking an eel when there is none usually is a fatal mistake!
Balrogs only appear on the deeper levels.
.
29a
Are you blind? Catch a floating Eye!
.
28a
An ettin is hard to kill; an imp is hard to hit. See the difference?
.
26a
An Umber hulk can be a confusing sight.
.
25a
Always read the info about a monster before dealing with it.
Always sweep the floor before engraving important messages.
.
24a
Always attack a floating Eye from behind!
.
23a
After being attacked by a Harpy you have a lot of arrows.
.
22c
Afraid of Mimics? Try to wear a ring of true seeing.
.
20a
A winner never quits. A quitter never wins.
A xan is a small animal. It doesn't reach higher than your leg.
Acid blobs should be attacked bare-handed.
.
19a
A wand of deaf is a more dangerous weapon than a wand of sheep.
.
14a
A staff may recharge if you drop it for awhile.
.
11a
A scroll of enchant amulet is only useful on your way back.
.
10a
A ring of conflict is a bad thing if there is a nurse in the room.
A ring of extra ringfinger is useless if not enchanted.
A ring of stealth can be recognised by that it does not teleport you.
A rope may form a trail in a maze.
.
9a
A potion of blindness makes you see invisible things.
A ring is just a wound wand.
.
7a
A magic vomit pump is a necessity for gourmands.
.
6a
A jaguar shouldn't frighten you.
A long worm can be defined recursively. So how should you attack it?
.
2a
A dragon is just a Snake that ate a scroll of fire.
.
1a
"So when I die, the first thing I will see in Heaven is a score list?"
-- more --
...and rings may protect your fingers.
...and sometimes a piercer drops by.
A Quasit is even faster than a jaguar!
A chameleon imitating a postman often delivers scrolls of fire.
A chameleon imitating a postman sometimes delivers scrolls of punishment.
A clove of garlic a day keeps your best friends away.
A cockatrice's corpse is guaranteed to be untainted!
A confused acid blob may attack.
.
w
q
-*-END-*-
echo Done.
echo Now edit config.h and Makefile and say "make".
