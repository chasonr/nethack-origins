Path: utzoo!utgpu!news-server.csri.toronto.edu!mailrus!iuvax!cica!tut.cis.ohio-state.edu!cs.utexas.edu!uunet!zephyr.ens.tek.com!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v10i026:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Patch8h
Message-ID: <5734@tekred.CNA.TEK.COM>
Date: 5 Jun 90 17:54:37 GMT
Sender: news@tekred.CNA.TEK.COM
Lines: 2209
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 10, Issue 26
Archive-name: NetHack3/Patch8h
Patch-To: NetHack3: Volume 7, Issue 56-93



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 8 (of 24)."
# Contents:  patch8.04
# Wrapped by billr@saab on Tue Jun  5 09:07:10 1990
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'patch8.04' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'patch8.04'\"
else
echo shar: Extracting \"'patch8.04'\" \(53751 characters\)
sed "s/^X//" >'patch8.04' <<'END_OF_FILE'
X*** src/Old/makemon.c	Sun Jun  3 13:29:39 1990
X--- src/makemon.c	Thu May 31 22:11:01 1990
X***************
X*** 7,21 ****
X  # include <ctype.h>
X  #endif
X  
X! VSTATIC struct monst zeromonst;
X  
X  static int FDECL(uncommon, (struct permonst *));
X! OSTATIC void FDECL(m_initgrp,(struct monst *,int,int,int));
X! static void FDECL(m_initthrow,(struct monst *,int,int));
X! OSTATIC void FDECL(m_initweap,(struct monst *));
X  static void FDECL(m_initinv,(struct monst *));
X- static void FDECL(rloc_to,(struct monst *,int,int));
X  static int FDECL(mstrength,(struct permonst *));
X  
X  extern int monstr[];
X  
X--- 7,26 ----
X  # include <ctype.h>
X  #endif
X  
X! STATIC_VAR struct monst NEARDATA zeromonst;
X  
X+ #ifdef OVL0
X+ static int NDECL(cmnum);
X  static int FDECL(uncommon, (struct permonst *));
X! #endif /* OVL0 */
X! STATIC_DCL void FDECL(m_initgrp,(struct monst *,int,int,int));
X! STATIC_DCL void FDECL(m_initthrow,(struct monst *,int,int));
X! STATIC_DCL void FDECL(m_initweap,(struct monst *));
X! STATIC_DCL void FDECL(rloc_to,(struct monst *,int,int));
X! #ifdef OVL1
X  static void FDECL(m_initinv,(struct monst *));
X  static int FDECL(mstrength,(struct permonst *));
X+ #endif /* OVL1 */
X  
X  extern int monstr[];
X  
X***************
X*** 32,38 ****
X  
X  #ifdef OVLB
X  
X! XSTATIC void
X  m_initgrp(mtmp, x, y, n)	/* make a group just like mtmp */
X  register struct monst *mtmp;
X  register int x, y, n;
X--- 37,43 ----
X  
X  #ifdef OVLB
X  
X! STATIC_OVL void
X  m_initgrp(mtmp, x, y, n)	/* make a group just like mtmp */
X  register struct monst *mtmp;
X  register int x, y, n;
X***************
X*** 57,75 ****
X  		 * are peaceful and some are not, the result will just be a
X  		 * smaller group.
X  		 */
X! 		enexto(&mm, mm.x, mm.y, mtmp->data);
X! 		mon = makemon(mtmp->data, mm.x, mm.y);
X! 		mon->mpeaceful = 0;
X! 		set_malign(mon);
X! 		/* Undo the second peace_minded() check in makemon(); if the
X! 		 * monster turned out to be peaceful the first time we didn't
X! 		 * create it at all; we don't want a second check.
X! 		 */
X  	}
X  }
X  
X! 
X! static void
X  m_initthrow(mtmp,otyp,oquan)
X  struct monst *mtmp;
X  int otyp,oquan;
X--- 62,81 ----
X  		 * are peaceful and some are not, the result will just be a
X  		 * smaller group.
X  		 */
X! 		if (enexto(&mm, mm.x, mm.y, mtmp->data)) {
X! 		    mon = makemon(mtmp->data, mm.x, mm.y);
X! 		    mon->mpeaceful = 0;
X! 		    set_malign(mon);
X! 		    /* Undo the second peace_minded() check in makemon(); if the
X! 		     * monster turned out to be peaceful the first time we
X! 		     * didn't create it at all; we don't want a second check.
X! 		     */
X! 		}
X  	}
X  }
X  
X! STATIC_OVL
X! void
X  m_initthrow(mtmp,otyp,oquan)
X  struct monst *mtmp;
X  int otyp,oquan;
X***************
X*** 85,91 ****
X  	mpickobj(mtmp, otmp);
X  }
X  
X! XSTATIC void
X  m_initweap(mtmp)
X  register struct monst *mtmp;
X  {
X--- 91,100 ----
X  	mpickobj(mtmp, otmp);
X  }
X  
X! #endif /* OVLB */
X! #ifdef OVL2
X! 
X! STATIC_OVL void
X  m_initweap(mtmp)
X  register struct monst *mtmp;
X  {
X***************
X*** 360,366 ****
X  	}
X  }
X  
X! #endif /* OVLB */
X  #ifdef OVL1
X  
X  static void
X--- 369,375 ----
X  	}
X  }
X  
X! #endif /* OVL2 */
X  #ifdef OVL1
X  
X  static void
X***************
X*** 460,466 ****
X  /*
X   * called with [x,y] = coordinates;
X   *	[0,0] means anyplace
X!  *	[u.ux,u.uy] means: call mnexto (if !in_mklev)
X   *
X   *	In case we make a monster group, only return the one at [x,y].
X   */
X--- 469,475 ----
X  /*
X   * called with [x,y] = coordinates;
X   *	[0,0] means anyplace
X!  *	[u.ux,u.uy] means: near player (if !in_mklev)
X   *
X   *	In case we make a monster group, only return the one at [x,y].
X   */
X***************
X*** 472,477 ****
X--- 481,487 ----
X  	register struct monst *mtmp;
X  	register int	ct;
X  	boolean anything = (!ptr);
X+ 	boolean byyou = (x == u.ux && y == u.uy);
X  
X  	/* if caller wants random location, do it here */
X  	if(x == 0 && y == 0) {
X***************
X*** 487,492 ****
X--- 497,510 ----
X  			y = rn2(ROWNO);
X  		} while(!goodpos(x, y, ptr) ||
X  			(!in_mklev && tryct++ < 50 && inroom(x, y) == uroom));
X+ 	} else if (byyou && !in_mklev) {
X+ 		coord bypos;
X+ 
X+ 		if(enexto(&bypos, u.ux, u.uy, ptr)) {
X+ 			x = bypos.x;
X+ 			y = bypos.y;
X+ 		} else
X+ 			return((struct monst *)0);
X  	}
X  
X  	/* if a monster already exists at the position, return */
X***************
X*** 508,514 ****
X  		}
X  	}
X  	/* if it's unique, don't ever make it again */
X! 	if (ptr->geno & G_UNIQ) ptr->geno &= G_GENOD;
X  /* gotmon:	/* label not referenced */
X  	mtmp = newmonst(ptr->pxlth);
X  	*mtmp = zeromonst;		/* clear all entries in structure */
X--- 526,532 ----
X  		}
X  	}
X  	/* if it's unique, don't ever make it again */
X! 	if (ptr->geno & G_UNIQ) ptr->geno |= G_GENOD;
X  /* gotmon:	/* label not referenced */
X  	mtmp = newmonst(ptr->pxlth);
X  	*mtmp = zeromonst;		/* clear all entries in structure */
X***************
X*** 550,556 ****
X  			mtmp->mhide = 1;
X  			if(in_mklev)
X  			    if(x && y)
X! 				(void) mkobj_at(0, x, y);
X  			if(OBJ_AT(x, y) || levl[x][y].gmask)
X  			    mtmp->mundetected = 1;
X  			break;
X--- 568,574 ----
X  			mtmp->mhide = 1;
X  			if(in_mklev)
X  			    if(x && y)
X! 				(void) mkobj_at(0, x, y, TRUE);
X  			if(OBJ_AT(x, y) || levl[x][y].gmask)
X  			    mtmp->mundetected = 1;
X  			break;
X***************
X*** 600,612 ****
X  		    (ptr == &mons[PM_GIANT_EEL])) && rn2(5))
X  			mtmp->msleep = 1;
X  	} else {
X! 		if(x == u.ux && y == u.uy) {
X! 			mnexto(mtmp);
X! 			if (ptr->mlet == S_MIMIC) {
X! 				set_mimic_sym(mtmp);
X! 				unpmon(mtmp);
X! 				pmon(mtmp);
X! 			}
X  		}
X  	}
X  #ifdef INFERNO
X--- 618,626 ----
X  		    (ptr == &mons[PM_GIANT_EEL])) && rn2(5))
X  			mtmp->msleep = 1;
X  	} else {
X! 		if(byyou) {
X! 			pmon(mtmp);
X! 			set_apparxy(mtmp);
X  		}
X  	}
X  #ifdef INFERNO
X***************
X*** 639,645 ****
X  	return(mtmp);
X  }
X  
X! void
X  enexto(cc, xx, yy, mdat)
X  coord *cc;
X  register xchar xx, yy;
X--- 653,659 ----
X  	return(mtmp);
X  }
X  
X! boolean
X  enexto(cc, xx, yy, mdat)
X  coord *cc;
X  register xchar xx, yy;
X***************
X*** 648,688 ****
X  	register xchar x,y;
X  	coord foo[15], *tfoo;
X  	int range, i;
X  
X  	tfoo = foo;
X  	range = 1;
X  	do {	/* full kludge action. */
X! 		for(x = xx-range; x <= xx+range; x++)
X! 			if(goodpos(x, yy-range, mdat)) {
X  				tfoo->x = x;
X! 				(tfoo++)->y = yy-range;
X  				if(tfoo == &foo[15]) goto foofull;
X  			}
X! 		for(x = xx-range; x <= xx+range; x++)
X! 			if(goodpos(x, yy+range, mdat)) {
X  				tfoo->x = x;
X! 				(tfoo++)->y = yy+range;
X  				if(tfoo == &foo[15]) goto foofull;
X  			}
X! 		for(y = yy+1-range; y < yy+range; y++)
X! 			if(goodpos(xx-range, y, mdat)) {
X! 				tfoo->x = xx-range;
X  				(tfoo++)->y = y;
X  				if(tfoo == &foo[15]) goto foofull;
X  			}
X! 		for(y = yy+1-range; y < yy+range; y++)
X! 			if(goodpos(xx+range, y, mdat)) {
X! 				tfoo->x = xx+range;
X  				(tfoo++)->y = y;
X  				if(tfoo == &foo[15]) goto foofull;
X  			}
X  		range++;
X  	} while(tfoo == foo);
X  foofull:
X  	i = rn2((int)(tfoo - foo));
X  	cc->x = foo[i].x;
X  	cc->y = foo[i].y;
X! 	return;
X  }
X  
X  int
X--- 662,709 ----
X  	register xchar x,y;
X  	coord foo[15], *tfoo;
X  	int range, i;
X+ 	int xmin, xmax, ymin, ymax;
X  
X  	tfoo = foo;
X  	range = 1;
X  	do {	/* full kludge action. */
X! 		xmin = max(0, xx-range);
X! 		xmax = min(COLNO, xx+range);
X! 		ymin = max(0, yy-range);
X! 		ymax = min(ROWNO, yy+range);
X! 
X! 		for(x = xmin; x <= xmax; x++)
X! 			if(goodpos(x, ymin, mdat)) {
X  				tfoo->x = x;
X! 				(tfoo++)->y = ymin;
X  				if(tfoo == &foo[15]) goto foofull;
X  			}
X! 		for(x = xmin; x <= xmax; x++)
X! 			if(goodpos(x, ymax, mdat)) {
X  				tfoo->x = x;
X! 				(tfoo++)->y = ymax;
X  				if(tfoo == &foo[15]) goto foofull;
X  			}
X! 		for(y = ymin+1; y < ymax; y++)
X! 			if(goodpos(xmin, y, mdat)) {
X! 				tfoo->x = xmin;
X  				(tfoo++)->y = y;
X  				if(tfoo == &foo[15]) goto foofull;
X  			}
X! 		for(y = ymin+1; y < ymax; y++)
X! 			if(goodpos(xmax, y, mdat)) {
X! 				tfoo->x = xmax;
X  				(tfoo++)->y = y;
X  				if(tfoo == &foo[15]) goto foofull;
X  			}
X  		range++;
X+ 		if(range > ROWNO && range > COLNO) return FALSE;
X  	} while(tfoo == foo);
X  foofull:
X  	i = rn2((int)(tfoo - foo));
X  	cc->x = foo[i].x;
X  	cc->y = foo[i].y;
X! 	return TRUE;
X  }
X  
X  int
X***************
X*** 710,716 ****
X  #endif /* OVL1 */
X  #ifdef OVLB
X  
X! static void
X  rloc_to(mtmp, x, y)
X  struct monst *mtmp;
X  register int x,y;
X--- 731,738 ----
X  #endif /* OVL1 */
X  #ifdef OVLB
X  
X! STATIC_OVL
X! void
X  rloc_to(mtmp, x, y)
X  struct monst *mtmp;
X  register int x,y;
X***************
X*** 732,737 ****
X--- 754,762 ----
X  	set_apparxy(mtmp);
X  }
X  
X+ #endif /* OVLB */
X+ #ifdef OVL2
X+ 
X  void
X  rloc(mtmp)
X  struct monst *mtmp;
X***************
X*** 748,753 ****
X--- 773,781 ----
X  	rloc_to(mtmp, x, y);
X  }
X  
X+ #endif /* OVL2 */
X+ #ifdef OVLB
X+ 
X  void
X  vloc(mtmp)
X  struct monst *mtmp;
X***************
X*** 870,879 ****
X  	register struct permonst *ptr;
X  	register int i, ct;
X  	register int zlevel;
X! 	static int minmlev, maxmlev, accept;
X! 	static long oldmoves = 0L;	/* != 1, starting value of moves */
X  #ifdef REINCARNATION
X! 	static boolean upper;
X  
X  	upper = (dlevel == rogue_level);
X  #endif
X--- 898,907 ----
X  	register struct permonst *ptr;
X  	register int i, ct;
X  	register int zlevel;
X! 	static int NEARDATA minmlev, NEARDATA maxmlev, NEARDATA accept;
X! 	static long NEARDATA oldmoves = 0L;	/* != 1, starting value of moves */
X  #ifdef REINCARNATION
X! 	static boolean NEARDATA upper;
X  
X  	upper = (dlevel == rogue_level);
X  #endif
X***************
X*** 1019,1025 ****
X  	if (ptr->mlevel >= 50 || mtmp->mhpmax <= 8*mtmp->m_lev)
X  	    return ptr;
X  	newtype = little_to_big(monsndx(ptr));
X! 	if (++mtmp->m_lev >= mons[newtype].mlevel) {
X  		if (mons[newtype].geno & G_GENOD) {
X  			pline("As %s grows up into %s, %s dies!",
X  				mon_nam(mtmp),
X--- 1047,1054 ----
X  	if (ptr->mlevel >= 50 || mtmp->mhpmax <= 8*mtmp->m_lev)
X  	    return ptr;
X  	newtype = little_to_big(monsndx(ptr));
X! 	if (++mtmp->m_lev >= mons[newtype].mlevel
X! 					&& newtype != monsndx(ptr)) {
X  		if (mons[newtype].geno & G_GENOD) {
X  			pline("As %s grows up into %s, %s dies!",
X  				mon_nam(mtmp),
X***************
X*** 1033,1038 ****
X--- 1062,1069 ----
X  	}
X  	if (mtmp->m_lev > 3*mtmp->data->mlevel / 2)
X  		mtmp->m_lev = 3*mtmp->data->mlevel / 2;
X+ 	if (mtmp->mhp > mtmp->m_lev * 8)
X+ 		mtmp->mhp = mtmp->m_lev * 8;
X  	return(mtmp->data);
X  }
X  
X***************
X*** 1145,1151 ****
X  #endif /* OVL1 */
X  #ifdef OVLB
X  
X! static char syms[] = { 0, 1, RING_SYM, WAND_SYM, WEAPON_SYM, FOOD_SYM, GOLD_SYM,
X  	SCROLL_SYM, POTION_SYM, ARMOR_SYM, AMULET_SYM, TOOL_SYM, ROCK_SYM,
X  	GEM_SYM,
X  #ifdef SPELLS
X--- 1176,1182 ----
X  #endif /* OVL1 */
X  #ifdef OVLB
X  
X! static char NEARDATA syms[] = { 0, 1, RING_SYM, WAND_SYM, WEAPON_SYM, FOOD_SYM, GOLD_SYM,
X  	SCROLL_SYM, POTION_SYM, ARMOR_SYM, AMULET_SYM, TOOL_SYM, ROCK_SYM,
X  	GEM_SYM,
X  #ifdef SPELLS
X*** src/Old/mhitm.c	Sun Jun  3 13:30:42 1990
X--- src/mhitm.c	Thu May 31 22:11:05 1990
X***************
X*** 9,20 ****
X  
X  #ifdef OVLB
X  
X! static boolean vis, far_noise;
X! static long noisetime;
X! static struct obj *otmp;
X  
X- #endif /* OVLB */
X- 
X  static void FDECL(mrustm, (struct monst *, struct monst *, struct obj *));
X  static int FDECL(hitmm, (struct monst *,struct monst *,struct attack *));
X  static int FDECL(gazemm, (struct monst *,struct monst *,struct attack *));
X--- 9,18 ----
X  
X  #ifdef OVLB
X  
X! static boolean NEARDATA vis, NEARDATA far_noise;
X! static long NEARDATA noisetime;
X! static struct obj NEARDATA *otmp;
X  
X  static void FDECL(mrustm, (struct monst *, struct monst *, struct obj *));
X  static int FDECL(hitmm, (struct monst *,struct monst *,struct attack *));
X  static int FDECL(gazemm, (struct monst *,struct monst *,struct attack *));
X***************
X*** 25,32 ****
X  static void FDECL(noises,(struct monst *,struct attack *));
X  static void FDECL(missmm,(struct monst *,struct monst *,struct attack *));
X  
X- #ifdef OVLB
X- 
X  static void
X  noises(magr, mattk)
X  	register struct monst *magr;
X--- 23,28 ----
X***************
X*** 391,411 ****
X  		    tmp = 0;
X  		    break;
X  		}
X- #ifdef GOLEMS
X- 		golemeffects(mdef, AD_FIRE, tmp);
X- #endif /* GOLEMS */
X  		if(vis) pline("%s is on fire!", Monnam(mdef));
X  		if(resists_fire(pd)) {
X  		    pline("The fire doesn't seem to burn %s!", mon_nam(mdef));
X  		    shieldeff(mdef->mx, mdef->my);
X  		    tmp = 0;
X- 		} else {
X- 		    tmp += destroy_mitem(mdef, SCROLL_SYM, AD_FIRE);
X- 		    tmp += destroy_mitem(mdef, POTION_SYM, AD_FIRE);
X- #ifdef SPELLS
X- 		    tmp += destroy_mitem(mdef, SPBOOK_SYM, AD_FIRE);
X- #endif
X  		}
X  		break;
X  	    case AD_COLD:
X  		if (magr->mcan) {
X--- 387,407 ----
X  		    tmp = 0;
X  		    break;
X  		}
X  		if(vis) pline("%s is on fire!", Monnam(mdef));
X+ 		tmp += destroy_mitem(mdef, SCROLL_SYM, AD_FIRE);
X+ #ifdef SPELLS
X+ 		tmp += destroy_mitem(mdef, SPBOOK_SYM, AD_FIRE);
X+ #endif
X  		if(resists_fire(pd)) {
X  		    pline("The fire doesn't seem to burn %s!", mon_nam(mdef));
X  		    shieldeff(mdef->mx, mdef->my);
X+ #ifdef GOLEMS
X+ 		    golemeffects(mdef, AD_FIRE, tmp);
X+ #endif /* GOLEMS */
X  		    tmp = 0;
X  		}
X+ 		/* only potions damage resistant players in destroy_item */
X+ 		tmp += destroy_mitem(mdef, POTION_SYM, AD_FIRE);
X  		break;
X  	    case AD_COLD:
X  		if (magr->mcan) {
X***************
X*** 412,427 ****
X  		    tmp = 0;
X  		    break;
X  		}
X- #ifdef GOLEMS
X- 		golemeffects(mdef, AD_COLD, tmp);
X- #endif /* GOLEMS */
X  		if(vis) pline("%s is covered in frost!", Monnam(mdef));
X  		if(resists_cold(pd)) {
X  		    pline("The frost doesn't seem to chill %s!",
X  			mon_nam(mdef));
X  		    shieldeff(mdef->mx, mdef->my);
X  		    tmp = 0;
X! 		} else tmp += destroy_mitem(mdef, POTION_SYM, AD_COLD);
X  		break;
X  	    case AD_ELEC:
X  		if (magr->mcan) {
X--- 408,424 ----
X  		    tmp = 0;
X  		    break;
X  		}
X  		if(vis) pline("%s is covered in frost!", Monnam(mdef));
X  		if(resists_cold(pd)) {
X  		    pline("The frost doesn't seem to chill %s!",
X  			mon_nam(mdef));
X  		    shieldeff(mdef->mx, mdef->my);
X+ #ifdef GOLEMS
X+ 		    golemeffects(mdef, AD_COLD, tmp);
X+ #endif /* GOLEMS */
X  		    tmp = 0;
X! 		}
X! 		tmp += destroy_mitem(mdef, POTION_SYM, AD_COLD);
X  		break;
X  	    case AD_ELEC:
X  		if (magr->mcan) {
X***************
X*** 428,442 ****
X  		    tmp = 0;
X  		    break;
X  		}
X- #ifdef GOLEMS
X- 		golemeffects(mdef, AD_ELEC, tmp);
X- #endif /* GOLEMS */
X  		if(vis) pline("%s gets zapped!", Monnam(mdef));
X  		if(resists_elec(pd)) {
X  		    pline("The zap doesn't shock %s!", mon_nam(mdef));
X  		    shieldeff(mdef->mx, mdef->my);
X  		    tmp = 0;
X  		}
X  		break;
X  	    case AD_ACID:
X  		if (magr->mcan) {
X--- 425,442 ----
X  		    tmp = 0;
X  		    break;
X  		}
X  		if(vis) pline("%s gets zapped!", Monnam(mdef));
X+ 		tmp += destroy_mitem(mdef, WAND_SYM, AD_ELEC);
X  		if(resists_elec(pd)) {
X  		    pline("The zap doesn't shock %s!", mon_nam(mdef));
X  		    shieldeff(mdef->mx, mdef->my);
X+ #ifdef GOLEMS
X+ 		    golemeffects(mdef, AD_ELEC, tmp);
X+ #endif /* GOLEMS */
X  		    tmp = 0;
X  		}
X+ 		/* only rings damage resistant players in destroy_item */
X+ 		tmp += destroy_mitem(mdef, RING_SYM, AD_ELEC);
X  		break;
X  	    case AD_ACID:
X  		if (magr->mcan) {
X***************
X*** 459,465 ****
X  			else if(mdef->mtame)
X  			     pline("May %s rust in peace.", mon_nam(mdef));
X  			mondied(mdef);
X! 			magr->mhpmax += 1 + rn2((int)mdef->m_lev+1);
X  			ptr = grow_up(magr);
X  			if(!ptr) return(-1);
X  			return(2);
X--- 459,466 ----
X  			else if(mdef->mtame)
X  			     pline("May %s rust in peace.", mon_nam(mdef));
X  			mondied(mdef);
X! 			magr->mhpmax = magr->mhpmax +
X!                                             (1 + rn2((int)mdef->m_lev+1));
X  			ptr = grow_up(magr);
X  			if(!ptr) return(-1);
X  			return(2);
X***************
X*** 475,481 ****
X  			else if(mdef->mtame)
X  			     pline("May %s rot in peace.", mon_nam(mdef));
X  			mondied(mdef);
X! 			magr->mhpmax += 1 + rn2((int)mdef->m_lev+1);
X  			ptr = grow_up(magr);
X  			if(!ptr) return(-1);
X  			return(2);
X--- 476,483 ----
X  			else if(mdef->mtame)
X  			     pline("May %s rot in peace.", mon_nam(mdef));
X  			mondied(mdef);
X! 			magr->mhpmax = magr->mhpmax +
X! 			                       (1 + rn2((int)mdef->m_lev+1));
X  			ptr = grow_up(magr);
X  			if(!ptr) return(-1);
X  			return(2);
X***************
X*** 485,491 ****
X  		break;
X  	    case AD_STON:
X  		if(!resists_ston(pd)) {
X! 			magr->mhpmax += 1 + rn2((int)mdef->m_lev+1);
X  			if(vis) pline("%s turns to stone!", Monnam(mdef));
X  			else if(mdef->mtame) You(psf);
X  			monstone(mdef);
X--- 487,494 ----
X  		break;
X  	    case AD_STON:
X  		if(!resists_ston(pd)) {
X! 			magr->mhpmax = magr->mhpmax +
X!                                               (1 + rn2((int)mdef->m_lev+1));
X  			if(vis) pline("%s turns to stone!", Monnam(mdef));
X  			else if(mdef->mtame) You(psf);
X  			monstone(mdef);
X***************
X*** 571,577 ****
X  			    else if (mdef->mtame)
X  	You("have a strangely sad feeling for a moment, then it passes.");
X  			    mondied(mdef);
X! 			    magr->mhpmax += 1 + rn2((int)mdef->m_lev+1);
X  			    ptr = grow_up(magr);
X  			    if(!ptr) return(-1);
X  			    return(2);
X--- 574,581 ----
X  			    else if (mdef->mtame)
X  	You("have a strangely sad feeling for a moment, then it passes.");
X  			    mondied(mdef);
X! 			    magr->mhpmax = magr->mhpmax +
X! 					          (1 + rn2((int)mdef->m_lev+1));
X  			    ptr = grow_up(magr);
X  			    if(!ptr) return(-1);
X  			    return(2);
X***************
X*** 657,663 ****
X  	if(!tmp) return(1);
X  
X  	if((mdef->mhp -= tmp) < 1) {
X! 	    magr->mhpmax += 1 + rn2((int)mdef->m_lev+1);
X  	    if(vis)
X  		pline("%s is %s!", Monnam(mdef),
X  			(is_demon(mdef->data) || is_undead(mdef->data)) ?
X--- 661,667 ----
X  	if(!tmp) return(1);
X  
X  	if((mdef->mhp -= tmp) < 1) {
X! 	    magr->mhpmax = magr->mhpmax + (1 + rn2((int)mdef->m_lev+1));
X  	    if(vis)
X  		pline("%s is %s!", Monnam(mdef),
X  			(is_demon(mdef->data) || is_undead(mdef->data)) ?
X***************
X*** 669,677 ****
X  	    if(!ptr) return(-1);
X  	    return(2);
X  	}
X- 	/* fixes a bug where max monster hp could overflow. */
X- 	if(magr->mhpmax <= 0 || magr->mhpmax > MHPMAX) magr->mhpmax = MHPMAX;
X- 
X  	return(1);
X  }
X  
X--- 673,678 ----
X*** src/Old/mhitu.c	Sun Jun  3 13:31:19 1990
X--- src/mhitu.c	Thu May 31 22:11:59 1990
X***************
X*** 7,34 ****
X  #  include "artifact.h"
X  #endif
X  
X! VSTATIC struct obj *otmp;
X  
X  #ifdef POLYSELF
X! OSTATIC void FDECL(urustm, (struct monst *, struct obj *));
X  static int FDECL(passiveum, (struct permonst *,struct monst *,struct attack *));
X! #endif
X! #ifdef SEDUCE
X  static void FDECL(mayberem, (struct obj *, const char *));
X! #endif
X! OSTATIC int FDECL(hitmu, (struct monst *,struct attack *));
X! OSTATIC int FDECL(gulpmu, (struct monst *,struct attack *));
X! OSTATIC int FDECL(explmu, (struct monst *,struct attack *));
X! OSTATIC int FDECL(gazemu, (struct monst *,struct attack *));
X! static void FDECL(hitmsg,(struct monst *,struct attack *));
X! OSTATIC void FDECL(missmu,(struct monst *,BOOLEAN_P,struct attack *));
X! OSTATIC void FDECL(mswings,(struct monst *,struct obj *));
X! OSTATIC void FDECL(wildmiss,(struct monst *));
X  
X! OSTATIC void FDECL(hurtarmor,(struct permonst *,int));
X  
X  #ifdef OVL1
X  
X  static void
X  hitmsg(mtmp, mattk)
X  register struct monst *mtmp;
X--- 7,41 ----
X  #  include "artifact.h"
X  #endif
X  
X! STATIC_VAR struct obj NEARDATA *otmp;
X  
X  #ifdef POLYSELF
X! STATIC_DCL void FDECL(urustm, (struct monst *, struct obj *));
X! # ifdef OVL1
X  static int FDECL(passiveum, (struct permonst *,struct monst *,struct attack *));
X! # endif /* OVL1 */
X! #endif /* POLYSELF */
X! 
X! #ifdef OVLB
X! # ifdef SEDUCE
X  static void FDECL(mayberem, (struct obj *, const char *));
X! # endif
X! #endif /* OVLB */
X  
X! STATIC_DCL int FDECL(hitmu, (struct monst *,struct attack *));
X! STATIC_DCL int FDECL(gulpmu, (struct monst *,struct attack *));
X! STATIC_DCL int FDECL(explmu, (struct monst *,struct attack *));
X! STATIC_DCL int FDECL(gazemu, (struct monst *,struct attack *));
X! STATIC_DCL void FDECL(missmu,(struct monst *,BOOLEAN_P,struct attack *));
X! STATIC_DCL void FDECL(mswings,(struct monst *,struct obj *));
X! STATIC_DCL void FDECL(wildmiss,(struct monst *));
X  
X+ STATIC_DCL void FDECL(hurtarmor,(struct permonst *,int));
X+ 
X  #ifdef OVL1
X  
X+ static void FDECL(hitmsg,(struct monst *,struct attack *));
X+ 
X  static void
X  hitmsg(mtmp, mattk)
X  register struct monst *mtmp;
X***************
X*** 69,78 ****
X  	    }
X  }
X  
X! #endif /* OVL1 */
X! #ifdef OVLB
X! 
X! XSTATIC void
X  missmu(mtmp, nearmiss, mattk)		/* monster missed you */
X  register struct monst *mtmp;
X  register boolean nearmiss;
X--- 76,82 ----
X  	    }
X  }
X  
X! STATIC_OVL void
X  missmu(mtmp, nearmiss, mattk)		/* monster missed you */
X  register struct monst *mtmp;
X  register boolean nearmiss;
X***************
X*** 88,94 ****
X  	}
X  }
X  
X! XSTATIC void
X  mswings(mtmp, otemp)		/* monster swings obj */
X  register struct monst *mtmp;
X  register struct obj *otemp;
X--- 92,98 ----
X  	}
X  }
X  
X! STATIC_OVL void
X  mswings(mtmp, otemp)		/* monster swings obj */
X  register struct monst *mtmp;
X  register struct obj *otemp;
X***************
X*** 105,111 ****
X  	      xname(otemp));
X  }
X  
X! XSTATIC void
X  wildmiss(mtmp)		/* monster attacked your displaced image */
X  	register struct monst *mtmp;
X  {
X--- 109,118 ----
X  	      xname(otemp));
X  }
X  
X! #endif /* OVL1 */
X! #ifdef OVLB
X! 
X! STATIC_OVL void
X  wildmiss(mtmp)		/* monster attacked your displaced image */
X  	register struct monst *mtmp;
X  {
X***************
X*** 271,277 ****
X  		    remove_monster(mtmp->mx, mtmp->my);
X  		    place_monster(mtmp, u.ux, u.uy);
X  		    pmon(mtmp);
X! 		    enexto(&cc, u.ux, u.uy, &playermon);
X  		    teleds(cc.x, cc.y);
X  		    You("fall from the ceiling!");
X  		    if (is_mercenary(mtmp->data) && m_carrying(mtmp,HELMET)) {
X--- 278,284 ----
X  		    remove_monster(mtmp->mx, mtmp->my);
X  		    place_monster(mtmp, u.ux, u.uy);
X  		    pmon(mtmp);
X! 		    (void) enexto(&cc, u.ux, u.uy, &playermon);
X  		    teleds(cc.x, cc.y);
X  		    You("fall from the ceiling!");
X  		    if (is_mercenary(mtmp->data) && m_carrying(mtmp,HELMET)) {
X***************
X*** 507,513 ****
X   * helper function for some compilers that have trouble with hitmu
X   */
X  
X! XSTATIC
X  void
X  hurtarmor(mdat, attk)
X  struct permonst *mdat;
X--- 514,520 ----
X   * helper function for some compilers that have trouble with hitmu
X   */
X  
X! STATIC_OVL
X  void
X  hurtarmor(mdat, attk)
X  struct permonst *mdat;
X***************
X*** 580,586 ****
X   *	  3 if the monster lives but teleported/paralyzed, so it can't keep
X   *	       attacking you
X   */
X! XSTATIC
X  int
X  hitmu(mtmp, mattk)
X  	register struct monst *mtmp;
X--- 587,593 ----
X   *	  3 if the monster lives but teleported/paralyzed, so it can't keep
X   *	       attacking you
X   */
X! STATIC_OVL
X  int
X  hitmu(mtmp, mattk)
X  	register struct monst *mtmp;
X***************
X*** 588,593 ****
X--- 595,601 ----
X  {
X  	register struct permonst *mdat = mtmp->data;
X  	register int dmg, ctmp, ptmp;
X+ 	int armpro;
X  	char	 buf[BUFSZ];
X  #ifdef POLYSELF
X  	struct permonst *olduasmon = uasmon;
X***************
X*** 621,629 ****
X  /*	Use ctmp when the cancellation factor takes into account certain
X   *	armor's special magic protection.  Otherwise just use !mtmp->mcan.
X   */
X! 	ctmp = !mtmp->mcan &&
X! 		(!uarm || (rn2(3) >= objects[uarm->otyp].a_can) || !rn2(50))
X! 	     && (!uarmc || (rn2(3) >= objects[uarmc->otyp].a_can) || !rn2(50));
X  
X  /*	Now, adjust damages via resistances or specific attacks */
X  	switch(mattk->adtyp) {
X--- 629,640 ----
X  /*	Use ctmp when the cancellation factor takes into account certain
X   *	armor's special magic protection.  Otherwise just use !mtmp->mcan.
X   */
X! 	armpro = 0;
X! 	if (uarm && armpro < objects[uarm->otyp].a_can)
X! 		armpro = objects[uarm->otyp].a_can;
X! 	if (uarmc && armpro < objects[uarmc->otyp].a_can)
X! 		armpro = objects[uarmc->otyp].a_can;
X! 	ctmp = !mtmp->mcan && ((rn2(3) >= armpro) || !rn2(50));
X  
X  /*	Now, adjust damages via resistances or specific attacks */
X  	switch(mattk->adtyp) {
X***************
X*** 1057,1063 ****
X  	    case AD_CONF:
X  		hitmsg(mtmp, mattk);
X  		if(!mtmp->mcan && !rn2(4) && !mtmp->mspec_used) {
X! 		    mtmp->mspec_used += (dmg + rn2(6));
X  		    if(Confusion)
X  			 You("are getting even more confused.");
X  		    else You("are getting confused.");
X--- 1068,1074 ----
X  	    case AD_CONF:
X  		hitmsg(mtmp, mattk);
X  		if(!mtmp->mcan && !rn2(4) && !mtmp->mspec_used) {
X! 		    mtmp->mspec_used = mtmp->mspec_used + (dmg + rn2(6));
X  		    if(Confusion)
X  			 You("are getting even more confused.");
X  		    else You("are getting confused.");
X***************
X*** 1093,1099 ****
X  #endif /* OVL1 */
X  #ifdef OVLB
X  
X! XSTATIC
X  int
X  gulpmu(mtmp, mattk)	/* monster swallows you, or damage if u.uswallow */
X  	register struct monst *mtmp;
X--- 1104,1110 ----
X  #endif /* OVL1 */
X  #ifdef OVLB
X  
X! STATIC_OVL
X  int
X  gulpmu(mtmp, mattk)	/* monster swallows you, or damage if u.uswallow */
X  	register struct monst *mtmp;
X***************
X*** 1254,1260 ****
X  	return(1);
X  }
X  
X! XSTATIC
X  int
X  explmu(mtmp, mattk)	/* monster explodes in your face */
X  	register struct monst *mtmp;
X--- 1265,1271 ----
X  	return(1);
X  }
X  
X! STATIC_OVL
X  int
X  explmu(mtmp, mattk)	/* monster explodes in your face */
X  	register struct monst *mtmp;
X***************
X*** 1302,1308 ****
X  	return(2);	/* it dies */
X  }
X  
X! XSTATIC
X  int
X  gazemu(mtmp, mattk)	/* monster gazes at you */
X  	register struct monst *mtmp;
X--- 1313,1319 ----
X  	return(2);	/* it dies */
X  }
X  
X! STATIC_OVL
X  int
X  gazemu(mtmp, mattk)	/* monster gazes at you */
X  	register struct monst *mtmp;
X***************
X*** 1335,1341 ****
X  					!mtmp->mspec_used && rn2(5)) {
X  		    int conf = d(3,4);
X  
X! 		    mtmp->mspec_used += (conf + rn2(6));
X  		    if(!Confusion)
X  			pline("%s's gaze confuses you!", Monnam(mtmp));
X  		    else
X--- 1346,1352 ----
X  					!mtmp->mspec_used && rn2(5)) {
X  		    int conf = d(3,4);
X  
X! 		    mtmp->mspec_used = mtmp->mspec_used + (conf + rn2(6));
X  		    if(!Confusion)
X  			pline("%s's gaze confuses you!", Monnam(mtmp));
X  		    else
X***************
X*** 1350,1356 ****
X  		    int stun = d(2,6);
X  
X  		    pline("%s stares piercingly at you!", Monnam(mtmp));
X! 		    mtmp->mspec_used += (stun + rn2(6));
X  		    make_stunned(HStun + stun, TRUE);
X  		}
X  		break;
X--- 1361,1367 ----
X  		    int stun = d(2,6);
X  
X  		    pline("%s stares piercingly at you!", Monnam(mtmp));
X! 		    mtmp->mspec_used = mtmp->mspec_used + (stun + rn2(6));
X  		    make_stunned(HStun + stun, TRUE);
X  		}
X  		break;
X***************
X*** 1387,1393 ****
X  #ifdef OVLB
X  
X  #ifdef POLYSELF
X! XSTATIC void
X  urustm(mon, obj)
X  register struct monst *mon;
X  register struct obj *obj;
X--- 1398,1404 ----
X  #ifdef OVLB
X  
X  #ifdef POLYSELF
X! STATIC_OVL void
X  urustm(mon, obj)
X  register struct monst *mon;
X  register struct obj *obj;
X***************
X*** 1561,1568 ****
X  	    }
X  	}
X  
X! 	pline("%s murmurs in your ear, while helping you undress.",
X! 		Blind ? (fem ? "She" : "He") : Monnam(mon));
X  	mayberem(uarmc, "cloak");
X  	if(!uarmc)
X  		mayberem(uarm, "suit");
X--- 1572,1587 ----
X  	    }
X  	}
X  
X! 	if (!uarmc && !uarmf && !uarmg && !uarms && !uarmh
X! #ifdef SHIRT
X! 								&& !uarmu
X! #endif
X! 									)
X! 		pline("%s murmurs sweet nothings into your ear.",
X! 			Blind ? (fem ? "She" : "He") : Monnam(mon));
X! 	else
X! 		pline("%s murmurs in your ear, while helping you undress.",
X! 			Blind ? (fem ? "She" : "He") : Monnam(mon));
X  	mayberem(uarmc, "cloak");
X  	if(!uarmc)
X  		mayberem(uarm, "suit");
X***************
X*** 1674,1680 ****
X  #endif
X  	else {
X  		long cost = (long)rnd(
X! 			(int)(u.ugold > 32767L ? 32767 : u.ugold) +10) + 500;
X  
X  		if (mon->mpeaceful) {
X  			cost /= 5;
X--- 1693,1699 ----
X  #endif
X  	else {
X  		long cost = (long)rnd(
X! 			(int)(u.ugold > 32757L ? 32757 : u.ugold) +10) + 500;
X  
X  		if (mon->mpeaceful) {
X  			cost /= 5;
X*** src/Old/mklev.c	Sun Jun  3 13:32:29 1990
X--- src/mklev.c	Thu May 31 22:13:01 1990
X***************
X*** 25,31 ****
X  static void NDECL(makebigroom);
X  static void FDECL(addrsx,(int,int,int,int,BOOLEAN_P));
X  static void FDECL(addrs,(int,int,int,int));
X! static int FDECL(comp,(genericptr_t,genericptr_t));
X  static void FDECL(dosdoor,(int,int,struct mkroom *,int));
X  static void NDECL(makecorridors);
X  static void FDECL(join,(int,int));
X--- 25,31 ----
X  static void NDECL(makebigroom);
X  static void FDECL(addrsx,(int,int,int,int,BOOLEAN_P));
X  static void FDECL(addrs,(int,int,int,int));
X! STATIC_PTR int FDECL(comp,(genericptr_t,genericptr_t));
X  static void FDECL(dosdoor,(int,int,struct mkroom *,int));
X  static void NDECL(makecorridors);
X  static void FDECL(join,(int,int));
X***************
X*** 134,142 ****
X  
X  /* Args must be genericptr_t so that qsort will always be happy. */
X  
X! static int
X  comp(vx,vy)
X! genericptr_t vx, vy;
X  {
X  #ifdef LINT
X  /* lint complains about possible pointer alignment problems, but we know
X--- 134,143 ----
X  
X  /* Args must be genericptr_t so that qsort will always be happy. */
X  
X! STATIC_PTR int
X  comp(vx,vy)
X! genericptr_t vx;
X! genericptr_t vy;
X  {
X  #ifdef LINT
X  /* lint complains about possible pointer alignment problems, but we know
X***************
X*** 203,223 ****
X  	/* check area around room (and make room smaller if necessary) */
X  	for(x = lowx - xlim; x <= hix + xlim; x++) {
X  		for(y = lowy - ylim; y <= hiy + ylim; y++) {
X! 			if(levl[x][y].typ) {
X  #ifdef WIZARD
X  			    if(wizard && !secret)
X  				pline("Strange area [%d,%d] in maker().",x,y);
X  #endif
X! 				if(!rn2(3)) return(0);
X! 				if(x < lowx)
X! 					lowx = x+xlim+1;
X! 				else
X! 					hix = x-xlim-1;
X! 				if(y < lowy)
X! 					lowy = y+ylim+1;
X! 				else
X! 					hiy = y-ylim-1;
X! 				goto chk;
X  			}
X  		}
X  	}
X--- 204,224 ----
X  	/* check area around room (and make room smaller if necessary) */
X  	for(x = lowx - xlim; x <= hix + xlim; x++) {
X  		for(y = lowy - ylim; y <= hiy + ylim; y++) {
X! 			if(isok(x,y) && levl[x][y].typ) {
X  #ifdef WIZARD
X  			    if(wizard && !secret)
X  				pline("Strange area [%d,%d] in maker().",x,y);
X  #endif
X! 			    if(!rn2(3)) return(0);
X! 			    if(x < lowx)
X! 				    lowx = x+xlim+1;
X! 			    else
X! 				    hix = x-xlim-1;
X! 			    if(y < lowy)
X! 				    lowy = y+ylim+1;
X! 			    else
X! 				    hiy = y-ylim-1;
X! 			    goto chk;
X  			}
X  		}
X  	}
X***************
X*** 540,546 ****
X--- 541,554 ----
X  		if (levl[x][y].doormask != D_ISOPEN && !shdoor && !rn2(25))
X  		    levl[x][y].doormask |= D_TRAPPED;
X  	    } else
X+ #ifdef STUPID
X+ 		if (shdoor)
X+ 			levl[x][y].doormask = D_ISOPEN;
X+ 		else
X+ 			levl[x][y].doormask = D_NODOOR;
X+ #else
X  		levl[x][y].doormask = (shdoor ? D_ISOPEN : D_NODOOR);
X+ #endif
X  	    levl[x][y].scrsym = news0(x,y);
X  	} else { /* SDOOR */
X  		if(shdoor || !rn2(5))	levl[x][y].doormask = D_LOCKED;
X***************
X*** 643,649 ****
X  		    dosdoor(xx, yy, aroom, rn2(5) ? SDOOR : DOOR);
X  		else {
X  		    (void) mksobj_at(SCR_TELEPORTATION, xx, yy+dy);
X! 		    if(!rn2(3)) (void) mkobj_at(0, xx, yy+dy);
X  		}
X  	    }
X  	    return;
X--- 651,657 ----
X  		    dosdoor(xx, yy, aroom, rn2(5) ? SDOOR : DOOR);
X  		else {
X  		    (void) mksobj_at(SCR_TELEPORTATION, xx, yy+dy);
X! 		    if(!rn2(3)) (void) mkobj_at(0, xx, yy+dy, TRUE);
X  		}
X  	    }
X  	    return;
X***************
X*** 696,702 ****
X  	}
X  	n = 6 + rn2(10);
X  	while (n--)
X! 		(void) mkobj_at(0,somex(croom),somey(croom));
X  }
X  
X  static void
X--- 704,710 ----
X  	}
X  	n = 6 + rn2(10);
X  	while (n--)
X! 		(void) mkobj_at(0,somex(croom),somey(croom),TRUE);
X  }
X  
X  static void
X***************
X*** 989,995 ****
X  	skip_nonrogue:
X  #endif
X  		if(!rn2(3)) {
X! 			(void) mkobj_at(0, somex(croom), somey(croom));
X  			tryct = 0;
X  			while(!rn2(5)) {
X  				if(++tryct > 100){
X--- 997,1003 ----
X  	skip_nonrogue:
X  #endif
X  		if(!rn2(3)) {
X! 			(void) mkobj_at(0, somex(croom), somey(croom), TRUE);
X  			tryct = 0;
X  			while(!rn2(5)) {
X  				if(++tryct > 100){
X***************
X*** 996,1002 ****
X  					Printf("tryct overflow4\n");
X  					break;
X  				}
X! 				(void) mkobj_at(0, somex(croom), somey(croom));
X  			}
X  		}
X  	}
X--- 1004,1011 ----
X  					Printf("tryct overflow4\n");
X  					break;
X  				}
X! 				(void) mkobj_at(0, somex(croom), somey(croom),
X! 									TRUE);
X  			}
X  		}
X  	}
X*** src/Old/mkmaze.c	Sun Jun  3 13:33:13 1990
X--- src/mkmaze.c	Sat May 12 16:06:58 1990
X***************
X*** 121,127 ****
X  #  undef tower
X  #endif
X  
X! static const uchar tower[] = {
X  	MOAT,	  MOAT,     MOAT,     MOAT,	MOAT,	  MOAT,     MOAT,
X  	MOAT,	  MOAT,     TLCORNER, HWALL,	TRCORNER, MOAT,     MOAT,
X  	MOAT,	  TLCORNER, BRCORNER, ROOM,	BLCORNER, TRCORNER, MOAT,
X--- 121,127 ----
X  #  undef tower
X  #endif
X  
X! static const uchar NEARDATA tower[] = {
X  	MOAT,	  MOAT,     MOAT,     MOAT,	MOAT,	  MOAT,     MOAT,
X  	MOAT,	  MOAT,     TLCORNER, HWALL,	TRCORNER, MOAT,     MOAT,
X  	MOAT,	  TLCORNER, BRCORNER, ROOM,	BLCORNER, TRCORNER, MOAT,
X***************
X*** 279,285 ****
X  #endif
X  	for(x = rn1(8,11); x; x--) {
X  		mazexy(&mm);
X! 		(void) mkobj_at(rn2(2) ? GEM_SYM : 0, mm.x, mm.y);
X  	}
X  	for(x = rn1(10,2); x; x--) {
X  		mazexy(&mm);
X--- 279,285 ----
X  #endif
X  	for(x = rn1(8,11); x; x--) {
X  		mazexy(&mm);
X! 		(void) mkobj_at(rn2(2) ? GEM_SYM : 0, mm.x, mm.y, TRUE);
X  	}
X  	for(x = rn1(10,2); x; x--) {
X  		mazexy(&mm);
X*** src/Old/mkobj.c	Sun Jun  3 13:33:34 1990
X--- src/mkobj.c	Sat Jun  2 19:44:49 1990
X***************
X*** 4,10 ****
X  
X  #include "hack.h"
X  
X! static void FDECL(mkbox_cnts,(struct obj *));
X  
X  struct icp {
X      int  iprob; /* probability of an item type */
X--- 4,10 ----
X  
X  #include "hack.h"
X  
X! STATIC_DCL void FDECL(mkbox_cnts,(struct obj *));
X  
X  struct icp {
X      int  iprob; /* probability of an item type */
X***************
X*** 11,17 ****
X      char ilet;	/* item class */
X  };
X  
X! #ifdef OVLB
X  
X  const struct icp mkobjprobs[] = {
X  {10, WEAPON_SYM},
X--- 11,17 ----
X      char ilet;	/* item class */
X  };
X  
X! #ifdef OVL1
X  
X  const struct icp mkobjprobs[] = {
X  {10, WEAPON_SYM},
X***************
X*** 70,81 ****
X  { 8, RING_SYM},
X  { 4, AMULET_SYM}};
X  
X! static int mksx=0, mksy=0;
X  
X  struct obj *
X! mkobj_at(let,x,y)
X  char let;
X  int x,y;
X  {
X  	register struct obj *otmp;
X  
X--- 70,82 ----
X  { 8, RING_SYM},
X  { 4, AMULET_SYM}};
X  
X! static int NEARDATA mksx=0, NEARDATA mksy=0;
X  
X  struct obj *
X! mkobj_at(let,x,y, artif)
X  char let;
X  int x,y;
X+ boolean artif;
X  {
X  	register struct obj *otmp;
X  
X***************
X*** 84,90 ****
X  	 * to insure shop boxes are empty.
X  	 * Yes, this is a horrible kludge...
X  	 */
X! 	otmp = mkobj(let,TRUE);
X  	otmp->nobj = fobj;
X  	fobj = otmp;
X  	place_object(otmp, x, y);
X--- 85,91 ----
X  	 * to insure shop boxes are empty.
X  	 * Yes, this is a horrible kludge...
X  	 */
X! 	otmp = mkobj(let,artif);
X  	otmp->nobj = fobj;
X  	fobj = otmp;
X  	place_object(otmp, x, y);
X***************
X*** 137,143 ****
X  	return(mksobj(i, artif));
X  }
X  
X! static void
X  mkbox_cnts(box)
X  /* Note: does not check to see if it overloaded the box capacity; usually
X   * possible only with corpses in ice boxes.
X--- 138,145 ----
X  	return(mksobj(i, artif));
X  }
X  
X! STATIC_OVL
X! void
X  mkbox_cnts(box)
X  /* Note: does not check to see if it overloaded the box capacity; usually
X   * possible only with corpses in ice boxes.
X***************
X*** 202,207 ****
X--- 204,211 ----
X  	return(i);
X  }
X  
X+ #endif /* OVL1 */
X+ #ifdef OVLB
X  const char dknowns[] = { WAND_SYM, RING_SYM, POTION_SYM, SCROLL_SYM, GEM_SYM,
X  #ifdef SPELLS
X  SPBOOK_SYM,
X***************
X*** 437,442 ****
X--- 441,448 ----
X  	return;
X  }
X  
X+ #endif /* OVLB */
X+ #ifdef OVL1
X  void
X  blessorcurse(otmp, chance)
X  register struct obj *otmp;
X***************
X*** 453,458 ****
X--- 459,466 ----
X  	return;
X  }
X  
X+ #endif /* OVL1 */
X+ #ifdef OVLB
X  int
X  bcsign(otmp)
X  register struct obj *otmp;
X***************
X*** 519,524 ****
X--- 527,534 ----
X  	return;
X  }
X  
X+ #endif /* OVLB */
X+ #ifdef OVL1
X  struct obj *
X  mkcorpstat(objtype, ptr, x, y)
X  int objtype;	/* CORPSE or STATUE */
X***************
X*** 538,543 ****
X--- 548,555 ----
X  	return(otmp);
X  }
X  
X+ #endif /* OVL1 */
X+ #ifdef OVLB
X  struct obj *
X  mk_tt_object(objtype, x, y)
X  int objtype; /* CORPSE or STATUE */
X***************
X*** 609,614 ****
X--- 621,628 ----
X  }
X  #endif
X  
X+ #endif /* OVLB */
X+ #ifdef OVL1
X  
X  /*
X   * These routines maintain the single-linked lists headed in level.objects[][]
X***************
X*** 629,634 ****
X--- 643,650 ----
X      otmp->oy = y;
X  }
X  
X+ #endif /* OVL1 */
X+ #ifdef OVLB
X  void
X  remove_object(otmp)
X  register struct obj *otmp;
X*** src/Old/mkroom.c	Tue Jun  5 10:20:22 1990
X--- src/mkroom.c	Tue Jun  5 10:17:54 1990
X***************
X*** 16,21
X  /* block some unused #defines to avoid overloading some cpp's */
X  #include "hack.h"
X  
X  static void NDECL(mkshop), FDECL(mkzoo,(int)), NDECL(mkswamp);
X  #ifdef ORACLE
X  static void NDECL(mkdelphi);
X
X--- 16,24 -----
X  /* block some unused #defines to avoid overloading some cpp's */
X  #include "hack.h"
X  
X+ #ifdef OVLB
X+ static boolean FDECL(isbig, (struct mkroom *));
X+ static struct mkroom * FDECL(pick_room,(BOOLEAN_P));
X  static void NDECL(mkshop), FDECL(mkzoo,(int)), NDECL(mkswamp);
X  #ifdef ORACLE
X  static void NDECL(mkdelphi);
X***************
X*** 28,33
X  #ifdef ARMY
X  static struct permonst * NDECL(squadmon);
X  #endif
X  
X  #define sq(x) ((x)*(x))
X  
X
X--- 31,37 -----
X  #ifdef ARMY
X  static struct permonst * NDECL(squadmon);
X  #endif
X+ #endif /* OVLB */
X  
X  #define sq(x) ((x)*(x))
X  
X***************
X*** 167,173
X  }
X  
X  static struct mkroom *
X! pick_room()
X  /* pick an unused room, preferably with only one door */
X  {
X  	register struct mkroom *sroom;
X
X--- 171,178 -----
X  }
X  
X  static struct mkroom *
X! pick_room(strict)
X! register boolean strict;
X  /* pick an unused room, preferably with only one door */
X  {
X  	register struct mkroom *sroom;
X***************
X*** 179,185
X  		if(sroom->hx < 0)
X  			return (struct mkroom *)0;
X  		if(sroom->rtype != OROOM)	continue;
X! 		if(has_upstairs(sroom) || (has_dnstairs(sroom) && rn2(3)))
X  			continue;
X  		if(sroom->doorct == 1 || !rn2(5))
X  			return sroom;
X
X--- 184,191 -----
X  		if(sroom->hx < 0)
X  			return (struct mkroom *)0;
X  		if(sroom->rtype != OROOM)	continue;
X! 		if(!strict) {
X! 		    if(has_upstairs(sroom) || (has_dnstairs(sroom) && rn2(3)))
X  			continue;
X  		} else if(has_upstairs(sroom) || has_dnstairs(sroom))
X  			continue;
X***************
X*** 181,186
X  		if(sroom->rtype != OROOM)	continue;
X  		if(has_upstairs(sroom) || (has_dnstairs(sroom) && rn2(3)))
X  			continue;
X  		if(sroom->doorct == 1 || !rn2(5))
X  			return sroom;
X  	}
X
X--- 187,194 -----
X  		if(!strict) {
X  		    if(has_upstairs(sroom) || (has_dnstairs(sroom) && rn2(3)))
X  			continue;
X+ 		} else if(has_upstairs(sroom) || has_dnstairs(sroom))
X+ 			continue;
X  		if(sroom->doorct == 1 || !rn2(5))
X  			return sroom;
X  	}
X***************
X*** 196,202
X  	register int sx,sy,i;
X  	int sh, tx, ty, goldlim = 500 * dlevel;
X  
X! 	if(!(sroom = pick_room())) return;
X  
X  	sroom->rtype = type;
X  	sh = sroom->fdoor;
X
X--- 204,210 -----
X  	register int sx,sy,i;
X  	int sh, tx, ty, goldlim = 500 * dlevel;
X  
X! 	if(!(sroom = pick_room(FALSE))) return;
X  
X  	sroom->rtype = type;
X  	sh = sroom->fdoor;
X***************
X*** 332,338
X  	int dy,xx,yy;
X  
X  	if(doorindex >= DOORMAX) return;
X! 	if(!(sroom = pick_room())) return;
X  
X  	if(!place_oracle(sroom,&dy,&xx,&yy)) return;
X  
X
X--- 340,346 -----
X  	int dy,xx,yy;
X  
X  	if(doorindex >= DOORMAX) return;
X! 	if(!(sroom = pick_room(FALSE))) return;
X  
X  	if(!place_oracle(sroom,&dy,&xx,&yy)) return;
X  
X***************
X*** 373,379
X  	register struct mkroom *sroom;
X  	int sx,sy;
X  
X! 	if(!(sroom = pick_room())) return;
X  
X  	/* set up Priest and shrine */
X  	sroom->rtype = TEMPLE;
X
X--- 381,387 -----
X  	register struct mkroom *sroom;
X  	int sx,sy;
X  
X! 	if(!(sroom = pick_room(TRUE))) return;
X  
X  	/* set up Priest and shrine */
X  	sroom->rtype = TEMPLE;
X***************
X*** 396,402
X  {
X  	register int dx, dy;
X  	register struct rm *lev;
X! 	for(dx = -1; dx <= 1; dx++) for(dy = -1; dy <= 1; dy++)
X  		if(IS_DOOR((lev = &levl[sx+dx][sy+dy])->typ) ||
X  		    lev->typ == SDOOR)
X  			return(TRUE);
X
X--- 404,411 -----
X  {
X  	register int dx, dy;
X  	register struct rm *lev;
X! 	for(dx = -1; dx <= 1; dx++) for(dy = -1; dy <= 1; dy++) {
X! 		if(!isok(sx+dx, sy+dy)) continue;
X  		if(IS_DOOR((lev = &levl[sx+dx][sy+dy])->typ) ||
X  		    lev->typ == SDOOR)
X  			return(TRUE);
X***************
X*** 400,405
X  		if(IS_DOOR((lev = &levl[sx+dx][sy+dy])->typ) ||
X  		    lev->typ == SDOOR)
X  			return(TRUE);
X  	return(FALSE);
X  }
X  
X
X--- 409,415 -----
X  		if(IS_DOOR((lev = &levl[sx+dx][sy+dy])->typ) ||
X  		    lev->typ == SDOOR)
X  			return(TRUE);
X+ 	}
X  	return(FALSE);
X  }
X  
X*** src/Old/mon.c	Sun Jun  3 13:34:26 1990
X--- src/mon.c	Thu May 31 22:11:18 1990
X***************
X*** 2,13 ****
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X! /* Aztec C on amiga doesn't recognize defined() at this point! */
X  #ifndef AZTEC_C
X  #if defined(MICROPORT_BUG) || (!defined(LINT) && !defined(__STDC__))
X  #define MKROOM_H
X  #endif /* Avoid the microport bug */
X  #endif
X  
X  #include "hack.h"
X  #include "mfndpos.h"
X--- 2,17 ----
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X! /* Aztec C on amiga doesn't recognize defined() at this point!
X!    Neither does the Mac Lightspeed C v.3  compiler. If you're using
X!    precompiled headers, you don't want this either */
X  #ifndef AZTEC_C
X+ #ifndef THINK_C
X  #if defined(MICROPORT_BUG) || (!defined(LINT) && !defined(__STDC__))
X  #define MKROOM_H
X  #endif /* Avoid the microport bug */
X  #endif
X+ #endif
X  
X  #include "hack.h"
X  #include "mfndpos.h"
X***************
X*** 17,34 ****
X  #endif
X  
X  #ifdef HARD
X! OSTATIC boolean FDECL(restrap,(struct monst *));
X  #endif
X  #ifdef INFERNO
X  #  include <ctype.h>
X  #endif
X  
X! static struct obj *FDECL(make_corpse,(struct monst *));
X! OSTATIC void NDECL(dmonsfree);
X! static void FDECL(m_detach,(struct monst *));
X  
X  #ifdef OVL1
X- 
X  long lastwarntime;
X  int lastwarnlev;
X  const char *warnings[] = {
X--- 21,35 ----
X  #endif
X  
X  #ifdef HARD
X! STATIC_DCL boolean FDECL(restrap,(struct monst *));
X  #endif
X  #ifdef INFERNO
X  #  include <ctype.h>
X  #endif
X  
X! STATIC_DCL void NDECL(dmonsfree);
X  
X  #ifdef OVL1
X  long lastwarntime;
X  int lastwarnlev;
X  const char *warnings[] = {
X***************
X*** 35,41 ****
X--- 36,45 ----
X  	"white", "pink", "red", "ruby", "purple", "black" };
X  
X  #endif /* OVL1 */
X+ 
X  #ifdef OVLB
X+ static struct obj *FDECL(make_corpse,(struct monst *));
X+ static void FDECL(m_detach,(struct monst *));
X  
X  struct monst *fdmon;  /* chain of dead monsters, need not be saved */
X  		      /* otherwise used only in priest.c */
X***************
X*** 167,173 ****
X  #endif /* OVLB */
X  #ifdef OVL2
X  
X! XSTATIC void
X  dmonsfree(){
X  register struct monst *mtmp;
X  	while(mtmp = fdmon){
X--- 171,177 ----
X  #endif /* OVLB */
X  #ifdef OVL2
X  
X! STATIC_OVL void
X  dmonsfree(){
X  register struct monst *mtmp;
X  	while(mtmp = fdmon){
X***************
X*** 817,822 ****
X--- 821,829 ----
X  	}
X  #endif
X  	if(mtmp->isshk) shkdead(mtmp);
X+ 	if(mtmp->isgd) {
X+ 		if(!grddead(mtmp)) return;
X+ 	}
X  #ifdef WORM
X  	if(mtmp->wormno) wormdead(mtmp);
X  #endif
X***************
X*** 1025,1031 ****
X  							) {
X  			int typ;
X  
X! 			otmp = mkobj_at(RANDOM_SYM, x, y);
X  			/* Don't create large objects from small monsters */
X  			typ = otmp->otyp;
X  			if (mdat->msize < MZ_HUMAN && typ != FOOD_RATION
X--- 1032,1038 ----
X  							) {
X  			int typ;
X  
X! 			otmp = mkobj_at(RANDOM_SYM, x, y, TRUE);
X  			/* Don't create large objects from small monsters */
X  			typ = otmp->otyp;
X  			if (mdat->msize < MZ_HUMAN && typ != FOOD_RATION
X***************
X*** 1071,1076 ****
X--- 1078,1089 ----
X  		}
X  		if(is_were(mtmp->data) && mtmp->data->mlet != S_HUMAN)
X  			(void) new_were(mtmp);
X+ 		if(mtmp->mimic && cansee(mtmp->mx, mtmp->my)) {
X+ 			seemimic(mtmp);
X+ 			/* we pretend that the mimic doesn't */
X+ 			/* know that it has been unmasked.   */
X+ 			mtmp->msleep = 1;
X+ 		}
X  	}
X  }
X  
X***************
X*** 1080,1088 ****
X  
X  	register struct monst *mtmp;
X  
X! 	for (mtmp = fmon; mtmp; mtmp = mtmp->nmon)
X  		if (mtmp->data == &mons[PM_CHAMELEON])
X  			mtmp->cham = 1;
X  }
X  
X  int
X--- 1093,1108 ----
X  
X  	register struct monst *mtmp;
X  
X! 	for (mtmp = fmon; mtmp; mtmp = mtmp->nmon) {
X  		if (mtmp->data == &mons[PM_CHAMELEON])
X  			mtmp->cham = 1;
X+ 		if(mtmp->data->mlet == S_MIMIC && mtmp->msleep &&
X+ 				cansee(mtmp->mx, mtmp->my)) {
X+ 			set_mimic_sym(mtmp);
X+ 			unpmon(mtmp);
X+ 			pmon(mtmp);
X+ 		}
X+ 	}
X  }
X  
X  int
X***************
X*** 1099,1105 ****
X  	tryct = 0;
X  	if(mdat == 0) {
X  		while (++tryct < 100) {
X! 			static int num;
X  			mdat = &mons[num=rn2(NUMMONS)];
X  			if ((!is_human(mdat) || num == PM_NURSE)
X  				&& !type_is_pname(mdat)
X--- 1119,1125 ----
X  	tryct = 0;
X  	if(mdat == 0) {
X  		while (++tryct < 100) {
X! 			static int NEARDATA num;
X  			mdat = &mons[num=rn2(NUMMONS)];
X  			if ((!is_human(mdat) || num == PM_NURSE)
X  				&& !type_is_pname(mdat)
X***************
X*** 1187,1193 ****
X  	struct monst *mtmp;
X  {
X  	coord mm;
X! 	enexto(&mm, u.ux, u.uy, mtmp->data);
X  	remove_monster(mtmp->mx, mtmp->my);
X  	place_monster(mtmp, mm.x, mm.y);
X  	pmon(mtmp);
X--- 1207,1213 ----
X  	struct monst *mtmp;
X  {
X  	coord mm;
X! 	if(!enexto(&mm, u.ux, u.uy, mtmp->data)) return;
X  	remove_monster(mtmp->mx, mtmp->my);
X  	place_monster(mtmp, mm.x, mm.y);
X  	pmon(mtmp);
X***************
X*** 1202,1208 ****
X  {
X  	coord mm;
X  	if(!gz || !goodpos(x,y,mtmp->data)) {
X! 		enexto(&mm, x, y, mtmp->data);
X  		x = mm.x; y = mm.y;
X  	}
X  	if(x == mtmp->mx && y == mtmp->my) /* that was easy */
X--- 1222,1228 ----
X  {
X  	coord mm;
X  	if(!gz || !goodpos(x,y,mtmp->data)) {
X! 		if(!enexto(&mm, x, y, mtmp->data)) return;
X  		x = mm.x; y = mm.y;
X  	}
X  	if(x == mtmp->mx && y == mtmp->my) /* that was easy */
X***************
X*** 1262,1268 ****
X  }
X  
X  #ifdef HARD
X! XSTATIC boolean
X  restrap(mtmp)
X  /* unwatched hiders may hide again,
X   * if so, a 1 is returned.
X--- 1282,1288 ----
X  }
X  
X  #ifdef HARD
X! STATIC_OVL boolean
X  restrap(mtmp)
X  /* unwatched hiders may hide again,
X   * if so, a 1 is returned.
X*** src/Old/mondata.c	Sun Jun  3 13:35:20 1990
X--- src/mondata.c	Wed Apr 11 20:13:05 1990
X***************
X*** 348,358 ****
X--- 348,374 ----
X  int little_to_big(montype)
X  int montype;
X  {
X+ #ifndef AIXPS2_BUG
X  	register int i;
X  	
X  	for(i=0; grownups[i][0] >= 0; i++)
X  		if(montype == grownups[i][0]) return grownups[i][1];
X  	return montype;
X+ #else
X+ /* AIX PS/2 C-compiler 1.1.1 optimizer does not like the above for loop,
X+  * and causes segmentation faults at runtime.  (The problem does not
X+  * occur if -O is not used.)
X+  * lehtonen@cs.Helsinki.FI (Tapio Lehtonen) 28031990
X+  */
X+ 	int i;
X+ 	int monvalue;
X+ 
X+ 	monvalue = montype;
X+ 	for(i=0; grownups[i][0] >= 0; i++)
X+ 		if(montype == grownups[i][0]) monvalue = grownups[i][1];
X+ 	
X+ 	return monvalue;
X+ #endif
X  }
X  
X  int big_to_little(montype)
X*** src/Old/monmove.c	Sun Jun  3 13:35:45 1990
X--- src/monmove.c	Thu May 31 22:11:21 1990
X***************
X*** 2,13 ****
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X! #ifndef LINT
X! # ifndef __STDC__
X  #define TRAP_H	/* comment line for pre-compiled headers */
X  /* block some unused #defines to avoid overloading some cpp's */
X! # endif
X! #endif
X  
X  #include "hack.h"
X  #include "mfndpos.h"
X--- 2,13 ----
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X! #ifndef LINT	/* comment line for pre-compiled headers */
X! # ifndef __STDC__	/* comment line for pre-compiled headers */
X  #define TRAP_H	/* comment line for pre-compiled headers */
X  /* block some unused #defines to avoid overloading some cpp's */
X! # endif	/* comment line for pre-compiled headers */
X! #endif	/* comment line for pre-compiled headers */
X  
X  #include "hack.h"
X  #include "mfndpos.h"
X***************
X*** 15,24 ****
X  #  include "artifact.h"
X  #endif
X  
X  static void FDECL(distfleeck,(struct monst *,int *,int *,int *));
X! #ifdef POLYSELF
X  static boolean FDECL(itsstuck,(struct monst *));
X! #endif
X  
X  #ifdef OVLB
X  
X--- 15,29 ----
X  #  include "artifact.h"
X  #endif
X  
X+ #ifdef OVL1
X  static void FDECL(distfleeck,(struct monst *,int *,int *,int *));
X! #endif /* OVL1 */
X! 
X! #ifdef OVL0
X! # ifdef POLYSELF
X  static boolean FDECL(itsstuck,(struct monst *));
X! # endif
X! #endif /* OVL0 */
X  
X  #ifdef OVLB
X  
X***************
X*** 96,102 ****
X  	    newsym(mtmp->mx,mtmp->my);
X  	else
X  	    mnewsym(mtmp->mx,mtmp->my);
X! 	here->seen = FALSE;
X  	return(TRUE);
X  }
X  
X--- 101,108 ----
X  	    newsym(mtmp->mx,mtmp->my);
X  	else
X  	    mnewsym(mtmp->mx,mtmp->my);
X! 	if (!canseeit)
X! 		here->seen = FALSE;
X  	return(TRUE);
X  }
X  
X***************
X*** 340,353 ****
X  	return(tmp == 2);
X  }
X  
X! static const char practical[] = { WEAPON_SYM, GEM_SYM, FOOD_SYM, 0 };
X! static const char magical[] = {
X  	AMULET_SYM, POTION_SYM, SCROLL_SYM, WAND_SYM, RING_SYM,
X  #ifdef SPELLS
X  	SPBOOK_SYM,
X  #endif
X  	0 };
X! static const char indigestion[] = { BALL_SYM, ROCK_SYM, 0 };
X  
X  #ifdef POLYSELF
X  static boolean
X--- 346,362 ----
X  	return(tmp == 2);
X  }
X  
X! static const char NEARDATA practical[] = { WEAPON_SYM, GEM_SYM, FOOD_SYM, 0 };
X! static const char NEARDATA magical[] = {
X  	AMULET_SYM, POTION_SYM, SCROLL_SYM, WAND_SYM, RING_SYM,
X  #ifdef SPELLS
X  	SPBOOK_SYM,
X  #endif
X  	0 };
X! static const char NEARDATA indigestion[] = { BALL_SYM, ROCK_SYM, 0 };
X! 
X! #endif /* OVL1 */
X! #ifdef OVL0
X  
X  #ifdef POLYSELF
X  static boolean
X***************
X*** 362,370 ****
X  }
X  #endif
X  
X- #endif /* OVL1 */
X- #ifdef OVL0
X- 
X  int
X  m_move(mtmp, after)
X  register struct monst *mtmp;
X--- 371,376 ----
X***************
X*** 517,523 ****
X  		conceals = hides_under(ptr);
X  	}
X  
X! #define	SRCHRADIUS	25
X  
X        { xchar mind = SRCHRADIUS;		/* not too far away */
X  	register int dd;
X--- 523,530 ----
X  		conceals = hides_under(ptr);
X  	}
X  
X! #define SQSRCHRADIUS	5
X! #define	SRCHRADIUS	(SQSRCHRADIUS*SQSRCHRADIUS)
X  
X        { xchar mind = SRCHRADIUS;		/* not too far away */
X  	register int dd;
X***************
X*** 539,564 ****
X  	if((likegems || likeobjs || likemagic || likerock || conceals)
X  	      && (!in_shop(omx, omy) || (!rn2(25) && !mtmp->isshk))) {
X  	    register struct obj *otmp;
X  
X! 	    for(otmp = fobj; otmp; otmp = otmp->nobj)
X! 		if((likeobjs && index(practical, otmp->olet)) ||
X! 		   (likemagic && index(magical, otmp->olet)) ||
X! 		   (likerock && otmp->otyp == BOULDER) ||
X! 		   (likegems && otmp->olet == GEM_SYM &&
X! 			otmp->otyp < LAST_GEM + 6) ||
X! 		   (conceals && !cansee(otmp->ox,otmp->oy)) ||
X! 		   (ptr == &mons[PM_GELATINOUS_CUBE] &&
X! 					!index(indigestion, otmp->olet))
X! 		  ) {
X! 			if(can_carry(mtmp,otmp))
X! 			if(ptr->mlet != S_UNICORN ||
X! 					objects[otmp->otyp].g_val != 0)
X! 			    if((dd = dist2(omx,omy,otmp->ox,otmp->oy)) < mind){
X  				mind = dd;
X  				gx = otmp->ox;
X  				gy = otmp->oy;
X  			    }
X  		}
X  	}
X  	if(mind < SRCHRADIUS && appr == -1) {
X  	    if(dist2(omx,omy,mtmp->mux,mtmp->muy) < 10) {
X--- 546,578 ----
X  	if((likegems || likeobjs || likemagic || likerock || conceals)
X  	      && (!in_shop(omx, omy) || (!rn2(25) && !mtmp->isshk))) {
X  	    register struct obj *otmp;
X+ 	    register int xx, yy;
X  
X! 	    for(xx = omx-SQSRCHRADIUS; xx <= omx+SQSRCHRADIUS; xx++) {
X! 		for(yy = omy-SQSRCHRADIUS; yy <= omy+SQSRCHRADIUS; yy++) {
X! 		    if(!isok(xx, yy)) continue;
X! 		    if((dd = dist2(omx,omy,xx, yy)) >= mind) continue;
X! 		    for(otmp = level.objects[xx][yy]; otmp; otmp = otmp->nexthere)
X! 		      if((likeobjs && index(practical, otmp->olet)) ||
X! 			 (likemagic && index(magical, otmp->olet)) ||
X! 			 (likerock && otmp->otyp == BOULDER) ||
X! 			 (likegems && otmp->olet == GEM_SYM &&
X! 			  otmp->otyp < LAST_GEM + 6) ||
X! 			 (conceals && !cansee(otmp->ox,otmp->oy)) ||
X! 			 (ptr == &mons[PM_GELATINOUS_CUBE] &&
X! 			  !index(indigestion, otmp->olet))
X! 			 ) {
X! 			  if(can_carry(mtmp,otmp))
X! 			    if(ptr->mlet != S_UNICORN ||
X! 			       objects[otmp->otyp].g_val != 0){
X  				mind = dd;
X  				gx = otmp->ox;
X  				gy = otmp->oy;
X+ 				break;
X  			    }
X+ 		      }
X  		}
X+ 	    }
X  	}
X  	if(mind < SRCHRADIUS && appr == -1) {
X  	    if(dist2(omx,omy,mtmp->mux,mtmp->muy) < 10) {
X***************
X*** 576,582 ****
X  	if (ptr->mlet == S_UNICORN) flag |= NOTONL;
X  	if (passes_walls(ptr)) flag |= (ALLOW_WALL | ALLOW_ROCK);
X  	if (can_tunnel) flag |= ALLOW_DIG;
X! 	if (is_human(ptr)) flag |= ALLOW_SSM;
X  	if (is_undead(ptr)) flag |= NOGARLIC;
X  	if (throws_rocks(ptr)) flag |= ALLOW_ROCK;
X  	if (can_open) flag |= OPENDOOR;
X--- 590,596 ----
X  	if (ptr->mlet == S_UNICORN) flag |= NOTONL;
X  	if (passes_walls(ptr)) flag |= (ALLOW_WALL | ALLOW_ROCK);
X  	if (can_tunnel) flag |= ALLOW_DIG;
X! 	if (is_human(ptr) || ptr == &mons[PM_MINOTAUR]) flag |= ALLOW_SSM;
X  	if (is_undead(ptr)) flag |= NOGARLIC;
X  	if (throws_rocks(ptr)) flag |= ALLOW_ROCK;
X  	if (can_open) flag |= OPENDOOR;
X***************
X*** 624,631 ****
X  	    if((info[chi] & ALLOW_M) ||
X  		   (nix == mtmp->mux && niy == mtmp->muy)) {
X  		int stat;
X! 		mtmp2 = 
X! 		    (MON_AT(nix, niy) ? m_at(nix,niy) : (struct monst *)0);
X  		if((stat = mattackm(mtmp, mtmp2)) == 1 && rn2(4) &&
X  			mtmp2->mlstmv != moves && mattackm(mtmp2, mtmp) == 2)
X  		    return(2);
X--- 638,644 ----
X  	    if((info[chi] & ALLOW_M) ||
X  		   (nix == mtmp->mux && niy == mtmp->muy)) {
X  		int stat;
X! 		mtmp2 = m_at(nix,niy);
X  		if((stat = mattackm(mtmp, mtmp2)) == 1 && rn2(4) &&
X  			mtmp2->mlstmv != moves && mattackm(mtmp2, mtmp) == 2)
X  		    return(2);
X
END_OF_FILE
if test 53751 -ne `wc -c <'patch8.04'`; then
    echo shar: \"'patch8.04'\" unpacked with wrong size!
fi
# end of 'patch8.04'
fi
echo shar: End of archive 8 \(of 24\).
cp /dev/null ark8isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 24 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
