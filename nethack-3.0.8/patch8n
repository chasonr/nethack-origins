Path: utzoo!utgpu!news-server.csri.toronto.edu!cs.utexas.edu!uwm.edu!ogicse!zephyr.ens.tek.com!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v10i032:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Patch8n
Message-ID: <5740@tekred.CNA.TEK.COM>
Date: 5 Jun 90 17:59:08 GMT
Sender: news@tekred.CNA.TEK.COM
Lines: 1565
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 10, Issue 32
Archive-name: NetHack3/Patch8n
Patch-To: NetHack3: Volume 7, Issue 56-93



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 14 (of 24)."
# Contents:  patch8.09
# Wrapped by billr@saab on Mon Jun  4 15:27:24 1990
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'patch8.09' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'patch8.09'\"
else
echo shar: Extracting \"'patch8.09'\" \(48346 characters\)
sed "s/^X//" >'patch8.09' <<'END_OF_FILE'
X*** src/Old/unixunix.c	Sun Jun  3 14:18:01 1990
X--- src/unixunix.c	Sun Apr 15 11:20:19 1990
X***************
X*** 175,181 ****
X  veryold(fd)
X  int fd;
X  {
X- 	register int i;
X  	time_t date;
X  
X  	if(fstat(fd, &buf)) return(0);			/* cannot get status */
X--- 175,180 ----
X***************
X*** 205,210 ****
X--- 204,217 ----
X  			return(0);
X  	}
X  	(void) close(fd);
X+ 	return(1);
X+ }
X+ 
X+ static int
X+ eraseoldlocks()
X+ {
X+ 	register int i;
X+ 
X  	for(i = 1; i <= MAXLEVEL+1; i++) {		/* try to remove all */
X  		glo(i);
X  		(void) unlink(lock);
X***************
X*** 218,224 ****
X  getlock()
X  {
X  	extern int errno;
X! 	register int i = 0, fd;
X  #ifdef NO_FILE_LINKS
X  	int hlockfd ;
X  	int sleepct = 20 ;
X--- 225,231 ----
X  getlock()
X  {
X  	extern int errno;
X! 	register int i = 0, fd, c;
X  #ifdef NO_FILE_LINKS
X  	int hlockfd ;
X  	int sleepct = 20 ;
X***************
X*** 282,292 ****
X  
X  	regularize(lock);
X  	glo(0);
X- 	if(locknum > 25) locknum = 25;
X  
X! 	do {
X! 		if(locknum) lock[0] = 'a' + i++;
X  
X  		if((fd = open(lock, 0)) == -1) {
X  			if(errno == ENOENT) goto gotlock;    /* no such file */
X  			perror(lock);
X--- 289,317 ----
X  
X  	regularize(lock);
X  	glo(0);
X  
X! 	if(locknum) {
X! 		if(locknum > 25) locknum = 25;
X  
X+ 		do {
X+ 			lock[0] = 'a' + i++;
X+ 
X+ 			if((fd = open(lock, 0)) == -1) {
X+ 			    if(errno == ENOENT) goto gotlock; /* no such file */
X+ 			    perror(lock);
X+ 			    (void) unlink(LLOCK);
X+ 			    error("Cannot open %s", lock);
X+ 			}
X+ 
X+ 			if(veryold(fd) /* closes fd if true */
X+ 							&& eraseoldlocks())
X+ 				goto gotlock;
X+ 			(void) close(fd);
X+ 		} while(i < locknum);
X+ 
X+ 		(void) unlink(LLOCK);
X+ 		error("Too many hacks running now.");
X+ 	} else {
X  		if((fd = open(lock, 0)) == -1) {
X  			if(errno == ENOENT) goto gotlock;    /* no such file */
X  			perror(lock);
X***************
X*** 294,307 ****
X  			error("Cannot open %s", lock);
X  		}
X  
X! 		if(veryold(fd))	/* if true, this closes fd and unlinks lock */
X  			goto gotlock;
X  		(void) close(fd);
X- 	} while(i < locknum);
X  
X! 	(void) unlink(LLOCK);
X! 	error(locknum ? "Too many hacks running now."
X! 		      : "There is a game in progress under your name.");
X  gotlock:
X  	fd = creat(lock, FCMASK);
X  	if(unlink(LLOCK) == -1)
X--- 319,345 ----
X  			error("Cannot open %s", lock);
X  		}
X  
X! 		if(veryold(fd) /* closes fd if true */ && eraseoldlocks())
X  			goto gotlock;
X  		(void) close(fd);
X  
X! 		Printf("\nThere is already a game in progress under your name.");
X! 		Printf("\nDestroy old game? [yn] ");
X! 		(void) fflush(stdout);
X! 		c = Getchar();
X! 		while (Getchar() != '\n') ; /* eat rest of line and newline */
X! 		if(c == 'y' || c == 'Y')
X! 			if(eraseoldlocks())
X! 				goto gotlock;
X! 			else {
X! 				(void) unlink(LLOCK);
X! 				error("Couldn't destroy old game.");
X! 			}
X! 		else {
X! 			(void) unlink(LLOCK);
X! 			error("");
X! 		}
X! 	}
X  gotlock:
X  	fd = creat(lock, FCMASK);
X  	if(unlink(LLOCK) == -1)
X*** src/Old/vault.c	Sun Jun  3 14:18:19 1990
X--- src/vault.c	Thu May 31 22:13:56 1990
X***************
X*** 5,30 ****
X  #include "hack.h"
X  #include "vault.h"
X  
X! static void FDECL(restfakecorr,(struct monst *));
X! OSTATIC boolean FDECL(in_vault,(int,int));
X! OSTATIC struct monst *NDECL(findgd);
X! static boolean FDECL(in_fcorridor, (struct monst *,int,int));
X  
X  #ifdef OVLB
X  
X! static void
X! restfakecorr(grd) 
X  register struct monst *grd;
X  {
X  	register int fcx, fcy, fcbeg;
X  	register struct rm *crm;
X  
X  	while((fcbeg = EGD(grd)->fcbeg) < EGD(grd)->fcend) {
X  		fcx = EGD(grd)->fakecorr[fcbeg].fx;
X  		fcy = EGD(grd)->fakecorr[fcbeg].fy;
X! 		if((u.ux == fcx && u.uy == fcy) || cansee(fcx,fcy) ||
X! 		   m_at(fcx,fcy))
X! 			return;
X  		crm = &levl[fcx][fcy];
X  		crm->typ = EGD(grd)->fakecorr[fcbeg].ftyp;
X  		if(!crm->typ) crm->seen = 0;
X--- 5,42 ----
X  #include "hack.h"
X  #include "vault.h"
X  
X! STATIC_DCL boolean FDECL(in_vault,(int,int));
X! STATIC_DCL struct monst *NDECL(findgd);
X  
X  #ifdef OVLB
X  
X! static boolean FDECL(clear_fcorr, (struct monst *,BOOLEAN_P));
X! static void FDECL(restfakecorr,(struct monst *));
X! static boolean FDECL(in_fcorridor, (struct monst *,int,int));
X! 
X! static boolean
X! clear_fcorr(grd, forceshow)
X  register struct monst *grd;
X+ register boolean forceshow;
X  {
X  	register int fcx, fcy, fcbeg;
X  	register struct rm *crm;
X+ 	register struct monst *mtmp = (struct monst *)0;
X  
X  	while((fcbeg = EGD(grd)->fcbeg) < EGD(grd)->fcend) {
X  		fcx = EGD(grd)->fakecorr[fcbeg].fx;
X  		fcy = EGD(grd)->fakecorr[fcbeg].fy;
X! 		if(!in_fcorridor(grd, u.ux, u.uy) && EGD(grd)->gddone)
X! 			forceshow = TRUE;
X! 		if((u.ux == fcx && u.uy == fcy) || 
X! 		   (!forceshow && cansee(fcx,fcy))) return(FALSE);
X! 		if(mtmp = m_at(fcx,fcy)) {
X! 			if(mtmp->isgd) return(FALSE);
X! 			else if(!in_fcorridor(grd, u.ux, u.uy)) {
X! 			    rloc(mtmp);
X! 			    if(mtmp->mpeaceful) You("hear a muffled yelp.");
X! 			}
X! 		}
X  		crm = &levl[fcx][fcy];
X  		crm->typ = EGD(grd)->fakecorr[fcbeg].ftyp;
X  		if(!crm->typ) crm->seen = 0;
X***************
X*** 32,39 ****
X  		if(cansee(fcx,fcy)) prl(fcx,fcy);
X  		EGD(grd)->fcbeg++;
X  	}
X  	/* it seems he left the corridor - let the guard disappear */
X! 	mongone(grd);
X  }
X  
X  static boolean
X--- 44,74 ----
X  		if(cansee(fcx,fcy)) prl(fcx,fcy);
X  		EGD(grd)->fcbeg++;
X  	}
X+ 	return(TRUE);
X+ }
X+ 
X+ static void
X+ restfakecorr(grd) 
X+ register struct monst *grd;
X+ {
X  	/* it seems he left the corridor - let the guard disappear */
X! 	if(clear_fcorr(grd, FALSE)) mongone(grd);
X! }
X! 
X! boolean
X! grddead(grd)				/* called in mon.c */
X! register struct monst *grd;
X! {
X! 	register boolean dispose = clear_fcorr(grd, TRUE);
X! 
X! 	if(!dispose) {
X! 		remove_monster(grd->mx, grd->my);
X! 		place_monster(grd, 0, 0);
X! 		EGD(grd)->ogx = grd->mx;
X! 		EGD(grd)->ogy = grd->my;
X! 		dispose = clear_fcorr(grd, TRUE);
X! 	}
X! 	return(dispose);
X  }
X  
X  static boolean
X***************
X*** 50,56 ****
X  	return(FALSE);
X  }
X  
X! XSTATIC 
X  struct monst *
X  findgd() {
X  
X--- 85,91 ----
X  	return(FALSE);
X  }
X  
X! STATIC_OVL
X  struct monst *
X  findgd() {
X  
X***************
X*** 65,71 ****
X  #endif /* OVLB */
X  #ifdef OVL0
X  
X! XSTATIC
X  boolean
X  in_vault(x, y)
X  int x, y;
X--- 100,106 ----
X  #endif /* OVLB */
X  #ifdef OVL0
X  
X! STATIC_OVL
X  boolean
X  in_vault(x, y)
X  int x, y;
X***************
X*** 197,208 ****
X  	m = n = 0;
X  #endif
X  	if(EGD(grd)->gdlevel != dlevel) return(-1);
X! 	if(!grd->mpeaceful && in_vault(grd->mx, grd->my) &&
X! 			!in_vault(u.ux, u.uy)) {
X  		rloc(grd);
X  		goto letknow;
X  	}
X- 	if(!grd->mpeaceful) return(-1);
X  	if(abs(EGD(grd)->ogx - grd->mx) > 1 || 
X  			abs(EGD(grd)->ogy - grd->my) > 1)
X  		return(-1);	/* teleported guard - treat as monster */
X--- 232,249 ----
X  	m = n = 0;
X  #endif
X  	if(EGD(grd)->gdlevel != dlevel) return(-1);
X! 	if(!grd->mpeaceful) {
X! 	    if((in_vault(grd->mx, grd->my) && !in_vault(u.ux, u.uy)) ||
X! 	       (in_fcorridor(grd, grd->mx, grd->my) && !in_vault(u.ux, u.uy) &&
X! 			!in_fcorridor(grd, u.ux, u.uy))) {
X  		rloc(grd);
X+ 		(void) clear_fcorr(grd, TRUE);
X  		goto letknow;
X+ 	    }
X+ 	    if(!in_fcorridor(grd, grd->mx, grd->my))
X+ 		(void) clear_fcorr(grd, TRUE);
X+ 	    return(-1);
X  	}
X  	if(abs(EGD(grd)->ogx - grd->mx) > 1 || 
X  			abs(EGD(grd)->ogy - grd->my) > 1)
X  		return(-1);	/* teleported guard - treat as monster */
X***************
X*** 212,219 ****
X  		if(EGD(grd)->warncnt == 3)
X  			pline("\"Again, %sfollow me!\"", 
X  				u.ugold ? "drop that gold and " : "");
X! 		if(EGD(grd)->warncnt == 6) {
X! 			register int m = grd->mx, n = grd->my;
X  			verbalize("You've been warned, knave!");
X  			mnexto(grd);
X  			levl[m][n].typ = EGD(grd)->fakecorr[0].ftyp;
X--- 253,261 ----
X  		if(EGD(grd)->warncnt == 3)
X  			pline("\"Again, %sfollow me!\"", 
X  				u.ugold ? "drop that gold and " : "");
X! 		if(EGD(grd)->warncnt == 7) {
X! 			m = grd->mx;
X! 			n = grd->my;
X  			verbalize("You've been warned, knave!");
X  			mnexto(grd);
X  			levl[m][n].typ = EGD(grd)->fakecorr[0].ftyp;
X***************
X*** 227,233 ****
X  		return(0);
X  	    }
X  	    if(!in_vault(u.ux,u.uy) && u.ugold) { /* player teleported */
X! 		register int m = grd->mx, n = grd->my;
X  		rloc(grd);
X  		levl[m][n].typ = EGD(grd)->fakecorr[0].ftyp;
X  		newsym(m,n);
X--- 269,276 ----
X  		return(0);
X  	    }
X  	    if(!in_vault(u.ux,u.uy) && u.ugold) { /* player teleported */
X! 		m = grd->mx;
X! 		n = grd->my;
X  		rloc(grd);
X  		levl[m][n].typ = EGD(grd)->fakecorr[0].ftyp;
X  		newsym(m,n);
X***************
X*** 244,251 ****
X  		return(-1);
X  	    }
X  	}
X! 	if(u.ugold && (in_fcorridor(grd, u.ux, u.uy) || /*cover 'blind' spot*/
X  		    (EGD(grd)->fcend > 1 && in_vault(u.ux, u.uy)))) {
X  		if(EGD(grd)->warncnt < 6) {
X  			EGD(grd)->warncnt = 6;
X  			verbalize("Drop all your gold, scoundrel!");
X--- 287,306 ----
X  		return(-1);
X  	    }
X  	}
X! 	if(EGD(grd)->fcend > 1) {
X! 	    if(EGD(grd)->fcend > 2 && in_fcorridor(grd, grd->mx, grd->my) &&
X! 		  !EGD(grd)->gddone && !in_fcorridor(grd, u.ux, u.uy) &&
X! 		  levl[EGD(grd)->fakecorr[0].fx][EGD(grd)->fakecorr[0].fy].typ
X! 				 == EGD(grd)->fakecorr[0].ftyp) {
X! 		pline("The guard, confused, disappears.");
X! 		goto cleanup;
X! 	    }
X! 	    if(u.ugold && (in_fcorridor(grd, u.ux, u.uy) || /*cover 'blind' spot*/
X  		    (EGD(grd)->fcend > 1 && in_vault(u.ux, u.uy)))) {
X+ 		if(!grd->mx) {
X+ 			restfakecorr(grd);
X+ 			return(-2);
X+ 		}
X  		if(EGD(grd)->warncnt < 6) {
X  			EGD(grd)->warncnt = 6;
X  			verbalize("Drop all your gold, scoundrel!");
X***************
X*** 255,261 ****
X  			grd->mpeaceful = 0;
X  			return(-1);
X  		}	
X! 	} 
X  	for(fci = EGD(grd)->fcbeg; fci < EGD(grd)->fcend; fci++)
X  	    if(g_at(EGD(grd)->fakecorr[fci].fx, EGD(grd)->fakecorr[fci].fy)){
X  		m = EGD(grd)->fakecorr[fci].fx;
X--- 310,317 ----
X  			grd->mpeaceful = 0;
X  			return(-1);
X  		}	
X! 	    } 
X! 	}
X  	for(fci = EGD(grd)->fcbeg; fci < EGD(grd)->fcend; fci++)
X  	    if(g_at(EGD(grd)->fakecorr[fci].fx, EGD(grd)->fakecorr[fci].fy)){
X  		m = EGD(grd)->fakecorr[fci].fx;
X***************
X*** 281,287 ****
X  		    pmon(grd);
X  		    mpickgold(grd);
X  		}
X! 		pline("The %s%s picks the gold.", lmonnam(grd)+4,
X  				grd->mpeaceful ? " calms down and" : "");
X  		if(x != grd->mx || y != grd->my) {
X  		    remove_monster(grd->mx, grd->my);
X--- 337,343 ----
X  		    pmon(grd);
X  		    mpickgold(grd);
X  		}
X! 		pline("The %s%s picks up the gold.", lmonnam(grd)+4,
X  				grd->mpeaceful ? " calms down and" : "");
X  		if(x != grd->mx || y != grd->my) {
X  		    remove_monster(grd->mx, grd->my);
X***************
X*** 385,397 ****
X  		/* to avoid a check at the top of this function.  */
X  		/* At the end of the process, the guard is killed */
X  		/* in restfakecorr().				  */
X  		remove_monster(grd->mx, grd->my);
X  		place_monster(grd, 0, 0);
X  		EGD(grd)->ogx = grd->mx;
X  		EGD(grd)->ogy = grd->my;
X  		restfakecorr(grd);
X! 		if(in_fcorridor(grd, u.ux, u.uy) || cansee(grd->mx, grd->my))
X  		    pline("Suddenly, the guard disappears.");
X  		return(-2);
X  	}
X  	EGD(grd)->ogx = grd->mx;	/* update old positions */
X--- 441,456 ----
X  		/* to avoid a check at the top of this function.  */
X  		/* At the end of the process, the guard is killed */
X  		/* in restfakecorr().				  */
X+ cleanup:
X  		remove_monster(grd->mx, grd->my);
X  		place_monster(grd, 0, 0);
X  		EGD(grd)->ogx = grd->mx;
X  		EGD(grd)->ogy = grd->my;
X  		restfakecorr(grd);
X! 		if(in_fcorridor(grd, u.ux, u.uy) || cansee(grd->mx, grd->my)) {
X  		    pline("Suddenly, the guard disappears.");
X+ 		    return(1);
X+ 		}
X  		return(-2);
X  	}
X  	EGD(grd)->ogx = grd->mx;	/* update old positions */
X***************
X*** 446,451 ****
X--- 505,511 ----
X  	mongone(guard);
X  }
X  
X+ #ifdef SOUNDS
X  boolean
X  gd_sound() {  /* prevent "You hear footsteps.." when inappropriate */
X  	register struct monst *grd = findgd();
X***************
X*** 452,456 ****
X--- 512,517 ----
X  
X  	return(grd == (struct monst *)0);
X  }
X+ #endif
X  
X  #endif /* OVLB */
X*** src/Old/weapon.c	Sun Jun  3 14:19:01 1990
X--- src/weapon.c	Tue Mar 20 19:51:15 1990
X***************
X*** 11,17 ****
X  
X  #ifdef OVLB
X  
X! static const char kebabable[] = { S_XORN, S_DRAGON, S_NAGA, S_GIANT, 0 };
X  
X  /*
X   * 	hitval returns an integer representing the "to hit" bonuses
X--- 11,17 ----
X  
X  #ifdef OVLB
X  
X! static const char NEARDATA kebabable[] = { S_XORN, S_DRAGON, S_NAGA, S_GIANT, 0 };
X  
X  /*
X   * 	hitval returns an integer representing the "to hit" bonuses
X***************
X*** 176,192 ****
X  #define	Oselect(x)	if((otmp = m_carrying(mtmp, x))) return(otmp);
X  
X  #ifdef TOLKIEN
X! static const int rwep[] =
X  	{ DWARVISH_SPEAR, ELVEN_SPEAR, SPEAR, ORCISH_SPEAR, JAVELIN,
X  	  SHURIKEN, SILVER_ARROW, ELVEN_ARROW, ARROW, ORCISH_ARROW,
X  	  CROSSBOW_BOLT, ELVEN_DAGGER, DAGGER, ORCISH_DAGGER, KNIFE, ROCK,
X! 	  LOADSTONE, LUCKSTONE, DART, BOOMERANG, CREAM_PIE
X  	  /* note: CREAM_PIE should NOT be #ifdef KOPS */
X  	  };
X  #else
X! static const int rwep[] =
X  	{ SPEAR, JAVELIN, SHURIKEN, SILVER_ARROW, ARROW, CROSSBOW_BOLT,
X! 	  DAGGER, KNIFE, ROCK, LOADSTONE, LUCKSTONE, DART, BOOMERANG, CREAM_PIE
X  	  /* note: CREAM_PIE should NOT be #ifdef KOPS */
X  	  };
X  #endif
X--- 176,193 ----
X  #define	Oselect(x)	if((otmp = m_carrying(mtmp, x))) return(otmp);
X  
X  #ifdef TOLKIEN
X! static const int NEARDATA rwep[] =
X  	{ DWARVISH_SPEAR, ELVEN_SPEAR, SPEAR, ORCISH_SPEAR, JAVELIN,
X  	  SHURIKEN, SILVER_ARROW, ELVEN_ARROW, ARROW, ORCISH_ARROW,
X  	  CROSSBOW_BOLT, ELVEN_DAGGER, DAGGER, ORCISH_DAGGER, KNIFE, ROCK,
X! 	  LOADSTONE, LUCKSTONE, DART, /* BOOMERANG, */ CREAM_PIE
X  	  /* note: CREAM_PIE should NOT be #ifdef KOPS */
X  	  };
X  #else
X! static const int NEARDATA rwep[] =
X  	{ SPEAR, JAVELIN, SHURIKEN, SILVER_ARROW, ARROW, CROSSBOW_BOLT,
X! 	  DAGGER, KNIFE, ROCK, LOADSTONE, LUCKSTONE, DART, /* BOOMERANG, */
X! 	  CREAM_PIE
X  	  /* note: CREAM_PIE should NOT be #ifdef KOPS */
X  	  };
X  #endif
X***************
X*** 261,267 ****
X  
X  #ifdef TOLKIEN
X  /* 0 = used by any monster; 1 = only used by strong monsters */
X! static const int hwep[][2] =
X  	{ {DWARVISH_MATTOCK,1}, {TWO_HANDED_SWORD,1}, {KATANA,0},
X  	  {UNICORN_HORN,1},
X  #ifdef WORM
X--- 262,268 ----
X  
X  #ifdef TOLKIEN
X  /* 0 = used by any monster; 1 = only used by strong monsters */
X! static const int NEARDATA hwep[][2] =
X  	{ {DWARVISH_MATTOCK,1}, {TWO_HANDED_SWORD,1}, {KATANA,0},
X  	  {UNICORN_HORN,1},
X  #ifdef WORM
X***************
X*** 288,294 ****
X  	};
X  #else /* TOLKIEN */
X  /* 0 = used by any monster; 1 = only used by strong monsters */
X! static const int hwep[][2] =
X  	{ {TWO_HANDED_SWORD,1}, {KATANA,0}, {UNICORN_HORN,1},
X  #ifdef WORM
X  	  {CRYSKNIFE,0},
X--- 289,295 ----
X  	};
X  #else /* TOLKIEN */
X  /* 0 = used by any monster; 1 = only used by strong monsters */
X! static const int NEARDATA hwep[][2] =
X  	{ {TWO_HANDED_SWORD,1}, {KATANA,0}, {UNICORN_HORN,1},
X  #ifdef WORM
X  	  {CRYSKNIFE,0},
X*** src/Old/were.c	Sun Jun  3 14:19:21 1990
X--- src/were.c	Thu May 31 22:13:58 1990
X***************
X*** 4,11 ****
X  
X  #include	"hack.h"
X  
X- static int FDECL(counter_were,(int));
X- 
X  #ifdef OVL0
X  
X  void
X--- 4,9 ----
X***************
X*** 28,33 ****
X--- 26,33 ----
X  
X  #endif /* OVL0 */
X  #ifdef OVLB
X+ 
X+ static int FDECL(counter_were,(int));
X  
X  static int
X  counter_were(pm)
X*** src/Old/wield.c	Sun Jun  3 14:19:35 1990
X--- src/wield.c	Tue Mar 20 19:51:16 1990
X***************
X*** 28,34 ****
X  	}
X  }
X  
X! static const char wield_objs[] = { '#', '-', WEAPON_SYM, TOOL_SYM, 0 };
X  
X  int
X  dowield()
X--- 28,34 ----
X  	}
X  }
X  
X! static const char NEARDATA wield_objs[] = { '#', '-', WEAPON_SYM, TOOL_SYM, 0 };
X  
X  int
X  dowield()
X***************
X*** 160,166 ****
X  	}
X  #endif
X  	/* there is a (soft) upper and lower limit to uwep->spe */
X! 	if(abs(uwep->spe) > 5 && rn2(3)) {
X  	    if (!Blind)
X  	    Your("%s violently %s for a while and then evaporate%s.",
X  		aobjnam(uwep,"glow"), color, uwep->quan == 1 ? "s" : "");
X--- 160,167 ----
X  	}
X  #endif
X  	/* there is a (soft) upper and lower limit to uwep->spe */
X! 	if(((uwep->spe > 5 && amount > 0) || (uwep->spe < -5 && amount < 0))
X! 								&& rn2(3)) {
X  	    if (!Blind)
X  	    Your("%s violently %s for a while and then evaporate%s.",
X  		aobjnam(uwep,"glow"), color, uwep->quan == 1 ? "s" : "");
X*** src/Old/wizard.c	Sun Jun  3 14:19:50 1990
X--- src/wizard.c	Sun Feb 25 14:49:37 1990
X***************
X*** 12,18 ****
X  
X  #ifdef HARD
X  /*	TODO:	Expand this list.	*/
X! static const int nasties[] = {
X  	PM_COCKATRICE, PM_ETTIN, PM_STALKER, PM_MINOTAUR, PM_RED_DRAGON,
X  	PM_GREEN_DRAGON, PM_OWLBEAR, PM_PURPLE_WORM, PM_ROCK_TROLL, PM_XAN,
X  	PM_GREMLIN, PM_UMBER_HULK, PM_VAMPIRE_LORD, PM_XORN, PM_ZRUTY,
X--- 12,18 ----
X  
X  #ifdef HARD
X  /*	TODO:	Expand this list.	*/
X! static const int NEARDATA nasties[] = {
X  	PM_COCKATRICE, PM_ETTIN, PM_STALKER, PM_MINOTAUR, PM_RED_DRAGON,
X  	PM_GREEN_DRAGON, PM_OWLBEAR, PM_PURPLE_WORM, PM_ROCK_TROLL, PM_XAN,
X  	PM_GREMLIN, PM_UMBER_HULK, PM_VAMPIRE_LORD, PM_XORN, PM_ZRUTY,
X***************
X*** 22,28 ****
X  	};
X  #endif /* HARD */
X  
X! static const unsigned wizapp[] = {
X  	PM_HUMAN, PM_WATER_DEMON, PM_VAMPIRE,
X  	PM_RED_DRAGON, PM_TROLL, PM_UMBER_HULK,
X  	PM_XORN, PM_XAN, PM_COCKATRICE,
X--- 22,28 ----
X  	};
X  #endif /* HARD */
X  
X! static const unsigned NEARDATA wizapp[] = {
X  	PM_HUMAN, PM_WATER_DEMON, PM_VAMPIRE,
X  	PM_RED_DRAGON, PM_TROLL, PM_UMBER_HULK,
X  	PM_XORN, PM_XAN, PM_COCKATRICE,
X*** src/Old/worm.c	Sun Jun  3 14:20:11 1990
X--- src/worm.c	Tue Feb 27 19:13:13 1990
X***************
X*** 97,103 ****
X  	} else	whd->wdispl = 0;
X  	if(wgrowtime[tmp] <= moves) {
X  		if(!wgrowtime[tmp]) wgrowtime[tmp] = moves + rnd(5);
X! 		else wgrowtime[tmp] += 2+rnd(15);
X  		mtmp->mhp += 3;
X  		if (mtmp->mhp > MHPMAX) mtmp->mhp = MHPMAX;
X  		if (mtmp->mhp > mtmp->mhpmax) mtmp->mhpmax = mtmp->mhp;
X--- 97,103 ----
X  	} else	whd->wdispl = 0;
X  	if(wgrowtime[tmp] <= moves) {
X  		if(!wgrowtime[tmp]) wgrowtime[tmp] = moves + rnd(5);
X! 		else wgrowtime[tmp] = wgrowtime[tmp]+2+rnd(15);
X  		mtmp->mhp += 3;
X  		if (mtmp->mhp > MHPMAX) mtmp->mhp = MHPMAX;
X  		if (mtmp->mhp > mtmp->mhpmax) mtmp->mhpmax = mtmp->mhp;
X*** src/Old/write.c	Sun Jun  3 14:20:37 1990
X--- src/write.c	Sun Feb 25 14:49:39 1990
X***************
X*** 59,65 ****
X  	return(1000);
X  }
X  
X! static const char write_on[] = { SCROLL_SYM, 0 };
X  
X  void
X  dowrite(pen)
X--- 59,65 ----
X  	return(1000);
X  }
X  
X! static const char NEARDATA write_on[] = { SCROLL_SYM, 0 };
X  
X  void
X  dowrite(pen)
X*** src/Old/zap.c	Sun Jun  3 14:20:57 1990
X--- src/zap.c	Sat May 26 22:43:51 1990
X***************
X*** 5,22 ****
X  #include "hack.h"
X  
X  #if defined(ALTARS) && defined(THEOLOGY)
X! static boolean priesthit = FALSE;
X  #endif
X  
X  static int FDECL(burn_floor_paper,(int,int));
X! #ifndef OVERLAY
X! static int FDECL(bhitm,(struct monst *,struct obj *));
X! #endif
X  static void FDECL(cancel_item,(struct obj *));
X  static int FDECL(bhitgold,(struct gold *,struct obj *));
X! #ifndef OVERLAY
X! static int FDECL(bhito,(struct obj *,struct obj *));
X! #endif
X  static void FDECL(backfire,(struct obj *));
X  static uchar FDECL(dirlet,(int,int));
X  static int FDECL(zhit,(struct monst *,int,int));
X--- 5,18 ----
X  #include "hack.h"
X  
X  #if defined(ALTARS) && defined(THEOLOGY)
X! static boolean NEARDATA priesthit = FALSE;
X  #endif
X  
X  static int FDECL(burn_floor_paper,(int,int));
X! STATIC_PTR int FDECL(bhitm,(struct monst *,struct obj *));
X  static void FDECL(cancel_item,(struct obj *));
X  static int FDECL(bhitgold,(struct gold *,struct obj *));
X! STATIC_PTR int FDECL(bhito,(struct obj *,struct obj *));
X  static void FDECL(backfire,(struct obj *));
X  static uchar FDECL(dirlet,(int,int));
X  static int FDECL(zhit,(struct monst *,int,int));
X***************
X*** 65,73 ****
X  
X  /* Routines for IMMEDIATE wands and spells. */
X  /* bhitm: monster mtmp was hit by the effect of wand or spell otmp */
X! #ifndef OVERLAY
X! static 
X! #endif
X  int
X  bhitm(mtmp, otmp)
X  register struct monst *mtmp;
X--- 61,67 ----
X  
X  /* Routines for IMMEDIATE wands and spells. */
X  /* bhitm: monster mtmp was hit by the effect of wand or spell otmp */
X! STATIC_PTR
X  int
X  bhitm(mtmp, otmp)
X  register struct monst *mtmp;
X***************
X*** 238,244 ****
X  	return mtmp;
X  }
X  
X! static const char charged_objs[] = { WAND_SYM, WEAPON_SYM, ARMOR_SYM, 0 };
X  
X  static void
X  cancel_item(obj)
X--- 232,238 ----
X  	return mtmp;
X  }
X  
X! static const char NEARDATA charged_objs[] = { WAND_SYM, WEAPON_SYM, ARMOR_SYM, 0 };
X  
X  static void
X  cancel_item(obj)
X***************
X*** 246,269 ****
X  {
X  	switch(obj->otyp) {
X  		case RIN_GAIN_STRENGTH:
X! 			ABON(A_STR) -= obj->spe;
X! 			flags.botl = 1;
X  			break;
X  		case RIN_ADORNMENT:
X! 			ABON(A_CHA) -= obj->spe;
X! 			flags.botl = 1;
X  			break;
X  		case RIN_INCREASE_DAMAGE:
X! 			u.udaminc -= obj->spe;
X  			break;
X  		case GAUNTLETS_OF_DEXTERITY:
X! 			ABON(A_DEX) -= obj->spe;
X! 			flags.botl = 1;
X  			break;
X  		case HELM_OF_BRILLIANCE:
X! 			ABON(A_INT) -= obj->spe;
X! 			ABON(A_WIS) -= obj->spe;
X! 			flags.botl = 1;
X  			break;
X  		/* case RIN_PROTECTION: /* not needed */
X  	}
X--- 240,272 ----
X  {
X  	switch(obj->otyp) {
X  		case RIN_GAIN_STRENGTH:
X! 			if(obj->owornmask & W_RING) {
X! 				ABON(A_STR) -= obj->spe;
X! 				flags.botl = 1;
X! 			}
X  			break;
X  		case RIN_ADORNMENT:
X! 			if(obj->owornmask & W_RING) {
X! 				ABON(A_CHA) -= obj->spe;
X! 				flags.botl = 1;
X! 			}
X  			break;
X  		case RIN_INCREASE_DAMAGE:
X! 			if(obj->owornmask & W_RING)
X! 				u.udaminc -= obj->spe;
X  			break;
X  		case GAUNTLETS_OF_DEXTERITY:
X! 			if(obj->owornmask & W_ARMG) {
X! 				ABON(A_DEX) -= obj->spe;
X! 				flags.botl = 1;
X! 			}
X  			break;
X  		case HELM_OF_BRILLIANCE:
X! 			if(obj->owornmask & W_ARMH) {
X! 				ABON(A_INT) -= obj->spe;
X! 				ABON(A_WIS) -= obj->spe;
X! 				flags.botl = 1;
X! 			}
X  			break;
X  		/* case RIN_PROTECTION: /* not needed */
X  	}
X***************
X*** 281,286 ****
X--- 284,290 ----
X  	    obj->otyp == KEY || obj->otyp == SKELETON_KEY ||
X  	    obj->otyp == LARGE_BOX || obj->otyp == CHEST))
X  		obj->spe = (obj->olet == WAND_SYM) ? -1 : 0;
X+ 
X  	if (obj->olet == SCROLL_SYM
X  #ifdef MAIL
X  	    && obj->otyp != SCR_MAIL
X***************
X*** 287,296 ****
X  #endif
X  	   )
X  	    obj->otyp = SCR_BLANK_PAPER;
X  	if (obj->olet == POTION_SYM && obj->otyp > POT_BOOZE)
X! 	    obj->otyp = (obj->otyp==POT_SICKNESS) ? POT_FRUIT_JUICE : POT_WATER;
X  	    /* sickness is "biologically contaminated" fruit juice; cancel it
X! 	     * and it just becomes fruit juice...
X  	     */
X  	obj->blessed = obj->cursed = FALSE;
X  }
X--- 291,302 ----
X  #endif
X  	   )
X  	    obj->otyp = SCR_BLANK_PAPER;
X+ 
X  	if (obj->olet == POTION_SYM && obj->otyp > POT_BOOZE)
X! 	    obj->otyp = (obj->otyp==POT_SICKNESS || obj->otyp==POT_SEE_INVISIBLE) ? POT_FRUIT_JUICE : POT_WATER;
X  	    /* sickness is "biologically contaminated" fruit juice; cancel it
X! 	     * and it just becomes fruit juice... whereas see invisible
X! 	     * tastes like "enchanted" fruit juice, it similarly cancels.
X  	     */
X  	obj->blessed = obj->cursed = FALSE;
X  }
X***************
X*** 311,319 ****
X  	return 1;
X  }
X  
X! #ifndef OVERLAY
X! static 
X! #endif
X  int
X  bhito(obj, otmp)	/* object obj was hit by the effect of wand otmp */
X  register struct obj *obj, *otmp;	/* returns TRUE if sth was done */
X--- 317,323 ----
X  	return 1;
X  }
X  
X! STATIC_PTR
X  int
X  bhito(obj, otmp)	/* object obj was hit by the effect of wand otmp */
X  register struct obj *obj, *otmp;	/* returns TRUE if sth was done */
X***************
X*** 329,336 ****
X  #ifdef SPELLS
X  	case SPE_POLYMORPH:
X  #endif
X  		/* preserve symbol and quantity */
X! 		otmp2 = mkobj_at(obj->olet, obj->ox, obj->oy);
X  		otmp2->quan = obj->quan;
X  #ifdef MAIL
X  		/* You can't send yourself 100 mail messages and then
X--- 333,343 ----
X  #ifdef SPELLS
X  	case SPE_POLYMORPH:
X  #endif
X+ 		/* avoid unicorn/tool abuse */
X+ 		if (obj->otyp == UNICORN_HORN) obj->olet = WEAPON_SYM;
X+ 
X  		/* preserve symbol and quantity */
X! 		otmp2 = mkobj_at(obj->olet, obj->ox, obj->oy, FALSE);
X  		otmp2->quan = obj->quan;
X  #ifdef MAIL
X  		/* You can't send yourself 100 mail messages and then
X***************
X*** 347,356 ****
X  		/* Amulet gets cheap   stewr 870807 */
X  		if (obj->otyp == AMULET_OF_YENDOR) otmp2->spe = -1;
X  
X- 		/* Wands of wishing max 3 stewr 870808 */
X- 		if ((otmp2->otyp == WAN_WISHING)
X- 		    && (obj->spe > 3)) otmp2->spe = 3;
X- 
X  		otmp2->cursed = obj->cursed;
X  		otmp2->blessed = obj->blessed;
X  		otmp2->rustfree = obj->rustfree;
X--- 354,359 ----
X***************
X*** 389,405 ****
X  		    }
X  		}
X  
X- 		/* no named weapons --KAA */
X- 		if (otmp2->onamelth) {
X- 			otmp2 = oname(otmp2, "", 0);
X- 			fobj = otmp2;
X- 			/* cannot use place_object() */
X- 			level.objects[otmp2->ox][otmp2->oy] = otmp2;
X- 		}
X- 
X  		/* no box contents --KAA */
X  		if (Is_container(otmp2)) delete_contents(otmp2);
X  
X  		/* update the weight */
X  		otmp2->owt = weight(otmp2);
X  		delobj(obj);
X--- 392,407 ----
X  		    }
X  		}
X  
X  		/* no box contents --KAA */
X  		if (Is_container(otmp2)) delete_contents(otmp2);
X  
X+ 		if(otmp2->otyp == MAGIC_LAMP) otmp2->otyp = LAMP;
X+ 
X+ 		if(otmp2->otyp == WAN_WISHING)
X+ 			while(otmp2->otyp == WAN_WISHING ||
X+ 			      otmp2->otyp == WAN_POLYMORPH)
X+ 			    otmp2->otyp = rnd_class(WAN_LIGHT, WAN_LIGHTNING);
X+ 
X  		/* update the weight */
X  		otmp2->owt = weight(otmp2);
X  		delobj(obj);
X***************
X*** 529,535 ****
X  	useup(otmp);
X  }
X  
X! static const char zap_syms[] = { WAND_SYM, 0 };
X  
X  int
X  dozap()
X--- 531,537 ----
X  	useup(otmp);
X  }
X  
X! static const char NEARDATA zap_syms[] = { WAND_SYM, 0 };
X  
X  int
X  dozap()
X***************
X*** 605,610 ****
X--- 607,614 ----
X  #endif /* GOLEMS */
X  #endif
X  		    }
X+ 		    destroy_item(WAND_SYM, AD_ELEC);
X+ 		    destroy_item(RING_SYM, AD_ELEC);
X  		    if(!Blind) {
X  			    You("are blinded by the flash!");
X  			    make_blinded((long)rnd(100),FALSE);
X***************
X*** 706,712 ****
X  		    find_ac();
X  		    break;
X  	       case WAN_MAKE_INVISIBLE:
X! 		    if (!Invisible) makeknown(WAN_MAKE_INVISIBLE);
X  		    HInvis |= INTRINSIC;
X  		    if (!See_invisible) newsym(u.ux, u.uy);
X  		    break;
X--- 710,717 ----
X  		    find_ac();
X  		    break;
X  	       case WAN_MAKE_INVISIBLE:
X! 		    if (!Invis && !See_invisible)
X! 			makeknown(WAN_MAKE_INVISIBLE);
X  		    HInvis |= INTRINSIC;
X  		    if (!See_invisible) newsym(u.ux, u.uy);
X  		    break;
X***************
X*** 823,832 ****
X  		    else
X  #endif
X  		    {
X! 			register struct obj *otmp, *otmp2;
X  
X  			if(levl[u.ux][u.uy].gmask)
X  				(void) bhitgold(g_at(u.ux, u.uy), obj);
X  			for(otmp = level.objects[u.ux][u.uy];
X  							otmp; otmp = otmp2) {
X  				/* changed by GAN to hit all objects there */
X--- 828,852 ----
X  		    else
X  #endif
X  		    {
X! 			register struct obj *otmp, *otmp2 = (struct obj *)0;
X  
X  			if(levl[u.ux][u.uy].gmask)
X  				(void) bhitgold(g_at(u.ux, u.uy), obj);
X+ 			/* pre-reverse the polymorph pile,  -dave- 3/90 */
X+ 			if (obj->otyp == WAN_POLYMORPH
X+ #ifdef SPELLS
X+ 				|| obj->otyp == SPE_POLYMORPH
X+ #endif
X+ 								) {
X+ 				otmp = level.objects[u.ux][u.uy];
X+ 				level.objects[u.ux][u.uy] = otmp2;
X+ 				while(otmp) {
X+ 					otmp2 = otmp->nexthere;
X+ 					otmp->nexthere = level.objects[u.ux][u.uy];
X+ 					level.objects[u.ux][u.uy] = otmp;
X+ 					otmp = otmp2;
X+ 				}
X+ 			}
X  			for(otmp = level.objects[u.ux][u.uy];
X  							otmp; otmp = otmp2) {
X  				/* changed by GAN to hit all objects there */
X***************
X*** 909,914 ****
X--- 929,937 ----
X  				stackobj(fobj);
X  				if(Invisible) newsym(u.ux, u.uy);
X  			    } else {
X+ #ifdef MACOS
X+ 				segments |= SEG_ZAP;
X+ #endif
X  				dighole();
X  			    }
X  			    break;
X***************
X*** 1075,1081 ****
X  # ifdef SPELLS
X  			case SPE_KNOCK:
X  # endif
X! 			    (void) open_drawbridge(x,y);
X  			    break;
X  			case WAN_LOCKING:
X  # ifdef SPELLS
X--- 1098,1105 ----
X  # ifdef SPELLS
X  			case SPE_KNOCK:
X  # endif
X! 			    if (is_db_wall(bhitpos.x, bhitpos.y))
X! 				(void) open_drawbridge(x,y);
X  			    break;
X  			case WAN_LOCKING:
X  # ifdef SPELLS
X***************
X*** 1087,1093 ****
X  # ifdef SPELLS
X  			case SPE_FORCE_BOLT:
X  # endif
X! 			    destroy_drawbridge(x,y);
X  		    }
X  #endif /* STRONGHOLD /**/
X  		if(MON_AT(bhitpos.x, bhitpos.y)){
X--- 1111,1119 ----
X  # ifdef SPELLS
X  			case SPE_FORCE_BOLT:
X  # endif
X! 			    if (levl[bhitpos.x][bhitpos.y].typ != 
X! 			   	DRAWBRIDGE_UP)
X! 			        destroy_drawbridge(x,y);
X  		    }
X  #endif /* STRONGHOLD /**/
X  		if(MON_AT(bhitpos.x, bhitpos.y)){
X***************
X*** 1102,1111 ****
X  		/* modified by GAN to hit all objects */
X  		if(fhito){
X  		    int hitanything = 0;
X! 		    register struct obj *next_obj;
X  
X  		    if((fhito == bhito) && levl[bhitpos.x][bhitpos.y].gmask)
X  			hitanything += bhitgold(g_at(bhitpos.x,bhitpos.y),obj);
X  		    for(otmp = level.objects[bhitpos.x][bhitpos.y];
X  							otmp; otmp = next_obj) {
X  			/* Fix for polymorph bug, Tim Wright */
X--- 1128,1152 ----
X  		/* modified by GAN to hit all objects */
X  		if(fhito){
X  		    int hitanything = 0;
X! 		    register struct obj *next_obj = (struct obj *)0;
X  
X  		    if((fhito == bhito) && levl[bhitpos.x][bhitpos.y].gmask)
X  			hitanything += bhitgold(g_at(bhitpos.x,bhitpos.y),obj);
X+ 		    /* pre-reverse the polymorph pile,  -dave- 3/90 */
X+ 		    if (obj->otyp == WAN_POLYMORPH
X+ #ifdef SPELLS
X+ 			    || obj->otyp == SPE_POLYMORPH
X+ #endif
X+ 							) {
X+ 			otmp = level.objects[bhitpos.x][bhitpos.y];
X+ 			level.objects[bhitpos.x][bhitpos.y] = next_obj;
X+ 			while(otmp) {
X+ 			    next_obj = otmp->nexthere;
X+ 			    otmp->nexthere = level.objects[bhitpos.x][bhitpos.y];
X+ 			    level.objects[bhitpos.x][bhitpos.y] = otmp;
X+ 			    otmp = next_obj; 
X+ 			}
X+ 		    }
X  		    for(otmp = level.objects[bhitpos.x][bhitpos.y];
X  							otmp; otmp = next_obj) {
X  			/* Fix for polymorph bug, Tim Wright */
X***************
X*** 1334,1341 ****
X  #endif
X  		if (obj->otyp == SCR_FIRE
X  #ifdef SPELLS
X! 					|| obj->otyp == SPE_FIREBALL)
X  #endif
X  		    continue;
X  		scrquan = obj->quan;
X  		for(i = 1; i <= scrquan ; i++)
X--- 1375,1383 ----
X  #endif
X  		if (obj->otyp == SCR_FIRE
X  #ifdef SPELLS
X! 					|| obj->otyp == SPE_FIREBALL
X  #endif
X+ 		    )
X  		    continue;
X  		scrquan = obj->quan;
X  		for(i = 1; i <= scrquan ; i++)
X***************
X*** 1430,1436 ****
X--- 1472,1485 ----
X  		if(abstype == 1 /* fire */ &&
X  		   (is_pool(sx,sy) || (lev->typ == ROOM && lev->icedpool))) {
X  		    if(lev->typ == ROOM) {
X+ #ifdef STUPID
X+ 			if (lev->icedpool == ICED_POOL)
X+ 				lev->typ = POOL;
X+ 			else
X+ 				lev->typ = MOAT;
X+ #else
X  			lev->typ = (lev->icedpool == ICED_POOL ? POOL : MOAT);
X+ #endif
X  			lev->icedpool = 0;
X  			pline("The ice crackles and melts.");
X  			mnewsym(sx,sy);
X***************
X*** 1713,1718 ****
X--- 1762,1771 ----
X  #endif
X  				    } else
X  					dam = d(nd, 6);
X+ 				    if(!rn2(3))
X+ 					destroy_item(WAND_SYM, AD_ELEC);
X+ 				    if(!rn2(3))
X+ 					destroy_item(RING_SYM, AD_ELEC);
X  				    break;
X  				case 6:		/* poison */
X  				    poisoned("blast", A_DEX, "poisoned blast", 15);
X***************
X*** 1807,1815 ****
X  		ty = rn2(ROWNO);
X  	} while(!goodpos(tx,ty,(struct permonst *)0));
X  	move_object(obj, tx, ty);
X! 	if(cansee(otx,oty))
X  		newsym(otx,oty);
X! 	if(cansee(tx,ty))
X  		newsym(tx,ty);
X  }
X  
X--- 1860,1872 ----
X  		ty = rn2(ROWNO);
X  	} while(!goodpos(tx,ty,(struct permonst *)0));
X  	move_object(obj, tx, ty);
X! 	mnewsym(otx, oty);
X! 	if(cansee(otx,oty) && !vism_at(otx,oty) && !Blind &&
X! 			(Invisible || u.ux != otx || u.uy != oty))
X  		newsym(otx,oty);
X! 	mnewsym(tx, ty);
X! 	if(cansee(tx,ty) && !vism_at(tx,ty) && !Blind &&
X! 			(Invisible || u.ux != tx || u.uy != ty))
X  		newsym(tx,ty);
X  }
X  
X***************
X*** 1823,1828 ****
X--- 1880,1886 ----
X  	obj->owt = weight(obj);
X  	obj->olet = GEM_SYM;
X  	obj->known = FALSE;
X+ 	obj->onamelth = 0;		/* no names */
X  	if(cansee(obj->ox,obj->oy))
X  		prl(obj->ox,obj->oy);
X  }
X***************
X*** 1844,1852 ****
X  	if (obj->spe) {
X  	    struct obj *magazine;
X  #ifdef SPELLS
X! 	    magazine = mkobj_at(SPBOOK_SYM, obj->ox, obj->oy);
X  #else
X! 	    magazine = mkobj_at(SCROLL_SYM, obj->ox, obj->oy);
X  #endif
X  	    magazine->blessed = obj->blessed;
X  	    magazine->cursed = obj->cursed;
X--- 1902,1910 ----
X  	if (obj->spe) {
X  	    struct obj *magazine;
X  #ifdef SPELLS
X! 	    magazine = mkobj_at(SPBOOK_SYM, obj->ox, obj->oy, TRUE);
X  #else
X! 	    magazine = mkobj_at(SCROLL_SYM, obj->ox, obj->oy, TRUE);
X  #endif
X  	    magazine->blessed = obj->blessed;
X  	    magazine->cursed = obj->cursed;
X***************
X*** 1955,1961 ****
X  				  : destroy_strings[dindx*3]);
X  		if(osym == POTION_SYM && dmgtyp != AD_COLD)
X  		    potionbreathe(obj);
X! 		for(i = 0; i < cnt; i++) useup(obj);
X  		if(dmg) {
X  		    if(xresist)	You("aren't hurt!");
X  		    else	losehp(dmg,
X--- 2013,2022 ----
X  				  : destroy_strings[dindx*3]);
X  		if(osym == POTION_SYM && dmgtyp != AD_COLD)
X  		    potionbreathe(obj);
X! 		for(i = 0; i < cnt; i++) {
X! 		    if (obj->owornmask) setnotworn(obj);
X! 		    useup(obj);
X! 		}
X  		if(dmg) {
X  		    if(xresist)	You("aren't hurt!");
X  		    else	losehp(dmg,
X***************
X*** 2107,2113 ****
X  {
X  	char buf[BUFSZ];
X  	register struct obj *otmp;
X! 	int wishquan, mergquan;
X  	register boolean dropit = (inv_cnt() >= 52);
X  	int tries = 0;
X  
X--- 2168,2174 ----
X  {
X  	char buf[BUFSZ];
X  	register struct obj *otmp;
X! 	unsigned wishquan, mergquan;
X  	register boolean dropit = (inv_cnt() >= 52);
X  	int tries = 0;
X  
X*** auxil/Old/rumors.fal	Sun Jun  3 09:40:57 1990
X--- auxil/rumors.fal	Fri Apr 13 18:48:06 1990
X***************
X*** 149,163 ****
X  The longer the wand the better.
X  The use of dynamite is dangerous.
X  They say that Demogorgon, Asmodeus, Orcus, Yeenoghu & Juiblex is no law firm.
X  They say that Medusa would make a terrible pet.
X! They say that Nethack comes in 256 flavors.
X! They say that Nethack is just a computer game.
X! They say that Nethack is more than just a computer game.
X  They say that a black pudding is simply a brown pudding gone bad.
X  They say that a black sheep has 3 bags full of wool.
X  They say that a blank scroll is like a blank check.
X  They say that a cat named Morris has nine lives.
X  They say that a desperate shopper might pay any price in a shop.
X  They say that a dwarf lord can carry a pick-axe because his armor is light.
X  They say that a floating eye can defeat Medusa.
X  They say that a fortune only has 1 line and you can't read between it.
X--- 149,168 ----
X  The longer the wand the better.
X  The use of dynamite is dangerous.
X  They say that Demogorgon, Asmodeus, Orcus, Yeenoghu & Juiblex is no law firm.
X+ They say that Geryon has an evil twin, beware!
X  They say that Medusa would make a terrible pet.
X! They say that NetHack bugs are Seldon planned.
X! They say that NetHack comes in 256 flavors.
X! They say that NetHack is just a computer game.
X! They say that NetHack is more than just a computer game.
X! They say that NetHack is never what it used to be.
X! They say that a baby dragon is too small to hurt or help you.
X  They say that a black pudding is simply a brown pudding gone bad.
X  They say that a black sheep has 3 bags full of wool.
X  They say that a blank scroll is like a blank check.
X  They say that a cat named Morris has nine lives.
X  They say that a desperate shopper might pay any price in a shop.
X+ They say that a diamond dog is everybody's best friend.
X  They say that a dwarf lord can carry a pick-axe because his armor is light.
X  They say that a floating eye can defeat Medusa.
X  They say that a fortune only has 1 line and you can't read between it.
X***************
X*** 164,180 ****
X--- 169,191 ----
X  They say that a fortune only has 1 line, but you can read between it.
X  They say that a fountain looks nothing like a regularly erupting geyser.
X  They say that a gold doubloon is worth more than its weight in gold.
X+ They say that a grid bug won't pay a shopkeeper for zapping you in a shop.
X  They say that a gypsy could tell your fortune for a price.
X  They say that a hacker named Alice once level teleported by using a mirror.
X  They say that a hacker named David once slew a giant with a sling and a rock.
X  They say that a hacker named Dorothy once rode a fog cloud to Oz.
X  They say that a hacker named Mary once lost a white sheep in the mazes.
X+ They say that a helm of brilliance is not to be taken lightly.
X+ They say that a hot dog and a hell hound are the same thing.
X  They say that a lamp named Aladdin contains a djinni with 3 wishes.
X  They say that a large dog named Lassie will lead you to the amulet.
X  They say that a long sword is not a light sword.
X+ They say that a manes won't mince words with you.
X+ They say that a mind is a terrible thing to waste.
X  They say that a plain nymph will only wear a wire ring in one ear.
X  They say that a plumed hat could be a previously used crested helmet.
X  They say that a potion of oil is difficult to grasp.
X+ They say that a potion of yogurt is a cancelled potion of sickness.
X  They say that a purple worm is not a baby purple dragon.
X  They say that a quivering blob tastes different than a gelatinous cube.
X  They say that a scroll of summoning has other names.
X***************
X*** 184,196 ****
X  They say that a spear will hit a neo-otyugh.  (Do YOU know what that is?)
X  They say that a spotted dragon is the ultimate shape changer.
X  They say that a stethoscope is no good if you can only hear your heartbeat.
X! They say that a succubus named Suzzy will sometimes warn you of danger.
X  They say that a wand of cancellation is not like a wand of polymorph.
X  They say that after killing a dragon its time for a change of scenery.
X  They say that an attic is the best place to hide your toys.
X  They say that an eye of newt and a wing of bat are double the trouble.
X  They say that an incubus named Izzy sometimes makes women feel sensitive.
X  They say that an unlucky hacker once had a nose bleed at an altar and died.
X  They say that any quantum mechanic knows that speed kills.
X  They say that applying a unicorn horn means you've missed the point.
X  They say that blue stones are radioactive, beware.
X--- 195,213 ----
X  They say that a spear will hit a neo-otyugh.  (Do YOU know what that is?)
X  They say that a spotted dragon is the ultimate shape changer.
X  They say that a stethoscope is no good if you can only hear your heartbeat.
X! They say that a succubus named Suzy will sometimes warn you of danger.
X  They say that a wand of cancellation is not like a wand of polymorph.
X+ They say that a wide sword named Stormbringer attracts vortices.
X+ They say that a wood golem named Pinocchio would be easy to control.
X  They say that after killing a dragon its time for a change of scenery.
X+ They say that an amulet of strangulation is worse than ring around the collar.
X  They say that an attic is the best place to hide your toys.
X+ They say that an axe named Cleaver once belonged to a hacker named Beaver.
X  They say that an eye of newt and a wing of bat are double the trouble.
X  They say that an incubus named Izzy sometimes makes women feel sensitive.
X+ They say that an opulent throne room is rarely a place to wish you'd be in.
X  They say that an unlucky hacker once had a nose bleed at an altar and died.
X+ They say that and they say this but they never say never, never!
X  They say that any quantum mechanic knows that speed kills.
X  They say that applying a unicorn horn means you've missed the point.
X  They say that blue stones are radioactive, beware.
X***************
X*** 197,208 ****
X--- 214,229 ----
X  They say that building a dungeon is a team effort.
X  They say that chaotic characters never get a kick out of altars.
X  They say that collapsing a dungeon often creates a panic.
X+ They say that counting your eggs before they hatch shows that you care.
X  They say that dipping a bag of tricks in a fountain won't make it an icebox.
X+ They say that dipping an eel and brown mold in hot water makes bouillabaisse.
X  They say that donating a doubloon is extremely pious charity.
X  They say that eating royal jelly attracts grizzly owlbears.
X  They say that eggs, pancakes and juice are just a mundane breakfast.
X  They say that everyone knows why Medusa stands alone in the dark.
X+ They say that finding a winning strategy is a deliberate move on your part.
X  They say that finding worthless glass is worth something.
X+ They say that fortune cookies are food for thought.
X  They say that gold is only wasted on a pet dragon.
X  They say that good things come to those that wait.
X  They say that if you can't spell then you'll wish you had a spell book.
X***************
X*** 218,233 ****
X  They say that in the dungeon the boorish customer is never right.
X  They say that in the dungeon you don't need a watch to tell time.
X  They say that in the dungeon you need something old, new, burrowed and blue.
X  They say that iron golem plate mail isn't worth wishing for.
X  They say that it takes four quarterstaffs to make one staff.
X  They say that it's not over till the fat ladies sing.
X  They say that it's not over till the fat lady shouts `Off with its head'.
X  They say that kicking a heavy statue is really a dumb move.
X  They say that leprechauns know Latin and you should too.
X  They say that most trolls are born again.
X  They say that naming your cat Garfield will make you more attractive.
X  They say that no one knows everything about everything in the dungeon.
X! They say that no one plays Nethack just for the fun of it.
X  They say that no one really subscribes to rec.games.hack.
X  They say that no one will admit to starting a rumor.
X  They say that nurses sometimes carry scalpels and never use them.
X--- 239,258 ----
X  They say that in the dungeon the boorish customer is never right.
X  They say that in the dungeon you don't need a watch to tell time.
X  They say that in the dungeon you need something old, new, burrowed and blue.
X+ They say that in the dungeon you should always count your blessings.
X  They say that iron golem plate mail isn't worth wishing for.
X  They say that it takes four quarterstaffs to make one staff.
X  They say that it's not over till the fat ladies sing.
X  They say that it's not over till the fat lady shouts `Off with its head'.
X  They say that kicking a heavy statue is really a dumb move.
X+ They say that kicking a valuable gem doesn't seem to make sense.
X  They say that leprechauns know Latin and you should too.
X+ They say that minotaurs get lost outside of the mazes.
X  They say that most trolls are born again.
X  They say that naming your cat Garfield will make you more attractive.
X+ They say that no one has ever walked to hell.
X  They say that no one knows everything about everything in the dungeon.
X! They say that no one plays NetHack just for the fun of it.
X  They say that no one really subscribes to rec.games.hack.
X  They say that no one will admit to starting a rumor.
X  They say that nurses sometimes carry scalpels and never use them.
X***************
X*** 236,242 ****
X  They say that only David can find the zoo!
X  They say that only angels play their harps for their pets.
X  They say that only big spenders carry gold.
X! They say that playing Nethack is like walking into a death trap.
X  They say that problem breathing is best treated by a proper diet.
X  They say that quaffing many potions of levitation can give you a headache.
X  They say that queen bees get that way by eating royal jelly.
X--- 261,269 ----
X  They say that only David can find the zoo!
X  They say that only angels play their harps for their pets.
X  They say that only big spenders carry gold.
X! They say that only female monsters can lay eggs.
X! They say that orc shamans are healthy, wealthy and wise.
X! They say that playing NetHack is like walking into a death trap.
X  They say that problem breathing is best treated by a proper diet.
X  They say that quaffing many potions of levitation can give you a headache.
X  They say that queen bees get that way by eating royal jelly.
X***************
X*** 244,257 ****
X  They say that real hackers always are controlled.
X  They say that real hackers never burn in hell.
X  They say that real hackers never sleep.
X  They say that shopkeepers never sell blessed potions of invisibility.
X  They say that soldiers wear kid gloves and silly helmets.
X  They say that some monsters may kiss your boots to stop your drum playing.
X  They say that sometimes you can be the hit of the party when playing a horn.
X! They say that the Nethack gods generally welcome your sacrifices.
X  They say that the Wizard of Yendor has a death wish.
X  They say that the best time to save your game is now before its too late.
X! They say that the biggest obstacle in Nethack is your mind.
X  They say that the gods are angry when they hit you with objects.
X  They say that the priesthood are specially favored by the gods.
X  They say that the way to make a unicorn happy is to give it what it wants.
X--- 271,287 ----
X  They say that real hackers always are controlled.
X  They say that real hackers never burn in hell.
X  They say that real hackers never sleep.
X+ They say that shopkeepers never carry more than 20 gold pieces, at night.
X  They say that shopkeepers never sell blessed potions of invisibility.
X  They say that soldiers wear kid gloves and silly helmets.
X  They say that some monsters may kiss your boots to stop your drum playing.
X  They say that sometimes you can be the hit of the party when playing a horn.
X! They say that the NetHack gods generally welcome your sacrifices.
X! They say that the Three Rings are named Vilya, Nenya and Narya.
X  They say that the Wizard of Yendor has a death wish.
X+ They say that the `hair of the dog' is sometimes an effective remedy.
X  They say that the best time to save your game is now before its too late.
X! They say that the biggest obstacle in NetHack is your mind.
X  They say that the gods are angry when they hit you with objects.
X  They say that the priesthood are specially favored by the gods.
X  They say that the way to make a unicorn happy is to give it what it wants.
X***************
X*** 259,272 ****
X  They say that there are no skeletons hence there are no skeleton keys.
X  They say that there is a clever rogue in every hacker just dying to escape.
X  They say that there is no such thing as free advice.
X! They say that there is only one way to win at Nethack.
X  They say that there once was a fearsome chaotic samurai named Luk No.
X  They say that there was a time when cursed holy water wasn't water.
X  They say that there's no point in crying over a gray ooze.
X  They say that trapdoors should always be marked 'Caution:  Trap Door'.
X  They say that using an amulet of change isn't a difficult operation.
X  They say that water walking boots are better if you are fast like Hermes.
X  They say that when you wear a circular amulet you might resemble a troll.
X  They say that when your god is angry you should try another one.
X  They say that wielding a unicorn horn takes strength.
X  They say that with speed boots you never worry about hit and run accidents.
X--- 289,304 ----
X  They say that there are no skeletons hence there are no skeleton keys.
X  They say that there is a clever rogue in every hacker just dying to escape.
X  They say that there is no such thing as free advice.
X! They say that there is only one way to win at NetHack.
X  They say that there once was a fearsome chaotic samurai named Luk No.
X  They say that there was a time when cursed holy water wasn't water.
X  They say that there's no point in crying over a gray ooze.
X+ They say that there's only hope left after you've opened Pandora's box.
X  They say that trapdoors should always be marked 'Caution:  Trap Door'.
X  They say that using an amulet of change isn't a difficult operation.
X  They say that water walking boots are better if you are fast like Hermes.
X  They say that when you wear a circular amulet you might resemble a troll.
X+ They say that when you're hungry you can get a pizza in 30 moves or it's free.
X  They say that when your god is angry you should try another one.
X  They say that wielding a unicorn horn takes strength.
X  They say that with speed boots you never worry about hit and run accidents.
X***************
X*** 300,305 ****
X--- 332,338 ----
X  Tridents are for use underwater.
X  Try calling your katana Moulinette.
X  Ulch!  That meat was painted!
X+ Unfortunately, this message was left intentionally blank.
X  Using a morning star in the evening has no effect.
X  Want a hint?  Zap a wand of make invisible on your weapon!
X  Warning:  fortune reading can be hazardous to your health.
X
END_OF_FILE
if test 48346 -ne `wc -c <'patch8.09'`; then
    echo shar: \"'patch8.09'\" unpacked with wrong size!
fi
# end of 'patch8.09'
fi
echo shar: End of archive 14 \(of 24\).
cp /dev/null ark14isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 24 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
