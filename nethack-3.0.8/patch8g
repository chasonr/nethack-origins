Path: utzoo!utgpu!watserv1!watmath!att!rutgers!cs.utexas.edu!uunet!ogicse!zephyr.ens.tek.com!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v10i025:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Patch8g
Message-ID: <5733@tekred.CNA.TEK.COM>
Date: 5 Jun 90 17:53:22 GMT
Sender: news@tekred.CNA.TEK.COM
Lines: 2346
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 10, Issue 25
Archive-name: NetHack3/Patch8g
Patch-To: NetHack3: Volume 7, Issue 56-93



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 7 (of 24)."
# Contents:  patch8.06 vms/oldcrtl.c
# Wrapped by billr@saab on Mon Jun  4 15:27:17 1990
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'patch8.06' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'patch8.06'\"
else
echo shar: Extracting \"'patch8.06'\" \(51445 characters\)
sed "s/^X//" >'patch8.06' <<'END_OF_FILE'
X*** src/Old/pager.c	Sun Jun  3 14:01:35 1990
X--- src/pager.c	Thu May 31 22:11:29 1990
X***************
X*** 26,40 ****
X  #define SEEK_SET 0
X  #endif
X  
X  #ifndef OVLB
X! OSTATIC char hc;
X  #else /* OVLB */
X! XSTATIC char hc = 0;
X! #endif /* OVLB */
X  
X  static void FDECL(page_more, (FILE *,int));
X! OSTATIC boolean FDECL(clear_help, (CHAR_P));
X! OSTATIC boolean FDECL(valid_help, (CHAR_P));
X  static boolean FDECL(pmatch,(const char *,const char *));
X  static boolean FDECL(outspec,(const char *,int));
X  static const char *FDECL(lookat,(int,int,UCHAR_P));
X--- 26,41 ----
X  #define SEEK_SET 0
X  #endif
X  
X+ STATIC_DCL boolean FDECL(clear_help, (CHAR_P));
X+ STATIC_DCL boolean FDECL(valid_help, (CHAR_P));
X+ 
X  #ifndef OVLB
X! STATIC_DCL char hc;
X  #else /* OVLB */
X! STATIC_OVL char NEARDATA hc = 0;
X  
X  static void FDECL(page_more, (FILE *,int));
X! static boolean FDECL(is_swallow_sym, (UCHAR_P));
X  static boolean FDECL(pmatch,(const char *,const char *));
X  static boolean FDECL(outspec,(const char *,int));
X  static const char *FDECL(lookat,(int,int,UCHAR_P));
X***************
X*** 43,50 ****
X  #endif
X  static void NDECL(help_menu);
X  
X- #ifdef OVLB
X- 
X  /*
X   * simple pattern matcher: '*' matches 0 or more characters
X   * returns TRUE if strng matches patrn
X--- 44,49 ----
X***************
X*** 74,79 ****
X--- 73,89 ----
X  }
X  
X  /*
X+  * returns "true" for characters that could represent a monster's stomach
X+  */
X+ 
X+ static boolean
X+ is_swallow_sym(c)
X+ uchar c;
X+ {
X+ 	return (index(" /-\\|", (char)c) != 0);
X+ }
X+ 
X+ /*
X   * print out another possibility for dowhatis. "new" is the possible new
X   * string; "out_flag" indicates whether we really want output, and if
X   * so what kind of output: 0 == no output, 1 == "(or %s)" output. 
X***************
X*** 85,91 ****
X  const char *new;
X  int out_flag;
X  {
X! 	static char old[50];
X  
X  	if (!strcmp(old, new))
X  		return FALSE;		/* don't print the same thing twice */
X--- 95,101 ----
X  const char *new;
X  int out_flag;
X  {
X! 	static char NEARDATA old[50];
X  
X  	if (!strcmp(old, new))
X  		return FALSE;		/* don't print the same thing twice */
X***************
X*** 110,116 ****
X  	register struct monst *mtmp;
X  	register struct obj *otmp;
X  	struct trap *trap;
X! 	static char answer[50];
X  	register char *s, *t;
X  	uchar typ;
X  
X--- 120,126 ----
X  	register struct monst *mtmp;
X  	register struct obj *otmp;
X  	struct trap *trap;
X! 	static char NEARDATA answer[50];
X  	register char *s, *t;
X  	uchar typ;
X  
X***************
X*** 133,138 ****
X--- 143,150 ----
X  			u.mtimedone ? mons[u.umonnum].mname :
X  #endif
X  			pl_character, plname);
X+ 	} else if (u.uswallow && is_swallow_sym(ch)) {
X+ 		Sprintf(answer, "interior of %s", defmonnam(u.ustuck));
X  	} else if (mtmp && !mtmp->mimic)
X  		Sprintf(answer, "%s%s",
X  		   mtmp->mtame ? "tame " :
X***************
X*** 152,158 ****
X  			if (mtmp->mappearance == STRANGE_OBJECT)
X  				Strcpy(answer, "strange object");
X  			else {
X! 				otmp = mksobj((int) mtmp->mappearance,FALSE );
X  				Strcpy(answer, distant_name(otmp, xname));
X  				free((genericptr_t) otmp);
X  			}
X--- 164,175 ----
X  			if (mtmp->mappearance == STRANGE_OBJECT)
X  				Strcpy(answer, "strange object");
X  			else {
X! 				int oindx = mtmp->mappearance;
X! 				otmp = mksobj(oindx,FALSE );
X! 				if(oindx == STATUE || oindx == FIGURINE)
X! 				    otmp->corpsenm = PM_KOBOLD;
X! 				else if (oindx == DRAGON_SCALE_MAIL)
X! 				    otmp->corpsenm = PM_RED_DRAGON;
X  				Strcpy(answer, distant_name(otmp, xname));
X  				free((genericptr_t) otmp);
X  			}
X***************
X*** 263,268 ****
X--- 280,286 ----
X  	boolean oldverb = flags.verbose;
X  	boolean found_in_file = FALSE, need_to_print = FALSE;
X  	int	found = 0;
X+ 	static const char *mon_interior = "the interior of a monster";
X  
X  #ifdef OS2_CODEVIEW
X  	char tmp[PATHLEN];
X***************
X*** 321,329 ****
X  			    return 0;
X  		}
X  		flags.verbose = FALSE;
X! 		q = levl[cc.x][cc.y].scrsym;
X! 		if (!q || (!levl[cc.x][cc.y].seen && !MON_AT(cc.x,cc.y)))
X! 			q = ' ';
X  	}
X  
X  	if (!q)
X--- 339,365 ----
X  			    return 0;
X  		}
X  		flags.verbose = FALSE;
X! 		if (!u.uswallow) {
X! 			q = levl[cc.x][cc.y].scrsym;
X! 			if (!q || (!levl[cc.x][cc.y].seen && !MON_AT(cc.x,cc.y)))
X! 				q = ' ';
X! 		}
X! 		else if (cc.x == u.ux && cc.y == u.uy)
X! 			q = u.usym;
X! 		else {
X! 			i = (u.uy - cc.y)+1;
X! 			if (i < 0 || i > 2)
X! 				q = ' ';
X! 			else {
X! 				firstmatch = (i == 0) ? "/-\\" :
X! 					(i == 1) ? "| |" : "\\-/";
X! 				i = (u.ux - cc.x)+1;
X! 				if (i < 0 || i > 2)
X! 					q = ' ';
X! 				else
X! 					q = firstmatch[i];
X! 			}
X! 		}
X  	}
X  
X  	if (!q)
X***************
X*** 337,343 ****
X  /*
X   * if the user just typed one letter, or we're identifying from the
X   * screen, then we have to check all the possibilities and print them
X!  * out for him/her
X   */
X  
X  /* Check for monsters */
X--- 373,379 ----
X  /*
X   * if the user just typed one letter, or we're identifying from the
X   * screen, then we have to check all the possibilities and print them
X!  * out for him/her.
X   */
X  
X  /* Check for monsters */
X***************
X*** 351,356 ****
X--- 387,406 ----
X  		}
X  	}
X  
X+ /* Special case: if identifying from the screen, and
X+  * we're swallowed, and looking at something other than our own symbol,
X+  * then just say "the interior of a monster".
X+  */
X+ 	if (u.uswallow && is_swallow_sym(q)) {
X+ 		if (!found) {
X+ 			pline("%c       %s", q, mon_interior);
X+ 			(void)outspec(firstmatch=mon_interior, 0);
X+ 		}
X+ 		else
X+ 			(void)outspec(mon_interior, 1);
X+ 		found++; need_to_print = TRUE;
X+ 	}
X+ 
X  /* Now check for objects */
X  	for (i = 0; objsyms[i]; i++) {
X  		if (q == objsyms[i]) {
X***************
X*** 402,407 ****
X--- 452,459 ----
X  
X  checkfile:
X  
X+ 	if (!strncmp(inp, "interior of ", 12))
X+ 		inp += 12;
X  	if (!strncmp(inp, "a ", 2))
X  		inp += 2;
X  	else if (!strncmp(inp, "an ", 3))
X***************
X*** 415,434 ****
X  	if (!strncmp(inp, "invisible ", 10))
X  		inp += 10;
X  
X! 	if ((!q || found) && *inp) {
X  /* adjust the input to remove "named " and convert to lower case */
X   		for (ep = inp; *ep; ) {
X  			if ((!strncmp(ep, " named ", 7) && (alt = ep + 7)) ||
X  			    !strncmp(ep, " called ", 8))
X  				*ep = 0;
X! 			else
X! 				(*ep = tolower(*ep)), ep++;
X  		}
X  
X  /*
X   * If the object is named, then the name is the alternate search string;
X   * otherwise, the result of makesingular() applied to the name is. This
X!  * isn't strictly optimal, but named objects of interest to the user should
X   * will usually be found under their name, rather than under their
X   * object type, so looking for a singular form is pointless.
X   */
X--- 467,495 ----
X  	if (!strncmp(inp, "invisible ", 10))
X  		inp += 10;
X  
X! /*
X!  * look in the file for more info if:
X!  * the user typed in the whole name (!q)
X!  * OR we've found a possible match with the character q (found) and
X!  *    flags.help is TRUE
X!  * and, of course, the name to look for must be non-empty.
X!  */
X! 	if ((!q || (found && flags.help)) && *inp) {
X  /* adjust the input to remove "named " and convert to lower case */
X   		for (ep = inp; *ep; ) {
X  			if ((!strncmp(ep, " named ", 7) && (alt = ep + 7)) ||
X  			    !strncmp(ep, " called ", 8))
X  				*ep = 0;
X! 			else {
X! 				if(isupper(*ep)) *ep = tolower(*ep);
X! 				ep++;
X! 			}
X  		}
X  
X  /*
X   * If the object is named, then the name is the alternate search string;
X   * otherwise, the result of makesingular() applied to the name is. This
X!  * isn't strictly optimal, but named objects of interest to the user
X   * will usually be found under their name, rather than under their
X   * object type, so looking for a singular form is pointless.
X   */
X***************
X*** 436,442 ****
X  		if (!alt)
X  			alt = makesingular(inp);
X  		else
X! 			for (ep = alt; *ep; ep++) *ep = tolower(*ep);
X  
X  		while(fgets(buf,BUFSZ,fp)) {
X  			if(*buf != '\t') {
X--- 497,504 ----
X  		if (!alt)
X  			alt = makesingular(inp);
X  		else
X! 			for (ep = alt; *ep; ep++) 
X! 				if(isupper(*ep)) *ep = tolower(*ep);
X  
X  		while(fgets(buf,BUFSZ,fp)) {
X  			if(*buf != '\t') {
X***************
X*** 555,561 ****
X  }
X  
X  /* make the paging of a file interruptible */
X! static int got_intrup;
X  
X  #if !defined(MSDOS) && !defined(TOS) && !defined(MACOS)
X  static int
X--- 617,623 ----
X  }
X  
X  /* make the paging of a file interruptible */
X! static volatile int NEARDATA got_intrup;
X  
X  #if !defined(MSDOS) && !defined(TOS) && !defined(MACOS)
X  static int
X***************
X*** 572,584 ****
X  FILE *fp;
X  int strip;	/* nr of chars to be stripped from each line (0 or 1) */
X  {
X- 	register char *bufr;
X- #if !defined(MSDOS) && !defined(MINIMAL_TERM)
X- 	register char *ep;
X- #endif
X- #if !defined(MSDOS) && !defined(TOS) && !defined(MACOS)
X- 	int (*prevsig)() = (int (*)())signal(SIGINT, (SIG_RET_TYPE) intruph);
X- #endif
X  #ifdef MACOS
X  	short tmpflags;
X  	
X--- 634,639 ----
X***************
X*** 590,595 ****
X--- 645,657 ----
X  	}
X  	macflags |= (tmpflags & fDoUpdate);
X  #else
X+ 	register char *bufr;
X+ #if !defined(MSDOS) && !defined(MINIMAL_TERM)
X+ 	register char *ep;
X+ #endif
X+ #if !defined(MSDOS) && !defined(TOS)
X+ 	int (*prevsig)() = (int (*)())signal(SIGINT, (SIG_RET_TYPE) intruph);
X+ #endif
X  #if defined(MSDOS) || defined(MINIMAL_TERM)
X  	/* There seems to be a bug in ANSI.SYS  The first tab character
X  	 * after a clear screen sequence is not expanded correctly.  Thus
X***************
X*** 603,608 ****
X--- 665,672 ----
X  	while (fgets(buf, BUFSIZ, fp) && (!strip || *buf == '\t')){
X  		bufp = buf;
X  		bufrp = bufr;
X+ 		if (strip && *bufp && *bufp != '\n')
X+ 			*bufrp++ = *bufp++;
X  		while (*bufp && *bufp != '\n') {
X  			if (*bufp == '\t') {
X  				spaces = tabstop - (bufrp - bufr) % tabstop;
X***************
X*** 631,641 ****
X  ret:
X  	free((genericptr_t) bufr);
X  	(void) fclose(fp);
X! #if !defined(MSDOS) && !defined(TOS) && !defined(MACOS)
X  	(void) signal(SIGINT, (SIG_RET_TYPE) prevsig);
X  	got_intrup = 0;
X  #endif
X! #endif
X  }
X  
X  #endif /* OVLB */
X--- 695,705 ----
X  ret:
X  	free((genericptr_t) bufr);
X  	(void) fclose(fp);
X! #if !defined(MSDOS) && !defined(TOS)
X  	(void) signal(SIGINT, (SIG_RET_TYPE) prevsig);
X  	got_intrup = 0;
X  #endif
X! #endif /* MACOS */
X  }
X  
X  #endif /* OVLB */
X***************
X*** 644,654 ****
X  
X  #ifndef OVLB
X  
X! OSTATIC boolean whole_screen;
X  
X  #else /* OVLB */
X  
X! XSTATIC boolean whole_screen = TRUE;
X  
X  void
X  set_whole_screen() {	/* called in termcap as soon as LI is known */
X--- 708,718 ----
X  
X  #ifndef OVLB
X  
X! STATIC_DCL boolean whole_screen;
X  
X  #else /* OVLB */
X  
X! STATIC_OVL boolean NEARDATA whole_screen = TRUE;
X  
X  void
X  set_whole_screen() {	/* called in termcap as soon as LI is known */
X***************
X*** 674,680 ****
X  #ifdef LINT	/* lint may handle static decl poorly -- static boolean so; */
X  	boolean so;
X  #else
X! 	static boolean so;
X  #endif
X  	if(mode == 0) {
X  		if(!whole_screen) {
X--- 738,744 ----
X  #ifdef LINT	/* lint may handle static decl poorly -- static boolean so; */
X  	boolean so;
X  #else
X! 	static boolean NEARDATA so;
X  #endif
X  	if(mode == 0) {
X  		if(!whole_screen) {
X***************
X*** 688,700 ****
X  		so = flags.standout;
X  		flags.standout = 1;
X  	} else {
X- #ifdef MACOS
X- 		macflags |= fFullScrKluge;
X- #endif
X  		if(mode == 1) {
X- #ifdef MACOS
X- 			macflags |= fCornScrKluge;
X- #endif
X  			curs(1, LI);
X  			more();
X  		}
X--- 752,758 ----
X***************
X*** 705,713 ****
X  			curs(1, ROWNO+4);
X  			cl_eos();
X  		}
X- #ifdef MACOS
X- 		macflags &= ~fScreenKluges;
X- #endif
X  	}
X  }
X  
X--- 763,768 ----
X***************
X*** 718,723 ****
X--- 773,782 ----
X  page_line(s)		/* returns 1 if we should quit */
X  register const char *s;
X  {
X+ #ifdef CLIPPING
X+ /* we assume here that no data files have more than 80 chars/line */
X+ 	static char tmp[81], *t;
X+ #endif
X  	if(cury == LI-1) {
X  		if(!*s)
X  			return(0);	/* suppress blank lines at top */
X***************
X*** 735,740 ****
X--- 794,821 ----
X  			cl_eos();
X  		}
X  	}
X+ #ifdef CLIPPING
X+ /* if lines are too long for the screen, first try stripping leading blanks */
X+ 	if (strlen(s) >= CO) {
X+ 		while (*s == ' ' || *s == '\t') s++;
X+ 	}
X+ 
X+ /* if it's still too long, try compressing blanks */
X+ 	if (strlen(s) >= CO) {
X+ 		t = tmp;
X+ 		while ( (*t = *s) != 0) {
X+ 			if (*t == ' ') {
X+ 				while (*s == ' ')
X+ 					s++;
X+ 			}
X+ 			else
X+ 				s++;
X+ 			t++;
X+ 		}
X+ 		s = tmp;
X+ 	}
X+ #endif /* CLIPPING */
X+ 
X  #ifdef TERMINFO
X  	xputs(s); xputc('\n');
X  #else
X***************
X*** 767,775 ****
X  	static struct line {
X  		struct line *next_line;
X  		char *line_text;
X! 	} *texthead, *texttail;
X! 	static int maxlen;
X! 	static int linect;
X  	register struct line *tl;
X  	register boolean hmenu = FALSE;
X  
X--- 848,856 ----
X  	static struct line {
X  		struct line *next_line;
X  		char *line_text;
X! 	} NEARDATA *texthead, NEARDATA *texttail;
X! 	static int NEARDATA maxlen;
X! 	static int NEARDATA linect;
X  	register struct line *tl;
X  	register boolean hmenu = FALSE;
X  
X***************
X*** 817,833 ****
X  	else
X  	if(mode == 2) {
X  	    register int curline, lth;
X- #ifdef MACOS
X- 		short tmpflags;
X- 		extern struct line *mactexthead;
X- 		extern int macmaxlen, maclinect;
X- 		
X- 		tmpflags = macflags;
X- 		macflags |= fDoUpdate | fDisplayKluge;
X- 		mactexthead = texthead;
X- 		macmaxlen = maxlen;
X- 		maclinect = linect;
X- #endif
X  
X  	    if(flags.toplin == 1) more();	/* ab@unido */
X  	    remember_topl();
X--- 898,903 ----
X***************
X*** 862,870 ****
X  #endif
X  		cl_end ();
X  		if (!hmenu) {
X- #ifdef MACOS
X- 			macflags |= fCornScrKluge;
X- #endif
X  			cmore (text);
X  		}
X  		if (!hmenu || clear_help(hc)) {
X--- 932,937 ----
X***************
X*** 872,886 ****
X  		    cl_end ();
X  		    docorner (lth, curline-1);
X  		}
X  #ifdef MACOS
X! 			mactexthead = NULL;
X! 			macflags |= (tmpflags & (fDoUpdate | fDisplayKluge));
X  #endif
X- 	    } else {					/* feed to pager */
X  		set_pager(0);
X  		for (tl = texthead; tl; tl = tl->next_line) {
X  		    if (page_line (tl->line_text)) {
X  			set_pager(2);
X  			while(tl = texthead) {
X  			    texthead = tl->next_line;
X  			    free((genericptr_t) tl);
X--- 939,958 ----
X  		    cl_end ();
X  		    docorner (lth, curline-1);
X  		}
X+ 	    } else {					/* feed to pager */
X  #ifdef MACOS
X! 		short	tmpflags;
X! 		
X! 		tmpflags = macflags;
X! 		macflags &= ~fDoNonKeyEvt;
X  #endif
X  		set_pager(0);
X  		for (tl = texthead; tl; tl = tl->next_line) {
X  		    if (page_line (tl->line_text)) {
X  			set_pager(2);
X+ #ifdef MACOS
X+ 			macflags = tmpflags;
X+ #endif
X  			while(tl = texthead) {
X  			    texthead = tl->next_line;
X  			    free((genericptr_t) tl);
X***************
X*** 893,898 ****
X--- 965,973 ----
X  			set_pager(2);
X  		} else
X  			set_pager(1);
X+ #ifdef MACOS
X+ 		macflags = tmpflags;
X+ #endif
X  	    }
X  	}
X  
X***************
X*** 966,972 ****
X  	cornline(-1,"");
X  }
X  
X! XSTATIC boolean
X  clear_help(c)
X  char c;
X  {
X--- 1041,1047 ----
X  	cornline(-1,"");
X  }
X  
X! STATIC_OVL boolean
X  clear_help(c)
X  char c;
X  {
X***************
X*** 1004,1010 ****
X  		);
X  }
X  
X! XSTATIC boolean
X  valid_help(c)
X  char c;
X  {
X--- 1079,1085 ----
X  		);
X  }
X  
X! STATIC_OVL boolean
X  valid_help(c)
X  char c;
X  {
X*** src/Old/pickup.c	Sun Jun  3 14:02:35 1990
X--- src/pickup.c	Sun May 27 17:58:15 1990
X***************
X*** 7,26 ****
X   */
X  
X  #include	"hack.h"
X! #ifndef OVERLAY
X! static int FDECL(in_container,(struct obj *));
X! static int FDECL(ck_container,(struct obj *));
X! static int FDECL(ck_bag,(struct obj *));
X! static int FDECL(out_container,(struct obj *));
X! #else
X! int FDECL(in_container,(struct obj *));
X! int FDECL(ck_container,(struct obj *));
X! int FDECL(ck_bag,(struct obj *));
X! int FDECL(out_container,(struct obj *));
X! #endif
X  void FDECL(explode_bag,(struct obj *));
X  
X! #ifdef OVLB
X  
X  static const char nearloadmsg[] = "have a little trouble lifting";
X  
X--- 7,21 ----
X   */
X  
X  #include	"hack.h"
X! STATIC_PTR int FDECL(in_container,(struct obj *));
X! STATIC_PTR int FDECL(ck_container,(struct obj *));
X! STATIC_PTR int FDECL(ck_bag,(struct obj *));
X! STATIC_PTR int FDECL(out_container,(struct obj *));
X  void FDECL(explode_bag,(struct obj *));
X  
X! #define DELTA_CWT(cont) ((cont)->cursed?(obj->owt*2):(obj->owt/((cont)->blessed?4:2)) + 1)
X! 
X! #ifdef OVL0
X  
X  static const char nearloadmsg[] = "have a little trouble lifting";
X  
X***************
X*** 257,265 ****
X  		if(wt > 0) {
X  			if(obj->quan > 1) {
X  				/* see how many we can lift */
X! 				int savequan = obj->quan;
X  				int iw = inv_weight();
X! 				int qq;
X  				for(qq = 1; qq < savequan; qq++){
X  					obj->quan = qq;
X  					if(iw + weight(obj) > 0)
X--- 252,260 ----
X  		if(wt > 0) {
X  			if(obj->quan > 1) {
X  				/* see how many we can lift */
X! 				unsigned savequan = obj->quan;
X  				int iw = inv_weight();
X! 				unsigned qq;
X  				for(qq = 1; qq < savequan; qq++){
X  					obj->quan = qq;
X  					if(iw + weight(obj) > 0)
X***************
X*** 274,280 ****
X  				You("can only carry %s of the %s lying here.",
X  					    (qq == 1) ? "one" : "some",
X  					    doname(obj));
X! 				    obj3 = splitobj(obj, qq);
X  				    if(obj3->otyp == SCR_SCARE_MONSTER)
X  					    if(obj3->spe) obj->spe = 0;
X  				    goto lift_some;
X--- 269,275 ----
X  				You("can only carry %s of the %s lying here.",
X  					    (qq == 1) ? "one" : "some",
X  					    doname(obj));
X! 				    obj3 = splitobj(obj, (int)qq);
X  				    if(obj3->otyp == SCR_SCARE_MONSTER)
X  					    if(obj3->spe) obj->spe = 0;
X  				    goto lift_some;
X***************
X*** 296,303 ****
X  				if(obj->spe) obj->spe = 0;
X  			break;
X  		}
X! 		{ int pickquan = obj->quan;
X! 		  int mergquan;
X  
X  		  obj = pick_obj(obj);
X  		  if(wt > -5) You(nearloadmsg);
X--- 291,298 ----
X  				if(obj->spe) obj->spe = 0;
X  			break;
X  		}
X! 		{ unsigned pickquan = obj->quan;
X! 		  unsigned mergquan;
X  
X  		  obj = pick_obj(obj);
X  		  if(wt > -5) You(nearloadmsg);
X***************
X*** 324,329 ****
X--- 319,327 ----
X  	return(addinv(otmp));    /* might merge it with other objects */
X  }
X  
X+ #endif /* OVL1 */
X+ #ifdef OVLB
X+ 
X  int
X  doloot() {	/* loot a container on the floor. */
X  
X***************
X*** 367,379 ****
X  }
X  
X  static
X! struct obj *current_container;	/* a local variable of use_container, to be
X  				used by its local procedures in/ck_container */
X  #define Icebox (current_container->otyp == ICE_BOX)
X  int baggone;	/* used in askchain so bag isn't used after explosion */
X  
X  #endif /* OVLB */
X! #ifdef OVL0
X  
X  void
X  inc_cwt(cobj, obj)
X--- 365,377 ----
X  }
X  
X  static
X! struct obj NEARDATA *current_container;	/* a local variable of use_container, to be
X  				used by its local procedures in/ck_container */
X  #define Icebox (current_container->otyp == ICE_BOX)
X  int baggone;	/* used in askchain so bag isn't used after explosion */
X  
X  #endif /* OVLB */
X! #ifdef OVL1
X  
X  void
X  inc_cwt(cobj, obj)
X***************
X*** 380,396 ****
X  register struct obj *cobj, *obj;
X  {
X  	if (cobj->otyp == BAG_OF_HOLDING)
X! 		cobj->owt += (cobj->cursed?(obj->owt*2):(obj->owt/(cobj->blessed?4:2)) + 1);
X  	else	cobj->owt += obj->owt;
X  }
X  
X! #endif /* OVL0 */
X  #ifdef OVLB
X  
X! #ifndef OVERLAY
X! static 
X! #endif
X! int
X  in_container(obj)
X  register struct obj *obj;
X  {
X--- 378,391 ----
X  register struct obj *cobj, *obj;
X  {
X  	if (cobj->otyp == BAG_OF_HOLDING)
X! 		cobj->owt += DELTA_CWT(cobj);
X  	else	cobj->owt += obj->owt;
X  }
X  
X! #endif /* OVL1 */
X  #ifdef OVLB
X  
X! STATIC_PTR int
X  in_container(obj)
X  register struct obj *obj;
X  {
X***************
X*** 466,475 ****
X  	return(1);
X  }
X  
X! #ifndef OVERLAY
X! static 
X! #endif
X! int
X  ck_container(obj)
X  register struct obj *obj;
X  {
X--- 461,467 ----
X  	return(1);
X  }
X  
X! STATIC_PTR int
X  ck_container(obj)
X  register struct obj *obj;
X  {
X***************
X*** 479,488 ****
X  /* ck_bag() needs a formal argument to make the overlay/prototype mechanism
X   * work right */
X  /*ARGSUSED*/
X! #ifndef OVERLAY
X! static 
X! #endif
X! int
X  ck_bag(obj)
X  struct obj *obj;
X  {
X--- 471,477 ----
X  /* ck_bag() needs a formal argument to make the overlay/prototype mechanism
X   * work right */
X  /*ARGSUSED*/
X! STATIC_PTR int
X  ck_bag(obj)
X  struct obj *obj;
X  {
X***************
X*** 489,502 ****
X  	return(!baggone);
X  }
X  
X! #ifndef OVERLAY
X! static 
X! #endif
X! int
X  out_container(obj)
X  register struct obj *obj;
X  {
X! 	register struct obj *otmp;
X  	register boolean near_capacity = (inv_weight() > -5);
X  
X  	if(inv_cnt() >= 52) {
X--- 478,488 ----
X  	return(!baggone);
X  }
X  
X! STATIC_PTR int
X  out_container(obj)
X  register struct obj *obj;
X  {
X! 	register struct obj *otmp, *ootmp;
X  	register boolean near_capacity = (inv_weight() > -5);
X  
X  	if(inv_cnt() >= 52) {
X***************
X*** 503,509 ****
X  		pline("You have no room to hold anything else.");
X  		return(0);
X  	}
X! 	if(obj->otyp != LOADSTONE && inv_weight() + (int)obj->owt > 0) {
X  		char buf[BUFSZ];
X  
X  		Strcpy(buf, doname(obj));
X--- 489,498 ----
X  		pline("You have no room to hold anything else.");
X  		return(0);
X  	}
X! 	if(obj->otyp != LOADSTONE && inv_weight() + (int)obj->owt -
X! 	   (carried(current_container) ?
X! 		(current_container->otyp == BAG_OF_HOLDING ?
X! 		    (int)DELTA_CWT(current_container) : (int)obj->owt) : 0) > 0) {
X  		char buf[BUFSZ];
X  
X  		Strcpy(buf, doname(obj));
X***************
X*** 528,558 ****
X  	if (Icebox) obj->age = monstermoves - obj->age;
X  	/* simulated point of time */
X  
X! 	(void) addinv(obj);
X  	if (near_capacity) You("have a little trouble removing");
X! 	prinv(obj);
X  	return 0;
X  }
X  
X- void
X- get_all_from_box() {
X- 	register struct obj *otmp, *cobj, *ootmp, *nxobj;
X- 
X- 	for(otmp = invent; otmp; otmp = otmp->nobj) {
X- 	    cobj = otmp;
X- 	    if(Is_container(otmp)) {
X- 		current_container = otmp;
X- 		for(ootmp=fcobj,nxobj=(fcobj ? fcobj->nobj : 0); ootmp;
X- 			    ootmp=nxobj,nxobj=(ootmp ? ootmp->nobj : 0) )
X- 		    if(ootmp->cobj == cobj)
X- 			(void)out_container(ootmp);
X- 	    }
X- 	}
X- 	return;
X- }
X- 
X  /* for getobj: 0: allow cnt; #: allow all types; %: expect food */
X! static const char frozen_food[] = { '0', '#', FOOD_SYM, 0 };
X  
X  void
X  use_container(obj, held)
X--- 517,530 ----
X  	if (Icebox) obj->age = monstermoves - obj->age;
X  	/* simulated point of time */
X  
X! 	ootmp = addinv(obj);
X  	if (near_capacity) You("have a little trouble removing");
X! 	prinv(ootmp);
X  	return 0;
X  }
X  
X  /* for getobj: 0: allow cnt; #: allow all types; %: expect food */
X! static const char NEARDATA frozen_food[] = { '0', '#', FOOD_SYM, 0 };
X  
X  void
X  use_container(obj, held)
X***************
X*** 662,669 ****
X  dec_cwt(cobj, obj)
X  register struct obj *cobj, *obj;
X  {
X! 	if (Is_mbag(cobj))
X! 		cobj->owt -= (cobj->cursed?(obj->owt*2):(obj->owt/(cobj->blessed?4:2)) + 1);
X  	else	cobj->owt -= obj->owt;
X  
X  	if(cobj->owt < objects[cobj->otyp].oc_weight)
X--- 634,641 ----
X  dec_cwt(cobj, obj)
X  register struct obj *cobj, *obj;
X  {
X! 	if (cobj->otyp == BAG_OF_HOLDING)
X! 		cobj->owt -= DELTA_CWT(cobj);
X  	else	cobj->owt -= obj->owt;
X  
X  	if(cobj->owt < objects[cobj->otyp].oc_weight)
X*** src/Old/polyself.c	Sun Jun  3 14:03:05 1990
X--- src/polyself.c	Thu May 31 22:11:33 1990
X***************
X*** 5,15 ****
X  #include "hack.h"
X  
X  #ifdef POLYSELF
X  static void NDECL(break_armor);
X  static void FDECL(drop_weapon,(int));
X  static void NDECL(skinback);
X  static void NDECL(uunstick);
X- #ifdef OVLB
X  static boolean sticky;
X  #endif /* OVLB */
X  #endif
X--- 5,15 ----
X  #include "hack.h"
X  
X  #ifdef POLYSELF
X+ #ifdef OVLB
X  static void NDECL(break_armor);
X  static void FDECL(drop_weapon,(int));
X  static void NDECL(skinback);
X  static void NDECL(uunstick);
X  static boolean sticky;
X  #endif /* OVLB */
X  #endif
X***************
X*** 629,635 ****
X  #ifdef MACOS
X  			char mac_tbuf[80];
X  			if(!flags.silent) SysBeep(1);
X! 			sprintf(mac_tbuf, "Really confuse %s?", mon_nam(mtmp));
X  			if(UseMacAlertText(128, mac_tbuf) != 1) continue;
X  #else
X  			pline("Really confuse %s? ", mon_nam(mtmp));
X--- 629,635 ----
X  #ifdef MACOS
X  			char mac_tbuf[80];
X  			if(!flags.silent) SysBeep(1);
X! 			Sprintf(mac_tbuf, "Really confuse %s?", mon_nam(mtmp));
X  			if(UseMacAlertText(128, mac_tbuf) != 1) continue;
X  #else
X  			pline("Really confuse %s? ", mon_nam(mtmp));
X***************
X*** 705,710 ****
X--- 705,712 ----
X  }
X  #endif
X  
X+ #endif /* OVLB */
X+ #ifdef OVL1
X  const char *
X  body_part(part)
X  int part;
X***************
X*** 713,745 ****
X  	 * plus the trailing null, after pluralizing (since sometimes a
X  	 * buffer is made a fixed size and must be able to hold it)
X  	 */
X! 	static const char *humanoid_parts[] = { "arm", "eye", "face", "finger",
X  		"fingertip", "foot", "hand", "handed", "head", "leg",
X                  "light headed", "neck", "spine", "toe" };
X  #ifdef POLYSELF
X! 	static const char *jelly_parts[] = { "pseudopod", "dark spot", "front",
X  		"pseudopod extension", "pseudopod extremity",
X  		"pseudopod root", "grasp", "grasped", "cerebral area",
X  		"lower pseudopod", "viscous", "middle", "surface",
X  		"pseudopod extremity" },
X! 	*animal_parts[] = { "forelimb", "eye", "face", "foreclaw", "claw tip",
X  		"rear claw", "foreclaw", "clawed", "head", "rear limb",
X  		"light headed", "neck", "spine", "rear claw tip" },
X! 	*horse_parts[] = { "forelimb", "eye", "face", "forehoof", "hoof tip",
X  		"rear hoof", "foreclaw", "hooved", "head", "rear limb",
X  		"light headed", "neck", "backbone", "rear hoof tip" },
X! 	*sphere_parts[] = { "appendage", "optic nerve", "body", "tentacle",
X  		"tentacle tip", "lower appendage", "tentacle", "tentacled",
X  		"body", "lower tentacle", "rotational", "equator", "body",
X  		"lower tentacle tip" },
X! 	*fungus_parts[] = { "mycelium", "visual area", "front", "hypha",
X  		"hypha", "root", "strand", "stranded", "cap area",
X  		"rhizome", "sporulated", "stalk", "root", "rhizome tip" },
X! 	*vortex_parts[] = { "region", "eye", "front", "minor current",
X  		"minor current", "lower current", "swirl", "swirled",
X  		"central core", "lower current", "addled", "center",
X  		"currents", "edge" },
X! 	*snake_parts[] = { "vestigial limb", "eye", "face", "large scale",
X  		"large scale tip", "rear region", "scale gap", "scale gapped",
X  		"head", "rear region", "light headed", "neck", "length",
X  		"rear scale" };
X--- 715,747 ----
X  	 * plus the trailing null, after pluralizing (since sometimes a
X  	 * buffer is made a fixed size and must be able to hold it)
X  	 */
X! 	static const char NEARDATA *humanoid_parts[] = { "arm", "eye", "face", "finger",
X  		"fingertip", "foot", "hand", "handed", "head", "leg",
X                  "light headed", "neck", "spine", "toe" };
X  #ifdef POLYSELF
X! 	static const char NEARDATA *jelly_parts[] = { "pseudopod", "dark spot", "front",
X  		"pseudopod extension", "pseudopod extremity",
X  		"pseudopod root", "grasp", "grasped", "cerebral area",
X  		"lower pseudopod", "viscous", "middle", "surface",
X  		"pseudopod extremity" },
X! 	NEARDATA *animal_parts[] = { "forelimb", "eye", "face", "foreclaw", "claw tip",
X  		"rear claw", "foreclaw", "clawed", "head", "rear limb",
X  		"light headed", "neck", "spine", "rear claw tip" },
X! 	NEARDATA *horse_parts[] = { "forelimb", "eye", "face", "forehoof", "hoof tip",
X  		"rear hoof", "foreclaw", "hooved", "head", "rear limb",
X  		"light headed", "neck", "backbone", "rear hoof tip" },
X! 	NEARDATA *sphere_parts[] = { "appendage", "optic nerve", "body", "tentacle",
X  		"tentacle tip", "lower appendage", "tentacle", "tentacled",
X  		"body", "lower tentacle", "rotational", "equator", "body",
X  		"lower tentacle tip" },
X! 	NEARDATA *fungus_parts[] = { "mycelium", "visual area", "front", "hypha",
X  		"hypha", "root", "strand", "stranded", "cap area",
X  		"rhizome", "sporulated", "stalk", "root", "rhizome tip" },
X! 	NEARDATA *vortex_parts[] = { "region", "eye", "front", "minor current",
X  		"minor current", "lower current", "swirl", "swirled",
X  		"central core", "lower current", "addled", "center",
X  		"currents", "edge" },
X! 	NEARDATA *snake_parts[] = { "vestigial limb", "eye", "face", "large scale",
X  		"large scale tip", "rear region", "scale gap", "scale gapped",
X  		"head", "rear region", "light headed", "neck", "length",
X  		"rear scale" };
X***************
X*** 761,767 ****
X  #endif
X  }
X  
X! #endif /* OVLB */
X  #ifdef OVL0
X  
X  int
X--- 763,769 ----
X  #endif
X  }
X  
X! #endif /* OVL1 */
X  #ifdef OVL0
X  
X  int
X*** src/Old/potion.c	Sun Jun  3 14:03:42 1990
X--- src/potion.c	Sat Jun  2 19:45:47 1990
X***************
X*** 5,11 ****
X  #include "hack.h"
X  
X  #ifdef OVLB
X! static int nothing, unkn;
X  #endif /* OVLB */
X  
X  #ifdef WORM
X--- 5,14 ----
X  #include "hack.h"
X  
X  #ifdef OVLB
X! static void NDECL(ghost_from_bottle);
X! static boolean FDECL(neutralizes, (struct obj *,struct obj *));
X! 
X! static int NEARDATA nothing, NEARDATA unkn;
X  #endif /* OVLB */
X  
X  #ifdef WORM
X***************
X*** 22,28 ****
X  
X  #ifdef OVLB
X  
X! static const char beverages[] = { POTION_SYM, 0 };
X  
X  void
X  make_confused(xtime,talk)
X--- 25,31 ----
X  
X  #ifdef OVLB
X  
X! static const char NEARDATA beverages[] = { POTION_SYM, 0 };
X  
X  void
X  make_confused(xtime,talk)
X***************
X*** 157,167 ****
X  static void
X  ghost_from_bottle()
X  {
X! 	if(!makemon(&mons[PM_GHOST], u.ux, u.uy)){
X  		pline("This bottle turns out to be empty.");
X  		return;
X  	}
X! 	pline("As you open the bottle, an enormous ghost emerges!");
X  	if(flags.verbose)
X  	    You("are frightened to death, and unable to move.");
X  	nomul(-3);
X--- 160,177 ----
X  static void
X  ghost_from_bottle()
X  {
X! 	struct monst *mtmp = makemon(&mons[PM_GHOST], u.ux, u.uy);
X! 
X! 	if (!mtmp) {
X  		pline("This bottle turns out to be empty.");
X  		return;
X  	}
X! 	if (Blind) {
X! 		pline("As you open the bottle, something emerges.");
X! 		return;
X! 	}
X! 	pline("As you open the bottle, an enormous %s emerges!",
X! 		Hallucination ? rndmonnam() : "ghost");
X  	if(flags.verbose)
X  	    You("are frightened to death, and unable to move.");
X  	nomul(-3);
X***************
X*** 268,273 ****
X--- 278,285 ----
X  			}
X  			if(++i >= A_MAX) i = 0;
X  		    }
X+ 		    if((ABASE(A_STR) == AMAX(A_STR)) && (u.uhs >= 3))
X+ 			losestr(1);		/* kludge - mrs */
X  		}
X  		break;
X  	case POT_HALLUCINATION:
X***************
X*** 342,352 ****
X  			unkn++;
X  			You("have an uneasy feeling...");
X  		} else {
X- 			You("feel self-knowledgeable...");
X  			if (otmp->blessed) {
X  				adjattrib(A_INT, 1, FALSE);
X  				adjattrib(A_WIS, 1, FALSE);
X  			}
X  			more();
X  			enlightenment();
X  			pline("The feeling subsides.");
X--- 354,364 ----
X  			unkn++;
X  			You("have an uneasy feeling...");
X  		} else {
X  			if (otmp->blessed) {
X  				adjattrib(A_INT, 1, FALSE);
X  				adjattrib(A_WIS, 1, FALSE);
X  			}
X+ 			You("feel self-knowledgeable...");
X  			more();
X  			enlightenment();
X  			pline("The feeling subsides.");
X***************
X*** 360,377 ****
X  		else {
X  		     newsym(u.ux,u.uy);
X  		     if(!Blind)
X! 		       pline("Gee!  All of a sudden, you can't see yourself.");
X  		     else
X  		       You("feel rather airy."), unkn++;
X  		}
X  		if (otmp->blessed && !(HInvis & INTRINSIC)) {
X  #ifndef MACOS
X  			pline("Do you want the invisibility to be permanent? ");
X- 			nothing = 0;
X  			if (yn()=='n') HInvis += rn1(15,31);
X  			else HInvis |= INTRINSIC;
X  #else
X- 			nothing = 0;
X  			if (UseMacAlertText(128,
X  				"Do you want the invisibility to be permanent ?")
X  				== 2) HInvis += rn1(15,31);
X--- 372,390 ----
X  		else {
X  		     newsym(u.ux,u.uy);
X  		     if(!Blind)
X! 		       pline(Hallucination ?
X! 			 "Far out, man!  You can see right through yourself!" :
X! 			 "Gee!  All of a sudden, you can't see yourself.");
X  		     else
X  		       You("feel rather airy."), unkn++;
X  		}
X  		if (otmp->blessed && !(HInvis & INTRINSIC)) {
X+ 			nothing = 0;
X  #ifndef MACOS
X  			pline("Do you want the invisibility to be permanent? ");
X  			if (yn()=='n') HInvis += rn1(15,31);
X  			else HInvis |= INTRINSIC;
X  #else
X  			if (UseMacAlertText(128,
X  				"Do you want the invisibility to be permanent ?")
X  				== 2) HInvis += rn1(15,31);
X***************
X*** 520,529 ****
X  		if (otmp->cursed) {
X  			unkn++;
X  			/* they went up a level */
X! 			if(dlevel > 1 && dlevel <= MAXLEVEL) { 
X  				You("rise up, through the ceiling!");
X  				goto_level(dlevel-1, FALSE, FALSE);
X  			} else You("have an uneasy feeling.");
X  			break;
X  		}
X  		pluslvl();
X--- 533,554 ----
X  		if (otmp->cursed) {
X  			unkn++;
X  			/* they went up a level */
X! #ifdef ENDGAME
X! 			if((dlevel > 1  || u.uhave_amulet) &&
X! 							dlevel <= MAXLEVEL) { 
X  				You("rise up, through the ceiling!");
X+ 				goto_level((dlevel==1) ? ENDLEVEL
X+ 					: dlevel-1, FALSE, FALSE);
X+ 			} else You("have an uneasy feeling.");
X+ #else
X+ 			if(dlevel > 1 && dlevel <= MAXLEVEL) {
X+ 				You("rise up, through the ceiling!");
X+ #ifdef MACOS
X+ 				segments |= SEG_POTION;
X+ #endif
X  				goto_level(dlevel-1, FALSE, FALSE);
X  			} else You("have an uneasy feeling.");
X+ #endif
X  			break;
X  		}
X  		pluslvl();
X***************
X*** 740,745 ****
X--- 765,772 ----
X  				if(!Blind)
X  				pline("%s looks healthier.", Monnam(mon));
X  				mon->mhp += d(2,6);
X+ 				if (mon->mhp > mon->mhpmax)
X+ 					mon->mhp = mon->mhpmax;
X  			}
X  		}
X  		/* TO DO: Gremlins multiply when doused with water */
X***************
X*** 1023,1032 ****
X  				return(1);
X  		}
X  
X! 		obj->spe--; /* diluted */
X! 		if (obj->otyp == POT_WATER)
X! 			pline("The mixture bubbles violently, then clears.");
X! 		else {
X  			if (!Blind) {
X  				pline("The mixture looks %s.", objects[obj->otyp].oc_descr);
X  				obj->dknown = 1;
X--- 1050,1061 ----
X  				return(1);
X  		}
X  
X! 		if (obj->otyp == POT_WATER) {
X! 			obj->spe = 0; /* in case it was diluted before */
X! 			pline("The mixture bubbles violently%s.",
X! 				Blind ? "" : ", then clears");
X! 		} else {
X! 			obj->spe--; /* diluted */
X  			if (!Blind) {
X  				pline("The mixture looks %s.", objects[obj->otyp].oc_descr);
X  				obj->dknown = 1;
X***************
X*** 1059,1064 ****
X--- 1088,1094 ----
X  		potion->otyp = POT_WATER;
X  		potion->blessed = 0;
X  		potion->cursed = 0;
X+ 		potion->spe = 0;
X  		return(1);
X  	}
X  
X***************
X*** 1159,1181 ****
X  {
X  	register struct obj	*objs;
X  	register struct monst	*mtmp;
X! 	boolean mfound=FALSE;
X  
X  	if(!fobj) {
X  		for(mtmp = fmon; mtmp; mtmp = mtmp->nmon) {
X! 			if (mtmp->minvent) {
X! 				/* OK, it's used for 2 different things */
X! 				mfound = TRUE;
X  				break;
X  			}
X  		}
X! 		if (!mfound) {
X  			if (otmp)
X  			    strange_feeling(otmp, "You feel a pull downward.");
X  			return(1);
X  		}
X  	}
X! 	mfound = FALSE;
X  	for(objs = fobj; objs; objs = objs->nobj)
X  		if(objs->ox != u.ux || objs->oy != u.uy)
X  			goto outobjmap;
X--- 1189,1213 ----
X  {
X  	register struct obj	*objs;
X  	register struct monst	*mtmp;
X! 	boolean mfound=FALSE, mofound=FALSE;
X  
X  	if(!fobj) {
X  		for(mtmp = fmon; mtmp; mtmp = mtmp->nmon) {
X! 			/* mofound can be 1 of 2 completely different things,
X! 			 * either of which stops the "strange feeling"...
X! 			 */
X! 			if (mtmp->minvent || (mtmp->mimic && otmp->cursed)) {
X! 				mofound = TRUE;
X  				break;
X  			}
X  		}
X! 		if (!mofound) {
X  			if (otmp)
X  			    strange_feeling(otmp, "You feel a pull downward.");
X  			return(1);
X  		}
X  	}
X! 	if (mofound) goto outobjmap;
X  	for(objs = fobj; objs; objs = objs->nobj)
X  		if(objs->ox != u.ux || objs->oy != u.uy)
X  			goto outobjmap;
X*** src/Old/pray.c	Sun Jun  3 14:04:30 1990
X--- src/pray.c	Sat May 12 16:07:09 1990
X***************
X*** 650,658 ****
X  	    case 6:	pline ("An object appears at your %s!",
X  				makeplural(body_part(FOOT)));
X  #ifdef SPELLS
X! 			bless(mkobj_at(SPBOOK_SYM, u.ux, u.uy));
X  #else
X! 			bless(mkobj_at(SCROLL_SYM, u.ux, u.uy));
X  #endif
X  			break;
X  
X--- 650,658 ----
X  	    case 6:	pline ("An object appears at your %s!",
X  				makeplural(body_part(FOOT)));
X  #ifdef SPELLS
X! 			bless(mkobj_at(SPBOOK_SYM, u.ux, u.uy, TRUE));
X  #else
X! 			bless(mkobj_at(SCROLL_SYM, u.ux, u.uy, TRUE));
X  #endif
X  			break;
X  
X***************
X*** 692,698 ****
X  }
X  
X  #ifdef ENDGAME
X! static const char sacrifice_types[] = { FOOD_SYM, AMULET_SYM, 0 };
X  #endif
X  
X  static void
X--- 692,698 ----
X  }
X  
X  #ifdef ENDGAME
X! static const char NEARDATA sacrifice_types[] = { FOOD_SYM, AMULET_SYM, 0 };
X  #endif
X  
X  static void
X***************
X*** 772,789 ****
X  		} else {
X  			register struct monst *dmon;
X      /* Human sacrifice on a chaotic altar is equivalent to demon summoning */
X! #ifdef THEOLOGY
X  			if (altaralign == U_CHAOTIC)
X  				pline("The blood covers the altar!");
X  			else {
X! #endif
X      pline("The blood floods over the altar, which vanishes in %s cloud!",
X  				  an(Hallucination ? hcolor() : black));
X  				levl[u.ux][u.uy].typ = ROOM;
X  				levl[u.ux][u.uy].altarmask = 0;
X! #ifdef THEOLOGY
X  			}
X! #endif
X  			change_luck(2);
X  			if(Invisible) newsym(u.ux, u.uy);
X  			if(dmon = makemon(&mons[dlord()], u.ux, u.uy)) {
X--- 772,789 ----
X  		} else {
X  			register struct monst *dmon;
X      /* Human sacrifice on a chaotic altar is equivalent to demon summoning */
X! # ifdef THEOLOGY
X  			if (altaralign == U_CHAOTIC)
X  				pline("The blood covers the altar!");
X  			else {
X! # endif
X      pline("The blood floods over the altar, which vanishes in %s cloud!",
X  				  an(Hallucination ? hcolor() : black));
X  				levl[u.ux][u.uy].typ = ROOM;
X  				levl[u.ux][u.uy].altarmask = 0;
X! # ifdef THEOLOGY
X  			}
X! # endif
X  			change_luck(2);
X  			if(Invisible) newsym(u.ux, u.uy);
X  			if(dmon = makemon(&mons[dlord()], u.ux, u.uy)) {
X***************
X*** 817,822 ****
X--- 817,823 ----
X  #ifdef __GNULINT__
X  		else { impossible("Bad unicorn type??"); unicalign = 0; }
X  #endif
X+ #ifdef ALTARS
X  		/* If same as altar, always a very bad action. */
X  		if (unicalign == altaralign) {
X  		    pline("Such an action is an insult to %s!", (unicalign== -1)
X***************
X*** 832,840 ****
X  		    else You("feel you are thoroughly on the right path.");
X  		    u.ualign = ALIGNLIM;
X  		    value += 3;
X! 		} else if (unicalign == u.ualigntyp) {
X  		/* If sacrificing unicorn of your alignment to altar not of */
X  		/* your alignment, your god gets angry and it's a conversion */
X  		    u.ualign = -1;
X  		    value = 1;
X  		} else value += 3;
X--- 833,843 ----
X  		    else You("feel you are thoroughly on the right path.");
X  		    u.ualign = ALIGNLIM;
X  		    value += 3;
X! 		} else
X  		/* If sacrificing unicorn of your alignment to altar not of */
X  		/* your alignment, your god gets angry and it's a conversion */
X+ #endif
X+ 		if (unicalign == u.ualigntyp) {
X  		    u.ualign = -1;
X  		    value = 1;
X  		} else value += 3;
X***************
X*** 959,964 ****
X--- 962,968 ----
X  			You("feel the power of %s increase.",
X  					u_gname());
X  			change_luck(1);
X+ 			/* Yes, this is supposed to be &=, not |= */
X  			levl[u.ux][u.uy].altarmask &= A_SHRINE;
X  			/* the following accommodates stupid compilers */
X  			levl[u.ux][u.uy].altarmask =
X*** src/Old/pri.c	Sun Jun  3 14:05:14 1990
X--- src/pri.c	Thu May 31 22:13:26 1990
X***************
X*** 5,43 ****
X  #define MONATTK_H	/* comment line for pre-compiled headers */
X  /* block some unused #defines to avoid overloading some cpp's */
X  #include "hack.h"
X- #include <ctype.h>  /* for isalpha() */
X  #if defined(ALTARS) && defined(THEOLOGY)
X  #include "epri.h"
X  #endif
X  #include "termcap.h"
X  
X! OSTATIC void FDECL(hilite, (int,int,UCHAR_P, UCHAR_P));
X! OSTATIC void FDECL(cornbot, (int));
X  #ifdef TEXTCOLOR
X! OSTATIC uchar FDECL(mimic_color, (struct monst *));
X  #endif
X  
X! #ifndef ASCIIGRAPH
X  # define g_putch  (void) putchar
X! #endif
X  
X! #ifndef g_putch
X! #ifdef OVL0
X  static boolean GFlag = FALSE; /* graphic flag */
X  #endif /* OVL0 */
X- #endif
X  
X  /* 100 suffices for bot(); must be larger than COLNO */
X  #define MAXCO 100
X! VSTATIC char oldbot1[MAXCO], newbot1[MAXCO];
X! VSTATIC char oldbot2[MAXCO], newbot2[MAXCO];
X  #ifdef OVL2
X! static const char *dispst = "*0#@#0#*0#@#0#*0#@#0#*0#@#0#*0#@#0#*";
X  #endif /* OVL2 */
X  #ifndef OVLB
X! OSTATIC int mrank_sz;
X  #else /* OVLB */
X! XSTATIC int mrank_sz = 0;  /* loaded by max_rank_sz (called in u_init) */
X  #endif /* OVLB */
X  
X  #ifdef CLIPPING
X--- 5,49 ----
X  #define MONATTK_H	/* comment line for pre-compiled headers */
X  /* block some unused #defines to avoid overloading some cpp's */
X  #include "hack.h"
X  #if defined(ALTARS) && defined(THEOLOGY)
X  #include "epri.h"
X  #endif
X  #include "termcap.h"
X  
X! #ifdef OVL0
X! static void FDECL(fillbot, (int,char *,char *));
X! static void NDECL(bot1);
X! static void NDECL(bot2);
X! #endif /* OVL0 */
X! 
X! STATIC_DCL void FDECL(hilite, (int,int,UCHAR_P, UCHAR_P));
X! STATIC_DCL void FDECL(cornbot, (int));
X  #ifdef TEXTCOLOR
X! STATIC_DCL uchar FDECL(mimic_color, (struct monst *));
X  #endif
X  
X! #ifdef OVL0
X! # ifndef ASCIIGRAPH
X  # define g_putch  (void) putchar
X! # endif /* ASCIIGRAPH */
X  
X! # ifndef g_putch
X! static void FDECL(g_putch, (UCHAR_P));
X  static boolean GFlag = FALSE; /* graphic flag */
X+ # endif
X  #endif /* OVL0 */
X  
X  /* 100 suffices for bot(); must be larger than COLNO */
X  #define MAXCO 100
X! STATIC_VAR char NEARDATA oldbot1[MAXCO], NEARDATA newbot1[MAXCO];
X! STATIC_VAR char NEARDATA oldbot2[MAXCO], NEARDATA newbot2[MAXCO];
X  #ifdef OVL2
X! static const char NEARDATA *dispst = "*0#@#0#*0#@#0#*0#@#0#*0#@#0#*0#@#0#*";
X  #endif /* OVL2 */
X  #ifndef OVLB
X! STATIC_DCL int mrank_sz;
X  #else /* OVLB */
X! STATIC_OVL int NEARDATA mrank_sz = 0;  /* loaded by max_rank_sz (called in u_init) */
X  #endif /* OVLB */
X  
X  #ifdef CLIPPING
X***************
X*** 126,131 ****
X--- 132,140 ----
X  #endif
X  }
X  
X+ #endif /* OVLB */
X+ #ifdef OVL0
X+ 
X  #ifdef CLIPPING
X  void
X  cliparound(x, y)
X***************
X*** 160,168 ****
X  }
X  #endif /* CLIPPING */
X  
X- #endif /* OVLB */
X- #ifdef OVL0
X- 
X  /*
X   *  Allow for a different implementation than this...
X   */
X--- 169,174 ----
X***************
X*** 173,179 ****
X  g_putch(ch)
X  uchar ch;
X  {
X! 	if (IBMgraphics)    /* IBM-compatible displays don't need other stuff */
X  		(void) putchar(ch);
X  	else if (ch & 0x80) {
X  		if (!GFlag) {
X--- 179,186 ----
X  g_putch(ch)
X  uchar ch;
X  {
X! 	if (flags.IBMgraphics)
X! 		/* IBM-compatible displays don't need other stuff */
X  		(void) putchar(ch);
X  	else if (ch & 0x80) {
X  		if (!GFlag) {
X***************
X*** 272,278 ****
X  	register const char *ch;
X  	register struct monst *mtmp = 0;
X  
X! 	if((x != u.ux) || (y != u.uy)) {
X  	    if(!(mtmp = m_at(x, y))) {
X  
X  		impossible("shield effect at %d,%d", x, y);
X--- 279,289 ----
X  	register const char *ch;
X  	register struct monst *mtmp = 0;
X  
X! 	nscr();
X! 
X! 	if((x == u.ux) && (y == u.uy)) 
X! 		curs_on_u();
X! 	else {
X  	    if(!(mtmp = m_at(x, y))) {
X  
X  		impossible("shield effect at %d,%d", x, y);
X***************
X*** 429,435 ****
X  #endif /* OVL0 */
X  #ifdef OVLB
X  
X! XSTATIC void
X  cornbot(lth)
X  register int lth;
X  {
X--- 440,446 ----
X  #endif /* OVL0 */
X  #ifdef OVLB
X  
X! STATIC_OVL void
X  cornbot(lth)
X  register int lth;
X  {
X***************
X*** 677,683 ****
X  /* Make sure that there are 18 entries in the rank arrays. */
X  /* 0 and even entries are male ranks, odd entries are female. */
X  
X! static const char *mage_ranks[] = {
X  	"Evoker",
X  	"Evoker",
X  	"Conjurer",
X--- 688,694 ----
X  /* Make sure that there are 18 entries in the rank arrays. */
X  /* 0 and even entries are male ranks, odd entries are female. */
X  
X! static const char NEARDATA *mage_ranks[] = {
X  	"Evoker",
X  	"Evoker",
X  	"Conjurer",
X***************
X*** 698,704 ****
X  	"Mage"
X  };
X  
X! static const char *priest_ranks[] = {
X  	"Aspirant",
X  	"Aspirant",
X  	"Acolyte",
X--- 709,715 ----
X  	"Mage"
X  };
X  
X! static const char NEARDATA *priest_ranks[] = {
X  	"Aspirant",
X  	"Aspirant",
X  	"Acolyte",
X***************
X*** 719,725 ****
X  	"High Priestess"
X  };
X  
X! static const char *thief_ranks[] = {
X  	"Footpad",
X  	"Footpad",
X  	"Cutpurse",
X--- 730,736 ----
X  	"High Priestess"
X  };
X  
X! static const char NEARDATA *thief_ranks[] = {
X  	"Footpad",
X  	"Footpad",
X  	"Cutpurse",
X***************
X*** 740,746 ****
X  	"Thief"
X  };
X  
X! static const char *fighter_ranks[] = {
X  	"Stripling",
X  	"Stripling",
X  	"Skirmisher",
X--- 751,757 ----
X  	"Thief"
X  };
X  
X! static const char NEARDATA *fighter_ranks[] = {
X  	"Stripling",
X  	"Stripling",
X  	"Skirmisher",
X***************
X*** 761,767 ****
X  	"Lady"
X  };
X  
X! static const char *tourist_ranks[] = {
X  	"Rambler",
X  	"Rambler",
X  	"Sightseer",
X--- 772,778 ----
X  	"Lady"
X  };
X  
X! static const char NEARDATA *tourist_ranks[] = {
X  	"Rambler",
X  	"Rambler",
X  	"Sightseer",
X***************
X*** 782,788 ****
X  	"Adventurer"
X  };
X  
X! static const char *nomad_ranks[] = {
X  	"Troglodyte",
X  	"Troglodyte",
X  	"Aborigine",
X--- 793,799 ----
X  	"Adventurer"
X  };
X  
X! static const char NEARDATA *nomad_ranks[] = {
X  	"Troglodyte",
X  	"Troglodyte",
X  	"Aborigine",
X***************
X*** 803,809 ****
X  	"Pioneer"
X  };
X  
X! static const char *knight_ranks[] = {
X  	"Gallant",
X  	"Gallant",
X  	"Esquire",
X--- 814,820 ----
X  	"Pioneer"
X  };
X  
X! static const char NEARDATA *knight_ranks[] = {
X  	"Gallant",
X  	"Gallant",
X  	"Esquire",
X***************
X*** 824,830 ****
X  	"Paladin"
X  };
X  
X! static const char *archeo_ranks[] = {
X  	"Digger",
X  	"Digger",
X  	"Field Worker",
X--- 835,841 ----
X  	"Paladin"
X  };
X  
X! static const char NEARDATA *archeo_ranks[] = {
X  	"Digger",
X  	"Digger",
X  	"Field Worker",
X***************
X*** 845,851 ****
X  	"Curator"
X  };
X  
X! static const char *healer_ranks[] = {
X  	"Pre-Med",
X  	"Pre-Med",
X  	"Med Student",
X--- 856,862 ----
X  	"Curator"
X  };
X  
X! static const char NEARDATA *healer_ranks[] = {
X  	"Pre-Med",
X  	"Pre-Med",
X  	"Med Student",
X***************
X*** 866,872 ****
X  	"Chief Surgeon"
X  };
X  
X! static const char *barbarian_ranks[] = {
X  	"Plunderer",
X  	"Plunderess",
X  	"Pillager",
X--- 877,883 ----
X  	"Chief Surgeon"
X  };
X  
X! static const char NEARDATA *barbarian_ranks[] = {
X  	"Plunderer",
X  	"Plunderess",
X  	"Pillager",
X***************
X*** 887,893 ****
X  	"Conqueress"
X  };
X  
X! static const char *ninja_ranks[] = {
X  	"Chigo",
X  	"Chigo",
X  	"Bushi",
X--- 898,904 ----
X  	"Conqueress"
X  };
X  
X! static const char NEARDATA *ninja_ranks[] = {
X  	"Chigo",
X  	"Chigo",
X  	"Bushi",
X***************
X*** 908,914 ****
X  	"Jonin",
X  };
X  
X! static const char *elf_ranks[] = {
X  	"Edhel",
X  	"Elleth",
X  	"Edhel",
X--- 919,925 ----
X  	"Jonin",
X  };
X  
X! static const char NEARDATA *elf_ranks[] = {
X  	"Edhel",
X  	"Elleth",
X  	"Edhel",
X***************
X*** 931,941 ****
X  
X  #endif /* OVL1 */
X  
X! OSTATIC const char **NDECL(rank_array);
X  
X  #ifdef OVL1
X  
X! XSTATIC const char **
X  rank_array() {
X  	register const char **ranks;
X  
X--- 942,952 ----
X  
X  #endif /* OVL1 */
X  
X! STATIC_DCL const char **NDECL(rank_array);
X  
X  #ifdef OVL1
X  
X! STATIC_OVL const char **
X  rank_array() {
X  	register const char **ranks;
X  
X***************
X*** 959,969 ****
X  
X  #endif /* OVL1 */
X  
X! OSTATIC const char *rank();
X  
X  #ifdef OVL1
X  
X! XSTATIC const char *
X  rank() {
X  	register int place;
X  	register const char **ranks = rank_array();
X--- 970,980 ----
X  
X  #endif /* OVL1 */
X  
X! STATIC_DCL const char *NDECL(rank);
X  
X  #ifdef OVL1
X  
X! STATIC_OVL const char *
X  rank() {
X  	register int place;
X  	register const char **ranks = rank_array();
X***************
X*** 1261,1267 ****
X   * user programmable
X   */
X  
X! static const char rndobs[] = {
X  	WEAPON_SYM, ARMOR_SYM, POTION_SYM, SCROLL_SYM, WAND_SYM,
X  #ifdef SPELLS
X  	SPBOOK_SYM,
X--- 1272,1278 ----
X   * user programmable
X   */
X  
X! static const char NEARDATA rndobs[] = {
X  	WEAPON_SYM, ARMOR_SYM, POTION_SYM, SCROLL_SYM, WAND_SYM,
X  #ifdef SPELLS
X  	SPBOOK_SYM,
X***************
X*** 1274,1280 ****
X  	return rndobs[rn2(SIZE(rndobs))];
X  }
X  
X! static const char *hcolors[] = {
X  			"ultraviolet", "infrared", "hot pink", "psychedelic",
X  			"bluish-orange", "reddish-green", "dark white",
X  			"light black", "loud", "salty", "sweet", "sour",
X--- 1285,1291 ----
X  	return rndobs[rn2(SIZE(rndobs))];
X  }
X  
X! static const char NEARDATA *hcolors[] = {
X  			"ultraviolet", "infrared", "hot pink", "psychedelic",
X  			"bluish-orange", "reddish-green", "dark white",
X  			"light black", "loud", "salty", "sweet", "sour",
X***************
X*** 1297,1303 ****
X  #ifdef OVL0
X  
X  /*ARGSUSED*/
X! XSTATIC void
X  hilite(x, y, let, typ)
X  int x, y;
X  uchar let, typ;
X--- 1308,1314 ----
X  #ifdef OVL0
X  
X  /*ARGSUSED*/
X! STATIC_OVL void
X  hilite(x, y, let, typ)
X  int x, y;
X  uchar let, typ;
X***************
X*** 1446,1452 ****
X  #ifdef TEXTCOLOR
X  /* pick an appropriate color for a mimic imitating an object */
X  
X! XSTATIC uchar
X  mimic_color(mtmp)
X  struct monst *mtmp;
X  {
X--- 1457,1463 ----
X  #ifdef TEXTCOLOR
X  /* pick an appropriate color for a mimic imitating an object */
X  
X! STATIC_OVL uchar
X  mimic_color(mtmp)
X  struct monst *mtmp;
X  {
X*** src/Old/priest.c	Sun Jun  3 14:06:04 1990
X--- src/priest.c	Thu May 31 22:13:29 1990
X***************
X*** 10,15 ****
X--- 10,18 ----
X  #include "eshk.h"
X  #include "epri.h"
X  
X+ #ifdef OVLB
X+ 
X+ #if defined(ALTARS) && defined(THEOLOGY)
X  static boolean FDECL(histemple_at,(struct monst *,int,int));
X  static int FDECL(t_alignment,(struct mkroom *));
X  static boolean FDECL(is_shrined,(struct mkroom *));
X***************
X*** 16,23 ****
X  static boolean FDECL(t_coaligned,(struct mkroom *));
X  struct monst *FDECL(findpriest,(struct mkroom *));
X  static boolean FDECL(p_inhistemple,(struct mkroom *));
X! 
X! #ifdef OVLB
X  
X  /* used for the insides of shk_move and pri_move */
X  int
X--- 19,25 ----
X  static boolean FDECL(t_coaligned,(struct mkroom *));
X  struct monst *FDECL(findpriest,(struct mkroom *));
X  static boolean FDECL(p_inhistemple,(struct mkroom *));
X! #endif
X  
X  /* used for the insides of shk_move and pri_move */
X  int
X***************
X*** 236,252 ****
X  		    cnt--;
X  		}
X  #endif
X! 		if(p_coaligned(priest)) {
X  		    (void) mongets(priest, rn2(2) ? CLOAK_OF_PROTECTION
X  						  : CLOAK_OF_MAGIC_RESISTANCE);
X! #ifdef NAMED_ITEMS
X! 		    otmp = mk_aligned_artifact((unsigned)EPRI(priest)->shralign + 1);
X! 		    if(otmp) {
X! 			otmp->spe = rnd(4);
X! 			mpickobj(priest, otmp);
X! 		    }
X! #endif
X! 		} else {
X  		    if(!rn2(5)) 
X  			otmp = mksobj(CLOAK_OF_MAGIC_RESISTANCE, FALSE); 
X  		    else otmp = mksobj(CLOAK_OF_PROTECTION, FALSE); 
X--- 238,247 ----
X  		    cnt--;
X  		}
X  #endif
X! 		if(p_coaligned(priest))
X  		    (void) mongets(priest, rn2(2) ? CLOAK_OF_PROTECTION
X  						  : CLOAK_OF_MAGIC_RESISTANCE);
X! 		else {
X  		    if(!rn2(5)) 
X  			otmp = mksobj(CLOAK_OF_MAGIC_RESISTANCE, FALSE); 
X  		    else otmp = mksobj(CLOAK_OF_PROTECTION, FALSE); 
X***************
X*** 254,265 ****
X  			if(!rn2(2)) curse(otmp);
X  			mpickobj(priest, otmp);
X  		    }
X! 		    otmp = mksobj(MACE, FALSE);
X! 		    if(otmp) {
X! 			otmp->spe = rnd(3);
X! 			if(!rn2(2)) curse(otmp);
X! 			mpickobj(priest, otmp);
X! 		    }
X  		}
X  	}
X  }
X--- 249,261 ----
X  			if(!rn2(2)) curse(otmp);
X  			mpickobj(priest, otmp);
X  		    }
X! 		}
X! 
X! 		otmp = mksobj(MACE, FALSE);
X! 		if(otmp) {
X! 		    otmp->spe = rnd(3);
X! 		    if(!rn2(2)) curse(otmp);
X! 		    mpickobj(priest, otmp);
X  		}
X  	}
X  }
X***************
X*** 268,274 ****
X  priestname(priest)
X  register struct monst *priest;
X  {
X! 	static char pname[PL_NSIZ];
X  
X  	Strcpy(pname, "the ");
X  	if(priest->minvis) Strcat(pname, "invisible ");
X--- 264,270 ----
X  priestname(priest)
X  register struct monst *priest;
X  {
X! 	static char NEARDATA pname[PL_NSIZ];
X  
X  	Strcpy(pname, "the ");
X  	if(priest->minvis) Strcat(pname, "invisible ");
X***************
X*** 447,452 ****
X--- 443,449 ----
X  	        kludge("%s gives you two bits for an ale.", Monnam(priest));
X  	        u.ugold = 2L;
X  		if (priest->mgold) priest->mgold -= 2L;
X+ 		flags.botl = 1;
X  	    } else
X  		kludge("%s is not interested.", Monnam(priest));
X  	    return;
X
END_OF_FILE
if test 51445 -ne `wc -c <'patch8.06'`; then
    echo shar: \"'patch8.06'\" unpacked with wrong size!
fi
# end of 'patch8.06'
fi
if test -f 'vms/oldcrtl.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vms/oldcrtl.c'\"
else
echo shar: Extracting \"'vms/oldcrtl.c'\" \(5259 characters\)
sed "s/^X//" >'vms/oldcrtl.c' <<'END_OF_FILE'
X/*       SCCS Id: @(#)oldcrtl.c   3.0      90/05/24
X/*   	 Pat Rankin  May'90                                       */
X/* VMS NetHack support, not needed for vms 4.6,4.7,or 5.x.        */
X
X#ifdef VERYOLD_VMS
X/*
X * The following routines are used by NetHack but were not available
X * from the C Run-Time Library (VAXCRTL) prior to VMS V4.6.
X *
X *      atexit, memcmp, memcpy, qsort, rename, vprintf, vsprintf
X *
X * Most of them are implemented here, but others will have to be worked
X * around in another fashion [such as '#define USE_OLDARGS' (even though
X * <varargs.h> is available) to avoid the need for vprintf & vsprintf].
X *
X */
X#define REG register
X
X#ifndef SUPPRESS_MEM_FUNCS
X/* note: hand optimized for VAX (hardware pre-decrement & post-increment) */
X
X/* void *memset(void *, int, size_t) -- fill chunk of memory.
X*/
Xchar *memset( dst, fil, cnt )
XREG char *dst;
XREG char  fil;
XREG int   cnt;
X{
X    char *dst_p = dst;
X    while ( --cnt >= 0 )
X	*dst++ = fil;
X    return dst_p;
X}
X
X/* void *memcpy(void *, const void *, size_t) -- copy chunk of memory.
X*/
Xchar *memcpy( dst, src, cnt )       /*[functionally equivalent to memmove()]*/
XREG char *dst;
XREG char *src;
XREG int   cnt;
X{
X    char *dst_p = dst;
X    if ( src == dst || cnt <= 0 ) {
X	;       /* do nothing */
X    } else if ( dst < src || dst >= src + cnt ) {
X	while ( --cnt >= 0 )
X	    *dst++ = *src++;
X    } else {    /* work backwards */
X	dst += cnt,  src += cnt;
X	while ( --cnt >= 0 )
X	    *--dst = *--src;
X    }
X    return dst_p;
X}
X
X/* void *memchr(const void *, int, size_t) -- search for a byte.
X*/
Xchar *memchr( buf, byt, len )
XREG char *buf;
XREG char  byt;
XREG int   len;
X{
X    while ( --len >= 0 )
X	if ( *buf++ == byt )    /* found */
X	    return --buf;
X    return (char *)0;       /* not found */
X}
X
X/* int memcmp(const void *, const void *, size_t) -- compare two chunks.
X*/
Xint memcmp( buf1, buf2, len )
XREG char *buf1;
XREG char *buf2;
XREG int   len;
X{
X    while ( --len >= 0 )
X	if ( *buf1++ != *buf2++ )
X	    return (*--buf1 - *--buf2);
X    return 0;   /* buffers matched */
X}
X#endif /*!SUPPRESS_MEM_FUNCS*/
X
X
X#ifndef SUPPRESS_ATEXIT
X/* int atexit(void (*)(void)) -- register an exit handler.
X*/
X#define MAX_EXIT_FUNCS 32       /* arbitrary (32 matches VAX C v3.x docs) */
Xstruct _ex_hndlr { long reserved, (*routine)(), arg_count, *arg1_addr; };
Xstatic int ex_cnt = 0;          /* number of handlers registered so far */
Xstatic struct { long dummy_arg; struct _ex_hndlr handler;   /*(black box)*/
X       } ex_data[MAX_EXIT_FUNCS];       /* static handler data */
X
Xint atexit( function )
X    int (*function)();          /* note: actually gets called with 1 arg */
X{
X    if ( ex_cnt < MAX_EXIT_FUNCS ) {
X	ex_data[ex_cnt].dummy_arg = 0;  /* ultimately receives exit reason */
X	ex_data[ex_cnt].handler.reserved  = 0;
X	ex_data[ex_cnt].handler.routine   = function;
X	ex_data[ex_cnt].handler.arg_count = 1;          /*(required)*/
X	ex_data[ex_cnt].handler.arg1_addr = &ex_data[ex_cnt].dummy_arg;
X	SYS$DCLEXH( &ex_data[ex_cnt].handler);  /* declare exit handler */
X	return ++ex_cnt;        /*(non-zero)*/
X    } else
X	return 0;
X}
X#endif /*!SUPPRESS_ATEXIT*/
X
X
X#ifndef SUPPRESS_RENAME
X/* int rename(const char *, const char *) -- rename a file (on same device).
X*/
X#ifndef EVMSERR
X#include <errno.h>
X#define C$$TRANSLATE(status)    (errno = EVMSERR,  vaxc$errno = (status))
X#endif
X
Xint rename( old_name, new_name )
X    char *old_name;
X    char *new_name;
X{
X    struct _dsc { int len; char *adr; } old_dsc, new_dsc;
X    unsigned long status, LIB$RENAME_FILE();
X
X    /* put strings into descriptors and call run-time library routine */
X    old_dsc.len = strlen( old_dsc.adr = old_name );
X    new_dsc.len = strlen( new_dsc.adr = new_name );
X    status = LIB$RENAME_FILE( &old_dsc, &new_dsc);  /* omit optional args */
X    if ( !(status & 1) ) {      /* even => failure */
X	C$$TRANSLATE(status);
X	return -1;
X    } else                      /*  odd => success */
X	return 0;
X}
X#endif /*!SUPPRESS_RENAME*/
X
X
X#ifndef SUPPRESS_QSORT
X/* void qsort(void *, size_t, size_t, int (*)()) -- sort arbitrary collection.
X*/
Xvoid qsort( base, count, size, compare )
X    char *base;
X    int   count;
XREG int   size;
X    int (*compare)();
X{
XREG int   i, cmp;
XREG char *next, *prev, *tmp = 0;
X    char  wrk_buf[512], *malloc();      /* assume no alloca() available */
X
X    /* just use a shuffle sort (tradeoff between efficiency & simplicity) */
X    /*  [Optimal if already sorted; worst case when initially reversed.]  */
X    for ( next = base, i = 1;  i < count;  i++ ) {
X	prev = next,  next += size;             /* increment front pointer */
X	if ( (cmp = (*compare)( next, prev)) < 0 ) {
X	    /* found element out of order; move other(s) up then re-insert it */
X	    if ( !tmp )  tmp = (size > sizeof wrk_buf ? malloc(size) : wrk_buf);
X	    memcpy( tmp, next, size);           /* save smaller element */
X	    while ( cmp < 0 ) {
X		memcpy( prev + size, prev, size);   /* move larger elem. up */
X		prev -= size;                   /* decrement back pointer */
X		cmp = (prev >= base ? (*compare)( tmp, prev) : 0);
X	    }
X	    memcpy( prev + size, tmp, size);    /* restore small element */
X	}
X    }
X    if ( tmp != 0 && tmp != wrk_buf )  free(tmp);
X    return;
X}
X#endif /*!SUPPRESS_QSORT*/
X
X#endif /*VERYOLD_VMS*/
END_OF_FILE
if test 5259 -ne `wc -c <'vms/oldcrtl.c'`; then
    echo shar: \"'vms/oldcrtl.c'\" unpacked with wrong size!
fi
# end of 'vms/oldcrtl.c'
fi
echo shar: End of archive 7 \(of 24\).
cp /dev/null ark7isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 24 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
