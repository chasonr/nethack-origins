Path: utzoo!utgpu!news-server.csri.toronto.edu!mailrus!tut.cis.ohio-state.edu!zaphod.mps.ohio-state.edu!usc!ucsd!ogicse!zephyr.ens.tek.com!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v10i031:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Patch8m
Message-ID: <5739@tekred.CNA.TEK.COM>
Date: 5 Jun 90 17:58:31 GMT
Sender: news@tekred.CNA.TEK.COM
Lines: 2077
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 10, Issue 31
Archive-name: NetHack3/Patch8m
Patch-To: NetHack3: Volume 7, Issue 56-93



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 13 (of 24)."
# Contents:  patch8.02
# Wrapped by billr@saab on Mon Jun  4 15:27:23 1990
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'patch8.02' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'patch8.02'\"
else
echo shar: Extracting \"'patch8.02'\" \(48763 characters\)
sed "s/^X//" >'patch8.02' <<'END_OF_FILE'
X*** src/Old/do.c	Sun Jun  3 12:52:30 1990
X--- src/do.c	Thu May 31 22:10:44 1990
X***************
X*** 5,10 ****
X--- 5,17 ----
X  /* Contains code for 'd', 'D' (drop), '>', '<' (up, down) */
X  
X  #include "hack.h"
X+ #ifndef STUPID_CPP
X+ /* fortunately, only errno is used from <errno.h> and all known STUPID_CPPs
X+  * are on UNIX SYSV and will thus all be using the extern int errno; declared
X+  * below 
X+  */
X+ #include <errno.h>
X+ #endif
X  
X  #if defined(DGK)
X  extern struct finfo fileinfo[];
X***************
X*** 13,33 ****
X  #endif
X  
X  #ifdef SINKS
X  static void FDECL(trycall, (struct obj *));
X! static void FDECL(dosinkring, (struct obj *));
X! #endif
X! #ifndef OVERLAY
X! static int FDECL(drop, (struct obj *));
X! #endif
X! static void NDECL(litter);
X! #ifndef OVERLAY
X! static int NDECL(wipeoff);
X! #endif
X  boolean NDECL(drag_down);
X  
X  #ifdef OVLB
X  
X! static const char drop_types[] = { '0', GOLD_SYM, '#', 0 };
X  
X  int
X  dodrop() {
X--- 20,38 ----
X  #endif
X  
X  #ifdef SINKS
X+ # ifdef OVLB
X  static void FDECL(trycall, (struct obj *));
X! # endif /* OVLB */
X! STATIC_DCL void FDECL(dosinkring, (struct obj *));
X! #endif /* SINKS */
X! STATIC_PTR int FDECL(drop, (struct obj *));
X! STATIC_DCL void NDECL(litter);
X! STATIC_PTR int NDECL(wipeoff);
X  boolean NDECL(drag_down);
X  
X  #ifdef OVLB
X  
X! static const char NEARDATA drop_types[] = { '0', GOLD_SYM, '#', 0 };
X  
X  int
X  dodrop() {
X***************
X*** 90,96 ****
X  	    }
X  	    obfree(obj, (struct obj *)0);
X  	    mnewsym(x,y);
X! 	    if ((x != u.ux || y != u.uy || Invisible) && !Blind)
X  		newsym(x,y);
X  	    return TRUE;
X  	}
X--- 95,101 ----
X  	    }
X  	    obfree(obj, (struct obj *)0);
X  	    mnewsym(x,y);
X! 	    if (!vism_at(x,y) && (x != u.ux || y != u.uy || Invisible) && !Blind)
X  		newsym(x,y);
X  	    return TRUE;
X  	}
X***************
X*** 132,138 ****
X  	   docall(obj);
X  }
X  
X! static
X  void
X  dosinkring(obj)  /* obj is a ring being dropped over a kitchen sink */
X  register struct obj *obj;
X--- 137,143 ----
X  	   docall(obj);
X  }
X  
X! STATIC_OVL
X  void
X  dosinkring(obj)  /* obj is a ring being dropped over a kitchen sink */
X  register struct obj *obj;
X***************
X*** 256,261 ****
X--- 261,269 ----
X  }
X  #endif
X  
X+ #endif /* OVLB */
X+ #ifdef OVL0
X+ 
X  /* some common tests when trying to drop or throw items */
X  boolean
X  canletgo(obj,word)
X***************
X*** 297,305 ****
X  	return(TRUE);
X  }
X  
X! #ifndef OVERLAY
X! static 
X! #endif
X  int
X  drop(obj) register struct obj *obj; {
X  	if(!obj) return(0);
X--- 305,311 ----
X  	return(TRUE);
X  }
X  
X! STATIC_PTR
X  int
X  drop(obj) register struct obj *obj; {
X  	if(!obj) return(0);
X***************
X*** 395,402 ****
X  	return(ggetobj("drop", drop, 0));
X  }
X  
X  #ifdef STRONGHOLD
X! static boolean at_ladder = FALSE;	/* on a ladder, used in goto_level */
X  #endif
X  
X  int
X--- 401,411 ----
X  	return(ggetobj("drop", drop, 0));
X  }
X  
X+ #endif /* OVL0 */
X+ #ifdef OVL2
X+ 
X  #ifdef STRONGHOLD
X! static boolean NEARDATA at_ladder = FALSE;	/* on a ladder, used in goto_level */
X  #endif
X  
X  int
X***************
X*** 493,514 ****
X  #endif
X  		return(1);
X  	}
X- 
X- #ifdef ENDGAME
X  	if (dlevel == 1) {
X  #ifdef MACOS
X  		if(!flags.silent) SysBeep(20);
X  		if(UseMacAlertText(128,
X! 			"Beware, there will be no return!  Still climb?") != 1) {
X  			return 0;
X  		}
X  #else
X  		pline("Beware, there will be no return!  Still climb? ");
X  		if (yn() != 'y') return(0);
X- 		else more();
X  #endif /* MACOS */
X  	}
X- #endif
X  #ifdef WALKIES
X  	if(!next_to_u()) {
X  		You("are held back by your pet!");
X--- 502,519 ----
X  #endif
X  		return(1);
X  	}
X  	if (dlevel == 1) {
X  #ifdef MACOS
X  		if(!flags.silent) SysBeep(20);
X  		if(UseMacAlertText(128,
X! 		    "Beware, there will be no return!  Still climb?") != 1) {
X  			return 0;
X  		}
X  #else
X  		pline("Beware, there will be no return!  Still climb? ");
X  		if (yn() != 'y') return(0);
X  #endif /* MACOS */
X  	}
X  #ifdef WALKIES
X  	if(!next_to_u()) {
X  		You("are held back by your pet!");
X***************
X*** 532,539 ****
X  	return(1);
X  }
X  
X  
X! static void
X  litter()
X  {
X  	struct obj *otmp = invent, *nextobj;
X--- 537,547 ----
X  	return(1);
X  }
X  
X+ #endif /* OVL2 */
X+ #ifdef OVLB
X  
X! STATIC_OVL
X! void
X  litter()
X  {
X  	struct obj *otmp = invent, *nextobj;
X***************
X*** 600,605 ****
X--- 608,616 ----
X  	return(FALSE);
X  }
X  
X+ #endif /* OVLB */
X+ #ifdef OVL2
X+ 
X  int save_dlevel = 0;
X  
X  void
X***************
X*** 622,641 ****
X  #endif
X  		done(ESCAPED);		/* in fact < 0 is impossible */
X  
X  /*	If you have the amulet and are trying to get out of Hell, going
X   *	up a set of stairs sometimes does some very strange things!
X   */
X  #ifdef HARD
X! 	if(Inhell && up && at_stairs  &&
X! 	   (dlevel < MAXLEVEL-3) && u.uhave_amulet) {
X! 	    newlevel = (rn2(5) ? newlevel :
X  /* neutral */	     !u.ualigntyp ? (rn2(2) ? dlevel : dlevel + (rnd(5) - 2)) :
X  /* lawful */	     (u.ualigntyp == U_LAWFUL) ? dlevel + (rnd(5) - 2) :
X  /* chaotic */	     dlevel);
X- 	    pline("A mysterious force surrounds you...");
X  	    if(newlevel < 1) newlevel = dlevel;
X! 	    if(newlevel == dlevel) (void) dotele();
X! 		
X  	}
X  #endif /* HARD /* */
X  	if(newlevel == dlevel) return;	      /* this can happen */
X--- 633,660 ----
X  #endif
X  		done(ESCAPED);		/* in fact < 0 is impossible */
X  
X+ #ifdef MACOS
X+ 	freeSegs(&segments);
X+ #endif
X  /*	If you have the amulet and are trying to get out of Hell, going
X   *	up a set of stairs sometimes does some very strange things!
X   */
X  #ifdef HARD
X! 	if(Inhell && up && !at_ladder &&
X! 			(dlevel < MAXLEVEL-3) && u.uhave_amulet) {
X! 	    int olev = newlevel;
X! 
X! 	    newlevel = (rn2(4) ? newlevel :
X  /* neutral */	     !u.ualigntyp ? (rn2(2) ? dlevel : dlevel + (rnd(5) - 2)) :
X  /* lawful */	     (u.ualigntyp == U_LAWFUL) ? dlevel + (rnd(5) - 2) :
X  /* chaotic */	     dlevel);
X  	    if(newlevel < 1) newlevel = dlevel;
X! 	    if(newlevel != olev)
X! 	        pline("A mysterious force momentarily surrounds you...");
X! 	    if(newlevel == dlevel) {
X! 		(void) dotele();
X! 		return;
X! 	    }
X  	}
X  #endif /* HARD /* */
X  	if(newlevel == dlevel) return;	      /* this can happen */
X***************
X*** 689,695 ****
X  		
X  		t = (term_info *)GetWRefCon(HackWindow);
X  		fileName[0] = (char)strlen(lock);
X! 		(void)Strcpy((char *)&fileName[1],lock);
X  		if (FSOpen(fileName, t->system.sysVRefNum, &refNum)) {
X  				if (er = Create(&fileName,t->system.sysVRefNum,
X  							CREATOR,LEVEL_TYPE))
X--- 708,714 ----
X  		
X  		t = (term_info *)GetWRefCon(HackWindow);
X  		fileName[0] = (char)strlen(lock);
X! 		Strcpy((char *)&fileName[1],lock);
X  		if (FSOpen(fileName, t->system.sysVRefNum, &refNum)) {
X  				if (er = Create(&fileName,t->system.sysVRefNum,
X  							CREATOR,LEVEL_TYPE))
X***************
X*** 799,805 ****
X  #else
X  		if((fd = open(lock,0)) < 0) {
X  #endif
X! 			pline("Cannot open %s .", lock);
X  			pline("Probably someone removed it.");
X  			done(TRICKED);
X  		}
X--- 818,825 ----
X  #else
X  		if((fd = open(lock,0)) < 0) {
X  #endif
X! 			extern int errno;
X! 			pline("Cannot open \"%s\" (errno %d).", lock, errno);
X  			pline("Probably someone removed it.");
X  			done(TRICKED);
X  		}
X***************
X*** 963,979 ****
X  		|| dlevel == ENDLEVEL
X  #endif
X  		);
X  }
X  
X  int
X  donull() {
X  	return(1);	/* Do nothing, but let other things happen */
X  }
X  
X! #ifndef OVERLAY
X! static
X! #endif
X! int
X  wipeoff() {
X  	if(u.ucreamed < 4)	u.ucreamed = 0;
X  	else			u.ucreamed -= 4;
X--- 983,1006 ----
X  		|| dlevel == ENDLEVEL
X  #endif
X  		);
X+ #ifdef MACOS
X+ 	freeSegs(&segments);
X+ 	segments = SEG_DO;
X+ #endif
X  }
X  
X+ #endif /* OVL2 */
X+ #ifdef OVL3
X+ 
X  int
X  donull() {
X  	return(1);	/* Do nothing, but let other things happen */
X  }
X  
X! #endif /* OVL3 */
X! #ifdef OVLB
X! 
X! STATIC_PTR int
X  wipeoff() {
X  	if(u.ucreamed < 4)	u.ucreamed = 0;
X  	else			u.ucreamed -= 4;
X***************
X*** 995,1001 ****
X  dowipe()
X  {
X  	if(u.ucreamed)  {
X! 		static char buf[39];
X  
X  		Sprintf(buf, "wiping off your %s", body_part(FACE));
X  		set_occupation(wipeoff, buf, 0);
X--- 1022,1028 ----
X  dowipe()
X  {
X  	if(u.ucreamed)  {
X! 		static char NEARDATA buf[39];
X  
X  		Sprintf(buf, "wiping off your %s", body_part(FACE));
X  		set_occupation(wipeoff, buf, 0);
X***************
X*** 1008,1013 ****
X--- 1035,1043 ----
X  	return(1);
X  }
X  
X+ #endif /* OVLB */
X+ #ifdef OVL1
X+ 
X  /* split obj so that it gets size num */
X  /* remainder is put in the object structure delivered by this call */
X  struct obj *
X***************
X*** 1026,1031 ****
X--- 1056,1064 ----
X  	if(obj->unpaid) splitbill(obj,otmp);
X  	return(otmp);
X  }
X+ 
X+ #endif /* OVL1 */
X+ #ifdef OVLB
X  
X  void
X  set_wounded_legs(side, timex)
X*** src/Old/do_name.c	Sun Jun  3 12:53:09 1990
X--- src/do_name.c	Thu May 31 22:10:46 1990
X***************
X*** 8,18 ****
X  # include <ctype.h>
X  #endif
X  
X  static char *FDECL(visctrl, (CHAR_P));
X  static void FDECL(do_oname, (struct obj *));
X  
X- #ifdef OVLB
X- 
X  static
X  char *
X  visctrl(c)
X--- 8,18 ----
X  # include <ctype.h>
X  #endif
X  
X+ #ifdef OVLB
X+ 
X  static char *FDECL(visctrl, (CHAR_P));
X  static void FDECL(do_oname, (struct obj *));
X  
X  static
X  char *
X  visctrl(c)
X***************
X*** 219,229 ****
X  		pline("The artifact seems to resist the attempt.");
X  	else if (restr_name(obj, buf) || exist_artifact(obj, buf)) {
X  		int n = rn2(strlen(buf));
X! 		char c;
X  
X! 		while (tolower(buf[n]) == (c = 'a' + rn2('z'-'a')));
X! 		if (isupper(buf[n])) buf[n] = toupper(c);
X! 		else buf[n] = c;
X  		pline("While engraving your hand slips.");
X  		more();
X  		You("engrave: \"%s\".",buf);
X--- 219,232 ----
X  		pline("The artifact seems to resist the attempt.");
X  	else if (restr_name(obj, buf) || exist_artifact(obj, buf)) {
X  		int n = rn2(strlen(buf));
X! 		char c1,c2;
X  
X! 		c1 = isupper(buf[n]) ? tolower(buf[n]) : buf[n];
X! 		while (c1 == (c2 = 'a' + rn2('z'-'a')));
X! 		if (isupper(buf[n]))
X! 			/* islower(c2) guaranteed by generation */
X! 			buf[n] = toupper(c2);
X! 		else buf[n] = c2;
X  		pline("While engraving your hand slips.");
X  		more();
X  		You("engrave: \"%s\".",buf);
X***************
X*** 244,259 ****
X  	register int	lth;
X  
X  	lth = *buf ? strlen(buf)+1 : 0;
X  #ifdef NAMED_ITEMS
X! 	/* if named artifact exists in the game, do not create another */
X! 	if (exist_artifact(obj, buf))
X! 		lth = 0;
X  	else
X  		artifact_exists(obj, buf, TRUE);
X  #endif
X- 	if(lth > 63){
X- 		lth = 63;
X- 	}
X  	otmp2 = newobj(lth);
X  	*otmp2 = *obj;
X  	otmp2->onamelth = lth;
X--- 247,268 ----
X  	register int	lth;
X  
X  	lth = *buf ? strlen(buf)+1 : 0;
X+ 	if(lth > 63){
X+ 		lth = 63;
X+ 	}
X+ 	/* if already properly named */
X+ 	if(lth == obj->onamelth && (!lth || !strcmp(ONAME(obj),buf)))
X+ 		return obj;
X  #ifdef NAMED_ITEMS
X! 	/* If named artifact exists in the game, do not create another.
X! 	 * Also trying to create an artifact shouldn't de-artifact
X! 	 * it (e.g. Excalibur from prayer). In this case the object
X! 	 * will retain its current name. */
X! 	if (is_artifact(obj) || exist_artifact(obj, buf))
X! 		return obj;
X  	else
X  		artifact_exists(obj, buf, TRUE);
X  #endif
X  	otmp2 = newobj(lth);
X  	*otmp2 = *obj;
X  	otmp2->onamelth = lth;
X***************
X*** 299,305 ****
X  	return otmp2;
X  }
X  
X! static const char callable[] = {
X  	SCROLL_SYM, POTION_SYM, WAND_SYM, RING_SYM, AMULET_SYM, GEM_SYM,
X  #ifdef SPELLS
X  	SPBOOK_SYM,
X--- 308,314 ----
X  	return otmp2;
X  }
X  
X! static const char NEARDATA callable[] = {
X  	SCROLL_SYM, POTION_SYM, WAND_SYM, RING_SYM, AMULET_SYM, GEM_SYM,
X  #ifdef SPELLS
X  	SPBOOK_SYM,
X***************
X*** 435,441 ****
X  		    gn = ghostnames[rn2(SIZE(ghostnames))];
X  		    Strcpy((char *) mtmp->mextra, !rn2(5) ? (const char *)plname : gn);
X  		  }
X! 		  Sprintf(buf, "%s's ghost", (char *) mtmp->mextra);
X  		}
X  		break;
X  	    default:
X--- 444,455 ----
X  		    gn = ghostnames[rn2(SIZE(ghostnames))];
X  		    Strcpy((char *) mtmp->mextra, !rn2(5) ? (const char *)plname : gn);
X  		  }
X! 		  if (Hallucination) {
X! 		    Strcat(buf, "the ");
X! 		    Strcat(buf, rndmonnam());
X! 		  }
X! 		  else
X! 		    Sprintf(buf, "%s's ghost", (char *) mtmp->mextra);
X  		}
X  		break;
X  	    default:
X***************
X*** 583,589 ****
X  const char *str;
X  const char *pronoun;
X  {
X! 	static char buf[BUFSZ];
X  	register int i;
X  
X  	for(i=0; pronoun_pairs[i][0]; i++) {
X--- 597,603 ----
X  const char *str;
X  const char *pronoun;
X  {
X! 	static char NEARDATA buf[BUFSZ];
X  	register int i;
X  
X  	for(i=0; pronoun_pairs[i][0]; i++) {
X*** src/Old/do_wear.c	Sun Jun  3 12:53:36 1990
X--- src/do_wear.c	Sun May 27 17:57:57 1990
X***************
X*** 6,24 ****
X  
X  #ifdef OVLB
X  
X! static int todelay;
X  
X  #endif /*OVLB */
X  
X  #ifndef OVLB
X  
X! OSTATIC long takeoff_mask, taking_off;
X  
X  #else /* OVLB */
X  
X! XSTATIC long takeoff_mask = 0L, taking_off = 0L;
X  
X! static const long takeoff_order[] = { WORN_BLINDF, 1L, /* weapon */
X  	WORN_SHIELD, WORN_GLOVES, LEFT_RING, RIGHT_RING, WORN_CLOAK,
X  	WORN_HELMET, WORN_AMUL, WORN_ARMOR,
X  #ifdef SHIRT
X--- 6,24 ----
X  
X  #ifdef OVLB
X  
X! static int NEARDATA todelay;
X  
X  #endif /*OVLB */
X  
X  #ifndef OVLB
X  
X! STATIC_DCL long takeoff_mask, taking_off;
X  
X  #else /* OVLB */
X  
X! STATIC_OVL long NEARDATA takeoff_mask = 0L, NEARDATA taking_off = 0L;
X  
X! static const long NEARDATA takeoff_order[] = { WORN_BLINDF, 1L, /* weapon */
X  	WORN_SHIELD, WORN_GLOVES, LEFT_RING, RIGHT_RING, WORN_CLOAK,
X  	WORN_HELMET, WORN_AMUL, WORN_ARMOR,
X  #ifdef SHIRT
X***************
X*** 27,50 ****
X  	WORN_BOOTS, 0L };
X  
X  static void FDECL(on_msg, (struct obj *));
X! #ifndef OVERLAY
X! static int NDECL(Armor_on);
X! static int NDECL(Boots_on);
X! #endif
X  static int NDECL(Cloak_on);
X! #ifndef OVERLAY
X! static int NDECL(Helmet_on);
X! static int NDECL(Gloves_on);
X! #endif
X  static void NDECL(Amulet_on);
X  static void FDECL(Ring_off_or_gone, (struct obj *, BOOLEAN_P));
X! #ifndef OVERLAY
X! static int FDECL(select_off, (struct obj *));
X! #endif
X  static struct obj *NDECL(do_takeoff);
X! #ifndef OVERLAY
X! static int NDECL(take_off);
X! #endif
X  
X  void
X  off_msg(otmp) register struct obj *otmp; {
X--- 27,42 ----
X  	WORN_BOOTS, 0L };
X  
X  static void FDECL(on_msg, (struct obj *));
X! STATIC_PTR int NDECL(Armor_on);
X! STATIC_PTR int NDECL(Boots_on);
X  static int NDECL(Cloak_on);
X! STATIC_PTR int NDECL(Helmet_on);
X! STATIC_PTR int NDECL(Gloves_on);
X  static void NDECL(Amulet_on);
X  static void FDECL(Ring_off_or_gone, (struct obj *, BOOLEAN_P));
X! STATIC_PTR int FDECL(select_off, (struct obj *));
X  static struct obj *NDECL(do_takeoff);
X! STATIC_PTR int NDECL(take_off);
X  
X  void
X  off_msg(otmp) register struct obj *otmp; {
X***************
X*** 59,64 ****
X--- 51,59 ----
X  	    You("are now wearing %s.", an(xname(otmp)));
X  }
X  
X+ #endif /* OVLB */
X+ #ifdef OVL2
X+ 
X  boolean
X  is_boots(otmp) register struct obj *otmp; {
X  	return(otmp->otyp >= LOW_BOOTS &&
X***************
X*** 76,81 ****
X--- 71,79 ----
X  #endif
X  }
X  
X+ #endif /* OVLB */
X+ #ifdef OVL2
X+ 
X  boolean
X  is_gloves(otmp) register struct obj *otmp; {
X  	return(otmp->otyp >= LEATHER_GLOVES &&
X***************
X*** 82,87 ****
X--- 80,88 ----
X  	   	otmp->otyp <= GAUNTLETS_OF_DEXTERITY);
X  }
X  
X+ #endif /* OVL2 */
X+ #ifdef OVLB
X+ 
X  boolean
X  is_cloak(otmp) register struct obj *otmp; {
X  	return(otmp->otyp >= MUMMY_WRAPPING &&
X***************
X*** 99,107 ****
X   * The Type_off() functions call setworn() themselves.
X   */
X  
X! #ifndef OVERLAY
X! static 
X! #endif
X  int
X  Boots_on() {
X      long oldprop =
X--- 100,106 ----
X   * The Type_off() functions call setworn() themselves.
X   */
X  
X! STATIC_PTR
X  int
X  Boots_on() {
X      long oldprop =
X***************
X*** 250,258 ****
X      return 0;
X  }
X  
X! #ifndef OVERLAY
X! static 
X! #endif
X  int
X  Helmet_on() {
X      switch(uarmh->otyp) {
X--- 249,255 ----
X      return 0;
X  }
X  
X! STATIC_PTR
X  int
X  Helmet_on() {
X      switch(uarmh->otyp) {
X***************
X*** 321,329 ****
X      return 0;
X  }
X  
X! #ifndef OVERLAY
X! static 
X! #endif
X  int
X  Gloves_on() {
X      long oldprop =
X--- 318,324 ----
X      return 0;
X  }
X  
X! STATIC_PTR
X  int
X  Gloves_on() {
X      long oldprop =
X***************
X*** 431,439 ****
X   * is fire resistance, and we have to immediately set HFire_resistance in worn.c
X   * since worn.c will check it before returning.
X   */
X! #ifndef OVERLAY
X! static 
X! #endif
X  int
X  Armor_on()
X  {
X--- 426,432 ----
X   * is fire resistance, and we have to immediately set HFire_resistance in worn.c
X   * since worn.c will check it before returning.
X   */
X! STATIC_PTR
X  int
X  Armor_on()
X  {
X***************
X*** 772,779 ****
X  	multi = 0;
X  }
X  
X! static const char clothes[] = {ARMOR_SYM, 0};
X! static const char accessories[] = {RING_SYM, AMULET_SYM, TOOL_SYM, 0};
X  
X  int
X  dotakeoff() {
X--- 765,772 ----
X  	multi = 0;
X  }
X  
X! static const char NEARDATA clothes[] = {ARMOR_SYM, 0};
X! static const char NEARDATA accessories[] = {RING_SYM, AMULET_SYM, TOOL_SYM, 0};
X  
X  int
X  dotakeoff() {
X***************
X*** 821,827 ****
X  		You("can't take that off.");
X  		return(0);
X  	}
X! 	if(otmp == uarmg && uwep && uwep->cursed) {	/* myers@uwmacc */
X      You("seem unable to take off the gloves while holding your %s.",
X  	  is_sword(uwep) ? "sword" : "weapon");
X  		uwep->bknown = 1;
X--- 814,820 ----
X  		You("can't take that off.");
X  		return(0);
X  	}
X! 	if(otmp == uarmg && welded(uwep)) {
X      You("seem unable to take off the gloves while holding your %s.",
X  	  is_sword(uwep) ? "sword" : "weapon");
X  		uwep->bknown = 1;
X***************
X*** 1327,1335 ****
X  	}
X  }
X  
X! #ifndef OVERLAY
X! static 
X! #endif
X  int
X  select_off(otmp)
X  register struct obj *otmp;
X--- 1320,1326 ----
X  	}
X  }
X  
X! STATIC_PTR
X  int
X  select_off(otmp)
X  register struct obj *otmp;
X***************
X*** 1435,1443 ****
X  	return(otmp);
X  }
X  
X! #ifndef OVERLAY
X! static 
X! #endif
X  int
X  take_off() {
X  
X--- 1426,1432 ----
X  	return(otmp);
X  }
X  
X! STATIC_PTR
X  int
X  take_off() {
X  
X*** src/Old/dog.c	Sun Jun  3 12:54:27 1990
X--- src/dog.c	Mon May 28 15:45:39 1990
X***************
X*** 7,14 ****
X  
X  #ifdef OVLB
X  
X! char dogname[63] = DUMMY;
X! char catname[63] = DUMMY;
X  
X  #endif /* OVLB */
X  
X--- 7,14 ----
X  
X  #ifdef OVLB
X  
X! char NEARDATA dogname[63] = DUMMY;
X! char NEARDATA catname[63] = DUMMY;
X  
X  #endif /* OVLB */
X  
X***************
X*** 130,136 ****
X  			mtmp0->nmon = mtmp->nmon;
X  		    mtmp->nmon = fmon;
X  		    fmon = mtmp;
X! 		    if (mtmp->data->geno & G_GENOD) {
X  #ifdef KOPS
X  			allow_kops = FALSE;
X  #endif
X--- 130,136 ----
X  			mtmp0->nmon = mtmp->nmon;
X  		    mtmp->nmon = fmon;
X  		    fmon = mtmp;
X! 		    if ((mtmp->data->geno&G_GENOD) && !(mtmp->data->geno&G_UNIQ)) {
X  #ifdef KOPS
X  			allow_kops = FALSE;
X  #endif
X***************
X*** 147,152 ****
X--- 147,155 ----
X  	}
X  }
X  
X+ #endif /* OVLB */
X+ #ifdef OVL2
X+ 
X  void
X  keepdogs(){
X  register struct monst *mtmp;
X***************
X*** 195,200 ****
X--- 198,206 ----
X  	}
X  }
X  
X+ #endif /* OVL2 */
X+ #ifdef OVLB
X+ 
X  void
X  fall_down(mtmp, tolev) 
X  register struct monst *mtmp; 
X***************
X*** 305,311 ****
X  #endif /* OVL0 */
X  #ifdef OVLB
X  
X! int
X  tamedog(mtmp, obj)
X  register struct monst *mtmp;
X  register struct obj *obj;
X--- 311,317 ----
X  #endif /* OVL0 */
X  #ifdef OVLB
X  
X! struct monst *
X  tamedog(mtmp, obj)
X  register struct monst *mtmp;
X  register struct obj *obj;
X***************
X*** 312,330 ****
X  {
X  	register struct monst *mtmp2;
X  
X  	/* worst case, at least he'll be peaceful. */
X  	mtmp->mpeaceful = 1;
X  	if(flags.moonphase == FULL_MOON && night() && rn2(6) && obj
X  						&& mtmp->data->mlet == S_DOG)
X! 		return(0);
X  
X  	/* If we cannot tame him, at least he's no longer afraid. */
X  	mtmp->mflee = 0;
X  	mtmp->mfleetim = 0;
X  	if(mtmp->mtame || !mtmp->mcanmove ||
X- #ifdef MEDUSA
X- 	   mtmp->data == &mons[PM_MEDUSA] ||
X- #endif
X  	   mtmp->isshk || mtmp->isgd ||
X  #if defined(ALTARS) && defined(THEOLOGY)
X  	   mtmp->ispriest ||
X--- 318,341 ----
X  {
X  	register struct monst *mtmp2;
X  
X+ 	/* The wiz and medusa aren't even made peaceful. */
X+ 	if (mtmp->iswiz
X+ #ifdef MEDUSA
X+ 			   || mtmp->data == &mons[PM_MEDUSA]
X+ #endif
X+ 								)
X+ 		return((struct monst *)0);
X+ 
X  	/* worst case, at least he'll be peaceful. */
X  	mtmp->mpeaceful = 1;
X  	if(flags.moonphase == FULL_MOON && night() && rn2(6) && obj
X  						&& mtmp->data->mlet == S_DOG)
X! 		return((struct monst *)0);
X  
X  	/* If we cannot tame him, at least he's no longer afraid. */
X  	mtmp->mflee = 0;
X  	mtmp->mfleetim = 0;
X  	if(mtmp->mtame || !mtmp->mcanmove ||
X  	   mtmp->isshk || mtmp->isgd ||
X  #if defined(ALTARS) && defined(THEOLOGY)
X  	   mtmp->ispriest ||
X***************
X*** 334,342 ****
X  #else
X  	   is_human(mtmp->data) || is_demon(mtmp->data))
X  #endif
X! 		return(0);
X  	if(obj) {
X! 		if(dogfood(mtmp, obj) >= MANFOOD) return(0);
X  		if(cansee(mtmp->mx,mtmp->my))
X  			pline("%s devours the %s.", Monnam(mtmp), xname(obj));
X  		obfree(obj, (struct obj *)0);
X--- 345,353 ----
X  #else
X  	   is_human(mtmp->data) || is_demon(mtmp->data))
X  #endif
X! 		return((struct monst *)0);
X  	if(obj) {
X! 		if(dogfood(mtmp, obj) >= MANFOOD) return((struct monst *)0);
X  		if(cansee(mtmp->mx,mtmp->my))
X  			pline("%s devours the %s.", Monnam(mtmp), xname(obj));
X  		obfree(obj, (struct obj *)0);
X***************
X*** 347,353 ****
X  	if(mtmp->mnamelth) Strcpy(NAME(mtmp2), NAME(mtmp));
X  	initedog(mtmp2);
X  	replmon(mtmp,mtmp2);
X! 	return(1);
X  }
X  
X  #endif /* OVLB */
X--- 358,364 ----
X  	if(mtmp->mnamelth) Strcpy(NAME(mtmp2), NAME(mtmp));
X  	initedog(mtmp2);
X  	replmon(mtmp,mtmp2);
X! 	return(mtmp2);
X  }
X  
X  #endif /* OVLB */
X*** src/Old/dogmove.c	Sun Jun  3 12:54:47 1990
X--- src/dogmove.c	Sat May 26 22:02:35 1990
X***************
X*** 9,23 ****
X  
X  #ifdef OVL0
X  
X! static const char nofetch[] = { BALL_SYM, CHAIN_SYM, ROCK_SYM, 0 };
X  
X  #endif /* OVL0 */
X  
X! OSTATIC void FDECL(dog_eat, (struct monst *, struct obj *, XCHAR_P, int, int));
X  
X  #ifdef OVLB
X  
X! XSTATIC void
X  dog_eat(mtmp, obj, otyp, x, y)
X  register struct monst *mtmp;
X  register struct obj * obj;
X--- 9,23 ----
X  
X  #ifdef OVL0
X  
X! static const char NEARDATA nofetch[] = { BALL_SYM, CHAIN_SYM, ROCK_SYM, 0 };
X  
X  #endif /* OVL0 */
X  
X! STATIC_DCL void FDECL(dog_eat, (struct monst *, struct obj *, XCHAR_P, int, int));
X  
X  #ifdef OVLB
X  
X! STATIC_OVL void
X  dog_eat(mtmp, obj, otyp, x, y)
X  register struct monst *mtmp;
X  register struct obj * obj;
X***************
X*** 140,146 ****
X  			edog->droptime = moves;
X  		}
X  	} else {
X! 		if((obj=level.objects[omx][omy]) && !index(nofetch,obj->olet)){
X  		    if((otyp = dogfood(mtmp, obj)) <= CADAVER){
X  			nix = omx;
X  			niy = omy;
X--- 140,150 ----
X  			edog->droptime = moves;
X  		}
X  	} else {
X! 		if((obj=level.objects[omx][omy]) && !index(nofetch,obj->olet)
X! #ifdef MAIL
X! 			&& obj->otyp != SCR_MAIL
X! #endif
X! 									){
X  		    if((otyp = dogfood(mtmp, obj)) <= CADAVER){
X  			nix = omx;
X  			niy = omy;
X***************
X*** 353,361 ****
X  #ifdef WALKIES
X  			if(mtmp->mleashed) { /* play it safe */
X  				pline("%s breaks loose of %s leash!", 
X  					is_female(mtmp) ? "her" :
X! 					is_human(mtmp->data) ? "his" : "its",
X! 					Monnam(mtmp));
X  				m_unleash(mtmp);
X  			}
X  #endif
X--- 357,365 ----
X  #ifdef WALKIES
X  			if(mtmp->mleashed) { /* play it safe */
X  				pline("%s breaks loose of %s leash!", 
X+ 					Monnam(mtmp),
X  					is_female(mtmp) ? "her" :
X! 					is_human(mtmp->data) ? "his" : "its");
X  				m_unleash(mtmp);
X  			}
X  #endif
X*** src/Old/dokick.c	Sun Jun  3 12:55:09 1990
X--- src/dokick.c	Sat May 12 16:06:36 1990
X***************
X*** 7,13 ****
X  
X  #define martial()	((pl_character[0] == 'S' || pl_character[0] == 'P'))
X  
X! static struct rm *maploc;
X  
X  #ifdef KICK
X  
X--- 7,13 ----
X  
X  #define martial()	((pl_character[0] == 'S' || pl_character[0] == 'P'))
X  
X! static struct rm NEARDATA *maploc;
X  
X  #ifdef KICK
X  
X***************
X*** 18,25 ****
X  static void FDECL(kickdmg, (struct monst *, BOOLEAN_P));
X  static void FDECL(kick_monster, (int, int));
X  static int FDECL(kick_object, (int, int));
X  
X! static struct obj *obj = (struct obj *) 0;
X  
X  static void
X  kickdmg(mon, clumsy)
X--- 18,26 ----
X  static void FDECL(kickdmg, (struct monst *, BOOLEAN_P));
X  static void FDECL(kick_monster, (int, int));
X  static int FDECL(kick_object, (int, int));
X+ static char *NDECL(kickstr);
X  
X! static struct obj NEARDATA *kickobj;
X  
X  static void
X  kickdmg(mon, clumsy)
X***************
X*** 298,310 ****
X  	for (otmp = level.objects[x][y]; otmp; otmp = otmp->nexthere)
X  		if(!otmp->cobj) {
X  			cnt++;
X! 			if(cnt == 1) obj = otmp;
X  		}
X  
X  	/* range < 2 means the object will not move.	*/
X  	/* maybe dexterity should also figure here.     */
X  	if(cnt) range = (int)((ACURR(A_STR) > 18 ? 20 : 
X! 				ACURR(A_STR))/2 - obj->owt/4);
X  	else range = rnd((int)ACURR(A_STR));
X  
X  	if(martial()) range = range + rnd(3);
X--- 299,311 ----
X  	for (otmp = level.objects[x][y]; otmp; otmp = otmp->nexthere)
X  		if(!otmp->cobj) {
X  			cnt++;
X! 			if(cnt == 1) kickobj = otmp;
X  		}
X  
X  	/* range < 2 means the object will not move.	*/
X  	/* maybe dexterity should also figure here.     */
X  	if(cnt) range = (int)((ACURR(A_STR) > 18 ? 20 : 
X! 				ACURR(A_STR))/2 - kickobj->owt/4);
X  	else range = rnd((int)ACURR(A_STR));
X  
X  	if(martial()) range = range + rnd(3);
X***************
X*** 360,384 ****
X  		return(1);
X  	}
X  
X! 	/* cnt should always be >= 1 here (meaning obj is set) due to
X  	 * conditions of call */
X! 	if(!cnt || obj->otyp == BOULDER || obj == uball || obj == uchain)
X  		return(0);
X  
X  	/* a box gets a chance of breaking open here */
X! 	if(Is_box(obj)) {
X! 		boolean otrp = obj->otrapped;
X  
X! 		if (!obj->olocked && (!rn2(3) ||
X  					(martial() && !rn2(2)))) {
X  		    pline("The lid slams open, then falls shut.");
X! 		    if(otrp) chest_trap(obj, LEG);
X  		    return(1);
X! 		} else if (obj->olocked && 
X  				(!rn2(5) || (martial() && !rn2(2)))) {
X  		    You("break open the lock!");
X! 		    obj->olocked = 0;
X! 	            if(otrp) chest_trap(obj, LEG);
X  		    return(1);
X  		}
X  		/* let it fall through to the next cases... */
X--- 361,386 ----
X  		return(1);
X  	}
X  
X! 	/* cnt should always be >= 1 here (meaning kickobj is set) due to
X  	 * conditions of call */
X! 	if(!cnt || kickobj->otyp == BOULDER
X! 			|| kickobj == uball || kickobj == uchain)
X  		return(0);
X  
X  	/* a box gets a chance of breaking open here */
X! 	if(Is_box(kickobj)) {
X! 		boolean otrp = kickobj->otrapped;
X  
X! 		if (!kickobj->olocked && (!rn2(3) ||
X  					(martial() && !rn2(2)))) {
X  		    pline("The lid slams open, then falls shut.");
X! 		    if(otrp) chest_trap(kickobj, LEG);
X  		    return(1);
X! 		} else if (kickobj->olocked && 
X  				(!rn2(5) || (martial() && !rn2(2)))) {
X  		    You("break open the lock!");
X! 		    kickobj->olocked = 0;
X! 	            if(otrp) chest_trap(kickobj, LEG);
X  		    return(1);
X  		}
X  		/* let it fall through to the next cases... */
X***************
X*** 390,405 ****
X  	}
X  
X  	/* fragile objects should not be kicked */
X! 	if (breaks(obj, FALSE)) return(1);
X  
X  	costly = costly_spot(x, y);
X  
X  	/* potions get a chance of breaking here */
X! 	if(obj->olet == POTION_SYM) {
X  		if(rn2(2)) {
X! 		    You("smash %s %s!", obj->quan==1 ? "the" : "a", xname(obj));
X! 		    potionbreathe(obj);
X! 		    useupf(obj);
X  		    return(1);
X  		}
X  	}
X--- 392,408 ----
X  	}
X  
X  	/* fragile objects should not be kicked */
X! 	if (breaks(kickobj, FALSE)) return(1);
X  
X  	costly = costly_spot(x, y);
X  
X  	/* potions get a chance of breaking here */
X! 	if(kickobj->olet == POTION_SYM) {
X  		if(rn2(2)) {
X! 		    You("smash %s %s!",
X! 			    kickobj->quan==1 ? "the" : "a", xname(kickobj));
X! 		    potionbreathe(kickobj);
X! 		    useupf(kickobj);
X  		    return(1);
X  		}
X  	}
X***************
X*** 412,433 ****
X  								) {
X  			if (Blind) pline("It doesn't come loose.");
X  			else pline("The %s do%sn't come loose.",
X! 				distant_name(obj, xname),
X! 				(obj->quan==1) ? "es" : "");
X  			return(!rn2(3) || martial());
X  		}
X  		if (Blind) pline("It comes loose.");
X! 		else pline("The %s come%s loose.", distant_name(obj, xname),
X! 			(obj->quan==1) ? "s" : "");
X! 		move_object(obj, u.ux, u.uy);
X  		newsym(x, y);
X! 		stackobj(obj);
X  		if (Invisible
X  #ifdef POLYSELF
X  				&& !u.uundetected
X  #endif
X  						) newsym(u.ux, u.uy);
X! 		if (costly && !costly_spot(u.ux, u.uy)) addtobill(obj, FALSE);
X  		return(1);
X  	}
X  
X--- 415,437 ----
X  								) {
X  			if (Blind) pline("It doesn't come loose.");
X  			else pline("The %s do%sn't come loose.",
X! 				distant_name(kickobj, xname),
X! 				(kickobj->quan==1) ? "es" : "");
X  			return(!rn2(3) || martial());
X  		}
X  		if (Blind) pline("It comes loose.");
X! 		else pline("The %s come%s loose.", distant_name(kickobj, xname),
X! 			(kickobj->quan==1) ? "s" : "");
X! 		move_object(kickobj, u.ux, u.uy);
X  		newsym(x, y);
X! 		stackobj(kickobj);
X  		if (Invisible
X  #ifdef POLYSELF
X  				&& !u.uundetected
X  #endif
X  						) newsym(u.ux, u.uy);
X! 		if (costly && !costly_spot(u.ux, u.uy))
X! 			addtobill(kickobj, FALSE);
X  		return(1);
X  	}
X  
X***************
X*** 435,459 ****
X  	/* in this function when range < 2 (a display bug */
X  	/* results otherwise).  			  */
X  	if(range <= 2) {
X! 	    if(Is_box(obj)) pline("THUD!");
X  	    else pline("Thump!");
X  	    if(!rn2(3) || martial()) return(1);
X  	    return(0);
X  	}
X  
X! 	if (obj->quan > 1) (void) splitobj(obj, 1);
X  
X  	/* Needed to fool bhit's display-cleanup to show immediately	*/
X  	/* the next object in the pile.  We know here that the object	*/
X  	/* will move, so there is no need to worry about the location,	*/
X  	/* which merely needs to be something other than ox, oy.	*/
X! 	move_object(obj, u.ux, u.uy);
X  	if(cnt == 1 && !MON_AT(x, y))
X  	    newsym(x, y);
X  
X! 	mon = bhit(u.dx, u.dy, range, obj->olet,
X! 			(int (*)()) 0, (int (*)()) 0, obj);
X! 	freeobj(obj);
X  	if(mon) {
X  # ifdef WORM
X  		if (mon->mx != bhitpos.x || mon->my != bhitpos.y)
X--- 439,463 ----
X  	/* in this function when range < 2 (a display bug */
X  	/* results otherwise).  			  */
X  	if(range <= 2) {
X! 	    if(Is_box(kickobj)) pline("THUD!");
X  	    else pline("Thump!");
X  	    if(!rn2(3) || martial()) return(1);
X  	    return(0);
X  	}
X  
X! 	if (kickobj->quan > 1) (void) splitobj(kickobj, 1);
X  
X  	/* Needed to fool bhit's display-cleanup to show immediately	*/
X  	/* the next object in the pile.  We know here that the object	*/
X  	/* will move, so there is no need to worry about the location,	*/
X  	/* which merely needs to be something other than ox, oy.	*/
X! 	move_object(kickobj, u.ux, u.uy);
X  	if(cnt == 1 && !MON_AT(x, y))
X  	    newsym(x, y);
X  
X! 	mon = bhit(u.dx, u.dy, range, kickobj->olet,
X! 			(int (*)()) 0, (int (*)()) 0, kickobj);
X! 	freeobj(kickobj);
X  	if(mon) {
X  # ifdef WORM
X  		if (mon->mx != bhitpos.x || mon->my != bhitpos.y)
X***************
X*** 461,488 ****
X  # endif
X  		/* awake monster if sleeping */
X  		wakeup(mon);
X! 		if(thitmonst(mon, obj)) return(1);
X  	}
X! 	if(costly && !costly_spot(bhitpos.x,bhitpos.y)) addtobill(obj, FALSE);
X! 	move_object(obj, bhitpos.x, bhitpos.y);
X! 	obj->nobj = fobj;
X! 	fobj = obj;
X! 	stackobj(obj);
X! 	if(!MON_AT(obj->ox, obj->oy))
X! 	    newsym(obj->ox, obj->oy);
X  	return(1);
X  }
X- #endif /* KICK */
X  
X! char *
X  kickstr() {
X! 	static char buf[BUFSIZ];
X  
X! #ifdef KICK
X! 	if (obj) Sprintf(buf, "kicking %s", doname(obj));
X! 	else
X! #endif
X! 	if (IS_STWALL(maploc->typ)) Strcpy(buf, "kicking a wall");
X  	else if (IS_ROCK(maploc->typ)) Strcpy(buf, "kicking a rock");
X  #ifdef THRONES
X  	else if (IS_THRONE(maploc->typ)) Strcpy(buf, "kicking a throne");
X--- 465,489 ----
X  # endif
X  		/* awake monster if sleeping */
X  		wakeup(mon);
X! 		if(thitmonst(mon, kickobj)) return(1);
X  	}
X! 	if(costly && !costly_spot(bhitpos.x,bhitpos.y))
X! 		addtobill(kickobj, FALSE);
X! 	move_object(kickobj, bhitpos.x, bhitpos.y);
X! 	kickobj->nobj = fobj;
X! 	fobj = kickobj;
X! 	stackobj(kickobj);
X! 	if(!MON_AT(kickobj->ox, kickobj->oy))
X! 	    newsym(kickobj->ox, kickobj->oy);
X  	return(1);
X  }
X  
X! static char *
X  kickstr() {
X! 	static char NEARDATA buf[BUFSIZ];
X  
X! 	if (kickobj) Sprintf(buf, "kicking %s", doname(kickobj));
X! 	else if (IS_STWALL(maploc->typ)) Strcpy(buf, "kicking a wall");
X  	else if (IS_ROCK(maploc->typ)) Strcpy(buf, "kicking a rock");
X  #ifdef THRONES
X  	else if (IS_THRONE(maploc->typ)) Strcpy(buf, "kicking a throne");
X***************
X*** 512,520 ****
X  
X  	return buf;
X  }
X  
X  int
X! dokick() {		/* try to kick the door down - noisy! */
X          register int x, y;
X  	register int avrg_attrib = (ACURR(A_STR)+ACURR(A_DEX)+ACURR(A_CON))/3;
X  
X--- 513,522 ----
X  
X  	return buf;
X  }
X+ #endif /* KICK */
X  
X  int
X! dokick() {
X          register int x, y;
X  	register int avrg_attrib = (ACURR(A_STR)+ACURR(A_DEX)+ACURR(A_CON))/3;
X  
X***************
X*** 586,591 ****
X--- 588,594 ----
X  		return(1);
X  	}
X  
X+ 	kickobj = (struct obj *)0;
X  	if((OBJ_AT(x, y) || maploc->gmask) && !Levitation) {
X  		if(kick_object(x, y)) return(1);
X  		else goto ouch;
X***************
X*** 630,644 ****
X  			mkgold((300L+(long)rn2(201)), x, y);
X  			i = Luck + 1;
X  			if(i > 6) i = 6;
X! 			while(i--) (void) mkobj_at(GEM_SYM, x, y);
X  			prl(x, y);
X  			/* prevent endless milking */
X  			maploc->looted = T_LOOTED;
X  			return(1);
X  		    } else if (!rn2(4)) {
X! 			register struct trap *ttmp = 
X! 					maketrap(u.ux,u.uy,TRAPDOOR);
X! 			dotrap(ttmp);
X  			return(1);
X  		    }
X  		    goto ouch;
X--- 633,645 ----
X  			mkgold((300L+(long)rn2(201)), x, y);
X  			i = Luck + 1;
X  			if(i > 6) i = 6;
X! 			while(i--) (void) mkobj_at(GEM_SYM, x, y, TRUE);
X  			prl(x, y);
X  			/* prevent endless milking */
X  			maploc->looted = T_LOOTED;
X  			return(1);
X  		    } else if (!rn2(4)) {
X! 			fall_through(FALSE);
X  			return(1);
X  		    }
X  		    goto ouch;
X***************
X*** 683,689 ****
X  			if(!maploc->looted) { /* only once per sink */
X  			    if(!Blind) 
X  				You("see a ring shining in its midst.");
X! 			    (void) mkobj_at(RING_SYM, x, y);
X  			    prl(x, y);
X  			    maploc->looted = T_LOOTED;
X  			}
X--- 684,690 ----
X  			if(!maploc->looted) { /* only once per sink */
X  			    if(!Blind) 
X  				You("see a ring shining in its midst.");
X! 			    (void) mkobj_at(RING_SYM, x, y, TRUE);
X  			    prl(x, y);
X  			    maploc->looted = T_LOOTED;
X  			}
X*** src/Old/dothrow.c	Sun Jun  3 12:55:40 1990
X--- src/dothrow.c	Wed May  9 18:39:53 1990
X***************
X*** 10,16 ****
X  static void FDECL(gem_accept, (struct monst *, struct obj *));
X  static boolean NDECL(martial);
X  static int FDECL(throw_gold, (struct obj *));
X! static const char toss_objs[] = { '0', GOLD_SYM, '#', WEAPON_SYM, 0 };
X  #ifdef WORM
X  extern boolean notonhead;
X  #endif
X--- 10,16 ----
X  static void FDECL(gem_accept, (struct monst *, struct obj *));
X  static boolean NDECL(martial);
X  static int FDECL(throw_gold, (struct obj *));
X! static const char NEARDATA toss_objs[] = { '0', GOLD_SYM, '#', WEAPON_SYM, 0 };
X  #ifdef WORM
X  extern boolean notonhead;
X  #endif
X***************
X*** 253,266 ****
X  	if (u.uswallow && mon == u.ustuck) tmp += 1000; /* Guaranteed hit */
X  
X  	if(obj->olet == GEM_SYM && mon->data->mlet == S_UNICORN) {
X! 		if (mon->mtame)
X  			kludge("%s catches and drops the %s.",
X  				Monnam(mon), xname(obj));
X! 		else {
X  			kludge("%s catches the %s.", Monnam(mon), xname(obj));
X  			gem_accept(mon, obj);
X  		}
X- 		return(1);
X  	}
X  	if(obj->olet == WEAPON_SYM || obj->otyp == PICK_AXE ||
X  	   obj->otyp == UNICORN_HORN || obj->olet == GEM_SYM) {
X--- 253,267 ----
X  	if (u.uswallow && mon == u.ustuck) tmp += 1000; /* Guaranteed hit */
X  
X  	if(obj->olet == GEM_SYM && mon->data->mlet == S_UNICORN) {
X! 		if (mon->mtame) {
X  			kludge("%s catches and drops the %s.",
X  				Monnam(mon), xname(obj));
X! 			return(0);
X! 		} else {
X  			kludge("%s catches the %s.", Monnam(mon), xname(obj));
X  			gem_accept(mon, obj);
X+ 			return(1);
X  		}
X  	}
X  	if(obj->olet == WEAPON_SYM || obj->otyp == PICK_AXE ||
X  	   obj->otyp == UNICORN_HORN || obj->olet == GEM_SYM) {
X***************
X*** 329,337 ****
X  register struct obj *obj;
X  {
X  	char buf[BUFSZ];
X! 	static const char nogood[] = " is not interested in your junk.";
X! 	static const char maybeluck[] = " hesitatingly accepts your gift.";
X! 	static const char addluck[] = " graciously accepts your gift.";
X  
X  	Strcpy(buf,Monnam(mon));
X  
X--- 330,338 ----
X  register struct obj *obj;
X  {
X  	char buf[BUFSZ];
X! 	static const char NEARDATA nogood[] = " is not interested in your junk.";
X! 	static const char NEARDATA maybeluck[] = " hesitatingly accepts your gift.";
X! 	static const char NEARDATA addluck[] = " graciously accepts your gift.";
X  
X  	Strcpy(buf,Monnam(mon));
X  
X*** src/Old/eat.c	Sun Jun  3 12:56:06 1990
X--- src/eat.c	Thu May 31 22:10:51 1990
X***************
X*** 13,55 ****
X  # endif
X  #endif
X  
X! static long FDECL(rounddiv, (long, long));
X! #ifndef OVERLAY
X! static int NDECL(Meatdone);
X! #endif
X  static void FDECL(choke, (struct obj *));
X  static void NDECL(recalc_wt);
X  static struct obj *FDECL(touchfood, (struct obj *));
X  static void NDECL(do_reset_eat);
X- #ifndef OVERLAY
X- static int NDECL(eatfood);
X- #endif
X  static void FDECL(done_eating, (BOOLEAN_P));
X  static void FDECL(cprefx, (int));
X  static void FDECL(cpostfx, (int));
X- #ifndef OVERLAY
X- static int NDECL(opentin);
X- #endif
X  static void FDECL(start_tin, (struct obj *));
X- #ifdef POLYSELF
X- static int FDECL(rottenfood, (struct obj *));
X- #else
X- static int NDECL(rottenfood);
X- #endif
X  static int FDECL(eatcorpse, (struct obj *));
X  static void FDECL(start_eating, (struct obj *));
X  static void FDECL(fprefx, (struct obj *));
X- #ifdef POLYSELF
X- static void NDECL(eatspecial);
X- static const char * FDECL(foodword, (struct obj *));
X- #endif
X  static void FDECL(fpostfx, (struct obj *));
X  static int NDECL(bite);
X- #ifndef OVERLAY
X- static int NDECL(unfaint);
X- #endif
X  
X! #ifdef OVLB
X  
X  char corpsename[60];
X  char msgbuf[BUFSZ];
X--- 13,46 ----
X  # endif
X  #endif
X  
X! STATIC_PTR int NDECL(Meatdone);
X! STATIC_PTR int NDECL(eatfood);
X! STATIC_PTR int NDECL(opentin);
X! STATIC_PTR int NDECL(unfaint);
X! 
X! #ifdef OVLB
X! static int FDECL(rounddiv, (long, int));
X  static void FDECL(choke, (struct obj *));
X  static void NDECL(recalc_wt);
X  static struct obj *FDECL(touchfood, (struct obj *));
X  static void NDECL(do_reset_eat);
X  static void FDECL(done_eating, (BOOLEAN_P));
X  static void FDECL(cprefx, (int));
X  static void FDECL(cpostfx, (int));
X  static void FDECL(start_tin, (struct obj *));
X  static int FDECL(eatcorpse, (struct obj *));
X  static void FDECL(start_eating, (struct obj *));
X  static void FDECL(fprefx, (struct obj *));
X  static void FDECL(fpostfx, (struct obj *));
X  static int NDECL(bite);
X  
X! #ifdef POLYSELF
X! static int FDECL(rottenfood, (struct obj *));
X! static void NDECL(eatspecial);
X! static const char * FDECL(foodword, (struct obj *));
X! #else
X! static int NDECL(rottenfood);
X! #endif /* POLYSELF */
X  
X  char corpsename[60];
X  char msgbuf[BUFSZ];
X***************
X*** 77,92 ****
X  	"Starved "
X  };
X  
X! static const char comestibles[] = { FOOD_SYM, 0 };
X  #ifdef POLYSELF
X! static const char everything[] = { GOLD_SYM, /* must come first */
X  	WEAPON_SYM, ARMOR_SYM, POTION_SYM, SCROLL_SYM, WAND_SYM,
X! #ifdef SPELLS
X  	SPBOOK_SYM,
X! #endif
X  	RING_SYM, WAND_SYM, AMULET_SYM, FOOD_SYM, TOOL_SYM, GEM_SYM,
X  	ROCK_SYM, BALL_SYM, CHAIN_SYM, 0 };
X  
X  boolean
X  is_edible(obj)
X  register struct obj *obj;
X--- 68,96 ----
X  	"Starved "
X  };
X  
X! #endif /* OVLB */
X! 
X! #ifndef OVLB
X! 
X! STATIC_DCL const char NEARDATA comestibles[];
X! 
X! #else
X! 
X! STATIC_OVL const char NEARDATA comestibles[] = { FOOD_SYM, 0 };
X  #ifdef POLYSELF
X! STATIC_OVL const char NEARDATA everything[] = { GOLD_SYM, /* must come first */
X  	WEAPON_SYM, ARMOR_SYM, POTION_SYM, SCROLL_SYM, WAND_SYM,
X! # ifdef SPELLS
X  	SPBOOK_SYM,
X! # endif
X  	RING_SYM, WAND_SYM, AMULET_SYM, FOOD_SYM, TOOL_SYM, GEM_SYM,
X  	ROCK_SYM, BALL_SYM, CHAIN_SYM, 0 };
X  
X+ #endif /* POLYSELF */
X+ #endif /* OVLB */
X+ #ifdef OVL1
X+ # ifdef POLYSELF
X+ 
X  boolean
X  is_edible(obj)
X  register struct obj *obj;
X***************
X*** 100,115 ****
X  		return TRUE;
X  	return !!index(comestibles, obj->olet);
X  }
X! #endif
X  
X  /* calculate x/y, rounding as appropriate */
X  
X! static long
X  rounddiv(x, y)
X! long x, y;
X  {
X  	int divsgn = 1;
X! 	long r, m;
X  
X  	if (y == 0)
X  		panic("division by zero in rounddiv");
X--- 104,122 ----
X  		return TRUE;
X  	return !!index(comestibles, obj->olet);
X  }
X! # endif /* POLYSELF */
X! #endif /* OVL1 */
X! #ifdef OVLB
X  
X  /* calculate x/y, rounding as appropriate */
X  
X! static int
X  rounddiv(x, y)
X! long x;
X! int y;
X  {
X  	int divsgn = 1;
X! 	int r, m;
X  
X  	if (y == 0)
X  		panic("division by zero in rounddiv");
X***************
X*** 145,151 ****
X  static struct {
X  	struct	obj *tin;
X  	int	usedtime, reqtime;
X! } tin;
X  
X  static struct {
X  	struct	obj *piece;	/* the thing being eaten, or last thing that
X--- 152,158 ----
X  static struct {
X  	struct	obj *tin;
X  	int	usedtime, reqtime;
X! } NEARDATA tin;
X  
X  static struct {
X  	struct	obj *piece;	/* the thing being eaten, or last thing that
X***************
X*** 158,168 ****
X  	Bitfield(fullwarn,1);	/* have warned about being full */
X  	Bitfield(eating,1);	/* victual currently being eaten */
X  	Bitfield(doreset,1);	/* stop eating at end of turn */
X! } victual;
X  
X! #ifndef OVERLAY
X! static 
X! #endif
X  int
X  Meatdone() {		/* called after mimicing is over */
X  	u.usym =
X--- 165,173 ----
X  	Bitfield(fullwarn,1);	/* have warned about being full */
X  	Bitfield(eating,1);	/* victual currently being eaten */
X  	Bitfield(doreset,1);	/* stop eating at end of turn */
X! } NEARDATA victual;
X  
X! STATIC_PTR
X  int
X  Meatdone() {		/* called after mimicing is over */
X  	u.usym =
X***************
X*** 308,316 ****
X  	stop_occupation();
X  }
X  
X! #ifndef OVERLAY
X! static 
X! #endif
X  int
X  eatfood() {		/* called each move during eating process */
X  	if(!carried(victual.piece) && !obj_here(victual.piece, u.ux, u.uy)) {
X--- 313,319 ----
X  	stop_occupation();
X  }
X  
X! STATIC_PTR
X  int
X  eatfood() {		/* called each move during eating process */
X  	if(!carried(victual.piece) && !obj_here(victual.piece, u.ux, u.uy)) {
X***************
X*** 563,571 ****
X  	return;
X  }
X  
X! #ifndef OVERLAY
X! static 
X! #endif
X  int
X  opentin()		/* called during each move whilst opening a tin */
X  {
X--- 566,572 ----
X  	return;
X  }
X  
X! STATIC_PTR
X  int
X  opentin()		/* called during each move whilst opening a tin */
X  {
X***************
X*** 580,591 ****
X  	}
X  	if(tin.usedtime < tin.reqtime)
X  		return(1);		/* still busy */
X! 	if(tin.tin->cursed && !rn2(8)) {
X  		b_trapped("tin");
X  		goto use_me;
X  	}
X  	You("succeed in opening the tin.");
X! 	if(!tin.tin->spe) {
X  	    if(tin.tin->corpsenm == -1) {
X  		pline("It turns out to be empty.");
X  		tin.tin->dknown = tin.tin->known = TRUE;
X--- 581,592 ----
X  	}
X  	if(tin.usedtime < tin.reqtime)
X  		return(1);		/* still busy */
X! 	if(tin.tin->cursed && tin.tin->spe != -1 && !rn2(8)) {
X  		b_trapped("tin");
X  		goto use_me;
X  	}
X  	You("succeed in opening the tin.");
X! 	if(tin.tin->spe != 1) {
X  	    if(tin.tin->corpsenm == -1) {
X  		pline("It turns out to be empty.");
X  		tin.tin->dknown = tin.tin->known = TRUE;
X***************
X*** 592,605 ****
X--- 593,618 ----
X  		goto use_me;
X  	    }
X  	    r = tin.tin->cursed ? 4 : rn2(TTSZ-1); /* Always rotten if cursed */
X+ #ifdef MACOS
X+ 	{
X+ 		char tmp[128];
X+ 		if(!flags.silent) SysBeep(20);
X+ 		Sprintf(tmp, "It smells like %s. Eat it ?", makeplural(
X+ 		  Hallucination ? rndmonnam() : mons[tin.tin->corpsenm].mname));
X+ 		if(UseMacAlertText(128, tmp) == 2) {
X+ #else
X  	    pline("It smells like %s.", makeplural(
X  		  Hallucination ? rndmonnam() : mons[tin.tin->corpsenm].mname));
X  	    pline("Eat it? ");
X  	    if (yn() == 'n') {
X+ #endif
X  		if (!Hallucination) tin.tin->dknown = tin.tin->known = TRUE;
X  		if (flags.verbose) You("discard the open tin.");
X  		goto use_me;
X  	    }
X+ #ifdef MACOS
X+ 	}
X+ #endif
X  	    You("consume %s %s.", tintxts[r].txt,
X  		  mons[tin.tin->corpsenm].mname);
X  	    tin.tin->dknown = tin.tin->known = TRUE;
X***************
X*** 615,621 ****
X--- 628,645 ----
X  			makeplural(body_part(FINGER)));
X  	    }
X  	} else {
X+ #ifdef MACOS
X+ 	{
X+ 		char tmp[128];
X+ 		if(!flags.silent) SysBeep(20);
X  	    if (tin.tin->cursed)
X+ 		Sprintf(tmp, "It contains some decaying %s substance. Eat it ?",
X+ 			Hallucination ? hcolor() : green);
X+ 	    else
X+ 		Sprintf(tmp, "It contains spinach. Eat it ?");
X+ 		if(UseMacAlertText(128, tmp) == 2) {
X+ #else
X+ 	    if (tin.tin->cursed)
X  		pline("It contains some decaying %s substance.",
X  			Hallucination ? hcolor() : green);
X  	    else
X***************
X*** 623,628 ****
X--- 647,653 ----
X  
X  	    pline("Eat it? ");
X  	    if (yn() == 'n') {
X+ #endif
X  		if (!Hallucination && !tin.tin->cursed)
X  		    tin.tin->dknown = tin.tin->known = TRUE;
X  		if (flags.verbose)
X***************
X*** 629,634 ****
X--- 654,662 ----
X  		    You("discard the open tin.");
X  		goto use_me;
X  	    }
X+ #ifdef MACOS
X+ 	}
X+ #endif
X  	    if (!tin.tin->cursed)
X  		pline("This makes you feel like %s!",
X  		      Hallucination ? "Swee'pea" : "Popeye");
X***************
X*** 926,932 ****
X  		} else 
X  #endif
X  		{
X! 		    int oldquan = otmp->quan;
X  		    otmp->quan = 1;
X  		    pline("This %s is %s!", xname(otmp),
X  		      otmp->cursed ? (Hallucination ? "grody" : "terrible"):
X--- 954,960 ----
X  		} else 
X  #endif
X  		{
X! 		    unsigned oldquan = otmp->quan;
X  		    otmp->quan = 1;
X  		    pline("This %s is %s!", xname(otmp),
X  		      otmp->cursed ? (Hallucination ? "grody" : "terrible"):
X***************
X*** 956,961 ****
X--- 984,992 ----
X  	}
X  	if (otmp->olet == POTION_SYM) {
X  		otmp->quan++; /* dopotion() does a useup() */
X+ #ifdef MACOS
X+ 		segments |= SEG_EAT;
X+ #endif
X  		(void)dopotion(otmp);
X  	}
X  	if (otmp == uball) unpunish();
X***************
X*** 1103,1109 ****
X  	 */
X  	    if (u.uhs != SATIATED) victual.canchoke = FALSE;
X  	    if(!carried(victual.piece)) {
X! 		if(victual.piece->quan != 1)
X  			(void) splitobj(victual.piece, 1);
X  	    }
X  	    You("resume your meal.");
X--- 1134,1140 ----
X  	 */
X  	    if (u.uhs != SATIATED) victual.canchoke = FALSE;
X  	    if(!carried(victual.piece)) {
X! 		if(victual.piece->quan > 1)
X  			(void) splitobj(victual.piece, 1);
X  	    }
X  	    You("resume your meal.");
X***************
X*** 1157,1163 ****
X  	debug("oeaten == %d, basenutrit == %d", otmp->oeaten, basenutrit);
X  #endif
X  	victual.reqtime = (basenutrit == 0 ? 0 :
X! 	  (int)rounddiv(victual.reqtime * (long)otmp->oeaten,(long)basenutrit));
X  #ifdef DEBUG
X  	debug("after rounddiv: victual.reqtime == %d", victual.reqtime);
X  #endif
X--- 1188,1194 ----
X  	debug("oeaten == %d, basenutrit == %d", otmp->oeaten, basenutrit);
X  #endif
X  	victual.reqtime = (basenutrit == 0 ? 0 :
X! 		rounddiv(victual.reqtime * (long)otmp->oeaten, basenutrit));
X  #ifdef DEBUG
X  	debug("after rounddiv: victual.reqtime == %d", victual.reqtime);
X  #endif
X***************
X*** 1271,1278 ****
X  		else {
X  		    victual.fullwarn = TRUE;
X  		    if (victual.canchoke) {
X  			pline("Stop eating? ");
X! 			if(yn() == 'y') reset_eat();
X  		    }
X  		}
X  	      }
X--- 1302,1315 ----
X  		else {
X  		    victual.fullwarn = TRUE;
X  		    if (victual.canchoke) {
X+ #ifdef MACOS
X+ 			if(!flags.silent) SysBeep(20);
X+ 			if(UseMacAlertText(128, "Stop eating ?") == 1)
X+ #else
X  			pline("Stop eating? ");
X! 			if(yn() == 'y')
X! #endif
X! 				reset_eat();
X  		    }
X  		}
X  	      }
X***************
X*** 1281,1289 ****
X  	newuhs(FALSE);
X  }
X  
X! #ifndef OVERLAY
X! static 
X! #endif
X  int
X  unfaint() {
X  	(void) Hear_again();
X--- 1318,1324 ----
X  	newuhs(FALSE);
X  }
X  
X! STATIC_PTR
X  int
X  unfaint() {
X  	(void) Hear_again();
X***************
X*** 1407,1417 ****
X--- 1442,1461 ----
X  #endif
X  #ifdef POLYSELF
X  	if (feeding && gold && metallivorous(uasmon)) {
X+ #ifdef MACOS
X+ 		char tmp[128];
X  	    if (gold->amount == 1)
X+ 		Sprintf(tmp, "There is 1 gold piece here. Eat it ?");
X+ 	    else Sprintf(tmp, "There are %ld gold pieces here. Eat them ?",
X+ 								gold->amount);
X+ 		if(UseMacAlertText(128, tmp) == 1) {
X+ #else
X+ 	    if (gold->amount == 1)
X  		pline("There is 1 gold piece here; eat it? ");
X  	    else pline("There are %ld gold pieces here; eat them? ",
X  								gold->amount);
X  	    if (yn() == 'y') {
X+ #endif
X  		otmp = newobj(0);
X  		otmp->olet = GOLD_SYM;
X  		otmp->ox = u.ux;
X***************
X*** 1430,1441 ****
X--- 1474,1499 ----
X  		    feeding ? is_edible(otmp) :
X  #endif
X  						otmp->olet==FOOD_SYM) {
X+ #ifdef MACOS
X+ 			if(!flags.silent) SysBeep(20);
X+ 		{
X+ 			char tmp[128];
X+ 			Sprintf(tmp, "There %s %s here. %s %s ?",
X+ 				(otmp->quan == 1) ? "is" : "are",
X+ 				doname(otmp), verb,
X+ 				(otmp->quan == 1) ? "it" : "one");
X+ 			if(UseMacAlertText(128, tmp) == 1)
X+ #else
X  			pline("There %s %s here; %s %s? ",
X  				(otmp->quan == 1) ? "is" : "are",
X  				doname(otmp), verb,
X  				(otmp->quan == 1) ? "it" : "one");
X  			if(yn() == 'y')
X+ #endif
X  				return(otmp);
X+ #ifdef MACOS
X+ 		}
X+ #endif
X  		}
X  	    }
X  	}
X
END_OF_FILE
if test 48763 -ne `wc -c <'patch8.02'`; then
    echo shar: \"'patch8.02'\" unpacked with wrong size!
fi
# end of 'patch8.02'
fi
echo shar: End of archive 13 \(of 24\).
cp /dev/null ark13isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 24 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
