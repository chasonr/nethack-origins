Path: utzoo!attcan!uunet!snorkelwacker!tut.cis.ohio-state.edu!ucsd!ogicse!zephyr.ens.tek.com!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v10i023:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Patch8e
Message-ID: <5731@tekred.CNA.TEK.COM>
Date: 5 Jun 90 17:51:49 GMT
Sender: news@tekred.CNA.TEK.COM
Lines: 2258
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 10, Issue 23
Archive-name: NetHack3/Patch8e
Patch-To: NetHack3: Volume 7, Issue 56-93



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 5 (of 24)."
# Contents:  UPDATE8 patch8.08
# Wrapped by billr@saab on Mon Jun  4 15:27:15 1990
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'UPDATE8' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'UPDATE8'\"
else
echo shar: Extracting \"'UPDATE8'\" \(2545 characters\)
sed "s/^X//" >'UPDATE8' <<'END_OF_FILE'
XFrom @RELAY.CS.NET,@central.cis.upenn.edu:izchak@linc.cis.upenn.edu Sun Jun  3 19:07:16 1990
XReceived: from tekred.CNA.TEK.COM by saab.CNA.TEK.COM (3.2/6.24)
X	id AA19831; Sun, 3 Jun 90 19:07:15 PDT
XReceived: by tekred.CNA.TEK.COM (5.51/6.24)
X	id AA07744; Sun, 3 Jun 90 19:04:46 PDT
XReceived: by tektronix.TEK.COM (5.51/7.1)
X	id AA19147; Sun, 3 Jun 90 19:09:13 PDT
XReceived: from  by zephyr.ENS.TEK.COM (4.1/7.1)
X	id AB19260; Sun, 3 Jun 90 19:03:29 PDT
XReceived: from relay.cs.net by RELAY.CS.NET id aa02627; 3 Jun 90 21:57 EDT
XReceived: from central.cis.upenn.edu by RELAY.CS.NET id aa02050;
X          3 Jun 90 21:58 EDT
XReceived: from LINC.CIS.UPENN.EDU by central.cis.upenn.edu
X	id AA24573; Sun, 3 Jun 90 21:58:54 -0400
XReturn-Path: <izchak@linc.cis.upenn.edu>
XReceived: by linc.cis.upenn.edu
X	id AA04476; Sun, 3 Jun 90 21:58:14 EDT
XDate: Sun, 3 Jun 90 21:58:14 EDT
XFrom: Izchak Miller <izchak@linc.cis.upenn.edu>
XPosted-Date: Sun, 3 Jun 90 21:58:14 EDT
XMessage-Id: <9006040158.AA04476@linc.cis.upenn.edu>
XTo: billr@saab.CNA.TEK.COM
XSubject: UPDATE8
XStatus: O
X
XThis patch is devoted to bugfixes and accommodations for more versions of
Xthe newer ports.
X
XThe VMS port should now compile with both VAXC and GNUC and install more
Xeasily under a variety of OS versions, thanks to Joshua Delahunty and Pat
XRankin.
X
XA number of strange interactions in the Macintosh-specific code have been
Xcleaned up.
X
XThe MSDOS overlay manager was debugged, and the overlay assignments and macro
Xnames straightened out, so the result should be both faster and more stable
Xthan previous versions.  See the new file Install.ovl and various files in
Xthe others directory for more information.
X
XThe Amiga port now specifies addressing modes for many external variables,
Xwhich should make its executable smaller and faster as well.
X
X
XThe biggest externally visible change separates DECgraphics and IBMgraphics
Xfrom the general graphics-setting code, and makes them selectable on the
Xcommand line.
X
XOnce again, existing saved games and bones files should be discarded (or the
Xupdate postponed until they are gone).
X
XA number of reasonably simple bugs are no more, although some screen update
Xoddities are postponed to 3.1.  Among the dead are problems with shops on
Xbones levels, renaming artifacts, kicking non-objects, winning gem treatment,
Xlevel bounds checking and monster filling, mimic appearances, taking items
Xout of containers, monster interiors and inventories, and guard behavior.
XVarious other things were changed to be consistent with similar situations.
X
X
END_OF_FILE
if test 2545 -ne `wc -c <'UPDATE8'`; then
    echo shar: \"'UPDATE8'\" unpacked with wrong size!
fi
# end of 'UPDATE8'
fi
if test -f 'patch8.08' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'patch8.08'\"
else
echo shar: Extracting \"'patch8.08'\" \(52966 characters\)
sed "s/^X//" >'patch8.08' <<'END_OF_FILE'
X*** src/Old/spell.c	Sun Jun  3 14:12:22 1990
X--- src/spell.c	Sat May 26 23:01:54 1990
X***************
X*** 6,13 ****
X  
X  #include "hack.h"
X  #ifdef SPELLS
X! static schar delay;		/* moves left for this spell */
X! static struct obj *book;	/* last/current book being xscribed */
X  
X  #ifdef HARD
X  #define spelluses(spell)	spl_book[spell-1].sp_uses
X--- 6,13 ----
X  
X  #include "hack.h"
X  #ifdef SPELLS
X! static schar NEARDATA delay;		/* moves left for this spell */
X! static struct obj NEARDATA *book;	/* last/current book being xscribed */
X  
X  #ifdef HARD
X  #define spelluses(spell)	spl_book[spell-1].sp_uses
X***************
X*** 17,22 ****
X--- 17,27 ----
X  #define spellname(spell)	objects[spl_book[spell-1].sp_id].oc_name
X  #define spellid(spell)		spl_book[spell-1].sp_id
X  
X+ static void FDECL(cursed_book, (int));
X+ STATIC_PTR int NDECL(learn);
X+ static int NDECL(getspell);
X+ static char FDECL(spellet, (int));
X+ 
X  static void
X  cursed_book(lev)
X  	register int	lev;
X***************
X*** 77,85 ****
X  	return;
X  }
X  
X! #ifndef OVERLAY
X! static 
X! #endif
X  int
X  learn()
X  {
X--- 82,88 ----
X  	return;
X  }
X  
X! STATIC_PTR
X  int
X  learn()
X  {
X***************
X*** 348,353 ****
X--- 351,362 ----
X  	case SPE_FINGER_OF_DEATH:
X  	case SPE_LIGHT:
X  	case SPE_DETECT_UNSEEN:
X+ #ifdef MACOS
X+ 		if (pseudo->otyp == SPE_DIG)
X+ 		{
X+ 			segments |= SEG_SPELL;
X+ 		}
X+ #endif
X  		if (!(objects[pseudo->otyp].bits & NODIR)) {
X  			if (atme) u.dx = u.dy = u.dz = 0;
X  			else (void) getdir(1);
X*** src/Old/steal.c	Sun Jun  3 14:12:42 1990
X--- src/steal.c	Thu May 31 22:13:47 1990
X***************
X*** 4,10 ****
X--- 4,13 ----
X  
X  #include "hack.h"
X  
X+ STATIC_DCL int NDECL(stealarm);
X+ 
X  #ifdef OVLB
X+ static const char * FDECL(equipname, (struct obj *));
X  
X  static const char *
X  equipname(otmp)
X***************
X*** 63,72 ****
X  unsigned int stealoid;		/* object to be stolen */
X  unsigned int stealmid;		/* monster doing the stealing */
X  
X! #ifndef OVERLAY
X! static 
X! #endif
X! int
X  stealarm(){
X  	register struct monst *mtmp;
X  	register struct obj *otmp;
X--- 66,72 ----
X  unsigned int stealoid;		/* object to be stolen */
X  unsigned int stealmid;		/* monster doing the stealing */
X  
X! STATIC_OVL int
X  stealarm(){
X  	register struct monst *mtmp;
X  	register struct obj *otmp;
X***************
X*** 75,82 ****
X  	  if(otmp->o_id == stealoid) {
X  	    for(mtmp = fmon; mtmp; mtmp = mtmp->nmon)
X  	      if(mtmp->m_id == stealmid) {
X  		  freeinv(otmp);
X! 		  pline("%s steals %s!", Blind ? "It" : Monnam(mtmp), doname(otmp));
X  		  mpickobj(mtmp,otmp);
X  		  mtmp->mflee = 1;
X  		  rloc(mtmp);
X--- 75,84 ----
X  	  if(otmp->o_id == stealoid) {
X  	    for(mtmp = fmon; mtmp; mtmp = mtmp->nmon)
X  	      if(mtmp->m_id == stealmid) {
X+ 		  if(otmp->unpaid) subfrombill(otmp);
X  		  freeinv(otmp);
X! 		  pline("%s steals %s!", Blind ? "It" : 
X! 					Monnam(mtmp), doname(otmp));
X  		  mpickobj(mtmp,otmp);
X  		  mtmp->mflee = 1;
X  		  rloc(mtmp);
X*** src/Old/termcap.c	Sun Jun  3 14:13:01 1990
X--- src/termcap.c	Sat Jun  2 19:46:20 1990
X***************
X*** 19,35 ****
X  short	ospeed = 0;	/* gets around "not defined" error message */
X  #endif
X  
X- #ifdef ASCIIGRAPH
X  
X- #ifdef OVLB
X- 
X- boolean IBMgraphics = FALSE;
X- 
X- #endif /* OVLB */
X- 
X- #endif
X- 
X- 
X  #ifdef MICROPORT_286_BUG
X  #define Tgetstr(key) (tgetstr(key,tbuf))
X  #else
X--- 19,25 ----
X***************
X*** 36,66 ****
X  #define Tgetstr(key) (tgetstr(key,&tbufptr))
X  #endif /* MICROPORT_286_BUG **/
X  
X! OSTATIC void FDECL(nocmov, (int, int));
X  #ifdef TEXTCOLOR
X  # ifdef TERMLIB
X  static void NDECL(init_hilite);
X  # endif
X  #endif
X  
X! VSTATIC char *HO, *CL, *CE, *UP, *CM, *ND, *XD, *BC, *SO, *SE, *TI, *TE;
X! VSTATIC char *VS, *VE, *US, *UE;
X! VSTATIC char *MR, *ME;
X  #if 0
X! VSTATIC char *MB, *MH;
X! VSTATIC char *MD;     /* may already be in use below */
X  #endif
X  #ifdef TERMLIB
X  # ifdef TEXTCOLOR
X! VSTATIC char *MD;
X  # endif
X! VSTATIC int SG;
X  #ifdef OVLB
X! XSTATIC char PC = '\0';
X  #else /* OVLB */
X! OSTATIC char PC;
X  #endif /* OVLB */
X! VSTATIC char tbuf[512];
X  #endif
X  
X  #ifdef OVLB
X--- 26,58 ----
X  #define Tgetstr(key) (tgetstr(key,&tbufptr))
X  #endif /* MICROPORT_286_BUG **/
X  
X! STATIC_DCL void FDECL(nocmov, (int, int));
X  #ifdef TEXTCOLOR
X  # ifdef TERMLIB
X+ #  ifdef OVLB
X  static void NDECL(init_hilite);
X+ #  endif /* OVLB */
X  # endif
X  #endif
X  
X! STATIC_VAR char *HO, *CL, *CE, *UP, *CM, *ND, *XD, *BC, *SO, *SE, *TI, *TE;
X! STATIC_VAR char *VS, *VE, *US, *UE;
X! STATIC_VAR char *MR, *ME;
X  #if 0
X! STATIC_VAR char *MB, *MH;
X! STATIC_VAR char *MD;     /* may already be in use below */
X  #endif
X  #ifdef TERMLIB
X  # ifdef TEXTCOLOR
X! STATIC_VAR char *MD;
X  # endif
X! STATIC_VAR int SG;
X  #ifdef OVLB
X! STATIC_OVL char PC = '\0';
X  #else /* OVLB */
X! STATIC_DCL char PC;
X  #endif /* OVLB */
X! STATIC_VAR char tbuf[512];
X  #endif
X  
X  #ifdef OVLB
X***************
X*** 68,74 ****
X  #endif /* OVLB */
X  
X  #ifndef TERMLIB
X! VSTATIC char tgotobuf[20];
X  # ifdef TOS
X  #define tgoto(fmt, x, y)	(Sprintf(tgotobuf, fmt, y+' ', x+' '), tgotobuf)
X  # else
X--- 60,66 ----
X  #endif /* OVLB */
X  
X  #ifndef TERMLIB
X! STATIC_VAR char tgotobuf[20];
X  # ifdef TOS
X  #define tgoto(fmt, x, y)	(Sprintf(tgotobuf, fmt, y+' ', x+' '), tgotobuf)
X  # else
X***************
X*** 101,147 ****
X  	(void) memcpy((genericptr_t) showsyms, 
X  		(genericptr_t) defsyms, sizeof showsyms);
X  
X- #ifdef ASCIIGRAPH
X- 	/*
X- 	 * If we're on an IBM box, default to the nice IBM Extended ASCII
X- 	 * line-drawing characters (codepage 437).
X- 	 *
X- 	 * OS/2 defaults to a multilingual character set (codepage 850,
X- 	 * corresponding to the ISO 8859 character set.  We should probably
X- 	 * do a VioSetCp() call to set the codepage to 437.
X- 	 *
X- 	 * Someday we should do a full terminfo(4) check for ACS forms
X- 	 * characters.
X- 	 */
X- # if !defined(MSDOS) || defined(DECRAINBOW) || defined(OS2)
X- #  ifdef TERMLIB
X- 	if (strncmp("AT", term, 2) == 0)
X- #  endif
X- # endif
X- 	{
X- 	    IBMgraphics = TRUE;
X- 	    showsyms[S_vwall] = 0xb3;	/* meta-3, vertical rule */
X- 	    showsyms[S_hodoor] = 0xb3;
X- 	    showsyms[S_hwall] = 0xc4;	/* meta-D, horizontal rule */
X- 	    showsyms[S_vodoor] = 0xc4;
X- 	    showsyms[S_tlcorn] = 0xda;	/* meta-Z, top left corner */
X- 	    showsyms[S_trcorn] = 0xbf;	/* meta-?, top right corner */
X- 	    showsyms[S_blcorn] = 0xc0;	/* meta-@, bottom left */
X- 	    showsyms[S_brcorn] = 0xd9;	/* meta-Y, bottom right */
X- 	    showsyms[S_crwall] = 0xc5;	/* meta-E, cross */
X- 	    showsyms[S_tuwall] = 0xc1;	/* meta-A, T up */
X- 	    showsyms[S_tdwall] = 0xc2;	/* meta-B, T down */
X- 	    showsyms[S_tlwall] = 0xb4;	/* meta-4, T left */
X- 	    showsyms[S_trwall] = 0xc3;	/* meta-C, T right */
X- 	    showsyms[S_vbeam] = 0xb3;	/* meta-3, vertical rule */
X- 	    showsyms[S_hbeam] = 0xc4;	/* meta-D, horizontal rule */
X- 	    showsyms[S_room] = 0xfa;	/* meta-z, centered dot */
X- 	    showsyms[S_ndoor] = 0xfa;
X- 	    showsyms[S_pool] = 0xf7;	/* meta-w, approx. equals */
X- 	    showsyms[S_hodoor] = 0xfe;	/* meta-~, small centered square */
X- 	    showsyms[S_vodoor] = 0xfe;
X- 	}
X- #endif /* ASCIIGRAPH */
X  
X  #ifdef TERMLIB
X  	if(!term)
X--- 93,98 ----
X***************
X*** 245,251 ****
X  		/* strictly, SE should be 2, and UE should be 24,
X  		   but we can't trust all ANSI emulators to be
X  		   that complete.  -3. */
X! #   if !defined(MSDOS) || defined(DECRAINBOW)
X  		AS = "\016";
X  		AE = "\017";
X  #   endif
X--- 196,202 ----
X  		/* strictly, SE should be 2, and UE should be 24,
X  		   but we can't trust all ANSI emulators to be
X  		   that complete.  -3. */
X! #   if !defined(MSDOS) || defined(TERMLIB)
X  		AS = "\016";
X  		AE = "\017";
X  #   endif
X***************
X*** 394,410 ****
X  {
X  	xputs(TI);
X  	xputs(VS);
X! #ifdef DECRAINBOW
X! 	/* Select normal ASCII and line drawing character sets.
X! 	 */
X! 	if (flags.DECRainbow) {
X! 		xputs("\033(B\033)0");
X! 		if (!AS) {
X! 			AS = "\016";
X! 			AE = "\017";
X! 		}
X  	}
X- #endif /* DECRAINBOW */
X  }
X  
X  void
X--- 345,361 ----
X  {
X  	xputs(TI);
X  	xputs(VS);
X! 	if (flags.DECgraphics) {
X! 		/* select the line-drawing character set as the alternate
X! 		 * character set
X! 		 * do not select NA ASCII as the primary character set
X! 		 * since people may reasonably be using the UK set
X! 		 */
X! 		xputs("\033)0");
X! 		/* 'as' and 'ae' are missing from some termcaps */
X! 		if (!AS) AS = "\016";  /* ^N */
X! 		if (!AE) AE = "\017";  /* ^O */
X  	}
X  }
X  
X  void
X***************
X*** 417,422 ****
X--- 368,376 ----
X  
X  /* Cursor movements */
X  
X+ #endif /* OVLB */
X+ #ifdef OVL0
X+ 
X  #ifdef CLIPPING
X  /* if (x,y) is currently viewable, move the cursor there and return TRUE */
X  boolean
X***************
X*** 432,437 ****
X--- 386,393 ----
X  }
X  #endif
X  
X+ #endif /* OVLB */
X+ #ifdef OVLB
X  void
X  curs(x, y)
X  register int x, y;	/* not xchar: perhaps xchar is unsigned and
X***************
X*** 457,464 ****
X  
X  #endif /* OVLB */
X  #ifdef OVL0
X  
X! XSTATIC void
X  nocmov(x, y)
X  int x,y;
X  {
X--- 413,425 ----
X  
X  #endif /* OVLB */
X  #ifdef OVL0
X+ /* Note to OVLx tinkerers.  The placement of this overlay controls the location
X+    of the function xputc().  This function is not currnently in trampoli.[ch]
X+    files for what is deemed to be performance reasons.  If this define is moved
X+    and or xputc() is taken out of the ROOT overlay, then action must be taken
X+    in trampoli.[ch]. */
X  
X! STATIC_OVL void
X  nocmov(x, y)
X  int x,y;
X  {
X***************
X*** 518,523 ****
X--- 479,485 ----
X  	curx = x;
X  }
X  
X+ /* See note at OVLx ifdef above.   xputc() is a special function. */
X  void
X  xputc(c)
X  char c;
X***************
X*** 634,639 ****
X--- 596,604 ----
X  	if(ME) xputs(ME);
X  }
X  
X+ #endif /* OVL0 */
X+ #ifdef OVLB
X+ 
X  void
X  backsp()
X  {
X***************
X*** 647,652 ****
X--- 612,620 ----
X  	(void) putchar('\007');		/* curx does not change */
X  	(void) fflush(stdout);
X  }
X+ 
X+ #endif /* OVLB */
X+ #ifdef OVL0
X  
X  #ifdef ASCIIGRAPH
X  void
X*** src/Old/timeout.c	Sun Jun  3 14:13:33 1990
X--- src/timeout.c	Mon May 28 15:47:16 1990
X***************
X*** 4,18 ****
X  
X  #include	"hack.h"
X  
X! #ifdef OVERLAY
X! extern void NDECL(stoned_dialog), NDECL(vomiting_dialog), NDECL(choke_dialog);
X! extern void FDECL(hatch_it, (struct obj*));
X! #endif
X  
X  #ifdef OVLB
X  
X  /* He is being petrified - dialogue by inmet!tower */
X! static const char *stoned_texts[] = {
X  	"You are slowing down.",		/* 5 */
X  	"Your limbs are stiffening.",		/* 4 */
X  	"Your limbs have turned to stone.",	/* 3 */
X--- 4,18 ----
X  
X  #include	"hack.h"
X  
X! STATIC_DCL void NDECL(stoned_dialogue);
X! STATIC_DCL void NDECL(vomiting_dialogue);
X! STATIC_DCL void NDECL(choke_dialogue);
X! STATIC_DCL void FDECL(hatch_it, (struct obj*));
X  
X  #ifdef OVLB
X  
X  /* He is being petrified - dialogue by inmet!tower */
X! static const char NEARDATA *stoned_texts[] = {
X  	"You are slowing down.",		/* 5 */
X  	"Your limbs are stiffening.",		/* 4 */
X  	"Your limbs have turned to stone.",	/* 3 */
X***************
X*** 20,26 ****
X  	"You are a statue."			/* 1 */
X  };
X  
X! XSTATIC void
X  stoned_dialogue() {
X  	register long i = (Stoned & TIMEOUT);
X  
X--- 20,26 ----
X  	"You are a statue."			/* 1 */
X  };
X  
X! STATIC_OVL void
X  stoned_dialogue() {
X  	register long i = (Stoned & TIMEOUT);
X  
X***************
X*** 33,39 ****
X  }
X  
X  /* He is getting sicker and sicker prior to vomiting */
X! static const char *vomiting_texts[] = {
X  	"You are feeling mildly nauseous.",	/* 11 */
X  	"You feel slightly confused.",		/* 8 */
X  	"You can't seem to think straight.",	/* 5 */
X--- 33,39 ----
X  }
X  
X  /* He is getting sicker and sicker prior to vomiting */
X! static const char NEARDATA *vomiting_texts[] = {
X  	"You are feeling mildly nauseous.",	/* 11 */
X  	"You feel slightly confused.",		/* 8 */
X  	"You can't seem to think straight.",	/* 5 */
X***************
X*** 41,47 ****
X  	"You suddenly vomit!"			/* 0 */
X  };
X  
X! XSTATIC void
X  vomiting_dialogue() {
X  	register long i = (Vomiting & TIMEOUT) / 3L;
X  
X--- 41,47 ----
X  	"You suddenly vomit!"			/* 0 */
X  };
X  
X! STATIC_OVL void
X  vomiting_dialogue() {
X  	register long i = (Vomiting & TIMEOUT) / 3L;
X  
X***************
X*** 58,64 ****
X  	}
X  }
X  
X! static const char *choke_texts[] = {
X  	"You find it hard to breathe.",
X  	"You're gasping for air.",
X  	"You can no longer breathe.",
X--- 58,64 ----
X  	}
X  }
X  
X! static const char NEARDATA *choke_texts[] = {
X  	"You find it hard to breathe.",
X  	"You're gasping for air.",
X  	"You can no longer breathe.",
X***************
X*** 66,72 ****
X  	"You suffocate."
X  };
X  
X! XSTATIC void
X  choke_dialogue()
X  {
X  	register long i = (Strangled & TIMEOUT);
X--- 66,72 ----
X  	"You suffocate."
X  };
X  
X! STATIC_OVL void
X  choke_dialogue()
X  {
X  	register long i = (Strangled & TIMEOUT);
X***************
X*** 208,214 ****
X  #endif /* OVL0 */
X  #ifdef OVLB
X  
X! XSTATIC void
X  hatch_it(otmp)		/* hatch the egg "otmp" if possible */
X  register struct obj *otmp;
X  {
X--- 208,214 ----
X  #endif /* OVL0 */
X  #ifdef OVLB
X  
X! STATIC_OVL void
X  hatch_it(otmp)		/* hatch the egg "otmp" if possible */
X  register struct obj *otmp;
X  {
X***************
X*** 238,253 ****
X  
X  #ifdef POLYSELF
X  		if (yours) {
X  		    pline("Its cries sound like \"%s.\"",
X  			flags.female ? "mommy" : "daddy");
X! 		    (void) tamedog(mtmp, (struct obj *)0);
X  		    mtmp->mtame = 20;
X  		    return;
X  		}
X  #endif
X  		if(mtmp->data->mlet == S_DRAGON) {
X  		    verbalize("Gleep!");		/* Mything eggs :-) */
X! 		    (void) tamedog(mtmp, (struct obj *)0);
X  		}
X  	    }
X  	}
X--- 238,267 ----
X  
X  #ifdef POLYSELF
X  		if (yours) {
X+ 		    struct monst *mtmp2;
X+ 
X  		    pline("Its cries sound like \"%s.\"",
X  			flags.female ? "mommy" : "daddy");
X! 		    if (mtmp2 = tamedog(mtmp, (struct obj *)0))
X! 			mtmp = mtmp2;
X  		    mtmp->mtame = 20;
X+ 		    while(otmp = (mtmp->minvent)) {
X+ 			mtmp->minvent = otmp->nobj;
X+ 			free((genericptr_t)otmp);
X+ 		    }
X  		    return;
X  		}
X  #endif
X  		if(mtmp->data->mlet == S_DRAGON) {
X+ 		    struct monst *mtmp2;
X+ 
X  		    verbalize("Gleep!");		/* Mything eggs :-) */
X! 		    if (mtmp2 = tamedog(mtmp, (struct obj *)0))
X! 			mtmp = mtmp2;
X! 		    while(otmp = (mtmp->minvent)) {
X! 			mtmp->minvent = otmp->nobj;
X! 			free((genericptr_t)otmp);
X! 		    }
X  		}
X  	    }
X  	}
X*** src/Old/topl.c	Sun Jun  3 14:13:51 1990
X--- src/topl.c	Sat May 26 22:43:09 1990
X***************
X*** 5,16 ****
X  #define NEED_VARARGS /* Uses ... */	/* comment line for pre-compiled headers */
X  #include "hack.h"
X  
X! VSTATIC char toplines[BUFSIZ];
X  
X  #ifndef OVLB
X! OSTATIC boolean no_repeat;
X  #else /* OVLB */
X! XSTATIC boolean no_repeat = FALSE;
X  #endif /* OVLB */
X  
X  extern xchar tlx, tly;
X--- 5,16 ----
X  #define NEED_VARARGS /* Uses ... */	/* comment line for pre-compiled headers */
X  #include "hack.h"
X  
X! STATIC_VAR char NEARDATA toplines[BUFSIZ];
X  
X  #ifndef OVLB
X! STATIC_DCL boolean no_repeat;
X  #else /* OVLB */
X! STATIC_OVL boolean no_repeat = FALSE;
X  #endif /* OVLB */
X  
X  extern xchar tlx, tly;
X***************
X*** 18,26 ****
X  xchar tlx, tly;			/* set by pline; used by addtopl */
X  #endif /* OVLB */
X  
X! OSTATIC void NDECL(redotoplin);
X! OSTATIC void FDECL(xmore,(const char *));
X! VSTATIC struct topl {
X  	struct topl *next_topl;
X  	char *topl_text;
X  } *old_toplines, *last_redone_topl;
X--- 18,26 ----
X  xchar tlx, tly;			/* set by pline; used by addtopl */
X  #endif /* OVLB */
X  
X! STATIC_DCL void NDECL(redotoplin);
X! STATIC_DCL void FDECL(xmore,(const char *));
X! STATIC_VAR struct topl {
X  	struct topl *next_topl;
X  	char *topl_text;
X  } *old_toplines, *last_redone_topl;
X***************
X*** 29,35 ****
X  
X  #ifdef OVL1
X  
X! XSTATIC void
X  redotoplin() {
X  	home();
X  	if(index(toplines, '\n')) cl_end();
X--- 29,35 ----
X  
X  #ifdef OVL1
X  
X! STATIC_OVL void
X  redotoplin() {
X  	home();
X  	if(index(toplines, '\n')) cl_end();
X***************
X*** 78,84 ****
X  	   !strcmp(toplines, old_toplines->topl_text)) return;
X  	last_redone_topl = 0;
X  	tl = (struct topl *)
X! 		alloc((unsigned)(strlen(toplines) + sizeof(struct topl) + 1));
X  	tl->next_topl = old_toplines;
X  	tl->topl_text = (char *)(tl + 1);
X  	Strcpy(tl->topl_text, toplines);
X--- 78,84 ----
X  	   !strcmp(toplines, old_toplines->topl_text)) return;
X  	last_redone_topl = 0;
X  	tl = (struct topl *)
X! 		alloc((unsigned)(strlen(toplines) + sizeof(struct topl) + 3));
X  	tl->next_topl = old_toplines;
X  	tl->topl_text = (char *)(tl + 1);
X  	Strcpy(tl->topl_text, toplines);
X***************
X*** 108,114 ****
X  #endif /* OVL1 */
X  #ifdef OVL2
X  
X! XSTATIC void
X  xmore(s)
X  const char *s;	/* allowed chars besides space/return */
X  {
X--- 108,114 ----
X  #endif /* OVL1 */
X  #ifdef OVL2
X  
X! STATIC_OVL void
X  xmore(s)
X  const char *s;	/* allowed chars besides space/return */
X  {
X*** src/Old/topten.c	Sun Jun  3 14:14:11 1990
X--- src/topten.c	Sun May 27 20:50:35 1990
X***************
X*** 19,27 ****
X  #endif
X  #include <ctype.h>
X  
X! #ifdef LATTICE
X! static void FDECL(lattice_mung_line,(char*));
X! static void FDECL(lattice_unmung_line,(char*));
X  #endif
X  
X  #define newttentry() (struct toptenentry *) alloc(sizeof(struct toptenentry))
X--- 19,27 ----
X  #endif
X  #include <ctype.h>
X  
X! #ifdef NO_SCAN_BRACK
X! static void FDECL(nsb_mung_line,(char*));
X! static void FDECL(nsb_unmung_line,(char*));
X  #endif
X  
X  #define newttentry() (struct toptenentry *) alloc(sizeof(struct toptenentry))
X***************
X*** 48,63 ****
X  
X  static char *FDECL(itoa, (int));
X  static const char *FDECL(ordin, (int));
X! static void outheader();
X  static int FDECL(outentry, (int,struct toptenentry *,int));
X  
X  /* must fit with end.c */
X! static const char *killed_by_prefix[] = {
X  	"killed by ", "choked on ", "poisoned by ", "", "drowned in ",
X  	"", "crushed to death by ", "petrified by ", "",
X  	"", "",
X  	"", "", "" };
X  
X  void
X  topten(how)
X  int how;
X--- 48,131 ----
X  
X  static char *FDECL(itoa, (int));
X  static const char *FDECL(ordin, (int));
X! static void NDECL(outheader);
X  static int FDECL(outentry, (int,struct toptenentry *,int));
X+ static void FDECL(readentry, (FILE *,struct toptenentry *));
X+ static void FDECL(writeentry, (FILE *,struct toptenentry *));
X+ static int FDECL(classmon, (CHAR_P,BOOLEAN_P));
X+ static boolean FDECL(onlyspace, (const char *));
X  
X  /* must fit with end.c */
X! static const char NEARDATA *killed_by_prefix[] = {
X  	"killed by ", "choked on ", "poisoned by ", "", "drowned in ",
X  	"", "crushed to death by ", "petrified by ", "",
X  	"", "",
X  	"", "", "" };
X  
X+ static void
X+ readentry(rfile,tt)
X+ FILE *rfile;
X+ struct toptenentry *tt;
X+ {
X+ # ifdef NO_SCAN_BRACK
X+ 	if(fscanf(rfile,"%6s %d %d %d %d %d %ld%*c%c%c %s %s",
X+ #  define TTFIELDS 12
X+ # else
X+ 	if(fscanf(rfile, "%6s %d %d %d %d %d %ld %c%c %[^,],%[^\n]",
X+ #  define TTFIELDS 11
X+ # endif
X+ 		tt->date, &tt->uid,
X+ 		&tt->level,
X+ 		&tt->maxlvl, &tt->hp, &tt->maxhp, &tt->points,
X+ 		&tt->plchar, &tt->sex,
X+ #ifdef LATTICE	/* return value is broken also, sigh */
X+ 		tt->name, tt->death) < 1)
X+ #else
X+ 		tt->name, tt->death) != TTFIELDS)
X+ #endif
X+ #undef TTFIELDS
X+ 			tt->points = 0;
X+ #ifdef NO_SCAN_BRACK
X+ 	if(tt->points > 0) {
X+ 		nsb_unmung_line(tt->name);
X+ 		nsb_unmung_line(tt->death);
X+ 	}
X+ #endif
X+ }
X+ 
X+ static void
X+ writeentry(rfile,tt)
X+ FILE *rfile;
X+ struct toptenentry *tt;
X+ {
X+ #ifdef NO_SCAN_BRACK
X+ 	nsb_mung_line(tt->name);
X+ 	nsb_mung_line(tt->death);
X+ #endif
X+ # ifdef NO_SCAN_BRACK
X+ 	(void) fprintf(rfile,"%6s %d %d %d %d %d %ld %c%c %s %s\n",
X+ # else
X+ 	(void) fprintf(rfile,"%6s %d %d %d %d %d %ld %c%c %s,%s\n",
X+ # endif
X+ 		tt->date, tt->uid,
X+ 		tt->level,
X+ 		tt->maxlvl, tt->hp, tt->maxhp, tt->points,
X+ 		tt->plchar, tt->sex,
X+ 		onlyspace(tt->name) ? "_" : tt->name, tt->death);
X+ #ifdef NO_SCAN_BRACK
X+ 	nsb_unmung_line(tt->name);
X+ 	nsb_unmung_line(tt->death);
X+ #endif
X+ }
X+ 
X+ static boolean
X+ onlyspace(s)
X+ const char *s;
X+ {
X+ 	for (;*s;s++) if (!isspace(*s)) return(FALSE);
X+ 	return(TRUE);
X+ }
X+ 
X  void
X  topten(how)
X  int how;
X***************
X*** 65,71 ****
X  	int uid = getuid();
X  	int rank, rank0 = -1, rank1 = 0;
X  	int occ_cnt = PERSMAX;
X! 	register struct toptenentry *t0, *t1, *tprev;
X  #ifdef UNIX
X  	char *reclock = "record_lock";
X  # ifdef NO_FILE_LINKS
X--- 133,140 ----
X  	int uid = getuid();
X  	int rank, rank0 = -1, rank1 = 0;
X  	int occ_cnt = PERSMAX;
X! 	register struct toptenentry *t0, *tprev;
X! 	register struct toptenentry *t1;
X  #ifdef UNIX
X  	char *reclock = "record_lock";
X  # ifdef NO_FILE_LINKS
X***************
X*** 170,180 ****
X  		HUP (void) puts("Cannot open log file!");
X  		goto lgend;
X  	}
X! 	(void) fprintf(lfile,"%6s %d %d %d %d %d %ld %c%c %s,%s\n",
X! 	    t0->date, t0->uid,
X! 	    t0->level, t0->maxlvl,
X! 	    t0->hp, t0->maxhp, t0->points,
X! 	    t0->plchar, t0->sex, t0->name, t0->death);
X  	(void) fclose(lfile);
X  # if defined(UNIX) || defined(VMS)
X  	(void) unlink(loglock);
X--- 239,245 ----
X  		HUP (void) puts("Cannot open log file!");
X  		goto lgend;
X  	}
X! 	writeentry(lfile, t0);
X  	(void) fclose(lfile);
X  # if defined(UNIX) || defined(VMS)
X  	(void) unlink(loglock);
X***************
X*** 228,240 ****
X  			short	i;
X  	
X  			rfile = openFile(recfile,"r");
X- 			
X- 			for (i = 0;i < t->maxRow; i++) {
X- 			    MoveTo(Screen_Border,
X- 				t->ascent + (i * t->height) + Screen_Border);
X- 			    DrawText(&t->screen[i][0], 0, t->maxCol);
X- 			}
X- 			ValidRect(&(**(*HackWindow).visRgn).rgnBBox);
X  		}
X  	}
X  
X--- 293,298 ----
X***************
X*** 257,280 ****
X  	tprev = 0;
X  	/* rank0: -1 undefined, 0 not_on_list, n n_th on list */
X  	for(rank = 1; ; ) {
X! #ifdef LATTICE
X! 	    if(fscanf(rfile,"%6s %d %d %d %d %d %ld%*c%c%c %s %s",
X! #else
X! 	    if(fscanf(rfile, "%6s %d %d %d %d %d %ld %c%c %[^,],%[^\n]",
X! #endif /* LATTICE */
X! 		t1->date, &t1->uid,
X! 		&t1->level, &t1->maxlvl,
X! 		&t1->hp, &t1->maxhp, &t1->points,
X! 		&t1->plchar, &t1->sex,
X! #ifdef LATTICE	/* return value is broken also, sigh */
X! 		t1->name, t1->death) <1    || t1->points < POINTSMIN)
X! #else
X! 		t1->name, t1->death) != 11 || t1->points < POINTSMIN)
X! #endif
X! 			t1->points = 0;
X! #ifdef LATTICE
X! 	    lattice_unmung_line(t1->death);
X! #endif
X  	    if(rank0 < 0 && t1->points < t0->points) {
X  		rank0 = rank++;
X  		if(tprev == 0)
X--- 315,322 ----
X  	tprev = 0;
X  	/* rank0: -1 undefined, 0 not_on_list, n n_th on list */
X  	for(rank = 1; ; ) {
X! 	    readentry(rfile, t1);
X! 	    if (t1->points < POINTSMIN) t1->points = 0;
X  	    if(rank0 < 0 && t1->points < t0->points) {
X  		rank0 = rank++;
X  		if(tprev == 0)
X***************
X*** 342,364 ****
X  	if(!done_stopprint) outheader();
X  	t1 = tt_head;
X  	for(rank = 1; t1->points != 0; rank++, t1 = t1->tt_next) {
X! #ifdef LATTICE
X! 	  lattice_mung_line(t1->death);
X! 	  if(flg) (void) fprintf(rfile,"%6s %d %d %d %d %d %ld %c%c %s %s\n",
X! #else
X! 	  if(flg) (void) fprintf(rfile,"%6s %d %d %d %d %d %ld %c%c %s,%s\n",
X! #endif
X! 	    t1->date, t1->uid,
X! 	    t1->level, t1->maxlvl,
X! 	    t1->hp, t1->maxhp, t1->points,
X! 	    t1->plchar, t1->sex, t1->name, t1->death);
X! #ifdef LATTICE
X! 	  lattice_unmung_line(t1->death);
X! #endif
X! 	  if(done_stopprint) continue;
X! 	  if(rank > flags.end_top &&
X! 	    (rank < rank0-flags.end_around || rank > rank0+flags.end_around)
X! 	    && (!flags.end_own ||
X  #ifdef PERS_IS_UID
X  				  t1->uid != t0->uid
X  #else
X--- 384,394 ----
X  	if(!done_stopprint) outheader();
X  	t1 = tt_head;
X  	for(rank = 1; t1->points != 0; rank++, t1 = t1->tt_next) {
X! 	    if(flg) writeentry(rfile, t1);
X! 	    if(done_stopprint) continue;
X! 	    if(rank > flags.end_top &&
X! 	      (rank < rank0-flags.end_around || rank > rank0+flags.end_around)
X! 	      && (!flags.end_own ||
X  #ifdef PERS_IS_UID
X  				  t1->uid != t0->uid
X  #else
X***************
X*** 365,388 ****
X  				  strncmp(t1->name, t0->name, NAMSZ)
X  #endif
X  		)) continue;
X! 	  if(rank == rank0-flags.end_around &&
X! 	     rank0 > flags.end_top+flags.end_around+1 &&
X! 	     !flags.end_own)
X  		(void) putchar('\n');
X! 	  if(rank != rank0)
X  		(void) outentry(rank, t1, 0);
X! 	  else if(!rank1)
X  		(void) outentry(rank, t1, 1);
X! 	  else {
X  		int t0lth = outentry(0, t0, -1);
X  		int t1lth = outentry(rank, t1, t0lth);
X  		if(t1lth > t0lth) t0lth = t1lth;
X  		(void) outentry(0, t0, t0lth);
X! 	  }
X  	}
X  	if(rank0 >= rank) if(!done_stopprint)
X  		(void) outentry(0, t0, 1);
X  	(void) fclose(rfile);
X  #ifdef VMS
X  	if (flg) {
X  		delete(RECORD);
X--- 395,437 ----
X  				  strncmp(t1->name, t0->name, NAMSZ)
X  #endif
X  		)) continue;
X! 	    if(rank == rank0-flags.end_around &&
X! 	       rank0 > flags.end_top+flags.end_around+1 &&
X! 	       !flags.end_own)
X  		(void) putchar('\n');
X! 	    if(rank != rank0)
X  		(void) outentry(rank, t1, 0);
X! 	    else if(!rank1)
X  		(void) outentry(rank, t1, 1);
X! 	    else {
X  		int t0lth = outentry(0, t0, -1);
X  		int t1lth = outentry(rank, t1, t0lth);
X  		if(t1lth > t0lth) t0lth = t1lth;
X  		(void) outentry(0, t0, t0lth);
X! 	    }
X  	}
X  	if(rank0 >= rank) if(!done_stopprint)
X  		(void) outentry(0, t0, 1);
X  	(void) fclose(rfile);
X+ #ifdef MACOS
X+ 	{
X+ 		Str255	name;
X+ 		FInfo	fndrInfo;
X+ 		term_info	*t;
X+ 		short	oldVol, error;
X+ 		
X+ 		t = (term_info *)GetWRefCon(HackWindow);
X+ 		GetVol(name, &oldVol);
X+ 		SetVol(0L, t->recordVRefNum);
X+ 		Strcpy((char *)name,recfile);
X+ 		CtoPstr((char *)name);
X+ 		error = GetFInfo(name, (short)0, &fndrInfo);
X+ 		fndrInfo.fdCreator = CREATOR;
X+ 		if (error == noErr)
X+ 			SetFInfo(name, (short)0, &fndrInfo);
X+ 		SetVol(0L, oldVol);
X+ 	}
X+ #endif
X  #ifdef VMS
X  	if (flg) {
X  		delete(RECORD);
X***************
X*** 469,475 ****
X  	    Sprintf(eos(linebuf), " on dungeon level %d", t1->level);
X  	  if(t1->maxlvl != t1->level)
X  	    Sprintf(eos(linebuf), " [max %d]", t1->maxlvl);
X! 	/* kuldge for "quit while already on Charon's boat" */
X  	  if(!strncmp(t1->death, "quit ", 5))
X  	    Strcat(linebuf, t1->death + 4);
X  	}
X--- 518,524 ----
X  	    Sprintf(eos(linebuf), " on dungeon level %d", t1->level);
X  	  if(t1->maxlvl != t1->level)
X  	    Sprintf(eos(linebuf), " [max %d]", t1->maxlvl);
X! 	/* kludge for "quit while already on Charon's boat" */
X  	  if(!strncmp(t1->death, "quit ", 5))
X  	    Strcat(linebuf, t1->death + 4);
X  	}
X***************
X*** 504,510 ****
X  	/* Quit, starved, ascended, and escaped contain no second line */
X  	if (second_line) {
X  		Strcpy(linebuf2, t1->death);
X! 		*linebuf2 = toupper(*linebuf2);
X  		Strcat(linebuf2, ".");
X  	}
X  
X--- 553,559 ----
X  	/* Quit, starved, ascended, and escaped contain no second line */
X  	if (second_line) {
X  		Strcpy(linebuf2, t1->death);
X! 		if (islower(*linebuf2)) *linebuf2 = toupper(*linebuf2);
X  		Strcat(linebuf2, ".");
X  	}
X  
X***************
X*** 619,649 ****
X  
X  	t1 = tt_head = newttentry();
X  	for(rank = 1; ; rank++) {
X! #ifdef LATTICE
X! 	  if(fscanf(rfile, "%6s %d %d %d %d %d %ld%*c%c%c %s %s",
X! #else
X! 	  if(fscanf(rfile, "%6s %d %d %d %d %d %ld %c%c %[^,],%[^\n]",
X! #endif /* LATTICE */
X! 		t1->date, &t1->uid,
X! 		&t1->level, &t1->maxlvl,
X! 		&t1->hp, &t1->maxhp, &t1->points,
X! 		&t1->plchar, &t1->sex,
X! #ifdef LATTICE
X! 		t1->name, t1->death)<1)
X! #else
X! 		t1->name, t1->death) != 11)
X! #endif
X! 			t1->points = 0;
X! 	  if(t1->points == 0) break;
X! #ifdef LATTICE
X! 	   lattice_unmung_line(t1->death);
X! #endif
X  #ifdef PERS_IS_UID
X! 	  if(!playerct && t1->uid == uid)
X  		flg++;
X! 	  else
X  #endif
X! 	  for(i = 0; i < playerct; i++){
X  		if(strcmp(players[i], "all") == 0 ||
X  		   strncmp(t1->name, players[i], NAMSZ) == 0 ||
X  		  (players[i][0] == '-' &&
X--- 668,681 ----
X  
X  	t1 = tt_head = newttentry();
X  	for(rank = 1; ; rank++) {
X! 	    readentry(rfile, t1);
X! 	    if(t1->points == 0) break;
X  #ifdef PERS_IS_UID
X! 	    if(!playerct && t1->uid == uid)
X  		flg++;
X! 	    else
X  #endif
X! 	    for(i = 0; i < playerct; i++){
X  		if(strcmp(players[i], "all") == 0 ||
X  		   strncmp(t1->name, players[i], NAMSZ) == 0 ||
X  		  (players[i][0] == '-' &&
X***************
X*** 651,658 ****
X  		   players[i][2] == 0) ||
X  		  (digit(players[i][0]) && rank <= atoi(players[i])))
X  			flg++;
X! 	  }
X! 	  t1 = t1->tt_next = newttentry();
X  	}
X  	(void) fclose(rfile);
X  	if(!flg) {
X--- 683,690 ----
X  		   players[i][2] == 0) ||
X  		  (digit(players[i][0]) && rank <= atoi(players[i])))
X  			flg++;
X! 	    }
X! 	    t1 = t1->tt_next = newttentry();
X  	}
X  	(void) fclose(rfile);
X  	if(!flg) {
X***************
X*** 715,720 ****
X--- 747,755 ----
X  		break;
X  	}
X  #endif /* nonsense /**/
X+ #ifdef MACOS
X+ 	more();
X+ #endif
X  }
X  
X  static int
X***************
X*** 772,796 ****
X  	rank = rnd(10);
X  pickentry:
X  	for(i = rank; i; i--) {
X! #ifdef LATTICE
X! 	  if(fscanf(rfile, "%6s %d %d %d %d %d %ld%*c%c%c %s %s",
X! #else
X! 	  if(fscanf(rfile, "%6s %d %d %d %d %d %ld %c%c %[^,],%[^\n]",
X! #endif
X! 		tt->date, &tt->uid,
X! 		&tt->level, &tt->maxlvl,
X! 		&tt->hp, &tt->maxhp, &tt->points,
X! 		&tt->plchar, &tt->sex,
X! #ifdef LATTICE
X! 		tt->name, tt->death) <1)
X! #else
X! 		tt->name, tt->death) != 11)
X! #endif
X! 			tt->points = 0;
X! 	  if(tt->points == 0) break;
X! #ifdef LATTICE
X! 	  lattice_unmung_line(tt->death);
X! #endif
X  	}
X  
X  	if(tt->points == 0) {
X--- 807,814 ----
X  	rank = rnd(10);
X  pickentry:
X  	for(i = rank; i; i--) {
X! 	    readentry(rfile, tt);
X! 	    if(tt->points == 0) break;
X  	}
X  
X  	if(tt->points == 0) {
X***************
X*** 814,828 ****
X  	return otmp;
X  }
X  
X! #ifdef LATTICE
X  /* Lattice scanf isn't up to reading the scorefile.  What */
X  /* follows deals with that; I admit it's ugly. (KL) */
X! static void lattice_mung_line(p)
X  	char *p;
X  	{
X  	while(p=strchr(p,' '))*p='|';
X  }
X! static void lattice_unmung_line(p)
X  	char *p;
X  	{
X  	while(p=strchr(p,'|'))*p=' ';
X--- 832,847 ----
X  	return otmp;
X  }
X  
X! #ifdef NO_SCAN_BRACK
X  /* Lattice scanf isn't up to reading the scorefile.  What */
X  /* follows deals with that; I admit it's ugly. (KL) */
X! /* Now generally available (KL) */
X! static void nsb_mung_line(p)
X  	char *p;
X  	{
X  	while(p=strchr(p,' '))*p='|';
X  }
X! static void nsb_unmung_line(p)
X  	char *p;
X  	{
X  	while(p=strchr(p,'|'))*p=' ';
X*** src/Old/track.c	Sun Jun  3 14:14:46 1990
X--- src/track.c	Sat May 26 22:43:19 1990
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)track.c	1.4	87/08/08
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  /* track.c - version 1.0.2 */
X--- 1,4 ----
X! /*	SCCS Id: @(#)track.c	3.0	87/08/08
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  /* track.c - version 1.0.2 */
X***************
X*** 7,14 ****
X  
X  #define	UTSZ	50
X  
X! VSTATIC int utcnt, utpnt;
X! VSTATIC coord utrack[UTSZ];
X  
X  #ifdef OVLB
X  void
X--- 7,14 ----
X  
X  #define	UTSZ	50
X  
X! STATIC_VAR int NEARDATA utcnt, NEARDATA utpnt;
X! STATIC_VAR coord NEARDATA utrack[UTSZ];
X  
X  #ifdef OVLB
X  void
X*** src/Old/trap.c	Sun Jun  3 14:15:03 1990
X--- src/trap.c	Thu May 31 22:13:54 1990
X***************
X*** 36,45 ****
X  #endif /* OVLB */
X  
X  void NDECL(domagictrap);
X! OSTATIC boolean FDECL(thitm, (int, struct monst *, struct obj *, int));
X  
X  #ifdef OVLB
X  
X  /* Generic rust-armor function.  Returns TRUE if a message was printed;
X   * "print", if set, means to print a message (and thus to return TRUE) even
X   * if the item could not be rusted; otherwise a message is printed and TRUE is
X--- 36,47 ----
X  #endif /* OVLB */
X  
X  void NDECL(domagictrap);
X! STATIC_DCL boolean FDECL(thitm, (int, struct monst *, struct obj *, int));
X  
X  #ifdef OVLB
X  
X+ static void NDECL(vtele);
X+ 
X  /* Generic rust-armor function.  Returns TRUE if a message was printed;
X   * "print", if set, means to print a message (and thus to return TRUE) even
X   * if the item could not be rusted; otherwise a message is printed and TRUE is
X***************
X*** 52,60 ****
X  int type;
X  boolean print;
X  {
X! 	static const char *gook[] = { "slag", "rust", "rot", "corrosion" };
X! 	static const char *action[] = { "smolder", "rust", "rot", "corrode" };
X! 	static const char *msg[] =  { "burnt", "rusted", "rotten", "corroded" };
X  	boolean vulnerable = FALSE;
X  	boolean plural;
X  
X--- 54,62 ----
X  int type;
X  boolean print;
X  {
X! 	static const char NEARDATA *gook[] = { "slag", "rust", "rot", "corrosion" };
X! 	static const char NEARDATA *action[] = { "smolder", "rust", "rot", "corrode" };
X! 	static const char NEARDATA *msg[] =  { "burnt", "rusted", "rotten", "corroded" };
X  	boolean vulnerable = FALSE;
X  	boolean plural;
X  
X***************
X*** 201,206 ****
X--- 203,251 ----
X  }
X  
X  void
X+ fall_through(td)
X+ boolean td;	/* td == TRUE : trapdoor */
X+ {
X+ 	register int newlevel = dlevel + 1;
X+ 
X+ 	while(!rn2(4) && newlevel < 29) newlevel++;
X+ 	if(td) pline("A trap door opens up under you!");
X+ 	else pline("The floor opens up under you!");
X+ 	if(Levitation || u.ustuck || dlevel == MAXLEVEL
X+ #ifdef POLYSELF
X+ 		|| is_flyer(uasmon) || u.umonnum == PM_WUMPUS
X+ #endif
X+ #ifdef ENDGAME
X+ 		|| dlevel == ENDLEVEL
X+ #endif
X+ 	) {
X+ 	    You("don't fall in.");
X+ 	    if(!td) {
X+ 		more();
X+ 		pline("The opening under you closes up.");
X+ 	    }
X+ 	    return;
X+ 	}
X+ #ifdef WALKIES
X+ 	if(!next_to_u()) {
X+ 	    You("are jerked back by your pet!");
X+ 	    if(!td) {
X+ 		more();
X+ 		pline("The opening in the floor closes up.");
X+ 	    }
X+ 	} else {
X+ #endif
X+ 	    if(in_shop(u.ux, u.uy)) shopdig(1);
X+ 	    unsee();
X+ 	    (void) fflush(stdout);
X+ 	    goto_level(newlevel, FALSE, TRUE);
X+ 	    if(!td) pline("The hole in the ceiling above you closes up.");
X+ #ifdef WALKIES
X+ 	}
X+ #endif
X+ }
X+ 
X+ void
X  dotrap(trap)
X  register struct trap *trap;
X  {
X***************
X*** 271,276 ****
X--- 316,322 ----
X  		    break;
X  		case MONST_TRAP:
X  		    if(mtmp=makemon(&mons[trap->pm],u.ux,u.uy)) {
X+ 		      mtmp->mpeaceful = FALSE;
X  		      switch(mtmp->data->mlet) {
X  			case S_PIERCER:
X  			    pline("%s suddenly drops from the ceiling!",
X***************
X*** 317,350 ****
X  				|| u.uundetected
X  #endif
X  						) newsym(u.ux, u.uy);
X! 		    } else {
X! 			register int newlevel = dlevel + 1;
X! 			while(!rn2(4) && newlevel < 29) newlevel++;
X! 			pline("A trap door opens up under you!");
X! 			if(Levitation || u.ustuck || dlevel == MAXLEVEL
X! #ifdef POLYSELF
X! 				|| is_flyer(uasmon) || u.umonnum == PM_WUMPUS
X! #endif
X! #ifdef ENDGAME
X! 				|| dlevel == ENDLEVEL
X! #endif
X! 							) {
X! 			    You("don't fall in.");
X! 			    break;
X! 			}
X! #ifdef WALKIES
X! 			if(!next_to_u())
X! 			    You("are jerked back by your pet!");
X! 			else {
X! #endif
X! 			    if(in_shop(u.ux, u.uy)) shopdig(1);
X! 			    unsee();
X! 			    (void) fflush(stdout);
X! 			    goto_level(newlevel, FALSE, TRUE);
X! #ifdef WALKIES
X! 			}
X! #endif
X! 		    }
X  		    break;
X  		case DART_TRAP:
X  		    pline("A little dart shoots out at you!");
X--- 363,369 ----
X  				|| u.uundetected
X  #endif
X  						) newsym(u.ux, u.uy);
X! 		    } else fall_through(TRUE);
X  		    break;
X  		case DART_TRAP:
X  		    pline("A little dart shoots out at you!");
X***************
X*** 644,654 ****
X  
X  #ifdef WALKIES
X  
X! OSTATIC boolean FDECL(teleport_pet, (struct monst *));
X  
X  #ifdef OVLB
X  
X! XSTATIC boolean
X  teleport_pet(mtmp)
X  register struct monst *mtmp;
X  {
X--- 663,673 ----
X  
X  #ifdef WALKIES
X  
X! STATIC_DCL boolean FDECL(teleport_pet, (struct monst *));
X  
X  #ifdef OVLB
X  
X! STATIC_OVL boolean
X  teleport_pet(mtmp)
X  register struct monst *mtmp;
X  {
X***************
X*** 674,684 ****
X  
X  #endif /* OVLB */
X  
X! #endif
X  
X  #ifdef OVLB
X  
X! XSTATIC void
X  seetrap(trap)
X  
X  	register struct trap *trap;
X--- 693,705 ----
X  
X  #endif /* OVLB */
X  
X! #endif /* WALKIES */
X! 
X! STATIC_DCL void FDECL(seetrap, (struct trap *));
X  
X  #ifdef OVLB
X  
X! STATIC_OVL void
X  seetrap(trap)
X  
X  	register struct trap *trap;
X***************
X*** 929,938 ****
X  
X  			if(rn2(3))
X  				break; /* monsters usually don't set it off */
X! 			if(in_sight)
X  			    pline("KAABLAMM!!!  %s triggers a land mine!",
X  				  Monnam(mtmp));
X! 			else if (flags.soundok)
X  				pline("Kaablamm!  You hear an explosion in the distance!");
X  			deltrap(t_at(mtmp->mx, mtmp->my));
X  			if(thitm(0, mtmp, (struct obj *)0, rnd(16)))
X--- 950,967 ----
X  
X  			if(rn2(3))
X  				break; /* monsters usually don't set it off */
X! 			if(is_flyer(mtmp->data)) {
X! 				if (in_sight) {
X! 	pline("A trigger appears in a pile of soil below %s.", Monnam(mtmp));
X! 					seetrap(trap);
X! 				}
X! 				if (rn2(3)) break;
X! 				if (in_sight)
X! 					pline("The air currents set it off!");
X! 			} else if(in_sight)
X  			    pline("KAABLAMM!!!  %s triggers a land mine!",
X  				  Monnam(mtmp));
X! 			if (!in_sight && flags.soundok)
X  				pline("Kaablamm!  You hear an explosion in the distance!");
X  			deltrap(t_at(mtmp->mx, mtmp->my));
X  			if(thitm(0, mtmp, (struct obj *)0, rnd(16)))
X***************
X*** 1246,1255 ****
X  
X  void
X  level_tele() {
X! register int newlevel;
X! #ifdef WALKIES
X! register boolean pet_by_u = next_to_u();
X! #endif
X  
X  	if(u.uhave_amulet
X  #ifdef ENDGAME
X--- 1275,1281 ----
X  
X  void
X  level_tele() {
X! 	register int newlevel;
X  
X  	if(u.uhave_amulet
X  #ifdef ENDGAME
X***************
X*** 1284,1293 ****
X  	    if(dlevel == newlevel)
X  		if(is_maze_lev) newlevel--; else newlevel++;
X  	}
X! 	if(newlevel < 0) {
X  #ifdef WALKIES
X! 	    if(pet_by_u) {
X  #endif
X  		if(newlevel <= -10) {
X  			You("arrive in heaven.");
X  			verbalize("Thou art early, but we'll admit thee.");
X--- 1310,1324 ----
X  	    if(dlevel == newlevel)
X  		if(is_maze_lev) newlevel--; else newlevel++;
X  	}
X! 
X  #ifdef WALKIES
X! 	if(!next_to_u()) {
X! 		You("shudder for a moment...");
X! 		return;
X! 	}
X  #endif
X+ 
X+ 	if(newlevel < 0) {
X  		if(newlevel <= -10) {
X  			You("arrive in heaven.");
X  			verbalize("Thou art early, but we'll admit thee.");
X***************
X*** 1294,1348 ****
X  			killer_format = NO_KILLER_PREFIX;
X  			killer = "went to heaven prematurely";
X  			done(DIED);
X  		} else	if (newlevel == -9) {
X  			You("feel deliriously happy. ");
X  			pline("(In fact, you're on Cloud 9!) ");
X  			more();
X  		} else
X! #ifndef STRONGHOLD
X! 			newlevel = 0;
X! #else
X! 			newlevel = 1;
X! #endif
X! 		You("are now high above the clouds...");
X  		if(Levitation) {
X  		    You("float gently down to earth.");
X! #ifndef STRONGHOLD
X  		    done(ESCAPED);
X  #endif
X  		}
X  #ifdef POLYSELF
X! 		if(is_flyer(uasmon)) {
X  		    You("fly down to earth.");
X! # ifndef STRONGHOLD
X  		    done(ESCAPED);
X  # endif
X  		}
X  #endif
X! 		pline("Unfortunately, you don't know how to fly.");
X! 		You("plummet a few thousand feet to your death.");
X! 		dlevel = 0;
X! 		killer_format = NO_KILLER_PREFIX;
X! 		killer =
X      self_pronoun("teleported out of the dungeon and fell to %s death","his");
X! 		done(DIED);
X! #ifdef WIZARD
X! 		return;  
X! #endif
X! #ifdef WALKIES
X! 	    } else {
X! 		You("shudder for a moment...");
X! 		return;
X! 	    }
X! #endif
X  	}
X  	/* calls done(ESCAPED) if newlevel==0 */
X! #ifdef WALKIES
X! 	if(!pet_by_u)
X! 	    You("shudder for a moment...");
X! 	else
X! #endif
X! 	    goto_level(newlevel, FALSE, FALSE);
X  }
X  
X  void
X--- 1325,1374 ----
X  			killer_format = NO_KILLER_PREFIX;
X  			killer = "went to heaven prematurely";
X  			done(DIED);
X+ 			return;
X  		} else	if (newlevel == -9) {
X  			You("feel deliriously happy. ");
X  			pline("(In fact, you're on Cloud 9!) ");
X  			more();
X  		} else
X! 			You("are now high above the clouds...");
X! 
X  		if(Levitation) {
X  		    You("float gently down to earth.");
X! #ifdef STRONGHOLD
X! 		    newlevel = 1;
X! #else
X  		    done(ESCAPED);
X  #endif
X  		}
X  #ifdef POLYSELF
X! 		else if(is_flyer(uasmon)) {
X  		    You("fly down to earth.");
X! # ifdef STRONGHOLD
X! 		    newlevel = 1;
X! # else
X  		    done(ESCAPED);
X  # endif
X  		}
X  #endif
X! 		else {
X! 		    int save_dlevel;
X! 
X! 		    save_dlevel = dlevel;
X! 		    pline("Unfortunately, you don't know how to fly.");
X! 		    You("plummet a few thousand feet to your death.");
X! 		    dlevel = 0;
X! 		    killer_format = NO_KILLER_PREFIX;
X! 		    killer =
X      self_pronoun("teleported out of the dungeon and fell to %s death","his");
X! 		    done(DIED);
X! 		    dlevel = save_dlevel;
X! 		    return;  
X! 		}
X  	}
X+ 
X  	/* calls done(ESCAPED) if newlevel==0 */
X! 	goto_level(newlevel, FALSE, FALSE);
X  }
X  
X  void
X***************
X*** 1418,1429 ****
X  	     case 19:
X  		    /* tame nearby monsters */
X  		   {   register int i,j;
X  
X  		       /* below pline added by GAN 10/30/86 */
X  		       adjattrib(A_CHA,1,FALSE);
X! 		       for(i = -1; i <= 1; i++) for(j = -1; j <= 1; j++)
X! 		       if(MON_AT(u.ux+i, u.uy+j))
X! 			   (void) tamedog(m_at(u.ux+i, u.uy+j), (struct obj *)0);
X  		       break;
X  		   }
X  
X--- 1444,1459 ----
X  	     case 19:
X  		    /* tame nearby monsters */
X  		   {   register int i,j;
X+ 		       register struct monst *mtmp;
X  
X  		       /* below pline added by GAN 10/30/86 */
X  		       adjattrib(A_CHA,1,FALSE);
X! 		       for(i = -1; i <= 1; i++) for(j = -1; j <= 1; j++) {
X! 			   if(!isok(u.ux+i, u.uy+j)) continue;
X! 			   mtmp = m_at(u.ux+i, u.uy+j);
X! 			   if(mtmp)
X! 			       (void) tamedog(mtmp, (struct obj *)0);
X! 		       }
X  		       break;
X  		   }
X  
X***************
X*** 1695,1702 ****
X  		case 4:
X  		case 3:
X  			pline("Suddenly you are frozen in place!");
X  			nomovemsg = "You can move again.";
X- 			multi = -d(5, 6);
X  			break;
X  		case 2:
X  		case 1:
X--- 1725,1732 ----
X  		case 4:
X  		case 3:
X  			pline("Suddenly you are frozen in place!");
X+ 			nomul(-d(5, 6));
X  			nomovemsg = "You can move again.";
X  			break;
X  		case 2:
X  		case 1:
X***************
X*** 1781,1787 ****
X  
X  /* Monster is hit by trap. */
X  /* Note: doesn't work if both obj and d_override are null */
X! XSTATIC boolean
X  thitm(tlev, mon, obj, d_override)
X  register int tlev;
X  register struct monst *mon;
X--- 1811,1817 ----
X  
X  /* Monster is hit by trap. */
X  /* Note: doesn't work if both obj and d_override are null */
X! STATIC_OVL boolean
X  thitm(tlev, mon, obj, d_override)
X  register int tlev;
X  register struct monst *mon;
X*** src/Old/u_init.c	Sun Jun  3 14:16:06 1990
X--- src/u_init.c	Sun Feb 25 14:49:27 1990
X***************
X*** 545,556 ****
X  		 */
X  		if (undefined) {
X  #ifdef POLYSELF
X! 			static unsigned nocreate = STRANGE_OBJECT;
X  #  ifdef SPELLS
X! 			static unsigned nocreate2 = STRANGE_OBJECT;
X  #  endif
X  #endif
X! 			static unsigned nocreate3 = STRANGE_OBJECT;
X  
X  			while(obj->otyp == WAN_WISHING
X  #ifdef POLYSELF
X--- 545,556 ----
X  		 */
X  		if (undefined) {
X  #ifdef POLYSELF
X! 			static unsigned NEARDATA nocreate = STRANGE_OBJECT;
X  #  ifdef SPELLS
X! 			static unsigned NEARDATA nocreate2 = STRANGE_OBJECT;
X  #  endif
X  #endif
X! 			static unsigned NEARDATA nocreate3 = STRANGE_OBJECT;
X  
X  			while(obj->otyp == WAN_WISHING
X  #ifdef POLYSELF
X*** src/Old/uhitm.c	Sun Jun  3 14:16:32 1990
X--- src/uhitm.c	Mon May 28 15:48:55 1990
X***************
X*** 7,17 ****
X  #  include "artifact.h"
X  #endif
X  
X! static boolean hitum();
X  #ifdef POLYSELF
X! static boolean hmonas();
X  #endif
X! static void nohandglow();
X  
X  #ifdef WORM
X  extern boolean notonhead;
X--- 7,20 ----
X  #  include "artifact.h"
X  #endif
X  
X! static boolean FDECL(known_hitum, (struct monst *,int));
X! static boolean FDECL(hitum, (struct monst *,int));
X  #ifdef POLYSELF
X! static int FDECL(explum, (struct monst *,struct attack *));
X! static int FDECL(gulpum, (struct monst *,struct attack *));
X! static boolean FDECL(hmonas, (struct monst *,int));
X  #endif
X! static void FDECL(nohandglow, (struct monst *));
X  
X  #ifdef WORM
X  extern boolean notonhead;
X***************
X*** 26,32 ****
X  
X  	mm.x = mon->mx;
X  	mm.y = mon->my;
X! 	enexto(&mm, mm.x, mm.y, mon->data);
X  	if (MON_AT(mm.x, mm.y) || mon->mhp <= 1) return (struct monst *)0;
X  	m2 = newmonst(0);
X  	*m2 = *mon;			/* copy condition of old monster */
X--- 29,35 ----
X  
X  	mm.x = mon->mx;
X  	mm.y = mon->my;
X! 	if (!enexto(&mm, mm.x, mm.y, mon->data)) return (struct monst *)0;
X  	if (MON_AT(mm.x, mm.y) || mon->mhp <= 1) return (struct monst *)0;
X  	m2 = newmonst(0);
X  	*m2 = *mon;			/* copy condition of old monster */
X***************
X*** 64,70 ****
X  	m2->mdispl = 0;
X  	pmon(m2);	/* display the new monster */
X  	place_monster(m2, m2->mx, m2->my);
X! 	if (mon->mtame) (void) tamedog(m2, (struct obj *)0);
X  	return m2;
X  }
X  
X--- 67,78 ----
X  	m2->mdispl = 0;
X  	pmon(m2);	/* display the new monster */
X  	place_monster(m2, m2->mx, m2->my);
X! 	if (mon->mtame) {
X! 	    struct monst *m3;
X! 
X! 	    if (m3 = tamedog(m2, (struct obj *)0))
X! 		m2 = m3;
X! 	}
X  	return m2;
X  }
X  
X***************
X*** 81,87 ****
X  #ifdef MACOS
X  			char mac_tbuf[80];
X  			if(!flags.silent) SysBeep(1);
X! 			sprintf(mac_tbuf, "Really attack %s?", mon_nam(mtmp));
X  			if(UseMacAlertText(128, mac_tbuf) != 1) {
X  #else
X  			pline("Really attack %s? ", mon_nam(mtmp));
X--- 89,95 ----
X  #ifdef MACOS
X  			char mac_tbuf[80];
X  			if(!flags.silent) SysBeep(1);
X! 			Sprintf(mac_tbuf, "Really attack %s?", mon_nam(mtmp));
X  			if(UseMacAlertText(128, mac_tbuf) != 1) {
X  #else
X  			pline("Really attack %s? ", mon_nam(mtmp));
X***************
X*** 296,302 ****
X  struct monst *mon;
X  int tmp;
X  {
X! 	static int malive;
X  	boolean mhit = (tmp > rnd(20) || u.uswallow);
X  
X  	malive = known_hitum(mon, mhit);
X--- 304,310 ----
X  struct monst *mon;
X  int tmp;
X  {
X! 	static int NEARDATA malive;
X  	boolean mhit = (tmp > rnd(20) || u.uswallow);
X  
X  	malive = known_hitum(mon, mhit);
X***************
X*** 428,433 ****
X--- 436,442 ----
X  			useup(obj);
X  			hittxt = TRUE;
X  			tmp = 1;
X+ 			break;
X  #endif
X  		case EXPENSIVE_CAMERA:
X  	You("succeed in destroying your camera.  Congratulations!");
X***************
X*** 445,451 ****
X  			    kludge("%s turns to stone.", Monnam(mon));
X  			    stoned = TRUE;
X  			    xkilled(mon,0);
X! 			    nohandglow();
X  			    return(FALSE);
X  			}
X  			tmp = mons[obj->corpsenm].msize + 1;
X--- 454,460 ----
X  			    kludge("%s turns to stone.", Monnam(mon));
X  			    stoned = TRUE;
X  			    xkilled(mon,0);
X! 			    nohandglow(mon);
X  			    return(FALSE);
X  			}
X  			tmp = mons[obj->corpsenm].msize + 1;
X***************
X*** 576,582 ****
X  		   /* && !destroyed  -- guaranteed by mhp > 1 */ ) {
X  
X  		if (clone_mon(mon)) {
X! 			pline("%s divides as you hit it!", Monnam(mon));
X  			hittxt = TRUE;
X  		}
X  	}
X--- 585,591 ----
X  		   /* && !destroyed  -- guaranteed by mhp > 1 */ ) {
X  
X  		if (clone_mon(mon)) {
X! 			kludge("%s divides as you hit it!", Monnam(mon));
X  			hittxt = TRUE;
X  		}
X  	}
X***************
X*** 602,614 ****
X  	if (poiskilled) {
X  		pline("The poison was deadly...");
X  		xkilled(mon, 0);
X! 		nohandglow();
X  		return FALSE;
X  	} else if (destroyed) {
X  		killed(mon);	/* takes care of most messages */
X! 		nohandglow();
X  	} else if(u.umconf && !thrown) {
X! 		nohandglow();
X  		if(!resist(mon, '+', 0, NOTELL)) mon->mconf = 1;
X  		if(!mon->mstun && mon->mcanmove && !mon->msleep &&
X  		   !Blind && mon->mconf)
X--- 611,623 ----
X  	if (poiskilled) {
X  		pline("The poison was deadly...");
X  		xkilled(mon, 0);
X! 		nohandglow(mon);
X  		return FALSE;
X  	} else if (destroyed) {
X  		killed(mon);	/* takes care of most messages */
X! 		nohandglow(mon);
X  	} else if(u.umconf && !thrown) {
X! 		nohandglow(mon);
X  		if(!resist(mon, '+', 0, NOTELL)) mon->mconf = 1;
X  		if(!mon->mstun && mon->mcanmove && !mon->msleep &&
X  		   !Blind && mon->mconf)
X***************
X*** 675,715 ****
X  			if(thick_skinned(mdef->data)) tmp = 0;
X  		break;
X  	    case AD_FIRE:
X  # ifdef GOLEMS
X! 		golemeffects(mdef, AD_FIRE, tmp);
X  # endif /* GOLEMS */
X- 		if(resists_fire(pd)) {
X  		    shieldeff(mdef->mx, mdef->my);
X  		    tmp = 0;
X- 		} else {
X- 		    if(!Blind) pline("%s is on fire!", Monnam(mdef));
X- 		    tmp += destroy_mitem(mdef, SCROLL_SYM, AD_FIRE);
X- 		    tmp += destroy_mitem(mdef, POTION_SYM, AD_FIRE);
X- # ifdef SPELLS
X- 		    tmp += destroy_mitem(mdef, SPBOOK_SYM, AD_FIRE);
X- # endif
X  		}
X  		break;
X  	    case AD_COLD:
X! # ifdef GOLEMS
X! 		golemeffects(mdef, AD_COLD, tmp);
X! # endif /* GOLEMS */
X  		if(resists_cold(pd)) {
X  		    shieldeff(mdef->mx, mdef->my);
X  		    tmp = 0;
X- 		} else {
X- 		    if(!Blind) pline("%s is covered in frost.", Monnam(mdef));
X- 		    tmp += destroy_mitem(mdef, POTION_SYM, AD_COLD);
X  		}
X  		break;
X  	    case AD_ELEC:
X  # ifdef GOLEMS
X! 		golemeffects(mdef, AD_ELEC, tmp);
X  # endif /* GOLEMS */
X- 		if(resists_elec(pd)) {
X  		    shieldeff(mdef->mx, mdef->my);
X  		    tmp = 0;
X  		}
X  		break;
X  	    case AD_ACID:
X  		if(resists_acid(pd)) tmp = 0;
X--- 684,733 ----
X  			if(thick_skinned(mdef->data)) tmp = 0;
X  		break;
X  	    case AD_FIRE:
X+ 		if(!Blind) pline("%s is on fire!", Monnam(mdef));
X+ 		tmp += destroy_mitem(mdef, SCROLL_SYM, AD_FIRE);
X+ # ifdef SPELLS
X+ 		tmp += destroy_mitem(mdef, SPBOOK_SYM, AD_FIRE);
X+ # endif
X+ 		if(resists_fire(pd)) {
X+ 		    if (!Blind)
X+ 			pline("The fire doesn't heat %s!", mon_nam(mdef));
X  # ifdef GOLEMS
X! 		    golemeffects(mdef, AD_FIRE, tmp);
X  # endif /* GOLEMS */
X  		    shieldeff(mdef->mx, mdef->my);
X  		    tmp = 0;
X  		}
X+ 		/* only potions damage resistant players in destroy_item */
X+ 		tmp += destroy_mitem(mdef, POTION_SYM, AD_FIRE);
X  		break;
X  	    case AD_COLD:
X! 		if(!Blind) pline("%s is covered in frost!", Monnam(mdef));
X  		if(resists_cold(pd)) {
X  		    shieldeff(mdef->mx, mdef->my);
X+ 		    if (!Blind)
X+ 			pline("The frost doesn't chill %s!", mon_nam(mdef));
X+ # ifdef GOLEMS
X+ 		    golemeffects(mdef, AD_COLD, tmp);
X+ # endif /* GOLEMS */
X  		    tmp = 0;
X  		}
X+ 		tmp += destroy_mitem(mdef, POTION_SYM, AD_COLD);
X  		break;
X  	    case AD_ELEC:
X+ 		if (!Blind) pline("%s is zapped!", Monnam(mdef));
X+ 		tmp += destroy_mitem(mdef, WAND_SYM, AD_ELEC);
X+ 		if(resists_elec(pd)) {
X+ 		    if (!Blind)
X+ 			pline("The zap doesn't shock %s!", mon_nam(mdef));
X  # ifdef GOLEMS
X! 		    golemeffects(mdef, AD_ELEC, tmp);
X  # endif /* GOLEMS */
X  		    shieldeff(mdef->mx, mdef->my);
X  		    tmp = 0;
X  		}
X+ 		/* only rings damage resistant players in destroy_item */
X+ 		tmp += destroy_mitem(mdef, RING_SYM, AD_ELEC);
X  		break;
X  	    case AD_ACID:
X  		if(resists_acid(pd)) tmp = 0;
X***************
X*** 1464,1472 ****
X  }
X  
X  static void
X! nohandglow()
X  {
X! 	if (!u.umconf) return; /* for safety */
X  	if (u.umconf == 1) {
X  		if (Blind)
X  			Your("%s stop tingling.", makeplural(body_part(HAND)));
X--- 1482,1491 ----
X  }
X  
X  static void
X! nohandglow(mon)
X! struct monst *mon;
X  {
X! 	if (!u.umconf || mon->mconf) return;
X  	if (u.umconf == 1) {
X  		if (Blind)
X  			Your("%s stop tingling.", makeplural(body_part(HAND)));
X*** src/Old/unixmain.c	Sun Jun  3 14:17:29 1990
X--- src/unixmain.c	Thu May 24 21:47:14 1990
X***************
X*** 21,27 ****
X  char *catmore = 0;				/* default pager */
X  #endif
X  
X! extern struct passwd *getpwuid();
X  #ifdef CHDIR
X  static void chdirx();
X  #endif /* CHDIR */
X--- 21,27 ----
X  char *catmore = 0;				/* default pager */
X  #endif
X  
X! extern struct passwd *getpwnam(), *getpwuid();
X  #ifdef CHDIR
X  static void chdirx();
X  #endif /* CHDIR */
X***************
X*** 32,38 ****
X  int argc;
X  char *argv[];
X  {
X- 	struct passwd *pw;
X  	extern int x_maze_max, y_maze_max;
X  	register int fd;
X  #ifdef CHDIR
X--- 32,37 ----
X***************
X*** 72,78 ****
X  #endif
X  	if(argc > 1) {
X  #ifdef CHDIR
X! 	    if (!strncmp(argv[1], "-d", 2)) {
X  		argc--;
X  		argv++;
X  		dir = argv[0]+2;
X--- 71,80 ----
X  #endif
X  	if(argc > 1) {
X  #ifdef CHDIR
X! 	    if (!strncmp(argv[1], "-d", 2) && argv[1][2] != 'e') {
X! 		/* avoid matching "-dec" for DECgraphics; since the man page
X! 		 * says -d directory, hope nobody's using -desomething_else
X! 		 */
X  		argc--;
X  		argv++;
X  		dir = argv[0]+2;
X***************
X*** 110,115 ****
X--- 112,120 ----
X  	u.uhp = 1;	/* prevent RIP on early quits */
X  	u.ux = FAR;	/* prevent nscr() */
X  	(void) signal(SIGHUP, (SIG_RET_TYPE) hangup);
X+ #ifdef SIGXCPU
X+ 	(void) signal(SIGXCPU, (SIG_RET_TYPE) hangup);
X+ #endif
X  
X  	/*
X  	 * Find the creation date of this game,
X***************
X*** 137,146 ****
X  # endif
X  		case 'D':
X  # ifdef WIZARD
X! 			pw = getpwuid(getuid());
X! 			if(!strcmp(pw->pw_name, WIZARD)) {
X! 				wizard = TRUE;
X! 				break;
X  			}
X  			/* otherwise fall thru to discover */
X  # endif
X--- 142,172 ----
X  # endif
X  		case 'D':
X  # ifdef WIZARD
X! 			{
X! 			  char *user;
X! 			  int uid;
X! 			  struct passwd *pw = (struct passwd *)0;
X! 
X! 			  uid = getuid();
X! 			  user = getlogin();
X! 			  if (user) {
X! 			      pw = getpwnam(user);
X! 			      if (pw && (pw->pw_uid != uid)) pw = 0;
X! 			  }
X! 			  if (pw == 0) {
X! 			      user = getenv("USER");
X! 			      if (user) {
X! 				  pw = getpwnam(user);
X! 				  if (pw && (pw->pw_uid != uid)) pw = 0;
X! 			      }
X! 			      if (pw == 0) {
X! 				  pw = getpwuid(uid);
X! 			      }
X! 			  }
X! 			  if (pw && !strcmp(pw->pw_name,WIZARD)) {
X! 			      wizard = TRUE;
X! 			      break;
X! 			  }
X  			}
X  			/* otherwise fall thru to discover */
X  # endif
X***************
X*** 164,169 ****
X--- 190,201 ----
X  			  (void) strncpy(plname, argv[0], sizeof(plname)-1);
X  			} else
X  				Printf("Player name expected after -u\n");
X+ 			break;
X+ 		case 'i':
X+ 			if(!strcmp(argv[0]+1, "ibm")) assign_ibm_graphics();
X+ 			break;
X+ 		case 'd':
X+ 			if(!strcmp(argv[0]+1, "dec")) assign_dec_graphics();
X  			break;
X  		default:
X  			/* allow -T for Tourist, etc. */
X
END_OF_FILE
if test 52966 -ne `wc -c <'patch8.08'`; then
    echo shar: \"'patch8.08'\" unpacked with wrong size!
fi
# end of 'patch8.08'
fi
echo shar: End of archive 5 \(of 24\).
cp /dev/null ark5isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 24 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
