Path: utzoo!attcan!uunet!tut.cis.ohio-state.edu!ucsd!ogicse!zephyr.ens.tek.com!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v10i040:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Patch8v
Message-ID: <5748@tekred.CNA.TEK.COM>
Date: 5 Jun 90 18:03:45 GMT
Sender: news@tekred.CNA.TEK.COM
Lines: 2141
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 10, Issue 40
Archive-name: NetHack3/Patch8v
Patch-To: NetHack3: Volume 7, Issue 56-93



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 22 (of 24)."
# Contents:  mac/MacAlert.c others/Makefile.ovl vms/vmsbuild.com
# Wrapped by billr@saab on Mon Jun  4 15:40:33 1990
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo shar: Extracting \"'mac/MacAlert.c'\" \(24474 characters\)
sed "s/^X//" >'mac/MacAlert.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)MacAlert.c		3.0	90/01/06
X/*      Copyright (c) Jon Watte  1989		*/ 
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include "hack.h"	/* */
X
X/* UseMacAlert is like UseMacAlertText, but without the text parameter.
X   This is so you can simply say "UseMacAlert(CAUTION)" or similar, if
X   you use predefined alert numbers.
X*/
X
X
Xextern WindowPtr HackWindow;
X
X
Xint
XUseMacAlert(MAno)
Xint MAno;
X{
X	return UseMacAlertText(MAno, 0L);
X}
X
X
X/* UseMacAlertText fetches a record in a resource of type MAlt, and uses
X   this as a template calling MacAlert. This is so you can have ready-
X   made resources, like ALRT templates, for your MacAlerts, which makes
X   it easier to customize the program, and to translate it. It also
X   makes for clearer code...
X   
X   If the txt argument is NULL, the text from the template is used,
X   otherwise the sypplied text is used.
X*/
Xint
XUseMacAlertText(MAno, txt)
Xint MAno;
Xchar * txt;
X{
X	MAlrtHandle foo;
X	MAlrtPtr bar;
X	int item;
X
X	SetResLoad(1);
X	foo = (MAlrtHandle) GetResource(MAtype, MAno);
X	if(foo) {
X		MoveHHi(foo);
X		HLock(foo);
X		bar = *foo;
X		item = MacAlert(bar->width, bar->height, bar->PICTno,
X			txt != 0L ? txt : bar->text, bar->but1, bar->but2, bar->but3,
X			bar->but4, bar->def, bar->esc);
X	} else {
X		if(!flags.silent) SysBeep(20);
X		item = -1;
X	}
X
X	ReleaseResource(foo);
X	DisposHandle(foo);
X	return item;
X}
X
X
X/* This is the MacAlert function. It creates a new window, frames it
X   (like a modal dialog) and tries to position the various buttons,
X   text and picture in a reasonable way. The arguments are:
X   
X   width : width of the window. If less than a constant, it defaults
X           to that constant.
X   height: see width.
X   PICTno: Resource ID of a PICT to display. If 0, no PICT is displayed.
X   text  : the C string containing the relevant text to be displayed.
X   but1 -: These are the button texts. Empty strings (they point at 0)
X   - but4: makes that button go away. If all are empty, the default OK
X           button text is used.
X   def   : This is which button is default, starting button # 1.
X   esc   : This is the button that corresponds to the ESC key.
X
X   The function returns the button hit, or maybe -1 on error.
X*/
Xint
XMacAlert(width, height, PICTno, text, but1, but2, but3, but4, def, esc)
Xint width, height, PICTno;
Xchar * text,* but1, * but2, * but3, * but4;
Xint def, esc;
X{
X	PicHandle thePICT;
X	char border[8];
X	EventRecord theEvent;
X	GrafPtr savedPort;
X	WindowPtr theWindow, tmpWind;
X	Rect bounds, textBox, brect[4];
X	char hilite[4], * but[4], s1[2], s2[2];
X	int nobutts, x, pool, spacing, heig, bwid[4],
X		item, c, ret;
X	long finalTicks;
X
X	memset(hilite, sizeof(hilite), 0);
X	memset(bwid, sizeof(bwid), 0);
X	SetCursor(&arrow);
X	def--;
X	esc--;
X	GetPort(&savedPort);
X
X	if(PICTno)
X		thePICT = (PicHandle) GetResource('PICT', PICTno);
X	else
X		thePICT = 0;
X	if(thePICT) DetachResource(thePICT);
X	bounds = (MAINGRAFPORT)->portRect;
X
X	but[0] = but1;
X	but[1] = but2;
X	but[2] = but3;
X	but[3] = but4;
X
X	if(width > bounds.right) width = bounds.right;
X	if(width < MIN_WIDTH) width = MIN_WIDTH;
X	if(height > bounds.bottom) height = bounds.bottom;
X	if(height < MIN_HEIGHT) height = MIN_HEIGHT;
X
X	InsetRect(&bounds, (int) ((bounds.right - width) >> 1), (int)
X		((bounds.bottom - height) >> 1));
X	theWindow = NewWindow(0L, &bounds, "", 1, plainDBox, 0L, 0, 0L);
X	ShowWindow(theWindow);
X	SelectWindow(theWindow);
X	SetPort(theWindow);
X	OffsetRect(&bounds, - bounds.left, - bounds.top);
X
X	nobutts = 0;
X	if(but1[0]) nobutts=1;
X	if(but2[0]) nobutts=2;
X	if(but3[0]) nobutts=3;
X	if(but4[0]) nobutts=4;
X
X	if(!nobutts) {
X		but[0] = "OK";
X		nobutts++;
X	}
X
X	spacing = 0;
X	for(x=0 ; x < nobutts; x++) {
X		bwid[x] = TextWidth(but[x], 0, strlen(but[x])) + 2 * BUT_MARGIN;
X		spacing += bwid[x] + BUT_SPACING;
X	}
X
X	pool = bounds.right - 2 * BUT_MARGIN;
X
X	heig = 1;
X	while(spacing / heig > pool - (nobutts - 1) * BUT_SPACING) {
X		heig++;
X	}
X
X	for(x=0; x<nobutts; x++) {
X		bwid[x] = (int) ((float) bwid[x] / spacing * pool);
X	}
X
X	pool = BUT_MARGIN + BUT_SPACING;
X	heig = bounds.bottom - BUT_MARGIN - BUT_SPACING - BUT_HEIGHT * heig;
X	for(x=0; x<nobutts; x++) {
X		SetRect(&(brect[x]), pool, heig, pool + bwid[x], bounds.bottom -
X			BUT_SPACING - BUT_MARGIN);
X		pool += bwid[x] + BUT_SPACING;
X		hilite[x] = 0;
X	}
X
X	InsetRect(&bounds, 2, 2);
X	textBox = bounds;
X	if(thePICT) {
X		textBox.left += (*thePICT)->picFrame.right;
X	}
X	textBox.left += 8;
X	textBox.right -= 8;
X	textBox.top += 8;
X	textBox.bottom = heig - BUT_MARGIN;
X	if(textBox.bottom < textBox.top + 15) {
X		textBox.bottom = bounds.bottom - 8;
X	}
X
X	goto mainLoop;
X
XdrawWindow:
X	SetPort(theWindow);
X	EraseRect(&(theWindow->portRect));
X	PenNormal();
X	PenSize(BORDER_WIDTH, BORDER_WIDTH);
X	GetIndPattern((void *) border, 0, BORDER_PAT);
X	PenPat(border);
X	FrameRect(&bounds);
X
X	PenNormal();
X
X	if(thePICT) {
X		HLock(thePICT);
X		DrawPicture(thePICT, &((*thePICT)->picFrame));
X		HUnlock(thePICT);
X	}
X
X	PenNormal();
X	TextFont(0);
X	TextSize(12);
X	TextBox(text, strlen(text), &textBox, teJustLeft);
X
X	for(x=0; x<nobutts; x++) {
X		EraseRoundRect(&(brect[x]), BUT_CORNER, BUT_CORNER);
X		FrameRoundRect(&(brect[x]), BUT_CORNER, BUT_CORNER);
X		InsetRect(&(brect[x]), BUT_MARGIN, 3);
X		TextBox(but[x], strlen(but[x]), &(brect[x]), teJustCenter);
X		InsetRect(&(brect[x]), - BUT_MARGIN, - 3);
X		if(hilite[x]) {
X			InvertRoundRect(&(brect[x]), BUT_CORNER, BUT_CORNER);
X		}
X		if(x == def) {
X			PenSize(FRAME_WIDTH, FRAME_WIDTH);
X			InsetRect(&(brect[x]), - FRAME_WIDTH - FRAME_OFFSET,
X				- FRAME_WIDTH - FRAME_OFFSET);
X			FrameRoundRect(&(brect[x]), FRAME_CORNER, FRAME_CORNER);
X			InsetRect(&(brect[x]), FRAME_WIDTH + FRAME_OFFSET,
X				FRAME_WIDTH + FRAME_OFFSET);
X			PenNormal();
X		}
X	}
X
XmainLoop:
X	while(1) {
X		if(WaitNextEvent(-1, &theEvent, 10L, 0L)) {
X			switch(theEvent.what) {
X
X			case updateEvt :
X				BeginUpdate((WindowPtr) theEvent.message);
X				EndUpdate((WindowPtr) theEvent.message);
X				goto drawWindow;
X
X			case mouseDown :
X				if (FindWindow(theEvent.where, &tmpWind) < inContent ||
X					tmpWind != theWindow) {
X					if(!flags.silent) SysBeep(20);
X					item = -1;
X				} else {
X					item = TrackThem(brect, hilite, nobutts);
X				}
X				if(item >= 0) {
X					Delay(FLASH_TIME, &finalTicks);
X					InvertRoundRect(&(brect[item]), BUT_CORNER, BUT_CORNER);
X					ret = item + 1;
X					goto getout;
X				}
X				break;
X
X			case keyDown :
X				c = theEvent.message & 0xFF;
X				if((c == 13) || (c == 3)) {
X					if(def >= 0) {
X						InvertRoundRect(&(brect[def]), BUT_CORNER, BUT_CORNER);
X						Delay(FLASH_TIME, &finalTicks);
X						InvertRoundRect(&(brect[def]), BUT_CORNER, BUT_CORNER);
X						ret = def + 1;
X						goto getout;
X					}
X				}
X				if(c == 27) {
X					if(esc >= 0) {
X						InvertRoundRect(&(brect[esc]), BUT_CORNER, BUT_CORNER);
X						Delay(FLASH_TIME, &finalTicks);
X						InvertRoundRect(&(brect[esc]), BUT_CORNER, BUT_CORNER);
X						ret = esc + 1;
X						goto getout;
X					}
X				}
X				for(x=0; x<nobutts; x++) {
X					s1[0] = 1;
X					s1[1] = c;
X					s2[0] = 1;
X					s2[1] = but[x][0];
X					UprString(s1, 1);
X					UprString(s2, 1);
X					if(s1[1] == s2[1]) {
X						InvertRoundRect(&(brect[x]), BUT_CORNER, BUT_CORNER);
X						Delay(FLASH_TIME, &finalTicks);
X						InvertRoundRect(&(brect[x]), BUT_CORNER, BUT_CORNER);
X						ret = x + 1;
X						goto getout;
X					}
X				}
X
X				PenSize(FRAME_WIDTH, FRAME_WIDTH);
X				InsetRect(&(brect[def]), - FRAME_WIDTH - FRAME_OFFSET,
X					- FRAME_WIDTH - FRAME_OFFSET);
X				PenMode(patXor);
X				FrameRoundRect(&(brect[def]), FRAME_CORNER, FRAME_CORNER);
X				InsetRect(&(brect[def]), FRAME_WIDTH + FRAME_OFFSET,
X					FRAME_WIDTH + FRAME_OFFSET);
X				PenNormal();
X
X				def++;
X				def %= nobutts;
X
X				PenSize(FRAME_WIDTH, FRAME_WIDTH);
X				InsetRect(&(brect[def]), - FRAME_WIDTH - FRAME_OFFSET,
X					- FRAME_WIDTH - FRAME_OFFSET);
X				FrameRoundRect(&(brect[def]), FRAME_CORNER, FRAME_CORNER);
X				InsetRect(&(brect[def]), FRAME_WIDTH + FRAME_OFFSET,
X					FRAME_WIDTH + FRAME_OFFSET);
X				PenNormal();
X
X				break;
X
X			default:
X				;
X			}
X		}
X	}
X
Xgetout:
X	DisposeWindow(theWindow);
X	if(thePICT) DisposHandle(thePICT);
X	SetPort(savedPort);
X
X	return ret;
X}
X
X
X/* TrackThem is a help function to MacAlert, it tracks buttons,
X   returns the button number (0 - (no_butts-1)) or -1 if no button
X   was hit. */
Xint
XTrackThem(b_rect, hi_lite, no_butts)
XRect * b_rect;
Xchar * hi_lite;
Xint no_butts;
X{
XPoint p;
Xint x, i;
X
X	while(Button()) {
X		SystemTask();
X		GetMouse(&p);
X		for(x=0; x<no_butts; x++) {
X			if(PtInRect(p, &(b_rect[x]))) {
X				if(!hi_lite[x]) {
X					hi_lite[x] = 1;
X					InvertRoundRect(&(b_rect[x]), BUT_CORNER, BUT_CORNER);
X				}
X			} else {
X				if(hi_lite[x]) {
X					hi_lite[x] = 0;
X					InvertRoundRect(&(b_rect[x]), BUT_CORNER, BUT_CORNER);
X				}
X			}
X		}
X	}
X
X	i = -1;
X	for(x=0; x<no_butts; x++) {
X		if(hi_lite[x]) i=x;
X	}
X
X	return i;
X}
X
X
X/* #defines for the mini-pager */
X
X#define SLACK 400 /* How much extra is taken per chunk ? */
X#define TAB_SIZE 8 /* How large tabs ? */
X
X#define X_POS 8 /* Window init pos */
X#define Y_POS 64
X#define X_SIZE 80 /* Window size */
X#define Y_SIZE 24
X#define X_BORDER 20 /* Extra space besides text */
X#define Y_BORDER 4
X#define TOP_MARGIN 2 /* Offset of text from border */
X#define LEFT_MARGIN 2
X#define MAX_LINE_LEN 128
X
X#include <ControlMgr.h>
X
Xtypedef struct select {
X	long start;
X	long end;
X	long startline;
X	long endline;
X} SELECTION;
X
Xextern WindowPtr HackWindow;
X
Xstatic WindowPtr PagerWindow;
Xstatic width, height;
Xstatic Handle theData;
Xstatic long length, textPos;
Xstatic Rect text_area;
Xstatic Rect windowSize;
Xstatic int inited;
Xstatic ControlHandle theScrollBar;
Xstatic int scrollMax = 0, scrollPt = 0;
Xstatic long ** lineStarts;
Xstatic long noRs;
Xstatic MenuHandle editMenuH;
Xstatic SELECTION theSelect, oldSelect;
X
Xint DoMenu(long selection);
Xvoid DoScroll(long amount);
X
X
X/* The mini-pager */
X
X
Xlong
XLineLength(long from, long lines)
X{
Xlong ndx;
X	if(lines + from > noRs) ndx = noRs;
X	else ndx = lines + from;
X	return (*lineStarts)[ndx] - (*lineStarts)[from];
X}
X
X
Xlong
XWhatOffset(Point p, long * line)
X{
Xint x, y;
Xlong l, ndx;
X
X	x = (p.h - LEFT_MARGIN) / width;
X	if(x < 0) x = 0;
X	y = (p.v - TOP_MARGIN) / height;
X	if(y < 0) {
X		y = 0;
X		DoScroll(-1);
X	} else if(y >= Y_SIZE) {
X		y = Y_SIZE;
X		DoScroll(1);
X	}
X	l = y + scrollPt > noRs-1 ? noRs-1 : y + scrollPt;
X	ndx = x + (*lineStarts)[l];
X	if(l == noRs) ndx = length;
X	else if(ndx > (*lineStarts)[l+1]) ndx = (*lineStarts)[l+1];
X
X	* line = l;
X	return ndx;
X}
X
X
Xvoid
XInvertRange(SELECTION * s, Rect * cr)
X{
Xlong sc = s->start;
Xlong ec = s->end;
Xlong sl = s->startline;
Xlong el = s->endline;
Xint sx, ex;
XRect r;
X
X#define HilitePtr (void *) 0x938
X
X	if(sc > ec) {
X	long t = sc;
X		sc = ec;
X		ec = t;
X		t = sl;
X		sl = el;
X		el = t;
X	}
X
X	sx = sc - (*lineStarts)[sl];
X	ex = ec - (*lineStarts)[el];
X	sl -= scrollPt;
X	el -= scrollPt;
X	r = text_area;
X	ClipRect(cr ? cr : &r);
X	if(el == sl) {
X		SetRect(&r, sx * width, sl * height, ex * width, (el + 1) * height);
X		OffsetRect(&r, LEFT_MARGIN, TOP_MARGIN);
X		BitClr(HilitePtr, pHiliteBit);
X		InvertRect(&r);
X	} else {
X		SetRect(&r, sx * width, sl * height, X_SIZE * width, (sl + 1) * height);
X		OffsetRect(&r, LEFT_MARGIN, TOP_MARGIN);
X		BitClr(HilitePtr, pHiliteBit);
X		InvertRect(&r);
X		SetRect(&r, 0, el * height, ex * width, (el + 1) * height);
X		OffsetRect(&r, LEFT_MARGIN, TOP_MARGIN);
X		BitClr(HilitePtr, pHiliteBit);
X		InvertRect(&r);
X		SetRect(&r, 0, (sl + 1) * height, X_SIZE * width, el * height);
X		OffsetRect(&r, LEFT_MARGIN, TOP_MARGIN);
X		BitClr(HilitePtr, pHiliteBit);
X		InvertRect(&r);
X	}
X	SetRect(&r, 0, 0, 20000, 20000);
X	ClipRect(&r);
X}
X
X
Xvoid
XDoDraw(EventRecord * theEvent, term_info * t)
X{
X	BeginUpdate((WindowPtr) theEvent->message);
X	if(StripAddress(theEvent->message) == StripAddress(HackWindow)) {
X		SetPort(HackWindow);
X		docrt();
X	} else if(StripAddress(theEvent->message) == StripAddress(PagerWindow)) {
X		MoveHHi(theData);
X		HLock(theData);
X		MoveHHi(lineStarts);
X		DrawControls(PagerWindow);
X		TextBox(&((*theData)[(*lineStarts)[textPos]]), LineLength(textPos,
X			Y_SIZE), &text_area, teJustLeft);
X		HUnlock(theData);
X		InvertRange(&theSelect, 0L);
X	}
X	EndUpdate((WindowPtr) theEvent->message);
X}
X
X
Xvoid
XDoScroll(long amount)
X{
Xint ab = amount > 0 ? amount : - amount;
X
X	if(textPos == 0 && amount < 0) return;
X	if(textPos == scrollMax && amount > 0) return;
X
X	textPos += amount;
X	if(textPos < 0) {
X		amount -= textPos;
X		textPos = 0;
X	}
X	if(textPos > scrollMax) {
X		amount -= textPos - scrollMax;
X		textPos = scrollMax;
X	}
X	scrollPt = textPos;
X
X	if(ab > Y_SIZE - 1) {
X		HLock(theData);
X		TextBox(&((*theData)[(*lineStarts)[textPos]]), LineLength(textPos,
X			ab), &text_area, teJustLeft);
X		HUnlock(theData);
X		InvertRange(&theSelect, (Rect *) 0L);
X	} else {
X	Rect r;
X	RgnHandle rgn = NewRgn();
X		r = text_area;
X		ScrollRect(&text_area, 0, - amount * height, rgn);
X		DisposHandle(rgn);
X		if(amount < 0) {
X			r.bottom -= (Y_SIZE - ab) * height;
X			HLock(theData);
X			TextBox(&((*theData)[(*lineStarts)[textPos]]), LineLength
X				(textPos, ab), &r, teJustLeft);
X			HUnlock(theData);
X			InvertRange(&theSelect, &r);
X		} else {
X			r.top += (Y_SIZE - ab) * height;
X			HLock(theData);
X			TextBox(&((*theData)[(*lineStarts)[textPos + Y_SIZE - ab]]),
X				LineLength(textPos + Y_SIZE - ab, ab), &r,
X				teJustLeft);
X			HUnlock(theData);
X			InvertRange(&theSelect, &r);
X		}
X	}
X	SetCtlValue(theScrollBar, scrollPt);
X	DrawControls(PagerWindow);
X}
X
X
Xpascal void
XLineUp(ControlHandle stl, int part)
X{
X	DoScroll(-1);
X}
X
Xpascal void
XLineDown(ControlHandle stl, int part)
X{
X	DoScroll(1);
X}
X
Xpascal void
XPageUp(ControlHandle stl, int part)
X{
X	DoScroll(- Y_SIZE + 1);
X}
X
Xpascal void
XPageDown(ControlHandle stl, int part)
X{
X	DoScroll(Y_SIZE - 1);
X}
X
X
Xint
XDoKey(EventRecord * theEvent, term_info * t)
X{
Xchar c = theEvent->message & 0xFF;
Xchar k = (theEvent->message & 0xFF00) >> 8;
X
X	switch(k) {
X
X	case 0x7A:
X		DoMenu((long)(editMenu << 16) | 1);
X		return 1;
X
X	case 0x78:
X		DoMenu((long)(editMenu << 16) | 3);
X		return 1;
X
X	case 0x63:
X		DoMenu((long)(editMenu << 16) | 4);
X		return 1;
X
X	case 0x76:
X		DoMenu((long)(editMenu << 16) | 5);
X		return 1;
X
X	case 0x7E:
X	case 0x7B:
X		if(theEvent->modifiers & (optionKey | shiftKey | cmdKey))
X			DoScroll(- Y_SIZE + 1);
X		else DoScroll(-1);
X		return 1;
X
X	case 0x7C:
X	case 0x7D:
X		if(theEvent->modifiers & (optionKey | shiftKey | cmdKey))
X			DoScroll(Y_SIZE - 1);
X		else DoScroll(1);
X		return 1;
X
X	case 0x73:
X		DoScroll(-scrollMax);
X		return 1;
X
X	case 0x77:
X		DoScroll(scrollMax);
X		return 1;
X
X	case 0x74:
X		DoScroll(1 - Y_SIZE);
X		return 1;
X		
X	case 0x79:
X		DoScroll(Y_SIZE - 1);
X		return 1;
X		
X	case 0x7F:
X		return 0;
X
X	default:
X		break;
X	}
X
X	switch(c) {
X
X	case 'c':
X	case 'C':
X		if(theEvent->modifiers & cmdKey) {
X			HiliteMenu(editMenu);
X			DoMenu((long)(editMenu << 16) | 4);
X			HiliteMenu(0);
X		}
X		return 1;
X
X	case '.':
X		if(!(theEvent->modifiers & cmdKey)) break;
X	case 'q':
X	case 'Q':
X	case 0x1B:
X		return 0;
X
X	case ' ':
X	case 0x9:
X		if(theEvent->modifiers & (optionKey | shiftKey | cmdKey))
X			DoScroll(- Y_SIZE + 1);
X		else DoScroll(Y_SIZE - 1);
X		break;
X
X	case 0x3:
X	case '\r':
X	case '\n':
X		if(theEvent->modifiers & (optionKey | shiftKey | cmdKey))
X			DoScroll(-1);
X		else DoScroll(1);
X		break;
X
X	case '<':
X		DoScroll(- scrollMax);
X		break;
X
X	case '>':
X		DoScroll(scrollMax);
X		break;
X
X	default:
X		break;
X	}
X
X	return 1;
X}
X
X
Xvoid
XDoClick(EventRecord * theEvent, term_info * t)
X{
XControlHandle control;
XPoint pt = theEvent->where;
Xint part;
X
X	GlobalToLocal(&pt);
X	part = FindControl(pt, PagerWindow, &control);
X	if(part) {
X		switch(part) {
X
X		case inThumb:
X			if(TrackControl(control, pt, 0L) == inThumb) {
X				scrollPt = GetCtlValue(control);
X				DoScroll(scrollPt - textPos);
X			}
X			break;
X
X		case inUpButton:
X			TrackControl(control, pt, LineUp);
X			break;
X
X		case inDownButton:
X			TrackControl(control, pt, LineDown);
X			break;
X
X		case inPageUp:
X			TrackControl(control, pt, PageUp);
X			break;
X
X		case inPageDown:
X			TrackControl(control, pt, PageDown);
X			break;
X
X		default:
X			break;
X		}
X	} else {
X		if(theEvent->modifiers & shiftKey) {
X			theSelect.end = WhatOffset(pt, &(theSelect.endline));
X			oldSelect.start = theSelect.end;
X			oldSelect.startline = theSelect.endline;
X			InvertRange(&oldSelect, (Rect *) 0L);
X			oldSelect = theSelect;
X		} else {
X			InvertRange(&theSelect, (Rect *) 0L);
X			theSelect.start = WhatOffset(pt, &(theSelect.startline));
X			theSelect.end = theSelect.start;
X			theSelect.endline = theSelect.startline;
X			InvertRange(&theSelect, (Rect *) 0L);
X			oldSelect = theSelect;
X		}
X		while(StillDown()) {
X			GetMouse(&pt);
X			theSelect.end = WhatOffset(pt, &(theSelect.endline));
X			oldSelect.start = theSelect.end;
X			oldSelect.startline = theSelect.endline;
X			InvertRange(&oldSelect, (Rect *) 0L);
X			oldSelect = theSelect;
X		}
X		if(theSelect.start > theSelect.end) {
X		long t = theSelect.start;
X			theSelect.start = theSelect.end;
X			theSelect.end = t;
X			t = theSelect.startline;
X			theSelect.startline = theSelect.endline;
X			theSelect.endline = t;
X			oldSelect = theSelect;
X		}
X	}
X}
X
X
Xint
XDoMenu(long selection)
X{
Xint menu = HiWord(selection);
Xint item = LoWord(selection);
X
X	switch(menu) {
X
X	case fileMenu:
X		if(item == 9) return 0;
X		if(item == 4) {
X		Rect foom = PagerWindow->portRect;
X			OffsetRect(&foom, -foom.left, -foom.top);
X			InvalRect(&foom);
X			return 1;
X		}
X		break;
X
X	case editMenu:
X		switch(item) {
X
X		case 1:
X			SysBeep(20);
X			break;
X
X		case 3:
X			SysBeep(20);
X			break;
X
X		case 4:
X			if(theSelect.start == theSelect.end) {
X				SysBeep(20);
X			} else {
X				ZeroScrap();
X				HLock(theData);
X				PutScrap(theSelect.end - theSelect.start, 'TEXT', &((*theData)
X					[theSelect.start]));
X				HUnlock(theData);
X			}
X			break;
X
X		case 5:
X			SysBeep(20);
X			break;
X
X		default:
X			break;
X
X		}
X		break;
X
X	default:
X		break;
X
X	}
X
X	return 1;
X}
X
X
Xint
XDoMDown(EventRecord * theEvent, term_info * t)
X{
XWindowPtr whatWindow;
Xint where;
X
X	where = FindWindow(theEvent->where, &whatWindow);
X	switch(where) {
X
X	case inMenuBar:
X		if(theSelect.start != theSelect.end) {
X			EnableItem(editMenuH, 4);
X		} else {
X			DisableItem(editMenuH, 4);
X		}
X		where = DoMenu(MenuSelect(theEvent->where));
X		HiliteMenu(0);
X		return where;
X
X	case inGrow:
X	case inContent:
X		if(StripAddress(whatWindow) == StripAddress(PagerWindow)) {
X			DoClick(theEvent, t);
X		} else {
X			SysBeep(20);
X		}
X		break;
X
X	case inDrag:
X		if(StripAddress(whatWindow) == StripAddress(PagerWindow)) {
X		RgnHandle theRgn = GetGrayRgn();
X		Point p;
X			DragWindow(PagerWindow, theEvent->where, &((*theRgn)->rgnBBox));
X			windowSize = PagerWindow->portRect;
X			p.h = windowSize.left;
X			p.v = windowSize.top;
X			LocalToGlobal(&p);
X			OffsetRect(&windowSize, p.h, p.v);
X		} else {
X			SysBeep(20);
X		}
X		break;
X
X	case inGoAway:
X		if(TrackGoAway(PagerWindow, theEvent->where)) return 0;
X		break;
X
X	default:
X		break;
X
X	}
X	return 1;
X}
X
X
Xint
XCheckEvent(EventRecord * theEvent, term_info * t)
X{
X	switch(theEvent->what) {
X
X	case autoKey:
X	case keyDown:
X		return DoKey(theEvent, t);
X		break;
X
X	case updateEvt:
X		DoDraw(theEvent, t);
X		break;
X
X	case mouseDown:
X		return DoMDown(theEvent, t);
X		break;
X
X	case activateEvt:
X		if(theEvent->modifiers & 1) {
X			ShowControl(theScrollBar);
X		} else {
X			HideControl(theScrollBar);
X		}
X		break;
X
X	case app4Evt:
X		if(theEvent->message >> 24 == 1) {
X			if(theEvent->message & 1) {
X				HiliteControl(theScrollBar, scrollMax ? 0 : 254);
X			} else {
X				HiliteControl(theScrollBar, 255);
X			}
X		}
X
X	default:
X		break;
X	}
X
X	return 1;
X}
X
X
Xvoid
XMagicDisplay(term_info * t)
X{
XEventRecord theEvent;
X
X	SetCursor(&ARROW_CURSOR);
X	do {
X		WaitNextEvent(everyEvent, &theEvent, 42L, 0L);
X		SetPort(PagerWindow);
X	} while(CheckEvent(&theEvent, t));
X}
X
X
Xint
XCountChars(char * s, long n, int c)
X{
Xint r = 0;
X
X	while(n-- > 0) if(*(s++) == c) r++;
X
X	return r;
X}
X
X
Xint
XTabSize(char * s)
X{
Xint r = 0, q;
X
X	for(q = 0; s[q]; q++)
X		r += (s[q] == '\t') ? 8 - (r & 7) : 1;
X
X	return r;
X}
X
X
Xint
XExpandTabs(char * s, char * d)
X{
Xint r, q, c = 0, t = 0;
X
X	for(q = 0; s[q]; q++)
X		switch(s[q]) {
X
X		case '\t':
X			for(r = 0; r < 8 - (t & 7); r++, c++)
X				*(d++) = 0x20;
X			t += 8 - (t & 7);
X			break;
X
X		case '\n':
X			*(d++) = '\r';
X			c++;
X			t = 0;
X			break;
X
X		default:
X			*(d++) = s[q];
X			c++;
X			t++;
X			break;
X		}
X
X	return c;
X}
X
X
Xint
XMoofFile(FILE * fp, int strip)
X{
Xlong			fpos;
Xlong			delta_slack;
Xlong			slack_left;
Xchar			buf[MAX_LINE_LEN];
X
X	if(!fp) {
X		panic("No file for pager");
X	}
X	fpos = ftell(fp);
X	length = 0;
X	theData = NewHandle(SLACK);
X	slack_left = SLACK;
X
X	do {
X		if(!fgets(buf, MAX_LINE_LEN, fp)) break;
X		if(!strip || isspace(*buf)) {
X			delta_slack = TabSize(buf);
X			slack_left -= delta_slack;
X			if(slack_left < 0) {
X				slack_left += SLACK;
X				SetHandleSize(theData, length + SLACK + delta_slack);
X				if(MemError())
X					panic("Out of memory");
X			}
X			MoveHHi(theData);
X			HLock(theData);
X			length += ExpandTabs(buf+strip, &((*theData)[length]));
X			HUnlock(theData);
X		}
X	} while(!feof(fp) && (isspace(*buf) || !strip));
X
X	fclose(fp);
X	return 0;
X}
X
X
Xvoid
XsetLineStarts(long ** starts, char * data, long length)
X{
Xlong x = length;
Xlong p = 0;
X
X	**starts = 0;
X	while(length--)
X		if(*(data++) == '\r')
X			(*starts)[++p] = x - length;
X}
X
X
Xvoid
XMoreDisabling(MenuHandle theMenu, int i)
X{
Xint x;
X
X	switch(i) {
X
X	default :
X		DisableItem(theMenu, 0);
X		break;
X
X	case fileMenu:
X		for(x = 1; x < 9; x++)
X			DisableItem(theMenu, x);
X		SetItem(theMenu, 9, "\PClose");
X		EnableItem(theMenu, 9);
X		EnableItem(theMenu, 0);
X		EnableItem(theMenu, 4);
X		break;
X
X	case editMenu:
X		for(x = 1; x < 7; x++)
X			DisableItem(theMenu, x);
X		EnableItem(theMenu, 0);
X		editMenuH = theMenu;
X		break;
X
X	}
X}
X
X
Xvoid
XMoreEnabling(MenuHandle theMenu, int i)
X{
Xint x;
X
X	switch(i) {
X
X	default :
X		EnableItem(theMenu, 0);
X		break;
X
X	case fileMenu:
X		for(x = 0; x < 9; x++) if(x != 6 && x != 8)
X			EnableItem(theMenu, x);
X		SetItem(theMenu, 9, "\PQuit");
X		break;
X
X	case editMenu:
X		for(x = 1; x < 7; x++)
X			EnableItem(theMenu, x);
X		DisableItem(theMenu, 0);
X		break;
X
X	}
X}
X
X
Xvoid
XMoreMenus(void)
X{
XMenuHandle theMenu;
Xint i;
X
X	for(i=appleMenu; i <=extendMenu; i++) {
X		if(theMenu = GetMHandle(i)) {
X			MoreDisabling(theMenu, i);
X		}
X	}
X	DrawMenuBar();
X}
X
X
Xvoid
XLessMenus(void)
X{
XMenuHandle theMenu;
Xint i;
X
X	for(i=appleMenu; i <=extendMenu; i++) {
X		if(theMenu = GetMHandle(i)) {
X			MoreEnabling(theMenu, i);
X		}
X	}	
X	DrawMenuBar();
X}
X
X
Xint
Xmac_more(FILE * fp, int strip)
X{
XWindowRecord	MoreWindow;
Xterm_info		* t;
XGrafPtr			savedPort;
X
X	if(MoofFile(fp, strip)) return -1; /* God knows what happened */
X
X	theSelect.start = theSelect.end = theSelect.startline =
X		theSelect.endline = 0;
X	oldSelect = theSelect;
X	MoveHHi(theData);
X	HLock(theData);
X	noRs = CountChars(*theData, length, '\r');
X	lineStarts = (long **) NewHandle((noRs + 1) * sizeof(long));
X	if(!lineStarts || MemError()) panic("Out of memory");
X	setLineStarts(lineStarts, *theData, length);
X	HUnlock(theData);
X	scrollMax = noRs - Y_SIZE;
X	if(scrollMax < 0) scrollMax = 0;
X
X	GetPort(&savedPort);
X	t = (term_info *) GetWRefCon(HackWindow);
X
X	if(t->inColor ? !GetNewCWindow(301, &MoreWindow, 0L) :
X		!GetNewWindow(301, &MoreWindow, 0)) {
X		DisposHandle(theData);
X		panic("No WIND resource for pager");
X	} else if(ResError()) {
X		DisposHandle(theData);
X		panic("No WIND resource for pager");
X	} /* And now set the sizes & things */
X	PagerWindow = (GrafPtr) &MoreWindow;
X
X	width = t->charWidth;
X	height = t->height;
X	if(inited != t->height) {
X		SetRect(&windowSize, X_POS, Y_POS, width * X_SIZE + X_BORDER + X_POS,
X			height * Y_SIZE + Y_BORDER + Y_POS);
X		inited = t->height;
X	}	
X	SizeWindow(PagerWindow, windowSize.right - windowSize.left,
X		windowSize.bottom - windowSize.top, 0);
X	MoveWindow(PagerWindow, windowSize.left, windowSize.top, 0);
X	ShowWindow(PagerWindow);
X	SelectWindow(PagerWindow);
X	SetPort(PagerWindow);
X
X	text_area = windowSize;
X	OffsetRect(&text_area, - text_area.left, - text_area.top);
X	text_area.left = text_area.right - 14;
X	InsetRect(&text_area, - 1, - 1);
X	theScrollBar = NewControl(PagerWindow, &text_area,
X		"\PMore Text", 1, 0, 0, scrollMax, scrollBarProc, 0);
X	HiliteControl(theScrollBar, scrollMax ? 0 : 254);
X
X	SetRect(&text_area, LEFT_MARGIN, TOP_MARGIN, width * X_SIZE + LEFT_MARGIN,
X		height * Y_SIZE + TOP_MARGIN);
X	TextFont(t->fontNum);
X	TextSize(t->fontSize);
X	TextMode(srcCopy);
X	textPos = 0;
X
X	MoreMenus();
X	MagicDisplay(t);
X	LessMenus();
X
X	if(theScrollBar) KillControls((WindowPtr) &MoreWindow);
X	CloseWindow((WindowPtr) &MoreWindow);
X	DisposHandle(theData);
X	SetPort(HackWindow);
X	docrt();
X	SetPort(savedPort);
X	return 0;
X}
END_OF_FILE
if test 24474 -ne `wc -c <'mac/MacAlert.c'`; then
    echo shar: \"'mac/MacAlert.c'\" unpacked with wrong size!
fi
# end of 'mac/MacAlert.c'
echo shar: Extracting \"'others/Makefile.ovl'\" \(24531 characters\)
sed "s/^X//" >'others/Makefile.ovl' <<'END_OF_FILE'
X#	SCCS Id: @(#)Makefile.ovl	3.0	90/06/03
X#	PC NetHack 3.0 Makefile for Microsoft(tm) "C" 5.1 -- Pierre Martineau
X#	Overlay Arrangement -- Stephen Spackman, Pierre Martineau, Norm Meluch
X#	Multiple Compilation Hack and so forth -- Stephen Spackman
X#	Additional editing -- Kevin Smolkowski
X#
X#	Other things that have to be reconfigured are in config.h, pcconf.h,
X#	and possibly system.h.
X#
X#	Nota Bene: OVERLAY *must* be defined in pcconf.h to use this makefile!
X#	Also: Rename this file to "makefile", some targets rely on it.
X# -----------------------------------------------------------------------------
X#	In addition to your C compiler,
X#
X#	if you want to change		you will need a
X#	files with suffix		workalike for
X#	       .y			    yacc
X#	       .l			    lex
X#	       .asm			    masm
X# -----------------------------------------------------------------------------
X#	As it is set up, this makefile requires that exesmurf (the
X#	NetHack overlay-aware .exe header editor) be on your path or in the
X#	$(SRC) directory. If you wish to change the path or use Microsoft
X#	EXEMOD instead, see the symbols EXEPATCH and EXEFLAGS.
X#
X# *****************************************************************************
X# ************************ Compiler Info **************************************
X# *****************************************************************************
XCC	 = cl /c
XLINK	 = link
XMODEL	 = L
XASM	 = masm
XEXEPATCH = exesmurf
X# $(MAKE) macro is often predefined, so we use $(MAKEBIN) instead.
XMAKEBIN = make
X# For those of us who have these on PC.
X# YACC	 = yacc
X# LEX	 = lex
XYACC	= bison -y
XLEX	= flex
X# Standard file names may vary in PC installations.
XYTABC	= y_tab.c
XYTABH	= y_tab.h
XLEXYYC	= lexyy.c
X# Register bug, remove stack probes...
X# /Gt22 is currently about the largest value that keeps the initialised data
X# segment below 64K (and keeps the linker happy).
X# 286 or higher machines can use the /G2 CFLAG option for better performance.
XCFLAGS	= /A$(MODEL) /Oa /Gs /Gt22 /Zp1 /W0 /I$(INCL)
XCOSPACE = /Os
XCOSPEED = /Os  # MSC 5.1 seems to be broken, or maybe it's the NetHack code.
X#              # Either way, setting COSPEED to /Ot wreaked jolly flaming havoc.
X#
XLFLAGS	= /noi /seg:512 /map /st:4096
X#
X# Available assembler flags:
X#	/Di386	= Use 386 specific enhancements
X#	/DNOEMS = Do not use EMS memory
X#	/DDEBUG = Report memory usage on startup
XAFLAGS	= /MX
X#
X###############################################################################
X# Use the first line if you are using EXESMURF or the second for EXEMOD.
XEXEFLAGS = /max3000 /min3000
X# EXEFLAGS = /max BB8 /min BB8
X###############################################################################
X#
X# *****************************************************************************
X# ********* Directories (makedefs hardcodes these, don't change them) *********
X# *****************************************************************************
X#
XINCL	= ..\include
XAUX	= ..\auxil
XSRC	= ..\src
XOTHERS	= ..\others
XOBJ	= $(SRC)\o
X#
X# *****************************************************************************
X# ************************ Local Variables ************************************
X# *****************************************************************************
X#
X# The game name
XGAME	 = NetHack
X#
X# The default make target (so just typing 'make' is useful)
XDEFAULT  : $(GAME)
X#
X# The game directory
X# make sure GAMEDIR exists!
XGAMEDIR  = ..
X#
X# The game filename
XGAMEFILE = $(GAMEDIR)\$(GAME).exe
X#
X# Target environment prefix
XTARG	 = pc
X#
X# Overlay manager object file.
XOVLMGR	 = ovlmgr.obj
X#
X# Termcap routines.
XTERMCAPS = $(SRC)\termlib.lib
X#
X###############################################################################
X# Switch the following lines if you have a MASM compatible assembler.
X# $(OBJ)\$(OVLMGR):
X$(OBJ)\$(OVLMGR): ; copy $(OTHERS)\$(OVLMGR) $(OBJ)\$(OVLMGR)
X###############################################################################
X# If you have yacc and lex programs and make any changes, comment out the
X# upper two targets and uncomment the lower two.
Xdo_yacc: yacc_msg
Xdo_lex:  lex_msg
X# do_yacc: yacc_act
X# do_lex:  lex_act
X###############################################################################
X# Optional high-quality BSD random number generation routines (see pcconf.h).
X# Set to nothing if not used.
XRANDOM	 = $(OBJ)\random.o
X# RANDOM =
X###############################################################################
X# Optional C library specifier for those with non-standard libraries or
X# a multiple-target library setup.
X# CLIB	   = llibcer /nod
XCLIB	 =
X###############################################################################
X# If TERMLIB is NOT #defined in the source, comment out the lower line and
X# uncomment the upper. Don't forget to copy the $(TERMCAPS) file to the
X# $(SRC) directory if you have uncommented the lower line.
X# TERMLIB  =
XTERMLIB  = $(TERMCAPS)
X###############################################################################
X#
X# nothing below this line should have to be changed
X
XROOT =  $(OBJ)\$(OVLMGR) $(OBJ)\trampoli.o $(OBJ)\main.o $(OBJ)\msdos.o \
X	$(OBJ)\alloc.o $(OBJ)\random.o $(OBJ)\decl.o $(OBJ)\monst.o \
X	$(OBJ)\objects.o $(OBJ)\invent.0 $(OBJ)\mkobj.0 $(OBJ)\mkroom.0 \
X	$(OBJ)\rnd.0 $(OBJ)\termcap.0
X# main monster code
XOVL01 = $(OBJ)\cmd.0 $(OBJ)\dbridge.0 $(OBJ)\dog.0 $(OBJ)\engrave.0-1 \
X	$(OBJ)\hack.0 $(OBJ)\mon.0-1 $(OBJ)\mondata.0-1 $(OBJ)\monmove.0-1 \
X	$(OBJ)\mthrowu.0 $(OBJ)\priest.0 $(OBJ)\shk.0 $(OBJ)\track.0 \
X	$(OBJ)\trap.0-1 $(OBJ)\were.0
X# pet code
XOVL02 = $(OBJ)\apply.0 $(OBJ)\dog.1 $(OBJ)\dogmove.o
X# advanced monsters
XOVL03 = $(OBJ)\demon.o $(OBJ)\mcastu.o
XOVL04 = $(OBJ)\priest.1-b
XOVL05 = $(OBJ)\shk.1-b
XOVL06 = $(OBJ)\were.1-b
XOVL07 = $(OBJ)\wizard.1-b
XOVL08 = $(OBJ)\worm.o
X# main people things: you take your turn
XOVL09 = $(OBJ)\allmain.0 $(OBJ)\artifact.0 $(OBJ)\attrib.1 $(OBJ)\cmd.1 \
X	$(OBJ)\do.1 $(OBJ)\do.3 $(OBJ)\eat.0 $(OBJ)\engrave.2 \
X	$(OBJ)\getline.0-1 $(OBJ)\hack.1 $(OBJ)\lock.0 $(OBJ)\mail.0 \
X	$(OBJ)\pickup.1 $(OBJ)\pri.1 $(OBJ)\prisym.1 $(OBJ)\sounds.0 \
X	$(OBJ)\timeout.0 $(OBJ)\track.1 $(OBJ)\vault.0 $(OBJ)\wizard.0
XOVL10 = $(OBJ)\attrib.0
XOVL11 = $(OBJ)\attrib.2-b $(OBJ)\exper.o
XOVL12 = $(OBJ)\artifact.2 $(OBJ)\eat.1 $(OBJ)\invent.1
XOVL13 = $(OBJ)\makemon.0-2 $(OBJ)\mkobj.1
XOVL14 = $(OBJ)\makemon.b
XOVL15 = $(OBJ)\mkobj.2-b
XOVL16 = $(OBJ)\hack.2
XOVL17 = $(OBJ)\mhitm.1-b
XOVL18 = $(OBJ)\mthrowu.1
XOVL19 = $(OBJ)\mthrowu.2-b
XOVL20 = $(OBJ)\allmain.1 $(OBJ)\mhitm.0 $(OBJ)\mhitu.0-1 $(OBJ)\rnd.1 \
X	$(OBJ)\weapon.0-1
XOVL21 = $(OBJ)\mon.2-b $(OBJ)\trap.2
XOVL22 = $(OBJ)\artifact.1 $(OBJ)\search.0 $(OBJ)\uhitm.o $(OBJ)\weapon.2-b
XOVL23 = $(OBJ)\do_wear.0-1 $(OBJ)\mhitu.2-b
XOVL24 = $(OBJ)\steal.0-1
XOVL25 = $(OBJ)\monmove.2-b $(OBJ)\steal.2-b
XOVL26 = $(OBJ)\rnd.2-b
XOVL27 = $(OBJ)\do_wear.2 $(OBJ)\getline.b $(OBJ)\mondata.2 $(OBJ)\objnam.0-1 \
X	$(OBJ)\pager.0 $(OBJ)\polyself.0-1
XOVL28 = $(OBJ)\do_name.0
XOVL29 = $(OBJ)\objnam.2-b
XOVL30 = $(OBJ)\pager.1-b
XOVL31 = $(OBJ)\pri.0 $(OBJ)\prisym.0 $(OBJ)\topl.0
XOVL32 = $(OBJ)\pri.b $(OBJ)\topl.1-2
XOVL33 = $(OBJ)\prisym.2
XOVL34 = $(OBJ)\prisym.b
XOVL35 = $(OBJ)\topl.b
XOVL36 = $(OBJ)\termcap.1 $(OBJ)\unix.0
XOVL37 = $(OBJ)\termcap.2-b
XOVL38 = $(OBJ)\dog.b $(OBJ)\sounds.1-b
XOVL39 = $(OBJ)\read.0
XOVL40 = $(OBJ)\invent.b
XOVL41 = $(OBJ)\hack.b
XOVL42 = $(OBJ)\mondata.b $(OBJ)\timeout.1-b
XOVL43 = $(OBJ)\do.0 $(OBJ)\invent.3
XOVL44 = $(OBJ)\cmd.2-b $(OBJ)\getline.2 $(OBJ)\write.o
XOVL45 = $(OBJ)\apply.2-b
XOVL46 = $(OBJ)\do.b
XOVL47 = $(OBJ)\dokick.o
XOVL48 = $(OBJ)\dothrow.o
XOVL49 = $(OBJ)\eat.2-b
XOVL50 = $(OBJ)\invent.2 $(OBJ)\pickup.0 $(OBJ)\pickup.2-b
XOVL51 = $(OBJ)\lock.1-b
XOVL52 = $(OBJ)\polyself.2-b
XOVL53 = $(OBJ)\potion.o
XOVL54 = $(OBJ)\pray.o
XOVL55 = $(OBJ)\read.1-b $(OBJ)\spell.o
XOVL56 = $(OBJ)\search.1-b
X# clothing stuff
XOVL57 = $(OBJ)\do_wear.b $(OBJ)\wield.o $(OBJ)\worn.o
X# Zappage
XOVL58 = $(OBJ)\pri.2 $(OBJ)\zap.o
XOVL59 = $(OBJ)\dbridge.1-b
XOVL60 = $(OBJ)\trap.b
X# Unusual circumstances
XOVL61 = $(OBJ)\artifact.b $(OBJ)\do_name.1-b $(OBJ)\fountain.o $(OBJ)\music.o \
X	$(OBJ)\rumors.o $(OBJ)\shknam.0 $(OBJ)\sit.o $(OBJ)\vault.1-b
X# Uppers and Downers
X# Note: version.o is in OVL62, but in a special way.  See below.
XOVL62 = $(OBJ)\allmain.2-b $(OBJ)\end.o $(OBJ)\engrave.b $(OBJ)\mail.1-b \
X	$(OBJ)\o_init.o $(OBJ)\options.o $(OBJ)\restore.o $(OBJ)\rip.o \
X	$(OBJ)\save.o $(OBJ)\shknam.1-b $(OBJ)\topten.o $(OBJ)\tty.o \
X	$(OBJ)\u_init.o $(OBJ)\unix.1-b
X# Levelling
XOVL63 = $(OBJ)\apply.1 $(OBJ)\bones.o $(OBJ)\do.2 $(OBJ)\dog.2 \
X	$(OBJ)\extralev.o $(OBJ)\mklev.o $(OBJ)\mkmaze.o $(OBJ)\mkroom.1-b \
X	$(OBJ)\sp_lev.o $(OBJ)\track.2-b
X
X
X# *****************************************************************************
X# ************************* Make Objects **************************************
X# *****************************************************************************
X
XMOBJ = $(OVL01) $(OVL02) $(OVL03) $(OVL04) $(OVL05) $(OVL06) $(OVL07) $(OVL08)\
X       $(OVL09) $(OVL10) $(OVL11) $(OVL12) $(OVL13) $(OVL14) $(OVL15) $(OVL16)\
X       $(OVL17) $(OVL18) $(OVL19) $(OVL20) $(OVL21) $(OVL22) $(OVL23) $(OVL24)\
X       $(OVL25) $(OVL26) $(OVL27) $(OVL28) $(OVL29) $(OVL30) $(OVL31) $(OVL32)\
X       $(OVL33) $(OVL34) $(OVL35) $(OVL36) $(OVL37) $(OVL38) $(OVL39) $(OVL40)\
X       $(OVL41) $(OVL42) $(OVL43) $(OVL44) $(OVL45) $(OVL46) $(OVL47) $(OVL48)\
X       $(OVL49) $(OVL50) $(OVL51) $(OVL52) $(OVL53) $(OVL54) $(OVL55) $(OVL56)\
X       $(OVL57) $(OVL58) $(OVL59) $(OVL60) $(OVL61) $(OVL62) $(OVL63)
X
XVOBJ =	$(ROOT) $(MOBJ)
X
XHOBJ =	$(VOBJ) $(OBJ)\version.o
X
X# object files for makedefs
XMAKEOBJS    =	$(OBJ)\makedefs.o $(OBJ)\alloc.o    $(OBJ)\monst.o    \
X		$(OBJ)\objects.o  $(OBJ)\panic.o
X
XOVERLAYS = ($(OVL01)) ($(OVL02)) ($(OVL03)) ($(OVL04)) ($(OVL05)) ($(OVL06)) \
X	   ($(OVL07)) ($(OVL08)) ($(OVL09)) ($(OVL10)) ($(OVL11)) ($(OVL12)) \
X	   ($(OVL13)) ($(OVL14)) ($(OVL15)) ($(OVL16)) ($(OVL17)) ($(OVL18)) \
X	   ($(OVL19)) ($(OVL20)) ($(OVL21)) ($(OVL22)) ($(OVL23)) ($(OVL24)) \
X	   ($(OVL25)) ($(OVL26)) ($(OVL27)) ($(OVL28)) ($(OVL29)) ($(OVL30)) \
X	   ($(OVL31)) ($(OVL32)) ($(OVL33)) ($(OVL34)) ($(OVL35)) ($(OVL36)) \
X	   ($(OVL37)) ($(OVL38)) ($(OVL39)) ($(OVL40)) ($(OVL41)) ($(OVL42)) \
X	   ($(OVL43)) ($(OVL44)) ($(OVL45)) ($(OVL46)) ($(OVL47)) ($(OVL48)) \
X	   ($(OVL49)) ($(OVL50)) ($(OVL51)) ($(OVL52)) ($(OVL53)) ($(OVL54)) \
X	   ($(OVL55)) ($(OVL56)) ($(OVL57)) ($(OVL58)) ($(OVL59)) ($(OVL60)) \
X	   ($(OVL61)) ($(OVL62)      $(OBJ)\version.o) ($(OVL63))
X
X# object files for special levels compiler
XSPLEVOBJS   =	$(OBJ)\lev_comp.o $(OBJ)\lev_lex.o  $(OBJ)\lev_main.o \
X		$(OBJ)\alloc.o	  $(OBJ)\monst.o    $(OBJ)\objects.o  \
X		$(OBJ)\panic.o
X
X# *****************************************************************************
X# ************************** Header Objects ***********************************
X# *****************************************************************************
X
XPCCONF_H   = $(INCL)\$(TARG)conf.h $(INCL)\msdos.h    $(INCL)\system.h
XGLOBAL_H   = $(PCCONF_H)	   $(INCL)\coord.h    $(INCL)\global.h
XCONFIG_H   = $(GLOBAL_H)	   $(INCL)\config.h   $(INCL)\tradstdc.h
XPERMONST_H = $(INCL)\permonst.h    $(INCL)\monattk.h  $(INCL)\monflag.h
XYOUPROP_H  = $(PERMONST_H)	   $(INCL)\prop.h     $(INCL)\mondata.h \
X	     $(INCL)\pm.h	   $(INCL)\youprop.h
XYOU_H	   = $(YOUPROP_H)	   $(INCL)\attrib.h   $(INCL)\monst.h \
X	     $(INCL)\you.h
XDECL_H	   = $(YOU_H)		   $(INCL)\decl.h     $(INCL)\obj.h \
X	     $(INCL)\onames.h	   $(INCL)\spell.h    $(INCL)\color.h
XHACK_H	   = $(CONFIG_H)	   $(DECL_H)	      $(INCL)\trap.h \
X	     $(INCL)\flag.h	   $(INCL)\gold.h     $(INCL)\mkroom.h \
X	     $(INCL)\monsym.h	   $(INCL)\objclass.h $(INCL)\rm.h \
X	     $(INCL)\trampoli.h    $(INCL)\hack.h
X
X# *****************************************************************************
X# ************************ File Dependencies **********************************
X# *****************************************************************************
X
X# Due to an NDMake inadequacy these must accord with a topological sort of the
X# generated-from relation... output on the left, input on the right. Trust me.
X.SUFFIXES:  .exe .0 .0-1 .0-2 .0-3 .1 .1-2 .1-3 .1-b .2 .2-3 .2-b .3 .3-b .b \
X	    .o .c .y .l .obj .asm
X
X.c.o:
X	$(CC) $(CFLAGS) $(COSPACE) /Fo$(OBJ)\$*.o $*.c
X.c.0:
X	$(CC) $(CFLAGS) $(COSPEED) /DOVL0 /NT$*.0 /Fo$(OBJ)\$*.0 $*.c
X.c.0-1:
X	$(CC) $(CFLAGS) $(COSPEED) /DOVL0 /DOVL1 /NT$*.0-1 /Fo$(OBJ)\$*.0-1 $*.c
X.c.0-2:
X	$(CC) $(CFLAGS) $(COSPACE) /DOVL0 /DOVL1 /DOVL2 /NT$*.0-2 /Fo$(OBJ)\$*.0-2 $*.c
X.c.0-3:
X	$(CC) $(CFLAGS) $(COSPACE) /DOVL0 /DOVL1 /DOVL2 /DOVL3 /NT$*.0-3 /Fo$(OBJ)\$*.0-3 $*.c
X.c.1:
X	$(CC) $(CFLAGS) $(COSPACE) /DOVL1 /NT$*.1 /Fo$(OBJ)\$*.1 $*.c
X.c.1-2:
X	$(CC) $(CFLAGS) $(COSPACE) /DOVL1 /DOVL2 /NT$*.1-2 /Fo$(OBJ)\$*.1-2 $*.c
X.c.1-3:
X	$(CC) $(CFLAGS) $(COSPACE) /DOVL1 /DOVL2 /DOVL3 /NT$*.1-3 /Fo$(OBJ)\$*.1-3 $*.c
X.c.1-b:
X	$(CC) $(CFLAGS) $(COSPACE) /DOVL1 /DOVL2 /DOVL3 /DOVLB /NT$*.1-b /Fo$(OBJ)\$*.1-b $*.c
X.c.2:
X	$(CC) $(CFLAGS) $(COSPACE) /DOVL2 /NT$*.2 /Fo$(OBJ)\$*.2 $*.c
X.c.2-3:
X	$(CC) $(CFLAGS) $(COSPACE) /DOVL2 /DOVL3 /NT$*.2-3 /Fo$(OBJ)\$*.2-3 $*.c
X.c.2-b:
X	$(CC) $(CFLAGS) $(COSPACE) /DOVL2 /DOVL3 /DOVLB /NT$*.2-b /Fo$(OBJ)\$*.2-b $*.c
X.c.3:
X	$(CC) $(CFLAGS) $(COSPACE) /DOVL3 /NT$*.3 /Fo$(OBJ)\$*.3 $*.c
X.c.3-b:
X	$(CC) $(CFLAGS) $(COSPACE) /DOVL3 /DOVLB /NT$*.3-b /Fo$(OBJ)\$*.3-b $*.c
X.c.b:
X	$(CC) $(CFLAGS) $(COSPACE) /DOVLB /NT$*.b /Fo$(OBJ)\$*.b $*.c
X.asm.obj:
X	$(ASM) $(AFLAGS) $*.asm,$(OBJ)\$*.obj ;
X
X$(GAME): $(GAMEFILE)
X
X$(GAME).exe: $(GAMEFILE)
X
X$(GAMEFILE): $(OBJ) $(HOBJ)
X	@echo Loading....
X	$(LINK) $(ROOT) $(OVERLAYS),$(GAMEFILE),$(GAME),$(CLIB) $(TERMLIB) $(LFLAGS) ;
X	$(EXEPATCH) $(GAMEFILE) $(EXEFLAGS)
X	@echo NetHack is up to date.
X
X$(OBJ):
X	if not exist .\$(OBJ)\*.* mkdir $(OBJ)
X
X#	The following 3 modules vary depending on what OS you are using.
X
X$(OBJ)\main.o:	$(HACK_H) $(TARG)main.c
X	$(CC) $(CFLAGS) $(COSPACE)  /Fo.\$(OBJ)\main.o $(TARG)main.c
X
X$(OBJ)\tty.o:	$(HACK_H) $(INCL)\func_tab.h $(TARG)tty.c
X	$(CC) $(CFLAGS) $(COSPACE)  /Fo.\$(OBJ)\tty.o  $(TARG)tty.c
X
X$(OBJ)\unix.0:	$(HACK_H) $(TARG)unix.c
X	$(CC) $(CFLAGS) $(COSPEED)  /DOVL0 /Fo.\$(OBJ)\unix.0 $(TARG)unix.c
X$(OBJ)\unix.1-b:	$(HACK_H) $(TARG)unix.c
X	$(CC) $(CFLAGS) $(COSPACE)  /DOVL1 /DOVL2 /DOVL3 /DOVLB /Fo.\$(OBJ)\unix.1-b $(TARG)unix.c
X
X$(OBJ)\makedefs.o:	$(INCL)\config.h $(INCL)\permonst.h $(INCL)\objclass.h
X
Xmakedefs.exe:	$(MAKEOBJS)
X	$(LINK) $(LFLAGS) $(MAKEOBJS), makedefs.exe,, $(CLIB);
X
X#	Targets for the special levels compiler
X
Xlev_comp.c: lev_comp.y
X	$(MAKEBIN) do_yacc
X
Xlev_lex.c:  lev_comp.l
X	$(MAKEBIN) do_lex
X
Xyacc_msg:
X	@echo lev_comp.y has changed. To update lev_comp.c and lev_comp.h run YACC.
X
Xyacc_act:
X	$(YACC) -d lev_comp.y
X	copy $(YTABC) lev_comp.c
X	copy $(YTABH) $(INCL)\lev_comp.h
X	del $(YTABC)
X	del $(YTABH)
X
Xlex_msg:
X	@echo lev_comp.l has changed. To update lev_lex.c run LEX.
X
Xlex_act:
X	$(LEX) lev_comp.l
X	copy $(LEXYYC) lev_lex.c
X	del $(LEXYYC)
X
X#	This is stupid but since the default rule does not work here ...
X
X$(OBJ)\lev_comp.o:	$(HACK_H)   $(INCL)\sp_lev.h	lev_comp.c
X	$(CC) $(CFLAGS) /Fo$(OBJ)\$*.o $*.c
X$(OBJ)\lev_lex.o:	$(HACK_H)   $(INCL)\sp_lev.h	$(INCL)\lev_comp.h \
X			lev_lex.c
X	$(CC) $(CFLAGS) /Fo$(OBJ)\$*.o $*.c
X
Xlev_comp.exe:	$(SPLEVOBJS)
X	$(LINK) $(LFLAGS) $(SPLEVOBJS),lev_comp.exe,, $(CLIB);
X
X# *****************************************************************************
X# *************************  Makedefs Stuff ***********************************
X# *****************************************************************************
X#	The following include files depend on makedefs to be created.
X#	date.h should be remade any time any of the source or include code
X#	is modified.
X
X$(INCL)\date.h: $(VOBJ) makedefs.exe
X	.\makedefs -v
X
X$(INCL)\onames.h: makedefs.exe
X	.\makedefs -o
X
X$(INCL)\pm.h: makedefs.exe
X	.\makedefs -p
X
X$(INCL)\trap.h: makedefs.exe
X	.\makedefs -t
X
Xdata:	$(AUX)\data.bas makedefs.exe
X	.\makedefs -d
X
Xrumors: $(AUX)\rumors.tru $(AUX)\rumors.fal makedefs.exe
X	.\makedefs -r
X
X# *****************************************************************************
X# ************************ Secondary targets **********************************
X# *****************************************************************************
X
Xall:	install
X
Xinstall:	$(OBJ) lev_comp.exe $(GAMEFILE) auxil.tag install.tag
X	@echo Don't forget to check HACKDIR in NetHack.cnf.
X	@echo Done.
X
Xinstall.tag:
X	copy $(OTHERS)\termcap		$(GAMEDIR)
X	copy $(AUX)\*.			$(GAMEDIR)
X	del  $(GAMEDIR)\MacHelp
X	copy $(OTHERS)\NetHack.cnf	$(GAMEDIR)
X	echo install done > install.tag
X
Xspec_lev.tag: lev_comp.exe $(AUX)\castle.des $(AUX)\endgame.des $(AUX)\tower.des
X	lev_comp $(AUX)\castle.des
X	lev_comp $(AUX)\endgame.des
X	lev_comp $(AUX)\tower.des
X	copy castle $(GAMEDIR)
X	copy endgame $(GAMEDIR)
X	copy tower? $(GAMEDIR)
X	del castle
X	del endgame
X	del tower?
X	echo spec_lev done > spec_lev.tag
X
Xauxil.tag:	spec_lev.tag	data	rumors
X	echo special levels created > auxil.tag
X
Xclean:
X	del $(OBJ)\*.o
X	del $(OBJ)\*.0
X	del $(OBJ)\*.0-1
X	del $(OBJ)\*.0-2
X	del $(OBJ)\*.0-3
X	del $(OBJ)\*.1
X	del $(OBJ)\*.1-2
X	del $(OBJ)\*.1-3
X	del $(OBJ)\*.1-b
X	del $(OBJ)\*.2
X	del $(OBJ)\*.2-3
X	del $(OBJ)\*.2-b
X	del $(OBJ)\*.3
X	del $(OBJ)\*.3-b
X	del $(OBJ)\*.b
X	del $(OBJ)\*.obj
X	rmdir $(OBJ)
X
Xspotless: clean
X	del $(INCL)\date.h
X	del $(INCL)\onames.h
X	del $(INCL)\pm.h
X	if exist makedefs.exe del makedefs.exe
X	if exist lev_comp.exe del lev_comp.exe
X	del castle
X	del endgame
X	del tower?
X	del *.bak
X	del *.tag
X	del *.map
X	del *.obj
X	del *.lib
X	del *.txt
X	del $(AUX)\data
X	del $(AUX)\rumors
X
X# *****************************************************************************
X# ************************* Other dependencies ********************************
X# *****************************************************************************
X# Other dependencies
X#
X# I deleted that line.	;-}
X
X$(OBJ)\allmain.0:	$(HACK_H)
X$(OBJ)\allmain.1:	$(HACK_H)
X$(OBJ)\allmain.2-b:	$(HACK_H)
X$(OBJ)\alloc.o: 	$(CONFIG_H)
X$(OBJ)\apply.0: 	$(HACK_H)   $(INCL)\edog.h
X$(OBJ)\apply.1: 	$(HACK_H)   $(INCL)\edog.h
X$(OBJ)\apply.2-b:	$(HACK_H)   $(INCL)\edog.h
X$(OBJ)\artifact.0:	$(HACK_H)   $(INCL)\artifact.h
X$(OBJ)\artifact.1:	$(HACK_H)   $(INCL)\artifact.h
X$(OBJ)\artifact.2:	$(HACK_H)   $(INCL)\artifact.h
X$(OBJ)\artifact.b:	$(HACK_H)   $(INCL)\artifact.h
X$(OBJ)\attrib.0:	$(HACK_H)
X$(OBJ)\attrib.1:	$(HACK_H)
X$(OBJ)\attrib.2-b:	$(HACK_H)
X$(OBJ)\bones.o: 	$(HACK_H)
X$(OBJ)\cmd.0:		$(HACK_H)   $(INCL)\func_tab.h
X$(OBJ)\cmd.1:		$(HACK_H)   $(INCL)\func_tab.h
X$(OBJ)\cmd.2-b: 	$(HACK_H)   $(INCL)\func_tab.h
X$(OBJ)\dbridge.0:	$(HACK_H)
X$(OBJ)\dbridge.1-b:	$(HACK_H)
X$(OBJ)\decl.o:		$(HACK_H)
X$(OBJ)\demon.o: 	$(HACK_H)
X$(OBJ)\do.0:		$(HACK_H)
X$(OBJ)\do.1:		$(HACK_H)
X$(OBJ)\do.2:		$(HACK_H)
X$(OBJ)\do.3:		$(HACK_H)
X$(OBJ)\do.b:		$(HACK_H)
X$(OBJ)\do_name.0:	$(HACK_H)
X$(OBJ)\do_name.1-b:	$(HACK_H)
X$(OBJ)\do_wear.0-1:	$(HACK_H)
X$(OBJ)\do_wear.2:	$(HACK_H)
X$(OBJ)\do_wear.b:	$(HACK_H)
X$(OBJ)\dog.0:		$(HACK_H)   $(INCL)\edog.h
X$(OBJ)\dog.1:		$(HACK_H)   $(INCL)\edog.h
X$(OBJ)\dog.2:		$(HACK_H)   $(INCL)\edog.h
X$(OBJ)\dog.b:		$(HACK_H)   $(INCL)\edog.h
X$(OBJ)\dogmove.o:	$(HACK_H)   $(INCL)\mfndpos.h	 $(INCL)\edog.h
X$(OBJ)\dokick.o:	$(HACK_H)   $(INCL)\eshk.h
X$(OBJ)\dothrow.o:	$(HACK_H)
X$(OBJ)\eat.0:		$(HACK_H)
X$(OBJ)\eat.1:		$(HACK_H)
X$(OBJ)\eat.2-b: 	$(HACK_H)
X$(OBJ)\end.o:		$(HACK_H)   $(INCL)\eshk.h
X$(OBJ)\engrave.0-1:	$(HACK_H)
X$(OBJ)\engrave.2:	$(HACK_H)
X$(OBJ)\engrave.b:	$(HACK_H)
X$(OBJ)\exper.o: 	$(HACK_H)
X$(OBJ)\extralev.o:	$(HACK_H)
X$(OBJ)\fountain.o:	$(HACK_H)
X$(OBJ)\getline.0-1:	$(HACK_H)   $(INCL)\func_tab.h
X$(OBJ)\getline.2:	$(HACK_H)   $(INCL)\func_tab.h
X$(OBJ)\getline.b:	$(HACK_H)   $(INCL)\func_tab.h
X$(OBJ)\hack.0:		$(HACK_H)
X$(OBJ)\hack.1:		$(HACK_H)
X$(OBJ)\hack.2:		$(HACK_H)
X$(OBJ)\hack.b:		$(HACK_H)
X$(OBJ)\invent.0:	$(HACK_H)   $(INCL)\lev.h	 $(INCL)\wseg.h
X$(OBJ)\invent.1:	$(HACK_H)   $(INCL)\lev.h	 $(INCL)\wseg.h
X$(OBJ)\invent.2:	$(HACK_H)   $(INCL)\lev.h	 $(INCL)\wseg.h
X$(OBJ)\invent.3:	$(HACK_H)   $(INCL)\lev.h	 $(INCL)\wseg.h
X$(OBJ)\invent.b:	$(HACK_H)   $(INCL)\lev.h	 $(INCL)\wseg.h
X$(OBJ)\ioctl.o: 	$(HACK_H)
X$(OBJ)\lev_main.o:	$(HACK_H)   $(INCL)\sp_lev.h
X$(OBJ)\lock.0:		$(HACK_H)
X$(OBJ)\lock.1-b:	$(HACK_H)
X$(OBJ)\mail.0:		$(HACK_H)
X$(OBJ)\mail.1-b:	$(HACK_H)
X$(OBJ)\makemon.0-2:	$(HACK_H)
X$(OBJ)\makemon.b:	$(HACK_H)
X$(OBJ)\mcastu.o:	$(HACK_H)
X$(OBJ)\mhitm.0: 	$(HACK_H)   $(INCL)\artifact.h
X$(OBJ)\mhitm.1-b:	$(HACK_H)   $(INCL)\artifact.h
X$(OBJ)\mhitu.0-1:	$(HACK_H)   $(INCL)\artifact.h	 $(INCL)\edog.h
X$(OBJ)\mhitu.2-b:	$(HACK_H)   $(INCL)\artifact.h	 $(INCL)\edog.h
X$(OBJ)\mklev.o: 	$(HACK_H)
X$(OBJ)\mkmaze.o:	$(HACK_H)
X$(OBJ)\mkobj.0: 	$(HACK_H)
X$(OBJ)\mkobj.1: 	$(HACK_H)
X$(OBJ)\mkobj.2-b:	$(HACK_H)
X$(OBJ)\mkroom.0:	$(HACK_H)
X$(OBJ)\mkroom.1-b:	$(HACK_H)
X$(OBJ)\mon.0-1: 	$(HACK_H)   $(INCL)\mfndpos.h	 $(INCL)\wseg.h
X$(OBJ)\mon.2-b: 	$(HACK_H)   $(INCL)\mfndpos.h	 $(INCL)\wseg.h
X$(OBJ)\mondata.0-1:	$(HACK_H)   $(INCL)\eshk.h	 $(INCL)\epri.h
X$(OBJ)\mondata.2:	$(HACK_H)   $(INCL)\eshk.h	 $(INCL)\epri.h
X$(OBJ)\mondata.b:	$(HACK_H)   $(INCL)\eshk.h	 $(INCL)\epri.h
X$(OBJ)\monmove.0-1:	$(HACK_H)   $(INCL)\mfndpos.h	 $(INCL)\artifact.h
X$(OBJ)\monmove.2-b:	$(HACK_H)   $(INCL)\mfndpos.h	 $(INCL)\artifact.h
X$(OBJ)\monst.o: 	$(CONFIG_H) $(PERMONST_H)	 $(INCL)\eshk.h \
X			$(INCL)\vault.h $(INCL)\epri.h	 $(INCL)\color.h
X$(OBJ)\msdos.o: 	$(HACK_H)
X$(OBJ)\mthrowu.0:	$(HACK_H)
X$(OBJ)\mthrowu.1:	$(HACK_H)
X$(OBJ)\mthrowu.2-b:	$(HACK_H)
X$(OBJ)\music.o: 	$(HACK_H)
X$(OBJ)\o_init.o:	$(HACK_H)
X$(OBJ)\objects.o:	$(CONFIG_H) $(INCL)\obj.h	 $(INCL)\objclass.h \
X			$(INCL)\prop.h	$(INCL)\color.h
X$(OBJ)\objnam.0-1:	$(HACK_H)
X$(OBJ)\objnam.2-b:	$(HACK_H)
X$(OBJ)\options.o:	$(HACK_H)
X$(OBJ)\pager.0: 	$(HACK_H)
X$(OBJ)\pager.1-b:	$(HACK_H)
X$(OBJ)\panic.o: 	$(CONFIG_H)
X$(OBJ)\pickup.0:	$(HACK_H)
X$(OBJ)\pickup.1:	$(HACK_H)
X$(OBJ)\pickup.2-b:	$(HACK_H)
X$(OBJ)\polyself.0-1:	$(HACK_H)
X$(OBJ)\polyself.2-b:	$(HACK_H)
X$(OBJ)\potion.o:	$(HACK_H)
X$(OBJ)\pray.o:		$(HACK_H)
X$(OBJ)\pri.0:		$(HACK_H)   $(INCL)\epri.h	 $(INCL)\termcap.h
X$(OBJ)\pri.1:		$(HACK_H)   $(INCL)\epri.h	 $(INCL)\termcap.h
X$(OBJ)\pri.2:		$(HACK_H)   $(INCL)\epri.h	 $(INCL)\termcap.h
X$(OBJ)\pri.b:		$(HACK_H)   $(INCL)\epri.h	 $(INCL)\termcap.h
X$(OBJ)\priest.0:	$(HACK_H)   $(INCL)\mfndpos.h	 $(INCL)\eshk.h \
X			$(INCL)\epri.h
X$(OBJ)\priest.1-b:	$(HACK_H)   $(INCL)\mfndpos.h	 $(INCL)\eshk.h \
X			$(INCL)\epri.h
X$(OBJ)\prisym.0:	$(HACK_H)   $(INCL)\lev.h	 $(INCL)\wseg.h
X$(OBJ)\prisym.1:	$(HACK_H)   $(INCL)\lev.h	 $(INCL)\wseg.h
X$(OBJ)\prisym.2:	$(HACK_H)   $(INCL)\lev.h	 $(INCL)\wseg.h
X$(OBJ)\prisym.b:	$(HACK_H)   $(INCL)\lev.h	 $(INCL)\wseg.h
X$(OBJ)\random.o:
X$(OBJ)\read.0:		$(HACK_H)
X$(OBJ)\read.1-b:	$(HACK_H)
X$(OBJ)\restore.o:	$(HACK_H)   $(INCL)\lev.h	 $(INCL)\wseg.h
X$(OBJ)\rip.o:		$(HACK_H)
X$(OBJ)\rnd.0:		$(HACK_H)
X$(OBJ)\rnd.1:		$(HACK_H)
X$(OBJ)\rnd.2-b: 	$(HACK_H)
X$(OBJ)\rumors.o:	$(HACK_H)
X$(OBJ)\save.o:		$(HACK_H)   $(INCL)\lev.h	 $(INCL)\wseg.h
X$(OBJ)\search.0:	$(HACK_H)   $(INCL)\artifact.h
X$(OBJ)\search.1-b:	$(HACK_H)   $(INCL)\artifact.h
X$(OBJ)\shk.0:		$(HACK_H)   $(INCL)\eshk.h
X$(OBJ)\shk.1-b: 	$(HACK_H)   $(INCL)\eshk.h
X$(OBJ)\shknam.0:	$(HACK_H)   $(INCL)\eshk.h
X$(OBJ)\shknam.1-b:	$(HACK_H)   $(INCL)\eshk.h
X$(OBJ)\sit.o:		$(HACK_H)
X$(OBJ)\sounds.0:	$(HACK_H)   $(INCL)\edog.h	 $(INCL)\eshk.h
X$(OBJ)\sounds.1-b:	$(HACK_H)   $(INCL)\edog.h	 $(INCL)\eshk.h
X$(OBJ)\sp_lev.o:	$(HACK_H)   $(INCL)\sp_lev.h
X$(OBJ)\spell.o: 	$(HACK_H)
X$(OBJ)\steal.0-1:	$(HACK_H)
X$(OBJ)\steal.2-b:	$(HACK_H)
X$(OBJ)\termcap.0:	$(HACK_H)   $(INCL)\termcap.h
X$(OBJ)\termcap.1:	$(HACK_H)   $(INCL)\termcap.h
X$(OBJ)\termcap.2-b:	$(HACK_H)   $(INCL)\termcap.h
X$(OBJ)\timeout.0:	$(HACK_H)
X$(OBJ)\timeout.1-b:	$(HACK_H)
X$(OBJ)\topl.0:		$(HACK_H)
X$(OBJ)\topl.1-2:	$(HACK_H)
X$(OBJ)\topl.b:		$(HACK_H)
X$(OBJ)\topten.o:	$(HACK_H)
X$(OBJ)\track.0: 	$(HACK_H)
X$(OBJ)\track.1: 	$(HACK_H)
X$(OBJ)\track.2-b:	$(HACK_H)
X$(OBJ)\trampoli.o:	$(HACK_H)
X$(OBJ)\trap.0-1:	$(HACK_H)   $(INCL)\edog.h
X$(OBJ)\trap.2:		$(HACK_H)   $(INCL)\edog.h
X$(OBJ)\trap.b:		$(HACK_H)   $(INCL)\edog.h
X$(OBJ)\u_init.o:	$(HACK_H)
X$(OBJ)\uhitm.o: 	$(HACK_H)   $(INCL)\artifact.h
X$(OBJ)\vault.0: 	$(HACK_H)   $(INCL)\vault.h
X$(OBJ)\vault.1-b:	$(HACK_H)   $(INCL)\vault.h
X$(OBJ)\version.o:	$(HACK_H)   $(INCL)\date.h	 $(INCL)\patchlev.h
X$(OBJ)\weapon.0-1:	$(HACK_H)
X$(OBJ)\weapon.2-b:	$(HACK_H)
X$(OBJ)\were.0:		$(HACK_H)
X$(OBJ)\were.1-b:	$(HACK_H)
X$(OBJ)\wield.o: 	$(HACK_H)
X$(OBJ)\wizard.0:	$(HACK_H)
X$(OBJ)\wizard.1-b:	$(HACK_H)
X$(OBJ)\worm.o:		$(HACK_H)   $(INCL)\wseg.h
X$(OBJ)\worn.o:		$(HACK_H)
X$(OBJ)\write.o: 	$(HACK_H)
X$(OBJ)\zap.o:		$(HACK_H)
END_OF_FILE
if test 24531 -ne `wc -c <'others/Makefile.ovl'`; then
    echo shar: \"'others/Makefile.ovl'\" unpacked with wrong size!
fi
# end of 'others/Makefile.ovl'
echo shar: Extracting \"'vms/vmsbuild.com'\" \(8030 characters\)
sed "s/^X//" >'vms/vmsbuild.com' <<'END_OF_FILE'
X$ ! vms/vmsbuild.com -- compile and link NetHack 3.0 patchlevel 8	[pr]
X$ !
X$ ! usage:
X$ !   $ set default [.src]	!or [-.src] if starting from [.vms]
X$ !   $ @[-.vms]vmsbuild  [compiler-option]  [link-option]  [cc-switches]
X$ ! options:
X$ !	compiler-option :  either "VAXC" or "GNUC" or ""	!default VAXC
X$ !	link-option	:  either "SHARE[able]" or "LIB[rary]"	!default SHARE
X$ !	cc-switches	:  optional qualifiers for CC (such as "/noOpt/Debug")
X$ ! notes:
X$ !	If the symbol "CC" is defined, compiler-option is not used.
X$ !	The link-option refers to VAXCRTL (C Run-Time Library) handling;
X$ !	  to specify it while letting compiler-option default, use "" as
X$ !	  the compiler-option.
X$ !	To re-link without compiling, use "LINK" as special 'compiler-option';
X$ !	  to re-link with GNUC library, 'CC' must begin with "G" (or "g").
X$ !	Default wizard definition moved to include/vmsconf.h.
X$
X$	vaxc_ = "CC/NOLIST/OPTIMIZE=NOINLINE"	    !vaxc v3.x (2.x fixed below)
X$	gnuc_ = "GCC/CC1=""-fwritable-strings"""
X$	gnulib = "gnu_cc:[000000]gcclib/Library"    !(not used w/ vaxc)
X$ ! common CC options (/obj=file doesn't work for GCC 1.36, use rename instead)
X$	c_c_  = "/INCLUDE=[-.INCLUDE]"	!/DEFINE=(""WIZARD=""""GENTZEL"""""")
X$	if f$extract(1,3,f$getsyi("VERSION")).lts."4.6" then -
X$		c_c_ = c_c_ + "/DEFINE=(""VERYOLD_VMS"")"
X$ ! miscellaneous setup
X$	ivqual = %x00038240	!DCL-W-IVQUAL (used to check for ancient vaxc)
X$	abort := exit %x1000002A
X$ ! validate first parameter
X$	p1 := 'p1'
X$	c_opt = f$locate("|"+p1, "|VAXC|GNUC|LINK|SPECIAL|") !5
X$     if (c_opt/5)*5 .eq. c_opt then  goto p1_ok
X$	copy sys$input: sys$error:	!p1 usage
X%first arg is compiler option; it must be one of
X       "VAXC" -- use VAX C to compile everything
X   or  "GNUC" -- use GNU C to compile everything
X   or  "LINK" -- skip compilation, just relink nethack.exe
X   or  "SPEC[IAL]" -- just compile and link lev_comp.exe
X   or    ""   -- default operation (VAXC unless 'CC' is defined)
X
XNote: if a DCL symbol for CC is defined, "VAXC" and "GNUC" are no-ops.
X      If the symbol value begins with "G" (or "g"), then the GNU C
X      library will be included in all link operations.  Do not rebuild
X      lev_comp with "SPECIAL" unless you have a CC symbol setup with
X      the proper options.
X$	abort
X$p1_ok:
X$ ! validate second parameter
X$	p2 := 'p2'
X$	l_opt = f$locate("|"+p2, "|SHAREABLE|LIBRARY__|") !10
X$     if (l_opt/10)*10 .eq. l_opt then	goto p2_ok
X$	copy sys$input: sys$error:	!p2 usage
X%second arg is VAXCRTL handling; it must be one of
X       "SHAREABLE" -- link with SYS$SHARE:VAXCRTL.EXE/SHAREABLE
X   or   "LIBRARY"  -- link with SYS$LIBRARY:VAXCRTL.OLB/LIBRARY
X   or      ""      -- default operation (use shareable image)
X
XNote: for MicroVMS 4.x, "SHAREABLE" (which is the default) is required.
X$	abort
X$p2_ok:
X$ ! compiler setup; if a symbol for "CC" is already defined it will be used
X$     if f$type(cc).eqs."STRING" then  goto got_cc
X$	cc = vaxc_			!assume "VAXC" requested or defaulted
X$	if c_opt.eq.5 then  cc = gnuc_	!explicitly invoked w/ "GNUC" option
X$	if c_opt.ne.0 then  goto got_cc !"GNUC" or "LINK", skip compiler check
X$	! we want to prevent function inlining with vaxc v3.x (/opt=noinline)
X$	!   but we can't use noInline with v2.x, so need to determine version
X$	  set noOn
X$	  msgenv = f$environment("MESSAGE")
X$	  set message/noFacil/noSever/noIdent/noText
X$	  cc/noObject _NLA0:/Include=[]     !strip 'noinline' if error
X$	  sts = $status
X$	if sts then  goto reset_msg	!3.0 or later will check out OK
X$	! must be dealing with vaxc 2.x; ancient version (2.2 or earlier)
X$	!   can't handle /include='dir', needs c$include instead
X$	  cc = cc - "=NOINLINE" - ",NOINLINE" - "NOINLINE,"
X$	  if sts.ne.IVQUAL then  goto reset_msg
X$	    define/noLog c$include [-.INCLUDE]
X$	    c_c_ = "/DEFINE=(""ANCIENT_VAXC"")"
X$	    if f$extract(1,3,f$getsyi("VERSION")).lts."4.6" then -
X$		c_c_ = c_c_ - ")" + ",""VERYOLD_VMS"")"
X$reset_msg:
X$	  set message 'msgenv'
X$	  set On
X$got_cc:
X$	cc = cc + c_c_			!append common qualifiers
X$	if p3.nes."" then  cc = cc + p3 !append optional user preferences
X$	g := 'f$extract(0,1,cc)'
X$	if g.nes."G" then  gnulib = ""
X$	if g.eqs."G" then  gnulib = "," + gnulib
X$ ! linker setup; if a symbol for "LINK" is defined, we'll use it
X$	if f$type(link).nes."STRING" then  link = "LINK/NOMAP"
X$	if p4.nes."" then  link = link + p4 !append optional user preferences
X$	vaxcrtl = "sys$library:vaxcrtl.olb/Library"	!object library
X$     if l_opt.ne.0 then  goto vaxcrtl_ok
X$	vaxcrtl = "sys$disk:[]vaxcrtl.opt/Options"	!shareable image
X$     if f$search("vaxcrtl.opt").nes."" then  goto vaxcrtl_ok !assume its right
X$	create sys$disk:[]vaxcrtl.opt
Xsys$share:vaxcrtl/Shareable
Xsys$library:vaxcrtl/Library	!/Include=C$$TRANSLATE	!for link() substitute
X$vaxcrtl_ok:
X$ ! final setup
X$	nethacklib = "nethack.olb"
X$	milestone = "write sys$output f$fao("" !5%T "",0),"
X$     if c_opt.eq.10 then  goto link	!"LINK" requested, skip compilation
X$	rename	 := rename/New_Vers
X$	touch	 := set file/Truncate
X$	makedefs := $sys$disk:[]makedefs
X$	show symbol cc
X$!
X$!  compile and link makedefs, then nethack, finally lev_comp.
X$!
X$ milestone "<compiling...>"
X$ cc [-.vms]vmsmisc	!try simplest one first
X$ cc alloc.c
X$ if f$search("monst.c").eqs."" then  copy/Concat monst.c1+.c2 *.c
X$ cc monst.c
X$ milestone " (monst)"
X$ cc objects.c
X$     if c_opt.eq.15 then  goto special !"SPECIAL" requested, skip main build
X$ cc makedefs.c
X$ link makedefs.obj,monst.obj,objects.obj,vmsmisc.obj,-
X	'vaxcrtl''gnulib',sys$input:/Opt
Xidentification="makedefs 3.0.8"
X$ milestone "makedefs"
X$! create some build-time files
X$ makedefs -p	!pm.h
X$ makedefs -o	!onames.h
X$ makedefs -t	!trap.h
X$ makedefs -v	!date.h
X$! create new object library
X$ libr/Obj 'nethacklib'/Create=(Block=2000,Hist=2) vmsmisc.obj,alloc.obj/Insert
X$ if f$search(f$parse(".olb;-2",nethacklib)).nes."" then -
X$	purge/Keep=2 'nethacklib'
X$! compile most of the source files:
X$ c1 = "decl,version,[-.vms]vmsmain,[-.vms]vmsunix,[-.vms]vmstty," -
X      + "[-.others]random,[-.vms]vmstparam"
X$ c2 = "allmain,apply,artifact,attrib,bones,cmd,dbridge,demon,do,do_name," -
X      + "do_wear,dog,dogmove,dokick,dothrow,eat,end,engrave,exper,extralev"
X$ c3 = "fountain,getline,hack,invent,lock,mail,makemon,mcastu,mhitm,mhitu," -
X      + "mklev,mkmaze,mkobj,mkroom,mon,mondata,monmove,mthrowu,music,o_init"
X$ c4 = "objnam,options,pager,pickup,polyself,potion,pray,pri,priest,prisym," -
X      + "read,restore,rip,rnd,rumors,save,search,shk,shknam,sit,sounds,sp_lev"
X$ c5 = "spell,steal,termcap,timeout,topl,topten,track,trap,u_init,uhitm," -
X      + "vault,weapon,were,wield,wizard,worm,worn,write,zap"
X$! process all 5 lists of files
X$   i = 1
X$list_loop:
X$     list = c'i'	!get next list
X$     j = 0
X$file_loop:
X$	file = f$element(j,",",list)	!get next file
X$	if file.eqs."" .or. file.eqs."," then  goto list_done
X$	cc 'file'.c
X$	if f$extract(0,1,file).eqs."[" then -
X$		file = f$edit(f$parse(file,,,"NAME"),"LOWERCASE")
X$	libr/Obj 'nethacklib' 'file'.obj/Insert
X$	delete 'file'.obj;*
X$	milestone " (",file,")"
X$	j = j + 1
X$     goto file_loop
X$list_done:
X$     i = i + 1
X$   if i.le.5 then  goto list_loop
X$! one special case left
X$ cc [-.vms]vmstermcap.c -
X	/Define=("bcopy(s,d,n)=memcpy((d),(s),(n))","exit=vms_exit")
X$ libr/Obj 'nethacklib' vmstermcap.obj/Insert
X$!
X$link:
X$ milestone "<linking...>"
X$ link/Exe=nethack 'nethacklib'/Lib/Incl=(vmsmain,allmain,vmsunix,vmstty,decl),-
X	sys$disk:[]monst.obj,objects.obj,-	!(data-only modules, like decl)
X	sys$input:/Opt,'vaxcrtl''gnulib'
Xidentification="NetHack 3.0.8"
X$ milestone "NetHack"
X$     if c_opt.eq.10 then  goto done	!"LINK" only
X$special:
X$!
X$! build special level compiler
X$!
X$ cc lev_main.c
X$ cc lev_comp.c
X$ copy [-.vms]lev_lex.h stdio.*/Prot=(s:rwd,o:rwd)
X$ cc lev_lex.c
X$ rename stdio.h lev_lex.*
X$ cc panic.c
X$ link lev_comp.obj,lev_lex.obj,lev_main.obj,-
X	monst.obj,objects.obj,alloc.obj,panic.obj,vmsmisc.obj,-
X	'vaxcrtl''gnulib',sys$input:/Opt
Xidentification="lev_comp 3.0.8"
X$ milestone "lev_comp"
X$!
X$done:
X$ exit
END_OF_FILE
if test 8030 -ne `wc -c <'vms/vmsbuild.com'`; then
    echo shar: \"'vms/vmsbuild.com'\" unpacked with wrong size!
fi
# end of 'vms/vmsbuild.com'
echo shar: End of archive 22 \(of 24\).
cp /dev/null ark22isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 24 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
