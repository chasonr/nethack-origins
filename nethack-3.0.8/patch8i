Path: utzoo!attcan!uunet!tut.cis.ohio-state.edu!zaphod.mps.ohio-state.edu!uakari.primate.wisc.edu!dali.cs.montana.edu!milton!uw-beaver!zephyr.ens.tek.com!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v10i027:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Patch8i
Message-ID: <5735@tekred.CNA.TEK.COM>
Date: 5 Jun 90 17:55:30 GMT
Sender: news@tekred.CNA.TEK.COM
Lines: 2386
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 10, Issue 27
Archive-name: NetHack3/Patch8i
Patch-To: NetHack3: Volume 7, Issue 56-93



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 9 (of 24)."
# Contents:  others/splitf.c patch8.03
# Wrapped by billr@saab on Mon Jun  4 15:27:20 1990
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'others/splitf.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'others/splitf.c'\"
else
echo shar: Extracting \"'others/splitf.c'\" \(4920 characters\)
sed "s/^X//" >'others/splitf.c' <<'END_OF_FILE'
X/******************************************************************************
X*									      *
X*			File Splitter and Re-assembler			      *
X*									      *
X*			by Pierre Martineau, 90/05/20			      *
X*									      *
X*				 Version 1.1				      *
X*									      *
X*			 Placed in the public domain			      *
X*									      *
X******************************************************************************/
X
X#include <sys\types.h>
X#include <sys\stat.h>
X#include <string.h>
X#include <stdlib.h>
X#include <stdio.h>
X#include <math.h>
X
XFILE *infile, *outfile;
Xchar fname[16];
Xchar chunk_name[16];
Xint extent = 0;
Xlong hunk_size;
Xunsigned buflen = 0x8000;
Xchar *buf = 0;
X
Xmain(argc, argv)
Xint argc;
Xchar *argv[];
X{
Xstruct stat stat_buf;
Xchar *cptr;
X
X    printf("File Splitter and Re-assembler V1.1, by Pierre Martineau, 90/05/20.\n");
X    printf("This program is public domain and may be freely distributed.\n");
X    if ((argc < 2) || (argc > 3)) {
X	printf("\nUsage: splitf file_to_split [chunk_size]\n");
X	printf("       If chunk_size isn't specified, the file will be split\n");
X	printf("       into two files of (approximately) equal size.\n\n");
X	printf("       splitf dest_file /r\n");
X	printf("       /r will re-assemble the parts back into the whole\n");
X	printf("       specified by dest_file.\n");
X	return;
X    }
X
X/*  Extract filename from first argumemt  */
X
X    if ((cptr = strrchr(argv[1], '\\')) == NULL)
X	cptr = argv[1];
X    else
X	cptr++;
X    strcpy(fname, cptr);
X    if ((cptr = strchr(fname, '.')) != NULL)
X	*++cptr = '\000';
X    else
X	strcat(fname, ".");
X
X    if ((argc == 3) && ((strcmpi(argv[2], "-r") == 0) || (strcmpi(argv[2], "/r") == 0))) {
X	getbuf();
X	printf("\nRe-assembling %s ...\n\n", argv[1]);
X	copy_hunks(argv[1]);
X	fclose(outfile);
X	freebuf();
X	printf("\nDone.\n");
X    }
X    else {
X	getbuf();
X	if ((infile = fopen(argv[1], "rb")) == NULL) {
X	    printf("\nCouldn't open input file!\n");
X	    return;
X	}
X	if (stat(argv[1], &stat_buf) != 0) {
X	    printf("\nBad file handle!\n");
X	    return;
X	}
X	if (argc == 3)
X	    hunk_size = atol(argv[2]);
X	else
X	    hunk_size = (stat_buf.st_size / 2) + 1;
X	if (hunk_size < 1) {
X	    printf("\nInvalid chunk size!\n");
X	    return;
X	}
X	printf("\nSplitting %s ...\n\n", argv[1]);
X	write_hunks();
X	fclose(infile);
X	freebuf();
X	printf("\nDone.\n");
X    }
X}
X
Xwrite_hunks()
X{
Xlong size;
Xunsigned bufsize;
Xunsigned numread;
X
X    for (;;) {
X	if(!next_file()) {
X	    printf("Too many files, please specify a chunk size that\n");
X	    printf("will result in fewer than 1000 output files!\n");
X	    return;
X	}
X	if ((outfile = fopen(chunk_name, "wb")) == NULL) {
X	    printf("Unable to create output file %s\n", chunk_name);
X	    return;
X	}
X	size = hunk_size;
X	numread = 1;
X	while(size > 0 && numread /* Work around TC idiot-syncracy */) {
X	    bufsize = size < buflen ? size : buflen;
X	    numread = fread(buf, sizeof(char), bufsize, infile);
X	    if (ferror(infile)) {
X		printf("Error while reading input file %s\n", chunk_name);
X		fclose(outfile);
X		return;
X	    }
X	    fwrite(buf, sizeof(char), numread, outfile);
X	    if (ferror(outfile)) {
X		printf("Error while writing output file!\n");
X		fclose(outfile);
X		return;
X	    }
X	    size -= numread;
X	    if (numread != bufsize) {
X		printf("    Writing %ld bytes to %s\n", hunk_size-size, chunk_name);
X		fclose(outfile);
X		return;
X	    }
X	}
X	fclose(outfile);
X	printf("    Writing %ld bytes to %s\n", hunk_size-size, chunk_name);
X    }
X}
X
Xcopy_hunks(filename)
Xchar *filename;
X{
Xunsigned numread;
X
X    if(!next_file())
X	return;
X    if ((infile = fopen(chunk_name, "rb")) == NULL) {
X	printf("Nothing to do!\n");
X	return;
X    }
X    if ((outfile = fopen(filename, "wb")) == NULL) {
X	printf("Couldn't open output file!\n");
X	return;
X    }
X    for (;;) {
X	numread = 1;
X	while(!feof(infile) && numread /* Avoid TC problem */) {
X	    numread = fread(buf, sizeof(char), buflen, infile);
X	    if (ferror(infile)) {
X		printf("Error while reading input file %s\n", chunk_name);
X		fclose(infile);
X		return;
X	    }
X	    fwrite(buf, sizeof(char), numread, outfile);
X	    if (ferror(outfile)) {
X		printf("Error while writing output file!\n");
X		fclose(infile);
X		return;
X	    }
X	}
X	printf("    Copying file %s to output file.\n", chunk_name);
X	fclose(infile);
X	if(!next_file())
X	    return;
X	if ((infile = fopen(chunk_name, "rb")) == NULL)
X	    return;
X	    
X    }
X}
X
Xnext_file()
X{
Xchar num[4];
X
X    if (extent > 999)
X	return(0);
X    strcpy(chunk_name, fname);
X    itoa(extent,num, 10);
X    if (strlen(num) == 1) {
X	strcat(chunk_name, "00");
X	strcat(chunk_name, num);
X    }
X    else if (strlen(num) == 2) {
X	strcat(chunk_name, "0");
X	strcat(chunk_name, num);
X    }
X    else
X	strcat(chunk_name, num);
X    ++extent;
X    return(-1);
X}
X
Xgetbuf()
X{
X    while (buflen >= 256 && !(buf = malloc(buflen)))
X	buflen >>= 1;
X    if (!buf) {
X	printf("\nCan't allocate an adequate copy buffer.\n");
X	exit(2);
X	}
X}
X
Xfreebuf()
X{
X    free(buf);
X}
X
END_OF_FILE
if test 4920 -ne `wc -c <'others/splitf.c'`; then
    echo shar: \"'others/splitf.c'\" unpacked with wrong size!
fi
# end of 'others/splitf.c'
fi
if test -f 'patch8.03' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'patch8.03'\"
else
echo shar: Extracting \"'patch8.03'\" \(50662 characters\)
sed "s/^X//" >'patch8.03' <<'END_OF_FILE'
X*** src/Old/end.c	Sun Jun  3 12:57:03 1990
X--- src/end.c	Thu May 31 22:12:57 1990
X***************
X*** 14,28 ****
X  #include "eshk.h"
X  
X  void NDECL(end_box_display);
X! static int NDECL(done_intr);
X  
X! static const char *deaths[] = {		/* the array of death */
X  	"died", "choked", "poisoned", "starvation", "drowning",
X  	"burning", "crushed", "turned to stone", "genocided",
X  	"panic", "trickery",
X  	"quit", "escaped", "ascended" };
X  
X! static const char *ends[] = {		/* "when you..." */
X  	"died", "choked", "were poisoned", "starved", "drowned",
X  	"burned", "were crushed", "turned to stone", "were genocided",
X  	"panicked", "were tricked",
X--- 14,29 ----
X  #include "eshk.h"
X  
X  void NDECL(end_box_display);
X! STATIC_PTR int NDECL(done_intr);
X! static void FDECL(disclose,(int,BOOLEAN_P));
X  
X! static const char NEARDATA *deaths[] = {		/* the array of death */
X  	"died", "choked", "poisoned", "starvation", "drowning",
X  	"burning", "crushed", "turned to stone", "genocided",
X  	"panic", "trickery",
X  	"quit", "escaped", "ascended" };
X  
X! static const char NEARDATA *ends[] = {		/* "when you..." */
X  	"died", "choked", "were poisoned", "starved", "drowned",
X  	"burned", "were crushed", "turned to stone", "were genocided",
X  	"panicked", "were tricked",
X***************
X*** 99,105 ****
X  	return 0;
X  }
X  
X! static
X  int
X  done_intr(){
X  	done_stopprint++;
X--- 100,106 ----
X  	return 0;
X  }
X  
X! STATIC_PTR
X  int
X  done_intr(){
X  	done_stopprint++;
X***************
X*** 240,255 ****
X  	done(PANICKED);
X  }
X  
X! /* Be careful not to call panic from here! */
X! void
X! done(how)
X  int how;
X  {
X  #ifdef MACOS
X  	int see_c;
X  	char mac_buf[80];
X  #endif
X  	struct permonst *upmon;
X  	char kilbuf[BUFSZ], buf2[BUFSZ];
X  	/* kilbuf: used to copy killer in case it comes from something like
X  	 *	xname(), which would otherwise get overwritten when we call
X--- 241,325 ----
X  	done(PANICKED);
X  }
X  
X! static void
X! disclose(how,taken)
X  int how;
X+ boolean taken;
X  {
X  #ifdef MACOS
X  	int see_c;
X  	char mac_buf[80];
X  #endif
X+ 	char	c;
X+ 
X+ 	if(invent) {
X+ #ifndef MACOS
X+ 	    if(taken)
X+ 		pline("Do you want to see what you had when you %s? ",
X+ 			(how == QUIT) ? "quit" : "died");
X+ 	    else
X+ 		pline("Do you want your possessions identified? ");
X+ 	    if ((c = yn_function(ynqchars,'y')) == 'y') {
X+ #else
X+ 		{
X+ 			extern short macflags;
X+ 		
X+ 			/* stop user from using menus, etc. */
X+ 			macflags &= ~(fDoNonKeyEvt | fDoUpdate);
X+ 		}
X+ 	    if(taken)
X+ 		Sprintf(mac_buf, "Do you want to see what you had when you %s? ",
X+ 			(how == QUIT) ? "quit" : "died");
X+ 	    else
X+ 		Sprintf(mac_buf, "Do you want your possessions identified? ");
X+ 		if(!flags.silent) SysBeep(1);
X+ 	    if ((c = "qqynq"[UseMacAlertText(129,mac_buf)+1]) == 'y') {
X+ #endif
X+ 	    /* New dump format by maartenj@cs.vu.nl */
X+ 		struct obj *obj;
X+ 
X+ 		for(obj = invent; obj && !done_stopprint; obj = obj->nobj) {
X+ 		    makeknown(obj->otyp);
X+ 		    obj->known = obj->bknown = obj->dknown = 1;
X+ 		}
X+ 		doinv(NULL);
X+ 		end_box_display();
X+ 	    }
X+ 	    if (c == 'q')  done_stopprint++;
X+ 	    if (taken) {
X+ 		/* paybill has already given the inventory locations 
X+ 		 * in the shop and put it on the main object list
X+ 		 */
X+ 		struct obj *obj;
X+ 
X+ 		for(obj = invent; obj; obj = obj->nobj) {
X+ 		    obj->owornmask = 0;
X+ 		    if(rn2(5)) curse(obj);
X+ 		}
X+ 	        invent = (struct obj *) 0;
X+ 	    }
X+ 	}
X+ 
X+ 	if (!done_stopprint) {
X+ #ifdef MACOS
X+ 		c = "qqynq"[UseMacAlertText(129, "Do you want to see your instrinsics ?")+1];
X+ #else
X+ 	    pline("Do you want to see your intrinsics? ");
X+ 	    c = yn_function(ynqchars, 'y');
X+ #endif
X+ 	    if (c == 'y') enlightenment();
X+ 	    if (c == 'q') done_stopprint++;
X+ 	}
X+ 
X+ }
X+ 
X+ /* Be careful not to call panic from here! */
X+ void
X+ done(how)
X+ int how;
X+ {
X  	struct permonst *upmon;
X+ 	boolean taken;
X  	char kilbuf[BUFSZ], buf2[BUFSZ];
X  	/* kilbuf: used to copy killer in case it comes from something like
X  	 *	xname(), which would otherwise get overwritten when we call
X***************
X*** 256,263 ****
X  	 *	xname() when listing possessions
X  	 * buf2: same as player name, except it is capitalized
X  	 */
X- 	char	c;
X- 	boolean taken;
X  #ifdef ENDGAME
X  	if (how == ASCENDED)
X  		killer_format = NO_KILLER_PREFIX;
X--- 326,331 ----
X***************
X*** 346,415 ****
X  			Strcpy(kilbuf, "quit while already on Charon's boat");
X  		}
X  	}
X! 	if (how == ESCAPED) killer_format = NO_KILLER_PREFIX;
X  	taken = paybill();
X  	paygd();
X  	clearlocks();
X  	if(flags.toplin == 1) more();
X  
X! 	if(invent) {
X! #ifndef MACOS
X! 	    if(taken)
X! 		pline("Do you want to see what you had when you %s? ",
X! 			(how == QUIT) ? "quit" : "died");
X! 	    else
X! 		pline("Do you want your possessions identified? ");
X! 	    if ((c = yn_function(ynqchars,'y')) == 'y') {
X! #else
X! 		{
X! 			extern short macflags;
X! 		
X! 			/* stop user from using menus, etc. */
X! 			macflags &= ~(fDoNonKeyEvt | fDoUpdate);
X! 		}
X! 	    if(taken)
X! 		sprintf(mac_buf, "Do you want to see what you had when you %s? ",
X! 			(how == QUIT) ? "quit" : "died");
X! 	    else
X! 		sprintf(mac_buf, "Do you want your possessions identified? ");
X! 		if(!flags.silent) SysBeep(1);
X! 	    if ((c = "qqynq"[UseMacAlertText(129,mac_buf)+1]) == 'y') {
X! #endif
X! 	    /* New dump format by maartenj@cs.vu.nl */
X! 		struct obj *obj;
X! 
X! 		for(obj = invent; obj && !done_stopprint; obj = obj->nobj) {
X! 		    makeknown(obj->otyp);
X! 		    obj->known = obj->bknown = obj->dknown = 1;
X! 		}
X! 		doinv(NULL);
X! 		end_box_display();
X! 	    }
X! 	    if (c == 'q')  done_stopprint++;
X! 	    if (taken) {
X! 		/* paybill has already given the inventory locations in the shop
X! 		 * and put it on the main object list
X! 		 */
X! 		struct obj *obj;
X! 
X! 		for(obj = invent; obj; obj = obj->nobj) {
X! 		    obj->owornmask = 0;
X! 		    if(rn2(5)) curse(obj);
X! 		}
X! 	        invent = (struct obj *) 0;
X! 	    }
X! 	}
X! 
X! 	if (!done_stopprint) {
X! #ifdef MACOS
X! 		c = "qqynq"[UseMacAlertText(129, "Do you want to see your instrinsics ?")+1];
X! #else
X! 	    pline("Do you want to see your intrinsics? ");
X! 	    c = yn_function(ynqchars, 'y');
X! #endif
X! 	    if (c == 'y') enlightenment();
X! 	    if (c == 'q') done_stopprint++;
X! 	}
X  
X  	if(how < GENOCIDED) {
X  #ifdef WIZARD
X--- 414,430 ----
X  			Strcpy(kilbuf, "quit while already on Charon's boat");
X  		}
X  	}
X! 	if (how == ESCAPED || how == PANICKED)
X! 		killer_format = NO_KILLER_PREFIX;
X! 
X! 	/* paybill() must be called unconditionally, or strange things will
X! 	 * happen to bones levels */
X  	taken = paybill();
X  	paygd();
X  	clearlocks();
X  	if(flags.toplin == 1) more();
X  
X! 	disclose(how,taken);
X  
X  	if(how < GENOCIDED) {
X  #ifdef WIZARD
X***************
X*** 464,472 ****
X  #endif
X  					) {
X  		register struct monst *mtmp;
X! 		register struct obj *otmp;
X  		long i;
X  		register unsigned int worthlessct = 0;
X  
X  		keepdogs();
X  		mtmp = mydogs;
X--- 479,535 ----
X  #endif
X  					) {
X  		register struct monst *mtmp;
X! 		register struct obj *otmp, *otmp2, *prevobj;
X! 		struct obj *jewels = (struct obj *)0;
X  		long i;
X  		register unsigned int worthlessct = 0;
X+ #if defined(LINT) || defined(__GNULINT__)
X+ 		prevobj = (struct obj *)0;
X+ #endif
X+ 
X+ 		/* put items that count into jewels chain
X+ 		 * rewriting the fcobj and invent chains here is safe,
X+ 		 * as they'll never be used again
X+ 		 */
X+ 		for(otmp = fcobj; otmp; otmp = otmp2) {
X+ 			otmp2 = otmp->nobj;
X+ 			if(carried(otmp->cobj)
X+ 					&& ((otmp->olet == GEM_SYM &&
X+ 					     otmp->otyp < LUCKSTONE)
X+ 					    || otmp->olet == AMULET_SYM)) {
X+ 				if(otmp == fcobj)
X+ 					fcobj = otmp->nobj;
X+ 				else
X+ 					prevobj->nobj = otmp->nobj;
X+ 				otmp->nobj = jewels;
X+ 				jewels = otmp;
X+ 			} else
X+ 				prevobj = otmp;
X+ 		}
X+ 		for(otmp = invent; otmp; otmp = otmp2) {
X+ 			otmp2 = otmp->nobj;
X+ 			if((otmp->olet == GEM_SYM && otmp->otyp < LUCKSTONE)
X+ 					    || otmp->olet == AMULET_SYM) {
X+ 				if(otmp == invent)
X+ 					invent = otmp->nobj;
X+ 				else
X+ 					prevobj->nobj = otmp->nobj;
X+ 				otmp->nobj = jewels;
X+ 				jewels = otmp;
X+ 			} else
X+ 				prevobj = otmp;
X+ 		}
X+ 
X+ 		/* add points for jewels */
X+ 		for(otmp = jewels; otmp; otmp = otmp->nobj) {
X+ 			if(otmp->olet == GEM_SYM)
X+ 				u.urexp += (long) otmp->quan *
X+ 					    objects[otmp->otyp].g_val;
X+ 			else 	/* amulet */
X+ 				u.urexp += (otmp->spe < 0) ? 2 :
X+ 					otmp->otyp == AMULET_OF_YENDOR ?
X+ 							5000 : 500;
X+ 		}
X  
X  		keepdogs();
X  		mtmp = mydogs;
X***************
X*** 498,507 ****
X  		  Printf("You escaped from the dungeon with %ld points,\n",
X  #endif
X  		    u.urexp);
X! 		get_all_from_box(); /* don't forget things in boxes and bags */
X! 		for(otmp = invent; otmp; otmp = otmp->nobj) {
X  			if(otmp->olet == GEM_SYM && otmp->otyp < LUCKSTONE) {
X- 				makeknown(otmp->otyp);
X  				i = (long) otmp->quan *
X  					objects[otmp->otyp].g_val;
X  				if(i == 0) {
X--- 561,571 ----
X  		  Printf("You escaped from the dungeon with %ld points,\n",
X  #endif
X  		    u.urexp);
X! 
X! 		/* print jewels chain here */
X! 		for(otmp = jewels; otmp; otmp = otmp->nobj) {
X! 			makeknown(otmp->otyp);
X  			if(otmp->olet == GEM_SYM && otmp->otyp < LUCKSTONE) {
X  				i = (long) otmp->quan *
X  					objects[otmp->otyp].g_val;
X  				if(i == 0) {
X***************
X*** 508,522 ****
X  					worthlessct += otmp->quan;
X  					continue;
X  				}
X- 				u.urexp += i;
X  				Printf("        %s (worth %ld zorkmids),\n",
X  				    doname(otmp), i);
X! 			} else if(otmp->olet == AMULET_SYM) {
X  				otmp->known = 1;
X  				i = (otmp->spe < 0) ? 2 :
X  					otmp->otyp == AMULET_OF_YENDOR ?
X  							5000 : 500;
X- 				u.urexp += i;
X  				Printf("        %s (worth %ld zorkmids),\n",
X  				    doname(otmp), i);
X  			}
X--- 572,584 ----
X  					worthlessct += otmp->quan;
X  					continue;
X  				}
X  				Printf("        %s (worth %ld zorkmids),\n",
X  				    doname(otmp), i);
X! 			} else {		/* amulet */
X  				otmp->known = 1;
X  				i = (otmp->spe < 0) ? 2 :
X  					otmp->otyp == AMULET_OF_YENDOR ?
X  							5000 : 500;
X  				Printf("        %s (worth %ld zorkmids),\n",
X  				    doname(otmp), i);
X  			}
X*** src/Old/engrave.c	Sun Jun  3 12:57:34 1990
X--- src/engrave.c	Sat May 26 22:14:12 1990
X***************
X*** 4,10 ****
X  
X  #include	"hack.h"
X  
X! VSTATIC struct engr {
X  	struct engr *nxt_engr;
X  	char *engr_txt;
X  	xchar engr_x, engr_y;
X--- 4,10 ----
X  
X  #include	"hack.h"
X  
X! STATIC_VAR struct engr {
X  	struct engr *nxt_engr;
X  	char *engr_txt;
X  	xchar engr_x, engr_y;
X***************
X*** 16,25 ****
X  #define BURN	3
X  #define MARK	4
X  #define POLY	5	/* temporary type - for polymorphing engraving */
X! } *head_engr;
X  
X! OSTATIC void FDECL(del_engr, (struct engr *));
X! OSTATIC struct engr * FDECL(engr_at,(XCHAR_P,XCHAR_P));
X  
X  #ifdef OVLB
X  /* random engravings */
X--- 16,25 ----
X  #define BURN	3
X  #define MARK	4
X  #define POLY	5	/* temporary type - for polymorphing engraving */
X! } NEARDATA *head_engr;
X  
X! STATIC_DCL void FDECL(del_engr, (struct engr *));
X! STATIC_DCL struct engr * FDECL(engr_at,(XCHAR_P,XCHAR_P));
X  
X  #ifdef OVLB
X  /* random engravings */
X***************
X*** 37,43 ****
X  #endif /* OVLB */
X  #ifdef OVL0
X  
X! XSTATIC struct engr *
X  engr_at(x,y) register xchar x,y; {
X  register struct engr *ep = head_engr;
X  	while(ep) {
X--- 37,43 ----
X  #endif /* OVLB */
X  #ifdef OVL0
X  
X! STATIC_OVL struct engr *
X  engr_at(x,y) register xchar x,y; {
X  register struct engr *ep = head_engr;
X  	while(ep) {
X***************
X*** 182,187 ****
X--- 182,189 ----
X  freehand(){
X  	return(!uwep ||
X  	   !uwep->cursed ||
X+ 	   (uwep->olet != WEAPON_SYM && uwep->otyp != TIN_OPENER
X+ 		&& uwep->otyp != PICK_AXE && uwep->otyp != UNICORN_HORN) || 
X  	   (!bimanual(uwep) && (!uarms || !uarms->cursed)));
X  /*	if ((uwep && bimanual(uwep)) ||
X  	    (uwep && uarms))
X***************
X*** 190,198 ****
X  		return(1);*/
X  }
X  
X! static const char styluses[] = { '#', '-', TOOL_SYM, WEAPON_SYM, WAND_SYM, 0 };
X! static const char too_large[] = { ARMOR_SYM, BALL_SYM, ROCK_SYM, 0 };
X! static const char paper[] = { SCROLL_SYM,
X  #ifdef SPELLS
X  	SPBOOK_SYM,
X  #endif
X--- 192,200 ----
X  		return(1);*/
X  }
X  
X! static const char NEARDATA styluses[] = { '#', '-', TOOL_SYM, WEAPON_SYM, WAND_SYM, 0 };
X! static const char NEARDATA too_large[] = { ARMOR_SYM, BALL_SYM, ROCK_SYM, 0 };
X! static const char NEARDATA paper[] = { SCROLL_SYM,
X  #ifdef SPELLS
X  	SPBOOK_SYM,
X  #endif
X***************
X*** 612,618 ****
X  	}
X  }
X  
X! XSTATIC void
X  del_engr(ep) register struct engr *ep; {
X  register struct engr *ept;
X  	if(ep == head_engr)
X--- 614,620 ----
X  	}
X  }
X  
X! STATIC_OVL void
X  del_engr(ep) register struct engr *ep; {
X  register struct engr *ept;
X  	if(ep == head_engr)
X*** src/Old/extralev.c	Sun Jun  3 12:58:12 1990
X--- src/extralev.c	Sun Feb 25 14:47:26 1990
X***************
X*** 20,26 ****
X  #define LEFT 4
X  #define RIGHT 8
X  
X! static struct rogueroom r[3][3];
X  static void FDECL(roguejoin,(int,int,int,int,int));
X  static void FDECL(roguecorr,(int,int,int));
X  static void FDECL(miniwalk,(int,int));
X--- 20,26 ----
X  #define LEFT 4
X  #define RIGHT 8
X  
X! static struct rogueroom NEARDATA r[3][3];
X  static void FDECL(roguejoin,(int,int,int,int,int));
X  static void FDECL(roguecorr,(int,int,int));
X  static void FDECL(miniwalk,(int,int));
X*** src/Old/fountain.c	Sun Jun  3 12:58:29 1990
X--- src/fountain.c	Wed May 23 17:45:37 1990
X***************
X*** 18,24 ****
X  	register int num = rnd(6);
X  	if (!(mons[PM_WATER_MOCCASIN].geno & G_GENOD)) {
X  		if (!Blind)
X! 			pline("An endless stream of snakes pours forth!");
X  		else
X  			You("hear something hissing!");
X  		while(num-- > 0) (void) makemon(&mons[PM_WATER_MOCCASIN],u.ux,u.uy);
X--- 18,26 ----
X  	register int num = rnd(6);
X  	if (!(mons[PM_WATER_MOCCASIN].geno & G_GENOD)) {
X  		if (!Blind)
X! 			pline("An endless stream of %s pours forth!",
X! 				Hallucination ? makeplural(rndmonnam())
X! 				: "snakes");
X  		else
X  			You("hear something hissing!");
X  		while(num-- > 0) (void) makemon(&mons[PM_WATER_MOCCASIN],u.ux,u.uy);
X***************
X*** 116,122 ****
X  dofindgem() /* Find a gem in the sparkling waters. */ {
X  
X  	if (!Blind) You("spot a gem in the sparkling waters!");
X! 	(void) mkobj_at(GEM_SYM,u.ux,u.uy);
X  	levl[u.ux][u.uy].looted = T_LOOTED;
X  }
X  
X--- 118,124 ----
X  dofindgem() /* Find a gem in the sparkling waters. */ {
X  
X  	if (!Blind) You("spot a gem in the sparkling waters!");
X! 	(void) mksobj_at(rnd_class(DILITHIUM_CRYSTAL, LUCKSTONE-1), u.ux, u.uy);
X  	levl[u.ux][u.uy].looted = T_LOOTED;
X  }
X  
X***************
X*** 352,358 ****
X  		return;
X  	}
X  	switch(rn2(20)) {
X! 		static struct obj *otmp;
X  		case 0: You("take a sip of very cold water.");
X  			break;
X  		case 1: You("take a sip of very warm water.");
X--- 354,360 ----
X  		return;
X  	}
X  	switch(rn2(20)) {
X! 		static struct obj NEARDATA *otmp;
X  		case 0: You("take a sip of very cold water.");
X  			break;
X  		case 1: You("take a sip of very warm water.");
X***************
X*** 365,371 ****
X  		case 3: if (mons[PM_SEWER_RAT].geno & G_GENOD)
X  				pline("The sink seems quite dirty.");
X  			else {
X! 				static struct monst *mtmp;
X  
X  				mtmp = makemon(&mons[PM_SEWER_RAT], u.ux, u.uy);
X  				pline("Eek!  There's %s in the sink!",
X--- 367,373 ----
X  		case 3: if (mons[PM_SEWER_RAT].geno & G_GENOD)
X  				pline("The sink seems quite dirty.");
X  			else {
X! 				static struct monst NEARDATA *mtmp;
X  
X  				mtmp = makemon(&mons[PM_SEWER_RAT], u.ux, u.uy);
X  				pline("Eek!  There's %s in the sink!",
X***************
X*** 391,397 ****
X  			break;
X  		case 5: if (!levl[u.ux][u.uy].looted) {
X  			    You("find a ring in the sink!");
X! 			    (void) mkobj_at(RING_SYM, u.ux, u.uy);
X  			    levl[u.ux][u.uy].looted = T_LOOTED;
X  			} else pline("Some dirty water backs up in the drain.");
X  			break;
X--- 393,399 ----
X  			break;
X  		case 5: if (!levl[u.ux][u.uy].looted) {
X  			    You("find a ring in the sink!");
X! 			    (void) mkobj_at(RING_SYM, u.ux, u.uy, TRUE);
X  			    levl[u.ux][u.uy].looted = T_LOOTED;
X  			} else pline("Some dirty water backs up in the drain.");
X  			break;
X*** src/Old/getline.c	Sun Jun  3 12:58:49 1990
X--- src/getline.c	Fri Apr 13 18:45:39 1990
X***************
X*** 49,55 ****
X  		if((c = Getchar()) == EOF) {
X  			*bufp = 0;
X  #ifdef MACOS
X! 	macflags |= (tmpflags & fDoNonKeyEvt);
X  #endif
X  			return;
X  		}
X--- 49,55 ----
X  		if((c = Getchar()) == EOF) {
X  			*bufp = 0;
X  #ifdef MACOS
X! 	macflags = tmpflags;
X  #endif
X  			return;
X  		}
X***************
X*** 57,63 ****
X  			*obufp = c;
X  			obufp[1] = 0;
X  #ifdef MACOS
X! 	macflags |= (tmpflags & fDoNonKeyEvt);
X  #endif
X  			return;
X  		}
X--- 57,63 ----
X  			*obufp = c;
X  			obufp[1] = 0;
X  #ifdef MACOS
X! 	macflags = tmpflags;
X  #endif
X  			return;
X  		}
X***************
X*** 69,75 ****
X  		} else if(c == '\n') {
X  			*bufp = 0;
X  #ifdef MACOS
X! 	macflags |= (tmpflags & fDoNonKeyEvt);
X  #endif
X  			return;
X  		} else if(' ' <= c && c < '\177' && 
X--- 69,75 ----
X  		} else if(c == '\n') {
X  			*bufp = 0;
X  #ifdef MACOS
X! 	macflags = tmpflags;
X  #endif
X  			return;
X  		} else if(' ' <= c && c < '\177' && 
X***************
X*** 93,99 ****
X  			bell();
X  	}
X  #ifdef MACOS
X! 	macflags |= (tmpflags & fDoNonKeyEvt);
X  #endif
X  }
X  
X--- 93,99 ----
X  			bell();
X  	}
X  #ifdef MACOS
X! 	macflags = tmpflags;
X  #endif
X  }
X  
X***************
X*** 128,137 ****
X--- 128,143 ----
X  register const char *s;	/* chars allowed besides space or return */
X  {
X  	register int c;
X+ #ifdef MACOS
X+ 	short	tmpflags;
X+ #endif
X  
X  	morc = 0;
X  #ifdef MACOS
X  	flags.wantspace = TRUE;
X+ 	tmpflags = macflags;
X+ 	macflags &= ~fDoNonKeyEvt;
X+ 	HideCursor();
X  #endif
X  
X  	while((c = readchar()) != '\n') {
X***************
X*** 149,155 ****
X--- 155,163 ----
X  	}
X  
X  #ifdef MACOS
X+ 	ShowCursor();
X  	flags.wantspace = FALSE;
X+ 	macflags = tmpflags;
X  #endif
X  }
X  
X***************
X*** 156,162 ****
X  #endif /* OVL1 */
X  #ifdef OVL0
X  
X! static int last_multi;
X  
X  char *
X  parse()
X--- 164,170 ----
X  #endif /* OVL1 */
X  #ifdef OVL0
X  
X! static int NEARDATA last_multi;
X  
X  char *
X  parse()
X***************
X*** 293,298 ****
X--- 301,312 ----
X  	register char *obufp = bufp;
X  	register int c;
X  	int com_index, oindex;
X+ #ifdef MACOS
X+ 	short tmpflags;
X+ 	
X+ 	tmpflags = macflags & ~(fExtCmdSeq1 | fExtCmdSeq2 | fExtCmdSeq3);
X+ 	macflags &= ~fDoNonKeyEvt;
X+ #endif
X  
X  	flags.toplin = 2;		/* nonempty, no --More-- required */
X  
X***************
X*** 300,310 ****
X--- 314,330 ----
X  		(void) fflush(stdout);
X  		if((c = readchar()) == EOF) {
X  			*bufp = 0;
X+ #ifdef MACOS
X+ 			macflags = tmpflags;
X+ #endif
X  			return;
X  		}
X  		if(c == '\033') {
X  			*obufp = c;
X  			obufp[1] = 0;
X+ #ifdef MACOS
X+ 			macflags = tmpflags;
X+ #endif
X  			return;
X  		}
X  		if(c == erase_char || c == '\b') {
X***************
X*** 314,319 ****
X--- 334,342 ----
X  			} else	bell();
X  		} else if(c == '\n') {
X  			*bufp = 0;
X+ #ifdef MACOS
X+ 			macflags = tmpflags;
X+ #endif
X  			return;
X  		} else if(' ' <= c && c < '\177') {
X  				/* avoid isprint() - some people don't have it
X***************
X*** 355,360 ****
X--- 378,386 ----
X  		} else
X  			bell();
X  	}
X+ #ifdef MACOS
X+ 	macflags = tmpflags;
X+ #endif
X  
X  }
X  #endif /* COM_COMPL */
X*** src/Old/hack.c	Sun Jun  3 12:59:10 1990
X--- src/hack.c	Thu May 31 22:10:54 1990
X***************
X*** 7,18 ****
X  static	const char	SCCS_Id[] = "@(#)hack.c	3.0\t89/11/20";
X  #endif
X  
X! OSTATIC int NDECL(moverock);
X  #ifdef SINKS
X! OSTATIC void NDECL(dosinkfall);
X  #endif
X  static boolean FDECL(is_edge,(XCHAR_P,XCHAR_P));
X  static boolean FDECL(bad_rock,(XCHAR_P,XCHAR_P));
X  
X  #ifdef OVLB
X  
X--- 7,21 ----
X  static	const char	SCCS_Id[] = "@(#)hack.c	3.0\t89/11/20";
X  #endif
X  
X! STATIC_DCL int NDECL(moverock);
X  #ifdef SINKS
X! STATIC_DCL void NDECL(dosinkfall);
X  #endif
X+ 
X+ #ifdef OVL1
X  static boolean FDECL(is_edge,(XCHAR_P,XCHAR_P));
X  static boolean FDECL(bad_rock,(XCHAR_P,XCHAR_P));
X+ #endif /* OVL1 */
X  
X  #ifdef OVLB
X  
X***************
X*** 28,44 ****
X  
X  	if(seehx){
X  		seehx = 0;
X! 	} else
X! 	for(x = u.ux-1; x < u.ux+2; x++)
X! 	    for(y = u.uy-1; y < u.uy+2; y++) {
X! 		if(!isok(x, y)) continue;
X! 		lev = &levl[x][y];
X! 		if(!lev->lit && lev->scrsym == ROOM_SYM) {
X  			lev->scrsym = STONE_SYM;
X  			lev->new = 1;
X  			on_scr(x,y);
X! 		}
X! 	    }
X  }
X  
X  /* called:
X--- 31,54 ----
X  
X  	if(seehx){
X  		seehx = 0;
X! 	} 
X! 	/*
X! 	 *  Erase surrounding positions if needed.  We don't need to do this
X! 	 *  if we are blind, since we can't see them anyway.  This removes the
X! 	 *  pl6 bug that makes monsters disappear if they are next to you if
X! 	 *  you teleport while blind and telepathic.
X! 	 */
X! 	else if(!Blind)
X! 	    for(x = u.ux-1; x < u.ux+2; x++)
X! 	        for(y = u.uy-1; y < u.uy+2; y++) {
X! 		    if(!isok(x, y)) continue;
X! 		    lev = &levl[x][y];
X! 		    if(!lev->lit && lev->scrsym == ROOM_SYM) {
X  			lev->scrsym = STONE_SYM;
X  			lev->new = 1;
X  			on_scr(x,y);
X! 		    }
X! 	        }
X  }
X  
X  /* called:
X***************
X*** 87,96 ****
X  #endif /* OVLB */
X  #ifdef OVL2
X  
X! XSTATIC int
X  moverock() {
X  	register xchar rx, ry;
X! 	register struct obj *otmp;
X  	register struct trap *ttmp;
X  	register struct	monst *mtmp;
X  
X--- 97,106 ----
X  #endif /* OVLB */
X  #ifdef OVL2
X  
X! STATIC_OVL int
X  moverock() {
X  	register xchar rx, ry;
X! 	register struct obj *otmp, *otmp2;
X  	register struct trap *ttmp;
X  	register struct	monst *mtmp;
X  
X***************
X*** 172,177 ****
X--- 182,204 ----
X  				delobj(otmp);
X  				continue;
X  			}
X+ 				/*
X+ 				 * Re-link at top of fobj chain so that 
X+ 				 * pile order is preserved when level is 
X+ 				 * restored.
X+ 				 */
X+ 			if (otmp != fobj) {
X+ 				otmp2 = fobj;
X+ 				while (otmp2->nobj && otmp2->nobj != otmp) 
X+ 					otmp2 = otmp2->nobj;
X+ 				if (!otmp2->nobj)
X+ 				    impossible("moverock: error in fobj chain");
X+ 				else {
X+ 					otmp2->nobj = otmp->nobj;	
X+ 					otmp->nobj = fobj;
X+ 					fobj = otmp;
X+ 				}
X+ 			}
X  			move_object(otmp, rx, ry);
X  			/* pobj(otmp); */
X  			if(cansee(rx,ry)) atl(rx,ry,otmp->olet);
X***************
X*** 182,188 ****
X  			long lastmovetime;
X  			lastmovetime = 0;
X  #else
X! 			static long lastmovetime;
X  #endif
X  			/* note: this var contains garbage initially and
X  			   after a restore */
X--- 209,215 ----
X  			long lastmovetime;
X  			lastmovetime = 0;
X  #else
X! 			static long NEARDATA lastmovetime;
X  #endif
X  			/* note: this var contains garbage initially and
X  			   after a restore */
X***************
X*** 229,241 ****
X  register xchar ox, oy;
X  {
X  	remove_object(obj);
X! 	newsym(obj->ox, obj->oy);
X  	place_object(obj, ox, oy);
X! 	newsym(ox, oy);
X  }
X  
X  #ifdef SINKS
X! XSTATIC
X  void
X  dosinkfall() {
X  	register struct obj *obj;
X--- 256,276 ----
X  register xchar ox, oy;
X  {
X  	remove_object(obj);
X! 	if (cansee(obj->ox, obj->oy)) {
X! 		levl[obj->ox][obj->oy].seen = 0;
X! 		prl(obj->ox, obj->oy);
X! 	} else
X! 		newsym(obj->ox, obj->oy);
X  	place_object(obj, ox, oy);
X! 	if (cansee(ox, oy)) {
X! 		levl[ox][oy].seen = 0;
X! 		prl(ox, oy);
X! 	} else
X! 		newsym(ox, oy);
X  }
X  
X  #ifdef SINKS
X! STATIC_OVL
X  void
X  dosinkfall() {
X  	register struct obj *obj;
X***************
X*** 323,329 ****
X  
X  void
X  domove() {
X! 	register struct monst *mtmp = (struct monst *)0;
X  	register struct rm *tmpr,*ust;
X  	register xchar x,y;
X  	struct trap *trap;
X--- 358,364 ----
X  
X  void
X  domove() {
X! 	register struct monst *mtmp;
X  	register struct rm *tmpr,*ust;
X  	register xchar x,y;
X  	struct trap *trap;
X***************
X*** 393,400 ****
X  #endif
X  			}
X  		}
X! 		if (MON_AT(x, y)) {
X! 			mtmp = m_at(x,y);
X  			/* Don't attack if you're running */
X  			if (flags.run && !mtmp->mimic &&
X  				    (Blind ? Telepat :
X--- 428,435 ----
X  #endif
X  			}
X  		}
X! 		mtmp = m_at(x,y);
X! 		if (mtmp) {
X  			/* Don't attack if you're running */
X  			if (flags.run && !mtmp->mimic &&
X  				    (Blind ? Telepat :
X***************
X*** 548,554 ****
X  	}
X  #ifdef POLYSELF
X  	if (tunnels(uasmon) && !needspick(uasmon) && IS_ROCK(tmpr->typ)) {
X! 		static const char *digtxt;
X  
X  		if(dig_pos.x != x || dig_pos.y != y
X  		    || dig_level != dlevel || dig_down) {
X--- 583,589 ----
X  	}
X  #ifdef POLYSELF
X  	if (tunnels(uasmon) && !needspick(uasmon) && IS_ROCK(tmpr->typ)) {
X! 		static const char NEARDATA *digtxt;
X  
X  		if(dig_pos.x != x || dig_pos.y != y
X  		    || dig_level != dlevel || dig_down) {
X***************
X*** 755,769 ****
X  #endif
X  	if(Blind || flags.run == 0) return;
X  	for(x = u.ux-1; x <= u.ux+1; x++) for(y = u.uy-1; y <= u.uy+1; y++) {
X  #ifdef POLYSELF
X  		if(u.umonnum == PM_GRID_BUG && x != u.ux && y != u.uy) continue;
X  #endif
X  		if(x == u.ux && y == u.uy) continue;
X! 		if(MON_AT(x, y) && (mtmp = m_at(x,y)) && !mtmp->mimic &&
X  		    (!mtmp->minvis || See_invisible) && !mtmp->mundetected) {
X! 			if((flags.run != 1 && !mtmp->mtame) || (x == u.ux+u.dx && y == u.uy+u.dy))
X  				goto stop;
X! 		} else mtmp = 0;
X  		if(levl[x][y].typ == STONE) continue;
X  		if(x == u.ux-u.dx && y == u.uy-u.dy) continue;
X  		{
X--- 790,806 ----
X  #endif
X  	if(Blind || flags.run == 0) return;
X  	for(x = u.ux-1; x <= u.ux+1; x++) for(y = u.uy-1; y <= u.uy+1; y++) {
X+ 		if(!isok(x,y)) continue;
X  #ifdef POLYSELF
X  		if(u.umonnum == PM_GRID_BUG && x != u.ux && y != u.uy) continue;
X  #endif
X  		if(x == u.ux && y == u.uy) continue;
X! 		if((mtmp = m_at(x,y)) && !mtmp->mimic &&
X  		    (!mtmp->minvis || See_invisible) && !mtmp->mundetected) {
X! 			if((flags.run != 1 && !mtmp->mtame)
X! 					|| (x == u.ux+u.dx && y == u.uy+u.dy))
X  				goto stop;
X! 		}
X  		if(levl[x][y].typ == STONE) continue;
X  		if(x == u.ux-u.dx && y == u.uy-u.dy) continue;
X  		{
X***************
X*** 861,868 ****
X  	if(!Blind)
X  	for(x = u.ux-1; x <= u.ux+1; x++)
X  	    for(y = u.uy-1; y <= u.uy+1; y++) {
X  		if(x == u.ux && y == u.uy) continue;
X! 		if(MON_AT(x, y) && (mtmp = m_at(x,y)) && !mtmp->mimic &&
X  		   !mtmp->mtame && !mtmp->mpeaceful &&
X  		   !noattacks(mtmp->data) &&
X  		   mtmp->mcanmove && !mtmp->msleep &&  /* aplvax!jcn */
X--- 898,906 ----
X  	if(!Blind)
X  	for(x = u.ux-1; x <= u.ux+1; x++)
X  	    for(y = u.uy-1; y <= u.uy+1; y++) {
X+ 		if(!isok(x,y)) continue;
X  		if(x == u.ux && y == u.uy) continue;
X! 		if((mtmp = m_at(x,y)) && !mtmp->mimic &&
X  		   !mtmp->mtame && !mtmp->mpeaceful &&
X  		   !noattacks(mtmp->data) &&
X  		   mtmp->mcanmove && !mtmp->msleep &&  /* aplvax!jcn */
X***************
X*** 931,936 ****
X--- 969,975 ----
X  	} else {
X  		for(ux = u.ux-1; ux <= u.ux+1; ux++)
X  			for(uy = u.uy-1; uy <= u.uy+1; uy++) {
X+ 				if(!isok(ux,uy)) continue;
X  				if(IS_ROCK(levl[ux][uy].typ) ||
X  					IS_DOOR(levl[ux][uy].typ)) continue;
X  				/* might have side-by-side walls, in which case
X*** src/Old/invent.c	Sun Jun  3 12:59:53 1990
X--- src/invent.c	Thu May 31 22:11:37 1990
X***************
X*** 11,30 ****
X  
X  #define	NOINVSYM	'#'
X  
X  static boolean FDECL(mergable,(struct obj *,struct obj *));
X- OSTATIC void FDECL(assigninvlet,(struct obj *));
X  static int FDECL(merged,(struct obj *,struct obj *,int));
X! OSTATIC struct obj *FDECL(mkgoldobj,(long));
X! #ifndef OVERLAY
X! static int FDECL(ckunpaid,(struct obj *));
X! #else
X! int FDECL(ckunpaid,(struct obj *));
X! #endif
X  static boolean NDECL(wearing_armor);
X  static boolean FDECL(is_worn,(struct obj *));
X! static char FDECL(obj_to_let,(struct obj *));
X  
X! OSTATIC char *FDECL(xprname,(struct obj *,CHAR_P,BOOLEAN_P));
X  
X  #ifdef OVLB
X  
X--- 11,30 ----
X  
X  #define	NOINVSYM	'#'
X  
X+ #ifdef OVL1
X  static boolean FDECL(mergable,(struct obj *,struct obj *));
X  static int FDECL(merged,(struct obj *,struct obj *,int));
X! #endif /* OVL1 */
X! STATIC_DCL void FDECL(assigninvlet,(struct obj *));
X! STATIC_DCL struct obj *FDECL(mkgoldobj,(long));
X! STATIC_PTR int FDECL(ckunpaid,(struct obj *));
X! #ifdef OVLB
X  static boolean NDECL(wearing_armor);
X  static boolean FDECL(is_worn,(struct obj *));
X! #endif /* OVLB */
X! STATIC_DCL char FDECL(obj_to_let,(struct obj *));
X  
X! STATIC_DCL char *FDECL(xprname,(struct obj *,CHAR_P,BOOLEAN_P));
X  
X  #ifdef OVLB
X  
X***************
X*** 38,44 ****
X  	POTION_SYM, RING_SYM, WAND_SYM, TOOL_SYM, GEM_SYM,
X  	ROCK_SYM, BALL_SYM, CHAIN_SYM, 0 };
X  
X! XSTATIC void
X  assigninvlet(otmp)
X  register struct obj *otmp;
X  {
X--- 38,44 ----
X  	POTION_SYM, RING_SYM, WAND_SYM, TOOL_SYM, GEM_SYM,
X  	ROCK_SYM, BALL_SYM, CHAIN_SYM, 0 };
X  
X! STATIC_OVL void
X  assigninvlet(otmp)
X  register struct obj *otmp;
X  {
X***************
X*** 175,180 ****
X--- 175,183 ----
X  	}
X  }
X  
X+ #endif /* OVLB */
X+ #ifdef OVL3
X+ 
X  void
X  freeinv(obj)
X  register struct obj *obj;
X***************
X*** 202,207 ****
X--- 205,213 ----
X  	}
X  }
X  
X+ #endif /* OVL3 */
X+ #ifdef OVL2
X+ 
X  /* destroy object in fobj chain (if unpaid, it remains on the bill) */
X  void
X  delobj(obj)
X***************
X*** 272,278 ****
X  #endif
X  }
X  
X! #endif /* OVLB */
X  #ifdef OVL0
X  
X  struct obj *
X--- 278,284 ----
X  #endif
X  }
X  
X! #endif /* OVL2 */
X  #ifdef OVL0
X  
X  struct obj *
X***************
X*** 348,353 ****
X--- 354,362 ----
X  	return(FALSE);
X  }
X  
X+ #endif /* OVLB */
X+ #ifdef OVL2
X+ 
X  struct gold *
X  g_at(x,y)
X  register int x, y;
X***************
X*** 360,367 ****
X  	return((struct gold *)0);
X  }
X  
X  /* make dummy object structure containing gold - for temporary use only */
X! XSTATIC
X  struct obj *
X  mkgoldobj(q)
X  register long q;
X--- 369,379 ----
X  	return((struct gold *)0);
X  }
X  
X+ #endif /* OVL2 */
X+ #ifdef OVLB
X+ 
X  /* make dummy object structure containing gold - for temporary use only */
X! STATIC_OVL
X  struct obj *
X  mkgoldobj(q)
X  register long q;
X***************
X*** 497,502 ****
X--- 509,521 ----
X  		return((struct obj *)0);
X  	}
X  	for(;;) {
X+ #ifdef MACOS
X+ 		short	tmpflags;
X+ 		extern short macflags;
X+ 		
X+ 		tmpflags = macflags;
X+ 		macflags &= ~fDoNonKeyEvt;
X+ #endif
X  		if(!buf[0]) {
X  #ifdef REDO
X  		    if(!in_doagain)
X***************
X*** 520,525 ****
X--- 539,547 ----
X  			allowcnt = 2;	/* signal presence of cnt */
X  			ilet = readchar();
X  		}
X+ #ifdef MACOS
X+ 		macflags = tmpflags;
X+ #endif
X  		if(digit(ilet)) {
X  			pline("No count allowed with this command.");
X  			continue;
X***************
X*** 624,633 ****
X  #endif /* OVL1 */
X  #ifdef OVLB
X  
X! #ifndef OVERLAY
X! static 
X! #endif
X! int
X  ckunpaid(otmp)
X  register struct obj *otmp;
X  {
X--- 646,652 ----
X  #endif /* OVL1 */
X  #ifdef OVLB
X  
X! STATIC_PTR int
X  ckunpaid(otmp)
X  register struct obj *otmp;
X  {
X***************
X*** 650,656 ****
X      return(!!(otmp->owornmask & (W_ARMOR | W_RING | W_AMUL | W_TOOL | W_WEP)));
X  }
X  
X! static const char removeables[] =
X  	{ ARMOR_SYM, WEAPON_SYM, RING_SYM, AMULET_SYM, TOOL_SYM, ' ', 0 };
X  
X  /* interactive version of getobj - used for Drop, Identify and */
X--- 669,675 ----
X      return(!!(otmp->owornmask & (W_ARMOR | W_RING | W_AMUL | W_TOOL | W_WEP)));
X  }
X  
X! static const char NEARDATA removeables[] =
X  	{ ARMOR_SYM, WEAPON_SYM, RING_SYM, AMULET_SYM, TOOL_SYM, ' ', 0 };
X  
X  /* interactive version of getobj - used for Drop, Identify and */
X***************
X*** 821,827 ****
X  	return(cnt);
X  }
X  
X! static char
X  obj_to_let(obj)	/* should of course only be called for things in invent */
X  register struct obj *obj;
X  {
X--- 840,850 ----
X  	return(cnt);
X  }
X  
X! #endif /* OVLB */
X! #ifdef OVL2
X! 
X! STATIC_OVL
X! char
X  obj_to_let(obj)	/* should of course only be called for things in invent */
X  register struct obj *obj;
X  {
X***************
X*** 843,852 ****
X  	pline(xprname(obj, obj_to_let(obj), TRUE));
X  }
X  
X! #endif /* OVLB */
X  #ifdef OVL1
X  
X! XSTATIC char *
X  xprname(obj,let,dot)
X  register struct obj *obj;
X  register char let;
X--- 866,875 ----
X  	pline(xprname(obj, obj_to_let(obj), TRUE));
X  }
X  
X! #endif /* OVL2 */
X  #ifdef OVL1
X  
X! STATIC_OVL char *
X  xprname(obj,let,dot)
X  register struct obj *obj;
X  register char let;
X***************
X*** 1340,1345 ****
X--- 1363,1371 ----
X  	delobj(otmp);
X  }
X  
X+ #endif /* OVLB */
X+ #ifdef OVL1
X+ 
X  /*
X   * Convert from a symbol to a string for printing object classes
X   *
X***************
X*** 1350,1356 ****
X   *	WAND_SYM, [SPBOOK_SYM], RING_SYM, GEM_SYM, 0 };
X   */
X  
X! static const char *names[] = {
X  	"Illegal objects", "Amulets", "Comestibles", "Weapons",
X  	"Tools", "Iron balls", "Chains", "Boulders/Statues", "Armor",
X  	"Potions", "Scrolls", "Wands",
X--- 1376,1382 ----
X   *	WAND_SYM, [SPBOOK_SYM], RING_SYM, GEM_SYM, 0 };
X   */
X  
X! static const char NEARDATA *names[] = {
X  	"Illegal objects", "Amulets", "Comestibles", "Weapons",
X  	"Tools", "Iron balls", "Chains", "Boulders/Statues", "Armor",
X  	"Potions", "Scrolls", "Wands",
X***************
X*** 1365,1371 ****
X  {
X  	const char *pos = index(obj_symbols, let);
X  	/* arbitrary buffer size by Tom May (tom@uw-warp) */
X! 	static char *buf = NULL;
X  
X  	if (buf == NULL)
X  	    buf = (char *) alloc ((unsigned)(strlen(HI)+17+strlen(HE)));
X--- 1391,1397 ----
X  {
X  	const char *pos = index(obj_symbols, let);
X  	/* arbitrary buffer size by Tom May (tom@uw-warp) */
X! 	static char NEARDATA *buf = NULL;
X  
X  	if (buf == NULL)
X  	    buf = (char *) alloc ((unsigned)(strlen(HI)+17+strlen(HE)));
X***************
X*** 1382,1387 ****
X--- 1408,1416 ----
X  	    Sprintf(buf, "%s", names[pos - obj_symbols]);
X  	return (buf);
X  }
X+ 
X+ #endif /* OVL1 */
X+ #ifdef OVLB
X  
X  void
X  reassign()
X*** src/Old/ioctl.c	Sun Jun  3 13:00:40 1990
X--- src/ioctl.c	Tue May  8 19:14:56 1990
X***************
X*** 6,11 ****
X--- 6,12 ----
X     systems (e.g. MUNIX) the include files <termio.h> and <sgtty.h>
X     define the same constants, and the C preprocessor complains. */
X  
X+ #ifndef VMS
X  /* block some unused #defines to avoid overloading some cpp's */
X  #define MONATTK_H
X  #define MONFLAG_H
X***************
X*** 89,91 ****
X--- 90,93 ----
X  	return(0);
X  }
X  #endif /* SUSPEND /**/
X+ #endif /*VMS*/
X*** src/Old/lev_comp.l	Sun Jun  3 13:02:02 1990
X--- src/lev_comp.l	Wed Apr 25 17:07:32 1990
X***************
X*** 28,33 ****
X--- 28,34 ----
X  
X  #ifdef MSDOS
X  #undef exit
X+ extern void FDECL(exit, (int));
X  #endif
X  
X  /* this doesn't always get put in lev_comp.h
X*** src/Old/lev_comp.y	Sun Jun  3 13:02:18 1990
X--- src/lev_comp.y	Wed Apr 25 17:07:36 1990
X***************
X*** 49,54 ****
X--- 49,55 ----
X  
X  #ifdef MSDOS
X  # undef exit
X+ extern void FDECL(exit, (int));
X  #endif
X  
X  #ifdef MACOS
X*** src/Old/lev_main.c	Sun Jun  3 13:03:18 1990
X--- src/lev_main.c	Fri May 18 18:40:57 1990
X***************
X*** 9,19 ****
X  
X  /* #include "hack.h"	/* uncomment for the Mac */
X  
X! #ifdef AMIGA
X! #include "hack.h"
X! #undef exit
X! #endif
X  #include <stdio.h>
X  
X  #define MAX_ERRORS	25
X  
X--- 9,32 ----
X  
X  /* #include "hack.h"	/* uncomment for the Mac */
X  
X! #ifndef VMS
X! # if defined(AMIGA) || defined(MSDOS)
X! #  include "hack.h"
X! #  undef exit
X! #  ifdef MSDOS
X! extern void FDECL(exit, (int));
X! #  endif
X! # else
X! #  include <stdio.h>
X! # endif
X! #else  /*VMS*/
X! # ifdef ANCIENT_VAXC    /* need KR1ED setup */
X! #  define GLOBAL_H      /* don't need other stuff */
X! #include "config.h"
X! # endif
X  #include <stdio.h>
X+ # define exit vms_exit
X+ #endif /*VMS*/
X  
X  #define MAX_ERRORS	25
X  
X***************
X*** 59,67 ****
X  	long	j;
X  	extern struct permonst *mons;
X  	extern struct objclass *objects;
X  
X  	/* sub in the Nethack resource filename */
X! 	strcpy((char *)name, "\010NH3.rsrc");
X  	yysbuf = (char *)alloc(YYLMAX);
X  	yysptr = yysbuf;
X  	yytext = (char *)alloc(YYLMAX);
X--- 72,81 ----
X  	long	j;
X  	extern struct permonst *mons;
X  	extern struct objclass *objects;
X+ 	char descrip[3][32];    /* 3 special level description files */
X  
X  	/* sub in the Nethack resource filename */
X! 	Strcpy((char *)name, "\021nethack.proj.rsrc");
X  	yysbuf = (char *)alloc(YYLMAX);
X  	yysptr = yysbuf;
X  	yytext = (char *)alloc(YYLMAX);
X***************
X*** 92,99 ****
X  	} else {
X  		panic("Can't get OBJECT resource data.");
X  	}
X! # ifdef THINKC4
X! 	argc = ccommand(&argv);
X  # endif
X  #endif
X  
X--- 106,119 ----
X  	} else {
X  		panic("Can't get OBJECT resource data.");
X  	}
X!     Sprintf(descrip[1], "%s", ":auxil:castle.des");
X!     Sprintf(descrip[2], "%s", ":auxil:endgame.des");
X!     Sprintf(descrip[3], "%s", ":auxil:tower.des");
X!     argc = 4;    /* argv[0] is irrelevant, argv[i] = descrip[i] */
X! #else   /* !MACOS || !SMALLDATA */
X! # ifdef VMS
X!     extern FILE *yyin, *yyout;
X!     yyin = stdin,  yyout = stdout;
X  # endif
X  #endif
X  
X***************
X*** 101,107 ****
X  	    yyparse();
X  	else 			/* Otherwise every argument is a filename */
X  	    for(i=1; i<argc; i++) {
X! #if defined(VMS) || defined(AZTEC_C)
X  		    extern FILE *yyin;
X  		    yyin = fin = fopen(argv[i], "r");
X  #else
X--- 121,131 ----
X  	    yyparse();
X  	else 			/* Otherwise every argument is a filename */
X  	    for(i=1; i<argc; i++) {
X! #ifdef MACOS
X!                     argv[i] = descrip[i];
X!                     fprintf(stdout, "Working on %s\n", argv[i]);
X! #endif
X! #if defined(AZTEC_C)
X  		    extern FILE *yyin;
X  		    yyin = fin = fopen(argv[i], "r");
X  #else
X***************
X*** 115,121 ****
X--- 139,149 ----
X  		    line_number = 1;
X  		    fatal_error = 0;
X  	    }
X+ #ifndef VMS
X  	return 0;
X+ #else
X+ 	return 1;       /* vms success */
X+ #endif /*VMS*/
X  }
X  
X  /* 
X*** src/Old/lock.c	Sun Jun  3 13:03:34 1990
X--- src/lock.c	Thu May 31 22:10:57 1990
X***************
X*** 4,30 ****
X  
X  #include	"hack.h"
X  
X! #ifndef OVERLAY
X! static int NDECL(picklock);
X! static int NDECL(forcelock);
X! #else
X! int NDECL(picklock);
X! int NDECL(forcelock);
X! #endif
X! static boolean FDECL(obstructed,(int,int));
X  
X! VSTATIC struct xlock_s {
X  	int	door_or_box, picktyp;
X  	struct rm  *door;
X  	struct obj *box;
X  	int chance, usedtime;
X! } xlock;
X  
X  #ifdef OVLB
X  
X! #ifndef OVERLAY
X! static
X! #endif
X  int
X  picklock() {	/* try to open/close a lock */
X  
X--- 4,24 ----
X  
X  #include	"hack.h"
X  
X! STATIC_PTR int NDECL(picklock);
X! STATIC_PTR int NDECL(forcelock);
X  
X! STATIC_VAR struct xlock_s {
X  	int	door_or_box, picktyp;
X  	struct rm  *door;
X  	struct obj *box;
X  	int chance, usedtime;
X! } NEARDATA xlock;
X  
X  #ifdef OVLB
X  
X! static boolean FDECL(obstructed,(int,int));
X! 
X! STATIC_PTR
X  int
X  picklock() {	/* try to open/close a lock */
X  
X***************
X*** 87,95 ****
X  	return((xlock.usedtime = 0));
X  }
X  
X! #ifndef OVERLAY
X! static 
X! #endif
X  int
X  forcelock() {	/* try to force a locked chest */
X  
X--- 81,87 ----
X  	return((xlock.usedtime = 0));
X  }
X  
X! STATIC_PTR
X  int
X  forcelock() {	/* try to force a locked chest */
X  
X***************
X*** 252,258 ****
X  	    struct monst *mtmp;
X  
X  	    door = &levl[x][y];
X! 	    if (MON_AT(x, y) && canseemon(mtmp = m_at(x,y)) && !mtmp->mimic) {
X  		if (picktyp == CREDIT_CARD &&
X  #ifdef ORACLE
X  		    (mtmp->isshk || mtmp->data == &mons[PM_ORACLE]))
X--- 244,250 ----
X  	    struct monst *mtmp;
X  
X  	    door = &levl[x][y];
X! 	    if ((mtmp = m_at(x,y)) && canseemon(mtmp) && !mtmp->mimic) {
X  		if (picktyp == CREDIT_CARD &&
X  #ifdef ORACLE
X  		    (mtmp->isshk || mtmp->data == &mons[PM_ORACLE]))
X***************
X*** 395,401 ****
X  	y = u.uy + u.dy;
X  	if((x == u.ux) && (y == u.uy)) return(0);
X  
X! 	if(MON_AT(x, y) && (mtmp = m_at(x,y))->mimic &&
X  				mtmp->m_ap_type == M_AP_FURNITURE &&
X  				mtmp->mappearance == S_cdoor &&
X  				!Protection_from_shape_changers) {
X--- 387,393 ----
X  	y = u.uy + u.dy;
X  	if((x == u.ux) && (y == u.uy)) return(0);
X  
X! 	if((mtmp = m_at(x,y)) && mtmp->mimic &&
X  				mtmp->m_ap_type == M_AP_FURNITURE &&
X  				mtmp->mappearance == S_cdoor &&
X  				!Protection_from_shape_changers) {
X***************
X*** 484,490 ****
X  		return(1);
X  	}
X  
X! 	if(MON_AT(x, y) && (mtmp = m_at(x,y))->mimic &&
X  				mtmp->m_ap_type == M_AP_FURNITURE && 
X  				mtmp->mappearance == S_cdoor &&
X  				!Protection_from_shape_changers) {
X--- 476,482 ----
X  		return(1);
X  	}
X  
X! 	if((mtmp = m_at(x,y)) && mtmp->mimic &&
X  				mtmp->m_ap_type == M_AP_FURNITURE && 
X  				mtmp->mappearance == S_cdoor &&
X  				!Protection_from_shape_changers) {
X***************
X*** 702,708 ****
X  
X  int
X  bimanual(otmp) struct obj * otmp; {
X! 	return(otmp->olet == WEAPON_SYM && objects[otmp->otyp].oc_bimanual);
X  }
X  #endif /* STUPID_CPP */
X  
X--- 694,701 ----
X  
X  int
X  bimanual(otmp) struct obj * otmp; {
X! 	return((otmp->olet == WEAPON_SYM || otmp->otyp == UNICORN_HORN)
X! 		&& objects[otmp->otyp].oc_bimanual);
X  }
X  #endif /* STUPID_CPP */
X  
X*** src/Old/mail.c	Sun Jun  3 13:28:46 1990
X--- src/mail.c	Tue May  8 19:16:30 1990
X***************
X*** 120,126 ****
X  
X  # ifdef VMS
X  extern unsigned long pasteboard_id;
X! int broadcasts = 0;
X  #  define getmailstatus()
X  # endif /* VMS */
X  
X--- 120,126 ----
X  
X  # ifdef VMS
X  extern unsigned long pasteboard_id;
X! volatile int broadcasts = 0;
X  #  define getmailstatus()
X  # endif /* VMS */
X  
X***************
X*** 150,156 ****
X  		/* find location next to (fx,fy) closest to (tx,ty) */
X  		d1 = dist2(fx,fy,tx,ty);
X  		for(dx = -1; dx <= 1; dx++) for(dy = -1; dy <= 1; dy++)
X! 		    if((dx || dy) && 
X  		       !IS_STWALL(levl[fx+dx][fy+dy].typ)) {
X  			d2 = dist2(fx+dx,fy+dy,tx,ty);
X  			if(d2 < d1) {
X--- 150,156 ----
X  		/* find location next to (fx,fy) closest to (tx,ty) */
X  		d1 = dist2(fx,fy,tx,ty);
X  		for(dx = -1; dx <= 1; dx++) for(dy = -1; dy <= 1; dy++)
X! 		    if((dx || dy) && isok(fx+dx,fy+dy) && 
X  		       !IS_STWALL(levl[fx+dx][fy+dy].typ)) {
X  			d2 = dist2(fx+dx,fy+dy,tx,ty);
X  			if(d2 < d1) {
X***************
X*** 229,238 ****
X  newmail() {
X  	/* deliver a scroll of mail */
X  	register boolean invload =
X! 	((inv_weight() + (int)objects[SCR_MAIL].oc_weight) > 0 ||
X! 	 inv_cnt() >= 52 || Fumbling);
X! 	register struct monst *md = 
X! 	makemon(&mons[PM_MAIL_DAEMON], u.ux, u.uy);
X  
X  	if(!md)	return;
X  
X--- 229,237 ----
X  newmail() {
X  	/* deliver a scroll of mail */
X  	register boolean invload =
X! 		((inv_weight() + (int)objects[SCR_MAIL].oc_weight) > 0 ||
X! 			 inv_cnt() >= 52 || Fumbling);
X! 	register struct monst *md = makemon(&mons[PM_MAIL_DAEMON], u.ux, u.uy);
X  
X  	if(!md)	return;
X  
X***************
X*** 262,267 ****
X--- 261,267 ----
X  		/* set known and do prinv() */
X  		(void) identify(addinv(mksobj(SCR_MAIL,FALSE)));
X  	}
X+ # endif /* NO_MAILREADER */
X  
X  	/* disappear again */
X  	mdappear(md,TRUE);
X***************
X*** 272,278 ****
X  # ifdef VMS
X  	broadcasts--;
X  # endif
X- # endif /* NO_MAILREADER */
X  }
X  
X  #endif /* OVLB */
X--- 272,277 ----
X*** src/Old/makedefs.c	Sun Jun  3 13:29:07 1990
X--- src/makedefs.c	Mon May 28 09:38:30 1990
X***************
X*** 3,17 ****
X  /* makedefs.c - NetHack version 3.0 */
X  
X  
X- #define EXTERN_H
X  #include	"config.h"
X  #include	"permonst.h"
X  #include	"objclass.h"
X  #ifdef NULL
X  #undef NULL
X  #endif /* NULL */
X  #define NULL	((genericptr_t)0)
X  
X  #if !defined(LINT) && !defined(__GNULINT__)
X  static	const char	SCCS_Id[] = "@(#)makedefs.c\t3.0\t89/11/15";
X  #endif
X--- 3,23 ----
X  /* makedefs.c - NetHack version 3.0 */
X  
X  
X  #include	"config.h"
X  #include	"permonst.h"
X  #include	"objclass.h"
X+ #ifdef MACOS
X+ #include "patchlevel.h"
X+ #endif
X  #ifdef NULL
X  #undef NULL
X  #endif /* NULL */
X  #define NULL	((genericptr_t)0)
X  
X+ #if defined(VMS) && defined(__GNUC__)
X+ 	char *FDECL(ctime, (time_t *));
X+ #endif
X+ 
X  #if !defined(LINT) && !defined(__GNULINT__)
X  static	const char	SCCS_Id[] = "@(#)makedefs.c\t3.0\t89/11/15";
X  #endif
X***************
X*** 26,33 ****
X  # define RDMODE	"r"
X  # define WRMODE	"w"
X  #else
X! # define RDMODE  "r+"
X! # define WRMODE  "w+"
X  #endif
X  
X  #ifdef MACOS
X--- 32,44 ----
X  # define RDMODE	"r"
X  # define WRMODE	"w"
X  #else
X! # ifdef VMS
X! #  define RDMODE  "r"
X! #  define WRMODE  "w"
X! # else
X! #  define RDMODE  "r+"
X! #  define WRMODE  "w+"
X! # endif
X  #endif
X  
X  #ifdef MACOS
X***************
X*** 101,110 ****
X  void NDECL(save_resource);
X  #endif
X  
X! char *FDECL(limit, (char *,BOOLEAN_P));
X  
X  #if defined(SMALLDATA) && defined(MACOS)
X! OSErr FDECL(write_resource, (Handle, short, Str255, short));
X  # if defined(AZTEC) || defined(THINKC4)
X  int NDECL(getpid);
X  # endif
X--- 112,121 ----
X  void NDECL(save_resource);
X  #endif
X  
X! char *FDECL(limit, (char *,int));
X  
X  #if defined(SMALLDATA) && defined(MACOS)
X! OSErr FDECL(write_resource, (Handle, ResType, short, Str255, short));
X  # if defined(AZTEC) || defined(THINKC4)
X  int NDECL(getpid);
X  # endif
X***************
X*** 220,226 ****
X  	(void) fflush(stderr);
X  	exit(1);
X  /*NOTREACHED*/
X! #ifdef MSDOS
X  	return 0;
X  #endif
X  }
X--- 231,237 ----
X  	(void) fflush(stderr);
X  	exit(1);
X  /*NOTREACHED*/
X! #if defined(MSDOS) || defined(__GNULINT__)
X  	return 0;
X  #endif
X  }
X***************
X*** 235,240 ****
X--- 246,255 ----
X  #else
X  	Sprintf(tempfile, "makedefs.%d", getpid());
X  #endif
X+ /* an ugly hack to limit pid-extension to 3 digits */
X+ #ifdef OS2
X+ 	if (strlen(tempfile) > 12) tempfile[12] = '\0';
X+ #endif
X  	if(freopen(tempfile, WRMODE, stdout) == (FILE *)0) {
X  		perror(tempfile);
X  		exit(1);
X***************
X*** 313,319 ****
X  	(void) fclose(stdin);
X  	(void) fclose(stdout);
X  #ifdef MACOS
X! 	strcpy((char *)File, RUMOR_FILE);
X  	CtoPstr((char *)File);
X  	if(!GetVol(VolName, &vRef) && !GetFInfo(File, vRef, &info)){
X  		info.fdCreator = CREATOR;
X--- 328,334 ----
X  	(void) fclose(stdin);
X  	(void) fclose(stdout);
X  #ifdef MACOS
X! 	Strcpy((char *)File, RUMOR_FILE);
X  	CtoPstr((char *)File);
X  	if(!GetVol(VolName, &vRef) && !GetFInfo(File, vRef, &info)){
X  		info.fdCreator = CREATOR;
X***************
X*** 363,369 ****
X  #ifndef INFERNO
X  	boolean	skipping_demons = TRUE;
X  #endif
X! 	Sprintf(tempfile, "%s.base", DATA_FILE);
X  	if(freopen(tempfile, RDMODE, stdin) == (FILE *)0) {
X  		perror(tempfile);
X  		exit(1);
X--- 378,390 ----
X  #ifndef INFERNO
X  	boolean	skipping_demons = TRUE;
X  #endif
X! 	Sprintf(tempfile,
X! #ifdef OS2
X! 		"%s.bas",
X! #else
X! 		"%s.base",
X! #endif
X! 		DATA_FILE);
X  	if(freopen(tempfile, RDMODE, stdin) == (FILE *)0) {
X  		perror(tempfile);
X  		exit(1);
X***************
X*** 472,478 ****
X  char *
X  limit(name,pref)	/* limit a name to 30 characters length */
X  char	*name;
X! boolean	pref;
X  {
X  	(void) strncpy(temp, name, pref ? 26 : 30);
X  	temp[pref ? 26 : 30] = 0;
X--- 493,499 ----
X  char *
X  limit(name,pref)	/* limit a name to 30 characters length */
X  char	*name;
X! int	pref;
X  {
X  	(void) strncpy(temp, name, pref ? 26 : 30);
X  	temp[pref ? 26 : 30] = 0;
X***************
X*** 487,493 ****
X  #ifdef SPELLS
X  	int nspell = 0;
X  #endif
X! 	boolean prefix = 0;
X  	char let = '\0';
X  	boolean	sumerr = FALSE;
X  
X--- 508,514 ----
X  #ifdef SPELLS
X  	int nspell = 0;
X  #endif
X! 	int prefix = 0;
X  	char let = '\0';
X  	boolean	sumerr = FALSE;
X  
X***************
X*** 536,551 ****
X  			if(objects[i].oc_material == GLASS) {
X  			    Printf("/* #define\t%s\t%d */\n",
X  							objnam, i);
X! 			    continue;
X  			}
X  		    default:
X  			Printf("#define\t");
X  		}
X! 		Printf("%s\t%d\n", limit(objnam, prefix), i);
X  		prefix = 0;
X  
X  		sum += objects[i].oc_prob;
X  	}
X  	Printf("#define\tLAST_GEM\t(JADE+1)\n");
X  #ifdef SPELLS
X  	Printf("#define\tMAXSPELL\t%d\n", nspell+1);
X--- 557,583 ----
X  			if(objects[i].oc_material == GLASS) {
X  			    Printf("/* #define\t%s\t%d */\n",
X  							objnam, i);
X! 			    prefix = -1;
X! 			    break;
X  			}
X  		    default:
X  			Printf("#define\t");
X  		}
X! 		if (prefix >= 0)
X! 			Printf("%s\t%d\n", limit(objnam, prefix), i);
X  		prefix = 0;
X  
X  		sum += objects[i].oc_prob;
X  	}
X+ 
X+ 	/* check last set of probabilities */
X+ 	if (sum && sum != 1000) {
X+ 	    (void) fprintf(stderr,
X+ 			"prob error for %c (%d%%)", let, sum);
X+ 	    (void) fflush(stderr);
X+ 	    sumerr = TRUE;
X+ 	}
X+ 
X  	Printf("#define\tLAST_GEM\t(JADE+1)\n");
X  #ifdef SPELLS
X  	Printf("#define\tMAXSPELL\t%d\n", nspell+1);
X***************
X*** 622,629 ****
X  void
X  do_monst()
X  {
X! 	Handle	monstData, objData;
X! 	short i,j;
X  	pmstr	*pmMonst;
X  	SFReply	reply;
X  	short	refNum,error;
X--- 654,662 ----
X  void
X  do_monst()
X  {
X! 	Handle	monstData, objData, versData;
X! 	char versStr[32], *vstr = VERSION;
X! 	short i, j, patlev = PATCHLEVEL;
X  	pmstr	*pmMonst;
X  	SFReply	reply;
X  	short	refNum,error;
X***************
X*** 655,677 ****
X  	}
X  	PtrToHand((Ptr)objects, &objData, ((i+1)*sizeof(struct objclass)));
X  
X! 	strcpy((char *)&name[0], "\010NH3.rsrc");
X  	if (findNamedFile(&name[1], 0, &reply)) {
X! 	    strncpy((char *)&name[0],(char *)&reply.fName[0], reply.fName[0]+1);
X  	    if ((refNum = OpenResFile(name)) != -1) {
X  		if (ResError() == noErr) {
X! 		    strcpy((char *)&name[0], "\012MONST_DATA");
X! 		    if (error = write_resource(monstData,
X  						MONST_DATA, name, refNum)) {
X  			SysBeep(1);
X  			Printf("Couldn't add monster data resource.\n");
X  		    }
X! 		    strcpy((char *)&name[0], "\013OBJECT_DATA");
X! 		    if (error = write_resource(objData,
X  						OBJECT_DATA, name, refNum)) {
X  			SysBeep(1);
X  			Printf("Couldn't add object data resource.\n");
X  		    }
X  		    CloseResFile(refNum);
X  		    if (ResError() != noErr) {
X  			SysBeep(1);
X--- 688,721 ----
X  	}
X  	PtrToHand((Ptr)objects, &objData, ((i+1)*sizeof(struct objclass)));
X  
X! 	/* place a small string in the creator resource to identify version */
X! 	Sprintf(versStr, "n%s patchlevel%2d", vstr, patlev);
X! 	*versStr = (int)strlen(VERSION) + 13;  /* n = actual string length */
X! 	PtrToHand(versStr, &versData, sizeof(versStr));
X! 
X! 	Strcpy((char *)&name[0], "\021nethack.proj.rsrc");
X  	if (findNamedFile(&name[1], 0, &reply)) {
X! 	    (void)strncpy((char *)&name[0],(char *)&reply.fName[0], reply.fName[0]+1);
X  	    if ((refNum = OpenResFile(name)) != -1) {
X  		if (ResError() == noErr) {
X! 		    Strcpy((char *)&name[0], "\012MONST_DATA");
X! 		    if (error = write_resource(monstData, HACK_DATA,
X  						MONST_DATA, name, refNum)) {
X  			SysBeep(1);
X  			Printf("Couldn't add monster data resource.\n");
X  		    }
X! 		    Strcpy((char *)&name[0], "\013OBJECT_DATA");
X! 		    if (error = write_resource(objData, HACK_DATA,
X  						OBJECT_DATA, name, refNum)) {
X  			SysBeep(1);
X  			Printf("Couldn't add object data resource.\n");
X  		    }
X+ 		    Strcpy((char *)&name[0], "\000");
X+ 		    if (error = write_resource(versData, CREATOR,
X+ 						0, name, refNum)) {
X+ 			SysBeep(1);
X+ 			Printf("Couldn't add creator info resource.\n");
X+ 		    }
X  		    CloseResFile(refNum);
X  		    if (ResError() != noErr) {
X  			SysBeep(1);
X***************
X*** 735,752 ****
X  
X  
X  OSErr
X! write_resource(data, resID, resName, refNum)
X  Handle	data;
X  short	resID;
X  Str255	resName;
X  short	refNum;
X  {
X- 	ResType	theType;
X  	short	error;
X  	Handle	theRes;
X  
X-     theType = HACK_DATA;
X-     error = CurResFile();
X      if (theRes = GetResource(theType, resID)) {
X  		RmveResource(theRes);
X  		error = ResError();
X--- 779,794 ----
X  
X  
X  OSErr
X! write_resource(data, theType, resID, resName, refNum)
X  Handle	data;
X+ ResType	theType;
X  short	resID;
X  Str255	resName;
X  short	refNum;
X  {
X  	short	error;
X  	Handle	theRes;
X  
X      if (theRes = GetResource(theType, resID)) {
X  		RmveResource(theRes);
X  		error = ResError();
X
END_OF_FILE
if test 50662 -ne `wc -c <'patch8.03'`; then
    echo shar: \"'patch8.03'\" unpacked with wrong size!
fi
# end of 'patch8.03'
fi
echo shar: End of archive 9 \(of 24\).
cp /dev/null ark9isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 24 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
