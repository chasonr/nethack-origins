Path: utzoo!utgpu!watserv1!watmath!att!rutgers!uwm.edu!ogicse!zephyr.ens.tek.com!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v10i024:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Patch8f
Message-ID: <5732@tekred.CNA.TEK.COM>
Date: 5 Jun 90 17:52:29 GMT
Sender: news@tekred.CNA.TEK.COM
Lines: 2132
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 10, Issue 24
Archive-name: NetHack3/Patch8f
Patch-To: NetHack3: Volume 7, Issue 56-93



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 6 (of 24)."
# Contents:  patch8.07
# Wrapped by billr@saab on Mon Jun  4 15:27:16 1990
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'patch8.07' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'patch8.07'\"
else
echo shar: Extracting \"'patch8.07'\" \(52827 characters\)
sed "s/^X//" >'patch8.07' <<'END_OF_FILE'
X*** src/Old/prisym.c	Sun Jun  3 14:06:29 1990
X--- src/prisym.c	Sun May 27 11:54:49 1990
X***************
X*** 8,14 ****
X  #include "wseg.h"
X  #include "lev.h"
X  
X! OSTATIC void FDECL(pwseg, (struct wseg *));
X  #endif
X  
X  #ifdef OVL0
X--- 8,14 ----
X  #include "wseg.h"
X  #include "lev.h"
X  
X! STATIC_DCL void FDECL(pwseg, (struct wseg *));
X  #endif
X  
X  #ifdef OVL0
X***************
X*** 66,74 ****
X  uchar let;
X  uchar col;
X  #else
X! static schar prevx, prevy;
X! static uchar let;
X! static uchar col;
X  #endif
X  
X  	switch ((int)x) {
X--- 66,74 ----
X  uchar let;
X  uchar col;
X  #else
X! static schar NEARDATA prevx, NEARDATA prevy;
X! static uchar NEARDATA let;
X! static uchar NEARDATA col;
X  #endif
X  
X  	switch ((int)x) {
X***************
X*** 115,125 ****
X  uchar col;
X  # endif
X  #else
X! static uchar let;
X! static xchar cnt;
X! static coord tc[COLNO];	/* but watch reflecting beams! */
X  # ifdef TEXTCOLOR
X! static uchar col;
X  # endif
X  #endif
X  register int xx,yy;
X--- 115,125 ----
X  uchar col;
X  # endif
X  #else
X! static uchar NEARDATA let;
X! static xchar NEARDATA cnt;
X! static coord NEARDATA tc[COLNO];	/* but watch reflecting beams! */
X  # ifdef TEXTCOLOR
X! static uchar NEARDATA col;
X  # endif
X  #endif
X  register int xx,yy;
X***************
X*** 573,579 ****
X  }
X  
X  #ifdef WORM
X! XSTATIC void
X  pwseg(wtmp)
X  register struct wseg *wtmp;
X  {
X--- 573,579 ----
X  }
X  
X  #ifdef WORM
X! STATIC_OVL void
X  pwseg(wtmp)
X  register struct wseg *wtmp;
X  {
X*** src/Old/read.c	Sun Jun  3 14:06:55 1990
X--- src/read.c	Thu May 31 22:13:33 1990
X***************
X*** 8,21 ****
X  
X  boolean	known;
X  
X! static const char readable[] = { '#', SCROLL_SYM,
X  #ifdef SPELLS
X  	SPBOOK_SYM,
X  #endif
X  	0 };
X  
X- #endif /* OVLB */
X- 
X  static void FDECL(explode, (struct obj *));
X  static void NDECL(do_class_genocide);
X  static void FDECL(stripspe,(struct obj *));
X--- 8,19 ----
X  
X  boolean	known;
X  
X! static const char NEARDATA readable[] = { '#', SCROLL_SYM,
X  #ifdef SPELLS
X  	SPBOOK_SYM,
X  #endif
X  	0 };
X  
X  static void FDECL(explode, (struct obj *));
X  static void NDECL(do_class_genocide);
X  static void FDECL(stripspe,(struct obj *));
X***************
X*** 23,29 ****
X  static void FDECL(p_glow2,(struct obj *,const char *));
X  static void FDECL(recharge,(struct obj *,int));
X  static void FDECL(forget,(BOOLEAN_P));
X! OSTATIC void FDECL(show_map_spot,(int,int));
X  
X  #ifdef OVLB
X  
X--- 21,30 ----
X  static void FDECL(p_glow2,(struct obj *,const char *));
X  static void FDECL(recharge,(struct obj *,int));
X  static void FDECL(forget,(BOOLEAN_P));
X! 
X! #endif /* OVLB */
X! 
X! STATIC_DCL void FDECL(show_map_spot,(int,int));
X  
X  #ifdef OVLB
X  
X***************
X*** 571,577 ****
X  		register struct monst *mtmp;
X  
X  		for(i = -bd; i <= bd; i++) for(j = -bd; j <= bd; j++)
X! 		if(MON_AT(u.ux+i, u.uy+j) && (mtmp = m_at(u.ux+i, u.uy+j))) {
X  		    if(sobj->cursed) {
X  			if(!mtmp->mtame) mtmp->mpeaceful = 0;
X  		    } else {
X--- 572,578 ----
X  		register struct monst *mtmp;
X  
X  		for(i = -bd; i <= bd; i++) for(j = -bd; j <= bd; j++)
X! 		if(isok(u.ux+i, u.uy+j) && (mtmp = m_at(u.ux+i, u.uy+j))) {
X  		    if(sobj->cursed) {
X  			if(!mtmp->mtame) mtmp->mpeaceful = 0;
X  		    } else {
X***************
X*** 656,661 ****
X--- 657,669 ----
X  	case SCR_CHARGING:
X  		if (confused) {
X  		    You("feel charged up!");
X+ #ifdef SPELLS
X+ 		    if (u.uen < u.uenmax)
X+ 			u.uen = u.uenmax;
X+ 		    else
X+ 			u.uen = u.uenmax + d(5,4);
X+ 		    flags.botl = 1;
X+ #endif
X  		    break;
X  		}
X  		known = TRUE;
X***************
X*** 908,914 ****
X  				if(mtmp->data == &mons[i])
X  				    mondead(mtmp);
X  			    }
X! 			} else if (mons[i].geno & G_GENOD)
X  			    pline("All %s are already nonexistent.", n);
X  			else
X  			    You("aren't permitted to genocide %s%s.",
X--- 916,923 ----
X  				if(mtmp->data == &mons[i])
X  				    mondead(mtmp);
X  			    }
X! 			} else if ((mons[i].geno & G_GENOD) &&
X! 			  !(mons[i].geno & G_UNIQ))
X  			    pline("All %s are already nonexistent.", n);
X  			else
X  			    You("aren't permitted to genocide %s%s.",
X***************
X*** 1016,1023 ****
X  	} else {
X  	    pline("Sent in some %s.", makeplural(buf));
X  	    j = rnd(3) + 3;
X! 	    for(i=1; i<=j; i++)
X! 		(void) makemon(ptr, u.ux, u.uy);
X  	}
X  }
X  
X--- 1025,1039 ----
X  	} else {
X  	    pline("Sent in some %s.", makeplural(buf));
X  	    j = rnd(3) + 3;
X! 	    for(i=1; i<=j; i++) {
X! 		struct monst *mmon = makemon(ptr, u.ux, u.uy);
X! 		struct obj *otmp;
X! 
X! 		while(otmp = (mmon->minvent)) {
X! 			mmon->minvent = otmp->nobj;
X! 			free((genericptr_t)otmp);
X! 		}
X! 	    }
X  	}
X  }
X  
X***************
X*** 1024,1030 ****
X  #endif /* OVLB */
X  #ifdef OVL0
X  
X! XSTATIC void
X  show_map_spot(x, y)
X  register int x, y;
X  {
X--- 1040,1046 ----
X  #endif /* OVLB */
X  #ifdef OVL0
X  
X! STATIC_OVL void
X  show_map_spot(x, y)
X  register int x, y;
X  {
X***************
X*** 1161,1168 ****
X  		uball->owt += 15 * (1 + sobj->cursed);
X  		return;
X  	}
X! 	setworn(mkobj_at(CHAIN_SYM, u.ux, u.uy), W_CHAIN);
X! 	setworn(mkobj_at(BALL_SYM, u.ux, u.uy), W_BALL);
X  	uball->spe = 1;		/* special ball (see save) */
X  }
X  
X--- 1177,1184 ----
X  		uball->owt += 15 * (1 + sobj->cursed);
X  		return;
X  	}
X! 	setworn(mkobj_at(CHAIN_SYM, u.ux, u.uy, TRUE), W_CHAIN);
X! 	setworn(mkobj_at(BALL_SYM, u.ux, u.uy, TRUE), W_BALL);
X  	uball->spe = 1;		/* special ball (see save) */
X  }
X  
X*** src/Old/restore.c	Sun Jun  3 14:07:40 1990
X--- src/restore.c	Wed May 23 17:55:45 1990
X***************
X*** 9,19 ****
X  #include "wseg.h"
X  #endif
X  
X  boolean restoring = FALSE;
X  #ifdef TUTTI_FRUTTI
X! static struct fruit *oldfruit;
X  #endif
X! static long omoves;
X  
X  /*
X   * "stuff" objects back into containers (relink the fcobj list).
X--- 9,28 ----
X  #include "wseg.h"
X  #endif
X  
X+ static void FDECL(stuff_objs, (struct obj *));
X+ static void NDECL(find_lev_obj);
X+ #ifndef NO_SIGNAL
X+ static void NDECL(inven_inuse);
X+ #endif
X+ static struct obj * FDECL(restobjchn, (int,BOOLEAN_P));
X+ static struct monst * FDECL(restmonchn, (int,BOOLEAN_P));
X+ static void FDECL(restgenoinfo, (int));
X+ 
X  boolean restoring = FALSE;
X  #ifdef TUTTI_FRUTTI
X! static struct fruit NEARDATA *oldfruit;
X  #endif
X! static long NEARDATA omoves;
X  
X  /*
X   * "stuff" objects back into containers (relink the fcobj list).
X***************
X*** 148,154 ****
X  	off_t differ;
X  
X  	mread(fd, (genericptr_t)&monbegin, sizeof(monbegin));
X! #if !defined(MSDOS) && !defined(M_XENIX) && !defined(THINKC4) && !defined(HPUX)
X  	differ = (genericptr_t)(&mons[0]) - (genericptr_t)(monbegin);
X  #else
X  	differ = (long)(&mons[0]) - (long)(monbegin);
X--- 157,163 ----
X  	off_t differ;
X  
X  	mread(fd, (genericptr_t)&monbegin, sizeof(monbegin));
X! #if !defined(MSDOS) && !defined(M_XENIX) && !defined(THINKC4) && !defined(HPUX) && !defined(VAXC)
X  	differ = (genericptr_t)(&mons[0]) - (genericptr_t)(monbegin);
X  #else
X  	differ = (long)(&mons[0]) - (long)(monbegin);
X***************
X*** 167,173 ****
X  		mread(fd, (genericptr_t) mtmp, (unsigned) xl + sizeof(struct monst));
X  		if(!mtmp->m_id)
X  			mtmp->m_id = flags.ident++;
X! #if !defined(MSDOS) && !defined(M_XENIX) && !defined(THINKC4) && !defined(HPUX)
X  		/* ANSI type for differ is ptrdiff_t --
X  		 * long may be wrong for segmented architecture --
X  		 * may be better to cast pointers to (struct permonst *)
X--- 176,182 ----
X  		mread(fd, (genericptr_t) mtmp, (unsigned) xl + sizeof(struct monst));
X  		if(!mtmp->m_id)
X  			mtmp->m_id = flags.ident++;
X! #if !defined(MSDOS) && !defined(M_XENIX) && !defined(THINKC4) && !defined(HPUX) && !defined(VAXC)
X  		/* ANSI type for differ is ptrdiff_t --
X  		 * long may be wrong for segmented architecture --
X  		 * may be better to cast pointers to (struct permonst *)
X***************
X*** 218,228 ****
X  #ifdef TUTTI_FRUTTI
X  	struct fruit *fruit;
X  #endif
X- #ifdef MSDOS
X  	struct flag oldflags;
X  
X! 	oldflags = flags;	/* Save flags set in the config file */
X! #endif
X  #ifdef ZEROCOMP
X  	minit();
X  #endif
X--- 227,236 ----
X  #ifdef TUTTI_FRUTTI
X  	struct fruit *fruit;
X  #endif
X  	struct flag oldflags;
X  
X! 	oldflags = flags;
X! 
X  #ifdef ZEROCOMP
X  	minit();
X  #endif
X***************
X*** 249,268 ****
X  		return(0);
X  	    }
X  	mread(fd, (genericptr_t) &flags, sizeof(struct flag));
X! 	/* Some config file OPTIONS take precedence over those in save file.
X  	 */
X! #ifdef MSDOS
X! #ifdef DGK
X  	flags.rawio = oldflags.rawio;
X- #ifdef DECRAINBOW
X- 	flags.DECRainbow = oldflags.DECRainbow;
X- #endif /* DECRAINBOW */
X  	flags.IBMBIOS = oldflags.IBMBIOS;
X  #endif
X  #ifdef TEXTCOLOR
X  	flags.use_color = oldflags.use_color;
X  #endif
X! #endif /* MSDOS */
X  	mread(fd, (genericptr_t) &dlevel, sizeof dlevel);
X  	mread(fd, (genericptr_t) &maxdlevel, sizeof maxdlevel);
X  	mread(fd, (genericptr_t) &moves, sizeof moves);
X--- 257,275 ----
X  		return(0);
X  	    }
X  	mread(fd, (genericptr_t) &flags, sizeof(struct flag));
X! 	/* Some config file and command line OPTIONS take precedence over
X! 	 * those in save file.
X  	 */
X! 	flags.DECgraphics = oldflags.DECgraphics;
X! 	flags.IBMgraphics = oldflags.IBMgraphics;
X! #if defined(MSDOS) && defined(DGK)
X  	flags.rawio = oldflags.rawio;
X  	flags.IBMBIOS = oldflags.IBMBIOS;
X  #endif
X  #ifdef TEXTCOLOR
X  	flags.use_color = oldflags.use_color;
X  #endif
X! 
X  	mread(fd, (genericptr_t) &dlevel, sizeof dlevel);
X  	mread(fd, (genericptr_t) &maxdlevel, sizeof maxdlevel);
X  	mread(fd, (genericptr_t) &moves, sizeof moves);
X***************
X*** 758,771 ****
X  	  for(mtmp = fmon; mtmp; mtmp = mtmp2) {
X  
X  		mtmp2 = mtmp->nmon;
X! 		if(mtmp->data->geno & G_GENOD) {
X! #ifdef KOPS
X! 			allow_kops = FALSE;
X! #endif
X! 			mondead(mtmp);
X! #ifdef KOPS
X! 			allow_kops = TRUE;
X! #endif
X  			continue;
X  		}
X  
X--- 765,784 ----
X  	  for(mtmp = fmon; mtmp; mtmp = mtmp2) {
X  
X  		mtmp2 = mtmp->nmon;
X! 		if((mtmp->data->geno&G_GENOD) && !(mtmp->data->geno&G_UNIQ)) {
X! 			/* mondead() would try to link the monster's objects
X! 			 * into fobj and the appropriate nexthere chain.
X! 			 * unfortunately, such things will not have sane
X! 			 * values until after find_lev_obj() well below
X! 			 * here, so we'd go chasing random pointers if we
X! 			 * tried that.  we could save the monster's objects
X! 			 * in another chain and insert them in the level
X! 			 * later, but that's a lot of work for very little
X! 			 * gain.  hence, just throw the objects away via
X! 			 * mongone() and pretend the monster wandered off
X! 			 * somewhere private before the genocide.
X! 			 */
X! 			mongone(mtmp);
X  			continue;
X  		}
X  
X***************
X*** 874,884 ****
X  #ifdef ZEROCOMP
X  #define RLESC '\0' 	/* Leading character for run of RLESC's */
X  
X! static unsigned char inbuf[BUFSZ];
X! static unsigned short inbufp = 0;
X! static unsigned short inbufsz = 0;
X! static short inrunlength = -1;
X! static int mreadfd;
X  
X  static int
X  mgetc()
X--- 887,898 ----
X  #ifdef ZEROCOMP
X  #define RLESC '\0' 	/* Leading character for run of RLESC's */
X  
X! static unsigned char NEARDATA inbuf[BUFSZ];
X! static unsigned short NEARDATA inbufp = 0;
X! static unsigned short NEARDATA inbufsz = 0;
X! static short NEARDATA inrunlength = -1;
X! static int NEARDATA mreadfd;
X! static int NDECL(mgetc);
X  
X  static int
X  mgetc()
X*** src/Old/rip.c	Sun Jun  3 14:08:20 1990
X--- src/rip.c	Wed Mar 21 19:41:27 1990
X***************
X*** 3,9 ****
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X  #include "hack.h"
X- #include <ctype.h>
X  
X  static void FDECL(center,(int,char *));
X  
X--- 3,8 ----
X*** src/Old/rumors.c	Sun Jun  3 14:08:43 1990
X--- src/rumors.c	Fri Mar 30 20:55:17 1990
X***************
X*** 23,29 ****
X--- 23,31 ----
X   * (but not terminated) by "-----" lines.
X   */
X  static void NDECL(init_rumors);
X+ #ifdef ORACLE
X  static void NDECL(outoracle);
X+ #endif
X  long first_rumor = sizeof(long);
X  long true_rumor_size, false_rumor_size, end_rumor_file;
X  #ifdef ORACLE
X*** src/Old/save.c	Sun Jun  3 14:08:59 1990
X--- src/save.c	Sat May 26 13:21:15 1990
X***************
X*** 14,26 ****
X  #ifndef NO_SIGNAL
X  #include <signal.h>
X  #endif /* !NO_SIGNAL */
X! #if defined(EXPLORE_MODE) && !defined(LSC) && !defined(O_RDONLY) && !defined(AZTEC_C)
X  #include <fcntl.h>
X  #endif /* EXPLORE_MODE */
X  
X  boolean hu;		/* set during hang-up */
X  
X! #if defined(DGK)
X  struct finfo fileinfo[MAXLEVEL+1];
X  long bytes_counted;
X  int count_only;
X--- 14,26 ----
X  #ifndef NO_SIGNAL
X  #include <signal.h>
X  #endif /* !NO_SIGNAL */
X! #if defined(EXPLORE_MODE) && !defined(LSC) && !defined(O_WRONLY) && !defined(AZTEC_C)
X  #include <fcntl.h>
X  #endif /* EXPLORE_MODE */
X  
X  boolean hu;		/* set during hang-up */
X  
X! #ifdef DGK
X  struct finfo fileinfo[MAXLEVEL+1];
X  long bytes_counted;
X  int count_only;
X***************
X*** 28,46 ****
X  boolean level_exists[MAXLEVEL+1];
X  #endif
X  
X! #if defined(DGK)
X! static void savelev0();
X  #endif /* DGK */
X! static void saveobjchn();
X! static void savemonchn();
X! static void savegoldchn();
X! static void savetrapchn();
X! static void savegenoinfo();
X! #if defined(DGK)
X! static boolean swapout_oldest();
X! static void copyfile();
X! #endif /* defined(DGK) */
X! static void spill_objs();
X  #ifdef __GNULINT__
X  static long nulls[10];
X  #else
X--- 28,47 ----
X  boolean level_exists[MAXLEVEL+1];
X  #endif
X  
X! #ifdef ZEROCOMP
X! static void FDECL(bputc, (UCHAR_P));
X! #endif
X! static void FDECL(saveobjchn, (int,struct obj *));
X! static void FDECL(savemonchn, (int,struct monst *));
X! static void FDECL(savegoldchn, (int,struct gold *));
X! static void FDECL(savetrapchn, (int,struct trap *));
X! static void FDECL(savegenoinfo, (int));
X! #ifdef DGK
X! static void FDECL(savelev0, (int,XCHAR_P));
X! static boolean NDECL(swapout_oldest);
X! static void FDECL(copyfile, (char *,char *));
X  #endif /* DGK */
X! static void FDECL(spill_objs, (struct obj *));
X  #ifdef __GNULINT__
X  static long nulls[10];
X  #else
X***************
X*** 93,99 ****
X  	register int fd, ofd;
X  	int tmp;		/* not register ! */
X  	xchar ltmp;
X! #if defined(DGK)
X  	long fds, needed;
X  	int mode;
X  #endif
X--- 94,100 ----
X  	register int fd, ofd;
X  	int tmp;		/* not register ! */
X  	xchar ltmp;
X! #ifdef DGK
X  	long fds, needed;
X  	int mode;
X  #endif
X***************
X*** 158,189 ****
X  	{
X  		Str255	fileName;
X  		OSErr	er;
X! 		OSType	fileType;
X! 		Point	where;
X! 		SFReply	reply;
X! 		char	*prompt;
X  		
X! 		savenum = 0;
X! 		(void)GetVol(&fileName, &tmp);
X  		Strcpy((char *)&fileName[1], SAVEF);
X  		fileName[0] = strlen(SAVEF);
X! 		where.h = where.v =
X! 		    (SCREEN_BITS.bounds.bottom - SCREEN_BITS.bounds.top) / 4;
X! 		prompt = "\022Save character in:";
X! 		SFPutFile(where, prompt, fileName, 0L, &reply);
X! 		if (reply.good) {
X! 			SetVol(0L, savenum = reply.vRefNum);
X! 			strncpy(SAVEF, (char *)&reply.fName[1],
X! 					(short)reply.fName[0]);
X! 			SAVEF[(short)reply.fName[0]] = '\0';
X! 			Strcpy((char *)fileName, (char *)reply.fName);
X! 		}
X! 		
X! 		fileType = (discover == TRUE) ? EXPLORE_TYPE : SAVE_TYPE;
X! 		if (er = Create(&fileName, 0, CREATOR, fileType))
X  			SysBeep(1);
X  	}
X- 	fd = open(SAVEF, O_WRONLY | O_BINARY);
X  # else
X  	fd = creat(SAVEF, FCMASK);
X  # endif /* MACOS */
X--- 159,178 ----
X  	{
X  		Str255	fileName;
X  		OSErr	er;
X! 		struct term_info	*t;
X! 		extern WindowPtr	HackWindow;
X  		
X! 		t = (term_info *)GetWRefCon(HackWindow);
X! 		(void)GetVol(&fileName,&tmp);	/* tmp is old volume */
X! 		(void)SetVol(0L, savenum = t->recordVRefNum);	/* savenum is used below */
X  		Strcpy((char *)&fileName[1], SAVEF);
X  		fileName[0] = strlen(SAVEF);
X! 
X! 		if (er = Create(&fileName, 0, CREATOR, discover ? EXPLORE_TYPE : SAVE_TYPE))
X  			SysBeep(1);
X+ 		fd = open(SAVEF, O_WRONLY | O_BINARY);
X+ 		(void)SetVol(0L, t->system.sysVRefNum);
X  	}
X  # else
X  	fd = creat(SAVEF, FCMASK);
X  # endif /* MACOS */
X***************
X*** 193,209 ****
X  #ifdef AMIGA_WBENCH
X  		ami_wbench_unlink(SAVEF);
X  #endif
X  		(void) unlink(SAVEF);		/* ab@unido */
X- 		return(0);
X- 	}
X  #ifdef MACOS
X! 	(void)SetVol(0L,tmp);
X  #endif
X  	if(flags.moonphase == FULL_MOON)	/* ut-sally!fletcher */
X  		change_luck(-1);		/* and unido!ab */
X  	home();
X  	cl_end();
X! #if defined(DGK)
X  	if(!hu) msmsg("Saving: ");
X  	mode = COUNT;
X  again:
X--- 182,201 ----
X  #ifdef AMIGA_WBENCH
X  		ami_wbench_unlink(SAVEF);
X  #endif
X+ #ifdef MACOS
X+ 		(void)SetVol(0L, savenum);
X+ #endif
X  		(void) unlink(SAVEF);		/* ab@unido */
X  #ifdef MACOS
X! 		(void)SetVol(0L, tmp);
X  #endif
X+ 		return(0);
X+ 	}
X  	if(flags.moonphase == FULL_MOON)	/* ut-sally!fletcher */
X  		change_luck(-1);		/* and unido!ab */
X  	home();
X  	cl_end();
X! #ifdef DGK
X  	if(!hu) msmsg("Saving: ");
X  	mode = COUNT;
X  again:
X***************
X*** 261,267 ****
X  	savefruitchn(fd);
X  #endif
X  	savenames(fd);
X! #if defined(DGK)
X  	if (mode == COUNT) {
X  # ifdef ZEROCOMP
X  		bflush(fd);
X--- 253,259 ----
X  	savefruitchn(fd);
X  #endif
X  	savenames(fd);
X! #ifdef DGK
X  	if (mode == COUNT) {
X  # ifdef ZEROCOMP
X  		bflush(fd);
X***************
X*** 294,300 ****
X  	}
X  #endif
X  	for(ltmp = (xchar)1; ltmp <= maxdlevel; ltmp++) {
X! #if defined(DGK)
X  		if (ltmp == dlevel || !fileinfo[ltmp].where) continue;
X  		if (fileinfo[ltmp].where != ACTIVE)
X  			swapin_file(ltmp);
X--- 286,292 ----
X  	}
X  #endif
X  	for(ltmp = (xchar)1; ltmp <= maxdlevel; ltmp++) {
X! #ifdef DGK
X  		if (ltmp == dlevel || !fileinfo[ltmp].where) continue;
X  		if (fileinfo[ltmp].where != ACTIVE)
X  			swapin_file(ltmp);
X***************
X*** 315,320 ****
X--- 307,315 ----
X  			(void)SetVol(0L, savenum);
X  #endif
X  		    (void) unlink(SAVEF);
X+ #ifdef MACOS
X+ 			(void)SetVol(0L, tmp);
X+ #endif
X  #ifdef AMIGA_WBENCH
X  		    ami_wbench_unlink(SAVEF);
X  #endif
X***************
X*** 327,333 ****
X  		getlev(ofd, hackpid, ltmp, FALSE);
X  		(void) close(ofd);
X  		bwrite(fd, (genericptr_t) &ltmp, sizeof ltmp);  /* level number */
X! #if defined(DGK)
X  		savelev(fd, ltmp, WRITE);			/* actual level */
X  #else
X  		savelev(fd, ltmp);			/* actual level */
X--- 322,328 ----
X  		getlev(ofd, hackpid, ltmp, FALSE);
X  		(void) close(ofd);
X  		bwrite(fd, (genericptr_t) &ltmp, sizeof ltmp);  /* level number */
X! #ifdef DGK
X  		savelev(fd, ltmp, WRITE);			/* actual level */
X  #else
X  		savelev(fd, ltmp);			/* actual level */
X***************
X*** 355,364 ****
X  #ifdef AMIGA_WBENCH
X  	ami_wbench_iconwrite(SAVEF);
X  #endif
X  	return(1);
X  }
X  
X! #if defined(DGK)
X  boolean
X  savelev(fd, lev, mode)
X  int fd;
X--- 350,362 ----
X  #ifdef AMIGA_WBENCH
X  	ami_wbench_iconwrite(SAVEF);
X  #endif
X+ #ifdef MACOS
X+ 	(void)SetVol(0L, tmp);
X+ #endif
X  	return(1);
X  }
X  
X! #ifdef DGK
X  boolean
X  savelev(fd, lev, mode)
X  int fd;
X***************
X*** 404,410 ****
X  xchar lev;
X  {
X  #ifdef WORM
X! 	register struct wseg *wtmp;
X  	register int tmp;
X  #endif
X  #ifdef TOS
X--- 402,408 ----
X  xchar lev;
X  {
X  #ifdef WORM
X! 	register struct wseg *wtmp, *wtmp2;
X  	register int tmp;
X  #endif
X  #ifdef TOS
X***************
X*** 412,418 ****
X  #endif
X  
X  	if(fd < 0) panic("Save on bad file!");	/* impossible */
X! #if !defined(DGK)
X  	if(lev >= 0 && lev <= MAXLEVEL)
X  		level_exists[lev] = TRUE;
X  #endif
X--- 410,416 ----
X  #endif
X  
X  	if(fd < 0) panic("Save on bad file!");	/* impossible */
X! #ifndef DGK
X  	if(lev >= 0 && lev <= MAXLEVEL)
X  		level_exists[lev] = TRUE;
X  #endif
X***************
X*** 490,499 ****
X  #ifdef WORM
X  	bwrite(fd,(genericptr_t) wsegs,sizeof(wsegs));
X  	for(tmp=1; tmp<32; tmp++){
X! 		for(wtmp = wsegs[tmp]; wtmp; wtmp = wtmp->nseg){
X  			bwrite(fd,(genericptr_t) wtmp,sizeof(struct wseg));
X  		}
X! #if defined(DGK)
X  		if (!count_only)
X  #endif
X  			wsegs[tmp] = 0;
X--- 488,502 ----
X  #ifdef WORM
X  	bwrite(fd,(genericptr_t) wsegs,sizeof(wsegs));
X  	for(tmp=1; tmp<32; tmp++){
X! 		for(wtmp = wsegs[tmp]; wtmp; wtmp = wtmp2){
X! 			wtmp2 = wtmp->nseg;
X  			bwrite(fd,(genericptr_t) wtmp,sizeof(struct wseg));
X+ #ifdef DGK
X+ 			if (!count_only)
X+ #endif
X+ 				free((genericptr_t) wtmp);
X  		}
X! #ifdef DGK
X  		if (!count_only)
X  #endif
X  			wsegs[tmp] = 0;
X***************
X*** 500,506 ****
X  	}
X  	bwrite(fd,(genericptr_t) wgrowtime,sizeof(wgrowtime));
X  #endif /* WORM /**/
X! #if defined(DGK)
X  	if (count_only)	return;
X  #endif
X  	billobjs = 0;
X--- 503,509 ----
X  	}
X  	bwrite(fd,(genericptr_t) wgrowtime,sizeof(wgrowtime));
X  #endif /* WORM /**/
X! #ifdef DGK
X  	if (count_only)	return;
X  #endif
X  	billobjs = 0;
X***************
X*** 515,524 ****
X  #define RLESC '\0'    /* Leading character for run of LRESC's */
X  #define flushoutrun(ln) bputc(RLESC); bputc(ln); ln = -1;
X  
X! static unsigned char outbuf[BUFSZ];
X! static unsigned short outbufp = 0;
X! static short outrunlength = -1;
X! static int bwritefd;
X  
X  /*dbg()
X  {
X--- 518,527 ----
X  #define RLESC '\0'    /* Leading character for run of LRESC's */
X  #define flushoutrun(ln) bputc(RLESC); bputc(ln); ln = -1;
X  
X! static unsigned char NEARDATA outbuf[BUFSZ];
X! static unsigned short NEARDATA outbufp = 0;
X! static short NEARDATA outrunlength = -1;
X! static int NEARDATA bwritefd;
X  
X  /*dbg()
X  {
X***************
X*** 549,555 ****
X  	  flushoutrun(outrunlength);
X        }
X        if (outbufp) {
X! #if defined(DGK)
X  	  if (!count_only)    /* flush buffer */
X  #endif
X  		  (void) write(fd, outbuf, outbufp);
X--- 552,558 ----
X  	  flushoutrun(outrunlength);
X        }
X        if (outbufp) {
X! #ifdef DGK
X  	  if (!count_only)    /* flush buffer */
X  #endif
X  		  (void) write(fd, outbuf, outbufp);
X***************
X*** 587,593 ****
X  register genericptr_t loc;
X  register unsigned num;
X  {
X! #if defined(DGK)
X  	bytes_counted += num;
X  	if (!count_only)
X  #endif
X--- 590,596 ----
X  register genericptr_t loc;
X  register unsigned num;
X  {
X! #ifdef DGK
X  	bytes_counted += num;
X  	if (!count_only)
X  #endif
X***************
X*** 620,626 ****
X  	    xl = otmp->onamelth;
X  	    bwrite(fd, (genericptr_t) &xl, sizeof(int));
X  	    bwrite(fd, (genericptr_t) otmp, xl + sizeof(struct obj));
X! #if defined(DGK)
X  	    if (!count_only)
X  #endif
X  		free((genericptr_t) otmp);
X--- 623,629 ----
X  	    xl = otmp->onamelth;
X  	    bwrite(fd, (genericptr_t) &xl, sizeof(int));
X  	    bwrite(fd, (genericptr_t) otmp, xl + sizeof(struct obj));
X! #ifdef DGK
X  	    if (!count_only)
X  #endif
X  		free((genericptr_t) otmp);
X***************
X*** 647,653 ****
X  		bwrite(fd, (genericptr_t) &xl, sizeof(int));
X  		bwrite(fd, (genericptr_t) mtmp, xl + sizeof(struct monst));
X  		if(mtmp->minvent) saveobjchn(fd,mtmp->minvent);
X! #if defined(DGK)
X  		if (!count_only)
X  #endif
X  		free((genericptr_t) mtmp);
X--- 650,656 ----
X  		bwrite(fd, (genericptr_t) &xl, sizeof(int));
X  		bwrite(fd, (genericptr_t) mtmp, xl + sizeof(struct monst));
X  		if(mtmp->minvent) saveobjchn(fd,mtmp->minvent);
X! #ifdef DGK
X  		if (!count_only)
X  #endif
X  		free((genericptr_t) mtmp);
X***************
X*** 665,671 ****
X  	while(gold) {
X  		gold2 = gold->ngold;
X  		bwrite(fd, (genericptr_t) gold, sizeof(struct gold));
X! #if defined(DGK)
X  		if (!count_only)
X  #endif
X  			free((genericptr_t) gold);
X--- 668,674 ----
X  	while(gold) {
X  		gold2 = gold->ngold;
X  		bwrite(fd, (genericptr_t) gold, sizeof(struct gold));
X! #ifdef DGK
X  		if (!count_only)
X  #endif
X  			free((genericptr_t) gold);
X***************
X*** 683,689 ****
X  	while(trap) {
X  		trap2 = trap->ntrap;
X  		bwrite(fd, (genericptr_t) trap, sizeof(struct trap));
X! #if defined(DGK)
X  		if (!count_only)
X  #endif
X  			free((genericptr_t) trap);
X--- 686,692 ----
X  	while(trap) {
X  		trap2 = trap->ntrap;
X  		bwrite(fd, (genericptr_t) trap, sizeof(struct trap));
X! #ifdef DGK
X  		if (!count_only)
X  #endif
X  			free((genericptr_t) trap);
X***************
X*** 710,716 ****
X  		if (f1->fid >= 0) {
X  			bwrite(fd, (genericptr_t) f1, sizeof(struct fruit));
X  		}
X! #if defined(DGK)
X  		if (!count_only)
X  #endif
X  			free((genericptr_t) f1);
X--- 713,719 ----
X  		if (f1->fid >= 0) {
X  			bwrite(fd, (genericptr_t) f1, sizeof(struct fruit));
X  		}
X! #ifdef DGK
X  		if (!count_only)
X  #endif
X  			free((genericptr_t) f1);
X***************
X*** 730,736 ****
X  		bwrite(fd, (genericptr_t) &(mons[i].geno), sizeof(unsigned));
X  }
X  
X! #if defined(DGK)
X  boolean
X  swapin_file(lev)
X  int lev;
X--- 733,739 ----
X  		bwrite(fd, (genericptr_t) &(mons[i].geno), sizeof(unsigned));
X  }
X  
X! #ifdef DGK
X  boolean
X  swapin_file(lev)
X  int lev;
X***************
X*** 744,755 ****
X  	while (fileinfo[lev].size > freediskspace(to))
X  		if (!swapout_oldest())
X  			return FALSE;
X! #ifdef WIZARD
X  	if (wizard) {
X  		pline("Swapping in `%s'", from);
X  		(void) fflush(stdout);
X  	}
X! #endif
X  	copyfile(from, to);
X  	(void) unlink(from);
X  	fileinfo[lev].where = ACTIVE;
X--- 747,758 ----
X  	while (fileinfo[lev].size > freediskspace(to))
X  		if (!swapout_oldest())
X  			return FALSE;
X! # ifdef WIZARD
X  	if (wizard) {
X  		pline("Swapping in `%s'", from);
X  		(void) fflush(stdout);
X  	}
X! # endif
X  	copyfile(from, to);
X  	(void) unlink(from);
X  	fileinfo[lev].where = ACTIVE;
X***************
X*** 776,787 ****
X  	Sprintf(to, "%s%s", permbones, alllevels);
X  	name_file(from, oldest);
X  	name_file(to, oldest);
X! #ifdef WIZARD
X  	if (wizard) {
X  		pline("Swapping out `%s'.", from);
X  		(void) fflush(stdout);
X  	}
X! #endif
X  	copyfile(from, to);
X  	(void) unlink(from);
X  	fileinfo[oldest].where = SWAPPED;
X--- 779,790 ----
X  	Sprintf(to, "%s%s", permbones, alllevels);
X  	name_file(from, oldest);
X  	name_file(to, oldest);
X! # ifdef WIZARD
X  	if (wizard) {
X  		pline("Swapping out `%s'.", from);
X  		(void) fflush(stdout);
X  	}
X! # endif
X  	copyfile(from, to);
X  	(void) unlink(from);
X  	fileinfo[oldest].where = SWAPPED;
X***************
X*** 793,803 ****
X  copyfile(from, to)
X  char *from, *to;
X  {
X! #ifdef TOS
X  
X  	if (_copyfile(from, to))
X  		panic("Can't copy %s to %s\n", from, to);
X! #else
X  	char buf[BUFSIZ];
X  	int nfrom, nto, fdfrom, fdto;
X  
X--- 796,806 ----
X  copyfile(from, to)
X  char *from, *to;
X  {
X! # ifdef TOS
X  
X  	if (_copyfile(from, to))
X  		panic("Can't copy %s to %s\n", from, to);
X! # else
X  	char buf[BUFSIZ];
X  	int nfrom, nto, fdfrom, fdto;
X  
X***************
X*** 813,819 ****
X  	} while (nfrom == BUFSIZ);
X  	(void) close(fdfrom);
X  	(void) close(fdto);
X! #endif /* TOS */
X  }
X  #endif
X  
X--- 816,822 ----
X  	} while (nfrom == BUFSIZ);
X  	(void) close(fdfrom);
X  	(void) close(fdto);
X! # endif /* TOS */
X  }
X  #endif
X  
X*** src/Old/search.c	Sun Jun  3 14:09:33 1990
X--- src/search.c	Thu May 31 22:13:35 1990
X***************
X*** 7,15 ****
X  #  include "artifact.h"
X  #endif
X  
X- static void FDECL(findone,(XCHAR_P,XCHAR_P,int *));
X- 
X  #ifdef OVLB
X  
X  static void
X  findone(zx,zy,num)
X--- 7,15 ----
X  #  include "artifact.h"
X  #endif
X  
X  #ifdef OVLB
X+ 
X+ static void FDECL(findone,(XCHAR_P,XCHAR_P,int *));
X  
X  static void
X  findone(zx,zy,num)
X*** src/Old/shk.c	Sun Jun  3 14:09:51 1990
X--- src/shk.c	Sat Jun  2 19:44:59 1990
X***************
X*** 8,16 ****
X  
X  #include "eshk.h"
X  
X! #ifdef KOPS
X! static int FDECL(makekops, (coord *));
X  static void NDECL(kops_gone);
X  #endif /* KOPS */
X  
X  #define	NOTANGRY(mon)	mon->mpeaceful
X--- 8,19 ----
X  
X  #include "eshk.h"
X  
X! 
X! # ifdef KOPS
X! STATIC_DCL int FDECL(makekops, (coord *));
X! # ifdef OVLB
X  static void NDECL(kops_gone);
X+ # endif /* OVLB */
X  #endif /* KOPS */
X  
X  #define	NOTANGRY(mon)	mon->mpeaceful
X***************
X*** 18,37 ****
X  
X  /* Descriptor of current shopkeeper. Note that the bill need not be
X     per-shopkeeper, since it is valid only when in a shop. */
X! VSTATIC struct monst *shopkeeper;
X! VSTATIC struct bill_x *bill;
X! VSTATIC int shlevel;		/* level of this shopkeeper */
X  /* struct obj *billobjs;	/* objects on bill with bp->useup */
X  				/* only accessed here and by save & restore */
X! VSTATIC long int total; 	/* filled by addupbill() */
X! VSTATIC long int followmsg;	/* last time of follow message */
X  
X! static void setpaid(), FDECL(findshk, (int));
X! static int FDECL(dopayobj, (struct bill_x *)), FDECL(getprice, (struct obj *));
X! static struct obj *FDECL(bp_to_obj, (struct bill_x *));
X  
X  #ifdef OVLB
X  
X  /*
X  	invariants: obj->unpaid iff onbill(obj) [unless bp->useup]
X  		obj->quan <= bp->bquan
X--- 21,49 ----
X  
X  /* Descriptor of current shopkeeper. Note that the bill need not be
X     per-shopkeeper, since it is valid only when in a shop. */
X! STATIC_VAR struct monst NEARDATA *shopkeeper;
X! STATIC_VAR struct bill_x NEARDATA *bill;
X! STATIC_VAR int NEARDATA shlevel; /* level of this shopkeeper */
X  /* struct obj *billobjs;	/* objects on bill with bp->useup */
X  				/* only accessed here and by save & restore */
X! STATIC_VAR long int NEARDATA total; 	/* filled by addupbill() */
X! STATIC_VAR long int NEARDATA followmsg;	/* last time of follow message */
X  
X! STATIC_DCL void NDECL(setpaid);
X! STATIC_DCL void NDECL(addupbill);
X! STATIC_DCL boolean FDECL(monstinroom, (struct permonst *,int));
X! STATIC_DCL void FDECL(findshk, (int));
X  
X  #ifdef OVLB
X  
X+ static struct bill_x * FDECL(onbill, (struct obj *));
X+ static long FDECL(check_credit, (long,struct monst *));
X+ static void FDECL(pay, (long,struct monst *));
X+ static unsigned FDECL(get_cost, (struct obj *));
X+ static unsigned FDECL(cost_per_charge, (struct obj *));
X+ static int FDECL(dopayobj, (struct bill_x *)), FDECL(getprice, (struct obj *));
X+ static struct obj *FDECL(bp_to_obj, (struct bill_x *));
X+ 
X  /*
X  	invariants: obj->unpaid iff onbill(obj) [unless bp->useup]
X  		obj->quan <= bp->bquan
X***************
X*** 69,75 ****
X  	}
X  }
X  
X! static void
X  setpaid(){	/* caller has checked that shopkeeper exists */
X  		/* either we paid or left the shop or he just died */
X  	register struct obj *obj;
X--- 81,87 ----
X  	}
X  }
X  
X! STATIC_OVL void
X  setpaid(){	/* caller has checked that shopkeeper exists */
X  		/* either we paid or left the shop or he just died */
X  	register struct obj *obj;
X***************
X*** 97,103 ****
X  	}
X  }
X  
X! static void
X  addupbill(){	/* delivers result in total */
X  		/* caller has checked that shopkeeper exists */
X  	register int ct = ESHK(shopkeeper)->billct;
X--- 109,115 ----
X  	}
X  }
X  
X! STATIC_OVL void
X  addupbill(){	/* delivers result in total */
X  		/* caller has checked that shopkeeper exists */
X  	register int ct = ESHK(shopkeeper)->billct;
X***************
X*** 109,116 ****
X  	}
X  }
X  
X  #endif /* OVLB */
X! #ifdef OVL2
X  
X  int
X  inshop() {
X--- 121,141 ----
X  	}
X  }
X  
X+ STATIC_OVL boolean
X+ monstinroom(mdat,roomno)
X+ struct permonst *mdat;
X+ int roomno;
X+ {
X+ 	register struct monst *mtmp;
X+ 
X+ 	for(mtmp = fmon; mtmp; mtmp = mtmp->nmon)
X+ 		if(mtmp->data == mdat && inroom(mtmp->mx,mtmp->my) == roomno)
X+ 			return(TRUE);
X+ 	return(FALSE);
X+ }
X+ 
X  #endif /* OVLB */
X! #ifdef OVL1
X  
X  int
X  inshop() {
X***************
X*** 205,214 ****
X  		    break;
X  #ifdef ARMY
X  		case BARRACKS:
X! 		    if(!((mons[PM_SOLDIER].geno & G_GENOD) &&
X! 		         (mons[PM_SERGEANT].geno & G_GENOD) &&
X! 		         (mons[PM_LIEUTENANT].geno & G_GENOD) &&
X! 		         (mons[PM_CAPTAIN].geno & G_GENOD)))
X  		    	You("enter a military barracks!");
X  		    else You("enter an abandoned barracks.");
X  		    break;
X--- 230,239 ----
X  		    break;
X  #ifdef ARMY
X  		case BARRACKS:
X! 		    if(monstinroom(&mons[PM_SOLDIER], roomno) ||
X! 			    monstinroom(&mons[PM_SERGEANT], roomno) ||
X! 			    monstinroom(&mons[PM_LIEUTENANT], roomno) ||
X! 			    monstinroom(&mons[PM_CAPTAIN], roomno))
X  		    	You("enter a military barracks!");
X  		    else You("enter an abandoned barracks.");
X  		    break;
X***************
X*** 215,222 ****
X  #endif
X  #ifdef ORACLE
X  		case DELPHI:
X! 		    if(!(mons[PM_ORACLE].geno & G_GENOD))
X! 		        pline("\"Hello, %s, welcome to Delphi!\"", plname);
X  		    break;
X  #endif
X  		default:
X--- 240,247 ----
X  #endif
X  #ifdef ORACLE
X  		case DELPHI:
X! 		    if(monstinroom(&mons[PM_ORACLE], roomno))
X! 			    pline("\"Hello, %s, welcome to Delphi!\"", plname);
X  		    break;
X  #endif
X  		default:
X***************
X*** 294,300 ****
X  	return (int)u.uinshop;
X  }
X  
X! #endif /* OVL2 */
X  #ifdef OVLB
X  
X  int
X--- 319,325 ----
X  	return (int)u.uinshop;
X  }
X  
X! #endif /* OVL1 */
X  #ifdef OVLB
X  
X  int
X***************
X*** 305,310 ****
X--- 330,336 ----
X  		ESHK(mtmp)->shoplevel == dlevel));
X  }
X  
X+ #ifdef SOUNDS
X  boolean
X  tended_shop(sroom)
X  struct mkroom *sroom;
X***************
X*** 316,323 ****
X  		&& inhishop(mtmp)) return(TRUE);
X  	return(FALSE);
X  }
X  
X! static void
X  findshk(roomno)
X  register int roomno;
X  {
X--- 342,350 ----
X  		&& inhishop(mtmp)) return(TRUE);
X  	return(FALSE);
X  }
X+ #endif
X  
X! STATIC_OVL void
X  findshk(roomno)
X  register int roomno;
X  {
X***************
X*** 671,677 ****
X  /* routine called after dying (or quitting) with nonempty bill or upset shk */
X  boolean
X  paybill(){
X! 	register struct monst *mtmp;
X  	register long loss = 0L;
X  	register struct obj *otmp;
X  	register xchar ox, oy;
X--- 698,704 ----
X  /* routine called after dying (or quitting) with nonempty bill or upset shk */
X  boolean
X  paybill(){
X! 	register struct monst *mtmp, *mtmp2;
X  	register long loss = 0L;
X  	register struct obj *otmp;
X  	register xchar ox, oy;
X***************
X*** 678,691 ****
X  	register boolean take = FALSE;
X  	register boolean taken = FALSE;
X  
X! 	for(mtmp = fmon; mtmp; mtmp = mtmp->nmon)
X  	    if(mtmp->isshk) {
X  		/* for bones: we don't want a shopless shk around */
X  		if(ESHK(mtmp)->shoplevel != dlevel) mongone(mtmp);
X  		else shopkeeper = mtmp;
X  	    }
X  
X! 	if(!shopkeeper) return(FALSE);
X  
X  	/* get one case out of the way: you die in the shop, the */
X  	/* shopkeeper is peaceful, nothing stolen, nothing owed. */
X--- 705,720 ----
X  	register boolean take = FALSE;
X  	register boolean taken = FALSE;
X  
X! 	for(mtmp = fmon; mtmp; mtmp = mtmp2) {
X! 	    mtmp2 = mtmp->nmon;
X  	    if(mtmp->isshk) {
X  		/* for bones: we don't want a shopless shk around */
X  		if(ESHK(mtmp)->shoplevel != dlevel) mongone(mtmp);
X  		else shopkeeper = mtmp;
X  	    }
X+ 	}
X  
X! 	if(!shopkeeper) goto clear;
X  
X  	/* get one case out of the way: you die in the shop, the */
X  	/* shopkeeper is peaceful, nothing stolen, nothing owed. */
X***************
X*** 709,716 ****
X  
X  	if(ESHK(shopkeeper)->following || ANGRY(shopkeeper) || take) {
X  		if((loss > u.ugold) || !loss) {
X! 			pline("%s comes and takes all your possessions.",
X! 					Monnam(shopkeeper));
X  			taken = TRUE;
X  			shopkeeper->mgold += u.ugold;
X  			u.ugold = 0L;
X--- 738,747 ----
X  
X  	if(ESHK(shopkeeper)->following || ANGRY(shopkeeper) || take) {
X  		if((loss > u.ugold) || !loss) {
X! 			pline("%s %sand takes all your possessions.",
X! 				Monnam(shopkeeper), 
X! 				(shopkeeper->msleep || shopkeeper->mfrozen) ?
X! 				"wakes up " : "comes ");
X  			taken = TRUE;
X  			shopkeeper->mgold += u.ugold;
X  			u.ugold = 0L;
X***************
X*** 745,752 ****
X  		} else {
X  			u.ugold -= loss;
X  			shopkeeper->mgold += loss;
X! 			pline("%s comes and takes %ld zorkmid%s %sowed %s.",
X  			      Monnam(shopkeeper),
X  			      loss,
X  			      plur(loss),
X  			      strncmp(ESHK(shopkeeper)->customer, plname, PL_NSIZ) ? "" : "you ",
X--- 776,785 ----
X  		} else {
X  			u.ugold -= loss;
X  			shopkeeper->mgold += loss;
X! 			pline("%s %sand takes %ld zorkmid%s %sowed %s.",
X  			      Monnam(shopkeeper),
X+ 			      (shopkeeper->msleep || shopkeeper->mfrozen) ?
X+ 					"wakes up " : "comes ",
X  			      loss,
X  			      plur(loss),
X  			      strncmp(ESHK(shopkeeper)->customer, plname, PL_NSIZ) ? "" : "you ",
X***************
X*** 786,799 ****
X  	return(obj);
X  }
X  
X! static long
X  get_cost(obj)
X  register struct obj *obj;
X  {
X! 	register long tmp;
X  
X! 	tmp = (long) getprice(obj);
X! 	if (!tmp) tmp = 5L;
X  	if (ANGRY(shopkeeper) || 
X  		(pl_character[0] == 'T' && u.ulevel < (MAXULEV/2))
X  #ifdef SHIRT
X--- 819,832 ----
X  	return(obj);
X  }
X  
X! static unsigned
X  get_cost(obj)
X  register struct obj *obj;
X  {
X! 	register unsigned tmp;
X  
X! 	tmp = getprice(obj);
X! 	if (!tmp) tmp = 5;
X  	if (ANGRY(shopkeeper) || 
X  		(pl_character[0] == 'T' && u.ulevel < (MAXULEV/2))
X  #ifdef SHIRT
X***************
X*** 800,812 ****
X  	    || (uarmu && !uarm) /* wearing just a Hawaiian shirt */
X  #endif
X  	   )
X! 		tmp += tmp/3L;
X! 	if (ACURR(A_CHA) > 18)		tmp /= 2L;
X! 	else if (ACURR(A_CHA) > 17)	tmp = (tmp * 2L)/3L;
X! 	else if (ACURR(A_CHA) > 15)	tmp = (tmp * 3L)/4L;
X! 	else if (ACURR(A_CHA) < 6)	tmp *= 2L;
X! 	else if (ACURR(A_CHA) < 8)	tmp = (tmp * 3L)/2L;
X! 	else if (ACURR(A_CHA) < 11)	tmp = (tmp * 4L)/3L;
X  	if (!tmp) return 1;
X  	return(tmp);
X  }
X--- 833,845 ----
X  	    || (uarmu && !uarm) /* wearing just a Hawaiian shirt */
X  #endif
X  	   )
X! 		tmp += tmp/3;
X! 	if (ACURR(A_CHA) > 18)		tmp /= 2;
X! 	else if (ACURR(A_CHA) > 17)	tmp = (tmp * 2)/3;
X! 	else if (ACURR(A_CHA) > 15)	tmp = (tmp * 3)/4;
X! 	else if (ACURR(A_CHA) < 6)	tmp *= 2;
X! 	else if (ACURR(A_CHA) < 8)	tmp = (tmp * 3)/2;
X! 	else if (ACURR(A_CHA) < 11)	tmp = (tmp * 4)/3;
X  	if (!tmp) return 1;
X  	return(tmp);
X  }
X***************
X*** 840,849 ****
X  	bp->bquan = obj->quan;
X  	bp->useup = 0;
X  	bp->price = get_cost(obj);
X! 	Strcpy(buf, "\"For you, ");
X! 	if (ANGRY(shopkeeper)) Strcat(buf, "scum ");
X! 	else {
X! 	    switch(rnd(4)
X  #ifdef HARD
X  		   + u.udemigod
X  #endif
X--- 873,883 ----
X  	bp->bquan = obj->quan;
X  	bp->useup = 0;
X  	bp->price = get_cost(obj);
X! 	if(!shopkeeper->msleep && !shopkeeper->mfrozen) {
X! 	    Strcpy(buf, "\"For you, ");
X! 	    if (ANGRY(shopkeeper)) Strcat(buf, "scum ");
X! 	    else {
X! 	        switch(rnd(4)
X  #ifdef HARD
X  		   + u.udemigod
X  #endif
X***************
X*** 859,878 ****
X  		case 5: if (u.ualigntyp == U_CHAOTIC) Strcat(buf, "un");
X  			Strcat(buf, "holy");
X  			break;
X! 	    }
X  #ifdef POLYSELF
X! 	    if(!is_human(uasmon)) Strcat(buf, " creature");
X! 	    else
X  #endif
X! 		Strcat(buf, (flags.female) ? " lady" : " sir");
X! 	}
X! 	obj->dknown = 1; /* after all, the shk is telling you what it is */
X! 	if(ininv) {
X  		obj->quan = 1; /* fool xname() into giving singular */
X  		pline("%s; only %d %s %s.\"", buf, bp->price,
X  			(bp->bquan > 1) ? "per" : "for this", xname(obj));
X  		obj->quan = bp->bquan;
X! 	} else pline("The %s will cost you %d zorkmid%s%s.",
X  			xname(obj), bp->price, plur((long)bp->price),
X  			(bp->bquan > 1) ? " each" : "");
X  	ESHK(shopkeeper)->billct++;
X--- 893,915 ----
X  		case 5: if (u.ualigntyp == U_CHAOTIC) Strcat(buf, "un");
X  			Strcat(buf, "holy");
X  			break;
X! 	        }
X  #ifdef POLYSELF
X! 	        if(!is_human(uasmon)) Strcat(buf, " creature");
X! 	        else
X  #endif
X! 		    Strcat(buf, (flags.female) ? " lady" : " sir");
X! 	    }
X! 	    obj->dknown = 1; /* after all, the shk is telling you what it is */
X! 	    if(ininv) {
X  		obj->quan = 1; /* fool xname() into giving singular */
X  		pline("%s; only %d %s %s.\"", buf, bp->price,
X  			(bp->bquan > 1) ? "per" : "for this", xname(obj));
X  		obj->quan = bp->bquan;
X! 	    } else pline("The %s will cost you %d zorkmid%s%s.",
X! 			xname(obj), bp->price, plur((long)bp->price),
X! 			(bp->bquan > 1) ? " each" : "");
X! 	} else pline("The list price of %s is %d zorkmid%s%s.",
X  			xname(obj), bp->price, plur((long)bp->price),
X  			(bp->bquan > 1) ? " each" : "");
X  	ESHK(shopkeeper)->billct++;
X***************
X*** 911,922 ****
X  	}
X  }
X  
X! static void
X  subfrombill(obj)
X  register struct obj *obj;
X  {
X  	register struct bill_x *bp;
X  
X  	if((bp = onbill(obj)) != 0) {
X  		register struct obj *otmp;
X  
X--- 948,961 ----
X  	}
X  }
X  
X! void
X  subfrombill(obj)
X  register struct obj *obj;
X  {
X  	register struct bill_x *bp;
X  
X+ 	if(!shopkeeper) return;
X+ 
X  	if((bp = onbill(obj)) != 0) {
X  		register struct obj *otmp;
X  
X***************
X*** 1034,1040 ****
X  		goto quit;
X  	    }
X  	    if(bp->useup || bp->bquan > obj->quan) {
X! 		register int cnt, oquan, uquan;
X  
X  		oquan = obj->quan;
X  		uquan = (bp->useup ? bp->bquan : bp->bquan - oquan);
X--- 1073,1080 ----
X  		goto quit;
X  	    }
X  	    if(bp->useup || bp->bquan > obj->quan) {
X! 		register int cnt;
X! 		register unsigned oquan, uquan;
X  
X  		oquan = obj->quan;
X  		uquan = (bp->useup ? bp->bquan : bp->bquan - oquan);
X***************
X*** 1308,1314 ****
X  }
X  
X  #ifdef KOPS
X! static int
X  makekops(mm)		/* returns the number of (all types of) Kops  made */
X  coord *mm;
X  {
X--- 1348,1354 ----
X  }
X  
X  #ifdef KOPS
X! STATIC_OVL int
X  makekops(mm)		/* returns the number of (all types of) Kops  made */
X  coord *mm;
X  {
X***************
X*** 1318,1337 ****
X  	register int kcnt = (cnt / 9);		/* and maybe a kaptain */
X  
X  	while(cnt--) {
X! 	    enexto(mm, mm->x, mm->y, &mons[PM_KEYSTONE_KOP]);
X! 	    (void) makemon(&mons[PM_KEYSTONE_KOP], mm->x, mm->y);
X  	}
X  	while(scnt--) {
X! 	    enexto(mm, mm->x, mm->y, &mons[PM_KOP_SERGEANT]);
X! 	    (void) makemon(&mons[PM_KOP_SERGEANT], mm->x, mm->y);
X  	}
X  	while(lcnt--) {
X! 	    enexto(mm, mm->x, mm->y, &mons[PM_KOP_LIEUTENANT]);
X! 	    (void) makemon(&mons[PM_KOP_LIEUTENANT], mm->x, mm->y);
X  	}
X  	while(kcnt--) {
X! 	    enexto(mm, mm->x, mm->y, &mons[PM_KOP_KAPTAIN]);
X! 	    (void) makemon(&mons[PM_KOP_KAPTAIN], mm->x, mm->y);
X  	}
X  	return(cnt + scnt + lcnt + kcnt);
X  }
X--- 1358,1377 ----
X  	register int kcnt = (cnt / 9);		/* and maybe a kaptain */
X  
X  	while(cnt--) {
X! 	    if (enexto(mm, mm->x, mm->y, &mons[PM_KEYSTONE_KOP]))
X! 		    (void) makemon(&mons[PM_KEYSTONE_KOP], mm->x, mm->y);
X  	}
X  	while(scnt--) {
X! 	    if (enexto(mm, mm->x, mm->y, &mons[PM_KOP_SERGEANT]))
X! 		    (void) makemon(&mons[PM_KOP_SERGEANT], mm->x, mm->y);
X  	}
X  	while(lcnt--) {
X! 	    if (enexto(mm, mm->x, mm->y, &mons[PM_KOP_LIEUTENANT]))
X! 		    (void) makemon(&mons[PM_KOP_LIEUTENANT], mm->x, mm->y);
X  	}
X  	while(kcnt--) {
X! 	    if (enexto(mm, mm->x, mm->y, &mons[PM_KOP_KAPTAIN]))
X! 		    (void) makemon(&mons[PM_KOP_KAPTAIN], mm->x, mm->y);
X  	}
X  	return(cnt + scnt + lcnt + kcnt);
X  }
X***************
X*** 1395,1401 ****
X  		if(um_dist(shopkeeper->mx, shopkeeper->my, 1)) goto gethim;
X  	} else {
X  	    /* if a !shopkeeper shows up at the door, move him */
X! 	    if(MON_AT(x, y) && (mtmp = m_at(x, y)) != shopkeeper) {
X  		if(flags.soundok) {
X  		    You("hear an angry voice:");
X  		    verbalize("Out of my way, scum!");
X--- 1435,1441 ----
X  		if(um_dist(shopkeeper->mx, shopkeeper->my, 1)) goto gethim;
X  	} else {
X  	    /* if a !shopkeeper shows up at the door, move him */
X! 	    if((mtmp = m_at(x, y)) && mtmp != shopkeeper) {
X  		if(flags.soundok) {
X  		    You("hear an angry voice:");
X  		    verbalize("Out of my way, scum!");
X***************
X*** 1490,1514 ****
X  }
X  #endif
X  
X! static long
X  cost_per_charge(otmp)
X  register struct obj *otmp;
X  {
X! 	register long tmp = get_cost(otmp);
X  
X  	/* The idea is to make the exhaustive use of */
X  	/* an unpaid item more expensive than buying */
X  	/* outright.				     */
X  	if(otmp->otyp == MAGIC_LAMP) {			 /* 1 */
X! 		tmp += (tmp/3L);
X  	} else if(otmp->otyp == MAGIC_MARKER) {  	 /* 70 - 100 */
X  		/* no way to determine in advance   */
X  		/* how many charges will be wasted. */
X  		/* so, arbitrarily, one half of the */
X  		/* price per use.		    */
X! 		tmp = (tmp/2L);
X  	} else if(otmp->otyp == BAG_OF_TRICKS) { 	 /* 1 - 20 */
X! 		tmp = (tmp/5L);
X  	} else if(otmp->otyp == CRYSTAL_BALL ||  	 /* 1 - 5 */
X  		  otmp->otyp == LAMP ||	                 /* 1-10 */
X  #ifdef MUSIC
X--- 1530,1554 ----
X  }
X  #endif
X  
X! static unsigned
X  cost_per_charge(otmp)
X  register struct obj *otmp;
X  {
X! 	register unsigned tmp = get_cost(otmp);
X  
X  	/* The idea is to make the exhaustive use of */
X  	/* an unpaid item more expensive than buying */
X  	/* outright.				     */
X  	if(otmp->otyp == MAGIC_LAMP) {			 /* 1 */
X! 		tmp += (tmp/3);
X  	} else if(otmp->otyp == MAGIC_MARKER) {  	 /* 70 - 100 */
X  		/* no way to determine in advance   */
X  		/* how many charges will be wasted. */
X  		/* so, arbitrarily, one half of the */
X  		/* price per use.		    */
X! 		tmp = (tmp/2);
X  	} else if(otmp->otyp == BAG_OF_TRICKS) { 	 /* 1 - 20 */
X! 		tmp = (tmp/5);
X  	} else if(otmp->otyp == CRYSTAL_BALL ||  	 /* 1 - 5 */
X  		  otmp->otyp == LAMP ||	                 /* 1-10 */
X  #ifdef MUSIC
X***************
X*** 1516,1524 ****
X  		  otmp->otyp <= DRUM_OF_EARTHQUAKE) || 	 /* 5 - 9 */
X  #endif
X  	  	  otmp->olet == WAND_SYM) {		 /* 3 - 11 */
X! 		if(otmp->spe > 1) tmp = (tmp/4L);
X  	}
X! 	else return(0L);
X  	return(tmp);
X  }
X  
X--- 1556,1564 ----
X  		  otmp->otyp <= DRUM_OF_EARTHQUAKE) || 	 /* 5 - 9 */
X  #endif
X  	  	  otmp->olet == WAND_SYM) {		 /* 3 - 11 */
X! 		if(otmp->spe > 1) tmp = (tmp/4);
X  	}
X! 	else return(0);
X  	return(tmp);
X  }
X  
X*** src/Old/shknam.c	Sun Jun  3 14:10:52 1990
X--- src/shknam.c	Thu May 31 22:13:42 1990
X***************
X*** 9,14 ****
X--- 9,18 ----
X  
X  #ifdef OVLB
X  
X+ static void FDECL(mkshobj_at, (const struct shclass *,int,int));
X+ static void FDECL(findname, (char *,const char **));
X+ static int  FDECL(shkinit, (const struct shclass *,struct mkroom *));
X+ 
X  static const char *shkliquors[] = {
X      /* Ukraine */
X      "Njezjin", "Tsjernigof", "Gomel", "Ossipewsk", "Gorlowka",
X***************
X*** 102,108 ****
X      "Sperc", "Noskcirdneh", "Yawolloh", "Hyeghu", "Niskal", "Trahnil",
X      "Htargcm", "Enrobwem", "Kachzi Rellim", "Regien", "Donmyar",
X      "Yelpur", "Nosnehpets", "Stewe", "Renrut", "Zlaw", "Nosalnef",
X!     "Rewuorb", "Rellenk",
X      ""
X  };
X  
X--- 106,125 ----
X      "Sperc", "Noskcirdneh", "Yawolloh", "Hyeghu", "Niskal", "Trahnil",
X      "Htargcm", "Enrobwem", "Kachzi Rellim", "Regien", "Donmyar",
X      "Yelpur", "Nosnehpets", "Stewe", "Renrut", "Zlaw", "Nosalnef",
X!     "Rewuorb", "Rellenk", "Yad", "Cire Htims", "Y-crad", "Nenilukah", 
X! #ifdef OVERLAY
X!     "Erreip", "Nehpets", "Mron", "Snivek",
X! #endif
X! #ifdef MAC
X!     "Nhoj-lee", "Evad\'kh", "Ettaw-noj", "Tsew-mot", "Ydna-s",
X! #endif
X! #ifdef AMIGA
X!     "Falo", "Nosid-da\'r", "Ekim-p", "Rebrol-nek", "Noslo", "Yl-rednow",
X!     "Mured-oog",
X! #endif
X! #ifdef VMS
X!     "Lez-tneg", "Ytnu-haled", "Niknar",
X! #endif
X      ""
X  };
X  
X***************
X*** 183,189 ****
X  static void
X  mkshobj_at(shp, sx, sy)
X  /* make an object of the appropriate type for a shop square */
X! struct shclass *shp;
X  int sx, sy;
X  {
X  	register struct monst *mtmp;
X--- 200,206 ----
X  static void
X  mkshobj_at(shp, sx, sy)
X  /* make an object of the appropriate type for a shop square */
X! const struct shclass *shp;
X  int sx, sy;
X  {
X  	register struct monst *mtmp;
X***************
X*** 200,206 ****
X  		}
X  	} else if ((atype = get_shop_item(shp - shtypes)) < 0)
X  		(void) mksobj_at(-atype, sx, sy);
X! 	else (void) mkobj_at(atype, sx, sy);
X  }
X  
X  static void
X--- 217,223 ----
X  		}
X  	} else if ((atype = get_shop_item(shp - shtypes)) < 0)
X  		(void) mksobj_at(-atype, sx, sy);
X! 	else (void) mkobj_at(atype, sx, sy, TRUE);
X  }
X  
X  static void
X***************
X*** 207,213 ****
X  findname(nampt, nlp)
X  /* extract a shopkeeper name for the given shop type */
X  	char *nampt;
X! 	char *nlp[];
X  {
X      register int i;
X  
X--- 224,230 ----
X  findname(nampt, nlp)
X  /* extract a shopkeeper name for the given shop type */
X  	char *nampt;
X! 	const char *nlp[];
X  {
X      register int i;
X  
X***************
X*** 214,220 ****
X      for(i = 0; i < dlevel; i++)
X  	if (strlen(nlp[i]) == 0) {
X  	    /* Not enough names, try general name */
X! 	    if (nlp != (char **)shkgeneral)
X  		findname(nampt, shkgeneral);
X  	    else
X  		Strcpy(nampt, "Dirk");
X--- 231,237 ----
X      for(i = 0; i < dlevel; i++)
X  	if (strlen(nlp[i]) == 0) {
X  	    /* Not enough names, try general name */
X! 	    if (nlp != shkgeneral)
X  		findname(nampt, shkgeneral);
X  	    else
X  		Strcpy(nampt, "Dirk");
X***************
X*** 226,232 ****
X  
X  static int
X  shkinit(shp, sroom)	/* create a new shopkeeper in the given room */
X! struct shclass	*shp;
X  struct mkroom	*sroom;
X  {
X  	register int sh, sx, sy;
X--- 243,249 ----
X  
X  static int
X  shkinit(shp, sroom)	/* create a new shopkeeper in the given room */
X! const struct shclass	*shp;
X  struct mkroom	*sroom;
X  {
X  	register int sh, sx, sy;
X***************
X*** 285,291 ****
X  	ESHK(shk)->billct = 0;
X  	shk->mgold = 1000L + 30L*(long)rnd(100);	/* initial capital */
X  	if (shp->shknms == (char **)shktools) {
X! 		static int who;
X  		who = rn2(sizeof(shktools)/sizeof(char *) - 1);
X  		if (who==21) ESHK(shk)->ismale = FALSE;
X  		else ESHK(shk)->ismale = TRUE;
X--- 302,308 ----
X  	ESHK(shk)->billct = 0;
X  	shk->mgold = 1000L + 30L*(long)rnd(100);	/* initial capital */
X  	if (shp->shknms == (char **)shktools) {
X! 		static int NEARDATA who;
X  		who = rn2(sizeof(shktools)/sizeof(char *) - 1);
X  		if (who==21) ESHK(shk)->ismale = FALSE;
X  		else ESHK(shk)->ismale = TRUE;
X***************
X*** 293,299 ****
X  		ESHK(shk)->shknam[PL_NSIZ-1] = 0;
X  	} else {
X  		ESHK(shk)->ismale = dlevel%2;
X! 		findname(ESHK(shk)->shknam, shp->shknms);
X  	}
X  
X  	return(sh);
X--- 310,316 ----
X  		ESHK(shk)->shknam[PL_NSIZ-1] = 0;
X  	} else {
X  		ESHK(shk)->ismale = dlevel%2;
X! 		findname(ESHK(shk)->shknam, (const char **)shp->shknms);
X  	}
X  
X  	return(sh);
X***************
X*** 325,330 ****
X--- 342,351 ----
X  
X      if(levl[sx][sy].doormask == D_NODOOR) {
X  	    levl[sx][sy].doormask = D_ISOPEN;
X+ 	    mnewsym(sx,sy);
X+     }
X+     if(levl[sx][sy].typ == SDOOR) {
X+ 	    levl[sx][sy].typ = DOOR;
X  	    mnewsym(sx,sy);
X      }
X      if(levl[sx][sy].doormask & D_TRAPPED) {	
X*** src/Old/sit.c	Sun Jun  3 14:11:17 1990
X--- src/sit.c	Fri Apr 13 17:52:16 1990
X***************
X*** 161,168 ****
X  	}
X  
X  	for (otmp = invent; otmp; otmp = otmp->nobj)  nobj++;
X- 	    if (nobj) for (cnt = rnd(6/((!!Antimagic) + 1)); cnt > 0; cnt--)  {
X  
X  		onum = rn2(nobj);
X  		for(otmp = invent; onum != 0; onum--)
X  		    otmp = otmp->nobj;
X--- 161,169 ----
X  	}
X  
X  	for (otmp = invent; otmp; otmp = otmp->nobj)  nobj++;
X  
X+ 	if (nobj)
X+ 	    for (cnt = rnd(6/((!!Antimagic) + 1)); cnt > 0; cnt--)  {
X  		onum = rn2(nobj);
X  		for(otmp = invent; onum != 0; onum--)
X  		    otmp = otmp->nobj;
X*** src/Old/sounds.c	Sun Jun  3 14:11:33 1990
X--- src/sounds.c	Thu May 31 22:13:45 1990
X***************
X*** 8,17 ****
X  #include "hack.h"
X  #include "edog.h"
X  
X- static int FDECL(domonnoise,(struct monst *));
X- 
X  #ifdef OVLB
X  
X  void
X  verbalize(str)
X  register const char *str;
X--- 8,17 ----
X  #include "hack.h"
X  #include "edog.h"
X  
X  #ifdef OVLB
X  
X+ static int FDECL(domonnoise,(struct monst *));
X+ 
X  void
X  verbalize(str)
X  register const char *str;
X***************
X*** 107,113 ****
X  			You("hear the tones of courtly conversation.");
X  			break;
X  		    case 1:
X! 			You("hear a sceptre being pounded in judgement.");
X  			break;
X  		    case 2:
X  			pline("Someone just shouted \"Off with %s head!\"",
X--- 107,113 ----
X  			You("hear the tones of courtly conversation.");
X  			break;
X  		    case 1:
X! 			You("hear a sceptre being pounded in judgment.");
X  			break;
X  		    case 2:
X  			pline("Someone just shouted \"Off with %s head!\"",
X*** src/Old/sp_lev.c	Sun Jun  3 14:11:57 1990
X--- src/sp_lev.c	Sat May 12 16:07:17 1990
X***************
X*** 26,32 ****
X  #define TOP	1
X  #define BOTTOM	3
X  
X! static walk walklist[50];
X  extern int x_maze_max, y_maze_max;
X  
X  #ifdef MACOS
X--- 26,32 ----
X  #define TOP	1
X  #define BOTTOM	3
X  
X! static walk NEARDATA walklist[50];
X  extern int x_maze_max, y_maze_max;
X  
X  #ifdef MACOS
X***************
X*** 36,43 ****
X  #endif
X  static char robjects[10], rloc_x[10], rloc_y[10], rmonst[10],
X  	ralign[3] = { A_CHAOS, A_NEUTRAL, A_LAW };
X! static xchar xstart, ystart, xsize, ysize;
X  
X  /*
X   * Make walls of the area (x1, y1, x2, y2) non diggable
X   */
X--- 36,53 ----
X  #endif
X  static char robjects[10], rloc_x[10], rloc_y[10], rmonst[10],
X  	ralign[3] = { A_CHAOS, A_NEUTRAL, A_LAW };
X! static xchar NEARDATA xstart, NEARDATA ystart, NEARDATA xsize, NEARDATA ysize;
X  
X+ static void FDECL(make_walls_nondiggable, (XCHAR_P,XCHAR_P,XCHAR_P,XCHAR_P));
X+ static int NDECL(rnddoor);
X+ static int NDECL(rndtrap);
X+ static void FDECL(get_location, (schar *,schar *));
X+ static void FDECL(shuffle, (char *,XCHAR_P));
X+ static void FDECL(shuffle2, (char *,char *,XCHAR_P));
X+ static boolean FDECL(load_rooms, (FILE *));
X+ static void FDECL(maze1xy, (coord *));
X+ static boolean FDECL(load_maze, (FILE *));
X+ 
X  /*
X   * Make walls of the area (x1, y1, x2, y2) non diggable
X   */
X***************
X*** 406,416 ****
X  			c = 0;
X  
X  		if (!c)
X! 			(void) mkobj_at(0, x, y);
X  		else if (tmpobj.id != -1)
X  			(void) mksobj_at(tmpobj.id, x, y);
X  		else
X! 			(void) mkobj_at(c, x, y);
X  	}
X  
X  	n = fgetc(fd); /* Number of drawbridges */
X--- 416,426 ----
X  			c = 0;
X  
X  		if (!c)
X! 			(void) mkobj_at(0, x, y, TRUE);
X  		else if (tmpobj.id != -1)
X  			(void) mksobj_at(tmpobj.id, x, y);
X  		else
X! 			(void) mkobj_at(c, x, y, TRUE);
X  	}
X  
X  	n = fgetc(fd); /* Number of drawbridges */
X***************
X*** 540,546 ****
X  	    mapfact = (int) ((mapcount * 100L) / mapcountmax);
X  	    for(x = rnd((int) (20 * mapfact) / 100); x; x--) {
X  		    maze1xy(&mm);
X! 		    (void) mkobj_at(rn2(2) ? GEM_SYM : 0, mm.x, mm.y);
X  	    }
X  	    for(x = rnd((int) (12 * mapfact) / 100); x; x--) {
X  		    maze1xy(&mm);
X--- 550,556 ----
X  	    mapfact = (int) ((mapcount * 100L) / mapcountmax);
X  	    for(x = rnd((int) (20 * mapfact) / 100); x; x--) {
X  		    maze1xy(&mm);
X! 		    (void) mkobj_at(rn2(2) ? GEM_SYM : 0, mm.x, mm.y, TRUE);
X  	    }
X  	    for(x = rnd((int) (12 * mapfact) / 100); x; x--) {
X  		    maze1xy(&mm);
X
END_OF_FILE
if test 52827 -ne `wc -c <'patch8.07'`; then
    echo shar: \"'patch8.07'\" unpacked with wrong size!
fi
# end of 'patch8.07'
fi
echo shar: End of archive 6 \(of 24\).
cp /dev/null ark6isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 24 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
