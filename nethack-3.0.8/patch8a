Path: utzoo!utgpu!news-server.csri.toronto.edu!cs.utexas.edu!uunet!zephyr.ens.tek.com!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v10i019:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Patch8a
Message-ID: <5727@tekred.CNA.TEK.COM>
Date: 5 Jun 90 17:46:05 GMT
Sender: news@tekred.CNA.TEK.COM
Lines: 1871
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 10, Issue 19
Archive-name: NetHack3/Patch8a
Patch-To: NetHack3: Volume 7, Issue 56-93

	[As before, unpack this in your top level NetHack3 directory.
         This set of patches will overwrite several existing files
         whose diffs were larger than the source itself and create
         several patch8.?? files to be fed to patch. Use the
         do_patch8.sh script to do this automatically. The script also
         deletes several old files or files that moved to other
         directories. There are 24 parts (a-x) in this patch (#8).
			  -br]

[[And now a word from the development team...
UPDATE8

This patch is devoted to bugfixes and accommodations for more versions of
the newer ports.

The VMS port should now compile with both VAXC and GNUC and install more
easily under a variety of OS versions, thanks to Joshua Delahunty and Pat
Rankin.

A number of strange interactions in the Macintosh-specific code have been
cleaned up.

The MSDOS overlay manager was debugged, and the overlay assignments and macro
names straightened out, so the result should be both faster and more stable
than previous versions.  See the new file Install.ovl and various files in
the others directory for more information.

The Amiga port now specifies addressing modes for many external variables,
which should make its executable smaller and faster as well.


The biggest externally visible change separates DECgraphics and IBMgraphics
from the general graphics-setting code, and makes them selectable on the
command line.

Once again, existing saved games and bones files should be discarded (or the
update postponed until they are gone).

A number of reasonably simple bugs are no more, although some screen update
oddities are postponed to 3.1.  Among the dead are problems with shops on
bones levels, renaming artifacts, kicking non-objects, winning gem treatment,
level bounds checking and monster filling, mimic appearances, taking items
out of containers, monster interiors and inventories, and guard behavior.
Various other things were changed to be consistent with similar situations.]]


#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 24)."
# Contents:  MANIFEST.P8 patch8.05
# Wrapped by billr@saab on Mon Jun  4 15:27:11 1990
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'MANIFEST.P8' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST.P8'\"
else
echo shar: Extracting \"'MANIFEST.P8'\" \(1881 characters\)
sed "s/^X//" >'MANIFEST.P8' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X Files                     24	
X Install.dos               23	
X Install.mac               20	
X Install.ovl               19	
X Install.vms               23	
X MANIFEST.P8                1	This shipping list
X UPDATE8                    5	
X amiga/GBinfo.uu            4	
X amiga/NHScore.uu          24	
X amiga/NHinfo.uu           24	
X amiga/NewGame.uu          24	
X amiga/dflticon.uu         24	
X auxil/Guidebook.mss       10	
X auxil/Guidebook.tex        3	
X auxil/Makefile.auxil      21	
X auxil/history             24	
X do_patch8.sh              20	
X include/decl.h            24	
X mac/MD.proj.hqx           19	
X mac/MD.rsrc.hqx           24	
X mac/MacAlert.c            22	
X mac/NH.proj.hqx           18	
X mac/NH.rsrc.hqx           17	
X mac/SL.proj.hqx           18	
X others/Makefile.os2       23	
X others/Makefile.ovl       22	
X others/exesmurf.c         19	
X others/exesmurf.uu        17	
X others/maintain.ovl       16	
X others/ovlmgr.asm         20	
X others/ovlmgr.doc         23	
X others/ovlmgr.uu          24	
X others/splitf.c            9	
X others/splitf.uu          16	
X others/suputils.ovl        3	
X patch8.01                 12	
X patch8.02                 13	
X patch8.03                  9	
X patch8.04                  8	
X patch8.05                 01	
X patch8.06                  7	
X patch8.07                  6	
X patch8.08                  5	
X patch8.09                 14	
X patch8.10                 15	
X patch8.11                 11	
X patch8.12                  4	
X patch8.13                  2	
X src/lev_comp.c            21	
X src/lev_lex.c             21	
X vms/install.com            2	
X vms/lev_lex.h              4	
X vms/oldcrtl.c              7	
X vms/spec_lev.com          23	
X vms/vmsbuild.com          22	
X vms/vmsmisc.c             20	
X vms/vmstty.c              24	
END_OF_FILE
if test 1881 -ne `wc -c <'MANIFEST.P8'`; then
    echo shar: \"'MANIFEST.P8'\" unpacked with wrong size!
fi
# end of 'MANIFEST.P8'
fi
if test -f 'patch8.05' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'patch8.05'\"
else
echo shar: Extracting \"'patch8.05'\" \(45498 characters\)
sed "s/^X//" >'patch8.05' <<'END_OF_FILE'
X*** src/Old/monst.c	Sun Jun  3 13:36:38 1990
X--- src/monst.c	Sun May 13 20:26:01 1990
X***************
X*** 2,11 ****
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X- /* since this file is also used in auxiliary programs, don't include all the
X-  * function declarations for all of nethack
X-  */
X- #define EXTERN_H
X  #include "config.h"
X  #include "permonst.h"
X  #include "monsym.h"
X--- 2,7 ----
X***************
X*** 28,40 ****
X  #endif
X  
X  #ifndef SPLITMON_2
X! struct permonst playermon = {		/* used by weapons bonus code */
X  	"player", S_HUMAN, 1, 10, 10, 0, 0, G_GENO | G_NOGEN,
X  	{ { AT_WEAP, AD_PHYS, 1, 6 }, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X  	45, 400, PL_NSIZ, MS_SILENT, MZ_HUMAN,
X  	M1_NEEDPICK | M1_HUMANOID | M1_COLLECT,
X  	M2_HUMAN | M2_STRONG, C(HI_DOMESTIC)
X! },	*uasmon = &playermon;
X  #endif /* SPLITMON_2 */
X  
X  /*
X--- 24,36 ----
X  #endif
X  
X  #ifndef SPLITMON_2
X! struct permonst NEARDATA playermon = {		/* used by weapons bonus code */
X  	"player", S_HUMAN, 1, 10, 10, 0, 0, G_GENO | G_NOGEN,
X  	{ { AT_WEAP, AD_PHYS, 1, 6 }, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X  	45, 400, PL_NSIZ, MS_SILENT, MZ_HUMAN,
X  	M1_NEEDPICK | M1_HUMANOID | M1_COLLECT,
X  	M2_HUMAN | M2_STRONG, C(HI_DOMESTIC)
X! },	NEARDATA *uasmon = &playermon;
X  #endif /* SPLITMON_2 */
X  
X  /*
X***************
X*** 76,82 ****
X  struct permonst *mons;	   /* for SMALLDATA - mons data stored in NetHack app */
X  #else
X  #ifndef SPLITMON_2
X! struct permonst mons[] = {
X  /*	ants	*/
X  	{ "giant ant",	S_ANT, 2, 18, 3, 0, 0, (G_GENO | G_SGROUP | 3),
X  	  { { AT_BITE, AD_PHYS, 1, 4 }, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X--- 72,78 ----
X  struct permonst *mons;	   /* for SMALLDATA - mons data stored in NetHack app */
X  #else
X  #ifndef SPLITMON_2
X! struct permonst NEARDATA mons[] = {
X  /*	ants	*/
X  	{ "giant ant",	S_ANT, 2, 18, 3, 0, 0, (G_GENO | G_SGROUP | 3),
X  	  { { AT_BITE, AD_PHYS, 1, 4 }, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X*** src/Old/mthrowu.c	Sun Jun  3 13:38:37 1990
X--- src/mthrowu.c	Sat May 26 22:30:17 1990
X***************
X*** 4,12 ****
X  
X  #include	"hack.h"
X  
X! OSTATIC int FDECL(movedist,(int,int,int,int));
X! static void FDECL(drop_throw,(struct obj *,BOOLEAN_P,int,int));
X! OSTATIC void FDECL(m_throw,(int,int,int,int,int,struct obj *));
X  
X  #define URETREATING(x,y) (movedist(u.ux,u.uy,x,y) > movedist(u.ux0,u.uy0,x,y))
X  
X--- 4,12 ----
X  
X  #include	"hack.h"
X  
X! STATIC_DCL int FDECL(movedist,(int,int,int,int));
X! STATIC_DCL void FDECL(drop_throw,(struct obj *,BOOLEAN_P,int,int));
X! STATIC_DCL void FDECL(m_throw,(int,int,int,int,int,struct obj *));
X  
X  #define URETREATING(x,y) (movedist(u.ux,u.uy,x,y) > movedist(u.ux0,u.uy0,x,y))
X  
X***************
X*** 14,26 ****
X  
X  #ifndef OVLB
X  
X! OSTATIC const char *breathwep[];
X  
X  #else /* OVLB */
X  
X! schar	tbx = 0, tby = 0;	/* used for direction of throw, buzz, etc. */
X  
X! XSTATIC const char *breathwep[] = {	"fragments",
X  				"fire",
X  				"sleep gas",
X  				"frost",
X--- 14,27 ----
X  
X  #ifndef OVLB
X  
X! STATIC_DCL const char *breathwep[];
X  
X  #else /* OVLB */
X  
X! schar NEARDATA tbx = 0, NEARDATA tby = 0;
X! 	/* used for direction of throw, buzz, etc. */
X  
X! STATIC_OVL const char NEARDATA *breathwep[] = {    "fragments",
X  				"fire",
X  				"sleep gas",
X  				"frost",
X***************
X*** 70,76 ****
X  /* Be sure this corresponds with what happens to player-thrown objects in
X   * dothrow.c (for consistency). --KAA
X   */
X! static void
X  drop_throw(obj, ohit, x, y)
X  register struct obj *obj;
X  boolean ohit;
X--- 71,78 ----
X  /* Be sure this corresponds with what happens to player-thrown objects in
X   * dothrow.c (for consistency). --KAA
X   */
X! 
X! STATIC_OVL void
X  drop_throw(obj, ohit, x, y)
X  register struct obj *obj;
X  boolean ohit;
X***************
X*** 93,99 ****
X  	} else free((genericptr_t)obj);
X  }
X  
X! XSTATIC void
X  m_throw(x, y, dx, dy, range, obj)
X  	register int x,y,dx,dy,range;		/* direction and range */
X  	register struct obj *obj;
X--- 95,104 ----
X  	} else free((genericptr_t)obj);
X  }
X  
X! #endif /* OVLB */
X! #ifdef OVL1
X! 
X! STATIC_OVL void
X  m_throw(x, y, dx, dy, range, obj)
X  	register int x,y,dx,dy,range;		/* direction and range */
X  	register struct obj *obj;
X***************
X*** 270,275 ****
X--- 275,283 ----
X  	}
X  }
X  
X+ #endif /* OVL1 */
X+ #ifdef OVLB
X+ 
X  /* Remove an item from the monster's inventory.
X   */
X  void
X***************
X*** 322,328 ****
X  		if(!URETREATING(x,y) ||
X  		   !rn2(BOLT_LIM-movedist(x,mtmp->mux,y,mtmp->muy)))
X  		{
X! 		    int savequan = otmp->quan;
X  		    const char *verb = "throws";
X  
X  		    if (otmp->otyp == ARROW
X--- 330,336 ----
X  		if(!URETREATING(x,y) ||
X  		   !rn2(BOLT_LIM-movedist(x,mtmp->mux,y,mtmp->muy)))
X  		{
X! 		    unsigned savequan = otmp->quan;
X  		    const char *verb = "throws";
X  
X  		    if (otmp->otyp == ARROW
X***************
X*** 476,482 ****
X  #endif /* OVL0 */
X  #ifdef OVL1
X  
X! XSTATIC int
X  movedist(x0, x1, y0, y1)
X  int x0, x1, y0, y1;
X  {
X--- 484,490 ----
X  #endif /* OVL0 */
X  #ifdef OVL1
X  
X! STATIC_OVL int
X  movedist(x0, x1, y0, y1)
X  int x0, x1, y0, y1;
X  {
X*** src/Old/music.c	Sun Jun  3 13:39:01 1990
X--- src/music.c	Sat May 12 16:09:00 1990
X***************
X*** 229,236 ****
X  				    else if (flags.soundok && humanoid(mtmp->data))
X  					You("hear a scream!");
X  				    if ((mtmp->mhp -= rnd(6)) <= 0) {
X- 					int saved_conf = u.umconf;
X- 
X  					if(!cansee(x,y))
X  					    pline("It is destroyed!");
X  					else {
X--- 229,234 ----
X***************
X*** 240,246 ****
X  						mon_nam(mtmp));
X  					}
X  					xkilled(mtmp,0);
X- 					u.umconf = saved_conf;
X  				    }
X  				}
X  			    } else if (x == u.ux && y == u.uy) {
X--- 238,243 ----
X***************
X*** 394,399 ****
X--- 391,397 ----
X  		/* Search for the drawbridge */
X  		for(y=u.uy-1; y<=u.uy+1; y++)
X  		    for(x=u.ux-1;x<=u.ux+1;x++)
X+ 			if(isok(x,y))
X  			if (find_drawbridge(&x,&y)) {
X  			    if (levl[x][y].typ == DRAWBRIDGE_DOWN)
X  				close_drawbridge(x,y);
X***************
X*** 408,413 ****
X--- 406,412 ----
X  		ok = FALSE;
X  		for(y = u.uy-1; y <= u.uy+1 && !ok; y++)
X  		    for(x = u.ux-1; x <= u.ux+1 && !ok; x++)
X+ 			if(isok(x,y))
X  			if(IS_DRAWBRIDGE(levl[x][y].typ) ||
X  			   is_drawbridge_wall(x,y) >= 0)
X  				ok = TRUE;
X*** src/Old/o_init.c	Sun Jun  3 13:39:22 1990
X--- src/o_init.c	Wed May  9 20:18:19 1990
X***************
X*** 4,9 ****
X--- 4,13 ----
X  
X  #include	"hack.h"		/* for typedefs */
X  
X+ #if defined(LATTICE) 				/* This is NOT */
X+ # define MACOS					/* a typo! */
X+ #endif
X+ 
X  static void NDECL(setgemprobs);
X  static void FDECL(shuffle,(int,int,BOOLEAN_P));
X  static boolean FDECL(interesting_to_discover,(int));
X***************
X*** 28,35 ****
X  #endif
X  	RING_SYM, GEM_SYM, 0 };
X  
X! int bases[sizeof(obj_symbols)] = DUMMY;
X! static int disco[TOTAL_OBJS] = DUMMY;
X  
X  int
X  letindex(let) register char let; {
X--- 32,39 ----
X  #endif
X  	RING_SYM, GEM_SYM, 0 };
X  
X! int NEARDATA bases[sizeof(obj_symbols)] = DUMMY;
X! static int NEARDATA disco[TOTAL_OBJS] = DUMMY;
X  
X  int
X  letindex(let) register char let; {
X***************
X*** 301,307 ****
X  		objects[i].oc_descr = d[switches[i]].descr;
X  	}
X  #else
X! # if !defined(MSDOS) && !defined(M_XENIX) && !defined(HPUX)
X  	differ = (genericptr_t)&objects[0] - (genericptr_t)then;
X  # else
X  	differ = (long)&objects[0] - (long)then;
X--- 305,311 ----
X  		objects[i].oc_descr = d[switches[i]].descr;
X  	}
X  #else
X! # if !defined(MSDOS) && !defined(M_XENIX) && !defined(HPUX) && !defined(VAXC)
X  	differ = (genericptr_t)&objects[0] - (genericptr_t)then;
X  # else
X  	differ = (long)&objects[0] - (long)then;
X***************
X*** 310,316 ****
X  	for(i=0; i < TOTAL_OBJS; i++) {
X  #ifndef MACOS
X  		if (objects[i].oc_name) {
X! # if !defined(MSDOS) && !defined(M_XENIX)
X  			objects[i].oc_name += differ;
X  # else
X  			objects[i].oc_name =
X--- 314,320 ----
X  	for(i=0; i < TOTAL_OBJS; i++) {
X  #ifndef MACOS
X  		if (objects[i].oc_name) {
X! # if !defined(MSDOS) && !defined(M_XENIX) && !defined(HPUX) && !defined(VAXC)
X  			objects[i].oc_name += differ;
X  # else
X  			objects[i].oc_name =
X***************
X*** 318,324 ****
X  # endif
X  		}
X  		if (objects[i].oc_descr) {
X! # if !defined(MSDOS) && !defined(M_XENIX)
X  			objects[i].oc_descr += differ;
X  # else
X  			objects[i].oc_descr =
X--- 322,328 ----
X  # endif
X  		}
X  		if (objects[i].oc_descr) {
X! # if !defined(MSDOS) && !defined(M_XENIX) && !defined(HPUX) && !defined(VAXC)
X  			objects[i].oc_descr += differ;
X  # else
X  			objects[i].oc_descr =
X*** src/Old/objects.c	Sun Jun  3 13:39:46 1990
X--- src/objects.c	Sun May 13 20:26:16 1990
X***************
X*** 2,16 ****
X  /* NetHack may be freely redistributed.  See license for details. */
X  /* Copyright (c) Mike Threepoint, 1989 (890110) */
X  
X- /* since this file is also used in auxiliary programs, don't include all the 
X-  * function declarations for all of nethack
X-  */
X- #define EXTERN_H
X  #include "config.h"
X  #include "obj.h"
X  #include "objclass.h"
X  #include "prop.h"
X- #undef BOW
X  
X  /* objects have letter " % ) ( 0 _ ` [ ! ? / = * + . */
X  
X--- 2,11 ----
X***************
X*** 28,34 ****
X  struct objclass *objects;
X  struct small_objclass sm_obj[] = {
X  #else
X! struct objclass objects[] = {
X  #endif
X  
X  #if defined(MACOS) && !defined(MAKEDEFS_C)
X--- 23,29 ----
X  struct objclass *objects;
X  struct small_objclass sm_obj[] = {
X  #else
X! struct objclass NEARDATA objects[] = {
X  #endif
X  
X  #if defined(MACOS) && !defined(MAKEDEFS_C)
X***************
X*** 549,554 ****
X--- 544,589 ----
X  #undef ARMOR
X  
X  #if defined(MACOS) && !defined(MAKEDEFS_C)
X+ #define GEM(name,desc,prob,wt,gval,glass, color) \
X+ 	{ name, desc}
X+ #else
X+ #define GEM(name,desc,prob,wt,gval,glass, color) \
X+ 		{ name, desc, NULL, 0,1,0,0,glass, 0,\
X+ 		GEM_SYM, prob, 0, wt, gval, 3, 3, WP_SLING, C(color)}
X+ #endif
X+ GEM("dilithium crystal", "white",	 3, 1, 4500, MINERAL, WHITE),
X+ GEM("diamond", "white", 		 4, 1, 4000, MINERAL, WHITE),
X+ GEM("ruby", "red",			 5, 1, 3500, MINERAL, RED),
X+ GEM("sapphire", "blue", 		 6, 1, 3000, MINERAL, BLUE),
X+ GEM("emerald", "green", 		 7, 1, 2500, MINERAL, GREEN),
X+ GEM("turquoise", "green",		 8, 1, 2000, MINERAL, GREEN),
X+ GEM("aquamarine", "green",		10, 1, 1500, MINERAL, GREEN),
X+ GEM("amber", "yellowish brown", 	11, 1, 1000, MINERAL, BROWN),
X+ GEM("topaz", "yellowish brown", 	13, 1,	900, MINERAL, BROWN),
X+ GEM("opal", "white",			15, 1,	800, MINERAL, WHITE),
X+ GEM("garnet", "red",			17, 1,	700, MINERAL, RED),
X+ GEM("amethyst", "violet",		19, 1,  600, MINERAL, MAGENTA),
X+ GEM("jasper", "red",			21, 1,	500, MINERAL, RED),
X+ GEM("fluorite", "violet",		22, 1,	400, MINERAL, MAGENTA),
X+ GEM("jade", "green",			23, 1,	300, MINERAL, GREEN),
X+ GEM("worthless piece of white glass", "white",	131, 1, 0, GLASS, WHITE),
X+ GEM("worthless piece of blue glass", "blue",	131, 1, 0, GLASS, BLUE),
X+ GEM("worthless piece of red glass", "red",	131, 1, 0, GLASS, RED),
X+ GEM("worthless piece of yellowish brown glass", "yellowish brown",
X+ 						131, 1, 0, GLASS, BROWN),
X+ GEM("worthless piece of green glass", "green",	131, 1, 0, GLASS, GREEN),
X+ GEM("worthless piece of violet glass", "violet",131, 1, 0, GLASS, MAGENTA),
X+ GEM("luckstone", "gray",		 10, 1,  60, MINERAL, GRAY),
X+ GEM("loadstone", "gray",		 10, 50,  1, MINERAL, GRAY),
X+ #if defined(MACOS) && !defined(MAKEDEFS_C)
X+ { "rock", NULL},
X+ #else
X+ { "rock", NULL, NULL, 1,1,0,0,MINERAL, 0,
X+ 		GEM_SYM, 10, 0, 1, 0, 3, 3, WP_SLING, C(HI_MINERAL)},
X+ #endif
X+ #undef GEM
X+ 
X+ #if defined(MACOS) && !defined(MAKEDEFS_C)
X  #define POTION(name,desc,power,prob,cost,color) \
X  	{ name, desc}
X  #else
X***************
X*** 756,802 ****
X  RING("protection from shape changers", "shining", PROT_FROM_SHAPE_CHANGERS,
X  							100, 0, METAL, HI_METAL|BRIGHT),
X  #undef RING
X- 
X- /* gems ************************************************************/
X- #if defined(MACOS) && !defined(MAKEDEFS_C)
X- #define GEM(name,desc,prob,wt,gval,glass, color) \
X- 	{ name, desc}
X- #else
X- #define GEM(name,desc,prob,wt,gval,glass, color) \
X- 		{ name, desc, NULL, 0,1,0,0,glass, 0,\
X- 		GEM_SYM, prob, 0, wt, gval, 3, 3, WP_SLING, C(color)}
X- #endif
X- GEM("dilithium crystal", "white",	 3, 1, 4500, MINERAL, WHITE),
X- GEM("diamond", "white", 		 4, 1, 4000, MINERAL, WHITE),
X- GEM("ruby", "red",			 5, 1, 3500, MINERAL, RED),
X- GEM("sapphire", "blue", 		 6, 1, 3000, MINERAL, BLUE),
X- GEM("emerald", "green", 		 7, 1, 2500, MINERAL, GREEN),
X- GEM("turquoise", "green",		 8, 1, 2000, MINERAL, GREEN),
X- GEM("aquamarine", "green",		10, 1, 1500, MINERAL, GREEN),
X- GEM("amber", "yellowish brown", 	11, 1, 1000, MINERAL, BROWN),
X- GEM("topaz", "yellowish brown", 	13, 1,	900, MINERAL, BROWN),
X- GEM("opal", "white",			15, 1,	800, MINERAL, WHITE),
X- GEM("garnet", "red",			17, 1,	700, MINERAL, RED),
X- GEM("amethyst", "violet",		19, 1,  600, MINERAL, MAGENTA),
X- GEM("jasper", "red",			21, 1,	500, MINERAL, RED),
X- GEM("fluorite", "violet",		22, 1,	400, MINERAL, MAGENTA),
X- GEM("jade", "green",			23, 1,	300, MINERAL, GREEN),
X- GEM("worthless piece of white glass", "white",	131, 1, 0, GLASS, WHITE),
X- GEM("worthless piece of blue glass", "blue",	131, 1, 0, GLASS, BLUE),
X- GEM("worthless piece of red glass", "red",	131, 1, 0, GLASS, RED),
X- GEM("worthless piece of yellowish brown glass", "yellowish brown",
X- 						131, 1, 0, GLASS, BROWN),
X- GEM("worthless piece of green glass", "green",	131, 1, 0, GLASS, GREEN),
X- GEM("worthless piece of violet glass", "violet",131, 1, 0, GLASS, MAGENTA),
X- GEM("luckstone", "gray",		 10, 1,  60, MINERAL, GRAY),
X- GEM("loadstone", "gray",		 10, 50,  1, MINERAL, GRAY),
X- #if defined(MACOS) && !defined(MAKEDEFS_C)
X- { "rock", NULL},
X- #else
X- { "rock", NULL, NULL, 1,1,0,0,MINERAL, 0,
X- 		GEM_SYM, 10, 0, 1, 0, 3, 3, WP_SLING, C(HI_MINERAL)},
X- #endif
X- #undef GEM
X  
X  #if defined(MACOS) && !defined(MAKEDEFS_C)
X  	{ NULL, NULL}
X--- 791,796 ----
X*** src/Old/objnam.c	Mon Jun  4 13:11:56 1990
X--- src/objnam.c	Mon Jun  4 13:04:34 1990
X***************
X*** 3,8
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X  #include	"hack.h"
X  #include <ctype.h>	/* for isalpha() */
X  
X  /* "an uncursed partly eaten guardian naga hatchling corpse" */
X
X--- 3,9 -----
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X  #include	"hack.h"
X+ #ifdef TUTTI_FRUTTI
X  #include <ctype.h>	/* for isalpha() */
X  #endif
X  
X***************
X*** 4,9
X  
X  #include	"hack.h"
X  #include <ctype.h>	/* for isalpha() */
X  
X  /* "an uncursed partly eaten guardian naga hatchling corpse" */
X  #define	PREFIX	50
X
X--- 5,11 -----
X  #include	"hack.h"
X  #ifdef TUTTI_FRUTTI
X  #include <ctype.h>	/* for isalpha() */
X+ #endif
X  
X  /* "an uncursed partly eaten guardian naga hatchling corpse" */
X  #define	PREFIX	50
X***************
X*** 11,17
X  
X  #ifndef OVLB
X  
X! OSTATIC const char *keystr[N_LOX], *lockstr[N_LOX];
X  
X  #else /* OVLB */
X  /*	We want the player to be able to learn what key goes in what lock.  */
X
X--- 13,19 -----
X  
X  #ifndef OVLB
X  
X! STATIC_DCL const char *keystr[N_LOX], *lockstr[N_LOX];
X  
X  #else /* OVLB */
X  /*	We want the player to be able to learn what key goes in what lock.  */
X***************
X*** 15,21
X  
X  #else /* OVLB */
X  /*	We want the player to be able to learn what key goes in what lock.  */
X! XSTATIC const char *keystr[N_LOX] = { "round", "square", "triangular", "oval",
X  			              "octagonal", "hexagonal", "cylindrical",
X  			              "irregular", "conical", "wedge-shaped" },
X  	          *lockstr[N_LOX] = { "round", "square", "triangular", "oval",
X
X--- 17,23 -----
X  
X  #else /* OVLB */
X  /*	We want the player to be able to learn what key goes in what lock.  */
X! STATIC_OVL const char NEARDATA *keystr[N_LOX] = { "round", "square", "triangular", "oval",
X  			              "octagonal", "hexagonal", "cylindrical",
X  			              "irregular", "conical", "wedge-shaped" },
X  	         NEARDATA *lockstr[N_LOX] = { "round", "square", "triangular", "oval",
X***************
X*** 18,24
X  XSTATIC const char *keystr[N_LOX] = { "round", "square", "triangular", "oval",
X  			              "octagonal", "hexagonal", "cylindrical",
X  			              "irregular", "conical", "wedge-shaped" },
X! 	          *lockstr[N_LOX] = { "round", "square", "triangular", "oval",
X  			              "octagonal", "hexagonal", "wide",
X  			              "notched", "large round", "large square" };
X  #endif /* OVLB */
X
X--- 20,26 -----
X  STATIC_OVL const char NEARDATA *keystr[N_LOX] = { "round", "square", "triangular", "oval",
X  			              "octagonal", "hexagonal", "cylindrical",
X  			              "irregular", "conical", "wedge-shaped" },
X! 	         NEARDATA *lockstr[N_LOX] = { "round", "square", "triangular", "oval",
X  			              "octagonal", "hexagonal", "wide",
X  			              "notched", "large round", "large square" };
X  #endif /* OVLB */
X***************
X*** 23,32
X  			              "notched", "large round", "large square" };
X  #endif /* OVLB */
X  
X! static int FDECL(rnd_class, (int,int));
X! OSTATIC int FDECL(named_key,(const char *));
X! OSTATIC int FDECL(named_box,(const char *));
X! OSTATIC char *FDECL(strprepend,(char *,const char *));
X  static char *FDECL(sitoa,(int));
X  
X  static struct Jitem {
X
X--- 25,35 -----
X  			              "notched", "large round", "large square" };
X  #endif /* OVLB */
X  
X! STATIC_DCL int FDECL(named_key,(const char *));
X! STATIC_DCL int FDECL(named_box,(const char *));
X! STATIC_DCL char *FDECL(strprepend,(char *,const char *));
X! 
X! #ifdef OVL1
X  static char *FDECL(sitoa,(int));
X  #endif /* OVL1 */
X  
X***************
X*** 28,33
X  OSTATIC int FDECL(named_box,(const char *));
X  OSTATIC char *FDECL(strprepend,(char *,const char *));
X  static char *FDECL(sitoa,(int));
X  
X  static struct Jitem {
X  	int item;
X
X--- 31,37 -----
X  
X  #ifdef OVL1
X  static char *FDECL(sitoa,(int));
X+ #endif /* OVL1 */
X  
X  struct Jitem {
X  	int item;
X***************
X*** 29,35
X  OSTATIC char *FDECL(strprepend,(char *,const char *));
X  static char *FDECL(sitoa,(int));
X  
X! static struct Jitem {
X  	int item;
X  	const char *name;
X  } Japanese_items[] = {
X
X--- 33,39 -----
X  static char *FDECL(sitoa,(int));
X  #endif /* OVL1 */
X  
X! struct Jitem {
X  	int item;
X  	const char *name;
X  };
X***************
X*** 32,38
X  static struct Jitem {
X  	int item;
X  	const char *name;
X! } Japanese_items[] = {
X  	{ SHORT_SWORD, "wakizashi" },
X  	{ BROADSWORD, "ninja-to" },
X  	{ GLAIVE, "naginata" },
X
X--- 36,50 -----
X  struct Jitem {
X  	int item;
X  	const char *name;
X! };
X! 
X! #ifndef OVLB
X! 
X! STATIC_DCL struct Jitem Japanese_items[];
X! 
X! #else /* OVLB */
X! 
X! STATIC_OVL struct Jitem Japanese_items[] = {
X  	{ SHORT_SWORD, "wakizashi" },
X  	{ BROADSWORD, "ninja-to" },
X  	{ GLAIVE, "naginata" },
X***************
X*** 40,46
X  	{ LOCK_PICK, "osaku" },
X  	{0, "" }
X  };
X- OSTATIC const char *FDECL(Japanese_item_name,(int));
X  
X  #ifdef OVL1
X  
X
X--- 52,57 -----
X  	{ LOCK_PICK, "osaku" },
X  	{0, "" }
X  };
X  
X  #endif /* OVLB */
X  
X***************
X*** 42,47
X  };
X  OSTATIC const char *FDECL(Japanese_item_name,(int));
X  
X  #ifdef OVL1
X  
X  XSTATIC int
X
X--- 53,62 -----
X  	{0, "" }
X  };
X  
X+ #endif /* OVLB */
X+ 
X+ STATIC_DCL const char *FDECL(Japanese_item_name,(int));
X+ 
X  #ifdef OVL1
X  
X  STATIC_OVL int
X***************
X*** 44,50
X  
X  #ifdef OVL1
X  
X! XSTATIC int
X  named_key(s) register const char *s; {
X  	char tc[BUFSZ];
X  	register int i;
X
X--- 59,65 -----
X  
X  #ifdef OVL1
X  
X! STATIC_OVL int
X  named_key(s) register const char *s; {
X  	char tc[BUFSZ];
X  	register int i;
X***************
X*** 57,63
X  	return(0);
X  }
X  
X! XSTATIC int
X  named_box(s)
X  register const char *s;
X  {
X
X--- 72,78 -----
X  	return(0);
X  }
X  
X! STATIC_OVL int
X  named_box(s)
X  register const char *s;
X  {
X***************
X*** 72,78
X  	return(0);
X  }
X  
X! XSTATIC char *
X  strprepend(s,pref)
X  register char *s;
X  register const char *pref; {
X
X--- 87,93 -----
X  	return(0);
X  }
X  
X! STATIC_OVL char *
X  strprepend(s,pref)
X  register char *s;
X  register const char *pref; {
X***************
X*** 91,97
X  #ifdef LINT	/* static char buf[13]; */
X  	char buf[13];
X  #else
X! 	static char buf[13];
X  #endif
X  	Sprintf(buf, (a < 0) ? "%d" : "+%d", a);
X  	return(buf);
X
X--- 106,112 -----
X  #ifdef LINT	/* static char buf[13]; */
X  	char buf[13];
X  #else
X! 	static char NEARDATA buf[13];
X  #endif
X  	Sprintf(buf, (a < 0) ? "%d" : "+%d", a);
X  	return(buf);
X***************
X*** 107,113
X  #ifdef LINT	/* static char buf[BUFSZ]; */
X  char buf[BUFSZ];
X  #else
X! static char buf[BUFSZ];
X  #endif
X  register struct objclass *ocl = &objects[otyp];
X  register const char *actualn = ocl->oc_name;
X
X--- 122,128 -----
X  #ifdef LINT	/* static char buf[BUFSZ]; */
X  char buf[BUFSZ];
X  #else
X! static char NEARDATA buf[BUFSZ];
X  #endif
X  register struct objclass *ocl = &objects[otyp];
X  register const char *actualn = ocl->oc_name;
X***************
X*** 612,618
X  register struct obj *otmp;
X  char *FDECL((*func), (struct obj *));
X  {
X! 	int savequan;
X  	char *nam;
X  
X  	/* Note: using xname for corpses will not give the monster type */
X
X--- 627,633 -----
X  register struct obj *otmp;
X  char *FDECL((*func), (struct obj *));
X  {
X! 	unsigned savequan;
X  	char *nam;
X  
X  	/* Note: using xname for corpses will not give the monster type */
X***************
X*** 617,623
X  
X  	/* Note: using xname for corpses will not give the monster type */
X  	if (otmp->otyp == CORPSE && func == xname) {
X! 		static char buf[31];
X  
X  		Sprintf(buf, "%s corpse", mons[otmp->corpsenm].mname);
X  		return buf;
X
X--- 632,638 -----
X  
X  	/* Note: using xname for corpses will not give the monster type */
X  	if (otmp->otyp == CORPSE && func == xname) {
X! 		static char NEARDATA buf[31];
X  
X  		Sprintf(buf, "%s corpse", mons[otmp->corpsenm].mname);
X  		return buf;
X***************
X*** 633,639
X  an(str)
X  register const char *str;
X  {
X! 	static char buf[BUFSZ];
X  
X  	buf[0] = '\0';
X  
X
X--- 648,654 -----
X  an(str)
X  register const char *str;
X  {
X! 	static char NEARDATA buf[BUFSZ];
X  
X  	buf[0] = '\0';
X  
X***************
X*** 639,644
X  
X  	if (strncmp(str, "the ", 4))
X  	    if (index(vowels, *str) &&
X  		strncmp(str, "unicorn", 7) &&
X  		strncmp(str, "uranium", 7))
X  		    Strcpy(buf, "an ");
X
X--- 654,660 -----
X  
X  	if (strncmp(str, "the ", 4))
X  	    if (index(vowels, *str) &&
X+ 		strncmp(str, "useful", 6) &&
X  		strncmp(str, "unicorn", 7) &&
X  		strncmp(str, "uranium", 7))
X  		    Strcpy(buf, "an ");
X***************
X*** 737,743
X  const char *oldstr;
X  {
X  	register char *spot;
X! 	static char str[BUFSZ];
X  	const char *excess;
X  	int len;
X  
X
X--- 753,759 -----
X  const char *oldstr;
X  {
X  	register char *spot;
X! 	static char NEARDATA str[BUFSZ];
X  	const char *excess;
X  	int len;
X  
X***************
X*** 876,883
X  	}
X  
X  	/* matzoh/matzot, possible food name */
X! 	if (len >= 6 && !strcmp(spot-5, "matzoh")) {
X! 		*(spot) = 't';
X  		goto bottom;
X  	}
X  
X
X--- 892,900 -----
X  	}
X  
X  	/* matzoh/matzot, possible food name */
X! 	if (len >= 6 && (!strcmp(spot-5, "matzoh")
X! 					|| !strcmp(spot-5, "matzah"))) {
X! 		Strcpy(spot-1, "ot");
X  		goto bottom;
X  	}
X  	if (len >= 5 && (!strcmp(spot-4, "matzo")
X***************
X*** 880,885
X  		*(spot) = 't';
X  		goto bottom;
X  	}
X  
X  	/* child/children (for the wise guys who give their food funny names) */
X  	if (len >= 5 && !strcmp(spot-4, "child")) {
X
X--- 897,907 -----
X  		Strcpy(spot-1, "ot");
X  		goto bottom;
X  	}
X+ 	if (len >= 5 && (!strcmp(spot-4, "matzo")
X+ 					|| !strcmp(spot-5, "matza"))) {
X+ 		Strcpy(spot, "ot");
X+ 		goto bottom;
X+ 	}
X  
X  	/* child/children (for the wise guys who give their food funny names) */
X  	if (len >= 5 && !strcmp(spot-4, "child")) {
X***************
X*** 931,937
X  
X  #ifndef OVLB
X  
X! OSTATIC const struct o_range o_ranges[];
X  
X  #else /* OVLB */
X  
X
X--- 953,959 -----
X  
X  #ifndef OVLB
X  
X! STATIC_DCL const struct o_range o_ranges[];
X  
X  #else /* OVLB */
X  
X***************
X*** 936,942
X  #else /* OVLB */
X  
X  /* wishable subranges of objects */
X! XSTATIC const struct o_range o_ranges[] = {
X  	{ "bag",	TOOL_SYM,   SACK,	    BAG_OF_TRICKS },
X  	{ "gloves",	ARMOR_SYM,  LEATHER_GLOVES, GAUNTLETS_OF_DEXTERITY },
X  	{ "gauntlets",	ARMOR_SYM,  LEATHER_GLOVES, GAUNTLETS_OF_DEXTERITY },
X
X--- 958,964 -----
X  #else /* OVLB */
X  
X  /* wishable subranges of objects */
X! STATIC_OVL const struct o_range NEARDATA o_ranges[] = {
X  	{ "bag",	TOOL_SYM,   SACK,	    BAG_OF_TRICKS },
X  	{ "gloves",	ARMOR_SYM,  LEATHER_GLOVES, GAUNTLETS_OF_DEXTERITY },
X  	{ "gauntlets",	ARMOR_SYM,  LEATHER_GLOVES, GAUNTLETS_OF_DEXTERITY },
X***************
X*** 963,969
X  const char *oldstr;
X  {
X  	char *p, *bp;
X! 	static char str[BUFSZ];
X  
X  	if (!oldstr || !*oldstr) {
X  		impossible("singular of null?");
X
X--- 985,991 -----
X  const char *oldstr;
X  {
X  	char *p, *bp;
X! 	static char NEARDATA str[BUFSZ];
X  
X  	if (!oldstr || !*oldstr) {
X  		impossible("singular of null?");
X***************
X*** 1228,1235
X  
X  sing:
X  	/* Maybe we need a special strcmp() which ignores capitalization and
X! 	 * dashes/spaces/underscores, so the below 3 special cases would be
X! 	 * unnecessary.
X  	 */
X  	/* Alternate spellings (two-handed sword vs. two handed sword) */
X  	if(!strcmp(bp, "two handed sword")) {
X
X--- 1250,1257 -----
X  
X  sing:
X  	/* Maybe we need a special strcmp() which ignores capitalization and
X! 	 * dashes/spaces/underscores, so some of the below special cases would
X! 	 * be unnecessary.
X  	 */
X  	/* Alternate spellings (two-handed sword vs. two handed sword) */
X  	if(!strcmp(bp, "two handed sword")) {
X***************
X*** 1615,1621
X  	return(otmp);
X  }
X  
X! static int
X  rnd_class(first,last)
X  int first,last;
X  {
X
X--- 1637,1643 -----
X  	return(otmp);
X  }
X  
X! int
X  rnd_class(first,last)
X  int first,last;
X  {
X***************
X*** 1629,1635
X  	return 0;
X  }
X  
X! XSTATIC const char *
X  Japanese_item_name(i)
X  int i;
X  {
X
X--- 1651,1657 -----
X  	return 0;
X  }
X  
X! STATIC_OVL const char *
X  Japanese_item_name(i)
X  int i;
X  {
X
X*** src/Old/options.c	Sun Jun  3 13:41:43 1990
X--- src/options.c	Sat May 26 16:05:14 1990
X***************
X*** 1,12 ****
X  /*	SCCS Id: @(#)options.c	3.0	89/11/15
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  #include "hack.h"
X! static boolean set_order;
X  
X  static void FDECL(nmcpy, (char *, const char *, int));
X  void FDECL(escapes,(const char *, char *));
X  
X  void
X  initoptions()
X  {
X--- 1,19 ----
X  /*	SCCS Id: @(#)options.c	3.0	89/11/15
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X+ 
X  #include "hack.h"
X! #include "termcap.h"
X! 
X! static boolean NEARDATA set_order;
X  
X  static void FDECL(nmcpy, (char *, const char *, int));
X  void FDECL(escapes,(const char *, char *));
X  
X+ #ifdef AMIGA_WBENCH
X+ extern int FromWBench;
X+ #endif
X+ 
X  void
X  initoptions()
X  {
X***************
X*** 28,40 ****
X  	nmcpy(pl_fruit, objects[SLIME_MOLD].oc_name, PL_FSIZ);
X  #endif
X  	flags.num_pad = FALSE;
X  #ifdef TEXTCOLOR
X  	flags.use_color = TRUE;
X  #endif
X! #ifdef MSDOS
X! #ifdef DECRAINBOW
X! 	flags.DECRainbow = FALSE;
X  #endif
X  #ifdef DGK
X  	flags.IBMBIOS =
X  #ifdef TOS
X--- 35,50 ----
X  	nmcpy(pl_fruit, objects[SLIME_MOLD].oc_name, PL_FSIZ);
X  #endif
X  	flags.num_pad = FALSE;
X+ 	flags.help = TRUE;
X+ 	flags.IBMgraphics = FALSE;
X+ 	flags.DECgraphics = FALSE;
X  #ifdef TEXTCOLOR
X  	flags.use_color = TRUE;
X  #endif
X! #ifdef AMIFLUSH
X! 	flags.amiflush = FALSE;	/* default to original behaviour */
X  #endif
X+ #ifdef MSDOS
X  #ifdef DGK
X  	flags.IBMBIOS =
X  #ifdef TOS
X***************
X*** 45,55 ****
X  	read_config_file();
X  #endif /* MSDOS */
X  #ifdef MACOS
X- 	flags.standout = TRUE;
X- 	flags.end_around = 2;	/* Mac display routines don't scroll */
X- 	flags.end_top = 4;
X  	read_config_file();
X! 	
X  #endif
X  	if(opts = getenv("NETHACKOPTIONS"))
X  		parseoptions(opts,TRUE);
X--- 55,62 ----
X  	read_config_file();
X  #endif /* MSDOS */
X  #ifdef MACOS
X  	read_config_file();
X! 	flags.standout = TRUE;	
X  #endif
X  	if(opts = getenv("NETHACKOPTIONS"))
X  		parseoptions(opts,TRUE);
X***************
X*** 153,158 ****
X--- 160,227 ----
X  		showsyms[i] = defsyms[i];
X  }
X  
X+ /*
X+  * Use the nice IBM Extended ASCII line-drawing characters (codepage 437).
X+  *
X+  * OS/2 defaults to a multilingual character set (codepage 850, corresponding
X+  * to the ISO 8859 character set.  We should probably do a VioSetCp() call to
X+  * set the codepage to 437.
X+  */
X+ void
X+ assign_ibm_graphics()
X+ {
X+ #ifdef ASCIIGRAPH
X+ 	flags.IBMgraphics = TRUE;	/* not set from command line */
X+ 
X+ 	showsyms[S_vwall] = 0xb3;	/* meta-3, vertical rule */
X+ 	showsyms[S_hwall] = 0xc4;	/* meta-D, horizontal rule */
X+ 	showsyms[S_tlcorn] = 0xda;	/* meta-Z, top left corner */
X+ 	showsyms[S_trcorn] = 0xbf;	/* meta-?, top right corner */
X+ 	showsyms[S_blcorn] = 0xc0;	/* meta-@, bottom left */
X+ 	showsyms[S_brcorn] = 0xd9;	/* meta-Y, bottom right */
X+ 	showsyms[S_crwall] = 0xc5;	/* meta-E, cross */
X+ 	showsyms[S_tuwall] = 0xc1;	/* meta-A, T up */
X+ 	showsyms[S_tdwall] = 0xc2;	/* meta-B, T down */
X+ 	showsyms[S_tlwall] = 0xb4;	/* meta-4, T left */
X+ 	showsyms[S_trwall] = 0xc3;	/* meta-C, T right */
X+ 	showsyms[S_vbeam] = 0xb3;	/* meta-3, vertical rule */
X+ 	showsyms[S_hbeam] = 0xc4;	/* meta-D, horizontal rule */
X+ 	showsyms[S_ndoor] = 0xfa;
X+ 	showsyms[S_vodoor] = 0xfe;	/* meta-~, small centered square */
X+ 	showsyms[S_hodoor] = 0xfe;	/* meta-~, small centered square */
X+ 	showsyms[S_room] = 0xfa;	/* meta-z, centered dot */
X+ 	showsyms[S_pool] = 0xf7;	/* meta-w, approx. equals */
X+ #endif  /* ASCIIGRAPH */
X+ }
X+ 
X+ /* Use VT100 graphics for terminals that have them */
X+ void
X+ assign_dec_graphics()
X+ {
X+ #ifdef TERMLIB
X+ 	flags.DECgraphics = TRUE;	/* not set from command line */
X+ 
X+ 	showsyms[S_vwall] = 0xf8;	/* vertical rule */
X+ 	showsyms[S_hwall] = 0xf1;	/* horizontal rule */
X+ 	showsyms[S_tlcorn] = 0xec;	/* top left corner */
X+ 	showsyms[S_trcorn] = 0xeb;	/* top right corner */
X+ 	showsyms[S_blcorn] = 0xed;	/* bottom left */
X+ 	showsyms[S_brcorn] = 0xea;	/* bottom right */
X+ 	showsyms[S_crwall] = 0xee;	/* cross */
X+ 	showsyms[S_tuwall] = 0xf6;	/* T up */
X+ 	showsyms[S_tdwall] = 0xf7;	/* T down */
X+ 	showsyms[S_tlwall] = 0xf5;	/* T left */
X+ 	showsyms[S_trwall] = 0xf4;	/* T right */
X+ 	showsyms[S_vbeam] = 0xf8;	/* vertical rule */
X+ 	showsyms[S_hbeam] = 0xf1;	/* horizontal rule */
X+ 	showsyms[S_ndoor] = 0xfe;
X+ 	showsyms[S_vodoor] = 0xe1;	/* small centered square */
X+ 	showsyms[S_hodoor] = 0xe1;	/* small centered square */
X+ 	showsyms[S_room] = 0xfe;	/* centered dot */
X+ 	showsyms[S_pool] = 0xe0;	/* diamond */
X+ #endif  /* TERMLIB */
X+ }
X+ 
X  void
X  parseoptions(opts, from_env)
X  register char *opts;
X***************
X*** 233,238 ****
X--- 302,340 ----
X  		return;
X  	}
X  
X+ 	if (!strncmp(opts, "hel", 3)) {
X+ 		flags.help = !negated;
X+ 		return;
X+ 	}
X+ 
X+ 	if (!strncmp(opts, "IBMg", 4)) {
X+ 		if(from_env) {
X+ 		    flags.IBMgraphics = !negated;
X+ 		    if(flags.IBMgraphics) assign_ibm_graphics();
X+ 		} else {
X+ #ifdef MSDOS
X+ 		  pline("\"IBMgraphics\" settable only from %s.", configfile);
X+ #else
X+ 		  pline("IBMgraphics can be set only from NETHACKOPTIONS.");
X+ #endif
X+ 		}
X+ 		return;
X+ 	}
X+ 
X+ 	if (!strncmp(opts, "DEC", 3)) {
X+ 		if(from_env) {
X+ 		    flags.DECgraphics = !negated;
X+ 		    if(flags.DECgraphics) assign_dec_graphics();
X+ 		} else {
X+ #ifdef MSDOS
X+ 		  pline("\"DECgraphics\" settable only from %s.", configfile);
X+ #else
X+ 		  pline("DECgraphics can be set only from NETHACKOPTIONS.");
X+ #endif
X+ 		}
X+ 		return;
X+ 	}
X+ 
X  #ifdef TEXTCOLOR
X  	if (!strncmp(opts, "col", 3)) {
X  		flags.use_color = !negated;
X***************
X*** 239,247 ****
X  		return;
X  	}
X  #endif
X! 
X  #ifdef DGK
X! 	if (!strncmp(opts, "IBM", 3)) {
X  		flags.IBMBIOS = !negated;
X  		return;
X  	}
X--- 341,354 ----
X  		return;
X  	}
X  #endif
X! #ifdef AMIFLUSH
X! 	if (!strncmp(opts, "flus", 4)) {
X! 		flags.amiflush = !negated;
X! 		return;
X! 	}
X! #endif
X  #ifdef DGK
X! 	if (!strncmp(opts, "IBM_", 4)) {
X  		flags.IBMBIOS = !negated;
X  		return;
X  	}
X***************
X*** 253,265 ****
X  			pline("\"rawio\" settable only from %s.", configfile);
X  		return;
X  	}
X- 
X- #ifdef DECRAINBOW
X- 	if (!strncmp(opts, "DEC", 3)) {
X- 		flags.DECRainbow = !negated;
X- 		return;
X- 	}
X- #endif /* DECRAINBOW */
X  #endif
X  
X  	if (!strncmp(opts, "sort", 4)) {
X--- 360,365 ----
X***************
X*** 335,340 ****
X--- 435,446 ----
X  	if (!strncmp(opts, "name", 4)) {
X  		if(!from_env) {
X  #ifdef MSDOS
X+ # ifdef AMIGA_WBENCH
X+ 		 if(FromWBench){
X+ 		  pline("\"name\" settable only from %s or in icon.",
X+ 			configfile);
X+ 		 } else
X+ # endif
X  		  pline("\"name\" settable only from %s.", configfile);
X  #else
X  		  pline("The playername can be set only from NETHACKOPTIONS.");
X***************
X*** 413,418 ****
X--- 519,530 ----
X  	if (!strncmp(opts, "dog", 3)) {
X  		if(!from_env) {
X  #ifdef MSDOS
X+ # ifdef AMIGA_WBENCH
X+ 		if(FromWBench){
X+ 		 pline("\"dogname\" settable only from %s or in icon.",
X+ 			configfile);
X+ 		} else
X+ # endif
X  		  pline("\"dogname\" settable only from %s.", configfile);
X  #else
X  		  Your("dog's name can be set only from NETHACKOPTIONS.");
X***************
X*** 427,432 ****
X--- 539,550 ----
X  	if (!strncmp(opts, "cat", 3)) {
X  		if(!from_env) {
X  #ifdef MSDOS
X+ # ifdef AMIGA_WBENCH
X+ 		if(FromWBench){
X+ 		 pline("\"catname\" settable only from %s or in icon.",
X+ 			configfile);
X+ 		} else
X+ # endif
X  		  pline("\"catname\" settable only from %s.", configfile);
X  #else
X  		  Your("cat's name can be set only from NETHACKOPTIONS.");
X***************
X*** 505,510 ****
X--- 623,629 ----
X  #define EXPLORE_BOX 4
X  #define FEM_BOX 5
X  #define NEWS_BOX 6
X+ #define MIN_OK_CHECKBOX 7
X  #define FIXINV_BOX 7
X  #define TOMB_BOX 8
X  #define TIME_BOX 9
X***************
X*** 528,533 ****
X--- 647,654 ----
X  #define END_AROUND 27
X  #define FRUIT_TEXT 35
X  #define PACK_TEXT 34
X+ #define ENABLE_INFO_BOX 38
X+ #define ALT_CURS_BOX 41
X  #define ITEMTEXT(item,text) {GetDItem(optionDlg,item,&type,&ItemHndl,&box); \
X  					         (void)CtoPstr(text); \
X  					         SetIText(ItemHndl,text);\
X***************
X*** 546,552 ****
X  					tmp_name[tmp_name[0]+1] = 0;\
X  					if (tmp_name[0] > maxsize)\
X  						tmp_name[0] = maxsize;}
X! 	static boolean *flag_ptrs[20] = {0, 0, 0, 0, &flags.explore,
X  			&flags.female, &flags.nonews,&flags.invlet_constant,
X  			&flags.notombstone, &flags.time, &flags.verbose,
X  			&flags.silent, 0, &flags.standout, &flags.sortpack,
X--- 667,673 ----
X  					tmp_name[tmp_name[0]+1] = 0;\
X  					if (tmp_name[0] > maxsize)\
X  						tmp_name[0] = maxsize;}
X! 	static boolean NEARDATA *flag_ptrs[20] = {0, 0, 0, 0, &flags.explore,
X  			&flags.female, &flags.nonews,&flags.invlet_constant,
X  			&flags.notombstone, &flags.time, &flags.verbose,
X  			&flags.silent, 0, &flags.standout, &flags.sortpack,
X***************
X*** 558,563 ****
X--- 679,685 ----
X  			&flags.pickup, &flags.confirm,
X  			&flags.safe_dog, &flags.no_rest_on_space};
X  	extern short macflags;
X+ 	extern short altCurs;
X  	short dlgItem, type;
X  	Rect box;
X  	extern WindowPtr	HackWindow;
X***************
X*** 565,611 ****
X  	unsigned num;
X  	char *op;
X  	char tmp_name[256];
X- 	char savename[PL_NSIZ];
X- 	char savedog[63];
X- 	char savecat[63];
X- 	char savefruit[PL_FSIZ];
X- 	char saveorder[20];
X  	DialogRecord	dlgR;
X  	DialogPtr optionDlg;
X  	DialogTHndl	th, centreDlgBox();
X  	boolean done = FALSE;
X      short savemacflags = macflags;
X- 	struct flag saveflags;
X  	register char	*sp, *tmp;
X  
X  	SetCursor(&ARROW_CURSOR);
X- 
X- 	BlockMove(&flags, &saveflags, sizeof(struct flag));
X  	
X  	th = centreDlgBox(130, FALSE);
X  
X  	optionDlg = GetNewDialog(130, (Ptr)&dlgR, (WindowPtr)-1);
X  /* set initial values of text items */
X- 	nmcpy(savename,plname,sizeof(plname)-1);
X  	ITEMTEXT(PLAYER_NAME,plname);
X! 	if(*dogname){
X! 		nmcpy(savedog,dogname,62);
X! 		ITEMTEXT(DOG_NAME,dogname);
X! 	}
X! 	if(*catname){
X! 		nmcpy(savecat,catname,62);
X! 		ITEMTEXT(CAT_NAME,catname);
X! 	}
X! #ifdef TUTTI_FRUTTI
X! 	if(*pl_fruit){
X! 		nmcpy(savefruit,pl_fruit,PL_FSIZ);
X! 		ITEMTEXT(FRUIT_NAME,pl_fruit);
X! 	}
X  #else
X  	HIDETEXT(FRUIT_NAME);
X  	HIDETEXT(FRUIT_TEXT);
X  #endif
X- 	nmcpy(saveorder,inv_order,strlen(inv_order)+1);
X  	ITEMTEXT(PACKORDER,inv_order);
X  /* set initial values of record items */
X  	Sprintf(tmp_name,"%u",flags.end_top);
X--- 687,729 ----
X  	unsigned num;
X  	char *op;
X  	char tmp_name[256];
X  	DialogRecord	dlgR;
X  	DialogPtr optionDlg;
X  	DialogTHndl	th, centreDlgBox();
X  	boolean done = FALSE;
X      short savemacflags = macflags;
X  	register char	*sp, *tmp;
X+ 	char a_k_a[PL_NSIZ];
X+ 	boolean fairsex, debugger, explorer;
X  
X+ /* Option handling:
X+ 	Startup: read options from Prefs (making changes!)
X+ 	Save exit: write current options to prefs
X+ 	Cancel exit: revert to options as defined in Prefs
X+ 	Use exit: allow changes. erased at next dialog
X+ */
X+ 	strncpy(a_k_a, plname, strlen(plname));
X+ 	a_k_a[(int)strlen(plname)] = '\0';
X+ 	fairsex = flags.female;
X+ 	debugger = flags.debug;
X+ 	explorer = flags.explore;
X+ 	read_config_file();
X+ 	macflags = savemacflags;
X  	SetCursor(&ARROW_CURSOR);
X  	
X  	th = centreDlgBox(130, FALSE);
X  
X  	optionDlg = GetNewDialog(130, (Ptr)&dlgR, (WindowPtr)-1);
X  /* set initial values of text items */
X  	ITEMTEXT(PLAYER_NAME,plname);
X! 	if(*dogname) ITEMTEXT(DOG_NAME,dogname);
X! 	if(*catname) ITEMTEXT(CAT_NAME,catname);
X! #ifdef TUTTI_FRUTTI
X! 	if(*pl_fruit) ITEMTEXT(FRUIT_NAME,pl_fruit);
X  #else
X  	HIDETEXT(FRUIT_NAME);
X  	HIDETEXT(FRUIT_TEXT);
X  #endif
X  	ITEMTEXT(PACKORDER,inv_order);
X  /* set initial values of record items */
X  	Sprintf(tmp_name,"%u",flags.end_top);
X***************
X*** 621,630 ****
X  				HIDEITEM(NEWS_BOX);
X  				break;
X  #endif
X- 			case TOMB_BOX:
X- 			case REST_SPACE_BOX:
X- 				SetCtlValue(ItemHndl,!(*(flag_ptrs[dlgItem])));
X- 				break;
X  			case AUTOZOOM_BOX:
X  				SetCtlValue(ItemHndl,macflags & fZoomOnContextSwitch);
X  				break;
X--- 739,744 ----
X***************
X*** 637,646 ****
X  				SetCtlValue(ItemHndl,*(flag_ptrs[dlgItem]));
X  		}
X  	}
X  	SelIText(optionDlg, PLAYER_NAME, 0, 32767);
X- 	
X  	ShowWindow(optionDlg);
X! 	GetDItem(optionDlg, OK, &type, &ItemHndl, &box);
X  	SetPort (optionDlg);
X  	PenSize(3, 3);
X  	InsetRect (&box, -4, -4);
X--- 751,764 ----
X  				SetCtlValue(ItemHndl,*(flag_ptrs[dlgItem]));
X  		}
X  	}
X+ 	GetDItem(optionDlg, ENABLE_INFO_BOX, &type, &ItemHndl, &box);
X+ 	SetCtlValue(ItemHndl, (int)flags.help);
X+ 	GetDItem(optionDlg, ALT_CURS_BOX, &type, &ItemHndl, &box);
X+  	SetCtlValue(ItemHndl, (short)altCurs);
X+ 
X  	SelIText(optionDlg, PLAYER_NAME, 0, 32767);
X  	ShowWindow(optionDlg);
X! 	GetDItem(optionDlg, OK_BUTTON, &type, &ItemHndl, &box);
X  	SetPort (optionDlg);
X  	PenSize(3, 3);
X  	InsetRect (&box, -4, -4);
X***************
X*** 649,663 ****
X  	while(!done) {
X  		ModalDialog((ProcPtr)0, &dlgItem);
X  		GetDItem(optionDlg, dlgItem, &type, &ItemHndl, &box);
X! 		if (dlgItem >= MIN_CHECKBOX && dlgItem <= MAX_CHECKBOX) {
X  			SetCtlValue(ItemHndl, ! GetCtlValue (ItemHndl));
X- 			if (dlgItem != AUTOZOOM_BOX)
X- 				*(flag_ptrs[dlgItem]) = !*(flag_ptrs[dlgItem]);
X- 			else
X- 				macflags ^= fZoomOnContextSwitch;
X  		}
X  		else switch(dlgItem){
X  			case SAVE_BUTTON:
X  				GETTEXT(PLAYER_NAME,PL_NSIZ-1);
X  				strncpy(plname, tmp_name, tmp_name[0]+1);
X  				(void)PtoCstr (plname);
X--- 767,794 ----
X  	while(!done) {
X  		ModalDialog((ProcPtr)0, &dlgItem);
X  		GetDItem(optionDlg, dlgItem, &type, &ItemHndl, &box);
X! 		if ((dlgItem >= MIN_CHECKBOX && dlgItem <= MAX_CHECKBOX)
X! 			|| dlgItem == ENABLE_INFO_BOX || dlgItem == ALT_CURS_BOX) {
X  			SetCtlValue(ItemHndl, ! GetCtlValue (ItemHndl));
X  		}
X  		else switch(dlgItem){
X  			case SAVE_BUTTON:
X+ 				for(dlgItem = MIN_CHECKBOX; dlgItem <= MAX_CHECKBOX; dlgItem++) {
X+ 					GetDItem(optionDlg, dlgItem, &type, &ItemHndl, &box);
X+ 					if (dlgItem == AUTOZOOM_BOX) {
X+ 						if ((boolean)GetCtlValue(ItemHndl)) {
X+ 							macflags |= fZoomOnContextSwitch;
X+ 						} else {
X+ 							macflags &= ~fZoomOnContextSwitch;
X+ 						}
X+ 					} else {
X+ 						*(flag_ptrs[dlgItem]) = GetCtlValue(ItemHndl);
X+ 					}
X+ 				}
X+ 				GetDItem(optionDlg, ENABLE_INFO_BOX, &type, &ItemHndl, &box);
X+ 				flags.help = GetCtlValue(ItemHndl);
X+ 				GetDItem(optionDlg, ALT_CURS_BOX, &type, &ItemHndl, &box);
X+ 				altCurs = (short)GetCtlValue(ItemHndl);
X  				GETTEXT(PLAYER_NAME,PL_NSIZ-1);
X  				strncpy(plname, tmp_name, tmp_name[0]+1);
X  				(void)PtoCstr (plname);
X***************
X*** 717,736 ****
X  					} else op++;
X  				}
X  				flags.end_around = num;
X  				write_opts();
X! 				nmcpy(dogname,savedog,62);
X! 				nmcpy(catname,savecat,62);
X! 				nmcpy(plname,savename,sizeof(plname)-1);
X! #ifdef TUTTI_FRUTTI
X! 				nmcpy(pl_fruit,savefruit,PL_FSIZ-1);
X! #endif
X! 				nmcpy(inv_order,saveorder,strlen(inv_order)+1);
X  			case CANCEL_BUTTON:
X- 				flags = saveflags;
X- 				macflags = savemacflags;
X  				done = TRUE;
X  				break;
X  			case OK_BUTTON:
X  				GETTEXT(END_TOP,5);
X  				op = tmp_name+1;
X  				while(*op) {
X--- 848,877 ----
X  					} else op++;
X  				}
X  				flags.end_around = num;
X+ 				
X  				write_opts();
X! 				done = TRUE;
X! 				break;
X  			case CANCEL_BUTTON:
X  				done = TRUE;
X  				break;
X  			case OK_BUTTON:
X+ 				for (dlgItem = MIN_OK_CHECKBOX; dlgItem <= MAX_CHECKBOX; dlgItem++) {
X+ 					GetDItem(optionDlg, dlgItem, &type, &ItemHndl, &box);
X+ 					if (dlgItem == AUTOZOOM_BOX) {
X+ 						if ((boolean)GetCtlValue(ItemHndl)) {
X+ 							macflags |= fZoomOnContextSwitch;
X+ 						} else {
X+ 							macflags &= ~fZoomOnContextSwitch;
X+ 						}
X+ 					} else {
X+ 						*(flag_ptrs[dlgItem]) = GetCtlValue(ItemHndl);
X+ 					}
X+ 				}
X+ 				GetDItem(optionDlg, ENABLE_INFO_BOX, &type, &ItemHndl, &box);
X+ 				flags.help = GetCtlValue(ItemHndl);
X+ 				GetDItem(optionDlg, ALT_CURS_BOX, &type, &ItemHndl, &box);
X+ 				altCurs = (short)GetCtlValue(ItemHndl);
X  				GETTEXT(END_TOP,5);
X  				op = tmp_name+1;
X  				while(*op) {
X***************
X*** 757,765 ****
X  				(void)fruitadd(tmp_name);
X  				nmcpy(pl_fruit,tmp_name,PL_FSIZ-1);
X  #endif
X- 				nmcpy(dogname,savedog,62);
X- 				nmcpy(catname,savecat,62);
X- 				nmcpy(plname,savename,sizeof(plname)-1);
X  				GETTEXT(PACKORDER,19);
X  				op = tmp_name+1;
X  				/* Missing characters in new order are filled in at the end 
X--- 898,903 ----
X***************
X*** 780,792 ****
X  					}
X  				Strcpy(inv_order, tmp);
X  				free((genericptr_t)tmp);
X- 				flags.female = saveflags.female;
X- 				flags.explore = saveflags.explore;
X  				done = TRUE;
X  				break;
X  			default:;
X  		}
X  	} 
X  	HideWindow(optionDlg);
X  	DisposDialog (optionDlg);
X  	SetPort (HackWindow);
X--- 918,933 ----
X  					}
X  				Strcpy(inv_order, tmp);
X  				free((genericptr_t)tmp);
X  				done = TRUE;
X  				break;
X  			default:;
X  		}
X  	} 
X+ 	flags.explore = explorer;
X+ 	flags.debug = debugger;
X+ 	flags.female = fairsex;
X+ 	strncpy(plname, a_k_a, strlen(a_k_a));
X+ 	plname[(int)strlen(a_k_a)] = '\0';
X  	HideWindow(optionDlg);
X  	DisposDialog (optionDlg);
X  	SetPort (HackWindow);
X***************
X*** 803,811 ****
X  	    if (flags.rawio) Strcat(buf,"rawio,");
X  	    if (flags.IBMBIOS) Strcat(buf,"IBM_BIOS,");
X  #endif /* DGK */
X- #ifdef DECRAINBOW
X- 	    if (flags.DECRainbow) Strcat(buf,"DEC_Rainbow,");
X- #endif /* DECRAINBOW */
X  #else /* MSDOS */
X  	    Strcpy(buf,"NETHACKOPTIONS=");
X  	    if(flags.standout) Strcat(buf,"standout,");
X--- 944,949 ----
X***************
X*** 829,834 ****
X--- 967,978 ----
X  #ifdef TEXTCOLOR
X  	    if (flags.use_color) Strcat(buf, "color,");
X  #endif
X+ #ifdef AMIFLUSH
X+ 	    if (flags.amiflush) Strcat(buf, "flush,");
X+ #endif
X+ 	    if (!flags.help) Strcat(buf, "nohelp,");
X+ 	    if (flags.IBMgraphics) Strcat(buf,"IBMgraphics,");
X+ 	    if (flags.DECgraphics) Strcat(buf,"DECgraphics,");
X  	    if (flags.confirm) Strcat(buf,"confirm,");
X  	    if (flags.safe_dog) Strcat(buf,"safe_pet,");
X  	    if (flags.pickup) Strcat(buf,"pickup,");
X***************
X*** 875,880 ****
X--- 1019,1029 ----
X  	if(page_line("") || page_line(buf) || page_line(""))	 goto quit;
X  
X  #ifdef MSDOS
X+ # ifdef AMIGA_WBENCH
X+ 	if(FromWBench){
X+ 	 Sprintf(buf,"Set options as OPTIONS= in %s or in icon;",configfile);
X+ 	} else
X+ # endif
X  	Sprintf(buf, "To set options use OPTIONS=<options> in %s;", configfile);
X  	Page_line(buf);
X  #else
X***************
X*** 886,897 ****
X  	Page_line("");
X  
X  	Page_line("Boolean options (which can be negated by prefixing them with '!' or \"no\"):");
X  #ifdef MSDOS
X- # ifdef DECRAINBOW
X- 	Next_opt("DEC_Rainbow, ");
X- # endif
X  	Next_opt("IBM_BIOS, ");
X  #endif
X  #ifdef TEXTCOLOR
X  	Next_opt("color, ");
X  #endif
X--- 1035,1048 ----
X  	Page_line("");
X  
X  	Page_line("Boolean options (which can be negated by prefixing them with '!' or \"no\"):");
X+ 	Next_opt("DECgraphics, ");
X  #ifdef MSDOS
X  	Next_opt("IBM_BIOS, ");
X  #endif
X+ 	Next_opt("IBMgraphics, ");
X+ #ifdef AMIFLUSH
X+ 	Next_opt("flush, ");
X+ #endif
X  #ifdef TEXTCOLOR
X  	Next_opt("color, ");
X  #endif
X***************
X*** 900,905 ****
X--- 1051,1057 ----
X  #ifdef UNIX
X  	Next_opt("ignintr, ");
X  #endif
X+ 	Next_opt("help, ");
X  #ifdef NEWS
X  	Next_opt("news, ");
X  #endif
X***************
X*** 923,928 ****
X--- 1075,1081 ----
X  	Page_line("Compound options:");
X  	Page_line("`name'      - your character's name (e.g., name:Merlin-W),");
X  	Page_line("`dogname'   - the name of your (first) dog (e.g., dogname:Fang),");
X+ 	Page_line("`catname'   - the name of your (first) cat (e.g., catname:Tabby),");
X  
X  	Page_line("`packorder' - the inventory order of the items in your pack");
X  	Sprintf(buf, "              (currently, packorder:%s ),", inv_order);
X
END_OF_FILE
if test 45498 -ne `wc -c <'patch8.05'`; then
    echo shar: \"'patch8.05'\" unpacked with wrong size!
fi
# end of 'patch8.05'
fi
echo shar: End of archive 1 \(of 24\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 24 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
