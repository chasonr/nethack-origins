Path: utzoo!attcan!uunet!zephyr.ens.tek.com!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v10i041:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Patch8w
Message-ID: <5749@tekred.CNA.TEK.COM>
Date: 5 Jun 90 18:04:32 GMT
Sender: news@tekred.CNA.TEK.COM
Lines: 1448
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 10, Issue 41
Archive-name: NetHack3/Patch8w
Patch-To: NetHack3: Volume 7, Issue 56-93



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 23 (of 24)."
# Contents:  Install.dos Install.vms others/Makefile.os2
#   others/ovlmgr.doc vms/spec_lev.com
# Wrapped by billr@saab on Mon Jun  4 15:40:34 1990
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo shar: Extracting \"'Install.dos'\" \(13860 characters\)
sed "s/^X//" >'Install.dos' <<'END_OF_FILE'
X	Instructions for compiling and installing NetHack 3.0
X		   on an MS-DOS, TOS, or OS/2 system
X	=====================================================
X	    (or, How to make PC, ST, and OS/2 NetHack 3.0)
X		      Last revision: 22 May 1990
X
X    Credit for ST and OS/2 NetHack 3.0 goes to Eric Smith and Timo Hakulinen,
X    respectively.  Additional credit should be given to Steve Creps and
X    Mike Threepoint for PC NetHack.
X
X*** Note: if you intend to compile NetHack on an MS-DOS PC using OVERLAY, 
X    please turn to the instructions in Install.ovl.  The overlay version is
X    currently available only for MSC.
X
X1.  Make sure all the NetHack files are in the appropriate directory structure.
X    You should have a main directory with subdirectories src, include, auxil,
X    others, amiga, mac, and vms.  If you do not follow this structure, the
X    Makefile will not function properly.
X
X    All the shared and UNIX-specific .c files and the source Makefile belong
X    in src; all the PC .c files and make files belong in others; all the .h
X    files belong in include; other assorted files belong in auxil.  We will
X    not need any of the files from the amiga, mac, and vms directories.
X
X    If you downloaded or ftp'd the sources from a UNIX system, the lines
X    will probably end in UNIX-style newlines, instead of the carriage
X    return and line feed pairs used by DOS and OS/2.  Turbo C 2.0 in
X    particular dislikes these; you'll have to convert them (with a utility
X    like Rahul Dhesi's "flip").  Also, every file should end with an empty
X    line, because both Microsoft C has a habit of ignoring the last line of
X    each file. (TOS compilers generally don't have either problem).
X
X2.  Copy the .c files from the others directory to your src directory
X    based on the following decisions.  (You will probably want to include
X    all of these files.)
X
X    You will definitely need pc*.c and msdos.c.
X
X    The file termcap.uu is the fixed version of the Fred Fish termcap library.
X    You will need to run a uudecode utility on it to generate the file
X    termcap.arc.  termcap.arc contains several files of termcap routines.
X    Using them with NetHack involves very little knowledge of the UNIX concept
X    of a termcap database; mostly you need to know enough to set a TERM
X    environment variable.  You can unarc termcap.arc here in the others
X    directory, but if you are going to use it, it is probably best to unarc a
X    copy in the src directory.  That way you will not miss copying any
X    files over.  Wherever you unarc it, get rid of the included makefile
X    since a better version has been provided as Makefile.lib.
X
X    random.c is only needed if you want the high-quality random number
X    generation routines.
X
X    trampoli.c and ovlmgr.obj files are needed for the MS-DOS overlays.
X    You may ignore these.
X
X    TOS users should use others/lev_lex.c instead of src/lev_lex.c.
X    MS-DOS users should be able to use either, but the one in src
X    is smaller.  If you have flex or some other lex work-alike, use
X    that to produce lev_lex.c from lev_comp.l.
X
X    Obviously, TOS users don't need the MS-DOS overlay functions.
X    Moreover, the GCC "curses" library has termcap routines built
X    in, so if you have this you don't need termcap.arc.
X
X3.  Now look at Makefile.* in your others directory.  Consult the list below
X    and pick out the makefile most appropriate to your system.  Rename this
X    file to "Makefile" (no extension), and move it into your src directory.
X
X    DOS:
X	Microsoft C 5.0+	Makefile.msc
X	Microsoft C 4.0 	Makefile.pc
X	Turbo C 2.0		Makefile.tcc
X    OS/2:
X	Microsoft C 5.1 	Makefile.os2
X    TOS:
X	GCC 1.34		Makefile.st
X
X    The PC NetHack makefiles are set up for NDMAKE, a public domain
X    "make" utility.  Both Microsoft's and Borland's "make" leave much to
X    be desired.  It is worth the extra effort to get NDMAKE if you don't
X    already have it.  Among other things, NDMAKE automatically generates
X    link response files when the link command involves so many objects
X    that the command would become longer than DOS can handle.  If you must
X    use Microsoft's or Borland's "make", you'll need to edit the makefile
X    into a form your make can use, and add instructions to generate a link
X    response file.
X
X    Makefile.os2 can also be used with Microsoft NMAKE, which is shipped with
X    new versions of MS languages.  This "make", although slightly incompatible
X    with NDMAKE, is powerful enough to make NetHack.  Since NDMAKE only works
X    in DOS, the only way to compile NetHack in OS/2 currently is to use NMAKE.
X    However, when cross-compiling for OS/2 in DOS, NDMAKE is a better choice
X    because it requires less RAM for itself.  See Makefile.os2 for more
X    information.
X
X    The ST NetHack makefile should work with either the widely available
X    PD make, or (much better) GNU Make.
X
X    If you're using a different compiler, you will have to adapt one of
X    the makefiles to your needs.  In particular, change the CC and CFLAGS
X    macros to your C compiler's file name and the parameters to pass it.
X
X    For DOS users, if you are going to be constructing the Fred Fish termlib
X    you will need the Makefile.lib.  Copy this to your source directory too,
X    and do not change its name.
X
X    Makefile.top in the top directory and Makefile.aux(il) in the
X    auxil directory are for UNIX NetHack.  You may delete them.
X
X4.  Now go to the include subdirectory to edit a couple of the header files
X    there.
X
X    First edit config.h according to the comments to match your system and
X    desired set of features.  Mostly you need to check the WIZARD option,
X    make sure the HACKDIR is set properly, and check TERMLIB and COMPRESS.
X
X    Also edit pcconf.h for PC or OS/2 NetHack, or tosconf.h for ST NetHack.
X    pcconf.h should not need much editing.  If you are not going to include
X    random.c or termcap.uu you will need to comment out RANDOM or TERMLIB
X    respectively.  You will definitely need to comment out OVERLAY.
X
X    Commenting out the #define TERMLIB in pcconf.h/tosconf.h to disable
X    use of termcap routines (relying on the ANSI_DEFAULT feature) will make
X    your job a bit easier.  However, you can compile with both and simply
X    not set your TERM variable if you do not wish to use the termcap file
X    settings.
X
X    ST and OS/2 NetHackers can skip to the next section, since the entire game
X    will fit in less than one megabyte.
X
X PC NetHackers:
X
X    To compile under MS-DOS, you must either produce an overlaid executable or
X    make some very difficult decisions about which features to include.
X
X    The base size of a PC NetHack executable, with no extra features or
X    overlays, will be around 570 (or better) kilobytes.  Anything over 590K
X    is likely not to work.  Here's an incomplete and outdated list of the
X    approximate costs of various additional features in terms of executable
X    size, using Microsoft C:
X
X	WIZARD		    3K
X	LOGFILE
X	NEWS
X	COMPRESS	    2K
X	ZEROCOMP
X	CHDIR
X
X	POLYSELF	   31K
X	THEOLOGY	   11K
X	SOUNDS		    6K
X	KICK
X
X	THRONES 	    3K
X	FOUNTAINS	    2K
X	SINKS		    5K
X	ALTARS		    4K
X
X	WALLIFIED_MAZE	    1K
X	REINCARNATION	    7K
X	STRONGHOLD	   13K
X
X	ORACLE
X	MEDUSA
X	KOPS
X	ARMY		    1K
X	WORM
X	GOLEMS		    2K
X	INFERNO
X	SEDUCE
X	TOLKIEN
X	PROBING 	    1K
X	WALKIES 	    4K
X	SHIRT
X	MUSIC		    6K
X	TUTTI_FRUTTI
X	SPELLS		   10K
X	NAMED_ITEMS
X
X	ELBERETH	    3K
X	EXPLORE_MODE	    2K
X	HARD
X
X	REDO		    1K
X	COM_COMPL	    1K
X	CLIPPING
X
X	DGK		    7K
X	TERMLIB
X	RANDOM		    1K
X	SHELL
X	TEXTCOLOR	    1K
X
X    Using Turbo C, we eked by with just WIZARD, ZEROCOMP, BITFIELDS, ELBERETH,
X    HARD, REDO, DGK and TEXTCOLOR.
X
X5.  If you're using a compiler not in the list in step 3, you may want to look
X    through system.h, in the include directory.  This file matches the return
X    and parameter types for system calls and library routines with various
X    flavors of compilers and operating systems.  Leaving this file alone is
X    unlikely to cause problems, but if you get compile errors with any
X    functions in the standard library, it's worth checking the declarations
X    there.
X
X6.  If you want to change the high score list behavior, examine the top of
X    topten.c, in the src directory.  You may want to change the definitions of
X    PERSMAX, POINTSMIN, and ENTRYMAX.  I set POINTSMIN to 51 and ENTRYMAX to
X    50 to keep the size of the score list down.
X
X7.  Go to the src directory and edit the top of your Makefile.  Be sure the
X    directory you want the game installed in actually exists.
X
X    If you elected not to use the high-quality BSD random number routines by
X    commenting out RANDOM in pcconf.h or tosconf.h, comment out (or set equal
X    to nothing) the RANDOM macro in your Makefile.
X
X    If you elected to use Fred Fish's termcap library (bundled in as
X    termcap.arc), you will have to generate termcap.lib from those sources
X    by typing make -f makefile.lib termlib.lib.  DOS / OS/2 users must set the
X    TERMLIB option in Makefile.msc / Makefile.os2 to link in the resulting
X    termlib.lib.
X
X    If you are recompiling after patching your sources, or if you got your
X    files from somewhere other than the official distribution, "touch
X    makedefs.c" to ensure that certain files (onames.h and pm.h) are remade,
X    lest potentially troublesome timestamps fool "make".
X
X8.  Now, enter "make all", and take a long siesta; your computer will be
X    occupied for a long time.  If all goes well, you will get an executable.
X    If you tried to compile in too many features, you will probably get a
X    dysfunctional executable, and will have to start over.
X
X	Hint:  If you're short on memory, you might enter "make -n all
X	>script.bat", and then in DOS enter "script", or in TOS use the Gulam
X	command "source script.bat".  GCC users will be short on memory if
X	they only have 2 megabytes. Indeed, some files will not compile in
X	2 megabytes with the GCC 1.36; for these you'll either have to turn
X	off the -O option or use an earlier version of the GCC.
X
X9.  Make sure the support files-- data, rumors, cmdhelp, opthelp, help, hh,
X    history, license, and oracles (if ORACLES was #define'd)-- were copied
X    to the game directory.  If not, move them there from the auxil directory
X    yourself.  rumors can be created manually by entering "makedefs -r";
X    data by entering "makedefs -d".
X
X    If you compiled in the compiled levels (if STRONGHOLD was #define'd), make
X    sure castle, tower?, and possibly endgame are there, too.  They can be
X    created manually by entering "lev_comp filename.des", where filename.des
X    is the appropriate description file (found in the auxil directory).
X
X10. Go to the others directory.  Copy NetHack.cnf, or Atari.cnf for TOS, to
X    your game directory as "NetHack.cnf".  Edit it to reflect your particular
X    setup and personal preferences, following the comments.
X
X    If you compiled in the TERMLIB feature, also move the "termcap" file to
X    your game directory.  (Note:  GCC's termcap routines have built-in
X    defaults, so the termcap file is not necessary with that compiler.)
X
X    To use funky graphics charaters in TOS, uudecode "atarifnt.uue" and unarc
X    the resulting "atarifnt.arc".  This contains a program to run that makes
X    some line graphics characters available to NetHack.  To use them, uncomment
X    the appropriate line in your NetHack.cnf file, and run the program before
X    running NetHack (you can put the program in an AUTO folder if you want).
X
X    If you'll be running NetHack from a different subdirectory, you will
X    want to "set HACKDIR=\games\nethack" (or whatever directory you want to
X    use) now.  Add it to your autoexec.bat (in DOS), if you'll be playing
X    often.
X
X11. Play NetHack.  If it works, you're done!
X
X
XNotes
X-----
X
X1)  Save files and bones files from previous versions will not work with
X    NetHack 3.0.  Don't bother trying to keep them.  Record (score) files
X    from before 3.0 patchlevel 7 will almost work, but you need to make one
X    change manually to them:  At the end of each line is a word or phrase
X    specifying what killed the player.  Change the string to start with the
X    words "killed by", "killed by a", or "killed by an" (whichever is
X    appropriate).  If the death was petrification, it should read "petrified
X    by" instead of "killed by".  Don't change "starvation", "quit", "escaped",
X    or "ascended".
X
X2)  To install an update of NetHack after changing something, enter "make"
X    from the src directory.  If you add, delete, or reorder monsters or
X    objects, or you change the format of saved level files, delete any save
X    and bones files.  (Trying to use such files sometimes produces amusing
X    confusions on the game's part, but usually crashes.)
X
X3)  During linking, the Microsoft Overlay Linker will need temporary storage
X    space to make the PC and OS/2 versions.  Make sure you have
X    about a meg of free disk where ever you have defined your temporary
X    storage.  It is also a good idea to compile with as much free RAM as
X    possible.  It may otherwise get crowded with the bigger, more complex
X    source files.  (Compiler bombs with "out of heap space" or similar.)
X    If this happens, strip your configuration, zap TSR's etc.
X
X4)  On a 286 10MHz PC you will have NetHack in about 2 - 2.5 hours.
X
X5)  Both OS/2 NetHack and the overlaid PC NetHack have been developed using
X    MSC 5.1.  MSC 6.0 is on the market, but since there hasn't been enough
X    time to fully test the game compiled with MSC 6.0, the distribution version
X    supports officially only MSC 5.1.  To compile NetHack with MSC 6.0, it may
X    be necessary to make some slight modifications to respective makefiles
X    as well as some source files.  Also, when compiling OS/2 version with MSC
X    6.0, change library "doscalls" to "os2" in Makefile.os2.
END_OF_FILE
if test 13860 -ne `wc -c <'Install.dos'`; then
    echo shar: \"'Install.dos'\" unpacked with wrong size!
fi
# end of 'Install.dos'
echo shar: Extracting \"'Install.vms'\" \(10809 characters\)
sed "s/^X//" >'Install.vms' <<'END_OF_FILE'
X
X               Instructions for Installing NetHack 3.0 
X                          on a VMS system
X               =======================================
X
X    (Credit for an enhanced VMS NetHack 3.0 goes to the VMS team of
X    Joshua Delahunty and Pat Rankin who built on the work of David
X    Gentzel.)
X
X1.  Building NetHack requires a C compiler (either VAX C or GNU C) and
X    VMS version 4.6 or later (but see note #9).  It has been tested on 5.3;
X    as of this writing, 5.4 has not yet been released.  For MicroVMS 4.6
X    or 4.7, an extra edit is required in file vmsconf.h (see step #3).
X    The new build procedure (vmsbuild.com) should not need to be
X    modified; it now accepts an option for selecting VAXC vs GNUC, and it
X    can detect different versions of VAXC to use appropriate CC command
X    qualifiers.  Versions of VAXC earlier than v2.3 will produce many
X    warning messages (over 100 per source file; close to 10,000 total!),
X    but NetHack has been verified to compile, link, and execute correctly
X    when built with VAXC v2.2 using vmsbuild.com.
X
X2.  Make sure all the NetHack files are in the appropriate directory
X    structure.  You should have a main directory with subdirectories
X    [.vms], [.src], [.include], [.auxil], and [.others]; you may also
X    have [.amiga] and [.mac], but they are not needed to build NetHack
X    on VMS.  If you do not follow this structure, the supplied procedures
X    and instructions in this file will not function properly.  The .c
X    files in [.src] are files which are used by all versions of NetHack,
X    regardless of machine (there are a few UNIX-specific files, but we can
X    ignore them).  The build & install command procedures (.com), the
X    VMS-specific .c files, and one VMS-specific .h file belong in [.vms].
X    All the .h files (except lev_lex.h) belong in [.include].  Other
X    assorted files belong in [.auxil].  The only files in [.others] used
X    by the VMS version of NetHack are random.c and possibly termcap.
X    (The directory structure is also described in the file called Files.)
X
X3.  Go to the [.include] subdirectory and edit vmsconf.h according to
X    the comments.  You may also want to edit config.h, but that's only
X    necessary if you want or need to disable some of the game options.
X    The distributed copy of config.h will work successfully on VMS;
X    vmsconf.h has conditional code to deal with the UNIX-specific items.
X
X4.  Go to the [.src] directory and look at the top of topten.c.  You may
X    want to change the definitions of PERSMAX and PERS_IS_UID here to get
X    different behavior from the high score list.
X
X5.  If you have lex or flex and yacc or bison, you may edit the procedure
X    [.vms]spec_lev.com and execute it to process a couple of source files
X    for NetHack's special level compiler.  This step is optional; the
X    distribution contains pre-processed versions of these files that can
X    be used as is.
X       $ @[.VMS]SPEC_LEV        !{OPTIONAL}
X    If you perform this step, do so prior to executing vmsbuild.com.
X
X6.  To build NETHACK.EXE and a couple of its auxiliary programs, execute
X    the following two DCL commands:
X       $ SET DEFAULT [.SRC]     !assuming you're currently in 'main'
X       $ @[-.VMS]VMSBUILD       !defaults to VAXC unless symbol 'CC' exists
X    or $ @[-.VMS]VMSBUILD "GNUC"
X    then go get a cup of coffee or take a nap.  Using VAXC v3.1, the
X    build procedure takes about 45-60 minutes on an unloaded VAXstation
X    3100-38 with local disk; it will take *much* longer on slower systems
X    such as uVAX-II and 11/7xx.  After completion, you should now have
X    created the game executable, NETHACK.EXE, with a size of roughly 1300
X    blocks (larger if the VAXCRTL object-library option of vmsbuild is used).
X
X7.  Go back to the main directory.  Edit [.vms]install.com to indicate
X    where you want everything to be installed.  Use the command
X       $ @[.VMS]INSTALL
X    to build some data files using the two auxiliary programs, and to
X    create the target directory and copy all necessary files there.
X    After it completes, the files [.src]*.obj, [.src]nethack.olb and
X    [.src]*.exe can be deleted if you wish to recover their disk space.
X
XNotes:
X
X1.  VMS NetHack uses the termcap routines borrowed from GNU Emacs.  These
X    have been supplied for those who do not already have GNU Emacs, but
X    they are not properly a part of the NetHack distribution.  Since
X    these files (vmstermcap.c and vmstparam.c) bear the usual GNU license,
X    any executable made with these files is also under the GNU license,
X    which among other things means you must be prepared to distribute all
X    the source that went into the executable if you distribute the
X    executable.  See the GNU license in the files for further details.
X
X2.  termcap is a text file containing descriptions of terminal capabilities
X    and the escape sequences that software must use to take advantage of
X    them.  If you do not already have a termcap file in use on your
X    system there is a small one in file [.OTHERS]TERMCAP.  It contains
X    definitions for common Digital terminals, also suitable for most
X    clones and emulators.  NetHack uses the translation of the logical
X    name TERMCAP to find the termcap file, so you need to use the DCL
X    command DEFINE or ASSIGN to set it up.  It uses the logical name
X    NETHACK_TERM to get the name of the terminal (such as "vt100").  If
X    that logical name is not defined, it tries EMACS_TERM.  If that also
X    is not defined, it uses the value generated by the C Run-Time library,
X    which is normally of the form "vt100-80" or "vt200-132".
X
X3.  There is code which attempts to make NetHack secure in case it is
X    installed with privileges (to allow the playground to be protected against
X    world write).  THIS HAS NOT BEEN TESTED.  Install NetHack with privileges
X    at your own risk.  If you do so, however, we would love to hear of your
X    experiences, good or bad.  The default setup uses world-writeable files,
X    which is NOT secure and not advisable in any environment where there
X    are untrustworthy users.  If you allow users to run NetHack from
X    captive accounts (VMS 5.1 or earlier) or from restricted accounts
X    (5.2 and later), you must either make sure that they do not have TMPMBX
X    privilege or else disable NetHack's ability to spawn an interactive
X    subprocess.  To disable subprocesses, disable the "!" (shell) command
X    by commenting out the definition of SHELL in vmsconf.h prior to
X    building the program.  This necessity will be removed in a future
X    release, where NetHack will check for captive accounts correctly.
X
X4.  VMS NetHack uses SMG$READ_KEYSTROKE to read characters from the
X    keyboard.  This means that arrow keys work, but also means that using
X    escape to abort commands doesn't.  If you want to abort a command use
X    two escapes or ^Z.  Just about any non-arrow function key should also
X    work as an abort.  Note that under UNIX ^Z is the suspend command; a
X    future release may re-utilize ^Z in some similar capacity on VMS.
X
X5.  NetHack does not run in PASTHRU or PASSALL mode.  This is to allow ^C
X    interrupts.  An unpleasant (albeit minor) side-effect of this is that
X    some wizard commands don't work (^G, ^O, ^X).  Another side-effect is
X    that ^Y and ^C echo "<interrupt>" and "<cancel>" respectively.  This
X    will be fixed in a future release.
X
X6.  To install an update of this version of NetHack after changing something
X    you will have to go through almost the entire build process (unless you
X    know for certain exactly what needs to be rebuilt).  If you added,
X    deleted, or reordered monsters or objects or changed the format of saved
X    level files, you should also remove any saved games and bones levels.
X    (Trying to use such files often produces amusing but useless confusions
X    on the game's part.)  If you just want to re-link the program, you
X    can invoke vmsbuild.com with a parameter value of "LINK", as in
X       $ @[-.vms]vmsbuild "LINK"
X    If you need to link with the GNUC library, then you must have a DCL
X    symbol 'CC' whose value begins with "G" (or "g").  This is necessary
X    because the mechanism for specifying GNUC vs VAXC is not accessible
X    when you specify "LINK" as the procedure parameter.
X
X7.  In version 3.0 patchlevel 7, the format of the record (score) file
X    was changed.  If you want to use an old record file from an earlier
X    version, manually edit it so that the killer (last item on each line)
X    is preceded by "killed by", "killed by a", or "killed by an".  If the
X    death was by petrification, use "petrified by" instead.  Do not
X    change "starvation", "quit", "escaped", or "ascended".  Record files
X    retained from patchlevel 7 to patchlevel 8 do not need any fixups.
X
X8.  NetHack optionally maintains a logfile which receives one line appended
X    to it whenever a game ends.  This can be disabled entirely by adding
X    an "#undef LOGFILE" directive to vmsconf.h prior to building the
X    program, or it can be disabled later by removing the file "LOGFILE."
X    from the playground directory.  If not disabled prior to compilation,
X    the logfile can be reinitialized by simply creating an empty LOGFILE
X    in the playground, but make sure that it's protected properly or new
X    entries will not be appended.
X
X9.  Support for VMS versions earlier than V4.6 is now included.  The need
X    for this support is detected automatically by vmsbuild.com, and also
X    automatically used when needed, but it has not received as thorough a
X    testing as the rest of NetHack.  The reason that special support is
X    needed is that the C Run-Time Library (VAXCRTL) underwent a major
X    revision for VMS V4.6.  Several routines which NetHack utilizes were
X    not available prior to that upgrade.
X
X10. The new release of vmsbuild.com collects most of the object files
X    (xxx.OBJ) into an object library (NETHACK.OLB) as it compiles the
X    source files.  This should prevent the EXQUOTA problem that some
X    sites have reported when linking nethack.exe, by limiting the number
X    of files which the linker accesses at one time.  Note that if you
X    compile any source files manually, you'll need to replace those
X    modules in the object library prior to linking the program:
X       $ cc/include=[-.include] [-.vms]vmstty   !for example
X       $ libr/obj nethack vmstty                !replace VMSTTY
X       $ @[-.vms]vmsbuild LINK                  !re-link NETHACK.EXE
X    If you forget to replace the library entry, your newly compiled code
X    will not be included in the new executable image.
X
X11. If necessary, send problem reports via email to
X       "nethack-bugs@linc.cis.upenn.edu"  (Internet address 130.91.6.8).
X
X27-MAY-1990
END_OF_FILE
if test 10809 -ne `wc -c <'Install.vms'`; then
    echo shar: \"'Install.vms'\" unpacked with wrong size!
fi
# end of 'Install.vms'
echo shar: Extracting \"'others/Makefile.os2'\" \(17844 characters\)
sed "s/^X//" >'others/Makefile.os2' <<'END_OF_FILE'
X#	SCCS Id: @(#)Makefile.os2	3.0	90/02/22
X#	OS/2 NetHack 3.0 Makefile for Microsoft(tm) C 5.1 -- Timo Hakulinen
X#
X#	NDMAKE ver 4.5 or MS-NMAKE is required, MS-MAKE will not work.
X#	To enable either make utility, uncomment the respective
X#	make-specific macros. If you plan to cross-compile in DOS, your
X#	best bet is NDMAKE, since it requires less memory than NMAKE.
X#	To compile in OS/2 use NMAKE or compatible.  Remember to set
X#	$(RLIBS) to real mode libraries if compiling in DOS, and to
X#	protected mode libraries for compilation in OS/2.
X#
X#	Copy pctty.c, pcunix.c, pcmain.c, msdos.c and this file
X#	(+ termcap library if used) into $(SRC) directory, rename
X#	this file to "makefile" (important, some targets rely on it),
X#	compile and link inside $(SRC).  Termcap library can be built
X#	from termcap sources using makefile.lib in "others" directory.
X#
X#	When using CodeView versions earlier than ver. 2.3, define
X#	OS2_CODEVIEW in pcconf.h and set HACKDIR (+ TERM and TERMCAP
X#	if used) in OS/2 config.sys. Otherwise path searches may fail.
X#
X#	Note that $(GAMEDIR) must exist prior to compilation.
X#
XCC	= cl
XLINK	= link
XLIB	= lib
X
X# Enable the upper three lines for NDMAKE and lower three for MS-NMAKE.
X# ($(MAKE) macro is often predefined, so we use $(MAKEBIN) instead).
XMAKEBIN = make
XAB	= $*.c
XCB	= $*.c
X#MAKEBIN = nmake
X#AB	= $(@B).c
X#CB	= $$(@B).c
X
X# For those of us who have these on PC.
X#YACC	= yacc
X#LEX	= lex
XYACC	= bison -y
XLEX	= flex
X# Standard file names may vary in PC installations.
XYTABC	= y_tab.c
XYTABH	= y_tab.h
XLEXYYC	= lexyy.c
X
X# Directories (makedefs hardcodes these, don't change them).
XINCL	= ..\include
XAUX	= ..\auxil
XSRC	= ..\src
XOBJ	= $(SRC)\o2
X
X# The game name and description.
XGAME	= nethack
XGAMEDES = NetHack 3.0
X
X# The game directory.
XGAMEDIR = \games\$(GAME)
X
X# Memory model, compile only, disable optimization, remove stack probes,
X# 80286 instruction set, dedicated datasegment for items >= 5 bytes,
X# pack structures on 1 byte boundaries, generate code for 8087
X# coprocessor, compiler warning level, include file path.
XCFLAGS	= /AL /c /Od /Gs /G2 /Gt5 /Zp1 /FPi87 /W1 /I$(INCL) $(CDFLAGS)
X
X# + prepare for CodeView symbolic debugger.
XCDFLAGS =
X#CDFLAGS = /Zi
X
X# Don't ignore case in symbols, no default lib search, stack 4096 bytes.
X# (actually a bit of overkill), allow max 1024 segments in program.
XLFLAGS	= /noig /nod /stack:4096 /seg:1024 $(LDFLAGS)
X
X# + prepare for CodeView symbolic debugger.
XLDFLAGS =
X#LDFLAGS = /CO
X
X# Protected mode C libraries for 8087 (change if necessary),
X# OS/2 API entry points.
XPLIBS	= llibc7p doscalls
X
X# C libraries used by makedefs and lev_comp (change if necessary).
X# If compilation is done in DOS, enable the upper line, if in OS/2,
X# the lower (protected mode libraries).
XRLIBS	= llibc7r
X#RLIBS	= $(PLIBS)
X
X# Module definition file for OS/2.
XOS2DEFS	= $(GAME).def
X
X# The default make target (so just typing 'make' is useful).
Xdefault: $(GAME)
X
X# If you have yacc and lex programs and make any changes, comment out the
X# upper two lines and uncomment the lower two.
Xdo_yacc: yacc_msg
Xdo_lex:  lex_msg
X#do_yacc: yacc_act
X#do_lex:  lex_act
X
X# Optional high-quality BSD random number generation routines (see pcconf.h).
X# Set to nothing if not used.
XRANDOM	= $(OBJ)\random.o
X#RANDOM	=
X
X# If TERMLIB defined in pcconf.h, comment out the upper line and
X# uncomment the lower.  If the termcap-library doesn't exist, use
X# others\makefile.lib to build it.
XTERMLIB =
X#TERMLIB = termlib.lib
X
X######################################################################
X#
X# Nothing below this line should have to be changed.
X#
X# Other things that have to be reconfigured are in
X# config.h, pcconf.h and possibly system.h.
X#
X
X# The game filename.
XGAMEFILE = $(GAMEDIR)\$(GAME).exe
X
X# Object files for makedefs.
XMAKEOBJS = $(OBJ)\makedefs.o $(OBJ)\monst.o $(OBJ)\objects.o
X
X# Object files for special levels compiler.
XSOBJ01 = $(OBJ)\lev_comp.o $(OBJ)\lev_lex.o $(OBJ)\lev_main.o $(OBJ)\alloc.o
XSOBJ02 = $(OBJ)\monst.o $(OBJ)\objects.o $(OBJ)\panic.o
X
XSPLEVOBJS = $(SOBJ01) $(SOBJ02)
X
XVOBJ01 = $(OBJ)\allmain.o  $(OBJ)\alloc.o    $(OBJ)\apply.o    $(OBJ)\artifact.o
XVOBJ02 = $(OBJ)\attrib.o   $(OBJ)\bones.o    $(OBJ)\cmd.o      $(OBJ)\dbridge.o
XVOBJ03 = $(OBJ)\decl.o     $(OBJ)\demon.o    $(OBJ)\do.o       $(OBJ)\do_name.o
XVOBJ04 = $(OBJ)\do_wear.o  $(OBJ)\dog.o      $(OBJ)\dogmove.o  $(OBJ)\dokick.o
XVOBJ05 = $(OBJ)\dothrow.o  $(OBJ)\eat.o      $(OBJ)\end.o
XVOBJ06 = $(OBJ)\engrave.o  $(OBJ)\exper.o    $(OBJ)\extralev.o $(OBJ)\fountain.o
XVOBJ07 = $(OBJ)\getline.o  $(OBJ)\hack.o     $(OBJ)\invent.o   $(OBJ)\lock.o
XVOBJ08 = $(OBJ)\mail.o     $(OBJ)\main.o     $(OBJ)\makemon.o  $(OBJ)\mcastu.o
XVOBJ09 = $(OBJ)\mhitm.o    $(OBJ)\mhitu.o    $(OBJ)\mklev.o    $(OBJ)\mkmaze.o
XVOBJ10 = $(OBJ)\mkobj.o    $(OBJ)\mkroom.o   $(OBJ)\mon.o      $(OBJ)\mondata.o
XVOBJ11 = $(OBJ)\msdos.o    $(OBJ)\monmove.o  $(OBJ)\monst.o    $(OBJ)\mthrowu.o
XVOBJ12 = $(OBJ)\music.o    $(OBJ)\o_init.o   $(OBJ)\objects.o
XVOBJ13 = $(OBJ)\objnam.o   $(OBJ)\options.o  $(OBJ)\pager.o    $(OBJ)\pickup.o
XVOBJ14 = $(OBJ)\polyself.o $(OBJ)\potion.o   $(OBJ)\pray.o     $(OBJ)\pri.o
XVOBJ15 = $(OBJ)\priest.o   $(OBJ)\prisym.o   $(RANDOM)         $(OBJ)\read.o
XVOBJ16 = $(OBJ)\restore.o  $(OBJ)\rip.o      $(OBJ)\rnd.o      $(OBJ)\rumors.o
XVOBJ17 = $(OBJ)\save.o     $(OBJ)\search.o   $(OBJ)\shk.o      $(OBJ)\shknam.o
XVOBJ18 = $(OBJ)\sit.o      $(OBJ)\sounds.o   $(OBJ)\sp_lev.o   $(OBJ)\spell.o
XVOBJ20 = $(OBJ)\steal.o    $(OBJ)\termcap.o  $(OBJ)\timeout.o  $(OBJ)\topl.o
XVOBJ21 = $(OBJ)\topten.o   $(OBJ)\track.o    $(OBJ)\trap.o     $(OBJ)\tty.o
XVOBJ22 = $(OBJ)\u_init.o   $(OBJ)\uhitm.o    $(OBJ)\unix.o     $(OBJ)\vault.o
XVOBJ23 = $(OBJ)\weapon.o   $(OBJ)\were.o     $(OBJ)\wield.o
XVOBJ24 = $(OBJ)\wizard.o   $(OBJ)\worm.o     $(OBJ)\worn.o     $(OBJ)\write.o
XVOBJ25 = $(OBJ)\zap.o
XHHOBJ  = $(OBJ)\version.o
X
XVOBJ =	$(VOBJ01) $(VOBJ02) $(VOBJ03) $(VOBJ04) $(VOBJ05) $(VOBJ06) $(VOBJ07) \
X	$(VOBJ08) $(VOBJ09) $(VOBJ10) $(VOBJ11) $(VOBJ12) $(VOBJ13) $(VOBJ14) \
X	$(VOBJ15) $(VOBJ16) $(VOBJ17) $(VOBJ18) $(VOBJ20) $(VOBJ21) $(VOBJ22) \
X	$(VOBJ23) $(VOBJ24) $(VOBJ25)
XHOBJ =	$(VOBJ) $(HHOBJ)
X
XPCCONF_H   = $(INCL)\pcconf.h $(INCL)\msdos.h $(INCL)\system.h \
X	     $(INCL)\extern.h $(INCL)\def_os2.h
XGLOBAL_H   = $(INCL)\global.h $(INCL)\coord.h $(PCCONF_H)
XCONFIG_H   = $(INCL)\config.h $(INCL)\tradstdc.h $(GLOBAL_H)
XTRAP_H	   = $(INCL)\trap.h
XPERMONST_H = $(INCL)\permonst.h $(INCL)\monattk.h $(INCL)\monflag.h
XYOU_H	   = $(INCL)\you.h $(INCL)\attrib.h $(PERMONST_H) $(INCL)\mondata.h \
X	     $(INCL)\monst.h $(INCL)\youprop.h $(INCL)\prop.h $(INCL)\pm.h
XDECL_H	   = $(INCL)\decl.h $(INCL)\spell.h $(INCL)\obj.h $(YOU_H) \
X	     $(INCL)\onames.h $(INCL)\color.h
XHACK_H	   = $(CONFIG_H) $(DECL_H) $(INCL)\monsym.h $(INCL)\mkroom.h \
X	     $(INCL)\objclass.h $(INCL)\gold.h $(TRAP_H) $(INCL)\flag.h \
X	     $(INCL)\rm.h $(INCL)\hack.h
X
X# The default target
X
Xall:	makedefs lev_comp $(GAME) auxil
X	@echo Done.
X
X# The main target
X
X$(GAME): $(OBJ) $(GAMEDIR)\$(GAME).exe
X$(GAME).exe: $(GAMEDIR)\$(GAME).exe
X$(GAMEDIR)\$(GAME).exe: $(GAME).res
X	$(LINK) @$(GAME).res
X
X$(GAME).res: $(HOBJ) $(OS2DEFS)
X	@echo $(VOBJ01) +> $@
X	@echo $(VOBJ02) +>> $@
X	@echo $(VOBJ03) +>> $@
X	@echo $(VOBJ04) +>> $@
X	@echo $(VOBJ05) +>> $@
X	@echo $(VOBJ06) +>> $@
X	@echo $(VOBJ07) +>> $@
X	@echo $(VOBJ08) +>> $@
X	@echo $(VOBJ09) +>> $@
X	@echo $(VOBJ10) +>> $@
X	@echo $(VOBJ11) +>> $@
X	@echo $(VOBJ12) +>> $@
X	@echo $(VOBJ13) +>> $@
X	@echo $(VOBJ14) +>> $@
X	@echo $(VOBJ15) +>> $@
X	@echo $(VOBJ16) +>> $@
X	@echo $(VOBJ17) +>> $@
X	@echo $(VOBJ18) +>> $@
X	@echo $(VOBJ20) +>> $@
X	@echo $(VOBJ21) +>> $@
X	@echo $(VOBJ22) +>> $@
X	@echo $(VOBJ23) +>> $@
X	@echo $(VOBJ24) +>> $@
X	@echo $(VOBJ25) +>> $@
X	@echo $(HHOBJ)>> $@
X	@echo $(GAMEDIR)\$(GAME)>> $@
X	@echo $(GAME)>> $@
X	@echo $(PLIBS) $(TERMLIB)>> $@
X	@echo $(OS2DEFS) $(LFLAGS);>> $@
X
X$(OBJ):
X	-mkdir $(OBJ)
X
X# Targets for makedefs.
X
Xmakedefs: $(OBJ) makedefs.exe
Xmakedefs.exe: makedefs.res
X	$(LINK) @makedefs.res
X
Xmakedefs.res: $(MAKEOBJS)
X	@echo $(MAKEOBJS)> $@
X	@echo makedefs>> $@
X	@echo nul>> $@
X	@echo $(RLIBS)>> $@
X	@echo $(LFLAGS);>> $@
X
X$(OBJ)\makedefs.o : $(CB) $(INCL)\config.h $(INCL)\permonst.h $(INCL)\objclass.h
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X
X# Targets for the special levels compiler.
X
Xlev_comp: $(OBJ) lev_comp.exe
Xlev_comp.exe: lev_comp.res
X	$(LINK) @lev_comp.res
X
Xlev_comp.res: $(SPLEVOBJS)
X	@echo $(SOBJ01) +> $@
X	@echo $(SOBJ02)>> $@
X	@echo lev_comp>> $@
X	@echo nul>> $@
X	@echo $(RLIBS)>> $@
X	@echo $(LFLAGS);>> $@
X
X$(OBJ)\lev_comp.o : $(CB) $(HACK_H) $(INCL)\sp_lev.h
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\lev_lex.o  : $(CB) $(HACK_H) $(INCL)\sp_lev.h $(INCL)\lev_comp.h
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\lev_main.o : $(CB) $(HACK_H)
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X
Xlev_comp.c : lev_comp.y
X	$(MAKEBIN) do_yacc
X
Xlev_lex.c  : lev_comp.l
X	$(MAKEBIN) do_lex
X
Xyacc_msg:
X	@echo lev_comp.y has changed. To update lev_comp.c and lev_comp.h run YACC.
X
Xyacc_act:
X	$(YACC) -d lev_comp.y
X	copy $(YTABC) lev_comp.c
X	copy $(YTABH) $(INCL)\lev_comp.h
X	del $(YTABC)
X	del $(YTABH)
X
Xlex_msg:
X	@echo lev_comp.l has changed. To update lev_lex.c run LEX.
X
Xlex_act:
X	$(LEX) lev_comp.l
X	copy $(LEXYYC) lev_lex.c
X	del $(LEXYYC)
X
X#
X#	The following include files depend on makedefs to be created.
X#
X#	date.h should be remade any time any of the source or include code
X#	is modified.
X#
X$(INCL)\date.h: $(VOBJ) makedefs.exe
X	makedefs -v
X
X$(INCL)\trap.h:	makedefs.exe
X	makedefs -t
X
X$(INCL)\onames.h: makedefs.exe
X	makedefs -o
X
X$(INCL)\pm.h: makedefs.exe
X	makedefs -p
X
Xdata:	$(AUX)\data.bas makedefs.exe
X	makedefs -d
X
Xrumors: $(AUX)\rumors.tru $(AUX)\rumors.fal makedefs.exe
X	makedefs -r
X
X#
X#	The following programs vary depending on what OS you are using.
X#
X$(OBJ)\main.o: pc$(CB) $(HACK_H)
X	$(CC) $(CFLAGS) /Fo$@ pc$(AB)
X
X$(OBJ)\tty.o:  pc$(CB) $(HACK_H) $(INCL)\func_tab.h
X	$(CC) $(CFLAGS) /Fo$@ pc$(AB)
X
X$(OBJ)\unix.o: pc$(CB) $(HACK_H)
X	$(CC) $(CFLAGS) /Fo$@ pc$(AB)
X
X#
X# Secondary targets
X#
X
Xauxil:	spec_lev data rumors
X	xcopy $(AUX)\cmdhelp $(GAMEDIR)
X	xcopy $(AUX)\help    $(GAMEDIR)
X	xcopy $(AUX)\hh      $(GAMEDIR)
X	xcopy $(AUX)\history $(GAMEDIR)
X	xcopy $(AUX)\license $(GAMEDIR)
X	xcopy $(AUX)\opthelp $(GAMEDIR)
X	xcopy $(AUX)\oracles $(GAMEDIR)
X	xcopy $(AUX)\data    $(GAMEDIR)
X	xcopy $(AUX)\rumors  $(GAMEDIR)
X
Xspec_lev: $(AUX)\castle.des $(AUX)\endgame.des $(AUX)\tower.des
X	lev_comp $(AUX)\castle.des
X	lev_comp $(AUX)\endgame.des
X	lev_comp $(AUX)\tower.des
X	xcopy castle  $(GAMEDIR)
X	xcopy endgame $(GAMEDIR)
X	xcopy tower?  $(GAMEDIR)
X	del castle
X	del endgame
X	del tower?
X
X$(OS2DEFS):
X	@echo NAME $(GAME) WINDOWCOMPAT> $(OS2DEFS)
X	@echo DESCRIPTION '$(GAMEDES)'>> $(OS2DEFS)
X	@echo PROTMODE>> $(OS2DEFS)
X	@echo EXETYPE OS2>> $(OS2DEFS)
X
Xclean:
X	-del $(OBJ)\*.o
X	-rmdir $(OBJ)
X
Xspotless: clean
X	-del $(INCL)\date.h
X	-del $(INCL)\onames.h
X	-del $(INCL)\pm.h
X	-del makedefs.exe
X	-del lev_comp.exe
X	-del *.res
X	-del *.def
X	-del *.map
X	-del $(AUX)\data
X	-del $(AUX)\rumors
X	-del castle
X	-del endgame
X	-del tower?
X
X#
X# Other dependencies.
X#
X# MS-NMAKE doesn't give a damn about default rules here, so until
X# that is fixed, we do this the hard way.
X#
X
X$(OBJ)\allmain.o  : $(CB) $(HACK_H)
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\alloc.o    : $(CB) $(CONFIG_H)
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\apply.o    : $(CB) $(HACK_H) $(INCL)\edog.h
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\artifact.o : $(CB) $(HACK_H) $(INCL)\artifact.h
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\attrib.o   : $(CB) $(HACK_H)
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\bones.o    : $(CB) $(HACK_H)
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\cmd.o      : $(CB) $(HACK_H) $(INCL)\func_tab.h
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\dbridge.o  : $(CB) $(HACK_H)
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\decl.o     : $(CB) $(HACK_H)
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\demon.o    : $(CB) $(HACK_H)
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\do.o       : $(CB) $(HACK_H)
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\do_name.o  : $(CB) $(HACK_H)
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\do_wear.o  : $(CB) $(HACK_H)
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\dog.o      : $(CB) $(HACK_H) $(INCL)\edog.h
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\dogmove.o  : $(CB) $(HACK_H) $(INCL)\mfndpos.h $(INCL)\edog.h
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\dokick.o   : $(CB) $(HACK_H) $(INCL)\eshk.h
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\dothrow.o  : $(CB) $(HACK_H)
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\eat.o      : $(CB) $(HACK_H)
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\end.o      : $(CB) $(HACK_H) $(INCL)\eshk.h
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\engrave.o  : $(CB) $(HACK_H)
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\exper.o    : $(CB) $(HACK_H)
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\extralev.o : $(CB) $(HACK_H)
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\fountain.o : $(CB) $(HACK_H)
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\getline.o  : $(CB) $(HACK_H) $(INCL)\func_tab.h
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\hack.o     : $(CB) $(HACK_H)
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\invent.o   : $(CB) $(HACK_H) $(INCL)\lev.h $(INCL)\wseg.h
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\ioctl.o    : $(CB) $(HACK_H)
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\lock.o     : $(CB) $(HACK_H)
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\makemon.o  : $(CB) $(HACK_H)
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\mail.o     : $(CB) $(HACK_H)
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\mcastu.o   : $(CB) $(HACK_H)
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\mhitm.o    : $(CB) $(HACK_H) $(INCL)\artifact.h
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\mhitu.o    : $(CB) $(HACK_H) $(INCL)\artifact.h $(INCL)\edog.h
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\mklev.o    : $(CB) $(HACK_H)
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\mkmaze.o   : $(CB) $(HACK_H)
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\mkobj.o    : $(CB) $(HACK_H)
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\mkroom.o   : $(CB) $(HACK_H)
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\mon.o      : $(CB) $(HACK_H) $(INCL)\mfndpos.h $(INCL)\wseg.h
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\mondata.o  : $(CB) $(HACK_H) $(INCL)\eshk.h $(INCL)\epri.h
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\monmove.o  : $(CB) $(HACK_H) $(INCL)\mfndpos.h $(INCL)\artifact.h
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\monst.o    : $(CB) $(CONFIG_H) $(PERMONST_H) $(INCL)\monsym.h $(INCL)\eshk.h \
X		    $(INCL)\vault.h $(INCL)\epri.h $(INCL)\color.h
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\msdos.o    : $(CB) $(HACK_H)
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\mthrowu.o  : $(CB) $(HACK_H)
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\music.o    : $(CB) $(HACK_H)
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\o_init.o   : $(CB) $(HACK_H)
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\objects.o  : $(CB) $(CONFIG_H) $(INCL)\obj.h $(INCL)\objclass.h $(INCL)\prop.h \
X		    $(INCL)\color.h
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\objnam.o   : $(CB) $(HACK_H)
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\options.o  : $(CB) $(HACK_H)
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\pager.o    : $(CB) $(HACK_H)
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\panic.o    : $(CB) $(CONFIG_H)
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\pickup.o   : $(CB) $(HACK_H)
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\polyself.o : $(CB) $(HACK_H)
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\potion.o   : $(CB) $(HACK_H)
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\pray.o     : $(CB) $(HACK_H)
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\pri.o      : $(CB) $(HACK_H) $(INCL)\epri.h $(INCL)\termcap.h
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\priest.o   : $(CB) $(HACK_H) $(INCL)\mfndpos.h $(INCL)\eshk.h $(INCL)\epri.h
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\prisym.o   : $(CB) $(HACK_H) $(INCL)\lev.h $(INCL)\wseg.h
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\random.o   : $(CB)
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\read.o     : $(CB) $(HACK_H)
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\restore.o  : $(CB) $(HACK_H) $(INCL)\lev.h $(INCL)\wseg.h
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\rip.o      : $(CB) $(HACK_H)
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\rnd.o      : $(CB) $(HACK_H)
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\rumors.o   : $(CB) $(HACK_H)
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\save.o     : $(CB) $(HACK_H) $(INCL)\lev.h $(INCL)\wseg.h
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\search.o   : $(CB) $(HACK_H) $(INCL)\artifact.h
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\shk.o      : $(CB) $(HACK_H) $(INCL)\eshk.h
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\shknam.o   : $(CB) $(HACK_H) $(INCL)\eshk.h
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\sit.o      : $(CB) $(HACK_H)
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\sounds.o   : $(CB) $(HACK_H) $(INCL)\edog.h $(INCL)\eshk.h
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\sp_lev.o   : $(CB) $(HACK_H) $(INCL)\sp_lev.h
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\spell.o    : $(CB) $(HACK_H)
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\steal.o    : $(CB) $(HACK_H)
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\termcap.o  : $(CB) $(HACK_H) $(INCL)\termcap.h
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\timeout.o  : $(CB) $(HACK_H)
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\topl.o     : $(CB) $(HACK_H)
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\topten.o   : $(CB) $(HACK_H)
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\track.o    : $(CB) $(HACK_H)
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\trap.o     : $(CB) $(HACK_H) $(INCL)\edog.h
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\u_init.o   : $(CB) $(HACK_H)
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\uhitm.o    : $(CB) $(HACK_H) $(INCL)\artifact.h
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\vault.o    : $(CB) $(HACK_H) $(INCL)\vault.h
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\version.o  : $(CB) $(HACK_H) $(INCL)\date.h $(INCL)\patchlev.h
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\weapon.o   : $(CB) $(HACK_H)
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\were.o     : $(CB) $(HACK_H)
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\wield.o    : $(CB) $(HACK_H)
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\wizard.o   : $(CB) $(HACK_H)
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\worm.o     : $(CB) $(HACK_H) $(INCL)\wseg.h
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\worn.o     : $(CB) $(HACK_H)
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\write.o    : $(CB) $(HACK_H)
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
X$(OBJ)\zap.o      : $(CB) $(HACK_H)
X	$(CC) $(CFLAGS) /Fo$@ $(AB)
END_OF_FILE
if test 17844 -ne `wc -c <'others/Makefile.os2'`; then
    echo shar: \"'others/Makefile.os2'\" unpacked with wrong size!
fi
# end of 'others/Makefile.os2'
echo shar: Extracting \"'others/ovlmgr.doc'\" \(13383 characters\)
sed "s/^X//" >'others/ovlmgr.doc' <<'END_OF_FILE'
X		     Brief notes about ovlmgr.asm
X		     ----------------------------
X			 (revised 1990may27)
X
XOVLMGR.ASM is a preliminary version of a multiple-residency overlay
Xmanager for use with the Microsoft Overlay Linker.  It is functionally
Xcompatible with the one in the MSC library _except_:
X
X- it usually accesses the disk less often and is a lot faster in some
X  applications.
X- it has different tuning characteristics.
X- you must (of course) link OVLMGR.OBJ into the root overlay (that is,
X  outside any parentheses in the link command).
X
X  See also the notes below.
X
X	As with other Microsoft-compatible overlay handlers you must be
X*very* careful never to call a function in an overlay through a pointer,
Xunless the initiator of the call resides in the *same* physical overlay
Xas the target (1).  Furthermore, setjmp() and longjmp() are not
Xsupported.
X
X	Unlike the Microsoft system, most of the available memory is
Xused to hold overlays.	Care must be taken to ensure that enough space
Xis reserved for the C heap.  This can be accomplished through
Xinformation stored in the .EXE file (currently the minalloc parameter,
Xas described below).
X
X       Furthermore, expanded memory support (EMS) is now an integral
Xpart of the overlay manager.  LIM EMS versions 3.2 and 4.0 are
Xsupported.  Note that the page frame must be 4 pages long (64K bytes) to
Xbe able to operate correctly (most drivers allocate a 64K frame by
Xdefault).  The overlay manager will use as much EMS as is necessary in
X64K chunks, up to a limit of 16 chunks (1 Meg).  Both hardware and
Xsoftware EMS drivers have been tested and found to be completely
Xcompatible.
X
X				~ * ~
X
X	OVLMGR.ASM currently has two assembly-time options, which are
Xspecified with the assembler's /D<symbol> option (or compatible).  They
Xare:
X
X	/DNOEMS Disable EMS support.
X		OVLMGR normally detects the presence of EMS memory and
X		makes use of it whenever it is present.  This flag
X		instructs ovlmgr to ignore EMS and operate only out of
X		conventional memory.  It should be used when overlaying
X		programmes which expect to use EMS themselves.
X
X	/Di386	Use 80386-specific instruction sequences.
X		Use of this flag will make ovlmgr perform better on
X		machines with 80386 processors.  However, the resulting
X		programme will not run at all on machines with less
X		capable CPUs.  Use this option with caution, especially
X		in the case of distribution code.
X
X				~ * ~
X
X	Although using the overlay manager is in essence much like using
XMicrosoft's, they operate on a slightly different principle, and tuning
Xfor them is rather different.  Technical part begins.
X
X	When overlay linking is requested (see your linker manual), the
XMS overlay linker changes all far calls into overlays from the (normal,
X8086) format:
X
X	offset	contents
X	------	--------
X	:0000	CALL
X	:0001	target-offset
X	:0003	target-segment
X
Xto this:
X	:0000	INT
X	:0001	int#	target-mod#
X	:0003	target-offset
X
X(note that here we are looking at the actual layout of the machine
Xcode, not at the assembly code as such) and relocates the code parts
Xof all the different overlays into the *same* physical area.  The
Xoverlaid code is all actually placed at the end of the .EXE file,
Xafter the 'normal' executable image, along with all its administrative
Xdata (fixups etc.).
X
X	When this altered 'call' is executed, of course, the interrupt
Xhandler int# is invoked.  Its job is to ensure that the target overlay
Xmodule is in memory (reading it from the tail of the .EXE file if it
Xisn't already loaded) and then transfer to the given offset within it,
X'faking up' the effect of the 'real' far call that would normally have
Xoccurred.  Something similar must be done when the call returns, to
Xensure that the thing being returned *into* is still (or is once more)
Xloaded.
X
X	The Microsoft linker, as we have said, relocates all the
Xoverlays to the same load address; and, in fact, it allocates am empty
Xblock of memory there that is at least as large as the largest
Xoverlay.  Into this area all the overlays are loaded without further
Xchange; thus, there can only ever be one overlay in memory at one
Xtime.  Transferring from one overlay to another causes one overlay to
Xreplace the other in the allocated overlay swap area.
X
X       Our overlay manager does not use the space allocated by the
Xlinker in the same way.  Rather, it allocates almost all of the memory
Xavailable from MS-DOS (including the original overlay area and any high
XDOS memory) as well as EMS memory if some is available and that option
Xis being used.	As overlays are needed, they are loaded wherever they
Xwill fit, and dynamically relocated to that address.  Thus, many more
Xthan one overlay may be loaded at any given time, greatly increasing
Xpotential performance.	Management of space is more or less according to
Xan LRU policy - once all of memory is full, the least recently used
Xoverlay is selected as the most likely candidate for replacement.
X
X	The implications of this difference are as follows:  while with
Xthe conventional (default) overlay manager, the best strategy is to
Xgroup object modules together in an overlay whenever they are known to
Xbe used in rapid succession, to make each overlay as big as possible
X(all things being equal) in order to take advantage of all available
Xmemory, and to make as few overlays as possible (to reduce the amount of
Xdisk access), the best strategy with our overlay manager is almost the
Xreverse.  Having a lot of small overlays will increase the amount of
Xuseful stuff that can be resident in memory at the same time; all of
Xmemory will automatically be employed; and there is no advantage at all
Xto uniformity of size (except perhaps in the unlikely case of *exact*
Xuniformity!).
X
X	Although ovlmgr allocates all available memory while it is
Xactive, you will find that the DOS exec() call works normally.	The
Xmemory that is allocated for administering the overlay system is freed
Xbefore the exec call is made and reallocated afterwards (we trap the DOS
Xfunction request vector to do this, which isn't very nice as a
Xprogramming practise but makes the existence of the overlay manager far
Xmore transparent).  There is, however, one circumstance under which this
Xcan be problematic:  if you use the exec() call to load a TSR
Xapplication, thereby causing memory that the overlay manager was using
Xto become unavailable, you may make it impossible for the overlaid
Xapplication to proceed.  This is because code that is nominally
X'running' (i.e. is currently on the stack) cannot be relocated and must
Xbe reloaded at the *same address* that previously held it.  If another
Xprocess now owns that area of memory, there is nothing we can do.  We
Xbelieve that this should not be a serious concern in normal use.
X
X				~ * ~
X
X	Since all available memory is potentially used by ovlmgr, there
Xis one additional concern in using it with C programmes:  the allocation
Xof sufficient space for the C heap (2).  While previous versions of
Xovlmgr.asm required the change of an internal constant and re-assembly
Xof ovlmgr to change the amount of space pre-allocated for this purpose,
Xthe current version uses the DOS minalloc parameter in the executable
Xfile to hold the size of the desired heap area.  This parameter can be
Xset at any time after the link process with either Microsoft's exemod
Xutility or with the supplied utility, exesmurf.
X
X				~ * ~
X
XNOTA BENE: This is a preliminary version of the overlay manager, but
Xby now it should be fairly well debugged. If you are considering
Xupgrading it please be aware that the following improvements are
Xplanned for the next version (though who knows when delivery will
Xoccur):
X
X      - compatible versions of setjmp() and longjmp()
X      - integral malloc() to eliminate the heap size guesswork
X      - support for swapped data areas (read-only and read/write)
X      - improved performance through dynamic link-loading (maybe)
X      - XMS support and improved EMS support
X      - support for divergent-functionality overlays (such as
X	  hardware-specific modules)
X      - enabling the overlay locking code
X      - Major code revamping
X
XSwap On!
X
X------------------------------------------------------------------------
XMESSAGES
X
XOVLMGR: Not enough free memory left to run this program.
X
X	Although DOS successfully loaded the programme, it proved
X	impossible to allocate enough additional contiguous memory to
X	load one or more of the overlays.  Either reduce the
X	RAM-loading of the application by reducing the size of either
X	the root or the largest overlays, or increase the amount of
X	memory available by unloading TSRs and/or simplifying your
X	CONFIG.SYS.
X
XOVLMGR: Internal memory allocation failure.
X
X	Either an internal error has occurred in ovlmgr or the
X	application programme, or some event has caused memory that
X	ovlmgr believed it could count on becoming unavailable.  A
X	typical example of the latter would be the result of
X	attempting to load a TSR while an overlaid application is
X	running.
X
XOVLMGR: Inaccessible EXE file. Can't load overlays.
X
X	For some reason ovlmgr could not locate or read the original
X	.EXE file in which the overlays reside.  This could be due to
X	your attempting to use a very old version of DOS,
X	an abject shortage of file handles, some strange event causing
X	the file to be deleted, a disk error, or the diskette that
X	contained the executable being removed.
X
XOVLMGR: Incorrect DOS version. Must be 3.00 or later.
X
X	The current version of ovlmgr does not support versions of DOS
X	prior to 3.0 because of the difficulty of locating the
X	executable file (and hence the overlays) at runtime.
X
XOVLMGR: EMS memory manager error.
X
X	An error occurred during an EMS access.  Either the hardware has
X	reported a bug, the software driver has detected an anomaly or
X	the page frame is not 64K bytes in length.
X
X(xxxx:xxxx:xxxx:xxxx)
X
X	This is a diagnostic code composed of the following fields:
X		- error code
X		- version number
X		- available conventional memory
X		- EMS memory usage
X	Please note it in any bug reports or correspondence with the
X	development team.
X
X------------------------------------------------------------------------
XKNOWN BUGS
X
XThe present version cannot always be used as a direct replacement for
XMicrosoft's overlay manager (even granted the documented differences)
Xbecause the minimum size required for an overlaid programme to run is at
Xleast the size of the root plus TWICE the size of the largest overlay.
XIf a programme has previously had its overlay structure tuned to take
Xbest advantage of Microsoft overlays, this may well cause a problem.
XThe overlays themselves will need to be split up.
X
XTransfers between overlays are very slow in machine terms, even if both
Xoverlays happen to reside in memory at the time (still significantly
Xfaster than Microsoft's, though).
X
XLocking overlays into memory is not really implemented even though
Xreading the source code might make you think it was.  Actually, reading
Xthe source code itself isn't very well implemented right now.  Comments
Xand stuff would help.  Yup, yup.
X
XDue to limitations in the LIM EMS standard (to 4.0), programmes that
Xthemselves use EMS memory cannot be overlaid with ovlmgr unless ovlmgr's
Xown EMS support is disabled.  This is accomplished by assembling with
Xthe /DNOEMS flag.
X
X------------------------------------------------------------------------
XBUG ALERT
X
XTo repeat a point made above, if you ever try to call a function in an
Xoverlay through a pointer, you *may* die with the Microsoft overlay
Xmanager.  If you ever try to call a function in an overlay through a
Xpointer, you *will* die with ours.  Nothing in an overlay ever ends up
Xin the same segment as the linker anticipated.	You have been warned!
X
X------------------------------------------------------------------------
XFOOTNOTES
X
X(1) This problem can be circumvented through the use of surrogate
X'trampoline' functions:  functions that reside in the root overlay and
Xsimply pass right through to the 'real', overlaid, implementations.
XThis can even be made transparent to the source code through the use
Xof the C macro preprocessor, with a locution of the form
X	#define foo(x) foo_(x)
Xvisible everywhere except at the actual definition point of the
Xtrampoline.  This has been implemented in NetHack 3.0.
X
X(2) If you should get a message to the effect that NetHack can't
Xallocate 28000 and some bytes when entering a maze level, that
Xisn't our problem!  In all probability you forgot to rebuild your
Xspecial level files when you changed the compiler flags.  We got
Xthat one, too, at one point.  The same applies to similar messages when
Xreading bones files or saved games:  it is more likely that you forgot
Xto discard them after recompiling your game than that the memory
Xallowance is so greatly incorrect.
X
X----------------------------------------------------------------------
XNOTICE
X
XOVLMGR.ASM is brought to you by Pierre Martineau and Stephen Spackman.
XIt, and this document, are copyright.  They are, however, provided as
Xpart of NetHack and may be freely distributed as described in the
XNetHack license.
X
X----------------------------------------------------------------------
XStephen P Spackman			     stephen@tira.uchicago.edu
XPierre G Martineau				  pierre@ozrout.uu.net
X----------------------------------------------------------------------
X    Copyright (c) 1989, 1990 Pierre G Martineau and Stephen P Spackman
X    All Rights Reserved.
END_OF_FILE
if test 13383 -ne `wc -c <'others/ovlmgr.doc'`; then
    echo shar: \"'others/ovlmgr.doc'\" unpacked with wrong size!
fi
# end of 'others/ovlmgr.doc'
echo shar: Extracting \"'vms/spec_lev.com'\" \(1123 characters\)
sed "s/^X//" >'vms/spec_lev.com' <<'END_OF_FILE'
X$ ! vms/spec_lev.com -- preprocess nethack's special level compiler code
X$ !
X$ ! This operation is optional.  If you are able to perform it and choose
X$ ! to do so, you should do it prior to executing vmsbuild.com.
X$ !
X$
X$ ! setup yacc/bison and lex/flex;
X$ !	  (uncomment the alternatives appropriate for your site)
X$     ! yacc := bison/def			!native bison (w/ DCL CLD)
X$     ! yacc := $bison$dir:bison -y -d		!'foreign' bison (w/o CLD)
X$	yacc := $shell$exe:yacc -d		!yacc from DECshell
X$     ! lex  := $flex$dir:flex			!flex
X$	lex  := $shell$exe:lex			!lex from DECshell
X$ ! additional setup
X$	rename := rename/new_vers
X$	! start from a known location -- [.vms], then move to [-.src]
X$	cur_dir = f$environment("DEFAULT")
X$	set default 'f$parse(f$environment("PROCEDURE"),,,"DIRECTORY")'
X$	set default [-.src]	!move to source directory
X$
X$ ! process lev_comp.y into lev_comp.c and ../include/lev_comp.h
X$  yacc lev_comp.y
X$  rename y_tab.c lev_comp.c
X$  rename y_tab.h [-.include]lev_comp.h
X$
X$ ! process lev_comp.l into lev_lex.c
X$  lex lev_comp.l
X$  rename lex_yy.c lev_lex.c
X$
X$ ! done
X$  set default 'cur_dir'
X$ exit
END_OF_FILE
if test 1123 -ne `wc -c <'vms/spec_lev.com'`; then
    echo shar: \"'vms/spec_lev.com'\" unpacked with wrong size!
fi
# end of 'vms/spec_lev.com'
echo shar: End of archive 23 \(of 24\).
cp /dev/null ark23isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 24 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
