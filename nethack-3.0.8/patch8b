Path: utzoo!attcan!uunet!ogicse!zephyr.ens.tek.com!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v10i020:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Patch8b
Message-ID: <5728@tekred.CNA.TEK.COM>
Date: 5 Jun 90 17:47:36 GMT
Sender: news@tekred.CNA.TEK.COM
Lines: 2049
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 10, Issue 20
Archive-name: NetHack3/Patch8b
Patch-To: NetHack3: Volume 7, Issue 56-93



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 2 (of 24)."
# Contents:  patch8.13 vms/install.com
# Wrapped by billr@saab on Mon Jun  4 15:27:12 1990
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'patch8.13' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'patch8.13'\"
else
echo shar: Extracting \"'patch8.13'\" \(54916 characters\)
sed "s/^X//" >'patch8.13' <<'END_OF_FILE'
X*** others/Old/Makefile.msc	Sun Jun  3 15:17:58 1990
X--- others/Makefile.msc	Fri May 18 20:44:19 1990
X***************
X*** 37,43 ****
X  GAMEFILE = $(GAMEDIR)\$(GAME).exe
X  
X  # object files for makedefs
X! MAKEOBJS = o\makedefs.o o\alloc.o o\monst.o o\objects.o o\panic.o
X  
X  # object files for special levels compiler
X  SPLEVOBJS = o\lev_comp.o o\lev_lex.o o\lev_main.o o\alloc.o o\monst.o o\objects.o o\panic.o
X--- 37,43 ----
X  GAMEFILE = $(GAMEDIR)\$(GAME).exe
X  
X  # object files for makedefs
X! MAKEOBJS = o\makedefs.o o\monst.o o\objects.o
X  
X  # object files for special levels compiler
X  SPLEVOBJS = o\lev_comp.o o\lev_lex.o o\lev_main.o o\alloc.o o\monst.o o\objects.o o\panic.o
X***************
X*** 68,81 ****
X  GLOBAL_H   = $(INCL)\global.h $(INCL)\coord.h $(PCCONF_H)
X  CONFIG_H   = $(INCL)\config.h $(INCL)\tradstdc.h $(GLOBAL_H)
X  TRAP_H	   = $(INCL)\trap.h
X! PERMONST_H = $(INCL)\permonst.h $(INCL)\monflag.h
X  YOU_H	   = $(INCL)\you.h $(INCL)\attrib.h $(PERMONST_H) $(INCL)\mondata.h \
X! 	     $(INCL)\monst.h $(INCL)\youprop.h
X  DECL_H	   = $(INCL)\decl.h $(INCL)\spell.h $(INCL)\obj.h $(YOU_H) \
X! 	     $(INCL)\onames.h $(INCL)\pm.h
X  HACK_H	   = $(CONFIG_H) $(DECL_H) $(INCL)\monsym.h $(INCL)\mkroom.h \
X  	     $(INCL)\objclass.h $(INCL)\gold.h $(INCL)\trap.h $(INCL)\flag.h \
X! 	     $(INCL)\rm.h
X  
X  # The main target
X  # NDMAKE automatically generates LINK response files
X--- 68,81 ----
X  GLOBAL_H   = $(INCL)\global.h $(INCL)\coord.h $(PCCONF_H)
X  CONFIG_H   = $(INCL)\config.h $(INCL)\tradstdc.h $(GLOBAL_H)
X  TRAP_H	   = $(INCL)\trap.h
X! PERMONST_H = $(INCL)\permonst.h $(INCL)\monattk.h $(INCL)\monflag.h
X  YOU_H	   = $(INCL)\you.h $(INCL)\attrib.h $(PERMONST_H) $(INCL)\mondata.h \
X! 	     $(INCL)\monst.h $(INCL)\youprop.h $(INCL)\prop.h $(INCL)\pm.h
X  DECL_H	   = $(INCL)\decl.h $(INCL)\spell.h $(INCL)\obj.h $(YOU_H) \
X! 	     $(INCL)\onames.h $(INCL)\color.h
X  HACK_H	   = $(CONFIG_H) $(DECL_H) $(INCL)\monsym.h $(INCL)\mkroom.h \
X  	     $(INCL)\objclass.h $(INCL)\gold.h $(INCL)\trap.h $(INCL)\flag.h \
X! 	     $(INCL)\rm.h $(INCL)\hack.h
X  
X  # The main target
X  # NDMAKE automatically generates LINK response files
X***************
X*** 118,124 ****
X  
X  o\lev_comp.o:  $(HACK_H) $(INCL)\sp_lev.h
X  o\lev_lex.o:  $(INCL)\lev_comp.h $(HACK_H) $(INCL)\sp_lev.h
X! o\lev_main.o:  $(HACK_H) $(INCL)\sp_lev.h
X  
X  # If you have yacc or lex programs, and make any changes,
X  # add some .y.c and .l.c rules to your Make.ini.
X--- 118,124 ----
X  
X  o\lev_comp.o:  $(HACK_H) $(INCL)\sp_lev.h
X  o\lev_lex.o:  $(INCL)\lev_comp.h $(HACK_H) $(INCL)\sp_lev.h
X! o\lev_main.o:  $(HACK_H)
X  
X  # If you have yacc or lex programs, and make any changes,
X  # add some .y.c and .l.c rules to your Make.ini.
X***************
X*** 245,251 ****
X  o\do_wear.o:  $(HACK_H)
X  o\dog.o:  $(HACK_H) $(INCL)\edog.h
X  o\dogmove.o:  $(HACK_H) $(INCL)\mfndpos.h $(INCL)\edog.h
X! o\dokick.o:  $(HACK_H)
X  o\dothrow.o:  $(HACK_H)
X  o\eat.o:  $(HACK_H)
X  o\end.o:  $(HACK_H) $(INCL)\eshk.h
X--- 245,251 ----
X  o\do_wear.o:  $(HACK_H)
X  o\dog.o:  $(HACK_H) $(INCL)\edog.h
X  o\dogmove.o:  $(HACK_H) $(INCL)\mfndpos.h $(INCL)\edog.h
X! o\dokick.o:  $(HACK_H) $(INCL)\eshk.h
X  o\dothrow.o:  $(HACK_H)
X  o\eat.o:  $(HACK_H)
X  o\end.o:  $(HACK_H) $(INCL)\eshk.h
X***************
X*** 257,263 ****
X  o\hack.o:  $(HACK_H)
X  o\invent.o:  $(HACK_H) $(INCL)\lev.h $(INCL)\wseg.h
X  o\ioctl.o:  $(HACK_H)
X- o\lev_comp.o:  $(HACK_H) $(INCL)\sp_lev.h
X  o\lock.o:  $(HACK_H)
X  o\makemon.o:  $(HACK_H)
X  o\mail.o:  $(HACK_H)
X--- 257,262 ----
X***************
X*** 268,282 ****
X  o\mkmaze.o:  $(HACK_H)
X  o\mkobj.o:  $(HACK_H)
X  o\mkroom.o:  $(HACK_H)
X! o\mon.o:  $(HACK_H) $(INCL)\mfndpos.h $(INCL)\artifact.h
X  o\mondata.o:  $(HACK_H) $(INCL)\eshk.h $(INCL)\epri.h
X  o\monmove.o:  $(HACK_H) $(INCL)\mfndpos.h $(INCL)\artifact.h
X! o\monst.o:  $(CONFIG_H) $(PERMONST_H) $(INCL)\eshk.h $(INCL)\vault.h $(INCL)\epri.h
X  o\msdos.o:  $(HACK_H)
X  o\mthrowu.o:  $(HACK_H)
X  o\music.o:  $(HACK_H)
X! o\o_init.o:  $(HACK_H) $(INCL)\onames.h
X! o\objects.o:  $(CONFIG_H) $(INCL)\obj.h $(INCL)\objclass.h $(INCL)\prop.h
X  o\objnam.o:  $(HACK_H)
X  o\options.o:  $(HACK_H)
X  o\pager.o:  $(HACK_H)
X--- 267,281 ----
X  o\mkmaze.o:  $(HACK_H)
X  o\mkobj.o:  $(HACK_H)
X  o\mkroom.o:  $(HACK_H)
X! o\mon.o:  $(HACK_H) $(INCL)\mfndpos.h $(INCL)\wseg.h
X  o\mondata.o:  $(HACK_H) $(INCL)\eshk.h $(INCL)\epri.h
X  o\monmove.o:  $(HACK_H) $(INCL)\mfndpos.h $(INCL)\artifact.h
X! o\monst.o:  $(CONFIG_H) $(PERMONST_H) $(INCL)\monsym.h $(INCL)\eshk.h $(INCL)\vault.h $(INCL)\epri.h $(INCL)\color.h
X  o\msdos.o:  $(HACK_H)
X  o\mthrowu.o:  $(HACK_H)
X  o\music.o:  $(HACK_H)
X! o\o_init.o:  $(HACK_H)
X! o\objects.o:  $(CONFIG_H) $(INCL)\obj.h $(INCL)\objclass.h $(INCL)\prop.h $(INCL)\color.h
X  o\objnam.o:  $(HACK_H)
X  o\options.o:  $(HACK_H)
X  o\pager.o:  $(HACK_H)
X***************
X*** 285,291 ****
X  o\polyself.o:  $(HACK_H)
X  o\potion.o:  $(HACK_H)
X  o\pray.o:  $(HACK_H)
X! o\pri.o:  $(HACK_H) $(INCL)\termcap.h
X  o\priest.o:  $(HACK_H) $(INCL)\mfndpos.h $(INCL)\eshk.h $(INCL)\epri.h
X  o\prisym.o:  $(HACK_H) $(INCL)\lev.h $(INCL)\wseg.h
X  o\random.o:
X--- 284,290 ----
X  o\polyself.o:  $(HACK_H)
X  o\potion.o:  $(HACK_H)
X  o\pray.o:  $(HACK_H)
X! o\pri.o:  $(HACK_H) $(INCL)\epri.h $(INCL)\termcap.h
X  o\priest.o:  $(HACK_H) $(INCL)\mfndpos.h $(INCL)\eshk.h $(INCL)\epri.h
X  o\prisym.o:  $(HACK_H) $(INCL)\lev.h $(INCL)\wseg.h
X  o\random.o:
X***************
X*** 312,318 ****
X  o\u_init.o:  $(HACK_H)
X  o\uhitm.o:  $(HACK_H) $(INCL)\artifact.h
X  o\vault.o:  $(HACK_H) $(INCL)\vault.h
X! o\version.o:  $(HACK_H) $(INCL)\date.h
X  o\weapon.o:  $(HACK_H)
X  o\were.o:  $(HACK_H)
X  o\wield.o:  $(HACK_H)
X--- 311,317 ----
X  o\u_init.o:  $(HACK_H)
X  o\uhitm.o:  $(HACK_H) $(INCL)\artifact.h
X  o\vault.o:  $(HACK_H) $(INCL)\vault.h
X! o\version.o:  $(HACK_H) $(INCL)\date.h $(INCL)\patchlev.h
X  o\weapon.o:  $(HACK_H)
X  o\were.o:  $(HACK_H)
X  o\wield.o:  $(HACK_H)
X*** others/Old/Makefile.pc	Sun Jun  3 15:19:29 1990
X--- others/Makefile.pc	Fri May 18 20:51:39 1990
X***************
X*** 35,41 ****
X  GAMEFILE = $(GAMEDIR)\$(GAME).exe
X  
X  # object files for makedefs
X! MAKEOBJS = o\makedefs.o o\alloc.o o\monst.o o\objects.o o\panic.o
X  
X  # object files for special levels compiler
X  SPLEVOBJS = o\lev_comp.o o\lev_lex.o o\lev_main.o o\alloc.o o\monst.o o\objects.o o\panic.o
X--- 35,41 ----
X  GAMEFILE = $(GAMEDIR)\$(GAME).exe
X  
X  # object files for makedefs
X! MAKEOBJS = o\makedefs.o o\monst.o o\objects.o
X  
X  # object files for special levels compiler
X  SPLEVOBJS = o\lev_comp.o o\lev_lex.o o\lev_main.o o\alloc.o o\monst.o o\objects.o o\panic.o
X***************
X*** 66,79 ****
X  GLOBAL_H   = $(INCL)\global.h $(INCL)\coord.h $(PCCONF_H)
X  CONFIG_H   = $(INCL)\config.h $(INCL)\tradstdc.h $(GLOBAL_H)
X  TRAP_H	   = $(INCL)\trap.h
X! PERMONST_H = $(INCL)\permonst.h $(INCL)\monflag.h
X  YOU_H	   = $(INCL)\you.h $(INCL)\attrib.h $(PERMONST_H) $(INCL)\mondata.h \
X! 	     $(INCL)\monst.h $(INCL)\youprop.h
X  DECL_H	   = $(INCL)\decl.h $(INCL)\spell.h $(INCL)\obj.h $(YOU_H) \
X! 	     $(INCL)\onames.h $(INCL)\pm.h
X  HACK_H	   = $(CONFIG_H) $(DECL_H) $(INCL)\monsym.h $(INCL)\mkroom.h \
X  	     $(INCL)\objclass.h $(INCL)\gold.h $(INCL)\trap.h $(INCL)\flag.h \
X! 	     $(INCL)\rm.h
X  
X  # The main target
X  $(GAMEDIR)\$(GAME).exe: o $(HOBJ)
X--- 66,79 ----
X  GLOBAL_H   = $(INCL)\global.h $(INCL)\coord.h $(PCCONF_H)
X  CONFIG_H   = $(INCL)\config.h $(INCL)\tradstdc.h $(GLOBAL_H)
X  TRAP_H	   = $(INCL)\trap.h
X! PERMONST_H = $(INCL)\permonst.h $(INCL)\monattk.h $(INCL)\monflag.h
X  YOU_H	   = $(INCL)\you.h $(INCL)\attrib.h $(PERMONST_H) $(INCL)\mondata.h \
X! 	     $(INCL)\monst.h $(INCL)\youprop.h $(INCL)\prop.h $(INCL)\pm.h
X  DECL_H	   = $(INCL)\decl.h $(INCL)\spell.h $(INCL)\obj.h $(YOU_H) \
X! 	     $(INCL)\onames.h $(INCL)\color.h
X  HACK_H	   = $(CONFIG_H) $(DECL_H) $(INCL)\monsym.h $(INCL)\mkroom.h \
X  	     $(INCL)\objclass.h $(INCL)\gold.h $(INCL)\trap.h $(INCL)\flag.h \
X! 	     $(INCL)\rm.h $(INCL)\hack.h
X  
X  # The main target
X  $(GAMEDIR)\$(GAME).exe: o $(HOBJ)
X***************
X*** 105,111 ****
X  
X  o\lev_comp.o:  $(HACK_H) $(INCL)\sp_lev.h
X  o\lev_lex.o:  $(INCL)\lev_comp.h $(HACK_H) $(INCL)\sp_lev.h
X! o\lev_main.o:  $(HACK_H) $(INCL)\sp_lev.h
X  
X  # If you have yacc or lex programs, and make any changes,
X  # add some .y.c and .l.c rules to your Make.ini.
X--- 105,111 ----
X  
X  o\lev_comp.o:  $(HACK_H) $(INCL)\sp_lev.h
X  o\lev_lex.o:  $(INCL)\lev_comp.h $(HACK_H) $(INCL)\sp_lev.h
X! o\lev_main.o:  $(HACK_H)
X  
X  # If you have yacc or lex programs, and make any changes,
X  # add some .y.c and .l.c rules to your Make.ini.
X***************
X*** 204,210 ****
X  o\do_wear.o:  $(HACK_H)
X  o\dog.o:  $(HACK_H) $(INCL)\edog.h
X  o\dogmove.o:  $(HACK_H) $(INCL)\mfndpos.h $(INCL)\edog.h
X! o\dokick.o:  $(HACK_H)
X  o\dothrow.o:  $(HACK_H)
X  o\eat.o:  $(HACK_H)
X  o\end.o:  $(HACK_H) $(INCL)\eshk.h
X--- 204,210 ----
X  o\do_wear.o:  $(HACK_H)
X  o\dog.o:  $(HACK_H) $(INCL)\edog.h
X  o\dogmove.o:  $(HACK_H) $(INCL)\mfndpos.h $(INCL)\edog.h
X! o\dokick.o:  $(HACK_H) $(INCL)\eshk.h
X  o\dothrow.o:  $(HACK_H)
X  o\eat.o:  $(HACK_H)
X  o\end.o:  $(HACK_H) $(INCL)\eshk.h
X***************
X*** 216,222 ****
X  o\hack.o:  $(HACK_H)
X  o\invent.o:  $(HACK_H) $(INCL)\lev.h $(INCL)\wseg.h
X  o\ioctl.o:  $(HACK_H)
X- o\lev_comp.o:  $(HACK_H) $(INCL)\sp_lev.h
X  o\lock.o:  $(HACK_H)
X  o\makemon.o:  $(HACK_H)
X  o\mail.o:  $(HACK_H)
X--- 216,221 ----
X***************
X*** 227,241 ****
X  o\mkmaze.o:  $(HACK_H)
X  o\mkobj.o:  $(HACK_H)
X  o\mkroom.o:  $(HACK_H)
X! o\mon.o:  $(HACK_H) $(INCL)\mfndpos.h $(INCL)\artifact.h
X  o\mondata.o:  $(HACK_H) $(INCL)\eshk.h $(INCL)\epri.h
X  o\monmove.o:  $(HACK_H) $(INCL)\mfndpos.h $(INCL)\artifact.h
X! o\monst.o:  $(CONFIG_H) $(PERMONST_H) $(INCL)\eshk.h $(INCL)\vault.h $(INCL)\epri.h
X  o\msdos.o:  $(HACK_H)
X  o\mthrowu.o:  $(HACK_H)
X  o\music.o:  $(HACK_H)
X! o\o_init.o:  $(HACK_H) $(INCL)\onames.h
X! o\objects.o:  $(CONFIG_H) $(INCL)\obj.h $(INCL)\objclass.h $(INCL)\prop.h
X  o\objnam.o:  $(HACK_H)
X  o\options.o:  $(HACK_H)
X  o\pager.o:  $(HACK_H)
X--- 226,240 ----
X  o\mkmaze.o:  $(HACK_H)
X  o\mkobj.o:  $(HACK_H)
X  o\mkroom.o:  $(HACK_H)
X! o\mon.o:  $(HACK_H) $(INCL)\mfndpos.h $(INCL)\wseg.h
X  o\mondata.o:  $(HACK_H) $(INCL)\eshk.h $(INCL)\epri.h
X  o\monmove.o:  $(HACK_H) $(INCL)\mfndpos.h $(INCL)\artifact.h
X! o\monst.o:  $(CONFIG_H) $(PERMONST_H) $(INCL)\monsym.h $(INCL)\eshk.h $(INCL)\vault.h $(INCL)\epri.h $(INCL)\color.h
X  o\msdos.o:  $(HACK_H)
X  o\mthrowu.o:  $(HACK_H)
X  o\music.o:  $(HACK_H)
X! o\o_init.o:  $(HACK_H)
X! o\objects.o:  $(CONFIG_H) $(INCL)\obj.h $(INCL)\objclass.h $(INCL)\prop.h $(INCL)\color.h
X  o\objnam.o:  $(HACK_H)
X  o\options.o:  $(HACK_H)
X  o\pager.o:  $(HACK_H)
X***************
X*** 244,250 ****
X  o\polyself.o:  $(HACK_H)
X  o\potion.o:  $(HACK_H)
X  o\pray.o:  $(HACK_H)
X! o\pri.o:  $(HACK_H) $(INCL)\termcap.h
X  o\priest.o:  $(HACK_H) $(INCL)\mfndpos.h $(INCL)\eshk.h $(INCL)\epri.h
X  o\prisym.o:  $(HACK_H) $(INCL)\lev.h $(INCL)\wseg.h
X  o\random.o:
X--- 243,249 ----
X  o\polyself.o:  $(HACK_H)
X  o\potion.o:  $(HACK_H)
X  o\pray.o:  $(HACK_H)
X! o\pri.o:  $(HACK_H) $(INCL)\epri.h $(INCL)\termcap.h
X  o\priest.o:  $(HACK_H) $(INCL)\mfndpos.h $(INCL)\eshk.h $(INCL)\epri.h
X  o\prisym.o:  $(HACK_H) $(INCL)\lev.h $(INCL)\wseg.h
X  o\random.o:
X***************
X*** 271,277 ****
X  o\u_init.o:  $(HACK_H)
X  o\uhitm.o:  $(HACK_H) $(INCL)\artifact.h
X  o\vault.o:  $(HACK_H) $(INCL)\vault.h
X! o\version.o:  $(HACK_H) $(INCL)\date.h
X  o\weapon.o:  $(HACK_H)
X  o\were.o:  $(HACK_H)
X  o\wield.o:  $(HACK_H)
X--- 270,276 ----
X  o\u_init.o:  $(HACK_H)
X  o\uhitm.o:  $(HACK_H) $(INCL)\artifact.h
X  o\vault.o:  $(HACK_H) $(INCL)\vault.h
X! o\version.o:  $(HACK_H) $(INCL)\date.h $(INCL)\patchlev.h
X  o\weapon.o:  $(HACK_H)
X  o\were.o:  $(HACK_H)
X  o\wield.o:  $(HACK_H)
X*** others/Old/Makefile.st	Sun Jun  3 15:19:46 1990
X--- others/Makefile.st	Thu May 17 07:39:01 1990
X***************
X*** 56,66 ****
X  GAMEFILE = $(GAMEDIR)\$(GAME).ttp
X  
X  # object files for makedefs
X! MAKEOBJS = makedefs.o alloc.o monst.o objects.o panic.o
X  
X  # object files for special levels compiler
X! SPLEVOBJS = lev_comp.o lev_lex.o \
X! 	lev_main.o alloc.o monst.o objects.o panic.o
X  
X  # nothing below this line should have to be changed
X  #
X--- 56,65 ----
X  GAMEFILE = $(GAMEDIR)\$(GAME).ttp
X  
X  # object files for makedefs
X! MAKEOBJS = makedefs.o monst.o objects.o
X  
X  # object files for special levels compiler
X! SPLEVOBJS = lev_comp.o lev_lex.o lev_main.o alloc.o monst.o objects.o panic.o
X  
X  # nothing below this line should have to be changed
X  #
X***************
X*** 88,101 ****
X  GLOBAL_H   = $(INCL)\global.h $(INCL)\coord.h $(PCCONF_H)
X  CONFIG_H   = $(INCL)\config.h $(INCL)\tradstdc.h $(GLOBAL_H)
X  TRAP_H	   = $(INCL)\trap.h
X! PERMONST_H = $(INCL)\permonst.h $(INCL)\monflag.h
X  YOU_H	   = $(INCL)\you.h $(INCL)\attrib.h $(PERMONST_H) $(INCL)\mondata.h \
X! 	     $(INCL)\monst.h $(INCL)\youprop.h
X  DECL_H	   = $(INCL)\decl.h $(INCL)\spell.h $(INCL)\obj.h $(YOU_H) \
X! 	     $(INCL)\onames.h $(INCL)\pm.h
X  HACK_H	   = $(CONFIG_H) $(DECL_H) $(INCL)\monsym.h $(INCL)\mkroom.h \
X  	     $(INCL)\objclass.h $(INCL)\gold.h $(INCL)\trap.h $(INCL)\flag.h \
X! 	     $(INCL)\rm.h
X  
X  # The main target
X  $(GAME).ttp: $(HOBJ)
X--- 87,100 ----
X  GLOBAL_H   = $(INCL)\global.h $(INCL)\coord.h $(PCCONF_H)
X  CONFIG_H   = $(INCL)\config.h $(INCL)\tradstdc.h $(GLOBAL_H)
X  TRAP_H	   = $(INCL)\trap.h
X! PERMONST_H = $(INCL)\permonst.h $(INCL)\monattk.h $(INCL)\monflag.h
X  YOU_H	   = $(INCL)\you.h $(INCL)\attrib.h $(PERMONST_H) $(INCL)\mondata.h \
X! 	     $(INCL)\monst.h $(INCL)\youprop.h $(INCL)\prop.h $(INCL)\pm.h
X  DECL_H	   = $(INCL)\decl.h $(INCL)\spell.h $(INCL)\obj.h $(YOU_H) \
X! 	     $(INCL)\onames.h $(INCL)\pm.h $(INCL)\color.h
X  HACK_H	   = $(CONFIG_H) $(DECL_H) $(INCL)\monsym.h $(INCL)\mkroom.h \
X  	     $(INCL)\objclass.h $(INCL)\gold.h $(INCL)\trap.h $(INCL)\flag.h \
X! 	     $(INCL)\rm.h $(INCL)\hack.h
X  
X  # The main target
X  $(GAME).ttp: $(HOBJ)
X***************
X*** 116,122 ****
X  
X  lev_comp.o:  $(HACK_H) $(INCL)\sp_lev.h
X  lev_lex.o:  $(INCL)\lev_comp.h $(HACK_H) $(INCL)\sp_lev.h
X! lev_main.o:  $(HACK_H) $(INCL)\sp_lev.h
X  
X  # If you have yacc or lex programs, and make any changes,
X  # you'll need rules like these. The names of the output
X--- 115,121 ----
X  
X  lev_comp.o:  $(HACK_H) $(INCL)\sp_lev.h
X  lev_lex.o:  $(INCL)\lev_comp.h $(HACK_H) $(INCL)\sp_lev.h
X! lev_main.o:  $(HACK_H)
X  
X  # If you have yacc or lex programs, and make any changes,
X  # you'll need rules like these. The names of the output
X***************
X*** 239,245 ****
X  do_wear.o:  $(HACK_H)
X  dog.o:  $(HACK_H) $(INCL)\edog.h
X  dogmove.o:  $(HACK_H) $(INCL)\mfndpos.h $(INCL)\edog.h
X! dokick.o:  $(HACK_H)
X  dothrow.o:  $(HACK_H)
X  eat.o:  $(HACK_H)
X  end.o:  $(HACK_H) $(INCL)\eshk.h
X--- 238,244 ----
X  do_wear.o:  $(HACK_H)
X  dog.o:  $(HACK_H) $(INCL)\edog.h
X  dogmove.o:  $(HACK_H) $(INCL)\mfndpos.h $(INCL)\edog.h
X! dokick.o:  $(HACK_H) $(INCL)\eshk.h
X  dothrow.o:  $(HACK_H)
X  eat.o:  $(HACK_H)
X  end.o:  $(HACK_H) $(INCL)\eshk.h
X***************
X*** 251,257 ****
X  hack.o:  $(HACK_H)
X  invent.o:  $(HACK_H) $(INCL)\lev.h $(INCL)\wseg.h
X  ioctl.o:  $(HACK_H)
X- lev_comp.o:  $(HACK_H) $(INCL)\sp_lev.h
X  lock.o:  $(HACK_H)
X  makemon.o:  $(HACK_H)
X  mail.o:  $(HACK_H)
X--- 250,255 ----
X***************
X*** 262,268 ****
X  mkmaze.o:  $(HACK_H)
X  mkobj.o:  $(HACK_H)
X  mkroom.o:  $(HACK_H)
X! mon.o:  $(HACK_H) $(INCL)\mfndpos.h $(INCL)\artifact.h
X  mondata.o:  $(HACK_H) $(INCL)\eshk.h $(INCL)\epri.h
X  monmove.o:  $(HACK_H) $(INCL)\mfndpos.h $(INCL)\artifact.h
X  
X--- 260,266 ----
X  mkmaze.o:  $(HACK_H)
X  mkobj.o:  $(HACK_H)
X  mkroom.o:  $(HACK_H)
X! mon.o:  $(HACK_H) $(INCL)\mfndpos.h $(INCL)\wseg.h
X  mondata.o:  $(HACK_H) $(INCL)\eshk.h $(INCL)\epri.h
X  monmove.o:  $(HACK_H) $(INCL)\mfndpos.h $(INCL)\artifact.h
X  
X***************
X*** 273,279 ****
X  # a comp.binaries.atari.st site, or get gnu sed (the port to
X  # the atari GCC is easy).
X  
X! monst.o:  $(CONFIG_H) $(PERMONST_H) $(INCL)\eshk.h $(INCL)\vault.h $(INCL)\epri.h
X  	$(CC) $(CFLAGS) -S -o monst1.s -DSPLITMON_1 monst.c
X  	$(CC) $(CFLAGS) -S -o monst2.s -DSPLITMON_2 monst.c
X  	sed -e s/LC/LD/ -e s/gcc_compiled.:// monst2.s >>monst1.s
X--- 271,277 ----
X  # a comp.binaries.atari.st site, or get gnu sed (the port to
X  # the atari GCC is easy).
X  
X! monst.o:  $(CONFIG_H) $(PERMONST_H) $(INCL)\eshk.h $(INCL)\vault.h $(INCL)\epri.h $(INCL)\color.h
X  	$(CC) $(CFLAGS) -S -o monst1.s -DSPLITMON_1 monst.c
X  	$(CC) $(CFLAGS) -S -o monst2.s -DSPLITMON_2 monst.c
X  	sed -e s/LC/LD/ -e s/gcc_compiled.:// monst2.s >>monst1.s
X***************
X*** 284,290 ****
X  mthrowu.o:  $(HACK_H)
X  music.o:  $(HACK_H)
X  o_init.o:  $(HACK_H) $(INCL)\onames.h
X! objects.o:  $(CONFIG_H) $(INCL)\obj.h $(INCL)\objclass.h $(INCL)\prop.h
X  objnam.o:  $(HACK_H)
X  options.o:  $(HACK_H)
X  pager.o:  $(HACK_H)
X--- 282,288 ----
X  mthrowu.o:  $(HACK_H)
X  music.o:  $(HACK_H)
X  o_init.o:  $(HACK_H) $(INCL)\onames.h
X! objects.o:  $(CONFIG_H) $(INCL)\obj.h $(INCL)\objclass.h $(INCL)\prop.h $(INCL)\color.h
X  objnam.o:  $(HACK_H)
X  options.o:  $(HACK_H)
X  pager.o:  $(HACK_H)
X***************
X*** 293,299 ****
X  polyself.o:  $(HACK_H)
X  potion.o:  $(HACK_H)
X  pray.o:  $(HACK_H)
X! pri.o:  $(HACK_H) $(INCL)\termcap.h
X  priest.o:  $(HACK_H) $(INCL)\mfndpos.h $(INCL)\eshk.h $(INCL)\epri.h
X  prisym.o:  $(HACK_H) $(INCL)\lev.h $(INCL)\wseg.h
X  random.o:
X--- 291,297 ----
X  polyself.o:  $(HACK_H)
X  potion.o:  $(HACK_H)
X  pray.o:  $(HACK_H)
X! pri.o:  $(HACK_H) $(INCL)\epri.h $(INCL)\termcap.h
X  priest.o:  $(HACK_H) $(INCL)\mfndpos.h $(INCL)\eshk.h $(INCL)\epri.h
X  prisym.o:  $(HACK_H) $(INCL)\lev.h $(INCL)\wseg.h
X  random.o:
X***************
X*** 320,326 ****
X  u_init.o:  $(HACK_H)
X  uhitm.o:  $(HACK_H) $(INCL)\artifact.h
X  vault.o:  $(HACK_H) $(INCL)\vault.h
X! version.o:  $(HACK_H) $(INCL)\date.h
X  weapon.o:  $(HACK_H)
X  were.o:  $(HACK_H)
X  wield.o:  $(HACK_H)
X--- 318,324 ----
X  u_init.o:  $(HACK_H)
X  uhitm.o:  $(HACK_H) $(INCL)\artifact.h
X  vault.o:  $(HACK_H) $(INCL)\vault.h
X! version.o:  $(HACK_H) $(INCL)\date.h $(INCL)\patchlevel.h
X  weapon.o:  $(HACK_H)
X  were.o:  $(HACK_H)
X  wield.o:  $(HACK_H)
X*** others/Old/Makefile.tcc	Sun Jun  3 15:20:08 1990
X--- others/Makefile.tcc	Wed May 16 21:36:45 1990
X***************
X*** 262,279 ****
X  # header dependencies
X  
X  PCCONF_H   = $(INCL)\$(TARG)conf.h  $(INCL)\msdos.h	$(INCL)\system.h
X! GLOBAL_H   = $(INCL)\global.h	    $(INCL)\coord.h	$(PCCONF_H)
X! CONFIG_H   = $(INCL)\config.h	    $(INCL)\tradstdc.h	$(GLOBAL_H)
X  TRAP_H	   = $(INCL)\trap.h
X! PERMONST_H = $(INCL)\permonst.h     $(INCL)\monflag.h
X! YOU_H	   = $(INCL)\you.h	    $(INCL)\attrib.h	$(PERMONST_H) \
X! 	     $(INCL)\mondata.h	    $(INCL)\monst.h	$(INCL)\youprop.h
X! DECL_H	   = $(INCL)\spell.h	    $(INCL)\obj.h	$(YOU_H) \
X! 	     $(INCL)\onames.h	    $(INCL)\pm.h
X! HACK_H	   = $(CONFIG_H)	    $(DECL_H)		$(INCL)\monsym.h \
X! 	     $(INCL)\mkroom.h	    $(INCL)\objclass.h	$(INCL)\gold.h \
X! 	     $(INCL)\trap.h	    $(INCL)\flag.h	$(INCL)\rm.h \
X! 	     $(OVERLAY_H)
X  
X  ## extern.h, and decl.h contain only external declarations.
X  ##
X--- 262,281 ----
X  # header dependencies
X  
X  PCCONF_H   = $(INCL)\$(TARG)conf.h  $(INCL)\msdos.h	$(INCL)\system.h
X! GLOBAL_H   = $(PCCONF_H)	    $(INCL)\global.h	$(INCL)\coord.h
X! CONFIG_H   = $(GLOBAL_H)	    $(INCL)\config.h	$(INCL)\tradstdc.h
X  TRAP_H	   = $(INCL)\trap.h
X! PERMONST_H = $(INCL)\permonst.h     $(INCL)\monattk.h	$(INCL)\monflag.h
X! YOUPROP_H  = $(PERMONST_H)	    $(INCL)\prop.h	$(INCL)\mondata.h \
X! 	     $(INCL)\pm.h	    $(INCL)\youprop.h
X! YOU_H	   = $(YOUPROP_H)	    $(INCL)\attrib.h	$(INCL)\monst.h	\
X! 	     $(INCL)\you.h
X! DECL_H	   = $(YOU_H)		    $(INCL)\decl.h	$(INCL)\obj.h \
X! 	     $(INCL)\onames.h	    $(INCL)\spell.h	$(INCL)\color.h
X! HACK_H	   = $(CONFIG_H)	    $(DECL_H)		$(INCL)\trap.h \
X! 	     $(INCL)\flag.h	    $(INCL)\gold.h	$(INCL)\mkroom.h \
X! 	     $(INCL)\monsym.h	    $(INCL)\objclass.h	$(INCL)\rm.h \
X! 	     $(INCL)\hack.h	    $(OVERLAY_H)
X  
X  ## extern.h, and decl.h contain only external declarations.
X  ##
X***************
X*** 447,453 ****
X  $(OBJ)\do_wear.obj:	$(HACK_H)
X  $(OBJ)\dog.obj: 	$(HACK_H)   $(INCL)\edog.h
X  $(OBJ)\dogmove.obj:	$(HACK_H)   $(INCL)\mfndpos.h	 $(INCL)\edog.h
X! $(OBJ)\dokick.obj:	$(HACK_H)
X  $(OBJ)\dothrow.obj:	$(HACK_H)
X  $(OBJ)\eat.obj: 	$(HACK_H)
X  $(OBJ)\end.obj: 	$(HACK_H)   $(INCL)\eshk.h
X--- 449,455 ----
X  $(OBJ)\do_wear.obj:	$(HACK_H)
X  $(OBJ)\dog.obj: 	$(HACK_H)   $(INCL)\edog.h
X  $(OBJ)\dogmove.obj:	$(HACK_H)   $(INCL)\mfndpos.h	 $(INCL)\edog.h
X! $(OBJ)\dokick.obj:	$(HACK_H)   $(INCL)\eshk.h
X  $(OBJ)\dothrow.obj:	$(HACK_H)
X  $(OBJ)\eat.obj: 	$(HACK_H)
X  $(OBJ)\end.obj: 	$(HACK_H)   $(INCL)\eshk.h
X***************
X*** 461,467 ****
X  $(OBJ)\ioctl.obj:	$(HACK_H)
X  $(OBJ)\lev_comp.obj:	$(HACK_H)   $(INCL)\sp_lev.h
X  $(OBJ)\lev_lex.obj:	$(HACK_H)   $(INCL)\sp_lev.h	 $(INCL)\lev_comp.h
X! $(OBJ)\lev_main.obj:	$(HACK_H)   $(INCL)\sp_lev.h
X  $(OBJ)\lock.obj:	$(HACK_H)
X  $(OBJ)\makemon.obj:	$(HACK_H)
X  $(OBJ)\mail.obj:	$(HACK_H)
X--- 463,469 ----
X  $(OBJ)\ioctl.obj:	$(HACK_H)
X  $(OBJ)\lev_comp.obj:	$(HACK_H)   $(INCL)\sp_lev.h
X  $(OBJ)\lev_lex.obj:	$(HACK_H)   $(INCL)\sp_lev.h	 $(INCL)\lev_comp.h
X! $(OBJ)\lev_main.obj:	$(HACK_H)
X  $(OBJ)\lock.obj:	$(HACK_H)
X  $(OBJ)\makemon.obj:	$(HACK_H)
X  $(OBJ)\mail.obj:	$(HACK_H)
X***************
X*** 475,490 ****
X  $(OBJ)\mon.obj: 	$(HACK_H)   $(INCL)\mfndpos.h	 $(INCL)\wseg.h
X  $(OBJ)\mondata.obj:	$(HACK_H)   $(INCL)\eshk.h	 $(INCL)\epri.h
X  $(OBJ)\monmove.obj:	$(HACK_H)   $(INCL)\mfndpos.h	 $(INCL)\artifact.h
X! $(OBJ)\monst.obj:	$(CONFIG_H) $(PERMONST_H)	 $(INCL)\eshk.h \
X! 				    $(INCL)\vault.h	 $(INCL)\epri.h
X  $(OBJ)\msdos.obj:	$(HACK_H) msdos.c
X  	$(CC) $(CFLAGS) -A- $*.c
X  # set ANSI only off -- many MS-DOS specific things.
X  $(OBJ)\mthrowu.obj:	$(HACK_H)
X  $(OBJ)\music.obj:	$(HACK_H)
X! $(OBJ)\o_init.obj:	$(HACK_H)   $(INCL)\onames.h
X  $(OBJ)\objects.obj:	$(CONFIG_H) $(INCL)\obj.h	 $(INCL)\objclass.h \
X! 				    $(INCL)\prop.h
X  $(OBJ)\objnam.obj:	$(HACK_H)
X  $(OBJ)\options.obj:	$(HACK_H)
X  $(OBJ)\pager.obj:	$(HACK_H)
X--- 477,493 ----
X  $(OBJ)\mon.obj: 	$(HACK_H)   $(INCL)\mfndpos.h	 $(INCL)\wseg.h
X  $(OBJ)\mondata.obj:	$(HACK_H)   $(INCL)\eshk.h	 $(INCL)\epri.h
X  $(OBJ)\monmove.obj:	$(HACK_H)   $(INCL)\mfndpos.h	 $(INCL)\artifact.h
X! $(OBJ)\monst.obj:	$(CONFIG_H) $(PERMONST_H)	 $(INCL)\monsym.h \
X! 				    $(INCL)\eshk.h	 $(INCL)\vault.h \
X! 				    $(INCL)\epri.h	 $(INCL)\color.h
X  $(OBJ)\msdos.obj:	$(HACK_H) msdos.c
X  	$(CC) $(CFLAGS) -A- $*.c
X  # set ANSI only off -- many MS-DOS specific things.
X  $(OBJ)\mthrowu.obj:	$(HACK_H)
X  $(OBJ)\music.obj:	$(HACK_H)
X! $(OBJ)\o_init.obj:	$(HACK_H)
X  $(OBJ)\objects.obj:	$(CONFIG_H) $(INCL)\obj.h	 $(INCL)\objclass.h \
X! 				    $(INCL)\prop.h	 $(INCL)\color.h
X  $(OBJ)\objnam.obj:	$(HACK_H)
X  $(OBJ)\options.obj:	$(HACK_H)
X  $(OBJ)\pager.obj:	$(HACK_H)
X*** others/Old/NetHack.cnf	Sun Jun  3 15:20:33 1990
X--- others/NetHack.cnf	Wed May 23 17:55:11 1990
X***************
X*** 12,20 ****
X  # These two options should be used for most setups.  If you're machine isn't
X  # very IBM-compatible, and NetHack doesn't work, try commenting out this line.
X  #
X! OPTIONS=rawio,IBM_BIOS
X  # DEC Rainbows will hang if rawio is set, so they should instead use:
X! #OPTIONS=IBM_BIOS,DEC_Rainbow
X  #
X  #
X  # Some options to set personal preferences.  Uncomment and change these to
X--- 12,20 ----
X  # These two options should be used for most setups.  If you're machine isn't
X  # very IBM-compatible, and NetHack doesn't work, try commenting out this line.
X  #
X! OPTIONS=rawio,IBM_BIOS,IBMgraphics
X  # DEC Rainbows will hang if rawio is set, so they should instead use:
X! #OPTIONS=IBM_BIOS,DECgraphics
X  #
X  #
X  # Some options to set personal preferences.  Uncomment and change these to
X***************
X*** 68,77 ****
X  # If you specify less that 35 ASCII values, the remaining characters will be
X  # set to their respective defaults.
X  #
X  #
X  # An example using the IBM graphics character set:
X  #	   ' '  |   -   .   .   `   '   -   -   -   -   -   |   -   \   /   .   -   |   +   .   #   <   >   ^   "   }   {   #   \   _   <   >   #   #
X! GRAPHICS = 032 179 196 218 191 192 217 197 193 194 180 195 179 196 092 047 249 239 239 254 249 177 060 062 094 157 247 244 035 190 220 060 062 186 205
X  # An alternative:
X  #GRAPHICS= 032 186 205 201 187 200 188 206 202 203 185 204 179 196 092 047 249 239 239 254 249 177 060 062 094 034 247 244 035 092 095 060 062 179 196
X  #
X--- 68,80 ----
X  # If you specify less that 35 ASCII values, the remaining characters will be
X  # set to their respective defaults.
X  #
X+ # If you merely set the IBMgraphics option as above, NetHack will use IBM
X+ # extended ASCII for dungeon characters.  If you don't like the selections,
X+ # you can make up your own via the graphics option (and not set IBMgraphics).
X  #
X  # An example using the IBM graphics character set:
X  #	   ' '  |   -   .   .   `   '   -   -   -   -   -   |   -   \   /   .   -   |   +   .   #   <   >   ^   "   }   {   #   \   _   <   >   #   #
X! #GRAPHICS = 032 179 196 218 191 192 217 197 193 194 180 195 179 196 092 047 249 239 239 254 249 177 060 062 094 157 247 244 035 190 220 060 062 186 205
X  # An alternative:
X  #GRAPHICS= 032 186 205 201 187 200 188 206 202 203 185 204 179 196 092 047 249 239 239 254 249 177 060 062 094 034 247 244 035 092 095 060 062 179 196
X  #
X***************
X*** 78,87 ****
X  #
X  # Using the DEC Rainbow/ANSI line-drawing character set:
X  #
X! # You must also set the DECRainbow option, above.  NetHack will then switch
X! # into the line drawing character set for any values over 128 below.  Just
X! # add 128 to the value of any line-drawing character you want to use.  You
X! # can use characters from both sets this way.  These are also the characters
X! # to use for the ANSI ruling character set '0'.
X  #
X  #GRAPHICS= 032 248 241 236 235 237 234 238 246 247 245 244 248 241 092 047 254 241 248 043 254 225
X--- 81,91 ----
X  #
X  # Using the DEC Rainbow/ANSI line-drawing character set:
X  #
X! # If you have compiled with TERMLIB, merely set the DECgraphics option as
X! # above.  NetHack will then switch into the VTxxx line-drawing character set
X! # (aka ANSI ruling character set '0') for dungeon characters.  If you don't
X! # like the selections, you can make up your own via the graphics option,
X! # adding 128 to the value of any line-drawing character you want to use.
X! # (In such a case, do not set DECgraphics.)
X  #
X  #GRAPHICS= 032 248 241 236 235 237 234 238 246 247 245 244 248 241 092 047 254 241 248 043 254 225
X*** others/Old/lev_lex.c	Sun Jun  3 15:21:46 1990
X--- others/lev_lex.c	Sun Jun  3 15:16:49 1990
X***************
X*** 167,172 ****
X--- 167,173 ----
X  
X  #ifdef MSDOS
X  #undef exit
X+ extern void FDECL(exit, (int));
X  #endif
X  
X  /* this doesn't always get put in lev_comp.h
X***************
X*** 196,202 ****
X  #define YYLMAX	2048
X  
X  #define MAPC 1
X! # line 61 "lev_comp.l"
X  #define YY_END_OF_BUFFER 57
X  typedef int yy_state_type;
X  static const short int yy_accept[274] =
X--- 197,203 ----
X  #define YYLMAX	2048
X  
X  #define MAPC 1
X! # line 62 "lev_comp.l"
X  #define YY_END_OF_BUFFER 57
X  typedef int yy_state_type;
X  static const short int yy_accept[274] =
X***************
X*** 584,594 ****
X  		continue; /* go to "YY_DO_BEFORE_ACTION" */
X  
X  case 1:
X! # line 62 "lev_comp.l"
X  { line_number++; yymore(); }	
X  	YY_BREAK
X  case 2:
X! # line 63 "lev_comp.l"
X  { BEGIN 0;
X  		  line_number++;
X  		  yytext[yyleng-7] = 0; /* Discard \nENDMAP */
X--- 585,595 ----
X  		continue; /* go to "YY_DO_BEFORE_ACTION" */
X  
X  case 1:
X! # line 63 "lev_comp.l"
X  { line_number++; yymore(); }	
X  	YY_BREAK
X  case 2:
X! # line 64 "lev_comp.l"
X  { BEGIN 0;
X  		  line_number++;
X  		  yytext[yyleng-7] = 0; /* Discard \nENDMAP */
X***************
X*** 598,796 ****
X  		}
X  	YY_BREAK
X  case 3:
X! # line 70 "lev_comp.l"
X  { line_number++; }
X  	YY_BREAK
X  case 4:
X! # line 71 "lev_comp.l"
X  return MAZE_ID;
X  	YY_BREAK
X  case 5:
X! # line 72 "lev_comp.l"
X  return LEVEL_ID;
X  	YY_BREAK
X  case 6:
X! # line 73 "lev_comp.l"
X  return GEOMETRY_ID;
X  	YY_BREAK
X  case 7:
X! # line 74 "lev_comp.l"
X  { BEGIN MAPC; line_number++; }
X  	YY_BREAK
X  case 8:
X! # line 75 "lev_comp.l"
X  return OBJECT_ID;
X  	YY_BREAK
X  case 9:
X! # line 76 "lev_comp.l"
X  return MONSTER_ID;
X  	YY_BREAK
X  case 10:
X! # line 77 "lev_comp.l"
X  return TRAP_ID;
X  	YY_BREAK
X  case 11:
X! # line 78 "lev_comp.l"
X  return DOOR_ID;
X  	YY_BREAK
X  case 12:
X! # line 79 "lev_comp.l"
X  return DRAWBRIDGE_ID;
X  	YY_BREAK
X  case 13:
X! # line 80 "lev_comp.l"
X  return MAZEWALK_ID;
X  	YY_BREAK
X  case 14:
X! # line 81 "lev_comp.l"
X  return REGION_ID;
X  	YY_BREAK
X  case 15:
X! # line 82 "lev_comp.l"
X  return RANDOM_OBJECTS_ID;
X  	YY_BREAK
X  case 16:
X! # line 83 "lev_comp.l"
X  return RANDOM_MONSTERS_ID;
X  	YY_BREAK
X  case 17:
X! # line 84 "lev_comp.l"
X  return RANDOM_PLACES_ID;
X  	YY_BREAK
X  case 18:
X! # line 85 "lev_comp.l"
X  return ALTAR_ID;
X  	YY_BREAK
X  case 19:
X! # line 86 "lev_comp.l"
X  return LADDER_ID;
X  	YY_BREAK
X  case 20:
X! # line 87 "lev_comp.l"
X  return NON_DIGGABLE_ID;
X  	YY_BREAK
X  case 21:
X! # line 88 "lev_comp.l"
X  return ROOM_ID;
X  	YY_BREAK
X  case 22:
X! # line 89 "lev_comp.l"
X  { yylval.i=D_ISOPEN; return DOOR_STATE; }
X  	YY_BREAK
X  case 23:
X! # line 90 "lev_comp.l"
X  { yylval.i=D_CLOSED; return DOOR_STATE; }
X  	YY_BREAK
X  case 24:
X! # line 91 "lev_comp.l"
X  { yylval.i=D_LOCKED; return DOOR_STATE; }
X  	YY_BREAK
X  case 25:
X! # line 92 "lev_comp.l"
X  { yylval.i=D_NODOOR; return DOOR_STATE; }
X  	YY_BREAK
X  case 26:
X! # line 93 "lev_comp.l"
X  { yylval.i=D_BROKEN; return DOOR_STATE; }
X  	YY_BREAK
X  case 27:
X! # line 94 "lev_comp.l"
X  { yylval.i=W_NORTH; return DIRECTION; }
X  	YY_BREAK
X  case 28:
X! # line 95 "lev_comp.l"
X  { yylval.i=W_EAST; return DIRECTION; }
X  	YY_BREAK
X  case 29:
X! # line 96 "lev_comp.l"
X  { yylval.i=W_SOUTH; return DIRECTION; }
X  	YY_BREAK
X  case 30:
X! # line 97 "lev_comp.l"
X  { yylval.i=W_WEST; return DIRECTION; }
X  	YY_BREAK
X  case 31:
X! # line 98 "lev_comp.l"
X  { yylval.i = -1; return RANDOM_TYPE; }
X  	YY_BREAK
X  case 32:
X! # line 99 "lev_comp.l"
X  return O_REGISTER;
X  	YY_BREAK
X  case 33:
X! # line 100 "lev_comp.l"
X  return M_REGISTER;
X  	YY_BREAK
X  case 34:
X! # line 101 "lev_comp.l"
X  return P_REGISTER;
X  	YY_BREAK
X  case 35:
X! # line 102 "lev_comp.l"
X  return A_REGISTER;
X  	YY_BREAK
X  case 36:
X! # line 103 "lev_comp.l"
X  { yylval.i=1; return LEFT_OR_RIGHT; }
X  	YY_BREAK
X  case 37:
X! # line 104 "lev_comp.l"
X  { yylval.i=3; return LEFT_OR_RIGHT; }
X  	YY_BREAK
X  case 38:
X! # line 105 "lev_comp.l"
X  { yylval.i=2; return CENTER; }
X  	YY_BREAK
X  case 39:
X! # line 106 "lev_comp.l"
X  { yylval.i=1; return TOP_OR_BOT; }
X  	YY_BREAK
X  case 40:
X! # line 107 "lev_comp.l"
X  { yylval.i=3; return TOP_OR_BOT; }
X  	YY_BREAK
X  case 41:
X! # line 108 "lev_comp.l"
X  { yylval.i=1; return LIGHT_STATE; }
X  	YY_BREAK
X  case 42:
X! # line 109 "lev_comp.l"
X  { yylval.i=0; return LIGHT_STATE; }
X  	YY_BREAK
X  case 43:
X! # line 110 "lev_comp.l"
X  { yylval.i=A_LAW; return ALIGNMENT; }
X  	YY_BREAK
X  case 44:
X! # line 111 "lev_comp.l"
X  { yylval.i=A_NEUTRAL; return ALIGNMENT; }
X  	YY_BREAK
X  case 45:
X! # line 112 "lev_comp.l"
X  { yylval.i=A_CHAOS; return ALIGNMENT; }
X  	YY_BREAK
X  case 46:
X! # line 113 "lev_comp.l"
X  { yylval.i=1; return ALTAR_TYPE; }
X  	YY_BREAK
X  case 47:
X! # line 114 "lev_comp.l"
X  { yylval.i=0; return ALTAR_TYPE; }
X  	YY_BREAK
X  case 48:
X! # line 115 "lev_comp.l"
X  { yylval.i=1; return UP_OR_DOWN; }
X  	YY_BREAK
X  case 49:
X! # line 116 "lev_comp.l"
X  { yylval.i=0; return UP_OR_DOWN; }
X  	YY_BREAK
X  case 50:
X! # line 117 "lev_comp.l"
X  { yylval.i=atoi(yytext); return INTEGER; }
X  	YY_BREAK
X  case 51:
X! # line 118 "lev_comp.l"
X  { yytext[yyleng-1] = 0; /* Discard the trailing \" */
X  		  yylval.map = (char *) alloc(strlen(yytext+1)+1);
X  		  strcpy(yylval.map, yytext+1); /* Discard the first \" */
X--- 599,797 ----
X  		}
X  	YY_BREAK
X  case 3:
X! # line 71 "lev_comp.l"
X  { line_number++; }
X  	YY_BREAK
X  case 4:
X! # line 72 "lev_comp.l"
X  return MAZE_ID;
X  	YY_BREAK
X  case 5:
X! # line 73 "lev_comp.l"
X  return LEVEL_ID;
X  	YY_BREAK
X  case 6:
X! # line 74 "lev_comp.l"
X  return GEOMETRY_ID;
X  	YY_BREAK
X  case 7:
X! # line 75 "lev_comp.l"
X  { BEGIN MAPC; line_number++; }
X  	YY_BREAK
X  case 8:
X! # line 76 "lev_comp.l"
X  return OBJECT_ID;
X  	YY_BREAK
X  case 9:
X! # line 77 "lev_comp.l"
X  return MONSTER_ID;
X  	YY_BREAK
X  case 10:
X! # line 78 "lev_comp.l"
X  return TRAP_ID;
X  	YY_BREAK
X  case 11:
X! # line 79 "lev_comp.l"
X  return DOOR_ID;
X  	YY_BREAK
X  case 12:
X! # line 80 "lev_comp.l"
X  return DRAWBRIDGE_ID;
X  	YY_BREAK
X  case 13:
X! # line 81 "lev_comp.l"
X  return MAZEWALK_ID;
X  	YY_BREAK
X  case 14:
X! # line 82 "lev_comp.l"
X  return REGION_ID;
X  	YY_BREAK
X  case 15:
X! # line 83 "lev_comp.l"
X  return RANDOM_OBJECTS_ID;
X  	YY_BREAK
X  case 16:
X! # line 84 "lev_comp.l"
X  return RANDOM_MONSTERS_ID;
X  	YY_BREAK
X  case 17:
X! # line 85 "lev_comp.l"
X  return RANDOM_PLACES_ID;
X  	YY_BREAK
X  case 18:
X! # line 86 "lev_comp.l"
X  return ALTAR_ID;
X  	YY_BREAK
X  case 19:
X! # line 87 "lev_comp.l"
X  return LADDER_ID;
X  	YY_BREAK
X  case 20:
X! # line 88 "lev_comp.l"
X  return NON_DIGGABLE_ID;
X  	YY_BREAK
X  case 21:
X! # line 89 "lev_comp.l"
X  return ROOM_ID;
X  	YY_BREAK
X  case 22:
X! # line 90 "lev_comp.l"
X  { yylval.i=D_ISOPEN; return DOOR_STATE; }
X  	YY_BREAK
X  case 23:
X! # line 91 "lev_comp.l"
X  { yylval.i=D_CLOSED; return DOOR_STATE; }
X  	YY_BREAK
X  case 24:
X! # line 92 "lev_comp.l"
X  { yylval.i=D_LOCKED; return DOOR_STATE; }
X  	YY_BREAK
X  case 25:
X! # line 93 "lev_comp.l"
X  { yylval.i=D_NODOOR; return DOOR_STATE; }
X  	YY_BREAK
X  case 26:
X! # line 94 "lev_comp.l"
X  { yylval.i=D_BROKEN; return DOOR_STATE; }
X  	YY_BREAK
X  case 27:
X! # line 95 "lev_comp.l"
X  { yylval.i=W_NORTH; return DIRECTION; }
X  	YY_BREAK
X  case 28:
X! # line 96 "lev_comp.l"
X  { yylval.i=W_EAST; return DIRECTION; }
X  	YY_BREAK
X  case 29:
X! # line 97 "lev_comp.l"
X  { yylval.i=W_SOUTH; return DIRECTION; }
X  	YY_BREAK
X  case 30:
X! # line 98 "lev_comp.l"
X  { yylval.i=W_WEST; return DIRECTION; }
X  	YY_BREAK
X  case 31:
X! # line 99 "lev_comp.l"
X  { yylval.i = -1; return RANDOM_TYPE; }
X  	YY_BREAK
X  case 32:
X! # line 100 "lev_comp.l"
X  return O_REGISTER;
X  	YY_BREAK
X  case 33:
X! # line 101 "lev_comp.l"
X  return M_REGISTER;
X  	YY_BREAK
X  case 34:
X! # line 102 "lev_comp.l"
X  return P_REGISTER;
X  	YY_BREAK
X  case 35:
X! # line 103 "lev_comp.l"
X  return A_REGISTER;
X  	YY_BREAK
X  case 36:
X! # line 104 "lev_comp.l"
X  { yylval.i=1; return LEFT_OR_RIGHT; }
X  	YY_BREAK
X  case 37:
X! # line 105 "lev_comp.l"
X  { yylval.i=3; return LEFT_OR_RIGHT; }
X  	YY_BREAK
X  case 38:
X! # line 106 "lev_comp.l"
X  { yylval.i=2; return CENTER; }
X  	YY_BREAK
X  case 39:
X! # line 107 "lev_comp.l"
X  { yylval.i=1; return TOP_OR_BOT; }
X  	YY_BREAK
X  case 40:
X! # line 108 "lev_comp.l"
X  { yylval.i=3; return TOP_OR_BOT; }
X  	YY_BREAK
X  case 41:
X! # line 109 "lev_comp.l"
X  { yylval.i=1; return LIGHT_STATE; }
X  	YY_BREAK
X  case 42:
X! # line 110 "lev_comp.l"
X  { yylval.i=0; return LIGHT_STATE; }
X  	YY_BREAK
X  case 43:
X! # line 111 "lev_comp.l"
X  { yylval.i=A_LAW; return ALIGNMENT; }
X  	YY_BREAK
X  case 44:
X! # line 112 "lev_comp.l"
X  { yylval.i=A_NEUTRAL; return ALIGNMENT; }
X  	YY_BREAK
X  case 45:
X! # line 113 "lev_comp.l"
X  { yylval.i=A_CHAOS; return ALIGNMENT; }
X  	YY_BREAK
X  case 46:
X! # line 114 "lev_comp.l"
X  { yylval.i=1; return ALTAR_TYPE; }
X  	YY_BREAK
X  case 47:
X! # line 115 "lev_comp.l"
X  { yylval.i=0; return ALTAR_TYPE; }
X  	YY_BREAK
X  case 48:
X! # line 116 "lev_comp.l"
X  { yylval.i=1; return UP_OR_DOWN; }
X  	YY_BREAK
X  case 49:
X! # line 117 "lev_comp.l"
X  { yylval.i=0; return UP_OR_DOWN; }
X  	YY_BREAK
X  case 50:
X! # line 118 "lev_comp.l"
X  { yylval.i=atoi(yytext); return INTEGER; }
X  	YY_BREAK
X  case 51:
X! # line 119 "lev_comp.l"
X  { yytext[yyleng-1] = 0; /* Discard the trailing \" */
X  		  yylval.map = (char *) alloc(strlen(yytext+1)+1);
X  		  strcpy(yylval.map, yytext+1); /* Discard the first \" */
X***************
X*** 797,819 ****
X  		  return STRING; }
X  	YY_BREAK
X  case 52:
X! # line 122 "lev_comp.l"
X  { line_number++; }
X  	YY_BREAK
X  case 53:
X! # line 123 "lev_comp.l"
X  ;
X  	YY_BREAK
X  case 54:
X! # line 124 "lev_comp.l"
X  { yylval.i = yytext[1]; return CHAR; }
X  	YY_BREAK
X  case 55:
X! # line 125 "lev_comp.l"
X  { return yytext[0]; }
X  	YY_BREAK
X  case 56:
X! # line 126 "lev_comp.l"
X  ECHO;
X  	YY_BREAK
X  case YY_STATE_EOF(INITIAL):
X--- 798,820 ----
X  		  return STRING; }
X  	YY_BREAK
X  case 52:
X! # line 123 "lev_comp.l"
X  { line_number++; }
X  	YY_BREAK
X  case 53:
X! # line 124 "lev_comp.l"
X  ;
X  	YY_BREAK
X  case 54:
X! # line 125 "lev_comp.l"
X  { yylval.i = yytext[1]; return CHAR; }
X  	YY_BREAK
X  case 55:
X! # line 126 "lev_comp.l"
X  { return yytext[0]; }
X  	YY_BREAK
X  case 56:
X! # line 127 "lev_comp.l"
X  ECHO;
X  	YY_BREAK
X  case YY_STATE_EOF(INITIAL):
X***************
X*** 1104,1110 ****
X      yyin = input_file;
X      yy_init = 1;
X      }
X! # line 126 "lev_comp.l"
X  
X  #ifdef	AMIGA
X  long *alloc(n)
X--- 1105,1111 ----
X      yyin = input_file;
X      yy_init = 1;
X      }
X! # line 127 "lev_comp.l"
X  
X  #ifdef	AMIGA
X  long *alloc(n)
X*** others/Old/msdos.c	Sun Jun  3 15:22:46 1990
X--- others/msdos.c	Sun Jun  3 14:59:15 1990
X***************
X*** 27,43 ****
X  #include <fcntl.h>
X  #include <process.h>
X  
X! static char DOSgetch();
X  # ifdef DGK
X! static char BIOSgetch();
X  # endif
X  # ifdef TOS
X! static void init_aline();
X  char *_a_line;			/* for Line A variables */
X  # else
X! static unsigned int ioctl();
X  # endif
X  
X  void
X  flushout()
X  {
X--- 27,54 ----
X  #include <fcntl.h>
X  #include <process.h>
X  
X! static char NDECL(DOSgetch);
X  # ifdef DGK
X! static char NDECL(BIOSgetch);
X  # endif
X  # ifdef TOS
X! static void NDECL(init_aline);
X  char *_a_line;			/* for Line A variables */
X  # else
X! static unsigned int FDECL(ioctl, (int,int,unsigned));
X! static boolean NDECL(comspec_exists);
X  # endif
X  
X+ static int FDECL(findfirst, (char *));
X+ static int NDECL(findnext);
X+ static boolean NDECL(record_exists);
X+ # if !defined(TOS) && !defined(__TURBOC__) && !defined(OS2)
X+ static char NDECL(switchar);
X+ # endif
X+ # ifndef OS2
X+ static char * NDECL(getdta);
X+ # endif
X+ 
X  void
X  flushout()
X  {
X***************
X*** 111,177 ****
X   *    shift values below.
X   */
X  static const struct pad {
X! 	char normal, shift;
X  } keypad[PADKEYS] = {
X  #  ifdef TOS
X! 			{C('['), 'Q'},		/* UNDO */
X! 			{'?', '/'},		/* HELP */
X! 			{'(', 'a'},		/* ( */
X! 			{')', 'w'},		/* ) */
X! 			{'/', '/'},		/* / */
X! 			{C('p'), '$'},		/* * */
X! #  endif
X! 			{'y', 'Y'},		/* 7 */
X! 			{'k', 'K'},		/* 8 */
X! 			{'u', 'U'},		/* 9 */
X! #  ifndef TOS
X! 			{'m', C('p')},		/* - */
X! #  endif
X! 			{'h', 'H'},		/* 4 */
X! #  ifdef TOS
X! 			{'.', '.'},
X! #  else
X! 			{'g', 'g'},		/* 5 */
X! #  endif
X! 			{'l', 'L'},		/* 6 */
X! #  ifndef TOS
X! 			{'p', 'P'},		/* + */
X! #  endif
X! 			{'b', 'B'},		/* 1 */
X! 			{'j', 'J'},		/* 2 */
X! 			{'n', 'N'},		/* 3 */
X! 			{'i', 'I'},		/* Ins */
X! 			{'.', ':'}		/* Del */
X  }, numpad[PADKEYS] = {
X  #  ifdef TOS
X! 			{C('['), 'Q'}	,	/* UNDO */
X! 			{'?', '/'},		/* HELP */
X! 			{'(', 'a'},		/* ( */
X! 			{')', 'w'},		/* ) */
X! 			{'/', '/'},		/* / */
X! 			{C('p'), '$'},		/* * */
X! #  endif
X! 			{'7', M('7')},		/* 7 */
X! 			{'8', M('8')},		/* 8 */
X! 			{'9', M('9')},		/* 9 */
X! #  ifndef TOS
X! 			{'m', C('p')},		/* - */
X! #  endif
X! 			{'4', M('4')},		/* 4 */
X! #  ifdef TOS
X! 			{'.', '.'},		/* 5 */
X! #  else
X! 			{'g', 'G'},		/* 5 */
X! #  endif
X! 			{'6', M('6')},		/* 6 */
X! #  ifndef TOS
X! 			{'p', 'P'},		/* + */
X! #  endif
X! 			{'1', M('1')},		/* 1 */
X! 			{'2', M('2')},		/* 2 */
X! 			{'3', M('3')},		/* 3 */
X! 			{'i', 'I'},		/* Ins */
X! 			{'.', ':'}		/* Del */
X  };
X  
X  /*
X--- 122,188 ----
X   *    shift values below.
X   */
X  static const struct pad {
X! 	char normal, shift, cntrl;
X  } keypad[PADKEYS] = {
X  #  ifdef TOS
X! 			{C('['), 'Q', C('[')},		/* UNDO */
X! 			{'?', '/', '?'},		/* HELP */
X! 			{'(', 'a', '('},		/* ( */
X! 			{')', 'w', ')'},		/* ) */
X! 			{'/', '/', '/'},		/* / */
X! 			{C('p'), '$', C('p')},		/* * */
X! #  endif
X! 			{'y', 'Y', C('y')},		/* 7 */
X! 			{'k', 'K', C('k')},		/* 8 */
X! 			{'u', 'U', C('u')},		/* 9 */
X! #  ifndef TOS
X! 			{'m', C('p'), C('p')},		/* - */
X! #  endif
X! 			{'h', 'H', C('h')},		/* 4 */
X! #  ifdef TOS
X! 			{'.', '.', '.'},
X! #  else
X! 			{'g', 'g', 'g'},		/* 5 */
X! #  endif
X! 			{'l', 'L', C('l')},		/* 6 */
X! #  ifndef TOS
X! 			{'p', 'P', C('p')},		/* + */
X! #  endif
X! 			{'b', 'B', C('b')},		/* 1 */
X! 			{'j', 'J', C('j')},		/* 2 */
X! 			{'n', 'N', C('n')},		/* 3 */
X! 			{'i', 'I', C('i')},		/* Ins */
X! 			{'.', ':', ':'}			/* Del */
X  }, numpad[PADKEYS] = {
X  #  ifdef TOS
X! 			{C('['), 'Q', C('[')}	,	/* UNDO */
X! 			{'?', '/', '?'},		/* HELP */
X! 			{'(', 'a', '('},		/* ( */
X! 			{')', 'w', ')'},		/* ) */
X! 			{'/', '/', '/'},		/* / */
X! 			{C('p'), '$', C('p')},		/* * */
X! #  endif
X! 			{'7', M('7'), '7'},		/* 7 */
X! 			{'8', M('8'), '8'},		/* 8 */
X! 			{'9', M('9'), '9'},		/* 9 */
X! #  ifndef TOS
X! 			{'m', C('p'), C('p')},		/* - */
X! #  endif
X! 			{'4', M('4'), '4'},		/* 4 */
X! #  ifdef TOS
X! 			{'.', '.', '.'},		/* 5 */
X! #  else
X! 			{'g', 'G', 'g'},		/* 5 */
X! #  endif
X! 			{'6', M('6'), '6'},		/* 6 */
X! #  ifndef TOS
X! 			{'p', 'P', C('p')},		/* + */
X! #  endif
X! 			{'1', M('1'), '1'},		/* 1 */
X! 			{'2', M('2'), '2'},		/* 2 */
X! 			{'3', M('3'), '3'},		/* 3 */
X! 			{'i', 'I', C('i')},		/* Ins */
X! 			{'.', ':', ':'}			/* Del */
X  };
X  
X  /*
X***************
X*** 250,255 ****
X--- 261,268 ----
X  		kpad = flags.num_pad ? numpad : keypad;
X  		if (shift & SHIFT)
X  			ch = kpad[scan - KEYPADLO].shift;
X+ 		else if (shift & CTRL)
X+ 			ch = kpad[scan - KEYPADLO].cntrl;
X  		else
X  			ch = kpad[scan - KEYPADLO].normal;
X  	}
X***************
X*** 359,368 ****
X  		}
X  #ifdef TOS
X  /* Some shells (e.g. Gulam) turn the cursor off when they exit */
X! 		if (flags.IBMBIOS)
X  			(void)Cursconf(1, -1);
X! #endif
X  		gettty(); /* ctrl-P might get turned back on (TH) */
X  		chdirx(hackdir, 0);
X  		start_screen();
X  		docrt();
X--- 372,385 ----
X  		}
X  #ifdef TOS
X  /* Some shells (e.g. Gulam) turn the cursor off when they exit */
X! 		if (flags.IBMBIOS) {
X  			(void)Cursconf(1, -1);
X! 			get_scr_size(); /* maybe they changed the screen */
X! 		}
X! #else
X  		gettty(); /* ctrl-P might get turned back on (TH) */
X+ 		get_scr_size(); /* maybe the screen mode changed (TH) */
X+ #endif
X  		chdirx(hackdir, 0);
X  		start_screen();
X  		docrt();
X***************
X*** 655,661 ****
X--- 672,680 ----
X  		return;
X  	}
X  
X+ #  ifdef TOS
X  error_copying:
X+ #  endif
X  	/* Last file didn't get there.
X  	 */
X  	Sprintf(to, "%s%s", topath, allbones);
X*** others/Old/pcmain.c	Sun Jun  3 15:25:44 1990
X--- others/pcmain.c	Thu May 31 22:10:27 1990
X***************
X*** 13,21 ****
X  #include <sys\stat.h>
X  #endif
X  #endif
X  #ifdef MACOS
X  extern WindowPtr	HackWindow;
X- extern short *switches;
X  extern short macflags;
X  pascal boolean FDECL(startDlogFProc, (DialogPtr, EventRecord *, short *));
X  #define msmsg mprintf
X--- 13,24 ----
X  #include <sys\stat.h>
X  #endif
X  #endif
X+ 
X+ #if defined(LATTICE) || defined(MACOS)
X+ extern short *switches;
X+ #endif
X  #ifdef MACOS
X  extern WindowPtr	HackWindow;
X  extern short macflags;
X  pascal boolean FDECL(startDlogFProc, (DialogPtr, EventRecord *, short *));
X  #define msmsg mprintf
X***************
X*** 71,76 ****
X--- 74,81 ----
X  extern int FromWBench;
X  #endif
X  
X+ int FDECL(main, (int,char **));
X+ 
X  const char *classes = "ABCEHKPRSTVW";
X  
X  int
X***************
X*** 127,138 ****
X  						(int)theFile.fName[0]);
X  			(void)strncpy(plname, (char *)&theFile.fName[1],
X  						(int)theFile.fName[0]);
X! 			SetVol(0,theFile.vRefNum);
X  			SAVEF[(int)theFile.fName[0]] = '\0';
X  			numFiles = 1;
X  		} else
X  			numFiles = 0;
X  	}
X  	switches = (short *)malloc((NROFOBJECTS+2) * sizeof(long));
X  	for (fd = 0; fd < (NROFOBJECTS + 2); fd++)
X  		switches[fd] = fd;
X--- 132,145 ----
X  						(int)theFile.fName[0]);
X  			(void)strncpy(plname, (char *)&theFile.fName[1],
X  						(int)theFile.fName[0]);
X! 			SetVol(0L,theFile.vRefNum);
X  			SAVEF[(int)theFile.fName[0]] = '\0';
X  			numFiles = 1;
X  		} else
X  			numFiles = 0;
X  	}
X+ #endif
X+ #if defined(LATTICE) || defined(MACOS)
X  	switches = (short *)malloc((NROFOBJECTS+2) * sizeof(long));
X  	for (fd = 0; fd < (NROFOBJECTS + 2); fd++)
X  		switches[fd] = fd;
X***************
X*** 202,208 ****
X  		Strcpy(hackdir, HACKDIR);
X  #endif
X  	if(argc > 1) {
X! 	    if (!strncmp(argv[1], "-d", 2)) {
X  		argc--;
X  		argv++;
X  		dir = argv[0]+2;
X--- 209,218 ----
X  		Strcpy(hackdir, HACKDIR);
X  #endif
X  	if(argc > 1) {
X! 	    if (!strncmp(argv[1], "-d", 2) && argv[1][2] != 'e') {
X! 		/* avoid matching "-dec" for DECgraphics; since the man page
X! 		 * says -d directory, hope nobody's using -desomething_else
X! 		 */
X  		argc--;
X  		argv++;
X  		dir = argv[0]+2;
X***************
X*** 306,311 ****
X--- 316,327 ----
X  			} else
X  				Printf("Player name expected after -u\n");
X  			break;
X+ 		case 'i':
X+ 			if(!strcmp(argv[0]+1, "ibm")) assign_ibm_graphics();
X+ 			break;
X+ 		case 'd':
X+ 			if(!strcmp(argv[0]+1, "dec")) assign_dec_graphics();
X+ 			break;
X  #ifdef DGK
X  		/* Player doesn't want to use a RAM disk
X  		 */
X***************
X*** 401,406 ****
X--- 417,427 ----
X  # endif
X  	Strcat(SAVEF, ".sav");
X  #else
X+ 	} else {	/* save file start, didn't askname() */
X+ 		char *stripCharSuffix;
X+ 
X+ 		if (stripCharSuffix = strrchr((char *)plname, '-'))
X+ 			*stripCharSuffix = '\0';
X  	}
X  	Strcpy(lock,plname);
X  	Strcat(lock,".99");
X***************
X*** 578,584 ****
X  #define WIZ 18
X  #define EXP 19
X  #define FEM 20
X! #define NEWS_BOX 21
X  #define SCORES 22
X  #define setCheckBox(a,b,c) {GetDItem(a,b,&kind,&knob,&box);SetCtlValue(knob,c?1:0);}
X  #define changeRadio(a,b,c) {setCheckBox(a,b,FALSE); setCheckBox(a,c,TRUE);}
X--- 599,605 ----
X  #define WIZ 18
X  #define EXP 19
X  #define FEM 20
X! #define NO_NEWS_BOX 21
X  #define SCORES 22
X  #define setCheckBox(a,b,c) {GetDItem(a,b,&kind,&knob,&box);SetCtlValue(knob,c?1:0);}
X  #define changeRadio(a,b,c) {setCheckBox(a,b,FALSE); setCheckBox(a,c,TRUE);}
X***************
X*** 621,629 ****
X  		changeDgenders(asknameDlog,TRUE);
X  	}
X  #ifdef NEWS
X! 	setCheckBox(asknameDlog,NEWS_BOX,!flags.nonews);
X  #else
X! 	Hide(NEWS_BOX);
X  #endif
X  #ifdef WIZARD
X  	wizard = FALSE;
X--- 642,650 ----
X  		changeDgenders(asknameDlog,TRUE);
X  	}
X  #ifdef NEWS
X! 	setCheckBox(asknameDlog,NO_NEWS_BOX,flags.nonews);
X  #else
X! 	Hide(NO_NEWS_BOX);
X  #endif
X  #ifdef WIZARD
X  	wizard = FALSE;
X***************
X*** 680,688 ****
X  				changeRadio(asknameDlog,VALKYRIE,ANY);
X  			}
X  			changeDgenders(asknameDlog,flags.female);
X! 		} else if(Hit == NEWS_BOX) {
X  			flags.nonews = !flags.nonews;
X! 			setCheckBox(asknameDlog,NEWS_BOX,!flags.nonews);
X  		} else if(Hit == SCORES) {
X  			justscores = !justscores;
X  			setCheckBox(asknameDlog,SCORES,justscores);
X--- 701,709 ----
X  				changeRadio(asknameDlog,VALKYRIE,ANY);
X  			}
X  			changeDgenders(asknameDlog,flags.female);
X! 		} else if(Hit == NO_NEWS_BOX) {
X  			flags.nonews = !flags.nonews;
X! 			setCheckBox(asknameDlog,NO_NEWS_BOX,flags.nonews);
X  		} else if(Hit == SCORES) {
X  			justscores = !justscores;
X  			setCheckBox(asknameDlog,SCORES,justscores);
X***************
X*** 735,741 ****
X  				*itemHit = EXP;
X  				return TRUE;
X  			case 'N' :
X! 				*itemHit = NEWS_BOX;
X  				return TRUE;
X  			case 'J' :
X  				*itemHit = SCORES;
X--- 756,762 ----
X  				*itemHit = EXP;
X  				return TRUE;
X  			case 'N' :
X! 				*itemHit = NO_NEWS_BOX;
X  				return TRUE;
X  			case 'J' :
X  				*itemHit = SCORES;
X*** others/Old/pcunix.c	Sun Jun  3 15:26:26 1990
X--- others/pcunix.c	Wed Apr 25 17:07:25 1990
X***************
X*** 20,25 ****
X--- 20,27 ----
X  #include	<sys/stat.h>
X  #endif
X  
X+ static struct tm * NDECL(getlt);
X+ 
X  #ifdef OVLB
X  
X  #ifndef MACOS
X*** others/Old/random.c	Sun Jun  3 15:26:40 1990
X--- others/random.c	Wed Apr 25 17:07:31 1990
X***************
X*** 23,28 ****
X--- 23,31 ----
X   *	- giving srandom() type void instead of allowing it to default to int
X   *	- making the first return in initstate() return a value consistent
X   *	with its type (instead of no value)
X+  *	- ANSI function prototyping in extern.h - therefore include hack.h
X+  *	instead of stdio.h and remove separate declaration of random() from
X+  *	the beginning of function srandom
X   */
X  
X  #ifdef LIBC_SCCS
X***************
X*** 31,37 ****
X  # endif
X  #endif /* LIBC_SCCS and not lint */
X  
X! #include <stdio.h>
X  
X  /*
X   * random.c:
X--- 34,40 ----
X  # endif
X  #endif /* LIBC_SCCS and not lint */
X  
X! #include "hack.h"
X  
X  /*
X   * random.c:
X***************
X*** 200,206 ****
X      unsigned		x;
X  {
X      	register  int		i, j;
X- 	long random();
X  
X  	if(  rand_type  ==  TYPE_0  )  {
X  	    state[ 0 ] = x;
X--- 203,208 ----
X*** others/Old/termcap	Sun Jun  3 15:27:50 1990
X--- others/termcap	Sun May 20 18:37:04 1990
X***************
X*** 71,77 ****
X  	:al=\E[L:dl=\E[M:ic=\E[@:dc=\E[P:
X  #
X  # For ST NetHack:
X! #
X  vt52|atari|DEC VT52:\
X  	:co#80:li#24:bs:pt:bl=^G:le=^H:do=^J:\
X  	:cl=\EH\EJ:ce=\EK:cd=\EJ:\
X--- 71,77 ----
X  	:al=\E[L:dl=\E[M:ic=\E[@:dc=\E[P:
X  #
X  # For ST NetHack:
X! #       for VT100/200/&c in VT52 mode, add :ti=\E[?2l:
X  vt52|atari|DEC VT52:\
X  	:co#80:li#24:bs:pt:bl=^G:le=^H:do=^J:\
X  	:cl=\EH\EJ:ce=\EK:cd=\EJ:\
X***************
X*** 80,102 ****
X  	:ku=\EA:kd=\EB:kl=\EC:kr=\ED:kb=^H:\
X  	:sr=\EI:as=\EF:ae=\EG:
X  #
X! # For Amiga NetHack:
X! #
X! vt100|amiga|DEC VT100:\
X  	:co#80:li#24:bs:pt:am:mi:bl=^G:le=^H:do=^J:xo:vt#3:\
X! 	:cl=50\EH\E[J:ce=3\E[K:cd=50\E[J:\
X  	:ho=\E[H:cm=5\E[%i%d;%dH:cs=\E[%i%d;%dr:\
X  	:up=\E[A:do=\E[B:le=\E[C:ri=\E[D:nd=\E[C:\
X  	:UP=\E[%dA:DO=\E[%dB:LE=\E[%dC:RI=\E[%dD:\
X  	:so=2\E[7m:se=2\E[m:us=2\E[4m:ue=2\E[m:\
X  	:mb=2\E[5m:md=2\E[1m:mr=2\E[7m:me=2\E[m:\
X! 	:ti=4\E(B\E)0:as=^N:ae=^O:\
X  	:ks=\E[?1h\E=:ke=\E[?11\E>:ku=\E[A:kd=\E[B:kl=\E[C:kr=\E[D:kb=^H:\
X  	:kn#4:k1=\EOP:k2=\EOQ:k3=\EOR:k4=\EOS:\
X  	:sc=\E7:ec=\E8:sr=5\EM:
X  #
X! # VT102 (or higher) emulators can add:
X! #	:im=\E[4h:ei=\E[4l:al=\E[L:dl=\E[M:dc=\E[P:
X  #
X  #
X  # For really complete ANSI emulations (FANSI-CONSOLE?):
X--- 80,119 ----
X  	:ku=\EA:kd=\EB:kl=\EC:kr=\ED:kb=^H:\
X  	:sr=\EI:as=\EF:ae=\EG:
X  #
X! # For Amiga or VMS NetHack:
X! #       VT100 or clone without the advanced video option installed
X! vt100|amiga|vt100-80|vt100-noavo|DEC VT100:\
X  	:co#80:li#24:bs:pt:am:mi:bl=^G:le=^H:do=^J:xo:vt#3:\
X! 	:cl=50\E[H\E[J:ce=3\E[K:cd=50\E[J:\
X  	:ho=\E[H:cm=5\E[%i%d;%dH:cs=\E[%i%d;%dr:\
X  	:up=\E[A:do=\E[B:le=\E[C:ri=\E[D:nd=\E[C:\
X  	:UP=\E[%dA:DO=\E[%dB:LE=\E[%dC:RI=\E[%dD:\
X  	:so=2\E[7m:se=2\E[m:us=2\E[4m:ue=2\E[m:\
X  	:mb=2\E[5m:md=2\E[1m:mr=2\E[7m:me=2\E[m:\
X! 	:ti=4\E<\E(B\E)0:as=^N:ae=^O:\
X  	:ks=\E[?1h\E=:ke=\E[?11\E>:ku=\E[A:kd=\E[B:kl=\E[C:kr=\E[D:kb=^H:\
X  	:kn#4:k1=\EOP:k2=\EOQ:k3=\EOR:k4=\EOS:\
X  	:sc=\E7:ec=\E8:sr=5\EM:
X  #
X! # VT102 and up:
X! #       includes VT100 with advanced video option
X! vt102|vt102-80|vt100-avo|DEC VT102:\
X! 	:im=\E[4h:ei=\E[4l:al=5\E[L:dl=5\E[M:dc=5\E[P:\
X! 	:AL=9\E[%dL:DL=9\E[%dM:tc=vt100:
X! vt200|vt200-80|vt220|vt240|vt241|VT200_Series:\
X! 	:ic=5\E[@:tc=vt102:
X! vt300|vt300-80|vt320|vt330|vt340|VT300_Series:\
X! 	:tc=vt200:
X! # VAXstations (should have full entries with no delays and 8-bit CSI's)
X! VWS|UIS:tc=vt200:
X! DECterm:tc=vt300:
X! #
X! # Wide screen (magnifying glass not included;-)
X! #       note: vt100 w/o AVO only supports 14 lines when in 132-column mode
X! vt132|vt100-132:vt102-132:\
X! 	:co#132:ti=9\E<\E(B\E)0\E[?3h:tc=vt102:
X! vt200-132|vt300-132:\
X! 	:co#132:ti=9\E<\E(B\E)0\E[?3h:tc=vt200:
X  #
X  #
X  # For really complete ANSI emulations (FANSI-CONSOLE?):
X*** others/Old/trampoli.c	Sun Jun  3 15:28:34 1990
X--- others/trampoli.c	Thu May 31 22:12:43 1990
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)trampoli.c 	3.0	89/11/15	  */
X  /* Copyright (c) 1989, by Norm Meluch and Stephen Spackman	  */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)trampoli.c 	3.0	90/05/31	  */
X  /* Copyright (c) 1989, by Norm Meluch and Stephen Spackman	  */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 181,189 ****
X  /* ### end.c ### */
X  #undef done1
X  #undef done2
X  
X! int done1() { return done1_(); }
X! int done2() { return done2_(); }
X  
X  
X  /* ### engrave.c ### */
X--- 181,201 ----
X  /* ### end.c ### */
X  #undef done1
X  #undef done2
X+ #undef hangup
X+ #undef done_intr
X  
X! #if defined(UNIX) || defined(VMS)
X! #undef done_hangup
X! #endif /* UNIX || VMS */
X! 
X! int done1()     { return done1_();     }
X! int done2()     { return done2_();     }
X! int hangup()    { return hangup_();    }
X! int done_intr() { return done_intr_(); }
X! 
X! #if defined(UNIX) || defined(VMS)
X! int done_hangup() { return done_hangup_(); }
X! #endif /* UNIX || VMS */
X  
X  
X  /* ### engrave.c ### */
X***************
X*** 225,239 ****
X  
X  
X  /* ### ioctl.c ### */
X- /*
X  #ifdef UNIX
X! #ifdef SUSPEND
X  #undef dosuspend
X  
X  int dosuspend() { return dosuspend_(); }
X! #endif
X! #endif
X! */
X  
X  
X  /* ### lock.c ### */
X--- 237,249 ----
X  
X  
X  /* ### ioctl.c ### */
X  #ifdef UNIX
X! # ifdef SUSPEND
X  #undef dosuspend
X  
X  int dosuspend() { return dosuspend_(); }
X! # endif /* SUSPEND */
X! #endif /* UNIX */
X  
X  
X  /* ### lock.c ### */
X***************
X*** 249,258 ****
X  int forcelock() { return forcelock_(); }
X  int picklock()  { return picklock_();  }
X  
X  /* ### mondata.c ### */
X! #undef canseemon
X  
X! boolean canseemon(x) struct monst *x; { return canseemon_(x); }
X  
X  
X  /* ### o_init.c ### */
X--- 259,278 ----
X  int forcelock() { return forcelock_(); }
X  int picklock()  { return picklock_();  }
X  
X+ 
X+ /* ### mklev.c ### */
X+ #undef comp
X+ 
X+ int comp(vx, vy) genericptr_t vx, vy;  { return comp_(vx, vy); }
X+ 
X+ 
X  /* ### mondata.c ### */
X! /* canseemon() is only called by a macro e_boolean.  If e_boolean ever does
X!    become a function for purposes of STUPID_CPP this may need to return. */
X! 
X! /* #undef canseemon */
X  
X! /* boolean canseemon(x) struct monst *x; { return canseemon_(x); } */
X  
X  
X  /* ### o_init.c ### */
X***************
X*** 282,294 ****
X  #undef dohistory
X  #undef dowhatdoes
X  #undef dowhatis
X  #ifdef UNIX
X! #ifdef SHELL
X  #undef dosh
X  
X  int dosh()       { return dosh_();       }
X! #endif
X! #endif
X  
X  int dohelp()     { return dohelp_();     }
X  int dohistory()  { return dohistory_();  }
X--- 302,317 ----
X  #undef dohistory
X  #undef dowhatdoes
X  #undef dowhatis
X+ 
X  #ifdef UNIX
X! #undef intruph
X! # ifdef SHELL
X  #undef dosh
X  
X  int dosh()       { return dosh_();       }
X! # endif /* SHELL */
X! int intruph()	 { return intruph_();    }
X! #endif /* UNIX */
X  
X  int dohelp()     { return dohelp_();     }
X  int dohistory()  { return dohistory_();  }
X***************
X*** 413,419 ****
X  #undef doversion
X  #undef doextversion
X  
X! int doversion() { return doversion_(); }
X  int doextversion() { return doextversion_(); }
X  
X  
X--- 436,442 ----
X  #undef doversion
X  #undef doextversion
X  
X! int doversion()    { return doversion_();    }
X  int doextversion() { return doextversion_(); }
X  
X  
X
END_OF_FILE
if test 54916 -ne `wc -c <'patch8.13'`; then
    echo shar: \"'patch8.13'\" unpacked with wrong size!
fi
# end of 'patch8.13'
fi
if test -f 'vms/install.com' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vms/install.com'\"
else
echo shar: Extracting \"'vms/install.com'\" \(1956 characters\)
sed "s/^X//" >'vms/install.com' <<'END_OF_FILE'
X$ ! vms/install.com -- set up nethack 'playground'
X$ !
X$ ! Use vmsbuild.com to create nethack.exe, makedefs, and lev_comp *first*.
X$ !
X$ ! Edit this file to define gamedir & gameuic, or else invoke it with two
X$ ! command line parameters, as in:
X$ !	@[.vms]install "disk$users:[games.nethack]" "[40,1]"
X$ !
X$	gamedir = "USR$ROOT0:[GENTZEL.NHDIR]"	!location of playground
X$	gameuic = "GENTZEL"			!owner of playground
X$	if p1.nes."" then  gamedir := 'p1'
X$	if p2.nes."" then  gameuic := 'p2'
X$
X$	play_files = "PERM.,RECORD.,LOGFILE."
X$	help_files = "HELP.,HH.,CMDHELP.,HISTORY.,OPTHELP.,ORACLES.,LICENSE."
X$	data_files = "DATA.,RUMORS."
X$	spec_files = "ENDGAME.,CASTLE.,TOWER%."
X$	spec_input = "endgame.des castle.des tower.des"
X$ makedefs := $sys$disk:[-.src]makedefs
X$ lev_comp := $sys$disk:[-.src]lev_comp
X$
X$	! start from a known location -- [.vms]
X$	set default 'f$parse(f$environment("PROCEDURE"),,,"DIRECTORY")'
X$! generate miscellaneous data files
X$	set default [-.auxil]	!move to auxiliary directory
X$ makedefs -d	!data
X$ makedefs -r	!rumors
X$! lev_comp 'spec_input' !special levels
X$! (flex'd version doesn't handle multiple inputs, so do them one at a time)
X$ lev_comp endgame.des
X$ lev_comp castle.des
X$ lev_comp tower.des
X$	set default [-]		!move up
X$
X$! set up the directories
X$ create/directory/owner='gameuic'/prot=(s:rwe,o:rwe,g:rwe,w:rwe)/log -
X	'f$string(gamedir - "]" + ".SAVE]")'
X$! create empty writeable files
X$ create/owner='gameuic'/prot=(s:rwed,o:rwed,g:rwed,w:rwed) -
X	'gamedir''play_files'
X$! copy over the remaining game files, then make them readonly
X$ copy/prot=(s:rwed,o:rwed,g:re,w:re) -
X	[.auxil]'help_files','data_files','spec_files',[.src]nethack.exe -
X	'gamedir'*.*
X$ set file/owner='gameuic'/prot=(s:re,o:re) -
X	'gamedir''help_files','data_files','spec_files',nethack.exe
X$! done
X$ define/nolog hackdir 'gamedir'
X$ write sys$output -
X    f$fao("!/ Nethack installation complete. !/ Playground is !AS !/",gamedir)
X$ exit
END_OF_FILE
if test 1956 -ne `wc -c <'vms/install.com'`; then
    echo shar: \"'vms/install.com'\" unpacked with wrong size!
fi
# end of 'vms/install.com'
fi
echo shar: End of archive 2 \(of 24\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 24 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
