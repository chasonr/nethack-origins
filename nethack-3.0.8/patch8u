Path: utzoo!utgpu!watserv1!watmath!att!rutgers!uwm.edu!zaphod.mps.ohio-state.edu!rpi!dali.cs.montana.edu!milton!uw-beaver!zephyr.ens.tek.com!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v10i039:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Patch8u
Message-ID: <5747@tekred.CNA.TEK.COM>
Date: 5 Jun 90 18:03:08 GMT
Sender: news@tekred.CNA.TEK.COM
Lines: 2640
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 10, Issue 39
Archive-name: NetHack3/Patch8u
Patch-To: NetHack3: Volume 7, Issue 56-93



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 21 (of 24)."
# Contents:  auxil/Makefile.auxil src/lev_comp.c src/lev_lex.c
# Wrapped by billr@saab on Mon Jun  4 15:40:32 1990
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo shar: Extracting \"'auxil/Makefile.auxil'\" \(1889 characters\)
sed "s/^X//" >'auxil/Makefile.auxil' <<'END_OF_FILE'
X#	NetHack Makefile.
X#	SCCS Id: @(#)Makefile.auxil	3.0	90/05/28
X
XVARAUX = data rumors
XGUIDEBOOK = Guidebook		# regular ASCII file
X#GUIDEBOOK = Guidebook.ps	# PostScript file
X#GUIDEBOOK = Guidebook.dvi	# TeX device-independent file
X
Xall:	$(GUIDEBOOK) $(VARAUX) spec_levs
X
X# The tmac.n macros come with the B news software, which should be available
X# at your friendly local archive site if you don't already have it.
X# An updated version also comes with the Elm mail distribution.
X# They are used here because they are more widely available (if not more
X# widely installed) than various proprietary macro packages that came with
X# your machine but not your neighbor's.
X#
X# If you can't install tmac.n in the appropriate system directory, you
X# can create the processed Guidebook in stages:
X#	tbl Guidebook.mn > Guidebook.tmp
X#	nroff tmac.n Guidebook.tmp | col > Guidebook
X#	rm Guidebook.tmp
X# or simply by saying:
X#	tbl tmac.n Guidebook.mn | nroff | col > Guidebook
XGuidebook:	Guidebook.mn
X	tbl Guidebook.mn | nroff -mn | col > Guidebook
X
X# Fancier output for those with ditroff, psdit and a PostScript printer.
XGuidebook.ps:	Guidebook.mn
X	tbl Guidebook.mn | ditroff -mn | psdit > Guidebook.ps
X
X# Guidebook.tex is the same as Guidebook.mn but formatted with LaTeX.
X# - The invocation command for LaTeX may vary in different installations.
X# - To print Guidebook.dvi you need to use a suitable dvi-driver.
XGuidebook.dvi:	Guidebook.tex
X	latex Guidebook.tex
X
Xdata:	data.base ../src/makedefs
X	( cd ../src ; ./makedefs -d )
X
Xrumors:	rumors.tru rumors.fal ../src/makedefs
X	( cd ../src ; ./makedefs -r )
X
Xspec_levs: castle.des endgame.des tower.des ../src/lev_comp
X	../src/lev_comp castle.des
X	../src/lev_comp endgame.des
X	../src/lev_comp tower.des
X	touch spec_levs
X
Xspotless:
X	-rm -f Guidebook Guidebook.ps Guidebook.dvi Guidebook.aux Guidebook.log data rumors castle endgame tower1 tower2 tower3
END_OF_FILE
if test 1889 -ne `wc -c <'auxil/Makefile.auxil'`; then
    echo shar: \"'auxil/Makefile.auxil'\" unpacked with wrong size!
fi
# end of 'auxil/Makefile.auxil'
echo shar: Extracting \"'src/lev_comp.c'\" \(33297 characters\)
sed "s/^X//" >'src/lev_comp.c' <<'END_OF_FILE'
X
X# line 1 "lev_comp.y"
X 
X/*	SCCS Id: @(#)lev_comp.c	3.0	90/01/03
X/*	Copyright (c) 1989 by Jean-Christophe Collet */
X/* NetHack may be freely redistributed.  See license for details. */
X
X/*
X * This file contains the Level Compiler code
X * It may handle special mazes & special room-levels
X */
X
X/* block some unused #defines to avoid overloading some cpp's */
X#define MONDATA_H	/* comment line for pre-compiled headers */
X#define MONFLAG_H	/* comment line for pre-compiled headers */
X
X#include "hack.h"
X#include "sp_lev.h"
X#ifndef O_WRONLY
X# include <fcntl.h>
X#endif
X#ifndef O_CREAT	/* some older BSD systems do not define O_CREAT in <fcntl.h> */
X# include <sys/file.h>
X#endif
X
Xvoid FDECL(yyerror, (char *));
Xvoid FDECL(yywarning, (char *));
Xint NDECL(yylex);
Xint NDECL(yyparse);
X
Xint FDECL(get_room_type, (char *));
Xint FDECL(get_trap_type, (char *));
Xint FDECL(get_monster_id, (char *, CHAR_P));
Xint FDECL(get_object_id, (char *, CHAR_P));
Xboolean FDECL(check_monster_char, (CHAR_P));
Xboolean FDECL(check_object_char, (CHAR_P));
Xvoid FDECL(scan_map, (char *));
Xvoid NDECL(store_part);
Xvoid FDECL(write_maze, (int, specialmaze *));
X
X#ifdef AMIGA
Xchar *fgets();
X# undef     fopen
X# undef     printf
X# undef     Printf
X# define    Printf  printf
X#ifndef	LATTICE
X# define    memset(addr,val,len)    setmem(addr,len,val)
X#endif
X#endif
X
X#ifdef MSDOS
X# undef exit
Xextern void FDECL(exit, (int));
X#endif
X
X#ifdef MACOS
X# undef printf
X# undef Printf
X# define Printf printf
X#endif
X
X#undef NULL
X
X#define MAX_REGISTERS	10
X#define ERR		(-1)
X
Xstruct reg {
X	int x1, y1;
X	int x2, y2;
X}		current_region;
X
Xstruct coord {
X	int x;
X	int y;
X}		current_coord;
X
Xstruct {
X	char *name;
X	short type;
X} trap_types[TRAPNUM-1] = {
X	"monster",	MONST_TRAP,
X	"statue",	STATUE_TRAP,
X	"bear",		BEAR_TRAP,
X	"arrow",	ARROW_TRAP,
X	"dart",		DART_TRAP,
X	"trapdoor",	TRAPDOOR,
X	"teleport",	TELEP_TRAP,
X	"pit",		PIT,
X	"sleep gas",	SLP_GAS_TRAP,
X	"magic",	MGTRP,
X	"board",	SQBRD,
X	"web",		WEB,
X	"spiked pit",	SPIKED_PIT,
X	"level teleport",LEVEL_TELEP,
X#ifdef SPELLS
X	"anti magic",	ANTI_MAGIC,
X#endif
X	"rust",		RUST_TRAP
X#ifdef POLYSELF
X	, "polymorph",	POLY_TRAP
X#endif
X#ifdef ARMY
X	, "land mine",	LANDMINE
X#endif
X  };
X
Xstruct {
X	char *name;
X	int type;
X} room_types[SHOPBASE-1] = {
X	/* for historical reasons, room types are not contiguous numbers */
X	/* (type 1 is skipped) */
X	"ordinary",	OROOM,
X#ifdef THRONES
X	"throne",	COURT,
X#endif
X	"swamp",	SWAMP,
X	"vault",	VAULT,
X	"beehive",	BEEHIVE,
X	"morgue",	MORGUE,
X#ifdef ARMY
X	"barracks",	BARRACKS,
X#endif
X	"zoo",		ZOO,
X	"temple",	TEMPLE,
X	"shop",		SHOPBASE,
X};
X
Xshort db_dirs[4] = {
X	DB_NORTH,
X	DB_EAST,
X	DB_SOUTH,
X	DB_WEST
X};
X
X#ifdef ALTARS
Xstatic altar *tmpaltar[256];
X#endif /* ALTARS /**/
Xstatic lad *tmplad[256];
Xstatic digpos *tmpdig[256];
Xstatic char *tmpmap[ROWNO];
Xstatic region *tmpreg[16];
Xstatic door *tmpdoor[256];
Xstatic trap *tmptrap[256];
Xstatic monster *tmpmonst[256];
Xstatic object *tmpobj[256];
Xstatic drawbridge *tmpdb[256];
Xstatic walk *tmpwalk[256];
Xstatic mazepart *tmppart[10];
Xstatic room *tmproom[MAXNROFROOMS];
Xstatic specialmaze maze;
X
Xstatic char olist[MAX_REGISTERS], mlist[MAX_REGISTERS];
Xstatic struct coord plist[MAX_REGISTERS];
Xstatic int n_olist = 0, n_mlist = 0, n_plist = 0;
X
Xunsigned int nreg = 0, ndoor = 0, ntrap = 0, nmons = 0, nobj = 0;
Xunsigned int ndb = 0, nwalk = 0, npart = 0, ndig = 0, nlad = 0;
X#ifdef ALTARS
Xunsigned int naltar = 0;
X#endif /* ALTARS /*/
X
Xunsigned int max_x_map, max_y_map;
X
Xextern int fatal_error;
Xextern char* fname;
X
X
X# line 169 "lev_comp.y"
Xtypedef union 
X{
X	int	i;
X	char*	map;
X} YYSTYPE;
X# define CHAR 257
X# define INTEGER 258
X# define MAZE_ID 259
X# define LEVEL_ID 260
X# define GEOMETRY_ID 261
X# define OBJECT_ID 262
X# define MONSTER_ID 263
X# define TRAP_ID 264
X# define DOOR_ID 265
X# define DRAWBRIDGE_ID 266
X# define MAZEWALK_ID 267
X# define REGION_ID 268
X# define RANDOM_OBJECTS_ID 269
X# define RANDOM_MONSTERS_ID 270
X# define RANDOM_PLACES_ID 271
X# define ALTAR_ID 272
X# define LADDER_ID 273
X# define NON_DIGGABLE_ID 274
X# define ROOM_ID 275
X# define DOOR_STATE 276
X# define LIGHT_STATE 277
X# define DIRECTION 278
X# define RANDOM_TYPE 279
X# define O_REGISTER 280
X# define M_REGISTER 281
X# define P_REGISTER 282
X# define A_REGISTER 283
X# define ALIGNMENT 284
X# define LEFT_OR_RIGHT 285
X# define CENTER 286
X# define TOP_OR_BOT 287
X# define ALTAR_TYPE 288
X# define UP_OR_DOWN 289
X# define STRING 290
X# define MAP_ID 291
X#define yyclearin yychar = -1
X#define yyerrok yyerrflag = 0
Xextern int yychar;
Xextern short yyerrflag;
X#ifndef YYMAXDEPTH
X#define YYMAXDEPTH 150
X#endif
XYYSTYPE yylval, yyval;
X# define YYERRCODE 256
X
X# line 654 "lev_comp.y"
X
X
X/* 
X * Find the type of a room in the table, knowing its name.
X */
X
Xint
Xget_room_type(s)
Xchar *s;
X{
X	register int i;
X	
X	for(i=0; i < SHOPBASE -1; i++)
X	    if (!strcmp(s, room_types[i].name))
X		return ((int) room_types[i].type);
X	return ERR;
X}
X
X/* 
X * Find the type of a trap in the table, knowing its name.
X */
X
Xint
Xget_trap_type(s)
Xchar *s;
X{
X	register int i;
X	
X	for(i=0; i < TRAPNUM - 1; i++)
X	    if(!strcmp(s,trap_types[i].name))
X		return((int)trap_types[i].type);
X	return ERR;
X}
X
X/* 
X * Find the index of a monster in the table, knowing its name.
X */
X
Xint
Xget_monster_id(s, c)
Xchar *s;
Xchar c;
X{
X	register int i;
X	
X	for(i=0; mons[i].mname[0]; i++)
X	    if(!strncmp(s, mons[i].mname, strlen(mons[i].mname))
X	       && c == mons[i].mlet)
X		return i;
X	return ERR;
X}
X
X/* 
X * Find the index of an object in the table, knowing its name.
X */
X
Xint
Xget_object_id(s, c)
Xchar *s;
Xchar c;
X{
X	register int i;
X	
X	for(i=0; i<=NROFOBJECTS;i++)
X	    if(objects[i].oc_name &&
X	       !strncmp(s, objects[i].oc_name, strlen(objects[i].oc_name))
X	       && c == objects[i].oc_olet)
X		return i;
X	return ERR;
X}
X
X/* 
X * Is the character 'c' a valid monster class ?
X */
X
Xboolean
Xcheck_monster_char(c)
Xchar c;
X{
X	register int i;
X	
X	for(i=0; mons[i].mname[0]; i++)
X	    if( c ==  mons[i].mlet)
X		return 1;
X	return(0);
X}
X
X/* 
X * Is the character 'c' a valid object class ?
X */
X
Xboolean
Xcheck_object_char(c)
Xchar c;
X{
X	register int i;
X	
X	for(i=0; i<=NROFOBJECTS;i++)
X	    if( c == objects[i].oc_olet)
X		return 1;
X	return 0;
X}
X
X/* 
X * Yep! LEX gives us the map in a raw mode.
X * Just analyze it here.
X */
X
Xvoid scan_map(map)
Xchar *map;
X{
X	register int i, len;
X	register char *s1, *s2;
X	int max_len = 0;
X	int max_hig = 0;
X	
X	/* First : find the max width of the map */
X
X	s1 = map;
X	while (s1 && *s1) {
X		s2 = index(s1, '\n');
X		if (s2) {
X			if (s2-s1 > max_len)
X			    max_len = s2-s1;
X			s1 = s2 + 1;
X		} else {
X			if (strlen(s1) > max_len)
X			    max_len = strlen(s1);
X			s1 = (char *) 0;
X		}
X	}
X
X	/* Then parse it now */
X
X	while (map && *map) {
X		tmpmap[max_hig] = (char *) alloc(max_len);
X		s1 = index(map, '\n');
X		if (s1) {
X			len = s1 - map;
X			s1++;
X		} else {
X			len = strlen(map);
X			s1 = map + len;
X		}
X		for(i=0; i<len; i++)
X		    switch(map[i]) {
X			  case '-' : tmpmap[max_hig][i] = HWALL; break;
X			  case '|' : tmpmap[max_hig][i] = VWALL; break;
X			  case '+' : tmpmap[max_hig][i] = DOOR; break;
X			  case 'S' : tmpmap[max_hig][i] = SDOOR; break;
X			  case '{' : 
X#ifdef FOUNTAINS
X			      tmpmap[max_hig][i] = FOUNTAIN;
X#else
X			      tmpmap[max_hig][i] = ROOM;
X			      yywarning("Fountains are not allowed in this version!  Ignoring...");
X#endif
X			      break;
X			  case '\\' : 
X#ifdef THRONES
X			      tmpmap[max_hig][i] = THRONE;
X#else
X			      tmpmap[max_hig][i] = ROOM;
X			      yywarning("Thrones are not allowed in this version!  Ignoring...");
X#endif
X			      break;
X			  case 'K' : 
X#ifdef SINKS
X			      tmpmap[max_hig][i] = SINK;
X#else
X			      tmpmap[max_hig][i] = ROOM;
X			      yywarning("Sinks are not allowed in this version!  Ignoring...");
X#endif
X			      break;
X			  case '}' : tmpmap[max_hig][i] = MOAT; break;
X			  case '#' : tmpmap[max_hig][i] = CORR; break;
X			  default  : tmpmap[max_hig][i] = ROOM; break;
X		    }
X		while(i < max_len)
X		    tmpmap[max_hig][i++] = ROOM;
X		map = s1;
X		max_hig++;
X	}
X
X	/* Memorize boundaries */
X
X	max_x_map = max_len - 1;
X	max_y_map = max_hig - 1;
X
X	/* Store the map into the mazepart structure */
X
X	tmppart[npart]->xsize = max_len;
X	tmppart[npart]->ysize = max_hig;
X	tmppart[npart]->map = (char **) alloc(max_hig*sizeof(char *));
X	for(i = 0; i< max_hig; i++)
X	    tmppart[npart]->map[i] = tmpmap[i];
X}
X
X/* 
X * Here we want to store the maze part we just got.
X */
X
Xvoid
Xstore_part()
X{
X	register int i;
X
X	/* Ok, We got the whole part, now we store it. */
X	
X	/* The Regions */
X
X	if(tmppart[npart]->nreg = nreg) {
X		tmppart[npart]->regions = (region**)alloc(sizeof(region*) * nreg);
X		for(i=0;i<nreg;i++)
X		    tmppart[npart]->regions[i] = tmpreg[i];
X	}
X	nreg = 0;
X
X	/* the doors */
X
X	if(tmppart[npart]->ndoor = ndoor) {
X		tmppart[npart]->doors = (door **)alloc(sizeof(door *) * ndoor);
X		for(i=0;i<ndoor;i++)
X		    tmppart[npart]->doors[i] = tmpdoor[i];
X	}
X	ndoor = 0;
X
X	/* the traps */
X
X	if(tmppart[npart]->ntraps = ntrap) {
X		tmppart[npart]->traps = (trap **)alloc(sizeof(trap*) * ntrap);
X		for(i=0;i<ntrap;i++)
X		    tmppart[npart]->traps[i] = tmptrap[i];
X	}
X	ntrap = 0;
X
X	/* the monsters */
X
X	if(tmppart[npart]->nmonster = nmons) {
X		tmppart[npart]->monsters = (monster**)alloc(sizeof(monster*)*nmons);
X		for(i=0;i<nmons;i++)
X		    tmppart[npart]->monsters[i] = tmpmonst[i];
X	}
X	nmons = 0;
X
X	/* the objects */
X
X	if(tmppart[npart]->nobjects = nobj) {
X		tmppart[npart]->objects = (object**)alloc(sizeof(object*)*nobj);
X		for(i=0;i<nobj;i++)
X		    tmppart[npart]->objects[i] = tmpobj[i];
X	}
X	nobj = 0;
X
X	/* the drawbridges */
X
X	if(tmppart[npart]->ndrawbridge = ndb) {
X		tmppart[npart]->drawbridges = (drawbridge**)alloc(sizeof(drawbridge*)*ndb);
X		for(i=0;i<ndb;i++)
X		    tmppart[npart]->drawbridges[i] = tmpdb[i];
X	}
X	ndb = 0;
X
X	/* The walkmaze directives */
X
X	if(tmppart[npart]->nwalk = nwalk) {
X		tmppart[npart]->walks = (walk**)alloc(sizeof(walk*)*nwalk);
X		for(i=0;i<nwalk;i++)
X		    tmppart[npart]->walks[i] = tmpwalk[i];
X	}
X	nwalk = 0;
X
X	/* The non_diggable directives */
X
X	if(tmppart[npart]->ndig = ndig) {
X		tmppart[npart]->digs = (digpos **) alloc(sizeof(digpos*) * ndig);
X		for(i=0;i<ndig;i++)
X		    tmppart[npart]->digs[i] = tmpdig[i];
X	}
X	ndig = 0;
X
X	/* The ladders */
X
X	if(tmppart[npart]->nlad = nlad) {
X		tmppart[npart]->lads = (lad **) alloc(sizeof(lad*) * nlad);
X		for(i=0;i<nlad;i++)
X		    tmppart[npart]->lads[i] = tmplad[i];
X	}
X	nlad = 0;
X#ifdef ALTARS
X	/* The altars */
X
X	if(tmppart[npart]->naltar = naltar) {
X		tmppart[npart]->altars = (altar**)alloc(sizeof(altar*) * naltar);
X		for(i=0;i<naltar;i++)
X		    tmppart[npart]->altars[i] = tmpaltar[i];
X	}
X	naltar = 0;
X#endif /* ALTARS /**/
X	npart++;
X	n_plist = n_mlist = n_olist = 0;
X}
X
X/* 
X * Here we write the structure of the maze in the specified file (fd).
X * Also, we have to free the memory allocated via alloc()
X */
X
Xvoid
Xwrite_maze(fd, maze)
Xint fd;
Xspecialmaze *maze;
X{
X	char c;
X	short i,j;
X	mazepart *pt;
X
X	c = 2;
X	(void) write(fd, &c, 1);	/* Header for special mazes */
X	(void) write(fd, &(maze->numpart), 1);	/* Number of parts */
X	for(i=0;i<maze->numpart;i++) {
X	    pt = maze->parts[i];
X
X	    /* First, write the map */
X
X	    (void) write(fd, &(pt->halign), 1);
X	    (void) write(fd, &(pt->valign), 1);
X	    (void) write(fd, &(pt->xsize), 1);
X	    (void) write(fd, &(pt->ysize), 1);
X	    for(j=0;j<pt->ysize;j++) {
X		    (void) write(fd, pt->map[j], pt->xsize);
X		    free(pt->map[j]);
X	    }
X	    free(pt->map);
X
X	    /* The random registers */
X	    (void) write(fd, &(pt->nrobjects), 1);
X	    if(pt->nrobjects) {
X		    (void) write(fd, pt->robjects, pt->nrobjects);
X		    free(pt->robjects);
X	    }
X	    (void) write(fd, &(pt->nloc), 1);
X	    if(pt->nloc) {
X		(void) write(fd,pt->rloc_x, pt->nloc);
X		(void) write(fd,pt->rloc_y, pt->nloc);
X		free(pt->rloc_x);
X		free(pt->rloc_y);
X	    }
X	    (void) write(fd,&(pt->nrmonst), 1);
X	    if(pt->nrmonst) {
X		    (void) write(fd, pt->rmonst, pt->nrmonst);
X		    free(pt->rmonst);
X	    }
X
X	    /* subrooms */
X	    (void) write(fd, &(pt->nreg), 1);
X	    for(j=0;j<pt->nreg;j++) {
X		    (void) write(fd,(genericptr_t) pt->regions[j], sizeof(region));
X		    free(pt->regions[j]);
X	    }
X	    if(pt->nreg > 0)
X		free(pt->regions);
X
X	    /* the doors */
X	    (void) write(fd,&(pt->ndoor),1);
X	    for(j=0;j<pt->ndoor;j++) {
X		    (void) write(fd,(genericptr_t) pt->doors[j], sizeof(door));
X		    free(pt->doors[j]);
X	    }
X	    if (pt->ndoor > 0)
X		free(pt->doors);
X
X	    /* The traps */
X	    (void) write(fd,&(pt->ntraps), 1);
X	    for(j=0;j<pt->ntraps;j++) {
X		    (void) write(fd,(genericptr_t) pt->traps[j], sizeof(trap));
X		    free(pt->traps[j]);
X	    }
X	    if (pt->ntraps)
X		free(pt->traps);
X
X	    /* The monsters */
X	    (void) write(fd, &(pt->nmonster), 1);
X	    for(j=0;j<pt->nmonster;j++) {
X		    (void) write(fd,(genericptr_t) pt->monsters[j], sizeof(monster));
X		    free(pt->monsters[j]);
X	    }
X	    if (pt->nmonster > 0)
X		free(pt->monsters);
X
X	    /* The objects */
X	    (void) write(fd, &(pt->nobjects), 1);
X	    for(j=0;j<pt->nobjects;j++) {
X		    (void) write(fd,(genericptr_t) pt->objects[j], sizeof(object));
X		    free(pt->objects[j]);
X	    }
X	    if(pt->nobjects > 0)
X		free(pt->objects);
X
X	    /* The drawbridges */
X	    (void) write(fd, &(pt->ndrawbridge),1);
X	    for(j=0;j<pt->ndrawbridge;j++) {
X		    (void) write(fd,(genericptr_t) pt->drawbridges[j], sizeof(drawbridge));
X		    free(pt->drawbridges[j]);
X	    }
X	    if(pt->ndrawbridge > 0)
X		free(pt->drawbridges);
X
X	    /* The mazewalk directives */
X	    (void) write(fd, &(pt->nwalk), 1);
X	    for(j=0; j<pt->nwalk; j++) {
X		    (void) write(fd,(genericptr_t) pt->walks[j], sizeof(walk));
X		    free(pt->walks[j]);
X	    }
X	    if (pt->nwalk > 0)
X		free(pt->walks);
X
X	    /* The non_diggable directives */
X	    (void) write(fd, &(pt->ndig), 1);
X	    for(j=0;j<pt->ndig;j++) {
X		    (void) write(fd,(genericptr_t) pt->digs[j], sizeof(digpos));
X		    free(pt->digs[j]);
X	    }
X	    if (pt->ndig > 0)
X		free(pt->digs);
X
X	    /* The ladders */
X	    (void) write(fd, &(pt->nlad), 1);
X	    for(j=0;j<pt->nlad;j++) {
X		    (void) write(fd,(genericptr_t) pt->lads[j], sizeof(lad));
X		    free(pt->lads[j]);
X	    }
X	    if (pt->nlad > 0)
X		free(pt->lads);
X#ifdef ALTARS
X	    /* The altars */
X	    (void) write(fd, &(pt->naltar), 1);
X	    for(j=0;j<pt->naltar;j++) {
X		    (void) write(fd,(genericptr_t) pt->altars[j], sizeof(altar));
X		    free(pt->altars[j]);
X	    }
X	    if (pt->naltar > 0)
X		free(pt->altars);
X#endif /* ALTARS /**/
X	    free(pt);
X	}
X}
Xshort yyexca[] ={
X-1, 1,
X	0, -1,
X	-2, 0,
X-1, 67,
X	44, 27,
X	-2, 26,
X	};
X# define YYNPROD 87
X# define YYLAST 251
Xshort yyact[]={
X
X 165, 130, 126,  91,  16,  19, 169, 146,  69,  72,
X 145,  19,  19,  19,  19, 168,  75,  74,  26,  27,
X 143, 137,  12, 138, 144, 141,  65,  87, 134,   6,
X  88,  78, 174,  80,  40,  39,  42,  41,  43,  46,
X  44, 171, 170, 156,  45,  47,  48, 148,  83,  85,
X  22,  24,  23, 135, 131, 127, 116, 105,  72,  65,
X  18,  92,  93,  86,  66,  70, 172,  63, 154, 152,
X 150, 158, 114, 110, 108,  97,  62,  61,  60,  59,
X  58,  57,  56,  55,  54,  53,  51,  50,  49,  17,
X  13,  64, 173,  71, 166, 157, 155, 153, 151, 149,
X 139, 122, 121, 119, 118, 117, 115, 113, 112, 111,
X 109, 107, 106,  68, 103,  52, 175,  90, 159,  69,
X  98,  99, 100, 101,   8,   2,  94,  84,  79,   7,
X  81,  76,  38,  37,  14,  36,  35,  34, 102,  33,
X  32,  31,  30,  29,  28, 104,  82,  77,  67,  21,
X  11,  20,  15,  10,   9,   4,   3,   1, 128, 124,
X   5, 142, 167, 140, 136, 163,  89,  73, 125,  25,
X 129, 120, 123, 132, 133,   0,   0,   0,   0,   0,
X   0,   0,   0,   0,  68,   0, 147,   0,   0,   0,
X   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
X   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
X   0, 160,   0, 161,   0,   0, 164, 162,   0,   0,
X   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
X   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
X   0,   0,   0,   0,   0,   0,   0,  95,   0,   0,
X  96 };
Xshort yypact[]={
X
X-230,-1000,-1000,-230,-1000,-239,  32,-1000,-1000,-239,
X-1000,-287,  31,-285,-1000,-219,-1000,-267,-1000,-1000,
X-228,-1000,  30,  29,  28,  71,-1000,-1000,-1000,-1000,
X-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,  27,
X  26,  25,  24,  23,  22,  21,  20,  19,  18,-198,
X  79,-199,-270,-248,-231,-249,-276, -32,  80, -32,
X -32, -32,  80,-1000,  70,-1000,-1000,-1000,-1000,-201,
X-1000,  68,-1000,-1000,-1000,-1000,  67,-1000,-1000,-1000,
X -17,  66,-1000,-1000,-1000, -18,  65,-1000,-1000,  64,
X-1000,-1000,  63,-1000,-1000,-1000, -19,  62,-202,  61,
X  60,  59,-1000,-198,  58,  57,-199,-277,-203,-278,
X-204, -32, -32,-250,-205,-256,  56,-259,-268,-282,
X-1000,  79,-211,-1000,  55,-1000,-1000, -23,  54,-1000,
X-1000, -24,-1000,-1000,  53, -25,  52,-1000,-1000,-215,
X  51,-1000,-1000,-1000, -20,-1000,-1000,-1000,  77, -32,
X-1000, -32,-1000,-249,-1000,-279,  50,-273,-216,-1000,
X-1000,-1000,-1000,-1000,-1000,-1000,-217,-1000,-1000,-1000,
X -27,  48,-1000,-226,  75,-1000 };
Xshort yypgo[]={
X
X   0, 169, 167, 166, 165,  63, 164, 163, 162, 161,
X  60, 160, 159, 158, 157, 125, 156, 155, 124, 154,
X 153, 152, 151, 150, 149,  67,  64,  65,  91,  93,
X 148, 145, 144, 143, 142, 141, 140, 139, 137, 136,
X 135, 133, 132, 131,  61, 130,  75, 128, 127,  62,
X 126 };
Xshort yyr1[]={
X
X   0,  14,  14,  15,  15,  16,  17,  11,  18,  18,
X  19,  20,  23,   1,   1,   2,   2,  21,  21,  24,
X  24,  24,  25,  25,  27,  27,  26,  31,  26,  22,
X  22,  32,  32,  32,  32,  32,  32,  32,  32,  32,
X  32,  33,  34,  35,  36,  37,  40,  41,  42,  38,
X  39,  43,  43,  43,  45,  45,  45,  12,  12,  13,
X  13,   3,   3,   4,   4,  44,  44,  44,   5,   5,
X   6,   6,   7,   7,   7,   8,   8,  50,  48,  47,
X   9,  30,  29,  28,  10,  49,  46 };
Xshort yyr2[]={
X
X   0,   0,   1,   1,   2,   1,   2,   3,   1,   2,
X   3,   2,   5,   1,   1,   1,   1,   0,   2,   3,
X   3,   3,   1,   3,   1,   3,   1,   0,   4,   0,
X   2,   1,   1,   1,   1,   1,   1,   1,   1,   1,
X   1,   7,   7,   5,   5,   7,   5,   5,   3,   7,
X   7,   1,   1,   1,   1,   1,   1,   1,   1,   1,
X   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
X   1,   1,   1,   1,   1,   1,   1,   4,   4,   4,
X   4,   1,   1,   1,   1,   5,   9 };
Xshort yychk[]={
X
X-1000, -14, -15, -16, -17, -11, 259, -15, -18, -19,
X -20, -23, 261,  58, -18, -21, 291,  58, -10, 290,
X -22, -24, 269, 271, 270,  -1, 285, 286, -32, -33,
X -34, -35, -36, -37, -38, -39, -40, -41, -42, 263,
X 262, 265, 264, 266, 268, 272, 267, 273, 274,  58,
X  58,  58,  44,  58,  58,  58,  58,  58,  58,  58,
X  58,  58,  58, -25, -28, 257, -26, -30, -49,  40,
X -27, -29, 257,  -2, 287, 286, -43, -29, 279, -47,
X 281, -45, -28, 279, -48, 280,  -5, 276, 279,  -3,
X -10, 279, -44, -49, -50, 279, 282, -46,  40, -44,
X -44, -44, -46,  44, -31, 258,  44,  44,  91,  44,
X  91,  44,  44,  44,  91,  44, 258,  44,  44,  44,
X -25,  44,  44, -27, -12, -10, 279, 258, -13, -10,
X 279, 258, -44, -44, 278, 258,  -6, 277, 279,  44,
X  -7, 284,  -9, 279, 283, 278, 289, -26, 258,  44,
X  93,  44,  93,  44,  93,  44, 258,  44,  91,  41,
X -44, -44,  -5,  -4, -10, 279,  44,  -8, 288, 279,
X 258, 258,  93,  44, 258,  41 };
Xshort yydef[]={
X
X   1,  -2,   2,   3,   5,   0,   0,   4,   6,   8,
X  17,   0,   0,   0,   9,  29,  11,   0,   7,  84,
X  10,  18,   0,   0,   0,   0,  13,  14,  30,  31,
X  32,  33,  34,  35,  36,  37,  38,  39,  40,   0,
X   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
X   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
X   0,   0,   0,  19,  22,  83,  20,  -2,  81,   0,
X  21,  24,  82,  12,  15,  16,   0,  51,  52,  53,
X   0,   0,  54,  55,  56,   0,   0,  68,  69,   0,
X  61,  62,   0,  65,  66,  67,   0,   0,   0,   0,
X   0,   0,  48,   0,   0,   0,   0,   0,   0,   0,
X   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
X  23,   0,   0,  25,   0,  57,  58,   0,   0,  59,
X  60,   0,  43,  44,   0,   0,   0,  70,  71,   0,
X   0,  72,  73,  74,   0,  46,  47,  28,   0,   0,
X  79,   0,  78,   0,  77,   0,   0,   0,   0,  85,
X  41,  42,  45,  49,  63,  64,   0,  50,  75,  76,
X   0,   0,  80,   0,   0,  86 };
X#ifndef lint
Xstatic char yaccpar_sccsid[] = "@(#)yaccpar	4.1	(Berkeley)	2/11/83";
X#endif not lint
X
X#
X# define YYFLAG -1000
X# define YYERROR goto yyerrlab
X# define YYACCEPT return(0)
X# define YYABORT return(1)
X
X/*	parser for yacc output	*/
X
X#ifdef YYDEBUG
Xint yydebug = 0; /* 1 for debugging */
X#endif
XYYSTYPE yyv[YYMAXDEPTH]; /* where the values are stored */
Xint yychar = -1; /* current input token number */
Xint yynerrs = 0;  /* number of errors */
Xshort yyerrflag = 0;  /* error recovery flag */
X
Xyyparse() {
X
X	short yys[YYMAXDEPTH];
X	short yyj, yym;
X	register YYSTYPE *yypvt;
X	register short yystate, *yyps, yyn;
X	register YYSTYPE *yypv;
X	register short *yyxi;
X
X	yystate = 0;
X	yychar = -1;
X	yynerrs = 0;
X	yyerrflag = 0;
X	yyps= &yys[-1];
X	yypv= &yyv[-1];
X
X yystack:    /* put a state and value onto the stack */
X
X#ifdef YYDEBUG
X	if( yydebug  ) printf( "state %d, char 0%o\n", yystate, yychar );
X#endif
X		if( ++yyps> &yys[YYMAXDEPTH] ) { yyerror( "yacc stack overflow" ); return(1); }
X		*yyps = yystate;
X		++yypv;
X		*yypv = yyval;
X
X yynewstate:
X
X	yyn = yypact[yystate];
X
X	if( yyn<= YYFLAG ) goto yydefault; /* simple state */
X
X	if( yychar<0 ) if( (yychar=yylex())<0 ) yychar=0;
X	if( (yyn += yychar)<0 || yyn >= YYLAST ) goto yydefault;
X
X	if( yychk[ yyn=yyact[ yyn ] ] == yychar ){ /* valid shift */
X		yychar = -1;
X		yyval = yylval;
X		yystate = yyn;
X		if( yyerrflag > 0 ) --yyerrflag;
X		goto yystack;
X		}
X
X yydefault:
X	/* default state action */
X
X	if( (yyn=yydef[yystate]) == -2 ) {
X		if( yychar<0 ) if( (yychar=yylex())<0 ) yychar = 0;
X		/* look through exception table */
X
X		for( yyxi=yyexca; (*yyxi!= (-1)) || (yyxi[1]!=yystate) ; yyxi += 2 ) ; /* VOID */
X
X		while( *(yyxi+=2) >= 0 ){
X			if( *yyxi == yychar ) break;
X			}
X		if( (yyn = yyxi[1]) < 0 ) return(0);   /* accept */
X		}
X
X	if( yyn == 0 ){ /* error */
X		/* error ... attempt to resume parsing */
X
X		switch( yyerrflag ){
X
X		case 0:   /* brand new error */
X
X			yyerror( "syntax error" );
X		yyerrlab:
X			++yynerrs;
X
X		case 1:
X		case 2: /* incompletely recovered error ... try again */
X
X			yyerrflag = 3;
X
X			/* find a state where "error" is a legal shift action */
X
X			while ( yyps >= yys ) {
X			   yyn = yypact[*yyps] + YYERRCODE;
X			   if( yyn>= 0 && yyn < YYLAST && yychk[yyact[yyn]] == YYERRCODE ){
X			      yystate = yyact[yyn];  /* simulate a shift of "error" */
X			      goto yystack;
X			      }
X			   yyn = yypact[*yyps];
X
X			   /* the current yyps has no shift onn "error", pop stack */
X
X#ifdef YYDEBUG
X			   if( yydebug ) printf( "error recovery pops state %d, uncovers %d\n", *yyps, yyps[-1] );
X#endif
X			   --yyps;
X			   --yypv;
X			   }
X
X			/* there is no state on the stack with an error shift ... abort */
X
X	yyabort:
X			return(1);
X
X
X		case 3:  /* no shift yet; clobber input char */
X
X#ifdef YYDEBUG
X			if( yydebug ) printf( "error recovery discards char %d\n", yychar );
X#endif
X
X			if( yychar == 0 ) goto yyabort; /* don't discard EOF, quit */
X			yychar = -1;
X			goto yynewstate;   /* try again in the same state */
X
X			}
X
X		}
X
X	/* reduction by production yyn */
X
X#ifdef YYDEBUG
X		if( yydebug ) printf("reduce %d\n",yyn);
X#endif
X		yyps -= yyr2[yyn];
X		yypvt = yypv;
X		yypv -= yyr2[yyn];
X		yyval = yypv[1];
X		yym=yyn;
X			/* consult goto table to find next state */
X		yyn = yyr1[yyn];
X		yyj = yypgo[yyn] + *yyps + 1;
X		if( yyj>=YYLAST || yychk[ yystate = yyact[yyj] ] != -yyn ) yystate = yyact[yypgo[yyn]];
X		switch(yym){
X			
Xcase 6:
X# line 201 "lev_comp.y"
X{
X			  int fout, i;
X
X			  if (fatal_error > 0)
X				  fprintf(stderr,"%s : %d errors detected. No output created!\n", fname, fatal_error);
X			  else {
X#ifdef MACOS
X				  OSErr	result;
X				  
X				  result = Create(CtoPstr(yypvt[-1].map), 0, CREATOR, AUXIL_TYPE);
X				  (void)PtoCstr(yypvt[-1].map);
X#endif		
X				  fout = open(yypvt[-1].map, O_WRONLY | O_CREAT
X#if defined(MSDOS) || defined(MACOS)
X					      | O_BINARY
X#endif /* MSDOS || MACOS */
X					      , 0644);
X				  if (fout < 0) {
X					  yyerror("Can't open output file!!");
X					  exit(1);
X				  }
X				  maze.numpart = npart;
X				  maze.parts = (mazepart**) alloc(sizeof(mazepart*)*npart);
X				  for(i=0;i<npart;i++)
X				      maze.parts[i] = tmppart[i];
X				  write_maze(fout, &maze);
X				  (void) close(fout);
X				  npart = 0;
X			  }
X		  } break;
Xcase 7:
X# line 233 "lev_comp.y"
X{
X			  yyval.map = yypvt[-0].map;
X		  } break;
Xcase 10:
X# line 241 "lev_comp.y"
X{
X			store_part();
X		  } break;
Xcase 11:
X# line 246 "lev_comp.y"
X{
X			tmppart[npart] = (mazepart *) alloc(sizeof(mazepart));
X			tmppart[npart]->halign = yypvt[-1].i % 10;
X			tmppart[npart]->valign = yypvt[-1].i / 10;
X			tmppart[npart]->nrobjects = 0;
X			tmppart[npart]->nloc = 0;
X			tmppart[npart]->nrmonst = 0;
X			scan_map(yypvt[-0].map);
X		  } break;
Xcase 12:
X# line 257 "lev_comp.y"
X{
X			  yyval.i = yypvt[-2].i + ( yypvt[-0].i * 10 );
X		  } break;
Xcase 19:
X# line 271 "lev_comp.y"
X{
X			  if (tmppart[npart]->nrobjects)
X			      yyerror("Object registers already initialized!");
X			  else {
X				  tmppart[npart]->robjects = (char *) alloc(n_olist);
X				  memcpy(tmppart[npart]->robjects, olist, n_olist);
X				  tmppart[npart]->nrobjects = n_olist;
X			  }
X		  } break;
Xcase 20:
X# line 281 "lev_comp.y"
X{
X			  if (tmppart[npart]->nloc)
X			      yyerror("Location registers already initialized!");
X			  else {
X				  register int i;
X				  tmppart[npart]->rloc_x = (char *) alloc(n_plist);
X				  tmppart[npart]->rloc_y = (char *) alloc(n_plist);
X				  for(i=0;i<n_plist;i++) {
X					  tmppart[npart]->rloc_x[i] = plist[i].x;
X					  tmppart[npart]->rloc_y[i] = plist[i].y;
X				  }
X				  tmppart[npart]->nloc = n_plist;
X			  }
X		  } break;
Xcase 21:
X# line 296 "lev_comp.y"
X{
X			  if (tmppart[npart]->nrmonst)
X			      yyerror("Monster registers already initialized!");
X			  else {
X				  tmppart[npart]->rmonst = (char *) alloc(n_mlist);
X				  memcpy(tmppart[npart]->rmonst, mlist, n_mlist);
X				  tmppart[npart]->nrmonst = n_mlist;
X			  }
X		  } break;
Xcase 22:
X# line 307 "lev_comp.y"
X{
X			  if (n_olist < MAX_REGISTERS)
X			      olist[n_olist++] = yypvt[-0].i;
X			  else
X			      yyerror("Object list too long!");
X		  } break;
Xcase 23:
X# line 314 "lev_comp.y"
X{
X			  if (n_olist < MAX_REGISTERS)
X			      olist[n_olist++] = yypvt[-2].i;
X			  else
X			      yyerror("Object list too long!");
X		  } break;
Xcase 24:
X# line 322 "lev_comp.y"
X{
X			  if (n_mlist < MAX_REGISTERS)
X			      mlist[n_mlist++] = yypvt[-0].i;
X			  else
X			      yyerror("Monster list too long!");
X		  } break;
Xcase 25:
X# line 329 "lev_comp.y"
X{
X			  if (n_mlist < MAX_REGISTERS)
X			      mlist[n_mlist++] = yypvt[-2].i;
X			  else
X			      yyerror("Monster list too long!");
X		  } break;
Xcase 26:
X# line 337 "lev_comp.y"
X{
X			  if (n_plist < MAX_REGISTERS)
X			      plist[n_plist++] = current_coord;
X			  else
X			      yyerror("Location list too long!");
X		  } break;
Xcase 27:
X# line 344 "lev_comp.y"
X{
X			  if (n_plist < MAX_REGISTERS)
X			      plist[n_plist++] = current_coord;
X			  else
X			      yyerror("Location list too long!");
X		  } break;
Xcase 41:
X# line 366 "lev_comp.y"
X{
X			  int token;
X
X			  tmpmonst[nmons] = (monster *) alloc(sizeof(monster));
X			  tmpmonst[nmons]->x = current_coord.x;
X			  tmpmonst[nmons]->y = current_coord.y;
X			  tmpmonst[nmons]->class = yypvt[-4].i;
X			  if (!yypvt[-2].map)
X			      tmpmonst[nmons]->id = -1;
X			  else {
X				  token = get_monster_id(yypvt[-2].map, (char) yypvt[-4].i);
X				  if (token == ERR) {
X				      yywarning("Illegal monster name!  Making random monster.");
X				      tmpmonst[nmons]->id = -1;
X				  } else
X				      tmpmonst[nmons]->id = token;
X			  }
X			  nmons++;
X		  } break;
Xcase 42:
X# line 387 "lev_comp.y"
X{
X			  int token;
X
X			  tmpobj[nobj] = (object *) alloc(sizeof(object));
X			  tmpobj[nobj]->x = current_coord.x;
X			  tmpobj[nobj]->y = current_coord.y;
X			  tmpobj[nobj]->class = yypvt[-4].i;
X			  if (!yypvt[-2].map)
X			      tmpobj[nobj]->id = -1;
X			  else {
X				  token = get_object_id(yypvt[-2].map, (char) yypvt[-4].i);
X				  if (token == ERR) {
X				      yywarning("Illegal object name!  Making random object.");
X				      tmpobj[nobj]->id = -1;
X				  } else
X				      tmpobj[nobj]->id = token;
X			  }
X			  nobj++;
X		  } break;
Xcase 43:
X# line 408 "lev_comp.y"
X{
X			tmpdoor[ndoor] = (door *) alloc(sizeof(door));
X			tmpdoor[ndoor]->x = current_coord.x;
X			tmpdoor[ndoor]->y = current_coord.y;
X			tmpdoor[ndoor]->mask = yypvt[-2].i;
X			ndoor++;
X		  } break;
Xcase 44:
X# line 417 "lev_comp.y"
X{
X			tmptrap[ntrap] = (trap *) alloc(sizeof(trap));
X			tmptrap[ntrap]->x = current_coord.x;
X			tmptrap[ntrap]->y = current_coord.y;
X			tmptrap[ntrap]->type = yypvt[-2].i;
X			ntrap++;
X		  } break;
Xcase 45:
X# line 426 "lev_comp.y"
X{
X			tmpdb[ndb] = (drawbridge *) alloc(sizeof(drawbridge));
X			tmpdb[ndb]->x = current_coord.x;
X			tmpdb[ndb]->y = current_coord.y;
X			tmpdb[ndb]->dir = db_dirs[yypvt[-2].i];
X			if ( yypvt[-0].i == D_ISOPEN )
X			  tmpdb[ndb]->open = 1;
X			else if ( yypvt[-0].i == D_CLOSED )
X			  tmpdb[ndb]->open = 0;
X			else
X			  yyerror("A drawbridge can only be open or closed!");
X			ndb++;
X		   } break;
Xcase 46:
X# line 441 "lev_comp.y"
X{
X			tmpwalk[nwalk] = (walk *) alloc(sizeof(walk));
X			tmpwalk[nwalk]->x = current_coord.x;
X			tmpwalk[nwalk]->y = current_coord.y;
X			tmpwalk[nwalk]->dir = yypvt[-0].i;
X			nwalk++;
X		  } break;
Xcase 47:
X# line 450 "lev_comp.y"
X{
X			tmplad[nlad] = (lad *) alloc(sizeof(lad));
X			tmplad[nlad]->x = current_coord.x;
X			tmplad[nlad]->y = current_coord.y;
X			tmplad[nlad]->up = yypvt[-0].i;
X			nlad++;
X		  } break;
Xcase 48:
X# line 459 "lev_comp.y"
X{
X			tmpdig[ndig] = (digpos *) alloc(sizeof(digpos));
X			tmpdig[ndig]->x1 = current_region.x1;
X			tmpdig[ndig]->y1 = current_region.y1;
X			tmpdig[ndig]->x2 = current_region.x2;
X			tmpdig[ndig]->y2 = current_region.y2;
X			ndig++;
X		  } break;
Xcase 49:
X# line 469 "lev_comp.y"
X{
X			tmpreg[nreg] = (region *) alloc(sizeof(region));
X			tmpreg[nreg]->x1 = current_region.x1;
X			tmpreg[nreg]->y1 = current_region.y1;
X			tmpreg[nreg]->x2 = current_region.x2;
X			tmpreg[nreg]->y2 = current_region.y2;
X			tmpreg[nreg]->rlit = yypvt[-2].i;
X			tmpreg[nreg]->rtype = yypvt[-0].i;
X			nreg++;
X		  } break;
Xcase 50:
X# line 481 "lev_comp.y"
X{
X#ifndef ALTARS
X			yywarning("Altars are not allowed in this version!  Ignoring...");
X#else
X			tmpaltar[naltar] = (altar *) alloc(sizeof(altar));
X			tmpaltar[naltar]->x = current_coord.x;
X			tmpaltar[naltar]->y = current_coord.y;
X			tmpaltar[naltar]->align = yypvt[-2].i;
X			tmpaltar[naltar]->shrine = yypvt[-0].i;
X			naltar++;
X#endif /* ALTARS */
X		  } break;
Xcase 52:
X# line 496 "lev_comp.y"
X{
X			  yyval.i = - MAX_REGISTERS - 1;
X		  } break;
Xcase 55:
X# line 503 "lev_comp.y"
X{
X			  yyval.i = - MAX_REGISTERS - 1;
X		  } break;
Xcase 58:
X# line 510 "lev_comp.y"
X{
X			  yyval.map = (char *) 0;
X		  } break;
Xcase 60:
X# line 516 "lev_comp.y"
X{
X			  yyval.map = (char *) 0;
X		  } break;
Xcase 61:
X# line 521 "lev_comp.y"
X{
X			int token = get_trap_type(yypvt[-0].map);
X			if (token == ERR)
X				yyerror("unknown trap type!");
X			yyval.i = token;
X		  } break;
Xcase 63:
X# line 530 "lev_comp.y"
X{
X			int token = get_room_type(yypvt[-0].map);
X			if (token == ERR) {
X				yywarning("Unknown room type!  Making ordinary room...");
X				yyval.i = OROOM;
X			} else
X				yyval.i = token;
X		  } break;
Xcase 67:
X# line 543 "lev_comp.y"
X{
X			  current_coord.x = current_coord.y = -MAX_REGISTERS-1;
X		  } break;
Xcase 74:
X# line 556 "lev_comp.y"
X{
X			  yyval.i = - MAX_REGISTERS - 1;
X		  } break;
Xcase 77:
X# line 564 "lev_comp.y"
X{
X			if ( yypvt[-1].i >= MAX_REGISTERS ) {
X				yyerror("Register Index overflow!");
X			} else {
X				current_coord.x = current_coord.y = - yypvt[-1].i - 1;
X			}
X		  } break;
Xcase 78:
X# line 573 "lev_comp.y"
X{
X			if ( yypvt[-1].i >= MAX_REGISTERS ) {
X				yyerror("Register Index overflow!");
X			} else {
X				yyval.i = - yypvt[-1].i - 1;
X			}
X		  } break;
Xcase 79:
X# line 582 "lev_comp.y"
X{
X			if ( yypvt[-1].i >= MAX_REGISTERS ) {
X				yyerror("Register Index overflow!");
X			} else {
X				yyval.i = - yypvt[-1].i - 1;
X			}
X		  } break;
Xcase 80:
X# line 591 "lev_comp.y"
X{
X			if ( yypvt[-1].i >= 3 ) {
X				yyerror("Register Index overflow!");
X			} else {
X				yyval.i = - yypvt[-1].i - 1;
X			}
X		  } break;
Xcase 82:
X# line 602 "lev_comp.y"
X{
X			if (check_monster_char((char) yypvt[-0].i))
X				yyval.i = yypvt[-0].i ;
X			else {
X				yyerror("unknown monster class!");
X				yyval.i = ERR;
X			}
X		  } break;
Xcase 83:
X# line 612 "lev_comp.y"
X{
X			char c;
X
X			c = yypvt[-0].i;
X#ifndef SPELLS
X			if ( c == '+') {
X				c = '?';
X				yywarning("Spellbooks are not allowed in this version! (converted into scroll)");
X			}
X#endif
X			if (check_object_char(c))
X				yyval.i = c;
X			else {
X				yyerror("Unknown char class!");
X				yyval.i = ERR;
X			}
X		  } break;
Xcase 85:
X# line 632 "lev_comp.y"
X{
X			if (yypvt[-3].i < 0 || yypvt[-3].i > max_x_map ||
X			    yypvt[-1].i < 0 || yypvt[-1].i > max_y_map)
X			    yyerror("Coordinates out of map range!");
X			current_coord.x = yypvt[-3].i;
X			current_coord.y = yypvt[-1].i;
X		  } break;
Xcase 86:
X# line 641 "lev_comp.y"
X{
X			if (yypvt[-7].i < 0 || yypvt[-7].i > max_x_map ||
X			    yypvt[-5].i < 0 || yypvt[-5].i > max_y_map ||
X			    yypvt[-3].i < 0 || yypvt[-3].i > max_x_map ||
X			    yypvt[-1].i < 0 || yypvt[-1].i > max_y_map)
X			    yyerror("Region out of map range!");
X			current_region.x1 = yypvt[-7].i;
X			current_region.y1 = yypvt[-5].i;
X			current_region.x2 = yypvt[-3].i;
X			current_region.y2 = yypvt[-1].i;
X		  } break; 
X		}
X		goto yystack;  /* stack new state and value */
X
X	}
END_OF_FILE
if test 33297 -ne `wc -c <'src/lev_comp.c'`; then
    echo shar: \"'src/lev_comp.c'\" unpacked with wrong size!
fi
# end of 'src/lev_comp.c'
echo shar: Extracting \"'src/lev_lex.c'\" \(21050 characters\)
sed "s/^X//" >'src/lev_lex.c' <<'END_OF_FILE'
X# include "stdio.h"
X# define U(x) x
X# define NLSTATE yyprevious=YYNEWLINE
X# define BEGIN yybgin = yysvec + 1 +
X# define INITIAL 0
X# define YYLERR yysvec
X# define YYSTATE (yyestate-yysvec-1)
X# define YYOPTIM 1
X# define YYLMAX 200
X# define output(c) putc(c,yyout)
X# define input() (((yytchar=yysptr>yysbuf?U(*--yysptr):getc(yyin))==10?(yylineno++,yytchar):yytchar)==EOF?0:yytchar)
X# define unput(c) {yytchar= (c);if(yytchar=='\n')yylineno--;*yysptr++=yytchar;}
X# define yymore() (yymorfg=1)
X# define ECHO fprintf(yyout, "%s",yytext)
X# define REJECT { nstr = yyreject(); goto yyfussy;}
Xint yyleng; extern char yytext[];
Xint yymorfg;
Xextern char *yysptr, yysbuf[];
Xint yytchar;
XFILE *yyin ={stdin}, *yyout ={stdout};
Xextern int yylineno;
Xstruct yysvf { 
X	struct yywork *yystoff;
X	struct yysvf *yyother;
X	int *yystops;};
Xstruct yysvf *yyestate;
Xextern struct yysvf yysvec[], *yybgin;
X/*	SCCS Id: @(#)lev_lex.c	3.0	90/01/04
X/*	Copyright (c) 1989 by Jean-Christophe Collet */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#define LEV_LEX_C
X
X/* block some unused #defines to avoid overloading some cpp's */
X#define MONDATA_H	/* comment this line for pre-compiled headers */
X#define MONFLAG_H	/* comment this line for pre-compiled headers */
X
X#include "hack.h"
X#include "lev_comp.h"
X#include "sp_lev.h"
X
X/* Most of these don't exist in flex, yywrap is macro and
X * yyunput is properly declared in flex.skel.
X */
X#ifndef FLEX_SCANNER
Xint FDECL (yyback, (int *, int));
Xint NDECL (yylook);
Xint NDECL (yyinput);
Xint NDECL (yywrap);
Xint NDECL (yylex);
Xint FDECL (yyunput, (int));
Xint FDECL (yyoutput, (int));
X#endif
X
X#ifdef MSDOS
X#undef exit
Xextern void FDECL(exit, (int));
X#endif
X
X/* this doesn't always get put in lev_comp.h
X * (esp. when using older versions of bison)
X */
X
Xextern YYSTYPE yylval;
X
X#ifdef MACOS
X#undef putchar
X#undef putc
X#undef printf
X#undef Printf
X#define Printf printf
X# ifdef LSC
X#define	putc(c,stream)	(fputc(c,stream))
X#define	putchar(c)	(fputc(c,stdout))
X# endif
X#endif
Xint line_number = 1;
X
X/* This is *** UGLY *** but I can't think a better way to do it
X * I really need a huge buffer to scan maps...
X */
X
X#undef YYLMAX
X#define YYLMAX	2048
X
X# define MAPC 2
X# define YYNEWLINE 10
Xyylex(){
Xint nstr; extern int yyprevious;
Xwhile((nstr = yylook()) >= 0)
Xyyfussy: switch(nstr){
Xcase 0:
Xif(yywrap()) return(0); break;
Xcase 1:
X{ line_number++; yymore(); }
Xbreak;
Xcase 2:
X{ BEGIN 0;
X		  line_number++;
X		  yytext[yyleng-7] = 0; /* Discard \nENDMAP */
X		  yylval.map = (char *) alloc(strlen(yytext)+1);
X		  strcpy(yylval.map, yytext);
X		  return MAP_ID;
X		}
Xbreak;
Xcase 3:
X	{ line_number++; }
Xbreak;
Xcase 4:
X	return MAZE_ID;
Xbreak;
Xcase 5:
X	return LEVEL_ID;
Xbreak;
Xcase 6:
Xreturn GEOMETRY_ID;
Xbreak;
Xcase 7:
X	{ BEGIN MAPC; line_number++; }
Xbreak;
Xcase 8:
X	return OBJECT_ID;
Xbreak;
Xcase 9:
X	return MONSTER_ID;
Xbreak;
Xcase 10:
X	return TRAP_ID;
Xbreak;
Xcase 11:
X	return DOOR_ID;
Xbreak;
Xcase 12:
Xreturn DRAWBRIDGE_ID;
Xbreak;
Xcase 13:
Xreturn MAZEWALK_ID;
Xbreak;
Xcase 14:
X	return REGION_ID;
Xbreak;
Xcase 15:
Xreturn RANDOM_OBJECTS_ID;
Xbreak;
Xcase 16:
Xreturn RANDOM_MONSTERS_ID;
Xbreak;
Xcase 17:
Xreturn RANDOM_PLACES_ID;
Xbreak;
Xcase 18:
X	return ALTAR_ID;
Xbreak;
Xcase 19:
X	return LADDER_ID;
Xbreak;
Xcase 20:
Xreturn NON_DIGGABLE_ID;
Xbreak;
Xcase 21:
X	return ROOM_ID;
Xbreak;
Xcase 22:
X	{ yylval.i=D_ISOPEN; return DOOR_STATE; }
Xbreak;
Xcase 23:
X	{ yylval.i=D_CLOSED; return DOOR_STATE; }
Xbreak;
Xcase 24:
X	{ yylval.i=D_LOCKED; return DOOR_STATE; }
Xbreak;
Xcase 25:
X	{ yylval.i=D_NODOOR; return DOOR_STATE; }
Xbreak;
Xcase 26:
X	{ yylval.i=D_BROKEN; return DOOR_STATE; }
Xbreak;
Xcase 27:
X	{ yylval.i=W_NORTH; return DIRECTION; }
Xbreak;
Xcase 28:
X	{ yylval.i=W_EAST; return DIRECTION; }
Xbreak;
Xcase 29:
X	{ yylval.i=W_SOUTH; return DIRECTION; }
Xbreak;
Xcase 30:
X	{ yylval.i=W_WEST; return DIRECTION; }
Xbreak;
Xcase 31:
X	{ yylval.i = -1; return RANDOM_TYPE; }
Xbreak;
Xcase 32:
X	return O_REGISTER;
Xbreak;
Xcase 33:
X	return M_REGISTER;
Xbreak;
Xcase 34:
X	return P_REGISTER;
Xbreak;
Xcase 35:
X	return A_REGISTER;
Xbreak;
Xcase 36:
X	{ yylval.i=1; return LEFT_OR_RIGHT; }
Xbreak;
Xcase 37:
X	{ yylval.i=3; return LEFT_OR_RIGHT; }
Xbreak;
Xcase 38:
X	{ yylval.i=2; return CENTER; }
Xbreak;
Xcase 39:
X	{ yylval.i=1; return TOP_OR_BOT; }
Xbreak;
Xcase 40:
X	{ yylval.i=3; return TOP_OR_BOT; }
Xbreak;
Xcase 41:
X	{ yylval.i=1; return LIGHT_STATE; }
Xbreak;
Xcase 42:
X	{ yylval.i=0; return LIGHT_STATE; }
Xbreak;
Xcase 43:
X	{ yylval.i=A_LAW; return ALIGNMENT; }
Xbreak;
Xcase 44:
X	{ yylval.i=A_NEUTRAL; return ALIGNMENT; }
Xbreak;
Xcase 45:
X	{ yylval.i=A_CHAOS; return ALIGNMENT; }
Xbreak;
Xcase 46:
X	{ yylval.i=1; return ALTAR_TYPE; }
Xbreak;
Xcase 47:
X	{ yylval.i=0; return ALTAR_TYPE; }
Xbreak;
Xcase 48:
X	{ yylval.i=1; return UP_OR_DOWN; }
Xbreak;
Xcase 49:
X	{ yylval.i=0; return UP_OR_DOWN; }
Xbreak;
Xcase 50:
X	{ yylval.i=atoi(yytext); return INTEGER; }
Xbreak;
Xcase 51:
X{ yytext[yyleng-1] = 0; /* Discard the trailing \" */
X		  yylval.map = (char *) alloc(strlen(yytext+1)+1);
X		  strcpy(yylval.map, yytext+1); /* Discard the first \" */
X		  return STRING; }
Xbreak;
Xcase 52:
X	{ line_number++; }
Xbreak;
Xcase 53:
X	;
Xbreak;
Xcase 54:
X	{ yylval.i = yytext[1]; return CHAR; }
Xbreak;
Xcase 55:
X	{ return yytext[0]; }
Xbreak;
Xcase -1:
Xbreak;
Xdefault:
Xfprintf(yyout,"bad switch yylook %d",nstr);
X} return(0); }
X/* end of yylex */
X#ifdef	AMIGA
Xlong *alloc(n)
X	unsigned n;
X{
X	return ((long *)malloc (n));
X}
X#endif
Xint yyvstop[] ={
X0,
X
X55,
X0,
X
X53,
X55,
X0,
X
X52,
X0,
X
X55,
X0,
X
X55,
X0,
X
X50,
X55,
X0,
X
X55,
X0,
X
X55,
X0,
X
X55,
X0,
X
X55,
X0,
X
X55,
X0,
X
X55,
X0,
X
X55,
X0,
X
X55,
X0,
X
X55,
X0,
X
X55,
X0,
X
X55,
X0,
X
X55,
X0,
X
X55,
X0,
X
X55,
X0,
X
X55,
X0,
X
X55,
X0,
X
X55,
X0,
X
X55,
X0,
X
X55,
X0,
X
X55,
X0,
X
X55,
X0,
X
X55,
X0,
X
X55,
X0,
X
X55,
X0,
X
X55,
X0,
X
X55,
X0,
X
X1,
X52,
X0,
X
X53,
X55,
X0,
X
X55,
X0,
X
X55,
X0,
X
X55,
X0,
X
X53,
X0,
X
X51,
X0,
X
X50,
X0,
X
X48,
X0,
X
X3,
X0,
X
X1,
X0,
X
X53,
X0,
X
X1,
X3,
X0,
X
X54,
X0,
X
X43,
X0,
X
X41,
X0,
X
X39,
X0,
X
X11,
X0,
X
X4,
X0,
X
X21,
X0,
X
X10,
X0,
X
X49,
X0,
X
X28,
X0,
X
X36,
X0,
X
X22,
X0,
X
X30,
X0,
X
X7,
X0,
X
X18,
X0,
X
X5,
X0,
X
X35,
X0,
X
X47,
X0,
X
X45,
X0,
X
X27,
X0,
X
X34,
X0,
X
X37,
X0,
X
X29,
X0,
X
X42,
X0,
X
X19,
X0,
X
X8,
X0,
X
X14,
X0,
X
X40,
X0,
X
X26,
X0,
X
X38,
X0,
X
X23,
X0,
X
X24,
X0,
X
X25,
X0,
X
X32,
X0,
X
X31,
X0,
X
X46,
X0,
X
X9,
X0,
X
X33,
X0,
X
X44,
X0,
X
X2,
X0,
X
X6,
X0,
X
X13,
X0,
X
X12,
X0,
X
X20,
X0,
X
X17,
X0,
X
X15,
X0,
X
X16,
X0,
X0};
X# define YYTYPE int
Xstruct yywork { YYTYPE verify, advance; } yycrank[] ={
X0,0,	0,0,	1,5,	0,0,	
X0,0,	0,0,	0,0,	0,0,	
X8,43,	0,0,	1,6,	1,7,	
X9,45,	0,0,	6,42,	0,0,	
X8,43,	8,43,	0,0,	0,0,	
X9,45,	9,0,	41,94,	0,0,	
X0,0,	0,0,	0,0,	0,0,	
X0,0,	0,0,	0,0,	0,0,	
X0,0,	1,6,	0,0,	1,8,	
X1,5,	6,42,	0,0,	8,43,	
X1,9,	8,44,	8,43,	9,45,	
X41,95,	9,45,	9,45,	41,95,	
X45,96,	1,10,	0,0,	0,0,	
X0,0,	0,0,	0,0,	8,43,	
X0,0,	0,0,	0,0,	9,45,	
X0,0,	0,0,	0,0,	0,0,	
X0,0,	0,0,	1,11,	14,51,	
X15,53,	1,12,	13,50,	14,52,	
X1,13,	17,56,	36,89,	49,99,	
X51,101,	1,14,	1,15,	1,16,	
X1,17,	11,47,	15,54,	1,18,	
X12,48,	1,19,	16,55,	12,49,	
X2,5,	18,57,	19,60,	40,93,	
X47,97,	18,58,	48,98,	50,100,	
X2,6,	2,7,	1,20,	1,21,	
X1,22,	1,23,	1,24,	18,59,	
X24,68,	34,86,	52,102,	53,103,	
X54,104,	1,25,	1,26,	1,27,	
X1,28,	1,29,	20,61,	1,30,	
X1,31,	1,32,	1,33,	2,6,	
X1,34,	2,8,	2,35,	23,67,	
X21,62,	26,73,	2,9,	21,63,	
X29,78,	32,83,	2,5,	55,105,	
X2,5,	2,5,	28,76,	2,10,	
X10,46,	10,46,	10,46,	10,46,	
X10,46,	10,46,	10,46,	10,46,	
X10,46,	10,46,	22,64,	27,74,	
X28,77,	22,65,	56,106,	30,79,	
X2,11,	22,66,	31,81,	2,12,	
X57,107,	27,75,	2,13,	30,80,	
X58,108,	31,82,	2,5,	2,14,	
X2,36,	2,16,	2,17,	59,109,	
X25,69,	2,18,	2,5,	2,19,	
X25,70,	33,84,	60,110,	33,85,	
X25,71,	62,113,	61,111,	2,5,	
X63,114,	64,115,	25,72,	65,116,	
X2,20,	2,21,	2,22,	2,23,	
X2,24,	61,112,	66,117,	3,37,	
X67,118,	68,119,	69,120,	2,25,	
X2,26,	2,27,	2,28,	2,29,	
X35,87,	2,30,	2,31,	2,32,	
X2,33,	70,121,	2,34,	71,122,	
X35,87,	35,88,	2,5,	2,5,	
X2,5,	3,38,	72,123,	73,124,	
X3,39,	74,125,	75,126,	76,128,	
X3,9,	77,129,	78,130,	79,131,	
X80,132,	81,133,	82,134,	83,135,	
X84,136,	86,137,	89,138,	35,87,	
X75,127,	35,87,	35,87,	93,139,	
X97,140,	98,141,	99,142,	95,94,	
X89,103,	100,143,	101,144,	102,145,	
X103,146,	104,147,	3,11,	35,87,	
X105,148,	3,12,	3,40,	106,149,	
X3,13,	107,150,	108,151,	109,152,	
X110,153,	3,14,	3,15,	3,16,	
X3,17,	95,95,	111,154,	3,18,	
X95,95,	3,19,	112,155,	113,156,	
X114,157,	115,158,	116,159,	117,160,	
X118,161,	119,162,	121,163,	123,164,	
X124,165,	4,37,	3,20,	3,21,	
X3,22,	3,23,	3,24,	125,166,	
X126,167,	127,168,	128,169,	129,170,	
X130,171,	3,25,	3,26,	3,27,	
X3,28,	3,29,	131,172,	3,30,	
X3,31,	3,32,	3,33,	4,38,	
X3,34,	132,173,	4,41,	133,174,	
X134,175,	136,176,	4,9,	137,177,	
X138,178,	139,179,	4,39,	140,180,	
X4,39,	4,39,	142,181,	143,182,	
X144,183,	145,184,	146,185,	147,186,	
X148,187,	149,188,	150,189,	151,190,	
X154,191,	155,192,	156,193,	157,194,	
X158,195,	159,196,	160,197,	164,198,	
X4,11,	165,199,	166,200,	4,12,	
X4,40,	167,201,	4,13,	168,202,	
X169,203,	171,204,	4,39,	4,14,	
X4,36,	4,16,	4,17,	172,205,	
X173,206,	4,18,	4,39,	4,19,	
X174,207,	175,208,	176,209,	179,210,	
X181,211,	182,212,	183,213,	4,39,	
X185,214,	186,215,	38,42,	38,90,	
X4,20,	4,21,	4,22,	4,23,	
X4,24,	187,216,	188,217,	189,218,	
X190,219,	193,220,	194,221,	4,25,	
X4,26,	4,27,	4,28,	4,29,	
X195,222,	4,30,	4,31,	4,32,	
X4,33,	38,91,	4,34,	39,90,	
X38,92,	197,223,	4,39,	4,39,	
X4,39,	198,224,	199,225,	200,226,	
X38,92,	201,227,	38,92,	38,92,	
X203,228,	205,229,	207,230,	210,231,	
X211,232,	212,233,	214,234,	215,235,	
X216,236,	39,92,	218,237,	225,238,	
X39,92,	226,239,	231,240,	232,241,	
X233,242,	234,243,	236,244,	241,248,	
X39,92,	244,249,	39,92,	39,92,	
X237,245,	245,250,	237,246,	237,247,	
X38,92,	246,251,	247,252,	248,253,	
X249,254,	250,255,	251,256,	252,257,	
X38,92,	254,258,	255,259,	256,260,	
X257,261,	258,262,	259,263,	260,264,	
X261,265,	38,92,	263,266,	264,267,	
X265,268,	266,269,	267,270,	269,271,	
X39,92,	0,0,	0,0,	0,0,	
X0,0,	0,0,	0,0,	0,0,	
X39,92,	0,0,	0,0,	0,0,	
X0,0,	0,0,	0,0,	0,0,	
X0,0,	39,92,	0,0,	0,0,	
X0,0,	0,0,	0,0,	0,0,	
X38,92,	38,92,	38,92,	0,0,	
X0,0,	0,0,	0,0,	0,0,	
X0,0,	0,0,	0,0,	0,0,	
X0,0,	0,0,	0,0,	0,0,	
X0,0,	0,0,	0,0,	0,0,	
X0,0,	0,0,	0,0,	0,0,	
X39,92,	39,92,	39,92,	0,0,	
X0,0};
Xstruct yysvf yysvec[] ={
X0,	0,	0,
Xyycrank+-1,	0,		0,	
Xyycrank+-87,	0,		0,	
Xyycrank+-181,	yysvec+1,	0,	
Xyycrank+-267,	yysvec+2,	0,	
Xyycrank+0,	0,		yyvstop+1,
Xyycrank+5,	0,		yyvstop+3,
Xyycrank+0,	0,		yyvstop+6,
Xyycrank+-7,	0,		yyvstop+8,
Xyycrank+-11,	0,		yyvstop+10,
Xyycrank+88,	0,		yyvstop+12,
Xyycrank+5,	0,		yyvstop+15,
Xyycrank+5,	0,		yyvstop+17,
Xyycrank+1,	0,		yyvstop+19,
Xyycrank+2,	0,		yyvstop+21,
Xyycrank+3,	0,		yyvstop+23,
Xyycrank+7,	0,		yyvstop+25,
Xyycrank+7,	0,		yyvstop+27,
Xyycrank+24,	0,		yyvstop+29,
Xyycrank+8,	0,		yyvstop+31,
Xyycrank+6,	0,		yyvstop+33,
Xyycrank+13,	0,		yyvstop+35,
Xyycrank+45,	0,		yyvstop+37,
Xyycrank+12,	0,		yyvstop+39,
Xyycrank+7,	0,		yyvstop+41,
Xyycrank+71,	0,		yyvstop+43,
Xyycrank+14,	0,		yyvstop+45,
Xyycrank+46,	0,		yyvstop+47,
Xyycrank+36,	0,		yyvstop+49,
Xyycrank+20,	0,		yyvstop+51,
Xyycrank+54,	0,		yyvstop+53,
Xyycrank+50,	0,		yyvstop+55,
Xyycrank+18,	0,		yyvstop+57,
Xyycrank+63,	0,		yyvstop+59,
Xyycrank+4,	0,		yyvstop+61,
Xyycrank+-199,	0,		yyvstop+63,
Xyycrank+9,	yysvec+15,	yyvstop+65,
Xyycrank+0,	0,		yyvstop+67,
Xyycrank+353,	0,		yyvstop+70,
Xyycrank+377,	0,		yyvstop+73,
Xyycrank+13,	0,		yyvstop+75,
Xyycrank+-12,	yysvec+35,	yyvstop+77,
Xyycrank+0,	yysvec+6,	yyvstop+79,
Xyycrank+0,	yysvec+8,	0,	
Xyycrank+0,	0,		yyvstop+81,
Xyycrank+9,	0,		0,	
Xyycrank+0,	yysvec+10,	yyvstop+83,
Xyycrank+8,	0,		0,	
Xyycrank+15,	0,		0,	
Xyycrank+10,	0,		0,	
Xyycrank+16,	0,		0,	
Xyycrank+8,	0,		0,	
Xyycrank+20,	0,		0,	
Xyycrank+17,	0,		0,	
Xyycrank+30,	0,		0,	
Xyycrank+53,	0,		0,	
Xyycrank+76,	0,		0,	
Xyycrank+78,	0,		0,	
Xyycrank+89,	0,		0,	
Xyycrank+88,	0,		0,	
Xyycrank+109,	0,		0,	
Xyycrank+73,	0,		0,	
Xyycrank+61,	0,		0,	
Xyycrank+69,	0,		0,	
Xyycrank+71,	0,		0,	
Xyycrank+86,	0,		0,	
Xyycrank+79,	0,		0,	
Xyycrank+73,	0,		0,	
Xyycrank+78,	0,		0,	
Xyycrank+75,	0,		0,	
Xyycrank+103,	0,		0,	
Xyycrank+91,	0,		0,	
Xyycrank+115,	0,		0,	
Xyycrank+105,	0,		0,	
Xyycrank+100,	0,		0,	
Xyycrank+118,	0,		0,	
Xyycrank+113,	0,		0,	
Xyycrank+120,	0,		0,	
Xyycrank+125,	0,		0,	
Xyycrank+113,	0,		0,	
Xyycrank+121,	0,		0,	
Xyycrank+111,	0,		0,	
Xyycrank+109,	0,		0,	
Xyycrank+115,	0,		0,	
Xyycrank+120,	0,		0,	
Xyycrank+0,	0,		yyvstop+85,
Xyycrank+114,	0,		0,	
Xyycrank+0,	yysvec+35,	0,	
Xyycrank+0,	0,		yyvstop+87,
Xyycrank+150,	0,		0,	
Xyycrank+0,	0,		yyvstop+89,
Xyycrank+0,	yysvec+38,	yyvstop+91,
Xyycrank+0,	yysvec+39,	0,	
Xyycrank+167,	0,		0,	
Xyycrank+0,	0,		yyvstop+93,
Xyycrank+-229,	yysvec+35,	0,	
Xyycrank+0,	0,		yyvstop+96,
Xyycrank+171,	0,		0,	
Xyycrank+155,	0,		0,	
Xyycrank+151,	0,		0,	
Xyycrank+164,	0,		0,	
Xyycrank+174,	0,		0,	
Xyycrank+174,	0,		0,	
Xyycrank+175,	0,		0,	
Xyycrank+162,	0,		0,	
Xyycrank+153,	0,		0,	
Xyycrank+182,	0,		0,	
Xyycrank+185,	0,		0,	
Xyycrank+181,	0,		0,	
Xyycrank+178,	0,		0,	
Xyycrank+176,	0,		0,	
Xyycrank+159,	0,		0,	
Xyycrank+169,	0,		0,	
Xyycrank+151,	0,		0,	
Xyycrank+161,	0,		0,	
Xyycrank+153,	0,		0,	
Xyycrank+159,	0,		0,	
Xyycrank+156,	0,		0,	
Xyycrank+162,	0,		0,	
Xyycrank+157,	0,		0,	
Xyycrank+0,	0,		yyvstop+98,
Xyycrank+158,	0,		0,	
Xyycrank+0,	0,		yyvstop+100,
Xyycrank+168,	0,		0,	
Xyycrank+161,	0,		0,	
Xyycrank+167,	0,		0,	
Xyycrank+173,	0,		0,	
Xyycrank+169,	0,		0,	
Xyycrank+185,	0,		0,	
Xyycrank+177,	0,		0,	
Xyycrank+189,	0,		0,	
Xyycrank+194,	0,		0,	
Xyycrank+197,	0,		0,	
Xyycrank+198,	0,		0,	
Xyycrank+188,	0,		0,	
Xyycrank+0,	0,		yyvstop+102,
Xyycrank+200,	0,		0,	
Xyycrank+191,	0,		0,	
Xyycrank+298,	0,		0,	
Xyycrank+232,	0,		0,	
Xyycrank+229,	0,		0,	
Xyycrank+0,	0,		yyvstop+104,
Xyycrank+248,	0,		0,	
Xyycrank+246,	0,		0,	
Xyycrank+247,	0,		0,	
Xyycrank+241,	0,		0,	
Xyycrank+231,	0,		yyvstop+106,
Xyycrank+235,	0,		0,	
Xyycrank+252,	0,		0,	
Xyycrank+254,	0,		0,	
Xyycrank+243,	0,		0,	
Xyycrank+244,	0,		0,	
Xyycrank+0,	0,		yyvstop+108,
Xyycrank+0,	0,		yyvstop+110,
Xyycrank+214,	0,		0,	
Xyycrank+211,	0,		0,	
Xyycrank+215,	0,		0,	
Xyycrank+226,	0,		0,	
Xyycrank+227,	0,		0,	
Xyycrank+214,	0,		0,	
Xyycrank+229,	0,		0,	
Xyycrank+0,	0,		yyvstop+112,
Xyycrank+0,	0,		yyvstop+114,
Xyycrank+0,	0,		yyvstop+116,
Xyycrank+230,	0,		0,	
Xyycrank+217,	0,		0,	
Xyycrank+220,	0,		0,	
Xyycrank+226,	0,		0,	
Xyycrank+235,	0,		0,	
Xyycrank+241,	0,		0,	
Xyycrank+0,	0,		yyvstop+118,
Xyycrank+240,	0,		0,	
Xyycrank+236,	0,		0,	
Xyycrank+232,	0,		0,	
Xyycrank+242,	0,		0,	
Xyycrank+249,	0,		0,	
Xyycrank+238,	0,		0,	
Xyycrank+0,	0,		yyvstop+120,
Xyycrank+0,	0,		yyvstop+122,
Xyycrank+290,	0,		0,	
Xyycrank+0,	0,		yyvstop+124,
Xyycrank+274,	0,		0,	
Xyycrank+273,	0,		0,	
Xyycrank+276,	0,		0,	
Xyycrank+0,	0,		yyvstop+126,
Xyycrank+295,	0,		0,	
Xyycrank+292,	0,		0,	
Xyycrank+296,	0,		0,	
Xyycrank+286,	0,		0,	
Xyycrank+294,	0,		0,	
Xyycrank+294,	0,		0,	
Xyycrank+0,	0,		yyvstop+128,
Xyycrank+0,	0,		yyvstop+130,
Xyycrank+264,	0,		0,	
Xyycrank+264,	0,		0,	
Xyycrank+266,	0,		0,	
Xyycrank+0,	0,		yyvstop+132,
Xyycrank+289,	0,		0,	
Xyycrank+293,	0,		0,	
Xyycrank+293,	0,		0,	
Xyycrank+298,	0,		0,	
Xyycrank+283,	0,		0,	
Xyycrank+0,	0,		yyvstop+134,
Xyycrank+284,	0,		0,	
Xyycrank+0,	0,		yyvstop+136,
Xyycrank+292,	0,		0,	
Xyycrank+0,	0,		yyvstop+138,
Xyycrank+301,	0,		0,	
Xyycrank+0,	0,		yyvstop+140,
Xyycrank+0,	0,		yyvstop+142,
Xyycrank+323,	0,		0,	
Xyycrank+331,	0,		0,	
Xyycrank+323,	0,		0,	
Xyycrank+0,	0,		yyvstop+144,
Xyycrank+330,	0,		0,	
Xyycrank+325,	0,		0,	
Xyycrank+337,	0,		0,	
Xyycrank+0,	0,		yyvstop+146,
Xyycrank+315,	0,		0,	
Xyycrank+0,	0,		yyvstop+148,
Xyycrank+0,	0,		yyvstop+150,
Xyycrank+0,	0,		yyvstop+152,
Xyycrank+0,	0,		yyvstop+154,
Xyycrank+0,	0,		yyvstop+156,
Xyycrank+0,	0,		yyvstop+158,
Xyycrank+297,	0,		0,	
Xyycrank+305,	0,		0,	
Xyycrank+0,	0,		yyvstop+160,
Xyycrank+0,	0,		yyvstop+162,
Xyycrank+0,	0,		yyvstop+164,
Xyycrank+0,	0,		yyvstop+166,
Xyycrank+404,	0,		0,	
Xyycrank+347,	0,		0,	
Xyycrank+327,	0,		0,	
Xyycrank+342,	0,		0,	
Xyycrank+0,	0,		yyvstop+168,
Xyycrank+347,	0,		0,	
Xyycrank+347,	0,		0,	
Xyycrank+0,	0,		yyvstop+170,
Xyycrank+0,	0,		yyvstop+172,
Xyycrank+0,	0,		yyvstop+174,
Xyycrank+348,	0,		0,	
Xyycrank+0,	0,		yyvstop+176,
Xyycrank+0,	0,		yyvstop+178,
Xyycrank+356,	0,		0,	
Xyycrank+346,	0,		0,	
Xyycrank+363,	0,		0,	
Xyycrank+354,	0,		0,	
Xyycrank+362,	0,		0,	
Xyycrank+366,	0,		0,	
Xyycrank+355,	0,		0,	
Xyycrank+360,	0,		0,	
Xyycrank+370,	0,		0,	
Xyycrank+0,	0,		yyvstop+180,
Xyycrank+361,	0,		0,	
Xyycrank+355,	0,		0,	
Xyycrank+370,	0,		0,	
Xyycrank+373,	0,		0,	
Xyycrank+372,	0,		0,	
Xyycrank+358,	0,		0,	
Xyycrank+376,	0,		0,	
Xyycrank+375,	0,		0,	
Xyycrank+0,	0,		yyvstop+182,
Xyycrank+377,	0,		0,	
Xyycrank+363,	0,		0,	
Xyycrank+365,	0,		0,	
Xyycrank+367,	0,		0,	
Xyycrank+367,	0,		0,	
Xyycrank+0,	0,		yyvstop+184,
Xyycrank+368,	0,		0,	
Xyycrank+0,	0,		yyvstop+186,
Xyycrank+0,	0,		yyvstop+188,
X0,	0,	0};
Xstruct yywork *yytop = yycrank+502;
Xstruct yysvf *yybgin = yysvec+1;
Xchar yymatch[] ={
X00  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
X01  ,011 ,012 ,01  ,01  ,01  ,01  ,01  ,
X01  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
X01  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
X040 ,01  ,'"' ,'#' ,01  ,01  ,01  ,01  ,
X01  ,01  ,01  ,'#' ,01  ,'#' ,'#' ,01  ,
X'0' ,'0' ,'0' ,'0' ,'0' ,'0' ,'0' ,'0' ,
X'0' ,'0' ,01  ,01  ,01  ,01  ,01  ,01  ,
X01  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
X01  ,01  ,01  ,'#' ,01  ,01  ,01  ,01  ,
X01  ,01  ,01  ,'#' ,01  ,01  ,01  ,01  ,
X01  ,01  ,01  ,01  ,'#' ,01  ,01  ,01  ,
X01  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
X01  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
X01  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
X01  ,01  ,01  ,'#' ,'#' ,'#' ,01  ,01  ,
X0};
Xchar yyextra[] ={
X0,0,0,0,0,0,0,0,
X0,0,0,0,0,0,0,0,
X0,0,0,0,0,0,0,0,
X0,0,0,0,0,0,0,0,
X0,0,0,0,0,0,0,0,
X0,0,0,0,0,0,0,0,
X0,0,0,0,0,0,0,0,
X0};
X/*	ncform	4.1	83/08/11	*/
X
Xint yylineno =1;
X# define YYU(x) x
X# define NLSTATE yyprevious=YYNEWLINE
Xchar yytext[YYLMAX];
Xstruct yysvf *yylstate [YYLMAX], **yylsp, **yyolsp;
Xchar yysbuf[YYLMAX];
Xchar *yysptr = yysbuf;
Xint *yyfnd;
Xextern struct yysvf *yyestate;
Xint yyprevious = YYNEWLINE;
Xyylook(){
X	register struct yysvf *yystate, **lsp;
X	register struct yywork *yyt;
X	struct yysvf *yyz;
X	int yych;
X	struct yywork *yyr;
X# ifdef LEXDEBUG
X	int debug;
X# endif
X	char *yylastch;
X	/* start off machines */
X# ifdef LEXDEBUG
X	debug = 0;
X# endif
X	if (!yymorfg)
X		yylastch = yytext;
X	else {
X		yymorfg=0;
X		yylastch = yytext+yyleng;
X		}
X	for(;;){
X		lsp = yylstate;
X		yyestate = yystate = yybgin;
X		if (yyprevious==YYNEWLINE) yystate++;
X		for (;;){
X# ifdef LEXDEBUG
X			if(debug)fprintf(yyout,"state %d\n",yystate-yysvec-1);
X# endif
X			yyt = yystate->yystoff;
X			if(yyt == yycrank){		/* may not be any transitions */
X				yyz = yystate->yyother;
X				if(yyz == 0)break;
X				if(yyz->yystoff == yycrank)break;
X				}
X			*yylastch++ = yych = input();
X		tryagain:
X# ifdef LEXDEBUG
X			if(debug){
X				fprintf(yyout,"char ");
X				allprint(yych);
X				putchar('\n');
X				}
X# endif
X			yyr = yyt;
X			if ( (int)yyt > (int)yycrank){
X				yyt = yyr + yych;
X				if (yyt <= yytop && yyt->verify+yysvec == yystate){
X					if(yyt->advance+yysvec == YYLERR)	/* error transitions */
X						{unput(*--yylastch);break;}
X					*lsp++ = yystate = yyt->advance+yysvec;
X					goto contin;
X					}
X				}
X# ifdef YYOPTIM
X			else if((int)yyt < (int)yycrank) {		/* r < yycrank */
X				yyt = yyr = yycrank+(yycrank-yyt);
X# ifdef LEXDEBUG
X				if(debug)fprintf(yyout,"compressed state\n");
X# endif
X				yyt = yyt + yych;
X				if(yyt <= yytop && yyt->verify+yysvec == yystate){
X					if(yyt->advance+yysvec == YYLERR)	/* error transitions */
X						{unput(*--yylastch);break;}
X					*lsp++ = yystate = yyt->advance+yysvec;
X					goto contin;
X					}
X				yyt = yyr + YYU(yymatch[yych]);
X# ifdef LEXDEBUG
X				if(debug){
X					fprintf(yyout,"try fall back character ");
X					allprint(YYU(yymatch[yych]));
X					putchar('\n');
X					}
X# endif
X				if(yyt <= yytop && yyt->verify+yysvec == yystate){
X					if(yyt->advance+yysvec == YYLERR)	/* error transition */
X						{unput(*--yylastch);break;}
X					*lsp++ = yystate = yyt->advance+yysvec;
X					goto contin;
X					}
X				}
X			if ((yystate = yystate->yyother) && (yyt= yystate->yystoff) != yycrank){
X# ifdef LEXDEBUG
X				if(debug)fprintf(yyout,"fall back to state %d\n",yystate-yysvec-1);
X# endif
X				goto tryagain;
X				}
X# endif
X			else
X				{unput(*--yylastch);break;}
X		contin:
X# ifdef LEXDEBUG
X			if(debug){
X				fprintf(yyout,"state %d char ",yystate-yysvec-1);
X				allprint(yych);
X				putchar('\n');
X				}
X# endif
X			;
X			}
X# ifdef LEXDEBUG
X		if(debug){
X			fprintf(yyout,"stopped at %d with ",*(lsp-1)-yysvec-1);
X			allprint(yych);
X			putchar('\n');
X			}
X# endif
X		while (lsp-- > yylstate){
X			*yylastch-- = 0;
X			if (*lsp != 0 && (yyfnd= (*lsp)->yystops) && *yyfnd > 0){
X				yyolsp = lsp;
X				if(yyextra[*yyfnd]){		/* must backup */
X					while(yyback((*lsp)->yystops,-*yyfnd) != 1 && lsp > yylstate){
X						lsp--;
X						unput(*yylastch--);
X						}
X					}
X				yyprevious = YYU(*yylastch);
X				yylsp = lsp;
X				yyleng = yylastch-yytext+1;
X				yytext[yyleng] = 0;
X# ifdef LEXDEBUG
X				if(debug){
X					fprintf(yyout,"\nmatch ");
X					sprint(yytext);
X					fprintf(yyout," action %d\n",*yyfnd);
X					}
X# endif
X				return(*yyfnd++);
X				}
X			unput(*yylastch);
X			}
X		if (yytext[0] == 0  /* && feof(yyin) */)
X			{
X			yysptr=yysbuf;
X			return(0);
X			}
X		yyprevious = yytext[0] = input();
X		if (yyprevious>0)
X			output(yyprevious);
X		yylastch=yytext;
X# ifdef LEXDEBUG
X		if(debug)putchar('\n');
X# endif
X		}
X	}
Xyyback(p, m)
X	int *p;
X{
Xif (p==0) return(0);
Xwhile (*p)
X	{
X	if (*p++ == m)
X		return(1);
X	}
Xreturn(0);
X}
X	/* the following are only used in the lex library */
Xyyinput(){
X	return(input());
X	}
Xyyoutput(c)
X  int c; {
X	output(c);
X	}
Xyyunput(c)
X   int c; {
X	unput(c);
X	}
END_OF_FILE
if test 21050 -ne `wc -c <'src/lev_lex.c'`; then
    echo shar: \"'src/lev_lex.c'\" unpacked with wrong size!
fi
# end of 'src/lev_lex.c'
echo shar: End of archive 21 \(of 24\).
cp /dev/null ark21isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 24 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
