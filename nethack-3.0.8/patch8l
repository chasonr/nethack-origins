Path: utzoo!utgpu!news-server.csri.toronto.edu!mailrus!uwm.edu!ogicse!zephyr.ens.tek.com!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v10i030:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Patch8l
Message-ID: <5738@tekred.CNA.TEK.COM>
Date: 5 Jun 90 17:57:47 GMT
Sender: news@tekred.CNA.TEK.COM
Lines: 2079
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 10, Issue 30
Archive-name: NetHack3/Patch8l
Patch-To: NetHack3: Volume 7, Issue 56-93



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 12 (of 24)."
# Contents:  patch8.01
# Wrapped by billr@saab on Mon Jun  4 15:27:23 1990
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'patch8.01' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'patch8.01'\"
else
echo shar: Extracting \"'patch8.01'\" \(50042 characters\)
sed "s/^X//" >'patch8.01' <<'END_OF_FILE'
X*** src/Old/Makefile.src	Sun Jun  3 12:47:55 1990
X--- src/Makefile.src	Sun Jun  3 08:53:06 1990
X***************
X*** 17,23 ****
X  #
X  SHELL=/bin/sh
X  
X! # if you are cross-compiling (eg. from Xenix into a Dos enviornment) you will
X  # have to redefine this filename prefix (which is used to select the filenames
X  # *main.c, *tty.c, and *unix.c for the target environment)
X  #
X--- 17,23 ----
X  #
X  SHELL=/bin/sh
X  
X! # if you are cross-compiling (eg. from Xenix into a Dos environment) you will
X  # have to redefine this filename prefix (which is used to select the filenames
X  # *main.c, *tty.c, and *unix.c for the target environment)
X  #
X***************
X*** 25,34 ****
X  # Systos wants 'pc'; everything else normally wants 'unix'
X  TARG = unix
X  
X  # if you are using gcc as your compiler:
X- #	add -fwritable-strings to your other CFLAGS
X  #	uncomment the CC definition below if it's not in your environment
X- #	ignore warnings about initializing non-const *s from const *s
X  #	if you get setcgtty() warnings during execution, you are feeding gcc
X  #		a non-ANSI <sys/ioctl.h> -- either run fixincludes on it or use
X  #		-traditional in CFLAGS
X--- 25,33 ----
X  # Systos wants 'pc'; everything else normally wants 'unix'
X  TARG = unix
X  
X+ 
X  # if you are using gcc as your compiler:
X  #	uncomment the CC definition below if it's not in your environment
X  #	if you get setcgtty() warnings during execution, you are feeding gcc
X  #		a non-ANSI <sys/ioctl.h> -- either run fixincludes on it or use
X  #		-traditional in CFLAGS
X***************
X*** 38,46 ****
X--- 37,55 ----
X  # flags for 286 Xenix:
X  # CFLAGS = -Ml2t16 -O -LARGE -I../include
X  # LFLAGS = -Ml -F 4000 -SEG 512
X+ 
X  # flags for 286 Microport SysV-AT
X  # CFLAGS = -DDUMB -Ml -I../include
X  # LFLAGS = -Ml
X+ 
X+ # flags for Atari GCC
X+ # CFLAGS = -mshort -O -I../include
X+ # LFLAGS = -s -mshort
X+ 
X+ # flags for Apollos using their native cc
X+ # (as long as it claims to be __STDC__ but isn't)
X+ # CFLAGS = -DAPOLLO -O -I../include
X+ 
X  # flags for debugging:
X  # CFLAGS = -g -I../include
X  
X***************
X*** 47,59 ****
X--- 56,79 ----
X  CFLAGS = -O -I../include
X  LFLAGS =
X  
X+ 
X  # on some systems the termcap library is in -ltermcap or -lcurses
X  # on 386 Xenix, the -ltermlib tputs() seems not to work; use -lcurses instead
X  # Sysatt uses shared library in lieu of this option
X+ # Systos needs -lcurses16 if you use -mshort
X+ #
X  # TERMLIB = -ltermcap
X  # TERMLIB = -lcurses
X  TERMLIB = -ltermlib
X  
X+ # any other strange libraries your system needs (for Sysunix only -- the more
X+ # specialized targets should already be right)
X+ #
X+ # on HP-UX, the malloc(3x) routines in libmalloc.a seem to align things
X+ # better than the malloc(3) ones in libc.a
X+ # LIBS = -lmalloc
X+ LIBS =
X+ 
X  # yacc/lex programs to use to generate lev_comp.c, lev_comp.h, and lev_lex.c.
X  # if, instead of yacc/lex you have bison/flex, comment/uncomment the following.
X  YACC     = yacc
X***************
X*** 91,98 ****
X  # all .c that are part of the main NetHack program and are not system specific
X  
X  # now the other .c files, with duplicates commented out
X! MAKESRC = makedefs.c panic.c # monst.c objects.c
X! SPLEVSRC = lev_comp.c lev_lex.c lev_main.c # alloc.c monst.c objects.c panic.c
X  TARGSRC = $(TARG)main.c $(TARG)tty.c $(TARG)unix.c
X  
X  CSOURCES = $(HACKCSRC) $(TARGSRC) $(MAKESRC) $(SPLEVSRC)
X--- 111,118 ----
X  # all .c that are part of the main NetHack program and are not system specific
X  
X  # now the other .c files, with duplicates commented out
X! MAKESRC = makedefs.c # monst.c objects.c
X! SPLEVSRC = lev_comp.c lev_lex.c lev_main.c panic.c # alloc.c monst.c objects.c
X  TARGSRC = $(TARG)main.c $(TARG)tty.c $(TARG)unix.c
X  
X  CSOURCES = $(HACKCSRC) $(TARGSRC) $(MAKESRC) $(SPLEVSRC)
X***************
X*** 106,113 ****
X  	   youprop.h
X  
X  # all .h files except date.h, onames.h, pm.h & trap.h which would cause
X! # dependency loops if run through "make depend".
X! # and lev_comp.h, a special level file
X  
X  HSOURCES = $(HACKINCL) date.h onames.h pm.h trap.h lev_comp.h
X  
X--- 126,133 ----
X  	   youprop.h
X  
X  # all .h files except date.h, onames.h, pm.h & trap.h which would cause
X! # dependency loops if run through "make depend"
X! # and lev_comp.h, a special level file.
X  
X  HSOURCES = $(HACKINCL) date.h onames.h pm.h trap.h lev_comp.h
X  
X***************
X*** 114,120 ****
X  SOURCES = $(CSOURCES) $(HSOURCES)
X  
X  # object files for makedefs
X! MAKEOBJS = makedefs.o monst.o objects.o panic.o
X  
X  # object files for special levels compiler
X  SPLEVOBJS = lev_comp.o lev_lex.o lev_main.o alloc.o monst.o objects.o panic.o
X--- 134,140 ----
X  SOURCES = $(CSOURCES) $(HSOURCES)
X  
X  # object files for makedefs
X! MAKEOBJS = makedefs.o monst.o objects.o
X  
X  # object files for special levels compiler
X  SPLEVOBJS = lev_comp.o lev_lex.o lev_main.o alloc.o monst.o objects.o panic.o
X***************
X*** 138,144 ****
X  
X  Sysunix:	$(HOBJ) Makefile
X  	@echo "Loading ..."
X! 	@$(CC) $(LFLAGS) -o $(GAME) $(HOBJ) $(TERMLIB)
X  	@touch Sysunix
X  
X  Sys3B2:	$(HOBJ) Makefile
X--- 158,164 ----
X  
X  Sysunix:	$(HOBJ) Makefile
X  	@echo "Loading ..."
X! 	@$(CC) $(LFLAGS) -o $(GAME) $(HOBJ) $(TERMLIB) $(LIBS)
X  	@touch Sysunix
X  
X  Sys3B2:	$(HOBJ) Makefile
X***************
X*** 151,159 ****
X  	@$(LD) $(LFLAGS) /lib/crt0s.o /lib/shlib.ifile -o $(GAME) $(HOBJ)
X  	@touch Sysatt
X  
X! Systos:	$(HOBJ) oldtos.o Makefile
X  	@echo "Loading ..."
X! 	@$(CC) $(LFLAGS) -o $(GAME) $(HOBJ) oldtos.o $(TERMLIB)
X  	@touch Systos
X  
X  SysV-AT:	DUMB.Setup $(HOBJ) Makefile
X--- 171,179 ----
X  	@$(LD) $(LFLAGS) /lib/crt0s.o /lib/shlib.ifile -o $(GAME) $(HOBJ)
X  	@touch Sysatt
X  
X! Systos:	$(HOBJ) msdos.o Makefile
X  	@echo "Loading ..."
X! 	@$(CC) $(LFLAGS) -o $(GAME) $(HOBJ) msdos.o $(TERMLIB)
X  	@touch Systos
X  
X  SysV-AT:	DUMB.Setup $(HOBJ) Makefile
X***************
X*** 184,198 ****
X  all:	$(GAME)
X  
X  #
X! #	Please note:	The dependency lines for the modules here are
X! #			deliberately incorrect.  Including "hack.h" in
X! #			the dependency list would cause a dependency
X! #			loop.
X  #
X  makedefs:	$(MAKEOBJS)
X  	$(CC) $(LFLAGS) -o makedefs $(MAKEOBJS)
X  
X! makedefs.o:  ../include/config.h ../include/permonst.h
X  
X  lev_comp:  $(SPLEVOBJS)
X  	$(CC) $(LFLAGS) -o lev_comp $(SPLEVOBJS)
X--- 204,215 ----
X  all:	$(GAME)
X  
X  #
X! #	dependencies for auxiliary programs
X  #
X  makedefs:	$(MAKEOBJS)
X  	$(CC) $(LFLAGS) -o makedefs $(MAKEOBJS)
X  
X! makedefs.o:  ../include/config.h ../include/permonst.h ../include/objclass.h ../include/patchlevel.h
X  
X  lev_comp:  $(SPLEVOBJS)
X  	$(CC) $(LFLAGS) -o lev_comp $(SPLEVOBJS)
X***************
X*** 199,207 ****
X  
X  lev_comp.o:  ../include/hack.h ../include/sp_lev.h
X  
X! lev_lex.o:   ../include/lev_comp.h ../include/hack.h ../include/sp_lev.h
X  
X! lev_main.o:  ../include/hack.h ../include/sp_lev.h
X  
X  ../include/lev_comp.h: lev_comp.c
X  
X--- 216,224 ----
X  
X  lev_comp.o:  ../include/hack.h ../include/sp_lev.h
X  
X! lev_lex.o:   ../include/hack.h ../include/lev_comp.h ../include/sp_lev.h
X  
X! lev_main.o:  ../include/hack.h
X  
X  ../include/lev_comp.h: lev_comp.c
X  
X***************
X*** 216,222 ****
X  
X  #
X  #	The following include files depend on makedefs to be created.
X! #	As a result, they are not defined in HACKINCL, instead, their
X  #	dependencies are explicitly outlined here.
X  #
X  
X--- 233,239 ----
X  
X  #
X  #	The following include files depend on makedefs to be created.
X! #	As a result, they are not defined in HACKINCL; instead, their
X  #	dependencies are explicitly outlined here.
X  #
X  
X***************
X*** 230,236 ****
X  ../include/date.h:	$(HACKCSRC) $(TARGSRC) ../include/hack.h makedefs
X  	./makedefs -v
X  
X! ../include/trap.h:	../include/config.h makedefs
X  	./makedefs -t
X  
X  ../include/onames.h:	makedefs
X--- 247,253 ----
X  ../include/date.h:	$(HACKCSRC) $(TARGSRC) ../include/hack.h makedefs
X  	./makedefs -v
X  
X! ../include/trap.h:	makedefs
X  	./makedefs -t
X  
X  ../include/onames.h:	makedefs
X***************
X*** 241,247 ****
X  
X  #
X  #	The following programs vary depending on what OS you are using.
X! #	As a result, they are not defined in HACKSRC, and their dependancies
X  #	are explicitly outlined here.
X  #
X  main.o:	../include/hack.h $(TARG)main.c
X--- 258,264 ----
X  
X  #
X  #	The following programs vary depending on what OS you are using.
X! #	As a result, they are not defined in HACKSRC, and their dependencies
X  #	are explicitly outlined here.
X  #
X  main.o:	../include/hack.h $(TARG)main.c
X***************
X*** 281,289 ****
X  spotless: clean
X  	rm -f a.out core $(GAME) lev_comp makedefs
X  	rm -f ../include/onames.h ../include/pm.h
X- 	touch ../include/onames.h ../include/pm.h
X- 	touch makedefs.c
X- #(make sure files exist and have timestamps in the right order for next compile)
X  
X  
X  depend:
X--- 298,303 ----
X***************
X*** 331,337 ****
X  	@rm -f Makefile.bak
X  
X  # PC dependency for Systos that won't be made on a UNIX system
X! oldtos.o:  ../include/hack.h
X  
X  # DO NOT DELETE THIS LINE
X  
X--- 345,351 ----
X  	@rm -f Makefile.bak
X  
X  # PC dependency for Systos that won't be made on a UNIX system
X! msdos.o:  ../include/hack.h
X  
X  # DO NOT DELETE THIS LINE
X  
X***************
X*** 372,378 ****
X  mkmaze.o:  ../include/hack.h
X  mkobj.o:  ../include/hack.h
X  mkroom.o:  ../include/hack.h
X! mon.o:  ../include/hack.h ../include/mfndpos.h ../include/artifact.h ../include/wseg.h
X  mondata.o:  ../include/hack.h ../include/eshk.h ../include/epri.h
X  monmove.o:  ../include/hack.h ../include/mfndpos.h ../include/artifact.h
X  monst.o:  ../include/config.h ../include/permonst.h ../include/monsym.h ../include/eshk.h ../include/vault.h ../include/epri.h ../include/color.h
X--- 386,392 ----
X  mkmaze.o:  ../include/hack.h
X  mkobj.o:  ../include/hack.h
X  mkroom.o:  ../include/hack.h
X! mon.o:  ../include/hack.h ../include/mfndpos.h ../include/wseg.h
X  mondata.o:  ../include/hack.h ../include/eshk.h ../include/epri.h
X  monmove.o:  ../include/hack.h ../include/mfndpos.h ../include/artifact.h
X  monst.o:  ../include/config.h ../include/permonst.h ../include/monsym.h ../include/eshk.h ../include/vault.h ../include/epri.h ../include/color.h
X***************
X*** 430,438 ****
X  			touch ../include/decl.h
X  ../include/global.h:  ../include/coord.h ../include/vmsconf.h ../include/unixconf.h ../include/pcconf.h ../include/tosconf.h ../include/amiconf.h ../include/macconf.h
X  			touch ../include/global.h
X! ../include/hack.h:  ../include/config.h ../include/decl.h ../include/monsym.h ../include/mkroom.h ../include/objclass.h ../include/gold.h ../include/trap.h ../include/flag.h ../include/rm.h 
X  			touch ../include/hack.h
X! ../include/macconf.h:  ../include/msdos.h ../include/system.h 
X  			touch ../include/macconf.h
X  ../include/pcconf.h:  ../include/msdos.h ../include/system.h
X  			touch ../include/pcconf.h
X--- 444,452 ----
X  			touch ../include/decl.h
X  ../include/global.h:  ../include/coord.h ../include/vmsconf.h ../include/unixconf.h ../include/pcconf.h ../include/tosconf.h ../include/amiconf.h ../include/macconf.h
X  			touch ../include/global.h
X! ../include/hack.h:  ../include/config.h ../include/decl.h ../include/monsym.h ../include/mkroom.h ../include/objclass.h ../include/gold.h ../include/trap.h ../include/flag.h ../include/rm.h  ../include/trampoli.h 
X  			touch ../include/hack.h
X! ../include/macconf.h:  ../include/msdos.h ../include/system.h  ../include/MacAlert.h
X  			touch ../include/macconf.h
X  ../include/pcconf.h:  ../include/msdos.h ../include/system.h
X  			touch ../include/pcconf.h
X*** src/Old/allmain.c	Sun Jun  3 12:48:24 1990
X--- src/allmain.c	Tue Mar 27 20:26:15 1990
X***************
X*** 27,78 ****
X  
X  	for(;;) {
X  #ifdef MACOS
X- 	static	int old_dlevel = 0;
X- 	extern	xchar dlevel; 
X  	extern	Boolean	lowMem;
X  	extern	long	lowMemLimit;
X! 	if (!(moves % 20) || lowMem || FreeMem() < lowMemLimit || old_dlevel != dlevel) {
X! 		old_dlevel = dlevel;
X! 		UnloadSeg(ddocall);
X! 		UnloadSeg(castmu);
X! 		UnloadSeg(doforce);
X! 		UnloadSeg(doeat);
X! 		UnloadSeg(dozap);
X! 		UnloadSeg(initterm);
X! 		UnloadSeg(doapply);
X! 		UnloadSeg(dokick);
X! 		UnloadSeg(outrumor);
X! 		UnloadSeg(steal);
X! 		UnloadSeg(done1);
X! 		UnloadSeg(dodrink);
X! 		UnloadSeg(doturn);
X! #ifdef REINCARNATION
X! 		UnloadSeg(makeroguerooms);
X! #endif
X! #ifdef STRONGHOLD
X! 		UnloadSeg(load_special);
X! #endif
X! 		UnloadSeg(mklev);
X! #ifdef MUSIC
X! 		UnloadSeg(do_play_instrument);
X! #endif
X! #ifdef SPELLS
X! 		UnloadSeg(docast);
X! #endif
X! 		UnloadSeg(savebones);
X! 		UnloadSeg(expels);
X! 		UnloadSeg(attack);
X! 		UnloadSeg(doname);
X! 		if (FreeMem() < 36864)
X! 		{
X! 			long	space;
X! 			
X! 			UnloadSeg(newhp);
X! 			UnloadSeg(attack);
X  
X! 			space = 0x7FFFFFFFL;
X! 			MaxMem(&space);
X! 		}
X  	}
X  #endif
X  #ifdef CLIPPING
X--- 27,38 ----
X  
X  	for(;;) {
X  #ifdef MACOS
X  	extern	Boolean	lowMem;
X  	extern	long	lowMemLimit;
X! 	if (!(moves % 20) || lowMem || FreeMem() < lowMemLimit) {
X! 		long tmp = 0;
X  
X! 		freeSegs(&tmp);
X  	}
X  #endif
X  #ifdef CLIPPING
X*** src/Old/alloc.c	Sun Jun  3 12:48:39 1990
X--- src/alloc.c	Fri Mar 30 20:54:43 1990
X***************
X*** 5,11 ****
X  /* since this file is also used in auxiliary programs, don't include all the 
X   * function declarations for all of nethack
X   */
X! #define EXTERN_H
X  #include "config.h"
X  long *FDECL(alloc,(unsigned int));
X  
X--- 5,11 ----
X  /* since this file is also used in auxiliary programs, don't include all the 
X   * function declarations for all of nethack
X   */
X! #define EXTERN_H	/* comment line for pre-compiled headers */
X  #include "config.h"
X  long *FDECL(alloc,(unsigned int));
X  
X*** src/Old/apply.c	Sun Jun  3 12:48:54 1990
X--- src/apply.c	Sat Jun  2 19:44:47 1990
X***************
X*** 13,21 ****
X  
X  #ifdef OVLB
X  
X! static const char tools[] = { TOOL_SYM, 0 };
X  
X! static boolean did_dig_msg;
X  
X  static struct monst *FDECL(bchit, (int, int, int, CHAR_P));
X  static void FDECL(use_camera, (struct obj *));
X--- 13,21 ----
X  
X  #ifdef OVLB
X  
X! static const char NEARDATA tools[] = { TOOL_SYM, 0 };
X  
X! static boolean NEARDATA did_dig_msg;
X  
X  static struct monst *FDECL(bchit, (int, int, int, CHAR_P));
X  static void FDECL(use_camera, (struct obj *));
X***************
X*** 25,31 ****
X  #ifdef WALKIES
X  static void FDECL(use_leash, (struct obj *));
X  #endif
X! OSTATIC int NDECL(dig);
X  static boolean FDECL(wield_tool, (struct obj *));
X  static int FDECL(use_pick_axe, (struct obj *));
X  #ifdef MEDUSA
X--- 25,31 ----
X  #ifdef WALKIES
X  static void FDECL(use_leash, (struct obj *));
X  #endif
X! STATIC_DCL int NDECL(dig);
X  static boolean FDECL(wield_tool, (struct obj *));
X  static int FDECL(use_pick_axe, (struct obj *));
X  #ifdef MEDUSA
X***************
X*** 353,358 ****
X--- 353,361 ----
X  	return;
X  }
X  
X+ #endif /* OVLB */
X+ #ifdef OVL1
X+ 
X  boolean
X  next_to_u()
X  {
X***************
X*** 377,382 ****
X--- 380,387 ----
X  	return(TRUE);
X  }
X  
X+ #endif /* OVL1 */
X+ #ifdef OVLB
X  struct obj *
X  get_mleash(mtmp) 	/* assuming mtmp->mleashed has been checked */
X  register struct monst *mtmp;
X***************
X*** 391,399 ****
X  	}
X  	return((struct obj *)0);
X  }
X- #endif /* WALKIES */
X  #endif /* OVLB */
X  #ifdef OVL0
X  #ifdef WALKIES
X  void
X  check_leash(x, y)
X--- 396,406 ----
X  	}
X  	return((struct obj *)0);
X  }
X  #endif /* OVLB */
X+ 
X+ #endif /* WALKIES */
X  #ifdef OVL0
X+ 
X  #ifdef WALKIES
X  void
X  check_leash(x, y)
X***************
X*** 446,453 ****
X  #endif /* OVL0 */
X  #ifdef OVLB
X  
X! XSTATIC
X! int
X  dig() {
X  	register struct rm *lev;
X  	register int dpx = dig_pos.x, dpy = dig_pos.y;
X--- 453,459 ----
X  #endif /* OVL0 */
X  #ifdef OVLB
X  
X! STATIC_OVL int
X  dig() {
X  	register struct rm *lev;
X  	register int dpx = dig_pos.x, dpy = dig_pos.y;
X***************
X*** 632,637 ****
X--- 638,646 ----
X  				u.utraptype = 0;
X  			    }
X  			    unsee();
X+ #ifdef MACOS
X+ 			    segments |= SEG_APPLY;
X+ #endif
X  			    goto_level(dlevel+1, FALSE, TRUE);
X  #ifdef WALKIES
X  			}
X***************
X*** 1067,1073 ****
X  	return;
X  }
X  
X! static const char cuddly[] = { TOOL_SYM, 0 };
X  
X  int
X  dorub()
X--- 1076,1082 ----
X  	return;
X  }
X  
X! static const char NEARDATA cuddly[] = { TOOL_SYM, 0 };
X  
X  int
X  dorub()
X***************
X*** 1147,1153 ****
X  use_tinning_kit(obj)
X  register struct obj *obj;
X  {
X! 	register struct obj *corpse, *can;
X  
X  	/* This takes only 1 move.  If this is to be changed to take many
X  	 * moves, we've got to deal with decaying corpses...
X--- 1156,1162 ----
X  use_tinning_kit(obj)
X  register struct obj *obj;
X  {
X! 	register struct obj *corpse, *can = (struct obj *)0;
X  
X  	/* This takes only 1 move.  If this is to be changed to take many
X  	 * moves, we've got to deal with decaying corpses...
X***************
X*** 1172,1189 ****
X  		You("can't tin something that insubstantial!");
X  		return;
X  	}
X! 	can = mksobj(TIN,FALSE);
X! 	can->corpsenm = corpse->corpsenm;
X! 	can->quan = 1; /* Defeat the occasional creation of pairs of tins */
X! 	can->owt = weight(can);
X! 	can->known = 1;
X! 	can->spe = 0; /* No spinach allowed... */
X! 	can->cursed = obj->cursed;
X! 	can->blessed = obj->blessed;
X! 	can = addinv(can);
X! 	You("now have %s.", doname(can));
X! 	if (carried(corpse)) useup(corpse);
X! 	else useupf(corpse);
X  }
X  
X  int
X--- 1181,1199 ----
X  		You("can't tin something that insubstantial!");
X  		return;
X  	}
X! 	if(can = mksobj(TIN,FALSE)) {
X! 	    can->corpsenm = corpse->corpsenm;
X! 	    can->quan = 1; /*Defeat the occasional creation of pairs of tins */
X! 	    can->owt = weight(can);
X! 	    can->known = 1;
X! 	    can->spe = -1; /* Mark tinned tins. No spinach allowed... */
X! 	    can->cursed = obj->cursed;
X! 	    can->blessed = obj->blessed;
X! 	    can = addinv(can);
X! 	    You("now have %s.", doname(can));
X! 	    if (carried(corpse)) useup(corpse);
X! 	    else useupf(corpse);
X! 	} else pline("Tinning failed.");
X  }
X  
X  int
X***************
X*** 1222,1229 ****
X  		make_sick(0L, TRUE);
X  		did_something++;
X  	}
X! 	if (Blinded && (!did_something || blessed)) {
X! 		make_blinded(0L, TRUE);
X  		did_something++;
X  	}
X  	if (Hallucination && (!did_something || blessed)) {
X--- 1232,1239 ----
X  		make_sick(0L, TRUE);
X  		did_something++;
X  	}
X! 	if (Blinded > (long)(u.ucreamed+1) && (!did_something || blessed)) {
X! 		make_blinded(u.ucreamed ? (long)(u.ucreamed+1) : 0L, TRUE);
X  		did_something++;
X  	}
X  	if (Hallucination && (!did_something || blessed)) {
X*** src/Old/artifact.c	Sun Jun  3 12:49:44 1990
X--- src/artifact.c	Sat May 26 21:13:05 1990
X***************
X*** 10,21 ****
X  
X  #ifndef OVLB
X  
X! OSTATIC const struct artifact artilist[];
X  
X  #else /* OVLB */
X  
X  /* the artifacts (currently weapons only) */
X! XSTATIC const struct artifact artilist[] = {
X  
X  #define	    NO_ATTK	{ 0, 0, 0, 0 }
X  
X--- 10,21 ----
X  
X  #ifndef OVLB
X  
X! STATIC_DCL const struct artifact artilist[];
X  
X  #else /* OVLB */
X  
X  /* the artifacts (currently weapons only) */
X! STATIC_OVL const struct artifact NEARDATA artilist[] = {
X  
X  #define	    NO_ATTK	{ 0, 0, 0, 0 }
X  
X***************
X*** 110,117 ****
X  
X  #endif /* OVLB */
X  
X! OSTATIC const struct artifact *FDECL(get_artifact, (struct obj *));
X! OSTATIC int FDECL(spec_applies, (const struct artifact *, struct permonst *));
X  
X  #ifdef OVLB
X  
X--- 110,117 ----
X  
X  #endif /* OVLB */
X  
X! STATIC_DCL const struct artifact *FDECL(get_artifact, (struct obj *));
X! STATIC_DCL int FDECL(spec_applies, (const struct artifact *, struct permonst *));
X  
X  #ifdef OVLB
X  
X***************
X*** 158,164 ****
X  #endif /* OVLB */
X  #ifdef OVL0
X  
X! XSTATIC const struct artifact *
X  get_artifact(otmp)
X  struct obj *otmp;
X  {
X--- 158,164 ----
X  #endif /* OVLB */
X  #ifdef OVL0
X  
X! STATIC_OVL const struct artifact *
X  get_artifact(otmp)
X  struct obj *otmp;
X  {
X***************
X*** 174,180 ****
X  }
X  
X  #endif /* OVL0 */
X! #ifdef OVLB
X  
X  boolean
X  is_artifact(otmp)
X--- 174,180 ----
X  }
X  
X  #endif /* OVL0 */
X! #ifdef OVL2
X  
X  boolean
X  is_artifact(otmp)
X***************
X*** 183,188 ****
X--- 183,190 ----
X  	return(get_artifact(otmp) != (struct artifact *)0);
X  }
X  
X+ #endif /* OVL2 */
X+ #ifdef OVLB
X  boolean
X  exist_artifact(otmp, name)
X  register struct obj *otmp;
X***************
X*** 298,304 ****
X  	return(0);
X  }
X  
X! XSTATIC int
X  spec_applies(weap, ptr)
X  register const struct artifact *weap;
X  struct permonst *ptr;
X--- 300,309 ----
X  	return(0);
X  }
X  
X! #endif /* OVLB */
X! #ifdef OVL1
X! 
X! STATIC_OVL int
X  spec_applies(weap, ptr)
X  register const struct artifact *weap;
X  struct permonst *ptr;
X***************
X*** 327,335 ****
X  	}
X  	return(0);
X  }
X- 
X- #endif /* OVLB */
X- #ifdef OVL1
X  
X  int
X  spec_abon(otmp, ptr)
X--- 332,337 ----
X*** src/Old/attrib.c	Sun Jun  3 12:50:04 1990
X--- src/attrib.c	Fri Apr 13 18:46:30 1990
X***************
X*** 152,158 ****
X  		   {	20, 15, 15, 15, 20, 15 },
X  		     0,  0, 12, 10, 14,  1,  0 };
X  
X! static const struct clattr *NDECL(clx);
X  static void NDECL(init_align);
X  
X  void
X--- 152,158 ----
X  		   {	20, 15, 15, 15, 20, 15 },
X  		     0,  0, 12, 10, 14,  1,  0 };
X  
X! static const struct clattr NEARDATA *NDECL(clx);
X  static void NDECL(init_align);
X  
X  void
X***************
X*** 164,170 ****
X  	if(!incr) return;
X  
X  	if(incr > 0) {
X! 	    if((AMAX(ndx) >= attrmax.a[ndx]) && (ACURR(ndx) == AMAX(ndx))) {
X  
X  		if(!silent && flags.verbose)
X  		    pline("You're already as %s as you can get.",
X--- 164,170 ----
X  	if(!incr) return;
X  
X  	if(incr > 0) {
X! 	    if((AMAX(ndx) >= attrmax.a[ndx]) && (ACURR(ndx) >= AMAX(ndx))) {
X  
X  		if(!silent && flags.verbose)
X  		    pline("You're already as %s as you can get.",
X***************
X*** 255,261 ****
X  
X  	for(otmp = invent; otmp; otmp=otmp->nobj)
X  	    if(otmp->otyp == LUCKSTONE) {
X! 		if (otmp->cursed) bonchance -= otmp->quan;
X  		else if (otmp->blessed) bonchance += otmp->quan;
X  		else if (parameter) bonchance += otmp->quan;
X  	    }
X--- 255,261 ----
X  
X  	for(otmp = invent; otmp; otmp=otmp->nobj)
X  	    if(otmp->otyp == LUCKSTONE) {
X! 		if (otmp->cursed) bonchance -= (int)otmp->quan;
X  		else if (otmp->blessed) bonchance += otmp->quan;
X  		else if (parameter) bonchance += otmp->quan;
X  	    }
X*** src/Old/bones.c	Sun Jun  3 12:50:23 1990
X--- src/bones.c	Tue May 22 20:40:21 1990
X***************
X*** 19,25 ****
X  static void NDECL(compress_bones);
X  #endif
X  static boolean FDECL(no_bones_level, (int));
X! void FDECL(resetobjs,(struct obj *));
X  #ifdef TUTTI_FRUTTI
X  static void FDECL(goodfruit, (int));
X  #endif
X--- 19,25 ----
X  static void NDECL(compress_bones);
X  #endif
X  static boolean FDECL(no_bones_level, (int));
X! static void FDECL(resetobjs,(struct obj *,BOOLEAN_P));
X  #ifdef TUTTI_FRUTTI
X  static void FDECL(goodfruit, (int));
X  #endif
X***************
X*** 78,119 ****
X  }
X  #endif
X  
X! void
X! resetobjs(ochain)
X  struct obj *ochain;
X  {
X  	struct obj *otmp;
X  
X  	for (otmp = ochain; otmp; otmp = otmp->nobj) {
X- 		otmp->o_id = 0;
X  		if (((otmp->otyp != CORPSE && otmp->otyp != STATUE)
X  			|| otmp->corpsenm < PM_ARCHEOLOGIST)
X  #ifdef NAMED_ITEMS
X! 			&& !(is_artifact(otmp) && !exist_artifact(otmp,ONAME(otmp)))
X  #endif
X  		)
X  			otmp->onamelth = 0;
X  #ifdef NAMED_ITEMS
X! 		else if (is_artifact(otmp))
X  			artifact_exists(otmp,ONAME(otmp),TRUE);
X  #endif
X! 		if(objects[otmp->otyp].oc_uses_known) otmp->known = 0;
X  #ifdef TUTTI_FRUTTI
X! 		if(otmp->otyp == SLIME_MOLD) goodfruit(otmp->spe);
X  #endif
X- 		otmp->dknown = otmp->bknown = 0;
X- 		otmp->invlet = 0;
X  #ifdef MAIL
X! 		if (otmp->otyp == SCR_MAIL)
X! 			otmp->spe = 1;
X  #endif
X  #ifdef POLYSELF
X! 		if (otmp->otyp == EGG)
X! 			otmp->spe = 0;
X  #endif
X! 		if(otmp->otyp == AMULET_OF_YENDOR && !otmp->spe) {
X! 			otmp->spe = -1;      /* no longer the actual amulet */
X! 			curse(otmp);
X  		}
X  	}			
X  }
X--- 78,125 ----
X  }
X  #endif
X  
X! static void
X! resetobjs(ochain,restore)
X  struct obj *ochain;
X+ boolean restore;
X  {
X  	struct obj *otmp;
X  
X  	for (otmp = ochain; otmp; otmp = otmp->nobj) {
X  		if (((otmp->otyp != CORPSE && otmp->otyp != STATUE)
X  			|| otmp->corpsenm < PM_ARCHEOLOGIST)
X  #ifdef NAMED_ITEMS
X! 			&& (!is_artifact(otmp) ||
X! 			    (exist_artifact(otmp,ONAME(otmp)) && restore))
X  #endif
X  		)
X  			otmp->onamelth = 0;
X  #ifdef NAMED_ITEMS
X! 		else if (is_artifact(otmp) && restore)
X  			artifact_exists(otmp,ONAME(otmp),TRUE);
X  #endif
X! 		if (!restore) {
X! 			/* resetting the o_id's after getlev has carefully
X! 			 * created proper new ones via restobjchn is a Bad
X! 			 * Idea */
X! 			otmp->o_id = 0;
X! 			if(objects[otmp->otyp].oc_uses_known) otmp->known = 0;
X! 			otmp->dknown = otmp->bknown = 0;
X! 			otmp->invlet = 0;
X  #ifdef TUTTI_FRUTTI
X! 			if(otmp->otyp == SLIME_MOLD) goodfruit(otmp->spe);
X  #endif
X  #ifdef MAIL
X! 			if (otmp->otyp == SCR_MAIL) otmp->spe = 1;
X  #endif
X  #ifdef POLYSELF
X! 			if (otmp->otyp == EGG) otmp->spe = 0;
X  #endif
X! 			if(otmp->otyp == AMULET_OF_YENDOR && !otmp->spe) {
X! 				otmp->spe = -1;
X! 				/* no longer the actual amulet */
X! 				curse(otmp);
X! 			}
X  		}
X  	}			
X  }
X***************
X*** 218,224 ****
X  	mtmp->msleep = 1;
X  	if(u.ugold) mkgold(u.ugold, u.ux, u.uy);
X  	for(mtmp = fmon; mtmp; mtmp = mtmp->nmon){
X! 		resetobjs(mtmp->minvent);
X  		mtmp->m_id = 0;
X  		mtmp->mlstmv = 0L;
X  		if(mtmp->mtame) mtmp->mtame = mtmp->mpeaceful = 0;
X--- 224,230 ----
X  	mtmp->msleep = 1;
X  	if(u.ugold) mkgold(u.ugold, u.ux, u.uy);
X  	for(mtmp = fmon; mtmp; mtmp = mtmp->nmon){
X! 		resetobjs(mtmp->minvent,FALSE);
X  		mtmp->m_id = 0;
X  		mtmp->mlstmv = 0L;
X  		if(mtmp->mtame) mtmp->mtame = mtmp->mpeaceful = 0;
X***************
X*** 227,234 ****
X  	for(ttmp = ftrap; ttmp; ttmp = ttmp->ntrap)
X  		ttmp->tseen = 0;
X  
X! 	resetobjs(fobj);
X! 	resetobjs(fcobj);   /* let's (not) forget about these - KCD, 10/21/89 */
X  
X  	for(x=0; x<COLNO; x++) for(y=0; y<ROWNO; y++)
X  		levl[x][y].seen = levl[x][y].new = levl[x][y].scrsym = 0;
X--- 233,241 ----
X  	for(ttmp = ftrap; ttmp; ttmp = ttmp->ntrap)
X  		ttmp->tseen = 0;
X  
X! 	resetobjs(fobj,FALSE);
X! 	/* let's (not) forget about these - KCD, 10/21/89 */
X! 	resetobjs(fcobj,FALSE);
X  
X  	for(x=0; x<COLNO; x++) for(y=0; y<ROWNO; y++)
X  		levl[x][y].seen = levl[x][y].new = levl[x][y].scrsym = 0;
X***************
X*** 246,252 ****
X  		
X  		t = (term_info *)GetWRefCon(HackWindow);
X  		(void)GetVol(&fileName,&oldvolume);
X! 		(void)SetVol(0L, t->system.sysVRefNum);
X  		fileName[0] = (uchar)strlen(bones);
X  		Strcpy((char *)&fileName[1],bones);
X  		
X--- 253,259 ----
X  		
X  		t = (term_info *)GetWRefCon(HackWindow);
X  		(void)GetVol(&fileName,&oldvolume);
X! 		(void)SetVol(0L, t->recordVRefNum);
X  		fileName[0] = (uchar)strlen(bones);
X  		Strcpy((char *)&fileName[1],bones);
X  		
X***************
X*** 300,305 ****
X--- 307,332 ----
X  	bflush(fd);
X  #endif
X  	(void) close(fd);
X+ #ifdef MACOS
X+ 	{
X+ 		FInfo	fndrInfo;
X+ 		Str255	name;
X+ 		term_info	*t;
X+ 		short	oldVol, error;
X+ 		
X+ 		t = (term_info *)GetWRefCon(HackWindow);
X+ 		GetVol(name, &oldVol);
X+ 		SetVol(0L, t->recordVRefNum);  
X+ 		Strcpy((char *)name, bones);
X+ 		CtoPstr((char *)name);
X+ 		error = GetFInfo(name, (short)0, &fndrInfo);
X+ 		fndrInfo.fdCreator = CREATOR;
X+ 		fndrInfo.fdType = BONES_TYPE;
X+ 		if (error == noErr)
X+ 			SetFInfo(name, (short)0, &fndrInfo);
X+ 		SetVol(0L, oldVol);
X+ 	}
X+ #endif
X  #ifdef COMPRESS
X  	compress_bones();
X  #endif
X***************
X*** 309,315 ****
X  getbones() {
X  	register int fd;
X  	register int ok;
X! 
X  #ifdef EXPLORE_MODE
X  	if(discover)		/* save bones files for real games */
X  		return(0);
X--- 336,349 ----
X  getbones() {
X  	register int fd;
X  	register int ok;
X! #ifdef MACOS
X! 	Str255	name;
X! 	short	oldVol;
X! 	term_info *t;
X! 	extern WindowPtr	HackWindow;
X! 	
X! 	t = (term_info *)GetWRefCon(HackWindow);
X! #endif
X  #ifdef EXPLORE_MODE
X  	if(discover)		/* save bones files for real games */
X  		return(0);
X***************
X*** 322,327 ****
X--- 356,365 ----
X  		) return(0);
X  	if(no_bones_level(dlevel)) return(0);
X  	name_file(bones, dlevel);
X+ #ifdef MACOS
X+ 	GetVol(name, &oldVol);
X+ 	SetVol(0L, t->recordVRefNum);
X+ #endif
X  #ifdef COMPRESS
X  	if((fd = open(bones, OMASK)) >= 0) goto gotbones;
X  	Strcpy(proxy, bones);
X***************
X*** 339,345 ****
X  	    (void) system(cmd);
X  	}
X  #endif
X! 	if((fd = open(bones, OMASK)) < 0) return(0);
X  #ifdef COMPRESS
X  gotbones:
X  #endif
X--- 377,391 ----
X  	    (void) system(cmd);
X  	}
X  #endif
X! 	if((fd = open(bones, OMASK)) < 0) {
X! #ifdef MACOS
X! 		SetVol(0L, oldVol);
X! #endif
X! 		return(0);
X! 	}
X! #ifdef MACOS
X! 	SetVol(0L, oldVol);
X! #endif
X  #ifdef COMPRESS
X  gotbones:
X  #endif
X***************
X*** 368,376 ****
X  		register struct monst *mtmp;
X  
X  		for(mtmp = fmon; mtmp; mtmp = mtmp->nmon)
X! 			resetobjs(mtmp->minvent);
X! 		resetobjs(fobj);
X! 		resetobjs(fcobj);
X  	}
X  #endif
X  #ifdef WIZARD
X--- 414,422 ----
X  		register struct monst *mtmp;
X  
X  		for(mtmp = fmon; mtmp; mtmp = mtmp->nmon)
X! 			resetobjs(mtmp->minvent,TRUE);
X! 		resetobjs(fobj,TRUE);
X! 		resetobjs(fcobj,TRUE);
X  	}
X  #endif
X  #ifdef WIZARD
X***************
X*** 384,393 ****
X--- 430,449 ----
X  		}
X  	}
X  #endif
X+ #ifdef MACOS
X+ 	GetVol(name, &oldVol);
X+ 	SetVol(0L, t->recordVRefNum);
X+ #endif
X  	if(unlink(bones) < 0){
X  		pline("Cannot unlink %s.", bones);
X+ #ifdef MACOS
X+ 		SetVol(0L, oldVol);
X+ #endif
X  		return(0);
X  	}
X+ #ifdef MACOS
X+ 	SetVol(0L, oldVol);
X+ #endif
X  	return(ok);
X  }
X  
X*** src/Old/cmd.c	Sun Jun  3 12:50:45 1990
X--- src/cmd.c	Thu May 31 22:10:37 1990
X***************
X*** 83,115 ****
X  
X  #endif /* OVL1 */
X  
X! #ifndef OVERLAY
X! static int NDECL(timed_occupation);
X! static int NDECL(doextcmd);
X  # ifdef POLYSELF
X! static int NDECL(domonability);
X  # endif
X  # ifdef WIZARD
X! static int NDECL(wiz_wish);
X! static int NDECL(wiz_identify);
X! static int NDECL(wiz_map);
X! static int NDECL(wiz_genesis);
X! static int NDECL(wiz_where);
X! static int NDECL(wiz_detect);
X! static int NDECL(wiz_level_tele);
X  # endif
X  # ifdef EXPLORE_MODE
X! static int NDECL(enter_explore_mode);
X  # endif
X  # if defined(WIZARD) || defined(EXPLORE_MODE)
X! static int NDECL(wiz_attributes);
X  # endif
X- #endif /* OVERLAY */
X  
X- #ifdef REDO
X- static char NDECL(popch);
X- #endif
X- 
X  #ifdef STUPID_CPP
X  static char FDECL(unctrl, (CHAR_P));
X  static char FDECL(unmeta, (CHAR_P));
X--- 83,109 ----
X  
X  #endif /* OVL1 */
X  
X! STATIC_PTR int NDECL(timed_occupation);
X! STATIC_PTR int NDECL(doextcmd);
X  # ifdef POLYSELF
X! STATIC_PTR int NDECL(domonability);
X  # endif
X  # ifdef WIZARD
X! STATIC_PTR int NDECL(wiz_wish);
X! STATIC_PTR int NDECL(wiz_identify);
X! STATIC_PTR int NDECL(wiz_map);
X! STATIC_PTR int NDECL(wiz_genesis);
X! STATIC_PTR int NDECL(wiz_where);
X! STATIC_PTR int NDECL(wiz_detect);
X! STATIC_PTR int NDECL(wiz_level_tele);
X  # endif
X  # ifdef EXPLORE_MODE
X! STATIC_PTR int NDECL(enter_explore_mode);
X  # endif
X  # if defined(WIZARD) || defined(EXPLORE_MODE)
X! STATIC_PTR int NDECL(wiz_attributes);
X  # endif
X  
X  #ifdef STUPID_CPP
X  static char FDECL(unctrl, (CHAR_P));
X  static char FDECL(unmeta, (CHAR_P));
X***************
X*** 118,127 ****
X  #ifdef OVL1
X  
X  /* Count down by decrementing multi */
X! #ifndef OVERLAY
X! static 
X! #endif
X! int
X  timed_occupation() {
X  	(*timed_occ_fn)();
X  	if (multi > 0)
X--- 112,118 ----
X  #ifdef OVL1
X  
X  /* Count down by decrementing multi */
X! STATIC_PTR int
X  timed_occupation() {
X  	(*timed_occ_fn)();
X  	if (multi > 0)
X***************
X*** 169,174 ****
X--- 160,168 ----
X  }
X  
X  #ifdef REDO
X+ 
X+ static char NDECL(popch);
X+ 
X  /* Provide a means to redo the last command.  The flag `in_doagain' is set
X   * to true while redoing the command.  This flag is tested in commands that
X   * require additional input (like `throw' which requires a thing and a
X***************
X*** 177,183 ****
X   */
X  #define BSIZE 20
X  static char pushq[BSIZE], saveq[BSIZE];
X! static int phead, ptail, shead, stail;
X  
X  static char
X  popch() {
X--- 171,177 ----
X   */
X  #define BSIZE 20
X  static char pushq[BSIZE], saveq[BSIZE];
X! static int NEARDATA phead, NEARDATA ptail, NEARDATA shead, NEARDATA stail;
X  
X  static char
X  popch() {
X***************
X*** 232,241 ****
X  #endif /* OVL1 */
X  #ifdef OVLB
X  
X! #ifndef OVERLAY
X! static 
X! #endif
X! int
X  doextcmd()	/* here after # - now read a full-word command */
X  {
X  	char buf[BUFSZ];
X--- 226,232 ----
X  #endif /* OVL1 */
X  #ifdef OVLB
X  
X! STATIC_PTR int
X  doextcmd()	/* here after # - now read a full-word command */
X  {
X  	char buf[BUFSZ];
X***************
X*** 290,299 ****
X  }
X  
X  #ifdef POLYSELF
X! #ifndef OVERLAY
X! static 
X! #endif
X! int
X  domonability()
X  {
X  	if (can_breathe(uasmon)) return dobreathe();
X--- 281,287 ----
X  }
X  
X  #ifdef POLYSELF
X! STATIC_PTR int
X  domonability()
X  {
X  	if (can_breathe(uasmon)) return dobreathe();
X***************
X*** 312,321 ****
X  #endif
X  
X  #ifdef EXPLORE_MODE
X! #ifndef OVERLAY
X! static 
X! #endif
X! int
X  enter_explore_mode()
X  {
X  	if(!discover && !wizard) {
X--- 300,306 ----
X  #endif
X  
X  #ifdef EXPLORE_MODE
X! STATIC_PTR int
X  enter_explore_mode()
X  {
X  	if(!discover && !wizard) {
X***************
X*** 342,351 ****
X  #endif
X  
X  #ifdef WIZARD
X! #ifndef OVERLAY
X! static 
X! #endif
X! int
X  wiz_wish()	/* Unlimited wishes for wizard mode by Paul Polderman */
X  {
X  	if (wizard)	makewish();
X--- 327,333 ----
X  #endif
X  
X  #ifdef WIZARD
X! STATIC_PTR int
X  wiz_wish()	/* Unlimited wishes for wizard mode by Paul Polderman */
X  {
X  	if (wizard)	makewish();
X***************
X*** 353,362 ****
X  	return 0;
X  }
X  
X! #ifndef OVERLAY
X! static 
X! #endif
X! int
X  wiz_identify()
X  {
X  	struct obj *obj;
X--- 335,341 ----
X  	return 0;
X  }
X  
X! STATIC_PTR int
X  wiz_identify()
X  {
X  	struct obj *obj;
X***************
X*** 372,381 ****
X  	return 0;
X  }
X  
X! #ifndef OVERLAY
X! static 
X! #endif
X! int
X  wiz_map()
X  {
X  	if (wizard)	do_mapping();
X--- 351,357 ----
X  	return 0;
X  }
X  
X! STATIC_PTR int
X  wiz_map()
X  {
X  	if (wizard)	do_mapping();
X***************
X*** 383,392 ****
X  	return 0;
X  }
X  
X! #ifndef OVERLAY
X! static 
X! #endif
X! int
X  wiz_genesis()
X  {
X  	if (wizard)	(void) create_particular();
X--- 359,365 ----
X  	return 0;
X  }
X  
X! STATIC_PTR int
X  wiz_genesis()
X  {
X  	if (wizard)	(void) create_particular();
X***************
X*** 394,403 ****
X  	return 0;
X  }
X  
X! #ifndef OVERLAY
X! static 
X! #endif
X! int
X  wiz_where()
X  {
X  	if (wizard) {
X--- 367,373 ----
X  	return 0;
X  }
X  
X! STATIC_PTR int
X  wiz_where()
X  {
X  	if (wizard) {
X***************
X*** 422,431 ****
X  	return 0;
X  }
X  
X! #ifndef OVERLAY
X! static 
X! #endif
X! int
X  wiz_detect()
X  {
X  	if(wizard)  (void) findit();
X--- 392,398 ----
X  	return 0;
X  }
X  
X! STATIC_PTR int
X  wiz_detect()
X  {
X  	if(wizard)  (void) findit();
X***************
X*** 433,442 ****
X  	return 0;
X  }
X  
X! #ifndef OVERLAY
X! static 
X! #endif
X! int
X  wiz_level_tele()
X  {
X  	if (wizard)	level_tele();
X--- 400,406 ----
X  	return 0;
X  }
X  
X! STATIC_PTR int
X  wiz_level_tele()
X  {
X  	if (wizard)	level_tele();
X***************
X*** 484,491 ****
X--- 448,457 ----
X  	if (Protection) cornline(1, "You are protected.");
X  	if (Warning) cornline(1, "You are warned.");
X  	if (Teleport_control) cornline(1, "You have teleport control.");
X+ #ifdef POLYSELF
X  	if (Polymorph) cornline(1, "You are polymorphing.");
X  	if (Polymorph_control) cornline(1, "You have polymorph control.");
X+ #endif
X  	if (Telepat) cornline(1, "You are telepathic.");
X  	if (Fast) cornline(1, "You are fast.");
X  	/* if (Stunned) cornline(1, "You are stunned."); */
X***************
X*** 535,544 ****
X  }
X  
X  #if defined(WIZARD) || defined(EXPLORE_MODE)
X! #ifndef OVERLAY
X! static 
X! #endif
X! int
X  wiz_attributes()
X  {
X  	if (wizard || discover)
X--- 501,507 ----
X  }
X  
X  #if defined(WIZARD) || defined(EXPLORE_MODE)
X! STATIC_PTR int
X  wiz_attributes()
X  {
X  	if (wizard || discover)
X***************
X*** 860,869 ****
X  }
X  
X  /* 'rogue'-like direction commands */
X! const char sdir[] = "hykulnjb><";
X! const char ndir[] = "47896321><";
X! const schar xdir[10] = { -1,-1, 0, 1, 1, 1, 0,-1, 0, 0 };
X! const schar ydir[10] = {  0,-1,-1,-1, 0, 1, 1, 1, 0, 0 };
X  const schar zdir[10] = {  0, 0, 0, 0, 0, 0, 0, 0, 1,-1 };
X  
X  #ifdef WALKIES
X--- 823,832 ----
X  }
X  
X  /* 'rogue'-like direction commands */
X! const char NEARDATA sdir[] = "hykulnjb><";
X! const char NEARDATA ndir[] = "47896321><";
X! const schar NEARDATA xdir[10] = { -1,-1, 0, 1, 1, 1, 0,-1, 0, 0 };
X! const schar NEARDATA ydir[10] = {  0,-1,-1,-1, 0, 1, 1, 1, 0, 0 };
X  const schar zdir[10] = {  0, 0, 0, 0, 0, 0, 0, 0, 1,-1 };
X  
X  #ifdef WALKIES
X***************
X*** 911,919 ****
X  	return !u.dz;
X  }
X  
X- #endif /* OVL1 */
X- #ifdef OVLB
X- 
X  int
X  getdir(s)
X  boolean s;
X--- 874,879 ----
X***************
X*** 938,943 ****
X--- 898,906 ----
X  	if(!u.dz && (Stunned || (Confusion && !rn2(5)))) confdir();
X  	return 1;
X  }
X+ 
X+ #endif /* OVL1 */
X+ #ifdef OVLB
X  
X  void
X  confdir()
X*** src/Old/dbridge.c	Sun Jun  3 12:51:22 1990
X--- src/dbridge.c	Thu May 31 22:10:40 1990
X***************
X*** 13,18 ****
X--- 13,19 ----
X  #include "hack.h"
X  
X  #ifdef STRONGHOLD
X+ # ifdef OVLB
X  static void FDECL(redosym, (int, int));
X  static void FDECL(get_wall_for_db, (int *, int *));
X  static struct entity *FDECL(e_at, (int, int));
X***************
X*** 28,34 ****
X  static boolean FDECL(e_missed, (struct entity *, BOOLEAN_P));
X  static boolean FDECL(e_jumps, (struct entity *));
X  static void FDECL(do_entity, (struct entity *));
X! #endif
X  
X  #ifdef OVL0
X  
X--- 29,36 ----
X  static boolean FDECL(e_missed, (struct entity *, BOOLEAN_P));
X  static boolean FDECL(e_jumps, (struct entity *));
X  static void FDECL(do_entity, (struct entity *));
X! # endif /* OVLB */
X! #endif /* STRONGHOLD */
X  
X  #ifdef OVL0
X  
X***************
X*** 63,68 ****
X--- 65,73 ----
X  	crm->seen = oldseen;
X  }
X  
X+ #endif /* OVL1 */
X+ #ifdef OVLB
X+ 
X  static void
X  redosym(x,y)
X  int x,y;
X***************
X*** 76,81 ****
X--- 81,89 ----
X  	}
X  }
X  
X+ #endif /* OVLB */
X+ #ifdef OVL1
X+ 
X  /* 
X   * We want to know whether a wall (or a door) is the portcullis (passageway)
X   * of an eventual drawbridge.
X***************
X*** 113,121 ****
X  	return (-1);
X  }
X  
X- #endif /* OVL1 */
X- #ifdef OVL1
X- 
X  /*
X   * Use is_db_wall where you want to verify that a
X   * drawbridge "wall" is UP in the location x, y
X--- 121,126 ----
X***************
X*** 129,136 ****
X  		levl[x][y].diggable & W_GATEWAY);
X  }
X  
X- #endif /* OVL1 */
X- #ifdef OVLB
X  
X  /*
X   * Return true with x,y pointing to the drawbridge if x,y initially indicate
X--- 134,139 ----
X***************
X*** 157,162 ****
X--- 160,168 ----
X  	return FALSE;
X  }
X  
X+ #endif /* OVL1 */
X+ #ifdef OVLB
X+ 
X  /* 
X   * Find the drawbridge wall associated with a drawbridge.
X   */
X***************
X*** 234,240 ****
X  
X  #define ENTITIES 2
X  
X! static struct entity occupants[ENTITIES];
X  
X  static
X  struct entity *
X--- 240,246 ----
X  
X  #define ENTITIES 2
X  
X! static struct entity NEARDATA occupants[ENTITIES];
X  
X  static
X  struct entity *
X***************
X*** 414,425 ****
X  		else {
X  			coord xy;
X  
X  			done(how);
X  			/* So, you didn't die */
X  			if (!e_survives_at(etmp, etmp->ex, etmp->ey)) {
X  				pline("A %s force teleports you away...",
X  		      		      Hallucination ? "normal" : "strange");
X! 				enexto(&xy, etmp->ex, etmp->ey, etmp->edata);
X  				teleds(xy.x, xy.y);
X  			}
X  		}
X--- 420,434 ----
X  		else {
X  			coord xy;
X  
X+ 			killer_format = KILLED_BY_AN;
X+ 			killer = "falling drawbridge";
X  			done(how);
X  			/* So, you didn't die */
X  			if (!e_survives_at(etmp, etmp->ex, etmp->ey)) {
X  				pline("A %s force teleports you away...",
X  		      		      Hallucination ? "normal" : "strange");
X! 				(void) enexto(&xy, etmp->ex, etmp->ey,
X! 								etmp->edata);
X  				teleds(xy.x, xy.y);
X  			}
X  		}
X***************
X*** 876,883 ****
X  	lev2->typ = DOOR;
X  	lev2->doormask = D_NODOOR;
X  	set_entity(x, y, etmp1);
X- 	e_inview = e_boolean(etmp1, canseemon);
X  	if (etmp1->edata) {
X  		if (e_missed(etmp1, TRUE)) {
X  #ifdef D_DEBUG
X  			pline("%s spared!", E_phrase(etmp1, "are"));
X--- 885,892 ----
X  	lev2->typ = DOOR;
X  	lev2->doormask = D_NODOOR;
X  	set_entity(x, y, etmp1);
X  	if (etmp1->edata) {
X+ 		e_inview = e_boolean(etmp1, canseemon);
X  		if (e_missed(etmp1, TRUE)) {
X  #ifdef D_DEBUG
X  			pline("%s spared!", E_phrase(etmp1, "are"));
X*** src/Old/decl.c	Sun Jun  3 12:51:53 1990
X--- src/decl.c	Mon Mar 12 18:49:33 1990
X***************
X*** 4,18 ****
X  
X  #include	"hack.h"
X  
X! int multi = 0;
X! int warnlevel = 0;		/* used by movemon and dochugw */
X! int nroom = 0;
X! int occtime = 0;
X  
X  int x_maze_max, y_maze_max;	/* initialized in main, used in mkmaze.c */
X  
X  #ifdef REDO
X! int in_doagain = 0;
X  #endif
X  
X  /*
X--- 4,18 ----
X  
X  #include	"hack.h"
X  
X! int NEARDATA multi = 0;
X! int NEARDATA warnlevel = 0;		/* used by movemon and dochugw */
X! int NEARDATA nroom = 0;
X! int NEARDATA occtime = 0;
X  
X  int x_maze_max, y_maze_max;	/* initialized in main, used in mkmaze.c */
X  
X  #ifdef REDO
X! int NEARDATA in_doagain = 0;
X  #endif
X  
X  /*
X***************
X*** 21,63 ****
X   */
X  
X   int
X! 	medusa_level = 0,	/* level that the medusa lives on */
X! 	bigroom_level = 0,	/* level consisting of a single big room */
X  #ifdef REINCARNATION
X! 	rogue_level = 0,	/* level near which rogue level gen'd */
X  #endif
X  #ifdef ORACLE
X! 	oracle_level = 0,	/* level near which Oracle gen'd */
X  #endif
X  #ifdef STRONGHOLD
X! 	stronghold_level = 3,	/* level the castle is on */
X  	/* Not 0, otherwise they start the game in Hell and burn immediately */
X! 	tower_level = 0,	/* level of the top of Vlad's 3-level tower */
X  #endif
X! 	wiz_level = 0;		/* level that the wiz lives on */
X! boolean is_maze_lev = FALSE;    /* if this is a maze level */
X  
X! int smeq[MAXNROFROOMS+1] = DUMMY;
X! int doorindex = 0;
X! 
X! char *save_cm = 0;
X! int killer_format = 0;
X! const char *killer = 0;
X! const char *nomovemsg = 0;
X! const char nul[40] = DUMMY;		/* contains zeros */
X! char plname[PL_NSIZ] = DUMMY;		/* player name */
X! char pl_character[PL_CSIZ] = DUMMY;
X  
X  #ifdef TUTTI_FRUTTI
X! char pl_fruit[PL_FSIZ] = DUMMY;
X! int current_fruit = 0;
X! struct fruit *ffruit = 0;
X  #endif
X  
X  #ifdef STRONGHOLD
X! char tune[6] = DUMMY;
X  #  ifdef MUSIC
X! schar music_heard = 0;
X  #  endif
X  #endif
X  
X--- 21,63 ----
X   */
X  
X   int
X! 	NEARDATA medusa_level = 0,	/* level that the medusa lives on */
X! 	NEARDATA bigroom_level = 0,	/* level consisting of a single big room */
X  #ifdef REINCARNATION
X! 	NEARDATA rogue_level = 0,	/* level near which rogue level gen'd */
X  #endif
X  #ifdef ORACLE
X! 	NEARDATA oracle_level = 0,	/* level near which Oracle gen'd */
X  #endif
X  #ifdef STRONGHOLD
X! 	NEARDATA stronghold_level = 3,	/* level the castle is on */
X  	/* Not 0, otherwise they start the game in Hell and burn immediately */
X! 	NEARDATA tower_level = 0,	/* level of the top of Vlad's 3-level tower */
X  #endif
X! 	NEARDATA wiz_level = 0;		/* level that the wiz lives on */
X! boolean NEARDATA is_maze_lev = FALSE;    /* if this is a maze level */
X  
X! int NEARDATA smeq[MAXNROFROOMS+1] = DUMMY;
X! int NEARDATA doorindex = 0;
X! 
X! char NEARDATA *save_cm = 0;
X! int NEARDATA killer_format = 0;
X! const char NEARDATA *killer = 0;
X! const char NEARDATA *nomovemsg = 0;
X! const char NEARDATA nul[40] = DUMMY;		/* contains zeros */
X! char NEARDATA plname[PL_NSIZ] = DUMMY;		/* player name */
X! char NEARDATA pl_character[PL_CSIZ] = DUMMY;
X  
X  #ifdef TUTTI_FRUTTI
X! char NEARDATA pl_fruit[PL_FSIZ] = DUMMY;
X! int NEARDATA current_fruit = 0;
X! struct fruit NEARDATA *ffruit = 0;
X  #endif
X  
X  #ifdef STRONGHOLD
X! char NEARDATA tune[6] = DUMMY;
X  #  ifdef MUSIC
X! schar NEARDATA music_heard = 0;
X  #  endif
X  #endif
X  
X***************
X*** 64,77 ****
X  #ifdef SMALLDATA
X  const char *occtxt = 0;
X  #else
X! const char *occtxt = DUMMY;
X  #endif
X! const char quitchars[] = " \r\n\033";
X! const char vowels[] = "aeiouAEIOU";
X! const char ynchars[] = "yn";
X! const char ynqchars[] = "ynq";
X! const char ynaqchars[] = "ynaq";
X! const char nyaqchars[] = "nyaq";
X  
X  #ifdef SMALLDATA
X  char *HI = 0, *HE = 0, *AS = 0, *AE = 0, *CD = 0;
X--- 64,77 ----
X  #ifdef SMALLDATA
X  const char *occtxt = 0;
X  #else
X! const char NEARDATA *occtxt = DUMMY;
X  #endif
X! const char NEARDATA quitchars[] = " \r\n\033";
X! const char NEARDATA vowels[] = "aeiouAEIOU";
X! const char NEARDATA ynchars[] = "yn";
X! const char NEARDATA ynqchars[] = "ynq";
X! const char NEARDATA ynaqchars[] = "ynaq";
X! const char NEARDATA nyaqchars[] = "nyaq";
X  
X  #ifdef SMALLDATA
X  char *HI = 0, *HE = 0, *AS = 0, *AE = 0, *CD = 0;
X***************
X*** 83,90 ****
X  int CO = 0, LI = 0;	/* set up in termcap.c: usually COLNO and ROWNO+3 */
X  
X  #ifdef CLIPPING
X! boolean clipping;	/* clipping on? */
X! int clipx, clipy, clipxmax, clipymax;
X  #endif
X  
X  #ifdef TEXTCOLOR
X--- 83,90 ----
X  int CO = 0, LI = 0;	/* set up in termcap.c: usually COLNO and ROWNO+3 */
X  
X  #ifdef CLIPPING
X! boolean clipping = FALSE;	/* clipping on? */
X! int clipx = 0, clipy = 0, clipxmax = 0, clipymax = 0;
X  #endif
X  
X  #ifdef TEXTCOLOR
X***************
X*** 91,97 ****
X  # ifdef TOS
X  const char *hilites[MAXCOLORS];	/* terminal escapes for the various colors */
X  # else
X! char *hilites[MAXCOLORS];	/* terminal escapes for the various colors */
X  # endif
X  #endif
X  #ifdef MSDOS
X--- 91,97 ----
X  # ifdef TOS
X  const char *hilites[MAXCOLORS];	/* terminal escapes for the various colors */
X  # else
X! char NEARDATA *hilites[MAXCOLORS]; /* terminal escapes for the various colors */
X  # endif
X  #endif
X  #ifdef MSDOS
X***************
X*** 115,169 ****
X  # endif
X  #endif
X  
X! int dig_effort = 0;	/* effort expended on current pos */
X! uchar dig_level = 0;
X! coord dig_pos = DUMMY;
X! boolean dig_down = FALSE;
X  
X! xchar dlevel = 1;
X! xchar maxdlevel = 1;
X! int done_stopprint = 0;
X! int done_hup = 0;
X! xchar xupstair = 0, yupstair = 0, xdnstair = 0, ydnstair = 0;
X  #ifdef STRONGHOLD
X! xchar xupladder = 0, yupladder = 0, xdnladder = 0, ydnladder = 0;
X  #endif
X! xchar curx = 0, cury = 0;
X! xchar seelx = 0, seehx = 0, seely = 0, seehy = 0; /* corners of lit room */
X! xchar seelx2 = 0, seehx2 = 0, seely2 = 0, seehy2 = 0; /* corners of lit room */
X! xchar scrlx = 0, scrhx = 0, scrly = 0, scrhy = 0; /* corners of new scr. area*/
X! xchar fountsound = 0;
X! xchar sinksound = 0; /* numbers of other things that make noise */
X! 
X! boolean in_mklev = FALSE;
X! boolean	stoned = FALSE;			/* done to monsters hit by 'c' */
X! boolean	unweapon = FALSE;
X! boolean mrg_to_wielded = FALSE; /* weapon picked is merged with wielded one */
X  
X  #ifdef KOPS
X! boolean allow_kops = TRUE;
X  #endif
X  
X! coord bhitpos = DUMMY;
X! coord doors[DOORMAX] = DUMMY;
X  
X! struct mkroom rooms[MAXNROFROOMS+1] = DUMMY;
X  dlevel_t level;		/* level map */
X  struct trap *ftrap = 0;
X  struct gold *fgold = 0;
X! struct monst youmonst = DUMMY;	/* dummy; used as return value for boomhit */
X! struct flag flags = DUMMY;
X! struct you u = DUMMY;
X  
X! struct obj *fcobj = 0, *invent = 0, *uwep = 0, *uarm = 0,
X  #ifdef SHIRT
X! 	*uarmu = 0,		/* under-wear, so to speak */
X  #endif
X  #ifdef POLYSELF
X! 	*uskin = 0,		/* dragon armor, if a dragon */
X  #endif
X! 	*uarmc = 0, *uarmh = 0, *uarms = 0, *uarmg = 0, *uarmf = 0, *uamul = 0,
X! 	*uright = 0, *uleft = 0, *ublindf = 0, *uchain = 0, *uball = 0;
X  
X  symbol_array defsyms = {
X      ' ', /* stone */
X--- 115,178 ----
X  # endif
X  #endif
X  
X! int NEARDATA dig_effort = 0;	/* effort expended on current pos */
X! uchar NEARDATA dig_level = 0;
X! coord NEARDATA dig_pos = DUMMY;
X! boolean NEARDATA dig_down = FALSE;
X  
X! xchar NEARDATA dlevel = 1;
X! xchar NEARDATA maxdlevel = 1;
X! int NEARDATA done_stopprint = 0;
X! int NEARDATA done_hup = 0;
X! xchar NEARDATA xupstair = 0, NEARDATA yupstair = 0, 
X! 	NEARDATA xdnstair = 0, NEARDATA ydnstair = 0;
X  #ifdef STRONGHOLD
X! xchar NEARDATA xupladder = 0, NEARDATA yupladder = 0,
X! 	NEARDATA xdnladder = 0, NEARDATA ydnladder = 0;
X  #endif
X! xchar NEARDATA curx = 0, NEARDATA cury = 0;
X! xchar NEARDATA seelx = 0, NEARDATA seehx = 0, NEARDATA seely = 0,
X! 	NEARDATA seehy = 0; /* corners of lit room */
X! xchar NEARDATA seelx2 = 0, NEARDATA seehx2 = 0, NEARDATA seely2 = 0,
X! 	NEARDATA  seehy2 = 0; /* corners of lit room */
X! xchar NEARDATA scrlx = 0, NEARDATA scrhx = 0, NEARDATA scrly = 0,
X! 	NEARDATA scrhy = 0; /* corners of new scr. area*/
X! xchar NEARDATA fountsound = 0;
X! xchar NEARDATA sinksound = 0; /* numbers of other things that make noise */
X! 
X! boolean NEARDATA in_mklev = FALSE;
X! boolean	NEARDATA stoned = FALSE;	/* done to monsters hit by 'c' */
X! boolean	NEARDATA unweapon = FALSE;
X! boolean NEARDATA mrg_to_wielded = FALSE;
X! 			 /* weapon picked is merged with wielded one */
X  
X  #ifdef KOPS
X! boolean NEARDATA allow_kops = TRUE;
X  #endif
X  
X! coord NEARDATA bhitpos = DUMMY;
X! coord NEARDATA doors[DOORMAX] = DUMMY;
X  
X! struct mkroom NEARDATA rooms[MAXNROFROOMS+1] = DUMMY;
X  dlevel_t level;		/* level map */
X  struct trap *ftrap = 0;
X  struct gold *fgold = 0;
X! struct monst NEARDATA youmonst = DUMMY;	/* dummy; used as return value for boomhit */
X! struct flag NEARDATA flags = DUMMY;
X! struct you NEARDATA u = DUMMY;
X  
X! struct obj NEARDATA *fcobj = 0, NEARDATA *invent = 0, NEARDATA *uwep = 0,
X! 	NEARDATA *uarm = 0,
X  #ifdef SHIRT
X! 	NEARDATA *uarmu = 0,		/* under-wear, so to speak */
X  #endif
X  #ifdef POLYSELF
X! 	NEARDATA *uskin = 0,		/* dragon armor, if a dragon */
X  #endif
X! 	NEARDATA *uarmc = 0, NEARDATA *uarmh = 0, NEARDATA *uarms = 0,
X! 	NEARDATA *uarmg = 0, NEARDATA *uarmf = 0, NEARDATA *uamul = 0,
X! 	NEARDATA *uright = 0, NEARDATA *uleft = 0, NEARDATA *ublindf = 0,
X! 	NEARDATA *uchain = 0, NEARDATA *uball = 0;
X  
X  symbol_array defsyms = {
X      ' ', /* stone */
X***************
X*** 245,257 ****
X  };
X  
X  #ifdef SPELLS
X! struct spell spl_book[MAXSPELL + 1] = DUMMY;
X  #endif
X  
X! long moves = 1, monstermoves = 1; /* These diverge when player is Fast */
X! long wailmsg = 0;
X  
X! struct obj zeroobj = DUMMY;	/* used to zero all elements of a struct obj */
X  
X  struct obj *billobjs = 0;
X  
X--- 254,267 ----
X  };
X  
X  #ifdef SPELLS
X! struct spell NEARDATA spl_book[MAXSPELL + 1] = DUMMY;
X  #endif
X  
X! long NEARDATA moves = 1, NEARDATA monstermoves = 1;
X! 	 /* These diverge when player is Fast */
X! long NEARDATA wailmsg = 0;
X  
X! struct obj NEARDATA zeroobj = DUMMY;	/* used to zero all elements of a struct obj */
X  
X  struct obj *billobjs = 0;
X  
X*** src/Old/demon.c	Sun Jun  3 12:52:14 1990
X--- src/demon.c	Sun Apr 15 10:02:49 1990
X***************
X*** 122,127 ****
X--- 122,129 ----
X  		   plur(offer));
X  
X  	u.ugold -= offer;
X+ 	mtmp->mgold += offer;
X+ 	flags.botl = 1;
X  	return(offer);
X  }
X  #endif
X
END_OF_FILE
if test 50042 -ne `wc -c <'patch8.01'`; then
    echo shar: \"'patch8.01'\" unpacked with wrong size!
fi
# end of 'patch8.01'
fi
echo shar: End of archive 12 \(of 24\).
cp /dev/null ark12isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 24 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
