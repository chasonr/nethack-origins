Path: utzoo!attcan!uunet!zephyr.ens.tek.com!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v10i029:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Patch8k
Message-ID: <5737@tekred.CNA.TEK.COM>
Date: 5 Jun 90 17:57:02 GMT
Sender: news@tekred.CNA.TEK.COM
Lines: 1650
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 10, Issue 29
Archive-name: NetHack3/Patch8k
Patch-To: NetHack3: Volume 7, Issue 56-93



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 11 (of 24)."
# Contents:  patch8.11
# Wrapped by billr@saab on Mon Jun  4 15:27:22 1990
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'patch8.11' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'patch8.11'\"
else
echo shar: Extracting \"'patch8.11'\" \(50401 characters\)
sed "s/^X//" >'patch8.11' <<'END_OF_FILE'
X*** mac/Old/mac.c	Sun Jun  3 11:09:32 1990
X--- mac/mac.c	Sat May 26 14:54:04 1990
X***************
X*** 11,24 ****
X  WindowPtr	HackWindow;	/* points to Hack's window */
X  extern char	*keys[8];
X  extern short macflags;
X  short cursorPos=0;
X  short repDelay;
X  long lastMD;
X! struct line {
X! 	struct line *next_line;
X! 	char *line_text;
X! } *mactexthead;
X! short maclinect, macmaxlen;
X  
X  int
X  tgetch()
X--- 11,22 ----
X  WindowPtr	HackWindow;	/* points to Hack's window */
X  extern char	*keys[8];
X  extern short macflags;
X+ extern long lowMemLimit;
X  short cursorPos=0;
X  short repDelay;
X  long lastMD;
X! long segments = SEG_DO;
X! extern short altCurs; /* should be a macflag */
X  
X  int
X  tgetch()
X***************
X*** 32,38 ****
X  	register short	keyCode;
X  	short	temp;
X  	term_info	*t;
X- 	boolean	noControlKey;
X  	GrafPtr	oldPort,oldPort1;
X  	static char nextCommand;
X  	short aboutBox();
X--- 30,35 ----
X***************
X*** 40,49 ****
X  	Point	mouseLoc;
X  	WindowPtr	theWindow;
X  	void	doUpdate();
X- #define noEscapeKey	noControlKey
X  #define	clearKey	0x47
X  #define ESCAPEkey	0x1B
X! 	
X  	t = (term_info *)GetWRefCon(HackWindow);
X  	mouseLoc.h = (macflags & fMoveWRTMouse) ? t->tcur_x : (u.ux-1);
X  	mouseLoc.v = (macflags & fMoveWRTMouse) ? t->tcur_y : (u.uy+1);
X--- 37,49 ----
X  	Point	mouseLoc;
X  	WindowPtr	theWindow;
X  	void	doUpdate();
X  #define	clearKey	0x47
X  #define ESCAPEkey	0x1B
X! 	static int see, saw = 0;
X! 	int eye, cursOff = 100;
X! 	boolean cursRectInv;	/* should be a macflag */
X! 	short	fInFront = TRUE;
X! 
X  	t = (term_info *)GetWRefCon(HackWindow);
X  	mouseLoc.h = (macflags & fMoveWRTMouse) ? t->tcur_x : (u.ux-1);
X  	mouseLoc.v = (macflags & fMoveWRTMouse) ? t->tcur_y : (u.uy+1);
X***************
X*** 50,62 ****
X  	cursorRect.left = t->tcur_x * t->charWidth + Screen_Border;
X  	cursorRect.right = cursorRect.left + t->charWidth - 1;
X  	cursorRect.top = t->height * t->tcur_y + Screen_Border;
X! 	cursorRect.bottom = cursorRect.top + t->height;
X  	cursorTime = GetCaretTime();
X! 	noControlKey = (t->system.keyBoardType <= envMacPlusKbd) ? TRUE : FALSE;
X! 	box.left = mouseLoc.h * t->charWidth + Screen_Border;
X! 	box.right = box.left + t->charWidth;
X! 	box.top = mouseLoc.v * t->height + Screen_Border + t->height/2 - (t->charWidth/2);
X! 	box.bottom = box.top + t->charWidth;
X  	/* permit use of cursor keys and numeric keypad */
X  	/* does the same translation as in msdos.c but includes cursor keys */
X  	ch = '\0';
X--- 50,61 ----
X  	cursorRect.left = t->tcur_x * t->charWidth + Screen_Border;
X  	cursorRect.right = cursorRect.left + t->charWidth - 1;
X  	cursorRect.top = t->height * t->tcur_y + Screen_Border;
X! 	cursorRect.bottom = cursorRect.top + t->height - 1;
X  	cursorTime = GetCaretTime();
X! 	box.left = mouseLoc.h * t->charWidth + Screen_Border - 1;
X! 	box.right = box.left + t->charWidth + 2;
X! 	box.top = mouseLoc.v * t->height + Screen_Border - 1;
X! 	box.bottom = box.top + t->height + 2;
X  	/* permit use of cursor keys and numeric keypad */
X  	/* does the same translation as in msdos.c but includes cursor keys */
X  	ch = '\0';
X***************
X*** 79,100 ****
X  	SetPort(HackWindow);
X  	if (!(macflags & fDoNonKeyEvt)) {
X  		cursorPos = -1;
X! 		SetCursor(&ARROW_CURSOR);
X  	}
X! 	/* do cursor blinking */
X! 	message = TickCount() + cursorTime;
X! 	if (!EventAvail(keyDownMask|mDownMask|autoKeyMask,&theEvent)) {
X! 		keyCode = true;
X! 		InvertRect(&cursorRect);
X! 	} else
X! 		keyCode = 0;
X  	while (!ch) {
X! 		(void)WaitNextEvent(everyEvent, &theEvent, 0L, 0L);
X  		if (theEvent.what == keyDown || theEvent.what == autoKey) {
X  			ch = 0;
X  			ObscureCursor();
X  			/* use raw key codes */
X- 			temp = keyCode;
X  			keyCode = (LoWord(theEvent.message) & keyCodeMask)>>8;
X   			if (keyCode == clearKey) {
X  				macflags = macflags ^ fToggleNumPad;
X--- 78,94 ----
X  	SetPort(HackWindow);
X  	if (!(macflags & fDoNonKeyEvt)) {
X  		cursorPos = -1;
X! 		if (! flags.wantspace) SetCursor(&ARROW_CURSOR);
X  	}
X! 	/* initialize cursor blinking */
X! 	message = TickCount();
X! 	cursRectInv = FALSE;
X  	while (!ch) {
X! 		(void)WaitNextEvent(everyEvent, &theEvent, (fInFront) ? 0L : 50L, 0L);
X  		if (theEvent.what == keyDown || theEvent.what == autoKey) {
X  			ch = 0;
X  			ObscureCursor();
X  			/* use raw key codes */
X  			keyCode = (LoWord(theEvent.message) & keyCodeMask)>>8;
X   			if (keyCode == clearKey) {
X  				macflags = macflags ^ fToggleNumPad;
X***************
X*** 101,112 ****
X  				SetWTitle(HackWindow,
X  					(macflags & fToggleNumPad)	? "\016NetHack [MOVE]"
X  												: "\015NetHack [NUM]");
X- 				keyCode = temp;
X  				ch = 0;
X  				continue;
X  			}
X- 			if (temp)
X- 				InvertRect(&cursorRect);
X  			if ((macflags & fToggleNumPad) && (keyCode>0x40 &&keyCode < 0x5D) 
X  				|| (keyCode > 0x7A && keyCode<0x7F)) {
X  				ch = t->keyMap[keyCode-65];
X--- 95,103 ----
X***************
X*** 116,127 ****
X  				if (ch)
X  					break;
X  			}
X! 			if (keyCode == 50 && noEscapeKey) {
X  				ch = (char)ESCAPEkey;	/* ESC */
X  				break;
X! 			}			/* make the command key = control key on old Mac keyboards */
X! 			if ((theEvent.modifiers & cmdKey) && noControlKey) {
X  				ch = (char)(theEvent.message & 0x1F);
X  				break;
X  			}
X  			if (theEvent.modifiers & optionKey) {
X--- 107,125 ----
X  				if (ch)
X  					break;
X  			}
X! 			if (t->system.keyBoardType < 4 && keyCode == 50) {
X  				ch = (char)ESCAPEkey;	/* ESC */
X  				break;
X! 			}			/* make the command key = control key on all non-adb keyboards
X! 						 Now, LEAVE it this way ! Otherwise you'll render non-us
X! keyboards useless, since here is where "<" and ">" are located */
X! 			if ((theEvent.message & 0xFF) == 0x60) {
X! 				ch = (char)ESCAPEkey;
X! 				break;
X! 			} /* This is the way to fix backquote->esc for all macs */
X! 			if (theEvent.modifiers & cmdKey) {
X  				ch = (char)(theEvent.message & 0x1F);
X+ 				if(ch == ('Q' & 0x1F)) ch = 'Q'; /* For Quit */
X  				break;
X  			}
X  			if (theEvent.modifiers & optionKey) {
X***************
X*** 140,155 ****
X  		/* what other events to handle */
X  			switch (theEvent.what) {		
X  			case nullEvent:
X  				GetPort(&oldPort1);
X  				SetPort((GrafPtr)HackWindow);
X  				/* wait until something occurs */
X! 				if (TickCount() > message) {
X  					message = TickCount() + cursorTime;
X! 					if (!(macflags & fMoveWRTMouse)
X! 						|| (macflags & fMoveWRTMouse && !keyCode)) {
X! 						InvertRect(&cursorRect);
X! 						keyCode = !keyCode;
X! 					}
X  				}
X  				if (FrontWindow() == HackWindow && (macflags & fDoNonKeyEvt)) {
X  					if ((FindWindow(theEvent.where,&theWindow) == inContent)
X--- 138,152 ----
X  		/* what other events to handle */
X  			switch (theEvent.what) {		
X  			case nullEvent:
X+ 				if (!fInFront)
X+ 					break;
X  				GetPort(&oldPort1);
X  				SetPort((GrafPtr)HackWindow);
X  				/* wait until something occurs */
X! 				if ((TickCount() > message) && (FrontWindow() == HackWindow)) {
X  					message = TickCount() + cursorTime;
X! 					InvertRect(&cursorRect);
X! 					cursRectInv = !cursRectInv;
X  				}
X  				if (FrontWindow() == HackWindow && (macflags & fDoNonKeyEvt)) {
X  					if ((FindWindow(theEvent.where,&theWindow) == inContent)
X***************
X*** 157,184 ****
X  						
X  						GetMouse(&mouseLoc);
X  						if (PtInRect(mouseLoc,&box)) {
X! 							CursHandle theCurs;
X! 							
X! 							theCurs = GetCursor(3);
X! 							cursorPos = 8;
X! 							SetCursor(*theCurs);
X  						} else {
X  							PtToAngle(&box,mouseLoc,&temp);
X! 							if (temp >336 || temp < 23) {
X! 								temp = 0;
X  							} else {
X! 								temp = (temp + 23)/45;
X  							}
X! 							if (temp >=0 && temp <8 && cursorPos != temp) {
X! 								SetCursor(*t->cursor[temp]);
X! 								cursorPos = temp;
X! #ifdef THINK_C
X! 								repDelay = KeyThresh*2;
X! #else
X! 								repDelay = 42;
X! #endif
X! 								lastMD = theEvent.when;
X  							}
X  						}
X  					} else if (cursorPos>=0) {
X  						cursorPos = -1;
X--- 154,203 ----
X  						
X  						GetMouse(&mouseLoc);
X  						if (PtInRect(mouseLoc,&box)) {
X! 							temp = 8;
X  						} else {
X  							PtToAngle(&box,mouseLoc,&temp);
X! 							temp = ((temp + 22) / 45) % 8;	/* 0=N, 1=NE ... 7=NW */
X! 						}
X! 						/* since we're not doing anything let's look at the cursor */
X! 						if (altCurs) {	/* this list is prioritized! */
X! 							if (Sick) {
X! 								cursOff = 130;	/* offset for CURS resource set */
X! 								see = SICK;
X! 							} else if (Blind) {
X! 								cursOff = 120;
X! 								see = BLINDED;
X! 							} else if (Hallucination) {
X! 								cursOff = 110;
X! 								see = HALLUC;
X! 							} else if (Confusion || Stunned) {
X! 								see = CONFUSION;
X  							} else {
X! 								cursOff = 100;
X! 								see = 0;
X  							}
X! 						} else {
X! 							see = (Confusion || Stunned) ? CONFUSION : 0;
X! 							cursOff = 100;
X! 						}
X! 						if ((cursorPos != temp) || (see != saw)) {
X! 							if (see != saw) {
X! 								switch(see) {
X! 								case CONFUSION:
X! 									break;
X! 								default:	/* hmm, a bit much for !altCurs */
X! 									for (eye=0; eye<=8; eye++) {
X! 										EmptyHandle(t->cursor[eye]);
X! 										t->cursor[eye] = GetCursor(eye+cursOff);
X! 										HNoPurge(t->cursor[eye]);
X! 									}
X! 									break;
X! 								}
X! 								saw = see;
X  							}
X+ 							cursorPos = temp;
X+ 							eye = (Confusion || Stunned) ? rn2(9) : temp;
X+ 							SetCursor(*t->cursor[eye]);
X  						}
X  					} else if (cursorPos>=0) {
X  						cursorPos = -1;
X***************
X*** 190,196 ****
X  					ch = mButtonDown(theEvent, t, &nextCommand);
X  					if (repDelay) {
X  #ifdef THINK_C
X! 						repDelay = KeyRepThresh*2;
X  #else
X  						repDelay /= 3;
X  #endif
X--- 209,215 ----
X  					ch = mButtonDown(theEvent, t, &nextCommand);
X  					if (repDelay) {
X  #ifdef THINK_C
X! 						repDelay = KeyRepThresh;
X  #else
X  						repDelay /= 3;
X  #endif
X***************
X*** 209,214 ****
X--- 228,234 ----
X  					case kSuspendResumeMessage:
X  						if (!SuspResIsResume(theEvent.message)) {
X  						/* ---------- SUSPEND EVENT ------------ */
X+ 							fInFront = FALSE;
X  							if (macflags & fZoomOnContextSwitch
X  								&& !EmptyRect(&(**(HackWindow)->visRgn).rgnBBox))
X  							{
X***************
X*** 217,222 ****
X--- 237,243 ----
X  							}
X  						} else {
X  						/* ---------- RESUME EVENT ------------- */
X+ 							fInFront = TRUE;
X  							if (macflags & fZoomOnContextSwitch) {
X  								SizeWindow(HackWindow,
X  								 (t->maxCol * t->charWidth) + 2 * Screen_Border,
X***************
X*** 244,249 ****
X--- 265,271 ----
X  			case updateEvt:
X  				if (HackWindow == (WindowPtr)theEvent.message) {
X  					doUpdate(t);
X+ 					if (cursRectInv) InvertRect(&cursorRect);	/* restore cursor */
X  				}
X  				break;
X  				
X***************
X*** 278,289 ****
X  				
X  			case mouseDown:
X  				ch = mButtonDown(theEvent, t, &nextCommand);
X  				break;
X  			}
X  		}		
X  	}
X! 	if (keyCode && ch && (theEvent.what != keyDown && theEvent.what != autoKey))
X! 		InvertRect(&cursorRect);
X  
X  	SetPort(oldPort);
X  	return ((ch == '\r') ? '\n' : ch);
X--- 300,316 ----
X  				
X  			case mouseDown:
X  				ch = mButtonDown(theEvent, t, &nextCommand);
X+ #ifdef THINK_C
X+ 				repDelay = KeyThresh;
X+ #else
X+ 				repDelay = 42;
X+ #endif
X+ 				lastMD = theEvent.when;
X  				break;
X  			}
X  		}		
X  	}
X! 	if (cursRectInv) InvertRect(&cursorRect);
X  
X  	SetPort(oldPort);
X  	return ((ch == '\r') ? '\n' : ch);
X***************
X*** 293,300 ****
X  doUpdate(t)
X  term_info	*t;
X  {
X! 	short	temp;
X  	GrafPtr	oldPort;
X  #ifdef TEXTCOLOR
X  	if (t->system.hasColorQD) {
X  		Rect	r;
X--- 320,329 ----
X  doUpdate(t)
X  term_info	*t;
X  {
X! 	register short	temp;
X  	GrafPtr	oldPort;
X+ 	register	short i,j;
X+ 	register char	attr, *p;
X  #ifdef TEXTCOLOR
X  	if (t->system.hasColorQD) {
X  		Rect	r;
X***************
X*** 312,381 ****
X  	GetPort(&oldPort);
X  	SetPort((GrafPtr)HackWindow);
X  	BeginUpdate(HackWindow);
X! 	if (t->inColor && (macflags & fDoUpdate) && !(macflags & 0x2000)) {
X! 		char	*tmp;
X! 		short	x,y;
X! 		
X! 		tmp = calloc(2*t->maxCol, sizeof(char));
X! 		BlockMove(t->screen[0], tmp, t->maxCol);
X! 		BlockMove(t->screen[1], &tmp[t->maxCol], t->maxCol);
X! 		x = t->tcur_x;
X! 		y = t->tcur_y;
X! 		temp = flags.toplin;
X! 		flags.toplin = 0;
X! 		docrt();
X! 		flags.toplin = temp;
X! 		BlockMove(tmp, t->screen[0], t->maxCol);
X! 		BlockMove(&tmp[t->maxCol], t->screen[1], t->maxCol);
X! 		free(tmp);
X! 		t->tcur_y = y;
X! 		t->tcur_x = x;
X! 	}
X! 	if (macflags & fDoUpdate) {
X! 		for (temp = 0;
X! 			temp < ((t->inColor && !(macflags & fFullScrKluge))
X! 				? 2 : t->maxRow);
X! 			temp++) {
X! 			if ((macflags & fScreenKluges) == fScreenKluges
X! 				&& temp == t->maxRow-1){
X! 				if(flags.standout)
X! 					standoutbeg();
X! 			}
X! 			MoveTo(Screen_Border,
X! 				t->ascent + (temp * t->height) + Screen_Border);
X! 			DrawText(&t->screen[temp][0], 0, t->maxCol);
X! 			if ((macflags & fScreenKluges) == fScreenKluges
X! 				&& temp == t->maxRow-1){
X! 				if(flags.standout)
X! 					standoutend();
X! 			}
X! 		}
X! 
X! 		if (macflags & fDisplayKluge) {
X! 			register struct line *tl;
X! 			int curline, lth;
X! 			
X! 		    if(flags.toplin == 1) more();	/* ab@unido */
X! 		    remember_topl();
X! 		
X! 		    lth = CO - macmaxlen - 2;		   /* Use full screen width */
X! 		    if (maclinect < LI && lth >= 10) {		     /* in a corner */
X! 				home ();
X! 				cl_end ();
X! 				flags.toplin = 0;
X! 				curline = 1;
X! 				for (tl = mactexthead; tl; tl = tl->next_line) {
X! 				    curs (lth, curline);
X! 				    if(curline > 1)
X! 						cl_end ();
X! 				    xputs(tl->line_text);
X! 				    curx = curx + strlen(tl->line_text);
X! 				    curline++;
X  				}
X! 				curs (lth, curline);
X  			}
X! 		}
X! 	}
X  	EndUpdate(HackWindow);
X  	SetPort(oldPort);
X  }
X--- 341,417 ----
X  	GetPort(&oldPort);
X  	SetPort((GrafPtr)HackWindow);
X  	BeginUpdate(HackWindow);
X!     ForeColor(t->color[0]);
X!     BackColor(t->color[7]);
X! 	for (i = 0; i<t->maxRow; i++) {
X! 		p = t->scrAttr[i];
X! 		for (j = temp = 0, attr = *p; j<t->maxCol; j +=1, p++) {
X! 			if (*p != attr) {
X! 				MoveTo(Screen_Border + temp*t->charWidth,
X! 					t->ascent + (i * t->height) +
X! 					Screen_Border);
X! 				if (attr & 0x80) {
X! 				    ForeColor(t->color[7]);
X! 				    BackColor(t->color[0]);
X! 				} else if (t->inColor) {
X! 					ForeColor(t->color[attr]);
X! 					 /* yellow fgnd hard to see on white bgnd */
X! 					 /* so change to green background */
X! 					switch(attr) {
X! 					case BROWN:
X! 						BackColor(t->color[GREEN]);
X! 						break;
X! 					case BLUE:
X! 						BackColor(t->color[CYAN]);
X! 						break;
X! 					case CYAN:
X! 						BackColor(t->color[BLUE]);
X! 						break;
X! 					default:
X! 					    BackColor(t->color[7]);
X! 					   	break;
X! 					}
X! 				} else {
X! 				    ForeColor(t->color[0]);
X! 				    BackColor(t->color[7]);
X! 				}
X! 				DrawText(&(t->screen[i][temp]), 0, j - temp);
X! 				temp = j;
X! 				attr = *p;
X! 			} /* if */
X! 		} /* for j */
X! 		if (temp != t->maxCol) {
X! 			MoveTo(Screen_Border + temp*t->charWidth,
X! 				t->ascent + (i * t->height) +
X! 				Screen_Border);
X! 			if (attr & 0x80) {
X! 			    ForeColor(t->color[7]);
X! 			    BackColor(t->color[0]);
X! 			} else if (t->inColor) {
X! 				ForeColor(t->color[attr]);
X! 				 /* yellow fgnd hard to see on white bgnd */
X! 				 /* so change to green background */
X! 				switch(attr) {
X! 				case BROWN:
X! 					BackColor(t->color[GREEN]);
X! 					break;
X! 				case BLUE:
X! 					BackColor(t->color[CYAN]);
X! 					break;
X! 				case CYAN:
X! 					BackColor(t->color[BLUE]);
X! 					break;
X! 				default:
X! 				    BackColor(t->color[7]);
X! 				   	break;
X  				}
X! 			} else {
X! 			    ForeColor(t->color[0]);
X! 			    BackColor(t->color[7]);
X  			}
X! 			DrawText(&(t->screen[i][temp]), 0, j - temp);
X! 		} /* if */
X! 	} /* for i */
X  	EndUpdate(HackWindow);
X  	SetPort(oldPort);
X  }
X***************
X*** 399,405 ****
X  	if (macflags & fDoNonKeyEvt) {
X  		switch (FindWindow(theEvent.where,&theWindow)) {
X  	    case inMenuBar:
X! 
X  		SetCursor(&ARROW_CURSOR);
X  		message = MenuSelect(theEvent.where);
X  
X--- 435,442 ----
X  	if (macflags & fDoNonKeyEvt) {
X  		switch (FindWindow(theEvent.where,&theWindow)) {
X  	    case inMenuBar:
X! 		if (!(macflags & fDoMenus))
X! 			break;
X  		SetCursor(&ARROW_CURSOR);
X  		message = MenuSelect(theEvent.where);
X  
X***************
X*** 509,519 ****
X  				box.bottom = box.top + 1;
X  				GetMouse(&mouseLoc);
X  				PtToAngle(&box,mouseLoc,&temp);
X! 				if (temp >337 || temp < 23) {
X! 					temp = 0;
X! 				} else {
X! 					temp = (temp + 23)/45;
X! 				}
X  				switch(cursorPos) {
X  					case 0:
X  						ch = 'k';
X--- 546,552 ----
X  				box.bottom = box.top + 1;
X  				GetMouse(&mouseLoc);
X  				PtToAngle(&box,mouseLoc,&temp);
X! 				temp = ((temp + 22) / 45) % 8;	/* ~same as above */
X  				switch(cursorPos) {
X  					case 0:
X  						ch = 'k';
X***************
X*** 551,557 ****
X  		break;
X  		}
X  	} else {
X! 		if(flags.wantspace) ch = 0x20;
X  	}
X  	return ch;
X  }
X--- 584,596 ----
X  		break;
X  		}
X  	} else {
X! 		switch (FindWindow(theEvent.where,&theWindow)) {
X! 		case inContent:
X! 			if(flags.wantspace) ch = 0x20;
X! 			break;
X! 		default:
X! 			break;
X! 		}
X  	}
X  	return ch;
X  }
X***************
X*** 635,647 ****
X  {
X  	if (t->tcur_y >= t->maxRow-1) {
X  		short	temp;
X! 		char	*s;
X  
X  		BlockMove((Ptr)t->screen[1], (Ptr)t->screen[0],
X  			(Size)((t->maxRow - 1) * t->maxCol));
X! 		for (temp = 0, s = t->screen[t->maxRow - 1];
X! 				temp < t->maxCol; temp++, s++) {
X  			*s = ' ';
X  		}
X  		{
X  			Pattern p, o;
X--- 674,689 ----
X  {
X  	if (t->tcur_y >= t->maxRow-1) {
X  		short	temp;
X! 		char	*s, *s1;
X  
X  		BlockMove((Ptr)t->screen[1], (Ptr)t->screen[0],
X  			(Size)((t->maxRow - 1) * t->maxCol));
X! 		BlockMove((Ptr)t->scrAttr[1], (Ptr)t->scrAttr[0],
X! 			(Size)((t->maxRow - 1) * t->maxCol));
X! 		for (temp = 0, s = t->screen[t->maxRow - 1], s1 = t->scrAttr[t->maxRow - 1];
X! 				temp < t->maxCol; temp++, s++, s1++) {
X  			*s = ' ';
X+ 			*s1 = 0;
X  		}
X  		{
X  			Pattern p, o;
X***************
X*** 698,705 ****
X  	if (!strncmp(s, "\033[", 2)) {
X  	    switch(*(s + 2)) {
X  		case 'c':	/* color kluge */
X- 		    if (t->inColor) {
X  			temp = (short)(*(s + 3) - 'a');
X  			if (temp >= BLACK && temp < MAXCOLORS &&
X  			    (temp % (MAXCOLORS / 2) != GRAY)) /* set colour */
X  				ForeColor(t->color[temp % (MAXCOLORS / 2)]);
X--- 740,753 ----
X  	if (!strncmp(s, "\033[", 2)) {
X  	    switch(*(s + 2)) {
X  		case 'c':	/* color kluge */
X  			temp = (short)(*(s + 3) - 'a');
X+ 			t->curAttr = temp;
X+ 			if (temp >= BLACK && temp < MAXCOLORS &&
X+ 			    (temp % (MAXCOLORS / 2) != GRAY)) /* set colour */
X+ 			    t->curAttr = temp % (MAXCOLORS / 2);
X+ 			if ((temp & 0x07) == GRAY)
X+ 				t->curAttr = 0;
X+ 		    if (t->inColor) {
X  			if (temp >= BLACK && temp < MAXCOLORS &&
X  			    (temp % (MAXCOLORS / 2) != GRAY)) /* set colour */
X  				ForeColor(t->color[temp % (MAXCOLORS / 2)]);
X***************
X*** 719,724 ****
X--- 767,774 ----
X  		    if (*(s + 3) == 'm') {
X  			    ForeColor(t->color[0]);
X  			    BackColor(t->color[7]);
X+ 			    t->curHilite = FALSE;
X+ 			    t->curAttr = 0;
X  		    }
X  		    break;
X  		case '1':	/* inverse video begin */
X***************
X*** 725,730 ****
X--- 775,782 ----
X  		    if (*(s + 3) == 'm') {
X  			    ForeColor(t->color[7]);
X  			    BackColor(t->color[0]);
X+ 			    t->curHilite = TRUE;
X+ 			    t->curAttr = 0;
X  		    }
X  		    break;
X  		case 'A':	/* cursor up */
X***************
X*** 762,769 ****
X  		    eraseRect.bottom = eraseRect.top + t->height;
X  		    eraseRect.right = (t->maxCol*t->charWidth) + Screen_Border;
X  		    EraseRect(&eraseRect);
X! 		    for (temp = x, c = &(t->screen[y][x]); temp < t->maxCol; temp++)
X  			    *c++ = ' ';
X  		    break;
X  		case '2':
X  		    if (*(s+3) == 'J') {	/* clear screen */
X--- 814,824 ----
X  		    eraseRect.bottom = eraseRect.top + t->height;
X  		    eraseRect.right = (t->maxCol*t->charWidth) + Screen_Border;
X  		    EraseRect(&eraseRect);
X! 		    for (temp = x, c = &(t->screen[y][x]), c1 = &(t->scrAttr[y][x]);
X! 		    	temp < t->maxCol; temp++) {
X  			    *c++ = ' ';
X+ 			    *c1++ = 0;
X+ 			}
X  		    break;
X  		case '2':
X  		    if (*(s+3) == 'J') {	/* clear screen */
X***************
X*** 772,779 ****
X  			eraseRect.bottom = t->maxRow*t->height + Screen_Border;
X  			eraseRect.right = t->charWidth*t->maxCol + Screen_Border;
X  			EraseRect(&eraseRect);
X! 			for (y = 0, c = t->screen[0]; y < t->maxCol * t->maxRow; y++) {
X  					*c++ = ' ';
X  			}
X  			cur.h = Screen_Border;
X  			cur.v = t->ascent + Screen_Border;
X--- 827,836 ----
X  			eraseRect.bottom = t->maxRow*t->height + Screen_Border;
X  			eraseRect.right = t->charWidth*t->maxCol + Screen_Border;
X  			EraseRect(&eraseRect);
X! 			for (y = 0, c = t->screen[0], c1 = t->scrAttr[0];
X! 				y < t->maxCol * t->maxRow; y++) {
X  					*c++ = ' ';
X+ 					*c1++ = 0;
X  			}
X  			cur.h = Screen_Border;
X  			cur.v = t->ascent + Screen_Border;
X***************
X*** 808,813 ****
X--- 865,872 ----
X  		    }
X  		    DrawText((Ptr)stmp, 0, temp);
X  		    BlockMove((Ptr)stmp, (Ptr)&(t->screen[y][x]), (long)temp);
X+ 		    memset(&(t->scrAttr[y][x]), ((t->curHilite) ? 128 : 0) + t->curAttr,
X+ 		    	temp);
X  		    stmp += temp + 1;
X  		    charleft -= temp + 1;
X  		    if (!savech) {
X***************
X*** 897,902 ****
X--- 956,962 ----
X  		}
X  	} else {
X  		t->screen[y][x] = c;
X+ 		t->scrAttr[y][x] = ((t->curHilite) ? 128 : 0) + t->curAttr;
X  		DrawText(&c, 0, 1);
X  		if (!savech) {
X  			t->tcur_x++;
X***************
X*** 979,987 ****
X  				c = *(fstr + 1);
X  				*(fstr + 1) = '\0';
X  				if (islong)
X! 				    sprintf(numAsStr, s, num);
X  				else
X! 				    sprintf(numAsStr, s, (short)num);
X  				*(fstr + 1) = c;
X  				Strcpy(pb, numAsStr);
X  				pb = (char *)(pb + strlen(numAsStr));
X--- 1039,1047 ----
X  				c = *(fstr + 1);
X  				*(fstr + 1) = '\0';
X  				if (islong)
X! 				    Sprintf(numAsStr, s, num);
X  				else
X! 				    Sprintf(numAsStr, s, (short)num);
X  				*(fstr + 1) = c;
X  				Strcpy(pb, numAsStr);
X  				pb = (char *)(pb + strlen(numAsStr));
X***************
X*** 1095,1102 ****
X  			ModalDialog(NULL, &itemHit);
X  		}
X  	} else {
X! 		while (!itemHit) {
X! 			SystemTask();
X  			if (GetNextEvent(everyEvent,&theEvent))
X  				if (theEvent.what == mouseDown ||
X    			            theEvent.what == keyDown ||
X--- 1155,1165 ----
X  			ModalDialog(NULL, &itemHit);
X  		}
X  	} else {
X! 		long	tickNum;
X! 
X! 		tickNum = TickCount() + 180;	/* 3 second wait max */
X! 		while (!itemHit && TickCount()<tickNum) {
X! 		/*	SystemTask();*/
X  			if (GetNextEvent(everyEvent,&theEvent))
X  				if (theEvent.what == mouseDown ||
X    			            theEvent.what == keyDown ||
X***************
X*** 1109,1111 ****
X--- 1172,1232 ----
X  	SetPort(oldPort);
X  	return (itemHit == MORE_INFO_BUTTON);
X  }
X+ 
X+ void
X+ freeSegs(segs)
X+ long	*segs;
X+ {
X+ 	register long s;
X+ 	
X+ 	s = (segs == (long *)0) ? 0L : (*segs);
X+ 	
X+ 	UnloadSeg(dothrow);
X+ 	UnloadSeg(dowear);
X+ 	UnloadSeg(ddocall);
X+ 	UnloadSeg(castmu);
X+ 	UnloadSeg(doforce);
X+ 	if (!(s & SEG_EAT))
X+ 		UnloadSeg(doeat);
X+ 	if (!(s & SEG_ZAP))
X+ 		UnloadSeg(dozap);
X+ 	UnloadSeg(initterm);
X+ 	if (!(s & SEG_APPLY))
X+ 		UnloadSeg(doapply);
X+ 	UnloadSeg(dokick);
X+ 	UnloadSeg(outrumor);
X+ 	if (!(s & SEG_DO))
X+ 		UnloadSeg(steal);
X+ 	UnloadSeg(done1);
X+ 	if (!(s & SEG_POTION))
X+ 		UnloadSeg(dodrink);
X+ 	UnloadSeg(doturn);
X+ #ifdef REINCARNATION
X+ 	UnloadSeg(makeroguerooms);
X+ #endif
X+ #ifdef STRONGHOLD
X+ 	UnloadSeg(load_special);
X+ #endif
X+ 	UnloadSeg(mklev);
X+ #ifdef MUSIC
X+ 	if (!(s & SEG_SPELL))
X+ 		UnloadSeg(do_play_instrument);
X+ #endif
X+ #ifdef SPELLS
X+ 	if (!(s & SEG_SPELL))
X+ 		UnloadSeg(docast);
X+ #endif
X+ 	UnloadSeg(savebones);
X+ 	UnloadSeg(expels);
X+ 	UnloadSeg(attack);
X+ 	UnloadSeg(doname);
X+ 	if (FreeMem() < lowMemLimit)
X+ 	{
X+ 		long	space;
X+ 		
X+ 		space = 0x7FFFFFFFL;
X+ 		MaxMem(&space);
X+ 	}
X+ 
X+ }
X+ 
X*** mac/Old/macinit.c	Sun Jun  3 11:10:27 1990
X--- mac/macinit.c	Tue May 22 20:40:33 1990
X***************
X*** 27,32 ****
X--- 27,33 ----
X  } defaultData;
X  #define	fDFZoomWindow	0x02L
X  #define	fDFUseDefaultFont	0x01L
X+ short altCurs;
X  
X  
X  int
X***************
X*** 35,41 ****
X  {
X  	register short	i, j;
X  	short		tempFont, tempSize, fontNum, size;
X! 	char	*l;
X  	EventRecord	theEvent;
X  	FontInfo	fInfo;
X  	Handle	temp;
X--- 36,42 ----
X  {
X  	register short	i, j;
X  	short		tempFont, tempSize, fontNum, size;
X! 	char	*l, *m;
X  	EventRecord	theEvent;
X  	FontInfo	fInfo;
X  	Handle	temp;
X***************
X*** 80,86 ****
X  	theMenu = NewMenu(appleMenu, "\001\024");	/*  apple menu  */
X  	{
X  		char	tmp[256];
X! 		sprintf(&tmp[1],"About NetHack %s\311;(-", VERSION);
X  		tmp[0] = (char)strlen(&tmp[1]);
X  		AppendMenu(theMenu,tmp);
X  	}
X--- 81,87 ----
X  	theMenu = NewMenu(appleMenu, "\001\024");	/*  apple menu  */
X  	{
X  		char	tmp[256];
X! 		Sprintf(&tmp[1],"About NetHack %s\311;(-", VERSION);
X  		tmp[0] = (char)strlen(&tmp[1]);
X  		AppendMenu(theMenu,tmp);
X  	}
X***************
X*** 125,131 ****
X  		size = 12;
X  	else
X  		size = 9;
X! 	strcpy((char *)&font[0], "\006Monaco");
X  	
X  	temp = GetResource(HACK_DATA, DEFAULT_DATA);
X  	if (temp) {
X--- 126,132 ----
X  		size = 12;
X  	else
X  		size = 9;
X! 	Strcpy((char *)&font[0], "\006Monaco");
X  	
X  	temp = GetResource(HACK_DATA, DEFAULT_DATA);
X  	if (temp) {
X***************
X*** 222,236 ****
X--- 223,243 ----
X  		TOP_OFFSET + (row * t->height) + 2 * Screen_Border + 10);
X  	
X  	t->screen = (char **)malloc(row * sizeof(char *));
X+ 	t->scrAttr = (char **)malloc(row * sizeof(char *));
X  	l = malloc(row * col * sizeof(char));
X+ 	m = malloc(row * col * sizeof(char));
X  	for (i = 0;i < row;i++) {
X  		t->screen[i] = (char *)(l + (i * col * sizeof(char)));
X+ 		t->scrAttr[i] = (char *)(m + (i * col * sizeof(char)));
X  	}
X  	for (i = 0; i < row; i++) {
X  		for (j = 0; j < col; j++) {
X  			t->screen[i][j] = ' ';
X+ 			t->scrAttr[i][j] = '\0';
X  		}
X  	}
X+ 	t->curHilite = 0;
X+ 	t->curAttr = 0;
X  
X  	/* give time for Multifinder to bring NetHack window to front */
X  	for(tempFont = 0; tempFont<10; tempFont++) {
X***************
X*** 290,297 ****
X  		panic("Can't get OBJECT resource data.");
X  	}
X  	
X! 	for (i = 0; i<8; i++) {
X! 		t->cursor[i] = GetCursor(100+i);
X  	}
X  	
X  	(void)aboutBox(0);	
X--- 297,306 ----
X  		panic("Can't get OBJECT resource data.");
X  	}
X  	
X! 	for (j = 30; j >= 0; j -= 10) {
X! 		for (i = 0; i<=8; i++) {
X! 			t->cursor[i] = GetCursor(100+i+j);	/* self-contained cursors */
X! 		}
X  	}
X  	
X  	(void)aboutBox(0);	
X***************
X*** 380,392 ****
X  int
X  read_config_file()
X  {
X! 
X  	int optfd;
X  	optfd = 0;
X! 	if ( (optfd = open(OPTIONS, OMASK)) > (int)NULL){
X  		read_opts(optfd);
X  		(void) close(optfd);
X  	}
X  }
X  
X  int
X--- 389,413 ----
X  int
X  read_config_file()
X  {
X! 	term_info	*t;
X  	int optfd;
X+ 	Str255	name;
X+ 	short	oldVol;
X+ 	
X  	optfd = 0;
X! 	t = (term_info *)GetWRefCon(HackWindow);
X! 
X! 	GetVol(name, &oldVol);
X! 	SetVol(0L, t->system.sysVRefNum);
X! 	if ( (optfd = open(OPTIONS, OMASK)) <= 0) {
X! 		SetVol(0L, t->recordVRefNum);
X! 		optfd = open(OPTIONS, OMASK);
X! 	}
X! 	if ( optfd > (short)NULL){
X  		read_opts(optfd);
X  		(void) close(optfd);
X  	}
X+ 	SetVol(0L, oldVol);
X  }
X  
X  int
X***************
X*** 394,408 ****
X  {
X  	int fd;
X  	short temp_flags;
X  
X  	if((fd = open(OPTIONS, O_WRONLY | O_BINARY)) <= 0) {
X  		OSErr	result;
X  		char	*tmp;
X  		
X! 		tmp = CtoPstr(OPTIONS);
X! 		result = Create((StringPtr)tmp, (short)0, CREATOR, AUXIL_TYPE);
X! 	 	if (result == noErr)
X! 	 		fd = open(OPTIONS, O_WRONLY | O_BINARY);
X  	 }
X  
X  	if (fd < 0)
X--- 415,437 ----
X  {
X  	int fd;
X  	short temp_flags;
X+ 	term_info	*t;
X  
X+ 	t = (term_info *)GetWRefCon(HackWindow);
X+ 	SetVol(0L, t->system.sysVRefNum);
X+ 
X  	if((fd = open(OPTIONS, O_WRONLY | O_BINARY)) <= 0) {
X  		OSErr	result;
X  		char	*tmp;
X  		
X! 		SetVol(0L, t->recordVRefNum);
X! 		if((fd = open(OPTIONS, O_WRONLY | O_BINARY)) <= 0) {
X! 			SetVol(0L, t->system.sysVRefNum);
X! 			tmp = CtoPstr(OPTIONS);
X! 			result = Create((StringPtr)tmp, (short)0, CREATOR, AUXIL_TYPE);
X! 		 	if (result == noErr)
X! 		 		fd = open(OPTIONS, O_WRONLY | O_BINARY);
X! 		}
X  	 }
X  
X  	if (fd < 0)
X***************
X*** 418,423 ****
X--- 447,454 ----
X  		
X  		temp_flags = (macflags & fZoomOnContextSwitch) ? 1 : 0;
X  		write(fd, &temp_flags, sizeof(short));
X+ 
X+ 		write(fd, &altCurs, sizeof(short));
X  	
X  #ifdef TUTTI_FRUTTI
X  		write(fd, pl_fruit, PL_FSIZ);
X***************
X*** 425,430 ****
X--- 456,464 ----
X  		write(fd, inv_order, strlen(inv_order)+1);
X  		close(fd);
X  	}
X+ 	
X+ 	SetVol(0L, t->recordVRefNum);
X+ 	
X  	return 0;
X  }
X  
X***************
X*** 448,459 ****
X  	else
X  		macflags &= ~fZoomOnContextSwitch;
X  
X  #ifdef TUTTI_FRUTTI
X  	read(fd, pl_fruit, PL_FSIZ);
X  #endif
X  	read(fd,tmp_order,strlen(inv_order)+1);
X  	if(strlen(tmp_order) == strlen(inv_order))
X! 		strcpy(inv_order,tmp_order);
X  	return 0;
X  }
X  
X--- 482,496 ----
X  	else
X  		macflags &= ~fZoomOnContextSwitch;
X  
X+ 	read(fd, &altCurs, sizeof(short));
X+ 	
X  #ifdef TUTTI_FRUTTI
X  	read(fd, pl_fruit, PL_FSIZ);
X  #endif
X  	read(fd,tmp_order,strlen(inv_order)+1);
X  	if(strlen(tmp_order) == strlen(inv_order))
X! 		Strcpy(inv_order,tmp_order);
X! 		
X  	return 0;
X  }
X  
X*** ./Old/Install.ami	Sun Jun  3 11:36:59 1990
X--- ./Install.ami	Sat Jun  2 19:45:10 1990
X***************
X*** 2,8 ****
X  	Instructions for compiling and installing NetHack 3.0
X  			on an AMIGA system
X  	=====================================================
X! 		    Last Revision: 17 Feb 1990
X  
X  Overview
X  --------
X--- 2,8 ----
X  	Instructions for compiling and installing NetHack 3.0
X  			on an AMIGA system
X  	=====================================================
X! 		    Last Revision: 27 May 1990
X  
X  Overview
X  --------
X***************
X*** 16,21 ****
X--- 16,33 ----
X      Section III and IV are compiler specific sections, with section III
X      designed for Lattice users, and section IV for Manx/Aztec users.
X  
X+ Requirements
X+ ------------
X+     Amiga 500,1000,2000,2500  running WorkBench 1.3 and KickStart 1.2 or 1.3.
X+     (As of this time, the Amiga 3000 running beta-release versions of
X+     WorkBench 2.0 are not supported.  While the core of the game appears to
X+     function, the custom font is not recognized by the operating system.
X+     The NetHack team welcomes reports of specific problems and solutions on
X+     this [or any other] subject.)
X+ 	one meg of RAM and one floppy drive (painful, but functional)
X+ or	one meg of RAM and two floppy drives (much better)
X+ or	more than one meg of RAM and a hard disk with 2+ meg free (best)
X+ 
X  Credits
X  -------
X      Olaf Seibert first ported NetHack 2.3 and 3.0 to the Amiga.  Richard
X***************
X*** 39,52 ****
X  		+ NetHack.info
X  		+ NewGame.info
X  		+ NetHackScore.info
X  		+ default.icon
X! 	* Special NetHack font.
X  
X      Installation Steps:
X  
X  	1) If you have a hard disk, create a directory named NetHack.
X  	   Assign Nethack: to be the path to this directory.  If you have a
X! 	   floppy, format a disk named NetHack.
X  
X  	2) If you have a hard disk, assign HackExe: to the above directory.
X  	   If you have a floppy, format an additional disk named HackExe.
X--- 51,67 ----
X  		+ NetHack.info
X  		+ NewGame.info
X  		+ NetHackScore.info
X+ 		+ Guidebook.info
X  		+ default.icon
X! 	* Special NetHack font (files hack.font and 8).
X  
X      Installation Steps:
X  
X  	1) If you have a hard disk, create a directory named NetHack.
X  	   Assign Nethack: to be the path to this directory.  If you have a
X! 	   floppy, format a disk named NetHack.  (If you have a hard disk
X! 	   but only one meg of memory, you will probably not have enough
X! 	   memory: you may need to run from a floppy.)
X  
X  	2) If you have a hard disk, assign HackExe: to the above directory.
X  	   If you have a floppy, format an additional disk named HackExe.
X***************
X*** 57,66 ****
X  
X  	4) Copy the remainder of the files to NetHack:.  If you are using
X  	   the optional font, create a Hack subdirectory on NetHack:, and
X! 	   copy "8" into it.
X  
X  	5) Configure NetHack.cnf as per your configuration.  Remember not
X! 	   to set GRAPHICS if you are not using the optional font.
X  
X      That's all there is to it!  If you are using the CLI interface, make sure
X      that the stack is set fairly large (at LEAST 40000 bytes).  Move to the
X--- 72,86 ----
X  
X  	4) Copy the remainder of the files to NetHack:.  If you are using
X  	   the optional font, create a Hack subdirectory on NetHack:, and
X! 	   copy "8" into it.  Be sure that Guidebook and Guidebook.info are
X! 	   in the same directory, and that the Default Tool field points to
X! 	   the More program (found on your AmigaDos System disk in the
X! 	   Utilities directory).  Depending on where you got your copy of
X! 	   NetHack, the Guidebook file may be called Guidebook.mss.
X  
X  	5) Configure NetHack.cnf as per your configuration.  Remember not
X! 	   to set GRAPHICS if you are not using the optional font.  If you
X! 	   have only one meg of ram, do not use a ram disk.
X  
X      That's all there is to it!  If you are using the CLI interface, make sure
X      that the stack is set fairly large (at LEAST 40000 bytes).  Move to the
X***************
X*** 70,81 ****
X      the WorkBench pull down menu.  This icon now represents your personal
X      profile.  You can now rename this icon, and tailor it to your liking
X      as described below.  If you start a game from the WorkBench interface,
X!     saving the game will automatically tie the personal file icon with the
X      saved game.  So the next time you select your icon, the game will be
X      restored.
X  
X      As mentioned above, the icon representing your personal profile can be
X!     customized by you.  This is done via the the Info command available from
X      WorkBench.  You can adjust the following using the ToolTypes from the
X      WorkBench info command:
X  
X--- 90,101 ----
X      the WorkBench pull down menu.  This icon now represents your personal
X      profile.  You can now rename this icon, and tailor it to your liking
X      as described below.  If you start a game from the WorkBench interface,
X!     saving the game will automatically tie the personal file icon to the
X      saved game.  So the next time you select your icon, the game will be
X      restored.
X  
X      As mentioned above, the icon representing your personal profile can be
X!     customized.  This is done via the the Info command available from
X      WorkBench.  You can adjust the following using the ToolTypes from the
X      WorkBench info command:
X  
X***************
X*** 90,101 ****
X  
X  	* PATH=<path> - To search for files such as rumors, help, etc.
X  
X! 	* CMDLINE=<args> - Arguments as passed on command line from cli.
X! 	  Note:  only the following flags are valid at this point: n, X,
X! 	  D, and r.
X  
X  	* SCORE <options> - Display the record of scores.  Options as
X! 	  available on the command line from CLI after a -s flag.
X  
X      Note that the NetHack.cnf file is read first, then the ToolTypes.  This
X      means that the options specified in the NetHack.cnf act as defaults
X--- 110,120 ----
X  
X  	* PATH=<path> - To search for files such as rumors, help, etc.
X  
X! 	* CMDLINE=<args> - Arguments as passed on the CLI command line.
X! 	  Note:  only the following flags are valid: n, X, D, and r.
X  
X  	* SCORE <options> - Display the record of scores.  Options as
X! 	  available on the CLI command line after a -s flag.
X  
X      Note that the NetHack.cnf file is read first, then the ToolTypes.  This
X      means that the options specified in the NetHack.cnf act as defaults
X***************
X*** 105,118 ****
X      default values for OPTIONS, which will generally be overridden by
X      ToolTypes entries.
X  
X  Section II - General Compilation Instructions
X  ---------------------------------------------
X  
X      1)  Before doing any compilation, read the README files distributed
X! 	with the source.  These should familiarize you with the
X! 	source tree layout, and what files are shared with what computers.
X! 	Generally, everything in the amiga directory is used exclusively by
X! 	the Amiga.
X  
X      2)  Create the sub-directories, and name them as indicated in the source
X  	README file.  If you have a hard drive, this is fairly trivial
X--- 124,142 ----
X      default values for OPTIONS, which will generally be overridden by
X      ToolTypes entries.
X  
X+     Also, there is one additional option that may be specified in the
X+     NetHack.cnf file or on an OPTIONS line: flush.  When enabled, flush
X+     discards all characters in the queue except the first, which limits
X+     but does NOT completely eliminate the "accidents" which can occur if
X+     you get ahead of the game when typing.  The default setting is noflush.
X+ 
X  Section II - General Compilation Instructions
X  ---------------------------------------------
X  
X      1)  Before doing any compilation, read the README files distributed
X! 	with the source.  These should familiarize you with the source tree
X! 	layout, and what files are shared with what computers.  Generally,
X! 	everything in the amiga directory is used exclusively by the Amiga.
X  
X      2)  Create the sub-directories, and name them as indicated in the source
X  	README file.  If you have a hard drive, this is fairly trivial
X***************
X*** 163,169 ****
X                running from CLI.
X  
X  	5) If you have significant spare ram, you may wish to make your
X! 	   compiler resident (Lattice 5.04's lc, lc1, and lc2 need about
X  	   215K while Manx's cc and as need about 135K).
X  
X  	6) At this point, you're almost ready to begin a compile.  Read VERY
X--- 187,193 ----
X                running from CLI.
X  
X  	5) If you have significant spare ram, you may wish to make your
X! 	   compiler resident (Lattice 5.05's lc, lc1, and lc2 need about
X  	   215K while Manx's cc and as need about 135K).
X  
X  	6) At this point, you're almost ready to begin a compile.  Read VERY
X***************
X*** 174,180 ****
X  	   the Amiga: directory (font and icons), define the UUDEC symbol
X  	   at the appropriate place in the makefile.  The first thing
X  	   Makefile.ami does is build a program called 'makedefs', which
X! 	   handles a variety of data file generation.  Makedefs will then be
X  	   run to create a few files, followed by an alphabetically sorted
X  	   compilation of the entire source tree.  This compilation process
X  	   will compile selected files from Amiga:, Others:, Src1:, Src2:,
X--- 198,205 ----
X  	   the Amiga: directory (font and icons), define the UUDEC symbol
X  	   at the appropriate place in the makefile.  The first thing
X  	   Makefile.ami does is build a program called 'makedefs', which
X! 	   handles a variety of data file generation, and a program called 
X! 	   'lev_comp' which compiles the special levels.  Makedefs will then be
X  	   run to create a few files, followed by an alphabetically sorted
X  	   compilation of the entire source tree.  This compilation process
X  	   will compile selected files from Amiga:, Others:, Src1:, Src2:,
X***************
X*** 181,188 ****
X  	   and Src3: directories.  If all goes well, all of the  objects will
X  	   be linked together to form a binary.  With all of the options
X  	   enabled, the Manx 3.6 executable runs about 790K, and the Lattice
X! 	   executable runs about 790K (without debug hunks, or about 1050K
X! 	   with debug hunks - see below).
X  
X  SECTION III - Lattice Compilation Instructions
X  ----------------------------------------------
X--- 206,215 ----
X  	   and Src3: directories.  If all goes well, all of the  objects will
X  	   be linked together to form a binary.  With all of the options
X  	   enabled, the Manx 3.6 executable runs about 790K, and the Lattice
X! 	   executable runs about 750K (without debug hunks, or about 1025K
X! 	   with debug hunks - see below).  After building the main binary,
X! 	   the makefile will build and install the auxiliary files including
X! 	   help files, special levels, icons, and the font files.
X  
X  SECTION III - Lattice Compilation Instructions
X  ----------------------------------------------
X***************
X*** 194,205 ****
X      onto the Ram: disk.  Read through the comments in that script if you
X      wish to utilize it.
X  
X!     Due to a problem with version 5.04, you must make one change:  edit the
X!     file Others:lev_lex.c.  At (or near) line 1002 is the definition for the
X!     function yyunput.  Delete the word "register" from this line.  Note that
X!     if you neglect to do this, you will get an Error 72 at line 318 of file
X!     lev_comp.l (this is the correct message - lev_lex.c is flex output).  Save
X!     the changed file.  Later compiler versions may or may not need this fix.
X  
X      Type 'CD NetHack:' and then type "lmk -f Amiga:Makefile.ami".  If all
X      goes well, you'll have a working binary a couple of hours later (depending
X--- 221,233 ----
X      onto the Ram: disk.  Read through the comments in that script if you
X      wish to utilize it.
X  
X!     Due to a problem with versions 5.04 and 5.05, you must make one change:
X!     edit the file Others:lev_lex.c.  At (or near) line 1002 is the definition
X!     for the function yyunput.  Delete the word "register" from this line.
X!     Note that if you neglect to do this, you will get an Error 72 at line 318
X!     of file lev_comp.l (this is the correct message - lev_lex.c is flex output).
X!     Save the changed file.  Later compiler versions may or may not need this
X!     fix.
X  
X      Type 'CD NetHack:' and then type "lmk -f Amiga:Makefile.ami".  If all
X      goes well, you'll have a working binary a couple of hours later (depending
X***************
X*** 207,221 ****
X      Lattice users on the team:
X  
X  	* The primary Lattice compiler used on the Amiga port was version
X! 	  5.04.  However, the patch bringing the compiler to 5.04a does
X! 	  not appear necessary for compiling NH3.0pl7.
X  
X  	* The function monsndx, in file mondata.c, has a section of code
X  	  which Lattice 5.04 compiles incorrectly.  A hack has been written
X  	  around this so that Lattice will generate the correct code.  It is
X  	  recommended that you leave this in place, and not attempt to
X! 	  "improve" it.  As of this date (1/90) Lattice is preparing 5.05
X! 	  which, it is being claimed, fixes this bug.
X  
X  	* Included in the Lattice port is code for generating a SnapShot.tb
X  	  file upon catching various internal disasters.  That is why the
X--- 235,248 ----
X      Lattice users on the team:
X  
X  	* The primary Lattice compiler used on the Amiga port was version
X! 	  5.05.  Previous versions of NetHack have been successfully compiled
X! 	  with 5.04 and 5.04a.
X  
X  	* The function monsndx, in file mondata.c, has a section of code
X  	  which Lattice 5.04 compiles incorrectly.  A hack has been written
X  	  around this so that Lattice will generate the correct code.  It is
X  	  recommended that you leave this in place, and not attempt to
X! 	  "improve" it.  This fix "does the right thing" in version 5.05.
X  
X  	* Included in the Lattice port is code for generating a SnapShot.tb
X  	  file upon catching various internal disasters.  That is why the
X***************
X*** 225,231 ****
X  	  fit on a single disk.
X  
X  	* The optimizer seems to work, but no extensive testing has been
X! 	  done with it.
X  
X  	* There are a large number of warnings under Lattice, which are
X  	  harmless.
X--- 252,258 ----
X  	  fit on a single disk.
X  
X  	* The optimizer seems to work, but no extensive testing has been
X! 	  done with it.  (Note: optimizing objnam.c takes several hours.)
X  
X  	* There are a large number of warnings under Lattice, which are
X  	  harmless.
X***************
X*** 301,307 ****
X  
X  	* Unfortunately, Manx 5.0 arrived too late to integrate into patch
X  	  level 7, but merging will occur in the next few weeks.  Contact us
X! 	  (below) for progress/hints.
X  
X  			- - - - - - - - - - - -
X  
X--- 328,335 ----
X  
X  	* Unfortunately, Manx 5.0 arrived too late to integrate into patch
X  	  level 7, but merging will occur in the next few weeks.  Contact us
X! 	  (below) for progress/hints.  (Postscript for PL8: the situation is
X! 	  very much improved, but there may be some problems remaining).
X  
X  			- - - - - - - - - - - -
X  
X*** ./Old/Install.unix	Sun Jun  3 11:38:30 1990
X--- ./Install.unix	Sun Apr 15 11:44:16 1990
X***************
X*** 52,58 ****
X  
X  1.  A number of systems, such as Xenix, support both the termcap and terminfo
X      terminal capability libraries.  Make sure that the TERMINFO definition in
X!     unixconf.h and the TERMLIB definition in the source Makefile correspond.
X      If spurious characters appear on the screen while kicking, zapping, etc.,
X      it is likely that you have linked the source to the wrong library or
X      mistakenly defined/undefined TERMINFO.  If your terminal library does not
X--- 52,58 ----
X  
X  1.  A number of systems, such as Xenix, support both the termcap and terminfo
X      terminal capability libraries.  Make sure that the TERMINFO definition in
X!     config.h and the TERMLIB definition in the source Makefile correspond.
X      If spurious characters appear on the screen while kicking, zapping, etc.,
X      it is likely that you have linked the source to the wrong library or
X      mistakenly defined/undefined TERMINFO.  If your terminal library does not
X***************
X*** 100,102 ****
X--- 100,109 ----
X      -DDUMB to CFLAGS and DUMB.Setup to the Sys.3B2 dependency line.  The
X      compiler provided with later versions of the OS has a large enough
X      symbol table that it does not need this workaround.
X+ 
X+ 8.  If NetHack seems to compile fine, starts up, allows you to pick a
X+     character, and then either hangs or gets a segmentation fault, you
X+     should try changing the schar and uchar definitions in config.h to
X+     short ints.  This problem is known to occur on the AT&T 3B series,
X+     Silicon Graphics Irises, and IBM PC/RT's running AIX, and may occur
X+     on other computers as well.
X*** ./Old/Makefile.top	Sun Jun  3 11:39:03 1990
X--- ./Makefile.top	Thu Mar  1 20:30:22 1990
X***************
X*** 65,71 ****
X  # copy over new versions of the game files
X  	( cd auxil ; cp $(AUX) $(GAMEDIR) )
X  #	(don't yank the old version out from under people who're playing it)
X! 	mv $(GAMEDIR)/$(GAME) $(GAMEDIR)/$(GAME).old
X  	cp src/$(GAME) $(GAMEDIR)
X  	-rm -f $(SHELLDIR)/$(GAME)
X  	sed -e 's;/usr/games/lib/nethackdir;$(GAMEDIR);' \
X--- 65,71 ----
X  # copy over new versions of the game files
X  	( cd auxil ; cp $(AUX) $(GAMEDIR) )
X  #	(don't yank the old version out from under people who're playing it)
X! 	-mv $(GAMEDIR)/$(GAME) $(GAMEDIR)/$(GAME).old
X  	cp src/$(GAME) $(GAMEDIR)
X  	-rm -f $(SHELLDIR)/$(GAME)
X  	sed -e 's;/usr/games/lib/nethackdir;$(GAMEDIR);' \
X***************
X*** 80,89 ****
X  	chgrp $(GAMEGRP) $(SHELLDIR)/$(GAME)
X  	chmod 0755 $(SHELLDIR)/$(GAME)
X  	chmod 04755 $(GAMEDIR)/$(GAME)
X! # and touch time-sensitive files
X  	-touch -c $(GAMEDIR)/bones* $(GAMEDIR)/?lock* $(GAMEDIR)/wizard*
X  	-touch -c $(GAMEDIR)/save/*
X  	touch $(GAMEDIR)/perm $(GAMEDIR)/record
X  
X  install: $(GAME) data rumors spec_levs
X  # set up the directories
X--- 80,92 ----
X  	chgrp $(GAMEGRP) $(SHELLDIR)/$(GAME)
X  	chmod 0755 $(SHELLDIR)/$(GAME)
X  	chmod 04755 $(GAMEDIR)/$(GAME)
X! # touch time-sensitive files
X  	-touch -c $(GAMEDIR)/bones* $(GAMEDIR)/?lock* $(GAMEDIR)/wizard*
X  	-touch -c $(GAMEDIR)/save/*
X  	touch $(GAMEDIR)/perm $(GAMEDIR)/record
X+ # and copy the man pages
X+ 	-$(GAMEMANCREATE) $(MANDIR)/$(GAME).$(MANEXT)
X+ 	-$(LEVMANCREATE) $(MANDIR)/lev_comp.$(MANEXT)
X  
X  install: $(GAME) data rumors spec_levs
X  # set up the directories
X*** ./Old/README	Sun Jun  3 11:39:26 1990
X--- ./README	Sun Apr 15 11:57:40 1990
X***************
X*** 77,105 ****
X  
X      At the time of this release, NetHack 3.0 is known to run on:
X  
X-         DEC vaxen running Ultrix and BSD
X-         Sun-3s running SunOS 4.0
X-         Encore Multimax running UMAX 4.2
X-         Bull XPS100 running System V R2.2 or R3.1
X-         Bull DPX/2 200 running System V R3.1
X-         AT&T 3B4000 running System V
X          AT&T 3B1 running System V (3.51)
X          AT&T 3B2/600 & 3B2/622 running System V R3.2.1
X          AT&T 3B2/1000 Model 80 running System V R3.2.2
X!         286 box running Microport SysV/AT (not extensively tested)
X!         IBM PC compatibles running MicroSoft C or Turbo C under MS-DOS
X!         IBM PS/2 and AT compatibles running MicroSoft C under OS/2
X!         Commodore Amiga running Lattice or Manx/Aztec C under
X! 		AmigaDOS 1.3 (WorkBench 1.3, KickStart 1.2 or 1.3)
X!         Atari 1040ST under TOS
X!         DEC vaxen running VMS
X!         Data General AViiON systems under DG/UX
X!         Valid Logic Systems SCALD-System
X!         Macintosh (still requires testing)
X!         Mips M2000 running RiscOS 4.1
X          Gould NP1 running UTX 3/2
X!         Stride 460 running UniStride 2.1
X          Pyramid 9820x running OSx 4.4c
X  
X  			- - - - - - - - - - -
X  
X--- 77,110 ----
X  
X      At the time of this release, NetHack 3.0 is known to run on:
X  
X          AT&T 3B1 running System V (3.51)
X          AT&T 3B2/600 & 3B2/622 running System V R3.2.1
X          AT&T 3B2/1000 Model 80 running System V R3.2.2
X!         AT&T 3B4000 running System V
X!         Bull DPX/2 200 running System V R3.1
X!         Bull XPS100 running System V R2.2 or R3.1
X!         Data General AViiON systems running DG/UX
X!         DEC vaxen running Ultrix and BSD
X!         Decstation 5400 running Ultrix 3.1
X!         Encore Multimax running UMAX 4.2
X          Gould NP1 running UTX 3/2
X!         H-P 9000s300 running HP-UX
X!         IBM PC/RT running AIX
X!         Mips M2000 running RiscOS 4.1
X          Pyramid 9820x running OSx 4.4c
X+         SGI Iris running IRIX
X+         Stride 460 running UniStride 2.1
X+         Sun-3s and -4s running SunOS 3.x and 4.0.x
X+         Valid Logic Systems SCALD-System
X+         286 box running Microport SysV/AT (not extensively tested)
X+ 
X+         Apple Macintosh running MacOS
X+         Atari 1040ST running TOS
X+         Commodore Amiga running AmigaDOS 1.3 (WorkBench 1.3,
X+                 KickStart 1.2 or 1.3) with Lattice or Manx/Aztec C
X+         DEC vaxen running VMS
X+         IBM PC compatibles running MS-DOS with MicroSoft C or Turbo C
X+         IBM PS/2 and AT compatibles running OS/2 with MicroSoft C
X  
X  			- - - - - - - - - - -
X  
X***************
X*** 107,112 ****
X--- 112,119 ----
X  development team may be reached as
X   
X  		    nethack-bugs@linc.cis.upenn.edu.  
X+ 
X+ Please be sure to include your machine type, OS, and patchlevel.
X  
X  Patches especially should be directed to this address.  If you've changed 
X  something to get NetHack to run on your system, it's likely that others have
X
END_OF_FILE
if test 50401 -ne `wc -c <'patch8.11'`; then
    echo shar: \"'patch8.11'\" unpacked with wrong size!
fi
# end of 'patch8.11'
fi
echo shar: End of archive 11 \(of 24\).
cp /dev/null ark11isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 24 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
