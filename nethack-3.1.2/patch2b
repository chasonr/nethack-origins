Path: uunet!news.tek.com!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v17i077:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Patch2b/33
Date: 11 Jun 1993 00:05:10 GMT
Organization: Tektronix, Inc, Redmond, OR, USA
Lines: 2477
Approved: billr@saab.CNA.TEK.COM
Message-ID: <1v8i7m$iou@ying.cna.tek.com>
NNTP-Posting-Host: saab.cna.tek.com
Xref: uunet comp.sources.games:1756

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 17, Issue 77
Archive-name: nethack31/Patch2b
Patch-To: nethack31: Volume 16, Issue 1-116
Environment: Amiga, Atari, Mac, MS-DOS, Windows-NT, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 2 (of 33)."
# Contents:  patches02m
# Wrapped by billr@saab on Thu Jun 10 16:54:59 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'patches02m' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'patches02m'\" to \"'patches02m.orig'\"
  mv -f 'patches02m' 'patches02m.orig'
fi
echo shar: Extracting \"'patches02m'\" \(58318 characters\)
sed "s/^X//" >'patches02m' <<'END_OF_FILE'
X*** /tmp/da11960	Tue Jun  1 17:01:06 1993
X--- sys/amiga/wb.c	Tue Jun  1 12:12:58 1993
X***************
X*** 10,15 ****
X--- 10,17 ----
X  # define __chip
X  #endif
X  
X+ #include "incl:patchlevel.h"
X+ 
X  #include "Amiga:wbdefs.h"		/* Miscellany information */
X  #ifdef  INTUI_NEW_LOOK
X  #define NewWindow   ExtNewWindow
X***************
X*** 84,97 ****
X      struct IntuiMessage mimsg;
X      int i;
X  
X!     ZapOptions( curopts );
X      InitWB( argc, argv );
X!     SetupWB( ); /* open window, build menus */
X!     errmsg( NO_FLASH, "Welcome to NetHack Version 3.1.1!" );
X      CopyRight( );
X  
X      ReadConfig( );
X-     LoadDefaults( defgname );
X  
X      /* Initially, no game selected so disable menu items */
X  
X--- 86,103 ----
X      struct IntuiMessage mimsg;
X      int i;
X  
X!     /* Initialize and load libraries. */
X      InitWB( argc, argv );
X! 
X!     /* open window, build menus */
X!     SetupWB( );
X! 
X!     errmsg( NO_FLASH, "Welcome to NetHack Version %d.%d.%d!",
X!       VERSION_MAJOR, VERSION_MINOR, PATCHLEVEL );
X! 
X      CopyRight( );
X  
X      ReadConfig( );
X  
X      /* Initially, no game selected so disable menu items */
X  
X***************
X*** 111,124 ****
X  
X  	rmask = Wait( mask );
X  
X- 	/* If displayed an error message before, clear it */
X- 
X- 	if( errup )
X- 	{
X- 	    errmsg( NO_FLASH, "" );
X- 	    errup = 0;
X- 	}
X- 
X  	/* Process the messages on the port unless the workbench is
X  	 * shutdown by a request to play a game.
X  	 */
X--- 117,122 ----
X***************
X*** 150,156 ****
X  		break;
X  
X  	    case MENUPICK:
X! 		do_menu( mimsg.Code );
X  		flushIDCMP( win->UserPort );
X  		break;
X  
X--- 148,159 ----
X  		break;
X  
X  	    case MENUPICK:
X! 		if( errup > 0 )
X! 		{
X! 		    errmsg( NO_FLASH, "" );
X! 		    errup = -1;
X! 		}
X! 		do_menu( &MenuList1, mimsg.Code );
X  		flushIDCMP( win->UserPort );
X  		break;
X  
X***************
X*** 157,162 ****
X--- 160,171 ----
X  	    case RAWKEY:
X  		if( mimsg.Code == 0x5f )
X  		{
X+ 		    if( errup > 0 )
X+ 		    {
X+ 			errmsg( NO_FLASH, "" );
X+ 			errup = -1;
X+ 		    }
X+ 
X  		    /* Pick the correct help message */
X  
X  		    if( lastgaddown == NULL )
X***************
X*** 179,184 ****
X--- 188,198 ----
X  		break;
X  
X  	    case GADGETDOWN:
X+ 		if( errup > 0 )
X+ 		{
X+ 		    errmsg( NO_FLASH, "" );
X+ 		    errup = -1;
X+ 		}
X  		do_gadgetdown( &mimsg );
X  		break;
X  
X***************
X*** 187,201 ****
X--- 201,227 ----
X  		break;
X  
X  	    case DISKINSERTED:
X+ 		if( errup > 0 )
X+ 		{
X+ 		    errmsg( NO_FLASH, "" );
X+ 		    errup = -1;
X+ 		}
X  		MapGadgets( R_DISK, 1 );
X  		break;
X  
X  	    case MOUSEBUTTONS:
X+ 		if( errup > 0 )
X+ 		{
X+ 		    errmsg( NO_FLASH, "" );
X+ 		    errup = -1;
X+ 		}
X  		do_buttons( &mimsg );
X  		flushIDCMP( win->UserPort );
X  		break;
X  	    }
X  	}
X+ 	if( errup == -1 )
X+ 	    errup = 0;
X  
X  	if( rmask & ( 1L << dosport->mp_SigBit ) )
X  	{
X***************
X*** 258,265 ****
X--- 284,294 ----
X  	struct MsgPort *port;
X  {
X  	struct Message *msg;
X+ 
X  	while( msg = GetMsg( port ) )
X  		ReplyMsg( msg );
X+ 
X+ 	SetSignal( 0L, ( 1L << port->mp_SigBit ) );
X  }
X  
X  void CopyRight( )
X***************
X*** 323,328 ****
X--- 352,358 ----
X  	argv = (char **)wbs;
X  	for( i = 1; i < argc; ++i )
X  	{
X+ 	    if( argv[i][0] == '?' )goto usage;
X  	    if( argv[i][0] != '-' )
X  		break;
X  	    for( j = 1; c = argv[i][j]; ++j )
X***************
X*** 378,387 ****
X  			    cleanup( 1 );
X  		    }
X  		    break;
X- 
X  		default:
X  		    fprintf( stderr, "%s: invalid option %c\n",
X  			argv[0], c );
X  		    fprintf( stderr,
X  "usage: %s [-m] [-f .def filename] [-c config filename] [ -N screen]\n",
X  			argv[ 0 ] );
X--- 408,417 ----
X  			    cleanup( 1 );
X  		    }
X  		    break;
X  		default:
X  		    fprintf( stderr, "%s: invalid option %c\n",
X  			argv[0], c );
X+ usage:
X  		    fprintf( stderr,
X  "usage: %s [-m] [-f .def filename] [-c config filename] [ -N screen]\n",
X  			argv[ 0 ] );
X***************
X*** 557,563 ****
X      NewScreenStructure.Width = GfxBase->NormalDisplayColumns;
X      NewScreenStructure.Height = GfxBase->NormalDisplayRows;
X  
X!     NewScreenStructure.DefaultTitle = "WorkBench for V3.1.1 of NetHack";
X  
X  #ifdef  INTUI_NEW_LOOK
X      if( IntuitionBase->LibNode.lib_Version < 37 )
X--- 587,598 ----
X      NewScreenStructure.Width = GfxBase->NormalDisplayColumns;
X      NewScreenStructure.Height = GfxBase->NormalDisplayRows;
X  
X!     {
X!     static char dt[40];
X!     sprintf(dt,"WorkBench for V%d.%d.%d of NetHack",
X!       VERSION_MAJOR, VERSION_MINOR, PATCHLEVEL );
X!     NewScreenStructure.DefaultTitle = dt;
X!     }
X  
X  #ifdef  INTUI_NEW_LOOK
X      if( IntuitionBase->LibNode.lib_Version < 37 )
X***************
X*** 583,596 ****
X  	{
X  	    if( ( scrn = LockPubScreen( pubscreen ) ) == 0 )
X  	    {
X  		scrntags[1].ti_Tag = SA_PubName;
X  		scrntags[1].ti_Data = (ULONG) pubscreen;
X  		scrntags[2].ti_Tag = TAG_DONE;
X  		if( ( scrn = OpenScreen( (void *)
X  		    &NewScreenStructure ) ) == NULL )
X  		{
X! 		    error( "Can't create screen" );
X! 		    cleanup( 1 );
X  		}
X  		pubopen = 1;
X  		scrlocked = 0;
X--- 618,653 ----
X  	{
X  	    if( ( scrn = LockPubScreen( pubscreen ) ) == 0 )
X  	    {
X+ 		/* Now add our pub screen name */
X  		scrntags[1].ti_Tag = SA_PubName;
X  		scrntags[1].ti_Data = (ULONG) pubscreen;
X  		scrntags[2].ti_Tag = TAG_DONE;
X+ 
X+ 		/* Get the default pub screen's size */
X+ 		scrn = LockPubScreen( NULL );
X+ 		NewScreenStructure.Height = scrn->Height;
X+ 		NewScreenStructure.Width = scrn->Width;
X+ 		UnlockPubScreen( NULL, scrn );
X+ 
X+ 		/* Request LACE if it looks laced.  For 2.1/3.0, we will get
X+ 		 * promoted to the users choice of modes (if promotion is alloed)
X+ 		 * which is best to avoid extra coding involving copying of the
X+ 		 * viewport modes etc.
X+ 		 */
X+ 		if( NewScreenStructure.Height > 300 )
X+ 			NewScreenStructure.ViewModes |= LACE;
X+ 
X  		if( ( scrn = OpenScreen( (void *)
X  		    &NewScreenStructure ) ) == NULL )
X  		{
X! 		    NewScreenStructure.Height = GfxBase->NormalDisplayRows;
X! 		    NewScreenStructure.Width = GfxBase->NormalDisplayColumns;
X! 		    if( ( scrn = OpenScreen( (void *)
X! 			&NewScreenStructure ) ) == NULL )
X! 		    {
X! 			error( "Can't create screen" );
X! 			cleanup( 1 );
X! 		    }
X  		}
X  		pubopen = 1;
X  		scrlocked = 0;
X***************
X*** 644,650 ****
X  
X  #ifdef  INTUI_NEW_LOOK
X      if( scrlocked )
X! 	strcpy( mytitle, "NetHack WB 3.1.1 - Select a GAME or press HELP" );
X      else
X  	strcpy( mytitle, "Select a GAME or press HELP" );
X  
X--- 701,709 ----
X  
X  #ifdef  INTUI_NEW_LOOK
X      if( scrlocked )
X! 	sprintf( mytitle, "NetHack WB %d.%d.%d - Select a GAME or press HELP",
X! 	  VERSION_MAJOR, VERSION_MINOR, PATCHLEVEL );
X! 
X      else
X  	strcpy( mytitle, "Select a GAME or press HELP" );
X  
X***************
X*** 682,687 ****
X--- 741,750 ----
X  #ifdef  INTUI_NEW_LOOK
X      if( IntuitionBase->LibNode.lib_Version >= 37 )
X      {
X+ 	/* If we did not create this screen, unlock it.
X+ 	 * otherwise, advertise it for other applications
X+ 	 * to use.
X+ 	 */
X  	if( scrlocked )
X  	    UnlockPubScreen( NULL, scrn );
X  	else if( pubopen )
X***************
X*** 1070,1076 ****
X  	Help3_NewWindowStructure10.Height += txtdiff;
X      }
X  
X!     Help3_NewWindowStructure10.Title = "Help for NetHack WorkBench V3.1.1";
X      Help3_NewWindowStructure10.Screen = scrn;
X      if( ( win = MyOpenWindow( &Help3_NewWindowStructure10 ) ) == NULL )
X      {
X--- 1133,1145 ----
X  	Help3_NewWindowStructure10.Height += txtdiff;
X      }
X  
X!     {
X!     static char title[40];
X!     sprintf(title,"Help for NetHack WorkBench V%d.%d.%d",
X!       VERSION_MAJOR, VERSION_MINOR, PATCHLEVEL );
X!     Help3_NewWindowStructure10.Title = title;
X!     }
X! 
X      Help3_NewWindowStructure10.Screen = scrn;
X      if( ( win = MyOpenWindow( &Help3_NewWindowStructure10 ) ) == NULL )
X      {
X***************
X*** 1204,1277 ****
X  /* Act on the menu item number passed */
X  
X  void
X! do_menu(mcode)
X      register int mcode;
X  {
X!     switch(MENUNUM(mcode))
X      {
X! 	case MENU_PROJECT:
X! 	    switch(ITEMNUM(mcode))
X! 	    {
X! 		case ITEM_HELP:
X! 		    help_requester( "NetHack:HackWB.hlp" );
X! 		    break;
X  
X! 		case ITEM_ABOUT:
X! 		    text_requester( &About_NewWindowStructure9,
X! 			    &About_IntuiTextList9 );
X! 		    break;
X  
X! 		case ITEM_SCORES:
X! 		    menu_scores( );
X! 		    break;
X  
X! 		case ITEM_RECOVER:
X! 		    menu_recover( );
X! 		    break;
X  
X! 		case ITEM_EDDEF:
X! 		    menu_editdef( GAME_FROM_DEFAULT );
X! 		    break;
X  
X! 		case ITEM_CONFIG:
X! 		    menu_config( );
X! 		    break;
X  
X! 		case ITEM_QUIT:
X! 		    quit = Ask( "Ready to Quit?" );
X! 		    break;
X  
X! 	    }
X! 	    break;
X  
X! 	case MENU_GAME:
X! 	    switch( ITEMNUM( mcode ) )
X! 	    {
X  
X! 		case ITEM_INFO:
X! 		    menu_info( );
X! 		    break;
X  
X! 		case ITEM_SETCOMMENT:
X! 		    menu_comment( );
X! 		    break;
X  
X! 		case ITEM_SETOPT:
X! 		    menu_setopt( );
X! 		    break;
X! 
X! 		case ITEM_COPYOPT:
X! 		    menu_copyopt( );
X! 		    break;
X! 
X! 		case ITEM_DISCARD:
X! 		    menu_discard( );
X! 		    break;
X! 
X! 		case ITEM_RENAME:
X! 		    menu_rename( );
X! 		    break;
X! 	    }
X      }
X  }
X  
X--- 1273,1339 ----
X  /* Act on the menu item number passed */
X  
X  void
X! do_menu( mptr, mcode)
X!     struct Menu *mptr;
X      register int mcode;
X  {
X!     while( mcode != MENUNULL )
X      {
X! 	switch(MENUNUM(mcode))
X! 	{
X! 	    case MENU_PROJECT:
X! 		switch(ITEMNUM(mcode))
X! 		{
X! 		    case ITEM_HELP:
X! 			help_requester( "NetHack:HackWB.hlp" );
X! 			break;
X  
X! 		    case ITEM_ABOUT:
X! 			text_requester( &About_NewWindowStructure9,
X! 				&About_IntuiTextList9 );
X! 			break;
X  
X! 		    case ITEM_SCORES:
X! 			menu_scores( );
X! 			break;
X  
X! 		    case ITEM_RECOVER:
X! 			menu_recover( );
X! 			break;
X  
X! 		    case ITEM_CONFIG:
X! 			menu_config( );
X! 			break;
X  
X! 		    case ITEM_QUIT:
X! 			quit = Ask( "Ready to Quit?" );
X! 			break;
X  
X! 		}
X! 		break;
X  
X! 	    case MENU_GAME:
X! 		switch( ITEMNUM( mcode ) )
X! 		{
X  
X! 		    case ITEM_INFO:
X! 			menu_info( );
X! 			break;
X  
X! 		    case ITEM_COPYOPT:
X! 			menu_copyopt( );
X! 			break;
X  
X! 		    case ITEM_DISCARD:
X! 			menu_discard( );
X! 			break;
X  
X! 		    case ITEM_RENAME:
X! 			menu_rename( );
X! 			break;
X! 		}
X! 	}
X!         mcode = ((struct MenuItem *)ItemAddress( mptr, (long)mcode ))->NextSelect;
X      }
X  }
X  
X***************
X*** 1300,1308 ****
X  run_game( gptr )
X      register GPTR gptr;
X  {
X      struct Task *ctask;
X      register struct MsgPort *proc = NULL;
X!     char buf[ 100 ], *t;
X      char namebuf[ 100 ];
X      int once, tidx;
X  
X--- 1362,1371 ----
X  run_game( gptr )
X      register GPTR gptr;
X  {
X+     extern UWORD __chip waitPointer[];
X      struct Task *ctask;
X      register struct MsgPort *proc = NULL;
X!     char buf[ 100 ];
X      char namebuf[ 100 ];
X      int once, tidx;
X  
X***************
X*** 1318,1340 ****
X  
X      if( gptr->dobj->do_Gadget.GadgetID == GADNEWGAME )
X      {
X- 	    /*
X- 	    if currrent name in use, get new name
X- 	    */
X- 
X- 	if( !defgame.plname )
X- 	    defgame.plname = strdup( defgname );
X- 
X- 	/* Put options from gadgets into options[ OPTIONS_IDX ] */
X- 
X- 	PutOptions( curopts );
X- 
X  	once = 0;
X! 	sprintf( buf, "%s/%s.sav", options[ SAVE_IDX ], defgame.plname );
X  	while( access( buf, 0 ) == 0 )
X  	{
X  	    if( StrRequest( "Game Already Exists, Enter a New Name",
X! 		namebuf, once ? namebuf : defgame.plname ) == 0 )
X  	    {
X  		return;
X  	    }
X--- 1381,1392 ----
X  
X      if( gptr->dobj->do_Gadget.GadgetID == GADNEWGAME )
X      {
X  	once = 0;
X! 	sprintf( buf, "%s/%s.sav", options[ SAVE_IDX ], gptr->name );
X  	while( access( buf, 0 ) == 0 )
X  	{
X  	    if( StrRequest( "Game Already Exists, Enter a New Name",
X! 		namebuf, once ? namebuf : gptr->gname ) == 0 )
X  	    {
X  		return;
X  	    }
X***************
X*** 1341,1386 ****
X  	    once = 1;
X  	    sprintf( buf, "%s/%s.sav", options[ SAVE_IDX ], namebuf );
X  	}
X- 
X- 	/* Set new name to use, if done one at all */
X- 	if( once )
X- 	{
X- 	    if( defgame.plname ) free( defgame.plname );
X- 	    defgame.plname = strdup( namebuf );
X- 	}
X- 
X- 	    /* set defaults for this game from previous defaults. */
X- 	if( defgame.plname && stricmp( defgame.plname, "wbdefaults" ) )
X- 	    SetToolLine( gptr, "NAME", defgame.plname );
X- 	if( defgame.pltype )
X- 	    SetToolLine( gptr, "CHARACTER", players[ defgame.pltype ] );
X- 
X- 	gptr->gname = xmalloc( 20 + strlen( defgame.plname ) );
X      }
X!     else
X!     {
X! 	gptr->gname = xmalloc( 20 + strlen( gptr->name ) );
X!     }
X  
X!     SetToolLine( gptr, "PATH", options[ PATH_IDX ] );
X!     if( defgame.options )
X! 	SetToolLine( gptr, "OPTIONS", defgame.options );
X!     else
X! 	SetToolLine( gptr, "OPTIONS", options[ OPTIONS_IDX ] );
X  
X-     /* Prefer a setting in the users data over the global one */
X-     if( ( ( t = ToolsEntry( gptr, "PENS" ) ) == NULL || *t == 0 ) &&
X-       ( ( t = ToolsEntry( gptr, "PEN" ) ) == NULL || *t == 0 ) )
X-     {
X- 	t = options[ PENS_IDX ];
X-     }
X-     SetToolLine( gptr, "PENS", t );
X-     SetToolLine( gptr, "HACKDIR", options[ HACKDIR_IDX ] );
X-     SetToolLine( gptr, "LEVELS", options[ LEVELS_IDX ] );
X-     SetToolLine( gptr, "SAVE", options[ SAVE_IDX ] );
X- 
X      gptr->wbs = AllocMem( sizeof( struct WBStartup ) +
X!     ( sizeof( struct WBArg ) * 2 ), MEMF_PUBLIC | MEMF_CLEAR );
X  
X      /* Check if we got everything */
X  
X--- 1393,1408 ----
X  	    once = 1;
X  	    sprintf( buf, "%s/%s.sav", options[ SAVE_IDX ], namebuf );
X  	}
X      }
X!     gptr->gname = xmalloc( 20 + strlen( gptr->name ) );
X  
X!     /*
X!      * options[] are no longer put into the tooltypes because they are in the options
X!      * string now.
X!      */
X  
X      gptr->wbs = AllocMem( sizeof( struct WBStartup ) +
X! 	    ( sizeof( struct WBArg ) * 2 ), MEMF_PUBLIC | MEMF_CLEAR );
X  
X      /* Check if we got everything */
X  
X***************
X*** 1400,1422 ****
X      if( shutdown )
X  	CloseDownWB( );
X  
X      /* Load the game into memory */
X  #ifdef SPLIT
X      /* Which version do we run? */
X      {
X!     char gi[80];
X  
X!     sprintf( gi, "%s.dir", GAMEIMAGE );
X!     if( access( gi, 0 ) == 0 ){
X! 	gptr->seglist = (BPTR)s_LoadSeg( gi );
X! 	if( gptr->seglist ) running_split=1;
X!     }else{
X! 	gptr->seglist = (BPTR)LoadSeg( GAMEIMAGE );
X      }
X-     }
X  #else
X      gptr->seglist = (BPTR)LoadSeg( GAMEIMAGE );
X  #endif
X  
X      if( gptr->seglist == NULL)
X      {
X--- 1422,1448 ----
X      if( shutdown )
X  	CloseDownWB( );
X  
X+     SetPointer( win, waitPointer, 16, 16, -6, 0 );
X+ 
X      /* Load the game into memory */
X+ 
X  #ifdef SPLIT
X      /* Which version do we run? */
X      {
X! 	char gi[80];
X  
X! 	sprintf( gi, "%s.dir", GAMEIMAGE );
X! 	if( access( gi, 0 ) == 0 ){
X! 	    gptr->seglist = (BPTR)s_LoadSeg( gi );
X! 	    if( gptr->seglist ) running_split=1;
X! 	}else{
X! 	    gptr->seglist = (BPTR)LoadSeg( GAMEIMAGE );
X! 	}
X      }
X  #else
X      gptr->seglist = (BPTR)LoadSeg( GAMEIMAGE );
X  #endif
X+     ClearPointer( win );
X  
X      if( gptr->seglist == NULL)
X      {
X***************
X*** 1429,1435 ****
X  
X      /* Set the game name for the status command */
X  
X!     sprintf( gptr->gname, "NetHack 3.1.1 %s", gptr->name );
X  
X      /* Create a process for the game to execute in */
X  
X--- 1455,1462 ----
X  
X      /* Set the game name for the status command */
X  
X!     sprintf( gptr->gname, "NetHack %d.%d.%d %s",
X!       VERSION_MAJOR, VERSION_MINOR, PATCHLEVEL, gptr->name );
X  
X      /* Create a process for the game to execute in */
X  
X***************
X*** 1471,1477 ****
X      gptr->wbs->sm_Process = proc;
X      gptr->wbs->sm_Segment = gptr->seglist;
X      gptr->wbs->sm_NumArgs = 2;
X!     gptr->wbs->sm_ToolWindow = "con:0/0/350/50/Amiga NetHack 3.1.1";
X      gptr->wbs->sm_ArgList = gptr->wba;
X  
X      /* Fill in the args */
X--- 1498,1509 ----
X      gptr->wbs->sm_Process = proc;
X      gptr->wbs->sm_Segment = gptr->seglist;
X      gptr->wbs->sm_NumArgs = 2;
X!     {
X!     static char tw[40];
X!     sprintf(tw,"con:0/0/350/50/Amiga NetHack %d.%d.%d",
X!       VERSION_MAJOR, VERSION_MINOR, PATCHLEVEL );
X!     gptr->wbs->sm_ToolWindow = tw;
X!     }
X      gptr->wbs->sm_ArgList = gptr->wba;
X  
X      /* Fill in the args */
X***************
X*** 1649,1656 ****
X  
X      /* Check if we can access the new save directory */
X  
X!     if( ( savedir = Lock( options[ SAVE_IDX ], ACCESS_READ ) ) == NULL )
X      {
X  	errmsg( FLASH,
X  		"Can't access save directory: %s", options[ SAVE_IDX ] );
X  	return;
X--- 1681,1701 ----
X  
X      /* Check if we can access the new save directory */
X  
X!     if( t = strchr( options[ SAVE_IDX ], ';' ) )
X      {
X+ 	strncpy( buf, options[ SAVE_IDX ], sizeof( buf ) - 1 );
X+ 	buf[ sizeof( buf ) - 1 ] = 0;
X+ 	if( ( t = strchr( buf, ';' ) ) && strcmp( t, ";n" ) == 0 )
X+ 	    *t = 0;
X+ 	if( ( savedir = Lock( buf, ACCESS_READ ) ) == NULL )
X+ 	{
X+ 	    errmsg( FLASH,
X+ 		    "Can't access save directory: %s", buf );
X+ 	    return;
X+ 	}
X+     }
X+     else if( ( savedir = Lock( options[ SAVE_IDX ], ACCESS_READ ) ) == NULL )
X+     {
X  	errmsg( FLASH,
X  		"Can't access save directory: %s", options[ SAVE_IDX ] );
X  	return;
X***************
X*** 1664,1671 ****
X  	return;
X      }
X  
X!     if( newgame = gamehead )
X  	gamehead = gamehead->next;
X  
X      if( !Examine( savedir, finfo ) )
X      {
X--- 1709,1718 ----
X  	return;
X      }
X  
X!     if( ( newgame = gamehead ) && newgame->dobj->do_Gadget.GadgetID == GADNEWGAME )
X  	gamehead = gamehead->next;
X+     else
X+ 	newgame = NULL;
X  
X      if( !Examine( savedir, finfo ) )
X      {
X***************
X*** 1752,1758 ****
X  
X      if( !once )
X      {
X! 	for( gd = Rst_NewWindowStructure12.FirstGadget;
X  		    gd; gd = gd->NextGadget )
X  	{
X  	    switch( gd->GadgetID )
X--- 1799,1805 ----
X  
X      if( !once )
X      {
X! 	for( gd = Rst_NewWindowStructure11.FirstGadget;
X  		    gd; gd = gd->NextGadget )
X  	{
X  	    switch( gd->GadgetID )
X***************
X*** 1786,1793 ****
X  		    break;
X  	    }
X  	}
X! 	Rst_NewWindowStructure12.Height += txtdiff*5;
X! 	for( ip = &Rst_IntuiTextList12; ip; ip = ip->NextText )
X  	{
X  	    if( *ip->IText == 'O' )
X  		ip->TopEdge += txtdiff;
X--- 1833,1840 ----
X  		    break;
X  	    }
X  	}
X! 	Rst_NewWindowStructure11.Height += txtdiff*5;
X! 	for( ip = &Rst_IntuiTextList11; ip; ip = ip->NextText )
X  	{
X  	    if( *ip->IText == 'O' )
X  		ip->TopEdge += txtdiff;
X***************
X*** 1797,1809 ****
X  	once = 1;
X      }
X  
X!     Rst_NewWindowStructure12.Screen = scrn;
X!     if( ( w = MyOpenWindow( &Rst_NewWindowStructure12 ) ) == NULL )
X      {
X  	errmsg( FLASH, "Can't create requester window" );
X  	return;
X      }
X!     PrintIText( w->RPort, &Rst_IntuiTextList12, 0, txtdiff );
X      lastact = FindGadget( w, NULL, GADRESTDIR );
X  
X      while( !done )
X--- 1844,1856 ----
X  	once = 1;
X      }
X  
X!     Rst_NewWindowStructure11.Screen = scrn;
X!     if( ( w = MyOpenWindow( &Rst_NewWindowStructure11 ) ) == NULL )
X      {
X  	errmsg( FLASH, "Can't create requester window" );
X  	return;
X      }
X!     PrintIText( w->RPort, &Rst_IntuiTextList11, 0, txtdiff );
X      lastact = FindGadget( w, NULL, GADRESTDIR );
X  
X      while( !done )
X***************
X*** 1878,1883 ****
X--- 1925,1931 ----
X      register struct Gadget *gd;
X      static int once = 0;
X      int txtdiff = scrn->RastPort.TxHeight - 8;
X+     char *env;
X  
X      strcpy( StrPath, options[ PATH_IDX ] );
X      strcpy( StrHackdir, options[ HACKDIR_IDX ] );
X***************
X*** 2050,2055 ****
X--- 2098,2108 ----
X  
X  			case GADCONFLOAD:
X  			    ReadConfig( );
X+                             env = malloc( strlen( StrConf ) + 3 +
X+ 						strlen( "NETHACKOPTIONS" ) );
X+ 			    sprintf( env, "NETHACKOPTIONS=@%s", StrConf );
X+ 			    putenv( env );
X+ 			    free( env );
X  			    strcpy( StrPath, options[ PATH_IDX ] );
X  			    strcpy( StrHackdir, options[ HACKDIR_IDX ] );
X  			    strcpy( StrPens, options[ PENS_IDX ] );
X***************
X*** 2064,2070 ****
X          		    	char buf[ 300 ], *t, nname[ 100 ], oname[100], *b;
X  
X                                  setoneopt( PATH_IDX, StrPath );
X-                                 PutOptions( curopts );
X                                  setoneopt( HACKDIR_IDX, StrHackdir );
X                                  setoneopt( PENS_IDX, StrPens );
X                                  setoneopt( LEVELS_IDX, StrLevels );
X--- 2117,2122 ----
X***************
X*** 2142,2148 ****
X      }
X  
X      setoneopt( PATH_IDX, StrPath );
X-     PutOptions( curopts );
X      setoneopt( HACKDIR_IDX, StrHackdir );
X      setoneopt( PENS_IDX, StrPens );
X      setoneopt( LEVELS_IDX, StrLevels );
X--- 2194,2199 ----
X***************
X*** 2242,2468 ****
X      rename( "new_nethack.cnf", "nethack.cnf" );
X  }
X  
X- void menu_editdef( gametype )
X-     int gametype;
X- {
X-     register struct Window *cwin;
X-     int done = 0, err;
X-     USHORT mcode;
X-     long class, qual, code;
X-     register struct IntuiMessage *imsg;
X-     register struct Gadget *gd;
X-     char buf[ 100 ];
X-     struct IntuiText *ip;
X-     static int once = 0;
X-     int txtdiff = scrn->RastPort.TxHeight - 8;
X-     register GPTR gptr;
X- 
X-     /* If gametype indicates an INFO request... */
X-     if( gametype == GAME_FROM_INFO )
X-     {
X- 	register char *t;
X- 
X- 	if( ( gptr = NeedGame() ) == NULL )
X- 	{
X- 	    errmsg( FLASH, "No Game selected to edit options for" );
X- 	    return;
X- 	}
X- 
X- 	strcpy( DefOutFile, gptr->name );
X- 	if( ( t = strrchr( DefOutFile, '.' ) ) &&
X- 		stricmp( t, ".sav" ) == 0 )
X- 	{
X- 	    *t = 0;
X- 	}
X- 	LoadDefaults( DefOutFile );
X-     }
X-     else /* if( gametype == GAME_FROM_DEFAULT ) */
X-     {
X- 	/* Find the newgame gadget... */
X- 
X- 	for( gptr = windowgads; gptr; gptr = gptr->nextwgad )
X- 	{
X- 	    if( gptr->dobj->do_Gadget.GadgetID == GADNEWGAME )
X- 		break;
X- 	}
X- 
X- 	if( !gptr )
X- 	{
X- 	    errmsg( FLASH, "Can't find NewGame information" );
X- 	    return;
X- 	}
X- 
X- 	strcpy( DefOutFile, defgname );
X- 	LoadDefaults( DefOutFile );
X-     }
X- 
X-     /* Copy the defgame.* date into the Defs_ window gadgets */
X-     CopyDefs2Gad();
X- 
X-     /* Do one time window setup and initialization */
X- 
X-     if( !once )
X-     {
X- 	/* Rearrange the gadgets based on fonts text height */
X- 
X- 	for( gd = Defs_NewWindowStructure11.FirstGadget;
X- 		gd; gd = gd->NextGadget )
X- 	{
X- 	    if( gd->GadgetID != 0 )
X- 	    {
X- 		gd->TopEdge += txtdiff;
X- 		gd->Height += txtdiff;
X- 		switch( gd->GadgetID )
X- 		{
X- 		    case GADOUTFILE:
X- 			gd->TopEdge += txtdiff;
X- 			break;
X- 		    case GADDEFLOAD:
X- 		    case GADDEFSAVE:
X- 		    case GADEDOPTIONS:
X- 			gd->TopEdge += txtdiff * 3;
X- 			break;
X- 		    default:
X- 			if( ( gd->Flags & GADGHIGHBITS ) == GADGHNONE )
X- 			    gd->TopEdge += txtdiff * 2;
X- 			break;
X- 		}
X- 		SetBorder( gd, -1 );
X- 	    }
X- 	}
X- 
X- 	/* Move the text down as appropriate */
X- 
X- 	for( ip = &Defs_IntuiTextList11; ip; ip = ip->NextText )
X- 	{
X- 	    if( *ip->IText == 'C' )
X- 		ip->TopEdge += txtdiff * 2;
X- 	    else if( *ip->IText == 'O' )
X- 		ip->TopEdge += txtdiff;
X- 	}
X- 
X- 	/* Adjust the height of the window */
X- 	Defs_NewWindowStructure11.Height += txtdiff * 5;
X- 	++once;
X-     }
X- 
X-     Defs_NewWindowStructure11.Screen = scrn;
X- 
X-     /* Set Correct title */
X-     if( gametype == GAME_FROM_DEFAULT )
X- 	Defs_NewWindowStructure11.Title = "Edit Default Game Definition";
X-     else if( gametype == GAME_FROM_INFO )
X- 	Defs_NewWindowStructure11.Title = "Edit Game Definition";
X-     else
X-     {
X- 	errmsg( FLASH, "Can't edit game of type %d", gametype );
X- 	return;
X-     }
X- 
X-     if( ( cwin = MyOpenWindow( &Defs_NewWindowStructure11 ) ) == NULL )
X-     {
X- 	errmsg( FLASH, "Can't create requester window" );
X- 	return;
X-     }
X- 
X-     PrintIText( cwin->RPort, &Defs_IntuiTextList11, 0, txtdiff );
X-     UpdateTypes( cwin );
X- 
X-     /* Do Menu Layouts Based on FontHeight */
X-     SetUpMenus( &Defs_MenuList11, scrn );
X-     SetMenuStrip( cwin, &Defs_MenuList11 );
X- 
X-     /* Process messages */
X-     while( !done )
X-     {
X- 	WaitPort( cwin->UserPort );
X- 	while( ( imsg = (void *) GetMsg( cwin->UserPort ) ) != NULL )
X- 	{
X- 	    mcode = imsg->Code;
X- 	    gd = (struct Gadget *)imsg->IAddress;
X- 	    qual = imsg->Qualifier;
X- 	    class = imsg->Class;
X- 	    code = imsg->Code;
X- 
X- 	    ReplyMsg( (struct Message *)imsg );
X- 
X- 	    switch( class )
X- 	    {
X- 		case VANILLAKEY:
X- 		    /* Escape or LEFT_AMIGA-b aborts the requester... */
X- 		    if( code == '\33' || (code == 'b' && (qual&AMIGALEFT)))
X- 		    {
X- 			done = 1;
X- 		    }
X- 		    break;
X- 
X- 		case ACTIVEWINDOW:
X- 		    if( gd = FindGadget( cwin, NULL, GADCHARNAME ) )
X- 			ActivateGadget( gd, cwin, NULL );
X- 		    break;
X- 
X- 		case MENUPICK:
X- 		    while( mcode != MENUNULL )
X- 		    {
X- 			switch(MENUNUM(mcode))
X- 			{
X- 			    case PLAYERMENU:
X- 				defgame.pltype = ITEMNUM( mcode );
X- 				UpdateTypes( cwin );
X- 				break;
X- 			}
X- 			mcode = ((struct MenuItem *)
X- 			    ItemAddress( &Defs_MenuList11,
X- 			    mcode))->NextSelect;
X- 		    }
X- 		    break;
X- 
X- 		case CLOSEWINDOW:
X- 		    CopyGad2Defs( );
X- 		    done = 1;
X- 		    break;
X- 
X- 		case GADGETUP:
X- 		    switch( gd->GadgetID )
X- 		    {
X- 			case GADEDOPTIONS:
X- 			    CopyOptions( curopts, gptr );
X- 			    if( EditOptions( curopts ) )
X- 				SetOptions( curopts, gptr );
X- 			    break;
X- 
X- 			case GADDEFSAVE:
X- 			    CopyGad2Defs( );
X- 			    sprintf( buf,
X- 				"Game definition saved in: %s", DefOutFile );
X- 			    errmsg( NO_FLASH, buf );
X- 			    SaveDefaults( DefOutFile );
X- 			    break;
X- 
X- 			case GADDEFLOAD:
X- 			    err = !LoadDefaults( DefPlayerName );
X- 			    if( !err )
X- 			    {
X- 				strcpy( DefOutFile, DefPlayerName );
X- 				CopyDefs2Gad();
X- 				UpdateTypes( cwin );
X- 				sprintf( buf, "Game definition loaded from: %s",
X- 				    DefPlayerName );
X- 				errmsg( NO_FLASH, buf );
X- 			    }
X- 			    break;
X- 
X- 			default:
X- 			    break;
X- 		    }
X- 		    break;
X- 	    }
X- 	}
X-     }
X- 
X-     SafeCloseWindow( cwin );
X- }
X- 
X  void do_gadgetup( imsg )
X      register struct IntuiMessage *imsg;
X  {
X--- 2293,2298 ----
X***************
X*** 2563,2583 ****
X      gptr->mics = imsg->Micros;
X  }
X  
X! void menu_setopt()
X! {
X      register GPTR gptr;
X! 
X!     if( ( gptr = NeedGame() ) == NULL )
X! 	return;
X      CopyOptions( curopts, gptr );
X!     if( EditOptions( curopts ) )
X  	SetOptions( curopts, gptr );
X  }
X  
X  void menu_info()
X  {
X      register struct IntuiMessage *imsg;
X-     struct IntuiText *ip;
X      char *t;
X      register GPTR gptr;
X      register struct Gadget *gd;
X--- 2393,2410 ----
X      gptr->mics = imsg->Micros;
X  }
X  
X! void setopt( gptr )
X      register GPTR gptr;
X! {
X      CopyOptions( curopts, gptr );
X!     if( EditOptions( curopts, gptr ) )
X  	SetOptions( curopts, gptr );
X  }
X  
X  void menu_info()
X  {
X+     int itemno;
X      register struct IntuiMessage *imsg;
X      char *t;
X      register GPTR gptr;
X      register struct Gadget *gd;
X***************
X*** 2584,2596 ****
X      register struct FileInfoBlock *finfo;
X      register struct Window *cwin;
X      register int i;
X!     int done = 0, quit;
X      char **sp;
X      static int once = 0;
X-     register BPTR lock;
X      long code, class, qual;
X!     static struct IntuiText itext[ 4 ];
X!     char commentstr[ 100 ], namestr[ 50 ];
X      int txtdiff = scrn->RastPort.TxHeight - 8;
X  
X      if( ( gptr = NeedGame() ) == NULL )
X--- 2411,2423 ----
X      register struct FileInfoBlock *finfo;
X      register struct Window *cwin;
X      register int i;
X!     int done = 0;
X!     long lock, olock;
X      char **sp;
X      static int once = 0;
X      long code, class, qual;
X!     static struct IntuiText itext[ 2 ];
X!     char commentstr[ 100 ], *s;
X      int txtdiff = scrn->RastPort.TxHeight - 8;
X  
X      if( ( gptr = NeedGame() ) == NULL )
X***************
X*** 2613,2619 ****
X      commentstr[ sizeof( finfo->fib_Comment ) ] = 0;
X      free( finfo );
X  
X!     for( i = 0; i < 4; ++i )
X      {
X  	itext[ i ].FrontPen = C_BLACK;
X  	itext[ i ].BackPen = C_GREY;
X--- 2440,2446 ----
X      commentstr[ sizeof( finfo->fib_Comment ) ] = 0;
X      free( finfo );
X  
X!     for( i = 0; i < 2; ++i )
X      {
X  	itext[ i ].FrontPen = C_BLACK;
X  	itext[ i ].BackPen = C_GREY;
X***************
X*** 2622,2634 ****
X  	itext[ i ].LeftEdge = 4;
X      }
X      ReallocTools( gptr, 0 );
X-     sp = gptr->dobj->do_ToolTypes;
X  
X      if( !once )
X      {
X! 	Info_Comment.TopEdge += txtdiff*2;
X! 	Info_Class.TopEdge += txtdiff;
X! 	Info_NewWindowStructure6.Height += txtdiff * 6;
X  	for( gd = Info_NewWindowStructure6.FirstGadget;
X  		gd; gd = gd->NextGadget )
X  	{
X--- 2449,2459 ----
X  	itext[ i ].LeftEdge = 4;
X      }
X      ReallocTools( gptr, 0 );
X  
X      if( !once )
X      {
X!     	Info_Comment.TopEdge += txtdiff*2;
X! 	Info_NewWindowStructure6.Height += txtdiff * 7;
X  	for( gd = Info_NewWindowStructure6.FirstGadget;
X  		gd; gd = gd->NextGadget )
X  	{
X***************
X*** 2640,2647 ****
X--- 2465,2479 ----
X  		case 0:
X  		    break;
X  
X+ 		case GADEDITOPTS:
X+ 		    gd->TopEdge += txtdiff*3;
X+ 		    SetBorder( gd, -1 );
X+ 		    break;
X+ 
X  		case GADTOOLTYPES:
X  		    gd->TopEdge += txtdiff*4;
X+ 		    if( scrn->Height > 300 )
X+ 			gd->TopEdge += 2;
X  		    SetBorder( gd, -1 );
X  		    break;
X  
X***************
X*** 2655,2666 ****
X  		    SetBorder( gd, -1 );
X  		    break;
X  
X  		case GADTOOLUP:
X  		    gd->TopEdge += txtdiff*4;
X  		    gd->Flags &= ~GADGHIGHBITS;
X  		    gd->Flags |= GADGIMAGE|GADGHIMAGE;
X! 		    gd->GadgetRender = (APTR)&up_selectimage;
X! 		    gd->SelectRender = (APTR)&up_renderimage;
X  		    break;
X  
X  		case GADTOOLDOWN:
X--- 2487,2524 ----
X  		    SetBorder( gd, -1 );
X  		    break;
X  
X+ 		case GADSAVEINFO:
X+ 		    gd->TopEdge += txtdiff*5;
X+ 		    SetBorder( gd, -1 );
X+ 		    break;
X+ 
X+ 		case GADQUITINFO:
X+ 		    gd->TopEdge += txtdiff*5;
X+ 		    SetBorder( gd, -1 );
X+ 		    break;
X+ 
X+ 		case GADUSEINFO:
X+ 		    gd->TopEdge += txtdiff*5;
X+ 		    SetBorder( gd, -1 );
X+ 		    break;
X+ 
X  		case GADTOOLUP:
X  		    gd->TopEdge += txtdiff*4;
X  		    gd->Flags &= ~GADGHIGHBITS;
X  		    gd->Flags |= GADGIMAGE|GADGHIMAGE;
X! 		    if( scrn->Height > 300 )
X! 		    {
X! 			gd->GadgetRender = (APTR)&tall_up_selectimage;
X! 			gd->SelectRender = (APTR)&tall_up_renderimage;
X! 			gd->Height *= 2;
X! 			if( txtdiff == 0 )
X! 			    gd->TopEdge -= 2;
X! 		    }
X! 		    else
X! 		    {
X! 			gd->GadgetRender = (APTR)&up_selectimage;
X! 			gd->SelectRender = (APTR)&up_renderimage;
X! 		    }
X  		    break;
X  
X  		case GADTOOLDOWN:
X***************
X*** 2667,2674 ****
X  		    gd->TopEdge += txtdiff*5;
X  		    gd->Flags &= ~GADGHIGHBITS;
X  		    gd->Flags |= GADGIMAGE|GADGHIMAGE;
X! 		    gd->GadgetRender = (APTR)&down_selectimage;
X! 		    gd->SelectRender = (APTR)&down_renderimage;
X  		    break;
X  
X  		default:
X--- 2525,2543 ----
X  		    gd->TopEdge += txtdiff*5;
X  		    gd->Flags &= ~GADGHIGHBITS;
X  		    gd->Flags |= GADGIMAGE|GADGHIMAGE;
X! 		    if( scrn->Height > 300 )
X! 		    {
X! 			gd->GadgetRender = (APTR)&tall_down_selectimage;
X! 			gd->SelectRender = (APTR)&tall_down_renderimage;
X! 			gd->Height *= 2;
X! 			if( txtdiff == 0 )
X! 			    gd->TopEdge += 4;
X! 		    }
X! 		    else
X! 		    {
X! 			gd->GadgetRender = (APTR)&down_selectimage;
X! 			gd->SelectRender = (APTR)&down_renderimage;
X! 		    }
X  		    break;
X  
X  		default:
X***************
X*** 2675,2727 ****
X  		    SetBorder( gd, -1 );
X  	    }
X  	}
X! 	for( ip = &Info_IntuiTextList6; ip; ip = ip->NextText )
X! 	{
X! 	    if( *ip->IText == 'C' )
X! 	    {
X! 		if( ip->IText[1] == 'o' )
X! 		    ip->TopEdge += 2*txtdiff;
X! 		else
X! 		    ip->TopEdge += txtdiff;
X! 	    }
X! 	    else if( *ip->IText == 'T' )
X! 		ip->TopEdge += 4*txtdiff;
X! 	}
X  	++once;
X      }
X  
X!     gd = &Info_EditDef;
X!     if( access( GameName( gptr, gptr->name ), 1 ) == 0 )
X! 	gd->Flags |= GADGDISABLED;
X!     else
X! 	gd->Flags &= ~GADGDISABLED;
X  
X-     /* Put in the comment */
X- 
X-     Info_Comment.GadgetText = &itext[ 0 ];
X-     itext[ 0 ].IText = commentstr;
X- 
X      /* The players name */
X  
X!     Info_Player.GadgetText = &itext[ 1 ];
X!     strncpy( namestr, ToolsEntry( gptr, "NAME" ), sizeof( namestr ) );
X!     namestr[ sizeof( namestr ) - 1 ] = 0;
X!     if( *namestr == 0 )
X      {
X! 	strncpy( namestr, gptr->name, sizeof( namestr ) );
X! 	namestr[ sizeof( namestr ) - 1 ] = 0;
X      }
X!     if( ( t = strrchr( namestr, '.' ) ) && stricmp( t, ".sav" ) == 0 )
X  	*t = 0;
X!     itext[ 1 ].IText = namestr;
X  
X      /* The character class of the player */
X  
X!     Info_Class.GadgetText = &itext[ 2 ];
X!     itext[ 2 ].IText = ToolsEntry( gptr, "CHARACTER" );
X  
X      /* If there are ToolTypes entries, put the first one into the gadget */
X  
X      if( sp && *sp )
X  	strcpy( StrTools, *sp );
X  
X--- 2544,2581 ----
X  		    SetBorder( gd, -1 );
X  	    }
X  	}
X! 
X  	++once;
X      }
X  
X!     strncpy( Sbuff( &Info_Comment ), commentstr, 100 );
X  
X      /* The players name */
X  
X!     strncpy( StrPlayer, ToolsEntry( gptr, "NAME" ), 100 );
X!     if( *StrPlayer == 0 )
X      {
X! 	strncpy( StrPlayer, gptr->name, 99 );
X      }
X! 
X!     if( ( t = strrchr( StrPlayer, '.' ) ) && stricmp( t, ".sav" ) == 0 )
X!     {
X  	*t = 0;
X!     }
X  
X      /* The character class of the player */
X  
X!     Info_Class.GadgetText = &itext[ 0 ];
X!     itext[ 0 ].IText = ToolsEntry( gptr, "CHARACTER" );
X!     if( *itext[ 0 ].IText == 0 )
X!     {
X! 	itext[ 0 ].IText = players[ 0 ];
X! 	SetToolLine( gptr, "CHARACTER", players[ 0 ] );
X!     }
X  
X      /* If there are ToolTypes entries, put the first one into the gadget */
X  
X+     sp = gptr->dobj->do_ToolTypes;
X      if( sp && *sp )
X  	strcpy( StrTools, *sp );
X  
X***************
X*** 2736,2743 ****
X  	errmsg( FLASH, "Can't create info window" );
X  	return;
X      }
X-     PrintIText( cwin->RPort, &Info_IntuiTextList6, 0, txtdiff );
X  
X      while( !done )
X      {
X  	WaitPort( cwin->UserPort );
X--- 2590,2613 ----
X  	errmsg( FLASH, "Can't create info window" );
X  	return;
X      }
X  
X+     itemno = 0;
X+     if( s = FindToolType( (char **) gptr->dobj->do_ToolTypes, "CHARACTER" ) )
X+     {
X+ 	s += 10;
X+ 	for( itemno = 0; players[ itemno ]; ++itemno )
X+ 	{
X+ 	    if( strnicmp( s, players[ itemno ], strlen( s ) ) == 0 )
X+ 		break;
X+ 	}
X+     }
X+     if( !players[ itemno ] )
X+ 	itemno = 0;
X+ 
X+     CheckOnly( &Info_MenuList6, 0, itemno );
X+     SetUpMenus( &Info_MenuList6, scrn );
X+     SetMenuStrip( cwin, &Info_MenuList6 );
X+ 
X      while( !done )
X      {
X  	WaitPort( cwin->UserPort );
X***************
X*** 2756,2762 ****
X  		    if( code == '\33' || (code == 'b' && (qual&AMIGALEFT)) )
X  		    {
X  			done = 1;
X- 			quit = 0;
X  		    }
X  		    break;
X  
X--- 2626,2631 ----
X***************
X*** 2768,2893 ****
X  			*sp = strdup( StrTools );
X  		    }
X  		    done = 1;
X- 		    quit = 0;
X  		    break;
X  
X  		case GADGETUP:
X  		    switch( gd->GadgetID )
X  		    {
X! 			case GADEDDEF:
X! 			    /* Put the game values into the defaults */
X  
X! 			    Game2Defs( gptr );
X  
X! 			    /* Put the options into the options array */
X  
X! 			    CopyOptions( curopts, gptr );
X  
X! 			    /* Edit the defaults */
X  
X! 			    menu_editdef( GAME_FROM_INFO );
X  
X! 			    /* Put the options back in */
X  
X! 			    SetOptions( curopts, gptr );
X  
X! 			    /* Move defaults to game */
X! 
X! 			    SetToolLine( gptr, "NAME", defgame.plname );
X! 			    SetToolLine( gptr, "CHARACTER",
X! 				defgame.pltype ?
X! 				players[ defgame.pltype ] : "" );
X! 			    itext[ 2 ].IText =
X! 				ToolsEntry( gptr, "CHARACTER" );
X! 			    strncpy( namestr, ToolsEntry( gptr, "NAME" ),
X! 				sizeof( namestr ) );
X! 			    namestr[ sizeof( namestr ) - 1 ] = 0;
X! 			    if( *namestr == 0 )
X! 			    {
X! 				strncpy( namestr, gptr->name, sizeof(namestr) );
X! 				namestr[ sizeof( namestr ) - 1 ] = 0;
X! 			    }
X! 			    if( ( t = strrchr( namestr, '.' ) ) &&
X! 				stricmp( t, ".sav" ) == 0 )
X! 			    {
X! 				*t = 0;
X! 			    }
X! 			    itext[ 1 ].IText = namestr;
X! 
X! 			    /* Make sure that the correct ToolTypes line
X! 			     * is displayed in the gadget.
X! 			     */
X! 
X! 			    sp = gptr->dobj->do_ToolTypes;
X  			    strcpy( StrTools, *sp );
X! 			    UpdateInfoWin( cwin );
X! 			    break;
X! 
X! 			case GADADDTOOL:
X! 			    ReallocTools( gptr, 1 );
X! 			    sp = gptr->dobj->do_ToolTypes;
X! 			    for( i = 0; sp[ i ]; ++i )
X! 				;
X! 			    sp[i] = strdup( "" );
X! 			    sp[i+1] = NULL;
X! 			    itext[ 2 ].IText =
X! 				ToolsEntry( gptr, "CHARACTER" );
X! 			    *StrTools = 0;
X! 			    UpdateInfoWin( cwin );
X! 			    sp += i;
X! 			    break;
X! 
X! 			case GADDELTOOL:
X! 			    while( *sp = sp[1] )
X! 				++sp;
X! 			    sp = gptr->dobj->do_ToolTypes;
X! 			    strcpy( StrTools, *sp ? *sp : "" );
X! 			    UpdateInfoWin( cwin );
X! 			    break;
X! 
X! 			case GADTOOLTYPES:
X! 			    if( sp && *sp && CheckAndCopy( StrTools, *sp ) )
X! 			    {
X! 				if( *sp )
X! 				    free( *sp );
X! 				*sp = strdup( StrTools );
X! 			    }
X! 			    break;
X! 
X! 			case GADTOOLDOWN:
X! 			    if( sp && *sp && CheckAndCopy( StrTools, *sp ) )
X! 			    {
X! 				if( *sp )
X! 				    free( *sp );
X! 				*sp = strdup( StrTools );
X! 			    }
X! 			    if( sp != NULL && sp[1] != NULL )
X! 			    {
X! 				++sp;
X! 				strcpy( StrTools, *sp );
X! 				if( IsEditEntry( StrTools, gptr ) )
X! 				    Info_ToolTypes.Flags &= ~GADGDISABLED;
X! 				else
X! 				    Info_ToolTypes.Flags |= GADGDISABLED;
X! 			    }
X  			    else
X! 			    {
X! 				if( sp && *sp )
X! 				    strcpy( StrTools, *sp );
X! 				DisplayBeep( NULL );
X! 			    }
X! 			    break;
X  
X! 			case GADTOOLUP:
X! 			    if( sp && *sp && CheckAndCopy( StrTools, *sp ) )
X  			    {
X- 				if( *sp )
X- 				    free( *sp );
X- 				*sp = strdup( StrTools );
X- 			    }
X- 			    if( sp && sp > gptr->dobj->do_ToolTypes )
X- 			    {
X- 				--sp;
X  				strcpy( StrTools, *sp );
X  				if( IsEditEntry( StrTools, gptr ) )
X  				    Info_ToolTypes.Flags &= ~GADGDISABLED;
X--- 2637,2760 ----
X  			*sp = strdup( StrTools );
X  		    }
X  		    done = 1;
X  		    break;
X  
X  		case GADGETUP:
X  		    switch( gd->GadgetID )
X  		    {
X! 		    case GADSAVEINFO:
X! 			/* Write icon and quit. */
X! 			SetToolLine( gptr, "NAME", StrPlayer );
X! 			UpdateGameIcon( gptr );
X! 			lock = Lock( gptr->dname, ACCESS_READ );
X! 			if( lock )
X! 			{
X! 			    olock = CurrentDir( lock );
X! 			    SetComment( gptr->fname, Sbuff( &Info_Comment ) );
X! 			    CurrentDir( olock );
X! 			    done = 1;
X! 			}
X! 			else
X! 			{
X! 			    errmsg( FLASH, "Can't access icon's directory" );
X! 			    sp = gptr->dobj->do_ToolTypes;
X! 			    strcpy( StrTools, *sp ? *sp : "" );
X! 			    UpdateInfoWin( cwin );
X! 			}
X! 			break;
X  
X! 		    case GADUSEINFO:
X! 			/* Quit this loop. */
X! 			done = 1;
X! 			break;
X  
X! 		    case GADQUITINFO:
X! 			/* Reload icon and quit this loop. */
X! 			RemoveGadget( win, &gptr->dobj->do_Gadget );
X! 			RemoveGITEM( gptr );
X! 			lastgaddown = NULL; /* very important... */
X! 			MapGadgets( R_DISK, 1 );
X! 			done = 1;
X! 			break;
X  
X! 		    case GADEDITOPTS:
X! 			setopt( gptr );
X! 			sp = gptr->dobj->do_ToolTypes;
X! 			strcpy( StrTools, *sp ? *sp : "" );
X! 			UpdateInfoWin( cwin );
X! 			break;
X  
X! 		    case GADADDTOOL:
X! 			FreeTools( gptr );
X! 			ReallocTools( gptr, 2 );
X! 			sp = gptr->dobj->do_ToolTypes;
X! 			for( i = 0; sp[ i ]; ++i )
X! 			    ;
X! 			sp[i] = strdup( "" );
X! 			sp[i+1] = NULL;
X! 			itext[ 0 ].IText =
X! 			    ToolsEntry( gptr, "CHARACTER" );
X! 			*StrTools = 0;
X! 			Info_ToolTypes.Flags &= ~GADGDISABLED;
X! 			UpdateInfoWin( cwin );
X! 			sp += i;
X! 			break;
X  
X! 		    case GADDELTOOL:
X! 			while( *sp = sp[1] )
X! 			    ++sp;
X! 			sp = gptr->dobj->do_ToolTypes;
X! 			strcpy( StrTools, *sp ? *sp : "" );
X! 			Info_ToolTypes.Flags &= ~GADGDISABLED;
X! 			UpdateInfoWin( cwin );
X! 			break;
X  
X! 		    case GADTOOLTYPES:
X! 			if( sp && *sp && CheckAndCopy( StrTools, *sp ) )
X! 			{
X! 			    if( *sp )
X! 				free( *sp );
X! 			    *sp = strdup( StrTools );
X! 			}
X! 			break;
X  
X! 		    case GADTOOLDOWN:
X! 			if( sp && *sp && CheckAndCopy( StrTools, *sp ) )
X! 			{
X! 			    if( *sp )
X! 				free( *sp );
X! 			    *sp = strdup( StrTools );
X! 			}
X  
X! 			if( sp && sp[0] && sp[1] )
X! 			{
X! 			    ++sp;
X  			    strcpy( StrTools, *sp );
X! 			    if( IsEditEntry( StrTools, gptr ) )
X! 				Info_ToolTypes.Flags &= ~GADGDISABLED;
X  			    else
X! 				Info_ToolTypes.Flags |= GADGDISABLED;
X! 			}
X! 			else
X! 			{
X! 			    if( sp && *sp )
X! 				strcpy( StrTools, *sp );
X! 			    DisplayBeep( NULL );
X! 			}
X! 			break;
X  
X! 		    case GADTOOLUP:
X! 			if( sp && *sp && CheckAndCopy( StrTools, *sp ) )
X! 			{
X! 			    if( *sp )
X! 				free( *sp );
X! 			    *sp = strdup( StrTools );
X! 			}
X! 			if( sp && sp > gptr->dobj->do_ToolTypes )
X! 			{
X! 			    --sp;
X! 			    if( *sp )
X  			    {
X  				strcpy( StrTools, *sp );
X  				if( IsEditEntry( StrTools, gptr ) )
X  				    Info_ToolTypes.Flags &= ~GADGDISABLED;
X***************
X*** 2894,2907 ****
X  				else
X  				    Info_ToolTypes.Flags |= GADGDISABLED;
X  			    }
X! 			    else
X! 			    {
X! 				DisplayBeep( NULL );
X! 			    }
X! 			    break;
X  		    }
X  		    RefreshGList( &Info_ToolTypes, cwin, NULL, 1 );
X  		    break;
X  	    }
X  	}
X      }
X--- 2761,2797 ----
X  				else
X  				    Info_ToolTypes.Flags |= GADGDISABLED;
X  			    }
X! 			}
X! 			else
X! 			{
X! 			    DisplayBeep( NULL );
X! 			}
X! 			break;
X! 
X! 		    case GADPLNAME:
X! 			SetToolLine( gptr, "NAME", StrPlayer );
X! 			sp = gptr->dobj->do_ToolTypes;
X! 			strcpy( StrTools, *sp ? *sp : "" );
X! 			UpdateInfoWin( cwin );
X! 			break;
X  		    }
X  		    RefreshGList( &Info_ToolTypes, cwin, NULL, 1 );
X  		    break;
X+ 
X+ 	    	case MENUPICK:
X+ 	    	    while( code != MENUNULL )
X+ 	    	    {
X+ 			SetToolLine( gptr, "CHARACTER",
X+ 				    players[ ITEMNUM( code ) ] );
X+ 			itext[ 0 ].IText =
X+ 				    ToolsEntry( gptr, "CHARACTER" );
X+ 			sp = gptr->dobj->do_ToolTypes;
X+ 			strcpy( StrTools, *sp ? *sp : "" );
X+ 			UpdateInfoWin( cwin );
X+ 			code = ((struct MenuItem *)ItemAddress(
X+ 				&Info_MenuList6, (long)code ))->NextSelect;
X+ 		    }
X+ 		    break;
X  	    }
X  	}
X      }
X***************
X*** 2921,2931 ****
X  	Info_Class.TopEdge,
X  	Info_Class.LeftEdge + Info_Class.Width-1,
X  	Info_Class.TopEdge + Info_Class.Height-1 );
X-     RectFill( cwin->RPort,
X- 	Info_Player.LeftEdge,
X- 	Info_Player.TopEdge,
X- 	Info_Player.LeftEdge + Info_Player.Width-1,
X- 	Info_Player.TopEdge + Info_Player.Height-1 );
X      RefreshGList( cwin->FirstGadget, cwin, NULL, -1 );
X  }
X  
X--- 2811,2816 ----
X***************
X*** 3131,3297 ****
X  }
X  
X  /*
X-  * Load a defaults file into global structures
X-  */
X- 
X- LoadDefaults( player )
X-     char *player;
X- {
X-     FILE *fp;
X-     int i;
X-     char fname[ 100 ];
X-     char buf[ 200 ];
X- 	char *t;
X- 
X-     sprintf( fname, "%s.def", player );
X- 
X-     if( ( fp = fopen( fname, "r" ) ) == NULL )
X-     {
X- 	errmsg( FLASH,
X- 	    "Can't open defaults, %s, in current directory", fname );
X- 	return 0;
X-     }
X- 
X-     while( fgets( buf, sizeof( buf ), fp ) != NULL )
X-     {
X- 	if( *buf == '#' )
X- 	    continue;
X- 
X- 	if( ( t = strchr( buf, '\n' ) ) != NULL )
X- 	    *t = 0;
X- 	if( strnicmp( "PLAYER=", buf, 7 ) == 0 )
X- 	{
X- 	    if( defgame.plname )
X- 		free( defgame.plname );
X- 	    defgame.plname = strdup( buf + 7 );
X- 	}
X- 	else if( strnicmp( "PLAYERTYPE=", buf, 11 ) == 0 )
X- 	{
X- 	    for( i = 0; players[ i ]; ++i )
X- 	    {
X- 		if( strnicmp( &buf[11], players[ i ], 1 ) == 0 )
X- 		    break;
X- 	    }
X- 
X- 	    if( players[ i ] )
X- 		defgame.pltype = i;
X- 	    else
X- 		defgame.pltype = 0;
X- 	}
X- 	else if( strnicmp( "OPTIONS=", buf, 8 ) == 0 )
X- 	{
X- 	    errmsg( FLASH, "OPTIONS set by game configuration" );
X- 	    setoneopt( OPTIONS_IDX, buf+8 );
X- 	    defgame.options = strdup( buf + 8 );
X- 	}
X- 	else
X- 	{
X- 	    errmsg( FLASH, "Invalid line in defaults file" );
X- 	    fclose( fp );
X- 	    return( 0 );
X- 	}
X-     }
X-     fclose( fp );
X-     return( 1 );
X- }
X- 
X- /*
X-  * Create a defaults file my the name given with all of the global
X-  * information currently set.
X-  */
X- 
X- void SaveDefaults( player )
X-     char *player;
X- {
X-     FILE *fp;
X-     char fname[ 100 ];
X-     int err;
X- 
X-     sprintf( fname, "%s.def", player );
X- 
X-     if( ( fp = fopen( fname, "w" ) ) == NULL )
X-     {
X- 	errmsg( FLASH, "Can't open defaults file: %s", fname );
X- 	return;
X-     }
X- 
X-     err = fprintf( fp, "PLAYER=%s\n", defgame.plname );
X-     if( defgame.pltype )
X- 	err |= fprintf( fp, "PLAYERTYPE=%s\n", players[ defgame.pltype ] );
X-     else
X- 	err |= fprintf( fp, "PLAYERTYPE=<RANDOM>\n" );
X- 
X-     /* Get the options. */
X-     PutOptions( curopts );
X- 
X-     /* Put them in too */
X-     err |= fprintf( fp, "OPTIONS=%s\n", options[ OPTIONS_IDX ] );
X-     err |= fclose( fp );
X- 
X-     if( err == EOF )
X- 	errmsg( FLASH, "Error writing out defaults for: %s", fname );
X- }
X- 
X- /*
X-  * Copy the defgame structure values into the Defs windows gadgets
X-  */
X- 
X- void CopyDefs2Gad()
X- {
X-     if( defgame.plname )
X- 	strcpy( DefPlayerName, defgame.plname );
X-     else
X- 	*DefPlayerName = 0;
X- 
X-     CheckOnly( &Defs_MenuList11, 0, defgame.pltype );
X- 
X-     /* If there are default options fill them in, else reset
X-      * to the real defaults.
X-      */
X-     if( defgame.options )
X- 	CopyOptionStr( curopts, defgame.options );
X-     else
X- 	ZapOptions( curopts );
X- }
X- 
X- /*
X-  * Copy the Defs window gadgets into the defgame structure
X-  */
X- 
X- void CopyGad2Defs( )
X- {
X-     if( defgame.plname )
X- 	free( defgame.plname );
X-     defgame.plname = strdup( DefPlayerName );
X- 
X-     defgame.pltype = FindChecked( &Defs_MenuList11, 0 );
X- }
X- 
X- /*
X-  * Make sure that the correct character type is checked
X-  */
X- 
X- void UpdateTypes( cwin )
X-     register struct Window *cwin;
X- {
X-     register struct RastPort *rp = cwin->RPort;
X- 
X-     SetAPen( rp, 0 );
X-     SetBPen( rp, 0 );
X-     SetDrMd( rp, JAM2 );
X-     RectFill( cwin->RPort,
X- 	Defs_PlayerType.LeftEdge+1,
X- 	Defs_PlayerType.TopEdge+1,
X- 	Defs_PlayerType.LeftEdge+Defs_PlayerType.Width-1,
X- 	Defs_PlayerType.TopEdge+Defs_PlayerType.Height-1 );
X- 
X-     Defs_PlayerType.GadgetText->IText = players[ defgame.pltype ];
X-     RefreshGList( &Defs_PlayerType, cwin, NULL, 1 );
X-     RefreshGList( &Defs_PlayerName, cwin, NULL, 1 );
X-     RefreshGList( &Defs_DefaultName, cwin, NULL, 1 );
X- }
X- 
X- /*
X   * Ask the user if they really want to do something.
X   */
X  
X--- 3016,3021 ----
X***************
X*** 3485,3492 ****
X  	switch( i )
X  	{
X  	    case ITEM_INFO:
X- 	    case ITEM_SETCOMMENT:
X- 	    case ITEM_SETOPT:
X  	    case ITEM_COPYOPT:
X  	    case ITEM_DISCARD:
X  	    case ITEM_RENAME:
X--- 3209,3214 ----
X***************
X*** 3524,3530 ****
X      {
X  	switch( i )
X  	{
X- 	    case ITEM_SETOPT:
X  	    case ITEM_RENAME:
X  	    case ITEM_DISCARD:
X  		ino = MENUITEMNO( 1,i,NOSUB );
X--- 3246,3251 ----
X***************
X*** 3533,3539 ****
X  
X  	    case ITEM_COPYOPT:
X  	    case ITEM_INFO:
X- 	    case ITEM_SETCOMMENT:
X  		ino = MENUITEMNO( 1,i,NOSUB );
X  		if( enable )
X  		    OnMenu( win, ino );
X--- 3254,3259 ----
X***************
X*** 3549,3556 ****
X   * of the members changed based on the users input
X   */
X  
X! int EditOptions( optr )
X      OPTR optr;
X  {
X      int done = 0, quit = 0;
X      register struct Window *cwin;
X--- 3269,3277 ----
X   * of the members changed based on the users input
X   */
X  
X! int EditOptions( optr, gptr )
X      OPTR optr;
X+     GPTR gptr;
X  {
X      int done = 0, quit = 0;
X      register struct Window *cwin;
X***************
X*** 3564,3570 ****
X  
X      if( !once )
X      {
X! 	if( gd = FindGadget( NULL, &Options_NewWindowStructure3, GADOCOLOR ))
X  	{
X  	    struct Gadget *g;
X  	    for( g = Options_NewWindowStructure3.FirstGadget;
X--- 3285,3291 ----
X  
X      if( !once )
X      {
X! 	if( gd = FindGadget( NULL, &Options_NewWindowStructure3, GADOLITCORRIDOR ))
X  	{
X  	    struct Gadget *g;
X  	    for( g = Options_NewWindowStructure3.FirstGadget;
X***************
X*** 3637,3674 ****
X  	    gd->TopEdge += txtdiff*4;
X  	    gd->Height += txtdiff;
X  	}
X  	if( gd = FindGadget( NULL, &Options_NewWindowStructure3, GADOCATNAME ))
X  	{
X  	    gd->TopEdge += txtdiff*5;
X  	    gd->Height += txtdiff;
X  	}
X  	if( gd = FindGadget( NULL, &Options_NewWindowStructure3, GADODOGNAME ))
X  	{
X  	    gd->TopEdge += txtdiff*6;
X  	    gd->Height += txtdiff;
X  	}
X  	if( gd = FindGadget( NULL, &Options_NewWindowStructure3, GADOFRUIT ))
X  	{
X  	    gd->TopEdge += txtdiff*7;
X  	    gd->Height += txtdiff;
X  	}
X  	if( gd = FindGadget( NULL, &Options_NewWindowStructure3, GADOOBJECTS ))
X  	{
X  	    gd->TopEdge += txtdiff*8;
X  	    gd->Height += txtdiff;
X  	}
X! 	if( gd = FindGadget( NULL, &Options_NewWindowStructure3, GADOOKAY ))
X  	{
X  	    gd->TopEdge += txtdiff*9;
X  	    gd->Height += txtdiff;
X  	}
X! 	if( gd = FindGadget( NULL, &Options_NewWindowStructure3, GADOCANCEL ))
X  	{
X  	    gd->TopEdge += txtdiff*9;
X  	    gd->Height += txtdiff;
X  	}
X! 	Options_NewWindowStructure3.Height += txtdiff*11;
X! 	Options_NewWindowStructure3.TopEdge -= txtdiff*6;
X  	if( Options_NewWindowStructure3.Height +
X  	    Options_NewWindowStructure3.TopEdge >= scrn->Height )
X  	{
X--- 3358,3430 ----
X  	    gd->TopEdge += txtdiff*4;
X  	    gd->Height += txtdiff;
X  	}
X+ 	if( gd = FindGadget( NULL, &Options_NewWindowStructure3, GADOPICKUPTYPES ))
X+ 	{
X+ 	    gd->TopEdge += txtdiff*4;
X+ 	    gd->Height += txtdiff;
X+ 	}
X  	if( gd = FindGadget( NULL, &Options_NewWindowStructure3, GADOCATNAME ))
X  	{
X  	    gd->TopEdge += txtdiff*5;
X  	    gd->Height += txtdiff;
X  	}
X+ 	if( gd = FindGadget( NULL, &Options_NewWindowStructure3, GADOWINDOWTYPE ))
X+ 	{
X+ 	    gd->TopEdge += txtdiff*5;
X+ 	    gd->Height += txtdiff;
X+ 	}
X  	if( gd = FindGadget( NULL, &Options_NewWindowStructure3, GADODOGNAME ))
X  	{
X  	    gd->TopEdge += txtdiff*6;
X  	    gd->Height += txtdiff;
X  	}
X+ 	if( gd = FindGadget( NULL, &Options_NewWindowStructure3, GADOMSGHISTORY ))
X+ 	{
X+ 	    gd->TopEdge += txtdiff*6;
X+ 	    gd->Height += txtdiff;
X+ 	}
X  	if( gd = FindGadget( NULL, &Options_NewWindowStructure3, GADOFRUIT ))
X  	{
X  	    gd->TopEdge += txtdiff*7;
X  	    gd->Height += txtdiff;
X  	}
X+ 	if( gd = FindGadget( NULL, &Options_NewWindowStructure3, GADOPALETTE ))
X+ 	{
X+ 	    gd->TopEdge += txtdiff*7;
X+ 	    gd->Height += txtdiff;
X+ 	}
X  	if( gd = FindGadget( NULL, &Options_NewWindowStructure3, GADOOBJECTS ))
X  	{
X  	    gd->TopEdge += txtdiff*8;
X  	    gd->Height += txtdiff;
X  	}
X! 	if( gd = FindGadget( NULL, &Options_NewWindowStructure3, GADOSCORE ))
X  	{
X+ 	    gd->TopEdge += txtdiff*8;
X+ 	    gd->Height += txtdiff;
X+ 	}
X+ 	if( gd = FindGadget( NULL, &Options_NewWindowStructure3, GADONAME ))
X+ 	{
X  	    gd->TopEdge += txtdiff*9;
X  	    gd->Height += txtdiff;
X  	}
X! 	if( gd = FindGadget( NULL, &Options_NewWindowStructure3, GADOPETTYPE ))
X  	{
X  	    gd->TopEdge += txtdiff*9;
X  	    gd->Height += txtdiff;
X  	}
X! 	if( gd = FindGadget( NULL, &Options_NewWindowStructure3, GADOOKAY ))
X! 	{
X! 	    gd->TopEdge += txtdiff*10;
X! 	    gd->Height += txtdiff;
X! 	}
X! 	if( gd = FindGadget( NULL, &Options_NewWindowStructure3, GADOCANCEL ))
X! 	{
X! 	    gd->TopEdge += txtdiff*10;
X! 	    gd->Height += txtdiff;
X! 	}
X! 	Options_NewWindowStructure3.Height += txtdiff*12;
X! 	Options_NewWindowStructure3.TopEdge -= txtdiff*12;
X  	if( Options_NewWindowStructure3.Height +
X  	    Options_NewWindowStructure3.TopEdge >= scrn->Height )
X  	{
X***************
X*** 3677,3686 ****
X  	}
X  	if( Options_NewWindowStructure3.TopEdge < 0 )
X  	    Options_NewWindowStructure3.TopEdge = 0;
X! 	{
X! 	    if( Options_NewWindowStructure3.Height > scrn->Height )
X! 		Options_NewWindowStructure3.Height = scrn->Height;
X! 	}
X  
X  	/* Now that heights are correct, render borders */
X  	for( gd = Options_NewWindowStructure3.FirstGadget;
X--- 3433,3440 ----
X  	}
X  	if( Options_NewWindowStructure3.TopEdge < 0 )
X  	    Options_NewWindowStructure3.TopEdge = 0;
X! 	if( Options_NewWindowStructure3.Height > scrn->Height )
X! 	    Options_NewWindowStructure3.Height = scrn->Height;
X  
X  	/* Now that heights are correct, render borders */
X  	for( gd = Options_NewWindowStructure3.FirstGadget;
X***************
X*** 3692,3709 ****
X  		SetBorder( gd, -1 );
X  	    }
X  	}
X  	for( ip = &Options_IntuiTextList3; ip; ip = ip->NextText )
X  	{
X! 	    if( *ip->IText == 'P' )
X  		ip->TopEdge += txtdiff * 5;
X! 	    else if( *ip->IText == 'C' )
X  		ip->TopEdge += txtdiff * 6;
X! 	    else if( *ip->IText == 'D' )
X  		ip->TopEdge += txtdiff * 7;
X! 	    else if( *ip->IText == 'F' )
X  		ip->TopEdge += txtdiff * 8;
X! 	    else if( *ip->IText == 'O' )
X  		ip->TopEdge += txtdiff * 9;
X  	}
X  	once = 1;
X      }
X--- 3446,3489 ----
X  		SetBorder( gd, -1 );
X  	    }
X  	}
X+ 
X  	for( ip = &Options_IntuiTextList3; ip; ip = ip->NextText )
X  	{
X! 	    /* Pack Order:  and  Pickup: */
X! 	    if( ( *ip->IText == 'P' && ip->IText[2] == 'c' ) )
X! 	    {
X! 		ip->TopEdge += txtdiff * 4;
X! 	    }
X! 	    /* Cat Name:  and  Window Type: */
X! 	    else if( ( *ip->IText == 'C' ) ||
X! 		    ( *ip->IText == 'W' ) )
X! 	    {
X  		ip->TopEdge += txtdiff * 5;
X! 	    }
X! 	    /* Dog Name:  and  Msg History: */
X! 	    else if( ( *ip->IText == 'D' ) ||
X! 		    ( *ip->IText == 'M' ) )
X! 	    {
X  		ip->TopEdge += txtdiff * 6;
X! 	    }
X! 	    /* Fruit:  and  Pallete: */
X! 	    else if( ( *ip->IText == 'F' ) ||
X! 		    ( *ip->IText == 'P' && ip->IText[2] == 'l' ) )
X! 	    {
X  		ip->TopEdge += txtdiff * 7;
X! 	    }
X! 	    /* Objects:  and  Score: */
X! 	    else if( ( *ip->IText == 'O' ) ||
X! 	    		( *ip->IText == 'S' ) )
X! 	    {
X  		ip->TopEdge += txtdiff * 8;
X! 	    }
X! 	    /* Name:  and  Pet Type: */
X! 	    else if(( *ip->IText == 'N' ) ||
X! 		    ( *ip->IText == 'P' && ip->IText[1] == 'e' ) )
X! 	    {
X  		ip->TopEdge += txtdiff * 9;
X+ 	    }
X  	}
X  	once = 1;
X      }
X***************
X*** 3717,3723 ****
X  	    /* If string valued option, set string */
X  	    if( optr[ i ].optstr )
X  	    {
X! 		strcpy( Sbuff( gd ), optr[i].optstr );
X  	    }
X  	    else
X  	    {
X--- 3497,3520 ----
X  	    /* If string valued option, set string */
X  	    if( optr[ i ].optstr )
X  	    {
X! 	    	char *t;
X! 
X! 		if( optr[ i ].id == GADOPALETTE &&
X! 				    ( optr[i].optstr == NULL || *optr[i].optstr == 0 ) )
X! 		{
X! 		    if( gptr && ( t = ToolsEntry( gptr, "PENS" ) ) )
X! 		    {
X! 			strcpy( Sbuff( gd ), t );
X! 		    }
X! 		    else
X! 		    {
X! 			strcpy( Sbuff( gd ), options[ PENS_IDX ] );
X! 		    }
X! 		    for( t = strchr( Sbuff( gd ), ',' ); t; t = strchr( t, ',' ) )
X! 		    	*t = '/';
X! 		}
X! 		else
X! 		    strcpy( Sbuff( gd ), optr[i].optstr );
X  	    }
X  	    else
X  	    {
X***************
X*** 3773,3814 ****
X  			done = 1;
X  			quit = 1;
X  		    }
X- 		    else
X- 		    {
X- 			switch( code )
X- 			{
X- 			    case 'p':
X- 			    case 'P':
X- 				ActivateGadget(
X- 				    FindGadget( cwin, 0, GADOPACKORDER ),
X- 				    cwin, 0 );
X- 				break;
X- 			    case 'c':
X- 			    case 'C':
X- 				ActivateGadget(
X- 				    FindGadget( cwin, 0, GADOCATNAME ),
X- 				    cwin, 0 );
X- 				break;
X- 			    case 'd':
X- 			    case 'D':
X- 				ActivateGadget(
X- 				    FindGadget( cwin, 0, GADODOGNAME ),
X- 				    cwin, 0 );
X- 				break;
X- 			    case 'f':
X- 			    case 'F':
X- 				ActivateGadget(
X- 				    FindGadget( cwin, 0, GADOFRUIT ),
X- 				    cwin, 0 );
X- 				break;
X- 			    case 'o':
X- 			    case 'O':
X- 				ActivateGadget(
X- 				    FindGadget( cwin, 0, GADOOBJECTS ),
X- 				    cwin, 0 );
X- 				break;
X- 			}
X- 		    }
X  		    break;
X  
X  		case CLOSEWINDOW:
X--- 3570,3575 ----
X***************
X*** 3820,3850 ****
X  		    {
X  			case GADOPACKORDER:
X  			    ActivateGadget(
X! 				FindGadget( cwin, 0, GADOCATNAME ),
X  				cwin, 0 );
X  			    break;
X  
X  			case GADOCATNAME:
X  			    ActivateGadget(
X! 				FindGadget( cwin, 0, GADODOGNAME ),
X  				cwin, 0 );
X  			    break;
X  
X  			case GADODOGNAME:
X  			    ActivateGadget(
X! 				FindGadget( cwin, 0, GADOFRUIT ),
X  				cwin, 0 );
X  			    break;
X  
X  			case GADOFRUIT:
X  			    ActivateGadget(
X! 				FindGadget( cwin, 0, GADOOBJECTS ),
X  				cwin, 0 );
X  			    break;
X  
X  			case GADOOBJECTS:
X  			    break;
X  
X  			case GADOOKAY:
X  			    done = 1;
X  			    break;
X--- 3581,3653 ----
X  		    {
X  			case GADOPACKORDER:
X  			    ActivateGadget(
X! 				FindGadget( cwin, 0, GADOPICKUPTYPES ),
X  				cwin, 0 );
X  			    break;
X  
X  			case GADOCATNAME:
X  			    ActivateGadget(
X! 				FindGadget( cwin, 0, GADOWINDOWTYPE ),
X  				cwin, 0 );
X  			    break;
X  
X  			case GADODOGNAME:
X  			    ActivateGadget(
X! 				FindGadget( cwin, 0, GADOMSGHISTORY ),
X  				cwin, 0 );
X  			    break;
X  
X  			case GADOFRUIT:
X  			    ActivateGadget(
X! 				FindGadget( cwin, 0, GADOPALETTE ),
X  				cwin, 0 );
X  			    break;
X  
X  			case GADOOBJECTS:
X+ 			    ActivateGadget(
X+ 				FindGadget( cwin, 0, GADOSCORE ),
X+ 				cwin, 0 );
X  			    break;
X  
X+ 			case GADONAME:
X+ 			    ActivateGadget(
X+ 				FindGadget( cwin, 0, GADOPETTYPE ),
X+ 				cwin, 0 );
X+ 			    break;
X+ 
X+ 			case GADOPICKUPTYPES:
X+ 			    ActivateGadget(
X+ 				FindGadget( cwin, 0, GADOCATNAME ),
X+ 				cwin, 0 );
X+ 			    break;
X+ 
X+ 			case GADOWINDOWTYPE:
X+ 			    ActivateGadget(
X+ 				FindGadget( cwin, 0, GADODOGNAME ),
X+ 				cwin, 0 );
X+ 			    break;
X+ 
X+ 			case GADOMSGHISTORY:
X+ 			    ActivateGadget(
X+ 				FindGadget( cwin, 0, GADOFRUIT ),
X+ 				cwin, 0 );
X+ 			    break;
X+ 
X+ 			case GADOPALETTE:
X+ 			    ActivateGadget(
X+ 				FindGadget( cwin, 0, GADOOBJECTS ),
X+ 				cwin, 0 );
X+ 			    break;
X+ 
X+ 			case GADOSCORE:
X+ 			    ActivateGadget(
X+ 				FindGadget( cwin, 0, GADONAME ),
X+ 				cwin, 0 );
X+ 			    break;
X+ 
X+ 			case GADOPETTYPE:
X+ 			    break;
X+ 
X  			case GADOOKAY:
X  			    done = 1;
X  			    break;
X***************
X*** 3865,3871 ****
X  			    {
X  				if( optr[ i ].optstr != NULL )
X  				{
X! 				    if( optr[i].optstr && *optr[i].optstr )
X  					free( optr[i].optstr );
X  
X  				    if( *Sbuff(gd) == 0 )
X--- 3668,3674 ----
X  			    {
X  				if( optr[ i ].optstr != NULL )
X  				{
X! 				    if( *optr[i].optstr )
X  					free( optr[i].optstr );
X  
X  				    if( *Sbuff(gd) == 0 )
X***************
X*** 3987,4019 ****
X  
X      setoneopt( OPTIONS_IDX, optbuf );
X      free( optbuf );
X- }
X- 
X- void Game2Defs( gptr )
X-     register GPTR gptr;
X- {
X-     register char *s;
X-     register int i;
X- 
X-     if( defgame.plname )
X- 	free( defgame.plname );
X-     defgame.plname = strdup( ToolsEntry( gptr, "NAME" ) );
X- 
X-     s = ToolsEntry( gptr, "CHARACTER" );
X-     for( i = 0; players[ i ]; ++i )
X-     {
X- 	if( strnicmp( s, players[ i ], strlen(s) ) == 0 )
X- 	    break;
X-     }
X- 
X-     if( players[ i ] )
X- 	defgame.pltype = i;
X-     else
X- 	defgame.pltype = 0;
X- 
X-     if( defgame.options )
X- 	free( defgame.options );
X-     defgame.options = strdup( ToolsEntry( gptr, "OPTIONS" ) );
X  }
X  
X  char *basename( str )
X--- 3790,3795 ----
END_OF_FILE
if test 58318 -ne `wc -c <'patches02m'`; then
    echo shar: \"'patches02m'\" unpacked with wrong size!
fi
# end of 'patches02m'
echo shar: End of archive 2 \(of 33\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 33 archives.
    echo "Now execute ./patchit.sh"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
