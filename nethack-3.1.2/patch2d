Path: uunet!news.tek.com!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v17i079:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Patch2d/33
Date: 11 Jun 1993 00:06:24 GMT
Organization: Tektronix, Inc, Redmond, OR, USA
Lines: 2132
Approved: billr@saab.CNA.TEK.COM
Message-ID: <1v8ia0$ipt@ying.cna.tek.com>
NNTP-Posting-Host: saab.cna.tek.com
Xref: uunet comp.sources.games:1767

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 17, Issue 79
Archive-name: nethack31/Patch2d
Patch-To: nethack31: Volume 16, Issue 1-116
Environment: Amiga, Atari, Mac, MS-DOS, Windows-NT, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 4 (of 33)."
# Contents:  patches02d sys/mac/NHDeflts
# Wrapped by billr@saab on Thu Jun 10 16:55:00 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'patches02d' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'patches02d'\" to \"'patches02d.orig'\"
  mv -f 'patches02d' 'patches02d.orig'
fi
echo shar: Extracting \"'patches02d'\" \(56886 characters\)
sed "s/^X//" >'patches02d' <<'END_OF_FILE'
X*** /tmp/da10978	Tue Jun  1 16:13:38 1993
X--- src/exper.c	Wed Mar  3 14:21:59 1993
X***************
X*** 24,29 ****
X--- 24,32 ----
X  experience(mtmp, nk)	/* return # of exp points for mtmp after nk killed */
X  	register struct	monst *mtmp;
X  	register int	nk;
X+ #if defined(applec)
X+ # pragma unused(nk)
X+ #endif
X  {
X  	register struct permonst *ptr = mtmp->data;
X  	int	i, tmp, tmp2;
X*** /tmp/da10986	Tue Jun  1 16:13:40 1993
X--- src/explode.c	Mon May 17 14:04:31 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)explode.c 3.1	93/02/17
X  /*	Copyright (C) 1990 by Ken Arromdee */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)explode.c 3.1	93/05/15	*/
X  /*	Copyright (C) 1990 by Ken Arromdee */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 5,14 ****
X  #include "hack.h"
X  
X  /* Note: Arrays are column first, while the screen is row first */
X! static int expl[3][3] = 
X! { S_explode1, S_explode4, S_explode7,
X!   S_explode2, S_explode5, S_explode8,
X!   S_explode3, S_explode6, S_explode9 };
X  
X  /* Note: I had to choose one of three possible kinds of "type" when writing
X   * this function: a wand type (like in zap.c), an adtyp, or an object type.
X--- 5,15 ----
X  #include "hack.h"
X  
X  /* Note: Arrays are column first, while the screen is row first */
X! static int expl[3][3] = {
X! 	{ S_explode1, S_explode4, S_explode7 },
X! 	{ S_explode2, S_explode5, S_explode8 },
X! 	{ S_explode3, S_explode6, S_explode9 }
X! };
X  
X  /* Note: I had to choose one of three possible kinds of "type" when writing
X   * this function: a wand type (like in zap.c), an adtyp, or an object type.
X***************
X*** 68,74 ****
X  		    }
X  		}
X  		/* can be both you and mtmp if you're swallowed */
X! 		if (mtmp = m_at(i+x-1, j+y-1)) {
X  		    switch(adtyp) {
X  			case AD_FIRE:
X  				explmask[i][j] = resists_fire(mtmp->data)
X--- 69,75 ----
X  		    }
X  		}
X  		/* can be both you and mtmp if you're swallowed */
X! 		if ((mtmp = m_at(i+x-1, j+y-1)) != 0) {
X  		    switch(adtyp) {
X  			case AD_FIRE:
X  				explmask[i][j] = resists_fire(mtmp->data)
X***************
X*** 83,89 ****
X  				explmask[i][j] = 0;
X  				break;
X  		    }
X! 		} else if (i+x-1 != u.ux || j+j-1 != u.uy)
X  		    explmask[i][j] = 0;
X  
X  		if (cansee(i+x-1, j+y-1)) visible = TRUE;
X--- 84,90 ----
X  				explmask[i][j] = 0;
X  				break;
X  		    }
X! 		} else if (i+x-1 != u.ux || j+y-1 != u.uy)
X  		    explmask[i][j] = 0;
X  
X  		if (cansee(i+x-1, j+y-1)) visible = TRUE;
X*** /tmp/da11002	Tue Jun  1 16:13:44 1993
X--- src/files.c	Mon May 24 12:32:37 1993
X***************
X*** 449,470 ****
X  
X  /* ----------  BEGIN FILE COMPRESSION HANDLING ----------- */
X  
X  /* compress file */
X  void
X  compress(filename)
X  const char *filename;
X  {
X  #ifdef COMPRESS
X! 	char cmd[80];
X! 
X! 	Strcpy(cmd, COMPRESS);
X! 	Strcat(cmd, " ");
X! # ifdef COMPRESS_OPTIONS
X! 	Strcat(cmd, COMPRESS_OPTIONS);
X! 	Strcat(cmd, " ");
X! # endif
X! 	Strcat(cmd,filename);
X! 	(void) system(cmd);
X  #endif
X  }
X  
X--- 449,534 ----
X  
X  /* ----------  BEGIN FILE COMPRESSION HANDLING ----------- */
X  
X+ #ifdef COMPRESS
X+ /* 
X+  * using system() is simpler, but opens up security holes and causes
X+  * problems on at least Interactive UNIX 3.0.1 (SVR3.2), where any
X+  * setuid is renounced by /bin/sh, so the files cannot be accessed.
X+  *
X+  * cf. child() in unixunix.c.
X+  */
X+ void
X+ docompress_file(filename, uncomp)
X+ char *filename;
X+ boolean uncomp;
X+ {
X+ 	char *args[10];
X+ # ifdef COMPRESS_OPTIONS
X+ 	char opts[80];
X+ # endif
X+ 	int i = 0;
X+ 	int f;
X+ 
X+ 	args[0] = COMPRESS;
X+ 	if (uncomp) args[++i] = "-d";	/* uncompress */
X+ # ifdef COMPRESS_OPTIONS
X+ 	{
X+ 	    /* we can't guarantee there's only one additional option, sigh */
X+ 	    char *opt;
X+ 	    boolean inword = FALSE;
X+ 
X+ 	    Strcpy(opts, COMPRESS_OPTIONS);
X+ 	    opt = opts;
X+ 	    while (*opt) {
X+ 		if ((*opt == ' ') || (*opt == '\t')) {
X+ 		    if (inword) {
X+ 			*opt = '\0';
X+ 			inword = FALSE;
X+ 		    }
X+ 		} else if (!inword) {
X+ 		    args[++i] = opt;
X+ 		    inword = TRUE;
X+ 		}
X+ 		opt++;
X+ 	    }
X+ 	}
X+ # endif
X+ 	args[++i] = filename;
X+ 	args[++i] = NULL;
X+ 
X+ 	f = fork();
X+ 	if (f == 0) {	/* child */
X+ 		(void) execv(args[0], args);
X+ 		perror(NULL);
X+ 		pline("Exec to %scompress %s failed.",
X+ 			uncomp ? "un" : "", filename);
X+ 		exit(1);
X+ 	} else if (f == -1) {
X+ 		perror(NULL);
X+ 		pline("Fork to %scompress %s failed.",
X+ 			uncomp ? "un" : "", filename);
X+ 		return;
X+ 	}
X+ 	(void) signal(SIGINT, SIG_IGN);
X+ 	(void) signal(SIGQUIT, SIG_IGN);
X+ 	(void) wait((int *)0);
X+ 	(void) signal(SIGINT, (SIG_RET_TYPE) done1);
X+ # ifdef WIZARD
X+ 	if (wizard) (void) signal(SIGQUIT, SIG_DFL);
X+ # endif
X+ }
X+ #endif
X+ 
X  /* compress file */
X  void
X  compress(filename)
X  const char *filename;
X+ #ifdef applec
X+ # pragma unused(filename)
X+ #endif
X  {
X  #ifdef COMPRESS
X! 	docompress_file(filename, FALSE);
X  #endif
X  }
X  
X***************
X*** 473,497 ****
X  void
X  uncompress(filename)
X  const char *filename;
X  {
X  #ifdef COMPRESS
X! 	char cmd[80], cfn[80];
X  	int fd;
X  
X! 	Strcpy(cfn,filename);
X  # ifdef COMPRESS_EXTENSION
X! 	Strcat(cfn,COMPRESS_EXTENSION);
X  # endif
X! 	if((fd = open(cfn,O_RDONLY)) >= 0) {
X! 	    (void) close(fd);
X! 	    Strcpy(cmd, COMPRESS);
X! 	    Strcat(cmd, " -d ");        /* uncompress */
X! # ifdef COMPRESS_OPTIONS
X! 	    Strcat(cmd, COMPRESS_OPTIONS);
X! 	    Strcat(cmd, " ");
X! # endif
X! 	    Strcat(cmd,cfn);
X! 	    (void) system(cmd);
X  	}
X  #endif
X  }
X--- 537,557 ----
X  void
X  uncompress(filename)
X  const char *filename;
X+ #ifdef applec
X+ # pragma unused(filename)
X+ #endif
X  {
X  #ifdef COMPRESS
X! 	char cfn[80];
X  	int fd;
X  
X! 	Strcpy(cfn, filename);
X  # ifdef COMPRESS_EXTENSION
X! 	Strcat(cfn, COMPRESS_EXTENSION);
X  # endif
X! 	if ((fd = open(cfn, O_RDONLY)) >= 0) {
X! 		(void) close(fd);
X! 		docompress_file(cfn, TRUE);
X  	}
X  #endif
X  }
X***************
X*** 540,545 ****
X--- 600,608 ----
X  lock_file(filename, retryct)
X  const char *filename;
X  int retryct;
X+ #ifdef applec
X+ # pragma unused(filename, retryct)
X+ #endif
X  {
X  #if defined(UNIX) || defined(VMS)
X  	char *lockname;
X***************
X*** 609,614 ****
X--- 672,680 ----
X  void
X  unlock_file(filename)
X  const char *filename;
X+ #if defined(applec)
X+ # pragma unused(filename)
X+ #endif
X  {
X  #if defined(UNIX) || defined(VMS)
X  	char *lockname;
X***************
X*** 658,666 ****
X  #endif
X  
X  	/* "filename" is an environment variable, so it should hang around */
X! 	if (filename && ((fp = fopenp(filename, "r")) != (FILE *)0)) {
X! 		configfile = filename;
X! 		return(fp);
X  	}
X  
X  #if defined(MICRO) || defined(MAC)
X--- 724,748 ----
X  #endif
X  
X  	/* "filename" is an environment variable, so it should hang around */
X! 	if (filename) {
X! #ifdef UNIX
X! 		if (access(filename, 4) == -1) {
X! 			/* 4 is R_OK on newer systems */
X! 			/* nasty sneaky attempt to read file through
X! 			 * NetHack's setuid permissions -- this is the only
X! 			 * place a file name may be wholly under the player's
X! 			 * control
X! 			 */
X! 			raw_printf("Access to %s denied (%d).",
X! 					filename, errno);
X! 			wait_synch();
X! 			/* fall through to standard names */
X! 		} else
X! #endif
X! 		if ((fp = fopenp(filename, "r")) != (FILE *)0) {
X! 			configfile = filename;
X! 			return(fp);
X! 		}
X  	}
X  
X  #if defined(MICRO) || defined(MAC)
X***************
X*** 752,757 ****
X--- 834,842 ----
X  char		*buf;
X  char		*tmp_ramdisk;
X  char		*tmp_levels;
X+ #if defined(applec)
X+ # pragma unused(tmp_ramdisk,tmp_levels)
X+ #endif
X  {
X  	char		*bufp, *altp;
X  
X***************
X*** 798,813 ****
X  		(void) strncpy(tmp_levels, bufp, PATHLEN);
X  
X  	} else if (!strncmpi(buf, "SAVE", 4)) {
X  		char *ptr;
X  		if (ptr = index(bufp, ';')) {
X  			*ptr = '\0';
X  # ifdef MFLOPPY
X  			if (*(ptr+1) == 'n' || *(ptr+1) == 'N') {
X- 				extern	int saveprompt;
X  				saveprompt = FALSE;
X  			}
X  # endif
X!     }
X  		(void) strncpy(SAVEP, bufp, PATHLEN);
X  		append_slash(SAVEP);
X  #endif /* MICRO */
X--- 883,905 ----
X  		(void) strncpy(tmp_levels, bufp, PATHLEN);
X  
X  	} else if (!strncmpi(buf, "SAVE", 4)) {
X+ # ifdef MFLOPPY
X+ 		extern	int saveprompt;
X+ #endif
X  		char *ptr;
X  		if (ptr = index(bufp, ';')) {
X  			*ptr = '\0';
X  # ifdef MFLOPPY
X  			if (*(ptr+1) == 'n' || *(ptr+1) == 'N') {
X  				saveprompt = FALSE;
X  			}
X  # endif
X! 		}
X! #ifdef	MFLOPPY
X! 		else
X! 		    saveprompt = flags.asksavedisk;
X! #endif
X! 
X  		(void) strncpy(SAVEP, bufp, PATHLEN);
X  		append_slash(SAVEP);
X  #endif /* MICRO */
X***************
X*** 836,854 ****
X  	    (void) get_uchars(fp, buf, bufp, &(monsyms[1]),
X  					MAXMCLASSES-1, "MONSTERS");
X  #ifdef AMIGA
X  	} else if (!strncmpi(buf, "PATH", 4)) {
X  		(void) strncpy(PATH, bufp, PATHLEN);
X- #endif
X- #ifdef AMII_GRAPHICS
X  	} else if (!strncmpi(buf, "PENS", 3)) {
X  		int i;
X  		char *t;
X! 		for (i = 0, t = strtok(bufp, ",");
X! 				t && i < 8;
X! 				t = strtok(NULL, ","), ++i) {
X  			sscanf(t, "%hx", &flags.amii_curmap[i]);
X  		}
X  		amii_setpens();
X  #endif
X  	} else
X  		return 0;
X--- 928,959 ----
X  	    (void) get_uchars(fp, buf, bufp, &(monsyms[1]),
X  					MAXMCLASSES-1, "MONSTERS");
X  #ifdef AMIGA
X+ 	} else if (!strncmpi(buf, "FONT", 4)) {
X+ 		char *t;
X+ 		int size;
X+ 		extern void amii_set_text_font( char *, int );
X+ 
X+ 		if( t = strchr( buf+5, ':' ) )
X+ 		{
X+ 		    *t = 0;
X+ 		    amii_set_text_font( buf+5, atoi( t + 1 ) );
X+ 		    *t = ':';
X+ 		}
X  	} else if (!strncmpi(buf, "PATH", 4)) {
X  		(void) strncpy(PATH, bufp, PATHLEN);
X  	} else if (!strncmpi(buf, "PENS", 3)) {
X+ # ifdef AMII_GRAPHICS
X  		int i;
X  		char *t;
X! 		extern void amii_setpens( void );
X! 
X! 		for (i = 0, t = strtok(bufp, ",/"); t != NULL;
X! 				    t = strtok(NULL, ",/"), ++i)
X! 		{
X  			sscanf(t, "%hx", &flags.amii_curmap[i]);
X  		}
X  		amii_setpens();
X+ # endif
X  #endif
X  	} else
X  		return 0;
X***************
X*** 942,947 ****
X--- 1047,1055 ----
X  void
X  check_recordfile(dir)
X  const char *dir;
X+ #if defined(applec)
X+ # pragma unused(dir)
X+ #endif
X  {
X  #if defined(UNIX) || defined(VMS)
X  	int fd = open(RECORD, O_RDWR, 0);
X*** /tmp/da11010	Tue Jun  1 16:13:47 1993
X--- src/fountain.c	Wed May 19 10:08:25 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)fountain.c	3.1	93/02/13	*/
X  /*	Copyright Scott R. Turner, srt@ucla, 10/27/86 */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)fountain.c	3.1	93/05/18	*/
X  /*	Copyright Scott R. Turner, srt@ucla, 10/27/86 */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 108,116 ****
X  	    pline("Water gushes forth from the overflowing fountain!");
X  
X  	/* Put a pool at x, y */
X- 
X  	levl[x][y].typ = POOL;
X! 
X  	water_damage(level.objects[x][y], FALSE, TRUE);
X  
X  	if ((mtmp = m_at(x, y)) != 0)
X--- 108,115 ----
X  	    pline("Water gushes forth from the overflowing fountain!");
X  
X  	/* Put a pool at x, y */
X  	levl[x][y].typ = POOL;
X! 	del_engr_at(x, y);
X  	water_damage(level.objects[x][y], FALSE, TRUE);
X  
X  	if ((mtmp = m_at(x, y)) != 0)
X***************
X*** 513,524 ****
X  			morehungry(rn1(30-ACURR(A_CON), 11));
X  			vomit();
X  			break;
X- #ifdef POLYSELF
X  		case 10: pline("This water contains toxic wastes!");
X  			You("undergo a freakish metamorphosis!");
X  			polyself();
X! 			break;
X  #endif
X  		/* more odd messages --JJB */
X  		case 11: You("hear clanking from the pipes....");
X  			break;
X--- 512,525 ----
X  			morehungry(rn1(30-ACURR(A_CON), 11));
X  			vomit();
X  			break;
X  		case 10: pline("This water contains toxic wastes!");
X  			You("undergo a freakish metamorphosis!");
X+ #ifdef POLYSELF
X  			polyself();
X! #else
X! 			newman();
X  #endif
X+ 			break;
X  		/* more odd messages --JJB */
X  		case 11: You("hear clanking from the pipes....");
X  			break;
X*** /tmp/da11018	Tue Jun  1 16:13:50 1993
X--- src/hack.c	Tue Jun  1 10:42:03 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)hack.c	3.1	93/02/18	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)hack.c	3.1	93/05/18	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 115,120 ****
X--- 115,124 ----
X  		case SPIKED_PIT:
X  		case PIT:
X  		    freeobj(otmp);
X+ 		    /* vision kludge to get messages right;
X+ 		       the pit will temporarily be seen even
X+ 		       if this is one among multiple boulders */
X+ 		    if (!Blind) viz_array[ry][rx] |= IN_SIGHT;
X  		    if (!flooreffects(otmp, rx, ry, "fall")) {
X  			place_object(otmp, rx, ry);
X  			otmp->nobj = fobj;
X***************
X*** 126,132 ****
X  			  The(xname(otmp)));
X  		    deltrap(ttmp);
X  		    delobj(otmp);
X! 		    delallobj(rx, ry);
X  		    if (cansee(rx,ry)) newsym(rx,ry);
X  		    continue;
X  		case LEVEL_TELEP:
X--- 130,136 ----
X  			  The(xname(otmp)));
X  		    deltrap(ttmp);
X  		    delobj(otmp);
X! 		    bury_objs(rx, ry);
X  		    if (cansee(rx,ry)) newsym(rx,ry);
X  		    continue;
X  		case LEVEL_TELEP:
X***************
X*** 286,292 ****
X      } else if (lev->typ == SDOOR) {
X  	if (lev->doormask & D_TRAPPED) {
X  	    lev->doormask = D_NODOOR;
X! 	    b_trapped("secret door");
X  	} else {
X  	    digtxt = "chew through the secret door.";
X  	    lev->doormask = D_BROKEN;
X--- 290,296 ----
X      } else if (lev->typ == SDOOR) {
X  	if (lev->doormask & D_TRAPPED) {
X  	    lev->doormask = D_NODOOR;
X! 	    b_trapped("secret door", 0);
X  	} else {
X  	    digtxt = "chew through the secret door.";
X  	    lev->doormask = D_BROKEN;
X***************
X*** 300,306 ****
X  	}
X  	if (lev->doormask & D_TRAPPED) {
X  	    lev->doormask = D_NODOOR;
X! 	    b_trapped("door");
X  	} else {
X  	    digtxt = "chew through the door.";
X  	    lev->doormask = D_BROKEN;
X--- 304,310 ----
X  	}
X  	if (lev->doormask & D_TRAPPED) {
X  	    lev->doormask = D_NODOOR;
X! 	    b_trapped("door", 0);
X  	} else {
X  	    digtxt = "chew through the door.";
X  	    lev->doormask = D_BROKEN;
X***************
X*** 513,518 ****
X--- 517,532 ----
X  				y = u.uy + u.dy;
X  			} while(!isok(x, y) || bad_rock(x, y));
X  		}
X+ 		/* turbulence might alter your actual destination */
X+ 		if (u.uinwater) {
X+ 			water_friction();
X+ 			if (!u.dx && !u.dy) {
X+ 				nomul(0);
X+ 				return;
X+ 			}
X+ 			x = u.ux + u.dx;
X+ 			y = u.uy + u.dy;
X+ 		}
X  		if(!isok(x, y)) {
X  			nomul(0);
X  			return;
X***************
X*** 783,789 ****
X  
X  	/* now move the hero */
X  	mtmp = m_at(x, y);
X- 	if (u.uinwater) water_friction();
X  	u.ux += u.dx;
X  	u.uy += u.dy;
X  	/* if safepet at destination then move the pet to the hero's
X--- 797,802 ----
X***************
X*** 980,990 ****
X  	if(IS_SINK(levl[u.ux][u.uy].typ) && Levitation)
X  		dosinkfall();
X  #endif
X! 	if(!flags.nopick && OBJ_AT(u.ux, u.uy) &&
X! 	   (!is_pool(u.ux,u.uy) || Underwater))
X! 		pickup(1);
X! 	else read_engr_at(u.ux,u.uy);
X! 	if(trap = t_at(u.ux,u.uy))
X  		dotrap(trap);	/* fall into pit, arrow trap, etc. */
X  	if((mtmp = m_at(u.ux, u.uy)) && !u.uswallow) {
X  		mtmp->mundetected = 0;
X--- 993,1000 ----
X  	if(IS_SINK(levl[u.ux][u.uy].typ) && Levitation)
X  		dosinkfall();
X  #endif
X! 	pickup(1);
X! 	if ((trap = t_at(u.ux,u.uy)) != 0)
X  		dotrap(trap);	/* fall into pit, arrow trap, etc. */
X  	if((mtmp = m_at(u.ux, u.uy)) && !u.uswallow) {
X  		mtmp->mundetected = 0;
X***************
X*** 1162,1172 ****
X  	if (*u.ushops0)
X  	    u_left_shop(u.ushops_left, newlev);
X  
X! 	if (!*u.uentered && !*u.ushops_entered) 
X  	    return;		/* no entrance messages necessary */
X  
X  	/* Did we just enter a shop? */
X! 	if (*u.ushops_entered && !newlev)
X              u_entered_shop(u.ushops_entered);
X  
X  	for (ptr = &u.uentered[0]; *ptr; ptr++) {
X--- 1172,1182 ----
X  	if (*u.ushops0)
X  	    u_left_shop(u.ushops_left, newlev);
X  
X! 	if (!*u.uentered && !*u.ushops_entered) 	/* implied by newlev */
X  	    return;		/* no entrance messages necessary */
X  
X  	/* Did we just enter a shop? */
X! 	if (*u.ushops_entered)
X              u_entered_shop(u.ushops_entered);
X  
X  	for (ptr = &u.uentered[0]; *ptr; ptr++) {
X***************
X*** 1176,1228 ****
X  	    /* vault.c insists that a vault remain a VAULT,
X  	     * and temples should remain TEMPLEs,
X  	     * but everything else gives a message only the first time */
X! 	    if(!newlev) 
X! 	   	switch (rt) {
X! 		    case ZOO:
X! 		   	pline("Welcome to David's treasure zoo!");
X! 		    	break;
X! 		    case SWAMP:
X! 		    	pline("It %s rather %s down here.",
X! 	    		      Blind ? "feels" : "looks",
X! 	    		      Blind ? "humid" : "muddy");
X! 		    	break;
X! 		    case COURT:
X! 			You("enter an opulent throne room!");
X! 		    	break;
X! 		    case MORGUE:
X! 		    	if(midnight())
X! 			    pline("Run away!  Run away!");
X! 		    	else
X! 			    You("have an uncanny feeling...");
X! 		    	break;
X! 		    case BEEHIVE:
X! 		    	You("enter a giant beehive!");
X! 		    	break;
X  #ifdef ARMY
X! 		    case BARRACKS:
X! 		    	if(monstinroom(&mons[PM_SOLDIER], roomno) ||
X! 			    monstinroom(&mons[PM_SERGEANT], roomno) ||
X! 			    monstinroom(&mons[PM_LIEUTENANT], roomno) ||
X! 			    monstinroom(&mons[PM_CAPTAIN], roomno))
X! 		    	    You("enter a military barracks!");
X! 		    	else 
X! 			    You("enter an abandoned barracks.");
X! 		    	break;
X  #endif
X! 		    case DELPHI:
X! 		    	if(monstinroom(&mons[PM_ORACLE], roomno))
X! 			    verbalize("Hello, %s, welcome to Delphi!", plname);
X! 		    	break;
X! 		    case TEMPLE:
X! 			intemple(roomno + ROOMOFFSET);
X! 		    	/* fall through */
X! 		    default:
X! 		    	rt = 0;
X! 	    	} 
X! 	    else 
X! 		rt = 0;
X  
X! 	    if(rt != 0) {
X  		rooms[roomno].rtype = OROOM;
X  		if (!search_special(rt)) {
X  			/* No more room of that type */
X--- 1186,1240 ----
X  	    /* vault.c insists that a vault remain a VAULT,
X  	     * and temples should remain TEMPLEs,
X  	     * but everything else gives a message only the first time */
X! 	    switch (rt) {
X! 		case ZOO:
X! 		    pline("Welcome to David's treasure zoo!");
X! 		    break;
X! 		case SWAMP:
X! 		    pline("It %s rather %s down here.",
X! 			  Blind ? "feels" : "looks",
X! 			  Blind ? "humid" : "muddy");
X! 		    break;
X! 		case COURT:
X! 		    You("enter an opulent throne room!");
X! 		    break;
X! 		case MORGUE:
X! 		    if(midnight()) {
X! #ifdef POLYSELF
X! 			const char *run = locomotion(uasmon, "Run");
X! 			pline("%s away!  %s away!", run, run);
X! #else
X! 			pline("Run away!  Run away!");
X! #endif
X! 		    } else
X! 			You("have an uncanny feeling...");
X! 		    break;
X! 		case BEEHIVE:
X! 		    You("enter a giant beehive!");
X! 		    break;
X  #ifdef ARMY
X! 		case BARRACKS:
X! 		    if(monstinroom(&mons[PM_SOLDIER], roomno) ||
X! 			monstinroom(&mons[PM_SERGEANT], roomno) ||
X! 			monstinroom(&mons[PM_LIEUTENANT], roomno) ||
X! 			monstinroom(&mons[PM_CAPTAIN], roomno))
X! 			You("enter a military barracks!");
X! 		    else 
X! 			You("enter an abandoned barracks.");
X! 		    break;
X  #endif
X! 		case DELPHI:
X! 		    if(monstinroom(&mons[PM_ORACLE], roomno))
X! 			verbalize("Hello, %s, welcome to Delphi!", plname);
X! 		    break;
X! 		case TEMPLE:
X! 		    intemple(roomno + ROOMOFFSET);
X! 		    /* fall through */
X! 		default:
X! 		    rt = 0;
X! 	    } 
X  
X! 	    if (rt != 0) {
X  		rooms[roomno].rtype = OROOM;
X  		if (!search_special(rt)) {
X  			/* No more room of that type */
X***************
X*** 1302,1308 ****
X  		return(0);
X  	}
X  	if(Levitation && !Is_airlevel(&u.uz) && !Is_waterlevel(&u.uz)) {
X! 		You("cannot reach the floor.");
X  		return(1);
X  	}
X  	pickup(-count);
X--- 1314,1320 ----
X  		return(0);
X  	}
X  	if(Levitation && !Is_airlevel(&u.uz) && !Is_waterlevel(&u.uz)) {
X! 		You("cannot reach the %s.", surface(u.ux,u.uy));
X  		return(1);
X  	}
X  	pickup(-count);
X*** /tmp/da11034	Tue Jun  1 16:13:55 1993
X--- src/invent.c	Wed May 19 10:30:00 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)invent.c	3.1	92/12/11	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)invent.c	3.1	93/05/17	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 21,26 ****
X--- 21,27 ----
X  static struct obj *FDECL(find_unpaid,(struct obj *,struct obj **));
X  static boolean NDECL(wearing_armor);
X  static boolean FDECL(is_worn,(struct obj *));
X+ static boolean FDECL(is_fully_identified,(struct obj *));
X  #endif /* OVLB */
X  STATIC_DCL char FDECL(obj_to_let,(struct obj *));
X  
X***************
X*** 28,38 ****
X  
X  static int lastinvnr = 51;	/* 0 ... 51 (never saved&restored) */
X  
X- char inv_order[] = {	/* manipulated in options.c, used below */
X- 	AMULET_CLASS, WEAPON_CLASS, ARMOR_CLASS, FOOD_CLASS, SCROLL_CLASS,
X- 	SPBOOK_CLASS, POTION_CLASS, RING_CLASS, WAND_CLASS, TOOL_CLASS, 
X- 	GEM_CLASS, ROCK_CLASS, BALL_CLASS, CHAIN_CLASS, 0 };
X- 
X  #ifdef WIZARD
X  /* wizards can wish for venom, which will become an invisible inventory
X   * item without this.  putting it in inv_order would mean venom would
X--- 29,34 ----
X***************
X*** 325,333 ****
X  	struct obj *otmp, *otmp2;
X  
X  	for (otmp = level.objects[x][y]; otmp; otmp = otmp2) {
X- 		otmp2 = otmp->nexthere;
X  		if (otmp == uball)
X  			unpunish();
X  		if (otmp == uchain)
X  			continue;
X  		delobj(otmp);
X--- 321,330 ----
X  	struct obj *otmp, *otmp2;
X  
X  	for (otmp = level.objects[x][y]; otmp; otmp = otmp2) {
X  		if (otmp == uball)
X  			unpunish();
X+ 		/* after unpunish(), or might get deallocated chain */
X+ 		otmp2 = otmp->nexthere;
X  		if (otmp == uchain)
X  			continue;
X  		delobj(otmp);
X***************
X*** 334,339 ****
X--- 331,426 ----
X  	}
X  }
X  
X+ /* move objects from fobj/nexthere lists to buriedobjlist, keeping position
X+  * information */
X+ void
X+ bury_objs(x, y)
X+ int x, y;
X+ {
X+ 	struct obj *otmp, *otmp2;
X+ 
X+ 	for (otmp = level.objects[x][y]; otmp; otmp = otmp2) {
X+ 		if (otmp == uball)
X+ 			unpunish();
X+ 		/* after unpunish(), or might get deallocated chain */
X+ 		otmp2 = otmp->nexthere;
X+ 		if (otmp == uchain)
X+ 			continue;
X+ #ifdef WALKIES
X+ 		if (otmp->otyp == LEASH && otmp->leashmon != 0)
X+ 			o_unleash(otmp);
X+ #endif
X+ 		if (otmp->lamplit) {
X+ 			otmp->lamplit = 0;
X+ 			check_lamps();
X+ 		}
X+ 		freeobj(otmp);
X+ 		if (otmp->otyp == ROCK) {
X+ 			/* melts into burying material */
X+ 			obfree(otmp, (struct obj *)0);
X+ 			continue;
X+ 		}
X+ 		otmp->nexthere = (struct obj *)0;
X+ 		otmp->nobj = level.buriedobjlist;
X+ 		level.buriedobjlist = otmp;
X+ 	}
X+ 	/* don't expect any engravings here, but just in case */
X+ 	del_engr_at(x, y);
X+ 	newsym(x, y);
X+ }
X+ 
X+ /* delete buried object */
X+ void
X+ delburiedobj(obj)
X+ struct obj *obj;
X+ {
X+ 	struct obj *otmp;
X+ 	if (obj == level.buriedobjlist)
X+ 		level.buriedobjlist = obj->nobj;
X+ 	else {
X+ 		for (otmp = level.buriedobjlist; otmp; otmp = otmp->nobj)
X+ 			if (otmp->nobj == obj) {
X+ 				otmp->nobj = obj->nobj;
X+ 				break;
X+ 			}
X+ 		if (!otmp) panic("error in delburiedobj");
X+ 	}
X+ 	obfree(obj, (struct obj *) 0);	/* frees contents also */
X+ }
X+ 
X+ /* move objects from buriedobjlist to fobj/nexthere lists */
X+ void
X+ unearth_objs(x, y)
X+ int x, y;
X+ {
X+ 	struct obj *otmp, *otmp2, *prevobj;
X+ 
X+ 	remove_cadavers(&level.buriedobjlist);
X+ 
X+ 	prevobj = (struct obj *) 0;
X+ 	for (otmp = level.buriedobjlist; otmp; otmp = otmp2) {
X+ 		otmp2 = otmp->nobj;
X+ 		if (otmp->ox == x && otmp->oy == y) {
X+ 			if (prevobj)
X+ 				prevobj->nobj = otmp2;
X+ 			else
X+ 				level.buriedobjlist = otmp2;
X+ 			if (is_organic(otmp) && rn2(2)) {
X+ 				/* rotted away */
X+ 				obfree(otmp, (struct obj *) 0);
X+ 			} else {
X+ 				otmp->nobj = fobj;
X+ 				fobj = otmp;
X+ 				place_object(otmp, x, y);
X+ 				stackobj(otmp);
X+ 			}
X+ 		} else
X+ 			prevobj = otmp;
X+ 	}
X+ 	del_engr_at(x, y);
X+ 	newsym(x, y);
X+ }
X+ 
X  #endif /* OVL3 */
X  #ifdef OVL2
X  
X***************
X*** 345,350 ****
X--- 432,448 ----
X  #ifdef WALKIES
X  	if(obj->otyp == LEASH && obj->leashmon != 0) o_unleash(obj);
X  #endif
X+ 	if (obj->otyp == AMULET_OF_YENDOR ||
X+ 			obj->otyp == CANDELABRUM_OF_INVOCATION ||
X+ 			obj->otyp == BELL_OF_OPENING ||
X+ 			obj->otyp == SPE_BOOK_OF_THE_DEAD) {
X+ 		/* player might be doing something stupid, but we
X+ 		 * can't guarantee that.  assume special artifacts
X+ 		 * are indestructible via drawbridges, and exploding
X+ 		 * chests, and golem creation, and ...
X+ 		 */
X+ 		return;
X+ 	}
X  	freeobj(obj);
X  	newsym(obj->ox,obj->oy);
X  	obfree(obj, (struct obj *) 0);	/* frees contents also */
X***************
X*** 431,437 ****
X  
X  	while(objchn) {
X  		if(objchn->o_id == id) return(objchn);
X! 		if (Is_container(objchn) && (temp = o_on(id,objchn->cobj)))
X  			return temp;
X  		objchn = objchn->nobj;
X  	}
X--- 529,535 ----
X  
X  	while(objchn) {
X  		if(objchn->o_id == id) return(objchn);
X! 		if (Has_contents(objchn) && (temp = o_on(id,objchn->cobj)))
X  			return temp;
X  		objchn = objchn->nobj;
X  	}
X***************
X*** 589,609 ****
X  		else if ((!strcmp(word, "wear") &&
X  		    (otmp->oclass == TOOL_CLASS &&
X  		     otmp->otyp != BLINDFOLD && otmp->otyp != TOWEL))
X  #ifdef POLYSELF
X  		|| (!strcmp(word, "eat") && !is_edible(otmp))
X  #endif
X! 		|| (!strcmp(word, "can") &&
X! 		    (otmp->otyp != CORPSE))
X  		|| (!strcmp(word, "write with") &&
X  		    (otmp->oclass == TOOL_CLASS &&
X  		     otmp->otyp != MAGIC_MARKER && otmp->otyp != TOWEL))
X  		|| (!strcmp(word, "rub") &&
X  		    (otmp->oclass == TOOL_CLASS &&
X  		     otmp->otyp != OIL_LAMP && otmp->otyp != MAGIC_LAMP &&
X  		     otmp->otyp != BRASS_LANTERN))
X- 		|| (!strcmp(word, "wield") &&
X- 		    (otmp->oclass == TOOL_CLASS &&
X- 		     otmp->otyp != PICK_AXE && otmp->otyp != UNICORN_HORN))
X  		    )
X  			foo--;
X  	    } else {
X--- 687,711 ----
X  		else if ((!strcmp(word, "wear") &&
X  		    (otmp->oclass == TOOL_CLASS &&
X  		     otmp->otyp != BLINDFOLD && otmp->otyp != TOWEL))
X+ 		|| (!strcmp(word, "wield") &&
X+ 		    (otmp->oclass == TOOL_CLASS &&
X+ 		     otmp->otyp != PICK_AXE && otmp->otyp != UNICORN_HORN))
X  #ifdef POLYSELF
X  		|| (!strcmp(word, "eat") && !is_edible(otmp))
X  #endif
X! 		|| (!strcmp(word, "sacrifice") &&
X! 		    (otmp->otyp != CORPSE &&
X! 		     otmp->otyp != AMULET_OF_YENDOR &&
X! 		     otmp->otyp != FAKE_AMULET_OF_YENDOR))
X  		|| (!strcmp(word, "write with") &&
X  		    (otmp->oclass == TOOL_CLASS &&
X  		     otmp->otyp != MAGIC_MARKER && otmp->otyp != TOWEL))
X+ 		|| (!strcmp(word, "tin") &&
X+ 		    (otmp->otyp != CORPSE))
X  		|| (!strcmp(word, "rub") &&
X  		    (otmp->oclass == TOOL_CLASS &&
X  		     otmp->otyp != OIL_LAMP && otmp->otyp != MAGIC_LAMP &&
X  		     otmp->otyp != BRASS_LANTERN))
X  		    )
X  			foo--;
X  	    } else {
X***************
X*** 782,787 ****
X--- 884,897 ----
X      return(!!(otmp->owornmask & (W_ARMOR | W_RING | W_AMUL | W_TOOL | W_WEP)));
X  }
X  
X+ static boolean
X+ is_fully_identified(otmp)
X+ register struct obj *otmp;
X+ {
X+     return(otmp->known && otmp->dknown && otmp->bknown && otmp->rknown
X+ 	   && objects[otmp->otyp].oc_name_known);
X+ }
X+ 
X  static NEARDATA const char removeables[] =
X  	{ ARMOR_CLASS, WEAPON_CLASS, RING_CLASS, AMULET_CLASS, TOOL_CLASS, 0 };
X  
X***************
X*** 801,806 ****
X--- 911,917 ----
X  	int FDECL((*ckfn),(OBJ_P)) = (int (*)()) 0;
X  	xchar allowgold = (u.ugold && !strcmp(word, "drop")) ? 1 : 0; /* BAH */
X  	register boolean takeoff = !strcmp(word, "take off");
X+ 	register boolean ident = !strcmp(word, "identify");
X  	struct obj *obj;
X  	int unpaid, oc_of_sym;
X  
X***************
X*** 819,825 ****
X  	unpaid = 0;
X  	for (obj = invent; obj; obj = obj->nobj) {
X  		sym = (char) def_oc_syms[(int) obj->oclass];
X! 		if (!index(ilets, sym) && (!takeoff || is_worn(obj))) {
X  			ilets[iletct++] = sym;
X  			/* necessary because of index() being used above */
X  			ilets[iletct] = '\0';
X--- 930,937 ----
X  	unpaid = 0;
X  	for (obj = invent; obj; obj = obj->nobj) {
X  		sym = (char) def_oc_syms[(int) obj->oclass];
X! 		if (!index(ilets, sym) && (!takeoff || is_worn(obj))
X! 		    && (!ident || !is_fully_identified(obj))) {
X  			ilets[iletct++] = sym;
X  			/* necessary because of index() being used above */
X  			ilets[iletct] = '\0';
X***************
X*** 828,834 ****
X  		if (obj->unpaid) unpaid = 1;
X  	}
X  
X! 	if (!takeoff && (unpaid || invent)) {
X  	    ilets[iletct++] = ' ';
X  	    if (unpaid) ilets[iletct++] = 'u';
X  	    if (invent) ilets[iletct++] = 'a';
X--- 940,949 ----
X  		if (obj->unpaid) unpaid = 1;
X  	}
X  
X! 	if (ident && !iletct) {
X! 	    You("have already identified all your possessions.");
X! 	    return -1;		/* special case for seffects(read.c) */
X! 	} else if (!takeoff && (unpaid || invent)) {
X  	    ilets[iletct++] = ' ';
X  	    if (unpaid) ilets[iletct++] = 'u';
X  	    if (invent) ilets[iletct++] = 'a';
X***************
X*** 938,946 ****
X  		if(ilet == 'z') ilet = 'A'; else ilet++;
X  		otmp2 = otmp->nobj;
X  		if (olets && *olets && otmp->oclass != *olets) continue;
X! 		if(takeoff && !is_worn(otmp)) continue;
X! 		if(ckfn && !(*ckfn)(otmp)) continue;
X! 		if(!allflag) {
X  			Strcpy(qbuf, ininv ?
X  				xprname(otmp, ilet, !nodot, 0L) : doname(otmp));
X  			Strcat(qbuf, "?");
X--- 1053,1062 ----
X  		if(ilet == 'z') ilet = 'A'; else ilet++;
X  		otmp2 = otmp->nobj;
X  		if (olets && *olets && otmp->oclass != *olets) continue;
X! 		if (takeoff && !is_worn(otmp)) continue;
X! 		if (ident && is_fully_identified(otmp)) continue;
X! 		if (ckfn && !(*ckfn)(otmp)) continue;
X! 		if (!allflag) {
X  			Strcpy(qbuf, ininv ?
X  				xprname(otmp, ilet, !nodot, 0L) : doname(otmp));
X  			Strcat(qbuf, "?");
X***************
X*** 981,986 ****
X--- 1097,1104 ----
X  		default:
X  			break;
X  		case 'q':
X+ 			/* special case for seffects() */
X+ 			if (ident) cnt = -1;
X  			goto ret;
X  		}
X  	}
X***************
X*** 1111,1117 ****
X  	    } else
X  		return (*last_found = list);
X  	}
X! 	if (Is_container(list) && list->cobj) {
X  	    if ((obj = find_unpaid(list->cobj, last_found)) != 0)
X  		return obj;
X  	}
X--- 1229,1235 ----
X  	    } else
X  		return (*last_found = list);
X  	}
X! 	if (Has_contents(list)) {
X  	    if ((obj = find_unpaid(list->cobj, last_found)) != 0)
X  		return obj;
X  	}
X***************
X*** 1136,1142 ****
X  	register struct obj *otmp;
X  	struct obj *z_obj;
X  	register char ilet;
X! 	char *invlet = inv_order;
X  	int classcount;
X  #if defined(LINT) || defined(GCC_WARN)
X  	int save_unpaid = 0;
X--- 1254,1260 ----
X  	register struct obj *otmp;
X  	struct obj *z_obj;
X  	register char ilet;
X! 	char *invlet = flags.inv_order;
X  	int classcount;
X  #if defined(LINT) || defined(GCC_WARN)
X  	int save_unpaid = 0;
X***************
X*** 1161,1167 ****
X  		if (do_containers) {	/* single non-inventory object */
X  		    z_obj = (struct obj *) 0;
X  		    if ((otmp = find_unpaid(invent, &z_obj)) != 0)
X! 			pline(xprname(otmp, CONTAINED_SYM, TRUE,
X  				     (show_cost ? unpaid_cost(otmp) : 0L)));
X  		    else
X  			impossible(
X--- 1279,1286 ----
X  		if (do_containers) {	/* single non-inventory object */
X  		    z_obj = (struct obj *) 0;
X  		    if ((otmp = find_unpaid(invent, &z_obj)) != 0)
X! 			pline("%s",
X! 			      xprname(otmp, CONTAINED_SYM, TRUE,
X  				     (show_cost ? unpaid_cost(otmp) : 0L)));
X  		    else
X  			impossible(
X***************
X*** 1169,1175 ****
X  		} else {
X  		    for(otmp = invent; otmp; otmp = otmp->nobj) {
X  			if (otmp->invlet == lets[0]) {
X! 			    pline(xprname(otmp, lets[0], TRUE,
X  					 (show_cost ? unpaid_cost(otmp) : 0L)));
X  			    break;
X  			}
X--- 1288,1295 ----
X  		} else {
X  		    for(otmp = invent; otmp; otmp = otmp->nobj) {
X  			if (otmp->invlet == lets[0]) {
X! 			    pline("%s",
X! 				  xprname(otmp, lets[0], TRUE,
X  					 (show_cost ? unpaid_cost(otmp) : 0L)));
X  			    break;
X  			}
X***************
X*** 1227,1233 ****
X  	     *  have unpaid items that have been already listed.
X  	     */
X  	    for (otmp = invent; otmp; otmp = otmp->nobj) {
X! 		if (Is_container(otmp) && otmp->cobj) {
X  		    z_obj = (struct obj *) 0;	/* haven't found any */
X  		    while (find_unpaid(otmp->cobj, (struct obj **)&z_obj)) {
X  			totcost += cost = unpaid_cost(z_obj);
X--- 1347,1353 ----
X  	     *  have unpaid items that have been already listed.
X  	     */
X  	    for (otmp = invent; otmp; otmp = otmp->nobj) {
X! 		if (Has_contents(otmp)) {
X  		    z_obj = (struct obj *) 0;	/* haven't found any */
X  		    while (find_unpaid(otmp->cobj, (struct obj **)&z_obj)) {
X  			totcost += cost = unpaid_cost(z_obj);
X***************
X*** 1263,1269 ****
X  
X      while (list) {
X  	if (list->unpaid) count++;
X! 	if (Is_container(list) && list->cobj)
X  	    count += count_unpaid(list->cobj);
X  	list = list->nobj;
X      }
X--- 1383,1389 ----
X  
X      while (list) {
X  	if (list->unpaid) count++;
X! 	if (Has_contents(list))
X  	    count += count_unpaid(list->cobj);
X  	list = list->nobj;
X      }
X***************
X*** 1361,1367 ****
X  	const char *verb = Blind ? "feel" : "see";
X  	const char *dfeature = (char*) 0;
X  	char fbuf[BUFSZ], fbuf2[BUFSZ];
X- 	int ct;
X  	boolean no_article = FALSE;
X  	winid tmpwin;
X  
X--- 1481,1486 ----
X***************
X*** 1449,1463 ****
X  	}
X  	/* we know there is something here */
X  
X! 	/* find out if there is more than one object there */
X! 	for (ct = 0, otmp = otmp0; otmp; otmp = otmp->nexthere)
X! 	    if (++ct > 1) break;
X! 
X! 	if (ct == 1) {
X  	    if (dfeature) pline(fbuf);
X  	    You("%s here %s.", verb, doname(otmp0));
X  	} else {
X! 	    display_nhwindow(NHW_MESSAGE, FALSE);
X  	    tmpwin = create_nhwindow(NHW_MENU);
X  	    if(dfeature) {
X  		putstr(tmpwin, 0, fbuf);
X--- 1568,1579 ----
X  	}
X  	/* we know there is something here */
X  
X! 	if (!otmp0->nexthere) {
X! 	    /* only one object */
X  	    if (dfeature) pline(fbuf);
X  	    You("%s here %s.", verb, doname(otmp0));
X  	} else {
X! 	    display_nhwindow(WIN_MESSAGE, FALSE);
X  	    tmpwin = create_nhwindow(NHW_MENU);
X  	    if(dfeature) {
X  		putstr(tmpwin, 0, fbuf);
X***************
X*** 1542,1547 ****
X--- 1658,1667 ----
X  	/* see burn_lamps() for a reference for the magic "25" */
X  	if (Is_candle(obj) && obj->age/25 != otmp->age/25)
X  	    return(FALSE);
X+ 
X+ 	/* don't merge surcharged item with base-cost item */
X+ 	if (obj->unpaid && !same_price(obj, otmp))
X+ 	    return FALSE;
X  
X  /* if they have names, make sure they're the same */
X  	if ( (obj->onamelth != otmp->onamelth &&
X*** /tmp/da11042	Tue Jun  1 16:13:58 1993
X--- src/lock.c	Tue Jun  1 12:07:19 1993
X***************
X*** 1,8 ****
X! /*	SCCS Id: @(#)lock.c	3.1	92/09/02
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X! #include	"hack.h"
X  
X  #define CONTAINER_BITS 0	/* box options not [yet?] implemented */
X  
X--- 1,8 ----
X! /*	SCCS Id: @(#)lock.c	3.1	93/05/28	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X! #include "hack.h"
X  
X  #define CONTAINER_BITS 0	/* box options not [yet?] implemented */
X  
X***************
X*** 18,23 ****
X--- 18,24 ----
X  
X  #ifdef OVLB
X  
X+ static const char *NDECL(lock_action);
X  static boolean FDECL(obstructed,(int,int));
X  static void FDECL(chest_shatter_msg, (struct obj *));
X  
X***************
X*** 41,46 ****
X--- 42,77 ----
X  	       xlock.door_or_box && (xlock.door == &levl[x][y])); 
X  }
X  
X+ /* produce an occupation string appropriate for the current activity */
X+ static const char *
X+ lock_action()
X+ {
X+ 	/* "unlocking"+2 == "locking" */
X+ 	static const char *actions[] = {
X+ 		/* [0] */	"unlocking the door",
X+ 		/* [1] */	"unlocking the chest",
X+ 		/* [2] */	"unlocking the box",
X+ 		/* [3] */	"picking the lock"
X+ 	};
X+ 
X+ 	/* if the target is currently unlocked, we're trying to lock it now */
X+ 	if (xlock.door_or_box && !(xlock.door->doormask & D_LOCKED))
X+ 		return actions[0]+2;	/* "locking the door" */
X+ 	else if (!xlock.door_or_box && !xlock.box->olocked)
X+ 		return xlock.box->otyp == CHEST ? actions[1]+2 : actions[2]+2;
X+ 	/* otherwise we're trying to unlock it */
X+ 	else if (xlock.picktyp == LOCK_PICK)
X+ 		return actions[3];	/* "picking the lock" */
X+ #ifdef TOURIST
X+ 	else if (xlock.picktyp == CREDIT_CARD)
X+ 		return actions[3];	/* same as lock_pick */
X+ #endif
X+ 	else if (xlock.door_or_box)
X+ 		return actions[0];	/* "unlocking the door" */
X+ 	else
X+ 		return xlock.box->otyp == CHEST ? actions[1] : actions[2];
X+ }
X+ 
X  STATIC_PTR
X  int
X  picklock()	/* try to open/close a lock */
X***************
X*** 73,83 ****
X  	   || nohands(uasmon)
X  #endif
X  	   ) {
X! 	    You("give up your attempt to %s the lock.",
X! 		  (xlock.door_or_box ? !(xlock.door->doormask & D_LOCKED) :
X! 		   !xlock.box->olocked) ? "lock" :
X! 		  ((xlock.picktyp == LOCK_PICK) ? "pick" : "open" ));
X! 
X  	    exercise(A_DEX, TRUE);	/* even if you don't succeed */
X  	    return((xlock.usedtime = 0));
X  	}
X--- 104,110 ----
X  	   || nohands(uasmon)
X  #endif
X  	   ) {
X! 	    You("give up your attempt at %s.", lock_action());
X  	    exercise(A_DEX, TRUE);	/* even if you don't succeed */
X  	    return((xlock.usedtime = 0));
X  	}
X***************
X*** 84,95 ****
X  
X  	if(rn2(100) > xlock.chance) return(1);		/* still busy */
X  
X  	if(xlock.door_or_box) {
X- 	    You("succeed in %sing the lock.",
X- 		  !(xlock.door->doormask & D_LOCKED) ? "lock" :
X- 		  ((xlock.picktyp == LOCK_PICK) ? "pick" : "open" ));
X  	    if(xlock.door->doormask & D_TRAPPED) {
X! 		    b_trapped("door");
X  		    xlock.door->doormask = D_NODOOR;
X  		    unblock_point(u.ux+u.dx, u.uy+u.dy);
X  		    newsym(u.ux+u.dx, u.uy+u.dy);
X--- 111,120 ----
X  
X  	if(rn2(100) > xlock.chance) return(1);		/* still busy */
X  
X+ 	You("succeed in %s.", lock_action());
X  	if(xlock.door_or_box) {
X  	    if(xlock.door->doormask & D_TRAPPED) {
X! 		    b_trapped("door", FINGER);
X  		    xlock.door->doormask = D_NODOOR;
X  		    unblock_point(u.ux+u.dx, u.uy+u.dy);
X  		    newsym(u.ux+u.dx, u.uy+u.dy);
X***************
X*** 97,105 ****
X  		xlock.door->doormask = D_CLOSED;
X  	    else xlock.door->doormask = D_LOCKED;
X  	} else {
X- 	    You("succeed in %sing the lock.",
X- 		  (!xlock.box->olocked) ? "lock" :
X- 		  (xlock.picktyp == LOCK_PICK) ? "pick" : "open" );
X  	    xlock.box->olocked = !xlock.box->olocked;
X  	    if(xlock.box->otrapped)	
X  		(void) chest_trap(xlock.box, FINGER, FALSE);
X--- 122,127 ----
X***************
X*** 152,166 ****
X  	xlock.box->olocked = 0;
X  	xlock.box->obroken = 1;
X  	if(!xlock.picktyp && !rn2(3)) {
X! 	    register struct monst *shkp;
X  	    long loss = 0L;
X  
X! #ifdef GCC_WARN
X! 	    shkp = (struct monst *) 0;
X! #endif
X  
X- 	    if(*u.ushops) shkp = shop_keeper(*u.ushops);
X- 
X  	    pline("In fact, you've totally destroyed %s.",
X  		  the(xname(xlock.box)));
X  
X--- 174,186 ----
X  	xlock.box->olocked = 0;
X  	xlock.box->obroken = 1;
X  	if(!xlock.picktyp && !rn2(3)) {
X! 	    struct monst *shkp;
X! 	    boolean costly;
X  	    long loss = 0L;
X  
X! 	    costly = (*u.ushops && costly_spot(u.ux, u.uy));
X! 	    shkp = costly ? shop_keeper(*u.ushops) : 0;
X  
X  	    pline("In fact, you've totally destroyed %s.",
X  		  the(xname(xlock.box)));
X  
X***************
X*** 169,175 ****
X  		otmp2 = otmp->nobj;
X  		if(!rn2(3) || otmp->oclass == POTION_CLASS) {
X  		    chest_shatter_msg(otmp);
X! 		    if(*u.ushops && costly_spot(u.ux, u.uy))
X  		        loss += stolen_value(otmp, u.ux, u.uy,
X  					     (boolean)shkp->mpeaceful, TRUE);
X  		    if (otmp->quan == 1L) {
X--- 189,195 ----
X  		otmp2 = otmp->nobj;
X  		if(!rn2(3) || otmp->oclass == POTION_CLASS) {
X  		    chest_shatter_msg(otmp);
X! 		    if (costly)
X  		        loss += stolen_value(otmp, u.ux, u.uy,
X  					     (boolean)shkp->mpeaceful, TRUE);
X  		    if (otmp->quan == 1L) {
X***************
X*** 184,191 ****
X  		stackobj(otmp);
X  	    }
X  	    xlock.box->cobj = (struct obj *) 0;	/* no contents */
X! 	    if(*u.ushops && costly_spot(u.ux, u.uy))
X! 		loss += stolen_value(otmp, u.ux, u.uy,
X  					     (boolean)shkp->mpeaceful, TRUE);
X  	    if(loss) You("owe %ld zorkmids for objects destroyed.", loss);
X  	    delobj(xlock.box);
X--- 204,211 ----
X  		stackobj(otmp);
X  	    }
X  	    xlock.box->cobj = (struct obj *) 0;	/* no contents */
X! 	    if (costly)
X! 		loss += stolen_value(xlock.box, u.ux, u.uy,
X  					     (boolean)shkp->mpeaceful, TRUE);
X  	    if(loss) You("owe %ld zorkmids for objects destroyed.", loss);
X  	    delobj(xlock.box);
X***************
X*** 216,232 ****
X  	ch = 0;		/* GCC myopia */
X  #endif
X  	picktyp = pick->otyp;
X! 	if(xlock.usedtime && picktyp == xlock.picktyp) {
X  
X! 	    You("resume your attempt to %s the lock.",
X! 		  (xlock.door_or_box ? !(xlock.door->doormask & D_LOCKED) :
X! 		   !xlock.box->olocked) ? "lock" :
X! 		  ((xlock.picktyp == LOCK_PICK) ? "pick" : "open" ));
X! 
X! 	    set_occupation(picklock,
X! 			   (picktyp == LOCK_PICK) ? "picking the lock" :
X! 						    "opening the lock",  0);
X! 	    return(1);
X  	}
X  
X  #ifdef POLYSELF
X--- 236,247 ----
X  	ch = 0;		/* GCC myopia */
X  #endif
X  	picktyp = pick->otyp;
X! 	if (xlock.usedtime && picktyp == xlock.picktyp) {
X! 		const char *action = lock_action();
X  
X! 		You("resume your attempt at %s.", action);
X! 		set_occupation(picklock, action, 0);
X! 		return(1);
X  	}
X  
X  #ifdef POLYSELF
X***************
X*** 381,389 ****
X  	xlock.chance = ch;
X  	xlock.picktyp = picktyp;
X  	xlock.usedtime = 0;
X! 	set_occupation(picklock,
X! 		       (picktyp == LOCK_PICK) ? "picking the lock" :
X! 						"opening the lock",  0);
X  	return(1);
X  }
X  
X--- 396,402 ----
X  	xlock.chance = ch;
X  	xlock.picktyp = picktyp;
X  	xlock.usedtime = 0;
X! 	set_occupation(picklock, lock_action(), 0);
X  	return(1);
X  }
X  
X***************
X*** 522,528 ****
X  	if (rnl(20) < (ACURRSTR+ACURR(A_DEX)+ACURR(A_CON))/3) {
X  	    pline("The door opens.");
X  	    if(door->doormask & D_TRAPPED) {
X! 		b_trapped("door");
X  		door->doormask = D_NODOOR;
X  	    } else
X  		door->doormask = D_ISOPEN;
X--- 535,541 ----
X  	if (rnl(20) < (ACURRSTR+ACURR(A_DEX)+ACURR(A_CON))/3) {
X  	    pline("The door opens.");
X  	    if(door->doormask & D_TRAPPED) {
X! 		b_trapped("door", FINGER);
X  		door->doormask = D_NODOOR;
X  	    } else
X  		door->doormask = D_ISOPEN;
X***************
X*** 706,711 ****
X--- 719,733 ----
X  	case WAN_LOCKING:
X  	case SPE_WIZARD_LOCK:
X  	    if (obstructed(x,y)) return 0;
X+ 	    /* Don't allow doors to close over traps.  This is for pits */
X+ 	    /* & trap doors, but is it ever OK for anything else? */
X+ 	    if (t_at(x,y)) {
X+ 		/* maketrap() clears doormask, so it should be NODOOR */
X+ 		pline(
X+ 	"A cloud of dust springs up in the doorway, but quickly dissipates.");
X+ 		return 0;
X+ 	    }
X+ 
X  	    switch (door->doormask & ~D_TRAPPED) {
X  	    case D_CLOSED:
X  		msg = "The door locks!";
X*** /tmp/da11050	Tue Jun  1 16:14:01 1993
X--- src/mail.c	Mon May 17 14:04:38 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)mail.c	3.1	92/11/14	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)mail.c	3.1	93/05/15	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 48,54 ****
X  #  include <sys/stat.h>
X  #  include <pwd.h>
X  /* DON'T trust all Unices to declare getpwuid() in <pwd.h> */
X! #  if !defined(_BULL_SOURCE) && !defined(sgi)
X  /* DO trust all SVR4 to typedef uid_t in <sys/types.h> (probably to a long) */
X  #   if defined(POSIX_TYPES) || defined(SVR4) || defined(HPUX)
X  extern struct passwd *FDECL(getpwuid,(uid_t));
X--- 48,54 ----
X  #  include <sys/stat.h>
X  #  include <pwd.h>
X  /* DON'T trust all Unices to declare getpwuid() in <pwd.h> */
X! #  if !defined(_BULL_SOURCE) && !defined(sgi) && !defined(_M_UNIX)
X  /* DO trust all SVR4 to typedef uid_t in <sys/types.h> (probably to a long) */
X  #   if defined(POSIX_TYPES) || defined(SVR4) || defined(HPUX)
X  extern struct passwd *FDECL(getpwuid,(uid_t));
X***************
X*** 368,377 ****
X  
X      message_seen = TRUE;
X  # ifdef NO_MAILREADER
X!     verbalize("Hello, %s!  You have some mail in the outside world.", plname);
X! # else
X      verbalize("Hello, %s!  %s.", plname, info->display_txt);
X  
X      if (info->message_typ) {
X  	struct obj *obj = mksobj(SCR_MAIL, FALSE, FALSE);
X  	if (distu(md->mx,md->my) > 2)
X--- 368,382 ----
X  
X      message_seen = TRUE;
X  # ifdef NO_MAILREADER
X!     if (info->message_typ) {
X! 	verbalize("Hello, %s!  You have some mail in the outside world.", plname);
X! 	goto go_back;
X!     }    
X! # endif /* NO_MAILREADER */
X! 
X      verbalize("Hello, %s!  %s.", plname, info->display_txt);
X  
X+ # ifndef NO_MAILREADER
X      if (info->message_typ) {
X  	struct obj *obj = mksobj(SCR_MAIL, FALSE, FALSE);
X  	if (distu(md->mx,md->my) > 2)
X***************
X*** 435,453 ****
X  readmail(otmp)
X  struct obj *otmp;
X  {
X- #ifdef AMIGA
X  	char *junk[]={
X! 	"It reads:  \"Please disregard previous letter.\"",
X! 	"It reads:  \"Welcome to NetHack 3.1!\"",
X! 	"It reads:  \"Only Amiga makes it possible.\"",
X! 	"It reads:  \"CATS have all the answers.\"",
X! 	"It reads:  \"Report bugs to nethack-bugs@linc.cis.upenn.edu\""
X  	};
X  
X! 	pline(junk[rn2(SIZE(junk))]);
X! #else
X! 	pline("It reads:  \"Please disregard previous letter.\"");
X! #endif
X  }
X  
X  #endif /* OVLB */
X--- 440,456 ----
X  readmail(otmp)
X  struct obj *otmp;
X  {
X  	char *junk[]={
X! 	"Please disregard previous letter.",
X! 	"Welcome to NetHack 3.1!",
X! #ifdef AMIGA
X! 	"Only Amiga makes it possible.",
X! 	"CATS have all the answers.",
X! #endif
X! 	"Report bugs to nethack-bugs@linc.cis.upenn.edu"
X  	};
X  
X! 	pline("It reads:  \"%s\"", junk[rn2(SIZE(junk))]);
X  }
X  
X  #endif /* OVLB */
X***************
X*** 552,562 ****
X  struct obj *otmp;
X  {
X  #  ifdef SHELL	/* can't access mail reader without spawning subprocess */
X!     char *p, *cmd, buf[BUFSZ], qbuf[BUFSZ];
X  
X      /* there should be a command hidden beyond the object name */
X!     p = otmp->onamelth ? ONAME(otmp) : "";
X!     cmd = (strlen(p) + 1 < otmp->onamelth) ? eos(p) + 1 : (char *) 0;
X      if (!cmd || !*cmd) cmd = "SPAWN";
X  
X      Sprintf(qbuf, "System command (%s)", cmd);
X--- 555,568 ----
X  struct obj *otmp;
X  {
X  #  ifdef SHELL	/* can't access mail reader without spawning subprocess */
X!     const char *txt, *cmd;
X!     char *p, buf[BUFSZ], qbuf[BUFSZ];
X!     int len;
X  
X      /* there should be a command hidden beyond the object name */
X!     txt = otmp->onamelth ? ONAME(otmp) : "";
X!     len = strlen(txt);
X!     cmd = (len + 1 < otmp->onamelth) ? txt + len + 1 : (char *) 0;
X      if (!cmd || !*cmd) cmd = "SPAWN";
X  
X      Sprintf(qbuf, "System command (%s)", cmd);
X*** /tmp/da11058	Tue Jun  1 16:14:03 1993
X--- src/makemon.c	Mon May 24 16:40:28 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)makemon.c	3.1	93/02/20	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)makemon.c	3.1	93/05/10	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 333,338 ****
X--- 333,343 ----
X  		(void)mongets(mtmp, KNIFE);
X  		(void)mongets(mtmp, LONG_SWORD);
X  		break;
X+ 	    case S_ZOMBIE:
X+ 		if (!rn2(4)) (void)mongets(mtmp, LEATHER_ARMOR);
X+ 		if (!rn2(4))
X+ 			(void)mongets(mtmp, (rn2(3) ? KNIFE : SHORT_SWORD));
X+ 		break;
X  	    case S_DEMON:
X  		switch (mm) {
X  		    case PM_BALROG:
X***************
X*** 364,380 ****
X  		if (!is_demon(ptr)) break;
X  		/* fall thru */
X  /*
X!  *	Now the general case, ~40% chance of getting some type
X!  *	of weapon. TODO: Add more weapons types (use bigmonst());
X   */
X  	    default:
X! 		switch(rnd(12)) {
X  		    case 1:
X! 			m_initthrow(mtmp, DART, 12);
X  			break;
X  		    case 2:
X! 			(void) mongets(mtmp, CROSSBOW);
X! 			m_initthrow(mtmp, CROSSBOW_BOLT, 12);
X  			break;
X  		    case 3:
X  			(void) mongets(mtmp, BOW);
X--- 369,395 ----
X  		if (!is_demon(ptr)) break;
X  		/* fall thru */
X  /*
X!  *	Now the general case, Some chance of getting some type
X!  *	of weapon for "normal" monsters.  Certain special types
X!  *	of monsters will get a bonus chance or different selections.
X   */
X  	    default:
X! 	      {
X! 		int bias;
X! 		
X! 		bias = is_lord(ptr) + is_prince(ptr) * 2 + extra_nasty(ptr);
X! 		switch(rnd(14 - (2 * bias))) {
X  		    case 1:
X! 			if(strongmonst(ptr)) (void) mongets(mtmp, BATTLE_AXE);
X! 			else m_initthrow(mtmp, DART, 12);
X  			break;
X  		    case 2:
X! 			if(strongmonst(ptr))
X! 			    (void) mongets(mtmp, TWO_HANDED_SWORD);
X! 			else {
X! 			    (void) mongets(mtmp, CROSSBOW);
X! 			    m_initthrow(mtmp, CROSSBOW_BOLT, 12);
X! 			}
X  			break;
X  		    case 3:
X  			(void) mongets(mtmp, BOW);
X***************
X*** 381,398 ****
X  			m_initthrow(mtmp, ARROW, 12);
X  			break;
X  		    case 4:
X! 			m_initthrow(mtmp, DAGGER, 3);
X  			break;
X  		    case 5:
X! 			(void) mongets(mtmp, AKLYS);
X  			break;
X  		    default:
X  			break;
X  		}
X! 		break;
X  	}
X  #ifdef MUSE
X! 	if ((int) mtmp->m_lev > rn2(70))
X  		(void) mongets(mtmp, rnd_offensive_item(mtmp));
X  #endif
X  }
X--- 396,417 ----
X  			m_initthrow(mtmp, ARROW, 12);
X  			break;
X  		    case 4:
X! 			if(strongmonst(ptr)) (void) mongets(mtmp, LONG_SWORD);
X! 			else m_initthrow(mtmp, DAGGER, 3);
X  			break;
X  		    case 5:
X! 			if(strongmonst(ptr))
X! 			    (void) mongets(mtmp, LUCERN_HAMMER);
X! 			else (void) mongets(mtmp, AKLYS);
X  			break;
X  		    default:
X  			break;
X  		}
X! 	      }
X! 	      break;
X  	}
X  #ifdef MUSE
X! 	if ((int) mtmp->m_lev > rn2(75))
X  		(void) mongets(mtmp, rnd_offensive_item(mtmp));
X  #endif
X  }
X***************
X*** 546,552 ****
X  	if (ptr == &mons[PM_SOLDIER] && rn2(13)) return;
X  #endif
X  #ifdef MUSE
X! 	if ((int) mtmp->m_lev > rn2(30))
X  		(void) mongets(mtmp, rnd_defensive_item(mtmp));
X  	if ((int) mtmp->m_lev > rn2(100))
X  		(void) mongets(mtmp, rnd_misc_item(mtmp));
X--- 565,571 ----
X  	if (ptr == &mons[PM_SOLDIER] && rn2(13)) return;
X  #endif
X  #ifdef MUSE
X! 	if ((int) mtmp->m_lev > rn2(50))
X  		(void) mongets(mtmp, rnd_defensive_item(mtmp));
X  	if ((int) mtmp->m_lev > rn2(100))
X  		(void) mongets(mtmp, rnd_misc_item(mtmp));
X***************
X*** 851,857 ****
X  	if (mdat) {
X  	    if (IS_POOL(levl[x][y].typ))
X  		if (mdat == &playermon &&
X! 		    (HLevitation || Wwalking || Magical_breathing))
X  			return 1;
X  		else	return (is_flyer(mdat) || is_swimmer(mdat));
X  	    if (levl[x][y].typ == LAVAPOOL)
X--- 870,876 ----
X  	if (mdat) {
X  	    if (IS_POOL(levl[x][y].typ))
X  		if (mdat == &playermon &&
X! 		    (HLevitation || Wwalking || Amphibious))
X  			return 1;
X  		else	return (is_flyer(mdat) || is_swimmer(mdat));
X  	    if (levl[x][y].typ == LAVAPOOL)
X***************
X*** 1210,1222 ****
X  	register int newtype;
X  	register struct permonst *ptr = mtmp->data;
X  
X- 	if (ptr->mlevel >= 50 || is_golem(ptr) || is_home_elemental(ptr)
X- 		|| is_mplayer(ptr))
X- 	    /* doesn't grow up, has strange hp calculation so might be
X- 	     * weakened by tests below */
X- 	    return ptr;
X- 
X  	if (victim) {
X  	    mtmp->mhpmax = mtmp->mhpmax + (1 + rn2((int)victim->m_lev+1));
X  	    if (mtmp->mhpmax <= (8 * (int)mtmp->m_lev)
X  			|| (mtmp->m_lev == 0 && mtmp->mhpmax <= 4))
X--- 1229,1241 ----
X  	register int newtype;
X  	register struct permonst *ptr = mtmp->data;
X  
X  	if (victim) {
X+ 	    if (ptr->mlevel >= 50 || is_golem(ptr) || is_home_elemental(ptr)
X+ 		    || is_mplayer(ptr))
X+ 		/* doesn't grow up, has strange hp calculation so might be
X+ 		 * weakened by tests below */
X+ 		return ptr;
X+ 
X  	    mtmp->mhpmax = mtmp->mhpmax + (1 + rn2((int)victim->m_lev+1));
X  	    if (mtmp->mhpmax <= (8 * (int)mtmp->m_lev)
X  			|| (mtmp->m_lev == 0 && mtmp->mhpmax <= 4))
X***************
X*** 1245,1250 ****
X--- 1264,1270 ----
X  			return (struct permonst *)0;
X  		}
X  		mtmp->data = &mons[newtype];
X+ 		newsym(mtmp->mx, mtmp->my);	/* color may change */
X  		mtmp->m_lev = mons[newtype].mlevel;
X  	}
X  	if (newtype == monsndx(ptr) && victim &&
X*** /tmp/da11066	Tue Jun  1 16:14:06 1993
X--- src/mcastu.c	Thu May  6 11:25:36 1993
X***************
X*** 1,25 ****
X! /*	SCCS Id: @(#)mcastu.c	3.1	90/09/21
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X! #include	"hack.h"
X  
X  #ifdef OVL0
X- 
X  static void FDECL(cursetxt,(struct monst *));
X- const char *spelltyp[] = {
X- 	"shower of missiles",
X- 	"fireball",
X- 	"sleep ray",
X- 	"cone of cold",
X- 	"finger of death",
X- 	"bolt of lightning",
X- 	"",
X- 	"",
X- 	"",
X- 	""
X- };
X  
X  static
X  void
X  cursetxt(mtmp)
X--- 1,14 ----
X! /*	SCCS Id: @(#)mcastu.c	3.1	93/05/04	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X! #include "hack.h"
X  
X  #ifdef OVL0
X  static void FDECL(cursetxt,(struct monst *));
X  
X+ extern const char *flash_types[];	/* from zap.c */
X+ 
X  static
X  void
X  cursetxt(mtmp)
X***************
X*** 337,342 ****
X--- 326,334 ----
X  #endif /* OVLB */
X  #ifdef OVL0
X  
X+ /* convert 1..10 to 0..9; add 10 for second group (spell casting) */
X+ #define ad_to_typ(k) (10 + (int)k - 1)
X+ 
X  int
X  buzzmu(mtmp, mattk)		/* monster uses spell (ranged) */
X  	register struct monst *mtmp;
X***************
X*** 351,358 ****
X  	    if(mattk->adtyp && (mattk->adtyp < 11)) { /* no cf unsigned >0 */
X  		if(canseemon(mtmp))
X  		    pline("%s zaps you with a %s!", Monnam(mtmp),
X! 			  spelltyp[mattk->adtyp-1]);
X! 		buzz((int) (-10 - (mattk->adtyp-1)), (int)mattk->damn,
X  		     mtmp->mx, mtmp->my, sgn(tbx), sgn(tby));
X  	    } else impossible("Monster spell %d cast", mattk->adtyp-1);
X  	}
X--- 343,350 ----
X  	    if(mattk->adtyp && (mattk->adtyp < 11)) { /* no cf unsigned >0 */
X  		if(canseemon(mtmp))
X  		    pline("%s zaps you with a %s!", Monnam(mtmp),
X! 			  flash_types[ad_to_typ(mattk->adtyp)]);
X! 		buzz(-ad_to_typ(mattk->adtyp), (int)mattk->damn,
X  		     mtmp->mx, mtmp->my, sgn(tbx), sgn(tby));
X  	    } else impossible("Monster spell %d cast", mattk->adtyp-1);
X  	}
X*** /tmp/da11074	Tue Jun  1 16:14:08 1993
X--- src/mhitm.c	Fri May 28 11:31:59 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)mhitm.c	3.1	93/02/09	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)mhitm.c	3.1	93/05/26	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 360,366 ****
X  
X  	if(vis) {
X  		Sprintf(buf,"%s gazes at", Monnam(magr));
X! 		pline("%s %s.", buf, mon_nam(mdef));
X  	}
X  
X  	if (!mdef->mcansee || mdef->msleep) {
X--- 360,366 ----
X  
X  	if(vis) {
X  		Sprintf(buf,"%s gazes at", Monnam(magr));
X! 		pline("%s %s...", buf, mon_nam(mdef));
X  	}
X  
X  	if (!mdef->mcansee || mdef->msleep) {
X***************
X*** 655,661 ****
X  		break;
X  	    case AD_TLPT:
X  		if(!magr->mcan && tmp < mdef->mhp) {
X! 		    rloc(mdef);
X  		    if(vis && !cansee(mdef->mx, mdef->my))
X  			pline("%s suddenly disappears!", Monnam(mdef));
X  		}
X--- 655,661 ----
X  		break;
X  	    case AD_TLPT:
X  		if(!magr->mcan && tmp < mdef->mhp) {
X! 		    if (!tele_restrict(mdef)) rloc(mdef);
X  		    if(vis && !cansee(mdef->mx, mdef->my))
X  			pline("%s suddenly disappears!", Monnam(mdef));
X  		}
X***************
X*** 856,862 ****
X  		remove_monster(mdef->mx, mdef->my);
X  		place_monster(mdef, mdef->mx, mdef->my);
X  	    }
X! 	    monkilled(mdef, "", mattk->adtyp);
X  	    if (mdef->mhp > 0) return 0; /* mdef lifesaved */
X  	    return (MM_DEF_DIED | (grow_up(magr,mdef) ? 0 : MM_AGR_DIED));
X  	}
X--- 856,862 ----
X  		remove_monster(mdef->mx, mdef->my);
X  		place_monster(mdef, mdef->mx, mdef->my);
X  	    }
X! 	    monkilled(mdef, "", (int)mattk->adtyp);
X  	    if (mdef->mhp > 0) return 0; /* mdef lifesaved */
X  	    return (MM_DEF_DIED | (grow_up(magr,mdef) ? 0 : MM_AGR_DIED));
X  	}
X***************
X*** 972,980 ****
X--- 972,988 ----
X  	/* These affect the enemy only if defender is still alive */
X  	if (rn2(3)) switch(mddat->mattk[i].adtyp) {
X  	    case AD_PLYS: /* Floating eye */
X+ 		if (tmp > 127) tmp = 127;
X  		if (mddat == &mons[PM_FLOATING_EYE]) {
X+ 		    if (!rn2(4)) tmp = 127;
X  		    if (magr->mcansee && haseyes(madat) && mdef->mcansee &&
X  			(perceives(madat) || !mdef->minvis)) {
X+ #ifdef MUSE
X+ 			Sprintf(buf, "%s gaze is reflected by %%s %%s.",
X+ 				s_suffix(mon_nam(mdef)));
X+ 			if (mon_reflects(magr, buf))
X+ 				return(mdead|mhit);
X+ #endif
X  			Strcpy(buf, Monnam(magr));
X  			if(canseemon(magr))
X  			    pline("%s is frozen by %s gaze!",
X***************
X*** 1057,1063 ****
X  
X      assess_dmg:
X  	if((magr->mhp -= tmp) <= 0) {
X! 		monkilled(magr,"",mddat->mattk[i].adtyp);
X  		return (mdead | mhit | MM_AGR_DIED);
X  	}
X  	return (mdead | mhit);
X--- 1065,1071 ----
X  
X      assess_dmg:
X  	if((magr->mhp -= tmp) <= 0) {
X! 		monkilled(magr, "", (int)mddat->mattk[i].adtyp);
X  		return (mdead | mhit | MM_AGR_DIED);
X  	}
X  	return (mdead | mhit);
END_OF_FILE
if test 56886 -ne `wc -c <'patches02d'`; then
    echo shar: \"'patches02d'\" unpacked with wrong size!
fi
# end of 'patches02d'
if test -f 'sys/mac/NHDeflts' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'sys/mac/NHDeflts'\" to \"'sys/mac/NHDeflts.orig'\"
  mv -f 'sys/mac/NHDeflts' 'sys/mac/NHDeflts.orig'
fi
echo shar: Extracting \"'sys/mac/NHDeflts'\" \(1450 characters\)
sed "s/^X//" >'sys/mac/NHDeflts' <<'END_OF_FILE'
X# These are recommended sample options
XOPTIONS=rest,!autopickup,!time,!silent,dogname:Rover,catname:Pixel
X
X# If you always want to play an Elf named Brother, with a cat, do:
X#OPTIONS=name:Brother-E,pettype:cat
X
X# Enable these (remove the # before them) to get a "classic" look & feel
XOPTIONS=window:tty,standout,hilite_pet
X
X# Enable these if you have a 13" color screen or larger in TTY mode
X# If you have a color classic, remove the ",large" option
XOPTIONS=time,color,large
X
X# This is a sample palette that looks "mac-like" (Jons favourite)
X# The order of the colors is Black, Red, Green, Brown, Blue, Magenta, 
X# Cyan, Gray, Text, Orange, Bright Green, Yellow, Bright blue, Bright 
X# Magenta, Bright Cyan, White, (Raw Text, Unused, Unused, Unused, 
X# Highlight)
XOPTIONS=palette:fff/500/050/530/005/505/055/555/222/962/292/980/229/828/099/000/222/474/622/62c/-610
X
X# This is a sample inverse-screen palette, for all of you asking for it...
X#OPTIONS=palette:000/c22/2c2/ca0/22c/a2a/2aa/ccc/999/f00/0f0/dd0/00f/d0d/0dd/fff/999/444/622/62c/-222
X
X# If you only want to change the hilite color (i e for --More--) you can 
X# do this: (white-on-blue --More--)
X#OPTIONS=hicolor:-027
X
X# WARNING: Setting colors only works on color-capable macs. If you have a 
X# non-color Mac, palette changes will not take effect, and you cannot 
X# play in reverse colors!
X# For a "real" old-style hack, use the inverse-screen palette but remove 
X# the ,color option above!
END_OF_FILE
if test 1450 -ne `wc -c <'sys/mac/NHDeflts'`; then
    echo shar: \"'sys/mac/NHDeflts'\" unpacked with wrong size!
fi
# end of 'sys/mac/NHDeflts'
echo shar: End of archive 4 \(of 33\).
cp /dev/null ark4isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 33 archives.
    echo "Now execute ./patchit.sh"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
