Path: uunet!news.tek.com!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v17i088:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Patch2m/33
Date: 11 Jun 1993 00:11:08 GMT
Organization: Tektronix, Inc, Redmond, OR, USA
Lines: 2520
Approved: billr@saab.CNA.TEK.COM
Message-ID: <1v8iis$j1h@ying.cna.tek.com>
NNTP-Posting-Host: saab.cna.tek.com
Xref: uunet comp.sources.games:1776

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 17, Issue 88
Archive-name: nethack31/Patch2m
Patch-To: nethack31: Volume 16, Issue 1-116
Environment: Amiga, Atari, Mac, MS-DOS, Windows-NT, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 13 (of 33)."
# Contents:  patches02l sys/amiga/windefs.h
# Wrapped by billr@saab on Thu Jun 10 16:55:03 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'patches02l' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'patches02l'\" to \"'patches02l.orig'\"
  mv -f 'patches02l' 'patches02l.orig'
fi
echo shar: Extracting \"'patches02l'\" \(54798 characters\)
sed "s/^X//" >'patches02l' <<'END_OF_FILE'
X*** /tmp/da11840	Tue Jun  1 17:00:36 1993
X--- sys/amiga/amiwind.c	Tue Jun  1 12:12:53 1993
X***************
X*** 3,70 ****
X  /*    Copyright (c) Kenneth Lorber, Bethesda, Maryland 1993	  */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X! /*
X!  *  Here is some very Amiga specific stuff, dealing with
X!  *  screens, windows, menus, and input via IntuiMessages.
X!  */
X  
X- #include "hack.h"
X- #include "winami.h"
X- 
X  /* Have to undef CLOSE as display.h and intuition.h both use it */
X  #undef CLOSE
X  
X! #include <exec/types.h>
X! #include <exec/alerts.h>
X! #include <exec/io.h>
X! #include <exec/devices.h>
X! #include <devices/console.h>
X! #include <devices/conunit.h>
X! #include <intuition/intuition.h>
X! #include <intuition/intuitionbase.h>
X! #include <libraries/dosextens.h>
X  
X! #ifdef __SASC
X! # undef COUNT
X! 
X! # include <dos.h>       /* for __emit */
X! # include <string.h>
X! # include <proto/dos.h>
X! # include <proto/exec.h>
X! 
X! /* kludge - see amirip for why */
X! # undef red
X! # undef green
X! # undef blue
X! # undef index
X! # include <proto/graphics.h>
X! 
X! # include <proto/intuition.h>
X! # include <proto/diskfont.h>
X! # include <proto/console.h>
X  #endif
X  
X- #undef  NULL
X- #define NULL    0L
X- 
X  #include "Amiga:amimenu.c"
X  
X- /*  First, external declarations... */
X- 
X- struct Library *ConsoleDevice;
X- 
X- #ifdef AZTEC_50
X- # include <functions.h>
X- #endif
X- 
X- #ifdef  INTUI_NEW_LOOK
X- #define NewWindow ExtNewWindow
X- #endif
X- 
X- #include "Amiga:winami.p"
X- #include "Amiga:amiwind.p"
X- #include "Amiga:amidos.p"
X- 
X  static int BufferGetchar(void);
X  static void ProcessMessage( register struct IntuiMessage *message );
X  
X--- 3,23 ----
X  /*    Copyright (c) Kenneth Lorber, Bethesda, Maryland 1993	  */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X! #include "amiga:windefs.h"
X! #include "amiga:winext.h"
X! #include "amiga:winproto.h"
X  
X  /* Have to undef CLOSE as display.h and intuition.h both use it */
X  #undef CLOSE
X  
X! #ifdef AMII_GRAPHICS	/* too early in the file? too late? */
X  
X! #ifndef	SHAREDLIB
X! struct Library *ConsoleDevice;
X  #endif
X  
X  #include "Amiga:amimenu.c"
X  
X  static int BufferGetchar(void);
X  static void ProcessMessage( register struct IntuiMessage *message );
X  
X***************
X*** 75,85 ****
X--- 28,42 ----
X  /*  Now our own variables */
X  
X  struct IntuitionBase *IntuitionBase;
X+ #ifndef	SHAREDLIB
X  struct Screen *HackScreen;
X+ #endif
X  struct Window *pr_WindowPtr;
X  struct MsgPort *HackPort;
X  struct IOStdReq ConsoleIO;
X+ #ifndef	SHAREDLIB
X  char Initialized = 0;
X+ #endif
X  WEVENT lastevent;
X  
X  #ifdef HACKFONT
X***************
X*** 87,98 ****
X  struct Library *DiskfontBase;
X  #endif
X  
X  extern struct Library *ConsoleDevice;
X  
X- #define CSI     '\x9b'
X- #define NO_CHAR     -1
X- #define RAWHELP     0x5F    /* Rawkey code of the HELP key */
X- 
X  #define KBDBUFFER   10
X  static unsigned char KbdBuffer[KBDBUFFER];
X  unsigned char KbdBuffered;
X--- 44,53 ----
X  struct Library *DiskfontBase;
X  #endif
X  
X+ #ifndef	SHAREDLIB
X  extern struct Library *ConsoleDevice;
X+ #endif
X  
X  #define KBDBUFFER   10
X  static unsigned char KbdBuffer[KBDBUFFER];
X  unsigned char KbdBuffered;
X***************
X*** 122,134 ****
X--- 77,118 ----
X   * See amiwind.c for the amiga specific colormap.
X   */
X  
X+ #ifdef	VIEWWINDOW
X+ int foreg[16] = { 8, 7, 4, 2, 6, 5, 3, 1, 1, 0, 0, 0, 0, 0, 0, 0 };
X+ int backg[16] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 4, 1, 6, 5, 3, 1 };
X+ #else
X  int foreg[16] = { 0, 7, 4, 2, 6, 5, 3, 1, 1, 0, 0, 0, 0, 0, 0, 0 };
X  int backg[16] = { 1, 0, 0, 0, 0, 0, 0, 0, 0, 7, 4, 1, 6, 5, 3, 1 };
X  #endif
X+ #if 0
X+ 	#define BLACK		0
X+ 	#define RED		1
X+ 	#define GREEN		2
X+ 	#define BROWN		3	/* on IBM, low-intensity yellow is brown */
X+ 	#define BLUE		4
X+ 	#define MAGENTA 	5
X+ 	#define CYAN		6
X+ 	#define GRAY		7	/* low-intensity white */
X+ 	#define NO_COLOR	8
X+ 	#define ORANGE_COLORED	9	/* "orange" conflicts with the object */
X+ 	#define BRIGHT_GREEN	10
X+ 	#define YELLOW		11
X+ 	#define BRIGHT_BLUE	12
X+ 	#define BRIGHT_MAGENTA  13
X+ 	#define BRIGHT_CYAN	14
X+ 	#define WHITE		15
X+ 	#define MAXCOLORS	16
X+ #endif
X+ #endif
X  
X  #ifdef HACKFONT
X  
X+ struct TextFont *TextsFont;
X  struct TextFont *HackFont;
X+ #ifdef	VIEWWINDOW
X+ struct TextFont *HackFont4;
X+ struct TextFont *HackFont16;
X+ #endif
X  UBYTE FontName[] = "NetHack:hack.font";
X      /* # chars in "NetHack:": */
X  #define         SIZEOF_DISKNAME 8
X***************
X*** 141,149 ****
X  #else
X      (UBYTE *) "topaz.font",
X  #endif
X!     TOPAZ_EIGHTY, FS_NORMAL, FPF_DISKFONT | FPF_ROMFONT
X  };
X  
X  /*
X   * Open a window that shares the HackPort IDCMP. Use CloseShWindow()
X   * to close.
X--- 125,168 ----
X  #else
X      (UBYTE *) "topaz.font",
X  #endif
X!     8, FS_NORMAL, FPF_DISKFONT | FPF_DESIGNED
X! 	| FPF_ROMFONT
X  };
X  
X+ #ifdef	VIEWWINDOW
X+ struct TextAttr Hack40 = {
X+ #ifdef HACKFONT
X+     &FontName[SIZEOF_DISKNAME],
X+ #else
X+     (UBYTE *) "topaz.font",
X+ #endif
X+     4, FS_NORMAL, FPF_DISKFONT | FPF_DESIGNED
X+ #ifndef	HACKFONT
X+ 	| FPF_ROMFONT
X+ #endif
X+ };
X+ 
X+ struct TextAttr Hack160 = {
X+ #ifdef HACKFONT
X+     &FontName[SIZEOF_DISKNAME],
X+ #else
X+     (UBYTE *) "topaz.font",
X+ #endif
X+     16, FS_NORMAL, FPF_DISKFONT | FPF_DESIGNED
X+ #ifndef	HACKFONT
X+ 	| FPF_ROMFONT
X+ #endif
X+ };
X+ #endif
X+ 
X+ struct TextAttr TextsFont13 = {
X+     (UBYTE *) "courier.font",
X+     13, FS_NORMAL, FPF_DISKFONT | FPF_DESIGNED
X+ #ifndef	HACKFONT
X+ 	| FPF_ROMFONT
X+ #endif
X+ };
X+ 
X  /*
X   * Open a window that shares the HackPort IDCMP. Use CloseShWindow()
X   * to close.
X***************
X*** 177,183 ****
X  void CloseShWindow(win)
X  struct Window *win;
X  {
X!     register struct IntuiMessage *msg, *nxt;
X  
X      if( !HackPort )
X  	panic("HackPort NULL in CloseShWindow" );
X--- 196,202 ----
X  void CloseShWindow(win)
X  struct Window *win;
X  {
X!     register struct IntuiMessage *msg;
X  
X      if( !HackPort )
X  	panic("HackPort NULL in CloseShWindow" );
X***************
X*** 332,353 ****
X      int c;
X      static int skip_mouse=0;    /* need to ignore next mouse event on
X  				 * a window activation */
X      switch(message->Class) {
X      case ACTIVEWINDOW:
X! 	skip_mouse=1;break;
X      case MOUSEBUTTONS:
X  	{
X! 	    if(skip_mouse){
X  		skip_mouse=0;
X  		break;
X  	    }
X! 	    if( message->Code == SELECTDOWN ){
X  		lastevent.type = WEMOUSE;
X! 		lastevent.u.mouse.x = message->MouseX;
X! 		lastevent.u.mouse.y = message->MouseY;
X  		    /* With shift equals RUN */
X! 		lastevent.u.mouse.qual = (message->Qualifier &
X  		  (IEQUALIFIER_LSHIFT|IEQUALIFIER_RSHIFT)) != 0;
X  	    }
X  	}
X  	break;
X--- 351,409 ----
X      int c;
X      static int skip_mouse=0;    /* need to ignore next mouse event on
X  				 * a window activation */
X+     struct Window *w = message->IDCMPWindow;
X+ 
X      switch(message->Class) {
X      case ACTIVEWINDOW:
X! 	if( alwaysinvent && WIN_INVEN != WIN_ERR &&
X! 			    message->IDCMPWindow ==
X! 			    amii_wins[ WIN_INVEN ]->win )
X! 	{
X! 	    DoMenuScroll( WIN_INVEN, 0 );
X! 	}
X! 	else if( scrollmsg && WIN_MESSAGE != WIN_ERR &&
X! 			    message->IDCMPWindow ==
X! 			    amii_wins[ WIN_MESSAGE ]->win )
X! 	{
X! 	    DoMenuScroll( WIN_MESSAGE, 0 );
X! 	}
X! 	else
X! 	{
X! 	    skip_mouse=1;
X! 	}
X! 	break;
X! 
X      case MOUSEBUTTONS:
X  	{
X! 	    if( skip_mouse )
X! 	    {
X  		skip_mouse=0;
X  		break;
X  	    }
X! 
X! 	    if( !amii_wins[ WIN_MAP ] || w != amii_wins[ WIN_MAP ]->win )
X! 		break;
X! 
X! 	    if( message->Code == SELECTUP )
X! 	    {
X! #ifdef	VIEWWINDOW
X! 		amii_putstr( WIN_MESSAGE, 0, "done..." );
X! 		w->Flags &= ~REPORTMOUSE;
X! #endif
X! 	    }
X! 	    else if( message->Code == SELECTDOWN )
X! 	    {
X  		lastevent.type = WEMOUSE;
X! 		lastevent.un.mouse.x = message->MouseX;
X! 		lastevent.un.mouse.y = message->MouseY;
X  		    /* With shift equals RUN */
X! 		lastevent.un.mouse.qual = (message->Qualifier &
X  		  (IEQUALIFIER_LSHIFT|IEQUALIFIER_RSHIFT)) != 0;
X+ #ifdef	VIEWWINDOW
X+ 		w->Flags |= REPORTMOUSE;
X+ 		amii_putstr( WIN_MESSAGE, 0,
X+ 			"drag mouse to see other areas of this level" );
X+ #endif
X  	    }
X  	}
X  	break;
X***************
X*** 358,364 ****
X  	    struct MenuItem *item;
X  
X  	    thismenu = message->Code;
X! 	    while (thismenu != MENUNULL) {
X  		item = ItemAddress(HackMenu, (ULONG) thismenu);
X  		if (KbdBuffered < KBDBUFFER)
X  		    BufferQueueChar(item->Command); /* Unused: No COMMSEQ */
X--- 414,421 ----
X  	    struct MenuItem *item;
X  
X  	    thismenu = message->Code;
X! 	    while (thismenu != MENUNULL)
X! 	    {
X  		item = ItemAddress(HackMenu, (ULONG) thismenu);
X  		if (KbdBuffered < KBDBUFFER)
X  		    BufferQueueChar(item->Command); /* Unused: No COMMSEQ */
X***************
X*** 367,372 ****
X--- 424,469 ----
X  	}
X  	break;
X  
X+     case REFRESHWINDOW:
X+ #ifdef	VIEWWINDOW
X+ 	{
X+ 	    struct Window *vw, *vbw;
X+ 	    if( amii_wins[ WIN_VIEWBOX ] && amii_wins[ WIN_VIEW ] &&
X+ 		    w == amii_wins[ WIN_VIEWBOX ]->win )
X+ 	    {
X+ 		vw = amii_wins[ WIN_VIEW ]->win;
X+ 		vbw = amii_wins[ WIN_VIEWBOX ]->win;
X+ 
X+ 		if( vw->LeftEdge != (vbw->LeftEdge+vbw->BorderLeft) ||
X+ 		    vw->TopEdge != ( vbw->TopEdge + vbw->BorderTop ) ||
X+ 		    vw->Width != (vbw->Width -vbw->BorderLeft - vbw->BorderRight ) ||
X+ 		    vw->Height != (vbw->Height - vbw->BorderTop - vbw->BorderBottom ) )
X+ 		{
X+ 		    MoveWindow( vw, (vbw->LeftEdge+vbw->BorderLeft) - vw->LeftEdge,
X+ 			( vbw->TopEdge + vbw->BorderTop ) - vw->TopEdge );
X+ 		    SizeWindow( vw,
X+ 			( vbw->Width -vbw->BorderLeft -
X+ 				vbw->BorderRight ) - vw->Width,
X+ 			( vbw->Height - vbw->BorderTop -
X+ 				vbw->BorderBottom - vw->Height ) );
X+ 		}
X+ 	    }
X+ 	    else if( amii_wins[ WIN_MESSAGE ] && w == amii_wins[ WIN_MESSAGE ]->win )
X+ 	    {
X+ 		DoMenuScroll( WIN_MESSAGE, 0 );
X+ 	    }
X+ 	}
X+ #endif
X+ 	break;
X+ 
X+     case CLOSEWINDOW:
X+ 	if( WIN_INVEN != WIN_ERR && message->IDCMPWindow ==
X+ 				amii_wins[ WIN_INVEN ]->win )
X+ 	{
X+ 	    dismiss_nhwindow( WIN_INVEN );
X+ 	}
X+ 	break;
X+ 
X      case RAWKEY:
X  	if (!(message->Code & IECODE_UP_PREFIX)){
X  	    /* May queue multiple characters
X***************
X*** 376,385 ****
X--- 473,557 ----
X  		BufferQueueChar( c );
X          }
X          break;
X+ 
X+     case MOUSEMOVE:
X+ #ifdef	VIEWWINDOW
X+ 	if( w == amii_wins[ WIN_MAP ]->win )
X+ 	{
X+ 	    int posx, posy, dx, dy;
X+ 	    register struct MsgPort *port = w->UserPort;
X+ 	    struct amii_WinDesc *cw;
X+ 
X+ 	    posx = message->MouseX;
X+ 	    posy = message->MouseY;
X+ 	    cursor_on( WIN_MAP );
X+ 	    cw = amii_wins[ WIN_MAP ];
X+ 
X+ 	    do {
X+ 		if( message->Class == MOUSEBUTTONS ||
X+ 					message->Class == INACTIVEWINDOW )
X+ 		{
X+ 		    w->Flags &= ~REPORTMOUSE;
X+ 		    break;
X+ 		}
X+ 		else if( message->Class == MOUSEMOVE )
X+ 		{
X+ 		    if( posx != message->MouseX || posy != message->MouseY )
X+ 		    {
X+ 			dx = message->MouseX - posx;
X+ 			dy = message->MouseY - posy;
X+ 			dx /= MAPFTWIDTH;
X+ 			dy /= MAPFTHEIGHT;
X+ 			if( dx != 0 || dy != 0 )
X+ 			{
X+ 			    posx = message->MouseX;
X+ 			    posy = message->MouseY;
X+ 			    amii_curs( WIN_MAP,
X+ 				(posx - w->BorderLeft)/MAPFTWIDTH+dx,
X+ 				(posy - w->BorderTop)/MAPFTHEIGHT+dy );
X+ 			    cursor_on( WIN_MAP );
X+ 			}
X+ 		    }
X+ 		}
X+ 		ReplyMsg( (struct Message *) message );
X+ 		while( !(message = (struct IntuiMessage *)GetMsg( port ) ) )
X+ 		    WaitPort( port );
X+ 	    } while( message );
X+ 	    amii_putstr( WIN_MESSAGE, 0, "done..." );
X+ 	    break;
X+ 	}
X+ #endif
X+ 	/* FALL through for MESSAGE or INVEN windows */
X+     case GADGETDOWN:
X+ 	if( WIN_MESSAGE != WIN_ERR && message->IDCMPWindow ==
X+ 			amii_wins[ WIN_MESSAGE ]->win )
X+ 	{
X+ 	    DoMenuScroll( WIN_MESSAGE, 0 );
X+ 	}
X+ 	else if( WIN_INVEN != WIN_ERR && message->IDCMPWindow ==
X+ 			amii_wins[ WIN_INVEN ]->win )
X+ 	{
X+ 	    DoMenuScroll( WIN_INVEN, 0 );
X+ 	}
X+ 	break;
X+ 
X+     case NEWSIZE:
X+ 	if( WIN_MESSAGE != WIN_ERR && message->IDCMPWindow ==
X+ 			amii_wins[ WIN_MESSAGE ]->win )
X+ 	{
X+ 	    ReDisplayData( WIN_MESSAGE );
X+ 	}
X+ 	else if( WIN_INVEN != WIN_ERR && message->IDCMPWindow ==
X+ 			amii_wins[ WIN_INVEN ]->win )
X+ 	{
X+ 	    ReDisplayData( WIN_INVEN );
X+ 	}
X+ 	break;
X      }
X      ReplyMsg((struct Message *) message);
X  }
X  
X+ #endif /* AMII_GRAPHICS */
X  /*
X   *  Get all incoming messages and fill up the keyboard buffer,
X   *  thus allowing Intuition to (maybe) free up the IntuiMessages.
X***************
X*** 388,403 ****
X--- 560,586 ----
X   *  between characters and incoming messages.
X   */
X  
X+ #if defined(TTY_GRAPHICS) && !defined(AMII_GRAPHICS)
X+ int kbhit(){return 0};
X+ #else
X  int
X  kbhit()
X  {
X      int c;
X+ #ifdef TTY_GRAPHICS
X+ 		/* a kludge to defuse the mess in allmain.c */
X+ 		/* I hope this is the right approach */
X+     if(windowprocs.win_init_nhwindows==amii_procs.win_init_nhwindows)return 0;
X+ #endif
X      c = amikbhit();
X      if( c <= 0 )
X      	return( 0 );
X      return( c );
X  }
X+ #endif
X  
X+ #ifdef AMII_GRAPHICS
X+ 
X  int
X  amikbhit()
X  {
X***************
X*** 445,451 ****
X      if( KbdBuffered )
X      {
X  	lastevent.type = WEKEY;
X! 	lastevent.u.key = BufferGetchar();
X      }
X      return( lastevent.type );
X  }
X--- 628,634 ----
X      if( KbdBuffered )
X      {
X  	lastevent.type = WEKEY;
X! 	lastevent.un.key = BufferGetchar();
X      }
X      return( lastevent.type );
X  }
X***************
X*** 455,470 ****
X   *  when there is something that s/he should read.
X   */
X  
X! void CleanUp()
X  {
X      register struct IntuiMessage *msg;
X  
X!     /* Finish closing things up */
X  
X-     amii_raw_print("");
X-     amii_getret();
X- 
X-     ((struct Process *) FindTask(NULL))->pr_WindowPtr = (APTR) pr_WindowPtr;
X      if (ConsoleIO.io_Device)
X  	CloseDevice( (struct IORequest *)&ConsoleIO );
X      ConsoleIO.io_Device = 0;
X--- 638,654 ----
X   *  when there is something that s/he should read.
X   */
X  
X! void amii_cleanup()
X  {
X      register struct IntuiMessage *msg;
X  
X!     /* Close things up */
X!     if( HackPort )
X!     {
X! 	amii_raw_print("");
X! 	amii_getret();
X!     }
X  
X      if (ConsoleIO.io_Device)
X  	CloseDevice( (struct IORequest *)&ConsoleIO );
X      ConsoleIO.io_Device = 0;
X***************
X*** 473,479 ****
X  	DeletePort( ConsoleIO.io_Message.mn_ReplyPort );
X      ConsoleIO.io_Message.mn_ReplyPort = 0;
X  
X!     if (HackPort) {
X  	Forbid();
X  	while (msg = (struct IntuiMessage *) GetMsg(HackPort))
X  	    ReplyMsg((struct Message *) msg);
X--- 657,665 ----
X  	DeletePort( ConsoleIO.io_Message.mn_ReplyPort );
X      ConsoleIO.io_Message.mn_ReplyPort = 0;
X  
X!     /* Strip messages before deleting the port */
X!     if( HackPort )
X!     {
X  	Forbid();
X  	while (msg = (struct IntuiMessage *) GetMsg(HackPort))
X  	    ReplyMsg((struct Message *) msg);
X***************
X*** 483,493 ****
X  	Permit();
X      }
X  
X!     if (HackScreen) {
X  #ifdef  INTUI_NEW_LOOK
X  	if( IntuitionBase->LibNode.lib_Version >= 37 )
X  	{
X! 	    while( CloseScreen(HackScreen) == FALSE )
X  	    {
X  		struct EasyStruct easy =
X  		{
X--- 669,683 ----
X  	Permit();
X      }
X  
X!     /* Close the screen, under v37 or greater it is a pub screen and there may be
X!      * visitors, so check close status and wait till everyone is gone.
X!      */
X!     if( HackScreen )
X!     {
X  #ifdef  INTUI_NEW_LOOK
X  	if( IntuitionBase->LibNode.lib_Version >= 37 )
X  	{
X! 	    while( CloseScreen( HackScreen ) == FALSE )
X  	    {
X  		struct EasyStruct easy =
X  		{
X***************
X*** 500,513 ****
X  		EasyRequest( NULL, &easy, NULL, NULL );
X  	    }
X  	}
X! #else
X! 	CloseScreen(HackScreen);
X  #endif
X  	HackScreen = NULL;
X      }
X  
X  #ifdef HACKFONT
X- 
X      if (HackFont)
X      {
X  	CloseFont(HackFont);
X--- 690,704 ----
X  		EasyRequest( NULL, &easy, NULL, NULL );
X  	    }
X  	}
X! 	else
X  #endif
X+ 	{
X+ 	    CloseScreen(HackScreen);
X+ 	}
X  	HackScreen = NULL;
X      }
X  
X  #ifdef HACKFONT
X      if (HackFont)
X      {
X  	CloseFont(HackFont);
X***************
X*** 514,519 ****
X--- 705,730 ----
X  	HackFont = NULL;
X      }
X  
X+ #ifdef	VIEWWINDOW
X+     if (HackFont4)
X+     {
X+ 	CloseFont(HackFont4);
X+ 	HackFont4 = NULL;
X+     }
X+ 
X+     if (HackFont16)
X+     {
X+ 	CloseFont(HackFont16);
X+ 	HackFont16 = NULL;
X+     }
X+ #endif
X+ 
X+     if( TextsFont )
X+     {
X+ 	CloseFont( TextsFont );
X+ 	TextsFont = NULL;
X+     }
X+ 
X      if( DiskfontBase )
X      {
X  	CloseLibrary(DiskfontBase);
X***************
X*** 521,526 ****
X--- 732,744 ----
X      }
X  #endif
X  
X+ #ifdef	VIEWWINDOW
X+     if (LayersBase) {
X+ 	CloseLibrary((struct Library *)LayersBase);
X+ 	LayersBase = NULL;
X+     }
X+ #endif
X+ 
X      if (GfxBase) {
X  	CloseLibrary((struct Library *)GfxBase);
X  	GfxBase = NULL;
X***************
X*** 531,563 ****
X  	IntuitionBase = NULL;
X      }
X  
X      Initialized = 0;
X  }
X  
X  void Abort(rc)
X  long rc;
X  {
X  #ifdef CHDIR
X      extern char orgdir[];
X      chdir(orgdir);
X  #endif
X!     if (Initialized && ConsoleDevice) {
X! 	printf("\n\nAbort with alert code %08lx...\n", rc);
X! 	amii_getret();
X      } else
X! 	Alert(rc);
X  #ifdef __SASC
X      {
X  /*  __emit(0x4afc);     /* illegal instruction */
X      __emit(0x40fc);     /* divide by */
X      __emit(0x0000);     /*  #0  */
X! 	/* NOTE: don't move CleanUp() above here - */
X! 	/* it is too likely to kill the system     */
X! 	/* before it can get the SnapShot out, if  */
X! 	/* there is something really wrong.    */
X      }
X  #endif
X!     CleanUp();
X  #undef exit
X  #ifdef AZTEC_C
X      _abort();
X--- 749,818 ----
X  	IntuitionBase = NULL;
X      }
X  
X+ #ifdef	SHAREDLIB
X+     if (DOSBase) {
X+ 	CloseLibrary((struct Library *)DOSBase);
X+ 	DOSBase = NULL;
X+     }
X+ #endif
X+ 
X+     ((struct Process *) FindTask(NULL))->pr_WindowPtr = (APTR) pr_WindowPtr;
X+ 
X      Initialized = 0;
X  }
X  
X+ #ifndef	SHAREDLIB
X  void Abort(rc)
X  long rc;
X  {
X+     int fault = 1;
X  #ifdef CHDIR
X      extern char orgdir[];
X      chdir(orgdir);
X  #endif
X! #ifdef AMII_GRAPHICS
X!     if (Initialized
X!       && ConsoleDevice
X!       && windowprocs.win_init_nhwindows==amii_procs.win_init_nhwindows) {
X!       printf("\n\nAbort with alert code %08lx...\n", rc);
X!       amii_getret();
X      } else
X! #endif
X!       printf("\n\nAbort with alert code %08lx...\n",rc);
X! #if 0
X!       Alert(rc);              /* this is too severe */
X! #endif
X  #ifdef __SASC
X+ #ifdef	INTUI_NEW_LOOK
X      {
X+     	struct EasyStruct es =
X+     	{
X+     		sizeof( struct EasyStruct ),
X+     		0,
X+     		"NetHack Panic Request",
X+     		"NetHack is Aborting with code == 0x%08lx",
X+ 		"Continue Abort|Return to Program|Clean up and exit",
X+     	};
X+     	fault = EasyRequest( NULL, &es, NULL, (long)rc );
X+     	if( fault == 2 )
X+     	    return;
X+     }
X+ #endif
X+     if( fault == 1 )
X+     {
X  /*  __emit(0x4afc);     /* illegal instruction */
X      __emit(0x40fc);     /* divide by */
X      __emit(0x0000);     /*  #0  */
X!       /* NOTE: don't move amii_cleanup() above here - */
X!       /* it is too likely to kill the system     */
X!       /* before it can get the SnapShot out, if  */
X!       /* there is something really wrong.    */
X      }
X  #endif
X! #ifdef AMII_GRAPHICS
X!     if(windowprocs.win_init_nhwindows==amii_procs.win_init_nhwindows)
X!       amii_cleanup();
X! #endif
X  #undef exit
X  #ifdef AZTEC_C
X      _abort();
X***************
X*** 565,570 ****
X--- 820,834 ----
X      exit((int) rc);
X  }
X  
X+ void
X+ CleanUp()
X+ {
X+ 	amii_cleanup();
X+ }
X+ #endif
X+ 
X+ #ifdef AMII_GRAPHICS
X+ 
X  #ifdef AMIFLUSH
X  /* This routine adapted from AmigaMail IV-37 by Michael Sinz */
X  static struct Message *
X***************
X*** 620,625 ****
X--- 884,894 ----
X      struct Window *w;
X  {
X      short i, x, y;
X+ #ifdef	VIEWWINDOW
X+     struct Window *vw = amii_wins[ WIN_VIEW ]->win;
X+     register struct RastPort *vrp = vw->RPort;
X+ #endif
X+     register struct RastPort *rp = w->RPort;
X  
X      /* If nothing is buffered, return before we do anything */
X      if(glyph_node_index == 0)
X***************
X*** 627,657 ****
X  
X      cursor_off( WIN_MAP );
X      start_glyphout( WIN_MAP );
X      /* Set up the drawing mode */
X!     SetDrMd( w->RPort, JAM2);
X  
X      /* Go ahead and start dumping the stuff */
X      for(i=0; i<glyph_node_index; ++i) {
X  	/* These coordinate calculations must be synced with the
X! 	 * code in curs() in winami.c.  curs_on_u() calls curs()
X  	 * to draw the cursor on top of the player
X  	 */
X! 	y = w->BorderTop + (g_nodes[i].y-1) * w->RPort->TxHeight +
X! 	    w->RPort->TxBaseline + 1;
X! 	x = g_nodes[i].x * w->RPort->TxWidth + w->BorderLeft;
X  
X  	/* Move pens to correct location */
X! 	Move(w->RPort, (long)x, (long)y);
X  
X  	/* Setup the colors */
X! 	SetAPen(w->RPort, (long)g_nodes[i].fg_color);
X! 	SetBPen(w->RPort, (long)g_nodes[i].bg_color);
X  
X  	/* Do it */
X! 	Text(w->RPort, g_nodes[i].buffer, g_nodes[i].len);
X      }
X  
X!     end_glyphout( WIN_MAP );
X      /* Clean up */
X      glyph_node_index = glyph_buffer_index = 0;
X  }
X--- 896,952 ----
X  
X      cursor_off( WIN_MAP );
X      start_glyphout( WIN_MAP );
X+ #ifdef	VIEWWINDOW
X+     cursor_off( WIN_VIEW );
X+     start_glyphout( WIN_VIEW );
X+ #endif
X+ 
X      /* Set up the drawing mode */
X!     SetDrMd( rp, JAM2);
X! #ifdef	VIEWWINDOW
X!     SetDrMd( vrp, JAM2);
X! #endif
X  
X      /* Go ahead and start dumping the stuff */
X      for(i=0; i<glyph_node_index; ++i) {
X  	/* These coordinate calculations must be synced with the
X! 	 * code in amii_curs() in winami.c.  curs_on_u() calls amii_curs()
X  	 * to draw the cursor on top of the player
X  	 */
X! 	y = w->BorderTop + (g_nodes[i].y-1) * rp->TxHeight +
X! 	    rp->TxBaseline + 1;
X! 	x = g_nodes[i].x * rp->TxWidth + w->BorderLeft;
X  
X  	/* Move pens to correct location */
X! 	Move( rp, (long)x, (long)y);
X  
X  	/* Setup the colors */
X! 	SetAPen( rp, (long)g_nodes[i].fg_color);
X! 	SetBPen( rp, (long)g_nodes[i].bg_color);
X  
X  	/* Do it */
X! 	Text( rp, g_nodes[i].buffer, g_nodes[i].len);
X! 
X! #ifdef	VIEWWINDOW
X! 	y = vw->BorderTop + (g_nodes[i].y-1) * vrp->TxHeight + vrp->TxBaseline + 1;
X! 	x = g_nodes[i].x * vrp->TxWidth + vw->BorderLeft;
X! 
X! 	/* Move pens to correct location */
X! 	Move( vrp, (long)x, (long)y);
X! 
X! 	/* Setup the colors */
X! 	SetAPen( vrp, (long)g_nodes[i].fg_color);
X! 	SetBPen( vrp, (long)g_nodes[i].bg_color);
X! 
X! 	/* Do it */
X! 	Text( vrp, g_nodes[i].buffer, g_nodes[i].len);
X! #endif
X      }
X  
X!     amii_end_glyphout( WIN_MAP );
X! #ifdef	VIEWWINDOW
X!     amii_end_glyphout( WIN_VIEW );
X! #endif
X      /* Clean up */
X      glyph_node_index = glyph_buffer_index = 0;
X  }
X***************
X*** 665,676 ****
X      int color_index, glyph;
X  {
X      int fg_color, bg_color;
X!     struct WinDesc *cw;
X      struct Window *w;
X      int curx;
X      int cury;
X  
X!     if( ( cw=wins[window] ) == (struct WinDesc *)NULL )
X  	panic("bad winid in amiga_print_glyph: %d", window );
X  
X      w = cw->win;
X--- 960,971 ----
X      int color_index, glyph;
X  {
X      int fg_color, bg_color;
X!     struct amii_WinDesc *cw;
X      struct Window *w;
X      int curx;
X      int cury;
X  
X!     if( ( cw=amii_wins[window] ) == (struct amii_WinDesc *)NULL )
X  	panic("bad winid in amiga_print_glyph: %d", window );
X  
X      w = cw->win;
X***************
X*** 740,752 ****
X  start_glyphout(window)
X      winid window;
X  {
X!     struct WinDesc *cw;
X      struct Window *w;
X  
X!     if( ( cw=wins[window] ) == (struct WinDesc *)NULL )
X  	panic( "bad winid %d in start_glyphout()", window );
X  
X!     if( cw->flags & FLMAP_INGLYPH )
X  	return;
X  
X      if( !(w = cw->win ) )
X--- 1035,1047 ----
X  start_glyphout(window)
X      winid window;
X  {
X!     struct amii_WinDesc *cw;
X      struct Window *w;
X  
X!     if( ( cw=amii_wins[window] ) == (struct amii_WinDesc *)NULL )
X  	panic( "bad winid %d in start_glyphout()", window );
X  
X!     if( cw->wflags & FLMAP_INGLYPH )
X  	return;
X  
X      if( !(w = cw->win ) )
X***************
X*** 766,772 ****
X       */
X      usecolor = flags.use_color;
X      flags.use_color = FALSE;
X!     cw->flags |= FLMAP_INGLYPH;
X  }
X  
X  /*
X--- 1061,1067 ----
X       */
X      usecolor = flags.use_color;
X      flags.use_color = FALSE;
X!     cw->wflags |= FLMAP_INGLYPH;
X  }
X  
X  /*
X***************
X*** 773,790 ****
X   * General cleanup routine -- flushes and restores cursor
X   */
X  void
X! end_glyphout(window)
X      winid window;
X  {
X!     struct WinDesc *cw;
X      struct Window *w;
X  
X!     if( ( cw = wins[ window ] ) == (struct WinDesc *)NULL )
X! 	panic("bad window id %d in end_glyphout()", window );
X  
X!     if( ( cw->flags & FLMAP_INGLYPH ) == 0 )
X  	return;
X!     cw->flags &= ~(FLMAP_INGLYPH);
X  
X      if( !(w = cw->win ) )
X  	panic( "bad winid %d, no window ptr set", window );
X--- 1068,1085 ----
X   * General cleanup routine -- flushes and restores cursor
X   */
X  void
X! amii_end_glyphout(window)
X      winid window;
X  {
X!     struct amii_WinDesc *cw;
X      struct Window *w;
X  
X!     if( ( cw = amii_wins[ window ] ) == (struct amii_WinDesc *)NULL )
X! 	panic("bad window id %d in amii_end_glyphout()", window );
X  
X!     if( ( cw->wflags & FLMAP_INGLYPH ) == 0 )
X  	return;
X!     cw->wflags &= ~(FLMAP_INGLYPH);
X  
X      if( !(w = cw->win ) )
X  	panic( "bad winid %d, no window ptr set", window );
X***************
X*** 866,871 ****
X--- 1161,1167 ----
X  	    free( sip );
X  	}
X  	else if( gd->GadgetType == PROPGADGET )
X+ 
X  	{
X  	    free( (struct PropInfo *)gd->SpecialInfo );
X  	}
X***************
X*** 893,899 ****
X--- 1189,1207 ----
X  int state;
X  {
X  }
X+ #endif  /* AMII_GRAPHICS */
X  
X+ #ifndef	SHAREDLIB
X+ void
X+ amiv_loadlib( void )
X+ {
X+ }
X+ 
X+ void
X+ amii_loadlib( void )
X+ {
X+ }
X+ 
X  /* fatal error */
X  /*VARARGS1*/
X  void error VA_DECL(const char *, s)
X***************
X*** 907,909 ****
X--- 1215,1218 ----
X      VA_END();
X      Abort(0L);
X  }
X+ #endif
X*** /tmp/da11848	Tue Jun  1 17:00:39 1993
X--- sys/amiga/amiwind.p	Tue Apr 13 15:41:46 1993
X***************
X*** 20,30 ****
X  void FDECL( WindowPrintf, ( char *,... ));
X  void NDECL( CleanUp );
X  int FDECL( ConvertKey, ( struct IntuiMessage * ));
X  void FDECL( Abort, (long ));
X  void FDECL( flush_glyph_buffer, (struct Window *));
X  void FDECL( amiga_print_glyph, (winid , int , int ));
X  void FDECL( start_glyphout, (winid ));
X! void FDECL( end_glyphout, (winid ));
X  #ifdef	INTUI_NEW_LOOK
X  struct ExtNewWindow *FDECL( DupNewWindow, (struct ExtNewWindow *));
X  void FDECL( FreeNewWindow, (struct ExtNewWindow *));
X--- 20,32 ----
X  void FDECL( WindowPrintf, ( char *,... ));
X  void NDECL( CleanUp );
X  int FDECL( ConvertKey, ( struct IntuiMessage * ));
X+ #ifndef	SHAREDLIB
X  void FDECL( Abort, (long ));
X+ #endif
X  void FDECL( flush_glyph_buffer, (struct Window *));
X  void FDECL( amiga_print_glyph, (winid , int , int ));
X  void FDECL( start_glyphout, (winid ));
X! void FDECL( amii_end_glyphout, (winid ));
X  #ifdef	INTUI_NEW_LOOK
X  struct ExtNewWindow *FDECL( DupNewWindow, (struct ExtNewWindow *));
X  void FDECL( FreeNewWindow, (struct ExtNewWindow *));
X***************
X*** 35,37 ****
X--- 37,40 ----
X  void NDECL( bell );
X  void NDECL( amii_delay_output );
X  void FDECL( amii_number_pad, (int ));
X+ void amii_cleanup( void );
X*** /tmp/da11864	Tue Jun  1 17:00:44 1993
X--- sys/amiga/char.c	Mon May  3 13:21:08 1993
X***************
X*** 14,23 ****
X  };
X  
X  struct IntuiText Type_IText1 = {
X! 	3,0,JAM2,
X  	38,1,
X  	NULL,
X! 	(UBYTE *)"Wizard",
X  	NULL
X  };
X  
X--- 14,23 ----
X  };
X  
X  struct IntuiText Type_IText1 = {
X! 	7,0,JAM2,
X  	38,1,
X  	NULL,
X! 	"Wizard",
X  	NULL
X  };
X  
X***************
X*** 53,62 ****
X  };
X  
X  struct IntuiText Type_IText2 = {
X! 	3,0,JAM2,
X  	29,1,
X  	NULL,
X! 	(UBYTE *)"Valkyrie",
X  	NULL
X  };
X  
X--- 53,62 ----
X  };
X  
X  struct IntuiText Type_IText2 = {
X! 	7,0,JAM2,
X  	29,1,
X  	NULL,
X! 	"Valkyrie",
X  	NULL
X  };
X  
X***************
X*** 95,101 ****
X  	1,0,JAM2,
X  	14,1,
X  	NULL,
X! 	(UBYTE *)"Pick a Random Character Type",
X  	NULL
X  };
X  
X--- 95,101 ----
X  	1,0,JAM2,
X  	14,1,
X  	NULL,
X! 	"Pick a Random Character Type",
X  	NULL
X  };
X  
X***************
X*** 131,140 ****
X  };
X  
X  struct IntuiText Type_IText4 = {
X! 	3,0,JAM2,
X  	33,1,
X  	NULL,
X! 	(UBYTE *)"Samurai",
X  	NULL
X  };
X  
X--- 131,140 ----
X  };
X  
X  struct IntuiText Type_IText4 = {
X! 	7,0,JAM2,
X  	33,1,
X  	NULL,
X! 	"Samurai",
X  	NULL
X  };
X  
X***************
X*** 170,179 ****
X  };
X  
X  struct IntuiText Type_IText5 = {
X! 	3,0,JAM2,
X  	34,1,
X  	NULL,
X! 	(UBYTE *)"Tourist",
X  	NULL
X  };
X  
X--- 170,179 ----
X  };
X  
X  struct IntuiText Type_IText5 = {
X! 	7,0,JAM2,
X  	34,1,
X  	NULL,
X! 	"Tourist",
X  	NULL
X  };
X  
X***************
X*** 209,218 ****
X  };
X  
X  struct IntuiText Type_IText6 = {
X! 	3,0,JAM2,
X  	40,1,
X  	NULL,
X! 	(UBYTE *)"Rogue",
X  	NULL
X  };
X  
X--- 209,218 ----
X  };
X  
X  struct IntuiText Type_IText6 = {
X! 	7,0,JAM2,
X  	40,1,
X  	NULL,
X! 	"Rogue",
X  	NULL
X  };
X  
X***************
X*** 248,257 ****
X  };
X  
X  struct IntuiText Type_IText7 = {
X! 	3,0,JAM2,
X  	36,1,
X  	NULL,
X! 	(UBYTE *)"Priest",
X  	NULL
X  };
X  
X--- 248,257 ----
X  };
X  
X  struct IntuiText Type_IText7 = {
X! 	7,0,JAM2,
X  	36,1,
X  	NULL,
X! 	"Priest",
X  	NULL
X  };
X  
X***************
X*** 287,296 ****
X  };
X  
X  struct IntuiText Type_IText8 = {
X! 	3,0,JAM2,
X  	35,1,
X  	NULL,
X! 	(UBYTE *)"Healer",
X  	NULL
X  };
X  
X--- 287,296 ----
X  };
X  
X  struct IntuiText Type_IText8 = {
X! 	7,0,JAM2,
X  	35,1,
X  	NULL,
X! 	"Healer",
X  	NULL
X  };
X  
X***************
X*** 326,335 ****
X  };
X  
X  struct IntuiText Type_IText9 = {
X! 	3,0,JAM2,
X  	33,1,
X  	NULL,
X! 	(UBYTE *)"Caveman",
X  	NULL
X  };
X  
X--- 326,335 ----
X  };
X  
X  struct IntuiText Type_IText9 = {
X! 	7,0,JAM2,
X  	33,1,
X  	NULL,
X! 	"Caveman",
X  	NULL
X  };
X  
X***************
X*** 365,374 ****
X  };
X  
X  struct IntuiText Type_IText10 = {
X! 	3,0,JAM2,
X  	16,1,
X  	NULL,
X! 	(UBYTE *)"Archeologist",
X  	NULL
X  };
X  
X--- 365,374 ----
X  };
X  
X  struct IntuiText Type_IText10 = {
X! 	7,0,JAM2,
X  	16,1,
X  	NULL,
X! 	"Archeologist",
X  	NULL
X  };
X  
X***************
X*** 404,413 ****
X  };
X  
X  struct IntuiText Type_IText11 = {
X! 	3,0,JAM2,
X  	36,1,
X  	NULL,
X! 	(UBYTE *)"Knight",
X  	NULL
X  };
X  
X--- 404,413 ----
X  };
X  
X  struct IntuiText Type_IText11 = {
X! 	7,0,JAM2,
X  	36,1,
X  	NULL,
X! 	"Knight",
X  	NULL
X  };
X  
X***************
X*** 443,452 ****
X  };
X  
X  struct IntuiText Type_IText12 = {
X! 	3,0,JAM2,
X  	48,1,
X  	NULL,
X! 	(UBYTE *)"Elf",
X  	NULL
X  };
X  
X--- 443,452 ----
X  };
X  
X  struct IntuiText Type_IText12 = {
X! 	7,0,JAM2,
X  	48,1,
X  	NULL,
X! 	"Elf",
X  	NULL
X  };
X  
X***************
X*** 482,491 ****
X  };
X  
X  struct IntuiText Type_IText13 = {
X! 	3,0,JAM2,
X  	27,1,
X  	NULL,
X! 	(UBYTE *)"Barbarian",
X  	NULL
X  };
X  
X--- 482,491 ----
X  };
X  
X  struct IntuiText Type_IText13 = {
X! 	7,0,JAM2,
X  	27,1,
X  	NULL,
X! 	"Barbarian",
X  	NULL
X  };
X  
X***************
X*** 515,521 ****
X  	WINDOWCLOSE+ACTIVATE+NOCAREREFRESH,
X  	&Type_Gadget1,
X  	NULL,
X! 	(UBYTE *)"Pick a Character",
X  	NULL,
X  	NULL,
X  	5,5,
X--- 515,521 ----
X  	WINDOWCLOSE+ACTIVATE+NOCAREREFRESH,
X  	&Type_Gadget1,
X  	NULL,
X! 	"Pick a Character",
X  	NULL,
X  	NULL,
X  	5,5,
X*** /tmp/da11888	Tue Jun  1 17:00:50 1993
X--- sys/amiga/colorwin.c	Wed May 19 10:07:49 1993
X***************
X*** 15,21 ****
X  };
X  
X  struct IntuiText Col_IText1 = {
X! 	3,0,JAM2,	/* front and back text pens, drawmode and fill byte */
X  	13,1,	/* XY origin relative to container TopLeft */
X  	NULL,	/* font pointer or NULL for default */
X  	"Save",	/* pointer to text */
X--- 15,21 ----
X  };
X  
X  struct IntuiText Col_IText1 = {
X! 	7,0,JAM2,	/* front and back text pens, drawmode and fill byte */
X  	13,1,	/* XY origin relative to container TopLeft */
X  	NULL,	/* font pointer or NULL for default */
X  	"Save",	/* pointer to text */
X***************
X*** 54,60 ****
X  };
X  
X  struct IntuiText Col_IText2 = {
X! 	3,0,JAM2,	/* front and back text pens, drawmode and fill byte */
X  	17,1,	/* XY origin relative to container TopLeft */
X  	NULL,	/* font pointer or NULL for default */
X  	"Use",	/* pointer to text */
X--- 54,60 ----
X  };
X  
X  struct IntuiText Col_IText2 = {
X! 	7,0,JAM2,	/* front and back text pens, drawmode and fill byte */
X  	17,1,	/* XY origin relative to container TopLeft */
X  	NULL,	/* font pointer or NULL for default */
X  	"Use",	/* pointer to text */
X***************
X*** 63,69 ****
X  
X  struct Gadget Col_Okay = {
X  	&Col_Save,	/* next gadget */
X! 	117,77,	/* origin XY of hit box relative to window TopLeft */
X  	58,11,	/* hit box width and height */
X  	NULL,	/* gadget flags */
X  	RELVERIFY,	/* activation flags */
X--- 63,69 ----
X  
X  struct Gadget Col_Okay = {
X  	&Col_Save,	/* next gadget */
X! 	128,77,	/* origin XY of hit box relative to window TopLeft */
X  	58,11,	/* hit box width and height */
X  	NULL,	/* gadget flags */
X  	RELVERIFY,	/* activation flags */
X***************
X*** 93,99 ****
X  };
X  
X  struct IntuiText Col_IText3 = {
X! 	3,0,JAM2,	/* front and back text pens, drawmode and fill byte */
X  	6,1,	/* XY origin relative to container TopLeft */
X  	NULL,	/* font pointer or NULL for default */
X  	"Cancel",	/* pointer to text */
X--- 93,99 ----
X  };
X  
X  struct IntuiText Col_IText3 = {
X! 	7,0,JAM2,	/* front and back text pens, drawmode and fill byte */
X  	6,1,	/* XY origin relative to container TopLeft */
X  	NULL,	/* font pointer or NULL for default */
X  	"Cancel",	/* pointer to text */
X***************
X*** 102,108 ****
X  
X  struct Gadget Col_Cancel = {
X  	&Col_Okay,	/* next gadget */
X! 	218,77,	/* origin XY of hit box relative to window TopLeft */
X  	58,11,	/* hit box width and height */
X  	NULL,	/* gadget flags */
X  	RELVERIFY,	/* activation flags */
X--- 102,108 ----
X  
X  struct Gadget Col_Cancel = {
X  	&Col_Okay,	/* next gadget */
X! 	244,77,	/* origin XY of hit box relative to window TopLeft */
X  	58,11,	/* hit box width and height */
X  	NULL,	/* gadget flags */
X  	RELVERIFY,	/* activation flags */
X***************
X*** 133,139 ****
X  
X  struct Gadget Col_RedPen = {
X  	&Col_Cancel,	/* next gadget */
X! 	7,12,	/* origin XY of hit box relative to window TopLeft */
X  	271,11,	/* hit box width and height */
X  	NULL,	/* gadget flags */
X  	RELVERIFY+GADGIMMEDIATE+FOLLOWMOUSE,	/* activation flags */
X--- 133,139 ----
X  
X  struct Gadget Col_RedPen = {
X  	&Col_Cancel,	/* next gadget */
X! 	32,12,	/* origin XY of hit box relative to window TopLeft */
X  	271,11,	/* hit box width and height */
X  	NULL,	/* gadget flags */
X  	RELVERIFY+GADGIMMEDIATE+FOLLOWMOUSE,	/* activation flags */
X***************
X*** 164,170 ****
X  
X  struct Gadget Col_GreenPen = {
X  	&Col_RedPen,	/* next gadget */
X! 	7,24,	/* origin XY of hit box relative to window TopLeft */
X  	271,11,	/* hit box width and height */
X  	NULL,	/* gadget flags */
X  	RELVERIFY+GADGIMMEDIATE+FOLLOWMOUSE,	/* activation flags */
X--- 164,170 ----
X  
X  struct Gadget Col_GreenPen = {
X  	&Col_RedPen,	/* next gadget */
X! 	32,24,	/* origin XY of hit box relative to window TopLeft */
X  	271,11,	/* hit box width and height */
X  	NULL,	/* gadget flags */
X  	RELVERIFY+GADGIMMEDIATE+FOLLOWMOUSE,	/* activation flags */
X***************
X*** 195,201 ****
X  
X  struct Gadget Col_BluePen = {
X  	&Col_GreenPen,	/* next gadget */
X! 	7,36,	/* origin XY of hit box relative to window TopLeft */
X  	271,11,	/* hit box width and height */
X  	NULL,	/* gadget flags */
X  	RELVERIFY+GADGIMMEDIATE+FOLLOWMOUSE,	/* activation flags */
X--- 195,201 ----
X  
X  struct Gadget Col_BluePen = {
X  	&Col_GreenPen,	/* next gadget */
X! 	32,36,	/* origin XY of hit box relative to window TopLeft */
X  	271,11,	/* hit box width and height */
X  	NULL,	/* gadget flags */
X  	RELVERIFY+GADGIMMEDIATE+FOLLOWMOUSE,	/* activation flags */
X***************
X*** 211,219 ****
X  
X  #define Col_GadgetList1 Col_BluePen
X  
X  struct NewWindow Col_NewWindowStructure1 = {
X  	175,45,	/* window XY origin relative to TopLeft of screen */
X! 	284,93,	/* window width and height */
X  	0,1,	/* detail and block pens */
X  	MOUSEBUTTONS+MOUSEMOVE+GADGETDOWN+GADGETUP+CLOSEWINDOW+VANILLAKEY+INTUITICKS,	/* IDCMP flags */
X  	WINDOWDRAG+WINDOWDEPTH+WINDOWCLOSE+ACTIVATE+NOCAREREFRESH,	/* other window flags */
X--- 211,245 ----
X  
X  #define Col_GadgetList1 Col_BluePen
X  
X+ struct IntuiText Col_IText6 = {
X+ 	3,0,JAM2,	/* front and back text pens, drawmode and fill byte */
X+ 	17,38,	/* XY origin relative to container TopLeft */
X+ 	NULL,	/* font pointer or NULL for default */
X+ 	"B",	/* pointer to text */
X+ 	NULL	/* next IntuiText structure */
X+ };
X+ 
X+ struct IntuiText Col_IText5 = {
X+ 	4,0,JAM2,	/* front and back text pens, drawmode and fill byte */
X+ 	16,26,	/* XY origin relative to container TopLeft */
X+ 	NULL,	/* font pointer or NULL for default */
X+ 	"G",	/* pointer to text */
X+ 	&Col_IText6	/* next IntuiText structure */
X+ };
X+ 
X+ struct IntuiText Col_IText4 = {
X+ 	7,0,JAM2,	/* front and back text pens, drawmode and fill byte */
X+ 	16,14,	/* XY origin relative to container TopLeft */
X+ 	NULL,	/* font pointer or NULL for default */
X+ 	"R",	/* pointer to text */
X+ 	&Col_IText5	/* next IntuiText structure */
X+ };
X+ 
X+ #define Col_IntuiTextList1 Col_IText4
X+ 
X  struct NewWindow Col_NewWindowStructure1 = {
X  	175,45,	/* window XY origin relative to TopLeft of screen */
X! 	312,93,	/* window width and height */
X  	0,1,	/* detail and block pens */
X  	MOUSEBUTTONS+MOUSEMOVE+GADGETDOWN+GADGETUP+CLOSEWINDOW+VANILLAKEY+INTUITICKS,	/* IDCMP flags */
X  	WINDOWDRAG+WINDOWDEPTH+WINDOWCLOSE+ACTIVATE+NOCAREREFRESH,	/* other window flags */
X*** /tmp/da11912	Tue Jun  1 17:00:55 1993
X--- sys/amiga/hackwb.hlp	Mon May  3 13:35:05 1993
X***************
X*** 22,35 ****
X   Top Scores  - View the score file.
X   Recover     - Recover a game which was interrupted by a
X                 GURU, Software Failure, or other disaster.
X-  Edit Default Game - The file wbdefaults.def is always
X-                loaded to provide the default ToolTypes
X-                information for the NewGame icon (specifying
X-                options, character name and character type).
X-                The window opened by this selection allows
X-                you to edit this information as well as
X-                create new "games" by changing wbdefaults to
X-                a different name and using save/load.
X   Edit Configuration - The string data in nethack.cnf can be
X                 edited saved and loaded using the requester
X                 opened by this selection.
X--- 22,27 ----
X***************
X*** 40,51 ****
X                 Game Configuration  gadget lets you change
X                 the options that "Edit Default Game" let you
X                 enter.  
X!  Change Comment  - Lets you set a comment string for the
X!                save file.
X!  Set Options - takes you directly to the options editing
X!                requester.
X!  Copy Options - Creates a new icon with the same options as
X!                the selected game.  The new Icon has no saved
X                 game associated with it.
X   Discard     - Deletes the icon and any saved game
X                 associated with it.
X--- 32,39 ----
X                 Game Configuration  gadget lets you change
X                 the options that "Edit Default Game" let you
X                 enter.  
X!  Copy Info   - Creates a new icon with the same tooltypes as
X!                the selected icon.  The new icon has no saved
X                 game associated with it.
X   Discard     - Deletes the icon and any saved game
X                 associated with it.
X*** /tmp/da11928	Tue Jun  1 17:00:59 1993
X--- sys/amiga/randwin.c	Tue May 11 10:08:45 1993
X***************
X*** 15,21 ****
X  };
X  
X  struct IntuiText Rnd_IText1 = {
X! 	3,0,JAM2,	/* front and back text pens, drawmode and fill byte */
X  	8,5,	/* XY origin relative to container TopLeft */
X  	NULL,	/* font pointer or NULL for default */
X  	"OKAY",	/* pointer to text */
X--- 15,21 ----
X  };
X  
X  struct IntuiText Rnd_IText1 = {
X! 	7,0,JAM2,	/* front and back text pens, drawmode and fill byte */
X  	8,5,	/* XY origin relative to container TopLeft */
X  	NULL,	/* font pointer or NULL for default */
X  	"OKAY",	/* pointer to text */
X***************
X*** 41,47 ****
X  #define Rnd_GadgetList1 Rnd_Gadget1
X  
X  struct IntuiText Rnd_IText6 = {
X! 	3,0,JAM2,	/* front and back text pens, drawmode and fill byte */
X  	198,29,	/* XY origin relative to container TopLeft */
X  	NULL,	/* font pointer or NULL for default */
X  	"a",	/* pointer to text */
X--- 41,47 ----
X  #define Rnd_GadgetList1 Rnd_Gadget1
X  
X  struct IntuiText Rnd_IText6 = {
X! 	6,0,JAM2,	/* front and back text pens, drawmode and fill byte */
X  	198,29,	/* XY origin relative to container TopLeft */
X  	NULL,	/* font pointer or NULL for default */
X  	"a",	/* pointer to text */
X***************
X*** 57,63 ****
X  };
X  
X  struct IntuiText Rnd_IText4 = {
X! 	3,0,JAM2,	/* front and back text pens, drawmode and fill byte */
X  	25,29,	/* XY origin relative to container TopLeft */
X  	NULL,	/* font pointer or NULL for default */
X  	"exciting game playing as",	/* pointer to text */
X--- 57,63 ----
X  };
X  
X  struct IntuiText Rnd_IText4 = {
X! 	6,0,JAM2,	/* front and back text pens, drawmode and fill byte */
X  	25,29,	/* XY origin relative to container TopLeft */
X  	NULL,	/* font pointer or NULL for default */
X  	"exciting game playing as",	/* pointer to text */
X***************
X*** 65,71 ****
X  };
X  
X  struct IntuiText Rnd_IText3 = {
X! 	3,0,JAM2,	/* front and back text pens, drawmode and fill byte */
X  	15,18,	/* XY origin relative to container TopLeft */
X  	NULL,	/* font pointer or NULL for default */
X  	"I think that you will have an",	/* pointer to text */
X--- 65,71 ----
X  };
X  
X  struct IntuiText Rnd_IText3 = {
X! 	6,0,JAM2,	/* front and back text pens, drawmode and fill byte */
X  	15,18,	/* XY origin relative to container TopLeft */
X  	NULL,	/* font pointer or NULL for default */
X  	"I think that you will have an",	/* pointer to text */
X***************
X*** 73,82 ****
X  };
X  
X  struct IntuiText Rnd_IText2 = {
X! 	3,0,JAM2,	/* front and back text pens, drawmode and fill byte */
X  	7,6,	/* XY origin relative to container TopLeft */
X  	NULL,	/* font pointer or NULL for default */
X! 	"You asked for a random Character,",	/* pointer to text */
X  	&Rnd_IText3	/* next IntuiText structure */
X  };
X  
X--- 73,82 ----
X  };
X  
X  struct IntuiText Rnd_IText2 = {
X! 	6,0,JAM2,	/* front and back text pens, drawmode and fill byte */
X  	7,6,	/* XY origin relative to container TopLeft */
X  	NULL,	/* font pointer or NULL for default */
X! 	"You asked for a random Character.",	/* pointer to text */
X  	&Rnd_IText3	/* next IntuiText structure */
X  };
X  
X*** /tmp/da11976	Tue Jun  1 17:01:20 1993
X--- sys/amiga/wbdata.c	Thu May  6 11:25:53 1993
X***************
X*** 11,20 ****
X  char *classes = "ABCEHKPRSTVW";
X  struct TmpRas tmpras;
X  
X! DEFAULTS  defgame =
X  {
X!     PL_RANDOM,
X!     NULL, NULL,
X  };
X  
X  OPTIONS curopts[] =
X--- 11,45 ----
X  char *classes = "ABCEHKPRSTVW";
X  struct TmpRas tmpras;
X  
X! UWORD __chip waitPointer[] =
X  {
X!     0x0000,0x0000,
X! 
X!     0x0400,0x07c0,
X!     0x0000,0x07c0,
X! 
X!     0x0100,0x0380,
X!     0x0000,0x07e0,
X! 
X!     0x07c0,0x1ff8,
X!     0x1ff0,0x3fec,
X! 
X!     0x3ff8,0x7fde,
X!     0x3ff8,0x7fbe,
X! 
X!     0x7ffc,0xff7f,
X!     0x7efc,0xffff,
X! 
X!     0x7ffc,0xffff,
X!     0x3ff8,0x7ffe,
X! 
X!     0x3ff8,0x7ffe,
X!     0x1ff0,0x3ffc,
X! 
X!     0x07c0,0x1ff8,
X!     0x0000,0x07e0,
X! 
X!     0x0000,0x0000,
X  };
X  
X  OPTIONS curopts[] =
X***************
X*** 32,40 ****
X      { 0, 1, "legacy", NULL, GADOLEGACY, },
X      { 0, 0, "lit_corridor", NULL, GADOLITCORRIDOR, },
X      { 0, 1, "news", NULL, GADONEWS, },
X!     { 0, 0, "numberpad", NULL, GADONUMBERPAD, },
X      { 0, 1, "null", NULL, GADONULL, },
X!     { 0, 1, "pickup", NULL, GADOPICKUP, },
X      { 0, 0, "rest_on_space", NULL, GADORESTONSPACE, },
X      { 0, 1, "safepet", NULL, GADOSAFEPET, },
X      { 0, 0, "showexp", NULL, GADOSHOWEXP, },
X--- 57,65 ----
X      { 0, 1, "legacy", NULL, GADOLEGACY, },
X      { 0, 0, "lit_corridor", NULL, GADOLITCORRIDOR, },
X      { 0, 1, "news", NULL, GADONEWS, },
X!     { 0, 0, "number_pad", NULL, GADONUMBERPAD, },
X      { 0, 1, "null", NULL, GADONULL, },
X!     { 0, 1, "autopickup", NULL, GADOPICKUP, },
X      { 0, 0, "rest_on_space", NULL, GADORESTONSPACE, },
X      { 0, 1, "safepet", NULL, GADOSAFEPET, },
X      { 0, 0, "showexp", NULL, GADOSHOWEXP, },
X***************
X*** 46,52 ****
X      { 0, 0, "time", NULL, GADOTIME, },
X      { 0, 1, "tombstone", NULL, GADOTOMBSTONE, },
X      { 0, 1, "verbose", NULL, GADOVERBOSE, },
X!     { 0, 0, "asksave", NULL, GADOASKSAVE, },
X      { 0, 0, "packorder", "", GADOPACKORDER, },
X      { 0, 0, "dogname", "", GADODOGNAME, },
X      { 0, 0, "catname", "", GADOCATNAME, },
X--- 71,84 ----
X      { 0, 0, "time", NULL, GADOTIME, },
X      { 0, 1, "tombstone", NULL, GADOTOMBSTONE, },
X      { 0, 1, "verbose", NULL, GADOVERBOSE, },
X!     { 0, 0, "asksavedisk", NULL, GADOASKSAVE, },
X!     { 0, 0, "name", "", GADONAME, },
X!     { 0, 0, "score", "", GADOSCORE, },
X!     { 0, 0, "palette", "", GADOPALETTE, },
X!     { 0, 0, "windowtype", "", GADOWINDOWTYPE, },
X!     { 0, 0, "msghistory", "", GADOMSGHISTORY, },
X!     { 0, 0, "pickup_types", "", GADOPICKUPTYPES, },
X!     { 0, 0, "pettype", "", GADOPETTYPE, },
X      { 0, 0, "packorder", "", GADOPACKORDER, },
X      { 0, 0, "dogname", "", GADODOGNAME, },
X      { 0, 0, "catname", "", GADOCATNAME, },
X***************
X*** 102,107 ****
X--- 134,174 ----
X  
X  };
X  
X+ USHORT __chip tall_up_renderdata[] = {
X+ /* Plane 0 */
X+    0xfff0,
X+    0x8700,
X+    0x8700,
X+    0x8700,
X+    0x8f80,
X+    0x8f80,
X+    0xbfe0,
X+    0xbfe0,
X+    0xbfe0,
X+    0x8000,
X+ 
X+ /* Plane 1 */
X+    0x0008,
X+    0x0708,
X+    0x0708,
X+    0x0708,
X+    0x0f88,
X+    0x0f88,
X+    0x3fe8,
X+    0x3fe8,
X+    0x3fe8,
X+    0x7ff8,
X+ 
X+ };
X+ 
X+ struct Image tall_up_renderimage = {
X+    0, 0,
X+    13, 10, 2,
X+    tall_up_renderdata,
X+    3,0,
X+    NULL,
X+ };
X+ 
X  struct Image up_renderimage = {
X     0, 0,
X     13, 5, 2,
X***************
X*** 110,120 ****
X     NULL,
X  };
X  
X  USHORT __chip up_selectdata[] = {
X  /* Plane 0 */
X!    0x0008, 0x78f8, 0x7078, 0x4018, 0xfff8,
X  /* Plane 1 */
X!    0xfff0, 0xf8f0, 0xf070, 0xc010, 0x0000,
X  };
X  
X  struct Image up_selectimage = {
X--- 177,220 ----
X     NULL,
X  };
X  
X+ USHORT __chip tall_up_selectdata[] = {
X+ /* Plane 0 */
X+    0x0008,
X+    0x78f8,
X+    0x78f8,
X+    0x78f8,
X+    0x7078,
X+    0x7078,
X+    0x4018,
X+    0x4018,
X+    0x4018,
X+    0xfff8,
X+ /* Plane 1 */
X+    0xfff0,
X+    0xf8f0,
X+    0xf8f0,
X+    0xf8f0,
X+    0xf070,
X+    0xf070,
X+    0xc010,
X+    0xc010,
X+    0xc010,
X+    0x0000,
X+ };
X+ 
X  USHORT __chip up_selectdata[] = {
X  /* Plane 0 */
X!    0x0008,
X!    0x78f8,
X!    0x7078,
X!    0x4018,
X!    0xfff8,
X  /* Plane 1 */
X!    0xfff0,
X!    0xf8f0,
X!    0xf070,
X!    0xc010,
X!    0x0000,
X  };
X  
X  struct Image up_selectimage = {
X***************
X*** 125,130 ****
X--- 225,238 ----
X     NULL,
X  };
X  
X+ struct Image tall_up_selectimage = {
X+    0, 0,
X+    13, 10, 2,
X+    tall_up_selectdata,
X+    3,0,
X+    NULL,
X+ };
X+ 
X  USHORT __chip down_renderdata[] = {
X  /* Plane 0 */
X     0xfff0,
X***************
X*** 142,147 ****
X--- 250,289 ----
X  
X  };
X  
X+ USHORT __chip tall_down_renderdata[] = {
X+ /* Plane 0 */
X+    0xfff0,
X+    0xbfe0,
X+    0xbfe0,
X+    0xbfe0,
X+    0x8f80,
X+    0x8f80,
X+    0x8700,
X+    0x8700,
X+    0x8700,
X+    0x8000,
X+ 
X+ /* Plane 1 */
X+    0x0008,
X+    0x3fe8,
X+    0x3fe8,
X+    0x3fe8,
X+    0x0f88,
X+    0x0f88,
X+    0x0708,
X+    0x0708,
X+    0x0708,
X+    0x7ff8,
X+ };
X+ 
X+ struct Image tall_down_renderimage = {
X+    0, 0,
X+    13, 10, 2,
X+    tall_down_renderdata,
X+    3,0,
X+    NULL,
X+ };
X+ 
X  struct Image down_renderimage = {
X     0, 0,
X     13, 5, 2,
X***************
X*** 152,160 ****
X  
X  USHORT __chip down_selectdata[] = {
X  /* Plane 0 */
X!    0x0008, 0x4018, 0x7078, 0x78f8, 0x7ff8,
X  /* Plane 1 */
X!    0xfff0, 0xc010, 0xf070, 0xf8f0, 0x8000,
X  };
X  
X  struct Image down_selectimage = {
X--- 294,343 ----
X  
X  USHORT __chip down_selectdata[] = {
X  /* Plane 0 */
X!    0x0008,
X!    0x4018,
X!    0x7078,
X!    0x78f8,
X!    0x7ff8,
X  /* Plane 1 */
X!    0xfff0,
X!    0xc010,
X!    0xf070,
X!    0xf8f0,
X!    0x8000,
X! };
X! 
X! USHORT __chip tall_down_selectdata[] = {
X! /* Plane 0 */
X!    0x0008,
X!    0x4018,
X!    0x4018,
X!    0x4018,
X!    0x7078,
X!    0x7078,
X!    0x78f8,
X!    0x78f8,
X!    0x78f8,
X!    0x7ff8,
X! /* Plane 1 */
X!    0xfff0,
X!    0xc010,
X!    0xc010,
X!    0xc010,
X!    0xf070,
X!    0xf070,
X!    0xf8f0,
X!    0xf8f0,
X!    0xf8f0,
X!    0x8000,
X! };
X! 
X! struct Image tall_down_selectimage = {
X!    0, 0,
X!    13, 10, 2,
X!    tall_down_selectdata,
X!    3,0,
X!    NULL,
X  };
X  
X  struct Image down_selectimage = {
X*** /tmp/da11984	Tue Jun  1 17:01:22 1993
X--- sys/amiga/wbdefs.h	Thu May  6 11:25:57 1993
X***************
X*** 43,60 ****
X  #define ITEM_ABOUT	1
X  #define ITEM_SCORES	2
X  #define ITEM_RECOVER	3
X! /*#define ITEM_EDNEW        4*/
X! #define ITEM_EDDEF	4
X! #define ITEM_CONFIG	5
X! #define ITEM_QUIT	6
X  
X  #define MENU_GAME	1
X  #define ITEM_INFO	0
X! #define ITEM_SETCOMMENT	1
X! #define ITEM_SETOPT	2
X! #define ITEM_COPYOPT	3
X! #define ITEM_DISCARD	4
X! #define ITEM_RENAME	5
X  
X  #define GADSCROLL	1   /* The scroll bar */
X  #define GADNEWGAME	2   /* New Game requested */
X--- 43,56 ----
X  #define ITEM_ABOUT	1
X  #define ITEM_SCORES	2
X  #define ITEM_RECOVER	3
X! #define ITEM_CONFIG	4
X! #define ITEM_QUIT	5
X  
X  #define MENU_GAME	1
X  #define ITEM_INFO	0
X! #define ITEM_COPYOPT	1
X! #define ITEM_DISCARD	2
X! #define ITEM_RENAME	3
X  
X  #define GADSCROLL	1   /* The scroll bar */
X  #define GADNEWGAME	2   /* New Game requested */
X***************
X*** 72,79 ****
X  #define GADOUTFILE	10
X  #define GADCATNAME	11
X  #define GADDOGNAME	12
X- #define GADDEFLOAD	13
X- #define GADDEFSAVE	14
X  
X  #define GADSTRSAVE	15
X  #define GADSTRLEVELS	16
X--- 68,73 ----
X***************
X*** 80,86 ****
X  #define GADSTRPATH	17
X  #define GADSTRPENS	18
X  #define GADSTRHACKDIR	19
X- #define GADEDOPTIONS	20
X  #define GADCONFSAVE	21
X  #define GADCONFLOAD	22
X  #define GADCONFNAME	23
X--- 74,79 ----
X***************
X*** 93,99 ****
X  #define GADHELPOKAY	30
X  #define GADHELPFRWD	31
X  #define GADHELPBKWD	32
X! #define GADEDDEF	33
X  
X  #define GADRESTDIR	34
X  #define GADRESTOLD	35
X--- 86,92 ----
X  #define GADHELPOKAY	30
X  #define GADHELPFRWD	31
X  #define GADHELPBKWD	32
X! #define GADEDITOPTS	33
X  
X  #define GADRESTDIR	34
X  #define GADRESTOLD	35
X***************
X*** 100,105 ****
X--- 93,102 ----
X  #define GADRESTNEW	36
X  #define GADRESTCAN	37
X  #define GADRESTOKAY	38
X+ #define GADSAVEINFO	39
X+ #define GADUSEINFO	40
X+ #define GADQUITINFO	41
X+ #define GADPLNAME	42
X  
X  /*
X   *  Option gadgets GadgetID's
X***************
X*** 139,144 ****
X--- 136,148 ----
X  #define GADOLITCORRIDOR	133
X  #define GADOSHOWEXP	134
X  #define GADOSHOWSCORE	135
X+ #define	GADONAME	136
X+ #define	GADOSCORE	137
X+ #define	GADOPALETTE	138
X+ #define	GADOWINDOWTYPE	139
X+ #define	GADOMSGHISTORY	140
X+ #define	GADOPICKUPTYPES	141
X+ #define	GADOPETTYPE	142
X  
X  /* Definition of workbench size layout */
X  
X***************
X*** 165,176 ****
X  #define RstOld		(Sbuff(&Rst_RestOld))
X  #define RstNew		(Sbuff(&Rst_RestNew))
X  
X- #define DefPlayerName	(Sbuff(&Defs_PlayerName))
X- #define DefOutFile	(Sbuff(&Defs_DefaultName))
X- 
X  #define StrString	(Sbuff(&Str_String))
X  
X  #define StrTools	(Sbuff(&Info_ToolTypes))
X  
X  #define GAMEIMAGE	"HackExe:NetHack"
X  #define GAMESTACK	50000
X--- 169,178 ----
X  #define RstOld		(Sbuff(&Rst_RestOld))
X  #define RstNew		(Sbuff(&Rst_RestNew))
X  
X  #define StrString	(Sbuff(&Str_String))
X  
X  #define StrTools	(Sbuff(&Info_ToolTypes))
X+ #define StrPlayer	(Sbuff(&Info_Player))
X  
X  #define GAMEIMAGE	"HackExe:NetHack"
X  #define GAMESTACK	50000
X***************
X*** 210,215 ****
X  
X  #define NO_FLASH	0
X  #define FLASH		1
X- 
X- #define GAME_FROM_DEFAULT   0
X- #define GAME_FROM_INFO      1
X--- 212,214 ----
X*** /tmp/da11992	Tue Jun  1 17:01:24 1993
X--- sys/amiga/wbprotos.h	Mon May 24 11:12:34 1993
X***************
X*** 23,29 ****
X  void getline P(( FILE *fp , long *offarr , int which , char *buf , int size ));
X  void help_requester P(( char *file ));
X  void do_closewindow P(( void ));
X! void do_menu P(( int mcode ));
X  void menu_discard P(( void ));
X  void menu_copyopt P(( void ));
X  void menu_rename P(( void ));
X--- 23,29 ----
X  void getline P(( FILE *fp , long *offarr , int which , char *buf , int size ));
X  void help_requester P(( char *file ));
X  void do_closewindow P(( void ));
X! void do_menu P(( struct Menu *mptr, int mcode ));
X  void menu_discard P(( void ));
X  void menu_copyopt P(( void ));
X  void menu_rename P(( void ));
X***************
X*** 34,39 ****
X--- 34,40 ----
X  void SafeCloseWindow P(( struct Window *window ));
X  GPTR AllocGITEM P(( void ));
X  void FreeGITEM P(( GPTR gptr ));
X+ void RemoveGITEM P(( GPTR ));
X  struct DiskObject *AllocDObj P(( char *str ));
X  void FreeDObj P(( struct DiskObject *doptr ));
X  void LoadIcons P(( void ));
X***************
X*** 45,51 ****
X  void do_buttons P(( struct IntuiMessage *imsg ));
X  void do_gadgetdown P(( struct IntuiMessage *imsg ));
X  int ask_request P(( char *str ));
X! void menu_setopt P(( void ));
X  void menu_info P(( void ));
X  int IsEditEntry P(( char *, GPTR ));
X  void menu_comment P(( void ));
X--- 46,52 ----
X  void do_buttons P(( struct IntuiMessage *imsg ));
X  void do_gadgetdown P(( struct IntuiMessage *imsg ));
X  int ask_request P(( char *str ));
X! void setopt P(( GPTR ));
X  void menu_info P(( void ));
X  int IsEditEntry P(( char *, GPTR ));
X  void menu_comment P(( void ));
X***************
X*** 75,81 ****
X  GPTR NeedGame P(( void ));
X  void ChgGameItems P(( struct Menu *menup , int enable ));
X  void ChgNewGameItems P(( struct Menu *menup , int enable ));
X! int EditOptions P(( OPTR optr ));
X  struct Gadget *FindGadget P(( struct Window *window ,
X      struct NewWindow *newwindow , int id ));
X  void ZapOptions P(( OPTR optr ));
X--- 76,82 ----
X  GPTR NeedGame P(( void ));
X  void ChgGameItems P(( struct Menu *menup , int enable ));
X  void ChgNewGameItems P(( struct Menu *menup , int enable ));
X! int EditOptions P(( OPTR optr, GPTR gptr ));
X  struct Gadget *FindGadget P(( struct Window *window ,
X      struct NewWindow *newwindow , int id ));
X  void ZapOptions P(( OPTR optr ));
X*** /tmp/da12000	Tue Jun  1 17:01:26 1993
X--- sys/amiga/wbstruct.h	Mon May  3 13:33:32 1993
X***************
X*** 42,51 ****
X  				 * options value.
X  				 */
X  } OPTIONS, *OPTR;
X- 
X- typedef struct DEFAULTS
X- {
X-     int pltype;			/* Character class */
X-     char *plname;		/* Players name */
X-     char *options;		/* Preferred options string */
X- } DEFAULTS;
X--- 42,44 ----
X*** /tmp/da12032	Tue Jun  1 17:01:51 1993
X--- sys/amiga/winami.p	Tue Apr 13 15:41:59 1993
X***************
X*** 40,46 ****
X  void FDECL(DisplayData, (int  , int  , int ));
X  void FDECL(SetPropInfo, (struct Window * , struct Gadget * , long  , long  , long ));
X  void FDECL(kill_nhwindows, (int ));
X! void FDECL(amii_cl_end, (struct WinDesc * , int ));
X  void FDECL(cursor_off, (winid ));
X  void FDECL(cursor_on, (winid ));
X  void NDECL(amii_getret );
X--- 40,46 ----
X  void FDECL(DisplayData, (int  , int  , int ));
X  void FDECL(SetPropInfo, (struct Window * , struct Gadget * , long  , long  , long ));
X  void FDECL(kill_nhwindows, (int ));
X! void FDECL(amii_cl_end, (struct amii_WinDesc * , int ));
X  void FDECL(cursor_off, (winid ));
X  void FDECL(cursor_on, (winid ));
X  void NDECL(amii_getret );
X***************
X*** 55,57 ****
X--- 55,58 ----
X  void NDECL( amii_setpens );
X  void FDECL( SetBorder, (struct Gadget *) );
X  void NDECL( port_help );
X+ void FDECL( dismiss_nhwindow, (winid) );
END_OF_FILE
if test 54798 -ne `wc -c <'patches02l'`; then
    echo shar: \"'patches02l'\" unpacked with wrong size!
fi
# end of 'patches02l'
if test -f 'sys/amiga/windefs.h' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'sys/amiga/windefs.h'\" to \"'sys/amiga/windefs.h.orig'\"
  mv -f 'sys/amiga/windefs.h' 'sys/amiga/windefs.h.orig'
fi
echo shar: Extracting \"'sys/amiga/windefs.h'\" \(3533 characters\)
sed "s/^X//" >'sys/amiga/windefs.h' <<'END_OF_FILE'
X/*    SCCS Id: @(#)windefs.h    3.1    93/04/02 */
X/* Copyright (c) Gregg Wonderly, Naperville, Illinois,  1991,1992,1993. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X/* These should probably not even be options, but, I will leave them
X * for now... GGW
X */
X
X#include "hack.h"
X#include "wintype.h"
X#include "winami.h"
X#include "func_tab.h"
X
X/*#define   TOPL_GETLINE	/* Don't use a window for getlin() */
X/*#define   WINDOW_YN		/* Use a window for y/n questions */
X
X#include <exec/types.h>
X#include <exec/memory.h>
X#include <exec/io.h>
X#include <dos.h>
X#include <exec/alerts.h>
X#include <exec/devices.h>
X#include <exec/execbase.h>
X#include <devices/console.h>
X#include <devices/conunit.h>
X#include <graphics/gfxbase.h>
X#include <intuition/intuition.h>
X#include <intuition/intuitionbase.h>
X#include <libraries/dosextens.h>
X#include <ctype.h>
X#undef  strcmpi
X#include <string.h>
X#include <errno.h>
X
X#ifdef  IDCMP_CLOSEWINDOW
X# ifndef	INTUI_NEW_LOOK
X#  define	INTUI_NEW_LOOK
X# endif
X#endif
X
X#ifdef AZTEC_C
X#include <functions.h>
X#else
X#include <proto/dos.h>
X#include <proto/exec.h>
X#include <proto/console.h>
X#ifdef	VIEWWINDOW
X#include <proto/layers.h>
X#endif
X#include <proto/diskfont.h>
X
X/* kludge - see amirip for why */
X# undef red
X# undef green
X# undef blue
X# include <proto/graphics.h>
X
X#ifndef __SASC_60
X#undef index
X# define index strchr
X#endif
X
X#include <proto/intuition.h>
X#endif
X
X#ifdef	SHAREDLIB
X#include "amiga:lib/libmacs.h"
X#endif
X
X/* cw->data[x] contains 2 characters worth of special information.  These
X * characters are stored at the offsets as described here.
X */
X#define VATTR	  0	/* Video attribute is in this slot */
X#define SEL_ITEM  1	/* If this is a select item, slot is 1 else 0 */
X#define SOFF	  2	/* The string starts here.  */
X
X/* Nethack defines NULL as ((char *)0) which is very inconvienent... */
X#undef NULL
X#define NULL 0L
X
X/*
X * Versions we need of various libraries.  We can't use LIBRARY_VERSION
X * as defined in <exec/types.h> because some of the libraries we need
X * don't have that version number in the 1.2 ROM.
X */
X
X#define INTUITION_VERSION	33L
X#define GRAPHICS_VERSION	33L
X#define DISKFONT_VERSION	34L
X#define ICON_VERSION		34L
X
X/* These values are just sorta suggestions in use, but are minimum requirements
X * in reality...
X */
X#define WINDOWHEIGHT	192
X#define SCREENHEIGHT	200
X#define WIDTH		640
X
X/* This character is a solid block (cursor) in Hack.font */
X#define CURSOR_CHAR	0x90
X
X#define FONTHEIGHT	8
X#define FONTWIDTH	8
X#define FONTBASELINE	8
X
X#ifdef	VIEWWINDOW
X#define MAPFTWIDTH	4
X#define MAPFTHEIGHT	4
X#define MAPFTBASELN	3
X#define VIEWCHARWIDTH	16	/* Each square is 16 pixels wide */
X#define VIEWCHARHEIGHT	16	/* Each square is 16 pixels tall */
X#else
X#define MAPFTWIDTH	8
X#define MAPFTHEIGHT	8
X#define MAPFTBASELN	6
X#endif
X
X/* If Compiling with the "New Look", redefine these now */
X#ifdef  INTUI_NEW_LOOK
X#define NewWindow ExtNewWindow
X#define NewScreen ExtNewScreen
X#endif
X
X#define         SIZEOF_DISKNAME 8
X
X#define CSI     '\x9b'
X#define NO_CHAR     -1
X#define RAWHELP     0x5F    /* Rawkey code of the HELP key */
X
X#define C_BLACK		0
X#define C_WHITE		1
X#define C_BROWN		2
X#define C_CYAN		3
X#define C_GREEN		4
X#define C_MAGENTA	5
X#define C_BLUE		6
X#define C_RED		7
X#ifdef	VIEWWINDOW
X#define C_VBLACK0	8
X#define C_VBLACK1	9
X#define C_VBLACK2	10
X#define C_VBLACK3	11
X#define C_VBLACK4	12
X#define C_VBLACK5	13
X#define C_VBLACK6	14
X#define C_VBLACK7	15
X#endif
X
X/* topl kludges */
X#define TOPL_NOSPACE	topl_addspace=0
X#define TOPL_SPACE	topl_addspace=1
END_OF_FILE
if test 3533 -ne `wc -c <'sys/amiga/windefs.h'`; then
    echo shar: \"'sys/amiga/windefs.h'\" unpacked with wrong size!
fi
# end of 'sys/amiga/windefs.h'
echo shar: End of archive 13 \(of 33\).
cp /dev/null ark13isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 33 archives.
    echo "Now execute ./patchit.sh"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
