Path: uunet!news.tek.com!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v17i086:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Patch2k/33
Date: 11 Jun 1993 00:10:11 GMT
Organization: Tektronix, Inc, Redmond, OR, USA
Lines: 2079
Approved: billr@saab.CNA.TEK.COM
Message-ID: <1v8ih3$j0s@ying.cna.tek.com>
NNTP-Posting-Host: saab.cna.tek.com
Xref: uunet comp.sources.games:1774

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 17, Issue 86
Archive-name: nethack31/Patch2k
Patch-To: nethack31: Volume 16, Issue 1-116
Environment: Amiga, Atari, Mac, MS-DOS, Windows-NT, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 11 (of 33)."
# Contents:  patches02h
# Wrapped by billr@saab on Thu Jun 10 16:55:02 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'patches02h' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'patches02h'\" to \"'patches02h.orig'\"
  mv -f 'patches02h' 'patches02h.orig'
fi
echo shar: Extracting \"'patches02h'\" \(55125 characters\)
sed "s/^X//" >'patches02h' <<'END_OF_FILE'
X*** /tmp/da11330	Tue Jun  1 16:15:37 1993
X--- src/rip.c	Tue Apr 27 17:00:24 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)rip.c	3.1	91/08/05
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)rip.c	3.1	93/04/26	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 8,13 ****
X--- 8,15 ----
X  
X  extern const char *killed_by_prefix[];
X  
X+ #if defined(TTY_GRAPHICS) || defined(X11_GRAPHICS) || defined(mac)
X+ 
X  static const char *rip_txt[] = {
X  "                       ----------",
X  "                      /          \\",
X***************
X*** 49,58 ****
X  	while(*ip) *op++ = *ip++;
X  }
X  
X  void
X! outrip(how, tmpwin)
X! int how;
X  winid tmpwin;
X  {
X  	register char **dp;
X  	register char *dpx;
X--- 51,61 ----
X  	while(*ip) *op++ = *ip++;
X  }
X  
X+ 
X  void
X! genl_outrip(tmpwin, how)
X  winid tmpwin;
X+ int how;
X  {
X  	register char **dp;
X  	register char *dpx;
X***************
X*** 126,130 ****
X--- 129,135 ----
X  	putstr(tmpwin, 0, "");
X  	putstr(tmpwin, 0, "");
X  }
X+ 
X+ #endif
X  
X  /*rip.c*/
X*** /tmp/da11354	Tue Jun  1 16:15:42 1993
X--- src/save.c	Fri May 28 11:32:09 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)save.c	3.1	93/02/09	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)save.c	3.1	93/05/26	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 31,37 ****
X  #endif
X  
X  #ifdef ZEROCOMP
X! static void FDECL(bputc, (UCHAR_P));
X  #endif
X  static void FDECL(savelevchn, (int, int));
X  static void FDECL(savedamage, (int,struct damage *, int));
X--- 31,37 ----
X  #endif
X  
X  #ifdef ZEROCOMP
X! static void FDECL(bputc, (int));
X  #endif
X  static void FDECL(savelevchn, (int, int));
X  static void FDECL(savedamage, (int,struct damage *, int));
X***************
X*** 138,149 ****
X  	if(flags.window_inited)
X  	    clear_nhwindow(WIN_MESSAGE);
X  
X! #ifdef MFLOPPY
X  	if(!hu) {
X  	    dotcnt = 0;
X  	    curs(WIN_MAP, 1, 1);
X  	    putstr(WIN_MAP, 0, "Saving:");
X  	}
X  	/* make sure there is enough disk space */
X  	savelev(fd, ledger_no(&u.uz), COUNT_SAVE);
X  	savegamestate(fd, COUNT_SAVE);
X--- 138,151 ----
X  	if(flags.window_inited)
X  	    clear_nhwindow(WIN_MESSAGE);
X  
X! #ifdef MICRO
X  	if(!hu) {
X  	    dotcnt = 0;
X  	    curs(WIN_MAP, 1, 1);
X  	    putstr(WIN_MAP, 0, "Saving:");
X  	}
X+ #endif
X+ #ifdef MFLOPPY
X  	/* make sure there is enough disk space */
X  	savelev(fd, ledger_no(&u.uz), COUNT_SAVE);
X  	savegamestate(fd, COUNT_SAVE);
X***************
X*** 383,389 ****
X  	    struct rm *prm, *rgrm;
X  	    int x, y;
X  	    uchar match;
X! 	    
X  	    rgrm = &levl[0][0];		/* start matching at first rm */
X  	    match = 0;
X  
X--- 385,391 ----
X  	    struct rm *prm, *rgrm;
X  	    int x, y;
X  	    uchar match;
X! 
X  	    rgrm = &levl[0][0];		/* start matching at first rm */
X  	    match = 0;
X  
X***************
X*** 412,418 ****
X  			bwrite(fd, (genericptr_t)rgrm, sizeof(struct rm));
X  			/* start encoding again. we have at least 1 rm
X  			 * in the next run, viz. this one. */
X! 			match = 1;	
X  			rgrm = prm;
X  		    }
X  		}
X--- 414,420 ----
X  			bwrite(fd, (genericptr_t)rgrm, sizeof(struct rm));
X  			/* start encoding again. we have at least 1 rm
X  			 * in the next run, viz. this one. */
X! 			match = 1;
X  			rgrm = prm;
X  		    }
X  		}
X***************
X*** 439,444 ****
X--- 441,447 ----
X  	save_worm(fd, mode);	/* save worm information */
X  	savetrapchn(fd, ftrap, mode);
X  	saveobjchn(fd, fobj, mode);
X+ 	saveobjchn(fd, level.buriedobjlist, mode);
X  	saveobjchn(fd, billobjs, mode);
X  
X  	save_engravings(fd, mode);
X***************
X*** 481,487 ****
X  
X  static void
X  bputc(c)
X! unsigned char c;
X  {
X  #ifdef MFLOPPY
X      bytes_counted++;
X--- 484,490 ----
X  
X  static void
X  bputc(c)
X! int c;
X  {
X  #ifdef MFLOPPY
X      bytes_counted++;
X***************
X*** 492,498 ****
X  	(void) write(bwritefd, outbuf, sizeof outbuf);
X  	outbufp = 0;
X      }
X!     outbuf[outbufp++] = c;
X  }
X  
X  /*ARGSUSED*/
X--- 495,501 ----
X  	(void) write(bwritefd, outbuf, sizeof outbuf);
X  	outbufp = 0;
X      }
X!     outbuf[outbufp++] = (unsigned char)c;
X  }
X  
X  /*ARGSUSED*/
X***************
X*** 499,504 ****
X--- 502,510 ----
X  void
X  bufon(fd)
X      int fd;
X+ #if defined(applec)
X+ # pragma unused(fd)
X+ #endif
X  {
X      return;
X  }
X***************
X*** 523,545 ****
X  
X  void
X  bwrite(fd, loc, num)
X! register int fd;
X  genericptr_t loc;
X  register unsigned num;
X  {
X!       bwritefd = fd;
X!       for (; num; num--, (*(char **)&loc)++) {
X! 	      if (*((char *)loc) == RLESC) { /* One more char in run */
X! 		  if (++outrunlength == 0xFF) {
X! 		      flushoutrun(outrunlength);
X! 		  }
X! 	      } else { /* end of run */
X! 		  if (outrunlength >= 0) {    /* flush run */
X! 		      flushoutrun(outrunlength);
X! 		  }
X! 		  bputc(*((char *)loc));
X! 	      }
X!       }
X  }
X  
X  void
X--- 529,553 ----
X  
X  void
X  bwrite(fd, loc, num)
X! int fd;
X  genericptr_t loc;
X  register unsigned num;
X  {
X! 	register unsigned char *bp = (unsigned char *)loc;
X! 
X! 	bwritefd = fd;
X! 	for (; num; num--, bp++) {
X! 	    if (*bp == RLESC) {	/* One more char in run */
X! 		if (++outrunlength == 0xFF) {
X! 		    flushoutrun(outrunlength);
X! 		}
X! 	    } else {		/* end of run */
X! 		if (outrunlength >= 0) {	/* flush run */
X! 		    flushoutrun(outrunlength);
X! 		}
X! 		bputc(*bp);
X! 	    }
X! 	}
X  }
X  
X  void
X***************
X*** 686,692 ****
X  	    bwrite(fd, (genericptr_t) &xl, sizeof(int));
X  	    bwrite(fd, (genericptr_t) otmp, xl + sizeof(struct obj));
X  
X! 	    if (Is_container(otmp) || otmp->otyp == STATUE)
X  		saveobjchn(fd,otmp->cobj,mode);
X  	    if (mode & FREE_SAVE) {
X  		if(otmp->oclass == FOOD_CLASS) food_disappears(otmp);
X--- 694,700 ----
X  	    bwrite(fd, (genericptr_t) &xl, sizeof(int));
X  	    bwrite(fd, (genericptr_t) otmp, xl + sizeof(struct obj));
X  
X! 	    if (Has_contents(otmp))
X  		saveobjchn(fd,otmp->cobj,mode);
X  	    if (mode & FREE_SAVE) {
X  		if(otmp->oclass == FOOD_CLASS) food_disappears(otmp);
X***************
X*** 711,719 ****
X  
X  	while(mtmp) {
X  		mtmp2 = mtmp->nmon;
X- #ifdef MUSE
X- 		if (mtmp->mw && mtmp->mw != mtmp->minvent) sort_mwep(mtmp);
X- #endif
X  		xl = mtmp->mxlth + mtmp->mnamelth;
X  		bwrite(fd, (genericptr_t) &xl, sizeof(int));
X  		bwrite(fd, (genericptr_t) mtmp, xl + sizeof(struct monst));
X--- 719,724 ----
X*** /tmp/da11362	Tue Jun  1 16:15:45 1993
X--- src/shk.c	Tue Jun  1 10:42:27 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)shk.c	3.1	93/02/09	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)shk.c	3.1	93/05/19	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 59,64 ****
X--- 59,65 ----
X  				      BOOLEAN_P));
X  static void FDECL(bill_box_content, (struct obj *, BOOLEAN_P, BOOLEAN_P,
X  				     struct monst *));
X+ static void FDECL(shk_names_obj, (struct obj *));
X  
X  /*
X  	invariants: obj->unpaid iff onbill(obj) [unless bp->useup]
X***************
X*** 128,134 ****
X  replshk(mtmp,mtmp2)
X  register struct monst *mtmp, *mtmp2;
X  {
X! 	if(inhishop(mtmp) && *u.ushops == ESHK(mtmp)->shoproom) {
X  		ESHK(mtmp2)->bill_p = &(ESHK(mtmp2)->bill[0]);
X  	}
X  }
X--- 129,136 ----
X  replshk(mtmp,mtmp2)
X  register struct monst *mtmp, *mtmp2;
X  {
X! 	rooms[ESHK(mtmp2)->shoproom - ROOMOFFSET].resident = mtmp2;
X! 	if (inhishop(mtmp) && *u.ushops == ESHK(mtmp)->shoproom) {
X  		ESHK(mtmp2)->bill_p = &(ESHK(mtmp2)->bill[0]);
X  	}
X  }
X***************
X*** 155,161 ****
X  register struct obj *list;
X  {
X      while (list) {
X! 	if (Is_container(list)) clear_unpaid(list->cobj);
X  	list->unpaid = 0;
X  	list = list->nobj;
X      }
X--- 157,163 ----
X  register struct obj *list;
X  {
X      while (list) {
X! 	if (Has_contents(list)) clear_unpaid(list->cobj);
X  	list->unpaid = 0;
X  	list = list->nobj;
X      }
X***************
X*** 170,175 ****
X--- 172,178 ----
X  
X  	clear_unpaid(invent);
X  	clear_unpaid(fobj);
X+ 	clear_unpaid(level.buriedobjlist);
X  	for(mtmp = fmon; mtmp; mtmp = mtmp->nmon)
X  		clear_unpaid(mtmp->minvent);
X  	for(mtmp = migrating_mons; mtmp; mtmp = mtmp->nmon)
X***************
X*** 303,314 ****
X  	if(!eshkp->billct && !eshkp->debit)	/* bill is settled */
X  	    return;
X  
X! 	if(!*leavestring) {
X  	    /*
X  	     * Player just stepped onto shop-boundary (known from above logic).
X  	     * Try to intimidate him into paying his bill
X  	     */
X- 
X  	    verbalize(NOTANGRY(shkp) ?
X  		      "%s!  Please pay before leaving." :
X  		      "%s!  Don't you leave without paying!",
X--- 306,316 ----
X  	if(!eshkp->billct && !eshkp->debit)	/* bill is settled */
X  	    return;
X  
X! 	if (!*leavestring && shkp->mcanmove && !shkp->msleep) {
X  	    /*
X  	     * Player just stepped onto shop-boundary (known from above logic).
X  	     * Try to intimidate him into paying his bill
X  	     */
X  	    verbalize(NOTANGRY(shkp) ?
X  		      "%s!  Please pay before leaving." :
X  		      "%s!  Don't you leave without paying!",
X***************
X*** 315,327 ****
X  		      plname);
X  	    return;
X  	}
X- 		/* by this point, we know an actual robbery has taken place */
X- 	You("escaped the shop without paying!");
X  	total = (addupbill(shkp) + eshkp->debit);
X! 	eshkp->robbed += total;
X! 	eshkp->credit = 0L;
X! 	eshkp->debit = 0L;
X  	setpaid(shkp);
X  	You("stole %ld zorkmid%s worth of merchandise.",
X  	    total, plur(total));
X  	if (pl_character[0] != 'R') /* stealing is unlawful */
X--- 317,336 ----
X  		      plname);
X  	    return;
X  	}
X  	total = (addupbill(shkp) + eshkp->debit);
X! 	if (eshkp->credit >= total) {
X! 	    Your("credit of %ld zorkmid%s is used to cover your shopping bill.",
X! 		 eshkp->credit, plur(eshkp->credit));
X! 	    total = 0L;		/* credit gets cleared by setpaid() */
X! 	} else {
X! 	    You("escaped the shop without paying!");
X! 	    total -= eshkp->credit;
X! 	}
X  	setpaid(shkp);
X+ 	if (!total) return;
X+ 
X+ 	/* by this point, we know an actual robbery has taken place */
X+ 	eshkp->robbed += total;
X  	You("stole %ld zorkmid%s worth of merchandise.",
X  	    total, plur(total));
X  	if (pl_character[0] != 'R') /* stealing is unlawful */
X***************
X*** 381,387 ****
X  	    pacify_shk(shkp);
X  	}
X  
X! 	if (eshkp->following)
X  	    return;
X  
X  	if (Invis) {
X--- 390,396 ----
X  	    pacify_shk(shkp);
X  	}
X  
X! 	if (shkp->msleep || !shkp->mcanmove || eshkp->following) /* no dialog */
X  	    return;
X  
X  	if (Invis) {
X***************
X*** 398,405 ****
X  		      s_suffix(shkname(shkp)),
X  		      shtypes[rt - SHOPBASE].name);
X  	} else if (eshkp->robbed) {
X! 	    verbalize("Beware, %s!  I am upset about missing stock!",
X! 		      plname);
X  	} else {
X  	    verbalize("Hello, %s!  Welcome%s to %s %s!",
X  		      plname,
X--- 407,413 ----
X  		      s_suffix(shkname(shkp)),
X  		      shtypes[rt - SHOPBASE].name);
X  	} else if (eshkp->robbed) {
X! 	    pline("%s mutters imprecations against shoplifters.", shkname(shkp));
X  	} else {
X  	    verbalize("Hello, %s!  Welcome%s to %s %s!",
X  		      plname,
X***************
X*** 418,423 ****
X--- 426,461 ----
X  	return;
X  }
X  
X+ /*
X+    Decide whether two unpaid items are mergable; caller is responsible for
X+    making sure they're unpaid and the same type of object; we check the price
X+    quoted by the shopkeeper and also that they both belong to the same shk.
X+  */
X+ boolean same_price(obj1, obj2)
X+ struct obj *obj1, *obj2;
X+ {
X+ 	register struct monst *shkp1, *shkp2;
X+ 	register struct bill_x *bp1 = 0, *bp2 = 0;
X+ 	register boolean are_mergable = FALSE;
X+ 
X+ 	/* look up the first object by finding shk whose bill it's on */
X+ 	for (shkp1 = next_shkp(fmon, TRUE); shkp1;
X+ 		shkp1 = next_shkp(shkp1, TRUE))
X+ 	    if ((bp1 = onbill(obj1, shkp1, TRUE)) != 0) break;
X+ 	/* second object is probably owned by same shk; if not, look harder */
X+ 	if (shkp1 && (bp2 = onbill(obj2, shkp1, TRUE)) != 0) {
X+ 	    shkp2 = shkp1;
X+ 	} else {
X+ 	    for (shkp2 = next_shkp(fmon, TRUE); shkp2;
X+ 		    shkp2 = next_shkp(shkp2, TRUE))
X+ 		if ((bp2 = onbill(obj2, shkp2, TRUE)) != 0) break;
X+ 	}
X+ 
X+ 	if (!bp1 || !bp2) impossible("same_price: object wasn't on any bill!");
X+ 	else are_mergable = (shkp1 == shkp2 && bp1->price == bp2->price);
X+ 	return are_mergable;
X+ }
X+ 
X  #endif /* OVL1 */
X  #ifdef OVLB
X  
X***************
X*** 830,835 ****
X--- 868,879 ----
X  		return(0);
X  	}
X  proceed:
X+ 
X+ 	if (shkp->msleep || !shkp->mcanmove) {
X+ 		pline("%s %s.", Monnam(shkp),
X+ 		      rn2(2) ? "seems to be napping" : "doesn't respond");
X+ 		return 0;
X+ 	}
X  	eshkp = ESHK(shkp);
X  
X  	ltmp = eshkp->robbed;
X***************
X*** 1115,1120 ****
X--- 1159,1165 ----
X  	}
X  
X  	pay(ltmp, shkp);
X+ 	shk_names_obj(obj);	/* identify some non-magic objects */
X  	You("bought %s for %ld gold piece%s.",
X  		doname(obj), ltmp, plur(ltmp));
X  	obj->quan = save_quan;		/* restore original count */
X***************
X*** 1194,1200 ****
X  	if(numsk > 1) {
X  	    if(cansee(shkp->mx, shkp->my) && croaked)
X  		pline("%s %slooks at your corpse%s%s", Monnam(shkp),
X! 		     (shkp->msleep || shkp->mfrozen) ?
X  				   "wakes up, " : "",
X  		     !rn2(2) ? (shkp->female ? ", shakes her head," :
X  				 ", shakes his head,") : "",
X--- 1239,1245 ----
X  	if(numsk > 1) {
X  	    if(cansee(shkp->mx, shkp->my) && croaked)
X  		pline("%s %slooks at your corpse%s%s", Monnam(shkp),
X! 		     (shkp->msleep || !shkp->mcanmove) ?
X  				   "wakes up, " : "",
X  		     !rn2(2) ? (shkp->female ? ", shakes her head," :
X  				 ", shakes his head,") : "",
X***************
X*** 1231,1237 ****
X  		if((loss > u.ugold) || !loss) {
X  			pline("%s %s%stakes all your possessions.",
X  				shkname(shkp),
X! 				(shkp->msleep || shkp->mfrozen) ?
X  				   "wakes up and " : "",
X  				(distu(shkp->mx, shkp->my) > 2) ?
X  				    "comes and " : "");
X--- 1276,1282 ----
X  		if((loss > u.ugold) || !loss) {
X  			pline("%s %s%stakes all your possessions.",
X  				shkname(shkp),
X! 				(shkp->msleep || !shkp->mcanmove) ?
X  				   "wakes up and " : "",
X  				(distu(shkp->mx, shkp->my) > 2) ?
X  				    "comes and " : "");
X***************
X*** 1272,1278 ****
X  			shkp->mgold += loss;
X  			pline("%s %sand takes %ld zorkmid%s %sowed %s.",
X  			      Monnam(shkp),
X! 			      (shkp->msleep || shkp->mfrozen) ?
X  					"wakes up " : "comes ",
X  			      loss, plur(loss),
X  			      strncmp(eshkp->customer,
X--- 1317,1323 ----
X  			shkp->mgold += loss;
X  			pline("%s %sand takes %ld zorkmid%s %sowed %s.",
X  			      Monnam(shkp),
X! 			      (shkp->msleep || !shkp->mcanmove) ?
X  					"wakes up " : "comes ",
X  			      loss, plur(loss),
X  			      strncmp(eshkp->customer,
X***************
X*** 1302,1307 ****
X--- 1347,1353 ----
X  		obj = o_on(id, billobjs);
X  	else if(!(obj = o_on(id, invent)) &&
X  		!(obj = o_on(id, fobj)) &&
X+ 		!(obj = o_on(id, level.buriedobjlist)) &&
X  		!(obj = o_on(id, migrating_objs))) {
X  		    for (mtmp = fmon; mtmp; mtmp = mtmp->nmon)
X  			if ((obj = o_on(id, mtmp->minvent)) != 0)
X***************
X*** 1385,1391 ****
X  		    price += get_cost(otmp, shkp);
X  	    }
X  
X! 	    if(Is_container(otmp))
X  		    price += contained_cost(otmp, shkp, price, usell);
X  	}
X  
X--- 1431,1437 ----
X  		    price += get_cost(otmp, shkp);
X  	    }
X  
X! 	    if (Has_contents(otmp))
X  		    price += contained_cost(otmp, shkp, price, usell);
X  	}
X  
X***************
X*** 1403,1409 ****
X  	for (otmp = obj->cobj; otmp; otmp = otmp->nobj)
X  	    if (otmp->oclass == GOLD_CLASS)
X  		value += otmp->quan;
X! 	    else if (Is_container(otmp))
X  		value += contained_gold(otmp);
X  
X  	return(value);
X--- 1449,1455 ----
X  	for (otmp = obj->cobj; otmp; otmp = otmp->nobj)
X  	    if (otmp->oclass == GOLD_CLASS)
X  		value += otmp->quan;
X! 	    else if (Has_contents(otmp))
X  		value += contained_gold(otmp);
X  
X  	return(value);
X***************
X*** 1429,1435 ****
X  	    if(!otmp->unpaid && !(sale && saleitem))
X  		otmp->no_charge = 1;
X  
X! 	    if(Is_container(otmp))
X  		dropped_container(otmp, shkp, sale);
X  	}
X  }
X--- 1475,1481 ----
X  	    if(!otmp->unpaid && !(sale && saleitem))
X  		otmp->no_charge = 1;
X  
X! 	    if (Has_contents(otmp))
X  		dropped_container(otmp, shkp, sale);
X  	}
X  }
X***************
X*** 1448,1454 ****
X  	    if(otmp->no_charge)
X  		otmp->no_charge = 0;
X  
X! 	    if(Is_container(otmp))
X  		picked_container(otmp);
X  	}
X  }
X--- 1494,1500 ----
X  	    if(otmp->no_charge)
X  		otmp->no_charge = 0;
X  
X! 	    if (Has_contents(otmp))
X  		picked_container(otmp);
X  	}
X  }
X***************
X*** 1563,1574 ****
X  		/* the "top" box is added in addtobill() */
X  		if(!otmp->no_charge)
X  		    add_one_tobill(otmp, dummy);
X! 		if(Is_container(otmp))
X  		    bill_box_content(otmp, ininv, dummy, shkp);
X  	}
X  
X  }
X  
X  void
X  addtobill(obj, ininv, dummy, silent)
X  register struct obj *obj;
X--- 1609,1635 ----
X  		/* the "top" box is added in addtobill() */
X  		if(!otmp->no_charge)
X  		    add_one_tobill(otmp, dummy);
X! 		if (Has_contents(otmp))
X  		    bill_box_content(otmp, ininv, dummy, shkp);
X  	}
X  
X  }
X  
X+ static void
X+ shk_names_obj(obj)
X+ register struct obj *obj;
X+ /* shopkeeper tells you what an object is */
X+ {
X+ 	obj->dknown = TRUE;
X+ 	/* use real name for ordinary weapons/armor, and spell-less
X+ 	 * scrolls/books (that is, blank and mail).
X+ 	 */
X+ 	if (!objects[obj->otyp].oc_magic &&
X+ 	    (obj->oclass == WEAPON_CLASS || obj->oclass == ARMOR_CLASS ||
X+ 	     obj->oclass == SCROLL_CLASS || obj->oclass == SPBOOK_CLASS))
X+ 	    makeknown(obj->otyp);
X+ }
X+ 
X  void
X  addtobill(obj, ininv, dummy, silent)
X  register struct obj *obj;
X***************
X*** 1577,1583 ****
X  	register struct monst *shkp;
X  	register char roomno = *u.ushops;
X  	long ltmp = 0L, cltmp = 0L, gltmp = 0L;
X! 	register boolean container = Is_container(obj);
X  
X  	if(!*u.ushops) return;
X  
X--- 1638,1644 ----
X  	register struct monst *shkp;
X  	register char roomno = *u.ushops;
X  	long ltmp = 0L, cltmp = 0L, gltmp = 0L;
X! 	register boolean container = Has_contents(obj);
X  
X  	if(!*u.ushops) return;
X  
X***************
X*** 1639,1645 ****
X  	} else /* i.e., !container */
X  	    add_one_tobill(obj, dummy);
X  speak:
X! 	if(!shkp->msleep && !shkp->mfrozen && !silent) {
X  	    char buf[BUFSZ];
X  
X  	    if(!ltmp) {
X--- 1700,1706 ----
X  	} else /* i.e., !container */
X  	    add_one_tobill(obj, dummy);
X  speak:
X! 	if (shkp->mcanmove && !shkp->msleep && !silent) {
X  	    char buf[BUFSZ];
X  
X  	    if(!ltmp) {
X***************
X*** 1650,1667 ****
X  	    Strcpy(buf, "\"For you, ");
X  	    if (ANGRY(shkp)) Strcat(buf, "scum ");
X  	    else {
X! 		switch(rnd(4) + u.uevent.udemigod) {
X! 		  case 1: Strcat(buf, "good");
X! 			  break;
X! 		  case 2: Strcat(buf, "honored");
X! 			  break;
X! 		  case 3: Strcat(buf, "most gracious");
X! 			  break;
X! 		  case 4: Strcat(buf, "esteemed");
X! 			  break;
X! 		  case 5: Strcat(buf, "most renowned and sacred");
X! 			  break;
X! 		}
X  #ifdef POLYSELF
X  		if(!is_human(uasmon)) Strcat(buf, " creature");
X  		else
X--- 1711,1721 ----
X  	    Strcpy(buf, "\"For you, ");
X  	    if (ANGRY(shkp)) Strcat(buf, "scum ");
X  	    else {
X! 		static const char *honored[5] = {
X! 		  "good", "honored", "most gracious", "esteemed",
X! 		  "most renowned and sacred"
X! 		};
X! 		Strcat(buf, honored[rn2(4) + u.uevent.udemigod]);
X  #ifdef POLYSELF
X  		if(!is_human(uasmon)) Strcat(buf, " creature");
X  		else
X***************
X*** 1668,1676 ****
X  #endif
X  		    Strcat(buf, (flags.female) ? " lady" : " sir");
X  	    }
X- 	    /* after all, the shk is telling you what it is */
X- 	    obj->dknown = 1;
X- 	    exercise(A_WIS, TRUE);
X  	    if(ininv) {
X  		long quan = obj->quan;
X  		obj->quan = 1L; /* fool xname() into giving singular */
X--- 1722,1727 ----
X***************
X*** 1777,1787 ****
X  
X  	sub_one_frombill(obj, shkp);
X  
X! 	if(Is_container(obj))
X  	    for(otmp = obj->cobj; otmp; otmp = otmp->nobj) {
X  		if(otmp->oclass == GOLD_CLASS) continue;
X  
X! 		if(Is_container(otmp))
X  		    subfrombill(otmp, shkp);
X  		else
X  		    sub_one_frombill(otmp, shkp);
X--- 1828,1838 ----
X  
X  	sub_one_frombill(obj, shkp);
X  
X! 	if (Has_contents(obj))
X  	    for(otmp = obj->cobj; otmp; otmp = otmp->nobj) {
X  		if(otmp->oclass == GOLD_CLASS) continue;
X  
X! 		if (Has_contents(otmp))
X  		    subfrombill(otmp, shkp);
X  		else
X  		    sub_one_frombill(otmp, shkp);
X***************
X*** 1810,1816 ****
X  
X  	    if(otmp->oclass == GOLD_CLASS) continue;
X  
X! 	    if(!Is_container(otmp)) {
X  		if(ininv) {
X  		    if(otmp->unpaid)
X  			price += get_cost(otmp, shkp);
X--- 1861,1867 ----
X  
X  	    if(otmp->oclass == GOLD_CLASS) continue;
X  
X! 	    if (!Has_contents(otmp)) {
X  		if(ininv) {
X  		    if(otmp->unpaid)
X  			price += get_cost(otmp, shkp);
X***************
X*** 1852,1858 ****
X  
X  	if(obj->oclass == GOLD_CLASS) {
X  	    gvalue += obj->quan;
X! 	} else if(Is_container(obj)) {
X  	    register boolean ininv = !!count_unpaid(obj->cobj);
X  
X  	    value += stolen_container(obj, shkp, value, ininv);
X--- 1903,1909 ----
X  
X  	if(obj->oclass == GOLD_CLASS) {
X  	    gvalue += obj->quan;
X! 	} else if (Has_contents(obj)) {
X  	    register boolean ininv = !!count_unpaid(obj->cobj);
X  
X  	    value += stolen_container(obj, shkp, value, ininv);
X***************
X*** 1918,1924 ****
X  	register struct monst *shkp;
X  	register struct eshk *eshkp;
X  	register long ltmp = 0L, cltmp = 0L, gltmp = 0L, offer;
X! 	boolean saleitem, cgold = FALSE, container = Is_container(obj);
X  	boolean isgold = (obj->oclass == GOLD_CLASS);
X  
X  	if(!(shkp = shop_keeper(*in_rooms(x, y, SHOPBASE))) ||
X--- 1969,1975 ----
X  	register struct monst *shkp;
X  	register struct eshk *eshkp;
X  	register long ltmp = 0L, cltmp = 0L, gltmp = 0L, offer;
X! 	boolean saleitem, cgold = FALSE, container = Has_contents(obj);
X  	boolean isgold = (obj->oclass == GOLD_CLASS);
X  
X  	if(!(shkp = shop_keeper(*in_rooms(x, y, SHOPBASE))) ||
X***************
X*** 1934,1951 ****
X  	    return;
X  	}
X  	if(container) {
X- 	    if(obj->cobj == (struct obj *)0) {
X- 		if(obj->unpaid) {
X- 		    sub_one_frombill(obj, shkp);
X- 		    return;
X- 		}
X- 	    } else {
X  		/* find the price of content before subfrombill */
X  		cltmp += contained_cost(obj, shkp, cltmp, TRUE);
X  		/* find the value of contained gold */
X  		gltmp += contained_gold(obj);
X  		cgold = (gltmp > 0L);
X- 	    }
X  	}
X  
X  	if(!isgold && !obj->unpaid && saleitem)
X--- 1985,1995 ----
X***************
X*** 1959,1971 ****
X  				  (container && count_unpaid(obj->cobj)));
X  
X  		if(container) {
X- 		    if(obj->cobj != (struct obj *)0) {
X  			dropped_container(obj, shkp, FALSE);
X  			if(!obj->unpaid && !saleitem)
X  			    obj->no_charge = 1;
X  			if(obj->unpaid || count_unpaid(obj->cobj))
X  			    subfrombill(obj, shkp);
X- 		    } else obj->no_charge = 1;
X  		} else obj->no_charge = 1;
X  
X  		if(!unpaid)
X--- 2003,2013 ----
X***************
X*** 1974,1986 ****
X  	}
X  
X  	/* you dropped something of your own - probably want to sell it */
X! 	if(shkp->msleep || !shkp->mcanmove) {
X! 		if(container && obj->cobj != (struct obj *)0) {
X  		    dropped_container(obj, shkp, TRUE);
X! 		}
X! 		if(!obj->unpaid && !saleitem && !isgold)
X  		    obj->no_charge = 1;
X! 		if(!shkp->mcanmove) {
X  		    if(ANGRY(shkp) && !rn2(4))
X  			pline("%s utters a curse.", Monnam(shkp));
X  		    else pline("%s is indisposed.", Monnam(shkp));
X--- 2016,2027 ----
X  	}
X  
X  	/* you dropped something of your own - probably want to sell it */
X! 	if (shkp->msleep || !shkp->mcanmove) {
X! 		if (container)
X  		    dropped_container(obj, shkp, TRUE);
X! 		if (!obj->unpaid)
X  		    obj->no_charge = 1;
X! 		if (!shkp->mcanmove) {
X  		    if(ANGRY(shkp) && !rn2(4))
X  			pline("%s utters a curse.", Monnam(shkp));
X  		    else pline("%s is indisposed.", Monnam(shkp));
X***************
X*** 2037,2048 ****
X  		if(offer) goto move_on;
X  		else {
X  		    if(!isgold) {
X! 		        if(container && obj->cobj != (struct obj *)0) {
X  			    dropped_container(obj, shkp, FALSE);
X! 		        }
X! 		        if(!obj->unpaid && !saleitem)
X! 			    obj->no_charge = 1;
X! 		        subfrombill(obj, shkp);
X  		    }
X  		    return;
X  		}
X--- 2078,2087 ----
X  		if(offer) goto move_on;
X  		else {
X  		    if(!isgold) {
X! 			if (container)
X  			    dropped_container(obj, shkp, FALSE);
X! 			if (!obj->unpaid && !saleitem) obj->no_charge = 1;
X! 			subfrombill(obj, shkp);
X  		    }
X  		    return;
X  		}
X***************
X*** 2056,2087 ****
X  	   || (Is_candle(obj) &&
X  		   obj->age < 20L * (long)objects[obj->otyp].oc_cost)) {
X  		pline("%s seems not interested%s.", Monnam(shkp),
X! 					   cgold ? " in the rest" : "");
X! 		if(container && obj->cobj != (struct obj *)0) {
X  		    dropped_container(obj, shkp, FALSE);
X- 		}
X  		obj->no_charge = 1;
X  		return;
X  	}
X  
X  	if(!shkp->mgold) {
X  		long tmpcr = (ltmp + cltmp) * 2L;
X  
X! 		pline("%s cannot pay you at present.", Monnam(shkp));
X! 		pline("Will you accept %ld zorkmids in credit for %s? ",
X! 					 tmpcr, doname(obj));
X! 		/* cannot use a yn function here */
X! 		if (readchar() == 'y') {
X  		    You("have %ld zorkmids in %scredit.", tmpcr,
X! 				ESHK(shkp)->credit > 0L ? "additional " : "");
X  		    ESHK(shkp)->credit += tmpcr;
X  		    subfrombill(obj, shkp);
X  		} else {
X! 		    if(container && obj->cobj != (struct obj *)0) {
X! 				dropped_container(obj, shkp, FALSE);
X! 		    }
X! 		    if(!obj->unpaid)
X! 			obj->no_charge = 1;
X  		    subfrombill(obj, shkp);
X  		}
X  	} else {
X--- 2095,2131 ----
X  	   || (Is_candle(obj) &&
X  		   obj->age < 20L * (long)objects[obj->otyp].oc_cost)) {
X  		pline("%s seems not interested%s.", Monnam(shkp),
X! 			cgold ? " in the rest" : "");
X! 		if (container)
X  		    dropped_container(obj, shkp, FALSE);
X  		obj->no_charge = 1;
X  		return;
X  	}
X  
X  	if(!shkp->mgold) {
X+ 		char c, qbuf[BUFSZ];
X  		long tmpcr = (ltmp + cltmp) * 2L;
X  
X! 		if (sell_response != 'n') {
X! 		    pline("%s cannot pay you at present.", Monnam(shkp));
X! 		    Sprintf(qbuf,
X! 			    "Will you accept %ld zorkmids in credit for %s? ",
X! 			    tmpcr, doname(obj));
X! 		    /* won't accept 'a' response here */
X! 		    c = ynq(qbuf);
X! 		} else		/* previously specified "quit" */
X! 		    c = 'n';
X! 
X! 		if (c == 'y') {
X  		    You("have %ld zorkmids in %scredit.", tmpcr,
X! 			ESHK(shkp)->credit > 0L ? "additional " : "");
X  		    ESHK(shkp)->credit += tmpcr;
X  		    subfrombill(obj, shkp);
X  		} else {
X! 		    if (c == 'q') sell_response = 'n';
X! 		    if (container)
X! 			dropped_container(obj, shkp, FALSE);
X! 		    if (!obj->unpaid) obj->no_charge = 1;
X  		    subfrombill(obj, shkp);
X  		}
X  	} else {
X***************
X*** 2113,2130 ****
X  
X  		switch (sell_response ? sell_response : ynaq(qbuf)) {
X  		 case 'q':  sell_response = 'n';
X! 		 case 'n':  if(container && obj->cobj != (struct obj *)0) {
X  				dropped_container(obj, shkp, FALSE);
X! 			    }
X! 		            if(!obj->unpaid) obj->no_charge = 1;
X  			    subfrombill(obj, shkp);
X  			    break;
X  		 case 'a':  sell_response = 'y';
X! 		 case 'y':  if(container && obj->cobj != (struct obj *)0)
X! 		                dropped_container(obj, shkp, TRUE);
X! 		            if(!obj->unpaid && !saleitem)
X! 			        obj->no_charge = 1;
X! 		            subfrombill(obj, shkp);
X  			    pay(-offer, shkp);
X  			    You("sold %s for %ld gold piece%s.", doname(obj),
X  				offer, plur(offer));
X--- 2157,2172 ----
X  
X  		switch (sell_response ? sell_response : ynaq(qbuf)) {
X  		 case 'q':  sell_response = 'n';
X! 		 case 'n':  if (container)
X  				dropped_container(obj, shkp, FALSE);
X! 			    if (!obj->unpaid) obj->no_charge = 1;
X  			    subfrombill(obj, shkp);
X  			    break;
X  		 case 'a':  sell_response = 'y';
X! 		 case 'y':  if (container)
X! 				dropped_container(obj, shkp, TRUE);
X! 			    if (!obj->unpaid && !saleitem) obj->no_charge = 1;
X! 			    subfrombill(obj, shkp);
X  			    pay(-offer, shkp);
X  			    You("sold %s for %ld gold piece%s.", doname(obj),
X  				offer, plur(offer));
X***************
X*** 2179,2194 ****
X  		goto quit;
X  	    }
X  	    if(bp->useup || bp->bquan > obj->quan) {
X! 		register long oquan, uquan;
X! 		long thisused;
X  
X  		oquan = obj->quan;
X  		uquan = (bp->useup ? bp->bquan : bp->bquan - oquan);
X  		thisused = bp->price * uquan;
X  		totused += thisused;
X  		obj->quan = uquan;		/* cheat doname */
X  		buf_p = xprname(obj, ' ', FALSE, thisused);
X  		obj->quan = oquan;		/* restore value */
X  		putstr(datawin, 0, buf_p);
X  	    }
X  	}
X--- 2221,2244 ----
X  		goto quit;
X  	    }
X  	    if(bp->useup || bp->bquan > obj->quan) {
X! 		register long oquan, uquan, thisused;
X! 		unsigned save_unpaid;
X  
X+ 		save_unpaid = obj->unpaid;
X  		oquan = obj->quan;
X  		uquan = (bp->useup ? bp->bquan : bp->bquan - oquan);
X  		thisused = bp->price * uquan;
X  		totused += thisused;
X  		obj->quan = uquan;		/* cheat doname */
X+ 		obj->unpaid = 0;		/* ditto */
X  		buf_p = xprname(obj, ' ', FALSE, thisused);
X  		obj->quan = oquan;		/* restore value */
X+ #ifdef __SASC
X+ 				/* SAS/C 6.2 can't cope for some reason */
X+ 		sasc_bug(obj,save_unpaid);
X+ #else
X+ 		obj->unpaid = save_unpaid;
X+ #endif
X  		putstr(datawin, 0, buf_p);
X  	    }
X  	}
X***************
X*** 2236,2241 ****
X--- 2286,2292 ----
X  	return tmp;
X  }
X  
X+ /* shk catches thrown pick-axe */
X  int
X  shkcatch(obj, x, y)
X  register struct obj *obj;
X***************
X*** 2403,2409 ****
X  
X  	if ((monstermoves - tmp_dam->when) < REPAIR_DELAY)
X  	    return(0);
X! 	if (ESHK(shkp)->following)
X  	    return(0);
X  	x = tmp_dam->place.x;
X  	y = tmp_dam->place.y;
X--- 2454,2460 ----
X  
X  	if ((monstermoves - tmp_dam->when) < REPAIR_DELAY)
X  	    return(0);
X! 	if (shkp->msleep || !shkp->mcanmove || ESHK(shkp)->following)
X  	    return(0);
X  	x = tmp_dam->place.x;
X  	y = tmp_dam->place.y;
X***************
X*** 2448,2455 ****
X  				y+vert(i)) == ESHK(shkp)->shoproom)
X  		    litter[i] |= INSHOP;
X  	    }
X! 	    if (Punished && ((uchain->ox == x && uchain->oy == y) ||
X! 					(uball->ox == x && uball->oy == y))) {
X  		/*
X  		 * Either the ball or chain is in the repair location.
X  		 *
X--- 2499,2507 ----
X  				y+vert(i)) == ESHK(shkp)->shoproom)
X  		    litter[i] |= INSHOP;
X  	    }
X! 	    if (Punished && !u.uswallow &&
X! 				((uchain->ox == x && uchain->oy == y) ||
X! 				 (uball->ox == x && uball->oy == y))) {
X  		/*
X  		 * Either the ball or chain is in the repair location.
X  		 *
X***************
X*** 2872,2878 ****
X  	    break;
X      /* note: otmp might have ->no_charge set, but that's ok */
X      return (otmp && costly_spot(x, y) && NOTANGRY(shkp)
X! 	    && !shkp->msleep && !shkp->mfrozen)
X  		? otmp : (struct obj *)0;
X  }
X  
X--- 2924,2930 ----
X  	    break;
X      /* note: otmp might have ->no_charge set, but that's ok */
X      return (otmp && costly_spot(x, y) && NOTANGRY(shkp)
X! 	    && shkp->mcanmove && !shkp->msleep)
X  		? otmp : (struct obj *)0;
X  }
X  
X***************
X*** 2950,2955 ****
X--- 3002,3048 ----
X      return ".";
X  }
X  
X+ #ifdef SOUNDS
X+ void
X+ shk_chat(shkp)
X+ register struct monst *shkp;
X+ {
X+ 	register struct eshk *eshk = ESHK(shkp);
X+ 
X+ 	if (ANGRY(shkp))
X+ 		pline("%s mentions how much %s dislikes %s customers.",
X+ 			shkname(shkp), he[shkp->female],
X+ 			eshk->robbed ? "non-paying" : "rude");
X+ 	else if (eshk->following)
X+ 		if (strncmp(eshk->customer, plname, PL_NSIZ)) {
X+ 		    verbalize("Hello %s!  I was looking for %s.",
X+ 			    plname, eshk->customer);
X+ 		    eshk->following = 0;
X+ 		} else {
X+ 		    verbalize("Hello %s!  Didn't you forget to pay?", plname);
X+ 		}
X+ 	else if (eshk->billct) {
X+ 		register long total = addupbill(shkp) + eshk->debit;
X+ 		pline("%s says that your bill comes to %ld zorkmid%s.",
X+ 		      shkname(shkp), total, plur(total));
X+ 	} else if (eshk->debit)
X+ 		pline("%s reminds you that you owe %s %ld zorkmid%s.",
X+ 		      shkname(shkp), him[shkp->female],
X+ 		      eshk->debit, plur(eshk->debit));
X+ 	else if (eshk->credit)
X+ 		pline("%s encourages you to use your %ld zorkmid%s of credit.",
X+ 		      shkname(shkp), eshk->credit, plur(eshk->credit));
X+ 	else if (eshk->robbed)
X+ 		pline("%s complains about a recent robbery.", shkname(shkp));
X+ 	else if (shkp->mgold < 50)
X+ 		pline("%s complains that business is bad.", shkname(shkp));
X+ 	else if (shkp->mgold > 4000)
X+ 		pline("%s says that business is good.", shkname(shkp));
X+ 	else
X+ 		pline("%s talks about the problem of shoplifters.", shkname(shkp));
X+ }
X+ #endif  /* SOUNDS */
X+ 
X  #ifdef KOPS
X  static void
X  kops_gone(silent)
X***************
X*** 3008,3014 ****
X  	} else if (otmp->oclass == SPBOOK_CLASS) {
X  		    tmp -= tmp / 5L;
X  	} else if (otmp->otyp == CAN_OF_GREASE)
X! 	            tmp /= 10L;
X  	return(tmp);
X  }
X  
X--- 3101,3107 ----
X  	} else if (otmp->oclass == SPBOOK_CLASS) {
X  		    tmp -= tmp / 5L;
X  	} else if (otmp->otyp == CAN_OF_GREASE)
X! 		    tmp /= 10L;
X  	return(tmp);
X  }
X  
X***************
X*** 3140,3144 ****
X--- 3233,3243 ----
X  }
X  
X  #endif /* OVLB */
X+ 
X+ #ifdef __SASC
X+ sasc_bug(struct obj *op, unsigned x){
X+ 	op->unpaid=x;
X+ }
X+ #endif
X  
X  /*shk.c*/
X*** /tmp/da11370	Tue Jun  1 16:15:50 1993
X--- src/shknam.c	Mon May 17 14:05:04 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)shknam.c	3.1	93/02/17	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)shknam.c	3.1	93/05/15	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 10,16 ****
X  #ifdef OVLB
X  
X  static void FDECL(mkshobj_at, (const struct shclass *,int,int));
X! static void FDECL(findname, (char *,const char **));
X  static int  FDECL(shkinit, (const struct shclass *,struct mkroom *));
X  
X  static const char *shkliquors[] = {
X--- 10,16 ----
X  #ifdef OVLB
X  
X  static void FDECL(mkshobj_at, (const struct shclass *,int,int));
X! static void FDECL(nameshk, (struct monst *,const char **));
X  static int  FDECL(shkinit, (const struct shclass *,struct mkroom *));
X  
X  static const char *shkliquors[] = {
X***************
X*** 123,128 ****
X--- 123,140 ----
X      ""
X  };
X  
X+ static const char *shklight[] = {
X+     /* Romania */
X+     "Zarnesti", "Slanic", "Nehoiasu", "Ludus", "Sighisoara", "Nisipitu",
X+     "Razboieni", "Bicaz", "Dorohoi", "Vaslui", "Fetesti", "Tirgu Neamt",
X+     "Babadag", "Zimnicea", "Zlatna", "Jiu", "Eforie", "Mamaia",
X+     /* Bulgaria */
X+     "Silistra", "Tulovo", "Panagyuritshte", "Smolyan", "Kirklareli",
X+     "Pernik", "Lom", "Haskovo", "Dobrinishte", "Varvara", "Oryahovo",
X+     "Troyan", "Lovech", "Sliven",
X+     ""
X+ };
X+ 
X  static const char *shkgeneral[] = {
X      /* Suriname */
X      "Hebiwerie", "Possogroenoe", "Asidonhopo", "Manlobbi",
X***************
X*** 191,197 ****
X  	 */
X  	{"lighting store", TOOL_CLASS, 0, D_SHOP,
X  	    {{32, -WAX_CANDLE}, {50, -TALLOW_CANDLE},
X! 	     {5, -BRASS_LANTERN}, {10, -OIL_LAMP}, {3, -MAGIC_LAMP}},shktools},
X  	{NULL, 0, 0, 0, {{0, 0}, {0, 0}, {0, 0}}, 0}
X  };
X  
X--- 203,209 ----
X  	 */
X  	{"lighting store", TOOL_CLASS, 0, D_SHOP,
X  	    {{32, -WAX_CANDLE}, {50, -TALLOW_CANDLE},
X! 	     {5, -BRASS_LANTERN}, {10, -OIL_LAMP}, {3, -MAGIC_LAMP}}, shklight},
X  	{NULL, 0, 0, 0, {{0, 0}, {0, 0}, {0, 0}}, 0}
X  };
X  
X***************
X*** 247,273 ****
X  	else (void) mkobj_at(atype, sx, sy, TRUE);
X  }
X  
X- static void
X- findname(nampt, nlp)
X  /* extract a shopkeeper name for the given shop type */
X! 	char *nampt;
X! 	const char *nlp[];
X  {
X!     register int i;
X  
X!     for(i = 0; i < ledger_no(&u.uz); i++) /* Note: _not_ depth */
X! 	if (!*nlp[i]) {
X! 	    /* Not enough names, try random/general name */
X! 	    if((i = rn2(i)))
X! 		break;
X! 	    else if (nlp != shkgeneral)
X! 		findname(nampt, shkgeneral);
X! 	    else
X! 		Strcpy(nampt, "Dirk");
X! 	    return;
X  	}
X!     (void) strncpy(nampt, nlp[i-1], PL_NSIZ);
X!     nampt[PL_NSIZ-1] = 0;
X  }
X  
X  static int
X--- 259,313 ----
X  	else (void) mkobj_at(atype, sx, sy, TRUE);
X  }
X  
X  /* extract a shopkeeper name for the given shop type */
X! static void
X! nameshk(shk, nlp)
X! struct monst *shk;
X! const char *nlp[];
X  {
X! 	int i, try, names_avail;
X! 	const char *shname = 0;
X! 	struct monst *mtmp;
X! 	int name_wanted = ledger_no(&u.uz);	/* Note: _not_ depth */
X  
X! 	for (names_avail = 0; *nlp[names_avail]; names_avail++)
X! 		;
X! 
X! 	for (try = 0; try < 50; try++) {
X! 		if (nlp == shktools) {
X! 		    shname = shktools[rn2(names_avail)];
X! 		    shk->female = (*shname == '_');
X! 		    if (shk->female) shname++;
X! 		} else {
X! 		    shk->female = name_wanted % 2;
X! 
X! 		    if (name_wanted < names_avail) {
X! 			shname = nlp[name_wanted];
X! 		    } else {
X! 			if ((i = rn2(names_avail)) != 0)
X! 			    shname = nlp[i-1];
X! 			else if (nlp != shkgeneral) {
X! 			    nlp = shkgeneral;	/* try general names */
X! 			    for (names_avail = 0; *nlp[names_avail];
X! 								names_avail++)
X! 				    ;
X! 			    continue;
X! 			} else
X! 			    shname = "Dirk";
X! 		    }
X! 		}
X! 
X! 		/* is name already is use on this level? */
X! 		for (mtmp = fmon; mtmp; mtmp = mtmp->nmon) {
X! 			if (mtmp == shk) continue;
X! 			if (!mtmp->isshk) continue;
X! 			if (strcmp(ESHK(mtmp)->shknam, shname)) continue;
X! 			break;
X! 		}
X! 		if (!mtmp) break;	/* new name */
X  	}
X! 	(void) strncpy(ESHK(shk)->shknam, shname, PL_NSIZ);
X! 	ESHK(shk)->shknam[PL_NSIZ-1] = 0;
X  }
X  
X  static int
X***************
X*** 328,336 ****
X  
X  	/* now initialize the shopkeeper monster structure */
X  	if(!(shk = makemon(&mons[PM_SHOPKEEPER], sx, sy))) return(-1);
X! 	shk->isshk = shk->mpeaceful = 1;
X  	set_malign(shk);
X! 	shk->msleep = 0;
X  	shk->mtrapseen = ~0;	/* we know all the traps already */
X  	ESHK(shk)->shoproom = (sroom - rooms) + ROOMOFFSET;
X  	sroom->resident = shk;
X--- 368,376 ----
X  
X  	/* now initialize the shopkeeper monster structure */
X  	if(!(shk = makemon(&mons[PM_SHOPKEEPER], sx, sy))) return(-1);
X! 	shk->isshk = shk->mpeaceful = TRUE;
X  	set_malign(shk);
X! 	shk->msleep = FALSE;
X  	shk->mtrapseen = ~0;	/* we know all the traps already */
X  	ESHK(shk)->shoproom = (sroom - rooms) + ROOMOFFSET;
X  	sroom->resident = shk;
X***************
X*** 347,362 ****
X  	ESHK(shk)->following = 0;
X  	ESHK(shk)->billct = 0;
X  	shk->mgold = 1000L + 30L*(long)rnd(100);	/* initial capital */
X! 	if (shp->shknms == shktools) {
X! 		int who = rn2(SIZE(shktools) - 1);
X! 		const char *shname = shp->shknms[who];
X! 		if (shk->female = (*shname == '_')) shname++;
X! 		(void) strncpy(ESHK(shk)->shknam, shname, PL_NSIZ);
X! 		ESHK(shk)->shknam[PL_NSIZ-1] = 0;
X! 	} else {
X! 		shk->female = ledger_no(&u.uz)%2;
X! 		findname(ESHK(shk)->shknam, shp->shknms);
X! 	}
X  
X  	return(sh);
X  }
X--- 387,393 ----
X  	ESHK(shk)->following = 0;
X  	ESHK(shk)->billct = 0;
X  	shk->mgold = 1000L + 30L*(long)rnd(100);	/* initial capital */
X! 	nameshk(shk, shp->shknms);
X  
X  	return(sh);
X  }
X***************
X*** 427,433 ****
X       * monsters will sit on top of objects and not the other way around.
X       */
X  
X!     level.flags.has_shop = 1;
X  }
X  
X  #endif /* OVLB */
X--- 458,464 ----
X       * monsters will sit on top of objects and not the other way around.
X       */
X  
X!     level.flags.has_shop = TRUE;
X  }
X  
X  #endif /* OVLB */
X*** /tmp/da11378	Tue Jun  1 16:15:53 1993
X--- src/sit.c	Thu May 20 15:43:51 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)sit.c	3.1	92/10/24	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)sit.c	3.1	93/05/19	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 36,42 ****
X  	    You("sit on %s.", the(xname(obj)));
X  	    if(!Is_box(obj)) pline("It's not very comfortable...");
X  
X! 	} else if(trap = t_at(u.ux, u.uy)) {
X  
X  	    if (u.utrap) {
X  		exercise(A_WIS, FALSE);	/* you're getting stuck longer */
X--- 36,42 ----
X  	    You("sit on %s.", the(xname(obj)));
X  	    if(!Is_box(obj)) pline("It's not very comfortable...");
X  
X! 	} else if ((trap = t_at(u.ux, u.uy)) != 0) {
X  
X  	    if (u.utrap) {
X  		exercise(A_WIS, FALSE);	/* you're getting stuck longer */
X***************
X*** 211,219 ****
X  			You("are granted an insight!");
X  			if (invent) {
X  			    int ret, cval = rn2(5); /* agrees w/seffects() */
X  			    do {
X  				ret = ggetobj("identify", identify, cval);
X! 			    } while (cval && (cval -= ret));
X  			}
X  			break;
X  		    case 13:
X--- 211,221 ----
X  			You("are granted an insight!");
X  			if (invent) {
X  			    int ret, cval = rn2(5); /* agrees w/seffects() */
X+ 			    /* use up `cval' "charges"; 0 is special case */
X  			    do {
X  				ret = ggetobj("identify", identify, cval);
X! 				if (ret < 0) break;	/* quit */
X! 			    } while (ret == 0 || (cval -= ret) > 0);
X  			}
X  			break;
X  		    case 13:
X***************
X*** 261,267 ****
X  	} else if (u.uswallow)
X  		pline("There are no seats in here!");
X  	else
X! 		pline("Having fun sitting on the floor?");
X  	return(1);
X  }
X  
X--- 263,269 ----
X  	} else if (u.uswallow)
X  		pline("There are no seats in here!");
X  	else
X! 		pline("Having fun sitting on the %s?", surface(u.ux,u.uy));
X  	return(1);
X  }
X  
X***************
X*** 271,280 ****
X  	int	nobj = 0;
X  	int	cnt, onum;
X  	struct	obj	*otmp;
X  
X  	if(Antimagic) {
X  	    shieldeff(u.ux, u.uy);
X! 	    You("feel a malignant aura surround you.");
X  	}
X  
X  	for (otmp = invent; otmp; otmp = otmp->nobj)  nobj++;
X--- 273,288 ----
X  	int	nobj = 0;
X  	int	cnt, onum;
X  	struct	obj	*otmp;
X+ 	static const char *mal_aura = "feel a malignant aura surround %s.";
X  
X+ 	if (uwep && (uwep->oartifact == ART_MAGICBANE) && rn2(20)) {
X+ 	    You(mal_aura, "the magic-absorbing blade");
X+ 	    return;
X+ 	}
X+ 
X  	if(Antimagic) {
X  	    shieldeff(u.ux, u.uy);
X! 	    You(mal_aura, "you");
X  	}
X  
X  	for (otmp = invent; otmp; otmp = otmp->nobj)  nobj++;
X*** /tmp/da11402	Tue Jun  1 16:16:01 1993
X--- src/spell.c	Mon May 17 14:05:10 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)spell.c	3.1	92/12/10
X  /*	Copyright (c) M. Stephenson 1988			  */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)spell.c	3.1	93/05/15	*/
X  /*	Copyright (c) M. Stephenson 1988			  */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 105,111 ****
X  	}
X  
X  	if(!u.uhave.bell || !u.uhave.menorah) {
X! 	    pline("A chill runs down your spine.");
X  	    if(!u.uhave.bell) You("hear a faint chime...");
X  	    if(!u.uhave.menorah) pline("Vlad's doppelganger is amused.");
X  	    return;
X--- 105,111 ----
X  	}
X  
X  	if(!u.uhave.bell || !u.uhave.menorah) {
X! 	    pline("A chill runs down your %s.", body_part(SPINE));
X  	    if(!u.uhave.bell) You("hear a faint chime...");
X  	    if(!u.uhave.menorah) pline("Vlad's doppelganger is amused.");
X  	    return;
X***************
X*** 149,155 ****
X  	mm.y = u.uy;
X  	mkundead(&mm);
X  	if(!rn2(4))
X! 	    if(mtmp = makemon(&mons[PM_MASTER_LICH],u.ux,u.uy)) {
X  		mtmp->mpeaceful = 0;
X  		set_malign(mtmp);
X  	    }
X--- 149,155 ----
X  	mm.y = u.uy;
X  	mkundead(&mm);
X  	if(!rn2(4))
X! 	    if ((mtmp = makemon(&mons[PM_MASTER_LICH],u.ux,u.uy)) != 0) {
X  		mtmp->mpeaceful = 0;
X  		set_malign(mtmp);
X  	    }
X***************
X*** 494,499 ****
X--- 494,501 ----
X  	case SPE_FINGER_OF_DEATH:
X  	case SPE_LIGHT:
X  	case SPE_DETECT_UNSEEN:
X+ 	case SPE_HEALING:
X+ 	case SPE_EXTRA_HEALING:
X  		if (!(objects[pseudo->otyp].oc_dir == NODIR)) {
X  			if (atme) u.dx = u.dy = u.dz = 0;
X  			else (void) getdir(NULL);
X***************
X*** 524,533 ****
X  	case SPE_INVISIBILITY:
X  		(void) peffects(pseudo);
X  		break;
X- 	case SPE_HEALING:
X- 		You("feel a bit better.");
X- 		healup(rnd(8), 0, FALSE, FALSE);
X- 		break;
X  	case SPE_CURE_BLINDNESS:
X  		healup(0, 0, FALSE, TRUE);
X  		break;
X--- 526,531 ----
X***************
X*** 534,543 ****
X  	case SPE_CURE_SICKNESS:
X  		if (Sick) You("are no longer ill.");
X  		healup(0, 0, TRUE, FALSE);
X- 		break;
X- 	case SPE_EXTRA_HEALING:
X- 		You("feel a fair bit better.");
X- 		healup(d(2,8)+2, 0, FALSE, FALSE);
X  		break;
X  	case SPE_CREATE_FAMILIAR:
X  		make_familiar((struct obj *)0, u.ux, u.uy);
X--- 532,537 ----
X*** /tmp/da11410	Tue Jun  1 16:16:03 1993
X--- src/steal.c	Tue Jun  1 11:58:39 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)steal.c	3.1	92/10/14	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)steal.c	3.1	93/05/30	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 11,20 ****
X  
X  static const char *
X  equipname(otmp)
X! 
X! 	register struct obj *otmp;
X  {
X- 
X  	return (
X  #ifdef TOURIST
X  		(otmp == uarmu) ? "shirt" :
X--- 11,18 ----
X  
X  static const char *
X  equipname(otmp)
X! register struct obj *otmp;
X  {
X  	return (
X  #ifdef TOURIST
X  		(otmp == uarmu) ? "shirt" :
X***************
X*** 27,33 ****
X  }
X  
X  long		/* actually returns something that fits in an int */
X! somegold(){
X  #ifdef LINT	/* long conv. ok */
X  	return(0L);
X  #else
X--- 25,32 ----
X  }
X  
X  long		/* actually returns something that fits in an int */
X! somegold()
X! {
X  #ifdef LINT	/* long conv. ok */
X  	return(0L);
X  #else
X***************
X*** 50,56 ****
X  	    pline("%s quickly snatches some gold from between your %s!",
X  		    Monnam(mtmp), makeplural(body_part(FOOT)));
X  	    if(!u.ugold || !rn2(5)) {
X! 		rloc(mtmp);
X  		mtmp->mflee = 1;
X  	    }
X  	} else if(u.ugold) {
X--- 49,55 ----
X  	    pline("%s quickly snatches some gold from between your %s!",
X  		    Monnam(mtmp), makeplural(body_part(FOOT)));
X  	    if(!u.ugold || !rn2(5)) {
X! 		if (!tele_restrict(mtmp)) rloc(mtmp);
X  		mtmp->mflee = 1;
X  	    }
X  	} else if(u.ugold) {
X***************
X*** 57,63 ****
X  	    u.ugold -= (tmp = somegold());
X  	    Your("purse feels lighter.");
X  	    mtmp->mgold += tmp;
X! 	    rloc(mtmp);
X  	    mtmp->mflee = 1;
X  	    flags.botl = 1;
X  	}
X--- 56,62 ----
X  	    u.ugold -= (tmp = somegold());
X  	    Your("purse feels lighter.");
X  	    mtmp->mgold += tmp;
X! 	    if (!tele_restrict(mtmp)) rloc(mtmp);
X  	    mtmp->mflee = 1;
X  	    flags.botl = 1;
X  	}
X***************
X*** 68,74 ****
X  unsigned int stealmid;		/* monster doing the stealing */
X  
X  STATIC_OVL int
X! stealarm(){
X  	register struct monst *mtmp;
X  	register struct obj *otmp;
X  
X--- 67,74 ----
X  unsigned int stealmid;		/* monster doing the stealing */
X  
X  STATIC_OVL int
X! stealarm()
X! {
X  	register struct monst *mtmp;
X  	register struct obj *otmp;
X  
X***************
X*** 82,88 ****
X  		  pline("%s steals %s!", Monnam(mtmp), doname(otmp));
X  		  mpickobj(mtmp,otmp);
X  		  mtmp->mflee = 1;
X! 		  rloc(mtmp);
X  		break;
X  	      }
X  	    break;
X--- 82,88 ----
X  		  pline("%s steals %s!", Monnam(mtmp), doname(otmp));
X  		  mpickobj(mtmp,otmp);
X  		  mtmp->mflee = 1;
X! 		  if (!tele_restrict(mtmp)) rloc(mtmp);
X  		break;
X  	      }
X  	    break;
X***************
X*** 263,270 ****
X--- 263,275 ----
X  register struct monst *mtmp;
X  register struct obj *otmp;
X  {
X+     if (otmp->otyp == GOLD_PIECE) {	/* from floor etc. -- not inventory */
X+ 	mtmp->mgold += otmp->quan;
X+ 	obfree(otmp, (struct obj *)0);
X+     } else {
X  	otmp->nobj = mtmp->minvent;
X  	mtmp->minvent = otmp;
X+     }
X  }
X  
X  #endif /* OVL1 */
X***************
X*** 278,288 ****
X  	register int	real, fake;
X  
X  	/* select the artifact to steal */
X!         if(u.uhave.amulet) {
X  		real = AMULET_OF_YENDOR ;
X  		fake = FAKE_AMULET_OF_YENDOR ;
X  #ifdef MULDGN
X  	} else if(u.uhave.questart) {
X  	    for(otmp = invent; otmp; otmp = otmp->nobj)
X  	        if(is_quest_artifact(otmp)) goto snatch_it;
X  #endif
X--- 283,294 ----
X  	register int	real, fake;
X  
X  	/* select the artifact to steal */
X! 	if(u.uhave.amulet) {
X  		real = AMULET_OF_YENDOR ;
X  		fake = FAKE_AMULET_OF_YENDOR ;
X  #ifdef MULDGN
X  	} else if(u.uhave.questart) {
X+ 	    real = fake = 0;		/* gcc -Wall lint */
X  	    for(otmp = invent; otmp; otmp = otmp->nobj)
X  	        if(is_quest_artifact(otmp)) goto snatch_it;
X  #endif
X***************
X*** 302,312 ****
X  	    if(otmp->otyp == real || (otmp->otyp == fake && !mtmp->iswiz)) {
X  		/* might be an imitation one */
X  snatch_it:
X  		setnotworn(otmp);
X  		freeinv(otmp);
X  		mpickobj(mtmp,otmp);
X  		pline("%s stole %s!", Monnam(mtmp), doname(otmp));
X! 		if (can_teleport(mtmp->data)) rloc(mtmp);
X  		return;
X  	    }
X  	}
X--- 308,322 ----
X  	    if(otmp->otyp == real || (otmp->otyp == fake && !mtmp->iswiz)) {
X  		/* might be an imitation one */
X  snatch_it:
X+ #ifdef MULDGN
X+ 		if (otmp->oclass == ARMOR_CLASS) adj_abon(otmp, -(otmp->spe));
X+ #endif
X  		setnotworn(otmp);
X  		freeinv(otmp);
X  		mpickobj(mtmp,otmp);
X  		pline("%s stole %s!", Monnam(mtmp), doname(otmp));
X! 		if (can_teleport(mtmp->data) && !tele_restrict(mtmp))
X! 			rloc(mtmp);
X  		return;
X  	    }
X  	}
X***************
X*** 315,353 ****
X  #endif /* OVLB */
X  #ifdef OVL0
X  
X! /* release the objects the killed animal was carrying */
X  void
X  relobj(mtmp,show,is_pet)
X  register struct monst *mtmp;
X  register int show;
X! boolean is_pet;		/* If true, pet should keep wielded weapon */
X  {
X  	register struct obj *otmp, *otmp2;
X  	register int omx = mtmp->mx, omy = mtmp->my;
X- 
X  #ifdef MUSE
X! 	otmp2 = otmp = 0;
X! 	if (is_pet) {
X! 		sort_mwep(mtmp);
X! 		if ((otmp2 = MON_WEP(mtmp))) {
X! 			otmp = otmp2->nobj;
X! 			otmp2->nobj = 0;
X! 		}
X! 	}
X! 	if (!otmp2)
X  #endif
X- 	{	otmp = mtmp->minvent;
X- 		mtmp->minvent = 0;
X- 	}
X  
X  	for (; otmp; otmp = otmp2) {
X  #ifdef MUSE
X! 		if (otmp->owornmask) {
X  			mtmp->misc_worn_check &= ~(otmp->owornmask);
X  			otmp->owornmask = 0L;
X  		}
X  #endif
X- 		otmp2 = otmp->nobj;
X  		if (is_pet && cansee(omx, omy) && flags.verbose)
X  			pline("%s drops %s.", Monnam(mtmp),
X  					distant_name(otmp, doname));
X--- 325,364 ----
X  #endif /* OVLB */
X  #ifdef OVL0
X  
X! /* release the objects the creature is carrying */
X  void
X  relobj(mtmp,show,is_pet)
X  register struct monst *mtmp;
X  register int show;
X! boolean is_pet;		/* If true, pet should keep wielded/worn items */
X  {
X  	register struct obj *otmp, *otmp2;
X  	register int omx = mtmp->mx, omy = mtmp->my;
X  #ifdef MUSE
X! 	struct obj *backobj = 0;
X! 	struct obj *wep = MON_WEP(mtmp);
X  #endif
X  
X+ 	otmp = mtmp->minvent;
X+ 	mtmp->minvent = 0;
X  	for (; otmp; otmp = otmp2) {
X+ 		otmp2 = otmp->nobj;
X  #ifdef MUSE
X! 		if (otmp->owornmask || otmp == wep) {
X! 			if (is_pet) { /* skip worn/wielded item */
X! 				if (!backobj) {
X! 					mtmp->minvent = backobj = otmp;
X! 				} else {
X! 					backobj->nobj = otmp;
X! 					backobj = backobj->nobj;
X! 				}
X! 				continue;
X! 			}
X  			mtmp->misc_worn_check &= ~(otmp->owornmask);
X  			otmp->owornmask = 0L;
X  		}
X+ 		if (backobj) backobj->nobj = otmp->nobj;
X  #endif
X  		if (is_pet && cansee(omx, omy) && flags.verbose)
X  			pline("%s drops %s.", Monnam(mtmp),
X  					distant_name(otmp, doname));
X*** /tmp/da11418	Tue Jun  1 16:16:06 1993
X--- src/timeout.c	Wed Mar 31 14:20:11 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)timeout.c	3.1	92/11/01	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)timeout.c	3.1	93/03/30	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 164,172 ****
X  			break;
X  		case INVIS:
X  			newsym(u.ux,u.uy);
X! 			if (!Invis && !See_invisible && !Blind)
X  				You("are no longer invisible.");
X! 			stop_occupation();
X  			break;
X  		case SEE_INVIS:
X  			set_mimic_blocking(); /* do special mimic handling */
X--- 164,173 ----
X  			break;
X  		case INVIS:
X  			newsym(u.ux,u.uy);
X! 			if (!Invis && !See_invisible && !Blind) {
X  				You("are no longer invisible.");
X! 				stop_occupation();
X! 			}
X  			break;
X  		case SEE_INVIS:
X  			set_mimic_blocking(); /* do special mimic handling */
X***************
X*** 213,219 ****
X  				switch (rn2(4)) {
X  				    case 1:
X  					if (ACCESSIBLE(levl[u.ux][u.uy].typ)) { /* not POOL or STONE */
X! 					    if (Hallucination) pline("A rock bites your foot.");
X  					    else You("trip over a rock.");
X  					    break;
X  					}
X--- 214,220 ----
X  				switch (rn2(4)) {
X  				    case 1:
X  					if (ACCESSIBLE(levl[u.ux][u.uy].typ)) { /* not POOL or STONE */
X! 					    if (Hallucination) pline("A rock bites your %s.", body_part(FOOT));
X  					    else You("trip over a rock.");
X  					    break;
X  					}
X***************
X*** 271,277 ****
X  			locomotion(mtmp->data, "drop"));
X  		else
X  		    You("see %s %s out of your pack!",
X! 			an(mtmp->data->mname),
X  			locomotion(mtmp->data, "drop"));
X  
X  #ifdef POLYSELF
X--- 272,278 ----
X  			locomotion(mtmp->data, "drop"));
X  		else
X  		    You("see %s %s out of your pack!",
X! 			a_monnam(mtmp),
X  			locomotion(mtmp->data, "drop"));
X  
X  #ifdef POLYSELF
X***************
X*** 280,289 ****
X  
X  		    pline("Its cries sound like \"%s.\"",
X  			flags.female ? "mommy" : "daddy");
X! 		    if (mtmp2 = tamedog(mtmp, (struct obj *)0))
X  			mtmp = mtmp2;
X  		    mtmp->mtame = 20;
X! 		    while(otmp = (mtmp->minvent)) {
X  			mtmp->minvent = otmp->nobj;
X  			dealloc_obj(otmp);
X  		    }
X--- 281,290 ----
X  
X  		    pline("Its cries sound like \"%s.\"",
X  			flags.female ? "mommy" : "daddy");
X! 		    if ((mtmp2 = tamedog(mtmp, (struct obj *)0)) != 0)
X  			mtmp = mtmp2;
X  		    mtmp->mtame = 20;
X! 		    while ((otmp = (mtmp->minvent)) != 0) {
X  			mtmp->minvent = otmp->nobj;
X  			dealloc_obj(otmp);
X  		    }
X***************
X*** 294,302 ****
X  		    struct monst *mtmp2;
X  
X  		    verbalize("Gleep!");		/* Mything eggs :-) */
X! 		    if (mtmp2 = tamedog(mtmp, (struct obj *)0))
X  			mtmp = mtmp2;
X! 		    while(otmp = (mtmp->minvent)) {
X  			mtmp->minvent = otmp->nobj;
X  			dealloc_obj(otmp);
X  		    }
X--- 295,303 ----
X  		    struct monst *mtmp2;
X  
X  		    verbalize("Gleep!");		/* Mything eggs :-) */
X! 		    if ((mtmp2 = tamedog(mtmp, (struct obj *)0)) != 0)
X  			mtmp = mtmp2;
X! 		    while ((otmp = (mtmp->minvent)) != 0) {
X  			mtmp->minvent = otmp->nobj;
X  			dealloc_obj(otmp);
X  		    }
X***************
X*** 316,322 ****
X  	for(otmp = invent; otmp; otmp = otmp2) {
X  	    otmp2 = otmp->nobj;	    /* otmp may hatch */
X  	    if(otmp->otyp == EGG && otmp->corpsenm >= 0) hatch_it(otmp);
X! 	    /* else if (Is_container(otmp) && otmp->cobj) ...		*/
X  	    /*								*/
X  	    /* Check for container here and hatch with the container.	*/
X  	    /* One of these days...					*/
X--- 317,323 ----
X  	for(otmp = invent; otmp; otmp = otmp2) {
X  	    otmp2 = otmp->nobj;	    /* otmp may hatch */
X  	    if(otmp->otyp == EGG && otmp->corpsenm >= 0) hatch_it(otmp);
X! 	    /* else if (Has_contents(otmp)) ...				*/
X  	    /*								*/
X  	    /* Check for container here and hatch with the container.	*/
X  	    /* One of these days...					*/
END_OF_FILE
if test 55125 -ne `wc -c <'patches02h'`; then
    echo shar: \"'patches02h'\" unpacked with wrong size!
fi
# end of 'patches02h'
echo shar: End of archive 11 \(of 33\).
cp /dev/null ark11isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 33 archives.
    echo "Now execute ./patchit.sh"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
