Path: uunet!news.tek.com!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v17i076:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Patch2a/33
Date: 11 Jun 1993 00:04:10 GMT
Organization: Tektronix, Inc, Redmond, OR, USA
Lines: 2274
Approved: billr@saab.CNA.TEK.COM
Message-ID: <1v8i5q$inn@ying.cna.tek.com>
NNTP-Posting-Host: saab.cna.tek.com
Xref: uunet comp.sources.games:1755

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 17, Issue 76
Archive-name: nethack31/Patch2a
Patch-To: nethack31: Volume 16, Issue 1-116
Environment: Amiga, Atari, Mac, MS-DOS, Windows-NT, OS2, Unix, VMS, X11

	[Here's patch 2 to nethack3.1 in a series of 33 shar files. There
	 are both new files, replacement files and patch files. Run the
	 'patchit.sh' script after unpacking everything to apply the patches.
	 You may then want to go in and cleanup things by removing the .orig
	 files.  -br]

[From the development team:]
[[In port-specific news, the Amiga and Mac ports have again changed the
most, both in user interface for the previously existing windowing
systems and in adding support for "tty" windowing.  The MS-DOS versions
may now use direct screen I/O instead of going through termcap routines,
and be compiled for NEC PC-9801 machines thanks to Yamamoto Keizo.
The SYSV 386 music driver was ported to 386BSD by Andrew Chernov and
SCO by Andreas Arens.

In general news, the pickup and disclosure options were enhanced;
information on the new usage is available from the Guidebook and
intra-game options help.

A number of bugs were fixed, of which the most commonly encountered
fatal ones were associated with cursed bags of holding, renaming
shopkeepers, objects falling through trapdoors on deep levels, and
kicking embedded objects loose.

As usual, bones and save files from previous versions should be discarded
when upgrading to 3.1.2.]]


#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 33)."
# Contents:  MANIFEST_P2 include src sys sys/amiga sys/amiga/amilib.c
#   sys/amiga/splitter sys/amiga/winfuncs.c sys/mac sys/mac/dprintf.c
#   sys/msdos sys/os2 sys/share sys/unix sys/winnt
# Wrapped by billr@saab on Thu Jun 10 16:54:59 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'MANIFEST_P2' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'MANIFEST_P2'\" to \"'MANIFEST_P2.orig'\"
  mv -f 'MANIFEST_P2' 'MANIFEST_P2.orig'
fi
echo shar: Extracting \"'MANIFEST_P2'\" \(2660 characters\)
sed "s/^X//" >'MANIFEST_P2' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X MANIFEST_P2                1	This shipping list
X UPDATE2                    9	
X include                    1	
X include/mactty.h          33	
X include/mttypriv.h         3	
X include/ntconf.h           9	
X patches02a                 8	
X patches02b                 7	
X patches02c                18	
X patches02d                 4	
X patches02e                15	
X patches02f                10	
X patches02g                20	
X patches02h                11	
X patches02i                 3	
X patches02j                19	
X patches02k                17	
X patches02l                13	
X patches02m                 2	
X patches02n                 5	
X patches02o                14	
X patches02p.1              22	
X patches02p.2              25	
X patches02q                 9	
X patches02r                32	
X patches02s                12	
X patches02t.uu1             6	
X patches02t.uu2            32	
X patches02u                32	
X patchit.sh                 7	
X src                        1	
X src/ball.c                23	
X src/sounds.c              22	
X sys                        1	
X sys/amiga                  1	
X sys/amiga/amifont8.uu     16	
X sys/amiga/amilib.c         1	
X sys/amiga/amitty.c         8	
X sys/amiga/charwin.uu      14	
X sys/amiga/colors.uu        7	
X sys/amiga/randwin.uu       8	
X sys/amiga/splitter         1	
X sys/amiga/splitter/splitter.c 28	
X sys/amiga/wbwin.c         16	
X sys/amiga/wbwin.uu        31	
X sys/amiga/winami.c        28	
X sys/amiga/windefs.h       13	
X sys/amiga/winext.h         6	
X sys/amiga/winfuncs.c       1	
X sys/amiga/winkey.c         5	
X sys/amiga/winmenu.c       24	
X sys/amiga/winproto.h      18	
X sys/amiga/winreq.c        27	
X sys/amiga/winstr.c        33	
X sys/mac                    1	
X sys/mac/NHDeflts           4	
X sys/mac/NHmake.hqx        24	
X sys/mac/NHrez.hqx         15	
X sys/mac/NHrsrc.hqx        26	
X sys/mac/dprintf.c          1	
X sys/mac/macmenu.c.uu      27	
X sys/mac/mactty.c          23	
X sys/mac/mrecover.c        30	
X sys/mac/mrecover.hqx      17	
X sys/mac/mttymain.c        31	
X sys/msdos                  1	
X sys/msdos/trampoli.c      29	
X sys/msdos/video.c         31	
X sys/os2                    1	
X sys/os2/Install.os2       30	
X sys/share                  1	
X sys/share/dgn_lex.c       25	
X sys/share/lev_lex.c       21	
X sys/share/pcsys.c         28	
X sys/share/termcap.uu      29	
X sys/unix                   1	
X sys/unix/snd86unx.shr     26	
X sys/winnt                  1	
X sys/winnt/Install.nt      30	
X sys/winnt/nhincl.mak      33	
X sys/winnt/nttty.c         29	
X sys/winnt/winnt.cnf       10	
END_OF_FILE
if test 2660 -ne `wc -c <'MANIFEST_P2'`; then
    echo shar: \"'MANIFEST_P2'\" unpacked with wrong size!
fi
# end of 'MANIFEST_P2'
if test ! -d 'include' ; then
    echo shar: Creating directory \"'include'\"
    mkdir 'include'
fi
if test ! -d 'src' ; then
    echo shar: Creating directory \"'src'\"
    mkdir 'src'
fi
if test ! -d 'sys' ; then
    echo shar: Creating directory \"'sys'\"
    mkdir 'sys'
fi
if test ! -d 'sys/amiga' ; then
    echo shar: Creating directory \"'sys/amiga'\"
    mkdir 'sys/amiga'
fi
if test -f 'sys/amiga/amilib.c' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'sys/amiga/amilib.c'\" to \"'sys/amiga/amilib.c.orig'\"
  mv -f 'sys/amiga/amilib.c' 'sys/amiga/amilib.c.orig'
fi
echo shar: Extracting \"'sys/amiga/amilib.c'\" \(7470 characters\)
sed "s/^X//" >'sys/amiga/amilib.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)amilib.c	3.1	93/04/26	*/
X/* Copyright (c) Gregg Wonderly, Naperville, Illinois,  1991,1992,1993. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include "hack.h"
X#include "wintype.h"
X#include "winami.h"
X#include "func_tab.h"
X
X#ifdef AMIGA_INTUITION
X
X#include <exec/types.h>
X#include <graphics/gfxbase.h>
X#include <intuition/intuition.h>
X#include <intuition/intuitionbase.h>
X#include <libraries/dosextens.h>
X#include <ctype.h>
X#undef  strcmpi
X#include <string.h>
X#include <errno.h>
X
X#ifdef  IDCMP_CLOSEWINDOW
X# define	INTUI_NEW_LOOK
X#endif
X
X#ifdef AZTEC_C
X#include <functions.h>
X#else
X#include <dos.h>
X#include <proto/exec.h>
X#endif
X
X#include "Amiga:lib/amilib.h"
X
X#include "Amiga:winami.p"
X#include "Amiga:amiwind.p"
X
XWinamiBASE *WinamiBase = 0;
X
Xextern char *roles[];
Xextern char orgdir[];
X
Xstruct Library *ConsoleDevice = 0;
Xint bigscreen = 0;
Xchar Initialized = 0;
Xstruct amii_DisplayDesc *amiIDisplay = 0;
Xstruct Screen *HackScreen = 0;
Xwinid WIN_BASE = WIN_ERR;
Xwinid amii_rawprwin = WIN_ERR;
X
X/*void genl_botl_flush( void );*/
Xvoid amii_outrip( winid, int );
Xvoid setup_librefs( WinamiBASE * );
X
X/* The current color map */
Xunsigned short amii_initmap[] = {
X#define C_BLACK		0
X#define C_WHITE		1
X#define C_BROWN		2
X#define C_CYAN		3
X#define C_GREEN		4
X#define C_MAGENTA	5
X#define C_BLUE		6
X#define C_RED		7
X
X    0x0000, /* color #0 */
X    0x0FFF, /* color #1 */
X    0x0830, /* color #2 */
X    0x07ac, /* color #3 */
X    0x0181, /* color #4 */
X    0x0C06, /* color #5 */
X    0x023E, /* color #6 */
X    0x0c00  /* color #7 */
X};
X
X
X
X/* Interface definition, for use by windows.c and winprocs.h to provide
X * the simple intuition interface for the amiga...
X */
Xstruct window_procs amii_procs =
X{
X    "amii",
X    amii_init_nhwindows,
X    amii_player_selection,
X    amii_askname,
X    amii_get_nh_event,
X    amii_exit_nhwindows,
X    amii_suspend_nhwindows,
X    amii_resume_nhwindows,
X    amii_create_nhwindow,
X    amii_clear_nhwindow,
X    amii_display_nhwindow,
X    amii_destroy_nhwindow,
X    amii_curs,
X    amii_putstr,
X    amii_display_file,
X    amii_start_menu,
X    amii_add_menu,
X    amii_end_menu,
X    amii_select_menu,
X    amii_update_inventory,
X    amii_mark_synch,
X    amii_wait_synch,
X#ifdef CLIPPING
X    amii_cliparound,
X#endif
X    amii_print_glyph,
X    amii_raw_print,
X    amii_raw_print_bold,
X    amii_nhgetch,
X    amii_nh_poskey,
X    amii_bell,
X    amii_doprev_message,
X    amii_yn_function,
X    amii_getlin,
X#ifdef COM_COMPL
X    amii_get_ext_cmd,
X#endif /* COM_COMPL */
X    amii_number_pad,
X    amii_delay_output,
X    /* other defs that really should go away (they're tty specific) */
X#ifdef CHANGE_COLOR
X    amii_delay_output,
X    amii_delay_output,
X#endif
X    amii_delay_output,
X    amii_delay_output,
X
X    amii_outrip,
X};
X
X
X/* Interface definition, for use by windows.c and winprocs.h to provide
X * the view window interface to nethack...
X */
Xstruct window_procs amiv_procs =
X{
X    "amiv",
X    amii_init_nhwindows,
X    amii_player_selection,
X    amii_askname,
X    amii_get_nh_event,
X    amii_exit_nhwindows,
X    amii_suspend_nhwindows,
X    amii_resume_nhwindows,
X    amii_create_nhwindow,
X    amii_clear_nhwindow,
X    amii_display_nhwindow,
X    amii_destroy_nhwindow,
X    amii_curs,
X    amii_putstr,
X    amii_display_file,
X    amii_start_menu,
X    amii_add_menu,
X    amii_end_menu,
X    amii_select_menu,
X    amii_update_inventory,
X    amii_mark_synch,
X    amii_wait_synch,
X#ifdef CLIPPING
X    amii_cliparound,
X#endif
X    amii_print_glyph,
X    amii_raw_print,
X    amii_raw_print_bold,
X    amii_nhgetch,
X    amii_nh_poskey,
X    amii_bell,
X    amii_doprev_message,
X    amii_yn_function,
X    amii_getlin,
X#ifdef COM_COMPL
X    amii_get_ext_cmd,
X#endif /* COM_COMPL */
X    amii_number_pad,
X    amii_delay_output,
X    /* other defs that really should go away (they're tty specific) */
X#ifdef CHANGE_COLOR
X    amii_delay_output,
X    amii_delay_output,
X#endif
X    amii_delay_output,
X    amii_delay_output,
X
X    amii_outrip,
X};
X
Xvoid
Xamii_loadlib( void )
X{
X    /* Close the library if opened it already (switching display types) */
X    if( WinamiBase )
X	CloseLibrary( (struct Library *)WinamiBase );
X
X    if( ( WinamiBase = ( WinamiBASE *)OpenLibrary( "winami.library", 0 ) ) == NULL )
X    {
X	panic( "can't find winami.library" );
X    }
X    setup_librefs( WinamiBase );
X}
X
Xvoid
Xamiv_loadlib( void )
X{
X    /* Close the library if opened it already (switching display types) */
X    if( WinamiBase )
X	CloseLibrary( (struct Library *)WinamiBase );
X
X    if( ( WinamiBase = ( WinamiBASE *)OpenLibrary( "winamiv.library", 0 ) ) == NULL )
X    {
X	panic( "can't find winami.library" );
X    }
X    setup_librefs( WinamiBase );
X}
X
Xvoid
XCleanUp()
X{
X    if( WinamiBase )
X    {
X	CloseLibrary( (struct Library *)WinamiBase );
X	WinamiBase = NULL;
X    }
X}
X
X/* The library has references to the following code and data items in the main
X * game, so fill in the access pointers for it to user...uggghhh...
X */
Xvoid
Xsetup_librefs( base )
X	WinamiBASE *base;
X{
X    base->G_pline = pline;
X    base->G_display_inventory = display_inventory;
X    base->G_terminate = terminate;
X    base->G_rnd = rnd;
X    base->G_panic = panic;
X    base->G_clearlocks = clearlocks;
X    base->G_on_level = on_level;
X    base->G_exit = exit;
X    base->G_lowc = lowc;
X    base->G_alloc = alloc;
X    base->G_Abort = Abort;
X    base->G_error = error;
X    base->G_fopenp = fopenp;
X/*    base->G_genl_botl_flush = genl_botl_flush; */
X
X    base->G_yn_number = &yn_number;
X    base->G_zapcolors = zapcolors;
X    base->G_plname = plname;
X    base->G_objects = objects;
X    base->G_monsyms = monsyms;
X    base->G_extcmdlist = extcmdlist;
X    base->G_flags = &flags;
X    base->G_oc_syms = oc_syms;
X    base->G_showsyms = showsyms;
X    base->G_quitchars = quitchars;
X    base->G_pl_character = pl_character;
X    base->G_WIN_MESSAGE = &WIN_MESSAGE;
X    base->G_WIN_MAP = &WIN_MAP;
X    base->G_tc_gbl_data = &tc_gbl_data;
X    base->G_defsyms = defsyms;
X    base->G_WIN_STATUS = &WIN_STATUS;
X    base->G_u = &u;
X    base->G_roles = roles;
X    base->G_dungeon_topology = &dungeon_topology;
X    base->G_toplines = toplines;
X    base->G_WIN_INVEN = &WIN_INVEN;
X    base->G_windowprocs = &windowprocs;
X    base->G_orgdir = orgdir;
X    base->G_mons = mons;
X    base->G_amiIDisplay = &amiIDisplay;
X    base->G_HackScreen = &HackScreen;
X    base->G_pl_classes = pl_classes;
X    base->G_bigscreen = &bigscreen;
X    base->G_WINBASE = &WIN_BASE;
X    base->G_amii_rawprwin = &amii_rawprwin;
X    base->G_amii_initmap = amii_initmap;
X    base->G_Initialized = &Initialized;
X    base->G_ConsoleDevice = &ConsoleDevice;
X    base->G_amii_procs = &amii_procs;
X}
X#endif
X
Xvoid Abort(rc)
Xlong rc;
X{
X#ifdef CHDIR
X    chdir(orgdir);
X#endif
X    if (Initialized && ConsoleDevice) {
X	printf("\n\nAbort with alert code %08lx...\n", rc);
X	amii_getret();
X    } else
X	Alert(rc);
X#ifdef __SASC
X    {
X/*  __emit(0x4afc);     /* illegal instruction */
X    __emit(0x40fc);     /* divide by */
X    __emit(0x0000);     /*  #0  */
X	/* NOTE: don't move CleanUp() above here - */
X	/* it is too likely to kill the system     */
X	/* before it can get the SnapShot out, if  */
X	/* there is something really wrong.    */
X    }
X#endif
X    CleanUp();
X#undef exit
X#ifdef AZTEC_C
X    _abort();
X#endif
X    exit((int) rc);
X}
X
X/* fatal error */
X/*VARARGS1*/
Xvoid error VA_DECL(const char *, s)
X    VA_START(s);
X    VA_INIT(s, char *);
X
X    putchar('\n');
X    vprintf(s, VA_ARGS);
X    putchar('\n');
X
X    VA_END();
X    Abort(0L);
X}
X
END_OF_FILE
if test 7470 -ne `wc -c <'sys/amiga/amilib.c'`; then
    echo shar: \"'sys/amiga/amilib.c'\" unpacked with wrong size!
fi
# end of 'sys/amiga/amilib.c'
if test ! -d 'sys/amiga/splitter' ; then
    echo shar: Creating directory \"'sys/amiga/splitter'\"
    mkdir 'sys/amiga/splitter'
fi
if test -f 'sys/amiga/winfuncs.c' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'sys/amiga/winfuncs.c'\" to \"'sys/amiga/winfuncs.c.orig'\"
  mv -f 'sys/amiga/winfuncs.c' 'sys/amiga/winfuncs.c.orig'
fi
echo shar: Extracting \"'sys/amiga/winfuncs.c'\" \(40043 characters\)
sed "s/^X//" >'sys/amiga/winfuncs.c' <<'END_OF_FILE'
X/*    SCCS Id: @(#)winfuncs.c    3.1    93/04/02 */
X/* Copyright (c) Gregg Wonderly, Naperville, Illinois,  1991,1992,1993. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include "amiga:windefs.h"
X#include "amiga:winext.h"
X#include "amiga:winproto.h"
X#include "incl:patchlevel.h"
X
Xint topl_addspace=1;
X
X
Xvoid
Xamii_destroy_nhwindow(win)      /* just hide */
X    register winid win;
X{
X    register struct amii_WinDesc *cw;
X
X    if( win == WIN_ERR || ( cw = amii_wins[win] ) == NULL )
X    {
X	panic(winpanicstr,win,"destroy_nhwindow");
X    }
X
X#ifdef	VIEWWINDOW
X    if( cw->type == NHW_MAP )
X    {
X	amii_destroy_nhwindow( WIN_VIEW );
X	amii_destroy_nhwindow( WIN_VIEWBOX );
X
X	/* If inventory is up, close it now, it will be freed later */
X	if( alwaysinvent && WIN_INVEN != WIN_ERR &&
X			    amii_wins[ WIN_INVEN ] &&
X			    amii_wins[ WIN_INVEN ]->win )
X	{
X	    dismiss_nhwindow( WIN_INVEN );
X	}
X    }
X#endif
X
X    /* Tear down the Intuition stuff */
X    dismiss_nhwindow(win);
X
X    if( cw->resp )
X	free( cw->resp );
X    cw->resp = NULL;
X
X    if( cw->canresp )
X	free( cw->canresp );
X    cw->canresp = NULL;
X
X    if( cw->morestr )
X	free( cw->morestr );
X    cw->morestr = NULL;
X
X    free( cw );
X    amii_wins[win] = NULL;
X}
X
Xamii_create_nhwindow(type)
X    register int type;
X{
X    register struct Window *w = NULL;
X    register struct NewWindow *nw = NULL;
X    register struct amii_WinDesc *wd = NULL;
X    struct Window *mapwin = NULL, *stwin = NULL, *msgwin = NULL;
X    register int newid;
X    int maph;
X
X    maph = ( 22 * MAPFTHEIGHT ) + HackScreen->WBorTop +
X			HackScreen->WBorBottom + MAPFTHEIGHT + 1 + 1;
X    if( WIN_STATUS != WIN_ERR && amii_wins[ WIN_STATUS ] )
X	stwin = amii_wins[ WIN_STATUS ]->win;
X
X    if( WIN_MESSAGE != WIN_ERR && amii_wins[ WIN_MESSAGE ] )
X	msgwin = amii_wins[ WIN_MESSAGE ]->win;
X
X    if( WIN_MAP != WIN_ERR && amii_wins[ WIN_MAP ] )
X	mapwin = amii_wins[ WIN_MAP ]->win;
X
X    /* Create Port anytime that we need it */
X
X    if( HackPort == NULL )
X    {
X	HackPort = CreatePort( NULL, 0 );
X	if( !HackPort )
X	    panic( "no memory for msg port" );
X    }
X
X    nw = &new_wins[ type ].newwin;
X    nw->Width = amiIDisplay->xpix;
X    nw->Screen = HackScreen;
X
X    nw->DetailPen = C_BLACK;
X    nw->BlockPen = C_WHITE;
X
X    if( type == NHW_MAP || type == NHW_BASE )
X    {
X	nw->LeftEdge = 0;
X
X	if(
X#ifndef	VIEWWINDOW
X		bigscreen &&
X#endif
X		type == NHW_MAP )
X	{
X	    nw->Height = maph;
X	    if( msgwin && stwin )
X	    {
X		nw->TopEdge = msgwin->TopEdge + msgwin->Height +
X			    ((stwin->TopEdge-
X			    (msgwin->TopEdge + msgwin->Height)-maph))/2;
X	    }
X	    else
X	    {
X		panic( "msgwin and stwin must open before map" );
X	    }
X#ifdef	VIEWWINDOW
X	    if( !bigscreen )
X		nw->Flags &= ~(BORDERLESS);
X	    nw->Width = (MAPFTWIDTH * 80) + HackScreen->WBorLeft +
X						HackScreen->WBorRight;
X#else
X	    nw->Width = HackScreen->Width;
X#endif
X	}
X	else
X	{
X	    nw->TopEdge = 1;
X	    nw->Height = amiIDisplay->ypix - nw->TopEdge;
X	}
X    }
X#ifdef	VIEWWINDOW
X    else if( type == NHW_VIEWBOX )
X    {
X	struct Window *w = amii_wins[ NHW_MAP ]->win;
X
X	nw->LeftEdge = w->Width;
X	nw->TopEdge = w->TopEdge;
X	nw->Width = amiIDisplay->xpix - nw->LeftEdge;
X	if( msgwin && stwin )
X	{
X	    nw->Height = stwin->TopEdge - nw->TopEdge;
X	}
X	else
X	{
X	    nw->Height = 10 * VIEWCHARHEIGHT +
X		    w->BorderTop + w->BorderBottom;
X	}
X	nw->MaxHeight = VIEWCHARHEIGHT*24;
X	nw->MaxWidth = VIEWCHARWIDTH*80;
X	if( nw->TopEdge + nw->Height > amiIDisplay->ypix - 1 )
X	    nw->Height = amiIDisplay->ypix - nw->TopEdge - 1;
X	if( !bigscreen )
X	    nw->Flags &= ~(WINDOWSIZING|WINDOWDRAG|WINDOWDEPTH|WINDOWCLOSE);
X    }
X    else if( type == NHW_VIEW )
X    {
X	struct Window *vw = amii_wins[ WIN_VIEWBOX ]->win;
X	int i;
X
X	nw->LeftEdge = vw->LeftEdge + vw->BorderLeft;
X	nw->TopEdge = vw->TopEdge + vw->BorderTop;
X	nw->Width = amiIDisplay->xpix - nw->LeftEdge - 1 - vw->BorderRight;
X	nw->Height = vw->Height - vw->BorderTop - vw->BorderBottom;
X	nw->MaxHeight = VIEWCHARHEIGHT*24;
X	nw->MaxWidth = VIEWCHARWIDTH*80;
X	if( nw->TopEdge + nw->Height > amiIDisplay->ypix - 1 )
X	    nw->Height = amiIDisplay->ypix - nw->TopEdge - 1;
X	InitBitMap( &amii_vbm, DEPTH, VIEWCHARWIDTH * 88, VIEWCHARHEIGHT * 30 );
X	for( i = 0; i < DEPTH; ++i )
X	{
X	    if( ( amii_vbm.Planes[i] = AllocRaster( VIEWCHARWIDTH * 88,
X							VIEWCHARHEIGHT * 30 ) ) == 0 )
X	    {
X		panic( "can't allocate bitmap for view window" );
X	    }
X	    memset( amii_vbm.Planes[i], 0,
X	    			RASSIZE( VIEWCHARWIDTH * 88, VIEWCHARHEIGHT * 30 ) );
X	}
X	nw->Flags |= SUPER_BITMAP;
X	nw->BitMap = &amii_vbm;
X    }
X#endif
X    else if( type == NHW_STATUS )
X    {
X#ifndef	VIEWWINDOW
X	if( WIN_MAP != WIN_ERR && amii_wins[ WIN_MAP ] )
X	    w = amii_wins[ WIN_MAP ]->win;
X	else
X#endif
X	if( WIN_BASE != WIN_ERR && amii_wins[ WIN_BASE ] )
X	    w = amii_wins[ WIN_BASE ]->win;
X	else
X	    panic( "No window to base STATUS location from" );
X
X	/* Status window is relative to bottom of WIN_BASE/WIN_MAP */
X
X	/* Expand the height of window by borders */
X	nw->Height = (txheight * 2) + 4;
X	if( bigscreen )
X	{
X	    nw->Height += txheight + w->WScreen->WBorTop + 1 + w->WScreen->WBorBottom;
X	}
X
X	nw->TopEdge = amiIDisplay->ypix - nw->Height - 1;
X	nw->LeftEdge = w->LeftEdge;
X	if( nw->LeftEdge + nw->Width >= amiIDisplay->xpix )
X	    nw->LeftEdge = 0;
X	if( nw->Width >= amiIDisplay->xpix - nw->LeftEdge )
X	    nw->Width = amiIDisplay->xpix - nw->LeftEdge;
X    }
X    else if( type == NHW_MESSAGE )
X    {
X#ifndef	VIEWWINDOW
X	if( WIN_MAP != WIN_ERR && amii_wins[ WIN_MAP ] )
X	    w = amii_wins[ WIN_MAP ]->win;
X	else
X#endif
X	if( WIN_BASE != WIN_ERR && amii_wins[ WIN_BASE ] )
X	    w = amii_wins[ WIN_BASE ]->win;
X	else
X	    panic( "No window to base STATUS location from" );
X
X	nw->TopEdge = 1;
X	nw->Height = HackScreen->WBorTop + 1 +
X		((txheight+1)*(1+(scrollmsg != 0))) + 1 + HackScreen->WBorBottom;
X	if( scrollmsg )
X	{
X	    nw->FirstGadget = &MsgScroll;
X	    nw->Height = HackScreen->Height - 1 -
X		/* Size of all borders for bigscreen */
X		( ( TextsFont->tf_YSize + HackScreen->WBorTop + 1 +
X					HackScreen->WBorBottom ) * 2 ) -
X		/* Text space in status window */
X		( ( TextsFont->tf_YSize + 1 ) * 2 ) - 2 -
X		maph;
X	    nw->Flags |= WINDOWSIZING;
X#ifdef	VIEWWINDOW
X	    nw->Flags |= WINDOWDRAG;
X#endif
X	}
X#ifdef  INTUI_NEW_LOOK
X	if( IntuitionBase->LibNode.lib_Version >= 37 )
X	{
X	    MsgPropScroll.Flags |= PROPNEWLOOK;
X	}
X#endif
X	/* Just allow height adjustments */
X	nw->MinWidth = w->Width;
X	nw->MinHeight = HackScreen->WBorTop +
X		HackScreen->WBorBottom + ((w->RPort->TxHeight+1)*2) + 3;
X    }
X
X    nw->IDCMPFlags |= MENUPICK;
X
X    /* Check if there is "Room" for all this stuff... */
X    if( bigscreen && type != NHW_BASE && type != NHW_VIEW )
X    {
X	nw->Flags &= ~( BORDERLESS | BACKDROP );
X#ifdef	VIEWWINDOW
X	nw->Flags |= ( WINDOWDRAG | WINDOWDEPTH | SIZEBRIGHT );
X#else
X	if( HackScreen->Width < 657 )
X	{
X	    nw->Flags |= ( WINDOWDRAG | WINDOWDEPTH );
X	}
X	else
X	{
X	    nw->Flags |= ( WINDOWDRAG | WINDOWDEPTH | SIZEBRIGHT );
X	    if( type == NHW_MAP )
X		nw->Flags |= WINDOWSIZING;
X	}
X#endif
X
X/*#endif*/
X#ifdef	VIEWWINDOW
X	if( type == NHW_VIEWBOX )
X	    nw->Flags |= WINDOWSIZING;
X#endif
X    }
X
X    /* No titles on a hires only screen */
X    if( !bigscreen )
X	nw->Title = 0;
X
X    /* Don't open MENU or TEXT windows yet */
X
X    if( type == NHW_MENU || type == NHW_TEXT )
X	w = NULL;
X    else
X	w=OpenShWindow( (void *)nw );
X
X    if( w == NULL && type != NHW_MENU && type != NHW_TEXT )
X    {
X	char buf[ 100 ];
X
X	sprintf( buf, "nw is l: %d, t: %d, w: %d, h: %d",
X		nw->LeftEdge, nw->TopEdge,
X		nw->Width, nw->Height );
X	raw_print( buf );
X	panic("bad openwin %d",type);
X    }
X
X    /* Check for an empty slot */
X
X    for(newid = 0; newid<MAXWIN + 1; newid++)
X    {
X	if(amii_wins[newid] == 0)
X	    break;
X    }
X
X    if(newid==MAXWIN+1)
X	panic("time to write re-alloc code\n");
X
X    /* Set wincnt accordingly */
X
X    if( newid > wincnt )
X	wincnt = newid;
X
X    /* Do common initialization */
X
X    wd = (struct amii_WinDesc *)alloc(sizeof(struct amii_WinDesc));
X    memset( wd, 0, sizeof( struct amii_WinDesc ) );
X    amii_wins[newid] = wd;
X
X    wd->newwin = NULL;
X    wd->win = w;
X    wd->type = type;
X    wd->wflags = 0;
X    wd->active = FALSE;
X    wd->curx=wd->cury = 0;
X    wd->resp = wd->canresp = wd->morestr = 0;   /* CHECK THESE */
X    wd->maxrow = new_wins[type].maxrow;
X    wd->maxcol = new_wins[type].maxcol;
X
X    if( type != NHW_TEXT && type != NHW_MENU )
X    {
X	if( TextsFont && ( type == NHW_MESSAGE || type == NHW_STATUS ) )
X	{
X	    SetFont(w->RPort, TextsFont);
X	    txheight = w->RPort->TxHeight;
X	    txwidth = w->RPort->TxWidth;
X	    txbaseline = w->RPort->TxBaseline;
X	    if( type == NHW_MESSAGE )
X	    {
X		if( scrollmsg )
X		{
X		    WindowLimits( w, w->Width, w->BorderTop +
X				w->BorderBottom +
X				((txheight+1)*3) + 1, 0, 0 );
X		}
X		else
X		{
X		    WindowLimits( w, w->Width, w->BorderTop +
X				w->BorderBottom +
X				txheight + 2, 0, 0 );
X		}
X	    }
X	}
X#ifdef HACKFONT
X	else if( HackFont )
X	    SetFont(w->RPort, HackFont);
X#endif
X	wd->rows = ( w->Height - w->BorderTop -
X		w->BorderBottom - 2 ) / w->RPort->TxHeight;
X	wd->cols = ( w->Width - w->BorderLeft -
X		w->BorderRight - 2 ) / w->RPort->TxWidth;
X    }
X
X    /* Okay, now do the individual type initialization */
X
X    switch(type)
X    {
X	/* History lines for MESSAGE windows are stored in cw->data[?].
X	 * maxcol and maxrow are used as cursors.  maxrow is the count
X	 * of the number of history lines stored.  maxcol is the cursor
X	 * to the last line that was displayed by ^P.
X	 */
X	case NHW_MESSAGE:
X	    SetMenuStrip(w, HackMenu);
X#ifdef	VIEWWINDOW
X	    if(flags.msg_history<20)flags.msg_history=20;
X#else
X	    if(flags.msg_history<40)flags.msg_history=40;
X#endif
X	    if(flags.msg_history>400)flags.msg_history=400;
X	    flags.window_inited=TRUE;
X	    wd->data = (char **)alloc( flags.msg_history*sizeof( char * ) );
X	    memset( wd->data, 0, flags.msg_history * sizeof( char * ) );
X	    wd->maxrow = wd->maxcol = 0;
X	    /* Indicate that we have not positioned the cursor yet */
X	    wd->curx = -1;
X	    break;
X
X	    /* A MENU contains a list of lines in wd->data[?].  These
X	     * lines are created in amii_putstr() by reallocating the size
X	     * of wd->data to hold enough (char *)'s.  wd->rows is the
X	     * number of (char *)'s allocated.  wd->maxrow is the number
X	     * used.  wd->maxcol is used to track how wide the menu needs
X	     * to be.  wd->resp[x] contains the characters that correspond
X	     * to selecting wd->data[x].  wd->resp[x] corresponds to
X	     * wd->data[x] for any x. Elements of wd->data[?] that are not
X	     * valid selections have the corresponding element of
X	     * wd->resp[] set to a value of '\01';  i.e. a ^A which is
X	     * not currently a valid keystroke for responding to any
X	     * MENU or TEXT window.
X	     */
X	case NHW_MENU:
X	    wd->resp=(char*)alloc(256);
X	    wd->resp[0]=0;
X	    wd->rows = wd->maxrow = 0;
X	    wd->cols = wd->maxcol = 0;
X	    wd->data = NULL;
X	    break;
X
X	    /* See the explanation of MENU above.  Except, wd->resp[] is not
X	     * used for TEXT windows since there is no selection of a
X	     * a line performed/allowed.  The window is always full
X	     * screen width.
X	     */
X	case NHW_TEXT:
X	    wd->rows = wd->maxrow = 0;
X	    wd->cols = wd->maxcol = amiIDisplay->cols;
X	    wd->data = NULL;
X	    wd->morestr = NULL;
X	    break;
X
X	    /* The status window has only two lines.  These are stored in
X	     * wd->data[], and here we allocate the space for them.
X	     */
X	case NHW_STATUS:
X	    SetMenuStrip(w, HackMenu);
X	    /* wd->cols is the number of characters which fit across the
X	     * screen.
X	     */
X	    wd->data=(char **)alloc(3*sizeof(char *));
X	    wd->data[0] = (char *)alloc(wd->cols + 10);
X	    wd->data[1] = (char *)alloc(wd->cols + 10);
X	    wd->data[2] = NULL;
X	    break;
X
X	    /* NHW_MAP does not use wd->data[] or the other text
X	     * manipulating members of the amii_WinDesc structure.
X	     */
X	case NHW_MAP:
X	    SetMenuStrip(w, HackMenu);
X#ifdef	VIEWWINDOW
X	    WIN_VIEWBOX = amii_create_nhwindow( NHW_VIEWBOX );
X	    WIN_VIEW = amii_create_nhwindow( NHW_VIEW );
X	    if( HackFont4 )
X		SetFont( w->RPort, HackFont4 );
X#else
X	    if( HackFont )
X		SetFont( w->RPort, HackFont );
X#endif
X	    break;
X
X	    /* The base window must exist until CleanUp() deletes it. */
X	case NHW_BASE:
X	    SetMenuStrip(w, HackMenu);
X	    /* Make our requesters come to our screen */
X	    {
X		register struct Process *myProcess =
X					(struct Process *) FindTask(NULL);
X		pr_WindowPtr = (struct Window *)(myProcess->pr_WindowPtr);
X		myProcess->pr_WindowPtr = (APTR) w;
X	    }
X
X	    /* Need this for RawKeyConvert() */
X
X	    ConsoleIO.io_Data = (APTR) w;
X	    ConsoleIO.io_Length = sizeof( struct Window );
X	    ConsoleIO.io_Message.mn_ReplyPort = CreatePort(NULL, 0L);
X	    if( OpenDevice("console.device", -1L,
X				(struct IORequest *) &ConsoleIO, 0L) != 0)
X	    {
X		Abort(AG_OpenDev | AO_ConsoleDev);
X	    }
X
X	    ConsoleDevice = (struct Library *) ConsoleIO.io_Device;
X
X	    KbdBuffered = 0;
X
X#ifdef HACKFONT
X	    if( TextsFont )
X		SetFont( w->RPort, TextsFont );
X	    else if( HackFont )
X		SetFont( w->RPort, HackFont );
X#endif
X	    txwidth = w->RPort->TxWidth;
X	    txheight = w->RPort->TxHeight;
X	    txbaseline = w->RPort->TxBaseline;
X	    break;
X
X#ifdef	VIEWWINDOW
X	case NHW_VIEWBOX:
X	    /* Position BitMap at zero, zero */
X	    ScrollLayer( 0, w->RPort->Layer,
X				-w->RPort->Layer->Scroll_X,
X				  -w->RPort->Layer->Scroll_Y );
X	case NHW_VIEW:
X	    if( HackFont16 )
X		SetFont( w->RPort, HackFont16 );
X	    wd->curx = -1;
X	    wd->cury = -1;
X	    SetMenuStrip(w, HackMenu);
X	    break;
X#endif
X
X	default:
X	    panic("bad create_nhwindow( %d )\n",type);
X	    return WIN_ERR;
X    }
X
X    return( newid );
X}
X
X/* Initialize the windowing environment */
X
Xvoid
Xamii_init_nhwindows()
X{
X    if (HackScreen)
X	panic( "init_nhwindow() called twice", 0 );
X
X    WIN_MESSAGE = WIN_ERR;
X    WIN_MAP = WIN_ERR;
X    WIN_STATUS = WIN_ERR;
X    WIN_INVEN = WIN_ERR;
X    WIN_BASE = WIN_ERR;
X
X#ifndef	SHAREDLIB
X    if ( (IntuitionBase = (struct IntuitionBase *)
X	  OpenLibrary("intuition.library", INTUITION_VERSION)) == NULL)
X    {
X	Abort(AG_OpenLib | AO_Intuition);
X    }
X
X    if ( (GfxBase = (struct GfxBase *)
X	      OpenLibrary("graphics.library", GRAPHICS_VERSION)) == NULL)
X    {
X	Abort(AG_OpenLib | AO_GraphicsLib);
X    }
X
X#ifdef	VIEWWINDOW
X    if ( (LayersBase = (struct Library *)
X		OpenLibrary("layers.library", 0)) == NULL)
X    {
X	Abort(AG_OpenLib | AO_LayersLib);
X    }
X#endif
X#endif
X    amiIDisplay=(struct amii_DisplayDesc *)alloc(sizeof(struct amii_DisplayDesc));
X    memset( amiIDisplay, 0, sizeof( struct amii_DisplayDesc ) );
X
X    /* Use Intuition sizes for overscan screens... */
X
X    amiIDisplay->ypix = GfxBase->NormalDisplayRows;
X    amiIDisplay->xpix = GfxBase->NormalDisplayColumns;
X
X    amiIDisplay->cols = amiIDisplay->xpix / FONTWIDTH;
X
X    amiIDisplay->toplin=0;
X    amiIDisplay->rawprint=0;
X    amiIDisplay->lastwin=0;
X
X    if( bigscreen == 0 )
X    {
X	if( ( GfxBase->ActiView->ViewPort->Modes & LACE ) == LACE )
X	{
X	    amiIDisplay->ypix *= 2;
X	    NewHackScreen.ViewModes |= LACE;
X	    bigscreen = 1;
X	}
X	else if( GfxBase->NormalDisplayRows >= 240 )
X	{
X	    bigscreen = 1;
X	}
X    }
X    else if( bigscreen == -1 )
X	bigscreen = 0;
X    else if( bigscreen )
X    {
X	/* If bigscreen requested and we don't have enough rows in
X	 * noninterlaced mode, switch to interlaced...
X	 */
X	if( GfxBase->NormalDisplayRows < 240 )
X	{
X	    amiIDisplay->ypix *= 2;
X	    NewHackScreen.ViewModes |= LACE;
X	}
X    }
X
X    if( !bigscreen )
X    {
X    	scrollmsg = 0;
X    	alwaysinvent = 0;
X    }
X    amiIDisplay->rows = amiIDisplay->ypix / FONTHEIGHT;
X
X#ifdef HACKFONT
X    /*
X     *  Load the fonts that we need.
X     */
X
X    if( DiskfontBase =
X		OpenLibrary( "diskfont.library", DISKFONT_VERSION ) )
X    {
X	Hack80.ta_Name -= SIZEOF_DISKNAME;
X	HackFont = OpenDiskFont( &Hack80 );
X	Hack80.ta_Name += SIZEOF_DISKNAME;
X
X#ifdef	VIEWWINDOW
X	Hack40.ta_Name -= SIZEOF_DISKNAME;
X	HackFont4 = OpenDiskFont( &Hack40 );
X	Hack40.ta_Name += SIZEOF_DISKNAME;
X
X	Hack160.ta_Name -= SIZEOF_DISKNAME;
X	HackFont16 = OpenDiskFont( &Hack160 );
X	Hack160.ta_Name += SIZEOF_DISKNAME;
X#endif
X	/* Textsfont13 is filled in with "FONT=" settings. The default is
X	 * courier/13.
X	 */
X	TextsFont = NULL;
X	if( bigscreen )
X	    TextsFont = OpenDiskFont( &TextsFont13 );
X
X	/* Try hack/8 for texts if no user specified font */
X	if( TextsFont == NULL )
X	{
X	    Hack80.ta_Name -= SIZEOF_DISKNAME;
X	    TextsFont = OpenDiskFont( &Hack80 );
X	    Hack80.ta_Name += SIZEOF_DISKNAME;
X	}
X
X	/* If no fonts, make everything topaz 8 for non-view windows.
X	 */
X	if( !HackFont || !TextsFont )
X	{
X	    Hack80.ta_Name = "topaz.font";
X	    if( !HackFont )
X	    {
X		HackFont = OpenFont( &Hack80 );
X		if( !HackFont )
X		    panic( "Can't get a map font, topaz:8" );
X	    }
X
X	    if( !TextsFont )
X	    {
X		TextsFont = OpenFont( &Hack80 );
X		if( !TextsFont )
X		    panic( "Can't open text font" );
X	    }
X	}
X#ifdef	VIEWWINDOW
X	/*
X	 * These other fonts are required for the view windows, so
X	 * we have to "panic".
X	 */
X	if( !HackFont4 || !HackFont16 )
X	{
X	    panic( "Can't open all hack/4 or hack/16 font" );
X	}
X#endif
X	CloseLibrary(DiskfontBase);
X	DiskfontBase = NULL;
X    }
X#endif
X
X    /* This is the size screen we want to open, within reason... */
X
X    NewHackScreen.Width = max( WIDTH, amiIDisplay->xpix );
X    NewHackScreen.Height = max( SCREENHEIGHT, amiIDisplay->ypix );
X    {
X    static char fname[18];
X    sprintf(fname,"NetHack %d.%d.%d", VERSION_MAJOR, VERSION_MINOR, PATCHLEVEL);
X    NewHackScreen.DefaultTitle=fname;
X    }
X    NewHackScreen.BlockPen = C_CYAN;
X#ifdef	INTUI_NEW_LOOK
X    if( IntuitionBase->LibNode.lib_Version >= 37 && bigscreen )
X    {
X	NewHackScreen.Width = STDSCREENWIDTH;
X	NewHackScreen.Height = STDSCREENHEIGHT;
X    }
X#endif
X
X    if( ( HackScreen = OpenScreen( (void *)&NewHackScreen ) ) == NULL )
X	Abort( AN_OpenScreen & ~AT_DeadEnd );
X#ifdef  INTUI_NEW_LOOK
X    if( IntuitionBase->LibNode.lib_Version >= 37 )
X	PubScreenStatus( HackScreen, 0 );
X#endif
X
X    amiIDisplay->ypix = HackScreen->Height;
X    amiIDisplay->xpix = HackScreen->Width;
X
X#ifdef TEXTCOLOR
X    LoadRGB4(&HackScreen->ViewPort, flags.amii_curmap, 1L << DEPTH );
X#endif
X
X    /* Display the copyright etc... */
X
X    if( WIN_BASE == WIN_ERR )
X	WIN_BASE = amii_create_nhwindow( NHW_BASE );
X    amii_clear_nhwindow( WIN_BASE );
X    amii_putstr( WIN_BASE, 0, "" );
X    amii_putstr( WIN_BASE, 0, "" );
X    amii_putstr( WIN_BASE, 0, "" );
X    amii_putstr( WIN_BASE, 0,
X      "NetHack, Copyright 1985, 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993.");
X    amii_putstr( WIN_BASE, 0,
X	"         By Stichting Mathematisch Centrum and M. Stephenson.");
X    amii_putstr( WIN_BASE, 0, "         See license for details.");
X    amii_putstr( WIN_BASE, 0, "");
X
X    Initialized = 1;
X}
X
X/* Clear the indicated window */
X
Xvoid
Xamii_clear_nhwindow(win)
X    register winid win;
X{
X    register struct amii_WinDesc *cw;
X    register struct Window *w;
X
X    if( win == WIN_ERR || ( cw = amii_wins[win] ) == NULL )
X	panic( winpanicstr, win, "clear_nhwindow" );
X
X    if( w = cw->win )
X	SetDrMd( w->RPort, JAM2);
X
X    cursor_off( win );
X
X    /* should be: clear the rastport, reset x,y etc */
X
X    if( cw->type == NHW_MENU || cw->type == NHW_TEXT )
X    {
X	/* Window might not be opened yet */
X
X	if( w )
X	{
X	    SetAPen( w->RPort, 0 );
X	    SetBPen( w->RPort, 0 );
X	    RectFill( w->RPort, w->BorderLeft, w->BorderTop,
X	      w->Width - w->BorderRight-1,
X	      w->Height - w->BorderBottom-1 );
X	    SetAPen( w->RPort, 1 );
X	}
X    }
X    else if( w )
X    {
X	if( cw->type == NHW_MESSAGE )
X	{
X	    amii_curs( win, 1, 0 );
X	    if( !scrollmsg )
X		TextSpaces( w->RPort, cw->cols );
X	}
X	else
X	{
X	    SetAPen( w->RPort, 0 );
X	    SetBPen( w->RPort, 0 );
X	    RectFill( w->RPort, w->BorderLeft, w->BorderTop,
X	      w->Width - w->BorderRight-1,
X	      w->Height - w->BorderBottom-1 );
X	    SetAPen( w->RPort, 1 );
X#ifdef	VIEWWINDOW
X	    if( win == WIN_MAP )
X		amii_clear_nhwindow( WIN_VIEW );
X#endif
X	}
X    }
X
X    cw->cury = 0;
X    cw->curx = 0;
X    amii_curs( win, 1, 0 );
X}
X
X/* Dismiss the window from the screen */
X
Xvoid
Xdismiss_nhwindow(win)
X    register winid win;
X{
X    int i;
X    register struct Window *w;
X    register struct amii_WinDesc *cw;
X
X    if( win == WIN_ERR || ( cw = amii_wins[win] ) == NULL )
X    {
X	panic(winpanicstr,win, "dismiss_nhwindow");
X    }
X
X    w = cw->win;
X
X    if( w )
X    {
X	/* All windows have this stuff attached to them. */
X	if( win == WIN_MAP || win == WIN_BASE ||
X		win == WIN_MESSAGE || win == WIN_STATUS
X#ifdef	VIEWWINDOW
X		|| win == WIN_VIEW || win == WIN_VIEWBOX
X#endif
X		)
X	{
X	    ClearMenuStrip( w );
X	}
X
X	/* Save where user like inventory to appear */
X	if( win == WIN_INVEN )
X	{
X	    lastinvent.MinX = w->LeftEdge;
X	    lastinvent.MinY = w->TopEdge;
X	    lastinvent.MaxX = w->Width;
X	    lastinvent.MaxY = w->Height;
X	}
X
X	/* Close the window */
X	CloseShWindow( w );
X	cw->win = NULL;
X
X#ifdef	VIEWWINDOW
X	if( cw->type == NHW_VIEW )
X	{
X	    for( i = 0; i < DEPTH; ++i )
X	    {
X		FreeRaster( amii_vbm.Planes[i],
X			VIEWCHARWIDTH*88, VIEWCHARHEIGHT*30 );
X	    }
X	}
X#endif
X
X	/* Free copy of NewWindow structure for TEXT/MENU windows. */
X	if( cw->newwin )
X	    FreeNewWindow( (void *)cw->newwin );
X	cw->newwin = NULL;
X    }
X
X    if( cw->canresp )
X	free( cw->canresp );
X    cw->canresp = NULL;
X
X    if( cw->morestr )
X	free( cw->morestr );
X    cw->morestr = NULL;
X
X    if( cw->data && ( cw->type == NHW_MESSAGE ||
X			    cw->type == NHW_MENU || cw->type == NHW_TEXT ) )
X    {
X	for( i = 0; i < cw->maxrow; ++i )
X	{
X	    if( cw->data[ i ] )
X		free( cw->data[ i ] );
X	}
X	free( cw->data );
X	cw->data = NULL;
X    }
X    cw->maxrow = cw->maxcol = 0;
X}
X
Xvoid
Xamii_exit_nhwindows(str)
X    const char *str;
X{
X    /* Seems strange to have to do this... but we need the BASE window
X     * left behind...
X     */
X    kill_nhwindows( 0 );
X    if( str )
X    {
X	raw_print( "\n");	/* be sure we're not under the top margin */
X	raw_print( str );
X    }
X}
X
Xvoid
Xamii_display_nhwindow(win,blocking)
X    winid win;
X    boolean blocking;
X{
X    int i;
X    static int lastwin = -1;
X    struct Window *w;
X    struct amii_WinDesc *cw;
X
X    if( !Initialized )
X	return;
X    lastwin = win;
X
X    if( win == WIN_ERR || ( cw = amii_wins[win] ) == NULL )
X	panic(winpanicstr,win,"display_nhwindow");
X
X    if( cw->type == NHW_MESSAGE )
X	cw->wflags &= ~FLMAP_SKIP;
X
X    if( w = cw->win )
X	WindowToFront( w );
X
X    if( cw->type == NHW_MESSAGE || cw->type == NHW_STATUS )
X	return;
X
X    if( WIN_MAP != WIN_ERR && amii_wins[ WIN_MAP ] )
X    {
X	flush_glyph_buffer( amii_wins[ WIN_MAP ]->win );
X    }
X
X    if( cw->type == NHW_MENU || cw->type == NHW_TEXT )
X    {
X	DoMenuScroll( win, blocking );
X    }
X    else if( cw->type==NHW_MAP )
X    {
X#ifdef	VIEWWINDOW
X	if( IntuitionBase->LibNode.lib_Version >= 37 )
X	{
X	    MoveWindowInFrontOf( amii_wins[ WIN_VIEW ]->win,
X						amii_wins[ WIN_VIEWBOX ]->win );
X	}
X	else
X	{
X	    WindowToFront( amii_wins[ WIN_VIEW ]->win );
X	}
X	amii_end_glyphout( WIN_VIEW );
X#endif
X	amii_end_glyphout( win );
X	for( i = 0; i < MAXWIN; ++i )
X	{
X	    if( ( cw = amii_wins[i] ) != NULL &&
X		( cw->type == NHW_STATUS || cw->type == NHW_MESSAGE ) &&
X		( cw->win ) )
X	    {
X		WindowToFront(cw->win);
X	    }
X	}
X
X	/* Do more if it is time... */
X	if( blocking == TRUE && amii_wins[ WIN_MESSAGE ]->curx )
X	{
X	    outmore( amii_wins[ WIN_MESSAGE ] );
X	}
X    }
X
X#ifdef	VIEWWINDOW
X    /* Pop the inventory window to the top if it is always displayed. */
X    if( alwaysinvent && WIN_INVEN != WIN_ERR &&
X		    (cw = amii_wins[ WIN_INVEN ] ) && cw->win )
X    {
X	WindowToFront( cw->win );
X    }
X#endif
X}
X
Xvoid
Xamii_curs(window, x, y)
Xwinid window;
Xregister int x, y;  /* not xchar: perhaps xchar is unsigned and
X	       curx-x would be unsigned as well */
X{
X    register struct amii_WinDesc *cw;
X    register struct Window *w;
X    register struct RastPort *rp;
X
X    if( window == WIN_ERR || ( cw = amii_wins[window] ) == NULL )
X	panic(winpanicstr,  window, "curs");
X    if( (w = cw->win) == NULL )
X    {
X	if( cw->type == NHW_MENU || cw->type == NHW_TEXT )
X	    return;
X	else
X	    panic( "No window open yet in curs() for winid %d\n", window );
X    }
X    amiIDisplay->lastwin = window;
X
X    /* Make sure x is within bounds */
X    if( x > 0 )
X	--x;    /* column 0 is never used */
X    else
X	x = 0;
X
X    cw->curx = x;
X    cw->cury = y;
X#ifdef DEBUG
X    if( x<0 || y<0 || y >= cw->rows || x >= cw->cols )
X    {
X	char *s = "[unknown type]";
X	switch(cw->type)
X	{
X	    case NHW_MESSAGE: s = "[topl window]"; break;
X	    case NHW_STATUS: s = "[status window]"; break;
X	    case NHW_MAP: s = "[map window]"; break;
X	    case NHW_MENU: s = "[menu window]"; break;
X	    case NHW_TEXT: s = "[text window]"; break;
X	}
X	impossible("bad curs positioning win %d %s (%d,%d)", window, s, x, y);
X	return;
X    }
X#endif
X
X#ifdef CLIPPING
X    if(clipping && window == WIN_MAP)
X    {
X	x -= clipx;
X	y -= clipy;
X    }
X#endif
X
X    /* Output all saved output before doing cursor movements for MAP */
X
X    if( cw->type == NHW_MAP )
X    {
X	flush_glyph_buffer( w );
X#ifdef	VIEWWINDOW
X	flush_glyph_buffer( amii_wins[ WIN_VIEW ]->win );
X#endif
X    }
X
X    /* Actually do it */
X
X    rp = w->RPort;
X    if( cw->type == NHW_MENU || cw->type == NHW_TEXT )
X    {
X	Move( rp, (x * rp->TxWidth) + w->BorderLeft + 1,
X	    (y*rp->TxHeight ) + rp->TxBaseline + w->BorderTop + 1 );
X    }
X    else if( cw->type == NHW_MAP || cw->type == NHW_BASE
X#ifdef	VIEWWINDOW
X	|| cw->type == NHW_VIEW
X#endif
X	)
X    {
X	/* These coordinate calculations must be synced with those
X	 * in flush_glyph_buffer() in amiwind.c.  curs_on_u() will
X	 * use this code, all other drawing occurs through the glyph
X	 * code.  In order for the cursor to appear on top of the hero,
X	 * the code must compute X,Y in the same manner relative to
X	 * the RastPort coordinates.
X	 *
X	 * y = w->BorderTop + (g_nodes[i].y-1) * rp->TxHeight +
X	 *   rp->TxBaseline + 1;
X	 * x = g_nodes[i].x * rp->TxWidth + w->BorderLeft;
X	 */
X
X	Move( rp, (x * w->RPort->TxWidth) + w->BorderLeft,
X			w->BorderTop + ( (y + 1) * w->RPort->TxHeight ) +
X			w->RPort->TxBaseline + 1 );
X    }
X    else if( cw->type == NHW_MESSAGE && !scrollmsg )
X    {
X	Move( rp, (x * w->RPort->TxWidth) + w->BorderLeft + 2,
X			w->BorderTop + w->RPort->TxBaseline + 3 );
X    }
X    else if( cw->type == NHW_STATUS )
X    {
X	Move( rp, (x * w->RPort->TxWidth) + w->BorderLeft + 2,
X			(y*(w->RPort->TxHeight+1)) + w->BorderTop +
X			w->RPort->TxBaseline + 1 );
X    }
X    else
X    {
X	Move( rp, (x * w->RPort->TxWidth) + w->BorderLeft + 2,
X			(y*w->RPort->TxHeight) + w->BorderTop +
X			w->RPort->TxBaseline + 1 );
X    }
X}
X
Xvoid
Xamii_set_text_font( name, size )
X    char *name;
X    int size;
X{
X    register int i;
X    register struct amii_WinDesc *cw;
X    int osize = TextsFont13.ta_YSize;
X    static char nname[ 100 ];
X
X    strncpy( nname, name, sizeof( nname ) - 1 );
X    nname[ sizeof( nname ) - 1 ] = 0;
X
X    TextsFont13.ta_Name = nname;
X    TextsFont13.ta_YSize = size;
X
X    /* No alternate text font allowed for 640x250 or smaller */
X    if( !HackScreen || !bigscreen )
X	return;
X
X    /* Look for windows to set, and change them */
X
X    if( DiskfontBase =
X		OpenLibrary( "diskfont.library", DISKFONT_VERSION ) )
X    {
X	TextsFont = OpenDiskFont( &TextsFont13 );
X	for( i = 0; TextsFont && i < MAXWIN; ++i )
X	{
X	    if( (cw = amii_wins[ i ]) && cw->win != NULL )
X	    {
X	    	switch( cw->type )
X	    	{
X	    	case NHW_STATUS:
X		    MoveWindow( cw->win, 0, -( size - osize ) * 2 );
X		    SizeWindow( cw->win, 0, ( size - osize ) * 2 );
X		    SetFont( cw->win->RPort, TextsFont );
X		    break;
X	    	case NHW_MESSAGE:
X	    	case NHW_MAP:
X	    	case NHW_BASE:
X		    SetFont( cw->win->RPort, TextsFont );
X		    break;
X	    	}
X	    }
X	}
X    }
X    CloseLibrary(DiskfontBase);
X    DiskfontBase = NULL;
X}
X
Xvoid
Xkill_nhwindows( all )
X    register int all;
X{
X    register int i;
X    register struct amii_WinDesc *cw;
X
X    /* Foreach open window in all of amii_wins[], CloseShWindow, free memory */
X
X    for( i = 0; i < MAXWIN; ++i )
X    {
X	if( (cw = amii_wins[ i ]) && (cw->type != NHW_BASE || all) )
X	{
X	    amii_destroy_nhwindow( i );
X	}
X    }
X}
X
Xvoid
Xamii_cl_end( cw, i )
X    register struct amii_WinDesc *cw;
X    register int i;
X{
X    register struct Window *w = cw->win;
X    register int oy, ox;
X
X    if( !w )
X	panic("NULL window pointer in amii_cl_end()");
X
X    oy = w->RPort->cp_y;
X    ox = w->RPort->cp_x;
X
X    TextSpaces( w->RPort, cw->cols - i );
X
X    Move( w->RPort, ox, oy );
X}
X
Xvoid
Xcursor_off( window )
X    winid window;
X{
X    register struct amii_WinDesc *cw;
X    register struct Window *w;
X    register struct RastPort *rp;
X    int curx, cury;
X    long dmode;
X    short apen, bpen;
X    unsigned char ch;
X
X    if( window == WIN_ERR || ( cw = amii_wins[window] ) == NULL )
X    {
X	flags.window_inited=0;
X	panic(winpanicstr,window, "cursor_off");
X    }
X
X    if( !(cw->wflags & FLMAP_CURSUP ) )
X	return;
X    w = cw->win;
X
X    if( !w )
X	return;
X
X    cw->wflags &= ~FLMAP_CURSUP;
X    rp = w->RPort;
X
X    /* Save the current information */
X    curx = rp->cp_x;
X    cury = rp->cp_y;
X    dmode = rp->DrawMode;
X    apen = rp->FgPen;
X    bpen = rp->BgPen;
X    SetAPen( rp, cw->curs_apen );
X    SetBPen( rp, cw->curs_bpen );
X    SetDrMd( rp, COMPLEMENT );
X
X    ch = CURSOR_CHAR;
X    Move( rp, cw->cursx, cw->cursy );
X    Text( rp, &ch, 1 );
X
X#ifdef	VIEWWINDOW
X    /* Remove view window outline from map */
X    if( window == WIN_MAP )
X    {
X	SetAPen( rp, C_RED );
X	SetBPen( rp, C_BLACK );
X	SetDrMd( rp, COMPLEMENT );
X    	Move( rp, cw->vwx, cw->vwy );
X    	Draw( rp, cw->vcx, cw->vwy );
X    	Draw( rp, cw->vcx, cw->vcy );
X    	Draw( rp, cw->vwx, cw->vcy );
X    	Draw( rp, cw->vwx, cw->vwy );
X    }
X#endif
X
X    /* Put back the other stuff */
X
X    Move( rp, curx, cury );
X    SetDrMd( rp, dmode );
X    SetAPen( rp, apen );
X    SetBPen( rp, bpen );
X
X#ifdef	VIEWWINDOW
X    if( window == WIN_MAP )
X	cursor_off( WIN_VIEW );
X#endif
X}
X
Xvoid
Xcursor_on( window )
X    winid window;
X{
X    register struct amii_WinDesc *cw;
X    register struct Window *w;
X#ifdef	VIEWWINDOW
X    int deltax, deltay, modx, mody;
X    register struct amii_WinDesc *vcw;
X    register struct Window *vw;
X#endif
X    register struct RastPort *rp;
X    unsigned char ch;
X    long dmode;
X    short apen, bpen;
X
X    if( window == WIN_ERR || ( cw = amii_wins[window] ) == NULL )
X    {
X	/* tty does this differently - is this OK? */
X	flags.window_inited=0;
X	panic(winpanicstr,window, "cursor_on");
X    }
X
X    if( (cw->wflags & FLMAP_CURSUP ) )
X	cursor_off( window );
X
X    w = cw->win;
X
X    if( !w )
X	return;
X
X    cw->wflags |= FLMAP_CURSUP;
X    rp = w->RPort;
X
X    /* Save the current information */
X
X    cw->cursx = rp->cp_x;
X    cw->cursy = rp->cp_y;
X    apen = rp->FgPen;
X    bpen = rp->BgPen;
X    dmode = rp->DrawMode;
X    ch = CURSOR_CHAR;
X
X    /* Draw in complement mode. The cursor body will be C_WHITE */
X
X    cw->curs_apen = C_WHITE;
X    cw->curs_bpen = C_WHITE;
X    SetAPen( rp, cw->curs_apen );
X    SetBPen( rp, cw->curs_bpen );
X    SetDrMd( rp, COMPLEMENT );
X    Move( rp, cw->cursx, cw->cursy );
X    Text( rp, &ch, 1 );
X    Move( rp, cw->cursx, cw->cursy );
X
X#ifdef	VIEWWINDOW
X    if( window == WIN_MAP )
X    {
X    	int x, y, cx, cy;
X
X	if( WIN_VIEW == WIN_ERR || ( vcw = amii_wins[ WIN_VIEW ] ) == NULL )
X	{
X	    flags.window_inited=0;
X	    panic(winpanicstr,WIN_VIEW, "cursor_on");
X	}
X
X	if( (vcw->wflags & FLMAP_CURSUP ) )
X	    cursor_off( WIN_VIEW );
X
X	vw = vcw->win;
X
X    	x = cw->cursx - (vw->Width/8);
X	if( x <= w->BorderLeft )
X	    x = w->BorderLeft + 1;
X
X    	y = cw->cursy - (vw->Height/8);
X	if( y <= w->BorderTop )
X	    y = w->BorderTop + 1;
X
X	cx = x + (vw->Width/4);
X	if( cx >= w->Width - w->BorderRight )
X	{
X	    cx = w->Width - w->BorderRight-1;
X	    x = cx - (vw->Width/4);
X	}
X
X	cy = y + (vw->Height/4);
X	if( cy >= w->Height - w->BorderBottom )
X	{
X	    cy = w->Height - w->BorderBottom-1;
X	    y = cy - (vw->Height/4);
X	}
X	cw->vwx = x;
X	cw->vwy = y;
X	cw->vcx = cx;
X	cw->vcy = cy;
X	SetAPen( rp, C_RED );
X	SetBPen( rp, C_BLACK );
X	SetDrMd( rp, COMPLEMENT );
X    	Move( rp, cw->vwx, cw->vwy );
X    	Draw( rp, cw->vcx, cw->vwy );
X    	Draw( rp, cw->vcx, cw->vcy );
X    	Draw( rp, cw->vwx, cw->vcy );
X    	Draw( rp, cw->vwx, cw->vwy );
X
X	/* Position VIEW at same location as cursor in MAP */
X	vcw->curx  = ( cw->cursx * 4 ) - (vw->Width/2) - vw->RPort->Layer->Scroll_X;
X	vcw->cury  = ( cw->cursy * 4 ) - ((2*vw->Height)/3) - vw->RPort->Layer->Scroll_Y;
X
X	if( vcw->curx + vw->RPort->Layer->Scroll_X < 0 )
X	    vcw->curx = -vw->RPort->Layer->Scroll_X;
X	else if( vcw->curx + vw->RPort->Layer->Scroll_X > vw->RPort->Layer->bounds.MaxX )
X	    vcw->curx = vw->RPort->Layer->bounds.MaxX - vw->RPort->Layer->Scroll_X;
X
X	if( vcw->cury + vw->RPort->Layer->Scroll_Y < 0 )
X	    vcw->cury = -vw->RPort->Layer->Scroll_Y;
X	else if( vcw->cury + vw->RPort->Layer->Scroll_Y > vw->RPort->Layer->bounds.MaxY )
X	    vcw->cury = vw->RPort->Layer->bounds.MaxY - vw->RPort->Layer->Scroll_Y;
X
X	{
X		char buf[ 100 ];
X		sprintf( buf, "bounds: %d,%d,%d,%d",
X			vw->RPort->Layer->bounds.MinX,
X			vw->RPort->Layer->bounds.MinY,
X			vw->RPort->Layer->bounds.MaxX,
X			vw->RPort->Layer->bounds.MaxY );
X		putstr( WIN_MESSAGE, 1, buf );
X		sprintf( buf, "loc - old: %d,%d,  new: %d,%d",
X			vw->RPort->Layer->Scroll_X,
X			vw->RPort->Layer->Scroll_Y,
X			vcw->curx + vw->RPort->Layer->Scroll_X,
X			vw->RPort->Layer->Scroll_Y + vcw->cury );
X		putstr( WIN_MESSAGE, 1, buf );
X	}
X
X	/* Figure out the scroll values to move in no more than 3 scrolls */
X	deltax     = vcw->curx / 3;
X	deltay     = vcw->cury / 3;
X	modx       = vcw->curx % 3;
X	mody       = vcw->cury % 3;
X	vcw->curx -= modx;
X	vcw->cury -= mody;
X
X	while( vcw->curx != 0 || vcw->cury != 0 )
X	{
X	    ScrollLayer( 0, vw->RPort->Layer, deltax, deltay );
X	    vcw->curx -= deltax;
X	    vcw->cury -= deltay;
X	}
X	if( modx || mody )
X	    ScrollLayer( 0, vw->RPort->Layer, modx, mody );
X    }
X#endif
X
X    SetDrMd( rp, dmode );
X    SetAPen( rp, apen );
X    SetBPen( rp, bpen );
X}
X
Xvoid amii_suspend_nhwindows( str )
X    char *str;
X{
X    if( HackScreen )
X	ScreenToBack( HackScreen );
X}
X
Xvoid amii_resume_nhwindows()
X{
X    if( HackScreen )
X	ScreenToFront( HackScreen );
X}
X
Xvoid amii_bell()
X{
X    DisplayBeep( NULL );
X}
X
Xvoid
Xremovetopl(cnt)
X	int cnt;
X{
X    struct amii_WinDesc *cw=amii_wins[WIN_MESSAGE];
X					/* NB - this is sufficient for
X					 * yn_function, but that's it
X					 */
X    if(cw->curx < cnt)cw->curx=0;
X    else cw->curx -= cnt;
X
X    amii_curs(WIN_MESSAGE, cw->curx+1, 0);
X    amii_cl_end(cw, cw->curx);
X}
X/*#endif /* AMIGA_INTUITION */
X
X#ifdef  PORT_HELP
Xvoid
Xport_help()
X{
X    display_file( PORT_HELP, 1 );
X}
X#endif
X
X/*
X *  print_glyph
X *
X *  Print the glyph to the output device.  Don't flush the output device.
X *
X *  Since this is only called from show_glyph(), it is assumed that the
X *  position and glyph are always correct (checked there)!
X */
X
Xvoid
Xamii_print_glyph(win,x,y,glyph)
X    winid win;
X    xchar x,y;
X    int glyph;
X{
X    struct amii_WinDesc *cw;
X    uchar   ch;
X    register int offset;
X#ifdef TEXTCOLOR
X    int     color;
X#ifndef	SHAREDLIB
X    extern int zapcolors[];
X#endif
X
X    if( win == WIN_ERR || (cw=amii_wins[win]) == NULL || cw->type != NHW_MAP)
X	panic(winpanicstr,win,"print_glyph");
X
X#define zap_color(n)  color = flags.use_color ? zapcolors[n] : NO_COLOR
X#define cmap_color(n) color = flags.use_color ? defsyms[n].color : NO_COLOR
X#define trap_color(n) color = flags.use_color ? \
X		(((n) == WEB) ? defsyms[S_web ].color  : \
X			    defsyms[S_trap].color) : \
X			NO_COLOR
X#define obj_color(n)  color = flags.use_color ? objects[n].oc_color : NO_COLOR
X#define mon_color(n)  color = flags.use_color ? mons[n].mcolor : NO_COLOR
X#define pet_color(n)  color = flags.use_color ? mons[n].mcolor :          \
X		/* If no color, try to hilite pets; black  */ \
X		/* should be HI                */ \
X		    ((flags.hilite_pet) ? BLACK : NO_COLOR)
X
X# else /* no text color */
X
X#define zap_color(n)
X#define cmap_color(n)
X#define trap_color(n)
X#define obj_color(n)
X#define mon_color(n)
X#define pet_color(n)
X
X#endif
X
X    /*
X     *  Map the glyph back to a character.
X     *
X     *  Warning:  For speed, this makes an assumption on the order of
X     *        offsets.  The order is set in display.h.
X     */
X    if ((offset = (glyph - GLYPH_SWALLOW_OFF)) >= 0) {  /* swallow */
X	/* see swallow_to_glyph()in display.c */
X	ch = (uchar) showsyms[S_sw_tl + (offset & 0x7)];
X	mon_color(offset >> 3);
X    } else if ((offset = (glyph - GLYPH_ZAP_OFF)) >= 0) {       /* zap beam */
X	ch = showsyms[S_vbeam + (offset & 0x3)];
X	zap_color((offset >> 2));
X    } else if( ( offset = (glyph - GLYPH_CMAP_OFF) ) >= 0 ) {   /* cmap */
X	ch = showsyms[offset];
X	cmap_color(offset);
X    } else if ( ( offset = (glyph - GLYPH_TRAP_OFF) ) >= 0 ) {  /* trap */
X	ch = (offset == WEB) ? showsyms[S_web] : showsyms[S_trap];
X	trap_color(offset);
X    } else if( ( offset = (glyph - GLYPH_OBJ_OFF) ) >= 0 ) {    /* object */
X	ch = oc_syms[objects[offset].oc_class];
X	obj_color(offset);
X    } else if ((offset = (glyph - GLYPH_BODY_OFF)) >= 0) {  /* a corpse */
X	ch = oc_syms[objects[CORPSE].oc_class];
X	mon_color(offset);
X    } else if ((offset = (glyph - GLYPH_PET_OFF)) >= 0) {   /* a pet */
X	ch = (uchar) monsyms[mons[offset].mlet];
X	pet_color(offset);
X    } else /*if( glyph_is_monster(glyph) )*/ {      /* a monster */
X	ch = (uchar) monsyms[mons[glyph].mlet];
X	mon_color(glyph);
X    }
X
X    /* Move the cursor. */
X#ifdef CLIPPING
X    if (!win_curs(x, y)) return;
X#else
X    amii_curs(win,x,y+2);
X#endif
X
X#ifdef TEXTCOLOR
X    /* Turn off color if rogue level. */
X# ifdef REINCARNATION
X    if (Is_rogue_level(&u.uz))
X	color = NO_COLOR;
X#  endif
X
X    amiga_print_glyph(win,color,ch);
X#else
X    g_putch(ch);    /* print the character */
X#endif
X    cw->curx++;     /* one character over */
X}
X
X/* Make sure the user sees a text string when no windowing is available */
X
Xvoid
Xamii_raw_print(s)
X    register const char *s;
X{
X    if( !s )
X	return;
X    if(amiIDisplay)
X	amiIDisplay->rawprint++;
X
X    if( Initialized == 0 && WIN_BASE == WIN_ERR )
X	    init_nhwindows();
X
X    if( amii_rawprwin != WIN_ERR )
X	amii_putstr( amii_rawprwin, 0, s );
X    else if( WIN_MAP != WIN_ERR && amii_wins[ WIN_MAP ] )
X	amii_putstr( WIN_MAP, 0, s );
X    else if( WIN_BASE != WIN_ERR && amii_wins[ WIN_BASE ] )
X	amii_putstr( WIN_BASE, 0, s );
X    else
X    {
X	puts( s);
X	fflush(stdout);
X    }
X}
X
X/* Make sure the user sees a bold text string when no windowing
X * is available
X */
X
Xvoid
Xamii_raw_print_bold(s)
X    register const char *s;
X{
X    if( !s )
X	return;
X
X    if(amiIDisplay)
X	amiIDisplay->rawprint++;
X
X    if( Initialized == 0 && WIN_BASE == WIN_ERR )
X	    init_nhwindows();
X
X    if( amii_rawprwin != WIN_ERR )
X	amii_putstr( amii_rawprwin, 1, s );
X    else if( WIN_MAP != WIN_ERR && amii_wins[ WIN_MAP ] )
X	amii_putstr( WIN_MAP, 1, s );
X    else if( WIN_BASE != WIN_ERR && amii_wins[ WIN_BASE ] )
X	amii_putstr( WIN_BASE, 1, s );
X    else
X    {
X	printf("\33[1m%s\33[0m\n",s);
X	fflush(stdout);
X    }
X}
X
X/* Rebuild/update the inventory if the window is up.
X */
Xvoid
Xamii_update_inventory()
X{
X    register struct amii_WinDesc *cw;
X
X    if( WIN_INVEN != WIN_ERR && ( cw = amii_wins[ WIN_INVEN ] ) &&
X				cw->type == NHW_MENU && cw->win )
X    {
X	display_inventory( NULL, FALSE );
X    }
X}
X
X/* Humm, doesn't really do anything useful */
X
Xvoid
Xamii_mark_synch()
X{
X    if(!amiIDisplay)
X	fflush(stderr);
X/* anything else?  do we need this much? */
X}
X
X/* Wait for everything to sync.  Nothing is asynchronous, so we just
X * ask for a key to be pressed.
X */
Xvoid
Xamii_wait_synch()
X{
X    if(!amiIDisplay || amiIDisplay->rawprint)
X    {
X	if(amiIDisplay) amiIDisplay->rawprint=0;
X    }
X    else
X    {
X	display_nhwindow(WIN_MAP,TRUE);
X	flush_glyph_buffer( amii_wins[ WIN_MAP ]->win );
X    }
X}
X
Xvoid
Xamii_setclipped()
X{
X    clipping = TRUE;
X    clipx=clipy=0;
X    clipxmax=CO;        /* WRONG */
X    clipymax=LI-5;      /* WRONG */
X}
X
Xvoid
Xamii_cliparound(x,y)
X    register int x,y;
X{
X/* pull this from wintty.c - LATER */
X}
X
Xvoid
XflushIDCMP( port )
X	struct MsgPort *port;
X{
X	struct Message *msg;
X	while( msg = GetMsg( port ) )
X		ReplyMsg( msg );
X}
END_OF_FILE
if test 40043 -ne `wc -c <'sys/amiga/winfuncs.c'`; then
    echo shar: \"'sys/amiga/winfuncs.c'\" unpacked with wrong size!
fi
# end of 'sys/amiga/winfuncs.c'
if test ! -d 'sys/mac' ; then
    echo shar: Creating directory \"'sys/mac'\"
    mkdir 'sys/mac'
fi
if test -f 'sys/mac/dprintf.c' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'sys/mac/dprintf.c'\" to \"'sys/mac/dprintf.c.orig'\"
  mv -f 'sys/mac/dprintf.c' 'sys/mac/dprintf.c.orig'
fi
echo shar: Extracting \"'sys/mac/dprintf.c'\" \(1302 characters\)
sed "s/^X//" >'sys/mac/dprintf.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)dprintf.c	3.1	93/05/14		  */
X/* Copyright (c) Jon W{tte, 1993.				  */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include "hack.h"
X
X#include <Types.h>
X#include <stdarg.h>
X#include <stdio.h>
X#include <strings.h>
X#include <GestaltEqu.h>
X
X
XBoolean
XHasDebugger ( void ) {
Xlong osAttr ;
X	if ( Gestalt ( gestaltOSAttr , & osAttr ) ||
X		! ( osAttr & ( 1 << gestaltSysDebuggerSupport ) ) ) {
X		return 0 ;
X	}
X	return 1 ;
X}
X
X
XBoolean
XKeyDown ( unsigned short code ) {
Xunsigned char keys [ 16 ] ;
X
X	GetKeys ( ( void * ) keys ) ;
X	return ( ( keys [ code >> 3 ] >> ( code & 7 ) ) & 1 ) != 0 ;
X}
X
X
Xvoid
Xdprintf ( char * format , ... ) {
Xstatic char buffer [ 100 ] ;
Xva_list list ;
Xstatic Boolean checkedTrap = 0 ;
Xstatic Boolean trapAvailable = 0 ;
X
X	if ( ! checkedTrap ) {
X		checkedTrap = 1 ;
X		trapAvailable = HasDebugger ( ) ;
X	}
X	list = va_start ( list , format ) ;
X	vsprintf ( & buffer [ 1 ] , format , list ) ;
X	va_end ( list )  ;
X	buffer [ 0 ] = strlen ( & buffer [ 1 ] ) ;
X	if ( trapAvailable ) {
X		if ( KeyDown ( 0x39 ) ) {									/* Caps Lock */
X			DebugStr ( buffer ) ;
X		} else if ( KeyDown ( 0x3B ) && flags . window_inited &&	/* Control */
X			( WIN_MESSAGE != -1 ) && theWindows [ WIN_MESSAGE ] . theWindow ) {
X			pline ( "%s" , & buffer [ 1 ] ) ;
X		}
X	}
X}
END_OF_FILE
if test 1302 -ne `wc -c <'sys/mac/dprintf.c'`; then
    echo shar: \"'sys/mac/dprintf.c'\" unpacked with wrong size!
fi
# end of 'sys/mac/dprintf.c'
if test ! -d 'sys/msdos' ; then
    echo shar: Creating directory \"'sys/msdos'\"
    mkdir 'sys/msdos'
fi
if test ! -d 'sys/os2' ; then
    echo shar: Creating directory \"'sys/os2'\"
    mkdir 'sys/os2'
fi
if test ! -d 'sys/share' ; then
    echo shar: Creating directory \"'sys/share'\"
    mkdir 'sys/share'
fi
if test ! -d 'sys/unix' ; then
    echo shar: Creating directory \"'sys/unix'\"
    mkdir 'sys/unix'
fi
if test ! -d 'sys/winnt' ; then
    echo shar: Creating directory \"'sys/winnt'\"
    mkdir 'sys/winnt'
fi
echo shar: End of archive 1 \(of 33\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 33 archives.
    echo "Now execute ./patchit.sh"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
