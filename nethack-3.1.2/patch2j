Path: uunet!news.tek.com!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v17i085:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Patch2j/33
Date: 11 Jun 1993 00:09:38 GMT
Organization: Tektronix, Inc, Redmond, OR, USA
Lines: 2049
Approved: billr@saab.CNA.TEK.COM
Message-ID: <1v8ig2$j0h@ying.cna.tek.com>
NNTP-Posting-Host: saab.cna.tek.com
Xref: uunet comp.sources.games:1773

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 17, Issue 85
Archive-name: nethack31/Patch2j
Patch-To: nethack31: Volume 16, Issue 1-116
Environment: Amiga, Atari, Mac, MS-DOS, Windows-NT, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 10 (of 33)."
# Contents:  patches02f sys/winnt/winnt.cnf
# Wrapped by billr@saab on Thu Jun 10 16:55:02 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'patches02f' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'patches02f'\" to \"'patches02f.orig'\"
  mv -f 'patches02f' 'patches02f.orig'
fi
echo shar: Extracting \"'patches02f'\" \(55370 characters\)
sed "s/^X//" >'patches02f' <<'END_OF_FILE'
X*** /tmp/da11202	Tue Jun  1 16:14:54 1993
X--- src/o_init.c	Fri May 28 11:40:29 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)o_init.c	3.1	92/12/11	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)o_init.c	3.1	93/05/25	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 23,29 ****
X  static NEARDATA short disco[TOTAL_OBJS] = DUMMY;
X  
X  int
X! letindex(acls) register char acls; {
X  register int i = 0;
X  register char ch;
X  	while ((ch = obj_symbols[i++]) != 0)
X--- 23,31 ----
X  static NEARDATA short disco[TOTAL_OBJS] = DUMMY;
X  
X  int
X! letindex(acls)
X! register char acls;
X! {
X  register int i = 0;
X  register char ch;
X  	while ((ch = obj_symbols[i++]) != 0)
X***************
X*** 85,91 ****
X  }
X  
X  void
X! init_objects(){
X  register int i, j, first, last, sum, end;
X  register char acls;
X  #ifdef TEXTCOLOR
X--- 87,94 ----
X  }
X  
X  void
X! init_objects()
X! {
X  register int i, j, first, last, sum, end;
X  register char acls;
X  #ifdef TEXTCOLOR
X***************
X*** 104,110 ****
X--- 107,115 ----
X  	/* initialize object descriptions */
X  	for (i = 0; i < TOTAL_OBJS; i++)
X  		objects[i].oc_name_idx = objects[i].oc_descr_idx = i;
X+ 	/* moved to after u_init()
X  	init_artifacts();
X+ 	*/
X  	/* init base; if probs given check that they add up to 1000,
X  	   otherwise compute probs; shuffle descriptions */
X  	end = TOTAL_OBJS;
X***************
X*** 199,204 ****
X--- 204,211 ----
X      for (i = SPEED_BOOTS; i <= LEVITATION_BOOTS; i++)
X  	if ((s = OBJ_DESCR(objects[i])) != 0 && !strcmp(s, "snow boots"))
X  	    return i;
X+     /* special case:  description of elven boots is nulled out for elf role */
X+     if (pl_character[0] == 'E') return ELVEN_BOOTS;
X  
X      impossible("snow boots not found?");
X      return -1;	/* not 0, or caller would try again each move */
X***************
X*** 311,317 ****
X  {
X      register int i, dis;
X      int	ct = 0;
X!     char class = -1;
X      winid tmpwin;
X  
X      tmpwin = create_nhwindow(NHW_MENU);
X--- 318,324 ----
X  {
X      register int i, dis;
X      int	ct = 0;
X!     char *s, oclass, prev_class, classes[MAXOCLASSES];
X      winid tmpwin;
X  
X      tmpwin = create_nhwindow(NHW_MENU);
X***************
X*** 318,331 ****
X      putstr(tmpwin, 0, "Discoveries");
X      putstr(tmpwin, 0, "");
X  
X!     for (i = 0; i <= NROFOBJECTS; i++) {
X! 	if ((dis = disco[i]) && interesting_to_discover(dis)) {
X! 	    ct++;
X! 	    if (objects[dis].oc_class != class) {
X! 		class = objects[dis].oc_class;
X! 		putstr(tmpwin, ATR_INVERSE, let_to_name(class, FALSE));
X  	    }
X- 	    putstr(tmpwin, 0, typename(dis));
X  	}
X      }
X      if (ct == 0) {
X--- 325,351 ----
X      putstr(tmpwin, 0, "Discoveries");
X      putstr(tmpwin, 0, "");
X  
X!     /* several classes are omitted from packorder; one is of interest here */
X!     Strcpy(classes, flags.inv_order);
X!     if (!index(classes, VENOM_CLASS)) {
X! 	s = eos(classes);
X! 	*s++ = VENOM_CLASS;
X! 	*s = '\0';
X!     }
X! 
X!     for (s = classes; *s; s++) {
X! 	oclass = *s;
X! 	prev_class = oclass + 1;	/* forced different from oclass */
X! 	for (i = bases[letindex(oclass)];
X! 	     i <= NROFOBJECTS && objects[i].oc_class == oclass; i++) {
X! 	    if ((dis = disco[i]) && interesting_to_discover(dis)) {
X! 		ct++;
X! 		if (oclass != prev_class) {
X! 		    putstr(tmpwin, ATR_INVERSE, let_to_name(oclass, FALSE));
X! 		    prev_class = oclass;
X! 		}
X! 		putstr(tmpwin, 0, typename(dis));
X  	    }
X  	}
X      }
X      if (ct == 0) {
X*** /tmp/da11210	Tue Jun  1 16:14:56 1993
X--- src/objects.c	Wed Mar 17 17:23:13 1993
X***************
X*** 560,567 ****
X  	FOOD("lump of royal jelly",  0, 1,  2, 0, VEGGY, 200, YELLOW),
X  	FOOD("cream pie",           25, 1, 10, 0, VEGGY, 100, WHITE),
X  	FOOD("candy bar",           13, 1,  2, 0, VEGGY, 100, BROWN),
X! 	FOOD("fortune cookie",      55, 1,  1, 0, VEGGY,  40, BROWN),
X! 	FOOD("pancake",             25, 2,  2, 0, VEGGY, 200, BROWN),
X  	FOOD("lembas wafer",        20, 2,  5, 0, VEGGY, 800, WHITE),
X  	FOOD("cram ration",         20, 3, 15, 0, VEGGY, 600, HI_ORGANIC),
X  	FOOD("food ration",        381, 5, 20, 0, VEGGY, 800, HI_ORGANIC),
X--- 560,567 ----
X  	FOOD("lump of royal jelly",  0, 1,  2, 0, VEGGY, 200, YELLOW),
X  	FOOD("cream pie",           25, 1, 10, 0, VEGGY, 100, WHITE),
X  	FOOD("candy bar",           13, 1,  2, 0, VEGGY, 100, BROWN),
X! 	FOOD("fortune cookie",      55, 1,  1, 0, VEGGY,  40, YELLOW),
X! 	FOOD("pancake",             25, 2,  2, 0, VEGGY, 200, YELLOW),
X  	FOOD("lembas wafer",        20, 2,  5, 0, VEGGY, 800, WHITE),
X  	FOOD("cram ration",         20, 3, 15, 0, VEGGY, 600, HI_ORGANIC),
X  	FOOD("food ration",        381, 5, 20, 0, VEGGY, 800, HI_ORGANIC),
X***************
X*** 648,654 ****
X  SPELL("finger of death", "stained",      5, 10, 7, 1, RAY,       HI_PAPER),
X  SPELL("light",           "cloth",       45,  1, 1, 1, NODIR,     HI_CLOTH),
X  SPELL("detect monsters", "leather",     45,  1, 1, 1, NODIR,     HI_LEATHER),
X! SPELL("healing",         "white",       40,  2, 1, 1, NODIR,     WHITE),
X  SPELL("knock",           "pink",        36,  1, 1, 1, IMMEDIATE, BRIGHT_MAGENTA),
X  SPELL("force bolt",      "red",         35,  2, 1, 1, IMMEDIATE, RED),
X  SPELL("confuse monster", "orange",      37,  2, 2, 1, IMMEDIATE, ORANGE_COLORED),
X--- 648,654 ----
X  SPELL("finger of death", "stained",      5, 10, 7, 1, RAY,       HI_PAPER),
X  SPELL("light",           "cloth",       45,  1, 1, 1, NODIR,     HI_CLOTH),
X  SPELL("detect monsters", "leather",     45,  1, 1, 1, NODIR,     HI_LEATHER),
X! SPELL("healing",         "white",       40,  2, 1, 1, IMMEDIATE, WHITE),
X  SPELL("knock",           "pink",        36,  1, 1, 1, IMMEDIATE, BRIGHT_MAGENTA),
X  SPELL("force bolt",      "red",         35,  2, 1, 1, IMMEDIATE, RED),
X  SPELL("confuse monster", "orange",      37,  2, 2, 1, IMMEDIATE, ORANGE_COLORED),
X***************
X*** 664,670 ****
X  SPELL("haste self",      "purple",      33,  4, 3, 1, NODIR,     MAGENTA),
X  SPELL("detect unseen",   "violet",      20,  4, 3, 1, NODIR,     MAGENTA),
X  SPELL("levitation",      "tan",         20,  4, 4, 1, NODIR,     BROWN),
X! SPELL("extra healing",   "plaid",       35,  5, 3, 1, NODIR,     GREEN),
X  SPELL("restore ability", "light brown", 25,  5, 4, 1, NODIR,     BROWN),
X  SPELL("invisibility",    "dark brown",  32,  5, 4, 1, NODIR,     BROWN),
X  SPELL("detect treasure", "gray",        25,  5, 4, 1, NODIR,     GRAY),
X--- 664,670 ----
X  SPELL("haste self",      "purple",      33,  4, 3, 1, NODIR,     MAGENTA),
X  SPELL("detect unseen",   "violet",      20,  4, 3, 1, NODIR,     MAGENTA),
X  SPELL("levitation",      "tan",         20,  4, 4, 1, NODIR,     BROWN),
X! SPELL("extra healing",   "plaid",       35,  5, 3, 1, IMMEDIATE, GREEN),
X  SPELL("restore ability", "light brown", 25,  5, 4, 1, NODIR,     BROWN),
X  SPELL("invisibility",    "dark brown",  32,  5, 4, 1, NODIR,     BROWN),
X  SPELL("detect treasure", "gray",        25,  5, 4, 1, NODIR,     GRAY),
X*** /tmp/da11218	Tue Jun  1 16:14:59 1993
X--- src/objnam.c	Tue Jun  1 12:13:20 1993
X***************
X*** 1,8 ****
X! /*	SCCS Id: @(#)objnam.c	3.1	93/02/12	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X! #include	"hack.h"
X  
X  /* "an uncursed partly eaten guardian naga hatchling corpse" */
X  #define	PREFIX	50
X--- 1,8 ----
X! /*	SCCS Id: @(#)objnam.c	3.1	93/05/15	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X! #include "hack.h"
X  
X  /* "an uncursed partly eaten guardian naga hatchling corpse" */
X  #define	PREFIX	50
X***************
X*** 24,31 ****
X--- 24,39 ----
X  STATIC_OVL struct Jitem Japanese_items[] = {
X  	{ SHORT_SWORD, "wakizashi" },
X  	{ BROADSWORD, "ninja-to" },
X+ 	{ FLAIL, "nunchaku" },
X  	{ GLAIVE, "naginata" },
X  	{ LOCK_PICK, "osaku" },
X+ 	{ WOODEN_HARP, "koto" },
X+ 	{ KNIFE, "shito" },
X+ 	{ PLATE_MAIL, "tanko" },
X+ 	{ HELMET, "kabuto" },
X+ 	{ LEATHER_GLOVES, "yugake" },
X+ 	{ FOOD_RATION, "gunyoki" },
X+ 	{ POT_BOOZE, "sake" },
X  	{0, "" }
X  };
X  
X***************
X*** 182,188 ****
X  		actualn = Japanese_item_name(typ);
X  
X  	buf[0] = '\0';
X! 	if (!Blind) obj->dknown=1;
X  	if (obj_is_pname(obj))
X  	    goto nameit;
X  	switch (obj->oclass) {
X--- 190,197 ----
X  		actualn = Japanese_item_name(typ);
X  
X  	buf[0] = '\0';
X! 	if (!Blind) obj->dknown = TRUE;
X! 	if (pl_character[0] == 'P') obj->bknown = TRUE;
X  	if (obj_is_pname(obj))
X  	    goto nameit;
X  	switch (obj->oclass) {
X***************
X*** 300,307 ****
X  			    Strcat(buf, " of ");
X  			    if (typ == POT_WATER &&
X  				objects[POT_WATER].oc_name_known &&
X! 				(obj->bknown || pl_character[0] == 'P') &&
X! 				(obj->blessed || obj->cursed)) {
X  				Strcat(buf, obj->blessed ? "holy " : "unholy ");
X  			    }
X  			    Strcat(buf, actualn);
X--- 309,315 ----
X  			    Strcat(buf, " of ");
X  			    if (typ == POT_WATER &&
X  				objects[POT_WATER].oc_name_known &&
X! 				obj->bknown && (obj->blessed || obj->cursed)) {
X  				Strcat(buf, obj->blessed ? "holy " : "unholy ");
X  			    }
X  			    Strcat(buf, actualn);
X***************
X*** 412,417 ****
X--- 420,426 ----
X  	 * end (Strcat is used on the end)
X  	 */
X  	register char *bp = xname(obj);
X+ 
X  	/* When using xname, we want "poisoned arrow", and when using
X  	 * doname, we want "poisoned +0 arrow".  This kludge is about the only
X  	 * way to do it, at least until someone overhauls xname() and doname(),
X***************
X*** 430,460 ****
X  		Strcpy(prefix, "the ");
X  	} else
X  		Strcpy(prefix, "a ");
X! 	if((obj->bknown || pl_character[0] == 'P') &&
X  	    (obj->otyp != POT_WATER || !objects[POT_WATER].oc_name_known
X  		|| (!obj->cursed && !obj->blessed))) {
X  	    /* allow 'blessed clear potion' if we don't know it's holy water;
X  	     * always allow "uncursed potion of water"
X  	     */
X! 	    if(obj->cursed)
X  		Strcat(prefix, "cursed ");
X! 	    else if(obj->blessed)
X  		Strcat(prefix, "blessed ");
X! 	    else if (((obj->oclass != ARMOR_CLASS
X! 			&& obj->oclass != WAND_CLASS
X! 			&& obj->oclass != WEAPON_CLASS
X! 			&& ((obj->oclass != TOOL_CLASS &&
X! 			     obj->oclass != RING_CLASS) ||
X! 			     !objects[obj->otyp].oc_charged))
X! 			    || !obj->known)
X! 		/* For items with charges or +/-, knowing the +/- means that
X! 		 * the item has been totally identified, and therefore there
X! 		 * is no doubt as to the object being uncursed if it's
X! 		 * not described as "blessed" or "cursed".
X  		 *
X! 		 * If the +/- isn't known, "uncursed" must be printed to
X! 		 * avoid ambiguity between an item whose curse status is
X! 		 * unknown, and an item known to be uncursed.
X  		 */
X  #ifdef MAIL
X  			&& obj->otyp != SCR_MAIL
X--- 439,467 ----
X  		Strcpy(prefix, "the ");
X  	} else
X  		Strcpy(prefix, "a ");
X! 
X! 	if (obj->bknown && 
X  	    (obj->otyp != POT_WATER || !objects[POT_WATER].oc_name_known
X  		|| (!obj->cursed && !obj->blessed))) {
X  	    /* allow 'blessed clear potion' if we don't know it's holy water;
X  	     * always allow "uncursed potion of water"
X  	     */
X! 	    if (obj->cursed)
X  		Strcat(prefix, "cursed ");
X! 	    else if (obj->blessed)
X  		Strcat(prefix, "blessed ");
X! 	    else if ((!obj->known || !objects[obj->otyp].oc_charged ||
X! 		      (obj->oclass == ARMOR_CLASS ||
X! 		       obj->oclass == RING_CLASS))
X! 		/* For most items with charges or +/-, if you know how many
X! 		 * charges are left or what the +/- is, then you must have
X! 		 * totally identified the item, so "uncursed" is unneccesary,
X! 		 * because an identified object not described as "blessed" or
X! 		 * "cursed" must be uncursed.
X  		 *
X! 		 * If the charges or +/- is not known, "uncursed" must be
X! 		 * printed to avoid ambiguity between an item whose curse
X! 		 * status is unknown, and an item known to be uncursed.
X  		 */
X  #ifdef MAIL
X  			&& obj->otyp != SCR_MAIL
X***************
X*** 464,470 ****
X  			&& pl_character[0] != 'P')
X  		Strcat(prefix, "uncursed ");
X  	}
X! 	if(obj->greased) Strcat(prefix, "greased ");
X  	switch(obj->oclass) {
X  	case AMULET_CLASS:
X  		if(obj->otyp == FAKE_AMULET_OF_YENDOR ||
X--- 471,479 ----
X  			&& pl_character[0] != 'P')
X  		Strcat(prefix, "uncursed ");
X  	}
X! 
X! 	if (obj->greased) Strcat(prefix, "greased ");
X! 
X  	switch(obj->oclass) {
X  	case AMULET_CLASS:
X  		if(obj->otyp == FAKE_AMULET_OF_YENDOR ||
X***************
X*** 489,495 ****
X  			Strcat(prefix,
X  			       is_rustprone(obj) ? "rusty " :
X  			       is_corrodeable(obj) ? "corroded " :
X! 			       is_flammable(obj) ? "burnt " : "eroded ");
X  		} else if (obj->rknown && obj->oerodeproof)
X  			Strcat(prefix,
X  			       is_rustprone(obj) ? "rustproof " :
X--- 498,505 ----
X  			Strcat(prefix,
X  			       is_rustprone(obj) ? "rusty " :
X  			       is_corrodeable(obj) ? "corroded " :
X! 			    /* is_flammable(obj) ? "burnt " : "eroded " */
X! 			       "damaged ");
X  		} else if (obj->rknown && obj->oerodeproof)
X  			Strcat(prefix,
X  			       is_rustprone(obj) ? "rustproof " :
X***************
X*** 523,534 ****
X  			goto plus;
X  		if (Is_candle(obj) &&
X  		    obj->age < 20L * (long)objects[obj->otyp].oc_cost)
X! 			Sprintf(eos(prefix), "partly used ");
X  		if (obj->otyp == OIL_LAMP || obj->otyp == MAGIC_LAMP ||
X  			obj->otyp == BRASS_LANTERN ||
X  		    Is_candle(obj) || obj->otyp == CANDELABRUM_OF_INVOCATION) {
X  			if(obj->lamplit)
X! 				Sprintf(eos(bp), " (lit)");
X  			break;
X  		}
X  		if(!objects[obj->otyp].oc_charged) break;
X--- 533,544 ----
X  			goto plus;
X  		if (Is_candle(obj) &&
X  		    obj->age < 20L * (long)objects[obj->otyp].oc_cost)
X! 			Strcat(prefix, "partly used ");
X  		if (obj->otyp == OIL_LAMP || obj->otyp == MAGIC_LAMP ||
X  			obj->otyp == BRASS_LANTERN ||
X  		    Is_candle(obj) || obj->otyp == CANDELABRUM_OF_INVOCATION) {
X  			if(obj->lamplit)
X! 				Strcat(bp, " (lit)");
X  			break;
X  		}
X  		if(!objects[obj->otyp].oc_charged) break;
X***************
X*** 573,578 ****
X--- 583,596 ----
X  		}
X  		break;
X  	case BALL_CLASS:
X+ 	case CHAIN_CLASS:
X+ 		if (obj->oeroded) {
X+ 		    switch(obj->oeroded) {
X+ 			case 2: Strcat(prefix, "very "); break;
X+ 			case 3: Strcat(prefix, "thoroughly "); break;
X+ 		    }
X+ 		    Strcat(prefix, "rusty ");
X+ 		}
X  		if(obj->owornmask & W_BALL)
X  			Strcat(bp, " (chained to you)");
X  			break;
X***************
X*** 753,764 ****
X  	"wand", "ring", "potion", "scroll", "gem", "amulet",
X  	"spellbook", "spell book",
X  	/* for non-specific wishes */
X! 	"weapon", "armor", "tool", "food", "comestible",
X  };
X  static const char wrpsym[] = {
X  	WAND_CLASS, RING_CLASS, POTION_CLASS, SCROLL_CLASS, GEM_CLASS, 
X          AMULET_CLASS, SPBOOK_CLASS, SPBOOK_CLASS,
X! 	WEAPON_CLASS, ARMOR_CLASS, TOOL_CLASS, FOOD_CLASS, FOOD_CLASS
X  };
X  
X  #endif /* OVLB */
X--- 771,783 ----
X  	"wand", "ring", "potion", "scroll", "gem", "amulet",
X  	"spellbook", "spell book",
X  	/* for non-specific wishes */
X! 	"weapon", "armor", "armour", "tool", "food", "comestible",
X  };
X  static const char wrpsym[] = {
X  	WAND_CLASS, RING_CLASS, POTION_CLASS, SCROLL_CLASS, GEM_CLASS, 
X          AMULET_CLASS, SPBOOK_CLASS, SPBOOK_CLASS,
X! 	WEAPON_CLASS, ARMOR_CLASS, ARMOR_CLASS, TOOL_CLASS, FOOD_CLASS,
X! 	FOOD_CLASS
X  };
X  
X  #endif /* OVLB */
X***************
X*** 900,906 ****
X  
X  	/* mumak/mumakil */
X  	if (len >= 5 && !strcmp(spot-4, "mumak")) {
X! 		Strcpy(spot, "il");
X  		goto bottom;
X  	}
X  
X--- 919,925 ----
X  
X  	/* mumak/mumakil */
X  	if (len >= 5 && !strcmp(spot-4, "mumak")) {
X! 		Strcpy(spot+1, "il");
X  		goto bottom;
X  	}
X  
X***************
X*** 1017,1022 ****
X--- 1036,1042 ----
X  #ifdef WIZARD
X  	{ "venom",	VENOM_CLASS,  BLINDING_VENOM, ACID_VENOM },
X  #endif
X+ 	{ "grey stone", GEM_CLASS,    LUCKSTONE,      LOADSTONE },
X  };
X  
X  #define BSTRCMP(base,ptr,string) ((ptr) < base || strcmp((ptr),string))
X***************
X*** 1038,1044 ****
X  
X  	if (!oldstr || !*oldstr) {
X  		impossible("singular of null?");
X! 		str[0] = 0; return str;
X  	}
X  	Strcpy(str, oldstr);
X  	bp = str;
X--- 1058,1065 ----
X  
X  	if (!oldstr || !*oldstr) {
X  		impossible("singular of null?");
X! 		str[0] = 0;
X! 		return str;
X  	}
X  	Strcpy(str, oldstr);
X  	bp = str;
X***************
X*** 1126,1131 ****
X--- 1147,1158 ----
X  	{ "warhammer", WAR_HAMMER },
X  	{ "grey dragon scale mail", GRAY_DRAGON_SCALE_MAIL },
X  	{ "grey dragon scales", GRAY_DRAGON_SCALES },
X+ 	{ "enchant armour", SCR_ENCHANT_ARMOR },
X+ 	{ "destroy armour", SCR_DESTROY_ARMOR },
X+ 	{ "scroll of enchant armour", SCR_ENCHANT_ARMOR },
X+ 	{ "scroll of destroy armour", SCR_DESTROY_ARMOR },
X+ 	{ "leather armour", LEATHER_ARMOR },
X+ 	{ "studded leather armour", STUDDED_LEATHER_ARMOR },
X  	{ "iron ball", HEAVY_IRON_BALL },
X  	{ "stone", ROCK },
X  	{ (const char *)0, 0 },
X***************
X*** 1236,1241 ****
X--- 1263,1271 ----
X  			   !strncmp(bp, "burned ", l=7) ||
X  			   !strncmp(bp, "rotted ", l=7)) {
X  			eroded = 1 + very; very = 0;
X+ 		} else if (!strncmpi(bp, "very ", l=5)) {
X+ 			/* very rusted very heavy iron ball */
X+ 			very = 1;
X  		} else if (!strncmpi(bp, "partly eaten ", l=13)) {
X  			halfeaten = 1;
X  		} else break;
X***************
X*** 1407,1424 ****
X  		goto typfnd;
X  	}
X  
X- 	if(!strcmpi(bp, "ring mail") ||	/* Note: ring mail is not a ring ! */
X- 	   !strcmpi(bp, "leather armor") || /* Prevent falling to 'armor'. */
X- 	   !strcmpi(bp, "studded leather armor")) {
X- 		let = ARMOR_CLASS;
X- 		actualn = bp;
X- 		goto srch;
X- 	}
X- 	if(!strcmpi(bp, "food ration")){
X- 		let = FOOD_CLASS;
X- 		actualn = bp;
X- 		goto srch;
X- 	}
X  	p = eos(bp);
X  	if(!BSTRCMPI(bp, p-10, "holy water")) {
X  		typ = POT_WATER;
X--- 1437,1442 ----
X***************
X*** 1466,1475 ****
X  		let = i;
X  		goto any;
X  	}
X  	if(strncmpi(bp, "enchant ", 8) &&
X  	   strncmpi(bp, "destroy ", 8) &&
X! 	   strncmpi(bp, "food detection", 14))
X! 	/* allow wishes for "enchant weapon" and "food detection" */
X  	for(i = 0; i < sizeof(wrpsym); i++) {
X  		register int j = strlen(wrp[i]);
X  		if(!strncmpi(bp, wrp[i], j)){
X--- 1484,1501 ----
X  		let = i;
X  		goto any;
X  	}
X+ 
X+ 	/* Search for class names: XXXXX potion, scroll of XXXXX.  Avoid */
X+ 	/* false hits on, e.g., rings for "ring mail". */
X  	if(strncmpi(bp, "enchant ", 8) &&
X  	   strncmpi(bp, "destroy ", 8) &&
X! 	   strncmpi(bp, "food detection", 14) &&
X! 	   strncmpi(bp, "ring mail", 9) &&
X! 	   strncmpi(bp, "studded leather arm", 19) &&
X! 	   strncmpi(bp, "leather arm", 11) &&
X! 	   strncmpi(bp, "tooled horn", 11) &&
X! 	   strncmpi(bp, "food ration", 11)
X! 	)
X  	for(i = 0; i < sizeof(wrpsym); i++) {
X  		register int j = strlen(wrp[i]);
X  		if(!strncmpi(bp, wrp[i], j)){
X***************
X*** 1502,1507 ****
X--- 1528,1534 ----
X  		if (!strncmpi(g, "worthless ", 10)) g += 10;
X  		if (!strncmpi(g, "piece of ", 9)) g += 9;
X  		if (!strncmpi(g, "colored ", 8)) g += 8;
X+ 		else if (!strncmpi(g, "coloured ", 9)) g += 9;
X  		if (!strcmpi(g, "glass")) {	/* choose random color */
X  			/* white, blue, red, yellowish brown, green, violet */
X  			typ = LAST_GEM + rnd(6);
X***************
X*** 1858,1864 ****
X  	if (ispoisoned) {
X  	    if (let == WEAPON_CLASS && typ <= SHURIKEN)
X  		otmp->opoisoned = (Luck >= 0);
X! 	    else if (Is_box(otmp))
X  		otmp->otrapped = 1;
X  	    else if (let == FOOD_CLASS)
X  		/* try to taint by making it as old as possible */
X--- 1885,1891 ----
X  	if (ispoisoned) {
X  	    if (let == WEAPON_CLASS && typ <= SHURIKEN)
X  		otmp->opoisoned = (Luck >= 0);
X! 	    else if (Is_box(otmp) || typ == TIN)
X  		otmp->otrapped = 1;
X  	    else if (let == FOOD_CLASS)
X  		/* try to taint by making it as old as possible */
X***************
X*** 1870,1875 ****
X--- 1897,1903 ----
X  		if (otmp->oartifact) otmp->quan = 1L;
X  	}
X  
X+ #ifdef MULDGN
X  	/* more wishing abuse: don't allow wishing for certain artifacts */
X  	/* and make them pay; charge them for the wish anyway! */
X  	if ((is_quest_artifact(otmp) || 
X***************
X*** 1881,1889 ****
X  	    artifact_unexist(otmp);
X  	    obfree(otmp, (struct obj *) 0);
X  	    otmp = &zeroobj;
X! 	    pline("For a moment, you feel something in your %s, but it disappears!", makeplural(body_part(HAND)));
X  	}
X! 	
X  	otmp->owt = weight(otmp);
X  	if (very && otmp->otyp == HEAVY_IRON_BALL) otmp->owt += 160;
X  	if (halfeaten && otmp->oclass == FOOD_CLASS) {
X--- 1909,1920 ----
X  	    artifact_unexist(otmp);
X  	    obfree(otmp, (struct obj *) 0);
X  	    otmp = &zeroobj;
X! 	    pline(
X! 	     "For a moment, you feel something in your %s, but it disappears!",
X! 		  makeplural(body_part(HAND)));
X  	}
X! #endif	/* MULDGN */
X! 
X  	otmp->owt = weight(otmp);
X  	if (very && otmp->otyp == HEAVY_IRON_BALL) otmp->owt += 160;
X  	if (halfeaten && otmp->oclass == FOOD_CLASS) {
X*** /tmp/da11226	Tue Jun  1 16:15:03 1993
X--- src/options.c	Tue Jun  1 11:19:05 1993
X***************
X*** 1,10 ****
X! /*	SCCS Id: @(#)options.c	3.1	93/02/19	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X  #include "hack.h"
X  #include "termcap.h"
X  #include <ctype.h>
X  
X  /*
X   *  NOTE:  If you add (or delete) an option, please update the short
X--- 1,18 ----
X! /*	SCCS Id: @(#)options.c	3.1	93/05/29	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X+ #ifdef OPTION_LISTS_ONLY	/* want option lists for external program */
X+ #include "config.h"
X+ #include "objclass.h"
X+ #include "flag.h"
X+ NEARDATA struct flag flags;	/* provide linkage */
X+ #define static
X+ #else
X  #include "hack.h"
X  #include "termcap.h"
X  #include <ctype.h>
X+ #endif
X  
X  /*
X   *  NOTE:  If you add (or delete) an option, please update the short
X***************
X*** 13,46 ****
X   *  and also the Guidebooks.
X   */
X  
X- #if defined(TOS) && defined(TEXTCOLOR)
X- extern boolean colors_changed;	/* in tos.c */
X- #endif
X- 
X- extern const char *roles[];	/* from u_init.c */
X- extern char inv_order[];	/* from invent.c */
X- 
X- static boolean initial, from_file;
X- 
X- static void FDECL(nmcpy, (char *, const char *, int));
X- static void FDECL(escapes, (const char *, char *));
X- static void FDECL(rejectoption, (const char *));
X- static void FDECL(badoption, (const char *));
X- static char *FDECL(string_for_opt, (char *));
X- static char *FDECL(string_for_env_opt, (const char *, char *));
X- static int FDECL(change_inv_order, (char *));
X- static void FDECL(oc_to_str, (char *, char *));
X- 
X  static struct Bool_Opt
X  {
X  	const char *name;
X  	boolean	*addr, initvalue;
X  } boolopt[] = {
X  #if defined(MICRO) && !defined(AMIGA)
X  	{"BIOS", &flags.BIOS, FALSE},
X  #endif
X  #ifdef INSURANCE
X  	{"checkpoint", &flags.ins_chkpt, TRUE},
X  #endif
X  #ifdef TEXTCOLOR
X  # ifdef MICRO
X--- 21,46 ----
X   *  and also the Guidebooks.
X   */
X  
X  static struct Bool_Opt
X  {
X  	const char *name;
X  	boolean	*addr, initvalue;
X  } boolopt[] = {
X+ #ifdef MFLOPPY
X+ 	{"asksavedisk", &flags.asksavedisk, FALSE},
X+ #else
X+ 	{"asksavedisk", (boolean *)0, FALSE},
X+ #endif
X+ 	{"autopickup", &flags.pickup, TRUE},
X  #if defined(MICRO) && !defined(AMIGA)
X  	{"BIOS", &flags.BIOS, FALSE},
X+ #else
X+ 	{"BIOS", (boolean *)0, FALSE},
X  #endif
X  #ifdef INSURANCE
X  	{"checkpoint", &flags.ins_chkpt, TRUE},
X+ #else
X+ 	{"checkpoint", (boolean *)0, FALSE},
X  #endif
X  #ifdef TEXTCOLOR
X  # ifdef MICRO
X***************
X*** 48,102 ****
X  # else	/* systems that support multiple terminals, many monochrome */
X  	{"color", &flags.use_color, FALSE},
X  # endif
X  #endif
X  	{"confirm",&flags.confirm, TRUE},
X  #ifdef TERMLIB
X  	{"DECgraphics", &flags.DECgraphics, FALSE},
X  #endif
X- 	{"disclose", &flags.end_disclose, TRUE},
X  	{"female", &flags.female, FALSE},
X  	{"fixinv", &flags.invlet_constant, TRUE},
X  #ifdef AMIFLUSH
X  	{"flush", &flags.amiflush, FALSE},
X  #endif
X  	{"help", &flags.help, TRUE},
X  #ifdef TEXTCOLOR
X  	{"hilite_pet", &flags.hilite_pet, FALSE},
X  #endif
X  #ifdef ASCIIGRAPH
X  	{"IBMgraphics", &flags.IBMgraphics, FALSE},
X  #endif
X  	{"ignintr", &flags.ignintr, FALSE},
X  #ifdef MAC_GRAPHICS_ENV
X  	{"large_font", &flags.large_font, FALSE},
X  #endif
X  	{"legacy",&flags.legacy, TRUE},
X  	{"lit_corridor", &flags.lit_corridor, FALSE},
X  #ifdef MAC_GRAPHICS_ENV
X  	{"Macgraphics", &flags.MACgraphics, TRUE},
X  #endif
X  #ifdef NEWS
X  	{"news", &flags.news, TRUE},
X  #endif
X  	{"null", &flags.null, TRUE},
X  	{"number_pad", &flags.num_pad, FALSE},
X  #ifdef MAC
X  	{"page_wait", &flags.page_wait, TRUE},
X  #endif
X- 	{"pickup", &flags.pickup, TRUE},
X  #ifdef MAC
X  	{"popup_dialog", &flags.popup_dialog, FALSE},
X  #endif
X  #if defined(MICRO) && !defined(AMIGA)
X  	{"rawio", &flags.rawio, FALSE},
X  #endif
X  	{"rest_on_space", &flags.rest_on_space, FALSE},
X  	{"safe_pet", &flags.safe_dog, TRUE},
X  #ifdef EXP_ON_BOTL
X  	{"showexp", &flags.showexp, FALSE},
X  #endif
X  #ifdef SCORE_ON_BOTL
X  	{"showscore", &flags.showscore, FALSE},
X  #endif
X  	{"silent", &flags.silent, TRUE},
X  	{"sortpack", &flags.sortpack, TRUE},
X--- 48,126 ----
X  # else	/* systems that support multiple terminals, many monochrome */
X  	{"color", &flags.use_color, FALSE},
X  # endif
X+ #else
X+ 	{"color", (boolean *)0, FALSE},
X  #endif
X  	{"confirm",&flags.confirm, TRUE},
X  #ifdef TERMLIB
X  	{"DECgraphics", &flags.DECgraphics, FALSE},
X+ #else
X+ 	{"DECgraphics", (boolean *)0, FALSE},
X  #endif
X  	{"female", &flags.female, FALSE},
X  	{"fixinv", &flags.invlet_constant, TRUE},
X  #ifdef AMIFLUSH
X  	{"flush", &flags.amiflush, FALSE},
X+ #else
X+ 	{"flush", (boolean *)0, FALSE},
X  #endif
X  	{"help", &flags.help, TRUE},
X  #ifdef TEXTCOLOR
X  	{"hilite_pet", &flags.hilite_pet, FALSE},
X+ #else
X+ 	{"hilite_pet", (boolean *)0, FALSE},
X  #endif
X  #ifdef ASCIIGRAPH
X  	{"IBMgraphics", &flags.IBMgraphics, FALSE},
X+ #else
X+ 	{"IBMgraphics", (boolean *)0, FALSE},
X  #endif
X  	{"ignintr", &flags.ignintr, FALSE},
X  #ifdef MAC_GRAPHICS_ENV
X  	{"large_font", &flags.large_font, FALSE},
X+ #else
X+ 	{"large_font", (boolean *)0, FALSE},
X  #endif
X  	{"legacy",&flags.legacy, TRUE},
X  	{"lit_corridor", &flags.lit_corridor, FALSE},
X  #ifdef MAC_GRAPHICS_ENV
X  	{"Macgraphics", &flags.MACgraphics, TRUE},
X+ #else
X+ 	{"Macgraphics", (boolean *)0, FALSE},
X  #endif
X  #ifdef NEWS
X  	{"news", &flags.news, TRUE},
X+ #else
X+ 	{"news", (boolean *)0, FALSE},
X  #endif
X  	{"null", &flags.null, TRUE},
X  	{"number_pad", &flags.num_pad, FALSE},
X  #ifdef MAC
X  	{"page_wait", &flags.page_wait, TRUE},
X+ #else
X+ 	{"page_wait", (boolean *)0, FALSE},
X  #endif
X  #ifdef MAC
X  	{"popup_dialog", &flags.popup_dialog, FALSE},
X+ #else
X+ 	{"popup_dialog", (boolean *)0, FALSE},
X  #endif
X  #if defined(MICRO) && !defined(AMIGA)
X  	{"rawio", &flags.rawio, FALSE},
X+ #else
X+ 	{"rawio", (boolean *)0, FALSE},
X  #endif
X  	{"rest_on_space", &flags.rest_on_space, FALSE},
X  	{"safe_pet", &flags.safe_dog, TRUE},
X  #ifdef EXP_ON_BOTL
X  	{"showexp", &flags.showexp, FALSE},
X+ #else
X+ 	{"showexp", (boolean *)0, FALSE},
X  #endif
X  #ifdef SCORE_ON_BOTL
X  	{"showscore", &flags.showscore, FALSE},
X+ #else
X+ 	{"showscore", (boolean *)0, FALSE},
X  #endif
X  	{"silent", &flags.silent, TRUE},
X  	{"sortpack", &flags.sortpack, TRUE},
X***************
X*** 108,115 ****
X--- 132,195 ----
X  	{NULL, (boolean *)0, FALSE}
X  };
X  
X+ /* compound options, for option_help() and external programs like Amiga
X+  * frontend */
X+ static struct Comp_Opt
X+ {
X+ 	const char *name, *descr;
X+ } compopt[] = {
X+ 	{ "catname",  "the name of your (first) cat (e.g., catname:Tabby)," },
X+ 	{ "disclose", "the kinds of information to disclose at end of game," },
X+ 	{ "dogname",  "the name of your (first) dog (e.g., dogname:Fang)," },
X+ #ifdef TUTTI_FRUTTI
X+ 	{ "fruit",    "the name of a fruit you enjoy eating," },
X+ #endif
X+ 	{ "graphics", "the symbols to use in drawing the dungeon map," },
X+ 	{ "monsters", "the symbols to use for monsters," },
X+ 	{ "msghistory", "number of top line messages to save," },
X+ 	{ "name",     "your character's name (e.g., name:Merlin-W)," },
X+ 	{ "objects",  "the symbols to use for objects," },
X+ 	{ "packorder", "the inventory order of the items in your pack," },
X+ #ifdef CHANGE_COLOR
X+ 	{ "palette",  "palette (00c/880/-fff is blue/yellow/reverse white)," },
X+ # if defined(MAC)
X+ 	{ "hicolor",  "same as palette, only order is reversed," },
X+ # endif
X+ #endif
X+ 	{ "pettype",  "your preferred initial pet type," },
X+ 	{ "pickup_types", "types of objects to pick up automatically," },
X+ 	{ "scores",   "the parts of the score list you wish to see," },
X+ 	{ "windowtype", "windowing system to use." },
X+ 	{ NULL, NULL }
X+ };
X+ 
X+ #ifndef OPTION_LISTS_ONLY	/* use rest of file */
X+ 
X  static boolean need_redraw; /* for doset() */
X  
X+ #if defined(TOS) && defined(TEXTCOLOR)
X+ extern boolean colors_changed;	/* in tos.c */
X+ #endif
X+ 
X+ extern const char *roles[];	/* from u_init.c */
X+ 
X+ static char def_inv_order[MAXOCLASSES] = {
X+ 	AMULET_CLASS, WEAPON_CLASS, ARMOR_CLASS, FOOD_CLASS, SCROLL_CLASS,
X+ 	SPBOOK_CLASS, POTION_CLASS, RING_CLASS, WAND_CLASS, TOOL_CLASS, 
X+ 	GEM_CLASS, ROCK_CLASS, BALL_CLASS, CHAIN_CLASS, 0,
X+ };
X+ 
X+ static boolean initial, from_file;
X+ 
X+ static void FDECL(nmcpy, (char *, const char *, int));
X+ static void FDECL(escapes, (const char *, char *));
X+ static void FDECL(rejectoption, (const char *));
X+ static void FDECL(badoption, (const char *));
X+ static char *FDECL(string_for_opt, (char *,BOOLEAN_P));
X+ static char *FDECL(string_for_env_opt, (const char *, char *,BOOLEAN_P));
X+ static int FDECL(change_inv_order, (char *));
X+ static void FDECL(oc_to_str, (char *, char *));
X+ 
X  void
X  initoptions()
X  {
X***************
X*** 128,137 ****
X  	/* Set the default monster and object class symbols.  Don't use */
X  	/* memcpy() --- sizeof char != sizeof uchar on some machines.	*/
X  	for (i = 0; i < MAXOCLASSES; i++)
X! 	    	oc_syms[i] = (uchar) def_oc_syms[i];
X  	for (i = 0; i < MAXMCLASSES; i++)
X! 	    	monsyms[i] = (uchar) def_monsyms[i];
X  
X  	switch_graphics(ASCII_GRAPHICS);	/* set default characters */
X  #if defined(UNIX) && defined(TTY_GRAPHICS)
X  	/*
X--- 208,222 ----
X  	/* Set the default monster and object class symbols.  Don't use */
X  	/* memcpy() --- sizeof char != sizeof uchar on some machines.	*/
X  	for (i = 0; i < MAXOCLASSES; i++)
X! 		oc_syms[i] = (uchar) def_oc_syms[i];
X  	for (i = 0; i < MAXMCLASSES; i++)
X! 		monsyms[i] = (uchar) def_monsyms[i];
X  
X+      /* assert( sizeof flags.inv_order == sizeof def_inv_order ); */
X+ 	(void)memcpy((genericptr_t)flags.inv_order,
X+ 		     (genericptr_t)def_inv_order, sizeof flags.inv_order);
X+ 	flags.pickup_types[0] = '\0';
X+ 
X  	switch_graphics(ASCII_GRAPHICS);	/* set default characters */
X  #if defined(UNIX) && defined(TTY_GRAPHICS)
X  	/*
X***************
X*** 153,159 ****
X  # ifdef TTY_GRAPHICS
X  	/* detect whether a "vt" terminal can handle alternate charsets */
X  	if (!strncmpi(getenv("TERM"), "vt", 2) && (AS && AE) &&
X! 	    !strcmp(AS, "\016") && !strcmp(AE, "\017")) {
X  		switch_graphics(DEC_GRAPHICS);
X  	}
X  # endif
X--- 238,244 ----
X  # ifdef TTY_GRAPHICS
X  	/* detect whether a "vt" terminal can handle alternate charsets */
X  	if (!strncmpi(getenv("TERM"), "vt", 2) && (AS && AE) &&
X! 	    index(AS, '\016') && index(AE, '\017')) {
X  		switch_graphics(DEC_GRAPHICS);
X  	}
X  # endif
X***************
X*** 170,176 ****
X  #endif
X  	opts = getenv("NETHACKOPTIONS");
X  	if (!opts) opts = getenv("HACKOPTIONS");
X! 	if (opts)
X  		if (*opts == '/' || *opts == '\\' || *opts == '@') {
X  			if (*opts == '@') opts++;	/* @filename */
X  			/* looks like a filename */
X--- 255,261 ----
X  #endif
X  	opts = getenv("NETHACKOPTIONS");
X  	if (!opts) opts = getenv("HACKOPTIONS");
X! 	if (opts) {
X  		if (*opts == '/' || *opts == '\\' || *opts == '@') {
X  			if (*opts == '@') opts++;	/* @filename */
X  			/* looks like a filename */
X***************
X*** 179,186 ****
X  			read_config_file(NULL);
X  			parseoptions(opts, TRUE, FALSE);
X  		}
X! 	else
X  		read_config_file(NULL);
X  #ifdef AMIGA
X  	ami_wbench_init();	/* must be here or can't set fruit */
X  #endif
X--- 264,272 ----
X  			read_config_file(NULL);
X  			parseoptions(opts, TRUE, FALSE);
X  		}
X! 	} else {
X  		read_config_file(NULL);
X+ 	}
X  #ifdef AMIGA
X  	ami_wbench_init();	/* must be here or can't set fruit */
X  #endif
X***************
X*** 319,332 ****
X  }
X  
X  static char *
X! string_for_opt(opts)
X  char *opts;
X  {
X  	register char *colon;
X  
X  	colon = index(opts, ':');
X  	if(!colon) {
X! 		badoption(opts);
X  		return NULL;
X  	}
X  	return ++colon;
X--- 405,419 ----
X  }
X  
X  static char *
X! string_for_opt(opts, val_optional)
X  char *opts;
X+ boolean val_optional;
X  {
X  	register char *colon;
X  
X  	colon = index(opts, ':');
X  	if(!colon) {
X! 		if (!val_optional) badoption(opts);
X  		return NULL;
X  	}
X  	return ++colon;
X***************
X*** 333,347 ****
X  }
X  
X  static char *
X! string_for_env_opt(optname, opts)
X  const char *optname;
X  char *opts;
X  {
X  	if(!initial) {
X  		rejectoption(optname);
X  		return NULL;
X  	}
X! 	return string_for_opt(opts);
X  }
X  
X  /*
X--- 420,435 ----
X  }
X  
X  static char *
X! string_for_env_opt(optname, opts, val_optional)
X  const char *optname;
X  char *opts;
X+ boolean val_optional;
X  {
X  	if(!initial) {
X  		rejectoption(optname);
X  		return NULL;
X  	}
X! 	return string_for_opt(opts, val_optional);
X  }
X  
X  /*
X***************
X*** 364,370 ****
X  
X  	/* Remove bad or duplicate entries. */
X  	if (oc_sym == MAXOCLASSES ||
X! 		(!index(inv_order, oc_sym)) || (index(sp+1, *sp)))
X  
X  	    return 0;
X  
X--- 452,458 ----
X  
X  	/* Remove bad or duplicate entries. */
X  	if (oc_sym == MAXOCLASSES ||
X! 		(!index(flags.inv_order, oc_sym)) || (index(sp+1, *sp)))
X  
X  	    return 0;
X  
X***************
X*** 371,382 ****
X  	*sp = (char) oc_sym;
X      } 
X      Strcpy(buf, op);
X!     for (sp = inv_order, num = strlen(buf); *sp; sp++)
X! 	if (!index(buf, *sp))
X  	    buf[num++] = *sp;
X  
X      buf[num] = 0;
X!     Strcpy(inv_order, buf);
X      return 1;
X  }
X  
X--- 459,472 ----
X  	*sp = (char) oc_sym;
X      } 
X      Strcpy(buf, op);
X!     for (sp = flags.inv_order, num = strlen(buf); *sp; sp++)
X! 	if (!index(buf, *sp)) {
X  	    buf[num++] = *sp;
X+ 	    buf[num] = '\0';	/* explicitly terminate for next index() */
X+ 	}
X  
X      buf[num] = 0;
X!     Strcpy(flags.inv_order, buf);
X      return 1;
X  }
X  
X***************
X*** 438,444 ****
X  	/* compound options */
X  
X  	if (!strncmpi(opts, "pettype", 3)) {
X! 		if ((op = string_for_env_opt("pettype", opts)) != 0)
X  		    switch (*op) {
X  			case 'd':	/* dog */
X  			case 'D':
X--- 528,534 ----
X  	/* compound options */
X  
X  	if (!strncmpi(opts, "pettype", 3)) {
X! 		if ((op = string_for_env_opt("pettype", opts, FALSE)) != 0)
X  		    switch (*op) {
X  			case 'd':	/* dog */
X  			case 'D':
X***************
X*** 458,483 ****
X  	}
X  
X  	if (!strncmpi(opts, "catname", 3)) {
X! 		if ((op = string_for_env_opt("catname", opts)) != 0)
X  			nmcpy(catname, op, 62);
X  		return;
X  	}
X  
X  	if (!strncmpi(opts, "dogname", 3)) {
X! 		if ((op = string_for_env_opt("dogname", opts)) != 0)
X  			nmcpy(dogname, op, 62);
X  		return;
X  	}
X  
X  	if (!strncmpi(opts, "msghistory", 3)) {
X! 		if ((op = string_for_env_opt("msghistory", opts)) != 0) {
X  			flags.msg_history = atoi(op);
X  		}
X  		return;
X  	}
X  #ifdef TUTTI_FRUTTI
X  	if (!strncmpi(opts, "fruit", 2)) {
X! 		if (!(op = string_for_opt(opts))) return;
X  		if (!initial) {
X  		    struct fruit *f;
X  
X--- 548,640 ----
X  	}
X  
X  	if (!strncmpi(opts, "catname", 3)) {
X! 		if ((op = string_for_env_opt("catname", opts, FALSE)) != 0)
X  			nmcpy(catname, op, 62);
X  		return;
X  	}
X  
X  	if (!strncmpi(opts, "dogname", 3)) {
X! 		if ((op = string_for_env_opt("dogname", opts, FALSE)) != 0)
X  			nmcpy(dogname, op, 62);
X  		return;
X  	}
X  
X  	if (!strncmpi(opts, "msghistory", 3)) {
X! 		if ((op = string_for_env_opt("msghistory", opts, FALSE)) != 0) {
X  			flags.msg_history = atoi(op);
X  		}
X  		return;
X  	}
X+ 
X+ #ifdef CHANGE_COLOR
X+ 	if (!strncmpi(opts, "palette", 3)
X+ # ifdef MAC
X+ 					|| !strncmpi(opts, "hicolor", 3)
X+ # endif
X+ 									) {
X+ 	    int color_number, color_incr;
X+ # ifdef MAC
X+ 	    if (!strncmpi(opts, "hicolor", 3)) {
X+ 		color_number = MAXCOLORS + 4;	/* HARDCODED inverse number */
X+ 		color_incr = -1;
X+ 	    } else {
X+ # endif
X+ 		color_number = 0;
X+ 		color_incr = 1;
X+ # ifdef MAC
X+ 	    }
X+ # endif
X+ 	    if ((op = string_for_opt(opts, FALSE)) != NULL) {
X+ 		char *pt = op;
X+ 		int cnt, tmp, reverse;
X+ 		long rgb;
X+ 
X+ 		while (*pt && color_number >= 0) {
X+ 		    cnt = 3;
X+ 		    rgb = 0L;
X+ 		    if (*pt == '-') {
X+ 			reverse = 1;
X+ 			pt++;
X+ 		    } else {
X+ 			reverse = 0;
X+ 		    }
X+ 		    while (cnt-- > 0) {
X+ 			if (*pt && *pt != '/') {
X+ # ifdef AMIGA
X+ 			    rgb <<= 4;
X+ # else
X+ 			    rgb <<= 8;
X+ # endif
X+ 			    tmp = *(pt++);
X+ 			    if (isalpha(tmp)) {
X+ 				tmp = (tmp + 9) & 0xf;	/* Assumes ASCII... */
X+ 			    } else {
X+ 				tmp &= 0xf;	/* Digits in ASCII too... */
X+ 			    }
X+ # ifndef AMIGA
X+ 			    /* Add an extra so we fill f -> ff and 0 -> 00 */
X+ 			    rgb += tmp << 4;
X+ # endif
X+ 			    rgb += tmp;
X+ 			}
X+ 		    }
X+ 		    if (*pt == '/') {
X+ 			pt++;
X+ 		    }
X+ 		    change_color(color_number, rgb, reverse);
X+ 		    color_number += color_incr;
X+ 		}
X+ 	    }
X+ 	    if (!initial) {
X+ 		need_redraw = TRUE;
X+ 	    }
X+ 	    return;
X+ 	}
X+ #endif
X+ 
X  #ifdef TUTTI_FRUTTI
X  	if (!strncmpi(opts, "fruit", 2)) {
X! 		if (!(op = string_for_opt(opts, FALSE))) return;
X  		if (!initial) {
X  		    struct fruit *f;
X  
X***************
X*** 510,516 ****
X  		uchar translate[MAXPCHARS+1];
X  		int length;
X  
X! 		if (!(opts = string_for_env_opt("graphics", opts)))
X  			return;
X  		escapes(opts, opts);
X  
X--- 667,673 ----
X  		uchar translate[MAXPCHARS+1];
X  		int length;
X  
X! 		if (!(opts = string_for_env_opt("graphics", opts, FALSE)))
X  			return;
X  		escapes(opts, opts);
X  
X***************
X*** 527,533 ****
X  	if (!strncmpi(opts, "objects", 7)) {
X  		int length;
X  
X! 		if (!(opts = string_for_env_opt("objects", opts)))
X  			return;
X  		escapes(opts, opts);
X  
X--- 684,690 ----
X  	if (!strncmpi(opts, "objects", 7)) {
X  		int length;
X  
X! 		if (!(opts = string_for_env_opt("objects", opts, FALSE)))
X  			return;
X  		escapes(opts, opts);
X  
X***************
X*** 553,559 ****
X  	if (!strncmpi(opts, "monsters", 8)) {
X  		int length;
X  
X! 		if (!(opts = string_for_env_opt("monsters", opts)))
X  			return;
X  		escapes(opts, opts);
X  
X--- 710,716 ----
X  	if (!strncmpi(opts, "monsters", 8)) {
X  		int length;
X  
X! 		if (!(opts = string_for_env_opt("monsters", opts, FALSE)))
X  			return;
X  		escapes(opts, opts);
X  
X***************
X*** 569,575 ****
X  
X  	/* name:string */
X  	if (!strncmpi(opts, "name", 4)) {
X! 		if ((op = string_for_env_opt("name", opts)) != 0)
X  			nmcpy(plname, op, (int)sizeof(plname)-1);
X  		return;
X  	}
X--- 726,732 ----
X  
X  	/* name:string */
X  	if (!strncmpi(opts, "name", 4)) {
X! 		if ((op = string_for_env_opt("name", opts, FALSE)) != 0)
X  			nmcpy(plname, op, (int)sizeof(plname)-1);
X  		return;
X  	}
X***************
X*** 576,591 ****
X  
X  	/* the order to list the pack */
X  	if (!strncmpi(opts, "packorder", 4)) {
X! 		if (!(op = string_for_opt(opts))) return;
X  
X  		if (!change_inv_order(op))
X! 		    	badoption(opts);
X  		return;
X  	}
X  
X  	/* scores:5t[op] 5a[round] o[wn] */
X  	if (!strncmpi(opts, "scores", 6)) {
X! 		if (!(op = string_for_opt(opts))) return;
X  
X  		while (*op) {
X  			num = 1;
X--- 733,808 ----
X  
X  	/* the order to list the pack */
X  	if (!strncmpi(opts, "packorder", 4)) {
X! 		if (!(op = string_for_opt(opts, FALSE))) return;
X  
X  		if (!change_inv_order(op))
X! 			badoption(opts);
X  		return;
X  	}
X  
X+ 	/* types of objects to pick up automatically */
X+ 	if (!strncmpi(opts, "pickup_types", 4)) {
X+ 		int oc_sym;
X+ 		boolean badopt = FALSE, compat = (strlen(opts) <= 6);
X+ 
X+ 		flags.pickup_types[0] = '\0';	/* all */
X+ 		if (!(op = string_for_opt(opts, compat))) {
X+ 		    /* for backwards compatibility, "pickup" without a value
X+ 		       is a synonym for boolean autopickup, and pickup_types
X+ 		       gets reset to "all"				    */
X+ 		    flags.pickup = !negated;
X+ 		    return;
X+ 		}
X+ 
X+ 		while (*op == ' ') op++;
X+ 		if (*op != 'a' && *op != 'A') {
X+ 		    num = 0;
X+ 		    while (*op) {
X+ 			oc_sym = def_char_to_objclass(*op);
X+ 			/* make sure all are valid obj symbols occuring once */
X+ 			if (oc_sym != MAXOCLASSES &&
X+ 			    !index(flags.pickup_types, oc_sym)) {
X+ 			    flags.pickup_types[num] = (char)oc_sym;
X+ 			    flags.pickup_types[++num] = '\0';
X+ 			} else
X+ 			    badopt = TRUE;
X+ 			op++;
X+ 		    }
X+ 		    if (badopt) badoption(opts);
X+ 		}
X+ 		return;
X+ 	}
X+ 
X+ 	/* things to disclose at end of game */
X+ 	if (!strncmpi(opts, "disclose", 4)) {
X+ 		flags.end_disclose[0] = '\0';	/* all */
X+ 		if (!(op = string_for_opt(opts, TRUE))) {
X+ 			/* for backwards compatibility, "disclose" without a
X+ 			 * value means all (was inventory and attributes,
X+ 			 * the only things available then), but negated
X+ 			 * it means "none"
X+ 			 * (note "none" contains none of "iavkg")
X+ 			 */
X+ 			if (negated) Strcpy(flags.end_disclose, "none");
X+ 			return;
X+ 		}
X+ 		num = 0;
X+ 		while (*op && num < sizeof flags.end_disclose - 1) {
X+ 			register char c;
X+ 			c = lowc(*op);
X+ 			if (c == 'k') c = 'v';	/* killed -> vanquished */
X+ 			if (!index(flags.end_disclose, c)) {
X+ 				flags.end_disclose[num++] = c;
X+ 				flags.end_disclose[num] = '\0';	/* for index */
X+ 			}
X+ 			op++;
X+ 		}
X+ 		return;
X+ 	}
X+ 
X  	/* scores:5t[op] 5a[round] o[wn] */
X  	if (!strncmpi(opts, "scores", 6)) {
X! 		if (!(op = string_for_opt(opts, FALSE))) return;
X  
X  		while (*op) {
X  			num = 1;
X***************
X*** 622,628 ****
X  	}
X  
X  	if (!strncmpi(opts, "windowtype", 3)) {
X! 	    if ((op = string_for_env_opt("windowtype", opts)) != 0) {
X  		char buf[16];
X  		nmcpy(buf, op, 15);
X  		choose_windows(buf);
X--- 839,845 ----
X  	}
X  
X  	if (!strncmpi(opts, "windowtype", 3)) {
X! 	    if ((op = string_for_env_opt("windowtype", opts, FALSE)) != 0) {
X  		char buf[16];
X  		nmcpy(buf, op, 15);
X  		choose_windows(buf);
X***************
X*** 634,642 ****
X  	 * options list
X  	 */
X  	for (i = 0; boolopt[i].name; i++) {
X! 		if (boolopt[i].addr && strlen(opts) >= 3 &&
X  		    !strncmpi(boolopt[i].name, opts, strlen(opts))) {
X! 		        /* options that must come from config file */
X  			if (!initial &&
X  			    ((boolopt[i].addr) == &flags.legacy
X  #if defined(MICRO) && !defined(AMIGA)
X--- 851,866 ----
X  	 * options list
X  	 */
X  	for (i = 0; boolopt[i].name; i++) {
X! 		if (strlen(opts) >= 3 &&
X  		    !strncmpi(boolopt[i].name, opts, strlen(opts))) {
X! 			/* options that don't exist */
X! 			if (!boolopt[i].addr) {
X! 			    if (!initial && !negated)
X! 				pline("The \"%s\" option is not available.",
X! 					boolopt[i].name);
X! 			    return;
X! 			}
X! 			/* options that must come from config file */
X  			if (!initial &&
X  			    ((boolopt[i].addr) == &flags.legacy
X  #if defined(MICRO) && !defined(AMIGA)
X***************
X*** 763,769 ****
X      *dest = '\0';
X  }
X  
X! #ifdef MICRO
X  # define OPTIONS_HEADING "OPTIONS"
X  #else
X  # define OPTIONS_HEADING "NETHACKOPTIONS"
X--- 987,993 ----
X      *dest = '\0';
X  }
X  
X! #if defined(MICRO) || defined(MAC)
X  # define OPTIONS_HEADING "OPTIONS"
X  #else
X  # define OPTIONS_HEADING "NETHACKOPTIONS"
X***************
X*** 772,778 ****
X  int
X  doset()
X  {
X! 	char buf[BUFSZ], pack_order[MAXOCLASSES+1], on_off;
X  	const char *opt_name;
X  	int i;
X  	winid tmpwin;
X--- 996,1002 ----
X  int
X  doset()
X  {
X! 	char buf[BUFSZ], ocl[MAXOCLASSES+1], on_off;
X  	const char *opt_name;
X  	int i;
X  	winid tmpwin;
X***************
X*** 806,811 ****
X--- 1030,1038 ----
X  	    Sprintf(buf, " catname: %s",
X  			(catname[0] != 0) ? catname : "(null)");
X  	    putstr(tmpwin, 0, buf);
X+ 	    Sprintf(buf, " disclose: %s",
X+ 			(flags.end_disclose[0]) ? flags.end_disclose : "all");
X+ 	    putstr(tmpwin, 0, buf);
X  	    Sprintf(buf, " dogname: %s",
X  			(dogname[0] != 0) ? dogname : "(null)");
X  	    putstr(tmpwin, 0, buf);
X***************
X*** 817,828 ****
X  	    putstr(tmpwin, 0, buf);
X  	    Sprintf(buf, " name: %s", plname);
X  	    putstr(tmpwin, 0, buf);
X! 	    oc_to_str(inv_order, pack_order);
X! 	    Sprintf(buf, " packorder: %s", pack_order);
X  	    putstr(tmpwin, 0, buf);
X  	    Sprintf(buf, " pettype: %s", preferred_pet == 'c' ? "cat" :
X  				    preferred_pet == 'd' ? "dog" : "random");
X  	    putstr(tmpwin, 0, buf);
X  	    Sprintf(buf, " scores: %utop/%uaround%s",
X  		        flags.end_top, flags.end_around,
X  		        (flags.end_own ? "/own" : ""));
X--- 1044,1062 ----
X  	    putstr(tmpwin, 0, buf);
X  	    Sprintf(buf, " name: %s", plname);
X  	    putstr(tmpwin, 0, buf);
X! 	    oc_to_str(flags.inv_order, ocl);
X! 	    Sprintf(buf, " packorder: %s", ocl);
X  	    putstr(tmpwin, 0, buf);
X+ #ifdef CHANGE_COLOR
X+ 	    Sprintf(buf, " palette: %s", get_color_string());
X+ 	    putstr(tmpwin, 0, buf);
X+ #endif
X  	    Sprintf(buf, " pettype: %s", preferred_pet == 'c' ? "cat" :
X  				    preferred_pet == 'd' ? "dog" : "random");
X  	    putstr(tmpwin, 0, buf);
X+ 	    oc_to_str(flags.pickup_types, ocl);
X+ 	    Sprintf(buf, " pickup_types: %s", (ocl[0]) ? ocl : "all");
X+ 	    putstr(tmpwin, 0, buf);
X  	    Sprintf(buf, " scores: %utop/%uaround%s",
X  		        flags.end_top, flags.end_around,
X  		        (flags.end_own ? "/own" : ""));
X***************
X*** 847,855 ****
X  }
X  
X  int
X! dotogglepickup() {
X  	flags.pickup = !flags.pickup;
X! 	pline("Pickup: %s.", flags.pickup ? "ON" : "OFF");
X  	return 0;
X  }
X  
X--- 1081,1098 ----
X  }
X  
X  int
X! dotogglepickup()
X! {
X! 	char buf[BUFSZ], ocl[MAXOCLASSES+1];
X! 
X  	flags.pickup = !flags.pickup;
X! 	if (flags.pickup) {
X! 	    oc_to_str(flags.pickup_types, ocl);
X! 	    Sprintf(buf, "ON, for %s objects", ocl[0] ? ocl : "all");
X! 	} else {
X! 	    Strcpy(buf, "OFF");
X! 	}
X! 	pline("Autopickup: %s.", buf);
X  	return 0;
X  }
X  
X***************
X*** 860,898 ****
X  	"",
X  #define CONFIG_SLOT 3	/* fill in next value at run-time */
X  	NULL,
X! #ifndef MICRO
X  	"or use `NETHACKOPTIONS=\"<options>\"' in your environment;",
X  # ifdef VMS
X! 	"-- for example, $ DEFINE NETHACKOPTIONS \"nopickup,fruit:kumquat\"",
X  # endif
X  #endif
X  	"or press \"O\" while playing, and type your <options> at the prompt.",
X! 	"In either case, <options> is a list of options separated by commas.",
X  	"",
X   "Boolean options (which can be negated by prefixing them with '!' or \"no\"):",
X  	NULL
X  };
X! static const char *opt_compound[] = {
X! 	"Compound options:",
X! 	"`catname'   - the name of your (first) cat (e.g., catname:Tabby),",
X! 	"`dogname'   - the name of your (first) dog (e.g., dogname:Fang),",
X! #ifdef TUTTI_FRUTTI
X! 	"`fruit'     - the name of a fruit you enjoy eating,",
X! # define FRUIT_OFFSET 1
X! #else
X! # define FRUIT_OFFSET 0
X! #endif
X! 	"`graphics'  - defines the symbols to use in drawing the dungeon map,",
X! 	"`monsters'  - defines the symbols to use for monsters,",
X! 	"`msghistory'- number of top line messages to save,",
X! 	"`name'      - your character's name (e.g., name:Merlin-W),",
X! 	"`objects'   - defines the symbols to use for objects,",
X! 	"`packorder' - the inventory order of the items in your pack",
X! #define PCKORD_SLOT 9+FRUIT_OFFSET
X! 	NULL,
X! 	"`pettype'   - your preferred initial pet type,",
X! 	"`scores'    - the parts of the score list you wish to see,",
X! 	"`windowtype'- windowing system to use.",
X  	"",
X   "Some of the options can be set only before the game is started.  You will",
X  	"be so informed, if you attempt to set them while in the game.",
X--- 1103,1122 ----
X  	"",
X  #define CONFIG_SLOT 3	/* fill in next value at run-time */
X  	NULL,
X! #if !defined(MICRO) && !defined(MAC)
X  	"or use `NETHACKOPTIONS=\"<options>\"' in your environment;",
X  # ifdef VMS
X! 	"-- for example, $ DEFINE NETHACKOPTIONS \"noautopickup,fruit:kumquat\"",
X  # endif
X  #endif
X  	"or press \"O\" while playing, and type your <options> at the prompt.",
X! 	"In all cases, <options> is a list of options separated by commas.",
X  	"",
X   "Boolean options (which can be negated by prefixing them with '!' or \"no\"):",
X  	NULL
X  };
X! 
X! static const char *opt_epilog[] = {
X  	"",
X   "Some of the options can be set only before the game is started.  You will",
X  	"be so informed, if you attempt to set them while in the game.",
X***************
X*** 902,909 ****
X  void
X  option_help()
X  {
X!     char	buf[BUFSZ], pack_order[MAXOCLASSES+1];
X!     register int	i;
X      winid datawin;
X  
X      datawin = create_nhwindow(NHW_TEXT);
X--- 1126,1133 ----
X  void
X  option_help()
X  {
X!     char buf[BUFSZ], buf2[BUFSZ];
X!     register int i;
X      winid datawin;
X  
X      datawin = create_nhwindow(NHW_TEXT);
X***************
X*** 925,939 ****
X      next_opt(datawin, "");
X  
X      /* Compound options */
X!     oc_to_str(inv_order, pack_order);
X!     Sprintf(buf, "              (currently, packorder:%s ),", pack_order);
X! #if 0
X!     assert( opt_compound[PCKORD_SLOT] == NULL );
X! #endif
X!     opt_compound[PCKORD_SLOT] = (const char *) buf;
X!     for (i = 0; opt_compound[i]; i++)
X! 	putstr(datawin, 0, opt_compound[i]);
X  
X      display_nhwindow(datawin, FALSE);
X      destroy_nhwindow(datawin);
X      return;
X--- 1149,1164 ----
X      next_opt(datawin, "");
X  
X      /* Compound options */
X!     putstr(datawin, 0, "Compound options:");
X!     for (i = 0; compopt[i].name; i++) {
X! 	Sprintf(buf2, "`%s'", compopt[i].name);
X! 	Sprintf(buf, "%-14s - %s", buf2, compopt[i].descr);
X! 	putstr(datawin, 0, buf);
X!     }
X  
X+     for (i = 0; opt_epilog[i]; i++)
X+ 	putstr(datawin, 0, opt_epilog[i]);
X+ 
X      display_nhwindow(datawin, FALSE);
X      destroy_nhwindow(datawin);
X      return;
X***************
X*** 1047,1051 ****
X--- 1272,1278 ----
X  	return f->fid;
X  }
X  #endif
X+ 
X+ #endif	/* OPTION_LISTS_ONLY */
X  
X  /*options.c*/
X*** /tmp/da11234	Tue Jun  1 16:15:06 1993
X--- src/pager.c	Fri May 28 11:32:07 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)pager.c	3.1	93/02/04	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)pager.c	3.1	93/05/26	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 5,17 ****
X  /* This file contains the command routines dowhatis() and dohelp() and */
X  /* a few other help related facilities */
X  
X! #include	"hack.h"
X  
X  #ifndef SEEK_SET
X  #define SEEK_SET 0
X  #endif
X  
X! static boolean FDECL(is_swallow_sym, (UCHAR_P));
X  static int FDECL(append_str, (char *, const char *));
X  static void FDECL(lookat, (int, int, char *));
X  static void FDECL(checkfile, (char *, BOOLEAN_P));
X--- 5,17 ----
X  /* This file contains the command routines dowhatis() and dohelp() and */
X  /* a few other help related facilities */
X  
X! #include "hack.h"
X  
X  #ifndef SEEK_SET
X  #define SEEK_SET 0
X  #endif
X  
X! static boolean FDECL(is_swallow_sym, (int));
X  static int FDECL(append_str, (char *, const char *));
X  static void FDECL(lookat, (int, int, char *));
X  static void FDECL(checkfile, (char *, BOOLEAN_P));
X***************
X*** 24,34 ****
X  /* Returns "true" for characters that could represent a monster's stomach. */
X  static boolean
X  is_swallow_sym(c)
X!     uchar c;
X  {
X      int i;
X      for (i = S_sw_tl; i <= S_sw_br; i++)
X! 	if (showsyms[i] == c) return TRUE;
X      return FALSE;
X  }
X  
X--- 24,34 ----
X  /* Returns "true" for characters that could represent a monster's stomach. */
X  static boolean
X  is_swallow_sym(c)
X! int c;
X  {
X      int i;
X      for (i = S_sw_tl; i <= S_sw_br; i++)
X! 	if ((int)showsyms[i] == c) return TRUE;
X      return FALSE;
X  }
X  
X***************
X*** 68,74 ****
X      buf[0] = 0;
X      glyph = glyph_at(x,y);
X      if (u.ux == x && u.uy == y && canseeself()) {
X! 	Sprintf(buf, "%s called %s",
X  #ifdef POLYSELF
X  		u.mtimedone ? mons[u.umonnum].mname :
X  #endif
X--- 68,75 ----
X      buf[0] = 0;
X      glyph = glyph_at(x,y);
X      if (u.ux == x && u.uy == y && canseeself()) {
X! 	Sprintf(buf, "%s%s called %s",
X! 		Invis ? "invisible " : "",
X  #ifdef POLYSELF
X  		u.mtimedone ? mons[u.umonnum].mname :
X  #endif
X***************
X*** 115,123 ****
X  	    }
X  	} else
X  	    Strcpy(buf, distant_name(otmp, xname));
X      }
X      else if (glyph_is_trap(glyph)) {
X! 	if (trap = t_at(x, y)) {
X  	    if (trap->ttyp == WEB)
X  		Strcpy(buf, "web");
X  	    else {
X--- 116,135 ----
X  	    }
X  	} else
X  	    Strcpy(buf, distant_name(otmp, xname));
X+ 
X+ 	if (levl[x][y].typ == STONE || levl[x][y].typ == SCORR)
X+ 	    Strcat(buf, " embedded in stone");
X+ 	else if (IS_WALL(levl[x][y].typ) || levl[x][y].typ == SDOOR)
X+ 	    Strcat(buf, " embedded in a wall");
X+ 	else if (closed_door(x,y))
X+ 	    Strcat(buf, " embedded in a door");
X+ 	else if (is_pool(x,y))
X+ 	    Strcat(buf, " in water");
X+ 	else if (is_lava(x,y))
X+ 	    Strcat(buf, " in molten lava");	/* [can this ever happen?] */
X      }
X      else if (glyph_is_trap(glyph)) {
X! 	if ((trap = t_at(x, y)) != 0) {
X  	    if (trap->ttyp == WEB)
X  		Strcpy(buf, "web");
X  	    else {
X***************
X*** 126,132 ****
X  		/* strip leading garbage */
X  		for (s = buf; *s && *s != ' '; s++) ;
X  		if (*s) ++s;
X! 		for (t = buf; *t++ = *s++; ) ;
X  	    }
X  	}
X      }
X--- 138,144 ----
X  		/* strip leading garbage */
X  		for (s = buf; *s && *s != ' '; s++) ;
X  		if (*s) ++s;
X! 		for (t = buf; (*t++ = *s++) != 0; ) ;
X  	    }
X  	}
X      }
X***************
X*** 296,305 ****
X      boolean need_to_look;	/* need to get explan. from glyph */
X      static const char *mon_interior = "the interior of a monster";
X  
X- #ifdef GCC_WARN
X-     sym = 0;
X- #endif
X- 
X      if (quick) {
X  	from_screen = TRUE;	/* yes, we want to use the cursor */
X      } else {
X--- 308,313 ----
X***************
X*** 311,316 ****
X--- 319,325 ----
X      if (from_screen) {
X  	cc.x = u.ux;
X  	cc.y = u.uy;
X+ 	sym = 0;		/* gcc -Wall lint */
X      } else {
X  	getlin("Specify what? (type the word)", out_str);
X  	if (out_str[0] == '\0' || out_str[0] == '\033')
X***************
X*** 357,365 ****
X  	    } else if (glyph_is_trap(glyph)) {
X  		sym = showsyms[(glyph_to_trap(glyph) == WEB) ? S_web : S_trap];
X  	    } else if (glyph_is_object(glyph)) {
X! 		sym = oc_syms[objects[glyph_to_obj(glyph)].oc_class];
X  	    } else if (glyph_is_monster(glyph)) {
X! 		sym = monsyms[mons[glyph_to_mon(glyph)].mlet];
X  	    } else if (glyph_is_swallow(glyph)) {
X  		sym = showsyms[glyph_to_swallow(glyph)+S_sw_tl];
X  	    } else {
X--- 366,374 ----
X  	    } else if (glyph_is_trap(glyph)) {
X  		sym = showsyms[(glyph_to_trap(glyph) == WEB) ? S_web : S_trap];
X  	    } else if (glyph_is_object(glyph)) {
X! 		sym = oc_syms[(int)objects[glyph_to_obj(glyph)].oc_class];
X  	    } else if (glyph_is_monster(glyph)) {
X! 		sym = monsyms[(int)mons[glyph_to_mon(glyph)].mlet];
X  	    } else if (glyph_is_swallow(glyph)) {
X  		sym = showsyms[glyph_to_swallow(glyph)+S_sw_tl];
X  	    } else {
X***************
X*** 393,399 ****
X  	 * and looking at something other than our own symbol, then just say
X  	 * "the interior of a monster".
X  	 */
X! 	if (u.uswallow && from_screen && is_swallow_sym((uchar) sym)) {
X  	    if (!found) {
X  		Sprintf(out_str, "%c       %s", sym, mon_interior);
X  		firstmatch = mon_interior;
X--- 402,408 ----
X  	 * and looking at something other than our own symbol, then just say
X  	 * "the interior of a monster".
X  	 */
X! 	if (u.uswallow && from_screen && is_swallow_sym(sym)) {
X  	    if (!found) {
X  		Sprintf(out_str, "%c       %s", sym, mon_interior);
X  		firstmatch = mon_interior;
END_OF_FILE
if test 55370 -ne `wc -c <'patches02f'`; then
    echo shar: \"'patches02f'\" unpacked with wrong size!
fi
# end of 'patches02f'
if test -f 'sys/winnt/winnt.cnf' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'sys/winnt/winnt.cnf'\" to \"'sys/winnt/winnt.cnf.orig'\"
  mv -f 'sys/winnt/winnt.cnf' 'sys/winnt/winnt.cnf.orig'
fi
echo shar: Extracting \"'sys/winnt/winnt.cnf'\" \(3017 characters\)
sed "s/^X//" >'sys/winnt/winnt.cnf' <<'END_OF_FILE'
X# NetHack.cnf file for Windows NT
X# A '#' at the beginning of a line means the rest of the line is a comment.
X#
X# To change the configuration, comment out the unwanted lines, and
X# uncomment the configuration you want.
X
X
X# *** OPTIONS ***
X#
X# Some options to set personal preferences.  Uncomment and change these to
X# suit your personal preference.  If several people are to use the same
X# configuration, options like these should not be set.
X#
X#OPTIONS=name:Janet-V,female,dogname:Fido,catname:Morris,fruit:apricot
X#OPTIONS=packorder:")[%?+/=!(*0_`,scores:10 top/2 around/own
X#
X#
X# Other general options.  You might also set "silent" so as not to attract
X# the boss's attention.
X#
XOPTIONS=time,rest_on_space,noautopickup,number_pad
X
X
X# *** HARD DISK CONFIGURATION ***
X#
XHACKDIR=c:\games\nethack
X#
X#   LEVELS and SAVE default to HACKDIR
X#
X#LEVELS=c:\games\nethack\bones
X#SAVE=c:\games\nethack\bones;n
X#
X#   appending a ";n" to SAVE means don't prompt to insert a disk.
XSAVE=;n
X#
X# *** CHARACTER GRAPHICS ***
X#
X# The 69 GRAPHICS characters (0-68) are:
X#
X# stone,
X# walls: vertical, horizontal,
X#	 4 corners: top left, top right, bottom left, bottom right,
X#	 cross wall,
X#	 4 T walls: upward, downward, left, right,
X# doors: no door,
X#	 open doors: vertical, horizontal,
X#	 closed doors: vertical, horizontal,
X# floor,
X# corridors: unlit, lit,
X# stairs up, stairs down, ladder up, ladder down,
X# trap, web, altar, throne, sink, fountain, pool/moat, ice, lava,
X# lowered drawbridge: vertical, horizontal,
X# raised drawbridge: vertical, horizontal,
X# air, cloud, water,
X# 4 beams: vertical, horizontal, left slant, right slant,
X# digging beam, camera flash beam, left boomerang, right boomerang,
X# 4 magic shield display symbols,
X# 8 swallowed: top left/middle/right, mid left/right, bottom left/mid/right,
X# 9 explosion: [3 rows (top, middle, bottom) of 3 characters]
X#
X# If you specify fewer that 69 ASCII values, the remaining characters will be
X# set to their respective defaults:
X#	   ' '  |   -   -   -   -   -   -   -   -
X#           |   |   .   -   |   +   +   .   #   #
X#	    <   >   <   >   ^   "   _   \   #   {
X#	    }   .   }   .   .   #   #  ' '  #   }
X#	    |   -   \   /   *   !   )   (   0   #
X#	    @   *   /   -   \   |   |   \   -   /
X#	    /   -   \   |  ' '  |   \   -   /
X#
X#
X# An example using the IBM graphics character set:
XGRAPHICS= 032 186 205 201 187 200 188 206 202 203 \
X	   185 204 249 239 239 254 254 249 177 177 \
X	   060 062 060 062 094 034 095 092 035 244 \
X	   247 249 247 042 042 179 196 046 035 247 \
X	   179 196 092 047 042 033 041 040 048 035 \
X	   064 042 047 045 092 058 058 092 045 047 \
X	   047 045 092 058 032 058 092 045 047
X
X# An alternative:
X#GRAPHICS= 032 179 196 218 191 192 217 197 193 194 \
X#	   180 195 249 239 239 254 254 249 177 177 \
X#	   060 062 060 062 094 157 220 190 035 244 \
X#	   247 249 247 042 042 186 205 046 035 247 \
X#	   179 196 092 047 042 033 041 040 048 035 \
X#	   064 042 047 045 092 058 058 092 045 047 \
X#	   047 045 092 058 032 058 092 045 047
END_OF_FILE
if test 3017 -ne `wc -c <'sys/winnt/winnt.cnf'`; then
    echo shar: \"'sys/winnt/winnt.cnf'\" unpacked with wrong size!
fi
# end of 'sys/winnt/winnt.cnf'
echo shar: End of archive 10 \(of 33\).
cp /dev/null ark10isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 33 archives.
    echo "Now execute ./patchit.sh"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
