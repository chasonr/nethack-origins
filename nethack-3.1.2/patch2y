Path: uunet!gatech!news-feed-1.peachnet.edu!emory!ogicse!news.tek.com!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v17i100:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Patch2y/33
Message-ID: <1v8itv$j7r@ying.cna.tek.com>
Date: 11 Jun 93 00:17:03 GMT
Article-I.D.: ying.1v8itv$j7r
Organization: Tektronix, Inc, Redmond, OR, USA
Lines: 2169
Approved: billr@saab.CNA.TEK.COM
NNTP-Posting-Host: saab.cna.tek.com
Xref: uunet comp.sources.games:1763

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 17, Issue 100
Archive-name: nethack31/Patch2y
Patch-To: nethack31: Volume 16, Issue 1-116
Environment: Amiga, Atari, Mac, MS-DOS, Windows-NT, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 25 (of 33)."
# Contents:  patches02p.2 sys/share/dgn_lex.c
# Wrapped by billr@saab on Thu Jun 10 16:55:06 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'patches02p.2' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'patches02p.2'\" to \"'patches02p.2.orig'\"
  mv -f 'patches02p.2' 'patches02p.2.orig'
fi
echo shar: Extracting \"'patches02p.2'\" \(23123 characters\)
sed "s/^X//" >'patches02p.2' <<'END_OF_FILE'
X***************
X*** 2031,2037 ****
X  {
X  	Rect r = theWindow -> portRect ;
X  	Rect r2 = r ;
X! 	NhWindow * aWin = ( NhWindow * ) GetWRefCon ( theWindow ) ;
X  	RgnHandle h ;
X  	Boolean vis ;
X  
X--- 2020,2026 ----
X  {
X  	Rect r = theWindow -> portRect ;
X  	Rect r2 = r ;
X! 	NhWindow * aWin = GetNhWin ( theWindow ) ;
X  	RgnHandle h ;
X  	Boolean vis ;
X  
X***************
X*** 2077,2082 ****
X--- 2066,2074 ----
X  static void
X  macCursorNull ( EventRecord * theEvent , WindowPtr theWindow , RgnHandle mouseRgn )
X  {
X+ #if defined(applec)
X+ # pragma unused(theWindow)
X+ #endif
X  	Rect r = { -1 , -1 , 2 , 2 } ;
X  
X  	InitCursor ( ) ;
X***************
X*** 2088,2093 ****
X--- 2080,2088 ----
X  static void
X  macCursorMessage ( EventRecord * theEvent , WindowPtr theWindow , RgnHandle mouseRgn )
X  {
X+ #if defined(applec)
X+ # pragma unused(theWindow)
X+ #endif
X  	Rect r = { -1 , -1 , 2 , 2 } ;
X  
X  	InitCursor ( ) ;
X***************
X*** 2097,2120 ****
X  
X  
X  static void
X! macCursorStatus ( EventRecord * theEvent , WindowPtr theWindow , RgnHandle mouseRgn )
X  {
X- 	Rect r = { -1 , -1 , 2 , 2 } ;
X- 
X- 	InitCursor ( ) ;
X- 	OffsetRect ( & r , theEvent -> where . h , theEvent -> where . v ) ;
X- 	RectRgn ( mouseRgn , & r ) ;
X- }
X- 
X- 
X- static void
X- macCursorMap ( EventRecord * theEvent , WindowPtr theWindow , RgnHandle mouseRgn )
X- {
X  	Point where ;
X  	char * dir_bas , * dir ;
X  	CursHandle ch ;
X  	GrafPtr gp ;
X! 	NhWindow * nhw = ( NhWindow * ) GetWRefCon ( theWindow ) ;
X  	Rect r = { 0 , 0 , 1 , 1 } ;
X  
X  	GetPort ( & gp ) ;
X--- 2092,2104 ----
X  
X  
X  static void
X! macCursorTerm ( EventRecord * theEvent , WindowPtr theWindow , RgnHandle mouseRgn )
X  {
X  	Point where ;
X  	char * dir_bas , * dir ;
X  	CursHandle ch ;
X  	GrafPtr gp ;
X! 	NhWindow * nhw = GetNhWin ( theWindow ) ;
X  	Rect r = { 0 , 0 , 1 , 1 } ;
X  
X  	GetPort ( & gp ) ;
X***************
X*** 2127,2133 ****
X  		dir = NULL ;
X  	else {
X  		dir_bas = flags . num_pad ? ndir : sdir ;
X! 		dir = strchr ( dir_bas , click_to_cmd ( where . h / nhw -> charWidth ,
X  												where . v / nhw -> charHeight ,
X  												CLICK_1 ) ) ;
X  	}
X--- 2111,2117 ----
X  		dir = NULL ;
X  	else {
X  		dir_bas = flags . num_pad ? ndir : sdir ;
X! 		dir = strchr ( dir_bas , click_to_cmd ( where . h / nhw -> charWidth + 1 ,
X  												where . v / nhw -> charHeight ,
X  												CLICK_1 ) ) ;
X  	}
X***************
X*** 2152,2157 ****
X--- 2136,2144 ----
X  static void
X  macCursorMenu ( EventRecord * theEvent , WindowPtr theWindow , RgnHandle mouseRgn )
X  {
X+ #if defined(applec)
X+ # pragma unused(theWindow)
X+ #endif
X  	Rect r = { -1 , -1 , 2 , 2 } ;
X  
X  	InitCursor ( ) ;
X***************
X*** 2163,2168 ****
X--- 2150,2158 ----
X  static void
X  macCursorText ( EventRecord * theEvent , WindowPtr theWindow , RgnHandle mouseRgn )
X  {
X+ #if defined(applec)
X+ # pragma unused(theWindow)
X+ #endif
X  	Rect r = { -1 , -1 , 2 , 2 } ;
X  
X  	InitCursor ( ) ;
X***************
X*** 2174,2179 ****
X--- 2164,2174 ----
X  void
X  UpdateMenus ( void )
X  {
X+ #if 1	/* see macmenu.c:AdjustMenus */
X+ 	extern void AdjustMenus(short);
X+ 
X+ 	AdjustMenus(0);
X+ #else
X  	WindowPeek w = ( WindowPeek ) FrontWindow ( ) ;
X  	Boolean enable = FALSE ;
X  	int i ;
X***************
X*** 2192,2197 ****
X--- 2187,2193 ----
X  			DisableItem ( editMenu , i ) ;
X  		}
X  	}
X+ #endif	/* see macmenu.c:AdjustMenus */
X  }
X  
X  
X***************
X*** 2198,2203 ****
X--- 2194,2204 ----
X  void
X  DoMenu ( long choise )
X  {
X+ #if 1	/* see macmenu.c:DoMenuEvt */
X+ 	extern void DoMenuEvt(long);
X+ 
X+ 	DoMenuEvt(choise);
X+ #else
X  	WindowPeek w = ( WindowPeek ) FrontWindow ( ) ;
X  	short menu = choise >> 16 ;
X  	short item = choise & 0xffff ;
X***************
X*** 2223,2233 ****
X  			str [ 0 ] = QUEUE_LEN ;
X  		}
X  		for ( i = 1 ; i <= str [ 0 ] ; i ++ ) {
X! 			addToKeyQueue ( str [ i ] , 0 ) ;
X  		}
X  	}
X  
X  	HiliteMenu ( 0 ) ;
X  }
X  
X  
X--- 2224,2235 ----
X  			str [ 0 ] = QUEUE_LEN ;
X  		}
X  		for ( i = 1 ; i <= str [ 0 ] ; i ++ ) {
X! 			AddToKeyQueue ( str [ i ] , 0 ) ;
X  		}
X  	}
X  
X  	HiliteMenu ( 0 ) ;
X+ #endif	/* see macmenu.c:DoMenuEvt */
X  }
X  
X  
X***************
X*** 2253,2260 ****
X  
X  dispatchKey :
X  		if ( theWindow ) {
X! 			( ( NhWindow * ) GetWRefCon ( theWindow ) ) -> keyFunc ( theEvent ,
X! 				theWindow ) ;
X  		} else {
X  			GeneralKey ( theEvent , (WindowPtr) NULL ) ;
X  		}
X--- 2255,2261 ----
X  
X  dispatchKey :
X  		if ( theWindow ) {
X! 			GetNhWin ( theWindow ) -> keyFunc ( theEvent , theWindow ) ;
X  		} else {
X  			GeneralKey ( theEvent , (WindowPtr) NULL ) ;
X  		}
X***************
X*** 2274,2280 ****
X  	InsetRect ( & r , 4 , 4 ) ;
X  
X  	code = FindWindow ( theEvent -> where , & theWindow ) ;
X! 	aWin = ( NhWindow * ) GetWRefCon ( theWindow ) ;
X  
X  	if ( code != inContent ) {
X  		InitCursor ( ) ;
X--- 2275,2281 ----
X  	InsetRect ( & r , 4 , 4 ) ;
X  
X  	code = FindWindow ( theEvent -> where , & theWindow ) ;
X! 	aWin = GetNhWin ( theWindow ) ;
X  
X  	if ( code != inContent ) {
X  		InitCursor ( ) ;
X***************
X*** 2287,2294 ****
X  		if ( inSelect == WIN_ERR || aWin - theWindows == inSelect ) {
X  			SelectWindow ( theWindow ) ;
X  			SetPort ( theWindow ) ;
X! 			( ( NhWindow * ) GetWRefCon ( theWindow ) ) -> clickFunc ( theEvent ,
X! 				theWindow ) ;
X  		} else {
X  			nhbell ( ) ;
X  		}
X--- 2288,2294 ----
X  		if ( inSelect == WIN_ERR || aWin - theWindows == inSelect ) {
X  			SelectWindow ( theWindow ) ;
X  			SetPort ( theWindow ) ;
X! 			GetNhWin ( theWindow ) -> clickFunc ( theEvent , theWindow ) ;
X  		} else {
X  			nhbell ( ) ;
X  		}
X***************
X*** 2325,2343 ****
X  		break ;
X  
X  	case inGoAway :
X! 		if ( TrackGoAway ( theWindow , theEvent -> where ) ) {
X! 			if ( aWin - theWindows == BASE_WINDOW && ! flags . window_inited ) {
X! 				addToKeyQueue ( '\033' , 1 ) ;
X! 				break ;
X! 			} else {
X! 				HideWindow ( theWindow ) ;
X! 			}
X! 			if ( inSelect == WIN_ERR || aWin - theWindows != inSelect ) {
X! 				destroy_nhwindow ( aWin - theWindows ) ;
X! 			} else {
X! 				addToKeyQueue ( '\033' , 1 ) ;
X! 			}
X! 		}
X  		break ;
X  
X  	case inMenuBar :
X--- 2325,2331 ----
X  		break ;
X  
X  	case inGoAway :
X! 		WindowGoAway(theEvent, theWindow);
X  		break ;
X  
X  	case inMenuBar :
X***************
X*** 2363,2370 ****
X  	BeginUpdate ( theWindow ) ;
X  	SetPort ( theWindow ) ;
X  	EraseRect ( & ( theWindow -> portRect ) ) ;
X! 	( ( NhWindow * ) GetWRefCon ( theWindow ) ) -> updateFunc ( theEvent ,
X! 		theWindow ) ;
X  	EndUpdate ( theWindow ) ;
X  }
X  
X--- 2351,2357 ----
X  	BeginUpdate ( theWindow ) ;
X  	SetPort ( theWindow ) ;
X  	EraseRect ( & ( theWindow -> portRect ) ) ;
X! 	GetNhWin ( theWindow ) -> updateFunc ( theEvent , theWindow ) ;
X  	EndUpdate ( theWindow ) ;
X  }
X  
X***************
X*** 2388,2394 ****
X  
X  		} else {
X  
X! 			NhWindow * nhw = ( ( NhWindow * ) GetWRefCon ( wp ) ) ;
X  			if ( nhw ) {
X  				nhw -> cursorFunc ( theEvent , wp , gMouseRgn ) ;
X  			}
X--- 2375,2381 ----
X  
X  		} else {
X  
X! 			NhWindow * nhw = GetNhWin ( wp ) ;
X  			if ( nhw ) {
X  				nhw -> cursorFunc ( theEvent , wp , gMouseRgn ) ;
X  			}
X***************
X*** 2440,2456 ****
X  long doDawdle = 0L ;
X  
X  void
X  DimMenuBar ( void )
X  {
X! 	DisableItem ( appleMenu , 0 ) ;
X! 	DisableItem ( fileMenu , 0 ) ;
X! 	DisableItem ( editMenu , 0 ) ;
X! 	DisableItem ( actionMenu , 0 ) ;
X! 	DisableItem ( inventoryMenu , 0 ) ;
X! 	DisableItem ( thingsMenu , 0 ) ;
X! 	DisableItem ( extendedMenu , 0 ) ;
X! 	DisableItem ( infoMenu , 0 ) ;
X! 	DrawMenuBar ( ) ;
X  }
X  
X  
X--- 2427,2471 ----
X  long doDawdle = 0L ;
X  
X  void
X+ WindowGoAway ( EventRecord * theEvent, WindowPtr theWindow )
X+ {
X+ 	NhWindow * aWin = GetNhWin(theWindow);
X+ 
X+ 	if ( ! theEvent || TrackGoAway ( theWindow , theEvent -> where ) ) {
X+ 		if ( aWin - theWindows == BASE_WINDOW && ! flags . window_inited ) {
X+ 			AddToKeyQueue ( '\033' , 1 ) ;
X+ 			return ;
X+ 		} else {
X+ 			HideWindow ( theWindow ) ;
X+ 		}
X+ 		if ( inSelect == WIN_ERR || aWin - theWindows != inSelect ) {
X+ 			destroy_nhwindow ( aWin - theWindows ) ;
X+ 		} else {
X+ 			AddToKeyQueue ( '\033' , 1 ) ;
X+ 		}
X+ 	}
X+ }
X+ 
X+ void
X  DimMenuBar ( void )
X  {
X! #if 1	/* see macmenu.c:AdjustMenus */
X! 	extern void AdjustMenus(short);
X! 
X! 	AdjustMenus(1);
X! #else
X! 	if ( appleMenu ) {
X! 		DisableItem ( appleMenu , 0 ) ;
X! 		DisableItem ( fileMenu , 0 ) ;
X! 		DisableItem ( editMenu , 0 ) ;
X! 		DisableItem ( actionMenu , 0 ) ;
X! 		DisableItem ( inventoryMenu , 0 ) ;
X! 		DisableItem ( thingsMenu , 0 ) ;
X! 		DisableItem ( extendedMenu , 0 ) ;
X! 		DisableItem ( infoMenu , 0 ) ;
X! 		DrawMenuBar ( ) ;
X! 	}
X! #endif	/* see macmenu.c:AdjustMenus */
X  }
X  
X  
X***************
X*** 2457,2471 ****
X  void
X  UndimMenuBar ( void )
X  {
X! 	EnableItem ( appleMenu , 0 ) ;
X! 	EnableItem ( fileMenu , 0 ) ;
X! 	EnableItem ( editMenu , 0 ) ;
X! 	EnableItem ( actionMenu , 0 ) ;
X! 	EnableItem ( inventoryMenu , 0 ) ;
X! 	EnableItem ( thingsMenu , 0 ) ;
X! 	EnableItem ( extendedMenu , 0 ) ;
X! 	EnableItem ( infoMenu , 0 ) ;
X! 	DrawMenuBar ( ) ;
X  }
X  
X  static int mBarDimmed = 0 ;
X--- 2472,2494 ----
X  void
X  UndimMenuBar ( void )
X  {
X! #if 1	/* see macmenu.c:AdjustMenus */
X! 	extern void AdjustMenus(short);
X! 
X! 	AdjustMenus(0);
X! #else
X! 	if ( appleMenu ) {
X! 		EnableItem ( appleMenu , 0 ) ;
X! 		EnableItem ( fileMenu , 0 ) ;
X! 		EnableItem ( editMenu , 0 ) ;
X! 		EnableItem ( actionMenu , 0 ) ;
X! 		EnableItem ( inventoryMenu , 0 ) ;
X! 		EnableItem ( thingsMenu , 0 ) ;
X! 		EnableItem ( extendedMenu , 0 ) ;
X! 		EnableItem ( infoMenu , 0 ) ;
X! 		DrawMenuBar ( ) ;
X! 	}
X! #endif	/* see macmenu.c:AdjustMenus */
X  }
X  
X  static int mBarDimmed = 0 ;
X***************
X*** 2499,2505 ****
X  		anEvent . what = nullEvent ;
X  	}
X  	doDawdle = 0L ;
X! 	HandleEvent ( & anEvent ) ;
X  
X  	if (top_line && theWindows) {
X  		WindowPeek win = (WindowPeek)theWindows[WIN_MESSAGE].theWindow;
X--- 2522,2532 ----
X  		anEvent . what = nullEvent ;
X  	}
X  	doDawdle = 0L ;
X! #if 0
X! 	/* I don't want to make the tty cursor blinking. */
X! 	if ( handle_tty_event ( _mt_window , & anEvent ) )	
X! #endif
X! 		HandleEvent ( & anEvent ) ;
X  
X  	if (top_line && theWindows) {
X  		WindowPeek win = (WindowPeek)theWindows[WIN_MESSAGE].theWindow;
X***************
X*** 2510,2534 ****
X  
X  
X  int
X! mac_nhgetch( void )
X! {
X! 	int ch ;
X! 	register int i ;
X! 	NhWindow * nhw = flags . window_inited ? theWindows + WIN_MAP : nil ;
X  
X  	if ( theWindows ) {
X! 		NhWindow * aWin = theWindows + WIN_MESSAGE ;
X! 		if ( aWin )
X  			aWin -> last_more_lin = aWin -> lin ;
X  	}
X  
X  	wait_synch ( ) ;
X  
X- 	if ( nhw && ! nhw -> cursorDrawn && nhw -> theWindow ) {
X- 		SetPort ( nhw -> theWindow ) ;
X- 		DrawMapCursor ( nhw ) ;
X- 	}
X- 
X  	if ( ! keyQueue [ 0 ] ) {
X  		long total , contig ;
X  		static char warn = 0 ;
X--- 2537,2570 ----
X  
X  
X  int
X! GetFromKeyQueue ( void ) {
X! int ix , ret ;
X  
X+ 	ret = keyQueue [ 0 ] ;
X+ 	for ( ix = 0 ; ix < QUEUE_LEN - 1 ; ix ++ ) {
X+ 		keyQueue [ ix ] = keyQueue [ ix + 1 ] ;
X+ 	}
X+ 	keyQueue [ ix ] = 0 ;
X+ 
X+ 	return ret ;
X+ }
X+ 
X+ 
X+ int
X+ mac_nhgetch( void ) {
X+ int ch ;
X+ NhWindow * nhw = flags . window_inited ? theWindows + WIN_MAP : nil ;
X+ 
X  	if ( theWindows ) {
X! 	NhWindow * aWin = theWindows + WIN_MESSAGE ;
X! 
X! 		if ( WIN_MESSAGE > 0 ) {
X  			aWin -> last_more_lin = aWin -> lin ;
X+ 		}
X  	}
X  
X  	wait_synch ( ) ;
X  
X  	if ( ! keyQueue [ 0 ] ) {
X  		long total , contig ;
X  		static char warn = 0 ;
X***************
X*** 2550,2558 ****
X  		if ( nhw ) {
X  			SetPort ( nhw -> theWindow ) ;
X  			if ( WaitMouseUp ( ) ) {
X! 				unsigned long tick = TickCount ( ) ;
X  				if ( tick >= gNextClickRepeat ) {
X! 					Point where ;
X  					GetMouse ( & where ) ;
X  					SetPt ( & clicked_pos , where . h / nhw -> charWidth ,
X  											where . v / nhw -> charHeight ) ;
X--- 2586,2596 ----
X  		if ( nhw ) {
X  			SetPort ( nhw -> theWindow ) ;
X  			if ( WaitMouseUp ( ) ) {
X! 			unsigned long tick = TickCount ( ) ;
X! 
X  				if ( tick >= gNextClickRepeat ) {
X! 				Point where ;
X! 
X  					GetMouse ( & where ) ;
X  					SetPt ( & clicked_pos , where . h / nhw -> charWidth ,
X  											where . v / nhw -> charHeight ) ;
X***************
X*** 2559,2572 ****
X  					gClickedToMove = TRUE ;
X  					gNextClickRepeat = tick + * ( short * ) KeyRepThresh ;
X  				}
X! 				if ( doDawdle > * ( short * ) KeyRepThresh )
X  					doDawdle = * ( short * ) KeyRepThresh ;
X! 			} else
X  				gNextClickRepeat = 0xffffffff ;
X  		}
X  
X  		get_nh_event ( ) ;
X! 		ch = keyQueue [ 0 ] ;
X  	} while ( ! ch && ! gClickedToMove ) ;
X  
X  	if ( ! gClickedToMove ) {
X--- 2597,2612 ----
X  					gClickedToMove = TRUE ;
X  					gNextClickRepeat = tick + * ( short * ) KeyRepThresh ;
X  				}
X! 				if ( doDawdle > * ( short * ) KeyRepThresh ) {
X  					doDawdle = * ( short * ) KeyRepThresh ;
X! 				}
X! 			} else {
X  				gNextClickRepeat = 0xffffffff ;
X+ 			}
X  		}
X  
X  		get_nh_event ( ) ;
X! 		ch = GetFromKeyQueue ( ) ;
X  	} while ( ! ch && ! gClickedToMove ) ;
X  
X  	if ( ! gClickedToMove ) {
X***************
X*** 2574,2583 ****
X  	} else {
X  		gClickedToMove = 0 ;
X  	}
X- 	for ( i = 0 ; i < QUEUE_LEN - 1 ; i ++ ) {
X- 		keyQueue [ i ] = keyQueue [ i + 1 ] ;
X- 	}
X- 	keyQueue [ i ] = 0 ;
X  
X  #ifdef MAC_THINKC5
X  	if (ch == '\r') ch = '\n';
X--- 2614,2619 ----
X***************
X*** 2625,2647 ****
X  void
X  mac_raw_print ( const char * str )
X  {
X! 	/* Here and in mac_raw_print_bold I assume that once theWindows got
X! 	   allocated by mac_init_nhwindows we can safely do putstr on BASE_WINDOW,
X! 	   even after mac_exit_nhwindows is called or flags.window_inited is reset
X! 	   to zero.  Is this assumption correct?
X! 	   Also add a space or a bullet before each line to indicate the bold face
X! 	   before we really implement the text attributes */
X! 	if ( theWindows ) {
X! 		char lstr [ 200 ] = " " ;
X! 		strcat ( lstr , str ) ;
X! 
X! 		ShowWindow ( theWindows [ BASE_WINDOW ] . theWindow ) ;
X! 		SelectWindow ( theWindows [ BASE_WINDOW ] . theWindow ) ;
X! 
X! 		putstr ( BASE_WINDOW , 0 , lstr ) ;
X! 
X! 	} else
X! 		showerror ( str , NULL ) ;
X  }
X  
X  
X--- 2661,2667 ----
X  void
X  mac_raw_print ( const char * str )
X  {
X! 	tty_raw_print(str);
X  }
X  
X  
X***************
X*** 2648,2666 ****
X  void
X  mac_raw_print_bold ( const char * str )
X  {
X! 	if ( theWindows ) {
X! 		char lstr [ 200 ] = "\xA5"/*bullet*/ ;
X! 		strcat ( lstr , str ) ;
X! 
X! 		ShowWindow ( theWindows [ BASE_WINDOW ] . theWindow ) ;
X! 		SelectWindow ( theWindows [ BASE_WINDOW ] . theWindow ) ;
X! 
X! 		putstr ( BASE_WINDOW , ATR_BOLD , lstr ) ;
X! 
X! 	} else {
X! 		nhbell ( ) ;
X! 		showerror ( str , NULL ) ;
X! 	}
X  }
X  
X  
X--- 2668,2674 ----
X  void
X  mac_raw_print_bold ( const char * str )
X  {
X! 	tty_raw_print_bold(str);
X  }
X  
X  
X***************
X*** 2667,2682 ****
X  void
X  mac_exit_nhwindows ( const char * s )
X  {
X! 	if ( s ) {
X! 		raw_print ( s ) ;
X! 		display_nhwindow ( BASE_WINDOW , TRUE ) ;
X! 	}
X! 
X! 	clear_nhwindow ( BASE_WINDOW ) ;
X! 	flags . window_inited = 0 ;
X! 	destroy_nhwindow ( WIN_MAP ) ;
X  	destroy_nhwindow ( WIN_MESSAGE ) ;
X- 	destroy_nhwindow ( WIN_STATUS ) ;
X  	destroy_nhwindow ( WIN_INVEN ) ;
X  }
X  
X--- 2675,2683 ----
X  void
X  mac_exit_nhwindows ( const char * s )
X  {
X! 	clear_screen ( ) ;
X! 	tty_exit_nhwindows ( s ) ;
X  	destroy_nhwindow ( WIN_MESSAGE ) ;
X  	destroy_nhwindow ( WIN_INVEN ) ;
X  }
X  
X***************
X*** 2694,2700 ****
X  	Rect r ;
X  
X  	if ( in_putstr > 3 ) {
X! 		DebugStr ( ( ConstStr255Param ) "\pRecursion!" ) ;
X  		return ;
X  	}
X  	if ( win < 0 || win >= NUM_MACWINDOWS ) {
X--- 2695,2701 ----
X  	Rect r ;
X  
X  	if ( in_putstr > 3 ) {
X! 		/* DebugStr ( ( ConstStr255Param ) "\pRecursion!" ) ; */
X  		return ;
X  	}
X  	if ( win < 0 || win >= NUM_MACWINDOWS ) {
X***************
X*** 2707,2735 ****
X  		return ;
X  	}
X  
X  	in_putstr ++ ;
X  	kind = ( ( WindowPeek ) ( aWin -> theWindow ) ) -> windowKind -
X  		WIN_BASE_KIND ;
X  	slen = strlen ( str ) ;
X  
X! 	if ( kind == NHW_MAP || kind == NHW_STATUS ) {
X! 		char *row;
X! 		r.right	 = aWin->theWindow->portRect.right;
X! 		r.left	 = aWin->charWidth	* aWin->cursor.h;
X! 		r.bottom = aWin->charHeight *(aWin->cursor.v + 1);
X! 		r.top	 = r.bottom - aWin->charHeight;
X! 		EraseRect(&r);
X! 		MoveTo(r.left, r.bottom - aWin->leading);
X! 		DrawText(str, 0, slen);
X! 
X! 		if (slen > NUM_COLS - aWin->cursor.h)
X! 			slen = NUM_COLS - aWin->cursor.h;
X! 		row = &((MapData *)*aWin->windowText)->map[aWin->cursor.v][aWin->cursor.h];
X! 		strncpy(row, str, slen);
X! 		memset(row + slen, CHAR_BLANK, NUM_COLS - slen - aWin->cursor.h);
X! 		curs(win, NUM_COLS, aWin->cursor.v);
X! 
X! 	} else {
X  		char * sr , * ds ;
X  
X  		r = aWin->theWindow->portRect;
X--- 2708,2724 ----
X  		return ;
X  	}
X  
X+ 	if (aWin->theWindow == _mt_window) {
X+ 		tty_putstr(win, attr, str);
X+ 		return;
X+ 	}
X+ 
X  	in_putstr ++ ;
X  	kind = ( ( WindowPeek ) ( aWin -> theWindow ) ) -> windowKind -
X  		WIN_BASE_KIND ;
X  	slen = strlen ( str ) ;
X  
X! 	{
X  		char * sr , * ds ;
X  
X  		r = aWin->theWindow->portRect;
X***************
X*** 2798,2861 ****
X  
X  
X  void
X- putsym ( winid win , int x , int y , CHAR_P sym )
X- {
X- 	NhWindow * aWin = & theWindows [ win ] ;
X- 	int kind = ( ( WindowPeek ) ( aWin -> theWindow ) ) -> windowKind
X- 		- WIN_BASE_KIND ;
X- 	Rect update ;
X- 
X- 	aWin -> clear = 0 ;
X- 	/*
X- 	 * We don't need to invalidate the old position or set the window,
X- 	 * since curs() will do that.
X- 	 */
X- 	curs ( win , x , y ) ;
X- 	x = aWin -> cursor . h ;
X- 	y = aWin -> cursor . v ;
X- 
X- 	if ( kind == NHW_MAP || kind == NHW_STATUS) {
X- 		switch ( sym ) {
X- 		case CHAR_LF :
X- 		case CHAR_CR :
X- 			curs ( win , 1 , y + 1 ) ;
X- 			break ;
X- 		case CHAR_BS :
X- 			if ( x ) {
X- 				curs ( win , x - 1 , y ) ;
X- 			}
X- 			break ;
X- 		default :
X- 			/*
X- 			 * Curs() takes care of getting cursor . v within range even for
X- 			 * the shorter status window - note; this assumes the status and
X- 			 * the map windows have the same width !
X- 			 */
X- 			update . top = y * aWin -> charHeight ;
X- 			update . bottom = ( y + 1 ) * aWin -> charHeight ;
X- 			update . left = x * aWin -> charWidth ;
X- 			update . right = ( x + 1 ) * aWin -> charWidth ;
X- 			EraseRect ( & update ) ;
X- 			MoveTo ( x * aWin -> charWidth , ( y + 1 ) * aWin -> charHeight -
X- 				aWin -> leading ) ;
X- 			( ( MapData * ) * aWin -> windowText ) -> map [ y ] [ x ] = sym ;
X- 			DrawChar ( sym ) ;
X- 			break ;
X- 		}
X- 	} else {
X- #if 1
X- 		Debugger ( ) ;
X- #else
X- 		char ss [ 2 ] ;
X- 		ss [ 0 ] = sym ;
X- 		ss [ 1 ] = 0 ;
X- 		putstr ( win , 0 , ss ) ;
X- #endif
X- 	}
X- }
X- 
X- 
X- void
X  mac_curs ( winid win , int x , int y )
X  {
X  	NhWindow * aWin = & theWindows [ win ] ;
X--- 2787,2792 ----
X***************
X*** 2862,2889 ****
X  	int kind = ( ( WindowPeek ) ( aWin -> theWindow ) ) -> windowKind -
X  		WIN_BASE_KIND ;
X  
X! 	SetPort  ( aWin -> theWindow ) ;
X! 	if ( kind == NHW_MAP || kind == NHW_STATUS ) {
X! 		Rect update ;
X! 		if ( x >= NUM_COLS ) {
X! 			x = 1 ; y ++ ;
X! 		}
X! 		if ( y >= ( kind == NHW_STATUS ? NUM_STAT_ROWS : NUM_ROWS ) ) {
X! 			y = 0 ; x = 1 ;
X! 		}
X! 		if ( aWin -> cursorDrawn ) {
X! 			update . top = aWin -> cursor . v * aWin -> charHeight ;
X! 			update . bottom = ( aWin -> cursor . v + 1 ) * aWin -> charHeight ;
X! 			update . left = aWin -> cursor . h * aWin -> charWidth ;
X! 			update . right = ( aWin -> cursor . h + 1 ) * aWin -> charWidth ;
X! 			EraseRect ( & update ) ;
X! 			MoveTo ( aWin -> cursor . h * aWin -> charWidth , ( aWin ->
X! 				cursor . v + 1 ) * aWin -> charHeight - aWin -> leading ) ;
X! 			DrawChar ( ( ( MapData * ) * ( aWin -> windowText ) ) -> map
X! 				[ aWin -> cursor . v ] [ aWin -> cursor . h ] ) ;
X! 			aWin -> cursorDrawn = 0 ;
X! 		}
X  	}
X  	MoveTo ( x * aWin -> charWidth , ( y + 1 ) * aWin -> charHeight -
X  		aWin -> leading ) ;
X  	SetPt ( & ( aWin -> cursor ) , x , y ) ;
X--- 2793,2804 ----
X  	int kind = ( ( WindowPeek ) ( aWin -> theWindow ) ) -> windowKind -
X  		WIN_BASE_KIND ;
X  
X! 	if (aWin->theWindow == _mt_window) {
X! 		tty_curs(win, x, y);
X! 		return;
X  	}
X+ 
X+ 	SetPort  ( aWin -> theWindow ) ;
X  	MoveTo ( x * aWin -> charWidth , ( y + 1 ) * aWin -> charHeight -
X  		aWin -> leading ) ;
X  	SetPt ( & ( aWin -> cursor ) , x , y ) ;
X***************
X*** 2890,2976 ****
X  }
X  
X  
X- /*
X-  *  print_glyph
X-  *
X-  *  Print the glyph to the output device.  Don't flush the output device.
X-  *
X-  *  Since this is only called from show_glyph(), it is assumed that the
X-  *  position and glyph are always correct (checked there)!
X-  */
X  void
X  mac_print_glyph ( winid window , XCHAR_P x , XCHAR_P y , int glyph )
X  {
X!     unsigned int	ch;
X!     register int	offset;
X! 
X! #define zap_color(n)
X! #define cmap_color(n)
X! #define trap_color(n)
X! #define obj_color(n)
X! #define mon_color(n)
X! #define pet_color(c)
X! 
X!     /*
X!      *  Map the glyph back to a character.
X!      *
X!      *  Warning:  For speed, this makes an assumption on the order of
X!      *		  offsets.  The order is set in display.h.
X!      */
X!     if ((offset = (glyph - GLYPH_SWALLOW_OFF)) >= 0) {		/* swallow */
X! 
X! 		/* see swallow_to_glyph() in display.c */
X! 		ch = (uchar) showsyms[S_sw_tl + (offset & 0x7)];
X! 		mon_color(offset >> 3);
X! 
X!     } else if ((offset = (glyph - GLYPH_ZAP_OFF)) >= 0) {	/* zap beam */
X! 
X! 		/* see zapdir_to_glyph() in display.c */
X! 		ch = showsyms[S_vbeam + (offset & 0x3)];
X! 		zap_color((offset >> 2));
X! 
X!     } else if ((offset = (glyph - GLYPH_CMAP_OFF)) >= 0) {	/* cmap */
X! 
X! 		ch = showsyms[offset];
X! 		cmap_color(offset);
X! 
X!     } else if ((offset = (glyph - GLYPH_TRAP_OFF)) >= 0) {	/* trap */
X! 
X! 		ch = (offset == WEB) ? showsyms[S_web] : showsyms[S_trap];
X! 		trap_color(offset);
X! 
X!     } else if ((offset = (glyph - GLYPH_OBJ_OFF)) >= 0) {	/* object */
X! 
X! 		ch = oc_syms[objects[offset].oc_class];
X! 		obj_color(offset);
X! 
X!     } else if ((offset = (glyph - GLYPH_BODY_OFF)) >= 0) {	/* a corpse */
X! 
X! 		ch = oc_syms[objects[CORPSE].oc_class];
X! 		mon_color(offset);
X! 
X!     } else if ((offset = (glyph - GLYPH_PET_OFF)) >= 0) {	/* a pet */
X! 
X! 		ch = monsyms[mons[offset].mlet];
X! 		pet_color(offset);
X! 
X!     } else {							/* a monster */
X! 
X! 		ch = monsyms[mons[glyph].mlet];
X! 		mon_color(glyph);
X!     }
X! 
X! 	if ( ch > 255 ) {
X! 		error ( "cicn plotting is not supported." ) ;
X! 		/*
X! 		 * cicn plotting goes here
X! 		 */
X! 	} else {
X! 		/*
X! 		 * Print a char from the hack font.
X! 		 */
X! 		putsym ( window , x , y , ch ) ;
X! 	}
X  }
X  
X  
X--- 2805,2816 ----
X  }
X  
X  
X  void
X  mac_print_glyph ( winid window , XCHAR_P x , XCHAR_P y , int glyph )
X  {
X! 	if (theWindows[window].theWindow != _mt_window)
X! 		Debugger();
X! 	tty_print_glyph(window, x, y, glyph);
X  }
X  
X  
X***************
X*** 3262,3267 ****
X--- 3102,3108 ----
X  void
X  mac_player_selection ( void )
X  {
X+ #if 0	/* see macmain.c:mac_askname() and macmenu.c:DialogAskName() */
X  	ControlHandle	ctrl;
X  	DialogPtr		characterDialog;
X  	short			itemHit, lastItemSelected, type;
X***************
X*** 3372,3377 ****
X--- 3213,3219 ----
X  	}
X  	
X  	DisposDialog(characterDialog);
X+ #endif
X  }
X  
X  void
X***************
X*** 3462,3470 ****
X--- 3304,3317 ----
X  #endif /* COM_COMPL */
X      mac_number_pad,
X      mac_delay_output,
X+ #ifdef CHANGE_COLOR
X+ 	donull,
X+ 	donull,
X+ #endif
X      /* other defs that really should go away (they're tty specific) */
X  	0,	//    mac_start_screen,
X  	0, //    mac_end_screen,
X+     genl_outrip,
X  } ;
X  
X  /*macwin.c*/
END_OF_FILE
if test 23123 -ne `wc -c <'patches02p.2'`; then
    echo shar: \"'patches02p.2'\" unpacked with wrong size!
fi
# end of 'patches02p.2'
if test -f 'sys/share/dgn_lex.c' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'sys/share/dgn_lex.c'\" to \"'sys/share/dgn_lex.c.orig'\"
  mv -f 'sys/share/dgn_lex.c' 'sys/share/dgn_lex.c.orig'
fi
echo shar: Extracting \"'sys/share/dgn_lex.c'\" \(32050 characters\)
sed "s/^X//" >'sys/share/dgn_lex.c' <<'END_OF_FILE'
X/* A lexical scanner for NetHack generated by flex */
X
X/* scanner skeleton version:
X * flexhack.skel 3.1.2 (from .../flex/RCS/flex.skel,v 2.16 90/08/03 14:09:36)
X */
X#define FLEX_SCANNER
X
X/* amount of stuff to slurp up with each read */
X#ifndef YY_READ_BUF_SIZE
X#define YY_READ_BUF_SIZE 8192
X#endif
X
X/* returned upon end-of-file */
X#define YY_END_TOK 0
X
X/* copy whatever the last rule matched to the standard output */
X#define ECHO (void)fwrite((genericptr_t)yytext, yyleng, 1, yyout)
X
X/* gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
X * is returned in "result".
X */
X#define YY_INPUT(buf,result,max_size) \
X	if ((result = fread((genericptr_t)buf, 1, max_size, yyin)) <= 0 && \
X	    !feof(yyin))  YY_FATAL_ERROR( "fread(yyin) in flex scanner failed" );
X#define YY_NULL 0
X
X/* no semi-colon after return; correct usage is to write "yyterminate();" */
X#define yyterminate() return ( YY_NULL )
X
X/* report a fatal error */
X#define YY_FATAL_ERROR(msg) \
X	do { \
X		(void) fputs( msg, stderr ); \
X		(void) putc( '\n', stderr ); \
X		exit( 1 ); \
X	} while ( 0 )
X
X/* default yywrap function - always treat EOF as an EOF */
X#define yywrap() 1
X
X/* enter a start condition.  This macro really ought to take a parameter,
X * but we do it the disgusting crufty way forced on us by the ()-less
X * definition of BEGIN
X */
X#define BEGIN yy_start = 1 + 2 *
X
X/* action number for EOF rule of a given start state */
X#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
X
X/* special action meaning "start processing a new file" */
X#define YY_NEW_FILE \
X	do { \
X		yy_init_buffer( yy_current_buffer, yyin ); \
X		yy_load_buffer_state(); \
X	} while ( 0 )
X
X/* default declaration of generated scanner - a define so the user can
X * easily add parameters
X */
X#define YY_DECL int NDECL(yylex)
X
X/* code executed at the end of each rule */
X#define YY_BREAK break;
X
X#define YY_END_OF_BUFFER_CHAR 0
X
X#ifndef YY_BUF_SIZE
X#define YY_BUF_SIZE (YY_READ_BUF_SIZE * 2) /* size of default input buffer */
X#endif
X
Xtypedef struct yy_buffer_state *YY_BUFFER_STATE;
X
X#define YY_CHAR char
X#define INITIAL 0
X/*	SCCS Id: @(#)dgn_lex.c	3.1	92/10/23	*/
X/*	Copyright (c) 1989 by Jean-Christophe Collet */
X/*	Copyright (c) 1990 by M. Stephenson	     */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#define DGN_COMP
X
X#include "config.h"
X#include "dgn_comp.h"
X#include "dgn_file.h"
X
Xlong *FDECL(alloc, (unsigned int));
X/*
X * Most of these don't exist in flex, yywrap is macro and
X * yyunput is properly declared in flex.skel.
X */
X#ifndef FLEX_SCANNER
Xint FDECL (yyback, (int *, int));
Xint NDECL (yylook);
Xint NDECL (yyinput);
Xint NDECL (yywrap);
Xint NDECL (yylex);
X	/* Traditional lexes let yyunput() and yyoutput() default to int;
X	 * newer ones may declare them as void since they don't return
X	 * values.  For even more fun, the lex supplied as part of the
X	 * newer unbundled compiler for SunOS 4.x adds the void declarations
X	 * (under __STDC__ or _cplusplus ifdefs -- otherwise they remain
X	 * int) while the bundled lex and the one with the older unbundled
X	 * compiler do not.  To detect this, we need help from outside --
X	 * sys/unix/Makefile.utl.
X	 */
X# if defined(NeXT) || defined(SVR4)
X#  define VOIDYYPUT
X# endif
X# if !defined(VOIDYYPUT)
X#  if defined(POSIX_TYPES) && !defined(BOS) && !defined(HISX) && !defined(_M_UNIX)
X#   define VOIDYYPUT
X#  endif
X# endif
X# if !defined(VOIDYYPUT) && defined(WEIRD_LEX)
X#  if defined(SUNOS4) && defined(__STDC__) && (WEIRD_LEX > 1) 
X#   define VOIDYYPUT
X#  endif
X# endif
X# ifdef VOIDYYPUT
Xvoid FDECL (yyunput, (int));
Xvoid FDECL (yyoutput, (int));
X# else
Xint FDECL (yyunput, (int));
Xint FDECL (yyoutput, (int));
X# endif
X#endif	/* FLEX_SCANNER */
X
Xvoid FDECL (init_yyin, (FILE *));
Xvoid FDECL (init_yyout, (FILE *));
X
X#ifdef MICRO
X#undef exit
Xextern void FDECL(exit, (int));
X#endif
X
X/* this doesn't always get put in dgn_comp.h
X * (esp. when using older versions of bison)
X */
X
Xextern YYSTYPE yylval;
X
Xint line_number = 1;
X/*
X *	This is a hack required by Michael Hamel to get things
X *	working on the Mac.
X */
X#if defined(applec) && !defined(FLEX_SCANNER)
X#undef input
X#undef unput
X#define unput(c) { yytchar = (c); if (yytchar == 10) yylineno--; *yysptr++ = yytchar; }				  
X# ifndef YYNEWLINE
X# define YYNEWLINE 10
X# endif
X
Xchar
Xinput() {	/* Under MPW \n is chr(13)! Compensate for this. */
X
X	if (yysptr > yysbuf) return(*--yysptr);
X	else {
X		yytchar = getc(yyin);
X	 	if (yytchar == '\n') {
X		    yylineno++;
X		    return(YYNEWLINE);
X		}
X		if (yytchar == EOF) return(0);
X		else		    return(yytchar);
X	}
X}
X#endif	/* applec && !FLEX_SCANNER */
X
X
X/* done after the current pattern has been matched and before the
X * corresponding action - sets up yytext
X */
X#define YY_DO_BEFORE_ACTION \
X	yytext = yy_bp; \
X	yyleng = yy_cp - yy_bp; \
X	yy_hold_char = *yy_cp; \
X	*yy_cp = '\0'; \
X	yy_c_buf_p = yy_cp;
X
X#define EOB_ACT_CONTINUE_SCAN 0
X#define EOB_ACT_END_OF_FILE 1
X#define EOB_ACT_LAST_MATCH 2
X
X/* return all but the first 'n' matched characters back to the input stream */
X#define yyless(n) \
X	do { \
X		/* undo effects of setting up yytext */ \
X		*yy_cp = yy_hold_char; \
X		yy_c_buf_p = yy_cp = yy_bp + n; \
X		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
X	} while ( 0 )
X
X#define unput(c) yyunput((int)c, yytext)
X
X
Xstruct yy_buffer_state {
X    FILE *yy_input_file;
X
X    YY_CHAR *yy_ch_buf;		/* input buffer */
X    YY_CHAR *yy_buf_pos;	/* current position in input buffer */
X
X    /* size of input buffer in bytes, not including room for EOB characters */
X    int yy_buf_size;
X
X    /* number of characters read into yy_ch_buf, not including EOB characters */
X    int yy_n_chars;
X
X    int yy_eof_status;		/* whether we've seen an EOF on this buffer */
X#define EOF_NOT_SEEN 0
X    /* "pending" happens when the EOF has been seen but there's still
X     * some text process
X     */
X#define EOF_PENDING 1
X#define EOF_DONE 2
X};
X
Xstatic YY_BUFFER_STATE yy_current_buffer;
X
X/* we provide macros for accessing buffer states in case in the
X * future we want to put the buffer states in a more general
X * "scanner state"
X */
X#define YY_CURRENT_BUFFER yy_current_buffer
X
X
X/* yy_hold_char holds the character lost when yytext is formed */
Xstatic YY_CHAR yy_hold_char;
X
Xstatic int yy_n_chars;		/* number of characters read into yy_ch_buf */
X
X
X#ifndef YY_USER_ACTION
X#define YY_USER_ACTION
X#endif
X
X#ifndef YY_USER_INIT
X#define YY_USER_INIT
X#endif
X
Xextern YY_CHAR *yytext;
Xextern int yyleng;
Xextern FILE *yyin, *yyout;
X
XYY_CHAR *yytext;
Xint yyleng;
X
XFILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
X
X#define YY_END_OF_BUFFER 36
Xtypedef int yy_state_type;
Xstatic const short int yy_accept[194] =
X    {   0,
X        0,    0,   36,   34,   33,   32,   34,   29,   34,   34,
X       34,   34,   34,   34,   34,   34,   34,   34,   34,   34,
X       34,   34,   34,   34,   34,   34,   34,   34,   33,    0,
X       30,   29,    0,    0,    0,    0,    0,    0,    0,    0,
X        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
X        0,    0,    0,    2,    0,   31,    0,    0,    0,    0,
X        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
X        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
X        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
X        3,    0,    0,    0,    0,    0,    0,    0,    0,    0,
X
X        0,   14,    0,    0,    0,    0,    0,    0,    4,    0,
X       25,    0,    0,    0,    0,    0,    0,    0,    0,    0,
X        6,    0,    0,    0,    5,    0,    0,   23,    0,    0,
X        0,    0,    0,    0,    0,    0,    0,    0,    0,   20,
X        0,    0,    0,    0,    8,    0,    0,    0,    0,    0,
X        0,    1,    0,    0,    0,    0,    0,   22,   15,    0,
X       21,    7,   19,    0,    0,    0,    0,    0,    0,   13,
X        0,    0,    0,   26,   16,    0,    0,   12,    0,    0,
X        0,   11,    9,    0,   17,   18,    0,   27,    0,   28,
X       24,   10,    0
X
X    } ;
X
Xstatic const YY_CHAR yy_ec[128] =
X    {   0,
X        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    2,    1,    4,    5,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    6,    1,    1,    6,    6,    6,
X        6,    6,    6,    6,    6,    6,    6,    1,    1,    1,
X        1,    1,    1,    1,    7,    8,    9,   10,   11,   12,
X       13,   14,   15,    1,    1,   16,   17,   18,   19,   20,
X        1,   21,   22,   23,   24,   25,    1,    1,   26,    1,
X        1,    1,    1,    1,   27,    1,   28,    1,   29,   30,
X
X       31,   32,   33,   34,   35,    1,   36,   37,   38,   39,
X       40,   41,    1,   42,   43,   44,   45,    1,   46,    1,
X        1,   47,    1,    1,    1,    1,    1
X    } ;
X
Xstatic const YY_CHAR yy_meta[48] =
X    {   0,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    1,    1
X    } ;
X
Xstatic const short int yy_base[196] =
X    {   0,
X        0,  212,  216,  218,  213,  218,  210,  207,  196,  190,
X      196,   37,  191,  197,  186,  188,  171,  164,  172,  174,
X      173,   18,  160,  159,  154,  157,   11,  193,  193,  190,
X      218,  187,  177,  184,  183,  167,  170,  164,  161,  166,
X      174,  155,  136,  144,  134,  132,  133,   26,  135,  143,
X      147,  128,  145,  218,  169,  218,  158,  152,  154,  159,
X      154,  145,   44,  142,   47,  124,  124,  125,  129,  129,
X      115,   27,  121,  113,  111,  120,  115,  116,  134,  142,
X      132,  128,  137,  121,  130,  129,  125,  129,  131,   97,
X      218,  105,   94,  101,   95,   96,   94,   99,  105,  101,
X
X       89,  218,   95,  112,  114,   51,  112,  107,  218,  110,
X      114,  111,  106,   96,   85,   76,   81,   82,   88,   69,
X      218,   81,   76,   75,  218,   78,   99,  218,   88,   97,
X       87,   88,   92,   93,   88,   91,   90,   71,   65,  218,
X       62,   60,   57,   56,  218,   59,   54,   74,   84,   65,
X       66,  218,   70,   65,   70,   60,   68,  218,  218,   52,
X      218,  218,  218,   46,   50,   57,   61,   67,   62,  218,
X       67,   64,   63,  218,  218,   42,   41,  218,   61,   53,
X       49,  218,  218,   50,  218,  218,   51,  218,   46,  218,
X      218,  218,  218,   61,   59
X
X    } ;
X
Xstatic const short int yy_def[196] =
X    {   0,
X      193,    1,  193,  193,  193,  193,  194,  193,  193,  193,
X      193,  193,  193,  193,  193,  193,  193,  193,  193,  193,
X      193,  193,  193,  193,  193,  193,  193,  195,  193,  194,
X      193,  193,  193,  193,  193,  193,  193,  193,  193,  193,
X      193,  193,  193,  193,  193,  193,  193,  193,  193,  193,
X      193,  193,  193,  193,  195,  193,  193,  193,  193,  193,
X      193,  193,  193,  193,  193,  193,  193,  193,  193,  193,
X      193,  193,  193,  193,  193,  193,  193,  193,  193,  193,
X      193,  193,  193,  193,  193,  193,  193,  193,  193,  193,
X      193,  193,  193,  193,  193,  193,  193,  193,  193,  193,
X
X      193,  193,  193,  193,  193,  193,  193,  193,  193,  193,
X      193,  193,  193,  193,  193,  193,  193,  193,  193,  193,
X      193,  193,  193,  193,  193,  193,  193,  193,  193,  193,
X      193,  193,  193,  193,  193,  193,  193,  193,  193,  193,
X      193,  193,  193,  193,  193,  193,  193,  193,  193,  193,
X      193,  193,  193,  193,  193,  193,  193,  193,  193,  193,
X      193,  193,  193,  193,  193,  193,  193,  193,  193,  193,
X      193,  193,  193,  193,  193,  193,  193,  193,  193,  193,
X      193,  193,  193,  193,  193,  193,  193,  193,  193,  193,
X      193,  193,    0,  193,  193
X
X    } ;
X
Xstatic const short int yy_nxt[266] =
X    {   0,
X        4,    5,    6,    7,    4,    8,    9,   10,   11,   12,
X       13,    4,    4,    4,    4,   14,    4,    4,    4,   15,
X       16,    4,    4,    4,    4,    4,    4,    4,   17,   18,
X        4,    4,    4,   19,    4,    4,   20,   21,   22,    4,
X       23,   24,   25,   26,   27,    4,    4,   36,   47,   53,
X       85,   54,   72,   73,   86,   88,   96,   48,  129,   55,
X       37,   30,   89,  192,  191,  190,  130,  189,  188,  187,
X      186,   97,  185,  184,  183,  182,  181,  180,  179,  178,
X      177,  176,  175,  174,  173,  172,  171,  170,  169,  168,
X      167,  166,  165,  164,  163,  162,  161,  160,  159,  158,
X
X      157,  156,  155,  154,  153,  152,  151,  150,  149,  148,
X      147,  146,  145,  144,  143,  142,  141,  140,  139,  138,
X      137,  136,  135,  134,  133,  132,  131,  128,  127,  126,
X      125,  124,  123,  122,  121,  120,  119,  118,  117,  116,
X      115,  114,  113,  112,  111,  110,  109,  108,  107,  106,
X      105,  104,  103,  102,  101,  100,   99,   98,   95,   94,
X       93,   92,   91,   90,   87,   84,   83,   82,   81,   80,
X       79,   56,   78,   77,   76,   75,   74,   71,   70,   69,
X       68,   67,   66,   65,   64,   63,   62,   61,   60,   59,
X       58,   57,   32,   31,   29,   56,   52,   51,   50,   49,
X
X       46,   45,   44,   43,   42,   41,   40,   39,   38,   35,
X       34,   33,   32,   31,   29,  193,   28,    3,  193,  193,
X      193,  193,  193,  193,  193,  193,  193,  193,  193,  193,
X      193,  193,  193,  193,  193,  193,  193,  193,  193,  193,
X      193,  193,  193,  193,  193,  193,  193,  193,  193,  193,
X      193,  193,  193,  193,  193,  193,  193,  193,  193,  193,
X      193,  193,  193,  193,  193
X    } ;
X
Xstatic const short int yy_chk[266] =
X    {   0,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    1,    1,   12,   22,   27,
X       63,   27,   48,   48,   63,   65,   72,   22,  106,  195,
X       12,  194,   65,  189,  187,  184,  106,  181,  180,  179,
X      177,   72,  176,  173,  172,  171,  169,  168,  167,  166,
X      165,  164,  160,  157,  156,  155,  154,  153,  151,  150,
X      149,  148,  147,  146,  144,  143,  142,  141,  139,  138,
X
X      137,  136,  135,  134,  133,  132,  131,  130,  129,  127,
X      126,  124,  123,  122,  120,  119,  118,  117,  116,  115,
X      114,  113,  112,  111,  110,  108,  107,  105,  104,  103,
X      101,  100,   99,   98,   97,   96,   95,   94,   93,   92,
X       90,   89,   88,   87,   86,   85,   84,   83,   82,   81,
X       80,   79,   78,   77,   76,   75,   74,   73,   71,   70,
X       69,   68,   67,   66,   64,   62,   61,   60,   59,   58,
X       57,   55,   53,   52,   51,   50,   49,   47,   46,   45,
X       44,   43,   42,   41,   40,   39,   38,   37,   36,   35,
X       34,   33,   32,   30,   29,   28,   26,   25,   24,   23,
X
X       21,   20,   19,   18,   17,   16,   15,   14,   13,   11,
X       10,    9,    8,    7,    5,    3,    2,  193,  193,  193,
X      193,  193,  193,  193,  193,  193,  193,  193,  193,  193,
X      193,  193,  193,  193,  193,  193,  193,  193,  193,  193,
X      193,  193,  193,  193,  193,  193,  193,  193,  193,  193,
X      193,  193,  193,  193,  193,  193,  193,  193,  193,  193,
X      193,  193,  193,  193,  193
X    } ;
X
Xstatic yy_state_type yy_last_accepting_state;
Xstatic YY_CHAR *yy_last_accepting_cpos;
X
X/* the intent behind this definition is that it'll catch
X * any uses of REJECT which flex missed
X */
X#define REJECT reject_used_but_not_detected
X#define yymore() yymore_used_but_not_detected
X#define YY_MORE_ADJ 0
X
X/* these variables are all declared out here so that section 3 code can
X * manipulate them
X */
X/* points to current character in buffer */
Xstatic YY_CHAR *yy_c_buf_p = (YY_CHAR *) 0;
Xstatic int yy_init = 1;		/* whether we need to initialize */
Xstatic int yy_start = 0;	/* start state number */
X
X/* flag which is used to allow yywrap()'s to do buffer switches
X * instead of setting up a fresh yyin.  A bit of a hack ...
X */
Xstatic int yy_did_buffer_switch_on_eof;
X
Xstatic yy_state_type NDECL(yy_get_previous_state);
Xstatic yy_state_type FDECL(yy_try_NUL_trans, (yy_state_type));
Xstatic int NDECL(yy_get_next_buffer);
X#if 0		/* not needed for NetHack */
Xstatic int NDECL(yyinput);
Xstatic void FDECL(yyunput, (int,YY_CHAR *));
X#endif
Xvoid FDECL(yyrestart, (FILE *));
Xvoid FDECL(yy_switch_to_buffer, (YY_BUFFER_STATE));
Xvoid NDECL(yy_load_buffer_state);
XYY_BUFFER_STATE FDECL(yy_create_buffer, (FILE *,int));
Xvoid FDECL(yy_delete_buffer, (YY_BUFFER_STATE));
Xvoid FDECL(yy_init_buffer, (YY_BUFFER_STATE,FILE *));
X
X#define yy_new_buffer yy_create_buffer
X
XYY_DECL
X{
X    register yy_state_type yy_current_state;
X    register YY_CHAR *yy_cp, *yy_bp;
X    register int yy_act;
X
X
X
X    if ( yy_init )
X	{
X	YY_USER_INIT;
X
X	if ( ! yy_start )
X	    yy_start = 1;	/* first start state */
X
X	if ( ! yyin )
X	    yyin = stdin;
X
X	if ( ! yyout )
X	    yyout = stdout;
X
X	if ( yy_current_buffer )
X	    yy_init_buffer( yy_current_buffer, yyin );
X	else
X	    yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );
X
X	yy_load_buffer_state();
X
X	yy_init = 0;
X	}
X
X    while ( 1 )		/* loops until end-of-file is reached */
X	{
X	yy_cp = yy_c_buf_p;
X
X	/* support of yytext */
X	*yy_cp = yy_hold_char;
X
X	/* yy_bp points to the position in yy_ch_buf of the start of the
X	 * current run.
X	 */
X	yy_bp = yy_cp;
X
X	yy_current_state = yy_start;
X	if ( yy_bp[-1] == '\n' )
X	    ++yy_current_state;
Xyy_match:
X	do
X	    {
X	    register YY_CHAR yy_c = yy_ec[*yy_cp];
X	    if ( yy_accept[yy_current_state] )
X		{
X		yy_last_accepting_state = yy_current_state;
X		yy_last_accepting_cpos = yy_cp;
X		}
X	    while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
X		{
X		yy_current_state = yy_def[yy_current_state];
X		if ( yy_current_state >= 194 )
X		    yy_c = yy_meta[yy_c];
X		}
X	    yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
X	    ++yy_cp;
X	    }
X	while ( yy_current_state != 193 );
X	yy_cp = yy_last_accepting_cpos;
X	yy_current_state = yy_last_accepting_state;
X
Xyy_find_action:
X	yy_act = yy_accept[yy_current_state];
X
X	YY_DO_BEFORE_ACTION;
X	YY_USER_ACTION;
X
Xdo_action:	/* this label is used only to access EOF actions */
X
X
X	switch ( yy_act )
X	    {
X	    case 0: /* must backtrack */
X	    /* undo the effects of YY_DO_BEFORE_ACTION */
X	    *yy_cp = yy_hold_char;
X	    yy_cp = yy_last_accepting_cpos;
X	    yy_current_state = yy_last_accepting_state;
X	    goto yy_find_action;
X
Xcase 1:
Xreturn(A_DUNGEON);
X	YY_BREAK
Xcase 2:
X{ yylval.i=1; return(UP_OR_DOWN); }
X	YY_BREAK
Xcase 3:
X{ yylval.i=0; return(UP_OR_DOWN); }
X	YY_BREAK
Xcase 4:
Xreturn(ENTRY);
X	YY_BREAK
Xcase 5:
Xreturn(STAIR);
X	YY_BREAK
Xcase 6:
Xreturn(NO_UP);
X	YY_BREAK
Xcase 7:
Xreturn(NO_DOWN);
X	YY_BREAK
Xcase 8:
Xreturn(PORTAL);
X	YY_BREAK
Xcase 9:
Xreturn(PROTOFILE);
X	YY_BREAK
Xcase 10:
Xreturn(DESCRIPTION);
X	YY_BREAK
Xcase 11:
Xreturn(LEVELDESC);
X	YY_BREAK
Xcase 12:
Xreturn(ALIGNMENT);
X	YY_BREAK
Xcase 13:
Xreturn(LEVALIGN);
X	YY_BREAK
Xcase 14:
X{ yylval.i=TOWN ; return(DESCRIPTOR); }
X	YY_BREAK
Xcase 15:
X{ yylval.i=HELLISH ; return(DESCRIPTOR); }
X	YY_BREAK
Xcase 16:
X{ yylval.i=MAZELIKE ; return(DESCRIPTOR); }
X	YY_BREAK
Xcase 17:
X{ yylval.i=ROGUELIKE ; return(DESCRIPTOR); }
X	YY_BREAK
Xcase 18:
X{ yylval.i=D_ALIGN_NONE ; return(DESCRIPTOR); }
X	YY_BREAK
Xcase 19:
X{ yylval.i=D_ALIGN_NONE ; return(DESCRIPTOR); }
X	YY_BREAK
Xcase 20:
X{ yylval.i=D_ALIGN_LAWFUL ; return(DESCRIPTOR); }
X	YY_BREAK
Xcase 21:
X{ yylval.i=D_ALIGN_NEUTRAL ; return(DESCRIPTOR); }
X	YY_BREAK
Xcase 22:
X{ yylval.i=D_ALIGN_CHAOTIC ; return(DESCRIPTOR); }
X	YY_BREAK
Xcase 23:
Xreturn(BRANCH);
X	YY_BREAK
Xcase 24:
Xreturn(CHBRANCH);
X	YY_BREAK
Xcase 25:
Xreturn(LEVEL);
X	YY_BREAK
Xcase 26:
Xreturn(RNDLEVEL);
X	YY_BREAK
Xcase 27:
Xreturn(CHLEVEL);
X	YY_BREAK
Xcase 28:
Xreturn(RNDCHLEVEL);
X	YY_BREAK
Xcase 29:
X{ yylval.i=atoi(yytext); return(INTEGER); }
X	YY_BREAK
Xcase 30:
X{ yytext[yyleng-1] = 0; /* Discard the trailing \" */
X		  yylval.str = (char *) alloc(strlen(yytext+1)+1);
X		  strcpy(yylval.str, yytext+1); /* Discard the first \" */
X		  return(STRING); }
X	YY_BREAK
Xcase 31:
X{ line_number++; }
X	YY_BREAK
Xcase 32:
X{ line_number++; }
X	YY_BREAK
Xcase 33:
X;	/* skip trailing tabs & spaces */
X	YY_BREAK
Xcase 34:
X{ return yytext[0]; }
X	YY_BREAK
Xcase 35:
XECHO;
X	YY_BREAK
Xcase YY_STATE_EOF(INITIAL):
X    yyterminate();
X
X	    case YY_END_OF_BUFFER:
X		{
X		/* amount of text matched not including the EOB char */
X		int yy_amount_of_matched_text = yy_cp - yytext - 1;
X
X		/* undo the effects of YY_DO_BEFORE_ACTION */
X		*yy_cp = yy_hold_char;
X
X		/* note that here we test for yy_c_buf_p "<=" to the position
X		 * of the first EOB in the buffer, since yy_c_buf_p will
X		 * already have been incremented past the NUL character
X		 * (since all states make transitions on EOB to the end-
X		 * of-buffer state).  Contrast this with the test in yyinput().
X		 */
X		if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )
X		    /* this was really a NUL */
X		    {
X		    yy_state_type yy_next_state;
X
X		    yy_c_buf_p = yytext + yy_amount_of_matched_text;
X
X		    yy_current_state = yy_get_previous_state();
X
X		    /* okay, we're now positioned to make the
X		     * NUL transition.  We couldn't have
X		     * yy_get_previous_state() go ahead and do it
X		     * for us because it doesn't know how to deal
X		     * with the possibility of jamming (and we
X		     * don't want to build jamming into it because
X		     * then it will run more slowly)
X		     */
X
X		    yy_next_state = yy_try_NUL_trans( yy_current_state );
X
X		    yy_bp = yytext + YY_MORE_ADJ;
X
X		    if ( yy_next_state )
X			{
X			/* consume the NUL */
X			yy_cp = ++yy_c_buf_p;
X			yy_current_state = yy_next_state;
X			goto yy_match;
X			}
X
X		    else
X			{
X			    yy_cp = yy_last_accepting_cpos;
X			    yy_current_state = yy_last_accepting_state;
X			goto yy_find_action;
X			}
X		    }
X
X		else switch ( yy_get_next_buffer() )
X		    {
X		    case EOB_ACT_END_OF_FILE:
X			{
X			yy_did_buffer_switch_on_eof = 0;
X
X			if ( yywrap() )
X			    {
X			    /* note: because we've taken care in
X			     * yy_get_next_buffer() to have set up yytext,
X			     * we can now set up yy_c_buf_p so that if some
X			     * total hoser (like flex itself) wants
X			     * to call the scanner after we return the
X			     * YY_NULL, it'll still work - another YY_NULL
X			     * will get returned.
X			     */
X			    yy_c_buf_p = yytext + YY_MORE_ADJ;
X
X			    yy_act = YY_STATE_EOF((yy_start - 1) / 2);
X			    goto do_action;
X			    }
X
X			else
X			    {
X			    if ( ! yy_did_buffer_switch_on_eof )
X				YY_NEW_FILE;
X			    }
X			}
X			break;
X
X		    case EOB_ACT_CONTINUE_SCAN:
X			yy_c_buf_p = yytext + yy_amount_of_matched_text;
X
X			yy_current_state = yy_get_previous_state();
X
X			yy_cp = yy_c_buf_p;
X			yy_bp = yytext + YY_MORE_ADJ;
X			goto yy_match;
X
X		    case EOB_ACT_LAST_MATCH:
X			yy_c_buf_p =
X			    &yy_current_buffer->yy_ch_buf[yy_n_chars];
X
X			yy_current_state = yy_get_previous_state();
X
X			yy_cp = yy_c_buf_p;
X			yy_bp = yytext + YY_MORE_ADJ;
X			goto yy_find_action;
X		    }
X		break;
X		}
X
X	    default:
X#ifdef FLEX_DEBUG
X		printf( "action # %d\n", yy_act );
X#endif
X		YY_FATAL_ERROR(
X			"fatal flex scanner internal error--no action found" );
X	    }
X	}
X}
X
X
X/* yy_get_next_buffer - try to read in a new buffer
X *
X * synopsis
X *     int yy_get_next_buffer();
X *
X * returns a code representing an action
X *     EOB_ACT_LAST_MATCH -
X *     EOB_ACT_CONTINUE_SCAN - continue scanning from current position
X *     EOB_ACT_END_OF_FILE - end of file
X */
X
Xstatic int yy_get_next_buffer()
X{
X    register YY_CHAR *dest = yy_current_buffer->yy_ch_buf;
X    register YY_CHAR *source = yytext - 1; /* copy prev. char, too */
X    register int number_to_move, i;
X    int ret_val;
X
X    if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )
X	YY_FATAL_ERROR(
X		"fatal flex scanner internal error--end of buffer missed" );
X
X    /* try to read more data */
X
X    /* first move last chars to start of buffer */
X    number_to_move = yy_c_buf_p - yytext;
X
X    for ( i = 0; i < number_to_move; ++i )
X	*(dest++) = *(source++);
X
X    if ( yy_current_buffer->yy_eof_status != EOF_NOT_SEEN )
X	/* don't do the read, it's not guaranteed to return an EOF,
X	 * just force an EOF
X	 */
X	yy_n_chars = 0;
X
X    else
X	{
X	int num_to_read = yy_current_buffer->yy_buf_size - number_to_move - 1;
X
X	if ( num_to_read > YY_READ_BUF_SIZE )
X	    num_to_read = YY_READ_BUF_SIZE;
X
X	else if ( num_to_read <= 0 )
X	    YY_FATAL_ERROR( "fatal error - scanner input buffer overflow" );
X
X	/* read in more data */
X	YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),
X		  yy_n_chars, num_to_read );
X	}
X
X    if ( yy_n_chars == 0 )
X	{
X	if ( number_to_move - YY_MORE_ADJ == 1 )
X	    {
X	    ret_val = EOB_ACT_END_OF_FILE;
X	    yy_current_buffer->yy_eof_status = EOF_DONE;
X	    }
X
X	else
X	    {
X	    ret_val = EOB_ACT_LAST_MATCH;
X	    yy_current_buffer->yy_eof_status = EOF_PENDING;
X	    }
X	}
X
X    else
X	ret_val = EOB_ACT_CONTINUE_SCAN;
X
X    yy_n_chars += number_to_move;
X    yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
X    yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;
X
X    /* yytext begins at the second character in yy_ch_buf; the first
X     * character is the one which preceded it before reading in the latest
X     * buffer; it needs to be kept around in case it's a newline, so
X     * yy_get_previous_state() will have with '^' rules active
X     */
X
X    yytext = &yy_current_buffer->yy_ch_buf[1];
X
X    return ( ret_val );
X}
X
X
X/* yy_get_previous_state - get the state just before the EOB char was reached
X *
X * synopsis
X *     yy_state_type yy_get_previous_state();
X */
X
Xstatic yy_state_type yy_get_previous_state()
X{
X    register yy_state_type yy_current_state;
X    register YY_CHAR *yy_cp;
X
X    register YY_CHAR *yy_bp = yytext;
X
X    yy_current_state = yy_start;
X    if ( yy_bp[-1] == '\n' )
X	++yy_current_state;
X
X    for ( yy_cp = yytext + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )
X	{
X	register YY_CHAR yy_c = (*yy_cp ? yy_ec[*yy_cp] : 1);
X	if ( yy_accept[yy_current_state] )
X	    {
X	    yy_last_accepting_state = yy_current_state;
X	    yy_last_accepting_cpos = yy_cp;
X	    }
X	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
X	    {
X	    yy_current_state = yy_def[yy_current_state];
X	    if ( yy_current_state >= 194 )
X		yy_c = yy_meta[yy_c];
X	    }
X	yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
X	}
X
X    return ( yy_current_state );
X}
X
X
X/* yy_try_NUL_trans - try to make a transition on the NUL character
X *
X * synopsis
X *     next_state = yy_try_NUL_trans( current_state );
X */
X
Xstatic yy_state_type yy_try_NUL_trans( yy_current_state )
Xregister yy_state_type yy_current_state;
X{
X    register int yy_is_jam;
X    register YY_CHAR *yy_cp = yy_c_buf_p;
X
X    register YY_CHAR yy_c = 1;
X    if ( yy_accept[yy_current_state] )
X	{
X	yy_last_accepting_state = yy_current_state;
X	yy_last_accepting_cpos = yy_cp;
X	}
X    while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
X	{
X	yy_current_state = yy_def[yy_current_state];
X	if ( yy_current_state >= 194 )
X	    yy_c = yy_meta[yy_c];
X	}
X    yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
X    yy_is_jam = (yy_current_state == 193);
X
X    return ( yy_is_jam ? 0 : yy_current_state );
X}
X
X
X#if 0		/* not needed for NetHack */
X
Xstatic void yyunput( in_c, yy_bp )
Xint in_c;		/* YY_CHAR c; */
Xregister YY_CHAR *yy_bp;
X{
X    register YY_CHAR *yy_cp = yy_c_buf_p;
X    YY_CHAR c = (YY_CHAR)in_c;
X
X    /* undo effects of setting up yytext */
X    *yy_cp = yy_hold_char;
X
X    if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
X	{ /* need to shift things up to make room */
X	register int number_to_move = yy_n_chars + 2; /* +2 for EOB chars */
X	register YY_CHAR *dest =
X	    &yy_current_buffer->yy_ch_buf[yy_current_buffer->yy_buf_size + 2];
X	register YY_CHAR *source =
X	    &yy_current_buffer->yy_ch_buf[number_to_move];
X
X	while ( source > yy_current_buffer->yy_ch_buf )
X	    *--dest = *--source;
X
X	yy_cp += dest - source;
X	yy_bp += dest - source;
X	yy_n_chars = yy_current_buffer->yy_buf_size;
X
X	if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
X	    YY_FATAL_ERROR( "flex scanner push-back overflow" );
X	}
X
X    if ( yy_cp > yy_bp && yy_cp[-1] == '\n' )
X	yy_cp[-2] = '\n';
X
X    *--yy_cp = c;
X
X    /* note: the formal parameter *must* be called "yy_bp" for this
X     *       macro to now work correctly
X     */
X    YY_DO_BEFORE_ACTION; /* set up yytext again */
X}
X
X
Xstatic int yyinput()
X{
X    int c;
X    YY_CHAR *yy_cp = yy_c_buf_p;
X
X    *yy_cp = yy_hold_char;
X
X    if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
X	{
X	/* yy_c_buf_p now points to the character we want to return.
X	 * If this occurs *before* the EOB characters, then it's a
X	 * valid NUL; if not, then we've hit the end of the buffer.
X	 */
X	if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )
X	    /* this was really a NUL */
X	    *yy_c_buf_p = '\0';
X
X	else
X	    { /* need more input */
X	    yytext = yy_c_buf_p;
X	    ++yy_c_buf_p;
X
X	    switch ( yy_get_next_buffer() )
X		{
X		case EOB_ACT_END_OF_FILE:
X		    {
X		    if ( yywrap() )
X			{
X			yy_c_buf_p = yytext + YY_MORE_ADJ;
X			return ( EOF );
X			}
X
X		    YY_NEW_FILE;
X
X		    return ( yyinput() );
X		    }
X		    break;
X
X		case EOB_ACT_CONTINUE_SCAN:
X		    yy_c_buf_p = yytext + YY_MORE_ADJ;
X		    break;
X
X		case EOB_ACT_LAST_MATCH:
X		    YY_FATAL_ERROR( "unexpected last match in yyinput()" );
X		}
X	    }
X	}
X
X    c = *yy_c_buf_p;
X    yy_hold_char = *++yy_c_buf_p;
X
X    return ( c );
X}
X
X#endif	/* 0 */
X
X
Xvoid yyrestart( input_file )
XFILE *input_file;
X{
X    yy_init_buffer( yy_current_buffer, input_file );
X    yy_load_buffer_state();
X}
X
X
Xvoid yy_switch_to_buffer( new_buffer )
XYY_BUFFER_STATE new_buffer;
X{
X    if ( yy_current_buffer == new_buffer )
X	return;
X
X    if ( yy_current_buffer )
X	{
X	/* flush out information for old buffer */
X	*yy_c_buf_p = yy_hold_char;
X	yy_current_buffer->yy_buf_pos = yy_c_buf_p;
X	yy_current_buffer->yy_n_chars = yy_n_chars;
X	}
X
X    yy_current_buffer = new_buffer;
X    yy_load_buffer_state();
X
X    /* we don't actually know whether we did this switch during
X     * EOF (yywrap()) processing, but the only time this flag
X     * is looked at is after yywrap() is called, so it's safe
X     * to go ahead and always set it.
X     */
X    yy_did_buffer_switch_on_eof = 1;
X}
X
X
Xvoid yy_load_buffer_state()
X{
X    yy_n_chars = yy_current_buffer->yy_n_chars;
X    yytext = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
X    yyin = yy_current_buffer->yy_input_file;
X    yy_hold_char = *yy_c_buf_p;
X}
X
X
XYY_BUFFER_STATE yy_create_buffer( file, size )
XFILE *file;
Xint size;
X{
X    YY_BUFFER_STATE b;
X
X    b = (YY_BUFFER_STATE) alloc( sizeof( struct yy_buffer_state ) );
X    b->yy_buf_size = size;
X
X    /* yy_ch_buf has to be 2 characters longer than the size given because
X     * we need to put in 2 end-of-buffer characters.
X     */
X    b->yy_ch_buf = (YY_CHAR *) alloc( (unsigned) (b->yy_buf_size + 2) );
X    yy_init_buffer( b, file );
X
X    return ( b );
X}
X
X
Xvoid yy_delete_buffer( b )
XYY_BUFFER_STATE b;
X{
X    if ( b == yy_current_buffer )
X	yy_current_buffer = (YY_BUFFER_STATE) 0;
X
X    free((genericptr_t)b->yy_ch_buf);
X    free((genericptr_t)b);
X}
X
X
Xvoid yy_init_buffer( b, file )
XYY_BUFFER_STATE b;
XFILE *file;
X{
X    b->yy_input_file = file;
X
X    /* we put in the '\n' and start reading from [1] so that an
X     * initial match-at-newline will be true.
X     */
X
X    b->yy_ch_buf[0] = '\n';
X    b->yy_n_chars = 1;
X
X    /* we always need two end-of-buffer characters.  The first causes
X     * a transition to the end-of-buffer state.  The second causes
X     * a jam in that state.
X     */
X    b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
X    b->yy_ch_buf[2] = YY_END_OF_BUFFER_CHAR;
X
X    b->yy_buf_pos = &b->yy_ch_buf[1];
X
X    b->yy_eof_status = EOF_NOT_SEEN;
X}
X
X
X/* routine to switch to another input file; needed for flex */
Xvoid init_yyin( input_f )
XFILE *input_f;
X{
X#ifdef FLEX_SCANNER
X	if (yyin)
X	    yyrestart(input_f);
X	else
X#endif
X	    yyin = input_f;
X}
X/* analogous routine (for completeness) */
Xvoid init_yyout( output_f )
XFILE *output_f;
X{
X	yyout = output_f;
X}
X
END_OF_FILE
if test 32050 -ne `wc -c <'sys/share/dgn_lex.c'`; then
    echo shar: \"'sys/share/dgn_lex.c'\" unpacked with wrong size!
fi
# end of 'sys/share/dgn_lex.c'
echo shar: End of archive 25 \(of 33\).
cp /dev/null ark25isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 33 archives.
    echo "Now execute ./patchit.sh"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
