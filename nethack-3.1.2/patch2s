Path: uunet!gatech!howland.reston.ans.net!europa.eng.gtefsd.com!emory!ogicse!news.tek.com!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v17i094:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Patch2s/33
Message-ID: <1v8iou$j57@ying.cna.tek.com>
Date: 11 Jun 93 00:14:22 GMT
Article-I.D.: ying.1v8iou$j57
Organization: Tektronix, Inc, Redmond, OR, USA
Lines: 2156
Approved: billr@saab.CNA.TEK.COM
NNTP-Posting-Host: saab.cna.tek.com
Xref: uunet comp.sources.games:1759

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 17, Issue 94
Archive-name: nethack31/Patch2s
Patch-To: nethack31: Volume 16, Issue 1-116
Environment: Amiga, Atari, Mac, MS-DOS, Windows-NT, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 19 (of 33)."
# Contents:  patches02j
# Wrapped by billr@saab on Thu Jun 10 16:55:05 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'patches02j' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'patches02j'\" to \"'patches02j.orig'\"
  mv -f 'patches02j' 'patches02j.orig'
fi
echo shar: Extracting \"'patches02j'\" \(52637 characters\)
sed "s/^X//" >'patches02j' <<'END_OF_FILE'
X*** /tmp/da11098	Tue Jun  1 16:14:17 1993
X--- src/mklev.c	Wed May 26 13:01:25 1993
X***************
X*** 385,391 ****
X  		else
X  		    levl[x][y].doormask = D_CLOSED;
X  
X! 		if (levl[x][y].doormask != D_ISOPEN && !shdoor && !rn2(25))
X  		    levl[x][y].doormask |= D_TRAPPED;
X  	    } else
X  #ifdef STUPID
X--- 385,392 ----
X  		else
X  		    levl[x][y].doormask = D_CLOSED;
X  
X! 		if (levl[x][y].doormask != D_ISOPEN && !shdoor &&
X! 		    level_difficulty() >= 5 && !rn2(25))
X  		    levl[x][y].doormask |= D_TRAPPED;
X  	    } else
X  #ifdef STUPID
X***************
X*** 415,421 ****
X  		if(shdoor || !rn2(5))	levl[x][y].doormask = D_LOCKED;
X  		else			levl[x][y].doormask = D_CLOSED;
X  
X! 		if(!shdoor && !rn2(20)) levl[x][y].doormask |= D_TRAPPED;
X  	}
X  
X  	add_door(x,y,aroom);
X--- 416,423 ----
X  		if(shdoor || !rn2(5))	levl[x][y].doormask = D_LOCKED;
X  		else			levl[x][y].doormask = D_CLOSED;
X  
X! 		if(!shdoor && level_difficulty() >= 4 && !rn2(20))
X! 		    levl[x][y].doormask |= D_TRAPPED;
X  	}
X  
X  	add_door(x,y,aroom);
X***************
X*** 479,488 ****
X  		    if(trap_type == TRAPDOOR && !Can_fall_thru(&u.uz))
X  			trap_type = ROCKTRAP;
X  		    ttmp = maketrap(xx, yy+dy, trap_type);
X! 		    ttmp->once = 1;
X! 		    if (trap_engravings[trap_type])
X! 			make_engr_at(xx, yy-dy,
X  				     trap_engravings[trap_type], 0L, DUST);
X  		}
X  		dosdoor(xx, yy, aroom, SDOOR);
X  	    } else {
X--- 481,492 ----
X  		    if(trap_type == TRAPDOOR && !Can_fall_thru(&u.uz))
X  			trap_type = ROCKTRAP;
X  		    ttmp = maketrap(xx, yy+dy, trap_type);
X! 		    if (ttmp) {
X! 			ttmp->once = 1;
X! 			if (trap_engravings[trap_type])
X! 			    make_engr_at(xx, yy-dy,
X  				     trap_engravings[trap_type], 0L, DUST);
X+ 		    }
X  		}
X  		dosdoor(xx, yy, aroom, SDOOR);
X  	    } else {
X***************
X*** 490,496 ****
X  		if(rn2(7))
X  		    dosdoor(xx, yy, aroom, rn2(5) ? SDOOR : DOOR);
X  		else {
X! 		    (void) mksobj_at(SCR_TELEPORTATION, xx, yy+dy, TRUE);
X  		    if(!rn2(3)) (void) mkobj_at(0, xx, yy+dy, TRUE);
X  		}
X  	    }
X--- 494,501 ----
X  		if(rn2(7))
X  		    dosdoor(xx, yy, aroom, rn2(5) ? SDOOR : DOOR);
X  		else {
X! 		    if (!level.flags.noteleport)
X! 			(void) mksobj_at(SCR_TELEPORTATION, xx, yy+dy, TRUE);
X  		    if(!rn2(3)) (void) mkobj_at(0, xx, yy+dy, TRUE);
X  		}
X  	    }
X***************
X*** 501,517 ****
X  static void
X  make_niches()
X  {
X! 	register int ct = rnd((nroom>>1) + 1);
X! 	boolean	ltptr = TRUE,
X! 		vamp = TRUE;
X  
X! 	while(ct--) {
X  
X! 		if(depth(&u.uz) > 15 && !rn2(6) && ltptr) {
X  			ltptr = FALSE;
X  			makeniche(LEVEL_TELEP);
X! 		} else if(depth(&u.uz) > 5 && depth(&u.uz) < 25
X! 							&& !rn2(6) && vamp) {
X  			vamp = FALSE;
X  			makeniche(TRAPDOOR);
X  		} else	makeniche(NO_TRAP);
X--- 506,521 ----
X  static void
X  make_niches()
X  {
X! 	register int ct = rnd((nroom>>1) + 1), dep = depth(&u.uz);
X  
X! 	boolean	ltptr = (!level.flags.noteleport && dep > 15),
X! 		vamp = (dep > 5 && dep < 25);
X  
X! 	while(ct--) {
X! 		if (ltptr && !rn2(6)) {
X  			ltptr = FALSE;
X  			makeniche(LEVEL_TELEP);
X! 		} else if (vamp && !rn2(6)) {
X  			vamp = FALSE;
X  			makeniche(TRAPDOOR);
X  		} else	makeniche(NO_TRAP);
X***************
X*** 551,556 ****
X--- 555,565 ----
X  	(void) memset((genericptr_t)level.objects, 0, sizeof(level.objects));
X  	(void) memset((genericptr_t)level.monsters, 0, sizeof(level.monsters));
X  #endif
X+ 	level.objlist = (struct obj *)0;
X+ 	level.buriedobjlist = (struct obj *)0;
X+ 	level.monlist = (struct monst *)0;
X+ 	level.damagelist = (struct damage *)0;
X+ 
X  	level.flags.nfountains = 0;
X  	level.flags.nsinks = 0;
X  	level.flags.has_shop = 0;
X***************
X*** 690,696 ****
X  #ifdef MULDGN
X  			mk_knox_portal(vault_x+w, vault_y+h);
X  #endif
X! 			if(!rn2(3)) makevtele();
X  		} else if(rnd_rect() && create_vault()) {
X  			vault_x = rooms[nroom].lx;
X  			vault_y = rooms[nroom].ly;
X--- 699,705 ----
X  #ifdef MULDGN
X  			mk_knox_portal(vault_x+w, vault_y+h);
X  #endif
X! 			if(!level.flags.noteleport && !rn2(3)) makevtele();
X  		} else if(rnd_rect() && create_vault()) {
X  			vault_x = rooms[nroom].lx;
X  			vault_y = rooms[nroom].ly;
X***************
X*** 999,1012 ****
X  bydoor(x, y)
X  register xchar x, y;
X  {
X! 	register boolean tmp1, tmp2;
X  
X! 	/* break up large expression to help some compilers */
X! 	tmp1 = (IS_DOOR(levl[x+1][y].typ) || levl[x+1][y].typ == SDOOR ||
X! 		IS_DOOR(levl[x-1][y].typ) || levl[x-1][y].typ == SDOOR);
X! 	tmp2 = (IS_DOOR(levl[x][y+1].typ) || levl[x][y+1].typ == SDOOR ||
X! 		IS_DOOR(levl[x][y-1].typ) || levl[x][y-1].typ == SDOOR);
X! 	return(tmp1 || tmp2);
X  }
X  
X  /* see whether it is allowable to create a door at [x,y] */
X--- 1008,1032 ----
X  bydoor(x, y)
X  register xchar x, y;
X  {
X! 	register int typ;
X  
X! 	if (isok(x+1, y)) {
X! 		typ = levl[x+1][y].typ;
X! 		if (IS_DOOR(typ) || typ == SDOOR) return TRUE;
X! 	}
X! 	if (isok(x-1, y)) {
X! 		typ = levl[x-1][y].typ;
X! 		if (IS_DOOR(typ) || typ == SDOOR) return TRUE;
X! 	}
X! 	if (isok(x, y+1)) {
X! 		typ = levl[x][y+1].typ;
X! 		if (IS_DOOR(typ) || typ == SDOOR) return TRUE;
X! 	}
X! 	if (isok(x, y-1)) {
X! 		typ = levl[x][y-1].typ;
X! 		if (IS_DOOR(typ) || typ == SDOOR) return TRUE;
X! 	}
X! 	return FALSE;
X  }
X  
X  /* see whether it is allowable to create a door at [x,y] */
X***************
X*** 1088,1106 ****
X  		kind = rnd(TRAPNUM-1);
X  		/* reject "too hard" traps */
X  		switch (kind) {
X  		    case LEVEL_TELEP:
X! 		    case LANDMINE:
X! 			if (lvl < 5) kind = NO_TRAP; break;
X  		    case SPIKED_PIT:
X! #ifdef POLYSELF
X! 		    case POLY_TRAP:
X! #endif
X  			if (lvl < 6) kind = NO_TRAP; break;
X  		    case WEB:
X- 		    case STATUE_TRAP:
X  			if (lvl < 7) kind = NO_TRAP; break;
X  		    case FIRE_TRAP:
X  			if (!Inhell) kind = NO_TRAP; break;
X  		}
X  	    } while (kind == NO_TRAP || kind == MAGIC_PORTAL);
X  	}
X--- 1108,1133 ----
X  		kind = rnd(TRAPNUM-1);
X  		/* reject "too hard" traps */
X  		switch (kind) {
X+ 		    case SLP_GAS_TRAP:
X+ 			if (lvl < 2) kind = NO_TRAP; break;
X  		    case LEVEL_TELEP:
X! 			if (lvl < 5 || level.flags.noteleport)
X! 			    kind = NO_TRAP; break;
X  		    case SPIKED_PIT:
X! 			if (lvl < 5) kind = NO_TRAP; break;
X! 		    case LANDMINE:
X  			if (lvl < 6) kind = NO_TRAP; break;
X  		    case WEB:
X  			if (lvl < 7) kind = NO_TRAP; break;
X+ 		    case STATUE_TRAP:
X+ #ifdef POLYSELF
X+ 		    case POLY_TRAP:
X+ #endif
X+ 			if (lvl < 8) kind = NO_TRAP; break;
X  		    case FIRE_TRAP:
X  			if (!Inhell) kind = NO_TRAP; break;
X+ 		    case TELEP_TRAP:
X+ 			if (level.flags.noteleport) kind = NO_TRAP; break;
X  		}
X  	    } while (kind == NO_TRAP || kind == MAGIC_PORTAL);
X  	}
X***************
X*** 1250,1256 ****
X      register xchar i;
X  
X      pline("The floor shakes violently under you!");
X!     pline("The walls around you begin to move and fall down!");
X      display_nhwindow(WIN_MESSAGE, TRUE);
X  
X      for(dist = 1; dist < 7; dist++) {
X--- 1277,1283 ----
X      register xchar i;
X  
X      pline("The floor shakes violently under you!");
X!     pline("The walls around you begin to bend and crumble!");
X      display_nhwindow(WIN_MESSAGE, TRUE);
X  
X      for(dist = 1; dist < 7; dist++) {
X***************
X*** 1310,1316 ****
X  	lev->typ = ROOM;
X  	if (is_pool(x,y)) break;
X  	ttmp = maketrap(x, y, FIRE_TRAP);
X! 	ttmp->tseen = TRUE;
X  	break;
X      case 2: /* lit room locations */
X      case 3:
X--- 1337,1343 ----
X  	lev->typ = ROOM;
X  	if (is_pool(x,y)) break;
X  	ttmp = maketrap(x, y, FIRE_TRAP);
X! 	if (ttmp) ttmp->tseen = TRUE;
X  	break;
X      case 2: /* lit room locations */
X      case 3:
X*** /tmp/da11114	Tue Jun  1 16:14:23 1993
X--- src/mkmaze.c	Wed May 26 13:03:15 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)mkmaze.c	3.1	93/01/17	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)mkmaze.c	3.1	93/05/23	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 339,344 ****
X--- 339,347 ----
X      } else if(Is_knox(&u.uz)) {
X  	/* using an unfilled morgue for rm id */
X  	croom = search_special(MORGUE);
X+ 	/* avoid inappropriate morgue-related messages */
X+ 	level.flags.graveyard = level.flags.has_morgue = FALSE;
X+ 	croom->rtype = OROOM;	/* perhaps it should be set to VAULT? */
X  	/* stock the main vault */
X  	for(x = croom->lx; x <= croom->hx; x++)
X  	    for(y = croom->ly; y <= croom->hy; y++) {
X***************
X*** 724,729 ****
X--- 727,736 ----
X  	/* portal in the destination dungeon/dlevel */
X  	register struct trap *ttmp = maketrap(x, y, MAGIC_PORTAL);
X  
X+ 	if (!ttmp) {
X+ 		impossible("portal on top of portal??");
X+ 		return;
X+ 	}
X  #ifdef DEBUG
X  	pline("mkportal: at (%d,%d), to %s, level %d",
X  		x, y, dungeons[todnum].dname, todlevel);
X***************
X*** 893,910 ****
X  	vision_full_recalc = 1;
X  }
X  
X  void
X  water_friction()
X  {
X  	register boolean eff = FALSE;
X  
X! 	if (u.dx && !rn2(3)) {
X! 		eff = TRUE;
X  		u.dx = 0;
X! 	}
X! 	if (u.dy && !rn2(3)) {
X  		eff = TRUE;
X  		u.dy = 0;
X  	}
X  	if (eff) pline("Water turbulence affects your movements.");
X  }
X--- 900,937 ----
X  	vision_full_recalc = 1;
X  }
X  
X+ /* when moving in water, possibly (1 in 3) alter the intended destination */
X  void
X  water_friction()
X  {
X+ 	register int x, y, dx, dy;
X  	register boolean eff = FALSE;
X  
X! #ifdef POLYSELF
X! 	if (is_swimmer(uasmon) && rn2(4))
X! 		return;		/* natural swimmers have advantage */
X! #endif
X! 
X! 	if (u.dx && !rn2(!u.dy ? 3 : 6)) {	/* 1/3 chance or half that */
X! 		/* cancel delta x and choose an arbitrary delta y value */
X! 		x = u.ux;
X! 		do {
X! 		    dy = rn2(3) - 1;		/* -1, 0, 1 */
X! 		    y = u.uy + dy;
X! 		} while (dy && (!isok(x,y) || !is_pool(x,y)));
X  		u.dx = 0;
X! 		u.dy = dy;
X  		eff = TRUE;
X+ 	} else if (u.dy && !rn2(!u.dx ? 3 : 5)) {	/* 1/3 or 1/5*(5/6) */
X+ 		/* cancel delta y and choose an arbitrary delta x value */
X+ 		y = u.uy;
X+ 		do {
X+ 		    dx = rn2(3) - 1;		/* -1 .. 1 */
X+ 		    x = u.ux + dx;
X+ 		} while (dx && (!isok(x,y) || !is_pool(x,y)));
X  		u.dy = 0;
X+ 		u.dx = dx;
X+ 		eff = TRUE;
X  	}
X  	if (eff) pline("Water turbulence affects your movements.");
X  }
X***************
X*** 1209,1214 ****
X  		}
X  	}
X  }
X- 
X  
X  /*mkmaze.c*/
X--- 1236,1240 ----
X*** /tmp/da11122	Tue Jun  1 16:14:26 1993
X--- src/mkobj.c	Mon May  3 13:20:27 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)mkobj.c	3.1	93/02/10	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)mkobj.c	3.1	93/05/01	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 66,73 ****
X  { 4, AMULET_CLASS}
X  };
X  
X- static NEARDATA int mksx=0, mksy=0;
X- 
X  struct obj *
X  mkobj_at(let,x,y, artif)
X  char let;
X--- 66,71 ----
X***************
X*** 76,91 ****
X  {
X  	register struct obj *otmp;
X  
X- 	mksx = x; mksy = y;
X- 	/* We need to know the X, Y coordinates while creating the object,
X- 	 * to insure shop boxes are empty.
X- 	 * Yes, this is a horrible kludge...
X- 	 */
X  	otmp = mkobj(let,artif);
X  	otmp->nobj = fobj;
X  	fobj = otmp;
X  	place_object(otmp, x, y);
X- 	mksx = mksy = 0;
X  	return(otmp);
X  }
X  
X--- 74,83 ----
X***************
X*** 96,107 ****
X  {
X  	register struct obj *otmp;
X  
X- 	mksx = x; mksy = y;
X  	otmp = mksobj(otyp,init,TRUE);
X  	otmp->nobj = fobj;
X  	place_object(otmp, x, y);
X! 	mksx = mksy = 0;
X! 	return((fobj = otmp));
X  }
X  
X  struct obj *
X--- 88,98 ----
X  {
X  	register struct obj *otmp;
X  
X  	otmp = mksobj(otyp,init,TRUE);
X  	otmp->nobj = fobj;
X+ 	fobj = otmp;
X  	place_object(otmp, x, y);
X! 	return(otmp);
X  }
X  
X  struct obj *
X***************
X*** 599,604 ****
X--- 590,597 ----
X  		return (int)obj->quan * mons[obj->corpsenm].cwt;
X  	else if (obj->otyp == GOLD_PIECE)
X  		return (int)((obj->quan + 50L) / 100L);
X+ 	else if (obj->otyp == HEAVY_IRON_BALL && obj->owt != 0)
X+ 		return obj->owt;	/* kludge for "very" heavy iron ball */
X  	return(wt ? wt*(int)obj->quan : ((int)obj->quan + 1)>>1);
X  }
X  
X*** /tmp/da10930	Tue Jun  1 16:13:22 1993
X--- src/dothrow.c	Wed May 19 10:08:19 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)dothrow.c	3.1	92/12/10	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)dothrow.c	3.1	93/05/15	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 84,93 ****
X  	}
X  	if (IS_ALTAR(levl[u.ux][u.uy].typ)) doaltarobj(obj);
X  	else
X! 		pline("%s hits the floor.", Doname2(obj));
X  	if (breaks(obj, TRUE)) return;
X  	else if(obj->oclass == POTION_CLASS) {
X! 		pline("The flask breaks, and you smell a peculiar odor...");
X  		potionbreathe(obj);
X  		if(*u.ushops)
X  		    check_shop_obj(obj, u.ux, u.uy, TRUE);
X--- 84,95 ----
X  	}
X  	if (IS_ALTAR(levl[u.ux][u.uy].typ)) doaltarobj(obj);
X  	else
X! 		pline("%s hit%s the %s.", Doname2(obj), 
X! 		      (obj->quan == 1L) ? "s" : "", surface(u.ux,u.uy));
X  	if (breaks(obj, TRUE)) return;
X  	else if(obj->oclass == POTION_CLASS) {
X! 		pline("The flask%s break%s, and you smell a peculiar odor...",
X! 		      plur(obj->quan), (obj->quan == 1L) ? "s" : "");
X  		potionbreathe(obj);
X  		if(*u.ushops)
X  		    check_shop_obj(obj, u.ux, u.uy, TRUE);
X***************
X*** 129,141 ****
X  	   (IS_DOOR(levl[nx][ny].typ) && (levl[nx][ny].doormask & D_ISOPEN))) {
X  	    pline("Ouch!");
X  	    losehp(rnd(2+range), IS_ROCK(levl[nx][ny].typ) ?
X! 		   "bumping to a wall" : "bumping into a door", KILLED_BY);
X  	    break;
X  	}
X  
X! 	if (obj = sobj_at(BOULDER,nx,ny)) {
X  	    You("bump into a %s.  Ouch!", xname(obj));
X! 	    losehp(rnd(2+range), "bumping to a boulder", KILLED_BY);
X  	    break;
X  	}
X  
X--- 131,143 ----
X  	   (IS_DOOR(levl[nx][ny].typ) && (levl[nx][ny].doormask & D_ISOPEN))) {
X  	    pline("Ouch!");
X  	    losehp(rnd(2+range), IS_ROCK(levl[nx][ny].typ) ?
X! 		   "bumping into a wall" : "bumping into a door", KILLED_BY);
X  	    break;
X  	}
X  
X! 	if ((obj = sobj_at(BOULDER,nx,ny)) != 0) {
X  	    You("bump into a %s.  Ouch!", xname(obj));
X! 	    losehp(rnd(2+range), "bumping into a boulder", KILLED_BY);
X  	    break;
X  	}
X  
X***************
X*** 142,148 ****
X  	u.ux = nx;
X  	u.uy = ny;
X  	newsym(u.ux - dx, u.uy - dy);
X! 	if(mon = m_at(u.ux, u.uy)) {
X  	    You("bump into %s.", a_monnam(mon));
X  	    wakeup(mon);
X  	    if(Is_airlevel(&u.uz))
X--- 144,150 ----
X  	u.ux = nx;
X  	u.uy = ny;
X  	newsym(u.ux - dx, u.uy - dy);
X! 	if ((mon = m_at(u.ux, u.uy)) != 0) {
X  	    You("bump into %s.", a_monnam(mon));
X  	    wakeup(mon);
X  	    if(Is_airlevel(&u.uz))
X***************
X*** 245,250 ****
X--- 247,253 ----
X  	      pline("%s hits the ceiling and returns to your hand!",
X  		    The(xname(obj)));
X  	      obj = addinv(obj);
X+ 	      (void) encumber_msg();
X  	      setuwep(obj);
X  	      return(1);
X  	  }
X***************
X*** 297,302 ****
X--- 300,306 ----
X  		if(mon == &youmonst) {		/* the thing was caught */
X  			exercise(A_DEX, TRUE);
X  			(void) addinv(obj);
X+ 			(void) encumber_msg();
X  			return(1);
X  		}
X  	} else {
X***************
X*** 365,371 ****
X  		int obj_glyph = obj_to_glyph(obj);
X  		boolean gone = FALSE;
X  
X! 		if (obj->oartifact == ART_MJOLLNIR && pl_character[0] == 'V') {
X  		    /* we must be wearing Gauntlets of Power to get here */
X  
X  		    /* might already be our location (bounced off a wall) */
X--- 369,376 ----
X  		int obj_glyph = obj_to_glyph(obj);
X  		boolean gone = FALSE;
X  
X! 		if (obj->oartifact == ART_MJOLLNIR &&
X! 			pl_character[0] == 'V' && rn2(100)) {
X  		    /* we must be wearing Gauntlets of Power to get here */
X  
X  		    /* might already be our location (bounced off a wall) */
X***************
X*** 381,389 ****
X  			tmp_at(DISP_END, 0);
X  		    }
X  
X! 		    if(!impaired) {
X  			pline("%s returns to your hand!", The(xname(obj)));
X  			obj = addinv(obj);
X  			setuwep(obj);
X  			if(cansee(bhitpos.x, bhitpos.y))
X  			    newsym(bhitpos.x,bhitpos.y);
X--- 386,395 ----
X  			tmp_at(DISP_END, 0);
X  		    }
X  
X! 		    if (!impaired && rn2(100)) {
X  			pline("%s returns to your hand!", The(xname(obj)));
X  			obj = addinv(obj);
X+ 			(void) encumber_msg();
X  			setuwep(obj);
X  			if(cansee(bhitpos.x, bhitpos.y))
X  			    newsym(bhitpos.x,bhitpos.y);
X***************
X*** 492,497 ****
X--- 498,520 ----
X  	/* it's easier to hit a larger target */
X  	if(bigmonst(mon->data)) tmp++;
X  
X+ 	/* gloves are a hinderance to proper use of bows */
X+ 	if (uarmg && uwep && -objects[uwep->otyp].w_propellor == WP_BOW) {
X+ 		switch(uarmg->otyp) {
X+ 			case GAUNTLETS_OF_POWER:    /* metal */
X+ 			    tmp -= 2;
X+ 			    break;
X+ 			case GAUNTLETS_OF_FUMBLING:
X+ 			    tmp -= 3;
X+ 			    break;
X+ 			case LEATHER_GLOVES:
X+ 			case GAUNTLETS_OF_DEXTERITY:
X+ 			    break;
X+ 			default: impossible("Unknown type of gloves (%d)",
X+ 			    uarmg->otyp);
X+ 		}
X+ 	}
X+ 
X  	if(mon->msleep) {
X  		mon->msleep = 0;
X  		tmp += 2;
X***************
X*** 709,723 ****
X  	            check_shop_obj(obj, obj->ox, obj->oy, TRUE);
X  		obfree(obj, (struct obj *)0);
X  	} else {
X! 	        /* it is assumed that the obj is a floor-object */ 
X! 	        register struct monst *shkp;
X! 	        boolean costly, insider;
X  		long loss = 0L;
X  
X- #ifdef GCC_WARN
X- 		shkp = (struct monst *) 0;
X- #endif
X- 
X  		costly = (costly_spot(obj->ox, obj->oy) && 
X  				   (shkp = shop_keeper(*in_rooms(obj->ox,
X  				  obj->oy, SHOPBASE))) != (struct monst *)0);
X--- 732,742 ----
X  	            check_shop_obj(obj, obj->ox, obj->oy, TRUE);
X  		obfree(obj, (struct obj *)0);
X  	} else {
X! 		/* it is assumed that the obj is a floor-object */ 
X! 		register struct monst *shkp = 0;
X! 		boolean costly, insider;
X  		long loss = 0L;
X  
X  		costly = (costly_spot(obj->ox, obj->oy) && 
X  				   (shkp = shop_keeper(*in_rooms(obj->ox,
X  				  obj->oy, SHOPBASE))) != (struct monst *)0);
X***************
X*** 763,773 ****
X  		    if(uarmh) pline("Fortunately, you are wearing a helmet!");
X  		}
X  		if(flooreffects(obj,u.ux,u.uy,"fall")) return(1);
X! 		if(u.dz > 0) pline("The gold hits the floor.");
X  		obj->nobj = fobj;	/* add the gold to the object list */
X  		fobj = obj;
X  		place_object(obj,u.ux,u.uy);
X!                 if(*u.ushops) sellobj(obj, u.ux, u.uy);
X  		stackobj(obj);
X  		newsym(u.ux,u.uy);
X  		return 1;
X--- 782,792 ----
X  		    if(uarmh) pline("Fortunately, you are wearing a helmet!");
X  		}
X  		if(flooreffects(obj,u.ux,u.uy,"fall")) return(1);
X! 		if(u.dz > 0) pline("The gold hits the %s.", surface(u.ux,u.uy));
X  		obj->nobj = fobj;	/* add the gold to the object list */
X  		fobj = obj;
X  		place_object(obj,u.ux,u.uy);
X! 		if(*u.ushops) sellobj(obj, u.ux, u.uy);
X  		stackobj(obj);
X  		newsym(u.ux,u.uy);
X  		return 1;
X***************
X*** 798,804 ****
X  	obj->nobj = fobj;	/* add the gold to the object list */
X  	fobj = obj;
X  	place_object(obj,bhitpos.x,bhitpos.y);
X!         if(*u.ushops) sellobj(obj, bhitpos.x, bhitpos.y);
X  	stackobj(obj);
X  	newsym(bhitpos.x,bhitpos.y);
X  	return(1);
X--- 817,823 ----
X  	obj->nobj = fobj;	/* add the gold to the object list */
X  	fobj = obj;
X  	place_object(obj,bhitpos.x,bhitpos.y);
X! 	if(*u.ushops) sellobj(obj, bhitpos.x, bhitpos.y);
X  	stackobj(obj);
X  	newsym(bhitpos.x,bhitpos.y);
X  	return(1);
X*** /tmp/da13396	Tue Jun  1 17:54:06 1993
X--- win/tty/getline.c	Wed Mar 10 20:39:07 1993
X***************
X*** 3,8 ****
X--- 3,11 ----
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X  #include "hack.h"
X+ 
X+ #ifdef TTY_GRAPHICS
X+ 
X  #include "wintty.h"
X  #include "func_tab.h"
X  
X***************
X*** 219,223 ****
X--- 222,228 ----
X  #endif /* COM_COMPL */
X  
X  #endif /* OVL2 */
X+ 
X+ #endif /* TTY_GRAPHICS */
X  
X  /*getline.c*/
X*** /tmp/da13404	Tue Jun  1 17:54:08 1993
X--- win/tty/termcap.c	Wed May 26 14:12:28 1993
X***************
X*** 3,8 ****
X--- 3,11 ----
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X  #include "hack.h"
X+ 
X+ #if defined (TTY_GRAPHICS) && !defined(NO_TERMS)
X+ 
X  #include "wintty.h"
X  
X  #include "termcap.h"
X***************
X*** 14,30 ****
X  #define Tgetstr(key) (tgetstr(key,&tbufptr))
X  #endif /* MICROPORT_286_BUG **/
X  
X  void FDECL(cmov, (int, int));
X  void FDECL(nocmov, (int, int));
X! #ifdef TEXTCOLOR
X! # ifdef TERMLIB
X! #  ifdef OVLB
X  #   ifndef TOS
X  static void FDECL(analyze_seq, (char *, int *, int *));
X  #   endif
X  static void NDECL(init_hilite);
X! #  endif /* OVLB */
X! # endif
X  #endif
X  
X  #ifdef OVLB
X--- 17,36 ----
X  #define Tgetstr(key) (tgetstr(key,&tbufptr))
X  #endif /* MICROPORT_286_BUG **/
X  
X+ static char * FDECL(s_atr2str, (int));
X+ static char * FDECL(e_atr2str, (int));
X+ 
X  void FDECL(cmov, (int, int));
X  void FDECL(nocmov, (int, int));
X! #if defined(TEXTCOLOR) && defined(TERMLIB)
X! # ifdef OVLB
X! #  if !defined(UNIX) || !defined(TERMINFO)
X  #   ifndef TOS
X  static void FDECL(analyze_seq, (char *, int *, int *));
X  #   endif
X+ #  endif
X  static void NDECL(init_hilite);
X! # endif /* OVLB */
X  #endif
X  
X  #ifdef OVLB
X***************
X*** 78,113 ****
X  
X  void
X  tty_startup(wid, hgt)
X!     int *wid, *hgt;
X  {
X  #ifdef TERMLIB
X  	register const char *term;
X  	register char *tptr;
X  	char *tbufptr, *pc;
X- #endif
X- 	register int i;
X  
X- #ifdef TERMLIB
X  # ifdef VMS
X! 	if (!(term = verify_termcap()))
X  # endif
X! 	term = getenv("TERM");
X! #endif
X  
X! #ifdef TERMLIB
X! 	if(!term)
X! #endif
X! #if defined(TOS) && defined(__GNUC__) && defined(TERMLIB)
X  		term = "builtin";		/* library has a default */
X  #else
X! #  ifdef ANSI_DEFAULT
X! #   ifdef TOS
X  	{
X  		CO = 80; LI = 25;
X  		TI = VS = VE = TE = nullstr;
X  		HO = "\033H";
X! 		CL = "\033E";		/* the VT52 termcap */
X! 		CE = "\033K";
X  		UP = "\033A";
X  		CM = "\033Y%c%c";	/* used with function tgoto() */
X  		ND = "\033C";
X--- 84,118 ----
X  
X  void
X  tty_startup(wid, hgt)
X! int *wid, *hgt;
X  {
X+ 	register int i;
X  #ifdef TERMLIB
X  	register const char *term;
X  	register char *tptr;
X  	char *tbufptr, *pc;
X  
X  # ifdef VMS
X! 	term = verify_termcap();
X! 	if (!term)
X  # endif
X! 		term = getenv("TERM");
X  
X! # if defined(TOS) && defined(__GNUC__)
X! 	if (!term)
X  		term = "builtin";		/* library has a default */
X+ # endif
X+ 	if (!term)
X+ #endif
X+ #ifndef ANSI_DEFAULT
X+ 		error("Can't get TERM.");
X  #else
X! # ifdef TOS
X  	{
X  		CO = 80; LI = 25;
X  		TI = VS = VE = TE = nullstr;
X  		HO = "\033H";
X! 		CE = "\033K";		/* the VT52 termcap */
X  		UP = "\033A";
X  		CM = "\033Y%c%c";	/* used with function tgoto() */
X  		ND = "\033C";
X***************
X*** 118,190 ****
X  	/* HI and HE will be updated in init_hilite if we're using color */
X  		HI = "\033p";
X  		HE = "\033q";
X  	}
X! #   else /* TOS */
X  	{
X! #    ifdef MICRO
X  		get_scr_size();
X! #     ifdef CLIPPING
X  		if(CO < COLNO || LI < ROWNO+3)
X  			setclipped();
X! #     endif
X! #    endif
X  		HO = "\033[H";
X- 		CL = "\033[2J";		/* the ANSI termcap */
X  /*		CD = "\033[J"; */
X! 		CE = "\033[K";
X! #    ifndef TERMLIB
X  		CM = "\033[%d;%dH";
X! #    else
X  		CM = "\033[%i%d;%dH";
X! #    endif
X  		UP = "\033[A";
X  		ND = "\033[C";
X  		XD = "\033[B";
X! #    ifdef MICRO	/* backspaces are non-destructive */
X  		BC = "\b";
X! #    else
X  		BC = "\033[D";
X! #    endif
X  		HI = SO = "\033[1m";
X  		US = "\033[4m";
X! #    if 0
X  		MR = "\033[7m";
X  		ME = "\033[0m";
X! #    endif
X  		TI = HE = SE = UE = "\033[0m";
X  		/* strictly, SE should be 2, and UE should be 24,
X  		   but we can't trust all ANSI emulators to be
X  		   that complete.  -3. */
X! #    ifndef MICRO
X  		AS = "\016";
X  		AE = "\017";
X! #    endif
X  		TE = VS = VE = nullstr;
X! #    ifdef TEXTCOLOR
X  		for (i = 0; i < MAXCOLORS / 2; i++)
X  		    if (i != BLACK) {
X  			hilites[i|BRIGHT] = (char *) alloc(sizeof("\033[1;3%dm"));
X  			Sprintf(hilites[i|BRIGHT], "\033[1;3%dm", i);
X  			if (i != GRAY)
X! #     ifdef MICRO
X  			    if (i == BLUE) hilites[BLUE] = hilites[BLUE|BRIGHT];
X  			    else
X! #     endif
X  			    {
X  				hilites[i] = (char *) alloc(sizeof("\033[0;3%dm"));
X  				Sprintf(hilites[i], "\033[0;3%dm", i);
X  			    }
X  		    }
X! #    endif
X  		*wid = CO;
X  		*hgt = LI;
X  		return;
X  	}
X! #   endif /* TOS */
X! #  else
X! 		error("Can't get TERM.");
X! #  endif /* ANSI_DEFAULT */
X! #endif /* __GNUC__ && TOS && TERMCAP */
X  #ifdef TERMLIB
X  	tptr = (char *) alloc(1024);
X  
X--- 123,197 ----
X  	/* HI and HE will be updated in init_hilite if we're using color */
X  		HI = "\033p";
X  		HE = "\033q";
X+ 		*wid = CO;
X+ 		*hgt = LI;
X+ 		CL = "\033E";		/* last thing set */
X+ 		return;
X  	}
X! # else /* TOS */
X  	{
X! #  ifdef MICRO
X  		get_scr_size();
X! #   ifdef CLIPPING
X  		if(CO < COLNO || LI < ROWNO+3)
X  			setclipped();
X! #   endif
X! #  endif
X  		HO = "\033[H";
X  /*		CD = "\033[J"; */
X! 		CE = "\033[K";		/* the ANSI termcap */
X! #  ifndef TERMLIB
X  		CM = "\033[%d;%dH";
X! #  else
X  		CM = "\033[%i%d;%dH";
X! #  endif
X  		UP = "\033[A";
X  		ND = "\033[C";
X  		XD = "\033[B";
X! #  ifdef MICRO	/* backspaces are non-destructive */
X  		BC = "\b";
X! #  else
X  		BC = "\033[D";
X! #  endif
X  		HI = SO = "\033[1m";
X  		US = "\033[4m";
X! #  if 0
X  		MR = "\033[7m";
X  		ME = "\033[0m";
X! #  endif
X  		TI = HE = SE = UE = "\033[0m";
X  		/* strictly, SE should be 2, and UE should be 24,
X  		   but we can't trust all ANSI emulators to be
X  		   that complete.  -3. */
X! #  ifndef MICRO
X  		AS = "\016";
X  		AE = "\017";
X! #  endif
X  		TE = VS = VE = nullstr;
X! #  ifdef TEXTCOLOR
X  		for (i = 0; i < MAXCOLORS / 2; i++)
X  		    if (i != BLACK) {
X  			hilites[i|BRIGHT] = (char *) alloc(sizeof("\033[1;3%dm"));
X  			Sprintf(hilites[i|BRIGHT], "\033[1;3%dm", i);
X  			if (i != GRAY)
X! #   ifdef MICRO
X  			    if (i == BLUE) hilites[BLUE] = hilites[BLUE|BRIGHT];
X  			    else
X! #   endif
X  			    {
X  				hilites[i] = (char *) alloc(sizeof("\033[0;3%dm"));
X  				Sprintf(hilites[i], "\033[0;3%dm", i);
X  			    }
X  		    }
X! #  endif
X  		*wid = CO;
X  		*hgt = LI;
X+ 		CL = "\033[2J";		/* last thing set */
X  		return;
X  	}
X! # endif /* TOS */
X! #endif /* ANSI_DEFAULT */
X! 
X  #ifdef TERMLIB
X  	tptr = (char *) alloc(1024);
X  
X***************
X*** 201,207 ****
X  	    error("Terminal must backspace.");
X  # else
X  	    if(!(BC = Tgetstr("bc"))) {	/* termcap also uses bc/bs */
X! #  if !defined(MINIMAL_TERM)
X  		if(!tgetflag("bs"))
X  			error("Terminal must backspace.");
X  #  endif
X--- 208,214 ----
X  	    error("Terminal must backspace.");
X  # else
X  	    if(!(BC = Tgetstr("bc"))) {	/* termcap also uses bc/bs */
X! #  ifndef MINIMAL_TERM
X  		if(!tgetflag("bs"))
X  			error("Terminal must backspace.");
X  #  endif
X***************
X*** 230,239 ****
X  		get_scr_size();
X  	else {
X  #  endif
X! 	CO = tgetnum("co");
X! 	LI = tgetnum("li");
X! 	if (!LI || !CO)			/* if we don't override it */
X! 		get_scr_size();
X  #  if defined(TOS) && defined(__GNUC__)
X  	}
X  #  endif
X--- 237,246 ----
X  		get_scr_size();
X  	else {
X  #  endif
X! 		CO = tgetnum("co");
X! 		LI = tgetnum("li");
X! 		if (!LI || !CO)			/* if we don't override it */
X! 			get_scr_size();
X  #  if defined(TOS) && defined(__GNUC__)
X  	}
X  #  endif
X***************
X*** 242,252 ****
X  	if(CO < COLNO || LI < ROWNO+3)
X  		setclipped();
X  # endif
X- 	if(!(CL = Tgetstr("cl")))
X- 		error("Hack needs CL.");
X  	ND = Tgetstr("nd");
X  	if(tgetflag("os"))
X! 		error("Hack can't have OS.");
X  	if(tgetflag("ul"))
X  		ul_hack = TRUE;
X  	CE = Tgetstr("ce");
X--- 249,257 ----
X  	if(CO < COLNO || LI < ROWNO+3)
X  		setclipped();
X  # endif
X  	ND = Tgetstr("nd");
X  	if(tgetflag("os"))
X! 		error("NetHack can't have OS.");
X  	if(tgetflag("ul"))
X  		ul_hack = TRUE;
X  	CE = Tgetstr("ce");
X***************
X*** 258,267 ****
X  	XD = Tgetstr("xd");
X  /* not: 		XD = Tgetstr("do"); */
X  	if(!(CM = Tgetstr("cm"))) {
X! 		if(!UP && !HO)
X! 			error("Hack needs CM or UP or HO.");
X! 		tty_raw_print("Playing hack on terminals without cm is suspect...");
X! 		tty_wait_synch();
X  	}
X  	SO = Tgetstr("so");
X  	SE = Tgetstr("se");
X--- 263,272 ----
X  	XD = Tgetstr("xd");
X  /* not: 		XD = Tgetstr("do"); */
X  	if(!(CM = Tgetstr("cm"))) {
X! 	    if(!UP && !HO)
X! 		error("NetHack needs CM or UP or HO.");
X! 	    tty_raw_print("Playing NetHack on terminals without CM is suspect.");
X! 	    tty_wait_synch();
X  	}
X  	SO = Tgetstr("so");
X  	SE = Tgetstr("se");
X***************
X*** 304,311 ****
X  # ifdef TEXTCOLOR
X  	MD = Tgetstr("md");
X  # endif
X- 	if(tbufptr-tbuf > sizeof(tbuf)) error("TERMCAP entry too big...\n");
X- 	free((genericptr_t)tptr);
X  # ifdef TEXTCOLOR
X  #  if defined(TOS) && defined(__GNUC__)
X  	if (!strcmp(term, "builtin") || !strcmp(term, "tw52") ||
X--- 309,314 ----
X***************
X*** 316,324 ****
X  	init_hilite();
X  #  endif
X  # endif
X- #endif /* TERMLIB */
X  	*wid = CO;
X  	*hgt = LI;
X  }
X  
X  void
X--- 319,331 ----
X  	init_hilite();
X  #  endif
X  # endif
X  	*wid = CO;
X  	*hgt = LI;
X+ 	if (!(CL = Tgetstr("cl")))	/* last thing set */
X+ 		error("NetHack needs CL.");
X+ 	if(tbufptr-tbuf > sizeof(tbuf)) error("TERMCAP entry too big...\n");
X+ 	free((genericptr_t)tptr);
X+ #endif /* TERMLIB */
X  }
X  
X  void
X***************
X*** 367,381 ****
X--- 374,428 ----
X  	 * Do not select NA ASCII as the primary font since people may
X  	 * reasonably be using the UK character set.
X  	 */
X+ #ifdef PC9801
X+ 	init_hilite();
X+ #endif
X  	if (flags.DECgraphics) xputs("\033)0");
X  }
X  #endif
X  
X+ #if defined(ASCIIGRAPH) && defined(PC9801)
X+ extern void NDECL((*ibmgraphics_mode_callback));    /* defined in drawing.c */
X+ #endif
X+ 
X+ #ifdef PC9801
X+ extern void NDECL((*ascgraphics_mode_callback));    /* defined in drawing.c */
X+ static void NDECL(tty_ascgraphics_hilite_fixup);
X+ 
X+ static void
X+ tty_ascgraphics_hilite_fixup()
X+ {
X+     register int c;
X+ 
X+     for (c = 0; c < MAXCOLORS / 2; c++)
X+ 	if (c != BLACK) {
X+ 	    hilites[c|BRIGHT] = (char *) alloc(sizeof("\033[1;3%dm"));
X+ 	    Sprintf(hilites[c]BRIGHT], "\033[1;3%dm", c);
X+ 	    if (c != GRAY) {
X+ 		    hilites[c] = (char *) alloc(sizeof("\033[0;3%dm"));
X+ 		    Sprintf(hilites[c], "\033[0;3%dm", c);
X+ 	    }
X+ 	}
X+ }
X+ #endif /* PC9801 */
X+ 
X  void
X  tty_start_screen()
X  {
X  	xputs(TI);
X  	xputs(VS);
X+ #ifdef PC9801
X+     if (!flags.IBMgraphics && !flags.DECgraphics)
X+ 	    tty_ascgraphics_hilite_fixup();
X+     /* set up callback in case option is not set yet but toggled later */
X+     ascgraphics_mode_callback = tty_ascgraphics_hilite_fixup;
X+ # ifdef ASCIIGRAPH
X+     if (flags.IBMgraphics) init_hilite();
X+     /* set up callback in case option is not set yet but toggled later */
X+     ibmgraphics_mode_callback = init_hilite;
X+ # endif
X+ #endif /* PC9801 */
X+ 
X  #ifdef TERMLIB
X  	if (flags.DECgraphics) tty_decgraphics_termcap_fixup();
X  	/* set up callback in case option is not set yet but toggled later */
X***************
X*** 869,875 ****
X  #   endif
X  		if (c == foreg)
X  		    hilites[c] = NULL;
X! 		else if (c != hi_foreg && backg != hi_backg) {
X  		    hilites[c] = (char *) alloc(sizeof("\033[%d;3%d;4%dm"));
X  		    Sprintf(hilites[c], "\033[%d", !!(c & BRIGHT));
X  		    if ((c | BRIGHT) != (foreg | BRIGHT))
X--- 916,922 ----
X  #   endif
X  		if (c == foreg)
X  		    hilites[c] = NULL;
X! 		else if (c != hi_foreg || backg != hi_backg) {
X  		    hilites[c] = (char *) alloc(sizeof("\033[%d;3%d;4%dm"));
X  		    Sprintf(hilites[c], "\033[%d", !!(c & BRIGHT));
X  		    if ((c | BRIGHT) != (foreg | BRIGHT))
X***************
X*** 889,894 ****
X--- 936,1037 ----
X  # endif /* UNIX */
X  #endif /* TEXTCOLOR */
X  
X+ 
X+ static char nulstr[] = "";
X+ 
X+ static char *
X+ s_atr2str(n)
X+ int n;
X+ {
X+     switch (n) {
X+ 	    case ATR_ULINE:
X+ 		    if(US) return US;
X+ 	    case ATR_BOLD:
X+ 	    case ATR_BLINK:
X+ 	    case ATR_INVERSE:
X+ 		    return HI;
X+     }
X+     return nulstr;
X+ }
X+ 
X+ static char *
X+ e_atr2str(n)
X+ int n;
X+ {
X+     switch (n) {
X+ 	    case ATR_ULINE:
X+ 		    if(UE) return UE;
X+ 	    case ATR_BOLD:
X+ 	    case ATR_BLINK:
X+ 	    case ATR_INVERSE:
X+ 		    return HE;
X+     }
X+     return nulstr;
X+ }
X+ 
X+ 
X+ void
X+ term_start_attr(attr)
X+ int attr;
X+ {
X+ 	if (attr) {
X+ 		xputs(s_atr2str(attr));
X+ 	}
X+ }
X+ 
X+ 		
X+ void
X+ term_end_attr(attr)
X+ int attr;
X+ {
X+ 	if(attr) {
X+ 		xputs(e_atr2str(attr));
X+ 	}
X+ }
X+ 
X+ 
X+ void
X+ term_start_raw_bold()
X+ {
X+ 	xputs(HI);
X+ }
X+ 
X+ 
X+ void
X+ term_end_raw_bold()
X+ {
X+ 	xputs(HE);
X+ }
X+ 
X+ 
X+ #ifdef TEXTCOLOR
X+ 
X+ void
X+ term_end_color()
X+ {
X+ 	xputs(HE);
X+ }
X+ 
X+ 
X+ void
X+ term_start_color(color)
X+ int color;
X+ {
X+ 	xputs(hilites[color]);
X+ }
X+ 
X+ 
X+ int
X+ has_color(color)
X+ int color;
X+ {
X+ 	return hilites[color] != NULL;
X+ }
X+ 
X+ #endif /* TEXTCOLOR */
X+ 
X  #endif /* OVLB */
X+ 
X+ #endif /* TTY_GRAPHICS */
X  
X  /*termcap.c*/
X*** /tmp/da14917	Wed Jun  2 08:47:20 1993
X--- win/tty/topl.c	Wed Jun  2 08:47:04 1993
X***************
X*** 1,8 ****
X! /*	SCCS Id: @(#)topl.c	3.1	90/09/21
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X  #include "hack.h"
X  #include "termcap.h"
X  #include "wintty.h"
X  #include <ctype.h>
X--- 1,11 ----
X! /*	SCCS Id: @(#)topl.c	3.1	93/06/01	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X  #include "hack.h"
X+ 
X+ #ifdef TTY_GRAPHICS
X+ 
X  #include "termcap.h"
X  #include "wintty.h"
X  #include <ctype.h>
X***************
X*** 42,48 ****
X  	if(*str & 0x80) {
X  		/* kludge for the / command, the only time we ever want a */
X  		/* graphics character on the top line */
X! 		g_putch(*str++);
X  		ttyDisplay->curx++;
X  	}
X  	end_glyphout();	/* in case message printed during graphics output */
X--- 45,51 ----
X  	if(*str & 0x80) {
X  		/* kludge for the / command, the only time we ever want a */
X  		/* graphics character on the top line */
X! 		g_putch((int)*str++);
X  		ttyDisplay->curx++;
X  	}
X  	end_glyphout();	/* in case message printed during graphics output */
X***************
X*** 196,201 ****
X--- 199,207 ----
X      }
X      cw->curx = ttyDisplay->curx;
X      if(cw->curx == 0) cl_end();
X+ #if defined(NO_TERMS) && defined(MSDOS)
X+     if (c != '\n')
X+ #endif 
X      (void) putchar(c);
X  }
X  
X***************
X*** 339,343 ****
X--- 345,351 ----
X  }
X  
X  #endif /* OVL2 */
X+ 
X+ #endif /* TTY_GRAPHICS */
X  
X  /*topl.c*/
X*** /tmp/da13420	Tue Jun  1 17:54:13 1993
X--- win/tty/wintty.c	Fri May 28 11:32:20 1993
X***************
X*** 1,10 ****
X! /*	SCCS Id: @(#)wintty.c	3.1	93/02/21	*/
X  /* Copyright (c) David Cohrs, 1991				  */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X  #include "hack.h"
X! #include "termcap.h"
X  #include "wintty.h"
X  #if (defined(BSD) || defined(ULTRIX) || defined(AIX_31) || defined(_BULL_SOURCE)) && defined(CLIPPING)
X  #include <signal.h>
X  #endif
X--- 1,27 ----
X! /*	SCCS Id: @(#)wintty.c	3.1	93/05/26	*/
X  /* Copyright (c) David Cohrs, 1991				  */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X+ /*
X+  * Neither a standard out nor character-based control codes should be
X+  * part of the "tty look" windowing implementation.
X+  * h+ 930227
X+  */
X+ 
X  #include "hack.h"
X! 
X! #ifdef TTY_GRAPHICS
X! 
X! #ifdef MAC
X! # define MICRO /* The Mac is a MICRO only for this file, not in general! */
X! #endif
X! 
X! #ifndef NO_TERMS
X! # include "termcap.h"
X! #endif
X! 
X  #include "wintty.h"
X+ 
X  #if (defined(BSD) || defined(ULTRIX) || defined(AIX_31) || defined(_BULL_SOURCE)) && defined(CLIPPING)
X  #include <signal.h>
X  #endif
X***************
X*** 54,62 ****
X--- 71,85 ----
X  #endif /* COM_COMPL */
X      tty_number_pad,
X      tty_delay_output,
X+ #ifdef CHANGE_COLOR	/* the Mac uses a palette device */
X+     tty_change_color,
X+     tty_get_color_string,
X+ #endif
X+ 
X      /* other defs that really should go away (they're tty specific) */
X      tty_start_screen,
X      tty_end_screen,
X+     genl_outrip,
X  };
X  
X  static int maxwin = 0;			/* number of windows in use */
X***************
X*** 78,95 ****
X  static int clipx = 0, clipy = 0, clipxmax = 0, clipymax = 0;
X  #endif
X  
X! #ifdef ASCIIGRAPH
X  boolean GFlag = FALSE;
X  #endif
X  
X  #ifdef MICRO
X! #define getret() getreturn("to continue")
X  #else
X  static void NDECL(getret);
X  #endif
X  static void FDECL(dmore,(struct WinDesc *));
X- static char * FDECL(s_atr2str, (int));
X- static char * FDECL(e_atr2str, (int));
X  static const char * FDECL(compress_str, (const char *));
X  static void FDECL(tty_putsym, (winid, int, int, CHAR_P));
X  
X--- 101,117 ----
X  static int clipx = 0, clipy = 0, clipxmax = 0, clipymax = 0;
X  #endif
X  
X! #if defined(ASCIIGRAPH) && !defined(NO_TERMS)
X  boolean GFlag = FALSE;
X  #endif
X  
X  #ifdef MICRO
X! static char to_continue[] = "to continue";
X! #define getret() getreturn(to_continue)
X  #else
X  static void NDECL(getret);
X  #endif
X  static void FDECL(dmore,(struct WinDesc *));
X  static const char * FDECL(compress_str, (const char *));
X  static void FDECL(tty_putsym, (winid, int, int, CHAR_P));
X  
X***************
X*** 329,338 ****
X  				ct--;
X  #ifdef MICRO
X  # if defined(WIN32CON)
X! 				nttty_rubout();  /* \b is visible on NT */
X  # else
X  				msmsg("\b \b");
X! # endif 
X  #else
X  				(void) putchar('\b');
X  				(void) putchar(' ');
X--- 351,360 ----
X  				ct--;
X  #ifdef MICRO
X  # if defined(WIN32CON)
X! 				backsp();       /* \b is visible on NT */
X  # else
X  				msmsg("\b \b");
X! # endif
X  #else
X  				(void) putchar('\b');
X  				(void) putchar(' ');
X***************
X*** 689,701 ****
X  		if(cw->type == NHW_MENU) {
X  		    (void) putchar(' '); ++ttyDisplay->curx;
X  		}
X! 		if(attr)
X! 		    xputs(s_atr2str(attr));
X  		for(cp = &cw->data[i][1];
X  		    *cp && (int)++ttyDisplay->curx < (int) ttyDisplay->cols; )
X  			(void) putchar(*cp++);
X! 		if(attr)
X! 		    xputs(e_atr2str(attr));
X  	    }
X  	}
X  	if(i == cw->maxrow) {
X--- 711,725 ----
X  		if(cw->type == NHW_MENU) {
X  		    (void) putchar(' '); ++ttyDisplay->curx;
X  		}
X! 		term_start_attr(attr);
X  		for(cp = &cw->data[i][1];
X  		    *cp && (int)++ttyDisplay->curx < (int) ttyDisplay->cols; )
X+ #ifdef __SASC
X+ 			(void) fputchar(*cp++);
X+ #else
X  			(void) putchar(*cp++);
X! #endif
X! 		term_end_attr(attr);
X  	    }
X  	}
X  	if(i == cw->maxrow) {
X***************
X*** 837,856 ****
X      if(cw->type == NHW_MAP)
X  	end_glyphout();
X  
X      if(!ND && (cx != x || x <= 3)) { /* Extremely primitive */
X  	cmov(x, y); /* bunker!wtm */
X  	return;
X      }
X      if((cy -= y) < 0) cy = -cy;
X      if((cx -= x) < 0) cx = -cx;
X!     if(cy <= 3 && cx <= 3)
X  	nocmov(x, y);
X!     else if((x <= 3 && cy <= 3) || (!CM && x < cx)) {
X  	(void) putchar('\r');
X  	ttyDisplay->curx = 0;
X  	nocmov(x, y);
X!     } else if(!CM) {
X  	nocmov(x, y);
X      } else
X  	cmov(x, y);
X  
X--- 861,885 ----
X      if(cw->type == NHW_MAP)
X  	end_glyphout();
X  
X+ #ifndef NO_TERMS
X      if(!ND && (cx != x || x <= 3)) { /* Extremely primitive */
X  	cmov(x, y); /* bunker!wtm */
X  	return;
X      }
X+ #endif
X+ 
X      if((cy -= y) < 0) cy = -cy;
X      if((cx -= x) < 0) cx = -cx;
X!     if(cy <= 3 && cx <= 3) {
X  	nocmov(x, y);
X! #ifndef NO_TERMS
X!     } else if ((x <= 3 && cy <= 3) || (!CM && x < cx)) {
X  	(void) putchar('\r');
X  	ttyDisplay->curx = 0;
X  	nocmov(x, y);
X!     } else if (!CM) {
X  	nocmov(x, y);
X+ #endif
X      } else
X  	cmov(x, y);
X  
X***************
X*** 886,928 ****
X      }
X  }
X  
X- static char nulstr[] = "";
X  
X- static char *
X- s_atr2str(n)
X-     int n;
X- {
X-     switch(n) {
X-     case ATR_ULINE:
X- 	if(US) return US;
X-     case ATR_BOLD:
X-     case ATR_BLINK:
X-     case ATR_INVERSE:
X- 	return HI;
X-     }
X-     return nulstr;
X- }
X- 
X- static char *
X- e_atr2str(n)
X-     int n;
X- {
X-     switch(n) {
X-     case ATR_ULINE:
X- 	if(UE) return UE;
X-     case ATR_BOLD:
X-     case ATR_BLINK:
X-     case ATR_INVERSE:
X- 	return HE;
X-     }
X-     return nulstr;
X- }
X- 
X  static const char*
X  compress_str(str)
X  const char *str;
X  {
X!     	static char cbuf[BUFSZ];
X  	/* compress in case line too long */
X  	if((int)strlen(str) >= CO) {
X  		register const char *bp0 = str;
X--- 915,926 ----
X      }
X  }
X  
X  
X  static const char*
X  compress_str(str)
X  const char *str;
X  {
X! 	static char cbuf[BUFSZ];
X  	/* compress in case line too long */
X  	if((int)strlen(str) >= CO) {
X  		register const char *bp0 = str;
X***************
X*** 1005,1020 ****
X      case NHW_MAP:
X      case NHW_BASE:
X  	tty_curs(window, cw->curx+1, cw->cury);
X! 	if(attr)
X! 	    xputs(s_atr2str(attr));
X  	while(*str && (int) ttyDisplay->curx < (int) ttyDisplay->cols-1) {
X  	    (void) putchar(*str++);
X  	    ttyDisplay->curx++;
X  	}
X  	cw->curx = 0;
X  	cw->cury++;
X! 	if(attr)
X! 	    xputs(e_atr2str(attr));
X  	break;
X      case NHW_MENU:
X      case NHW_TEXT:
X--- 1003,1020 ----
X      case NHW_MAP:
X      case NHW_BASE:
X  	tty_curs(window, cw->curx+1, cw->cury);
X! 	term_start_attr(attr);
X  	while(*str && (int) ttyDisplay->curx < (int) ttyDisplay->cols-1) {
X+ #ifdef __SASC
X+ 	    (void) fputchar(*str++);
X+ #else
X  	    (void) putchar(*str++);
X+ #endif
X  	    ttyDisplay->curx++;
X  	}
X  	cw->curx = 0;
X  	cw->cury++;
X! 	term_end_attr(attr);
X  	break;
X      case NHW_MENU:
X      case NHW_TEXT:
X***************
X*** 1058,1064 ****
X  		cw->data[cw->cury-1][++i] = '\0';
X  		tty_putstr(window, attr, &str[i]);
X  	    }
X! 		
X  	}
X  	break;
X      }
X--- 1058,1064 ----
X  		cw->data[cw->cury-1][++i] = '\0';
X  		tty_putstr(window, attr, &str[i]);
X  	    }
X! 
X  	}
X  	break;
X      }
X***************
X*** 1097,1109 ****
X--- 1097,1118 ----
X      }
X  #else
X      {
X+ #ifdef MAC
X+ 	int fd;
X+ #else
X  	FILE *f;
X+ #endif
X  	char buf[BUFSZ];
X  	char *cr;
X  
X  	tty_clear_nhwindow(WIN_MESSAGE);
X+ #ifdef MAC
X+ 	fd = open(fname, O_RDONLY, TEXT_TYPE);
X+ 	if (fd < 0) {
X+ #else
X  	f = fopen_datafile(fname, "r");
X  	if (!f) {
X+ #endif
X  	    if(complain) {
X  		home();  tty_mark_synch();  tty_raw_print("");
X  		perror(fname);  tty_wait_synch();
X***************
X*** 1111,1123 ****
X  	    } else if(u.ux) docrt();
X  	} else {
X  	    winid datawin = tty_create_nhwindow(NHW_TEXT);
X! 	    if(complain && CD) {
X  		/* attempt to scroll text below map window if there's room */
X  		wins[datawin]->offy = wins[WIN_STATUS]->offy+3;
X  		if((int) wins[datawin]->offy + 12 > (int) ttyDisplay->rows)
X  		    wins[datawin]->offy = 0;
X  	    }
X  	    while (fgets(buf, BUFSZ, f)) {
X  		if ((cr = index(buf, '\n')) != 0) *cr = 0;
X  		if (index(buf, '\t') != 0) (void) tabexpand(buf);
X  		tty_putstr(datawin, 0, buf);
X--- 1120,1140 ----
X  	    } else if(u.ux) docrt();
X  	} else {
X  	    winid datawin = tty_create_nhwindow(NHW_TEXT);
X! 	    if(complain
X! #ifndef NO_TERMS
X! 		&& CD
X! #endif
X! 	    ) {
X  		/* attempt to scroll text below map window if there's room */
X  		wins[datawin]->offy = wins[WIN_STATUS]->offy+3;
X  		if((int) wins[datawin]->offy + 12 > (int) ttyDisplay->rows)
X  		    wins[datawin]->offy = 0;
X  	    }
X+ #ifdef MAC
X+ 	    while (macgets(fd, buf, BUFSZ)) {
X+ #else
X  	    while (fgets(buf, BUFSZ, f)) {
X+ #endif
X  		if ((cr = index(buf, '\n')) != 0) *cr = 0;
X  		if (index(buf, '\t') != 0) (void) tabexpand(buf);
X  		tty_putstr(datawin, 0, buf);
X***************
X*** 1126,1132 ****
X--- 1143,1153 ----
X  	    }
X  	    tty_display_nhwindow(datawin, FALSE);
X  	    tty_destroy_nhwindow(datawin);
X+ #ifdef MAC
X+ 	    (void) close(fd);
X+ #else
X  	    (void) fclose(f);
X+ #endif
X  	}
X      }
X  #endif /* DEF_PAGER */
X***************
X*** 1276,1282 ****
X  	tty_curs(BASE_WINDOW, xmin,y);	/* move cursor */
X  	cl_end();			/* clear to end of line */
X  #ifdef CLIPPING
X! 	if (y<(int) cw->offy || y+clipy > ROWNO) 
X  		continue; /* only refresh board */
X  	row_refresh(xmin+clipx-(int)cw->offx,COLNO-1,y+clipy-(int)cw->offy);
X  #else
X--- 1297,1303 ----
X  	tty_curs(BASE_WINDOW, xmin,y);	/* move cursor */
X  	cl_end();			/* clear to end of line */
X  #ifdef CLIPPING
X! 	if (y<(int) cw->offy || y+clipy > ROWNO)
X  		continue; /* only refresh board */
X  	row_refresh(xmin+clipx-(int)cw->offx,COLNO-1,y+clipy-(int)cw->offy);
X  #else
X***************
X*** 1286,1292 ****
X      }
X  
X      end_glyphout();
X!     if (ymax >= (int) wins[WIN_STATUS]->offy) { 
X  					/* we have wrecked the bottom line */
X  	flags.botlx = 1;
X  	bot();
X--- 1307,1313 ----
X      }
X  
X      end_glyphout();
X!     if (ymax >= (int) wins[WIN_STATUS]->offy) {
X  					/* we have wrecked the bottom line */
X  	flags.botlx = 1;
X  	bot();
X***************
X*** 1296,1302 ****
X  void
X  end_glyphout()
X  {
X! #ifdef ASCIIGRAPH
X      if (GFlag) {
X  	GFlag = FALSE;
X  	graph_off();
X--- 1317,1323 ----
X  void
X  end_glyphout()
X  {
X! #if defined(ASCIIGRAPH) && !defined(NO_TERMS)
X      if (GFlag) {
X  	GFlag = FALSE;
X  	graph_off();
X***************
X*** 1304,1349 ****
X  #endif
X  #ifdef TEXTCOLOR
X      if(ttyDisplay->color != NO_COLOR) {
X! 	xputs(HE);
X  	ttyDisplay->color = NO_COLOR;
X      }
X  #endif
X  }
X  
X- #ifdef ASCIIGRAPH
X  void
X! g_putch(ch)
X!     uchar ch;
X  {
X      if (flags.IBMgraphics)
X  	/* IBM-compatible displays don't need other stuff */
X! 	(void) putchar((char) ch);
X      else if (ch & 0x80) {
X  	if (!GFlag) {
X  	    graph_on();
X  	    GFlag = TRUE;
X  	}
X! 	(void) putchar((char) (ch ^ 0x80)); /* Strip 8th bit */
X      } else {
X  	if (GFlag) {
X  	    graph_off();
X  	    GFlag = FALSE;
X  	}
X! 	(void) putchar((char) ch);
X      }
X- }
X  
X  #else
X  
X! void
X! g_putch(ch)
X!     uchar ch;
X! {
X!     (void) putchar((char)(ch));
X  };
X  
X- #endif	/* ASCIIGRAPH */
X- 
X  #ifdef CLIPPING
X  void
X  setclipped()
X--- 1325,1368 ----
X  #endif
X  #ifdef TEXTCOLOR
X      if(ttyDisplay->color != NO_COLOR) {
X! 	term_end_color();
X  	ttyDisplay->color = NO_COLOR;
X      }
X  #endif
X  }
X  
X  void
X! g_putch(in_ch)
X! int in_ch;
X  {
X+     register char ch = (char)in_ch;
X+ 
X+ # if defined(ASCIIGRAPH) && !defined(NO_TERMS)
X      if (flags.IBMgraphics)
X  	/* IBM-compatible displays don't need other stuff */
X! 	(void) putchar(ch);
X      else if (ch & 0x80) {
X  	if (!GFlag) {
X  	    graph_on();
X  	    GFlag = TRUE;
X  	}
X! 	(void) putchar((ch ^ 0x80)); /* Strip 8th bit */
X      } else {
X  	if (GFlag) {
X  	    graph_off();
X  	    GFlag = FALSE;
X  	}
X! 	(void) putchar(ch);
X      }
X  
X  #else
X+     (void) putchar(ch);
X  
X! #endif	/* ASCIIGRAPH && !NO_TERMS */
X! 
X!     return;
X  };
X  
X  #ifdef CLIPPING
X  void
X  setclipped()
X***************
X*** 1407,1413 ****
X  #define cmap_color(n) color = flags.use_color ? defsyms[n].color : NO_COLOR
X  #define trap_color(n) color = flags.use_color ? \
X  				(((n) == WEB) ? defsyms[S_web ].color  : \
X! 					        defsyms[S_trap].color) : \
X  						NO_COLOR
X  #define obj_color(n)  color = flags.use_color ? objects[n].oc_color : NO_COLOR
X  #define mon_color(n)  color = flags.use_color ? mons[n].mcolor : NO_COLOR
X--- 1426,1432 ----
X  #define cmap_color(n) color = flags.use_color ? defsyms[n].color : NO_COLOR
X  #define trap_color(n) color = flags.use_color ? \
X  				(((n) == WEB) ? defsyms[S_web ].color  : \
X! 						defsyms[S_trap].color) : \
X  						NO_COLOR
X  #define obj_color(n)  color = flags.use_color ? objects[n].oc_color : NO_COLOR
X  #define mon_color(n)  color = flags.use_color ? mons[n].mcolor : NO_COLOR
X***************
X*** 1414,1421 ****
X  #define pet_color(n)  color = flags.use_color ? mons[n].mcolor :	      \
X  				/* If no color, try to hilite pets; black  */ \
X  				/* should be HI				   */ \
X!     				((flags.hilite_pet && hilites[BLACK]) ?	      \
X  							BLACK : NO_COLOR)
X  # else /* no text color */
X  
X  #define zap_color(n)
X--- 1433,1441 ----
X  #define pet_color(n)  color = flags.use_color ? mons[n].mcolor :	      \
X  				/* If no color, try to hilite pets; black  */ \
X  				/* should be HI				   */ \
X! 				((flags.hilite_pet && has_color(BLACK)) ?     \
X  							BLACK : NO_COLOR)
X+ 
X  # else /* no text color */
X  
X  #define zap_color(n)
X***************
X*** 1453,1468 ****
X  	ch = (offset == WEB) ? showsyms[S_web] : showsyms[S_trap];
X  	trap_color(offset);
X      } else if ((offset = (glyph - GLYPH_OBJ_OFF)) >= 0) {	/* object */
X! 	ch = oc_syms[objects[offset].oc_class];
X  	obj_color(offset);
X      } else if ((offset = (glyph - GLYPH_BODY_OFF)) >= 0) {	/* a corpse */
X! 	ch = oc_syms[objects[CORPSE].oc_class];
X  	mon_color(offset);
X      } else if ((offset = (glyph - GLYPH_PET_OFF)) >= 0) {	/* a pet */
X! 	ch = monsyms[mons[offset].mlet];
X  	pet_color(offset);
X      } else {							/* a monster */
X! 	ch = monsyms[mons[glyph].mlet];
X  	mon_color(glyph);
X      }
X  
X--- 1473,1488 ----
X  	ch = (offset == WEB) ? showsyms[S_web] : showsyms[S_trap];
X  	trap_color(offset);
X      } else if ((offset = (glyph - GLYPH_OBJ_OFF)) >= 0) {	/* object */
X! 	ch = oc_syms[(int)objects[offset].oc_class];
X  	obj_color(offset);
X      } else if ((offset = (glyph - GLYPH_BODY_OFF)) >= 0) {	/* a corpse */
X! 	ch = oc_syms[(int)objects[CORPSE].oc_class];
X  	mon_color(offset);
X      } else if ((offset = (glyph - GLYPH_PET_OFF)) >= 0) {	/* a pet */
X! 	ch = monsyms[(int)mons[offset].mlet];
X  	pet_color(offset);
X      } else {							/* a monster */
X! 	ch = monsyms[(int)mons[glyph].mlet];
X  	mon_color(glyph);
X      }
X  
X***************
X*** 1469,1497 ****
X      /* Move the cursor. */
X      tty_curs(window, x,y);
X  
X      if (ul_hack && ch == '_') {		/* non-destructive underscore */
X  	(void) putchar((char) ' ');
X  	backsp();
X      }
X  
X  #ifdef TEXTCOLOR
X      /* Turn off color if no color defined, or rogue level. */
X  #  ifdef REINCARNATION
X!     if (hilites[color] == NULL || Is_rogue_level(&u.uz))
X  #  else
X!     if (hilites[color] == NULL)
X  #  endif
X  	color = NO_COLOR;
X  
X      if (color != ttyDisplay->color) {
X  	if(ttyDisplay->color != NO_COLOR)
X! 	    xputs(HE);
X  	ttyDisplay->color = color;
X  	if(color != NO_COLOR)
X! 	    xputs(hilites[color]);
X      }
X  #endif
X!     g_putch(ch);		/* print the character */
X      wins[window]->curx++;	/* one character over */
X      ttyDisplay->curx++;		/* the real cursor moved too */
X  }
X--- 1489,1519 ----
X      /* Move the cursor. */
X      tty_curs(window, x,y);
X  
X+ #ifndef NO_TERMS
X      if (ul_hack && ch == '_') {		/* non-destructive underscore */
X  	(void) putchar((char) ' ');
X  	backsp();
X      }
X+ #endif
X  
X  #ifdef TEXTCOLOR
X      /* Turn off color if no color defined, or rogue level. */
X  #  ifdef REINCARNATION
X!     if (!has_color(color) || Is_rogue_level(&u.uz))
X  #  else
X!     if (!has_color(color))
X  #  endif
X  	color = NO_COLOR;
X  
X      if (color != ttyDisplay->color) {
X  	if(ttyDisplay->color != NO_COLOR)
X! 	    term_end_color();
X  	ttyDisplay->color = color;
X  	if(color != NO_COLOR)
X! 	    term_start_color(color);
X      }
X  #endif
X!     g_putch((int)ch);		/* print the character */
X      wins[window]->curx++;	/* one character over */
X      ttyDisplay->curx++;		/* the real cursor moved too */
X  }
X***************
X*** 1513,1525 ****
X      const char *str;
X  {
X      if(ttyDisplay) ttyDisplay->rawprint++;
X!     xputs(HI);
X  #ifdef MICRO
X      msmsg("%s", str);
X  #else
X      (void) fputs(str, stdout);
X  #endif
X!     xputs(HE);
X  #ifdef MICRO
X      msmsg("\n");
X  #else
X--- 1535,1547 ----
X      const char *str;
X  {
X      if(ttyDisplay) ttyDisplay->rawprint++;
X!     term_start_raw_bold();
X  #ifdef MICRO
X      msmsg("%s", str);
X  #else
X      (void) fputs(str, stdout);
X  #endif
X!     term_end_raw_bold();
X  #ifdef MICRO
X      msmsg("\n");
X  #else
X***************
X*** 1586,1589 ****
X--- 1608,1612 ----
X      return;
X  }
X  
X+ #endif /* TTY_GRAPHICS */
X  /*wintty.c*/
X*** /tmp/da12240	Tue Jun  1 17:23:04 1993
X--- sys/atari/atari.cnf	Wed Mar 17 16:46:25 1993
X***************
X*** 25,31 ****
X  # Other general options.  You might also set "silent" so as not to attract
X  # the boss's attention.
X  #
X! OPTIONS=BIOS,time,rest_on_space,nopickup
X  
X  # Color: if you have a color monitor and *don't* want colors, 
X  # comment out the following line. (Mono users don't get color no matter what.)
X--- 25,31 ----
X  # Other general options.  You might also set "silent" so as not to attract
X  # the boss's attention.
X  #
X! OPTIONS=BIOS,time,rest_on_space,noautopickup
X  
X  # Color: if you have a color monitor and *don't* want colors, 
X  # comment out the following line. (Mono users don't get color no matter what.)
X*** /tmp/da12692	Tue Jun  1 17:32:22 1993
X--- sys/share/sounds/README	Tue Jun  1 10:50:48 1993
X***************
X*** 1,7 ****
X  README for the AIFF files:
X  
X  These files are sound files for the instruments in NetHack.
X! There are 12 sounds, one for each distinct instrument.
X  The sounds are in 8-bit 22kHz AIFF format, which should be
X  readable by a broad range of platforms. Since the sounds
X  came from Rolands S-750 sample library (most of them) there
X--- 1,7 ----
X  README for the AIFF files:
X  
X  These files are sound files for the instruments in NetHack.
X! There are 11 sounds, one for each distinct instrument.
X  The sounds are in 8-bit 22kHz AIFF format, which should be
X  readable by a broad range of platforms. Since the sounds
X  came from Rolands S-750 sample library (most of them) there
END_OF_FILE
if test 52637 -ne `wc -c <'patches02j'`; then
    echo shar: \"'patches02j'\" unpacked with wrong size!
fi
# end of 'patches02j'
echo shar: End of archive 19 \(of 33\).
cp /dev/null ark19isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 33 archives.
    echo "Now execute ./patchit.sh"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
