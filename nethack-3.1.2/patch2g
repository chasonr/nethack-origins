Path: uunet!news.tek.com!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v17i082:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Patch2g/33
Date: 11 Jun 1993 00:07:56 GMT
Organization: Tektronix, Inc, Redmond, OR, USA
Lines: 2212
Approved: billr@saab.CNA.TEK.COM
Message-ID: <1v8ics$irk@ying.cna.tek.com>
NNTP-Posting-Host: saab.cna.tek.com
Xref: uunet comp.sources.games:1770

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 17, Issue 82
Archive-name: nethack31/Patch2g
Patch-To: nethack31: Volume 16, Issue 1-116
Environment: Amiga, Atari, Mac, MS-DOS, Windows-NT, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 7 (of 33)."
# Contents:  patches02b patchit.sh sys/amiga/colors.uu
# Wrapped by billr@saab on Thu Jun 10 16:55:01 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'patches02b' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'patches02b'\" to \"'patches02b.orig'\"
  mv -f 'patches02b' 'patches02b.orig'
fi
echo shar: Extracting \"'patches02b'\" \(55636 characters\)
sed "s/^X//" >'patches02b' <<'END_OF_FILE'
X*** /tmp/da10810	Tue Jun  1 16:12:41 1993
X--- src/attrib.c	Tue Apr  6 15:58:07 1993
X***************
X*** 469,474 ****
X--- 469,481 ----
X  	}
X  }
X  
X+ /* next_check will otherwise have its initial 600L after a game restore */
X+ void
X+ reset_attribute_clock()
X+ {
X+ 	if (moves > 600L) next_check = moves + rn1(50,800);
X+ }
X+ 
X  static const struct	clattr *
X  clx()  {
X  
X***************
X*** 677,683 ****
X--- 684,694 ----
X  
X  	if (x == A_STR) {
X  		if (uarmg && uarmg->otyp == GAUNTLETS_OF_POWER) return(125);
X+ #ifdef WIN32_BUG
X+ 		else return(x=((tmp >= 125) ? 125 : (tmp <= 3) ? 3 : tmp));
X+ #else
X  		else return((tmp >= 125) ? 125 : (tmp <= 3) ? 3 : tmp);
X+ #endif
X  	} 
X  #ifdef POLYSELF
X  	else if(x == A_CHA) {
X***************
X*** 686,692 ****
X--- 697,707 ----
X  		    return 18;
X  	}
X  #endif
X+ #ifdef WIN32_BUG
X+ 	return(x=((tmp >= 25) ? 25 : (tmp <= 3) ? 3 : tmp));
X+ #else
X  	return((tmp >= 25) ? 25 : (tmp <= 3) ? 3 : tmp);
X+ #endif
X  }
X  
X  schar
X*** /tmp/da10826	Tue Jun  1 16:12:47 1993
X--- src/bones.c	Mon May 24 12:00:16 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)bones.c	3.1	93/01/07	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985,1993. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)bones.c	3.1	93/05/22	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985,1993. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 83,118 ****
X  			otmp->invlet = 0;
X  #ifdef TUTTI_FRUTTI
X  			if(otmp->otyp == SLIME_MOLD) goodfruit(otmp->spe);
X  #endif
X  #ifdef MAIL
X  			if (otmp->otyp == SCR_MAIL) otmp->spe = 1;
X  #endif
X  #ifdef POLYSELF
X  			if (otmp->otyp == EGG) otmp->spe = 0;
X  #endif
X! 			if(otmp->otyp == AMULET_OF_YENDOR) {
X! 				/* no longer the actual amulet */
X! 				otmp->otyp = FAKE_AMULET_OF_YENDOR;
X! 				curse(otmp);
X! 			}
X! 			if(otmp->otyp == CANDELABRUM_OF_INVOCATION) {
X! 			    if(otmp->spe > 0) { /* leave candles, if any */
X! 			        otmp->otyp = WAX_CANDLE;
X! 				otmp->age = 50L;  /* assume used */
X  				otmp->quan = (long)otmp->spe;
X! 				otmp->lamplit = 0;
X! 				otmp->spe = 0;
X! 			    } else obfree(otmp, (struct obj *)0);
X! 			}
X! 			if(otmp->otyp == BELL_OF_OPENING) otmp->otyp = BELL;
X! 			if(otmp->otyp == SPE_BOOK_OF_THE_DEAD) {
X! 			    otmp->otyp = SPE_MAGIC_MISSILE +
X! 			                    rn2(SPE_BLANK_PAPER -
X! 						  SPE_MAGIC_MISSILE + 1);
X  			    curse(otmp);
X  			}
X  		}
X! 	}			
X  }
X  
X  static void
X--- 83,129 ----
X  			otmp->invlet = 0;
X  #ifdef TUTTI_FRUTTI
X  			if(otmp->otyp == SLIME_MOLD) goodfruit(otmp->spe);
X+ 			else
X  #endif
X  #ifdef MAIL
X  			if (otmp->otyp == SCR_MAIL) otmp->spe = 1;
X+ 			else
X  #endif
X  #ifdef POLYSELF
X  			if (otmp->otyp == EGG) otmp->spe = 0;
X+ 			else
X  #endif
X! 			if (otmp->otyp == AMULET_OF_YENDOR) {
X! 			    /* no longer the real Amulet */
X! 			    otmp->otyp = FAKE_AMULET_OF_YENDOR;
X! 			    curse(otmp);
X! 			} else if (otmp->otyp == CANDELABRUM_OF_INVOCATION) {
X! 			    otmp->otyp = WAX_CANDLE;
X! 			    otmp->age = 50L;  /* assume used */
X! 			    if (otmp->spe > 0)
X  				otmp->quan = (long)otmp->spe;
X! 			    otmp->lamplit = 0;
X! 			    otmp->spe = 0;
X! 			    otmp->owt = weight(otmp);
X! 			} else if (otmp->otyp == BELL_OF_OPENING) {
X! 			    otmp->otyp = BELL;
X  			    curse(otmp);
X+ 			} else if (otmp->otyp == SPE_BOOK_OF_THE_DEAD) {
X+ 			    otmp->otyp = SPE_BLANK_PAPER;
X+ 			    curse(otmp);
X+ #ifdef MULDGN
X+ 			} else if (is_quest_artifact(otmp)) {
X+ 			    /*
X+ 			     * never leave our own quest artifact among the
X+ 			     * bones; others (via wishing) might remain though
X+ 			     */
X+ 			 /* artifact_unexist(otmp); */
X+ 			    otmp->oartifact = 0;
X+ 			    ONAME(otmp)[0] = '\0';
X+ #endif
X  			}
X  		}
X! 	}
X  }
X  
X  static void
X***************
X*** 172,182 ****
X  	}
X  
X  	if(depth(&u.uz) <= 0 ||		/* bulletproofing for endgame */
X! 	   !rn2(1 + (depth(&u.uz)>>2)) /* fewer ghosts on low levels */
X  #ifdef WIZARD
X  		&& !wizard
X  #endif
X! 		) return;
X  #ifdef EXPLORE_MODE
X  	/* don't let multiple restarts generate multiple copies of objects
X  	 * in bones files */
X--- 183,193 ----
X  	}
X  
X  	if(depth(&u.uz) <= 0 ||		/* bulletproofing for endgame */
X! 	   (!rn2(1 + (depth(&u.uz)>>2)) /* fewer ghosts on low levels */
X  #ifdef WIZARD
X  		&& !wizard
X  #endif
X! 		)) return;
X  #ifdef EXPLORE_MODE
X  	/* don't let multiple restarts generate multiple copies of objects
X  	 * in bones files */
X***************
X*** 269,274 ****
X--- 280,286 ----
X  		ttmp->tseen = 0;
X  	}
X  	resetobjs(fobj,FALSE);
X+ 	resetobjs(level.buriedobjlist, FALSE);
X  
X  	/* Clear all memory from the level. */
X  	for(x=0; x<COLNO; x++) for(y=0; y<ROWNO; y++) {
X***************
X*** 369,374 ****
X--- 381,387 ----
X  			for(mtmp = fmon; mtmp; mtmp = mtmp->nmon)
X  				resetobjs(mtmp->minvent,TRUE);
X  			resetobjs(fobj,TRUE);
X+ 			resetobjs(level.buriedobjlist,TRUE);
X  		}
X  	}
X  	(void) close(fd);
X*** /tmp/da10834	Tue Jun  1 16:12:49 1993
X--- src/botl.c	Tue May 11 16:41:43 1993
X***************
X*** 20,28 ****
X  static void NDECL(bot2);
X  #endif /* OVL0 */
X  
X! /* 100 suffices for bot(); must be larger than COLNO */
X! #if COLNO <= 80
X! #define MAXCO 100
X  #else
X  #define MAXCO (COLNO+20)
X  #endif
X--- 20,35 ----
X  static void NDECL(bot2);
X  #endif /* OVL0 */
X  
X! /* MAXCO must hold longest uncompressed status line, and must be larger
X!  * than COLNO
X!  *
X!  * longest practical second status line at the moment is
X!  *	Astral Plane $:12345 HP:700(700) Pw:111(111) AC:-127 Xp:30/123456789
X!  *	T:123456 Satiated Conf Sick Blind Stun Hallu Overloaded
X!  * -- or somewhat over 120 characters
X!  */
X! #if COLNO <= 130
X! #define MAXCO 150
X  #else
X  #define MAXCO (COLNO+20)
X  #endif
X*** /tmp/da10842	Tue Jun  1 16:12:51 1993
X--- src/cmd.c	Thu May  6 11:31:50 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)cmd.c	3.1	93/02/16	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)cmd.c	3.1	93/04/24	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 339,348 ****
X  enter_explore_mode()
X  {
X  	if(!discover && !wizard) {
X! 		pline("Beware!  From discovery mode there will be no return to normal game.");
X! 		if (yn("Do you want to enter discovery mode?") == 'y') {
X  			clear_nhwindow(WIN_MESSAGE);
X! 			You("are now in non-scoring discovery mode.");
X  			discover = TRUE;
X  		}
X  		else {
X--- 339,348 ----
X  enter_explore_mode()
X  {
X  	if(!discover && !wizard) {
X! 		pline("Beware!  From explore mode there will be no return to normal game.");
X! 		if (yn("Do you want to enter explore mode?") == 'y') {
X  			clear_nhwindow(WIN_MESSAGE);
X! 			You("are now in non-scoring explore mode.");
X  			discover = TRUE;
X  		}
X  		else {
X***************
X*** 376,382 ****
X  	else {
X  		for (obj = invent; obj; obj = obj->nobj)
X  			if (!objects[obj->otyp].oc_name_known || !obj->known
X! 						|| !obj->dknown || !obj->bknown)
X  				(void) identify(obj);
X  	}
X  	return 0;
X--- 376,382 ----
X  	else {
X  		for (obj = invent; obj; obj = obj->nobj)
X  			if (!objects[obj->otyp].oc_name_known || !obj->known
X! 			    || !obj->dknown || !obj->bknown || !obj->rknown)
X  				(void) identify(obj);
X  	}
X  	return 0;
X***************
X*** 459,464 ****
X--- 459,475 ----
X  	putstr(en_win, 0, final ? "Final Attributes:" : "Current Attributes:");
X  	putstr(en_win, 0, "");
X  
X+ #ifdef ELBERETH
X+ 	if (u.uevent.uhand_of_elbereth) {
X+ 	    static const char *hofe_titles[3] = {
X+ 				"the Hand of Elbereth",
X+ 				"the Envoy of Balance",
X+ 				"the Glory of Arioch"
X+ 	    };
X+ 	    you_are(hofe_titles[u.uevent.uhand_of_elbereth - 1]);
X+ 	}
X+ #endif
X+ 
X  	/* note: piousness 20 matches MIN_QUEST_ALIGN (quest.h) */
X  	if (u.ualign.record >= 20)	you_are("piously aligned");
X  	else if (u.ualign.record > 13)	you_are("devoutly aligned");
X***************
X*** 487,493 ****
X  	if (Fast) you_are((Fast & ~INTRINSIC) ? "very fast" : "fast");
X  	if (Stealth) you_are("stealthy");
X  	if (Regeneration) enl_msg("You regenerate", "", "d", "");
X! 	if (Hunger) you_have("hunger");
X  	if (Conflict) enl_msg("You cause", "", "d", " conflict");
X  	if (Aggravate_monster) enl_msg("You aggravate", "", "d", " monsters");
X  	if (Poison_resistance) you_are("poison resistant");
X--- 498,504 ----
X  	if (Fast) you_are((Fast & ~INTRINSIC) ? "very fast" : "fast");
X  	if (Stealth) you_are("stealthy");
X  	if (Regeneration) enl_msg("You regenerate", "", "d", "");
X! 	if (Hunger) enl_msg("You hunger", "", "ed", " rapidly");
X  	if (Conflict) enl_msg("You cause", "", "d", " conflict");
X  	if (Aggravate_monster) enl_msg("You aggravate", "", "d", " monsters");
X  	if (Poison_resistance) you_are("poison resistant");
X***************
X*** 528,537 ****
X  	if (Protection) you_are("protected");
X  	if (Reflecting) you_have("reflection");
X  	if (Levitation) you_are("levitating");
X  	if (Fumbling) enl_msg("You fumble", "", "d", "");
X  	if (Jumping) you_can("jump");
X  	if (Wwalking) you_can("walk on water");
X! 	if (Magical_breathing) you_can("survive without air");
X  	if (Antimagic) you_are("magic-protected");
X  	if (Displaced) you_are("displaced");
X  	if (Clairvoyant) you_are("clairvoyant");
X--- 539,555 ----
X  	if (Protection) you_are("protected");
X  	if (Reflecting) you_have("reflection");
X  	if (Levitation) you_are("levitating");
X+ #ifdef POLYSELF
X+ 	else if (is_flyer(uasmon)) you_can("fly");
X+ #endif
X  	if (Fumbling) enl_msg("You fumble", "", "d", "");
X  	if (Jumping) you_can("jump");
X  	if (Wwalking) you_can("walk on water");
X! #ifdef POLYSELF
X! 	if (passes_walls(uasmon)) you_can("walk through walls");
X! #endif
X! 	if (Breathless) you_can("survive without air");
X! 	else if (Amphibious) you_can("breathe water");
X  	if (Antimagic) you_are("magic-protected");
X  	if (Displaced) you_are("displaced");
X  	if (Clairvoyant) you_are("clairvoyant");
X***************
X*** 738,746 ****
X  	{"untrap", "untrap something", dountrap},
X  	{"version", "list compile time options for this version of NetHack",
X  		doextversion},
X- #ifdef MAC
X- 	{"window", "clean up windows", SanePositions},
X- #endif
X  	{"wipe", "wipe off your face", dowipe},
X  	{"?", "get this list of extended commands", doextlist},
X  	{NULL, NULL, donull}
X--- 756,761 ----
X*** /tmp/da10850	Tue Jun  1 16:12:54 1993
X--- src/dbridge.c	Mon May 17 14:04:09 1993
X***************
X*** 1,5 ****
X! /*	SCCS Id: @(#)dbridge.c	3.1	92/10/24	*/
X! /*	Copyright (c) 1989 by Jean-Christophe Collet */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X  /*
X--- 1,5 ----
X! /*	SCCS Id: @(#)dbridge.c	3.1	93/05/15	*/
X! /*	Copyright (c) 1989 by Jean-Christophe Collet		  */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X  /*
X***************
X*** 18,28 ****
X  static void FDECL(m_to_e, (struct monst *, XCHAR_P, XCHAR_P, struct entity *));
X  static void FDECL(u_to_e, (struct entity *));
X  static void FDECL(set_entity, (int, int, struct entity *));
X! static char *FDECL(e_nam, (struct entity *));
X  #ifdef D_DEBUG
X! static char *FDECL(Enam, (struct entity *)); /* unused */
X  #endif
X! static char *FDECL(E_phrase, (struct entity *, const char *));
X  static boolean FDECL(e_survives_at, (struct entity *, int, int));
X  static void FDECL(e_died, (struct entity *, int, int));
X  static boolean FDECL(automiss, (struct entity *));
X--- 18,28 ----
X  static void FDECL(m_to_e, (struct monst *, XCHAR_P, XCHAR_P, struct entity *));
X  static void FDECL(u_to_e, (struct entity *));
X  static void FDECL(set_entity, (int, int, struct entity *));
X! static const char *FDECL(e_nam, (struct entity *));
X  #ifdef D_DEBUG
X! static const char *FDECL(Enam, (struct entity *)); /* unused */
X  #endif
X! static const char *FDECL(E_phrase, (struct entity *, const char *));
X  static boolean FDECL(e_survives_at, (struct entity *, int, int));
X  static void FDECL(e_died, (struct entity *, int, int));
X  static boolean FDECL(automiss, (struct entity *));
X***************
X*** 297,303 ****
X  
X  /* #define e_strg(etmp, func) (is_u(etmp)? (char *)0 : func(etmp->emon)) */
X  
X! static char *
X  e_nam(etmp)
X  struct entity *etmp;
X  {
X--- 297,303 ----
X  
X  /* #define e_strg(etmp, func) (is_u(etmp)? (char *)0 : func(etmp->emon)) */
X  
X! static const char *
X  e_nam(etmp)
X  struct entity *etmp;
X  {
X***************
X*** 309,315 ****
X   * Enam is another unused utility routine:  E_phrase is preferable.
X   */
X  
X! static char *
X  Enam(etmp)
X  struct entity *etmp;
X  {
X--- 309,315 ----
X   * Enam is another unused utility routine:  E_phrase is preferable.
X   */
X  
X! static const char *
X  Enam(etmp)
X  struct entity *etmp;
X  {
X***************
X*** 322,328 ****
X   * verb, where necessary.
X   */
X  
X! static char *
X  E_phrase(etmp, verb)
X  struct entity *etmp;
X  const char *verb;
X--- 322,328 ----
X   * verb, where necessary.
X   */
X  
X! static const char *
X  E_phrase(etmp, verb)
X  struct entity *etmp;
X  const char *verb;
X***************
X*** 379,385 ****
X  	if (noncorporeal(etmp->edata))
X  		return(TRUE);
X  	if (is_pool(x, y))
X! 		return((is_u(etmp) && (Wwalking || Magical_breathing || Levitation)) ||
X  		       is_swimmer(etmp->edata) || is_flyer(etmp->edata) ||
X  		       is_floater(etmp->edata));
X  	/* must force call to lava_effects in e_died if is_u */
X--- 379,385 ----
X  	if (noncorporeal(etmp->edata))
X  		return(TRUE);
X  	if (is_pool(x, y))
X! 		return((is_u(etmp) && (Wwalking || Amphibious || Levitation)) ||
X  		       is_swimmer(etmp->edata) || is_flyer(etmp->edata) ||
X  		       is_floater(etmp->edata));
X  	/* must force call to lava_effects in e_died if is_u */
X***************
X*** 539,549 ****
X  		    	    (crm->typ == DRAWBRIDGE_UP))
X  				Strcpy(edifice, "drawbridge");
X  			else
X!      				if (at_portcullis) 
X  					Strcpy(edifice, "portcullis");
X  			if (*edifice)
X  				pline("The %s passes through %s!", edifice, 
X! 			      	      e_nam(etmp));			
X  		}
X  		return;
X  	}
X--- 539,549 ----
X  		    	    (crm->typ == DRAWBRIDGE_UP))
X  				Strcpy(edifice, "drawbridge");
X  			else
X! 				if (at_portcullis) 
X  					Strcpy(edifice, "portcullis");
X  			if (*edifice)
X  				pline("The %s passes through %s!", edifice, 
X! 				      e_nam(etmp));
X  		}
X  		return;
X  	}
X***************
X*** 570,579 ****
X  	} else {
X  		if (crm->typ == DRAWBRIDGE_DOWN) {
X  			pline("%s crushed underneath the drawbridge.",
X! 		      	      E_phrase(etmp, "are"));	   	  /* no jump */
X  			e_died(etmp, e_inview? 3 : 2, CRUSHING);/* no corpse */
X  			return;   /* Note: Beyond this point, we know we're  */
X! 		}                 /* not at an opened drawbridge, since all  */
X  		must_jump = TRUE; /* *missable* creatures survive on the     */
X  	}			  /* square, and all the unmissed ones die.  */
X  	if (must_jump) {
X--- 570,579 ----
X  	} else {
X  		if (crm->typ == DRAWBRIDGE_DOWN) {
X  			pline("%s crushed underneath the drawbridge.",
X! 			      E_phrase(etmp, "are"));		  /* no jump */
X  			e_died(etmp, e_inview? 3 : 2, CRUSHING);/* no corpse */
X  			return;   /* Note: Beyond this point, we know we're  */
X! 		}		  /* not at an opened drawbridge, since all  */
X  		must_jump = TRUE; /* *missable* creatures survive on the     */
X  	}			  /* square, and all the unmissed ones die.  */
X  	if (must_jump) {
X***************
X*** 691,697 ****
X  					pline("The drawbridge closes in...");
X  			} else
X  				pline("%s behind the drawbridge.",
X! 		      	      	      E_phrase(etmp, "disappear"));
X  		}
X  		if (!e_survives_at(etmp, etmp->ex, etmp->ey)) {
X  			killer_format = KILLED_BY_AN;
X--- 691,697 ----
X  					pline("The drawbridge closes in...");
X  			} else
X  				pline("%s behind the drawbridge.",
X! 				      E_phrase(etmp, "disappear"));
X  		}
X  		if (!e_survives_at(etmp, etmp->ex, etmp->ey)) {
X  			killer_format = KILLED_BY_AN;
X***************
X*** 713,720 ****
X  			if (e_inview && !is_flyer(etmp->edata) &&
X  			    !is_floater(etmp->edata))
X  				pline("%s from the bridge.",
X! 		      	      	      E_phrase(etmp, "fall"));	
X! 			return;	
X  		}
X  #ifdef D_DEBUG
X  		pline("%s cannot survive on the drawbridge square",Enam(etmp));
X--- 713,720 ----
X  			if (e_inview && !is_flyer(etmp->edata) &&
X  			    !is_floater(etmp->edata))
X  				pline("%s from the bridge.",
X! 				      E_phrase(etmp, "fall"));
X! 			return;
X  		}
X  #ifdef D_DEBUG
X  		pline("%s cannot survive on the drawbridge square",Enam(etmp));
X***************
X*** 865,871 ****
X  		}
X  		lev1->typ = lava ? LAVAPOOL : MOAT;
X  		lev1->drawbridgemask = 0;
X! 		if(otmp = sobj_at(BOULDER,x,y)) {
X  		    freeobj(otmp);
X  		    (void) flooreffects(otmp,x,y,"fall");
X  		}
X--- 865,871 ----
X  		}
X  		lev1->typ = lava ? LAVAPOOL : MOAT;
X  		lev1->drawbridgemask = 0;
X! 		if ((otmp = sobj_at(BOULDER,x,y)) != 0) {
X  		    freeobj(otmp);
X  		    (void) flooreffects(otmp,x,y,"fall");
X  		}
X***************
X*** 893,899 ****
X  		if (!automiss(etmp2)) {
X  			if (e_inview)
X  				pline("%s blown apart by flying debris.",
X! 			      	      E_phrase(etmp2, "are"));
X  			killer_format = KILLED_BY_AN;
X  			killer = "exploding drawbridge";
X  			e_died(etmp2, e_inview? 3 : 2, CRUSHING); /*no corpse*/
X--- 893,899 ----
X  		if (!automiss(etmp2)) {
X  			if (e_inview)
X  				pline("%s blown apart by flying debris.",
X! 				      E_phrase(etmp2, "are"));
X  			killer_format = KILLED_BY_AN;
X  			killer = "exploding drawbridge";
X  			e_died(etmp2, e_inview? 3 : 2, CRUSHING); /*no corpse*/
X*** /tmp/da10858	Tue Jun  1 16:12:57 1993
X--- src/decl.c	Fri Mar 19 17:37:20 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)decl.c	3.1	92/12/11	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)decl.c	3.1	93/03/18	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 165,171 ****
X      WHITE,		/* 2 - frost */
X      HI_ZAP,		/* 3 - sleep */
X      BLACK,		/* 4 - death */
X!     HI_ZAP,		/* 5 - lightning */
X      YELLOW,		/* 6 - poison gas */
X      GREEN,		/* 7 - acid */
X  };
X--- 165,171 ----
X      WHITE,		/* 2 - frost */
X      HI_ZAP,		/* 3 - sleep */
X      BLACK,		/* 4 - death */
X!     WHITE,		/* 5 - lightning */
X      YELLOW,		/* 6 - poison gas */
X      GREEN,		/* 7 - acid */
X  };
X*** /tmp/da10866	Tue Jun  1 16:12:59 1993
X--- src/detect.c	Fri Apr 23 12:21:05 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)detect.c	3.1	92/12/16	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)detect.c	3.1	93/03/30	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 30,39 ****
X  
X      if (obj->oclass == oclass) return obj;
X  
X!     if (Is_container(obj)) {
X  	for (otmp = obj->cobj; otmp; otmp = otmp->nobj)
X  	    if (otmp->oclass == oclass) return otmp;
X! 	    else if (Is_container(otmp) && (temp = o_in(otmp, oclass)))
X  		return temp;
X      }
X      return (struct obj *) 0;
X--- 30,39 ----
X  
X      if (obj->oclass == oclass) return obj;
X  
X!     if (Has_contents(obj)) {
X  	for (otmp = obj->cobj; otmp; otmp = otmp->nobj)
X  	    if (otmp->oclass == oclass) return otmp;
X! 	    else if (Has_contents(otmp) && (temp = o_in(otmp, oclass)))
X  		return temp;
X      }
X      return (struct obj *) 0;
X***************
X*** 209,215 ****
X  	known = stale && !confused;
X  	if (stale) {
X  	    docrt();
X! 	    You("sense lack of %s nearby.", what);
X  	} else if (sobj)
X  	    strange_feeling(sobj, "Your nose twitches.");
X  	return !stale;
X--- 209,215 ----
X  	known = stale && !confused;
X  	if (stale) {
X  	    docrt();
X! 	    You("sense a lack of %s nearby.", what);
X  	} else if (sobj)
X  	    strange_feeling(sobj, "Your nose twitches.");
X  	return !stale;
X***************
X*** 605,610 ****
X--- 605,611 ----
X  	    break;
X  	}
X  	obj->spe--;
X+ 	check_unpaid(obj);
X  	return;
X      }
X  
X***************
X*** 628,633 ****
X--- 629,635 ----
X  		break;
X  	    }
X  	    obj->spe--;
X+ 	    check_unpaid(obj);
X  	}
X  	return;
X      }
X***************
X*** 650,655 ****
X--- 652,658 ----
X  
X  	makeknown(CRYSTAL_BALL);
X  	obj->spe--;
X+ 	check_unpaid(obj);
X  
X  	if ((class = def_char_to_objclass(ch)) != MAXOCLASSES)
X  		ret = object_detect((struct obj *)0, class);
X***************
X*** 807,813 ****
X  		if(levl[zx][zy].typ == SDOOR)
X  		    levl[zx][zy].typ = DOOR;
X  		if(levl[zx][zy].doormask & D_TRAPPED) {
X! 		    if(distu(zx, zy) < 3) b_trapped("door");
X  		    else Norep("You %s an explosion!",
X  				cansee(zx, zy) ? "see" :
X  				   (flags.soundok ? "hear" :
X--- 810,816 ----
X  		if(levl[zx][zy].typ == SDOOR)
X  		    levl[zx][zy].typ = DOOR;
X  		if(levl[zx][zy].doormask & D_TRAPPED) {
X! 		    if(distu(zx, zy) < 3) b_trapped("door", 0);
X  		    else Norep("You %s an explosion!",
X  				cansee(zx, zy) ? "see" :
X  				   (flags.soundok ? "hear" :
X*** /tmp/da10874	Tue Jun  1 16:13:01 1993
X--- src/display.c	Tue Jun  1 12:12:43 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)display.c	3.1	92/10/25	*/
X  /* Copyright (c) Dean Luick, with acknowledgements to Kevin Darcy */
X  /* and Dave Cohrs, 1990.					  */
X  /* NetHack may be freely redistributed.  See license for details. */
X--- 1,4 ----
X! /*	SCCS Id: @(#)display.c	3.1	93/05/15	*/
X  /* Copyright (c) Dean Luick, with acknowledgements to Kevin Darcy */
X  /* and Dave Cohrs, 1990.					  */
X  /* NetHack may be freely redistributed.  See license for details. */
X***************
X*** 250,257 ****
X   *
X   * Make whatever at this location show up.  This is only for non-living
X   * things.  This will not handle feeling invisible objects correctly.
X   */
X! #define map_location(x,y,show)						\
X  {									\
X      register struct obj   *obj;						\
X      register struct trap  *trap;					\
X--- 250,259 ----
X   *
X   * Make whatever at this location show up.  This is only for non-living
X   * things.  This will not handle feeling invisible objects correctly.
X+  *
X+  * Internal to display.c, this is a #define for speed.
X   */
X! #define _map_location(x,y,show)						\
X  {									\
X      register struct obj   *obj;						\
X      register struct trap  *trap;					\
X***************
X*** 264,270 ****
X--- 266,278 ----
X  	map_background(x,y,show);					\
X  }
X  
X+ void map_location(x,y,show)
X+     int x, y, show;
X+ {
X+     _map_location(x,y,show);
X+ }
X  
X+ 
X  /*
X   * display_monster()
X   *
X***************
X*** 397,403 ****
X  	if (IS_ROCK(lev->typ) || (IS_DOOR(lev->typ) &&
X  				(lev->doormask & (D_LOCKED | D_CLOSED)))) {
X  	    map_background(x, y, 1);
X! 	} else if (boulder = sobj_at(BOULDER,x,y)) {
X  	    map_object(boulder, 1);
X  	} else if (IS_DOOR(lev->typ)) {
X  	    map_background(x, y, 1);
X--- 405,411 ----
X  	if (IS_ROCK(lev->typ) || (IS_DOOR(lev->typ) &&
X  				(lev->doormask & (D_LOCKED | D_CLOSED)))) {
X  	    map_background(x, y, 1);
X! 	} else if ((boulder = sobj_at(BOULDER,x,y)) != 0) {
X  	    map_object(boulder, 1);
X  	} else if (IS_DOOR(lev->typ)) {
X  	    map_background(x, y, 1);
X***************
X*** 438,444 ****
X  		show_glyph(x, y, lev->glyph = cmap_to_glyph(S_corr));
X  	}
X      } else {
X! 	map_location(x, y, 1);
X  
X  	if (Punished) {
X  	    /*
X--- 446,452 ----
X  		show_glyph(x, y, lev->glyph = cmap_to_glyph(S_corr));
X  	}
X      } else {
X! 	_map_location(x, y, 1);
X  
X  	if (Punished) {
X  	    /*
X***************
X*** 509,528 ****
X  
X  	if (x == u.ux && y == u.uy) {
X  	    if (canseeself()) {
X! 		map_location(x,y,0);	/* map *under* self */
X  		display_self();
X  	    } else
X  		/* we can see what is there */
X! 		map_location(x,y,1);
X  	}
X  	else if ((mon = m_at(x,y)) &&
X  		 ((see_it = mon_visible(mon)) || sensemon(mon))) {
X! 	    map_location(x,y,0); 	/* map under the monster */
X      	    worm_tail = ((x != mon->mx)  || (y != mon->my));
X  	    display_monster(x,y,mon,see_it,worm_tail);
X  	}
X  	else
X! 	    map_location(x,y,1);	/* map the location */
X      }
X  
X      /* Can't see the location. */
X--- 517,536 ----
X  
X  	if (x == u.ux && y == u.uy) {
X  	    if (canseeself()) {
X! 		_map_location(x,y,0);	/* map *under* self */
X  		display_self();
X  	    } else
X  		/* we can see what is there */
X! 		_map_location(x,y,1);
X  	}
X  	else if ((mon = m_at(x,y)) &&
X  		 ((see_it = mon_visible(mon)) || sensemon(mon))) {
X! 	    _map_location(x,y,0); 	/* map under the monster */
X      	    worm_tail = ((x != mon->mx)  || (y != mon->my));
X  	    display_monster(x,y,mon,see_it,worm_tail);
X  	}
X  	else
X! 	    _map_location(x,y,1);	/* map the location */
X      }
X  
X      /* Can't see the location. */
X*** /tmp/da10882	Tue Jun  1 16:13:04 1993
X--- src/do.c	Tue May 11 13:46:35 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)do.c	3.1	93/02/20	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)do.c	3.1	93/03/30	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 85,91 ****
X  		} else
X  		    levl[rx][ry].typ = ROOM;
X  
X! 		delallobj(rx, ry);
X  		newsym(rx,ry);
X  		if (pushing) {
X  		    You("push %s into the %s.", the(xname(otmp)), what);
X--- 85,91 ----
X  		} else
X  		    levl[rx][ry].typ = ROOM;
X  
X! 		bury_objs(rx, ry);
X  		newsym(rx,ry);
X  		if (pushing) {
X  		    You("push %s into the %s.", the(xname(otmp)), what);
X***************
X*** 153,159 ****
X  		 (t->ttyp==PIT || t->ttyp==SPIKED_PIT || t->ttyp==TRAPDOOR)) {
X  		struct monst *mtmp;
X  
X! 		delallobj(x, y);
X  		if(!Can_fall_thru(&u.uz) && t->ttyp == TRAPDOOR)
X  			return FALSE;
X  		if (((mtmp = m_at(x, y)) && mtmp->mtrapped) ||
X--- 153,159 ----
X  		 (t->ttyp==PIT || t->ttyp==SPIKED_PIT || t->ttyp==TRAPDOOR)) {
X  		struct monst *mtmp;
X  
X! 		bury_objs(x, y);
X  		if(!Can_fall_thru(&u.uz) && t->ttyp == TRAPDOOR)
X  			return FALSE;
X  		if (((mtmp = m_at(x, y)) && mtmp->mtrapped) ||
X***************
X*** 165,173 ****
X  		    if (mtmp) {
X  			if (!passes_walls(mtmp->data) && !throws_rocks(mtmp->data))
X  				if (hmon(mtmp, obj, TRUE))
X! 					return FALSE;	  /* still alive */
X  				else
X! 					delallobj(x, y);  /* treasure, corpse */
X  		    } else
X  #ifdef POLYSELF
X  			if (!passes_walls(uasmon) && !throws_rocks(uasmon))
X--- 165,173 ----
X  		    if (mtmp) {
X  			if (!passes_walls(mtmp->data) && !throws_rocks(mtmp->data))
X  				if (hmon(mtmp, obj, TRUE))
X! 				    return FALSE;	/* still alive */
X  				else
X! 				    bury_objs(x, y);	/* treasure, corpse */
X  		    } else
X  #ifdef POLYSELF
X  			if (!passes_walls(uasmon) && !throws_rocks(uasmon))
X***************
X*** 470,486 ****
X  	if (!u.uswallow && flooreffects(obj,u.ux,u.uy,"drop")) return;
X  	if(obj->otyp == CRYSKNIFE)
X  		obj->otyp = WORM_TOOTH;
X  	/* uswallow check done by GAN 01/29/87 */
X  	if(u.uswallow) {
X! 		if (obj->otyp == GOLD_PIECE) {
X! 		    u.ustuck->mgold += obj->quan;
X! 		    delobj(obj);
X! 		} else if (obj != uball) {	/* mon doesn't pick up ball */
X! 		    (void) snuff_candle(obj);   /* security. it's never lit */
X  		    mpickobj(u.ustuck,obj);
X  		}
X  	} else  {
X- 		(void) snuff_candle(obj);
X  		obj->nobj = fobj;
X  		fobj = obj;
X  		place_object(obj, u.ux, u.uy);
X--- 470,482 ----
X  	if (!u.uswallow && flooreffects(obj,u.ux,u.uy,"drop")) return;
X  	if(obj->otyp == CRYSKNIFE)
X  		obj->otyp = WORM_TOOTH;
X+ 	(void) snuff_candle(obj);
X  	/* uswallow check done by GAN 01/29/87 */
X  	if(u.uswallow) {
X! 		if (obj != uball) {		/* mon doesn't pick up ball */
X  		    mpickobj(u.ustuck,obj);
X  		}
X  	} else  {
X  		obj->nobj = fobj;
X  		fobj = obj;
X  		place_object(obj, u.ux, u.uy);
X***************
X*** 790,798 ****
X  			pline("Probably someone removed it.");
X  			done(TRICKED);
X  		}
X! #ifdef ZEROCOMP
X! 		minit();
X! #endif
X  		getlev(fd, hackpid, ledger_no(&u.uz), FALSE);
X  		(void) close(fd);
X  	}
X--- 786,792 ----
X  			pline("Probably someone removed it.");
X  			done(TRICKED);
X  		}
X! 		minit();	/* ZEROCOMP */
X  		getlev(fd, hackpid, ledger_no(&u.uz), FALSE);
X  		(void) close(fd);
X  	}
X***************
X*** 929,938 ****
X  	if (newdungeon && In_tower(&u.uz))
X  		pline("The heat and smoke are gone.");
X  #ifdef MULDGN
X! 	if(!In_quest(&u.uz0) && at_dgn_entrance("The Quest") &&
X! 		!(u.uevent.qexpelled || u.uevent.qcompleted || leaderless()))
X! 	    com_pager(2);	/* the message from the leader */
X  
X  	if(Is_knox(&u.uz)) {
X  		register struct monst *mtmp;
X  
X--- 923,940 ----
X  	if (newdungeon && In_tower(&u.uz))
X  		pline("The heat and smoke are gone.");
X  #ifdef MULDGN
X! 	/* the message from your quest leader */
X! 	if (!In_quest(&u.uz0) && at_dgn_entrance("The Quest") &&
X! 		!(u.uevent.qexpelled || u.uevent.qcompleted || leaderless())) {
X  
X+ 		if (u.uevent.qcalled) {
X+ 			com_pager(3);
X+ 		} else {
X+ 			com_pager(2);
X+ 			u.uevent.qcalled = TRUE;
X+ 		}
X+ 	}
X+ 
X  	if(Is_knox(&u.uz)) {
X  		register struct monst *mtmp;
X  
X***************
X*** 1007,1016 ****
X  	save_currentstate();
X  #endif
X  
X! 	if(!flags.nopick && OBJ_AT(u.ux, u.uy) &&
X! 	   (!is_pool(u.ux,u.uy) || Underwater))
X! 		pickup(1);
X! 	else read_engr_at(u.ux,u.uy);
X  }
X  
X  /* handle something like portal ejection */
X--- 1009,1015 ----
X  	save_currentstate();
X  #endif
X  
X! 	pickup(1);
X  }
X  
X  /* handle something like portal ejection */
X***************
X*** 1078,1083 ****
X--- 1077,1083 ----
X      register long corpse_age;
X      boolean ininv = (*chain == invent);
X      boolean onfloor = (*chain == fobj);
X+     boolean buried = (*chain == level.buriedobjlist);
X  
X      for (obj = *chain; obj; obj = nobj) {
X  	nobj = obj->nobj;
X***************
X*** 1088,1096 ****
X  		rn2(3) && is_ice(obj->ox, obj->oy)) obj->age++;
X  	    corpse_age = monstermoves - obj->age;
X  
X! 	    if (is_rider(&mons[obj->corpsenm]) && corpse_age >= 12) {
X  		/* these always come back eventually */
X! 		/* riders can't be picked up, so no need to check onfloor */
X  		revive_corpse(obj, 3, FALSE);
X  	    } else if (mons[obj->corpsenm].mlet == S_TROLL && !obj->oldcorpse
X  		       && !(mons[obj->corpsenm].geno & (G_GENOD | G_EXTINCT))
X--- 1088,1098 ----
X  		rn2(3) && is_ice(obj->ox, obj->oy)) obj->age++;
X  	    corpse_age = monstermoves - obj->age;
X  
X! 	    if (is_rider(&mons[obj->corpsenm]) && corpse_age >= 12 && onfloor) {
X  		/* these always come back eventually */
X! 		/* riders can't be picked up, but can be buried, but
X! 		 * the astral level seems to rule out that possibility
X! 		 */
X  		revive_corpse(obj, 3, FALSE);
X  	    } else if (mons[obj->corpsenm].mlet == S_TROLL && !obj->oldcorpse
X  		       && !(mons[obj->corpsenm].geno & (G_GENOD | G_EXTINCT))
X***************
X*** 1113,1118 ****
X--- 1115,1122 ----
X  		    useup(obj);
X  		else if(onfloor)
X  		    delobj(obj);
X+ 		else if(buried)
X+ 		    delburiedobj(obj);
X  		else { /* in a container */
X  		    if(pobj) pobj->nobj = nobj;
X  		    else *chain = nobj;
X***************
X*** 1120,1127 ****
X  		    obj = 0;
X  		}
X  	    }
X! 	} else if(obj->cobj && Is_container(obj) && obj->otyp != ICE_BOX)
X  	    remove_cadavers(&obj->cobj);
X  	/* pobj is only used for containers, which don't allow revive() -dlc */
X  	/* and for monster inventory (special cases only) under MUSE */
X  	if (obj) pobj = obj;
X--- 1124,1132 ----
X  		    obj = 0;
X  		}
X  	    }
X! 	} else if (Has_contents(obj) && obj->otyp != ICE_BOX) {
X  	    remove_cadavers(&obj->cobj);
X+ 	}
X  	/* pobj is only used for containers, which don't allow revive() -dlc */
X  	/* and for monster inventory (special cases only) under MUSE */
X  	if (obj) pobj = obj;
X***************
X*** 1129,1135 ****
X  }
X  
X  int
X! donull() {
X  	return(1);	/* Do nothing, but let other things happen */
X  }
X  
X--- 1134,1141 ----
X  }
X  
X  int
X! donull()
X! {
X  	return(1);	/* Do nothing, but let other things happen */
X  }
X  
X***************
X*** 1137,1143 ****
X  #ifdef OVLB
X  
X  STATIC_PTR int
X! wipeoff() {
X  	if(u.ucreamed < 4)	u.ucreamed = 0;
X  	else			u.ucreamed -= 4;
X  	if (Blinded < 4)	Blinded = 0;
X--- 1143,1150 ----
X  #ifdef OVLB
X  
X  STATIC_PTR int
X! wipeoff()
X! {
X  	if(u.ucreamed < 4)	u.ucreamed = 0;
X  	else			u.ucreamed -= 4;
X  	if (Blinded < 4)	Blinded = 0;
X*** /tmp/da10890	Tue Jun  1 16:13:07 1993
X--- src/do_name.c	Mon May 17 14:04:22 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)do_name.c	3.1	93/02/22	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)do_name.c	3.1	93/05/15	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 581,587 ****
X  	return(bp);
X  }
X  
X! static NEARDATA const char *bogusmons[] = {
X  	"jumbo shrimp", "giant pigmy", "gnu", "killer penguin", 
X  	"giant cockroach", "giant slug", "maggot", "pterodactyl",
X  	"tyrannosaurus rex", "basilisk", "beholder", "nightmare",
X--- 581,587 ----
X  	return(bp);
X  }
X  
X! static const char *bogusmons[] = {
X  	"jumbo shrimp", "giant pigmy", "gnu", "killer penguin", 
X  	"giant cockroach", "giant slug", "maggot", "pterodactyl",
X  	"tyrannosaurus rex", "basilisk", "beholder", "nightmare",
X***************
X*** 623,630 ****
X  	"samurai rabbit",			/* Usagi Yojimbo */
X  	"aardvark",				/* Cerebus */
X  	"Audrey II",				/* Little Shop of Horrors */
X! 	"witch doctor", "one-eyed one-horned flying purple people eater"
X  						/* 50's rock 'n' roll */
X  };
X  
X  const char *
X--- 623,631 ----
X  	"samurai rabbit",			/* Usagi Yojimbo */
X  	"aardvark",				/* Cerebus */
X  	"Audrey II",				/* Little Shop of Horrors */
X! 	"witch doctor", "one-eyed one-horned flying purple people eater",
X  						/* 50's rock 'n' roll */
X+ 	"Barney the dinosaur"			/* saccharine kiddy TV */
X  };
X  
X  const char *
X***************
X*** 692,702 ****
X  {
X  	char *i, *opts;
X  
X! 	if(opts = getenv("ROGUEOPTS")) {
X! 		for(i=opts; *i; i++)
X  			if (!strncmp("name=",i,5)) {
X  				char *j;
X! 				if (j=index(i+5,','))
X  					*j = (char)0;
X  				return i+5;
X  			}
X--- 693,703 ----
X  {
X  	char *i, *opts;
X  
X! 	if ((opts = getenv("ROGUEOPTS")) != 0) {
X! 		for (i = opts; *i; i++)
X  			if (!strncmp("name=",i,5)) {
X  				char *j;
X! 				if ((j = index(i+5,',')) != 0)
X  					*j = (char)0;
X  				return i+5;
X  			}
X*** /tmp/da10898	Tue Jun  1 16:13:10 1993
X--- src/do_wear.c	Wed May 26 11:55:34 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)do_wear.c	3.1	92/12/13	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)do_wear.c	3.1	93/05/25	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 40,46 ****
X  static void FDECL(already_wearing, (const char*));
X  
X  void
X! off_msg(otmp) register struct obj *otmp; {
X  	if(flags.verbose)
X  	    You("were wearing %s.", doname(otmp));
X  }
X--- 40,48 ----
X  static void FDECL(already_wearing, (const char*));
X  
X  void
X! off_msg(otmp)
X! register struct obj *otmp;
X! {
X  	if(flags.verbose)
X  	    You("were wearing %s.", doname(otmp));
X  }
X***************
X*** 59,71 ****
X  #ifdef OVL2
X  
X  boolean
X! is_boots(otmp) register struct obj *otmp; {
X  	return(otmp->otyp >= LOW_BOOTS &&
X  		otmp->otyp <= LEVITATION_BOOTS);
X  }
X  
X  boolean
X! is_helmet(otmp) register struct obj *otmp; {
X  	return(otmp->otyp >= ELVEN_LEATHER_HELM &&
X  		otmp->otyp <= HELM_OF_TELEPATHY);
X  }
X--- 61,77 ----
X  #ifdef OVL2
X  
X  boolean
X! is_boots(otmp)
X! register struct obj *otmp;
X! {
X  	return(otmp->otyp >= LOW_BOOTS &&
X  		otmp->otyp <= LEVITATION_BOOTS);
X  }
X  
X  boolean
X! is_helmet(otmp)
X! register struct obj *otmp;
X! {
X  	return(otmp->otyp >= ELVEN_LEATHER_HELM &&
X  		otmp->otyp <= HELM_OF_TELEPATHY);
X  }
X***************
X*** 74,80 ****
X  #ifdef OVL2
X  
X  boolean
X! is_gloves(otmp) register struct obj *otmp; {
X  	return(otmp->otyp >= LEATHER_GLOVES &&
X  		otmp->otyp <= GAUNTLETS_OF_DEXTERITY);
X  }
X--- 80,88 ----
X  #ifdef OVL2
X  
X  boolean
X! is_gloves(otmp)
X! register struct obj *otmp;
X! {
X  	return(otmp->otyp >= LEATHER_GLOVES &&
X  		otmp->otyp <= GAUNTLETS_OF_DEXTERITY);
X  }
X***************
X*** 83,95 ****
X  #ifdef OVLB
X  
X  boolean
X! is_cloak(otmp) register struct obj *otmp; {
X  	return(otmp->otyp >= MUMMY_WRAPPING &&
X  		otmp->otyp <= CLOAK_OF_DISPLACEMENT);
X  }
X  
X  boolean
X! is_shield(otmp) register struct obj *otmp; {
X  	return(otmp->otyp >= SMALL_SHIELD &&
X  		otmp->otyp <= SHIELD_OF_REFLECTION);
X  }
X--- 91,107 ----
X  #ifdef OVLB
X  
X  boolean
X! is_cloak(otmp)
X! register struct obj *otmp;
X! {
X  	return(otmp->otyp >= MUMMY_WRAPPING &&
X  		otmp->otyp <= CLOAK_OF_DISPLACEMENT);
X  }
X  
X  boolean
X! is_shield(otmp)
X! register struct obj *otmp;
X! {
X  	return(otmp->otyp >= SMALL_SHIELD &&
X  		otmp->otyp <= SHIELD_OF_REFLECTION);
X  }
X***************
X*** 101,107 ****
X  
X  STATIC_PTR
X  int
X! Boots_on() {
X      long oldprop = u.uprops[objects[uarmf->otyp].oc_oprop].p_flgs & ~WORN_BOOTS;
X  
X      switch(uarmf->otyp) {
X--- 113,120 ----
X  
X  STATIC_PTR
X  int
X! Boots_on()
X! {
X      long oldprop = u.uprops[objects[uarmf->otyp].oc_oprop].p_flgs & ~WORN_BOOTS;
X  
X      switch(uarmf->otyp) {
X***************
X*** 144,150 ****
X  }
X  
X  int
X! Boots_off() {
X      register struct obj *obj = uarmf;
X  	/* For levitation, float_down() returns if Levitation, so we
X  	 * must do a setworn() _before_ the levitation case.
X--- 157,164 ----
X  }
X  
X  int
X! Boots_off()
X! {
X      register struct obj *obj = uarmf;
X  	/* For levitation, float_down() returns if Levitation, so we
X  	 * must do a setworn() _before_ the levitation case.
X***************
X*** 198,204 ****
X  }
X  
X  static int
X! Cloak_on() {
X      long oldprop = u.uprops[objects[uarmc->otyp].oc_oprop].p_flgs & ~WORN_CLOAK;
X  
X      switch(uarmc->otyp) {
X--- 212,219 ----
X  }
X  
X  static int
X! Cloak_on()
X! {
X      long oldprop = u.uprops[objects[uarmc->otyp].oc_oprop].p_flgs & ~WORN_CLOAK;
X  
X      switch(uarmc->otyp) {
X***************
X*** 228,234 ****
X  }
X  
X  int
X! Cloak_off() {
X      long oldprop = u.uprops[objects[uarmc->otyp].oc_oprop].p_flgs & ~WORN_CLOAK;
X  
X      switch(uarmc->otyp) {
X--- 243,250 ----
X  }
X  
X  int
X! Cloak_off()
X! {
X      long oldprop = u.uprops[objects[uarmc->otyp].oc_oprop].p_flgs & ~WORN_CLOAK;
X  
X      switch(uarmc->otyp) {
X***************
X*** 324,330 ****
X  
X  STATIC_PTR
X  int
X! Gloves_on() {
X      long oldprop =
X  	u.uprops[objects[uarmg->otyp].oc_oprop].p_flgs & ~(WORN_GLOVES | TIMEOUT);
X  
X--- 340,347 ----
X  
X  STATIC_PTR
X  int
X! Gloves_on()
X! {
X      long oldprop =
X  	u.uprops[objects[uarmg->otyp].oc_oprop].p_flgs & ~(WORN_GLOVES | TIMEOUT);
X  
X***************
X*** 350,356 ****
X  }
X  
X  int
X! Gloves_off() {
X      long oldprop =
X  	u.uprops[objects[uarmg->otyp].oc_oprop].p_flgs & ~(WORN_GLOVES | TIMEOUT);
X  
X--- 367,374 ----
X  }
X  
X  int
X! Gloves_off()
X! {
X      long oldprop =
X  	u.uprops[objects[uarmg->otyp].oc_oprop].p_flgs & ~(WORN_GLOVES | TIMEOUT);
X  
X***************
X*** 391,397 ****
X  
X  /*
X  static int
X! Shield_on() {
X      switch(uarms->otyp) {
X  	case SMALL_SHIELD:
X  	case ELVEN_SHIELD:
X--- 409,416 ----
X  
X  /*
X  static int
X! Shield_on()
X! {
X      switch(uarms->otyp) {
X  	case SMALL_SHIELD:
X  	case ELVEN_SHIELD:
X***************
X*** 408,414 ****
X  */
X  
X  int
X! Shield_off() {
X  /*
X      switch(uarms->otyp) {
X  	case SMALL_SHIELD:
X--- 427,434 ----
X  */
X  
X  int
X! Shield_off()
X! {
X  /*
X      switch(uarms->otyp) {
X  	case SMALL_SHIELD:
X***************
X*** 504,512 ****
X  		break;
X  	case AMULET_OF_MAGICAL_BREATHING:
X  		if (Underwater) {
X  			You("suddenly inhale an unhealthy amount of water!");
X! 			/* Magical_breathing has to be set
X! 			   off before calling drown() */
X  			setworn((struct obj *)0, W_AMUL);
X  			(void) drown();
X  			return;
X--- 524,536 ----
X  		break;
X  	case AMULET_OF_MAGICAL_BREATHING:
X  		if (Underwater) {
X+ #ifdef POLYSELF
X+ 			if (!breathless(uasmon) && !amphibious(uasmon)
X+ 			    && !is_swimmer(uasmon))
X+ #endif
X  			You("suddenly inhale an unhealthy amount of water!");
X! 			/* HMagical_breathing must be set off
X! 			   before calling drown() */
X  			setworn((struct obj *)0, W_AMUL);
X  			(void) drown();
X  			return;
X***************
X*** 743,749 ****
X  
X  /* called in main to set intrinsics of worn start-up items */
X  void
X! set_wear() {
X  	if (uarm)  (void) Armor_on();
X  	if (uarmc) (void) Cloak_on();
X  	if (uarmf) (void) Boots_on();
X--- 767,774 ----
X  
X  /* called in main to set intrinsics of worn start-up items */
X  void
X! set_wear()
X! {
X  	if (uarm)  (void) Armor_on();
X  	if (uarmc) (void) Cloak_on();
X  	if (uarmf) (void) Boots_on();
X***************
X*** 850,856 ****
X  }
X  
X  int
X! doremring() {
X  #ifdef GCC_WARN
X  	register struct obj *otmp = (struct obj *)0;
X  		/* suppress "may be used uninitialized" warning */
X--- 875,882 ----
X  }
X  
X  int
X! doremring()
X! {
X  #ifdef GCC_WARN
X  	register struct obj *otmp = (struct obj *)0;
X  		/* suppress "may be used uninitialized" warning */
X***************
X*** 916,922 ****
X  }
X  
X  int
X! cursed(otmp) register struct obj *otmp; {
X  	/* Curses, like chickens, come home to roost. */
X  	if(otmp->cursed){
X  		You("can't.  %s to be cursed.",
X--- 942,950 ----
X  }
X  
X  int
X! cursed(otmp)
X! register struct obj *otmp;
X! {
X  	/* Curses, like chickens, come home to roost. */
X  	if(otmp->cursed){
X  		You("can't.  %s to be cursed.",
X***************
X*** 929,935 ****
X  }
X  
X  int
X! armoroff(otmp) register struct obj *otmp; {
X  	register int delay = -objects[otmp->otyp].oc_delay;
X  
X  	if(cursed(otmp)) return(0);
X--- 957,965 ----
X  }
X  
X  int
X! armoroff(otmp)
X! register struct obj *otmp;
X! {
X  	register int delay = -objects[otmp->otyp].oc_delay;
X  
X  	if(cursed(otmp)) return(0);
X***************
X*** 1244,1250 ****
X  #ifdef OVL0
X  
X  void
X! find_ac() {
X  	register int uac = 10;
X  #ifdef POLYSELF
X  	if (u.mtimedone) uac = mons[u.umonnum].ac;
X--- 1274,1281 ----
X  #ifdef OVL0
X  
X  void
X! find_ac()
X! {
X  	register int uac = 10;
X  #ifdef POLYSELF
X  	if (u.mtimedone) uac = mons[u.umonnum].ac;
X***************
X*** 1315,1322 ****
X  }
X  
X  struct obj *
X! some_armor(){
X! register struct obj *otmph = (uarmc ? uarmc : uarm);
X  	if(uarmh && (!otmph || !rn2(4))) otmph = uarmh;
X  	if(uarmg && (!otmph || !rn2(4))) otmph = uarmg;
X  	if(uarmf && (!otmph || !rn2(4))) otmph = uarmf;
X--- 1346,1354 ----
X  }
X  
X  struct obj *
X! some_armor()
X! {
X! 	register struct obj *otmph = (uarmc ? uarmc : uarm);
X  	if(uarmh && (!otmph || !rn2(4))) otmph = uarmh;
X  	if(uarmg && (!otmph || !rn2(4))) otmph = uarmg;
X  	if(uarmf && (!otmph || !rn2(4))) otmph = uarmf;
X***************
X*** 1331,1337 ****
X  erode_armor(acid_dmg)
X  boolean acid_dmg;
X  {
X! register struct obj *otmph = some_armor();
X  
X  	if (otmph && otmph != uarmf) {
X  	    if (otmph->greased) {
X--- 1363,1369 ----
X  erode_armor(acid_dmg)
X  boolean acid_dmg;
X  {
X! 	register struct obj *otmph = some_armor();
X  
X  	if (otmph && otmph != uarmf) {
X  	    if (otmph->greased) {
X***************
X*** 1416,1423 ****
X  }
X  
X  static struct obj *
X! do_takeoff() {
X! 
X  	register struct obj *otmp = (struct obj *)0;
X  
X  	if (taking_off == 1L) { /* weapon */
X--- 1448,1455 ----
X  }
X  
X  static struct obj *
X! do_takeoff()
X! {
X  	register struct obj *otmp = (struct obj *)0;
X  
X  	if (taking_off == 1L) { /* weapon */
X***************
X*** 1471,1478 ****
X  
X  STATIC_PTR
X  int
X! take_off() {
X! 
X  	register int i;
X  	register struct obj *otmp;
X  
X--- 1503,1510 ----
X  
X  STATIC_PTR
X  int
X! take_off()
X! {
X  	register int i;
X  	register struct obj *otmp;
X  
X***************
X*** 1489,1500 ****
X  
X  	for(i = 0; takeoff_order[i]; i++)
X  	    if(takeoff_mask & takeoff_order[i]) {
X- 
X  		taking_off = takeoff_order[i];
X  		break;
X  	    }
X  
X  	otmp = (struct obj *) 0;
X  
X  	if (taking_off == 0L) {
X  	  You("finish disrobing.");
X--- 1521,1532 ----
X  
X  	for(i = 0; takeoff_order[i]; i++)
X  	    if(takeoff_mask & takeoff_order[i]) {
X  		taking_off = takeoff_order[i];
X  		break;
X  	    }
X  
X  	otmp = (struct obj *) 0;
X+ 	todelay = 0;
X  
X  	if (taking_off == 0L) {
X  	  You("finish disrobing.");
X***************
X*** 1503,1508 ****
X--- 1535,1545 ----
X  	  todelay = 1;
X  	} else if (taking_off == WORN_ARMOR) {
X  	  otmp = uarm;
X+ 	  /* If a cloak is being worn, add the time to take it off and put
X+ 	   * it back on again.  Kludge alert! since that time is 0 for all
X+ 	   * known cloaks, add 1 so that it actually matters...
X+ 	   */
X+ 	  if (uarmc) todelay += 2 * objects[uarmc->otyp].oc_delay + 1;
X  	} else if (taking_off == WORN_CLOAK) {
X  	  otmp = uarmc;
X  	} else if (taking_off == WORN_BOOTS) {
X***************
X*** 1516,1521 ****
X--- 1553,1561 ----
X  #ifdef TOURIST
X  	} else if (taking_off == WORN_SHIRT) {
X  	  otmp = uarmu;
X+ 	  /* add the time to take off and put back on armor and/or cloak */
X+ 	  if (uarm)  todelay += 2 * objects[uarm->otyp].oc_delay;
X+ 	  if (uarmc) todelay += 2 * objects[uarmc->otyp].oc_delay + 1;
X  #endif
X  	} else if (taking_off == WORN_AMUL) {
X  	  todelay = 1;
X***************
X*** 1530,1536 ****
X  	  return 0;	/* force done */
X  	}
X  
X! 	if(otmp) todelay = objects[otmp->otyp].oc_delay;
X  	set_occupation(take_off, "disrobing", 0);
X  	return(1);		/* get busy */
X  }
X--- 1570,1576 ----
X  	  return 0;	/* force done */
X  	}
X  
X! 	if (otmp) todelay += objects[otmp->otyp].oc_delay;
X  	set_occupation(take_off, "disrobing", 0);
X  	return(1);		/* get busy */
X  }
X***************
X*** 1539,1554 ****
X  #ifdef OVL1
X  
X  void
X! reset_remarm() { taking_off = takeoff_mask =0L; }
X  
X  #endif /* OVL1 */
X  #ifdef OVLB
X  
X  int
X! doddoremarm() {
X! 
X  	if(taking_off || takeoff_mask) {
X- 
X  	    You("continue disrobing.");
X  	    set_occupation(take_off, "disrobing", 0);
X  	    return(take_off());
X--- 1579,1596 ----
X  #ifdef OVL1
X  
X  void
X! reset_remarm()
X! {
X! 	taking_off = takeoff_mask =0L;
X! }
X  
X  #endif /* OVL1 */
X  #ifdef OVLB
X  
X  int
X! doddoremarm()
X! {
X  	if(taking_off || takeoff_mask) {
X  	    You("continue disrobing.");
X  	    set_occupation(take_off, "disrobing", 0);
X  	    return(take_off());
X*** /tmp/da10906	Tue Jun  1 16:13:13 1993
X--- src/dog.c	Wed Mar 31 17:29:08 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)dog.c	3.1	92/10/18	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)dog.c	3.1	93/03/30	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 94,99 ****
X--- 94,106 ----
X  		newsym(mtmp->mx, mtmp->my);
X  	}
X  	set_malign(mtmp); /* more alignment changes */
X+ #ifdef MUSE
X+ 	/* must wield weapon immediately since pets will otherwise drop it */
X+ 	if (mtmp->mtame && attacktype(mtmp->data, AT_WEAP)) {
X+ 		mtmp->weapon_check = NEED_HTH_WEAPON;
X+ 		(void) mon_wield_item(mtmp);
X+ 	}
X+ #endif
X  }
X  
X  struct monst *
X***************
X*** 126,135 ****
X  void
X  losedogs()
X  {
X! 	register struct monst *mtmp,*mtmp0,*mtmp2;
X  	int num_segs;
X  
X! 	while(mtmp = mydogs){
X  		mydogs = mtmp->nmon;
X  		mtmp->nmon = fmon;
X  		fmon = mtmp;
X--- 133,142 ----
X  void
X  losedogs()
X  {
X! 	register struct monst *mtmp, *mtmp0 = 0, *mtmp2;
X  	int num_segs;
X  
X! 	while ((mtmp = mydogs) != 0) {
X  		mydogs = mtmp->nmon;
X  		mtmp->nmon = fmon;
X  		fmon = mtmp;
X***************
X*** 146,154 ****
X  		mnexto(mtmp);
X  	}
X  
X- #if defined(LINT) || defined(GCC_WARN)
X- 	mtmp0 = (struct monst *)0;
X- #endif
X  	for(mtmp = migrating_mons; mtmp; mtmp = mtmp2) {
X  		mtmp2 = mtmp->nmon;
X  		if(mtmp->mx == u.uz.dnum && mtmp->mux == u.uz.dlevel) {
X--- 153,158 ----
X***************
X*** 312,319 ****
X  
X  		/* set minvent's obj->no_charge to 0 */
X  		for(obj = mtmp->minvent; obj; obj = obj->nobj) {
X! 		    if(Is_container(obj))
X! 		        picked_container(obj); /* does the right thing */
X  		    obj->no_charge = 0;
X  		}
X  
X--- 316,323 ----
X  
X  		/* set minvent's obj->no_charge to 0 */
X  		for(obj = mtmp->minvent; obj; obj = obj->nobj) {
X! 		    if (Has_contents(obj))
X! 			picked_container(obj);	/* does the right thing */
X  		    obj->no_charge = 0;
X  		}
X  
X***************
X*** 358,365 ****
X  
X  	/* set minvent's obj->no_charge to 0 */
X  	for(obj = mtmp->minvent; obj; obj = obj->nobj) {
X! 	    if(Is_container(obj))
X! 	        picked_container(obj); /* does the right thing */
X  	    obj->no_charge = 0;
X  	}
X  
X--- 362,369 ----
X  
X  	/* set minvent's obj->no_charge to 0 */
X  	for(obj = mtmp->minvent; obj; obj = obj->nobj) {
X! 	    if (Has_contents(obj))
X! 		picked_container(obj);	/* does the right thing */
X  	    obj->no_charge = 0;
X  	}
X  
X***************
X*** 534,539 ****
X--- 538,549 ----
X  	initedog(mtmp2);
X  	replmon(mtmp,mtmp2);
X  	newsym(mtmp2->mx, mtmp2->my);
X+ #ifdef MUSE
X+ 	if (attacktype(mtmp2->data, AT_WEAP)) {
X+ 		mtmp2->weapon_check = NEED_HTH_WEAPON;
X+ 		(void) mon_wield_item(mtmp2);
X+ 	}
X+ #endif
X  	return(mtmp2);
X  }
X  
X*** /tmp/da10914	Tue Jun  1 16:13:16 1993
X--- src/dogmove.c	Tue Jun  1 12:13:16 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)dogmove.c	3.1	93/02/09	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)dogmove.c	3.1	93/05/15	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 125,142 ****
X  register struct monst *mtmp;
X  register struct edog *edog;
X  {
X! 	if(moves > edog->hungrytime + 500) {
X! 	    if(!carnivorous(mtmp->data) && !herbivorous(mtmp->data)) {
X  		edog->hungrytime = moves + 500;
X  		/* but not too high; it might polymorph */
X  	    } else if (!mtmp->mconf) {
X  		mtmp->mconf = 1;
X  		mtmp->mhpmax /= 3;
X! 		if(mtmp->mhp > mtmp->mhpmax)
X  		    mtmp->mhp = mtmp->mhpmax;
X! 		if(mtmp->mhp < 1) goto dog_died;
X! 		if(cansee(mtmp->mx, mtmp->my))
X  		    pline("%s is confused from hunger.", Monnam(mtmp));
X  		else {
X  		    char buf[BUFSZ];
X  
X--- 125,146 ----
X  register struct monst *mtmp;
X  register struct edog *edog;
X  {
X! 	if (moves > edog->hungrytime + 500) {
X! 	    if (!carnivorous(mtmp->data) && !herbivorous(mtmp->data)) {
X  		edog->hungrytime = moves + 500;
X  		/* but not too high; it might polymorph */
X  	    } else if (!mtmp->mconf) {
X  		mtmp->mconf = 1;
X  		mtmp->mhpmax /= 3;
X! 		if (mtmp->mhp > mtmp->mhpmax)
X  		    mtmp->mhp = mtmp->mhpmax;
X! 		if (mtmp->mhp < 1) goto dog_died;
X! 		if (cansee(mtmp->mx, mtmp->my))
X  		    pline("%s is confused from hunger.", Monnam(mtmp));
X+ #ifdef SOUNDS
X+ 		else if (couldsee(mtmp->mx, mtmp->my))
X+ 		    beg(mtmp);
X+ #endif
X  		else {
X  		    char buf[BUFSZ];
X  
X***************
X*** 145,161 ****
X  			NAME(mtmp) : strcat(buf, Hallucination
X  			? rndmonnam() : mtmp->data->mname));
X  		}
X! 	    } else if(moves > edog->hungrytime + 750 || mtmp->mhp < 1) {
X  	    dog_died:
X  #ifdef WALKIES
X! 		if(mtmp->mleashed)
X  		    Your("leash goes slack.");
X  #endif
X! 		if(cansee(mtmp->mx, mtmp->my))
X  		    pline("%s dies%s.", Monnam(mtmp),
X  			    (mtmp->mhp >= 1) ? "" : " from hunger");
X  		else
X! 		    You("have a sad feeling for a moment, then it passes.");
X  		mondied(mtmp);
X  		return(TRUE);
X  	    }
X--- 149,167 ----
X  			NAME(mtmp) : strcat(buf, Hallucination
X  			? rndmonnam() : mtmp->data->mname));
X  		}
X! 	    } else if (moves > edog->hungrytime + 750 || mtmp->mhp < 1) {
X  	    dog_died:
X  #ifdef WALKIES
X! 		if (mtmp->mleashed)
X  		    Your("leash goes slack.");
X+ 		else
X  #endif
X! 		if (cansee(mtmp->mx, mtmp->my))
X  		    pline("%s dies%s.", Monnam(mtmp),
X  			    (mtmp->mhp >= 1) ? "" : " from hunger");
X  		else
X! 		    You("feel %s for a moment.",
X! 			Hallucination ? "bummed" : "sad");
X  		mondied(mtmp);
X  		return(TRUE);
X  	    }
X***************
X*** 207,212 ****
X--- 213,224 ----
X  			    freeobj(obj);
X  			    newsym(omx,omy);
X  			    mpickobj(mtmp,obj);
X+ #ifdef MUSE
X+ 			    if (attacktype(mtmp->data, AT_WEAP)) {
X+ 				mtmp->weapon_check = NEED_HTH_WEAPON;
X+ 				(void) mon_wield_item(mtmp);
X+ 			    }
X+ #endif
X  			}
X  	    }
X  	}
X***************
X*** 470,476 ****
X  		    (j = distu(nx, ny)) > 16 && j >= udist) continue;
X  
X  		if ((info[i] & ALLOW_M) && MON_AT(nx, ny)) {
X! 		    int stat;
X  		    register struct monst *mtmp2 = m_at(nx,ny);
X  
X  		    if ((int)mtmp2->m_lev >= (int)mtmp->m_lev+2 ||
X--- 482,488 ----
X  		    (j = distu(nx, ny)) > 16 && j >= udist) continue;
X  
X  		if ((info[i] & ALLOW_M) && MON_AT(nx, ny)) {
X! 		    int mstatus;
X  		    register struct monst *mtmp2 = m_at(nx,ny);
X  
X  		    if ((int)mtmp2->m_lev >= (int)mtmp->m_lev+2 ||
X***************
X*** 479,490 ****
X  			 && (perceives(mtmp->data) || !mtmp2->minvis)) ||
X  			(mtmp2->data==&mons[PM_GELATINOUS_CUBE] && rn2(10)) ||
X  			(max_passive_dmg(mtmp2, mtmp) >= mtmp->mhp) ||
X! 			((mtmp->mhp*4 < mtmp->mhpmax ||
X  #ifdef MULDGN
X! 			  mtmp2->data->msound == MS_GUARDIAN ||
X! 			  mtmp2->data->msound == MS_LEADER
X  #endif
X- 
X  			  ) &&
X  			 mtmp2->mpeaceful && !Conflict) ||
X  			   (mtmp2->data->mlet == S_COCKATRICE &&
X--- 491,501 ----
X  			 && (perceives(mtmp->data) || !mtmp2->minvis)) ||
X  			(mtmp2->data==&mons[PM_GELATINOUS_CUBE] && rn2(10)) ||
X  			(max_passive_dmg(mtmp2, mtmp) >= mtmp->mhp) ||
X! 			((mtmp->mhp*4 < mtmp->mhpmax
X  #ifdef MULDGN
X! 			  || mtmp2->data->msound == MS_GUARDIAN
X! 			  || mtmp2->data->msound == MS_LEADER
X  #endif
X  			  ) &&
X  			 mtmp2->mpeaceful && !Conflict) ||
X  			   (mtmp2->data->mlet == S_COCKATRICE &&
X***************
X*** 493,508 ****
X  
X  		    if (after) return(0); /* hit only once each move */
X  
X! 		    stat = mattackm(mtmp, mtmp2);
X  
X  		    /* aggressor (pet) died */
X! 		    if (stat & MM_AGR_DIED) return 2;
X  
X! 		    if ((stat & MM_HIT) && !(stat & MM_DEF_DIED) &&
X  			rn2(4) && mtmp2->mlstmv != monstermoves &&
X  			!onscary(mtmp->mx, mtmp->my, mtmp2)) {
X! 			stat = mattackm(mtmp2, mtmp);	/* return attack */
X! 			if (stat & MM_DEF_DIED) return 2;
X  		    }
X  
X  		    return 0;
X--- 504,519 ----
X  
X  		    if (after) return(0); /* hit only once each move */
X  
X! 		    mstatus = mattackm(mtmp, mtmp2);
X  
X  		    /* aggressor (pet) died */
X! 		    if (mstatus & MM_AGR_DIED) return 2;
X  
X! 		    if ((mstatus & MM_HIT) && !(mstatus & MM_DEF_DIED) &&
X  			rn2(4) && mtmp2->mlstmv != monstermoves &&
X  			!onscary(mtmp->mx, mtmp->my, mtmp2)) {
X! 			mstatus = mattackm(mtmp2, mtmp);	/* return attack */
X! 			if (mstatus & MM_DEF_DIED) return 2;
X  		    }
X  
X  		    return 0;
X***************
X*** 524,531 ****
X  				    && (is_flyer(mtmp->data) ||
X  					is_clinger(mtmp->data)))
X  				|| (trap->ttyp == SLP_GAS_TRAP &&
X! 				    resists_sleep(mtmp->data)))
X! 			    if(!trap->tseen || rn2(3)) continue;
X  #ifdef WALKIES
X  			if (!mtmp->mleashed) {
X  #endif
X--- 535,543 ----
X  				    && (is_flyer(mtmp->data) ||
X  					is_clinger(mtmp->data)))
X  				|| (trap->ttyp == SLP_GAS_TRAP &&
X! 				    resists_sleep(mtmp->data))) {
X! 			    if (!trap->tseen || rn2(3)) continue;
X! 			} else
X  #ifdef WALKIES
X  			if (!mtmp->mleashed) {
X  #endif
X***************
X*** 532,542 ****
X  			    if (!trap->tseen && rn2(40)) continue;
X  			    if (rn2(10)) continue;
X  #ifdef WALKIES
X- 			}
X  # ifdef SOUNDS
X! 			else if (flags.soundok)
X  				whimper(mtmp);
X  # endif
X  #endif
X  		    }
X  		}
X--- 544,554 ----
X  			    if (!trap->tseen && rn2(40)) continue;
X  			    if (rn2(10)) continue;
X  #ifdef WALKIES
X  # ifdef SOUNDS
X! 			} else if (flags.soundok) {
X  				whimper(mtmp);
X  # endif
X+ 			}
X  #endif
X  		    }
X  		}
END_OF_FILE
if test 55636 -ne `wc -c <'patches02b'`; then
    echo shar: \"'patches02b'\" unpacked with wrong size!
fi
# end of 'patches02b'
if test -f 'patchit.sh' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'patchit.sh'\" to \"'patchit.sh.orig'\"
  mv -f 'patchit.sh' 'patchit.sh.orig'
fi
echo shar: Extracting \"'patchit.sh'\" \(356 characters\)
sed "s/^X//" >'patchit.sh' <<'END_OF_FILE'
X#!/bin/sh
Xecho building file patches02p
Xcat patches02p.1 patches02p.2 > patches02p
Xrm patches02p.1 patches02p.2
Xecho building file patches02t
Xcat patches02t.uu1 patches02t.uu2 | uudecode
Xrm patches02t.uu1 patches02t.uu2
Xecho applying patches
Xfor pfile in patches02[a-u]
Xdo patch -p < $pfile
Xdone
X(cd sys/mac; uudecode macmenu.c.uu; rm macmenu.c.uu)
Xexit 0
END_OF_FILE
if test 356 -ne `wc -c <'patchit.sh'`; then
    echo shar: \"'patchit.sh'\" unpacked with wrong size!
fi
chmod +x 'patchit.sh'
# end of 'patchit.sh'
if test -f 'sys/amiga/colors.uu' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'sys/amiga/colors.uu'\" to \"'sys/amiga/colors.uu.orig'\"
  mv -f 'sys/amiga/colors.uu' 'sys/amiga/colors.uu.orig'
fi
echo shar: Extracting \"'sys/amiga/colors.uu'\" \(2140 characters\)
sed "s/^X//" >'sys/amiga/colors.uu' <<'END_OF_FILE'
Xbegin 664 colors.pw
XM4&]W97)7:6YD;W=S('8R+C5C(*DQ.3@W+"`Q.3@X(&)Y($E.3U9!5%)/3DE#
XM4RP@24Y#+B`@("`@("`@("`@("`@("`@("`@("`@```"[`````E```#\````
XM`0`````!`````!%A;6EG83IC;VQO<G=I;BYC``?2=4```````H``R``#``&`
XM```/``````?(V?@```````````````(````!``````$``````0`````8````
XM\/#P8"``4(#`$'`0P`!@(##@P````````0`"$`X`8`)X``4`!?____\`````
XM!]*!D```````````````````````!@?/-;@```````5#;VQ?```!`*\`+0$X
XM`%T`!0`%_____P```!-%9&ET(%-C<F5E;B!#;VQO<G,`!])YX``@`"0!#P`+
XM`````P`#!](I(`````````````````?2.A@`!0?2>1#_____`P``!0?2>/0`
XM``````````$0```!$``,````#````````````0<`!P``````````````````
XM```!`P````#_____````"@````L'SSI8!\\]$`?//:`'ST#X!\]+>`?/5!@`
XM```(0FQU95!E;@`````!``````$`````"T=!1$),545014X``````0`````!
XM``?2>H``(``8`0\`"P````,``P?22U@````````````````'TGHX``8'TGI8
XM_____P,```4'TGH<```````````!$````1``#`````P```````````$'``<`
XM`````````````````````0,`````_____P````H````+!\]6@`?/5;@'SU\8
XM!\]B\`?/;$`'SWHX````"4=R965N4&5N``````$``````0`````,1T%$1U)%
XM14Y014X``````0`````!``?2?8``(``,`0\`"P````,``P?2>M@`````````
XM```````'TGKX``<'TGL8_____P,```4'TGJ\```````````!$````1``#```
XM``P```````````$'``<``````````````````````0,`````_____P````H`
XM```+!\^"$`?2<'@'TGDX!])]6`?2>T`'TGUP````!U)E9%!E;@`````!````
XM``$`````"D=!1%)%1%!%3@`````!``````$`!])^F`#T`$T`.@`+`````P`!
XM!])]K``````'TGW8````````````!@?2?@C_____`P``!0?2?;P`````````
XM```[````.P`,````#```````````!P`!```&``$`````!])]^``````````'
XM0V%N8V5L``````H````!!])^,`?2?D`'TGY0!])^8`?2?G@'TGZ(````!T-A
XM;F-E;``````!``````$`````#4=!1$-/3$-!3D-%3``````!``````$`!]*`
XM>`"``$T`.@`+`````P`!!])^Q``````'TG[P````````````!P?2?YC_____
XM`P``!0?2?M0````````````[````.P`,````#```````````!P`!```1``$`
XM````!])_$``````````$57-E``````H````!!])_P`?2?]`'TG_@!])_\`?2
XM@`@'TH`8````!4]K87D``````0`````!``````M'041#3TQ/2T%9``````$`
XM`````0````````D`30`Z``L````#``$'TH"D``````?2@-`````````````*
XM!]*!`/____\#```%!]*`M````````````#L````[``P````,```````````'
XM``$```T``0`````'TH#P``````````53879E``````H````!!]*!*`?2@3@'
XMTH%(!]*!6`?2@7`'TH&`````!5-A=F4``````0`````!``````M'041#3TQ3
XM059%``````$``````0`'``$``!``#@`````'TH&P!]*!P`````)2``0``0``
XM$``:``````?2@>`'TH'P`````D<``P`!```1`"8`````!]*"$``````````"
X"0@`:
X`
Xend
END_OF_FILE
if test 2140 -ne `wc -c <'sys/amiga/colors.uu'`; then
    echo shar: \"'sys/amiga/colors.uu'\" unpacked with wrong size!
fi
# end of 'sys/amiga/colors.uu'
echo shar: End of archive 7 \(of 33\).
cp /dev/null ark7isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 33 archives.
    echo "Now execute ./patchit.sh"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
