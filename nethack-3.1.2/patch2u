Path: uunet!news.tek.com!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v17i096:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Patch2u/33
Date: 11 Jun 1993 00:15:16 GMT
Organization: Tektronix, Inc, Redmond, OR, USA
Lines: 1676
Approved: billr@saab.CNA.TEK.COM
Message-ID: <1v8iqk$j5u@ying.cna.tek.com>
NNTP-Posting-Host: saab.cna.tek.com
Xref: uunet comp.sources.games:1783

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 17, Issue 96
Archive-name: nethack31/Patch2u
Patch-To: nethack31: Volume 16, Issue 1-116
Environment: Amiga, Atari, Mac, MS-DOS, Windows-NT, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 21 (of 33)."
# Contents:  sys/share/lev_lex.c
# Wrapped by billr@saab on Thu Jun 10 16:55:05 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'sys/share/lev_lex.c' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'sys/share/lev_lex.c'\" to \"'sys/share/lev_lex.c.orig'\"
  mv -f 'sys/share/lev_lex.c' 'sys/share/lev_lex.c.orig'
fi
echo shar: Extracting \"'sys/share/lev_lex.c'\" \(50181 characters\)
sed "s/^X//" >'sys/share/lev_lex.c' <<'END_OF_FILE'
X/* A lexical scanner for NetHack generated by flex */
X
X/* scanner skeleton version:
X * flexhack.skel 3.1.2 (from .../flex/RCS/flex.skel,v 2.16 90/08/03 14:09:36)
X */
X#define FLEX_SCANNER
X
X/* amount of stuff to slurp up with each read */
X#ifndef YY_READ_BUF_SIZE
X#define YY_READ_BUF_SIZE 8192
X#endif
X
X/* returned upon end-of-file */
X#define YY_END_TOK 0
X
X/* copy whatever the last rule matched to the standard output */
X#define ECHO (void)fwrite((genericptr_t)yytext, yyleng, 1, yyout)
X
X/* gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
X * is returned in "result".
X */
X#define YY_INPUT(buf,result,max_size) \
X	if ((result = fread((genericptr_t)buf, 1, max_size, yyin)) <= 0 && \
X	    !feof(yyin))  YY_FATAL_ERROR( "fread(yyin) in flex scanner failed" );
X#define YY_NULL 0
X
X/* no semi-colon after return; correct usage is to write "yyterminate();" */
X#define yyterminate() return ( YY_NULL )
X
X/* report a fatal error */
X#define YY_FATAL_ERROR(msg) \
X	do { \
X		(void) fputs( msg, stderr ); \
X		(void) putc( '\n', stderr ); \
X		exit( 1 ); \
X	} while ( 0 )
X
X/* default yywrap function - always treat EOF as an EOF */
X#define yywrap() 1
X
X/* enter a start condition.  This macro really ought to take a parameter,
X * but we do it the disgusting crufty way forced on us by the ()-less
X * definition of BEGIN
X */
X#define BEGIN yy_start = 1 + 2 *
X
X/* action number for EOF rule of a given start state */
X#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
X
X/* special action meaning "start processing a new file" */
X#define YY_NEW_FILE \
X	do { \
X		yy_init_buffer( yy_current_buffer, yyin ); \
X		yy_load_buffer_state(); \
X	} while ( 0 )
X
X/* default declaration of generated scanner - a define so the user can
X * easily add parameters
X */
X#define YY_DECL int NDECL(yylex)
X
X/* code executed at the end of each rule */
X#define YY_BREAK break;
X
X#define YY_END_OF_BUFFER_CHAR 0
X
X#ifndef YY_BUF_SIZE
X#define YY_BUF_SIZE (YY_READ_BUF_SIZE * 2) /* size of default input buffer */
X#endif
X
Xtypedef struct yy_buffer_state *YY_BUFFER_STATE;
X
X#define YY_CHAR char
X#define INITIAL 0
X/*	SCCS Id: @(#)lev_lex.c	3.1	93/05/27	*/
X/*	Copyright (c) 1989 by Jean-Christophe Collet */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#define LEV_LEX_C
X
X#include "hack.h"
X#include "lev_comp.h"
X#include "sp_lev.h"
X
X/* Most of these don't exist in flex, yywrap is macro and
X * yyunput is properly declared in flex.skel.
X */
X#ifndef FLEX_SCANNER
Xint FDECL (yyback, (int *, int));
Xint NDECL (yylook);
Xint NDECL (yyinput);
Xint NDECL (yywrap);
Xint NDECL (yylex);
X	/* Traditional lexes let yyunput() and yyoutput() default to int;
X	 * newer ones may declare them as void since they don't return
X	 * values.  For even more fun, the lex supplied as part of the
X	 * newer unbundled compiler for SunOS 4.x adds the void declarations
X	 * (under __STDC__ or _cplusplus ifdefs -- otherwise they remain
X	 * int) while the bundled lex and the one with the older unbundled
X	 * compiler do not.  To detect this, we need help from outside --
X	 * sys/unix/Makefile.utl.
X	 */
X# if defined(NeXT) || defined(SVR4)
X#  define VOIDYYPUT
X# endif
X# if !defined(VOIDYYPUT)
X#  if defined(POSIX_TYPES) && !defined(BOS) && !defined(HISX) && !defined(_M_UNIX)
X#   define VOIDYYPUT
X#  endif
X# endif
X# if !defined(VOIDYYPUT) && defined(WEIRD_LEX)
X#  if defined(SUNOS4) && defined(__STDC__) && (WEIRD_LEX > 1) 
X#   define VOIDYYPUT
X#  endif
X# endif
X# ifdef VOIDYYPUT
Xvoid FDECL (yyunput, (int));
Xvoid FDECL (yyoutput, (int));
X# else
Xint FDECL (yyunput, (int));
Xint FDECL (yyoutput, (int));
X# endif
X#endif	/* FLEX_SCANNER */
X
Xvoid FDECL (init_yyin, (FILE *));
Xvoid FDECL (init_yyout, (FILE *));
X
X#ifdef MICRO
X#undef exit
Xextern void FDECL(exit, (int));
X#endif
X
X/*
X * This doesn't always get put in lev_comp.h
X * (esp. when using older versions of bison).
X */
Xextern YYSTYPE yylval;
X
Xint line_number = 1, colon_line_number = 1;
X
X/*
X * This is *** UGLY *** but I can't think a better way to do it;
X * I really need a huge buffer to scan maps...
X * (This should probably be `#ifndef FLEX_SCANNER' since it's lex-specific.)
X */
X#ifdef YYLMAX
X#undef YYLMAX
X#endif
X#define YYLMAX	2048
X
X/*
X *	This is a hack required by Michael Hamel to get things
X *	working on the Mac.
X */
X#if defined(applec) && !defined(FLEX_SCANNER)
X#undef input
X#undef unput
X#define unput(c) { yytchar = (c); if (yytchar == 10) yylineno--; *yysptr++ = yytchar; }
X# ifndef YYNEWLINE
X# define YYNEWLINE 10
X# endif
X
Xchar
Xinput() {	/* Under MPW \n is chr(13)! Compensate for this. */
X
X	if (yysptr > yysbuf) return(*--yysptr);
X	else {
X		yytchar = getc(yyin);
X		if (yytchar == '\n') {
X		    yylineno++;
X		    return(YYNEWLINE);
X		}
X		if (yytchar == EOF) return(0);
X		else		    return(yytchar);
X	}
X}
X#endif	/* applec && !FLEX_SCANNER */
X
X#define MAPC 1
X
X/* done after the current pattern has been matched and before the
X * corresponding action - sets up yytext
X */
X#define YY_DO_BEFORE_ACTION \
X	yytext = yy_bp; \
X	yytext -= yy_more_len; \
X	yyleng = yy_cp - yytext; \
X	yy_hold_char = *yy_cp; \
X	*yy_cp = '\0'; \
X	yy_c_buf_p = yy_cp;
X
X#define EOB_ACT_CONTINUE_SCAN 0
X#define EOB_ACT_END_OF_FILE 1
X#define EOB_ACT_LAST_MATCH 2
X
X/* return all but the first 'n' matched characters back to the input stream */
X#define yyless(n) \
X	do { \
X		/* undo effects of setting up yytext */ \
X		*yy_cp = yy_hold_char; \
X		yy_c_buf_p = yy_cp = yy_bp + n; \
X		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
X	} while ( 0 )
X
X#define unput(c) yyunput((int)c, yytext)
X
X
Xstruct yy_buffer_state {
X    FILE *yy_input_file;
X
X    YY_CHAR *yy_ch_buf;		/* input buffer */
X    YY_CHAR *yy_buf_pos;	/* current position in input buffer */
X
X    /* size of input buffer in bytes, not including room for EOB characters */
X    int yy_buf_size;
X
X    /* number of characters read into yy_ch_buf, not including EOB characters */
X    int yy_n_chars;
X
X    int yy_eof_status;		/* whether we've seen an EOF on this buffer */
X#define EOF_NOT_SEEN 0
X    /* "pending" happens when the EOF has been seen but there's still
X     * some text process
X     */
X#define EOF_PENDING 1
X#define EOF_DONE 2
X};
X
Xstatic YY_BUFFER_STATE yy_current_buffer;
X
X/* we provide macros for accessing buffer states in case in the
X * future we want to put the buffer states in a more general
X * "scanner state"
X */
X#define YY_CURRENT_BUFFER yy_current_buffer
X
X
X/* yy_hold_char holds the character lost when yytext is formed */
Xstatic YY_CHAR yy_hold_char;
X
Xstatic int yy_n_chars;		/* number of characters read into yy_ch_buf */
X
X
X#ifndef YY_USER_ACTION
X#define YY_USER_ACTION
X#endif
X
X#ifndef YY_USER_INIT
X#define YY_USER_INIT
X#endif
X
Xextern YY_CHAR *yytext;
Xextern int yyleng;
Xextern FILE *yyin, *yyout;
X
XYY_CHAR *yytext;
Xint yyleng;
X
XFILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
X
X#define YY_END_OF_BUFFER 106
Xtypedef int yy_state_type;
Xstatic const short int yy_accept[573] =
X    {   0,
X        0,    0,    0,    0,  106,  104,  102,  101,  104,  104,
X      104,   99,    4,  104,  104,  104,  104,  104,  104,  104,
X      104,  104,  104,  104,  104,  104,  104,  104,  104,  104,
X      104,  104,  104,  104,  104,  104,  104,  104,  104,  104,
X      104,  104,  104,  104,  104,  104,  104,  104,  104,    2,
X      102,  104,  104,  104,  104,  104,  104,  104,  104,  104,
X      104,  104,  104,  102,    0,  100,    0,   99,    0,    0,
X        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
X        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
X        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
X
X        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
X        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
X        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
X        0,    0,    0,    0,    0,    0,    0,    0,   84,    0,
X        0,    3,    0,    2,  102,    0,    0,    0,    0,    0,
X        0,    0,    2,    0,  103,    0,    0,    0,    0,    0,
X        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
X        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
X        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
X        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
X
X        0,    0,    0,    0,    0,    0,    0,    0,   71,    0,
X        0,   66,    0,    0,    0,    0,    0,    0,    0,    0,
X        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
X        0,    0,    0,    0,    0,   64,    0,    0,    0,    0,
X        0,    0,    0,    0,    0,    0,    0,    0,    0,   16,
X        0,    0,    0,    0,    0,   39,    0,    0,    0,    6,
X        0,    0,   41,    0,    0,    0,   32,    0,    0,    0,
X       35,   31,    0,    0,    0,   15,    0,    0,    0,    0,
X        0,    0,    0,    0,   90,    0,    0,    0,    0,   85,
X       88,   50,    0,    0,    0,    0,    0,    0,   59,    0,
X
X        0,    0,    0,    0,   91,    0,    0,    0,    0,    0,
X       54,    0,    0,    0,   44,    0,    0,    0,    0,    0,
X        0,    0,    0,   87,    0,    0,    0,   52,   12,    0,
X        0,   24,    0,    0,    0,    0,    0,   10,    0,    0,
X        0,    0,    8,    0,    0,    0,    7,    0,    0,    0,
X        0,    0,    0,   26,    0,    0,    0,   58,   83,    0,
X       77,    0,    0,    0,    0,   73,    0,    0,    0,   86,
X        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
X        0,    0,    0,    0,   49,    0,    0,    0,   57,    0,
X       63,    0,    0,    0,   51,    0,    0,   67,    0,    0,
X
X       29,   42,    0,    0,    0,    0,    0,    0,   25,    0,
X        0,    0,    0,    0,   13,   27,    0,   20,    0,    0,
X        0,   76,    0,   65,   48,   61,   45,   94,    0,   68,
X        0,    0,    0,    0,    0,   46,    0,    0,    0,    0,
X        0,    0,   47,   97,    0,   55,    0,   53,    0,    0,
X       82,    0,    0,    1,    0,    0,    0,    0,    0,    0,
X        0,    5,   14,    0,    0,    0,   36,    0,   19,   92,
X       89,    0,    0,    0,   75,    0,    0,    0,    0,   56,
X       72,   70,    0,    0,   81,    0,    0,    0,   38,    0,
X        0,   30,   11,    9,   18,    0,    0,    0,    0,    0,
X
X        0,    0,    0,    0,    0,    0,    0,    0,   80,    0,
X       74,    0,   93,   69,    0,   40,    0,    0,    0,    0,
X        0,    0,    0,   60,    0,   96,   43,   78,   79,    0,
X        0,   17,    0,    0,    0,    0,    0,    0,    0,   62,
X       95,    0,    0,    0,    0,    0,    0,    0,    0,    0,
X       33,   34,    0,    0,    0,    0,    0,   98,    0,    0,
X        0,   23,    0,    0,    0,   21,    0,    0,   22,   28,
X       37,    0
X    } ;
X
Xstatic const YY_CHAR yy_ec[128] =
X    {   0,
X        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    4,    1,    5,    6,    1,    1,    1,    7,    1,
X        1,    1,    8,    1,    9,   10,    1,   11,   11,   11,
X       11,   11,   11,   11,   11,   11,   11,   12,    1,    1,
X        1,    1,    1,    1,   13,   14,   15,   16,   17,   18,
X       19,   20,   21,   22,   23,   24,   25,   26,   27,   28,
X        1,   29,   30,   31,   32,   33,   34,    1,   35,   36,
X        1,   10,    1,    1,   37,    1,   38,   39,   40,   41,
X
X       42,   43,   44,   45,   46,   47,   48,   49,   50,   51,
X       52,   53,    1,   54,   55,   56,   57,   58,   59,    1,
X        1,    1,   10,   10,   10,    1,    1
X    } ;
X
Xstatic const YY_CHAR yy_meta[60] =
X    {   0,
X        1,    2,    3,    2,    1,    2,    1,    2,    2,    2,
X        1,    1,    2,    2,    2,    1,    1,    1,    1,    2,
X        2,    1,    2,    2,    1,    1,    1,    2,    1,    2,
X        1,    1,    1,    2,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    1,    1,    1,    1
X    } ;
X
Xstatic const short int yy_base[577] =
X    {   0,
X        0,   54,   77,   57,  674,  675,   60,  675,  668,    0,
X      661,  660,  675,  646,  640,   41,   38,  642,   42,   57,
X      641,   58,   76,   75,  652,  638,   82,   83,   79,  651,
X       57,   68,   79,   20,   72,   32,   75,   88,   81,   87,
X       92,   93,  100,   99,   89,   96,  621,  659,  135,  675,
X      151,  154,  156,  158,  161,  166,  635,  163,  168,  152,
X      156,  161,  191,  171,  655,  675,  652,  647,  626,  643,
X      642,  625,  626,  639,  632,  637,  617,  621,  623,  625,
X      629,  611,  607,  612,  615,  615,  166,  617,  169,  612,
X      618,  609,  609,  621,  619,  608,  618,  606,  157,  580,
X
X      590,  585,  570,  573,  570,  572,  584,  569,  566,  560,
X      563,  562,  572,  566,  565,  153,  558,  553,  165,  555,
X      570,  166,  555,  557,  550,  179,  559,  563,  566,  565,
X      551,  557,  549,  170,  542,  545,  540,  188,  675,  541,
X      592,  675,  198,  675,  236,  239,  241,  167,   57,  232,
X      233,  234,  675,    0,  675,  581,  567,  566,  562,  561,
X      555,  559,  568,  560,  560,  568,  552,  566,  564,  563,
X      549,  548,  560,  563,  538,  557,  549,  541,  555,  549,
X      544,  545,  546,  537,  548,  536,  539,  518,  523,  518,
X      511,  503,  501,  508,  504,  498,  501,  497,  496,  499,
X
X      493,  492,  493,  491,  496,  501,  502,  486,  675,  485,
X      486,  675,  491,  496,  485,  497,  487,  479,  477,  483,
X      479,  480,  487,  472,  485,  484,  474,  484,  483,  481,
X      476,  480,  465,  472,  461,  675,  474,  458,  468,  467,
X      456,  508,  239,  485,  240,  480,  493,  492,  485,  675,
X      491,  491,  473,  471,  484,  675,  463,  482,  474,  463,
X      483,  464,  675,  466,  238,  478,  675,  479,  464,  463,
X      675,  675,  460,  461,  459,  675,  465,  434,  430,  441,
X      440,  426,  428,  437,  675,  436,  422,  434,  433,  675,
X      675,  675,  436,  431,  430,  462,  427,  423,  675,  426,
X
X      425,  428,  414,  417,  675,  407,  408,  415,  408,  421,
X      675,  413,  408,  416,  675,  413,  412,  401,  396,  395,
X      394,  398,  403,  675,  393,  397,  389,  675,  675,  431,
X      250,  675,  423,  425,  425,  411,  406,  675,  425,  406,
X      411,  406,  675,  421,  414,  415,  675,  410,  417,  398,
X      404,  402,  400,  675,  398,  397,  405,  675,  675,  369,
X      675,  379,  370,  368,  364,  675,  376,  375,  357,  675,
X      373,  178,  364,  363,  367,  369,  353,  353,  365,  364,
X      367,  360,  349,  349,  675,  359,  344,  356,  675,  348,
X      675,  340,  341,  353,  675,  339,  344,  675,  364,  256,
X
X      675,  675,  364,  369,  368,  367,  358,  373,  675,  361,
X      367,  354,  363,  351,  675,  675,  343,  675,  354,  349,
X      342,  675,  335,  675,  675,  675,  675,  675,  333,  675,
X      332,  327,  320,  329,  324,  675,  312,  312,  327,  312,
X      316,  313,  675,  675,  310,  675,  305,  675,  311,  314,
X      675,  317,  316,  675,  328,  340,  329,  328,  318,  324,
X      328,  675,  675,  331,  319,  253,  675,  317,  675,  675,
X      675,  304,  302,  293,  675,  292,  289,  300,  285,  675,
X      675,  675,  288,  290,  675,  294,  296,  295,  675,  316,
X      315,  675,  675,  675,  675,  320,  298,  304,  303,  315,
X
X      304,  290,  270,  280,  270,  272,  280,  267,  675,  266,
X      675,  274,  675,  675,  301,  675,  303,  303,  286,  288,
X      291,  299,  282,  675,  254,  675,  675,  675,  675,  253,
X      252,  675,  283,  282,  276,  274,  286,  287,  284,  675,
X      675,  258,  282,  274,  276,  265,  280,  277,  274,  251,
X      675,  675,  263,  260,  245,  245,  249,  675,  235,  232,
X      230,  675,  228,  207,  180,  675,  124,  102,  675,  675,
X      675,  675,  281,  284,  286,  288
X    } ;
X
Xstatic const short int yy_def[577] =
X    {   0,
X      572,    1,    1,    3,  572,  572,  572,  572,  573,  574,
X      572,  572,  572,  572,  572,  572,  572,  572,  572,  572,
X      572,  572,  572,  572,  572,  572,  572,  572,  572,  572,
X      572,  572,  572,  572,  572,  572,  572,  572,  572,  572,
X      572,  572,  572,  572,  572,  572,  572,  575,  572,  572,
X      576,  576,  576,  576,  576,  576,  572,  576,  576,   56,
X       56,   59,  575,  572,  573,  572,  572,  572,  572,  572,
X      572,  572,  572,  572,  572,  572,  572,  572,  572,  572,
X      572,  572,  572,  572,  572,  572,  572,  572,  572,  572,
X      572,  572,  572,  572,  572,  572,  572,  572,  572,  572,
X
X      572,  572,  572,  572,  572,  572,  572,  572,  572,  572,
X      572,  572,  572,  572,  572,  572,  572,  572,  572,  572,
X      572,  572,  572,  572,  572,  572,  572,  572,  572,  572,
X      572,  572,  572,  572,  572,  572,  572,  572,  572,  572,
X      575,  572,  572,  572,  576,  576,  576,   59,  572,   59,
X       59,   59,  572,   63,  572,  572,  572,  572,  572,  572,
X      572,  572,  572,  572,  572,  572,  572,  572,  572,  572,
X      572,  572,  572,  572,  572,  572,  572,  572,  572,  572,
X      572,  572,  572,  572,  572,  572,  572,  572,  572,  572,
X      572,  572,  572,  572,  572,  572,  572,  572,  572,  572,
X
X      572,  572,  572,  572,  572,  572,  572,  572,  572,  572,
X      572,  572,  572,  572,  572,  572,  572,  572,  572,  572,
X      572,  572,  572,  572,  572,  572,  572,  572,  572,  572,
X      572,  572,  572,  572,  572,  572,  572,  572,  572,  572,
X      572,  572,   59,  572,   59,  572,  572,  572,  572,  572,
X      572,  572,  572,  572,  572,  572,  572,  572,  572,  572,
X      572,  572,  572,  572,  572,  572,  572,  572,  572,  572,
X      572,  572,  572,  572,  572,  572,  572,  572,  572,  572,
X      572,  572,  572,  572,  572,  572,  572,  572,  572,  572,
X      572,  572,  572,  572,  572,  572,  572,  572,  572,  572,
X
X      572,  572,  572,  572,  572,  572,  572,  572,  572,  572,
X      572,  572,  572,  572,  572,  572,  572,  572,  572,  572,
X      572,  572,  572,  572,  572,  572,  572,  572,  572,  572,
X       59,  572,  572,  572,  572,  572,  572,  572,  572,  572,
X      572,  572,  572,  572,  572,  572,  572,  572,  572,  572,
X      572,  572,  572,  572,  572,  572,  572,  572,  572,  572,
X      572,  572,  572,  572,  572,  572,  572,  572,  572,  572,
X      572,  572,  572,  572,  572,  572,  572,  572,  572,  572,
X      572,  572,  572,  572,  572,  572,  572,  572,  572,  572,
X      572,  572,  572,  572,  572,  572,  572,  572,  572,   59,
X
X      572,  572,  572,  572,  572,  572,  572,  572,  572,  572,
X      572,  572,  572,  572,  572,  572,  572,  572,  572,  572,
X      572,  572,  572,  572,  572,  572,  572,  572,  572,  572,
X      572,  572,  572,  572,  572,  572,  572,  572,  572,  572,
X      572,  572,  572,  572,  572,  572,  572,  572,  572,  572,
X      572,  572,  572,  572,  572,  572,  572,  572,  572,  572,
X      572,  572,  572,  572,  572,  572,  572,  572,  572,  572,
X      572,  572,  572,  572,  572,  572,  572,  572,  572,  572,
X      572,  572,  572,  572,  572,  572,  572,  572,  572,  572,
X      572,  572,  572,  572,  572,  572,  572,  572,  572,  572,
X
X      572,  572,  572,  572,  572,  572,  572,  572,  572,  572,
X      572,  572,  572,  572,  572,  572,  572,  572,  572,  572,
X      572,  572,  572,  572,  572,  572,  572,  572,  572,  572,
X      572,  572,  572,  572,  572,  572,  572,  572,  572,  572,
X      572,  572,  572,  572,  572,  572,  572,  572,  572,  572,
X      572,  572,  572,  572,  572,  572,  572,  572,  572,  572,
X      572,  572,  572,  572,  572,  572,  572,  572,  572,  572,
X      572,    0,  572,  572,  572,  572
X    } ;
X
Xstatic const short int yy_nxt[735] =
X    {   0,
X        6,    7,    8,    7,    9,    6,   10,   11,   11,    6,
X       12,   13,   14,   15,   16,   17,   18,   19,   20,    6,
X       21,    6,    6,   22,   23,   24,   25,   26,   27,   28,
X       29,    6,    6,   30,    6,    6,    6,   31,   32,   33,
X       34,   35,   36,    6,   37,    6,    6,    6,   38,   39,
X       40,   41,   42,   43,   44,   45,   46,    6,   47,   48,
X       71,   64,   63,   64,   73,   76,   74,   72,   77,  114,
X       81,  110,  244,   78,   82,  162,  111,  115,   49,   50,
X       51,   49,   52,   79,   53,   53,   52,   86,   83,   54,
X       55,   56,   84,   57,   90,   96,   52,   58,   91,   52,
X
X       59,   87,   85,   93,   60,   99,   61,   97,   92,  112,
X       62,  100,  116,   94,   95,  101,  102,  122,  123,  103,
X      106,  104,  113,  107,  105,  118,  117,  108,  125,  119,
X      127,  571,  124,  120,  129,  109,  133,  131,  126,  121,
X      136,  130,  137,  134,  128,  132,  138,  143,  139,  570,
X      135,   84,   64,  144,  145,  572,  144,  572,  144,  572,
X      144,   85,  572,  144,  572,  144,   68,  572,  144,  572,
X      144,  146,   64,  152,   64,  146,  151,  572,   89,  243,
X      150,  147,  572,  572,   82,  148,   94,   95,   80,   70,
X      174,  175,   72,  153,  154,  177,  154,  178,  154,  154,
X
X      154,  206,  188,  154,  154,  154,  207,  210,  214,  569,
X      154,  154,  189,  154,  154,  215,  220,  216,  154,  221,
X      154,  233,  211,  234,  154,  242,  431,  238,  222,  223,
X      239,  432,  224,  170,  225,  568,  240,   64,  144,  145,
X      572,  144,  572,  144,  146,  146,  146,  168,  572,  572,
X      572,  146,  146,  348,  567,  572,  572,  245,  182,  566,
X      565,  564,  146,  331,  248,  349,  572,  498,  146,  563,
X      400,  156,  572,  421,  562,  561,  560,  499,  559,  500,
X      501,   65,   65,   65,   67,   67,  141,  141,  141,  146,
X      146,  558,  557,  556,  555,  554,  553,  552,  551,  550,
X
X      549,  548,  547,  546,  545,  544,  543,  542,  541,  540,
X      539,  538,  537,  536,  535,  534,  533,  532,  531,  530,
X      529,  528,  527,  526,  525,  524,  523,  522,  521,  520,
X      519,  518,  517,  516,  515,  514,  513,  512,  511,  510,
X      509,  508,  507,  506,  505,  504,  503,  502,  497,  496,
X      495,  494,  493,  492,  491,  490,  489,  488,  487,  486,
X      485,  484,  483,  482,  481,  480,  479,  478,  477,  476,
X      475,  474,  473,  472,  471,  470,  469,  468,  467,  466,
X      465,  464,  463,  462,  461,  460,  459,  458,  457,  456,
X      455,  454,  453,  452,  451,  450,  449,  448,  447,  446,
X
X      445,  444,  443,  442,  441,  440,  439,  438,  437,  436,
X      435,  434,  433,  430,  429,  428,  427,  426,  425,  424,
X      423,  422,  421,  420,  419,  418,  417,  416,  415,  414,
X      413,  412,  411,  410,  409,  408,  407,  406,  405,  404,
X      403,  402,  401,  399,  398,  397,  396,  395,  394,  393,
X      392,  391,  390,  389,  388,  387,  386,  385,  384,  383,
X      382,  381,  380,  379,  378,  377,  376,  375,  374,  373,
X      372,  371,  370,  369,  368,  367,  366,  365,  364,  363,
X      362,  361,  360,  359,  358,  357,  356,  355,  354,  353,
X      352,  351,  350,  347,  346,  345,  344,  343,  342,  341,
X
X      340,  339,  338,  337,  336,  335,  334,  333,  332,  330,
X      329,  328,  327,  326,  325,  324,  323,  322,  321,  320,
X      319,  318,  317,  316,  315,  314,  313,  312,  311,  310,
X      309,  308,  307,  306,  305,  304,  303,  302,  301,  300,
X      299,  298,  297,  296,  295,  294,  293,  292,  291,  290,
X      289,  288,  287,  286,  285,  284,  283,  282,  281,  280,
X      279,  278,  277,  276,  275,  274,  273,  272,  271,  270,
X      269,  268,  267,  266,  265,  264,  263,  262,  261,  260,
X      259,  258,  257,  256,  255,  254,  253,  252,  251,  250,
X      249,  248,  247,  246,  142,  241,  237,  236,  235,  232,
X
X      231,  230,  229,  228,  227,  226,  219,  218,  217,  213,
X      212,  209,  208,  205,  204,  203,  202,  201,  200,  199,
X      198,  197,  196,  195,  194,  193,  192,  191,  190,  187,
X      186,  185,  184,  183,  182,  181,  180,  179,  176,  173,
X      172,  171,  170,  169,  168,  167,  166,  165,  164,  163,
X      162,  161,  160,  159,  158,  157,  156,   68,  155,   66,
X      149,  142,  140,   98,   89,   88,   80,   75,   70,   69,
X       68,   68,   66,  572,    5,  572,  572,  572,  572,  572,
X      572,  572,  572,  572,  572,  572,  572,  572,  572,  572,
X      572,  572,  572,  572,  572,  572,  572,  572,  572,  572,
X
X      572,  572,  572,  572,  572,  572,  572,  572,  572,  572,
X      572,  572,  572,  572,  572,  572,  572,  572,  572,  572,
X      572,  572,  572,  572,  572,  572,  572,  572,  572,  572,
X      572,  572,  572,  572
X    } ;
X
Xstatic const short int yy_chk[735] =
X    {   0,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    2,
X       16,    7,    4,    7,   17,   19,   17,   16,   19,   36,
X       22,   34,  149,   20,   22,  149,   34,   36,    2,    3,
X        3,    4,    3,   20,    3,    3,    3,   24,   23,    3,
X        3,    3,   23,    3,   27,   29,    3,    3,   27,    3,
X
X        3,   24,   23,   28,    3,   31,    3,   29,   27,   35,
X        3,   31,   37,   28,   28,   31,   32,   39,   39,   32,
X       33,   32,   35,   33,   32,   38,   37,   33,   40,   38,
X       41,  568,   39,   38,   42,   33,   44,   43,   40,   38,
X       45,   42,   45,   44,   41,   43,   46,   49,   46,  567,
X       44,   49,   51,   51,   51,   52,   52,   53,   53,   54,
X       54,   49,   55,   55,   58,   58,   53,   56,   56,   59,
X       59,   60,   64,   62,   64,   61,   61,   62,   60,  148,
X       59,   54,   61,  148,   59,   56,   61,   61,   58,   55,
X       87,   87,   56,   63,   63,   89,   63,   89,   63,   63,
X
X       63,  116,   99,   63,   63,   63,  116,  119,  122,  565,
X       63,   63,   99,   63,   63,  122,  126,  122,   63,  126,
X       63,  134,  119,  134,   63,  143,  372,  138,  126,  126,
X      138,  372,  126,  143,  126,  564,  138,  145,  145,  145,
X      146,  146,  147,  147,  150,  151,  152,  150,  150,  151,
X      152,  243,  245,  265,  563,  243,  245,  152,  151,  561,
X      560,  559,  331,  245,  243,  265,  331,  466,  400,  557,
X      331,  147,  400,  400,  556,  555,  554,  466,  553,  466,
X      466,  573,  573,  573,  574,  574,  575,  575,  575,  576,
X      576,  550,  549,  548,  547,  546,  545,  544,  543,  542,
X
X      539,  538,  537,  536,  535,  534,  533,  531,  530,  525,
X      523,  522,  521,  520,  519,  518,  517,  515,  512,  510,
X      508,  507,  506,  505,  504,  503,  502,  501,  500,  499,
X      498,  497,  496,  491,  490,  488,  487,  486,  484,  483,
X      479,  478,  477,  476,  474,  473,  472,  468,  465,  464,
X      461,  460,  459,  458,  457,  456,  455,  453,  452,  450,
X      449,  447,  445,  442,  441,  440,  439,  438,  437,  435,
X      434,  433,  432,  431,  429,  423,  421,  420,  419,  417,
X      414,  413,  412,  411,  410,  408,  407,  406,  405,  404,
X      403,  399,  397,  396,  394,  393,  392,  390,  388,  387,
X
X      386,  384,  383,  382,  381,  380,  379,  378,  377,  376,
X      375,  374,  373,  371,  369,  368,  367,  365,  364,  363,
X      362,  360,  357,  356,  355,  353,  352,  351,  350,  349,
X      348,  346,  345,  344,  342,  341,  340,  339,  337,  336,
X      335,  334,  333,  330,  327,  326,  325,  323,  322,  321,
X      320,  319,  318,  317,  316,  314,  313,  312,  310,  309,
X      308,  307,  306,  304,  303,  302,  301,  300,  298,  297,
X      296,  295,  294,  293,  289,  288,  287,  286,  284,  283,
X      282,  281,  280,  279,  278,  277,  275,  274,  273,  270,
X      269,  268,  266,  264,  262,  261,  260,  259,  258,  257,
X
X      255,  254,  253,  252,  251,  249,  248,  247,  246,  244,
X      242,  241,  240,  239,  238,  237,  235,  234,  233,  232,
X      231,  230,  229,  228,  227,  226,  225,  224,  223,  222,
X      221,  220,  219,  218,  217,  216,  215,  214,  213,  211,
X      210,  208,  207,  206,  205,  204,  203,  202,  201,  200,
X      199,  198,  197,  196,  195,  194,  193,  192,  191,  190,
X      189,  188,  187,  186,  185,  184,  183,  182,  181,  180,
X      179,  178,  177,  176,  175,  174,  173,  172,  171,  170,
X      169,  168,  167,  166,  165,  164,  163,  162,  161,  160,
X      159,  158,  157,  156,  141,  140,  137,  136,  135,  133,
X
X      132,  131,  130,  129,  128,  127,  125,  124,  123,  121,
X      120,  118,  117,  115,  114,  113,  112,  111,  110,  109,
X      108,  107,  106,  105,  104,  103,  102,  101,  100,   98,
X       97,   96,   95,   94,   93,   92,   91,   90,   88,   86,
X       85,   84,   83,   82,   81,   80,   79,   78,   77,   76,
X       75,   74,   73,   72,   71,   70,   69,   68,   67,   65,
X       57,   48,   47,   30,   26,   25,   21,   18,   15,   14,
X       12,   11,    9,    5,  572,  572,  572,  572,  572,  572,
X      572,  572,  572,  572,  572,  572,  572,  572,  572,  572,
X      572,  572,  572,  572,  572,  572,  572,  572,  572,  572,
X
X      572,  572,  572,  572,  572,  572,  572,  572,  572,  572,
X      572,  572,  572,  572,  572,  572,  572,  572,  572,  572,
X      572,  572,  572,  572,  572,  572,  572,  572,  572,  572,
X      572,  572,  572,  572
X    } ;
X
Xstatic yy_state_type yy_last_accepting_state;
Xstatic YY_CHAR *yy_last_accepting_cpos;
X
X/* the intent behind this definition is that it'll catch
X * any uses of REJECT which flex missed
X */
X#define REJECT reject_used_but_not_detected
Xstatic int yy_more_flag = 0;
Xstatic int yy_doing_yy_more = 0;
Xstatic int yy_more_len = 0;
X#define yymore() { yy_more_flag = 1; }
X#define YY_MORE_ADJ (yy_doing_yy_more ? yy_more_len : 0)
X
X/* these variables are all declared out here so that section 3 code can
X * manipulate them
X */
X/* points to current character in buffer */
Xstatic YY_CHAR *yy_c_buf_p = (YY_CHAR *) 0;
Xstatic int yy_init = 1;		/* whether we need to initialize */
Xstatic int yy_start = 0;	/* start state number */
X
X/* flag which is used to allow yywrap()'s to do buffer switches
X * instead of setting up a fresh yyin.  A bit of a hack ...
X */
Xstatic int yy_did_buffer_switch_on_eof;
X
Xstatic yy_state_type NDECL(yy_get_previous_state);
Xstatic yy_state_type FDECL(yy_try_NUL_trans, (yy_state_type));
Xstatic int NDECL(yy_get_next_buffer);
X#if 0		/* not needed for NetHack */
Xstatic int NDECL(yyinput);
Xstatic void FDECL(yyunput, (int,YY_CHAR *));
X#endif
Xvoid FDECL(yyrestart, (FILE *));
Xvoid FDECL(yy_switch_to_buffer, (YY_BUFFER_STATE));
Xvoid NDECL(yy_load_buffer_state);
XYY_BUFFER_STATE FDECL(yy_create_buffer, (FILE *,int));
Xvoid FDECL(yy_delete_buffer, (YY_BUFFER_STATE));
Xvoid FDECL(yy_init_buffer, (YY_BUFFER_STATE,FILE *));
X
X#define yy_new_buffer yy_create_buffer
X
XYY_DECL
X{
X    register yy_state_type yy_current_state;
X    register YY_CHAR *yy_cp, *yy_bp;
X    register int yy_act;
X
X
X
X    if ( yy_init )
X	{
X	YY_USER_INIT;
X
X	if ( ! yy_start )
X	    yy_start = 1;	/* first start state */
X
X	if ( ! yyin )
X	    yyin = stdin;
X
X	if ( ! yyout )
X	    yyout = stdout;
X
X	if ( yy_current_buffer )
X	    yy_init_buffer( yy_current_buffer, yyin );
X	else
X	    yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );
X
X	yy_load_buffer_state();
X
X	yy_init = 0;
X	}
X
X    while ( 1 )		/* loops until end-of-file is reached */
X	{
X	yy_more_len = 0;
X	yy_doing_yy_more = yy_more_flag;
X	if ( yy_doing_yy_more )
X	    {
X	    yy_more_len = yyleng;
X	    yy_more_flag = 0;
X	    }
X	yy_cp = yy_c_buf_p;
X
X	/* support of yytext */
X	*yy_cp = yy_hold_char;
X
X	/* yy_bp points to the position in yy_ch_buf of the start of the
X	 * current run.
X	 */
X	yy_bp = yy_cp;
X
X	yy_current_state = yy_start;
X	if ( yy_bp[-1] == '\n' )
X	    ++yy_current_state;
Xyy_match:
X	do
X	    {
X	    register YY_CHAR yy_c = yy_ec[*yy_cp];
X	    if ( yy_accept[yy_current_state] )
X		{
X		yy_last_accepting_state = yy_current_state;
X		yy_last_accepting_cpos = yy_cp;
X		}
X	    while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
X		{
X		yy_current_state = yy_def[yy_current_state];
X		if ( yy_current_state >= 573 )
X		    yy_c = yy_meta[yy_c];
X		}
X	    yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
X	    ++yy_cp;
X	    }
X	while ( yy_current_state != 572 );
X	yy_cp = yy_last_accepting_cpos;
X	yy_current_state = yy_last_accepting_state;
X
Xyy_find_action:
X	yy_act = yy_accept[yy_current_state];
X
X	YY_DO_BEFORE_ACTION;
X	YY_USER_ACTION;
X
Xdo_action:	/* this label is used only to access EOF actions */
X
X
X	switch ( yy_act )
X	    {
X	    case 0: /* must backtrack */
X	    /* undo the effects of YY_DO_BEFORE_ACTION */
X	    *yy_cp = yy_hold_char;
X	    yy_cp = yy_last_accepting_cpos;
X	    yy_current_state = yy_last_accepting_state;
X	    goto yy_find_action;
X
Xcase 1:
X{
X#ifdef FLEX23_BUG
X		  /*
X		   * There is a bug in Flex 2.3 patch level < 6
X		   * (absent in previous versions)
X		   * that results in the following behaviour :
X		   * Once you enter an yymore(), you never exit from it.
X		   * This should do the trick!
X		   */
X		  extern int yy_more_len;
X
X		  yy_more_len = 0;
X#endif
X		  BEGIN(INITIAL);
X		  yylval.map = (char *) alloc(yyleng-5);
X		  strncpy(yylval.map, yytext,yyleng-6);
X		  yylval.map[yyleng-6] = 0;
X		  return MAP_ID;
X		}
X	YY_BREAK
Xcase 2:
X{ line_number++; yymore(); }
X	YY_BREAK
Xcase 3:
X{ line_number++; }
X	YY_BREAK
Xcase 4:
X{ colon_line_number = line_number; return ':'; }
X	YY_BREAK
Xcase 5:
Xreturn MESSAGE_ID;
X	YY_BREAK
Xcase 6:
Xreturn MAZE_ID;
X	YY_BREAK
Xcase 7:
Xreturn NOMAP_ID;
X	YY_BREAK
Xcase 8:
Xreturn LEVEL_ID;
X	YY_BREAK
Xcase 9:
Xreturn LEV_INIT_ID;
X	YY_BREAK
Xcase 10:
Xreturn FLAGS_ID;
X	YY_BREAK
Xcase 11:
Xreturn GEOMETRY_ID;
X	YY_BREAK
Xcase 12:
X{ BEGIN(MAPC); line_number++; }
X	YY_BREAK
Xcase 13:
Xreturn OBJECT_ID;
X	YY_BREAK
Xcase 14:
Xreturn MONSTER_ID;
X	YY_BREAK
Xcase 15:
Xreturn TRAP_ID;
X	YY_BREAK
Xcase 16:
Xreturn DOOR_ID;
X	YY_BREAK
Xcase 17:
Xreturn DRAWBRIDGE_ID;
X	YY_BREAK
Xcase 18:
Xreturn MAZEWALK_ID;
X	YY_BREAK
Xcase 19:
Xreturn WALLIFY_ID;
X	YY_BREAK
Xcase 20:
Xreturn REGION_ID;
X	YY_BREAK
Xcase 21:
Xreturn RANDOM_OBJECTS_ID;
X	YY_BREAK
Xcase 22:
Xreturn RANDOM_MONSTERS_ID;
X	YY_BREAK
Xcase 23:
Xreturn RANDOM_PLACES_ID;
X	YY_BREAK
Xcase 24:
Xreturn ALTAR_ID;
X	YY_BREAK
Xcase 25:
Xreturn LADDER_ID;
X	YY_BREAK
Xcase 26:
Xreturn STAIR_ID;
X	YY_BREAK
Xcase 27:
Xreturn PORTAL_ID;
X	YY_BREAK
Xcase 28:
Xreturn TELEPRT_ID;
X	YY_BREAK
Xcase 29:
Xreturn BRANCH_ID;
X	YY_BREAK
Xcase 30:
Xreturn FOUNTAIN_ID;
X	YY_BREAK
Xcase 31:
Xreturn SINK_ID;
X	YY_BREAK
Xcase 32:
Xreturn POOL_ID;
X	YY_BREAK
Xcase 33:
Xreturn NON_DIGGABLE_ID;
X	YY_BREAK
Xcase 34:
Xreturn NON_PASSWALL_ID;
X	YY_BREAK
Xcase 35:
Xreturn ROOM_ID;
X	YY_BREAK
Xcase 36:
Xreturn SUBROOM_ID;
X	YY_BREAK
Xcase 37:
Xreturn RAND_CORRIDOR_ID;
X	YY_BREAK
Xcase 38:
Xreturn CORRIDOR_ID;
X	YY_BREAK
Xcase 39:
Xreturn GOLD_ID;
X	YY_BREAK
Xcase 40:
Xreturn ENGRAVING_ID;
X	YY_BREAK
Xcase 41:
Xreturn NAME_ID;
X	YY_BREAK
Xcase 42:
Xreturn CHANCE_ID;
X	YY_BREAK
Xcase 43:
Xreturn LEV;
X	YY_BREAK
Xcase 44:
X{ yylval.i=D_ISOPEN; return DOOR_STATE; }
X	YY_BREAK
Xcase 45:
X{ yylval.i=D_CLOSED; return DOOR_STATE; }
X	YY_BREAK
Xcase 46:
X{ yylval.i=D_LOCKED; return DOOR_STATE; }
X	YY_BREAK
Xcase 47:
X{ yylval.i=D_NODOOR; return DOOR_STATE; }
X	YY_BREAK
Xcase 48:
X{ yylval.i=D_BROKEN; return DOOR_STATE; }
X	YY_BREAK
Xcase 49:
X{ yylval.i=W_NORTH; return DIRECTION; }
X	YY_BREAK
Xcase 50:
X{ yylval.i=W_EAST; return DIRECTION; }
X	YY_BREAK
Xcase 51:
X{ yylval.i=W_SOUTH; return DIRECTION; }
X	YY_BREAK
Xcase 52:
X{ yylval.i=W_WEST; return DIRECTION; }
X	YY_BREAK
Xcase 53:
X{ yylval.i = -1; return RANDOM_TYPE; }
X	YY_BREAK
Xcase 54:
X{ yylval.i = -2; return NONE; }
X	YY_BREAK
Xcase 55:
Xreturn O_REGISTER;
X	YY_BREAK
Xcase 56:
Xreturn M_REGISTER;
X	YY_BREAK
Xcase 57:
Xreturn P_REGISTER;
X	YY_BREAK
Xcase 58:
Xreturn A_REGISTER;
X	YY_BREAK
Xcase 59:
X{ yylval.i=1; return LEFT_OR_RIGHT; }
X	YY_BREAK
Xcase 60:
X{ yylval.i=2; return LEFT_OR_RIGHT; }
X	YY_BREAK
Xcase 61:
X{ yylval.i=3; return CENTER; }
X	YY_BREAK
Xcase 62:
X{ yylval.i=4; return LEFT_OR_RIGHT; }
X	YY_BREAK
Xcase 63:
X{ yylval.i=5; return LEFT_OR_RIGHT; }
X	YY_BREAK
Xcase 64:
X{ yylval.i=1; return TOP_OR_BOT; }
X	YY_BREAK
Xcase 65:
X{ yylval.i=5; return TOP_OR_BOT; }
X	YY_BREAK
Xcase 66:
X{ yylval.i=1; return LIGHT_STATE; }
X	YY_BREAK
Xcase 67:
X{ yylval.i=0; return LIGHT_STATE; }
X	YY_BREAK
Xcase 68:
X{ yylval.i=0; return FILLING; }
X	YY_BREAK
Xcase 69:
X{ yylval.i=1; return FILLING; }
X	YY_BREAK
Xcase 70:
X{ yylval.i= AM_NONE; return ALIGNMENT; }
X	YY_BREAK
Xcase 71:
X{ yylval.i= AM_LAWFUL; return ALIGNMENT; }
X	YY_BREAK
Xcase 72:
X{ yylval.i= AM_NEUTRAL; return ALIGNMENT; }
X	YY_BREAK
Xcase 73:
X{ yylval.i= AM_CHAOTIC; return ALIGNMENT; }
X	YY_BREAK
Xcase 74:
X{ yylval.i=1; return MON_ATTITUDE; }
X	YY_BREAK
Xcase 75:
X{ yylval.i=0; return MON_ATTITUDE; }
X	YY_BREAK
Xcase 76:
X{ yylval.i=1; return MON_ALERTNESS; }
X	YY_BREAK
Xcase 77:
X{ yylval.i=0; return MON_ALERTNESS; }
X	YY_BREAK
Xcase 78:
X{ yylval.i= M_AP_FURNITURE; return MON_APPEARANCE; }
X	YY_BREAK
Xcase 79:
X{ yylval.i= M_AP_MONSTER;   return MON_APPEARANCE; }
X	YY_BREAK
Xcase 80:
X{ yylval.i= M_AP_OBJECT;    return MON_APPEARANCE; }
X	YY_BREAK
Xcase 81:
X{ yylval.i=2; return ALTAR_TYPE; }
X	YY_BREAK
Xcase 82:
X{ yylval.i=1; return ALTAR_TYPE; }
X	YY_BREAK
Xcase 83:
X{ yylval.i=0; return ALTAR_TYPE; }
X	YY_BREAK
Xcase 84:
X{ yylval.i=1; return UP_OR_DOWN; }
X	YY_BREAK
Xcase 85:
X{ yylval.i=0; return UP_OR_DOWN; }
X	YY_BREAK
Xcase 86:
X{ yylval.i=0; return BOOLEAN; }
X	YY_BREAK
Xcase 87:
X{ yylval.i=1; return BOOLEAN; }
X	YY_BREAK
Xcase 88:
X{ yylval.i=DUST; return ENGRAVING_TYPE; }
X	YY_BREAK
Xcase 89:
X{ yylval.i=ENGRAVE; return ENGRAVING_TYPE; }
X	YY_BREAK
Xcase 90:
X{ yylval.i=BURN; return ENGRAVING_TYPE; }
X	YY_BREAK
Xcase 91:
X{ yylval.i=MARK; return ENGRAVING_TYPE; }
X	YY_BREAK
Xcase 92:
X{ yylval.i=1; return CURSE_TYPE; }
X	YY_BREAK
Xcase 93:
X{ yylval.i=2; return CURSE_TYPE; }
X	YY_BREAK
Xcase 94:
X{ yylval.i=3; return CURSE_TYPE; }
X	YY_BREAK
Xcase 95:
X{ yylval.i=NOTELEPORT; return FLAG_TYPE; }
X	YY_BREAK
Xcase 96:
X{ yylval.i=HARDFLOOR; return FLAG_TYPE; }
X	YY_BREAK
Xcase 97:
X{ yylval.i=NOMMAP; return FLAG_TYPE; }
X	YY_BREAK
Xcase 98:
X{ yylval.i=SHORTSIGHTED; return FLAG_TYPE; }
X	YY_BREAK
Xcase 99:
X{ yylval.i=atoi(yytext); return INTEGER; }
X	YY_BREAK
Xcase 100:
X{ yytext[yyleng-1] = 0; /* Discard the trailing \" */
X		  yylval.map = (char *) alloc(strlen(yytext+1)+1);
X		  strcpy(yylval.map, yytext+1); /* Discard the first \" */
X		  return STRING; }
X	YY_BREAK
Xcase 101:
X{ line_number++; }
X	YY_BREAK
Xcase 102:
X;
X	YY_BREAK
Xcase 103:
X{ yylval.i = yytext[1]; return CHAR; }
X	YY_BREAK
Xcase 104:
X{ return yytext[0]; }
X	YY_BREAK
Xcase 105:
XECHO;
X	YY_BREAK
Xcase YY_STATE_EOF(INITIAL):
Xcase YY_STATE_EOF(MAPC):
X    yyterminate();
X
X	    case YY_END_OF_BUFFER:
X		{
X		/* amount of text matched not including the EOB char */
X		int yy_amount_of_matched_text = yy_cp - yytext - 1;
X
X		/* undo the effects of YY_DO_BEFORE_ACTION */
X		*yy_cp = yy_hold_char;
X
X		/* note that here we test for yy_c_buf_p "<=" to the position
X		 * of the first EOB in the buffer, since yy_c_buf_p will
X		 * already have been incremented past the NUL character
X		 * (since all states make transitions on EOB to the end-
X		 * of-buffer state).  Contrast this with the test in yyinput().
X		 */
X		if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )
X		    /* this was really a NUL */
X		    {
X		    yy_state_type yy_next_state;
X
X		    yy_c_buf_p = yytext + yy_amount_of_matched_text;
X
X		    yy_current_state = yy_get_previous_state();
X
X		    /* okay, we're now positioned to make the
X		     * NUL transition.  We couldn't have
X		     * yy_get_previous_state() go ahead and do it
X		     * for us because it doesn't know how to deal
X		     * with the possibility of jamming (and we
X		     * don't want to build jamming into it because
X		     * then it will run more slowly)
X		     */
X
X		    yy_next_state = yy_try_NUL_trans( yy_current_state );
X
X		    yy_bp = yytext + YY_MORE_ADJ;
X
X		    if ( yy_next_state )
X			{
X			/* consume the NUL */
X			yy_cp = ++yy_c_buf_p;
X			yy_current_state = yy_next_state;
X			goto yy_match;
X			}
X
X		    else
X			{
X			    yy_cp = yy_last_accepting_cpos;
X			    yy_current_state = yy_last_accepting_state;
X			goto yy_find_action;
X			}
X		    }
X
X		else switch ( yy_get_next_buffer() )
X		    {
X		    case EOB_ACT_END_OF_FILE:
X			{
X			yy_did_buffer_switch_on_eof = 0;
X
X			if ( yywrap() )
X			    {
X			    /* note: because we've taken care in
X			     * yy_get_next_buffer() to have set up yytext,
X			     * we can now set up yy_c_buf_p so that if some
X			     * total hoser (like flex itself) wants
X			     * to call the scanner after we return the
X			     * YY_NULL, it'll still work - another YY_NULL
X			     * will get returned.
X			     */
X			    yy_c_buf_p = yytext + YY_MORE_ADJ;
X
X			    yy_act = YY_STATE_EOF((yy_start - 1) / 2);
X			    goto do_action;
X			    }
X
X			else
X			    {
X			    if ( ! yy_did_buffer_switch_on_eof )
X				YY_NEW_FILE;
X			    }
X			}
X			break;
X
X		    case EOB_ACT_CONTINUE_SCAN:
X			yy_c_buf_p = yytext + yy_amount_of_matched_text;
X
X			yy_current_state = yy_get_previous_state();
X
X			yy_cp = yy_c_buf_p;
X			yy_bp = yytext + YY_MORE_ADJ;
X			goto yy_match;
X
X		    case EOB_ACT_LAST_MATCH:
X			yy_c_buf_p =
X			    &yy_current_buffer->yy_ch_buf[yy_n_chars];
X
X			yy_current_state = yy_get_previous_state();
X
X			yy_cp = yy_c_buf_p;
X			yy_bp = yytext + YY_MORE_ADJ;
X			goto yy_find_action;
X		    }
X		break;
X		}
X
X	    default:
X#ifdef FLEX_DEBUG
X		printf( "action # %d\n", yy_act );
X#endif
X		YY_FATAL_ERROR(
X			"fatal flex scanner internal error--no action found" );
X	    }
X	}
X}
X
X
X/* yy_get_next_buffer - try to read in a new buffer
X *
X * synopsis
X *     int yy_get_next_buffer();
X *
X * returns a code representing an action
X *     EOB_ACT_LAST_MATCH -
X *     EOB_ACT_CONTINUE_SCAN - continue scanning from current position
X *     EOB_ACT_END_OF_FILE - end of file
X */
X
Xstatic int yy_get_next_buffer()
X{
X    register YY_CHAR *dest = yy_current_buffer->yy_ch_buf;
X    register YY_CHAR *source = yytext - 1; /* copy prev. char, too */
X    register int number_to_move, i;
X    int ret_val;
X
X    if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )
X	YY_FATAL_ERROR(
X		"fatal flex scanner internal error--end of buffer missed" );
X
X    /* try to read more data */
X
X    /* first move last chars to start of buffer */
X    number_to_move = yy_c_buf_p - yytext;
X
X    for ( i = 0; i < number_to_move; ++i )
X	*(dest++) = *(source++);
X
X    if ( yy_current_buffer->yy_eof_status != EOF_NOT_SEEN )
X	/* don't do the read, it's not guaranteed to return an EOF,
X	 * just force an EOF
X	 */
X	yy_n_chars = 0;
X
X    else
X	{
X	int num_to_read = yy_current_buffer->yy_buf_size - number_to_move - 1;
X
X	if ( num_to_read > YY_READ_BUF_SIZE )
X	    num_to_read = YY_READ_BUF_SIZE;
X
X	else if ( num_to_read <= 0 )
X	    YY_FATAL_ERROR( "fatal error - scanner input buffer overflow" );
X
X	/* read in more data */
X	YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),
X		  yy_n_chars, num_to_read );
X	}
X
X    if ( yy_n_chars == 0 )
X	{
X	if ( number_to_move - YY_MORE_ADJ == 1 )
X	    {
X	    ret_val = EOB_ACT_END_OF_FILE;
X	    yy_current_buffer->yy_eof_status = EOF_DONE;
X	    }
X
X	else
X	    {
X	    ret_val = EOB_ACT_LAST_MATCH;
X	    yy_current_buffer->yy_eof_status = EOF_PENDING;
X	    }
X	}
X
X    else
X	ret_val = EOB_ACT_CONTINUE_SCAN;
X
X    yy_n_chars += number_to_move;
X    yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
X    yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;
X
X    /* yytext begins at the second character in yy_ch_buf; the first
X     * character is the one which preceded it before reading in the latest
X     * buffer; it needs to be kept around in case it's a newline, so
X     * yy_get_previous_state() will have with '^' rules active
X     */
X
X    yytext = &yy_current_buffer->yy_ch_buf[1];
X
X    return ( ret_val );
X}
X
X
X/* yy_get_previous_state - get the state just before the EOB char was reached
X *
X * synopsis
X *     yy_state_type yy_get_previous_state();
X */
X
Xstatic yy_state_type yy_get_previous_state()
X{
X    register yy_state_type yy_current_state;
X    register YY_CHAR *yy_cp;
X
X    register YY_CHAR *yy_bp = yytext;
X
X    yy_current_state = yy_start;
X    if ( yy_bp[-1] == '\n' )
X	++yy_current_state;
X
X    for ( yy_cp = yytext + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )
X	{
X	register YY_CHAR yy_c = (*yy_cp ? yy_ec[*yy_cp] : 1);
X	if ( yy_accept[yy_current_state] )
X	    {
X	    yy_last_accepting_state = yy_current_state;
X	    yy_last_accepting_cpos = yy_cp;
X	    }
X	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
X	    {
X	    yy_current_state = yy_def[yy_current_state];
X	    if ( yy_current_state >= 573 )
X		yy_c = yy_meta[yy_c];
X	    }
X	yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
X	}
X
X    return ( yy_current_state );
X}
X
X
X/* yy_try_NUL_trans - try to make a transition on the NUL character
X *
X * synopsis
X *     next_state = yy_try_NUL_trans( current_state );
X */
X
Xstatic yy_state_type yy_try_NUL_trans( yy_current_state )
Xregister yy_state_type yy_current_state;
X{
X    register int yy_is_jam;
X    register YY_CHAR *yy_cp = yy_c_buf_p;
X
X    register YY_CHAR yy_c = 1;
X    if ( yy_accept[yy_current_state] )
X	{
X	yy_last_accepting_state = yy_current_state;
X	yy_last_accepting_cpos = yy_cp;
X	}
X    while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
X	{
X	yy_current_state = yy_def[yy_current_state];
X	if ( yy_current_state >= 573 )
X	    yy_c = yy_meta[yy_c];
X	}
X    yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
X    yy_is_jam = (yy_current_state == 572);
X
X    return ( yy_is_jam ? 0 : yy_current_state );
X}
X
X
X#if 0		/* not needed for NetHack */
X
Xstatic void yyunput( in_c, yy_bp )
Xint in_c;		/* YY_CHAR c; */
Xregister YY_CHAR *yy_bp;
X{
X    register YY_CHAR *yy_cp = yy_c_buf_p;
X    YY_CHAR c = (YY_CHAR)in_c;
X
X    /* undo effects of setting up yytext */
X    *yy_cp = yy_hold_char;
X
X    if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
X	{ /* need to shift things up to make room */
X	register int number_to_move = yy_n_chars + 2; /* +2 for EOB chars */
X	register YY_CHAR *dest =
X	    &yy_current_buffer->yy_ch_buf[yy_current_buffer->yy_buf_size + 2];
X	register YY_CHAR *source =
X	    &yy_current_buffer->yy_ch_buf[number_to_move];
X
X	while ( source > yy_current_buffer->yy_ch_buf )
X	    *--dest = *--source;
X
X	yy_cp += dest - source;
X	yy_bp += dest - source;
X	yy_n_chars = yy_current_buffer->yy_buf_size;
X
X	if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
X	    YY_FATAL_ERROR( "flex scanner push-back overflow" );
X	}
X
X    if ( yy_cp > yy_bp && yy_cp[-1] == '\n' )
X	yy_cp[-2] = '\n';
X
X    *--yy_cp = c;
X
X    /* note: the formal parameter *must* be called "yy_bp" for this
X     *       macro to now work correctly
X     */
X    YY_DO_BEFORE_ACTION; /* set up yytext again */
X}
X
X
Xstatic int yyinput()
X{
X    int c;
X    YY_CHAR *yy_cp = yy_c_buf_p;
X
X    *yy_cp = yy_hold_char;
X
X    if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
X	{
X	/* yy_c_buf_p now points to the character we want to return.
X	 * If this occurs *before* the EOB characters, then it's a
X	 * valid NUL; if not, then we've hit the end of the buffer.
X	 */
X	if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )
X	    /* this was really a NUL */
X	    *yy_c_buf_p = '\0';
X
X	else
X	    { /* need more input */
X	    yytext = yy_c_buf_p;
X	    ++yy_c_buf_p;
X
X	    switch ( yy_get_next_buffer() )
X		{
X		case EOB_ACT_END_OF_FILE:
X		    {
X		    if ( yywrap() )
X			{
X			yy_c_buf_p = yytext + YY_MORE_ADJ;
X			return ( EOF );
X			}
X
X		    YY_NEW_FILE;
X
X		    return ( yyinput() );
X		    }
X		    break;
X
X		case EOB_ACT_CONTINUE_SCAN:
X		    yy_c_buf_p = yytext + YY_MORE_ADJ;
X		    break;
X
X		case EOB_ACT_LAST_MATCH:
X		    YY_FATAL_ERROR( "unexpected last match in yyinput()" );
X		}
X	    }
X	}
X
X    c = *yy_c_buf_p;
X    yy_hold_char = *++yy_c_buf_p;
X
X    return ( c );
X}
X
X#endif	/* 0 */
X
X
Xvoid yyrestart( input_file )
XFILE *input_file;
X{
X    yy_init_buffer( yy_current_buffer, input_file );
X    yy_load_buffer_state();
X}
X
X
Xvoid yy_switch_to_buffer( new_buffer )
XYY_BUFFER_STATE new_buffer;
X{
X    if ( yy_current_buffer == new_buffer )
X	return;
X
X    if ( yy_current_buffer )
X	{
X	/* flush out information for old buffer */
X	*yy_c_buf_p = yy_hold_char;
X	yy_current_buffer->yy_buf_pos = yy_c_buf_p;
X	yy_current_buffer->yy_n_chars = yy_n_chars;
X	}
X
X    yy_current_buffer = new_buffer;
X    yy_load_buffer_state();
X
X    /* we don't actually know whether we did this switch during
X     * EOF (yywrap()) processing, but the only time this flag
X     * is looked at is after yywrap() is called, so it's safe
X     * to go ahead and always set it.
X     */
X    yy_did_buffer_switch_on_eof = 1;
X}
X
X
Xvoid yy_load_buffer_state()
X{
X    yy_n_chars = yy_current_buffer->yy_n_chars;
X    yytext = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
X    yyin = yy_current_buffer->yy_input_file;
X    yy_hold_char = *yy_c_buf_p;
X}
X
X
XYY_BUFFER_STATE yy_create_buffer( file, size )
XFILE *file;
Xint size;
X{
X    YY_BUFFER_STATE b;
X
X    b = (YY_BUFFER_STATE) alloc( sizeof( struct yy_buffer_state ) );
X    b->yy_buf_size = size;
X
X    /* yy_ch_buf has to be 2 characters longer than the size given because
X     * we need to put in 2 end-of-buffer characters.
X     */
X    b->yy_ch_buf = (YY_CHAR *) alloc( (unsigned) (b->yy_buf_size + 2) );
X    yy_init_buffer( b, file );
X
X    return ( b );
X}
X
X
Xvoid yy_delete_buffer( b )
XYY_BUFFER_STATE b;
X{
X    if ( b == yy_current_buffer )
X	yy_current_buffer = (YY_BUFFER_STATE) 0;
X
X    free((genericptr_t)b->yy_ch_buf);
X    free((genericptr_t)b);
X}
X
X
Xvoid yy_init_buffer( b, file )
XYY_BUFFER_STATE b;
XFILE *file;
X{
X    b->yy_input_file = file;
X
X    /* we put in the '\n' and start reading from [1] so that an
X     * initial match-at-newline will be true.
X     */
X
X    b->yy_ch_buf[0] = '\n';
X    b->yy_n_chars = 1;
X
X    /* we always need two end-of-buffer characters.  The first causes
X     * a transition to the end-of-buffer state.  The second causes
X     * a jam in that state.
X     */
X    b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
X    b->yy_ch_buf[2] = YY_END_OF_BUFFER_CHAR;
X
X    b->yy_buf_pos = &b->yy_ch_buf[1];
X
X    b->yy_eof_status = EOF_NOT_SEEN;
X}
X
X#ifdef	AMIGA
Xlong *alloc(n)
X	unsigned n;
X{
X	return ((long *)malloc (n));
X}
X#endif
X
X/* routine to switch to another input file; needed for flex */
Xvoid init_yyin( input_f )
XFILE *input_f;
X{
X#ifdef FLEX_SCANNER
X	if (yyin)
X	    yyrestart(input_f);
X	else
X#endif
X	    yyin = input_f;
X}
X/* analogous routine (for completeness) */
Xvoid init_yyout( output_f )
XFILE *output_f;
X{
X	yyout = output_f;
X}
X
END_OF_FILE
if test 50181 -ne `wc -c <'sys/share/lev_lex.c'`; then
    echo shar: \"'sys/share/lev_lex.c'\" unpacked with wrong size!
fi
# end of 'sys/share/lev_lex.c'
echo shar: End of archive 21 \(of 33\).
cp /dev/null ark21isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 33 archives.
    echo "Now execute ./patchit.sh"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
