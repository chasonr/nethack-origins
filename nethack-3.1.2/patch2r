Path: uunet!gatech!europa.eng.gtefsd.com!emory!ogicse!news.tek.com!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v17i093:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Patch2r/33
Message-ID: <1v8io1$j4r@ying.cna.tek.com>
Date: 11 Jun 93 00:13:53 GMT
Article-I.D.: ying.1v8io1$j4r
Organization: Tektronix, Inc, Redmond, OR, USA
Lines: 2153
Approved: billr@saab.CNA.TEK.COM
NNTP-Posting-Host: saab.cna.tek.com
Xref: uunet comp.sources.games:1758

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 17, Issue 93
Archive-name: nethack31/Patch2r
Patch-To: nethack31: Volume 16, Issue 1-116
Environment: Amiga, Atari, Mac, MS-DOS, Windows-NT, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 18 (of 33)."
# Contents:  patches02c sys/amiga/winproto.h
# Wrapped by billr@saab on Thu Jun 10 16:55:04 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'patches02c' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'patches02c'\" to \"'patches02c.orig'\"
  mv -f 'patches02c' 'patches02c.orig'
fi
echo shar: Extracting \"'patches02c'\" \(53667 characters\)
sed "s/^X//" >'patches02c' <<'END_OF_FILE'
X*** /tmp/da10922	Tue Jun  1 16:13:19 1993
X--- src/dokick.c	Mon May 17 13:39:49 1993
X***************
X*** 1,9 ****
X! /*	SCCS Id: @(#)dokick.c	3.1	93/02/18	*/
X  /* Copyright (c) Izchak Miller, Mike Stephenson, Steve Linhart, 1989. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X! #include	"hack.h"
X! #include	"eshk.h"
X  
X  #ifndef POLYSELF
X  # define martial()	(pl_character[0] == 'S' || pl_character[0] == 'P')
X--- 1,9 ----
X! /*	SCCS Id: @(#)dokick.c	3.1	93/05/14	*/
X  /* Copyright (c) Izchak Miller, Mike Stephenson, Steve Linhart, 1989. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X! #include "hack.h"
X! #include "eshk.h"
X  
X  #ifndef POLYSELF
X  # define martial()	(pl_character[0] == 'S' || pl_character[0] == 'P')
X***************
X*** 46,51 ****
X--- 46,57 ----
X  	/* a good kick exercises your dex */
X  	exercise(A_DEX, TRUE);
X  
X+ /*	it is unchivalrous to attack the defenseless or from behind */
X+ 	if (pl_character[0] == 'K' &&
X+ 		u.ualign.type == A_LAWFUL && u.ualign.record > -10 &&
X+ 		(!mon->mcanmove || mon->msleep || mon->mflee))
X+ 		adjalign(-1);
X+ 
X  	/* squeeze some guilt feelings... */
X  	if(mon->mtame) {
X  	    abuse_dog(mon);
X***************
X*** 57,63 ****
X  #endif
X  	}
X  
X! 	if (dmg)
X  		mon->mhp -= (!martial() ? rnd(dmg) :
X  			rnd(dmg)+rnd(ACURR(A_DEX)/2));
X  	if(mon->mhp < 1) {
X--- 63,69 ----
X  #endif
X  	}
X  
X! 	if (dmg > 0)
X  		mon->mhp -= (!martial() ? rnd(dmg) :
X  			rnd(dmg)+rnd(ACURR(A_DEX)/2));
X  	if(mon->mhp < 1) {
X***************
X*** 81,92 ****
X  	}
X  	(void) passive(mon, FALSE, 1, TRUE);
X  
X- /*	it is unchivalrous to attack the defenseless or from behind */
X- 	if (pl_character[0] == 'K' &&
X- 		u.ualign.type == A_LAWFUL && u.ualign.record > -10 &&
X- 		(!mon->mcanmove || mon->msleep || mon->mflee))
X- 		adjalign(-1);
X- 
X  }
X  
X  static void
X--- 87,92 ----
X***************
X*** 436,447 ****
X  		else pline("%s come%s loose.",
X  			   The(distant_name(kickobj, xname)),
X  			   (kickobj->quan == 1L) ? "s" : "");
X! 		remove_object(kickobj);
X  		newsym(x, y);
X  		if (costly && (!costly_spot(u.ux, u.uy)
X  			       || !index(u.urooms, *in_rooms(x, y, SHOPBASE))))
X  			addtobill(kickobj, FALSE, FALSE, FALSE);
X  		if(!flooreffects(kickobj,u.ux,u.uy,"fall")) {
X  		    place_object(kickobj, u.ux, u.uy);
X  		    stackobj(kickobj);
X  		    newsym(u.ux, u.uy);
X--- 436,449 ----
X  		else pline("%s come%s loose.",
X  			   The(distant_name(kickobj, xname)),
X  			   (kickobj->quan == 1L) ? "s" : "");
X! 		freeobj(kickobj);
X  		newsym(x, y);
X  		if (costly && (!costly_spot(u.ux, u.uy)
X  			       || !index(u.urooms, *in_rooms(x, y, SHOPBASE))))
X  			addtobill(kickobj, FALSE, FALSE, FALSE);
X  		if(!flooreffects(kickobj,u.ux,u.uy,"fall")) {
X+ 		    kickobj->nobj = fobj;
X+ 		    fobj = kickobj;
X  		    place_object(kickobj, u.ux, u.uy);
X  		    stackobj(kickobj);
X  		    newsym(u.ux, u.uy);
X***************
X*** 541,594 ****
X  dokick()
X  {
X  	register int x, y;
X! 	register int avrg_attrib = (ACURRSTR+ACURR(A_DEX)+ACURR(A_CON))/3;
X  	register struct monst *mtmp;
X! 	register s_level *slev = Is_special(&u.uz);
X  
X  #ifdef POLYSELF
X! 	if(nolimbs(uasmon)) {
X  		You("have no legs to kick with.");
X! 		return(0);
X! 	}
X! 	if(verysmall(uasmon)) {
X  		You("are too small to do any kicking.");
X! 		return(0);
X! 	}
X  #endif
X! 	if(Wounded_legs) {
X  		Your("%s %s in no shape for kicking.",
X  		      ((Wounded_legs & BOTH_SIDES)==BOTH_SIDES)
X  			? (const char *)makeplural(body_part(LEG)) : body_part(LEG),
X  		      ((Wounded_legs & BOTH_SIDES)==BOTH_SIDES) ? "are" : "is");
X! 		return(0);
X! 	}
X! 
X! 	if(near_capacity() > SLT_ENCUMBER) {
X  		Your("load is too heavy to balance yourself for a kick.");
X! 		return(0);
X! 	}
X! 
X! 	if(u.uinwater && !rn2(2)) {
X  		Your("slow motion kick doesn't hit anything.");
X! 		return(0);
X! 	}
X! 
X! 	if(u.utrap) {
X  		switch (u.utraptype) {
X  		    case TT_PIT:
X! 			pline("There's nothing to kick down here.");
X  		    case TT_WEB:
X  		    case TT_BEARTRAP:
X  			You("can't move your %s!", body_part(LEG));
X  		}
X! 		return(0);
X  	}
X  
X  	if(!getdir(NULL)) return(0);
X  	if(!u.dx && !u.dy) return(0);
X  
X  	x = u.ux + u.dx;
X  	y = u.uy + u.dy;
X  
X  	if(u.uswallow) {
X  		switch(rn2(3)) {
X--- 543,601 ----
X  dokick()
X  {
X  	register int x, y;
X! 	int avrg_attrib;
X  	register struct monst *mtmp;
X! 	s_level *slev;
X! 	boolean no_kick = FALSE;
X  
X  #ifdef POLYSELF
X! 	if (nolimbs(uasmon)) {
X  		You("have no legs to kick with.");
X! 		no_kick = TRUE;
X! 	} else if (verysmall(uasmon)) {
X  		You("are too small to do any kicking.");
X! 		no_kick = TRUE;
X! 	} else
X  #endif
X! 	if (Wounded_legs) {
X  		Your("%s %s in no shape for kicking.",
X  		      ((Wounded_legs & BOTH_SIDES)==BOTH_SIDES)
X  			? (const char *)makeplural(body_part(LEG)) : body_part(LEG),
X  		      ((Wounded_legs & BOTH_SIDES)==BOTH_SIDES) ? "are" : "is");
X! 		no_kick = TRUE;
X! 	} else if (near_capacity() > SLT_ENCUMBER) {
X  		Your("load is too heavy to balance yourself for a kick.");
X! 		no_kick = TRUE;
X! 	} else if (u.uinwater && !rn2(2)) {
X  		Your("slow motion kick doesn't hit anything.");
X! 		no_kick = TRUE;
X! 	} else if (u.utrap) {
X  		switch (u.utraptype) {
X  		    case TT_PIT:
X! 			pline("There's not enough room to kick down here.");
X! 			break;
X  		    case TT_WEB:
X  		    case TT_BEARTRAP:
X  			You("can't move your %s!", body_part(LEG));
X+ 			break;
X+ 		    default:
X+ 			break;
X  		}
X! 		no_kick = TRUE;
X  	}
X  
X+ 	if (no_kick) {
X+ 		/* discard direction typeahead, if any */
X+ 		display_nhwindow(WIN_MESSAGE, TRUE);	/* --More-- */
X+ 		return 0;
X+ 	}
X+ 
X  	if(!getdir(NULL)) return(0);
X  	if(!u.dx && !u.dy) return(0);
X  
X  	x = u.ux + u.dx;
X  	y = u.uy + u.dy;
X+ 	avrg_attrib = (ACURRSTR+ACURR(A_DEX)+ACURR(A_CON))/3;
X  
X  	if(u.uswallow) {
X  		switch(rn2(3)) {
X***************
X*** 647,654 ****
X  			exercise(A_DEX, TRUE);
X  			maploc->typ = DOOR;
X  			if(maploc->doormask & D_TRAPPED) {
X- 			    b_trapped("door");
X  			    maploc->doormask = D_NODOOR;
X  			} else
X  			    maploc->doormask = D_ISOPEN;
X  			if (Blind)
X--- 654,661 ----
X  			exercise(A_DEX, TRUE);
X  			maploc->typ = DOOR;
X  			if(maploc->doormask & D_TRAPPED) {
X  			    maploc->doormask = D_NODOOR;
X+ 			    b_trapped("door", FOOT);
X  			} else
X  			    maploc->doormask = D_ISOPEN;
X  			if (Blind)
X***************
X*** 824,833 ****
X  	if(rnl(35) < avrg_attrib + (!martial() ? 0 : ACURR(A_DEX))) {
X  		/* break the door */
X  		if(maploc->doormask & D_TRAPPED) {
X! 		    pline("As you kick the door, it explodes!");
X  		    exercise(A_STR, FALSE);
X- 		    b_trapped("door");
X  		    maploc->doormask = D_NODOOR;
X  		} else if(ACURR(A_STR) > 18 && !rn2(5) &&
X  			  !*in_rooms(x, y, SHOPBASE)) {
X  		    pline("As you kick the door, it shatters to pieces!");
X--- 831,840 ----
X  	if(rnl(35) < avrg_attrib + (!martial() ? 0 : ACURR(A_DEX))) {
X  		/* break the door */
X  		if(maploc->doormask & D_TRAPPED) {
X! 		    if (flags.verbose) You("kick the door.");
X  		    exercise(A_STR, FALSE);
X  		    maploc->doormask = D_NODOOR;
X+ 		    b_trapped("door", FOOT);
X  		} else if(ACURR(A_STR) > 18 && !rn2(5) &&
X  			  !*in_rooms(x, y, SHOPBASE)) {
X  		    pline("As you kick the door, it shatters to pieces!");
X***************
X*** 847,853 ****
X  		else
X  		    newsym(x,y);
X  		unblock_point(x,y);		/* vision */
X! 		if(slev && slev->flags.town)
X  		  for(mtmp = fmon; mtmp; mtmp = mtmp->nmon) {
X  		    if((mtmp->data == &mons[PM_WATCHMAN] ||
X  			mtmp->data == &mons[PM_WATCH_CAPTAIN]) &&
X--- 854,860 ----
X  		else
X  		    newsym(x,y);
X  		unblock_point(x,y);		/* vision */
X! 		if ((slev = Is_special(&u.uz)) && slev->flags.town)
X  		  for(mtmp = fmon; mtmp; mtmp = mtmp->nmon) {
X  		    if((mtmp->data == &mons[PM_WATCHMAN] ||
X  			mtmp->data == &mons[PM_WATCH_CAPTAIN]) &&
X***************
X*** 863,869 ****
X  	    if (Blind) feel_location(x,y);	/* we know we hit it */
X  	    exercise(A_STR, TRUE);
X  	    pline("WHAMMM!!!");
X! 	    if(slev && slev->flags.town)
X  	      for(mtmp = fmon; mtmp; mtmp = mtmp->nmon) {
X  	        if((mtmp->data == &mons[PM_WATCHMAN] ||
X  		  mtmp->data == &mons[PM_WATCH_CAPTAIN]) &&
X--- 870,876 ----
X  	    if (Blind) feel_location(x,y);	/* we know we hit it */
X  	    exercise(A_STR, TRUE);
X  	    pline("WHAMMM!!!");
X! 	    if ((slev = Is_special(&u.uz)) && slev->flags.town)
X  	      for(mtmp = fmon; mtmp; mtmp = mtmp->nmon) {
X  	        if((mtmp->data == &mons[PM_WATCHMAN] ||
X  		  mtmp->data == &mons[PM_WATCH_CAPTAIN]) &&
X***************
X*** 997,1006 ****
X  				 index(u.urooms, *in_rooms(x, y, SHOPBASE))),
X  				TRUE);
X  		    /* set obj->no_charge to 0 */
X! 		    if(Is_container(obj))
X! 		        picked_container(obj); /* does the right thing */
X! 		    if(obj->otyp != GOLD_PIECE)
X! 		        obj->no_charge = 0;
X  		}
X  		obj->nobj = migrating_objs;
X  		migrating_objs = obj;
X--- 1004,1013 ----
X  				 index(u.urooms, *in_rooms(x, y, SHOPBASE))),
X  				TRUE);
X  		    /* set obj->no_charge to 0 */
X! 		    if (Has_contents(obj))
X! 			picked_container(obj);	/* does the right thing */
X! 		    if (obj->otyp != GOLD_PIECE)
X! 			obj->no_charge = 0;
X  		}
X  		obj->nobj = migrating_objs;
X  		migrating_objs = obj;
X***************
X*** 1019,1028 ****
X  		pline("From the impact, %sother %s.",
X  			dct == oct ? "the " : dct == 1L ? "an" : "", what);
X  	    else
X! 		pline("%s adjacent %s %s",
X! 			oct == dct ? (dct > 1L ? "All the" : "The") :
X! 			    (dct == 1L ? "One of the" : "Some of the"),
X! 			what, gate_str(toloc));
X  	}
X  
X  	if(costly && shkp && price) {
X--- 1026,1041 ----
X  		pline("From the impact, %sother %s.",
X  			dct == oct ? "the " : dct == 1L ? "an" : "", what);
X  	    else
X! 		if (oct == dct) {
X! 		    pline("%s adjacent %s %s",
X! 			    dct == 1L ? "The" : "All the",
X! 			    what, gate_str(toloc));
X! 		} else {
X! 		    pline("%s adjacent %s %s",
X! 			    dct == 1L ? "One of the" : "Some of the",
X! 			    dct == 1L ? "objects falls" : what,
X! 			    gate_str(toloc));
X! 		}
X  	}
X  
X  	if(costly && shkp && price) {
X***************
X*** 1079,1085 ****
X  	drop_to(&cc, toloc);
X  	if(!cc.y) return(FALSE);
X  
X! 	container = Is_container(otmp);
X  
X  	unpaid = (otmp->unpaid || (container && count_unpaid(otmp->cobj)));
X  
X--- 1092,1098 ----
X  	drop_to(&cc, toloc);
X  	if(!cc.y) return(FALSE);
X  
X! 	container = Has_contents(otmp);
X  
X  	unpaid = (otmp->unpaid || (container && count_unpaid(otmp->cobj)));
X  
X***************
X*** 1151,1157 ****
X  	register struct obj *otmp, *otmp0 = (struct obj *)0, *otmp2;
X  
X  	for(otmp = migrating_objs; otmp; otmp = otmp2) {
X- 
X  	    otmp2 = otmp->nobj;
X  
X  	    if(otmp->ox == u.uz.dnum && otmp->oy == u.uz.dlevel) {
X--- 1164,1169 ----
X***************
X*** 1197,1202 ****
X--- 1209,1217 ----
X  			    } /* else fall through */
X  		    default:
X  scatter:
X+ 			    /* set dummy coordinates because there's no
X+ 			       current position for rloco() to update */
X+ 			    otmp->ox = otmp->oy = 0;
X  			    rloco(otmp);
X  			    break;
X  		}
X***************
X*** 1244,1249 ****
X--- 1259,1267 ----
X  {
X  	register struct trap *ttmp = t_at(x, y);
X  
X+ #ifdef MULDGN	/* this matches the player restriction in goto_level() */
X+ 	if (on_level(&u.uz, &qstart_level) && !ok_to_quest()) return -1;
X+ #endif
X  	if(ttmp && ttmp->ttyp == TRAPDOOR && ttmp->tseen) return 0;
X  	if(xdnstair == x && ydnstair == y) return 1;
X  	if(xdnladder == x && ydnladder == y) return 2;
X*** /tmp/da10938	Tue Jun  1 16:13:24 1993
X--- src/drawing.c	Mon Apr 26 17:37:45 1993
X***************
X*** 268,273 ****
X--- 268,278 ----
X  #undef C
X  
X  #ifdef ASCIIGRAPH
X+ 
X+ #ifdef PC9801
X+ void NDECL((*ibmgraphics_mode_callback)) = 0;	/* set in tty_start_screen() */
X+ #endif /* PC9801 */
X+ 
X  static uchar ibm_graphics[MAXPCHARS] = {
X  /* 0*/	g_FILLER(S_stone),
X  	0xb3,	/* S_vwall:	meta-3, vertical rule */
X***************
X*** 489,496 ****
X  	g_FILLER(S_explode8),
X  	g_FILLER(S_explode9)
X  };
X! #endif  /* MAC_GRAPHICS_ENV */
X  
X  /*
X   * Convert the given character to an object class.  If the character is not
X   * recognized, then MAXOCLASSES is returned.  Used in invent.c, options.c,
X--- 494,505 ----
X  	g_FILLER(S_explode8),
X  	g_FILLER(S_explode9)
X  };
X! #endif	/* MAC_GRAPHICS_ENV */
X  
X+ #ifdef PC9801
X+ void NDECL((*ascgraphics_mode_callback)) = 0;	/* set in tty_start_screen() */
X+ #endif
X+ 
X  /*
X   * Convert the given character to an object class.  If the character is not
X   * recognized, then MAXOCLASSES is returned.  Used in invent.c, options.c,
X***************
X*** 540,545 ****
X--- 549,557 ----
X  	default:
X  	case ASCII_GRAPHICS:
X  	    assign_graphics((uchar *)0, 0);
X+ #ifdef PC9801
X+ 	    if (ascgraphics_mode_callback) (*ascgraphics_mode_callback)();
X+ #endif
X  	    break;
X  #ifdef ASCIIGRAPH
X  	case IBM_GRAPHICS:
X***************
X*** 553,558 ****
X--- 565,573 ----
X  	    flags.IBMgraphics = TRUE;
X  	    flags.DECgraphics = FALSE;
X  	    assign_graphics(ibm_graphics, SIZE(ibm_graphics));
X+ #ifdef PC9801
X+ 	    if (ibmgraphics_mode_callback) (*ibmgraphics_mode_callback)();
X+ #endif
X  	    break;
X  #endif /* ASCIIGRAPH */
X  #ifdef TERMLIB
X*** /tmp/da10946	Tue Jun  1 16:13:27 1993
X--- src/dungeon.c	Fri Mar 12 17:20:47 1993
X***************
X*** 548,553 ****
X--- 548,591 ----
X      return FALSE;
X  }
X  
X+ 
X+ struct level_map {
X+ 	const char *lev_name;
X+ 	d_level *lev_spec;
X+ } level_map[] = {
X+ 	{ "air",	&air_level },
X+ 	{ "asmodeus",	&asmodeus_level },
X+ 	{ "astral",	&astral_level },
X+ 	{ "baalz",	&baalzebub_level },
X+ 	{ "bigroom",	&bigroom_level },
X+ 	{ "castle",	&stronghold_level },
X+ 	{ "earth",	&earth_level },
X+ 	{ "fakewiz1",	&portal_level },
X+ 	{ "fire",	&fire_level },
X+ 	{ "juiblex",	&juiblex_level },
X+ #ifdef MULDGN
X+ 	{ "knox",	&knox_level },
X+ #endif
X+ 	{ "medusa",	&medusa_level },
X+ 	{ "oracle",	&oracle_level },
X+ 	{ "orcus",	&orcus_level },
X+ #ifdef REINCARNATION
X+ 	{ "rogue",	&rogue_level },
X+ #endif
X+ 	{ "sanctum",	&sanctum_level },
X+ 	{ "valley",	&valley_level },
X+ 	{ "water",	&water_level },
X+ 	{ "wizard1",	&wiz1_level },
X+ 	{ "wizard2",	&wiz2_level },
X+ 	{ "wizard3",	&wiz3_level },
X+ #ifdef MULDGN
X+ 	{ X_START,	&qstart_level },
X+ 	{ X_LOCATE,	&qlocate_level },
X+ 	{ X_GOAL,	&nemesis_level },
X+ #endif
X+ 	{ "",		(d_level *)0 }
X+ };
X+ 
X  void
X  init_dungeons()		/* initialize the "dungeon" structs */
X  {
X***************
X*** 555,560 ****
X--- 593,599 ----
X  	register int i, cl = 0, cb = 0;
X  	register s_level *x;
X  	struct proto_dungeon pd;
X+ 	struct level_map *lev_map;
X  
X  	pd.n_levs = pd.n_brs = 0;
X  
X***************
X*** 722,801 ****
X  	 * Find most of the special levels and dungeons so we can access their
X  	 * locations quickly.
X  	 */
X! #ifdef REINCARNATION
X! 	if ((x = find_level("rogue")) != 0)
X! 	    assign_level(&rogue_level, &x->dlevel);
X! #endif
X! 	if ((x = find_level("oracle")) != 0)
X! 	    assign_level(&oracle_level, &x->dlevel);
X! 	if ((x = find_level("bigroom")) != 0)
X! 	    assign_level(&bigroom_level, &x->dlevel);
X! 	if ((x = find_level("medusa")) != 0)
X! 	    assign_level(&medusa_level, &x->dlevel);
X! 	if ((x = find_level("castle")) != 0)
X! 	    assign_level(&stronghold_level, &x->dlevel);
X! 	if ((x = find_level("valley")) != 0)
X! 	    assign_level(&valley_level, &x->dlevel);
X! 	if ((x = find_level("wizard1")) != 0)
X! 	    assign_level(&wiz1_level, &x->dlevel);
X! 	if ((x = find_level("wizard2")) != 0)
X! 	    assign_level(&wiz2_level, &x->dlevel);
X! 	if ((x = find_level("wizard3")) != 0)
X! 	    assign_level(&wiz3_level, &x->dlevel);
X! 	if ((x = find_level("juiblex")) != 0)
X! 	    assign_level(&juiblex_level, &x->dlevel);
X! 	if ((x = find_level("orcus")) != 0)
X! 	    assign_level(&orcus_level, &x->dlevel);
X! 	if ((x = find_level("asmodeus")) != 0)
X! 	    assign_level(&asmodeus_level, &x->dlevel);
X! 	if ((x = find_level("baalz")) != 0)
X! 	    assign_level(&baalzebub_level, &x->dlevel);
X! 	if ((x = find_level("fakewiz1")) != 0)
X! 	    assign_level(&portal_level, &x->dlevel);
X! 	if ((x = find_level("sanctum")) != 0)
X! 	    assign_level(&sanctum_level, &x->dlevel);
X! 	if ((x = find_level("earth")) != 0)
X! 	    assign_level(&earth_level, &x->dlevel);
X! 	if ((x = find_level("water")) != 0)
X! 	    assign_level(&water_level, &x->dlevel);
X! 	if ((x = find_level("fire")) != 0)
X! 	    assign_level(&fire_level, &x->dlevel);
X! 	if ((x = find_level("air")) != 0)
X! 	    assign_level(&air_level, &x->dlevel);
X! 	if ((x = find_level("astral")) != 0)
X! 	    assign_level(&astral_level, &x->dlevel);
X  #ifdef MULDGN
X! 	if ((x = find_level("knox")) != 0) {
X! 	    branch *br;
X! 	    assign_level(&knox_level, &x->dlevel);
X! 	    /*
X! 	     * Kludge to allow floating Knox entrance.  We specify a floating
X! 	     * entrance by the fact that its entrance (end1) has a bogus dnum,
X! 	     * namely n_dgns.
X! 	     */
X! 	    for (br = branches; br; br = br->next)
X! 		if (on_level(&br->end2, &knox_level)) break;
X  
X! 	    if (br) br->end1.dnum = n_dgns;
X! 	    /* adjust the branch's position on the list */
X! 	    insert_branch(br, TRUE);
X  	}
X! /*
X!  *	This is where the name substitution on the levels of the quest
X!  *	dungeon occur.
X!  */
X! 	if ((x = find_level(X_START)) != 0) {
X! 	    x->proto[0] = pl_character[0];
X! 	    assign_level(&qstart_level, &x->dlevel);
X! 	}
X! 	if ((x = find_level(X_LOCATE)) != 0) {
X! 	    x->proto[0] = pl_character[0];
X! 	    assign_level(&qlocate_level, &x->dlevel);
X! 	}
X! 	if ((x = find_level(X_GOAL)) != 0) {
X! 	    x->proto[0] = pl_character[0];
X! 	    assign_level(&nemesis_level, &x->dlevel);
X! 	}
X  /*
X   *	I hate hardwiring these names. :-(
X   */
X--- 761,795 ----
X  	 * Find most of the special levels and dungeons so we can access their
X  	 * locations quickly.
X  	 */
X! 	for (lev_map = level_map; lev_map->lev_name[0]; lev_map++) {
X! 		x = find_level(lev_map->lev_name);
X! 		if (x) {
X! 			assign_level(lev_map->lev_spec, &x->dlevel);
X  #ifdef MULDGN
X! 			if (!strncmp(lev_map->lev_name, "x-", 2)) {
X! 				/* This is where the name substitution on the
X! 				 * levels of the quest dungeon occur.
X! 				 */
X! 				x->proto[0] = pl_character[0];
X! 			} else if (lev_map->lev_spec == &knox_level) {
X! 				branch *br;
X! 				/*
X! 				 * Kludge to allow floating Knox entrance.  We
X! 				 * specify a floating entrance by the fact that
X! 				 * its entrance (end1) has a bogus dnum, namely
X! 				 * n_dgns.
X! 				 */
X! 				for (br = branches; br; br = br->next)
X! 				    if (on_level(&br->end2, &knox_level)) break;
X  
X! 				if (br) br->end1.dnum = n_dgns;
X! 				/* adjust the branch's position on the list */
X! 				insert_branch(br, TRUE);
X! 			}
X! #endif
X! 		}
X  	}
X! #ifdef MULDGN
X  /*
X   *	I hate hardwiring these names. :-(
X   */
X*** /tmp/da10954	Tue Jun  1 16:13:30 1993
X--- src/eat.c	Tue Jun  1 10:47:41 1993
X***************
X*** 1,8 ****
X! /*	SCCS Id: @(#)eat.c	3.1	93/02/19	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X! #include	"hack.h"
X  /*#define DEBUG		/* uncomment to enable new eat code debugging */
X  
X  #ifdef DEBUG
X--- 1,8 ----
X! /*	SCCS Id: @(#)eat.c	3.1	93/05/19	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X! #include "hack.h"
X  /*#define DEBUG		/* uncomment to enable new eat code debugging */
X  
X  #ifdef DEBUG
X***************
X*** 176,182 ****
X  
X  	exercise(A_CON, FALSE);
X  
X! 	if (!rn2(20)) {
X  		You("stuff yourself and then vomit voluminously.");
X  		morehungry(1000);	/* you just got *very* sick! */
X  		vomit();
X--- 176,182 ----
X  
X  	exercise(A_CON, FALSE);
X  
X! 	if (!rn2(20) || Breathless) {
X  		You("stuff yourself and then vomit voluminously.");
X  		morehungry(1000);	/* you just got *very* sick! */
X  		vomit();
X***************
X*** 285,292 ****
X  		 || otmp->unpaid) &&
X  		 (otmp->otyp == CORPSE || objects[otmp->otyp].oc_delay > 1)) {
X  		/* create a dummy duplicate to put on bill */
X! 		verbalize("You bite it, you bought it!");
X  		bill_dummy_object(otmp);
X  	    }
X  	    otmp->oeaten = (otmp->otyp == CORPSE ?
X  				(int)mons[otmp->corpsenm].cnutrit :
X--- 285,293 ----
X  		 || otmp->unpaid) &&
X  		 (otmp->otyp == CORPSE || objects[otmp->otyp].oc_delay > 1)) {
X  		/* create a dummy duplicate to put on bill */
X! 		verbalize("You bit it, you bought it!");
X  		bill_dummy_object(otmp);
X+ 		otmp->no_charge = 1;	/* you now own this */
X  	    }
X  	    otmp->oeaten = (otmp->otyp == CORPSE ?
X  				(int)mons[otmp->corpsenm].cnutrit :
X***************
X*** 345,351 ****
X  	}
X  	if(!victual.eating) return(0);
X  
X! 	if(++victual.usedtime < victual.reqtime) {
X  	    if(bite()) return(0);
X  	    return(1);	/* still busy */
X  	} else {	/* done */
X--- 346,352 ----
X  	}
X  	if(!victual.eating) return(0);
X  
X! 	if(++victual.usedtime <= victual.reqtime) {
X  	    if(bite()) return(0);
X  	    return(1);	/* still busy */
X  	} else {	/* done */
X***************
X*** 876,883 ****
X  	}
X  	if(tin.usedtime < tin.reqtime)
X  		return(1);		/* still busy */
X! 	if(tin.tin->cursed && tin.tin->spe != -1 && !rn2(8)) {
X! 		b_trapped("tin");
X  		goto use_me;
X  	}
X  	You("succeed in opening the tin.");
X--- 877,885 ----
X  	}
X  	if(tin.usedtime < tin.reqtime)
X  		return(1);		/* still busy */
X! 	if(tin.tin->otrapped || 
X! 	   (tin.tin->cursed && tin.tin->spe != -1 && !rn2(8))) {
X! 		b_trapped("tin", 0);
X  		goto use_me;
X  	}
X  	You("succeed in opening the tin.");
X***************
X*** 1034,1045 ****
X  		pline("Everything suddenly goes dark.");
X  		make_blinded((long)d(2,10),FALSE);
X  	} else if(!rn2(3)) {
X! 		if(Blind)
X! 		  pline("The world spins and you %s.",
X! 			Levitation ? "collapse in place" :
X! 			"slap against the floor");
X  		else
X! 		  pline("The world spins and goes dark.");
X  		flags.soundok = 0;
X  		nomul(-rnd(10));
X  		nomovemsg = "You are conscious again.";
X--- 1036,1050 ----
X  		pline("Everything suddenly goes dark.");
X  		make_blinded((long)d(2,10),FALSE);
X  	} else if(!rn2(3)) {
X! 		const char *what, *where;
X! 		if (!Blind)
X! 		    what = "goes",  where = "dark";
X! 		else if (Levitation || Is_airlevel(&u.uz) ||
X! 			 Is_waterlevel(&u.uz))
X! 		    what = "you lose control of",  where = "yourself";
X  		else
X! 		    what = "you slap against the",  where = surface(u.ux,u.uy);
X! 		pline("The world spins and %s %s.", what, where);
X  		flags.soundok = 0;
X  		nomul(-rnd(10));
X  		nomovemsg = "You are conscious again.";
X***************
X*** 1438,1444 ****
X  	if (!(otmp = floorfood("eat", 0))) return 0;
X  	if (check_capacity(NULL)) return 0;
X  #ifdef POLYSELF
X! 	/* We have to make non-foods take no time to eat, unless we want to
X  	 * do ridiculous amounts of coding to deal with partly eaten plate
X  	 * mails, players who polymorph back to human in the middle of their
X  	 * metallic meal, etc....
X--- 1443,1449 ----
X  	if (!(otmp = floorfood("eat", 0))) return 0;
X  	if (check_capacity(NULL)) return 0;
X  #ifdef POLYSELF
X! 	/* We have to make non-foods take 1 move to eat, unless we want to
X  	 * do ridiculous amounts of coding to deal with partly eaten plate
X  	 * mails, players who polymorph back to human in the middle of their
X  	 * metallic meal, etc....
X***************
X*** 1458,1463 ****
X--- 1463,1471 ----
X  	    if (otmp->oclass == GOLD_CLASS)
X  		basenutrit = ((otmp->quan > 200000L) ? 2000
X  			: (int)(otmp->quan/100L));
X+ 	    else if(otmp->oclass == BALL_CLASS || otmp->oclass == CHAIN_CLASS)
X+ 		basenutrit = weight(otmp);
X+ 	    /* oc_nutrition is usually weight anyway */
X  	    else basenutrit = objects[otmp->otyp].oc_nutrition;
X  	    victual.nmod = basenutrit;
X  	    victual.eating = TRUE; /* needed for lesshungry() */
X***************
X*** 1614,1620 ****
X  	    /* Conflict uses up food too */
X  	    if ((Conflict & (~W_ARTI))) u.uhunger--;
X  	    /* +0 charged rings don't do anything, so don't affect hunger */
X! 	    switch (moves % 20) {	/* note: use even cases only */
X  	     case  4: if (uleft &&
X  			  (uleft->spe || !objects[uleft->otyp].oc_charged))
X  			    u.uhunger--;
X--- 1622,1628 ----
X  	    /* Conflict uses up food too */
X  	    if ((Conflict & (~W_ARTI))) u.uhunger--;
X  	    /* +0 charged rings don't do anything, so don't affect hunger */
X! 	    switch ((int)(moves % 20)) {	/* note: use even cases only */
X  	     case  4: if (uleft &&
X  			  (uleft->spe || !objects[uleft->otyp].oc_charged))
X  			    u.uhunger--;
X*** /tmp/da10962	Tue Jun  1 16:13:33 1993
X--- src/end.c	Tue Jun  1 11:19:02 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)end.c	3.1	93/02/09	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)end.c	3.1	93/05/29	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 10,19 ****
X--- 10,22 ----
X  #include <signal.h>
X  #endif
X  
X+ 
X  STATIC_PTR int NDECL(done_intr);
X  static void FDECL(disclose,(int,BOOLEAN_P));
X  static struct obj *FDECL(get_valuables, (struct obj *));
X  static void FDECL(savelife, (int));
X+ static void NDECL(list_vanquished);
X+ static void NDECL(list_genocided);
X  
X  /*
X   * The order of these needs to match the macros in hack.h.
X***************
X*** 70,75 ****
X--- 73,79 ----
X  	}
X  #if defined(WIZARD) && (defined(UNIX) || defined(VMS) || defined(LATTICE))
X  	if(wizard) {
X+ 	    int c;
X  # ifdef VMS
X  	    const char *tmp = "Enter debugger?";
X  # else
X***************
X*** 79,85 ****
X  	    const char *tmp = "Dump core?";
X  #  endif
X  # endif
X! 	    if(yn(tmp) == 'y') {
X  		(void) signal(SIGINT, (SIG_RET_TYPE) done1);
X  		exit_nhwindows(NULL);
X  #ifdef AMIGA
X--- 83,89 ----
X  	    const char *tmp = "Dump core?";
X  #  endif
X  # endif
X! 	    if ((c = ynq(tmp)) == 'y') {
X  		(void) signal(SIGINT, (SIG_RET_TYPE) done1);
X  		exit_nhwindows(NULL);
X  #ifdef AMIGA
X***************
X*** 90,96 ****
X  # endif
X  		    abort();
X  #endif
X! 	    }
X  	}
X  #endif
X  #ifndef LINT
X--- 94,100 ----
X  # endif
X  		    abort();
X  #endif
X! 	    } else if (c == 'q') done_stopprint++;
X  	}
X  #endif
X  #ifndef LINT
X***************
X*** 101,107 ****
X  
X  STATIC_PTR
X  int
X! done_intr(){
X  	done_stopprint++;
X  #ifndef NO_SIGNAL
X  	(void) signal(SIGINT, SIG_IGN);
X--- 105,112 ----
X  
X  STATIC_PTR
X  int
X! done_intr()
X! {
X  	done_stopprint++;
X  #ifndef NO_SIGNAL
X  	(void) signal(SIGINT, SIG_IGN);
X***************
X*** 108,114 ****
X  # if defined(UNIX) || defined(VMS)
X  	(void) signal(SIGQUIT, SIG_IGN);
X  # endif
X! #endif /* NO_SIGNAL /* */
X  	return 0;
X  }
X  
X--- 113,119 ----
X  # if defined(UNIX) || defined(VMS)
X  	(void) signal(SIGQUIT, SIG_IGN);
X  # endif
X! #endif /* NO_SIGNAL */
X  	return 0;
X  }
X  
X***************
X*** 115,121 ****
X  #if defined(UNIX) || defined(VMS)
X  static
X  int
X! done_hangup(){
X  	done_hup++;
X  	(void)signal(SIGHUP, SIG_IGN);
X  	(void)done_intr();
X--- 120,127 ----
X  #if defined(UNIX) || defined(VMS)
X  static
X  int
X! done_hangup()
X! {
X  	done_hup++;
X  	(void)signal(SIGHUP, SIG_IGN);
X  	(void)done_intr();
X***************
X*** 240,246 ****
X  	char	c;
X  	char	qbuf[QBUFSZ];
X  
X! 	if(invent) {
X  	    if(taken)
X  		Sprintf(qbuf,"Do you want to see what you had when you %s?",
X  			(how == QUIT) ? "quit" : "died");
X--- 246,253 ----
X  	char	c;
X  	char	qbuf[QBUFSZ];
X  
X! 	if (invent && !done_stopprint &&
X! 		(!flags.end_disclose[0] || index(flags.end_disclose, 'i'))) {
X  	    if(taken)
X  		Sprintf(qbuf,"Do you want to see what you had when you %s?",
X  			(how == QUIT) ? "quit" : "died");
X***************
X*** 272,283 ****
X  	    }
X  	}
X  
X! 	if (!done_stopprint) {
X! 	    c = yn_function("Do you want to see your intrinsics?",ynqchars,'y');
X  	    if (c == 'y') enlightenment(TRUE);	/* final */
X  	    if (c == 'q') done_stopprint++;
X  	}
X  
X  }
X  
X  /* try to get the player back in a viable state after being killed */
X--- 279,300 ----
X  	    }
X  	}
X  
X! 	if (!done_stopprint &&
X! 		(!flags.end_disclose[0] || index(flags.end_disclose, 'a'))) {
X! 	    c = yn_function("Do you want to see your attributes?",ynqchars,'y');
X  	    if (c == 'y') enlightenment(TRUE);	/* final */
X  	    if (c == 'q') done_stopprint++;
X  	}
X  
X+ 	if (!done_stopprint &&
X+ 		(!flags.end_disclose[0] || index(flags.end_disclose, 'v'))) {
X+ 	    list_vanquished();
X+ 	}
X+ 
X+ 	if (!done_stopprint &&
X+ 		(!flags.end_disclose[0] || index(flags.end_disclose, 'g'))) {
X+ 	    list_genocided();
X+ 	}
X  }
X  
X  /* try to get the player back in a viable state after being killed */
X***************
X*** 313,319 ****
X      struct obj *valuables = (struct obj *)0;
X  
X      for (obj = list; obj; obj = next_obj) {
X! 	if (Is_container(obj) && obj->cobj) {
X  	    c_vals = get_valuables(obj->cobj);
X  
X  	    if (c_vals) {
X--- 330,336 ----
X      struct obj *valuables = (struct obj *)0;
X  
X      for (obj = list; obj; obj = next_obj) {
X! 	if (Has_contents(obj)) {
X  	    c_vals = get_valuables(obj->cobj);
X  
X  	    if (c_vals) {
X***************
X*** 412,418 ****
X  	(void) signal(SIGQUIT, (SIG_RET_TYPE) done_intr);
X  	(void) signal(SIGHUP, (SIG_RET_TYPE) done_hangup);
X  # endif
X! #endif /* NO_SIGNAL /* */
X  #ifdef POLYSELF
X  	if (u.mtimedone)
X  	    upmon = uasmon;
X--- 429,435 ----
X  	(void) signal(SIGQUIT, (SIG_RET_TYPE) done_intr);
X  	(void) signal(SIGHUP, (SIG_RET_TYPE) done_hangup);
X  # endif
X! #endif /* NO_SIGNAL */
X  #ifdef POLYSELF
X  	if (u.mtimedone)
X  	    upmon = uasmon;
X***************
X*** 454,460 ****
X  #endif
X  	if (have_windows) display_nhwindow(WIN_MESSAGE, FALSE);
X  
X! 	if (flags.end_disclose && how != PANICKED) disclose(how,taken);
X  
X  	if (how < GENOCIDED) {
X  #ifdef WIZARD
X--- 471,478 ----
X  #endif
X  	if (have_windows) display_nhwindow(WIN_MESSAGE, FALSE);
X  
X! 	if (strcmp(flags.end_disclose, "none") && how != PANICKED)
X! 		disclose(how, taken);
X  
X  	if (how < GENOCIDED) {
X  #ifdef WIZARD
X***************
X*** 490,496 ****
X  	    if(!done_stopprint || flags.tombstone)
X  		endwin = create_nhwindow(NHW_TEXT);
X  
X! 	    if(how < GENOCIDED && flags.tombstone) outrip(how, endwin);
X  	} else
X  	    done_stopprint = 1; /* just avoid any more output */
X  
X--- 508,514 ----
X  	    if(!done_stopprint || flags.tombstone)
X  		endwin = create_nhwindow(NHW_TEXT);
X  
X! 	    if(how < GENOCIDED && flags.tombstone) outrip(endwin, how);
X  	} else
X  	    done_stopprint = 1; /* just avoid any more output */
X  
X***************
X*** 500,506 ****
X  	if (u.uhave.amulet) Strcat(kilbuf, " (with the Amulet)");
X  	if (!done_stopprint) {
X  	    Sprintf(pbuf, "%s %s the %s...",
X! 		   (pl_character[0]=='S') ? "Sayonara" : "Goodbye", plname,
X  		   how != ASCENDED ? (const char *) pl_character :
X  		   (const char *) (flags.female ? "Demigoddess" : "Demigod"));
X  	    putstr(endwin, 0, pbuf);
X--- 518,525 ----
X  	if (u.uhave.amulet) Strcat(kilbuf, " (with the Amulet)");
X  	if (!done_stopprint) {
X  	    Sprintf(pbuf, "%s %s the %s...",
X! 		   (pl_character[0] == 'S') ? "Sayonara" :
X! 		   (pl_character[0] == 'T') ? "Aloha" : "Goodbye", plname,
X  		   how != ASCENDED ? (const char *) pl_character :
X  		   (const char *) (flags.female ? "Demigoddess" : "Demigod"));
X  	    putstr(endwin, 0, pbuf);
X***************
X*** 623,652 ****
X  	    putstr(endwin, 0, pbuf);
X  	    putstr(endwin, 0, "");
X  	}
X! #if (defined(WIZARD) || defined(EXPLORE_MODE))
X! # ifndef LOGFILE
X! 	if (wizard || discover) {
X! 	    if (!done_stopprint) {
X! 		putstr(endwin, 0, "");
X! 		Sprintf(pbuf, "Since you were in %s mode, the score list \
X! will not be checked.", wizard ? "wizard" : "discover");
X! 		putstr(endwin, 0, pbuf);
X! 		putstr(endwin, 0, "");
X! 		display_nhwindow(endwin, TRUE);
X! 	    }
X! 	    if (have_windows)
X! 		exit_nhwindows(NULL);
X! 	} else
X! # endif
X! #endif
X! 	{
X! 	    if (!done_stopprint)
X! 		display_nhwindow(endwin, TRUE);
X! 	    if (have_windows)
X! 		exit_nhwindows(NULL);
X! /* "So when I die, the first thing I will see in Heaven is a score list?" */
X! 	    topten(how);
X! 	}
X  	if(done_stopprint) { raw_print(""); raw_print(""); }
X  	terminate(0);
X  }
X--- 642,654 ----
X  	    putstr(endwin, 0, pbuf);
X  	    putstr(endwin, 0, "");
X  	}
X! 	if (!done_stopprint)
X! 	    display_nhwindow(endwin, TRUE);
X! 	if (have_windows)
X! 	    exit_nhwindows(NULL);
X! 	/* "So when I die, the first thing I will see in Heaven is a
X! 	 * score list?" */
X! 	topten(how);
X  	if(done_stopprint) { raw_print(""); raw_print(""); }
X  	terminate(0);
X  }
X***************
X*** 700,705 ****
X--- 702,708 ----
X  	}
X  }
X  
X+ 
X  void
X  terminate(status)
X  int status;
X***************
X*** 706,721 ****
X  {
X  #ifdef MAC
X  	if (!hu) {
X! 		int idx;
X! 		for (idx = theWindows[BASE_WINDOW].windowTextLen; --idx >= 0; )
X! 			/* If there is something to show... */
X! 			if (((unsigned char *)*theWindows[BASE_WINDOW].windowText)[idx] > ' ') {
X! 				display_nhwindow(BASE_WINDOW, TRUE);
X! 				break;
X! 			}
X  	}
X  #endif
X  	exit(status);
X  }
X  
X  /*end.c*/
X--- 709,821 ----
X  {
X  #ifdef MAC
X  	if (!hu) {
X! 		getreturn("to exit");
X  	}
X  #endif
X  	exit(status);
X+ }
X+ 
X+ static void
X+ list_vanquished()
X+ {
X+     register int i, lev;
X+     int ntypes = 0, max_lev = 0, nkilled;
X+     long total_killed = 0L;
X+     char c;
X+     static winid klwin;
X+     char buf[BUFSZ];
X+ 
X+     /* get totals first */
X+     for (i = 0; i < NUMMONS; i++) {
X+ 	if (u.nr_killed[i]) ntypes++;
X+ 	total_killed += (long)u.nr_killed[i];
X+ 	if (mons[i].mlevel > max_lev) max_lev = mons[i].mlevel;
X+     }
X+ 
X+     /* vanquished foes list;
X+      * includes all dead monsters, not just those killed by the player
X+      */
X+     if (ntypes != 0) {
X+ 	c = yn_function("Do you want an account of foes vanquished?",
X+ 			ynqchars, 'n');
X+ 	if (c == 'q') done_stopprint++;
X+ 	if (c == 'y') {
X+ 	    klwin = create_nhwindow(NHW_MENU);
X+ 	    putstr(klwin, 0, "Vanquished foes:");
X+ 	    putstr(klwin, 0, "");
X+ 
X+ 	    /* countdown by monster "toughness" */
X+ 	    for (lev = max_lev; lev >= 0; lev--)
X+ 	      for (i = 0; i < NUMMONS; i++)
X+ 		if (mons[i].mlevel == lev && (nkilled = u.nr_killed[i])) {
X+ 		    if (i == PM_WIZARD_OF_YENDOR || mons[i].geno & G_UNIQ) {
X+ 			Sprintf(buf, type_is_pname(&mons[i]) ? mons[i].mname :
X+ 				The(mons[i].mname));
X+ 			if (nkilled > 1)
X+ 			    Sprintf(eos(buf)," (%d time%s)",
X+ 				    nkilled, plur(nkilled));
X+ 		    } else {
X+ 			/* trolls or undead might have come back,
X+ 			   but we don't keep track of that */
X+ 			if (nkilled == 1)
X+ 			    Strcpy(buf, an(mons[i].mname));
X+ 			else
X+ 			    Sprintf(buf, "%d %s",
X+ 				    nkilled, makeplural(mons[i].mname));
X+ 		    }
X+ 		    putstr(klwin, 0, buf);
X+ 		}
X+ 	    /*
X+ 	     * if (Hallucination)
X+ 	     *     putstr(klwin, 0, "and a partridge in a pear tree");
X+ 	     */
X+ 	    if (ntypes > 1) {
X+ 		putstr(klwin, 0, "");
X+ 		Sprintf(buf, "%ld creatures vanquished.", total_killed);
X+ 		putstr(klwin, 0, buf);
X+ 	    }
X+ 	    display_nhwindow(klwin, TRUE);
X+ 	    destroy_nhwindow(klwin);
X+ 	}
X+     }
X+ }
X+ 
X+ static void
X+ list_genocided()
X+ {
X+     register int i;
X+     int ngenocided = 0;
X+     char c;
X+     static winid klwin;
X+     char buf[BUFSZ];
X+ 
X+     /* get totals first */
X+     for (i = 0; i < NUMMONS; i++) {
X+ 	if (mons[i].geno & G_GENOD) ngenocided++;
X+     }
X+ 
X+     /* genocided species list */
X+     if (ngenocided != 0) {
X+ 	c = yn_function("Do you want a list of species genocided?",
X+ 			ynqchars, 'n');
X+ 	if (c == 'q') done_stopprint++;
X+ 	if (c == 'y') {
X+ 	    klwin = create_nhwindow(NHW_MENU);
X+ 	    putstr(klwin, 0, "Genocided species:");
X+ 	    putstr(klwin, 0, "");
X+ 
X+ 	    for (i = 0; i < NUMMONS; i++)
X+ 		if (mons[i].geno & G_GENOD)
X+ 		    putstr(klwin, 0, makeplural(mons[i].mname));
X+ 
X+ 	    putstr(klwin, 0, "");
X+ 	    Sprintf(buf, "%d species genocided.", ngenocided);
X+ 	    putstr(klwin, 0, buf);
X+ 
X+ 	    display_nhwindow(klwin, TRUE);
X+ 	    destroy_nhwindow(klwin);
X+ 	}   
X+     }
X  }
X  
X  /*end.c*/
X*** /tmp/da10970	Tue Jun  1 16:13:36 1993
X--- src/engrave.c	Fri May 28 11:32:27 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)engrave.c	3.1	92/02/25	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)engrave.c	3.1	92/05/18	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 47,52 ****
X--- 47,73 ----
X  #endif /* OVLB */
X  #ifdef OVL0
X  
X+ const char *
X+ surface(x, y)
X+ register int x, y;
X+ {
X+ 	register struct rm *lev = &levl[x][y];
X+ 
X+ 	if (IS_AIR(lev->typ))
X+ 	    return "air";
X+ 	else if (is_pool(x,y))
X+ 	    return "water";
X+ 	else if (is_ice(x,y))
X+ 	    return "ice";
X+ 	else if (is_lava(x,y))
X+ 	    return "lava";
X+ 	else if ((IS_ROOM(lev->typ) && !Is_earthlevel(&u.uz)) ||
X+ 		 IS_WALL(lev->typ) || IS_DOOR(lev->typ) || lev->typ == SDOOR)
X+ 	    return "floor";
X+ 	else
X+ 	    return "ground";
X+ }
X+ 
X  struct engr *
X  engr_at(x,y) register xchar x,y; {
X  register struct engr *ep = head_engr;
X***************
X*** 140,164 ****
X  	    case DUST:
X  		if(!Blind) {
X  			sensed = 1;
X! 			pline("Something is written here in the dust.");
X  		}
X  		break;
X  	    case ENGRAVE:
X  		if(!Blind || !Levitation) {
X  			sensed = 1;
X! 			pline("Something is engraved here on the floor.");
X  		}
X  		break;
X  	    case BURN:
X  		if(!Blind || !Levitation) {
X  			sensed = 1;
X! 			pline("Some text has been burned into the floor here.");
X  		}
X  		break;
X  	    case MARK:
X  		if(!Blind) {
X  			sensed = 1;
X! 			pline("There's some graffiti on the floor here.");
X  		}
X  		break;
X  	    case BLOOD:
X--- 161,190 ----
X  	    case DUST:
X  		if(!Blind) {
X  			sensed = 1;
X! 			pline("Something is written here in the %s.",
X! 				is_ice(x,y) ? "frost" : "dust");
X  		}
X  		break;
X  	    case ENGRAVE:
X  		if(!Blind || !Levitation) {
X  			sensed = 1;
X! 			pline("Something is engraved here on the %s.",
X! 				surface(x,y));
X  		}
X  		break;
X  	    case BURN:
X  		if(!Blind || !Levitation) {
X  			sensed = 1;
X! 			pline("Some text has been %s into the %s here.",
X! 				is_ice(x,y) ? "melted" : "burned",
X! 				surface(x,y));
X  		}
X  		break;
X  	    case MARK:
X  		if(!Blind) {
X  			sensed = 1;
X! 			pline("There's some graffiti on the %s here.",
X! 				surface(x,y));
X  		}
X  		break;
X  	    case BLOOD:
X***************
X*** 195,201 ****
X  {
X  	register struct engr *ep;
X  
X! 	if(ep = engr_at(x,y))
X  	    del_engr(ep);
X  	ep = newengr(strlen(s) + 1);
X  	ep->nxt_engr = head_engr;
X--- 221,227 ----
X  {
X  	register struct engr *ep;
X  
X! 	if ((ep = engr_at(x,y)) != 0)
X  	    del_engr(ep);
X  	ep = newengr(strlen(s) + 1);
X  	ep->nxt_engr = head_engr;
X***************
X*** 210,215 ****
X--- 236,251 ----
X  	ep->engr_lth = strlen(s) + 1;
X  }
X  
X+ /* delete any engraving at location <x,y> */
X+ void
X+ del_engr_at(x, y)
X+ int x, y;
X+ {
X+ 	register struct engr *ep = engr_at(x, y);
X+ 
X+ 	if (ep) del_engr(ep);
X+ }
X+ 
X  /*
X   *	freehand - returns true if player has a free hand
X   */
X***************
X*** 278,286 ****
X  	char buf[BUFSZ];	/* Buffer for final/poly engraving text */
X  	char ebuf[BUFSZ];	/* Buffer for initial engraving text */
X  	char qbuf[QBUFSZ];	/* Buffer for query text */
X  	const char *everb;	/* Present tense of engraving type */
X  	const char *eloc;	/* Where the engraving is (ie dust/floor/...) */
X- 	const char *post_engr_text; /* Text displayed after engraving prompt */
X  	register char *sp;	/* Place holder for space count of engr text */
X  	register int len;	/* # of nonspace chars of new engraving text */
X  	register int maxelen;	/* Max allowable length of new engraving text */
X--- 314,322 ----
X  	char buf[BUFSZ];	/* Buffer for final/poly engraving text */
X  	char ebuf[BUFSZ];	/* Buffer for initial engraving text */
X  	char qbuf[QBUFSZ];	/* Buffer for query text */
X+ 	char post_engr_text[BUFSZ]; /* Text displayed after engraving prompt */
X  	const char *everb;	/* Present tense of engraving type */
X  	const char *eloc;	/* Where the engraving is (ie dust/floor/...) */
X  	register char *sp;	/* Place holder for space count of engr text */
X  	register int len;	/* # of nonspace chars of new engraving text */
X  	register int maxelen;	/* Max allowable length of new engraving text */
X***************
X*** 295,301 ****
X  
X  	buf[0] = (char)0;
X  	ebuf[0] = (char)0;
X! 	post_engr_text = (char *)0;
X  	maxelen = BUFSZ - 1;
X  
X  	/* Can the adventurer engrave at all? */
X--- 331,337 ----
X  
X  	buf[0] = (char)0;
X  	ebuf[0] = (char)0;
X! 	post_engr_text[0] = (char)0;
X  	maxelen = BUFSZ - 1;
X  
X  	/* Can the adventurer engrave at all? */
X***************
X*** 305,315 ****
X  			pline("What would you write?  \"Jonah was here\"?");
X  			return(0);
X  		} else if (is_whirly(u.ustuck->data)) {
X! 			You("can't reach the ground.");
X  			return(0);
X  		} else 
X  			jello = TRUE;
X!     	} else if (is_lava(u.ux, u.uy)) {
X  		You("can't write on the lava!");
X  		return(0);
X  	} else if (is_pool(u.ux,u.uy) || IS_FOUNTAIN(levl[u.ux][u.uy].typ)) {
X--- 341,351 ----
X  			pline("What would you write?  \"Jonah was here\"?");
X  			return(0);
X  		} else if (is_whirly(u.ustuck->data)) {
X! 			You("can't reach the %s.", surface(u.ux,u.uy));
X  			return(0);
X  		} else 
X  			jello = TRUE;
X! 	} else if (is_lava(u.ux, u.uy)) {
X  		You("can't write on the lava!");
X  		return(0);
X  	} else if (is_pool(u.ux,u.uy) || IS_FOUNTAIN(levl[u.ux][u.uy].typ)) {
X***************
X*** 351,357 ****
X  		return(0);
X  	}
X  	if(Levitation && otmp->oclass != WAND_CLASS){		/* riv05!a3 */
X! 		You("can't reach the floor!");
X  		return(0);
X  	}
X  
X--- 387,393 ----
X  		return(0);
X  	}
X  	if(Levitation && otmp->oclass != WAND_CLASS){		/* riv05!a3 */
X! 		You("can't reach the %s!", surface(u.ux,u.uy));
X  		return(0);
X  	}
X  
X***************
X*** 421,426 ****
X--- 457,463 ----
X  	     */
X  	    case WAND_CLASS:
X  		if (zappable(otmp)) {
X+ 		    check_unpaid(otmp);
X  		    zapwand = TRUE;
X  		    if (Levitation) ptext = FALSE;
X  
X***************
X*** 438,457 ****
X  			break;
X  
X  			/* IMMEDIATE wands */
X! 	    		/* If wand is "IMMEDIATE", remember to effect the
X! 			 * previous engraving even if turning to dust.,
X  			 */
X  		    case WAN_STRIKING:
X! 			post_engr_text =
X! 			"The wand unsuccessfully fights your attempt to write!";
X  			break;
X  		    case WAN_SLOW_MONSTER:
X! 			if (!Blind)
X! 			   post_engr_text = "The bugs on the ground slow down!";
X  			break;
X  		    case WAN_SPEED_MONSTER:
X! 			if (!Blind)
X! 			   post_engr_text = "The bugs on the ground speed up!";
X  			break;
X  		    case WAN_POLYMORPH:
X  			if(oep)  {
X--- 475,501 ----
X  			break;
X  
X  			/* IMMEDIATE wands */
X! 	    		/* If wand is "IMMEDIATE", remember to affect the
X! 			 * previous engraving even if turning to dust.
X  			 */
X  		    case WAN_STRIKING:
X! 			Strcpy(post_engr_text,
X! 			"The wand unsuccessfully fights your attempt to write!"
X! 			);
X  			break;
X  		    case WAN_SLOW_MONSTER:
X! 			if (!Blind) {
X! 			   Sprintf(post_engr_text,
X! 				   "The bugs on the %s slow down!",
X! 				   surface(u.ux, u.uy));
X! 			}
X  			break;
X  		    case WAN_SPEED_MONSTER:
X! 			if (!Blind) {
X! 			   Sprintf(post_engr_text,
X! 				   "The bugs on the %s speed up!",
X! 				   surface(u.ux, u.uy));
X! 			}
X  			break;
X  		    case WAN_POLYMORPH:
X  			if(oep)  {
X***************
X*** 472,494 ****
X  			/* RAY wands */
X  		    case WAN_MAGIC_MISSILE:
X  			ptext = TRUE;
X! 			if (!Blind)
X! 			    post_engr_text =
X! 				"The ground is riddled by bullet holes!";
X  			break;
X  
X  		    /* can't tell sleep from death - Eric Backus */
X  		    case WAN_SLEEP:
X  		    case WAN_DEATH:
X! 			if (!Blind)
X! 			    post_engr_text =
X! 				"The bugs on the ground stop moving!";
X  			break;
X  
X  		    case WAN_COLD:
X  			if (!Blind)
X! 			    post_engr_text =
X! 				"A few ice cubes drop from the wand.";
X  			if(!oep || (oep->engr_type != BURN))
X  			    break;
X  		    case WAN_CANCELLATION:
X--- 516,542 ----
X  			/* RAY wands */
X  		    case WAN_MAGIC_MISSILE:
X  			ptext = TRUE;
X! 			if (!Blind) {
X! 			   Sprintf(post_engr_text,
X! 				   "The %s is riddled by bullet holes!",
X! 				   surface(u.ux, u.uy));
X! 			}
X  			break;
X  
X  		    /* can't tell sleep from death - Eric Backus */
X  		    case WAN_SLEEP:
X  		    case WAN_DEATH:
X! 			if (!Blind) {
X! 			   Sprintf(post_engr_text,
X! 				   "The bugs on the %s stop moving!",
X! 				   surface(u.ux, u.uy));
X! 			}
X  			break;
X  
X  		    case WAN_COLD:
X  			if (!Blind)
X! 			    Strcpy(post_engr_text,
X! 				"A few ice cubes drop from the wand.");
X  			if(!oep || (oep->engr_type != BURN))
X  			    break;
X  		    case WAN_CANCELLATION:
X***************
X*** 495,501 ****
X  		    case WAN_MAKE_INVISIBLE:
X  			if(oep) {
X  			    if (!Blind)
X! 				pline("The engraving on the floor vanishes!");
X  			    dengr = TRUE;
X  			}
X  			break;
X--- 543,550 ----
X  		    case WAN_MAKE_INVISIBLE:
X  			if(oep) {
X  			    if (!Blind)
X! 				pline("The engraving on the %s vanishes!",
X! 					surface(u.ux,u.uy));
X  			    dengr = TRUE;
X  			}
X  			break;
X***************
X*** 502,508 ****
X  		    case WAN_TELEPORTATION:
X  			if (oep) {
X  			    if (!Blind)
X! 				pline("The engraving on the floor vanishes!");
X  			    teleengr = TRUE;
X  			}
X  			break;
X--- 551,558 ----
X  		    case WAN_TELEPORTATION:
X  			if (oep) {
X  			    if (!Blind)
X! 				pline("The engraving on the %s vanishes!",
X! 					surface(u.ux,u.uy));
X  			    teleengr = TRUE;
X  			}
X  			break;
X***************
X*** 518,526 ****
X  			    doknown = TRUE;
X  			}
X  			if (!Blind)
X! 			    post_engr_text = "Gravel flies up from the floor.";
X  			else
X! 			    post_engr_text = "You hear drilling!";
X  			break;
X  
X  		    /* type = BURN wands */
X--- 568,579 ----
X  			    doknown = TRUE;
X  			}
X  			if (!Blind)
X! 			    Strcpy(post_engr_text,
X! 				is_ice(u.ux,u.uy) ? 
X! 				"Ice chips fly up from the ice surface!" :
X! 			        "Gravel flies up from the floor.");
X  			else
X! 			    Strcpy(post_engr_text, "You hear drilling!");
X  			break;
X  
X  		    /* type = BURN wands */
X***************
X*** 532,541 ****
X  			    pline("This %s is a wand of fire!", xname(otmp));
X  			    doknown = TRUE;
X  			}
X! 			if (!Blind)
X! 			    post_engr_text = "Flames fly from the wand.";
X! 			else
X! 			    post_engr_text = "You feel the wand heat up.";
X  			break;
X  		    case WAN_LIGHTNING:
X  			ptext = TRUE;
X--- 585,593 ----
X  			    pline("This %s is a wand of fire!", xname(otmp));
X  			    doknown = TRUE;
X  			}
X! 			Strcpy(post_engr_text,
X! 				Blind ? "You feel the wand heat up." :
X! 					"Flames fly from the wand.");
X  			break;
X  		    case WAN_LIGHTNING:
X  			ptext = TRUE;
X***************
X*** 547,556 ****
X  			    doknown = TRUE;
X  			}
X  			if (!Blind) {
X! 			    post_engr_text = "Lightning arcs from the wand.";
X  			    doblind = TRUE;
X  			} else
X! 			    post_engr_text = "You hear crackling!";
X  			break;
X  
X  		    /* type = MARK wands */
X--- 599,609 ----
X  			    doknown = TRUE;
X  			}
X  			if (!Blind) {
X! 			    Strcpy(post_engr_text,
X! 				    "Lightning arcs from the wand.");
X  			    doblind = TRUE;
X  			} else
X! 			    Strcpy(post_engr_text, "You hear crackling!");
X  			break;
X  
X  		    /* type = MARK wands */
X***************
X*** 558,564 ****
X  		    }
X  		} else /* end if zappable */
X  		    if (Levitation) {
X! 			You("can't reach the floor!");
X  			return(0);
X  		    }
X  		break;
X--- 611,617 ----
X  		    }
X  		} else /* end if zappable */
X  		    if (Levitation) {
X! 			You("can't reach the %s!", surface(u.ux,u.uy));
X  			return(0);
X  		    }
X  		break;
X***************
X*** 656,662 ****
X  	if (zapwand && (otmp->spe < 0)) {
X  	    pline("%s %sturns to dust.",
X  		  The(xname(otmp)), Blind ? "" : "glows violently, then ");
X! You("are not going to get anywhere trying to write in the dust with your dust.");
X  	    useup(otmp);
X  	    ptext = FALSE;
X  	}
X--- 709,716 ----
X  	if (zapwand && (otmp->spe < 0)) {
X  	    pline("%s %sturns to dust.",
X  		  The(xname(otmp)), Blind ? "" : "glows violently, then ");
X!  You("are not going to get anywhere trying to write in the %s with your dust.",
X! 		is_ice(u.ux,u.uy) ? "frost" : "dust");
X  	    useup(otmp);
X  	    ptext = FALSE;
X  	}
X***************
X*** 663,669 ****
X  
X  	if (!ptext) {		/* Early exit for some implements. */
X  	    if (Levitation && (otmp->oclass == WAND_CLASS))
X! 		You("can't reach the floor!");
X  	    return(1);
X  	}
X  
X--- 717,723 ----
X  
X  	if (!ptext) {		/* Early exit for some implements. */
X  	    if (Levitation && (otmp->oclass == WAND_CLASS))
X! 		You("can't reach the %s!", surface(u.ux,u.uy));
X  	    return(1);
X  	}
X  
X***************
X*** 703,711 ****
X  		} else
X  		    if ( (type == DUST) || (type == MARK) || (type == BLOOD) ) {
X  			You(
X! 		       "cannot wipe out the message that is %s the floor here.",
X! 		            (oep->engr_type == BURN) ? "burned into" :
X! 			    "engraved in");
X  			return(1);
X  		    } else
X  			if ( (type != oep->engr_type) || (c == 'n') ) {
X--- 757,766 ----
X  		} else
X  		    if ( (type == DUST) || (type == MARK) || (type == BLOOD) ) {
X  			You(
X! 			 "cannot wipe out the message that is %s the %s here.",
X! 			 oep->engr_type == BURN ? 
X! 			   (is_ice(u.ux,u.uy) ? "melted into" : "burned into") :
X! 			   "engraved in", surface(u.ux,u.uy));
X  			return(1);
X  		    } else
X  			if ( (type != oep->engr_type) || (c == 'n') ) {
X***************
X*** 715,762 ****
X  			}
X  	}
X  
X  	switch(type){
X  	    default:
X  		everb = (oep && !eow ? "add to the weird writing on" :
X  				       "write strangely on");
X- 		eloc  = "the floor";
X  		break;
X  	    case DUST:
X  		everb = (oep && !eow ? "add to the writing in" :
X  				       "write in");
X! 		eloc = "the dust";
X  		break;
X  	    case ENGRAVE:
X  		everb = (oep && !eow ? "add to the engraving in" :
X  				       "engrave in");
X- 		eloc = "the floor";
X  		break;
X  	    case BURN:
X! 		everb = (oep && !eow ? "add to the text burned into" :
X! 				       "burn into");
X! 		eloc = "the floor";
X  		break;
X  	    case MARK:
X  		everb = (oep && !eow ? "add to the graffiti on" :
X  				       "scribble on");
X- 		eloc = "the floor";
X  		break;
X  	    case BLOOD:
X  		everb = (oep && !eow ? "add to the scrawl on" :
X  				       "scrawl on");
X- 		eloc = "the floor";
X  		break;
X  	}
X  
X  	/* Tell adventurer what is going on */
X  	if (otmp != &zeroobj)
X! 	    You("%s %s with %s.", everb, eloc, doname(otmp));
X  	else
X! 	    You("%s %s with your %s.", everb, eloc,
X  		makeplural(body_part(FINGER)));
X  
X  	/* Prompt for engraving! */
X! 	Sprintf(qbuf,"What do you want to %s %s here?", everb, eloc);
X  	getlin(qbuf, ebuf);
X  
X  	/* Mix up engraving if surface or state of mind is unsound.  */
X--- 770,815 ----
X  			}
X  	}
X  
X+ 	eloc = surface(u.ux,u.uy);
X  	switch(type){
X  	    default:
X  		everb = (oep && !eow ? "add to the weird writing on" :
X  				       "write strangely on");
X  		break;
X  	    case DUST:
X  		everb = (oep && !eow ? "add to the writing in" :
X  				       "write in");
X! 		eloc = is_ice(u.ux,u.uy) ? "frost" : "dust";
X  		break;
X  	    case ENGRAVE:
X  		everb = (oep && !eow ? "add to the engraving in" :
X  				       "engrave in");
X  		break;
X  	    case BURN:
X! 		everb = (oep && !eow ? 
X! 			( is_ice(u.ux,u.uy) ? "add to the text melted into" :
X! 			                      "add to the text burned into") :
X! 			( is_ice(u.ux,u.uy) ? "melt into" : "burn into"));
X  		break;
X  	    case MARK:
X  		everb = (oep && !eow ? "add to the graffiti on" :
X  				       "scribble on");
X  		break;
X  	    case BLOOD:
X  		everb = (oep && !eow ? "add to the scrawl on" :
X  				       "scrawl on");
X  		break;
X  	}
X  
X  	/* Tell adventurer what is going on */
X  	if (otmp != &zeroobj)
X! 	    You("%s the %s with %s.", everb, eloc, doname(otmp));
X  	else
X! 	    You("%s the %s with your %s.", everb, eloc,
X  		makeplural(body_part(FINGER)));
X  
X  	/* Prompt for engraving! */
X! 	Sprintf(qbuf,"What do you want to %s the %s here?", everb, eloc);
X  	getlin(qbuf, ebuf);
X  
X  	/* Mix up engraving if surface or state of mind is unsound.  */
X***************
X*** 831,837 ****
X  	    case BURN:
X  		multi = -(len/10);
X  		if (multi)
X! 		    nomovemsg =
X  			"You finish burning your message into the floor.";
X  		break;
X  	    case MARK:
X--- 884,891 ----
X  	    case BURN:
X  		multi = -(len/10);
X  		if (multi)
X! 		    nomovemsg = is_ice(u.ux,u.uy) ?
X! 			"You finish melting your message into the ice.":
X  			"You finish burning your message into the floor.";
X  		break;
X  	    case MARK:
X***************
X*** 873,879 ****
X  
X  	make_engr_at(u.ux, u.uy, buf, (moves - multi), type);
X  
X! 	if (post_engr_text) pline(post_engr_text);
X  
X  	if (doblind) {
X  	    You("are blinded by the flash!");
X--- 927,933 ----
X  
X  	make_engr_at(u.ux, u.uy, buf, (moves - multi), type);
X  
X! 	if (post_engr_text[0]) pline(post_engr_text);
X  
X  	if (doblind) {
X  	    You("are blinded by the flash!");
X***************
X*** 914,920 ****
X  }
X  
X  void
X! rest_engravings(fd) int fd; {
X  register struct engr *ep;
X  unsigned lth;
X  	head_engr = 0;
X--- 968,976 ----
X  }
X  
X  void
X! rest_engravings(fd)
X! int fd;
X! {
X  register struct engr *ep;
X  unsigned lth;
X  	head_engr = 0;
X***************
X*** 934,953 ****
X  }
X  
X  STATIC_OVL void
X! del_engr(ep) register struct engr *ep; {
X! register struct engr *ept;
X! 	if(ep == head_engr)
X  		head_engr = ep->nxt_engr;
X! 	else {
X! 		for(ept = head_engr; ept; ept = ept->nxt_engr) {
X! 			if(ept->nxt_engr == ep) {
X! 				ept->nxt_engr = ep->nxt_engr;
X! 				goto fnd;
X! 			}
X  		}
X- 		impossible("Error in del_engr?");
X- 		return;
X- 	fnd:	;
X  	}
X  	dealloc_engr(ep);
X  }
X--- 990,1012 ----
X  }
X  
X  STATIC_OVL void
X! del_engr(ep)
X! register struct engr *ep;
X! {
X! 	if (ep == head_engr) {
X  		head_engr = ep->nxt_engr;
X! 	} else {
X! 		register struct engr *ept;
X! 
X! 		for (ept = head_engr; ept; ept = ept->nxt_engr)
X! 		    if (ept->nxt_engr == ep) {
X! 			ept->nxt_engr = ep->nxt_engr;
X! 			break;
X! 		    }
X! 		if (!ept) {
X! 		    impossible("Error in del_engr?");
X! 		    return;
X  		}
X  	}
X  	dealloc_engr(ep);
X  }
END_OF_FILE
if test 53667 -ne `wc -c <'patches02c'`; then
    echo shar: \"'patches02c'\" unpacked with wrong size!
fi
# end of 'patches02c'
if test -f 'sys/amiga/winproto.h' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'sys/amiga/winproto.h'\" to \"'sys/amiga/winproto.h.orig'\"
  mv -f 'sys/amiga/winproto.h' 'sys/amiga/winproto.h.orig'
fi
echo shar: Extracting \"'sys/amiga/winproto.h'\" \(4469 characters\)
sed "s/^X//" >'sys/amiga/winproto.h' <<'END_OF_FILE'
X/*	SCCS Id: @(#)winproto.h	3.1	93/04/26	*/
X/* Copyright (c) Gregg Wonderly, Naperville, Illinois,  1991,1992,1993. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X/* winreq.c */
Xvoid EditColor ( void );
Xvoid DrawCol ( struct Window *w , int idx , UWORD *colors );
Xvoid DispCol ( struct Window *w , int idx , UWORD *colors );
Xvoid amii_change_color( int, long, int );
Xchar *amii_get_color_string( );
Xvoid amii_setpens ( void );
Xvoid amii_getlin ( const char *prompt , char *bufp );
Xvoid getlind ( const char *prompt , char *bufp , const char *dflt );
Xchar *amii_get_color_string( void );
X
X/* winstr.c */
Xvoid amii_putstr ( winid window , int attr , const char *str );
Xvoid outmore ( struct amii_WinDesc *cw );
Xvoid outsubstr ( struct amii_WinDesc *cw , char *str , int len );
Xvoid amii_putsym ( winid st , int i , int y , CHAR_P c );
Xvoid amii_addtopl ( const char *s );
Xvoid TextSpaces ( struct RastPort *rp , int nr );
Xvoid amii_remember_topl ( void );
Xint amii_doprev_message ( void );
Xvoid flushIDCMP( struct MsgPort * );
X
X/* winkey.c */
Xint amii_nh_poskey ( int *x , int *y , int *mod );
Xint amii_nhgetch ( void );
Xvoid amii_get_nh_event ( void );
Xvoid amii_getret ( void );
X
X/* winmenu.c */
Xvoid amii_start_menu ( winid window );
Xvoid amii_add_menu ( winid window , char ch , int attr , const char *str );
Xvoid amii_end_menu ( winid window , char cancel , const char *str , const char *morestr );
Xchar amii_select_menu ( winid window );
Xvoid DoMenuScroll ( int win , int blocking );
Xint ReDisplayData ( winid win );
Xvoid DisplayData ( winid win , int start , int where );
Xvoid SetPropInfo ( struct Window *win , struct Gadget *gad , long vis , long total , long top );
X
X/* amiwind.c */
Xstruct Window *OpenShWindow ( struct NewWindow *nw );
Xvoid CloseShWindow ( struct Window *win );
Xint ConvertKey ( struct IntuiMessage *message );
Xint kbhit ( void );
Xint kbhit ( void );
Xint amikbhit ( void );
Xint WindowGetchar ( void );
XWETYPE WindowGetevent ( void );
Xvoid amii_cleanup ( void );
X#ifndef	SHAREDLIB
Xvoid Abort ( long rc );
X#endif
Xvoid CleanUp ( void );
Xvoid flush_glyph_buffer ( struct Window *w );
Xvoid amiga_print_glyph ( winid window , int color_index , int glyph );
Xvoid start_glyphout ( winid window );
Xvoid amii_end_glyphout ( winid window );
Xstruct NewWindow *DupNewWindow ( struct NewWindow *win );
Xvoid FreeNewWindow ( struct NewWindow *win );
Xvoid bell ( void );
Xvoid amii_delay_output ( void );
Xvoid amii_number_pad ( int state );
X#ifndef	SHAREDLIB
Xvoid amiv_loadlib ( void );
Xvoid amii_loadlib ( void );
X#endif
Xvoid preserve_icon( void );
Xvoid clear_icon( void );
X
X/* winfuncs.c */
Xvoid amii_destroy_nhwindow ( winid win );
Xint amii_create_nhwindow ( int type );
Xvoid amii_init_nhwindows ( void );
Xvoid amii_clear_nhwindow ( winid win );
Xvoid dismiss_nhwindow ( winid win );
Xvoid amii_exit_nhwindows ( const char *str );
Xvoid amii_display_nhwindow ( winid win , boolean blocking );
Xvoid amii_curs ( winid window , int x , int y );
Xvoid kill_nhwindows ( int all );
Xvoid amii_cl_end ( struct amii_WinDesc *cw , int i );
Xvoid cursor_off ( winid window );
Xvoid cursor_on ( winid window );
Xvoid amii_suspend_nhwindows ( char *str );
Xvoid amii_resume_nhwindows ( void );
Xvoid amii_bell ( void );
Xvoid removetopl ( int cnt );
Xvoid port_help ( void );
Xvoid amii_print_glyph ( winid win , xchar x , xchar y , int glyph );
Xvoid amii_raw_print ( const char *s );
Xvoid amii_raw_print_bold ( const char *s );
Xvoid amii_update_inventory ( void );
Xvoid amii_mark_synch ( void );
Xvoid amii_wait_synch ( void );
Xvoid amii_setclipped ( void );
Xvoid amii_cliparound ( int x , int y );
Xvoid amii_set_text_font( char *font, int size );
X
X/* winami.c */
X#ifdef	SHAREDLIB
Xint __UserLibInit ( void );
Xvoid __UserLibCleanup ( void );
X#endif
Xvoid amii_askname ( void );
Xvoid amii_player_selection ( void );
Xvoid RandomWindow ( char *name );
Xvoid amii_get_ext_cmd ( char *bufp );
Xchar amii_yn_function ( const char *prompt , const char *resp , char def );
Xchar amii_yn_function ( const char *query , const char *resp , char def );
Xvoid amii_display_file ( const char *fn , boolean complain );
Xvoid SetBorder ( struct Gadget *gd );
Xvoid *malloc ( register unsigned size );
Xvoid free ( void *q );
X
X#ifdef	SHAREDLIB
X/* amilib.c */
Xvoid amii_loadlib ( void );
Xvoid amiv_loadlib ( void );
Xvoid CleanUp ( void );
Xvoid setup_librefs ( WinamiBASE *base );
Xvoid Abort ( long rc );
X#endif
X
X/* amiga:amirip.c */
Xvoid FDECL(amii_outrip, ( winid tmpwin, int how ));
END_OF_FILE
if test 4469 -ne `wc -c <'sys/amiga/winproto.h'`; then
    echo shar: \"'sys/amiga/winproto.h'\" unpacked with wrong size!
fi
# end of 'sys/amiga/winproto.h'
echo shar: End of archive 18 \(of 33\).
cp /dev/null ark18isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 33 archives.
    echo "Now execute ./patchit.sh"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
