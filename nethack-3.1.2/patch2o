Path: uunet!news.tek.com!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v17i090:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Patch2o/33
Date: 11 Jun 1993 00:12:10 GMT
Organization: Tektronix, Inc, Redmond, OR, USA
Lines: 1982
Approved: billr@saab.CNA.TEK.COM
Message-ID: <1v8ikq$j35@ying.cna.tek.com>
NNTP-Posting-Host: saab.cna.tek.com
Xref: uunet comp.sources.games:1778

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 17, Issue 90
Archive-name: nethack31/Patch2o
Patch-To: nethack31: Volume 16, Issue 1-116
Environment: Amiga, Atari, Mac, MS-DOS, Windows-NT, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 15 (of 33)."
# Contents:  patches02e sys/mac/NHrez.hqx
# Wrapped by billr@saab on Thu Jun 10 16:55:03 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'patches02e' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'patches02e'\" to \"'patches02e.orig'\"
  mv -f 'patches02e' 'patches02e.orig'
fi
echo shar: Extracting \"'patches02e'\" \(54556 characters\)
sed "s/^X//" >'patches02e' <<'END_OF_FILE'
X*** /tmp/da11082	Tue Jun  1 16:14:11 1993
X--- src/mhitu.c	Tue May 11 11:15:17 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)mhitu.c	3.1	93/02/09	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)mhitu.c	3.1	93/03/14	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 429,434 ****
X--- 429,435 ----
X  	    }
X  	    return (0);
X  	}
X+ 
X  #ifdef MUSE
X  	/* Unlike defensive stuff, don't let them use item _and_ attack. */
X  	/* Exception:  Medusa; her gaze is automatic.  (We actually kludge
X***************
X*** 607,615 ****
X  			break;
X  	    }
X  	    if(flags.botl) bot();
X! 	    if(sum[i] == 2)  return(1);  	/* attacker dead */
X  	    if(sum[i] == 3) break;  /* attacker teleported, no more attacks */
X- 	    /* sum[i] == 1: successful attack */
X  	    /* sum[i] == 0: unsuccessful attack */
X  	}
X  	return(0);
X--- 608,622 ----
X  			break;
X  	    }
X  	    if(flags.botl) bot();
X! 	/* give player a chance of waking up before dying -kaa */
X! 	    if(sum[i] == 1) {	    /* successful attack */
X! 		if (u.usleep && !rn2(10)) {
X! 		    multi = -1;
X! 		    nomovemsg = "The combat suddenly awakens you.";
X! 		}
X! 	    }
X! 	    if(sum[i] == 2)  return(1); 	/* attacker dead */
X  	    if(sum[i] == 3) break;  /* attacker teleported, no more attacks */
X  	    /* sum[i] == 0: unsuccessful attack */
X  	}
X  	return(0);
X***************
X*** 706,712 ****
X  	} else {
X  		if (!Sick) You("feel very sick.");
X  		exercise(A_CON, FALSE);
X! 		make_sick(Sick + (long)rn1(25-ACURR(A_CON),15),FALSE);
X  		u.usick_cause = mdat->mname;
X  		return TRUE;
X  	}
X--- 713,719 ----
X  	} else {
X  		if (!Sick) You("feel very sick.");
X  		exercise(A_CON, FALSE);
X! 		make_sick(Sick ? Sick/4 + 1L : (long)rn1(ACURR(A_CON), 20), FALSE);
X  		u.usick_cause = mdat->mname;
X  		return TRUE;
X  	}
X***************
X*** 1051,1057 ****
X  #ifdef POLYSELF
X  			    && !is_swimmer(uasmon)
X  #endif
X! 			    && !Magical_breathing
X  			   ) {
X  			    boolean moat = (levl[u.ux][u.uy].typ != POOL) &&
X  				(levl[u.ux][u.uy].typ != WATER) &&
X--- 1058,1064 ----
X  #ifdef POLYSELF
X  			    && !is_swimmer(uasmon)
X  #endif
X! 			    && !Amphibious
X  			   ) {
X  			    boolean moat = (levl[u.ux][u.uy].typ != POOL) &&
X  				(levl[u.ux][u.uy].typ != WATER) &&
X***************
X*** 1109,1115 ****
X  			else
X  	pline("%s makes some remarks about how difficult theft is lately.",
X  	Monnam(mtmp));
X! 			rloc(mtmp);
X  			return 3;
X  		} else
X  #endif
X--- 1116,1122 ----
X  			else
X  	pline("%s makes some remarks about how difficult theft is lately.",
X  	Monnam(mtmp));
X! 			if (!tele_restrict(mtmp)) rloc(mtmp);
X  			return 3;
X  		} else
X  #endif
X***************
X*** 1121,1127 ****
X  			    flags.female ? "unaffected" : "uninterested");
X  		    }
X  		    if(rn2(3)) {
X! 			rloc(mtmp);
X  			return 3;
X  		    }
X  		} else {
X--- 1128,1134 ----
X  			    flags.female ? "unaffected" : "uninterested");
X  		    }
X  		    if(rn2(3)) {
X! 			if (!tele_restrict(mtmp)) rloc(mtmp);
X  			return 3;
X  		    }
X  		} else {
X***************
X*** 1131,1137 ****
X  		      case 0:
X  			break;
X  		      default:
X! 			rloc(mtmp);
X  			mtmp->mflee = 1;
X  			return 3;
X  		    }
X--- 1138,1144 ----
X  		      case 0:
X  			break;
X  		      default:
X! 			if (!tele_restrict(mtmp)) rloc(mtmp);
X  			mtmp->mflee = 1;
X  			return 3;
X  		    }
X***************
X*** 1214,1224 ****
X  #endif
X  		        exercise(A_STR, TRUE);
X  		        exercise(A_CON, TRUE);
X  			flags.botl = 1;
X  			if (mtmp->mhp == 0)
X  			    return 2; /* mongone() was called above */
X  			if(!rn2(50)) {
X! 			    rloc(mtmp);
X  			    return 3;
X  			}
X  			dmg = 0;
X--- 1221,1232 ----
X  #endif
X  		        exercise(A_STR, TRUE);
X  		        exercise(A_CON, TRUE);
X+ 			if (Sick) make_sick(0L, FALSE);
X  			flags.botl = 1;
X  			if (mtmp->mhp == 0)
X  			    return 2; /* mongone() was called above */
X  			if(!rn2(50)) {
X! 			    if (!tele_restrict(mtmp)) rloc(mtmp);
X  			    return 3;
X  			}
X  			dmg = 0;
X***************
X*** 1794,1800 ****
X  doseduce(mon)
X  register struct monst *mon;
X  {
X! 	register struct obj *ring;
X  	boolean fem = (mon->data == &mons[PM_SUCCUBUS]); /* otherwise incubus */
X  	char qbuf[QBUFSZ];
X  
X--- 1802,1808 ----
X  doseduce(mon)
X  register struct monst *mon;
X  {
X! 	register struct obj *ring, *nring;
X  	boolean fem = (mon->data == &mons[PM_SUCCUBUS]); /* otherwise incubus */
X  	char qbuf[QBUFSZ];
X  
X***************
X*** 1814,1820 ****
X  	if (Blind) pline("It caresses you...");
X  	else You("feel very attracted to %s.", mon_nam(mon));
X  
X! 	for(ring = invent; ring; ring = ring->nobj) {
X  	    if (ring->otyp != RIN_ADORNMENT) continue;
X  	    if (fem) {
X  		if (rn2(20) < ACURR(A_CHA)) {
X--- 1822,1829 ----
X  	if (Blind) pline("It caresses you...");
X  	else You("feel very attracted to %s.", mon_nam(mon));
X  
X! 	for(ring = invent; ring; ring = nring) {
X! 	    nring = ring->nobj;
X  	    if (ring->otyp != RIN_ADORNMENT) continue;
X  	    if (fem) {
X  		if (rn2(20) < ACURR(A_CHA)) {
X***************
X*** 1899,1905 ****
X  	if (uarm || uarmc) {
X  		verbalize("You're such a %s; I wish...",
X  				flags.female ? "sweet lady" : "nice guy");
X! 		rloc(mon);
X  		return 1;
X  	}
X  	if (u.ualign.type == A_CHAOTIC && u.ualign.record < ALIGNLIM)
X--- 1908,1914 ----
X  	if (uarm || uarmc) {
X  		verbalize("You're such a %s; I wish...",
X  				flags.female ? "sweet lady" : "nice guy");
X! 		if (!tele_restrict(mon)) rloc(mon);
X  		return 1;
X  	}
X  	if (u.ualign.type == A_CHAOTIC && u.ualign.record < ALIGNLIM)
X***************
X*** 1992,1998 ****
X  	if (mon->mtame) /* don't charge */ ;
X  	else if (rn2(20) < ACURR(A_CHA)) {
X  		pline("%s demands that you pay %s, but you refuse...",
X! 			Monnam(mon), (fem ? "her" : "him"));
X  	}
X  #ifdef POLYSELF
X  	else if (u.umonnum == PM_LEPRECHAUN)
X--- 2001,2007 ----
X  	if (mon->mtame) /* don't charge */ ;
X  	else if (rn2(20) < ACURR(A_CHA)) {
X  		pline("%s demands that you pay %s, but you refuse...",
X! 			Monnam(mon), him[fem]);
X  	}
X  #ifdef POLYSELF
X  	else if (u.umonnum == PM_LEPRECHAUN)
X***************
X*** 2021,2027 ****
X  		}
X  	}
X  	if (!rn2(25)) mon->mcan = 1; /* monster is worn out */
X! 	rloc(mon);
X  	return 1;
X  }
X  
X--- 2030,2036 ----
X  		}
X  	}
X  	if (!rn2(25)) mon->mcan = 1; /* monster is worn out */
X! 	if (!tele_restrict(mon)) rloc(mon);
X  	return 1;
X  }
X  
X***************
X*** 2134,2141 ****
X  	/* These affect the enemy only if you are still a monster */
X  	if (rn2(3)) switch(uasmon->mattk[i].adtyp) {
X  	    case AD_PLYS: /* Floating eye */
X  		if (u.umonnum == PM_FLOATING_EYE) {
X! 		    if (!rn2(4)) tmp = 120;
X  		    if (mtmp->mcansee && haseyes(mtmp->data) && rn2(3) &&
X  				(perceives(mdat) || !Invis)) {
X  			if (Blind)
X--- 2143,2151 ----
X  	/* These affect the enemy only if you are still a monster */
X  	if (rn2(3)) switch(uasmon->mattk[i].adtyp) {
X  	    case AD_PLYS: /* Floating eye */
X+ 		if (tmp > 127) tmp = 127;
X  		if (u.umonnum == PM_FLOATING_EYE) {
X! 		    if (!rn2(4)) tmp = 127;
X  		    if (mtmp->mcansee && haseyes(mtmp->data) && rn2(3) &&
X  				(perceives(mdat) || !Invis)) {
X  			if (Blind)
X***************
X*** 2142,2147 ****
X--- 2152,2162 ----
X  			    pline("As a blind %s, you cannot defend yourself.",
X  							uasmon->mname);
X  		        else {
X+ #ifdef MUSE
X+ 			    if (mon_reflects(mtmp, 
X+ 					    "Your gaze is reflected by %s %s."))
X+ 				return 1;
X+ #endif
X  			    pline("%s is frozen by your gaze!", Monnam(mtmp));
X  			    mtmp->mcanmove = 0;
X  			    mtmp->mfrozen = tmp;
X*** /tmp/da11130	Tue Jun  1 16:14:28 1993
X--- src/mkroom.c	Tue Apr  6 15:46:24 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)mkroom.c	3.1	92/11/14	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)mkroom.c	3.1	93/04/04	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 363,368 ****
X--- 363,369 ----
X  	      if(enexto(mm, mm->x, mm->y, mdat))
X  		   (void) makemon(mdat, mm->x, mm->y);
X  	}
X+ 	level.flags.graveyard = TRUE;	/* reduced chance for undead corpse */
X  }
X  
X  static struct permonst *
X***************
X*** 618,625 ****
X  };
X  
X  static struct permonst *
X! squadmon() {	    /* return soldier types. */
X! 
X  	register struct permonst *ptr;
X  	register int	i, cpro, sel_prob = rnd(80+level_difficulty());
X  
X--- 619,626 ----
X  };
X  
X  static struct permonst *
X! squadmon()		/* return soldier types. */
X! {
X  	register struct permonst *ptr;
X  	register int	i, cpro, sel_prob = rnd(80+level_difficulty());
X  
X***************
X*** 634,640 ****
X  	if(!(ptr->geno & (G_GENOD | G_EXTINCT)))  return(ptr);
X  	else			    return((struct permonst *) 0);
X  }
X! #endif /* ARMY /* */
X  
X  /* 
X   * save_room : A recursive function that saves a room and its subrooms 
X--- 635,641 ----
X  	if(!(ptr->geno & (G_GENOD | G_EXTINCT)))  return(ptr);
X  	else			    return((struct permonst *) 0);
X  }
X! #endif /* ARMY */
X  
X  /* 
X   * save_room : A recursive function that saves a room and its subrooms 
X*** /tmp/da11138	Tue Jun  1 16:14:30 1993
X--- src/mon.c	Fri May 28 11:32:05 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)mon.c	3.1	93/02/21	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)mon.c	3.1	93/05/26	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 19,26 ****
X  #define warnDelay 10
X  long lastwarntime;
X  int lastwarnlev;
X  const char *warnings[] = {
X! 	"white", "pink", "red", "ruby", "purple", "black" };
X  
X  static void NDECL(warn_effects);
X  
X--- 19,28 ----
X  #define warnDelay 10
X  long lastwarntime;
X  int lastwarnlev;
X+ 
X  const char *warnings[] = {
X! 	"white", "pink", "red", "ruby", "purple", "black"
X! };
X  
X  static void NDECL(warn_effects);
X  
X***************
X*** 256,262 ****
X  	 * be handled here.  Swimmers are able to protect their stuff...
X  	 */
X  	if (!is_clinger(mtmp->data)
X! 	    && !is_swimmer(mtmp->data) && !magic_breathing(mtmp->data)) {
X  	    if (cansee(mtmp->mx,mtmp->my))
X  		pline("%s drowns.", Monnam(mtmp));
X  	    mondead(mtmp);
X--- 258,264 ----
X  	 * be handled here.  Swimmers are able to protect their stuff...
X  	 */
X  	if (!is_clinger(mtmp->data)
X! 	    && !is_swimmer(mtmp->data) && !amphibious(mtmp->data)) {
X  	    if (cansee(mtmp->mx,mtmp->my))
X  		pline("%s drowns.", Monnam(mtmp));
X  	    mondead(mtmp);
X***************
X*** 495,506 ****
X  	register struct monst *mtmp;
X  	register const char *str;
X  {
X! 	register struct obj *otmp;
X  
X  /*	prevent shopkeepers from leaving the door of their shop */
X  	if(mtmp->isshk && inhishop(mtmp)) return;
X  
X! 	for(otmp = level.objects[mtmp->mx][mtmp->my]; otmp; otmp=otmp->nexthere)
X  /*	Nymphs take everything.  Most monsters don't pick up corpses. */
X  	    if (
X  #ifdef MUSE
X--- 497,509 ----
X  	register struct monst *mtmp;
X  	register const char *str;
X  {
X! 	register struct obj *otmp, *otmp2;
X  
X  /*	prevent shopkeepers from leaving the door of their shop */
X  	if(mtmp->isshk && inhishop(mtmp)) return;
X  
X! 	for(otmp = level.objects[mtmp->mx][mtmp->my]; otmp; otmp = otmp2) {
X! 	    otmp2 = otmp->nexthere;
X  /*	Nymphs take everything.  Most monsters don't pick up corpses. */
X  	    if (
X  #ifdef MUSE
X***************
X*** 525,530 ****
X--- 528,534 ----
X  		newsym(mtmp->mx, mtmp->my);
X  		return;			/* pick only one object */
X  	    }
X+ 	}
X  }
X  
X  #endif /* OVL2 */
X***************
X*** 983,989 ****
X  #ifdef REINCARNATION
X  	   && !Is_rogue_level(&u.uz)
X  #endif
X! 					)
X  		(void) make_corpse(mdef);
X  }
X  
X--- 987,993 ----
X  #ifdef REINCARNATION
X  	   && !Is_rogue_level(&u.uz)
X  #endif
X! 	   && !(level.flags.graveyard && is_undead(mdef->data) && rn2(3)))
X  		(void) make_corpse(mdef);
X  }
X  
X***************
X*** 1010,1016 ****
X  monstone(mdef)
X  register struct monst *mdef;
X  {
X! 	struct obj *otmp, *contents;
X  	xchar x = mdef->mx, y = mdef->my;
X  
X  #ifdef MUSE
X--- 1014,1020 ----
X  monstone(mdef)
X  register struct monst *mdef;
X  {
X! 	struct obj *otmp, *obj, *nxt, *contents;
X  	xchar x = mdef->mx, y = mdef->my;
X  
X  #ifdef MUSE
X***************
X*** 1021,1037 ****
X  	lifesaved_monster(mdef);
X  	if (mdef->mhp > 0) return;
X  #endif
X  
X  	if((int)mdef->data->msize > MZ_TINY ||
X  	   !rn2(2 + ((mdef->data->geno & G_FREQ) > 2))) {
X  		otmp = mk_named_object(STATUE, mdef->data, x, y,
X! 			NAME(mdef), (int)mdef->mnamelth);
X! 		contents = otmp->cobj = mdef->minvent;
X! 		while(contents) {
X! 			contents->owornmask = 0L;
X! 			contents = contents->nobj;
X  		}
X! 		mdef->minvent = (struct obj *)0;
X  		if (mdef->mgold) {
X  			struct obj *au;
X  			au = mksobj(GOLD_PIECE, FALSE, FALSE);
X--- 1025,1057 ----
X  	lifesaved_monster(mdef);
X  	if (mdef->mhp > 0) return;
X  #endif
X+ 	mdef->mtrapped = 0;	/* (see m_detach) */
X  
X  	if((int)mdef->data->msize > MZ_TINY ||
X  	   !rn2(2 + ((mdef->data->geno & G_FREQ) > 2))) {
X  		otmp = mk_named_object(STATUE, mdef->data, x, y,
X! 					NAME(mdef), (int)mdef->mnamelth);
X! 		/* some objects may end up outside the statue */
X! 		contents = 0;
X! 		for (obj = mdef->minvent; obj; obj = nxt) {
X! 		    nxt = obj->nobj;
X! 		    obj->owornmask = 0L;
X! 		    if (obj->otyp == BOULDER ||
X! #if 0				/* monsters don't carry statues */
X!      (obj->otyp == STATUE && mons[obj->corpsenm].msize >= mdef->data->msize) ||
X! #endif
X! 				obj_resists(obj, 0, 0)) {
X! 			if (flooreffects(obj, x, y, "fall")) continue;
X! 			place_object(obj, x, y);
X! 			obj->nobj = fobj;
X! 			fobj = obj;
X! 		    } else {
X! 			obj->nobj = contents;
X! 			contents = obj;
X! 		    }
X  		}
X! 		otmp->cobj = contents;
X! 		mdef->minvent = 0;
X  		if (mdef->mgold) {
X  			struct obj *au;
X  			au = mksobj(GOLD_PIECE, FALSE, FALSE);
X***************
X*** 1055,1061 ****
X  monkilled(mdef, fltxt, how)
X  register struct monst *mdef;
X  const char *fltxt;
X! uchar how;
X  {
X  	if (cansee(mdef->mx, mdef->my) && fltxt)
X  	    pline("%s is %s%s%s!", Monnam(mdef),
X--- 1075,1081 ----
X  monkilled(mdef, fltxt, how)
X  register struct monst *mdef;
X  const char *fltxt;
X! int how;
X  {
X  	if (cansee(mdef->mx, mdef->my) && fltxt)
X  	    pline("%s is %s%s%s!", Monnam(mdef),
X***************
X*** 1154,1161 ****
X  #ifdef REINCARNATION
X  		 || Is_rogue_level(&u.uz)
X  #endif
X! 	   || (level.flags.graveyard && is_undead(mdat) &&
X! 			rn2(mdat == &mons[PM_WRAITH] ? 5 : 2)))
X  		goto cleanup;
X  
X  #ifdef MAIL
X--- 1174,1180 ----
X  #ifdef REINCARNATION
X  		 || Is_rogue_level(&u.uz)
X  #endif
X! 	   || (level.flags.graveyard && is_undead(mdat) && rn2(3)))
X  		goto cleanup;
X  
X  #ifdef MAIL
X***************
X*** 1572,1577 ****
X--- 1591,1610 ----
X  		if(!mtmp->female) mtmp->female = TRUE;
X  	} else if (!is_neuter(mdat)) {
X  		if(!rn2(10)) mtmp->female = !mtmp->female;
X+ 	}
X+ 
X+ 	if (In_endgame(&u.uz) && is_mplayer(olddata)) {
X+ 		/* mplayers start out as "Foo the Bar", but some of the
X+ 		 * titles are inappropriate when polymorphed, particularly
X+ 		 * into the opposite sex.  players don't use ranks when
X+ 		 * polymorphed, so dropping the rank for mplayers seems
X+ 		 * reasonable.
X+ 		 */
X+ 		char *p = index(NAME(mtmp), ' ');
X+ 		if (p) {
X+ 			*p = '\0';
X+ 			mtmp->mnamelth = p - NAME(mtmp) + 1;
X+ 		}
X  	}
X  
X  	if(mdat == mtmp->data) return(0);	/* still the same monster */
X*** /tmp/da11146	Tue Jun  1 16:14:34 1993
X--- src/mondata.c	Wed Apr 14 15:39:26 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)mondata.c	3.1	92/11/24	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)mondata.c	3.1	93/03/16	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 214,219 ****
X--- 214,225 ----
X  	if (!strncmp(str, "a ", 2)) str += 2;
X  	else if (!strncmp(str, "an ", 3)) str += 3;
X  
X+ 	/* Alternate spellings */
X+ 	if (!strncmpi(str, "grey dragon", 11)) return PM_GRAY_DRAGON;
X+ 	if (!strncmpi(str, "baby grey dragon", 16)) return PM_BABY_GRAY_DRAGON;
X+ 	if (!strncmpi(str, "grey unicorn", 12)) return PM_GRAY_UNICORN;
X+ 	if (!strncmpi(str, "grey ooze", 9)) return PM_GRAY_OOZE;
X+ 
X  	/* Some irregular plurals */
X  	if (!strncmpi(str, "incubi", 6)) return PM_INCUBUS;
X  	if (!strncmpi(str, "succubi", 7)) return PM_SUCCUBUS;
X***************
X*** 397,402 ****
X--- 403,413 ----
X  	return montype;
X  }
X  
X+ static const char *levitate[2]	= { "float", "Float" };
X+ static const char *fly[2]	= { "fly", "Fly" };
X+ static const char *slither[2]	= { "slither", "Slither" };
X+ static const char *ooze[2]	= { "ooze", "Ooze" };
X+ static const char *crawl[2]	= { "crawl", "Crawl" };
X  
X  const char *
X  locomotion(ptr, def)
X***************
X*** 403,414 ****
X  const struct permonst *ptr;
X  const char *def;
X  {
X  	return (
X! 		is_floater(ptr) ? (const char *)"float" :
X! 		is_flyer(ptr)   ? (const char *)"fly" :
X! 		slithy(ptr)     ? (const char *)"slither" :
X! 		amorphous(ptr)  ? (const char *)"ooze" :
X! 		nolimbs(ptr)    ? (const char *)"crawl" :
X  		def
X  	       );
X  
X--- 414,427 ----
X  const struct permonst *ptr;
X  const char *def;
X  {
X+ 	int capitalize = (*def == highc(*def));
X+ 
X  	return (
X! 		is_floater(ptr) ? levitate[capitalize] :
X! 		is_flyer(ptr)   ? fly[capitalize] :
X! 		slithy(ptr)     ? slither[capitalize] :
X! 		amorphous(ptr)  ? ooze[capitalize] :
X! 		nolimbs(ptr)    ? crawl[capitalize] :
X  		def
X  	       );
X  
X*** /tmp/da11154	Tue Jun  1 16:14:36 1993
X--- src/monmove.c	Mon May 17 14:04:41 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)monmove.c	3.1	93/02/17	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)monmove.c	3.1	93/05/15	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 61,67 ****
X  		  pline("%s yells:", Amonnam(mtmp));
X  		  if(levl[x][y].looted & D_WARNED) {
X  			verbalize("Halt, thief!  You're under arrest!");
X! 			angry_guards(!(flags.soundok));
X  		  } else {
X  			verbalize("Hey, stop picking that lock!");
X  			levl[x][y].looted |=  D_WARNED;
X--- 61,67 ----
X  		  pline("%s yells:", Amonnam(mtmp));
X  		  if(levl[x][y].looted & D_WARNED) {
X  			verbalize("Halt, thief!  You're under arrest!");
X! 			(void) angry_guards(!(flags.soundok));
X  		  } else {
X  			verbalize("Hey, stop picking that lock!");
X  			levl[x][y].looted |=  D_WARNED;
X***************
X*** 897,914 ****
X  	    if((info[chi] & ALLOW_M) ||
X  		   (nix == mtmp->mux && niy == mtmp->muy)) {
X  		struct monst *mtmp2;
X! 		int stat;
X  		mtmp2 = m_at(nix,niy);
X  
X! 		stat = mattackm(mtmp, mtmp2);
X  
X! 		if (stat & MM_AGR_DIED)		/* aggressor died */
X  		    return 2;
X  
X! 		if ((stat & MM_HIT) && !(stat & MM_DEF_DIED)  &&
X  		    rn2(4) && mtmp2->mlstmv != monstermoves) {
X! 		    stat = mattackm(mtmp2, mtmp);	/* return attack */
X! 		    if (stat & MM_DEF_DIED)
X  			return 2;
X  		}
X  		return 3;
X--- 897,914 ----
X  	    if((info[chi] & ALLOW_M) ||
X  		   (nix == mtmp->mux && niy == mtmp->muy)) {
X  		struct monst *mtmp2;
X! 		int mstatus;
X  		mtmp2 = m_at(nix,niy);
X  
X! 		mstatus = mattackm(mtmp, mtmp2);
X  
X! 		if (mstatus & MM_AGR_DIED)		/* aggressor died */
X  		    return 2;
X  
X! 		if ((mstatus & MM_HIT) && !(mstatus & MM_DEF_DIED)  &&
X  		    rn2(4) && mtmp2->mlstmv != monstermoves) {
X! 		    mstatus = mattackm(mtmp2, mtmp);	/* return attack */
X! 		    if (mstatus & MM_DEF_DIED)
X  			return 2;
X  		}
X  		return 3;
X***************
X*** 1083,1128 ****
X  #endif /* OVL2 */
X  #ifdef OVL0
X  
X  void
X! set_apparxy(mtmp)		/* where does mtmp think you are standing? */
X! 	register struct monst *mtmp;
X  {
X! #define notseen (Invis && !perceives(mtmp->data))
X! /*	add cases as required.  eg. Displacement ... */
X! 	register int disp = (Underwater ? 3 : notseen ? 1 : Displaced ? 2 : 0);
X  
X! /* 	without something like the following, invis. and displ. are too */
X! /*	powerful. */
X! 	register boolean gotu =
X! 		(notseen ? !rn2(3) : Displaced ? !rn2(4) : FALSE);
X  
X! /*	Monsters which know where you are don't suddenly forget, if you
X! 	didn't move away. */
X! 	if (mtmp->mux==u.ux && mtmp->muy==u.uy) gotu = 1;
X  
X! /* 	your dog follows your smell */
X! 	if(!disp || mtmp->mtame || gotu ||
X! /* 	Monsters touching you know where you are */
X! 	   mtmp == u.ustuck ||
X! /*	If invisible but not displaced, staying around gets you 'discovered' */
X! 	    (!Displaced && u.dx == 0 && u.dy == 0)) {
X! 		mtmp->mux = u.ux;
X! 		mtmp->muy = u.uy;
X  	}
X! 	else do {
X! 		mtmp->mux = u.ux - disp + rn2(2*disp+1);
X! 		mtmp->muy = u.uy - disp + rn2(2*disp+1);
X! 	} while((mtmp->mux != u.ux || mtmp->muy != u.uy) &&
X! 	        ( (!passes_walls(mtmp->data) &&
X! 		      (!ACCESSIBLE(levl[mtmp->mux][mtmp->muy].typ) ||
X! 		       (closed_door(mtmp->mux, mtmp->muy) &&
X! 			!amorphous(mtmp->data)
X! 		       )
X! 		      )
X! 		  ) ||
X! 		  (disp==1 && mtmp->mux == mtmp->mx && mtmp->muy == mtmp->my)
X! 	        )
X! 	       );
X  }
X  
X  #endif /* OVL0 */
X--- 1083,1139 ----
X  #endif /* OVL2 */
X  #ifdef OVL0
X  
X+ /* decide where the monster thinks you are standing */
X  void
X! set_apparxy(mtmp)
X! register struct monst *mtmp;
X  {
X! 	boolean notseen, gotu;
X! 	register int disp, mx = mtmp->mux, my = mtmp->muy;
X  
X! 	/*
X! 	 * do cheapest and/or most likely tests first
X! 	 */
X  
X! 	/* pet knows your smell; grabber still has hold of you */
X! 	if (mtmp->mtame || mtmp == u.ustuck) goto found_you;
X  
X! 	/* monsters which know where you are don't suddenly forget,
X! 	   if you haven't moved away */
X! 	if (mx == u.ux && my == u.uy) goto found_you;
X! 
X! 	notseen = Invis && !perceives(mtmp->data);
X! 	/* add cases as required.  eg. Displacement ... */
X! 	disp = (notseen || Underwater ? 1 : Displaced ? 2 : 0);
X! 	if (!disp) goto found_you;
X! 
X! 	/* without something like the following, invis. and displ.
X! 	   are too powerful */
X! 	gotu = notseen ? !rn2(3) : Displaced ? !rn2(4) : FALSE;
X! 
X! 	/* If invis but not displaced, staying around gets you 'discovered' */
X! 	gotu |= (!Displaced && u.dx == 0 && u.dy == 0);
X! 
X! 	if (!gotu) {
X! 	    register int try_cnt = 0;
X! 	    do {
X! 		if (++try_cnt > 200) goto found_you;		/* punt */
X! 		mx = u.ux - disp + rn2(2*disp+1);
X! 		my = u.uy - disp + rn2(2*disp+1);
X! 	    } while (!isok(mx,my)
X! 		  || (disp != 2 && mx == mtmp->mx && my == mtmp->my)
X! 		  || ((mx != u.ux || my != u.uy) &&
X! 		      !passes_walls(mtmp->data) &&
X! 		      (!ACCESSIBLE(levl[mx][my].typ) ||
X! 			(closed_door(mx, my) && !amorphous(mtmp->data)))));
X! 	} else {
X! found_you:
X! 	    mx = u.ux;
X! 	    my = u.uy;
X  	}
X! 
X! 	mtmp->mux = mx;
X! 	mtmp->muy = my;
X  }
X  
X  #endif /* OVL0 */
X*** /tmp/da11162	Tue Jun  1 16:14:39 1993
X--- src/monst.c	Tue Jun  1 14:28:15 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)monst.c	3.1	92/11/25		  */
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)monst.c	3.1	93/05/26		  */
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 712,718 ****
X  	  M2_HOSTILE | M2_STRONG | M2_NASTY,
X  	  0, C(MAGENTA) },
X  /*	Dummy monster needed for visual interface. */
X! 	{ "long worm tail", S_WORM_TAIL, 0, 0, 0, 0, 0, G_NOGEN | G_NOCORPSE,
X  	  { NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X  	  0, 0, 0, 0, 0, 0, 0, 0, M2_NOPOLY, 0, C(BROWN) },
X  /*	xan, &c.	*/
X--- 712,719 ----
X  	  M2_HOSTILE | M2_STRONG | M2_NASTY,
X  	  0, C(MAGENTA) },
X  /*	Dummy monster needed for visual interface. */
X! 	{ "long worm tail", S_WORM_TAIL, 0, 0, 0, 0, 0,
X! 	  (G_NOGEN | G_NOCORPSE | G_UNIQ),	/* uniq prevents figurines */
X  	  { NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X  	  0, 0, 0, 0, 0, 0, 0, 0, M2_NOPOLY, 0, C(BROWN) },
X  /*	xan, &c.	*/
X***************
X*** 1273,1280 ****
X  	  M1_NOLIMBS | M1_SLITHY | M1_THICK_HIDE | M1_OVIPAROUS,
X  	  M2_STRONG, 0, C(HI_GOLD) },
X  	{ "guardian naga", S_NAGA, 12, 16, 0, 50, 7, (G_GENO | 1),
X! 	  { { AT_BITE, AD_PLYS, 1, 6 }, { AT_HUGS, AD_PHYS, 2, 4 },
X! 	    { AT_SPIT, AD_DRST, 1, 6 }, NO_ATTK, NO_ATTK, NO_ATTK },
X  	  2600, 400, 0, MS_MUMBLE, MZ_HUGE, MR_POISON, MR_POISON,
X  	  M1_NOLIMBS | M1_SLITHY | M1_THICK_HIDE | M1_OVIPAROUS | M1_POIS,
X  	  M2_STRONG, 0, C(GREEN) },
X--- 1274,1281 ----
X  	  M1_NOLIMBS | M1_SLITHY | M1_THICK_HIDE | M1_OVIPAROUS,
X  	  M2_STRONG, 0, C(HI_GOLD) },
X  	{ "guardian naga", S_NAGA, 12, 16, 0, 50, 7, (G_GENO | 1),
X! 	  { { AT_BITE, AD_PLYS, 1, 6 }, { AT_SPIT, AD_DRST, 1, 6 },
X! 	    { AT_HUGS, AD_PHYS, 2, 4 }, NO_ATTK, NO_ATTK, NO_ATTK },
X  	  2600, 400, 0, MS_MUMBLE, MZ_HUGE, MR_POISON, MR_POISON,
X  	  M1_NOLIMBS | M1_SLITHY | M1_THICK_HIDE | M1_OVIPAROUS | M1_POIS,
X  	  M2_STRONG, 0, C(GREEN) },
X***************
X*** 1569,1576 ****
X  	  MR_SLEEP | MR_POISON, 0, M1_BREATHLESS | M1_MINDLESS | M1_HUMANOID,
X  	  M2_HOSTILE | M2_NEUTER, 0, C(YELLOW) },
X  	{ "rope golem", S_GOLEM, 4, 9, 8, 0, 0, (G_GENO | G_NOCORPSE | 1),
X! 	  { { AT_CLAW, AD_PHYS, 1, 6 }, { AT_HUGS, AD_PHYS, 6, 1 },
X! 	    NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X  	  450, 0, 0, MS_SILENT, MZ_LARGE,
X  	  MR_SLEEP | MR_POISON, 0, M1_BREATHLESS | M1_MINDLESS | M1_HUMANOID,
X  	  M2_HOSTILE | M2_NEUTER, 0, C(BROWN) },
X--- 1570,1577 ----
X  	  MR_SLEEP | MR_POISON, 0, M1_BREATHLESS | M1_MINDLESS | M1_HUMANOID,
X  	  M2_HOSTILE | M2_NEUTER, 0, C(YELLOW) },
X  	{ "rope golem", S_GOLEM, 4, 9, 8, 0, 0, (G_GENO | G_NOCORPSE | 1),
X! 	  { { AT_CLAW, AD_PHYS, 1, 4 }, { AT_CLAW, AD_PHYS, 1, 4 },
X! 	    { AT_HUGS, AD_PHYS, 6, 1 }, NO_ATTK, NO_ATTK, NO_ATTK },
X  	  450, 0, 0, MS_SILENT, MZ_LARGE,
X  	  MR_SLEEP | MR_POISON, 0, M1_BREATHLESS | M1_MINDLESS | M1_HUMANOID,
X  	  M2_HOSTILE | M2_NEUTER, 0, C(BROWN) },
X***************
X*** 1792,1799 ****
X  	    { AT_BITE, AD_DRST, 1, 6 }, { AT_WEAP, AD_PHYS, 2, 4 },
X  	    NO_ATTK, NO_ATTK },
X  	  WT_HUMAN, 400, 0, MS_HISS, MZ_LARGE,
X! 	  MR_POISON | MR_STONE, MR_POISON | MR_STONE, M1_SWIM |
X! 	  M1_AMPHIBIOUS | M1_HUMANOID | M1_SLITHY | M1_POIS | M1_OMNIVORE,
X  	  M2_NOPOLY | M2_HOSTILE | M2_STRONG | M2_PNAME | M2_FEMALE,
X  	  M3_WAITFORU, C(BRIGHT_GREEN) },
X  	{ "Wizard of Yendor", S_HUMAN, 30, 12, -8, 100, A_NONE, G_NOGEN,
X--- 1793,1800 ----
X  	    { AT_BITE, AD_DRST, 1, 6 }, { AT_WEAP, AD_PHYS, 2, 4 },
X  	    NO_ATTK, NO_ATTK },
X  	  WT_HUMAN, 400, 0, MS_HISS, MZ_LARGE,
X! 	  MR_POISON | MR_STONE, MR_POISON | MR_STONE, M1_FLY | M1_SWIM |
X! 	  M1_AMPHIBIOUS | M1_HUMANOID | M1_POIS | M1_OMNIVORE,
X  	  M2_NOPOLY | M2_HOSTILE | M2_STRONG | M2_PNAME | M2_FEMALE,
X  	  M3_WAITFORU, C(BRIGHT_GREEN) },
X  	{ "Wizard of Yendor", S_HUMAN, 30, 12, -8, 100, A_NONE, G_NOGEN,
X***************
X*** 2042,2048 ****
X  	{ "Death", S_DEMON, 20, 3, 4, 95, 0, (G_UNIQ | G_NOGEN),
X  	  { { AT_TUCH, AD_DETH, 8, 8 }, { AT_TUCH, AD_DETH, 8, 8 },
X  	    NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X! 	  WT_HUMAN, 0, 0, MS_DEATH, MZ_HUMAN,
X  	  MR_FIRE | MR_COLD | MR_ELEC | MR_SLEEP | MR_POISON | MR_STONE,
X  	  MR_FIRE | MR_COLD | MR_ELEC | MR_SLEEP | MR_POISON | MR_STONE,
X  	  M1_FLY | M1_SEE_INVIS | M1_HUMANOID | M1_REGEN,
X--- 2043,2049 ----
X  	{ "Death", S_DEMON, 20, 3, 4, 95, 0, (G_UNIQ | G_NOGEN),
X  	  { { AT_TUCH, AD_DETH, 8, 8 }, { AT_TUCH, AD_DETH, 8, 8 },
X  	    NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X! 	  WT_HUMAN, 0, 0, MS_RIDER, MZ_HUMAN,
X  	  MR_FIRE | MR_COLD | MR_ELEC | MR_SLEEP | MR_POISON | MR_STONE,
X  	  MR_FIRE | MR_COLD | MR_ELEC | MR_SLEEP | MR_POISON | MR_STONE,
X  	  M1_FLY | M1_SEE_INVIS | M1_HUMANOID | M1_REGEN,
X***************
X*** 2051,2057 ****
X  	{ "Pestilence", S_DEMON, 20, 3, 4, 95, 0, (G_UNIQ | G_NOGEN),
X  	  { { AT_TUCH, AD_PEST, 8, 8 }, { AT_TUCH, AD_PEST, 8, 8 },
X  	    NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X! 	  WT_HUMAN, 0, 0, MS_PESTILENCE, MZ_HUMAN,
X  	  MR_FIRE | MR_COLD | MR_ELEC | MR_SLEEP | MR_POISON | MR_STONE,
X  	  MR_FIRE | MR_COLD | MR_ELEC | MR_SLEEP | MR_POISON | MR_STONE,
X  	  M1_FLY | M1_SEE_INVIS | M1_HUMANOID | M1_REGEN,
X--- 2052,2058 ----
X  	{ "Pestilence", S_DEMON, 20, 3, 4, 95, 0, (G_UNIQ | G_NOGEN),
X  	  { { AT_TUCH, AD_PEST, 8, 8 }, { AT_TUCH, AD_PEST, 8, 8 },
X  	    NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X! 	  WT_HUMAN, 0, 0, MS_RIDER, MZ_HUMAN,
X  	  MR_FIRE | MR_COLD | MR_ELEC | MR_SLEEP | MR_POISON | MR_STONE,
X  	  MR_FIRE | MR_COLD | MR_ELEC | MR_SLEEP | MR_POISON | MR_STONE,
X  	  M1_FLY | M1_SEE_INVIS | M1_HUMANOID | M1_REGEN,
X***************
X*** 2060,2066 ****
X  	{ "Famine", S_DEMON, 20, 3, 4, 95, 0, (G_UNIQ | G_NOGEN),
X  	  { { AT_TUCH, AD_FAMN, 8, 8 }, { AT_TUCH, AD_FAMN, 8, 8 },
X  	    NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X! 	  WT_HUMAN, 0, 0, MS_FAMINE, MZ_HUMAN,
X  	  MR_FIRE | MR_COLD | MR_ELEC | MR_SLEEP | MR_POISON | MR_STONE,
X  	  MR_FIRE | MR_COLD | MR_ELEC | MR_SLEEP | MR_POISON | MR_STONE,
X  	  M1_FLY | M1_SEE_INVIS | M1_HUMANOID | M1_REGEN,
X--- 2061,2067 ----
X  	{ "Famine", S_DEMON, 20, 3, 4, 95, 0, (G_UNIQ | G_NOGEN),
X  	  { { AT_TUCH, AD_FAMN, 8, 8 }, { AT_TUCH, AD_FAMN, 8, 8 },
X  	    NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X! 	  WT_HUMAN, 0, 0, MS_RIDER, MZ_HUMAN,
X  	  MR_FIRE | MR_COLD | MR_ELEC | MR_SLEEP | MR_POISON | MR_STONE,
X  	  MR_FIRE | MR_COLD | MR_ELEC | MR_SLEEP | MR_POISON | MR_STONE,
X  	  M1_FLY | M1_SEE_INVIS | M1_HUMANOID | M1_REGEN,
X***************
X*** 2160,2166 ****
X  	    NO_ATTK, NO_ATTK, NO_ATTK },
X  	  WT_HUMAN, 400, 0, MS_HUMANOID, MZ_HUMAN, 0, 0,
X  	  M1_HUMANOID | M1_OMNIVORE,
X! 	  M2_NOPOLY | M2_HUMAN | M2_STRONG | M2_MALE | M2_COLLECT, 0, C(RED) },
X  	{ "cavewoman", S_HUMAN, 1, 10, 10, 0, 1, G_NOGEN,
X  	  { { AT_WEAP, AD_PHYS, 2, 4 }, NO_ATTK, NO_ATTK,
X  	    NO_ATTK, NO_ATTK, NO_ATTK },
X--- 2161,2168 ----
X  	    NO_ATTK, NO_ATTK, NO_ATTK },
X  	  WT_HUMAN, 400, 0, MS_HUMANOID, MZ_HUMAN, 0, 0,
X  	  M1_HUMANOID | M1_OMNIVORE,
X! 	  M2_NOPOLY | M2_HUMAN | M2_STRONG | M2_MALE | M2_COLLECT, 0,
X! 	  C(HI_DOMESTIC) },
X  	{ "cavewoman", S_HUMAN, 1, 10, 10, 0, 1, G_NOGEN,
X  	  { { AT_WEAP, AD_PHYS, 2, 4 }, NO_ATTK, NO_ATTK,
X  	    NO_ATTK, NO_ATTK, NO_ATTK },
X*** /tmp/da11170	Tue Jun  1 16:14:44 1993
X--- src/mplayer.c	Mon Mar 15 12:36:28 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)mplayer.c	3.1	92/10/28	*/
X  /*	Copyright (c) Izchak Miller, 1992.			  */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)mplayer.c	3.1	93/03/14	*/
X  /*	Copyright (c) Izchak Miller, 1992.			  */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 26,35 ****
X  	/* Mac team */
X  	"David", "Johnny", "Jon", "Jonathan", "Michael", "Rob",
X  	"Tim", "Wang",
X- 	/* OS/2 team */
X- 	"Timo",
X  	/* Atari team */
X  	"Eric",
X  	/* VMS team */
X  	"Joshua", "Pat",
X  	""};
X--- 26,37 ----
X  	/* Mac team */
X  	"David", "Johnny", "Jon", "Jonathan", "Michael", "Rob",
X  	"Tim", "Wang",
X  	/* Atari team */
X  	"Eric",
X+ 	/* NT team */
X+ 	"Michael",
X+ 	/* OS/2 team */
X+ 	"Timo",
X  	/* VMS team */
X  	"Joshua", "Pat",
X  	""};
X***************
X*** 281,311 ****
X  mplayer_talk(mtmp)
X  register struct monst *mtmp;
X  {
X! 	char pbuf[BUFSZ];
X  
X  	if(mtmp->mpeaceful) return; /* will drop to humanoid talk */
X  
X! 	Strcpy(pbuf, "Talk? -- ");
X! 	if(pl_character[0] == highc(*mtmp->data->mname)) { /* same kind */
X! 	     switch(rn2(4)) {
X! 	       case 0: Strcat(pbuf, "I can't win, and neither will you!");
X! 		       break;
X! 	       case 1: Strcat(pbuf, "You don't deserve to win!");
X! 		       break;
X! 	       case 3: Strcat(pbuf, "Mine should be the honor, not yours!");
X! 		       break;
X! 	     }
X! 	} else {
X! 	     switch(rn2(4)) {
X! 	       case 0: Strcat(pbuf, "The low-life wants to talk, eh?");
X! 		       break;
X! 	       case 1: Strcat(pbuf, "Fight, scum!");
X! 		       break;
X! 	       case 3: Strcat(pbuf, "Here is what I have to say!");
X! 		       break;
X! 	     }
X! 	}
X! 	pline(pbuf);
X  }
X  
X  /*mplayer.c*/
X--- 283,302 ----
X  mplayer_talk(mtmp)
X  register struct monst *mtmp;
X  {
X! 	static const char *same_class_msg[3] = {
X! 		"I can't win, and neither will you!",
X! 		"You don't deserve to win!",
X! 		"Mine should be the honor, not yours!",
X! 	},		  *other_class_msg[3] = {
X! 		"The low-life wants to talk, eh?",
X! 		"Fight, scum!",
X! 		"Here is what I have to say!",
X! 	};
X  
X  	if(mtmp->mpeaceful) return; /* will drop to humanoid talk */
X  
X! 	pline("Talk? -- %s", pl_character[0] == highc(*mtmp->data->mname) ?
X! 		same_class_msg[rn2(3)] : other_class_msg[rn2(3)]);
X  }
X  
X  /*mplayer.c*/
X*** /tmp/da11186	Tue Jun  1 16:14:48 1993
X--- src/muse.c	Tue Jun  1 12:13:09 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)muse.c	3.1	93/02/12	*/
X  /* Monster item usage routine.  Copyright (C) 1990 by Ken Arromdee */
X  /* NetHack may be freely redistributed.  See license for details.  */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)muse.c	3.1	93/05/25	*/
X  /* Monster item usage routine.  Copyright (C) 1990 by Ken Arromdee */
X  /* NetHack may be freely redistributed.  See license for details.  */
X  
X***************
X*** 319,324 ****
X--- 319,330 ----
X  	if (m.has_defense)	/* stairs, trapdoor or tele-trap, bugle alert */
X  		goto botm;
X  
X+ 	/* kludge to cut down on trap destruction (particularly portals) */
X+ 	t = t_at(x,y);
X+ 	if (t && (t->ttyp == PIT || t->ttyp == SPIKED_PIT ||
X+ 		  t->ttyp == WEB || t->ttyp == BEAR_TRAP))
X+ 		t = 0;		/* ok for monster to dig here */
X+ 
X  #define nomore(x) if(m.has_defense==x) continue;
X  	for (obj = mtmp->minvent; obj; obj = obj->nobj) {
X  		/* don't always use the same selection pattern */
X***************
X*** 326,332 ****
X  
X  		/* nomore(MUSE_WAN_DIGGING); */
X  		if (m.has_defense == MUSE_WAN_DIGGING) break;
X! 		if (obj->otyp == WAN_DIGGING && obj->spe > 0 && !stuck
X  		    && !mtmp->isshk && !mtmp->isgd && !mtmp->ispriest
X  		    && !is_floater(mtmp->data)
X  		    /* digging wouldn't be effective; assume they know that */
X--- 332,338 ----
X  
X  		/* nomore(MUSE_WAN_DIGGING); */
X  		if (m.has_defense == MUSE_WAN_DIGGING) break;
X! 		if (obj->otyp == WAN_DIGGING && obj->spe > 0 && !stuck && !t
X  		    && !mtmp->isshk && !mtmp->isgd && !mtmp->ispriest
X  		    && !is_floater(mtmp->data)
X  		    /* digging wouldn't be effective; assume they know that */
X***************
X*** 409,420 ****
X  		otmp->spe--;
X  		if (oseen) makeknown(WAN_TELEPORTATION);
X  mon_tele:
X! 		if(level.flags.noteleport) {
X! 		    if (vismon)
X! 		      pline("A mysterious force prevents %s from teleporting!",
X! 			mon_nam(mtmp));
X  		    return 2;
X- 		}
X  		if((/*mon_has_amulet(mtmp)||*/ Is_wiz1_level(&u.uz) ||
X  		      Is_wiz2_level(&u.uz) || Is_wiz3_level(&u.uz))
X  								&& !rn2(3)) {
X--- 415,422 ----
X  		otmp->spe--;
X  		if (oseen) makeknown(WAN_TELEPORTATION);
X  mon_tele:
X! 		if (tele_restrict(mtmp))
X  		    return 2;
X  		if((/*mon_has_amulet(mtmp)||*/ Is_wiz1_level(&u.uz) ||
X  		      Is_wiz2_level(&u.uz) || Is_wiz3_level(&u.uz))
X  								&& !rn2(3)) {
X***************
X*** 471,476 ****
X--- 473,480 ----
X  		return 2;
X  	    }
X  	case MUSE_WAN_DIGGING:
X+ 	    {	struct trap *ttmp;
X+ 
X  		mzapmsg(mtmp, otmp, FALSE);
X  		otmp->spe--;
X  		if (oseen) makeknown(WAN_DIGGING);
X***************
X*** 485,491 ****
X  			pline("The floor here is too hard to dig in.");
X  		    return 2;
X  		}
X! 		seetrap(maketrap(mtmp->mx, mtmp->my, TRAPDOOR));
X  		if (vis) {
X  			pline("%s's made a hole in the floor.", Monnam(mtmp));
X  			pline("%s falls through...", Monnam(mtmp));
X--- 489,497 ----
X  			pline("The floor here is too hard to dig in.");
X  		    return 2;
X  		}
X! 		ttmp = maketrap(mtmp->mx, mtmp->my, TRAPDOOR);
X! 		if (!ttmp) return 2;
X! 		seetrap(ttmp);
X  		if (vis) {
X  			pline("%s's made a hole in the floor.", Monnam(mtmp));
X  			pline("%s falls through...", Monnam(mtmp));
X***************
X*** 497,502 ****
X--- 503,509 ----
X  		/* we made sure that there is a level for mtmp to go to */
X  		migrate_to_level(mtmp, ledger_no(&u.uz)+1, 0);
X  		return 2;
X+ 	    }
X  	case MUSE_WAN_CREATE_MONSTER:
X  	    {	coord cc;
X  		struct permonst *pm=rndmonst();
X***************
X*** 524,529 ****
X--- 531,538 ----
X  				: rndmonst(), cc.x, cc.y);
X  			if (mon) newsym(mon->mx,mon->my);
X  		}
X+ 		/* flush monsters before asking for identification */
X+ 		flush_screen(0);
X  		if (oseen && !objects[SCR_CREATE_MONSTER].oc_name_known
X  			  && !objects[SCR_CREATE_MONSTER].oc_uname)
X  			docall(otmp); /* not makeknown(); be consistent */
X***************
X*** 651,664 ****
X  		) return 0;
X  	switch (rn2(8 + (difficulty > 3) + (difficulty > 6) +
X  				(difficulty > 8))) {
X  		case 0: case 1:
X  			return SCR_TELEPORTATION;
X  		case 2: return SCR_CREATE_MONSTER;
X  		case 3: case 4:
X  			return POT_HEALING;
X  		case 5: return POT_EXTRA_HEALING;
X- 		case 6: case 9:
X- 			return WAN_TELEPORTATION;
X  		case 7: if (is_floater(pm) || mtmp->isshk || mtmp->isgd
X  						|| mtmp->ispriest
X  									)
X--- 660,677 ----
X  		) return 0;
X  	switch (rn2(8 + (difficulty > 3) + (difficulty > 6) +
X  				(difficulty > 8))) {
X+ 		case 6: case 9:
X+ 			if (!rn2(3)) return WAN_TELEPORTATION;
X+ 			/* else FALLTHRU */
X  		case 0: case 1:
X  			return SCR_TELEPORTATION;
X+ 		case 8: case 10:
X+ 			if (!rn2(3)) return WAN_CREATE_MONSTER;
X+ 			/* else FALLTHRU */
X  		case 2: return SCR_CREATE_MONSTER;
X  		case 3: case 4:
X  			return POT_HEALING;
X  		case 5: return POT_EXTRA_HEALING;
X  		case 7: if (is_floater(pm) || mtmp->isshk || mtmp->isgd
X  						|| mtmp->ispriest
X  									)
X***************
X*** 665,672 ****
X  				return 0;
X  			else
X  				return WAN_DIGGING;
X- 		case 8: case 10:
X- 			return WAN_CREATE_MONSTER;
X  	}
X  	/*NOTREACHED*/
X  	return 0;
X--- 678,683 ----
X***************
X*** 1199,1211 ****
X  		    }
X  		}
X  		if (vismon) pline("%s seems more experienced.", Monnam(mtmp));
X- 		i = rnd(8);
X  		if (oseen) makeknown(POT_GAIN_LEVEL);
X  		m_useup(mtmp, otmp);
X  		if (!grow_up(mtmp,(struct monst *)0)) return 1;
X  			/* grew into genocided monster */
X- 		mtmp->mhp += i;
X- 		mtmp->mhpmax += i;
X  		return 2;
X  	case MUSE_WAN_MAKE_INVISIBLE:
X  		mzapmsg(mtmp, otmp, TRUE);
X--- 1210,1219 ----
X***************
X*** 1319,1328 ****
X  	switch (rn2(3)) {
X  		case 0:
X  			if (mtmp->isgd) return 0;
X! 			return rn2(4) ? POT_SPEED : WAN_SPEED_MONSTER;
X  		case 1:
X  			if (mtmp->mpeaceful && !See_invisible) return 0;
X! 			return rn2(4) ? POT_INVISIBILITY : WAN_MAKE_INVISIBLE;
X  		case 2:
X  			return POT_GAIN_LEVEL;
X  	}
X--- 1327,1336 ----
X  	switch (rn2(3)) {
X  		case 0:
X  			if (mtmp->isgd) return 0;
X! 			return rn2(6) ? POT_SPEED : WAN_SPEED_MONSTER;
X  		case 1:
X  			if (mtmp->mpeaceful && !See_invisible) return 0;
X! 			return rn2(6) ? POT_INVISIBILITY : WAN_MAKE_INVISIBLE;
X  		case 2:
X  			return POT_GAIN_LEVEL;
X  	}
X***************
X*** 1363,1368 ****
X  			&& obj->corpsenm == PM_COCKATRICE)
X  	);
X  }
X! #endif
X  
X  /*muse.c*/
X--- 1371,1401 ----
X  			&& obj->corpsenm == PM_COCKATRICE)
X  	);
X  }
X! 
X! boolean
X! mon_reflects(mon,str)
X! struct monst *mon;
X! const char *str;
X! {
X! 	struct obj *orefl = which_armor(mon, W_ARMS);
X! 
X! 	if (orefl && orefl->otyp == SHIELD_OF_REFLECTION) {
X! 	    if (str) {
X! 		pline(str, s_suffix(mon_nam(mon)), "shield");
X! 		makeknown(SHIELD_OF_REFLECTION);
X! 	    }
X! 	    return TRUE;
X! 	} else if ((orefl = which_armor(mon, W_AMUL)) &&
X! 				orefl->otyp == AMULET_OF_REFLECTION) {
X! 	    if (str) {
X! 		pline(str, s_suffix(mon_nam(mon)), "amulet");
X! 		makeknown(AMULET_OF_REFLECTION);
X! 	    }
X! 	    return TRUE;
X! 	}
X! 	return FALSE;
X! }
X! 
X! #endif	/* MUSE */
X  
X  /*muse.c*/
X*** /tmp/da11194	Tue Jun  1 16:14:52 1993
X--- src/music.c	Wed May 26 11:55:23 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)music.c	3.1	92/11/26	*/
X  /* 	Copyright (c) 1989 by Jean-Christophe Collet */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)music.c	3.1	93/05/25	*/
X  /* 	Copyright (c) 1989 by Jean-Christophe Collet */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 36,41 ****
X--- 36,52 ----
X  static void FDECL(do_earthquake,(int));
X  static int FDECL(do_improvisation,(struct obj *));
X  
X+ #ifdef UNIX386MUSIC
X+ static int NDECL(atconsole);
X+ static void FDECL(speaker,(struct obj *,char *));
X+ #endif
X+ #ifdef VPIX_MUSIC
X+ extern int sco_flag_console;	/* will need changing if not _M_UNIX */
X+ static void NDECL(playinit);
X+ static void FDECL(playstring, (char *,size_t));
X+ static void FDECL(speaker,(struct obj *,char *));
X+ #endif
X+ 
X  /*
X   * Wake every monster in range...
X   */
X***************
X*** 45,60 ****
X  int distance;
X  {
X  	register struct monst *mtmp = fmon;
X  
X  	while(mtmp) {
X! 		if (distu(mtmp->mx, mtmp->my) < distance/3) {
X! 			/* May scare some monsters */
X! 			if (!resist(mtmp, SCROLL_CLASS, 0, NOTELL))
X! 			  mtmp->mflee = 1;
X! 		} else if (distu(mtmp->mx, mtmp->my) < distance) {
X! 			mtmp->msleep = 0;
X! 			mtmp->mcanmove = 1;
X! 			mtmp->mfrozen = 0;
X  		}
X  		mtmp = mtmp->nmon;
X  	}
X--- 56,73 ----
X  int distance;
X  {
X  	register struct monst *mtmp = fmon;
X+ 	register int distm;
X  
X  	while(mtmp) {
X! 		distm = distu(mtmp->mx, mtmp->my);
X! 		if (distm < distance) {
X! 		    mtmp->msleep = 0;
X! 		    mtmp->mcanmove = 1;
X! 		    mtmp->mfrozen = 0;
X! 		    /* May scare some monsters */
X! 		    if (distm < distance/3 &&
X! 			    !resist(mtmp, SCROLL_CLASS, 0, NOTELL))
X! 			mtmp->mflee = 1;
X  		}
X  		mtmp = mtmp->nmon;
X  	}
X***************
X*** 71,79 ****
X  	register struct monst *mtmp = fmon;
X  
X  	while(mtmp) {
X! 		  if (distu(mtmp->mx, mtmp->my) < distance)
X! 		    if(mtmp->mcanmove && !resist(mtmp, WAND_CLASS, 0, NOTELL))
X! 		      mtmp->mcanmove = mtmp->mfrozen = 0;
X  		mtmp = mtmp->nmon;
X  	}
X  }
X--- 84,98 ----
X  	register struct monst *mtmp = fmon;
X  
X  	while(mtmp) {
X! 		if (distu(mtmp->mx, mtmp->my) < distance &&
X! 			!resist(mtmp, WAND_CLASS, 0, NOTELL)) {
X! 		    register int min_sleep = d(10,10);
X! 		    /* 10d10 turns + wake_nearby() to rouse */
X! 		    mtmp->msleep = 1;
X! 		    mtmp->mcanmove = 0;
X! 		    if ((int)mtmp->mfrozen < min_sleep)
X! 			mtmp->mfrozen = min_sleep;
X! 		}
X  		mtmp = mtmp->nmon;
X  	}
X  }
X***************
X*** 125,137 ****
X  /* Awake only soldiers of the level. */
X  
X  void
X! awaken_soldiers() {
X  #ifdef ARMY
X  	register struct monst *mtmp = fmon;
X  
X  	while(mtmp) {
X  	    if (is_mercenary(mtmp->data) && mtmp->data != &mons[PM_GUARD]) {
X! 		mtmp->mpeaceful = mtmp->msleep = 0;
X  		mtmp->mcanmove = 1;
X  		if (canseemon(mtmp))
X  		    pline("%s is now ready for battle!", Monnam(mtmp));
X--- 144,157 ----
X  /* Awake only soldiers of the level. */
X  
X  void
X! awaken_soldiers()
X! {
X  #ifdef ARMY
X  	register struct monst *mtmp = fmon;
X  
X  	while(mtmp) {
X  	    if (is_mercenary(mtmp->data) && mtmp->data != &mons[PM_GUARD]) {
X! 		mtmp->mpeaceful = mtmp->msleep = mtmp->mfrozen = 0;
X  		mtmp->mcanmove = 1;
X  		if (canseemon(mtmp))
X  		    pline("%s is now ready for battle!", Monnam(mtmp));
X***************
X*** 184,190 ****
X  	if (end_x >= COLNO) end_x = COLNO - 1;
X  	if (end_y >= ROWNO) end_y = ROWNO - 1;
X  	for (x=start_x; x<=end_x; x++) for (y=start_y; y<=end_y; y++) {
X! 	    if (mtmp = m_at(x,y)) {
X  		if (mtmp->mundetected && is_hider(mtmp->data)) {
X  		    mtmp->mundetected = 0;
X  		    if (cansee(x,y))
X--- 204,211 ----
X  	if (end_x >= COLNO) end_x = COLNO - 1;
X  	if (end_y >= ROWNO) end_y = ROWNO - 1;
X  	for (x=start_x; x<=end_x; x++) for (y=start_y; y<=end_y; y++) {
X! 	    if ((mtmp = m_at(x,y)) != 0) {
X! 		wakeup(mtmp);	/* peaceful monster will become hostile */
X  		if (mtmp->mundetected && is_hider(mtmp->data)) {
X  		    mtmp->mundetected = 0;
X  		    if (cansee(x,y))
X***************
X*** 220,225 ****
X--- 241,247 ----
X  		  case ROOM :
X  		  case CORR : /* Try to make a pit */
X  do_pit:		    chasm = maketrap(x,y,PIT);
X+ 		    if (!chasm) break;	/* no pit if portal at that location */
X  		    chasm->tseen = 1;
X  
X  		    levl[x][y].doormask = 0;
X***************
X*** 226,232 ****
X  
X  		    mtmp = m_at(x,y);
X  
X! 		    if (otmp = sobj_at(BOULDER, x, y)) {
X  			if (cansee(x, y))
X  			   pline("KADOOM! The boulder falls into a chasm%s!",
X  			      ((x == u.ux) && (y == u.uy)) ? " below you" : "");
X--- 248,254 ----
X  
X  		    mtmp = m_at(x,y);
X  
X! 		    if ((otmp = sobj_at(BOULDER, x, y)) != 0) {
X  			if (cansee(x, y))
X  			   pline("KADOOM! The boulder falls into a chasm%s!",
X  			      ((x == u.ux) && (y == u.uy)) ? " below you" : "");
X***************
X*** 235,241 ****
X  			freeobj(otmp);
X  			(void) flooreffects(otmp, x, y, "");
X  			break;
X! 		    }	
X  
X  		    /* We have to check whether monsters or player
X  		       falls in a chasm... */
X--- 257,263 ----
X  			freeobj(otmp);
X  			(void) flooreffects(otmp, x, y, "");
X  			break;
X! 		    }
X  
X  		    /* We have to check whether monsters or player
X  		       falls in a chasm... */
X***************
X*** 304,313 ****
X  #ifdef MAC
X  	mac_speaker ( instr , "C" ) ;
X  #endif
X- 
X  #ifdef AMIGA
X  	amii_speaker ( instr , "Cw", AMII_OKAY_VOLUME ) ;
X  #endif
X  	if (Confusion)
X  	  pline("What you produce is quite far from music...");
X  	else
X--- 326,338 ----
X  #ifdef MAC
X  	mac_speaker ( instr , "C" ) ;
X  #endif
X  #ifdef AMIGA
X  	amii_speaker ( instr , "Cw", AMII_OKAY_VOLUME ) ;
X  #endif
X+ #ifdef VPIX_MUSIC
X+ 	if (sco_flag_console)
X+ 		speaker(instr, "C");
X+ #endif
X  	if (Confusion)
X  	  pline("What you produce is quite far from music...");
X  	else
X***************
X*** 321,326 ****
X--- 346,352 ----
X  	      case MAGIC_FLUTE: /* Make monster fall asleep */
X  		if (instr->spe > 0) {
X  			instr->spe--;
X+ 			check_unpaid(instr);
X  			You("produce soft music.");
X  			put_monsters_to_sleep((int)u.ulevel*5);
X  		}
X***************
X*** 335,340 ****
X--- 361,367 ----
X  	      case FIRE_HORN:	/* Idem wand of fire */
X  		if (instr->spe > 0) {
X  			instr->spe--;
X+ 			check_unpaid(instr);
X  			if (!getdir(NULL)) {
X  				if (!Blind)
X  				    pline("%s glows then fades.",
X***************
X*** 366,374 ****
X  		break;
X  	      case MAGIC_HARP:	/* Charm monsters */
X  		if (instr->spe > 0) {
X  			pline("%s produces very attractive music.",
X  			      The(xname(instr)));
X- 			instr->spe--;
X  			charm_monsters(((int)u.ulevel - 1) / 3 + 1);
X  		}
X  		exercise(A_DEX, TRUE);
X--- 393,402 ----
X  		break;
X  	      case MAGIC_HARP:	/* Charm monsters */
X  		if (instr->spe > 0) {
X+ 			instr->spe--;
X+ 			check_unpaid(instr);
X  			pline("%s produces very attractive music.",
X  			      The(xname(instr)));
X  			charm_monsters(((int)u.ulevel - 1) / 3 + 1);
X  		}
X  		exercise(A_DEX, TRUE);
X***************
X*** 380,389 ****
X  		break;
X  	      case DRUM_OF_EARTHQUAKE:	/* create several pits */
X  		if (instr->spe > 0) {
X  			You("produce a heavy, thunderous rolling!");
X  			pline("The entire dungeon is shaking around you!");
X- 			instr->spe--;
X  			do_earthquake(((int)u.ulevel - 1) / 3 + 1);
X  			makeknown(DRUM_OF_EARTHQUAKE);
X  		}
X  		break;
X--- 408,420 ----
X  		break;
X  	      case DRUM_OF_EARTHQUAKE:	/* create several pits */
X  		if (instr->spe > 0) {
X+ 			instr->spe--;
X+ 			check_unpaid(instr);
X  			You("produce a heavy, thunderous rolling!");
X  			pline("The entire dungeon is shaking around you!");
X  			do_earthquake(((int)u.ulevel - 1) / 3 + 1);
X+ 			/* shake up monsters in a much larger radius... */
X+ 			awaken_monsters(ROWNO * COLNO);
X  			makeknown(DRUM_OF_EARTHQUAKE);
X  		}
X  		break;
X***************
X*** 394,464 ****
X  	return (2);		/* That takes time */
X  }
X  
X- #ifdef SYSV386MUSIC
X  /*
X-  * Play audible music on the machine's speaker if appropriate.
X-  */
X- 
X- static int
X- atconsole()
X- {
X-     /*
X-      * Kluge alert: This code assumes that your [34]86 has no X terminals
X-      * attached and that the console tty type is AT386 (this is always true
X-      * under AT&T UNIX for these boxen). The theory here is that your remote
X-      * ttys will have terminal type `ansi' or something else other than
X-      * `AT386' or `xterm'. We'd like to do better than this, but testing
X-      * to see if we're running on the console physical terminal is quite
X-      * difficult given the presence of virtual consoles and other modern
X-      * UNIX impedimenta...
X-      */
X-     char	*termtype = getenv("TERM");
X- 
X-      return(!strcmp(termtype, "AT386") || !strcmp(termtype, "xterm"));
X- }
X- 
X- static void
X- speaker(instr, buf)
X- struct obj *instr;
X- char	*buf;
X- {
X-     /*
X-      * For this to work, you need to have installed the PD speaker-control
X-      * driver for PC-compatible UNIX boxes that I (eric@snark.uu.net)
X-      * posted to comp.sources.unix in Feb 1990. A copy may be included
X-      * with your nethack distribution.
X-      */
X-     int	fd;
X- 
X-     if ((fd = open("/dev/speaker", 1)) != -1)
X-     {
X- 	/* send a prefix to modify instrumental `timbre' */
X- 	switch (instr->otyp)
X- 	{
X- 	case WOODEN_FLUTE:
X- 	case MAGIC_FLUTE:
X- 	    (void) write(fd, ">ol", 1); /* up one octave & lock */
X- 	    break;
X- 	case TOOLED_HORN:
X- 	case FROST_HORN:
X- 	case FIRE_HORN:
X- 	    (void) write(fd, "<<ol", 2); /* drop two octaves & lock */
X- 	    break;
X- 	case BUGLE:
X- 	    (void) write(fd, "ol", 2); /* octave lock */
X- 	    break;
X- 	case WOODEN_HARP:
X- 	case MAGIC_HARP:
X- 	    (void) write(fd, "l8mlol", 4); /* fast, legato, octave lock */
X- 	    break;
X- 	}
X- 	(void) write(fd, buf, strlen(buf));
X- 	(void) close(fd);
X-     }
X- }
X- #endif /* SYSV386MUSIC */
X- 
X- /*
X   * So you want music...
X   */
X  
X--- 425,431 ----
X***************
X*** 478,494 ****
X  	c = yn("Improvise?");
X      }
X      if (c == 'n') {
X! 	getlin("What tune are you playing? [what 5 notes]", buf);
X  #ifndef	AMIGA
X  	/* The AMIGA supports two octaves of notes */
X  	for (s=buf; *s; s++) *s = highc(*s);
X  #endif
X  	You("extract a strange sound from %s!", the(xname(instr)));
X! #ifdef SYSV386MUSIC 
X  	/* if user is at the console, play through the console speaker */
X  	if (atconsole())
X  	    speaker(instr, buf);
X! #endif /* SYSV386MUSIC */
X  #ifdef MAC
X  	mac_speaker ( instr , buf ) ;
X  #endif
X--- 445,468 ----
X  	c = yn("Improvise?");
X      }
X      if (c == 'n') {
X! 	if (u.uevent.uheard_tune == 2 && yn("Play the passtune?") == 'y')
X! 		Strcpy(buf, tune);
X! 	else
X! 		getlin("What tune are you playing? [what 5 notes]", buf);
X  #ifndef	AMIGA
X  	/* The AMIGA supports two octaves of notes */
X  	for (s=buf; *s; s++) *s = highc(*s);
X  #endif
X  	You("extract a strange sound from %s!", the(xname(instr)));
X! #ifdef UNIX386MUSIC
X  	/* if user is at the console, play through the console speaker */
X  	if (atconsole())
X  	    speaker(instr, buf);
X! #endif
X! #ifdef VPIX_MUSIC
X! 	if (sco_flag_console)
X! 	    speaker(instr, buf);
X! #endif
X  #ifdef MAC
X  	mac_speaker ( instr , buf ) ;
X  #endif
X***************
X*** 575,579 ****
X--- 549,696 ----
X      } else
X  	    return do_improvisation(instr);
X  }
X+ 
X+ #ifdef UNIX386MUSIC
X+ /*
X+  * Play audible music on the machine's speaker if appropriate.
X+  */
X+ 
X+ static int
X+ atconsole()
X+ {
X+     /*
X+      * Kluge alert: This code assumes that your [34]86 has no X terminals
X+      * attached and that the console tty type is AT386 (this is always true
X+      * under AT&T UNIX for these boxen). The theory here is that your remote
X+      * ttys will have terminal type `ansi' or something else other than
X+      * `AT386' or `xterm'. We'd like to do better than this, but testing
X+      * to see if we're running on the console physical terminal is quite
X+      * difficult given the presence of virtual consoles and other modern
X+      * UNIX impedimenta...
X+      */
X+     char	*termtype = getenv("TERM");
X+ 
X+      return(!strcmp(termtype, "AT386") || !strcmp(termtype, "xterm"));
X+ }
X+ 
X+ static void
X+ speaker(instr, buf)
X+ struct obj *instr;
X+ char	*buf;
X+ {
X+     /*
X+      * For this to work, you need to have installed the PD speaker-control
X+      * driver for PC-compatible UNIX boxes that I (esr@snark.thyrsus.com)
X+      * posted to comp.sources.unix in Feb 1990.  A copy should be included
X+      * with your nethack distribution.
X+      */
X+     int	fd;
X+ 
X+     if ((fd = open("/dev/speaker", 1)) != -1)
X+     {
X+ 	/* send a prefix to modify instrumental `timbre' */
X+ 	switch (instr->otyp)
X+ 	{
X+ 	case WOODEN_FLUTE:
X+ 	case MAGIC_FLUTE:
X+ 	    (void) write(fd, ">ol", 1); /* up one octave & lock */
X+ 	    break;
X+ 	case TOOLED_HORN:
X+ 	case FROST_HORN:
X+ 	case FIRE_HORN:
X+ 	    (void) write(fd, "<<ol", 2); /* drop two octaves & lock */
X+ 	    break;
X+ 	case BUGLE:
X+ 	    (void) write(fd, "ol", 2); /* octave lock */
X+ 	    break;
X+ 	case WOODEN_HARP:
X+ 	case MAGIC_HARP:
X+ 	    (void) write(fd, "l8mlol", 4); /* fast, legato, octave lock */
X+ 	    break;
X+ 	}
X+ 	(void) write(fd, buf, strlen(buf));
X+ 	(void) close(fd);
X+     }
X+ }
X+ #endif /* UNIX386MUSIC */
X+ 
X+ #ifdef VPIX_MUSIC
X+ 
X+ # if 0
X+ #include <sys/types.h>
X+ #include <sys/console.h>
X+ #include <sys/vtkd.h>
X+ # else
X+ #define KIOC ('K' << 8)
X+ #define KDMKTONE (KIOC | 8)
X+ # endif
X+ 
X+ #define noDEBUG
X+ 
X+ #include "interp.c"	/* from snd86unx.shr */
X+ 
X+ static void tone(hz, ticks)
X+ /* emit tone of frequency hz for given number of ticks */
X+ unsigned int hz, ticks;
X+ {
X+     ioctl(0,KDMKTONE,hz|((ticks*10)<<16));
X+ # ifdef DEBUG
X+     printf("TONE: %6d %6d\n",hz,ticks * 10);
X+ # endif
X+     nap(ticks * 10);
X+ }
X+ 
X+ 
X+ static void rest(ticks)
X+ /* rest for given number of ticks */
X+ int	ticks;
X+ {
X+     nap(ticks * 10);
X+ # ifdef DEBUG
X+     printf("REST:        %6d\n",ticks * 10);
X+ # endif
X+ }
X+ 
X+ 
X+ static void
X+ speaker(instr, buf)
X+ struct obj *instr;
X+ char	*buf;
X+ {
X+     /* emit a prefix to modify instrumental `timbre' */
X+     playinit();
X+     switch (instr->otyp)
X+     {
X+ 	case WOODEN_FLUTE:
X+ 	case MAGIC_FLUTE:
X+ 	    playstring(">ol", 1); /* up one octave & lock */
X+ 	    break;
X+ 	case TOOLED_HORN:
X+ 	case FROST_HORN:
X+ 	case FIRE_HORN:
X+ 	    playstring("<<ol", 2); /* drop two octaves & lock */
X+ 	    break;
X+ 	case BUGLE:
X+ 	    playstring("ol", 2); /* octave lock */
X+ 	    break;
X+ 	case WOODEN_HARP:
X+ 	case MAGIC_HARP:
X+ 	    playstring("l8mlol", 4); /* fast, legato, octave lock */
X+ 	    break;
X+     }
X+     playstring( buf, strlen(buf));
X+ }
X+ 
X+ # ifdef DEBUG
X+ main(argc,argv)
X+ char *argv[];
X+ {
X+     if (argc == 2) {
X+ 	playinit();
X+ 	playstring(argv[1], strlen(argv[1]));
X+     }
X+ }
X+ # endif
X+ #endif	/* VPIX_MUSIC */
X  
X  /*music.c*/
END_OF_FILE
if test 54556 -ne `wc -c <'patches02e'`; then
    echo shar: \"'patches02e'\" unpacked with wrong size!
fi
# end of 'patches02e'
if test -f 'sys/mac/NHrez.hqx' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'sys/mac/NHrez.hqx'\" to \"'sys/mac/NHrez.hqx.orig'\"
  mv -f 'sys/mac/NHrez.hqx' 'sys/mac/NHrez.hqx.orig'
fi
echo shar: Extracting \"'sys/mac/NHrez.hqx'\" \(3692 characters\)
sed "s/^X//" >'sys/mac/NHrez.hqx' <<'END_OF_FILE'
X(This file must be converted with BinHex 4.0)
X
X:#8jPG%KKBfXZFJ"849K869"6)!#3"!Nc!!!"V2@%58j$6&9%45!L6Q9d5'&MDbj
XbFh*M)MX*N!-[+L"048j9,#"03N&5,#""6&*8,#"A58j%,#"*3diM,#"PG'-J+Lm
X058j$6&9%45!L8fpeEQ4c,R*cFQ-L1`Q3!bmU)%PZFh4bG@ePER4c)'&c)(0ZC#"
XbCA0[GA*MCA-J+Lm0$50TEQ0XG@4P)#*8HA"PFbjb)JdMD@jME(9NC5!L8hPc9(P
X`CA-ZFL)0)fPZBfaeC'8J)N*KE'a[Efj8HA"PFbjb)JNJN!3[+L"0B@-JFQ9cEh9
XbBf8JG(P`C5"NC@CTEQPdD@pZFb!U,`d0FQ9KC#!R9%9B9#FJ+$%`N!-X)NKPE(!
XL+5!*)#3N8fKPE'`S)N4KG#)T)#*)C@a`)MX0FQ9KC#!R9%9B9#FJ+$%`-$%X)PG
XTHNKPE(!L+5!N*&0SC@aX+#*%BA3L+5!L9fPk5'9XF#)l$A*PB@3J*e4&@&3R)#J
Xa-$!b,#*2F(4)C@a`)LNJ*#46D'9XE#JL4'&d)LNJ)Np`G%KPE(!L1`d[+JebC@&
XN)#G849K8*b!S-6!`-b`L3feN5'9XF#)T)#3N8fKPE'`S)N4KG#)T)#*$E@4)C@a
X`)MX0+Lm0FQ9KC#!R9%9B9#FJ+$%`-$3X)NeKBdKPE(!L+5!N*&0SC@aX+#*0B@0
X%DA)L+5!L6@&M5'9XF#)l$3ebC@&N)#G849K8*b!S-6!`05`L5%JL+5!*)#3N8fK
XPE'`S)N4KG#)T)#*)5#)l$A*PB@3J*e4&@&3R)#Ja-$!f,#*)DA0dEh*j)LNJ*#4
X6D'9XE#JL4'&d)LNJ)NKTFh4[FRNL1`ebC@&N)#G849K8*b!S-6!`0b`L6'PMC@j
XcC5)T)#3N8fKPE'`S)N4KG#)T)#*-D@0PER0P)MX0$A*PB@3J*e4&@&3R)#Ja-$!
Xi,#*1CAGc)LN*)#3N8fKPE'`S)NeKBd4TFL)T)#*1CAGc)MX0FQ9KC#!R9%9B9#F
XJ+$%`-$NX)Np`G'P[ER-L+5!N*&0SC@aX+#*2BQT%DA)L+5!L6h"dD@pZFb)l$3d
X[+JebC@&N)#G849K8*b!S-6!a-#`L8R9YEh*c)LNJ)#3N8fKPE'`S)NpLDN4TFL)
XT)#*5G@e[FR-L1`ebC@&N)#G849K8*b!S-6!a-5`L4'&dB5)T)*!%*#46D'9XE#J
XL6f*U4'Pb)LNJ)N4KG'%L1`dU,`d0FQ9cEh9bBf8J*e0*@N8R)#JY-5NJH`d*FQ9
XcCA*fC@3X$3PKBf0PF(46GA0`C@jN8Q9cG@eP4ACPER4c,!d*FQ9cCA*fC@3X$3P
XMB@j#B@0VCh*[G@jN,!d*C'pPFd&MG'PfBA4P6fj'4e0hDA4MD#`0#@*KBfYRFQp
XeEQ4"EQ4'Eh*PCh*[G@jN,!d*C'pZG%GPG%CbEfjd3faTBfYc,!d*D@GZEh*P3A"
X`4'PPC%9fC@jdFb`0#@Pc-c*#DA4$Efe`BA4TBQaP,!d*EQpd5'PRD%aPGQ9X4AC
XPER4"Gf&bC5`0#@pZE(P-Ef0KE%K-4ACPER4c,!d*EQpd8h4KG'P[EQ9bH8&hBA*
XP,!d*C'pZG&9cC94PH(4&C'Pd8f9bGQPMCA-X$3PbCA0PFRCPC#`0#A*PFf9bGQ9
XN,!d*FQ9cCA*fC@3X$3Na06!`)#SJ-6!b0#`*#5mU)(*PBfpYE@9ZC'9N)#S[$3N
Xa-*!$)#SJ-6!b0!Q3!bmU)'&LFfpXGA4P)'eTEQPYG@dX)(4[)'*P)'4PG'9bE@P
XZC@3J+Lm0I6X0$5mU)&0jFh4PE5!h)'KPE(!JBQ&XE'p[EL"TEQC[FQeKG'P[EL!
XU,`ebCA0[GA*MC5!RD'CNFLFJ+#de0MNf,#"`GA*RC@&LE'8T)(XJ$5#3"8KPE("
X0Ch*@CA*cD@pZ,#"SE84PCQ&eE(42F(4TEfjc,#!`,#!`,#![+L"SC@&NCA)JD@j
XQEh*YBA4TEfiJ+LmJ$3NJN!4l)%K08e458Q9c5A4PE5"l)#mU)(9cC5!R8e45)#F
XJFQ9cEh9bBf8J-M#3!b!U,b!b-*!$)(dJ$3Pp)!ep1`d0FQ9cEh9bBf8J*e088L!
XR)#Jb-*!$,#"`GA*RC@&LE'8T)(XJ,bSJ5'9XF#"YCA0cB@GP)'C[FL"KF(!JD@0
X[EL!U,`dJN!-L6Q9d5'&MDb!c,M&FEP4SDA-JDA-JG'KP)'CKE@peFb"%G@jRC@p
XZFb"KEQ3J4(*KCfpZFkSYE'PVC5"RB@eP)("[FR4PC#"dEb"dD'8J6@&MD@jdEh0
XS,L)J$Adl$3ebCA0[GA*MC5!R8e45)#FS,6%f-cNf,#"`GA*RC@&LE'8T)(X*,bS
XJ9fPXE#"LC5"MEh"TC@3JG'mJG'KP)(0KGQ9N)'CTE'8Z)#S[$3NL6Q9d5'&MDb)
X*N!F[+L"6C@8J5@jcD@4P)%eKBb"@55`JF'&RC5!j,6)a,JNJ+Lm0I6X0N!-[+L"
X0B@-JCA*bEh)JC'9MEf4PFb!k)$)`N!-J,5"PFR)M)'C[FL"MEfeYEfiJCA*bEh*
Xc,L""C'3JH@peFL"QBAC[FQPdCA-JBQ9XEhFJ+Lm0$A*PFfpeFQ0P)#G69&)J*b!
XS-M!c0#NJHb!LG'KP)'4TFfXJDA-JCR9XE#)J)(dl$A*PFfpeFQ0P)#G69&)J*b!
XS-M!c0LNJHb!LG'KPFQ8JGf&c)'&Z)%N[6b"PFR*[FL)J)(dl$A*PFfpeFQ0P)#G
X69&)J*b!S-M!d-bNJHb!LB5"QD@aP)'Pc)'eTFh0TEQFL)#"p1`ebCA0[GA*MC5!
XR8e45)#FJ+$)`0$3T)(XJ)R4SC5"NDA0V)'Pc)(GbDA4P,A"bEh4PBh4PC#)J)(d
Xl$A*PFfpeFQ0P)#G69&)J*b!S-M!d0bNJHb!LG'KP)'CTE'8JDA-JBR9cH5)J)(d
Xl$A*PFfpeFQ0P)#G69&)J*b!S-M!d15NJHb!LG'KP)'CTE'8JDA-JB@abC@&NH5"
X[F'9Z)L!JI6X0FQ9cEh9bBf8J*e088L!R)#Jb-6!i+5"l)#*dD'9bC5"TFb"ZEh3
XJC@j[G@GS)'ePE@pbH5)J)(dl$A*PFfpeFQ0P)#G69&)J*b!S-M%j-LNJHb!LB5"
XbCA0[GA*MC5"TFb"YDA0cD@jR)L!JI6X0NN!!!!%!N!-"EJ#3!fi!N!-q'rJ!!$[
Xi!!"lq!!!!rJ!!2ri!!$`1!!!rrJ!!1!i!!!*6Q9d5'&MDbjb!J#3!e4&@&409dP
X*!*!-9%9B9%eA58N!N"LS#ac8!!!*-`!!!D`!N"'!ri!!!)&!!!#")!!!J4!!!)(
Xi!!#!#!!!MmJ!!)!)!!#Ib!!!J!J!!)r)!!#!#!!!RmJ!!)!)!!#!#!!!rrJ!N$9
X)!!P0EfjKBfm!!'pd)'9iC@0eG'8JB5"NDA*PBh4[FRNX)!!'!!3!+J!N!eF#)!!
Xm!#3"M3)pTkY4EJ#3$!%!N!3H!#S!*!0A!L!!2!!N!Bd#23#3%!%!N!-"EJ#3!fi
X!N!-q!"[ej!C!!*!$(!!q!!"08&05!!%!#J2Yrrm!N!8EqZJ$m2rr!*!$6!!Eq33
Xp+3:
END_OF_FILE
if test 3692 -ne `wc -c <'sys/mac/NHrez.hqx'`; then
    echo shar: \"'sys/mac/NHrez.hqx'\" unpacked with wrong size!
fi
# end of 'sys/mac/NHrez.hqx'
echo shar: End of archive 15 \(of 33\).
cp /dev/null ark15isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 33 archives.
    echo "Now execute ./patchit.sh"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
