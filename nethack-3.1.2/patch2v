Path: uunet!gatech!howland.reston.ans.net!ux1.cso.uiuc.edu!uwm.edu!ogicse!news.tek.com!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v17i097:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Patch2v/33
Message-ID: <1v8irj$j5v@ying.cna.tek.com>
Date: 11 Jun 93 00:15:47 GMT
Article-I.D.: ying.1v8irj$j5v
Organization: Tektronix, Inc, Redmond, OR, USA
Lines: 2133
Approved: billr@saab.CNA.TEK.COM
NNTP-Posting-Host: saab.cna.tek.com
Xref: uunet comp.sources.games:1760

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 17, Issue 97
Archive-name: nethack31/Patch2v
Patch-To: nethack31: Volume 16, Issue 1-116
Environment: Amiga, Atari, Mac, MS-DOS, Windows-NT, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 22 (of 33)."
# Contents:  patches02p.1 src/sounds.c
# Wrapped by billr@saab on Thu Jun 10 16:55:06 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'patches02p.1' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'patches02p.1'\" to \"'patches02p.1.orig'\"
  mv -f 'patches02p.1' 'patches02p.1.orig'
fi
echo shar: Extracting \"'patches02p.1'\" \(39051 characters\)
sed "s/^X//" >'patches02p.1' <<'END_OF_FILE'
X*** /tmp/da14064	Tue Jun  1 20:02:00 1993
X--- sys/mac/macwin.c	Tue Jun  1 19:57:55 1993
X***************
X*** 17,22 ****
X--- 17,24 ----
X  
X  #include "hack.h"
X  #include "func_tab.h"
X+ #include "mactty.h"
X+ #include "wintty.h"
X  
X  #include <osutils.h>
X  #include <dialogs.h>
X***************
X*** 38,48 ****
X  
X  NhWindow * theWindows = (NhWindow *) NULL ;
X  
X  /*
X   * Some useful #defines for the scroll bar width and height
X   */
X  #define		SBARWIDTH	15
X! #define		SBARHEIGHT	14
X  
X  /*
X   * We put a TE on the message window for the "top line" queries.
X--- 40,57 ----
X  
X  NhWindow * theWindows = (NhWindow *) NULL ;
X  
X+ extern pascal short tty_environment_changed ( WindowPtr ) ;
X+ 
X  /*
X+  * Borrowed from the Mac tty port
X+  */
X+ extern WindowPtr _mt_window;
X+ 
X+ /*
X   * Some useful #defines for the scroll bar width and height
X   */
X  #define		SBARWIDTH	15
X! #define		SBARHEIGHT	13
X  
X  /*
X   * We put a TE on the message window for the "top line" queries.
X***************
X*** 75,80 ****
X--- 84,90 ----
X   * queue, shifting in a 0.
X   */
X  #define QUEUE_LEN 24
X+ const int keyQueueLen = QUEUE_LEN ;
X  static int keyQueue [ QUEUE_LEN ] ;
X  
X  Boolean gClickedToMove = 0 ; /* For ObscureCursor */
X***************
X*** 86,91 ****
X--- 96,104 ----
X  
X  static Boolean cursor_locked = false ;
X  
X+ extern void dprintf ( char * , ... ) ;
X+ 
X+ 
X  void
X  lock_mouse_cursor(Boolean new_cursor_locked)
X  {
X***************
X*** 96,105 ****
X  
X  
X  /*
X!  * Add key to input queue, force means replace last if full
X   */
X  void
X! addToKeyQueue ( int ch , Boolean force )
X  {
X  	int i ;
X  
X--- 109,118 ----
X  
X  
X  /*
X!  * Add key to input queue, force means flush left and replace if full
X   */
X  void
X! AddToKeyQueue ( int ch , Boolean force )
X  {
X  	int i ;
X  
X***************
X*** 112,118 ****
X  		}
X  	}
X  	if ( force ) {
X! 
X  		keyQueue [ QUEUE_LEN - 1 ] = ch ;
X  	}
X  }
X--- 125,133 ----
X  		}
X  	}
X  	if ( force ) {
X! 		for ( i = 0 ; i < QUEUE_LEN - 1 ; i ++ ) {
X! 			keyQueue [ i ] = keyQueue [ i + 1 ] ;
X! 		}
X  		keyQueue [ QUEUE_LEN - 1 ] = ch ;
X  	}
X  }
X***************
X*** 141,150 ****
X  static NhWindow * asyDSC = (NhWindow *) NULL ;
X  
X  /*
X!  * The font to be used in the text window, will be set to geneva after
X!  * we create the base window
X   */
X! short text_wind_font = monaco;
X  
X  /*
X   * Whether to adjust the height of a text window according to its contents
X--- 156,164 ----
X  static NhWindow * asyDSC = (NhWindow *) NULL ;
X  
X  /*
X!  * The font to be used in the text window
X   */
X! short text_wind_font = geneva;
X  
X  /*
X   * Whether to adjust the height of a text window according to its contents
X***************
X*** 165,171 ****
X  MenuHandle helpMenu ;
X  
X  #define NHW_BASE 0
X! winid BASE_WINDOW ; // Was: , WIN_MAP , WIN_MESSAGE , WIN_INVEN , WIN_STATUS ;
X  
X  void NDECL(port_help);
X  
X--- 179,185 ----
X  MenuHandle helpMenu ;
X  
X  #define NHW_BASE 0
X! extern winid BASE_WINDOW ; // Was: , WIN_MAP , WIN_MESSAGE , WIN_INVEN , WIN_STATUS ;
X  
X  void NDECL(port_help);
X  
X***************
X*** 178,183 ****
X--- 192,198 ----
X  void FDECL(HandleClick, ( EventRecord * theEvent ));
X  void FDECL(HandleUpdate, ( EventRecord * theEvent ));
X  void FDECL(HandleEvent, ( EventRecord * theEvent ));
X+ void FDECL(WindowGoAway, ( EventRecord *, WindowPtr));
X  void NDECL(DimMenuBar);
X  void NDECL(UndimMenuBar);
X  int FDECL(filter_scroll_key,(const int, NhWindow *));
X***************
X*** 198,226 ****
X  #define NUM_FUNCS 6
X  static void FDECL(macKeyNull, ( EventRecord * , WindowPtr )) ;
X  static void FDECL(macKeyMessage, ( EventRecord * , WindowPtr )) ;
X! static void FDECL(macKeyStatus, ( EventRecord * , WindowPtr )) ;
X! static void FDECL(macKeyMap, ( EventRecord * , WindowPtr )) ;
X  static void FDECL(macKeyMenu, ( EventRecord * , WindowPtr )) ;
X  static void FDECL(macKeyText, ( EventRecord * , WindowPtr )) ;
X  
X  static void FDECL(macClickNull, ( EventRecord * , WindowPtr )) ;
X  static void FDECL(macClickMessage, ( EventRecord * , WindowPtr )) ;
X! static void FDECL(macClickStatus, ( EventRecord * , WindowPtr )) ;
X! static void FDECL(macClickMap, ( EventRecord * , WindowPtr )) ;
X  static void FDECL(macClickMenu, ( EventRecord * , WindowPtr )) ;
X  static void FDECL(macClickText, ( EventRecord * , WindowPtr )) ;
X  
X  static void FDECL(macUpdateNull, ( EventRecord * , WindowPtr )) ;
X  static void FDECL(macUpdateMessage, ( EventRecord * , WindowPtr )) ;
X! static void FDECL(macUpdateStatus, ( EventRecord * , WindowPtr )) ;
X! static void FDECL(macUpdateMap, ( EventRecord * , WindowPtr )) ;
X  static void FDECL(macUpdateMenu, ( EventRecord * , WindowPtr )) ;
X  static void FDECL(macUpdateText, ( EventRecord * , WindowPtr )) ;
X  
X  static void FDECL(macCursorNull, ( EventRecord * , WindowPtr , RgnHandle )) ;
X  static void FDECL(macCursorMessage, ( EventRecord * , WindowPtr , RgnHandle )) ;
X! static void FDECL(macCursorStatus, ( EventRecord * , WindowPtr , RgnHandle )) ;
X! static void FDECL(macCursorMap, ( EventRecord * , WindowPtr , RgnHandle )) ;
X  static void FDECL(macCursorMenu, ( EventRecord * , WindowPtr , RgnHandle )) ;
X  static void FDECL(macCursorText, ( EventRecord * , WindowPtr , RgnHandle )) ;
X  
X--- 213,237 ----
X  #define NUM_FUNCS 6
X  static void FDECL(macKeyNull, ( EventRecord * , WindowPtr )) ;
X  static void FDECL(macKeyMessage, ( EventRecord * , WindowPtr )) ;
X! static void FDECL(macKeyTerm, ( EventRecord * , WindowPtr )) ;
X  static void FDECL(macKeyMenu, ( EventRecord * , WindowPtr )) ;
X  static void FDECL(macKeyText, ( EventRecord * , WindowPtr )) ;
X  
X  static void FDECL(macClickNull, ( EventRecord * , WindowPtr )) ;
X  static void FDECL(macClickMessage, ( EventRecord * , WindowPtr )) ;
X! static void FDECL(macClickTerm, ( EventRecord * , WindowPtr )) ;
X  static void FDECL(macClickMenu, ( EventRecord * , WindowPtr )) ;
X  static void FDECL(macClickText, ( EventRecord * , WindowPtr )) ;
X  
X  static void FDECL(macUpdateNull, ( EventRecord * , WindowPtr )) ;
X  static void FDECL(macUpdateMessage, ( EventRecord * , WindowPtr )) ;
X! static void FDECL(macUpdateTerm, ( EventRecord * , WindowPtr )) ;
X  static void FDECL(macUpdateMenu, ( EventRecord * , WindowPtr )) ;
X  static void FDECL(macUpdateText, ( EventRecord * , WindowPtr )) ;
X  
X  static void FDECL(macCursorNull, ( EventRecord * , WindowPtr , RgnHandle )) ;
X  static void FDECL(macCursorMessage, ( EventRecord * , WindowPtr , RgnHandle )) ;
X! static void FDECL(macCursorTerm, ( EventRecord * , WindowPtr , RgnHandle )) ;
X  static void FDECL(macCursorMenu, ( EventRecord * , WindowPtr , RgnHandle )) ;
X  static void FDECL(macCursorText, ( EventRecord * , WindowPtr , RgnHandle )) ;
X  
X***************
X*** 229,235 ****
X  
X  static void FDECL (DrawScrollbar, ( NhWindow * , WindowPtr ));
X  static void FDECL (InvalScrollBar, ( NhWindow * ));
X- static void FDECL(DrawMapCursor,(NhWindow *));
X  static void FDECL(DoScrollBar,(Point, short, ControlHandle, NhWindow *, WindowPtr));
X  static pascal void FDECL(Up, (ControlHandle, short));
X  static pascal void FDECL(Down,(ControlHandle, short));
X--- 240,245 ----
X***************
X*** 238,261 ****
X  typedef void ( * CbCursFunc ) ( EventRecord * , WindowPtr , RgnHandle ) ;
X  
X  CbFunc winKeyFuncs [ NUM_FUNCS ] = {
X! 	macKeyNull , macKeyMessage , macKeyStatus , macKeyMap , macKeyMenu , macKeyText
X  } ;
X  
X  CbFunc winClickFuncs [ NUM_FUNCS ] = {
X! 	macClickNull , macClickMessage , macClickStatus , macClickMap , macClickMenu ,
X  	macClickText
X  } ;
X  
X  CbFunc winUpdateFuncs [ NUM_FUNCS ] = {
X! 	macUpdateNull , macUpdateMessage , macUpdateStatus , macUpdateMap ,
X  	macUpdateMenu , macUpdateText
X  } ;
X  
X  CbCursFunc winCursorFuncs [ NUM_FUNCS ] = {
X! 	macCursorNull , macCursorMessage , macCursorStatus , macCursorMap ,
X  	macCursorMenu , macCursorText
X  } ;
X  
X  #ifdef applec
X    extern void _DataInit();
X    /* This routine is part of the MPW runtime library. This external
X--- 248,282 ----
X  typedef void ( * CbCursFunc ) ( EventRecord * , WindowPtr , RgnHandle ) ;
X  
X  CbFunc winKeyFuncs [ NUM_FUNCS ] = {
X! 	macKeyNull , macKeyMessage , macKeyTerm , macKeyTerm , macKeyMenu , macKeyText
X  } ;
X  
X  CbFunc winClickFuncs [ NUM_FUNCS ] = {
X! 	macClickNull , macClickMessage , macClickTerm , macClickTerm , macClickMenu ,
X  	macClickText
X  } ;
X  
X  CbFunc winUpdateFuncs [ NUM_FUNCS ] = {
X! 	macUpdateNull , macUpdateMessage , macUpdateTerm , macUpdateTerm ,
X  	macUpdateMenu , macUpdateText
X  } ;
X  
X  CbCursFunc winCursorFuncs [ NUM_FUNCS ] = {
X! 	macCursorNull , macCursorMessage , macCursorTerm , macCursorTerm ,
X  	macCursorMenu , macCursorText
X  } ;
X  
X+ NhWindow *
X+ GetNhWin(WindowPtr mac_win)
X+ {
X+ 	int ix;
X+ 	for (ix = 0; ix < NUM_MACWINDOWS; ++ix)
X+ 		if (mac_win == theWindows[ix].theWindow)
X+ 			return theWindows + ix;
X+ 	return nil;
X+ }
X+ 
X+ 
X  #ifdef applec
X    extern void _DataInit();
X    /* This routine is part of the MPW runtime library. This external
X***************
X*** 274,285 ****
X  	UnloadSeg((Ptr) _DataInit);
X  #endif
X  
X! 	SetApplLimit ( 
X  					( void * ) 
X  					( 
X! 					( ( long ) GetApplLimit() ) - 40 * 1024L 
X  					) 
X  				 ) ;
X  	MaxApplZone ( ) ;
X  	for ( i = 0 ; i < 5 ; i ++ )
X  		MoreMasters ( ) ;
X--- 295,308 ----
X  	UnloadSeg((Ptr) _DataInit);
X  #endif
X  
X! 	if ( * ( long * ) DefltStack < 50 * 1024L ) {
X! 		SetApplLimit ( 
X  					( void * ) 
X  					( 
X! 					( * ( long * ) CurStackBase ) - 50 * 1024L 
X  					) 
X  				 ) ;
X+ 	}
X  	MaxApplZone ( ) ;
X  	for ( i = 0 ; i < 5 ; i ++ )
X  		MoreMasters ( ) ;
X***************
X*** 343,348 ****
X--- 366,373 ----
X  	}
X  
X  	gMouseRgn = NewRgn ( ) ;
X+ 	InitCursor ( ) ;
X+ 	ObscureCursor ( ) ;
X  }
X  
X  
X***************
X*** 357,364 ****
X  int
X  SanePositions ( void )
X  {
X! 	short mainTop , mainLeft , mainWidth , mainHeight ;
X! 	short statTop , statLeft , statWidth , statHeight ;
X  	short mesgTop , mesgLeft , mesgWidth , mesgHeight ;
X  	short left , top , width , height ;
X  	short ix , numText = 0 , numMenu = 0 ;
X--- 382,388 ----
X  int
X  SanePositions ( void )
X  {
X! 	short mainTop , mainLeft ;
X  	short mesgTop , mesgLeft , mesgWidth , mesgHeight ;
X  	short left , top , width , height ;
X  	short ix , numText = 0 , numMenu = 0 ;
X***************
X*** 383,420 ****
X  
X  	mainTop = top ;
X  	mainLeft = left ;
X- 	mainHeight = height ;
X- 	mainWidth = width ;
X  
X- /* Status Window */
X- 	nhWin = theWindows + WIN_STATUS ;
X- 	theWindow = nhWin -> theWindow ;
X- 
X- 	height = nhWin -> charHeight * NUM_STAT_ROWS ;
X- 
X- 	if ( ! RetrievePosition ( kStatusWindow , & top , & left ) ) {
X- 		top = mainTop + mainHeight + 2 ;
X- 		left = mainLeft ;
X- 	}
X- 
X- 	if ( top + height > screenArea . bottom ) {
X- 		top = screenArea . bottom - height ;
X- 		left += 20 ; /* Edge to the right so we can read it */
X- 	}
X- 	statTop = top ;
X- 	statLeft = left ;
X- 	statHeight = height ;
X- 	statWidth = width ;
X- 
X  /* Message Window */
X  	nhWin = theWindows + WIN_MESSAGE ;
X  	theWindow = nhWin -> theWindow ;
X  
X  	if ( ! RetrievePosition ( kMessageWindow , & top , & left ) ) {
X! 		top = statTop + statHeight ;
X  		if ( ! small_screen )
X  			top += 20 ;
X! 		left = statLeft ;
X  	}
X  
X  	if ( ! RetrieveSize ( kMessageWindow , top , left , & height , & width ) ) {
X--- 407,422 ----
X  
X  	mainTop = top ;
X  	mainLeft = left ;
X  
X  /* Message Window */
X  	nhWin = theWindows + WIN_MESSAGE ;
X  	theWindow = nhWin -> theWindow ;
X  
X  	if ( ! RetrievePosition ( kMessageWindow , & top , & left ) ) {
X! 		top = mainTop + _mt_window->portRect.bottom - _mt_window->portRect.top;
X  		if ( ! small_screen )
X  			top += 20 ;
X! 		left = mainLeft ;
X  	}
X  
X  	if ( ! RetrieveSize ( kMessageWindow , top , left , & height , & width ) ) {
X***************
X*** 436,449 ****
X  /* Move these windows */
X  	MoveWindow ( theWindows [ WIN_MESSAGE ] . theWindow , mesgLeft , mesgTop , 1 ) ;
X  	SizeWindow ( theWindows [ WIN_MESSAGE ] . theWindow , mesgWidth , mesgHeight , 1 ) ;
X! 	MoveWindow ( theWindows [ WIN_STATUS ] . theWindow , statLeft , statTop , 1 ) ;
X! 	SizeWindow ( theWindows [ WIN_STATUS ] . theWindow , statWidth , statHeight , 1 ) ;
X! 	MoveWindow ( theWindows [ WIN_MAP ] . theWindow , mainLeft , mainTop , 1 ) ;
X! 	SizeWindow ( theWindows [ WIN_MAP ] . theWindow , mainWidth , mainHeight , 1 ) ;
X  
X  /* Handle other windows */
X  	for ( ix = 0 ; ix < NUM_MACWINDOWS ; ix ++ ) {
X! 		if ( ix != WIN_STATUS && ix != WIN_MESSAGE && ix != WIN_MAP ) {
X  			if ( theWindow = theWindows [ ix ] . theWindow ) {
X  				if ( ( ( WindowPeek ) theWindow ) -> visible ) {
X  					if ( theWindows [ ix ] . kind == NHW_MENU ) {
X--- 438,448 ----
X  /* Move these windows */
X  	MoveWindow ( theWindows [ WIN_MESSAGE ] . theWindow , mesgLeft , mesgTop , 1 ) ;
X  	SizeWindow ( theWindows [ WIN_MESSAGE ] . theWindow , mesgWidth , mesgHeight , 1 ) ;
X! 	MoveWindow ( _mt_window , mainLeft , mainTop , 1 ) ;
X  
X  /* Handle other windows */
X  	for ( ix = 0 ; ix < NUM_MACWINDOWS ; ix ++ ) {
X! 		if ( ix != WIN_STATUS && ix != WIN_MESSAGE && ix != WIN_MAP && ix != BASE_WINDOW ) {
X  			if ( theWindow = theWindows [ ix ] . theWindow ) {
X  				if ( ( ( WindowPeek ) theWindow ) -> visible ) {
X  					if ( theWindows [ ix ] . kind == NHW_MENU ) {
X***************
X*** 502,509 ****
X  	if ( i >= NUM_MACWINDOWS ) {
X  		for ( i = 0 ; i < NUM_MACWINDOWS ; i ++ ) {
X  			WindowPeek w = ( WindowPeek ) theWindows [ i ] . theWindow ;
X! 			if ( w -> visible || i == WIN_INVEN || ( w -> windowKind
X! 				!= NHW_MENU && w -> windowKind != NHW_TEXT ) )
X  				continue ;
X  			error ( "The window list is getting full, freeing unnecessary window (%d)..." ,
X  				i ) ;
X--- 501,509 ----
X  	if ( i >= NUM_MACWINDOWS ) {
X  		for ( i = 0 ; i < NUM_MACWINDOWS ; i ++ ) {
X  			WindowPeek w = ( WindowPeek ) theWindows [ i ] . theWindow ;
X! 			if ( w -> visible || i == WIN_INVEN ||
X! 				 w -> windowKind != WIN_BASE_KIND + NHW_MENU &&
X! 				 w -> windowKind != WIN_BASE_KIND + NHW_TEXT )
X  				continue ;
X  			error ( "The window list is getting full, freeing unnecessary window (%d)..." ,
X  				i ) ;
X***************
X*** 517,563 ****
X  
X  got1 :
X  	aWin = & theWindows [ i ] ;
X! 	aWin -> theWindow = GetNewWindow ( WIN_BASE_RES + type ,
X! 		( WindowPtr ) 0L , ( WindowPtr ) -1L ) ;
X! 	( ( WindowPeek ) aWin -> theWindow ) -> windowKind = WIN_BASE_KIND
X! 		+ type ;
X  	aWin -> windowTextLen = 0L ;
X  	aWin -> clear = 0 ; /* Yes, we need to inval the area on a clear */
X  	aWin -> scrollBar = (ControlHandle) NULL ;
X! 	switch ( type ) {
X! 	case NHW_MAP :
X! 		if ( ! ( aWin -> windowText = NewHandle
X! 			( sizeof ( MapData ) ) ) ) {
X! 			error ( "NewHandle failed in create_nhwindow (%ld bytes)" ,
X! 				( long ) sizeof ( MapData ) ) ;
X! 			DisposeWindow ( aWin -> theWindow ) ;
X! 			aWin -> theWindow = (WindowPtr) NULL ;
X! 			return WIN_ERR ;
X  		}
X! 		break ;
X! 	case NHW_STATUS :
X! 		if ( ! ( aWin -> windowText = NewHandle
X! 			( sizeof ( StatusData ) ) ) ) {
X! 			error ( "NewHandle failed in create_nhwindow (%ld bytes)" ,
X! 				( long ) sizeof ( StatusData ) ) ;
X! 			DisposeWindow ( aWin -> theWindow ) ;
X! 			aWin -> theWindow = (WindowPtr) NULL ;
X! 			return WIN_ERR ;
X! 		}
X! 		break ;
X! 	default :
X! 		if ( ! ( aWin -> windowText = NewHandle ( TEXT_BLOCK ) ) ) {
X! 			error ( "NewHandle failed in create_nhwindow (%ld bytes)" ,
X! 				( long ) TEXT_BLOCK ) ;
X! 			DisposeWindow ( aWin -> theWindow ) ;
X! 			aWin -> theWindow = (WindowPtr) NULL ;
X! 			return WIN_ERR ;
X! 		}
X! 		aWin -> windowTextLen = 0L ;
X! 		aWin -> lin = 0 ;
X! 		break ;
X  	}
X  
X  	clear_nhwindow ( i ) ;
X  
X  /*HARDCODED*/
X--- 517,570 ----
X  
X  got1 :
X  	aWin = & theWindows [ i ] ;
X! 
X  	aWin -> windowTextLen = 0L ;
X  	aWin -> clear = 0 ; /* Yes, we need to inval the area on a clear */
X  	aWin -> scrollBar = (ControlHandle) NULL ;
X! 
X! 	dprintf ( "Created window type %d" , type ) ;
X! 	aWin -> kind = type ;
X! 	aWin -> keyFunc = winKeyFuncs [ type ] ;
X! 	aWin -> clickFunc = winClickFuncs [ type ] ;
X! 	aWin -> updateFunc = winUpdateFuncs [ type ] ;
X! 	aWin -> cursorFunc = winCursorFuncs [ type ] ;
X! 
X! 	if (type == NHW_BASE || type == NHW_MAP || type == NHW_STATUS) {
X! 		short x_sz, x_sz_p, y_sz_p;
X! 		dprintf ( "This is in the TTY window" ) ;
X! 		if (type == NHW_BASE) {
X! 			aWin -> keyFunc = winKeyFuncs [ NHW_MAP ] ;
X! 			aWin -> clickFunc = winClickFuncs [ NHW_MAP ] ;
X! 			aWin -> updateFunc = winUpdateFuncs [ NHW_MAP ] ;
X! 			aWin -> cursorFunc = winCursorFuncs [ NHW_MAP ] ;
X! 		} else {
X! 			if (i != tty_create_nhwindow(type)) {
X! 				dprintf ( "Cannot create window type %d" , type ) ;
X! 			}
X! 			if (type == NHW_MAP) {
X! 				wins[i]->offy = 0;	/* the message box is in a separate window */
X! 			}
X  		}
X! 		aWin->theWindow = _mt_window;
X! 		((WindowPeek)aWin->theWindow)->windowKind = WIN_BASE_KIND + NHW_MAP;
X! 		get_tty_metrics(aWin->theWindow, &x_sz, &aWin->lin, &x_sz_p, &y_sz_p,
X! 										 &aWin->fontNum, &aWin->fontSize,
X! 										 &aWin->charWidth, &aWin->charHeight);
X! 		return i;
X  	}
X  
X+ 	aWin -> theWindow = GetNewWindow ( WIN_BASE_RES + type ,
X+ 		( WindowPtr ) 0L , ( WindowPtr ) -1L ) ;
X+ 	( ( WindowPeek ) aWin -> theWindow ) -> windowKind = WIN_BASE_KIND
X+ 		+ type ;
X+ 	if ( ! ( aWin -> windowText = NewHandle ( TEXT_BLOCK ) ) ) {
X+ 		error ( "NewHandle failed in create_nhwindow (%ld bytes)" ,
X+ 			( long ) TEXT_BLOCK ) ;
X+ 		DisposeWindow ( aWin -> theWindow ) ;
X+ 		aWin -> theWindow = (WindowPtr) NULL ;
X+ 		return WIN_ERR ;
X+ 	}
X+ 	aWin -> lin = 0 ;
X  	clear_nhwindow ( i ) ;
X  
X  /*HARDCODED*/
X***************
X*** 566,576 ****
X  	PenPat ( &qd . black ) ;
X  
X  	switch ( type ) {
X- 		case NHW_MAP :
X- 		case NHW_STATUS :
X- 			GetFNum ( "\pHackFont", & aWin -> fontNum ) ;
X- 			aWin -> fontSize = flags.large_font ? 12 : 9 ;
X- 			break ;
X  		case NHW_MESSAGE :
X  			GetFNum ( "\pPSHackFont", & aWin -> fontNum ) ;
X  			aWin -> fontSize = flags.large_font ? 12 : 9 ;
X--- 573,578 ----
X***************
X*** 600,626 ****
X  	}
X  	SetPt ( & ( theWindows [ i ] . cursor ) , 0 , 0 ) ;
X  
X! 	aWin -> kind = type ;
X! 	aWin -> keyFunc = winKeyFuncs [ type ] ;
X! 	aWin -> clickFunc = winClickFuncs [ type ] ;
X! 	aWin -> updateFunc = winUpdateFuncs [ type ] ;
X! 	aWin -> cursorFunc = winCursorFuncs [ type ] ;
X! 	SetWRefCon ( aWin -> theWindow , ( long ) aWin ) ;
X! 
X! 	SetRect ( & siz , 0 , 0 , aWin -> charWidth * NUM_COLS ,
X! 		aWin -> charHeight * NUM_ROWS ) ;
X! 	switch ( type ) {
X! 	case NHW_MAP :
X! 		OffsetRect ( & siz , 50 , 50 ) ;
X! 		break ;
X! 	case NHW_BASE :
X! 		OffsetRect ( & siz , 20 , 10 ) ;
X! 		break ;
X! 	default :
X! 		siz = aWin -> theWindow -> portRect ;
X! 		OffsetRect ( & siz , 30 + rn2 ( 20 ) , 250 + rn2 ( 50 ) ) ;
X! 		break ;
X! 	}
X  	SizeWindow ( aWin -> theWindow , siz . right - siz . left ,
X  		siz . bottom - siz . top , FALSE ) ;
X  	MoveWindow ( aWin -> theWindow , siz . left , siz . top , FALSE ) ;
X--- 602,609 ----
X  	}
X  	SetPt ( & ( theWindows [ i ] . cursor ) , 0 , 0 ) ;
X  
X! 	siz = aWin -> theWindow -> portRect ;
X! 	OffsetRect ( & siz , 30 + rn2 ( 20 ) , 250 + rn2 ( 50 ) ) ;
X  	SizeWindow ( aWin -> theWindow , siz . right - siz . left ,
X  		siz . bottom - siz . top , FALSE ) ;
X  	MoveWindow ( aWin -> theWindow , siz . left , siz . top , FALSE ) ;
X***************
X*** 634,644 ****
X  		r . top -= 1 ;
X  		r . right += 1 ;
X  		bool = ( r . bottom > r . top + 50 ) ;
X! 		aWin -> scrollBar = NewControl ( aWin -> theWindow , & r , (StringPtr)"" ,
X  			bool , 0 , 0 , 0 , 16 , 0L ) ;
X  	}
X  	aWin -> scrollPos = 0 ;
X- 	aWin -> cursorDrawn = 0 ;
X  
X  	return i ;
X  }
X--- 617,626 ----
X  		r . top -= 1 ;
X  		r . right += 1 ;
X  		bool = ( r . bottom > r . top + 50 ) ;
X! 		aWin -> scrollBar = NewControl ( aWin -> theWindow , & r , "\P" ,
X  			bool , 0 , 0 , 0 , 16 , 0L ) ;
X  	}
X  	aWin -> scrollPos = 0 ;
X  
X  	return i ;
X  }
X***************
X*** 655,665 ****
X  	return menu;
X  }
X  
X  void
X  InitRes ( void )
X  {
X! 	Str255 str ;
X  
X  	mBar = GetNewMBar ( 128 ) ;
X  	mustwork(ResError());
X  	SetMenuBar ( mBar ) ;
X--- 637,725 ----
X  	return menu;
X  }
X  
X+ 
X+ #define A_LOT 0x7fffffff
X+ #define HEAP_SPACE 100000
X+ #define RES_FACTOR 1.1
X+ 
X+ static long
X+ SpaceToLoad ( char * name ) {
X+ FCBPBRec fcb ;
X+ long ret ;
X+ 
X+ 	memset ( & fcb , 0 , sizeof ( fcb ) ) ;
X+ 
X+ 	fcb . ioRefNum = CurResFile ( ) ;
X+ 	fcb . ioNamePtr = name ;
X+ 	if ( PBGetFCBInfoSync ( & fcb ) ) {
X+ 		return A_LOT ;
X+ 	}
X+ 	ret = fcb . ioFCBEOF * RES_FACTOR + HEAP_SPACE ;
X+ 	dprintf ( "Space needed %ld" , ret ) ;
X+ 	return ret ;
X+ }
X+ 
X+ 
X  void
X  InitRes ( void )
X  {
X! #if 1	/* see macmenu.c:InitMenuRes */
X! # if 0
X! extern void InitMenuRes(void);
X! int resIDIndex ;
X! int resTypeIndex ;
X! ResType resType , infoType ;
X! Str255 name ;
X! short id ;
X! long spaceFree , totalContig ;
X! Handle theResource ;
X! static Boolean stuffLoaded = 0 ;
X! # endif
X  
X+ 	InitMenuRes();
X+ 
X+ # if 0
X+ /*
X+  * For better performance (and powerbooks) we may want to load in the
X+  * entire game to avoid spinning the disk up.
X+  * This doesn't seem to be efficient, though. Better to just use whatever
X+  * memory is assigned for default resource caching.
X+  */
X+ 	if ( ! stuffLoaded ) {
X+ 		PurgeSpace ( & spaceFree , & totalContig ) ;
X+ 		if ( spaceFree > SpaceToLoad ( name ) ) {
X+ 			dprintf ( "Space now: %ld" , spaceFree ) ;
X+ 			SetResLoad ( 0 ) ;
X+ 			for ( resTypeIndex = Count1Types ( ) ; resTypeIndex > 0 ; resTypeIndex -- ) {
X+ 				Get1IndType ( & resType , resTypeIndex ) ;
X+ 				for ( resIDIndex = Count1Resources ( resType ) ; resIDIndex > 0 ; resIDIndex -- ) {
X+ 					theResource = Get1IndResource ( resType , resIDIndex ) ;
X+ 					if ( ! * theResource ) {
X+ 						GetResInfo ( theResource , & id , & infoType , name ) ;
X+ #  ifdef applec
X+ 						if ( infoType != 'CODE'  || ! EqualString ( name , "\P%A5Init" , 0 , 0 ) ) {
X+ #  else
X+ 						if ( infotype != 'ZREF' && infoType != 'DATA' ) {
X+ #  endif
X+ 							LoadResource ( theResource ) ;
X+ 							HUnlock ( theResource ) ;
X+ 							MoveHHi ( theResource ) ;
X+ 							HLock ( theResource ) ;
X+ 						}
X+ 					}
X+ 				}
X+ 			}
X+ 			SetResLoad ( 1 ) ;
X+ 			stuffLoaded = 1 ;
X+ 		} else {
X+ 			dprintf ( "Space now: %ld" , spaceFree ) ;
X+ 		}
X+ 	}
X+ # endif
X+ 
X+ #else
X+ Str255 str ;
X+ 
X  	mBar = GetNewMBar ( 128 ) ;
X  	mustwork(ResError());
X  	SetMenuBar ( mBar ) ;
X***************
X*** 689,694 ****
X--- 749,755 ----
X  	DrawMenuBar ( ) ;
X  
X  	return ;
X+ #endif	/* see macmenu.c:InitMenuRes */
X  }
X  
X  
X***************
X*** 714,733 ****
X  		keyQueue [ i ] = 0 ;
X  	}
X  
X- 	BASE_WINDOW = create_nhwindow ( NHW_TEXT ) ;
X-     clear_nhwindow(BASE_WINDOW);
X-     putstr(BASE_WINDOW, 0, "");
X-     putstr(BASE_WINDOW, 0,
X- 	  "NetHack, Copyright 1985, 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993");
X-     putstr(BASE_WINDOW, 0,
X- 	  "         By Stichting Mathematisch Centrum and M. Stephenson.");
X-     putstr(BASE_WINDOW, 0, "         See license for details.");
X-     putstr(BASE_WINDOW, 0, "");
X-     display_nhwindow(BASE_WINDOW, FALSE);
X- 
X- 	flags . window_inited = 1 ;
X  	DimMenuBar ( ) ;
X! 	normal_font ( ) ;
X  }
X  
X  
X--- 775,788 ----
X  		keyQueue [ i ] = 0 ;
X  	}
X  
X  	DimMenuBar ( ) ;
X! 
X! 	tty_init_nhwindows();
X! 	flags.window_inited = TRUE;
X! 
X! 	/* Some ugly hacks to make both interfaces happy */
X! 	mac_create_nhwindow(NHW_BASE);
X! 	tty_create_nhwindow(NHW_MESSAGE);
X  }
X  
X  
X***************
X*** 752,761 ****
X  static void
X  DrawScrollbar ( NhWindow * aWin , WindowPtr theWindow )
X  {
X! 	Rect r2 = theWindow -> portRect ;
X! 	Rect r = r2 ;
X! 	Boolean vis ;
X! 	short val , lin ;
X  
X  	if ( ! aWin -> scrollBar ) {
X  		return ;
X--- 807,816 ----
X  static void
X  DrawScrollbar ( NhWindow * aWin , WindowPtr theWindow )
X  {
X! Rect r2 = theWindow -> portRect ;
X! Rect r = r2 ;
X! Boolean vis ;
X! short val , lin ;
X  
X  	if ( ! aWin -> scrollBar ) {
X  		return ;
X***************
X*** 766,777 ****
X  	r2 . right += 1 ;
X  	r2 . top -= 1 ;
X  	if ( ( * aWin -> scrollBar ) -> contrlRect . top  != r2 . top ||
X! 		 ( * aWin -> scrollBar ) -> contrlRect . left != r2 . left )
X  		MoveControl ( aWin -> scrollBar , r2 . left , r2 . top ) ;
X  	if ( ( * aWin -> scrollBar ) -> contrlRect . bottom != r2 . bottom ||
X! 		 ( * aWin -> scrollBar ) -> contrlRect . right  != r2 . right )
X  		SizeControl ( aWin -> scrollBar , r2 . right  - r2 . left ,
X  										  r2 . bottom - r2 . top ) ;
X  	vis = ( r2 . bottom > r2 . top + 50 ) ;
X  	if ( vis && ! ( * aWin -> scrollBar ) -> contrlVis ) {
X  		ShowControl ( aWin -> scrollBar ) ;
X--- 821,834 ----
X  	r2 . right += 1 ;
X  	r2 . top -= 1 ;
X  	if ( ( * aWin -> scrollBar ) -> contrlRect . top  != r2 . top ||
X! 		 ( * aWin -> scrollBar ) -> contrlRect . left != r2 . left ) {
X  		MoveControl ( aWin -> scrollBar , r2 . left , r2 . top ) ;
X+ 	}
X  	if ( ( * aWin -> scrollBar ) -> contrlRect . bottom != r2 . bottom ||
X! 		 ( * aWin -> scrollBar ) -> contrlRect . right  != r2 . right ) {
X  		SizeControl ( aWin -> scrollBar , r2 . right  - r2 . left ,
X  										  r2 . bottom - r2 . top ) ;
X+ 	}
X  	vis = ( r2 . bottom > r2 . top + 50 ) ;
X  	if ( vis && ! ( * aWin -> scrollBar ) -> contrlVis ) {
X  		ShowControl ( aWin -> scrollBar ) ;
X***************
X*** 784,798 ****
X  		r . bottom -= SBARHEIGHT + 1 ;
X  		min = aWin -> save_lin + ( r . bottom - r . top ) / aWin ->
X  			charHeight ;
X! 		if ( lin < min )
X  			lin = min ;
X  	}
X  	if ( lin ) {
X  		short max = lin - ( r . bottom - r . top ) / aWin -> charHeight ;
X! 		if ( max < 0 ) max = 0 ;
X  		SetCtlMax ( aWin -> scrollBar , max ) ;
X! 		if ( max ) HiliteControl ( aWin -> scrollBar , 0 ) ;
X! 		else HiliteControl ( aWin -> scrollBar , 255 ) ;
X  	} else {
X  		HiliteControl ( aWin -> scrollBar , 255 ) ;
X  	}
X--- 841,861 ----
X  		r . bottom -= SBARHEIGHT + 1 ;
X  		min = aWin -> save_lin + ( r . bottom - r . top ) / aWin ->
X  			charHeight ;
X! 		if ( lin < min ) {
X  			lin = min ;
X+ 		}
X  	}
X  	if ( lin ) {
X  		short max = lin - ( r . bottom - r . top ) / aWin -> charHeight ;
X! 		if ( max < 0 ) {
X! 			max = 0 ;
X! 		}
X  		SetCtlMax ( aWin -> scrollBar , max ) ;
X! 		if ( max ) {
X! 			HiliteControl ( aWin -> scrollBar , 0 ) ;
X! 		} else {
X! 			HiliteControl ( aWin -> scrollBar , 255 ) ;
X! 		}
X  	} else {
X  		HiliteControl ( aWin -> scrollBar , 255 ) ;
X  	}
X***************
X*** 823,829 ****
X  {
X  	long l ;
X  	Rect r ;
X- 	register char * start , * stop ;
X  	WindowPtr theWindow ;
X  	NhWindow * aWin = & theWindows [ win ] ;
X  
X--- 886,891 ----
X***************
X*** 831,839 ****
X  		error ( "Invalid window %d in clear_nhwindow." , win ) ;
X  		return ;
X  	}
X  	if ( aWin -> clear )
X  		return ;
X- 	theWindow = aWin -> theWindow ;
X  	if ( ! theWindow ) {
X  		error ( "Unallocated window %d in clear_nhwindow." , win ) ;
X  		return ;
X--- 893,907 ----
X  		error ( "Invalid window %d in clear_nhwindow." , win ) ;
X  		return ;
X  	}
X+ 
X+ 	theWindow = aWin -> theWindow ;
X+ 	if (theWindow == _mt_window) {
X+ 		tty_clear_nhwindow(win);
X+ 		return;
X+ 	}
X+ 
X  	if ( aWin -> clear )
X  		return ;
X  	if ( ! theWindow ) {
X  		error ( "Unallocated window %d in clear_nhwindow." , win ) ;
X  		return ;
X***************
X*** 846,863 ****
X  		r . bottom -= SBARHEIGHT + 1 ;
X  	InvalRect ( & r ) ;
X  	switch ( ( ( WindowPeek ) theWindow ) -> windowKind - WIN_BASE_KIND ) {
X- 	case NHW_MAP :
X- 		stop = ( char * ) ( ( MapData * ) ( * aWin -> windowText ) )
X- 			-> map ;
X- 		start = stop + NUM_COLS * NUM_ROWS ;
X- 		while ( start > stop ) * -- start = CHAR_BLANK ;
X- 		break ;
X- 	case NHW_STATUS :
X- 		stop = ( char * ) ( ( StatusData * ) ( * aWin -> windowText ) )
X- 			-> map ;
X- 		start = stop + NUM_COLS * NUM_STAT_ROWS ;
X- 		while ( start > stop ) * -- start = CHAR_BLANK ;
X- 		break ;
X  	case NHW_MESSAGE :
X  		l = 0;
X  		while (aWin->lin > flags.msg_history) {
X--- 914,919 ----
X***************
X*** 892,898 ****
X  	}
X  	SetPt ( & ( aWin -> cursor ) , 0 , 0 ) ;
X  	aWin -> clear = 1 ;
X- 	aWin -> cursorDrawn = 0 ;
X  }
X  
X  
X--- 948,953 ----
X***************
X*** 1222,1235 ****
X  		return ;
X  	}
X  
X! 	if ( f && inSelect == WIN_ERR && ( win == BASE_WINDOW || win == WIN_MESSAGE ) ) {
X! 		if ( win == WIN_MESSAGE ) {
X! 			topl_set_resp ( NULL , 0 ) ;
X! 			if ( aWin -> windowTextLen > 0 &&
X! 				 ( * aWin -> windowText ) [ aWin -> windowTextLen - 1 ] == CHAR_CR ) {
X! 				-- aWin -> windowTextLen ;
X! 				-- aWin -> lin ;
X! 			}
X  		}
X  		putstr ( win , flags . standout ? ATR_INVERSE : ATR_NONE , " --More--" ) ;
X  	}
X--- 1277,1293 ----
X  		return ;
X  	}
X  
X! 	if (theWindow == _mt_window) {
X! 		tty_display_nhwindow(win, f);
X! 		return;
X! 	}
X! 
X! 	if ( f && inSelect == WIN_ERR && win == WIN_MESSAGE ) {
X! 		topl_set_resp ( NULL , 0 ) ;
X! 		if ( aWin -> windowTextLen > 0 &&
X! 			 ( * aWin -> windowText ) [ aWin -> windowTextLen - 1 ] == CHAR_CR ) {
X! 			-- aWin -> windowTextLen ;
X! 			-- aWin -> lin ;
X  		}
X  		putstr ( win , flags . standout ? ATR_INVERSE : ATR_NONE , " --More--" ) ;
X  	}
X***************
X*** 1236,1243 ****
X  
X  	if ( ! ( ( WindowPeek ) theWindow ) -> visible || full_screen ) {
X  
X! 		int kind = ((WindowPeek)theWindow)->windowKind - WIN_BASE_KIND;
X! 		if (kind == NHW_TEXT || kind == NHW_MENU) {
X  			const char cr = CHAR_CR;
X  			short w = 0;
X  			long line_start = 0;
X--- 1294,1300 ----
X  
X  	if ( ! ( ( WindowPeek ) theWindow ) -> visible || full_screen ) {
X  
X! 		if ( win != WIN_MESSAGE ) {
X  			const char cr = CHAR_CR;
X  			short w = 0;
X  			long line_start = 0;
X***************
X*** 1280,1286 ****
X  
X  		if ( win == WIN_MESSAGE )
X  			topl_set_resp ( "" , '\0' ) ;
X! 		else if ( win != WIN_MAP && win != WIN_STATUS )
X  			HideWindow ( theWindow ) ;
X  
X  	} else {
X--- 1337,1343 ----
X  
X  		if ( win == WIN_MESSAGE )
X  			topl_set_resp ( "" , '\0' ) ;
X! 		else
X  			HideWindow ( theWindow ) ;
X  
X  	} else {
X***************
X*** 1308,1313 ****
X--- 1365,1376 ----
X  			win ) ;
X  		return ;
X  	}
X+ /*
X+  *	if (theWindow == _mt_window) {
X+  *		tty_destroy_nhwindow(win);
X+  *		return;
X+  *	}
X+  */
X  
X  	/*
X  	 * Check special windows.
X***************
X*** 1318,1325 ****
X  	if ( win == BASE_WINDOW ) {
X  		return ;
X  	}
X! 	if ( win == WIN_INVEN || win == WIN_STATUS || win == WIN_MAP ||
X! 		win == WIN_MESSAGE ) {
X  		if ( flags . window_inited ) {
X  			if ( flags . tombstone && killer ) {
X  				/* Prepare for the coming of the tombstone window. */
X--- 1381,1387 ----
X  	if ( win == BASE_WINDOW ) {
X  		return ;
X  	}
X! 	if ( win == WIN_INVEN || win == WIN_MESSAGE ) {
X  		if ( flags . window_inited ) {
X  			if ( flags . tombstone && killer ) {
X  				/* Prepare for the coming of the tombstone window. */
X***************
X*** 1333,1339 ****
X  	kind = ( ( WindowPeek ) theWindow ) -> windowKind - WIN_BASE_KIND ;
X  	visible = ( ( WindowPeek ) theWindow ) -> visible ;
X  
X! 	if ( ! visible || ( kind != NHW_MENU && kind != NHW_TEXT ) ) {
X  		DisposeWindow ( theWindow ) ;
X  		if ( aWin -> windowText ) {
X  			DisposHandle ( aWin -> windowText ) ;
X--- 1395,1402 ----
X  	kind = ( ( WindowPeek ) theWindow ) -> windowKind - WIN_BASE_KIND ;
X  	visible = ( ( WindowPeek ) theWindow ) -> visible ;
X  
X! 	if ( ( ! visible || ( kind != NHW_MENU && kind != NHW_TEXT ) ) &&
X! 		theWindow != _mt_window ) {
X  		DisposeWindow ( theWindow ) ;
X  		if ( aWin -> windowText ) {
X  			DisposHandle ( aWin -> windowText ) ;
X***************
X*** 1378,1385 ****
X  void
X  GeneralKey ( EventRecord * theEvent , WindowPtr theWindow )
X  {
X  	trans_num_keys ( theEvent ) ;
X! 	addToKeyQueue ( topl_resp_key ( theEvent -> message & 0xff ) , 1 ) ;
X  }
X  
X  
X--- 1441,1451 ----
X  void
X  GeneralKey ( EventRecord * theEvent , WindowPtr theWindow )
X  {
X+ #if defined(applec)
X+ # pragma unused(theWindow)
X+ #endif
X  	trans_num_keys ( theEvent ) ;
X! 	AddToKeyQueue ( topl_resp_key ( theEvent -> message & 0xff ) , 1 ) ;
X  }
X  
X  
X***************
X*** 1398,1404 ****
X  
X  
X  static void
X! macKeyStatus ( EventRecord * theEvent , WindowPtr theWindow )
X  {
X  	GeneralKey ( theEvent , theWindow ) ;
X  }
X--- 1464,1470 ----
X  
X  
X  static void
X! macKeyTerm ( EventRecord * theEvent , WindowPtr theWindow )
X  {
X  	GeneralKey ( theEvent , theWindow ) ;
X  }
X***************
X*** 1405,1421 ****
X  
X  
X  static void
X- macKeyMap ( EventRecord * theEvent , WindowPtr theWindow )
X- {
X- 	GeneralKey ( theEvent , theWindow ) ;
X- }
X- 
X- 
X- static void
X  macKeyMenu ( EventRecord * theEvent , WindowPtr theWindow )
X  {
X  	if ( filter_scroll_key ( theEvent -> message & 0xff ,
X! 		( NhWindow * ) GetWRefCon ( theWindow ) ) ) {
X  		GeneralKey ( theEvent , theWindow ) ;
X  	}
X  }
X--- 1471,1480 ----
X  
X  
X  static void
X  macKeyMenu ( EventRecord * theEvent , WindowPtr theWindow )
X  {
X  	if ( filter_scroll_key ( theEvent -> message & 0xff ,
X! 		GetNhWin ( theWindow ) ) ) {
X  		GeneralKey ( theEvent , theWindow ) ;
X  	}
X  }
X***************
X*** 1425,1435 ****
X  macKeyText ( EventRecord * theEvent , WindowPtr theWindow )
X  {
X  	char c = filter_scroll_key ( theEvent -> message & 0xff ,
X! 								 ( NhWindow * ) GetWRefCon ( theWindow ) ) ;
X  	if ( c )
X  		if ( inSelect == WIN_ERR && ClosingWindowChar ( c ) ) {
X  			HideWindow ( theWindow ) ;
X! 			destroy_nhwindow ( ( NhWindow * ) GetWRefCon ( theWindow ) - theWindows ) ;
X  		} else {
X  			GeneralKey ( theEvent , theWindow ) ;
X  		}
X--- 1484,1494 ----
X  macKeyText ( EventRecord * theEvent , WindowPtr theWindow )
X  {
X  	char c = filter_scroll_key ( theEvent -> message & 0xff ,
X! 								 GetNhWin ( theWindow ) ) ;
X  	if ( c )
X  		if ( inSelect == WIN_ERR && ClosingWindowChar ( c ) ) {
X  			HideWindow ( theWindow ) ;
X! 			destroy_nhwindow ( GetNhWin ( theWindow ) - theWindows ) ;
X  		} else {
X  			GeneralKey ( theEvent , theWindow ) ;
X  		}
X***************
X*** 1469,1475 ****
X  			}
X  			if (in_btn) {
X  				InvertRect(&frame);
X! 				addToKeyQueue ( topl_resp [ r_idx ] , 1 ) ;
X  			}
X  			return;
X  
X--- 1528,1534 ----
X  			}
X  			if (in_btn) {
X  				InvertRect(&frame);
X! 				AddToKeyQueue ( topl_resp [ r_idx ] , 1 ) ;
X  			}
X  			return;
X  
X***************
X*** 1482,1504 ****
X  
X  
X  static void
X! macClickStatus ( EventRecord * theEvent , WindowPtr theWindow )
X  {
X- 	if ( ! theEvent || ! theWindow ) {
X- 		Debugger ( ) ;
X- 	}
X- }
X- 
X- 
X- static void
X- macClickMap ( EventRecord * theEvent , WindowPtr theWindow )
X- {
X  	int shift_down = theEvent->modifiers & shiftKey;
X! 	NhWindow *nhw = (NhWindow *)GetWRefCon(theWindow);
X  	Point where = theEvent->where;
X  		GlobalToLocal(&where);
X! 		where.h /= nhw->charWidth;
X! 		where.v /= nhw->charHeight;
X  	clicked_mod = shift_down ? CLICK_2 : CLICK_1;
X  
X  	if (strchr(topl_resp, click_to_cmd(where.h, where.v, clicked_mod)))
X--- 1541,1554 ----
X  
X  
X  static void
X! macClickTerm ( EventRecord * theEvent , WindowPtr theWindow )
X  {
X  	int shift_down = theEvent->modifiers & shiftKey;
X! 	NhWindow *nhw = GetNhWin(theWindow);
X  	Point where = theEvent->where;
X  		GlobalToLocal(&where);
X! 		where.h = where.h / nhw->charWidth + 1;
X! 		where.v = where.v / nhw->charHeight;
X  	clicked_mod = shift_down ? CLICK_2 : CLICK_1;
X  
X  	if (strchr(topl_resp, click_to_cmd(where.h, where.v, clicked_mod)))
X***************
X*** 1675,1681 ****
X  	Point p ;
X  	short hiRow = -1 , loRow = -1 ;
X  	Rect r ;
X! 	NhWindow * aWin = ( NhWindow * ) GetWRefCon ( theWindow ) ;
X  
X  	r = theWindow -> portRect ;
X  	if ( aWin -> scrollBar && ( * aWin -> scrollBar ) -> contrlVis ) {
X--- 1725,1731 ----
X  	Point p ;
X  	short hiRow = -1 , loRow = -1 ;
X  	Rect r ;
X! 	NhWindow * aWin = GetNhWin ( theWindow ) ;
X  
X  	r = theWindow -> portRect ;
X  	if ( aWin -> scrollBar && ( * aWin -> scrollBar ) -> contrlVis ) {
X***************
X*** 1725,1731 ****
X  		} while ( StillDown ( ) ) ;
X  		if ( loRow > -1 && aWin -> itemChars [ loRow + aWin -> scrollPos ] ) {
X  			InvertRect ( & r ) ;
X! 			addToKeyQueue ( aWin -> itemChars [ loRow + aWin -> scrollPos ] , 1 ) ;
X  		}
X  	}
X  }
X--- 1775,1781 ----
X  		} while ( StillDown ( ) ) ;
X  		if ( loRow > -1 && aWin -> itemChars [ loRow + aWin -> scrollPos ] ) {
X  			InvertRect ( & r ) ;
X! 			AddToKeyQueue ( aWin -> itemChars [ loRow + aWin -> scrollPos ] , 1 ) ;
X  		}
X  	}
X  }
X***************
X*** 1736,1742 ****
X  {
X  	short hiRow = -1 , loRow = -1 ;
X  	Rect r ;
X! 	NhWindow * aWin = ( NhWindow * ) GetWRefCon ( theWindow ) ;
X  
X  	r = theWindow -> portRect ;
X  	if ( aWin -> scrollBar && ( * aWin -> scrollBar ) -> contrlVis ) {
X--- 1786,1792 ----
X  {
X  	short hiRow = -1 , loRow = -1 ;
X  	Rect r ;
X! 	NhWindow * aWin = GetNhWin ( theWindow ) ;
X  
X  	r = theWindow -> portRect ;
X  	if ( aWin -> scrollBar && ( * aWin -> scrollBar ) -> contrlVis ) {
X***************
X*** 1787,1793 ****
X  {
X  	RgnHandle org_clip = NewRgn(), clip = NewRgn();
X  	Rect r = theWindow -> portRect ;
X! 	NhWindow * aWin = ( NhWindow * ) GetWRefCon ( theWindow ) ;
X  	int l ;
X  
X  	if ( ! theEvent ) {
X--- 1837,1843 ----
X  {
X  	RgnHandle org_clip = NewRgn(), clip = NewRgn();
X  	Rect r = theWindow -> portRect ;
X! 	NhWindow * aWin = GetNhWin ( theWindow ) ;
X  	int l ;
X  
X  	if ( ! theEvent ) {
X***************
X*** 1907,1989 ****
X  
X  
X  static void
X! macUpdateStatus ( EventRecord * theEvent , WindowPtr theWindow )
X  {
X! 	NhWindow * nhw = ( NhWindow * ) GetWRefCon ( theWindow ) ;
X! 	int height = nhw -> charHeight ;
X! 	int leading = nhw -> leading ;
X! 	int i ;
X! 
X! 	if ( ! theEvent ) {
X! 		Debugger ( ) ;
X! 	}
X! 
X! 	TextFont ( nhw -> fontNum ) ;
X! 	TextSize ( nhw -> fontSize ) ;
X! 	HLock ( nhw -> windowText ) ;
X! 	for ( i = 0 ; i < NUM_STAT_ROWS ; i ++ ) {
X! 		MoveTo ( 0 , ( i + 1 ) * height - leading ) ;
X! 		DrawText ( ( ( StatusData * ) ( * nhw -> windowText ) ) -> map [ i ] ,
X! 			0 , NUM_COLS ) ;
X! 	}
X! 	HUnlock ( nhw -> windowText ) ;
X  }
X  
X  
X  static void
X- DrawMapCursor ( NhWindow * nhw )
X- {
X- 	Rect r ;
X- 
X- 	/*
X- 	 * We only want a cursor in the map
X- 	 * window...
X- 	 */
X- 	if ( ! WIN_MAP || nhw - theWindows != WIN_MAP )
X- 		return ;
X- 
X- 	r . left = nhw -> cursor . h * nhw -> charWidth ;
X- 	r . right = ( nhw -> cursor . h + 1 ) * nhw -> charWidth ;
X- 	r . top = nhw -> cursor . v * nhw -> charHeight ;
X- 	r . bottom = ( nhw -> cursor . v + 1 ) * nhw -> charHeight ;
X- 	InvertRect ( & r ) ;
X- 	nhw -> cursorDrawn = 1 ;
X- }
X- 
X- 
X- static void
X- macUpdateMap ( EventRecord * theEvent , WindowPtr theWindow )
X- {
X- 	NhWindow * nhw = ( NhWindow * ) GetWRefCon ( theWindow ) ;
X- 	int height = nhw -> charHeight ;
X- 	int leading = nhw -> leading ;
X- 	int i ;
X- 
X- 	if ( ! theEvent ) {
X- 		Debugger ( ) ;
X- 	}
X- 
X- 	TextFont ( nhw -> fontNum ) ;
X- 	TextSize ( nhw -> fontSize ) ;
X- 	HLock ( nhw -> windowText ) ;
X- 	for ( i = 0 ; i < NUM_ROWS ; i ++ ) {
X- 		MoveTo ( 0 , ( i + 1 ) * height - leading ) ;
X- 		DrawText ( ( ( MapData * ) ( * nhw -> windowText ) ) -> map [ i ] ,
X- 			0 , NUM_COLS ) ;
X- 	}
X- 	HUnlock ( nhw -> windowText ) ;
X- 	if ( nhw -> cursorDrawn ) {
X- 		DrawMapCursor ( nhw ) ;
X- 	}
X- }
X- 
X- 
X- static void
X  macUpdateMenu ( EventRecord * theEvent , WindowPtr theWindow )
X  {
X  	Rect r = theWindow -> portRect ;
X  	Rect r2 = r ;
X! 	NhWindow * aWin = ( NhWindow * ) GetWRefCon ( theWindow ) ;
X  	RgnHandle h ;
X  	Boolean vis ;
X  
X--- 1957,1978 ----
X  
X  
X  static void
X! macUpdateTerm ( EventRecord * theEvent , WindowPtr theWindow )
X  {
X! #if defined(applec)
X! # pragma unused(theEvent)
X! #endif
X! 	tty_environment_changed ( theWindow ) ;
X! 	image_tty(theWindow);
X  }
X  
X  
X  static void
X  macUpdateMenu ( EventRecord * theEvent , WindowPtr theWindow )
X  {
X  	Rect r = theWindow -> portRect ;
X  	Rect r2 = r ;
X! 	NhWindow * aWin = GetNhWin ( theWindow ) ;
X  	RgnHandle h ;
X  	Boolean vis ;
X  
END_OF_FILE
if test 39051 -ne `wc -c <'patches02p.1'`; then
    echo shar: \"'patches02p.1'\" unpacked with wrong size!
fi
# end of 'patches02p.1'
if test -f 'src/sounds.c' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'src/sounds.c'\" to \"'src/sounds.c.orig'\"
  mv -f 'src/sounds.c' 'src/sounds.c.orig'
fi
echo shar: Extracting \"'src/sounds.c'\" \(16940 characters\)
sed "s/^X//" >'src/sounds.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)sounds.c	3.1	93/03/14	*/
X/*	Copyright (c) 1989 Janet Walz, Mike Threepoint */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include "hack.h"
X#include "edog.h"
X
X#ifdef OVLB
X
Xstatic int FDECL(domonnoise,(struct monst *));
Xstatic int NDECL(dochat);
X
X#endif /* OVLB */
X
X#ifdef SOUNDS
X
X#ifdef OVL0
X
Xvoid
Xdosounds()
X{
X    register xchar hallu;
X    register struct mkroom *sroom;
X    register int vx, vy;
X#if defined(AMIGA) && defined(AZTEC_C_WORKAROUND)
X    int xx;
X#endif
X
X    hallu = Hallucination ? 1 : 0;
X
X    if(!flags.soundok || u.uswallow || Underwater) return;
X
X    if (level.flags.nfountains && !rn2(400)) {
X	static const char *fountain_msg[4] = {
X		"hear bubbling water.",
X		"hear water falling on coins.",
X		"hear the splashing of a naiad.",
X		"hear a soda fountain!",
X	};
X	You(fountain_msg[rn2(3)+hallu]);
X    }
X#ifdef SINK
X    if (level.flags.nsinks && !rn2(300)) {
X	static const char *sink_msg[3] = {
X		"hear a slow drip.",
X		"hear a gurgling noise.",
X		"hear dishes being washed!",
X	};
X	You(sink_msg[rn2(2)+hallu]);
X    }
X#endif
X    if (level.flags.has_court && !rn2(200)) {
X	static const char *throne_msg[4] = {
X		"hear the tones of courtly conversation.",
X		"hear a sceptre pounded in judgment.",
X		"Someone shouts \"Off with %s head!\"",
X		"hear Queen Beruthiel's cats!",
X	};
X	int which = rn2(3)+hallu;
X	if (which != 2) You(throne_msg[which]);
X	else		pline(throne_msg[2], his[flags.female]);
X	return;
X    }
X    if (level.flags.has_swamp && !rn2(200)) {
X	static const char *swamp_msg[3] = {
X		"hear mosquitoes!",
X		"smell marsh gas!",	/* so it's a smell...*/
X		"hear Donald Duck!",
X	};
X	You(swamp_msg[rn2(2)+hallu]);
X	return;
X    }
X    if (level.flags.has_vault && !rn2(200)) {
X	if (!(sroom = search_special(VAULT))) {
X	    /* strange ... */
X	    level.flags.has_vault = 0;
X	    return;
X	}
X	if(gd_sound())
X	    switch (rn2(2)+hallu) {
X		case 1: {
X		    boolean gold_in_vault = FALSE;
X
X		    for (vx = sroom->lx;vx <= sroom->hx; vx++)
X			for (vy = sroom->ly; vy <= sroom->hy; vy++)
X			    if (g_at(vx, vy))
X				gold_in_vault = TRUE;
X#if defined(AMIGA) && defined(AZTEC_C_WORKAROUND)
X		    /* Bug in aztec assembler here. Workaround below */
X		    xx = ROOM_INDEX(sroom) + ROOMOFFSET;
X		    xx = (xx != vault_occupied(u.urooms));
X		    if(xx)
X#else
X		    if (vault_occupied(u.urooms) != 
X			 (ROOM_INDEX(sroom) + ROOMOFFSET))
X#endif /* AZTEC_C_WORKAROUND */
X		    {
X			if (gold_in_vault)
X			    You(!hallu ? "hear someone counting money." :
X				"hear the quarterback calling the play.");
X			else
X			    You("hear someone searching.");
X			break;
X		    }
X		    /* fall into... (yes, even for hallucination) */
X		}
X		case 0:
X		    You("hear the footsteps of a guard on patrol.");
X		    break;
X		case 2:
X		    You("hear Ebenezer Scrooge!");
X		    break;
X	    }
X	return;
X    }
X    if (level.flags.has_beehive && !rn2(200)) {
X	switch (rn2(2)+hallu) {
X	    case 0:
X		You("hear a low buzzing.");
X		break;
X	    case 1:
X		You("hear an angry drone.");
X		break;
X	    case 2:
X		You("hear bees in your %sbonnet!",
X		    uarmh ? "" : "(nonexistent) ");
X		break;
X	}
X	return;
X    }
X    if (level.flags.has_morgue && !rn2(200)) {
X	switch (rn2(2)+hallu) {
X	    case 0:
X		You("suddenly realize it is unnaturally quiet.");
X		break;
X	    case 1:
X		pline("The hair on the back of your %s stands up.",
X			body_part(NECK));
X		break;
X	    case 2:
X		pline("The hair on your %s seems to stand up.",
X			body_part(HEAD));
X		break;
X	}
X	return;
X    }
X#ifdef ARMY
X    if (level.flags.has_barracks && !rn2(200)) {
X	static const char *barracks_msg[4] = {
X		"hear blades being honed.",
X		"hear loud snoring.",
X		"hear dice being thrown.",
X		"hear General MacArthur!",
X	};
X	You(barracks_msg[rn2(3)+hallu]);
X	return;
X    }
X#endif /* ARMY */
X    if (level.flags.has_zoo && !rn2(200)) {
X	static const char *zoo_msg[3] = {
X		"hear a sound reminiscent of an elephant stepping on a peanut.",
X		"hear a sound reminiscent of a seal barking.",
X		"hear Doctor Doolittle!",
X	};
X	You(zoo_msg[rn2(2)+hallu]);
X	return;
X    }
X    if (level.flags.has_shop && !rn2(200)) {
X	if (!(sroom = search_special(ANY_SHOP))) {
X	    /* strange... */
X	    level.flags.has_shop = 0;
X	    return;
X	}
X	if (tended_shop(sroom) &&
X		!index(u.ushops, ROOM_INDEX(sroom) + ROOMOFFSET)) {
X	    static const char *shop_msg[3] = {
X		    "hear someone cursing shoplifters.",
X		    "hear the chime of a cash register.",
X		    "hear Neiman and Marcus arguing!",
X	    };
X	    You(shop_msg[rn2(2)+hallu]);
X	}
X	return;
X    }
X}
X
X#endif /* OVL0 */
X#ifdef OVLB
X
Xstatic const char *h_sounds[] = {
X    "beep", "boing", "sing", "belche", "creak", "cough", "rattle",
X    "ululate", "pop", "jingle", "sniffle", "tinkle", "eep"
X};
X
Xvoid
Xgrowl(mtmp)
Xregister struct monst *mtmp;
X{
X    register const char *growl_verb = 0;
X
X    if (mtmp->msleep || !mtmp->mcanmove || !mtmp->data->msound) return;
X
X    /* presumably nearness and soundok checks have already been made */
X    if (Hallucination)
X        growl_verb = h_sounds[rn2(SIZE(h_sounds))];
X    else switch (mtmp->data->msound) {
X	case MS_MEW:
X	case MS_HISS:
X	    growl_verb = "hisse";	/* hisseS */
X	    break;
X	case MS_BARK:
X	case MS_GROWL:
X	    growl_verb = "growl";
X	    break;
X	case MS_ROAR:
X	    growl_verb = "roar";
X	    break;
X	case MS_BUZZ:
X	    growl_verb = "buzze";
X	    break;
X	case MS_SQEEK:
X	    growl_verb = "squeal";
X	    break;
X	case MS_SQAWK:
X	    growl_verb = "screeche";
X	    break;
X	case MS_NEIGH:
X	    growl_verb = "neigh";
X	    break;
X	case MS_WAIL:
X	    growl_verb = "wail";
X	    break;
X    }
X    if (growl_verb) pline("%s %ss!", Monnam(mtmp), growl_verb);
X}
X
X/* the sounds of mistreated pets */
Xvoid
Xyelp(mtmp)
Xregister struct monst *mtmp;
X{
X    register const char *yelp_verb = 0;
X
X    if (mtmp->msleep || !mtmp->mcanmove || !mtmp->data->msound) return;
X
X    /* presumably nearness and soundok checks have already been made */
X    if (Hallucination)
X        yelp_verb = h_sounds[rn2(SIZE(h_sounds))];
X    else switch (mtmp->data->msound) {
X	case MS_MEW:
X	    yelp_verb = "yowl";
X	    break;
X	case MS_BARK:
X	case MS_GROWL:
X	    yelp_verb = "yelp";
X	    break;
X	case MS_ROAR:
X	    yelp_verb = "snarl";
X	    break;
X	case MS_SQEEK:
X	    yelp_verb = "squeal";
X	    break;
X	case MS_SQAWK:
X	    yelp_verb = "screak";
X	    break;
X	case MS_WAIL:
X	    yelp_verb = "wail";
X	    break;
X    }
X    if (yelp_verb) pline("%s %ss!", Monnam(mtmp), yelp_verb);
X}
X
X/* the sounds of distressed pets */
Xvoid
Xwhimper(mtmp)
Xregister struct monst *mtmp;
X{
X    register const char *whimper_verb = 0;
X
X    if (mtmp->msleep || !mtmp->mcanmove || !mtmp->data->msound) return;
X
X    /* presumably nearness and soundok checks have already been made */
X    if (Hallucination)
X        whimper_verb = h_sounds[rn2(SIZE(h_sounds))];
X    else switch (mtmp->data->msound) {
X	case MS_MEW:
X	case MS_GROWL:
X	    whimper_verb = "whimper";
X	    break;
X	case MS_BARK:
X	    whimper_verb = "whine";
X	    break;
X	case MS_SQEEK:
X	    whimper_verb = "squeal";
X	    break;
X    }
X    if (whimper_verb) pline("%s %ss.", Monnam(mtmp), whimper_verb);
X}
X
X/* pet makes "I'm hungry" noises */
Xvoid
Xbeg(mtmp)
Xregister struct monst *mtmp;
X{
X    if (mtmp->msleep || !mtmp->mcanmove ||
X	!(carnivorous(mtmp->data) || herbivorous(mtmp->data))) return;
X    /* presumably nearness and soundok checks have already been made */
X    if (mtmp->data->msound != MS_SILENT && mtmp->data->msound <= MS_ANIMAL)
X	(void) domonnoise(mtmp);
X    else if (mtmp->data->msound >= MS_HUMANOID)
X	verbalize("I'm hungry.");
X}
X
X#endif /* OVLB */
X
X#endif /* SOUNDS */
X
X#ifdef OVLB
X
Xstatic int
Xdomonnoise(mtmp)
Xregister struct monst *mtmp;
X{
X#ifdef SOUNDS
X    register const char *pline_msg = 0;	/* Monnam(mtmp) will be prepended */
X#endif
X
X    /* presumably nearness and sleep checks have already been made */
X    if (!flags.soundok) return(0);
X
X    switch (mtmp->data->msound) {
X	case MS_ORACLE:
X	    return doconsult(mtmp);
X	case MS_PRIEST:
X	    priest_talk(mtmp);
X	    break;
X#ifdef MULDGN
X	case MS_LEADER:
X	case MS_NEMESIS:
X	case MS_GUARDIAN:
X	    quest_chat(mtmp);
X	    break;
X#endif
X#ifdef SOUNDS
X	case MS_SELL: /* pitch, pay, total */
X	    shk_chat(mtmp);
X	    break;
X	case MS_SILENT:
X	    break;
X	case MS_BARK:
X	    if (flags.moonphase == FULL_MOON && night()) {
X		pline_msg = "howls.";
X	    } else if (mtmp->mpeaceful) {
X		if (mtmp->mtame &&
X		    (mtmp->mconf || mtmp->mflee || mtmp->mtrapped ||
X		     moves > EDOG(mtmp)->hungrytime || mtmp->mtame < 5))
X		    pline_msg = "whines.";
X		else if (EDOG(mtmp)->hungrytime > moves + 1000)
X		    pline_msg = "yips.";
X		else
X		    pline_msg = "barks.";
X	    } else {
X		pline_msg = "growls.";
X	    }
X	    break;
X	case MS_MEW:
X	    if (mtmp->mtame) {
X		if (mtmp->mconf || mtmp->mflee || mtmp->mtrapped ||
X		    mtmp->mtame < 5)
X		    pline_msg = "yowls.";
X		else if (moves > EDOG(mtmp)->hungrytime)
X		    pline_msg = "miaos.";
X		else if (EDOG(mtmp)->hungrytime > moves + 1000)
X		    pline_msg = "purrs.";
X		else
X		    pline_msg = "mews.";
X		break;
X	    } /* else FALLTHRU */
X	case MS_GROWL:
X	    pline_msg = mtmp->mpeaceful ? "snarls." : "growls!";
X	    break;
X	case MS_ROAR:
X	    pline_msg = mtmp->mpeaceful ? "snarls." : "roars!";
X	    break;
X	case MS_SQEEK:
X	    pline_msg = "squeaks.";
X	    break;
X	case MS_SQAWK:
X	    pline_msg = "squawks.";
X	    break;
X	case MS_HISS:
X	    if (!mtmp->mpeaceful)
X		pline_msg = "hisses!";
X	    else return 0;	/* no sound */
X	    break;
X	case MS_BUZZ:
X	    pline_msg = mtmp->mpeaceful ? "drones." : "buzzes angrily.";
X	    break;
X	case MS_GRUNT:
X	    pline_msg = "grunts.";
X	    break;
X	case MS_NEIGH:
X	    if (mtmp->mtame < 5)
X		pline_msg = "neighs.";
X	    else if (moves > EDOG(mtmp)->hungrytime)
X		pline_msg = "whinnies.";
X	    else
X		pline_msg = "whickers.";
X	    break;
X	case MS_WAIL:
X	    pline_msg = "wails mournfully.";
X	    break;
X	case MS_GURGLE:
X	    pline_msg = "gurgles.";
X	    break;
X	case MS_BURBLE:
X	    pline_msg = "burbles.";
X	    break;
X	case MS_SHRIEK:
X	    pline_msg = "shrieks.";
X	    aggravate();
X	    break;
X	case MS_IMITATE:
X	    pline_msg = "imitates you.";
X	    break;
X	case MS_BONES:
X	    pline("%s rattles noisily.", Monnam(mtmp));
X	    You("freeze for a moment.");
X	    nomul(-2);
X	    break;
X	case MS_LAUGH:
X	    {
X		static const char *laugh_msg[4] = {
X		    "giggles.", "chuckles.", "snickers.", "laughs.",
X		};
X		pline_msg = laugh_msg[rn2(4)];
X	    }
X	    break;
X	case MS_MUMBLE:
X	    pline_msg = "mumbles incomprehensibly.";
X	    break;
X	case MS_DJINNI:
X	    if (mtmp->mtame) verbalize("Thank you for freeing me!");
X	    else if (mtmp->mpeaceful) verbalize("I'm free!");
X	    else verbalize("This will teach you not to disturb me!");
X	    break;
X	case MS_HUMANOID:
X	    if (!mtmp->mpeaceful) {
X		if (In_endgame(&u.uz) && is_mplayer(mtmp->data)) {
X		    mplayer_talk(mtmp);
X		    break;
X		} else {
X		    return 0;	/* no sound */
X		}
X	    }
X	    /* Generic peaceful humanoid behaviour. */
X	    if (mtmp->mflee)
X		pline_msg = "wants nothing to do with you.";
X	    else if (mtmp->mhp < mtmp->mhpmax/4)
X		pline_msg = "moans.";
X	    else if (mtmp->mconf || mtmp->mstun)
X		verbalize(!rn2(3) ? "Huh?" : rn2(2) ? "What?" : "Eh?");
X	    else if (!mtmp->mcansee)
X		verbalize("I can't see!");
X	    else if (mtmp->mtrapped)
X		verbalize("I'm trapped!");
X	    else if (mtmp->mhp < mtmp->mhpmax/2)
X		pline_msg = "asks for a potion of healing.";
X	    else if (mtmp->mtame && moves > EDOG(mtmp)->hungrytime)
X		verbalize("I'm hungry.");
X	    /* Specific monster's interests */
X	    else if (is_elf(mtmp->data))
X		pline_msg = "curses orcs.";
X	    else if (is_dwarf(mtmp->data))
X		pline_msg = "talks about mining.";
X	    else if (likes_magic(mtmp->data))
X		pline_msg = "talks about spellcraft.";
X	    else if (carnivorous(mtmp->data))
X		pline_msg = "discusses hunting.";
X	    else switch (monsndx(mtmp->data)) {
X		case PM_HOBBIT:
X		    pline_msg = (mtmp->mhpmax - mtmp->mhp >= 10) ?
X				"complains about unpleasant dungeon conditions."
X				: "asks you about the One Ring.";
X		    break;
X		case PM_ARCHEOLOGIST:
X    pline_msg = "describes a recent article in \"Spelunker Today\" magazine.";
X		    break;
X# ifdef TOURIST
X		case PM_TOURIST:
X		    verbalize("Aloha.");
X		    break;
X# endif
X		default:
X		    pline_msg = "discusses dungeon exploration.";
X	    }
X	    break;
X	case MS_SEDUCE:
X# ifdef SEDUCE
X	    if (mtmp->data->mlet != S_NYMPH &&
X		could_seduce(mtmp, &youmonst, (struct attack *)0) == 1) {
X			(void) doseduce(mtmp);
X			break;
X	    }
X	    switch ((poly_gender() != mtmp->female) ? rn2(3) : 0) {
X# else
X	    switch ((poly_gender() == 0) ? rn2(3) : 0) {
X# endif
X		case 2:
X			verbalize("Hello, sailor.");
X			break;
X		case 1:
X			pline_msg = "comes on to you.";
X			break;
X		default:
X			pline_msg = "cajoles you.";
X	    }
X	    break;
X# ifdef KOPS
X	case MS_ARREST:
X	    if (mtmp->mpeaceful)
X		verbalize("Just the facts, %s.",
X		      flags.female ? "Ma'am" : "Sir");
X	    else {
X		static const char *arrest_msg[3] = {
X		    "Anything you say can be used against you.",
X		    "You're under arrest!",
X		    "Stop in the name of the Law!",
X		};
X		verbalize(arrest_msg[rn2(3)]);
X	    }
X	    break;
X# endif
X	case MS_BRIBE:
X	    if (mtmp->mpeaceful && !mtmp->mtame) {
X		(void) demon_talk(mtmp);
X		break;
X	    }
X	    /* fall through */
X	case MS_CUSS:
X	    if (!mtmp->mpeaceful)
X		cuss(mtmp);
X	    break;
X	case MS_NURSE:
X	    if (uwep)
X		verbalize("Put that weapon away before you hurt someone!");
X	    else if (uarmc || uarm || uarmh || uarms || uarmg || uarmf)
X		if (pl_character[0] == 'H')
X		    verbalize("Doc, I can't help you unless you cooperate.");
X		else
X		    verbalize("Please undress so I can examine you.");
X# ifdef TOURIST
X	    else if (uarmu)
X		verbalize("Take off your shirt, please.");
X# endif
X	    else verbalize("Relax, this won't hurt a bit.");
X	    break;
X	case MS_GUARD:
X	    if (u.ugold)
X		verbalize("Please drop that gold and follow me.");
X	    else
X		verbalize("Please follow me.");
X	    break;
X	case MS_SOLDIER:
X	    {
X		static const char *soldier_foe_msg[3] = {
X		    "Resistance is useless!",
X		    "You're dog meat!",
X		    "Surrender!",
X		},		  *soldier_pax_msg[3] = {
X		    "What lousy pay we're getting here!",
X		    "The food's not fit for Orcs!",
X		    "My feet hurt, I've been on them all day!",
X		};
X		verbalize(mtmp->mpeaceful ? soldier_pax_msg[rn2(3)]
X					  : soldier_foe_msg[rn2(3)]);
X	    }
X	    break;
X	case MS_RIDER:
X	    if (mtmp->data == &mons[PM_DEATH] && mtmp->mpeaceful)
X		pline_msg = "is busy reading a copy of Sandman #9.";
X	    else verbalize("Who do you think you are, War?");
X	    break;
X#endif /* SOUNDS */
X    }
X
X#ifdef SOUNDS
X    if (pline_msg) pline("%s %s", Monnam(mtmp), pline_msg);
X#endif
X    return(1);
X}
X
X
Xint
Xdotalk()
X{
X    int result;
X    boolean save_soundok = flags.soundok;
X    flags.soundok = 1;	/* always allow sounds while chatting */
X    result = dochat();
X    flags.soundok = save_soundok;
X    return result;
X}
X
Xstatic int
Xdochat()
X{
X    register struct monst *mtmp;
X    register int tx,ty;
X    struct obj *otmp;
X
X#ifdef POLYSELF
X    if (uasmon->msound == MS_SILENT) {
X	pline("As %s, you cannot speak.", an(uasmon->mname));
X	return(0);
X    }
X#endif
X    if (Strangled) {
X	You("can't speak.  You're choking!");
X	return(0);
X    }
X    if (u.uswallow) {
X	pline("They won't hear you out there.");
X	return(0);
X    }
X    if (Underwater) {
X	pline("Your speech is unintelligible underwater.");
X	return(0);
X    }
X
X    if (!Blind && (otmp = shop_object(u.ux, u.uy)) != (struct obj *)0) {
X	/* standing on something in a shop and chatting causes the shopkeeper
X	   to describe the price(s).  This can inhibit other chatting inside
X	   a shop, but that shouldn't matter much.  shop_object() returns an
X	   object iff inside a shop and the shopkeeper is present and willing
X	   (not angry) and able (not asleep) to speak and the position contains
X	   any objects other than just gold.
X	*/
X	price_quote(otmp);
X	return(1);
X    }
X
X    (void) getdir("Talk to whom? [in what direction]");
X
X    if (u.dz) {
X	pline("They won't hear you %s there.", u.dz < 0 ? "up" : "down");
X	return(0);
X    }
X
X    if (u.dx == 0 && u.dy == 0) {
X/*
X * Let's not include this.  It raises all sorts of questions: can you wear
X * 2 helmets, 2 amulets, 3 pairs of gloves or 6 rings as a marilith,
X * etc...  --KAA
X#ifdef POLYSELF
X	if (u.umonnum == PM_ETTIN) {
X	    You("discover that your other head makes boring conversation.");
X	    return(1);
X	}
X#endif
X*/
X	pline("Talking to yourself is a bad habit for a dungeoneer.");
X	return(0);
X    }
X
X    tx = u.ux+u.dx; ty = u.uy+u.dy;
X    mtmp = m_at(tx, ty);
X    if ((Blind && !Telepat) || !mtmp || mtmp->mundetected ||
X		mtmp->m_ap_type == M_AP_FURNITURE ||
X		mtmp->m_ap_type == M_AP_OBJECT) {
X	pline("I see nobody there.");
X	return(0);
X    }
X    if (!mtmp->mcanmove || mtmp->msleep) {
X	pline("%s seems not to notice you.", Monnam(mtmp));
X	return(0);
X    }
X
X    if (mtmp->mtame && mtmp->meating) {
X	pline("%s is eating noisily.", Monnam(mtmp));
X	return (0);
X    }
X
X    return domonnoise(mtmp);
X}
X
X#endif /* OVLB */
X
X/*sounds.c*/
END_OF_FILE
if test 16940 -ne `wc -c <'src/sounds.c'`; then
    echo shar: \"'src/sounds.c'\" unpacked with wrong size!
fi
# end of 'src/sounds.c'
echo shar: End of archive 22 \(of 33\).
cp /dev/null ark22isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 33 archives.
    echo "Now execute ./patchit.sh"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
