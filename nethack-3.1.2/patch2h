Path: uunet!news.tek.com!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v17i083:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Patch2h/33
Date: 11 Jun 1993 00:08:23 GMT
Organization: Tektronix, Inc, Redmond, OR, USA
Lines: 2159
Approved: billr@saab.CNA.TEK.COM
Message-ID: <1v8idn$is3@ying.cna.tek.com>
NNTP-Posting-Host: saab.cna.tek.com
Xref: uunet comp.sources.games:1771

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 17, Issue 83
Archive-name: nethack31/Patch2h
Patch-To: nethack31: Volume 16, Issue 1-116
Environment: Amiga, Atari, Mac, MS-DOS, Windows-NT, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 8 (of 33)."
# Contents:  patches02a sys/amiga/amitty.c sys/amiga/randwin.uu
# Wrapped by billr@saab on Thu Jun 10 16:55:01 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'patches02a' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'patches02a'\" to \"'patches02a.orig'\"
  mv -f 'patches02a' 'patches02a.orig'
fi
echo shar: Extracting \"'patches02a'\" \(55493 characters\)
sed "s/^X//" >'patches02a' <<'END_OF_FILE'
X*** /tmp/da10778	Tue Jun  1 16:12:30 1993
X--- src/allmain.c	Fri May 28 11:40:21 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)allmain.c	3.1	92/11/13	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)allmain.c	3.1	93/05/23	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 95,100 ****
X--- 95,108 ----
X  		    ++moves;
X  		    if (u.ublesscnt)  u.ublesscnt--;
X  		    if(flags.time) flags.botl = 1;
X+ 		    /* One possible result of prayer is healing.  Whether or
X+ 		     * not you get healed depends on your current hit points.
X+ 		     * If you are allowed to regenerate during the prayer, the
X+ 		     * end-of-prayer calculation messes up on this.
X+ 		     */
X+ 		    if (u.uinvulnerable)
X+ 			;
X+ 		    else
X  #ifdef POLYSELF
X  		    if (u.mtimedone && u.mh < u.mhmax) {
X  			if (u.mh < 1) {
X***************
X*** 355,361 ****
X       * have to split display_gamewindows into create_gamewindows
X       * and show_gamewindows to get rid of this ifdef...
X       */
X!     SanePositions ( ) ;
X  #endif
X  
X      /*
X--- 363,371 ----
X       * have to split display_gamewindows into create_gamewindows
X       * and show_gamewindows to get rid of this ifdef...
X       */
X! 	if ( ! strcmp ( windowprocs . name , "mac" ) ) {
X! 	    SanePositions ( ) ;
X! 	}
X  #endif
X  
X      /*
X***************
X*** 375,388 ****
X  	gameDiskPrompt();
X  #endif
X  
X! 	fobj = invent = migrating_objs = (struct obj *)0;
X  	fmon = migrating_mons = (struct monst *)0;
X  	ftrap = 0;
X  	flags.ident = 1;
X  
X  	if(wiz1_level.dlevel == 0) init_dungeons();
X! 	init_objects();
X  	u_init();
X  
X  #ifndef NO_SIGNAL
X  	(void) signal(SIGINT, (SIG_RET_TYPE) done1);
X--- 385,399 ----
X  	gameDiskPrompt();
X  #endif
X  
X! 	fobj = invent = level.buriedobjlist = migrating_objs = (struct obj *)0;
X  	fmon = migrating_mons = (struct monst *)0;
X  	ftrap = 0;
X  	flags.ident = 1;
X  
X  	if(wiz1_level.dlevel == 0) init_dungeons();
X! 	init_objects();		/* must be before u_init() */
X  	u_init();
X+ 	init_artifacts();	/* must be after u_init() */
X  
X  #ifndef NO_SIGNAL
X  	(void) signal(SIGINT, (SIG_RET_TYPE) done1);
X*** /tmp/da10794	Tue Jun  1 16:12:34 1993
X--- src/apply.c	Wed May 26 12:59:26 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)apply.c	3.1	93/02/19		  */
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)apply.c	3.1	93/05/25	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 38,43 ****
X--- 38,44 ----
X  static boolean NDECL(rm_waslit);
X  static void FDECL(mkcavepos, (XCHAR_P,XCHAR_P,int,BOOLEAN_P,BOOLEAN_P));
X  static void FDECL(mkcavearea, (BOOLEAN_P));
X+ static void FDECL(digactualhole, (int));
X  
X  #ifdef TOURIST
X  static int
X***************
X*** 57,63 ****
X  	} else if(obj->cursed && !rn2(2)) goto blindu;
X  	else if(u.dz) {
X  		You("take a picture of the %s.",
X! 			(u.dz > 0) ? "floor" : "ceiling");
X  	} else if(!u.dx && !u.dy) {
X  blindu:
X  		if(!Blind) {
X--- 58,64 ----
X  	} else if(obj->cursed && !rn2(2)) goto blindu;
X  	else if(u.dz) {
X  		You("take a picture of the %s.",
X! 			(u.dz > 0) ? surface(u.ux,u.uy) : "ceiling");
X  	} else if(!u.dx && !u.dy) {
X  blindu:
X  		if(!Blind) {
X***************
X*** 64,71 ****
X  			You("are blinded by the flash!");
X  			make_blinded((long)rnd(25),FALSE);
X  		}
X! 	} else if(mtmp = bhit(u.dx,u.dy,COLNO,FLASHED_LIGHT,
X! 						(int(*)())0,(int(*)())0,obj)) {
X  		if(mtmp->msleep) {
X  		    mtmp->msleep = 0;
X  		    if(cansee(mtmp->mx,mtmp->my))
X--- 65,72 ----
X  			You("are blinded by the flash!");
X  			make_blinded((long)rnd(25),FALSE);
X  		}
X! 	} else if ((mtmp = bhit(u.dx,u.dy,COLNO,FLASHED_LIGHT,
X! 				(int(*)())0,(int(*)())0,obj)) != 0) {
X  		if(mtmp->msleep) {
X  		    mtmp->msleep = 0;
X  		    if(cansee(mtmp->mx,mtmp->my))
X***************
X*** 158,164 ****
X  		return 1;
X  	}
X  
X! 	Your("%s and %s are already clean.", 
X  		body_part(FACE), makeplural(body_part(HAND)));
X  
X  	return 0;
X--- 159,165 ----
X  		return 1;
X  	}
X  
X! 	Your("%s and %s are already clean.",
X  		body_part(FACE), makeplural(body_part(HAND)));
X  
X  	return 0;
X***************
X*** 189,199 ****
X  		if (Underwater)
X  		    You("hear faint splashing.");
X  		else if (u.dz < 0 || Levitation)
X! 		    You("can't reach the %s.", u.dz<0 ? "ceiling" : "floor");
X  		else if (Is_stronghold(&u.uz))
X  		    You("hear the crackling of hellfire.");
X  		else
X! 		    pline("The floor seems healthy enough.");
X  		return;
X  	} else if (obj->cursed && !rn2(2)) {
X  		You("hear your heart beat.");
X--- 190,201 ----
X  		if (Underwater)
X  		    You("hear faint splashing.");
X  		else if (u.dz < 0 || Levitation)
X! 		    You("can't reach the %s.",
X! 			(u.dz > 0) ? surface(u.ux,u.uy) : "ceiling");
X  		else if (Is_stronghold(&u.uz))
X  		    You("hear the crackling of hellfire.");
X  		else
X! 		    pline("The %s seems healthy enough.", surface(u.ux,u.uy));
X  		return;
X  	} else if (obj->cursed && !rn2(2)) {
X  		You("hear your heart beat.");
X***************
X*** 209,215 ****
X  		You("hear a faint typing noise.");
X  		return;
X  	}
X! 	if(mtmp = m_at(rx,ry)) {
X  		mstatusline(mtmp);
X  		if (mtmp->mundetected) {
X  			mtmp->mundetected = 0;
X--- 211,217 ----
X  		You("hear a faint typing noise.");
X  		return;
X  	}
X! 	if ((mtmp = m_at(rx,ry)) != 0) {
X  		mstatusline(mtmp);
X  		if (mtmp->mundetected) {
X  			mtmp->mundetected = 0;
X***************
X*** 239,244 ****
X--- 241,249 ----
X  static void
X  use_whistle(obj)
X  struct obj *obj;
X+ #if defined(applec)
X+ # pragma unused(obj)
X+ #endif
X  {
X  	You(whistle_str, "high");
X  	wake_nearby();
X***************
X*** 287,293 ****
X  }
X  
X  void
X! o_unleash(otmp) 	/* otmp is about to be destroyed or stolen */
X  register struct obj *otmp;
X  {
X  	register struct monst *mtmp;
X--- 292,298 ----
X  }
X  
X  void
X! o_unleash(otmp)		/* otmp is about to be destroyed or stolen */
X  register struct obj *otmp;
X  {
X  	register struct monst *mtmp;
X***************
X*** 299,305 ****
X  }
X  
X  void
X! m_unleash(mtmp) 	/* mtmp is about to die, or become untame */
X  register struct monst *mtmp;
X  {
X  	register struct obj *otmp;
X--- 304,310 ----
X  }
X  
X  void
X! m_unleash(mtmp)		/* mtmp is about to die, or become untame */
X  register struct monst *mtmp;
X  {
X  	register struct obj *otmp;
X***************
X*** 422,428 ****
X  #endif /* OVL1 */
X  #ifdef OVLB
X  struct obj *
X! get_mleash(mtmp) 	/* assuming mtmp->mleashed has been checked */
X  register struct monst *mtmp;
X  {
X  	register struct obj *otmp;
X--- 427,433 ----
X  #endif /* OVL1 */
X  #ifdef OVLB
X  struct obj *
X! get_mleash(mtmp)	/* assuming mtmp->mleashed has been checked */
X  register struct monst *mtmp;
X  {
X  	register struct obj *otmp;
X***************
X*** 497,506 ****
X  rm_waslit() {
X      register xchar x, y;
X  
X!     if(levl[u.ux][u.uy].typ == ROOM && levl[u.ux][u.uy].waslit) 
X!         return(TRUE);
X      for(x = u.ux-2; x < u.ux+3; x++)
X!         for(y = u.uy-1; y < u.uy+2; y++)
X  	    if(isok(x,y) && levl[x][y].waslit) return(TRUE);
X      return(FALSE);
X  }
X--- 502,511 ----
X  rm_waslit() {
X      register xchar x, y;
X  
X!     if(levl[u.ux][u.uy].typ == ROOM && levl[u.ux][u.uy].waslit)
X! 	return(TRUE);
X      for(x = u.ux-2; x < u.ux+3; x++)
X! 	for(y = u.uy-1; y < u.uy+2; y++)
X  	    if(isok(x,y) && levl[x][y].waslit) return(TRUE);
X      return(FALSE);
X  }
X***************
X*** 521,531 ****
X      lev = &levl[x][y];
X  
X      if(rockit) {
X!         register struct monst *mtmp;
X  
X!         if(IS_ROCK(lev->typ)) return;
X  	if(t_at(x, y)) return; /* don't cover the portal */
X! 	if(mtmp = m_at(x, y)) /* make sure crucial monsters survive */
X  	    if(!passes_walls(mtmp->data)) rloc(mtmp);
X      } else if(lev->typ == ROOM) return;
X  
X--- 526,536 ----
X      lev = &levl[x][y];
X  
X      if(rockit) {
X! 	register struct monst *mtmp;
X  
X! 	if(IS_ROCK(lev->typ)) return;
X  	if(t_at(x, y)) return; /* don't cover the portal */
X! 	if ((mtmp = m_at(x, y)) != 0)	/* make sure crucial monsters survive */
X  	    if(!passes_walls(mtmp->data)) rloc(mtmp);
X      } else if(lev->typ == ROOM) return;
X  
X***************
X*** 586,592 ****
X      }
X  
X      if(!rockit && levl[u.ux][u.uy].typ == CORR) {
X!         levl[u.ux][u.uy].typ = ROOM;
X  	if(waslit) levl[u.ux][u.uy].waslit = TRUE;
X  	newsym(u.ux, u.uy); /* in case player is invisible */
X      }
X--- 591,597 ----
X      }
X  
X      if(!rockit && levl[u.ux][u.uy].typ == CORR) {
X! 	levl[u.ux][u.uy].typ = ROOM;
X  	if(waslit) levl[u.ux][u.uy].waslit = TRUE;
X  	newsym(u.ux, u.uy); /* in case player is invisible */
X      }
X***************
X*** 608,649 ****
X  	    ((dig_down && (dpx != u.ux || dpy != u.uy)) ||
X  	     (!dig_down && distu(dpx,dpy) > 2)))
X  		return(0);
X  	if (dig_down) {
X! 	    if(On_stairs(u.ux, u.uy)) {
X! 		if(u.ux == xdnladder || u.ux == xupladder)
X  		     pline("The ladder resists your effort.");
X  		else pline("The stairs are too hard to dig in.");
X  		return(0);
X! 	    }
X! 	    if(IS_THRONE(levl[u.ux][u.uy].typ)) {
X  		pline("The throne is too hard to break apart.");
X  		return (0);
X! 	    }
X! 	    if(IS_ALTAR(levl[u.ux][u.uy].typ)) {
X  		pline("The altar is too hard to break apart.");
X  		return (0);
X! 	    }
X! 	    if(t_at(dpx, dpy) && !Can_dig_down(&u.uz)) {
X! 		pline("The floor here is too hard to dig in.");
X! 		return(0);
X! 	    }
X! 	    if(sobj_at(BOULDER, dpx, dpy)) {
X! 		pline("There isn't enough room to dig here.");
X! 		return(0);
X! 	    }
X! 	    if(Is_airlevel(&u.uz)) {
X  		You("cannot dig in thin air.");
X  		return(0);
X! 	    }
X! 	    if(Is_waterlevel(&u.uz)) {
X  		pline("The water splashes and subsides.");
X  		return(0);
X  	    }
X! 	} else /* !dig_down */
X  	    if(IS_ROCK(lev->typ) && !may_dig(dpx,dpy)) {
X  		pline("This wall is too hard to dig into.");
X  		return(0);
X  	    }
X  	if(Fumbling && !rn2(3)) {
X  		switch(rn2(3)) {
X  		case 0:  if(!welded(uwep)) {
X--- 613,654 ----
X  	    ((dig_down && (dpx != u.ux || dpy != u.uy)) ||
X  	     (!dig_down && distu(dpx,dpy) > 2)))
X  		return(0);
X+ 
X  	if (dig_down) {
X! 	    struct trap *ttmp;
X! 
X! 	    if (On_stairs(u.ux, u.uy)) {
X! 		if (u.ux == xdnladder || u.ux == xupladder)
X  		     pline("The ladder resists your effort.");
X  		else pline("The stairs are too hard to dig in.");
X  		return(0);
X! 	    } else if (IS_THRONE(levl[u.ux][u.uy].typ)) {
X  		pline("The throne is too hard to break apart.");
X  		return (0);
X! 	    } else if (IS_ALTAR(levl[u.ux][u.uy].typ)) {
X  		pline("The altar is too hard to break apart.");
X  		return (0);
X! 	    } else if (Is_airlevel(&u.uz)) {
X  		You("cannot dig in thin air.");
X  		return(0);
X! 	    } else if (Is_waterlevel(&u.uz)) {
X  		pline("The water splashes and subsides.");
X  		return(0);
X+ 	    } else if ((ttmp = t_at(dpx, dpy)) &&
X+ 			(ttmp->ttyp == MAGIC_PORTAL || !Can_dig_down(&u.uz))) {
X+ 		pline("The %s here is too hard to dig in.",
X+ 			surface(dpx,dpy));
X+ 		return(0);
X+ 	    } else if (sobj_at(BOULDER, dpx, dpy)) {
X+ 		pline("There isn't enough room to dig here.");
X+ 		return(0);
X  	    }
X! 	} else { /* !dig_down */
X  	    if(IS_ROCK(lev->typ) && !may_dig(dpx,dpy)) {
X  		pline("This wall is too hard to dig into.");
X  		return(0);
X  	    }
X+ 	}
X  	if(Fumbling && !rn2(3)) {
X  		switch(rn2(3)) {
X  		case 0:  if(!welded(uwep)) {
X***************
X*** 659,665 ****
X  		case 1:  pline("Bang!  You hit with the broad side of %s!",
X  			       the(xname(uwep)));
X  			 break;
X! 		default: Your("swing misses its mark."); 
X  			 break;
X  		}
X  		return(0);
X--- 664,670 ----
X  		case 1:  pline("Bang!  You hit with the broad side of %s!",
X  			       the(xname(uwep)));
X  			 break;
X! 		default: Your("swing misses its mark.");
X  			 break;
X  		}
X  		return(0);
X***************
X*** 688,710 ****
X  			angry_priest();
X  		}
X  
X! 		ttmp = maketrap(dpx,dpy,PIT);
X! 		ttmp->tseen = 1;
X! 		if(Invisible) newsym(ttmp->tx,ttmp->ty);
X! 		You("dig a pit.");
X! 		u.utrap = rn1(4,2);
X! 		u.utraptype = TT_PIT;
X! 		vision_full_recalc = 1;	/* vision limits change */
X  		dig_level.dnum = 0;
X  		dig_level.dlevel = -1;
X  		return(0);
X! 	} 
X  	if(dig_effort > 100) {
X  		register const char *digtxt, *dmgtxt = (const char*) 0;
X  		register struct obj *obj;
X  		register boolean shopedge = *in_rooms(dpx, dpy, SHOPBASE);
X  
X! 		if(obj = sobj_at(STATUE, dpx, dpy)) {
X  			if (break_statue(obj))
X  				digtxt = "The statue shatters.";
X  			else
X--- 693,709 ----
X  			angry_priest();
X  		}
X  
X! 		digactualhole(PIT);	/* at u.ux, u.uy */
X  		dig_level.dnum = 0;
X  		dig_level.dlevel = -1;
X  		return(0);
X! 	}
X  	if(dig_effort > 100) {
X  		register const char *digtxt, *dmgtxt = (const char*) 0;
X  		register struct obj *obj;
X  		register boolean shopedge = *in_rooms(dpx, dpy, SHOPBASE);
X  
X! 		if ((obj = sobj_at(STATUE, dpx, dpy)) != 0) {
X  			if (break_statue(obj))
X  				digtxt = "The statue shatters.";
X  			else
X***************
X*** 712,729 ****
X  				 * printed a message and updated the screen
X  				 */
X  				digtxt = NULL;
X! 		} else if(obj = sobj_at(BOULDER, dpx, dpy)) {
X  			fracture_rock(obj);
X  			digtxt = "The boulder falls apart.";
X  		} else if(!lev->typ || lev->typ == SCORR) {
X! 		        if(Is_earthlevel(&u.uz)) {
X  			    if(uwep->blessed && !rn2(3)) {
X! 			        mkcavearea(FALSE);
X  				goto cleanup;
X! 			    } else if((uwep->cursed && !rn2(4)) || 
X! 				          (!uwep->blessed && !rn2(6))) {
X! 			        mkcavearea(TRUE);
X! 			        goto cleanup;
X  			    }
X  			}
X  			lev->typ = CORR;
X--- 711,728 ----
X  				 * printed a message and updated the screen
X  				 */
X  				digtxt = NULL;
X! 		} else if ((obj = sobj_at(BOULDER, dpx, dpy)) != 0) {
X  			fracture_rock(obj);
X  			digtxt = "The boulder falls apart.";
X  		} else if(!lev->typ || lev->typ == SCORR) {
X! 			if(Is_earthlevel(&u.uz)) {
X  			    if(uwep->blessed && !rn2(3)) {
X! 				mkcavearea(FALSE);
X  				goto cleanup;
X! 			    } else if((uwep->cursed && !rn2(4)) ||
X! 					  (!uwep->blessed && !rn2(6))) {
X! 				mkcavearea(TRUE);
X! 				goto cleanup;
X  			    }
X  			}
X  			lev->typ = CORR;
X***************
X*** 730,741 ****
X  			digtxt = "You succeed in cutting away some rock.";
X  		} else if(IS_WALL(lev->typ)) {
X  			if(shopedge) {
X! 		    	    add_damage(dpx, dpy, 10L * ACURRSTR);
X  			    dmgtxt = "damage";
X  			}
X! 		        if (level.flags.is_maze_lev) {
X  			    lev->typ = ROOM;
X! 		        } else if (level.flags.is_cavernous_lev) {
X  			    lev->typ = CORR;
X  			} else {
X  			    lev->typ = DOOR;
X--- 729,740 ----
X  			digtxt = "You succeed in cutting away some rock.";
X  		} else if(IS_WALL(lev->typ)) {
X  			if(shopedge) {
X! 			    add_damage(dpx, dpy, 10L * ACURRSTR);
X  			    dmgtxt = "damage";
X  			}
X! 			if (level.flags.is_maze_lev) {
X  			    lev->typ = ROOM;
X! 			} else if (level.flags.is_cavernous_lev) {
X  			    lev->typ = CORR;
X  			} else {
X  			    lev->typ = DOOR;
X***************
X*** 750,756 ****
X  		} else if(closed_door(dpx, dpy)) {
X  			digtxt = "You break through the door.";
X  			if(shopedge) {
X! 		    	    add_damage(dpx, dpy, 400L);
X  			    dmgtxt = "break";
X  			}
X  			if(!(lev->doormask & D_TRAPPED))
X--- 749,755 ----
X  		} else if(closed_door(dpx, dpy)) {
X  			digtxt = "You break through the door.";
X  			if(shopedge) {
X! 			    add_damage(dpx, dpy, 400L);
X  			    dmgtxt = "break";
X  			}
X  			if(!(lev->doormask & D_TRAPPED))
X***************
X*** 770,787 ****
X  		    register struct monst *mtmp;
X  
X  		    switch(rn2(2)) {
X! 		      case 0: 
X! 		        mtmp = makemon(&mons[PM_EARTH_ELEMENTAL], dpx, dpy);
X  			break;
X! 		      default: 
X! 			mtmp = makemon(&mons[PM_XORN], dpx, dpy); 
X  			break;
X  		    }
X  		    if(mtmp) pline("The debris from your digging comes to life!");
X  		}
X  		if(IS_DOOR(lev->typ) && (lev->doormask & D_TRAPPED)) {
X- 			b_trapped("door");
X  			lev->doormask = D_NODOOR;
X  			newsym(dpx, dpy);
X  		}
X  cleanup:
X--- 769,786 ----
X  		    register struct monst *mtmp;
X  
X  		    switch(rn2(2)) {
X! 		      case 0:
X! 			mtmp = makemon(&mons[PM_EARTH_ELEMENTAL], dpx, dpy);
X  			break;
X! 		      default:
X! 			mtmp = makemon(&mons[PM_XORN], dpx, dpy);
X  			break;
X  		    }
X  		    if(mtmp) pline("The debris from your digging comes to life!");
X  		}
X  		if(IS_DOOR(lev->typ) && (lev->doormask & D_TRAPPED)) {
X  			lev->doormask = D_NODOOR;
X+ 			b_trapped("door", 0);
X  			newsym(dpx, dpy);
X  		}
X  cleanup:
X***************
X*** 823,831 ****
X  int x, y;
X  {
X      register int x1, y1;
X  
X!     for(x1 = max(1,x-1); x1<=min(x+1,COLNO-1); x1++)
X! 	for(y1 = max(0,y-1); y1<=min(y+1,ROWNO-1); y1++)
X  	    if(levl[x1][y1].typ == MOAT || levl[x1][y1].typ == LAVAPOOL)
X  		return levl[x1][y1].typ;
X  
X--- 822,832 ----
X  int x, y;
X  {
X      register int x1, y1;
X+     int lo_x = max(1,x-1), hi_x = min(x+1,COLNO-1),
X+ 	lo_y = max(0,y-1), hi_y = min(y+1,ROWNO-1);
X  
X!     for (x1 = lo_x; x1 <= hi_x; x1++)
X! 	for (y1 = lo_y; y1 <= hi_y; y1++)
X  	    if(levl[x1][y1].typ == MOAT || levl[x1][y1].typ == LAVAPOOL)
X  		return levl[x1][y1].typ;
X  
X***************
X*** 832,1008 ****
X      return ROOM;
X  }
X  
X! void
X! dighole()
X  {
X! 	register struct trap *ttmp = t_at(u.ux, u.uy);
X! 	struct rm *lev = &levl[u.ux][u.uy];
X! 	struct obj *boulder_here;
X! 	boolean nohole = !Can_dig_down(&u.uz);
X! 
X! 	if(ttmp && nohole) {
X! 		pline("The floor here is too hard to dig in.");
X! 	} else {
X! 		d_level	newlevel;
X! 
X! 		if (is_pool(u.ux, u.uy) || is_lava(u.ux, u.uy)) {
X! 		    pline(
X! 		       "The %s sloshes furiously for a moment, then subsides.",
X! 			  is_lava(u.ux, u.uy) ? "lava" : "water");
X! 		    wake_nearby();	/* splashing */
X! 		    return;
X! 		}
X! 		if (lev->typ == DRAWBRIDGE_DOWN) {
X! 			destroy_drawbridge(u.ux,u.uy);
X! 			return;
X! 		} else if (boulder_here = sobj_at(BOULDER, u.ux, u.uy)) {
X! 			if (ttmp && ((ttmp->ttyp == PIT) || 
X! 			 	     (ttmp->ttyp == SPIKED_PIT))) {
X! 				pline("The boulder settles into the pit.");
X! 				ttmp->ttyp = PIT; 	 /* crush spikes */
X! 			} else {
X! 				/*
X! 				 * digging makes a hole, but the boulder
X! 				 * immediately fills it.  Final outcome:
X! 				 * no hole, no boulder.
X! 				 */
X! 				pline("KADOOM! The boulder falls in!");
X! 
X! 				/* destroy traps that emanate from the floor */
X! 				/* some of these are arbitrary -dlc */
X! 				if (ttmp && ((ttmp->ttyp == SQKY_BOARD) ||
X! 					     (ttmp->ttyp == BEAR_TRAP) ||
X! 					     (ttmp->ttyp == LANDMINE) ||
X! 					     (ttmp->ttyp == FIRE_TRAP) ||
X! 					     (ttmp->ttyp == TRAPDOOR) ||
X! 					     (ttmp->ttyp == TELEP_TRAP) ||
X! 					     (ttmp->ttyp == LEVEL_TELEP) ||
X! 					     (ttmp->ttyp == WEB) ||
X! 					     (ttmp->ttyp == MAGIC_TRAP) ||
X! 					     (ttmp->ttyp == ANTI_MAGIC))) {
X! 					deltrap(ttmp);
X! 					u.utrap = 0;
X! 					u.utraptype = 0;
X! 				}
X! 			}
X! 			delobj(boulder_here);
X! 			return;
X! 		}
X! 		if (lev->typ == DRAWBRIDGE_UP) {
X! 			/* must be floor or ice, other cases handled above */
X! 			/* dig "pit" and let fluid flow in (if possible) */
X! 			schar typ = fillholetyp(u.ux,u.uy);
X! 
X! 			if(typ == ROOM) {
X! 			    if(lev->drawbridgemask & DB_ICE)
X! 				typ = MOAT;
X! 			    else {
X! 				/*
X! 				 * We can't dig a pit here since that will
X! 				 * destroy the drawbridge.  The following is
X! 				 * a cop-out. --dlc
X! 				 */
X! 				pline("The floor here is too hard to dig in.");
X! 				return;
X! 			    }
X! 			}
X! 
X! 		    	lev->drawbridgemask &= DB_DIR;
X! 			if(typ == LAVAPOOL) lev->drawbridgemask |= DB_LAVA;
X! 		    liquid_flow:
X! 			newsym(u.ux,u.uy);
X! 
X! 			pline("As you dig a pit, it fills with %s!",
X! 			      typ == LAVAPOOL ? "lava" : "water");
X! 			if(!Levitation
X  #ifdef POLYSELF
X! 			   && !is_flyer(uasmon)
X  #endif
X- 	    					) {
X- 			    if (typ == LAVAPOOL)
X- 				(void) lava_effects();
X- 			    else if(!Wwalking)
X- 				(void) drown();
X- 			}
X- 			return;
X- 		} else if (lev->typ == ICE) {
X- 			schar typ = fillholetyp(u.ux,u.uy);
X  
X! 			if(typ == ROOM) {
X! 			    if(nohole) {
X! 				/* can't make a trapdoor, so make a pit */
X! 				ttmp = maketrap(u.ux, u.uy, PIT);
X! 			    } else
X! 				ttmp = maketrap(u.ux, u.uy, TRAPDOOR);
X! 			} else {
X! 			    lev->typ = typ;
X! 			    goto liquid_flow;
X! 			}
X! 		} else if (IS_FOUNTAIN(lev->typ)) {
X! 			dogushforth(FALSE);
X! 			dryup(u.ux,u.uy);
X! 			return;
X! #ifdef SINKS
X! 		} else if (IS_SINK(lev->typ)) {
X! 			breaksink(u.ux, u.uy);
X! 			return;
X! #endif
X! 		/* the following two are here for the wand of digging */
X! 		} else if(IS_THRONE(levl[u.ux][u.uy].typ)) {
X! 			pline("The throne is too hard to break apart.");
X! 			return;
X! 		} else if(IS_ALTAR(levl[u.ux][u.uy].typ)) {
X! 			pline("The altar is too hard to break apart.");
X! 			return;
X! 		} else if(ttmp) {
X! 			ttmp->ttyp = TRAPDOOR;
X! 		} else if(nohole) {
X! 			/* can't make a trapdoor, so make a pit */
X! 			ttmp = maketrap(u.ux, u.uy, PIT);
X! 		} else
X! 			ttmp = maketrap(u.ux, u.uy, TRAPDOOR);
X! 		ttmp->tseen = 1;
X! 		if(Invisible) newsym(ttmp->tx,ttmp->ty);
X! 		if(ttmp->ttyp == PIT) {
X! 		    You("dig a pit.");
X! 		    if(!Levitation) {
X  			u.utrap = rn1(4,2);
X  			u.utraptype = TT_PIT;
X  			vision_full_recalc = 1;	/* vision limits change */
X! 		    } else
X  			u.utrap = 0;
X! 		    return;
X! 		} 
X! 		pline("You dig a hole through the floor.");
X  
X  		/* floor objects get a chance of falling down.
X  		 * the case where the hero does NOT fall down
X  		 * is treated here.  the case where the hero
X  		 * does fall down is treated in goto_level().
X  		 */
X! 		if(OBJ_AT(u.ux, u.uy) && (u.ustuck || Levitation 
X! #ifdef WALKIES
X! 			                     || !next_to_u()
X! #endif
X! 					  ))
X! 		    impact_drop((struct obj *)0, u.ux, u.uy, 0);
X! 
X! 		if (*u.ushops)
X! 		    add_damage(u.ux, u.uy, 0L);
X! 		if(!u.ustuck && !Levitation) {			/* KAA */
X! 			if(*u.ushops)
X  				shopdig(1);
X  #ifdef WALKIES
X! 			if(!next_to_u())
X  			    You("are jerked back by your pet!");
X! 			else
X  #endif
X  			{
X  			    You("fall through...");
X  
X! 			    /* the checks above must ensure that   */
X! 			    /* the destination level exists and is */
X! 			    /* in the present dungeon.		   */
X  
X  			    newlevel.dnum = u.uz.dnum;
X  			    newlevel.dlevel = u.uz.dlevel + 1;
X--- 833,905 ----
X      return ROOM;
X  }
X  
X! static void
X! digactualhole(ttyp)
X! int ttyp;
X  {
X! 	struct obj *oldobjs, *newobjs;
X! 	register struct trap *ttmp;
X! 	boolean wont_fall = !!Levitation;
X  #ifdef POLYSELF
X! 		wont_fall |= !!is_flyer(uasmon);
X  #endif
X  
X! 	oldobjs = level.objects[u.ux][u.uy];
X! 	ttmp = maketrap(u.ux, u.uy, ttyp);
X! 	if (!ttmp) return;
X! 	newobjs = level.objects[u.ux][u.uy];
X! 	ttmp->tseen = 1;
X! 	if (Invisible) newsym(ttmp->tx,ttmp->ty);
X! 
X! 	if (ttyp == PIT) {
X! 		if (!wont_fall) {
X  			u.utrap = rn1(4,2);
X  			u.utraptype = TT_PIT;
X  			vision_full_recalc = 1;	/* vision limits change */
X! 		} else
X  			u.utrap = 0;
X! 		if (oldobjs != newobjs)	/* something unearthed */
X! 			pickup(1);	/* detects pit */
X! 		else
X! 			You("dig a pit.");
X  
X+ 	} else {	/* TRAPDOOR */
X+ 		pline("You dig a hole through the %s.", surface(u.ux,u.uy));
X+ 
X+ 		if (*u.ushops)
X+ 			add_damage(u.ux, u.uy, 0L);
X+ 
X  		/* floor objects get a chance of falling down.
X  		 * the case where the hero does NOT fall down
X  		 * is treated here.  the case where the hero
X  		 * does fall down is treated in goto_level().
X  		 */
X! 		if (u.ustuck || wont_fall) {
X! 			if (newobjs)
X! 				impact_drop((struct obj *)0, u.ux, u.uy, 0);
X! 			if (oldobjs != newobjs)
X! 				pickup(1);
X! 		} else {
X! 			if (*u.ushops)
X  				shopdig(1);
X  #ifdef WALKIES
X! 			if (!next_to_u()) {
X  			    You("are jerked back by your pet!");
X! 			    if (newobjs)
X! 				impact_drop((struct obj *)0, u.ux, u.uy, 0);
X! 			    if (oldobjs != newobjs)
X! 				pickup(1);
X! 			} else
X  #endif
X  			{
X+ 			    d_level newlevel;
X+ 
X  			    You("fall through...");
X  
X! 			    /* earlier checks must ensure that the
X! 			     * destination level exists and is in the
X! 			     * present dungeon.
X! 			     */
X  
X  			    newlevel.dnum = u.uz.dnum;
X  			    newlevel.dlevel = u.uz.dlevel + 1;
X***************
X*** 1012,1017 ****
X--- 909,1032 ----
X  	}
X  }
X  
X+ void
X+ dighole()
X+ {
X+ 	register struct trap *ttmp = t_at(u.ux, u.uy);
X+ 	struct rm *lev = &levl[u.ux][u.uy];
X+ 	struct obj *boulder_here;
X+ 	schar typ;
X+ 	boolean nohole = !Can_dig_down(&u.uz);
X+ 
X+ 	if (ttmp && (ttmp->ttyp == MAGIC_PORTAL || nohole)) {
X+ 		pline("The %s here is too hard to dig in.", surface(u.ux,u.uy));
X+ 
X+ 	} else if (is_pool(u.ux, u.uy) || is_lava(u.ux, u.uy)) {
X+ 		pline("The %s sloshes furiously for a moment, then subsides.",
X+ 			is_lava(u.ux, u.uy) ? "lava" : "water");
X+ 		wake_nearby();	/* splashing */
X+ 
X+ 	} else if (lev->typ == DRAWBRIDGE_DOWN) {
X+ 		destroy_drawbridge(u.ux,u.uy);
X+ 
X+ 	} else if ((boulder_here = sobj_at(BOULDER, u.ux, u.uy)) != 0) {
X+ 		if (ttmp && (ttmp->ttyp == PIT || ttmp->ttyp == SPIKED_PIT)) {
X+ 			pline("The boulder settles into the pit.");
X+ 			ttmp->ttyp = PIT;	 /* crush spikes */
X+ 		} else {
X+ 			/*
X+ 			 * digging makes a hole, but the boulder immediately
X+ 			 * fills it.  Final outcome:  no hole, no boulder.
X+ 			 */
X+ 			pline("KADOOM! The boulder falls in!");
X+ 
X+ 			/* destroy traps that emanate from the floor */
X+ 			/* some of these are arbitrary -dlc */
X+ 			if (ttmp && ((ttmp->ttyp == SQKY_BOARD) ||
X+ 				     (ttmp->ttyp == BEAR_TRAP) ||
X+ 				     (ttmp->ttyp == LANDMINE) ||
X+ 				     (ttmp->ttyp == FIRE_TRAP) ||
X+ 				     (ttmp->ttyp == TRAPDOOR) ||
X+ 				     (ttmp->ttyp == TELEP_TRAP) ||
X+ 				     (ttmp->ttyp == LEVEL_TELEP) ||
X+ 				     (ttmp->ttyp == WEB) ||
X+ 				     (ttmp->ttyp == MAGIC_TRAP) ||
X+ 				     (ttmp->ttyp == ANTI_MAGIC))) {
X+ 				deltrap(ttmp);
X+ 				u.utrap = 0;
X+ 				u.utraptype = 0;
X+ 			}
X+ 		}
X+ 		delobj(boulder_here);
X+ 
X+ 	} else if (lev->typ == DRAWBRIDGE_UP) {
X+ 		/* must be floor or ice, other cases handled above */
X+ 		/* dig "pit" and let fluid flow in (if possible) */
X+ 		typ = fillholetyp(u.ux,u.uy);
X+ 
X+ 		if (typ == ROOM) {
X+ 		    if (lev->drawbridgemask & DB_ICE)
X+ 			typ = MOAT;
X+ 		    else {
X+ 			/*
X+ 			 * We can't dig a pit here since that will destroy
X+ 			 * the drawbridge.  The following is a cop-out. --dlc
X+ 			 */
X+ 			pline("The floor here is too hard to dig in.");
X+ 			return;
X+ 		    }
X+ 		}
X+ 
X+ 		lev->drawbridgemask &= DB_DIR;
X+ 		if (typ == LAVAPOOL) lev->drawbridgemask |= DB_LAVA;
X+ 	    liquid_flow:
X+ 		newsym(u.ux,u.uy);
X+ 
X+ 		pline("As you dig a pit, it fills with %s!",
X+ 		      typ == LAVAPOOL ? "lava" : "water");
X+ 		if (!Levitation
X+ #ifdef POLYSELF
X+ 		   && !is_flyer(uasmon)
X+ #endif
X+ 					) {
X+ 		    if (typ == LAVAPOOL)
X+ 			(void) lava_effects();
X+ 		    else if (!Wwalking)
X+ 			(void) drown();
X+ 		}
X+ 
X+ 	} else if (IS_FOUNTAIN(lev->typ)) {
X+ 		dogushforth(FALSE);
X+ 		dryup(u.ux,u.uy);
X+ #ifdef SINKS
X+ 	} else if (IS_SINK(lev->typ)) {
X+ 		breaksink(u.ux, u.uy);
X+ #endif
X+ 	/* the following two are here for the wand of digging */
X+ 	} else if (IS_THRONE(lev->typ)) {
X+ 		pline("The throne is too hard to break apart.");
X+ 
X+ 	} else if (IS_ALTAR(lev->typ)) {
X+ 		pline("The altar is too hard to break apart.");
X+ 
X+ 	} else {
X+ 		if (lev->typ == ICE) {
X+ 			typ = fillholetyp(u.ux,u.uy);
X+ 
X+ 			if (typ != ROOM) {
X+ 			    lev->typ = typ;
X+ 			    goto liquid_flow;
X+ 			}
X+ 		}
X+ 
X+ 		/* finally we get to make a hole */
X+ 		if (nohole) {	/* can't make a trapdoor, so make a pit */
X+ 			digactualhole(PIT);
X+ 		} else
X+ 			digactualhole(TRAPDOOR);
X+ 	}
X+ }
X+ 
X  static boolean
X  wield_tool(obj)
X  struct obj *obj;
X***************
X*** 1119,1125 ****
X  				dig_pos.y = ry;
X  				assign_level(&dig_level, &u.uz);
X  				dig_effort = 0;
X! 			    	You("start %s.",
X  				   sobj_at(STATUE, rx, ry) ?
X  						"chipping the statue" :
X  				   sobj_at(BOULDER, rx, ry) ?
X--- 1134,1140 ----
X  				dig_pos.y = ry;
X  				assign_level(&dig_level, &u.uz);
X  				dig_effort = 0;
X! 				You("start %s.",
X  				   sobj_at(STATUE, rx, ry) ?
X  						"chipping the statue" :
X  				   sobj_at(BOULDER, rx, ry) ?
X***************
X*** 1141,1147 ****
X  		/* it must be air -- water checked above */
X  		You("swing your %s through thin air.", aobjnam(obj, NULL));
X  	} else if(Levitation) {
X! 		You("can't reach the floor.");
X  	} else if (is_pool(u.ux, u.uy)) {
X  		/* Monsters which swim also happen not to be able to dig */
X  		You("cannot stay underwater long enough.");
X--- 1156,1162 ----
X  		/* it must be air -- water checked above */
X  		You("swing your %s through thin air.", aobjnam(obj, NULL));
X  	} else if(Levitation) {
X! 		You("can't reach the %s.", surface(u.ux,u.uy));
X  	} else if (is_pool(u.ux, u.uy)) {
X  		/* Monsters which swim also happen not to be able to dig */
X  		You("cannot stay underwater long enough.");
X***************
X*** 1153,1163 ****
X  			dig_pos.y = u.uy;
X  			assign_level(&dig_level, &u.uz);
X  			dig_effort = 0;
X! 			You("start digging in the floor.");
X  			if(*u.ushops)
X  				shopdig(0);
X  		} else
X! 			You("continue digging in the floor.");
X  		did_dig_msg = FALSE;
X  		set_occupation(dig, "digging", 0);
X  	}
X--- 1168,1178 ----
X  			dig_pos.y = u.uy;
X  			assign_level(&dig_level, &u.uz);
X  			dig_effort = 0;
X! 			You("start digging in the %s.", surface(u.ux,u.uy));
X  			if(*u.ushops)
X  				shopdig(0);
X  		} else
X! 			You("continue digging in the %s.", surface(u.ux,u.uy));
X  		did_dig_msg = FALSE;
X  		set_occupation(dig, "digging", 0);
X  	}
X***************
X*** 1221,1227 ****
X  		return 1;
X  	}
X  	if(Underwater) {
X! 		You(Hallucination ? 
X  		    "give the fish a chance to fix their makeup." :
X  		    "reflect the murky water.");
X  		return 1;
X--- 1236,1242 ----
X  		return 1;
X  	}
X  	if(Underwater) {
X! 		You(Hallucination ?
X  		    "give the fish a chance to fix their makeup." :
X  		    "reflect the murky water.");
X  		return 1;
X***************
X*** 1228,1234 ****
X  	}
X  	if(u.dz) {
X  		if (!Blind)
X! 		    You("reflect the %s.", (u.dz > 0) ? "floor" : "ceiling");
X  		return 1;
X  	}
X  	if(!(mtmp = bhit(u.dx,u.dy,COLNO,INVIS_BEAM,
X--- 1243,1250 ----
X  	}
X  	if(u.dz) {
X  		if (!Blind)
X! 		    You("reflect the %s.",
X! 			(u.dz > 0) ? surface(u.ux,u.uy) : "ceiling");
X  		return 1;
X  	}
X  	if(!(mtmp = bhit(u.dx,u.dy,COLNO,INVIS_BEAM,
X***************
X*** 1271,1287 ****
X  	} else if(!mtmp->mcan && mtmp->data == &mons[PM_UMBER_HULK]) {
X  		if (vis)
X  			pline ("%s confuses itself!", Monnam(mtmp));
X! 	    	mtmp->mconf = 1;
X  	} else if(!mtmp->mcan && !mtmp->minvis && (mlet == S_NYMPH
X! 			             || mtmp->data==&mons[PM_SUCCUBUS])) {
X  		if (vis) {
X! 	    	    pline ("%s admires herself in your mirror.", Monnam(mtmp));
X! 	    	    pline ("She takes it!");
X  		} else pline ("It steals your mirror!");
X  		setnotworn(obj); /* in case mirror was wielded */
X! 	    	freeinv(obj);
X! 	    	mpickobj(mtmp,obj);
X! 	    	rloc(mtmp);
X  	} else if (mlet != S_UNICORN && !humanoid(mtmp->data) &&
X  			(!mtmp->minvis || perceives(mtmp->data)) && rn2(5)) {
X  		if (vis)
X--- 1287,1303 ----
X  	} else if(!mtmp->mcan && mtmp->data == &mons[PM_UMBER_HULK]) {
X  		if (vis)
X  			pline ("%s confuses itself!", Monnam(mtmp));
X! 		mtmp->mconf = 1;
X  	} else if(!mtmp->mcan && !mtmp->minvis && (mlet == S_NYMPH
X! 				     || mtmp->data==&mons[PM_SUCCUBUS])) {
X  		if (vis) {
X! 		    pline ("%s admires herself in your mirror.", Monnam(mtmp));
X! 		    pline ("She takes it!");
X  		} else pline ("It steals your mirror!");
X  		setnotworn(obj); /* in case mirror was wielded */
X! 		freeinv(obj);
X! 		mpickobj(mtmp,obj);
X! 		rloc(mtmp);
X  	} else if (mlet != S_UNICORN && !humanoid(mtmp->data) &&
X  			(!mtmp->minvis || perceives(mtmp->data)) && rn2(5)) {
X  		if (vis)
X***************
X*** 1316,1324 ****
X  	    pline("But the sound is muffled.");
X  	    return;
X  	}
X!         if(obj->otyp == BELL) {
X  	    if(u.uswallow) {
X! 	        pline(nothing_happens);
X  		return;
X  	    }
X  #ifdef	AMIGA
X--- 1332,1340 ----
X  	    pline("But the sound is muffled.");
X  	    return;
X  	}
X! 	if(obj->otyp == BELL) {
X  	    if(u.uswallow) {
X! 		pline(nothing_happens);
X  		return;
X  	    }
X  #ifdef	AMIGA
X***************
X*** 1325,1333 ****
X  	    amii_speaker( obj, "awdwgwewdhehaqdqfwgw", AMII_MUFFLED_VOLUME );
X  #endif
X  	    if(obj->cursed && !rn2(3)) {
X! 	        register struct monst *mtmp;
X  
X! 		if(mtmp = makemon(&mons[PM_WOOD_NYMPH], u.ux, u.uy))
X  		   You("summon %s!", a_monnam(mtmp));
X  	    }
X  	    wake_nearby();
X--- 1341,1349 ----
X  	    amii_speaker( obj, "awdwgwewdhehaqdqfwgw", AMII_MUFFLED_VOLUME );
X  #endif
X  	    if(obj->cursed && !rn2(3)) {
X! 		register struct monst *mtmp;
X  
X! 		if ((mtmp = makemon(&mons[PM_WOOD_NYMPH], u.ux, u.uy)) != 0)
X  		   You("summon %s!", a_monnam(mtmp));
X  	    }
X  	    wake_nearby();
X***************
X*** 1339,1345 ****
X  	    pline(nothing_happens);
X  	    return;
X  	}
X!         if(obj->cursed) {
X  	    coord mm;
X  	    mm.x = u.ux;
X  	    mm.y = u.uy;
X--- 1355,1361 ----
X  	    pline(nothing_happens);
X  	    return;
X  	}
X! 	if(obj->cursed) {
X  	    coord mm;
X  	    mm.x = u.ux;
X  	    mm.y = u.uy;
X***************
X*** 1349,1356 ****
X  	    if(obj->spe > 0) obj->spe--;
X  	    return;
X  	}
X! 	if(invocation_pos(u.ux, u.uy) && 
X! 	             !On_stairs(u.ux, u.uy) && !u.uswallow) {
X  	    pline("%s issues an unsettling shrill sound...", The(xname(obj)));
X  #ifdef	AMIGA
X  	    amii_speaker( obj, "aefeaefeaefeaefeaefe", AMII_LOUDER_VOLUME );
X--- 1365,1372 ----
X  	    if(obj->spe > 0) obj->spe--;
X  	    return;
X  	}
X! 	if(invocation_pos(u.ux, u.uy) &&
X! 		     !On_stairs(u.ux, u.uy) && !u.uswallow) {
X  	    pline("%s issues an unsettling shrill sound...", The(xname(obj)));
X  #ifdef	AMIGA
X  	    amii_speaker( obj, "aefeaefeaefeaefeaefe", AMII_LOUDER_VOLUME );
X***************
X*** 1363,1369 ****
X  	}
X  	if(obj->blessed) {
X  	    if(obj->spe > 0) {
X! 	        register int cnt = openit();
X  		if(cnt == -1) return; /* was swallowed */
X  #ifdef	AMIGA
X  		amii_speaker( obj, "awawawDwEwCw", AMII_SOFT_VOLUME );
X--- 1379,1385 ----
X  	}
X  	if(obj->blessed) {
X  	    if(obj->spe > 0) {
X! 		register int cnt = openit();
X  		if(cnt == -1) return; /* was swallowed */
X  #ifdef	AMIGA
X  		amii_speaker( obj, "awawawDwEwCw", AMII_SOFT_VOLUME );
X***************
X*** 1371,1378 ****
X  		switch(cnt) {
X  		  case 0:  pline(nothing_happens); break;
X  		  case 1:  pline("Something opens..."); break;
X! 	          default: pline("Things open around you..."); break;
X! 	        }
X  		if(cnt > 0) obj->known = 1;
X  		obj->spe--;
X  	    } else pline(nothing_happens);
X--- 1387,1394 ----
X  		switch(cnt) {
X  		  case 0:  pline(nothing_happens); break;
X  		  case 1:  pline("Something opens..."); break;
X! 		  default: pline("Things open around you..."); break;
X! 		}
X  		if(cnt > 0) obj->known = 1;
X  		obj->spe--;
X  	    } else pline(nothing_happens);
X***************
X*** 1381,1395 ****
X  	    amii_speaker( obj, "AeFeaeFeAefegW", AMII_OKAY_VOLUME );
X  #endif
X  	    if(obj->spe > 0) {
X! 	        register int cnt = findit();
X  		if(cnt == 0) pline(nothing_happens);
X  		else obj->known = 1;
X! 	        obj->spe--;
X  	    } else {
X! 	        if(!rn2(3)) goto cursed_bell;
X  		else pline(nothing_happens);
X  	    }
X!         }
X  }
X  
X  static void
X--- 1397,1411 ----
X  	    amii_speaker( obj, "AeFeaeFeAefegW", AMII_OKAY_VOLUME );
X  #endif
X  	    if(obj->spe > 0) {
X! 		register int cnt = findit();
X  		if(cnt == 0) pline(nothing_happens);
X  		else obj->known = 1;
X! 		obj->spe--;
X  	    } else {
X! 		if(!rn2(3)) goto cursed_bell;
X  		else pline(nothing_happens);
X  	    }
X! 	}
X  }
X  
X  static void
X***************
X*** 1411,1425 ****
X  		return;
X  	}
X  	if(u.uswallow || obj->cursed) {
X! 		pline("The candle%s flicker%s for a moment, then die%s.", 
X  			obj->spe > 1 ? "s" : "",
X  			obj->spe > 1 ? "" : "s",
X  			obj->spe > 1 ? "" : "s");
X! 	        return;
X! 	} 
X!         if(obj->spe < 7) {
X! 	        pline("There %s only %d candle%s in %s.",
X! 		       obj->spe == 1 ? "is" : "are", 
X  		       obj->spe,
X  		       obj->spe > 1 ? "s" : "",
X  		       the(xname(obj)));
X--- 1427,1441 ----
X  		return;
X  	}
X  	if(u.uswallow || obj->cursed) {
X! 		pline("The candle%s flicker%s for a moment, then die%s.",
X  			obj->spe > 1 ? "s" : "",
X  			obj->spe > 1 ? "" : "s",
X  			obj->spe > 1 ? "" : "s");
X! 		return;
X! 	}
X! 	if(obj->spe < 7) {
X! 		pline("There %s only %d candle%s in %s.",
X! 		       obj->spe == 1 ? "is" : "are",
X  		       obj->spe,
X  		       obj->spe > 1 ? "s" : "",
X  		       the(xname(obj)));
X***************
X*** 1435,1441 ****
X  			(obj->spe > 1 ? "s are" : " is"));
X  		obj->age /= 2;
X  	} else {
X! 	        if(obj->spe == 7) {
X  		    if (Blind)
X  		      pline("%s radiates a strange warmth!", The(xname(obj)));
X  		    else
X--- 1451,1457 ----
X  			(obj->spe > 1 ? "s are" : " is"));
X  		obj->age /= 2;
X  	} else {
X! 		if(obj->spe == 7) {
X  		    if (Blind)
X  		      pline("%s radiates a strange warmth!", The(xname(obj)));
X  		    else
X***************
X*** 1456,1467 ****
X  	char qbuf[QBUFSZ];
X  
X  	if(obj->lamplit) {
X! 	        use_lamp(obj);
X  		return;
X  	}
X  
X  	if(u.uswallow) {
X! 	        You("don't have enough elbow-room to maneuver.");
X  		return;
X  	}
X  	if(Underwater) {
X--- 1472,1483 ----
X  	char qbuf[QBUFSZ];
X  
X  	if(obj->lamplit) {
X! 		use_lamp(obj);
X  		return;
X  	}
X  
X  	if(u.uswallow) {
X! 		You("don't have enough elbow-room to maneuver.");
X  		return;
X  	}
X  	if(Underwater) {
X***************
X*** 1487,1502 ****
X  	} else {
X  		register long needed = 7L - (long)otmp->spe;
X  
X! 		You("attach %ld%s candle%s to %s.", 
X  			obj->quan >= needed ? needed : obj->quan,
X  			!otmp->spe ? "" : " more",
X  			(needed > 1L && obj->quan > 1L) ? "s" : "",
X  			the(xname(otmp)));
X! 		if(otmp->lamplit) 
X  			pline("The new candle%s magically ignite%s!",
X  			    (needed > 1L && obj->quan > 1L) ? "s" : "",
X  			    (needed > 1L && obj->quan > 1L) ? "" : "s");
X! 		if(obj->unpaid) 
X  			verbalize("You burn %s, you bought %s!",
X  			    (needed > 1L && obj->quan > 1L) ? "them" : "it",
X  			    (needed > 1L && obj->quan > 1L) ? "them" : "it");
X--- 1503,1518 ----
X  	} else {
X  		register long needed = 7L - (long)otmp->spe;
X  
X! 		You("attach %ld%s candle%s to %s.",
X  			obj->quan >= needed ? needed : obj->quan,
X  			!otmp->spe ? "" : " more",
X  			(needed > 1L && obj->quan > 1L) ? "s" : "",
X  			the(xname(otmp)));
X! 		if(otmp->lamplit)
X  			pline("The new candle%s magically ignite%s!",
X  			    (needed > 1L && obj->quan > 1L) ? "s" : "",
X  			    (needed > 1L && obj->quan > 1L) ? "" : "s");
X! 		if(obj->unpaid)
X  			verbalize("You burn %s, you bought %s!",
X  			    (needed > 1L && obj->quan > 1L) ? "them" : "it",
X  			    (needed > 1L && obj->quan > 1L) ? "them" : "it");
X***************
X*** 1560,1566 ****
X  			obj->lamplit = 0;
X  			check_lamps();
X  			return(TRUE);
X! 		} 
X  
X  		if(snuff_candle(obj)) return(TRUE);
X  	}
X--- 1576,1582 ----
X  			obj->lamplit = 0;
X  			check_lamps();
X  			return(TRUE);
X! 		}
X  
X  		if(snuff_candle(obj)) return(TRUE);
X  	}
X***************
X*** 1593,1599 ****
X  		return;
X  	}
X  	if(obj->cursed && !rn2(2))
X! 		pline("%s flicker%s for a moment, then die%s.", 
X  		       The(xname(obj)),
X  		       obj->quan > 1L ? "" : "s",
X  		       obj->quan > 1L ? "" : "s");
X--- 1609,1615 ----
X  		return;
X  	}
X  	if(obj->cursed && !rn2(2))
X! 		pline("%s flicker%s for a moment, then die%s.",
X  		       The(xname(obj)),
X  		       obj->quan > 1L ? "" : "s",
X  		       obj->quan > 1L ? "" : "s");
X***************
X*** 1603,1611 ****
X  		    Your("lamp is now on.");
X  		else
X  		    pline("%s%s flame%s burn%s%s", The(xname(obj)),
X! 		        obj->quan > 1L ? "'" : "'s",
X! 		        obj->quan > 1L ? "s" : "",
X! 		        obj->quan > 1L ? "" : "s",
X  			Blind ? "." : " brightly!");
X  		obj->lamplit = 1;
X  		check_lamps();
X--- 1619,1627 ----
X  		    Your("lamp is now on.");
X  		else
X  		    pline("%s%s flame%s burn%s%s", The(xname(obj)),
X! 			obj->quan > 1L ? "'" : "'s",
X! 			obj->quan > 1L ? "s" : "",
X! 			obj->quan > 1L ? "" : "s",
X  			Blind ? "." : " brightly!");
X  		obj->lamplit = 1;
X  		check_lamps();
X***************
X*** 1695,1701 ****
X  	cc.x = u.ux;
X  	cc.y = u.uy;
X  	getpos(&cc, TRUE, "the desired position");
X!         if(cc.x == -10) return 0; /* user pressed esc */
X  	if (!(Jumping & ~INTRINSIC) && distu(cc.x, cc.y) != 5) {
X  		pline("Illegal move!");
X  		return 0;
X--- 1711,1717 ----
X  	cc.x = u.ux;
X  	cc.y = u.uy;
X  	getpos(&cc, TRUE, "the desired position");
X! 	if(cc.x == -10) return 0; /* user pressed esc */
X  	if (!(Jumping & ~INTRINSIC) && distu(cc.x, cc.y) != 5) {
X  		pline("Illegal move!");
X  		return 0;
X***************
X*** 1705,1711 ****
X  	} else if (!cansee(cc.x, cc.y)) {
X  		You("cannot see where to land!");
X  		return 0;
X! 	} else if (mtmp = m_at(cc.x, cc.y)) {
X  		You("cannot trample %s!", mon_nam(mtmp));
X  		return 0;
X  	} else if (!isok(cc.x, cc.y) ||
X--- 1721,1727 ----
X  	} else if (!cansee(cc.x, cc.y)) {
X  		You("cannot see where to land!");
X  		return 0;
X! 	} else if ((mtmp = m_at(cc.x, cc.y)) != 0) {
X  		You("cannot trample %s!", mon_nam(mtmp));
X  		return 0;
X  	} else if (!isok(cc.x, cc.y) ||
X***************
X*** 1763,1769 ****
X  	/* This takes only 1 move.  If this is to be changed to take many
X  	 * moves, we've got to deal with decaying corpses...
X  	 */
X! 	if (!(corpse = floorfood("can", 1))) return;
X  	if (corpse->oeaten) {
X  		You("cannot tin something which is partly eaten.");
X  		return;
X--- 1779,1785 ----
X  	/* This takes only 1 move.  If this is to be changed to take many
X  	 * moves, we've got to deal with decaying corpses...
X  	 */
X! 	if (!(corpse = floorfood("tin", 1))) return;
X  	if (corpse->oeaten) {
X  		You("cannot tin something which is partly eaten.");
X  		return;
X***************
X*** 1794,1800 ****
X  		pline("That's too insubstantial to tin.");
X  		return;
X  	}
X! 	if(can = mksobj(TIN, FALSE, FALSE)) {
X  	    can->corpsenm = corpse->corpsenm;
X  	    can->cursed = obj->cursed;
X  	    can->blessed = obj->blessed;
X--- 1810,1816 ----
X  		pline("That's too insubstantial to tin.");
X  		return;
X  	}
X! 	if ((can = mksobj(TIN, FALSE, FALSE)) != 0) {
X  	    can->corpsenm = corpse->corpsenm;
X  	    can->cursed = obj->cursed;
X  	    can->blessed = obj->blessed;
X***************
X*** 1802,1819 ****
X  	    can->known = 1;
X  	    can->spe = -1;  /* Mark tinned tins. No spinach allowed... */
X  	    if (carried(corpse)) {
X! 	        if(corpse->unpaid) {
X  		    verbalize("You tin it, you bought it!");
X  		    bill_dummy_object(corpse);
X  		}
X! 	        useup(corpse);
X  	    } else {
X! 	        if(costly_spot(corpse->ox, corpse->oy) &&
X  		      !corpse->no_charge) {
X  		    verbalize("You tin it, you bought it!");
X  		    bill_dummy_object(corpse);
X  		}
X! 	        useupf(corpse);
X  	    }
X  	    can = hold_another_object(can, "You make, but cannot pick up, %s.",
X  				      doname(can), (const char *)0);
X--- 1818,1835 ----
X  	    can->known = 1;
X  	    can->spe = -1;  /* Mark tinned tins. No spinach allowed... */
X  	    if (carried(corpse)) {
X! 		if(corpse->unpaid) {
X  		    verbalize("You tin it, you bought it!");
X  		    bill_dummy_object(corpse);
X  		}
X! 		useup(corpse);
X  	    } else {
X! 		if(costly_spot(corpse->ox, corpse->oy) &&
X  		      !corpse->no_charge) {
X  		    verbalize("You tin it, you bought it!");
X  		    bill_dummy_object(corpse);
X  		}
X! 		useupf(corpse);
X  	    }
X  	    can = hold_another_object(can, "You make, but cannot pick up, %s.",
X  				      doname(can), (const char *)0);
X***************
X*** 1830,1836 ****
X  	if (obj && obj->cursed) {
X  		switch (rn2(6)) {
X  		    static char buf[BUFSZ];
X! 		    case 0: make_sick(Sick ? 1L : (long) rn1(20, 20), TRUE);
X  			    Strcpy(buf, xname(obj));
X  			    u.usick_cause = (const char *)buf;
X  			    break;
X--- 1846,1852 ----
X  	if (obj && obj->cursed) {
X  		switch (rn2(6)) {
X  		    static char buf[BUFSZ];
X! 		    case 0: make_sick(Sick ? Sick/4 + 1L : (long) rn1(ACURR(A_CON), 20), TRUE);
X  			    Strcpy(buf, xname(obj));
X  			    u.usick_cause = (const char *)buf;
X  			    break;
X***************
X*** 1851,1857 ****
X  		}
X  		return;
X  	}
X! 		
X  	if (Sick) {
X  		make_sick(0L, TRUE);
X  		did_something++;
X--- 1867,1873 ----
X  		}
X  		return;
X  	}
X! 
X  	if (Sick) {
X  		make_sick(0L, TRUE);
X  		did_something++;
X***************
X*** 1884,1890 ****
X  			/* don't recover strength lost while hungry */
X  			if ((blessed || j==i) &&
X  				((j != A_STR || u.uhs < WEAK)
X! 				? (ABASE(i) < AMAX(i))
X  				: (ABASE(A_STR) < (AMAX(A_STR) - 1)))) {
X  				did_something++;
X  				/* They may have to use it several times... */
X--- 1900,1906 ----
X  			/* don't recover strength lost while hungry */
X  			if ((blessed || j==i) &&
X  				((j != A_STR || u.uhs < WEAK)
X! 				? (ABASE(j) < AMAX(j))
X  				: (ABASE(A_STR) < (AMAX(A_STR) - 1)))) {
X  				did_something++;
X  				/* They may have to use it several times... */
X***************
X*** 1892,1898 ****
X  					did_stat++;
X  					pline("This makes you feel good!");
X  				}
X! 				ABASE(i)++;
X  				flags.botl = 1;
X  			}
X  		}
X--- 1908,1914 ----
X  					did_stat++;
X  					pline("This makes you feel good!");
X  				}
X! 				ABASE(j)++;
X  				flags.botl = 1;
X  			}
X  		}
X***************
X*** 1954,1959 ****
X--- 1970,1976 ----
X  	if (obj->spe > 0) {
X  		if ((obj->cursed || Fumbling) && !rn2(2)) {
X  			obj->spe--;
X+ 			check_unpaid(obj);
X  			dropx(obj);
X  			pline("%s slips from your %s.", The(xname(obj)),
X  			      makeplural(body_part(FINGER)));
X***************
X*** 1962,1967 ****
X--- 1979,1985 ----
X  		otmp = getobj(lubricables, "grease");
X  		if (!otmp) return;
X  		obj->spe--;
X+ 		check_unpaid(obj);
X  		if (otmp != &zeroobj) {
X  			You("cover your %s with a thick layer of grease.",
X  			    xname(otmp));
X***************
X*** 1994,2000 ****
X  		if (obj == ublindf) {
X  		    if(cursed(obj)) break;
X  		    else Blindf_off(obj);
X! 		} 
X  		else if (!ublindf) Blindf_on(obj);
X  		else You("are already %s.", ublindf->otyp == TOWEL ?
X  			 "covered by a towel" : "wearing a blindfold");
X--- 2012,2018 ----
X  		if (obj == ublindf) {
X  		    if(cursed(obj)) break;
X  		    else Blindf_off(obj);
X! 		}
X  		else if (!ublindf) Blindf_on(obj);
X  		else You("are already %s.", ublindf->otyp == TOWEL ?
X  			 "covered by a towel" : "wearing a blindfold");
X***************
X*** 2005,2011 ****
X  	case SACK:
X  	case BAG_OF_HOLDING:
X  	case OILSKIN_SACK:
X! 		res = use_container(obj, 1); 
X  		break;
X  	case BAG_OF_TRICKS:
X  		if(obj->spe > 0) {
X--- 2023,2029 ----
X  	case SACK:
X  	case BAG_OF_HOLDING:
X  	case OILSKIN_SACK:
X! 		res = use_container(obj, 1);
X  		break;
X  	case BAG_OF_TRICKS:
X  		if(obj->spe > 0) {
X***************
X*** 2012,2017 ****
X--- 2030,2036 ----
X  			register int cnt = 1;
X  
X  			obj->spe--;
X+ 			check_unpaid(obj);
X  			if(!rn2(23)) cnt += rn2(7) + 1;
X  			while(cnt--)
X  			    (void) makemon((struct permonst *) 0, u.ux, u.uy);
X***************
X*** 2055,2061 ****
X  		break;
X  	case BELL:
X  	case BELL_OF_OPENING:
X! 	        use_bell(obj);
X  		break;
X  	case CANDELABRUM_OF_INVOCATION:
X  		use_candelabrum(obj);
X--- 2074,2080 ----
X  		break;
X  	case BELL:
X  	case BELL_OF_OPENING:
X! 		use_bell(obj);
X  		break;
X  	case CANDELABRUM_OF_INVOCATION:
X  		use_candelabrum(obj);
X***************
X*** 2071,2081 ****
X  		break;
X  #ifdef TOURIST
X  	case EXPENSIVE_CAMERA:
X! 		res = use_camera(obj); 
X  		break;
X  #endif
X  	case TOWEL:
X! 		res = use_towel(obj); 
X  		break;
X  	case CRYSTAL_BALL:
X  		use_crystal_ball(obj);
X--- 2090,2100 ----
X  		break;
X  #ifdef TOURIST
X  	case EXPENSIVE_CAMERA:
X! 		res = use_camera(obj);
X  		break;
X  #endif
X  	case TOWEL:
X! 		res = use_towel(obj);
X  		break;
X  	case CRYSTAL_BALL:
X  		use_crystal_ball(obj);
X***************
X*** 2119,2124 ****
X--- 2138,2144 ----
X  		    const char *what;
X  
X  		    obj->spe--;
X+ 		    check_unpaid(obj);
X  		    if (!rn2(13)) {
X  			otmp = mkobj(POTION_CLASS, FALSE);
X  			if (objects[otmp->otyp].oc_magic) do {
X*** /tmp/da10802	Tue Jun  1 16:12:38 1993
X--- src/artifact.c	Fri May 28 11:40:24 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)artifact.c	3.1	93/02/17	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)artifact.c	3.1	93/05/25	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 7,13 ****
X  #ifdef OVLB
X  #include "artilist.h"
X  #else
X! STATIC_DCL const struct artifact artilist[];
X  #endif
X  /*
X   * Note:  both artilist[] and artiexist[] have a dummy element #0,
X--- 7,13 ----
X  #ifdef OVLB
X  #include "artilist.h"
X  #else
X! STATIC_DCL struct artifact artilist[];
X  #endif
X  /*
X   * Note:  both artilist[] and artiexist[] have a dummy element #0,
X***************
X*** 33,45 ****
X--- 33,61 ----
X  /* flags including which artifacts have already been created */
X  static boolean artiexist[1+NROFARTIFACTS+1];
X  
X+ static void NDECL(hack_artifacts);
X  static boolean FDECL(attacks, (int,struct obj *));
X  
X+ /* handle some special cases; must be called after u_init() */
X+ static void
X+ hack_artifacts()
X+ {
X+ 	/* Excalibur can be used by any lawful character, not just knights */
X+ 	if (pl_character[0] != 'K')
X+ 	    artilist[ART_EXCALIBUR].class = '\0';
X+ #ifdef MULDGN
X+ 	/* Mitre of Holiness has same alignment as priest starts out with */
X+ 	if (pl_character[0] == 'P')
X+ 	    artilist[ART_MITRE_OF_HOLINESS].alignment = u.ualignbase[1];
X+ #endif
X+ }
X+ 
X  /* zero out the artifact existence list */
X  void
X  init_artifacts()
X  {
X  	(void) memset((genericptr_t) artiexist, 0, sizeof artiexist);
X+ 	hack_artifacts();
X  }
X  
X  void
X***************
X*** 54,59 ****
X--- 70,76 ----
X  int fd;
X  {
X  	mread(fd, (genericptr_t) artiexist, sizeof artiexist);
X+ 	hack_artifacts();	/* redo non-saved special cases */
X  }
X  
X  const char *
X***************
X*** 202,209 ****
X  artifact_unexist(otmp)
X      register struct obj *otmp;
X  {
X!     if (otmp->oartifact && artiexist[otmp->oartifact])
X! 	artiexist[otmp->oartifact] = 0;
X      else
X  	impossible("Destroying non-existing artifact?!");
X  }
X--- 219,226 ----
X  artifact_unexist(otmp)
X      register struct obj *otmp;
X  {
X!     if (otmp->oartifact && artiexist[(int)otmp->oartifact])
X! 	artiexist[(int)otmp->oartifact] = 0;
X      else
X  	impossible("Destroying non-existing artifact?!");
X  }
X***************
X*** 404,415 ****
X  	((oart->alignment !=
X  	  (yours ? u.ualign.type : sgn(mon->data->maligntyp))) ||
X  	 (yours && u.ualign.record < 0));
X-     /*
X-      * hack: Excalibur allows all lawfuls to touch it, but "class" is
X-      * set to 'K' to allow Knights to get it via sacrifice.  This requires an
X-      * additional artifact field to fix, or some similar treatment. -dlc
X-      */
X-     if (obj->oartifact == ART_EXCALIBUR && !badalign) badclass = FALSE;
X  
X      if(((badclass || badalign) && (oart->spfx & SPFX_INTEL)) ||
X         (badalign && (!yours || !rn2(4))))  {
X--- 421,426 ----
X***************
X*** 762,772 ****
X  	}
X  	/* end of Magicbane code */
X  
X! 	/* We really want "on a natural 19 or 20" but Nethack does it in */
X  	/* reverse from AD&D. */
X  	if (spec_ability(otmp, SPFX_BEHEAD)) {
X  #ifdef MULDGN
X! 	    if (otmp->oartifact == ART_TSURUGI_OF_MURAMASA && dieroll <= 2) {
X  		/* not really beheading, but so close, why add another SPFX */
X  		if (youattack && u.uswallow && mdef == u.ustuck) {
X  		    You("slice %s wide open!", mon_nam(mdef));
X--- 773,783 ----
X  	}
X  	/* end of Magicbane code */
X  
X! 	/* We really want "on a natural 20" but Nethack does it in */
X  	/* reverse from AD&D. */
X  	if (spec_ability(otmp, SPFX_BEHEAD)) {
X  #ifdef MULDGN
X! 	    if (otmp->oartifact == ART_TSURUGI_OF_MURAMASA && dieroll == 1) {
X  		/* not really beheading, but so close, why add another SPFX */
X  		if (youattack && u.uswallow && mdef == u.ustuck) {
X  		    You("slice %s wide open!", mon_nam(mdef));
X***************
X*** 789,795 ****
X  				return TRUE;
X  			}
X  			*dmgptr = mdef->mhp;
X! 			pline("The razorsharp blade cuts %s in half!",
X  			      mon_nam(mdef));
X  			otmp->dknown = TRUE;
X  			return TRUE;
X--- 800,806 ----
X  				return TRUE;
X  			}
X  			*dmgptr = mdef->mhp;
X! 			pline("The razor-sharp blade cuts %s in half!",
X  			      mon_nam(mdef));
X  			otmp->dknown = TRUE;
X  			return TRUE;
X***************
X*** 802,816 ****
X  				return TRUE;
X  			}
X  #endif
X! 			*dmgptr = u.uhp;
X! 			pline("The razorsharp blade cuts you in half!");
X  			otmp->dknown = TRUE;
X  			return TRUE;
X  		}
X! 	    } else 
X  #endif /* MULDGN */
X! 	        if (otmp->oartifact == ART_VORPAL_BLADE &&
X! 			(dieroll <= 2 || mdef->data == &mons[PM_JABBERWOCK])) {
X  		if (youattack && u.uswallow && mdef == u.ustuck)
X  			return FALSE;
X  		if (!youdefend) {
X--- 813,838 ----
X  				return TRUE;
X  			}
X  #endif
X! 			/* Players with negative AC's take less damage instead
X! 			 * of just not getting hit.  We must add a large enough
X! 			 * value to the damage so that this reduction in
X! 			 * damage does not prevent death.
X! 			 */
X! 			*dmgptr = u.uhp + 1234;
X! 			pline("The razor-sharp blade cuts you in half!");
X  			otmp->dknown = TRUE;
X  			return TRUE;
X  		}
X! 	    } else
X  #endif /* MULDGN */
X! 	    if (otmp->oartifact == ART_VORPAL_BLADE &&
X! 			(dieroll == 1 || mdef->data == &mons[PM_JABBERWOCK])) {
X! 
X! 		static const char *behead_msg[2] = {
X! 		     "%s beheads %s!",
X! 		     "%s decapitates %s!"
X! 		};
X! 
X  		if (youattack && u.uswallow && mdef == u.ustuck)
X  			return FALSE;
X  		if (!youdefend) {
X***************
X*** 824,833 ****
X  				*dmgptr = 0;
X  				return (youattack || vis);
X  			}
X  			*dmgptr = mdef->mhp;
X! 			pline("%s cuts off %s head!",
X! 					artilist[ART_VORPAL_BLADE].name,
X! 					s_suffix(mon_nam(mdef)));
X  			otmp->dknown = TRUE;
X  			return TRUE;
X  		} else {
X--- 846,861 ----
X  				*dmgptr = 0;
X  				return (youattack || vis);
X  			}
X+ 			if (noncorporeal(mdef->data) || amorphous(mdef->data)) {
X+ 				pline("%s slices through %s neck.",
X+ 				      artilist[ART_VORPAL_BLADE].name,
X+ 				      s_suffix(mon_nam(mdef)));
X+ 				return (youattack || vis);
X+ 			}
X  			*dmgptr = mdef->mhp;
X! 			pline(behead_msg[rn2(SIZE(behead_msg))],
X! 			      artilist[ART_VORPAL_BLADE].name,
X! 			      mon_nam(mdef));
X  			otmp->dknown = TRUE;
X  			return TRUE;
X  		} else {
X***************
X*** 838,847 ****
X  				*dmgptr = 0;
X  				return TRUE;
X  			}
X  #endif
X! 			*dmgptr = u.uhp;
X! 			pline("%s cuts off your head!",
X! 					artilist[ART_VORPAL_BLADE].name);
X  			otmp->dknown = TRUE;
X  			/* Should amulets fall off? */
X  			return TRUE;
X--- 866,880 ----
X  				*dmgptr = 0;
X  				return TRUE;
X  			}
X+ 			if (noncorporeal(uasmon) || amorphous(uasmon)) {
X+ 				pline("%s slices through your neck.",
X+ 				      artilist[ART_VORPAL_BLADE].name);
X+ 				return TRUE;
X+ 			}
X  #endif
X! 			*dmgptr = u.uhp + 1234;
X! 			pline(behead_msg[rn2(SIZE(behead_msg))],
X! 			      artilist[ART_VORPAL_BLADE].name, "you");
X  			otmp->dknown = TRUE;
X  			/* Should amulets fall off? */
X  			return TRUE;
X***************
X*** 1044,1053 ****
X  	  }
X  	}
X      } else {
X! 	boolean on;
X! 	unsigned long cprop;
X! 	cprop = u.uprops[oart->inv_prop].p_flgs ^= W_ARTI;
X! 	on = (cprop & W_ARTI) != 0; /* did we just turn on the invoked prop? */
X  
X  	if(on && obj->age > monstermoves) {
X  	    /* the artifact is tired :-) */
X--- 1077,1084 ----
X  	  }
X  	}
X      } else {
X! 	long cprop = (u.uprops[oart->inv_prop].p_flgs ^= W_ARTI);
X! 	boolean on = (cprop & W_ARTI) != 0; /* true if invoked prop just set */
X  
X  	if(on && obj->age > monstermoves) {
X  	    /* the artifact is tired :-) */
END_OF_FILE
if test 55493 -ne `wc -c <'patches02a'`; then
    echo shar: \"'patches02a'\" unpacked with wrong size!
fi
# end of 'patches02a'
if test -f 'sys/amiga/amitty.c' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'sys/amiga/amitty.c'\" to \"'sys/amiga/amitty.c.orig'\"
  mv -f 'sys/amiga/amitty.c' 'sys/amiga/amitty.c.orig'
fi
echo shar: Extracting \"'sys/amiga/amitty.c'\" \(1512 characters\)
sed "s/^X//" >'sys/amiga/amitty.c' <<'END_OF_FILE'
X/*    SCCS Id: @(#)amitty.c     3.1    93/01/08
X/*    Copyright (c) Kenneth Lorber, Bethesda, Maryland 1993	  */
X/* NetHack may be freely redistributed.  See license for details. */
X
X/* TTY-specific code for the Amiga */
X
X/* Still to do:
X * add command line switches for enough control to use as BBS door
X * add realy termcap handling - currently requires ANSI_DEFAULT
X * fix tids everywhere
X * fix commented out code that tries (and fails) to avoid problems with
X *  typeahead - we may need to resort to basic packet I/O. Sigh.
X * prototype and related cleanup
X */
X
X#include "hack.h"
X#include "termcap.h"
X#include <stdio.h>
X
Xvoid NDECL( get_scr_size );
Xvoid NDECL( tty_change_color );
Xchar *NDECL( tty_get_color_string );
X
X#ifdef TTY_GRAPHICS
Xvoid settty(const char *s){
X	end_screen();
X	if(s)raw_print(s);
X	flags.cbreak=ON;	/* this is too easy: probably wrong */
X#if 0 /* should be version>=36 */
X	if(IsInteractive(Input())){
X		SetMode(Input(),0);	/* con mode */
X	}
X#endif
X}
Xvoid gettty(){
X#if 0 /* should be VERSION >=36 */
X	if(IsInteractive(Input())){
X		SetMode(Input(),1);	/* raw mode */
X	}
X#endif
X}
Xvoid setftty(){
X	flags.cbreak=ON;	/* ditto */
X}
Xchar kill_char='X'-'@';
Xchar erase_char='\b';
Xtgetch(){
X#if 1
X	int x=getch();		/* can't use getch() - typeahead ends up stalling the
X				 * game (since it's a con:) */
X#else
X	int x;
X	Read(Input(),&x,1);
X#endif
X	return (x=='\r')?'\n':x;
X}
Xvoid get_scr_size(){
X	CO=80;
X	LI=24;
X}
X
X#endif
X
Xvoid tty_change_color() {}
Xchar *tty_get_color_string() { return( "" ); }
END_OF_FILE
if test 1512 -ne `wc -c <'sys/amiga/amitty.c'`; then
    echo shar: \"'sys/amiga/amitty.c'\" unpacked with wrong size!
fi
# end of 'sys/amiga/amitty.c'
if test -f 'sys/amiga/randwin.uu' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'sys/amiga/randwin.uu'\" to \"'sys/amiga/randwin.uu.orig'\"
  mv -f 'sys/amiga/randwin.uu' 'sys/amiga/randwin.uu.orig'
fi
echo shar: Extracting \"'sys/amiga/randwin.uu'\" \(963 characters\)
sed "s/^X//" >'sys/amiga/randwin.uu' <<'END_OF_FILE'
Xbegin 664 randwin.pw
XM4&]W97)7:6YD;W=S('8R+C5C(*DQ.3@W+"`Q.3@X(&)Y($E.3U9!5%)/3DE#
XM4RP@24Y#+B`@("`@("`@("`@("`@("`@("`@("`@```"[`````E```#\````
XM`0`````!`````!!A;6EG83IR86YD=VEN+F,`!\\UT``````"@`#(``(``8``
XM``\`````!\L\^````````````````@````$``````0`````!``````R@H*``
XM``#P\/"00'`````!``(0``!(`D``!0`%_____P`````'SU_@````````````
XM```````````!!\\Z>```````!5)N9%\```$`K@`Z`/D`6@`%``7_____````
XM`0```````&,`00`P`!$````#``$'SUU4``````?/4?@`````````````!\]=
XM@/____\#```%!\]=9````````````#$````Q`!(````2```````````'``$`
XM``@`!0`````'SU(8``````````5/2T%9``````H````!!\]2*`?/7?@'SUX(
XM!\]>&`?/7B@'SUXX`````0`````!``````$``````C$``````0`````!``8`
XM`0``!P`&``````?/8``'SV`P````(EEO=2!A<VME9"!F;W(@82!R86YD;VT@
XM0VAA<F%C=&5R+@`&``$```\`$@`````'SV!0!\]@>````!Y)('1H:6YK('1H
XM870@>6]U('=I;&P@:&%V92!A;@`&``$``!D`'0`````'SV"8!\]@P````!EE
XM>&-I=&EN9R!G86UE('!L87EI;F<@87,``0`!``!#`"\`````!\]@X`?/80``
XM```10VAA<F%C=&5R($-H;VEC90`&``$``,8`'0`````'SUY(``````````)A
X!```1
X`
Xend
END_OF_FILE
if test 963 -ne `wc -c <'sys/amiga/randwin.uu'`; then
    echo shar: \"'sys/amiga/randwin.uu'\" unpacked with wrong size!
fi
# end of 'sys/amiga/randwin.uu'
echo shar: End of archive 8 \(of 33\).
cp /dev/null ark8isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 33 archives.
    echo "Now execute ./patchit.sh"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
