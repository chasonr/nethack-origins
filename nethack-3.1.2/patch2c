Path: uunet!news.tek.com!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v17i078:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Patch2c/33
Date: 11 Jun 1993 00:05:44 GMT
Organization: Tektronix, Inc, Redmond, OR, USA
Lines: 2245
Approved: billr@saab.CNA.TEK.COM
Message-ID: <1v8i8o$ipi@ying.cna.tek.com>
NNTP-Posting-Host: saab.cna.tek.com
Xref: uunet comp.sources.games:1766

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 17, Issue 78
Archive-name: nethack31/Patch2c
Patch-To: nethack31: Volume 16, Issue 1-116
Environment: Amiga, Atari, Mac, MS-DOS, Windows-NT, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 3 (of 33)."
# Contents:  include/mttypriv.h patches02i
# Wrapped by billr@saab on Thu Jun 10 16:55:00 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'include/mttypriv.h' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'include/mttypriv.h'\" to \"'include/mttypriv.h.orig'\"
  mv -f 'include/mttypriv.h' 'include/mttypriv.h.orig'
fi
echo shar: Extracting \"'include/mttypriv.h'\" \(1297 characters\)
sed "s/^X//" >'include/mttypriv.h' <<'END_OF_FILE'
X/*	SCCS Id: @(#)mttypriv.h	3.1	93/03/01			*/
X/* Copyright (c) Jon W{tte 1993.					*/
X/* NetHack may be freely redistributed.  See license for details.	*/
X
X/*
X * This file contains private structures used to implement the
X * tty windows - note that these structures may change between
X * minor releases!
X */
X
X#ifndef _H_tty_private
X# define _H_tty_private
X
X# ifndef _H_tty_public
X#  include "mactty.h"
X# endif
X
X#define TA_TO_RGB(ta,rgb) (((rgb).red=(((ta)>>16)&0xff)*257),((rgb).green=(((ta)>>8)&0xff)*257),\
X	((rgb).blue=((ta)&0xff)*257)),rgb
X
Xtypedef struct tty_record {
X	void				* not_used ;
X	WindowPtr			its_window ;
X	GWorldPtr			its_window_world ;
X	BitMap				its_bits ;
X	GrafPtr				offscreen_port ;
X	GWorldPtr			offscreen_world ;
X#if CLIP_RECT_ONLY
X	Rect				invalid_rect ;
X#else
X	RgnHandle			invalid_part ;
X#endif
X
X	short				font_number ;
X	short				font_size ;
X	short				char_width ;
X	short				row_height ;
X	short				ascent_height ;
X
X	short				x_size ;
X	short				y_size ;
X	short				x_curs ;
X	short				y_curs ;
X
X	long				attribute [ TTY_NUMBER_ATTRIBUTES ] ;
X	long				last_cursor ;
X
X#if TTY_INPUT
X	short				input_buffer_len ;
X	short				input_buffer_limit ;
X	char				* input_buffer ;
X#endif
X
X	Boolean				was_allocated ;
X	Boolean				curs_state ;
X	Boolean				uses_gworld ;
X} tty_record ;
X
X
X#endif
END_OF_FILE
if test 1297 -ne `wc -c <'include/mttypriv.h'`; then
    echo shar: \"'include/mttypriv.h'\" unpacked with wrong size!
fi
# end of 'include/mttypriv.h'
if test -f 'patches02i' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'patches02i'\" to \"'patches02i.orig'\"
  mv -f 'patches02i' 'patches02i.orig'
fi
echo shar: Extracting \"'patches02i'\" \(56999 characters\)
sed "s/^X//" >'patches02i' <<'END_OF_FILE'
X*** /tmp/da11426	Tue Jun  1 16:16:08 1993
X--- src/topten.c	Tue May 25 15:33:42 1993
X***************
X*** 36,42 ****
X  #define	POINTSMIN	1	/* must be > 0 */
X  #define	ENTRYMAX	100	/* must be >= 10 */
X  
X! #ifndef MICRO
X  #define	PERS_IS_UID		/* delete for PERSMAX per name; now per uid */
X  #endif
X  struct toptenentry {
X--- 36,42 ----
X  #define	POINTSMIN	1	/* must be > 0 */
X  #define	ENTRYMAX	100	/* must be >= 10 */
X  
X! #if !defined(MICRO) && !defined(MAC)
X  #define	PERS_IS_UID		/* delete for PERSMAX per name; now per uid */
X  #endif
X  struct toptenentry {
X***************
X*** 77,98 ****
X  	/* note: fscanf() below must read the record's terminating newline */
X  	final_fpos = tt->fpos = ftell(rfile);
X  #endif
X  #ifdef NO_SCAN_BRACK
X  	if(fscanf(rfile,"%6s %d %d %d %d %d %d %ld%*c%c%c %s %s%*c",
X- #  define TTFIELDS 13
X  #else
X  	if(fscanf(rfile, "%6s %d %d %d %d %d %d %ld %c%c %[^,],%[^\n]%*c",
X- #  define TTFIELDS 12
X  #endif
X  			tt->date, &tt->uid,
X  			&tt->deathdnum, &tt->deathlev,
X  			&tt->maxlvl, &tt->hp, &tt->maxhp, &tt->points,
X  			&tt->plchar, &tt->sex,
X- #ifdef LATTICE	/* return value is broken also, sigh */
X- 			tt->name, tt->death) < 1)
X- #else
X  			tt->name, tt->death) != TTFIELDS)
X- #endif
X  #undef TTFIELDS
X  		tt->points = 0;
X  	else {
X--- 77,93 ----
X  	/* note: fscanf() below must read the record's terminating newline */
X  	final_fpos = tt->fpos = ftell(rfile);
X  #endif
X+ #define TTFIELDS 12
X  #ifdef NO_SCAN_BRACK
X  	if(fscanf(rfile,"%6s %d %d %d %d %d %d %ld%*c%c%c %s %s%*c",
X  #else
X  	if(fscanf(rfile, "%6s %d %d %d %d %d %d %ld %c%c %[^,],%[^\n]%*c",
X  #endif
X  			tt->date, &tt->uid,
X  			&tt->deathdnum, &tt->deathlev,
X  			&tt->maxlvl, &tt->hp, &tt->maxhp, &tt->points,
X  			&tt->plchar, &tt->sex,
X  			tt->name, tt->death) != TTFIELDS)
X  #undef TTFIELDS
X  		tt->points = 0;
X  	else {
X***************
X*** 208,217 ****
X  
X  #if defined(WIZARD) || defined(EXPLORE_MODE)
X  	if (wizard || discover) {
X! 	    raw_print("");
X! 	    raw_printf(
X  	      "Since you were in %s mode, the score list will not be checked.",
X  		    wizard ? "wizard" : "discover");
X  	    return;
X  	}
X  #endif
X--- 203,214 ----
X  
X  #if defined(WIZARD) || defined(EXPLORE_MODE)
X  	if (wizard || discover) {
X! 	    HUP {
X! 		raw_print("");
X! 		raw_printf(
X  	      "Since you were in %s mode, the score list will not be checked.",
X  		    wizard ? "wizard" : "discover");
X+ 	    }
X  	    return;
X  	}
X  #endif
X***************
X*** 533,538 ****
X--- 530,543 ----
X  		return;
X  	}
X  
X+ #ifdef	AMIGA
X+ 	{
X+ 	    extern winid amii_rawprwin;
X+ 	    init_nhwindows();
X+ 	    amii_rawprwin = create_nhwindow( NHW_TEXT );
X+ 	}
X+ #endif
X+ 
X  	/* If the score list isn't after a game, we never went through */
X  	/* init_dungeons() */
X  	if (wiz1_level.dlevel == 0) init_dungeons();
X***************
X*** 556,562 ****
X--- 561,571 ----
X  #else
X  		player0 = plname;
X  		if(!*player0)
X+ #ifdef AMIGA
X+ 			player0 = "all";	/* single user system */
X+ #else
X  			player0 = "hackplayer";
X+ #endif
X  		playerct = 1;
X  		players = &player0;
X  #endif
X***************
X*** 602,607 ****
X--- 611,621 ----
X  			     hname);
X  		}
X  	    }
X+ #ifdef	AMIGA
X+ 	    display_nhwindow( amii_rawprwin, 1 );
X+ 	    destroy_nhwindow( amii_rawprwin );
X+ 	    amii_rawprwin = WIN_ERR;
X+ #endif
X  	    return;
X  	}
X  
X***************
X*** 651,656 ****
X--- 665,675 ----
X  		break;
X  	}
X  #endif /* nonsense /**/
X+ #ifdef	AMIGA
X+ 	display_nhwindow( amii_rawprwin, 1 );
X+ 	destroy_nhwindow( amii_rawprwin );
X+ 	amii_rawprwin = WIN_ERR;
X+ #endif
X  }
X  
X  static int
X*** /tmp/da11442	Tue Jun  1 16:16:12 1993
X--- src/trap.c	Tue Jun  1 10:47:53 1993
X***************
X*** 1,8 ****
X! /*	SCCS Id: @(#)trap.c	3.1	93/02/13	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X! #include	"hack.h"
X  
X  #ifdef OVLB
X  const char *traps[TRAPNUM] = {
X--- 1,8 ----
X! /*	SCCS Id: @(#)trap.c	3.1	93/05/25	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X! #include "hack.h"
X  
X  #ifdef OVLB
X  const char *traps[TRAPNUM] = {
X***************
X*** 125,133 ****
X--- 125,135 ----
X  register int x, y, typ;
X  {
X  	register struct trap *ttmp;
X+ 	register struct rm *lev;
X  	register boolean oldplace;
X  
X  	if ((ttmp = t_at(x,y)) != 0) {
X+ 	    if (ttmp->ttyp == MAGIC_PORTAL) return (struct trap *)0;
X  	    oldplace = TRUE;
X  	    if (u.utrap && (x == u.ux) && (y == u.uy) && 
X  	      ((u.utraptype == TT_BEARTRAP && typ != BEAR_TRAP) ||
X***************
X*** 148,156 ****
X  	    case PIT:
X  	    case SPIKED_PIT:
X  	    case TRAPDOOR:
X! 		levl[x][y].doormask = 0;   /* subsumes altarmask, icedpool... */
X! 		if (IS_ROOM(levl[x][y].typ))
X! 			levl[x][y].typ = ROOM;
X  		break;
X  	}
X  	ttmp->tseen = 0;
X--- 150,172 ----
X  	    case PIT:
X  	    case SPIKED_PIT:
X  	    case TRAPDOOR:
X! 		lev = &levl[x][y];
X! 		lev->doormask = 0;	/* subsumes altarmask, icedpool... */
X! 		if (IS_ROOM(lev->typ)) /* && !IS_AIR(lev->typ) */
X! 		    lev->typ = ROOM;
X! #if defined(POLYSELF) || defined(MUSE)
X! 		/*
X! 		 * some cases which can happen when digging
X! 		 * down while phazing thru solid areas
X! 		 */
X! 		else if (lev->typ == STONE || lev->typ == SCORR)
X! 		    lev->typ = CORR;
X! 		else if (IS_WALL(lev->typ) ||
X! 			 IS_DOOR(lev->typ) || lev->typ == SDOOR)
X! 		    lev->typ = level.flags.is_maze_lev ? ROOM :
X! 			       level.flags.is_cavernous_lev ? CORR : DOOR;
X! #endif
X! 		unearth_objs(x, y);
X  		break;
X  	}
X  	ttmp->tseen = 0;
X***************
X*** 181,187 ****
X  # endif
X  	tmp2 = !sobj_at(BOULDER,x,y) && (trapok || !t_at(x,y));
X  	tmp3 = !(is_pool(x,y) &&
X! 	       !(Levitation || Wwalking || Magical_breathing
X  # ifdef POLYSELF
X  		 || is_flyer(uasmon) || is_swimmer(uasmon)
X  		 || is_clinger(uasmon)
X--- 197,203 ----
X  # endif
X  	tmp2 = !sobj_at(BOULDER,x,y) && (trapok || !t_at(x,y));
X  	tmp3 = !(is_pool(x,y) &&
X! 	       !(Levitation || Wwalking || Amphibious
X  # ifdef POLYSELF
X  		 || is_flyer(uasmon) || is_swimmer(uasmon)
X  		 || is_clinger(uasmon)
X***************
X*** 200,206 ****
X  		!MON_AT(x, y) &&
X  		!sobj_at(BOULDER,x,y) && (trapok || !t_at(x,y)) &&
X  		!(is_pool(x,y) &&
X! 		!(Levitation || Wwalking || Magical_breathing
X  # ifdef POLYSELF
X  		  || is_flyer(uasmon) || is_swimmer(uasmon)
X  		  || is_clinger(uasmon)
X--- 216,222 ----
X  		!MON_AT(x, y) &&
X  		!sobj_at(BOULDER,x,y) && (trapok || !t_at(x,y)) &&
X  		!(is_pool(x,y) &&
X! 		!(Levitation || Wwalking || Amphibious
X  # ifdef POLYSELF
X  		  || is_flyer(uasmon) || is_swimmer(uasmon)
X  		  || is_clinger(uasmon)
X***************
X*** 273,279 ****
X  	} while(!rn2(4) && newlevel < dunlevs_in_dungeon(&u.uz));
X  
X  	if(td) pline("A trap door opens up under you!");
X! 	else pline("The floor opens up under you!");
X  
X  	if(Levitation || u.ustuck || !Can_fall_thru(&u.uz)
X  #ifdef POLYSELF
X--- 289,295 ----
X  	} while(!rn2(4) && newlevel < dunlevs_in_dungeon(&u.uz));
X  
X  	if(td) pline("A trap door opens up under you!");
X! 	else pline("The %s opens up under you!", surface(u.ux,u.uy));
X  
X  	if(Levitation || u.ustuck || !Can_fall_thru(&u.uz)
X  #ifdef POLYSELF
X***************
X*** 937,944 ****
X  
X  		case FIRE_TRAP:
X  			if (in_sight)
X! 		pline("A tower of flame bursts from the floor under %s!",
X! 					mon_nam(mtmp));
X  			if(resists_fire(mptr)) {
X  			    if (in_sight) {
X  				shieldeff(mtmp->mx,mtmp->my);
X--- 953,960 ----
X  
X  		case FIRE_TRAP:
X  			if (in_sight)
X! 			 pline("A tower of flame bursts from the %s under %s!",
X! 				surface(mtmp->mx,mtmp->my), mon_nam(mtmp));
X  			if(resists_fire(mptr)) {
X  			    if (in_sight) {
X  				shieldeff(mtmp->mx,mtmp->my);
X***************
X*** 954,959 ****
X--- 970,977 ----
X  			(void) destroy_mitem(mtmp, SCROLL_CLASS, AD_FIRE);
X  			(void) destroy_mitem(mtmp, SPBOOK_CLASS, AD_FIRE);
X  			(void) destroy_mitem(mtmp, POTION_CLASS, AD_FIRE);
X+ 			if (is_ice(mtmp->mx,mtmp->my))
X+ 			    melt_ice(mtmp->mx,mtmp->my);
X  			if (in_sight) seetrap(trap);
X  			break;
X  
X***************
X*** 1055,1060 ****
X--- 1073,1079 ----
X  			break;
X  
X  		case TELEP_TRAP:
X+ 			if(tele_restrict(mtmp)) break;
X  		case MAGIC_PORTAL:
X  #ifdef WALKIES
X  			if(teleport_pet(mtmp)) {
X***************
X*** 1133,1139 ****
X  				break; /* monsters usually don't set it off */
X  			if(is_flyer(mptr)) {
X  				if (in_sight) {
X! 	pline("A trigger appears in a pile of soil below %s.", Monnam(mtmp));
X  					seetrap(trap);
X  				}
X  				if (rn2(3)) break;
X--- 1152,1158 ----
X  				break; /* monsters usually don't set it off */
X  			if(is_flyer(mptr)) {
X  				if (in_sight) {
X! 	pline("A trigger appears in a pile of soil below %s.", mon_nam(mtmp));
X  					seetrap(trap);
X  				}
X  				if (rn2(3)) break;
X***************
X*** 1345,1353 ****
X  		default:
X  			dotrap(trap);
X  	}
X! 	if(!flags.nopick && OBJ_AT(u.ux, u.uy) &&
X! 	   !Is_airlevel(&u.uz) && !Is_waterlevel(&u.uz) &&
X! 	   (!is_pool(u.ux,u.uy) || Underwater))
X  	    pickup(1);
X  	return 0;
X  }
X--- 1364,1370 ----
X  		default:
X  			dotrap(trap);
X  	}
X! 	if(!Is_airlevel(&u.uz) && !Is_waterlevel(&u.uz))
X  	    pickup(1);
X  	return 0;
X  }
X***************
X*** 1404,1409 ****
X--- 1421,1439 ----
X  	(void) safe_teleds();
X  }
X  
X+ boolean
X+ tele_restrict(mon)
X+ struct monst *mon;
X+ {
X+ 	if(level.flags.noteleport) {
X+ 		if (canseemon(mon))
X+ 		    pline("A mysterious force prevents %s from teleporting!",
X+ 			mon_nam(mon));
X+ 		return TRUE;
X+ 	}
X+ 	return FALSE;
X+ }
X+ 
X  void
X  teleds(nux, nuy)
X  register int nux,nuy;
X***************
X*** 1423,1433 ****
X  		u.uundetected = 0;
X  	if (u.usym == S_MIMIC_DEF) u.usym = S_MIMIC;
X  #endif
X- 	if(Punished) placebc();
X  	if(u.uswallow){
X  		u.uswldtim = u.uswallow = 0;
X  		docrt();
X  	}
X  	initrack(); /* teleports mess up tracking monsters without this */
X  	/*
X  	 *  Make sure the hero disappears from the old location.  This will
X--- 1453,1463 ----
X  		u.uundetected = 0;
X  	if (u.usym == S_MIMIC_DEF) u.usym = S_MIMIC;
X  #endif
X  	if(u.uswallow){
X  		u.uswldtim = u.uswallow = 0;
X  		docrt();
X  	}
X+ 	if(Punished) placebc();
X  	initrack(); /* teleports mess up tracking monsters without this */
X  	/*
X  	 *  Make sure the hero disappears from the old location.  This will
X***************
X*** 1446,1452 ****
X  {
X  	struct trap *trap;
X  	boolean castit = FALSE;
X! 	register int sp_no = 0;
X  
X  	trap = t_at(u.ux, u.uy);
X  	if (trap && (!trap->tseen || trap->ttyp != TELEP_TRAP))
X--- 1476,1482 ----
X  {
X  	struct trap *trap;
X  	boolean castit = FALSE;
X! 	register int sp_no = 0, energy;
X  
X  	trap = t_at(u.ux, u.uy);
X  	if (trap && (!trap->tseen || trap->ttyp != TELEP_TRAP))
X***************
X*** 1503,1514 ****
X  	}
X  
X  	if(!trap && (u.uhunger <= 100 || ACURR(A_STR) < 6)) {
X- 		You("lack the strength for a teleport spell.");
X  #ifdef WIZARD
X! 		if(!wizard)
X  #endif
X! 		return(1);
X  	}
X  	if(!trap &&
X  	  check_capacity("Your concentration falters from carrying so much."))
X  	    return 1;
X--- 1533,1563 ----
X  	}
X  
X  	if(!trap && (u.uhunger <= 100 || ACURR(A_STR) < 6)) {
X  #ifdef WIZARD
X! 		if (!wizard) {
X  #endif
X! 			You("lack the strength %s.",
X! 			    castit ? "for a teleport spell" : "to teleport");
X! 			return 1;
X! #ifdef WIZARD
X! 		}
X! #endif
X  	}
X+ 
X+ 	energy = objects[SPE_TELEPORT_AWAY].oc_level * 7 / 2 - 2;
X+ 
X+ 	if(!trap && u.uen <= energy) {
X+ #ifdef WIZARD
X+ 		if (!wizard) {
X+ #endif
X+ 			You("lack the energy %s.",
X+ 			    castit ? "for a teleport spell" : "to teleport");
X+ 			return 1;
X+ #ifdef WIZARD
X+ 		} else u.uen = energy;
X+ #endif
X+ 	}
X+ 
X  	if(!trap &&
X  	  check_capacity("Your concentration falters from carrying so much."))
X  	    return 1;
X***************
X*** 1522,1528 ****
X  		    if (!wizard)
X  #endif
X  			return(0);
X! 	}
X  #ifdef WALKIES
X  	if(next_to_u()) {
X  #endif
X--- 1571,1579 ----
X  		    if (!wizard)
X  #endif
X  			return(0);
X! 	} else if (!trap)
X! 		u.uen -= energy;
X! 
X  #ifdef WALKIES
X  	if(next_to_u()) {
X  #endif
X***************
X*** 1729,1735 ****
X  	 * SCR_FIRE by GAN 11/02/86
X  	 */
X  
X! 	pline("A tower of flame bursts from the floor!");
X  	if(Fire_resistance) {
X  		shieldeff(u.ux, u.uy);
X  		You("are uninjured.");
X--- 1780,1786 ----
X  	 * SCR_FIRE by GAN 11/02/86
X  	 */
X  
X! 	pline("A tower of flame bursts from the %s!", surface(u.ux,u.uy));
X  	if(Fire_resistance) {
X  		shieldeff(u.ux, u.uy);
X  		You("are uninjured.");
X***************
X*** 1741,1746 ****
X--- 1792,1799 ----
X  	destroy_item(SCROLL_CLASS, AD_FIRE);
X  	destroy_item(SPBOOK_CLASS, AD_FIRE);
X  	destroy_item(POTION_CLASS, AD_FIRE);
X+ 	if (is_ice(u.ux, u.uy))
X+ 		melt_ice(u.ux, u.uy);
X  }
X  
X  static void
X***************
X*** 1888,1895 ****
X  		} else if(is_rustprone(obj) && obj->oeroded < MAX_ERODE &&
X  			  !(obj->oerodeproof || (obj->blessed && !rnl(4))) &&
X  			  (force || rn2(12) > Luck)) {
X! 			/* all metal stuff and armor except body armor
X! 			   protected by oilskin cloak */
X  			if(obj->oclass != ARMOR_CLASS || obj != uarm ||
X  			   !uarmc || uarmc->otyp != OILSKIN_CLOAK ||
X   			   (uarmc->cursed && !rn2(3)))
X--- 1941,1948 ----
X  		} else if(is_rustprone(obj) && obj->oeroded < MAX_ERODE &&
X  			  !(obj->oerodeproof || (obj->blessed && !rnl(4))) &&
X  			  (force || rn2(12) > Luck)) {
X! 			/* all metal stuff and armor except (body armor
X! 			   protected by oilskin cloak) */
X  			if(obj->oclass != ARMOR_CLASS || obj != uarm ||
X  			   !uarmc || uarmc->otyp != OILSKIN_CLOAK ||
X   			   (uarmc->cursed && !rn2(3)))
X***************
X*** 1965,1971 ****
X  #ifdef POLYSELF
X  	     is_swimmer(uasmon) ||
X  #endif
X! 	     Magical_breathing)) {
X  		/* water effects on objects every now and then */
X  		if (!rn2(5)) inpool_ok = TRUE;
X  		else return(FALSE);
X--- 2018,2024 ----
X  #ifdef POLYSELF
X  	     is_swimmer(uasmon) ||
X  #endif
X! 	     Amphibious)) {
X  		/* water effects on objects every now and then */
X  		if (!rn2(5)) inpool_ok = TRUE;
X  		else return(FALSE);
X***************
X*** 1972,1979 ****
X  	}
X  
X  	if (!u.uinwater) {
X! 	    You("%s into the water!",
X! 		Is_waterlevel(&u.uz) ? "plunge" : "fall");
X  #ifdef POLYSELF
X  	    if(!is_swimmer(uasmon))
X  #endif
X--- 2025,2033 ----
X  	}
X  
X  	if (!u.uinwater) {
X! 	    You("%s into the water%c",
X! 		Is_waterlevel(&u.uz) ? "plunge" : "fall",
X! 		Amphibious ? '.' : '!');
X  #ifdef POLYSELF
X  	    if(!is_swimmer(uasmon))
X  #endif
X***************
X*** 1992,2005 ****
X  			You("multiply.");
X  		}
X  	}
X- 
X- 	if(is_swimmer(uasmon) && !inpool_ok) {
X- 	    if (Punished) placebc();
X- 	    u.uinwater = 1;
X- 	    under_water(1);
X- 	    vision_full_recalc = 1;
X- 	    return(FALSE);
X- 	}
X  #endif
X  	if (inpool_ok) return(FALSE);
X  #ifdef WALKIES
X--- 2046,2051 ----
X***************
X*** 2010,2021 ****
X  		unleash_all();
X  	}
X  #endif
X! 	if (Magical_breathing) {
X! 		pline("But wait!");
X! 		Your("lungs start acting like gills.");
X! 		if (!Is_waterlevel(&u.uz))
X! 			Your("%s the bottom.",Hallucination ? "keel hits" : "feet touch");
X! 		if (Punished) placebc();
X  		u.uinwater = 1;
X  		under_water(1);
X  		vision_full_recalc = 1;
X--- 2056,2079 ----
X  		unleash_all();
X  	}
X  #endif
X! 	if (Amphibious
X! #ifdef POLYSELF
X! 			|| is_swimmer(uasmon)
X! #endif
X! 						) {
X! 		if (Amphibious) {
X! 			if (flags.verbose)
X! 				pline("But you aren't drowning.");
X! 			if (!Is_waterlevel(&u.uz))
X! 				if (Hallucination) 
X! 					Your("keel hits the bottom.");
X! 				else
X! 					You("touch bottom.");
X! 		}
X! 		if (Punished) {
X! 			unplacebc();
X! 			placebc();
X! 		}
X  		u.uinwater = 1;
X  		under_water(1);
X  		vision_full_recalc = 1;
X***************
X*** 2076,2083 ****
X  			done(DROWNING);
X  		}
X  	u.uinwater = 0;
X! 	You("find yourself back %s.",Is_waterlevel(&u.uz) ?
X! 		"in an air bubble" : "on dry land");
X  	return(TRUE);
X  }
X  
X--- 2134,2141 ----
X  			done(DROWNING);
X  		}
X  	u.uinwater = 0;
X! 	You("find yourself back %s.", Is_waterlevel(&u.uz) ?
X! 		"in an air bubble" : "on land");
X  	return(TRUE);
X  }
X  
X***************
X*** 2216,2222 ****
X  		    if(!force && (confused || Fumbling || 
X  		                     rnd(75+level_difficulty()/2) > ch)) {
X  			    You("set it off!");
X! 			    b_trapped("door");
X  		    } else
X  			    You("disarm it!");
X  		    levl[x][y].doormask &= ~D_TRAPPED;
X--- 2274,2280 ----
X  		    if(!force && (confused || Fumbling || 
X  		                     rnd(75+level_difficulty()/2) > ch)) {
X  			    You("set it off!");
X! 			    b_trapped("door", FINGER);
X  		    } else
X  			    You("disarm it!");
X  		    levl[x][y].doormask &= ~D_TRAPPED;
X***************
X*** 2327,2333 ****
X  		case 14:
X  		case 13:
X  			You("feel a needle prick your %s.",body_part(bodypart));
X! 			poisoned("needle", A_CON, "poison needle",10);
X  			exercise(A_CON, FALSE);
X  			break;
X  		case 12:
X--- 2385,2391 ----
X  		case 14:
X  		case 13:
X  			You("feel a needle prick your %s.",body_part(bodypart));
X! 			poisoned("needle", A_CON, "poisoned needle",10);
X  			exercise(A_CON, FALSE);
X  			break;
X  		case 12:
X***************
X*** 2343,2348 ****
X--- 2401,2408 ----
X  			destroy_item(SCROLL_CLASS, AD_FIRE);
X  			destroy_item(SPBOOK_CLASS, AD_FIRE);
X  			destroy_item(POTION_CLASS, AD_FIRE);
X+ 			if (is_ice(u.ux, u.uy))
X+ 			    melt_ice(u.ux, u.uy);
X  			break;
X  		case 8:
X  		case 7:
X***************
X*** 2422,2440 ****
X  	dealloc_trap(trap);
X  }
X  
X! /* used for doors.  can be used for anything else that opens. */
X  void
X! b_trapped(item)
X  register const char *item;
X  {
X  	register int lvl = level_difficulty();
X! 	int dmg = rnd(5 + (lvl<5 ? lvl : 2+lvl/2));
X  
X  	pline("KABOOM!!  %s was booby-trapped!", The(item));
X! 	if (u.ulevel < 4 && lvl < 3 && !rnl(3))
X! 		You("are shaken, but luckily unhurt.");		
X! 	else losehp(dmg, "explosion", KILLED_BY_AN);
X  	exercise(A_STR, FALSE);
X  	make_stunned(HStun + dmg, TRUE);
X  }
X  
X--- 2482,2500 ----
X  	dealloc_trap(trap);
X  }
X  
X! /* used for doors (also tins).  can be used for anything else that opens. */
X  void
X! b_trapped(item, bodypart)
X  register const char *item;
X+ register int bodypart;
X  {
X  	register int lvl = level_difficulty();
X! 	int dmg = rnd(5 + (lvl < 5 ? lvl : 2+lvl/2));
X  
X  	pline("KABOOM!!  %s was booby-trapped!", The(item));
X! 	losehp(dmg, "explosion", KILLED_BY_AN);
X  	exercise(A_STR, FALSE);
X+ 	if (bodypart) exercise(A_CON, FALSE);
X  	make_stunned(HStun + dmg, TRUE);
X  }
X  
X*** /tmp/da11450	Tue Jun  1 16:16:16 1993
X--- src/u_init.c	Tue Apr 27 17:00:42 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)u_init.c	3.1	93/02/21	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)u_init.c	3.1	93/04/24	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 368,374 ****
X  			 * generators are bad enough to seriously skew the
X  			 * results if we use rn2(2)...  --KAA
X  			 */
X! 
X  		/*
X  		 * Elves are people of music and song, or they are warriors.
X  		 * Warriors get mithril coats; non-warriors MAY get an
X--- 368,374 ----
X  			 * generators are bad enough to seriously skew the
X  			 * results if we use rn2(2)...  --KAA
X  			 */
X! 		ini_inv(Elf);
X  		/*
X  		 * Elves are people of music and song, or they are warriors.
X  		 * Warriors get mithril coats; non-warriors MAY get an
X***************
X*** 375,396 ****
X  		 * instrument.  We use a kludge to get only non-magic
X  		 * instruments.
X  		 */
X! 		if (Elf[E_ARMOR].trotyp == ELVEN_CLOAK) {
X! 			if (!rn2(5)) {
X! 		    	static int trotyp[] = {
X! 					WOODEN_FLUTE, TOOLED_HORN, WOODEN_HARP,
X! 					BELL, BUGLE, LEATHER_DRUM
X! 				};
X! 
X! 				Instrument[0].trotyp = trotyp[rn2(SIZE(trotyp))];
X! #ifdef DEBUG
X! 				debugpline("Elf got instrument %d",
X! 					Instrument[0].trotyp);
X! #endif
X! 				ini_inv(Instrument);
X! 			}
X  		}
X- 		ini_inv(Elf);
X  		if(!rn2(5)) ini_inv(Blindfold);
X  		else if(!rn2(6)) ini_inv(Lamp);
X  		knows_object(ELVEN_SHORT_SWORD);
X--- 375,388 ----
X  		 * instrument.  We use a kludge to get only non-magic
X  		 * instruments.
X  		 */
X! 		if (Elf[E_ARMOR].trotyp == ELVEN_CLOAK && !rn2(5)) {
X! 		    static int trotyp[] = {
X! 			WOODEN_FLUTE, TOOLED_HORN, WOODEN_HARP,
X! 			BELL, BUGLE, LEATHER_DRUM
X! 		    };
X! 		    Instrument[0].trotyp = trotyp[rn2(SIZE(trotyp))];
X! 		    ini_inv(Instrument);
X  		}
X  		if(!rn2(5)) ini_inv(Blindfold);
X  		else if(!rn2(6)) ini_inv(Lamp);
X  		knows_object(ELVEN_SHORT_SWORD);
X*** /tmp/da11458	Tue Jun  1 16:16:19 1993
X--- src/uhitm.c	Tue Jun  1 14:25:48 1993
X***************
X*** 323,328 ****
X--- 323,330 ----
X  	    }
X  #endif
X  	} else {
X+ 	    int oldhp = mon->mhp;
X+ 
X  	    /* we hit the monster; be careful: it might die! */
X  	    notonhead = (mon->mx != u.ux+u.dx || mon->my != u.uy+u.dy);
X  	    if((malive = hmon(mon, uwep, 0)) == TRUE) {
X***************
X*** 337,343 ****
X  								)
X  				u.ustuck = 0;
X  		}
X! 		if (mon->wormno) cutworm(mon, u.ux+u.dx, u.uy+u.dy, uwep);
X  	    }
X  	    if(mon->ispriest && !rn2(2)) ghod_hitsu(mon);
X  	    if(special) (void) angry_guards(!flags.soundok);
X--- 339,350 ----
X  								)
X  				u.ustuck = 0;
X  		}
X! 		/* If no damage was done (Vorpal Blade and not on head)
X! 		 * do not cut the worm.  We lost the information long ago, so
X! 		 * we must do this by checking the hit points.
X! 		 */
X! 		if (mon->wormno && mon->mhp < oldhp)
X! 			cutworm(mon, u.ux+u.dx, u.uy+u.dy, uwep);
X  	    }
X  	    if(mon->ispriest && !rn2(2)) ghod_hitsu(mon);
X  	    if(special) (void) angry_guards(!flags.soundok);
X***************
X*** 1347,1359 ****
X  			if (mon->data == &mons[PM_SHADE])
X  			    Your("hug passes harmlessly through %s.",
X  				mon_nam(mon));
X! 			else if (!sticks(mon->data))
X  			    if (mon==u.ustuck) {
X  				pline("%s is being %s.", Monnam(mon),
X  				    u.umonnum==PM_ROPE_GOLEM ? "choked":
X  				    "crushed");
X  				sum[i] = damageum(mon, mattk);
X! 			    } else if(sum[i-1] && sum[i-2]) {
X  				You("grab %s!", mon_nam(mon));
X  				u.ustuck = mon;
X  				sum[i] = damageum(mon, mattk);
X--- 1354,1366 ----
X  			if (mon->data == &mons[PM_SHADE])
X  			    Your("hug passes harmlessly through %s.",
X  				mon_nam(mon));
X! 			else if (!sticks(mon->data) && !u.uswallow)
X  			    if (mon==u.ustuck) {
X  				pline("%s is being %s.", Monnam(mon),
X  				    u.umonnum==PM_ROPE_GOLEM ? "choked":
X  				    "crushed");
X  				sum[i] = damageum(mon, mattk);
X! 			    } else if(i >= 2 && sum[i-1] && sum[i-2]) {
X  				You("grab %s!", mon_nam(mon));
X  				u.ustuck = mon;
X  				sum[i] = damageum(mon, mattk);
X***************
X*** 1526,1532 ****
X  			} else {
X  			    You("are frozen by %s gaze!", 
X  				  s_suffix(mon_nam(mon)));
X! 			    nomul((ACURR(A_WIS) > 12 || rn2(4)) ? -tmp : -120);
X  			}
X  		    } else {
X  			pline("%s cannot defend itself.",
X--- 1533,1539 ----
X  			} else {
X  			    You("are frozen by %s gaze!", 
X  				  s_suffix(mon_nam(mon)));
X! 			    nomul((ACURR(A_WIS) > 12 || rn2(4)) ? -tmp : -127);
X  			}
X  		    } else {
X  			pline("%s cannot defend itself.",
X*** /tmp/da11466	Tue Jun  1 16:16:22 1993
X--- src/vault.c	Tue Jun  1 12:12:46 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)vault.c	3.1	93/01/15	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)vault.c	3.1	93/03/30	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 41,47 ****
X  			}
X  		}
X  		levl[fcx][fcy].typ = EGD(grd)->fakecorr[fcbeg].ftyp;
X! 		map_background(fcx,fcy, 1);
X  		if(!ACCESSIBLE(levl[fcx][fcy].typ)) block_point(fcx,fcy);
X  		EGD(grd)->fcbeg++;
X  	}
X--- 41,47 ----
X  			}
X  		}
X  		levl[fcx][fcy].typ = EGD(grd)->fakecorr[fcbeg].ftyp;
X! 		map_location(fcx, fcy, 1);	/* bypass vision */
X  		if(!ACCESSIBLE(levl[fcx][fcy].typ)) block_point(fcx,fcy);
X  		EGD(grd)->fcbeg++;
X  	}
X***************
X*** 331,338 ****
X  		if(!IS_WALL(levl[x][y].typ) && !in_fcorridor(grd, x, y)) {
X  		    if(MON_AT(x, y) && grd->mx != x && grd->my != y) {
X  			struct monst *mon = m_at(x,y);
X! 			if (mon->data->msound != MS_SILENT)
X! 			    yelp(mon);
X  			rloc(mon);
X  		    }
X  		    if ((gold = g_at(x, y)) != 0) {
X--- 331,339 ----
X  		if(!IS_WALL(levl[x][y].typ) && !in_fcorridor(grd, x, y)) {
X  		    if(MON_AT(x, y) && grd->mx != x && grd->my != y) {
X  			struct monst *mon = m_at(x,y);
X! #ifdef SOUNDS
X! 			yelp(mon);
X! #endif
X  			rloc(mon);
X  		    }
X  		    if ((gold = g_at(x, y)) != 0) {
X***************
X*** 367,374 ****
X  		if(!IS_WALL(levl[x][y].typ) && !in_fcorridor(grd, x, y)) {
X  		    if(MON_AT(x, y) && grd->mx != x && grd->my != y) {
X  			struct monst *mon = m_at(x,y);
X! 			if (mon->data->msound != MS_SILENT)
X! 			    yelp(mon);
X  			rloc(mon);
X  		    }
X  		    if ((gold = g_at(x, y)) != 0) {
X--- 368,376 ----
X  		if(!IS_WALL(levl[x][y].typ) && !in_fcorridor(grd, x, y)) {
X  		    if(MON_AT(x, y) && grd->mx != x && grd->my != y) {
X  			struct monst *mon = m_at(x,y);
X! #ifdef SOUNDS
X! 			yelp(mon);
X! #endif
X  			rloc(mon);
X  		    }
X  		    if ((gold = g_at(x, y)) != 0) {
X***************
X*** 724,731 ****
X  	register struct obj *obj;
X  
X  	for (obj = invent; obj; obj = obj->nobj)
X! 	    if (Is_container(obj))
X  		value += contained_gold(obj);
X  
X  	return(value);
X  }
X--- 726,734 ----
X  	register struct obj *obj;
X  
X  	for (obj = invent; obj; obj = obj->nobj)
X! 	    if (Has_contents(obj))
X  		value += contained_gold(obj);
X+ 	/* unknown gold stuck inside statues may cause some consternation... */
X  
X  	return(value);
X  }
X*** /tmp/da11474	Tue Jun  1 16:16:24 1993
X--- src/version.c	Mon Apr 19 16:59:52 1993
X***************
X*** 5,11 ****
X  #include	"hack.h"
X  #include	"date.h"
X  #ifndef BETA
X! # if defined(MICRO) && !defined(AMIGA) && !defined(TOS) && !defined(OS2_HPFS)
X  # include	"patchlev.h"
X  # else
X  # include	"patchlevel.h"
X--- 5,11 ----
X  #include	"hack.h"
X  #include	"date.h"
X  #ifndef BETA
X! # ifdef SHORT_FILENAMES
X  # include	"patchlev.h"
X  # else
X  # include	"patchlevel.h"
X***************
X*** 16,28 ****
X  doversion()
X  {
X  #ifdef BETA
X! 	pline("%s NetHack Beta Version %s - last build %s.",
X  #else
X! 	pline("%s NetHack Version %s.%d - last build %s.",
X  #endif
X! 		PORT_ID, VERSION,
X! #ifndef BETA
X! 		PATCHLEVEL,
X  #endif
X  		BUILD_DATE);	/* from date.h, generated by 'makedefs' */
X  	return 0;
X--- 16,28 ----
X  doversion()
X  {
X  #ifdef BETA
X! 	pline("%s NetHack Beta Version %d.%d.%d-%d - last build %s.",
X  #else
X! 	pline("%s NetHack Version %d.%d.%d - last build %s.",
X  #endif
X! 		PORT_ID, VERSION_MAJOR, VERSION_MINOR, PATCHLEVEL,
X! #ifdef BETA
X! 		EDITLEVEL,
X  #endif
X  		BUILD_DATE);	/* from date.h, generated by 'makedefs' */
X  	return 0;
X*** /tmp/da11482	Tue Jun  1 16:16:27 1993
X--- src/vision.c	Mon Mar 29 14:33:20 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)vision.c	3.1	92/11/14	*/
X  /* Copyright (c) Dean Luick, with acknowledgements to Dave Cohrs, 1990.	*/
X  /* NetHack may be freely redistributed.  See license for details.	*/
X  #include "hack.h"
X--- 1,4 ----
X! /*	SCCS Id: @(#)vision.c	3.1	93/03/28	*/
X  /* Copyright (c) Dean Luick, with acknowledgements to Dave Cohrs, 1990.	*/
X  /* NetHack may be freely redistributed.  See license for details.	*/
X  #include "hack.h"
X***************
X*** 300,306 ****
X      char *rmin, *rmax;
X  {
X      int rnum = levl[u.ux][u.uy].roomno - ROOMOFFSET; /* no SHARED... */
X!     int start, stop, in_door;
X      register int zx, zy;
X  
X      /* If in a lit room, we are able to see to its boundaries. */
X--- 300,306 ----
X      char *rmin, *rmax;
X  {
X      int rnum = levl[u.ux][u.uy].roomno - ROOMOFFSET; /* no SHARED... */
X!     int start, stop, in_door, xhi, xlo, yhi, ylo;
X      register int zx, zy;
X  
X      /* If in a lit room, we are able to see to its boundaries. */
X***************
X*** 323,333 ****
X      in_door = levl[u.ux][u.uy].typ == DOOR;
X  
X      /* Can always see adjacent. */
X!     for (zy = u.uy-1; zy <= u.uy+1; zy++) {
X! 	rmin[zy] = min(rmin[zy],u.ux-1);
X! 	rmax[zy] = max(rmax[zy],u.ux+1);
X  
X! 	for (zx = u.ux-1; zx <= u.ux+1; zx++) {
X  	    next[zy][zx] = COULD_SEE | IN_SIGHT;
X  	    /*
X  	     * Yuck, update adjacent non-diagonal positions when in a doorway.
X--- 323,337 ----
X      in_door = levl[u.ux][u.uy].typ == DOOR;
X  
X      /* Can always see adjacent. */
X!     ylo = max(u.uy - 1, 0);
X!     yhi = min(u.uy + 1, ROWNO - 1);
X!     xlo = max(u.ux - 1, 1);
X!     xhi = min(u.ux + 1, COLNO - 1);
X!     for (zy = ylo; zy <= yhi; zy++) {
X! 	if (xlo < rmin[zy]) rmin[zy] = xlo;
X! 	if (xhi > rmax[zy]) rmax[zy] = xhi;
X  
X! 	for (zx = xlo; zx <= xhi; zx++) {
X  	    next[zy][zx] = COULD_SEE | IN_SIGHT;
X  	    /*
X  	     * Yuck, update adjacent non-diagonal positions when in a doorway.
X*** /tmp/da11490	Tue Jun  1 16:16:31 1993
X--- src/weapon.c	Wed Mar  3 14:34:34 1993
X***************
X*** 462,488 ****
X  	mon->weapon_check = NEED_WEAPON;
X  	return 0;
X  }
X- 
X- /* rearrange a monster's inventory so that wielded weapon is first */
X- void
X- sort_mwep(mon)
X- struct monst *mon;
X- {
X- 	struct obj *otmp, *prev, *mw_tmp = MON_WEP(mon);
X- 
X- 	if (!mw_tmp) return;
X- 	for (otmp = mon->minvent, prev = 0; otmp; otmp = otmp->nobj) {
X- 		if (otmp == mw_tmp)  break;
X- 		prev = otmp;
X- 	}
X- 	if (!otmp) {
X- 		MON_NOWEP(mon);
X- 	} else if (prev) {
X- 		prev->nobj = otmp->nobj;
X- 		otmp->nobj = mon->minvent;
X- 		mon->minvent = otmp;
X- 	}
X- }
X  #endif
X  
X  int
X--- 462,467 ----
X*** /tmp/da11514	Tue Jun  1 16:16:36 1993
X--- src/windows.c	Tue Apr 13 17:37:55 1993
X***************
X*** 17,22 ****
X--- 17,25 ----
X  #endif
X  #ifdef AMIGA_INTUITION
X  extern struct window_procs amii_procs ;
X+ extern struct window_procs amiv_procs ;
X+ extern void NDECL( amii_loadlib );
X+ extern void NDECL( amiv_loadlib );
X  #endif
X  
X  NEARDATA struct window_procs windowprocs;
X***************
X*** 36,42 ****
X  	{ & mac_procs , NULL } ,
X  #endif
X  #ifdef AMIGA_INTUITION
X! 	{ & amii_procs , NULL } ,
X  #endif
X      { 0, 0 }		/* must be last */
X  };
X--- 39,51 ----
X  	{ & mac_procs , NULL } ,
X  #endif
X  #ifdef AMIGA_INTUITION
X! 	/* A shared library is used for implementing the access to these two
X! 	 * different display mechanisms.  This means that the function names
X! 	 * are actually the same (assembler stubs) and the libraries do different
X! 	 * things.
X! 	 */
X! 	{ & amii_procs , amii_loadlib } ,
X! 	{ & amiv_procs , amiv_loadlib } ,
X  #endif
X      { 0, 0 }		/* must be last */
X  };
X*** /tmp/da11522	Tue Jun  1 16:16:38 1993
X--- src/wizard.c	Fri May 28 11:32:12 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)wizard.c	3.1	92/11/13		  */
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)wizard.c	3.1	93/05/26	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 14,25 ****
X  
X  #ifdef OVLB
X  
X! static short FDECL(which_arti, (UCHAR_P));
X  static boolean FDECL(mon_has_arti, (struct monst *,SHORT_P));
X  static struct monst *FDECL(other_mon_has_arti, (struct monst *,SHORT_P));
X  static struct obj *FDECL(on_ground, (SHORT_P));
X! static boolean FDECL(you_have, (UCHAR_P));
X! static long FDECL(target_on, (UCHAR_P,struct monst *));
X  static long FDECL(strategy, (struct monst *));
X  
X  /*	TODO:	Expand this list.	*/
X--- 14,25 ----
X  
X  #ifdef OVLB
X  
X! static short FDECL(which_arti, (int));
X  static boolean FDECL(mon_has_arti, (struct monst *,SHORT_P));
X  static struct monst *FDECL(other_mon_has_arti, (struct monst *,SHORT_P));
X  static struct obj *FDECL(on_ground, (SHORT_P));
X! static boolean FDECL(you_have, (int));
X! static long FDECL(target_on, (int,struct monst *));
X  static long FDECL(strategy, (struct monst *));
X  
X  /*	TODO:	Expand this list.	*/
X***************
X*** 135,141 ****
X  
X  static short
X  which_arti(mask)
X! 	register uchar mask;
X  {
X  	switch(mask) {
X  	    case M3_WANTSAMUL:	return(AMULET_OF_YENDOR);
X--- 135,141 ----
X  
X  static short
X  which_arti(mask)
X! 	register int mask;
X  {
X  	switch(mask) {
X  	    case M3_WANTSAMUL:	return(AMULET_OF_YENDOR);
X***************
X*** 205,211 ****
X  
X  static boolean
X  you_have(mask)
X! 	register uchar	mask;
X  {
X  	switch(mask) {
X  	    case M3_WANTSAMUL:	return(u.uhave.amulet);
X--- 205,211 ----
X  
X  static boolean
X  you_have(mask)
X! 	register int mask;
X  {
X  	switch(mask) {
X  	    case M3_WANTSAMUL:	return(u.uhave.amulet);
X***************
X*** 222,228 ****
X  
X  static long
X  target_on(mask, mtmp)
X! 	register uchar  mask;
X  	register struct monst *mtmp;
X  {
X  	register short	otyp;
X--- 222,228 ----
X  
X  static long
X  target_on(mask, mtmp)
X! 	register int mask;
X  	register struct monst *mtmp;
X  {
X  	register short	otyp;
X***************
X*** 329,338 ****
X  
X  	    default:		/* kill, maim, pillage! */
X  	    {
X! 		long  where = (mtmp->mstrategy & 0xff000000);
X  		xchar tx = (xchar)((mtmp->mstrategy >> 16) & 0xff),
X  		      ty = (xchar)((mtmp->mstrategy >> 8) & 0xff);
X! 		uchar targ = (xchar)(mtmp->mstrategy & 0xff);
X  		struct obj *otmp;
X  
X  		if(!targ) { /* simply wants you to close */
X--- 329,338 ----
X  
X  	    default:		/* kill, maim, pillage! */
X  	    {
X! 		long  where = (mtmp->mstrategy & 0xff000000L);
X  		xchar tx = (xchar)((mtmp->mstrategy >> 16) & 0xff),
X  		      ty = (xchar)((mtmp->mstrategy >> 8) & 0xff);
X! 		int   targ = (mtmp->mstrategy & 0xff);
X  		struct obj *otmp;
X  
X  		if(!targ) { /* simply wants you to close */
X***************
X*** 388,394 ****
X  {
X  	register struct monst *mtmp2;
X  
X! 	if(mtmp2 = makemon(&mons[PM_WIZARD_OF_YENDOR], u.ux, u.uy)) {
X  		mtmp2->msleep = mtmp2->mtame = mtmp2->mpeaceful = 0;
X  		if (!u.uhave.amulet && rn2(2)) {  /* give clone a fake */
X  			mtmp2->minvent = mksobj(FAKE_AMULET_OF_YENDOR, TRUE, FALSE);
X--- 388,394 ----
X  {
X  	register struct monst *mtmp2;
X  
X! 	if ((mtmp2 = makemon(&mons[PM_WIZARD_OF_YENDOR], u.ux, u.uy)) != 0) {
X  		mtmp2->msleep = mtmp2->mtame = mtmp2->mpeaceful = 0;
X  		if (!u.uhave.amulet && rn2(2)) {  /* give clone a fake */
X  			mtmp2->minvent = mksobj(FAKE_AMULET_OF_YENDOR, TRUE, FALSE);
X***************
X*** 435,441 ****
X  {
X  	register struct monst	*mtmp;
X  
X! 	if(mtmp = makemon(&mons[PM_WIZARD_OF_YENDOR], u.ux, u.uy)) {
X  		mtmp->msleep = mtmp->mtame = mtmp->mpeaceful = 0;
X  		set_malign(mtmp);
X  		pline("A voice booms out...");
X--- 435,441 ----
X  {
X  	register struct monst	*mtmp;
X  
X! 	if ((mtmp = makemon(&mons[PM_WIZARD_OF_YENDOR], u.ux, u.uy)) != 0) {
X  		mtmp->msleep = mtmp->mtame = mtmp->mpeaceful = 0;
X  		set_malign(mtmp);
X  		pline("A voice booms out...");
X*** /tmp/da11538	Tue Jun  1 16:16:43 1993
X--- src/worn.c	Sat Mar 13 16:33:03 1993
X***************
X*** 131,138 ****
X  # ifdef TOURIST
X  		else if (obj->otyp == HAWAIIAN_SHIRT) flag = W_ARMU;
X  # endif
X! 		else if (is_cloak(obj)) flag = W_ARMC;
X! 		else if (is_helmet(obj)) flag = W_ARMH;
X  		else if (is_shield(obj)) {
X  			if (MON_WEP(mon) && bimanual(MON_WEP(mon)))
X  				continue;
X--- 131,141 ----
X  # ifdef TOURIST
X  		else if (obj->otyp == HAWAIIAN_SHIRT) flag = W_ARMU;
X  # endif
X! 		else if (is_cloak(obj)) {
X! 			if (cantweararm(mon->data))
X! 				continue;
X! 			flag = W_ARMC;
X! 		} else if (is_helmet(obj)) flag = W_ARMH;
X  		else if (is_shield(obj)) {
X  			if (MON_WEP(mon) && bimanual(MON_WEP(mon)))
X  				continue;
X***************
X*** 140,152 ****
X  		} else if (is_gloves(obj)) {
X  			if (MON_WEP(mon) && MON_WEP(mon)->cursed)
X  				continue;
X! 		    flag = W_ARMG;
X! 		} else if (is_boots(obj)) flag = W_ARMF;
X! 		else if (obj->oclass == ARMOR_CLASS) {
X! #ifdef POLYSELF
X  			if (cantweararm(mon->data))
X  				continue;
X- #endif
X  			flag = W_ARM;
X  		} else continue;
X  		if (mon->misc_worn_check & flag) continue;
X--- 143,156 ----
X  		} else if (is_gloves(obj)) {
X  			if (MON_WEP(mon) && MON_WEP(mon)->cursed)
X  				continue;
X! 			flag = W_ARMG;
X! 		} else if (is_boots(obj)) {
X! 			if (slithy(mon->data) || mon->data->mlet == S_CENTAUR)
X! 				continue;
X! 			flag = W_ARMF;
X! 		} else if (obj->oclass == ARMOR_CLASS) {
X  			if (cantweararm(mon->data))
X  				continue;
X  			flag = W_ARM;
X  		} else continue;
X  		if (mon->misc_worn_check & flag) continue;
X***************
X*** 310,315 ****
X--- 314,322 ----
X  		otmp->owornmask &= ~W_ARMH;
X  		rel_1_obj(mon, otmp);
X  	    }
X+ 	}
X+ 	if (nohands(mdat) || verysmall(mdat) || slithy(mdat) ||
X+ 	    mdat->mlet == S_CENTAUR) {
X  	    if (otmp = which_armor(mon, W_ARMF)) {
X  		if (vis) {
X  		    if (is_whirly(mon->data))
X*** /tmp/da11554	Tue Jun  1 16:16:47 1993
X--- src/zap.c	Fri May 28 16:20:14 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)zap.c	3.1	92/10/21	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)zap.c	3.1	93/05/17	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 19,25 ****
X  extern boolean m_using;
X  #endif
X  
X- static boolean FDECL(obj_resists, (struct obj *));
X  static boolean FDECL(obj_shudders, (struct obj *));
X  static void FDECL(polyuse, (struct obj*, int, int));
X  static void FDECL(do_osshock, (struct obj *));
X--- 19,24 ----
X***************
X*** 49,55 ****
X  #define ZT_SPELL(x)		(10+(x))
X  #define ZT_BREATH(x)	(20+(x))
X  
X! const char *fl[]= {
X  	"magic missile",	/* Wands must be 0-9 */
X  	"bolt of fire",
X  	"bolt of cold",
X--- 48,54 ----
X  #define ZT_SPELL(x)		(10+(x))
X  #define ZT_BREATH(x)	(20+(x))
X  
X! const char *flash_types[] = {		/* also used in buzzmu(mcastu.c) */
X  	"magic missile",	/* Wands must be 0-9 */
X  	"bolt of fire",
X  	"bolt of cold",
X***************
X*** 93,104 ****
X  register struct obj *otmp;
X  {
X  	register boolean wake = FALSE;
X  #ifdef MULDGN
X  	boolean dbldam = (pl_character[0] == 'K') && u.uhave.questart;
X  #endif
X  	register int dmg;
X  
X! 	switch(otmp->otyp) {
X  	case WAN_STRIKING:
X  	case SPE_FORCE_BOLT:
X  		wake = TRUE;
X--- 92,104 ----
X  register struct obj *otmp;
X  {
X  	register boolean wake = FALSE;
X+ 	register int otyp = otmp->otyp;
X  #ifdef MULDGN
X  	boolean dbldam = (pl_character[0] == 'K') && u.uhave.questart;
X  #endif
X  	register int dmg;
X  
X! 	switch(otyp) {
X  	case WAN_STRIKING:
X  	case SPE_FORCE_BOLT:
X  		wake = TRUE;
X***************
X*** 107,118 ****
X  #ifdef MULDGN
X  			if(dbldam) dmg *= 2;
X  #endif
X! 			hit((otmp->otyp == WAN_STRIKING) ? "wand" :
X! 						"spell", mtmp, exclam(dmg));
X  			(void) resist(mtmp, otmp->oclass, dmg, TELL);
X! 		} else miss((otmp->otyp == WAN_STRIKING) ? "wand" :
X! 						"spell", mtmp);
X! 		makeknown(otmp->otyp);
X  		break;
X  	case WAN_SLOW_MONSTER:
X  	case SPE_SLOW_MONSTER:
X--- 107,117 ----
X  #ifdef MULDGN
X  			if(dbldam) dmg *= 2;
X  #endif
X! 			hit((otyp == WAN_STRIKING) ? "wand" : "spell",
X! 			    mtmp, exclam(dmg));
X  			(void) resist(mtmp, otmp->oclass, dmg, TELL);
X! 		} else miss((otyp == WAN_STRIKING) ? "wand" : "spell", mtmp);
X! 		makeknown(otyp);
X  		break;
X  	case WAN_SLOW_MONSTER:
X  	case SPE_SLOW_MONSTER:
X***************
X*** 153,159 ****
X  		    if (!rn2(25)) {
X  			if (canseemon(mtmp)) {
X  			    pline("%s shudders!", Monnam(mtmp));
X! 			    makeknown(otmp->otyp);
X  			}
X  			/* no corpse after system shock */
X  			xkilled(mtmp, 3);
X--- 152,158 ----
X  		    if (!rn2(25)) {
X  			if (canseemon(mtmp)) {
X  			    pline("%s shudders!", Monnam(mtmp));
X! 			    makeknown(otyp);
X  			}
X  			/* no corpse after system shock */
X  			xkilled(mtmp, 3);
X***************
X*** 160,166 ****
X  		    }
X  		    else if (newcham(mtmp, (struct permonst *)0) )
X  			if (!Hallucination && (!Blind || sensemon(mtmp)))
X! 			    makeknown(otmp->otyp);
X  		}
X  		break;
X  	case WAN_CANCELLATION:
X--- 159,165 ----
X  		    }
X  		    else if (newcham(mtmp, (struct permonst *)0) )
X  			if (!Hallucination && (!Blind || sensemon(mtmp)))
X! 			    makeknown(otyp);
X  		}
X  		break;
X  	case WAN_CANCELLATION:
X***************
X*** 188,194 ****
X  	case WAN_NOTHING:
X  		break;
X  	case WAN_PROBING:
X! 		makeknown(otmp->otyp);
X  		mstatusline(mtmp);
X  		break;
X  	case WAN_OPENING:
X--- 187,193 ----
X  	case WAN_NOTHING:
X  		break;
X  	case WAN_PROBING:
X! 		makeknown(otyp);
X  		mstatusline(mtmp);
X  		break;
X  	case WAN_OPENING:
X***************
X*** 198,211 ****
X  				else pline("%s opens its mouth!", Monnam(mtmp));
X  			}
X  			expels(mtmp, mtmp->data, TRUE);
X  			break;
X  		}
X  	case WAN_LOCKING:
X  	case SPE_KNOCK:
X  	case SPE_WIZARD_LOCK:
X  		break;
X  	default:
X! 		impossible("What an interesting effect (%u)", otmp->otyp);
X  	}
X  	if(wake) {
X  	    if(mtmp->mhp > 0) {
X--- 197,223 ----
X  				else pline("%s opens its mouth!", Monnam(mtmp));
X  			}
X  			expels(mtmp, mtmp->data, TRUE);
X+ 		}
X  			break;
X+ 	case SPE_HEALING:
X+ 	case SPE_EXTRA_HEALING:
X+ 		mtmp->mhp += (otyp == SPE_HEALING) ? rnd(8) : d(2,8)+2;
X+ 		if (mtmp->mhp > mtmp->mhpmax) 
X+ 		    mtmp->mhp = mtmp->mhpmax;
X+ 		if (canseemon(mtmp))
X+ 		    pline(otyp == SPE_HEALING ? "%s begins to look better." :
X+ 			  "%s looks much better.", Monnam(mtmp));
X+ 		if (mtmp->mtame || mtmp->mpeaceful) {		    
X+ 		    adjalign((pl_character[0] == 'H') ? 1 :
X+ 			     sgn(u.ualign.type));
X  		}
X+  		break;
X  	case WAN_LOCKING:
X  	case SPE_KNOCK:
X  	case SPE_WIZARD_LOCK:
X  		break;
X  	default:
X! 		impossible("What an interesting effect (%u)", otyp);
X  	}
X  	if(wake) {
X  	    if(mtmp->mhp > 0) {
X***************
X*** 399,407 ****
X  	uncurse(obj);
X  }
X  
X! static boolean
X! obj_resists(obj)
X  struct obj *obj;
X  {
X  	if (obj->otyp == AMULET_OF_YENDOR ||
X  	    obj->otyp == SPE_BOOK_OF_THE_DEAD ||
X--- 411,420 ----
X  	uncurse(obj);
X  }
X  
X! boolean
X! obj_resists(obj, ochance, achance)
X  struct obj *obj;
X+ int ochance, achance;	/* percent chance for ordinary objects, artifacts */
X  {
X  	if (obj->otyp == AMULET_OF_YENDOR ||
X  	    obj->otyp == SPE_BOOK_OF_THE_DEAD ||
X***************
X*** 410,418 ****
X  	    (obj->otyp == CORPSE && is_rider(&mons[obj->corpsenm]))) {
X  		return TRUE;
X  	} else {
X! 		int chance = rn2(20);
X! 		/* artifacts resist 95% of the time; normal objects 5% */
X! 		return (obj->oartifact ? !!chance : !chance);
X  	}
X  }
X  
X--- 423,431 ----
X  	    (obj->otyp == CORPSE && is_rider(&mons[obj->corpsenm]))) {
X  		return TRUE;
X  	} else {
X! 		int chance = rn2(100);
X! 
X! 		return (chance < (obj->oartifact ? achance : ochance));
X  	}
X  }
X  
X***************
X*** 475,481 ****
X  {
X  	struct permonst *mdat = (struct permonst *)0;
X  	struct monst *mtmp;
X! 	char *material;
X  	int pm_index;
X  
X  	/* no golems if you zap only one object -- not enough stuff */
X--- 488,494 ----
X  {
X  	struct permonst *mdat = (struct permonst *)0;
X  	struct monst *mtmp;
X! 	const char *material;
X  	int pm_index;
X  
X  	/* no golems if you zap only one object -- not enough stuff */
X***************
X*** 581,593 ****
X  	register int res = 1;
X  	struct obj *otmp2;
X  
X! 	if(obj == uball || obj == uchain)
X  		res = 0;
X! 	else
X  	switch(otmp->otyp) {
X  	case WAN_POLYMORPH:
X  	case SPE_POLYMORPH:
X! 		if (obj_resists(obj)) {
X  		    res = 0;
X  		    break;
X  		} else if (obj_shudders(obj)) {
X--- 594,613 ----
X  	register int res = 1;
X  	struct obj *otmp2;
X  
X! 	if (obj == uball) {
X  		res = 0;
X! 	} else if (obj == uchain) {
X! 		if (otmp->otyp == WAN_OPENING || otmp->otyp == SPE_KNOCK) {
X! 		    unpunish();
X! 		    res = 1;
X! 		    makeknown(otmp->otyp);
X! 		} else
X! 		    res = 0;
X! 	} else
X  	switch(otmp->otyp) {
X  	case WAN_POLYMORPH:
X  	case SPE_POLYMORPH:
X! 		if (obj_resists(obj, 5, 95)) {
X  		    res = 0;
X  		    break;
X  		} else if (obj_shudders(obj)) {
X***************
X*** 646,651 ****
X--- 666,672 ----
X  			otmp2->otyp = LOW_BOOTS;
X  			otmp2->oclass = ARMOR_CLASS;
X  			otmp2->spe = 0;
X+ 			otmp2->oeroded = 0;
X  			otmp2->oerodeproof = TRUE;
X  			otmp2->quan = 1L;
X  			otmp2->cursed = FALSE;
X***************
X*** 653,659 ****
X  		}
X  
X  		/* no box contents --KAA */
X! 		if (Is_container(otmp2) || otmp2->otyp == STATUE)
X  			delete_contents(otmp2);
X  
X  		/* 'n' merged objects may be fused into 1 object */
X--- 674,680 ----
X  		}
X  
X  		/* no box contents --KAA */
X! 		if (Has_contents(otmp2))
X  			delete_contents(otmp2);
X  
X  		/* 'n' merged objects may be fused into 1 object */
X***************
X*** 676,682 ****
X  		          shop_keeper(*in_rooms(obj->ox, obj->oy, SHOPBASE));
X  
X  		    if ((!obj->no_charge ||
X! 			 (Is_container(obj) &&
X  			    (contained_cost(obj, shkp, 0L, FALSE) != 0L)))
X  		       && inhishop(shkp)) {
X  		        if(shkp->mpeaceful) {
X--- 697,703 ----
X  		          shop_keeper(*in_rooms(obj->ox, obj->oy, SHOPBASE));
X  
X  		    if ((!obj->no_charge ||
X! 			 (Has_contents(obj) &&
X  			    (contained_cost(obj, shkp, 0L, FALSE) != 0L)))
X  		       && inhishop(shkp)) {
X  		        if(shkp->mpeaceful) {
X***************
X*** 699,711 ****
X  			fracture_rock(obj);
X  		else if (obj->otyp == STATUE)
X  			(void) break_statue(obj);
X! 		else
X  			res = 0;
X  		makeknown(otmp->otyp);
X  		break;
X  	case WAN_CANCELLATION:
X  	case SPE_CANCELLATION:
X  		cancel_item(obj);
X  		break;
X  	case WAN_TELEPORTATION:
X  	case SPE_TELEPORT_AWAY:
X--- 720,745 ----
X  			fracture_rock(obj);
X  		else if (obj->otyp == STATUE)
X  			(void) break_statue(obj);
X! 		else {
X! 			(void)breaks(obj, FALSE);
X  			res = 0;
X+ 		}
X  		makeknown(otmp->otyp);
X  		break;
X+ 	case WAN_DIGGING:
X+ 	case SPE_DIG:
X+ 		/* vaporize boulders */
X+ 		if (obj->otyp == BOULDER) {
X+ 			delobj(obj);
X+ 			res = 0;
X+ 		}
X+ 		break;
X  	case WAN_CANCELLATION:
X  	case SPE_CANCELLATION:
X  		cancel_item(obj);
X+ #ifdef TEXTCOLOR
X+ 		newsym(obj->ox,obj->oy);	/* might change color */
X+ #endif
X  		break;
X  	case WAN_TELEPORTATION:
X  	case SPE_TELEPORT_AWAY:
X***************
X*** 721,734 ****
X  		break;
X  	case WAN_OPENING:
X  	case SPE_KNOCK:
X- 		/* Zap it at the chain, not the ball */
X- 		if (obj == uchain) {
X- 			unpunish();
X- 			res = 1;
X- 			makeknown(obj->otyp);
X- 			break;
X- 		}
X- 		/* fall through */
X  	case WAN_LOCKING:
X  	case SPE_WIZARD_LOCK:
X  		if(Is_box(obj))
X--- 755,760 ----
X***************
X*** 735,742 ****
X  			res = boxlock(obj, otmp);
X  		else
X  			res = 0;
X! 		if (res /* && obj->oclass == WAND_CLASS */)
X! 			makeknown(obj->otyp);
X  		break;
X  	case WAN_SLOW_MONSTER:		/* no effect on objects */
X  	case SPE_SLOW_MONSTER:
X--- 761,768 ----
X  			res = boxlock(obj, otmp);
X  		else
X  			res = 0;
X! 		if (res /* && otmp->oclass == WAND_CLASS */)
X! 			makeknown(otmp->otyp);
X  		break;
X  	case WAN_SLOW_MONSTER:		/* no effect on objects */
X  	case SPE_SLOW_MONSTER:
X***************
X*** 743,748 ****
X--- 769,776 ----
X  	case WAN_SPEED_MONSTER:
X  	case WAN_NOTHING:
X  	case WAN_PROBING:
X+ 	case SPE_HEALING:
X+ 	case SPE_EXTRA_HEALING:
X  		res = 0;
X  		break;
X  	default:
X***************
X*** 990,996 ****
X  		case SPE_CANCELLATION:
X  		    cancel_monst(&youmonst, obj, TRUE, FALSE, TRUE);
X  		    break;
X! 	       case WAN_MAKE_INVISIBLE: {
X  		    /* have to test before changing HInvis but must change
X  		     * HInvis before doing newsym().
X  		     */
X--- 1018,1024 ----
X  		case SPE_CANCELLATION:
X  		    cancel_monst(&youmonst, obj, TRUE, FALSE, TRUE);
X  		    break;
X! 		case WAN_MAKE_INVISIBLE: {
X  		    /* have to test before changing HInvis but must change
X  		     * HInvis before doing newsym().
X  		     */
X***************
X*** 1006,1012 ****
X  		    }
X  		    break;
X  		}
X! 	       case WAN_SPEED_MONSTER:
X  		    if (!(Fast & INTRINSIC)) {
X  			You("seem to be moving faster.");
X  			makeknown(WAN_SPEED_MONSTER);
X--- 1034,1040 ----
X  		    }
X  		    break;
X  		}
X! 		case WAN_SPEED_MONSTER:
X  		    if (!(Fast & INTRINSIC)) {
X  			You("seem to be moving faster.");
X  			makeknown(WAN_SPEED_MONSTER);
X***************
X*** 1014,1020 ****
X  		    }
X  		    Fast |= FROMOUTSIDE;
X  		    break;
X! 	       case WAN_SLEEP:
X  		    makeknown(WAN_SLEEP);
X  		case SPE_SLEEP:
X  		    if(Sleep_resistance) {
X--- 1042,1048 ----
X  		    }
X  		    Fast |= FROMOUTSIDE;
X  		    break;
X! 		case WAN_SLEEP:
X  		    makeknown(WAN_SLEEP);
X  		case SPE_SLEEP:
X  		    if(Sleep_resistance) {
X***************
X*** 1067,1075 ****
X  		    }
X  #endif
X  		    break;
X  		case SPE_DIG:
X  		case SPE_DETECT_UNSEEN:
X- 		case WAN_DIGGING:
X  		case WAN_NOTHING:
X  		case WAN_OPENING:
X  		case WAN_LOCKING:
X--- 1095,1110 ----
X  		    }
X  #endif
X  		    break;
X+ 		case SPE_HEALING:
X+ 		case SPE_EXTRA_HEALING:
X+ 		    healup(obj->otyp == SPE_HEALING ? rnd(8) : d(2,8)+2,
X+ 			   0, FALSE, FALSE);
X+ 		    You(obj->otyp == SPE_HEALING ? "begin to feel better." :
X+ 			"feel a fair bit better.");
X+ 		    break;
X+ 		case WAN_DIGGING:
X  		case SPE_DIG:
X  		case SPE_DETECT_UNSEEN:
X  		case WAN_NOTHING:
X  		case WAN_OPENING:
X  		case WAN_LOCKING:
X***************
X*** 1712,1721 ****
X  	return(cnt);
X  }
X  
X! /* type == 0 to 9     : you shooting a wand */
X! /* type == 10 to 19   : you casting a spell */
X! /* type == 20 to 29   : you breathing as a monster */
X! /* type == -10 to -19   : monster casting spell */
X  /* type == -20 to -29 : monster breathing at you */
X  /* type == -30 to -39 : monster shooting a wand (MUSE only) */
X  /* called with dx = dy = 0 with vertical bolts */
X--- 1747,1756 ----
X  	return(cnt);
X  }
X  
X! /* type ==   0 to   9 : you shooting a wand */
X! /* type ==  10 to  19 : you casting a spell */
X! /* type ==  20 to  29 : you breathing as a monster */
X! /* type == -10 to -19 : monster casting spell */
X  /* type == -20 to -29 : monster breathing at you */
X  /* type == -30 to -39 : monster shooting a wand (MUSE only) */
X  /* called with dx = dy = 0 with vertical bolts */
X***************
X*** 1730,1739 ****
X      register xchar lsx, lsy;
X      struct monst *mon;
X      boolean bodyhit = FALSE, shopdamage = FALSE;
X  #ifdef MUSE
X!     register const char *fltxt = fl[(type <= -30) ? abstype : abs(type)];
X  #else
X!     register const char *fltxt = fl[abs(type)];
X  #endif
X      if(u.uswallow) {
X  	register int tmp;
X--- 1765,1776 ----
X      register xchar lsx, lsy;
X      struct monst *mon;
X      boolean bodyhit = FALSE, shopdamage = FALSE;
X+     register const char *fltxt;
X+ 
X  #ifdef MUSE
X!     fltxt = flash_types[(type <= -30) ? abstype : abs(type)];
X  #else
X!     fltxt = flash_types[abs(type)];
X  #endif
X      if(u.uswallow) {
X  	register int tmp;
X***************
X*** 1774,1804 ****
X  	    if (type >= 0) mon->data->mflags3 &= ~M3_WAITMASK;
X  	    if (rnd(20) < 18 + find_mac(mon)) {
X  #ifdef MUSE
X! 		struct obj *orefl = which_armor(mon, W_ARMS);
X! 
X! 		if (orefl && orefl->otyp == SHIELD_OF_REFLECTION) {
X  		    if(cansee(mon->mx,mon->my)) {
X  			hit(fltxt, mon, exclam(0));
X! 			pline("But it reflects from %s shield!",
X! 			      s_suffix(mon_nam(mon)));
X! 			makeknown(SHIELD_OF_REFLECTION);
X! 			shieldeff(sx, sy);
X  		    }
X- 
X  		    dx = -dx;
X  		    dy = -dy;
X- 		} else if ((orefl = which_armor(mon, W_AMUL)) &&
X- 					orefl->otyp == AMULET_OF_REFLECTION) {
X- 		    if(cansee(mon->mx,mon->my)) {
X- 			hit(fltxt, mon, exclam(0));
X- 			pline("But it reflects from %s amulet!",
X- 			      s_suffix(mon_nam(mon)));
X- 			makeknown(AMULET_OF_REFLECTION);
X- 			shieldeff(sx, sy);
X- 		    }
X- 
X- 		    dx = -dx;
X- 		    dy = -dy;
X  		} else
X  #endif
X  		{
X--- 1811,1824 ----
X  	    if (type >= 0) mon->data->mflags3 &= ~M3_WAITMASK;
X  	    if (rnd(20) < 18 + find_mac(mon)) {
X  #ifdef MUSE
X! 		if (mon_reflects(mon, "")) {
X  		    if(cansee(mon->mx,mon->my)) {
X  			hit(fltxt, mon, exclam(0));
X! 			shieldeff(mon->mx, mon->my);
X! 			(void) mon_reflects(mon, "But it reflects from %s %s!");
X  		    }
X  		    dx = -dx;
X  		    dy = -dy;
X  		} else
X  #endif
X  		{
X***************
X*** 1820,1827 ****
X  		        mon->mhp = mon->mhpmax;
X  			break; /* Out of while loop */
X  		    }
X! 		    if(mon->data == &mons[PM_DEATH] &&
X! 				            abs(type)%10 == ZT_DEATH) {
X  		        if(cansee(mon->mx,mon->my)) {
X  			    hit(fltxt, mon, exclam(tmp));
X  		            pline("Death absorbs the deadly %s!",
X--- 1840,1846 ----
X  		        mon->mhp = mon->mhpmax;
X  			break; /* Out of while loop */
X  		    }
X! 		    if(mon->data == &mons[PM_DEATH] && abstype == ZT_DEATH) {
X  		        if(cansee(mon->mx,mon->my)) {
X  			    hit(fltxt, mon, exclam(tmp));
X  		            pline("Death absorbs the deadly %s!",
X***************
X*** 1983,1990 ****
X  		    else if(Antimagic) {
X  			shieldeff(sx, sy);
X  			You("aren't affected.");
X! 		    } else
X! 			u.uhp = -1;
X  		    break;
X  		case ZT_LIGHTNING:
X  		    if (Shock_resistance) {
X--- 2002,2010 ----
X  		    else if(Antimagic) {
X  			shieldeff(sx, sy);
X  			You("aren't affected.");
X! 			break;
X! 		    }
X! 		    u.uhp = -1;
X  		    break;
X  		case ZT_LIGHTNING:
X  		    if (Shock_resistance) {
X***************
X*** 2078,2083 ****
X--- 2098,2127 ----
X  	   	       abstype == ZT_DEATH ? "disintegrate" : "destroy");
X  }
X  
X+ void
X+ melt_ice(x, y)
X+ xchar x, y;
X+ {
X+ 	struct rm *lev = &levl[x][y];
X+ 
X+ 	if (lev->typ == DRAWBRIDGE_UP)
X+ 	    lev->drawbridgemask &= ~DB_ICE;	/* revert to DB_MOAT */
X+ 	else {	/* lev->typ == ICE */
X+ #ifdef STUPID
X+ 	    if (lev->icedpool == ICED_POOL) lev->typ = POOL;
X+ 	    else lev->typ = MOAT;
X+ #else
X+ 	    lev->typ = (lev->icedpool == ICED_POOL ? POOL : MOAT);
X+ #endif
X+ 	    lev->icedpool = 0;
X+ 	}
X+ 	unearth_objs(x, y);
X+ 	newsym(x,y);
X+ 	if (cansee(x,y)) Norep("The ice crackles and melts.");
X+ 	if (x == u.ux && y == u.uy)
X+ 		spoteffects();	/* possibly drown, notice objects */
X+ }
X+ 
X  /* Burn floor scrolls, evaporate pools, etc...  in a single square.  Used
X   * both for normal bolts of fire, cold, etc... and for fireballs.
X   * Sets shopdamage to TRUE if a shop door is destroyed, and returns the 
X***************
X*** 2096,2116 ****
X  
X  	if(abstype == ZT_FIRE) {
X  	    if(is_ice(x, y)) {
X! 		if (lev->typ == DRAWBRIDGE_UP)
X! 		    lev->drawbridgemask &= ~DB_ICE;	/* revert to DB_MOAT */
X! 		else {	/* lev->typ == ICE */
X! #ifdef STUPID
X! 		    if (lev->icedpool == ICED_POOL) lev->typ = POOL;
X! 		    else lev->typ = MOAT;
X! #else
X! 		    lev->typ = (lev->icedpool == ICED_POOL ? POOL : MOAT);
X! #endif
X! 		    lev->icedpool = 0;
X! 		}
X! 		newsym(x,y);
X! 		Norep("The ice crackles and melts.");
X! 		if (x == u.ux && y == u.uy)
X! 			spoteffects();	/* possibly drown */
X  	    } else if(is_pool(x,y)) {
X  		const char *msgtxt = "You hear hissing gas.";
X  		if(lev->typ != POOL) {	/* MOAT or DRAWBRIDGE_UP */
X--- 2140,2146 ----
X  
X  	if(abstype == ZT_FIRE) {
X  	    if(is_ice(x, y)) {
X! 		melt_ice(x, y);
X  	    } else if(is_pool(x,y)) {
X  		const char *msgtxt = "You hear hissing gas.";
X  		if(lev->typ != POOL) {	/* MOAT or DRAWBRIDGE_UP */
X***************
X*** 2121,2127 ****
X  		    rangemod -= 3;
X  		    lev->typ = ROOM;
X  		    ttmp = maketrap(x, y, PIT);
X! 		    ttmp->tseen = 1;
X  		    if (cansee(x,y)) msgtxt = "The water evaporates.";
X  		}
X  		Norep(msgtxt);
X--- 2151,2157 ----
X  		    rangemod -= 3;
X  		    lev->typ = ROOM;
X  		    ttmp = maketrap(x, y, PIT);
X! 		    if (ttmp) ttmp->tseen = 1;
X  		    if (cansee(x,y)) msgtxt = "The water evaporates.";
X  		}
X  		Norep(msgtxt);
X***************
X*** 2152,2165 ****
X  				    (lev->typ == POOL ? ICED_POOL : ICED_MOAT);
X  			lev->typ = (lava ? ROOM : ICE);
X  		    }
X! 		    /*
X! 		     * Not perfect: There could be stuff on the bottom.  If
X! 		     * we leave it here, it'll pop to the surface which is
X! 		     * strange, so just destroy all the objects at this location.
X! 		     * A better solution requires major changes (as usual).
X! 		     */
X! 		    if(OBJ_AT(x,y))
X! 			delallobj(x,y);
X  		    if(cansee(x,y)) {
X  			if(moat)
X  				Norep("The moat is bridged with ice!");
X--- 2182,2188 ----
X  				    (lev->typ == POOL ? ICED_POOL : ICED_MOAT);
X  			lev->typ = (lava ? ROOM : ICE);
X  		    }
X! 		    bury_objs(x,y);
X  		    if(cansee(x,y)) {
X  			if(moat)
X  				Norep("The moat is bridged with ice!");
X***************
X*** 2295,2313 ****
X  	} while(!goodpos(tx,ty,(struct monst *)0, (struct permonst *)0));
X  	freeobj(obj);
X  	if (flooreffects(obj, tx, ty, "fall"))
X!  		return;
X! 	if(costly_spot(otx, oty) && (!costly_spot(tx, ty) ||
X! 				     !index(in_rooms(tx, ty, 0),
X! 					    *in_rooms(otx, oty, 0)))) {
X  		if(costly_spot(u.ux, u.uy) &&
X  			    index(u.urooms, *in_rooms(otx, oty, 0)))
X  		    addtobill(obj, FALSE, FALSE, FALSE);
X  		else (void)stolen_value(obj, otx, oty, FALSE, FALSE);
X  	}
X  	obj->nobj = fobj;
X  	fobj = obj;
X  	place_object(obj, tx, ty);
X- 	newsym(otx, oty);
X  	newsym(tx,ty);
X  }
X  
X--- 2318,2340 ----
X  	} while(!goodpos(tx,ty,(struct monst *)0, (struct permonst *)0));
X  	freeobj(obj);
X  	if (flooreffects(obj, tx, ty, "fall"))
X! 		return;
X! 	if (otx == 0 && oty == 0) {
X! 	    ;	/* fell through a trapdoor; no update of old loc needed */
X! 	} else {
X! 	    if (costly_spot(otx, oty)
X! 	      && (!costly_spot(tx, ty) ||
X! 		  !index(in_rooms(tx, ty, 0), *in_rooms(otx, oty, 0)))) {
X  		if(costly_spot(u.ux, u.uy) &&
X  			    index(u.urooms, *in_rooms(otx, oty, 0)))
X  		    addtobill(obj, FALSE, FALSE, FALSE);
X  		else (void)stolen_value(obj, otx, oty, FALSE, FALSE);
X+ 	    }
X+ 	    newsym(otx, oty);	/* update old location */
X  	}
X  	obj->nobj = fobj;
X  	fobj = obj;
X  	place_object(obj, tx, ty);
X  	newsym(tx,ty);
X  }
X  
END_OF_FILE
if test 56999 -ne `wc -c <'patches02i'`; then
    echo shar: \"'patches02i'\" unpacked with wrong size!
fi
# end of 'patches02i'
echo shar: End of archive 3 \(of 33\).
cp /dev/null ark3isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 33 archives.
    echo "Now execute ./patchit.sh"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
