Path: uunet!news.tek.com!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v17i095:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Patch2t/33
Date: 11 Jun 1993 00:14:48 GMT
Organization: Tektronix, Inc, Redmond, OR, USA
Lines: 2031
Approved: billr@saab.CNA.TEK.COM
Message-ID: <1v8ipo$j5m@ying.cna.tek.com>
NNTP-Posting-Host: saab.cna.tek.com
Xref: uunet comp.sources.games:1781

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 17, Issue 95
Archive-name: nethack31/Patch2t
Patch-To: nethack31: Volume 16, Issue 1-116
Environment: Amiga, Atari, Mac, MS-DOS, Windows-NT, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 20 (of 33)."
# Contents:  patches02g
# Wrapped by billr@saab on Thu Jun 10 16:55:05 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'patches02g' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'patches02g'\" to \"'patches02g.orig'\"
  mv -f 'patches02g' 'patches02g.orig'
fi
echo shar: Extracting \"'patches02g'\" \(52366 characters\)
sed "s/^X//" >'patches02g' <<'END_OF_FILE'
X*** /tmp/da11242	Tue Jun  1 16:15:08 1993
X--- src/pickup.c	Tue May 11 13:53:18 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)pickup.c	3.1	93/02/16	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)pickup.c	3.1	93/04/11	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 12,18 ****
X  static void FDECL(simple_look, (struct obj *,BOOLEAN_P));
X  static boolean FDECL(query_classes, (char *,boolean *,boolean *,
X  			     const char *,struct obj *,BOOLEAN_P,BOOLEAN_P));
X! static boolean FDECL(pickup_object, (struct obj *,struct obj *));
X  static boolean FDECL(mbag_explodes, (struct obj *,int));
X  STATIC_PTR int FDECL(in_container,(struct obj *));
X  STATIC_PTR int FDECL(ck_bag,(struct obj *));
X--- 12,19 ----
X  static void FDECL(simple_look, (struct obj *,BOOLEAN_P));
X  static boolean FDECL(query_classes, (char *,boolean *,boolean *,
X  			     const char *,struct obj *,BOOLEAN_P,BOOLEAN_P));
X! static void FDECL(check_here, (BOOLEAN_P));
X! static int FDECL(pickup_object, (struct obj *,struct obj *));
X  static boolean FDECL(mbag_explodes, (struct obj *,int));
X  STATIC_PTR int FDECL(in_container,(struct obj *));
X  STATIC_PTR int FDECL(ck_bag,(struct obj *));
X***************
X*** 104,111 ****
X  }
X  
X  static boolean
X! query_classes(olets, one_at_a_time, everything, action, objs, here, incl_gold)
X! char olets[];
X  boolean *one_at_a_time, *everything;
X  const char *action;
X  struct obj *objs;
X--- 105,112 ----
X  }
X  
X  static boolean
X! query_classes(oclasses, one_at_a_time, everything, action, objs, here, incl_gold)
X! char oclasses[];
X  boolean *one_at_a_time, *everything;
X  const char *action;
X  struct obj *objs;
X***************
X*** 112,128 ****
X  boolean here, incl_gold;
X  {
X  	char ilets[20], inbuf[BUFSZ];
X! 	int iletct, oletct;
X  	char qbuf[QBUFSZ];
X  
X! 	olets[oletct = 0] = '\0';
X  	*one_at_a_time = *everything = FALSE;
X  	iletct = collect_obj_classes(ilets, objs, here, incl_gold);
X  	if (iletct == 0) {
X  		return FALSE;
X  	} else if (iletct == 1) {
X! 		olets[0] = def_char_to_objclass(ilets[0]);
X! 		olets[1] = '\0';
X  	} else  {	/* more than one choice available */
X  		const char *where = 0;
X  		register char sym, oc_of_sym, *p;
X--- 113,129 ----
X  boolean here, incl_gold;
X  {
X  	char ilets[20], inbuf[BUFSZ];
X! 	int iletct, oclassct;
X  	char qbuf[QBUFSZ];
X  
X! 	oclasses[oclassct = 0] = '\0';
X  	*one_at_a_time = *everything = FALSE;
X  	iletct = collect_obj_classes(ilets, objs, here, incl_gold);
X  	if (iletct == 0) {
X  		return FALSE;
X  	} else if (iletct == 1) {
X! 		oclasses[0] = def_char_to_objclass(ilets[0]);
X! 		oclasses[1] = '\0';
X  	} else  {	/* more than one choice available */
X  		const char *where = 0;
X  		register char sym, oc_of_sym, *p;
X***************
X*** 133,139 ****
X  		ilets[iletct++] = (objs == invent ? 'i' : ':');
X  		ilets[iletct] = '\0';
X  ask_again:
X! 		olets[oletct = 0] = '\0';
X  		*one_at_a_time = *everything = FALSE;
X  		Sprintf(qbuf,"What kinds of thing do you want to %s? [%s]",
X  			action, ilets);
X--- 134,140 ----
X  		ilets[iletct++] = (objs == invent ? 'i' : ':');
X  		ilets[iletct] = '\0';
X  ask_again:
X! 		oclasses[oclassct = 0] = '\0';
X  		*one_at_a_time = *everything = FALSE;
X  		Sprintf(qbuf,"What kinds of thing do you want to %s? [%s]",
X  			action, ilets);
X***************
X*** 154,161 ****
X  		    } else {
X  			oc_of_sym = def_char_to_objclass(sym);
X  			if (index(ilets,sym)) {
X! 			    olets[oletct++] = oc_of_sym;
X! 			    olets[oletct] = '\0';
X  			} else {
X  			    if (!where)
X  				where = !strcmp(action,"pick up")  ? "here" :
X--- 155,162 ----
X  		    } else {
X  			oc_of_sym = def_char_to_objclass(sym);
X  			if (index(ilets,sym)) {
X! 			    oclasses[oclassct++] = oc_of_sym;
X! 			    oclasses[oclassct] = '\0';
X  			} else {
X  			    if (!where)
X  				where = !strcmp(action,"pick up")  ? "here" :
X***************
X*** 168,178 ****
X  			}
X  		    }
X  		}
X! 		if (!oletct && !*everything) *one_at_a_time = TRUE;
X  	}
X  	return TRUE;
X  }
X  
X  void
X  pickup(all)
X  int all;	/* all >= 0 => yes/no; < 0 => -count */
X--- 169,209 ----
X  			}
X  		    }
X  		}
X! 		if (!oclassct && !*everything) *one_at_a_time = TRUE;
X  	}
X  	return TRUE;
X  }
X  
X+ /* look at the objects at our location, unless there are too many of them */
X+ static void
X+ check_here(picked_some)
X+ boolean picked_some;
X+ {
X+ 	register struct obj *obj;
X+ 	register int ct = 0;
X+ 
X+ 	/* count the objects here */
X+ 	for (obj = level.objects[u.ux][u.uy]; obj; obj = obj->nexthere) {
X+ 	    if (obj != uchain)
X+ 		ct++;
X+ 	}
X+ 
X+ 	/* If there are objects here, take a look. */
X+ 	if (ct) {
X+ 	    if (flags.run) nomul(0);
X+ 	    flush_screen(1);
X+ 	    if (ct < 5) {
X+ 		(void) dolook();
X+ 	    } else {
X+ 		read_engr_at(u.ux,u.uy);
X+ 		pline("There are several %sobjects here.",
X+ 		      picked_some ? "more " : "");
X+ 	    }
X+ 	} else {
X+ 	    read_engr_at(u.ux,u.uy);
X+ 	}
X+ }
X+ 
X  void
X  pickup(all)
X  int all;	/* all >= 0 => yes/no; < 0 => -count */
X***************
X*** 179,192 ****
X  {
X  	register struct obj *obj;
X  	struct obj *obj2, *objx;
X! 	boolean all_of_a_type = FALSE, selective = FALSE;
X! 	char olets[20];
X  	long count;
X  
X  	count = (all < 0) ? (-1L * all) : 0L;
X  	if (count) all = 0;
X  
X! 	if(Levitation && !Is_airlevel(&u.uz) && !Is_waterlevel(&u.uz)) {
X  		if ((multi && !flags.run) || (all && !flags.pickup))
X  			read_engr_at(u.ux,u.uy);
X  		return;
X--- 210,230 ----
X  {
X  	register struct obj *obj;
X  	struct obj *obj2, *objx;
X! 	boolean all_of_a_type, selective;
X! 	char oclasses[20];
X  	long count;
X+ 	int pick, pick_count = 0;
X  
X  	count = (all < 0) ? (-1L * all) : 0L;
X  	if (count) all = 0;
X  
X! 	if (all && (flags.nopick || !OBJ_AT(u.ux, u.uy) ||
X! 			(is_pool(u.ux, u.uy) && !Underwater))) {
X! 		read_engr_at(u.ux, u.uy);
X! 		return;
X! 	}
X! 
X! 	if (Levitation && !Is_airlevel(&u.uz) && !Is_waterlevel(&u.uz)) {
X  		if ((multi && !flags.run) || (all && !flags.pickup))
X  			read_engr_at(u.ux,u.uy);
X  		return;
X***************
X*** 197,276 ****
X  	 * teleported onto the object.  They shouldn't pick it up.
X  	 */
X  	if ((multi && !flags.run) || (all && !flags.pickup)) {
X! 		int ct = 0;
X! 
X! 		for (obj = level.objects[u.ux][u.uy]; obj;
X! 						 obj = obj->nexthere)
X! 			if(obj != uchain)
X! 				ct++;
X! 
X! 		/* If there are objects here, take a look.
X! 		 */
X! 		if (ct) {
X! 			if (flags.run)
X! 				nomul(0);
X! 			flush_screen(1);
X! 			if (ct < 5)
X! 				(void) dolook();
X! 			else {
X! 				read_engr_at(u.ux,u.uy);
X! 				pline("There are several objects here.");
X! 			}
X! 		} else read_engr_at(u.ux,u.uy);
X  		return;
X  	}
X  
X! 	/* check for more than one object */
X! 	if(!all) {
X  		register int ct = 0;
X  
X! 		for(obj = level.objects[u.ux][u.uy]; obj; obj = obj->nexthere)
X! 			ct++;
X! 		if(ct < 2)
X! 			all++;
X! 		else {
X! 			pline("There are several objects here.");
X! 			count = 0;
X! 		}
X! 	}
X  
X! 	/* added by GAN 10/24/86 to allow selective picking up */
X! 	if (!all) {
X! 		if (!query_classes(olets, &selective, &all_of_a_type,
X  			  "pick up", level.objects[u.ux][u.uy], TRUE, FALSE))
X  			return;
X  	}
X- 	if(all_of_a_type && !olets[0]) all = TRUE;
X  
X! 	for(obj = level.objects[u.ux][u.uy]; obj; obj = obj2) {
X  		obj2 = obj->nexthere;	/* perhaps obj will be picked up */
X  		objx = 0;
X! 		if(flags.run) nomul(0);
X  
X! 		if(!all)  {
X! 		    if(!selective && !index(olets,obj->oclass)) continue;
X  
X! 		    if (!all_of_a_type) {
X! 			char qbuf[QBUFSZ];
X! 			Sprintf(qbuf, "Pick up %s?", doname(obj));
X! 			switch ((obj->quan < 2L) ? ynaq(qbuf) : ynNaq(qbuf)) {
X! 			case 'q': return;
X! 			case 'n': continue;
X! 			case 'a':
X! 			    all_of_a_type = TRUE;
X! 			    if (selective) {
X! 				selective = FALSE;
X! 				olets[0] = obj->oclass;
X! 				olets[1] = '\0';
X! 			    }
X! 			    break;
X! 			case '#':	/* count was entered */
X! 			    if (!yn_number) continue; /* 0 count => No */
X! 			    else count = yn_number;
X! 			    /* fall thru */
X! 			default:	/* 'y' */
X! 			    break;
X  			}
X  		    }
X  		}
X  
X--- 235,296 ----
X  	 * teleported onto the object.  They shouldn't pick it up.
X  	 */
X  	if ((multi && !flags.run) || (all && !flags.pickup)) {
X! 		check_here(FALSE);
X  		return;
X  	}
X  
X! 	oclasses[0] = '\0';	/* types to consider (empty for all) */
X! 	all_of_a_type = TRUE;	/* take all of considered types */
X! 	selective = FALSE;	/* ask for each item */
X! 
X! 	if (all) {
X! 		if (flags.pickup) Strcpy(oclasses, flags.pickup_types);
X! 	} else {
X! 		/* check for more than one object */
X  		register int ct = 0;
X  
X! 		for (obj = level.objects[u.ux][u.uy]; obj; obj = obj->nexthere)
X! 		    ct++;
X  
X! 		if (ct >= 2) {
X! 		    pline("There are several objects here.");
X! 		    count = 0;
X! 
X! 		    /* added by GAN 10/24/86 to allow selective picking up */
X! 		    if (!query_classes(oclasses, &selective, &all_of_a_type,
X  			  "pick up", level.objects[u.ux][u.uy], TRUE, FALSE))
X  			return;
X+ 		}
X  	}
X  
X! 	for (obj = level.objects[u.ux][u.uy]; obj; obj = obj2) {
X  		obj2 = obj->nexthere;	/* perhaps obj will be picked up */
X  		objx = 0;
X! 		if (flags.run) nomul(0);
X  
X! 		if (!selective && oclasses[0] && !index(oclasses,obj->oclass))
X! 			continue;
X  
X! 		if (!all_of_a_type) {
X! 		    char qbuf[QBUFSZ];
X! 		    Sprintf(qbuf, "Pick up %s?", doname(obj));
X! 		    switch ((obj->quan < 2L) ? ynaq(qbuf) : ynNaq(qbuf)) {
X! 		    case 'q': return;
X! 		    case 'n': continue;
X! 		    case 'a':
X! 			all_of_a_type = TRUE;
X! 			if (selective) {
X! 			    selective = FALSE;
X! 			    oclasses[0] = obj->oclass;
X! 			    oclasses[1] = '\0';
X  			}
X+ 			break;
X+ 		    case '#':	/* count was entered */
X+ 			if (!yn_number) continue; /* 0 count => No */
X+ 			else count = yn_number;
X+ 			/* fall thru */
X+ 		    default:	/* 'y' */
X+ 			break;
X  		    }
X  		}
X  
X***************
X*** 287,293 ****
X  		    }
X  		    count = 0;	/* reset */
X  		}
X! 		if (pickup_object(obj, objx)) break;
X  	}
X  
X  	/*
X--- 307,314 ----
X  		    }
X  		    count = 0;	/* reset */
X  		}
X! 		if ((pick = pickup_object(obj, objx)) < 0) break;
X! 		pick_count += pick;
X  	}
X  
X  	/*
X***************
X*** 295,307 ****
X  	 *  map is correct.
X  	 */
X  	newsym(u.ux,u.uy);
X  }
X  
X  /*
X   * Pick up an object from the ground or out of a container and add it to
X!  * the inventory.  Returns true if pickup() should break out of its loop.
X   */
X! static boolean
X  pickup_object(obj, objx)
X  struct obj *obj, *objx;
X  {
X--- 316,332 ----
X  	 *  map is correct.
X  	 */
X  	newsym(u.ux,u.uy);
X+ 
X+ 	/* see whether there's anything else here, after auto-pickup is done */
X+ 	if (all && flags.pickup) check_here(pick_count > 0);
X  }
X  
X  /*
X   * Pick up an object from the ground or out of a container and add it to
X!  * the inventory.  Returns -1 if pickup() should break out of its loop,
X!  * 0 if nothing picked up, 1 if otherwise.
X   */
X! static int
X  pickup_object(obj, objx)
X  struct obj *obj, *objx;
X  {
X***************
X*** 308,317 ****
X  	int wt, nearload;
X  	long pickquan;
X  
X  	if (obj == uchain) {    /* do not pick up attached chain */
X! 	    return FALSE;
X  	} else if (obj->oartifact && !touch_artifact(obj,&youmonst)) {
X! 	    return FALSE;
X  	} else if (obj->otyp == GOLD_PIECE) {
X  	    /*
X  	     *  Special consideration for gold pieces...
X--- 333,346 ----
X  	int wt, nearload;
X  	long pickquan;
X  
X+ 	/* in case of auto-pickup, where we haven't had a chance
X+ 	   to look at it yet; affects docall(SCR_SCARE_MONSTER) */
X+ 	if (!Blind) obj->dknown = 1;
X+ 
X  	if (obj == uchain) {    /* do not pick up attached chain */
X! 	    return 0;
X  	} else if (obj->oartifact && !touch_artifact(obj,&youmonst)) {
X! 	    return 0;
X  	} else if (obj->otyp == GOLD_PIECE) {
X  	    /*
X  	     *  Special consideration for gold pieces...
X***************
X*** 324,330 ****
X         pline("There %s %ld gold piece%s here, but you cannot carry any more.",
X  			(obj->quan == 1L) ? "is" : "are",
X  			obj->quan, plur(obj->quan));
X! 		return FALSE;
X  	    } else if (gold_capacity < obj->quan) {
X  		if (objx) unsplitobj(obj, objx, 0L);
X  		You("can only carry %s of the %ld gold pieces lying here.",
X--- 353,359 ----
X         pline("There %s %ld gold piece%s here, but you cannot carry any more.",
X  			(obj->quan == 1L) ? "is" : "are",
X  			obj->quan, plur(obj->quan));
X! 		return 0;
X  	    } else if (gold_capacity < obj->quan) {
X  		if (objx) unsplitobj(obj, objx, 0L);
X  		You("can only carry %s of the %ld gold pieces lying here.",
X***************
X*** 348,354 ****
X  	    }
X  	    flags.botl = 1;
X  	    if (flags.run) nomul(0);
X! 	    return FALSE;
X  	} else if (obj->otyp == CORPSE) {
X  
X  	    if (obj->corpsenm == PM_COCKATRICE && !uarmg
X--- 377,383 ----
X  	    }
X  	    flags.botl = 1;
X  	    if (flags.run) nomul(0);
X! 	    return 1;
X  	} else if (obj->otyp == CORPSE) {
X  
X  	    if (obj->corpsenm == PM_COCKATRICE && !uarmg
X***************
X*** 368,379 ****
X  		    killer_format = KILLED_BY_AN;
X  		    killer = "cockatrice corpse";
X  		    done(STONING);
X  		}
X  	    } else if (is_rider(&mons[obj->corpsenm])) {
X  		pline("At your touch, the corpse suddenly moves...");
X  		revive_corpse(obj, 1, FALSE);
X  		exercise(A_WIS, FALSE);
X! 		return FALSE;
X  	    }
X  	} else  if (obj->otyp == SCR_SCARE_MONSTER) {
X  	    if (obj->blessed) obj->blessed = 0;
X--- 397,409 ----
X  		    killer_format = KILLED_BY_AN;
X  		    killer = "cockatrice corpse";
X  		    done(STONING);
X+ 		    return -1;
X  		}
X  	    } else if (is_rider(&mons[obj->corpsenm])) {
X  		pline("At your touch, the corpse suddenly moves...");
X  		revive_corpse(obj, 1, FALSE);
X  		exercise(A_WIS, FALSE);
X! 		return -1;
X  	    }
X  	} else  if (obj->otyp == SCR_SCARE_MONSTER) {
X  	    if (obj->blessed) obj->blessed = 0;
X***************
X*** 386,392 ****
X  				    !(objects[SCR_SCARE_MONSTER].oc_uname))
X  		    docall(obj);
X  		useupf(obj);
X! 		return FALSE;
X  	    }
X  	}
X  
X--- 416,423 ----
X  				    !(objects[SCR_SCARE_MONSTER].oc_uname))
X  		    docall(obj);
X  		useupf(obj);
X! 		return 1;	/* tried to pick something up and failed, but
X! 				   don't want to terminate pickup loop yet   */
X  	    }
X  	}
X  
X***************
X*** 438,444 ****
X  				"they are too heavy for you to lift") :
X  			"you cannot carry any more");
X  	    if (obj->otyp == SCR_SCARE_MONSTER) obj->spe = 0;
X! 	    return TRUE;
X  	}
X  
X  lift_some:
X--- 469,475 ----
X  				"they are too heavy for you to lift") :
X  			"you cannot carry any more");
X  	    if (obj->otyp == SCR_SCARE_MONSTER) obj->spe = 0;
X! 	    return -1;
X  	}
X  
X  lift_some:
X***************
X*** 446,452 ****
X  	    if (objx) unsplitobj(obj, objx, 0L);
X  	    if (obj->otyp == SCR_SCARE_MONSTER) obj->spe = 0;
X  	    Your("knapsack cannot accommodate any more items.");
X! 	    return TRUE;
X  	}
X  
X  	if (obj->otyp != LOADSTONE &&
X--- 477,483 ----
X  	    if (objx) unsplitobj(obj, objx, 0L);
X  	    if (obj->otyp == SCR_SCARE_MONSTER) obj->spe = 0;
X  	    Your("knapsack cannot accommodate any more items.");
X! 	    return -1;
X  	}
X  
X  	if (obj->otyp != LOADSTONE &&
X***************
X*** 462,468 ****
X  				if (objx) unsplitobj(obj, objx, 0L);
X  				if (obj->otyp == SCR_SCARE_MONSTER)
X  					obj->spe = 0;
X! 				return (ch == 'q');
X  			default:  break;	/* 'y' */
X  		}
X  	}
X--- 493,499 ----
X  				if (objx) unsplitobj(obj, objx, 0L);
X  				if (obj->otyp == SCR_SCARE_MONSTER)
X  					obj->spe = 0;
X! 				return (ch == 'q') ? -1 : 0;
X  			default:  break;	/* 'y' */
X  		}
X  	}
X***************
X*** 470,482 ****
X  	pickquan = obj->quan;	/* save number picked up */
X  	obj = pick_obj(obj);
X  
X- 	if (!Blind) obj->dknown = 1;
X  	if (uwep && uwep == obj) mrg_to_wielded = TRUE;
X  	nearload = near_capacity();
X! 	prinv(nearload > UNENCUMBERED && nearload < MOD_ENCUMBER ?
X! 	      moderateloadmsg : NULL, obj, pickquan);
X  	mrg_to_wielded = FALSE;
X! 	return FALSE;
X  }
X  
X  /* Gold never reaches this routine. */
X--- 501,512 ----
X  	pickquan = obj->quan;	/* save number picked up */
X  	obj = pick_obj(obj);
X  
X  	if (uwep && uwep == obj) mrg_to_wielded = TRUE;
X  	nearload = near_capacity();
X! 	prinv(nearload == SLT_ENCUMBER ? moderateloadmsg : NULL,
X! 		obj, pickquan);
X  	mrg_to_wielded = FALSE;
X! 	return 1;
X  }
X  
X  /* Gold never reaches this routine. */
X***************
X*** 608,614 ****
X      if ((Is_mbag(obj) || (obj->otyp == WAN_CANCELLATION && obj->spe > 0)) &&
X  	(rn2(1 << (depthin > 7 ? 7 : depthin)) <= depthin))
X  	return TRUE;
X!     else if (Is_container(obj)) {
X  	struct obj *otmp;
X  
X  	for (otmp = obj->cobj; otmp; otmp = otmp->nobj)
X--- 638,644 ----
X      if ((Is_mbag(obj) || (obj->otyp == WAN_CANCELLATION && obj->spe > 0)) &&
X  	(rn2(1 << (depthin > 7 ? 7 : depthin)) <= depthin))
X  	return TRUE;
X!     else if (Has_contents(obj)) {
X  	struct obj *otmp;
X  
X  	for (otmp = obj->cobj; otmp; otmp = otmp->nobj)
X***************
X*** 860,867 ****
X  	}
X  	/* Count the number of contained objects. Sometimes toss objects if */
X  	/* a cursed magic bag.						    */
X! 	for(curr = obj->cobj, prev = (struct obj *) 0; curr;
X! 					    prev = curr, curr = otmp) {
X  	    otmp = curr->nobj;
X  	    if (Is_mbag(obj) && obj->cursed && !rn2(13)) {
X  		if (curr->known)
X--- 890,897 ----
X  	}
X  	/* Count the number of contained objects. Sometimes toss objects if */
X  	/* a cursed magic bag.						    */
X! 	prev = (struct obj *) 0;
X! 	for (curr = obj->cobj; curr; curr = otmp) {
X  	    otmp = curr->nobj;
X  	    if (Is_mbag(obj) && obj->cursed && !rn2(13)) {
X  		if (curr->known)
X***************
X*** 888,895 ****
X  		}
X  		/* obfree() will free all contained objects */
X  		obfree(curr, (struct obj *) 0);
X! 	    } else
X  		cnt++;
X  	}
X  
X  	if (cnt && loss)
X--- 918,927 ----
X  		}
X  		/* obfree() will free all contained objects */
X  		obfree(curr, (struct obj *) 0);
X! 	    } else {
X! 		prev = curr;
X  		cnt++;
X+ 	    }
X  	}
X  
X  	if (cnt && loss)
X*** /tmp/da11258	Tue Jun  1 16:15:13 1993
X--- src/polyself.c	Tue Jun  1 10:47:50 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)polyself.c 3.1	92/11/24
X  /*	Copyright (C) 1987, 1988, 1989 by Ken Arromdee */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)polyself.c 3.1	93/05/15	*/
X  /*	Copyright (C) 1987, 1988, 1989 by Ken Arromdee */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 96,102 ****
X  	redist_attr();
X  	u.uhunger = rn1(500,500);
X  	newuhs(FALSE);
X! 	Sick = 0;
X  	Stoned = 0;
X  	if (u.uhp <= 0 || u.uhpmax <= 0) {
X  #ifdef POLYSELF
X--- 96,102 ----
X  	redist_attr();
X  	u.uhunger = rn1(500,500);
X  	newuhs(FALSE);
X! 	if (Sick) make_sick(0L, FALSE);
X  	Stoned = 0;
X  	if (u.uhp <= 0 || u.uhpmax <= 0) {
X  #ifdef POLYSELF
X***************
X*** 274,280 ****
X  		You("no longer seem to be petrifying.");
X  	}
X  	if (u.usym == S_FUNGUS && Sick) {
X! 		Sick = 0;
X  		You("no longer feel sick.");
X  	}
X  
X--- 274,280 ----
X  		You("no longer seem to be petrifying.");
X  	}
X  	if (u.usym == S_FUNGUS && Sick) {
X! 		make_sick(0L, FALSE);
X  		You("no longer feel sick.");
X  	}
X  
X***************
X*** 360,365 ****
X--- 360,369 ----
X  	    u.utrap = 0;
X  	    pline("The rock seems to no longer trap you.");
X  	}
X+ 	if ((amorphous(uasmon) || is_whirly(uasmon)) && Punished) {
X+ 	    You("slip out of the iron chain.");
X+ 	    unpunish();
X+ 	}
X  	flags.botl = 1;
X  	vision_full_recalc = 1;
X  	exercise(A_CON, FALSE);
X***************
X*** 371,380 ****
X  static void
X  break_armor()
X  {
X!      struct obj *otmp;
X  
X!      if (breakarm(uasmon)) {
X! 	if (otmp = uarm) {
X  		if (donning(otmp)) cancel_don();
X  		You("break out of your armor!");
X  		exercise(A_STR, FALSE);
X--- 375,384 ----
X  static void
X  break_armor()
X  {
X!     register struct obj *otmp;
X  
X!     if (breakarm(uasmon)) {
X! 	if ((otmp = uarm) != 0) {
X  		if (donning(otmp)) cancel_don();
X  		You("break out of your armor!");
X  		exercise(A_STR, FALSE);
X***************
X*** 381,387 ****
X  		(void) Armor_gone();
X  		useup(otmp);
X  	}
X! 	if (otmp = uarmc) {
X  	    if(otmp->oartifact) {
X  		Your("cloak falls off!");
X  		(void) Cloak_off();
X--- 385,391 ----
X  		(void) Armor_gone();
X  		useup(otmp);
X  	}
X! 	if ((otmp = uarmc) != 0) {
X  	    if(otmp->oartifact) {
X  		Your("cloak falls off!");
X  		(void) Cloak_off();
X***************
X*** 398,411 ****
X  		useup(uarmu);
X  	}
X  #endif
X!      } else if (sliparm(uasmon)) {
X! 	if (otmp = uarm) {
X  		if (donning(otmp)) cancel_don();
X  		Your("armor falls around you!");
X  		(void) Armor_gone();
X  		dropx(otmp);
X  	}
X! 	if (otmp = uarmc) {
X  		if (is_whirly(uasmon))
X  			Your("cloak falls, unsupported!");
X  		else You("shrink out of your cloak!");
X--- 402,415 ----
X  		useup(uarmu);
X  	}
X  #endif
X!     } else if (sliparm(uasmon)) {
X! 	if ((otmp = uarm) != 0) {
X  		if (donning(otmp)) cancel_don();
X  		Your("armor falls around you!");
X  		(void) Armor_gone();
X  		dropx(otmp);
X  	}
X! 	if ((otmp = uarmc) != 0) {
X  		if (is_whirly(uasmon))
X  			Your("cloak falls, unsupported!");
X  		else You("shrink out of your cloak!");
X***************
X*** 413,419 ****
X  		dropx(otmp);
X  	}
X  #ifdef TOURIST
X! 	if (otmp = uarmu) {
X  		if (is_whirly(uasmon))
X  			You("seep right through your shirt!");
X  		else You("become much too small for your shirt!");
X--- 417,423 ----
X  		dropx(otmp);
X  	}
X  #ifdef TOURIST
X! 	if ((otmp = uarmu) != 0) {
X  		if (is_whirly(uasmon))
X  			You("seep right through your shirt!");
X  		else You("become much too small for your shirt!");
X***************
X*** 421,457 ****
X  		dropx(otmp);
X  	}
X  #endif
X!      }
X!      if (nohands(uasmon) || verysmall(uasmon)) {
X! 	  if (otmp = uarmg) {
X! 	       if (donning(otmp)) cancel_don();
X! 	       /* Drop weapon along with gloves */
X! 	       You("drop your gloves%s!", uwep ? " and weapon" : "");
X! 	       drop_weapon(0);
X! 	       (void) Gloves_off();
X! 	       dropx(otmp);
X! 	  }
X! 	  if (otmp = uarms) {
X! 	       You("can no longer hold your shield!");
X! 	       (void) Shield_off();
X! 	       dropx(otmp);
X! 	  }
X! 	  if (otmp = uarmh) {
X! 	       if (donning(otmp)) cancel_don();
X! 	       Your("helmet falls to the floor!");
X! 	       (void) Helmet_off();
X! 	       dropx(otmp);
X! 	  }
X! 	  if (otmp = uarmf) {
X! 	       if (donning(otmp)) cancel_don();
X! 	       if (is_whirly(uasmon))
X! 		   Your("boots fall away!");
X! 	       else Your("boots %s off your feet!",
X  			verysmall(uasmon) ? "slide" : "are pushed");
X! 	       (void) Boots_off();
X! 	       dropx(otmp);
X! 	  }
X!      }
X  }
X  
X  static void
X--- 425,464 ----
X  		dropx(otmp);
X  	}
X  #endif
X!     }
X!     if (nohands(uasmon) || verysmall(uasmon)) {
X! 	if ((otmp = uarmg) != 0) {
X! 	    if (donning(otmp)) cancel_don();
X! 	    /* Drop weapon along with gloves */
X! 	    You("drop your gloves%s!", uwep ? " and weapon" : "");
X! 	    drop_weapon(0);
X! 	    (void) Gloves_off();
X! 	    dropx(otmp);
X! 	}
X! 	if ((otmp = uarms) != 0) {
X! 	    You("can no longer hold your shield!");
X! 	    (void) Shield_off();
X! 	    dropx(otmp);
X! 	}
X! 	if ((otmp = uarmh) != 0) {
X! 	    if (donning(otmp)) cancel_don();
X! 	    Your("helmet falls to the floor!");
X! 	    (void) Helmet_off();
X! 	    dropx(otmp);
X! 	}
X!     }
X!     if (nohands(uasmon) || verysmall(uasmon) || slithy(uasmon) || 
X! 		u.usym == S_CENTAUR) {
X! 	if ((otmp = uarmf) != 0) {
X! 	    if (donning(otmp)) cancel_don();
X! 	    if (is_whirly(uasmon))
X! 		Your("boots fall away!");
X! 	    else Your("boots %s off your feet!",
X  			verysmall(uasmon) ? "slide" : "are pushed");
X! 	    (void) Boots_off();
X! 	    dropx(otmp);
X! 	}
X!     }
X  }
X  
X  static void
X***************
X*** 459,465 ****
X  int alone;
X  {
X       struct obj *otmp;
X!      if (otmp = uwep) {
X  	  /* !alone check below is currently superfluous but in the
X  	   * future it might not be so if there are monsters which cannot
X  	   * wear gloves but can wield weapons
X--- 466,472 ----
X  int alone;
X  {
X       struct obj *otmp;
X!      if ((otmp = uwep) != 0) {
X  	  /* !alone check below is currently superfluous but in the
X  	   * future it might not be so if there are monsters which cannot
X  	   * wear gloves but can wield weapons
X***************
X*** 587,593 ****
X  		case PIT:
X  		case SPIKED_PIT: You("spin a web, covering up the pit.");
X  			deltrap(ttmp);
X! 			delallobj(u.ux, u.uy);
X  			if (Invisible) newsym(u.ux, u.uy);
X  			return(1);
X  		case SQKY_BOARD: pline("The squeaky board is muffled.");
X--- 594,600 ----
X  		case PIT:
X  		case SPIKED_PIT: You("spin a web, covering up the pit.");
X  			deltrap(ttmp);
X! 			bury_objs(u.ux, u.uy);
X  			if (Invisible) newsym(u.ux, u.uy);
X  			return(1);
X  		case SQKY_BOARD: pline("The squeaky board is muffled.");
X***************
X*** 596,610 ****
X  			return(1);
X  		case TELEP_TRAP:
X  		case LEVEL_TELEP:
X  			Your("webbing vanishes!");
X  			return(0);
X  		case WEB: You("make the web thicker.");
X  			return(1);
X  		case TRAPDOOR:
X! 		    You("web over the trap door.");
X! 		    deltrap(ttmp);
X! 		    if (Invisible) newsym(u.ux, u.uy);
X! 		    return 1;
X  		case ARROW_TRAP:
X  		case DART_TRAP:
X  		case BEAR_TRAP:
X--- 603,618 ----
X  			return(1);
X  		case TELEP_TRAP:
X  		case LEVEL_TELEP:
X+ 		case MAGIC_PORTAL:
X  			Your("webbing vanishes!");
X  			return(0);
X  		case WEB: You("make the web thicker.");
X  			return(1);
X  		case TRAPDOOR:
X! 			You("web over the trap door.");
X! 			deltrap(ttmp);
X! 			if (Invisible) newsym(u.ux, u.uy);
X! 			return 1;
X  		case ARROW_TRAP:
X  		case DART_TRAP:
X  		case BEAR_TRAP:
X***************
X*** 622,628 ****
X  			return(0);
X  	}
X  	ttmp = maketrap(u.ux, u.uy, WEB);
X! 	ttmp->tseen = 1;
X  	if (Invisible) newsym(u.ux, u.uy);
X  	return(1);
X  }
X--- 630,636 ----
X  			return(0);
X  	}
X  	ttmp = maketrap(u.ux, u.uy, WEB);
X! 	if (ttmp) ttmp->tseen = 1;
X  	if (Invisible) newsym(u.ux, u.uy);
X  	return(1);
X  }
X***************
X*** 675,680 ****
X--- 683,691 ----
X  		    if (!mtmp->mcanmove || mtmp->mstun || mtmp->msleep ||
X  					!mtmp->mcansee || !haseyes(mtmp->data))
X  			continue;
X+ #ifdef MUSE
X+ 		    if (!mon_reflects(mtmp, "Your gaze is reflected by %s %s."))
X+ #endif
X  		    if (!mtmp->mconf)
X  			Your("gaze confuses %s!", mon_nam(mtmp));
X  		    else
X*** /tmp/da11266	Tue Jun  1 16:15:16 1993
X--- src/potion.c	Mon May 17 14:04:55 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)potion.c	3.1	93/02/06		  */
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)potion.c	3.1	93/05/15	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 856,862 ****
X  potionbreathe(obj)
X  register struct obj *obj;
X  {
X! 	register int i, ii, isdone;
X  
X  	switch(obj->otyp) {
X  	case POT_RESTORE_ABILITY:
X--- 856,862 ----
X  potionbreathe(obj)
X  register struct obj *obj;
X  {
X! 	register int i, ii, isdone, kn = 0;
X  
X  	switch(obj->otyp) {
X  	case POT_RESTORE_ABILITY:
X***************
X*** 890,896 ****
X  		}
X  		break;
X  	case POT_HALLUCINATION:
X! 		You("have a vision for a moment.");
X  		break;
X  	case POT_CONFUSION:
X  	case POT_BOOZE:
X--- 890,896 ----
X  		}
X  		break;
X  	case POT_HALLUCINATION:
X! 		You("have a momentary vision.");
X  		break;
X  	case POT_CONFUSION:
X  	case POT_BOOZE:
X***************
X*** 903,926 ****
X  			pline("For an instant you could see through yourself!");
X  		break;
X  	case POT_PARALYSIS:
X  		pline("Something seems to be holding you.");
X  		nomul(-rnd(5));
X  		exercise(A_DEX, FALSE);
X  		break;
X  	case POT_SPEED:
X  		Fast += rnd(5);
X- 		Your("knees seem more flexible now.");
X  		exercise(A_DEX, TRUE);
X  		break;
X  	case POT_BLINDNESS:
X! 		if (!Blind && !u.usleep) pline("It suddenly gets dark.");
X! 		make_blinded(Blinded + rnd(5),FALSE);
X  		break;
X  	case POT_WATER:
X  #ifdef POLYSELF
X  		if(u.umonnum == PM_GREMLIN) {
X  		    struct monst *mtmp;
X! 		    if(mtmp = cloneu()) {
X  			mtmp->mhpmax = (u.mhmax /= 2);
X  			You("multiply.");
X  		    }
X--- 903,930 ----
X  			pline("For an instant you could see through yourself!");
X  		break;
X  	case POT_PARALYSIS:
X+ 		kn++;
X  		pline("Something seems to be holding you.");
X  		nomul(-rnd(5));
X  		exercise(A_DEX, FALSE);
X  		break;
X  	case POT_SPEED:
X+ 		if (!Fast) Your("knees seem more flexible now.");
X  		Fast += rnd(5);
X  		exercise(A_DEX, TRUE);
X  		break;
X  	case POT_BLINDNESS:
X! 		if (!Blind && !u.usleep) {
X! 		    kn++;
X! 		    pline("It suddenly gets dark.");
X! 		}
X! 		make_blinded(Blinded + rnd(5), FALSE);
X  		break;
X  	case POT_WATER:
X  #ifdef POLYSELF
X  		if(u.umonnum == PM_GREMLIN) {
X  		    struct monst *mtmp;
X! 		    if ((mtmp = cloneu()) != 0) {
X  			mtmp->mhpmax = (u.mhmax /= 2);
X  			You("multiply.");
X  		    }
X***************
X*** 936,942 ****
X  		break;
X  	}
X  	/* note: no obfree() */
X! 	if (obj->dknown && !objects[obj->otyp].oc_name_known &&
X  						!objects[obj->otyp].oc_uname)
X  		docall(obj);
X  }
X--- 940,949 ----
X  		break;
X  	}
X  	/* note: no obfree() */
X! 	if (obj->dknown)
X! 	    if (kn)
X! 		makeknown(obj->otyp);
X! 	    else if (!objects[obj->otyp].oc_name_known &&
X  						!objects[obj->otyp].oc_uname)
X  		docall(obj);
X  }
X*** /tmp/da11274	Tue Jun  1 16:15:18 1993
X--- src/pray.c	Thu Apr 29 16:19:13 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)pray.c	3.1	92/12/10	*/
X  /* Copyright (c) Benson I. Margulies, Mike Stephenson, Steve Linhart, 1989. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)pray.c	3.1	93/04/24	*/
X  /* Copyright (c) Benson I. Margulies, Mike Stephenson, Steve Linhart, 1989. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 11,16 ****
X--- 11,17 ----
X  static void FDECL(angrygods,(ALIGNTYP_P));
X  static void FDECL(pleased,(ALIGNTYP_P));
X  static void FDECL(godvoice,(ALIGNTYP_P,const char*));
X+ static void FDECL(god_zaps_you,(ALIGNTYP_P));
X  static void FDECL(gods_angry,(ALIGNTYP_P));
X  static void FDECL(gods_upset,(ALIGNTYP_P));
X  static void FDECL(consume_offering,(struct obj *));
X***************
X*** 342,347 ****
X--- 343,398 ----
X  }
X  
X  static void
X+ god_zaps_you(resp_god)
X+ aligntyp resp_god;
X+ {
X+ 	pline("Suddenly, a bolt of lightning strikes you!");
X+ 	if (Reflecting) {
X+ 	    shieldeff(u.ux, u.uy);
X+ 	    if (Blind)
X+ 		pline("For some reason you're unaffected.");
X+ 	    else {
X+ 		if (Reflecting & W_AMUL) {
X+ 		    pline("It reflects from your medallion.");
X+ 		    makeknown(AMULET_OF_REFLECTION);
X+ 		} else {
X+ 		    pline("It reflects from your shield.");
X+ 		    makeknown(SHIELD_OF_REFLECTION);
X+ 		}
X+ 	    }
X+ 	    goto ohno;
X+ 	} else if (Shock_resistance) {
X+ 	    shieldeff(u.ux, u.uy);
X+ 	    pline("It seems not to affect you.");
X+ ohno:
X+ 	    pline("%s is not deterred...", align_gname(resp_god));
X+ 	    pline("A wide-angle disintegration beam hits you!");
X+ 	    if (Disint_resistance) {
X+ 		You("bask in its %s glow for a minute...", Black);
X+ 		godvoice(resp_god, "I believe it not!");
X+ 		if(Is_astralevel(&u.uz)) {
X+ 
X+ 		    /* one more try on the astral level */
X+ 		    verbalize("Thou cannot escape my wrath, mortal!");
X+ 		    summon_minion(resp_god, FALSE);
X+ 		    summon_minion(resp_god, FALSE);
X+ 		    summon_minion(resp_god, FALSE);
X+ 		    verbalize("Destroy %s, my servants!", him[flags.female]);
X+ 		}
X+ 		return;
X+ 	    }
X+ 	}
X+ 	{
X+ 	    char killerbuf[64];
X+ 	    You("fry to a crisp.");
X+ 	    killer_format = KILLED_BY;
X+ 	    Sprintf(killerbuf, "the wrath of %s", align_gname(resp_god));
X+ 	    killer = killerbuf;
X+ 	    done(DIED);
X+ 	}
X+ }
X+ 
X+ static void
X  angrygods(resp_god)
X  aligntyp resp_god;
X  {
X***************
X*** 418,461 ****
X  			break;
X  
X  	    default:	gods_angry(resp_god);
X! 			pline("Suddenly, a bolt of lightning strikes you!");
X! 			if (Reflecting) {
X! 			    shieldeff(u.ux, u.uy);
X! 			    if (Blind)
X! 				pline("For some reason you're unaffected.");
X! 			    else {
X! 				if (Reflecting & W_AMUL) {
X! 				    pline("It reflects from your medallion.");
X! 				    makeknown(AMULET_OF_REFLECTION);
X! 				} else {
X! 				    pline("It reflects from your shield.");
X! 				    makeknown(SHIELD_OF_REFLECTION);
X! 				}
X! 			    }
X! 			    goto ohno;
X! 			} else if (Shock_resistance) {
X! 			    shieldeff(u.ux, u.uy);
X! 			    pline("It seems not to affect you.");
X! ohno:
X! 			    pline("%s is not deterred...",
X! 				  align_gname(resp_god));
X! 			    pline("A wide-angle disintegration beam hits you!");
X! 			    if (Disint_resistance) {
X! 				You("bask in its %s glow for a minute...",
X! 				    Black);
X! 				godvoice(resp_god, "I believe it not!");
X! 				break;
X! 			    }
X! 			}
X! 			{
X! 			    char killerbuf[64];
X! 			    You("fry to a crisp.");
X! 			    killer_format = KILLED_BY;
X! 			    Sprintf(killerbuf, "the wrath of %s",
X! 				    align_gname(resp_god));
X! 			    killer = killerbuf;
X! 			    done(DIED);
X! 			}
X  			break;
X  	}
X  	u.ublesscnt = rnz(300);
X--- 469,475 ----
X  			break;
X  
X  	    default:	gods_angry(resp_god);
X! 			god_zaps_you(resp_god);
X  			break;
X  	}
X  	u.ublesscnt = rnz(300);
X***************
X*** 628,634 ****
X  		register struct obj *obj = uwep;	/* to be blessed */
X  		boolean already_exists, in_hand;
X  
X- 		u.uevent.uhand_of_elbereth = TRUE;
X  		HSee_invisible |= FROMOUTSIDE;
X  		HFire_resistance |= FROMOUTSIDE;
X  		HCold_resistance |= FROMOUTSIDE;
X--- 642,647 ----
X***************
X*** 637,647 ****
X--- 650,662 ----
X  
X  		switch(u.ualign.type) {
X  		case A_LAWFUL:
X+ 		    u.uevent.uhand_of_elbereth = 1;
X  		    verbalize("I crown thee...      The Hand of Elbereth!");
X  		    if (obj && (obj->otyp == LONG_SWORD) && !obj->oartifact)
X  			obj = oname(obj, artiname(ART_EXCALIBUR), 1);
X  		    break;
X  		case A_NEUTRAL:
X+ 		    u.uevent.uhand_of_elbereth = 2;
X  		    verbalize("Thou shalt be my Envoy of Balance!");
X  		    if (uwep && uwep->oartifact == ART_VORPAL_BLADE) {
X  			obj = uwep;	/* to be blessed and rustproofed */
X***************
X*** 672,677 ****
X--- 687,693 ----
X  		     * ordinary good broadsword is given and the messages are
X  		     * a bit different.
X  		     */
X+ 		    u.uevent.uhand_of_elbereth = 3;
X  		    in_hand = (uwep && uwep->oartifact == ART_STORMBRINGER);
X  		    already_exists = exist_artifact(RUNESWORD,
X  						artiname(ART_STORMBRINGER));
X***************
X*** 871,877 ****
X  		/* curse the lawful/neutral altar */
X  		pline("The altar is stained with %sn blood.",
X  		      (pl_character[0]=='E') ? "elve" : "huma");
X! 		levl[u.ux][u.uy].altarmask = AM_CHAOTIC;
X  		angry_priest();
X  	    } else {
X  		register struct monst *dmon;
X--- 887,894 ----
X  		/* curse the lawful/neutral altar */
X  		pline("The altar is stained with %sn blood.",
X  		      (pl_character[0]=='E') ? "elve" : "huma");
X! 		if(!Is_astralevel(&u.uz))
X! 		    levl[u.ux][u.uy].altarmask = AM_CHAOTIC;
X  		angry_priest();
X  	    } else {
X  		register struct monst *dmon;
X***************
X*** 947,952 ****
X--- 964,970 ----
X  	} else {
X  	    /* The final Test.	Did you win? */
X  	    if(uamul == otmp) Amulet_off();
X+ 	    u.uevent.ascended = 1;
X  	    if(carried(otmp)) useup(otmp); /* well, it's gone now */
X  	    else useupf(otmp);
X  	    You("offer the Amulet of Yendor to %s...", a_gname());
X***************
X*** 997,1003 ****
X  	return (1);
X      }
X  
X!     if (value < 0) /* I don't think the gods are gonna like this... */
X  	gods_upset(altaralign);
X      else {
X  	int saved_anger = u.ugangr;
X--- 1015,1031 ----
X  	return (1);
X      }
X  
X!     if(Is_astralevel(&u.uz) && (altaralign != u.ualign.type)) {
X! 	/*
X! 	 * REAL BAD NEWS!!! High altars cannot be converted.  Even an attempt
X! 	 * gets the god who owns it truely pissed off.
X! 	 */
X! 	You("feel the air around you grow charged...");
X! 	pline("Suddenly, you realize that %s has noticed you...", a_gname());
X! 	godvoice(altaralign, "So, mortal!  You dare desecrate my High Temple!");
X! 	/* Throw everything we have at the player */
X! 	god_zaps_you(altaralign);
X!     } else if (value < 0) /* I don't think the gods are gonna like this... */
X  	gods_upset(altaralign);
X      else {
X  	int saved_anger = u.ugangr;
X***************
X*** 1204,1209 ****
X--- 1232,1238 ----
X  	if (yn("Force the gods to be pleased?") == 'y') {
X  	    u.ublesscnt = 0;
X  	    if (u.uluck < 0) u.uluck = 0;
X+ 	    if (u.ualign.record <= 0) u.ualign.record = 1;
X  	    u.ugangr = 0;
X  	    if(p_type < 2) p_type = 3;
X  	}
X***************
X*** 1244,1250 ****
X      if (Inhell) {
X  	pline("Since you are in Gehennom, %s won't help you.",
X  	      align_gname(alignment));
X! 	if(rnl(u.ualign.record)) /* yes, this is the right sense */
X  	    angrygods(u.ualign.type);
X  	return(0);
X      }
X--- 1273,1280 ----
X      if (Inhell) {
X  	pline("Since you are in Gehennom, %s won't help you.",
X  	      align_gname(alignment));
X! 	/* haltingly aligned is least likely to anger */
X! 	if (u.ualign.record <= 0 || rnl(u.ualign.record))
X  	    angrygods(u.ualign.type);
X  	return(0);
X      }
X*** /tmp/da11282	Tue Jun  1 16:15:22 1993
X--- src/priest.c	Mon May 17 14:05:01 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)priest.c	3.1	93/02/09
X  /* Copyright (c) Izchak Miller, Steve Linhart, 1989. 		  */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)priest.c	3.1	93/05/15	*/
X  /* Copyright (c) Izchak Miller, Steve Linhart, 1989. 		  */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 196,203 ****
X  	if(MON_AT(sx+1, sy))
X  		rloc(m_at(sx+1, sy)); /* insurance */
X  
X! 	if(priest = (sanctum ? makemon(&mons[PM_HIGH_PRIEST], sx+1, sy)
X! 			     : makemon(&mons[PM_ALIGNED_PRIEST], sx+1, sy))) {
X  		EPRI(priest)->shroom = (sroom - rooms) + ROOMOFFSET;
X  		EPRI(priest)->shralign = Amask2align(levl[sx][sy].altarmask);
X  		EPRI(priest)->shrpos.x = sx;
X--- 196,204 ----
X  	if(MON_AT(sx+1, sy))
X  		rloc(m_at(sx+1, sy)); /* insurance */
X  
X! 	priest = (sanctum ? makemon(&mons[PM_HIGH_PRIEST], sx+1, sy)
X! 			  : makemon(&mons[PM_ALIGNED_PRIEST], sx+1, sy));
X! 	if (priest) {
X  		EPRI(priest)->shroom = (sroom - rooms) + ROOMOFFSET;
X  		EPRI(priest)->shralign = Amask2align(levl[sx][sy].altarmask);
X  		EPRI(priest)->shrpos.x = sx;
X***************
X*** 377,383 ****
X  		switch(rn2(3)) {
X  		  case 0: You("have an eerie feeling..."); break;
X  		  case 1: You("feel like you are being watched."); break;
X! 		  default: pline("A shiver runs down your spine."); break;
X  		}
X  		if(!rn2(5)) {
X  		    struct monst *mtmp;
X--- 378,385 ----
X  		switch(rn2(3)) {
X  		  case 0: You("have an eerie feeling..."); break;
X  		  case 1: You("feel like you are being watched."); break;
X! 		  default: pline("A shiver runs down your %s.",
X! 			body_part(SPINE)); break;
X  		}
X  		if(!rn2(5)) {
X  		    struct monst *mtmp;
X***************
X*** 627,633 ****
X  {
X  	register struct monst *priest;
X  
X! 	if(priest = findpriest(temple_occupied(u.urooms)))
X  		wakeup(priest);
X  }
X  
X--- 629,635 ----
X  {
X  	register struct monst *priest;
X  
X! 	if ((priest = findpriest(temple_occupied(u.urooms))) != 0)
X  		wakeup(priest);
X  }
X  
X*** /tmp/da11290	Tue Jun  1 16:15:25 1993
X--- src/quest.c	Thu Mar 11 15:35:05 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)quest.c	3.1	92/11/13	*/
X  /*	Copyright 1991, M. Stephenson		  */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)quest.c	3.1	93/03/10	*/
X  /*	Copyright 1991, M. Stephenson		  */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 24,30 ****
X  static void NDECL(chat_with_guardian);
X  
X  static void
X! on_start() {
X    if(!Qstat(first_start)) {
X      qt_pager(QT_FIRSTTIME);
X      Qstat(first_start) = TRUE;
X--- 24,31 ----
X  static void NDECL(chat_with_guardian);
X  
X  static void
X! on_start()
X! {
X    if(!Qstat(first_start)) {
X      qt_pager(QT_FIRSTTIME);
X      Qstat(first_start) = TRUE;
X***************
X*** 35,41 ****
X  }
X  
X  static void
X! on_locate() {
X    if(!Qstat(first_locate)) {
X      qt_pager(QT_FIRSTLOCATE);
X      Qstat(first_locate) = TRUE;
X--- 36,43 ----
X  }
X  
X  static void
X! on_locate()
X! {
X    if(!Qstat(first_locate)) {
X      qt_pager(QT_FIRSTLOCATE);
X      Qstat(first_locate) = TRUE;
X***************
X*** 44,50 ****
X  }
X  
X  static void
X! on_goal() {
X    if(!Qstat(made_goal)) {
X      qt_pager(QT_FIRSTGOAL);
X      Qstat(made_goal) = 1;
X--- 46,53 ----
X  }
X  
X  static void
X! on_goal()
X! {
X    if(!Qstat(made_goal)) {
X      qt_pager(QT_FIRSTGOAL);
X      Qstat(made_goal) = 1;
X***************
X*** 86,93 ****
X  }
X  
X  void
X! onquest() {
X! 
X  	if(Not_firsttime)	return;
X  	if(!Is_special(&u.uz)) return;
X  
X--- 89,96 ----
X  }
X  
X  void
X! onquest()
X! {
X  	if(Not_firsttime)	return;
X  	if(!Is_special(&u.uz)) return;
X  
X***************
X*** 98,104 ****
X  }
X  
X  void
X! nemdead() {
X  	if(!Qstat(killed_nemesis)) {
X  	    Qstat(killed_nemesis) = TRUE;
X  	    qt_pager(QT_KILLEDNEM);
X--- 101,108 ----
X  }
X  
X  void
X! nemdead()
X! {
X  	if(!Qstat(killed_nemesis)) {
X  	    Qstat(killed_nemesis) = TRUE;
X  	    qt_pager(QT_KILLEDNEM);
X***************
X*** 106,112 ****
X  }
X  
X  void
X! artitouch() {
X  	if(!Qstat(touched_artifact)) {
X  	    Qstat(touched_artifact) = TRUE;
X  	    qt_pager(QT_GOTIT);
X--- 110,117 ----
X  }
X  
X  void
X! artitouch()
X! {
X  	if(!Qstat(touched_artifact)) {
X  	    Qstat(touched_artifact) = TRUE;
X  	    qt_pager(QT_GOTIT);
X***************
X*** 116,134 ****
X  
X  /* external hook for do.c (level change check) */
X  boolean
X! ok_to_quest() {
X! 
X! 	return(Qstat(got_quest));
X  }
X  
X  static boolean
X! not_capable() {
X!   return(u.ulevel < MIN_QUEST_LEVEL);
X  }
X  
X  /* TODO:	This one needs tuning. */
X  static boolean
X! not_pure() {
X  #ifdef WIZARD
X  	if(wizard && (u.ualign.record < MIN_QUEST_ALIGN)) {
X  
X--- 121,141 ----
X  
X  /* external hook for do.c (level change check) */
X  boolean
X! ok_to_quest()
X! {
X! 	return(Qstat(got_quest) || Qstat(got_thanks));
X  }
X  
X  static boolean
X! not_capable()
X! {
X! 	return(u.ulevel < MIN_QUEST_LEVEL);
X  }
X  
X  /* TODO:	This one needs tuning. */
X  static boolean
X! not_pure()
X! {
X  #ifdef WIZARD
X  	if(wizard && (u.ualign.record < MIN_QUEST_ALIGN)) {
X  
X***************
X*** 175,182 ****
X   *	the quest.  If so, try to induce the player to quest.
X   */
X  	if(Qstat(got_thanks)) {
X! /*	Rule 1:	You've gone back with/whithout the amulet.	*/
X!             if(u.uhave.amulet)	qt_pager(QT_HASAMULET);
X  
X  /*	Rule 2:	You've gone back before going for the amulet.	*/
X  	    else		qt_pager(QT_POSTHANKS);
X--- 182,189 ----
X   *	the quest.  If so, try to induce the player to quest.
X   */
X  	if(Qstat(got_thanks)) {
X! /*	Rule 1:	You've gone back with/without the amulet.	*/
X! 	    if(u.uhave.amulet)	qt_pager(QT_HASAMULET);
X  
X  /*	Rule 2:	You've gone back before going for the amulet.	*/
X  	    else		qt_pager(QT_POSTHANKS);
X***************
X*** 233,239 ****
X  		mtmp->data->mflags3 = 0;	/* end the inaction */
X  	}
X  
X!         if(Qstat(pissed_off)) {
X  	  qt_pager(QT_LASTLEADER);
X  	  expulsion(TRUE);
X  	} else chat_with_leader();
X--- 240,246 ----
X  		mtmp->data->mflags3 = 0;	/* end the inaction */
X  	}
X  
X! 	if(Qstat(pissed_off)) {
X  	  qt_pager(QT_LASTLEADER);
X  	  expulsion(TRUE);
X  	} else chat_with_leader();
X***************
X*** 272,278 ****
X  
X  void
X  quest_chat(mtmp)
X- 
X  	register struct monst *mtmp;
X  {
X  
X--- 279,284 ----
X***************
X*** 287,293 ****
X  
X  void
X  quest_talk(mtmp)
X- 
X  	register struct monst *mtmp;
X  {
X      switch(mtmp->data->msound) {
X--- 293,298 ----
X***************
X*** 299,305 ****
X  
X  void
X  quest_stat_check(mtmp)
X- 
X  	struct monst *mtmp;
X  {
X      if(mtmp->data->msound == MS_NEMESIS)
X--- 304,309 ----
X*** /tmp/da11306	Tue Jun  1 16:15:29 1993
X--- src/read.c	Fri May 28 11:40:39 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)read.c	3.1	93/02/04	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)read.c	3.1	93/05/26	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 610,618 ****
X  		if(!rn2(73) && !sobj->blessed) cnt += rnd(4);
X  		if(confused || sobj->cursed) cnt += 12;
X  		while(cnt--) {
X! #if defined(WIZARD) || defined(EXPLORE_MODE)
X! 		    if((!wizard && !discover) || !create_particular())
X! #endif /* WIZARD || EXPLORE_MODE */
X  		    (void) makemon (confused ? &mons[PM_ACID_BLOB] :
X  					(struct permonst *) 0, u.ux, u.uy);
X  		}
X--- 610,618 ----
X  		if(!rn2(73) && !sobj->blessed) cnt += rnd(4);
X  		if(confused || sobj->cursed) cnt += 12;
X  		while(cnt--) {
X! #ifdef WIZARD
X! 		    if(!wizard || !create_particular())
X! #endif /* WIZARD  */
X  		    (void) makemon (confused ? &mons[PM_ACID_BLOB] :
X  					(struct permonst *) 0, u.ux, u.uy);
X  		}
X***************
X*** 713,730 ****
X  			You("identify this as an identify scroll.");
X  		else
X  			pline("This is an identify scroll.");
X! 		if (sobj->blessed || (!sobj->cursed && !rn2(5)))
X  			cval = rn2(5);
X  			/* Note: if rn2(5)==0, identify all items */
X! 		else	cval = 1;
X  		useup(sobj);
X  		makeknown(SCR_IDENTIFY);
X  	id:
X  		if(invent && !confused) {
X  		    int ret;
X  		    do {
X  			ret = ggetobj("identify", identify, cval);
X! 		    } while(cval && (cval -= ret));
X  		}
X  		return(1);
X  	case SCR_CHARGING:
X--- 713,733 ----
X  			You("identify this as an identify scroll.");
X  		else
X  			pline("This is an identify scroll.");
X! 		if (sobj->blessed || (!sobj->cursed && !rn2(5))) {
X  			cval = rn2(5);
X  			/* Note: if rn2(5)==0, identify all items */
X! 			if (cval == 1 && sobj->blessed && Luck > 0) ++cval;
X! 		} else	cval = 1;
X  		useup(sobj);
X  		makeknown(SCR_IDENTIFY);
X  	id:
X  		if(invent && !confused) {
X  		    int ret;
X+ 		    /* use up `cval' "charges"; 0 is special case */
X  		    do {
X  			ret = ggetobj("identify", identify, cval);
X! 			if (ret < 0) break;	/* quit or no eligible items */
X! 		    } while (ret == 0 || (cval -= ret) > 0);
X  		}
X  		return(1);
X  	case SCR_CHARGING:
X***************
X*** 1167,1177 ****
X  	     || *mtype==PM_ALIGNED_PRIEST || *mtype==PM_ANGEL) {
X  		*mtype = PM_HUMAN_ZOMBIE;
X  		return TRUE;
X  	}
X  	return FALSE;
X  }
X  
X! #if defined(WIZARD) || defined(EXPLORE_MODE)
X  boolean
X  create_particular()
X  {
X--- 1170,1183 ----
X  	     || *mtype==PM_ALIGNED_PRIEST || *mtype==PM_ANGEL) {
X  		*mtype = PM_HUMAN_ZOMBIE;
X  		return TRUE;
X+ 	} else if (*mtype==PM_LONG_WORM_TAIL) {	/* for create_particular() */
X+ 		*mtype = PM_LONG_WORM;
X+ 		return TRUE;
X  	}
X  	return FALSE;
X  }
X  
X! #ifdef WIZARD
X  boolean
X  create_particular()
X  {
X***************
X*** 1180,1185 ****
X--- 1186,1192 ----
X  
X  	do {
X  	    getlin("Create what kind of monster? [type the name]", buf);
X+ 	    if (buf[0] == '\033') return FALSE;
X  	    which = name_to_mon(buf);
X  	    if (which < 0) pline("I've never heard of such monsters.");
X  	    else break;
X***************
X*** 1186,1204 ****
X  	} while (++tries < 5);
X  	if (tries == 5) pline(thats_enough_tries);
X  	else {
X! 	    if (!(mons[which].geno & G_GENOD) && cant_create(&which) &&
X! 								!Blind) {
X! 		if (mons[which].geno & G_GENOD)
X! pline("An image of the creature forms, wavers momentarily, then fades.");
X! 		else
X! pline("The disoriented creature's eyes slowly glaze over.");
X! 	    }
X! 	    (void) makemon(&mons[which], u.ux, u.uy);
X! 	    return TRUE;
X  	}
X  	return FALSE;
X  }
X! #endif /* WIZARD || EXPLORE_MODE */
X  
X  #endif /* OVLB */
X  
X--- 1193,1204 ----
X  	} while (++tries < 5);
X  	if (tries == 5) pline(thats_enough_tries);
X  	else {
X! 	    (void) cant_create(&which);
X! 	    return makemon(&mons[which], u.ux, u.uy) != 0;
X  	}
X  	return FALSE;
X  }
X! #endif /* WIZARD */
X  
X  #endif /* OVLB */
X  
X*** /tmp/da11322	Tue Jun  1 16:15:34 1993
X--- src/restore.c	Tue Apr 13 16:19:09 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)restore.c	3.1	93/01/23	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)restore.c	3.1	93/04/06	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 162,168 ****
X  register int fd;
X  boolean ghostly;
X  {
X! 	register struct obj *otmp, *otmp2;
X  	register struct obj *first = (struct obj *)0;
X  #ifdef TUTTI_FRUTTI
X  	register struct fruit *oldf;
X--- 162,168 ----
X  register int fd;
X  boolean ghostly;
X  {
X! 	register struct obj *otmp, *otmp2 = 0;
X  	register struct obj *first = (struct obj *)0;
X  #ifdef TUTTI_FRUTTI
X  	register struct fruit *oldf;
X***************
X*** 169,178 ****
X  #endif
X  	int xl;
X  
X- #if defined(LINT) || defined(GCC_WARN)
X- 	/* suppress "used before set" warning from lint */
X- 	otmp2 = 0;
X- #endif
X  	while(1) {
X  		mread(fd, (genericptr_t) &xl, sizeof(xl));
X  		if(xl == -1) break;
X--- 169,174 ----
X***************
X*** 200,207 ****
X  				&& !Is_candle(otmp))
X  			otmp->age = monstermoves-omoves+otmp->age;
X  
X! 		/* get contents of the container */
X! 		if (Is_container(otmp) || otmp->otyp == STATUE)
X  		    otmp->cobj = restobjchn(fd,ghostly);
X  
X  		otmp2 = otmp;
X--- 196,203 ----
X  				&& !Is_candle(otmp))
X  			otmp->age = monstermoves-omoves+otmp->age;
X  
X! 		/* get contents of a container or statue */
X! 		if (Has_contents(otmp))
X  		    otmp->cobj = restobjchn(fd,ghostly);
X  
X  		otmp2 = otmp;
X***************
X*** 219,225 ****
X  register int fd;
X  boolean ghostly;
X  {
X! 	register struct monst *mtmp, *mtmp2;
X  	register struct monst *first = (struct monst *)0;
X  	int xl;
X  	struct permonst *monbegin;
X--- 215,221 ----
X  register int fd;
X  boolean ghostly;
X  {
X! 	register struct monst *mtmp, *mtmp2 = 0;
X  	register struct monst *first = (struct monst *)0;
X  	int xl;
X  	struct permonst *monbegin;
X***************
X*** 229,238 ****
X  	mread(fd, (genericptr_t)&monbegin, sizeof(monbegin));
X  	moved = (monbegin != mons);
X  
X- #if defined(LINT) || defined(GCC_WARN)
X- 	/* suppress "used before set" warning from lint */
X- 	mtmp2 = 0;
X- #endif
X  	while(1) {
X  		mread(fd, (genericptr_t) &xl, sizeof(xl));
X  		if(xl == -1) break;
X--- 225,230 ----
X***************
X*** 392,397 ****
X--- 384,392 ----
X  restlevelfile(fd, ltmp)
X  register int fd;
X  xchar ltmp;
X+ #ifdef applec
X+ # pragma unused(fd)
X+ #endif
X  {
X  	register int nfd;
X  
X***************
X*** 468,486 ****
X  	if (rtmp < 2) return(rtmp);  /* dorecover called recursively */
X  
X  #ifdef MICRO
X! # ifdef AMIGA
X  	{
X! 	extern winid WIN_BASE;
X! 	clear_nhwindow(WIN_BASE);	/* hack until there's a hook for this */
X  	}
X  # else
X  	clear_nhwindow(WIN_MAP);
X  # endif
X  	clear_nhwindow(WIN_MESSAGE);
X! 	You("got as far as level %d in %s%s.",
X  		depth(&u.uz), dungeons[u.uz.dnum].dname,
X! 		flags.debug ? " while in WIZARD mode" :
X! 		flags.explore ? " while in discovery mode" : "");
X  	curs(WIN_MAP, 1, 1);
X  	dotcnt = 0;
X  	putstr(WIN_MAP, 0, "Restoring:");
X--- 463,484 ----
X  	if (rtmp < 2) return(rtmp);  /* dorecover called recursively */
X  
X  #ifdef MICRO
X! # ifdef AMII_GRAPHICS
X  	{
X! 	extern struct window_procs amii_procs;
X! 	if(windowprocs.win_init_nhwindows== amii_procs.win_init_nhwindows){
X! 	    extern winid WIN_BASE;
X! 	    clear_nhwindow(WIN_BASE);	/* hack until there's a hook for this */
X  	}
X+ 	}
X  # else
X  	clear_nhwindow(WIN_MAP);
X  # endif
X  	clear_nhwindow(WIN_MESSAGE);
X! 	You("return to level %d in %s%s.",
X  		depth(&u.uz), dungeons[u.uz.dnum].dname,
X! 		flags.debug ? " while in debug mode" :
X! 		flags.explore ? " while in explore mode" : "");
X  	curs(WIN_MAP, 1, 1);
X  	dotcnt = 0;
X  	putstr(WIN_MAP, 0, "Restoring:");
X***************
X*** 559,564 ****
X--- 557,563 ----
X  #ifdef MULDGN
X  	load_qtlist();	/* re-load the quest text info */
X  #endif
X+ 	reset_attribute_clock();
X  	/* Set up the vision internals, after levl[] data is loaded */
X  	/* but before docrt().					    */
X  	vision_reset();
X***************
X*** 642,647 ****
X--- 641,649 ----
X  		uchar	len;
X  		struct rm r;
X  		
X+ #if defined(applec)
X+ 		memset ( & r , 0 , sizeof ( r ) ) ; /* Suppress warning about used before set */
X+ #endif
X  		i = 0; j = 0; len = 0;
X  		while(i < ROWNO) {
X  		    while(j < COLNO) {
X***************
X*** 760,765 ****
X--- 762,768 ----
X  	dealloc_trap(trap);
X  	fobj = restobjchn(fd, ghostly);
X  	find_lev_obj();
X+ 	level.buriedobjlist = restobjchn(fd, ghostly);
X  	billobjs = restobjchn(fd, ghostly);
X  	rest_engravings(fd);
X  	rest_rooms(fd);		/* No joke :-) */
END_OF_FILE
if test 52366 -ne `wc -c <'patches02g'`; then
    echo shar: \"'patches02g'\" unpacked with wrong size!
fi
# end of 'patches02g'
echo shar: End of archive 20 \(of 33\).
cp /dev/null ark20isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 33 archives.
    echo "Now execute ./patchit.sh"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
