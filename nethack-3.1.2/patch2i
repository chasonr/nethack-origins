Path: uunet!news.tek.com!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v17i084:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Patch2i/33
Date: 11 Jun 1993 00:08:57 GMT
Organization: Tektronix, Inc, Redmond, OR, USA
Lines: 2285
Approved: billr@saab.CNA.TEK.COM
Message-ID: <1v8iep$iun@ying.cna.tek.com>
NNTP-Posting-Host: saab.cna.tek.com
Xref: uunet comp.sources.games:1772

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 17, Issue 84
Archive-name: nethack31/Patch2i
Patch-To: nethack31: Volume 16, Issue 1-116
Environment: Amiga, Atari, Mac, MS-DOS, Windows-NT, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 9 (of 33)."
# Contents:  UPDATE2 include/ntconf.h patches02q
# Wrapped by billr@saab on Thu Jun 10 16:55:02 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'UPDATE2' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'UPDATE2'\" to \"'UPDATE2.orig'\"
  mv -f 'UPDATE2' 'UPDATE2.orig'
fi
echo shar: Extracting \"'UPDATE2'\" \(931 characters\)
sed "s/^X//" >'UPDATE2' <<'END_OF_FILE'
XIn port-specific news, the Amiga and Mac ports have again changed the
Xmost, both in user interface for the previously existing windowing
Xsystems and in adding support for "tty" windowing.  The MS-DOS versions
Xmay now use direct screen I/O instead of going through termcap routines,
Xand be compiled for NEC PC-9801 machines thanks to Yamamoto Keizo.
XThe SYSV 386 music driver was ported to 386BSD by Andrew Chernov and
XSCO by Andreas Arens.
X
XIn general news, the pickup and disclosure options were enhanced;
Xinformation on the new usage is available from the Guidebook and
Xintra-game options help.
X
XA number of bugs were fixed, of which the most commonly encountered
Xfatal ones were associated with cursed bags of holding, renaming
Xshopkeepers, objects falling through trapdoors on deep levels, and
Xkicking embedded objects loose.
X
XAs usual, bones and save files from previous versions should be discarded
Xwhen upgrading to 3.1.2.
X
END_OF_FILE
if test 931 -ne `wc -c <'UPDATE2'`; then
    echo shar: \"'UPDATE2'\" unpacked with wrong size!
fi
# end of 'UPDATE2'
if test -f 'include/ntconf.h' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'include/ntconf.h'\" to \"'include/ntconf.h.orig'\"
  mv -f 'include/ntconf.h' 'include/ntconf.h.orig'
fi
echo shar: Extracting \"'include/ntconf.h'\" \(1220 characters\)
sed "s/^X//" >'include/ntconf.h' <<'END_OF_FILE'
X/*	SCCS Id: @(#)ntconf.h	3.1	93/04/08	*/
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#ifndef NTCONF_H
X#define NTCONF_H
X
X#define MICRO		/* always define this! */
X
X#define SHELL
X
X#define RANDOM		/* have Berkeley random(3) */
X
X#define TEXTCOLOR	/* Color text */
X
X#define PATHLEN		64	/* maximum pathlength */
X#define FILENAME	80	/* maximum filename length (conservative) */
X#ifndef MICRO_H
X#include "micro.h"      /* contains necessary externs for [os_name].c */
X#endif
X
X
X/*
X *  The remaining code shouldn't need modification.
X */
X
X#define NO_TERMS       /* April 8/93 mja */
X#define ASCIIGRAPH
X 
X#ifndef SYSTEM_H
X#include "system.h"
X#endif
X#define index	strchr
X#define rindex	strrchr
X
X#include <time.h>
X
X#ifdef RANDOM
X/* Use the high quality random number routines. */
X#define Rand()	random()
X#else
X#define Rand()	rand()
X#endif
X
X#define FCMASK	0660	/* file creation mask */
X
X#include <fcntl.h>
X#include <io.h>
X#include <direct.h>
X#include <conio.h>
X#undef kbhit	        /* Use our special NT kbhit */
X
X#define exit	msexit		/* do chdir first */
X
X#ifndef REDO
X#undef	Getchar
X#define Getchar nhgetch
X#endif
X
X
X#endif /* NTCONF_H */
END_OF_FILE
if test 1220 -ne `wc -c <'include/ntconf.h'`; then
    echo shar: \"'include/ntconf.h'\" unpacked with wrong size!
fi
# end of 'include/ntconf.h'
if test -f 'patches02q' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'patches02q'\" to \"'patches02q.orig'\"
  mv -f 'patches02q' 'patches02q.orig'
fi
echo shar: Extracting \"'patches02q'\" \(55421 characters\)
sed "s/^X//" >'patches02q' <<'END_OF_FILE'
X*** /tmp/da12288	Tue Jun  1 17:23:16 1993
X--- sys/mac/MacHelp	Wed Mar 17 14:02:42 1993
X***************
X*** 20,25 ****
X--- 20,26 ----
X          will be created if it doesn't exist.
X      various special level files (with a ".lev" suffix).
X      various help and other utility NetHack documents.
X+     Recover - the application to restore save files from crashed games.
X  
X      During play another file type appears:
X      player level files (labelled "iName.n", i is a constant number,
X***************
X*** 34,41 ****
X      The following files or file types may be thrown away:
X      logfile - if it becomes too large.  A new one will be generated.
X      player level files _not_ belonging to a game in progress.
X!         Alternatively, these files may be processed by a utility
X!         application, Recover (not included in this distribution).
X      Old bones files and saved games.
X  
X  === Resuming a saved game
X--- 35,42 ----
X      The following files or file types may be thrown away:
X      logfile - if it becomes too large.  A new one will be generated.
X      player level files _not_ belonging to a game in progress.
X!         Alternatively, these files may be processed by Recover,
X!         which may be able to restore a save file from the level files.
X      Old bones files and saved games.
X  
X  === Resuming a saved game
X***************
X*** 54,60 ****
X          without scrolling to the end.
X  
X      The Extended command "Window Cleanup" may be used to restore the
X!         the startup sizes and locations of the essential windows.  The
X          window positions are saved in a file labelled "NetHack Windows"
X          in the appropriate preferences folder.
X  
X--- 55,61 ----
X          without scrolling to the end.
X  
X      The Extended command "Window Cleanup" may be used to restore the
X!         the startup sizes and locations of the various windows.  The
X          window positions are saved in a file labelled "NetHack Windows"
X          in the appropriate preferences folder.
X  
X***************
X*** 63,68 ****
X--- 64,70 ----
X      MACgraphics  - use enhanced dungeon map symbols [TRUE]
X      large_font   - use 12 point font instead of 9 point font [FALSE]
X      popup_dialog - use real dialogs for question prompts [FALSE]
X+     page_wait    - display  --MORE--  after messages [TRUE]
X  
X      large_font is currently a pre-game option and has no effect
X          after the Dungeon Map, Message and Status windows are created.
X*** /tmp/da12337	Tue Jun  1 17:23:34 1993
X--- sys/mac/News	Thu Mar 18 09:57:43 1993
X***************
X*** 1,8 ****
X! Welcome to NetHack 3.1 for the Macintosh    (1/93)
X  
X  This game is brought to you by Jon Watte, Hao-Yang Wang and the rest
X! of the Macintosh Team (Mike Engber, David Hairston, Jonathan Handler,
X! Tim Lennan, Rob Menke, Chris Russo and Andy Swanson).
X  
X  Bug reports, suggestions, comments, etc., should be e-mailed to the
X  Internet address: nethack-bugs@linc.cis.upenn.edu
X--- 1,8 ----
X! Welcome to NetHack 3.1 for the Macintosh
X  
X  This game is brought to you by Jon Watte, Hao-Yang Wang and the rest
X! of the Macintosh Team (David Hairston, Jonathan Handler, Tim Lennan,
X! Rob Menke, Chris Russo and Andy Swanson).
X  
X  Bug reports, suggestions, comments, etc., should be e-mailed to the
X  Internet address: nethack-bugs@linc.cis.upenn.edu
X*** /tmp/da12361	Tue Jun  1 17:23:39 1993
X--- sys/mac/maccurs.c	Mon May 17 16:17:13 1993
X***************
X*** 11,16 ****
X--- 11,18 ----
X  #include <Memory.h>
X  #include <Files.h>
X  
X+ extern void dprintf ( char * , ... ) ;
X+ 
X  #define DIV_FACTOR 3
X  
X  static Boolean winFileInit = 0 ;
X***************
X*** 162,176 ****
X  
X  
X  Boolean
X! RetrievePosition ( short kind , short * top , short * left )
X! {
X! 	Point p ;
X  
X  	InitWinFile ( ) ;
X  	if ( kind < 0 || kind > kLastWindowKind ) {
X  		return 0 ;
X  	}
X  	if ( ! usePos [ kind ] . validPos ) {
X  		return 0 ;
X  	}
X  	* top = usePos [ kind ] . top ;
X--- 164,179 ----
X  
X  
X  Boolean
X! RetrievePosition ( short kind , short * top , short * left ) {
X! Point p ;
X  
X  	InitWinFile ( ) ;
X  	if ( kind < 0 || kind > kLastWindowKind ) {
X+ 		dprintf ( "Retrieve Bad kind %d" , kind ) ;
X  		return 0 ;
X  	}
X  	if ( ! usePos [ kind ] . validPos ) {
X+ 		dprintf ( "Retrieve Not stored kind %d" , kind ) ;
X  		return 0 ;
X  	}
X  	* top = usePos [ kind ] . top ;
X***************
X*** 177,182 ****
X--- 180,186 ----
X  	* left = usePos [ kind ] . left ;
X  	p . h = * left ;
X  	p . v = * top ;
X+ 	dprintf ( "Retrieve Kind %d Point (%d,%d)" , kind , * left , * top ) ;
X  	return PtInRgn ( p , GetGrayRgn ( ) ) ;
X  }
X  
X***************
X*** 206,216 ****
X--- 210,222 ----
X  {
X  	InitWinFile ( ) ;
X  	if ( kind < 0 || kind > kLastWindowKind ) {
X+ 		dprintf ( "Save bad kind %d" , kind ) ;
X  		return ;
X  	}
X  	savePos [ kind ] . validPos = 1 ;
X  	savePos [ kind ] . top = top ;
X  	savePos [ kind ] . left = left ;
X+ 	dprintf ( "Save kind %d point (%d,%d)" , kind , left , top ) ;
X  	FlushWinFile ( ) ;
X  }
X  
X***************
X*** 232,239 ****
X  static short
X  GetWinKind ( WindowPtr win )
X  {
X! 	short kind ;
X! 	NhWindow * nhw = GetWRefCon ( win ) ;
X  
X  	if ( ! nhw || ( ( ( long ) nhw ) & 1 ) || nhw -> theWindow != win ) {
X  		return -1 ;
X--- 238,248 ----
X  static short
X  GetWinKind ( WindowPtr win )
X  {
X! short kind ;
X! NhWindow * nhw = GetNhWin ( win ) ;
X! char * typeStr [ ] = {
X! 	"map" , "status" , "message" , "text" , "menu" ,
X! } ;
X  
X  	if ( ! nhw || ( ( ( long ) nhw ) & 1 ) || nhw -> theWindow != win ) {
X  		return -1 ;
X***************
X*** 242,254 ****
X  	if ( kind < 0 || kind > NHW_TEXT ) {
X  		return -1 ;
X  	}
X  	switch ( kind ) {
X  	case NHW_MAP :
X  		kind = kMapWindow ;
X  		break ;
X- 	case NHW_STATUS :
X- 		kind = kStatusWindow ;
X- 		break ;
X  	case NHW_MESSAGE :
X  		kind = kMessageWindow ;
X  		break ;
X--- 251,263 ----
X  	if ( kind < 0 || kind > NHW_TEXT ) {
X  		return -1 ;
X  	}
X+ 	dprintf ( "Got window kind %d (%lx)->%lx" , kind , win , nhw ) ;
X  	switch ( kind ) {
X  	case NHW_MAP :
X+ 	case NHW_STATUS :
X+ 	case NHW_BASE :
X  		kind = kMapWindow ;
X  		break ;
X  	case NHW_MESSAGE :
X  		kind = kMessageWindow ;
X  		break ;
X***************
X*** 259,265 ****
X  		kind = kTextWindow ;
X  		break ;
X  	}
X! 
X  	return kind ;
X  }
X  
X--- 268,274 ----
X  		kind = kTextWindow ;
X  		break ;
X  	}
X! 	dprintf ( "Returning kind %s" , typeStr [ kind ] ) ;
X  	return kind ;
X  }
X  
X***************
X*** 291,296 ****
X--- 300,306 ----
X  	GetPort ( & gp ) ;
X  	SetPort ( win ) ;
X  	LocalToGlobal ( & p ) ;
X+ 	AddPt ( * ( Point * ) & ( win -> portRect ) , & p ) ; /* Adjust for origin */
X  	SetPort ( gp ) ;
X  	SavePosition ( kind , p . v , p . h ) ;
X  }
X*** /tmp/da12369	Tue Jun  1 17:23:41 1993
X--- sys/mac/macerrs.c	Wed Mar  3 14:22:13 1993
X***************
X*** 74,80 ****
X      short		 itemHit;
X  	Str255 		 errdesc;
X  	StringHandle strh;
X- 	Ptr			 junk;
X  	
X  	errdesc[0] = '\0';
X  	if (errcode > 0) GetIndString(errdesc,stdIOErrID,errcode);  /* STDIO file rres, etc */
X--- 74,79 ----
X*** /tmp/da12377	Tue Jun  1 17:23:43 1993
X--- sys/mac/macfile.c	Fri May  7 15:50:31 1993
X***************
X*** 36,41 ****
X--- 36,43 ----
X  int FDECL(macwrite,(int, void *, unsigned));
X  long FDECL(macseek,(int, long, short));
X  
X+ char * FDECL(macgets,(int, char *, unsigned));
X+ 
X  static short FDECL(IsHandleFile,(int));
X  static int FDECL(OpenHandleFile,(const unsigned char *, long));
X  static int FDECL(CloseHandleFile,(int));
X***************
X*** 125,131 ****
X  	if ( ! itworked(ResError()) ) return (-1);
X  	
X  	HLock(h);
X! 	BlockMove ( *h , ptr , len );
X  	HUnlock(h);
X  	theHandleFiles[fd].mark += len ;
X  
X--- 127,133 ----
X  	if ( ! itworked(ResError()) ) return (-1);
X  	
X  	HLock(h);
X! 	BlockMove ( *h + theHandleFiles[fd].mark , ptr , len );
X  	HUnlock(h);
X  	theHandleFiles[fd].mark += len ;
X  
X***************
X*** 322,327 ****
X--- 324,344 ----
X  			return -1 ;
X  		}
X  	}
X+ }
X+ 
X+ 
X+ char *
X+ macgets ( int fd , char * ptr , unsigned len )
X+ {
X+ 	int idx = 0 ;
X+ 	while ( -- len > 0 ) {
X+ 		if ( macread ( fd , ptr + idx , 1 ) <= 0 )
X+ 			return NULL ;
X+ 		if ( ptr [ idx ++ ] == '\n' )
X+ 			break ;
X+ 	}
X+ 	ptr [ idx ] = '\0' ;
X+ 	return ptr ;
X  }
X  
X  
X*** /tmp/da12385	Tue Jun  1 17:23:45 1993
X--- sys/mac/macmain.c	Mon May 17 16:17:17 1993
X***************
X*** 27,32 ****
X--- 27,34 ----
X  #include <fcntl.h>
X  #endif
X  
X+ extern void	DialogAskName(asknameRec *);
X+ 
X  int NDECL(main);
X  void NDECL(ListGUnloads);
X  
X***************
X*** 286,352 ****
X  void
X  mac_askname(void) /* Code taken from getlin */
X  {
X! 	ControlHandle	ctrl ;
X! 	DialogPtr		promptDialog ;
X! 	short			itemHit , type ;
X! 	Rect			box ;
X! 	Str255			pasStr ;
X  
X! 	/*
X! 	** Set the query line as parameter text.
X! 	*/
X  
X! 	ParamText ( "\PWho are you?" , "\p" , "\p" , "\p" ) ;
X  
X! 	promptDialog = GetNewDialog ( 130 , ( Ptr ) NULL , ( WindowPtr ) -1 ) ;
X! 	ShowWindow ( promptDialog ) ;
X  
X! 	InitCursor ( ) ;
X! 	SetFrameItem ( promptDialog , 6 , 1 ) ;
X! 	do {
X  
X! 		ModalDialog ( ( ModalFilterProcPtr ) DragFilter , & itemHit ) ;
X  
X! 	} while ( ( itemHit != 1 ) && ( itemHit != 2 ) ) ;
X  
X! 	if ( itemHit == 1 ) {
X! 
X! 		/*
X! 		** Get the text from the text edit item.
X! 		*/
X! 
X! 		GetDItem ( promptDialog , 4 , & type , ( Handle * ) & ctrl , & box ) ;
X! 		GetIText ( ( Handle ) ctrl , pasStr ) ;
X! 
X! 		/*
X! 		** Convert it to a 'C' string and copy it into the return value.
X! 		*/
X! 
X! 		PtoCstr ( pasStr ) ;
X! 		strcpy ( plname , ( char * ) pasStr ) ;
X! 
X! 	/*
X! 	 * Special check for debugging here
X! 	 *
X! 	 */
X! #ifdef WIZARD
X! 		if ( ! strcmp ( plname , WIZARD ) ) {
X! 
X! 			flags . debug = 1 ;
X! 		}
X  #endif
X  
X  	} else {
X! 
X! 		/*
X! 		** Okay, we didn't want to run
X! 		*/
X! 
X! 	/*	* ( short * ) DSErrCode = dsBadLaunch ; */
X! 		ExitToShell ( ) ;
X  	}
X  
X! 	DisposDialog ( promptDialog ) ;
X  }
X  
X  
X--- 288,347 ----
X  void
X  mac_askname(void) /* Code taken from getlin */
X  {
X! 	asknameRec	anr;
X! 	/* eventually use roles[] a/o pl_classes[] */
X! 	static char		asknRoles [ ] = "ABCEHKPRSTVW" ;
X  
X! 	/* initialize the askname record */
X! 	qd.randSeed = TickCount() ;
X! 	anr.anMenu[anRole] = (Random ( ) & 0x7fff ) % askn_role_end;
X  
X! #ifndef TOURIST
X! 	if (anr.anMenu[anRole] == asknTourist) {
X! 		anr.anMenu[anRole] = asknValkyrie;
X! 	}
X! #endif
X  
X! 	if (anr.anMenu[anRole] == asknValkyrie) {
X! 		anr.anMenu[anSex] = asknFemale;
X! 	} else {
X! 		anr.anMenu[anSex] = ( (Random() & 2) ? asknMale : asknFemale);
X! 	}
X  
X! 	anr.anMenu[anMode] = asknRegular;
X  
X! 	InitCursor();
X! 	DialogAskName(&anr);
X  
X! 	if (anr.anMenu[anMode] == asknQuit) {
X! 		ExitToShell();
X! 	}
X  
X! #ifdef EXPLORE_MODE
X! 	if (anr.anMenu[anMode] == asknExplore ) {
X! 		discover = 1 ;
X! 	} else {
X! 		discover = 0 ;
X! 	}
X  #endif
X  
X+ #ifdef WIZARD
X+ 	if ( anr.anMenu [ anMode ] == asknDebug ) {
X+ 		wizard = 1 ;
X  	} else {
X! 		wizard = 0 ;
X  	}
X+ 	if (wizard) {
X+ 		strcpy(plname, WIZARD);
X+ 	} else
X+ #endif
X+ 	{
X+ 		BlockMove(&(anr.anWho[1]), plname, anr.anWho[0]);
X+ 		plname [ anr . anWho [ 0 ] ] = 0 ;
X+ 	}
X  
X! 	flags.female = anr.anMenu[anSex];
X! 	pl_character[0] = asknRoles[anr.anMenu[anRole]];
X  }
X  
X  
X*** /tmp/da12425	Tue Jun  1 17:23:57 1993
X--- sys/mac/macunix.c	Wed Mar  3 14:22:17 1993
X***************
X*** 15,20 ****
X--- 15,23 ----
X  int
X  uptodate(int fd)
X  {
X+ #if defined(applec)
X+ # pragma unused(fd)
X+ #endif
X  	return(1);
X  }
X  
X*** /tmp/da12441	Tue Jun  1 17:24:07 1993
X--- sys/mac/mgetline.c	Wed May 19 10:08:51 1993
X***************
X*** 352,360 ****
X--- 352,362 ----
X  void
X  mac_get_ext_cmd(char *bufp)
X  {
X+ #if 0	/* already in error and then broken by macmenu.c */
X  	if (flags.popup_dialog)
X  		popup_get_ext_cmd(bufp);
X  	else
X+ #endif
X  		topl_getlin("# ", bufp, &topl_ext_key);
X  }
X  
X*** /tmp/da11614	Tue Jun  1 16:57:11 1993
X--- util/dgn_comp.l	Fri Apr 23 14:21:35 1993
X***************
X*** 34,40 ****
X  #  define VOIDYYPUT
X  # endif
X  # if !defined(VOIDYYPUT)
X! #  if defined(POSIX_TYPES) && !defined(BOS) && !defined(HISX)
X  #   define VOIDYYPUT
X  #  endif
X  # endif
X--- 34,40 ----
X  #  define VOIDYYPUT
X  # endif
X  # if !defined(VOIDYYPUT)
X! #  if defined(POSIX_TYPES) && !defined(BOS) && !defined(HISX) && !defined(_M_UNIX)
X  #   define VOIDYYPUT
X  #  endif
X  # endif
X*** /tmp/da11622	Tue Jun  1 16:57:13 1993
X--- util/dgn_comp.y	Mon May 17 13:55:22 1993
X***************
X*** 1,5 ****
X  %{
X! /*	SCCS Id: @(#)dgn_comp.c	3.1	93/01/17	*/
X  /*	Copyright (c) 1989 by Jean-Christophe Collet */
X  /*	Copyright (c) 1990 by M. Stephenson				  */
X  /* NetHack may be freely redistributed.  See license for details. */
X--- 1,5 ----
X  %{
X! /*	SCCS Id: @(#)dgn_comp.c	3.1	93/05/15	*/
X  /*	Copyright (c) 1989 by Jean-Christophe Collet */
X  /*	Copyright (c) 1990 by M. Stephenson				  */
X  /* NetHack may be freely redistributed.  See license for details. */
X***************
X*** 25,32 ****
X  #include "config.h"
X  #include "dgn_file.h"
X  
X! void FDECL(yyerror, (char *));
X! void FDECL(yywarning, (char *));
X  int NDECL(yylex);
X  int NDECL(yyparse);
X  int FDECL(getchain, (char *));
X--- 25,32 ----
X  #include "config.h"
X  #include "dgn_file.h"
X  
X! void FDECL(yyerror, (const char *));
X! void FDECL(yywarning, (const char *));
X  int NDECL(yylex);
X  int NDECL(yyparse);
X  int FDECL(getchain, (char *));
X***************
X*** 62,68 ****
X  static int in_dungeon = 0, n_dgns = -1, n_levs = -1, n_brs = -1;
X  
X  extern int fatal_error;
X! extern char* fname;
X  
X  %}
X  
X--- 62,68 ----
X  static int in_dungeon = 0, n_dgns = -1, n_levs = -1, n_brs = -1;
X  
X  extern int fatal_error;
X! extern const char *fname;
X  
X  %}
X  
X*** /tmp/da11630	Tue Jun  1 16:57:15 1993
X--- util/dgn_main.c	Mon May 17 13:55:10 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)dgn_main.c 3.1	92/03/10	*/
X  /*	Copyright (c) 1989 by Jean-Christophe Collet	*/
X  /*	Copyright (c) 1990 by M. Stephenson		*/
X  /* NetHack may be freely redistributed.  See license for details. */
X--- 1,4 ----
X! /*	SCCS Id: @(#)dgn_main.c 3.1	93/05/15	*/
X  /*	Copyright (c) 1989 by Jean-Christophe Collet	*/
X  /*	Copyright (c) 1990 by M. Stephenson		*/
X  /* NetHack may be freely redistributed.  See license for details. */
X***************
X*** 37,49 ****
X  #define MAX_ERRORS	25
X  
X  extern int line_number;
X! char *fname = "(stdin)";
X  int fatal_error = 0;
X  
X  int  FDECL (main, (int, char **));
X  int  NDECL (yyparse);
X! void FDECL (yyerror, (char *));
X! void FDECL (yywarning, (char *));
X  int  NDECL (yywrap);
X  void FDECL (init_yyin, (FILE *));
X  void FDECL (init_yyout, (FILE *));
X--- 37,49 ----
X  #define MAX_ERRORS	25
X  
X  extern int line_number;
X! const char *fname = "(stdin)";
X  int fatal_error = 0;
X  
X  int  FDECL (main, (int, char **));
X  int  NDECL (yyparse);
X! void FDECL (yyerror, (const char *));
X! void FDECL (yywarning, (const char *));
X  int  NDECL (yywrap);
X  void FDECL (init_yyin, (FILE *));
X  void FDECL (init_yyout, (FILE *));
X***************
X*** 121,127 ****
X   */
X  
X  void yyerror(s)
X! char *s;
X  {
X  	fprintf(stderr,"%s : line %d : %s\n",fname,line_number, s);
X  	if (++fatal_error > MAX_ERRORS) {
X--- 121,127 ----
X   */
X  
X  void yyerror(s)
X! const char *s;
X  {
X  	fprintf(stderr,"%s : line %d : %s\n",fname,line_number, s);
X  	if (++fatal_error > MAX_ERRORS) {
X***************
X*** 135,141 ****
X   */
X  
X  void yywarning(s)
X! char *s;
X  {
X  	fprintf(stderr,"%s : line %d : WARNING : %s\n",fname,line_number,s);
X  }
X--- 135,141 ----
X   */
X  
X  void yywarning(s)
X! const char *s;
X  {
X  	fprintf(stderr,"%s : line %d : WARNING : %s\n",fname,line_number,s);
X  }
X*** /tmp/da11638	Tue Jun  1 16:57:17 1993
X--- util/lev_comp.l	Tue Jun  1 10:50:15 1993
X***************
X*** 1,5 ****
X  %{
X! /*	SCCS Id: @(#)lev_lex.c	3.1	92/07/12	*/
X  /*	Copyright (c) 1989 by Jean-Christophe Collet */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,5 ----
X  %{
X! /*	SCCS Id: @(#)lev_lex.c	3.1	93/05/27	*/
X  /*	Copyright (c) 1989 by Jean-Christophe Collet */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 31,37 ****
X  #  define VOIDYYPUT
X  # endif
X  # if !defined(VOIDYYPUT)
X! #  if defined(POSIX_TYPES) && !defined(BOS) && !defined(HISX)
X  #   define VOIDYYPUT
X  #  endif
X  # endif
X--- 31,37 ----
X  #  define VOIDYYPUT
X  # endif
X  # if !defined(VOIDYYPUT)
X! #  if defined(POSIX_TYPES) && !defined(BOS) && !defined(HISX) && !defined(_M_UNIX)
X  #   define VOIDYYPUT
X  #  endif
X  # endif
X***************
X*** 57,75 ****
X  extern void FDECL(exit, (int));
X  #endif
X  
X! /* this doesn't always get put in lev_comp.h
X!  * (esp. when using older versions of bison)
X   */
X- 
X  extern YYSTYPE yylval;
X  
X  int line_number = 1, colon_line_number = 1;
X  
X! /* This is *** UGLY *** but I can't think a better way to do it
X   * I really need a huge buffer to scan maps...
X   */
X! 
X  #undef YYLMAX
X  #define YYLMAX	2048
X  
X  /*
X--- 57,78 ----
X  extern void FDECL(exit, (int));
X  #endif
X  
X! /*
X!  * This doesn't always get put in lev_comp.h
X!  * (esp. when using older versions of bison).
X   */
X  extern YYSTYPE yylval;
X  
X  int line_number = 1, colon_line_number = 1;
X  
X! /*
X!  * This is *** UGLY *** but I can't think a better way to do it;
X   * I really need a huge buffer to scan maps...
X+  * (This should probably be `#ifndef FLEX_SCANNER' since it's lex-specific.)
X   */
X! #ifdef YYLMAX
X  #undef YYLMAX
X+ #endif
X  #define YYLMAX	2048
X  
X  /*
X***************
X*** 107,113 ****
X  %s MAPC
X  %%
X  <MAPC>ENDMAP	{
X! #ifdef FLEX_SCANNER
X  		  /*
X  		   * There is a bug in Flex 2.3 patch level < 6
X  		   * (absent in previous versions)
X--- 110,116 ----
X  %s MAPC
X  %%
X  <MAPC>ENDMAP	{
X! #ifdef FLEX23_BUG
X  		  /*
X  		   * There is a bug in Flex 2.3 patch level < 6
X  		   * (absent in previous versions)
X*** /tmp/da11646	Tue Jun  1 16:57:19 1993
X--- util/lev_comp.y	Mon May 17 13:55:26 1993
X***************
X*** 1,5 ****
X  %{
X! /*	SCCS Id: @(#)lev_comp.c	3.1	93/02/13	*/
X  /*	Copyright (c) 1989 by Jean-Christophe Collet */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,5 ----
X  %{
X! /*	SCCS Id: @(#)lev_comp.c	3.1	93/05/15	*/
X  /*	Copyright (c) 1989 by Jean-Christophe Collet */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 51,58 ****
X  extern void FDECL(exit, (int));
X  #endif
X  
X! extern void FDECL(yyerror, (char *));
X! extern void FDECL(yywarning, (char *));
X  extern int NDECL(yylex);
X  int NDECL(yyparse);
X  
X--- 51,58 ----
X  extern void FDECL(exit, (int));
X  #endif
X  
X! extern void FDECL(yyerror, (const char *));
X! extern void FDECL(yywarning, (const char *));
X  extern int NDECL(yylex);
X  int NDECL(yyparse);
X  
X***************
X*** 68,74 ****
X  extern void FDECL(scan_map, (char *));
X  extern void NDECL(wallify_map);
X  extern boolean NDECL(check_subrooms);
X! extern void FDECL(check_coord, (int, int, char *));
X  extern void NDECL(store_part);
X  extern void NDECL(store_room);
X  extern void FDECL(write_maze, (int, specialmaze *));
X--- 68,74 ----
X  extern void FDECL(scan_map, (char *));
X  extern void NDECL(wallify_map);
X  extern boolean NDECL(check_subrooms);
X! extern void FDECL(check_coord, (int, int, const char *));
X  extern void NDECL(store_part);
X  extern void NDECL(store_room);
X  extern void FDECL(write_maze, (int, specialmaze *));
X***************
X*** 137,143 ****
X  
X  extern int fatal_error;
X  extern int want_warnings;
X! extern char* fname;
X  
X  %}
X  
X--- 137,143 ----
X  
X  extern int fatal_error;
X  extern int want_warnings;
X! extern const char *fname;
X  
X  %}
X  
X*** /tmp/da11654	Tue Jun  1 16:57:22 1993
X--- util/lev_main.c	Fri May 28 11:40:47 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)lev_main.c	3.1	92/12/11	*/
X  /*	Copyright (c) 1989 by Jean-Christophe Collet */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)lev_main.c	3.1	93/05/27	*/
X  /*	Copyright (c) 1989 by Jean-Christophe Collet */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 56,63 ****
X  extern void FDECL (init_yyout, (FILE *));
X  
X  int  FDECL (main, (int, char **));
X! void FDECL (yyerror, (char *));
X! void FDECL (yywarning, (char *));
X  int  NDECL (yywrap);
X  char *FDECL(dup_string,(const char *));
X  int FDECL(get_floor_type, (CHAR_P));
X--- 56,63 ----
X  extern void FDECL (init_yyout, (FILE *));
X  
X  int  FDECL (main, (int, char **));
X! void FDECL (yyerror, (const char *));
X! void FDECL (yywarning, (const char *));
X  int  NDECL (yywrap);
X  char *FDECL(dup_string,(const char *));
X  int FDECL(get_floor_type, (CHAR_P));
X***************
X*** 71,77 ****
X  void FDECL(scan_map, (char *));
X  void NDECL(wallify_map);
X  boolean NDECL(check_subrooms);
X! void FDECL(check_coord, (int, int, char *));
X  void NDECL(store_part);
X  void NDECL(store_room);
X  static void FDECL(write_common_data, (int,int,lev_init *,long));
X--- 71,77 ----
X  void FDECL(scan_map, (char *));
X  void NDECL(wallify_map);
X  boolean NDECL(check_subrooms);
X! void FDECL(check_coord, (int, int, const char *));
X  void NDECL(store_part);
X  void NDECL(store_room);
X  static void FDECL(write_common_data, (int,int,lev_init *,long));
X***************
X*** 109,115 ****
X  };
X  
X  static struct {
X! 	char *name;
X  	int type;
X  } room_types[] = {
X  	/* for historical reasons, room types are not contiguous numbers */
X--- 109,115 ----
X  };
X  
X  static struct {
X! 	const char *name;
X  	int type;
X  } room_types[] = {
X  	/* for historical reasons, room types are not contiguous numbers */
X***************
X*** 140,151 ****
X  	{ 0, 0 }
X  };
X  
X! char *fname = "(stdin)";
X  int fatal_error = 0;
X  int want_warnings = 0;
X  
X! /* Flex 2.3 bug work around */
X  int yy_more_len = 0;
X  
X  extern char tmpmessage[];
X  extern altar *tmpaltar[];
X--- 140,153 ----
X  	{ 0, 0 }
X  };
X  
X! const char *fname = "(stdin)";
X  int fatal_error = 0;
X  int want_warnings = 0;
X  
X! #ifdef FLEX23_BUG
X! /* Flex 2.3 bug work around; not needed for 2.3.6 or later */
X  int yy_more_len = 0;
X+ #endif
X  
X  extern char tmpmessage[];
X  extern altar *tmpaltar[];
X***************
X*** 268,274 ****
X  
X  void
X  yyerror(s)
X! char *s;
X  {
X  	(void) fprintf(stderr, "%s: line %d : %s\n", fname,
X  		(*s >= 'A' && *s <= 'Z') ? colon_line_number : line_number, s);
X--- 270,276 ----
X  
X  void
X  yyerror(s)
X! const char *s;
X  {
X  	(void) fprintf(stderr, "%s: line %d : %s\n", fname,
X  		(*s >= 'A' && *s <= 'Z') ? colon_line_number : line_number, s);
X***************
X*** 284,290 ****
X  
X  void
X  yywarning(s)
X! char *s;
X  {
X  	(void) fprintf(stderr, "%s: line %d : WARNING : %s\n",
X  				fname, colon_line_number, s);
X--- 286,292 ----
X  
X  void
X  yywarning(s)
X! const char *s;
X  {
X  	(void) fprintf(stderr, "%s: line %d : WARNING : %s\n",
X  				fname, colon_line_number, s);
X***************
X*** 607,613 ****
X  void
X  check_coord(x, y, str)
X  int x, y;
X! char *str;
X  {
X      char ebuf[60];
X  
X--- 609,615 ----
X  void
X  check_coord(x, y, str)
X  int x, y;
X! const char *str;
X  {
X      char ebuf[60];
X  
X*** /tmp/da11662	Tue Jun  1 16:57:25 1993
X--- util/makedefs.c	Mon May 17 13:55:07 1993
X***************
X*** 13,18 ****
X--- 13,25 ----
X  #include "monsym.h"
X  #include "artilist.h"
X  
X+ /* version information */
X+ #ifdef SHORT_FILENAMES
X+ #include "patchlev.h"
X+ #else
X+ #include "patchlevel.h"
X+ #endif
X+ 
X  #ifdef MAC
X  # ifdef applec	/* Means the MPW compiler, I hope */
X  #  define MPWTOOL
X***************
X*** 40,47 ****
X  #endif
X  #define NULL	((char *)0)
X  
X! #if !defined(LINT) && !defined(GCC_WARN)
X! static	const char	SCCS_Id[] = "@(#)makedefs.c\t3.1\t93/01/20";
X  #endif
X  
X  #ifdef MICRO
X--- 47,54 ----
X  #endif
X  #define NULL	((char *)0)
X  
X! #if defined(UNIX) && !defined(LINT) && !defined(GCC_WARN)
X! static	const char	SCCS_Id[] = "@(#)makedefs.c\t3.1\t93/05/15";
X  #endif
X  
X  #ifdef MICRO
X***************
X*** 103,108 ****
X--- 110,120 ----
X      *Dont_Edit_Data =
X  	"#\tThis data file is generated by 'makedefs'.  Do not edit. \n";
X  
X+ static struct {
X+ 	long	incarnation;
X+ 	long	features;
X+ } version;
X+ 
X  /* definitions used for vision tables */
X  #define TEST_WIDTH  COLNO
X  #define TEST_HEIGHT ROWNO
X***************
X*** 144,149 ****
X--- 156,162 ----
X  extern void NDECL(monst_init);		/* monst.c */
X  extern void NDECL(objects_init);	/* objects.c */
X  
X+ static void NDECL(make_version);
X  static char *FDECL(xcrypt, (const char *));
X  static int FDECL(check_control, (char *));
X  static char *FDECL(without_control, (char *));
X***************
X*** 174,185 ****
X  static int FDECL(clear_path, (int,int,int,int));
X  #endif
X  
X! char * FDECL(tmpdup, (const char *));
X! char * FDECL(limit, (char *,int));
X  
X  /* input, output, tmp */
X  
X! FILE	*ifp, *ofp, *tfp;
X  
X  #ifdef MACsansMPWTOOL
X  char mac_opt;
X--- 187,198 ----
X  static int FDECL(clear_path, (int,int,int,int));
X  #endif
X  
X! static char *FDECL(tmpdup, (const char *));
X! static char *FDECL(limit, (char *,int));
X  
X  /* input, output, tmp */
X  
X! static FILE *ifp, *ofp, *tfp;
X  
X  #ifdef MACsansMPWTOOL
X  char mac_opt;
X***************
X*** 228,233 ****
X--- 241,249 ----
X  	monst_init();
X  	objects_init();
X  
X+ 	/* construct the current version number */
X+ 	make_version();
X+ 
X  #ifdef MACsansMPWTOOL
X  	while (1) {
X  		macstart();
X***************
X*** 390,395 ****
X--- 406,492 ----
X  	return;
X  }
X  
X+ static void
X+ make_version()
X+ {
X+ 	/*
X+ 	 * integer version number
X+ 	 */
X+ 	version.incarnation = ((long)VERSION_MAJOR << 24) |
X+ 				((long)VERSION_MINOR << 16) |
X+ 				((long)PATCHLEVEL << 8) |
X+ 				((long)EDITLEVEL);
X+ 	/*
X+ 	 * encoded feature list
X+ 	 * Note:  if any of these magic numbers are changed or reassigned,
X+ 	 * EDITLEVEL in patchlevel.h should be incremented at the same time.
X+ 	 * The actual values have no special meaning, and the category
X+ 	 * groupings are just for convenience.
X+ 	 */
X+ 	version.features = 0
X+ 		/* levels and/or topology (0..4) */
X+ #ifdef MULDGN
X+ 			| (1L <<  0)
X+ #endif
X+ #ifdef REINCARNATION
X+ 			| (1L <<  1)
X+ #endif
X+ #ifdef SINKS
X+ 			| (1L <<  2)
X+ #endif
X+ 		/* monsters (5..9) */
X+ #ifdef ARMY
X+ 			| (1L <<  5)
X+ #endif
X+ #ifdef KOPS
X+ 			| (1L <<  6)
X+ #endif
X+ #ifdef MAIL
X+ 			| (1L <<  7)
X+ #endif
X+ 		/* objects (10..14) */
X+ #ifdef TOURIST
X+ 			| (1L << 10)
X+ #endif
X+ #ifdef TUTTI_FRUTTI
X+ 			| (1L << 11)
X+ #endif
X+ #ifdef WALKIES
X+ 			| (1L << 12)
X+ #endif
X+ 		/* flag bits and/or other global variables (15..26) */
X+ #ifdef MUSE
X+ 			| (1L << 15)
X+ #endif
X+ #ifdef POLYSELF
X+ 			| (1L << 16)
X+ #endif
X+ #ifdef TEXTCOLOR
X+ 			| (1L << 17)
X+ #endif
X+ #ifdef INSURANCE
X+ 			| (1L << 18)
X+ #endif
X+ #ifdef ELBERETH
X+ 			| (1L << 19)
X+ #endif
X+ #ifdef EXP_ON_BOTL
X+ 			| (1L << 20)
X+ #endif
X+ #ifdef SCORE_ON_BOTL
X+ 			| (1L << 21)
X+ #endif
X+ 		/* data format [COMPRESS excluded] (27..31) */
X+ #ifdef ZEROCOMP
X+ 			| (1L << 27)
X+ #endif
X+ #ifdef RLECOMP
X+ 			| (1L << 28)
X+ #endif
X+ 			;
X+ 	return;
X+ }
X+ 
X  void
X  do_date()
X  {
X***************
X*** 401,407 ****
X  		perror(filename);
X  		exit(1);
X  	}
X! 	Fprintf(ofp,"/*\tSCCS Id: @(#)date.h\t3.1\t92/01/04 */\n\n");
X  	Fprintf(ofp,Dont_Edit_Code);
X  
X  #ifdef KR1ED
X--- 498,504 ----
X  		perror(filename);
X  		exit(1);
X  	}
X! 	Fprintf(ofp,"/*\tSCCS Id: @(#)date.h\t3.1\t92/04/07 */\n\n");
X  	Fprintf(ofp,Dont_Edit_Code);
X  
X  #ifdef KR1ED
X***************
X*** 414,426 ****
X  	for(c = cbuf; *c != '\n'; c++);	*c = 0; /* strip off the '\n' */
X  	Fprintf(ofp,"#define BUILD_DATE \"%s\"\n", cbuf);
X  	Fprintf(ofp,"#define BUILD_TIME (%ldL)\n", clocktim);
X  #ifdef AMIGA
X  	{
X  	struct tm *tm = localtime((time_t *) &clocktim);
X  	Fprintf(ofp,"#ifdef AMIGA\n");
X  	Fprintf(ofp,"const char amiga_version_string[] = ");
X! 	Fprintf(ofp,"\"\\0$VER: NetHack %s (%d.%d.%d)\";\n",VERSION,tm->tm_mday,
X! 		tm->tm_mon+1,tm->tm_year);
X  	Fprintf(ofp,"#endif\n");
X  	}
X  #endif
X--- 511,528 ----
X  	for(c = cbuf; *c != '\n'; c++);	*c = 0; /* strip off the '\n' */
X  	Fprintf(ofp,"#define BUILD_DATE \"%s\"\n", cbuf);
X  	Fprintf(ofp,"#define BUILD_TIME (%ldL)\n", clocktim);
X+ 	Fprintf(ofp,"\n");
X+ 	Fprintf(ofp,"#define VERSION_NUMBER 0x%08lxL\n", version.incarnation);
X+ 	Fprintf(ofp,"#define VERSION_FEATURES 0x%08lxL\n", version.features);
X+ 	Fprintf(ofp,"\n");
X  #ifdef AMIGA
X  	{
X  	struct tm *tm = localtime((time_t *) &clocktim);
X  	Fprintf(ofp,"#ifdef AMIGA\n");
X  	Fprintf(ofp,"const char amiga_version_string[] = ");
X! 	Fprintf(ofp,"\"\\0$VER: NetHack %d.%d.%d (%d.%d.%d)\";\n",
X! 		VERSION_MAJOR, VERSION_MINOR, PATCHLEVEL,
X! 		tm->tm_mday, tm->tm_mon+1, tm->tm_year);
X  	Fprintf(ofp,"#endif\n");
X  	}
X  #endif
X***************
X*** 445,470 ****
X  		"command line completion",
X  #endif
X  #ifdef COMPRESS
X! 		"compress bones/level/save files",
X  #endif
X  #ifdef ELBERETH
X  		"Elbereth",
X  #endif
X  #ifdef EXP_ON_BOTL
X! 		"experience points on bottom line",
X  #endif
X  #ifdef EXPLORE_MODE
X  		"explore mode",
X  #endif
X- #ifdef WALLIFIED_MAZE
X- 		"fancy mazes",
X- #endif
X  #ifdef MFLOPPY
X  		"floppy drive support",
X  #endif
X  #ifdef TUTTI_FRUTTI
X! 		"fruits",
X  #endif
X  #ifdef KOPS
X  		"Keystone Kops",
X  #endif
X--- 547,575 ----
X  		"command line completion",
X  #endif
X  #ifdef COMPRESS
X! 		"data file compression",
X  #endif
X+ #ifdef WIZARD
X+ 		"debug mode",
X+ #endif
X  #ifdef ELBERETH
X  		"Elbereth",
X  #endif
X  #ifdef EXP_ON_BOTL
X! 		"experience points on status line",
X  #endif
X  #ifdef EXPLORE_MODE
X  		"explore mode",
X  #endif
X  #ifdef MFLOPPY
X  		"floppy drive support",
X  #endif
X  #ifdef TUTTI_FRUTTI
X! 		"fruit names",
X  #endif
X+ #ifdef INSURANCE
X+ 		"insurance against game crashes",
X+ #endif
X  #ifdef KOPS
X  		"Keystone Kops",
X  #endif
X***************
X*** 493,514 ****
X  		"quest dungeon",
X  #endif
X  #ifdef REDO
X! 		"redoing commands",
X  #endif
X  #ifdef REINCARNATION
X  		"rogue level",
X  #endif
X  #ifdef SCORE_ON_BOTL
X! 		"score on bottom line",
X  #endif
X  #ifdef CLIPPING
X  		"screen clipping",
X  #endif
X  #ifdef SEDUCE
X  		"seduction",
X  #endif
X  #ifdef POLYSELF
X! 		"self-polymorphing",
X  #endif
X  #ifdef SHELL
X  		"shell command",
X--- 598,633 ----
X  		"quest dungeon",
X  #endif
X  #ifdef REDO
X! 		"redo command",
X  #endif
X  #ifdef REINCARNATION
X  		"rogue level",
X  #endif
X  #ifdef SCORE_ON_BOTL
X! 		"score on status line",
X  #endif
X  #ifdef CLIPPING
X  		"screen clipping",
X  #endif
X+ #ifdef NO_TERMS
X+ # ifdef MAC
X+ 		"screen control via mactty",
X+ # endif
X+ # ifdef SCREEN_BIOS
X+ 		"screen control via BIOS",
X+ # endif
X+ # ifdef SCREEN_DJGPPFAST
X+ 		"screen control via DJGPP fast",
X+ # endif
X+ # ifdef WIN32CON
X+ 		"screen control via WIN32 console I/O",
X+ # endif
X+ #endif
X  #ifdef SEDUCE
X  		"seduction",
X  #endif
X  #ifdef POLYSELF
X! 		"self-polymorph",
X  #endif
X  #ifdef SHELL
X  		"shell command",
X***************
X*** 535,542 ****
X  #ifdef VISION_TABLES
X  		"vision tables",
X  #endif
X! #ifdef WIZARD
X! 		"wizard mode",
X  #endif
X  #ifdef ZEROCOMP
X  		"zero-compressed save files",
X--- 654,661 ----
X  #ifdef VISION_TABLES
X  		"vision tables",
X  #endif
X! #ifdef WALLIFIED_MAZE
X! 		"walled mazes",
X  #endif
X  #ifdef ZEROCOMP
X  		"zero-compressed save files",
X***************
X*** 571,579 ****
X  		perror(filename);
X  		exit(1);
X  	}
X-      /* Fprintf(ofp,Dont_Edit_Data); */
X- 	Fprintf(ofp,"\nOptions compiled into this version of NetHack:\n");
X  
X  	length = COLNO + 1;	/* force 1st item onto new line */
X  	for (i = 0; i < SIZE(build_opts); i++) {
X  	    str = build_opts[i];
X--- 690,706 ----
X  		perror(filename);
X  		exit(1);
X  	}
X  
X+ 	Fprintf(ofp,
X+ #ifdef BETA
X+ 		"\n    NetHack version %d.%d.%d [beta]\n",
X+ #else
X+ 		"\n    NetHack version %d.%d.%d\n",
X+ #endif
X+ 		VERSION_MAJOR, VERSION_MINOR, PATCHLEVEL);
X+ 
X+ 	Fprintf(ofp,"\nOptions compiled into this edition:\n");
X+ 
X  	length = COLNO + 1;	/* force 1st item onto new line */
X  	for (i = 0; i < SIZE(build_opts); i++) {
X  	    str = build_opts[i];
X***************
X*** 660,666 ****
X  	Sprintf(tempfile, DATA_TEMPLATE, "database.tmp");
X  	Sprintf(filename, DATA_TEMPLATE, DATA_FILE);
X  	Strcat(strcpy(infile, filename),
X! #if (defined(OS2) && !defined(OS2_HPFS)) || defined(WIN32)
X  		".bas"
X  #else
X  		".base"
X--- 787,793 ----
X  	Sprintf(tempfile, DATA_TEMPLATE, "database.tmp");
X  	Sprintf(filename, DATA_TEMPLATE, DATA_FILE);
X  	Strcat(strcpy(infile, filename),
X! #ifdef SHORT_FILENAMES
X  		".bas"
X  #else
X  		".base"
X***************
X*** 933,939 ****
X  	if(s[0] != '%') return(-1);
X  
X  	for(i = 0; deflist[i].defname; i++)
X! 	    if(!strncmp(deflist[i].defname, s+1, sizeof(deflist[i].defname)))
X  		return(i);
X  
X  	return(-1);
X--- 1060,1066 ----
X  	if(s[0] != '%') return(-1);
X  
X  	for(i = 0; deflist[i].defname; i++)
X! 	    if(!strncmp(deflist[i].defname, s+1, strlen(deflist[i].defname)))
X  		return(i);
X  
X  	return(-1);
X***************
X*** 1415,1421 ****
X  
X  static	char	temp[32];
X  
X! char *
X  limit(name,pref)	/* limit a name to 30 characters length */
X  char	*name;
X  int	pref;
X--- 1542,1548 ----
X  
X  static	char	temp[32];
X  
X! static char *
X  limit(name,pref)	/* limit a name to 30 characters length */
X  char	*name;
X  int	pref;
X***************
X*** 1541,1547 ****
X  	return;
X  }
X  
X! char *
X  tmpdup(str)
X  const char *str;
X  {
X--- 1668,1674 ----
X  	return;
X  }
X  
X! static char *
X  tmpdup(str)
X  const char *str;
X  {
X*** /tmp/da11678	Tue Jun  1 16:57:31 1993
X--- util/recover.c	Mon May 17 13:55:18 1993
X***************
X*** 1,4 ****
X! /* recover.c - NetHack version 3.1 */
X  
X  /*
X   *  Utility for reconstructing NetHack save file from a set of individual
X--- 1,6 ----
X! /*	SCCS Id: @(#)recover.c	3.1	93/05/15	*/
X! /*	Copyright (c) Janet Walz, 1992.				  */
X! /* NetHack may be freely redistributed.  See license for details. */
X  
X  /*
X   *  Utility for reconstructing NetHack save file from a set of individual
X***************
X*** 25,31 ****
X  int FDECL(restore_savefile, (char *));
X  void FDECL(set_levelfile_name, (int));
X  int FDECL(open_levelfile, (int));
X! int FDECL(create_savefile, (char *));
X  void FDECL(copy_bytes, (int,int));
X  
X  #ifdef UNIX
X--- 27,33 ----
X  int FDECL(restore_savefile, (char *));
X  void FDECL(set_levelfile_name, (int));
X  int FDECL(open_levelfile, (int));
X! int NDECL(create_savefile);
X  void FDECL(copy_bytes, (int,int));
X  
X  #ifdef UNIX
X***************
X*** 47,53 ****
X  char *argv[];
X  {
X  	int argno;
X! 	char *dir = (char *)0;
X  
X  	if (argc == 1 || (argc == 2 && !strcmp(argv[1], "-"))) {
X  		(void) fprintf(stderr,
X--- 49,58 ----
X  char *argv[];
X  {
X  	int argno;
X! 	const char *dir = (char *)0;
X! #ifdef AMIGA
X! 	char *startdir = (char *)0;
X! #endif
X  
X  	if (argc == 1 || (argc == 2 && !strcmp(argv[1], "-"))) {
X  		(void) fprintf(stderr,
X***************
X*** 90,96 ****
X  	if (!dir) dir = HACKDIR;
X  #endif
X  
X! 	if (dir && chdir(dir) < 0) {
X  		(void) fprintf(stderr, "%s: cannot chdir to %s.\n",
X  				argv[0], dir);
X  		exit(1);
X--- 95,104 ----
X  	if (!dir) dir = HACKDIR;
X  #endif
X  
X! #ifdef AMIGA
X! 	startdir = getcwd(0,255);
X! #endif
X! 	if (dir && chdir((char *) dir) < 0) {
X  		(void) fprintf(stderr, "%s: cannot chdir to %s.\n",
X  				argv[0], dir);
X  		exit(1);
X***************
X*** 100,105 ****
X--- 108,116 ----
X  		(void) restore_savefile(argv[argno]);
X  		argno++;
X  	}
X+ #ifdef AMIGA
X+ 	if (startdir) (void)chdir(startdir);
X+ #endif
X  #ifndef VMS
X  	return 0;
X  #else
X***************
X*** 143,150 ****
X  }
X  
X  int
X! create_savefile(savename)
X! char *savename;
X  {
X  	int fd;
X  
X--- 154,160 ----
X  }
X  
X  int
X! create_savefile()
X  {
X  	int fd;
X  
X***************
X*** 209,215 ****
X  	 *	(non-level-based) game state
X  	 *	other levels
X  	 */
X! 	sfd = create_savefile(savename);
X  	if (sfd < 0) {
X  	    (void) fprintf(stderr, "Cannot create savefile %s.\n", savename);
X  	    (void) close(gfd);
X--- 219,225 ----
X  	 *	(non-level-based) game state
X  	 *	other levels
X  	 */
X! 	sfd = create_savefile();
X  	if (sfd < 0) {
X  	    (void) fprintf(stderr, "Cannot create savefile %s.\n", savename);
X  	    (void) close(gfd);
X*** /tmp/da13252	Tue Jun  1 17:53:27 1993
X--- win/X11/Install.X11	Tue May 25 15:06:03 1993
X***************
X*** 3,12 ****
X  potential for NetHack, little of which is realized here.  If you have ideas
X  and extra time, feel free to send in improvements!
X  
X! There are no explicit UNIX dependencies in this code, but it is only
X! known to work under UNIX, using X11R4 or X11R5.  Other X11R4+ platforms
X! may work as well, with some tweaking likely.  Follow WIN* in
X! sys/unix/Makefile.src for compilation hints.
X  
X  (If you try to compile it with X11R3 or earlier, you will get many errors,
X  starting with complaints about XtPointer not being declared.  If you get
X--- 3,14 ----
X  potential for NetHack, little of which is realized here.  If you have ideas
X  and extra time, feel free to send in improvements!
X  
X! There are no explicit UNIX dependencies in this code, but we have only
X! tested it under UNIX, using X11R4 or X11R5.  We have two reports that the
X! code also works under DesqView/X on MS-DOS with djgpp, but you will have
X! to add dependencies for the X code to that makefile before you can use it.
X! Other X11R4+ platforms may work as well, with some tweaking likely.
X! Follow WIN* in sys/unix/Makefile.src for compilation hints.
X  
X  (If you try to compile it with X11R3 or earlier, you will get many errors,
X  starting with complaints about XtPointer not being declared.  If you get
X***************
X*** 82,97 ****
X  needed for systems that don't use X11.
X  
X  Notes for Sun's OpenWindows:
X!     1.	For OpenWindows 3.x (NOT 2.x), define OPENWINBUG in include/unixconf.h.
X  	The library bug from SunOS 4.1.x is apparently fixed in Solaris 2.x, 
X  	so it is also unnecessary there.  (Defining it when unnecessary
X  	causes the same problem being avoided when it is necessary. :-)
X- 	Add -I/usr/openwin/include to CFLAGS, -L/usr/openwin/lib to LFLAGS,
X- 	and -lm to WINX11LIB in src/Makefile.  (Naturally, if your OpenWindows
X- 	is installed elsewhere, adapt the two openwin paths.)  This will
X- 	allow you to create a game executable.
X  
X!     2.	Run the fonts through convertfont and run bldfamily on the directory.
X  	Now you must let your X server know where to find the fonts.  For a
X  	personal installation, the simplest thing is to include the directory
X  	of the fonts in the environment variable FONTPATH, as set in your
X--- 84,109 ----
X  needed for systems that don't use X11.
X  
X  Notes for Sun's OpenWindows:
X!     1.	For OpenWindows 3.0 (NOT 2.x), define OPENWINBUG in include/unixconf.h.
X  	The library bug from SunOS 4.1.x is apparently fixed in Solaris 2.x, 
X  	so it is also unnecessary there.  (Defining it when unnecessary
X  	causes the same problem being avoided when it is necessary. :-)
X  
X!     2.  In addition to the changes suggested by the comments in src/Makefile,
X! 
X! 	-- for OpenWindows 2.x and 3.0 (NOT 3.1) (i.e., versions for SunOS 4.x),
X! 	   add -I/usr/openwin/include to CFLAGS, -L/usr/openwin/lib to LFLAGS,
X! 	   and -lm to WINX11LIB in src/Makefile.
X! 
X! 	-- for OpenWindows 3.1 (i.e., versions for Solaris 2.x), add
X! 	   -I/usr/openwin/include to CFLAGS, -L/usr/openwin/lib -L/usr/ccs/lib
X! 	   -R/usr/openwin/lib to LFLAGS, and -lsocket -lnsl -lm
X! 	   to WINX11LIB in src/Makefile.
X! 
X! 	(Naturally, if your OpenWindows is installed elsewhere, adapt the
X! 	openwin paths.)  This will allow you to create a game executable.
X! 
X!     3.	Run the fonts through convertfont and run bldfamily on the directory.
X  	Now you must let your X server know where to find the fonts.  For a
X  	personal installation, the simplest thing is to include the directory
X  	of the fonts in the environment variable FONTPATH, as set in your
X***************
X*** 99,107 ****
X  	installation, you have the various "xset fp+" options outlined
X  	above for standard X.
X  
X!     3.  Something must still be done with the NetHack.ad file -- all three
X  	of the possibilities mentioned for standard X11 should work.
X  
X  
X  File				Description
X  ---------	---------------------------------------------------------------
X--- 111,127 ----
X  	installation, you have the various "xset fp+" options outlined
X  	above for standard X.
X  
X!     4.  Something must still be done with the NetHack.ad file -- all three
X  	of the possibilities mentioned for standard X11 should work.
X  
X+ 
X+ Notes for XFree86 - (on linux and BSD386 platforms)
X+ 
X+     1.  Edit src/Makefile for linux/BSD386. Even though you use the 
X+ 	Open Look Window manager, do not define OPENWINBUG.  Use the 
X+ 	standard X11 object and library options.
X+ 
X+     2.  Follow the standard installation directions defined above.
X  
X  File				Description
X  ---------	---------------------------------------------------------------
X*** /tmp/da13268	Tue Jun  1 17:53:31 1993
X--- win/X11/Window.c	Fri Apr 23 14:29:42 1993
X***************
X*** 11,17 ****
X--- 11,25 ----
X  #define PRESERVE_NO_SYSV	/* X11 include files may define SYSV */
X  #endif
X  
X+ #ifdef MSDOS			/* from compiler */
X+ #define SHORT_FILENAMES
X+ #endif
X+ 
X+ #ifdef SHORT_FILENAMES
X+ #include <X11/IntrinsP.h>
X+ #else
X  #include <X11/IntrinsicP.h>
X+ #endif
X  #include <X11/StringDefs.h>
X  
X  #ifdef PRESERVE_NO_SYSV
X*** /tmp/da13292	Tue Jun  1 17:53:37 1993
X--- win/X11/nethack.rc	Wed Mar 17 16:45:19 1993
X***************
X*** 8,15 ****
X  #
X  #
X  OPTIONS=windowtype:x11
X! OPTIONS=confirm,male,fixinv,nopickup,safe_pet,sortpack,tombstone,verbose,news
X! OPTIONS=fruit:pineapple
X  OPTIONS=dogname:Dhairrhuwyth
X  OPTIONS=catname:Ghisteslwchlohm
X  #
X--- 8,15 ----
X  #
X  #
X  OPTIONS=windowtype:x11
X! OPTIONS=confirm,male,fixinv,noautopickup,safe_pet,sortpack,tombstone
X! OPTIONS=verbose,news,fruit:pineapple
X  OPTIONS=dogname:Dhairrhuwyth
X  OPTIONS=catname:Ghisteslwchlohm
X  #
X*** /tmp/da13332	Tue Jun  1 17:53:48 1993
X--- win/X11/winX.c	Fri Apr 23 14:29:07 1993
X***************
X*** 12,17 ****
X--- 12,21 ----
X  #define PRESERVE_NO_SYSV	/* X11 include files may define SYSV */
X  #endif
X  
X+ #ifdef MSDOS			/* from compiler */
X+ #define SHORT_FILENAMES
X+ #endif
X+ 
X  #include <X11/Intrinsic.h>
X  #include <X11/StringDefs.h>
X  #include <X11/Shell.h>
X***************
X*** 23,29 ****
X--- 27,37 ----
X  #include <X11/Xos.h>
X  
X  /* for color support; should be ifdef TEXTCOLOR, but must come before hack.h */
X+ #ifdef SHORT_FILENAMES
X+ #include <X11/IntrinsP.h>
X+ #else
X  #include <X11/IntrinsicP.h>
X+ #endif
X  
X  #ifdef PRESERVE_NO_SYSV
X  # ifdef SYSV
X***************
X*** 109,117 ****
X--- 117,130 ----
X  #endif /* COM_COMPL */
X      X11_number_pad,
X      X11_delay_output,
X+ #ifdef CHANGE_COLOR	/* only a Mac option currently */
X+     donull,
X+     donull,
X+ #endif
X      /* other defs that really should go away (they're tty specific) */
X      X11_start_screen,
X      X11_end_screen,
X+     genl_outrip,
X  };
X  
X  /*
X*** /tmp/da13348	Tue Jun  1 17:53:53 1993
X--- win/X11/winmenu.c	Wed May 19 10:08:41 1993
X***************
X*** 35,47 ****
X  static void FDECL(clear_old_menu, (struct xwindow *));
X  static char *FDECL(copy_of, (const char *));
X  
X- #define check_menu(func_name)					\
X- {								\
X-     if (!menu_info->is_menu) {					\
X- 	impossible("%s:  called before start_menu", func_name);	\
X- 	return;							\
X-     }								\
X- }
X  
X  static char menu_selected;	/* selected menu item */
X  static const char menu_translations[] =
X--- 35,40 ----
X***************
X*** 175,181 ****
X  
X      check_winid(window);
X      menu_info = window_list[window].menu_information;
X!     check_menu("add_menu");
X  
X      item = (struct menu_item *) alloc((unsigned)sizeof(struct menu_item));
X      item->next = (struct menu_item *) 0;
X--- 168,177 ----
X  
X      check_winid(window);
X      menu_info = window_list[window].menu_information;
X!     if (!menu_info->is_menu) {
X! 	impossible("add_menu:  called before start_menu");
X! 	return;
X!     }
X  
X      item = (struct menu_item *) alloc((unsigned)sizeof(struct menu_item));
X      item->next = (struct menu_item *) 0;
X***************
X*** 202,208 ****
X      struct menu_info_t *menu_info;
X      check_winid(window);
X      menu_info = window_list[window].menu_information;
X!     check_menu("end_menu");
X  
X      if(morestr && strlen(morestr))
X  	X11_add_menu(window, 0, 0, morestr);
X--- 198,207 ----
X      struct menu_info_t *menu_info;
X      check_winid(window);
X      menu_info = window_list[window].menu_information;
X!     if (!menu_info->is_menu) {
X! 	impossible("end_menu:  called before start_menu");
X! 	return;
X!     }
X  
X      if(morestr && strlen(morestr))
X  	X11_add_menu(window, 0, 0, morestr);
X***************
X*** 229,246 ****
X      check_winid(window);
X      wp = &window_list[window];
X      menu_info = wp->menu_information;
X! 
X! #if defined(LINT) || defined(GCC_WARN)
X!     {
X! 	/* cannot use check_menu, since it doesn't return anything */
X! 	if (!menu_info->is_menu) {
X! 	    impossible("%s:  called before start_menu", "select_menu");
X! 	    return '\0';
X! 	}
X      }
X- #else
X-     check_menu("select_menu");
X- #endif
X  
X  #ifdef VERBOSE
X      /* ********** */
X--- 228,237 ----
X      check_winid(window);
X      wp = &window_list[window];
X      menu_info = wp->menu_information;
X!     if (!menu_info->is_menu) {
X! 	impossible("select_menu:  called before start_menu");
X! 	return '\0';
X      }
X  
X  #ifdef VERBOSE
X      /* ********** */
X*** /tmp/da13372	Tue Jun  1 17:53:59 1993
X--- win/X11/winstat.c	Wed Mar 10 17:27:15 1993
X***************
X*** 234,239 ****
X--- 234,240 ----
X  /*
X   * Notes:
X   * + Alignment needs a different init value, because -1 is an alignment.
X+  * + Armor Class is an schar, so 256 is out of range.
X   * + Blank value is 0 and should never change.
X   */
X  static struct X_status_value shown_stats[NUM_STATS] = {
X***************
X*** 251,265 ****
X      { "Max HP",		SV_VALUE, (Widget) 0, -1, 0, FALSE, FALSE },	/*10*/
X      { "Power",		SV_VALUE, (Widget) 0, -1, 0, FALSE, FALSE },
X      { "Max Power",	SV_VALUE, (Widget) 0, -1, 0, FALSE, FALSE },
X!     { "Armor Class",	SV_VALUE, (Widget) 0, -1, 0, FALSE, FALSE },
X      { "Level",		SV_VALUE, (Widget) 0, -1, 0, FALSE, FALSE },
X      { "Experience",	SV_VALUE, (Widget) 0, -1, 0, FALSE, FALSE },	/*15*/
X      { "Alignment",	SV_VALUE, (Widget) 0, -2, 0, FALSE, FALSE },
X!     { "Time",		SV_VALUE, (Widget) 0, -2, 0, FALSE, FALSE },
X!     { "Score",		SV_VALUE, (Widget) 0, -2, 0, FALSE, FALSE },
X  
X!     { "",		SV_NAME,  (Widget) 0,  0, 0, FALSE, TRUE }, /* hunger*/
X!     { "Confused",	SV_NAME,  (Widget) 0,  1, 0, FALSE, TRUE },	/*20*/
X      { "Sick",		SV_NAME,  (Widget) 0,  0, 0, FALSE, TRUE },
X      { "Blind",		SV_NAME,  (Widget) 0,  0, 0, FALSE, TRUE },
X      { "Stunned",	SV_NAME,  (Widget) 0,  0, 0, FALSE, TRUE },
X--- 252,266 ----
X      { "Max HP",		SV_VALUE, (Widget) 0, -1, 0, FALSE, FALSE },	/*10*/
X      { "Power",		SV_VALUE, (Widget) 0, -1, 0, FALSE, FALSE },
X      { "Max Power",	SV_VALUE, (Widget) 0, -1, 0, FALSE, FALSE },
X!     { "Armor Class",	SV_VALUE, (Widget) 0,256, 0, FALSE, FALSE },
X      { "Level",		SV_VALUE, (Widget) 0, -1, 0, FALSE, FALSE },
X      { "Experience",	SV_VALUE, (Widget) 0, -1, 0, FALSE, FALSE },	/*15*/
X      { "Alignment",	SV_VALUE, (Widget) 0, -2, 0, FALSE, FALSE },
X!     { "Time",		SV_VALUE, (Widget) 0, -1, 0, FALSE, FALSE },
X!     { "Score",		SV_VALUE, (Widget) 0, -1, 0, FALSE, FALSE },
X  
X!     { "",		SV_NAME,  (Widget) 0, -1, 0, FALSE, TRUE }, /* hunger*/
X!     { "Confused",	SV_NAME,  (Widget) 0,  0, 0, FALSE, TRUE },	/*20*/
X      { "Sick",		SV_NAME,  (Widget) 0,  0, 0, FALSE, TRUE },
X      { "Blind",		SV_NAME,  (Widget) 0,  0, 0, FALSE, TRUE },
X      { "Stunned",	SV_NAME,  (Widget) 0,  0, 0, FALSE, TRUE },
X*** /tmp/da13090	Tue Jun  1 17:34:06 1993
X--- sys/winnt/Makefile.dat	Tue Apr  6 15:58:03 1993
X***************
X*** 1,4 ****
X! # SCCS Id: @(#)Makefile.dat  3.1   93/02/21
X  # Copyright (c) NetHack PC Development Team 1992,1993
X  # NetHack may be freely redistributed.  See license for details.
X  #
X--- 1,4 ----
X! # SCCS Id: @(#)Makefile.dat  3.1   93/04/02
X  # Copyright (c) NetHack PC Development Team 1992,1993
X  # NetHack may be freely redistributed.  See license for details.
X  #
X***************
X*** 5,12 ****
X  #       NT NetHack 3.1 DAT Makefile 
X  #	for MS NMAKE for Windows NT
X  #  
X! #	NT Version Tested:  October 1992 SDK pre-release
X! #			    + December '92 compiler fix
X  #
X  #       For questions read the Install.nt file included with
X  #       the distribution.
X--- 5,12 ----
X  #       NT NetHack 3.1 DAT Makefile 
X  #	for MS NMAKE for Windows NT
X  #  
X! #	NT Version Tested:  March 1993 SDK pre-release
X! #
X  #
X  #       For questions read the Install.nt file included with
X  #       the distribution.
X*** /tmp/da13098	Tue Jun  1 17:34:08 1993
X--- sys/winnt/Makefile.src	Tue Apr  6 15:58:16 1993
X***************
X*** 1,12 ****
X! #       SCCS Id: @(#)Makefile.src       3.1     93/02/21
X  #       Copyright (c) NetHack PC Development Team 1993
X  #
X  #       NT NetHack 3.1 Src Makefile 
X  #	for MS NMAKE for Windows NT
X  #  
X! #	NT Version Tested:  October 1992 SDK pre-release
X! #			    + December '92 compiler fix
X  #
X  #       For questions read the Install.nt file included with
X  #       the distribution.
X  #
X--- 1,12 ----
X! #       SCCS Id: @(#)Makefile.src       3.1     93/04/02
X  #       Copyright (c) NetHack PC Development Team 1993
X  #
X  #       NT NetHack 3.1 Src Makefile 
X  #	for MS NMAKE for Windows NT
X  #  
X! #	NT Version Tested:  March 1993 SDK pre-release
X  #
X+ #
X  #       For questions read the Install.nt file included with
X  #       the distribution.
X  #
X***************
X*** 24,32 ****
X  #  Set the gamedir according to your preference.  It must be present prior
X  #  to compilation.
X  
X! GAME    = nethack            # Game Name
X! GAMEDIR = c:\games\hackdir      # Game directory
X  
X  #
X  #  Source directories.    Makedefs hardcodes these, don't change them.
X  #
X--- 24,33 ----
X  #  Set the gamedir according to your preference.  It must be present prior
X  #  to compilation.
X  
X! GAME    = nethack               # Game Name
X! GAMEDIR = c:\games\nethack      # Game directory
X  
X+ 
X  #
X  #  Source directories.    Makedefs hardcodes these, don't change them.
X  #
X***************
X*** 47,60 ****
X  #
X  #  Uncomment the next two lines _ONLY_ if you do not want any
X  #  debug capability in the object files, or in the NetHack executable.
X  #cdebug =
X  #linkdebug =
X  
X  #
X! #  The default make target (so just typing 'nmake' is useful).
X! #
X  
X- default : $(GAMEFILE)
X  
X  ######################################################################
X  #
X--- 48,65 ----
X  #
X  #  Uncomment the next two lines _ONLY_ if you do not want any
X  #  debug capability in the object files, or in the NetHack executable.
X+ #  Leave them commented if you want debug capability.
X  #cdebug =
X  #linkdebug =
X  
X  #
X! #  To embed the nethack ICON into the .exe file, comment out 
X! #  the first line and uncomment the second line below.
X! #  Note that for this to work, you must have sucessfully uudecoded the 
X! #  file sys\winnt\nhico.uu into sys\winnt\nethack.ico (appr. 766 bytes).
X! RESFILE = 
X! #RESFILE = $(GAME).rbj
X  
X  
X  ######################################################################
X  #
X***************
X*** 67,73 ****
X--- 72,84 ----
X  #       This line should not be deleted.
X  
X  NTSUB = -DWIN32CON
X+ 
X  #
X+ #  The default make target (so just typing 'nmake' is useful).
X+ #
X+ default : $(GAMEFILE)
X+ 
X+ #
X  #  Make Rules.
X  #
X  
X***************
X*** 157,167 ****
X  install: install.tag
X  
X  install.tag:    $(GAMEFILE) $(DAT)\sp_lev.tag
X-     copy $(SYS)\termcap       $(GAMEDIR)
X      copy $(DAT)\*.?           $(GAMEDIR)
X      copy $(DAT)\*.dat         $(GAMEDIR)
X      copy $(DAT)\*.lev         $(GAMEDIR)
X!     copy $(SYS)\NetHack.cnf   $(GAMEDIR)
X      copy $(UTIL)\recover.exe  $(GAMEDIR)
X      del   $(GAMEDIR)\makefile
X      echo install done > install.tag
X--- 168,177 ----
X  install: install.tag
X  
X  install.tag:    $(GAMEFILE) $(DAT)\sp_lev.tag
X      copy $(DAT)\*.?           $(GAMEDIR)
X      copy $(DAT)\*.dat         $(GAMEDIR)
X      copy $(DAT)\*.lev         $(GAMEDIR)
X!     copy $(MSYS)\winnt.cnf    $(GAMEDIR)\NetHack.cnf
X      copy $(UTIL)\recover.exe  $(GAMEDIR)
X      del   $(GAMEDIR)\makefile
X      echo install done > install.tag
X***************
X*** 169,178 ****
X  #
X  #  The main target.
X  #
X! $(GAMEFILE) : $(GAME).res  $(UTIL)\utility.tag
X!     $(link) $(linkdebug) $(conflags) -out:$*.exe @$(GAME).res $(conlibs)
X  
X! $(GAME).res : $(ALLOBJ)
X      @echo $(VOBJ01) > $@
X      @echo $(VOBJ02) >> $@
X      @echo $(VOBJ03) >> $@
X--- 179,188 ----
X  #
X  #  The main target.
X  #
X! $(GAMEFILE) : $(GAME).lnk $(RESFILE) $(UTIL)\utility.tag
X!     $(link) $(linkdebug) $(conflags) -out:$*.exe $(RESFILE) @$(GAME).lnk $(conlibs)
X  
X! $(GAME).lnk : $(ALLOBJ)
X      @echo $(VOBJ01) > $@
X      @echo $(VOBJ02) >> $@
X      @echo $(VOBJ03) >> $@
X***************
X*** 198,204 ****
X--- 208,225 ----
X      @echo $(SOBJ) >> $@
X      @echo $(VVOBJ) >> $@
X  
X+ $(GAME).rbj : $(GAME).res
X+     cvtres -$(CPU) $(GAME).res -o $(GAME).rbj
X  
X+ $(GAME).res : $(GAME).rc 
X+     rc -r $(GAME).rc
X+ 
X+ $(GAME).rc : $(GAME)_.ico
X+     @echo $(GAME)Icon ICON $(GAME)_.ico >$@
X+ 
X+ $(GAME)_.ico : $(MSYS)\$(GAME).ico
X+     @copy $(MSYS)\$(GAME).ico $(GAME)_.ico
X+     
X  #
X  #  The following include files depend on makedefs to be created.
X  #
X***************
X*** 236,244 ****
X  getline.o : $(WIN)\getline.c
X      $(cc) $(cflags) $(NTSUB) -I$(INCL)  $(cvars) $(cdebug) -Fo$*.o $(WIN)\$*.c
X  
X- termcap.o : $(CONFIG_H) $(WIN)\termcap.c
X-     $(cc) $(cflags) $(NTSUB) -I$(INCL)  $(cvars) $(cdebug) -Fo$*.o $(WIN)\$*.c
X- 
X  topl.o : $(CONFIG_H) $(WIN)\topl.c
X      $(cc) $(cflags) $(NTSUB) -I$(INCL)  $(cvars) $(cdebug) -Fo$*.o $(WIN)\$*.c
X  
X--- 257,262 ----
X***************
X*** 245,250 ****
X--- 263,273 ----
X  wintty.o : $(CONFIG_H) $(WIN)\wintty.c
X      $(cc) $(cflags) $(NTSUB) -I$(INCL)  $(cvars) $(cdebug) -Fo$*.o $(WIN)\$*.c
X  
X+ # March '93 Compiler has bugs.  Routines needing work arounds.
X+ 
X+ attrib.o      : $(HACK_H)
X+     $(cc) $(cflags) -DWIN32_BUG $(NTSUB) -I$(INCL) $(cvars) $(cdebug) -Fo$*.o $*.c
X+ 
X  #
X  #  Housekeeping.
X  #
X***************
X*** 251,256 ****
X--- 274,284 ----
X  
X  clean :
X      -del *.o
X+     -if exist *.rc  del *.rc
X+     -if exist *.ico del *.ico
X+     -if exist *.res del *.res
X+     -if exist *.lnk del *.lnk
X+     -if exist *.rbj del *.rbj
X  
X  spotless : clean
X      -del $(INCL)\date.h
X***************
X*** 261,267 ****
X      -del $(UTIL)\makedefs.exe
X      -del $(UTIL)\lev_comp.exe
X      -del $(UTIL)\dgn_comp.exe
X!     -del $(UTIL)\*.res
X      -del $(UTIL)\*.def
X      -del $(UTIL)\*.map
X      -del $(DAT)\data
X--- 289,295 ----
X      -del $(UTIL)\makedefs.exe
X      -del $(UTIL)\lev_comp.exe
X      -del $(UTIL)\dgn_comp.exe
X!     -del $(UTIL)\*.lnk
X      -del $(UTIL)\*.def
X      -del $(UTIL)\*.map
X      -del $(DAT)\data
X***************
X*** 273,279 ****
X  alloc.o       : $(CONFIG_H)
X  apply.o       : $(HACK_H)
X  artifact.o    : $(HACK_H)       $(INCL)\artifact.h
X- attrib.o      : $(HACK_H)
X  bones.o       : $(HACK_H)
X  botl.o        : $(HACK_H)
X  cmd.o         : $(HACK_H)       $(INCL)\func_tab.h
X--- 301,306 ----
X*** /tmp/da13106	Tue Jun  1 17:34:11 1993
X--- sys/winnt/Makefile.utl	Tue Apr  6 15:57:59 1993
X***************
X*** 1,11 ****
X! #       SCCS Id: @(#)Makefile.utl               3.1     93/02/21
X  #       Copyright (c) NetHack PC Development Team 1993
X  #
X  #       NT NetHack 3.1 Utilities Makefile 
X  #	for MS NMAKE for Windows NT
X  #  
X! #	NT Version Tested:  October 1992 SDK pre-release
X! #			    + December '92 compiler fix
X  #
X  #       For questions read the Install.nt file included with
X  #       the distribution.
X--- 1,11 ----
X! #       SCCS Id: @(#)Makefile.utl               3.1     93/04/02
X  #       Copyright (c) NetHack PC Development Team 1993
X  #
X  #       NT NetHack 3.1 Utilities Makefile 
X  #	for MS NMAKE for Windows NT
X  #  
X! #	NT Version Tested:  March 1993 SDK pre-release
X! #
X  #
X  #       For questions read the Install.nt file included with
X  #       the distribution.
END_OF_FILE
if test 55421 -ne `wc -c <'patches02q'`; then
    echo shar: \"'patches02q'\" unpacked with wrong size!
fi
# end of 'patches02q'
echo shar: End of archive 9 \(of 33\).
cp /dev/null ark9isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 33 archives.
    echo "Now execute ./patchit.sh"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
