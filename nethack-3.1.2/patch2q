Path: uunet!gatech!europa.eng.gtefsd.com!emory!ogicse!news.tek.com!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v17i092:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Patch2q/33
Message-ID: <1v8in0$j4g@ying.cna.tek.com>
Date: 11 Jun 93 00:13:20 GMT
Article-I.D.: ying.1v8in0$j4g
Organization: Tektronix, Inc, Redmond, OR, USA
Lines: 2070
Approved: billr@saab.CNA.TEK.COM
NNTP-Posting-Host: saab.cna.tek.com
Xref: uunet comp.sources.games:1757

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 17, Issue 92
Archive-name: nethack31/Patch2q
Patch-To: nethack31: Volume 16, Issue 1-116
Environment: Amiga, Atari, Mac, MS-DOS, Windows-NT, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 17 (of 33)."
# Contents:  patches02k sys/mac/mrecover.hqx
# Wrapped by billr@saab on Thu Jun 10 16:55:04 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'patches02k' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'patches02k'\" to \"'patches02k.orig'\"
  mv -f 'patches02k' 'patches02k.orig'
fi
echo shar: Extracting \"'patches02k'\" \(54276 characters\)
sed "s/^X//" >'patches02k' <<'END_OF_FILE'
X*** /tmp/da11703	Tue Jun  1 17:00:00 1993
X--- sys/amiga/Install.ami	Mon May 17 13:36:03 1993
X***************
X*** 2,19 ****
X  	  Using, Compiling, and Installing Amiga NetHack 3.1
X        (or Everything You Never Wanted to Know Before NetHacking)
X  
X! 	     Last Revision: 22 February 1993 for NetHack 3.1.1
X  
X  
X! 0. Pre-intro for NetHack 3.1.1.
X!    New for 3.1.1:
X!      Audio support.
X!      Much faster loading, slightly smaller files.
X!      HackWB allows NewGame to be copied for multiple sets of defaults.
X!      HackCli allows options to be changed between games.
X!      Many fewer bugs.
X! 
X!    We would also like to thank each and every one of the people who took
X     the time and effort to report bugs to us.  THANK YOU!
X  
X  I. Introduction
X--- 2,19 ----
X  	  Using, Compiling, and Installing Amiga NetHack 3.1
X        (or Everything You Never Wanted to Know Before NetHacking)
X  
X! 	     Last Revision: 12 May 1993 for NetHack 3.1.2
X  
X  
X! 0. Pre-intro for NetHack 3.1.2.
X!    New for 3.1.2:
X!      Addition of asksavedisk option to eliminate need for savedir;n syntax
X!      Scrolling message window if screen is tall enough.
X!      Consolidation of defaults and config information into one in HackWB.
X!      All known fatal bugs dealing with the Amiga port have been fixed.
X!      Preliminary tty mode - see below.
X!      
X!    We would like to thank each and every one of the people who took
X     the time and effort to report bugs to us.  THANK YOU!
X  
X  I. Introduction
X***************
X*** 52,59 ****
X      compiling NetHack, you may use the same address, or, for compiler
X      specific problems, send mail to:
X      	Greg Olson (golson@sundown.sun.com)  for Manx
X!     	Ken Lorber (keni@oasys.dt.navy.mil) for SAS/C, or
X!     	Richard Addison (addison@pollux.usc.edu) for either.
X      We do not currently have a contact for the DICE port.
X  
X  I.C. Credits
X--- 52,58 ----
X      compiling NetHack, you may use the same address, or, for compiler
X      specific problems, send mail to:
X      	Greg Olson (golson@sundown.sun.com)  for Manx
X!     	Richard Addison (addison@pollux.usc.edu) for SAS/C.
X      We do not currently have a contact for the DICE port.
X  
X  I.C. Credits
X***************
X*** 195,230 ****
X  	A-filla.lev	A-fillb.lev	A-goal.lev	A-locate.lev
X  	A-start.lev	air.lev		asmodeus.lev	astral.lev
X  	B-filla.lev	B-fillb.lev	B-goal.lev	B-locate.lev
X! 	B-start.lev	baalz.lev	Bell		bigroom.lev
X! 	Bugle		C-filla.lev	C-fillb.lev	C-goal.lev
X! 	C-locate.lev	C-start.lev	castle.lev	cmdhelp
X! 	data		default.icon	Drum_Of_Earthquake
X  	dungeon		E-filla.lev	E-fillb.lev	E-goal.lev
X  	E-locate.lev	E-start.lev	earth.lev	fakewiz1.lev
X! 	fakewiz2.lev	Fire_Horn	fire.lev	Frost_Horn
X! 	Guidebook	Guidebook.info	H-filla.lev	H-fillb.lev
X! 	H-goal.lev	H-locate.lev	H-start.lev	hack/8
X! 	hack.font	HackWB		HackWB.info	HackCli
X! 	help		hh		history		juiblex.lev
X! 	K-filla.lev	K-fillb.lev	K-goal.lev	K-locate.lev
X! 	K-start.lev	knox.lev	Leather_Drum	license
X! 	logfile		Magic_Flute	Magic_Harp	ManPage
X! 	ManPage.info	medusa-1.lev	medusa-2.lev	minefill.lev
X! 	minetown.lev	mine_end.lev	NetHack.cnf	NetHack.c01
X! 	NetHack.d00	news		NewGame.info	opthelp
X! 	options		oracle.lev	oracles		orcus.lev
X! 	P-filla.lev	P-fillb.lev	P-goal.lev	P-locate.lev
X! 	P-start.lev	perm		quest.dat	R-filla.lev
X! 	R-fillb.lev	R-goal.lev	R-locate.lev	R-start.lev
X! 	ReadMe		ReadMe.info	record		recover
X! 	rumors		S-filla.lev	S-fillb.lev	S-goal.lev
X! 	S-locate.lev	S-start.lev	sanctum.lev	T-filla.lev
X! 	T-fillb.lev	T-goal.lev	T-locate.lev	T-start.lev
X! 	Tooled_Horn	tower1.lev	tower2.lev	tower3.lev
X! 	V-filla.lev	V-fillb.lev	V-goal.lev	V-locate.lev
X! 	V-start.lev	valley.lev	W-filla.lev	W-fillb.lev
X! 	W-goal.lev	W-locate.lev	W-start.lev	water.lev
X! 	wizard1.lev	wizard2.lev	wizard3.lev	wizhelp
X  	Wooden_Flute	Wooden_Harp
X  
X      HackExe:
X--- 194,235 ----
X  	A-filla.lev	A-fillb.lev	A-goal.lev	A-locate.lev
X  	A-start.lev	air.lev		asmodeus.lev	astral.lev
X  	B-filla.lev	B-fillb.lev	B-goal.lev	B-locate.lev
X! 	B-start.lev	baalz.lev	bigroom.lev	C-filla.lev
X! 	C-fillb.lev	C-goal.lev	C-locate.lev	C-start.lev
X! 	castle.lev	cmdhelp		data		default.icon
X  	dungeon		E-filla.lev	E-fillb.lev	E-goal.lev
X  	E-locate.lev	E-start.lev	earth.lev	fakewiz1.lev
X! 	fakewiz2.lev	fire.lev	Guidebook	Guidebook.info
X! 	H-filla.lev	H-fillb.lev	H-goal.lev	H-locate.lev
X! 	H-start.lev	hack.font	HackWB		HackWB.info
X! 	HackCli		help		hh		history
X! 	juiblex.lev	K-filla.lev	K-fillb.lev	K-goal.lev
X! 	K-locate.lev	K-start.lev	knox.lev	license
X! 	logfile		ManPage		ManPage.info	medusa-1.lev
X! 	medusa-2.lev	minefill.lev	minetown.lev	mine_end.lev
X! 	NetHack.cnf	NetHack.c01	NetHack.d00	news
X! 	NewGame.info	opthelp		options		oracle.lev
X! 	oracles		orcus.lev	P-filla.lev	P-fillb.lev
X! 	P-goal.lev	P-locate.lev	P-start.lev	perm
X! 	quest.dat	R-filla.lev	R-fillb.lev	R-goal.lev
X! 	R-locate.lev	R-start.lev	ReadMe		ReadMe.info
X! 	record		recover		rumors		S-filla.lev
X! 	S-fillb.lev	S-goal.lev	S-locate.lev	S-start.lev
X! 	sanctum.lev	T-filla.lev	T-fillb.lev	T-goal.lev
X! 	T-locate.lev	T-start.lev	tower1.lev	tower2.lev
X! 	tower3.lev	V-filla.lev	V-fillb.lev	V-goal.lev
X! 	V-locate.lev	V-start.lev	valley.lev	W-filla.lev
X! 	W-fillb.lev	W-goal.lev	W-locate.lev	W-start.lev
X! 	water.lev	wizard1.lev	wizard2.lev	wizard3.lev
X! 	wizhelp
X! 
X!     NetHack:hack
X! 	8
X! 
X!     NetHack:sounds
X! 	Bell		Bugle		Drum_Of_Earthquake
X! 	Fire_Horn	Frost_Horn	Leather_Drum
X! 	Magic_Flute	Magic_Harp	Tooled_Horn
X  	Wooden_Flute	Wooden_Harp
X  
X      HackExe:
X***************
X*** 267,274 ****
X      CAREFULLY through the Makefile to familiarize yourself with which
X      assignments are assumed.  Otherwise, you're going to get something
X      like "Insert NHS: in any drive." requestors.  You will need the
X!     programs uudecode, flex, and bison.  Be sure the p bit is set in
X!     the permissions for ifchange.  The first thing Makefile.ami does
X      is build a program called 'makedefs', which handles a variety of
X      data file generation, and a pair of programs called 'lev_comp' and
X      'dgn_comp' which compile the special levels.  Makedefs will then be
X--- 272,278 ----
X      CAREFULLY through the Makefile to familiarize yourself with which
X      assignments are assumed.  Otherwise, you're going to get something
X      like "Insert NHS: in any drive." requestors.  You will need the
X!     programs uudecode, flex, and bison.  The first thing Makefile.ami does
X      is build a program called 'makedefs', which handles a variety of
X      data file generation, and a pair of programs called 'lev_comp' and
X      'dgn_comp' which compile the special levels.  Makedefs will then be
X***************
X*** 308,314 ****
X  
X  	* Included in the SAS/C port is code for generating a SnapShot.tb
X  	  file upon catching various internal disasters.  That is why the
X! 	  -d1 flag is in the makefile.  This adds about 270K to the disk
X  	  image, but it does not increase the run time memory requirements.
X            (But note that this is not useful for split binaries - see below.)
X  
X--- 312,318 ----
X  
X  	* Included in the SAS/C port is code for generating a SnapShot.tb
X  	  file upon catching various internal disasters.  That is why the
X! 	  debug=l flag is in the makefile.  This adds about 270K to the disk
X  	  image, but it does not increase the run time memory requirements.
X            (But note that this is not useful for split binaries - see below.)
X  
X***************
X*** 348,350 ****
X--- 352,369 ----
X      decision is based on the presence (or absence) of HackExe:NetHack.dir.
X      Note that the contents of NetHack.dir after a build will generally not
X      be the correct contents for a floppy based system.
X+ 
X+ IV.C.2 TTY Interface
X+     There is a basic tty interface available under 3.1.2.  This is a
X+     preliminary version and it will change in the future.  Expect bugs.
X+     (Due to the instability of the interface it will not be in the
X+     official binaries for 3.1.2).  The TTY mode is designed for use in
X+     a BBS setting - it is specifically not recommended for use on the
X+     console.  The TTY interface is not currently compatible with split
X+     binaries - invoke NetHack directly as NetHack.  In addition, you should
X+     specify #undef SHELL when you compile and add "OPTIONS=windowtype=tty"
X+     and delete GRAPHICS from NetHack.cnf; a 24x80 ANSI-compatible terminal
X+     is assumed.  The present version does not deal with protecting one
X+     user's saved games from another's, or deal with situations such as
X+     low disk space gracefully.  Bug reports and suggestions for improvements
X+     are requested from the user community.
X*** /tmp/da11711	Tue Jun  1 17:00:03 1993
X--- sys/amiga/Makefile.ami	Tue Jun  1 12:07:34 1993
X***************
X*** 22,27 ****
X--- 22,28 ----
X  #   Incl:	"include" directory
X  #   Share:	"share" directory
X  #   NHS:	"src" directory
X+ #   TTY:	"win/tty" directory
X  #   Util:	"util" directory
X  #   OBJ:	destination for object files for main binary
X  #   OBJO:	destination for object files for everything else
X***************
X*** 112,118 ****
X  UUDEC	= uudecode
X  
X  # Flex/Bison command assignments -- Useful only if you have flex/bison
X! FLEX	= flex
X  BISON	= bison
X  # FBFIL and FBLIB may be used, if required by your version of flex or bison,
X  # to specify additional files or libraries to be linked with
X--- 113,119 ----
X  UUDEC	= uudecode
X  
X  # Flex/Bison command assignments -- Useful only if you have flex/bison
X! FLEX	= flex #-Sshare:flexhack.skel
X  BISON	= bison
X  # FBFIL and FBLIB may be used, if required by your version of flex or bison,
X  # to specify additional files or libraries to be linked with
X***************
X*** 124,133 ****
X--- 125,147 ----
X  # "protect +s ifchange"
X  EXECUTE = execute
X  
X+ # SHARED LIBRARY CONFIGURATION
X+ # to build for shared libraries, you need these two objects
X+ # LIBOBJS = OBJ:aglue.o OBJ:amilib.o
X+ 
X+ # NON-SHARED LIBRARY CONFIGURATION
X+ # To build for one particular windowing configuration,
X+ # you need these seven objects
X+ LIBOBJS = OBJ:winami.o OBJ:winstr.o OBJ:winreq.o OBJ:winfuncs.o \
X+ 	  OBJ:winkey.o OBJ:winmenu.o OBJ:amiwind.o
X+ 
X+ AMDEP = amiga:winproto.h amiga:winext.h amiga:windefs.h Incl:winami.h
X+ 
X  # Pathname for the C compiler being used.
X  
X  #[SAS6]
X  CC	= sc
X+ ASM	= asm
X  
X  #[MANX]
X  #CC	= cc
X***************
X*** 159,171 ****
X  # undefine this to not compile with GSTs
X  #GST=gst=$(GSTFILE)
X  #
X! DEBUG=l
X! CFLAGS	= data=far nminc debug=$(DEBUG) idir=incl: cpu=any nostkchk ign=104 \
X! 	codename=none ignore=85,62 strmerge optsize ppbuf=8000 \
X  	afp $(ERRREXX) $(GST)
X  # for files that are too large for the standard flags:
X  CFLAGS2 = code=far nostrmerge
X! WBCFLAGS = ignore=217,62 data=far ansi nminc code=far \
X  	debug=sf $(ERRREXX) $(GST)
X  WBC2FLAGS = define=CLI
X  SPLFLAGS = ignore=77 define=SPLIT dollarok
X--- 173,190 ----
X  # undefine this to not compile with GSTs
X  #GST=gst=$(GSTFILE)
X  #
X! VIEWWINDOW=#define=VIEWWINDOW
X! DEBUG=debug=l
X! #OPTFLAGS=opt optsize optinl optcomp=10 optpeep optgo optdep=5 \
X! 	optrdep=5 optalias
X! CFLAGS	= data=far nminc $(DEBUG) idir=incl: cpu=any nostkchk ign=104 \
X! 	nover codename=none ignore=85,62 strmerge ppbuf=8000 \
X! 	$(OPTFLAGS) \
X! 	${VIEWWINDOW} \
X  	afp $(ERRREXX) $(GST)
X  # for files that are too large for the standard flags:
X  CFLAGS2 = code=far nostrmerge
X! WBCFLAGS = ignore=217,62 data=far ansi nminc code=far idir=incl: cpu=any afp \
X  	debug=sf $(ERRREXX) $(GST)
X  WBC2FLAGS = define=CLI
X  SPLFLAGS = ignore=77 define=SPLIT dollarok
X***************
X*** 296,311 ****
X  	OBJ:monstr.o
X  
X  AMIGAOBJ = \
X! 	OBJ:amidos.o	OBJ:amirip.o 	OBJ:amiwbench.o OBJ:amiwind.o	\
X! 	OBJ:winami.o	OBJ:amisnd.o
X  
X  SHAREOBJ = \
X  	OBJ:pcmain.o	$(RANDOBJ)
X  
X  
X  # All the object files for NetHack:
X  
X! HOBJ = $(COMMOBJ) $(AMIGAOBJ) $(SHAREOBJ) $(MAKEDEFOBJ)
X  
X  # Getting down to business:
X  
X--- 315,333 ----
X  	OBJ:monstr.o
X  
X  AMIGAOBJ = \
X! 	OBJ:amidos.o	OBJ:amirip.o 	OBJ:amiwbench.o \
X! 	$(LIBOBJS) OBJ:amisnd.o
X  
X  SHAREOBJ = \
X  	OBJ:pcmain.o	$(RANDOBJ)
X  
X+ TTYOBJ = \
X+ 	OBJ:getline.o OBJ:termcap.o OBJ:topl.o OBJ:wintty.o OBJ:amitty.o \
X+ 	OBJ:rip.o
X  
X  # All the object files for NetHack:
X  
X! HOBJ = $(COMMOBJ) $(AMIGAOBJ) $(SHAREOBJ) $(MAKEDEFOBJ) $(TTYOBJ)
X  
X  # Getting down to business:
X  
X***************
X*** 557,569 ****
X  
X  OBJ:amirip.o:  Amiga:amirip.c $(HDEP)
X  
X! OBJ:amiwind.o:  Amiga:amiwind.c Amiga:amimenu.c $(HDEP)
X  
X  OBJ:amisnd.o:	Amiga:amisnd.c $(HDEP)
X- 	$(CC) $(CFLAGS) debug=ff $(OBJSPEC)OBJ:amisnd.o Amiga:amisnd.c
X  
X! OBJ:winami.o:	Amiga:winami.c $(HDEP) Amiga:char.c Amiga:colorwin.c Amiga:randwin.c
X  
X  OBJ:amiwbench.o:  Amiga:amiwbench.c $(HDEP)
X  
X  OBJ:random.o:  Share:random.c
X--- 579,605 ----
X  
X  OBJ:amirip.o:  Amiga:amirip.c $(HDEP)
X  
X! OBJ:aglue.o:  Amiga:aglue.a
X! 	$(ASM) -d $(AFLAGS) -oOBJ:aglue.o Amiga:aglue.a
X  
X  OBJ:amisnd.o:	Amiga:amisnd.c $(HDEP)
X  
X! OBJ:winstr.o:	Amiga:winstr.c $(HDEP) $(AMDEP)
X  
X+ OBJ:winreq.o:	Amiga:winreq.c $(HDEP) $(AMDEP) Amiga:colorwin.c
X+ 
X+ OBJ:winfuncs.o:	Amiga:winfuncs.c $(HDEP) $(AMDEP) Incl:patchlevel.h
X+ 
X+ OBJ:winkey.o:	Amiga:winkey.c $(HDEP) $(AMDEP)
X+ 
X+ OBJ:winmenu.o:	Amiga:winmenu.c $(HDEP) $(AMDEP)
X+ 
X+ OBJ:winami.o:	Amiga:winami.c $(HDEP) $(AMDEP) Amiga:char.c Amiga:randwin.c
X+ 
X+ OBJ:amilib.o:	Amiga:amilib.c $(HDEP) $(AMDEP)
X+ 
X+ OBJ:amiwind.o:  Amiga:amiwind.c $(HDEP) $(AMDEP)
X+ 
X  OBJ:amiwbench.o:  Amiga:amiwbench.c $(HDEP)
X  
X  OBJ:random.o:  Share:random.c
X***************
X*** 585,597 ****
X  ASP	= Amiga:splitter
X  OBJO:wb.o: $(WBH) Amiga:wb.c Amiga:wbwin.c Amiga:wbdata.c
X  	$(CC) $(WBCFLAGS) $(SPLFLAGS) $(OBJSPEC)OBJO:wb.o Amiga:wb.c
X! OBJO:wbx.o: $(WBH) Amiga:wbcli.c Amiga:wbwin.c Amiga:wbdata.c Incl:date.h
X  	$(CC) $(WBCFLAGS) $(SPLFLAGS) $(OBJSPEC)OBJO:wbx.o Amiga:wbcli.c
X  OBJO:loader.o: $(ASP)/loader.c $(ASP)/split.h $(ASP)/amiout.h $(ASP)/multi.h
X  	$(CC) $(WBCFLAGS) $(SPLFLAGS) $(OBJSPEC)OBJO:loader.o $(ASP)/loader.c
X  OBJO:multi.o: $(ASP)/multi.c $(ASP)/multi.h
X  	$(CC) $(WBCFLAGS) $(SPLFLAGS) $(OBJSPEC)OBJO:multi.o $(ASP)/multi.c
X! OBJO:cli.o: $(WBH) Amiga:wbcli.c Incl:date.h
X  	$(CC) $(WBCFLAGS) $(WBC2FLAGS) $(SPLFLAGS) $(OBJSPEC)OBJO:cli.o Amiga:wbcli.c
X  ####
X  # splitter support
X--- 621,633 ----
X  ASP	= Amiga:splitter
X  OBJO:wb.o: $(WBH) Amiga:wb.c Amiga:wbwin.c Amiga:wbdata.c
X  	$(CC) $(WBCFLAGS) $(SPLFLAGS) $(OBJSPEC)OBJO:wb.o Amiga:wb.c
X! OBJO:wbx.o: $(WBH) Amiga:wbcli.c Amiga:wbwin.c Amiga:wbdata.c #Incl:date.h
X  	$(CC) $(WBCFLAGS) $(SPLFLAGS) $(OBJSPEC)OBJO:wbx.o Amiga:wbcli.c
X  OBJO:loader.o: $(ASP)/loader.c $(ASP)/split.h $(ASP)/amiout.h $(ASP)/multi.h
X  	$(CC) $(WBCFLAGS) $(SPLFLAGS) $(OBJSPEC)OBJO:loader.o $(ASP)/loader.c
X  OBJO:multi.o: $(ASP)/multi.c $(ASP)/multi.h
X  	$(CC) $(WBCFLAGS) $(SPLFLAGS) $(OBJSPEC)OBJO:multi.o $(ASP)/multi.c
X! OBJO:cli.o: $(WBH) Amiga:wbcli.c Incl:patchlevel.h #Incl:date.h
X  	$(CC) $(WBCFLAGS) $(WBC2FLAGS) $(SPLFLAGS) $(OBJSPEC)OBJO:cli.o Amiga:wbcli.c
X  ####
X  # splitter support
X***************
X*** 993,998 ****
X--- 1029,1035 ----
X  OBJ:rumors.o:  NHS:rumors.c $(HDEP)
X  OBJ:save.o:  NHS:save.c $(HDEP) Incl:lev.h Incl:quest.h
X  OBJ:shk.o:  NHS:shk.c $(HDEP) Incl:eshk.h
X+ 	$(CC) $(CFLAGS) $(CFLAGS2) $(OBJSPEC)$@ NHS:shk.c
X  OBJ:shknam.o:  NHS:shknam.c $(HDEP) Incl:eshk.h
X  OBJ:sit.o:  NHS:sit.c $(HDEP)
X  OBJ:sounds.o:  NHS:sounds.c $(HDEP) Incl:edog.h Incl:eshk.h
X***************
X*** 1017,1022 ****
X--- 1054,1067 ----
X  OBJ:worn.o:  NHS:worn.c $(HDEP)
X  OBJ:write.o:  NHS:write.c $(HDEP)
X  OBJ:zap.o:  NHS:zap.c $(HDEP)
X+ 
X+ OBJ:getline.o:	TTY:getline.c $(HDEP) Incl:wintty.h
X+ OBJ:termcap.o:	TTY:termcap.c $(HDEP) Incl:wintty.h Incl:termcap.h
X+ OBJ:topl.o:	TTY:topl.c $(HDEP) Incl:wintty.h Incl:termcap.h
X+ OBJ:wintty.o:	TTY:wintty.c $(HDEP) Incl:wintty.h Incl:termcap.h
X+ OBJ:amitty.o:	amiga:amitty.c $(HDEP)
X+ OBJ:rip.o:	NHS:rip.c $(HDEP) #more?
X+ 
X  Incl:config.h:  Incl:tradstdc.h Incl:global.h
X  	-setdate Incl:config.h
X  	-wait 2
X*** /tmp/da14854	Wed Jun  2 08:41:45 1993
X--- sys/amiga/NetHack.cnf	Wed Jun  2 08:41:02 1993
X***************
X*** 15,28 ****
X  #OPTIONS=packorder:")[%?+/=!(*0_`,scores:10t/2a,noverbose
X  
X  # Other general options
X! #OPTIONS=time,rest_on_space,nopickup
X  
X  # The search path for files like record, help, opthelp, etc.
X  #PATH=NetHack:
X! PATH=NetHack:playground
X  
X  # My own setup
X! #OPTIONS=name:Rhialto,catname:Killie,time,nopickup
X  
X  # A hard disk configuration.
X  #
X--- 15,28 ----
X  #OPTIONS=packorder:")[%?+/=!(*0_`,scores:10t/2a,noverbose
X  
X  # Other general options
X! #OPTIONS=time,rest_on_space,noautopickup
X  
X  # The search path for files like record, help, opthelp, etc.
X  #PATH=NetHack:
X! PATH=NetHack:
X  
X  # My own setup
X! #OPTIONS=name:Rhialto,catname:Killie,time,noautopickup
X  
X  # A hard disk configuration.
X  #
X***************
X*** 91,96 ****
X  	   215 213 046 193 192 198 198 046 229 035 \
X  	   060 062 060 062 094 034 095 092 035 123 \
X  	   125 042 125 042 042 035 035 046 035 125 \
X! 	   192 193 092 047 042 033 123 125 064 038 \
X! 	   042 035 047 201 092 200 200 092 201 047 \
X  	   230 234 231 236 212 237 232 235 233
X--- 91,114 ----
X  	   215 213 046 193 192 198 198 046 229 035 \
X  	   060 062 060 062 094 034 095 092 035 123 \
X  	   125 042 125 042 042 035 035 046 035 125 \
X! 	   241 240 242 243 042 033 123 125 064 038 \
X! 	   042 035 244 245 246 247 239 248 249 250 \
X  	   230 234 231 236 212 237 232 235 233
X+ # Monitors vary greatly in their color response.  If the default colors
X+ # are not good on your monitor, here are some other alternatives:
X+ #CBM 1960, set color/contrast for good pure red, green, and blue. True colors.
X+ #PENS=000,fff,a61,7bb,0f0,e0c,00f,f00
X+ #CBM 1960, set color/contrast as above, better colors for NetHack.
X+ #PENS=667,fff,da1,7bb,2f0,e0d,0af,f42
X+ #and one other suggestion:
X+ #PENS=888,ffc,840,0b8,4e4,e8b,7be,a04
X+ PENS=000,fff,830,7ae,181,c06,23e,c00
X+ # for an "interlaced"+ line screen, the default is courier:13.  If you want
X+ #  a different font, set it here.  The format is "fontname.font:size"; i.e. the
X+ # .font extension is required.
X+ #FONT=topaz.font:13
X+ # Proportional fonts such as CGTimes are probably not a good idea because they
X+ # result in many things not being spaced out correctly.
X+ #FONT=CGTimes.font:15
X+ # This sized proportional font is readable, but still has spacing problems
X+ #FONT=CGTimes.font:21
X*** /tmp/da11743	Tue Jun  1 17:00:12 1993
X--- sys/amiga/amidos.c	Mon Apr 26 17:36:56 1993
X***************
X*** 34,39 ****
X--- 34,40 ----
X  #include "Amiga:amidos.p"
X  
X  extern char Initialized;
X+ extern struct window_procs amii_procs;
X  
X  #ifndef __SASC_60
X  int Enable_Abort = 0;   /* for stdio package */
X***************
X*** 83,89 ****
X      extern struct ExecBase *SysBase;
X  
X      /* Only under 2.0 and later ROMs do we have System() */
X!     if( SysBase->LibNode.lib_Version >= 37 )
X      {
X  	getlin("Enter CLI Command...", buf );
X  	i = System( buf, NULL );
X--- 84,90 ----
X      extern struct ExecBase *SysBase;
X  
X      /* Only under 2.0 and later ROMs do we have System() */
X!     if( SysBase->LibNode.lib_Version >= 37 && !amibbs)
X      {
X  	getlin("Enter CLI Command...", buf );
X  	i = System( buf, NULL );
X***************
X*** 261,282 ****
X  /* this should be replaced */
X  saveDiskPrompt(start)
X  {
X-     extern int saveprompt;
X      char buf[BUFSIZ], *bp;
X      BPTR fileLock;
X  
X!     if (saveprompt) {
X  	    /* Don't prompt if you can find the save file */
X  	if (fileLock = Lock(SAVEF, SHARED_LOCK)) {
X  	    UnLock(fileLock);
X! 	    clear_nhwindow( WIN_BASE );
X  	    return 1;
X  	}
X  	pline( "If save file is on a SAVE disk, put that disk in now." );
X  	if( strlen( SAVEF ) > QBUFSZ - 25 - 22 )
X  	    panic( "not enough buffer space for prompt" );
X! 	getlind("File name ?", buf, SAVEF);
X! 	clear_nhwindow( WIN_BASE );
X  	if (!start && *buf == '\033')
X  	    return 0;
X  
X--- 262,301 ----
X  /* this should be replaced */
X  saveDiskPrompt(start)
X  {
X      char buf[BUFSIZ], *bp;
X      BPTR fileLock;
X  
X!     if (flags.asksavedisk) {
X  	    /* Don't prompt if you can find the save file */
X  	if (fileLock = Lock(SAVEF, SHARED_LOCK)) {
X  	    UnLock(fileLock);
X! #if defined(TTY_GRAPHICS)
X! 	    if(windowprocs.win_init_nhwindows!=amii_procs.win_init_nhwindows)
X! 		clear_nhwindow( WIN_MAP );
X! #endif
X! #if defined(AMII_GRAPHICS)
X! 	    if(windowprocs.win_init_nhwindows==amii_procs.win_init_nhwindows)
X! 		clear_nhwindow( WIN_BASE );
X! #endif
X  	    return 1;
X  	}
X  	pline( "If save file is on a SAVE disk, put that disk in now." );
X  	if( strlen( SAVEF ) > QBUFSZ - 25 - 22 )
X  	    panic( "not enough buffer space for prompt" );
X! /* THIS IS A HACK */
X! #if defined(TTY_GRAPHICS)
X! 	if(windowprocs.win_init_nhwindows!=amii_procs.win_init_nhwindows){
X! 	    getlin("File name ?",buf);
X! 	    clear_nhwindow( WIN_MAP );
X! 	}
X! #endif
X! #if defined(AMII_GRAPHICS)
X! 	if(windowprocs.win_init_nhwindows==amii_procs.win_init_nhwindows){
X! 	    getlind("File name ?", buf, SAVEF);
X! 	    clear_nhwindow( WIN_BASE );
X! 	}
X! #endif
X! 	clear_nhwindow( WIN_MESSAGE);
X  	if (!start && *buf == '\033')
X  	    return 0;
X  
X***************
X*** 448,454 ****
X      chdir(orgdir);      /* chdir, not chdirx */
X  #endif
X  
X!     CleanUp();
X      exit(code);
X  }
X  
X--- 467,476 ----
X      chdir(orgdir);      /* chdir, not chdirx */
X  #endif
X  
X! #ifdef AMII_GRAPHICS
X!     if(windowprocs.win_init_nhwindows==amii_procs.win_init_nhwindows)
X! 	CleanUp();
X! #endif
X      exit(code);
X  }
X  
X*** /tmp/da11751	Tue Jun  1 17:00:15 1993
X--- sys/amiga/amidos.p	Tue Apr 13 15:41:37 1993
X***************
X*** 28,35 ****
X--- 28,39 ----
X  void NDECL(gameDiskPrompt );
X  void FDECL(append_slash, (char *));
X  void FDECL(getreturn, (const char *));
X+ #ifndef msmsg
X  void FDECL(msmsg, ( const char *, ... ));
X+ #endif
X+ #if 0
X  FILE *FDECL(fopenp, (const char * , const char *));
X+ #endif
X  #ifndef	__SASC_60
X  int FDECL(chdir, (char *));
X  #endif
X*** /tmp/da11784	Tue Jun  1 17:00:22 1993
X--- sys/amiga/amii.hlp	Mon May 24 11:20:33 1993
X***************
X*** 1,4 ****
X!             Amiga specific help file for NetHack 3.1.1
X  
X  The Amiga port of NetHack supports a number of additional commands
X  and facilities specific to the Amiga.  Listed below are the things
X--- 1,4 ----
X!             Amiga specific help file for NetHack 3.1.2
X  
X  The Amiga port of NetHack supports a number of additional commands
X  and facilities specific to the Amiga.  Listed below are the things
X***************
X*** 23,28 ****
X--- 23,30 ----
X          SCORE=                  Scores for specified players.
X          CHARACTER=              Class of player (e.g. Rogue).
X          PENS=xxx,xxx,...        8 pen settings for game palette.
X+         FONT=name.font:size     Set the text font for text info.
X+                                 "courier.font:13" is the default.
X          PATH=                   PATH for locating files.
X          OPTIONS=                Comma separated list of options.
X          HACKDIR=                Directory to play game in.
X*** /tmp/da11800	Tue Jun  1 17:00:26 1993
X--- sys/amiga/amimenu.c	Tue Apr 13 15:41:42 1993
X***************
X*** 7,13 ****
X  
X  #define TEXT(nam,str) \
X  static struct IntuiText nam = \
X!   {1,5,JAM2,0,0,0L,(UBYTE*)str,0L}  /* 1,5 == C_WHITE,C_MAGENTA */
X  
X      /* Commands */
X      TEXT(T_HELP,  "?   Display help menu");
X--- 7,13 ----
X  
X  #define TEXT(nam,str) \
X  static struct IntuiText nam = \
X!   {0,1,JAM2,0,0,0L,(UBYTE*)str,0L}  /* 0,1 == C_BLACK,C_WHITE */
X  
X      /* Commands */
X      TEXT(T_HELP,  "?   Display help menu");
X***************
X*** 154,162 ****
X  /* Width = #letters * 8 + 8 + 10 */
X  
X  struct Menu HackMenu[] = {
X!    { &HackMenu[1], 10,0, 72,0,MENUENABLED,"Commands",     &cmdsub[0] }, /*8*/
X!    { &HackMenu[2], 92,0, 80,0,MENUENABLED,"Inventory",    &invsub[0] }, /*9*/
X!    { &HackMenu[3],182,0, 64,0,MENUENABLED,"Actions",      &actsub[0] }, /*7*/
X!    { &HackMenu[4],256,0,104,0,MENUENABLED,"Preparations", &armsub[0] }, /*12*/
X!    { NULL,    370,0, 72,0,MENUENABLED,"Movement",     &movsub[0] },	/*8*/
X  };
X--- 154,162 ----
X  /* Width = #letters * 8 + 8 + 10 */
X  
X  struct Menu HackMenu[] = {
X!    { &HackMenu[1], 0,0, 72,0,MENUENABLED,"Commands",     &cmdsub[0] }, /*8*/
X!    { &HackMenu[2], 82,0, 80,0,MENUENABLED,"Inventory",    &invsub[0] }, /*9*/
X!    { &HackMenu[3],172,0, 64,0,MENUENABLED,"Actions",      &actsub[0] }, /*7*/
X!    { &HackMenu[4],246,0,104,0,MENUENABLED,"Preparations", &armsub[0] }, /*12*/
X!    { NULL,    360,0, 72,0,MENUENABLED,"Movement",     &movsub[0] },	/*8*/
X  };
X*** /tmp/da11808	Tue Jun  1 17:00:28 1993
X--- sys/amiga/amirip.c	Mon May  3 13:34:28 1993
X***************
X*** 1,4 ****
X! /*  SCCS Id: @(#)amirip.c   3.2 93/01/08
X  /* Copyright (c) Kenneth Lorber, Bethesda, Maryland 1991, 1992, 1993. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)amirip.c	3.2	93/04/26	*/
X  /* Copyright (c) Kenneth Lorber, Bethesda, Maryland 1991, 1992, 1993. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 17,22 ****
X--- 17,24 ----
X  #include <string.h>
X  #include "winami.h"
X  
X+ #ifdef AMII_GRAPHICS
X+ 
X  #undef  NULL
X  #define NULL    0
X  
X***************
X*** 156,162 ****
X  static struct RastPort *rp;
X  static unsigned char tomb_line;
X  
X! extern struct DisplayDesc *amiIDisplay;
X  extern struct Screen *HackScreen;
X  extern int havelace;
X  
X--- 158,164 ----
X  static struct RastPort *rp;
X  static unsigned char tomb_line;
X  
X! extern struct amii_DisplayDesc *amiIDisplay;
X  extern struct Screen *HackScreen;
X  extern int havelace;
X  
X***************
X*** 330,338 ****
X  #undef WIN_DEPTH
X  
X  void
X! outrip( how, tmpwin )
X! int how;
X  winid tmpwin;
X  {
X      int done, rtxth;
X      struct IntuiMessage *imsg;
X--- 332,340 ----
X  #undef WIN_DEPTH
X  
X  void
X! amii_outrip( tmpwin, how )
X  winid tmpwin;
X+ int how;
X  {
X      int done, rtxth;
X      struct IntuiMessage *imsg;
X***************
X*** 710,712 ****
X--- 712,716 ----
X        ((tomb_line-6)*(rp->TxHeight+1))+horizon);
X      Text(rp,buf,strlen(buf));
X  }
X+ 
X+ #endif /* AMII_GRAPHICS */
X*** /tmp/da11816	Tue Jun  1 17:00:30 1993
X--- sys/amiga/amisnd.c	Mon Mar 29 12:32:22 1993
X***************
X*** 148,155 ****
X--- 148,157 ----
X  		*t = '_';
X  	if( (fp = fopen( name, "r" )) == NULL )
X  	{
X+ 	    if((fp=fopen(&name[15],"r"))==NULL){
X  		perror( name );
X  		return;
X+ 	    }
X  	}
X  
X  	AudioIO = (struct IOAudio *)
X*** /tmp/da11832	Tue Jun  1 17:00:33 1993
X--- sys/amiga/amiwbench.c	Mon May 24 11:38:38 1993
X***************
X*** 33,39 ****
X--- 33,45 ----
X  extern struct Library *IconBase;
X  #endif
X  
X+ extern void NDECL( preserve_icon );
X+ extern void NDECL( clear_icon );
X+ #ifndef	SHAREDLIB
X+ extern void FDECL( amii_set_text_font, ( char *, int ) );
X+ #endif
X  extern int FDECL(parse_config_line, (FILE *, char *, char *, char *));
X+ extern char *FDECL( ami_default_icon, ( char * ) );
X  
X  int ami_argc;           /* global argc */
X  char **ami_argv;        /* global argv */
X***************
X*** 46,56 ****
X--- 52,67 ----
X  static char iconname[PATHLEN+5];
X  static char origicon[PATHLEN+5];
X  static char savefname[PL_NSIZ];     /* name from name of save file */
X+ int amibbs=0;			/* BBS mode */
X  
X+ #ifdef AMII_GRAPHICS
X  extern int bigscreen;
X+ #endif
X  extern const char *classes; /* liberated from pcmain */
X  extern char PATH[];
X  
X+ static void score(char *);
X+ 
X  /* Called after NetHack.cnf (and maybe NETHACKOPTIONS) are read.
X   * If this is a request to show the score file, do it here and quit.
X   */
X***************
X*** 109,114 ****
X--- 120,126 ----
X      }
X  
X      argline[0]='\0';
X+ #ifdef AMII_GRAPHICS
X      if( p = FindToolType( dobj->do_ToolTypes, "SCREEN" ) )
X      {
X  	extern int bigscreen;
X***************
X*** 117,127 ****
X  	else if( MatchToolValue( p, "LACE" ) )
X  	    bigscreen = 1;
X      }
X      if(dobj->do_ToolTypes)for(x=0;p=dobj->do_ToolTypes[x];x++){
X  	lp=index(p,'=');
X! 	if( !lp++ || strncmp(p, "SCORE", 5 ) == 0 ){
X  	    if((strncmp(p,"SCORES",6)==0) || (strncmp(p,"SCORE",5)==0)){
X! 		if( !lp ) lp = "";
X  		doscore=1;
X  		scorearg=(char *)alloc(strlen(lp)+1);
X  		strcpy(scorearg,lp);
X--- 129,143 ----
X  	else if( MatchToolValue( p, "LACE" ) )
X  	    bigscreen = 1;
X      }
X+ #endif
X      if(dobj->do_ToolTypes)for(x=0;p=dobj->do_ToolTypes[x];x++){
X  	lp=index(p,'=');
X! 	if( !lp || strncmp(p, "SCORE", 5 ) == 0 ){
X  	    if((strncmp(p,"SCORES",6)==0) || (strncmp(p,"SCORE",5)==0)){
X! 		if( !lp )
X! 		    lp = "";
X! 		else
X! 		    ++lp;
X  		doscore=1;
X  		scorearg=(char *)alloc(strlen(lp)+1);
X  		strcpy(scorearg,lp);
X***************
X*** 131,136 ****
X--- 147,153 ----
X  		TTparse=FALSE;
X  	    }
X  	} else {
X+ 	    lp++;
X  	    TTparse=TRUE;
X  		/* new things */
X  	    if((strncmp(p,"CMDLINE",7)==0)||
X***************
X*** 140,147 ****
X--- 157,186 ----
X  		if(*p=='I'){
X  		    FromTool=0; /* ugly hack bugfix */
X  		    FromCLI=1;  /* frontend ICLI only */
X+ 		    if(*argline==':'){
X+ 			char *x=lp;
X+ 			amibbs=1;
X+ #ifdef for_later
X+ 			copy to next blank in argline to amibasename
X+ 			delete from argline
X+ #else
X+ 			while(*x && !isspace(*x))x++;
X+ 			while(*x && isspace(*x))x++;
X+ 			strncpy(argline,x,79);
X+ #endif
X+ 		    }
X  		}
X  	    }
X+ 	    else if( strncmp( p, "FONT", 4 ) == 0 )
X+ 	    {
X+ 		if( p = strdup( lp ) )
X+ 		{
X+ 		    lp = strchr( p, ':' );
X+ 		    *lp++ = 0;
X+ 		    amii_set_text_font( p, atoi( lp ) );
X+ 		    free( p );
X+ 		}
X+ 	    }
X  	    else if( strncmp( p, "SCREEN",6 ) )
X  	    {
X  		if (!parse_config_line((FILE *)0, p, 0, tmp_levels)){
X***************
X*** 148,160 ****
X  		    raw_printf("Bad ToolTypes line: '%s'\n",p);
X  		    getreturn("to continue");
X  		}
X! 	    }
X! 	TTparse=FALSE;
X  	}
X      }
X! 	/* cleanup - from files.c, except we only change things
X! 	 * that are explicitly changed, since we already
X! 	 * did this once to get the defaults (in amidos.c)  */
X      if(plname[0]){
X  	plnamesuffix(); /* from files.c */
X  	set_savefile_name();
X--- 187,202 ----
X  		    raw_printf("Bad ToolTypes line: '%s'\n",p);
X  		    getreturn("to continue");
X  		}
X! 	    } 
X! 	    TTparse=FALSE;
X  	}
X      }
X! 
X!     /* cleanup - from files.c, except we only change things
X!      * that are explicitly changed, since we already
X!      * did this once to get the defaults (in amidos.c)
X!      */
X! 
X      if(plname[0]){
X  	plnamesuffix(); /* from files.c */
X  	set_savefile_name();
X***************
X*** 166,191 ****
X      }
X      FreeDiskObject(dobj);   /* we'll get it again later if we need it */
X  
X!     if(doscore){
X! 	long ac;
X! 	char *p;
X! 	char **av=calloc(1,50*sizeof(char *));
X! #ifdef CHDIR
X! 	chdirx(hackdir,0);
X! #endif
X! 	av[0]="NetHack";            /* why not? */
X! 	av[1]="-s";             /* why not? */
X! 	for(ac=2,p=scorearg;*p;ac++){
X! 	    av[ac]=p;
X! 	    while(*p && !isspace(*p))p++;
X! 	    if(!*p)break;
X! 	    *p++='\0';
X! 	    while(*p && isspace(*p))p++;
X! 	}
X! 	prscore(ac+1,av);
X! 	free( av );
X! 	exit(0);        /* overloaded */
X!     }
X  
X  	    /* if the user started us from the tool icon,
X  	     * we can't save the game in the same place
X--- 208,214 ----
X      }
X      FreeDiskObject(dobj);   /* we'll get it again later if we need it */
X  
X!     if(doscore)score(scorearg);
X  
X  	    /* if the user started us from the tool icon,
X  	     * we can't save the game in the same place
X***************
X*** 197,204 ****
X      }
X  }
X  
X! /* Simulate the command line (-s is already done, although this is
X!  * not exactly the way it should be). Note that we do not handle the
X   * entire range of standard NetHack flags.
X   */
X  void ami_wbench_args(){
X--- 220,226 ----
X      }
X  }
X  
X! /* Simulate the command line. Note that we do not handle the
X   * entire range of standard NetHack flags.
X   */
X  void ami_wbench_args(){
X***************
X*** 234,239 ****
X--- 256,262 ----
X  # endif
X  	    break;
X  #endif
X+ #ifdef AMII_GRAPHICS
X  	case 'L':   /* interlaced screen */
X  	    bigscreen = 1;
X  	    break;
X***************
X*** 240,245 ****
X--- 263,269 ----
X  	case 'l':   /* No interlaced screen */
X  	    bigscreen = -1;
X  	    break;
X+ #endif
X  	case 'u':
X  	    {
X  	    char *c,*dest;
X***************
X*** 257,262 ****
X--- 281,289 ----
X  	    strcpy(savefname,plname);
X  	    set_savefile_name();
X  	    break;
X+ 	case 's':
X+ 	    score(p);
X+ 	    /* NOTREACHED */
X  	default:
X  	    p--;
X  	    if(index(classes,toupper(*p))){
X***************
X*** 270,294 ****
X  	    /* FALL THROUGH */
X  	case '?':
X  	    {
X! 	    char buf[77];
X  
X! 	    raw_printf("Usage: %s -s [-[%s]] [maxrank] [name]...",
X! 	      hname, classes);
X! 	    raw_print("       or");
X! 	    sprintf(buf,"       %s [-u name] [-[%s]]", hname, classes);
X  #if defined(WIZARD) || defined(EXPLORE_MODE)
X! 	    strcat(buf," [-[DX]]");
X  #endif
X  #ifdef NEWS
X! 	    strcat(buf," [-n]");
X  #endif
X  #ifdef MFLOPPY
X  # ifndef AMIGA
X! 	    strcat(" [-r]");
X  # endif
X  #endif
X! 	    raw_print(buf);
X! 	    exit(0);
X  	    }
X  	}
X      }
X--- 297,321 ----
X  	    /* FALL THROUGH */
X  	case '?':
X  	    {
X! 		char buf[77];
X  
X! 		raw_printf("Usage: %s -s [-[%s]] [maxrank] [name]...",
X! 		  hname, classes);
X! 		raw_print("       or");
X! 		sprintf(buf,"       %s [-u name] [-[%s]]", hname, classes);
X  #if defined(WIZARD) || defined(EXPLORE_MODE)
X! 		strcat(buf," [-[DX]]");
X  #endif
X  #ifdef NEWS
X! 		strcat(buf," [-n]");
X  #endif
X  #ifdef MFLOPPY
X  # ifndef AMIGA
X! 		strcat(" [-r]");
X  # endif
X  #endif
X! 		raw_print(buf);
X! 		exit(0);
X  	    }
X  	}
X      }
X***************
X*** 315,326 ****
X  {
X      BPTR lock;
X      char tmp[PATHLEN+5];
X!     struct DiskObject *dobj;
X!     char **savtp, *ourtools[ 21 ];
X! #define CHARACTER   0
X! #define PENS        1
X!     char types[ 4 ][ 80 ];  /* Buffer space for tooltypes until written */
X!     int i, j;
X  
X      if(!FromWBench)return;
X      if(FromCLI)return;
X--- 342,348 ----
X  {
X      BPTR lock;
X      char tmp[PATHLEN+5];
X!     char *n;
X  
X      if(!FromWBench)return;
X      if(FromCLI)return;
X***************
X*** 327,401 ****
X  
X      strcpy(tmp,base);
X      strcat(tmp,".info");
X      if(FromTool){               /* user clicked on main icon */
X! 	(void)CopyFile(DEFAULT_ICON,tmp);
X      } else {                /* from project */
X  	lock=Lock(tmp,ACCESS_READ);
X  	if(lock==0){    /* maybe our name changed - try to get
X! 		 * original icon */
X  	    if(!Rename(origicon,tmp)){
X  		/* nope, build a new icon */
X! 	    lock=Lock(DEFAULT_ICON,ACCESS_READ);
X  	    if(lock==0)return;      /* no icon today */
X  	    UnLock(lock);
X! 	    (void)CopyFile(DEFAULT_ICON,tmp);
X  	    }
X  	} else UnLock(lock);
X      }
X      KillIcon=FALSE;
X- 
X- #if 0
X-     dobj=GetDiskObject(base);
X- 
X-     /* Save the current pointer */
X- 
X-     savtp = (char **)dobj->do_ToolTypes;
X- 
X-     /* Copy the old and set new entries for the WorkBench. */
X- 
X-     for( i = 0; savtp[i]; ++i )
X-     {
X- 	/* Ignore any current settings of these values */
X- 
X- 	if( strncmpi( savtp[ i ], "CHARACTER=", 10 ) == 0 ||
X- 	    strncmpi( savtp[ i ], "PENS=", 5 ) == 0 )
X- 	{
X- 	    continue;
X- 	}
X- 
X- 	ourtools[ i ] = savtp[ i ];
X-     }
X- 
X-     /* Fill in the needed values. */
X- 
X-     ourtools[ i++ ] = types[ CHARACTER ];
X-     sprintf( types[ CHARACTER ], "CHARACTER=%c", *pl_character );
X- 
X-     ourtools[ i++ ] = types[ PENS ];
X-     strcpy( types[ PENS ], "PENS=" );
X- 
X-     /* Put in the pen colors... */
X-     for( j = 0; j < (1L << DEPTH); ++j )
X-     {
X- 	sprintf( types[ PENS ] + strlen( types[ PENS ] ),
X- 	  "%03x,", flags.amii_curmap[ j ] );
X-     }
X- 
X-     /* Remove trailing comma */
X-     types[ PENS ][ strlen( types[ PENS ] ) - 1 ] = 0;
X- 
X-     ourtools[ i ] = NULL;
X- 
X-     /* Set the tools pointer to the temporary copy */
X- 
X-     dobj->do_ToolTypes = (void *)ourtools;
X-     PutDiskObject(base,dobj);
X- 
X-     /* Restore the pointer and free the structures */
X- 
X-     dobj->do_ToolTypes = (void *)savtp;
X-     FreeDiskObject(dobj);
X- #endif
X  }
X  
X  /* How much disk space will we need for the icon? */
X--- 349,373 ----
X  
X      strcpy(tmp,base);
X      strcat(tmp,".info");
X+ 
X+     /* Get the name of the icon */
X+     n = ami_default_icon( DEFAULT_ICON );
X      if(FromTool){               /* user clicked on main icon */
X! 	(void)CopyFile( n, tmp );
X      } else {                /* from project */
X  	lock=Lock(tmp,ACCESS_READ);
X  	if(lock==0){    /* maybe our name changed - try to get
X! 			 * original icon */
X  	    if(!Rename(origicon,tmp)){
X  		/* nope, build a new icon */
X! 	    lock=Lock( n, ACCESS_READ);
X  	    if(lock==0)return;      /* no icon today */
X  	    UnLock(lock);
X! 	    (void)CopyFile( n,tmp);
X  	    }
X  	} else UnLock(lock);
X      }
X      KillIcon=FALSE;
X  }
X  
X  /* How much disk space will we need for the icon? */
X***************
X*** 414,420 ****
X      strcat(tmp,".info");
X      lock=Lock(tmp,ACCESS_READ);
X      if(lock==0){    /* check the default */
X! 	lock=Lock(DEFAULT_ICON,ACCESS_READ);
X  	if(lock==0)return(0);
X      }
X      fib = (struct FileInfoBlock *)AllocMem(ALLOC_SIZE, MEMF_CLEAR);
X--- 386,392 ----
X      strcat(tmp,".info");
X      lock=Lock(tmp,ACCESS_READ);
X      if(lock==0){    /* check the default */
X! 	lock=Lock( ami_default_icon( DEFAULT_ICON ),ACCESS_READ);
X  	if(lock==0)return(0);
X      }
X      fib = (struct FileInfoBlock *)AllocMem(ALLOC_SIZE, MEMF_CLEAR);
X***************
X*** 429,434 ****
X--- 401,422 ----
X      return(rv);
X  }
X  
X+ char *
X+ ami_default_icon( defname )
X+     char *defname;
X+ {
X+     long lock;
X+     static char name[ 300 ];
X+ 
X+     strcpy( name, "NetHack:x.icon" );
X+     name[ 8 ] = pl_character[ 0 ];
X+ 
X+     if( access( name, 0 ) == 0 )
X+     	return( name );
X+ 
X+     return( defname );
X+ }
X+ 
X  /* Delete the icon associated with the given file (NOT the file itself! */
X  /* (Don't worry if the icon doesn't exist */
X  void ami_wbench_unlink(base)
X***************
X*** 447,455 ****
X--- 435,446 ----
X  
X  static int preserved=0;		/* wizard mode && saved save file */
X  
X+ void
X  preserve_icon(){
X      preserved=1;
X  }
X+ 
X+ void
X  clear_icon(){
X      if(!FromWBench)return;
X      if(FromCLI)return;
X***************
X*** 498,501 ****
X--- 489,519 ----
X      }
X      FreeMem(fib,ALLOC_SIZE);
X      return(-1);     /* give up */
X+ }
X+ 
X+ static void
X+ score(scorearg)
X+ 	char *scorearg;
X+         {
X+ 	long ac;
X+ 	char *p;
X+ 	char **av=calloc(1,50*sizeof(char *));
X+ 
X+ #ifdef CHDIR
X+ 	chdirx(hackdir,0);
X+ #endif
X+ 	av[0]="NetHack";            /* why not? */
X+ 	av[1]="-s";             /* why not? */
X+ 	av[2]=0;
X+ 	for(ac=2,p=scorearg;*p;ac++){
X+ 	    av[ac]=p;av[ac+1]=0;
X+ 	    while(*p && !isspace(*p))p++;
X+ 	    if(!*p)break;
X+ 	    *p++='\0';
X+ 	    while(*p && isspace(*p))p++;
X+ 	    /* *p='\0';	/* extra? */
X+ 	}
X+ 	prscore(ac+1,av);
X+ 	free( av );
X+ 	exit(0);        /* #defined to msexit() */
X  }
X*** /tmp/da11968	Tue Jun  1 17:01:16 1993
X--- sys/amiga/wbcli.c	Tue Jun  1 10:42:19 1993
X***************
X*** 11,17 ****
X   * interface; not #defining it supports (along with wb.c) the WB interface.
X   */
X  
X! #include "Incl:date.h"          /* this gives us the version string */
X  
X  #ifdef AZTEC_C
X  /* Aztec doesn't recognize __chip syntax */
X--- 11,18 ----
X   * interface; not #defining it supports (along with wb.c) the WB interface.
X   */
X  
X! /*#include "Incl:date.h"          /* this gives us the version string */
X! #include "Incl:patchlevel.h"	/* and the individual bits */
X  
X  #ifdef AZTEC_C
X  /* Aztec doesn't recognize __chip syntax */
X***************
X*** 52,57 ****
X--- 53,61 ----
X  #ifdef CLI
X  char *cnfsavedir="NetHack:save";    /* unless overridden in cnf file */
X  char argline[255];  /* no overflow - bigger than ADOS will pass */
X+ #ifdef for_later
X+ int amibbs=0;				/* BBS mode flag */
X+ #endif
X  
X  void WaitEOG(GPTR);
X  char *eos(char *);
X***************
X*** 63,69 ****
X  #else
X  extern char *options[NUMIDX+1];
X  extern GPTR gamehead,gameavail;
X- extern DEFAULTS defgame;
X  extern struct Window *win;
X  #endif  /* CLI */
X  
X--- 67,72 ----
X***************
X*** 123,148 ****
X      GPTR gptr;
X      BPTR lc,lc2;
X      struct FileInfoBlock finfo;
X!     char *name;
X      char namebuf[50];
X      char **argv=(char **)wbs;
X- #undef CMDLINE
X- #define CMDLINE
X- #ifdef CMDLINE
X      char newcmdline[80]="";
X      char forcenewcmd=0;
X- #endif
X  
X      ZapOptions( curopts );
X      InitWB( argc, (struct WBStartup *)argv );
X!     errmsg( NO_FLASH, "Welcome to NetHack Version 3.1.1!\n" );
X      CopyRight( );
X  
X      ReadConfig( );
X  
X!     /* Wait till user quits */
X  
X! #ifdef CMDLINE
X      {
X      int c;
X  				/* slow but easy - not a critical path */
X--- 126,155 ----
X      GPTR gptr;
X      BPTR lc,lc2;
X      struct FileInfoBlock finfo;
X!     char *name=0;
X      char namebuf[50];
X      char **argv=(char **)wbs;
X      char newcmdline[80]="";
X      char forcenewcmd=0;
X  
X      ZapOptions( curopts );
X      InitWB( argc, (struct WBStartup *)argv );
X!     errmsg( NO_FLASH, "Welcome to NetHack Version %d.%d.%d!\n",
X!       VERSION_MAJOR, VERSION_MINOR, PATCHLEVEL );
X      CopyRight( );
X  
X      ReadConfig( );
X  
X! #ifdef for_later
X!     /* check for BBS mode */
X!     if (argc>1 && argv[1][0]==':'){
X! 	amibbs=1;
X! 	strcpy(newcmdline,":");
X! 	amibasename= &argv[1][1];
X!     }
X! #endif
X  
X! 		/* check/re-assemble initial command line */
X      {
X      int c;
X  				/* slow but easy - not a critical path */
X***************
X*** 158,175 ****
X  	    }else{
X  		name= &argv[c][2];
X  	    }
X  	}
X  	if(c<argc)strcpy(eos(newcmdline)," ");
X      }
X      eos(newcmdline)[-1]='\0';
X      strcpy(argline,newcmdline);
X-     if(!name){
X- 	errmsg(NO_FLASH, "No name found.\n");
X- 	argline[0]=' ';
X      }
X-     }
X- #endif
X  
X      while( !quit )
X      {
X  	char tbuf[80];
X--- 165,183 ----
X  	    }else{
X  		name= &argv[c][2];
X  	    }
X+ 	    if(!name){
X+ 		errmsg(NO_FLASH, "No name found.\n");
X+ 		newcmdline[0]='\0';	/* don't leave -u as default */
X+ 		forcenewcmd=1;
X+ 	    }
X  	}
X  	if(c<argc)strcpy(eos(newcmdline)," ");
X      }
X      eos(newcmdline)[-1]='\0';
X      strcpy(argline,newcmdline);
X      }
X  
X+     /* Wait till user quits */
X      while( !quit )
X      {
X  	char tbuf[80];
X***************
X*** 177,210 ****
X  	char *dirname=cnfsavedir;
X  /* play a game */
X  
X! #ifdef CMDLINE
X! 	if(forcenewcmd)goto build_new_argline;	/* allow initial args to be
X! 						 * wrong */
X! #endif
X! #ifndef CMDLINE
X! 	{
X! 	    int c;
X! 	    argline[0]='\0';
X! 	    name="NewGame.info";        /* this will fail - it's in NetHack: */
X! 	    for(c=1;c<argc;c++){
X! 		/* slow but easy - not a critical path */
X! 		strcpy(eos(argline),argv[c]);
X! 		if(!strncmp(argv[c],"-u",2)){
X! 		    if(!strcmp(argv[c],"-u")){
X! 			name= argv[c+1];
X! 		    }else{
X! 			name= &argv[c][2];
X! 		    }
X! 		}
X! 		if(c<argc)strcpy(eos(argline)," ");
X! 	    }
X! 	    eos(argline)[-1]='\0';
X! 	}
X! 	if(!name){
X! 	    errmsg(NO_FLASH,"No name found.\n");
X! 	    cleanup(1);
X! 	}
X! #endif
X  #undef TESTCMDLINE
X  #ifdef TESTCMDLINE
X  __builtin_printf("sending '%s'\n",argline);
X--- 185,192 ----
X  	char *dirname=cnfsavedir;
X  /* play a game */
X  
X! 	if(forcenewcmd)
X! 	    goto build_new_argline;	/* allow initial args to be wrong */
X  #undef TESTCMDLINE
X  #ifdef TESTCMDLINE
X  __builtin_printf("sending '%s'\n",argline);
X***************
X*** 211,216 ****
X--- 193,199 ----
X  #else
X  	strcpy(namebuf,cnfsavedir);
X  	condaddslash(namebuf);
X+ 	if(!name)name="NewGame.info";
X  	strcpy(eos(namebuf),name);
X  	lc=Lock(namebuf,ACCESS_READ);
X  	if(!lc){
X***************
X*** 239,272 ****
X  	FreeGITEM(gptr);
X  #endif /* TESTCMDLINE */
X  /* ask about another? */
X- #ifndef CMDLINE
X- 	printf("Play again? [yn] ");
X- 	fgets(tbuf,sizeof(tbuf),stdin);
X- 	while(*p && isspace(*p))p++;
X- 	switch(*p){
X- 	case 'n':
X- 	case 'N':
X- 	    quit=1;
X- 	}
X- #else
X  build_new_argline:
X  	forcenewcmd=0;
X  	{
X! #define NBA	*stpblk(argline)	/* non-blank argline */
X! 	printf("Enter options for next game %s%s%s(space return to clear) ",
X! 	    NBA?"(default ":"" ,
X! 	    NBA?argline:"" ,
X! 	    NBA?")\n":"");
X! 	printf("or Q to quit: ");
X  	fgets(tbuf,sizeof(tbuf),stdin);
X  	tbuf[strlen(tbuf)-1]='\0';		/* kill \n */
X  	if(strlen(tbuf)==1 && (*p=='q' || *p=='Q')){
X  	    quit=1;
X! 	} else
X  	    if(strlen(tbuf))strcpy(argline,tbuf);
X  	}
X- #undef NBA
X- #endif
X      }
X      cleanup(0);
X  }
X--- 222,251 ----
X  	FreeGITEM(gptr);
X  #endif /* TESTCMDLINE */
X  /* ask about another? */
X  build_new_argline:
X  	forcenewcmd=0;
X+ #ifdef for_later
X+ 	if(amibbs) {
X+ 	    quit = 1;		/* bbs mode aborts after one game */
X+ 	} else
X+ #endif
X  	{
X! 	char *x=argline;
X! 	while(isspace(*x))x++;
X! 	if(*x){			/* non-blank argline */
X! 		printf("%s %s %s",
X! 		  "Enter options for next game.  Default:\n\t", argline,
X! 		  "\n(space return to clear) or Q to quit:\n");
X! 	} else {
X! 		printf("Enter options for next game or Q to quit:\n");
X! 	}
X  	fgets(tbuf,sizeof(tbuf),stdin);
X  	tbuf[strlen(tbuf)-1]='\0';		/* kill \n */
X  	if(strlen(tbuf)==1 && (*p=='q' || *p=='Q')){
X  	    quit=1;
X! 		} else
X  	    if(strlen(tbuf))strcpy(argline,tbuf);
X  	}
X      }
X      cleanup(0);
X  }
X***************
X*** 343,348 ****
X--- 322,328 ----
X      int argc;
X      register struct WBStartup *wbs;
X  {
X+     char **argv=(char **)wbs;
X  
X      /* Open Libraries */
X      GfxBase= (struct GfxBase *) OldOpenLibrary("graphics.library");
X***************
X*** 371,376 ****
X--- 351,388 ----
X  	Delay(400);
X  	cleanup(1);
X      }
X+ /* we should include hack.h but due to conflicting options to sc
X+  * we can't parse tradstdc.h and clib/graphics_protos.h - fake it
X+  */
X+ #define NEWS
X+ #define WIZARD
X+     if (argc>1 && argv[1][0]=='?'){
X+ 	    (void) printf(
X+ "\nUsage:\n %s [:uname] [-d dir] -s [-[%s]] [maxrank] [name]...",
X+ 		argv[0], classes);
X+ 	    (void) printf("\n or");
X+ 	    (void) printf("\n %s [-d dir] [-u name] [-[%s]]",
X+ 		argv[0], classes);
X+ #if defined(WIZARD) || defined(EXPLORE_MODE)
X+ 	    (void) printf(" [-[DX]]");
X+ #endif
X+ #ifdef NEWS
X+ 	    (void) printf(" [-n]");
X+ #endif
X+ #ifndef AMIGA
X+ 	    (void) printf(" [-I] [-i] [-d]");
X+ #endif
X+ #ifdef MFLOPPY
X+ # ifndef AMIGA
X+ 	    (void) printf(" [-r]");
X+ # endif
X+ #endif
X+ #ifdef AMIGA
X+ 	    (void) printf(" [-[lL]]");
X+ #endif
X+ 	    putchar('\n');
X+ 	    cleanup(1);
X+ 	}
X  }
X  
X  /* CLI */
X***************
X*** 482,488 ****
X      }
X  
X      /* Set the game name for the status command */
X!     sprintf( gptr->gname, "NetHack 3.1.1 %s", gptr->name );
X  
X      /* Create a process for the game to execute in */
X      ctask = FindTask( NULL );
X--- 494,501 ----
X      }
X  
X      /* Set the game name for the status command */
X!     sprintf( gptr->gname, "NetHack %d.%d.%d %s",
X!       VERSION_MAJOR, VERSION_MINOR, PATCHLEVEL, gptr->name );
X  
X      /* Create a process for the game to execute in */
X      ctask = FindTask( NULL );
X***************
X*** 518,524 ****
X      gptr->wbs->sm_Process = proc;
X      gptr->wbs->sm_Segment = gptr->seglist;
X      gptr->wbs->sm_NumArgs = 2;
X!     gptr->wbs->sm_ToolWindow = "con:0/0/100/300/NetHack 3.1.1";
X      gptr->wbs->sm_ArgList = gptr->wba;
X  
X      /* Fill in the args */
X--- 531,542 ----
X      gptr->wbs->sm_Process = proc;
X      gptr->wbs->sm_Segment = gptr->seglist;
X      gptr->wbs->sm_NumArgs = 2;
X!     {
X!     static char title[45];	/* some slack */
X!     sprintf(title,"con:0/0/100/300/NetHack %d.%d.%d",
X!       VERSION_MAJOR, VERSION_MINOR, PATCHLEVEL);
X!     gptr->wbs->sm_ToolWindow = title;
X!     }
X      gptr->wbs->sm_ArgList = gptr->wba;
X  
X      /* Fill in the args */
X***************
X*** 628,642 ****
X  menu_copyopt()
X  {
X      GPTR gptr;
X!     char newname[ 100 ], oldname[ 100 ], cmd[ 200 ];
X  
X      if( ( gptr = NeedGame() ) == NULL )
X  	return;
X  
X!     if( StrRequest( "Enter new player name", newname, gptr->fname ) == 0 )
X  	return;
X  
X!     if( strcmp( newname, gptr->fname ) == 0 )
X      {
X  	errmsg( FLASH, "Copying aborted, new name same as old" );
X  	return;
X--- 646,660 ----
X  menu_copyopt()
X  {
X      GPTR gptr;
X!     char newname[ 100 ], oldname[ 100 ], cmd[ 300 ], dir[ 100 ];
X  
X      if( ( gptr = NeedGame() ) == NULL )
X  	return;
X  
X!     if( StrRequest( "Enter new player name", newname, gptr->name ) == 0 )
X  	return;
X  
X!     if( strcmp( newname, gptr->name ) == 0 )
X      {
X  	errmsg( FLASH, "Copying aborted, new name same as old" );
X  	return;
X***************
X*** 643,651 ****
X      }
X  
X      strcpy( oldname, GameName( gptr, NULL ) );
X-     strcpy( newname, GameName( gptr, newname ) );
X  
X!     sprintf( cmd, "c:copy \"%s\" \"%s\"", oldname, newname );
X      Execute( cmd, NULL, NULL );
X      MapGadgets( R_DISK, 1 );
X  }
X--- 661,674 ----
X      }
X  
X      strcpy( oldname, GameName( gptr, NULL ) );
X  
X!     strcpy( dir, options[ SAVE_IDX ] );
X!     if( strchr( "/:", dir[strlen(dir)-1] ) == 0 && *dir )
X! 	strcat( dir, "/" );
X!     if( gptr->dobj->do_Gadget.GadgetID == GADNEWGAME )
X! 	sprintf( cmd, "c:copy \"%s\" \"%s%s.cfg.info\"", oldname, dir, newname );
X!     else
X! 	sprintf( cmd, "c:copy \"%s\" \"%s%s.info\"", oldname, dir, newname );
X      Execute( cmd, NULL, NULL );
X      MapGadgets( R_DISK, 1 );
X  }
X***************
X*** 752,757 ****
X--- 775,800 ----
X      Permit();
X  }
X  
X+ void RemoveGITEM( ggptr )
X+     register GPTR ggptr;
X+ {
X+     register GPTR gptr, pgptr = NULL;
X+ 
X+     for( gptr = gamehead; gptr; pgptr = gptr, gptr = gptr->next )
X+     {
X+ 	if( gptr == ggptr )
X+ 	{
X+ 	    if( pgptr )
X+ 		pgptr->next = gptr->next;
X+ 	    else
X+ 		gamehead = gptr->next;
X+ 	    FreeGITEM( gptr );
X+ 	    return;
X+ 	}
X+     }
X+ }
X+ 
X+ 
X  #else   /* CLI */
X  
X  void CloseLibraries( )
X***************
X*** 975,981 ****
X  	}
X  
X  	/* Add the scores entry */
X! 	    SetToolLine( gptr, "SCORES", *buf1 ? buf1 : "all" );
X  
X  	/* Get the scores */
X  	run_game( gptr );
X--- 1018,1024 ----
X  	}
X  
X  	/* Add the scores entry */
X! 	SetToolLine( gptr, "SCORES", *buf1 ? buf1 : "all" );
X  
X  	/* Get the scores */
X  	run_game( gptr );
X***************
X*** 1033,1040 ****
X      char *str;
X      register GPTR gptr;
X  {
X-     if( gptr->dobj->do_Gadget.GadgetID == GADNEWGAME )
X- 	return( 1 );
X      if( strncmp( str, "CHARACTER=", 10 ) == 0 )
X  	return( 0 );
X      return( 1 );
X--- 1076,1081 ----
X***************
X*** 1408,1414 ****
X  	sp[1] = gd->Height - 1;
X  	sp[2] = -1;
X  	sp[3] = -1;
X! 	sp[4] = gd->Width - 1;
X  	sp[5] = -1;
X  
X  	sp[6] = gd->Width + 1;
X--- 1449,1455 ----
X  	sp[1] = gd->Height - 1;
X  	sp[2] = -1;
X  	sp[3] = -1;
X! 	sp[4] = gd->Width-1;
X  	sp[5] = -1;
X  
X  	sp[6] = gd->Width + 1;
X***************
X*** 1576,1598 ****
X      OPTR optr;
X      GPTR gptr;
X  {
X!     char **sp;
X  
X!     for( sp = gptr->dobj->do_ToolTypes; *sp; ++sp )
X!     {
X! 	if( strnicmp( *sp, "options=", 8 ) == 0 )
X! 	{
X! 	    break;
X! 	}
X!     }
X! 
X!     if( *sp == NULL )
X!     {
X! 	errmsg( NO_FLASH, "Options not set for %s", gptr->name );
X! 	return;
X!     }
X! 
X!     CopyOptionStr( optr, *sp + 8 );
X  }
X  
X  /* !CLI */
X--- 1617,1628 ----
X      OPTR optr;
X      GPTR gptr;
X  {
X!     char *sp;
X  
X!     sp = ToolsEntry( gptr, "OPTIONS" );
X!     ZapOptions( optr );
X!     if( sp && *sp )
X! 	CopyOptionStr( optr, sp );
X  }
X  
X  /* !CLI */
X***************
X*** 1658,1664 ****
X  	}
X  
X  	/* If at end of string or comma and we have some text... */
X! 	if( !*t || *t == ',' && *buf )
X  	{
X  	    /* Mark end */
X  	    *s = 0;
X--- 1688,1694 ----
X  	}
X  
X  	/* If at end of string or comma and we have some text... */
X! 	if( ( !*t || *t == ',' ) && *buf )
X  	{
X  	    /* Mark end */
X  	    *s = 0;
X***************
X*** 1732,1738 ****
X  {
X      PutOptions( optr );
X      SetToolLine( gptr, "OPTIONS", options[ OPTIONS_IDX ] );
X-     UpdateGameIcon( gptr );
X  }
X  
X  void
X--- 1762,1767 ----
X***************
X*** 1773,1789 ****
X   * later to clean up whatever "GetDiskObject" allocated.
X   */
X  void ReallocTools( gptr, add )
X!     GPTR gptr;
X!     int add;
X  {
X!     int i, cnt;
X!     char **sp, **tp;
X  
X      for( cnt = 0, tp = gptr->dobj->do_ToolTypes; tp && *tp ; ++tp )
X  	++cnt;
X  
X!     if( !tp )
X      {
X  	/* If no tooltypes array, fudge something to start with */
X  	if( sp = xmalloc( 2 * sizeof( char * ) ) )
X  	{
X--- 1802,1824 ----
X   * later to clean up whatever "GetDiskObject" allocated.
X   */
X  void ReallocTools( gptr, add )
X!     register GPTR gptr;
X!     register int add;
X  {
X!     register int i, cnt;
X!     register char **sp, **tp;
X  
X+     /* Already allocated */
X+     if( gptr->talloc && add == 0 )
X+     	return;
X+ 
X      for( cnt = 0, tp = gptr->dobj->do_ToolTypes; tp && *tp ; ++tp )
X  	++cnt;
X  
X!     if( !tp || cnt == 0 )
X      {
X+ 	if( gptr->talloc )
X+ 	    free( gptr->dobj->do_ToolTypes );
X  	/* If no tooltypes array, fudge something to start with */
X  	if( sp = xmalloc( 2 * sizeof( char * ) ) )
X  	{
X***************
X*** 1799,1807 ****
X  	    sp[i++] = strdup( *tp );
X  	}
X  
X! 	sp[i] = NULL;
X      }
X!     gptr->otools = gptr->dobj->do_ToolTypes;
X      gptr->dobj->do_ToolTypes = sp;
X      gptr->toolcnt = cnt + 1;
X      gptr->talloc = 1;
X--- 1834,1846 ----
X  	    sp[i++] = strdup( *tp );
X  	}
X  
X! 	if( gptr->talloc && gptr->dobj->do_ToolTypes )
X! 	    free( gptr->dobj->do_ToolTypes );
X! 	while( i < cnt+add+1 )
X! 	    sp[ i++ ] = NULL;
X      }
X!     if( ! gptr->talloc )
X! 	gptr->otools = gptr->dobj->do_ToolTypes;
X      gptr->dobj->do_ToolTypes = sp;
X      gptr->toolcnt = cnt + 1;
X      gptr->talloc = 1;
X***************
X*** 1808,1817 ****
X  }
X  
X  void FreeTools( gptr )
X!     GPTR gptr;
X  {
X!     int i;
X!     char **sp;
X  
X      if( !gptr->talloc )
X  	return;
X--- 1847,1856 ----
X  }
X  
X  void FreeTools( gptr )
X!     register GPTR gptr;
X  {
X!     register int i;
X!     register char **sp;
X  
X      if( !gptr->talloc )
X  	return;
X***************
X*** 1835,1842 ****
X  
X      /* Realloc ToolTypes to be in memory we know how to manage */
X  
X!     if( gptr->talloc == 0 )
X! 	ReallocTools( gptr, 0 );
X  
X      sp = gptr->dobj->do_ToolTypes;
X      len = strlen( name );
X--- 1874,1880 ----
X  
X      /* Realloc ToolTypes to be in memory we know how to manage */
X  
X!     ReallocTools( gptr, 0 );
X  
X      sp = gptr->dobj->do_ToolTypes;
X      len = strlen( name );
X*** /tmp/da12128	Tue Jun  1 17:02:15 1993
X--- sys/amiga/splitter/loader.c	Thu May 20 15:41:48 1993
X***************
X*** 276,282 ****
X--- 276,284 ----
X  	{
X  		ULONG *p=where;		/* clear memory block */
X  		ULONG c=(where[-2]/4)-1;	/* (len includes ptr) */
X+ #if 0			/* don't ship enabled - Gigamem returns 0 */
X  		if(!TypeOfMem(p))spanic("clearing bogus memory");
X+ #endif
X  		while(c--)*p++=0;	/* not memset - use longs for speed */
X  	}
X  
END_OF_FILE
if test 54276 -ne `wc -c <'patches02k'`; then
    echo shar: \"'patches02k'\" unpacked with wrong size!
fi
# end of 'patches02k'
if test -f 'sys/mac/mrecover.hqx' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'sys/mac/mrecover.hqx'\" to \"'sys/mac/mrecover.hqx.orig'\"
  mv -f 'sys/mac/mrecover.hqx' 'sys/mac/mrecover.hqx.orig'
fi
echo shar: Extracting \"'sys/mac/mrecover.hqx'\" \(4001 characters\)
sed "s/^X//" >'sys/mac/mrecover.hqx' <<'END_OF_FILE'
X(This file must be converted with BinHex 4.0)
X
X:%QebC@0[GQ9b,R"bEfSZFR0bB`"bFh*M8P0&4!#3#!ar&9d!N!3"!*!$#S!!!!Q
X!!!!"r`!!Bk-+B80XDfPZDA3ZBi!#!*!$9%9B9%Y"5%`"!!!`$febC@0[GQ9b,VN
XZFR0bB`)!N!0bFh*M8P0&4!%!!$3!!(*cFQ058d9%!3!!0!#3"%qm!*!-CKDRXp9
XM!*!'$(m!N!J3!*!$Bk-+B80XDfa[Eh!ZBi!#!*!$9%9B9%Y"5%`"!!"J!'`!N!4
XMU`#3"&Le!!"F!*!,SqX*YD8(Z%F!N!4hD3#3%$e9!"F!N"dL!!%!N!8i!'i!6!$
XQ"!*25`#3"3S!#J!U!8U)!Pi`!*!$$!!S!#J!JJ&m!)!!"!#3!``!+!!S!-)"I!#
X"!!3!N!0)!))!N!MrN!2l"%9NDA3%9@jNE`"D!!!",3#3"!0$GA3!@!!!"%0[F(N
X!3`!!"9"KFh4P!&B!!!9$E'9KFJ#3#$J!J!#3#2q3!rF"&"""BQpeG#"5C@0[GQ9
Xb,T!$!*!%"dKPE(!ZN!-!N!3",3#3#%3!!!2!!X!$`!'!!m!--!J3%#J35"H)%!J
X)%!``!m!!!!2!"q!(i!IJ!m!2m"ri(rJrr$rm2r`rr"ri(rJ2m!2!!!N!"`#3!d!
X'J!l!CZ!hB"r!6mcq%[mUkG6XL#N3-V!&@!5-!`3!!"r!Ir"rq2rmrrlrr[q3#(r
XrIrmrrarq$ri$q!#3!aaZD&*M!*!$!8C548B!N!@!5801)`#3"B!!N!-(39"36!#
X3"K364'&fD@3J5'&TFR0dEfiJ-bmj-`!!!3#3"Km!N!0r`!!JIm!!1$q`!"3rF!!
X512J!#6Gi!!6rH!!#IlJ!!6ri!''Iq!$rc$$Jrq3"-1lb!T!!kIN&82IPLU$[ip9
X!6Z%LJ!(Jb3!2m))!$r%N!!I#LJ!!"9N!!!UNJ!!93N!!%S&J!"N!d!!1!&!!N!-
X`!*!)$rm!!$rr`!"rrr!!Irri!2rrr!$rrri!rj!$!2q3!i$rN!2!rj!$i2q3!r$
XrN!2irj!$r2q3!rcrN!2qrj!$r[q3"(rrN!0rrj!$2rq3!crrN!-Irj!$$rq3!`I
XrN!-$rj!$!Iq3!`$rN!-!Irrr!$rrrJ!Irri!"rrm!!(rm!!!!J#3&[q3!`#3$!m
X4N!2r!*!)m!!!$a'3!am!N!Mrm!!!m4%4(rm!N!F2h`!!m4%4m4m!N!F2hI!!m4r
Xr%4(`!*!(rGm!mI%4m4(`!*!($phr%C!$m4(`!*!)rGm4N!-I%I!!N!J2hI%4N!6
X`!*!&$r!!$rhI%Irr%I!!N!Aa(rra(phr!!$r!!$rm!!!m4'3"2hI!*!%$d6r!!$
Xa(a%I%4rGm!#3!r6d6`!!m4mIm4(rrGm!!!p2N!-!!2%4m4%4m!r3m!$dN!2`!!$
Xa(a'3!r!!m!m26j!$!*!$$rm4(a(`!!rGp%6dm!#3"!rrm4(`!!$r4242!*!&$a'
X3!am!!24%42!!N!82m4%4(`!24242!*!($rrrm!$dp%6pm!#3#Jp2N!2ph`#3#[5
X3!r!2hI!!N!J26j!$!!$ph`#3#!p%p2!!!!r3m!#3"`rd6`#3"2$I!*!)rr!!N!3
X2h`#3$rm!N#@!!!!2rr!!N!Aa(am!N!-0d!mI%I!!N!2G$a(am!#3!`hI%4m!N!-
X2!0hrr`$r!2(rrG!!$d6`m4%Ih3$dp2$a(am0hdp2!2rr(`$d42!!N!2`$d42!*!
X&p26p!*!%$dp2$G!!N!-242!!h3#3"2m!!!d!N!`J"S!1`'EJ0f!I`%r-rK,r+ZR
X8l)JT%$+`"9J%M!-%!*!&pJ!"!*!&H!"Z!)`!jJ3#6dX!N!8+!!S!DJ&+L08a+5"
X6C@aPBh3J)Np`C@iZN!-L)'CbEfdJG'KP)%CTE'8JE@9ZG5i0-LNJ8f9XC@0d)(4
XSC5"RB@eP)(4[)(*PBfpfCA)JCR*[E5"dD'8JC'PKE'pR,Jdc+5"AB@Pd)'C[FL"
XdD'8JFQ9cG@ad)#K25b"[FL"6Eh*bH5NZ$3e%Eb"ZEh3JBA4dC@e`G#"dEb"bC@0
X[GQ9b)'%JCf&YC5"dD'&d)'Pc)#*TEL"`FQpRFQ9cFb)J+'NZC5iJFh4TE'`JFR9
XZEQPZCb"TEL"1CA4)B@0V+5%!N!4!!a'!!*!$!c-Z-695C@0[GQ9b)$-Z-5#3"#J
Xc,cNc+3eZCA4SB@0V,@*eCh0!E'PZBbjMDA-ZGA"PEQiZC@4e!*!$)!-4J!#3!`-
Xc,M%98Q9MEhCPFL!c,M%JN!3S-bmj-bN!N!0#!)%!N!MrN!2V"%CTE'8(6h"PELk
X3!`"2!!!",3#3"!K$E'pcC5"%33"A!!!",3#3"!44G@Pd!&%!N!B8!*!$"!!!J!#
X3!c!!N!-3!*!$3!#3"%)%8(*TGNCA8N3(3faPB@jeF%4A8N3(8(*PC@e`G%4-6NF
X(9f&bEQPZCd4-6NF&3@*[FR4%6%j("NP2)%*eCN4-6NF!N!0%!!!$`!0!!m!"J!'
X!!N!%B!3J"'!&S!3J"'!#3!'!!!!$`!IJ"q!(i!2!!m!(i!r`$r!2m!r`$r!2m!I
XJ!m!"J!!*!!F!N!0%!!!$`!,!!m!"J!'!!N!$`!*!"m!'3!2!!N!$`!'!!!!$`!I
XJ"q!(i!2!!m!(i!IJ"q!2i!rJ"q!(i!IJ!m!"J!!*!!F!N!-G!#J!+!"!!8!!"!#
X3#!%!#&"bEfGbCA0c!*!$%!#3"`F!#`!4!3f!!*!%4!!!!m!$3!2!!B!"J!*!"Q!
X%)!CJ"D!')!4J!d!"J!!!!m!(i!IJ"q!$`!2!"q!2m!r`$r!2m!r`$r!(i!2!!B!
X!#3!(!*!$4!!!!m!$3!2!!B!"J!0!"L!&B!8J"@!&)!9J!N!"J!!!!m!(i!IJ"q!
X$`!2!"q!2m!r`$r!2m!r`$r!(i!2!!B!!#3!(!*!$4!!!!m!#`!2!!B!"J!*!!m!
X#3!2J!Q!$`!*!!m!"J!!!!m!(i!IJ"q!$`!2!"q!(i!IJ"r!(m!IJ"q!(i!2!!B!
X!#3!(!*!$4!!!!m!#`!2!!B!$J!q3!!`3'CJCQ"QB'CJ*N!!-%!2!!!!$`!IJ"q!
X(i!2!$r!Iq"ri2r`rr$rm2r`Iq"ri$r!$`!!*!!F!N!0%!!!$`!0!!m!"J!'!!m!
X&)!DJ"+!'S!5J"U!$3!'!!!!$`!IJ"q!(i!2!!m!(i!r`$r!2m!r`$r!2m!IJ!m!
X"J!!*!!F!!!%!N!-+J!!!#B!!!!(r!"[mX!4U!*!$(!(k!!p"6&*8!!%!JN4*9%`
X!!J#D689193!#!,j$99*6!!F!iNP$6L-!!!&#D@0c)`!!!8j#6N4-!!!"@QjS8Q-
X!!!&Q4P*&4J!!!A*fCA*c!!%"IQPME$3!!!'@D@0c0!!!!D*65801!!!"VQePE8)
X!!!'k9%e36!!!!FC%6%p(!!!"dJ#!rrm!N!-Q!"[lI!#"rrm!N!-f!"[lH!#!rrm
XJ!*!%'rZ3!!#"rrmJ!!90!"[lP!%!rrmJ!!J%!"[ke!##rrm!N!0'!"[lC!#!rrm
X!N!15!"[l@!#"rrm!!!D[!"[l5!#!rrm8!!$1!"[lY!#"rrm8!!G6!"[lF!##rrm
X8!!HE!"[lG!#(rrm8!!JB!"[lT!#&rrm8!!KJ!"[kI!#'rrm8!!LS!"[lS!#%rrm
X8!!M`!"[lR!#$rrm8!!Ni!"[l(!#!rrm!!!'G!"[kN!!!J2rr!!!"&J!Eql!!J2r
Xr!!!"@J!Eqf`!!2rr!!!"K3!Er-!!J2rr!!!"HJ!Eqi3!!Irr!!!'4`!Eqc!!![r
Xr!!!'L`!Er'!!J2rr!!!#S3!Eqi`!J2rr!!!%T3!Eqe`!J2rr!!!&+3!Eqe!!J2r
Xr&!!'p3!Eqf!!J!#3"!F0!"[l2!%!rrm!!!IM!"[QP!4YC@e#,TN:
END_OF_FILE
if test 4001 -ne `wc -c <'sys/mac/mrecover.hqx'`; then
    echo shar: \"'sys/mac/mrecover.hqx'\" unpacked with wrong size!
fi
# end of 'sys/mac/mrecover.hqx'
echo shar: End of archive 17 \(of 33\).
cp /dev/null ark17isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 33 archives.
    echo "Now execute ./patchit.sh"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
