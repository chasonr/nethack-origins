Relay-Version: version B 2.10 5/3/83; site utzoo.UUCP
Posting-Version: version B 2.10.1 6/24/83 (MC830713); site ark.UUCP
Path: utzoo!watmath!clyde!cbosgd!cbdkc1!desoto!packard!edsel!bentley!hoxna!houxm!whuxlm!harpo!decvax!genrad!panda!talcott!harvard!seismo!mcvax!vu44!botter!ark!huisjes
From: huisjes@ark.UUCP (Michiel B. Huisjes)
Newsgroups: net.sources
Subject: Hack sources for PDP11/44 and PDP11/45 (part 5 of 5)
Message-ID: <423@ark.UUCP>
Date: Wed, 6-Feb-85 01:53:23 EST
Article-I.D.: ark.423
Posted: Wed Feb  6 01:53:23 1985
Date-Received: Sat, 9-Feb-85 08:29:23 EST
Reply-To: huisjes@ark.UUCP (Michiel Huisjes)
Organization: VU Informatica, Amsterdam
Lines: 2169

#!/bin/sh
#
# 
# 
# This is a shell archive. These archives are packed by the program 
# packmail(1). If you have the program unshar(1), I suggest you use it.
# If you don't remove anything before the cut line and then feed to
# sh(1)
# 
# =====CUT HERE=======CUT HERE=======CUT HERE=======CUT HERE=======CUT HERE===
#
echo 'Start of Hack, part 05 of 05:'
echo 'x - Makefile'
sed 's/^X//' > Makefile << '/'
X# hack makefile.
X# layout en verdere verbeteringen Michiel en Fred
X
XPLAYDIR = /usr/games/playdir
XSAVEDIR = /usr/games/playdir/save
X
XCFLAGS = -O -i
XLIB = -ltermlib
X
XTARGET = hack
X
XHFILES = hack.c hack.lev.c hack.pri.c hack.do.c hack.do1.c hack.main.c\
Xhack.mon.c hack.dog.c hack.invent.c hack.eat.c hack.save.c\
Xhack.do_wear.c hack.shk.c hack.io.c hack.end.c hack.rip.c\
Xhack.bones.c hack.mkobj.c hack.monst.c hack.invinit.c hack.worm.c\
Xhack.debug.c hack.move.c hack.do.misc.c hack.mon.do.c hack.str.c\
Xhack.office.c
X
XMFILES = mklev.c mklev.make.c mklev.mkobj.c mklev.svlev.c 
X
XGFILES = rnd.c alloc.c
X
XHOBJ = hack.o hack.lev.o hack.pri.o hack.do.o hack.do1.o hack.main.o\
Xhack.mon.o hack.dog.o hack.invent.o hack.eat.o hack.save.o\
Xhack.do_wear.o hack.shk.o hack.io.o hack.end.o hack.rip.o\
Xhack.bones.o hack.mkobj.o hack.monst.o hack.invinit.o hack.worm.o\
Xhack.debug.o hack.move.o hack.do.misc.o hack.mon.do.o hack.str.o\
Xhack.office.o
X
XGOBJ = rnd.o alloc.o
X
XMKOBJ = mklev.o mklev.make.o mklev.mkobj.o
X
Xall: hack mklev show
X
X$(TARGET)   : $(HOBJ) $(GOBJ)
X	@echo Loading...
X	@$(CC) $(CFLAGS) -o $(TARGET) $(GOBJ) $(HOBJ) $(LIB)
X	@size $(TARGET)
X	@echo 'Done Hack'
X
X$(HOBJ) $(MKOBJ) :	hack.h
Xhack.do.misc.o:		hack.do.vars.h envir.h
Xhack.vars.h:		hack.foods.h hack.armors.h hack.weapons.h
Xhack.lev.o:		hack.savelev.c
Xhack.dog.o hack.monst.o:        hack.dog.h
Xhack.mkobj.o mklev.mkobj.o: 	hack.vars.h
Xhack.main.o hack.lev.o hack.debug.o \
Xhack.do.misc.o hack.end.o hack.invinit.o: envir.h
X
Xhack.invinit.o:
X	cc $(CFLAGS) -c hack.invinit.c
X
Xmklev.o: hack.h envir.h
X	cc $(CFLAGS) -c mklev.c
X
Xmklev:  $(MKOBJ) $(GOBJ) mklev.svlev.c
X	cc $(CFLAGS) $(MKOBJ) $(GOBJ) -o mklev
X	@echo 'Done mklev'
X
Xshow: show.c hack.h envir.h
X	cc -O show.c -o show
X	@echo 'Done show'
X
Xcleanup:
X	rm -f $(HOBJ) $(GOBJ) $(PLAYDIR)/show $(PLAYDIR)/makelev \
X	   $(PLAYDIR)/bones_* mklev.mkobj.o mklev.o
X
Xinstall: all 
X	rm -f $(PLAYDIR)/bones_*
X	install -c -m 4711 $(TARGET) $(PLAYDIR)/$(TARGET)
X	install -c -m 711 mklev $(PLAYDIR)/mklev
X	install -c -m 700 show $(PLAYDIR)/show
X
Xnew: dirs install
X
Xdirs:
X	mkdir $(PLAYDIR)
X	mkdir $(SAVEDIR)
X	mv help $(PLAYDIR)
X	cp /dev/null $(PLAYDIR)/record
X	chmod 700 $(PLAYDIR)/record
X
Xlint:
X	lint -phbxac mk*.c rnd.c alloc.c -lc
/
echo 'x - READ_ME'
sed 's/^X//' > READ_ME << '/'
X
XWell, here they are, the sources of Hack for pdp11/44 and pdp11/45.
X
XHow to install these on your machine.
XThis is actually quite simple. Edit the file ``envir.h'' to define the
Xlocal parameters. Edit the Makefile to define the playdir directory
X(default /usr/games). Determine who will be the owner of the game, since
Xit has the setuid bits on. 
XAfter you unshared the shar-files (in a new directory),
Xyou should have the following files:
X	1) - help data Makefile show.c rnd.c alloc.c
X
X	2) - envir.h hack.armors.h hack.do.vars.h hack.dog.h hack.foods.h 
X	   - hack.h hack.name.h hack.vars.h hack.weapons.h 
X
X	3) - hack.bones.c hack.c hack.debug.c hack.do.c hack.do.misc.c 
X	   - hack.do1.c hack.do_wear.c hack.dog.c hack.eat.c hack.end.c 
X	   - hack.invent.c hack.invinit.c hack.io.c hack.lev.c hack.main.c 
X	   - hack.mkobj.c hack.mon.c hack.mon.do.c hack.monst.c hack.move.c 
X	   - hack.office.c hack.pri.c hack.rip.c hack.save.c hack.savelev.c 
X	   - hack.shk.c hack.str.c hack.worm.c
X
X	4) - mklev.c mklev.make.c mklev.mkobj.c mklev.svlev.c 
X
XNow type ``make'' and the file ``hack'', ``mklev'' and ``show'' will be created.
XNow type make new and the program will be installed in the right place.
X
XOne of the main problems of Hack is its size. If you add about 1000 bytes of
Xtext more, your text segment will be to big. Therefore we saved text wherever 
Xthis was possible. We removed the function fscanf(), and made the record file
Xbinary. To show the contents, use the program show (with flag -r).
X
XSome additions we (Fred de Wilde and Michiel Huisjes) made are
X	- The Vault
X	- The Swamp
X	- The Zoo
X	- The Graveyard
X	- Maxlevel = 40
X	- Proper Saving
X	- Several bugs
X	- And many, many more...
XA great bug that still exists is the display of the screen when you're blind.
XSome more bugs are still existing, but you'll find those out while playing.
X
XThere is not a manual included with these sources. I suggest you use the
Xmanual of the distributed version of hack (1.0.1) of CWI. 
X
XHave fun, and good hacking!
X
X				Michiel Huisjes and Fred de Wilde
X				{seismo|decvax|philabs}!mcvac!vu44!ark!huisjes
X								   ...!wilde
/
echo 'x - alloc.c'
sed 's/^X//' > alloc.c << '/'
X/*
X * Alloc.c
X *
X * Added new return values Michiel and Fred
X *
X */
X
X/*
X * The strange return value of alloc is implemented to shut lint up
X */
X
X#include "hack.h"
X
Xextern char    *malloc ();
X
Xunion PTRS ptrs;
X
Xunion PTRS *
Xalloc (num)
Xregister        num;
X{
X	register char  *val;
X
X	if (!(val = malloc (num)))
X		panic (CORE, "Cannot get %d bytes", num);
X	ptrs.Val = val;
X	return (&ptrs);
X}
/
echo 'x - envir.h'
sed 's/^X//' > envir.h << '/'
X/*
X * Envir.h
X */
X
X#define	PLAYGROUND	"/usr/games/playdir"
X#define HELP 		"/usr/games/playdir/help"
X#define HELP 		"/usr/games/playdir/data"
X#define RECORD		"/usr/games/playdir/record"
X#define LOCK		"/usr/games/playdir/hack.lock"
X#define	WIZARD		"huisjes"
X/*
X#define DEBUG
X*/
X
X#define SAVEDIR		"save/"
X#define	MORE		"/usr/ucb/more"
X#define VERSION		1
/
echo 'x - hack.armors.h'
sed 's/^X//' > hack.armors.h << '/'
X/*
X * Hack.armors.h
X */
X
Xstruct armor armors[] = {
X	{ "plate mail",	 	    5,	5, 3, 2 },
X	{ "splint mail",	   10,	5, 4, 1 },
X	{ "banded mail",	   10,	5, 4, 0 },
X	{ "chain mail",		   10,	5, 5, 1 },
X	{ "scale mail",		   10,	5, 6, 0 },
X	{ "ring mail",		   15,	5, 7, 0 },
X	{ "studded leather armor", 15,	3, 7, 1 },
X	{ "leather armor",   	   20,	3, 8, 0 },
X	{ "elven cloak",	    5,	0, 9, 3 },
X	{ "PROG ERROR",	   	  100,	0, 0, 0 }
X };
/
echo 'x - hack.bones.c'
sed 's/^X//' > hack.bones.c << '/'
X/*
X * Hack.bones.c
X *
X * Added increased chances on bones files.
X * Fixed bug with mad shopkeeper.
X *
X */
X
X#include "hack.h"
X
X#define NOBONES	0
X#define BONES	1
X
Xextern char     plname[10];
Xextern  MONSTER shopkeeper;
X
Xstruct permonst pm_ghost = {
X	"ghost", '\t', 10, 3, -5, 1, 1, sizeof (plname)
X};
X
X/* (a3)#define	GHMAX	10 */
X
Xchar    bones[] = "bones_xx";
X
X/* Save bones and possessions of a deceased adventurer */
Xsavebones () {
X	register        fd;
X	register        OBJECT otmp;
X	register        GOLD_TRAP gtmp;
X	register        MONSTER mtmp;
X
X	if (!rn2 (1 + dlevel/2))
X		return;	/* not so many ghosts on low levels */
X	sprintf (&bones[6], "%d", dlevel);
X	if ((fd = open (bones, 0)) >= 0 ) {
X		close (fd);
X		return;
X	}
X
X /* Drop everything; the corpse's possessions are usually cursed */
X	otmp = invent;
X	while (otmp) {
X		otmp -> ox = u.ux;
X		otmp -> oy = u.uy;
X		otmp -> unpaid = 0;
X		otmp -> known = 0;
X		if (rn2 (5))
X			otmp -> cursed = 1;
X		if (!otmp -> nobj) {
X			otmp -> nobj = fobj;
X			fobj = invent;
X			invent = 0;/* Superfluous */
X			break;
X		}
X		otmp = otmp -> nobj;
X	}
X	if (makemon (&pm_ghost))
X		return;
X	fmon -> mx = u.ux;
X	fmon -> my = u.uy;
X	fmon -> msleep = 1;
X/* Added: sizeof fmon->extra */
X/* This is actually nonsens. Ghosts do not have names in this version */
X	strncpy (fmon -> mextra, plname, sizeof fmon -> mextra);
X	if (shopkeeper &&
X			inshproom (shopkeeper -> mx, shopkeeper -> my))
X		shopkeeper -> angry = 0;
X	gtmp = newgen ();
X	gtmp -> ngen = fgold;
X	fgold = gtmp;
X	gtmp -> gx = u.ux;
X	gtmp -> gy = u.uy;
X	gtmp -> gflag = somegold () + d (dlevel, 30);
X	u.ux = u.uy = 100;	/* Random outside map */
X	keepdogs (1);		/* All tame animals become wild again */
X	for (mtmp = fmon; mtmp; mtmp = mtmp -> nmon)
X		levlsym (mtmp -> mx, mtmp -> my, mtmp -> data -> mlet);
X	if ((fd = creat (bones, 0644)) < 0)
X		return;
X	savelev (fd);
X	close (fd);
X}
X
Xgetbones () {
X	register        fd, x, y;
X
X	sprintf (&bones[6], "%d", dlevel);
X	if ((fd = open (bones, 0)) < 0 || rn2 (3)) {
X		close (fd);	/* Sometimes we find bones */
X		return NOBONES;
X	}
X	getlev (fd);
X	close (fd);
X	if (unlink (bones) < 0) {
X		pline ("Cannot unlink %s", bones);
X		return NOBONES;
X	}
X	for (x = 0; x < 80; x++)
X		for (y = 0; y < 22; y++) {
X			levl[x][y].seen = 0;
X			levl[x][y].new = 0;
X		}
X	return BONES;
X}
/
echo 'x - hack.do.vars.h'
sed 's/^X//' > hack.do.vars.h << '/'
X/*
X * Hack.do.vars.h
X */
X
Xint 	doredraw(),  dodrop(),    dodrink(),    doread(),
X	dosearch(),  armwear(),   dowearring(), doremarm(),
X	doremring(), dopay(),     save(),       dowield(),
X	ddoinv(),    dozap(),     m_call(),     doset(),
X	dowhatis(),  dohelp(),    doeat(),      ddoup(),
X	ddodown(),   done1(),     donull(),     dothrow(),
X	doshow(),    dosh(),	  doreprint(),  gemsdrop();
X
X#ifdef DEBUG
Xint debug();
X#endif DEBUG
X
XFUNCTIONS list[] = {
X	'\020', doredraw, 	 /* was  '\014' */
X	'A', doreprint,	 /* Michiel: Repeat last message printed */
X#ifdef DEBUG
X	'D', debug,
X#endif DEBUG
X	'P', dowearring,
X	'Q', done1,
X	'R', doremring,
X	'G', gemsdrop,
X	'S', save,
X	'T', doremarm,
X	'W', armwear,
X	'a', doshow,	/* Michiel: show everything you're wearing */
X	'c', m_call,
X	'd', dodrop,
X	'e', doeat,
X	'i', ddoinv,
X	'o', doset,
X	'p', dopay,
X	'q', dodrink,
X	'r', doread,
X	's', dosearch,
X	't', dothrow,
X	'w', dowield,
X	'z', dozap,
X	'<', ddoup,
X	'>', ddodown,
X	'/', dowhatis,
X	'?', dohelp,
X	'!', dosh,
X	'\n', donull,
X	' ', donull,
X	0, 0
X};
/
echo 'x - hack.do_wear.c'
sed 's/^X//' > hack.do_wear.c << '/'
X/*
X * Hack.do_wear.c
X */
X
X#include "hack.h"
X
X#define CURSED		1
X#define NOTCURSED	0
X
Xoff_msg (otmp)
Xregister        OBJECT otmp;
X{
X	doname (otmp, buf);
X	pline ("You were wearing %s.", buf);
X}
X
Xdoremarm () {
X	register        OBJECT oldarm = uarm;
X
X	nomove ();
X	if (!uarm) {
X		pline ("Not wearing any armor.");
X		return;
X	}
X	flags.move = 1;
X	if (cursed (uarm))
X		return;
X	nomul (-armors[uarm -> otyp].delay);
X	u.uac += uarm -> spe;
X	uarm = uarm2;
X	uarm2 = 0;
X	off_msg (oldarm);
X	flags.dac = 1;
X}
X
Xdoremring () {
X
X	nomove ();
X	if (!uleft && !uright) {
X		pline ("Not wearing any ring.");
X		return;
X	}
X	if (!uleft)
X		dorr (&uright);
X	else if (!uright)
X		dorr (&uleft);
X	else
X		for (;;) {
X			pline ("What ring, Right or Left? ");
X			flush ();
X			*buf = getchar ();
X			flags.topl = 0;
X			if (*buf == '\n' || *buf == '\033')
X				return;
X			if (*buf == 'l' || *buf == 'L') {
X				dorr (&uleft);
X				return;
X			}
X			if (*buf == 'r' || *buf == 'R') {
X				dorr (&uright);
X				return;
X			}
X			if (*buf == '?')
X				doinv ("=", 0);
X		}
X}
X
Xdorr (ring)
Xregister        OBJECT * ring;
X{
X	register        OBJECT otmp = *ring;
X
X	if (cursed (otmp))
X		return;
X	*ring = 0;
X	doring (otmp, OFF);
X	off_msg (otmp);
X}
X
Xcursed (otmp)
Xregister        OBJECT otmp;
X{
X	if (otmp -> cursed) {
X		pline ("You can't. It appears to be cursed.");
X		return (CURSED);
X	}
X	return (NOTCURSED);
X}
X
Xarmwear () {
X	register        OBJECT otmp;
X
X	otmp = getobj ("[", "wear");
X	if (!otmp) {
X		nomove ();
X		return;
X	}
X	if (uarm) {
X		if (otmp -> otyp == A_ELVEN_CLOAK && !uarm2)
X			uarm2 = uarm;
X		else {
X			pline ("You are already wearing some armor.");
X			flags.move = 0;
X			return;
X		}
X	}
X	uarm = otmp;
X	nomul (-armors[otmp -> otyp].delay);
X	uarm -> known = 1;
X	u.uac -= uarm -> spe;
X	flags.dac = 1;
X}
X
Xdowearring () {
X	register        OBJECT otmp;
X
X	otmp = getobj ("=", "wear");
X	if (!otmp) {
XR: 
X		nomove ();
X		return;
X	}
X	if (uleft && uright) {
X		pline ("There are no more fingers to fill.");
X		goto R;
X	}
X	if (otmp == uleft || otmp == uright) {
X		pline ("You are already wearing that.");
X		goto R;
X	}
X	if (uleft)
X		uright = otmp;
X	else if (uright)
X		uleft = otmp;
X	else
X		while (!uright && !uleft) {
X			pline ("What finger, Right or Left? ");
X			flush ();
X			*buf = getchar ();
X			flags.topl = 0;
X			if (*buf == 'l' || *buf == 'L')
X				uleft = otmp;
X			else if (*buf == 'r' || *buf == 'R')
X				uright = otmp;
X		}
X	doring (otmp, ON);
X	prinv (otmp);
X}
X
Xdoring (obj, eff)
Xregister        OBJECT obj;
Xregister        eff;
X{
X	register        tmp;
X
X	if (!obj)
X		return;
X	tmp = obj -> spe;
X	if (eff == OFF)
X		tmp = -tmp;
X	if (uleft && uright && uleft == uright &&
X			obj -> otyp <= R_GAIN_STR)
X		return;
X /* If wearing the same ring sometimes the flag must remain actif. */
X	switch (obj -> otyp) {
X		case R_TELE: 
X			u.utel = eff;
X		case R_ADORNMENT: 
X			break;
X		case R_REGEN: 
X			u.uregen = eff;
X			break;
X		case R_SEARCH: 
X			u.usearch = eff;
X			break;
X		case R_SEE_INV: 
X			u.ucinvis = eff;
X			break;
X		case R_STEALTH: 
X			u.ustelth = eff;
X			break;
X		case R_FLOAT: 
X			u.ufloat = eff;
X			break;
X		case R_POISON_RES: 
X			u.upres = eff;
X			break;
X		case R_AGGRAV_MON: 
X			u.uagmon = eff;
X			break;
X		case R_HUNGER: 
X			u.ufeed = eff;
X			break;
X		case R_FIRE_RES: 
X			u.ufireres = eff;
X			break;
X		case R_COLD_RES: 
X			u.ucoldres = eff;
X			break;
X		case R_SHAPE: 
X			u.ucham = eff;
X			if (eff != OFF)
X				rescham ();
X			break;
X		case R_GAIN_STR: 
X			u.ustr += tmp;
X			u.ustrmax += tmp;
X			flags.dstr = 1;
X			break;
X		case R_DAM_INC: 
X			u.udaminc += tmp;
X			break;
X		case R_PROTECTION: 
X			u.uac -= tmp;
X			flags.dac = 1;
X			break;
X		default: 
X			pline ("Bad(%d)ring", obj -> otyp);
X			impossible ();
X	}
X}
/
echo 'x - hack.dog.h'
sed 's/^X//' > hack.dog.h << '/'
X/*
X * Hack.dog.h
X */
X
Xstruct edog {
X	unsigned        hungrytime;	/* At this time dog gets hungry */
X	unsigned        eattime;	/* Dog is eating */
X	unsigned        droptime;	/* Moment dog dropped object */
X	unsigned        dropdist;	/* Dist of drpped obj from @ */
X	unsigned        apport;		/* Amount of training */
X	unsigned        carry:	1;	/* The dog is carrying sth */
X};
/
echo 'x - hack.eat.c'
sed 's/^X//' > hack.eat.c << '/'
X/*
X * hack.eat.c
X */
X
X#include "hack.h"
X
Xextern char    *nomvmsg;
X
Xunsigned        starved = 0;	/* Michiel: after 30 times fainting you starve
X				   to death */
X
Xchar   *hu_stat[4] = {
X	"        ",
X	"Hungry  ",		/* Hunger texts used in main (each 8 chars
X				   long) */
X	"Weak    ",
X	"Fainting"
X};
X
Xdoeat () {
X	register        OBJECT otmp;
X	register        FOOD ftmp;
X
X	if (!(otmp = getobj ("%", "eat"))) {
X		nomove ();
X		return;
X	}
X	starved = 0;
X	ftmp = &foods[otmp -> otyp];
X	if (!rn2 (7)) {
X		pline ("Blecch!  Rotten food!");
X		if (!rn2 (4)) {
X			pline ("You feel rather light headed.");
X			u.uconfused += d (2, 4);
X		}
X		else if (!rn2 (4) && !u.ublind) {
X			pline ("Everything suddenly goes dark.");
X			u.ublind = d (2, 10);
X			unCoff (COFF, 0);
X		}
X		else if (!rn2 (3)) {
X			pline ("The world spins and goes dark.");
X			nomul (-rnd (10));
X			nomvmsg = "You are conscious again";
X		}
X		lesshungry (ftmp -> nutrition >> 2);
X	}
X	else {
X		multi = -ftmp -> delay;
X		switch (otmp -> otyp) {
X
X			case F_FOOD: 
X				if (u.uhunger < 500)
X					pline ("That food really hit the spot!");
X				else if (u.uhunger < 1000)
X					pline ("That satiated your stomach!");
X				else if (u.uhunger < 1500) {
X					pline ("You're having a hard time getting all that food down.");
X					multi -= 2;
X				}
X				else {
X					pline ("You choke over your food.");
X					more ();
X					killer = ftmp -> foodnam;
X					done (CHOKED);
X				}
X				lesshungry (ftmp -> nutrition);
X				if (multi < 0)
X					nomvmsg = "You finished your meal.";
X				break;
X
X			case F_TRIPE: 
X				pline ("Yak - dog food!");
X				if (rn2 (2)) {
X					pline ("You vomit.");
X					lesshungry (-20);
X				}
X				else
X					lesshungry (ftmp -> nutrition);
X				break;
X
X			default: 
X				pline ("That %s was delicious!", ftmp -> foodnam);
X				lesshungry (ftmp -> nutrition);
X				break;
X		}
X	}
X	if (multi < 0 && !nomvmsg) {
X		static char     msgbuf[40];
X
X		sprintf (msgbuf, "You finished eating your %s.",
X				ftmp -> foodnam);
X		nomvmsg = msgbuf;
X	}
X	useup (otmp);
X}
X
Xlesshungry (num)		/* Eat stg or drink fruit juice */
Xregister        num;
X{
X	register        newhunger;
X
X	newhunger = u.uhunger + num;
X	if (u.uhunger < 151 && newhunger > 150) {
X		if (u.uhunger < 51 && u.ustr < u.ustrmax)
X			losestr (-1);
X		u.uhs = 0;
X		goto Ldohs;
X	}
X	if (u.uhunger < 51 && newhunger > 50) {
X		pline ("You only feel hungry now.");
X		if (u.ustr < u.ustrmax)
X			losestr (-1);
X		u.uhs = 1;
X		goto Ldohs;
X	}
X	if (u.uhunger <= 0 && newhunger < 50) {
X		pline ("You feel weak now.");
X		u.uhs = 2;
XLdohs: 
X		flags.dhs = 1;
X	}
X	u.uhunger = newhunger;
X}
X
Xgethungry () {			/* Called in main */
X	--u.uhunger;
X	if ((u.uregen || u.ufeed) && moves % 2)
X		u.uhunger--;
X	if (u.uhunger <= 150 && !u.uhs) {
X		pline ("You are beginning to feel hungry.");
X		u.uhs = 1;
X		goto Ldohs;
X	}
X	if (u.uhunger <= 50 && u.uhs == 1) {
X		pline ("You are beginning to feel weak.");
X		losestr (1);
X		u.uhs = 2;
X		goto Ldohs;
X	}
X	if (u.uhunger <= 0) {
X		pline ("You faint from lack of food.");
X		if (starved++ == 100) {
X			pline ("You starve!");
X			more ();
X			done (STARVED);
X		}
X		nomul (-20);
X		u.uhunger = rn1 (4, 22);
X		if (u.uhs != 3) {
X			u.uhs = 3;
X	Ldohs: 
X			flags.dhs = 1;
X		}
X	}
X}
/
echo 'x - hack.foods.h'
sed 's/^X//' > hack.foods.h << '/'
X/*
X * Hack.foods.h
X */
X
X/* Dog eats foods 0-4 but prefers 1 above 0, 2, 3, 4 */
X
Xstruct food foods[] = {
X	{ "food ration",  50, 5, 800 },
X	{ "tripe ration", 20, 1, 200 },
X	{ "pancake",  	   3, 1, 200 },
X	{ "dead lizard",   3, 0,  40 },
X	{ "cookie",	   7, 0,  40 },
X	{ "orange",	   3, 0,  80 },
X	{ "apple",	   3, 0,  50 },
X	{ "pear",	   3, 0,  50 },
X	{ "melon",	   1, 0, 100 },
X	{ "banana",	   3, 0,  80 },
X	{ "candy bar",	   3, 0, 100 },
X	{ "egg",	   1, 0,  80 },
X	{ "PROG ERROR",  100, 0,   0 }
X};
/
echo 'x - hack.io.c'
sed 's/^X//' > hack.io.c << '/'
X/*
X * Hack.io.c
X */
X
X#include "hack.h"
X#include <sgtty.h>
X
Xshort   ospeed;			/* Used by tputs */
X
Xgetlin (str)
Xregister char  *str;
X{
X	register char  *ostr = str;
X
X	flags.topl = 0;
X	flush ();
X	for (;;) {
X		*str = getchar ();
X		if (*str == '\b') {
X			if (str != ostr) {
X				str--;
X				write (1, "\b \b", 3);
X			}
X			else
X				write (1, "\7", 1);
X		}
X		else if (*str == '\n') {
X			*str = 0;
X			return;
X		}
X		else if (*str >= ' ') {
X			write (1, str, 1);
X			str++;
X		}
X	}
X}
X
Xgetret () {
X	printf ("\nHit space to continue: ");
X	flush ();
X	while (getchar () != ' ');
X}
X/*
X * Put together cbreak-mode and echo --- Michiel
X */
X
Xhackmode (x)
Xregister        x;
X{
X	struct sgttyb   ttyp;
X
X	ioctl (1, TIOCGETP, &ttyp);/* Use of basic functions */
X	ospeed = ttyp.sg_ospeed;
X	if (x) {
X		ttyp.sg_flags &= ~ECHO;
X		ttyp.sg_flags |= CBREAK;
X	}
X	else {
X		ttyp.sg_flags |= ECHO;
X		ttyp.sg_flags &= ~CBREAK;
X	}
X	if (ioctl (1, TIOCSETP, &ttyp) < 0) {
X		printf ("ERROR: Cannot change tty");
X		exit (1);
X	}
X}
X
Xmore () {
X	printf (" --More--");
X	flush ();
X	while (getchar () != ' ');
X	flags.topl = 0;
X}
X
X#ifndef NORMAL_IO
Xgetchar () {
X	char    c;
X
X	read (0, &c, 1);
X	return (c);
X}
X#endif NORMAL_IO
/
echo 'x - hack.monst.c'
sed 's/^X//' > hack.monst.c << '/'
X/*
X * Hack.monst.c
X */
X
X#include "hack.h"
X#include "hack.dog.h"
X
X/*
X * Unfortunately the syntax for structure initialization is
X * different on VAX and 11/45. Define VAX to get the VAX syntax
X */
X
X#define VAX
X
X#ifdef VAX
X
X#define	SOSEP	{
X#define	SCSEP	}
X#define GOSEP
X#define	GMSEP
X#define	GCSEP
X
X#else
X
X#define	SOSEP
X#define	SCSEP
X#define	GOSEP	{
X#define	GMSEP	},{
X#define	GCSEP	}
X
X#endif VAX
X
Xstruct permonst mon[8][7]={
X	GOSEP
X	SOSEP "bat",		'B',1,22,8,1,4,0 SCSEP,
X	SOSEP "gnome",		'G',1,6,5,1,6,0 SCSEP,
X	SOSEP "hobgoblin",	'H',1,9,5,1,8,0 SCSEP,
X	SOSEP "jackal",		'J',0,12,7,1,2,0 SCSEP,
X	SOSEP "kobold",		'K',1,6,7,1,4,0 SCSEP,
X	SOSEP "leprechaun",	'L',1,15,8,1,5,0 SCSEP,
X	SOSEP "giant rat",	'r',0,12,7,1,3,0 SCSEP,
X	GMSEP
X	SOSEP "acid blob",	'a',2,3,8,0,0,0 SCSEP,
X	SOSEP "floating eye",	'E',2,1,9,0,0,0 SCSEP,
X	SOSEP "homunculus",	'h',2,6,6,1,3,0 SCSEP,
X	SOSEP "imp",		'i',2,6,2,1,4,0 SCSEP,
X	SOSEP "orc",		'O',2,9,6,1,8,0 SCSEP,
X	SOSEP "yellow light",	'y',3,15,0,0,0,0 SCSEP,
X	SOSEP "zombie",		'Z',2,6,8,1,8,0 SCSEP,
X	GMSEP
X	SOSEP "giant ant",	'A',3,18,3,1,6,0 SCSEP,
X	SOSEP "fog cloud",	'f',3,1,0,1,6,0 SCSEP,
X	SOSEP "nymph",		'N',3,12,9,1,4,0 SCSEP,
X	SOSEP "piercer",	'p',3,1,3,2,6,0 SCSEP,
X	SOSEP "quasit",		'Q',3,15,3,1,4,0 SCSEP,
X	SOSEP "quivering blob",	'q',3,1,8,1,8,0 SCSEP,
X	SOSEP "violet fungi",	'v',3,1,7,1,4,0 SCSEP,
X	GMSEP
X	SOSEP "giant beetle",	'b',4,6,4,3,4,0 SCSEP,
X	SOSEP "centaur",	'C',4,18,4,1,6,0 SCSEP,
X	SOSEP "cockatrice",	'c',4,6,6,1,3,0 SCSEP,
X	SOSEP "gelatinous cube",'g',4,6,8,2,4,0 SCSEP,
X	SOSEP "jaguar",		'j',4,15,6,1,8,0 SCSEP,
X	SOSEP "killer bee",	'k',4,6,4,2,4,0 SCSEP,
X	SOSEP "snake",		'S',4,15,3,1,6,0 SCSEP,
X	GMSEP
X	SOSEP "freezing sphere",'F',2,13,4,0,0,0 SCSEP,
X	SOSEP "owlbear",	'o',5,12,5,2,6,0 SCSEP,
X	SOSEP "rust monster",	'R',5,18,3,0,0,0 SCSEP,
X	SOSEP "giant scorpion",	's',5,15,3,1,4,0 SCSEP,
X	SOSEP "teleporter",	't',5,3,5,1,7,0 SCSEP,
X	SOSEP "wraith",		'W',5,12,5,1,6,0 SCSEP,
X	SOSEP "long worm",	'w',6,3,5,2,5,0 SCSEP,
X	GMSEP
X	SOSEP "large dog",	'd',6,15,4,2,4,0 SCSEP,
X	SOSEP "leocrotta",	'l',6,18,4,3,6,0 SCSEP,
X	SOSEP "mimic",		'M',7,3,7,3,4,0 SCSEP,
X	SOSEP "minotaur",	'm',6,12,6,2,8,0 SCSEP,
X	SOSEP "troll",		'T',7,12,4,2,6,0 SCSEP,
X	SOSEP "ugod",		'u',6,11,5,1,10,0 SCSEP,
X	SOSEP "yeti",		'Y',5,15,6,1,6,0 SCSEP,
X	GMSEP
X	SOSEP "invisible stalker",'I',8,12,3,4,4,0 SCSEP,
X	SOSEP "umber hulk",	'U',9,6,2,2,14,0 SCSEP,
X	SOSEP "vampire",	'V',8,12,1,1,6,0 SCSEP,
X	SOSEP "xorn",		'X',8,9,-2,4,6,0 SCSEP,
X	SOSEP "xerp",		'x',7,6,3,2,4,0 SCSEP,
X	SOSEP "zelomp",		'z',9,8,3,3,6,0 SCSEP,
X	SOSEP "chameleon",	':',6,5,6,4,2,0 SCSEP,
X	GMSEP
X	SOSEP "dragon",		'D',20,9,-1,3,8,0 SCSEP,
X	SOSEP "ettin",		'e',10,12,3,2,8,0 SCSEP,
X	SOSEP "lurker above",	'\'',10,3,3,0,0,0 SCSEP,
X	SOSEP "neo-otyugh",	'n',11,6,0,1,3,0 SCSEP,
X	SOSEP "trapper",	',',12,3,3,0,0,0 SCSEP,
X	SOSEP "purple worm",	'P',20,9,-1,2,8,0 SCSEP,
X	SOSEP "demon",		'&',14,9,-4,1,6,0 SCSEP
X	GCSEP
X};
Xstruct permonst /* _mon={0,0,0,0,0,0,0,0},*/
X	li_dog={"little dog",	'd',2,18,6,1,6,sizeof(struct edog)},
X		dog={"dog",	'd',4,16,5,1,6,sizeof(struct edog)},
X	la_dog={"large dog",	'd',6,15,4,2,4,sizeof(struct edog)};
/
echo 'x - hack.name.h'
sed 's/^X//' > hack.name.h << '/'
X/*
X * Hack.name.h
X */
X
X#define S_ENCH_ARMOR	0
X#define S_DROP		1
X#define S_CURSE_LEV	2
X#define S_REM_CURSE	3
X#define S_ENCH_WEP	4
X#define S_CREAT_MON	5
X#define S_DAM_WEP	6
X#define S_GENOCIDE	7
X#define S_DESTR_ARMOR	8
X#define S_LIGHT		9
X#define S_TELEPORT	10
X#define S_GOLD_DETEC	11
X#define S_IDENTIFY	12
X#define S_MAG_MAP	13
X#define S_FIRE		14
X
X#define P_REST_STR	0
X#define P_BOOZE		1
X#define P_INVIS		2
X#define P_JUICE		3
X#define P_HEALING	4
X#define P_FROZEN	5
X#define P_MONDETEC	6
X#define P_OBJDETEC	7
X#define P_POISON	8
X#define P_CONF		9
X#define P_GAIN_STR	10
X#define P_SPEED		11
X#define P_BLIND		12
X#define P_GAIN_LEV	13
X#define P_EXTRA_HEALING	14
X
X#define Z_LIGHT		0
X#define Z_DETEC		1
X#define Z_CREATE_MON	2
X#define Z_EXHAUST	3
X#define Z_SLOW_MON	4
X#define Z_SPEED_MON	5
X#define Z_UND_TUR	6
X#define Z_POLYMORF	7
X#define Z_CAN		8
X#define Z_TELEPORT	9
X#define Z_DIGGING	10
X#define Z_MAG_MISSILE	11
X#define Z_FIRE		12
X#define Z_SLEEP		13
X#define Z_COLD		14
X#define Z_DEATH		15
X#define Z_CONF_MON	16
X#define Z_CLOSING	17
X
X#define R_ADORNMENT	0
X#define R_TELE		1
X#define R_REGEN		2
X#define R_SEARCH	3
X#define R_SEE_INV	4
X#define R_STEALTH	5
X#define R_FLOAT		6
X#define R_POISON_RES	7
X#define R_AGGRAV_MON	8
X#define R_HUNGER	9
X#define R_FIRE_RES	10
X#define R_COLD_RES	11
X#define R_SHAPE		12
X#define R_GAIN_STR	13
X#define R_DAM_INC	14
X#define R_PROTECTION	15
X
X#define W_ARROW		0
X#define W_SL_BULLET	1
X#define W_CROSS_BOLT	2
X#define W_DART		3
X#define W_MACE		4
X#define W_AXE		5
X#define W_FLAIL		6
X#define W_LONG_SWORD	7
X#define W_TWOH_SWORD	8
X#define W_DAGGER	9
X#define W_SPEAR		10
X#define W_BOW		11
X#define W_SLING		12
X#define W_CROSSBOW	13
X
X#define W_USE_AMMO	11
X#define W_AMMUNITION	3
X
X#define A_PLATE		0
X#define A_SPLINT	1
X#define A_BANDED	2
X#define A_CHAIN		3
X#define A_SCALE		4
X#define A_RING		5
X#define A_STD_LEATHER	6
X#define A_LEATHER	7
X#define A_ELVEN_CLOAK	8
X
X#define F_FOOD		0
X#define F_TRIPE		1
X#define F_PANCAKE	2
X#define F_LIZARD	3
X#define F_COOKIE	4
X#define F_ORANGE	5
X#define F_APPLE		6
X#define F_PEAR		7
X#define F_MELON		8
X#define F_BANANA	9
X#define F_CANDY		10
X#define F_EGG		11
/
echo 'x - hack.office.c'
sed 's/^X//' > hack.office.c << '/'
X/*
X * Hack.office.c
X */
X
Xstruct tm {			/* see ctime(3) */
X	int     tm_sec;
X	int     tm_min;
X	int     tm_hour;
X	int     tm_mday;
X	int     tm_mon;
X	int     tm_year;
X	int     tm_wday;
X	int     tm_yday;
X	int     tm_isdst;
X};
X
X
X#define SUNDAY 0
X#define SATURDAY 6
X
Xextern struct tm       *localtime ();
X
Xkantoor () {
X	struct tm      *s;
X	long    clock;
X
X	time (&clock);
X	s = localtime (&clock);
X	return (s -> tm_wday != SUNDAY && s -> tm_wday != SATURDAY &&
X			s -> tm_hour <= 17 && s -> tm_hour > 9);
X}
/
echo 'x - hack.rip.c'
sed 's/^X//' > hack.rip.c << '/'
X/*
X * Hack.rip.c
X */
X
X#include <time.h>
X#include "hack.h"
X
Xextern char     plname[];
X
Xstatic char    *rip[] = {
X	"                       ----------",
X	"                      /          \\",
X	"                     /    REST    \\",
X	"                    /      IN      \\",
X	"                   /     PEACE      \\",
X	"                  /                  \\",
X	"                  |                  |",
X	"                  |                  |",
X	"                  |   killed by a    |",
X	"                  |                  |",
X	"                  |       1001       |",
X	"                 *|     *  *  *      | *",
X	"        _________)/\\\\_//(\\/(/\\)/\\//\\/|_)_______",
X	0
X};
X
Xoutrip () {
X	register char **dp = rip;
X	register struct tm     *lt;
X	long    date;
X	char    buffer[BUFSZ];
X	struct tm      *localtime ();
X
X	time (&date);
X	lt = localtime (&date);
X	cls ();
X	strcpy (buffer, plname);
X	center (6, buffer);
X	sprintf (buffer, "%D Au", u.ugold);
X	center (7, buffer);
X	strcpy (buffer, killer);
X	center (9, buffer);
X	sprintf (buffer, "19%2d", lt -> tm_year);
X	center (10, buffer);
X	curs (1, 8);
X	while (*dp)
X		printf ("%s\n", *dp++);
X	getret ();
X}
X
Xcenter (line, text)
Xregister int    line;
Xregister char  *text;
X{
X	register char  *ip, *op;
X
X	ip = text;
X	op = &rip[line][28 - ((strlen (text) + 1) >> 1)];
X	while (*ip)
X		*op++ = *ip++;
X}
/
echo 'x - hack.savelev.c'
sed 's/^X//' > hack.savelev.c << '/'
X/*
X * Hack.savelev.c
X */
X
Xsavelev (fd) {
X	register        MONSTER mtmp, mtmp2;
X	register        GOLD_TRAP gtmp, gtmp2;
X	register        OBJECT otmp, otmp2;
X	register        WORMSEGMENT wtmp, wtmp2;
X	register        tmp;
X	int     minusone = -1;
X
X	if (fd < 0)
X		panic (CORE, "Save on bad file!");
X	bwrite (fd, levl, sizeof (levl));
X	bwrite (fd, &moves, sizeof (unsigned));
X	bwrite (fd, &xupstair, 1);
X	bwrite (fd, &yupstair, 1);
X	bwrite (fd, &xdnstair, 1);
X	bwrite (fd, &ydnstair, 1);
X	for (mtmp = fmon; mtmp; mtmp = mtmp2) {
X		mtmp2 = mtmp -> nmon;
X		bwrite (fd, &mtmp -> mxlth, sizeof (int));
X		bwrite (fd, mtmp, mtmp -> mxlth + sizeof (struct monst));
X
X/* Michiel save stolen objects */
X		if (mtmp -> mstole) {
X			bwrite (fd, mtmp -> mstole, sizeof (struct stole));
X			for (otmp = mtmp -> mstole -> sobj; otmp;
X					otmp = otmp -> nobj)
X				bwrite (fd, otmp, sizeof (struct obj));
X			bwrite (fd, nul, sizeof (struct obj));
X			free (mtmp -> mstole);
X		}
X		else
X			bwrite (fd, nul, sizeof (struct stole));
X		free (mtmp);
X	}
X	bwrite (fd, &minusone, sizeof (int));
X	for (gtmp = fgold; gtmp; gtmp = gtmp2) {
X		gtmp2 = gtmp -> ngen;
X		bwrite (fd, gtmp, sizeof (struct gen));
X		free (gtmp);
X	}
X	bwrite (fd, nul, sizeof (struct gen));
X	for (gtmp = ftrap; gtmp; gtmp = gtmp2) {
X		gtmp2 = gtmp -> ngen;
X		bwrite (fd, gtmp, sizeof (struct gen));
X		free (gtmp);
X	}
X	bwrite (fd, nul, sizeof (struct gen));
X	for (otmp = fobj; otmp; otmp = otmp2) {
X		otmp2 = otmp -> nobj;
X		bwrite (fd, otmp, sizeof (struct obj));
X		ofree (otmp);
X	}
X	bwrite (fd, nul, sizeof (struct obj));
X	bwrite (fd, rooms, sizeof (rooms));
X	bwrite (fd, doors, sizeof (doors));
X	fgold = 0;
X	ftrap = 0;
X	fmon = 0;
X	fobj = 0;
X	bwrite (fd, wsegs, sizeof (wsegs));
X	for (tmp = 1; tmp < 32; tmp++) {
X		for (wtmp = wsegs[tmp]; wtmp; wtmp = wtmp2) {
X			wtmp2 = wtmp -> nseg;
X			bwrite (fd, wtmp, sizeof (struct wseg));
X		}
X		wsegs[tmp] = 0;
X	}
X	bwrite (fd, wgrowtime, sizeof (wgrowtime));
X	shopkeeper = 0;
X}
X
Xbwrite (fd, loc, num)
Xregister        fd, num;
Xregister char  *loc;
X{
X	if (write (fd, loc, num) != num)
X		panic (CORE, "Cannot write %d bytes to file #%d", num,
X				fd);
X}
/
echo 'x - hack.str.c'
sed 's/^X//' > hack.str.c << '/'
X/*
X * Hack.str.c
X */
X
X/*
X * strprint() : Cheap alternative for sprintf() and printf(), by
X * Fred and Michiel. If you want the normal io just define NORMAL_IO
X */
X
X
X#include "hack.h"
X
X#ifndef NORMAL_IO
X
X#define ARINDEX		512
Xstatic char output_buffer[ARINDEX];
Xstatic arcount = 0;
X
Xchar *litoa();
X
X/*VARARGS10*/
Xstrprint( dest, src, argptr )
Xregister char *dest, *src;
Xregister int *argptr;
X{
X	register kar;
X	register char *string;
X	register field;
X	int negated;
X	int printflag = 0;
X	static char extra[512];
X
X	if ( dest == STDOUT ) {
X		dest = extra;
X		printflag++;
X	}
X
X	while( *src ) {
X		if ( *src == '%' ) {
X			field = 0;
X			negated = 0;
X			if ( *++src == '-' )
X				++negated;
X			else
X				--src;
X			while( *++src & 060 && *src <= '9' )
X				field = 10*field + ( *src & 017 );
X			if ( (kar = *src) == '%' )
X				*dest++ = '%';
X			else if ( kar == 'c' )
X				*dest++ = (char)*argptr++;
X			else {
X				switch ( kar ) {
X					
X				case 'd' :
X					string = litoa( (long)(*argptr));
X					break;
X				case 'U' :
X				case 'D' :
X					string = litoa( *((long *)argptr++) );
X					break;
X				case 'u' :
X					string =
X					litoa( (long)( *((unsigned *)argptr)) );
X					break;
X				case 's' :
X					string = (char *)(*argptr);
X					break;
X				default :
X					strcpy( string, "%'" );
X				}
X				if ( field )
X					field -= strlen( string );
X				if ( field > 0 && !negated )
X					while( --field >= 0 )
X						*dest++ = ' ';
X				while( *dest++ = *string++ )
X					;
X				dest--;  /* Remove '\0' character */
X				if ( field > 0 && negated )
X					while( --field >= 0 )
X						*dest++ = ' ';
X				argptr++;
X			}
X			src++;
X		}	
X		else
X			*dest++ = *src++;
X	}
X	*dest = 0;
X	if ( printflag ) {
X		WRITE( extra, strlen(extra) );
X	}
X}
X
Xchar *
Xlitoa( l_arg )
Xlong l_arg;
X{
X	static char string[20];
X	register int i = 0;
X	register char *str2 = string;
X	char pipo[20];
X
X	if ( !l_arg )
X		return( "0" );
X	if ( l_arg < 0L ) {
X		*str2++ = '-';
X		l_arg = -l_arg;
X	}
X
X	while( l_arg ) {
X		pipo[i++] = (int)( l_arg % 10L + '0');
X		l_arg /= 10L;
X	}
X	while( --i >= 0 ) /* Michiel */
X		*str2++ = pipo[i];
X	*str2 = '\0';
X	return( string );
X}
X
XWRITE( string , length )
Xregister char *string;
Xregister length;
X{
X	if ( arcount + length >= ARINDEX )
X		flush();
X	strcat( output_buffer, string );
X	arcount += length;
X}
X
Xflush()
X{
X	write( 1, output_buffer, arcount );
X	arcount = 0;
X	output_buffer[0] = 0;
X}
X
Xputchar ( c )
X{
X	WRITE( &c, 1 );
X}
X
Xprintf( fmt, args )
X{
X	strprint( STDOUT, fmt, &args );
X}
X
Xsprintf( buffer, fmt, args )
X{
X	strprint( buffer, fmt, &args );
X}
X#endif NORMAL_IO
/
echo 'x - hack.vars.h'
sed 's/^X//' > hack.vars.h << '/'
X/*
X * Hack.vars.h
X */
X
X#define	SIZE(x)	(sizeof x)/(sizeof x[0])
X
Xchar    NOTHIN[]   = "Nothing Happens",
X        WCLEV[]    = "Welcome to level %d.",
X        STOPGLOW[] = "Your hands stop glowing blue.",
X        UMISS[]    = "You miss %s.";
X
X
Xchar   *traps[] = {
X	" bear trap",
X	"n arrow trap",
X	" dart trap",
X	" trapdoor",
X	" teleportation trap",
X	" pit",
X	" sleeping gas trap",
X	" piercer",
X	" mimic"
X};
X
X#include "hack.foods.h"
X#include "hack.armors.h"
X#include "hack.weapons.h"
X
Xchar   *pottyp[] = {
X	"restore strength",
X	"booze",
X	"invisibility",
X	"fruit juice",
X	"healing",
X	"paralysis",
X	"monster detection",
X	"object detection",
X	"sickness",
X	"confusion",
X	"gain strength",
X	"speed",
X	"blindness",
X	"gain level",
X	"extra healing"
X};
X
X
X
Xchar   *potcol[] = {
X	"ebony",
X	"magenta",
X	"clear",
X	"brilliant blue",
X	"sky blue",
X	"emerald",
X	"dark green",
X	"ruby",
X	"purple-red",
X	"swirly",
X	"white",
X	"yellow",
X	"purple",
X	"puce",
X	"pink",
X	"smokey",
X	"glowing",
X	"bubbly",
X	"orange"
X};
X
Xchar   *potcall[SIZE (pottyp)];
X
X /* SCROLLS */
X
Xchar   *scrtyp[] = {
X	"enchant armor",
X	"losing",
X	"curse levels",
X	"remove curse",
X	"enchant weapon",
X	"create monster",
X	"damage weapon",
X	"genocide",
X	"destroy armor",
X	"light",
X	"transportation",
X	"gold detection",
X	"identify",
X	"magic mapping",
X	"fire"
X};
X
X
Xchar   *scrnam[] = {
X	"VELOX NEB",
X	"FOOBIE BLETCH",
X	"TEMOV",
X	"GARVEN DEH",
X	"ZELGO MER",
X	"ANDOVA BEGARIN",
X	"ELAM EBOW",
X	"KERNOD WEL",
X	"THARR",
X	"VENZAR BORGAVVE",
X /* "ELBIB YLOH", */
X	"VERR YED HORRE",
X	"JUYED AWK YACC",
X	"HACKEM MUCHE",
X	"LEP GEX VEN ZEA",
X	"DAIYEN FOOELS"
X};
Xchar   *scrcall[SIZE (scrtyp)];
X
X
X /* WANDS */
X
Xchar   *wantyp[] = {
X	"light",
X	"secret door + trap detection",
X	"create monster",
X	"exhaustion",
X	"slow monster",
X	"speed monster",
X	"undead turning",
X	"polymorph",
X	"cancellation",
X	"teleport monster",
X	"digging",
X	"magic missile",
X	"fire",
X	"sleep",
X	"cold",
X	"death",
X	"confusion",
X	"door closing"
X};
X
X
Xchar   *wannam[] = {
X	"oak",
X	"ebony",
X	"runed",
X	"long",
X	"short",
X	"curved",
X	"steel",
X	"aluminium",
X	"iron",
X	"marble",
X	"pine",
X	"maple",
X	"brass",
X	"silver",
X	"copper",
X	"balsa",
X	"zinc",
X	"platinum"
X};
Xchar   *wandcall[SIZE (wantyp)];
X
X
X /* RINGS */
X
Xchar   *ringtyp[] = {
X	"adornment",
X	"teleportation",
X	"regeneration",
X	"searching",
X	"see invisible",
X	"stealth",
X	"floating",
X	"poison resistance",
X	"aggravate monster",
X	"hunger",
X	"fire resistance",
X	"cold resistance",
X	"protection from shape-changers",
X	"gain strength",
X	"increase damage",
X	"protection"
X};
X
X
Xchar   *rinnam[] = {
X	"blackened",
X /* "ivory", */
X	"granite",
X	"silver",
X	"ruby",
X	"jade",
X	"diamond",
X	"copper",
X	"gold",
X	"shining",
X	"tiger eye",
X	"agate",
X	"moonstone",
X	"sapphire",
X	"pearl",
X	"topaz",
X /* "black onix", */
X	"wired"
X};
X
Xchar   *ringcall[SIZE (ringtyp)], oiden[40], oldux, olduy;
/
echo 'x - hack.weapons.h'
sed 's/^X//' > hack.weapons.h << '/'
X/*
X * Hack.weapons.h
X */
X
X/*
X * weapons 0-4 come several at a time
X * weapons 0-2 are shot using 11-13
X */
X
Xstruct weapon weapons[] = {
X	{ "arrow",		7, 6, 6 },
X	{ "sling bullet",	7, 4, 6 },
X	{ "crossbow bolt",	7, 4, 6 },
X	{ "dart",		7, 3, 2 },
X	{ "mace",		7, 6, 6 },
X	{ "axe",		7, 6, 4 },
X	{ "flail",		7, 6, 4 },
X	{ "long sword",		9, 8,12 },
X	{ "two handed sword",	7,10, 6 },
X	{ "dagger",		7, 4, 3 },
X	{ "spear",		7, 6, 8 },
X	{ "bow",		7, 4, 6 },
X	{ "sling",		7, 6, 6 },
X	{ "crossbow",		7, 4, 6 },
X	{ "PROG ERROR",	      100, 0, 0 }
X };
/
echo 'x - hack.worm.c'
sed 's/^X//' > hack.worm.c << '/'
X/*
X * Hack.worm.c
X */
X
X#include "hack.h"
X
X/* Linked list, tail first */
XWORMSEGMENT wsegs[32], wheads[32];
X
Xunsigned        wgrowtime[32];
X
Xgetwn (mtmp)
XMONSTER mtmp;
X{
X	register        tmp;
X
X	for (tmp = 1; tmp < 32; tmp++)
X		if (!wsegs[tmp]) {
X			mtmp -> wormno = tmp;
X			return 1;
X		}
X	return 0;		/* Level infested with worms */
X}
X
Xinitworm (mtmp)
XMONSTER mtmp;
X{
X	register        WORMSEGMENT wtmp;
X	register        tmp = mtmp -> wormno;
X
X	if (!tmp)
X		return;
X	wheads[tmp] = wsegs[tmp] = wtmp = newseg ();
X	wgrowtime[tmp] = 0;
X	wtmp -> wx = mtmp -> mx;
X	wtmp -> wy = mtmp -> my;
X	wtmp -> nseg = 0;
X}
X
Xworm_move (mtmp)
XMONSTER mtmp;
X{
X	register        WORMSEGMENT wtmp, whd;
X	register        tmp = mtmp -> wormno;
X
X	wtmp = newseg ();
X	wtmp -> wx = mtmp -> mx;
X	wtmp -> wy = mtmp -> my;
X	wtmp -> nseg = 0;
X	whd = wheads[tmp];
X	whd -> nseg = wtmp;
X	wheads[tmp] = wtmp;
X	seeatl (whd -> wx, whd -> wy, '~');
X	if (wgrowtime[tmp] <= moves) {
X		if (!wgrowtime[tmp])
X			wgrowtime[tmp] = moves + rnd (5);
X		else
X			wgrowtime[tmp] += 2 + rnd (15);
X		mtmp -> orig_hp++;
X		mtmp -> mhp++;
X		return;
X	}
X	whd = wsegs[tmp];
X	wsegs[tmp] = whd -> nseg;
X	remseg (whd);
X}
X
Xworm_nomove (mtmp)
Xregister        MONSTER mtmp;
X{
X	register        tmp;
X	register        WORMSEGMENT wtmp;
X
X	tmp = mtmp -> wormno;
X	wtmp = wsegs[tmp];
X	if (wtmp == wheads[tmp])
X		return;
X	wsegs[tmp] = wtmp -> nseg;
X	remseg (wtmp);
X	mtmp -> mhp--;		/* Orig_hp not changed! */
X}
X
Xwormdead (mtmp)
Xregister        MONSTER mtmp;
X{
X	register        tmp = mtmp -> wormno;
X	register        WORMSEGMENT wtmp, wtmp2;
X
X	if (!tmp)
X		return;
X	for (wtmp = wsegs[tmp]; wtmp; wtmp = wtmp2) {
X		wtmp2 = wtmp -> nseg;
X		remseg (wtmp);
X	}
X	wsegs[tmp] = 0;
X}
X
Xwormhit (mtmp)
Xregister        MONSTER mtmp;
X{
X	register        tmp = mtmp -> wormno;
X	register        MONSTDATA mdat = mtmp -> data;
X	register        WORMSEGMENT wtmp;
X
X	if (!tmp)
X		return;		/* Worm without tail */
X	for (wtmp = wsegs[tmp]; wtmp; wtmp = wtmp -> nseg)
X		hitu (mdat -> mhd, 1, mdat -> mname);
X}
X
Xwormsee (tmp)
Xregister        tmp;
X{
X	register        WORMSEGMENT wtmp;
X
X	for (wtmp = wsegs[tmp]; wtmp -> nseg; wtmp = wtmp -> nseg)
X		if (!cansee (wtmp -> wx, wtmp -> wy))
X			levlsym (wtmp -> wx, wtmp -> wy, '~');
X}
X
Xcutworm (mtmp, x, y, weptyp)
Xregister        MONSTER mtmp;
Xregister char   x, y;
Xregister unsigned       weptyp;
X{
X	register        WORMSEGMENT wtmp, wtmp2;
X	register        MONSTER mtmp2;
X	register        tmp, tmp2;
X
X	if (mtmp -> mx == x && mtmp -> my == y)
X		return;		/* Hit headon */
X
X/* Cutting goes best with axe or sword */
X	tmp = rnd (20);
X	if (weptyp == 7 || weptyp == 8 || weptyp == 5)
X		tmp += 5;
X	if (tmp < 16)
X		return;
X
X/* If tail then worm just loses a tail segment */
X	tmp = mtmp -> wormno;
X	wtmp = wsegs[tmp];
X	if (wtmp -> wx == x && wtmp -> wy == y) {
X		wsegs[tmp] = wtmp -> nseg;
X		remseg (wtmp);
X		return;
X	}
X
X/* Cut the worm in two halves */
X	mtmp2 = newmonst (0);
X	*mtmp2 = *mtmp;
X
X/* Sometimes the tail end dies */
X	if (rn2 (8) || !getwn (mtmp2)) {/* Michiel was rn2(3) */
X		free (mtmp2);
X		tmp2 = 0;
X	}
X	else {
X		tmp2 = mtmp2 -> wormno;
X		wsegs[tmp2] = wsegs[tmp];
X		wgrowtime[tmp2] = 0;
X	}
X	do {
X		if (wtmp -> nseg -> wx == x && wtmp -> nseg -> wy == y) {
X			if (tmp2)
X				wheads[tmp2] = wtmp;
X			wsegs[tmp] = wtmp -> nseg -> nseg;
X			remseg (wtmp -> nseg);
X			wtmp -> nseg = 0;
X			if (tmp2) {
X				pline ("You cut the worm in half.");
X				mtmp2 -> orig_hp = mtmp2 -> mhp =
X					d (mtmp2 -> data -> mhd, 8);
X				mtmp2 -> mx = wtmp -> wx;
X				mtmp2 -> my = wtmp -> wy;
X				mtmp2 -> nmon = fmon;
X				fmon = mtmp2;
X				pmon (mtmp2);
X			}
X			else {
X				pline ("You cut off part of the worm's tail.");
X				remseg (wtmp);
X			}
X			mtmp -> mhp >>= 1;
X			return;
X		}
X		wtmp2 = wtmp -> nseg;
X		if (!tmp2)
X			remseg (wtmp);
X		wtmp = wtmp2;
X	} while (wtmp -> nseg);
X	panic (CORE, "Cannot find worm segment");
X}
X
Xremseg (wtmp)
Xregister        WORMSEGMENT wtmp;
X{
X	levlsym (wtmp -> wx, wtmp -> wy, '~');
X	free (wtmp);
X}
/
echo 'x - help'
sed 's/^X//' > help << '/'
X	Welcome to HACK!
X
X	Hack is a Dungeons and Dragons like game where you (the adventurer)
Xdescend into the depths of the dungeon in search of the Amulet of Guyver
X(reputed to be hidden on the twentieth level).  On the way you will find
Xuseful (or useless) magic items, and assorted monsters.  You attack a monster
Xby trying to move into the space a monster is in.
X
X	Unlike most adventure games, which give you a verbal description of
Xyour location, hack gives you a visual image of the dungeon level you are on.
X
X	Hack uses the following symbols:
X		A to Z and a to z:  monsters.  You can find out what a letter
Xrepresents by saying "whatis (letter)", as in "whatis A", which will tell you
Xthat 'A' is a giant ant.
X		- and |  These form the walls of a room.
X		.  this is the floor of a room.
X		#  this is a corridor.
X		}  this is a water filled area.
X		>  this is the staircase to the next level.
X		<  the staircase to the previous level.
X		@  You (usually).
X		^  A trap.
X		)  A weapon of some sort.
X		[  A suit of armor.
X		%  A piece of food.
X		/  A wand.
X		=  A ring.
X		?  A scroll.
X		!  A magic potion.
X		$  A pile or pot of gold.
X
XCommands:
X	Hack knows the following commands:
X		help		print this list. (Hack mode: ?)
X		quit		quit the game. (Hack mode: Q)
X		up		go up the staircase. (if you are standing on it)
X				(Hack mode: <)
X		down		go down (just like up).
X				(Hack mode: >)
X		n,s,ne,etc.	go one space in the direction indicated.
X				North is toward the top of the screen.
X		N,S,NE, etc.	Go in that direction until you hit a wall or
X				run into something.
X		invent		Print your inventory.
X				(Hack mode: i)
X		search		search for secret doors and traps in the 
X				locations next to you.
X				(hack mode: s)
X		(return)	rest, do nothing.
X		redraw		redraws the screen, useful if you type too fast
X				or your terminal is too slow.
X				(Hack mode: ^z (control/z))
X		whatis ~	(~ is any symbol printed on your screen)
X				Tell what ~ is.  (For instance 'whatis A'
X				will tell you that A is a giant ant.
X				(Hack mode: /)
X		eat		Eat food.  It will then ask what object you
X				want to eat.
X				(Hack mode: e)
X		wield		Change the weapon you use to attack with.
X				It will ask what you want to wield.
X				(Hack mode: w)
X		drink		Drink a potion.  (Hack mode: q quaff)
X		read		Read a scroll.   (Hack mode: r)
X		remove		Remove your armor or ring.
X				(Hack mode: T takeoff armor; R remove ring)
X		wear		Wear a suit of armor or a ring.
X				(Hack mode: W wear armor; P put on ring)
X		pay		Pay your shopping bill.
X				(Hack mode: p)
X		show            Show all you are wearing on armor and rings.
X				(Hack mode: a)
X		repeat          Repeat last message printed.
X				(Hack mode: A)
X		drop gems       Drop all your gems that you are currently 
X				holding.
X				(Hack mode: G)
X		oneline		Give inventories one line at a time
X				(at the top of your screen).
X				(Hack mode: o)
X
X	You can put a number before a command to repeat it that many times,
X	as in "20 search" or "40" (40 rest).
X	You can also put more than one command on a line by putting commas
X	between them, as in "20 search,2 e,20 search", or 
X	"n,e,n,e,n".
X
X	In hack mode you have the commands h (left), j (down), k (up),
X	l (right), y (nw), u (ne), b (sw), n(se); these move you one step.
X	Also HJKLYUBN - these move you as far as possible in the indicated
X	direction.
X	Also fh, fj etc. - these move you repeatedly in the indicated
X	direction until something interesting happens.
X	Finally FH, FJ etc. - these work like the previous, but branching
X	in a corridor is not considered interesting.
X
X
X	Have Fun, and Good Hacking!
/
echo 'x - mklev.mkobj.c'
sed 's/^X//' > mklev.mkobj.c << '/'
X/*
X * Mklev.mkobj.c
X */
X
X#define NORMAL_IO
X#include "hack.h"
X#include "hack.vars.h"
X
Xmkfood () {
X	register        FOOD fp;
X	register        i = rn2 (100);
X
X	fp = &foods[0];
X	while ((i -= fp -> prob) >= 0)
X		fp++;
X	return (fp - foods);
X}
X
Xmkarm () {
X	register        ARMOR ap;
X	register        i = rn2 (100);
X
X	ap = &armors[0];
X	while ((i -= ap -> prob) >= 0)
X		ap++;
X	return (ap - armors);
X}
X
Xmkwep () {
X	register        WEAPON wp;
X	register        i = rn2 (100);
X	wp = &weapons[0];
X	while ((i -= wp -> prob) >= 0)
X		wp++;
X	return (wp - weapons);
X}
X
Xchar    mkobjstr[] = "))[[!!!!????%%%%//=**";
X
Xmkobj (let)
Xregister        let;
X{
X	register        OBJECT otmp;
X
X	otmp = newobj ();
X	otmp -> nobj = fobj;
X	fobj = otmp;
X	otmp -> known = 0;
X	otmp -> cursed = 0;
X	otmp -> spe = 0;
X	otmp -> unpaid = 0;
X	otmp -> quan = 1;
X	if (!let)
X		let = mkobjstr[rn2 (sizeof (mkobjstr) - 1)];
X	otmp -> olet = let;
X	switch (let) {
X
X		case ')': 
X			otmp -> otyp = mkwep ();
X			if (otmp -> otyp <= W_AMMUNITION)
X				otmp -> quan = rn1 (6, 6);
X			if (!rn2 (11))
X				otmp -> spe = rnd (3);
X			else if (!rn2 (10)) {
X				otmp -> cursed = 1;
X				otmp -> spe = -rnd (3);
X			}
X			break;
X
X		case '*': 
X			otmp -> otyp = rn2 (SIZE (potcol));
X			otmp -> quan = rn2 (6) ? 1 : 2;
X			break;
X
X		case '[': 
X			otmp -> otyp = mkarm ();
X			if (!rn2 (8))
X				otmp -> cursed = 1;
X			if (!rn2 (10))
X				otmp -> spe = rnd (3);
X			else if (!rn2 (9)) {
X				otmp -> spe = -rnd (3);
X				otmp -> cursed = 1;
X			}
X			otmp -> spe += 10 - armors[otmp -> otyp].a_ac;
X			break;
X
X		case '!': 
X			otmp -> otyp = rn2 (SIZE (pottyp));
X			break;
X
X		case '?': 
X			otmp -> otyp = rn2 (SIZE (scrtyp));
X			break;
X
X		case '%': 
X			otmp -> otyp = mkfood ();
X			otmp -> quan = rn2 (6) ? 1 : 2;
X			break;
X
X		case '/': 
X			otmp -> otyp = rn2 (SIZE (wantyp));
X			if (otmp -> otyp == Z_DEATH)
X				otmp -> otyp = rn2 (SIZE (wantyp));
X			otmp -> spe = rn1 (5, (otmp -> otyp <= Z_CREATE_MON) ?
X					11 : 4);
X			break;
X
X		case '=': 
X			otmp -> otyp = rn2 (SIZE (ringtyp));
X			if (otmp -> otyp >= R_GAIN_STR) {
X				if (!rn2 (3)) {
X					otmp -> spe = -rnd (2);
X					otmp -> cursed = 1;
X				}
X				else
X					otmp -> spe = rnd (2);
X			}
X			else if (otmp -> otyp == R_TELE ||
X						otmp -> otyp == R_AGGRAV_MON ||
X					otmp -> otyp == R_HUNGER)
X				otmp -> cursed = 1;
X			break;
X
X		default: 
X			panic ("impossible mkobj");
X	}
X}
/
echo 'x - rnd.c'
sed 's/^X//' > rnd.c << '/'
X/*
X * Rnd.c
X */
X
X#define RND(x)	((rand() >> 3) % x)
X
Xrn1 (x, y)
Xregister        x, y;
X{
X	return (RND (x) + y);
X}
X
Xrn2 (x)
Xregister        x;
X{
X	return (RND (x));
X}
X
Xrnd (x)
Xregister        x;
X{
X	return (RND (x) + 1);
X}
X
Xd (n, x)
Xregister        n, x;
X{
X	register        tmp = n;
X
X	while (n--)
X		tmp += RND (x);
X	return tmp;
X}
/
echo 'Part 05 of Hack complete.'
exit
-- 

			Michiel Huisjes.
			{seismo|decvax|philabs}!mcvax!vu44!ark!huisjes
