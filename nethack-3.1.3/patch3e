Path: uunet!news.tek.com!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v18i038:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Patch3e/18
Date: 20 Jul 1993 22:32:34 GMT
Organization: Tektronix, Inc, Redmond, OR, USA
Lines: 2185
Approved: billr@saab.CNA.TEK.COM
Message-ID: <22hrq2$9ps@ying.cna.tek.com>
NNTP-Posting-Host: saab.cna.tek.com
Xref: uunet comp.sources.games:1838

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 18, Issue 38
Archive-name: nethack31/patch3e
Patch-To: nethack31: Volume 16, Issue 1-116
Environment: Amiga, Atari, Mac, MS-DOS, Windows-NT, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 5 (of 18)."
# Contents:  patches03a sys/amiga/amifont8.uu
# Wrapped by billr@saab on Tue Jul 20 14:57:19 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'patches03a' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'patches03a'\" to \"'patches03a.orig'\"
  mv -f 'patches03a' 'patches03a.orig'
fi
echo shar: Extracting \"'patches03a'\" \(53393 characters\)
sed "s/^X//" >'patches03a' <<'END_OF_FILE'
X*** /tmp/da20824	Mon Jul 12 17:31:22 1993
X--- src/allmain.c	Thu Jul  1 14:42:14 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)allmain.c	3.1	93/05/23	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)allmain.c	3.1	93/06/16	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 163,169 ****
X  		    }
X  
X  		    if(!u.uinvulnerable) {
X! 			if(Teleportation && !rn2(85)) tele();
X  #ifdef POLYSELF
X  			if(Polymorph && !rn2(100)) {
X  			    if (multi >= 0) {
X--- 163,175 ----
X  		    }
X  
X  		    if(!u.uinvulnerable) {
X! 			if(Teleportation && !rn2(85)) {
X! #ifdef REDO		    /* clear doagain keystrokes */
X! 			    pushch(0);
X! 			    savech(0);
X! #endif
X! 			    tele();
X! 			}
X  #ifdef POLYSELF
X  			if(Polymorph && !rn2(100)) {
X  			    if (multi >= 0) {
X*** /tmp/da20840	Mon Jul 12 17:31:27 1993
X--- src/apply.c	Wed Jul  7 16:23:53 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)apply.c	3.1	93/05/25	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)apply.c	3.1	93/06/24	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 40,45 ****
X--- 40,49 ----
X  static void FDECL(mkcavearea, (BOOLEAN_P));
X  static void FDECL(digactualhole, (int));
X  
X+ #ifdef	AMIGA
X+ void FDECL( amii_speaker, ( struct obj *, char *, int ) );
X+ #endif
X+ 
X  #ifdef TOURIST
X  static int
X  use_camera(obj)
X***************
X*** 270,276 ****
X  um_dist(x,y,n)
X  register xchar x, y, n;
X  {
X! 	return(abs(u.ux - x) > n  || abs(u.uy - y) > n);
X  }
X  
X  #endif /* OVLB */
X--- 274,280 ----
X  um_dist(x,y,n)
X  register xchar x, y, n;
X  {
X! 	return((boolean)(abs(u.ux - x) > n  || abs(u.uy - y) > n));
X  }
X  
X  #endif /* OVLB */
X***************
X*** 674,680 ****
X  		register struct trap *ttmp;
X  
X  		if(dig_effort > 250) {
X! 			dighole();
X  			dig_level.dnum = 0;
X  			dig_level.dlevel = -1;
X  			return(0);	/* done with digging */
X--- 678,684 ----
X  		register struct trap *ttmp;
X  
X  		if(dig_effort > 250) {
X! 			(void) dighole(FALSE);
X  			dig_level.dnum = 0;
X  			dig_level.dlevel = -1;
X  			return(0);	/* done with digging */
X***************
X*** 693,701 ****
X  			angry_priest();
X  		}
X  
X! 		digactualhole(PIT);	/* at u.ux, u.uy */
X! 		dig_level.dnum = 0;
X! 		dig_level.dlevel = -1;
X  		return(0);
X  	}
X  	if(dig_effort > 100) {
X--- 697,706 ----
X  			angry_priest();
X  		}
X  
X! 		if (dighole(TRUE)) {	/* make pit at <u.ux,u.uy> */
X! 		    dig_level.dnum = 0;
X! 		    dig_level.dlevel = -1;
X! 		}
X  		return(0);
X  	}
X  	if(dig_effort > 100) {
X***************
X*** 824,836 ****
X      register int x1, y1;
X      int lo_x = max(1,x-1), hi_x = min(x+1,COLNO-1),
X  	lo_y = max(0,y-1), hi_y = min(y+1,ROWNO-1);
X  
X      for (x1 = lo_x; x1 <= hi_x; x1++)
X  	for (y1 = lo_y; y1 <= hi_y; y1++)
X! 	    if(levl[x1][y1].typ == MOAT || levl[x1][y1].typ == LAVAPOOL)
X! 		return levl[x1][y1].typ;
X  
X!     return ROOM;
X  }
X  
X  static void
X--- 829,858 ----
X      register int x1, y1;
X      int lo_x = max(1,x-1), hi_x = min(x+1,COLNO-1),
X  	lo_y = max(0,y-1), hi_y = min(y+1,ROWNO-1);
X+     int pool_cnt = 0, moat_cnt = 0, lava_cnt = 0;
X  
X      for (x1 = lo_x; x1 <= hi_x; x1++)
X  	for (y1 = lo_y; y1 <= hi_y; y1++)
X! 	    if (levl[x1][y1].typ == POOL)
X! 		pool_cnt++;
X! 	    else if (levl[x1][y1].typ == MOAT ||
X! 		    (levl[x1][y1].typ == DRAWBRIDGE_UP &&
X! 			(levl[x1][y1].drawbridgemask & DB_UNDER) == DB_MOAT))
X! 		moat_cnt++;
X! 	    else if (levl[x1][y1].typ == LAVAPOOL ||
X! 		    (levl[x1][y1].typ == DRAWBRIDGE_UP &&
X! 			(levl[x1][y1].drawbridgemask & DB_UNDER) == DB_LAVA))
X! 		lava_cnt++;
X!     pool_cnt /= 3;		/* not as much liquid as the others */
X  
X!     if (lava_cnt > moat_cnt + pool_cnt && rn2(lava_cnt + 1))
X! 	return LAVAPOOL;
X!     else if (moat_cnt > 0 && rn2(moat_cnt + 1))
X! 	return MOAT;
X!     else if (pool_cnt > 0 && rn2(pool_cnt + 1))
X! 	return POOL;
X!     else
X! 	return ROOM;
X  }
X  
X  static void
X***************
X*** 861,867 ****
X  		if (oldobjs != newobjs)	/* something unearthed */
X  			pickup(1);	/* detects pit */
X  		else
X! 			You("dig a pit.");
X  
X  	} else {	/* TRAPDOOR */
X  		pline("You dig a hole through the %s.", surface(u.ux,u.uy));
X--- 883,889 ----
X  		if (oldobjs != newobjs)	/* something unearthed */
X  			pickup(1);	/* detects pit */
X  		else
X! 			You("dig a pit in the %s.", surface(u.ux, u.uy));
X  
X  	} else {	/* TRAPDOOR */
X  		pline("You dig a hole through the %s.", surface(u.ux,u.uy));
X***************
X*** 909,916 ****
X  	}
X  }
X  
X! void
X! dighole()
X  {
X  	register struct trap *ttmp = t_at(u.ux, u.uy);
X  	struct rm *lev = &levl[u.ux][u.uy];
X--- 931,940 ----
X  	}
X  }
X  
X! /* return TRUE if digging succeeded, FALSE otherwise */
X! boolean
X! dighole(pit_only)
X! boolean pit_only;
X  {
X  	register struct trap *ttmp = t_at(u.ux, u.uy);
X  	struct rm *lev = &levl[u.ux][u.uy];
X***************
X*** 927,933 ****
X  		wake_nearby();	/* splashing */
X  
X  	} else if (lev->typ == DRAWBRIDGE_DOWN) {
X! 		destroy_drawbridge(u.ux,u.uy);
X  
X  	} else if ((boulder_here = sobj_at(BOULDER, u.ux, u.uy)) != 0) {
X  		if (ttmp && (ttmp->ttyp == PIT || ttmp->ttyp == SPIKED_PIT)) {
X--- 951,963 ----
X  		wake_nearby();	/* splashing */
X  
X  	} else if (lev->typ == DRAWBRIDGE_DOWN) {
X! 		if (pit_only) {
X! 		    pline("The drawbridge seems too hard to dig through.");
X! 		    return FALSE;
X! 		} else {
X! 		    destroy_drawbridge(u.ux, u.uy);
X! 		    return TRUE;
X! 		}
X  
X  	} else if ((boulder_here = sobj_at(BOULDER, u.ux, u.uy)) != 0) {
X  		if (ttmp && (ttmp->ttyp == PIT || ttmp->ttyp == SPIKED_PIT)) {
X***************
X*** 958,963 ****
X--- 988,994 ----
X  			}
X  		}
X  		delobj(boulder_here);
X+ 		return TRUE;
X  
X  	} else if (lev->typ == DRAWBRIDGE_UP) {
X  		/* must be floor or ice, other cases handled above */
X***************
X*** 965,985 ****
X  		typ = fillholetyp(u.ux,u.uy);
X  
X  		if (typ == ROOM) {
X- 		    if (lev->drawbridgemask & DB_ICE)
X- 			typ = MOAT;
X- 		    else {
X  			/*
X! 			 * We can't dig a pit here since that will destroy
X  			 * the drawbridge.  The following is a cop-out. --dlc
X  			 */
X! 			pline("The floor here is too hard to dig in.");
X! 			return;
X! 		    }
X  		}
X  
X! 		lev->drawbridgemask &= DB_DIR;
X! 		if (typ == LAVAPOOL) lev->drawbridgemask |= DB_LAVA;
X! 	    liquid_flow:
X  		newsym(u.ux,u.uy);
X  
X  		pline("As you dig a pit, it fills with %s!",
X--- 996,1014 ----
X  		typ = fillholetyp(u.ux,u.uy);
X  
X  		if (typ == ROOM) {
X  			/*
X! 			 * We can't dig a hole here since that will destroy
X  			 * the drawbridge.  The following is a cop-out. --dlc
X  			 */
X! 			pline("The %s here is too hard to dig in.",
X! 			      surface(u.ux, u.uy));
X! 			return FALSE;
X  		}
X  
X! 		lev->drawbridgemask &= ~DB_UNDER;
X! 		lev->drawbridgemask |= (typ == LAVAPOOL) ? DB_LAVA : DB_MOAT;
X! 
X!  liquid_flow:
X  		newsym(u.ux,u.uy);
X  
X  		pline("As you dig a pit, it fills with %s!",
X***************
X*** 994,1006 ****
X--- 1023,1038 ----
X  		    else if (!Wwalking)
X  			(void) drown();
X  		}
X+ 		return TRUE;
X  
X  	} else if (IS_FOUNTAIN(lev->typ)) {
X  		dogushforth(FALSE);
X  		dryup(u.ux,u.uy);
X+ 		return TRUE;
X  #ifdef SINKS
X  	} else if (IS_SINK(lev->typ)) {
X  		breaksink(u.ux, u.uy);
X+ 		return TRUE;
X  #endif
X  	/* the following two are here for the wand of digging */
X  	} else if (IS_THRONE(lev->typ)) {
X***************
X*** 1010,1030 ****
X  		pline("The altar is too hard to break apart.");
X  
X  	} else {
X! 		if (lev->typ == ICE) {
X! 			typ = fillholetyp(u.ux,u.uy);
X  
X! 			if (typ != ROOM) {
X! 			    lev->typ = typ;
X! 			    goto liquid_flow;
X! 			}
X  		}
X  
X  		/* finally we get to make a hole */
X! 		if (nohole) {	/* can't make a trapdoor, so make a pit */
X  			digactualhole(PIT);
X! 		} else
X  			digactualhole(TRAPDOOR);
X  	}
X  }
X  
X  static boolean
X--- 1042,1064 ----
X  		pline("The altar is too hard to break apart.");
X  
X  	} else {
X! 		typ = fillholetyp(u.ux,u.uy);
X  
X! 		if (typ != ROOM) {
X! 			lev->typ = typ;
X! 			goto liquid_flow;
X  		}
X  
X  		/* finally we get to make a hole */
X! 		if (nohole || pit_only)
X  			digactualhole(PIT);
X! 		else
X  			digactualhole(TRAPDOOR);
X+ 
X+ 		return TRUE;
X  	}
X+ 
X+ 	return FALSE;
X  }
X  
X  static boolean
X***************
X*** 1168,1178 ****
X  			dig_pos.y = u.uy;
X  			assign_level(&dig_level, &u.uz);
X  			dig_effort = 0;
X! 			You("start digging in the %s.", surface(u.ux,u.uy));
X  			if(*u.ushops)
X  				shopdig(0);
X  		} else
X! 			You("continue digging in the %s.", surface(u.ux,u.uy));
X  		did_dig_msg = FALSE;
X  		set_occupation(dig, "digging", 0);
X  	}
X--- 1202,1212 ----
X  			dig_pos.y = u.uy;
X  			assign_level(&dig_level, &u.uz);
X  			dig_effort = 0;
X! 			You("start digging downward.");
X  			if(*u.ushops)
X  				shopdig(0);
X  		} else
X! 			You("continue digging downward.");
X  		did_dig_msg = FALSE;
X  		set_occupation(dig, "digging", 0);
X  	}
X***************
X*** 1327,1333 ****
X  
X  	if(Underwater) {
X  #ifdef	AMIGA
X! 	    amii_speaker( obj, "AwDwGwEwDhEhAqDqFwGw", AMII_MUFFLED_VOLUME );
X  #endif
X  	    pline("But the sound is muffled.");
X  	    return;
X--- 1361,1367 ----
X  
X  	if(Underwater) {
X  #ifdef	AMIGA
X! 	    amii_speaker( obj, "AhDhGqEqDhEhAqDqFhGw", AMII_MUFFLED_VOLUME );
X  #endif
X  	    pline("But the sound is muffled.");
X  	    return;
X***************
X*** 1338,1344 ****
X  		return;
X  	    }
X  #ifdef	AMIGA
X! 	    amii_speaker( obj, "awdwgwewdhehaqdqfwgw", AMII_MUFFLED_VOLUME );
X  #endif
X  	    if(obj->cursed && !rn2(3)) {
X  		register struct monst *mtmp;
X--- 1372,1378 ----
X  		return;
X  	    }
X  #ifdef	AMIGA
X! 	    amii_speaker( obj, "ahdhgqeqdhehaqdqfhgw", AMII_MUFFLED_VOLUME );
X  #endif
X  	    if(obj->cursed && !rn2(3)) {
X  		register struct monst *mtmp;
X***************
X*** 1382,1388 ****
X  		register int cnt = openit();
X  		if(cnt == -1) return; /* was swallowed */
X  #ifdef	AMIGA
X! 		amii_speaker( obj, "awawawDwEwCw", AMII_SOFT_VOLUME );
X  #endif
X  		switch(cnt) {
X  		  case 0:  pline(nothing_happens); break;
X--- 1416,1422 ----
X  		register int cnt = openit();
X  		if(cnt == -1) return; /* was swallowed */
X  #ifdef	AMIGA
X! 		amii_speaker( obj, "ahahahDhEhCw", AMII_SOFT_VOLUME );
X  #endif
X  		switch(cnt) {
X  		  case 0:  pline(nothing_happens); break;
X***************
X*** 1394,1400 ****
X  	    } else pline(nothing_happens);
X  	} else {  /* uncursed */
X  #ifdef	AMIGA
X! 	    amii_speaker( obj, "AeFeaeFeAefegW", AMII_OKAY_VOLUME );
X  #endif
X  	    if(obj->spe > 0) {
X  		register int cnt = findit();
X--- 1428,1434 ----
X  	    } else pline(nothing_happens);
X  	} else {  /* uncursed */
X  #ifdef	AMIGA
X! 	    amii_speaker( obj, "AeFeaeFeAefegw", AMII_OKAY_VOLUME );
X  #endif
X  	    if(obj->spe > 0) {
X  		register int cnt = findit();
X***************
X*** 1770,1775 ****
X--- 1804,1818 ----
X  	}
X  }
X  
X+ boolean
X+ tinnable(corpse)
X+ struct obj *corpse;
X+ {
X+ 	if (corpse->oeaten) return 0;
X+ 	if (!mons[corpse->corpsenm].cnutrit) return 0;
X+ 	return 1;
X+ }
X+ 
X  static void
X  use_tinning_kit(obj)
X  register struct obj *obj;
X***************
X*** 1779,1785 ****
X  	/* This takes only 1 move.  If this is to be changed to take many
X  	 * moves, we've got to deal with decaying corpses...
X  	 */
X! 	if (!(corpse = floorfood("tin", 1))) return;
X  	if (corpse->oeaten) {
X  		You("cannot tin something which is partly eaten.");
X  		return;
X--- 1822,1828 ----
X  	/* This takes only 1 move.  If this is to be changed to take many
X  	 * moves, we've got to deal with decaying corpses...
X  	 */
X! 	if (!(corpse = floorfood("tin", 2))) return;
X  	if (corpse->oeaten) {
X  		You("cannot tin something which is partly eaten.");
X  		return;
X*** /tmp/da20850	Mon Jul 12 17:31:33 1993
X--- src/artifact.c	Wed Jul  7 16:23:58 1993
X***************
X*** 235,241 ****
X  {
X  	const struct artifact *arti = get_artifact(otmp);
X  
X! 	return(arti && (arti->spfx & abil));
X  }
X  
X  #endif /* OVL0 */
X--- 235,241 ----
X  {
X  	const struct artifact *arti = get_artifact(otmp);
X  
X! 	return((boolean)(arti && (arti->spfx & abil)));
X  }
X  
X  #endif /* OVL0 */
X***************
X*** 256,263 ****
X  		 */
X  	for (a = artilist+1; a->otyp; a++)
X  	    if (a->otyp == otmp->otyp && !strcmp(a->name, name))
X! 		return ((a->spfx & (SPFX_NOGEN|SPFX_RESTR)) != 0 ||
X! 			otmp->quan > 1L);
X  
X  	return FALSE;
X  }
X--- 256,263 ----
X  		 */
X  	for (a = artilist+1; a->otyp; a++)
X  	    if (a->otyp == otmp->otyp && !strcmp(a->name, name))
X! 		return ((boolean)((a->spfx & (SPFX_NOGEN|SPFX_RESTR)) != 0 ||
X! 			otmp->quan > 1L));
X  
X  	return FALSE;
X  }
X***************
X*** 270,276 ****
X  	register const struct artifact *weap;
X  
X  	if ((weap = get_artifact(otmp)) != 0)
X! 		return(weap->attk.adtyp == adtyp);
X  	return(0);
X  }
X  
X--- 270,276 ----
X  	register const struct artifact *weap;
X  
X  	if ((weap = get_artifact(otmp)) != 0)
X! 		return((boolean)(weap->attk.adtyp == adtyp));
X  	return(0);
X  }
X  
X***************
X*** 282,288 ****
X  	register const struct artifact *weap;
X  
X  	if ((weap = get_artifact(otmp)) != 0)
X! 		return(weap->defn.adtyp == adtyp);
X  	return(0);
X  }
X  
X--- 282,288 ----
X  	register const struct artifact *weap;
X  
X  	if ((weap = get_artifact(otmp)) != 0)
X! 		return((boolean)(weap->defn.adtyp == adtyp));
X  	return(0);
X  }
X  
X***************
X*** 844,856 ****
X  					pline("Somehow, %s misses wildly.",
X  						mon_nam(magr));
X  				*dmgptr = 0;
X! 				return (youattack || vis);
X  			}
X  			if (noncorporeal(mdef->data) || amorphous(mdef->data)) {
X  				pline("%s slices through %s neck.",
X  				      artilist[ART_VORPAL_BLADE].name,
X  				      s_suffix(mon_nam(mdef)));
X! 				return (youattack || vis);
X  			}
X  			*dmgptr = mdef->mhp;
X  			pline(behead_msg[rn2(SIZE(behead_msg))],
X--- 844,856 ----
X  					pline("Somehow, %s misses wildly.",
X  						mon_nam(magr));
X  				*dmgptr = 0;
X! 				return ((boolean)(youattack || vis));
X  			}
X  			if (noncorporeal(mdef->data) || amorphous(mdef->data)) {
X  				pline("%s slices through %s neck.",
X  				      artilist[ART_VORPAL_BLADE].name,
X  				      s_suffix(mon_nam(mdef)));
X! 				return ((boolean)(youattack || vis));
X  			}
X  			*dmgptr = mdef->mhp;
X  			pline(behead_msg[rn2(SIZE(behead_msg))],
X*** /tmp/da20858	Mon Jul 12 17:31:35 1993
X--- src/attrib.c	Wed Jul  7 16:24:00 1993
X***************
X*** 687,693 ****
X  #ifdef WIN32_BUG
X  		else return(x=((tmp >= 125) ? 125 : (tmp <= 3) ? 3 : tmp));
X  #else
X! 		else return((tmp >= 125) ? 125 : (tmp <= 3) ? 3 : tmp);
X  #endif
X  	} 
X  #ifdef POLYSELF
X--- 687,693 ----
X  #ifdef WIN32_BUG
X  		else return(x=((tmp >= 125) ? 125 : (tmp <= 3) ? 3 : tmp));
X  #else
X! 		else return((schar)((tmp >= 125) ? 125 : (tmp <= 3) ? 3 : tmp));
X  #endif
X  	} 
X  #ifdef POLYSELF
X***************
X*** 700,706 ****
X  #ifdef WIN32_BUG
X  	return(x=((tmp >= 25) ? 25 : (tmp <= 3) ? 3 : tmp));
X  #else
X! 	return((tmp >= 25) ? 25 : (tmp <= 3) ? 3 : tmp);
X  #endif
X  }
X  
X--- 700,706 ----
X  #ifdef WIN32_BUG
X  	return(x=((tmp >= 25) ? 25 : (tmp <= 3) ? 3 : tmp));
X  #else
X! 	return((schar)((tmp >= 25) ? 25 : (tmp <= 3) ? 3 : tmp));
X  #endif
X  }
X  
X***************
X*** 711,719 ****
X  {
X  	register int str = ACURR(A_STR);
X  
X! 	if (str <= 18) return str;
X! 	if (str <= 121) return (19 + str / 50); /* map to 19-21 */
X! 	else return str - 100;
X  }
X  
X  #endif /* OVL0 */
X--- 711,719 ----
X  {
X  	register int str = ACURR(A_STR);
X  
X! 	if (str <= 18) return((schar)str);
X! 	if (str <= 121) return((schar)(19 + str / 50)); /* map to 19-21 */
X! 	else return((schar)(str - 100));
X  }
X  
X  #endif /* OVL0 */
X*** /tmp/da20875	Mon Jul 12 17:31:40 1993
X--- src/bones.c	Wed Jul  7 16:59:00 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)bones.c	3.1	93/05/22	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985,1993. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)bones.c	3.1	93/06/05	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985,1993. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 26,32 ****
X  
X  	if (ledger_no(&save_dlevel)) assign_level(lev, &save_dlevel);
X  
X! 	return (((sptr = Is_special(lev)) && !sptr->boneid)
X  		|| !dungeons[lev->dnum].boneid
X  		   /* no bones on the last or multiway branch levels */
X  		   /* in any dungeon (level 1 isn't multiway).       */
X--- 26,32 ----
X  
X  	if (ledger_no(&save_dlevel)) assign_level(lev, &save_dlevel);
X  
X! 	return (boolean)(((sptr = Is_special(lev)) && !sptr->boneid)
X  		|| !dungeons[lev->dnum].boneid
X  		   /* no bones on the last or multiway branch levels */
X  		   /* in any dungeon (level 1 isn't multiway).       */
X***************
X*** 172,178 ****
X  #ifdef TUTTI_FRUTTI
X  	struct fruit *f;
X  #endif
X! 	char *bonesid;
X  
X  	if(ledger_no(&u.uz) <= 0 || ledger_no(&u.uz) > maxledgerno()) return;
X  	if(no_bones_level(&u.uz)) return; /* no bones for specific levels */
X--- 172,178 ----
X  #ifdef TUTTI_FRUTTI
X  	struct fruit *f;
X  #endif
X! 	char c, *bonesid;
X  
X  	if(ledger_no(&u.uz) <= 0 || ledger_no(&u.uz) > maxledgerno()) return;
X  	if(no_bones_level(&u.uz)) return; /* no bones for specific levels */
X***************
X*** 321,327 ****
X  	co_false();	/* make sure bonesid and savefruitchn get written */
X  #endif /* MFLOPPY */
X  
X! 	bwrite(fd, (genericptr_t) bonesid, 7);	/* DD.nnn */
X  #ifdef TUTTI_FRUTTI
X  	savefruitchn(fd, WRITE_SAVE | FREE_SAVE);
X  #endif
X--- 321,329 ----
X  	co_false();	/* make sure bonesid and savefruitchn get written */
X  #endif /* MFLOPPY */
X  
X! 	c = (char) (strlen(bonesid) + 1);
X! 	bwrite(fd, (genericptr_t) &c, sizeof c);
X! 	bwrite(fd, (genericptr_t) bonesid, (unsigned) c);	/* DD.nnn */
X  #ifdef TUTTI_FRUTTI
X  	savefruitchn(fd, WRITE_SAVE | FREE_SAVE);
X  #endif
X***************
X*** 335,341 ****
X  {
X  	register int fd;
X  	register int ok;
X! 	char *bonesid, oldbonesid[7];
X  
X  #ifdef EXPLORE_MODE
X  	if(discover)		/* save bones files for real games */
X--- 337,343 ----
X  {
X  	register int fd;
X  	register int ok;
X! 	char c, *bonesid, oldbonesid[10];
X  
X  #ifdef EXPLORE_MODE
X  	if(discover)		/* save bones files for real games */
X***************
X*** 362,368 ****
X  		}
X  #endif
X  		minit();	/* ZEROCOMP */
X! 		mread(fd, (genericptr_t) oldbonesid, 7);	/* DD.nnn */
X  		if (strcmp(bonesid, oldbonesid)) {
X  #ifdef WIZARD
X  			if (wizard) {
X--- 364,371 ----
X  		}
X  #endif
X  		minit();	/* ZEROCOMP */
X! 		mread(fd, (genericptr_t) &c, sizeof c);	/* length incl. '\0' */
X! 		mread(fd, (genericptr_t) oldbonesid, (unsigned) c); /* DD.nnn */
X  		if (strcmp(bonesid, oldbonesid)) {
X  #ifdef WIZARD
X  			if (wizard) {
X*** /tmp/da20893	Mon Jul 12 17:31:45 1993
X--- src/cmd.c	Thu Jul  8 13:53:33 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)cmd.c	3.1	93/04/24	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)cmd.c	3.1	93/06/18	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 201,208 ****
X  	 * pushed back on the pushq.
X  	 */
X  	if (occupation) return '\0';
X! 	if (in_doagain) return (shead != stail) ? saveq[stail++] : '\0';
X! 	else		return (phead != ptail) ? pushq[ptail++] : '\0';
X  }
X  
X  char
X--- 201,208 ----
X  	 * pushed back on the pushq.
X  	 */
X  	if (occupation) return '\0';
X! 	if (in_doagain) return(char)((shead != stail) ? saveq[stail++] : '\0');
X! 	else		return(char)((phead != ptail) ? pushq[ptail++] : '\0');
X  }
X  
X  char
X***************
X*** 211,217 ****
X  
X  	if(!(ch = popch()))
X  		ch = nhgetch();
X! 	return(ch);
X  }
X  
X  /* A ch == 0 resets the pushq */
X--- 211,217 ----
X  
X  	if(!(ch = popch()))
X  		ch = nhgetch();
X! 	return((char)ch);
X  }
X  
X  /* A ch == 0 resets the pushq */
X***************
X*** 581,586 ****
X--- 581,594 ----
X  		enl_msg("Bad luck ", "does", "did", " not time out for you");
X  	    if (ltmp >= 0)
X  		enl_msg("Good luck ", "does", "did", " not time out for you");
X+ 	}
X+ 
X+ 	if (u.umortality) {
X+ 	    if (u.umortality == 1)
X+ 		Sprintf(buf, "once");
X+ 	    else
X+ 		Sprintf(buf, "%d times", u.umortality);
X+ 	    enl_msg("You ", "have been killed ", "died ", buf);
X  	}
X  
X  	display_nhwindow(en_win, TRUE);
X*** /tmp/da20901	Mon Jul 12 17:31:47 1993
X--- src/dbridge.c	Wed Jul  7 16:24:08 1993
X***************
X*** 112,118 ****
X  is_db_wall(x,y)
X  int x,y;
X  {
X! 	return( levl[x][y].typ == DBWALL );
X  }
X  
X  
X--- 112,118 ----
X  is_db_wall(x,y)
X  int x,y;
X  {
X! 	return((boolean)( levl[x][y].typ == DBWALL ));
X  }
X  
X  
X***************
X*** 379,392 ****
X  	if (noncorporeal(etmp->edata))
X  		return(TRUE);
X  	if (is_pool(x, y))
X! 		return((is_u(etmp) && (Wwalking || Amphibious || Levitation)) ||
X  		       is_swimmer(etmp->edata) || is_flyer(etmp->edata) ||
X! 		       is_floater(etmp->edata));
X  	/* must force call to lava_effects in e_died if is_u */
X  	if (is_lava(x, y))
X! 		return(is_u(etmp) ? !!Levitation : resists_fire(etmp->edata));
X  	if (is_db_wall(x, y))
X! 		return(passes_walls(etmp->edata));
X  	return(TRUE);
X  }
X  
X--- 379,392 ----
X  	if (noncorporeal(etmp->edata))
X  		return(TRUE);
X  	if (is_pool(x, y))
X! 		return((boolean)((is_u(etmp) && (Wwalking || Amphibious || Levitation)) ||
X  		       is_swimmer(etmp->edata) || is_flyer(etmp->edata) ||
X! 		       is_floater(etmp->edata)));
X  	/* must force call to lava_effects in e_died if is_u */
X  	if (is_lava(x, y))
X! 		return((boolean)(is_u(etmp) ? !!Levitation : resists_fire(etmp->edata)));
X  	if (is_db_wall(x, y))
X! 		return((boolean)(passes_walls(etmp->edata)));
X  	return(TRUE);
X  }
X  
X***************
X*** 434,440 ****
X  automiss(etmp)
X  struct entity *etmp;
X  {
X! 	return(passes_walls(etmp->edata) || noncorporeal(etmp->edata));
X  }
X  
X  /*
X--- 434,440 ----
X  automiss(etmp)
X  struct entity *etmp;
X  {
X! 	return((boolean)(passes_walls(etmp->edata) || noncorporeal(etmp->edata)));
X  }
X  
X  /*
X***************
X*** 477,483 ****
X  	pline("Miss chance = %d (out of 8)", misses);
X  #endif
X  
X! 	return((misses >= rnd(8))? TRUE : FALSE);
X  }
X  
X  /*
X--- 477,483 ----
X  	pline("Miss chance = %d (out of 8)", misses);
X  #endif
X  
X! 	return((boolean)((misses >= rnd(8))? TRUE : FALSE));
X  }
X  
X  /*
X***************
X*** 507,513 ****
X  #ifdef D_DEBUG
X  	pline("%s to jump (%d chances in 10)", E_phrase(etmp, "try"), tmp);
X  #endif
X! 	return((tmp >= rnd(10))? TRUE : FALSE);
X  }
X  
X  static void
X--- 507,513 ----
X  #ifdef D_DEBUG
X  	pline("%s to jump (%d chances in 10)", E_phrase(etmp, "try"), tmp);
X  #endif
X! 	return((boolean)((tmp >= rnd(10))? TRUE : FALSE));
X  }
X  
X  static void
X*** /tmp/da20917	Mon Jul 12 17:31:52 1993
X--- src/detect.c	Wed Jul  7 16:24:11 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)detect.c	3.1	93/03/30	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)detect.c	3.1	93/06/15	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 53,61 ****
X  	if (glyph_is_object(lev->glyph)) {
X  	    /* there's some object shown here */
X  	    if (oclass == ALL_CLASSES) {
X! 		return !(level.objects[x][y] ||     /* stale if nothing here */
X  			    ((mtmp = m_at(x,y)) != 0 &&
X! 				(mtmp->mgold || mtmp->minvent)));
X  	    } else if (objects[glyph_to_obj(lev->glyph)].oc_class == oclass) {
X  		/* the object shown here is of interest */
X  		for (otmp = level.objects[x][y]; otmp; otmp = otmp->nexthere)
X--- 53,61 ----
X  	if (glyph_is_object(lev->glyph)) {
X  	    /* there's some object shown here */
X  	    if (oclass == ALL_CLASSES) {
X! 		return((boolean)( !(level.objects[x][y] ||     /* stale if nothing here */
X  			    ((mtmp = m_at(x,y)) != 0 &&
X! 				(mtmp->mgold || mtmp->minvent)))));
X  	    } else if (objects[glyph_to_obj(lev->glyph)].oc_class == oclass) {
X  		/* the object shown here is of interest */
X  		for (otmp = level.objects[x][y]; otmp; otmp = otmp->nexthere)
X***************
X*** 587,593 ****
X      }
X      oops = (rnd(20) > ACURR(A_INT) || obj->cursed);
X      if (oops && (obj->spe > 0)) {
X! 	switch(rnd(5)) {
X  	case 1 : pline("%s is too much to comprehend!", The(bname));
X  	    break;
X  	case 2 : pline("%s confuses you!", The(bname));
X--- 587,593 ----
X      }
X      oops = (rnd(20) > ACURR(A_INT) || obj->cursed);
X      if (oops && (obj->spe > 0)) {
X! 	switch (rnd(obj->oartifact ? 4 : 5)) {
X  	case 1 : pline("%s is too much to comprehend!", The(bname));
X  	    break;
X  	case 2 : pline("%s confuses you!", The(bname));
X*** /tmp/da20933	Mon Jul 12 17:31:57 1993
X--- src/do.c	Thu Jul  8 17:04:53 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)do.c	3.1	93/03/30	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)do.c	3.1	93/06/26	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 153,159 ****
X  		 (t->ttyp==PIT || t->ttyp==SPIKED_PIT || t->ttyp==TRAPDOOR)) {
X  		struct monst *mtmp;
X  
X- 		bury_objs(x, y);
X  		if(!Can_fall_thru(&u.uz) && t->ttyp == TRAPDOOR)
X  			return FALSE;
X  		if (((mtmp = m_at(x, y)) && mtmp->mtrapped) ||
X--- 153,158 ----
X***************
X*** 166,173 ****
X  			if (!passes_walls(mtmp->data) && !throws_rocks(mtmp->data))
X  				if (hmon(mtmp, obj, TRUE))
X  				    return FALSE;	/* still alive */
X- 				else
X- 				    bury_objs(x, y);	/* treasure, corpse */
X  		    } else
X  #ifdef POLYSELF
X  			if (!passes_walls(uasmon) && !throws_rocks(uasmon))
X--- 165,170 ----
X***************
X*** 193,198 ****
X--- 190,196 ----
X  		}
X  		deltrap(t);
X  		obfree(obj, (struct obj *)0);
X+ 		bury_objs(x, y);
X  		newsym(x,y);
X  		return TRUE;
X  	} else if (is_pool(x, y)) {
X***************
X*** 219,226 ****
X  	} else {
X  		pline("%s land%s on the altar.", Doname2(obj),
X  			(obj->quan == 1L) ? "s" : "");
X! 		if (obj->otyp != GOLD_PIECE)
X! 			obj->bknown = 1;
X  	}
X  }
X  
X--- 217,223 ----
X  	} else {
X  		pline("%s land%s on the altar.", Doname2(obj),
X  			(obj->quan == 1L) ? "s" : "");
X! 		obj->bknown = 1;
X  	}
X  }
X  
X***************
X*** 976,983 ****
X  		    if (enexto(&mm, mm.x, mm.y, &mons[PM_ANGEL])) {
X  			if ((mtmp = mk_roamer(&mons[PM_ANGEL], u.ualign.type,
X  					   mm.x, mm.y, TRUE)) != 0) {
X! 			    register struct obj *otmp =
X! 					   mksobj(SILVER_SABER, FALSE, FALSE);
X  
X  			    if (!Blind)
X  				pline("An angel appears near you.");
X--- 973,979 ----
X  		    if (enexto(&mm, mm.x, mm.y, &mons[PM_ANGEL])) {
X  			if ((mtmp = mk_roamer(&mons[PM_ANGEL], u.ualign.type,
X  					   mm.x, mm.y, TRUE)) != 0) {
X! 			    register struct obj *otmp;
X  
X  			    if (!Blind)
X  				pline("An angel appears near you.");
X***************
X*** 992,1000 ****
X  			    mtmp->m_lev = rn1(8,15);
X  			    mtmp->mhp = mtmp->mhpmax =
X  					d((int)mtmp->m_lev,10) + 30 + rnd(30);
X  			    bless(otmp);
X! 			    otmp->spe = 7;
X! 			    mpickobj(mtmp, otmp);
X  			}
X  		    }
X  		}
X--- 988,1006 ----
X  			    mtmp->m_lev = rn1(8,15);
X  			    mtmp->mhp = mtmp->mhpmax =
X  					d((int)mtmp->m_lev,10) + 30 + rnd(30);
X+ 			    if ((otmp = select_hwep(mtmp)) == 0) {
X+ 				otmp = mksobj(SILVER_SABER, FALSE, FALSE);
X+ 				mpickobj(mtmp, otmp);
X+ 			    }
X  			    bless(otmp);
X! 			    if (otmp->spe < 4) otmp->spe += rnd(4);
X! #ifdef MUSE
X! 			    if ((otmp = which_armor(mtmp, W_ARMS)) == 0
X! 			      || otmp->otyp != SHIELD_OF_REFLECTION) {
X! 				(void) mongets(mtmp, AMULET_OF_REFLECTION);
X! 				m_dowear(mtmp, TRUE);
X! 			    }
X! #endif
X  			}
X  		    }
X  		}
X*** /tmp/da20951	Mon Jul 12 17:32:04 1993
X--- src/do_wear.c	Wed Jul  7 16:24:13 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)do_wear.c	3.1	93/05/25	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)do_wear.c	3.1	93/06/24	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 64,71 ****
X  is_boots(otmp)
X  register struct obj *otmp;
X  {
X! 	return(otmp->otyp >= LOW_BOOTS &&
X! 		otmp->otyp <= LEVITATION_BOOTS);
X  }
X  
X  boolean
X--- 64,71 ----
X  is_boots(otmp)
X  register struct obj *otmp;
X  {
X! 	return((boolean)(otmp->otyp >= LOW_BOOTS &&
X! 		otmp->otyp <= LEVITATION_BOOTS));
X  }
X  
X  boolean
X***************
X*** 72,79 ****
X  is_helmet(otmp)
X  register struct obj *otmp;
X  {
X! 	return(otmp->otyp >= ELVEN_LEATHER_HELM &&
X! 		otmp->otyp <= HELM_OF_TELEPATHY);
X  }
X  
X  #endif /* OVLB */
X--- 72,79 ----
X  is_helmet(otmp)
X  register struct obj *otmp;
X  {
X! 	return((boolean)(otmp->otyp >= ELVEN_LEATHER_HELM &&
X! 		otmp->otyp <= HELM_OF_TELEPATHY));
X  }
X  
X  #endif /* OVLB */
X***************
X*** 83,90 ****
X  is_gloves(otmp)
X  register struct obj *otmp;
X  {
X! 	return(otmp->otyp >= LEATHER_GLOVES &&
X! 		otmp->otyp <= GAUNTLETS_OF_DEXTERITY);
X  }
X  
X  #endif /* OVL2 */
X--- 83,90 ----
X  is_gloves(otmp)
X  register struct obj *otmp;
X  {
X! 	return((boolean)(otmp->otyp >= LEATHER_GLOVES &&
X! 		otmp->otyp <= GAUNTLETS_OF_DEXTERITY));
X  }
X  
X  #endif /* OVL2 */
X***************
X*** 94,101 ****
X  is_cloak(otmp)
X  register struct obj *otmp;
X  {
X! 	return(otmp->otyp >= MUMMY_WRAPPING &&
X! 		otmp->otyp <= CLOAK_OF_DISPLACEMENT);
X  }
X  
X  boolean
X--- 94,101 ----
X  is_cloak(otmp)
X  register struct obj *otmp;
X  {
X! 	return((boolean)(otmp->otyp >= MUMMY_WRAPPING &&
X! 		otmp->otyp <= CLOAK_OF_DISPLACEMENT));
X  }
X  
X  boolean
X***************
X*** 102,109 ****
X  is_shield(otmp)
X  register struct obj *otmp;
X  {
X! 	return(otmp->otyp >= SMALL_SHIELD &&
X! 		otmp->otyp <= SHIELD_OF_REFLECTION);
X  }
X  
X  /*
X--- 102,109 ----
X  is_shield(otmp)
X  register struct obj *otmp;
X  {
X! 	return((boolean)(otmp->otyp >= SMALL_SHIELD &&
X! 		otmp->otyp <= SHIELD_OF_REFLECTION));
X  }
X  
X  /*
X***************
X*** 781,790 ****
X  donning(otmp)
X  register struct obj *otmp;
X  {
X!     return (otmp == uarmf && (afternmv == Boots_on || afternmv == Boots_off))
X  	|| (otmp == uarmh && (afternmv == Helmet_on || afternmv == Helmet_off))
X  	|| (otmp == uarmg && (afternmv == Gloves_on || afternmv == Gloves_off))
X! 	|| (otmp == uarm && (afternmv == Armor_on || afternmv == Armor_off));
X  }
X  
X  void
X--- 781,790 ----
X  donning(otmp)
X  register struct obj *otmp;
X  {
X!     return((boolean)((otmp == uarmf && (afternmv == Boots_on || afternmv == Boots_off))
X  	|| (otmp == uarmh && (afternmv == Helmet_on || afternmv == Helmet_off))
X  	|| (otmp == uarmg && (afternmv == Gloves_on || afternmv == Gloves_off))
X! 	|| (otmp == uarm && (afternmv == Armor_on || afternmv == Armor_off))));
X  }
X  
X  void
X***************
X*** 865,872 ****
X  		pline("The bear trap prevents you from pulling your %s out.",
X  		      body_part(FOOT));
X  	    else
X! 		You("are stuck in the floor, and cannot pull your %s out.",
X! 		     makeplural(body_part(FOOT)));
X  		return(0);
X  	}
X  	reset_remarm();			/* since you may change ordering */
X--- 865,872 ----
X  		pline("The bear trap prevents you from pulling your %s out.",
X  		      body_part(FOOT));
X  	    else
X! 		You("are stuck in the %s, and cannot pull your %s out.",
X! 		    surface(u.ux, u.uy), makeplural(body_part(FOOT)));
X  		return(0);
X  	}
X  	reset_remarm();			/* since you may change ordering */
X***************
X*** 1067,1084 ****
X  		}
X  		if(!err) mask = W_ARMS;
X  	} else if(is_boots(otmp)) {
X! 		   if(uarmf) {
X  			already_wearing("boots.");
X  			err++;
X! 		   } if (u.utrap && (u.utraptype == TT_BEARTRAP ||
X! 				     u.utraptype == TT_INFLOOR)) {
X! 		       if (u.utraptype == TT_BEARTRAP)
X! 			   Your("%s is trapped!", body_part(FOOT));
X! 		       else
X! 			   Your("%s are stuck in the floor!",
X! 				makeplural(body_part(FOOT)));
X! 		       err++;
X! 		   } else
X  			mask = W_ARMF;
X  	} else if(is_gloves(otmp)) {
X  		if(uarmg) {
X--- 1067,1085 ----
X  		}
X  		if(!err) mask = W_ARMS;
X  	} else if(is_boots(otmp)) {
X! 		if (uarmf) {
X  			already_wearing("boots.");
X  			err++;
X! 		} if (u.utrap && (u.utraptype == TT_BEARTRAP ||
X! 				  u.utraptype == TT_INFLOOR)) {
X! 			if (u.utraptype == TT_BEARTRAP)
X! 			    Your("%s is trapped!", body_part(FOOT));
X! 			else
X! 			    Your("%s are stuck in the %s!",
X! 				 makeplural(body_part(FOOT)),
X! 				 surface(u.ux, u.uy));
X! 			err++;
X! 		} else
X  			mask = W_ARMF;
X  	} else if(is_gloves(otmp)) {
X  		if(uarmg) {
X***************
X*** 1337,1343 ****
X  		/* changed so cursed weapons don't fall, GAN 10/30/86 */
X  		Your("%s %sslips from your %s.",
X  			is_sword(otmp) ? "sword" :
X! 				makesingular(oclass_names[otmp->oclass]),
X  			xfl ? "also " : "",
X  			makeplural(body_part(HAND)));
X  		setuwep((struct obj *)0);
X--- 1338,1344 ----
X  		/* changed so cursed weapons don't fall, GAN 10/30/86 */
X  		Your("%s %sslips from your %s.",
X  			is_sword(otmp) ? "sword" :
X! 				makesingular(oclass_names[(int)otmp->oclass]),
X  			xfl ? "also " : "",
X  			makeplural(body_part(HAND)));
X  		setuwep((struct obj *)0);
X***************
X*** 1614,1620 ****
X  	} else if((otmp = uarm) && (!atmp || atmp == uarm)) {
X  		/* may be disintegrated by spell or dragon breath... */
X  		if (donning(otmp)) cancel_don();
X! 		Your("armor turns to dust and falls to the floor!");
X  		(void) Armor_gone();
X  		useup(otmp);
X  #ifdef TOURIST
X--- 1615,1622 ----
X  	} else if((otmp = uarm) && (!atmp || atmp == uarm)) {
X  		/* may be disintegrated by spell or dragon breath... */
X  		if (donning(otmp)) cancel_don();
X! 		Your("armor turns to dust and falls to the %s!",
X! 			surface(u.ux,u.uy));
X  		(void) Armor_gone();
X  		useup(otmp);
X  #ifdef TOURIST
X*** /tmp/da20959	Mon Jul 12 17:32:07 1993
X--- src/dog.c	Wed Jul  7 16:55:05 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)dog.c	3.1	93/03/30	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)dog.c	3.1	93/06/19	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 195,200 ****
X--- 195,208 ----
X  			/* let monster move a bit on the new level */
X  			/* see placement code below */
X  			mtmp->mx = min(nmv, 8);
X+ #ifdef MULDGN
X+ 			/*	temporary hack...
X+ 			 * Ft.Ludios' entry chamber isn't classified as a
X+ 			 * room by lev_comp and any movement greater than
X+ 			 * 1 can result in placement beyond solid walls.
X+ 			 */
X+ 			if (Is_knox(&u.uz)) mtmp->mx = 1;
X+ #endif
X  
X  			if(!regenerates(mtmp->data)) nmv /= 20;
X  			if((long)mtmp->mhp + nmv >= (long)mtmp->mhpmax)
X***************
X*** 215,220 ****
X--- 223,229 ----
X  			home_shk(mtmp, TRUE);
X  		    else switch(mtmp->my) {
X  			xchar xlocale, ylocale;
X+ 			register struct trap *t;
X  
X  			case 1: xlocale = xupstair; ylocale = yupstair;
X  				goto common;
X***************
X*** 226,256 ****
X  				goto common;
X  			case 5: xlocale = sstairs.sx; ylocale = sstairs.sy;
X  				goto common;
X  common:
X! 				if (xlocale) {
X! 				    if(mtmp->mx) {
X! 					/* monster moved a bit */
X! 					/* pick a nearby location */
X! 					/* mnearto() deals w/stone, et al */
X  					int i, j;
X! 					char *rmlist = in_rooms(xlocale,
X! 								ylocale, 0);
X! 
X! 					if (rmlist) {
X! 					    xlocale = somex(
X! 						&rooms[*rmlist - ROOMOFFSET]);
X! 					    ylocale = somey(
X! 						&rooms[*rmlist - ROOMOFFSET]);
X! 					} else {
X! 					    i = max(1, xlocale - mtmp->mx);
X! 					    j = min(COLNO-1, xlocale+mtmp->mx);
X! 					    xlocale = rn1(j-i,i);
X! 
X! 					    i = max(0, ylocale - mtmp->mx);
X! 					    j = min(ROWNO-1, ylocale+mtmp->mx);
X! 					    ylocale = rn1(j-i,i);
X! 					}
X  				    }
X  				    (void) mnearto(mtmp,
X  						   xlocale, ylocale, FALSE);
X  				    break;
X--- 235,276 ----
X  				goto common;
X  			case 5: xlocale = sstairs.sx; ylocale = sstairs.sy;
X  				goto common;
X+ 			case 6:		/* portal */
X+ 				for (t = ftrap; t; t = t->ntrap)
X+ 				    if (t->ttyp == MAGIC_PORTAL) break;
X+ 				if (t) {
X+ 				    xlocale = t->tx;
X+ 				    ylocale = t->ty;
X+ 				} else {
X+ 				    if (!In_endgame(&u.uz))
X+ 			      impossible("losedogs: no corresponding portal?");
X+ 				    xlocale = ylocale = 0;
X+ 				}
X+ 				goto common;
X  common:
X! 				if (xlocale && mtmp->mx) {
X! 				    /* monster moved a bit */
X! 				    /* pick a nearby location */
X! 				    /* mnearto() deals w/stone, et al */
X! 				    char *r = in_rooms(xlocale, ylocale, 0);
X! 				    if (r && *r) {
X! 					coord c;
X! 					/* somexy() handles irregular rooms */
X! 					if (somexy(&rooms[*r - ROOMOFFSET], &c))
X! 					    xlocale = c.x,  ylocale = c.y;
X! 					else
X! 					    xlocale = ylocale = 0;
X! 				    } else {
X  					int i, j;
X! 					i = max(1, xlocale - mtmp->mx);
X! 					j = min(COLNO-1, xlocale + mtmp->mx);
X! 					xlocale = rn1(j - i, i);
X! 					i = max(0, ylocale - mtmp->mx);
X! 					j = min(ROWNO-1, ylocale + mtmp->mx);
X! 					ylocale = rn1(j - i, i);
X  				    }
X+ 				}
X+ 				if (xlocale) {
X  				    (void) mnearto(mtmp,
X  						   xlocale, ylocale, FALSE);
X  				    break;
X***************
X*** 309,316 ****
X  			set_residency(mtmp, TRUE);
X  
X  		if (mtmp->wormno) {
X  		    /* NOTE: worm is truncated to # segs = max wormno size */
X! 		    num_segs = min(count_wsegs(mtmp), MAX_NUM_WORMS - 1);
X  		    wormgone(mtmp);
X  		}
X  
X--- 329,338 ----
X  			set_residency(mtmp, TRUE);
X  
X  		if (mtmp->wormno) {
X+ 		    register int cnt;
X  		    /* NOTE: worm is truncated to # segs = max wormno size */
X! 		    cnt = count_wsegs(mtmp);
X! 		    num_segs = min(cnt, MAX_NUM_WORMS - 1);
X  		    wormgone(mtmp);
X  		}
X  
X***************
X*** 346,351 ****
X--- 368,374 ----
X  			 *	3: < ladder,
X  			 *	4: > ladder,
X  			 *	5: sstairs
X+ 			 *	6: portal
X  			 */ 
X  {
X          register struct obj *obj;
X***************
X*** 355,362 ****
X  	    set_residency(mtmp, TRUE);
X  
X  	if (mtmp->wormno) {
X  	  /* **** NOTE: worm is truncated to # segs = max wormno size **** */
X! 	    num_segs = min(count_wsegs(mtmp), MAX_NUM_WORMS - 1);
X  	    wormgone(mtmp);
X  	}
X  
X--- 378,387 ----
X  	    set_residency(mtmp, TRUE);
X  
X  	if (mtmp->wormno) {
X+ 	    register int cnt;
X  	  /* **** NOTE: worm is truncated to # segs = max wormno size **** */
X! 	    cnt = count_wsegs(mtmp);
X! 	    num_segs = min(cnt, MAX_NUM_WORMS - 1);
X  	    wormgone(mtmp);
X  	}
X  
X*** /tmp/da20975	Mon Jul 12 17:32:12 1993
X--- src/dokick.c	Thu Jul  1 14:06:55 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)dokick.c	3.1	93/05/14	*/
X  /* Copyright (c) Izchak Miller, Mike Stephenson, Steve Linhart, 1989. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)dokick.c	3.1	93/06/15	*/
X  /* Copyright (c) Izchak Miller, Mike Stephenson, Steve Linhart, 1989. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 344,350 ****
X  		for(otmp = kickobj->cobj; otmp; otmp = otmp2) {
X  			otmp2 = otmp->nobj;
X  			if (objects[otmp->otyp].oc_material == GLASS
X! 								&& !rn2(3)) {
X  				You("hear a muffled shatter.");
X  				if(costly) loss += stolen_value(otmp, x, y, 
X  					    (boolean)shkp->mpeaceful, TRUE);
X--- 344,350 ----
X  		for(otmp = kickobj->cobj; otmp; otmp = otmp2) {
X  			otmp2 = otmp->nobj;
X  			if (objects[otmp->otyp].oc_material == GLASS
X! 			    && !obj_resists(otmp, 33, 100)) {
X  				You("hear a muffled shatter.");
X  				if(costly) loss += stolen_value(otmp, x, y, 
X  					    (boolean)shkp->mpeaceful, TRUE);
X*** /tmp/da20984	Mon Jul 12 17:32:15 1993
X--- src/dothrow.c	Tue Jul  6 15:53:45 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)dothrow.c	3.1	93/05/15	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)dothrow.c	3.1	93/06/15	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 539,544 ****
X--- 539,553 ----
X  			return(gem_accept(mon, obj));
X  		}
X  	}
X+ #ifdef MULDGN
X+ 	/* don't make game unwinnable if naive player throws artifact
X+ 	   at leader.... */
X+ 	if (mon->data->msound == MS_LEADER && is_quest_artifact(obj)) {
X+ 		if (mon->mcanmove)
X+ 			pline("%s ignores %s.", Monnam(mon), the(xname(obj)));
X+ 		return(0);
X+ 	}
X+ #endif
X  	if(obj->oclass == WEAPON_CLASS || obj->otyp == PICK_AXE ||
X  	   obj->otyp == UNICORN_HORN || obj->oclass == GEM_CLASS) {
X  		if(obj->otyp < DART || obj->oclass == GEM_CLASS) {
X***************
X*** 695,700 ****
X--- 704,711 ----
X  register struct obj   *obj;
X  register boolean loose;		/* if not loose, obj is in fobj chain */
X  {
X+ 	if (obj_resists(obj, 1, 100)) return 0;
X+ 
X  	switch(obj->otyp) {
X  		case MIRROR:
X  			change_luck(-2);	/* and fall through */
X*** /tmp/da21001	Mon Jul 12 17:32:20 1993
X--- src/dungeon.c	Wed Jul  7 16:24:18 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)dungeon.c	3.1	93/01/17	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)dungeon.c	3.1	93/06/26	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 8,14 ****
X  #ifdef OVL1
X  
X  #define	DUNGEON_FILE	"dungeon"
X! #if defined(MICRO) && !defined(AMIGA)
X  # define RDMODE "rb"
X  #else
X  # define RDMODE "r"
X--- 8,14 ----
X  #ifdef OVL1
X  
X  #define	DUNGEON_FILE	"dungeon"
X! #if (defined(MICRO) && !defined(AMIGA)) || defined(THINK_C)
X  # define RDMODE "rb"
X  #else
X  # define RDMODE "r"
X***************
X*** 182,190 ****
X  	    if (!strcmp(dungeons[i].dname, s)) return i;
X  
X  	panic("Couldn't resolve dungeon number for name \"%s\".", s);
X! #if defined(LINT) || defined(GCC_WARN)
X  	return (xchar)0;
X- #endif
X  }
X  
X  s_level *
X--- 182,189 ----
X  	    if (!strcmp(dungeons[i].dname, s)) return i;
X  
X  	panic("Couldn't resolve dungeon number for name \"%s\".", s);
X! 	/*NOT REACHED*/
X  	return (xchar)0;
X  }
X  
X  s_level *
X***************
X*** 233,241 ****
X  		return(pdnum);
X  
X  	panic("parent_dnum: couldn't resolve branch.");
X! #if defined(LINT) || defined(GCC_WARN)
X  	return (xchar)0;
X- #endif
X  }
X  
X  /*
X--- 232,239 ----
X  		return(pdnum);
X  
X  	panic("parent_dnum: couldn't resolve branch.");
X! 	/*NOT REACHED*/
X  	return (xchar)0;
X  }
X  
X  /*
X***************
X*** 856,862 ****
X  ledger_no(lev)
X  d_level	*lev;
X  {
X! 	return(lev->dlevel + dungeons[lev->dnum].ledger_start);
X  }
X  
X  /*
X--- 854,860 ----
X  ledger_no(lev)
X  d_level	*lev;
X  {
X! 	return((xchar)(lev->dlevel + dungeons[lev->dnum].ledger_start));
X  }
X  
X  /*
X***************
X*** 881,892 ****
X  ledger_to_dnum(ledgerno)
X  xchar	ledgerno;
X  {
X! 	xchar	i;
X  
X! 	for(i = 0; i < n_dgns; i++)
X! 	    if(dungeons[i].ledger_start >= ledgerno) return(i-1);
X  
X! 	return(MAXDUNGEON);
X  }
X  
X  /* return the level of the dungeon this ledgerno exists in */
X--- 879,895 ----
X  ledger_to_dnum(ledgerno)
X  xchar	ledgerno;
X  {
X! 	register int i;
X  
X! 	/* find i such that (i->base + 1) <= ledgerno <= (i->base + i->count) */
X! 	for (i = 0; i < n_dgns; i++)
X! 	    if (dungeons[i].ledger_start < ledgerno &&
X! 		ledgerno <= dungeons[i].ledger_start + dungeons[i].num_dunlevs)
X! 		return (xchar)i;
X  
X! 	panic("level number out of range [ledger_to_dnum(%d)]", (int)ledgerno);
X! 	/*NOT REACHED*/
X! 	return (xchar)0;
X  }
X  
X  /* return the level of the dungeon this ledgerno exists in */
X***************
X*** 894,900 ****
X  ledger_to_dlev(ledgerno)
X  xchar	ledgerno;
X  {
X! 	return(ledgerno - dungeons[ledger_to_dnum(ledgerno)].ledger_start);
X  }
X  
X  #endif /* OVL1 */
X--- 897,903 ----
X  ledger_to_dlev(ledgerno)
X  xchar	ledgerno;
X  {
X! 	return((xchar)(ledgerno - dungeons[ledger_to_dnum(ledgerno)].ledger_start));
X  }
X  
X  #endif /* OVL1 */
X***************
X*** 906,912 ****
X  depth(lev)
X  d_level	*lev;
X  {
X! 	return dungeons[lev->dnum].depth_start + lev->dlevel - 1;
X  }
X  
X  boolean
X--- 909,915 ----
X  depth(lev)
X  d_level	*lev;
X  {
X! 	return((schar)( dungeons[lev->dnum].depth_start + lev->dlevel - 1));
X  }
X  
X  boolean
X***************
X*** 913,919 ****
X  on_level(lev1, lev2)	/* are "lev1" and "lev2" actually the same? */
X  d_level	*lev1, *lev2;
X  {
X! 	return((lev1->dnum == lev2->dnum) && (lev1->dlevel == lev2->dlevel));
X  }
X  
X  #endif /* OVL0 */
X--- 916,922 ----
X  on_level(lev1, lev2)	/* are "lev1" and "lev2" actually the same? */
X  d_level	*lev1, *lev2;
X  {
X! 	return((boolean)((lev1->dnum == lev2->dnum) && (lev1->dlevel == lev2->dlevel)));
X  }
X  
X  #endif /* OVL0 */
X***************
X*** 1034,1044 ****
X  On_stairs(x, y)
X  xchar x, y;
X  {
X! 	return((x == xupstair && y == yupstair) ||
X  	       (x == xdnstair && y == ydnstair) ||
X  	       (x == xdnladder && y == ydnladder) ||
X  	       (x == xupladder && y == yupladder) ||
X! 	       (x == sstairs.sx && y == sstairs.sy));
X  }
X  
X  boolean
X--- 1037,1047 ----
X  On_stairs(x, y)
X  xchar x, y;
X  {
X! 	return((boolean)((x == xupstair && y == yupstair) ||
X  	       (x == xdnstair && y == ydnstair) ||
X  	       (x == xdnladder && y == ydnladder) ||
X  	       (x == xupladder && y == yupladder) ||
X! 	       (x == sstairs.sx && y == sstairs.sy)));
X  }
X  
X  boolean
X***************
X*** 1045,1051 ****
X  Is_botlevel(lev)
X  d_level *lev;
X  {
X! 	return lev->dlevel == dungeons[lev->dnum].num_dunlevs;
X  }
X  
X  boolean
X--- 1048,1054 ----
X  Is_botlevel(lev)
X  d_level *lev;
X  {
X! 	return((boolean)(lev->dlevel == dungeons[lev->dnum].num_dunlevs));
X  }
X  
X  boolean
X***************
X*** 1052,1059 ****
X  Can_dig_down(lev)
X  d_level *lev;
X  {
X! 	return !level.flags.hardfloor
X! 	    && !Is_botlevel(lev) && !Invocation_lev(lev);
X  }
X  
X  /*
X--- 1055,1062 ----
X  Can_dig_down(lev)
X  d_level *lev;
X  {
X! 	return((boolean)(!level.flags.hardfloor
X! 	    && !Is_botlevel(lev) && !Invocation_lev(lev)));
X  }
X  
X  /*
X***************
X*** 1065,1071 ****
X  Can_fall_thru(lev)
X  d_level *lev;
X  {
X! 	return Can_dig_down(lev) || Is_stronghold(lev);
X  }
X  
X  /*
X--- 1068,1074 ----
X  Can_fall_thru(lev)
X  d_level *lev;
X  {
X! 	return((boolean)(Can_dig_down(lev) || Is_stronghold(lev)));
X  }
X  
X  /*
X***************
X*** 1078,1087 ****
X  Can_rise_up(lev)
X  d_level *lev;
X  {
X!     return !In_endgame(lev) &&
X  	(lev->dlevel > 1 ||
X  	 (dungeons[lev->dnum].entry_lev == 1 && ledger_no(lev) != 1 &&
X! 	  sstairs.sx && sstairs.up));
X  }
X  
X  /*
X--- 1081,1090 ----
X  Can_rise_up(lev)
X  d_level *lev;
X  {
X!     return((boolean)(!In_endgame(lev) &&
X  	(lev->dlevel > 1 ||
X  	 (dungeons[lev->dnum].entry_lev == 1 && ledger_no(lev) != 1 &&
X! 	  sstairs.sx && sstairs.up))));
X  }
X  
X  /*
X***************
X*** 1151,1157 ****
X  In_quest(lev)	/* are you in the quest dungeon? */
X  d_level *lev;
X  {
X! 	return(lev->dnum == quest_dnum);
X  }
X  #endif /* MULDGN */
X  
X--- 1154,1160 ----
X  In_quest(lev)	/* are you in the quest dungeon? */
X  d_level *lev;
X  {
X! 	return((boolean)(lev->dnum == quest_dnum));
X  }
X  #endif /* MULDGN */
X  
X***************
X*** 1163,1169 ****
X  In_mines(lev)	/* are you in the mines dungeon? */
X  d_level	*lev;
X  {
X! 	return(lev->dnum == mines_dnum);
X  }
X  
X  /*
X--- 1166,1172 ----
X  In_mines(lev)	/* are you in the mines dungeon? */
X  d_level	*lev;
X  {
X! 	return((boolean)(lev->dnum == mines_dnum));
X  }
X  
X  /*
X***************
X*** 1207,1213 ****
X      branch *br;
X  
X      br = dungeon_branch(s);
X!     return on_level(&u.uz, &br->end1) ? TRUE : FALSE;
X  }
X  #endif /* MULDGN */
X  
X--- 1210,1216 ----
X      branch *br;
X  
X      br = dungeon_branch(s);
X!     return((boolean)(on_level(&u.uz, &br->end1) ? TRUE : FALSE));
X  }
X  #endif /* MULDGN */
X  
X***************
X*** 1215,1221 ****
X  In_tower(lev)	/* are you inside the tower? */
X  d_level	*lev;
X  {
X! 	return(lev->dnum == tower_dnum);
X  }
X  
X  #endif /* OVL1 */
X--- 1218,1224 ----
X  In_tower(lev)	/* are you inside the tower? */
X  d_level	*lev;
X  {
X! 	return((boolean)(lev->dnum == tower_dnum));
X  }
X  
X  #endif /* OVL1 */
X***************
X*** 1225,1231 ****
X  In_hell(lev)	/* are you in one of the Hell levels? */
X  d_level	*lev;
X  {
X! 	return(dungeons[lev->dnum].flags.hellish);
X  }
X  
X  #endif /* OVL0 */
X--- 1228,1234 ----
X  In_hell(lev)	/* are you in one of the Hell levels? */
X  d_level	*lev;
X  {
X! 	return((boolean)(dungeons[lev->dnum].flags.hellish));
X  }
X  
X  #endif /* OVL0 */
X***************
X*** 1291,1298 ****
X  Invocation_lev(lev)
X  d_level *lev;
X  {
X! 	return(In_hell(lev) &&
X! 		lev->dlevel == (dungeons[lev->dnum].num_dunlevs - 1));
X  }
X  
X  /* use instead of depth() wherever a degree of difficulty is made
X--- 1294,1301 ----
X  Invocation_lev(lev)
X  d_level *lev;
X  {
X! 	return((boolean)(In_hell(lev) &&
X! 		lev->dlevel == (dungeons[lev->dnum].num_dunlevs - 1)));
X  }
X  
X  /* use instead of depth() wherever a degree of difficulty is made
X***************
X*** 1302,1308 ****
X  level_difficulty()
X  {
X  	if (In_endgame(&u.uz))
X! 		return((xchar) depth(&sanctum_level) + u.ulevel/2);
X  	else
X  		if (u.uhave.amulet)
X  			return(deepest_lev_reached(FALSE));
X--- 1305,1311 ----
X  level_difficulty()
X  {
X  	if (In_endgame(&u.uz))
X! 		return((xchar)(depth(&sanctum_level) + u.ulevel/2));
X  	else
X  		if (u.uhave.amulet)
X  			return(deepest_lev_reached(FALSE));
X*** /tmp/da21010	Mon Jul 12 17:32:24 1993
X--- src/eat.c	Mon Jul 12 13:45:04 1993
X***************
X*** 103,109 ****
X  		return TRUE;
X  	if (u.umonnum == PM_GELATINOUS_CUBE && is_organic(obj))
X  		return TRUE;
X! 	return !!index(comestibles, obj->oclass);
X  }
X  # endif /* POLYSELF */
X  #endif /* OVL1 */
X--- 103,109 ----
X  		return TRUE;
X  	if (u.umonnum == PM_GELATINOUS_CUBE && is_organic(obj))
X  		return TRUE;
X! 	return((boolean)(!!index(comestibles, obj->oclass)));
X  }
X  # endif /* POLYSELF */
X  #endif /* OVL1 */
X***************
X*** 956,963 ****
X  
X  #ifdef POLYSELF
X  	if (metallivorous(uasmon)) {
X! 		You("bite right into the metal tin....");
X  		tmp = 1;
X  	} else
X  #endif
X  	if (otmp->blessed) {
X--- 956,966 ----
X  
X  #ifdef POLYSELF
X  	if (metallivorous(uasmon)) {
X! 		You("bite right into the metal tin...");
X  		tmp = 1;
X+ 	} else if (nolimbs(uasmon)) {
X+ 		You("cannot handle the tin properly to open it.");
X+ 		return;
X  	} else
X  #endif
X  	if (otmp->blessed) {
X***************
X*** 1718,1724 ****
X  boolean
X  is_fainted()
X  {
X! 	return(u.uhs == FAINTED);
X  }
X  
X  void
X--- 1721,1727 ----
X  boolean
X  is_fainted()
X  {
X! 	return((boolean)(u.uhs == FAINTED));
X  }
X  
X  void
X***************
X*** 1832,1840 ****
X   * in inventory.
X   */
X  struct obj *
X! floorfood(verb,corpseonly)	/* get food from floor or pack */
X  	const char *verb;
X! 	boolean corpseonly;
X  {
X  	register struct obj *otmp;
X  	char qbuf[QBUFSZ];
X--- 1835,1843 ----
X   * in inventory.
X   */
X  struct obj *
X! floorfood(verb,corpsecheck)	/* get food from floor or pack */
X  	const char *verb;
X! 	int corpsecheck; /* 0, no check, 1, corpses, 2, tinnable corpses */
X  {
X  	register struct obj *otmp;
X  	char qbuf[QBUFSZ];
X***************
X*** 1859,1865 ****
X  	if (!(Levitation && !Is_airlevel(&u.uz)  && !Is_waterlevel(&u.uz))
X  	    && !u.uswallow) {
X  	    for(otmp = level.objects[u.ux][u.uy]; otmp; otmp = otmp->nexthere) {
X! 		if(corpseonly ? otmp->otyp==CORPSE :
X  #ifdef POLYSELF
X  		    feeding ? (otmp->oclass != GOLD_CLASS && is_edible(otmp)) :
X  #endif
X--- 1862,1869 ----
X  	if (!(Levitation && !Is_airlevel(&u.uz)  && !Is_waterlevel(&u.uz))
X  	    && !u.uswallow) {
X  	    for(otmp = level.objects[u.ux][u.uy]; otmp; otmp = otmp->nexthere) {
X! 		if(corpsecheck ?
X! 		(otmp->otyp==CORPSE && (corpsecheck == 1 || tinnable(otmp))) :
X  #ifdef POLYSELF
X  		    feeding ? (otmp->oclass != GOLD_CLASS && is_edible(otmp)) :
X  #endif
X*** /tmp/da21019	Mon Jul 12 17:32:28 1993
X--- src/end.c	Thu Jul  8 13:53:35 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)end.c	3.1	93/05/29	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)end.c	3.1	93/06/30	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 18,23 ****
X--- 18,27 ----
X  static void NDECL(list_vanquished);
X  static void NDECL(list_genocided);
X  
X+ #ifdef AMIGA
X+ void NDECL(clear_icon);
X+ #endif
X+ 
X  /*
X   * The order of these needs to match the macros in hack.h.
X   */
X***************
X*** 382,387 ****
X--- 386,392 ----
X  		return;
X  	}
X  #endif
X+ 	if (how < PANICKED) u.umortality++;
X  	if (Lifesaved && how <= GENOCIDED) {
X  		pline("But wait...");
X  		makeknown(AMULET_OF_LIFE_SAVING);
X***************
X*** 684,690 ****
X  		    for (obj = box->cobj; obj; obj = obj->nobj) {
X  			if (identified) {
X  			    makeknown(obj->otyp);
X! 			    obj->known = obj->bknown = obj->dknown = 1;
X  			}
X  			putstr(tmpwin, 0, doname(obj));
X  		    }
X--- 689,696 ----
X  		    for (obj = box->cobj; obj; obj = obj->nobj) {
X  			if (identified) {
X  			    makeknown(obj->otyp);
X! 			    obj->known = obj->bknown =
X! 			    obj->dknown = obj->rknown = 1;
X  			}
X  			putstr(tmpwin, 0, doname(obj));
X  		    }
END_OF_FILE
if test 53393 -ne `wc -c <'patches03a'`; then
    echo shar: \"'patches03a'\" unpacked with wrong size!
fi
# end of 'patches03a'
if test -f 'sys/amiga/amifont8.uu' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'sys/amiga/amifont8.uu'\" to \"'sys/amiga/amifont8.uu.orig'\"
  mv -f 'sys/amiga/amifont8.uu' 'sys/amiga/amifont8.uu.orig'
fi
echo shar: Extracting \"'sys/amiga/amifont8.uu'\" \(3490 characters\)
sed "s/^X//" >'sys/amiga/amifont8.uu' <<'END_OF_FILE'
Xbegin 644 8
XM```#\P`````````!``````````````)E```#Z0```F5P_TYU```````````,
XM`````!H/@``!``````````````````````````````````````````!&140`
XM```````````,`````!H`````"20`"`!```@`!@`!```@_P```&X`M```!@X`
XM```````````8;&P8`#@8##````````,\&#P\''X<?CP\```,`#`\?!C\//C^
XM_CQF?@[F\(+&./PX_#Q^9L/&P\/^/,`\$``8`.``#@`<`.`8!N`X````````
XM``@````````.&'!RS.?BY^?EY^?GY^?GY.?AY^?__\,8`&;GY^?GY^3GX>?G
XMYVH```!J:A@````8&!@``!@88L!6`%96```8`!@8`*@5P8.BP:@5YP/_[W_^
XM````P,```P`\;&P^QFP8&!AF&`````9F.&9F/&`P9F9F&!@8`!AFQCQF9FQF
XM9F9F&`9F8,;F;&9L9F9:9L/&9L/&,&`,.``8`&``!@`V`&```&`8````````
XM`!@````````8&!B<,Z6BH:&EI*2AI:6EI*2AI*3__\,8`&:DH:6EI:2DH:2D
XMI58```!65CP````8&!@``!@\96-J`&IJ```8`!@8UB/$`\`C+"O4A`/_]Y_Y
XM````P,```P`\`/Y@S&@P,`P\&`````QN&`8&;'Q@!F9F&!@P?@P&WCQFP&9@
XM8,!F&`9L8.[VQF;&9G`89F;&/&:,,#`,;``,/&P\-CPP.VPX!F889GP\W#WL
XM/CYF9F-C9GX8&!@`S.7BY^?GY^?AY^?GY^3GY^?_`.<8`,/GX>?GY^?DY^?G
XMY6K_#_!KZCP````8&!@``!AF8#97_];7`&8<`#@\;&I6)F1I/&F6YP./]]_[
XM#__PP,```P`8`&P\&'8`,`S_?@!^`!A^&!P<S`9\##P^``!@``8,WF9\P&9X
XM>,Y^&`9X8/[>QGS&?#@89F;6&#P8,!@,Q@``!G9F;F9X9G88!FP8=V9F9F9V
XM8!AF9FLV9DQP&`X`,Z6BI*&AH:6AI:&EI:2EI*3_`.<8_P`E(24A)24D)20D
XMI595/5Q55F;_#_`/\/\``-O#?AMJ5:JJ```?__C_JIPY:];X*]I;A`-F[\_S
XM.``<P&``!@`8`/X&,-P`,`P\&````#!V&#`&_@9F&&8&```P``P8WGYFP&9@
XM8,9F&&9L8M;.QF#&;`X89CS^/!@R,`P,````'F9@9GXP9F88!G@8:V9F9F9F
XM/!AF9FL<9A@8&!@`S.?BY^?AY^?AY^'EY^?GY^3_`.<8_P`G(2<A)2<G)R<D
XMIVJJ:JHZK&8`&!@``!@``,/;9NQ5JE95&``</#@`;&O6G#DK^#?LYP/Q[_//
XM8``&P#@`'````&Q\9LP`&!AF&!@`&&!F&&9F#&9F&&8,&!@8?A@`P,-F9FQF
XM8&9F&&9F9L;&;&!L9F889CSN9AAF,`8,````9F9F9F`P/&88!FP88V9F?#Y@
XM!AIF/#8V/#(8&!@`,P````````````````````#_`.<8`,,`````````````
XM`%;_5=8/\,,`&!@``!AS`&889C9KU^K_```8&!@`UB9D:E8\:;0M``/_W_O?
XMP``#P`__\``8`&P8QG8`##```!@`&,`\?GX\'CP\&#PX&!@,`#`8>,/\//C^
XM\#YF?CSF_L;&./`\XSP\/AC&PSS^/`,\````.SP\.SQXQN8\9N8\8V8\8`;P
XM?`P[&#9C&'X.&'``S`````````````````````#__\,8`&8`````````````
XM`&H`:VH``,,`&!@``!B<&#P89F-6:E8``&88&!@`K`/`(\0L(T&"``/_W_F?
XMP``#P````````````````````#```````````````````#``````````````
XM```````````````&`````````````````/X`````````?```/```````\`<`
XM````````<```````,P````````````````````#__\,8`&8`````````````
XM`%8`5E8`````&!@``!@``!@8`,!J5FH````8&!@``,&#J!7!HL&#``/_[_Y_
XMP``#P`````````@`"``(`!``"``8``@`(``(`"@`"``P``@`.``(`$``"`!(
XM``@`4``(`%@`"`!@``@`:``(`'``"`!X``@`@``(`(@`"`"0``@`F``(`*``
XM"`"H``@`L``(`+@`"`#```@`R``(`-``"`#8``@`X``(`.@`"`#P``@`^``(
XM`0``"`$(``@!$``(`1@`"`$@``@!*``(`3``"`$X``@!0``(`4@`"`%0``@!
XM6``(`6``"`%H``@!<``(`7@`"`&```@!B``(`9``"`&8``@!H``(`:@`"`&P
XM``@!N``(`<``"`'(``@!T``(`=@`"`'@``@!Z``(`?``"`'X``@"```(`@@`
XM"`(0``@"&``(`B``"`(H``@",``(`C@`"`)```@"2``(`E``"`)8``@"8``(
XM`F@`"`)P``@">``(`H``"`*(``@"D``(`I@`"`*@``@"J``(`K``"`*X``@"
XMP``(`L@`"`+0``@"V``(`N``"`+H``@"\``(`O@`"`,```@#"``(`Q``"`,8
XM``@#(``(`R@`"`,P``@#.``(`T``"`-(``@#4``(`U@`"`-@``@#:``(`W``
XM"`-X``@#@``(`X@`"`.0``@#F``(`Z``"`.H``@#L``(`[@`"`/```@#R``(
XM`]``"`/8``@#X``(`^@`"`/P``@#^``(!```"``(``@`$``(`!@`"``@``@`
XM*``(`#``"``X``@`0``(`$@`"`!0``@`6``(`&``"`!H``@`<``(`'@`"`"`
XM``@`B``(`)``"`"8``@`H``(`*@`"`"P``@`N``(`,``"`#(``@`T``(`-@`
XM"`#@``@`Z``(`/``"`#X``@$"``(!!``"`08``@$(``(!"@`"`0P``@#J``(
XM!#@`"`.8``@$0``(!$@`"`10``@$6``(!&``"`1H``@$<``(!'@`"`2```@$
XMB``(!)``"`28``@$H``(!*@`"`2P``@$N``(!,``"`3(``@!V``(`>``"`'H
XM``@!\``(`?@`"`(```@$T``(!-@`"`3@``@$Z``(!/``"`3X``@%```(!0@`
XM"`40``@%&``(!2``"`4H``@%,``(!3@`"`5```@%2``(!5``"`58``@%8``(
XM!6@`"`5P``@%>``(!8``"`6(``@%D``(!9@`"`+8``@"X``(`N@`"`+P``@"
XM^``(````"``````#[`````0`````````#@```$0```!<````8@````````/R
X`
Xend
END_OF_FILE
if test 3490 -ne `wc -c <'sys/amiga/amifont8.uu'`; then
    echo shar: \"'sys/amiga/amifont8.uu'\" unpacked with wrong size!
fi
# end of 'sys/amiga/amifont8.uu'
echo shar: End of archive 5 \(of 18\).
cp /dev/null ark5isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 18 archives.
    echo "Now execute ./patchit3.sh"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
