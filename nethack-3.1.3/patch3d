Path: uunet!news.tek.com!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v18i037:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Patch3d/18
Date: 20 Jul 1993 22:32:27 GMT
Organization: Tektronix, Inc, Redmond, OR, USA
Lines: 1780
Approved: billr@saab.CNA.TEK.COM
Message-ID: <22hrpr$9pr@ying.cna.tek.com>
NNTP-Posting-Host: saab.cna.tek.com
Xref: uunet comp.sources.games:1837

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 18, Issue 37
Archive-name: nethack31/patch3d
Patch-To: nethack31: Volume 16, Issue 1-116
Environment: Amiga, Atari, Mac, MS-DOS, Windows-NT, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 4 (of 18)."
# Contents:  patches03e sys/msdos/msdos.hlp
# Wrapped by billr@saab on Tue Jul 20 14:57:19 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'patches03e' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'patches03e'\" to \"'patches03e.orig'\"
  mv -f 'patches03e' 'patches03e.orig'
fi
echo shar: Extracting \"'patches03e'\" \(53675 characters\)
sed "s/^X//" >'patches03e' <<'END_OF_FILE'
X*** /tmp/da22173	Mon Jul 12 17:39:27 1993
X--- sys/msdos/Install.dos	Mon Jul 12 14:10:02 1993
X***************
X*** 1,13 ****
X! 	SCCS Id: @(#)Install.dos	 3.1		93/05/10
X  
X          Copyright (c) NetHack PC Development Team 1990 - 1993.
X!         NetHack may be freely redistributed.  See license for details.
X! 	    ======================================================
X!             Instructions for compiling and installing
X!                  NetHack 3.1 on an MS-DOS system
X! 	    ======================================================
X!                  (or, How to make PC NetHack 3.1)
X!                     Last revision: May 10, 1993
X  
X  Credit for a runnable full PC NetHack 3.1 goes to the PC Development team
X  of Norm Meluch, Kevin Smolkowski, Paul Winner, Michael Allison and Steve
X--- 1,13 ----
X! 	SCCS Id: @(#)Install.dos	 3.1		93/07/07
X  
X          Copyright (c) NetHack PC Development Team 1990 - 1993.
X!        NetHack may be freely redistributed.  See license for details.
X!        ==============================================================
X!               Instructions for compiling and installing
X!                     NetHack 3.1 on an MS-DOS system
X!          ======================================================
X!                   (or, How to make PC NetHack 3.1)
X!                      Last revision: July 11, 1993
X  
X  Credit for a runnable full PC NetHack 3.1 goes to the PC Development team
X  of Norm Meluch, Kevin Smolkowski, Paul Winner, Michael Allison and Steve
X***************
X*** 25,40 ****
X  
X      Microsoft C 6.0a
X      Microsoft C 7.0 and Microsoft Visual C++ Professional (MSVC) 1.0
X!     DJGPP       1.9   (gcc version 2.2 for msdos,
X!                        free from your local archive sites)
X  
X      For specific details concerning each compiler, please see the
X      corresponding appendix.
X  
X      All the makefiles were created for use with NDMAKE.  The make programs
X!     provided by the various vendors all seem to lack necessary features.
X      NDMAKE is available free from your local archive site.
X  
X      You may find it useful to obtain copies of lex (flex) and yacc (bison).
X      While not strictly necessary to compile nethack, they are required should
X      you desire to make any changes to the level and dungeon compilers.
X--- 25,44 ----
X  
X      Microsoft C 6.0a
X      Microsoft C 7.0 and Microsoft Visual C++ Professional (MSVC) 1.0
X!     DJGPP       1.9 or later
X  
X      For specific details concerning each compiler, please see the
X      corresponding appendix.
X  
X      All the makefiles were created for use with NDMAKE.  The make programs
X!     provided by the various vendors all seem to lack necessary features,
X!     or differ enough in their syntax that the supplied makefiles won't
X!     work.  That is the case with 'nmake' supplied with the MSC compiler.  
X      NDMAKE is available free from your local archive site.
X  
X+     If you want to build a copy of NetHack that is identical to the
X+     "official binaries", please see appendix A.
X+ 
X      You may find it useful to obtain copies of lex (flex) and yacc (bison).
X      While not strictly necessary to compile nethack, they are required should
X      you desire to make any changes to the level and dungeon compilers.
X***************
X*** 73,79 ****
X      termcap.zip.  termcap.zip contains several files of termcap routines.
X      Using them with NetHack involves very little knowledge of the UNIX concept
X      of a termcap database; mostly you need to know enough to set a TERM
X!     environment variable.  You can unzip termcap.zip in the sys/msdos
X      directory, but if you are going to use it, it is probably better to
X      unzip a copy in a special directory and copy the library files to where
X      your linker can find them.
X--- 77,83 ----
X      termcap.zip.  termcap.zip contains several files of termcap routines.
X      Using them with NetHack involves very little knowledge of the UNIX concept
X      of a termcap database; mostly you need to know enough to set a TERM
X!     environment variable.  You can unzip termcap.zip in the sys/share
X      directory, but if you are going to use it, it is probably better to
X      unzip a copy in a special directory and copy the library files to where
X      your linker can find them.
X***************
X*** 83,88 ****
X--- 87,96 ----
X      and generates termcap.lib, Makegcc.lib works with DJGPP and generates
X      libtermc.a.
X  
X+     Note that you only need the termcap library if you have changed 
X+     pcconf.h to define TERMLIB, and commented out the #define NO_TERMS 
X+     (See point 6).
X+ 
X  4.  ovlmgr.uu (MS-DOS overlay manager) is the uuencoded assembled
X      object module for the overlay manager used with Microsoft C 6.0
X      and older.  This file is provided in case you do not have an assembler
X***************
X*** 104,117 ****
X  
X      First check config.h according to the comments to match your system and
X      desired set of features.  Mostly you need to check the WIZARD option,
X!     make sure the HACKDIR is set properly, and check TERMLIB and COMPRESS.
X  
X      We've managed to enable all the special features.  You may include all
X!     or as few of them as you wish.
X  
X      Also check pcconf.h, which should not need much editing (if you are
X!     including termcap.uu and random.c).  If you are not including random.c
X!     you will need to comment out RANDOM. 
X  
X      There are several options available for screen management with this
X      release of PC NetHack.  The features #define TERMLIB, #define
X--- 112,128 ----
X  
X      First check config.h according to the comments to match your system and
X      desired set of features.  Mostly you need to check the WIZARD option,
X!     make sure the HACKDIR is set properly or disabled, and check TERMLIB
X!     and COMPRESS.
X  
X      We've managed to enable all the special features.  You may include all
X!     or as few of them as you wish.  To conserve disk space, you may wish
X!     to disable LOGFILE and NEWS.
X  
X      Also check pcconf.h, which should not need much editing (if you are
X!     including random.c, and if you do not require termcap for screen
X!     management).  If you are not including random.c you will need to 
X!     comment out RANDOM. 
X  
X      There are several options available for screen management with this
X      release of PC NetHack.  The features #define TERMLIB, #define
X***************
X*** 118,139 ****
X      ANSI_DEFAULT, and #define NO_TERMS in pcconf.h control the various
X      options.
X  
X!     Commenting out the #define TERMLIB in pcconf.h to disable use of termcap
X!     routines means relying on either the ANSI_DEFAULT feature, or the
X!     NO_TERMS feature, and will make your job a bit easier.
X!     You can elect to compile with both TERMLIB and ANSI_DEFAULT
X!     and simply not set your TERM variable if you do not wish to use the
X!     termcap file settings.  The NO_TERMS feature has the advantage of not
X!     needing the DEVICE=ANSI.SYS statement in config.sys.  It will not
X!     work with TERMLIB, nor with ANSI_DEFAULT.  It uses internal routines 
X!     for screen management, and may be an ideal choice if your
X!     play machine is industry standard (has an IBM compatible BIOS).
X  
X!     Should you define NO_TERMS, only define one of the two screen
X!     access methods.  If compiling for Microsoft machines, use
X!     SCREEN_BIOS, if using DJGPP you can choose between SCREEN_BIOS
X      and SCREEN_DJGPPFAST.  Never, never, ever choose both.  Bad things
X      will happen.
X      
X      If you are using a Microsoft compiler you should make doubly certain
X      that OVERLAY is defined in pcconf.h, since otherwise things will 
X--- 129,157 ----
X      ANSI_DEFAULT, and #define NO_TERMS in pcconf.h control the various
X      options.
X  
X!     The NO_TERMS feature (the default) has the advantage of not needing the
X!     DEVICE=ANSI.SYS statement in config.sys.  The supplied sources and
X!     header files are distributed with support for NO_TERMS enabled.  
X!     NO_TERMS will not work with TERMLIB, nor with ANSI_DEFAULT defined.  
X!     The NO_TERMS feature uses internal routines for screen management, and 
X!     may be an ideal choice if your play machine is industry standard (has 
X!     an IBM compatible BIOS).
X  
X!     Should you choose to leave NO_TERMS defined, define only one of the two 
X!     screen access methods.  If compiling for Microsoft compilers, use
X!     SCREEN_BIOS; if using DJGPP, you can choose between SCREEN_BIOS
X      and SCREEN_DJGPPFAST.  Never, never, ever choose both.  Bad things
X      will happen.
X+ 
X+     If you leave the #define TERMLIB commented in pcconf.h to disable use
X+     of termcap routines, then your screen management must rely on either 
X+     the NO_TERMS feature described above, or the ANSI_DEFAULT feature.  
X+     Either of these will make your job a bit easier than if you choose to 
X+     use TERMLIB.  If you elect to include TERMLIB support, you may compile 
X+     with both TERMLIB and ANSI_DEFAULT, and simply not set your TERM variable 
X+     if you do not wish to use the termcap file settings.  You will need
X+     to uudecode the termcap library in sys\share if you are using the TERMLIB
X+     feature.  
X      
X      If you are using a Microsoft compiler you should make doubly certain
X      that OVERLAY is defined in pcconf.h, since otherwise things will 
X***************
X*** 154,164 ****
X      commenting out RANDOM in pcconf.h or tosconf.h, comment out (or set equal
X      to nothing) the RANDOM macro in your Makefile.
X  
X!     If you elected not to use termcap, then comment out (or set equal to
X!     nothing) the TERMLIB macro in your Makefile.
X      
X!     That is,    TERMLIB = (SSYS)\termlib.lib
X!     should be   TERMLIB =
X  
X      If you are recompiling after patching your sources, or if you got your
X      files from somewhere other than the official distribution, "touch
X--- 172,183 ----
X      commenting out RANDOM in pcconf.h or tosconf.h, comment out (or set equal
X      to nothing) the RANDOM macro in your Makefile.
X  
X!     If you elected to use termcap (TERMLIB defined), then uncomment the 
X!     TERMLIB macro in your Makefile that points to the location of the
X!     library.
X      
X!     That is,    TERMLIB =
X!     should be   TERMLIB = (SSYS)\termlib.lib
X  
X      If you are recompiling after patching your sources, or if you got your
X      files from somewhere other than the official distribution, "touch
X***************
X*** 184,189 ****
X--- 203,212 ----
X      termcap to your game directory.  Edit NetHack.cnf to reflect your
X      particular setup and personal preferences, by following the comments.
X  
X+     Also, make sure the file msdos.hlp made it to your game directory.
X+     If it didn't, move it from sys\msdos to your game directory
X+     yourself.
X+ 
X      If you'll be running NetHack from a different subdirectory, you will
X      want to "set HACKDIR=c:\games\nethack" (or whatever drive and directory 
X      you want to use) now.  Add it to your autoexec.bat (in DOS), as you'll
X***************
X*** 191,199 ****
X  
X  11. Play NetHack.  If it works, you're done!
X  
X  
X! Appendix A - Microsoft C Compilers
X  
X      You can compile NetHack using almost any version of Microsoft C later
X      than 5.1, including Microsoft Visual C++ Professional 1.0.  MSC Versions
X      5.0 and earlier are broken in such a way that it is impossible to use 
X--- 214,243 ----
X  
X  11. Play NetHack.  If it works, you're done!
X  
X+ Appendix A - Building the "offical binaries"
X  
X!     If you wish to build a copy of NetHack identical to the ones that
X!     the pc team distributes, observe the following:
X  
X+     For the binary built with Microsoft C 7.00, make no changes to
X+     any of the defines.  
X+ 
X+     For the 386 binary built with DJGPP, set the following
X+     - include/pcconf.h
X+       comment out #SCREEN_BIOS
X+       define SCREEN_DJGPPFAST
X+ 
X+     Make sure the following files have been converted from the
X+     unix style "^J" end of line, to the msdos style "^M^J":
X+       license, help, hh, termcap, history, cmdhelp wizhelp and
X+       nethack.cnf.
X+ 
X+     Uudecode nhico.uu nhpif.uu.
X+ 
X+     Place all the files in a clean directory and test.
X+ 
X+ Appendix B - Microsoft C Compilers
X+ 
X      You can compile NetHack using almost any version of Microsoft C later
X      than 5.1, including Microsoft Visual C++ Professional 1.0.  MSC Versions
X      5.0 and earlier are broken in such a way that it is impossible to use 
X***************
X*** 269,275 ****
X      The Microsoft Visual C++ Professional compiler can utilize the same
X      Makefiles and instructions for compiling as Microsoft C version 7.0.
X  
X! Appendix B - DJGPP Compiler (gcc ported to msdos)
X  
X      If you have a 386 or better machine, you are in luck.  You can compile
X      NetHack without spending money on a compiler.  DJGPP is available free
X--- 313,319 ----
X      The Microsoft Visual C++ Professional compiler can utilize the same
X      Makefiles and instructions for compiling as Microsoft C version 7.0.
X  
X! Appendix C - DJGPP Compiler (gcc ported to msdos)
X  
X      If you have a 386 or better machine, you are in luck.  You can compile
X      NetHack without spending money on a compiler.  DJGPP is available free
X***************
X*** 281,297 ****
X      dungeon compilers.  They should be available at the same place you got
X      djgpp.
X  
X!     The executable version of NetHack built with DJGPP runs in protected mode
X!     without overlays and is quite fast.  It cannot run under Microsoft
X!     Windows.  See the DJGPP documentation for more details on particular
X!     memory requirements.
X  
X      If you want to use the built-in DJGPP screen routines, uncomment
X      SCREEN_DJGPPFAST in pcconf.h.  Note that some of these routines
X!     seem to be broken so we pick and choose the ones that work.  See
X!     video.c for details. 
X  
X! Appendix C - Borland C Compiler
X  
X      NetHack will not compile at all with any version of Turbo C/C++.  It
X      has been made to compile with Borland C v2.0 after much work, but the
X--- 325,339 ----
X      dungeon compilers.  They should be available at the same place you got
X      djgpp.
X  
X!     The latest version of djgpp, 1.10, will produce a binary that will
X!     run under Microsoft Windows.
X  
X      If you want to use the built-in DJGPP screen routines, uncomment
X      SCREEN_DJGPPFAST in pcconf.h.  Note that some of these routines
X!     are broken under early versions of the compiler, so we pick and 
X!     choose the ones that work.  See video.c for details. 
X  
X! Appendix D - Borland C Compiler
X  
X      NetHack will not compile at all with any version of Turbo C/C++.  It
X      has been made to compile with Borland C v2.0 after much work, but the
X***************
X*** 331,337 ****
X         to convert the raw data files into game readable form.  If you
X         get errors then something is wrong.
X  
X! Appendix D - Microsoft C Compiler Warnings
X  
X      If you are using MSC for your compile with any of the /W levels set,
X      you can expect warnings.  The list below are those warnings that we
X--- 373,379 ----
X         to convert the raw data files into game readable form.  If you
X         get errors then something is wrong.
X  
X! Appendix E - Microsoft C Compiler Warnings
X  
X      If you are using MSC for your compile with any of the /W levels set,
X      you can expect warnings.  The list below are those warnings that we
X*** /tmp/da22197	Mon Jul 12 17:39:35 1993
X--- sys/msdos/MakeMSC.src	Mon Jul 12 13:51:23 1993
X***************
X*** 1,4 ****
X! # SCCS Id: @(#)MakeMSC.src	3.1	93/05/23
X  # Copyright (c) NetHack PC Development Team 1992, 1993
X  # PC NetHack 3.1 Makefile for Microsoft(tm) "C" >= 6.0ax and MSVC >= 1.0
X  #
X--- 1,4 ----
X! # SCCS Id: @(#)MakeMSC.src	3.1	93/07/11
X  # Copyright (c) NetHack PC Development Team 1992, 1993
X  # PC NetHack 3.1 Makefile for Microsoft(tm) "C" >= 6.0ax and MSVC >= 1.0
X  #
X***************
X*** 67,73 ****
X  # command line exceeds the MSDOS 128 character limit.
X  #
X  CFLAGS	= /c
X! LFLAGS	= /noi /seg:512 /map /st:5120 /DYNAMIC:1050 /INFO
X  OVLMUCKING =	# None required
X  MSC6MUCK =	# None required
X  OVERLAY =	# None required
X--- 67,73 ----
X  # command line exceeds the MSDOS 128 character limit.
X  #
X  CFLAGS	= /c
X! LFLAGS	= /noi /seg:512 /map /st:5120 /DYNAMIC:1052 /INFO
X  OVLMUCKING =	# None required
X  MSC6MUCK =	# None required
X  OVERLAY =	# None required
X***************
X*** 137,148 ****
X  # RANDOM	=
X  
X  #
X! # If TERMLIB is NOT #defined in the source (in include\pcconf.h), 
X! # comment out the lower line and uncomment the upper.  Make sure 
X  # that TERMLIB contains the full pathname to the termcap library. 
X  
X! #TERMLIB =
X! TERMLIB = $(SSYS)\termcap.lib
X  
X  #
X  #	Nothing below this line should have to be changed.
X--- 137,148 ----
X  # RANDOM	=
X  
X  #
X! # If TERMLIB is #defined in the source (in include\pcconf.h), 
X! # comment out the upper line and uncomment the lower.  Make sure 
X  # that TERMLIB contains the full pathname to the termcap library. 
X  
X! TERMLIB =
X! #TERMLIB = $(SSYS)\termcap.lib
X  
X  #
X  #	Nothing below this line should have to be changed.
X***************
X*** 382,387 ****
X--- 382,388 ----
X  	copy $(DAT)\*.lev		$(GAMEDIR)
X  	copy $(SSYS)\NetHack.cnf	$(GAMEDIR)
X  	copy $(UTL)\recover.exe		$(GAMEDIR)
X+ 	copy $(SYS)\msdos.hlp		$(GAMEDIR)
X  	del  $(GAMEDIR)\makefile
X  	echo install done > install.tag
X  
X*** /tmp/da22301	Mon Jul 12 17:40:02 1993
X--- sys/msdos/setup.bat	Thu Jul  1 15:51:39 1993
X***************
X*** 6,12 ****
X  
X  REM setup batch file for msdos, see Install.dos for details.
X  
X! if not %1 .==. goto ok_parm
X  goto err_set
X  
X  :ok_parm
X--- 6,12 ----
X  
X  REM setup batch file for msdos, see Install.dos for details.
X  
X! if not %1.==. goto ok_parm
X  goto err_set
X  
X  :ok_parm
X*** /tmp/da22317	Mon Jul 12 17:40:07 1993
X--- sys/msdos/video.c	Fri Jul  2 14:27:51 1993
X***************
X*** 1,4 ****
X! /*   SCCS Id: @(#)video.c   3.1     93/05/09                        */
X  /*   Copyright (c) NetHack PC Development Team 1993                 */
X  /*   NetHack may be freely redistributed.  See license for details. */
X  /*                                                                  */
X--- 1,4 ----
X! /*   SCCS Id: @(#)video.c   3.1     93/06/28                        */
X  /*   Copyright (c) NetHack PC Development Team 1993                 */
X  /*   NetHack may be freely redistributed.  See license for details. */
X  /*                                                                  */
X***************
X*** 12,17 ****
X--- 12,22 ----
X   *     Use CO,LI in decl.c           M. Allison      93/04/24
X   *     Add djgpp support             K. Smolkowski   93/04/26
X   *     Add runtime monoadapter check M. Allison      93/05/09
X+  *     Fix grays                     M. Allison      93/06/15
X+  *     MONO_CHECK not BIOS specific  M. Allison      93/06/19
X+  *     Add .cnf videoshades support  M. Allison      93/06/25
X+  *     Add .cnf videocolors support  M. Allison      93/06/27
X+  *     Make tty_delay_output() work  M. Allison      93/06/28
X   */
X  
X  #include "hack.h"
X***************
X*** 18,27 ****
X  
X  #include <dos.h>
X  
X! #ifdef SCREEN_BIOS
X! #define MONO_CHECK	   		/* Enable monochrome adapter support */
X! #endif
X  
X  /*
X   * PC interrupts
X   */
X--- 23,56 ----
X  
X  #include <dos.h>
X  
X! /*
X!  * Choose compile options for different compilers/environments.
X!  * Current optional features in video.c :
X!  *
X!  *     MONO_CHECK     Enables runtime checking for monochrome
X!  *                    adapter. 93/06/19
X!  *     ENABLE_SLEEP   Enables the tty_delay_output() function. 93/06/28
X!  *
X!  */
X  
X+ # ifdef SCREEN_BIOS
X+ # define MONO_CHECK		/* Video BIOS can do the check       */ 
X+ #  if defined(_MSC_VER) && _MSC_VER >= 700
X+ # define ENABLE_SLEEP		/* enable napping for visual effects */
X+ #  endif
X+ # endif
X+ 
X+ # ifdef SCREEN_DJGPPFAST
X+ /*# define MONO_CHECK 		/* djgpp should be able to do check  */ 
X+ # define ENABLE_SLEEP		/* enable napping for visual effects */
X+ # endif
X+ 
X+ # ifdef PC9801
X+ #  ifdef MONO_CHECK
X+ #undef MONO_CHECK		/* Don't suppose it can do the check */
X+ #  endif                        /* Can it?                           */
X+ # endif
X+ 
X  /*
X   * PC interrupts
X   */
X***************
X*** 37,56 ****
X   */
X  #define ATTRIB_NORMAL         0x07	/* Normal attribute */
X  #define ATTRIB_INTENSE 	      0x0f	/* Intense White */
X  #ifdef MONO_CHECK
X  #define ATTRIB_MONO_UNDERLINE 0x01	/* Underlined,white */
X  #define ATTRIB_MONO_BLINK     0x87	/* Flash bit, white */
X  #define ATTRIB_MONO_REVERSE   0x70	/* Black on white */
X  #endif
X  /*
X   * Video BIOS functions
X   */
X! #ifdef PC9801
X  #define SETCURPOS   0x13    /* Set Cursor Position */
X  #define SENSEMODE   0x0b    /* Sense CRT Mode */
X  #else
X- #define GETCURPOS   0x03    /* Get Cursor Position */
X  #define SETCURPOS   0x02    /* Set Cursor Position */
X  #define GETMODE     0x0f    /* Get Video Mode */
X  #define SETMODE     0x00    /* Set Video Mode */
X  #define SETPAGE     0x05    /* Set Video Page */
X--- 66,89 ----
X   */
X  #define ATTRIB_NORMAL         0x07	/* Normal attribute */
X  #define ATTRIB_INTENSE 	      0x0f	/* Intense White */
X+ 
X  #ifdef MONO_CHECK
X  #define ATTRIB_MONO_UNDERLINE 0x01	/* Underlined,white */
X  #define ATTRIB_MONO_BLINK     0x87	/* Flash bit, white */
X  #define ATTRIB_MONO_REVERSE   0x70	/* Black on white */
X  #endif
X+ 
X  /*
X   * Video BIOS functions
X   */
X! #if defined(PC9801)
X  #define SETCURPOS   0x13    /* Set Cursor Position */
X  #define SENSEMODE   0x0b    /* Sense CRT Mode */
X  #else
X  #define SETCURPOS   0x02    /* Set Cursor Position */
X+ #endif
X+ 
X+ #define GETCURPOS   0x03    /* Get Cursor Position */
X  #define GETMODE     0x0f    /* Get Video Mode */
X  #define SETMODE     0x00    /* Set Video Mode */
X  #define SETPAGE     0x05    /* Set Video Page */
X***************
X*** 57,64 ****
X  #define FONTINFO    0x1130  /* Get Font Info */
X  #define SCROLL      0x06    /* Scroll or initialize window */
X  #define PUTCHARATT  0x09    /* Write attribute & char at cursor */
X- #endif
X  
X  #ifdef OVLB
X  
X  void
X--- 90,97 ----
X  #define FONTINFO    0x1130  /* Get Font Info */
X  #define SCROLL      0x06    /* Scroll or initialize window */
X  #define PUTCHARATT  0x09    /* Write attribute & char at cursor */
X  
X+ 
X  #ifdef OVLB
X  
X  void
X***************
X*** 78,84 ****
X  
X  	LI = (regs.h.al & 0x01) ? 20 : 25;
X  	CO = (regs.h.al & 0x02) ? 40 : 80;
X! # else
X  	regs.x.ax = FONTINFO;
X  	regs.x.bx = 0;			/* current ROM BIOS font */
X  	regs.h.dl = 24;			/* default row count */
X--- 111,117 ----
X  
X  	LI = (regs.h.al & 0x01) ? 20 : 25;
X  	CO = (regs.h.al & 0x02) ? 40 : 80;
X! # else 
X  	regs.x.ax = FONTINFO;
X  	regs.x.bx = 0;			/* current ROM BIOS font */
X  	regs.h.dl = 24;			/* default row count */
X***************
X*** 105,111 ****
X  	CO = regs.h.ah;
X  # endif /* PC9801 */
X  }
X! #endif
X  
X  #ifdef NO_TERMS
X  
X--- 138,144 ----
X  	CO = regs.h.ah;
X  # endif /* PC9801 */
X  }
X! #endif /*OVLB*/
X  
X  #ifdef NO_TERMS
X  
X***************
X*** 121,134 ****
X  # ifdef TEXTCOLOR
X  char ttycolors[MAXCOLORS];
X  static void NDECL(init_ttycolor);
X! # endif
X  
X  # ifdef SCREEN_BIOS
X  void FDECL(gotoxy, (int,int));
X  void FDECL(get_cursor, (int *, int *));
X- #  ifdef MONO_CHECK
X- int  NDECL(monoadapt_check);
X- #  endif
X  # endif
X  
X  # ifdef SCREEN_DJGPPFAST
X--- 154,164 ----
X  # ifdef TEXTCOLOR
X  char ttycolors[MAXCOLORS];
X  static void NDECL(init_ttycolor);
X! # endif /* TEXTCOLOR */
X  
X  # ifdef SCREEN_BIOS
X  void FDECL(gotoxy, (int,int));
X  void FDECL(get_cursor, (int *, int *));
X  # endif
X  
X  # ifdef SCREEN_DJGPPFAST
X***************
X*** 136,146 ****
X  #define get_cursor(x,y) ScreenGetCursor(y,x)
X  # endif
X  
X  /* 
X   *  LI, CO are ifdefs of a data structure in decl.c, and are initialized
X   *  by get_scr_size()
X   */
X- /*extern  int LI, CO; */	/* decl.h does this already */
X  char g_attribute;		/* Current attribute to use */
X  
X  # ifdef MONO_CHECK
X--- 166,179 ----
X  #define get_cursor(x,y) ScreenGetCursor(y,x)
X  # endif
X  
X+ # ifdef MONO_CHECK
X+ int  NDECL(monoadapt_check);
X+ # endif
X+ 
X  /* 
X   *  LI, CO are ifdefs of a data structure in decl.c, and are initialized
X   *  by get_scr_size()
X   */
X  char g_attribute;		/* Current attribute to use */
X  
X  # ifdef MONO_CHECK
X***************
X*** 170,175 ****
X--- 203,209 ----
X   * so for now we just use the BIOS Routines
X   */
X  {
X+ 
X  	union REGS regs;
X  
X  	regs.h.dl = CO - 1;	  /* columns */
X***************
X*** 377,390 ****
X  }
X  
X  # endif /* OVLB */
X! # ifdef OVL1
X  
X  void
X  tty_delay_output()
X  {
X! 	/* delay 50 ms - not implimented */
X  }
X! # endif /* OVL1 */
X  
X  # ifdef OVLB
X  void
X--- 411,432 ----
X  }
X  
X  # endif /* OVLB */
X! # ifdef OVL0
X  
X  void
X  tty_delay_output()
X  {
X! 	/* delay 50 ms - now uses clock() which is ANSI C */
X! #  if defined(ENABLE_SLEEP) || defined(__STDC__)
X! 	clock_t goal;
X! 
X! 	goal = 50 + clock();
X! 	while ( goal > clock()) {
X! 	    /* do nothing */
X! 	}
X! #  endif /* ENABLE_SLEEP || __STDC__*/
X  }
X! # endif /* OVL0 */
X  
X  # ifdef OVLB
X  void
X***************
X*** 473,480 ****
X--- 515,526 ----
X  	int x,y;
X  	char attribute;
X  
X+ #  ifdef MONO_CHECK
X+ 	attribute = ((g_attribute == 0) ? ATTRIB_NORMAL : g_attribute);
X+ #  else
X  	attribute = (((g_attribute > 0) && (g_attribute < MAXCOLORS)) ?
X  			g_attribute : ATTRIB_NORMAL);
X+ #  endif
X  
X  #  ifdef SCREEN_DJGPPFAST
X  	get_cursor(&x,&y);
X***************
X*** 485,497 ****
X  	regs.h.ah = PUTCHARATT;	/* write attribute & character */
X  	regs.h.al = ch;			/* character */
X  	regs.h.bh = 0;			/* display page */
X! 					/* BL = attribute */
X! #    ifdef MONO_CHECK
X! 	regs.h.bl = ((g_attribute == 0) ? ATTRIB_NORMAL : g_attribute);
X! #    else
X! 	regs.h.bl = (((g_attribute > 0) && (g_attribute < MAXCOLORS)) ? 
X! 			g_attribute : ATTRIB_NORMAL);
X! #    endif
X  	regs.x.cx = 1;			/* one character */
X  	int86(VIDEO_BIOS, &regs, &regs); /* write attribute & character */
X  	get_cursor(&x,&y);
X--- 531,537 ----
X  	regs.h.ah = PUTCHARATT;	/* write attribute & character */
X  	regs.h.al = ch;			/* character */
X  	regs.h.bh = 0;			/* display page */
X! 	regs.h.bl = attribute;		/* BL = attribute */
X  	regs.x.cx = 1;			/* one character */
X  	int86(VIDEO_BIOS, &regs, &regs); /* write attribute & character */
X  	get_cursor(&x,&y);
X***************
X*** 501,508 ****
X  }
X  
X  /*
X!  *  Supporting routines.  None of these routines are required to 
X!  *  resolve references outside this source file.
X   */
X  #  ifdef SCREEN_BIOS
X  void
X--- 541,547 ----
X  }
X  
X  /*
X!  *  Supporting routines.
X   */
X  #  ifdef SCREEN_BIOS
X  void
X***************
X*** 543,548 ****
X--- 582,589 ----
X  	 * returns nothing.  -3.
X  	 */
X  }
X+ #  endif /* SCREEN_BIOS */ 
X+ 
X  #  ifdef MONO_CHECK
X  int monoadapt_check()
X  {
X***************
X*** 553,565 ****
X  	int86(VIDEO_BIOS, &regs, &regs);
X  	return (regs.h.al == 7) ? 1 : 0;	/* 7 means monochrome mode */
X  }
X! #   endif /* MONO_CHECK */
X! #  endif /* SCREEN_BIOS */
X  
X  # endif /* OVL0 */
X- # ifdef OVLB
X  
X! #  ifdef TEXTCOLOR
X  /*
X   * BLACK                0
X   * RED                  1
X--- 594,606 ----
X  	int86(VIDEO_BIOS, &regs, &regs);
X  	return (regs.h.al == 7) ? 1 : 0;	/* 7 means monochrome mode */
X  }
X! #  endif /* MONO_CHECK */
X  
X  # endif /* OVL0 */
X  
X! # ifdef TEXTCOLOR
X! #  ifdef OVLB
X! 
X  /*
X   * BLACK                0
X   * RED                  1
X***************
X*** 581,609 ****
X   * BRIGHT               8
X   */
X  
X  static void
X  init_ttycolor()
X  {
X! 	ttycolors[BLACK] = 7;                  	/* mapped to 7 = white */
X! 	ttycolors[RED] = 4;			/*  4 = red */
X! 	ttycolors[GREEN] = 2;			/*  2 = green */
X! 	ttycolors[BROWN] = 6;			/*  6 = brown */
X! 	ttycolors[BLUE] = 1;			/*  1 = blue */
X! 	ttycolors[MAGENTA] = 5;			/*  5 = magenta */
X! 	ttycolors[CYAN] = 3;			/*  3 = cyan */
X! 	ttycolors[GRAY] = 8;			/*  8 = dark gray */
X! 	ttycolors[BRIGHT] = 15;			/* 15 = intense white */
X! 	ttycolors[ORANGE_COLORED] = 12;		/* 12 = light red */
X! 	ttycolors[BRIGHT_GREEN] = 10;		/* 10 = light green */
X! 	ttycolors[YELLOW] = 14;			/* 14 = yellow */
X! 	ttycolors[BRIGHT_BLUE] = 9;		/*  9 = light blue */
X! 	ttycolors[BRIGHT_MAGENTA] = 13;		/* 13 = light magenta */
X! 	ttycolors[BRIGHT_CYAN] = 11;		/* 11 = light cyan */
X! 	ttycolors[WHITE] = 7;			/*  7 = white */
X  }
X  
X! #  endif /* TEXTCOLOR */
X! # endif OVLB
X  
X  #endif /* NO_TERMS */
X  
X--- 622,763 ----
X   * BRIGHT               8
X   */
X  
X+ #  ifdef VIDEOSHADES
X+ /* assign_videoshades() is prototyped in extern.h */
X+ int shadeflag;					/* shades are initialized */
X+ int colorflag;					/* colors are initialized */
X+ char *schoice[3] = {"dark","normal","light"};
X+ char *shade[3];
X+ #  endif /* VIDEOSHADES */
X+ 
X  static void
X  init_ttycolor()
X  {
X! #   ifdef VIDEOSHADES
X! 	if (!shadeflag) {
X! 		ttycolors[BLACK] = 8;           /*  8 = dark gray */
X! 		ttycolors[WHITE] = 15;          /* 15 = bright white */
X! 		ttycolors[GRAY]  = 7;		/*  7 = normal white */
X! 		shade[0] = schoice[0];
X! 		shade[1] = schoice[1];
X! 		shade[2] = schoice[2];
X! 	}
X! #   else
X! 	ttycolors[BLACK] = 7;			/*  mapped to white */
X! 	ttycolors[WHITE] = 7;			/*  mapped to white */
X! 	ttycolors[GRAY]  = 7;			/*  mapped to white */
X! #   endif
X! 
X! #   ifdef VIDEOSHADES
X!     	if (!colorflag) {
X! #   endif
X! 		ttycolors[RED] = 4;			/*  4 = red */
X! 		ttycolors[GREEN] = 2;			/*  2 = green */
X! 		ttycolors[BROWN] = 6;			/*  6 = brown */
X! 		ttycolors[BLUE] = 1;			/*  1 = blue */
X! 		ttycolors[MAGENTA] = 5;			/*  5 = magenta */
X! 		ttycolors[CYAN] = 3;			/*  3 = cyan */
X! 		ttycolors[BRIGHT] = 15;			/* 15 = bright white */
X! 		ttycolors[ORANGE_COLORED] = 12;		/* 12 = light red */
X! 		ttycolors[BRIGHT_GREEN] = 10;		/* 10 = light green */
X! 		ttycolors[YELLOW] = 14;			/* 14 = yellow */
X! 		ttycolors[BRIGHT_BLUE] = 9;		/*  9 = light blue */
X! 		ttycolors[BRIGHT_MAGENTA] = 13;		/* 13 = light magenta */
X! 		ttycolors[BRIGHT_CYAN] = 11;		/* 11 = light cyan */
X! #   ifdef VIDEOSHADES
X! 	}
X! #   endif
X  }
X  
X! #   ifdef VIDEOSHADES
X! int assign_videoshades(uchar *choiceptr,int linelen)
X! {
X! 	char choices[120];
X! 	char *cptr, *cvalue[3];
X! 	int i,icolor;
X! 
X! 	strncpy(choices,choiceptr,linelen);
X! 	choices[linelen] = '\0';
X! 	cvalue[0] = choices;
X! 
X!         /* find the next ' ' or tab */
X!         cptr = index(cvalue[0], ' ');
X!         if (!cptr) cptr = index(cvalue[0], '\t');
X!         if (!cptr) return 0;
X! 	*cptr = '\0';
X!         /* skip  whitespace between '=' and value */
X!         do { ++cptr; } while (isspace(*cptr));
X! 	cvalue[1] = cptr;
X! 
X!         cptr = index(cvalue[1], ' ');
X!         if (!cptr) cptr = index(cvalue[1], '\t');
X!         if (!cptr) return 0;
X! 	*cptr = '\0';
X!         do { ++cptr; } while (isspace(*cptr));
X! 	cvalue[2] = cptr;
X! 
X! 	for (i=0; i < 3; ++i) {
X! 		switch(i) {
X! 			case 0: icolor = BLACK;
X! 				break;
X! 			case 1: icolor = GRAY;
X! 				break;
X! 			case 2: icolor = WHITE;
X! 				break;
X! 		}
X! 
X! 		shadeflag = 1;			
X! 		if ((strncmpi(cvalue[i],"black",5) == 0) ||
X! 		    (strncmpi(cvalue[i],"dark",4) == 0)) {
X! 			shade[i] = schoice[0];
X! 			ttycolors[icolor] = 8;  /* dark gray */
X! 		} else if ((strncmpi(cvalue[i],"gray",4) == 0) ||
X! 		           (strncmpi(cvalue[i],"grey",4) == 0) ||
X! 			   (strncmpi(cvalue[i],"medium",6) == 0) ||
X! 			   (strncmpi(cvalue[i],"normal",6) == 0)) {
X! 			shade[i] = schoice[1];
X! 			ttycolors[icolor] = 7;  /* regular gray */
X! 		} else if ((strncmpi(cvalue[i],"white",5) == 0) ||
X! 			   (strncmpi(cvalue[i],"light",5) == 0)) {
X! 			shade[i] = schoice[2];
X! 			ttycolors[icolor] = 15;  /* bright white */
X! 		} else {
X! 			shadeflag = 0;
X! 			return 0;
X! 		}
X! 	}
X! 	return 1;
X! }
X! 
X! /*
X!  * Process NetHack.cnf option VIDEOCOLORS=
X!  * Left to right assignments for: 
X!  * 	red green brown blue magenta cyan orange br.green yellow 
X!  * 	br.blue br.mag br.cyan
X!  *
X!  * Default Mapping: 4 2 6 1 5 3 12 10 14 9 13 11
X!  */
X! int assign_videocolors(uchar *tmpcolor,int len)
X! {
X! 	int i,icolor,max1,max2;
X! 
X! 	init_ttycolor();	/* in case nethack.cnf entry wasn't complete */
X! 	icolor = RED;
X! 	for( i = 0; i < len; ++i) {
X! 		if (icolor < (WHITE)) {
X! 			ttycolors[icolor++] = tmpcolor[i];
X! 			if ((icolor > CYAN) && (icolor < ORANGE_COLORED)) {
X! 				 icolor = ORANGE_COLORED;
X! 			}
X! 		}
X! 	}
X! 	colorflag = 1;
X! 	return 1;
X! }
X! #   endif /* VIDEOSHADES */
X! 
X! #  endif /* OVLB */
X! # endif /* TEXTCOLOR */
X  
X  #endif /* NO_TERMS */
X  
X*** /tmp/da22807	Mon Jul 12 17:59:42 1993
X--- sys/winnt/Install.nt	Fri Jul  2 15:31:46 1993
X***************
X*** 4,11 ****
X  	    Instructions for compiling and installing
X  		 NetHack 3.1 on a Windows NT system
X  	    ======================================================
X! 		 (or, How to make NT NetHack 3.1.2)
X! 		    Last revision: Apr 16, 1993
X  
X  Credit for the PC versions of NetHack goes to the PC Development team 
X  consisting of Norm Meluch, Kevin Smolkowski, Paul Winner and Steve 
X--- 4,11 ----
X  	    Instructions for compiling and installing
X  		 NetHack 3.1 on a Windows NT system
X  	    ======================================================
X! 		 (or, How to make NT NetHack 3.1.3)
X! 		    Last revision: Jun 30, 1993
X  
X  Credit for the PC versions of NetHack goes to the PC Development team 
X  consisting of Norm Meluch, Kevin Smolkowski, Paul Winner and Steve 
X***************
X*** 20,26 ****
X  completion of the first Windows NT port of NetHack: Doug Thompson, 
X  Phil Mills, Scott Murray. 
X  
X! This first version of NetHack for Windows NT is a tty port utilizing 
X  the NT WIN32 Console I/O subsystem.
X  
X  
X--- 20,26 ----
X  completion of the first Windows NT port of NetHack: Doug Thompson, 
X  Phil Mills, Scott Murray. 
X  
X! This current version of NetHack for Windows NT is a tty port utilizing 
X  the NT WIN32 Console I/O subsystem.
X  
X  
X***************
X*** 197,203 ****
X      "Working Directory:" dialogue box field when creating your 
X      Program Manager Icon:
X  
X!     ie.  Description      :  NetHack 3.1.2 
X           Command Line     :  C:\GAMES\NETHACK\NETHACK.EXE
X           Working Directory:  C:\GAMES\NETHACK
X           Shortcut key     :
X--- 197,203 ----
X      "Working Directory:" dialogue box field when creating your 
X      Program Manager Icon:
X  
X!     ie.  Description      :  NetHack 3.1.3 
X           Command Line     :  C:\GAMES\NETHACK\NETHACK.EXE
X           Working Directory:  C:\GAMES\NETHACK
X           Shortcut key     :
X***************
X*** 232,239 ****
X  	More than 1,900,000 bytes, nethack.exe when debugging information 
X          is included in the .exe, and more than 1,200,000 bytes without.
X  
X! 3)  If you want to use the number pad on the keyboard for movement when
X!     playing the game, be sure the NUMLOCK is on.
X  
X  4)  A true Windows (WIN32s) version of NetHack is currently under development
X      by the PC Windows Porting team.
X--- 232,242 ----
X  	More than 1,900,000 bytes, nethack.exe when debugging information 
X          is included in the .exe, and more than 1,200,000 bytes without.
X  
X! 3)  Beginning with NetHack 3.1.3, the keyboard command sequences match
X!     those in the MSDOS port of NetHack more exactly.  The keypad may be used for
X!     movement without having the NUMLOCK on.  This also gives you the advantage
X!     of being able to RUN by pressing the SHIFT key at the same time as one
X!     of the directional movement keys on the keypad (1,2,3,4,6,7,8,9).
X  
X  4)  A true Windows (WIN32s) version of NetHack is currently under development
X      by the PC Windows Porting team.
X*** /tmp/da22847	Mon Jul 12 17:59:51 1993
X--- sys/winnt/nhincl.mak	Mon Jul 12 14:14:52 1993
X***************
X*** 1,6 ****
X  # =========================================================================
X! # NTWIN32.MAK - Win32 application master NMAKE definitions file for the
X! #               Microsoft Win32 SDK for Windows NT programming samples
X  # -------------------------------------------------------------------------
X  # NMAKE Options
X  #
X--- 1,6 ----
X  # =========================================================================
X! # NHINCL.MAK - Modified Win32 application master NMAKE definitions file for
X! #              NetHack 3.1.3 - NetHack PC Development Team 93/07/12
X  # -------------------------------------------------------------------------
X  # NMAKE Options
X  #
X***************
X*** 116,122 ****
X  # -------------------------------------------------------------------------
X  
X  # declarations common to all compilers.
X! ccommon = -c -W0
X  
X  !IF "$(CPU)" == "i386"
X  cflags = $(ccommon) -G3 -D_X86_=1
X--- 116,122 ----
X  # -------------------------------------------------------------------------
X  
X  # declarations common to all compilers.
X! ccommon = -c -W0 -nologo
X  
X  !IF "$(CPU)" == "i386"
X  cflags = $(ccommon) -G3 -D_X86_=1
X***************
X*** 271,278 ****
X  psxlflags = -subsystem:posix -entry:__PosixProcessStartup
X  
X  # for compatibility with older style makefiles
X! conflags  = $(conlflags)
X! guiflags  = $(guilflags)
X  psxflags  = $(psxlflags)
X  
X  # -------------------------------------------------------------------------
X--- 271,278 ----
X  psxlflags = -subsystem:posix -entry:__PosixProcessStartup
X  
X  # for compatibility with older style makefiles
X! conflags  = $(conlflags) -IGNORE:505
X! guiflags  = $(guilflags) -IGNORE:505
X  psxflags  = $(psxlflags)
X  
X  # -------------------------------------------------------------------------
X*** /tmp/da22855	Mon Jul 12 17:59:53 1993
X--- sys/winnt/nttty.c	Tue Jul  6 15:14:43 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)nttty.c	3.1	90/05/23
X  /* Copyright (c) NetHack PC Development Team 1993    */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)nttty.c	3.1	93/07/04
X  /* Copyright (c) NetHack PC Development Team 1993    */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 18,23 ****
X--- 18,24 ----
X  #pragma pack(8)
X  #include <windows.h>
X  #include <wincon.h>
X+ #pragma pack()
X  
X  void FDECL(cmov, (int, int));
X  void FDECL(nocmov, (int, int));
X***************
X*** 47,53 ****
X  /* Flag for whether NetHack was launched via progman, not command line.
X   * The reason we care at all, is so that we can get
X   * a final RETURN at the end of the game when launched from progman
X!  * to prevent the scoreboard (or panic message :-| from vanishing
X   * immediately after it is displayed, yet not bother when started
X   * from the command line. 
X   */
X--- 48,54 ----
X  /* Flag for whether NetHack was launched via progman, not command line.
X   * The reason we care at all, is so that we can get
X   * a final RETURN at the end of the game when launched from progman
X!  * to prevent the scoreboard (or panic message :-|) from vanishing
X   * immediately after it is displayed, yet not bother when started
X   * from the command line. 
X   */
X***************
X*** 93,136 ****
X  	start_screen();
X  }
X  
X  int
X  tgetch()
X  {
X- 	int ch;
X  	int valid = 0;
X  	int metaflags = 0;
X  	int count;
X  
X  	valid = 0;
X  	while (!valid)
X  	{
X! 	    ReadConsoleInput(hConIn,&ir,1,&count);
X! 	    /* We only care about ascii press-down KEY_EVENTs */
X! 	    if ((ir.EventType == KEY_EVENT) &&
X! 	       (ir.Event.KeyEvent.bKeyDown) &&	
X! 	       (ir.Event.KeyEvent.uChar.AsciiChar)) valid = 1;
X  	}
X! 	metaflags = ir.Event.KeyEvent.dwControlKeyState;
X! 	/*
X! 	 * metaflags can be checked to see if various special
X!          * keys were pressed at the same time as the key.
X!          * Currently we are using the ALT keys only.
X! 	 *
X! 	 *           RIGHT_ALT_PRESSED, LEFT_ALT_PRESSED,
X!          *           RIGHT_CTRL_PRESSED, LEFT_CTRL_PRESSED,
X!          *           SHIFT_PRESSED,NUMLOCK_ON, SCROLLLOCK_ON,
X!          *           CAPSLOCK_ON, ENHANCED_KEY
X!          *
X! 	 * are all valid bit masks to use on metaflags
X!          * eg. (metaflags & LEFT_CTRL_PRESSED) is true if the
X!          *      left control key was pressed with the keystroke.
X!          */
X! 	ch = (ir.Event.KeyEvent.uChar.AsciiChar == '\r') ?
X! 			 '\n' :ir.Event.KeyEvent.uChar.AsciiChar;
X! 	if (metaflags & (LEFT_ALT_PRESSED|RIGHT_ALT_PRESSED))
X! 	   ch = tolower(ch) | 0x080;
X! 	return ch;
X! }
X  
X  int
X  kbhit()
X--- 94,226 ----
X  	start_screen();
X  }
X  
X+ /*
X+  *  Keyboard translation tables.
X+  *  (Adopted from the MSDOS port)
X+  */
X+ 
X+ #define KEYPADLO	0x47
X+ #define KEYPADHI	0x53
X+ 
X+ #define PADKEYS 	(KEYPADHI - KEYPADLO + 1)
X+ #define iskeypad(x)	(KEYPADLO <= (x) && (x) <= KEYPADHI)
X+ 
X+ /*
X+  * Keypad keys are translated to the normal values below.
X+  * Shifted keypad keys are translated to the
X+  *    shift values below.
X+  */
X+ 
X+ static const struct pad {
X+ 	char normal, shift, cntrl;
X+ } keypad[PADKEYS] = {
X+ 			{'y', 'Y', C('y')},		/* 7 */
X+ 			{'k', 'K', C('k')},		/* 8 */
X+ 			{'u', 'U', C('u')},		/* 9 */
X+ 			{'m', C('p'), C('p')},		/* - */
X+ 			{'h', 'H', C('h')},		/* 4 */
X+ 			{'g', 'g', 'g'},		/* 5 */
X+ 			{'l', 'L', C('l')},		/* 6 */
X+ 			{'p', 'P', C('p')},		/* + */
X+ 			{'b', 'B', C('b')},		/* 1 */
X+ 			{'j', 'J', C('j')},		/* 2 */
X+ 			{'n', 'N', C('n')},		/* 3 */
X+ 			{'i', 'I', C('i')},		/* Ins */
X+ 			{'.', ':', ':'}			/* Del */
X+ }, numpad[PADKEYS] = {
X+ 			{'7', M('7'), '7'},		/* 7 */
X+ 			{'8', M('8'), '8'},		/* 8 */
X+ 			{'9', M('9'), '9'},		/* 9 */
X+ 			{'m', C('p'), C('p')},		/* - */
X+ 			{'4', M('4'), '4'},		/* 4 */
X+ 			{'g', 'G', 'g'},		/* 5 */
X+ 			{'6', M('6'), '6'},		/* 6 */
X+ 			{'p', 'P', C('p')},		/* + */
X+ 			{'1', M('1'), '1'},		/* 1 */
X+ 			{'2', M('2'), '2'},		/* 2 */
X+ 			{'3', M('3'), '3'},		/* 3 */
X+ 			{'i', 'I', C('i')},		/* Ins */
X+ 			{'.', ':', ':'}			/* Del */
X+ };
X+ /*
X+  * Unlike Ctrl-letter, the Alt-letter keystrokes have no specific ASCII
X+  * meaning unless assigned one by a keyboard conversion table
X+  * To interpret Alt-letters, we use a
X+  * scan code table to translate the scan code into a letter, then set the
X+  * "meta" bit for it.  -3.
X+  */
X+ #define SCANLO		0x10
X+ 
X+ static const char scanmap[] = { 	/* ... */
X+ 	'q','w','e','r','t','y','u','i','o','p','[',']', '\n',
X+ 	0, 'a','s','d','f','g','h','j','k','l',';','\'', '`',
X+ 	0, '\\', 'z','x','c','v','b','n','m',',','.','?'	/* ... */
X+ };
X+ 
X+ #define inmap(x)	(SCANLO <= (x) && (x) < SCANLO + SIZE(scanmap))
X+ 
X  int
X  tgetch()
X  {
X  	int valid = 0;
X  	int metaflags = 0;
X  	int count;
X+ 	unsigned short int scan;
X+ 	unsigned char ch;
X+ 	unsigned long shiftstate;
X+ 	int altseq;
X+ 	const struct pad *kpad;
X+ 	char keymess[100];
X  
X+ 	shiftstate = 0L;
X  	valid = 0;
X  	while (!valid)
X  	{
X! 	   ReadConsoleInput(hConIn,&ir,1,&count);
X! 	   if ((ir.EventType == KEY_EVENT) && ir.Event.KeyEvent.bKeyDown) {
X! 		ch    = ir.Event.KeyEvent.uChar.AsciiChar;
X! 		scan  = ir.Event.KeyEvent.wVirtualScanCode;
X! 		shiftstate = ir.Event.KeyEvent.dwControlKeyState;
X! 		altseq=(shiftstate & (LEFT_ALT_PRESSED|RIGHT_ALT_PRESSED)) && inmap(scan);
X! 		if (ch || (iskeypad(scan)) || altseq)
X! 			valid = 1;
X! 	   }
X  	}
X! 	if (valid) {
X!     	    /*
X! 	    * shiftstate can be checked to see if various special
X!             * keys were pressed at the same time as the key.
X!             * Currently we are using the ALT & SHIFT & CONTROLS.
X!             *
X!             *           RIGHT_ALT_PRESSED, LEFT_ALT_PRESSED,
X!             *           RIGHT_CTRL_PRESSED, LEFT_CTRL_PRESSED,
X!             *           SHIFT_PRESSED,NUMLOCK_ON, SCROLLLOCK_ON,
X!             *           CAPSLOCK_ON, ENHANCED_KEY
X!             *
X!             * are all valid bit masks to use on shiftstate.
X!             * eg. (shiftstate & LEFT_CTRL_PRESSED) is true if the
X!             *      left control key was pressed with the keystroke.
X!             */
X!             if (iskeypad(scan)) {
X!                 kpad = flags.num_pad ? numpad : keypad;
X!                 if (shiftstate & SHIFT_PRESSED) {
X!                     ch = kpad[scan - KEYPADLO].shift;
X!                 }
X!                 else if (shiftstate & (LEFT_CTRL_PRESSED | RIGHT_CTRL_PRESSED)) {
X!                     ch = kpad[scan - KEYPADLO].cntrl;
X!                 }
X!                 else {
X!                     ch = kpad[scan - KEYPADLO].normal;
X!                 }
X!             }
X!             else if (shiftstate & (LEFT_ALT_PRESSED|RIGHT_ALT_PRESSED)) { /* ALT sequence */
X!                     if (inmap(scan))
X!                         ch = scanmap[scan - SCANLO];
X!                     ch = (isprint(ch) ? M(ch) : ch);
X!             }
X!             return (ch == '\r') ? '\n' : ch;
X! 	}
X! }
X  
X  int
X  kbhit()
X***************
X*** 137,144 ****
X  {
X  	int done = 0;	/* true =  "stop searching"        */
X  	int retval;	/* true =  "we had a match"        */
X! 	int count;	/* scratch-pad area for API call   */
X! 
X  	done = 0;
X  	retval = 0;
X  	while (!done)
X--- 227,238 ----
X  {
X  	int done = 0;	/* true =  "stop searching"        */
X  	int retval;	/* true =  "we had a match"        */
X! 	int count;
X! 	unsigned short int scan;
X! 	unsigned char ch;
X! 	unsigned long shiftstate;
X! 	int altseq;
X!         
X  	done = 0;
X  	retval = 0;
X  	while (!done)
X***************
X*** 145,168 ****
X  	{
X  	    count = 0;
X  	    PeekConsoleInput(hConIn,&ir,1,&count);
X! 	    if (count > 0)
X!             {
X! 		/* Make sure its an ascii press-down KEY_EVENT */
X! 	        if ((ir.EventType == KEY_EVENT) &&
X! 	        (ir.Event.KeyEvent.bKeyDown) &&	
X! 	        (ir.Event.KeyEvent.uChar.AsciiChar))
X! 	        { 
X! 		     /* This is what we were looking for        */
X! 		     done = 1;	        /* Stop looking         */
X! 		     retval = 1;        /* Found what we sought */
X! 	        }
X! 		/* Discard it, its an insignificant event */
X! 	        else ReadConsoleInput(hConIn,&ir,1,&count);
X! 	    }
X! 	    else  /* There are no events in console event queue*/
X! 	    {
X  		done = 1;	  /* Stop looking               */
X! 		retval = 0;	  /* No ascii press-down key    */
X  	    }
X  	}
X  	return retval;
X--- 239,259 ----
X  	{
X  	    count = 0;
X  	    PeekConsoleInput(hConIn,&ir,1,&count);
X! 	    if (count > 0) {
X! 		ch    = ir.Event.KeyEvent.uChar.AsciiChar;
X! 		scan  = ir.Event.KeyEvent.wVirtualScanCode;
X! 		shiftstate = ir.Event.KeyEvent.dwControlKeyState;
X! 		altseq=(shiftstate & (LEFT_ALT_PRESSED|RIGHT_ALT_PRESSED)) && inmap(scan);
X! 		if (((ir.EventType == KEY_EVENT) && ir.Event.KeyEvent.bKeyDown) &&
X! 		     (ch || (iskeypad(scan)) || altseq)) {
X! 			done = 1;	    /* Stop looking         */
X! 			retval = 1;         /* Found what we sought */
X! 		}
X! 		else /* Discard it, its an insignificant event */
X! 			ReadConsoleInput(hConIn,&ir,1,&count);
X! 		} else  /* There are no events in console event queue */ {
X  		done = 1;	  /* Stop looking               */
X! 		retval = 0;
X  	    }
X  	}
X  	return retval;
X***************
X*** 173,179 ****
X  nttty_open()
X  {
X          HANDLE hStdOut;
X! 
X          /* The following 6 lines of code were suggested by 
X           * Bob Landau of Microsoft WIN32 Developer support,
X           * as the only current means of determining whether
X--- 264,273 ----
X  nttty_open()
X  {
X          HANDLE hStdOut;
X!         long cmode;
X!         long mask;
X!         unsigned int codepage;
X!         
X          /* The following 6 lines of code were suggested by 
X           * Bob Landau of Microsoft WIN32 Developer support,
X           * as the only current means of determining whether
X***************
X*** 193,203 ****
X  			GENERIC_READ |GENERIC_WRITE,
X  			FILE_SHARE_READ |FILE_SHARE_WRITE,
X  			NULL, OPEN_EXISTING, 0, NULL);					
X! 
X  	hConOut = CreateFile("CONOUT$",
X  			GENERIC_READ |GENERIC_WRITE,
X  			FILE_SHARE_READ |FILE_SHARE_WRITE,
X! 			NULL, OPEN_EXISTING, 0, NULL);					
X  	get_scr_size();
X  }
X  
X--- 287,303 ----
X  			GENERIC_READ |GENERIC_WRITE,
X  			FILE_SHARE_READ |FILE_SHARE_WRITE,
X  			NULL, OPEN_EXISTING, 0, NULL);					
X! 	GetConsoleMode(hConIn,&cmode);
X! 	mask = ENABLE_PROCESSED_INPUT | ENABLE_LINE_INPUT |
X! 	       ENABLE_MOUSE_INPUT | ENABLE_ECHO_INPUT | ENABLE_WINDOW_INPUT;   
X! 	cmode &= ~mask;
X! 	SetConsoleMode(hConIn,cmode);
X! 	
X  	hConOut = CreateFile("CONOUT$",
X  			GENERIC_READ |GENERIC_WRITE,
X  			FILE_SHARE_READ |FILE_SHARE_WRITE,
X! 			NULL, OPEN_EXISTING, 0, NULL);					        
X!         
X  	get_scr_size();
X  }
X  
X***************
X*** 364,370 ****
X  void
X  tty_delay_output()
X  {
X! 	/* delay 50 ms - not implimented */
X  }
X  
X  void
X--- 464,476 ----
X  void
X  tty_delay_output()
X  {
X! 	/* delay 50 ms - uses ANSI C clock() function now */
X! 	clock_t goal;
X! 
X! 	goal = 50 + clock();
X! 	while (goal > clock()) {
X! 	    /* Do nothing */
X! 	}
X  }
X  
X  void
X***************
X*** 523,526 ****
X  }
X  
X  #endif /* WIN32CON */
X- 
X--- 629,631 ----
X*** /tmp/da22911	Mon Jul 12 18:00:08 1993
X--- win/X11/dialogs.c	Thu Jul  1 15:32:48 1993
X***************
X*** 34,39 ****
X--- 34,44 ----
X   *	We don't need it here.
X   *    + Add the function positionpopup() from another part of ghostview
X   *	to this code.
X+  *
X+  * Modified 2/93, Various.
X+  *    + Added workaround for SYSV include problem.
X+  *    + Changed the default width response text widget to be as wide as the
X+  *	window itself.  Suggestion from David E. Wexelblat, dwex@goblin.org.
X   */
X  
X  #ifndef SYSV
X***************
X*** 226,231 ****
X--- 231,237 ----
X      return XtNewString(s);
X  }
X  
X+ #define max(a,b) (((a) > (b)) ? (a) : (b))
X  /* set the default reponse */
X  void
X  SetDialogResponse(w, s)
X***************
X*** 232,251 ****
X      Widget w;
X      String s;
X  {
X!     Arg args[3];
X      Widget response;
X      XFontStruct *font;
X!     Dimension width, leftMargin, rightMargin;
X  
X      response = XtNameToWidget(w, "response");
X      XtSetArg(args[0], XtNfont, &font);
X      XtSetArg(args[1], XtNleftMargin, &leftMargin);
X      XtSetArg(args[2], XtNrightMargin, &rightMargin);
X!     XtGetValues(response, args, THREE);
X!     width = font->max_bounds.width * strlen(s) + leftMargin + rightMargin;
X  
X      XtSetArg(args[0], XtNstring, s);
X!     XtSetArg(args[1], XtNwidth, width);
X      XtSetValues(response, args, TWO);
X      XawTextSetInsertionPoint(response, strlen(s));
X  }
X--- 238,259 ----
X      Widget w;
X      String s;
X  {
X!     Arg args[4];
X      Widget response;
X      XFontStruct *font;
X!     Dimension width, nwidth, leftMargin, rightMargin;
X  
X      response = XtNameToWidget(w, "response");
X      XtSetArg(args[0], XtNfont, &font);
X      XtSetArg(args[1], XtNleftMargin, &leftMargin);
X      XtSetArg(args[2], XtNrightMargin, &rightMargin);
X!     XtSetArg(args[3], XtNwidth, &width);
X!     XtGetValues(response, args, FOUR);
X!     nwidth = max(((font->max_bounds.width * strlen(s))+leftMargin+rightMargin),
X! 		 (width-(leftMargin+rightMargin)));
X  
X      XtSetArg(args[0], XtNstring, s);
X!     XtSetArg(args[1], XtNwidth, nwidth);
X      XtSetValues(response, args, TWO);
X      XawTextSetInsertionPoint(response, strlen(s));
X  }
X*** /tmp/da22991	Mon Jul 12 18:00:30 1993
X--- win/X11/winmesg.c	Thu Jul  1 15:33:02 1993
X***************
X*** 80,86 ****
X  
X      mesg_info->fs = 0;
X      mesg_info->num_lines = 0;
X!     mesg_info->head = mesg_info->last_pause =
X  			mesg_info->last_pause_head = (struct line_element *) 0;
X      mesg_info->dirty = False;
X      mesg_info->viewport_width = mesg_info->viewport_height = 0;
X--- 80,86 ----
X  
X      mesg_info->fs = 0;
X      mesg_info->num_lines = 0;
X!     mesg_info->head = mesg_info->line_here = mesg_info->last_pause =
X  			mesg_info->last_pause_head = (struct line_element *) 0;
X      mesg_info->dirty = False;
X      mesg_info->viewport_width = mesg_info->viewport_height = 0;
X***************
X*** 445,451 ****
X  {
X      struct mesg_info_t *mesg_info = wp->mesg_information;
X      register struct line_element *curr;
X!     register int row;
X  
X      /*
X       * Do this the cheap and easy way.  Clear the window and just redraw
X--- 445,451 ----
X  {
X      struct mesg_info_t *mesg_info = wp->mesg_information;
X      register struct line_element *curr;
X!     register int row, y_base;
X  
X      /*
X       * Do this the cheap and easy way.  Clear the window and just redraw
X***************
X*** 456,469 ****
X       *
X       * Only need to clear if window has new text.
X       */
X!     if (mesg_info->dirty) XClearWindow(XtDisplay(wp->w), XtWindow(wp->w));
X  
X      /* For now, just update the whole shootn' match. */
X!     for (row = 0, curr = mesg_info->head;
X! 			row < mesg_info->num_lines; row++, curr = curr->next) {
X  
X- 	register int y_base = row * mesg_info->char_height;
X- 
X  	XDrawString(XtDisplay(wp->w), XtWindow(wp->w),
X  		mesg_info->gc,
X  		mesg_info->char_lbearing,
X--- 456,471 ----
X       *
X       * Only need to clear if window has new text.
X       */
X!     if (mesg_info->dirty) {
X! 	XClearWindow(XtDisplay(wp->w), XtWindow(wp->w));
X! 	mesg_info->line_here = mesg_info->last_pause;
X!     }
X  
X      /* For now, just update the whole shootn' match. */
X!     for (y_base = row = 0, curr = mesg_info->head;
X! 		row < mesg_info->num_lines;
X! 		row++, y_base += mesg_info->char_height, curr = curr->next) {
X  
X  	XDrawString(XtDisplay(wp->w), XtWindow(wp->w),
X  		mesg_info->gc,
X  		mesg_info->char_lbearing,
X***************
X*** 470,481 ****
X  		mesg_info->char_ascent + y_base,
X  		curr->line,
X  		curr->str_length);
X- 
X  	/*
X  	 * This draws a line at the _top_ of the line of text pointed to by
X  	 * mesg_info->last_pause.
X  	 */
X! 	if (appResources.message_line && curr == mesg_info->last_pause) {
X  	    XDrawLine(XtDisplay(wp->w), XtWindow(wp->w),
X  		mesg_info->gc,
X  		0, y_base, wp->pixel_width, y_base);
X--- 472,482 ----
X  		mesg_info->char_ascent + y_base,
X  		curr->line,
X  		curr->str_length);
X  	/*
X  	 * This draws a line at the _top_ of the line of text pointed to by
X  	 * mesg_info->last_pause.
X  	 */
X! 	if (appResources.message_line && curr == mesg_info->line_here) {
X  	    XDrawLine(XtDisplay(wp->w), XtWindow(wp->w),
X  		mesg_info->gc,
X  		0, y_base, wp->pixel_width, y_base);
END_OF_FILE
if test 53675 -ne `wc -c <'patches03e'`; then
    echo shar: \"'patches03e'\" unpacked with wrong size!
fi
# end of 'patches03e'
if test -f 'sys/msdos/msdos.hlp' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'sys/msdos/msdos.hlp'\" to \"'sys/msdos/msdos.hlp.orig'\"
  mv -f 'sys/msdos/msdos.hlp' 'sys/msdos/msdos.hlp.orig'
fi
echo shar: Extracting \"'sys/msdos/msdos.hlp'\" \(3605 characters\)
sed "s/^X//" >'sys/msdos/msdos.hlp' <<'END_OF_FILE'
X            MSDOS specific help file for NetHack 3.1.3 
X                    (Last Revised: July 11, 1993)
X
XCopyright (c) NetHack PC Development Team 1993
XNetHack may be freely distributed.  See license for details.
X
XThe MSDOS port of NetHack supports some additional or enhanced commands
Xas well as some NetHack.cnf file options specific to configuration choices 
Xused during the building of PC NetHack.  Listed below are those commands
Xand NetHack.cnf file options.
X
XRecognized MSDOS specific NetHack.cnf entries are outlined below.
X
X
XCompound options available under MSDOS if using internal screen routines
X(NO_TERMS was defined during the compile):
X
X        videoshades             May be specified to override the default 
X                                gray intensity mapping for the following 
X                                shades of gray (listed in the required 
X                                order): black gray white
X                                The choices for mapping to each shade of 
X                                gray are: dark, normal, or light. 
X                                Default: videoshades = dark normal light
X
X        videocolors             May be specified to override the default 
X                                color map used by the internal screen 
X                                management routines in the following 
X                                order: red green brown blue magenta cyan 
X                                       orange bright_green yellow bright_blue 
X                                       bright_magenta bright_cyan
X                                Default:
X                                  videocolors = 4 2 6 1 5 3 12 10 14 9 13 11
X
XBoolean Options:
X
X        IBMgraphics             Use IBM extended characters for the dungeon
X                                Default: [FALSE]
X
XBoolean options if DGK was set at compile time:
X
X        BIOS                    Allow the use of IBM ROM BIOS calls
X                                Default: [FALSE]
X        rawio                   Allow the use of raw I/O (may only be set
X                                on startup)
X                                Default: [FALSE]
X
X
XThe following options are NOT currently recognized under the MSDOS
Xport of PC NetHack:
X
X        LEVELS=                 Where to store/create per level
X                                data files.
X        SAVE=                   Where to save games.
X        BONES=                  Where to store bones files.
X        RAMDISK=                Where your RAM disk is (driver letter).
X
XMSDOS Additional/Enhanced Commands:
X
XWhile playing NetHack under MSDOS you can press the ALT key in combination 
Xwith another key to execute an extended command as an alternative method
Xto pressing the # key combination:
X
XAlt-a    adjust    - adjust inventory letters.
XAlt-c    chat      - talk to someone.
XAlt-d    dip       - dip an object into something.
XAlt-f    force     - force a lock.
XAlt-i    invoke    - invoke an object's powers.
XAlt-j    jump      - jump to a location.
XAlt-l    loot      - loot a box on the floor.
XAlt-m    monster   - use a monster's special ability.
XAlt-n    name      - name an item or type of object.
XAlt-o    offer     - offer a sacrifice to the gods.
XAlt-p    pray      - pray to the gods for help.
XAlt-r    rub       - rub a lamp.
XAlt-s    sit       - sit down.
XAlt-t    turn      - turn undead.
XAlt-u    untrap    - untrap something.
XAlt-v    version   - list compile time options for this version of NetHack.
XAlt-w    wipe      - wipe off your face.
XAlt-?    ?         - get this list of extended commands.
END_OF_FILE
if test 3605 -ne `wc -c <'sys/msdos/msdos.hlp'`; then
    echo shar: \"'sys/msdos/msdos.hlp'\" unpacked with wrong size!
fi
# end of 'sys/msdos/msdos.hlp'
echo shar: End of archive 4 \(of 18\).
cp /dev/null ark4isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 18 archives.
    echo "Now execute ./patchit3.sh"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
