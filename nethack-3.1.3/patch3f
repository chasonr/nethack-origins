Path: uunet!news.tek.com!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v18i039:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Patch3f/18
Date: 20 Jul 1993 22:32:40 GMT
Organization: Tektronix, Inc, Redmond, OR, USA
Lines: 2195
Approved: billr@saab.CNA.TEK.COM
Message-ID: <22hrq8$9pt@ying.cna.tek.com>
NNTP-Posting-Host: saab.cna.tek.com
Xref: uunet comp.sources.games:1839

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 18, Issue 39
Archive-name: nethack31/patch3f
Patch-To: nethack31: Volume 16, Issue 1-116
Environment: Amiga, Atari, Mac, MS-DOS, Windows-NT, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 6 (of 18)."
# Contents:  include/unixconf.h patches03h sys/mac/NetHack.r
# Wrapped by billr@saab on Tue Jul 20 14:57:20 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'include/unixconf.h' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'include/unixconf.h'\" to \"'include/unixconf.h.orig'\"
  mv -f 'include/unixconf.h' 'include/unixconf.h.orig'
fi
echo shar: Extracting \"'include/unixconf.h'\" \(8118 characters\)
sed "s/^X//" >'include/unixconf.h' <<'END_OF_FILE'
X/*	SCCS Id: @(#)unixconf.h	3.1	90/22/02	*/
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#ifdef UNIX
X#ifndef UNIXCONF_H
X#define UNIXCONF_H
X
X/*
X * Some include files are in a different place under SYSV
X *	BSD		   SYSV
X * <sys/time.h>		<time.h>
X * <sgtty.h>		<termio.h>
X *
X * Some routines are called differently
X * index		strchr
X * rindex		strrchr
X *
X */
X
X/* define exactly one of the following four choices */
X#define BSD		/* define for 4.n BSD  */
X			/* also for relatives like SunOS, Linux and DG/UX */
X/* #define ULTRIX	/* define for Ultrix v3.0 or higher (but not lower) */
X			/* Use BSD for < v3.0 */
X			/* "ULTRIX" not to be confused with "ultrix" */
X/* #define SYSV		/* define for System V */
X/* #define HPUX		/* Hewlett-Packard's Unix, version 6.5 or higher */
X			/* use SYSV for < v6.5 */
X
X
X/* define any of the following that are appropriate */
X/* #define SVR4		/* use in addition to SYSV for System V Release 4 */
X#define NETWORK	/* if running on a networked system */
X			/* e.g. Suns sharing a playground through NFS */
X#define SUNOS4	/* SunOS 4.x */
X/* #define LINUX  /* Another Unix clone running on Intel processors */
X/* #define GENIX	/* Yet Another Unix Clone */
X/* #define HISX		/* Bull Unix for XPS Machines */
X/* #define BOS		/* Bull Open Software - Unix for DPX/2 Machines */
X/* #define UNIXPC	/* use in addition to SYSV for AT&T 7300/3B1 */
X/* #define AIX_31	/* In AIX 3.1 (IBM RS/6000) use BSD ioctl's to gain
X			   job control (note that AIX is SYSV otherwise) */
X/* #define TEXTCOLOR	/* Use System V r3.2 terminfo color support */
X			/* or ANSI color support on termcap systems */
X			/* or X11 color	*/
X/* #define POSIX_JOB_CONTROL	/* use System V POSIX job control */
X/* #define POSIX_TYPES	/* use POSIX types for system calls and termios */
X                        /* define for platforms using the GNU libraries */
X                        /* linux, etc .. */
X
X/* #define OPENWINBUG	/* avoid a problem using OpenWindows 3.0 for X11
X			   on SunOS 4.1.x, x>= 2 */
X/* #define PYRAMID_BUG	/* avoid a bug on the Pyramid */
X/* #define BSD_43_BUG	/* for real 4.3BSD cc's without schain botch fix */
X/* #define MICROPORT_BUG /* problems with large arrays in structs */
X/* #define MICROPORT_286_BUG /* Changes needed in termcap.c to get it to
X			   run with Microport Sys V/AT version 2.4.
X			   By Jay Maynard */
X/* #define AIXPS_2BUG	/* avoid a problem with little_to_big() optimization */
X
X/* #define RANDOM	/* if neither random/srandom nor lrand48/srand48
X			   is available from your system */
X
X/* see sys/unix/snd86.shr for more information on these */
X/* #define UNIX386MUSIC	/* Play real music through speaker on systems with
X			   music driver installed */
X/* #define VPIX_MUSIC	/* Play real music through speaker on systems with
X			   built-in VPIX support */
X
X
X/*
X * The next two defines are intended mainly for the Andrew File System,
X * which does not allow hard links.  If NO_FILE_LINKS is defined, lock files
X * will be created in LOCKDIR using open() instead of in the playground using
X * link().
X *		Ralf Brown, 7/26/89 (from v2.3 hack of 10/10/88)
X */
X
X/* #define NO_FILE_LINKS	/* if no hard links */
X/* #define LOCKDIR "/usr/games/lib/nethackdir"	/* where to put locks */
X
X
X/*
X * Define DEF_PAGER as your default pager, e.g. "/bin/cat" or "/usr/ucb/more"
X * If defined, it can be overridden by the environment variable PAGER.
X * Hack will use its internal pager if DEF_PAGER is not defined.
X * (This might be preferable for security reasons.)
X * #define DEF_PAGER	".../mydir/mypager"
X */
X
X
X
X/*
X * Define PORT_HELP to be the name of the port-specfic help file.
X * This file is found in HACKDIR. 
X * Normally, you shouldn't need to change this.
X * There is currently no port-specific help for Unix systems.
X */
X/* #define PORT_HELP "Unixhelp" */
X
X/*
X * If you define MAIL, then the player will be notified of new mail
X * when it arrives.  If you also define DEF_MAILREADER then this will
X * be the default mail reader, and can be overridden by the environment
X * variable MAILREADER; otherwise an internal pager will be used.
X * A stat system call is done on the mailbox every MAILCKFREQ moves.
X */
X
X#define MAIL			/* Deliver mail during the game */
X
X/* The Andrew Message System does mail a little differently from normal
X * UNIX.  Mail is deposited in the user's own directory in ~/Mailbox
X * (another directory).  MAILBOX is the element that will be added on to
X * the user's home directory path to generate the Mailbox path - just in
X * case other Andrew sites do it differently from CMU.
X *
X *		dan lovinger
X *		dl2n+@andrew.cmu.edu (dec 19 1989)
X */
X
X/* #define AMS			/* use Andrew message system for mail */
X
X/* NO_MAILREADER is for kerberos authentcating filesystems where it is
X * essentially impossible to securely exec child processes, like mail
X * readers, when the game is running under a special token.
X *
X *             dan
X */
X
X/* #define NO_MAILREADER	/* have mail daemon just tell player of mail */
X
X#ifdef	MAIL
X# if defined(BSD) || defined(ULTRIX)
X#  ifdef AMS
X#define AMS_MAILBOX	"/Mailbox"
X#  else
X#define DEF_MAILREADER	"/usr/ucb/Mail"
X#  endif
X#else
X# if defined(SYSV) || defined(DGUX) || defined(HPUX)
X#  ifdef M_XENIX
X#define DEF_MAILREADER	"/usr/bin/mail"
X#  else
X#define DEF_MAILREADER	"/usr/bin/mailx"
X#  endif
X# else
X#define DEF_MAILREADER	"/bin/mail"
X# endif
X#endif
X
X#define MAILCKFREQ	50
X#endif	/* MAIL */
X
X
X
X#ifdef COMPRESS
X/* Some implementations of compress need a 'quiet' option.
X * If you've got one of these versions, put -q here.
X * You can also include any other strange options your compress needs.
X * If you have a normal compress, just leave it commented out.
X */
X/* #define COMPRESS_OPTIONS	"-q"	/* */
X#endif
X
X#define FCMASK	0660	/* file creation mask */
X
X
X/*
X * The remainder of the file should not need to be changed.
X */
X
X#ifdef _AUX_SOURCE
X# ifdef AUX /* gcc ? */
X#  define _SYSV_SOURCE
X#  define _BSD_SOURCE
X#else
X#  define AUX
X# endif
X#endif /* _AUX_SOURCE */
X
X/*
X * BSD/ULTRIX systems are normally the only ones that can suspend processes.
X * Suspending NetHack processes cleanly should be easy to add to other systems
X * that have SIGTSTP in the Berkeley sense.  Currently the only such systems
X * known to work are HPUX and AIX 3.1; other systems will probably require
X * tweaks to unixtty.c and ioctl.c.
X *
X * POSIX defines a slightly different type of job control, which should be
X * equivalent for NetHack's purposes.  POSIX_JOB_CONTROL should work on
X * various recent SYSV versions (with possibly tweaks to unixtty.c again).
X */
X#ifndef POSIX_JOB_CONTROL
X# if defined(BSD) || defined(ULTRIX) || defined(HPUX) || defined(AIX_31)
X#  define BSD_JOB_CONTROL
X# else
X#  if defined(SVR4)
X#   define POSIX_JOB_CONTROL
X#  endif
X# endif
X#endif
X#if defined(BSD_JOB_CONTROL) || defined(POSIX_JOB_CONTROL) || defined(AUX)
X#define SUSPEND		/* let ^Z suspend the game */
X#endif
X
X
X#if defined(BSD) || defined(ULTRIX)
X#include	<sys/time.h>
X#else
X#include	<time.h>
X#endif
X
X#define HLOCK	"perm"	/* an empty file used for locking purposes */
X
X#ifndef REDO
X#define Getchar nhgetch
X#endif
X#define tgetch getchar
X
X#define SHELL		/* do not delete the '!' command */
X
X#include "system.h"
X
X#if defined(BSD) || defined(ULTRIX)
X# if !defined(DGUX) && !defined(SUNOS4)
X#define memcpy(d, s, n)		bcopy(s, d, n)
X#define memcmp(s1, s2, n)	bcmp(s2, s1, n)
X# endif
X#else	/* therefore SYSV */
X# ifndef index	/* some systems seem to do this for you */
X#define index	strchr
X# endif
X# ifndef rindex
X#define rindex	strrchr
X# endif
X#endif
X
X/* A safety check for BOS and AUX */
X#if (defined(BOS) || defined(AUX)) && defined(NHSTDC)
X# if defined(VISION_TABLES) && defined(BRACES)
X#  undef BRACES
X# endif
X#endif
X
X/* Use the high quality random number routines. */
X#if defined(BSD) || defined(ULTRIX) || defined(RANDOM)
X#define Rand()	random()
X#else
X#define Rand()	lrand48()
X#endif
X
X#ifdef hc	/* older versions of the MetaWare High-C compiler define this */
X# ifdef __HC__
X#  undef __HC__
X# endif
X# define __HC__ hc
X# undef hc
X#endif
X
X#endif /* UNIXCONF_H */
X#endif /* UNIX */
END_OF_FILE
if test 8118 -ne `wc -c <'include/unixconf.h'`; then
    echo shar: \"'include/unixconf.h'\" unpacked with wrong size!
fi
# end of 'include/unixconf.h'
if test -f 'patches03h' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'patches03h'\" to \"'patches03h.orig'\"
  mv -f 'patches03h' 'patches03h.orig'
fi
echo shar: Extracting \"'patches03h'\" \(46114 characters\)
sed "s/^X//" >'patches03h' <<'END_OF_FILE'
X*** /tmp/da24021	Mon Jul 12 20:10:17 1993
X--- sys/mac/MacHelp	Wed Jul  7 15:49:08 1993
X***************
X*** 45,60 ****
X          the saved game in the Dungeon Folder.
X  
X  === Windows
X!     Dungeon Map, Message and Status are the essential windows used
X!         for play.  As needed, Info windows are generated and may be
X!         dismissed (clicking the close box or hitting the space bar
X!         when that window is frontmost) at any time.  Special inventory
X!         and list windows also appear in the front from time to time
X!         and are dismissed by hitting the space bar (or Return or
X!         Enter keys).  Hitting the ESCape key will dismiss a window
X!         without scrolling to the end.
X  
X!     The Extended command "Window Cleanup" may be used to restore the
X          the startup sizes and locations of the various windows.  The
X          window positions are saved in a file labelled "NetHack Windows"
X          in the appropriate preferences folder.
X--- 45,63 ----
X          the saved game in the Dungeon Folder.
X  
X  === Windows
X!     The Dungeon Map and Message windows are the essential windows used
X!         during window-mode play.  During tty-mode play there is only one
X!         window which displays the map, messages, lists and other info.
X!         For window-mode play, lists (e.g. the list of objects that may
X!         be wielded) and special info windows appear as needed.  Windows
X!         may be closed in the normal ways (i.e. clicking their close box,
X!         choosing 'Close' from the File menu or typing the command
X!         equivalent for 'Close', cmd-W) and the list windows may also be
X!         dismissed by hitting the space bar (or Return or Enter Keys).
X!         Hitting the ESCape key will dismiss special windows without
X!         scrolling to the end.
X  
X!     The command "Reposition" on the File menu may be used to restore the
X          the startup sizes and locations of the various windows.  The
X          window positions are saved in a file labelled "NetHack Windows"
X          in the appropriate preferences folder.
X***************
X*** 67,73 ****
X      page_wait    - display  --MORE--  after messages [TRUE]
X  
X      large_font is currently a pre-game option and has no effect
X!         after the Dungeon Map, Message and Status windows are created.
X  
X      Default options may be set by editing the NetHack Defaults text
X          file (possibly using TeachText or your favorite editor).
X--- 70,76 ----
X      page_wait    - display  --MORE--  after messages [TRUE]
X  
X      large_font is currently a pre-game option and has no effect
X!         after the Dungeon Map window is created.
X  
X      Default options may be set by editing the NetHack Defaults text
X          file (possibly using TeachText or your favorite editor).
X***************
X*** 74,79 ****
X--- 77,88 ----
X          Unix(tm)-style notation is used, as in:
X      OPTIONS=name:Arnold,time,!tombstone
X  
X+     It should also be mentioned here that there are two graphic
X+     interface modes available: 'mac' and 'tty'.  Choosing between
X+     these interfaces is accomplished by the option:
X+     window:mac - the default multi-window Macintosh(tm) interface.
X+     window:tty - traditional Unix(tm)-style TTY window interface.
X+ 
X      See option help (?f or ?g) for more details.
X  
X  === Movement by mouse
X***************
X*** 89,100 ****
X      The option "silent" [FALSE] controls whether or not a sound will
X      be heard when an instrument is applied.
X  
X! === Debugging-Mode
X!     Open NetHack and answer "wizard" to the "Who are you?" dialog.
X!     The debug-mode (wizard-mode) commands are then listed in the
X!     help menu, ?k.
X  
X!     WARNING: This mode is only intended for developers and others
X      interested in characterizing bugs.  Using this mode for other
X!     purposes will have confusing results and may significantly
X!     decrease your enjoyment of the game!
X--- 98,148 ----
X      The option "silent" [FALSE] controls whether or not a sound will
X      be heard when an instrument is applied.
X  
X! === Explore and Debug Modes
X!     As of version 3.1.2, you can enter Discover (aka Explore) mode or
X!     Wizard (aka Debug) mode by choosing the appropriate entries on the
X!     'Mode' popup-menu section of the "Who are you?" startup dialog.
X!     This same dialog allows you to specify your sex, role and name,
X!     of course.
X  
X!     Starting in Discover mode is essentially the same as playing in
X!     Regular mode except that if you are killed then you are given an
X!     oppurtunity to override your death.  Because of this advantage,
X!     your Discover mode scores are not entered on the scoreboard record.
X!     You also get a wand of wishing in your starting inventory and can
X!     see your intrinsic abilities using the command ctl-X (also available
X!     on the 'Explore' submenu on the File menu).
X! 
X!     Starting in Wizard mode is only intended for developers and others
X      interested in characterizing bugs.  Using this mode for other
X!     purposes will have confusing results and eliminate your enjoyment
X!     of the game!
X! 
X! === Menus
X!     As of version 3.1.2, the menus have been reworked to provide access
X!     to all the NetHack commands and a special 'Kbd' menu was added to
X!     facilitate play using only the mouse.  In some cases, a command may
X!     appear on more than one menu.  In general, the commands have been
X!     grouped to appear on an appropriate menu:
X!     File  - commands related to windows, start mode and play control.
X!     Help  - info commands generally not related to a specific game (i.e.
X!             (key descriptions, version info, internal option editor).
X!     Info  - commands that are generally game-specific (i.e. inventory
X!             related, describe features seen on the map or name things).
X!     Equip - commands related to things you might wield or wear.
X!     Act   - commands for actions that you might do alone (i.e. wait,
X!             jump) or do with another dungeon denizen (i.e. pay, chat).
X!     Magic - commands for things that you might do with items (drop,
X!             eat, read) or spell-related.
X!     Bits  - commands for things you might do to dungeon pieces (i.e.
X!             open door, loot chest, engrave on the floor, climb stairs).
X! 
X!     The key related to a command generally appears to the left of the
X!     menu entry for that command (i.e. w for wield and W for wear). A
X!     leftmost # denotes an extended command (without a related key) and
X!     a left cloverleaf or command symbol denotes a command that requires
X!     either a control or command key modifier (i.e. holding down the
X!     control or command key while hitting the related key).
X! 
X! ===
X! The members of the Macintosh NetHack port team hope you enjoy this game.
X*** /tmp/da24085	Mon Jul 12 20:10:44 1993
X--- sys/mac/News	Tue Jul  6 15:33:26 1993
X***************
X*** 1,8 ****
X  Welcome to NetHack 3.1 for the Macintosh
X  
X! This game is brought to you by Jon Watte, Hao-Yang Wang and the rest
X! of the Macintosh Team (David Hairston, Jonathan Handler, Tim Lennan,
X! Rob Menke, Chris Russo and Andy Swanson).
X  
X  Bug reports, suggestions, comments, etc., should be e-mailed to the
X  Internet address: nethack-bugs@linc.cis.upenn.edu
X--- 1,7 ----
X  Welcome to NetHack 3.1 for the Macintosh
X  
X! This game is brought to you by Jon Watte, Hao-Yang Wang, Barton House,
X! David Hairston, Jonathan Handler, Dean Luick, Rob Menke and Andy Swanson.
X  
X  Bug reports, suggestions, comments, etc., should be e-mailed to the
X  Internet address: nethack-bugs@linc.cis.upenn.edu
X*** /tmp/da24093	Mon Jul 12 20:10:46 1993
X--- sys/mac/dprintf.c	Tue Jul  6 15:20:27 1993
X***************
X*** 7,13 ****
X--- 7,15 ----
X  #include <Types.h>
X  #include <stdarg.h>
X  #include <stdio.h>
X+ #ifndef THINK_C
X  #include <strings.h>
X+ #endif
X  #include <GestaltEqu.h>
X  
X  
X***************
X*** 48,54 ****
X  	buffer [ 0 ] = strlen ( & buffer [ 1 ] ) ;
X  	if ( trapAvailable ) {
X  		if ( KeyDown ( 0x39 ) ) {									/* Caps Lock */
X! 			DebugStr ( buffer ) ;
X  		} else if ( KeyDown ( 0x3B ) && flags . window_inited &&	/* Control */
X  			( WIN_MESSAGE != -1 ) && theWindows [ WIN_MESSAGE ] . theWindow ) {
X  			pline ( "%s" , & buffer [ 1 ] ) ;
X--- 50,56 ----
X  	buffer [ 0 ] = strlen ( & buffer [ 1 ] ) ;
X  	if ( trapAvailable ) {
X  		if ( KeyDown ( 0x39 ) ) {									/* Caps Lock */
X! 			DebugStr ( (uchar *) buffer ) ;
X  		} else if ( KeyDown ( 0x3B ) && flags . window_inited &&	/* Control */
X  			( WIN_MESSAGE != -1 ) && theWindows [ WIN_MESSAGE ] . theWindow ) {
X  			pline ( "%s" , & buffer [ 1 ] ) ;
X*** /tmp/da24117	Mon Jul 12 20:10:51 1993
X--- sys/mac/macerrs.c	Mon Jul 12 13:38:42 1993
X***************
X*** 14,21 ****
X  #ifdef MAC_MPW32
X  #include <String.h>
X  #include <Strings.h>
X! #endif
X! #ifdef MAC_THINKC5
X  #include <pascal.h>
X  #endif
X  #include <Dialogs.h>
X--- 14,20 ----
X  #ifdef MAC_MPW32
X  #include <String.h>
X  #include <Strings.h>
X! #else
X  #include <pascal.h>
X  #endif
X  #include <Dialogs.h>
X*** /tmp/da24133	Mon Jul 12 20:10:55 1993
X--- sys/mac/macmain.c	Tue Jul  6 15:20:43 1993
X***************
X*** 13,26 ****
X  #include <String.h>
X  #include <Strings.h>
X  #endif
X- #ifdef MAC_THINKC5
X- #include <pascal.h>
X- #endif
X  #include <Dialogs.h>
X  #include <Packages.h>
X  #include <ToolUtils.h>
X  #include <Resources.h>
X  #include <SysEqu.h>
X  #include <Errors.h>
X  
X  #ifndef O_RDONLY
X--- 13,25 ----
X  #include <String.h>
X  #include <Strings.h>
X  #endif
X  #include <Dialogs.h>
X  #include <Packages.h>
X  #include <ToolUtils.h>
X  #include <Resources.h>
X+ #ifndef THINK_C
X  #include <SysEqu.h>
X+ #endif
X  #include <Errors.h>
X  
X  #ifndef O_RDONLY
X***************
X*** 540,546 ****
X  pascal long GetA5(void) = { 0x2E8D };					/* MOVE.L A5,(A7) */
X  pascal short GetCurJTOffset(void) = { 0x3EB8, 0x934 };   /* MOVE.W CurJTOffset,(SP) */
X  #endif
X! #ifdef MAC_THINKC5
X  pascal long GetA5(void) = { 0x2E8D };					/* MOVE.L A5,(A7) */
X  pascal short GetCurJTOffset(void) = { 0x3EB8, 0x934 };   /* MOVE.W CurJTOffset,(SP) */
X  #endif
X--- 539,545 ----
X  pascal long GetA5(void) = { 0x2E8D };					/* MOVE.L A5,(A7) */
X  pascal short GetCurJTOffset(void) = { 0x3EB8, 0x934 };   /* MOVE.W CurJTOffset,(SP) */
X  #endif
X! #ifdef THINK_C
X  pascal long GetA5(void) = { 0x2E8D };					/* MOVE.L A5,(A7) */
X  pascal short GetCurJTOffset(void) = { 0x3EB8, 0x934 };   /* MOVE.W CurJTOffset,(SP) */
X  #endif
X*** /tmp/da24165	Mon Jul 12 20:11:04 1993
X--- sys/mac/mactty.c	Mon Jul 12 13:50:08 1993
X***************
X*** 210,216 ****
X  static short
X  allocate_offscreen_world ( tty_record * record ) {
X  GWorldPtr gw = NULL ;
X! GWorldFlags world_flags = clipPix ;
X  long mem_here , mem_there , other , required_mem ;
X  Point p = { 0 , 0 } ;
X  Rect r_screen ;
X--- 210,216 ----
X  static short
X  allocate_offscreen_world ( tty_record * record ) {
X  GWorldPtr gw = NULL ;
X! GWorldFlags world_flags = 0 ;
X  long mem_here , mem_there , other , required_mem ;
X  Point p = { 0 , 0 } ;
X  Rect r_screen ;
X***************
X*** 239,249 ****
X  		}
X  		world_flags |= useTempMem ;
X  	}
X! 	s_err = NewGWorld ( & gw , 16 , & r_screen , NULL , NULL , world_flags ) ;
X  	if ( ! s_err ) {
X  		record -> offscreen_world = gw ;
X  		select_offscreen_port ( record ) ;
X  		SetOrigin ( 0 , 0 ) ;
X  		dprintf ( "New GWorld @ %lx;dm %lx CGrafPtr" , gw , gw ) ;
X  	}
X  	return s_err ;
X--- 239,250 ----
X  		}
X  		world_flags |= useTempMem ;
X  	}
X! 	s_err = NewGWorld ( & gw , 0 , & r_screen , NULL , NULL , world_flags ) ;
X  	if ( ! s_err ) {
X  		record -> offscreen_world = gw ;
X  		select_offscreen_port ( record ) ;
X  		SetOrigin ( 0 , 0 ) ;
X+ 		select_onscreen_window ( record ) ;
X  		dprintf ( "New GWorld @ %lx;dm %lx CGrafPtr" , gw , gw ) ;
X  	}
X  	return s_err ;
X***************
X*** 654,659 ****
X--- 655,661 ----
X  
X  	select_offscreen_port ( record ) ;
X  	do_set_port_font ( record ) ;
X+ 	select_onscreen_window ( record ) ;
X  }
X  
X  
X***************
X*** 703,708 ****
X--- 705,711 ----
X  			NULL , NULL , stretchPix ) ;
X  		select_offscreen_port ( record ) ;
X  		SetOrigin ( 0 , 0 ) ;
X+ 		select_onscreen_window ( record ) ;
X  	}
X  	return s_err ;
X  }
X***************
X*** 919,924 ****
X--- 922,928 ----
X  		copy_bits ( record , & r , srcCopy , NULL ) ;
X  	} else {
X  		accumulate_rect ( record , & r ) ;
X+ 		select_onscreen_window ( record ) ;
X  	}
X  }
X  
X***************
X*** 1295,1301 ****
X--- 1299,1312 ----
X  	case updateEvt :
X  		if ( event -> message == ( long ) window ) {
X  			BeginUpdate ( window ) ;
X+ 			
X+ 			/* Why do we have to erase the same area we are about to
X+ 				do a copy_bits to?
X+ 				
X  			erase_rect ( record , & ( record -> its_bits . bounds ) ) ;
X+ 			
X+ 			*/
X+ 			
X  			tty_environment_changed ( window ) ;
X  			s_err = image_tty ( window ) ;
X  			EndUpdate ( window ) ;
X***************
X*** 1444,1450 ****
X  	accumulate_rect ( record , & r ) ;
X  	if ( DRAW_DIRECT ) {
X  		update_tty ( window ) ;
X! 	}
X  }
X  
X  
X--- 1455,1462 ----
X  	accumulate_rect ( record , & r ) ;
X  	if ( DRAW_DIRECT ) {
X  		update_tty ( window ) ;
X! 	} else
X! 		select_onscreen_window ( record ) ;
X  }
X  
X  
X***************
X*** 1468,1474 ****
X  	accumulate_rect ( record , & r ) ;
X  	if ( DRAW_DIRECT ) {
X  		update_tty ( window ) ;
X! 	}
X  }
X  
X  
X--- 1480,1487 ----
X  	accumulate_rect ( record , & r ) ;
X  	if ( DRAW_DIRECT ) {
X  		update_tty ( window ) ;
X! 	} else
X! 		select_onscreen_window ( record ) ;
X  }
X  
X  
X***************
X*** 1490,1496 ****
X  	accumulate_rect ( record , & r ) ;
X  	if ( DRAW_DIRECT ) {
X  		update_tty ( window ) ;
X! 	}
X  }
X  
X  
X--- 1503,1510 ----
X  	accumulate_rect ( record , & r ) ;
X  	if ( DRAW_DIRECT ) {
X  		update_tty ( window ) ;
X! 	} else
X! 		select_onscreen_window ( record ) ;
X  }
X  
X  
X***************
X*** 1528,1534 ****
X  	accumulate_rect ( record , & r ) ;
X  	if ( DRAW_DIRECT ) {
X  		update_tty ( window ) ;
X! 	}
X  }
X  
X  
X--- 1542,1549 ----
X  	accumulate_rect ( record , & r ) ;
X  	if ( DRAW_DIRECT ) {
X  		update_tty ( window ) ;
X! 	} else
X! 		select_onscreen_window ( record ) ;
X  }
X  
X  
X*** /tmp/da24189	Mon Jul 12 20:11:15 1993
X--- sys/mac/mgetline.c	Mon Jul 12 13:14:15 1993
X***************
X*** 4,12 ****
X  
X  #include "hack.h"
X  #include "Dialogs.h"
X- #ifdef THINK_C
X- #include "pascal.h"
X- #endif
X  #include <Packages.h>
X  
X  // void FDECL(getlin,(const char *, char *));
X--- 4,9 ----
X***************
X*** 138,144 ****
X  	if ( get_line_from_key_queue ( bufp ) )
X  		return ;
X  
X! 	enter_topl_mode(query);
X  	while ((*key)(nhgetch())) ;
X  	leave_topl_mode(bufp);
X  }
X--- 135,141 ----
X  	if ( get_line_from_key_queue ( bufp ) )
X  		return ;
X  
X! 	enter_topl_mode((char *) query);
X  	while ((*key)(nhgetch())) ;
X  	leave_topl_mode(bufp);
X  }
X***************
X*** 352,363 ****
X  void
X  mac_get_ext_cmd(char *bufp)
X  {
X! #if 0	/* already in error and then broken by macmenu.c */
X! 	if (flags.popup_dialog)
X! 		popup_get_ext_cmd(bufp);
X! 	else
X! #endif
X! 		topl_getlin("# ", bufp, &topl_ext_key);
X  }
X  
X  #endif /* COM_COMPL /* */
X--- 349,355 ----
X  void
X  mac_get_ext_cmd(char *bufp)
X  {
X! 	topl_getlin("# ", bufp, &topl_ext_key);
X  }
X  
X  #endif /* COM_COMPL /* */
X*** /tmp/da24963	Tue Jul 13 09:33:38 1993
X--- sys/mac/maccurs.c	Tue Jul 13 09:29:25 1993
X***************
X*** 19,25 ****
X  static unsigned char winFileName [ 32 ] ;
X  static long winFileDir ;
X  static short winFileVol ;
X! static Handle winFileContents = NULL ;
X  
X  typedef struct WinPosSave {
X  	short			validPos ;
X--- 19,25 ----
X  static unsigned char winFileName [ 32 ] ;
X  static long winFileDir ;
X  static short winFileVol ;
X! static Handle winFileContents = (Handle) NULL ;
X  
X  typedef struct WinPosSave {
X  	short			validPos ;
X***************
X*** 54,60 ****
X  	sh = GetString ( 128 ) ;
X  	if ( sh && * sh ) {
X  		BlockMove ( * sh , winFileName , * * sh + 1 ) ;
X! 		ReleaseResource ( sh ) ;
X  	} else {
X  		BlockMove ( "\PNetHack Windows" , winFileName , 16 ) ;
X  	}
X--- 54,60 ----
X  	sh = GetString ( 128 ) ;
X  	if ( sh && * sh ) {
X  		BlockMove ( * sh , winFileName , * * sh + 1 ) ;
X! 		ReleaseResource ( (Handle) sh ) ;
X  	} else {
X  		BlockMove ( "\PNetHack Windows" , winFileName , 16 ) ;
X  	}
X*** /tmp/da24984	Tue Jul 13 09:34:07 1993
X--- sys/mac/macfile.c	Tue Jul 13 09:29:28 1993
X***************
X*** 294,300 ****
X  		if ( FSClose ( fd ) ) {
X  			return -1 ;
X  		}
X! 		FlushVol ( NULL , theDirs . dataRefNum ) ;
X  	}
X  	return 0 ;
X  }
X--- 294,300 ----
X  		if ( FSClose ( fd ) ) {
X  			return -1 ;
X  		}
X! 		FlushVol ( (StringPtr) NULL , theDirs . dataRefNum ) ;
X  	}
X  	return 0 ;
X  }
X***************
X*** 330,344 ****
X  char *
X  macgets ( int fd , char * ptr , unsigned len )
X  {
X! 	int idx = 0 ;
X! 	while ( -- len > 0 ) {
X! 		if ( macread ( fd , ptr + idx , 1 ) <= 0 )
X! 			return NULL ;
X! 		if ( ptr [ idx ++ ] == '\n' )
X! 			break ;
X! 	}
X! 	ptr [ idx ] = '\0' ;
X! 	return ptr ;
X  }
X  
X  
X--- 330,347 ----
X  char *
X  macgets ( int fd , char * ptr , unsigned len )
X  {
X!         int idx = 0 ;
X!         char c;
X! 
X!         while ( -- len > 0 ) {
X!                 if ( macread ( fd , ptr + idx , 1 ) <= 0 )
X!                         return NULL ;
X!                 c = ptr[ idx++ ];
X!                 if ( c  == '\n' || c == '\r' )
X!                         break ;
X!         }
X!         ptr [ idx ] = '\0' ;
X!         return ptr ;
X  }
X  
X  
X*** /tmp/da25018	Tue Jul 13 09:34:38 1993
X--- sys/mac/macsnd.c	Tue Jul 13 09:29:37 1993
X***************
X*** 26,32 ****
X  void
X  mac_speaker ( struct obj * instr , char * melody )
X  {
X! 	SndChannelPtr theChannel = NULL ;
X  	SndCommand theCmd ;
X  	Handle theSound ;
X  	unsigned char theName [ 32 ] ;
X--- 26,32 ----
X  void
X  mac_speaker ( struct obj * instr , char * melody )
X  {
X! 	SndChannelPtr theChannel = (SndChannelPtr) NULL ;
X  	SndCommand theCmd ;
X  	Handle theSound ;
X  	unsigned char theName [ 32 ] ;
X***************
X*** 70,76 ****
X  
X  		theCmd . cmd = soundCmd ;
X  		theCmd . param1 = 0 ;
X! 		theCmd . param2 = SND_BUFFER ( theSound ) ;
X  		err = SndDoCommand ( theChannel , & theCmd , false ) ;
X  
X  	/*
X--- 70,76 ----
X  
X  		theCmd . cmd = soundCmd ;
X  		theCmd . param1 = 0 ;
X! 		theCmd . param2 = (long) SND_BUFFER ( theSound ) ;
X  		err = SndDoCommand ( theChannel , & theCmd , false ) ;
X  
X  	/*
X*** /tmp/da25035	Tue Jul 13 09:34:51 1993
X--- sys/mac/mactopl.c	Tue Jul 13 09:29:41 1993
X***************
X*** 29,35 ****
X  queued_resp(char *resp)
X  {
X  	char buf[30];
X! 	if (try_key_queue(&buf)) {
X  		if (!resp || strchr(resp, buf[0]))
X  			return buf[0];
X  		if (digit(buf[0]) && strchr(resp, '#')) {
X--- 29,35 ----
X  queued_resp(char *resp)
X  {
X  	char buf[30];
X! 	if (try_key_queue(buf)) {
X  		if (!resp || strchr(resp, buf[0]))
X  			return buf[0];
X  		if (digit(buf[0]) && strchr(resp, '#')) {
X***************
X*** 108,114 ****
X  {
X  	unsigned char code ;
X  	char ch ;
X! 	char * re = gRespStr ;
X  
X  	if ( ev -> what != keyDown ) {
X  
X--- 108,114 ----
X  {
X  	unsigned char code ;
X  	char ch ;
X! 	char * re = (char *) gRespStr ;
X  
X  	if ( ev -> what != keyDown ) {
X  
X***************
X*** 192,204 ****
X  	DialogPtr dp ;
X  	short item ;
X  
X! 	char c = queued_resp ( resp ) ;
X  	if ( c )
X  		return c ;
X  
X  	dlogID = dlog ;
X! 	strcpy ( p , query ) ;
X! 	ParamText ( CtoPstr ( p ) , NULL , NULL , NULL ) ;
X  	dp = mv_get_new_dialog ( dlog ) ;
X  	if ( ! dp ) {
X  
X--- 192,204 ----
X  	DialogPtr dp ;
X  	short item ;
X  
X! 	char c = queued_resp ( (char *) resp ) ;
X  	if ( c )
X  		return c ;
X  
X  	dlogID = dlog ;
X! 	strcpy ( (char *) p , query ) ;
X! 	ParamText ( CtoPstr ( (char *) p ) , (uchar *) NULL , (uchar *) NULL , (uchar *) NULL ) ;
X  	dp = mv_get_new_dialog ( dlog ) ;
X  	if ( ! dp ) {
X  
X***************
X*** 289,295 ****
X  	unsigned char com [ 32 ] = { 1 , 27 } ; // margin for getitext
X  	Str255 pQuery ;
X  
X! 	char c = queued_resp ( resp ) ;
X  	if ( c )
X  		return c ;
X  
X--- 289,295 ----
X  	unsigned char com [ 32 ] = { 1 , 27 } ; // margin for getitext
X  	Str255 pQuery ;
X  
X! 	char c = queued_resp ( (char *) resp ) ;
X  	if ( c )
X  		return c ;
X  
X***************
X*** 313,319 ****
X  		strcat ( ( char * ) pQuery , resp ) ;
X  		strcat ( ( char * ) pQuery , ")" ) ;
X  	}
X! 	ParamText ( CtoPstr ( pQuery ) , NULL , NULL , NULL ) ;
X  	GetDItem ( dp , 4 , & k , & h , & r ) ;
X  	SetIText ( h , com ) ;
X  	SelIText ( dp , 4 , 0 , 0x7fff ) ;
X--- 313,319 ----
X  		strcat ( ( char * ) pQuery , resp ) ;
X  		strcat ( ( char * ) pQuery , ")" ) ;
X  	}
X! 	ParamText ( CtoPstr ( (char *) pQuery ) , (uchar *) NULL , (uchar *) NULL , (uchar *) NULL ) ;
X  	GetDItem ( dp , 4 , & k , & h , & r ) ;
X  	SetIText ( h , com ) ;
X  	SelIText ( dp , 4 , 0 , 0x7fff ) ;
X***************
X*** 368,375 ****
X  		return generic_yn_function ( query , resp , def ) ;
X  	}
X  
X! 	return do_question_dialog ( query , dia ,
X! 		( strchr ( resp , def ) - resp ) + 1 , resp ) ;
X  }
X  
X  
X--- 368,375 ----
X  		return generic_yn_function ( query , resp , def ) ;
X  	}
X  
X! 	return do_question_dialog ( (char *) query , dia ,
X! 		( strchr ( resp , def ) - resp ) + 1 , (char *) resp ) ;
X  }
X  
X  
X***************
X*** 379,388 ****
X  char def;
X  {
X  	char buf[30];
X! 	char c = queued_resp(resp);
X  	if (!c) {
X! 		enter_topl_mode(query);
X! 		topl_set_resp(resp, def);
X  
X  		do {
X  			c = readchar();
X--- 379,388 ----
X  char def;
X  {
X  	char buf[30];
X! 	char c = queued_resp((char *) resp);
X  	if (!c) {
X! 		enter_topl_mode((char *) query);
X! 		topl_set_resp((char *) resp, def);
X  
X  		do {
X  			c = readchar();
X***************
X*** 393,399 ****
X  		} while (!c);
X  
X  		topl_set_resp("", '\0');
X! 		leave_topl_mode(&buf);
X  		if (c == '#')
X  			yn_number = atoi(buf);
X  	}
X--- 393,399 ----
X  		} while (!c);
X  
X  		topl_set_resp("", '\0');
X! 		leave_topl_mode(buf);
X  		if (c == '#')
X  			yn_number = atoi(buf);
X  	}
X*** /tmp/da25052	Tue Jul 13 09:35:05 1993
X--- sys/mac/macwin.c	Tue Jul 13 09:29:45 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)macwin.c	3.1	93/01/24		  */
X  /* Copyright (c) Jon W{tte, Hao-Yang Wang, Jonathan Handler 1992. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)macwin.c	3.1	93/07/09		  */
X  /* Copyright (c) Jon W{tte, Hao-Yang Wang, Jonathan Handler 1992. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 24,31 ****
X  #include <dialogs.h>
X  #include <textedit.h>
X  #include <menus.h>
X! #ifndef MAC_THINKC5
X  #include <sysequ.h>
X  #endif
X  #include <resources.h>
X  #include <desk.h>
X--- 24,33 ----
X  #include <dialogs.h>
X  #include <textedit.h>
X  #include <menus.h>
X! #ifndef THINK_C
X  #include <sysequ.h>
X+ #else
X+ #include <LoMem.h>
X  #endif
X  #include <resources.h>
X  #include <desk.h>
X***************
X*** 38,43 ****
X--- 40,47 ----
X  #include <Sound.h>
X  #include <DiskInit.h>
X  
X+ static short kApplicInFront = 1;
X+ 
X  NhWindow * theWindows = (NhWindow *) NULL ;
X  
X  extern pascal short tty_environment_changed ( WindowPtr ) ;
X***************
X*** 61,67 ****
X   * response to a yn query, while topl_resp[topl_def_idx] is the
X   * default response to a yn query.
X   */
X! TEHandle top_line = nil;
X  int		 topl_query_len;
X  int		 topl_def_idx = -1;
X  char	 topl_resp[10] = "";
X--- 65,71 ----
X   * response to a yn query, while topl_resp[topl_def_idx] is the
X   * default response to a yn query.
X   */
X! TEHandle top_line = (TEHandle) nil;
X  int		 topl_query_len;
X  int		 topl_def_idx = -1;
X  char	 topl_resp[10] = "";
X***************
X*** 136,142 ****
X  /*
X   * Cursor movement
X   */
X! RgnHandle gMouseRgn = NULL ;
X  
X  /*
X   * _Gestalt madness - we rely heavily on the _Gestalt glue, since we
X--- 140,146 ----
X  /*
X   * Cursor movement
X   */
X! RgnHandle gMouseRgn = (RgnHandle) NULL ;
X  
X  /*
X   * _Gestalt madness - we rely heavily on the _Gestalt glue, since we
X***************
X*** 178,183 ****
X--- 182,190 ----
X  MenuHandle infoMenu ;
X  MenuHandle helpMenu ;
X  
X+ #ifdef NHW_BASE
X+ # undef NHW_BASE
X+ #endif
X  #define NHW_BASE 0
X  extern winid BASE_WINDOW ; // Was: , WIN_MAP , WIN_MESSAGE , WIN_INVEN , WIN_STATUS ;
X  
X***************
X*** 202,208 ****
X  
X  void trans_num_keys ( EventRecord * ) ;
X  
X! #ifndef MAC_THINKC5
X  /*
X   * Why aren't these declared when including hack.h - I thought
X   * they were...
X--- 209,215 ----
X  
X  void trans_num_keys ( EventRecord * ) ;
X  
X! #ifndef THINK_C
X  /*
X   * Why aren't these declared when including hack.h - I thought
X   * they were...
X***************
X*** 235,242 ****
X  static void FDECL(macCursorMenu, ( EventRecord * , WindowPtr , RgnHandle )) ;
X  static void FDECL(macCursorText, ( EventRecord * , WindowPtr , RgnHandle )) ;
X  
X! static void NDECL(UpdateMenus);
X! static void FDECL(DoMenu, (long choise));
X  
X  static void FDECL (DrawScrollbar, ( NhWindow * , WindowPtr ));
X  static void FDECL (InvalScrollBar, ( NhWindow * ));
X--- 242,249 ----
X  static void FDECL(macCursorMenu, ( EventRecord * , WindowPtr , RgnHandle )) ;
X  static void FDECL(macCursorText, ( EventRecord * , WindowPtr , RgnHandle )) ;
X  
X! void NDECL(UpdateMenus);
X! void FDECL(DoMenu, (long choise));
X  
X  static void FDECL (DrawScrollbar, ( NhWindow * , WindowPtr ));
X  static void FDECL (InvalScrollBar, ( NhWindow * ));
X***************
X*** 273,279 ****
X  	for (ix = 0; ix < NUM_MACWINDOWS; ++ix)
X  		if (mac_win == theWindows[ix].theWindow)
X  			return theWindows + ix;
X! 	return nil;
X  }
X  
X  
X--- 280,286 ----
X  	for (ix = 0; ix < NUM_MACWINDOWS; ++ix)
X  		if (mac_win == theWindows[ix].theWindow)
X  			return theWindows + ix;
X! 	return ((NhWindow *) nil) ;
X  }
X  
X  
X***************
X*** 290,295 ****
X--- 297,303 ----
X  {
X  	int i ;
X  	long l ;
X+ 	long applLimit;
X  
X  #ifdef applec
X  	UnloadSeg((Ptr) _DataInit);
X***************
X*** 296,307 ****
X  #endif
X  
X  	if ( * ( long * ) DefltStack < 50 * 1024L ) {
X! 		SetApplLimit ( 
X! 					( void * ) 
X! 					( 
X! 					( * ( long * ) CurStackBase ) - 50 * 1024L 
X! 					) 
X! 				 ) ;
X  	}
X  	MaxApplZone ( ) ;
X  	for ( i = 0 ; i < 5 ; i ++ )
X--- 304,315 ----
X  #endif
X  
X  	if ( * ( long * ) DefltStack < 50 * 1024L ) {
X! #ifdef THINK_C
X! 		applLimit = (long) CurStackBase - (50 * 1024L);
X! #else
X! 		applLimit = (* (long *) CurStackBase) - (50 * 1024L);
X! #endif
X! 		SetApplLimit ( ( void * ) applLimit ) ;
X  	}
X  	MaxApplZone ( ) ;
X  	for ( i = 0 ; i < 5 ; i ++ )
X***************
X*** 570,576 ****
X  /*HARDCODED*/
X  
X  	SetPort ( aWin -> theWindow ) ;
X! 	PenPat ( &qd . black ) ;
X  
X  	switch ( type ) {
X  		case NHW_MESSAGE :
X--- 578,584 ----
X  /*HARDCODED*/
X  
X  	SetPort ( aWin -> theWindow ) ;
X! 	PenPat ( (void *) &qd . black ) ;
X  
X  	switch ( type ) {
X  		case NHW_MESSAGE :
X***************
X*** 630,636 ****
X  mustGetMHandle(int menu_id)
X  {
X  	MenuHandle menu = GetMHandle(menu_id);
X! 	if (menu == nil) {
X  		comment("Cannot find the menu.", menu_id);
X  		ExitToShell();
X  	}
X--- 638,644 ----
X  mustGetMHandle(int menu_id)
X  {
X  	MenuHandle menu = GetMHandle(menu_id);
X! 	if (menu == (MenuHandle)  nil) {
X  		comment("Cannot find the menu.", menu_id);
X  		ExitToShell();
X  	}
X***************
X*** 650,656 ****
X  	memset ( & fcb , 0 , sizeof ( fcb ) ) ;
X  
X  	fcb . ioRefNum = CurResFile ( ) ;
X! 	fcb . ioNamePtr = name ;
X  	if ( PBGetFCBInfoSync ( & fcb ) ) {
X  		return A_LOT ;
X  	}
X--- 658,664 ----
X  	memset ( & fcb , 0 , sizeof ( fcb ) ) ;
X  
X  	fcb . ioRefNum = CurResFile ( ) ;
X! 	fcb . ioNamePtr = (uchar *) name ;
X  	if ( PBGetFCBInfoSync ( & fcb ) ) {
X  		return A_LOT ;
X  	}
X***************
X*** 663,755 ****
X  void
X  InitRes ( void )
X  {
X- #if 1	/* see macmenu.c:InitMenuRes */
X- # if 0
X- extern void InitMenuRes(void);
X- int resIDIndex ;
X- int resTypeIndex ;
X- ResType resType , infoType ;
X- Str255 name ;
X- short id ;
X- long spaceFree , totalContig ;
X- Handle theResource ;
X- static Boolean stuffLoaded = 0 ;
X- # endif
X- 
X  	InitMenuRes();
X- 
X- # if 0
X- /*
X-  * For better performance (and powerbooks) we may want to load in the
X-  * entire game to avoid spinning the disk up.
X-  * This doesn't seem to be efficient, though. Better to just use whatever
X-  * memory is assigned for default resource caching.
X-  */
X- 	if ( ! stuffLoaded ) {
X- 		PurgeSpace ( & spaceFree , & totalContig ) ;
X- 		if ( spaceFree > SpaceToLoad ( name ) ) {
X- 			dprintf ( "Space now: %ld" , spaceFree ) ;
X- 			SetResLoad ( 0 ) ;
X- 			for ( resTypeIndex = Count1Types ( ) ; resTypeIndex > 0 ; resTypeIndex -- ) {
X- 				Get1IndType ( & resType , resTypeIndex ) ;
X- 				for ( resIDIndex = Count1Resources ( resType ) ; resIDIndex > 0 ; resIDIndex -- ) {
X- 					theResource = Get1IndResource ( resType , resIDIndex ) ;
X- 					if ( ! * theResource ) {
X- 						GetResInfo ( theResource , & id , & infoType , name ) ;
X- #  ifdef applec
X- 						if ( infoType != 'CODE'  || ! EqualString ( name , "\P%A5Init" , 0 , 0 ) ) {
X- #  else
X- 						if ( infotype != 'ZREF' && infoType != 'DATA' ) {
X- #  endif
X- 							LoadResource ( theResource ) ;
X- 							HUnlock ( theResource ) ;
X- 							MoveHHi ( theResource ) ;
X- 							HLock ( theResource ) ;
X- 						}
X- 					}
X- 				}
X- 			}
X- 			SetResLoad ( 1 ) ;
X- 			stuffLoaded = 1 ;
X- 		} else {
X- 			dprintf ( "Space now: %ld" , spaceFree ) ;
X- 		}
X- 	}
X- # endif
X- 
X- #else
X- Str255 str ;
X- 
X- 	mBar = GetNewMBar ( 128 ) ;
X- 	mustwork(ResError());
X- 	SetMenuBar ( mBar ) ;
X- 	
X- 	appleMenu = mustGetMHandle ( 128 ) ;
X- 	AppendMenu ( appleMenu , ( ConstStr255Param ) "\002(-" ) ;
X- 	AddResMenu ( appleMenu , 'DRVR' ) ;
X- 
X- 	fileMenu = mustGetMHandle ( 129 ) ;
X- 	editMenu = mustGetMHandle ( 130 ) ;
X- 	actionMenu = mustGetMHandle ( 131 ) ;
X- 	inventoryMenu = mustGetMHandle ( 132 ) ;
X- 	thingsMenu = mustGetMHandle ( 133 ) ;
X- 	extendedMenu = mustGetMHandle ( 134 ) ;
X- 	infoMenu = mustGetMHandle ( 135 ) ;
X- 
X- 	if ( macFlags . help ) {
X- 		if ( HMGetHelpMenuHandle ( & helpMenu ) ) {
X- 			helpMenu = (MenuHandle) NULL ;
X- 		}
X- 	}
X- 	if ( helpMenu ) {
X- 		GetIndString ( str , 128 , 1 ) ;
X- 		AppendMenu ( helpMenu , str ) ;
X- 	} else AppendMenu ( appleMenu , str ) ;
X- 	
X- 	DrawMenuBar ( ) ;
X- 
X- 	return ;
X- #endif	/* see macmenu.c:InitMenuRes */
X  }
X  
X  
X--- 671,677 ----
X***************
X*** 1101,1107 ****
X  				oindex++;
X  			}
X  			if(com_index >= 0)
X! 				topl_replace(extcmdlist[com_index].ef_txt);
X  			return true;
X  		}
X  	}
X--- 1023,1029 ----
X  				oindex++;
X  			}
X  			if(com_index >= 0)
X! 				topl_replace((char *) extcmdlist[com_index].ef_txt);
X  			return true;
X  		}
X  	}
X***************
X*** 1144,1150 ****
X  
X  	if (!resp) {
X  		const char any_str[2] = { CHAR_ANY, '\0' };
X! 		resp = any_str;
X  		def = CHAR_ANY;
X  	}
X  
X--- 1066,1072 ----
X  
X  	if (!resp) {
X  		const char any_str[2] = { CHAR_ANY, '\0' };
X! 		resp = (char *) any_str;
X  		def = CHAR_ANY;
X  	}
X  
X***************
X*** 1226,1233 ****
X  void
X  adjust_window_pos(NhWindow *aWin, WindowPtr theWindow, short w)
X  {
X! 	const Rect scr_r   = (*GetGrayRgn())->rgnBBox,
X! 			   win_ind = { 20, 2, 3, 3 };
X  	const short	min_w = theWindow->portRect.right - theWindow->portRect.left,
X  				max_w = scr_r.right - scr_r.left - win_ind.left - win_ind.right;
X  	Point pos;
X--- 1148,1158 ----
X  void
X  adjust_window_pos(NhWindow *aWin, WindowPtr theWindow, short w)
X  {
X! #ifdef THINK_C
X! 	Rect scr_r   = (*GetGrayRgn())->rgnBBox, win_ind = { 20, 2, 3, 3 };
X! #else
X! 	const Rect scr_r   = (*GetGrayRgn())->rgnBBox, win_ind = { 20, 2, 3, 3 };
X! #endif
X  	const short	min_w = theWindow->portRect.right - theWindow->portRect.left,
X  				max_w = scr_r.right - scr_r.left - win_ind.left - win_ind.right;
X  	Point pos;
X***************
X*** 1878,1884 ****
X  			default:
X  				tmp[0] = 1;
X  				tmp[1] = topl_resp[l];
X! 				name = &tmp;
X  				break;
X  		}
X  		TextFont(geneva);
X--- 1803,1809 ----
X  			default:
X  				tmp[0] = 1;
X  				tmp[1] = topl_resp[l];
X! 				name = tmp;
X  				break;
X  		}
X  		TextFont(geneva);
X***************
X*** 1948,1954 ****
X  #if 1
X  	r.bottom = r.top + aWin->save_lin * aWin->charHeight;
X  	r.top	 = r.bottom - 1;
X! 	FillRect(&r, &qd.gray);
X  #endif
X  
X  	SetClip(org_clip);
X--- 1873,1879 ----
X  #if 1
X  	r.bottom = r.top + aWin->save_lin * aWin->charHeight;
X  	r.top	 = r.bottom - 1;
X! 	FillRect(&r, (void *) &qd.gray);
X  #endif
X  
X  	SetClip(org_clip);
X***************
X*** 2110,2116 ****
X  	if ( cursor_locked )
X  		dir = NULL ;
X  	else {
X! 		dir_bas = flags . num_pad ? ndir : sdir ;
X  		dir = strchr ( dir_bas , click_to_cmd ( where . h / nhw -> charWidth + 1 ,
X  												where . v / nhw -> charHeight ,
X  												CLICK_1 ) ) ;
X--- 2035,2041 ----
X  	if ( cursor_locked )
X  		dir = NULL ;
X  	else {
X! 		dir_bas = flags . num_pad ? (char *) ndir : (char *) sdir ;
X  		dir = strchr ( dir_bas , click_to_cmd ( where . h / nhw -> charWidth + 1 ,
X  												where . v / nhw -> charHeight ,
X  												CLICK_1 ) ) ;
X***************
X*** 2164,2193 ****
X  void
X  UpdateMenus ( void )
X  {
X- #if 1	/* see macmenu.c:AdjustMenus */
X  	extern void AdjustMenus(short);
X  
X  	AdjustMenus(0);
X- #else
X- 	WindowPeek w = ( WindowPeek ) FrontWindow ( ) ;
X- 	Boolean enable = FALSE ;
X- 	int i ;
X- 
X- 	/* All menu items are OK, except the "edit" menu */
X- 
X- 	if ( w && w -> windowKind < 0 ) {
X- 		enable = TRUE ;
X- 	}
X- 	for ( i = 1 ; i < 7 ; i ++ ) {
X- 		if ( i == 2 )
X- 			continue ;
X- 		if ( enable ) {
X- 			EnableItem ( editMenu , i ) ;
X- 		} else {
X- 			DisableItem ( editMenu , i ) ;
X- 		}
X- 	}
X- #endif	/* see macmenu.c:AdjustMenus */
X  }
X  
X  
X--- 2089,2097 ----
X***************
X*** 2194,2235 ****
X  void
X  DoMenu ( long choise )
X  {
X- #if 1	/* see macmenu.c:DoMenuEvt */
X  	extern void DoMenuEvt(long);
X  
X  	DoMenuEvt(choise);
X- #else
X- 	WindowPeek w = ( WindowPeek ) FrontWindow ( ) ;
X- 	short menu = choise >> 16 ;
X- 	short item = choise & 0xffff ;
X- 	int i ;
X- 	Str255 str ;
X- 
X- 	HiliteMenu ( menu ) ;
X- 
X- 	if ( menu == kHMHelpMenuID ) {
X- 		menu = 128 ;
X- 		item = 2 ;
X- 	}
X- 
X- 	if ( menu == 128 && item > 2 ) /* apple, DA */ {
X- 		GetItem ( appleMenu , item , str ) ;
X- 		OpenDeskAcc ( str ) ;
X- 	} else if ( menu == 130 ) /* edit */ {
X- 		SystemEdit ( item - 1 ) ;
X- 	} else {
X- 		GetIndString ( str , menu + 1 , item ) ;
X- 		if ( str [ 0 ] > QUEUE_LEN ) {
X- 			error ( "Too long command : menul %d item %d" , menu , item ) ;
X- 			str [ 0 ] = QUEUE_LEN ;
X- 		}
X- 		for ( i = 1 ; i <= str [ 0 ] ; i ++ ) {
X- 			AddToKeyQueue ( str [ i ] , 0 ) ;
X- 		}
X- 	}
X- 
X- 	HiliteMenu ( 0 ) ;
X- #endif	/* see macmenu.c:DoMenuEvt */
X  }
X  
X  
X--- 2098,2106 ----
X***************
X*** 2383,2388 ****
X--- 2254,2261 ----
X  	} else {
X  
X  		/* Suspend/resume */
X+ 		if ( ( ( theEvent -> message & osEvtMessageMask) >> 24 ) == suspendResumeMessage )
X+ 			kApplicInFront = ( theEvent -> message & resumeFlag );
X  	}
X  }
X  
X***************
X*** 2449,2471 ****
X  void
X  DimMenuBar ( void )
X  {
X- #if 1	/* see macmenu.c:AdjustMenus */
X  	extern void AdjustMenus(short);
X  
X  	AdjustMenus(1);
X- #else
X- 	if ( appleMenu ) {
X- 		DisableItem ( appleMenu , 0 ) ;
X- 		DisableItem ( fileMenu , 0 ) ;
X- 		DisableItem ( editMenu , 0 ) ;
X- 		DisableItem ( actionMenu , 0 ) ;
X- 		DisableItem ( inventoryMenu , 0 ) ;
X- 		DisableItem ( thingsMenu , 0 ) ;
X- 		DisableItem ( extendedMenu , 0 ) ;
X- 		DisableItem ( infoMenu , 0 ) ;
X- 		DrawMenuBar ( ) ;
X- 	}
X- #endif	/* see macmenu.c:AdjustMenus */
X  }
X  
X  
X--- 2322,2330 ----
X***************
X*** 2472,2494 ****
X  void
X  UndimMenuBar ( void )
X  {
X- #if 1	/* see macmenu.c:AdjustMenus */
X  	extern void AdjustMenus(short);
X  
X  	AdjustMenus(0);
X- #else
X- 	if ( appleMenu ) {
X- 		EnableItem ( appleMenu , 0 ) ;
X- 		EnableItem ( fileMenu , 0 ) ;
X- 		EnableItem ( editMenu , 0 ) ;
X- 		EnableItem ( actionMenu , 0 ) ;
X- 		EnableItem ( inventoryMenu , 0 ) ;
X- 		EnableItem ( thingsMenu , 0 ) ;
X- 		EnableItem ( extendedMenu , 0 ) ;
X- 		EnableItem ( infoMenu , 0 ) ;
X- 		DrawMenuBar ( ) ;
X- 	}
X- #endif	/* see macmenu.c:AdjustMenus */
X  }
X  
X  static int mBarDimmed = 0 ;
X--- 2331,2339 ----
X***************
X*** 2518,2526 ****
X  		SetPort ( asyDSC -> theWindow ) ;
X  		DrawScrollbar ( asyDSC , asyDSC -> theWindow ) ;
X  	}
X! 	if ( ! WaitNextEvent ( -1 , & anEvent , doDawdle , gMouseRgn ) ) {
X! 		anEvent . what = nullEvent ;
X  	}
X  	doDawdle = 0L ;
X  #if 0
X  	/* I don't want to make the tty cursor blinking. */
X--- 2363,2372 ----
X  		SetPort ( asyDSC -> theWindow ) ;
X  		DrawScrollbar ( asyDSC , asyDSC -> theWindow ) ;
X  	}
X! 	if ( kApplicInFront ) {
X! 		AdjustMenus ( 0 ) ;
X  	}
X+ 	(void) WaitNextEvent ( -1 , & anEvent , doDawdle , gMouseRgn ) ;
X  	doDawdle = 0L ;
X  #if 0
X  	/* I don't want to make the tty cursor blinking. */
X***************
X*** 2553,2559 ****
X  int
X  mac_nhgetch( void ) {
X  int ch ;
X! NhWindow * nhw = flags . window_inited ? theWindows + WIN_MAP : nil ;
X  
X  	if ( theWindows ) {
X  	NhWindow * aWin = theWindows + WIN_MESSAGE ;
X--- 2399,2405 ----
X  int
X  mac_nhgetch( void ) {
X  int ch ;
X! NhWindow * nhw = flags . window_inited ? theWindows + WIN_MAP : (NhWindow *) nil ;
X  
X  	if ( theWindows ) {
X  	NhWindow * aWin = theWindows + WIN_MESSAGE ;
X***************
X*** 2615,2621 ****
X  		gClickedToMove = 0 ;
X  	}
X  
X! #ifdef MAC_THINKC5
X  	if (ch == '\r') ch = '\n';
X  #endif
X  
X--- 2461,2467 ----
X  		gClickedToMove = 0 ;
X  	}
X  
X! #ifdef THINK_C
X  	if (ch == '\r') ch = '\n';
X  #endif
X  
X***************
X*** 3102,3219 ****
X  void
X  mac_player_selection ( void )
X  {
X! #if 0	/* see macmain.c:mac_askname() and macmenu.c:DialogAskName() */
X! 	ControlHandle	ctrl;
X! 	DialogPtr		characterDialog;
X! 	short			itemHit, lastItemSelected, type;
X! 	Rect			box;
X! 
X! 	char pc;
X! 	if ((pc = highc(pl_character[0])) != 0) {
X! 		char pbuf[QBUFSZ];
X! 		EventRecord update_evt;
X! 		if(index(pl_classes, pc) != (char*) 0) {
X! 			pl_character[0] = pc;
X! 			return;
X! 		}
X! 		putstr(WIN_MESSAGE, 0, "");
X! 		Sprintf(pbuf, "Unknown role: %c", pc);
X! 		putstr(WIN_MESSAGE, 0, pbuf);
X! 		while (CheckUpdate(&update_evt))
X! 			HandleUpdate(&update_evt);
X! 	}
X! 
X! 	characterDialog = GetNewDialog(132, (Ptr) NULL, (WindowPtr) -1);
X! 	
X! 	/*
X! 	** Default selection is random, beginning at the first item after the "Cancel" button.
X! 	*/
X! 	
X! 	lastItemSelected = rn1(12, 3);
X! 
X! 	/*
X! 	** Mark the default selection.
X! 	*/
X! 	
X! 	GetDItem(characterDialog, lastItemSelected, &type, (Handle *) &ctrl, &box);
X! 	SetCtlValue(ctrl, 1);
X! 
X! 	InitCursor ( ) ;
X! 	SetFrameItem ( characterDialog , 15 , 1 ) ;
X! 	do {
X! 		ModalDialog((ModalFilterProcPtr) CharacterDialogFilter , &itemHit);
X! 		if ((itemHit != 1) && (itemHit != 2)) {
X! 			/*
X! 			** If OK and Cancel (items 1 and 2) weren't selected then a radio button 
X! 			** was pushed.  Unmark the previous selection.
X! 			*/
X! 			
X! 			GetDItem(characterDialog, lastItemSelected, &type, (Handle *) &ctrl, &box);
X! 			SetCtlValue(ctrl, 0);
X! 			
X! 			/*
X! 			** Mark the current selection.
X! 			*/
X! 			
X! 			GetDItem(characterDialog, itemHit, &type, (Handle *) &ctrl, &box);
X! 			SetCtlValue(ctrl, 1);
X! 
X! 			/*
X! 			** Save the item number for use later.
X! 			*/
X! 			
X! 			lastItemSelected = itemHit;
X! 		}
X! 	} while ((itemHit != 1) && (itemHit != 2));
X! 	
X! 	if (itemHit == 2) {
X! 
X! 		clearlocks();
X! 		ExitToShell();
X! 
X! 	} else {
X! 		switch (lastItemSelected) {
X! 		case 3:
X! 			pl_character [ 0 ] = 'A';
X! 			break;
X! 		case 4:
X! 			pl_character [ 0 ] = 'B';
X! 			break;
X! 		case 5:
X! 			pl_character [ 0 ] = 'C';
X! 			break;
X! 		case 6:
X! 			pl_character [ 0 ] = 'E';
X! 			break;
X! 		case 7:
X! 			pl_character [ 0 ] = 'H';
X! 			break;
X! 		case 8:
X! 			pl_character [ 0 ] = 'K';
X! 			break;
X! 		case 9:
X! 			pl_character [ 0 ] = 'P';
X! 			break;
X! 		case 10:
X! 			pl_character [ 0 ] = 'R';
X! 			break;
X! 		case 11:
X! 			pl_character [ 0 ] = 'S';
X! 			break;
X! 		case 12:
X! 			pl_character [ 0 ] = 'T';
X! 			break;
X! 		case 13:
X! 			pl_character [ 0 ] = 'V';
X! 			break;
X! 		case 14:
X! 			pl_character [ 0 ] = 'W';
X! 			break;
X! 		}
X! 	}
X! 	
X! 	DisposDialog(characterDialog);
X! #endif
X  }
X  
X  void
X--- 2948,2954 ----
X  void
X  mac_player_selection ( void )
X  {
X! /* see macmain.c:mac_askname() and macmenu.c:DialogAskName() */
X  }
X  
X  void
X***************
X*** 3223,3229 ****
X  
X  
X  void
X! mac_suspend_nhwindows ( const char * )
X  {
X  	/*	Can't relly do that :-)		*/
X  }
X--- 2958,2964 ----
X  
X  
X  void
X! mac_suspend_nhwindows ( const char * foo)
X  {
X  	/*	Can't relly do that :-)		*/
X  }
X***************
X*** 3305,3312 ****
X      mac_number_pad,
X      mac_delay_output,
X  #ifdef CHANGE_COLOR
X! 	donull,
X! 	donull,
X  #endif
X      /* other defs that really should go away (they're tty specific) */
X  	0,	//    mac_start_screen,
X--- 3040,3047 ----
X      mac_number_pad,
X      mac_delay_output,
X  #ifdef CHANGE_COLOR
X! 	(void *) donull,
X! 	(void *) donull,
X  #endif
X      /* other defs that really should go away (they're tty specific) */
X  	0,	//    mac_start_screen,
X*** /tmp/da25069	Tue Jul 13 09:35:38 1993
X--- sys/mac/mmodal.c	Tue Jul 13 09:29:48 1993
X***************
X*** 122,128 ****
X  		DialogPtr dialog = FrontWindow();
X  		EventRecord evt;
X  
X! 		WaitNextEvent(everyEvent, &evt, GetCaretTime(), nil);
X  
X  		if (evt.what == keyDown)
X  			if (evt.modifiers & cmdKey) {
X--- 122,128 ----
X  		DialogPtr dialog = FrontWindow();
X  		EventRecord evt;
X  
X! 		WaitNextEvent(everyEvent, &evt, GetCaretTime(), (RgnHandle) nil);
X  
X  		if (evt.what == keyDown)
X  			if (evt.modifiers & cmdKey) {
X*** /tmp/da25086	Tue Jul 13 09:35:50 1993
X--- sys/mac/mttymain.c	Tue Jul 13 09:29:52 1993
X***************
X*** 188,194 ****
X  char kill_char = 27 ;
X  char erase_char = 8 ;
X  
X! WindowPtr _mt_window = NULL ;
X  static Boolean _mt_in_color = 0 ;
X  
X  
X--- 188,194 ----
X  char kill_char = 27 ;
X  char erase_char = 8 ;
X  
X! WindowPtr _mt_window = (WindowPtr) NULL ;
X  static Boolean _mt_in_color = 0 ;
X  
X  
X***************
X*** 201,207 ****
X  short hor , vert ;
X  
X  #if 1
X! 	if ( windowprocs == mac_procs ) {
X  		dprintf ( "Mac Windows" ) ;
X  		MT_HEIGHT -= 1 ;
X  	} else {
X--- 201,207 ----
X  short hor , vert ;
X  
X  #if 1
X! 	if ( !strcmp(windowprocs.name, mac_procs.name) ) {
X  		dprintf ( "Mac Windows" ) ;
X  		MT_HEIGHT -= 1 ;
X  	} else {
X***************
X*** 264,270 ****
X  	SizeWindow ( _mt_window , win_width + 6 , win_height + 6 , 1 ) ;
X  	dprintf ( "Checking for TTY window position" ) ;
X  	if ( RetrievePosition ( kMapWindow , & vert , & hor ) ) {
X! 		dprintf ( "\PMoving window to (%d,%d)" , hor , vert ) ;
X  		MoveWindow ( _mt_window , hor , vert , 1 ) ;
X  	}
X  	ShowWindow ( _mt_window ) ;
X--- 264,270 ----
X  	SizeWindow ( _mt_window , win_width + 6 , win_height + 6 , 1 ) ;
X  	dprintf ( "Checking for TTY window position" ) ;
X  	if ( RetrievePosition ( kMapWindow , & vert , & hor ) ) {
X! 		dprintf ( "Moving window to (%d,%d)" , hor , vert ) ;
X  		MoveWindow ( _mt_window , hor , vert , 1 ) ;
X  	}
X  	ShowWindow ( _mt_window ) ;
X***************
X*** 271,287 ****
X  	SetPort ( _mt_window ) ;
X  
X  	mustwork ( get_tty_attrib ( _mt_window , TTY_ATTRIB_FLAGS , & flag ) ) ;
X! /* Start in raw, always flushing mode */
X! 	flag |= TA_ALWAYS_REFRESH ;
X  	mustwork ( set_tty_attrib ( _mt_window , TTY_ATTRIB_FLAGS , flag ) ) ;
X  
X  	mustwork ( get_tty_attrib ( _mt_window , TTY_ATTRIB_CURSOR , & flag ) ) ;
X! 	flag |= TA_BLINKING_CURSOR | TA_WRAP_AROUND ;
X  #ifdef applec
X  	flag &= ~ TA_CR_ADD_NL ;
X  #else
X! 	flag |= ~ TA_NL_ADD_CR ;
X  #endif
X  	mustwork ( set_tty_attrib ( _mt_window , TTY_ATTRIB_CURSOR , flag ) ) ;
X  
X  	InitRes ( ) ;
X--- 271,292 ----
X  	SetPort ( _mt_window ) ;
X  
X  	mustwork ( get_tty_attrib ( _mt_window , TTY_ATTRIB_FLAGS , & flag ) ) ;
X! 	
X! 	/* Start in raw, always flushing mode */
X! 
X! 	flag |= TA_ALWAYS_REFRESH | TA_WRAP_AROUND;
X  	mustwork ( set_tty_attrib ( _mt_window , TTY_ATTRIB_FLAGS , flag ) ) ;
X  
X  	mustwork ( get_tty_attrib ( _mt_window , TTY_ATTRIB_CURSOR , & flag ) ) ;
X! 	
X! 	flag |= TA_BLINKING_CURSOR;
X! 
X  #ifdef applec
X  	flag &= ~ TA_CR_ADD_NL ;
X  #else
X! 	flag &= ~ TA_NL_ADD_CR ;
X  #endif
X+ 
X  	mustwork ( set_tty_attrib ( _mt_window , TTY_ATTRIB_CURSOR , flag ) ) ;
X  
X  	InitRes ( ) ;
X***************
X*** 332,337 ****
X--- 337,343 ----
X  EventRecord event ;
X  long sleepTime = 0 ;
X  int ret ;
X+ int key ;
X  
X  	while ( 1 ) {
X  		update_tty ( _mt_window ) ;
X***************
X*** 346,352 ****
X  		}
X  		if ( event . what == keyDown || event . what == autoKey ) {
X  			if ( ! ( event . modifiers & cmdKey ) ) {
X! 				return ( event . message & 0xff ) ;
X  			} else {
X  				DoMenu ( MenuKey ( event . message & 0xff ) ) ;
X  			}
X--- 352,360 ----
X  		}
X  		if ( event . what == keyDown || event . what == autoKey ) {
X  			if ( ! ( event . modifiers & cmdKey ) ) {
X! 				key = event . message & 0xff;
X! 				if(key == '\r') key = '\n';
X! 				return ( key ) ;
X  			} else {
X  				DoMenu ( MenuKey ( event . message & 0xff ) ) ;
X  			}
X***************
X*** 495,501 ****
X  
X  
X  void
X! xputs ( char * str ) {
X  short err ;
X  
X  	err = add_tty_string ( _mt_window , str ) ;
X--- 503,509 ----
X  
X  
X  void
X! xputs ( const char * str ) {
X  short err ;
X  
X  	err = add_tty_string ( _mt_window , str ) ;
X***************
X*** 562,568 ****
X  void
X  msmsg ( const char * str , ... ) {
X  va_list args ;
X! char * buf = alloc ( 1000 ) ;
X  
X  	va_start ( args , str ) ;
X  	vsprintf ( buf , str , args ) ;
X--- 570,576 ----
X  void
X  msmsg ( const char * str , ... ) {
X  va_list args ;
X! char * buf = (char *) alloc ( 1000 ) ;
X  
X  	va_start ( args , str ) ;
X  	vsprintf ( buf , str , args ) ;
X***************
X*** 604,614 ****
X  	mustwork ( set_tty_attrib ( _mt_window , TTY_ATTRIB_FLAGS , flag ) ) ;
X  
X  	mustwork ( get_tty_attrib ( _mt_window , TTY_ATTRIB_CURSOR , & flag ) ) ;
X  #ifdef applec
X  	flag &= ~ TA_CR_ADD_NL ;
X  #else
X! 	flag |= ~ TA_NL_ADD_CR ;
X  #endif
X  	mustwork ( set_tty_attrib ( _mt_window , TTY_ATTRIB_CURSOR , flag ) ) ;
X  
X  	flags . cbreak = 1 ;
X--- 612,624 ----
X  	mustwork ( set_tty_attrib ( _mt_window , TTY_ATTRIB_FLAGS , flag ) ) ;
X  
X  	mustwork ( get_tty_attrib ( _mt_window , TTY_ATTRIB_CURSOR , & flag ) ) ;
X+ 
X  #ifdef applec
X  	flag &= ~ TA_CR_ADD_NL ;
X  #else
X! 	flag &= ~ TA_NL_ADD_CR ;
X  #endif
X+ 
X  	mustwork ( set_tty_attrib ( _mt_window , TTY_ATTRIB_CURSOR , flag ) ) ;
X  
X  	flags . cbreak = 1 ;
X***************
X*** 641,651 ****
X--- 651,663 ----
X  	mustwork ( set_tty_attrib ( _mt_window , TTY_ATTRIB_FLAGS , flag ) ) ;
X  
X  	mustwork ( get_tty_attrib ( _mt_window , TTY_ATTRIB_CURSOR , & flag ) ) ;
X+ 
X  #ifdef applec
X  	flag |= TA_CR_ADD_NL ;
X  #else
X  	flag |= TA_NL_ADD_CR ;
X  #endif
X+ 
X  	mustwork ( set_tty_attrib ( _mt_window , TTY_ATTRIB_CURSOR , flag ) ) ;
X  
X  	tty_raw_print ( "\n" ) ;
END_OF_FILE
if test 46114 -ne `wc -c <'patches03h'`; then
    echo shar: \"'patches03h'\" unpacked with wrong size!
fi
# end of 'patches03h'
if test -f 'sys/mac/NetHack.r' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'sys/mac/NetHack.r'\" to \"'sys/mac/NetHack.r.orig'\"
  mv -f 'sys/mac/NetHack.r' 'sys/mac/NetHack.r.orig'
fi
echo shar: Extracting \"'sys/mac/NetHack.r'\" \(2834 characters\)
sed "s/^X//" >'sys/mac/NetHack.r' <<'END_OF_FILE'
X#ifndef THINK_Rez
XINCLUDE "NetHack.rsrc";			/* MENU, ALRT, WIND, ICN#, etc */
XINCLUDE "Sounds.rsrc";			/* Instruments as snd resources */
X#endif
X
X#include "Types.r"
X#include "SysTypes.r"
X#include "BalloonTypes.r"	    /* Mac resource type definitions */
X
X#ifdef THINK_Rez
Xread 'TEXT' (1000,"Help") 	 "help";
Xread 'TEXT' (1001,"WizHelp") "wizhelp";
Xread 'TEXT' (1002,"OptHelp") "opthelp";
Xread 'TEXT' (1004,"MacHelp") "MacHelp";
Xread 'TEXT' (1005,"HH") 	 "hh";
Xread 'TEXT' (1006,"History") "history";
Xread 'TEXT' (1007,"License") "license";
Xread 'TEXT' (1008,"News")	 "News";
Xread 'TEXT' (1009,"Options") "options";
X#else	/* MPW rez */
Xread 'TEXT' (1000,"Help") 	 $$Shell("Dat") "Help";
Xread 'TEXT' (1001,"WizHelp") $$Shell("Dat") "WizHelp";
Xread 'TEXT' (1002,"OptHelp") $$Shell("Dat") "OptHelp";
X/*
Xread 'TEXT' (1003,"CmdHelp") $$Shell("Dat") "CmdHelp";
X*/
Xread 'TEXT' (1004,"MacHelp") $$Shell("MacDir") "MacHelp";
X
Xread 'TEXT' (1005,"HH") 	 $$Shell("Dat") "HH";
Xread 'TEXT' (1006,"History") $$Shell("Dat") "History";
Xread 'TEXT' (1007,"License") $$Shell("Dat") "License";
X
Xread 'TEXT' (1008,"News")	 $$Shell("MacDir") "News";
Xread 'TEXT' (1009,"Options") $$Shell("ObjDir") "Options";
X
X/*
Xread 'TEXT' (1010,"Rumors")  $$Shell("ObjDir") "Rumors";
Xread 'TEXT' (1011,"Data")    $$Shell("ObjDir") "Data";
X*/
X
X/* Think C generates a SIZE resource into NetHack.rsrc, MPW needs this */
Xresource 'SIZE' (-1) {
X	reserved,
X	acceptSuspendResumeEvents,
X	reserved,
X	canBackground,
X	doesActivateOnFGSwitch,
X	backgroundAndForeground,
X	dontGetFrontClicks,
X	ignoreAppDiedEvents,
X	is32BitCompatible,
X	notHighLevelEventAware,
X	onlyLocalHLEvents,
X	notStationeryAware,
X	dontUseTextEditServices,
X	reserved,
X	reserved,
X	reserved,
X	1500 * 1024,		/* recommended */
X	1000 * 1024		/* absolute minimum, to be determined */
X};
X#endif
X
X/* System 7 help balloon information */
Xresource 'hfdr' (-5696, purgeable) { 
X     HelpMgrVersion, hmDefaultOptions, 0, 0, /* header information */ 
X	    { HMSTRResItem { /* use 'STR ' resource 2000 */ 2000 } 
X	} 
X};
X
Xresource 'STR ' (2000, purgeable) { /* Help message for app icon */
X   "NetHack 3.1\nThis is the famous Dungeons and Dragons*-like game ported to the Macintosh." 
X};
X
Xresource 'STR '(-16396, purgeable) {	/* Will be copied to the saved file. */
X	"NetHack"							/* See Inside Mac VI, page 9-21.	 */
X};
X
X
X/* Mac error decodes : 2000 - err# for common errors. Add your favorites below */
X
Xresource 'STR ' (2034) { "the disk is full"  };
Xresource 'STR ' (2036) { "there was an I/O error"  };
Xresource 'STR ' (2043) { "a file is missing"  };
Xresource 'STR ' (2044) { "the disk is write-protected"  };
Xresource 'STR ' (2047) { "the file is busy"  };
Xresource 'STR ' (2049) { "the file is already open"  };
Xresource 'STR ' (2108) { "there is not enough memory"  };
Xresource 'STR ' (2192) { "a resource is missing"  };
END_OF_FILE
if test 2834 -ne `wc -c <'sys/mac/NetHack.r'`; then
    echo shar: \"'sys/mac/NetHack.r'\" unpacked with wrong size!
fi
# end of 'sys/mac/NetHack.r'
echo shar: End of archive 6 \(of 18\).
cp /dev/null ark6isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 18 archives.
    echo "Now execute ./patchit3.sh"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
