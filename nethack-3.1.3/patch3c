Path: uunet!news.tek.com!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v18i036:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Patch3c/18
Date: 20 Jul 1993 22:32:21 GMT
Organization: Tektronix, Inc, Redmond, OR, USA
Lines: 2159
Approved: billr@saab.CNA.TEK.COM
Message-ID: <22hrpl$9pq@ying.cna.tek.com>
NNTP-Posting-Host: saab.cna.tek.com
Xref: uunet comp.sources.games:1836

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 18, Issue 36
Archive-name: nethack31/patch3c
Patch-To: nethack31: Volume 16, Issue 1-116
Environment: Amiga, Atari, Mac, MS-DOS, Windows-NT, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 3 (of 18)."
# Contents:  UPDATE3 patches03b sys/share/lev_comp.h
# Wrapped by billr@saab on Tue Jul 20 14:57:18 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'UPDATE3' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'UPDATE3'\" to \"'UPDATE3.orig'\"
  mv -f 'UPDATE3' 'UPDATE3.orig'
fi
echo shar: Extracting \"'UPDATE3'\" \(658 characters\)
sed "s/^X//" >'UPDATE3' <<'END_OF_FILE'
XMac windowing was further revised, and the Macintosh code was ported to
XThink C by Barton House.  Amiga windowing was also touched up.
X
XThe MSDOS black/gray/white intensities were changed again to avoid
Xconfusing displays on some PC hardware.  New video options were added
Xto allow configuration around any other oddities.
X
XBugs were fixed.  In particular, an elusive bug dealing with horns of
Xplenty was finally found, along with a couple VMS-specific ones such as
Xfetching some bones files.  A number of messages were revised and updated
Xas well.
X
XBones files and saved NetHack 3.1.2 games will not work with NetHack 3.1.3.
XDelete them, to avoid problems.
END_OF_FILE
if test 658 -ne `wc -c <'UPDATE3'`; then
    echo shar: \"'UPDATE3'\" unpacked with wrong size!
fi
# end of 'UPDATE3'
if test -f 'patches03b' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'patches03b'\" to \"'patches03b.orig'\"
  mv -f 'patches03b' 'patches03b.orig'
fi
echo shar: Extracting \"'patches03b'\" \(54812 characters\)
sed "s/^X//" >'patches03b' <<'END_OF_FILE'
X*** /tmp/da21027	Mon Jul 12 17:32:31 1993
X--- src/engrave.c	Fri Jul  2 15:24:48 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)engrave.c	3.1	92/05/18	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)engrave.c	3.1	92/06/16	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 61,66 ****
X--- 61,68 ----
X  	    return "ice";
X  	else if (is_lava(x,y))
X  	    return "lava";
X+ 	else if (lev->typ == DRAWBRIDGE_DOWN)
X+ 	    return "bridge";
X  	else if ((IS_ROOM(lev->typ) && !Is_earthlevel(&u.uz)) ||
X  		 IS_WALL(lev->typ) || IS_DOOR(lev->typ) || lev->typ == SDOOR)
X  	    return "floor";
X***************
X*** 441,447 ****
X  	    case FOOD_CLASS:
X  	    case SCROLL_CLASS:
X  	    case SPBOOK_CLASS:
X! 		Your("%s would get too dirty.", xname(otmp));
X  		ptext = FALSE;
X  		break;
X  
X--- 443,450 ----
X  	    case FOOD_CLASS:
X  	    case SCROLL_CLASS:
X  	    case SPBOOK_CLASS:
X! 		Your("%s would get %s.", xname(otmp),
X! 			is_ice(u.ux,u.uy) ? "all frosty" : "too dirty");
X  		ptext = FALSE;
X  		break;
X  
X***************
X*** 647,659 ****
X  				if (!Blind)
X  				    You("wipe out the message here.");
X  				else
X! 				    Your("%s gets dusty.", xname(otmp));
X  				dengr = TRUE;
X  			    } else
X  				Your("%s can't wipe out this engraving.",
X  				     xname(otmp));
X  			else
X! 			    Your("%s gets dusty.", xname(otmp));
X  			break;
X  		    default:
X  			break;
X--- 650,665 ----
X  				if (!Blind)
X  				    You("wipe out the message here.");
X  				else
X! 				    Your("%s gets %s.", xname(otmp),
X! 					  is_ice(u.ux,u.uy) ?
X! 					  "frosty" : "dusty");
X  				dengr = TRUE;
X  			    } else
X  				Your("%s can't wipe out this engraving.",
X  				     xname(otmp));
X  			else
X! 			    Your("%s gets %s.", xname(otmp),
X! 				  is_ice(u.ux,u.uy) ? "frosty" : "dusty");
X  			break;
X  		    default:
X  			break;
X*** /tmp/da21035	Mon Jul 12 17:32:35 1993
X--- src/exper.c	Wed Jul  7 16:24:25 1993
X***************
X*** 16,22 ****
X  #else
X  	if(lev < 10) return (10L*(1L << lev));
X  	if(lev < 20) return (10000L*(1L << (lev-10)));
X! 	return (10000000L*(lev-19));
X  #endif
X  }
X  
X--- 16,22 ----
X  #else
X  	if(lev < 10) return (10L*(1L << lev));
X  	if(lev < 20) return (10000L*(1L << (lev-10)));
X! 	return((long)(10000000L*(lev-19)));
X  #endif
X  }
X  
X*** /tmp/da21059	Mon Jul 12 17:32:40 1993
X--- src/files.c	Wed Jul  7 16:24:27 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)files.c	3.1	93/02/20	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)files.c	3.1	93/06/27	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 927,936 ****
X  	    /* monsyms[0] is unused */
X  	    (void) get_uchars(fp, buf, bufp, &(monsyms[1]),
X  					MAXMCLASSES-1, "MONSTERS");
X  #ifdef AMIGA
X  	} else if (!strncmpi(buf, "FONT", 4)) {
X  		char *t;
X- 		int size;
X  		extern void amii_set_text_font( char *, int );
X  
X  		if( t = strchr( buf+5, ':' ) )
X--- 927,949 ----
X  	    /* monsyms[0] is unused */
X  	    (void) get_uchars(fp, buf, bufp, &(monsyms[1]),
X  					MAXMCLASSES-1, "MONSTERS");
X+ #ifdef VIDEOSHADES
X+ 	} else if (!strncmpi(buf, "VIDEOCOLORS", 6)) {
X+ 	    uchar   transcolors[MAXCOLORS];
X+ 	    int   len;
X+ 
X+ 	    len = get_uchars(fp, buf, bufp, transcolors,
X+ 					MAXCOLORS, "VIDEOCOLORS");
X+ 	    assign_videocolors(transcolors, len);
X+ 	} else if (!strncmpi(buf, "VIDEOSHADES", 6)) {
X+ 	    int   len;
X+ 
X+ 	    len = strlen(bufp);
X+ 	    assign_videoshades(bufp, len);
X+ #endif
X  #ifdef AMIGA
X  	} else if (!strncmpi(buf, "FONT", 4)) {
X  		char *t;
X  		extern void amii_set_text_font( char *, int );
X  
X  		if( t = strchr( buf+5, ':' ) )
X***************
X*** 941,946 ****
X--- 954,961 ----
X  		}
X  	} else if (!strncmpi(buf, "PATH", 4)) {
X  		(void) strncpy(PATH, bufp, PATHLEN);
X+ #endif
X+ #ifdef AMIGA
X  	} else if (!strncmpi(buf, "PENS", 3)) {
X  # ifdef AMII_GRAPHICS
X  		int i;
X*** /tmp/da21067	Mon Jul 12 17:32:43 1993
X--- src/fountain.c	Mon Jul 12 13:45:10 1993
X***************
X*** 206,212 ****
X  		    if (++i >= A_MAX) i = 0;
X  		}
X  		display_nhwindow(WIN_MESSAGE, FALSE);
X! 		pline("A wisp of vapor escapes the fountain....");
X  		exercise(A_WIS, TRUE);
X  		levl[u.ux][u.uy].blessedftn = 0;
X  		return;
X--- 206,212 ----
X  		    if (++i >= A_MAX) i = 0;
X  		}
X  		display_nhwindow(WIN_MESSAGE, FALSE);
X! 		pline("A wisp of vapor escapes the fountain...");
X  		exercise(A_WIS, TRUE);
X  		levl[u.ux][u.uy].blessedftn = 0;
X  		return;
X***************
X*** 222,228 ****
X  
X  		case 19: /* Self-knowledge */
X  
X! 			You("feel self-knowledgeable....");
X  			display_nhwindow(WIN_MESSAGE, FALSE);
X  			enlightenment(FALSE);
X  			exercise(A_WIS, TRUE);
X--- 222,228 ----
X  
X  		case 19: /* Self-knowledge */
X  
X! 			You("feel self-knowledgeable...");
X  			display_nhwindow(WIN_MESSAGE, FALSE);
X  			enlightenment(FALSE);
X  			exercise(A_WIS, TRUE);
X***************
X*** 521,529 ****
X  #endif
X  			break;
X  		/* more odd messages --JJB */
X! 		case 11: You("hear clanking from the pipes....");
X  			break;
X! 		case 12: You("hear snatches of song from among the sewers....");
X  			break;
X  		case 19: if (Hallucination) {
X  		   pline("From the murky drain, a hand reaches up... --oops--");
X--- 521,529 ----
X  #endif
X  			break;
X  		/* more odd messages --JJB */
X! 		case 11: You("hear clanking from the pipes...");
X  			break;
X! 		case 12: You("hear snatches of song from among the sewers...");
X  			break;
X  		case 19: if (Hallucination) {
X  		   pline("From the murky drain, a hand reaches up... --oops--");
X*** /tmp/da21075	Mon Jul 12 17:32:45 1993
X--- src/hack.c	Wed Jul  7 16:24:29 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)hack.c	3.1	93/05/18	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)hack.c	3.1	93/06/15	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 126,133 ****
X  		    }
X  		    continue;
X  		case TRAPDOOR:
X! 		    pline("%s falls into and plugs a hole in the ground!",
X! 			  The(xname(otmp)));
X  		    deltrap(ttmp);
X  		    delobj(otmp);
X  		    bury_objs(rx, ry);
X--- 126,133 ----
X  		    }
X  		    continue;
X  		case TRAPDOOR:
X! 		    pline("%s falls into and plugs a hole in the %s!",
X! 			  The(xname(otmp)), surface(rx, ry));
X  		    deltrap(ttmp);
X  		    delobj(otmp);
X  		    bury_objs(rx, ry);
X***************
X*** 394,400 ****
X  register xchar x,y;
X  /* intended to be called only on ROCKs */
X  {
X! return (!(IS_STWALL(levl[x][y].typ) && (levl[x][y].diggable & W_NONDIGGABLE)));
X  }
X  
X  boolean
X--- 394,400 ----
X  register xchar x,y;
X  /* intended to be called only on ROCKs */
X  {
X! return((boolean)(!(IS_STWALL(levl[x][y].typ) && (levl[x][y].diggable & W_NONDIGGABLE))));
X  }
X  
X  boolean
X***************
X*** 401,407 ****
X  may_passwall(x,y)
X  register xchar x,y;
X  {
X! return (!(IS_STWALL(levl[x][y].typ) && (levl[x][y].diggable & W_NONPASSWALL)));
X  }
X  
X  #endif /* OVLB */
X--- 401,407 ----
X  may_passwall(x,y)
X  register xchar x,y;
X  {
X! return((boolean)(!(IS_STWALL(levl[x][y].typ) && (levl[x][y].diggable & W_NONPASSWALL))));
X  }
X  
X  #endif /* OVLB */
X***************
X*** 411,422 ****
X  bad_rock(x,y)
X  register xchar x,y;
X  {
X! 	return(IS_ROCK(levl[x][y].typ)
X  #ifdef POLYSELF
X  		    && !(passes_walls(uasmon) && may_passwall(x,y))
X  		    && (!tunnels(uasmon) || needspick(uasmon) || !may_dig(x,y))
X  #endif
X! 	);
X  }
X  
X  boolean
X--- 411,422 ----
X  bad_rock(x,y)
X  register xchar x,y;
X  {
X! 	return((boolean)(IS_ROCK(levl[x][y].typ)
X  #ifdef POLYSELF
X  		    && !(passes_walls(uasmon) && may_passwall(x,y))
X  		    && (!tunnels(uasmon) || needspick(uasmon) || !may_dig(x,y))
X  #endif
X! 	));
X  }
X  
X  boolean
X***************
X*** 423,429 ****
X  invocation_pos(x, y)
X  xchar x, y;
X  {
X!         return(Invocation_lev(&u.uz) && x == inv_pos.x && y == inv_pos.y);
X  }
X  
X  #endif /* OVL1 */
X--- 423,429 ----
X  invocation_pos(x, y)
X  xchar x, y;
X  {
X!         return((boolean)(Invocation_lev(&u.uz) && x == inv_pos.x && y == inv_pos.y));
X  }
X  
X  #endif /* OVL1 */
X***************
X*** 954,961 ****
X  		if (!is_pool(u.ux,u.uy)) {
X  			if (Is_waterlevel(&u.uz))
X  				You("pop into an air bubble.");
X  			else
X! 				You("are on solid ground again.");
X  		}
X  		else if (Is_waterlevel(&u.uz))
X  			goto stillinwater;
X--- 954,964 ----
X  		if (!is_pool(u.ux,u.uy)) {
X  			if (Is_waterlevel(&u.uz))
X  				You("pop into an air bubble.");
X+ 			else if (is_lava(u.ux, u.uy))
X+ 				You("leave the water...");	/* oops! */
X  			else
X! 				You("are on solid %s again.",
X! 				    is_ice(u.ux, u.uy) ? "ice" : "land");
X  		}
X  		else if (Is_waterlevel(&u.uz))
X  			goto stillinwater;
X***************
X*** 1081,1087 ****
X  
X  	min_x = x - 1;
X  	max_x = x + 1;
X! 	if (x < 0)
X  		min_x += step;
X  	else 
X  	if (x >= COLNO)
X--- 1084,1090 ----
X  
X  	min_x = x - 1;
X  	max_x = x + 1;
X! 	if (x < 1)
X  		min_x += step;
X  	else 
X  	if (x >= COLNO)
X*** /tmp/da21083	Mon Jul 12 17:32:49 1993
X--- src/hacklib.c	Wed Jul  7 16:24:32 1993
X***************
X*** 50,56 ****
X  digit(c)		/* is 'c' a digit? */
X      char c;
X  {
X!     return '0' <= c && c <= '9';
X  }
X  
X  boolean
X--- 50,56 ----
X  digit(c)		/* is 'c' a digit? */
X      char c;
X  {
X!     return((boolean)('0' <= c && c <= '9'));
X  }
X  
X  boolean
X***************
X*** 57,63 ****
X  letter(c)		/* is 'c' a letter?  note: '@' classed as letter */
X      char c;
X  {
X!     return ('@' <= c && c <= 'Z') || ('a' <= c && c <= 'z');
X  }
X  #endif /* OVLB */
X  
X--- 57,63 ----
X  letter(c)		/* is 'c' a letter?  note: '@' classed as letter */
X      char c;
X  {
X!     return((boolean)(('@' <= c && c <= 'Z') || ('a' <= c && c <= 'z')));
X  }
X  #endif /* OVLB */
X  
X***************
X*** 66,72 ****
X  highc(c)			/* force 'c' into uppercase */
X      char c;
X  {
X!     return ('a' <= c && c <= 'z') ? (c & ~040) : c;
X  }
X  
X  char
X--- 66,72 ----
X  highc(c)			/* force 'c' into uppercase */
X      char c;
X  {
X!     return((char)(('a' <= c && c <= 'z') ? (c & ~040) : c));
X  }
X  
X  char
X***************
X*** 73,79 ****
X  lowc(c)			/* force 'c' into lowercase */
X      char c;
X  {
X!     return ('A' <= c && c <= 'Z') ? (c | 040) : c;
X  }
X  #endif /* OVL1 */
X  
X--- 73,79 ----
X  lowc(c)			/* force 'c' into lowercase */
X      char c;
X  {
X!     return((char)(('A' <= c && c <= 'Z') ? (c | 040) : c));
X  }
X  #endif /* OVL1 */
X  
X***************
X*** 277,283 ****
X    /*  If either delta is zero then they're on an orthogonal line,
X     :  else if the deltas are equal (signs ignored) they're on a diagonal.
X     */
X!     return !dy || !dx || (dy == dx) || (dy + dx == 0);	/* (dy == -dx) */
X  }
X  
X  #endif /* OVL0 */
X--- 277,283 ----
X    /*  If either delta is zero then they're on an orthogonal line,
X     :  else if the deltas are equal (signs ignored) they're on a diagonal.
X     */
X!     return((boolean)(!dy || !dx || (dy == dx) || (dy + dx == 0)));	/* (dy == -dx) */
X  }
X  
X  #endif /* OVL0 */
X***************
X*** 295,304 ****
X  pmatch_top:
X      s = *strng++;  p = *patrn++;	/* get next chars and pre-advance */
X      if (!p)			/* end of pattern */
X! 	return (s == '\0');		/* matches iff end of string too */
X      else if (p == '*')		/* wildcard reached */
X! 	return (!*patrn || pmatch(patrn, strng-1)) ? TRUE :
X! 		s ? pmatch(patrn-1, strng) : FALSE;
X      else if (p != s && (p != '?' || !s))  /* check single character */
X  	return FALSE;		/* doesn't match */
X      else				/* return pmatch(patrn, strng); */
X--- 295,304 ----
X  pmatch_top:
X      s = *strng++;  p = *patrn++;	/* get next chars and pre-advance */
X      if (!p)			/* end of pattern */
X! 	return((boolean)(s == '\0'));		/* matches iff end of string too */
X      else if (p == '*')		/* wildcard reached */
X! 	return((boolean)((!*patrn || pmatch(patrn, strng-1)) ? TRUE :
X! 		s ? pmatch(patrn-1, strng) : FALSE));
X      else if (p != s && (p != '?' || !s))  /* check single character */
X  	return FALSE;		/* doesn't match */
X      else				/* return pmatch(patrn, strng); */
X***************
X*** 498,504 ****
X  {
X  	register struct tm *lt = getlt();
X  
X! 	return (lt->tm_wday == 5 /* friday */ && lt->tm_mday == 13);
X  }
X  
X  int
X--- 498,504 ----
X  {
X  	register struct tm *lt = getlt();
X  
X! 	return((boolean)(lt->tm_wday == 5 /* friday */ && lt->tm_mday == 13));
X  }
X  
X  int
X*** /tmp/da21091	Mon Jul 12 17:32:51 1993
X--- src/invent.c	Wed Jul  7 16:24:34 1993
X***************
X*** 701,707 ****
X  		    (otmp->oclass == TOOL_CLASS &&
X  		     otmp->otyp != MAGIC_MARKER && otmp->otyp != TOWEL))
X  		|| (!strcmp(word, "tin") &&
X! 		    (otmp->otyp != CORPSE))
X  		|| (!strcmp(word, "rub") &&
X  		    (otmp->oclass == TOOL_CLASS &&
X  		     otmp->otyp != OIL_LAMP && otmp->otyp != MAGIC_LAMP &&
X--- 701,707 ----
X  		    (otmp->oclass == TOOL_CLASS &&
X  		     otmp->otyp != MAGIC_MARKER && otmp->otyp != TOWEL))
X  		|| (!strcmp(word, "tin") &&
X! 		    (otmp->otyp != CORPSE || !tinnable(otmp)))
X  		|| (!strcmp(word, "rub") &&
X  		    (otmp->oclass == TOOL_CLASS &&
X  		     otmp->otyp != OIL_LAMP && otmp->otyp != MAGIC_LAMP &&
X***************
X*** 870,880 ****
X  
X  static boolean
X  wearing_armor() {
X! 	return(uarm || uarmc || uarmf || uarmg || uarmh || uarms
X  #ifdef TOURIST
X  		|| uarmu
X  #endif
X! 		);
X  }
X  
X  static boolean
X--- 870,880 ----
X  
X  static boolean
X  wearing_armor() {
X! 	return((boolean)(uarm || uarmc || uarmf || uarmg || uarmh || uarms
X  #ifdef TOURIST
X  		|| uarmu
X  #endif
X! 		));
X  }
X  
X  static boolean
X***************
X*** 881,887 ****
X  is_worn(otmp)
X  register struct obj *otmp;
X  {
X!     return(!!(otmp->owornmask & (W_ARMOR | W_RING | W_AMUL | W_TOOL | W_WEP)));
X  }
X  
X  static boolean
X--- 881,887 ----
X  is_worn(otmp)
X  register struct obj *otmp;
X  {
X!     return((boolean)(!!(otmp->owornmask & (W_ARMOR | W_RING | W_AMUL | W_TOOL | W_WEP))));
X  }
X  
X  static boolean
X***************
X*** 888,895 ****
X  is_fully_identified(otmp)
X  register struct obj *otmp;
X  {
X!     return(otmp->known && otmp->dknown && otmp->bknown && otmp->rknown
X! 	   && objects[otmp->otyp].oc_name_known);
X  }
X  
X  static NEARDATA const char removeables[] =
X--- 888,895 ----
X  is_fully_identified(otmp)
X  register struct obj *otmp;
X  {
X!     return((boolean)(otmp->known && otmp->dknown && otmp->bknown && otmp->rknown
X! 	   && objects[otmp->otyp].oc_name_known));
X  }
X  
X  static NEARDATA const char removeables[] =
X***************
X*** 1127,1133 ****
X  	ilet = 'a';
X  	for(otmp = invent; otmp && otmp != obj; otmp = otmp->nobj)
X  		if(++ilet > 'z') ilet = 'A';
X! 	return(otmp ? ilet : NOINVSYM);
X  }
X  
X  /*
X--- 1127,1133 ----
X  	ilet = 'a';
X  	for(otmp = invent; otmp && otmp != obj; otmp = otmp->nobj)
X  		if(++ilet > 'z') ilet = 'A';
X! 	return((char)(otmp ? ilet : NOINVSYM));
X  }
X  
X  /*
X***************
X*** 1675,1681 ****
X  
X  	if(obj->known == otmp->known ||
X  		!objects[otmp->otyp].oc_uses_known) {
X! 		return(objects[obj->otyp].oc_merge);
X  	} else return(FALSE);
X  }
X  
X--- 1675,1681 ----
X  
X  	if(obj->known == otmp->known ||
X  		!objects[otmp->otyp].oc_uses_known) {
X! 		return((boolean)(objects[obj->otyp].oc_merge));
X  	} else return(FALSE);
X  }
X  
X*** /tmp/da21099	Mon Jul 12 17:32:54 1993
X--- src/lock.c	Wed Jul  7 16:24:37 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)lock.c	3.1	93/05/28	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)lock.c	3.1	93/06/12	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 38,45 ****
X  picking_at(x, y)
X  int x, y;
X  {
X! 	return((occupation == picklock) && 
X! 	       xlock.door_or_box && (xlock.door == &levl[x][y])); 
X  }
X  
X  /* produce an occupation string appropriate for the current activity */
X--- 38,45 ----
X  picking_at(x, y)
X  int x, y;
X  {
X! 	return((boolean)((occupation == picklock) && 
X! 	       xlock.door_or_box && (xlock.door == &levl[x][y]))); 
X  }
X  
X  /* produce an occupation string appropriate for the current activity */
X***************
X*** 154,160 ****
X  	if(xlock.picktyp) {	/* blade */
X  
X  	    if(rn2(1000-(int)uwep->spe) > (992-(int)uwep->oeroded*10) && 
X! 	       !uwep->cursed) {
X  		/* for a +0 weapon, probability that it survives an unsuccessful
X  		 * attempt to force the lock is (.992)^50 = .67
X  		 */
X--- 154,160 ----
X  	if(xlock.picktyp) {	/* blade */
X  
X  	    if(rn2(1000-(int)uwep->spe) > (992-(int)uwep->oeroded*10) && 
X! 	       !uwep->cursed && !obj_resists(uwep, 0, 99)) {
X  		/* for a +0 weapon, probability that it survives an unsuccessful
X  		 * attempt to force the lock is (.992)^50 = .67
X  		 */
X*** /tmp/da21115	Mon Jul 12 17:32:59 1993
X--- src/makemon.c	Wed Jul  7 16:24:40 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)makemon.c	3.1	93/05/10	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)makemon.c	3.1	93/06/26	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 19,25 ****
X  static boolean NDECL(cmavail);
X  static int FDECL(align_shift, (struct permonst *));
X  #endif /* OVL0 */
X- STATIC_DCL boolean FDECL(is_home_elemental,(struct permonst *));
X  STATIC_DCL boolean FDECL(wrong_elem_type, (struct permonst *));
X  STATIC_DCL void FDECL(m_initgrp,(struct monst *,int,int,int));
X  STATIC_DCL void FDECL(m_initthrow,(struct monst *,int,int));
X--- 19,24 ----
X***************
X*** 36,54 ****
X  #define tooweak(monindx, lev)	(monstr[monindx] < lev)
X  
X  #ifdef OVLB
X! STATIC_OVL boolean
X  is_home_elemental(ptr)
X  register struct permonst *ptr;
X  {
X! 	if (ptr->mlet != S_ELEMENTAL) return FALSE;
X! 	if (!In_endgame(&u.uz)) return FALSE;
X! 	switch(monsndx(ptr)) {
X  		case PM_AIR_ELEMENTAL: return Is_airlevel(&u.uz);
X  		case PM_FIRE_ELEMENTAL: return Is_firelevel(&u.uz);
X  		case PM_EARTH_ELEMENTAL: return Is_earthlevel(&u.uz);
X  		case PM_WATER_ELEMENTAL: return Is_waterlevel(&u.uz);
X! 	}
X! 	return FALSE;	/* shouldn't be reached */
X  }
X  
X  /*
X--- 35,52 ----
X  #define tooweak(monindx, lev)	(monstr[monindx] < lev)
X  
X  #ifdef OVLB
X! boolean
X  is_home_elemental(ptr)
X  register struct permonst *ptr;
X  {
X! 	if (ptr->mlet == S_ELEMENTAL)
X! 	    switch (monsndx(ptr)) {
X  		case PM_AIR_ELEMENTAL: return Is_airlevel(&u.uz);
X  		case PM_FIRE_ELEMENTAL: return Is_firelevel(&u.uz);
X  		case PM_EARTH_ELEMENTAL: return Is_earthlevel(&u.uz);
X  		case PM_WATER_ELEMENTAL: return Is_waterlevel(&u.uz);
X! 	    }
X! 	return FALSE;
X  }
X  
X  /*
X***************
X*** 58,64 ****
X  wrong_elem_type(ptr)
X      register struct permonst *ptr;
X  {
X!     if (Is_earthlevel(&u.uz)) {
X  	/* no restrictions? */
X      } else if (Is_waterlevel(&u.uz)) {
X  	/* just monsters that can swim */
X--- 56,64 ----
X  wrong_elem_type(ptr)
X      register struct permonst *ptr;
X  {
X!     if (ptr->mlet == S_ELEMENTAL) {
X! 	return((boolean)(!is_home_elemental(ptr)));
X!     } else if (Is_earthlevel(&u.uz)) {
X  	/* no restrictions? */
X      } else if (Is_waterlevel(&u.uz)) {
X  	/* just monsters that can swim */
X***************
X*** 1303,1314 ****
X--- 1303,1321 ----
X  		otmp->oerodeproof = TRUE;
X  	    } else if(is_mplayer(mtmp->data) && is_sword(otmp))
X  			otmp->spe = (3 + rn2(4));
X+ 
X  	    if(otmp->otyp == CANDELABRUM_OF_INVOCATION) {
X  		otmp->spe = 0;
X  		otmp->age = 0L;
X  		otmp->lamplit = FALSE;
X  		otmp->blessed = otmp->cursed = FALSE;
X+ 	    } else if (otmp->otyp == BELL_OF_OPENING) {
X+ 		otmp->blessed = otmp->cursed = FALSE;
X+ 	    } else if (otmp->otyp == SPE_BOOK_OF_THE_DEAD) {
X+ 		otmp->blessed = FALSE;
X+ 		otmp->cursed = TRUE;
X  	    }
X+ 
X  	    mpickobj(mtmp, otmp);
X  	    return(otmp->spe);
X  	} else return(0);
X***************
X*** 1363,1376 ****
X  	if (mal < A_NEUTRAL && u.uhave.amulet) return FALSE;
X  
X  	/* minions are hostile to players that have strayed at all */
X! 	if (is_minion(ptr)) return(u.ualign.record >= 0);
X  
X  	/* Last case:  a chance of a co-aligned monster being
X  	 * hostile.  This chance is greater if the player has strayed
X  	 * (u.ualign.record negative) or the monster is not strongly aligned.
X  	 */
X! 	return !!rn2(16 + (u.ualign.record < -15 ? -15 : u.ualign.record)) &&
X! 		!!rn2(2 + abs(mal));
X  }
X  
X  /* Set malign to have the proper effect on player alignment if monster is
X--- 1370,1383 ----
X  	if (mal < A_NEUTRAL && u.uhave.amulet) return FALSE;
X  
X  	/* minions are hostile to players that have strayed at all */
X! 	if (is_minion(ptr)) return((boolean)(u.ualign.record >= 0));
X  
X  	/* Last case:  a chance of a co-aligned monster being
X  	 * hostile.  This chance is greater if the player has strayed
X  	 * (u.ualign.record negative) or the monster is not strongly aligned.
X  	 */
X! 	return((boolean)(!!rn2(16 + (u.ualign.record < -15 ? -15 : u.ualign.record)) &&
X! 		!!rn2(2 + abs(mal))));
X  }
X  
X  /* Set malign to have the proper effect on player alignment if monster is
X***************
X*** 1414,1433 ****
X  		else
X  			mtmp->malign = 20;	/* really hostile */
X  	} else if (always_peaceful(mtmp->data)) {
X  		if (mtmp->mpeaceful)
X! 			mtmp->malign = -3*max(5,abs(mal));
X  		else
X! 			mtmp->malign = 3*max(5,abs(mal)); /* renegade */
X  	} else if (always_hostile(mtmp->data)) {
X  		if (coaligned)
X  			mtmp->malign = 0;
X  		else
X! 			mtmp->malign = max(5,abs(mal));
X  	} else if (coaligned) {
X  		if (mtmp->mpeaceful)
X! 			mtmp->malign = -3*max(3,abs(mal));
X  		else	/* renegade */
X! 			mtmp->malign = max(3,abs(mal));
X  	} else	/* not coaligned and therefore hostile */
X  		mtmp->malign = abs(mal);
X  }
X--- 1421,1443 ----
X  		else
X  			mtmp->malign = 20;	/* really hostile */
X  	} else if (always_peaceful(mtmp->data)) {
X+ 		int absmal = abs(mal);
X  		if (mtmp->mpeaceful)
X! 			mtmp->malign = -3*max(5,absmal);
X  		else
X! 			mtmp->malign = 3*max(5,absmal); /* renegade */
X  	} else if (always_hostile(mtmp->data)) {
X+ 		int absmal = abs(mal);
X  		if (coaligned)
X  			mtmp->malign = 0;
X  		else
X! 			mtmp->malign = max(5,absmal);
X  	} else if (coaligned) {
X+ 		int absmal = abs(mal);
X  		if (mtmp->mpeaceful)
X! 			mtmp->malign = -3*max(3,absmal);
X  		else	/* renegade */
X! 			mtmp->malign = max(3,absmal);
X  	} else	/* not coaligned and therefore hostile */
X  		mtmp->malign = abs(mal);
X  }
X*** /tmp/da21123	Mon Jul 12 17:33:02 1993
X--- src/mcastu.c	Mon Jul 12 13:45:12 1993
X***************
X*** 196,202 ****
X  			    if (Stunned)
X  				You("struggle to keep your balance.");
X  			    else
X! 				You("reel....");
X  			    dmg = d(ACURR(A_DEX) < 12 ? 6 : 4, 4);
X  			    if(Half_spell_damage) dmg = (dmg+1) / 2;
X  			    make_stunned(HStun + dmg, FALSE);
X--- 196,202 ----
X  			    if (Stunned)
X  				You("struggle to keep your balance.");
X  			    else
X! 				You("reel...");
X  			    dmg = d(ACURR(A_DEX) < 12 ? 6 : 4, 4);
X  			    if(Half_spell_damage) dmg = (dmg+1) / 2;
X  			    make_stunned(HStun + dmg, FALSE);
X*** /tmp/da21132	Mon Jul 12 17:33:05 1993
X--- src/mhitm.c	Mon Jul 12 13:45:15 1993
X***************
X*** 1030,1036 ****
X  		if (!magr->mstun) {
X  		    magr->mstun = 1;
X  		    if (canseemon(magr))
X! 			pline("%s staggers....", Monnam(magr));
X  		}
X  		tmp = 0;
X  		break;
X--- 1030,1036 ----
X  		if (!magr->mstun) {
X  		    magr->mstun = 1;
X  		    if (canseemon(magr))
X! 			pline("%s staggers...", Monnam(magr));
X  		}
X  		tmp = 0;
X  		break;
X*** /tmp/da21141	Mon Jul 12 17:33:08 1993
X--- src/mhitu.c	Mon Jul 12 13:45:20 1993
X***************
X*** 1065,1071 ****
X  				!Is_medusa_level(&u.uz) &&
X  				!Is_waterlevel(&u.uz);
X  
X! 			    pline("%s drowns you....", Monnam(mtmp));
X  			    killer_format = KILLED_BY_AN;
X  			    Sprintf(buf, "%s by %s",
X  				    moat ? "moat" : "pool of water",
X--- 1065,1071 ----
X  				!Is_medusa_level(&u.uz) &&
X  				!Is_waterlevel(&u.uz);
X  
X! 			    pline("%s drowns you...", Monnam(mtmp));
X  			    killer_format = KILLED_BY_AN;
X  			    Sprintf(buf, "%s by %s",
X  				    moat ? "moat" : "pool of water",
X*** /tmp/da21157	Mon Jul 12 17:33:14 1993
X--- src/mklev.c	Wed Jul  7 16:24:42 1993
X***************
X*** 439,447 ****
X  	}
X  	*xx = dd.x;
X  	*yy = dd.y;
X! 	return((isok(*xx,*yy+*dy) && levl[*xx][*yy+*dy].typ == STONE)
X  	    && (isok(*xx,*yy-*dy) && !IS_POOL(levl[*xx][*yy-*dy].typ)
X! 				  && !IS_FURNITURE(levl[*xx][*yy-*dy].typ)));
X  }
X  
X  /* there should be one of these per trap, in the same order as trap.h */
X--- 439,447 ----
X  	}
X  	*xx = dd.x;
X  	*yy = dd.y;
X! 	return((boolean)((isok(*xx,*yy+*dy) && levl[*xx][*yy+*dy].typ == STONE)
X  	    && (isok(*xx,*yy-*dy) && !IS_POOL(levl[*xx][*yy-*dy].typ)
X! 				  && !IS_FURNITURE(levl[*xx][*yy-*dy].typ))));
X  }
X  
X  /* there should be one of these per trap, in the same order as trap.h */
X***************
X*** 1057,1063 ****
X  occupied(x, y)
X  register xchar x, y;
X  {
X! 	return(t_at(x, y) || levl[x][y].typ == STAIRS
X  		|| IS_FOUNTAIN(levl[x][y].typ)
X  		|| IS_THRONE(levl[x][y].typ)
X  #ifdef SINKS
X--- 1057,1063 ----
X  occupied(x, y)
X  register xchar x, y;
X  {
X! 	return((boolean)(t_at(x, y) || levl[x][y].typ == STAIRS
X  		|| IS_FOUNTAIN(levl[x][y].typ)
X  		|| IS_THRONE(levl[x][y].typ)
X  #ifdef SINKS
X***************
X*** 1067,1073 ****
X  		|| is_lava(x,y)
X  		|| is_pool(x,y)
X  		|| invocation_pos(x,y)
X! 		);
X  }
X  
X  /* make a trap somewhere (in croom if mazeflag = 0 && !tm) */
X--- 1067,1073 ----
X  		|| is_lava(x,y)
X  		|| is_pool(x,y)
X  		|| invocation_pos(x,y)
X! 		));
X  }
X  
X  /* make a trap somewhere (in croom if mazeflag = 0 && !tm) */
X*** /tmp/da21173	Mon Jul 12 17:33:19 1993
X--- src/mkmaze.c	Wed Jul  7 16:24:45 1993
X***************
X*** 129,138 ****
X      xchar x, y;
X      xchar lx, ly, hx, hy;
X  {
X!     return(occupied(x, y) ||
X  	   ((x >= lx) && (x <= hx) && (y >= ly) && (y <= hy)) ||
X  	   !((levl[x][y].typ == CORR && level.flags.is_maze_lev) ||
X! 	       levl[x][y].typ == ROOM || levl[x][y].typ == AIR));
X  }
X  
X  /* pick a location in area (lx, ly, hx, hy) but not in (nlx, nly, nhx, nhy) */
X--- 129,138 ----
X      xchar x, y;
X      xchar lx, ly, hx, hy;
X  {
X!     return((boolean)(occupied(x, y) ||
X  	   ((x >= lx) && (x <= hx) && (y >= ly) && (y <= hy)) ||
X  	   !((levl[x][y].typ == CORR && level.flags.is_maze_lev) ||
X! 	       levl[x][y].typ == ROOM || levl[x][y].typ == AIR)));
X  }
X  
X  /* pick a location in area (lx, ly, hx, hy) but not in (nlx, nly, nhx, nhy) */
X*** /tmp/da21181	Mon Jul 12 17:33:21 1993
X--- src/mkobj.c	Wed Jul  7 16:24:48 1993
X***************
X*** 591,597 ****
X  	else if (obj->otyp == GOLD_PIECE)
X  		return (int)((obj->quan + 50L) / 100L);
X  	else if (obj->otyp == HEAVY_IRON_BALL && obj->owt != 0)
X! 		return obj->owt;	/* kludge for "very" heavy iron ball */
X  	return(wt ? wt*(int)obj->quan : ((int)obj->quan + 1)>>1);
X  }
X  
X--- 591,597 ----
X  	else if (obj->otyp == GOLD_PIECE)
X  		return (int)((obj->quan + 50L) / 100L);
X  	else if (obj->otyp == HEAVY_IRON_BALL && obj->owt != 0)
X! 		return((int)(obj->owt));	/* kludge for "very" heavy iron ball */
X  	return(wt ? wt*(int)obj->quan : ((int)obj->quan + 1)>>1);
X  }
X  
X***************
X*** 681,687 ****
X  
X  	if (objects[otyp].oc_oprop == FIRE_RES) return FALSE;
X  
X! 	return((objects[otyp].oc_material <= WOOD &&
X  			objects[otyp].oc_material != LIQUID));
X  }
X  
X--- 681,687 ----
X  
X  	if (objects[otyp].oc_oprop == FIRE_RES) return FALSE;
X  
X! 	return((boolean)(objects[otyp].oc_material <= WOOD &&
X  			objects[otyp].oc_material != LIQUID));
X  }
X  
X*** /tmp/da21189	Mon Jul 12 17:33:24 1993
X--- src/mkroom.c	Wed Jul  7 16:24:50 1993
X***************
X*** 41,47 ****
X  {
X  	register int area = (sroom->hx - sroom->lx + 1)
X  			   * (sroom->hy - sroom->ly + 1);
X! 	return( area > 20 );
X  }
X  
X  void
X--- 41,47 ----
X  {
X  	register int area = (sroom->hx - sroom->lx + 1)
X  			   * (sroom->hy - sroom->ly + 1);
X! 	return((boolean)( area > 20 ));
X  }
X  
X  void
X***************
X*** 110,116 ****
X  				return;
X  			}
X  			for(i=0; shtypes[i].name; i++)
X! 				if(*ep == def_oc_syms[shtypes[i].symb])
X  				    goto gottype;
X  			if(*ep == 'g' || *ep == 'G')
X  				i = 0;
X--- 110,116 ----
X  				return;
X  			}
X  			for(i=0; shtypes[i].name; i++)
X! 				if(*ep == def_oc_syms[(int)shtypes[i].symb])
X  				    goto gottype;
X  			if(*ep == 'g' || *ep == 'G')
X  				i = 0;
X***************
X*** 296,302 ****
X  		switch(type) {
X  		    case ZOO:
X  			if(sroom->doorct)
X! 			    i = sq(dist2(sx,sy,doors[sh].x,doors[sh].y));
X  			else
X  			    i = goldlim;
X  			if(i >= goldlim) i = 5*level_difficulty();
X--- 296,305 ----
X  		switch(type) {
X  		    case ZOO:
X  			if(sroom->doorct)
X! 			{
X! 			    int distval = dist2(sx,sy,doors[sh].x,doors[sh].y);
X! 			    i = sq(distval);
X! 			}
X  			else
X  			    i = goldlim;
X  			if(i >= goldlim) i = 5*level_difficulty();
X***************
X*** 474,480 ****
X  	if (sroom == dnstairs_room)
X  		return TRUE;
X  	if (sstairs.sx && !sstairs.up)
X! 		return sroom == sstairs_room;
X  	return FALSE;
X  }
X  
X--- 477,483 ----
X  	if (sroom == dnstairs_room)
X  		return TRUE;
X  	if (sstairs.sx && !sstairs.up)
X! 		return((boolean)(sroom == sstairs_room));
X  	return FALSE;
X  }
X  
X***************
X*** 485,491 ****
X  	if (sroom == upstairs_room)
X  		return TRUE;
X  	if (sstairs.sx && sstairs.up)
X! 		return sroom == sstairs_room;
X  	return FALSE;
X  }
X  
X--- 488,494 ----
X  	if (sroom == upstairs_room)
X  		return TRUE;
X  	if (sstairs.sx && sstairs.up)
X! 		return((boolean)(sroom == sstairs_room));
X  	return FALSE;
X  }
X  
X***************
X*** 511,518 ****
X  struct mkroom *croom;
X  xchar x, y;
X  {
X! 	return (x >= croom->lx-1 && x <= croom->hx+1 &&
X! 		y >= croom->ly-1 && y <= croom->hy+1);
X  }
X  
X  boolean
X--- 514,521 ----
X  struct mkroom *croom;
X  xchar x, y;
X  {
X! 	return((boolean)(x >= croom->lx-1 && x <= croom->hx+1 &&
X! 		y >= croom->ly-1 && y <= croom->hy+1));
X  }
X  
X  boolean
X*** /tmp/da21197	Mon Jul 12 17:33:26 1993
X--- src/mon.c	Mon Jul 12 13:45:22 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)mon.c	3.1	93/05/26	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)mon.c	3.1	93/06/12	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 215,221 ****
X  		break;
X  	    default:
X  		if (Hallucination)
X! 		    Your("spider-sense is tingling....");
X  		else
X  		    You("feel apprehensive as you sense a %s flash.",
X  			warnings[warnlevel]);
X--- 215,221 ----
X  		break;
X  	    default:
X  		if (Hallucination)
X! 		    Your("spider-sense is tingling...");
X  		else
X  		    You("feel apprehensive as you sense a %s flash.",
X  			warnings[warnlevel]);
X***************
X*** 379,385 ****
X  	/* Eats topmost metal object if it is there */
X  	for (otmp = level.objects[mtmp->mx][mtmp->my];
X  						    otmp; otmp = otmp->nexthere)
X! 	    if (is_metallic(otmp) && touch_artifact(otmp,mtmp)) {
X  		    if (cansee(mtmp->mx,mtmp->my) && flags.verbose)
X  			pline("%s eats %s!", Monnam(mtmp),
X  				distant_name(otmp,doname));
X--- 379,386 ----
X  	/* Eats topmost metal object if it is there */
X  	for (otmp = level.objects[mtmp->mx][mtmp->my];
X  						    otmp; otmp = otmp->nexthere)
X! 	    if (is_metallic(otmp) && !obj_resists(otmp, 5, 95) &&
X! 		touch_artifact(otmp,mtmp)) {
X  		    if (cansee(mtmp->mx,mtmp->my) && flags.verbose)
X  			pline("%s eats %s!", Monnam(mtmp),
X  				distant_name(otmp,doname));
X***************
X*** 418,424 ****
X  	/* Engulfs others, except huge rocks and metal attached to player */
X  	for (otmp = level.objects[mtmp->mx][mtmp->my]; otmp; otmp = otmp2) {
X  	    otmp2 = otmp->nexthere;
X! 	    if(is_organic(otmp) && touch_artifact(otmp,mtmp)) {
X  		if (otmp->otyp == CORPSE && otmp->corpsenm == PM_COCKATRICE
X  						&& !resists_ston(mtmp->data))
X  		    continue;
X--- 419,426 ----
X  	/* Engulfs others, except huge rocks and metal attached to player */
X  	for (otmp = level.objects[mtmp->mx][mtmp->my]; otmp; otmp = otmp2) {
X  	    otmp2 = otmp->nexthere;
X! 	    if (is_organic(otmp) && !obj_resists(otmp, 5, 95) &&
X! 		    touch_artifact(otmp,mtmp)) {
X  		if (otmp->otyp == CORPSE && otmp->corpsenm == PM_COCKATRICE
X  						&& !resists_ston(mtmp->data))
X  		    continue;
X***************
X*** 603,609 ****
X  
X  	/* nymphs deal in stolen merchandise, but not boulders or statues */
X  	if (mtmp->data->mlet == S_NYMPH)
X! 		return !(otmp->oclass == ROCK_CLASS);
X  
X  	if(curr_mon_load(mtmp) + newload > max_mon_load(mtmp)) return(FALSE);
X  
X--- 605,611 ----
X  
X  	/* nymphs deal in stolen merchandise, but not boulders or statues */
X  	if (mtmp->data->mlet == S_NYMPH)
X! 		return((boolean)(!(otmp->oclass == ROCK_CLASS)));
X  
X  	if(curr_mon_load(mtmp) + newload > max_mon_load(mtmp)) return(FALSE);
X  
X***************
X*** 778,784 ****
X  {
X  	register int distance = dist2(mon->mx, mon->my, x, y);
X  	if (distance==2 && mon->data==&mons[PM_GRID_BUG]) return 0;
X! 	return (distance < 3);
X  }
X  
X  #endif /* OVL1 */
X--- 780,786 ----
X  {
X  	register int distance = dist2(mon->mx, mon->my, x, y);
X  	if (distance==2 && mon->data==&mons[PM_GRID_BUG]) return 0;
X! 	return((boolean)(distance < 3));
X  }
X  
X  #endif /* OVL1 */
X***************
X*** 983,988 ****
X--- 985,993 ----
X  register struct monst *mdef;
X  {
X  	mondead(mdef);
X+ #ifdef MUSE
X+ 	if(mdef->mhp > 0) return; /* lifesaved */
X+ #endif
X  	if(rn2(3)
X  #ifdef REINCARNATION
X  	   && !Is_rogue_level(&u.uz)
X***************
X*** 1137,1143 ****
X  	boolean wasinside = u.uswallow && (u.ustuck == mtmp);
X  
X  	if (dest & 1) {
X! 	    if(!canseemon(mtmp) && !sensemon(mtmp)) You("destroy it!");
X  	    else {
X  		You("destroy %s!",
X  			mtmp->mtame ? x_monnam(mtmp, 0, "poor", 0)
X--- 1142,1149 ----
X  	boolean wasinside = u.uswallow && (u.ustuck == mtmp);
X  
X  	if (dest & 1) {
X! 	    if(!wasinside && !canseemon(mtmp) && !sensemon(mtmp))
X! 		You("destroy it!");
X  	    else {
X  		You("destroy %s!",
X  			mtmp->mtame ? x_monnam(mtmp, 0, "poor", 0)
X*** /tmp/da21205	Mon Jul 12 17:33:29 1993
X--- src/mondata.c	Wed Jul  7 16:24:55 1993
X***************
X*** 30,37 ****
X  poly_when_stoned(ptr)
X      struct permonst *ptr;
X  {
X!     return (is_golem(ptr) && ptr != &mons[PM_STONE_GOLEM] &&
X! 	    !(mons[PM_STONE_GOLEM].geno & G_GENOD));	/* allow G_EXTINCT */
X  }
X  
X  boolean
X--- 30,37 ----
X  poly_when_stoned(ptr)
X      struct permonst *ptr;
X  {
X!     return((boolean)(is_golem(ptr) && ptr != &mons[PM_STONE_GOLEM] &&
X! 	    !(mons[PM_STONE_GOLEM].geno & G_GENOD)));	/* allow G_EXTINCT */
X  }
X  
X  boolean
X***************
X*** 39,45 ****
X  
X  	register struct permonst *ptr;
X  {
X! 	return(is_undead(ptr) || is_demon(ptr) || is_were(ptr));
X  }
X  
X  #endif /* OVLB */
X--- 39,45 ----
X  
X  	register struct permonst *ptr;
X  {
X! 	return((boolean)(is_undead(ptr) || is_demon(ptr) || is_were(ptr)));
X  }
X  
X  #endif /* OVLB */
X***************
X*** 70,78 ****
X  register struct permonst *ptr;
X  /* returns TRUE if monster is especially affected by silver weapons */
X  {
X! 	return (is_were(ptr) || ptr->mlet==S_VAMPIRE || is_demon(ptr) ||
X  		ptr == &mons[PM_SHADE] ||
X! 		(ptr->mlet==S_IMP && ptr != &mons[PM_TENGU]));
X  }
X  
X  #endif /* OVL0 */
X--- 70,78 ----
X  register struct permonst *ptr;
X  /* returns TRUE if monster is especially affected by silver weapons */
X  {
X! 	return((boolean)(is_were(ptr) || ptr->mlet==S_VAMPIRE || is_demon(ptr) ||
X  		ptr == &mons[PM_SHADE] ||
X! 		(ptr->mlet==S_IMP && ptr != &mons[PM_TENGU])));
X  }
X  
X  #endif /* OVL0 */
X***************
X*** 85,91 ****
X  	if (uwep && uwep->oartifact == ART_EXCALIBUR)
X  		return TRUE;
X  	else
X! 		return(haseyes(ptr));
X  }
X  
X  #endif /* OVL1 */
X--- 85,91 ----
X  	if (uwep && uwep->oartifact == ART_EXCALIBUR)
X  		return TRUE;
X  	else
X! 		return((boolean)haseyes(ptr));
X  }
X  
X  #endif /* OVL1 */
X***************
X*** 96,103 ****
X  sliparm(ptr)	/* creature will slide out of armor */
X  	register struct permonst *ptr;
X  {
X! 	return is_whirly(ptr) || ptr->msize <= MZ_SMALL ||
X! 		ptr == &mons[PM_GHOST];
X  }
X  
X  boolean
X--- 96,103 ----
X  sliparm(ptr)	/* creature will slide out of armor */
X  	register struct permonst *ptr;
X  {
X! 	return((boolean)(is_whirly(ptr) || ptr->msize <= MZ_SMALL ||
X! 		ptr == &mons[PM_GHOST]));
X  }
X  
X  boolean
X***************
X*** 104,111 ****
X  breakarm(ptr)	/* creature will break out of armor */
X  	register struct permonst *ptr;
X  {
X! 	return((bigmonst(ptr) || (ptr->msize > MZ_SMALL && !humanoid(ptr))
X! 	                || ptr == &mons[PM_MARILITH]) && !sliparm(ptr));
X  	/* Marilith is about the only case of a monster which is otherwise
X  	 * humanoid but cannot wear armor (too many arms).  Centaurs would
X  	 * be another except that they are already accounted for by
X--- 104,111 ----
X  breakarm(ptr)	/* creature will break out of armor */
X  	register struct permonst *ptr;
X  {
X! 	return((boolean)((bigmonst(ptr) || (ptr->msize > MZ_SMALL && !humanoid(ptr))
X! 	                || ptr == &mons[PM_MARILITH]) && !sliparm(ptr)));
X  	/* Marilith is about the only case of a monster which is otherwise
X  	 * humanoid but cannot wear armor (too many arms).  Centaurs would
X  	 * be another except that they are already accounted for by
X***************
X*** 120,127 ****
X  sticks(ptr)	/* creature sticks other creatures it hits */
X  	register struct permonst *ptr;
X  {
X! 	return(dmgtype(ptr,AD_STCK) || dmgtype(ptr,AD_WRAP) ||
X! 		attacktype(ptr,AT_HUGS));
X  }
X  
X  boolean
X--- 120,127 ----
X  sticks(ptr)	/* creature sticks other creatures it hits */
X  	register struct permonst *ptr;
X  {
X! 	return((boolean)(dmgtype(ptr,AD_STCK) || dmgtype(ptr,AD_WRAP) ||
X! 		attacktype(ptr,AT_HUGS)));
X  }
X  
X  boolean
X***************
X*** 270,276 ****
X  webmaker(ptr)   /* creature can spin a web */
X  	register struct permonst *ptr;
X  {
X! 	return (ptr->mlet == S_SPIDER && ptr != &mons[PM_SCORPION]);
X  }
X  #endif
X  
X--- 270,276 ----
X  webmaker(ptr)   /* creature can spin a web */
X  	register struct permonst *ptr;
X  {
X! 	return((boolean)(ptr->mlet == S_SPIDER && ptr != &mons[PM_SCORPION]));
X  }
X  #endif
X  
X***************
X*** 302,309 ****
X  levl_follower(mtmp)
X  register struct monst *mtmp;
X  {
X! 	return (mtmp->mtame || (mtmp->data->mflags2 & M2_STALK) || is_fshk(mtmp)
X! 		|| (mtmp->iswiz && !mon_has_amulet(mtmp)));
X  }
X  
X  struct permonst *
X--- 302,309 ----
X  levl_follower(mtmp)
X  register struct monst *mtmp;
X  {
X! 	return((boolean)(mtmp->mtame || (mtmp->data->mflags2 & M2_STALK) || is_fshk(mtmp)
X! 		|| (mtmp->iswiz && !mon_has_amulet(mtmp))));
X  }
X  
X  struct permonst *
X*** /tmp/da21213	Mon Jul 12 17:33:31 1993
X--- src/monmove.c	Wed Jul  7 16:24:58 1993
X***************
X*** 186,196 ****
X  			mtmp->data->mlet == S_HUMAN || mtmp->mpeaceful ||
X  			mtmp->data == &mons[PM_MINOTAUR])
X  		return(FALSE);
X! 	return(
X  #ifdef ELBERETH
X  		   sengr_at("Elbereth", x, y) ||
X  #endif
X! 		    sobj_at(SCR_SCARE_MONSTER, x, y) != (struct obj *)0);
X  }
X  
X  #endif /* OVL2 */
X--- 186,196 ----
X  			mtmp->data->mlet == S_HUMAN || mtmp->mpeaceful ||
X  			mtmp->data == &mons[PM_MINOTAUR])
X  		return(FALSE);
X! 	return((boolean)(
X  #ifdef ELBERETH
X  		   sengr_at("Elbereth", x, y) ||
X  #endif
X! 		    sobj_at(SCR_SCARE_MONSTER, x, y) != (struct obj *)0));
X  }
X  
X  #endif /* OVL2 */
X***************
X*** 1069,1076 ****
X  closed_door(x, y)
X  register int x, y;
X  {
X! 	return(IS_DOOR(levl[x][y].typ) &&
X! 			(levl[x][y].doormask & (D_LOCKED | D_CLOSED)));
X  }
X  
X  boolean
X--- 1069,1076 ----
X  closed_door(x, y)
X  register int x, y;
X  {
X! 	return((boolean)(IS_DOOR(levl[x][y].typ) &&
X! 			(levl[x][y].doormask & (D_LOCKED | D_CLOSED))));
X  }
X  
X  boolean
X***************
X*** 1077,1083 ****
X  accessible(x, y)
X  register int x, y;
X  {
X! 	return(ACCESSIBLE(levl[x][y].typ) && !closed_door(x, y));
X  }
X  
X  #endif /* OVL2 */
X--- 1077,1083 ----
X  accessible(x, y)
X  register int x, y;
X  {
X! 	return((boolean)(ACCESSIBLE(levl[x][y].typ) && !closed_door(x, y)));
X  }
X  
X  #endif /* OVL2 */
X*** /tmp/da21229	Mon Jul 12 17:33:39 1993
X--- src/mplayer.c	Fri Jul  9 15:36:18 1993
X***************
X*** 24,30 ****
X  	/* Amiga team */
X  	"Greg", "Gregg", "Keni", "Mike", "Olaf", "Richard",
X  	/* Mac team */
X! 	"David", "Johnny", "Jon", "Jonathan", "Michael", "Rob",
X  	"Tim", "Wang",
X  	/* Atari team */
X  	"Eric",
X--- 24,30 ----
X  	/* Amiga team */
X  	"Greg", "Gregg", "Keni", "Mike", "Olaf", "Richard",
X  	/* Mac team */
X! 	"Barton", "David", "Johnny", "Jon", "Jonathan", "Michael", "Rob",
X  	"Tim", "Wang",
X  	/* Atari team */
X  	"Eric",
X*** /tmp/da21237	Mon Jul 12 17:33:41 1993
X--- src/mthrowu.c	Mon Jul 12 14:14:07 1993
X***************
X*** 148,159 ****
X  #ifdef MUSE
X  		/* not possibly_unwield, which checks the object's */
X  		/* location, not its existence */
X! 		if (MON_WEP(mon) == obj)
X  			MON_NOWEP(mon);
X  #endif
X  		m_useup(mon, obj);
X  	    }
X  	}
X  
X  	if (singleobj->cursed && (dx || dy) && !rn2(7)) {
X  	    if(canseemon(mon) && flags.verbose) {
X--- 148,164 ----
X  #ifdef MUSE
X  		/* not possibly_unwield, which checks the object's */
X  		/* location, not its existence */
X! 		if (MON_WEP(mon) == obj) {
X! 			obj->owornmask &= ~W_WEP;
X  			MON_NOWEP(mon);
X+ 		}
X  #endif
X  		m_useup(mon, obj);
X  	    }
X  	}
X+ #ifdef MUSE
X+ 	singleobj->owornmask = 0; /* threw one of multiple weapons in hand? */
X+ #endif
X  
X  	if (singleobj->cursed && (dx || dy) && !rn2(7)) {
X  	    if(canseemon(mon) && flags.verbose) {
X***************
X*** 550,556 ****
X  	if((!tbx || !tby || abs(tbx) == abs(tby)) /* straight line or diagonal */
X  	   && distmin(tbx, tby, 0, 0) < BOLT_LIM) {
X  
X! 	    if(ax == u.ux && ay == u.uy) return couldsee(bx,by);
X  	    else if(clear_path(ax,ay,bx,by)) return TRUE;
X  	}
X  	return FALSE;
X--- 555,561 ----
X  	if((!tbx || !tby || abs(tbx) == abs(tby)) /* straight line or diagonal */
X  	   && distmin(tbx, tby, 0, 0) < BOLT_LIM) {
X  
X! 	    if(ax == u.ux && ay == u.uy) return((boolean)(couldsee(bx,by)));
X  	    else if(clear_path(ax,ay,bx,by)) return TRUE;
X  	}
X  	return FALSE;
X*** /tmp/da21245	Mon Jul 12 17:33:44 1993
X--- src/muse.c	Wed Jul  7 16:25:05 1993
X***************
X*** 379,385 ****
X  			m.has_defense = MUSE_SCR_CREATE_MONSTER;
X  		}
X  	}
X! botm:	return !!m.has_defense;
X  #undef nomore
X  }
X  
X--- 379,385 ----
X  			m.has_defense = MUSE_SCR_CREATE_MONSTER;
X  		}
X  	}
X! botm:	return((boolean)(!!m.has_defense));
X  #undef nomore
X  }
X  
X***************
X*** 452,458 ****
X  			}
X  			if (Is_botlevel(&u.uz)) goto mon_tele;
X  			else {
X! 			    int nlev = max(depth(&u.uz), 0);
X  			    d_level flev;
X  
X  			    if (rn2(5)) nlev = rnd(nlev + 3);
X--- 452,459 ----
X  			}
X  			if (Is_botlevel(&u.uz)) goto mon_tele;
X  			else {
X! 			    int dpth = depth(&u.uz);
X! 			    int nlev = max(dpth, 0);
X  			    d_level flev;
X  
X  			    if (rn2(5)) nlev = rnd(nlev + 3);
X***************
X*** 784,790 ****
X  		}
X  #endif
X  	}
X! 	return !!m.has_offense;
X  #undef nomore
X  }
X  
X--- 785,791 ----
X  		}
X  #endif
X  	}
X! 	return((boolean)(!!m.has_offense));
X  #undef nomore
X  }
X  
X***************
X*** 1161,1167 ****
X  			m.has_misc = MUSE_WAN_POLYMORPH;
X  		}
X  	}
X! 	return !!m.has_misc;
X  #undef nomore
X  }
X  
X--- 1162,1168 ----
X  			m.has_misc = MUSE_WAN_POLYMORPH;
X  		}
X  	}
X! 	return((boolean)(!!m.has_misc));
X  #undef nomore
X  }
X  
X***************
X*** 1346,1352 ****
X  	int typ = obj->otyp;
X  
X  	if (is_animal(mon->data) || mindless(mon->data)) return FALSE;
X! 	return((obj->oclass == WAND_CLASS && objects[typ].oc_dir == RAY)
X  		|| typ == WAN_STRIKING
X  		|| (!mon->minvis &&
X  			(typ == WAN_MAKE_INVISIBLE || typ == POT_INVISIBILITY))
X--- 1347,1353 ----
X  	int typ = obj->otyp;
X  
X  	if (is_animal(mon->data) || mindless(mon->data)) return FALSE;
X! 	return((boolean)((obj->oclass == WAND_CLASS && objects[typ].oc_dir == RAY)
X  		|| typ == WAN_STRIKING
X  		|| (!mon->minvis &&
X  			(typ == WAN_MAKE_INVISIBLE || typ == POT_INVISIBILITY))
X***************
X*** 1369,1375 ****
X  		|| typ == AMULET_OF_LIFE_SAVING
X  		|| ((mon->misc_worn_check & W_ARMG) && typ == CORPSE
X  			&& obj->corpsenm == PM_COCKATRICE)
X! 	);
X  }
X  
X  boolean
X--- 1370,1376 ----
X  		|| typ == AMULET_OF_LIFE_SAVING
X  		|| ((mon->misc_worn_check & W_ARMG) && typ == CORPSE
X  			&& obj->corpsenm == PM_COCKATRICE)
X! 	));
X  }
X  
X  boolean
X*** /tmp/da21253	Mon Jul 12 17:33:47 1993
X--- src/music.c	Wed Jul  7 16:25:07 1993
X***************
X*** 47,52 ****
X--- 47,56 ----
X  static void FDECL(speaker,(struct obj *,char *));
X  #endif
X  
X+ #ifdef AMIGA
X+ void FDECL( amii_speaker, ( struct obj *, char *, int ) );
X+ #endif
X+ 
X  /*
X   * Wake every monster in range...
X   */
X***************
X*** 433,439 ****
X  do_play_instrument(instr)
X  struct obj *instr;
X  {
X!     char buf[BUFSZ], *s, c = 'y';
X      int x,y;
X      boolean ok;
X  
X--- 437,446 ----
X  do_play_instrument(instr)
X  struct obj *instr;
X  {
X!     char buf[BUFSZ], c = 'y';
X! #ifndef	AMIGA
X! 	char *s;
X! #endif
X      int x,y;
X      boolean ok;
X  
X*** /tmp/da21261	Mon Jul 12 17:33:49 1993
X--- src/o_init.c	Wed Jul  7 16:25:10 1993
X***************
X*** 309,316 ****
X  interesting_to_discover(i)
X  register int i;
X  {
X!     return objects[i].oc_uname != NULL ||
X! 		(objects[i].oc_name_known && OBJ_DESCR(objects[i]) != NULL);
X  }
X  
X  int
X--- 309,316 ----
X  interesting_to_discover(i)
X  register int i;
X  {
X!     return((boolean)(objects[i].oc_uname != NULL ||
X! 		(objects[i].oc_name_known && OBJ_DESCR(objects[i]) != NULL)));
X  }
X  
X  int
X*** /tmp/da21277	Mon Jul 12 17:33:54 1993
X--- src/objnam.c	Thu Jul  8 13:49:50 1993
X***************
X*** 142,149 ****
X  obj_is_pname(obj)
X  register struct obj *obj;
X  {
X!     return (obj->dknown && obj->known && obj->onamelth && obj->oartifact &&
X! 	    !objects[obj->otyp].oc_unique);
X  }
X  
X  /* Give the name of an object seen at a distance.  Unlike xname/doname,
X--- 142,149 ----
X  obj_is_pname(obj)
X  register struct obj *obj;
X  {
X!     return((boolean)(obj->dknown && obj->known && obj->onamelth && obj->oartifact &&
X! 	    !objects[obj->otyp].oc_unique));
X  }
X  
X  /* Give the name of an object seen at a distance.  Unlike xname/doname,
X***************
X*** 441,446 ****
X--- 441,447 ----
X  		Strcpy(prefix, "a ");
X  
X  	if (obj->bknown && 
X+ 	    obj->oclass != GOLD_CLASS &&
X  	    (obj->otyp != POT_WATER || !objects[POT_WATER].oc_name_known
X  		|| (!obj->cursed && !obj->blessed))) {
X  	    /* allow 'blessed clear potion' if we don't know it's holy water;
X***************
X*** 993,1000 ****
X  
X  	/* Japanese words: plurals are the same as singlar */
X  	if ((len == 2 && !strcmp(str, "ya")) ||
X! 	    (len > 2 && !strcmp(spot-2, " ya")))
X! 	    goto bottom;
X  
X  	/* Default: append an 's' */
X  	Strcpy(spot+1, "s");
X--- 994,1007 ----
X  
X  	/* Japanese words: plurals are the same as singlar */
X  	if ((len == 2 && !strcmp(str, "ya")) ||
X! 	    (len > 2 && !strcmp(spot-2, " ya")) ||
X! 	    (len >= 5 && (!strcmp(spot-4, "ninja") ||
X! 			!strcmp(spot-4, "ronin") ||
X! 			!strcmp(spot-4, "shito") ||
X! 			!strcmp(spot-4, "tengu"))) ||
X! 	    (len >= 7 && (!strcmp(spot-6, "samurai") ||
X! 			!strcmp(spot-6, "gunyoki"))))
X! 		goto bottom;
X  
X  	/* Default: append an 's' */
X  	Strcpy(spot+1, "s");
X*** /tmp/da21285	Mon Jul 12 17:33:58 1993
X--- src/options.c	Fri Jul  2 14:16:55 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)options.c	3.1	93/05/29	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)options.c	3.1	93/06/27	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 159,164 ****
X--- 159,168 ----
X  	{ "pettype",  "your preferred initial pet type," },
X  	{ "pickup_types", "types of objects to pick up automatically," },
X  	{ "scores",   "the parts of the score list you wish to see," },
X+ #ifdef VIDEOSHADES
X+ 	{ "videocolors", "color mappings for internal screen routines," },
X+ 	{ "videoshades", "gray shades to map to black/gray/white," },
X+ #endif
X  	{ "windowtype", "windowing system to use." },
X  	{ NULL, NULL }
X  };
X***************
X*** 171,176 ****
X--- 175,185 ----
X  extern boolean colors_changed;	/* in tos.c */
X  #endif
X  
X+ #ifdef VIDEOSHADES
X+ extern char *shade[3];		  /* in sys/msdos/video.c */
X+ extern char ttycolors[MAXCOLORS]; /* in sys/msdos/video.c */
X+ #endif
X+ 
X  extern const char *roles[];	/* from u_init.c */
X  
X  static char def_inv_order[MAXOCLASSES] = {
X***************
X*** 838,843 ****
X--- 847,875 ----
X  		return;
X  	}
X  
X+ #ifdef VIDEOSHADES
X+ 	/* videocolors:string */
X+ 	if (!strncmpi(opts, "videocolors", 6)) {
X+ 		int length;
X+ 
X+ 		if (!(opts = string_for_env_opt("videocolors", opts, FALSE))) {
X+ 			return;
X+ 		}
X+ 		badoption(opts);
X+ 		return;
X+ 	}
X+ 	/* videoshades:string */
X+ 	if (!strncmpi(opts, "videoshades", 6)) {
X+ 		int length;
X+ 
X+ 		if (!(opts = string_for_env_opt("videoshades", opts, FALSE))) {
X+ 			return;
X+ 		}
X+ 		badoption(opts);
X+ 		return;
X+ 	}
X+ #endif /* VIDEOSHADES */
X+ 
X  	if (!strncmpi(opts, "windowtype", 3)) {
X  	    if ((op = string_for_env_opt("windowtype", opts, FALSE)) != 0) {
X  		char buf[16];
X***************
X*** 1057,1066 ****
X  	    oc_to_str(flags.pickup_types, ocl);
X  	    Sprintf(buf, " pickup_types: %s", (ocl[0]) ? ocl : "all");
X  	    putstr(tmpwin, 0, buf);
X! 	    Sprintf(buf, " scores: %utop/%uaround%s",
X  		        flags.end_top, flags.end_around,
X  		        (flags.end_own ? "/own" : ""));
X  	    putstr(tmpwin, 0, buf);
X  	    Sprintf(buf, " windowtype: %s", windowprocs.name);
X  	    putstr(tmpwin, 0, buf);
X  	    display_nhwindow(tmpwin, TRUE);
X--- 1089,1110 ----
X  	    oc_to_str(flags.pickup_types, ocl);
X  	    Sprintf(buf, " pickup_types: %s", (ocl[0]) ? ocl : "all");
X  	    putstr(tmpwin, 0, buf);
X! 	    Sprintf(buf, " scores: %u top/%u around%s",
X  		        flags.end_top, flags.end_around,
X  		        (flags.end_own ? "/own" : ""));
X  	    putstr(tmpwin, 0, buf);
X+ #ifdef VIDEOSHADES
X+             Sprintf(buf, " videoshades: %s %s %s",
X+ 				shade[0],shade[1],shade[2]);
X+             putstr(tmpwin, 0, buf);
X+             Sprintf(buf, " videocolors: %d %d %d %d %d %d %d %d %d %d %d %d",
X+ 		 ttycolors[RED],ttycolors[GREEN],ttycolors[BROWN],
X+                  ttycolors[BLUE],ttycolors[MAGENTA],ttycolors[CYAN],
X+                  ttycolors[ORANGE_COLORED],ttycolors[BRIGHT_GREEN],
X+ 		 ttycolors[YELLOW],ttycolors[BRIGHT_BLUE],
X+                  ttycolors[BRIGHT_MAGENTA],ttycolors[BRIGHT_CYAN]);
X+             putstr(tmpwin, 0, buf);
X+ #endif /* VIDEOSHADES */
X  	    Sprintf(buf, " windowtype: %s", windowprocs.name);
X  	    putstr(tmpwin, 0, buf);
X  	    display_nhwindow(tmpwin, TRUE);
X*** /tmp/da21317	Mon Jul 12 17:34:07 1993
X--- src/polyself.c	Mon Jul 12 13:14:29 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)polyself.c 3.1	93/05/15	*/
X  /*	Copyright (C) 1987, 1988, 1989 by Ken Arromdee */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)polyself.c 3.1	93/06/24	*/
X  /*	Copyright (C) 1987, 1988, 1989 by Ken Arromdee */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 118,124 ****
X  #ifdef POLYSELF
X  	polyman();
X  #endif
X! 	You("feel like a new %sman!", flags.female ? "wo" : "");
X  	flags.botl = 1;
X  	(void) encumber_msg();
X  }
X--- 118,125 ----
X  #ifdef POLYSELF
X  	polyman();
X  #endif
X! 	You("feel like a new %s!",
X! 	    pl_character[0] == 'E' ? "elf" : flags.female ? "woman" : "man");
X  	flags.botl = 1;
X  	(void) encumber_msg();
X  }
X***************
X*** 345,351 ****
X  	    if (u.usym == S_UNICORN)
X  		pline(use_thec,monsterc,"use your horn");
X  	    if (u.umonnum == PM_MIND_FLAYER)
X! 		pline(use_thec,monsterc,"for a mental blast");
X  	    if (uasmon->msound == MS_SHRIEK) /* worthless, actually */
X  		pline(use_thec,monsterc,"shriek");
X  	    if ((lays_eggs(uasmon) || u.umonnum==PM_QUEEN_BEE) && flags.female)
X--- 346,352 ----
X  	    if (u.usym == S_UNICORN)
X  		pline(use_thec,monsterc,"use your horn");
X  	    if (u.umonnum == PM_MIND_FLAYER)
X! 		pline(use_thec,monsterc,"emit a mental blast");
X  	    if (uasmon->msound == MS_SHRIEK) /* worthless, actually */
X  		pline(use_thec,monsterc,"shriek");
X  	    if ((lays_eggs(uasmon) || u.umonnum==PM_QUEEN_BEE) && flags.female)
X***************
X*** 442,448 ****
X  	}
X  	if ((otmp = uarmh) != 0) {
X  	    if (donning(otmp)) cancel_don();
X! 	    Your("helmet falls to the floor!");
X  	    (void) Helmet_off();
X  	    dropx(otmp);
X  	}
X--- 443,449 ----
X  	}
X  	if ((otmp = uarmh) != 0) {
X  	    if (donning(otmp)) cancel_don();
X! 	    Your("helmet falls to the %s!", surface(u.ux, u.uy));
X  	    (void) Helmet_off();
X  	    dropx(otmp);
X  	}
X*** /tmp/da21325	Mon Jul 12 17:34:11 1993
X--- src/potion.c	Mon Jul 12 13:45:25 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)potion.c	3.1	93/05/15	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)potion.c	3.1	93/07/07	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 55,61 ****
X  	}
X  	if (xtime && !old) {
X  		if (talk)
X! 			You("stagger....");
X  		flags.botl = 1;
X  	}
X  	HStun = xtime;
X--- 55,61 ----
X  	}
X  	if (xtime && !old) {
X  		if (talk)
X! 			You("stagger...");
X  		flags.botl = 1;
X  	}
X  	HStun = xtime;
X***************
X*** 458,468 ****
X  		newsym(u.ux,u.uy); /* see yourself! */
X  		break;
X  	case POT_PARALYSIS:
X! 		if(Levitation || Is_waterlevel(&u.uz))
X! 			You("are motionlessly suspended.");
X  		else
X! 			Your("%s are frozen to the floor!",
X! 				makeplural(body_part(FOOT)));
X  		nomul(-(rn1(10, 25 - 12*bcsign(otmp))));
X  		exercise(A_DEX, FALSE);
X  		break;
X--- 458,468 ----
X  		newsym(u.ux,u.uy); /* see yourself! */
X  		break;
X  	case POT_PARALYSIS:
X! 		if (Levitation || Is_airlevel(&u.uz) || Is_waterlevel(&u.uz))
X! 		    You("are motionlessly suspended.");
X  		else
X! 		    Your("%s are frozen to the %s!",
X! 			 makeplural(body_part(FOOT)), surface(u.ux, u.uy));
X  		nomul(-(rn1(10, 25 - 12*bcsign(otmp))));
X  		exercise(A_DEX, FALSE);
X  		break;
X***************
X*** 643,649 ****
X  			} while (lmoves < 1 || lmoves > 300);
X  			HLevitation += lmoves;
X  		} else HLevitation += rnd(150);
X- 		u.uprops[LEVITATION].p_tofn = float_down;
X  		break;
X  	case POT_GAIN_ENERGY:			/* M. Stephenson */
X  		{	register int	 num;
X--- 643,648 ----
END_OF_FILE
if test 54812 -ne `wc -c <'patches03b'`; then
    echo shar: \"'patches03b'\" unpacked with wrong size!
fi
# end of 'patches03b'
if test -f 'sys/share/lev_comp.h' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'sys/share/lev_comp.h'\" to \"'sys/share/lev_comp.h.orig'\"
  mv -f 'sys/share/lev_comp.h' 'sys/share/lev_comp.h.orig'
fi
echo shar: Extracting \"'sys/share/lev_comp.h'\" \(1610 characters\)
sed "s/^X//" >'sys/share/lev_comp.h' <<'END_OF_FILE'
X#define CHAR 257
X#define INTEGER 258
X#define BOOLEAN 259
X#define MESSAGE_ID 260
X#define MAZE_ID 261
X#define LEVEL_ID 262
X#define LEV_INIT_ID 263
X#define GEOMETRY_ID 264
X#define NOMAP_ID 265
X#define OBJECT_ID 266
X#define MONSTER_ID 267
X#define TRAP_ID 268
X#define DOOR_ID 269
X#define DRAWBRIDGE_ID 270
X#define MAZEWALK_ID 271
X#define WALLIFY_ID 272
X#define REGION_ID 273
X#define FILLING 274
X#define RANDOM_OBJECTS_ID 275
X#define RANDOM_MONSTERS_ID 276
X#define RANDOM_PLACES_ID 277
X#define ALTAR_ID 278
X#define LADDER_ID 279
X#define STAIR_ID 280
X#define NON_DIGGABLE_ID 281
X#define NON_PASSWALL_ID 282
X#define ROOM_ID 283
X#define PORTAL_ID 284
X#define TELEPRT_ID 285
X#define BRANCH_ID 286
X#define LEV 287
X#define CHANCE_ID 288
X#define CORRIDOR_ID 289
X#define GOLD_ID 290
X#define ENGRAVING_ID 291
X#define FOUNTAIN_ID 292
X#define POOL_ID 293
X#define SINK_ID 294
X#define NONE 295
X#define RAND_CORRIDOR_ID 296
X#define DOOR_STATE 297
X#define LIGHT_STATE 298
X#define CURSE_TYPE 299
X#define ENGRAVING_TYPE 300
X#define DIRECTION 301
X#define RANDOM_TYPE 302
X#define O_REGISTER 303
X#define M_REGISTER 304
X#define P_REGISTER 305
X#define A_REGISTER 306
X#define ALIGNMENT 307
X#define LEFT_OR_RIGHT 308
X#define CENTER 309
X#define TOP_OR_BOT 310
X#define ALTAR_TYPE 311
X#define UP_OR_DOWN 312
X#define SUBROOM_ID 313
X#define NAME_ID 314
X#define FLAGS_ID 315
X#define FLAG_TYPE 316
X#define MON_ATTITUDE 317
X#define MON_ALERTNESS 318
X#define MON_APPEARANCE 319
X#define STRING 320
X#define MAP_ID 321
Xtypedef union
X{
X	int	i;
X	char*	map;
X	struct {
X		xchar room;
X		xchar wall;
X		xchar door;
X	} corpos;
X} YYSTYPE;
Xextern YYSTYPE yylval;
END_OF_FILE
if test 1610 -ne `wc -c <'sys/share/lev_comp.h'`; then
    echo shar: \"'sys/share/lev_comp.h'\" unpacked with wrong size!
fi
# end of 'sys/share/lev_comp.h'
echo shar: End of archive 3 \(of 18\).
cp /dev/null ark3isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 18 archives.
    echo "Now execute ./patchit3.sh"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
