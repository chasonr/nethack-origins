Path: uunet!news.tek.com!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v18i035:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Patch3b/18
Date: 20 Jul 1993 22:31:41 GMT
Organization: Tektronix, Inc, Redmond, OR, USA
Lines: 2204
Approved: billr@saab.CNA.TEK.COM
Message-ID: <22hrod$9pp@ying.cna.tek.com>
NNTP-Posting-Host: saab.cna.tek.com
Xref: uunet comp.sources.games:1835

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 18, Issue 35
Archive-name: nethack31/patch3b
Patch-To: nethack31: Volume 16, Issue 1-116
Environment: Amiga, Atari, Mac, MS-DOS, Windows-NT, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 2 (of 18)."
# Contents:  patches03c sys/share/NOTE
# Wrapped by billr@saab on Tue Jul 20 14:57:18 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'patches03c' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'patches03c'\" to \"'patches03c.orig'\"
  mv -f 'patches03c' 'patches03c.orig'
fi
echo shar: Extracting \"'patches03c'\" \(56262 characters\)
sed "s/^X//" >'patches03c' <<'END_OF_FILE'
X*** /tmp/da21333	Mon Jul 12 17:34:14 1993
X--- src/pray.c	Fri Jul  9 15:33:46 1993
X***************
X*** 770,776 ****
X  	      (changed > 1L ? "s" : ""), (changed > 1L ? "" : "s"),
X  	      (bless_water ? amber : Black));
X      }
X!     return (changed > 0L);
X  }
X  
X  static void
X--- 770,776 ----
X  	      (changed > 1L ? "s" : ""), (changed > 1L ? "" : "s"),
X  	      (bless_water ? amber : Black));
X      }
X!     return((boolean)(changed > 0L));
X  }
X  
X  static void
X*** /tmp/da21341	Mon Jul 12 17:34:17 1993
X--- src/priest.c	Thu Jul  8 15:49:54 1993
X***************
X*** 132,139 ****
X  register struct monst *priest;
X  register xchar x, y;
X  {
X! 	return((EPRI(priest)->shroom == *in_rooms(x, y, TEMPLE)) &&
X! 	       on_level(&(EPRI(priest)->shrlevel), &u.uz));
X  }
X  
X  /*
X--- 132,139 ----
X  register struct monst *priest;
X  register xchar x, y;
X  {
X! 	return((boolean)((EPRI(priest)->shroom == *in_rooms(x, y, TEMPLE)) &&
X! 	       on_level(&(EPRI(priest)->shrlevel), &u.uz)));
X  }
X  
X  /*
X***************
X*** 305,311 ****
X  p_coaligned(priest)
X  struct monst *priest;
X  {
X! 	return(u.ualign.type == ((int)EPRI(priest)->shralign));
X  }
X  
X  static boolean
X--- 305,311 ----
X  p_coaligned(priest)
X  struct monst *priest;
X  {
X! 	return((boolean)(u.ualign.type == ((int)EPRI(priest)->shralign)));
X  }
X  
X  static boolean
X***************
X*** 319,325 ****
X  	lev = &levl[EPRI(pri)->shrpos.x][EPRI(pri)->shrpos.y];
X  	if (!IS_ALTAR(lev->typ) || !(lev->altarmask & AM_SHRINE))
X  		return(FALSE);
X! 	return(EPRI(pri)->shralign == Amask2align(lev->altarmask & ~AM_SHRINE));
X  }
X  
X  struct monst *
X--- 319,325 ----
X  	lev = &levl[EPRI(pri)->shrpos.x][EPRI(pri)->shrpos.y];
X  	if (!IS_ALTAR(lev->typ) || !(lev->altarmask & AM_SHRINE))
X  		return(FALSE);
X! 	return((boolean)(EPRI(pri)->shralign == Amask2align(lev->altarmask & ~AM_SHRINE)));
X  }
X  
X  struct monst *
X***************
X*** 483,489 ****
X  		    verbalize("I bestow upon thee a blessing.");
X  		    Clairvoyant += rn1(500,500);
X  		}
X! 	    } else if(offer < (u.ulevel * 600)) {
X  		verbalize("Thy devotion has been rewarded.");
X  		if (!(Protection & INTRINSIC))  {
X  			Protection |= FROMOUTSIDE;
X--- 483,491 ----
X  		    verbalize("I bestow upon thee a blessing.");
X  		    Clairvoyant += rn1(500,500);
X  		}
X! 	    } else if(offer < (u.ulevel * 600) &&
X! 		      u.ublessed < 20 &&
X! 		      (u.ublessed < 9 || !rn2(u.ublessed))) {
X  		verbalize("Thy devotion has been rewarded.");
X  		if (!(Protection & INTRINSIC))  {
X  			Protection |= FROMOUTSIDE;
X***************
X*** 493,499 ****
X  		verbalize("Thy selfless generosity is deeply appreciated.");
X  		if(u.ugold < (offer * 2L) && coaligned) {
X  		    if(strayed && (moves - u.ucleansed) > 5000L) {
X! 			u.ualign.record = 0; /* cleanse him */
X  			u.ucleansed = moves;
X  		    } else {
X  			u.ualign.record += 2;
X--- 495,501 ----
X  		verbalize("Thy selfless generosity is deeply appreciated.");
X  		if(u.ugold < (offer * 2L) && coaligned) {
X  		    if(strayed && (moves - u.ucleansed) > 5000L) {
X! 			u.ualign.record = 0; /* cleanse thee */
X  			u.ucleansed = moves;
X  		    } else {
X  			u.ualign.record += 2;
X***************
X*** 561,567 ****
X  	    (roomno != *in_rooms(x, y, TEMPLE)) ||
X  	    !(priest = findpriest(roomno)))
X  		return(FALSE);
X! 	return(has_shrine(priest) && p_coaligned(priest) && priest->mpeaceful);
X  }
X  
X  void
X--- 563,569 ----
X  	    (roomno != *in_rooms(x, y, TEMPLE)) ||
X  	    !(priest = findpriest(roomno)))
X  		return(FALSE);
X! 	return((boolean)(has_shrine(priest) && p_coaligned(priest) && priest->mpeaceful));
X  }
X  
X  void
X*** /tmp/da21350	Mon Jul 12 17:34:19 1993
X--- src/quest.c	Wed Jul  7 16:25:20 1993
X***************
X*** 123,135 ****
X  boolean
X  ok_to_quest()
X  {
X! 	return(Qstat(got_quest) || Qstat(got_thanks));
X  }
X  
X  static boolean
X  not_capable()
X  {
X! 	return(u.ulevel < MIN_QUEST_LEVEL);
X  }
X  
X  /* TODO:	This one needs tuning. */
X--- 123,135 ----
X  boolean
X  ok_to_quest()
X  {
X! 	return((boolean)(Qstat(got_quest) || Qstat(got_thanks)));
X  }
X  
X  static boolean
X  not_capable()
X  {
X! 	return((boolean)(u.ulevel < MIN_QUEST_LEVEL));
X  }
X  
X  /* TODO:	This one needs tuning. */
X***************
X*** 145,151 ****
X  		u.ualign.record = MIN_QUEST_ALIGN;
X  	}
X  #endif
X!   return(u.ualign.record < MIN_QUEST_ALIGN);
X  }
X  
X  /*
X--- 145,151 ----
X  		u.ualign.record = MIN_QUEST_ALIGN;
X  	}
X  #endif
X!   return((boolean)(u.ualign.record < MIN_QUEST_ALIGN));
X  }
X  
X  /*
X*** /tmp/da21358	Mon Jul 12 17:34:21 1993
X--- src/questpgr.c	Wed Jul  7 16:25:22 1993
X***************
X*** 10,16 ****
X  #include "qtext.h"
X  
X  #define QTEXT_FILE	"quest.dat"
X! #if defined(MICRO) && !defined(AMIGA)
X  # define RDMODE "rb"
X  #else
X  # define RDMODE "r"
X--- 10,16 ----
X  #include "qtext.h"
X  
X  #define QTEXT_FILE	"quest.dat"
X! #if (defined(MICRO) && !defined(AMIGA)) || defined(THINK_C)
X  # define RDMODE "rb"
X  #else
X  # define RDMODE "r"
X***************
X*** 243,249 ****
X  	    case 'A':	return(0);
X  	    case 'B':	return(1);
X  	    case 'C':	return(2);
X! 	    case 'E':	return(3+flags.female);
X  	    case 'H':	return(5);
X  	    case 'K':	return(6);
X  	    case 'P':	return(7);
X--- 243,249 ----
X  	    case 'A':	return(0);
X  	    case 'B':	return(1);
X  	    case 'C':	return(2);
X! 	    case 'E':	return((unsigned)(3+flags.female));
X  	    case 'H':	return(5);
X  	    case 'K':	return(6);
X  	    case 'P':	return(7);
X***************
X*** 280,286 ****
X  is_quest_artifact(otmp)
X  struct obj *otmp;
X  {
X! 	return(otmp->oartifact == qt_matrix[class_index()].artinum);
X  }
X  
X  static const char *
X--- 280,286 ----
X  is_quest_artifact(otmp)
X  struct obj *otmp;
X  {
X! 	return((boolean)(otmp->oartifact == qt_matrix[class_index()].artinum));
X  }
X  
X  static const char *
X***************
X*** 305,311 ****
X  leaderless()	/* return true iff leader is dead */
X  {
X  	int i = qt_matrix[class_index()].ldrnum;
X! 	return (u.nr_killed[i] > 0);
X  }
X  
X  static struct qtmsg *
X--- 305,311 ----
X  leaderless()	/* return true iff leader is dead */
X  {
X  	int i = qt_matrix[class_index()].ldrnum;
X! 	return((boolean)(u.nr_killed[i] > 0));
X  }
X  
X  static struct qtmsg *
X*** /tmp/da21367	Mon Jul 12 17:34:24 1993
X--- src/read.c	Mon Jul 12 13:45:27 1993
X***************
X*** 86,94 ****
X  	    pline("As you read the scroll, it disappears.");
X  	  if(confused) {
X  	    if (Hallucination)
X! 		pline("Being so trippy, you screw up....");
X  	    else
X! 		pline("Being confused, you mispronounce the magic words....");
X  	  }
X  	}
X  	if(!seffects(scroll))  {
X--- 86,94 ----
X  	    pline("As you read the scroll, it disappears.");
X  	  if(confused) {
X  	    if (Hallucination)
X! 		pline("Being so trippy, you screw up...");
X  	    else
X! 		pline("Being confused, you mispronounce the magic words...");
X  	  }
X  	}
X  	if(!seffects(scroll))  {
X***************
X*** 1194,1200 ****
X  	if (tries == 5) pline(thats_enough_tries);
X  	else {
X  	    (void) cant_create(&which);
X! 	    return makemon(&mons[which], u.ux, u.uy) != 0;
X  	}
X  	return FALSE;
X  }
X--- 1194,1200 ----
X  	if (tries == 5) pline(thats_enough_tries);
X  	else {
X  	    (void) cant_create(&which);
X! 	    return((boolean)(makemon(&mons[which], u.ux, u.uy) != 0));
X  	}
X  	return FALSE;
X  }
X*** /tmp/da21383	Mon Jul 12 17:34:28 1993
X--- src/restore.c	Mon Jul 12 13:38:57 1993
X***************
X*** 25,30 ****
X--- 25,34 ----
X  static boolean FDECL(restgamestate, (int, unsigned int *));
X  static int FDECL(restlevelfile, (int,XCHAR_P));
X  
X+ #ifdef AMII_GRAPHICS
X+ void NDECL( amii_setpens );		/* use colors from save file */
X+ #endif
X+ 
X  #ifdef MULDGN
X  #include "quest.h"
X  #endif
X***************
X*** 241,247 ****
X  		if(mtmp->minvent)
X  			mtmp->minvent = restobjchn(fd, ghostly);
X  #ifdef MUSE
X! 		if (mtmp->mw) mtmp->mw = mtmp->minvent;	/* wield 1st obj in inventory */
X  #endif
X  		if (mtmp->isshk) restshk(mtmp, ghostly);
X  		if (mtmp->ispriest) restpriest(mtmp, ghostly);
X--- 245,261 ----
X  		if(mtmp->minvent)
X  			mtmp->minvent = restobjchn(fd, ghostly);
X  #ifdef MUSE
X! 		if (mtmp->mw) {
X! 			struct obj *obj;
X! 
X! 			for(obj = mtmp->minvent; obj; obj = obj->nobj)
X! 				if (obj->owornmask & W_WEP) break;
X! 			if (obj) mtmp->mw = obj;
X! 			else {
X! 				MON_NOWEP(mtmp);
X! 				impossible("bad monster weapon restore");
X! 			}
X! 		}
X  #endif
X  		if (mtmp->isshk) restshk(mtmp, ghostly);
X  		if (mtmp->ispriest) restpriest(mtmp, ghostly);
X***************
X*** 641,647 ****
X  		uchar	len;
X  		struct rm r;
X  		
X! #if defined(applec)
X  		memset ( & r , 0 , sizeof ( r ) ) ; /* Suppress warning about used before set */
X  #endif
X  		i = 0; j = 0; len = 0;
X--- 655,661 ----
X  		uchar	len;
X  		struct rm r;
X  		
X! #if defined(MAC)
X  		memset ( & r , 0 , sizeof ( r ) ) ; /* Suppress warning about used before set */
X  #endif
X  		i = 0; j = 0; len = 0;
X*** /tmp/da21415	Mon Jul 12 17:34:37 1993
X--- src/save.c	Fri Jul  2 15:11:03 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)save.c	3.1	93/05/26	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)save.c	3.1	93/06/27	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 13,18 ****
X--- 13,21 ----
X  #endif /* EXPLORE_MODE */
X  
X  boolean hu;		/* set during hang-up */
X+ #ifdef VMS
X+ extern volatile int exiting;		/* sys/vms/vmsmain.c */
X+ #endif
X  
X  #ifdef MULDGN
X  #include "quest.h"
X***************
X*** 74,86 ****
X  
X  #ifndef NOSAVEONHANGUP
X  int
X! hangup() {
X  	if(!hu) {
X  		hu = TRUE;
X  		(void) dosave0();
X! # ifndef VMS
X! 		terminate(1);
X  # endif
X  	}
X  	return 0;
X  }
X--- 77,93 ----
X  
X  #ifndef NOSAVEONHANGUP
X  int
X! hangup()
X! {
X  	if(!hu) {
X  		hu = TRUE;
X  		(void) dosave0();
X! # ifdef VMS
X! 		/* don't call exit when already within an exit handler;
X! 		   that would cancel any other pending user-mode handlers */
X! 		if (!exiting)
X  # endif
X+ 		terminate(1);
X  	}
X  	return 0;
X  }
X*** /tmp/da21423	Mon Jul 12 17:34:39 1993
X--- src/shk.c	Wed Jul  7 16:25:30 1993
X***************
X*** 495,501 ****
X  	if (!mtmp)
X  		return(FALSE);
X  	else
X! 		return(inhishop(mtmp));
X  }
X  #endif	/* SOUNDS */
X  
X--- 495,501 ----
X  	if (!mtmp)
X  		return(FALSE);
X  	else
X! 		return((boolean)(inhishop(mtmp)));
X  }
X  #endif	/* SOUNDS */
X  
X***************
X*** 2168,2173 ****
X--- 2168,2174 ----
X  			    if (!obj->unpaid && !saleitem) obj->no_charge = 1;
X  			    subfrombill(obj, shkp);
X  			    pay(-offer, shkp);
X+ 			    shk_names_obj(obj);     /* identify some non-magic objects */
X  			    You("sold %s for %ld gold piece%s.", doname(obj),
X  				offer, plur(offer));
X  			    break;
X***************
X*** 2180,2185 ****
X--- 2181,2189 ----
X  doinvbill(mode)
X  int mode;		/* 0: deliver count 1: paged */
X  {
X+ #ifdef	__SASC
X+ 	void sasc_bug(struct obj *, unsigned);
X+ #endif
X  	register struct monst* shkp;
X  	register struct bill_x *bp, *end_bp;
X  	register struct obj *obj;
X***************
X*** 2651,2657 ****
X  is_fshk(mtmp)
X  register struct monst *mtmp;
X  {
X! 	return(mtmp->isshk && ESHK(mtmp)->following);
X  }
X  
X  /* You are digging in the shop. */
X--- 2655,2661 ----
X  is_fshk(mtmp)
X  register struct monst *mtmp;
X  {
X! 	return((boolean)(mtmp->isshk && ESHK(mtmp)->following));
X  }
X  
X  /* You are digging in the shop. */
X***************
X*** 2902,2910 ****
X  	shkp = shop_keeper(*in_rooms(x, y, SHOPBASE));
X  	if(!shkp || !inhishop(shkp)) return(FALSE);
X  
X! 	return(inside_shop(x, y) &&
X  		!(x == ESHK(shkp)->shk.x &&
X! 			y == ESHK(shkp)->shk.y));
X  }
X  
X  /* called by dotalk(sounds.c) when #chatting; returns obj if location
X--- 2906,2914 ----
X  	shkp = shop_keeper(*in_rooms(x, y, SHOPBASE));
X  	if(!shkp || !inhishop(shkp)) return(FALSE);
X  
X! 	return((boolean)(inside_shop(x, y) &&
X  		!(x == ESHK(shkp)->shk.x &&
X! 			y == ESHK(shkp)->shk.y)));
X  }
X  
X  /* called by dotalk(sounds.c) when #chatting; returns obj if location
X***************
X*** 3235,3240 ****
X--- 3239,3245 ----
X  #endif /* OVLB */
X  
X  #ifdef __SASC
X+ void
X  sasc_bug(struct obj *op, unsigned x){
X  	op->unpaid=x;
X  }
X*** /tmp/da21431	Mon Jul 12 17:34:45 1993
X--- src/shknam.c	Fri Jul  9 15:36:24 1993
X***************
X*** 107,117 ****
X      "Htargcm", "Enrobwem", "Kachzi Rellim", "Regien", "Donmyar",
X      "Yelpur", "Nosnehpets", "Stewe", "Renrut", "_Zlaw", "Nosalnef",
X      "Rewuorb", "Rellenk", "Yad", "Cire Htims", "Y-crad", "Nenilukah",
X  #ifdef OVERLAY
X!     "Erreip", "Nehpets", "Mron", "Snivek",
X  #endif
X  #ifdef MAC
X      "Nhoj-lee", "Evad\'kh", "Ettaw-noj", "Tsew-mot", "Ydna-s",
X  #endif
X  #ifdef AMIGA
X      "Falo", "Nosid-da\'r", "Ekim-p", "Rebrol-nek", "Noslo", "Yl-rednow",
X--- 107,122 ----
X      "Htargcm", "Enrobwem", "Kachzi Rellim", "Regien", "Donmyar",
X      "Yelpur", "Nosnehpets", "Stewe", "Renrut", "_Zlaw", "Nosalnef",
X      "Rewuorb", "Rellenk", "Yad", "Cire Htims", "Y-crad", "Nenilukah",
X+     "Corsh", "Aned",
X  #ifdef OVERLAY
X!     "Erreip", "Nehpets", "Mron", "Snivek", "Lapu",
X  #endif
X+ #ifdef WIN32
X+     "Lechaim",
X+ #endif
X  #ifdef MAC
X      "Nhoj-lee", "Evad\'kh", "Ettaw-noj", "Tsew-mot", "Ydna-s",
X+     "Yao-hang", "Tonbar",
X  #endif
X  #ifdef AMIGA
X      "Falo", "Nosid-da\'r", "Ekim-p", "Rebrol-nek", "Noslo", "Yl-rednow",
X*** /tmp/da21455	Mon Jul 12 17:34:52 1993
X--- src/sp_lev.c	Tue Jul  6 15:20:22 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)sp_lev.c	3.1	92/11/14	*/
X  /*	Copyright (c) 1989 by Jean-Christophe Collet */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)sp_lev.c	3.1	93/06/29	*/
X  /*	Copyright (c) 1989 by Jean-Christophe Collet */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 42,48 ****
X  static boolean FDECL(create_subroom, (struct mkroom *, XCHAR_P, XCHAR_P,
X  					XCHAR_P, XCHAR_P, XCHAR_P, XCHAR_P));
X  
X! #if defined(MICRO) && !defined(AMIGA)
X  # define RDMODE "rb"
X  #else
X  # define RDMODE "r"
X--- 42,48 ----
X  static boolean FDECL(create_subroom, (struct mkroom *, XCHAR_P, XCHAR_P,
X  					XCHAR_P, XCHAR_P, XCHAR_P, XCHAR_P));
X  
X! #if (defined(MICRO) && !defined(AMIGA)) || defined(THINK_C)
X  # define RDMODE "rb"
X  #else
X  # define RDMODE "r"
X***************
X*** 962,968 ****
X  		croom_is_temple = FALSE;
X  	} else {
X  	    get_location(&x, &y, DRY);
X! 	    if (sproom = (schar) *in_rooms(x, y, TEMPLE))
X  		croom = &rooms[sproom - ROOMOFFSET];
X  	    else
X  		croom_is_temple = FALSE;
X--- 962,968 ----
X  		croom_is_temple = FALSE;
X  	} else {
X  	    get_location(&x, &y, DRY);
X! 	    if ((sproom = (schar) *in_rooms(x, y, TEMPLE)) != 0)
X  		croom = &rooms[sproom - ROOMOFFSET];
X  	    else
X  		croom_is_temple = FALSE;
X***************
X*** 1376,1392 ****
X  		r = ro[n];
X  		Free(r->name);
X  		Free(r->parent);
X! 		if (j = r->ndoor) {
X  			while(j--)
X  			    Free(r->doors[j]);
X  			Free(r->doors);
X  		}
X! 		if (j = r->ntrap) {
X  			while (j--)
X  			    Free(r->traps[j]);
X  			Free(r->traps);
X  		}
X! 		if (j = r->nmonster) {
X  			while (j--) {
X  				Free(r->monsters[j]->name);
X  				Free(r->monsters[j]->appear_as);
X--- 1376,1392 ----
X  		r = ro[n];
X  		Free(r->name);
X  		Free(r->parent);
X! 		if ((j = r->ndoor) != 0) {
X  			while(j--)
X  			    Free(r->doors[j]);
X  			Free(r->doors);
X  		}
X! 		if ((j = r->ntrap) != 0) {
X  			while (j--)
X  			    Free(r->traps[j]);
X  			Free(r->traps);
X  		}
X! 		if ((j = r->nmonster) != 0) {
X  			while (j--) {
X  				Free(r->monsters[j]->name);
X  				Free(r->monsters[j]->appear_as);
X***************
X*** 1394,1400 ****
X  			}
X  			Free(r->monsters);
X  		}
X! 		if (j = r->nobject) {
X  			while(j--) {
X  				Free(r->objects[j]->name);
X  				Free(r->objects[j]);
X--- 1394,1400 ----
X  			}
X  			Free(r->monsters);
X  		}
X! 		if ((j = r->nobject) != 0) {
X  			while(j--) {
X  				Free(r->objects[j]->name);
X  				Free(r->objects[j]);
X***************
X*** 1401,1422 ****
X  			}
X  			Free(r->objects);
X  		}
X! 		if (j = r->nstair) {
X  			while(j--)
X  			    Free(r->stairs[j]);
X  			Free(r->stairs);
X  		}
X! 		if (j = r->naltar) {
X  			while (j--)
X  			    Free(r->altars[j]);
X  			Free(r->altars);
X  		}
X! 		if (j = r->ngold) {
X  			while(j--)
X  			    Free(r->golds[j]);
X  			Free(r->golds);
X  		}
X! 		if (j = r->nengraving) {
X  			while(j--) {
X  				Free(r->engravings[j]->e.text);
X  				Free(r->engravings[j]);
X--- 1401,1422 ----
X  			}
X  			Free(r->objects);
X  		}
X! 		if ((j = r->nstair) != 0) {
X  			while(j--)
X  			    Free(r->stairs[j]);
X  			Free(r->stairs);
X  		}
X! 		if ((j = r->naltar) != 0) {
X  			while (j--)
X  			    Free(r->altars[j]);
X  			Free(r->altars);
X  		}
X! 		if ((j = r->ngold) != 0) {
X  			while(j--)
X  			    Free(r->golds[j]);
X  			Free(r->golds);
X  		}
X! 		if ((j = r->nengraving) != 0) {
X  			while(j--) {
X  				Free(r->engravings[j]->e.text);
X  				Free(r->engravings[j]);
X***************
X*** 1423,1439 ****
X  			}
X  			Free(r->engravings);
X  		}
X! 		if (j = r->nfountain) {
X  			while(j--)
X  			    Free(r->fountains[j]);
X  			Free(r->fountains);
X  		}
X! 		if (j = r->nsink) {
X  			while(j--)
X  			    Free(r->sinks[j]);
X  			Free(r->sinks);
X  		}
X! 		if (j = r->npool) {
X  			while(j--)
X  			    Free(r->pools[j]);
X  			Free(r->pools);
X--- 1423,1439 ----
X  			}
X  			Free(r->engravings);
X  		}
X! 		if ((j = r->nfountain) != 0) {
X  			while(j--)
X  			    Free(r->fountains[j]);
X  			Free(r->fountains);
X  		}
X! 		if ((j = r->nsink) != 0) {
X  			while(j--)
X  			    Free(r->sinks[j]);
X  			Free(r->sinks);
X  		}
X! 		if ((j = r->npool) != 0) {
X  			while(j--)
X  			    Free(r->pools[j]);
X  			Free(r->pools);
X***************
X*** 1685,1691 ****
X  
X  		/* read the doors */
X  		Fread((genericptr_t) &r->ndoor, 1, sizeof(r->ndoor), fd);
X! 		if(n = r->ndoor)
X  		    r->doors = NewTab(room_door, n);
X  		while(n--) {
X  			r->doors[n] = New(room_door);
X--- 1685,1691 ----
X  
X  		/* read the doors */
X  		Fread((genericptr_t) &r->ndoor, 1, sizeof(r->ndoor), fd);
X! 		if ((n = r->ndoor) != 0)
X  		    r->doors = NewTab(room_door, n);
X  		while(n--) {
X  			r->doors[n] = New(room_door);
X***************
X*** 1695,1701 ****
X  
X  		/* read the traps */
X  		Fread((genericptr_t) &r->ntrap, 1, sizeof(r->ntrap), fd);
X! 		if(n = r->ntrap)
X  		    r->traps = NewTab(trap, n);
X  		while(n--) {
X  			r->traps[n] = New(trap);
X--- 1695,1701 ----
X  
X  		/* read the traps */
X  		Fread((genericptr_t) &r->ntrap, 1, sizeof(r->ntrap), fd);
X! 		if ((n = r->ntrap) != 0)
X  		    r->traps = NewTab(trap, n);
X  		while(n--) {
X  			r->traps[n] = New(trap);
X***************
X*** 1704,1710 ****
X  
X  		/* read the monsters */
X  		Fread((genericptr_t) &r->nmonster, 1, sizeof(r->nmonster), fd);
X! 		if(n = r->nmonster)
X  		    r->monsters = NewTab(monster, n);
X  		while(n--) {
X  			r->monsters[n] = New(monster);
X--- 1704,1710 ----
X  
X  		/* read the monsters */
X  		Fread((genericptr_t) &r->nmonster, 1, sizeof(r->nmonster), fd);
X! 		if ((n = r->nmonster) != 0)
X  		    r->monsters = NewTab(monster, n);
X  		while(n--) {
X  			r->monsters[n] = New(monster);
X***************
X*** 1732,1738 ****
X  
X  		/* read the objects */
X  		Fread((genericptr_t) &r->nobject, 1, sizeof(r->nobject), fd);
X! 		if(n = r->nobject)
X  		    r->objects = NewTab(object, n);
X  		while (n--) {
X  			r->objects[n] = New(object);
X--- 1732,1738 ----
X  
X  		/* read the objects */
X  		Fread((genericptr_t) &r->nobject, 1, sizeof(r->nobject), fd);
X! 		if ((n = r->nobject) != 0)
X  		    r->objects = NewTab(object, n);
X  		while (n--) {
X  			r->objects[n] = New(object);
X***************
X*** 1750,1756 ****
X  
X  		/* read the stairs */
X  		Fread((genericptr_t) &r->nstair, 1, sizeof(r->nstair), fd);
X! 		if (n = r->nstair)
X  		    r->stairs = NewTab(stair, n);
X  		while (n--) {
X  			r->stairs[n] = New(stair);
X--- 1750,1756 ----
X  
X  		/* read the stairs */
X  		Fread((genericptr_t) &r->nstair, 1, sizeof(r->nstair), fd);
X! 		if ((n = r->nstair) != 0)
X  		    r->stairs = NewTab(stair, n);
X  		while (n--) {
X  			r->stairs[n] = New(stair);
X***************
X*** 1760,1766 ****
X  
X  		/* read the altars */
X  		Fread((genericptr_t) &r->naltar, 1, sizeof(r->naltar), fd);
X! 		if (n = r->naltar)
X  		    r->altars = NewTab(altar, n);
X  		while (n--) {
X  			r->altars[n] = New(altar);
X--- 1760,1766 ----
X  
X  		/* read the altars */
X  		Fread((genericptr_t) &r->naltar, 1, sizeof(r->naltar), fd);
X! 		if ((n = r->naltar) != 0)
X  		    r->altars = NewTab(altar, n);
X  		while (n--) {
X  			r->altars[n] = New(altar);
X***************
X*** 1770,1776 ****
X  
X  		/* read the gold piles */
X  		Fread((genericptr_t) &r->ngold, 1, sizeof(r->ngold), fd);
X! 		if (n = r->ngold)
X  		    r->golds = NewTab(gold, n);
X  		while (n--) {
X  			r->golds[n] = New(gold);
X--- 1770,1776 ----
X  
X  		/* read the gold piles */
X  		Fread((genericptr_t) &r->ngold, 1, sizeof(r->ngold), fd);
X! 		if ((n = r->ngold) != 0)
X  		    r->golds = NewTab(gold, n);
X  		while (n--) {
X  			r->golds[n] = New(gold);
X***************
X*** 1780,1786 ****
X  		/* read the engravings */
X  		Fread((genericptr_t) &r->nengraving, 1,
X  			sizeof(r->nengraving), fd);
X! 		if (n = r->nengraving)
X  		    r->engravings = NewTab(engraving,n);
X  		while(n--) {
X  			r->engravings[n] = New(engraving);
X--- 1780,1786 ----
X  		/* read the engravings */
X  		Fread((genericptr_t) &r->nengraving, 1,
X  			sizeof(r->nengraving), fd);
X! 		if ((n = r->nengraving) != 0)
X  		    r->engravings = NewTab(engraving,n);
X  		while(n--) {
X  			r->engravings[n] = New(engraving);
X***************
X*** 1796,1802 ****
X  		/* read the fountains */
X  		Fread((genericptr_t) &r->nfountain, 1,
X  			sizeof(r->nfountain), fd);
X! 		if (n = r->nfountain)
X  		    r->fountains = NewTab(fountain, n);
X  		while (n--) {
X  			r->fountains[n] = New(fountain);
X--- 1796,1802 ----
X  		/* read the fountains */
X  		Fread((genericptr_t) &r->nfountain, 1,
X  			sizeof(r->nfountain), fd);
X! 		if ((n = r->nfountain) != 0)
X  		    r->fountains = NewTab(fountain, n);
X  		while (n--) {
X  			r->fountains[n] = New(fountain);
X***************
X*** 1806,1812 ****
X  
X  		/* read the sinks */
X  		Fread((genericptr_t) &r->nsink, 1, sizeof(r->nsink), fd);
X! 		if (n = r->nsink)
X  		    r->sinks = NewTab(sink, n);
X  		while (n--) {
X  			r->sinks[n] = New(sink);
X--- 1806,1812 ----
X  
X  		/* read the sinks */
X  		Fread((genericptr_t) &r->nsink, 1, sizeof(r->nsink), fd);
X! 		if ((n = r->nsink) != 0)
X  		    r->sinks = NewTab(sink, n);
X  		while (n--) {
X  			r->sinks[n] = New(sink);
X***************
X*** 1815,1821 ****
X  
X  		/* read the pools */
X  		Fread((genericptr_t) &r->npool, 1, sizeof(r->npool), fd);
X! 		if (n = r->npool)
X  		    r->pools = NewTab(pool,n);
X  		while (n--) {
X  			r->pools[n] = New(pool);
X--- 1815,1821 ----
X  
X  		/* read the pools */
X  		Fread((genericptr_t) &r->npool, 1, sizeof(r->npool), fd);
X! 		if ((n = r->npool) != 0)
X  		    r->pools = NewTab(pool,n);
X  		while (n--) {
X  			r->pools[n] = New(pool);
X***************
X*** 1835,1841 ****
X  			if (tmproom[j]->name && !strcmp(tmproom[j]->name,
X  						       tmproom[i]->parent)) {
X  				n = tmproom[j]->nsubroom++;
X! 				tmproom[j]->subrooms[n] = tmproom[i];
X  				break;
X  			}
X  	    }
X--- 1835,1841 ----
X  			if (tmproom[j]->name && !strcmp(tmproom[j]->name,
X  						       tmproom[i]->parent)) {
X  				n = tmproom[j]->nsubroom++;
X! 				tmproom[j]->subrooms[(int)n] = tmproom[i];
X  				break;
X  			}
X  	    }
X***************
X*** 2183,2190 ****
X  
X  	/* now that we have rooms _and_ associated doors, fill the rooms */
X  	for(n = 0; n < SIZE(mustfill); n++)
X! 	    if(mustfill[n])
X! 		fill_room(&rooms[n], (mustfill[n] == 2));
X  
X  	/* if special boundary syms (CROSSWALL) in map, remove them now */
X  	if(has_bounds) {
X--- 2183,2190 ----
X  
X  	/* now that we have rooms _and_ associated doors, fill the rooms */
X  	for(n = 0; n < SIZE(mustfill); n++)
X! 	    if(mustfill[(int)n])
X! 		fill_room(&rooms[(int)n], (mustfill[(int)n] == 2));
X  
X  	/* if special boundary syms (CROSSWALL) in map, remove them now */
X  	if(has_bounds) {
X*** /tmp/da21463	Mon Jul 12 17:34:56 1993
X--- src/spell.c	Mon Jul 12 13:45:30 1993
X***************
X*** 92,98 ****
X  deadbook(book2)
X  struct obj *book2;
X  {
X!     You("turn the pages of the Book of the Dead....");
X      makeknown(SPE_BOOK_OF_THE_DEAD);
X      if(invocation_pos(u.ux, u.uy) && !On_stairs(u.ux, u.uy)) {
X  	register struct obj *otmp;
X--- 92,98 ----
X  deadbook(book2)
X  struct obj *book2;
X  {
X!     You("turn the pages of the Book of the Dead...");
X      makeknown(SPE_BOOK_OF_THE_DEAD);
X      if(invocation_pos(u.ux, u.uy) && !On_stairs(u.ux, u.uy)) {
X  	register struct obj *otmp;
X***************
X*** 571,577 ****
X  spellet(spl)
X  int spl;
X  {
X! 	return (spl < 27) ? ('a' + spl - 1) : ('A' + spl - 27);
X  }
X  
X  int
X--- 571,577 ----
X  spellet(spl)
X  int spl;
X  {
X! 	return((char)((spl < 27) ? ('a' + spl - 1) : ('A' + spl - 27)));
X  }
X  
X  int
X*** /tmp/da21479	Mon Jul 12 17:35:00 1993
X--- src/timeout.c	Thu Jul  8 13:59:18 1993
X***************
X*** 1,8 ****
X! /*	SCCS Id: @(#)timeout.c	3.1	93/03/30	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X! #include	"hack.h"
X  
X  STATIC_DCL void NDECL(stoned_dialogue);
X  STATIC_DCL void NDECL(vomiting_dialogue);
X--- 1,8 ----
X! /*	SCCS Id: @(#)timeout.c	3.1	93/07/07	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X! #include "hack.h"
X  
X  STATIC_DCL void NDECL(stoned_dialogue);
X  STATIC_DCL void NDECL(vomiting_dialogue);
X***************
X*** 123,130 ****
X  
X  	for(upp = u.uprops; upp < u.uprops+SIZE(u.uprops); upp++)
X  	    if((upp->p_flgs & TIMEOUT) && !(--upp->p_flgs & TIMEOUT)) {
X! 		if(upp->p_tofn) (*upp->p_tofn)();
X! 		else switch(upp - u.uprops){
X  		case STONED:
X  			if (!killer) {
X  				killer_format = KILLED_BY_AN;
X--- 123,129 ----
X  
X  	for(upp = u.uprops; upp < u.uprops+SIZE(u.uprops); upp++)
X  	    if((upp->p_flgs & TIMEOUT) && !(--upp->p_flgs & TIMEOUT)) {
X! 		switch(upp - u.uprops){
X  		case STONED:
X  			if (!killer) {
X  				killer_format = KILLED_BY_AN;
X***************
X*** 196,201 ****
X--- 195,203 ----
X  				Sleeping = sleeptime + rnd(100);
X  			}
X  			break;
X+ 		case LEVITATION:
X+ 			(void) float_down();
X+ 			break;
X  		case STRANGLED:
X  			killer_format = KILLED_BY;
X  			killer = "strangulation";
X***************
X*** 255,268 ****
X  #ifdef POLYSELF
X  	int yours = otmp->spe;
X  #endif
X  
X! 	if(monstermoves-otmp->age > 200)  /* very old egg - it's dead */
X  	    otmp->corpsenm = -1;
X! #ifdef LINT	/* long conv. ok */
X! 	else if(rnd(150) > 150) {
X! #else
X! 	else if(rnd((int)(monstermoves-otmp->age)) > 150) {
X! #endif
X  	    mtmp = makemon(&mons[big_to_little(otmp->corpsenm)], u.ux, u.uy);
X  	    useup(otmp);
X  	    if(mtmp) {
X--- 257,270 ----
X  #ifdef POLYSELF
X  	int yours = otmp->spe;
X  #endif
X+ 	long egg_age = monstermoves - otmp->age;
X  
X! 	if (egg_age > 200L) {		/* very old egg - it's dead */
X  	    otmp->corpsenm = -1;
X! 	    return;
X! 	} else if (egg_age <= 150L) {	/* too young to hatch */
X! 	    return;
X! 	} else if (rnd((int)egg_age) > 150) {
X  	    mtmp = makemon(&mons[big_to_little(otmp->corpsenm)], u.ux, u.uy);
X  	    useup(otmp);
X  	    if(mtmp) {
X*** /tmp/da21504	Mon Jul 12 17:35:07 1993
X--- src/trap.c	Wed Jul  7 16:25:35 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)trap.c	3.1	93/05/25	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)trap.c	3.1	93/06/20	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 819,825 ****
X  register struct monst *mtmp;
X  {
X  	register struct trap *trap = t_at(mtmp->mx, mtmp->my);
X! 	boolean trapkilled = FALSE, tdoor = FALSE;
X  	struct permonst *mptr = mtmp->data;
X  	struct obj *otmp;
X  
X--- 819,825 ----
X  register struct monst *mtmp;
X  {
X  	register struct trap *trap = t_at(mtmp->mx, mtmp->my);
X! 	boolean trapkilled = FALSE;
X  	struct permonst *mptr = mtmp->data;
X  	struct obj *otmp;
X  
X***************
X*** 1003,1080 ****
X  			if(!Can_fall_thru(&u.uz))
X  			    panic("Trapdoors cannot exist on this level.");
X  
X! 			if ( (mptr == &mons[PM_WUMPUS]) ||
X! 			     (mtmp->wormno && count_wsegs(mtmp) > 5) ) break;
X! 			tdoor = TRUE;
X  			/* Fall through */
X  		case LEVEL_TELEP:
X! 			/* long worms w/tails can now change levels! - Norm */
X! 			if (!is_flyer(mptr)) {
X! 			    register int nlev;
X! 			    d_level tolevel;
X  #ifdef WALKIES
X! 			    if(teleport_pet(mtmp)) {
X  #endif
X! 				if(tdoor) {
X! 				    if(Is_stronghold(&u.uz))
X! 				        assign_level(&tolevel, &valley_level);
X! 				    else if(Is_botlevel(&u.uz)) {
X! 				        pline("%s avoids the trap.", 
X! 					                  Monnam(mtmp));
X! 					break;
X! 				    } else get_level(&tolevel,depth(&u.uz)+1);
X  				} else {
X! #ifdef MULDGN
X! 				    if(Is_knox(&u.uz)) {
X! 				        rloc(mtmp);
X! 					break;
X  				    }
X! #endif
X! 				    nlev = rnd(3);
X! 				    if(!rn2(2)) nlev = -(nlev);
X! 				    nlev = dunlev(&u.uz) + nlev;
X! 				    if(nlev > dunlevs_in_dungeon(&u.uz)) {
X! 				    	nlev = dunlevs_in_dungeon(&u.uz);
X! 					/* teleport up if already on bottom */
X! 					if (Is_botlevel(&u.uz)) 
X! 					    nlev -= rnd(3);
X  				    }
X- 				    if (nlev < 1) {
X- 					nlev = 1;
X- 					if (dunlev(&u.uz) == 1) {
X- 					    nlev += rnd(3);
X- 					    if (nlev >
X- 					          dunlevs_in_dungeon(&u.uz)) 
X- 					        nlev = 
X- 						  dunlevs_in_dungeon(&u.uz);
X- 					}
X- 				    }
X- 				    /* can't seem to go anywhere    */
X- 				    /* (possible in short dungeons) */
X- 				    if (nlev == dunlev(&u.uz)) {
X- 					rloc(mtmp);
X- 					break;
X- 				    }
X- 				    nlev = dungeons[u.uz.dnum].depth_start +
X- 				                               nlev;
X- 				    get_level(&tolevel, nlev);
X  				}
X! 				if(in_sight) {
X! 		pline("Suddenly, %s disappears out of sight.", mon_nam(mtmp));
X! 				    seetrap(trap);
X  				}
X! 				migrate_to_level(mtmp, 
X! 						 ledger_no(&tolevel), 0);
X! 				return(3);	/* no longer on this level */
X! #ifdef WALKIES
X  			    }
X! #endif
X  			}
X  			break;
X  
X  		case TELEP_TRAP:
X  			if(tele_restrict(mtmp)) break;
X- 		case MAGIC_PORTAL:
X  #ifdef WALKIES
X  			if(teleport_pet(mtmp)) {
X  #endif
X--- 1003,1089 ----
X  			if(!Can_fall_thru(&u.uz))
X  			    panic("Trapdoors cannot exist on this level.");
X  
X! 			if (is_flyer(mptr) || mptr == &mons[PM_WUMPUS] ||
X! 			    (mtmp->wormno && count_wsegs(mtmp) > 5)) break;
X  			/* Fall through */
X  		case LEVEL_TELEP:
X! 		case MAGIC_PORTAL:
X! 			if (mtmp == u.ustuck)	/* probably a vortex */
X! 			    break;		/* temporary? kludge */
X  #ifdef WALKIES
X! 			if (teleport_pet(mtmp))
X  #endif
X! 			{
X! 			    d_level tolevel;
X! 			    int migrate_typ = 0;
X! 
X! 			    if (tt == TRAPDOOR) {
X! 				if (Is_stronghold(&u.uz)) {
X! 				    assign_level(&tolevel, &valley_level);
X! 				} else if (Is_botlevel(&u.uz)) {
X! 				    pline("%s avoids the trap.", Monnam(mtmp));
X! 				    break;
X  				} else {
X! 				    get_level(&tolevel, depth(&u.uz) + 1);
X! 				}
X! 			    } else if (tt == MAGIC_PORTAL) {
X! 				if (In_endgame(&u.uz) &&
X! 				    (mon_has_amulet(mtmp) ||
X! 					is_home_elemental(mptr))) {
X! 				    if (in_sight && mptr->mlet != S_ELEMENTAL) {
X! 				     pline("%s seems to shimmer for a moment.",
X! 					   Monnam(mtmp));
X! 					seetrap(trap);
X  				    }
X! 				    break;
X! 				} else {
X! 				    assign_level(&tolevel, &trap->dst);
X! 				    migrate_typ = 6; /* see dog.c */
X! 				}
X! 			    } else { /* (tt == LEVEL_TELEP) */
X! 				register int nlev;
X! 
X! 				if (mon_has_amulet(mtmp)) break;
X! 				nlev = rnd(3);
X! 				if (!rn2(2)) nlev = -nlev;
X! 				nlev += dunlev(&u.uz);
X! 				if (nlev > dunlevs_in_dungeon(&u.uz)) {
X! 				    nlev = dunlevs_in_dungeon(&u.uz);
X! 				    /* teleport up if already on bottom */
X! 				    if (Is_botlevel(&u.uz)) nlev -= rnd(3);
X! 				}
X! 				if (nlev < 1) {
X! 				    nlev = 1;
X! 				    if (dunlev(&u.uz) == 1) {
X! 					nlev += rnd(3);
X! 					if (nlev > dunlevs_in_dungeon(&u.uz)) 
X! 					    nlev = dunlevs_in_dungeon(&u.uz);
X  				    }
X  				}
X! 				/* can't seem to go anywhere    */
X! 				/* (possible in short dungeons) */
X! 				if (nlev == dunlev(&u.uz)) {
X! 				    rloc(mtmp);
X! 				    break;
X  				}
X! 				nlev += dungeons[u.uz.dnum].depth_start;
X! 				get_level(&tolevel, nlev);
X  			    }
X! 
X! 			    if (in_sight) {
X! 				pline("Suddenly, %s disappears out of sight.",
X! 				      mon_nam(mtmp));
X! 				seetrap(trap);
X! 			    }
X! 			    migrate_to_level(mtmp, 
X! 					     ledger_no(&tolevel),
X! 					     migrate_typ);
X! 			    return(3);	/* no longer on this level */
X  			}
X  			break;
X  
X  		case TELEP_TRAP:
X  			if(tele_restrict(mtmp)) break;
X  #ifdef WALKIES
X  			if(teleport_pet(mtmp)) {
X  #endif
X***************
X*** 1081,1088 ****
X  			    /* Note: don't remove the trap if a vault.  Other-
X  			     * wise the monster will be stuck there, since 
X  			     * the guard isn't going to come for it...
X- 			     * Also: don't remove if magic portal.  In short,
X- 			     * don't remove :-)
X  			     */
X  			    if (in_sight) {
X  				pline("%s suddenly disappears!", 
X--- 1090,1095 ----
X***************
X*** 1096,1102 ****
X  #endif
X  			break;
X  
X! 	       case WEB:
X  			/* Monster in a web. */
X  			if (mptr->mlet == S_SPIDER) break;
X  			if (amorphous(mptr)) {
X--- 1103,1109 ----
X  #endif
X  			break;
X  
X! 		case WEB:
X  			/* Monster in a web. */
X  			if (mptr->mlet == S_SPIDER) break;
X  			if (amorphous(mptr)) {
X***************
X*** 1142,1149 ****
X  		case MAGIC_TRAP:
X  			/* A magic trap.  Monsters immune. */
X  			break;
X! 		case ANTI_MAGIC:	
X!                         break;
X  
X  		case LANDMINE: {
X  			register struct monst *mntmp = fmon;
X--- 1149,1156 ----
X  		case MAGIC_TRAP:
X  			/* A magic trap.  Monsters immune. */
X  			break;
X! 		case ANTI_MAGIC:
X! 			break;
X  
X  		case LANDMINE: {
X  			register struct monst *mntmp = fmon;
X***************
X*** 1338,1344 ****
X  	if (!trap) {
X  		if(Is_airlevel(&u.uz))
X  			You("begin to tumble in place.");
X! 		if(Is_waterlevel(&u.uz) && !no_msg)
X  			You("feel heavier.");
X  		/* u.uinwater msgs already in spoteffects()/drown() */
X  		else if (!u.uinwater && !no_msg) {
X--- 1345,1351 ----
X  	if (!trap) {
X  		if(Is_airlevel(&u.uz))
X  			You("begin to tumble in place.");
X! 		else if (Is_waterlevel(&u.uz) && !no_msg)
X  			You("feel heavier.");
X  		/* u.uinwater msgs already in spoteffects()/drown() */
X  		else if (!u.uinwater && !no_msg) {
X***************
X*** 1345,1354 ****
X  			if (Hallucination)
X  				pline("Bummer!  You've %s.",
X  				      is_pool(u.ux,u.uy) ?
X! 			      		"splashed down" : "hit the ground");
X  			else
X  				You("float gently to the %s.",
X! 				    is_pool(u.ux,u.uy) ? "water" : "ground");
X  		}
X  		trap = t_at(u.ux,u.uy);
X  	}
X--- 1352,1361 ----
X  			if (Hallucination)
X  				pline("Bummer!  You've %s.",
X  				      is_pool(u.ux,u.uy) ?
X! 					"splashed down" : "hit the ground");
X  			else
X  				You("float gently to the %s.",
X! 				    surface(u.ux, u.uy));
X  		}
X  		trap = t_at(u.ux,u.uy);
X  	}
X***************
X*** 2426,2432 ****
X  		case 2:
X  		case 1:
X  		case 0:
X! 			pline("A cloud of %s gas billows from %s",
X  			      hcolor(), the(xname(obj)));
X  			if(!Stunned) {
X  			    if (Hallucination)
X--- 2433,2439 ----
X  		case 2:
X  		case 1:
X  		case 0:
X! 			pline("A cloud of %s gas billows from %s.",
X  			      hcolor(), the(xname(obj)));
X  			if(!Stunned) {
X  			    if (Hallucination)
X***************
X*** 2559,2568 ****
X  boolean
X  unconscious()
X  {
X! 	return (multi < 0 && (!nomovemsg ||
X  		u.usleep ||
X  		!strncmp(nomovemsg,"You regain con", 15) ||
X! 		!strncmp(nomovemsg,"You are consci", 15)));
X  }
X  
X  static char lava_killer[] = "molten lava";
X--- 2566,2575 ----
X  boolean
X  unconscious()
X  {
X! 	return((boolean)(multi < 0 && (!nomovemsg ||
X  		u.usleep ||
X  		!strncmp(nomovemsg,"You regain con", 15) ||
X! 		!strncmp(nomovemsg,"You are consci", 15))));
X  }
X  
X  static char lava_killer[] = "molten lava";
X***************
X*** 2622,2628 ****
X  			pline("You're still burning.");
X  			done(BURNING);
X  		}
X! 	You("find yourself back on solid ground.");
X  	return(TRUE);
X      }
X  
X--- 2629,2635 ----
X  			pline("You're still burning.");
X  			done(BURNING);
X  		}
X! 	You("find yourself back on solid %s.", surface(u.ux, u.uy));
X  	return(TRUE);
X      }
X  
X*** /tmp/da21512	Mon Jul 12 17:35:11 1993
X--- src/u_init.c	Thu Jul  8 13:59:21 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)u_init.c	3.1	93/04/24	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)u_init.c	3.1	93/07/07	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 274,281 ****
X  	/* zero u, including pointer values --
X  	 * necessary when aborting from a failed restore */
X  	(void) memset((genericptr_t)&u, 0, sizeof(u));
X- 	for (i = 0; i < LAST_PROP+1; i++) u.uprops[i].p_tofn = 0;
X  	u.ustuck = (struct monst *)0;
X  
X  #if 0	/* documentation of more zero values as desirable */
X  	u.uluck  = u.moreluck = 0;
X--- 274,281 ----
X  	/* zero u, including pointer values --
X  	 * necessary when aborting from a failed restore */
X  	(void) memset((genericptr_t)&u, 0, sizeof(u));
X  	u.ustuck = (struct monst *)0;
X+ 	u.usick_cause = NULL;
X  
X  #if 0	/* documentation of more zero values as desirable */
X  	u.uluck  = u.moreluck = 0;
X***************
X*** 304,309 ****
X--- 304,310 ----
X  
X  	u.usym = S_HUMAN;
X  	u.umoved = FALSE;
X+ 	u.umortality = 0;
X  	u.ugrave_arise = -1;
X  
X  	u.ulevel = 0;	/* set up some of the initial attributes */
X***************
X*** 319,324 ****
X--- 320,331 ----
X  	u.umonnum = -1;
X  	u.ulycn = -1;
X  	set_uasmon();
X+ #endif
X+ 
X+ #ifdef BSD
X+ 	(void) time((long *)&u.ubirthday);
X+ #else
X+ 	(void) time(&u.ubirthday);
X  #endif
X  
X  	/*
X*** /tmp/da21520	Mon Jul 12 17:35:14 1993
X--- src/uhitm.c	Wed Jul  7 16:25:38 1993
X***************
X*** 171,177 ****
X  	if (is_orc(mtmp->data) && pl_character[0]=='E') tmp++;
X  
X  /*	with a lot of luggage, your agility diminishes */
X! 	if(tmp2 = near_capacity()) tmp -= (tmp2*2) - 1;
X  	if(u.utrap) tmp -= 3;
X  #ifdef POLYSELF
X  /*	Some monsters have a combination of weapon attacks and non-weapon
X--- 171,177 ----
X  	if (is_orc(mtmp->data) && pl_character[0]=='E') tmp++;
X  
X  /*	with a lot of luggage, your agility diminishes */
X! 	if ((tmp2 = near_capacity()) != 0) tmp -= (tmp2*2) - 1;
X  	if(u.utrap) tmp -= 3;
X  #ifdef POLYSELF
X  /*	Some monsters have a combination of weapon attacks and non-weapon
X***************
X*** 312,317 ****
X--- 312,318 ----
X  		/* 1/20 chance of shattering defender's weapon */
X  		struct obj *obj = MON_WEP(mon);
X  
X+ 		obj->owornmask &= ~W_WEP;
X  		MON_NOWEP(mon);
X  		m_useup(mon, obj);
X  		pline("%s weapon shatters!", s_suffix(Monnam(mon)));
X***************
X*** 357,363 ****
X  struct monst *mon;
X  int tmp;
X  {
X! 	static NEARDATA int malive;
X  	boolean mhit = (tmp > (dieroll = rnd(20)) || u.uswallow);
X  
X  	if(tmp > dieroll) exercise(A_DEX, TRUE);
X--- 358,364 ----
X  struct monst *mon;
X  int tmp;
X  {
X! 	static NEARDATA boolean malive;
X  	boolean mhit = (tmp > (dieroll = rnd(20)) || u.uswallow);
X  
X  	if(tmp > dieroll) exercise(A_DEX, TRUE);
X***************
X*** 743,749 ****
X  	}
X  #endif
X  
X! 	return(destroyed ? FALSE : TRUE);
X  }
X  
X  #ifdef POLYSELF
X--- 744,750 ----
X  	}
X  #endif
X  
X! 	return((boolean)(destroyed ? FALSE : TRUE));
X  }
X  
X  #ifdef POLYSELF
X***************
X*** 1283,1289 ****
X  			/* Enemy dead, before any special abilities used */
X  			if (!known_hitum(mon,dhit)) return 0;
X  			/* might be a worm that gets cut in half */
X! 			if (m_at(u.ux+u.dx, u.uy+u.dy) != mon) return(nsum);
X  			/* Do not print "You hit" message, since known_hitum
X  			 * already did it.
X  			 */
X--- 1284,1290 ----
X  			/* Enemy dead, before any special abilities used */
X  			if (!known_hitum(mon,dhit)) return 0;
X  			/* might be a worm that gets cut in half */
X! 			if (m_at(u.ux+u.dx, u.uy+u.dy) != mon) return((boolean)(nsum != 0));
X  			/* Do not print "You hit" message, since known_hitum
X  			 * already did it.
X  			 */
X***************
X*** 1410,1416 ****
X  	    }
X  	    if (dhit == -1)
X  		rehumanize();
X! 	    if(sum[i] == 2) return(passive(mon, 1, 0, (mattk->aatyp==AT_KICK)));
X  							/* defender dead */
X  	    else {
X  		(void) passive(mon, sum[i], 1, (mattk->aatyp==AT_KICK));
X--- 1411,1417 ----
X  	    }
X  	    if (dhit == -1)
X  		rehumanize();
X! 	    if(sum[i] == 2) return((boolean)passive(mon, 1, 0, (mattk->aatyp==AT_KICK)));
X  							/* defender dead */
X  	    else {
X  		(void) passive(mon, sum[i], 1, (mattk->aatyp==AT_KICK));
X***************
X*** 1421,1427 ****
X  	    if (multi < 0)
X  		break; /* If paralyzed while attacking, i.e. floating eye */
X  	}
X! 	return(nsum);
X  }
X  
X  #endif /* POLYSELF */
X--- 1422,1428 ----
X  	    if (multi < 0)
X  		break; /* If paralyzed while attacking, i.e. floating eye */
X  	}
X! 	return((boolean)(nsum != 0));
X  }
X  
X  #endif /* POLYSELF */
X*** /tmp/da21529	Mon Jul 12 17:35:18 1993
X--- src/vault.c	Wed Jul  7 16:25:41 1993
X***************
X*** 739,745 ****
X  {
X  	register struct monst *grd = findgd();
X  
X! 	return(grd == (struct monst *)0);
X  }
X  #endif
X  
X--- 739,745 ----
X  {
X  	register struct monst *grd = findgd();
X  
X! 	return((boolean)(grd == (struct monst *)0));
X  }
X  #endif
X  
X*** /tmp/da21537	Mon Jul 12 17:35:20 1993
X--- src/version.c	Wed Jul  7 16:25:44 1993
X***************
X*** 40,46 ****
X  comp_times(filetime)
X  long filetime;
X  {
X! 	return (filetime < BUILD_TIME);
X  }
X  #endif
X  
X--- 40,46 ----
X  comp_times(filetime)
X  long filetime;
X  {
X! 	return((boolean)(filetime < BUILD_TIME));
X  }
X  #endif
X  
X*** /tmp/da21545	Mon Jul 12 17:35:22 1993
X--- src/vision.c	Wed Jul  7 16:25:47 1993
X***************
X*** 1446,1452 ****
X  	}
X      }
X  cleardone:
X!     return result;
X  }
X  
X  #ifdef VISION_TABLES
X--- 1446,1452 ----
X  	}
X      }
X  cleardone:
X!     return((boolean)result);
X  }
X  
X  #ifdef VISION_TABLES
X*** /tmp/da21554	Mon Jul 12 17:35:26 1993
X--- src/weapon.c	Mon Jul 12 13:38:27 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)weapon.c	3.1	93/02/09	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)weapon.c	3.1	93/07/10	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 7,13 ****
X   *	bonuses for any given weapon used, as well as weapons selection
X   *	code for monsters.
X   */
X! #include	"hack.h"
X  
X  #ifdef OVLB
X  
X--- 7,13 ----
X   *	bonuses for any given weapon used, as well as weapons selection
X   *	code for monsters.
X   */
X! #include "hack.h"
X  
X  #ifdef OVLB
X  
X***************
X*** 344,349 ****
X--- 344,350 ----
X  		return;
X  	}
X  	if (!attacktype(mon->data, AT_WEAP)) {
X+ 		mw_tmp->owornmask &= ~W_WEP;
X  		MON_NOWEP(mon);
X  		mon->weapon_check = NO_WEAPON_WANTED;
X  		if (cansee(mon->mx, mon->my)) {
X***************
X*** 424,443 ****
X  		 */
X  		if (mw_tmp && mw_tmp->cursed && mw_tmp->otyp != CORPSE) {
X  		    if (canseemon(mon)) {
X  			if (obj->otyp == PICK_AXE) {
X! 			    pline("Since %s weapon %s welded to %s hand,",
X  				  s_suffix(mon_nam(mon)),
X! 				  (mw_tmp->quan == 1L) ? "is" : "are",
X! 				  his[pronoun_gender(mon)]);
X  			    pline("%s cannot wield that %s.",
X  				mon_nam(mon), xname(obj));
X  			} else {
X  			    pline("%s tries to wield %s.", Monnam(mon),
X  				doname(obj));
X! 			    pline("%s %s %s welded to %s hand!",
X! 				  s_suffix(Monnam(mon)), xname(mw_tmp),
X! 				  (mw_tmp->quan == 1L) ? "is" : "are",
X! 				  his[pronoun_gender(mon)]);
X  			}
X  			mw_tmp->bknown = 1;
X  		    }
X--- 425,449 ----
X  		 */
X  		if (mw_tmp && mw_tmp->cursed && mw_tmp->otyp != CORPSE) {
X  		    if (canseemon(mon)) {
X+ 			char welded_buf[BUFSZ];
X+ 
X+ 			Sprintf(welded_buf, "%s welded to %s hand%s",
X+ 				(mw_tmp->quan == 1L) ? "is" : "are",
X+ 				his[pronoun_gender(mon)],
X+ 				objects[mw_tmp->otyp].oc_bimanual ? "s" : "");
X+ 
X  			if (obj->otyp == PICK_AXE) {
X! 			    pline("Since %s weapon%s %s,",
X  				  s_suffix(mon_nam(mon)),
X! 				  plur(mw_tmp->quan), welded_buf);
X  			    pline("%s cannot wield that %s.",
X  				mon_nam(mon), xname(obj));
X  			} else {
X  			    pline("%s tries to wield %s.", Monnam(mon),
X  				doname(obj));
X! 			    pline("%s %s %s!",
X! 				  s_suffix(Monnam(mon)),
X! 				  xname(mw_tmp), welded_buf);
X  			}
X  			mw_tmp->bknown = 1;
X  		    }
X***************
X*** 445,450 ****
X--- 451,457 ----
X  		    return 1;
X  		}
X  		mon->mw = obj;		/* wield obj */
X+ 		if (mw_tmp) mw_tmp->owornmask &= ~W_WEP;
X  		mon->weapon_check = NEED_WEAPON;
X  		if (canseemon(mon)) {
X  			pline("%s wields %s!", Monnam(mon), doname(obj));
X***************
X*** 457,462 ****
X--- 464,470 ----
X  				obj->bknown = 1;
X  			}
X  		}
X+ 		obj->owornmask = W_WEP;
X  		return 1;
X  	}
X  	mon->weapon_check = NEED_WEAPON;
X*** Old/src/windows.c	Wed Jul 14 01:29:19 1993
X--- src/windows.c	Wed Jul 14 01:29:51 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)windows.c	3.1	93/01/08	*/
X  /* Copyright (c) D. Cohrs, 1993. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)windows.c	3.1	93/07/13	*/
X  /* Copyright (c) D. Cohrs, 1993. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 13,27 ****
X  extern void NDECL(win_X11_init);
X  #endif
X  #ifdef MAC
X! extern struct window_procs mac_procs ;
X  #endif
X  #ifdef AMIGA_INTUITION
X! extern struct window_procs amii_procs ;
X! extern struct window_procs amiv_procs ;
X! extern void NDECL( amii_loadlib );
X! extern void NDECL( amiv_loadlib );
X  #endif
X  
X  NEARDATA struct window_procs windowprocs;
X  
X  static
X--- 13,29 ----
X  extern void NDECL(win_X11_init);
X  #endif
X  #ifdef MAC
X! extern struct window_procs mac_procs;
X  #endif
X  #ifdef AMIGA_INTUITION
X! extern struct window_procs amii_procs;
X! extern struct window_procs amiv_procs;
X! extern void NDECL(amii_loadlib);
X! extern void NDECL(amiv_loadlib);
X  #endif
X  
X+ static void FDECL(def_raw_print, (const char *s));
X+ 
X  NEARDATA struct window_procs windowprocs;
X  
X  static
X***************
X*** 36,51 ****
X      { &X11_procs, win_X11_init },
X  #endif
X  #ifdef MAC
X! 	{ & mac_procs , NULL } ,
X  #endif
X  #ifdef AMIGA_INTUITION
X  	/* A shared library is used for implementing the access to these two
X  	 * different display mechanisms.  This means that the function names
X! 	 * are actually the same (assembler stubs) and the libraries do different
X! 	 * things.
X  	 */
X! 	{ & amii_procs , amii_loadlib } ,
X! 	{ & amiv_procs , amiv_loadlib } ,
X  #endif
X      { 0, 0 }		/* must be last */
X  };
X--- 38,53 ----
X      { &X11_procs, win_X11_init },
X  #endif
X  #ifdef MAC
X!     { &mac_procs, 0 },
X  #endif
X  #ifdef AMIGA_INTUITION
X  	/* A shared library is used for implementing the access to these two
X  	 * different display mechanisms.  This means that the function names
X! 	 * are actually the same (assembler stubs) and the libraries do
X! 	 * different things.
X  	 */
X!     { &amii_procs, amii_loadlib },
X!     { &amiv_procs, amiv_loadlib },
X  #endif
X      { 0, 0 }		/* must be last */
X  };
X*** /tmp/da21587	Mon Jul 12 17:35:34 1993
X--- src/wizard.c	Wed Jul  7 16:25:52 1993
X***************
X*** 208,219 ****
X  	register int mask;
X  {
X  	switch(mask) {
X! 	    case M3_WANTSAMUL:	return(u.uhave.amulet);
X! 	    case M3_WANTSBELL:	return(u.uhave.bell);
X! 	    case M3_WANTSCAND:	return(u.uhave.menorah);
X! 	    case M3_WANTSBOOK:	return(u.uhave.book);
X  #ifdef MULDGN
X! 	    case M3_WANTSARTI:	return(u.uhave.questart);
X  #endif
X  	    default:		break;
X  	}
X--- 208,219 ----
X  	register int mask;
X  {
X  	switch(mask) {
X! 	    case M3_WANTSAMUL:	return(boolean)(u.uhave.amulet);
X! 	    case M3_WANTSBELL:	return(boolean)(u.uhave.bell);
X! 	    case M3_WANTSCAND:	return(boolean)(u.uhave.menorah);
X! 	    case M3_WANTSBOOK:	return(boolean)(u.uhave.book);
X  #ifdef MULDGN
X! 	    case M3_WANTSARTI:	return(boolean)(u.uhave.questart);
X  #endif
X  	    default:		break;
X  	}
X*** /tmp/da21605	Mon Jul 12 17:35:39 1993
X--- src/worn.c	Fri Jul  2 15:28:14 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)worn.c	3.1	93/02/09
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)worn.c	3.1	93/06/24	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 212,218 ****
X  			*ppronoun = his[pronoun_gender(mon)];
X  
X  	if (breakarm(mdat)) {
X! 	    if (otmp = which_armor(mon, W_ARM)) {
X  		if (vis)
X  		    pline("%s breaks out of %s armor!", Monnam(mon), ppronoun);
X  		else
X--- 212,218 ----
X  			*ppronoun = his[pronoun_gender(mon)];
X  
X  	if (breakarm(mdat)) {
X! 	    if ((otmp = which_armor(mon, W_ARM)) != 0) {
X  		if (vis)
X  		    pline("%s breaks out of %s armor!", Monnam(mon), ppronoun);
X  		else
X***************
X*** 220,226 ****
X  		mon->misc_worn_check &= ~W_ARM;
X  		m_useup(mon, otmp);
X  	    }
X! 	    if (otmp = which_armor(mon, W_ARMC)) {
X  		if (otmp->oartifact) {
X  		    if (vis)
X  			pline("%s cloak falls off!", s_suffix(Monnam(mon)));
X--- 220,226 ----
X  		mon->misc_worn_check &= ~W_ARM;
X  		m_useup(mon, otmp);
X  	    }
X! 	    if ((otmp = which_armor(mon, W_ARMC)) != 0) {
X  		if (otmp->oartifact) {
X  		    if (vis)
X  			pline("%s cloak falls off!", s_suffix(Monnam(mon)));
X***************
X*** 237,243 ****
X  		}
X  	    }
X  # ifdef TOURIST
X! 	    if (otmp = which_armor(mon, W_ARMU)) {
X  		if (vis)
X  		    pline("%s shirt rips to shreds!", s_suffix(Monnam(mon)));
X  		else
X--- 237,243 ----
X  		}
X  	    }
X  # ifdef TOURIST
X! 	    if ((otmp = which_armor(mon, W_ARMU)) != 0) {
X  		if (vis)
X  		    pline("%s shirt rips to shreds!", s_suffix(Monnam(mon)));
X  		else
X***************
X*** 247,253 ****
X  	    }
X  # endif
X          } else if (sliparm(mdat)) {
X! 	    if (otmp = which_armor(mon, W_ARM)) {
X  		if (vis)
X  		    pline("%s armor falls around %s!", 
X  			         s_suffix(Monnam(mon)), pronoun);
X--- 247,253 ----
X  	    }
X  # endif
X          } else if (sliparm(mdat)) {
X! 	    if ((otmp = which_armor(mon, W_ARM)) != 0) {
X  		if (vis)
X  		    pline("%s armor falls around %s!", 
X  			         s_suffix(Monnam(mon)), pronoun);
X***************
X*** 257,263 ****
X  		otmp->owornmask &= ~W_ARM;
X  		rel_1_obj(mon, otmp);
X  	    }
X! 	    if (otmp = which_armor(mon, W_ARMC)) {
X  		if (vis)
X  		    if (is_whirly(mon->data))
X  			pline("%s cloak falls, unsupported!", 
X--- 257,263 ----
X  		otmp->owornmask &= ~W_ARM;
X  		rel_1_obj(mon, otmp);
X  	    }
X! 	    if ((otmp = which_armor(mon, W_ARMC)) != 0) {
X  		if (vis)
X  		    if (is_whirly(mon->data))
X  			pline("%s cloak falls, unsupported!", 
X***************
X*** 270,276 ****
X  		rel_1_obj(mon, otmp);
X  	    }
X  # ifdef TOURIST
X! 	    if (otmp = which_armor(mon, W_ARMU)) {
X  		if (vis)
X  		    if (sliparm(mon->data))
X  			pline("%s seeps right through %s shirt!",
X--- 270,276 ----
X  		rel_1_obj(mon, otmp);
X  	    }
X  # ifdef TOURIST
X! 	    if ((otmp = which_armor(mon, W_ARMU)) != 0) {
X  		if (vis)
X  		    if (sliparm(mon->data))
X  			pline("%s seeps right through %s shirt!",
X***************
X*** 285,291 ****
X  # endif
X  	}
X  	if (nohands(mdat) || verysmall(mdat)) {
X! 	    if (otmp = which_armor(mon, W_ARMG)) {
X  		if (vis)
X  		    pline("%s drops %s gloves%s!", Monnam(mon), ppronoun,
X  					MON_WEP(mon) ? " and weapon" : "");
X--- 285,291 ----
X  # endif
X  	}
X  	if (nohands(mdat) || verysmall(mdat)) {
X! 	    if ((otmp = which_armor(mon, W_ARMG)) != 0) {
X  		if (vis)
X  		    pline("%s drops %s gloves%s!", Monnam(mon), ppronoun,
X  					MON_WEP(mon) ? " and weapon" : "");
X***************
X*** 294,300 ****
X  		otmp->owornmask &= ~W_ARMG;
X  		rel_1_obj(mon, otmp);
X  	    }
X! 	    if (otmp = which_armor(mon, W_ARMS)) {
X  		if (vis)
X  		    pline("%s can no longer hold %s shield!", Monnam(mon),
X  								ppronoun);
X--- 294,300 ----
X  		otmp->owornmask &= ~W_ARMG;
X  		rel_1_obj(mon, otmp);
X  	    }
X! 	    if ((otmp = which_armor(mon, W_ARMS)) != 0) {
X  		if (vis)
X  		    pline("%s can no longer hold %s shield!", Monnam(mon),
X  								ppronoun);
X***************
X*** 304,313 ****
X  		otmp->owornmask &= ~W_ARMS;
X  		rel_1_obj(mon, otmp);
X  	    }
X! 	    if (otmp = which_armor(mon, W_ARMH)) {
X  		if (vis)
X! 		    pline("%s helmet falls to the floor!", 
X! 			           s_suffix(Monnam(mon)));
X  		else
X  		    You("hear a clank.");
X  		mon->misc_worn_check &= ~W_ARMH;
X--- 304,313 ----
X  		otmp->owornmask &= ~W_ARMS;
X  		rel_1_obj(mon, otmp);
X  	    }
X! 	    if ((otmp = which_armor(mon, W_ARMH)) != 0) {
X  		if (vis)
X! 		    pline("%s helmet falls to the %s!", 
X! 			  s_suffix(Monnam(mon)), surface(mon->mx, mon->my));
X  		else
X  		    You("hear a clank.");
X  		mon->misc_worn_check &= ~W_ARMH;
X***************
X*** 317,323 ****
X  	}
X  	if (nohands(mdat) || verysmall(mdat) || slithy(mdat) ||
X  	    mdat->mlet == S_CENTAUR) {
X! 	    if (otmp = which_armor(mon, W_ARMF)) {
X  		if (vis) {
X  		    if (is_whirly(mon->data))
X  			pline("%s boots fall away!", 
X--- 317,323 ----
X  	}
X  	if (nohands(mdat) || verysmall(mdat) || slithy(mdat) ||
X  	    mdat->mlet == S_CENTAUR) {
X! 	    if ((otmp = which_armor(mon, W_ARMF)) != 0) {
X  		if (vis) {
X  		    if (is_whirly(mon->data))
X  			pline("%s boots fall away!", 
X*** /tmp/da21622	Mon Jul 12 17:35:43 1993
X--- src/zap.c	Fri Jul  9 15:36:30 1993
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)zap.c	3.1	93/05/17	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)zap.c	3.1	93/06/16	*/
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 425,431 ****
X  	} else {
X  		int chance = rn2(100);
X  
X! 		return (chance < (obj->oartifact ? achance : ochance));
X  	}
X  }
X  
X--- 425,431 ----
X  	} else {
X  		int chance = rn2(100);
X  
X! 		return((boolean)(chance < (obj->oartifact ? achance : ochance)));
X  	}
X  }
X  
X***************
X*** 447,453 ****
X  	/* adjust for "large" quantities of identical things */
X  	if(obj->quan > 4L) zap_odds /= 2;
X  
X! 	return (! rn2(zap_odds));
X  }
X  
X  /* Use up at least minwt number of things made of material mat.
X--- 447,453 ----
X  	/* adjust for "large" quantities of identical things */
X  	if(obj->quan > 4L) zap_odds /= 2;
X  
X! 	return((boolean)(! rn2(zap_odds)));
X  }
X  
X  /* Use up at least minwt number of things made of material mat.
X***************
X*** 963,969 ****
X  		case WAN_FIRE:
X  		    makeknown(WAN_FIRE);
X  		case FIRE_HORN:
X- 		    pline("You've set yourself afire!");
X  		    if (Fire_resistance) {
X  			shieldeff(u.ux, u.uy);
X  			You("feel rather warm.");
X--- 963,968 ----
X***************
X*** 970,977 ****
X  #ifdef POLYSELF
X  			ugolemeffects(AD_FIRE, d(12,6));
X  #endif
X! 		    } else
X  			damage = d(12,6);
X  		    destroy_item(SCROLL_CLASS, AD_FIRE);
X  		    destroy_item(POTION_CLASS, AD_FIRE);
X  		    destroy_item(SPBOOK_CLASS, AD_FIRE);
X--- 969,978 ----
X  #ifdef POLYSELF
X  			ugolemeffects(AD_FIRE, d(12,6));
X  #endif
X! 		    } else {
X! 			pline("You've set yourself afire!");
X  			damage = d(12,6);
X+ 		    }
X  		    destroy_item(SCROLL_CLASS, AD_FIRE);
X  		    destroy_item(POTION_CLASS, AD_FIRE);
X  		    destroy_item(SPBOOK_CLASS, AD_FIRE);
X***************
X*** 1258,1264 ****
X  				    stackobj(fobj);
X  				    if(Invisible) newsym(u.ux, u.uy);
X  				} else {
X! 				    dighole();
X  				}
X  			    }
X  			    break;
X--- 1259,1265 ----
X  				    stackobj(fobj);
X  				    if(Invisible) newsym(u.ux, u.uy);
X  				} else {
X! 				    (void) dighole(FALSE);
X  				}
X  			    }
X  			    break;
X***************
X*** 2175,2180 ****
X--- 2176,2182 ----
X  		} else {
X  		    rangemod -= 3;
X  		    if (lev->typ == DRAWBRIDGE_UP) {
X+ 			lev->drawbridgemask &= ~DB_UNDER;  /* clear lava */
X  			lev->drawbridgemask |= (lava ? DB_FLOOR : DB_ICE);
X  		    } else {
X  			if (!lava)
END_OF_FILE
if test 56262 -ne `wc -c <'patches03c'`; then
    echo shar: \"'patches03c'\" unpacked with wrong size!
fi
# end of 'patches03c'
if test -f 'sys/share/NOTE' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'sys/share/NOTE'\" to \"'sys/share/NOTE.orig'\"
  mv -f 'sys/share/NOTE' 'sys/share/NOTE.orig'
fi
echo shar: Extracting \"'sys/share/NOTE'\" \(803 characters\)
sed "s/^X//" >'sys/share/NOTE' <<'END_OF_FILE'
XThe files lev_yacc.c, lev_lex.c, lev_comp.h, dgn_yacc.c, dgn_lex.c
Xand dgn_comp.h in this directory were generated on a Sun, using byacc
X(4.4BSD yacc) and flex, and were placed here for the convenience of
Xthose who do not have native lex/yacc on their system.
X
XThese files, while widely tested, are NOT guaranteed to work on all
Xsystems.  In particular, the flex output files (lev_lex.c and dgn_lex.c)
Xare known NOT to work on the Macintosh, when using MPW (they do work
Xwith Think C).  If you use MPW, and you do NOT have native lex to generate
Xyour own files, do one of the following:  Either (a) get/generate these
Xfiles from/on a UNIX system, using standard lex (not flex), or (b) seek
Xthe files from another Macintosh/MPW owner, who has lex on his system.
XSorry, but that's the best we can do now.
END_OF_FILE
if test 803 -ne `wc -c <'sys/share/NOTE'`; then
    echo shar: \"'sys/share/NOTE'\" unpacked with wrong size!
fi
# end of 'sys/share/NOTE'
echo shar: End of archive 2 \(of 18\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 18 archives.
    echo "Now execute ./patchit3.sh"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
