Path: uunet!news.tek.com!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v18i048:  nethack31 - display oriented dungeons & dragons (Ver. 3.1), Patch3o/18
Date: 20 Jul 1993 22:33:33 GMT
Organization: Tektronix, Inc, Redmond, OR, USA
Lines: 2113
Approved: billr@saab.CNA.TEK.COM
Message-ID: <22hrrt$9q7@ying.cna.tek.com>
NNTP-Posting-Host: saab.cna.tek.com
Xref: uunet comp.sources.games:1848

Submitted-by: izchak@linc.cis.upenn.edu (Izchak Miller)
Posting-number: Volume 18, Issue 48
Archive-name: nethack31/patch3o
Patch-To: nethack31: Volume 16, Issue 1-116
Environment: Amiga, Atari, Mac, MS-DOS, Windows-NT, OS2, Unix, VMS, X11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 15 (of 18)."
# Contents:  sys/mac/macmenu.c sys/share/dgn_yacc.c
# Wrapped by billr@saab on Tue Jul 20 14:57:23 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'sys/mac/macmenu.c' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'sys/mac/macmenu.c'\" to \"'sys/mac/macmenu.c.orig'\"
  mv -f 'sys/mac/macmenu.c' 'sys/mac/macmenu.c.orig'
fi
echo shar: Extracting \"'sys/mac/macmenu.c'\" \(23678 characters\)
sed "s/^X//" >'sys/mac/macmenu.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)macmenu.c	3.1	           93/04/29       */
X/*      Copyright (c) Macintosh NetHack Port Team, 1993.          */
X/* NetHack may be freely redistributed.  See license for details. */
X
X/****************************************\
X * Extended Macintosh menu support
X *
X * provides access to all keyboard commands from cmd.c
X * provides control key functionality for classic keyboards
X * provides key equivalent references and logical menu groups
X * supports various menu highlighting modes
X * does not (yet) provide balloon help support (maybe never will!)
X\****************************************/
X
X/****************************************\
X * Edit History:
X *
X * 930512	- More bug fixes and getting tty to work again, Jon W{tte
X * 930508	- Bug fixes in-flight, Jon W{tte
X * 04/29/93 - 1st Release Draft, David Hairston
X * 04/11/93 - 1st Draft, David Hairston
X\****************************************/
X
X/******** Application Defines ********/
X#include "hack.h"
X#include "patchlevel.h"
X
X/******** Toolbox Defines ********/
X/* #include <Controls.h> */
X#include <Desk.h>
X/* #include <Dialogs.h> */
X/* #include <Memory.h> */
X#include <Menus.h>
X/* #include <Quickdraw.h> */
X#include <Resources.h>
X/* #include <SegLoad.h> */
X#include <TextEdit.h>
X#include <ToolUtils.h>
X#include <Packages.h>
X/* #include <Windows.h> */
X
X/* Think/MPW incompatibility from Think.h/Script.h */
X#if !defined(__THINK__) && !defined(__SCRIPT__)
X#define GetMBarHeight()		(* (short *) 0x0BAA)
X#endif
X
X/* Think/MPW incompatibility from LoMem.h/SysEqu.h */
X#if !defined(__LOMEM__) && !defined(__SYSEQU__)
Xenum { WindowList = 0x9D6 };
X#endif
X
X/* Think has separated out c2pstr and other pascal odditites */
X#if defined(THINK_C)
X#include <pascal.h>
X#endif
X
X/******** Local Defines ********/
X
X/* 'MNU#' (menu list record) */
Xtypedef union menuRefUnn
X{
X	short		mresID;		/* MENU resource ID (before GetMenu) */
X	MenuHandle	mhnd;		/* MENU handle (after GetMenu) */
X} menuRefUnn;
X
Xtypedef struct menuListRec
X{
X	short		firstMenuID;
X	short		numMenus;
X	menuRefUnn	mref[];
X} menuListRec, *menuListPtr, **menuListHandle;
X
X/* indices and resource IDs of the menu list data */
Xenum
X{
X	listMenubar,
X	listSubmenu,
X
X	menuBarListID = 128,
X	subMenuListID
X};
X
X/* the following mref[] indices are reserved */
Xenum
X{
X	/* menu bar */
X	menuApple,
X	menuFile,
X	menuEdit,
X
X	/* submenu */
X	menuWizard = 0
X};
X
X/* the following menu items are reserved */
Xenum
X{
X	/* apple */
X	menuAppleAboutBox = 1,
X	____Apple__1,
X
X	/* File */
X	menuFileOpenMap = 1,
X	menuFileRedraw,
X	menuFilePrevMsg,
X	menuFileCleanup,
X	menuFileClose,
X	____File___1,
X	menuFilePlayMode,
X	menuFileEnterExplore,
X	____File___2,
X	menuFileOptionEdit,
X	____File___3,
X	menuFileSave,
X	____File___4,
X	menuFileQuit,
X
X	/* standard minimum Edit menu items */
X
X	/* Wizard */
X	menuWizardAttributes = 1
X};
X
X/* symbols here correspond to arrays in DialogAskName */
X/* eventually this data will become a 'STR#' resource */
Xstatic unsigned char	uitmChar[3][16] = {{"ABCEHKPRSTVW"}, {"MF"}, {" XD"}};
X
X	/* arrays here correspond to symbols in drawANUserItem */
X	/* eventually this data will be moved to 'STR#' resources */
Xstatic unsigned char * nhRole [ askn_role_end ] = {
X	{"\pArcheologist"}, {"\pBarbarian"},
X	{"\pCaveman"}, {"\pElf"}, {"\pHealer"}, {"\pKnight"},
X	{"\pPriest"}, {"\pRogue"}, {"\pSamurai"}, {"\pTourist"},
X	{"\pValkyrie"}, {"\pWizard"}
X};
Xstatic unsigned char * nhSex [ 2 ] = {
X	{"\pMale"}, {"\pFemale"}
X};
Xstatic unsigned char * nhMode [ 3 ] = {
X	{"\pRegular"}, {"\pExplore"}, {"\pDebug"}
X};
X
X
X/*
X * menuListRec data (preloaded and locked) specifies the number of menus in
X * the menu bar, the number of hierarchal or submenus and the menu IDs of
X * all of those menus.  menus that go into in the menu bar are specified by
X * 'MNU#' 128 and submenus are specified by 'MNU#' 129.  the fields of the
X * menuListRec are:
X * firstMenuID - the menu ID (not resource ID) of the 1st menu.  subsequent
X *     menus in the list are _forced_ to have consecutively incremented IDs.
X * numMenus - the total count of menus in a given list (and the extent of
X *     valid menu IDs).
X * mref[] - initially the MENU resource ID is stored in the placeholder for
X *     the resource handle.  after loading (GetResource), the menu handle
X *     is stored and the menu ID, in memory, is set as noted above.
X *
X * NOTE: a ResEdit template editor is supplied to edit the 'MNU#' resources.
X *
X * NOTE: the resource IDs do not need to match the menu IDs in a menu list
X * record although they have been originally set that way.
X *
X * NOTE: the menu ID's of menus in the submenu list record may be reset, as
X * noted above.  it is the programmers responsibility to make sure that
X * submenu references/IDs are valid.
X *
X * WARNING: the existence of the submenu list record is assumed even if the
X * number of submenus is zero.  also, no error checking is done on the
X * extents of the menu IDs.  this must be correctly setup by the programmer.
X */
X
X#define ID1_MBAR	pMenuList[listMenubar]->firstMenuID
X#define ID1_SUBM	pMenuList[listSubmenu]->firstMenuID
X
X#define NUM_MBAR	pMenuList[listMenubar]->numMenus
X#define NUM_SUBM	pMenuList[listSubmenu]->numMenus
X
X#define MHND_APPLE	pMenuList[listMenubar]->mref[menuApple].mhnd
X#define MHND_FILE	pMenuList[listMenubar]->mref[menuFile].mhnd
X#define MHND_EDIT	pMenuList[listMenubar]->mref[menuEdit].mhnd
X
X#define MBARHND(x)	pMenuList[listMenubar]->mref[(x)].mhnd
X
X#define MHND_WIZ	pMenuList[listSubmenu]->mref[menuWizard].mhnd
X
X
X/* mutually exclusive (and prioritized) menu bar states */
Xenum
X{
X	mbarDim,
X	mbarNoWindows,
X	mbarDA,
X	mbarNoMap,
X	mbarRegular,
X	mbarSpecial					/* explore or debug mode */
X};
X
X#define WKND_MAP		(WIN_BASE_KIND + NHW_MAP)
X
X
X/* menu routine error numbers */
Xenum
X{
X	errGetMenuList,
X	errGetMenu,
X	errGetANDlogTemplate,
X	errGetANDlogItems,
X	errGetANDialog,
X	errANNewMenu,
X	err_Menu_total
X};
X
X
X/* menu 'STR#' comment char */
X#define mstrEndChar		0xA5		/* '\245' or option-* or "bullet" */
X
X/* max key queue (from macwin.c) */
X#define QUEUE_LEN		keyQueueLen
Xextern const int keyQueueLen ;
X
X/* 'ALRT' */
Xenum
X{
X	alrt_Menu_start = 5000,
X	alrtMenuNote = alrt_Menu_start,
X	alrtMenu_NY,
X	alrt_Menu_limit
X};
X
X#define beepMenuAlertErr	1		/* # of SysBeep()'s before exitting */
Xenum
X{
X	bttnMenuAlertNo = 1,
X	bttnMenuAlertYes
X};
X
X/* askname menus */
Xenum
X{
X	menuANRole,
X	menuANSex,
X	menuANMode,
X	menuAN_total
X};
X
X
X/******** Globals ********/
Xstatic	unsigned char *menuErrStr[err_Menu_total] = 
X	{
X		"\pAbort: Bad \'MNU#\' resource!",		/* errGetMenuList */
X		"\pAbort: Bad \'MENU\' resource!",		/* errGetMenu */
X		"\pAbort: Bad \'DLOG\' resource!",		/* errGetANDlogTemplate */
X		"\pAbort: Bad \'DITL\' resource!",		/* errGetANDlogItems */
X		"\pAbort: Bad Dialog Allocation!",		/* errGetANDialog */
X		"\pAbort: Bad Menu Allocation!",		/* errANNewMenu */
X	};
Xstatic	menuListPtr	pMenuList[2];
Xstatic	short		theMenubar = mbarDA;	/* force initial update */
Xstatic	short		kAdjustWizardMenu = 1;
X
X
X/******** Prototypes ********/
Xstatic	void alignAD(Rect *, short);
Xstatic	void mustGetMenuAlerts(void);
Xstatic	void menuError(short);
X
Xextern	void AddToKeyQueue ( int ch , Boolean force ) ;
Xpascal	void drawANUserItem(WindowPtr, short);
X		void DialogAskName(asknameRec *);
X		void InitMenuRes(void);
X		void AdjustMenus(short);
X		void DoMenuEvt(long);
Xextern	void WindowGoAway(EventRecord *, WindowPtr);
X
Xstatic	void aboutNetHack(void);
Xstatic	void openMap(void);
Xstatic	void closeFrontWindow(void);
Xstatic	void optionEditor(void);
Xstatic	void askSave(void);
Xstatic	void askQuit(void);
X
X
X/******** Routines ********/
Xstatic void
XalignAD(Rect *pRct, short vExempt)
X{
X	(*pRct).right -= (*pRct).left;		/* width */
X	(*pRct).bottom -= (*pRct).top;		/* height */
X	(*pRct).left = (qd.screenBits.bounds.right - (*pRct).right) / 2;
X	(*pRct).top = (qd.screenBits.bounds.bottom - (*pRct).bottom - vExempt) / 2;
X	(*pRct).top += vExempt;
X	(*pRct).right += (*pRct).left;
X	(*pRct).bottom += (*pRct).top;
X}
X
Xstatic void
XmustGetMenuAlerts()
X{
X	short		i, mbarHgt = GetMBarHeight();
X	Rect		**hRct;
X
X	for (i = alrt_Menu_start; i < alrt_Menu_limit; i++)
X	{
X		if (! (hRct = (Rect **) GetResource('ALRT', i)))	/* AlertTHndl */
X		{
X			for (i = 0; i < beepMenuAlertErr; i++)
X				SysBeep(3);
X			ExitToShell();
X		}
X
X		alignAD(*hRct, mbarHgt);
X	}
X}
X
Xstatic void
XmenuError(short menuErr)
X{
X	short	i;
X
X	for (i = 0; i < beepMenuAlertErr; i++)
X		SysBeep(3);
X
X	ParamText(menuErrStr[menuErr], "\p", "\p", "\p");
X	(void) Alert(alrtMenuNote, (ModalFilterProcPtr) 0L);
X
X	ExitToShell();
X}
X
Xpascal void
XdrawANUserItem(WindowPtr wPtr, short uItm)
X{
X	asknameRec	*pANR;
X	short		iTyp;
X	Handle		iHnd;
X	Rect		iRct;
X	short		whichUserItem;
X
X	pANR = (asknameRec *) GetWRefCon(wPtr);
X	GetDItem((DialogPtr) wPtr, uItm, &iTyp, &iHnd, &iRct);
X
X	switch (uItm)
X	{
X	case uitmANOutlineDefault:
X		PenSize(3, 3);
X		FrameRoundRect(&iRct, 16, 16);
X		break;
X
X	case uitmANRole:
X	case uitmANSex:
X	case uitmANMode:
X		whichUserItem = uItm - uitmANRole;
X
X		PenNormal();
X		EraseRect(&iRct);
X
X		/* drop shadow */
X		iRct.right--;
X		iRct.bottom--;
X		MoveTo(iRct.right, (iRct.top + 1));
X		LineTo(iRct.right, iRct.bottom);
X		LineTo((iRct.left + 1), iRct.bottom);
X
X		/* frame */
X		FrameRect(&iRct);
X
X		/* menu character */
X		MoveTo((iRct.left + 2), (iRct.top + 12));
X		DrawChar(uitmChar[whichUserItem][(*pANR).anMenu[whichUserItem]]);
X
X		/* popup symbol */
X		MoveTo((iRct.left + 18), (iRct.top + 6));
X		LineTo((iRct.left + 28), (iRct.top + 6));
X		LineTo((iRct.left + 23), (iRct.top + 11));
X		LineTo((iRct.left + 19), (iRct.top + 7));
X		LineTo((iRct.left + 26), (iRct.top + 7));
X		LineTo((iRct.left + 23), (iRct.top + 10));
X		LineTo((iRct.left + 21), (iRct.top + 8));
X		LineTo((iRct.left + 24), (iRct.top + 8));
X		LineTo((iRct.left + 23), (iRct.top + 9));
X		break;
X	}
X}
X
X/* this routine manages the extended askname dialog */
Xvoid
XDialogAskName(asknameRec *pANR)
X{
X	GrafPtr			pOldPort;
X	DialogTHndl		dTHnd;
X	Handle			dIHnd;
X	DialogRecord	dRec;
X	short			i, iHit, iTyp;
X	Handle			iHnd;
X	Rect			iRct, iRct2;
X	MenuHandle		mhndAskName[menuAN_total];
X	short			mbarHgt = GetMBarHeight();
X	short			ndxItem, menuEntry;
X	Point			pt;
X
X	if (! (dTHnd = (DialogTHndl) GetResource('DLOG', dlogAskName)))
X		menuError(errGetANDlogTemplate);
X	alignAD((Rect *) *dTHnd, mbarHgt);
X
X	if (! (dIHnd = GetResource('DITL', dlogAskName)))
X		menuError(errGetANDlogItems);
X
X	GetPort(&pOldPort);
X	/* to do: check if theWorld.hasColorQD ... */
X	(void) GetNewDialog(dlogAskName, (Ptr) &dRec, (WindowPtr) 0L);
X	if (ResError() || MemError())
X		menuError(errGetANDialog);
X
X	SetWRefCon((WindowPtr) &dRec, (long) pANR);
X	for (i = 0; i < menuAN_total; i++) {
X		if (! (mhndAskName[i] = NewMenu((dlogAskName + i), "\pPopup")))
X			menuError(errANNewMenu);
X	}
X
X	/* role menu */
X	for (i = 0; i < askn_role_end; i++)
X		AppendMenu(mhndAskName[menuANRole], * (Str255 *) nhRole[i]);
X
X	/* sex menu */
X	for (i = 0; i < 2; i++)
X		AppendMenu(mhndAskName[menuANSex], * (Str255 *) nhSex[i]);
X
X	/* mode menu */
X	for (i = 0; i < 3; i++)
X		AppendMenu(mhndAskName[menuANMode], * (Str255 *) nhMode[i]);
X
X	/* insert the popup menus */
X	for (i = 0; i < menuAN_total; i++)
X		InsertMenu(mhndAskName[i], hierMenu);
X
X	for (i = uitmANOutlineDefault; i <= uitmANMode; i++)
X	{
X		GetDItem((DialogPtr)&dRec, i, &iTyp, &iHnd, &iRct);
X		SetDItem((DialogPtr)&dRec, i, iTyp, (Handle) drawANUserItem, &iRct);
X	}
X	{
X	short kind ; Handle item ; Rect area ;
X	Str32 pName ;
X		pName [ 0 ] = 0 ;
X		if ( plname && plname [ 0 ] ) {
X			strcpy ( ( char * ) pName , plname ) ;
X			c2pstr ( ( char * ) pName ) ;
X		} else {
X			Handle h ;
X			h = GetResource ( 'STR ' , -16096 ) ;
X			if ( ( (Handle) NULL != h ) && ( GetHandleSize ( h ) > 0 ) ) {
X				DetachResource ( h ) ;
X				HLock ( h ) ;
X				if ( * * h > 31 ) {
X					* * h = 31 ;
X				}
X				BlockMove ( * h , pName , * * h + 1 )  ;
X				DisposeHandle ( h ) ;
X			}
X		}
X		if ( pName [ 0 ] ) {
X			GetDItem ( ( WindowPtr ) & dRec , etxtANWho , & kind , & item , & area ) ;
X			SetIText ( item , pName ) ;
X			if ( pName [ 0 ] > 2 && pName [ pName [ 0 ] - 1 ] == '-' ) {
X				(*pANR).anMenu[anRole] = ( strchr ( (char *) uitmChar [ 0 ] , pName [ pName [ 0 ] ] ) -
X					(char *) uitmChar [ 0 ] ) ;
X			}
X		}
X	}
X	SelIText ( ( WindowPtr ) & dRec , etxtANWho , 0 , 32767 ) ;
X
X	SetPort((GrafPtr) &dRec);
X	ShowWindow((WindowPtr) &dRec);
X	SelectWindow((WindowPtr) &dRec);
X
X	iHit = bttnANQuit + 1;
X	while (iHit > bttnANQuit)
X	{
X		/* adjust the askname menus */
X		{
X			static short	checkFeatures = 1;
X			static short	currRole = -1, currSex = -1;
X			unsigned char	anCavePerson[2][16] = {{"\pCaveman"}, {"\pCavewoman"}};
X			unsigned char	anCleric[2][16] = {{"\pPriest"}, {"\pPriestess"}};
X
X			if (checkFeatures)
X			{
X				checkFeatures = 0;
X
X#ifndef TOURIST
X				DisableItem(mhndAskName[menuANRole], (asknTourist + 1));
X#endif
X#ifndef WIZARD
X				DisableItem(mhndAskName[menuANMode], (asknDebug + 1));
X#endif
X#ifndef EXPLORE_MODE
X				DisableItem(mhndAskName[menuANMode], (asknExplore + 1));
X#endif
X			}
X
X			/* check role 1st, valkyrie forces female */
X			if (currRole != (*pANR).anMenu[anRole])
X			{
X				currRole = (*pANR).anMenu[anRole];
X
X				if ((*pANR).anMenu[anRole] == asknValkyrie)
X				{
X					(*pANR).anMenu[anSex] = asknFemale;
X
X					GetDItem((DialogPtr) &dRec, uitmANSex, &iTyp, &iHnd, &iRct);
X					InvalRect(&iRct);
X
X					/* disable male sex option */
X					DisableItem(mhndAskName[menuANSex], (asknMale + 1));
X				}
X				else
X					/* enable male sex option */
X					EnableItem(mhndAskName[menuANSex], (asknMale + 1));
X			}
X
X			if (currSex != (*pANR).anMenu[anSex])
X			{
X				currSex = (*pANR).anMenu[anSex];
X
X				SetItem(mhndAskName[menuANRole], (asknCaveman + 1),
X						* (Str255 *) anCavePerson[currSex]);
X				SetItem(mhndAskName[menuANRole], (asknPriest + 1),
X						* (Str255 *) anCleric[currSex]);
X			}
X		}
X
X		ModalDialog((ModalFilterProcPtr) 0L, &iHit);
X
X		switch (iHit)
X		{
X		case bttnANPlay:		/* done!  let's play */
X			break;
X
X		case bttnANQuit:
X			(*pANR).anMenu[anMode] = asknQuit;
X			break;
X
X		case uitmANRole:
X		case uitmANSex:
X		case uitmANMode:
X			ndxItem = iHit - uitmANRole;
X
X			/* invert the popup title */
X			GetDItem((DialogPtr) &dRec, (iHit + 3), &iTyp, &iHnd, &iRct2);
X			InvertRect(&iRct2);
X
X			/* get the menu item */
X			GetDItem((DialogPtr) &dRec, iHit, &iTyp, &iHnd, &iRct);
X			pt = * (Point *) &iRct;
X			LocalToGlobal(&pt);
X			if (menuEntry = PopUpMenuSelect(mhndAskName[ndxItem],
X							pt.v, pt.h, ((*pANR).anMenu[ndxItem] + 1)))
X				/* set last item selected */
X				(*pANR).anMenu[ndxItem] = LoWord(menuEntry) - 1;
X
X			InvertRect(&iRct2);
X			InvalRect(&iRct);
X			break;
X
X		case etxtANWho:
X			/* limit the data here to 25 chars */
X			{
X				short beepTEDelete = 1;
X
X				while ((**dRec.textH).teLength > 25)
X				{
X					if (beepTEDelete++ <= 3)
X						SysBeep(3);
X					TEKey('\b', dRec.textH);
X				}
X			}
X
X			/* special case filter (that doesn't plug all the holes!) */
X			if (((**dRec.textH).teLength == 1) && (**((**dRec.textH).hText) < 32))
X				TEKey('\b', dRec.textH);
X
X			/* if no name then disable the play button */
X			GetDItem((DialogPtr) &dRec, bttnANPlay, &iTyp, &iHnd, &iRct);
X			if ((**dRec.textH).teLength > 0)
X				iTyp &= ~itemDisable;
X			else
X				iTyp |= itemDisable;
X			HiliteControl((ControlHandle) iHnd, ((iTyp & itemDisable) ? 255 : 0));
X			SetDItem((DialogPtr) &dRec, bttnANPlay, iTyp, iHnd, &iRct);
X			break;
X		}
X	}
X
X	if ((*pANR).anMenu[anMode] != asknQuit) {
X/*
X * This is a good example of how NOT to get text from a dialog
X *
X *		HLock((Handle) (**dRec.textH).hText);
X *		BlockMove(*((**dRec.textH).hText), &((*pANR).anWho[1]), (**dRec.textH).teLength);
X *		(*pANR).anWho[0] = (**dRec.textH).teLength;
X *		HUnlock((Handle) (**dRec.textH).hText);
X */
X		short kind ; Rect outline ; Handle item ;
X		Str32 pName ;
X
X		GetDItem ( ( WindowPtr ) & dRec , etxtANWho , & kind , & item , & outline ) ;
X 		GetIText ( item , ( * pANR ) . anWho ) ;
X		BlockMove ( pANR -> anWho , pName , pANR -> anWho [ 0 ] + 1 ) ;
X		if ( pName [ 0 ] > 2 && pName [ pName [ 0 ] - 1 ] == '-' ) {
X			(*pANR).anMenu[anRole] = ( strchr ( (char *) uitmChar [ 0 ] , pName [ pName [ 0 ] ] ) -
X				(char *) uitmChar [ 0 ] ) ;
X		}
X	}
X
X	/* cleanup (in reverse order) and leave */
X	for (i = 0; i < menuAN_total; i++)
X	{
X		DeleteMenu(dlogAskName + i);
X		DisposeMenu(mhndAskName[i]);
X	}
X	CloseDialog((DialogPtr)&dRec);
X	DisposHandle(dRec.items);
X	ReleaseResource(dIHnd);
X	ReleaseResource((Handle) dTHnd);
X	SetPort(pOldPort);
X}
X
Xvoid
XInitMenuRes()
X{
Xstatic Boolean was_inited = 0 ;
Xshort			i, j;
XmenuListHandle	mlHnd;
XMenuHandle		mHnd;
X
X	if ( was_inited ) {
X		return ;
X	}
X	was_inited = 1 ;
X
X	mustGetMenuAlerts();
X
X	for (i = listMenubar; i <= listSubmenu; i++)
X	{
X		if (! (mlHnd = (menuListHandle) GetResource('MNU#', (menuBarListID + i))))
X			menuError(errGetMenuList);
X
X		pMenuList[i] = *mlHnd;
X
X		for (j = 0; j < (**mlHnd).numMenus; j++)
X		{
X			if (! (mHnd = (MenuHandle) GetMenu((**mlHnd).mref[j].mresID))) {
X			Str31 d ;
X				NumToString ( (**mlHnd).mref[j].mresID , d ) ;
X//				DebugStr ( d ) ;
X				menuError(errGetMenu);
X			}
X
X			(**mlHnd).mref[j].mhnd = mHnd;
X			* ((short *) *mHnd) = j + (**mlHnd).firstMenuID;	/* consecutive IDs */
X
X			/* expand apple menu */
X			if ((i == listMenubar) && (j == menuApple)) {
X				AddResMenu(mHnd, 'DRVR');
X			}
X
X			InsertMenu(mHnd, ((i == listSubmenu) ? hierMenu : 0));
X		}
X	}
X
X	DrawMenuBar();
X}
X
Xvoid
XAdjustMenus(short dimMenubar)
X{
Xshort		newMenubar = mbarRegular;
XWindowPeek	peekWindow = (WindowPeek) FrontWindow();
Xshort		i;
X
X/*
X *	if ( windowprocs != mac_procs ) {
X *		return ;
X *	}
X */
X	/* determine the new menubar state */
X	if (dimMenubar) {
X		newMenubar = mbarDim;
X	} else if (! peekWindow) {
X		newMenubar = mbarNoWindows;
X	} else if (peekWindow->windowKind < 0) {
X		newMenubar = mbarDA;
X	} else {
X		while (peekWindow && (peekWindow->windowKind != WKND_MAP)) {
X			peekWindow = peekWindow->nextWindow;
X		}
X		if ((! peekWindow) || (! peekWindow->visible)) {
X			newMenubar = mbarNoMap;
X		}
X	}
X
X	if (newMenubar != mbarRegular)
X		;							/* we've already found its state */
X#ifdef WIZARD
X	else if (wizard)
X	{
X		newMenubar = mbarSpecial;
X
X		if (kAdjustWizardMenu)
X		{
X			kAdjustWizardMenu = 0;
X
X			SetItem(MHND_FILE, menuFilePlayMode, "\pDebug");
X		}
X	}
X#endif
X
X#ifdef EXPLORE_MODE
X	else if (discover)
X	{
X		newMenubar = mbarSpecial;
X
X		if (kAdjustWizardMenu)
X		{
X			kAdjustWizardMenu = 0;
X
X			SetItem(MHND_FILE, menuFilePlayMode, "\pExplore");
X
X			for (i = CountMItems(MHND_WIZ); i > menuWizardAttributes; i--)
X				DelMenuItem(MHND_WIZ, i);
X		}
X	}
X#endif
X
X	/* adjust the menubar, if there's a state change */
X	if (theMenubar != newMenubar)
X	{
X		switch(theMenubar = newMenubar)
X		{
X		case mbarDim:
X			/* disable all menus (except the apple menu) */
X			for (i = menuFile; i < NUM_MBAR; i++)
X				DisableItem(MBARHND(i), 0);
X			break;
X
X		case mbarNoWindows:
X		case mbarDA:
X		case mbarNoMap:
X			/* enable the file menu, but ... */
X			EnableItem(MHND_FILE, 0);
X
X			if (theMenubar == mbarDA)
X				DisableItem(MHND_FILE, menuFileOpenMap);
X			else
X				EnableItem(MHND_FILE, menuFileOpenMap);
X
X			/* ... disable the window commands! */
X			for (i = menuFileRedraw; i <= menuFileEnterExplore; i++)
X				DisableItem(MHND_FILE, i);
X
X			if (theMenubar != mbarNoWindows)
X				EnableItem(MHND_FILE, menuFileClose);
X
X			/* ... and disable the rest of the menus */
X			for (i = menuEdit; i < NUM_MBAR; i++)
X				DisableItem(MBARHND(i), 0);
X
X			if (theMenubar == mbarDA)
X				EnableItem(MHND_EDIT, 0);
X
X			break;
X
X		case mbarRegular:
X		case mbarSpecial:
X			/* enable all menus ... */
X			for (i = menuFile; i < NUM_MBAR; i++)
X				EnableItem(MBARHND(i), 0);
X
X			/* ... except the unused Edit menu */
X			DisableItem(MHND_EDIT, 0);
X
X			/* ... the map is already open! */
X			DisableItem(MHND_FILE, menuFileOpenMap);
X
X			/* ... enable the window commands */
X			for (i = menuFileRedraw; i <= menuFileEnterExplore; i++)
X				EnableItem(MHND_FILE, i);
X
X			if (theMenubar == mbarRegular)
X				DisableItem(MHND_FILE, menuFilePlayMode);
X			else
X				DisableItem(MHND_FILE, menuFileEnterExplore);
X
X			break;
X		}
X
X		DrawMenuBar();
X	}
X}
X
Xvoid
XDoMenuEvt(long menuEntry)
X{
X	short menuID = HiWord(menuEntry);
X	short menuItem = LoWord(menuEntry);
X
X	switch(menuID - ID1_MBAR)	/* all submenus are default case */
X	{
X	case menuApple:
X		if (menuItem == menuAppleAboutBox)
X			aboutNetHack();
X		else
X		{
X			unsigned char daName[32];
X
X			GetItem(MHND_APPLE, menuItem, * (Str255 *) daName);
X			(void) OpenDeskAcc(daName);
X		}
X		break;
X
X	/*
X	 * Those direct calls are ugly: they should be installed into cmd.c .
X	 * Those AddToKeyQueue() calls are also ugly: they should be put into
X	 * the 'STR#' resource.
X	 */
X	case menuFile:
X		switch(menuItem)
X		{
X		case menuFileOpenMap:
X			openMap();
X			break;
X
X		case menuFileRedraw:
X			AddToKeyQueue ( 'R' & 0x1f , 1 ) ;
X			break;
X
X		case menuFilePrevMsg:
X			AddToKeyQueue ( 'P' & 0x1f , 1 ) ;
X			break;
X
X		case menuFileCleanup:
X			(void) SanePositions();
X			break;
X
X		case menuFileClose:
X			closeFrontWindow();
X			break;
X
X		case menuFileEnterExplore:
X			AddToKeyQueue ( 'X' , 1 ) ;
X			break;
X
X		case menuFileOptionEdit:
X			optionEditor();
X			break;
X
X		case menuFileSave:
X			askSave();
X			break;
X
X		case menuFileQuit:
X			askQuit();
X			break;
X		}
X		break;
X
X	case menuEdit:
X		(void) SystemEdit(menuItem - 1);
X		break;
X
X	default:	/* get associated string and add to key queue */
X		{
X			Str255	mstr;
X			short	i;
X
X			GetIndString(mstr, menuID, menuItem);
X			if (mstr[0] > QUEUE_LEN)
X				mstr[0] = QUEUE_LEN;
X
X			for (i = 1; ((i <= mstr[0]) && (mstr[i] != mstrEndChar)); i++)
X				AddToKeyQueue(mstr[i], false);
X		}
X		break;
X	}
X
X	HiliteMenu(0);
X}
X
X
Xstatic void
XaboutNetHack() {
X	if (theMenubar >= mbarRegular) {
X		(void) doversion();				/* is this necessary? */
X	} else {
X	unsigned char aboutStr[32] = "\pNetHack 3.1.";
X
X		if (PATCHLEVEL > 10) {
X			aboutStr[++aboutStr[0]] = '0'+PATCHLEVEL/10;
X		}
X
X		aboutStr[++aboutStr[0]] = '0' + (PATCHLEVEL % 10);
X
X		ParamText(aboutStr, "\p\rnethack-bugs@linc.cis.upenn.edu", "\p", "\p");
X		(void) Alert(alrtMenuNote, (ModalFilterProcPtr) 0L);
X		ResetAlrtStage();
X	}
X}
X
Xstatic void
XopenMap()
X{
X	WindowPeek	peekWindow = *(WindowPeek*) WindowList;
X
X	while (peekWindow && (peekWindow->windowKind != WKND_MAP))
X		peekWindow = peekWindow->nextWindow;
X
X	if (! peekWindow)
X		return;				/* impossible? */
X
X	ShowWindow((WindowPtr) peekWindow);
X	SelectWindow((WindowPtr) peekWindow);
X}
X
Xstatic void
XcloseFrontWindow()
X{
X	WindowPeek	peekWindow = (WindowPeek) FrontWindow();
X
X	if (! peekWindow)
X		return;				/* impossible? */
X	else if (peekWindow->windowKind < 0)
X		CloseDeskAcc(peekWindow->windowKind);
X	else if (peekWindow->windowKind == WKND_MAP)
X		HideWindow((WindowPtr) peekWindow);
X	else
X		WindowGoAway((EventRecord *) 0L, (WindowPtr) peekWindow);
X}
X
Xstatic void
XoptionEditor()
X{
X	ParamText("\pSorry, not yet implemented!  Use Options on the Help menu.", "\p", "\p", "\p");
X	(void) Alert(alrtMenuNote, (ModalFilterProcPtr) 0L);
X	ResetAlrtStage();
X}
X
Xstatic void
XaskSave() {
XBoolean doSave = 1 ;
XBoolean doYes = 0 ;
X
X	if (theMenubar < mbarRegular) {
X	short	itemHit;
X
X		ParamText("\pReally Save?", "\p", "\p", "\p");
X		itemHit = Alert(alrtMenu_NY, (ModalFilterProcPtr) 0L);
X		ResetAlrtStage();
X
X		if (itemHit != bttnMenuAlertYes) {
X			doSave = 0 ;
X		} else {
X			doYes = 1 ;
X		}
X	}
X	if ( doSave ) {
X		AddToKeyQueue ( 'S' , 1 ) ;
X		if ( doYes ) {
X			AddToKeyQueue ( 'y' , 1 ) ;
X		}
X	}
X}
X
Xstatic void
XaskQuit() {
XBoolean doQuit = 1 ;
XBoolean doYes = 0 ;
X
X	if (theMenubar < mbarRegular) {
X	short	itemHit;
X
X		ParamText("\pReally Quit?", "\p", "\p", "\p");
X		itemHit = Alert(alrtMenu_NY, (ModalFilterProcPtr) 0L);
X		ResetAlrtStage();
X
X		if (itemHit != bttnMenuAlertYes) {
X			doQuit = 0 ;
X		} else {
X			doYes = 1 ;
X		}
X	}
X	if ( doQuit ) {
X		AddToKeyQueue ( 'Q' , 1 ) ;
X		if ( doYes ) {
X			AddToKeyQueue ( 'y' , 1 ) ;
X		}
X	}
X}
END_OF_FILE
if test 23678 -ne `wc -c <'sys/mac/macmenu.c'`; then
    echo shar: \"'sys/mac/macmenu.c'\" unpacked with wrong size!
fi
# end of 'sys/mac/macmenu.c'
if test -f 'sys/share/dgn_yacc.c' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'sys/share/dgn_yacc.c'\" to \"'sys/share/dgn_yacc.c.orig'\"
  mv -f 'sys/share/dgn_yacc.c' 'sys/share/dgn_yacc.c.orig'
fi
echo shar: Extracting \"'sys/share/dgn_yacc.c'\" \(30875 characters\)
sed "s/^X//" >'sys/share/dgn_yacc.c' <<'END_OF_FILE'
X#ifndef lint
Xstatic char yysccsid[] = "@(#)yaccpar	1.9 (Berkeley) 02/21/93";
X#endif
X#define YYBYACC 1
X#define YYMAJOR 1
X#define YYMINOR 9
X#define yyclearin (yychar=(-1))
X#define yyerrok (yyerrflag=0)
X#define YYRECOVERING (yyerrflag!=0)
X#define YYPREFIX "yy"
X/*	SCCS Id: @(#)dgn_comp.c	3.1	93/05/15	*/
X/*	Copyright (c) 1989 by Jean-Christophe Collet */
X/*	Copyright (c) 1990 by M. Stephenson				  */
X/* NetHack may be freely redistributed.  See license for details. */
X
X/*
X * This file contains the Dungeon Compiler code
X */
X
X/* In case we're using bison in AIX.  This definition must be
X * placed before any other C-language construct in the file
X * excluding comments and preprocessor directives (thanks IBM
X * for this wonderful feature...).
X *
X * Note: some cpps barf on this 'undefined control' (#pragma).
X * Addition of the leading space seems to prevent barfage for now,
X * and AIX will still see the directive in its non-standard locale.
X */
X
X#ifdef _AIX
X #pragma alloca		/* keep leading space! */
X#endif
X
X#include "config.h"
X#include "dgn_file.h"
X
Xvoid FDECL(yyerror, (const char *));
Xvoid FDECL(yywarning, (const char *));
Xint NDECL(yylex);
Xint NDECL(yyparse);
Xint FDECL(getchain, (char *));
Xint NDECL(check_dungeon);
Xint NDECL(check_branch);
Xint NDECL(check_level);
Xvoid NDECL(init_dungeon);
Xvoid NDECL(init_branch);
Xvoid NDECL(init_level);
Xvoid NDECL(output_dgn);
X
X#ifdef AMIGA
X# undef	printf
X#ifndef	LATTICE
X# define    memset(addr,val,len)    setmem(addr,len,val)
X#endif
X#endif
X
X#ifdef MICRO
X# undef exit
Xextern void FDECL(exit, (int));
X#endif
X
X#undef NULL
X
X#define ERR		(-1)
X
Xstatic struct couple couple;
Xstatic struct tmpdungeon tmpdungeon[MAXDUNGEON];
Xstatic struct tmplevel tmplevel[LEV_LIMIT];
Xstatic struct tmpbranch tmpbranch[BRANCH_LIMIT];
X
Xstatic int in_dungeon = 0, n_dgns = -1, n_levs = -1, n_brs = -1;
X
Xextern int fatal_error;
Xextern const char *fname;
X
Xtypedef union
X{
X	int	i;
X	char*	str;
X} YYSTYPE;
X#define INTEGER 257
X#define A_DUNGEON 258
X#define BRANCH 259
X#define CHBRANCH 260
X#define LEVEL 261
X#define RNDLEVEL 262
X#define CHLEVEL 263
X#define RNDCHLEVEL 264
X#define UP_OR_DOWN 265
X#define PROTOFILE 266
X#define DESCRIPTION 267
X#define DESCRIPTOR 268
X#define LEVELDESC 269
X#define ALIGNMENT 270
X#define LEVALIGN 271
X#define ENTRY 272
X#define STAIR 273
X#define NO_UP 274
X#define NO_DOWN 275
X#define PORTAL 276
X#define STRING 277
X#define YYERRCODE 256
Xshort yylhs[] = {                                        -1,
X    0,    0,    4,    4,    5,    5,    5,    5,    6,    1,
X    1,    7,    7,    7,   11,   12,   14,   14,   13,    9,
X    9,    9,    9,    9,   15,   15,   16,   16,   17,   17,
X   18,   18,   19,   19,    8,    8,   21,   22,    3,    3,
X    3,    3,    3,    2,    2,   20,   10,
X};
Xshort yylen[] = {                                         2,
X    0,    1,    1,    2,    1,    1,    1,    1,    6,    0,
X    1,    1,    1,    1,    3,    1,    3,    3,    3,    1,
X    1,    1,    1,    1,    6,    7,    7,    8,    3,    3,
X    7,    8,    8,    9,    1,    1,    7,    8,    0,    1,
X    1,    1,    1,    0,    1,    5,    5,
X};
Xshort yydefred[] = {                                      0,
X    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
X    0,    0,    0,    0,    0,    3,    5,    6,    7,    8,
X   12,   13,   14,   16,   20,   21,   22,   23,   24,   35,
X   36,    0,    0,    0,    0,    0,    0,    0,    0,    0,
X    0,    0,    0,    0,    4,    0,    0,    0,    0,    0,
X    0,    0,   19,   17,   29,   18,   30,   15,    0,    0,
X    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
X    0,    0,    0,    0,    0,   11,    9,    0,   40,   41,
X   42,   43,    0,    0,    0,    0,    0,    0,    0,    0,
X   45,   37,    0,   27,    0,    0,    0,    0,    0,   38,
X   28,   33,    0,   47,   46,   34,
X};
Xshort yydgoto[] = {                                      14,
X   77,   92,   83,   15,   16,   17,   18,   19,   20,   67,
X   21,   22,   23,   24,   25,   26,   27,   28,   29,   69,
X   30,   31,
X};
Xshort yysindex[] = {                                   -237,
X  -50,  -49,  -48,  -47,  -46,  -45,  -44,  -43,  -39,  -38,
X  -30,  -22,  -21,    0, -237,    0,    0,    0,    0,    0,
X    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
X    0, -239, -238, -236, -235, -234, -233, -232, -230, -228,
X -220, -219, -218, -206,    0, -225,  -11, -223, -222, -221,
X -217, -215,    0,    0,    0,    0,    0,    0,   17,   18,
X   20,   -5,    2, -213, -212, -190, -189, -188, -271,   17,
X   18,   18,   27,   28,   29,    0,    0,   30,    0,    0,
X    0,    0, -193, -271, -182, -180,   17,   17, -179, -178,
X    0,    0, -193,    0, -177, -176, -175,   42,   43,    0,
X    0,    0, -172,    0,    0,    0,
X};
Xshort yyrindex[] = {                                     86,
X    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
X    0,    0,    0,    0,   87,    0,    0,    0,    0,    0,
X    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
X    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
X    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
X    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
X    0,    0,    0,    0,    0,    0,   16,    0,    1,    0,
X    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
X    0,    0,   31,    1,   46,    0,    0,    0,    0,    0,
X    0,    0,   31,    0,   61,   76,    0,    0,    0,    0,
X    0,    0,   91,    0,    0,    0,
X};
Xshort yygindex[] = {                                      0,
X    0,   -4,    4,    0,   75,    0,    0,    0,    0,  -70,
X    0,    0,    0,    0,    0,    0,    0,    0,    0,  -65,
X    0,    0,
X};
X#define YYTABLESIZE 363
Xshort yytable[] = {                                      84,
X   39,   79,   80,   81,   82,   85,   86,   32,   33,   34,
X   35,   36,   37,   38,   39,   10,   96,   97,   40,   41,
X    1,    2,    3,    4,    5,    6,    7,   42,    8,    9,
X   44,   10,   11,   12,   13,   43,   44,   46,   47,   54,
X   48,   49,   50,   51,   52,   25,   53,   55,   56,   57,
X   58,   59,   60,   61,   62,   63,   66,   68,   71,   64,
X   26,   65,   70,   73,   74,   72,   75,   76,   78,   87,
X   88,   91,   89,   90,   94,   31,   95,   98,   99,  101,
X  102,  103,  104,  105,  106,    1,    2,   93,  100,   45,
X   32,    0,    0,    0,    0,    0,    0,    0,    0,    0,
X    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
X    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
X    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
X    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
X    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
X    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
X    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
X    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
X    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
X    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
X    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
X    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
X    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
X    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
X    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
X    0,    0,    0,    0,    0,    0,    0,    0,   39,   39,
X   39,   39,   39,   39,   39,   39,   39,   39,    0,   39,
X   39,   39,   39,   10,   10,   10,   10,   10,   10,   10,
X    0,   10,   10,    0,   10,   10,   10,   10,   44,   44,
X   44,   44,   44,   44,   44,    0,   44,   44,    0,   44,
X   44,   44,   44,   25,   25,   25,   25,   25,   25,   25,
X    0,   25,   25,    0,   25,   25,   25,   25,   26,   26,
X   26,   26,   26,   26,   26,    0,   26,   26,    0,   26,
X   26,   26,   26,   31,   31,   31,   31,   31,   31,   31,
X    0,   31,   31,    0,   31,   31,   31,   31,   32,   32,
X   32,   32,   32,   32,   32,    0,   32,   32,    0,   32,
X   32,   32,   32,
X};
Xshort yycheck[] = {                                      70,
X    0,  273,  274,  275,  276,   71,   72,   58,   58,   58,
X   58,   58,   58,   58,   58,    0,   87,   88,   58,   58,
X  258,  259,  260,  261,  262,  263,  264,   58,  266,  267,
X    0,  269,  270,  271,  272,   58,   58,  277,  277,  268,
X  277,  277,  277,  277,  277,    0,  277,  268,  268,  268,
X  257,  277,   64,  277,  277,  277,   40,   40,   64,  277,
X    0,  277,   43,  277,  277,   64,  257,  257,  257,   43,
X   43,  265,   44,   44,  257,    0,  257,  257,  257,  257,
X  257,  257,   41,   41,  257,    0,    0,   84,   93,   15,
X    0,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
X   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
X   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
X   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
X   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
X   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
X   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
X   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
X   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
X   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
X   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
X   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
X   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
X   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
X   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
X   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
X   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  258,  259,
X  260,  261,  262,  263,  264,  265,  266,  267,   -1,  269,
X  270,  271,  272,  258,  259,  260,  261,  262,  263,  264,
X   -1,  266,  267,   -1,  269,  270,  271,  272,  258,  259,
X  260,  261,  262,  263,  264,   -1,  266,  267,   -1,  269,
X  270,  271,  272,  258,  259,  260,  261,  262,  263,  264,
X   -1,  266,  267,   -1,  269,  270,  271,  272,  258,  259,
X  260,  261,  262,  263,  264,   -1,  266,  267,   -1,  269,
X  270,  271,  272,  258,  259,  260,  261,  262,  263,  264,
X   -1,  266,  267,   -1,  269,  270,  271,  272,  258,  259,
X  260,  261,  262,  263,  264,   -1,  266,  267,   -1,  269,
X  270,  271,  272,
X};
X#define YYFINAL 14
X#ifndef YYDEBUG
X#define YYDEBUG 0
X#endif
X#define YYMAXTOKEN 277
X#if YYDEBUG
Xchar *yyname[] = {
X"end-of-file",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
X0,0,0,0,0,0,"'('","')'",0,"'+'","','",0,0,0,0,0,0,0,0,0,0,0,0,0,"':'",0,0,0,0,0,
X"'@'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
X0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
X0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
X0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
X0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"INTEGER",
X"A_DUNGEON","BRANCH","CHBRANCH","LEVEL","RNDLEVEL","CHLEVEL","RNDCHLEVEL",
X"UP_OR_DOWN","PROTOFILE","DESCRIPTION","DESCRIPTOR","LEVELDESC","ALIGNMENT",
X"LEVALIGN","ENTRY","STAIR","NO_UP","NO_DOWN","PORTAL","STRING",
X};
Xchar *yyrule[] = {
X"$accept : file",
X"file :",
X"file : dungeons",
X"dungeons : dungeon",
X"dungeons : dungeons dungeon",
X"dungeon : dungeonline",
X"dungeon : dungeondesc",
X"dungeon : branches",
X"dungeon : levels",
X"dungeonline : A_DUNGEON ':' STRING STRING rcouple optional_int",
X"optional_int :",
X"optional_int : INTEGER",
X"dungeondesc : entry",
X"dungeondesc : descriptions",
X"dungeondesc : prototype",
X"entry : ENTRY ':' INTEGER",
X"descriptions : desc",
X"desc : DESCRIPTION ':' DESCRIPTOR",
X"desc : ALIGNMENT ':' DESCRIPTOR",
X"prototype : PROTOFILE ':' STRING",
X"levels : level1",
X"levels : level2",
X"levels : levdesc",
X"levels : chlevel1",
X"levels : chlevel2",
X"level1 : LEVEL ':' STRING STRING '@' acouple",
X"level1 : RNDLEVEL ':' STRING STRING '@' acouple INTEGER",
X"level2 : LEVEL ':' STRING STRING '@' acouple INTEGER",
X"level2 : RNDLEVEL ':' STRING STRING '@' acouple INTEGER INTEGER",
X"levdesc : LEVELDESC ':' DESCRIPTOR",
X"levdesc : LEVALIGN ':' DESCRIPTOR",
X"chlevel1 : CHLEVEL ':' STRING STRING STRING '+' rcouple",
X"chlevel1 : RNDCHLEVEL ':' STRING STRING STRING '+' rcouple INTEGER",
X"chlevel2 : CHLEVEL ':' STRING STRING STRING '+' rcouple INTEGER",
X"chlevel2 : RNDCHLEVEL ':' STRING STRING STRING '+' rcouple INTEGER INTEGER",
X"branches : branch",
X"branches : chbranch",
X"branch : BRANCH ':' STRING '@' acouple branch_type direction",
X"chbranch : CHBRANCH ':' STRING STRING '+' rcouple branch_type direction",
X"branch_type :",
X"branch_type : STAIR",
X"branch_type : NO_UP",
X"branch_type : NO_DOWN",
X"branch_type : PORTAL",
X"direction :",
X"direction : UP_OR_DOWN",
X"acouple : '(' INTEGER ',' INTEGER ')'",
X"rcouple : '(' INTEGER ',' INTEGER ')'",
X};
X#endif
X#ifdef YYSTACKSIZE
X#undef YYMAXDEPTH
X#define YYMAXDEPTH YYSTACKSIZE
X#else
X#ifdef YYMAXDEPTH
X#define YYSTACKSIZE YYMAXDEPTH
X#else
X#define YYSTACKSIZE 500
X#define YYMAXDEPTH 500
X#endif
X#endif
Xint yydebug;
Xint yynerrs;
Xint yyerrflag;
Xint yychar;
Xshort *yyssp;
XYYSTYPE *yyvsp;
XYYSTYPE yyval;
XYYSTYPE yylval;
Xshort yyss[YYSTACKSIZE];
XYYSTYPE yyvs[YYSTACKSIZE];
X#define yystacksize YYSTACKSIZE
X
Xvoid
Xinit_dungeon()
X{
X	if(++n_dgns > MAXDUNGEON) {
X	    fprintf(stderr, "FATAL - Too many dungeons (limit: %d).\n",
X		    MAXDUNGEON);
X	    fprintf(stderr, "To increase the limit edit MAXDUNGEON in global.h\n");
X	    exit(1);
X	}
X
X	in_dungeon = 1;
X	tmpdungeon[n_dgns].lev.base = 0;
X	tmpdungeon[n_dgns].lev.rand = 0;
X	tmpdungeon[n_dgns].chance = 100;
X	strcpy(tmpdungeon[n_dgns].name, "");
X	strcpy(tmpdungeon[n_dgns].protoname, "");
X	tmpdungeon[n_dgns].flags = 0;
X	tmpdungeon[n_dgns].levels = 0;
X	tmpdungeon[n_dgns].branches = 0;
X	tmpdungeon[n_dgns].entry_lev = 0;
X}
X
Xvoid
Xinit_level()
X{
X	if(++n_levs > LEV_LIMIT) {
X
X		yyerror("FATAL - Too many special levels defined.");
X		exit(1);
X	}
X	tmplevel[n_levs].lev.base = 0;
X	tmplevel[n_levs].lev.rand = 0;
X	tmplevel[n_levs].chance = 100;
X	tmplevel[n_levs].rndlevs = 0;
X	tmplevel[n_levs].flags = 0;
X	strcpy(tmplevel[n_levs].name, "");
X	tmplevel[n_levs].chain = -1;
X}
X
Xvoid
Xinit_branch()
X{
X	if(++n_brs > BRANCH_LIMIT) {
X
X		yyerror("FATAL - Too many special levels defined.");
X		exit(1);
X	}
X	tmpbranch[n_brs].lev.base = 0;
X	tmpbranch[n_brs].lev.rand = 0;
X	strcpy(tmpbranch[n_brs].name, "");
X	tmpbranch[n_brs].chain = -1;
X}
X
Xint
Xgetchain(s)
X	char	*s;
X{
X	int i;
X
X	if(strlen(s)) {
X
X	    for(i = n_levs - tmpdungeon[n_dgns].levels + 1; i <= n_levs; i++)
X		if(!strcmp(tmplevel[i].name, s)) return i;
X
X	    yyerror("Can't locate the specified chain level.");
X	    return(-2);
X	}
X	return(-1);
X}
X
X/*
X *	Consistancy checking routines:
X *
X *	- A dungeon must have a unique name.
X *	- A dungeon must have a originating "branch" command
X *	  (except, of course, for the first dungeon).
X *	- A dungeon must have a proper depth (at least (1, 0)).
X */
X
Xint
Xcheck_dungeon()
X{
X	int i;
X
X	for(i = 0; i < n_dgns; i++)
X	    if(!strcmp(tmpdungeon[i].name, tmpdungeon[n_dgns].name)) {
X		yyerror("Duplicate dungeon name.");
X		return(0);
X	    }
X
X	if(n_dgns)
X	  for(i = 0; i < n_brs - tmpdungeon[n_dgns].branches; i++) {
X	    if(!strcmp(tmpbranch[i].name, tmpdungeon[n_dgns].name)) break;
X
X	    if(i >= n_brs - tmpdungeon[n_dgns].branches) {
X		yyerror("Dungeon cannot be reached.");
X		return(0);
X	    }
X	  }
X
X	if(tmpdungeon[n_dgns].lev.base <= 0 ||
X	   tmpdungeon[n_dgns].lev.rand < 0) {
X		yyerror("Invalid dungeon depth specified.");
X		return(0);
X	}
X	return(1);	/* OK */
X}
X
X/*
X *	- A level must have a unique level name.
X *	- If chained, the level used as reference for the chain
X *	  must be in this dungeon, must be previously defined, and
X *	  the level chained from must be "non-probabalistic" (ie.
X *	  have a 100% chance of existing).
X */
X
Xint
Xcheck_level()
X{
X	int i;
X
X	if(!in_dungeon) {
X		yyerror("Level defined outside of dungeon.");
X		return(0);
X	}
X
X	for(i = 0; i < n_levs; i++)
X	    if(!strcmp(tmplevel[i].name, tmplevel[n_levs].name)) {
X		yyerror("Duplicate level name.");
X		return(0);
X	    }
X
X	if(tmplevel[i].chain == -2) {
X		yyerror("Invaild level chain reference.");
X		return(0);
X	} else if(tmplevel[i].chain != -1) {	/* there is a chain */
X	    if(tmplevel[tmpbranch[i].chain].chance != 100) {
X		yyerror("Level cannot chain from a probabalistic level.");
X		return(0);
X	    } else if(tmplevel[i].chain == n_levs) {
X		yyerror("A level cannot chain to itself!");
X		return(0);
X	    }
X	}
X	return(1);	/* OK */
X}
X
X/*
X *	- A branch may not branch backwards - to avoid branch loops.
X *	- A branch name must be unique.
X *	  (ie. You can only have one entry point to each dungeon).
X *	- If chained, the level used as reference for the chain
X *	  must be in this dungeon, must be previously defined, and
X *	  the level chained from must be "non-probabalistic" (ie.
X *	  have a 100% chance of existing).
X */
X
Xint
Xcheck_branch()
X{
X	int i;
X
X	if(!in_dungeon) {
X		yyerror("Branch defined outside of dungeon.");
X		return(0);
X	}
X
X	for(i = 0; i < n_dgns; i++)
X	    if(!strcmp(tmpdungeon[i].name, tmpbranch[n_brs].name)) {
X
X		yyerror("Reverse branching not allowed.");
X		return(0);
X	    }
X
X	if(tmpbranch[i].chain == -2) {
X
X		yyerror("Invaild branch chain reference.");
X		return(0);
X	} else if(tmpbranch[i].chain != -1) {	/* it is chained */
X
X	    if(tmplevel[tmpbranch[i].chain].chance != 100) {
X		yyerror("Branch cannot chain from a probabalistic level.");
X		return(0);
X	    }
X	}
X	return(1);	/* OK */
X}
X
X/*
X *	Output the dungon definition into a file.
X *
X *	The file will have the following format:
X *
X *	[ number of dungeons ]
X *	[ first dungeon struct ]
X *	[ levels for the first dungeon ]
X *	  ...
X *	[ branches for the first dungeon ]
X *	  ...
X *	[ second dungeon struct ]
X *	  ...
X */
X
Xvoid
Xoutput_dgn()
X{
X	int	nd, cl = 0, nl = 0,
X		    cb = 0, nb = 0;
X
X	if(++n_dgns <= 0) {
X
X	    yyerror("FATAL - no dungeons were defined.");
X	    exit(1);
X	}
X
X	fwrite((char *)(&n_dgns), sizeof(int), 1, stdout);
X	for(nd = 0; nd < n_dgns; nd++) {
X
X	    fwrite((char *)&tmpdungeon[nd], sizeof(struct tmpdungeon), 1,
X								stdout);
X
X	    nl += tmpdungeon[nd].levels;
X	    for(; cl < nl; cl++)
X		fwrite((char *)&tmplevel[cl], sizeof(struct tmplevel), 1,
X								stdout);
X
X	    nb += tmpdungeon[nd].branches;
X	    for(; cb < nb; cb++)
X		fwrite((char *)&tmpbranch[cb], sizeof(struct tmpbranch), 1,
X								stdout);
X	}
X}
X#define YYABORT goto yyabort
X#define YYREJECT goto yyabort
X#define YYACCEPT goto yyaccept
X#define YYERROR goto yyerrlab
Xint
Xyyparse()
X{
X    register int yym, yyn, yystate;
X#if YYDEBUG
X    register char *yys;
X    extern char *getenv();
X
X    if ((yys = getenv("YYDEBUG")) != 0)
X    {
X        yyn = *yys;
X        if (yyn >= '0' && yyn <= '9')
X            yydebug = yyn - '0';
X    }
X#endif
X
X    yynerrs = 0;
X    yyerrflag = 0;
X    yychar = (-1);
X
X    yyssp = yyss;
X    yyvsp = yyvs;
X    *yyssp = yystate = 0;
X
Xyyloop:
X    if ((yyn = yydefred[yystate]) != 0) goto yyreduce;
X    if (yychar < 0)
X    {
X        if ((yychar = yylex()) < 0) yychar = 0;
X#if YYDEBUG
X        if (yydebug)
X        {
X            yys = 0;
X            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
X            if (!yys) yys = "illegal-symbol";
X            printf("%sdebug: state %d, reading %d (%s)\n",
X                    YYPREFIX, yystate, yychar, yys);
X        }
X#endif
X    }
X    if ((yyn = yysindex[yystate]) != 0 && (yyn += yychar) >= 0 &&
X            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
X    {
X#if YYDEBUG
X        if (yydebug)
X            printf("%sdebug: state %d, shifting to state %d\n",
X                    YYPREFIX, yystate, yytable[yyn]);
X#endif
X        if (yyssp >= yyss + yystacksize - 1)
X        {
X            goto yyoverflow;
X        }
X        *++yyssp = yystate = yytable[yyn];
X        *++yyvsp = yylval;
X        yychar = (-1);
X        if (yyerrflag > 0)  --yyerrflag;
X        goto yyloop;
X    }
X    if ((yyn = yyrindex[yystate]) != 0 && (yyn += yychar) >= 0 &&
X            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
X    {
X        yyn = yytable[yyn];
X        goto yyreduce;
X    }
X    if (yyerrflag) goto yyinrecovery;
X#ifdef lint
X    goto yynewerror;
X#endif
Xyynewerror:
X    yyerror("syntax error");
X#ifdef lint
X    goto yyerrlab;
X#endif
Xyyerrlab:
X    ++yynerrs;
Xyyinrecovery:
X    if (yyerrflag < 3)
X    {
X        yyerrflag = 3;
X        for (;;)
X        {
X            if ((yyn = yysindex[*yyssp]) != 0 && (yyn += YYERRCODE) >= 0 &&
X                    yyn <= YYTABLESIZE && yycheck[yyn] == YYERRCODE)
X            {
X#if YYDEBUG
X                if (yydebug)
X                    printf("%sdebug: state %d, error recovery shifting\
X to state %d\n", YYPREFIX, *yyssp, yytable[yyn]);
X#endif
X                if (yyssp >= yyss + yystacksize - 1)
X                {
X                    goto yyoverflow;
X                }
X                *++yyssp = yystate = yytable[yyn];
X                *++yyvsp = yylval;
X                goto yyloop;
X            }
X            else
X            {
X#if YYDEBUG
X                if (yydebug)
X                    printf("%sdebug: error recovery discarding state %d\n",
X                            YYPREFIX, *yyssp);
X#endif
X                if (yyssp <= yyss) goto yyabort;
X                --yyssp;
X                --yyvsp;
X            }
X        }
X    }
X    else
X    {
X        if (yychar == 0) goto yyabort;
X#if YYDEBUG
X        if (yydebug)
X        {
X            yys = 0;
X            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
X            if (!yys) yys = "illegal-symbol";
X            printf("%sdebug: state %d, error recovery discards token %d (%s)\n",
X                    YYPREFIX, yystate, yychar, yys);
X        }
X#endif
X        yychar = (-1);
X        goto yyloop;
X    }
Xyyreduce:
X#if YYDEBUG
X    if (yydebug)
X        printf("%sdebug: state %d, reducing by rule %d (%s)\n",
X                YYPREFIX, yystate, yyn, yyrule[yyn]);
X#endif
X    yym = yylen[yyn];
X    yyval = yyvsp[1-yym];
X    switch (yyn)
X    {
Xcase 2:
X{
X			output_dgn();
X		  }
Xbreak;
Xcase 9:
X{
X			init_dungeon();
X			strcpy(tmpdungeon[n_dgns].name, yyvsp[-3].str);
X			if (!strcmp(yyvsp[-2].str, "none"))
X				tmpdungeon[n_levs].boneschar = '\0';
X			else if (yyvsp[-2].str[1])
X				yyerror("Bones marker must be a single char, or \"none\"!");
X			else
X				tmpdungeon[n_dgns].boneschar = yyvsp[-2].str[0];
X			tmpdungeon[n_dgns].lev.base = couple.base;
X			tmpdungeon[n_dgns].lev.rand = couple.rand;
X			tmpdungeon[n_dgns].chance = yyvsp[0].i;
X		  }
Xbreak;
Xcase 10:
X{
X			yyval.i = 0;
X		  }
Xbreak;
Xcase 11:
X{
X			yyval.i = yyvsp[0].i;
X		  }
Xbreak;
Xcase 15:
X{
X			tmpdungeon[n_dgns].entry_lev = yyvsp[0].i;
X		  }
Xbreak;
Xcase 17:
X{
X			if(yyvsp[0].i <= TOWN || yyvsp[0].i >= D_ALIGN_CHAOTIC)
X			    yyerror("Illegal description - ignoring!");
X			else
X			    tmpdungeon[n_dgns].flags |= yyvsp[0].i ;
X		  }
Xbreak;
Xcase 18:
X{
X			if(yyvsp[0].i && yyvsp[0].i < D_ALIGN_CHAOTIC)
X			    yyerror("Illegal alignment - ignoring!");
X			else
X			    tmpdungeon[n_dgns].flags |= yyvsp[0].i ;
X		  }
Xbreak;
Xcase 19:
X{
X			strcpy(tmpdungeon[n_dgns].protoname, yyvsp[0].str);
X		  }
Xbreak;
Xcase 25:
X{
X			init_level();
X			strcpy(tmplevel[n_levs].name, yyvsp[-3].str);
X			if (!strcmp(yyvsp[-2].str, "none"))
X				tmplevel[n_levs].boneschar = '\0';
X			else if (yyvsp[-2].str[1])
X				yyerror("Bones marker must be a single char, or \"none\"!");
X			else
X				tmplevel[n_levs].boneschar = yyvsp[-2].str[0];
X			tmplevel[n_levs].lev.base = couple.base;
X			tmplevel[n_levs].lev.rand = couple.rand;
X			tmpdungeon[n_dgns].levels++;
X		  }
Xbreak;
Xcase 26:
X{
X			init_level();
X			strcpy(tmplevel[n_levs].name, yyvsp[-4].str);
X			if (!strcmp(yyvsp[-3].str, "none"))
X				tmplevel[n_levs].boneschar = '\0';
X			else if (yyvsp[-3].str[1])
X				yyerror("Bones marker must be a single char, or \"none\"!");
X			else
X				tmplevel[n_levs].boneschar = yyvsp[-3].str[0];
X			tmplevel[n_levs].lev.base = couple.base;
X			tmplevel[n_levs].lev.rand = couple.rand;
X			tmplevel[n_levs].rndlevs = yyvsp[0].i;
X			tmpdungeon[n_dgns].levels++;
X		  }
Xbreak;
Xcase 27:
X{
X			init_level();
X			strcpy(tmplevel[n_levs].name, yyvsp[-4].str);
X			if (!strcmp(yyvsp[-3].str, "none"))
X				tmplevel[n_levs].boneschar = '\0';
X			else if (yyvsp[-3].str[1])
X				yyerror("Bones marker must be a single char, or \"none\"!");
X			else
X				tmplevel[n_levs].boneschar = yyvsp[-3].str[0];
X			tmplevel[n_levs].lev.base = couple.base;
X			tmplevel[n_levs].lev.rand = couple.rand;
X			tmplevel[n_levs].chance = yyvsp[0].i;
X			tmpdungeon[n_dgns].levels++;
X		  }
Xbreak;
Xcase 28:
X{
X			init_level();
X			strcpy(tmplevel[n_levs].name, yyvsp[-5].str);
X			if (!strcmp(yyvsp[-4].str, "none"))
X				tmplevel[n_levs].boneschar = '\0';
X			else if (yyvsp[-4].str[1])
X				yyerror("Bones marker must be a single char, or \"none\"!");
X			else
X				tmplevel[n_levs].boneschar = yyvsp[-4].str[0];
X			tmplevel[n_levs].lev.base = couple.base;
X			tmplevel[n_levs].lev.rand = couple.rand;
X			tmplevel[n_levs].chance = yyvsp[-1].i;
X			tmplevel[n_levs].rndlevs = yyvsp[0].i;
X			tmpdungeon[n_dgns].levels++;
X		  }
Xbreak;
Xcase 29:
X{
X			if(yyvsp[0].i >= D_ALIGN_CHAOTIC)
X			    yyerror("Illegal description - ignoring!");
X			else
X			    tmplevel[n_levs].flags |= yyvsp[0].i ;
X		  }
Xbreak;
Xcase 30:
X{
X			if(yyvsp[0].i && yyvsp[0].i < D_ALIGN_CHAOTIC)
X			    yyerror("Illegal alignment - ignoring!");
X			else
X			    tmplevel[n_levs].flags |= yyvsp[0].i ;
X		  }
Xbreak;
Xcase 31:
X{
X			init_level();
X			strcpy(tmplevel[n_levs].name, yyvsp[-4].str);
X			if (!strcmp(yyvsp[-3].str, "none"))
X				tmplevel[n_levs].boneschar = '\0';
X			else if (yyvsp[-3].str[1])
X				yyerror("Bones marker must be a single char, or \"none\"!");
X			else
X				tmplevel[n_levs].boneschar = yyvsp[-3].str[0];
X			tmplevel[n_levs].chain = getchain(yyvsp[-2].str);
X			tmplevel[n_levs].lev.base = couple.base;
X			tmplevel[n_levs].lev.rand = couple.rand;
X			if(!check_level()) n_levs--;
X			else tmpdungeon[n_dgns].levels++;
X		  }
Xbreak;
Xcase 32:
X{
X			init_level();
X			strcpy(tmplevel[n_levs].name, yyvsp[-5].str);
X			if (!strcmp(yyvsp[-4].str, "none"))
X				tmplevel[n_levs].boneschar = '\0';
X			else if (yyvsp[-4].str[1])
X				yyerror("Bones marker must be a single char, or \"none\"!");
X			else
X				tmplevel[n_levs].boneschar = yyvsp[-4].str[0];
X			tmplevel[n_levs].chain = getchain(yyvsp[-3].str);
X			tmplevel[n_levs].lev.base = couple.base;
X			tmplevel[n_levs].lev.rand = couple.rand;
X			tmplevel[n_levs].rndlevs = yyvsp[0].i;
X			if(!check_level()) n_levs--;
X			else tmpdungeon[n_dgns].levels++;
X		  }
Xbreak;
Xcase 33:
X{
X			init_level();
X			strcpy(tmplevel[n_levs].name, yyvsp[-5].str);
X			if (!strcmp(yyvsp[-4].str, "none"))
X				tmplevel[n_levs].boneschar = '\0';
X			else if (yyvsp[-4].str[1])
X				yyerror("Bones marker must be a single char, or \"none\"!");
X			else
X				tmplevel[n_levs].boneschar = yyvsp[-4].str[0];
X			tmplevel[n_levs].chain = getchain(yyvsp[-3].str);
X			tmplevel[n_levs].lev.base = couple.base;
X			tmplevel[n_levs].lev.rand = couple.rand;
X			tmplevel[n_levs].chance = yyvsp[0].i;
X			if(!check_level()) n_levs--;
X			else tmpdungeon[n_dgns].levels++;
X		  }
Xbreak;
Xcase 34:
X{
X			init_level();
X			strcpy(tmplevel[n_levs].name, yyvsp[-6].str);
X			if (!strcmp(yyvsp[-5].str, "none"))
X				tmplevel[n_levs].boneschar = '\0';
X			else if (yyvsp[-5].str[1])
X				yyerror("Bones marker must be a single char, or \"none\"!");
X			else
X				tmplevel[n_levs].boneschar = yyvsp[-5].str[0];
X			tmplevel[n_levs].chain = getchain(yyvsp[-4].str);
X			tmplevel[n_levs].lev.base = couple.base;
X			tmplevel[n_levs].lev.rand = couple.rand;
X			tmplevel[n_levs].chance = yyvsp[-1].i;
X			tmplevel[n_levs].rndlevs = yyvsp[0].i;
X			if(!check_level()) n_levs--;
X			else tmpdungeon[n_dgns].levels++;
X		  }
Xbreak;
Xcase 37:
X{
X			init_branch();
X			strcpy(tmpbranch[n_brs].name, yyvsp[-4].str);
X			tmpbranch[n_brs].lev.base = couple.base;
X			tmpbranch[n_brs].lev.rand = couple.rand;
X			tmpbranch[n_brs].type = yyvsp[-1].i;
X			tmpbranch[n_brs].up = yyvsp[0].i;
X			if(!check_branch()) n_brs--;
X			else tmpdungeon[n_dgns].branches++;
X		  }
Xbreak;
Xcase 38:
X{
X			init_branch();
X			strcpy(tmpbranch[n_brs].name, yyvsp[-5].str);
X			tmpbranch[n_brs].chain = getchain(yyvsp[-4].str);
X			tmpbranch[n_brs].lev.base = couple.base;
X			tmpbranch[n_brs].lev.rand = couple.rand;
X			tmpbranch[n_brs].type = yyvsp[-1].i;
X			tmpbranch[n_brs].up = yyvsp[0].i;
X			if(!check_branch()) n_brs--;
X			else tmpdungeon[n_dgns].branches++;
X		  }
Xbreak;
Xcase 39:
X{
X			yyval.i = TBR_STAIR;	/* two way stair */
X		  }
Xbreak;
Xcase 40:
X{
X			yyval.i = TBR_STAIR;	/* two way stair */
X		  }
Xbreak;
Xcase 41:
X{
X			yyval.i = TBR_NO_UP;	/* no up staircase */
X		  }
Xbreak;
Xcase 42:
X{
X			yyval.i = TBR_NO_DOWN;	/* no down staircase */
X		  }
Xbreak;
Xcase 43:
X{
X			yyval.i = TBR_PORTAL;	/* portal connection */
X		  }
Xbreak;
Xcase 44:
X{
X			yyval.i = 0;	/* defaults to down */
X		  }
Xbreak;
Xcase 45:
X{
X			yyval.i = yyvsp[0].i;
X		  }
Xbreak;
Xcase 46:
X{
X			if (yyvsp[-3].i < -MAXLEVEL || yyvsp[-3].i > MAXLEVEL) {
X			    yyerror("Abs base out of dlevel range - zeroing!");
X			    couple.base = couple.rand = 0;
X			} else if (yyvsp[-1].i < -1 ||
X				((yyvsp[-3].i < 0) ? (MAXLEVEL + yyvsp[-3].i + yyvsp[-1].i + 1) > MAXLEVEL :
X					(yyvsp[-3].i + yyvsp[-1].i) > MAXLEVEL)) {
X			    yyerror("Abs range out of dlevel range - zeroing!");
X			    couple.base = couple.rand = 0;
X			} else {
X			    couple.base = yyvsp[-3].i;
X			    couple.rand = yyvsp[-1].i;
X			}
X		  }
Xbreak;
Xcase 47:
X{
X			if (yyvsp[-3].i < -MAXLEVEL || yyvsp[-3].i > MAXLEVEL) {
X			    yyerror("Rel base out of dlevel range - zeroing!");
X			    couple.base = couple.rand = 0;
X			} else {
X			    couple.base = yyvsp[-3].i;
X			    couple.rand = yyvsp[-1].i;
X			}
X		  }
Xbreak;
X    }
X    yyssp -= yym;
X    yystate = *yyssp;
X    yyvsp -= yym;
X    yym = yylhs[yyn];
X    if (yystate == 0 && yym == 0)
X    {
X#if YYDEBUG
X        if (yydebug)
X            printf("%sdebug: after reduction, shifting from state 0 to\
X state %d\n", YYPREFIX, YYFINAL);
X#endif
X        yystate = YYFINAL;
X        *++yyssp = YYFINAL;
X        *++yyvsp = yyval;
X        if (yychar < 0)
X        {
X            if ((yychar = yylex()) < 0) yychar = 0;
X#if YYDEBUG
X            if (yydebug)
X            {
X                yys = 0;
X                if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
X                if (!yys) yys = "illegal-symbol";
X                printf("%sdebug: state %d, reading %d (%s)\n",
X                        YYPREFIX, YYFINAL, yychar, yys);
X            }
X#endif
X        }
X        if (yychar == 0) goto yyaccept;
X        goto yyloop;
X    }
X    if ((yyn = yygindex[yym]) != 0 && (yyn += yystate) >= 0 &&
X            yyn <= YYTABLESIZE && yycheck[yyn] == yystate)
X        yystate = yytable[yyn];
X    else
X        yystate = yydgoto[yym];
X#if YYDEBUG
X    if (yydebug)
X        printf("%sdebug: after reduction, shifting from state %d \
Xto state %d\n", YYPREFIX, *yyssp, yystate);
X#endif
X    if (yyssp >= yyss + yystacksize - 1)
X    {
X        goto yyoverflow;
X    }
X    *++yyssp = yystate;
X    *++yyvsp = yyval;
X    goto yyloop;
Xyyoverflow:
X    yyerror("yacc stack overflow");
Xyyabort:
X    return (1);
Xyyaccept:
X    return (0);
X}
END_OF_FILE
if test 30875 -ne `wc -c <'sys/share/dgn_yacc.c'`; then
    echo shar: \"'sys/share/dgn_yacc.c'\" unpacked with wrong size!
fi
# end of 'sys/share/dgn_yacc.c'
echo shar: End of archive 15 \(of 18\).
cp /dev/null ark15isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 18 archives.
    echo "Now execute ./patchit3.sh"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
