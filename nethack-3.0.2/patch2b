Path: utzoo!utgpu!jarvis.csri.toronto.edu!mailrus!csd4.csd.uwm.edu!cs.utexas.edu!uunet!zephyr.ens.tek.com!tekgen!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v08i007:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Patch2b
Message-ID: <4459@tekred.CNA.TEK.COM>
Date: 18 Aug 89 15:47:32 GMT
Sender: nobody@tekred.CNA.TEK.COM
Lines: 2123
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 8, Issue 7
Archive-name: NetHack3/Patch2b
Patch-To: NetHack3: Volume 7, Issue 56-93

	[If this shar file unpacks with 2 control characters missing,
	 they are the control-G characters at the end of the "echo "
	 statements in Makefile.tcc.	-br]

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 2 (of 7)."
# Contents:  patch02b
# Wrapped by billr@saab on Fri Aug 18 08:33:16 1989
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'patch02b' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'patch02b'\"
else
echo shar: Extracting \"'patch02b'\" \(52490 characters\)
sed "s/^X//" >'patch02b' <<'END_OF_FILE'
X*** others/Old/Make.ini	Wed Aug 16 12:06:40 1989
X--- others/Make.ini	Tue Aug 15 20:38:30 1989
X***************
X*** 1,7 ****
X! #	SCCS Id: @(#)Make.ini	1.4	87/08/08
X! # This is a sample `make.ini' file for NDMAKE v3.7.  You will probably want
X! # to customize it for your system.
X  
X  
X  
X  # The order to search for rules and files is specified by .SUFFIXES
X--- 1,7 ----
X! #	SCCS Id: @(#)Make.ini	3.0	89/08/13
X  
X+ # This is a sample `make.ini' file for NDMAKE v3.8.  You will probably want
X+ # to customize it for your system.
X  
X  
X  # The order to search for rules and files is specified by .SUFFIXES
X***************
X*** 14,19 ****
X--- 14,20 ----
X  LIBS =
X  BIN =
X  LFLAGS =
X+ CC = cl
X  
X  # A universally useful target.
X  clean:
X***************
X*** 30,36 ****
X  .asm.obj:; masm $*.asm;
X  
X  # To produce a `.obj' file from a `.c' file using Microsoft C. 
X! .c.obj:; msc $(CFLAGS) -I\c $*.c
X  
X  # To produce a `.obj' file from a `.for' file using Microsoft Fortran.
X  .for.obj:
X--- 31,37 ----
X  .asm.obj:; masm $*.asm;
X  
X  # To produce a `.obj' file from a `.c' file using Microsoft C. 
X! .c.obj:; $(CC) $(CFLAGS) -c $*.c
X  
X  # To produce a `.obj' file from a `.for' file using Microsoft Fortran.
X  .for.obj:
X***************
X*** 55,61 ****
X  
X  # To produce a `.exe' file from a `.c' file.
X  .c.exe:
X! 	msc $(CFLAGS) -I\c $*.c
X  	link $*.obj $(SETARGV), $@,, $(LIBS) $(LFLAGS)
X  	erase $*.obj
X  
X--- 56,62 ----
X  
X  # To produce a `.exe' file from a `.c' file.
X  .c.exe:
X! 	$(CC) $(CFLAGS) -c $*.c
X  	link $*.obj $(SETARGV), $@,, $(LIBS) $(LFLAGS)
X  	erase $*.obj
X  
X*** others/Old/Makefile.tcc	Wed Aug 16 12:07:08 1989
X--- others/Makefile.tcc	Wed Aug 16 10:14:40 1989
X***************
X*** 24,36 ****
X  # Optional PC NetHack features (see pcconf.h).  Set to nothing if not used.
X  #
X  #	Fish's TERMLIB termcap library.
X! TERMLIB = $(LIB)\termlib.lib
X  #
X  # 	High-quality BSD random number generation routines.
X  RANDOM = o\random.obj
X  
X  LFLAGS	= /noi
X! TLFLAGS = /x /c
X  # No need to link in the floating point library
X  LIBS	= $(LIB)\c$(MODEL)
X  
X--- 24,37 ----
X  # Optional PC NetHack features (see pcconf.h).  Set to nothing if not used.
X  #
X  #	Fish's TERMLIB termcap library.
X! #TERMLIB = $(LIB)\termlib.lib
X! TERMLIB =
X  #
X  # 	High-quality BSD random number generation routines.
X  RANDOM = o\random.obj
X  
X  LFLAGS	= /noi
X! TLFLAGS = /x/c
X  # No need to link in the floating point library
X  LIBS	= $(LIB)\c$(MODEL)
X  
X***************
X*** 43,48 ****
X--- 44,54 ----
X  # reason with too many objects it produces a file that freaks out
X  # and hangs the system.
X  #
X+ # Also note:
X+ #
X+ # Using /EXEPACK with LINK will greatly reduce the size of the
X+ # executable (about 50K), it will also greatly increase the memory
X+ # required to load it (about 20K).
X  TLINK	= tlink
X  LINK	= link
X  
X***************
X*** 76,90 ****
X  VOBJM = o\apply.obj o\artifact.obj o\attrib.obj o\bones.obj o\dbridge.obj \
X  	o\demon.obj o\do.obj o\do_name.obj o\do_wear.obj o\dog.obj \
X  	o\dogmove.obj o\dokick.obj o\dothrow.obj o\eat.obj o\engrave.obj \
X! 	o\exper.obj o\fountain.obj o\invent.obj o\lock.obj o\mcastu.obj \
X! 	o\mhitm.obj o\mhitu.obj o\msdos.obj o\mthrowu.obj o\music.obj \
X! 	o\objnam.obj o\options.obj o\pager.obj o\pickup.obj o\polyself.obj \
X! 	o\potion.obj o\pray.obj o\priest.obj o\read.obj o\restore.obj \
X! 	o\rip.obj o\rnd.obj o\rumors.obj o\save.obj o\search.obj o\shk.obj \
X! 	o\sit.obj o\sounds.obj o\spell.obj o\steal.obj o\termcap.obj \
X! 	o\track.obj o\trap.obj o\uhitm.obj o\vault.obj o\weapon.obj \
X! 	o\were.obj o\wield.obj o\wizard.obj o\worm.obj o\worn.obj \
X! 	o\write.obj o\zap.obj
X  VOBJL = o\mklev.obj o\mkmaze.obj o\extralev.obj o\sp_lev.obj o\mkroom.obj \
X  	o\shknam.obj o\topten.obj o\end.obj o\o_init.obj o\u_init.obj
X  VOBJ  = $(VOBJS) $(VOBJM) $(VOBJL)
X--- 82,96 ----
X  VOBJM = o\apply.obj o\artifact.obj o\attrib.obj o\bones.obj o\dbridge.obj \
X  	o\demon.obj o\do.obj o\do_name.obj o\do_wear.obj o\dog.obj \
X  	o\dogmove.obj o\dokick.obj o\dothrow.obj o\eat.obj o\engrave.obj \
X! 	o\exper.obj o\fountain.obj o\invent.obj o\lock.obj \
X! 	o\mcastu.obj o\mhitm.obj o\mhitu.obj o\msdos.obj o\mthrowu.obj \
X! 	o\music.obj o\objnam.obj o\options.obj o\pager.obj o\pickup.obj \
X! 	o\polyself.obj o\potion.obj o\pray.obj o\priest.obj o\read.obj \
X! 	o\restore.obj o\rip.obj o\rnd.obj o\rumors.obj o\save.obj \
X! 	o\search.obj o\shk.obj o\sit.obj o\sounds.obj o\spell.obj \
X! 	o\steal.obj o\termcap.obj o\track.obj o\trap.obj o\uhitm.obj \
X! 	o\vault.obj o\weapon.obj o\were.obj o\wield.obj o\wizard.obj \
X! 	o\worm.obj o\worn.obj o\write.obj o\zap.obj
X  VOBJL = o\mklev.obj o\mkmaze.obj o\extralev.obj o\sp_lev.obj o\mkroom.obj \
X  	o\shknam.obj o\topten.obj o\end.obj o\o_init.obj o\u_init.obj
X  VOBJ  = $(VOBJS) $(VOBJM) $(VOBJL)
X***************
X*** 102,112 ****
X  GLOBAL_H   = $(INCL)\global.h $(INCL)\coord.h $(PCCONF_H)
X  CONFIG_H   = $(INCL)\config.h $(INCL)\tradstdc.h $(GLOBAL_H)
X  TRAP_H	   = $(INCL)\trap.h
X! PCCONF_H   = $(INCL)\$(TARG)conf.h $(INCL)\system.h $(INCL)\extern.h
X  PERMONST_H = $(INCL)\permonst.h $(INCL)\monflag.h
X  YOU_H	   = $(INCL)\you.h $(INCL)\attrib.h $(PERMONST_H) $(INCL)\mondata.h \
X  	     $(INCL)\monst.h $(INCL)\youprop.h
X! DECL_H	   = $(INCL)\decl.h
X  DECL_H	   = $(INCL)\spell.h $(INCL)\obj.h $(YOU_H) $(INCL)\onames.h \
X  	     $(INCL)\pm.h
X  HACK_H	   = $(CONFIG_H) $(DECL_H) $(INCL)\monsym.h $(INCL)\mkroom.h \
X--- 108,118 ----
X  GLOBAL_H   = $(INCL)\global.h $(INCL)\coord.h $(PCCONF_H)
X  CONFIG_H   = $(INCL)\config.h $(INCL)\tradstdc.h $(GLOBAL_H)
X  TRAP_H	   = $(INCL)\trap.h
X! #PCCONF_H  = $(INCL)\system.h $(INCL)\extern.h
X  PERMONST_H = $(INCL)\permonst.h $(INCL)\monflag.h
X  YOU_H	   = $(INCL)\you.h $(INCL)\attrib.h $(PERMONST_H) $(INCL)\mondata.h \
X  	     $(INCL)\monst.h $(INCL)\youprop.h
X! #DECL_H	   = $(INCL)\decl.h
X  DECL_H	   = $(INCL)\spell.h $(INCL)\obj.h $(YOU_H) $(INCL)\onames.h \
X  	     $(INCL)\pm.h
X  HACK_H	   = $(CONFIG_H) $(DECL_H) $(INCL)\monsym.h $(INCL)\mkroom.h \
X***************
X*** 122,129 ****
X  
X  # The main target
X  $(GAMEFILE): o $(HOBJ) Makefile
X! 	if exist $(GAMEFILE) del $(GAMEFILE)
X! 	link $(C0) $(HOBJ),$(GAMEFILE) /seg:1024 /e,,$(LIBS) $(TERMLIB) $(LFLAGS)
X  	echo 
X  $(GAME): $(GAMEFILE)
X  
X--- 128,135 ----
X  
X  # The main target
X  $(GAMEFILE): o $(HOBJ) Makefile
X! 	if exist $@ del $@
X! 	$(LINK) $(C0) $(HOBJ),$@ /seg:1024,,$(LIBS) $(TERMLIB) $(LFLAGS)
X  	echo 
X  $(GAME): $(GAMEFILE)
X  
X***************
X*** 198,204 ****
X  	cd $(AUX)
X  	xcopy *. $(GAMEDIR)
X  
X! spec_levs: $(AUX)\castle.des $(AUX)\endgame.des $(AUX)\tower.des
X  	lev_comp $(AUX)\castle.des
X  	lev_comp $(AUX)\endgame.des
X  	lev_comp $(AUX)\tower.des
X--- 204,210 ----
X  	cd $(AUX)
X  	xcopy *. $(GAMEDIR)
X  
X! spec_levs: $(AUX)\castle.des $(AUX)\endgame.des $(AUX)\tower.des lev_comp.exe
X  	lev_comp $(AUX)\castle.des
X  	lev_comp $(AUX)\endgame.des
X  	lev_comp $(AUX)\tower.des
X***************
X*** 220,225 ****
X--- 226,234 ----
X  	del onames.h
X  	del pm.h
X  	touch date.h onames.h pm.h
X+ 	cd $(AUX)
X+ 	del data
X+ 	del rumors
X  	cd $(SRC)
X  	del makedefs.exe
X  	if exist lev_comp.exe del lev_comp.exe
X*** others/Old/msdos.c	Wed Aug 16 12:07:48 1989
X--- others/msdos.c	Wed Aug 16 10:15:04 1989
X***************
X*** 16,21 ****
X--- 16,24 ----
X  #   undef getdate
X  #  endif
X  # endif
X+ #ifdef OS2
X+ # include "def_os2.h"    /* OS2 definitions (Timo Hakulinen) */
X+ #endif
X  static char DOSgetch();
X  #ifdef DGK
X  static char BIOSgetch();
X***************
X*** 43,55 ****
X  	return ((ch == '\r') ? '\n' : ch);
X  }
X  
X  #define DIRECT_INPUT	0x7
X  static char
X  DOSgetch() {
X  #ifdef TOS
X  	return (Crawcin() & 0x007f);
X  #else
X! 	union REGS regs;
X  
X  	regs.h.ah = DIRECT_INPUT;
X  	intdos(&regs, &regs);
X--- 46,72 ----
X  	return ((ch == '\r') ? '\n' : ch);
X  }
X  
X+ #ifndef OS2
X  #define DIRECT_INPUT	0x7
X+ #endif
X  static char
X  DOSgetch() {
X+ #ifdef OS2
X+ 	KBDKEYINFO CharData;
X+ 	USHORT IOWait = 0;
X+ 	HKBD KbdHandle = 0;
X+ 
X+ 	KbdCharIn(&CharData,IOWait,KbdHandle);
X+ 	if (CharData.chChar == 0) {	/* an extended code -- not yet supported */
X+ 		KbdCharIn(&CharData,IOWait,KbdHandle);	   /* eat the next character */
X+ 		CharData.chChar = 0;		/* and return a 0 */
X+ 	}
X+ 	return (CharData.chChar);
X+ #else
X  #ifdef TOS
X  	return (Crawcin() & 0x007f);
X  #else
X!     union REGS regs;
X  
X  	regs.h.ah = DIRECT_INPUT;
X  	intdos(&regs, &regs);
X***************
X*** 60,65 ****
X--- 77,83 ----
X  	}
X  	return (regs.h.al);
X  #endif /* TOS */
X+ #endif /* OS2 */
X  }
X  
X  #include <ctype.h>
X***************
X*** 93,107 ****
X--- 111,130 ----
X  			flags.toplin = 0;
X  			more();
X  		}
X+ 		gettty(); /* ctrl-P might get turned back on (TH) */
X  		chdirx(hackdir, 0);
X  		start_screen();
X  		docrt();
X  	} else
X+ #ifdef OS2
X+ 		pline("Cannot exec CMD.EXE");
X+ #else
X  #ifdef TOS
X  		pline("Cannot find SHELL");
X  #else
X  		pline("Cannot exec COMMAND.COM");
X  #endif
X+ #endif /* OS2 */
X  	return 0;
X  }
X  #endif /* SHELL */
X***************
X*** 173,189 ****
X  #define SHIFT		(0x1 | 0x2)
X  /* #define CTRL		0x4 */
X  /* #define ALT		0x8 */
X  #define KEYBRD_BIOS	0x16
X  
X  static char
X  BIOSgetch() {
X  	unsigned char scan, shift, ch;
X  #ifdef TOS
X  	long  x;
X  #else
X  	union REGS regs;
X  #endif
X- 	struct pad (*kpad)[PADKEYS];
X  
X  	/* Get scan code.
X  	 */
X--- 196,225 ----
X  #define SHIFT		(0x1 | 0x2)
X  /* #define CTRL		0x4 */
X  /* #define ALT		0x8 */
X+ #ifndef OS2
X  #define KEYBRD_BIOS	0x16
X+ #endif
X  
X  static char
X  BIOSgetch() {
X  	unsigned char scan, shift, ch;
X+ 	struct pad (*kpad)[PADKEYS];
X+ 
X+ #ifdef OS2
X+ 	KBDKEYINFO CharData;
X+ 	USHORT IOWait = 0;
X+ 	HKBD KbdHandle = 0;
X+ 
X+ 	KbdCharIn(&CharData,IOWait,KbdHandle);
X+ 	ch = CharData.chChar;
X+ 	scan = CharData.chScan;
X+ 	shift = CharData.fsState;
X+ #else /* OS2 */
X  #ifdef TOS
X  	long  x;
X  #else
X  	union REGS regs;
X  #endif
X  
X  	/* Get scan code.
X  	 */
X***************
X*** 191,197 ****
X  	x = Crawcin();
X  	ch = x & 0x0ff;
X  	scan = (x & 0x00ff0000L) >> 16;
X! #else	
X  	regs.h.ah = 0;
X  	int86(KEYBRD_BIOS, &regs, &regs);
X  	ch = regs.h.al;
X--- 227,233 ----
X  	x = Crawcin();
X  	ch = x & 0x0ff;
X  	scan = (x & 0x00ff0000L) >> 16;
X! #else
X  	regs.h.ah = 0;
X  	int86(KEYBRD_BIOS, &regs, &regs);
X  	ch = regs.h.al;
X***************
X*** 206,220 ****
X  	int86(KEYBRD_BIOS, &regs, &regs);
X  	shift = regs.h.al;
X  #endif
X  	/* If scan code is for the keypad, translate it.
X  	 */
X  	kpad = flags.num_pad ? numpad : keypad;
X  	if (iskeypad(scan)) {
X  		if (shift & SHIFT) {
X! #ifndef TOS
X! 			flags.mv = flags.run = 1;
X! 			/* necessary if number_pad is on */
X! #endif
X  			ch = (*kpad)[scan - KEYPADLOW].shift;
X  		} else
X  			ch = (*kpad)[scan - KEYPADLOW].normal;
X--- 242,255 ----
X  	int86(KEYBRD_BIOS, &regs, &regs);
X  	shift = regs.h.al;
X  #endif
X+ #endif /* OS2 */
X+ 
X  	/* If scan code is for the keypad, translate it.
X  	 */
X  	kpad = flags.num_pad ? numpad : keypad;
X  	if (iskeypad(scan)) {
X  		if (shift & SHIFT) {
X! 			/* if number_pad is on, this makes little difference */
X  			ch = (*kpad)[scan - KEYPADLOW].shift;
X  		} else
X  			ch = (*kpad)[scan - KEYPADLOW].normal;
X***************
X*** 224,229 ****
X--- 259,265 ----
X  
X  #ifndef TOS
X  
X+ #ifndef OS2
X  #define FINDFIRST	0x4E00
X  #define FINDNEXT	0x4F00
X  #define GETDTA		0x2F00
X***************
X*** 230,248 ****
X  #define SETFILETIME	0x5701
X  #define GETSWITCHAR	0x3700
X  #define FREESPACE	0x36
X  
X  #ifdef __TURBOC__
X  #define switchar()	(char)getswitchar()
X  #else
X  static char
X  switchar()
X  {
X! 	union REGS regs;
X  
X  	regs.x.ax = GETSWITCHAR;
X  	intdos(&regs, &regs);
X  	return regs.h.dl;
X  }
X  #endif
X  
X  long
X--- 266,287 ----
X  #define SETFILETIME	0x5701
X  #define GETSWITCHAR	0x3700
X  #define FREESPACE	0x36
X+ #endif
X  
X  #ifdef __TURBOC__
X  #define switchar()	(char)getswitchar()
X  #else
X+ #ifndef OS2
X  static char
X  switchar()
X  {
X!     union REGS regs;
X  
X  	regs.x.ax = GETSWITCHAR;
X  	intdos(&regs, &regs);
X  	return regs.h.dl;
X  }
X+ #endif /* OS2 */
X  #endif
X  
X  long
X***************
X*** 249,254 ****
X--- 288,314 ----
X  freediskspace(path)
X  char *path;
X  {
X+ #ifdef OS2
X+ 	struct {
X+ 		ULONG  idFileSystem;
X+ 		ULONG  cSectorUnit;
X+ 		ULONG  cUnit;
X+ 		ULONG  cUnitAvail;
X+ 		USHORT cbSector;
X+ 	} FSInfoBuf;
X+ 	USHORT DriveNumber, FSInfoLevel = 1, res;
X+ 
X+ 	if (path[0] && path[1] == ':')
X+ 		DriveNumber = (toupper(path[0]) - 'A') + 1;
X+ 	else
X+ 		DriveNumber = 0;
X+ 	res = DosQFSInfo(DriveNumber,FSInfoLevel,(PBYTE)&FSInfoBuf,sizeof(FSInfoBuf));
X+ 	if (res)
X+ 		return -1L;		/* error */
X+ 	else
X+ 		return ((long) FSInfoBuf.cSectorUnit * FSInfoBuf.cUnitAvail *
X+ 			       FSInfoBuf.cbSector);
X+ #else
X  	union REGS regs;
X  
X  	regs.h.ah = FREESPACE;
X***************
X*** 261,268 ****
X--- 321,334 ----
X  		return -1L;		/* bad drive number */
X  	else
X  		return ((long) regs.x.bx * regs.x.cx * regs.x.ax);
X+ #endif /* OS2 */
X  }
X  
X+ #ifdef OS2
X+ FILEFINDBUF ResultBuf;
X+ HDIR DirHandle;
X+ #endif
X+ 
X  /* Functions to get filenames using wildcards
X   */
X  static int
X***************
X*** 269,274 ****
X--- 335,347 ----
X  findfirst(path)
X  char *path;
X  {
X+ #ifdef OS2
X+ 	USHORT res, SearchCount = 1;
X+ 
X+ 	DirHandle = 1;
X+ 	res = DosFindFirst((PSZ)path,&DirHandle,0,&ResultBuf,sizeof(FILEFINDBUF),&SearchCount,0L);
X+ 	return(!res);
X+ #else
X  	union REGS regs;
X  	struct SREGS sregs;
X  
X***************
X*** 278,294 ****
X--- 351,376 ----
X  	sregs.ds = FP_SEG(path);
X  	intdosx(&regs, &regs, &sregs);
X  	return !regs.x.cflag;
X+ #endif /* OS2 */
X  }
X  
X  static int
X  findnext() {
X+ #ifdef OS2
X+ 	USHORT res, SearchCount = 1;
X+ 
X+ 	res = DosFindNext(DirHandle,&ResultBuf,sizeof(FILEFINDBUF),&SearchCount);
X+ 	return(!res);
X+ #else
X  	union REGS regs;
X  
X  	regs.x.ax = FINDNEXT;
X  	intdos(&regs, &regs);
X  	return !regs.x.cflag;
X+ #endif /* OS2 */
X  }
X  
X+ #ifndef OS2
X  /* Get disk transfer area, Turbo C already has getdta */
X  static char *
X  getdta() {
X***************
X*** 306,311 ****
X--- 388,394 ----
X  #endif
X  	return ret;
X  }
X+ #endif  /* OS2 */
X  
X  #else /* TOS */
X  
X***************
X*** 348,358 ****
X--- 431,447 ----
X  filesize(file)
X  char *file;
X  {
X+ #ifndef OS2
X  	char *dta;
X+ #endif
X  
X  	if (findfirst(file)) {
X+ #ifdef OS2
X+ 		return  (* (long *) (ResultBuf.cbFileAlloc));
X+ #else
X  		dta = getdta();
X  		return  (* (long *) (dta + 26));
X+ #endif
X  	} else
X  		return -1L;
X  }
X***************
X*** 361,373 ****
X  eraseall(path, files)
X  char *path, *files;
X  {
X! 	char *dta, buf[PATHLEN];
X  
X  	dta = getdta();
X  	Sprintf(buf, "%s%s", path, files);
X  	if (findfirst(buf))
X  		do {
X! 			Sprintf(buf, "%s%s", path, dta + 30);
X  			(void) unlink(buf);
X  		} while (findnext());
X  	return;
X--- 450,474 ----
X  eraseall(path, files)
X  char *path, *files;
X  {
X! 	char
X! #ifndef OS2
X! 		*dta,
X! #endif
X! 	buf[PATHLEN];
X  
X+ #ifndef OS2
X  	dta = getdta();
X+ #endif
X  	Sprintf(buf, "%s%s", path, files);
X  	if (findfirst(buf))
X  		do {
X! 			Sprintf(buf, "%s%s", path,
X! #ifdef OS2
X! 				ResultBuf.achName
X! #else
X! 				dta + 30
X! #endif
X! 				);
X  			(void) unlink(buf);
X  		} while (findnext());
X  	return;
X***************
X*** 378,387 ****
X  void
X  copybones(mode) {
X  	char from[PATHLEN], to[PATHLEN], last[13], copy[8];
X! 	char *frompath, *topath, *dta, *comspec;
X  	int status;
X  	long fs;
X  	extern saveprompt;
X  #ifdef TOS
X  	extern int _copyfile();
X  #endif
X--- 479,493 ----
X  void
X  copybones(mode) {
X  	char from[PATHLEN], to[PATHLEN], last[13], copy[8];
X! 	char *frompath, *topath,
X! #ifndef OS2
X! 	*dta,
X! #endif
X! 	*comspec;
X  	int status;
X  	long fs;
X  	extern saveprompt;
X+ 
X  #ifdef TOS
X  	extern int _copyfile();
X  #endif
X***************
X*** 391,397 ****
X--- 497,505 ----
X  	/* Find the name of the last file to be transferred
X  	 */
X  	frompath = (mode != TOPERM) ? permbones : levels;
X+ #ifndef OS2
X  	dta = getdta();
X+ #endif
X  	last[0] = '\0';
X  	Sprintf(from, "%s%s", frompath, allbones);
X  	topath = (mode == TOPERM) ? permbones : levels;
X***************
X*** 406,412 ****
X  			if (_copyfile(from, to))
X  				goto error_copying;
X  #endif
X! 			Strcpy(last, dta + 30);
X  		} while (findnext());
X  #ifdef TOS
X  	else
X--- 514,526 ----
X  			if (_copyfile(from, to))
X  				goto error_copying;
X  #endif
X! 			Strcpy(last,
X! #ifdef OS2
X! 				ResultBuf.achName
X! #else
X! 				dta + 30
X! #endif
X! 				);
X  		} while (findnext());
X  #ifdef TOS
X  	else
X***************
X*** 413,419 ****
X  		return;
X  #else
X  	if (last[0]) {
X! 		Sprintf(copy, "%cC copy", switchar());
X  
X  		/* Remove any bones files in `to' directory.
X  		 */
X--- 527,539 ----
X  		return;
X  #else
X  	if (last[0]) {
X! 		Sprintf(copy, "%cC copy",
X! #ifdef OS2
X! 			'/'
X! #else
X! 			switchar()
X! #endif
X! 			);
X  
X  		/* Remove any bones files in `to' directory.
X  		 */
X***************
X*** 516,523 ****
X--- 636,651 ----
X  static boolean
X  record_exists() {
X  	int fd;
X+ #ifdef OS2_CODEVIEW
X+ 	char tmp[PATHLEN];
X  
X+ 	Strcpy(tmp,hackdir);
X+ 	append_slash(tmp);
X+ 	Strcat(tmp,RECORD);
X+ 	if ((fd = open(tmp, 0)) >= 0) {
X+ #else
X  	if ((fd = open(RECORD, 0)) >= 0) {
X+ #endif
X  		(void) close(fd);
X  		return TRUE;
X  	}
X***************
X*** 788,794 ****
X--- 916,924 ----
X  /* Chdrive() changes the default drive.
X   */
X  #ifndef __TURBOC__
X+ #ifndef OS2
X  #define SELECTDISK	0x0E
X+ #endif
X  void
X  chdrive(str)
X  char *str;
X***************
X*** 795,802 ****
X--- 925,934 ----
X  {
X  	char *ptr;
X  #ifndef TOS
X+ #ifndef OS2
X  	union REGS inregs;
X  #endif
X+ #endif
X  	char drive;
X  
X  	if ((ptr = index(str, ':')) != NULL) {
X***************
X*** 804,813 ****
X--- 936,949 ----
X  #ifdef TOS
X  		Dsetdrv(drive - 'A');
X  #else
X+ #ifdef OS2
X+ 		DosSelectDisk((USHORT)(drive - 'A' + 1));
X+ #else
X  		inregs.h.ah = SELECTDISK;
X  		inregs.h.dl = drive - 'A';
X  		intdos(&inregs, &inregs);
X  #endif
X+ #endif
X  	}
X  	return;
X  }
X***************
X*** 829,834 ****
X--- 965,971 ----
X   * Thanks to Mark Zbikowski (markz@microsoft.UUCP).
X   */
X  
X+ #ifndef OS2
X  #define DEVICE		0x80
X  #define RAW		0x20
X  #define IOCTL		0x44
X***************
X*** 836,849 ****
X--- 973,999 ----
X  #define STDOUT		fileno(stdout)
X  #define GETBITS		0
X  #define SETBITS		1
X+ #endif
X  
X  static unsigned	int old_stdin, old_stdout;
X  
X  void
X  disable_ctrlP() {
X+ #ifdef OS2
X+ 	KBDINFO KbdInfo;
X+ 	HKBD KbdHandle = 0;
X+ #endif
X+ 
X  #ifdef DGK
X  	if (!flags.rawio) return;
X  #endif
X+ #ifdef OS2
X+ 	KbdInfo.cb = 10;
X+ 	KbdGetStatus(&KbdInfo,KbdHandle);
X+ 	KbdInfo.fsMask &= 0xFFF7; /* ASCII off */
X+ 	KbdInfo.fsMask |= 0x0004; /* BINARY on */
X+ 	KbdSetStatus(&KbdInfo,KbdHandle);
X+ #else
X  	old_stdin = ioctl(STDIN, GETBITS, 0);
X  	old_stdout = ioctl(STDOUT, GETBITS, 0);
X  	if (old_stdin & DEVICE)
X***************
X*** 850,870 ****
X--- 1000,1035 ----
X  		ioctl(STDIN, SETBITS, old_stdin | RAW);
X  	if (old_stdout & DEVICE)
X  		ioctl(STDOUT, SETBITS, old_stdout | RAW);
X+ #endif /* OS2 */
X  	return;
X  }
X  
X  void
X  enable_ctrlP() {
X+ #ifdef OS2
X+ 	KBDINFO KbdInfo;
X+ 	HKBD KbdHandle = 0;
X+ #endif
X+ 
X  #ifdef DGK
X  	if (!flags.rawio) return;
X  #endif
X+ #ifdef OS2
X+ 	KbdInfo.cb = 10;
X+ 	KbdGetStatus(&KbdInfo,KbdHandle);
X+ 	KbdInfo.fsMask &= 0xFFFB; /* BINARY off */
X+ 	KbdInfo.fsMask |= 0x0008; /* ASCII on */
X+ 	KbdSetStatus(&KbdInfo,KbdHandle);
X+ #else
X  	if (old_stdin)
X  		(void) ioctl(STDIN, SETBITS, old_stdin);
X  	if (old_stdout)
X  		(void) ioctl(STDOUT, SETBITS, old_stdout);
X+ #endif
X  	return;
X  }
X  
X+ #ifndef OS2
X  static unsigned int
X  ioctl(handle, mode, setvalue)
X  int handle, mode;
X***************
X*** 880,885 ****
X--- 1045,1051 ----
X  	intdos(&regs, &regs);
X  	return (regs.x.dx);
X  }
X+ #endif /* OS2 */
X  #endif /* TOS */
X  
X  #ifdef DGK
X***************
X*** 918,923 ****
X--- 1084,1096 ----
X  				pp++;
X  		}
X  	}
X+ #ifdef OS2_CODEVIEW /* one more try for hackdir */
X+ 	Strcpy(buf,hackdir);
X+ 	append_slash(buf);
X+ 	Strcat(buf,name);
X+ 	if(fp = fopen(buf,mode))
X+ 		return fp;
X+ #endif
X  	return (FILE *)0;
X  }
X  #endif /* DGK */
X***************
X*** 950,955 ****
X--- 1123,1179 ----
X  	exit(code);
X  	return;
X  }
X+ 
X+ # ifdef DGK		/* for flags.IBMBIOS */
X+ void
X+ get_scr_size()
X+ {
X+ #  ifdef OS2
X+ 	VIOMODEINFO ModeInfo;
X+ 	HVIO VideoHandle = 0;
X+ 
X+ 	ModeInfo.cb = sizeof(ModeInfo);
X+ 
X+ 	VioGetMode(&ModeInfo,VideoHandle);
X+ 
X+ 	CO = ModeInfo.col;
X+ 	LI = ModeInfo.row;
X+ #  else
X+ 	union REGS regs;
X+ 
X+ 	if (!flags.IBMBIOS) {		/* assume standard screen size */
X+ 		CO = 80;
X+ 		LI = 24;
X+ 		return;
X+ 	}
X+ 
X+ 	regs.x.ax = 0x1130;		/* Func AH = 11h, Subfunc AL = 30h */
X+ 	regs.x.bx = 0;			/* current ROM BIOS font */
X+ 	regs.h.dl = 24;			/* default row count */
X+ 					/* in case no EGA/MCGA/VGA */
X+ 	int86(0x10, &regs, &regs);	/* Get Font Information */
X+ 
X+ 	/* MDA/CGA/PCjr ignore INT 10h, Function 11h, but since we
X+ 	 * cleverly loaded up DL with the default, everything's fine.
X+ 	 *
X+ 	 * Otherwise, DL now contains rows - 1.  Also, CX contains the
X+ 	 * points (bytes per character) and ES:BP points to the font
X+ 	 * table.  -3.
X+ 	 */
X+ 
X+ 	regs.h.ah = 0x0f;
X+ 	int86(0x10, &regs, &regs);	/* Get Video Mode */
X+ 
X+ 	/* This goes back all the way to the original PC.  Completely
X+ 	 * safe.  AH contains # of columns, AL contains display mode,
X+ 	 * and BH contains the active display page.
X+ 	 */
X+ 
X+ 	LI = regs.h.dl + 1;
X+ 	CO = regs.h.ah;
X+ #  endif
X+ }
X+ # endif
X  #endif /* MSDOS */
X  
X  #ifdef TOS
X*** others/Old/pcmain.c	Wed Aug 16 12:08:48 1989
X--- others/pcmain.c	Tue Aug 15 21:13:42 1989
X***************
X*** 1,7 ****
X  /*	SCCS Id: @(#)pcmain.c	3.0	88/11/23
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X! /* main.c - (PC, TOS and AMIGA) version */
X  
X  #include "hack.h"
X  #ifndef NO_SIGNAL
X--- 1,7 ----
X  /*	SCCS Id: @(#)pcmain.c	3.0	88/11/23
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X! /* main.c - PC, ST, and Amiga NetHack */
X  
X  #include "hack.h"
X  #ifndef NO_SIGNAL
X***************
X*** 15,20 ****
X--- 15,21 ----
X  
X  int (*afternmv)(), (*occupation)();
X  static void moveloop();	/* a helper function for MSC optimizer */
X+ static void newgame();
X  
X  #if defined(DGK) && !defined(OLD_TOS)
X  struct finfo	zfinfo = ZFINFO;
X***************
X*** 74,80 ****
X  # endif
X  	if (getcwd(orgdir, sizeof orgdir) == NULL) {
X  		xputs("NetHack: current directory path too long\n");
X! 		_exit(1);
X  	}
X  	funcp = exit;	/* Kludge to get around LINT_ARGS of signal.
X  			 * This will produce a compiler warning, but that's OK.
X--- 75,81 ----
X  # endif
X  	if (getcwd(orgdir, sizeof orgdir) == NULL) {
X  		xputs("NetHack: current directory path too long\n");
X! 		return 1;
X  	}
X  	funcp = exit;	/* Kludge to get around LINT_ARGS of signal.
X  			 * This will produce a compiler warning, but that's OK.
X***************
X*** 85,91 ****
X  #endif /* AMIGA */
X  
X  	/* Set the default values of the presentation characters */
X! 	memcpy((genericptr_t) &showsyms, (genericptr_t) &defsyms, sizeof(struct symbols));
X  	if ((dir = getenv("HACKDIR")) != NULL) {
X  		Strcpy(hackdir, dir);
X  #ifdef CHDIR
X--- 86,93 ----
X  #endif /* AMIGA */
X  
X  	/* Set the default values of the presentation characters */
X! 	(void) memcpy((genericptr_t) &showsyms,
X! 		(genericptr_t) &defsyms, sizeof(struct symbols));
X  	if ((dir = getenv("HACKDIR")) != NULL) {
X  		Strcpy(hackdir, dir);
X  #ifdef CHDIR
X***************
X*** 101,110 ****
X  	initoptions();
X  	if (!hackdir[0])
X  		Strcpy(hackdir, orgdir);
X  #ifdef TOS
X! 	if(argc > 1 && !strncmp(argv[1], "-D", 2)) {
X  #else
X! 	if(argc > 1 && !strncmp(argv[1], "-d", 2)) {
X  #endif
X  		argc--;
X  		argv++;
X--- 103,114 ----
X  	initoptions();
X  	if (!hackdir[0])
X  		Strcpy(hackdir, orgdir);
X+ 
X+ 	if(argc > 1) {
X  #ifdef TOS
X! 	    if(!strncmp(argv[1], "-D", 2)) {
X  #else
X! 	    if(!strncmp(argv[1], "-d", 2)) {
X  #endif
X  		argc--;
X  		argv++;
X***************
X*** 115,124 ****
X  			argv++;
X  			dir = argv[0];
X  		}
X! 		if(!*dir)
X! 		    error("Flag -d must be followed by a directory name.");
X  		Strcpy(hackdir, dir);
X! 	}
X  
X  	/*
X  	 * Now we know the directory containing 'record' and
X--- 119,131 ----
X  			argv++;
X  			dir = argv[0];
X  		}
X! 		if(!*dir) {
X! 		    /* can't use error() until termcap read in */
X! 		    xputs("Flag -d must be followed by a directory name.\n");
X! 		    return 1;
X! 		}
X  		Strcpy(hackdir, dir);
X! 	    }
X  
X  	/*
X  	 * Now we know the directory containing 'record' and
X***************
X*** 125,133 ****
X  	 * may do a prscore().
X  	 */
X  #ifdef TOS
X! 	if(argc > 1 && !strncmp(argv[1], "-S", 2)) {
X  #else
X! 	if(argc > 1 && !strncmp(argv[1], "-s", 2)) {
X  #endif
X  #ifdef CHDIR
X  		chdirx(hackdir,0);
X--- 132,140 ----
X  	 * may do a prscore().
X  	 */
X  #ifdef TOS
X! 	    else if (!strncmp(argv[1], "-S", 2)) {
X  #else
X! 	    else if (!strncmp(argv[1], "-s", 2)) {
X  #endif
X  #ifdef CHDIR
X  		chdirx(hackdir,0);
X***************
X*** 134,139 ****
X--- 141,147 ----
X  #endif
X  		prscore(argc, argv);
X  		exit(0);
X+ 	    }
X  	}
X  
X  #ifndef AMIGA
X***************
X*** 149,162 ****
X  	cls();
X  	u.uhp = 1;	/* prevent RIP on early quits */
X  	u.ux = FAR;	/* prevent nscr() */
X  #ifndef OLD_TOS
X  	/*
X  	 * We cannot do chdir earlier, otherwise gethdate will fail.
X  	 */
X! #ifdef CHDIR
X  	chdirx(hackdir,1);
X! #endif
X  #endif
X  	/*
X  	 * Process options.
X  	 */
X--- 157,178 ----
X  	cls();
X  	u.uhp = 1;	/* prevent RIP on early quits */
X  	u.ux = FAR;	/* prevent nscr() */
X+ 
X+ 	/*
X+ 	 * Find the creation date of this game,
X+ 	 * so as to avoid restoring outdated savefiles.
X+ 	 */
X+ 	/* gethdate(hname); */
X+ 
X  #ifndef OLD_TOS
X  	/*
X  	 * We cannot do chdir earlier, otherwise gethdate will fail.
X  	 */
X! # ifdef CHDIR
X  	chdirx(hackdir,1);
X! # endif
X  #endif
X+ 
X  	/*
X  	 * Process options.
X  	 */
X***************
X*** 165,173 ****
X  		argc--;
X  		switch(argv[0][1]){
X  #if defined(WIZARD) || defined(EXPLORE_MODE)
X! #ifndef TOS
X  		case 'D':
X! #endif	/* TOS */
X  		case 'X':
X  # ifdef WIZARD
X  			/* Must have "name" set correctly by NETHACK.CNF,
X--- 181,189 ----
X  		argc--;
X  		switch(argv[0][1]){
X  #if defined(WIZARD) || defined(EXPLORE_MODE)
X! # ifndef TOS
X  		case 'D':
X! # endif
X  		case 'X':
X  # ifdef WIZARD
X  			/* Must have "name" set correctly by NETHACK.CNF,
X***************
X*** 186,195 ****
X--- 202,217 ----
X  #endif
X  #ifdef NEWS
X  		case 'N':
X+ # ifndef TOS
X+ 		case 'n':
X+ # endif
X  			flags.nonews = TRUE;
X  			break;
X  #endif
X  		case 'U':
X+ #ifndef TOS
X+ 		case 'u':
X+ #endif
X  			if(argv[0][2])
X  			  (void) strncpy(plname, argv[0]+2, sizeof(plname)-1);
X  			else if(argc > 1) {
X***************
X*** 202,217 ****
X  #ifdef DGK
X  		/* Person does not want to use a ram disk
X  		 */
X  		case 'R':
X  			ramdisk = FALSE;
X  			break;
X  #endif
X  		case 'C':   /* character role is next character */
X! 			/* allow -T for Tourist, etc. */
X  			(void) strncpy(pl_character, argv[0]+2,
X  				sizeof(pl_character)-1);
X  		default:
X  			Printf("Unknown option: %s\n", *argv);
X  		}
X  	}
X  
X--- 224,250 ----
X  #ifdef DGK
X  		/* Person does not want to use a ram disk
X  		 */
X+ # ifdef TOS
X  		case 'R':
X+ # else
X+ 		case 'r':
X+ # endif
X  			ramdisk = FALSE;
X  			break;
X  #endif
X  		case 'C':   /* character role is next character */
X! 			/* allow -CT for Tourist, etc. */
X  			(void) strncpy(pl_character, argv[0]+2,
X  				sizeof(pl_character)-1);
X+ 			break;
X  		default:
X+ #ifndef TOS
X+ 			/* allow -T for Tourist, etc. */
X+ 			(void) strncpy(pl_character, argv[0]+1,
X+ 				sizeof(pl_character)-1);
X+ #else
X  			Printf("Unknown option: %s\n", *argv);
X+ #endif
X  		}
X  	}
X  
X***************
X*** 274,281 ****
X  		/* get shopkeeper set properly if restore is in shop */
X  		(void) inshop();
X  #ifdef EXPLORE_MODE
X! 		if (discover) {
X  			You("are in non-scoring discovery mode.");
X  			pline("Do you want to keep the save file? ");
X  			if(yn() == 'n')
X  				(void) unlink(SAVEF);
X--- 307,317 ----
X  		/* get shopkeeper set properly if restore is in shop */
X  		(void) inshop();
X  #ifdef EXPLORE_MODE
X! 		if (discover)
X  			You("are in non-scoring discovery mode.");
X+ #endif
X+ #if defined(EXPLORE_MODE) || defined(WIZARD)
X+ 		if (discover || wizard) {
X  			pline("Do you want to keep the save file? ");
X  			if(yn() == 'n')
X  				(void) unlink(SAVEF);
X***************
X*** 284,327 ****
X  		flags.move = 0;
X  	} else {
X  not_recovered:
X! #ifdef DGK
X! 		gameDiskPrompt();
X! #endif
X! 		fobj = fcobj = invent = 0;
X! 		fmon = fallen_down = 0;
X! 		ftrap = 0;
X! 		fgold = 0;
X! 		flags.ident = 1;
X! 		init_objects();
X! 		u_init();
X! #ifndef NO_SIGNAL
X! 		(void) signal(SIGINT, (SIG_RET_TYPE) done1);
X! #endif
X! 		mklev();
X! 		u.ux = xupstair;
X! 		u.uy = yupstair;
X! 		(void) inshop();
X! 		setsee();
X! 		flags.botlx = 1;
X! 		/* Fix bug with dog not being made because a monster
X! 		 * was on the level 1 staircase
X! 		 */
X! 		if(levl[u.ux][u.uy].mmask) mnexto(m_at(u.ux, u.uy));
X! 		(void) makedog();
X! 		seemons();
X! #ifdef NEWS
X! 		if(flags.nonews || !readnews())
X! 			/* after reading news we did docrt() already */
X! #endif
X! 			docrt();
X! 
X  		/* give welcome message before pickup messages */
X  		pline("Hello %s, welcome to NetHack!", plname);
X  		set_wear();
X  		pickup(1);
X  		read_engr_at(u.ux,u.uy);
X- 		flags.move = 0;
X  	}
X  	flags.moonphase = phase_of_the_moon();
X  	if(flags.moonphase == FULL_MOON) {
X  		You("are lucky!  Full moon tonight.");
X--- 320,338 ----
X  		flags.move = 0;
X  	} else {
X  not_recovered:
X! 		newgame();
X  		/* give welcome message before pickup messages */
X  		pline("Hello %s, welcome to NetHack!", plname);
X+ #ifdef EXPLORE_MODE
X+ 		if (discover)
X+ 			You("are in non-scoring discovery mode.");
X+ #endif
X+ 		flags.move = 0;
X  		set_wear();
X  		pickup(1);
X  		read_engr_at(u.ux,u.uy);
X  	}
X+ 
X  	flags.moonphase = phase_of_the_moon();
X  	if(flags.moonphase == FULL_MOON) {
X  		You("are lucky!  Full moon tonight.");
X***************
X*** 334,339 ****
X--- 345,353 ----
X  #ifndef NO_SIGNAL
X  	(void) signal(SIGINT, SIG_IGN);
X  #endif
X+ #ifdef OS2
X+ 	gettty(); /* somehow ctrl-P gets turned back on during startup ... */
X+ #endif
X  	/* Help for Microsoft optimizer.  Otherwise main is too large -dgk*/
X  	moveloop();
X  	return 0;
X***************
X*** 376,382 ****
X  #endif
X  			    if(u.uhp < 1) {
X  				You("die...");
X! 				done("died");
X  			    }
X  #ifdef POLYSELF
X  			if (u.mtimedone) {
X--- 390,396 ----
X  #endif
X  			    if(u.uhp < 1) {
X  				You("die...");
X! 				done(DIED);
X  			    }
X  #ifdef POLYSELF
X  			if (u.mtimedone) {
X***************
X*** 590,601 ****
X  #else
X  		dir = ".";
X  #endif
X! 	    if((fd = open(RECORD, 2)) < 0) {
X  #ifdef DGK
X  		char tmp[PATHLEN];
X  
X  		Strcpy(tmp, dir);
X  		append_slash(tmp);
X  		msmsg("Warning: cannot write %s%s\n", tmp, RECORD);
X  		getreturn("to continue");
X  #else
X--- 604,627 ----
X  #else
X  		dir = ".";
X  #endif
X! #ifdef OS2_CODEVIEW  /* explicit path on opening for OS/2 */
X! 		{
X! 		char tmp[PATHLEN];
X! 
X! 		Strcpy(tmp, dir);
X! 		append_slash(tmp);
X! 		Strcat(tmp, RECORD);
X! 		if((fd = open(tmp, 2)) < 0) {
X! #else
X! 		if((fd = open(RECORD, 2)) < 0) {
X! #endif
X  #ifdef DGK
X+ #ifndef OS2_CODEVIEW
X  		char tmp[PATHLEN];
X  
X  		Strcpy(tmp, dir);
X  		append_slash(tmp);
X+ #endif
X  		msmsg("Warning: cannot write %s%s\n", tmp, RECORD);
X  		getreturn("to continue");
X  #else
X***************
X*** 604,609 ****
X--- 630,638 ----
X  #endif
X  	    } else
X  		(void) close(fd);
X+ #ifdef OS2_CODEVIEW
X+ 		}
X+ #endif
X  	}
X  }
X  #endif /* CHDIR /**/
X***************
X*** 619,622 ****
X--- 648,695 ----
X  		pushch(0);
X  #endif
X  	}
X+ }
X+ 
X+ static void
X+ newgame() {
X+ #ifdef DGK
X+ 	gameDiskPrompt();
X+ #endif
X+ 
X+ 	fobj = fcobj = invent = 0;
X+ 	fmon = fallen_down = 0;
X+ 	ftrap = 0;
X+ 	fgold = 0;
X+ 	flags.ident = 1;
X+ 
X+ 	init_objects();
X+ 	u_init();
X+ 
X+ #ifndef NO_SIGNAL
X+ 	(void) signal(SIGINT, (SIG_RET_TYPE) done1);
X+ #endif
X+ 
X+ 	mklev();
X+ 	u.ux = xupstair;
X+ 	u.uy = yupstair;
X+ 	(void) inshop();
X+ 
X+ 	setsee();
X+ 	flags.botlx = 1;
X+ 
X+ 	/* Move the monster from under you or else
X+ 	 * makedog() will fail when it calls makemon().
X+ 	 * 			- ucsfcgl!kneller
X+ 	 */
X+ 	if(levl[u.ux][u.uy].mmask) mnexto(m_at(u.ux, u.uy));
X+ 
X+ 	(void) makedog();
X+ 	seemons();
X+ #ifdef NEWS
X+ 	if(flags.nonews || !readnews())
X+ 		/* after reading news we did docrt() already */
X+ #endif
X+ 		docrt();
X+ 
X+ 	return;
X  }
X*** /dev/null	Tue Aug 15 10:53:49 1989
X--- others/Makefile.os2	Tue Aug 15 20:51:02 1989
X***************
X*** 0 ****
X--- 1,320 ----
X+ #	SCCS Id: @(#)Makefile.os2	3.0	89/08/10
X+ #	PC NetHack 3.0 Makefile for Microsoft(tm) C 5.1 and OS/2
X+ #
X+ #	NDMAKE ver 4.3+ is required, MS-MAKE does *not* work
X+ #
X+ # Large memory model
X+ CC	= cl
X+ LINK	= link
X+ MODEL	= L
X+ 
X+ # Directories (makedefs hardcodes these, don't change them)
X+ INCL	= ..\include
X+ AUX	= ..\auxil
X+ SRC	= ..\src
X+ 
X+ # memory model, compile only, #define LINT_ARGS, disable optimization,
X+ # remove stack probes, 80286 instruction set, dedicated datasegment for
X+ # items >= 5 bytes, pack structures on 1 byte boundaries, generate code
X+ # for 8087 coprocessor, include file path
X+ CFLAGS	= /A$(MODEL) /c /DLINT_ARGS /Od /Gs /G2 /Gt5 /Zp1 /FPi87 /I$(INCL)
X+ 
X+ # + prepare for CodeView symbolic debugger
X+ #CFLAGS	= /A$(MODEL) /c /DLINT_ARGS /Od /Gs /G2 /Gt5 /Zp1 /FPi87 /I$(INCL) /Zi
X+ 
X+ # don't ignore case in symbols, no default lib search, stack 4096 bytes
X+ # (actually a bit of overkill), allow max 1024 segments in program
X+ LFLAGS	= /noig /nod /stack:4096 /seg:1024
X+ 
X+ # + prepare for CodeView symbolic debugger
X+ #LFLAGS	= /noig /nod /stack:4096 /seg:1024 /CO
X+ 
X+ # real mode C libraries for 8087 coprocessor
X+ RLIBS	= $(MODEL)libc7r
X+ 
X+ # protected mode C libraries for 8087, OS/2 API entry points
X+ PLIBS	= $(MODEL)libc7p doscalls
X+ 
X+ # termcap routines
X+ TERMLIB= termlib.lib
X+ 
X+ # module definition file for OS/2
X+ OS2DEFS	= $(GAME).def
X+ 
X+ # target system
X+ TARG	= pc
X+ 
X+ .c.o:
X+ 	$(CC) $(CFLAGS) /Foo\$*.o $*.c
X+ 
X+ # Optional high-quality BSD random number generation routines (see pcconf.h).
X+ # Set to nothing if not used.
X+ RANDOM = o\random.o
X+ 
X+ # Termcap objs
X+ TERMOBJS= o\tgetent.o o\tgetflag.o o\tgetnum.o o\tgetstr.o o\tgoto.o o\tputs.o o\isdigit.o o\fgetlr.o
X+ 
X+ # For NDMAKE, to handle the .o suffix.
X+ .SUFFIXES: .exe .o .c .y .l
X+ 
X+ # The game name
X+ GAME= nethack
X+ 
X+ # The game directory
X+ GAMEDIR = \games\$(GAME)
X+ 
X+ # The game filename
X+ GAMEFILE = $(GAMEDIR)\$(GAME).exe
X+ 
X+ # object files for makedefs
X+ MAKEOBJS = o\makedefs.o o\alloc.o o\monst.o o\objects.o o\panic.o
X+ 
X+ # object files for special levels compiler
X+ SPLEVOBJS = o\lev_comp.o o\lev_lex.o o\lev_main.o o\alloc.o o\monst.o o\objects.o o\panic.o
X+ 
X+ # nothing below this line should have to be changed
X+ #
X+ # other things that have to be reconfigured are in config.h,
X+ # {unixconf.h, pcconf.h, tosconf.h}, and possibly system.h
X+ 
X+ VOBJ =	o\alloc.o o\apply.o o\artifact.o o\attrib.o o\bones.o o\cmd.o \
X+ 	o\dbridge.o o\decl.o o\demon.o o\do.o o\do_name.o o\do_wear.o \
X+ 	o\dog.o o\dogmove.o o\dokick.o o\dothrow.o o\eat.o o\end.o o\engrave.o \
X+ 	o\exper.o o\extralev.o o\fountain.o o\getline.o o\hack.o o\invent.o \
X+ 	o\lock.o o\mail.o o\main.o o\makemon.o o\mcastu.o o\mhitm.o o\mhitu.o \
X+ 	o\mklev.o o\mkmaze.o o\mkobj.o o\mkroom.o o\mon.o o\mondata.o \
X+ 	o\msdos.o o\monmove.o o\monst.o o\mthrowu.o o\music.o o\o_init.o \
X+ 	o\objects.o o\objnam.o o\options.o o\pager.o o\pickup.o o\polyself.o \
X+ 	o\potion.o o\pray.o o\pri.o o\priest.o o\prisym.o $(RANDOM) o\read.o \
X+ 	o\restore.o o\rip.o o\rnd.o o\rumors.o o\save.o o\search.o o\shk.o \
X+ 	o\shknam.o o\sit.o o\sounds.o o\sp_lev.o o\spell.o o\steal.o \
X+ 	o\termcap.o o\timeout.o o\topl.o o\topten.o o\track.o o\trap.o \
X+ 	o\tty.o o\u_init.o o\uhitm.o o\unix.o o\vault.o o\weapon.o o\were.o \
X+ 	o\wield.o o\wizard.o o\worm.o o\worn.o o\write.o o\zap.o
X+ HOBJ =	$(VOBJ) o\version.o
X+ 
X+ PCCONF_H   = $(INCL)\$(TARG)conf.h $(INCL)\msdos.h $(INCL)\system.h \
X+ 	     $(INCL)\extern.h $(INCL)\def_os2.h 
X+ GLOBAL_H   = $(INCL)\global.h $(INCL)\coord.h $(PCCONF_H)
X+ CONFIG_H   = $(INCL)\config.h $(INCL)\tradstdc.h $(GLOBAL_H)
X+ TRAP_H	   = $(INCL)\trap.h
X+ PERMONST_H = $(INCL)\permonst.h $(INCL)\monflag.h
X+ YOU_H	   = $(INCL)\you.h $(INCL)\attrib.h $(PERMONST_H) $(INCL)\mondata.h \
X+ 	     $(INCL)\monst.h $(INCL)\youprop.h
X+ DECL_H	   = $(INCL)\decl.h $(INCL)\spell.h $(INCL)\obj.h $(YOU_H) \
X+ 	     $(INCL)\onames.h $(INCL)\pm.h
X+ HACK_H	   = $(CONFIG_H) $(DECL_H) $(INCL)\monsym.h $(INCL)\mkroom.h \
X+ 	     $(INCL)\objclass.h $(INCL)\gold.h $(INCL)\trap.h $(INCL)\flag.h \
X+ 	     $(INCL)\rm.h
X+ 
X+ # The main target
X+ $(GAMEDIR)\$(GAME).exe: o $(HOBJ) $(OS2DEFS) $(TERMLIB)
X+ 	$(LINK) $(HOBJ),$(GAMEDIR)\$(GAME),$(GAME),$(PLIBS) $(TERMLIB),$(OS2DEFS) $(LFLAGS) ;
X+ 
X+ # NDMAKE automatically generates LINK response files, so you can
X+ # uncomment the second line if you are using NDMAKE.
X+ 
X+ $(GAME): $(GAMEDIR)\$(GAME).exe
X+ $(GAME).exe: $(GAMEDIR)\$(GAME).exe
X+ 
X+ all:	o makedefs lev_comp $(GAME) auxil record
X+ 	@echo Done.
X+ 
X+ o:
X+ 	mkdir o
X+ 
X+ $(TERMLIB): $(TERMOBJS)
X+ 	lib $(TERMLIB) -+ $(TERMOBJS) ;
X+ 
X+ makedefs:	makedefs.exe
X+ makedefs.exe:	$(MAKEOBJS)
X+ 	$(LINK) $(MAKEOBJS),,,$(RLIBS) $(LFLAGS) ;
X+ 
X+ o\makedefs.o:  $(INCL)\config.h $(INCL)\permonst.h $(INCL)\objclass.h
X+ 
X+ lev_comp:  lev_comp.exe
X+ lev_comp.exe:  $(SPLEVOBJS)
X+ 	$(LINK) $(SPLEVOBJS),lev_comp,,$(RLIBS) $(LFLAGS) ;
X+ 
X+ o\lev_comp.o:  $(HACK_H) $(INCL)\sp_lev.h
X+ o\lev_lex.o:  $(INCL)\lev_comp.h $(HACK_H) $(INCL)\sp_lev.h
X+ o\lev_main.o:  $(HACK_H) $(INCL)\sp_lev.h
X+ 
X+ # If you have yacc or lex programs, and make any changes,
X+ # add some .y.c and .l.c rules to your Make.ini.
X+ 
X+ lev_comp.c:  lev_comp.y
X+ lev_lex.c:  lev_comp.l
X+ 
X+ #
X+ #	The following include files depend on makedefs to be created.
X+ #
X+ #	date.h should be remade any time any of the source or include code
X+ #	is modified.
X+ #
X+ $(INCL)\date.h:	 $(VOBJ) makedefs.exe
X+ 	.\makedefs -v
X+ 
X+ $(INCL)\trap.h:	makedefs.exe
X+ 	.\makedefs -t
X+ 
X+ $(INCL)\onames.h: makedefs.exe
X+ 	.\makedefs -o
X+ 
X+ $(INCL)\pm.h: makedefs.exe
X+ 	.\makedefs -p
X+ 
X+ data:	$(AUX)\data.base makedefs.exe
X+ 	.\makedefs -d
X+ 
X+ rumors: $(AUX)\rumors.tru $(AUX)\rumors.fal makedefs.exe
X+ 	.\makedefs -r
X+ 
X+ #
X+ #	The following programs vary depending on what OS you are using.
X+ #
X+ o\main.o:   $(HACK_H) $(TARG)main.c
X+ 	$(CC) $(CFLAGS) /Foo\main.o $(TARG)main.c
X+ 
X+ o\tty.o:   $(HACK_H) $(INCL)\func_tab.h $(TARG)tty.c
X+ 	$(CC) $(CFLAGS) /Foo\tty.o $(TARG)tty.c
X+ 
X+ o\unix.o:   $(HACK_H) $(TARG)unix.c
X+ 	$(CC) $(CFLAGS) /Foo\unix.o $(TARG)unix.c
X+ 
X+ #
X+ # Secondary targets
X+ #
X+ 
X+ auxil:	spec_levs
X+ 	xcopy $(AUX)\*. $(GAMEDIR)
X+ 
X+ spec_levs: $(AUX)\castle.des $(AUX)\endgame.des $(AUX)\tower.des
X+ 	lev_comp $(AUX)\castle.des
X+ 	lev_comp $(AUX)\endgame.des
X+ 	lev_comp $(AUX)\tower.des
X+ 	xcopy castle $(GAMEDIR)
X+ 	del castle
X+ 	xcopy endgame $(GAMEDIR)
X+ 	del endgame
X+ 	xcopy tower? $(GAMEDIR)
X+ 	del tower?
X+ 
X+ $(OS2DEFS):
X+ 	echo NAME $(GAME) WINDOWCOMPAT> $(OS2DEFS)
X+ 	echo DESCRIPTION 'NetHack 3.0'>> $(OS2DEFS)
X+ 	echo PROTMODE>> $(OS2DEFS)
X+ 	echo EXETYPE OS2>> $(OS2DEFS)
X+ 
X+ record: $(GAMEDIR)\record
X+ $(GAMEDIR)\record:
X+ 	echo foo> $(GAMEDIR)\record
X+ 
X+ clean:
X+ 	del o\*.obj
X+ 	rmdir o
X+ 
X+ spotless: clean
X+ 	del $(INCL)\date.h
X+ 	del $(INCL)\onames.h
X+ 	del $(INCL)\pm.h
X+ 	touch $(INCL)\date.h $(INCL)\onames.h $(INCL)\pm.h
X+ 	del makedefs.exe
X+ 	if exist lev_comp.exe del lev_comp.exe
X+ 
X+ #
X+ # Other dependencies
X+ #
X+ 
X+ # GO AHEAD, DELETE THIS LINE
X+ 
X+ o\alloc.o:  $(CONFIG_H)
X+ o\apply.o:  $(HACK_H) $(INCL)\edog.h
X+ o\artifact.o:  $(HACK_H) $(INCL)\artifact.h
X+ o\attrib.o:  $(HACK_H)
X+ o\bones.o:  $(HACK_H)
X+ o\cmd.o:  $(HACK_H) $(INCL)\func_tab.h
X+ o\dbridge.o: $(HACK_H)
X+ o\decl.o:  $(HACK_H)
X+ o\demon.o:  $(HACK_H)
X+ o\do.o:  $(HACK_H)
X+ o\do_name.o:  $(HACK_H)
X+ o\do_wear.o:  $(HACK_H)
X+ o\dog.o:  $(HACK_H) $(INCL)\edog.h
X+ o\dogmove.o:  $(HACK_H) $(INCL)\mfndpos.h $(INCL)\edog.h
X+ o\dokick.o:  $(HACK_H)
X+ o\dothrow.o:  $(HACK_H)
X+ o\eat.o:  $(HACK_H)
X+ o\end.o:  $(HACK_H) $(INCL)\eshk.h
X+ o\engrave.o:  $(HACK_H)
X+ o\exper.o:  $(HACK_H)
X+ o\extralev.o:  $(HACK_H)
X+ o\fountain.o:  $(HACK_H)
X+ o\getline.o:  $(HACK_H) $(INCL)\func_tab.h
X+ o\hack.o:  $(HACK_H)
X+ o\invent.o:  $(HACK_H) $(INCL)\lev.h $(INCL)\wseg.h
X+ o\ioctl.o:  $(HACK_H)
X+ o\lev_comp.o:  $(HACK_H) $(INCL)\sp_lev.h
X+ o\lock.o:  $(HACK_H)
X+ o\makemon.o:  $(HACK_H)
X+ o\mail.o:  $(HACK_H)
X+ o\mcastu.o:  $(HACK_H)
X+ o\mhitm.o:  $(HACK_H) $(INCL)\artifact.h
X+ o\mhitu.o:  $(HACK_H) $(INCL)\artifact.h $(INCL)\edog.h
X+ o\mklev.o:  $(HACK_H)
X+ o\mkmaze.o:  $(HACK_H)
X+ o\mkobj.o:  $(HACK_H)
X+ o\mkroom.o:  $(HACK_H)
X+ o\mon.o:  $(HACK_H) $(INCL)\mfndpos.h $(INCL)\artifact.h
X+ o\mondata.o:  $(HACK_H) $(INCL)\eshk.h $(INCL)\epri.h
X+ o\monmove.o:  $(HACK_H) $(INCL)\mfndpos.h $(INCL)\artifact.h
X+ o\monst.o:  $(CONFIG_H) $(PERMONST_H) $(INCL)\eshk.h $(INCL)\vault.h $(INCL)\epri.h
X+ o\msdos.o:  $(HACK_H)
X+ o\mthrowu.o:  $(HACK_H)
X+ o\music.o:  $(HACK_H)
X+ o\o_init.o:  $(HACK_H) $(INCL)\onames.h
X+ o\objects.o:  $(CONFIG_H) $(INCL)\obj.h $(INCL)\objclass.h $(INCL)\prop.h
X+ o\objnam.o:  $(HACK_H)
X+ o\options.o:  $(HACK_H)
X+ o\pager.o:  $(HACK_H)
X+ o\panic.o:  $(CONFIG_H)
X+ o\pickup.o:  $(HACK_H)
X+ o\polyself.o:  $(HACK_H)
X+ o\potion.o:  $(HACK_H)
X+ o\pray.o:  $(HACK_H)
X+ o\pri.o:  $(HACK_H)
X+ o\priest.o:  $(HACK_H) $(INCL)\mfndpos.h $(INCL)\eshk.h $(INCL)\epri.h
X+ o\prisym.o:  $(HACK_H) $(INCL)\lev.h $(INCL)\wseg.h
X+ o\random.o:
X+ o\read.o:  $(HACK_H)
X+ o\restore.o:  $(HACK_H) $(INCL)\lev.h $(INCL)\wseg.h
X+ o\rip.o:  $(HACK_H)
X+ o\rnd.o:  $(HACK_H)
X+ o\rumors.o:  $(HACK_H)
X+ o\save.o:  $(HACK_H) $(INCL)\lev.h $(INCL)\wseg.h
X+ o\search.o:  $(HACK_H) $(INCL)\artifact.h
X+ o\shk.o:  $(HACK_H) $(INCL)\eshk.h
X+ o\shknam.o:  $(HACK_H) $(INCL)\eshk.h
X+ o\sit.o:  $(HACK_H)
X+ o\sounds.o:  $(HACK_H) $(INCL)\edog.h $(INCL)\eshk.h
X+ o\sp_lev.o:  $(HACK_H) $(INCL)\sp_lev.h
X+ o\spell.o:  $(HACK_H)
X+ o\steal.o:  $(HACK_H)
X+ o\termcap.o:  $(HACK_H)
X+ o\timeout.o:  $(HACK_H)
X+ o\topl.o:  $(HACK_H)
X+ o\topten.o:  $(HACK_H)
X+ o\track.o:  $(HACK_H)
X+ o\trap.o:  $(HACK_H) $(INCL)\edog.h $(INCL)\trapname.h
X+ o\u_init.o:  $(HACK_H)
X+ o\uhitm.o:  $(HACK_H) $(INCL)\artifact.h
X+ o\vault.o:  $(HACK_H) $(INCL)\vault.h
X+ o\version.o:  $(HACK_H) $(INCL)\date.h
X+ o\weapon.o:  $(HACK_H)
X+ o\were.o:  $(HACK_H)
X+ o\wield.o:  $(HACK_H)
X+ o\wizard.o:  $(HACK_H)
X+ o\worm.o:  $(HACK_H) $(INCL)\wseg.h
X+ o\worn.o:  $(HACK_H)
X+ o\write.o:  $(HACK_H)
X+ o\zap.o:  $(HACK_H)
X*** /dev/null	Tue Aug 15 10:53:49 1989
X--- others/Makefile.msc	Tue Aug 15 20:51:09 1989
X***************
X*** 0 ****
X--- 1,322 ----
X+ #	SCCS Id: @(#)Makefile.msc	3.0	89/08/13
X+ #	PC NetHack 3.0 Makefile for Microsoft(tm) "C" 5.1 -- Paul Gyugyi
X+ #
X+ # Large memory model, register bug, remove stack probes:
X+ CC	= cl /c
X+ LINK	= link
X+ MODEL	= L
X+ 
X+ # Directories (makedefs hardcodes these, don't change them)
X+ INCL	= ..\include
X+ AUX	= ..\auxil
X+ SRC	= ..\src
X+ 
X+ # If you don't have a 286 or better, remove the /G2 in the line below.
X+ CFLAGS	= /A$(MODEL) /DLINT_ARGS /DDGK /Os /Oa /G2 /Gs /Gt28 /I$(INCL) /W0
X+ LFLAGS	= /noi /st:0x0aff /se:512
X+ TARG	= pc
X+ 
X+ .c.o:
X+ 	$(CC) $(CFLAGS) /Foo\$*.o $*.c 
X+ 
X+ # Optional high-quality BSD random number generation routines (see pcconf.h).
X+ # Set to nothing if not used.
X+ # RANDOM = o\random.o
X+ RANDOM =
X+ 
X+ # For NDMAKE, to handle the .o suffix.
X+ .SUFFIXES: .exe .o .c .y .l
X+ 
X+ # The game name
X+ GAME= nethack
X+ 
X+ # The game directory
X+ GAMEDIR = \games\$(GAME)
X+ 
X+ # The game filename
X+ GAMEFILE = $(GAMEDIR)\$(GAME).exe
X+ 
X+ # object files for makedefs
X+ MAKEOBJS = o\makedefs.o o\alloc.o o\monst.o o\objects.o o\panic.o
X+ 
X+ # object files for special levels compiler
X+ SPLEVOBJS = o\lev_comp.o o\lev_lex.o o\lev_main.o o\alloc.o o\monst.o o\objects.o o\panic.o
X+ 
X+ # nothing below this line should have to be changed
X+ #
X+ # other things that have to be reconfigured are in config.h,
X+ # {unixconf.h, pcconf.h, tosconf.h}, and possibly system.h
X+ 
X+ VOBJ =	o\alloc.o o\apply.o o\artifact.o o\attrib.o o\bones.o o\cmd.o \
X+ 	o\dbridge.o o\decl.o o\demon.o o\do.o o\do_name.o o\do_wear.o \
X+ 	o\dog.o o\dogmove.o o\dokick.o o\dothrow.o o\eat.o o\end.o o\engrave.o \
X+ 	o\exper.o o\extralev.o o\fountain.o o\getline.o o\hack.o o\invent.o \
X+ 	o\lock.o o\mail.o o\main.o o\makemon.o o\mcastu.o o\mhitm.o o\mhitu.o \
X+ 	o\mklev.o o\mkmaze.o o\mkobj.o o\mkroom.o o\mon.o o\mondata.o \
X+ 	o\msdos.o o\monmove.o o\monst.o o\mthrowu.o o\music.o o\o_init.o \
X+ 	o\objects.o o\objnam.o o\options.o o\pager.o o\pickup.o o\polyself.o \
X+ 	o\potion.o o\pray.o o\pri.o o\priest.o o\prisym.o $(RANDOM) o\read.o \
X+ 	o\restore.o o\rip.o o\rnd.o o\rumors.o o\save.o o\search.o o\shk.o \
X+ 	o\shknam.o o\sit.o o\sounds.o o\sp_lev.o o\spell.o o\steal.o \
X+ 	o\termcap.o o\timeout.o o\topl.o o\topten.o o\track.o o\trap.o \
X+ 	o\tty.o o\u_init.o o\uhitm.o o\unix.o o\vault.o o\weapon.o o\were.o \
X+ 	o\wield.o o\wizard.o o\worm.o o\worn.o o\write.o o\zap.o
X+ HOBJ =	$(VOBJ) o\version.o
X+ 
X+ PCCONF_H   = $(INCL)\$(TARG)conf.h $(INCL)\msdos.h $(INCL)\system.h \
X+ 	     $(INCL)\extern.h 
X+ GLOBAL_H   = $(INCL)\global.h $(INCL)\coord.h $(PCCONF_H)
X+ CONFIG_H   = $(INCL)\config.h $(INCL)\tradstdc.h $(GLOBAL_H)
X+ TRAP_H	   = $(INCL)\trap.h
X+ PERMONST_H = $(INCL)\permonst.h $(INCL)\monflag.h
X+ YOU_H	   = $(INCL)\you.h $(INCL)\attrib.h $(PERMONST_H) $(INCL)\mondata.h \
X+ 	     $(INCL)\monst.h $(INCL)\youprop.h
X+ DECL_H	   = $(INCL)\decl.h $(INCL)\spell.h $(INCL)\obj.h $(YOU_H) \
X+ 	     $(INCL)\onames.h $(INCL)\pm.h
X+ HACK_H	   = $(CONFIG_H) $(DECL_H) $(INCL)\monsym.h $(INCL)\mkroom.h \
X+ 	     $(INCL)\objclass.h $(INCL)\gold.h $(INCL)\trap.h $(INCL)\flag.h \
X+ 	     $(INCL)\rm.h
X+ 
X+ # The main target
X+ # NDMAKE automatically generates LINK response files
X+ $(GAMEDIR)\$(GAME).exe: $(HOBJ) ltermlib.lib
X+ 	$(LINK) $(HOBJ),nethack,nethack,$(SRC)\ltermlib $(LFLAGS)
X+ 
X+ 
X+ $(GAME): $(GAMEDIR)\$(GAME).exe
X+ $(GAME).exe: $(GAMEDIR)\$(GAME).exe
X+ 
X+ 
X+ # make ltermlib.lib -- replaces makefile in termcap.arc
X+ # unarc termcap.arc into src directory, but be careful that the
X+ # makefile in the archive does not overwrite this one
X+ TL_LSOURCES =	tgetent.c tgetflag.c tgetnum.c tgetstr.c tgoto.c tputs.c \
X+ 		isdigit.c fgetlr.c
X+ 
X+ TL_LOBJECTS =	o\tgetent.o o\tgetflag.o o\tgetnum.o o\tgetstr.o \
X+                 o\tgoto.o o\tputs.o o\isdigit.o o\fgetlr.o
X+ 
X+ ltermlib.lib :	$(TL_LOBJECTS)
X+ 		lib ltermlib.lib -+ $(TL_LOBJECTS);
X+ 
X+ .c.o:
X+ 	$(CC) $(CFLAGS) /Fo.\o\$*.o $*.c
X+ 
X+ all:	o lev_comp.exe $(GAME) auxil.tag install.tag
X+ 	@echo Done.
X+ 
X+ o:
X+ 	if not exist .\o\*.* mkdir o
X+ 
X+ makedefs.exe:	$(MAKEOBJS)
X+ 	$(LINK) $(LFLAGS) $(MAKEOBJS);
X+ 
X+ o\makedefs.o:  $(INCL)\config.h $(INCL)\permonst.h $(INCL)\objclass.h
X+ 
X+ lev_comp.exe:  $(SPLEVOBJS)
X+ 	$(LINK) $(LFLAGS) $(SPLEVOBJS),lev_comp.exe;
X+ 
X+ o\lev_comp.o:  $(HACK_H) $(INCL)\sp_lev.h
X+ o\lev_lex.o:  $(INCL)\lev_comp.h $(HACK_H) $(INCL)\sp_lev.h
X+ o\lev_main.o:  $(HACK_H) $(INCL)\sp_lev.h
X+ 
X+ # If you have yacc or lex programs, and make any changes,
X+ # add some .y.c and .l.c rules to your Make.ini.
X+ 
X+ lev_comp.c:  lev_comp.y
X+ lev_lex.c:  lev_comp.l
X+ 
X+ #
X+ #	The following include files depend on makedefs to be created.
X+ #
X+ #	date.h should be remade any time any of the source or include code
X+ #	is modified.
X+ #
X+ $(INCL)\date.h:	 $(VOBJ) makedefs.exe
X+ 	.\makedefs -v
X+ 
X+ $(INCL)\trap.h:	 makedefs.exe
X+ 	.\makedefs -t
X+ 
X+ $(INCL)\onames.h:  makedefs.exe
X+ 	.\makedefs -o
X+ 
X+ $(INCL)\pm.h:  makedefs.exe
X+ 	.\makedefs -p
X+ 
X+ data:	$(AUX)\data.base makedefs.exe
X+ 	.\makedefs -d
X+ 
X+ rumors: $(AUX)\rumors.tru $(AUX)\rumors.fal makedefs.exe
X+ 	.\makedefs -r
X+ 
X+ #
X+ #	The following programs vary depending on what OS you are using.
X+ #
X+ o\main.o:   $(HACK_H) $(TARG)main.c
X+ 	$(CC) $(CFLAGS)  /Fo.\o\main.o $(TARG)main.c
X+ 
X+ o\tty.o:   $(HACK_H) $(INCL)\func_tab.h $(TARG)tty.c
X+ 	$(CC) $(CFLAGS)  /Fo.\o\tty.o $(TARG)tty.c
X+ 
X+ o\unix.o:   $(HACK_H) $(TARG)unix.c
X+ 	$(CC) $(CFLAGS)  /Fo.\o\unix.o $(TARG)unix.c
X+ 
X+ #
X+ # Secondary targets
X+ #
X+ 
X+ auxil.tag:	spec_levs.tag data rumors termcap
X+ # the tag file is a dummy file to keep from redoing this every make
X+         echo special levels created > auxil.tag
X+ 
X+ install.tag:
X+ # always done
X+ # assume \games exists already, but make it just to make sure
X+         md \games
X+         md $(GAMEDIR)
X+         md $(GAMEDIR)\bones
X+         echo y>yes.txt
X+ #
X+ #       Watch Out!  The next command cleans out the game & bones dirs!
X+ #       This will delete any config file you have and overwrite it
X+ #       with the default.
X+ #       Since the game options may have changed since your last install, 
X+ #       you should say yes to clean the directory.
X+ #
X+         del $(GAMEDIR)\*.* < yes.txt
X+         del $(GAMEDIR)\bones\*.* < yes.txt
X+         copy termcap     $(GAMEDIR)\termcap
X+         copy castle      $(GAMEDIR)
X+ 	copy endgame     $(GAMEDIR)
X+ 	copy tower?      $(GAMEDIR)
X+         copy $(GAME).exe $(GAMEDIR)
X+ 	copy $(AUX)\*.   $(GAMEDIR)
X+         copy nethack.cnf $(GAMEDIR)
X+         echo record >    $(GAMEDIR)\record
X+         echo install done >install.tag
X+ 
X+ 
X+ spec_levs.tag: lev_comp.exe $(AUX)\castle.des $(AUX)\endgame.des $(AUX)\tower.des
X+ 	lev_comp $(AUX)\castle.des
X+ 	lev_comp $(AUX)\endgame.des
X+ 	lev_comp $(AUX)\tower.des
X+         echo spec_lev done >spec_levs.tag
X+ 
X+ clean:
X+ 	del o\*.o
X+ 	rmdir o
X+ 
X+ spotless: clean
X+ 	cd $(INCL)
X+ 	del date.h
X+ 	del onames.h
X+ 	del pm.h
X+ 	cd $(SRC)
X+ 	del makedefs.exe
X+ 	del lev_comp.exe
X+         del $(AUX)\data
X+         del $(AUX)\rumors
X+         del castle
X+         del endgame
X+         del tower?
X+         del *.tag
X+         del $(GAME).exe
X+         del $(GAME).map
X+ 
X+ #
X+ # Other dependencies
X+ #
X+ 
X+ # GO AHEAD, DELETE THIS LINE
X+ 
X+ o\alloc.o:  $(CONFIG_H)
X+ o\apply.o:  $(HACK_H) $(INCL)\edog.h
X+ o\artifact.o:  $(HACK_H) $(INCL)\artifact.h
X+ o\attrib.o:  $(HACK_H)
X+ o\bones.o:  $(HACK_H)
X+ o\cmd.o:  $(HACK_H) $(INCL)\func_tab.h
X+ o\dbridge.o: $(HACK_H)
X+ o\decl.o:  $(HACK_H)
X+ o\demon.o:  $(HACK_H)
X+ o\do.o:  $(HACK_H)
X+ o\do_name.o:  $(HACK_H)
X+ o\do_wear.o:  $(HACK_H)
X+ o\dog.o:  $(HACK_H) $(INCL)\edog.h
X+ o\dogmove.o:  $(HACK_H) $(INCL)\mfndpos.h $(INCL)\edog.h
X+ o\dokick.o:  $(HACK_H)
X+ o\dothrow.o:  $(HACK_H)
X+ o\eat.o:  $(HACK_H)
X+ o\end.o:  $(HACK_H) $(INCL)\eshk.h
X+ o\engrave.o:  $(HACK_H)
X+ o\exper.o:  $(HACK_H)
X+ o\extralev.o:  $(HACK_H)
X+ o\fountain.o:  $(HACK_H)
X+ o\getline.o:  $(HACK_H) $(INCL)\func_tab.h
X+ o\hack.o:  $(HACK_H)
X+ o\invent.o:  $(HACK_H) $(INCL)\lev.h $(INCL)\wseg.h
X+ o\ioctl.o:  $(HACK_H)
X+ o\lev_comp.o:  $(HACK_H) $(INCL)\sp_lev.h
X+ o\lock.o:  $(HACK_H)
X+ o\makemon.o:  $(HACK_H)
X+ o\mail.o:  $(HACK_H)
X+ o\mcastu.o:  $(HACK_H)
X+ o\mhitm.o:  $(HACK_H) $(INCL)\artifact.h
X+ o\mhitu.o:  $(HACK_H) $(INCL)\artifact.h $(INCL)\edog.h
X+ o\mklev.o:  $(HACK_H)
X+ o\mkmaze.o:  $(HACK_H)
X+ o\mkobj.o:  $(HACK_H)
X+ o\mkroom.o:  $(HACK_H)
X+ o\mon.o:  $(HACK_H) $(INCL)\mfndpos.h $(INCL)\artifact.h
X+ o\mondata.o:  $(HACK_H) $(INCL)\eshk.h $(INCL)\epri.h
X+ o\monmove.o:  $(HACK_H) $(INCL)\mfndpos.h $(INCL)\artifact.h
X+ o\monst.o:  $(CONFIG_H) $(PERMONST_H) $(INCL)\eshk.h $(INCL)\vault.h $(INCL)\epri.h
X+ o\msdos.o:  $(HACK_H)
X+ o\mthrowu.o:  $(HACK_H)
X+ o\music.o:  $(HACK_H)
X+ o\o_init.o:  $(HACK_H) $(INCL)\onames.h
X+ o\objects.o:  $(CONFIG_H) $(INCL)\obj.h $(INCL)\objclass.h $(INCL)\prop.h
X+ o\objnam.o:  $(HACK_H)
X+ o\options.o:  $(HACK_H)
X+ o\pager.o:  $(HACK_H)
X+ o\panic.o:  $(CONFIG_H)
X+ o\pickup.o:  $(HACK_H)
X+ o\polyself.o:  $(HACK_H)
X+ o\potion.o:  $(HACK_H)
X+ o\pray.o:  $(HACK_H)
X+ o\pri.o:  $(HACK_H)
X+ o\priest.o:  $(HACK_H) $(INCL)\mfndpos.h $(INCL)\eshk.h $(INCL)\epri.h
X+ o\prisym.o:  $(HACK_H) $(INCL)\lev.h $(INCL)\wseg.h
X+ o\random.o:
X+ o\read.o:  $(HACK_H)
X+ o\restore.o:  $(HACK_H) $(INCL)\lev.h $(INCL)\wseg.h
X+ o\rip.o:  $(HACK_H)
X+ o\rnd.o:  $(HACK_H)
X+ o\rumors.o:  $(HACK_H)
X+ o\save.o:  $(HACK_H) $(INCL)\lev.h $(INCL)\wseg.h
X+ o\search.o:  $(HACK_H) $(INCL)\artifact.h
X+ o\shk.o:  $(HACK_H) $(INCL)\eshk.h
X+ o\shknam.o:  $(HACK_H) $(INCL)\eshk.h
X+ o\sit.o:  $(HACK_H)
X+ o\sounds.o:  $(HACK_H) $(INCL)\edog.h $(INCL)\eshk.h
X+ o\sp_lev.o:  $(HACK_H) $(INCL)\sp_lev.h
X+ o\spell.o:  $(HACK_H)
X+ o\steal.o:  $(HACK_H)
X+ o\termcap.o:  $(HACK_H)
X+ o\timeout.o:  $(HACK_H)
X+ o\topl.o:  $(HACK_H)
X+ o\topten.o:  $(HACK_H)
X+ o\track.o:  $(HACK_H)
X+ o\trap.o:  $(HACK_H) $(INCL)\edog.h $(INCL)\trapname.h
X+ o\u_init.o:  $(HACK_H)
X+ o\uhitm.o:  $(HACK_H) $(INCL)\artifact.h
X+ o\vault.o:  $(HACK_H) $(INCL)\vault.h
X+ o\version.o:  $(HACK_H) $(INCL)\date.h
X+ o\weapon.o:  $(HACK_H)
X+ o\were.o:  $(HACK_H)
X+ o\wield.o:  $(HACK_H)
X+ o\wizard.o:  $(HACK_H)
X+ o\worm.o:  $(HACK_H) $(INCL)\wseg.h
X+ o\worn.o:  $(HACK_H)
X+ o\write.o:  $(HACK_H)
X+ o\zap.o:  $(HACK_H)
END_OF_FILE
echo shar: 2 control characters may be missing from \"'patch02b'\"
if test 52490 -ne `wc -c <'patch02b'`; then
    echo shar: \"'patch02b'\" unpacked with wrong size!
fi
# end of 'patch02b'
fi
echo shar: End of archive 2 \(of 7\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 3 4 5 6 7 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 7 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
