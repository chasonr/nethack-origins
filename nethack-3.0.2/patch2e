Path: utzoo!utgpu!jarvis.csri.toronto.edu!mailrus!tut.cis.ohio-state.edu!gem.mps.ohio-state.edu!ginosko!uunet!zephyr.ens.tek.com!tekgen!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v08i010:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Patch2e
Message-ID: <4462@tekred.CNA.TEK.COM>
Date: 18 Aug 89 15:50:19 GMT
Sender: nobody@tekred.CNA.TEK.COM
Lines: 2209
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 8, Issue 10
Archive-name: NetHack3/Patch2e
Patch-To: NetHack3: Volume 7, Issue 56-93



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 5 (of 7)."
# Contents:  patch02e
# Wrapped by billr@saab on Fri Aug 18 08:35:58 1989
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'patch02e' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'patch02e'\"
else
echo shar: Extracting \"'patch02e'\" \(54587 characters\)
sed "s/^X//" >'patch02e' <<'END_OF_FILE'
X*** src/Old/mhitu.c	Wed Aug 16 12:26:05 1989
X--- src/mhitu.c	Tue Aug 15 20:34:37 1989
X***************
X*** 20,71 ****
X  static int explmu P((struct monst *,struct attack *));
X  static int gazemu P((struct monst *,struct attack *));
X  
X- #ifdef POLYSELF
X- boolean
X- /* also needed in uhitm.c */
X- #else
X- static boolean
X- #endif
X- incompatible(mon)
X- register struct monst *mon;
X- {
X- 	return(poly_gender() != 1-gender(mon));
X- }
X- 
X- boolean
X- is_nymph(mon)
X- register struct monst *mon;
X- {
X- 	return( mon->data->mlet == S_NYMPH );
X- }
X  
X- boolean
X- sp_melee(mon)
X- register struct monst *mon;
X- {
X- 	return(
X- #ifdef SEDUCE
X- 		(mon->data == &mons[PM_SUCCUBUS] && !mon->minvis) ||
X- 		(mon->data == &mons[PM_INCUBUS] && !mon->minvis) ||
X- #endif
X- 		is_nymph(mon));
X- }
X- 
X  static void
X! hitmsg(mtmp, attyp)
X  register struct monst *mtmp;
X! register uchar attyp;
X  {
X  	/* Note: if opposite gender, "seductively" */
X  	/* If same gender, "engagingly" for nymph, normal msg for others */
X! 	if(sp_melee(mtmp) && !mtmp->mcan && !mtmp->mspec_used) {
X! 		if(!is_nymph(mtmp) && incompatible(mtmp)) goto strike;
X  	    	kludge("%s %s you %s.", Monnam(mtmp),
X  			Blind ? "talks to" : "smiles at",
X! 			incompatible(mtmp) ? "engagingly" : "seductively");
X  	} else
X! strike:
X! 	    switch (attyp) {
X  		case AT_BITE:
X  			kludge("%s bites!", Monnam(mtmp));
X  			break;
X--- 20,42 ----
X  static int explmu P((struct monst *,struct attack *));
X  static int gazemu P((struct monst *,struct attack *));
X  
X  
X  static void
X! hitmsg(mtmp, mattk)
X  register struct monst *mtmp;
X! register struct attack *mattk;
X  {
X+ 	int compat;
X+ 
X  	/* Note: if opposite gender, "seductively" */
X  	/* If same gender, "engagingly" for nymph, normal msg for others */
X! 	if((compat = could_seduce(mtmp, &youmonst, mattk))
X! 			&& !mtmp->mcan && !mtmp->mspec_used) {
X  	    	kludge("%s %s you %s.", Monnam(mtmp),
X  			Blind ? "talks to" : "smiles at",
X! 			compat == 2 ? "engagingly" : "seductively");
X  	} else
X! 	    switch (mattk->aatyp) {
X  		case AT_BITE:
X  			kludge("%s bites!", Monnam(mtmp));
X  			break;
X***************
X*** 91,105 ****
X  }
X  
X  static void
X! missmu(mtmp, nearmiss)		/* monster missed you */
X  register struct monst *mtmp;
X  register boolean nearmiss;
X  {
X! 	if(sp_melee(mtmp) && !mtmp->mcan) {
X! 	    if(!is_nymph(mtmp) && incompatible(mtmp)) goto strike;
X  	    kludge("%s pretends to be friendly.", Monnam(mtmp));
X! 	} else {
X! strike:
X  	    if (!flags.verbose || !nearmiss)
X  		kludge("%s misses.", Monnam(mtmp));
X  	    else
X--- 62,75 ----
X  }
X  
X  static void
X! missmu(mtmp, nearmiss, mattk)		/* monster missed you */
X  register struct monst *mtmp;
X  register boolean nearmiss;
X+ register struct attack *mattk;
X  {
X! 	if(could_seduce(mtmp, &youmonst, mattk) && !mtmp->mcan)
X  	    kludge("%s pretends to be friendly.", Monnam(mtmp));
X! 	else {
X  	    if (!flags.verbose || !nearmiss)
X  		kludge("%s misses.", Monnam(mtmp));
X  	    else
X***************
X*** 127,141 ****
X  wildmiss(mtmp)		/* monster attacked your displaced image */
X  	register struct monst *mtmp;
X  {
X  	if (!flags.verbose) return;
X  	if (!cansee(mtmp->mx, mtmp->my)) return;
X  		/* maybe it's attacking an image around the corner? */
X  	if(Invis && !perceives(mtmp->data)) {
X! 	    if(sp_melee(mtmp) && !mtmp->mcan) {
X! 		if(!is_nymph(mtmp) && incompatible(mtmp)) goto strike;
X  		kludge("%s tries to touch you and misses!", Monnam(mtmp));
X! 	    } else
X! strike:
X  		switch(rn2(3)) {
X  		case 0: kludge("%s swings wildly and misses!", Monnam(mtmp));
X  		    break;
X--- 97,119 ----
X  wildmiss(mtmp)		/* monster attacked your displaced image */
X  	register struct monst *mtmp;
X  {
X+ 	int compat;
X+ 
X  	if (!flags.verbose) return;
X  	if (!cansee(mtmp->mx, mtmp->my)) return;
X  		/* maybe it's attacking an image around the corner? */
X+ 
X+ 	compat = could_seduce(mtmp, &youmonst, (struct attack *)0);
X+ 		/* we really want to have the attack here to pass --
X+ 		 * the previous code checked whether mtmp was a nymph,
X+ 		 * which was not correct either since the attack type of
X+ 		 * succubi/incubi varies with SEDUCE
X+ 		 */
X+ 
X  	if(Invis && !perceives(mtmp->data)) {
X! 	    if(compat)
X  		kludge("%s tries to touch you and misses!", Monnam(mtmp));
X! 	    else
X  		switch(rn2(3)) {
X  		case 0: kludge("%s swings wildly and misses!", Monnam(mtmp));
X  		    break;
X***************
X*** 148,161 ****
X  		}
X  	}
X  	else if(Displaced) {
X! 	    if(sp_melee(mtmp) && !mtmp->mcan) {
X! 		if(!is_nymph(mtmp) && incompatible(mtmp)) goto strikem;
X  		kludge("%s smiles %s at your %sdisplaced image...",
X  			Monnam(mtmp),
X! 			incompatible(mtmp) ? "engagingly" : "seductively",
X  			Invis ? "invisible " : "");
X! 	   } else
X! strikem:
X  		kludge("%s strikes at your %sdisplaced image and misses you!",
X  			/* Note: if you're both invisible and displaced,
X  			 * only monsters which see invisible will attack your
X--- 126,137 ----
X  		}
X  	}
X  	else if(Displaced) {
X! 	    if(compat)
X  		kludge("%s smiles %s at your %sdisplaced image...",
X  			Monnam(mtmp),
X! 			compat == 2 ? "engagingly" : "seductively",
X  			Invis ? "invisible " : "");
X! 	   else
X  		kludge("%s strikes at your %sdisplaced image and misses you!",
X  			/* Note: if you're both invisible and displaced,
X  			 * only monsters which see invisible will attack your
X***************
X*** 338,343 ****
X--- 314,320 ----
X  
X  	for(i = 0; i < NATTK; i++) {
X  
X+ 	    sum[i] = 0;
X  	    mattk = &(mdat->mattk[i]);
X  	    switch(mattk->aatyp) {
X  		case AT_CLAW:	/* "hand to hand" attacks */
X***************
X*** 347,395 ****
X  		case AT_TUCH:
X  		case AT_BUTT:
X  			if(!range2) {
X! 			    if (!foundyou) {
X! 				wildmiss(mtmp);
X! 				sum[i] = 0;
X! 			    } else if(tmp > (j = rnd(20+i)))
X  #ifdef POLYSELF
X! 				if (mattk->aatyp == AT_KICK &&
X! 					thick_skinned(uasmon)) sum[i] = 0;
X! 			        else
X  #endif
X  					sum[i] = hitmu(mtmp, mattk);
X! 			    else {
X! 				missmu(mtmp, (tmp == j));
X! 				sum[i] = 0;
X! 			    }
X! 			} else	sum[i] = 0;
X  			break;
X  
X  		case AT_HUGS:	/* automatic if prev two attacks succeed */
X  			/* Note: if displaced, prev attacks never succeeded */
X! 			if(!range2) {
X! 			    if(sum[i-1] && sum[i-2])
X  				sum[i]= hitmu(mtmp, mattk);
X- 			    else sum[i] = 0;
X- 			} else	 sum[i] = 0;
X  			break;
X  
X  		case AT_GAZE:	/* can affect you either ranged or not */
X! 			if (!youseeit) sum[i] = 0;
X! 			    /* Displaced and around a corner so not visible */
X! 			else sum[i] = gazemu(mtmp, mattk);
X  			break;
X  
X  		case AT_EXPL:	/* automatic hit if next to, and aimed at you */
X  			if(!range2) {
X! 			    if (!foundyou) {
X  				if (!mtmp->mcan) {
X  				    pline("%s explodes at a spot in thin air!",
X  					youseeit ? Monnam(mtmp) : "It");
X  				    mondead(mtmp);
X  				    sum[i] = 2;
X! 				} else sum[i] = 0;
X! 			    } else    sum[i] = explmu(mtmp, mattk);
X! 			} else sum[i] = 0;
X  			break;
X  
X  		case AT_ENGL:
X--- 324,368 ----
X  		case AT_TUCH:
X  		case AT_BUTT:
X  			if(!range2) {
X! 			    if (foundyou) {
X! 				if(tmp > (j = rnd(20+i))) {
X  #ifdef POLYSELF
X! 				    if (mattk->aatyp != AT_KICK ||
X! 					    !thick_skinned(uasmon))
X  #endif
X  					sum[i] = hitmu(mtmp, mattk);
X! 				} else
X! 				    missmu(mtmp, (tmp == j), mattk);
X! 			    } else
X! 				wildmiss(mtmp);
X! 			}
X  			break;
X  
X  		case AT_HUGS:	/* automatic if prev two attacks succeed */
X  			/* Note: if displaced, prev attacks never succeeded */
X! 			if(!range2 && sum[i-1] && sum[i-2])
X  				sum[i]= hitmu(mtmp, mattk);
X  			break;
X  
X  		case AT_GAZE:	/* can affect you either ranged or not */
X! 			if (youseeit)
X! 			    /* not displaced around a corner so not visible */
X! 			    sum[i] = gazemu(mtmp, mattk);
X  			break;
X  
X  		case AT_EXPL:	/* automatic hit if next to, and aimed at you */
X  			if(!range2) {
X! 			    if (foundyou)
X! 				sum[i] = explmu(mtmp, mattk);
X! 			    else {
X  				if (!mtmp->mcan) {
X  				    pline("%s explodes at a spot in thin air!",
X  					youseeit ? Monnam(mtmp) : "It");
X  				    mondead(mtmp);
X  				    sum[i] = 2;
X! 				}
X! 			    }
X! 			}
X  			break;
X  
X  		case AT_ENGL:
X***************
X*** 402,423 ****
X  				    nscr();
X  				    sum[i] = gulpmu(mtmp, mattk);
X  				} else {
X! 				    missmu(mtmp, (tmp == j));
X! 				    sum[i] = 0;
X  				}
X  			    } else pline("%s gulps some air!", youseeit ?
X  				Monnam(mtmp) : "It");
X! 			} else	sum[i] = 0;
X  			break;
X  		case AT_BREA:
X  			if(range2) sum[i] = breamu(mtmp, mattk);
X  			/* Note: breamu takes care of displacement */
X- 			else	   sum[i] = 0;
X  			break;
X  		case AT_SPIT:
X  			if(range2) sum[i] = spitmu(mtmp);
X  			/* Note: spitmu takes care of displacement */
X- 			else	   sum[i] = 0;
X  			break;
X  		case AT_WEAP:
X  			if(range2) {
X--- 375,393 ----
X  				    nscr();
X  				    sum[i] = gulpmu(mtmp, mattk);
X  				} else {
X! 				    missmu(mtmp, (tmp == j), mattk);
X  				}
X  			    } else pline("%s gulps some air!", youseeit ?
X  				Monnam(mtmp) : "It");
X! 			}
X  			break;
X  		case AT_BREA:
X  			if(range2) sum[i] = breamu(mtmp, mattk);
X  			/* Note: breamu takes care of displacement */
X  			break;
X  		case AT_SPIT:
X  			if(range2) sum[i] = spitmu(mtmp);
X  			/* Note: spitmu takes care of displacement */
X  			break;
X  		case AT_WEAP:
X  			if(range2) {
X***************
X*** 425,435 ****
X  				if (dlevel != rogue_level)
X  #endif
X  					sum[i] = thrwmu(mtmp);
X! 			} else {
X! 			    if (!foundyou) {
X! 				wildmiss(mtmp);
X! 				sum[i] = 0;
X! 			    } else {
X  				set_uasmon();
X  				otmp = select_hwep(mtmp);
X  				if(otmp) {
X--- 395,402 ----
X  				if (dlevel != rogue_level)
X  #endif
X  					sum[i] = thrwmu(mtmp);
X! 			} else
X! 			    if (foundyou) {
X  				set_uasmon();
X  				otmp = select_hwep(mtmp);
X  				if(otmp) {
X***************
X*** 438,456 ****
X  				}
X  				if(tmp > (j = rnd(20+i)))
X  				    sum[i] = hitmu(mtmp, mattk);
X! 				else {
X! 				    missmu(mtmp, (tmp == j));
X! 				    sum[i] = 0;
X! 				}
X! 			    }
X! 			}
X  			break;
X  		case AT_MAGC:
X! 			if(!range2) {
X! 			    if (!foundyou) {
X  				pline("%s casts a spell at thin air!",
X  					youseeit ? Monnam(mtmp) : "It");
X- 				sum[i] = 0;
X  				/* Not totally right since castmu allows other
X  				 * spells, such as the monster healing itself,
X  				 * that should work even when not next to you--
X--- 405,424 ----
X  				}
X  				if(tmp > (j = rnd(20+i)))
X  				    sum[i] = hitmu(mtmp, mattk);
X! 				else
X! 				    missmu(mtmp, (tmp == j), mattk);
X! 			    } else
X! 				wildmiss(mtmp);
X  			break;
X  		case AT_MAGC:
X! 			if (range2)
X! 			    sum[i] = buzzmu(mtmp, mattk);
X! 			else
X! 			    if (foundyou)
X! 				sum[i] = castmu(mtmp, mattk);
X! 			    else
X  				pline("%s casts a spell at thin air!",
X  					youseeit ? Monnam(mtmp) : "It");
X  				/* Not totally right since castmu allows other
X  				 * spells, such as the monster healing itself,
X  				 * that should work even when not next to you--
X***************
X*** 457,472 ****
X  				 * but the previous code was just as wrong.
X  				 * --KAA
X  				 */
X- 			    } else sum[i] = castmu(mtmp, mattk);
X- 			} else	sum[i] = buzzmu(mtmp, mattk);
X  			break;
X  
X  		default:		/* no attack */
X- 			sum[i] = 0;
X  			break;
X  	    }
X  	    if(flags.botl) bot();
X  	    if(sum[i] == 2)  return(1);  	/* attacker dead */
X  	}
X  	return(0);
X  }
X--- 425,440 ----
X  				 * but the previous code was just as wrong.
X  				 * --KAA
X  				 */
X  			break;
X  
X  		default:		/* no attack */
X  			break;
X  	    }
X  	    if(flags.botl) bot();
X  	    if(sum[i] == 2)  return(1);  	/* attacker dead */
X+ 	    if(sum[i] == 3) break;  /* attacker teleported, no more attacks */
X+ 	    /* sum[i] == 1: successful attack */
X+ 	    /* sum[i] == 0: unsuccessful attack */
X  	}
X  	return(0);
X  }
X***************
X*** 473,479 ****
X  
X  /*
X   * hitmu: monster hits you
X!  *	  returns 2 if monster dies (e.g. "yellow light"), 0 otherwise
X   */
X  static
X  int
X--- 441,448 ----
X  
X  /*
X   * hitmu: monster hits you
X!  *	  returns 2 if monster dies (e.g. "yellow light"), 1 otherwise
X!  *	  3 if the monster lives but teleported, so it can't keep attacking you
X   */
X  static
X  int
X***************
X*** 541,547 ****
X  			      "crushed");
X  
X  		} else {			  /* hand to hand weapon */
X! 		    hitmsg(mtmp,mattk->aatyp);
X  		    if(mattk->aatyp == AT_WEAP && otmp) {
X  			dmg += dmgval(otmp, uasmon);
X  			if (dmg <= 0) dmg = 1;
X--- 510,516 ----
X  			      "crushed");
X  
X  		} else {			  /* hand to hand weapon */
X! 		    hitmsg(mtmp, mattk);
X  		    if(mattk->aatyp == AT_WEAP && otmp) {
X  			dmg += dmgval(otmp, uasmon);
X  			if (dmg <= 0) dmg = 1;
X***************
X*** 551,559 ****
X  						&& !resists_drli(uasmon)
X  #  endif
X  									) {
X  				pline("The %s blade drains your life!",
X  					Hallucination ? hcolor() : black);
X! 				losexp();
X  			}
X  #endif
X  #ifdef POLYSELF
X--- 520,531 ----
X  						&& !resists_drli(uasmon)
X  #  endif
X  									) {
X+ 			    if (Blind)
X+ 				You("feel an unholy blade drain your life!");
X+ 			    else
X  				pline("The %s blade drains your life!",
X  					Hallucination ? hcolor() : black);
X! 			    losexp();
X  			}
X  #endif
X  #ifdef POLYSELF
X***************
X*** 577,589 ****
X  		}
X  		break;
X  	    case AD_DISE:
X! 		hitmsg(mtmp, mattk->aatyp);
X  		You("feel very sick.");
X  		make_sick((long)rn1(25-ACURR(A_CON),15),FALSE);
X  		u.usick_cause = mdat->mname;
X  		break;
X  	    case AD_FIRE:
X! 		hitmsg(mtmp,mattk->aatyp);
X  		if(ctmp && rn2(2)) {
X  		    pline("You're on fire!");
X  		    if (Fire_resistance) {
X--- 549,561 ----
X  		}
X  		break;
X  	    case AD_DISE:
X! 		hitmsg(mtmp, mattk);
X  		You("feel very sick.");
X  		make_sick((long)rn1(25-ACURR(A_CON),15),FALSE);
X  		u.usick_cause = mdat->mname;
X  		break;
X  	    case AD_FIRE:
X! 		hitmsg(mtmp, mattk);
X  		if(ctmp && rn2(2)) {
X  		    pline("You're on fire!");
X  		    if (Fire_resistance) {
X***************
X*** 601,607 ****
X  		}
X  		break;
X  	    case AD_COLD:
X! 		hitmsg(mtmp,mattk->aatyp);
X  		if(ctmp && rn2(2)) {
X  		    pline("You're covered in frost!");
X  		    if (Cold_resistance) {
X--- 573,579 ----
X  		}
X  		break;
X  	    case AD_COLD:
X! 		hitmsg(mtmp, mattk);
X  		if(ctmp && rn2(2)) {
X  		    pline("You're covered in frost!");
X  		    if (Cold_resistance) {
X***************
X*** 613,619 ****
X  		}
X  		break;
X  	    case AD_ELEC:
X! 		hitmsg(mtmp,mattk->aatyp);
X  		if(ctmp && rn2(2)) {
X  		    You("get zapped!");
X  		    if (Shock_resistance) {
X--- 585,591 ----
X  		}
X  		break;
X  	    case AD_ELEC:
X! 		hitmsg(mtmp, mattk);
X  		if(ctmp && rn2(2)) {
X  		    You("get zapped!");
X  		    if (Shock_resistance) {
X***************
X*** 627,633 ****
X  		}
X  		break;
X  	    case AD_SLEE:
X! 		hitmsg(mtmp,mattk->aatyp);
X  		if(ctmp && multi >= 0 && !rn2(5)) {
X  		    if (Sleep_resistance) break;
X  		    nomul(-rnd(10));
X--- 599,605 ----
X  		}
X  		break;
X  	    case AD_SLEE:
X! 		hitmsg(mtmp, mattk);
X  		if(ctmp && multi >= 0 && !rn2(5)) {
X  		    if (Sleep_resistance) break;
X  		    nomul(-rnd(10));
X***************
X*** 644,650 ****
X  	    case AD_DRCO:
X  		ptmp = A_CON;
X  dopois:
X! 		hitmsg(mtmp,mattk->aatyp);
X  		if(ctmp && !rn2(8)) {
X  			Sprintf(buf, "%s's %s",
X  				Hallucination ? rndmonnam() : mdat->mname,
X--- 616,622 ----
X  	    case AD_DRCO:
X  		ptmp = A_CON;
X  dopois:
X! 		hitmsg(mtmp, mattk);
X  		if(ctmp && !rn2(8)) {
X  			Sprintf(buf, "%s's %s",
X  				Hallucination ? rndmonnam() : mdat->mname,
X***************
X*** 653,659 ****
X  		}
X  		break;
X  	    case AD_PLYS:
X! 		hitmsg(mtmp, mattk->aatyp);
X  		if(ctmp && multi >= 0 && !rn2(3)) {
X  		    if (Blind)	You("are frozen!");
X  		    else	You("are frozen by %s!", mon_nam(mtmp));
X--- 625,631 ----
X  		}
X  		break;
X  	    case AD_PLYS:
X! 		hitmsg(mtmp, mattk);
X  		if(ctmp && multi >= 0 && !rn2(3)) {
X  		    if (Blind)	You("are frozen!");
X  		    else	You("are frozen by %s!", mon_nam(mtmp));
X***************
X*** 661,667 ****
X  		}
X  		break;
X  	    case AD_DRLI:
X! 		hitmsg(mtmp, mattk->aatyp);
X  		if (ctmp && !rn2(3)
X  #ifdef POLYSELF
X  		    && !resists_drli(uasmon)
X--- 633,639 ----
X  		}
X  		break;
X  	    case AD_DRLI:
X! 		hitmsg(mtmp, mattk);
X  		if (ctmp && !rn2(3)
X  #ifdef POLYSELF
X  		    && !resists_drli(uasmon)
X***************
X*** 674,689 ****
X  	    case AD_LEGS:
X  		{ register long side = rn2(2) ? RIGHT_SIDE : LEFT_SIDE;
X  		  if (mtmp->mcan) {
X! 		    pline("%s nuzzles against your %s %s!", Monnam(mtmp),
X  			  (side == RIGHT_SIDE) ? "right" : "left",
X  			  body_part(LEG));
X  		  } else {
X  		    if (uarmf) {
X! 			pline("%s scratches your %s boot!", Monnam(mtmp),
X  				(side == RIGHT_SIDE) ? "right" : "left");
X  			break;
X  		    }
X! 		    pline("%s pricks your %s %s!", Monnam(mtmp),
X  			  (side == RIGHT_SIDE) ? "right" : "left",
X  			  body_part(LEG));
X  		    set_wounded_legs(side, rnd(60-ACURR(A_DEX)));
X--- 646,661 ----
X  	    case AD_LEGS:
X  		{ register long side = rn2(2) ? RIGHT_SIDE : LEFT_SIDE;
X  		  if (mtmp->mcan) {
X! 		    kludge("%s nuzzles against your %s %s!", Monnam(mtmp),
X  			  (side == RIGHT_SIDE) ? "right" : "left",
X  			  body_part(LEG));
X  		  } else {
X  		    if (uarmf) {
X! 			kludge("%s scratches your %s boot!", Monnam(mtmp),
X  				(side == RIGHT_SIDE) ? "right" : "left");
X  			break;
X  		    }
X! 		    kludge("%s pricks your %s %s!", Monnam(mtmp),
X  			  (side == RIGHT_SIDE) ? "right" : "left",
X  			  body_part(LEG));
X  		    set_wounded_legs(side, rnd(60-ACURR(A_DEX)));
X***************
X*** 691,704 ****
X  		  break;
X  		}
X  	    case AD_STON:	/* at present only a cockatrice */
X! 		hitmsg(mtmp,mattk->aatyp);
X  		if(!rn2(3) && !Stoned) {
X  		    if (mtmp->mcan) {
X  			if (flags.soundok)
X! 			    You("hear a cough from %s!", mon_nam(mtmp));
X  		    } else {
X  			if (flags.soundok)
X! 			    You("hear %s's hissing!", mon_nam(mtmp));
X  			if((!rn2(10) ||
X  			    (flags.moonphase == NEW_MOON &&
X  			     !carrying(DEAD_LIZARD)))
X--- 663,678 ----
X  		  break;
X  		}
X  	    case AD_STON:	/* at present only a cockatrice */
X! 		hitmsg(mtmp, mattk);
X  		if(!rn2(3) && !Stoned) {
X  		    if (mtmp->mcan) {
X  			if (flags.soundok)
X! 			    You("hear a cough from %s!", Blind ? "it"
X! 				: mon_nam(mtmp));
X  		    } else {
X  			if (flags.soundok)
X! 			    if (Blind) You("hear its hissing!");
X! 			    else You("hear %s's hissing!", mon_nam(mtmp));
X  			if((!rn2(10) ||
X  			    (flags.moonphase == NEW_MOON &&
X  			     !carrying(DEAD_LIZARD)))
X***************
X*** 715,721 ****
X  		}
X  		break;
X  	    case AD_STCK:
X! 		hitmsg(mtmp,mattk->aatyp);
X  		if(ctmp && !u.ustuck
X  #ifdef POLYSELF
X  				     && !sticks(uasmon)
X--- 689,695 ----
X  		}
X  		break;
X  	    case AD_STCK:
X! 		hitmsg(mtmp, mattk);
X  		if(ctmp && !u.ustuck
X  #ifdef POLYSELF
X  				     && !sticks(uasmon)
X***************
X*** 729,736 ****
X  #endif
X  					  ) {
X  		    if(!u.ustuck && !rn2(10)) {
X! 			pline("%s swings itself around you!",
X! 				Monnam(mtmp));
X  			u.ustuck = mtmp;
X  		    } else if(u.ustuck == mtmp) {
X  			if (is_pool(mtmp->mx,mtmp->my)
X--- 703,709 ----
X  #endif
X  					  ) {
X  		    if(!u.ustuck && !rn2(10)) {
X! 			kludge("%s swings itself around you!", Monnam(mtmp));
X  			u.ustuck = mtmp;
X  		    } else if(u.ustuck == mtmp) {
X  			if (is_pool(mtmp->mx,mtmp->my)
X***************
X*** 738,745 ****
X  			    && !is_swimmer(uasmon)
X  #endif
X  			   ) {
X! 			    pline("%s drowns you...", Monnam(mtmp));
X! 			    done("drowned");
X  			} else if(mattk->aatyp == AT_HUGS)
X  			    You("are being crushed.");
X  		    } else dmg = 0;
X--- 711,718 ----
X  			    && !is_swimmer(uasmon)
X  #endif
X  			   ) {
X! 			    kludge("%s drowns you...", Monnam(mtmp));
X! 			    done(DROWNING);
X  			} else if(mattk->aatyp == AT_HUGS)
X  			    You("are being crushed.");
X  		    } else dmg = 0;
X***************
X*** 746,752 ****
X  		} else dmg = 0;
X  		break;
X  	    case AD_WERE:
X! 		hitmsg(mtmp,mattk->aatyp);
X  #ifdef POLYSELF
X  		if (ctmp && !rn2(4) && u.ulycn == -1
X  # ifdef NAMED_ITEMS
X--- 719,725 ----
X  		} else dmg = 0;
X  		break;
X  	    case AD_WERE:
X! 		hitmsg(mtmp, mattk);
X  #ifdef POLYSELF
X  		if (ctmp && !rn2(4) && u.ulycn == -1
X  # ifdef NAMED_ITEMS
X***************
X*** 759,765 ****
X  #endif
X  		break;
X  	    case AD_SGLD:
X! 		hitmsg(mtmp,mattk->aatyp);
X  #ifdef POLYSELF
X  		if (u.usym == mdat->mlet) break;
X  #endif
X--- 732,738 ----
X  #endif
X  		break;
X  	    case AD_SGLD:
X! 		hitmsg(mtmp, mattk);
X  #ifdef POLYSELF
X  		if (u.usym == mdat->mlet) break;
X  #endif
X***************
X*** 775,786 ****
X  #  endif
X  						) {
X  			if (mtmp->minvent)
X! 	pline("%s brags about the goods some dungeon explorer provided.",
X  	Monnam(mtmp));
X  			else
X! 	pline("%s makes some remarks about how difficult theft is lately.",
X  	Monnam(mtmp));
X  			rloc(mtmp);
X  		} else
X  #endif
X  		if(mtmp->mcan) {
X--- 748,760 ----
X  #  endif
X  						) {
X  			if (mtmp->minvent)
X! 	kludge("%s brags about the goods some dungeon explorer provided.",
X  	Monnam(mtmp));
X  			else
X! 	kludge("%s makes some remarks about how difficult theft is lately.",
X  	Monnam(mtmp));
X  			rloc(mtmp);
X+ 			return 3;
X  		} else
X  #endif
X  		if(mtmp->mcan) {
X***************
X*** 790,808 ****
X  			    flags.female ? "charm" : "seduce",
X  			    flags.female ? "unaffected" : "uninterested");
X  		    }
X! 		    if(rn2(3)) rloc(mtmp);
X  		} else if(steal(mtmp)) {
X  			rloc(mtmp);
X  			mtmp->mflee = 1;
X  		}
X  		break;
X  #ifdef SEDUCE
X  	    case AD_SSEX:
X! 		if(!mtmp->mcan && !mtmp->minvis) doseduce(mtmp);
X  		break;
X  #endif
X  	    case AD_SAMU:
X! 		hitmsg(mtmp,mattk->aatyp);
X  		/* when the Wiz hits, 1/20 steals the amulet */
X  		if (!carrying(AMULET_OF_YENDOR)) break;
X  		if (!rn2(20)) stealamulet(mtmp);
X--- 764,789 ----
X  			    flags.female ? "charm" : "seduce",
X  			    flags.female ? "unaffected" : "uninterested");
X  		    }
X! 		    if(rn2(3)) {
X! 			rloc(mtmp);
X! 			return 3;
X! 		    }
X  		} else if(steal(mtmp)) {
X  			rloc(mtmp);
X  			mtmp->mflee = 1;
X+ 			return 3;
X  		}
X  		break;
X  #ifdef SEDUCE
X  	    case AD_SSEX:
X! 		if(could_seduce(mtmp, &youmonst, mattk) == 1
X! 			&& !mtmp->mcan)
X! 		    if (doseduce(mtmp))
X! 			return 3;
X  		break;
X  #endif
X  	    case AD_SAMU:
X! 		hitmsg(mtmp, mattk);
X  		/* when the Wiz hits, 1/20 steals the amulet */
X  		if (!carrying(AMULET_OF_YENDOR)) break;
X  		if (!rn2(20)) stealamulet(mtmp);
X***************
X*** 809,815 ****
X  		break;
X  
X  	    case AD_TLPT:
X! 		hitmsg(mtmp,mattk->aatyp);
X  		if(ctmp) {
X  		    if(flags.verbose)
X  			Your("position suddenly seems very uncertain!");
X--- 790,796 ----
X  		break;
X  
X  	    case AD_TLPT:
X! 		hitmsg(mtmp, mattk);
X  		if(ctmp) {
X  		    if(flags.verbose)
X  			Your("position suddenly seems very uncertain!");
X***************
X*** 817,823 ****
X  		}
X  		break;
X  	    case AD_RUST:
X! 		hitmsg(mtmp,mattk->aatyp);
X  		if (mtmp->mcan) break;
X  #ifdef POLYSELF
X  #ifdef GOLEMS
X--- 798,804 ----
X  		}
X  		break;
X  	    case AD_RUST:
X! 		hitmsg(mtmp, mattk);
X  		if (mtmp->mcan) break;
X  #ifdef POLYSELF
X  #ifdef GOLEMS
X***************
X*** 868,874 ****
X  		}
X  		break;
X  	    case AD_DCAY:
X! 		hitmsg(mtmp,mattk->aatyp);
X  		if (mtmp->mcan) break;
X  #ifdef POLYSELF
X  #ifdef GOLEMS
X--- 849,855 ----
X  		}
X  		break;
X  	    case AD_DCAY:
X! 		hitmsg(mtmp, mattk);
X  		if (mtmp->mcan) break;
X  #ifdef POLYSELF
X  #ifdef GOLEMS
X***************
X*** 888,894 ****
X  			break;
X  		    case 1:
X  			if (uarmc) break;
X! 			(void)rust_dmg(uarm, "leather armor", 2, TRUE);
X  			break;
X  		    case 2:
X  			if (!rust_dmg(uarms, "wooden shield", 2, FALSE))
X--- 869,875 ----
X  			break;
X  		    case 1:
X  			if (uarmc) break;
X! 			if (uarm) (void)rust_dmg(uarm, xname(uarm), 2, TRUE);
X  			break;
X  		    case 2:
X  			if (!rust_dmg(uarms, "wooden shield", 2, FALSE))
X***************
X*** 934,943 ****
X  			    if (flags.soundok && !(moves % 5))
X  				pline("'Doc, I can't help you unless you cooperate.'");
X  			    dmg = 0;
X! 		    } else hitmsg(mtmp,mattk->aatyp);
X  		break;
X  	    case AD_CURS:
X! 		hitmsg(mtmp,mattk->aatyp);
X  		if(!night() && mdat == &mons[PM_GREMLIN]) break;
X  		if(!mtmp->mcan && !rn2(10)) {
X  		    if (flags.soundok)
X--- 915,924 ----
X  			    if (flags.soundok && !(moves % 5))
X  				pline("'Doc, I can't help you unless you cooperate.'");
X  			    dmg = 0;
X! 		    } else hitmsg(mtmp, mattk);
X  		break;
X  	    case AD_CURS:
X! 		hitmsg(mtmp, mattk);
X  		if(!night() && mdat == &mons[PM_GREMLIN]) break;
X  		if(!mtmp->mcan && !rn2(10)) {
X  		    if (flags.soundok)
X***************
X*** 956,962 ****
X  		}
X  		break;
X  	    case AD_STUN:
X! 		hitmsg(mtmp,mattk->aatyp);
X  		if(!mtmp->mcan && !rn2(4)) {
X  		    make_stunned(HStun + dmg, TRUE);
X  		    dmg /= 2;
X--- 937,943 ----
X  		}
X  		break;
X  	    case AD_STUN:
X! 		hitmsg(mtmp, mattk);
X  		if(!mtmp->mcan && !rn2(4)) {
X  		    make_stunned(HStun + dmg, TRUE);
X  		    dmg /= 2;
X***************
X*** 963,969 ****
X  		}
X  		break;
X  	    case AD_ACID:
X! 		hitmsg(mtmp,mattk->aatyp);
X  		if(!mtmp->mcan && !rn2(3))
X  #ifdef POLYSELF
X  		    if (resists_acid(uasmon)) {
X--- 944,950 ----
X  		}
X  		break;
X  	    case AD_ACID:
X! 		hitmsg(mtmp, mattk);
X  		if(!mtmp->mcan && !rn2(3))
X  #ifdef POLYSELF
X  		    if (resists_acid(uasmon)) {
X***************
X*** 975,981 ****
X  		else		dmg = 0;
X  		break;
X  	    case AD_SLOW:
X! 		hitmsg(mtmp,mattk->aatyp);
X  		if(!ctmp && (Fast & (INTRINSIC|TIMEOUT)) && !rn2(4)) {
X  		    Fast &= ~(INTRINSIC|TIMEOUT);
X  		    You("feel yourself slowing down.");
X--- 956,962 ----
X  		else		dmg = 0;
X  		break;
X  	    case AD_SLOW:
X! 		hitmsg(mtmp, mattk);
X  		if(!ctmp && (Fast & (INTRINSIC|TIMEOUT)) && !rn2(4)) {
X  		    Fast &= ~(INTRINSIC|TIMEOUT);
X  		    You("feel yourself slowing down.");
X***************
X*** 982,988 ****
X  		}
X  		break;
X  	    case AD_DREN:
X! 		hitmsg(mtmp,mattk->aatyp);
X  #ifdef SPELLS
X  		if(!ctmp && !rn2(4)) drain_en(dmg);
X  #endif
X--- 963,969 ----
X  		}
X  		break;
X  	    case AD_DREN:
X! 		hitmsg(mtmp, mattk);
X  #ifdef SPELLS
X  		if(!ctmp && !rn2(4)) drain_en(dmg);
X  #endif
X***************
X*** 994,1000 ****
X  		break;
X  #ifdef HARD /* a non-gaze AD_CONF exists only for one of the demons */
X  	    case AD_CONF:
X! 		hitmsg(mtmp,mattk->aatyp);
X  		if(!mtmp->mcan && !rn2(4) && !mtmp->mspec_used) {
X  		    mtmp->mspec_used += (dmg + rn2(6));
X  		    if(Confusion)
X--- 975,981 ----
X  		break;
X  #ifdef HARD /* a non-gaze AD_CONF exists only for one of the demons */
X  	    case AD_CONF:
X! 		hitmsg(mtmp, mattk);
X  		if(!mtmp->mcan && !rn2(4) && !mtmp->mspec_used) {
X  		    mtmp->mspec_used += (dmg + rn2(6));
X  		    if(Confusion)
X***************
X*** 1252,1258 ****
X  #endif
X  			You("turn to stone...");
X  			killer = mons[PM_MEDUSA].mname;
X! 			done("stoned");
X  	    	}
X  		break;
X  #endif
X--- 1233,1239 ----
X  #endif
X  			You("turn to stone...");
X  			killer = mons[PM_MEDUSA].mname;
X! 			done(STONING);
X  	    	}
X  		break;
X  #endif
X***************
X*** 1269,1274 ****
X--- 1250,1267 ----
X  		    make_confused(HConfusion + conf, FALSE);
X  		}
X  		break;
X+ #ifdef HARD
X+ 	    case AD_STUN:
X+ 		if(!mtmp->mcan && canseemon(mtmp) && mtmp->mcansee &&
X+ 					!mtmp->mspec_used && rn2(5)) {
X+ 		    int stun = d(2,6);
X+ 
X+ 		    pline("%s stares piercingly at you!", Monnam(mtmp));
X+ 		    mtmp->mspec_used += (stun + rn2(6));
X+ 		    make_stunned(HStun + stun, TRUE);
X+ 		}
X+ 		break;
X+ #endif
X  	    default: impossible("Gaze attack %d?", mattk->adtyp);
X  		break;
X  	}
X***************
X*** 1323,1330 ****
X  }
X  #endif
X  
X  #ifdef SEDUCE
X! void
X  doseduce(mon)
X  register struct monst *mon;
X  {
X--- 1316,1379 ----
X  }
X  #endif
X  
X+ int
X+ could_seduce(magr,mdef,mattk)
X+ struct monst *magr, *mdef;
X+ struct attack *mattk;
X+ /* returns 0 if seduction impossible,
X+  *	   1 if fine,
X+  *	   2 if wrong gender for nymph */
X+ {
X+ 	register struct permonst *pagr, *pdef;
X+ 	boolean agrinvis, defperc;
X+ 	xchar genagr, gendef;
X+ 
X+ 	if(magr == &youmonst) {
X+ 		pagr = uasmon;
X+ 		agrinvis = (Invis != 0);
X+ 		genagr = poly_gender();
X+ 	} else {
X+ 		pagr = magr->data;
X+ 		agrinvis = magr->minvis;
X+ 		genagr = gender(magr);
X+ 	}
X+ 	if(mdef == &youmonst) {
X+ 		pdef = uasmon;
X+ 		defperc = (See_invisible != 0);
X+ 		gendef = poly_gender();
X+ 	} else {
X+ 		pdef = mdef->data;
X+ 		defperc = perceives(pdef);
X+ 		gendef = gender(mdef);
X+ 	}
X+ 
X+ 	if(agrinvis && !defperc
X+ #ifdef SEDUCE
X+ 		&& mattk && mattk->adtyp != AD_SSEX
X+ #endif
X+ 		)
X+ 		return 0;
X+ 
X+ 	if(pagr->mlet != S_NYMPH
X+ #ifdef HARD
X+ 		&& ((pagr != &mons[PM_INCUBUS] && pagr != &mons[PM_SUCCUBUS])
X+ # ifdef SEDUCE
X+ 		    || (mattk && mattk->adtyp != AD_SSEX)
X+ # endif
X+ 		   )
X+ #endif
X+ 		)
X+ 		return 0;
X+ 	
X+ 	if(genagr == 1 - gendef)
X+ 		return 1;
X+ 	else
X+ 		return (pagr->mlet == S_NYMPH) ? 2 : 0;
X+ }
X+ 
X  #ifdef SEDUCE
X! /* Returns 1 if monster teleported */
X! int
X  doseduce(mon)
X  register struct monst *mon;
X  {
X***************
X*** 1331,1350 ****
X  	register struct obj *ring;
X  	boolean fem = (mon->data == &mons[PM_SUCCUBUS]); /* otherwise incubus */
X  
X- 	if (fem == poly_gender() || poly_gender()==2) return;
X- 
X  	if (mon->mcan || mon->mspec_used) {
X    		pline("%s acts as though %s has got a %sheadache.",
X    			Blind ? "It" : Monnam(mon), Blind ? "it" :
X    			fem ? "she" : "he",
X  			mon->mcan ? "severe " : "");
X! 		return;
X  	}
X  
X  	if (unconscious()) {
X  		kludge("%s seems dismayed at your lack of response.",
X  			Monnam(mon));
X! 		return;
X  	}
X  
X  	if (Blind) pline("It caresses you...");
X--- 1380,1397 ----
X  	register struct obj *ring;
X  	boolean fem = (mon->data == &mons[PM_SUCCUBUS]); /* otherwise incubus */
X  
X  	if (mon->mcan || mon->mspec_used) {
X    		pline("%s acts as though %s has got a %sheadache.",
X    			Blind ? "It" : Monnam(mon), Blind ? "it" :
X    			fem ? "she" : "he",
X  			mon->mcan ? "severe " : "");
X! 		return 0;
X  	}
X  
X  	if (unconscious()) {
X  		kludge("%s seems dismayed at your lack of response.",
X  			Monnam(mon));
X! 		return 0;
X  	}
X  
X  	if (Blind) pline("It caresses you...");
X***************
X*** 1360,1366 ****
X  		    if (yn() == 'n') continue;
X  		} else pline("%s decides she'd like your %s, and takes it.",
X  			Blind ? "She" : Monnam(mon), xname(ring));
X! 		if (ring->known) makeknown(RIN_ADORNMENT);
X  		if (ring==uleft || ring==uright) Ring_gone(ring);
X  		if (ring==uwep) setuwep((struct obj *)0);
X  		freeinv(ring);
X--- 1407,1413 ----
X  		    if (yn() == 'n') continue;
X  		} else pline("%s decides she'd like your %s, and takes it.",
X  			Blind ? "She" : Monnam(mon), xname(ring));
X! 		makeknown(RIN_ADORNMENT);
X  		if (ring==uleft || ring==uright) Ring_gone(ring);
X  		if (ring==uwep) setuwep((struct obj *)0);
X  		freeinv(ring);
X***************
X*** 1426,1432 ****
X  		pline("\"You're such a %s; I wish...\"",
X  				flags.female ? "sweet lady" : "nice guy");
X  		rloc(mon);
X! 		return;
X  	}
X  #define ALIGNLIM 	(5L + (moves/200L)) /* from pray.c */
X  	if (u.ualigntyp == U_CHAOTIC && u.ualign < ALIGNLIM) u.ualign++;
X--- 1473,1479 ----
X  		pline("\"You're such a %s; I wish...\"",
X  				flags.female ? "sweet lady" : "nice guy");
X  		rloc(mon);
X! 		return 1;
X  	}
X  #define ALIGNLIM 	(5L + (moves/200L)) /* from pray.c */
X  	if (u.ualigntyp == U_CHAOTIC && u.ualign < ALIGNLIM) u.ualign++;
X***************
X*** 1464,1469 ****
X--- 1511,1520 ----
X  #endif
X  				    You("feel out of shape.");
X  				    losexp();
X+ 				    if(u.uhp <= 0) {
X+ 					killer = "overexertion";
X+ 					done(DIED);
X+ 				    }
X  #ifdef POLYSELF
X  				}
X  #endif
X***************
X*** 1534,1539 ****
X--- 1585,1591 ----
X  	}
X  	if (!rn2(25)) mon->mcan = 1; /* monster is worn out */
X  	rloc(mon);
X+ 	return 1;
X  }
X  
X  static void
X*** src/Old/mklev.c	Wed Aug 16 12:27:26 1989
X--- src/mklev.c	Tue Aug 15 18:48:20 1989
X***************
X*** 14,19 ****
X--- 14,20 ----
X  #ifdef ALTARS
X  static void mkaltar();
X  #endif
X+ static boolean occupied();
X  
X  int
X  somex(croom)
X***************
X*** 501,507 ****
X  	    if(!rn2(3)) {      /* is it a locked door, closed, or a doorway? */
X  		if(!rn2(5))
X  		    levl[x][y].doormask = D_ISOPEN;
X! 		else if(!rn2(4))
X  		    levl[x][y].doormask = D_LOCKED;
X  		else
X  		    levl[x][y].doormask = D_CLOSED;
X--- 502,508 ----
X  	    if(!rn2(3)) {      /* is it a locked door, closed, or a doorway? */
X  		if(!rn2(5))
X  		    levl[x][y].doormask = D_ISOPEN;
X! 		else if(!rn2(6))
X  		    levl[x][y].doormask = D_LOCKED;
X  		else
X  		    levl[x][y].doormask = D_CLOSED;
X***************
X*** 798,805 ****
X  		croom = &rooms[rn2(nroom-1)];
X  		if(croom >= troom) croom++;
X  	}
X! 	xupstair = somex(croom);    /* %% < and > might be in the same place */
X! 	yupstair = somey(croom);
X  	levl[xupstair][yupstair].scrsym = UP_SYM;
X  	levl[xupstair][yupstair].typ = STAIRS;
X  #ifdef STRONGHOLD
X--- 799,808 ----
X  		croom = &rooms[rn2(nroom-1)];
X  		if(croom >= troom) croom++;
X  	}
X! 	do {
X! 	    xupstair = somex(croom);
X! 	    yupstair = somey(croom);
X! 	} while(occupied(xupstair, yupstair));
X  	levl[xupstair][yupstair].scrsym = UP_SYM;
X  	levl[xupstair][yupstair].typ = STAIRS;
X  #ifdef STRONGHOLD
X***************
X*** 1025,1030 ****
X--- 1028,1034 ----
X  #ifdef ALTARS
X  		|| levl[x][y].typ == ALTAR
X  #endif
X+ 		|| is_pool(x,y)
X  		);
X  }
X  
X*** src/Old/mkmaze.c	Wed Aug 16 12:28:20 1989
X--- src/mkmaze.c	Tue Aug 15 20:34:39 1989
X***************
X*** 164,169 ****
X--- 164,174 ----
X  	return;
X  }
X  
X+ /* NCR towers define "tower".  Blecccch. */
X+ #ifdef tower
X+ #  undef tower
X+ #endif
X+ 
X  static const uchar tower[] = {
X  	MOAT,	  MOAT,     MOAT,     MOAT,	MOAT,	  MOAT,     MOAT,
X  	MOAT,	  MOAT,     TLCORNER, HWALL,	TRCORNER, MOAT,     MOAT,
X***************
X*** 233,239 ****
X  			return;
X  		}
X  		impossible("Cannot build the EndGame Level!");
X! 		done("escaped");
X  	}
X  # endif
X  #endif
X--- 238,244 ----
X  			return;
X  		}
X  		impossible("Cannot build the EndGame Level!");
X! 		done(ESCAPED);
X  	}
X  # endif
X  #endif
X*** src/Old/mkobj.c	Wed Aug 16 12:28:46 1989
X--- src/mkobj.c	Tue Aug 15 18:48:04 1989
X***************
X*** 231,241 ****
X  	case WEAPON_SYM:
X  		otmp->quan = (otmp->otyp <= SHURIKEN) ? rn1(6,6) : 1;
X  		if(!rn2(11)) {
X! 			otmp->spe = rne(2);
X  			otmp->blessed = rn2(2);
X  		} else if(!rn2(10)) {
X  			curse(otmp);
X! 			otmp->spe = -rne(2);
X  		} else	blessorcurse(otmp, 10);
X  
X  #ifdef NAMED_ITEMS
X--- 231,241 ----
X  	case WEAPON_SYM:
X  		otmp->quan = (otmp->otyp <= SHURIKEN) ? rn1(6,6) : 1;
X  		if(!rn2(11)) {
X! 			otmp->spe = rne(3);
X  			otmp->blessed = rn2(2);
X  		} else if(!rn2(10)) {
X  			curse(otmp);
X! 			otmp->spe = -rne(3);
X  		} else	blessorcurse(otmp, 10);
X  
X  #ifdef NAMED_ITEMS
X***************
X*** 349,357 ****
X  		   otmp->otyp == GAUNTLETS_OF_FUMBLING ||
X  		   !rn2(11))) {
X  			curse(otmp);
X! 			otmp->spe = -rne(2);
X  		} else if(!rn2(10)) {
X! 			otmp->spe = rne(2);
X  			otmp->blessed = rn2(2);
X  		} else	blessorcurse(otmp, 10);
X  		if(otmp->otyp == DRAGON_SCALE_MAIL)
X--- 349,357 ----
X  		   otmp->otyp == GAUNTLETS_OF_FUMBLING ||
X  		   !rn2(11))) {
X  			curse(otmp);
X! 			otmp->spe = -rne(3);
X  		} else if(!rn2(10)) {
X! 			otmp->spe = rne(3);
X  			otmp->blessed = rn2(2);
X  		} else	blessorcurse(otmp, 10);
X  		if(otmp->otyp == DRAGON_SCALE_MAIL)
X*** src/Old/mkroom.c	Wed Aug 16 12:29:10 1989
X--- src/mkroom.c	Thu Aug 10 10:25:36 1989
X***************
X*** 88,94 ****
X  				return;
X  			}
X  #ifdef THRONES
X! 			if(*ep == 't' || *ep == 'T'){
X  				mkzoo(COURT);
X  				return;
X  			}
X--- 88,94 ----
X  				return;
X  			}
X  #ifdef THRONES
X! 			if(*ep == 't' || *ep == 'T' || *ep == '\\'){
X  				mkzoo(COURT);
X  				return;
X  			}
X***************
X*** 111,117 ****
X  			}
X  			for(i=0; shtypes[i].name; i++)
X  				if(*ep == shtypes[i].symb) goto gottype;
X! 			i = -1;
X  		}
X  	}
X  gottype:
X--- 111,120 ----
X  			}
X  			for(i=0; shtypes[i].name; i++)
X  				if(*ep == shtypes[i].symb) goto gottype;
X! 			if(*ep == 'g' || *ep == 'G')
X! 				i = 0;
X! 			else
X! 				i = -1;
X  		}
X  	}
X  gottype:
X***************
X*** 320,325 ****
X--- 323,330 ----
X  	if(!(sroom = pick_room())) return;
X  
X  	if(!place_oracle(sroom,&dy,&xx,&yy)) return;
X+ 
X+ 	if(levl[xx][yy].mmask) rloc(m_at(xx, yy)); /* insurance */
X  
X  	/* set up Oracle and environment */
X  	if(!(oracl = makemon(&mons[PM_ORACLE],xx,yy))) return;
X*** src/Old/mon.c	Wed Aug 16 12:29:34 1989
X--- src/mon.c	Wed Aug 16 10:15:20 1989
X***************
X*** 10,15 ****
X--- 10,16 ----
X  
X  #ifdef HARD
X  static boolean restrap();
X+ #  include <ctype.h>
X  #endif
X  
X  long lastwarntime;
X***************
X*** 211,219 ****
X  			/* continue if the monster died fighting */
X  			fr = -1;
X  /* TODO:	Handle the case of the agressor dying? */
X! 			if(Conflict && cansee(mtmp->mx,mtmp->my)
X! 				&& !mtmp->iswiz
X! 				&& (fr = fightm(mtmp)) == 2)
X  				continue;
X    			if(fr<0 && dochugw(mtmp))
X  				continue;
X--- 212,226 ----
X  			/* continue if the monster died fighting */
X  			fr = -1;
X  /* TODO:	Handle the case of the agressor dying? */
X! 			if(Conflict && !mtmp->iswiz &&
X! 			   /* area you can see if you're not blind */
X! 			   (dist(mtmp->mx,mtmp->my) < 3 ||
X! 			    (levl[mtmp->mx][mtmp->my].lit &&
X! 			     ((seelx <= mtmp->mx && mtmp->mx <= seehx &&
X! 			       seely <= mtmp->my && mtmp->my <= seehy) ||
X! 			      (seelx2 <= mtmp->mx && mtmp->mx <= seehx2 &&
X! 			       seely2 <= mtmp->my && mtmp->my <= seehy2)))) &&
X! 			   (fr = fightm(mtmp)) == 2)
X  				continue;
X    			if(fr<0 && dochugw(mtmp))
X  				continue;
X***************
X*** 635,643 ****
X  	    /* so have "poison arrow", "poison dart", etc... */
X  	    plural = (string[strlen(string) - 1] == 's')? 1 : 0;
X  	    if(Blind)
X! 		pline("%s poisoned.", (plural) ? "They were" : "It was");
X  	    else
X! 		pline("The %s %s poisoned!", string, (plural) ? "were" : "was");
X  	}
X  
X  	if(Poison_resistance) {
X--- 642,655 ----
X  	    /* so have "poison arrow", "poison dart", etc... */
X  	    plural = (string[strlen(string) - 1] == 's')? 1 : 0;
X  	    if(Blind)
X! 		pline("%s poisoned.", plural ? "They were" : "It was");
X! #ifdef HARD
X! 	    /* avoid "The" Orcus's sting was poisoned... */
X! 	    else if(isupper(*string))
X! 		pline("%s %s poisoned!", string, plural ? "were" : "was");
X! #endif
X  	    else
X! 		pline("The %s %s poisoned!", string, plural ? "were" : "was");
X  	}
X  
X  	if(Poison_resistance) {
X***************
X*** 657,663 ****
X  	}
X  	if(u.uhp < 1) {
X  		killer = pname;
X! 		done("died");
X  	}
X  }
X  
X--- 669,675 ----
X  	}
X  	if(u.uhp < 1) {
X  		killer = pname;
X! 		done(POISONING);
X  	}
X  }
X  
X***************
X*** 831,837 ****
X  #ifdef DEBUG
X  		pline("Automatically genocided %s.", makeplural(mons[tmp].mname));
X  #endif
X! 		mons[tmp].geno |= G_GENOD;
X  	}
X  #ifdef MAIL
X  	/* If you kill the mail daemon, no more mail delivery.  -3. */
X--- 843,850 ----
X  #ifdef DEBUG
X  		pline("Automatically genocided %s.", makeplural(mons[tmp].mname));
X  #endif
X! 		if (tmp != PM_WIZARD_OF_YENDOR)
X! 			mons[tmp].geno |= G_GENOD;
X  	}
X  #ifdef MAIL
X  	/* If you kill the mail daemon, no more mail delivery.  -3. */
X*** src/Old/mondata.c	Wed Aug 16 12:30:26 1989
X--- src/mondata.c	Tue Aug 15 22:58:29 1989
X***************
X*** 96,102 ****
X  canseemon(mtmp)
X  	register struct monst *mtmp;
X  {
X! 	return((!mtmp->minvis || See_invisible)
X  		&& (!mtmp->mhide ||
X  		    (levl[mtmp->mx][mtmp->my].omask == 0 &&
X  		     levl[mtmp->mx][mtmp->my].gmask == 0))
X--- 96,102 ----
X  canseemon(mtmp)
X  	register struct monst *mtmp;
X  {
X! 	return((!mtmp->minvis || See_invisible || Telepat)
X  		&& (!mtmp->mhide ||
X  		    (levl[mtmp->mx][mtmp->my].omask == 0 &&
X  		     levl[mtmp->mx][mtmp->my].gmask == 0))
X***************
X*** 121,135 ****
X  	struct	permonst	*ptr;
X  {
X  	register int	i;
X- 	register struct permonst *mdat;
X  
X  	if(ptr == &playermon) return(-1);
X  
X! 	for(i = 0, mdat = &mons[0]; mdat->mlet; i++)
X! 	     if(ptr == mdat++) return(i);
X  
X! 	panic("monsndx - could not index monster (%x)", ptr);
X! 	return FALSE;			   /* will not get here */
X  }
X  
X  int
X--- 121,137 ----
X  	struct	permonst	*ptr;
X  {
X  	register int	i;
X  
X  	if(ptr == &playermon) return(-1);
X  
X! 	i = (int)(ptr - &mons[0]);
X  
X! 	if(i < 0 || i >= NUMMONS) {    
X! 	    panic("monsndx - could not index monster (%x)", ptr);
X! 	    return FALSE;		/* will not get here */
X! 	}
X! 
X! 	return(i);
X  }
X  
X  int
X***************
X*** 630,641 ****
X  cantweararm(ptr) struct permonst *ptr; {
X  	return(breakarm(ptr) || sliparm(ptr));
X  }
X  
X  int
X  nolimbs(ptr) struct permonst *ptr; {
X  	return((ptr->mflags2 & M2_NOLIMBS) != 0L);
X  }
X- # endif /* POLYSELF */
X  
X  int
X  carnivorous(ptr) struct permonst *ptr; {
X--- 632,643 ----
X  cantweararm(ptr) struct permonst *ptr; {
X  	return(breakarm(ptr) || sliparm(ptr));
X  }
X+ # endif /* POLYSELF */
X  
X  int
X  nolimbs(ptr) struct permonst *ptr; {
X  	return((ptr->mflags2 & M2_NOLIMBS) != 0L);
X  }
X  
X  int
X  carnivorous(ptr) struct permonst *ptr; {
X*** src/Old/monmove.c	Wed Aug 16 12:30:53 1989
X--- src/monmove.c	Tue Aug 15 18:49:05 1989
X***************
X*** 8,14 ****
X  #  include "artifact.h"
X  #endif
X  
X! static boolean /* TRUE : mtmp died */
X  mb_trapped(mtmp)
X  register struct monst *mtmp;
X  {
X--- 8,14 ----
X  #  include "artifact.h"
X  #endif
X  
X! boolean /* TRUE : mtmp died */
X  mb_trapped(mtmp)
X  register struct monst *mtmp;
X  {
X***************
X*** 684,689 ****
X--- 684,690 ----
X  		u.uy = mtmp->my;
X  	        if(mtmp->mx != mtmp->mdx || mtmp->my != mtmp->mdy) {
X  		    swallowed(0);
X+ 		    newsym(mtmp->mdx,mtmp->mdy);
X  		    mtmp->mdx = mtmp->mx;
X  		    mtmp->mdy = mtmp->my;
X  		}
X*** src/Old/mthrowu.c	Mon Jul 31 21:56:30 1989
X--- src/mthrowu.c	Thu Aug 17 09:02:22 1989
X***************
X*** 133,139
X  				kludge("The poison doesn't seem to affect %s.",
X  								mon_nam(mtmp));
X  			    else {
X! 				if (rn2(10)) damage += rnd(6);
X  				else {
X  				    pline("The poison was deadly...");
X  				    damage = mtmp->mhp;
X
X--- 133,139 -----
X  				kludge("The poison doesn't seem to affect %s.",
X  								mon_nam(mtmp));
X  			    else {
X! 				if (rn2(30)) damage += rnd(6);
X  				else {
X  				    pline("The poison was deadly...");
X  				    damage = mtmp->mhp;
X*** src/Old/version.c	Wed Aug 16 12:49:33 1989
X--- src/version.c	Tue Aug 15 22:05:17 1989
X***************
X*** 4,9 ****
X--- 4,12 ----
X  
X  #include	"hack.h"
X  #include	"date.h"
X+ #ifndef BETA
X+ #include	"patchlevel.h"
X+ #endif
X  
X  int
X  doversion(){
X***************
X*** 11,17 ****
X  #ifdef BETA
X  	pline("%s NetHack Beta Version %s - last build %s.",
X  #else
X! 	pline("%s NetHack Version %s - last build %s.",
X  #endif
X  #if defined(MSDOS)
X  # if defined(TOS)
X--- 14,20 ----
X  #ifdef BETA
X  	pline("%s NetHack Beta Version %s - last build %s.",
X  #else
X! 	pline("%s NetHack Version %s Patchlevel %d - last build %s.",
X  #endif
X  #if defined(MSDOS)
X  # if defined(TOS)
X***************
X*** 20,26 ****
X--- 23,33 ----
X  #  if defined(AMIGA)
X  		"Amiga",
X  #  else
X+ #   if defined(OS2)
X+ 		"OS/2",
X+ #   else
X  		"PC",
X+ #   endif
X  #  endif
X  # endif
X  #endif
X***************
X*** 27,32 ****
X  #ifdef UNIX
X  		"Unix",
X  #endif
X! 		VERSION, datestring);
X  	return 0;
X  }
X--- 34,43 ----
X  #ifdef UNIX
X  		"Unix",
X  #endif
X! 		VERSION,
X! #ifndef BETA
X! 		PATCHLEVEL,
X! #endif
X! 		datestring);
X  	return 0;
X  }
X*** src/Old/weapon.c	Sun Jul 16 10:05:53 1989
X--- src/weapon.c	Fri Aug 18 08:13:41 1989
X***************
X*** 205,211 ****
X  
X  	    /* shooting gems from slings; this goes just before the darts */
X  	    if (rwep[i]==DART && !likes_gems(mtmp->data)
X! 			/* && m_carrying(mtmp, SLING) */) {
X  		for(otmp=mtmp->minvent; otmp; otmp=otmp->nobj) {
X  		    if(otmp->olet==GEM_SYM &&
X  				(otmp->otyp != LOADSTONE || !otmp->cursed))
X--- 205,211 ----
X  
X  	    /* shooting gems from slings; this goes just before the darts */
X  	    if (rwep[i]==DART && !likes_gems(mtmp->data)
X! 			&& m_carrying(mtmp, SLING)) {
X  		for(otmp=mtmp->minvent; otmp; otmp=otmp->nobj) {
X  		    if(otmp->olet==GEM_SYM &&
X  				(otmp->otyp != LOADSTONE || !otmp->cursed))
X***************
X*** 224,237 ****
X  		  no_propellor = !(m_carrying(mtmp, BOW));
X  #endif
X  		  break;
X! 		/* case WP_SLING:
X  		  no_propellor = (m_carrying(mtmp, SLING) != 0);
X! 		  break; */
X  		case WP_CROSSBOW:
X  		  no_propellor = (m_carrying(mtmp, CROSSBOW) != 0);
X  		}
X  	      }
X! 	    if (!no_propellor) Oselect(rwep[i]);
X  	  }
X  
X  	/* failure */
X--- 224,248 ----
X  		  no_propellor = !(m_carrying(mtmp, BOW));
X  #endif
X  		  break;
X! 		case WP_SLING:
X  		  no_propellor = (m_carrying(mtmp, SLING) != 0);
X! 		  break;
X  		case WP_CROSSBOW:
X  		  no_propellor = (m_carrying(mtmp, CROSSBOW) != 0);
X  		}
X  	      }
X! 	    if (!no_propellor) {
X! 		/* Note: cannot use m_carrying for loadstones, since it will
X! 		 * always select the first object of a type, and maybe the
X! 		 * monster is carrying two but only the first is unthrowable.
X! 		 */
X! 		if (rwep[i] != LOADSTONE) {
X! 			Oselect(rwep[i]);
X! 		} else for(otmp=mtmp->minvent; otmp; otmp=otmp->nobj) {
X! 		    if (otmp->otyp == LOADSTONE && !otmp->cursed)
X! 			return otmp;
X! 		}
X! 	    }
X  	  }
X  
X  	/* failure */
X***************
X*** 327,333 ****
X  	else if(ACURR(A_DEX) < 6) return(sbon-2);
X  	else if(ACURR(A_DEX) < 8) return(sbon-1);
X  	else if(ACURR(A_DEX) < 14) return(sbon);
X! 	else return(sbon+ACURR(A_DEX)-15);
X  }
X  
X  int
X--- 338,344 ----
X  	else if(ACURR(A_DEX) < 6) return(sbon-2);
X  	else if(ACURR(A_DEX) < 8) return(sbon-1);
X  	else if(ACURR(A_DEX) < 14) return(sbon);
X! 	else return(sbon+ACURR(A_DEX)-14);
X  }
X  
X  int
X*** src/Old/were.c	Wed Aug 16 12:49:59 1989
X--- src/were.c	Fri Aug  4 12:37:40 1989
X***************
X*** 47,53 ****
X  	}
X  
X  	if(canseemon(mon))
X! 	    pline("%s changes into a %s.", Monnam(mon), mons[pm].mname);
X  
X  	mon->data = &mons[pm];
X  	/* regenerate by 1/4 of the lost hit points */
X--- 47,54 ----
X  	}
X  
X  	if(canseemon(mon))
X! 	    pline("%s changes into a %s.", Monnam(mon),
X! 			Hallucination ? rndmonnam() : mons[pm].mname);
X  
X  	mon->data = &mons[pm];
X  	/* regenerate by 1/4 of the lost hit points */
X*** src/Old/wield.c	Wed Aug 16 12:50:15 1989
X--- src/wield.c	Tue Aug 15 20:35:31 1989
X***************
X*** 66,72 ****
X  			makeplural(body_part(HAND)));
X  	    You("turn to stone...");
X  	    killer="cockatrice corpse";
X! 	    done("stoned");
X  	} else if(uarms && bimanual(wep))
X  	    You("cannot wield a two-handed %s and hold a shield.",
X  		 is_sword(wep) ? "sword" : "weapon");
X--- 66,72 ----
X  			makeplural(body_part(HAND)));
X  	    You("turn to stone...");
X  	    killer="cockatrice corpse";
X! 	    done(STONING);
X  	} else if(uarms && bimanual(wep))
X  	    You("cannot wield a two-handed %s and hold a shield.",
X  		 is_sword(wep) ? "sword" : "weapon");
X*** src/Old/worn.c	Wed Aug 16 12:50:55 1989
X--- src/worn.c	Tue Aug 15 20:35:33 1989
X***************
X*** 68,74 ****
X  	if (Inhell && !Fire_resistance) {
X  		pline(crispy);
X  		killer = "loss of fire protection";
X! 		done("burned");
X  		/* If we're here they survived with life saving, so put the
X  		 * weapon they just unwielded back in their hands...
X  		 */
X--- 68,74 ----
X  	if (Inhell && !Fire_resistance) {
X  		pline(crispy);
X  		killer = "loss of fire protection";
X! 		done(BURNING);
X  		/* If we're here they survived with life saving, so put the
X  		 * weapon they just unwielded back in their hands...
X  		 */
X***************
X*** 108,114 ****
X  	if (Inhell && !Fire_resistance && obj->olet != AMULET_SYM) {
X  		pline(crispy);
X  		killer = "loss of fire protection";
X! 		done("burned");
X  		/* Survived with lifesaving, etc...; there's no general way
X  		 * to undo the setnotworn()--we can't re-wear/wield the
X  		 * item since it might have been stolen, disintegrated, etc....
X--- 108,114 ----
X  	if (Inhell && !Fire_resistance && obj->olet != AMULET_SYM) {
X  		pline(crispy);
X  		killer = "loss of fire protection";
X! 		done(BURNING);
X  		/* Survived with lifesaving, etc...; there's no general way
X  		 * to undo the setnotworn()--we can't re-wear/wield the
X  		 * item since it might have been stolen, disintegrated, etc....
X***************
X*** 121,127 ****
X  			 */
X  #endif
X  			You("are still burning and die again...");
X! 			done("burned");
X  #if defined(WIZARD) || defined(EXPLORE_MODE)
X  		}
X  #endif
X--- 121,127 ----
X  			 */
X  #endif
X  			You("are still burning and die again...");
X! 			done(BURNING);
X  #if defined(WIZARD) || defined(EXPLORE_MODE)
X  		}
X  #endif
X*** src/Old/zap.c	Wed Aug 16 13:54:17 1989
X--- src/zap.c	Wed Aug 16 13:40:28 1989
X***************
X*** 43,48 ****
X--- 43,55 ----
X  	""
X  };
X  
X+ #ifdef TEXTCOLOR
X+ static const int zapcolor[10] = {
X+ 	AT_ZAP, RED, AT_ZAP, WHITE, AT_ZAP, WHITE,
X+ 	AT_ZAP, AT_ZAP, AT_ZAP, AT_ZAP
X+ };
X+ #endif
X+ 
X  /* Routines for IMMEDIATE wands and spells. */
X  /* bhitm: monster mtmp was hit by the effect of wand or spell otmp */
X  static int
X***************
X*** 657,663 ****
X  		    You("die.");
X  		    makeknown(WAN_DEATH);
X  			/* They might survive with an amulet of life saving */
X! 		    done("died");
X  		    break;
X  #ifdef SPELLS
X  		case SPE_TURN_UNDEAD:
X--- 664,670 ----
X  		    You("die.");
X  		    makeknown(WAN_DEATH);
X  			/* They might survive with an amulet of life saving */
X! 		    done(DIED);
X  		    break;
X  #ifdef SPELLS
X  		case SPE_TURN_UNDEAD:
X***************
X*** 705,743 ****
X  	if(objects[obj->otyp].bits & IMMEDIATE) {
X  	    if(u.uswallow)	(void)bhitm(u.ustuck, obj);
X  	    else if(u.dz) {
X! 		if(u.dz > 0 && levl[u.ux][u.uy].omask) {
X! 		    register struct obj *otmp,*otmp2;
X! 
X! 		    /* changed by GAN to hit all objects there */
X! 		    for(otmp = fobj; otmp ; otmp = otmp2) {
X! 			otmp2 = otmp->nobj;
X! 			/* save pointer as bhito may destroy otmp */
X! 			if(otmp->ox == u.ux && otmp->oy == u.uy)
X! 			    (void) bhito(otmp, obj);
X! 		    }
X! 		}
X! 	    } else if((obj->otyp == WAN_OPENING) ||
X! #ifdef SPELLS
X! 		      (obj->otyp == SPE_KNOCK) ||
X! 		      (obj->otyp == SPE_WIZARD_LOCK) ||
X! #endif
X! 		      (obj->otyp == WAN_LOCKING)) {
X! 		    (void)bhit(u.dx,u.dy,rn1(8,6),0,bhitm,bhito,obj);
X  #ifdef STRONGHOLD
X! 	    } else if(obj->otyp == WAN_STRIKING
X! #ifdef SPELLS
X! 		      || obj->otyp == SPE_FORCE_BOLT
X! #endif /* SPELLS /**/
X! 		      ) {
X! 		    int x,y;
X! 		    x = u.ux + u.dx;
X! 		    y = u.uy + u.dy;
X! 		    if (find_drawbridge(&x,&y))
X! 			destroy_drawbridge(x,y);
X! 
X! 		    else (void) bhit(u.dx,u.dy,rn1(8,6),0,bhitm,bhito,obj);
X! #endif /* STRONGHOLD /**/
X! 	    } else  (void) bhit(u.dx,u.dy,rn1(8,6),0,bhitm,bhito,obj);
X  	} else {
X  	    switch(obj->otyp){
X  		case WAN_LIGHT:
X--- 712,741 ----
X  	if(objects[obj->otyp].bits & IMMEDIATE) {
X  	    if(u.uswallow)	(void)bhitm(u.ustuck, obj);
X  	    else if(u.dz) {
X! 		if(u.dz > 0) {
X  #ifdef STRONGHOLD
X! 		    if(levl[u.ux][u.uy].typ == DRAWBRIDGE_DOWN &&
X! 		       (obj->otyp == WAN_LOCKING
X! # ifdef SPELLS
X! 			|| obj->otyp == SPE_WIZARD_LOCK
X! # endif
X! 			))
X! 				(void)close_drawbridge(u.ux, u.uy);
X! 		    else
X! #endif
X! 		    if (levl[u.ux][u.uy].omask) {
X! 			register struct obj *otmp,*otmp2;
X! 
X! 			/* changed by GAN to hit all objects there */
X! 			for(otmp = fobj; otmp ; otmp = otmp2) {
X! 				otmp2 = otmp->nobj;
X! 				/* save pointer as bhito may destroy otmp */
X! 				if(otmp->ox == u.ux && otmp->oy == u.uy)
X! 			    		(void) bhito(otmp, obj);
X! 			}
X! 		    }
X! 		}
X! 	    } else (void) bhit(u.dx,u.dy,rn1(8,6),0,bhitm,bhito,obj);
X  	} else {
X  	    switch(obj->otyp){
X  		case WAN_LIGHT:
X***************
X*** 935,940 ****
X--- 933,940 ----
X  	register struct monst *mtmp;
X  	register struct obj *otmp;
X  	register int typ;
X+ 	boolean shopdoor = FALSE;
X+ 	xchar dlx, dly;
X  
X  	bhitpos.x = u.ux;
X  	bhitpos.y = u.uy;
X***************
X*** 944,966 ****
X  		tmp_at(-3, (int)AT_OBJ);
X  	}
X  	while(range-- > 0) {
X  		bhitpos.x += ddx;
X  		bhitpos.y += ddy;
X- 		typ = levl[bhitpos.x][bhitpos.y].typ;
X  #ifdef STRONGHOLD
X! 		if(IS_DRAWBRIDGE(typ))
X  		    switch (obj->otyp) {
X  			case WAN_OPENING:
X  # ifdef SPELLS
X  			case SPE_KNOCK:
X  # endif
X! 			    (void) open_drawbridge(bhitpos.x,bhitpos.y);
X  			    break;
X  			case WAN_LOCKING:
X  # ifdef SPELLS
X  			case SPE_WIZARD_LOCK:
X  # endif
X! 			    (void) close_drawbridge(bhitpos.x,bhitpos.y);
X  		    }
X  #endif /* STRONGHOLD /**/
X  		if(levl[bhitpos.x][bhitpos.y].mmask){
X--- 944,975 ----
X  		tmp_at(-3, (int)AT_OBJ);
X  	}
X  	while(range-- > 0) {
X+ #ifdef STRONGHOLD
X+ 		int x,y;
X+ #endif
X  		bhitpos.x += ddx;
X  		bhitpos.y += ddy;
X  #ifdef STRONGHOLD
X! 		x = bhitpos.x; y = bhitpos.y;
X! 		if (find_drawbridge(&x,&y))
X  		    switch (obj->otyp) {
X  			case WAN_OPENING:
X  # ifdef SPELLS
X  			case SPE_KNOCK:
X  # endif
X! 			    (void) open_drawbridge(x,y);
X  			    break;
X  			case WAN_LOCKING:
X  # ifdef SPELLS
X  			case SPE_WIZARD_LOCK:
X  # endif
X! 			    (void) close_drawbridge(x,y);
X! 			    break;
X! 			case WAN_STRIKING:
X! # ifdef SPELLS
X! 			case SPE_FORCE_BOLT:
X! # endif
X! 			    destroy_drawbridge(x,y);
X  		    }
X  #endif /* STRONGHOLD /**/
X  		if(levl[bhitpos.x][bhitpos.y].mmask){
X***************
X*** 987,1002 ****
X  		    }
X  		    if(hitanything)	range--;
X  		}
X  		if(IS_DOOR(typ) || typ == SDOOR) {
X  		    switch (obj->otyp) {
X  			case WAN_OPENING:
X  			case WAN_LOCKING:
X  #ifdef SPELLS
X  			case SPE_KNOCK:
X  			case SPE_WIZARD_LOCK:
X  #endif
X! 			    if (doorlock(obj,bhitpos.x,bhitpos.y))
X! 				    makeknown(obj->otyp);
X  			    break;
X  		    }
X  		}
X--- 996,1020 ----
X  		    }
X  		    if(hitanything)	range--;
X  		}
X+ 		typ = levl[bhitpos.x][bhitpos.y].typ;
X  		if(IS_DOOR(typ) || typ == SDOOR) {
X  		    switch (obj->otyp) {
X  			case WAN_OPENING:
X  			case WAN_LOCKING:
X+ 			case WAN_STRIKING:
X  #ifdef SPELLS
X  			case SPE_KNOCK:
X  			case SPE_WIZARD_LOCK:
X+ 			case SPE_FORCE_BOLT:
X  #endif
X! 			    if (doorlock(obj, bhitpos.x, bhitpos.y)) {
X! 				makeknown(obj->otyp);
X! 				if (levl[bhitpos.x][bhitpos.y].doormask == D_BROKEN
X! 				    && in_shop(bhitpos.x, bhitpos.y)) {
X! 					shopdoor = TRUE;
X! 					dlx = bhitpos.x; dly = bhitpos.y;
X! 				}
X! 			    }
X  			    break;
X  		    }
X  		}
X***************
X*** 1017,1022 ****
X--- 1035,1044 ----
X  	/* leave last symbol unless in a pool */
X  	if(sym)
X  	   tmp_at(-1, is_pool(bhitpos.x,bhitpos.y) ? -1 : 0);
X+ 
X+ 	if(shopdoor && !in_shop(u.ux, u.uy))
X+ 		pay_for_door(dlx, dly, "destroy");
X+ 
X  	return (struct monst *)0;
X  }
X  
X***************
X*** 1032,1038 ****
X--- 1054,1064 ----
X  
X  	for(i=0; i<8; i++) if(xdir[i] == dx && ydir[i] == dy) break;
X  	tmp_at(-1, sym);	/* open call */
X+ #ifndef TEXTCOLOR
X  	tmp_at(-3, (int)AT_OBJ);
X+ #else
X+ 	tmp_at(-3, HI_METAL);
X+ #endif
X  	for(ct=0; ct<10; ct++) {
X  		if(i == 8) i = 0;
X  		sym = ')' + '(' - sym;
X***************
X*** 1225,1234 ****
X  	if(type < 0) pru();
X  	range = rn1(7,7);
X  	Tmp_at2(-1, (int) dirlet(dx,dy));	/* open call */
X! #ifdef MSDOSCOLOR
X! 	Tmp_at2(-3, (int)(abstype == 1 ? AT_RED :	/* fire */
X! 			  abstype == 3 || abstype == 5 ? AT_WHITE :	/* cold/elec */
X! 			  AT_ZAP));
X  #endif
X  	while(range-- > 0) {
X  		sx += dx;
X--- 1251,1258 ----
X  	if(type < 0) pru();
X  	range = rn1(7,7);
X  	Tmp_at2(-1, (int) dirlet(dx,dy));	/* open call */
X! #ifdef TEXTCOLOR
X! 	Tmp_at2(-3, zapcolor[abstype]);
X  #endif
X  	while(range-- > 0) {
X  		sx += dx;
END_OF_FILE
if test 54587 -ne `wc -c <'patch02e'`; then
    echo shar: \"'patch02e'\" unpacked with wrong size!
fi
# end of 'patch02e'
fi
echo shar: End of archive 5 \(of 7\).
cp /dev/null ark5isdone
MISSING=""
for I in 1 2 3 4 5 6 7 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 7 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
