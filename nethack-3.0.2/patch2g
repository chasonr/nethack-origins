Path: utzoo!utgpu!jarvis.csri.toronto.edu!mailrus!wasatch!cs.utexas.edu!uunet!zephyr.ens.tek.com!tekgen!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v08i012:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Patch2g
Message-ID: <4464@tekred.CNA.TEK.COM>
Date: 18 Aug 89 15:51:40 GMT
Sender: nobody@tekred.CNA.TEK.COM
Lines: 2159
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 8, Issue 12
Archive-name: NetHack3/Patch2g
Patch-To: NetHack3: Volume 7, Issue 56-93



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 7 (of 7)."
# Contents:  patch02g
# Wrapped by billr@saab on Fri Aug 18 08:44:43 1989
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'patch02g' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'patch02g'\"
else
echo shar: Extracting \"'patch02g'\" \(53958 characters\)
sed "s/^X//" >'patch02g' <<'END_OF_FILE'
X*** src/Old/priest.c	Wed Aug 16 12:38:50 1989
X--- src/priest.c	Mon Aug  7 23:38:33 1989
X***************
X*** 173,179 ****
X  	return(move_special(priest,temple,TRUE,FALSE,avoid,omx,omy,gx,gy));
X  }
X  
X! /* exclusevely for mktemple() */
X  void
X  priestini(lvl, sx, sy, align)
X  register int lvl, sx, sy, align;
X--- 173,179 ----
X  	return(move_special(priest,temple,TRUE,FALSE,avoid,omx,omy,gx,gy));
X  }
X  
X! /* exclusively for mktemple() */
X  void
X  priestini(lvl, sx, sy, align)
X  register int lvl, sx, sy, align;
X***************
X*** 183,190 ****
X  #ifdef SPELLS
X  	register int cnt;
X  #endif
X  
X! 	if (priest = makemon(&mons[!rn2(2) ? PM_TEMPLE_PRIEST : 
X  			PM_TEMPLE_PRIESTESS], sx+1, sy)) {
X  		EPRI(priest)->shroom = inroom(sx, sy);
X  		EPRI(priest)->shralign = align;
X--- 183,191 ----
X  #ifdef SPELLS
X  	register int cnt;
X  #endif
X+ 	if(levl[sx+1][sy].mmask) rloc(m_at(sx+1, sy)); /* insurance */
X  
X! 	if(priest = makemon(&mons[!rn2(2) ? PM_TEMPLE_PRIEST : 
X  			PM_TEMPLE_PRIESTESS], sx+1, sy)) {
X  		EPRI(priest)->shroom = inroom(sx, sy);
X  		EPRI(priest)->shralign = align;
X*** src/Old/prisym.c	Wed Aug 16 12:39:12 1989
X--- src/prisym.c	Tue Aug 15 22:58:34 1989
X***************
X*** 106,112 ****
X  uchar let;
X  xchar cnt;
X  coord tc[COLNO];	/* but watch reflecting beams! */
X! # ifdef MSDOSCOLOR
X  uchar col;
X  # endif
X  #else
X--- 106,112 ----
X  uchar let;
X  xchar cnt;
X  coord tc[COLNO];	/* but watch reflecting beams! */
X! # ifdef TEXTCOLOR
X  uchar col;
X  # endif
X  #else
X***************
X*** 113,119 ****
X  static uchar let;
X  static xchar cnt;
X  static coord tc[COLNO];	/* but watch reflecting beams! */
X! # ifdef MSDOSCOLOR
X  static uchar col;
X  # endif
X  #endif
X--- 113,119 ----
X  static uchar let;
X  static xchar cnt;
X  static coord tc[COLNO];	/* but watch reflecting beams! */
X! # ifdef TEXTCOLOR
X  static uchar col;
X  # endif
X  #endif
X***************
X*** 123,129 ****
X  		if(y > 0) {	/* open call */
X  			let = y;
X  			cnt = 0;
X! #ifdef MSDOSCOLOR
X  			col = AT_ZAP;
X  #endif
X  			return;
X--- 123,129 ----
X  		if(y > 0) {	/* open call */
X  			let = y;
X  			cnt = 0;
X! #ifdef TEXTCOLOR
X  			col = AT_ZAP;
X  #endif
X  			return;
X***************
X*** 140,146 ****
X  	    case -2:		/* change let call */
X  		let = y;
X  		return;
X! #ifdef MSDOSCOLOR
X  	    case -3:		/* set color call */
X  		col = y;
X  		return;
X--- 140,146 ----
X  	    case -2:		/* change let call */
X  		let = y;
X  		return;
X! #ifdef TEXTCOLOR
X  	    case -3:		/* set color call */
X  		col = y;
X  		return;
X***************
X*** 149,155 ****
X  	/* normal call */
X  	if(cansee(x,y)) {
X  		if(cnt) delay_output();
X! #ifdef MSDOSCOLOR
X  		at(x,y,let,col);
X  #else
X  		at(x,y,let,AT_ZAP);
X--- 149,155 ----
X  	/* normal call */
X  	if(cansee(x,y)) {
X  		if(cnt) delay_output();
X! #ifdef TEXTCOLOR
X  		at(x,y,let,col);
X  #else
X  		at(x,y,let,AT_ZAP);
X***************
X*** 218,224 ****
X  		return;
X  	if(room->mmask) mtmp = m_at(x,y);
X  	if(mtmp && !mtmp->mhide &&
X! 		(!mtmp->minvis || See_invisible)) {
X  #ifdef WORM
X  		if(m_atseg)
X  			pwseg(m_atseg);
X--- 218,224 ----
X  		return;
X  	if(room->mmask) mtmp = m_at(x,y);
X  	if(mtmp && !mtmp->mhide &&
X! 		(!mtmp->minvis || See_invisible || Telepat)) {
X  #ifdef WORM
X  		if(m_atseg)
X  			pwseg(m_atseg);
X***************
X*** 235,241 ****
X  	else if((!mtmp || mtmp->data == &mons[PM_GIANT_SPIDER]) &&
X  		  (ttmp = t_at(x,y)) && ttmp->ttyp == WEB)
X  		atl(x,y,(char)WEB_SYM);
X! 	else if(mtmp && (!mtmp->minvis || See_invisible)) {
X  		/* must be a hiding monster, but not hiding right now */
X  		/* assume for the moment that long worms do not hide */
X  		pmon(mtmp);
X--- 235,241 ----
X  	else if((!mtmp || mtmp->data == &mons[PM_GIANT_SPIDER]) &&
X  		  (ttmp = t_at(x,y)) && ttmp->ttyp == WEB)
X  		atl(x,y,(char)WEB_SYM);
X! 	else if(mtmp && (!mtmp->minvis || See_invisible || Telepat)) {
X  		/* must be a hiding monster, but not hiding right now */
X  		/* assume for the moment that long worms do not hide */
X  		pmon(mtmp);
X*** src/Old/read.c	Wed Aug 16 12:39:33 1989
X--- src/read.c	Wed Aug 16 10:15:57 1989
X***************
X*** 192,198 ****
X  			  sobj->cursed ? black : silver,
X  			  (s*s>1) ? "while" : "moment");
X  		otmp->cursed = sobj->cursed;
X! 		otmp->blessed = sobj->blessed;
X  		otmp->spe += s;
X  		adj_abon(otmp, s);
X  		break;
X--- 192,199 ----
X  			  sobj->cursed ? black : silver,
X  			  (s*s>1) ? "while" : "moment");
X  		otmp->cursed = sobj->cursed;
X! 		if (!otmp->blessed || sobj->cursed)
X! 			otmp->blessed = sobj->blessed;
X  		otmp->spe += s;
X  		adj_abon(otmp, s);
X  		break;
X***************
X*** 329,336 ****
X  		if(confused || sobj->cursed) cnt += 12;
X  		while(cnt--) {
X  #if defined(WIZARD) || defined(EXPLORE_MODE)
X! 		    if(wizard || discover)
X! 			if (!create_particular())
X  #endif /* WIZARD || EXPLORE_MODE */
X  		    (void) makemon (confused ? &mons[PM_ACID_BLOB] :
X  					(struct permonst *) 0, u.ux, u.uy);
X--- 330,336 ----
X  		if(confused || sobj->cursed) cnt += 12;
X  		while(cnt--) {
X  #if defined(WIZARD) || defined(EXPLORE_MODE)
X! 		    if((!wizard && !discover) || !create_particular())
X  #endif /* WIZARD || EXPLORE_MODE */
X  		    (void) makemon (confused ? &mons[PM_ACID_BLOB] :
X  					(struct permonst *) 0, u.ux, u.uy);
X***************
X*** 694,709 ****
X      useup(obj);
X  }
X  
X- int
X- identify(otmp)		/* also called by newmail() */
X- 	register struct obj *otmp;
X- {
X- 	makeknown(otmp->otyp);
X- 	otmp->known = otmp->dknown = otmp->bknown = 1;
X- 	prinv(otmp);
X- 	return(1);
X- }
X- 
X  void
X  litroom(on)
X  register boolean on;
X--- 694,699 ----
X***************
X*** 811,817 ****
X  				    You("feel dead inside.");
X  				else
X  #endif
X! 				    done("died");
X  			    }
X  			    /* for simplicity (and fairness) let's avoid
X  			     * alignment changes here...
X--- 801,807 ----
X  				    You("feel dead inside.");
X  				else
X  #endif
X! 				    done(GENOCIDED);
X  			    }
X  			    /* for simplicity (and fairness) let's avoid
X  			     * alignment changes here...
X***************
X*** 917,923 ****
X  		if(u.umonnum >= 0)	You("feel dead inside.");
X  		else
X  #endif
X! 			done("died");
X  		return;
X  	    }
X  #ifdef POLYSELF
X--- 907,913 ----
X  		if(u.umonnum >= 0)	You("feel dead inside.");
X  		else
X  #endif
X! 			done(GENOCIDED);
X  		return;
X  	    }
X  #ifdef POLYSELF
X***************
X*** 983,1029 ****
X  	    for(zx = (u.ux-9 < 0 ? 0 : u.ux-9); 
X  			zx < (u.ux+10 > COLNO ? COLNO : u.ux+10); zx++)
X  		show_map_spot(zx, zy);
X- }
X- 
X- int
X- destroy_arm(atmp)
X- register struct obj *atmp;
X- {
X- 	register struct obj *otmp;
X- 
X- 	if((otmp = uarmc) && (!atmp || atmp == uarmc)) {
X- 		Your("cloak crumbles and turns to dust!");
X- 		(void) Cloak_off();
X- 		useup(otmp);
X- 	} else if((otmp = uarm) && (!atmp || atmp == uarm)) {
X- 		Your("armor turns to dust and falls to the floor!");
X- 		(void) Armor_gone();
X- 		useup(otmp);
X- #ifdef SHIRT
X- 	} else if((otmp = uarmu) && (!atmp || atmp == uarmu)) {
X- 		Your("shirt crumbles into tiny threads and falls apart!");
X- 		useup(otmp);
X- #endif
X- 	} else if((otmp = uarmh) && (!atmp || atmp == uarmh)) {
X- 		Your("helmet turns to dust and is blown away!");
X- 		(void) Helmet_off();
X- 		useup(otmp);
X- 	} else if((otmp = uarmg) && (!atmp || atmp == uarmg)) {
X- 		Your("gloves vanish!");
X- 		(void) Gloves_off();
X- 		useup(otmp);
X- 		selftouch("You");
X- 	} else if((otmp = uarmf) && (!atmp || atmp == uarmf)) {
X- 		Your("boots disintegrate!");
X- 		(void) Boots_off();
X- 		useup(otmp);
X- 	} else if((otmp =uarms) && (!atmp || atmp == uarms)) {
X- 		Your("shield crumbles away!");
X- 		(void) Shield_off();
X- 		useup(otmp);
X- 	} else 	return(0);		/* could not destroy anything */
X- 
X- 	return(1);
X  }
X  
X  int
X--- 973,978 ----
X*** src/Old/restore.c	Fri Jul 28 01:59:18 1989
X--- src/restore.c	Thu Aug 17 00:20:55 1989
X***************
X*** 211,216
X  	mread(fd, (genericptr_t) &moves, sizeof moves);
X  	mread(fd, (genericptr_t) &wiz_level, sizeof wiz_level);
X  	mread(fd, (genericptr_t) &medusa_level, sizeof medusa_level);
X  #ifdef ORACLE
X  	mread(fd, (genericptr_t) &oracle_level, sizeof oracle_level);
X  #endif
X
X--- 211,217 -----
X  	mread(fd, (genericptr_t) &moves, sizeof moves);
X  	mread(fd, (genericptr_t) &wiz_level, sizeof wiz_level);
X  	mread(fd, (genericptr_t) &medusa_level, sizeof medusa_level);
X+ 	mread(fd, (genericptr_t) &bigroom_level, sizeof bigroom_level);
X  #ifdef ORACLE
X  	mread(fd, (genericptr_t) &oracle_level, sizeof oracle_level);
X  #endif
X***************
X*** 424,430
X  		pline("Strange, this map is not as I remember it.");
X  		pline("Somebody is trying some trickery here...");
X  		pline("This game is void.");
X! 		done("tricked");
X  	}
X  
X  	mread(fd, (genericptr_t) levl, sizeof(levl));
X
X--- 425,431 -----
X  		pline("Strange, this map is not as I remember it.");
X  		pline("Somebody is trying some trickery here...");
X  		pline("This game is void.");
X! 		done(TRICKED);
X  	}
X  
X  	mread(fd, (genericptr_t) levl, sizeof(levl));
X***************
X*** 598,603
X  
X  		mtmp2 = mtmp->nmon;
X  		if(mtmp->data->geno & G_GENOD) {
X  			mondead(mtmp);
X  			continue;
X  		}
X
X--- 599,607 -----
X  
X  		mtmp2 = mtmp->nmon;
X  		if(mtmp->data->geno & G_GENOD) {
X+ #ifdef KOPS
X+ 			allow_kops = FALSE;
X+ #endif
X  			mondead(mtmp);
X  #ifdef KOPS
X  			allow_kops = TRUE;
X***************
X*** 599,604
X  		mtmp2 = mtmp->nmon;
X  		if(mtmp->data->geno & G_GENOD) {
X  			mondead(mtmp);
X  			continue;
X  		}
X  
X
X--- 603,611 -----
X  			allow_kops = FALSE;
X  #endif
X  			mondead(mtmp);
X+ #ifdef KOPS
X+ 			allow_kops = TRUE;
X+ #endif
X  			continue;
X  		}
X  
X*** src/Old/rnd.c	Wed Aug 16 12:40:51 1989
X--- src/rnd.c	Wed Aug 16 10:32:27 1989
X***************
X*** 69,75 ****
X  {
X  	register int tmp = 1;
X  	while(!rn2(x)) tmp++;
X! 	return(tmp);
X  }
X  
X  #ifdef THEOLOGY
X--- 69,75 ----
X  {
X  	register int tmp = 1;
X  	while(!rn2(x)) tmp++;
X! 	return(min(tmp,(u.ulevel < 15) ? 5 : (int)u.ulevel/3));
X  }
X  
X  #ifdef THEOLOGY
X*** src/Old/rumors.c	Wed Aug 16 12:41:04 1989
X--- src/rumors.c	Tue Aug 15 21:57:08 1989
X***************
X*** 34,40 ****
X--- 34,50 ----
X  {
X  	register FILE *fp;
X  
X+ #ifdef OS2_CODEVIEW
X+ 	{
X+ 	char tmp[PATHLEN];
X+ 
X+ 	Strcpy(tmp,hackdir);
X+ 	append_slash(tmp);
X+ 	Strcat(tmp,RUMORFILE);
X+ 	if(fp = fopen(tmp, "r")) {
X+ #else
X  	if(fp = fopen(RUMORFILE, "r")) {
X+ #endif
X  	    (void) fread((genericptr_t)&true_rumor_size,sizeof(long),1,fp);
X  	    (void) fseek(fp, 0L, 2);
X  	    end_rumor_file = ftell(fp);
X***************
X*** 44,51 ****
X--- 54,74 ----
X  		pline("Can't open rumors file!");
X  		end_rumor_file = -1;	/* don't try to open it again */
X  	}
X+ #ifdef OS2_CODEVIEW
X+ 	}
X+ #endif
X  #ifdef ORACLE
X+ #ifdef OS2_CODEVIEW
X+ 	{
X+ 	char tmp[PATHLEN];
X+ 
X+ 	Strcpy(tmp,hackdir);
X+ 	append_slash(tmp);
X+ 	Strcat(tmp,ORACLEFILE);
X+ 	if(fp = fopen(tmp, "r")) {
X+ #else
X  	if(fp = fopen(ORACLEFILE, "r")) {
X+ #endif
X  	    (void) fseek(fp, 0L, 2);
X  	    oracle_size = ftell(fp);
X  	    (void) fclose(fp);
X***************
X*** 53,58 ****
X--- 76,84 ----
X  		pline("Can't open oracles file!");
X  		oracle_size = -1;	/* don't try to open it again */
X  	}
X+ #ifdef OS2_CODEVIEW
X+ 	}
X+ #endif
X  #endif
X  }
X  
X***************
X*** 76,82 ****
X--- 102,118 ----
X  	}
X  	if (end_rumor_file < 0) /* We couldn't open RUMORFILE */
X  		return;
X+ #ifdef OS2_CODEVIEW
X+ 	{
X+ 	char tmp[PATHLEN];
X+ 
X+ 	Strcpy(tmp,hackdir);
X+ 	append_slash(tmp);
X+ 	Strcat(tmp,RUMORFILE);
X+ 	if(rumors = fopen(tmp, "r")) {
X+ #else
X  	if(rumors = fopen(RUMORFILE, "r")) {
X+ #endif
X  		if (!end_rumor_file) {	/* if this is the first outrumor() */
X  			init_rumors();
X  		}
X***************
X*** 109,114 ****
X--- 145,153 ----
X  		pline("Can't open rumors file!");
X  		end_rumor_file = -1;	/* don't try to open it again */
X  	}
X+ #ifdef OS2_CODEVIEW
X+ 	}
X+ #endif
X  }
X  
X  #ifdef ORACLE
X***************
X*** 121,127 ****
X--- 160,176 ----
X  
X  	if (oracle_size < 0)	/* We couldn't open ORACLEFILE */
X  		return;
X+ #ifdef OS2_CODEVIEW
X+ 	{
X+     char tmp[PATHLEN];
X+ 
X+     Strcpy(tmp,hackdir);
X+     append_slash(tmp);
X+     Strcat(tmp,ORACLEFILE);
X+ 	if(oracles = fopen(tmp, "r")) {
X+ #else
X  	if(oracles = fopen(ORACLEFILE, "r")) {
X+ #endif
X  		if (!oracle_size) {	/* if this is the first outrumor() */
X  			init_rumors();
X  		}
X***************
X*** 148,153 ****
X--- 197,205 ----
X  		pline("Can't open oracles file!");
X  		oracle_size = -1;	/* don't try to open it again */
X  	}
X+ #ifdef OS2_CODEVIEW
X+ 	}
X+ #endif
X  }
X  
X  int
X*** src/Old/save.c	Wed Aug 16 12:41:20 1989
X--- src/save.c	Tue Aug 15 22:05:11 1989
X***************
X*** 52,58 ****
X--- 52,62 ----
X  		if(multi > 0) nomul(0);
X  	} else {
X  #ifdef EXPLORE_MODE
X+ # ifdef WIZARD
X+ 		if(!discover && !wizard) {
X+ # else
X  		if(!discover) {
X+ # endif
X  	pline("Do you want to create a non-scoring, restartable save file? ");
X  			if(yn() == 'y')  discover = TRUE;
X  		}
X***************
X*** 162,167 ****
X--- 166,172 ----
X  	bwrite(fd, (genericptr_t) &moves, sizeof moves);
X  	bwrite(fd, (genericptr_t) &wiz_level, sizeof wiz_level);
X  	bwrite(fd, (genericptr_t) &medusa_level, sizeof medusa_level);
X+ 	bwrite(fd, (genericptr_t) &bigroom_level, sizeof bigroom_level);
X  #ifdef ORACLE
X  	bwrite(fd, (genericptr_t) &oracle_level, sizeof oracle_level);
X  #endif
X***************
X*** 232,238 ****
X  		    if(!hu) pline("Error while saving: cannot read %s.", lock);
X  		    (void) close(fd);
X  		    (void) unlink(SAVEF);
X! 		    if(!hu) done("tricked");
X  		    return(0);
X  		}
X  #ifdef ZEROCOMP
X--- 237,243 ----
X  		    if(!hu) pline("Error while saving: cannot read %s.", lock);
X  		    (void) close(fd);
X  		    (void) unlink(SAVEF);
X! 		    if(!hu) done(TRICKED);
X  		    return(0);
X  		}
X  #ifdef ZEROCOMP
X*** src/Old/search.c	Wed Aug 16 12:41:46 1989
X--- src/search.c	Tue Aug 15 22:04:11 1989
X***************
X*** 201,208 ****
X  seemimic(mtmp)
X  register struct monst *mtmp;
X  {
X! 		mtmp->mimic = 0;
X! 		mtmp->mappearance = 0;
X! 		unpmon(mtmp);
X! 		pmon(mtmp);
X  }
X--- 201,208 ----
X  seemimic(mtmp)
X  register struct monst *mtmp;
X  {
X! 	mtmp->mimic = 0;
X! 	mtmp->mappearance = 0;
X! 	unpmon(mtmp);
X! 	pmon(mtmp);
X  }
X*** src/Old/shk.c	Wed Aug 16 12:42:05 1989
X--- src/shk.c	Wed Aug  2 20:48:09 1989
X***************
X*** 1302,1308 ****
X  register char *dmgstr;
X  {
X  	register struct monst *mtmp;
X- 	register int ox, oy;
X  	register int roomno = inroom(x, y);
X  	register int damage = (ACURR(A_STR) > 18) ? 400 : 20 * ACURR(A_STR);
X  
X--- 1302,1307 ----
X***************
X*** 1327,1337 ****
X  		return;
X  	}
X  
X- 	ox = shopkeeper->mx;
X- 	oy = shopkeeper->my;
X- 
X  	/* if he's not in his shop.. */
X! 	if(!in_shop(ox, oy)) return;
X  
X  	/* if a !shopkeeper shows up at the door, move him */
X  	if(levl[x][y].mmask && (mtmp = m_at(x, y)) != shopkeeper) {
X--- 1326,1333 ----
X  		return;
X  	}
X  
X  	/* if he's not in his shop.. */
X! 	if(!in_shop(shopkeeper->mx ,shopkeeper->my)) return;
X  
X  	/* if a !shopkeeper shows up at the door, move him */
X  	if(levl[x][y].mmask && (mtmp = m_at(x, y)) != shopkeeper) {
X***************
X*** 1376,1390 ****
X  		pline("Mollified, %s accepts your restitution.",
X  			shkname(shopkeeper));
X  
X! 		/* clear ox oy of another monster, if one got there somehow */
X! 		if(levl[ox][oy].mmask) mnearto(m_at(ox,oy),ox,oy,FALSE);
X! 
X! 		/* move shk back to his orig loc */
X! 		levl[shopkeeper->mx][shopkeeper->my].mmask = 0;
X! 		levl[ox][oy].mmask = 1;
X! 		shopkeeper->mx = ox;
X! 		shopkeeper->my = oy;
X! 		unpmon(shopkeeper);
X  		NOTANGRY(shopkeeper) = 1;
X  	}
X  	else {
X--- 1372,1379 ----
X  		pline("Mollified, %s accepts your restitution.",
X  			shkname(shopkeeper));
X  
X! 		/* move shk back to his home loc */
X! 		home_shk(shopkeeper);
X  		NOTANGRY(shopkeeper) = 1;
X  	}
X  	else {
X*** src/Old/shknam.c	Wed Aug 16 12:42:44 1989
X--- src/shknam.c	Fri Aug  4 11:38:47 1989
X***************
X*** 258,263 ****
X--- 258,265 ----
X  			return(-1);
X  		    }
X  
X+ 	if(levl[sx][sy].mmask) rloc(m_at(sx, sy)); /* insurance */
X+ 
X  	/* now initialize the shopkeeper monster structure */
X  	if(!(shk = makemon(&mons[PM_SHOPKEEPER], sx, sy))) return(-1);
X  	shk->isshk = shk->mpeaceful = 1;
X*** src/Old/sit.c	Wed Aug 16 12:43:02 1989
X--- src/sit.c	Tue Aug 15 20:35:12 1989
X***************
X*** 181,187 ****
X  			if (Inhell && !Fire_resistance) {
X  			    You("burn to a crisp.");
X  			    killer = "gremlin curse";
X! 			    done("died");
X  			} else You("feel warmer.");
X  			break;
X  		}
X--- 181,187 ----
X  			if (Inhell && !Fire_resistance) {
X  			    You("burn to a crisp.");
X  			    killer = "gremlin curse";
X! 			    done(BURNING);
X  			} else You("feel warmer.");
X  			break;
X  		}
X*** src/Old/sounds.c	Wed Aug 16 12:43:19 1989
X--- src/sounds.c	Mon Aug  7 23:10:57 1989
X***************
X*** 380,386 ****
X  	    break;
X  	case MS_HUMANOID:
X  	    /* Generic humanoid behaviour. */
X! 	    if (!mtmp->mpeaceful || !mtmp->mtame) break;
X  	    if (mtmp->mhp < 10)
X  		kludge("%s moans.", Monnam(mtmp));
X  	    else if (mtmp->mflee)
X--- 380,386 ----
X  	    break;
X  	case MS_HUMANOID:
X  	    /* Generic humanoid behaviour. */
X! 	    if (!mtmp->mpeaceful && !mtmp->mtame) break;
X  	    if (mtmp->mhp < 10)
X  		kludge("%s moans.", Monnam(mtmp));
X  	    else if (mtmp->mflee)
X***************
X*** 420,432 ****
X  	    break;
X  	case MS_SEDUCE:
X  # ifdef SEDUCE
X! 	    if ((mtmp->data==&mons[PM_SUCCUBUS] ||
X! 		mtmp->data==&mons[PM_INCUBUS])) {
X! 		doseduce(mtmp);
X! 		break;
X  	    }
X  # endif
X- 	    switch (poly_gender() == 0 ? rn2(3) : 0) {
X  		case 2:
X  			verbalize("Hello, sailor.");
X  			break;
X--- 420,434 ----
X  	    break;
X  	case MS_SEDUCE:
X  # ifdef SEDUCE
X! 	    if (mtmp->data->mlet != S_NYMPH &&
X! 		could_seduce(mtmp, &youmonst, (struct attack *)0) == 1) {
X! 			(void) doseduce(mtmp);
X! 			break;
X  	    }
X+ 	    switch ((poly_gender() != is_female(mtmp)) ? rn2(3) : 0) {
X+ # else
X+ 	    switch ((poly_gender() == 0) ? rn2(3) : 0) {
X  # endif
X  		case 2:
X  			verbalize("Hello, sailor.");
X  			break;
X*** src/Old/sp_lev.c	Wed Aug 16 12:43:41 1989
X--- src/sp_lev.c	Tue Aug 15 21:57:10 1989
X***************
X*** 571,577 ****
X--- 571,590 ----
X  	boolean result;
X  	schar c;
X  
X+ #ifdef OS2_CODEVIEW
X+ 	{
X+ 	char tmp[PATHLEN];
X+ 
X+ 	Strcpy(tmp,hackdir);
X+ 	append_slash(tmp);
X+ 	Strcat(tmp,name);
X+ 	fd = fopen(tmp, RDMODE);
X+ #else
X  	fd = fopen(name, RDMODE);
X+ #endif
X+ #ifdef OS2_CODEVIEW
X+ 	}
X+ #endif
X  	if (!fd) return FALSE;
X  
X  	if ((c = fgetc(fd)) == EOF) {
X*** src/Old/spell.c	Wed Aug 16 12:44:00 1989
X--- src/spell.c	Sat Aug  5 11:30:35 1989
X***************
X*** 1,6 ****
X  /*	SCCS Id: @(#)spell.c	3.0	88/09/18
X   *
X!  *	Copyright (c) M. Stepheneon 1988
X   */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,6 ----
X  /*	SCCS Id: @(#)spell.c	3.0	88/09/18
X   *
X!  *	Copyright (c) M. Stephenson 1988
X   */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X*** src/Old/termcap.c	Wed Aug 16 12:44:34 1989
X--- src/termcap.c	Tue Aug 15 22:05:16 1989
X***************
X*** 8,13 ****
X--- 8,17 ----
X  #define MONATTK_H
X  #include "hack.h"	/* for ROWNO, COLNO, *HI, *HE, *AS, *AE */
X  
X+ #ifndef MSDOS
X+ # define TERMLIB	/* include termcap code */
X+ #endif
X+ 
X  #if !defined(SYSV) || defined(TOS) || defined(UNIXPC)
X  # ifndef LINT
X  extern			/* it is defined in libtermlib (libtermcap) */
X***************
X*** 24,34 ****
X  #endif /* MICROPORT_286_BUG **/
X  
X  static void nocmov();
X! #ifdef MSDOSCOLOR
X  static void init_hilite();
X! #endif /* MSDOSCOLOR */
X  
X- static char tbuf[512];
X  static char *HO, *CL, *CE, *UP, *CM, *ND, *XD, *BC, *SO, *SE, *TI, *TE;
X  static char *VS, *VE, *US, *UE;
X  static char *MR, *ME;
X--- 28,43 ----
X  #endif /* MICROPORT_286_BUG **/
X  
X  static void nocmov();
X! #ifdef TEXTCOLOR
X! # ifdef TERMLIB
X  static void init_hilite();
X! # endif
X! #define NONE		0
X! #define HIGH_INTENSITY	1
X! #define BLACK		0
X! #define HILITE_ATTRIB	HIGH_INTENSITY
X! #endif /* TEXTCOLOR */
X  
X  static char *HO, *CL, *CE, *UP, *CM, *ND, *XD, *BC, *SO, *SE, *TI, *TE;
X  static char *VS, *VE, *US, *UE;
X  static char *MR, *ME;
X***************
X*** 35,86 ****
X  #if 0
X  static char *MB, *MD, *MH;
X  #endif
X  static int SG;
X  static char PC = '\0';
X  
X! #if defined(MSDOS) && !defined(TERMLIB)
X  static char tgotobuf[20];
X! #ifdef TOS
X  #define tgoto(fmt, x, y)	(Sprintf(tgotobuf, fmt, y+' ', x+' '), tgotobuf)
X! #else
X  #define tgoto(fmt, x, y)	(Sprintf(tgotobuf, fmt, y+1, x+1), tgotobuf)
X! #endif
X! #endif /* MSDOS /**/
X  
X  void
X  startup()
X  {
X! #if defined(TOS) && !defined(TERMLIB)
X! 	HO = "\033H";
X! 	CL = "\033E";		/* the VT52 termcap */
X! 	CE = "\033K";
X! 	UP = "\033A";
X! 	CM = "\033Y%c%c";	/* used with function tgoto() */
X! 	ND = "\033C";
X! 	XD = "\033B";
X! 	BC = "\033D";
X! 	SO = "\033p";
X! 	SE = "\033q";
X! 	HI = "\033p";
X! 	HE = "\033q";
X! #else
X  	register char *term;
X  	register char *tptr;
X  	char *tbufptr, *pc;
X  	register int i;
X  
X  	if(!(term = getenv("TERM")))
X  # ifdef ANSI_DEFAULT
X  	{
X  		HO = "\033[H";
X  		CL = "\033[2J";		/* the ANSI termcap */
X  /*		CD = "\033[J"; */
X  		CE = "\033[K";
X  		CM = "\033[%i%d;%dH";
X  		UP = "\033[A";
X  		ND = "\033[C";
X  		XD = "\033[B";
X  		BC = "\033[D";
X  		HI = SO = "\033[1m";
X  		US = "\033[4m";
X  		MR = "\033[7m";
X--- 44,120 ----
X  #if 0
X  static char *MB, *MD, *MH;
X  #endif
X+ #ifdef TERMLIB
X  static int SG;
X  static char PC = '\0';
X+ static char tbuf[512];
X+ #endif
X  
X! #ifndef TERMLIB
X  static char tgotobuf[20];
X! # ifdef TOS
X  #define tgoto(fmt, x, y)	(Sprintf(tgotobuf, fmt, y+' ', x+' '), tgotobuf)
X! # else
X  #define tgoto(fmt, x, y)	(Sprintf(tgotobuf, fmt, y+1, x+1), tgotobuf)
X! # endif
X! #endif /* TERMLIB */
X  
X  void
X  startup()
X  {
X! #ifdef TERMLIB
X  	register char *term;
X  	register char *tptr;
X  	char *tbufptr, *pc;
X+ #endif
X  	register int i;
X  
X+ #ifdef TERMLIB
X  	if(!(term = getenv("TERM")))
X+ #endif
X+ #if defined(TOS) && defined(__GNUC__)	/* library has a default */
X+ 		term = "st52";
X+ #else
X  # ifdef ANSI_DEFAULT
X+ #  ifdef TOS
X+ 	{
X+ 		HO = "\033H";
X+ 		CL = "\033E";		/* the VT52 termcap */
X+ 		CE = "\033K";
X+ 		UP = "\033A";
X+ 		CM = "\033Y%c%c";	/* used with function tgoto() */
X+ 		ND = "\033C";
X+ 		XD = "\033B";
X+ 		BC = "\033D";
X+ 		SO = "\033p";
X+ 		SE = "\033q";
X+ 		HI = "\033p";
X+ 		HE = "\033q";
X+ 	}
X+ #  else /* TOS */
X  	{
X+ #   ifdef DGK
X+ 		get_scr_size();
X+ 		if(CO < COLNO || LI < ROWNO+3)
X+ 			setclipped();
X+ #   endif
X  		HO = "\033[H";
X  		CL = "\033[2J";		/* the ANSI termcap */
X  /*		CD = "\033[J"; */
X  		CE = "\033[K";
X+ #   ifndef TERMLIB
X+ 		CM = "\033[%d;%dH";
X+ #   else
X  		CM = "\033[%i%d;%dH";
X+ #   endif
X  		UP = "\033[A";
X  		ND = "\033[C";
X  		XD = "\033[B";
X+ #   ifdef MSDOS	/* backspaces are non-destructive */
X+ 		BC = "\b";
X+ #   else
X  		BC = "\033[D";
X+ #   endif
X  		HI = SO = "\033[1m";
X  		US = "\033[4m";
X  		MR = "\033[7m";
X***************
X*** 88,113 ****
X  		/* strictly, SE should be 2, and UE should be 24,
X  		   but we can't trust all ANSI emulators to be
X  		   that complete.  -3. */
X  		AS = "\016";
X  		AE = "\017";
X! 		VS = VE = "";
X! #  ifdef MSDOSCOLOR
X! 		HI_WHITE = HI;
X! 		HI_RED = "\033[1;31m";
X! 		HI_YELLOW = "\033[1;33m";
X! 		HI_GREEN = "\033[1;32m";
X! 		HI_BLUE = "\033[1;34m";
X! #  endif
X  		return;
X  	}
X  # else
X- #  if defined(TOS) && defined(__GNUC__)		/* library has a default */
X- 		term = "st52";
X- #  else
X  		error("Can't get TERM.");
X! #  endif
X! # endif
X! 
X  	tptr = (char *) alloc(1024);
X  
X  	tbufptr = tbuf;
X--- 122,147 ----
X  		/* strictly, SE should be 2, and UE should be 24,
X  		   but we can't trust all ANSI emulators to be
X  		   that complete.  -3. */
X+ #   if !defined(MSDOS) || defined(DECRAINBOW)
X  		AS = "\016";
X  		AE = "\017";
X! #   endif
X! 		TE = VS = VE = "";
X! #   ifdef TEXTCOLOR
X! 		for (i = 0; i < SIZE(HI_COLOR); i++) {
X! 			HI_COLOR[i] = (char *) alloc(sizeof("E[0;33;44m"));
X! 			Sprintf(HI_COLOR[i], "\033[%d;3%dm",
X! 				i == BLACK ? NONE : HILITE_ATTRIB, i);
X! 		}
X! #   endif
X  		return;
X  	}
X+ #  endif /* TOS */
X  # else
X  		error("Can't get TERM.");
X! # endif /* ANSI_DEFAULT */
X! #endif /* __GNUC__ */
X! #ifdef TERMLIB
X  	tptr = (char *) alloc(1024);
X  
X  	tbufptr = tbuf;
X***************
X*** 117,142 ****
X  		error("Unknown terminal type: %s.", term);
X  	if(pc = Tgetstr("pc"))
X  		PC = *pc;
X! #ifdef TERMINFO
X  	if(!(BC = Tgetstr("le"))) {	
X! #else
X  	if(!(BC = Tgetstr("bc"))) {	
X! #endif
X! #if !defined(MINIMAL_TERM) && !defined(HISX)
X  		if(!tgetflag("bs"))
X  			error("Terminal must backspace.");
X! #endif
X  		BC = tbufptr;
X  		tbufptr += 2;
X  		*BC = '\b';
X  	}
X! #ifdef MINIMAL_TERM
X  	HO = NULL;
X! #else
X  	HO = Tgetstr("ho");
X! #endif
X  	CO = tgetnum("co");
X  	LI = tgetnum("li");
X  	if(CO < COLNO || LI < ROWNO+3)
X  		setclipped();
X  	if(!(CL = Tgetstr("cl")))
X--- 151,188 ----
X  		error("Unknown terminal type: %s.", term);
X  	if(pc = Tgetstr("pc"))
X  		PC = *pc;
X! # ifdef TERMINFO
X  	if(!(BC = Tgetstr("le"))) {	
X! # else
X  	if(!(BC = Tgetstr("bc"))) {	
X! # endif
X! # if !defined(MINIMAL_TERM) && !defined(HISX)
X  		if(!tgetflag("bs"))
X  			error("Terminal must backspace.");
X! # endif
X  		BC = tbufptr;
X  		tbufptr += 2;
X  		*BC = '\b';
X  	}
X! # ifdef MINIMAL_TERM
X  	HO = NULL;
X! # else
X  	HO = Tgetstr("ho");
X! # endif
X! 	/*
X! 	 * LI and CO are set in ioctl.c via a TIOCGWINSZ if available.  If
X! 	 * the kernel has values for either we should use them rather than
X! 	 * the values from TERMCAP ...
X! 	 */
X! # ifndef DGK
X! 	if (!CO) CO = tgetnum("co");
X! 	if (!LI) LI = tgetnum("li");
X! # else
X  	CO = tgetnum("co");
X  	LI = tgetnum("li");
X+ 	if (!LI || !CO)			/* if we don't override it */
X+ 		get_scr_size();
X+ # endif
X  	if(CO < COLNO || LI < ROWNO+3)
X  		setclipped();
X  	if(!(CL = Tgetstr("cl")))
X***************
X*** 167,177 ****
X  	TI = Tgetstr("ti");
X  	TE = Tgetstr("te");
X  	VS = VE = "";
X! #if 0
X  	MB = Tgetstr("mb");	/* blink */
X  	MD = Tgetstr("md");	/* boldface */
X  	MH = Tgetstr("mh");	/* dim */
X! #endif
X  	MR = Tgetstr("mr");	/* reverse */
X  	ME = Tgetstr("me");
X  
X--- 213,223 ----
X  	TI = Tgetstr("ti");
X  	TE = Tgetstr("te");
X  	VS = VE = "";
X! # if 0
X  	MB = Tgetstr("mb");	/* blink */
X  	MD = Tgetstr("md");	/* boldface */
X  	MH = Tgetstr("mh");	/* dim */
X! # endif
X  	MR = Tgetstr("mr");	/* reverse */
X  	ME = Tgetstr("me");
X  
X***************
X*** 194,203 ****
X  	set_whole_screen();		/* uses LI and CD */
X  	if(tbufptr-tbuf > sizeof(tbuf)) error("TERMCAP entry too big...\n");
X  	free((genericptr_t)tptr);
X! # ifdef MSDOSCOLOR
X  	init_hilite();
X  # endif
X! #endif /* TOS /* */
X  }
X  
X  void
X--- 240,249 ----
X  	set_whole_screen();		/* uses LI and CD */
X  	if(tbufptr-tbuf > sizeof(tbuf)) error("TERMCAP entry too big...\n");
X  	free((genericptr_t)tptr);
X! # ifdef TEXTCOLOR
X  	init_hilite();
X  # endif
X! #endif /* TERMLIB */
X  }
X  
X  void
X***************
X*** 318,324 ****
X  xputs(s)
X  char *s;
X  {
X! #if defined(MSDOS) && !defined(TERMLIB)
X  	(void) fputs(s, stdout);
X  #else
X  # ifdef __STDC__
X--- 364,370 ----
X  xputs(s)
X  char *s;
X  {
X! #ifndef TERMLIB
X  	(void) fputs(s, stdout);
X  #else
X  # ifdef __STDC__
X***************
X*** 496,523 ****
X  	}
X  }
X  
X! #ifdef MSDOSCOLOR
X! /* Sets up highlighting, using ANSI escape sequences, for monsters,
X!  * objects, and gold (highlight code found in pri.c).
X!  * The termcap entry for HI (from SO) is scanned to find the background 
X!  * color. If everything is OK, monsters are displayed in the color
X!  * used to define HILITE_MONSTER, objects are displayed in the color
X!  * used to define HILITE_OBJECT, and gold is displayed in the color
X!  * used to define HILITE_GOLD. -3. */
X  
X! #define ESC		0x1b
X! #define NONE		0
X! #define HIGH_INTENSITY	1
X! #define BLACK		0
X! #define RED		1
X! #define GREEN		2
X! #define YELLOW		3
X! #define BLUE		4
X! #define MAGENTA		5
X! #define CYAN		6
X! #define WHITE		7
X  
X! #define HILITE_ATTRIB	HIGH_INTENSITY
X  
X  static void
X  init_hilite()
X--- 542,596 ----
X  	}
X  }
X  
X! #if defined(TEXTCOLOR) && defined(TERMLIB)
X! # ifdef UNIX
X! /*
X!  * Sets up color highlighting, using terminfo(4) escape sequences (highlight
X!  * code found in pri.c).  It is assumed that the background color is black.
X!  */
X! /* terminfo indexes for the basic colors it guarantees */
X! #define COLOR_BLACK   0
X! #define COLOR_BLUE    1
X! #define COLOR_GREEN   2
X! #define COLOR_CYAN    3
X! #define COLOR_RED     4
X! #define COLOR_MAGENTA 5
X! #define COLOR_YELLOW  6
X! #define COLOR_WHITE   7
X! 
X! /* map ANSI RGB to terminfo BGR */
X! const int ti_map[8] = {
X! 	COLOR_BLACK, COLOR_RED, COLOR_GREEN, COLOR_YELLOW,
X! 	COLOR_BLUE, COLOR_MAGENTA, COLOR_CYAN, COLOR_WHITE };
X  
X! static void
X! init_hilite()
X! {
X! 	int erret;
X! 	char *setf, *scratch;
X! 	extern int setupterm();
X! 	extern char *tparm(), *tigetstr();
X  
X! 	for (c = 0; c < SIZE(HI_COLOR); c++)
X! 		HI_COLOR[c] = HI;
X! 
X! 	if (tgetnum("Co") < 8 || (setf = tgetstr("Sf", 0)) == (char *)NULL)
X! 		return;
X! 
X! 	for (c = 0; c < SIZE(HI_COLOR); c++) {
X! 		scratch = tparm(setf, ti_map[c]);
X! 		HI_COLOR[c] = (char *)alloc(strlen(scratch) + 1);
X! 		Strcpy(HI_COLOR[c], scratch);
X! 	}
X! }
X! 
X! # else /* UNIX */
X! 
X! /*
X!  * Sets up highlighting sequences, using ANSI escape sequences (highlight code
X!  * found in pri.c).  The termcap entry for HI (from SO) is scanned to find the
X!  * background color.
X!  */
X  
X  static void
X  init_hilite()
X***************
X*** 525,531 ****
X  	int backg = BLACK, foreg = WHITE, len;
X  	register int c, color;
X  
X! 	HI_RED = HI_YELLOW = HI_GREEN = HI_BLUE = HI_WHITE = HI;
X  
X  	/* find the background color, HI[len] == 'm' */
X  	len = strlen(HI) - 1;
X--- 598,605 ----
X  	int backg = BLACK, foreg = WHITE, len;
X  	register int c, color;
X  
X! 	for (c = 0; c < SIZE(HI_COLOR); c++)
X! 		HI_COLOR[c] = HI;
X  
X  	/* find the background color, HI[len] == 'm' */
X  	len = strlen(HI) - 1;
X***************
X*** 546,581 ****
X  	    c++;
X  	}
X  
X! 	/* avoid invisibility */
X! 	if (foreg != RED && backg != RED) {
X! 	    HI_RED = (char *) alloc(sizeof("E[0;33;44;54m"));
X! 	    Sprintf(HI_RED, "%c[%d;3%d;4%dm", ESC, HILITE_ATTRIB,
X! 		    RED, backg);
X! 	}
X! 
X! 	if (foreg != YELLOW && backg != YELLOW) {
X! 	    HI_YELLOW = (char *) alloc(sizeof("E[0;33;44;54m"));
X! 	    Sprintf(HI_YELLOW, "%c[%d;3%d;4%dm", ESC, HILITE_ATTRIB,
X! 		    YELLOW, backg);
X! 	}
X! 
X! 	if (foreg != GREEN && backg != GREEN) {
X! 	    HI_GREEN = (char *) alloc(sizeof("E[0;33;44;54m"));
X! 	    Sprintf(HI_GREEN, "%c[%d;3%d;4%dm", ESC, HILITE_ATTRIB,
X! 		    GREEN, backg);
X! 	}
X! 
X! 	if (foreg != BLUE && backg != BLUE) {
X! 	    HI_BLUE = (char *) alloc(sizeof("E[0;33;44;54m"));
X! 	    Sprintf(HI_BLUE, "%c[%d;3%d;4%dm", ESC, HILITE_ATTRIB,
X! 		    BLUE, backg);
X! 	}
X! 
X! 	if (foreg != WHITE && backg != WHITE) {
X! 	    HI_WHITE = (char *) alloc(sizeof("E[0;33;44;54m"));
X! 	    Sprintf(HI_WHITE, "%c[%d;3%d;4%dm", ESC, HILITE_ATTRIB,
X! 		    WHITE, backg);
X! 	}
X  }
X! 
X! #endif
X--- 620,633 ----
X  	    c++;
X  	}
X  
X! 	for (c = 0; c < SIZE(HI_COLOR); c++)
X! 	    /* avoid invisibility */
X! 	    if (foreg != c && backg != c) {
X! 		HI_COLOR[c] = (char *) alloc(sizeof("E[0;33;44;54m"));
X! 		Sprintf(HI_COLOR[c], "\033[%d;3%d;4%dm",
X! 			c == BLACK ? NONE : HILITE_ATTRIB,
X! 			c, backg);
X! 	    }
X  }
X! # endif /* UNIX */
X! #endif /* TEXTCOLOR */
X*** src/Old/timeout.c	Wed Aug 16 12:44:59 1989
X--- src/timeout.c	Tue Aug 15 20:35:14 1989
X***************
X*** 78,89 ****
X  		else switch(upp - u.uprops){
X  		case STONED:
X  			killer = "cockatrice";
X! 			done("stoned");
X  			break;
X  		case SICK:
X  			You("die from food poisoning.");
X  			killer = u.usick_cause;
X! 			done("died");
X  			break;
X  		case FAST:
X  			You("feel yourself slowing down.");
X--- 78,89 ----
X  		else switch(upp - u.uprops){
X  		case STONED:
X  			killer = "cockatrice";
X! 			done(STONING);
X  			break;
X  		case SICK:
X  			You("die from food poisoning.");
X  			killer = u.usick_cause;
X! 			done(POISONING);
X  			break;
X  		case FAST:
X  			You("feel yourself slowing down.");
X***************
X*** 125,131 ****
X  			break;
X  		case STRANGLED:
X  			killer = "strangulation";
X! 			done("died");
X  			break;
X  		case FUMBLING:
X  			/* call this only when a move took place.  */
X--- 125,131 ----
X  			break;
X  		case STRANGLED:
X  			killer = "strangulation";
X! 			done(DIED);
X  			break;
X  		case FUMBLING:
X  			/* call this only when a move took place.  */
X*** src/Old/topl.c	Wed Aug 16 12:45:16 1989
X--- src/topl.c	Fri Aug 11 17:17:51 1989
X***************
X*** 6,11 ****
X--- 6,12 ----
X  
X  char toplines[BUFSIZ];
X  xchar tlx, tly;			/* set by pline; used by addtopl */
X+ static boolean no_repeat = FALSE;
X  
X  struct topl {
X  	struct topl *next_topl;
X***************
X*** 148,154 ****
X  	if(!line || !*line) return;
X  	if(!index(line, '%')) Strcpy(pbuf,line); else
X  	Sprintf(pbuf,line,arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
X! /*	if(flags.toplin == 1 && !strcmp(pbuf, toplines)) return;*/
X  	nscr();		/* %% */
X  
X  	/* If there is room on the line, print message on same line */
X--- 149,155 ----
X  	if(!line || !*line) return;
X  	if(!index(line, '%')) Strcpy(pbuf,line); else
X  	Sprintf(pbuf,line,arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
X! 	if(no_repeat && flags.toplin == 1 && !strcmp(pbuf, toplines)) return;
X  	nscr();		/* %% */
X  
X  	/* If there is room on the line, print message on same line */
X***************
X*** 201,206 ****
X--- 202,221 ----
X  		if(n0 && tl[0]) Strcat(tl, "\n");
X  	}
X  	redotoplin();
X+ }
X+ 
X+ /*VARARGS1*/
X+ void
X+ Norep(line,arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9)
X+ #ifndef TOS
X+ register
X+ #endif
X+ const char *line,*arg1,*arg2,*arg3,*arg4,*arg5,*arg6,*arg7,*arg8,*arg9;
X+ {
X+ 	no_repeat = TRUE;
X+ 	pline(line, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
X+ 	no_repeat = FALSE;
X+ 	return;
X  }
X  
X  /*VARARGS1*/
X*** src/Old/topten.c	Wed Aug 16 12:45:32 1989
X--- src/topten.c	Tue Aug 15 22:04:44 1989
X***************
X*** 48,55 ****
X  # ifdef NO_FILE_LINKS
X  	int lockfd ;
X  # endif
X  #endif /* UNIX */
X- 	int sleepct = 300;
X  	FILE *rfile;
X  	register int flg = 0;
X  #ifdef LOGFILE
X--- 48,55 ----
X  # ifdef NO_FILE_LINKS
X  	int lockfd ;
X  # endif
X+ 	int sleepct = 100;
X  #endif /* UNIX */
X  	FILE *rfile;
X  	register int flg = 0;
X  #ifdef LOGFILE
X***************
X*** 67,107 ****
X  #define	HUP	if(!done_hup)
X  #endif
X  
X- #ifdef UNIX
X- # ifdef NO_FILE_LINKS
X- 	reclock = (char *)alloc(sizeof(LOCKDIR)+1+strlen(recfile)+7);
X- 	Strcpy(reclock,LOCKDIR) ;
X- 	Strcat(reclock,"/") ;
X- 	Strcat(reclock,recfile) ;
X- 	Strcat(reclock,"_lock") ;
X- 	while ((lockfd = open(reclock,O_RDWR|O_CREAT|O_EXCL,0666)) == -1) {
X- # else
X- 	while(link(recfile, reclock) == -1) {
X- # endif /* NO_FILE_LINKS */
X- 		HUP perror(reclock);
X- 		if(!sleepct--) {
X- 			HUP (void) puts("I give up.  Sorry.");
X- 			HUP (void) puts("Perhaps there is an old record_lock around?");
X- 			return;
X- 		}
X- 		HUP Printf("Waiting for access to record file. (%d)\n",
X- 			sleepct);
X- 		HUP (void) fflush(stdout);
X- # if defined(SYSV) || defined(ULTRIX)
X- 		(void)
X- # endif
X- 		    sleep(1);
X- 	}
X- #endif /* UNIX */
X- 	if(!(rfile = fopen(recfile,"r"))){
X- 		HUP (void) puts("Cannot open record file!");
X- 		goto unlock;
X- 	}
X- #ifdef NO_FILE_LINKS
X- 	(void) close(lockfd) ;
X- #endif
X- 	HUP (void) putchar('\n');
X- 
X  	/* create a new 'topten' entry */
X  	t0 = newttentry();
X  	t0->level = dlevel;
X--- 67,72 ----
X***************
X*** 118,125 ****
X  	(t0->death)[DTHSZ] = 0;
X  	Strcpy(t0->date, getdate());
X  
X- 	/* assure minimum number of points */
X- 	if(t0->points < POINTSMIN) t0->points = 0;
X  #ifdef LOGFILE		/* used for debugging (who dies of what, where) */
X  # ifdef UNIX
X  #  ifdef NO_FILE_LINKS
X--- 83,88 ----
X***************
X*** 168,175 ****
X--- 131,183 ----
X  # ifdef NO_FILE_LINKS
X  	(void) close(lockfd) ;
X  # endif
X+ # if defined(WIZARD) || defined(EXPLORE_MODE)
X+ 	if (wizard || discover) {
X+  Printf("\nSince you were in %s mode, the score list will not be checked.\n",
X+ 	wizard ? "wizard" : "discover");
X+ 		return;
X+ 	}
X+ # endif
X  #endif /* LOGFILE */
X  
X+ #ifdef UNIX
X+ # ifdef NO_FILE_LINKS
X+ 	reclock = (char *)alloc(sizeof(LOCKDIR)+1+strlen(recfile)+7);
X+ 	Strcpy(reclock,LOCKDIR) ;
X+ 	Strcat(reclock,"/") ;
X+ 	Strcat(reclock,recfile) ;
X+ 	Strcat(reclock,"_lock") ;
X+ 	while ((lockfd = open(reclock,O_RDWR|O_CREAT|O_EXCL,0666)) == -1) {
X+ # else
X+ 	while(link(recfile, reclock) == -1) {
X+ # endif /* NO_FILE_LINKS */
X+ 		HUP perror(reclock);
X+ 		if(!sleepct--) {
X+ 			HUP (void) puts("I give up.  Sorry.");
X+ 			HUP (void) puts("Perhaps there is an old record_lock around?");
X+ 			return;
X+ 		}
X+ 		HUP Printf("Waiting for access to record file. (%d)\n",
X+ 			sleepct);
X+ 		HUP (void) fflush(stdout);
X+ # if defined(SYSV) || defined(ULTRIX)
X+ 		(void)
X+ # endif
X+ 		    sleep(1);
X+ 	}
X+ #endif /* UNIX */
X+ 	if(!(rfile = fopen(recfile,"r"))){
X+ 		HUP (void) puts("Cannot open record file!");
X+ 		goto unlock;
X+ 	}
X+ #ifdef NO_FILE_LINKS
X+ 	(void) close(lockfd) ;
X+ #endif
X+ 	HUP (void) putchar('\n');
X+ 
X+ 	/* assure minimum number of points */
X+ 	if(t0->points < POINTSMIN) t0->points = 0;
X+ 
X  	t1 = tt_head = newttentry();
X  	tprev = 0;
X  	/* rank0: -1 undefined, 0 not_on_list, n n_th on list */
X***************
X*** 320,358 ****
X  	char linebuf[BUFSZ];
X  	linebuf[0] = 0;
X  	if(rank) Sprintf(eos(linebuf), " %2d", rank);
X! 		else Sprintf(eos(linebuf), "   ");
X  	Sprintf(eos(linebuf), " %7ld  %.10s", t1->points, t1->name);
X  	Sprintf(eos(linebuf), "-%c ", t1->plchar);
X  	if(!strncmp("escaped", t1->death, 7)) {
X! 	  if(!strcmp(" (with amulet)", t1->death+7))
X! 	    Sprintf(eos(linebuf), "escaped the dungeon with amulet");
X  	  else
X  	    Sprintf(eos(linebuf), "escaped the dungeon [max level %d]",
X  	      t1->maxlvl);
X  #ifdef ENDGAME
X  	} else if(!strncmp("ascended", t1->death, 8)) {
X! 	   Sprintf(eos(linebuf), "ascended to demigod-hood");
X  #endif
X  	} else {
X  	  if(!strncmp(t1->death,"quit",4)) {
X  		quit = TRUE;
X! 		Sprintf(eos(linebuf), "quit");
X! 	  } else if(!strcmp(t1->death,"choked"))
X  		Sprintf(eos(linebuf), "choked on %s food",
X  			(t1->sex == 'F') ? "her" : "his");
X! 	  else if(!strncmp(t1->death,"starv",5)) {
X! 		Sprintf(eos(linebuf), "starved to death");
X  		starv = TRUE;
X  	  } else if(!strncmp(t1->death, "turned to stone by ",19)) {
X! 		Sprintf(eos(linebuf), "was petrified");
X  		isstoned = TRUE;
X  	  } else {
X! 		Sprintf(eos(linebuf), "was killed");
X  		iskilled = TRUE;
X  	  }
X  #ifdef ENDLEVEL
X  	  if (t1->level == ENDLEVEL)
X! 		Strcpy(eos(linebuf), " in the endgame");
X  	  else
X  #endif
X  	    Sprintf(eos(linebuf), " on%s level %d",
X--- 328,370 ----
X  	char linebuf[BUFSZ];
X  	linebuf[0] = 0;
X  	if(rank) Sprintf(eos(linebuf), " %2d", rank);
X! 		else Strcat(linebuf, "   ");
X  	Sprintf(eos(linebuf), " %7ld  %.10s", t1->points, t1->name);
X  	Sprintf(eos(linebuf), "-%c ", t1->plchar);
X  	if(!strncmp("escaped", t1->death, 7)) {
X! 	  if(!strcmp(" (with the Amulet)", t1->death+7))
X! 	    Strcat(linebuf, "escaped the dungeon with the Amulet");
X  	  else
X  	    Sprintf(eos(linebuf), "escaped the dungeon [max level %d]",
X  	      t1->maxlvl);
X  #ifdef ENDGAME
X  	} else if(!strncmp("ascended", t1->death, 8)) {
X! 	   Strcat(linebuf, "ascended to demigod-hood");
X  #endif
X  	} else {
X  	  if(!strncmp(t1->death,"quit",4)) {
X  		quit = TRUE;
X! 		Strcat(linebuf, "quit");
X! 	  } else if(!strcmp(t1->death,"choked")) {
X  		Sprintf(eos(linebuf), "choked on %s food",
X  			(t1->sex == 'F') ? "her" : "his");
X! 	  } else if(!strncmp(t1->death,"starv",5)) {
X! 		Strcat(linebuf, "starved to death");
X  		starv = TRUE;
X+ 	  } else if(!strcmp(t1->death,"poisoned")) {
X+ 		Strcat(linebuf, "was posioned");
X+ 	  } else if(!strcmp(t1->death,"crushed")) {
X+ 		Strcat(linebuf, "was crushed to death");
X  	  } else if(!strncmp(t1->death, "turned to stone by ",19)) {
X! 		Strcat(linebuf, "was petrified");
X  		isstoned = TRUE;
X  	  } else {
X! 		Strcat(linebuf, "was killed");
X  		iskilled = TRUE;
X  	  }
X  #ifdef ENDLEVEL
X  	  if (t1->level == ENDLEVEL)
X! 		Strcat(linebuf, " in the endgame");
X  	  else
X  #endif
X  	    Sprintf(eos(linebuf), " on%s level %d",
X***************
X*** 359,382 ****
X  	      (iskilled || isstoned || starv) ? "" : " dungeon", t1->level);
X  	  if(t1->maxlvl != t1->level)
X  	    Sprintf(eos(linebuf), " [max %d]", t1->maxlvl);
X! 	  if(quit && t1->death[4]) Sprintf(eos(linebuf), t1->death + 4);
X  	}
X  	if(iskilled) Sprintf(eos(linebuf), " by %s%s",
X  	  (!strncmp(t1->death, "trick", 5) || !strncmp(t1->death, "the ", 4)
X  	   || !strncmp(t1->death, "Mr. ", 4) || !strncmp(t1->death, "Ms. ", 4)
X! 	   || !strncmp(eos(t1->death)-4, "tion", 4)
X  	   ) ? "" :
X  	  index(vowels,*t1->death) ? "an " : "a ",
X  	  t1->death);
X  	if (isstoned) Sprintf(eos(linebuf), " by %s%s", index(vowels,
X  		*(t1->death + 19)) ? "an " : "a ", t1->death + 19);
X! 	Sprintf(eos(linebuf), ".");
X  	if(t1->maxhp) {
X  	  register char *bp = eos(linebuf);
X  	  char hpbuf[10];
X  	  int hppos;
X  	  int lngr = strlen(linebuf);
X! 	  Sprintf(hpbuf, (t1->hp > 0) ? itoa(t1->hp) : "-");
X  	  hppos = COLNO - 7 - strlen(hpbuf);
X  	  if (lngr >= hppos) hppos = (2*COLNO) - 7 - strlen(hpbuf);
X  	  if(bp <= linebuf + hppos) {
X--- 371,394 ----
X  	      (iskilled || isstoned || starv) ? "" : " dungeon", t1->level);
X  	  if(t1->maxlvl != t1->level)
X  	    Sprintf(eos(linebuf), " [max %d]", t1->maxlvl);
X! 	  if(quit && t1->death[4]) Strcat(linebuf, t1->death + 4);
X  	}
X  	if(iskilled) Sprintf(eos(linebuf), " by %s%s",
X  	  (!strncmp(t1->death, "trick", 5) || !strncmp(t1->death, "the ", 4)
X  	   || !strncmp(t1->death, "Mr. ", 4) || !strncmp(t1->death, "Ms. ", 4)
X! 	   || !strncmp(eos(t1->death)-5, "ation", 5)
X  	   ) ? "" :
X  	  index(vowels,*t1->death) ? "an " : "a ",
X  	  t1->death);
X  	if (isstoned) Sprintf(eos(linebuf), " by %s%s", index(vowels,
X  		*(t1->death + 19)) ? "an " : "a ", t1->death + 19);
X! 	Strcat(linebuf, ".");
X  	if(t1->maxhp) {
X  	  register char *bp = eos(linebuf);
X  	  char hpbuf[10];
X  	  int hppos;
X  	  int lngr = strlen(linebuf);
X! 	  Strcpy(hpbuf, (t1->hp > 0) ? itoa(t1->hp) : "-");
X  	  hppos = COLNO - 7 - strlen(hpbuf);
X  	  if (lngr >= hppos) hppos = (2*COLNO) - 7 - strlen(hpbuf);
X  	  if(bp <= linebuf + hppos) {
X*** src/Old/trap.c	Wed Aug 16 12:46:13 1989
X--- src/trap.c	Wed Aug 16 10:15:44 1989
X***************
X*** 259,265 ****
X  			fobj->quan = 1;
X  			fobj->owt = weight(fobj);
X  			stackobj(fobj);
X! 			if(Invisible) newsym(u.ux, u.uy);
X  		    } else {
X  			register int newlevel = dlevel + 1;
X  			while(!rn2(4) && newlevel < 29) newlevel++;
X--- 259,269 ----
X  			fobj->quan = 1;
X  			fobj->owt = weight(fobj);
X  			stackobj(fobj);
X! 			if(Invisible
X! #ifdef POLYSELF
X! 				|| u.uundetected
X! #endif
X! 						) newsym(u.ux, u.uy);
X  		    } else {
X  			register int newlevel = dlevel + 1;
X  			while(!rn2(4) && newlevel < 29) newlevel++;
X***************
X*** 422,427 ****
X--- 426,433 ----
X  		    selftouch("Falling, you");
X  		    break;
X  		case LEVEL_TELEP:
X+ 		{   int oldl = dlevel;
X+ 
X  		    pline("You have %s onto a level teleport trap!",
X  #ifdef POLYSELF
X  			is_flyer(uasmon) ? "flown" :
X***************
X*** 429,436 ****
X  #else
X  			Levitation ? "moved" : "stepped");
X  #endif
X! 		    if(Antimagic)
X  			shieldeff(u.ux, u.uy);
X  		    if(Antimagic
X  #ifdef ENDGAME
X  				|| dlevel == ENDLEVEL
X--- 435,444 ----
X  #else
X  			Levitation ? "moved" : "stepped");
X  #endif
X! 		    if(Antimagic) {
X! 			pru();
X  			shieldeff(u.ux, u.uy);
X+ 		    }
X  		    if(Antimagic
X  #ifdef ENDGAME
X  				|| dlevel == ENDLEVEL
X***************
X*** 446,451 ****
X--- 454,468 ----
X  		    deltrap(trap);
X  		    newsym(u.ux,u.uy);
X  		    level_tele();
X+ 		    if(oldl == dlevel && !Invisible
X+ #ifdef POLYSELF
X+ 						&& !u.uundetected
X+ #endif
X+ 								) {
X+ 			levl[u.ux][u.uy].seen = 0; /* force atl */
X+ 			atl(u.ux,u.uy,(char)u.usym);
X+ 		    }
X+ 		}
X  		    break;
X  #ifdef SPELLS
X  		case ANTI_MAGIC:
X***************
X*** 477,483 ****
X  			u.uen = (u.uenmax += 2);
X  #endif
X  			deltrap(trap);
X! 			if(Invisible) newsym(u.ux,u.uy);
X  		    } else domagictrap();
X  		    break;
X  		case SQBRD:	    /* Stepped on a squeaky board. */
X--- 494,504 ----
X  			u.uen = (u.uenmax += 2);
X  #endif
X  			deltrap(trap);
X! 			if(Invisible
X! #ifdef POLYSELF
X! 				&& !u.uundetected
X! #endif
X! 						) newsym(u.ux,u.uy);
X  		    } else domagictrap();
X  		    break;
X  		case SQBRD:	    /* Stepped on a squeaky board. */
X***************
X*** 604,610 ****
X  	/* A bug fix for dumb messages by ab@unido.
X  	 */
X  	    int in_sight = cansee(mtmp->mx,mtmp->my)
X! 			   && (!mtmp->minvis || See_invisible);
X  
X  	    if(mtmp->mtrapseen & (1 << tt)) {
X  		/* he has been in such a trap - perhaps he escapes */
X--- 625,631 ----
X  	/* A bug fix for dumb messages by ab@unido.
X  	 */
X  	    int in_sight = cansee(mtmp->mx,mtmp->my)
X! 			   && (!mtmp->minvis || See_invisible || Telepat);
X  
X  	    if(mtmp->mtrapseen & (1 << tt)) {
X  		/* he has been in such a trap - perhaps he escapes */
X***************
X*** 822,828 ****
X  		pline("%s touch the cockatrice corpse.", arg);
X  		You("turn to stone...");
X  		killer = "cockatrice corpse accident";
X! 		done("stoned");
X  	}
X  }
X  
X--- 843,849 ----
X  		pline("%s touch the cockatrice corpse.", arg);
X  		You("turn to stone...");
X  		killer = "cockatrice corpse accident";
X! 		done(STONING);
X  	}
X  }
X  
X***************
X*** 910,915 ****
X--- 931,938 ----
X  		pline("Being unconscious, you cannot control your teleport.");
X  	    else {
X  		    pline("To what position do you want to be teleported?");
X+ 		    cc.x = u.ux;
X+ 		    cc.y = u.uy;
X  		    getpos(&cc, 1, "the desired position"); /* 1: force valid */
X  		    /* possible extensions: introduce a small error if
X  		       magic power is low; allow transfer to solid rock */
X***************
X*** 1116,1122 ****
X  			You("arrive in heaven.");
X  			pline("\"You are here a bit early, but we'll let you in.\"");
X  			killer = "visit to heaven";
X! 			done("died");
X  		} else	if (newlevel == -9) {
X  			You("feel deliriously happy. ");
X  			pline("(In fact, you're on Cloud 9!) ");
X--- 1139,1145 ----
X  			You("arrive in heaven.");
X  			pline("\"You are here a bit early, but we'll let you in.\"");
X  			killer = "visit to heaven";
X! 			done(DIED);
X  		} else	if (newlevel == -9) {
X  			You("feel deliriously happy. ");
X  			pline("(In fact, you're on Cloud 9!) ");
X***************
X*** 1131,1137 ****
X  		if(Levitation) {
X  		    You("float gently down to earth.");
X  #ifndef STRONGHOLD
X! 		    done("escaped");
X  #endif
X  		}
X  #ifdef POLYSELF
X--- 1154,1160 ----
X  		if(Levitation) {
X  		    You("float gently down to earth.");
X  #ifndef STRONGHOLD
X! 		    done(ESCAPED);
X  #endif
X  		}
X  #ifdef POLYSELF
X***************
X*** 1138,1144 ****
X  		if(is_flyer(uasmon)) {
X  		    You("fly down to earth.");
X  # ifndef STRONGHOLD
X! 		    done("escaped");
X  # endif
X  		}
X  #endif
X--- 1161,1167 ----
X  		if(is_flyer(uasmon)) {
X  		    You("fly down to earth.");
X  # ifndef STRONGHOLD
X! 		    done(ESCAPED);
X  # endif
X  		}
X  #endif
X***************
X*** 1146,1152 ****
X  		You("plummet a few thousand feet to your death.");
X  		dlevel = 0;
X  		killer = "long fall";
X! 		done("died");
X  #ifdef WALKIES
X  	    } else {
X  		You("shudder for a moment...");
X--- 1169,1175 ----
X  		You("plummet a few thousand feet to your death.");
X  		dlevel = 0;
X  		killer = "long fall";
X! 		done(DIED);
X  #ifdef WALKIES
X  	    } else {
X  		You("shudder for a moment...");
X***************
X*** 1154,1160 ****
X  	    }
X  #endif
X  	}
X! 	/* calls done("escaped") if newlevel==0 */
X  #ifdef WALKIES
X  	if(!pet_by_u)
X  	    You("shudder for a moment...");
X--- 1177,1183 ----
X  	    }
X  #endif
X  	}
X! 	/* calls done(ESCAPED) if newlevel==0 */
X  #ifdef WALKIES
X  	if(!pet_by_u)
X  	    You("shudder for a moment...");
X***************
X*** 1313,1319 ****
X  	}
X  	You("drown.");
X  	killer = levl[u.ux][u.uy].typ == POOL ? "pool of water" : "moat";
X! 	done("drowned");
X  }
X  
X  #ifdef SPELLS
X--- 1336,1342 ----
X  	}
X  	You("drown.");
X  	killer = levl[u.ux][u.uy].typ == POOL ? "pool of water" : "moat";
X! 	done(DROWNING);
X  }
X  
X  #ifdef SPELLS
X***************
X*** 1364,1370 ****
X  				case 'n': continue;
X  			    }
X  
X! 			    if((otmp->otrapped && !confused && rn2(44-dlevel*2) < 10)
X  			       || confused && !rn2(3)) {
X  				You("find a trap on the %s!  Disarm it? ",
X  				       xname(otmp));
X--- 1387,1394 ----
X  				case 'n': continue;
X  			    }
X  
X! 			    if((otmp->otrapped && !confused 
X! 					&& rn2(MAXLEVEL+2-dlevel) < 10)
X  			       || confused && !rn2(3)) {
X  				You("find a trap on the %s!  Disarm it? ",
X  				       xname(otmp));
X***************
X*** 1383,1389 ****
X  					chest_trap(otmp, FINGER);
X  				    } else {
X  					You("disarm it!");
X! 					otmp->otrapped = 0;
X  				    }
X  				} else pline("That %s was not trapped.",
X  					     doname(otmp));
X--- 1407,1413 ----
X  					chest_trap(otmp, FINGER);
X  				    } else {
X  					You("disarm it!");
X! 				        otmp->otrapped = 0;
X  				    }
X  				} else pline("That %s was not trapped.",
X  					     doname(otmp));
X***************
X*** 1422,1428 ****
X  	}
X  
X  	if ((levl[x][y].doormask & D_TRAPPED && !confused &&
X! 	     rn2(44-dlevel*2) < 10)
X  	    || confused && !rn2(3)) {
X  		You("find a trap on the door!  Disarm it? ");
X  		if (ynq() != 'y') return(1);
X--- 1446,1452 ----
X  	}
X  
X  	if ((levl[x][y].doormask & D_TRAPPED && !confused &&
X! 	     rn2(MAXLEVEL+2-dlevel) < 10)
X  	    || confused && !rn2(3)) {
X  		You("find a trap on the door!  Disarm it? ");
X  		if (ynq() != 'y') return(1);
X***************
X*** 1433,1442 ****
X  		    if(confused || Fumbling || rnd(75+dlevel/2) > ch) {
X  			    You("set it off!");
X  			    b_trapped("door");
X! 		    } else {
X  			    You("disarm it!");
X! 			    levl[x][y].doormask &= ~D_TRAPPED;
X! 		    }
X  		} else pline("This door was not trapped.");
X  		return(1);
X  	} else {
X--- 1457,1465 ----
X  		    if(confused || Fumbling || rnd(75+dlevel/2) > ch) {
X  			    You("set it off!");
X  			    b_trapped("door");
X! 		    } else
X  			    You("disarm it!");
X! 		    levl[x][y].doormask &= ~D_TRAPPED;
X  		} else pline("This door was not trapped.");
X  		return(1);
X  	} else {
X***************
X*** 1581,1591 ****
X  b_trapped(item)		/* used for doors. can be used */
X  register char *item;    /* for anything else that opens */
X  {
X! 	register int dmg = rn2(15) + rnd((int)u.ulevel);
X  
X  	pline("KABOOM!!  The %s was booby-trapped!", item);
X  	make_stunned(HStun + dmg, TRUE);
X- 	losehp(dmg, "explosion");
X  }
X  
X  /* Monster is hit by trap. */
X--- 1604,1616 ----
X  b_trapped(item)		/* used for doors. can be used */
X  register char *item;    /* for anything else that opens */
X  {
X! 	register int dmg = rnd(5+(dlevel < 5 ? dlevel : 2+dlevel/2));
X  
X  	pline("KABOOM!!  The %s was booby-trapped!", item);
X+ 	if(u.ulevel < 4 && dlevel < 3 && !rn2(3)) 
X+ 		You("are shaken, but luckily unhurt.");		
X+ 	else losehp(dmg, "explosion");
X  	make_stunned(HStun + dmg, TRUE);
X  }
X  
X  /* Monster is hit by trap. */
X*** src/Old/u_init.c	Wed Aug 16 12:47:06 1989
X--- src/u_init.c	Tue Aug  8 21:44:38 1989
X***************
X*** 534,547 ****
X  		 * items: wand of wishing, ring of levitation, or the
X  		 * polymorph/polymorph control combination.  Specific objects,
X  		 * i.e. the discovery wishing, are still OK.
X  		 */
X  		if (undefined) {
X  #ifdef POLYSELF
X! 			static int nocreate = STRANGE_OBJECT;
X  #  ifdef SPELLS
X! 			static int nocreate2 = STRANGE_OBJECT;
X  #  endif
X  #endif
X  
X  			while(obj->otyp == WAN_WISHING
X  #ifdef POLYSELF
X--- 534,552 ----
X  		 * items: wand of wishing, ring of levitation, or the
X  		 * polymorph/polymorph control combination.  Specific objects,
X  		 * i.e. the discovery wishing, are still OK.
X+ 		 * Also, don't get a couple of really useless items.  (Note:
X+ 		 * punishment isn't "useless".  Some players who start out with
X+ 		 * one will immediately read it and use the iron ball as a
X+ 		 * weapon.)
X  		 */
X  		if (undefined) {
X  #ifdef POLYSELF
X! 			int nocreate = STRANGE_OBJECT;
X  #  ifdef SPELLS
X! 			int nocreate2 = STRANGE_OBJECT;
X  #  endif
X  #endif
X+ 			int nocreate3 = STRANGE_OBJECT;
X  
X  			while(obj->otyp == WAN_WISHING
X  #ifdef POLYSELF
X***************
X*** 550,558 ****
X--- 555,571 ----
X  				|| obj->otyp == nocreate2
X  #  endif
X  #endif
X+ 				|| obj->otyp == nocreate3
X  #ifdef ELBERETH
X  				|| obj->otyp == RIN_LEVITATION
X  #endif
X+ 				/* 'useless' items */
X+ 				|| obj->otyp == POT_HALLUCINATION
X+ 				|| obj->otyp == SCR_AMNESIA
X+ 				|| obj->otyp == SCR_FIRE
X+ 				|| obj->otyp == RIN_AGGRAVATE_MONSTER
X+ 				|| obj->otyp == RIN_HUNGER
X+ 				|| obj->otyp == WAN_NOTHING
X  							) {
X  				free((genericptr_t) obj);
X  				obj = mkobj(trop->trolet, FALSE);
X***************
X*** 565,578 ****
X  			/* Heavily relies on the fact that 1) we create wands
X  			 * before rings, 2) that we create rings before
X  			 * spellbooks, and that 3) not more than 1 object of a
X! 			 * particular symbol is to be prohibited.
X  			 */
X  #ifdef POLYSELF
X! 			if (obj->otyp == WAN_POLYMORPH)
X  				nocreate = RIN_POLYMORPH_CONTROL;
X! 			if (obj->otyp == RIN_POLYMORPH)
X! 				nocreate = RIN_POLYMORPH_CONTROL;
X! 			if (obj->otyp == RIN_POLYMORPH_CONTROL) {
X  				nocreate = RIN_POLYMORPH;
X  #  ifdef SPELLS
X  				nocreate2 = SPE_POLYMORPH;
X--- 578,593 ----
X  			/* Heavily relies on the fact that 1) we create wands
X  			 * before rings, 2) that we create rings before
X  			 * spellbooks, and that 3) not more than 1 object of a
X! 			 * particular symbol is to be prohibited.  (For more
X! 			 * objects, we need more nocreate variables...)
X  			 */
X  #ifdef POLYSELF
X! 			switch (obj->otyp) {
X! 			    case WAN_POLYMORPH:
X! 			    case RIN_POLYMORPH:
X  				nocreate = RIN_POLYMORPH_CONTROL;
X! 				break;
X! 			    case RIN_POLYMORPH_CONTROL:
X  				nocreate = RIN_POLYMORPH;
X  #  ifdef SPELLS
X  				nocreate2 = SPE_POLYMORPH;
X***************
X*** 579,584 ****
X--- 594,602 ----
X  #  endif /* SPELLS */
X  			}
X  #endif /* POLYSELF */
X+ 			/* Don't have 2 of the same ring */
X+ 			if (obj->olet == RING_SYM)
X+ 				nocreate3 = obj->otyp;
X  		}
X  
X  		obj->bknown = trop->trknown;
X***************
X*** 606,612 ****
X  				&& obj->otyp != SACK
X  				&& obj->otyp != CHEST
X  				&& obj->otyp != LARGE_BOX
X! 				&& obj->otyp != ICE_BOX)
X  		}
X  		*/
X  		if(trop->trspe != UNDEF_SPE)
X--- 624,630 ----
X  				&& obj->otyp != SACK
X  				&& obj->otyp != CHEST
X  				&& obj->otyp != LARGE_BOX
X! 				&& obj->otyp != ICE_BOX);
X  		}
X  		*/
X  		if(trop->trspe != UNDEF_SPE)
END_OF_FILE
if test 53958 -ne `wc -c <'patch02g'`; then
    echo shar: \"'patch02g'\" unpacked with wrong size!
fi
# end of 'patch02g'
fi
echo shar: End of archive 7 \(of 7\).
cp /dev/null ark7isdone
MISSING=""
for I in 1 2 3 4 5 6 7 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 7 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
