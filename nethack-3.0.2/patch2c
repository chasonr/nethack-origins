Path: utzoo!utgpu!jarvis.csri.toronto.edu!mailrus!wasatch!cs.utexas.edu!uunet!zephyr.ens.tek.com!tekgen!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v08i008:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Patch2c
Message-ID: <4460@tekred.CNA.TEK.COM>
Date: 18 Aug 89 15:48:35 GMT
Sender: nobody@tekred.CNA.TEK.COM
Lines: 2210
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 8, Issue 8
Archive-name: NetHack3/Patch2c
Patch-To: NetHack3: Volume 7, Issue 56-93



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 3 (of 7)."
# Contents:  patch02c
# Wrapped by billr@saab on Fri Aug 18 08:43:01 1989
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'patch02c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'patch02c'\"
else
echo shar: Extracting \"'patch02c'\" \(56848 characters\)
sed "s/^X//" >'patch02c' <<'END_OF_FILE'
X*** src/Old/Makefile.src	Wed Aug 16 12:10:18 1989
X--- src/Makefile.src	Fri Aug 11 15:13:19 1989
X***************
X*** 5,11 ****
X  # Makefile.3B2, Makefile.att, and Makefile.tos.
X  # Set SYSTEM to one of:
X  #	'Sysunix'	-- generic UNIX
X! #	'Sysxenix'	-- 286 Xenix (386 Xenix can use Sysunix)
X  #	'Sys3B2'	-- AT&T 3B2, 3B5, etc.
X  #	'Sysatt'	-- AT&T UNIXPC, 7300, 3B1
X  #	'Systos'	-- Atari
X--- 5,11 ----
X  # Makefile.3B2, Makefile.att, and Makefile.tos.
X  # Set SYSTEM to one of:
X  #	'Sysunix'	-- generic UNIX
X! #	'Sysxenix'	-- 286 Xenix (386 Xenix should use Sysunix)
X  #	'Sys3B2'	-- AT&T 3B2, 3B5, etc.
X  #	'Sysatt'	-- AT&T UNIXPC, 7300, 3B1
X  #	'Systos'	-- Atari
X***************
X*** 60,65 ****
X--- 60,66 ----
X  #	      Spanic.o
X  
X  # on some systems the termcap library is in -ltermcap or -lcurses
X+ # on 386 Xenix, the -ltermlib tputs() seems not to work; use -lcurses instead
X  # Sysatt uses shared library in lieu of this option
X  # TERMLIB = -ltermcap
X  # TERMLIB = -lcurses
X***************
X*** 100,107 ****
X  
X  # all .c that are part of the main NetHack program and are not system specific
X  
X! CSOURCES = $(HACKCSRC) $(TARG)main.c $(TARG)main.c $(TARG)main.c makedefs.c panic.c
X  
X  HACKINCL = artifact.h attrib.h config.h coord.h decl.h edog.h epri.h eshk.h\
X  	   extern.h flag.h func_tab.h global.h gold.h hack.h lev.h mfndpos.h\
X  	   mkroom.h monattk.h mondata.h monflag.h monst.h monsym.h msdos.h\
X--- 101,113 ----
X  
X  # all .c that are part of the main NetHack program and are not system specific
X  
X! # now the other .c files, with duplicates commented out
X! MAKESRC = makedefs.c panic.c # monst.c objects.c
X! SPLEVSRC = lev_comp.c lev_lex.c lev_main.c # alloc.c monst.c objects.c panic.c
X! TARGSRC = $(TARG)main.c $(TARG)tty.c $(TARG)unix.c
X  
X+ CSOURCES = $(HACKCSRC) $(TARGSRC) $(MAKESRC) $(SPLEVSRC)
X+ 
X  HACKINCL = artifact.h attrib.h config.h coord.h decl.h edog.h epri.h eshk.h\
X  	   extern.h flag.h func_tab.h global.h gold.h hack.h lev.h mfndpos.h\
X  	   mkroom.h monattk.h mondata.h monflag.h monst.h monsym.h msdos.h\
X***************
X*** 110,117 ****
X  
X  # all .h files except date.h, onames.h, pm.h & trap.h which would cause
X  # dependency loops if run through "make depend".
X  
X! HSOURCES = $(HACKINCL) date.h onames.h pm.h trap.h
X  
X  SOURCES = $(CSOURCES) $(HSOURCES)
X  
X--- 116,124 ----
X  
X  # all .h files except date.h, onames.h, pm.h & trap.h which would cause
X  # dependency loops if run through "make depend".
X+ # and lev_comp.h, a special level file
X  
X! HSOURCES = $(HACKINCL) date.h onames.h pm.h trap.h lev_comp.h
X  
X  SOURCES = $(CSOURCES) $(HSOURCES)
X  
X***************
X*** 265,271 ****
X  #	files, we kludge around this by making date.h dependent on hack.h,
X  #	even though it doesn't include this file.
X  #
X! ../include/date.h:	$(CSOURCES) ../include/hack.h makedefs
X  	./makedefs -v
X  
X  ../include/trap.h:	../include/config.h makedefs
X--- 272,278 ----
X  #	files, we kludge around this by making date.h dependent on hack.h,
X  #	even though it doesn't include this file.
X  #
X! ../include/date.h:	$(HACKCSRC) $(TARGSRC) ../include/hack.h makedefs
X  	./makedefs -v
X  
X  ../include/trap.h:	../include/config.h makedefs
X***************
X*** 300,306 ****
X  # doweararm() versus dowearring().
X  # _flsbuf comes from <stdio.h>, a bug in the system libraries.
X  	@echo lint -axbh -DLINT ...
X! 	@lint -axbh -I../include -DLINT $(HACKCSRC) $(TARG)main.c $(TARG)tty.c $(TARG)unix.c | sed '/_flsbuf/d'
X  
X  
X  diff:
X--- 307,313 ----
X  # doweararm() versus dowearring().
X  # _flsbuf comes from <stdio.h>, a bug in the system libraries.
X  	@echo lint -axbh -DLINT ...
X! 	@lint -axbh -I../include -DLINT $(HACKCSRC) $(TARGSRC) | sed '/_flsbuf/d'
X  
X  
X  diff:
X*** src/Old/apply.c	Wed Aug 16 12:11:01 1989
X--- src/apply.c	Tue Aug 15 22:58:25 1989
X***************
X*** 24,31 ****
X  
X  	if(sym) {
X  		Tmp_at2(-1, sym);	/* open call */
X! #ifdef MSDOSCOLOR
X! 		Tmp_at2(-3, (int)AT_WHITE);
X  #endif
X  	}
X  	while(range--) {
X--- 24,31 ----
X  
X  	if(sym) {
X  		Tmp_at2(-1, sym);	/* open call */
X! #ifdef TEXTCOLOR
X! 		Tmp_at2(-3, WHITE);
X  #endif
X  	}
X  	while(range--) {
X***************
X*** 305,312 ****
X  			pline("This %s is already leashed!", lmonnam(mtmp)+4);
X  			return;
X  		}
X! 		You("slip the leash around your %s.",
X! 				mtmp->data->mname);
X  		mtmp->mleashed = 1;
X  		obj->leashmon = (int)mtmp->m_id;
X  		if(mtmp->msleep)  mtmp->msleep = 0;
X--- 305,311 ----
X  			pline("This %s is already leashed!", lmonnam(mtmp)+4);
X  			return;
X  		}
X! 		You("slip the leash around your %s.", lmonnam(mtmp)+4);
X  		mtmp->mleashed = 1;
X  		obj->leashmon = (int)mtmp->m_id;
X  		if(mtmp->msleep)  mtmp->msleep = 0;
X***************
X*** 490,496 ****
X  			if (break_statue(obj))
X  				digtxt = "The statue shatters.";
X  			else
X! 	digtxt = "Instead of shattering, the statue suddenly comes alive!";
X  		} else if(!lev->typ || lev->typ == SCORR) {
X  			lev->typ = CORR;
X  			digtxt = "You succeeded in cutting away some rock.";
X--- 489,498 ----
X  			if (break_statue(obj))
X  				digtxt = "The statue shatters.";
X  			else
X! 				/* it was a statue trap; break_statue()
X! 				 * printed a message and updated the screen
X! 				 */
X! 				digtxt = NULL;
X  		} else if(!lev->typ || lev->typ == SCORR) {
X  			lev->typ = CORR;
X  			digtxt = "You succeeded in cutting away some rock.";
X***************
X*** 518,524 ****
X  		  digtxt = "Now what exactly was it that you were digging in?";
X  		mnewsym(dpx, dpy);
X  		prl(dpx, dpy);
X! 		pline(digtxt);		/* after mnewsym & prl */
X  		if(IS_DOOR(lev->typ) && (lev->doormask & D_TRAPPED)) {
X  			b_trapped("door");
X  			lev->doormask = D_NODOOR;
X--- 520,526 ----
X  		  digtxt = "Now what exactly was it that you were digging in?";
X  		mnewsym(dpx, dpy);
X  		prl(dpx, dpy);
X! 		if (digtxt) pline(digtxt);	/* after mnewsym & prl */
X  		if(IS_DOOR(lev->typ) && (lev->doormask & D_TRAPPED)) {
X  			b_trapped("door");
X  			lev->doormask = D_NODOOR;
X***************
X*** 747,761 ****
X  use_mirror(obj)
X  struct obj *obj;
X  {
X!      register struct monst *mtmp;
X!      register char mlet;
X  
X  	if(!getdir(1)){		/* ask: in what direction? */
X  		flags.move = multi = 0;
X  		return;
X  	}
X  	if(!u.dx && !u.dy && !u.dz) {
X! 		if(!Blind && !Invisible)
X  #ifdef POLYSELF
X  		    if(u.umonnum == PM_FLOATING_EYE) {
X  			pline("Yikes!  You've frozen yourself!");
X--- 749,768 ----
X  use_mirror(obj)
X  struct obj *obj;
X  {
X! 	register struct monst *mtmp;
X! 	register char mlet;
X  
X  	if(!getdir(1)){		/* ask: in what direction? */
X  		flags.move = multi = 0;
X  		return;
X  	}
X+ 	if(obj->cursed && !rn2(2)) {
X+ 		if (!Blind)
X+ 			pline("The mirror gets foggy and doesn't reflect!");
X+ 		return;
X+ 	}
X  	if(!u.dx && !u.dy && !u.dz) {
X! 		if(!Blind && !Invisible) {
X  #ifdef POLYSELF
X  		    if(u.umonnum == PM_FLOATING_EYE) {
X  			pline("Yikes!  You've frozen yourself!");
X***************
X*** 788,794 ****
X  				ACURR(A_CHA) > 14 ?
X  				(poly_gender()==1 ? "beautiful" : "handsome") :
X  				"ugly");
X! 		else {
X  		if (rn2(4-u.uluck/3) || !HTelepat ||
X  		    (u.ukilled_medusa
X  #ifdef HARD
X--- 795,801 ----
X  				ACURR(A_CHA) > 14 ?
X  				(poly_gender()==1 ? "beautiful" : "handsome") :
X  				"ugly");
X! 		} else {
X  		if (rn2(4-u.uluck/3) || !HTelepat ||
X  		    (u.ukilled_medusa
X  #ifdef HARD
X***************
X*** 838,898 ****
X  			(u.dz > 0) ? "floor" : "ceiling");
X  		return;
X  	}
X! 	if((mtmp = bchit(u.dx, u.dy, COLNO, 0)) && haseyes(mtmp->data)) {
X! 	    mlet = mtmp->data->mlet;
X! 	    if(mtmp->msleep) {
X! 		if (!Blind)
X  		    pline ("%s is tired and doesn't look at your mirror.",
X  			    Monnam(mtmp));
X  		mtmp->msleep = 0;
X! 	    } else if (!mtmp->mcansee) {
X  		if (!Blind)
X  		    pline("%s can't see anything at the moment.", Monnam(mtmp));
X! 	    } else if (mtmp->minvis || mlet == S_VAMPIRE ||
X! 					mlet == S_DEMON || mlet == S_GHOST) {
X  		if (!Blind)
X  		   pline ("%s doesn't seem to reflect anything.", Monnam(mtmp));
X! 	    } else if (!mtmp->mcan) {
X! 	    /* some monsters do special things */
X! 		if(obj->cursed && !rn2(2)) {
X! 		    if (!Blind)
X! 			pline("The mirror gets foggy and doesn't reflect!");
X! 		    return;
X! 		} else if(mtmp->data == &mons[PM_MEDUSA]) {
X! 		    if (!Blind)
X  			pline("%s is turned to stone!", Monnam(mtmp));
X! 		    stoned = TRUE;
X! 		    killed(mtmp);
X! 		} else if(mtmp->data == &mons[PM_FLOATING_EYE]) {
X! 		    if (!Blind)
X  			pline("%s is frozen by its reflection.",Monnam(mtmp));
X! 		    mtmp->mfroz = 1;
X! 		} else if(mtmp->data == &mons[PM_UMBER_HULK]) {
X! 		    if (!Blind)
X  			pline ("%s has confused itself!", Monnam(mtmp));
X! 	    	    mtmp->mconf = 1;
X! 		} else if(mlet == S_NYMPH
X  #ifdef HARD
X  			  || mtmp->data==&mons[PM_SUCCUBUS]
X  #endif
X! 			  ) {
X! 		    if (!Blind) {
X! 	    	      pline ("%s looks beautiful in your mirror.",Monnam(mtmp));
X! 	    	      pline ("She decides to take it!");
X! 		    } else pline ("It steals your mirror!");
X! 	    	    freeinv(obj);
X! 	    	    mpickobj(mtmp,obj);
X! 	    	    rloc(mtmp);
X! 		}
X! 	    } else if (mlet != S_UNICORN && !humanoid(mtmp->data) && rn2(5)) {
X  		if (!Blind)
X! 		pline ("%s is frightened by its reflection.", Monnam(mtmp));
X  		mtmp->mflee = 1;
X  		mtmp->mfleetim += d(2,4);
X! 	    } else if (!Blind)
X! 		pline("%s doesn't seem to mind %s reflection.", Monnam(mtmp),
X! 		      (is_female(mtmp) ? "her" :
X! 		       is_human(mtmp->data) ? "his" : "its"));
X  	}
X  }/* use_mirror */
X  
X--- 845,916 ----
X  			(u.dz > 0) ? "floor" : "ceiling");
X  		return;
X  	}
X! 	if(!(mtmp = bchit(u.dx, u.dy, COLNO, 0)) || !haseyes(mtmp->data))
X! 		return;
X! 
X! 	mlet = mtmp->data->mlet;
X! 	if(mtmp->msleep) {
X! 		if(!Blind)
X  		    pline ("%s is tired and doesn't look at your mirror.",
X  			    Monnam(mtmp));
X  		mtmp->msleep = 0;
X! 	} else if (!mtmp->mcansee) {
X  		if (!Blind)
X  		    pline("%s can't see anything at the moment.", Monnam(mtmp));
X! 	/* some monsters do special things */
X! 	} else if (mlet == S_VAMPIRE || mlet == S_DEMON || mlet == S_GHOST ||
X! 		  (mtmp->minvis && !perceives(mtmp->data) && !See_invisible)) {
X  		if (!Blind)
X  		   pline ("%s doesn't seem to reflect anything.", Monnam(mtmp));
X! 	} else if(!mtmp->mcan && mtmp->data == &mons[PM_MEDUSA]) {
X! 		if (!Blind)
X  			pline("%s is turned to stone!", Monnam(mtmp));
X! 		stoned = TRUE;
X! 		killed(mtmp);
X! 	} else if(!mtmp->mcan && !mtmp->minvis &&
X! 					mtmp->data == &mons[PM_FLOATING_EYE]) {
X! 	/* Note: floating eyes cannot use their abilities while invisible,
X! 	 * but medusas and umber hulks can.
X! 	 */
X! 		if (!Blind)
X  			pline("%s is frozen by its reflection.",Monnam(mtmp));
X! 		mtmp->mfroz = 1;
X! 	} else if(!mtmp->mcan && mtmp->data == &mons[PM_UMBER_HULK]) {
X! 		if (!Blind)
X  			pline ("%s has confused itself!", Monnam(mtmp));
X! 	    	mtmp->mconf = 1;
X! 	} else if(!mtmp->mcan && !mtmp->minvis && (mlet == S_NYMPH
X  #ifdef HARD
X  			  || mtmp->data==&mons[PM_SUCCUBUS]
X  #endif
X! 			  )) {
X! 		if (!Blind) {
X! 	    	    pline ("%s looks beautiful in your mirror.",Monnam(mtmp));
X! 	    	    pline ("She decides to take it!");
X! 		} else pline ("It steals your mirror!");
X! 	    	freeinv(obj);
X! 	    	mpickobj(mtmp,obj);
X! 	    	rloc(mtmp);
X! 	} else if (mlet != S_UNICORN && !humanoid(mtmp->data) && 
X! 			(!mtmp->minvis || perceives(mtmp->data)) && rn2(5)) {
X  		if (!Blind)
X! 			pline ("%s is frightened by its reflection%s.",
X! 				Monnam(mtmp), (mtmp->minvis && !See_invisible
X! 					&& !Telepat) ?
X! 				", though you see nothing" : "");
X  		mtmp->mflee = 1;
X  		mtmp->mfleetim += d(2,4);
X! 	} else if (!Blind) {
X! 		if (mtmp->minvis && !See_invisible)
X! 		    pline("%s doesn't seem to reflect anything.",
X! 			Monnam(mtmp));
X! 		else if (mtmp->minvis && !perceives(mtmp->data))
X! 		    pline("%s doesn't seem to be aware of its reflection.",
X! 			Monnam(mtmp));
X! 		else
X! 		    pline("%s doesn't seem to mind %s reflection.",
X! 			Monnam(mtmp), (is_female(mtmp) ? "her" :
X! 		        is_human(mtmp->data) ? "his" : "its"));
X  	}
X  }/* use_mirror */
X  
X***************
X*** 1048,1053 ****
X--- 1066,1073 ----
X  		return 0;
X  	}
X  	pline("Where do you want to jump?");
X+ 	cc.x = u.ux;
X+ 	cc.y = u.uy;
X  	getpos(&cc, 1, "the desired position");
X  	if (dist(cc.x, cc.y) > 9) {
X  		pline("Too far!");
X***************
X*** 1095,1101 ****
X  pline("Tinning a cockatrice corpse without gloves was not a very wise move...");
X  		You("turn to stone...");
X  		killer = "unwise tinning decision";
X! 		done("stoned");
X  	}
X  	can = mksobj(TIN,FALSE);
X  	can->corpsenm = corpse->corpsenm;
X--- 1115,1121 ----
X  pline("Tinning a cockatrice corpse without gloves was not a very wise move...");
X  		You("turn to stone...");
X  		killer = "unwise tinning decision";
X! 		done(STONING);
X  	}
X  	can = mksobj(TIN,FALSE);
X  	can->corpsenm = corpse->corpsenm;
X*** src/Old/bones.c	Wed Aug 16 12:12:22 1989
X--- src/bones.c	Tue Aug 15 21:55:10 1989
X***************
X*** 42,47 ****
X--- 42,50 ----
X  {
X  	return (lev == medusa_level ||
X  		lev == wiz_level
X+ #ifdef REINCARNATION
X+ 		|| lev == rogue_level
X+ #endif
X  #ifdef STRONGHOLD
X  		|| lev == stronghold_level ||
X  		(lev >= tower_level && lev <= tower_level+2)
X***************
X*** 240,246 ****
X--- 243,251 ----
X  	savefruitchn(fd);
X  #endif
X  	savelev(fd, dlevel, COUNT);
X+ #ifdef ZEROCOMP
X  	bflush(fd);
X+ #endif
X  	if (bytes_counted > freediskspace(bones)) {	/* not enough room */
X  #ifdef WIZARD
X  		if (wizard)
X*** src/Old/cmd.c	Wed Aug 16 12:12:44 1989
X--- src/cmd.c	Tue Aug 15 22:58:59 1989
X***************
X*** 90,95 ****
X--- 90,115 ----
X  	return multi > 0;
X  }
X  
X+ /* If you have moved since initially setting some occupations, they
X+  * now shouldn't be able to restart.
X+  *
X+  * The basic rule is that if you are carrying it, you can continue
X+  * since it is with you.  If you are acting on something at a distance,
X+  * your orientation to it must have changed when you moved.
X+  *
X+  * The exception to this is taking off items, since they can be taken
X+  * off in a number of ways in the intervening time, screwing up ordering.
X+  *
X+  *	Currently:	Take off all armor.
X+  *			Picking Locks / Forcing Chests.
X+  */
X+ void
X+ reset_occupations() {
X+ 
X+ 	reset_remarm();
X+ 	reset_pick();
X+ }
X+ 
X  /* If a time is given, use it to timeout this function, otherwise the
X   * function times out by its own means.
X   */
X***************
X*** 417,443 ****
X  }
X  #endif /* WIZARD || EXPLORE_MODE */
X  
X  const struct func_tab cmdlist[]={
X! 	{'\004', /* ^D */ dokick},	/* "D" is for door!...? */
X  #ifdef WIZARD
X! 	{'\005', /* ^E */ wiz_detect},
X! 	{'\006', /* ^F */ wiz_map},
X! 	{'\007', /* ^G */ wiz_genesis},
X! 	{'\011', /* ^I */ wiz_identify},
X! 	{'\017', /* ^O */ wiz_where},
X  #endif
X! 	{'\020', /* ^P */ doredotopl},
X! 	{'\022', /* ^R */ doredraw},
X! 	{'\024', /* ^T */ dotele},
X  #ifdef WIZARD
X! 	{'\026', /* ^V */ wiz_level_tele},
X! 	{'\027', /* ^W */ wiz_wish},
X  #endif
X  #if defined(WIZARD) || defined(EXPLORE_MODE)
X! 	{'\030', /* ^X */ wiz_attributes},
X  #endif
X  #ifdef SUSPEND
X! 	{'\032', /* ^Z */ dosuspend},
X  #endif
X  	{'a', doapply},
X  	{'A', doddoremarm},
X--- 437,465 ----
X  }
X  #endif /* WIZARD || EXPLORE_MODE */
X  
X+ #define M(c)		(0x80 | (c))
X+ #define C(c)		(0x1f & (c))
X  const struct func_tab cmdlist[]={
X! 	{C('d'), dokick},	/* "D" is for door!...? */
X  #ifdef WIZARD
X! 	{C('e'), wiz_detect},
X! 	{C('f'), wiz_map},
X! 	{C('g'), wiz_genesis},
X! 	{C('i'), wiz_identify},
X! 	{C('o'), wiz_where},
X  #endif
X! 	{C('p'), doredotopl},
X! 	{C('r'), doredraw},
X! 	{C('t'), dotele},
X  #ifdef WIZARD
X! 	{C('v'), wiz_level_tele},
X! 	{C('w'), wiz_wish},
X  #endif
X  #if defined(WIZARD) || defined(EXPLORE_MODE)
X! 	{C('x'), wiz_attributes},
X  #endif
X  #ifdef SUSPEND
X! 	{C('z'), dosuspend},
X  #endif
X  	{'a', doapply},
X  	{'A', doddoremarm},
X***************
X*** 444,451 ****
X--- 466,475 ----
X  /*	'b', 'B' : go sw */
X  	{'c', doclose},
X  	{'C', do_mname},
X+ 	{M('c'), dotalk},
X  	{'d', dodrop},
X  	{'D', doddrop},
X+ 	{M('d'), dodip},
X  	{'e', doeat},
X  	{'E', doengrave},
X  /* Soon to be
X***************
X*** 452,457 ****
X--- 476,482 ----
X  	{'f', dofight, "fighting"},
X  	{'F', doFight, "fighting"},
X   */
X+ 	{M('f'), doforce},
X  /*	'g', 'G' : multiple go */
X  /*	'h', 'H' : go west */
X  	{'h', dohelp}, /* if number_pad is set */
X***************
X*** 459,486 ****
X--- 484,528 ----
X  	{'I', dotypeinv},		/* Robert Viduya */
X  /*	'j', 'J', 'k', 'K', 'l', 'L', 'm', 'M', 'n', 'N' : move commands */
X  	{'j', dojump}, /* if number_pad is on */
X+ 	{M('j'), dojump},
X  	{'k', dokick}, /* if number_pad is on */
X  	{'l', doloot}, /* if number_pad is on */
X+ 	{M('l'), doloot},
X  /*	'n' prefixes a count if number_pad is on */
X+ #ifdef POLYSELF
X+ 	{M('m'), domonability},
X+ #endif /* POLYSELF */
X  	{'N', ddocall}, /* if number_pad is on */
X+ 	{M('N'), ddocall},
X  	{'o', doopen},
X  	{'O', doset},
X+ #ifdef THEOLOGY
X+ 	{M('o'), dosacrifice},
X+ #endif /* THEOLOGY */
X  	{'p', dopay},
X  	{'P', doputon},
X+ #ifdef THEOLOGY
X+ 	{M('p'), dopray},
X+ #endif /* THEOLOGY */
X  	{'q', dodrink},
X  	{'Q', done2},
X  	{'r', doread},
X  	{'R', doremring},
X+ 	{M('r'), dorub},
X  	{'s', dosearch, "searching"},
X  	{'S', dosave},
X+ 	{M('s'), dosit},
X  	{'t', dothrow},
X  	{'T', dotakeoff},
X+ 	{M('t'), doturn},
X  /*	'u', 'U' : go ne */
X  	{'u', dountrap}, /* if number_pad is on */
X+ 	{M('u'), dountrap},
X  	{'v', doversion},
X  	{'V', dohistory},
X  	{'w', dowield},
X  	{'W', dowear},
X+ 	{M('w'), dowipe},
X  #ifdef SPELLS
X  	{'x', dovspell},			/* Mike Stephenson */
X  #endif
X***************
X*** 516,521 ****
X--- 558,565 ----
X  	{'#', doextcmd},
X  	{0,0,0}
X  };
X+ #undef M
X+ #undef C
X  
X  const struct ext_func_tab extcmdlist[] = {
X  	"chat", "talk to someone", dotalk,	/* converse? */
X***************
X*** 618,624 ****
X  		goto rush;
X  	}
X  	while(tlist->f_char) {
X! 		if(*cmd == tlist->f_char){
X  			/* Special case of *cmd == ' ' handled here */
X  			if (*cmd == ' ' && flags.no_rest_on_space)
X  				break;
X--- 662,668 ----
X  		goto rush;
X  	}
X  	while(tlist->f_char) {
X! 		if((*cmd & 0xff) == (tlist->f_char & 0xff)){
X  			/* Special case of *cmd == ' ' handled here */
X  			if (*cmd == ' ' && flags.no_rest_on_space)
X  				break;
X***************
X*** 642,647 ****
X--- 686,696 ----
X  	  while(*cmd && cp-expcmd < sizeof(expcmd)-2) {
X  		if(*cmd >= 040 && *cmd < 0177)
X  			*cp++ = *cmd++;
X+ 		else if (*cmd & 0200) {
X+ 			*cp++ = 'M';
X+ 			*cp++ = '-';
X+ 			*cp++ = *cmd++ &=~ 0200;
X+ 		}
X  		else {
X  			*cp++ = '^';
X  			*cp++ = *cmd++ ^ 0100;
X*** src/Old/dbridge.c	Wed Aug 16 12:13:20 1989
X--- src/dbridge.c	Tue Aug 15 20:34:01 1989
X***************
X*** 62,76 ****
X  	struct rm *lev;
X  
X  	lev = &levl[x][y];
X! 	if ( lev->typ == VWALL || lev->typ == DOOR) {
X! 		if (IS_DRAWBRIDGE(levl[x+1][y].typ) && 
X! 		    (levl[x+1][y].drawbridgemask & DB_DIR) == DB_WEST)
X  			return (DB_WEST);
X  		if (IS_DRAWBRIDGE(levl[x-1][y].typ) && 
X  		    (levl[x-1][y].drawbridgemask & DB_DIR) == DB_EAST)
X  			return (DB_EAST);
X! 	}
X! 	if ( lev->typ == HWALL || lev->typ == DOOR) {
X  		if (IS_DRAWBRIDGE(levl[x][y-1].typ) && 
X  		    (levl[x][y-1].drawbridgemask & DB_DIR) == DB_SOUTH)
X  			return (DB_SOUTH);
X--- 62,80 ----
X  	struct rm *lev;
X  
X  	lev = &levl[x][y];
X! 	if (lev->typ != DOOR && !(lev->diggable & W_GATEWAY))
X! 		return (-1);
X! 	switch (lev->typ) {
X! 	    case DOOR:
X! 	    case VWALL:
X! 		if (IS_DRAWBRIDGE(levl[x+1][y].typ) &&
X!  		    (levl[x+1][y].drawbridgemask & DB_DIR) == DB_WEST)
X  			return (DB_WEST);
X  		if (IS_DRAWBRIDGE(levl[x-1][y].typ) && 
X  		    (levl[x-1][y].drawbridgemask & DB_DIR) == DB_EAST)
X  			return (DB_EAST);
X! 		if (lev->typ == VWALL) break;
X! 	    case HWALL:
X  		if (IS_DRAWBRIDGE(levl[x][y-1].typ) && 
X  		    (levl[x][y-1].drawbridgemask & DB_DIR) == DB_SOUTH)
X  			return (DB_SOUTH);
X***************
X*** 252,258 ****
X  
X  		You("are crushed by a falling portcullis.");
X  		killer = "closing drawbridge";
X! 		done("died");
X  		/* So, you didn't die */
X  		pline("A %s force teleports you away...",
X  		      Hallucination ? "normal" : "strange");
X--- 256,262 ----
X  
X  		You("are crushed by a falling portcullis.");
X  		killer = "closing drawbridge";
X! 		done(CRUSHING);
X  		/* So, you didn't die */
X  		pline("A %s force teleports you away...",
X  		      Hallucination ? "normal" : "strange");
X***************
X*** 295,301 ****
X  			newsym(x2,y2);
X  		You("are hit by the descending drawbridge!");
X  		killer = "descending drawbridge";
X! 		done("died");
X  	}
X  	redosym(x,y);
X  	redosym(x2,y2);
X--- 299,305 ----
X  			newsym(x2,y2);
X  		You("are hit by the descending drawbridge!");
X  		killer = "descending drawbridge";
X! 		done(CRUSHING);
X  	}
X  	redosym(x,y);
X  	redosym(x2,y2);
X***************
X*** 354,360 ****
X  
X  		You("are crushed by a falling portcullis.");
X  		killer = "collapsing drawbridge";
X! 		done("died");
X  		/* So, you didn't die */
X  		pline("A %s force teleports you away...",
X  		      Hallucination ? "normal" : "strange");
X--- 358,364 ----
X  
X  		You("are crushed by a falling portcullis.");
X  		killer = "collapsing drawbridge";
X! 		done(CRUSHING);
X  		/* So, you didn't die */
X  		pline("A %s force teleports you away...",
X  		      Hallucination ? "normal" : "strange");
X*** src/Old/decl.c	Wed Aug 16 12:13:39 1989
X--- src/decl.c	Fri Aug 11 17:05:27 1989
X***************
X*** 71,78 ****
X  	/* set up in termcap.c */
X  int CO = 0, LI = 0;	/* set up in termcap.c: usually COLNO and ROWNO+3 */
X  
X! #ifdef MSDOSCOLOR
X! char *HI_RED, *HI_YELLOW, *HI_GREEN, *HI_BLUE, *HI_WHITE; /* termcap.c */
X  #endif
X  
X  #ifdef MSDOS
X--- 71,78 ----
X  	/* set up in termcap.c */
X  int CO = 0, LI = 0;	/* set up in termcap.c: usually COLNO and ROWNO+3 */
X  
X! #ifdef TEXTCOLOR
X! char *HI_COLOR[8];		/* terminal escapes for the various colors */
X  #endif
X  
X  #ifdef MSDOS
X*** src/Old/demon.c	Wed Aug 16 12:13:54 1989
X--- src/demon.c	Tue Aug 15 22:05:37 1989
X***************
X*** 10,15 ****
X--- 10,16 ----
X  {
X  	register int dtype, cnt = 0;
X  
X+ #ifdef HARD
X  	if(is_dprince(ptr) || (ptr == &mons[PM_WIZARD_OF_YENDOR])) {
X  
X  	    dtype = (!rn2(20)) ? dprince() : (!rn2(4)) ? dlord() : ndemon();
X***************
X*** 27,32 ****
X--- 28,37 ----
X  	}
X  
X  	if(!dtype) return;
X+ #else
X+ 	dtype = PM_DEMON;
X+ 	cnt = 1;
X+ #endif
X  
X  	while(cnt > 0) {
X  
X***************
X*** 100,110 ****
X  }
X  #endif
X  
X! #if defined(HARD) || (defined(ALTARS) && defined(SOUNDS))
X  long
X  bribe(mtmp)
X! 
X! 	struct monst *mtmp;
X  {
X  	char buf[80];
X  	long offer;
X--- 105,114 ----
X  }
X  #endif
X  
X! #if defined(HARD) || (defined(ALTARS) && defined(THEOLOGY))
X  long
X  bribe(mtmp)
X! struct monst *mtmp;
X  {
X  	char buf[80];
X  	long offer;
X***************
X*** 118,127 ****
X   		You("try to shortchange %s, but fumble.", 
X   			x_monnam(mtmp, 0));
X   		offer = 0L;
X   	} else if(offer >= u.ugold) {
X  		You("give %s all your gold.", x_monnam(mtmp, 0));
X  		offer = u.ugold;
X! 	} else You("give %s %ld Zorkmids.", x_monnam(mtmp, 0), offer);
X  
X  	u.ugold -= offer;
X  	return(offer);
X--- 122,134 ----
X   		You("try to shortchange %s, but fumble.", 
X   			x_monnam(mtmp, 0));
X   		offer = 0L;
X+  	} else if(offer == 0L) {
X+ 		You("refuse.");
X   	} else if(offer >= u.ugold) {
X  		You("give %s all your gold.", x_monnam(mtmp, 0));
X  		offer = u.ugold;
X! 	} else You("give %s %ld Zorkmid%s.", x_monnam(mtmp, 0), offer,
X! 		   offer == 1 ? "" : "s");
X  
X  	u.ugold -= offer;
X  	return(offer);
X***************
X*** 131,166 ****
X  int
X  dprince() {
X  #ifdef HARD
X! 	int	tryct;
X! 	struct	permonst *ptr;
X! 
X! 	for(tryct = 0; tryct < 20; tryct++)
X! 	    if(is_dprince((ptr = mkclass(S_DEMON))))
X! 		return(monsndx(ptr));
X  
X  #endif
X- 	return(dlord());
X  }
X  
X  int
X  dlord() {
X  #ifdef HARD
X! 	int	tryct;
X! 	struct	permonst *ptr;
X! 
X! 	for(tryct = 0; tryct < 20; tryct++)
X! 	    if(is_dlord((ptr = mkclass(S_DEMON))))
X! 		return(monsndx(ptr));
X  
X  #endif
X- 	return(ndemon());
X  }
X  
X  int
X  ndemon() {
X! #ifndef HARD
X! 	return(PM_DEMON);
X! #else
X  	int	tryct;
X  	struct	permonst *ptr;
X  
X--- 138,175 ----
X  int
X  dprince() {
X  #ifdef HARD
X! 	int	tryct, pm;
X  
X+ 	for(tryct = 0; tryct < 20; tryct++) {
X+ 	    pm = rn1(PM_DEMOGORGON + 1 - PM_ORCUS, PM_ORCUS);
X+ 	    if(!(mons[pm].geno & G_GENOD))
X+ 		return(pm);
X+ 	}
X+ 	return(dlord());	/* approximate */
X+ #else
X+ 	return(PM_DEMON);
X  #endif
X  }
X  
X  int
X  dlord() {
X  #ifdef HARD
X! 	int	tryct, pm;
X  
X+ 	for(tryct = 0; tryct < 20; tryct++) {
X+ 	    pm = rn1(PM_YEENOGHU + 1 - PM_JUIBLEX, PM_JUIBLEX);
X+ 	    if(!(mons[pm].geno & G_GENOD))
X+ 		return(pm);
X+ 	}
X+ 	return(ndemon());	/* approximate */
X+ #else
X+ 	return(PM_DEMON);
X  #endif
X  }
X  
X  int
X  ndemon() {
X! #ifdef HARD
X  	int	tryct;
X  	struct	permonst *ptr;
X  
X***************
X*** 169,173 ****
X--- 178,184 ----
X  		return(monsndx(ptr));
X  
X  	return(0);
X+ #else
X+ 	return(PM_DEMON);
X  #endif
X  }
X*** src/Old/do.c	Fri Jul 28 01:58:01 1989
X--- src/do.c	Wed Aug 16 22:13:57 1989
X***************
X*** 285,291
X  		/* turn water into [(un)holy] water */
X  		if (obj->otyp == POT_WATER) {
X  			obj->blessed = !!(levl[u.ux][u.uy].altarmask & A_LAW);
X! 			obj->cursed = !!(levl[u.ux][u.uy].altarmask & A_CHAOS);
X  		}
X  		doaltarobj(obj);	/* set bknown */
X  	} else
X
X--- 285,292 -----
X  		/* turn water into [(un)holy] water */
X  		if (obj->otyp == POT_WATER) {
X  			obj->blessed = !!(levl[u.ux][u.uy].altarmask & A_LAW);
X! 			obj->cursed =
X! 			    !(levl[u.ux][u.uy].altarmask & (A_LAW | A_NEUTRAL));
X  		}
X  		doaltarobj(obj);	/* set bknown */
X  	} else
X***************
X*** 342,347
X  dodown()
X  {
X  	struct trap *trap = 0;
X  #ifdef STRONGHOLD
X  	if((u.ux != xdnstair || u.uy != ydnstair) &&
X  	   (!xdnladder || u.ux != xdnladder || u.uy != ydnladder)) {
X
X--- 343,350 -----
X  dodown()
X  {
X  	struct trap *trap = 0;
X+ 
X+ 	if((u.ux != xdnstair || u.uy != ydnstair)
X  #ifdef STRONGHOLD
X  	   && (!xdnladder || u.ux != xdnladder || u.uy != ydnladder)
X  #endif
X***************
X*** 343,353
X  {
X  	struct trap *trap = 0;
X  #ifdef STRONGHOLD
X! 	if((u.ux != xdnstair || u.uy != ydnstair) &&
X! 	   (!xdnladder || u.ux != xdnladder || u.uy != ydnladder)) {
X! #else
X! 	if(u.ux != xdnstair || u.uy != ydnstair) {
X! #endif /* STRONGHOLD /**/
X  		if (!(trap = t_at(u.ux,u.uy)) || trap->ttyp != TRAPDOOR
X  							|| !trap->tseen) {
X  			You("can't go down here.");
X
X--- 346,354 -----
X  
X  	if((u.ux != xdnstair || u.uy != ydnstair)
X  #ifdef STRONGHOLD
X! 	   && (!xdnladder || u.ux != xdnladder || u.uy != ydnladder)
X! #endif
X! 	  ) {
X  		if (!(trap = t_at(u.ux,u.uy)) || trap->ttyp != TRAPDOOR
X  							|| !trap->tseen) {
X  			You("can't go down here.");
X***************
X*** 364,370
X  		      levl[u.ux][u.uy].typ == STAIRS ? "stairs" : "ladder");
X  #else
X  		pline("You're floating high above the stairs.");
X! #endif /* STRONGHOLD /**/
X  		return(0);
X  	}
X  
X
X--- 365,371 -----
X  		      levl[u.ux][u.uy].typ == STAIRS ? "stairs" : "ladder");
X  #else
X  		pline("You're floating high above the stairs.");
X! #endif
X  		return(0);
X  	}
X  
X***************
X*** 393,398
X  int
X  doup()
X  {
X  #ifdef STRONGHOLD
X  	if((u.ux != xupstair || u.uy != yupstair) &&
X  	   (!xupladder || u.ux != xupladder || u.uy != yupladder)) {
X
X--- 394,400 -----
X  int
X  doup()
X  {
X+ 	if((u.ux != xupstair || u.uy != yupstair)
X  #ifdef STRONGHOLD
X  	   && (!xupladder || u.ux != xupladder || u.uy != yupladder)
X  #endif
X***************
X*** 394,404
X  doup()
X  {
X  #ifdef STRONGHOLD
X! 	if((u.ux != xupstair || u.uy != yupstair) &&
X! 	   (!xupladder || u.ux != xupladder || u.uy != yupladder)) {
X! #else
X! 	if(u.ux != xupstair || u.uy != yupstair) {
X! #endif /* STRONGHOLD /**/
X  		You("can't go up here.");
X  		return(0);
X  	}
X
X--- 396,404 -----
X  {
X  	if((u.ux != xupstair || u.uy != yupstair)
X  #ifdef STRONGHOLD
X! 	   && (!xupladder || u.ux != xupladder || u.uy != yupladder)
X! #endif
X! 	  ) {
X  		You("can't go up here.");
X  		return(0);
X  	}
X***************
X*** 413,419
X  		      levl[u.ux][u.uy].typ == STAIRS ? "stairs" : "ladder");
X  #else
X  		Your("load is too heavy to climb the stairs.");
X! #endif /* STRONGHOLD /**/
X  		return(1);
X  	}
X  
X
X--- 413,419 -----
X  		      levl[u.ux][u.uy].typ == STAIRS ? "stairs" : "ladder");
X  #else
X  		Your("load is too heavy to climb the stairs.");
X! #endif
X  		return(1);
X  	}
X  
X***************
X*** 464,470
X  		newlevel = ENDLEVEL;	/* Endgame Level !!! */
X  	    else
X  #endif
X! 		done("escaped");    /* in fact < 0 is impossible */
X  
X  /*	If you have the amulet and are trying to get out of Hell, going
X   *	up a set of stairs sometimes does some very strange things!
X
X--- 464,470 -----
X  		newlevel = ENDLEVEL;	/* Endgame Level !!! */
X  	    else
X  #endif
X! 		done(ESCAPED);		/* in fact < 0 is impossible */
X  
X  /*	If you have the amulet and are trying to get out of Hell, going
X   *	up a set of stairs sometimes does some very strange things!
X***************
X*** 510,516
X  		You("die...");
X  		dlevel = maxdlevel = newlevel;
X  		killer = "visit to hell";
X! 		done("burned");
X  		dlevel = newlevel = save_dlevel; /* in case they survive */
X  	    }
X  	}
X
X--- 510,516 -----
X  		You("die...");
X  		dlevel = maxdlevel = newlevel;
X  		killer = "visit to hell";
X! 		done(BURNING);
X  		dlevel = newlevel = save_dlevel; /* in case they survive */
X  	    }
X  	}
X***************
X*** 615,621
X  #endif
X  			pline("Cannot open %s .", lock);
X  			pline("Probably someone removed it.");
X! 			done("tricked");
X  		}
X  #ifdef ZEROCOMP
X  		minit();
X
X--- 615,621 -----
X  #endif
X  			pline("Cannot open %s .", lock);
X  			pline("Probably someone removed it.");
X! 			done(TRICKED);
X  		}
X  #ifdef ZEROCOMP
X  		minit();
X***************
X*** 734,739
X  	if (dlevel == 1 && u.uhave_amulet && flags.no_of_wizards == 0)
X  	    resurrect();
X  #endif
X  }
X  
X  int
X
X--- 734,740 -----
X  	if (dlevel == 1 && u.uhave_amulet && flags.no_of_wizards == 0)
X  	    resurrect();
X  #endif
X+ 	is_maze_lev = !xdnstair;
X  }
X  
X  int
X*** src/Old/do_name.c	Wed Aug 16 12:14:43 1989
X--- src/do_name.c	Fri Aug 11 16:42:20 1989
X***************
X*** 34,41 ****
X  	register int cx, cy, i, c;
X  	char *sdp = flags.num_pad ? ndir : sdir;
X  	if(flags.verbose) pline("(For instructions type a ?)");
X! 	cx = u.ux;
X! 	cy = u.uy;
X  	curs(cx,cy+2);
X  	while((c = readchar()) != '.'){
X  		for(i=0; i<8; i++) if(sdp[i] == c){
X--- 34,41 ----
X  	register int cx, cy, i, c;
X  	char *sdp = flags.num_pad ? ndir : sdir;
X  	if(flags.verbose) pline("(For instructions type a ?)");
X! 	cx = cc->x;
X! 	cy = cc->y;
X  	curs(cx,cy+2);
X  	while((c = readchar()) != '.'){
X  		for(i=0; i<8; i++) if(sdp[i] == c){
X***************
X*** 46,58 ****
X  			goto nxtc;
X  		}
X  		if(c == '?'){
X- 		    if(flags.verbose) {
X  			pline("Use [%s] to move the cursor to %s.",
X  			      flags.num_pad ? "2468" : "hjkl", goal);
X  			pline("Type a . when you are at the right place.");
X- 		    }
X  		} else {
X! 			pline("Unknown direction: '%s' (%s).",
X  				visctrl(c),
X  				force ?
X  				    flags.num_pad ? "use 2468 or ." :
X--- 46,57 ----
X  			goto nxtc;
X  		}
X  		if(c == '?'){
X  			pline("Use [%s] to move the cursor to %s.",
X  			      flags.num_pad ? "2468" : "hjkl", goal);
X  			pline("Type a . when you are at the right place.");
X  		} else {
X! 			if (!index(quitchars, c))
X! 			    pline("Unknown direction: '%s' (%s).",
X  				visctrl(c),
X  				force ?
X  				    flags.num_pad ? "use 2468 or ." :
X***************
X*** 80,85 ****
X--- 79,86 ----
X  	register char *curr;
X  	boolean blank;
X  
X+ 	cc.x = u.ux;
X+ 	cc.y = u.uy;
X  	getpos(&cc, 0, "the monster you want to name");
X  	cx = cc.x;
X  	cy = cc.y;
X*** src/Old/do_wear.c	Wed Aug 16 12:15:06 1989
X--- src/do_wear.c	Tue Aug 15 18:49:53 1989
X***************
X*** 520,526 ****
X  #endif
X  		break;
X  	case RIN_SEE_INVISIBLE:
X! 		if (Invisible && !Blind) {
X  			newsym(u.ux,u.uy);
X  			pline("Suddenly you can see yourself.");
X  			makeknown(RIN_SEE_INVISIBLE);
X--- 520,530 ----
X  #endif
X  		break;
X  	case RIN_SEE_INVISIBLE:
X! 		if (Invis && !oldprop
X! #ifdef POLYSELF
X! 				&& !perceives(uasmon)
X! #endif
X! 							&& !Blind) {
X  			newsym(u.ux,u.uy);
X  			pline("Suddenly you can see yourself.");
X  			makeknown(RIN_SEE_INVISIBLE);
X***************
X*** 739,744 ****
X--- 743,749 ----
X  		pline("The bear trap prevents you from pulling your foot out.");
X  		return(0);
X  	}
X+ 	reset_remarm();			/* since you may change ordering */
X  	(void) armoroff(otmp);
X  	return(1);
X  }
X***************
X*** 1386,1391 ****
X--- 1391,1399 ----
X  	return(1);		/* get busy */
X  }
X  
X+ void
X+ reset_remarm() { taking_off = takeoff_mask =0L; }
X+ 
X  int
X  doddoremarm() {
X  
X***************
X*** 1399,1404 ****
X--- 1407,1453 ----
X  	(void) ggetobj("take off", select_off, 0);
X  	if(takeoff_mask) return(take_off());
X  	else		 return(0);
X+ }
X+ 
X+ int
X+ destroy_arm(atmp)
X+ register struct obj *atmp;
X+ {
X+ 	register struct obj *otmp;
X+ 
X+ 	if((otmp = uarmc) && (!atmp || atmp == uarmc)) {
X+ 		Your("cloak crumbles and turns to dust!");
X+ 		(void) Cloak_off();
X+ 		useup(otmp);
X+ 	} else if((otmp = uarm) && (!atmp || atmp == uarm)) {
X+ 		Your("armor turns to dust and falls to the floor!");
X+ 		(void) Armor_gone();
X+ 		useup(otmp);
X+ #ifdef SHIRT
X+ 	} else if((otmp = uarmu) && (!atmp || atmp == uarmu)) {
X+ 		Your("shirt crumbles into tiny threads and falls apart!");
X+ 		useup(otmp);
X+ #endif
X+ 	} else if((otmp = uarmh) && (!atmp || atmp == uarmh)) {
X+ 		Your("helmet turns to dust and is blown away!");
X+ 		(void) Helmet_off();
X+ 		useup(otmp);
X+ 	} else if((otmp = uarmg) && (!atmp || atmp == uarmg)) {
X+ 		Your("gloves vanish!");
X+ 		(void) Gloves_off();
X+ 		useup(otmp);
X+ 		selftouch("You");
X+ 	} else if((otmp = uarmf) && (!atmp || atmp == uarmf)) {
X+ 		Your("boots disintegrate!");
X+ 		(void) Boots_off();
X+ 		useup(otmp);
X+ 	} else if((otmp =uarms) && (!atmp || atmp == uarms)) {
X+ 		Your("shield crumbles away!");
X+ 		(void) Shield_off();
X+ 		useup(otmp);
X+ 	} else 	return(0);		/* could not destroy anything */
X+ 
X+ 	return(1);
X  }
X  
X  void
X*** src/Old/dog.c	Thu Aug  3 08:44:30 1989
X--- src/dog.c	Fri Aug 18 08:13:38 1989
X***************
X*** 129,135 ****
X  			mtmp0->nmon = mtmp->nmon;
X  		    mtmp->nmon = fmon;
X  		    fmon = mtmp;
X! 		    if (mtmp->isshk)
X  			home_shk(mtmp);
X  		    else
X  			rloc(mtmp);
X--- 129,143 ----
X  			mtmp0->nmon = mtmp->nmon;
X  		    mtmp->nmon = fmon;
X  		    fmon = mtmp;
X! 		    if (mtmp->data->geno & G_GENOD) {
X! #ifdef KOPS
X! 			allow_kops = FALSE;
X! #endif
X! 			mondead(mtmp);	/* must put in fmon list first */
X! #ifdef KOPS
X! 			allow_kops = TRUE;
X! #endif
X! 		    } else if (mtmp->isshk)
X  			home_shk(mtmp);
X  		    else
X  			rloc(mtmp);
X***************
X*** 215,221 ****
X  struct monst *mon;
X  register struct obj *obj;
X  {
X! 	boolean carn = carnivorous(mon->data);
X  
X  	switch(obj->olet) {
X  	case FOOD_SYM:
X--- 223,230 ----
X  struct monst *mon;
X  register struct obj *obj;
X  {
X! 	boolean carni = carnivorous(mon->data);
X! 	boolean herbi = herbivorous(mon->data);
X  
X  	switch(obj->olet) {
X  	case FOOD_SYM:
X***************
X*** 223,249 ****
X  		!resists_ston(mon->data))
X  		    return TABU;
X  
X! 	    if (!carn && !herbivorous(mon->data))
X  		    return (obj->cursed ? UNDEF : APPORT);
X  
X  	    switch (obj->otyp) {
X  		case TRIPE_RATION:
X! 		    return (carn ? DOGFOOD : MANFOOD);
X  		case EGG:
X  		    if (obj->corpsenm == PM_COCKATRICE &&
X  						!resists_ston(mon->data))
X  			return POISON;
X! 		    return (carn ? CADAVER : MANFOOD);
X  		case CORPSE:
X  		    if ((obj->age+50 <= moves && mon->data->mlet != S_FUNGUS) ||
X  			(poisonous(&mons[obj->corpsenm]) &&
X  						!resists_poison(mon->data)))
X  			return POISON;
X! 		    else return (carn ? CADAVER : MANFOOD);
X  		case DEAD_LIZARD:
X! 		    return (carn ? ACCFOOD : MANFOOD);
X  		default:
X! 		    return (obj->otyp < CARROT ? ACCFOOD : MANFOOD);
X  	    }
X  	default:
X  	    if(!obj->cursed) return(APPORT);
X--- 232,272 ----
X  		!resists_ston(mon->data))
X  		    return TABU;
X  
X! 	    if (!carni && !herbi)
X  		    return (obj->cursed ? UNDEF : APPORT);
X  
X  	    switch (obj->otyp) {
X  		case TRIPE_RATION:
X! 		    return (carni ? DOGFOOD : MANFOOD);
X  		case EGG:
X  		    if (obj->corpsenm == PM_COCKATRICE &&
X  						!resists_ston(mon->data))
X  			return POISON;
X! 		    return (carni ? CADAVER : MANFOOD);
X  		case CORPSE:
X  		    if ((obj->age+50 <= moves && mon->data->mlet != S_FUNGUS) ||
X  			(poisonous(&mons[obj->corpsenm]) &&
X  						!resists_poison(mon->data)))
X  			return POISON;
X! 		    else return (carni ? CADAVER : MANFOOD);
X  		case DEAD_LIZARD:
X! 		    return (carni ? ACCFOOD : MANFOOD);
X! 		case CLOVE_OF_GARLIC:
X! 		    return (is_undead(mon->data) ? TABU :
X! 			    (herbi ? ACCFOOD : MANFOOD));
X! 		case TIN:
X! 		    return MANFOOD;
X! 		case APPLE:
X! 		case CARROT:
X! 		    return (herbi ? DOGFOOD : MANFOOD);
X  		default:
X! #ifdef SLIME_MOLD
X! 		    return (obj->otyp > SLIME_MOLD ?
X! #else
X! 		    return (obj->otyp > CLOVE_OF_GARLIC ?
X! #endif
X! 			    (carni ? ACCFOOD : MANFOOD) :
X! 			    (herbi ? ACCFOOD : MANFOOD));
X  	    }
X  	default:
X  	    if(!obj->cursed) return(APPORT);
X***************
X*** 302,311 ****
X  	   or get in your way */
X  	if(obj) {
X  		if(dogfood(mtmp, obj) >= MANFOOD) return(0);
X! 		if(cansee(mtmp->mx,mtmp->my)){
X! 			pline("%s devours the %s.", Monnam(mtmp),
X! 				objects[obj->otyp].oc_name);
X! 		}
X  		obfree(obj, (struct obj *)0);
X  	}
X  	mtmp2 = newmonst(sizeof(struct edog) + mtmp->mnamelth);
X--- 325,332 ----
X  	   or get in your way */
X  	if(obj) {
X  		if(dogfood(mtmp, obj) >= MANFOOD) return(0);
X! 		if(cansee(mtmp->mx,mtmp->my))
X! 			pline("%s devours the %s.", Monnam(mtmp), xname(obj));
X  		obfree(obj, (struct obj *)0);
X  	}
X  	mtmp2 = newmonst(sizeof(struct edog) + mtmp->mnamelth);
X*** src/Old/dogmove.c	Wed Aug 16 12:16:10 1989
X--- src/dogmove.c	Tue Aug 15 18:49:35 1989
X***************
X*** 173,179 ****
X  		if(appr == 0){
X  			obj = invent;
X  			while(obj){
X! 				if(obj->otyp == TRIPE_RATION){
X  					appr = 1;
X  					break;
X  				}
X--- 173,179 ----
X  		if(appr == 0){
X  			obj = invent;
X  			while(obj){
X! 				if(dogfood(mtmp, obj) == DOGFOOD) {
X  					appr = 1;
X  					break;
X  				}
X***************
X*** 216,222 ****
X  
X  			    if(mtmp2->m_lev >= mtmp->m_lev+2 ||
X  			       (mtmp2->data->mlet == S_COCKATRICE &&
X! 				!(mtmp->data->mflags1 & M1_STON_RES)))
X  				continue;
X  			    if(after) return(0); /* hit only once each move */
X  
X--- 216,222 ----
X  
X  			    if(mtmp2->m_lev >= mtmp->m_lev+2 ||
X  			       (mtmp2->data->mlet == S_COCKATRICE &&
X! 				!resists_ston(mtmp->data)))
X  				continue;
X  			    if(after) return(0); /* hit only once each move */
X  
X*** src/Old/dokick.c	Wed Aug 16 12:16:29 1989
X--- src/dokick.c	Wed Aug 16 10:31:40 1989
X***************
X*** 50,56 ****
X  		mon->mhp -= (!martial() ? rnd(dmg) :
X  			rnd(dmg)+rnd(ACURR(A_DEX)/2));  
X  	if(mon->mhp < 1) {
X! 		(void) passive(mon, TRUE, 0);
X  		killed(mon);
X  		return;
X  	}
X--- 50,56 ----
X  		mon->mhp -= (!martial() ? rnd(dmg) :
X  			rnd(dmg)+rnd(ACURR(A_DEX)/2));  
X  	if(mon->mhp < 1) {
X! 		(void) passive(mon, TRUE, 0, TRUE);
X  		killed(mon);
X  		return;
X  	}
X***************
X*** 68,74 ****
X  			set_apparxy(mon);
X  	    	}
X  	}
X! 	(void) passive(mon, FALSE, 1);
X  
X  /*	it is unchivalrous to attack the defenseless or from behind */
X  	if (pl_character[0] == 'K' && u.ualigntyp == U_LAWFUL && 
X--- 68,74 ----
X  			set_apparxy(mon);
X  	    	}
X  	}
X! 	(void) passive(mon, FALSE, 1, TRUE);
X  
X  /*	it is unchivalrous to attack the defenseless or from behind */
X  	if (pl_character[0] == 'K' && u.ualigntyp == U_LAWFUL && 
X***************
X*** 85,90 ****
X--- 85,120 ----
X  	register struct monst *mon = m_at(x, y);
X  	register int i, j;
X  
X+ 	if(special_case(mon)) return;
X+ 	setmangry(mon);
X+ #ifdef POLYSELF
X+ 	/* Kick attacks by kicking monsters are normal attacks, not special.
X+ 	 * If you have >1 kick attack, you get all of them.
X+ 	 */
X+ 	if (attacktype(uasmon, AT_KICK)) {
X+ 	    schar tmp = find_roll_to_hit(mon);
X+ 	    for(i=0; i<NATTK; i++) {
X+ 		int sum = 0;
X+ 		if (uasmon->mattk[i].aatyp == AT_KICK && multi >= 0) {
X+ 		    /* check multi; maybe they had 2 kicks and the first */
X+ 		    /* was a kick against a floating eye */
X+ 		    j = 1;
X+ 		    if (tmp > rnd(20)) {
X+ 			kludge("You kick %s.", mon_nam(mon));
X+ 			sum = damageum(mon, &(uasmon->mattk[i]));
X+ 			if (sum == 2)
X+ 				(void)passive(mon, 1, 0, TRUE);
X+ 			else (void)passive(mon, sum, 1, TRUE);
X+ 		    } else {
X+ 			missum(mon, &(uasmon->mattk[i]));
X+ 			(void)passive(mon, 0, 1, TRUE);
X+ 		    }
X+ 		}
X+ 	    }
X+ 	    return;
X+ 	}
X+ #endif
X+ 
X  	/* no need to check POLYSELF since only ghosts, which you can't turn */
X  	/* into, are noncorporeal */
X  	if(noncorporeal(mon->data)) {
X***************
X*** 92,105 ****
X  		return;
X  	}
X  
X- 	if(special_case(mon)) return;
X- 
X- 	setmangry(mon);
X- 
X  	if(Levitation && !rn2(3) && verysmall(mon->data) &&
X  	   !is_flyer(mon->data)) {
X  		pline("Floating in the air, you miss wildly!");
X! 		(void) passive(mon, FALSE, 1);
X  		return;
X  	}
X  
X--- 122,131 ----
X  		return;
X  	}
X  
X  	if(Levitation && !rn2(3) && verysmall(mon->data) &&
X  	   !is_flyer(mon->data)) {
X  		pline("Floating in the air, you miss wildly!");
X! 		(void) passive(mon, FALSE, 1, TRUE);
X  		return;
X  	}
X  
X***************
X*** 110,116 ****
X  		if(!rn2((i < j/10) ? 2 : (i < j/5) ? 3 : 4)) {
X  			if(martial() && !rn2(2)) goto doit;
X  			Your("clumsy kick does no damage.");
X! 			(void) passive(mon, FALSE, 1);
X  			return;
X  		}
X  		if(i < j/10) clumsy = TRUE;
X--- 136,142 ----
X  		if(!rn2((i < j/10) ? 2 : (i < j/5) ? 3 : 4)) {
X  			if(martial() && !rn2(2)) goto doit;
X  			Your("clumsy kick does no damage.");
X! 			(void) passive(mon, FALSE, 1, TRUE);
X  			return;
X  		}
X  		if(i < j/10) clumsy = TRUE;
X***************
X*** 130,136 ****
X  		if(!nohands(mon->data) && !rn2(martial() ? 5 : 3)) {
X  		    kludge("%s blocks your %skick.", Monnam(mon), 
X  				clumsy ? "clumsy " : "");
X! 		    (void) passive(mon, FALSE, 1);
X  		    return;
X  		} else {
X  		    mnexto(mon);
X--- 156,162 ----
X  		if(!nohands(mon->data) && !rn2(martial() ? 5 : 3)) {
X  		    kludge("%s blocks your %skick.", Monnam(mon), 
X  				clumsy ? "clumsy " : "");
X! 		    (void) passive(mon, FALSE, 1, TRUE);
X  		    return;
X  		} else {
X  		    mnexto(mon);
X***************
X*** 138,150 ****
X  		        pline("%s %s, %s evading your %skick.", 
X  				Blind ? "It" : Monnam(mon),
X  				(can_teleport(mon->data) ? "teleports" :
X- 				 is_flyer(mon->data) ? "flutters" :
X  				 is_floater(mon->data) ? "floats" :
X  				 nolimbs(mon->data) ? "slides" :
X  				 "jumps"),
X  				clumsy ? "easily" : "nimbly",
X  				clumsy ? "clumsy " : "");
X! 			(void) passive(mon, FALSE, 1);
X  		        return;
X  		    } 
X  		}
X--- 164,176 ----
X  		        pline("%s %s, %s evading your %skick.", 
X  				Blind ? "It" : Monnam(mon),
X  				(can_teleport(mon->data) ? "teleports" :
X  				 is_floater(mon->data) ? "floats" :
X+ 				 is_flyer(mon->data) ? "flutters" :
X  				 nolimbs(mon->data) ? "slides" :
X  				 "jumps"),
X  				clumsy ? "easily" : "nimbly",
X  				clumsy ? "clumsy " : "");
X! 			(void) passive(mon, FALSE, 1, TRUE);
X  		        return;
X  		    } 
X  		}
X*** src/Old/dothrow.c	Wed Aug 16 12:16:53 1989
X--- src/dothrow.c	Wed Aug  9 19:21:56 1989
X***************
X*** 251,258 ****
X  		}
X  		return(1);
X  	}
X! 	if(obj->olet == WEAPON_SYM || obj->otyp == ROCK || obj->olet == GEM_SYM) {
X! 		if(obj->otyp < DART || obj->otyp == ROCK || obj->olet == GEM_SYM) {
X  		    if (!uwep ||
X  			objects[obj->otyp].w_propellor !=
X  			-objects[uwep->otyp].w_propellor)
X--- 251,258 ----
X  		}
X  		return(1);
X  	}
X! 	if(obj->olet == WEAPON_SYM || obj->otyp == PICK_AXE || obj->olet == GEM_SYM) {
X! 		if(obj->otyp < DART || obj->olet == GEM_SYM) {
X  		    if (!uwep ||
X  			objects[obj->otyp].w_propellor !=
X  			-objects[uwep->otyp].w_propellor)
X*** src/Old/eat.c	Wed Aug 16 12:17:14 1989
X--- src/eat.c	Tue Aug 15 20:36:37 1989
X***************
X*** 127,133 ****
X  			You("turn to stone.");
X  			Sprintf(killer, "%s meat",
X  				      mons[pm].mname);
X! 			done("stoned");
X  #ifdef POLYSELF
X  		}
X  #endif
X--- 127,133 ----
X  			You("turn to stone.");
X  			Sprintf(killer, "%s meat",
X  				      mons[pm].mname);
X! 			done(STONING);
X  #ifdef POLYSELF
X  		}
X  #endif
X***************
X*** 409,422 ****
X  /* Created by GAN 01/28/87
X   * Amended by AKP 09/22/87: if not hard, don't choke, just vomit.
X   * Amended by 3.  06/12/89: if not hard, sometimes choke anyway, to keep risk.
X-  *
X-  * Note that if you have enough food, you can always stop being Sick!
X-  * choke() returns if you don't choke, kills you if you do.
X   */
X  /*ARGSUSED*/
X  static void
X  choke(food)
X! register struct objclass *food;
X  {
X  	/* only happens if you were satiated */
X  	if(u.uhs != SATIATED) return;
X--- 409,419 ----
X  /* Created by GAN 01/28/87
X   * Amended by AKP 09/22/87: if not hard, don't choke, just vomit.
X   * Amended by 3.  06/12/89: if not hard, sometimes choke anyway, to keep risk.
X   */
X  /*ARGSUSED*/
X  static void
X  choke(food)
X! register struct obj *food;
X  {
X  	/* only happens if you were satiated */
X  	if(u.uhs != SATIATED) return;
X***************
X*** 431,441 ****
X  		vomit();
X  	} else {
X  #endif
X! 		if(food)	killer = food->oc_name;
X! 		else		killer = "exuberant appetite";
X  		You("choke over your food.");
X  		You("die...");
X! 		done("choked");
X  #ifndef HARD
X  	}
X  #endif
X--- 428,443 ----
X  		vomit();
X  	} else {
X  #endif
X! 		if(food) {
X! 			int savequan = food->quan;
X! 			food->quan = 1;
X! 			killer = xname(food);
X! 			food->quan = savequan;
X! 		} else
X! 			killer = "exuberant appetite";
X  		You("choke over your food.");
X  		You("die...");
X! 		done(CHOKING);
X  #ifndef HARD
X  	}
X  #endif
X***************
X*** 508,514 ****
X  		rottenfood();
X  		lesshungry(ftmp->nutrition >> 2);
X  	    } else {
X! 		if(u.uhunger >= 1500) choke(ftmp);
X  
X  		switch(otmp->otyp){
X  		case FOOD_RATION:
X--- 510,516 ----
X  		rottenfood();
X  		lesshungry(ftmp->nutrition >> 2);
X  	    } else {
X! 		if(u.uhunger >= 1500) choke(otmp);
X  
X  		switch(otmp->otyp){
X  		case FOOD_RATION:
X***************
X*** 617,623 ****
X  					u.uhp = u.uhpmax;
X  				} else if(u.uhp <= 0) {
X  					killer = "rotten jelly lump";
X! 					done("died");
X  				}
X  				if(!otmp->cursed) heal_legs();
X  				break;
X--- 619,625 ----
X  					u.uhp = u.uhpmax;
X  				} else if(u.uhp <= 0) {
X  					killer = "rotten jelly lump";
X! 					done(POISONING);
X  				}
X  				if(!otmp->cursed) heal_legs();
X  				break;
X***************
X*** 701,707 ****
X  register int num;
X  {
X  	u.uhunger += num;
X! 	if(u.uhunger >= 2000) choke((struct objclass *) 0);
X  	else {
X  	    /* Have lesshungry() report when you're nearly full so all eating
X  	     * warns when you're about to choke.
X--- 703,709 ----
X  register int num;
X  {
X  	u.uhunger += num;
X! 	if(u.uhunger >= 2000) choke((struct obj *) 0);
X  	else {
X  	    /* Have lesshungry() report when you're nearly full so all eating
X  	     * warns when you're about to choke.
X***************
X*** 749,755 ****
X  			flags.botl = 1;
X  			bot();
X  			You("die from starvation.");
X! 			done("starved");
X  		}
X  	}
X  
X--- 751,757 ----
X  			flags.botl = 1;
X  			bot();
X  			You("die from starvation.");
X! 			done(STARVING);
X  		}
X  	}
X  
X***************
X*** 785,791 ****
X  		if(u.uhp < 1) {
X  			You("die from hunger and exhaustion.");
X  			killer = "exhaustion";
X! 			done("starved");
X  		}
X  	}
X  }
X--- 787,793 ----
X  		if(u.uhp < 1) {
X  			You("die from hunger and exhaustion.");
X  			killer = "exhaustion";
X! 			done(STARVING);
X  		}
X  	}
X  }
X*** src/Old/fountain.c	Wed Aug 16 12:18:56 1989
X--- src/fountain.c	Tue Aug 15 18:48:37 1989
X***************
X*** 87,92 ****
X--- 87,93 ----
X  	    levl[mx][my].typ = POOL;
X  	    levl[mx][my].doormask = 0;
X  	    if(!Blind) atl(mx,my,(char) POOL_SYM);
X+ 	    else levl[mx][my].seen = 0;
X  	    madepool = 1;
X  	}
X  
X*** src/Old/hack.c	Sat Jul 29 01:11:26 1989
X--- src/hack.c	Wed Aug 16 22:18:51 1989
X***************
X*** 114,119
X  				You("push the boulder into a pit!");
X  				deltrap(ttmp);
X  				delobj(otmp);
X  				if(flags.verbose)
X  				    pline("It completely fills the pit!");
X  				continue;
X
X--- 114,121 -----
X  				You("push the boulder into a pit!");
X  				deltrap(ttmp);
X  				delobj(otmp);
X+ 				if(cansee(rx,ry)) newsym(rx,ry);
X+ 				else levl[rx][ry].seen = 0;
X  				if(flags.verbose)
X  				    pline("It completely fills the pit!");
X  				continue;
X***************
X*** 121,126
X  				pline("The boulder falls into and plugs a hole in the ground!");
X  				deltrap(ttmp);
X  				delobj(otmp);
X  				continue;
X  			    case LEVEL_TELEP:
X  			    case TELEP_TRAP:
X
X--- 123,130 -----
X  				pline("The boulder falls into and plugs a hole in the ground!");
X  				deltrap(ttmp);
X  				delobj(otmp);
X+ 				if(cansee(rx,ry)) newsym(rx,ry);
X+ 				else levl[rx][ry].seen = 0;
X  				continue;
X  			    case LEVEL_TELEP:
X  			    case TELEP_TRAP:
X***************
X*** 300,306
X  domove() {
X  	register struct monst *mtmp = (struct monst *)0;
X  	register struct rm *tmpr,*ust;
X! 	register xchar x,y;
X  	struct trap *trap;
X  
X  	u_wipe_engr(rnd(5));
X
X--- 304,310 -----
X  domove() {
X  	register struct monst *mtmp = (struct monst *)0;
X  	register struct rm *tmpr,*ust;
X! 	register xchar x,y,xx,yy;
X  	struct trap *trap;
X  
X  	u_wipe_engr(rnd(5));
X***************
X*** 312,317
X  	}
X  	if(u.uswallow) {
X  		u.dx = u.dy = 0;
X  		x = u.ux = u.ustuck->mx;
X  		y = u.uy = u.ustuck->my;
X  	} else {
X
X--- 316,323 -----
X  	}
X  	if(u.uswallow) {
X  		u.dx = u.dy = 0;
X+ 		xx = u.ux;
X+ 		yy = u.uy;
X  		x = u.ux = u.ustuck->mx;
X  		y = u.uy = u.ustuck->my;
X  		if(xx != u.ustuck->mx || yy != u.ustuck->my) newsym(xx,yy);
X***************
X*** 314,319
X  		u.dx = u.dy = 0;
X  		x = u.ux = u.ustuck->mx;
X  		y = u.uy = u.ustuck->my;
X  	} else {
X  		x = u.ux + u.dx;
X  		y = u.uy + u.dy;
X
X--- 320,326 -----
X  		yy = u.uy;
X  		x = u.ux = u.ustuck->mx;
X  		y = u.uy = u.ustuck->my;
X+ 		if(xx != u.ustuck->mx || yy != u.ustuck->my) newsym(xx,yy);
X  	} else {
X  		x = u.ux + u.dx;
X  		y = u.uy + u.dy;
X***************
X*** 399,405
X  	if(u.utrap) {
X  		if(u.utraptype == TT_PIT) {
X  		    if(flags.verbose)
X! 			You("are still in a pit.");
X  		    u.utrap--;
X  		} else if (u.utraptype == TT_WEB) {
X  		    if(flags.verbose)
X
X--- 406,412 -----
X  	if(u.utrap) {
X  		if(u.utraptype == TT_PIT) {
X  		    if(flags.verbose)
X! 			Norep("You are still in a pit.");
X  		    u.utrap--;
X  		} else if (u.utraptype == TT_WEB) {
X  		    if(flags.verbose)
X***************
X*** 403,409
X  		    u.utrap--;
X  		} else if (u.utraptype == TT_WEB) {
X  		    if(flags.verbose)
X! 		    	You("are stuck to the web.");
X  		    u.utrap--;
X  		} else {
X  		    if(flags.verbose)
X
X--- 410,416 -----
X  		    u.utrap--;
X  		} else if (u.utraptype == TT_WEB) {
X  		    if(flags.verbose)
X! 		    	Norep("You are stuck to the web.");
X  		    u.utrap--;
X  		} else {
X  		    if(flags.verbose)
X***************
X*** 407,413
X  		    u.utrap--;
X  		} else {
X  		    if(flags.verbose)
X! 			You("are caught in a bear trap.");
X  		    if((u.dx && u.dy) || !rn2(5)) u.utrap--;
X  		}
X  		return;
X
X--- 414,420 -----
X  		    u.utrap--;
X  		} else {
X  		    if(flags.verbose)
X! 			Norep("You are caught in a bear trap.");
X  		    if((u.dx && u.dy) || !rn2(5)) u.utrap--;
X  		}
X  		return;
X***************
X*** 535,540
X  #endif
X  	u.ux += u.dx;
X  	u.uy += u.dy;
X  	if(flags.run) {
X  		if(IS_DOOR(tmpr->typ) ||
X  #ifdef POLYSELF
X
X--- 542,548 -----
X  #endif
X  	u.ux += u.dx;
X  	u.uy += u.dy;
X+ 	reset_occupations();
X  	if(flags.run) {
X  		if(IS_DOOR(tmpr->typ) ||
X  #ifdef POLYSELF
X***************
X*** 688,694
X  	for(x = u.ux-1; x <= u.ux+1; x++) for(y = u.uy-1; y <= u.uy+1; y++) {
X  		if(x == u.ux && y == u.uy) continue;
X  		if(levl[x][y].mmask && (mtmp = m_at(x,y)) && !mtmp->mimic &&
X! 		    (!mtmp->minvis || See_invisible) && !mtmp->mundetected) {
X  			if((flags.run != 1 && !mtmp->mtame) || (x == u.ux+u.dx && y == u.uy+u.dy))
X  				goto stop;
X  		} else mtmp = 0;
X
X--- 696,702 -----
X  	for(x = u.ux-1; x <= u.ux+1; x++) for(y = u.uy-1; y <= u.uy+1; y++) {
X  		if(x == u.ux && y == u.uy) continue;
X  		if(levl[x][y].mmask && (mtmp = m_at(x,y)) && !mtmp->mimic &&
X! 		    (!mtmp->minvis || See_invisible || Telepat) && !mtmp->mundetected) {
X  			if((flags.run != 1 && !mtmp->mtame) || (x == u.ux+u.dx && y == u.uy+u.dy))
X  				goto stop;
X  		} else mtmp = 0;
X***************
X*** 792,798
X  		   !mtmp->mtame && !mtmp->mpeaceful &&
X  		   !noattacks(mtmp->data) &&
X  		   !mtmp->mfroz && !mtmp->msleep &&  /* aplvax!jcn */
X! 		   (!mtmp->minvis || See_invisible) &&
X  		   !onscary(u.ux, u.uy, mtmp))
X  			return(1);
X  	}
X
X--- 800,806 -----
X  		   !mtmp->mtame && !mtmp->mpeaceful &&
X  		   !noattacks(mtmp->data) &&
X  		   !mtmp->mfroz && !mtmp->msleep &&  /* aplvax!jcn */
X! 		   (!mtmp->minvis || See_invisible || Telepat) &&
X  		   !onscary(u.ux, u.uy, mtmp))
X  			return(1);
X  	}
X***************
X*** 804,810
X  xchar x,y;
X  {
X  	if(Blind || (u.uswallow && (x != u.ux || y != u.uy))) return(0);
X- 	if(dist(x,y) < 3) return(1);
X  	if(IS_ROCK(levl[x][y].typ) && levl[u.ux][u.uy].typ == CORR &&
X  							!levl[u.ux][u.uy].lit)
X  		return(0);
X
X--- 812,817 -----
X  xchar x,y;
X  {
X  	if(Blind || (u.uswallow && (x != u.ux || y != u.uy))) return(0);
X  	if(IS_ROCK(levl[x][y].typ) && levl[u.ux][u.uy].typ == CORR &&
X  				!levl[x][y].mmask && !levl[u.ux][u.uy].lit)
X  		return(0);
X***************
X*** 806,812
X  	if(Blind || (u.uswallow && (x != u.ux || y != u.uy))) return(0);
X  	if(dist(x,y) < 3) return(1);
X  	if(IS_ROCK(levl[x][y].typ) && levl[u.ux][u.uy].typ == CORR &&
X! 							!levl[u.ux][u.uy].lit)
X  		return(0);
X  	if(levl[x][y].lit &&
X  		((seelx <= x && x <= seehx && seely <= y && y <= seehy) ||
X
X--- 813,819 -----
X  {
X  	if(Blind || (u.uswallow && (x != u.ux || y != u.uy))) return(0);
X  	if(IS_ROCK(levl[x][y].typ) && levl[u.ux][u.uy].typ == CORR &&
X! 				!levl[x][y].mmask && !levl[u.ux][u.uy].lit)
X  		return(0);
X  	if(dist(x,y) < 3) return(1);
X  	if(levl[x][y].lit &&
X***************
X*** 808,813
X  	if(IS_ROCK(levl[x][y].typ) && levl[u.ux][u.uy].typ == CORR &&
X  							!levl[u.ux][u.uy].lit)
X  		return(0);
X  	if(levl[x][y].lit &&
X  		((seelx <= x && x <= seehx && seely <= y && y <= seehy) ||
X  		(seelx2 <= x && x <= seehx2 && seely2 <= y && y <= seehy2)))
X
X--- 815,821 -----
X  	if(IS_ROCK(levl[x][y].typ) && levl[u.ux][u.uy].typ == CORR &&
X  				!levl[x][y].mmask && !levl[u.ux][u.uy].lit)
X  		return(0);
X+ 	if(dist(x,y) < 3) return(1);
X  	if(levl[x][y].lit &&
X  		((seelx <= x && x <= seehx && seely <= y && y <= seehy) ||
X  		(seelx2 <= x && x <= seehx2 && seely2 <= y && y <= seehy2)))
X***************
X*** 935,941
X  	if(u.uhp < 1) {
X  		killer = knam;	/* the thing that killed you */
X  		You("die...");
X! 		done("died");
X  	} else if(u.uhp*10 < u.uhpmax && moves-wailmsg > 50 && n > 0){
X  		wailmsg = moves;
X  		if(index("WEV", pl_character[0])) {
X
X--- 943,949 -----
X  	if(u.uhp < 1) {
X  		killer = knam;	/* the thing that killed you */
X  		You("die...");
X! 		done(DIED);
X  	} else if(u.uhp*10 < u.uhpmax && moves-wailmsg > 50 && n > 0){
X  		wailmsg = moves;
X  		if(index("WEV", pl_character[0])) {
X***************
X*** 1030,1035
X  		otmp = otmp->nobj;
X  	}
X  	return(ct);
X  }
X  
X  #ifdef STUPID_CPP	/* otherwise these functions are macros in hack.h */
X
X--- 1038,1053 -----
X  		otmp = otmp->nobj;
X  	}
X  	return(ct);
X+ }
X+ 
X+ int
X+ identify(otmp)		/* also called by newmail() */
X+ 	register struct obj *otmp;
X+ {
X+ 	makeknown(otmp->otyp);
X+ 	otmp->known = otmp->dknown = otmp->bknown = 1;
X+ 	prinv(otmp);
X+ 	return(1);
X  }
X  
X  #ifdef STUPID_CPP	/* otherwise these functions are macros in hack.h */
X*** src/Old/invent.c	Wed Aug 16 12:20:27 1989
X--- src/invent.c	Tue Aug 15 20:34:29 1989
X***************
X*** 660,666 ****
X  	olets[0] = 0;
X  	while(sym = *ip++){
X  		if(sym == ' ') continue;
X! 		if(takeoff) {
X  		    if(!index(removeables,sym)) {
X  			pline("Not applicable.");
X  			return(0);
X--- 660,666 ----
X  	olets[0] = 0;
X  	while(sym = *ip++){
X  		if(sym == ' ') continue;
X! 		if(takeoff && !(uwep && sym == uwep->olet)) {
X  		    if(!index(removeables,sym)) {
X  			pline("Not applicable.");
X  			return(0);
X***************
X*** 1082,1089 ****
X  	       		(otmp->otyp == CORPSE && otmp->corpsenm == PM_COCKATRICE)) {
X  			    pline("Touching the dead cockatrice is a fatal mistake...");
X  			    You("turn to stone...");
X! 			    killer = "dead cockatrice";
X! 		 	    done("stoned");
X  	    		}
X  		}
X      	}
X--- 1082,1089 ----
X  	       		(otmp->otyp == CORPSE && otmp->corpsenm == PM_COCKATRICE)) {
X  			    pline("Touching the dead cockatrice is a fatal mistake...");
X  			    You("turn to stone...");
X! 			    killer = "cockatrice corpse";
X! 			    done(STONING);
X  	    		}
X  		}
X      	}
X*** src/Old/ioctl.c	Wed Aug 16 12:21:02 1989
X--- src/ioctl.c	Sat Aug  5 13:03:55 1989
X***************
X*** 26,31 ****
X--- 26,50 ----
X  #else
X  	(void) ioctl(fileno(stdin), (int) TCGETA, &termio);
X  #endif
X+ #ifdef TIOCGWINSZ
X+ 	{
X+ 		/*
X+ 		 * ttysize is found on Suns and BSD
X+ 		 * winsize is found on Suns, BSD, and Ultrix
X+ 		 */
X+ 		struct winsize ttsz;
X+ 
X+ 		(void) ioctl(fileno(stdin), (int) TIOCGWINSZ, (char *) &ttsz);
X+ 		/*
X+ 		 * Use the kernel's values for lines and columns if it has
X+ 		 * any idea.
X+ 		 */
X+ 		if (ttsz.ws_row)
X+ 			LI = ttsz.ws_row;
X+ 		if (ttsz.ws_col)
X+ 			CO = ttsz.ws_col;
X+ 	}
X+ #endif
X  }
X  
X  void
END_OF_FILE
if test 56848 -ne `wc -c <'patch02c'`; then
    echo shar: \"'patch02c'\" unpacked with wrong size!
fi
# end of 'patch02c'
fi
echo shar: End of archive 3 \(of 7\).
cp /dev/null ark3isdone
MISSING=""
for I in 1 2 3 4 5 6 7 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 7 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
