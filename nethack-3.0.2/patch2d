Path: utzoo!utgpu!jarvis.csri.toronto.edu!mailrus!csd4.csd.uwm.edu!cs.utexas.edu!uunet!zephyr.ens.tek.com!tekgen!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v08i009:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Patch2d
Message-ID: <4461@tekred.CNA.TEK.COM>
Date: 18 Aug 89 15:49:24 GMT
Sender: nobody@tekred.CNA.TEK.COM
Lines: 2107
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 8, Issue 9
Archive-name: NetHack3/Patch2d
Patch-To: NetHack3: Volume 7, Issue 56-93



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 4 (of 7)."
# Contents:  patch02d
# Wrapped by billr@saab on Fri Aug 18 08:43:06 1989
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'patch02d' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'patch02d'\"
else
echo shar: Extracting \"'patch02d'\" \(54146 characters\)
sed "s/^X//" >'patch02d' <<'END_OF_FILE'
X*** src/Old/mail.c	Wed Aug 16 12:23:56 1989
X--- src/mail.c	Tue Aug 15 22:04:27 1989
X***************
X*** 56,65 ****
X  static char *mailbox;
X  static long laststattime;
X  
X  void
X  getmailstatus() {
X! 	if(!(mailbox = getenv("MAIL")))
X  		return;
X  	if(stat(mailbox, &omstat)){
X  #  ifdef PERMANENT_MAILBOX
X  		pline("Cannot get status of MAIL=%s .", mailbox);
X--- 56,79 ----
X  static char *mailbox;
X  static long laststattime;
X  
X+ #  ifdef BSD
X+ #   define MAILPATH "/usr/spool/mail/"
X+ #  endif
X+ #  ifdef SYSV
X+ #   define MAILPATH "/usr/mail/"
X+ #  endif
X+ 
X  void
X  getmailstatus() {
X! 	if(!(mailbox = getenv("MAIL"))) {
X! #  ifdef MAILPATH
X! 		mailbox = (char *) alloc(sizeof(MAILPATH)+8);
X! 		Strcpy(mailbox, MAILPATH);
X! 		Strcat(mailbox, getlogin());
X! #  else
X  		return;
X+ #  endif
X+ 	}
X  	if(stat(mailbox, &omstat)){
X  #  ifdef PERMANENT_MAILBOX
X  		pline("Cannot get status of MAIL=%s .", mailbox);
X*** src/Old/makemon.c	Thu Aug  3 08:44:40 1989
X--- src/makemon.c	Fri Aug 18 08:13:40 1989
X***************
X*** 7,13 ****
X  struct monst zeromonst;
X  static int uncommon P((struct permonst *));
X  
X! static int monstr[NUMMONS];
X  
X  #define m_initsgrp(mtmp, x, y) m_initgrp(mtmp, x, y, 3)
X  #define m_initlgrp(mtmp, x, y) m_initgrp(mtmp, x, y, 10)
X--- 7,13 ----
X  struct monst zeromonst;
X  static int uncommon P((struct permonst *));
X  
X! int monstr[NUMMONS];
X  
X  #define m_initsgrp(mtmp, x, y) m_initgrp(mtmp, x, y, 3)
X  #define m_initlgrp(mtmp, x, y) m_initgrp(mtmp, x, y, 10)
X***************
X*** 116,121 ****
X--- 116,124 ----
X  			case 1:
X  			    (void)mongets(mtmp, ELVEN_DAGGER);
X  			    break;
X+ 			case 2:
X+ 			    (void)mongets(mtmp, SLING);
X+ 			    break;
X  		      }
X  		    if (!rn2(10)) (void)mongets(mtmp, ELVEN_MITHRIL_COAT);
X  		} else if (is_dwarf(ptr)) {
X***************
X*** 541,547 ****
X  	} else {
X  		if(x == u.ux && y == u.uy && ptr->mlet != S_GHOST) {
X  			mnexto(mtmp);
X! 			if (ptr->mlet == S_MIMIC) set_mimic_sym(mtmp);
X  		}
X  	}
X  #ifdef HARD
X--- 544,554 ----
X  	} else {
X  		if(x == u.ux && y == u.uy && ptr->mlet != S_GHOST) {
X  			mnexto(mtmp);
X! 			if (ptr->mlet == S_MIMIC) {
X! 				set_mimic_sym(mtmp);
X! 				unpmon(mtmp);
X! 				pmon(mtmp);
X! 			}
X  		}
X  	}
X  #ifdef HARD
X***************
X*** 1092,1103 ****
X  		sym = ALTAR_SYM;
X  #endif
X  	/* We won't bother with beehives, morgues, barracks, throne rooms
X! 	 * since they shouldn't contain mimics anyway...
X  	 */
X  	else if (rt >= SHOPBASE) {
X  		int s_sym = get_shop_item(rt - SHOPBASE);
X  
X! 		if (s_sym < 0) sym = objects[-sym].oc_olet;
X  		else if (s_sym == RANDOM_SYM)
X  			sym = syms[rn2(sizeof(syms)-2) + 2];
X  		else sym = s_sym;
X--- 1099,1110 ----
X  		sym = ALTAR_SYM;
X  #endif
X  	/* We won't bother with beehives, morgues, barracks, throne rooms
X! 	 * since they shouldn't contain too many mimics anyway...
X  	 */
X  	else if (rt >= SHOPBASE) {
X  		int s_sym = get_shop_item(rt - SHOPBASE);
X  
X! 		if (s_sym < 0) sym = objects[-s_sym].oc_olet;
X  		else if (s_sym == RANDOM_SYM)
X  			sym = syms[rn2(sizeof(syms)-2) + 2];
X  		else sym = s_sym;
X*** src/Old/end.c	Wed Aug 16 12:17:44 1989
X--- src/end.c	Tue Aug 15 20:36:34 1989
X***************
X*** 13,18 ****
X--- 13,30 ----
X  
X  void end_box_display();
X  
X+ static const char *deaths[] = { 	/* the array of death */
X+ 	"died", "choked", "poisoned", "starvation", "drowning",
X+ 	"burning", "crushed", "turned to stone", "genocided",
X+ 	"panic", "trickery",
X+ 	"quit", "escaped", "ascended" };
X+ 
X+ static const char *ends[] = {		/* "when you..." */
X+ 	"died", "choked", "were poisoned", "starved", "drowned",
X+ 	"burned", "were crushed", "turned to stone", "were genocided",
X+ 	"panicked", "were tricked",
X+ 	"quit", "escaped", "ascended" };
X+ 
X  int
X  done1()
X  {
X***************
X*** 60,66 ****
X  	}
X  #endif
X  #ifndef LINT
X! 	done("quit");
X  #endif
X  	return 0;
X  }
X--- 72,78 ----
X  	}
X  #endif
X  #ifndef LINT
X! 	done(QUIT);
X  #endif
X  	return 0;
X  }
X***************
X*** 97,118 ****
X  
X  	You("die...");
X  	buf[0] = '\0';
X  	if (mtmp->minvis)
X! 		Sprintf(eos(buf), "invisible ");
X  	if (Hallucination)
X! 		Sprintf(eos(buf), "hallucinogen-distorted ");
X  
X  	if(mtmp->data->mlet == S_GHOST) {
X  		register char *gn = (char *) mtmp->mextra;
X  		if (!Hallucination && !mtmp->minvis && *gn)
X! 			Sprintf(eos(buf), "the ");
X  		Sprintf(eos(buf), (*gn ? "ghost of %s" : "ghost%s"), gn);
X  	} else if(mtmp->isshk) {
X  		Sprintf(eos(buf), "%s %s, the shopkeeper",
X  			(ESHK(mtmp)->ismale ? "Mr." : "Ms."), shkname(mtmp));
X! 	} else if (mtmp->iswiz)
X! 		Sprintf(eos(buf), "the %s", mons[PM_WIZARD_OF_YENDOR].mname);
X! 	else Sprintf(eos(buf), "%s", mtmp->data->mname);
X  	if (mtmp->mnamelth) Sprintf(eos(buf), " called %s", NAME(mtmp));
X  	killer = buf;
X  	if (mtmp->data->mlet == S_WRAITH)
X--- 109,130 ----
X  
X  	You("die...");
X  	buf[0] = '\0';
X+ 	if (mtmp->iswiz)
X+ 		Strcat(buf, "the ");
X  	if (mtmp->minvis)
X! 		Strcat(buf, "invisible ");
X  	if (Hallucination)
X! 		Strcat(buf, "hallucinogen-distorted ");
X  
X  	if(mtmp->data->mlet == S_GHOST) {
X  		register char *gn = (char *) mtmp->mextra;
X  		if (!Hallucination && !mtmp->minvis && *gn)
X! 			Strcat(buf, "the ");
X  		Sprintf(eos(buf), (*gn ? "ghost of %s" : "ghost%s"), gn);
X  	} else if(mtmp->isshk) {
X  		Sprintf(eos(buf), "%s %s, the shopkeeper",
X  			(ESHK(mtmp)->ismale ? "Mr." : "Ms."), shkname(mtmp));
X! 	} else Strcat(buf, mtmp->data->mname);
X  	if (mtmp->mnamelth) Sprintf(eos(buf), " called %s", NAME(mtmp));
X  	killer = buf;
X  	if (mtmp->data->mlet == S_WRAITH)
X***************
X*** 125,133 ****
X  	if (u.ugrave_arise > -1 && (mons[u.ugrave_arise].geno & G_GENOD))
X  		u.ugrave_arise = -1;
X  	if (mtmp->data->mlet == S_COCKATRICE)
X! 		done("stoned");
X  	else
X! 		done("died");
X  	return;
X  }
X  
X--- 137,145 ----
X  	if (u.ugrave_arise > -1 && (mons[u.ugrave_arise].geno & G_GENOD))
X  		u.ugrave_arise = -1;
X  	if (mtmp->data->mlet == S_COCKATRICE)
X! 		done(STONING);
X  	else
X! 		done(DIED);
X  	return;
X  }
X  
X***************
X*** 170,189 ****
X  		    abort();	/* generate core dump */
X  # endif
X  #endif
X! 	done("panicked");
X  }
X  
X- /* called with arg "died", "drowned", "escaped", "quit", "choked", "panicked",
X-    "burned", "starved", "stoned", or "tricked" */
X  /* Be careful not to call panic from here! */
X  void
X! done(st1)
X! register char *st1;
X  {
X  	struct permonst *upmon;
X! 	char buf[BUFSZ], buf1[BUFSZ], buf2[BUFSZ], buf3[BUFSZ];
X  	/* buf: used if killer gets changed
X- 	 * buf1: used if st1 gets changed
X  	 * buf2: same as player name, except it is capitalized
X  	 * buf3: used to copy killer in case it comes from something like
X  		xname(), which would otherwise get overwritten when we call
X--- 182,198 ----
X  		    abort();	/* generate core dump */
X  # endif
X  #endif
X! 	done(PANICKED);
X  }
X  
X  /* Be careful not to call panic from here! */
X  void
X! done(how)
X! int how;
X  {
X  	struct permonst *upmon;
X! 	char buf[BUFSZ], buf2[BUFSZ], buf3[BUFSZ];
X  	/* buf: used if killer gets changed
X  	 * buf2: same as player name, except it is capitalized
X  	 * buf3: used to copy killer in case it comes from something like
X  		xname(), which would otherwise get overwritten when we call
X***************
X*** 192,206 ****
X  	char	c;
X  	boolean taken;
X  
X! 	Strcpy(buf3, killer);
X  	killer = buf3;
X  #ifdef WIZARD
X! 	if (wizard && *st1=='t') {
X  		You("are a very tricky wizard, it seems.");
X  		return;
X  	}
X  #endif
X! 	if(Lifesaved && index("bcds", *st1)){
X  		u.uswldtim = 0;
X  		if(u.uhpmax < 0) u.uhpmax = 10;	/* arbitrary */
X  		u.uhp = u.uhpmax;
X--- 201,215 ----
X  	char	c;
X  	boolean taken;
X  
X! 	Strcpy(buf3, (!killer || how >= PANICKED ? deaths[how] : killer));
X  	killer = buf3;
X  #ifdef WIZARD
X! 	if (wizard && how == TRICKED) {
X  		You("are a very tricky wizard, it seems.");
X  		return;
X  	}
X  #endif
X! 	if(Lifesaved && how <= GENOCIDED) {
X  		u.uswldtim = 0;
X  		if(u.uhpmax < 0) u.uhpmax = 10;	/* arbitrary */
X  		u.uhp = u.uhpmax;
X***************
X*** 212,218 ****
X  		You("feel much better!");
X  		pline("The medallion crumbles to dust!");
X  		useup(uamul);
X- 		Lifesaved = 0;
X  		if (u.uhunger < 500) u.uhunger = 500;
X  		nomovemsg = "You survived that attempt on your life.";
X  		curs_on_u();
X--- 221,226 ----
X***************
X*** 220,233 ****
X  		if(multi > 0) multi = 0; else multi = -1;
X  		flags.botl = 1;
X  		u.ugrave_arise = -1;
X! 		if (!strncmp(killer, "genocide", 8)) {
X  			pline("Unfortunately you are still genocided...");
X! 			done("died");
X  		}
X- 		return;
X  	}
X  #if defined(WIZARD) || defined(EXPLORE_MODE)
X! 	if((wizard || discover) && index("bcds", *st1)){
X  		pline("Die? ");
X  		if(yn() == 'y') goto die;
X  		u.uswldtim = 0;
X--- 228,242 ----
X  		if(multi > 0) multi = 0; else multi = -1;
X  		flags.botl = 1;
X  		u.ugrave_arise = -1;
X! 		if (how == GENOCIDED)
X  			pline("Unfortunately you are still genocided...");
X! 		else {
X! 			killer = 0;
X! 			return;
X  		}
X  	}
X  #if defined(WIZARD) || defined(EXPLORE_MODE)
X! 	if((wizard || discover) && how <= GENOCIDED) {
X  		pline("Die? ");
X  		if(yn() == 'y') goto die;
X  		u.uswldtim = 0;
X***************
X*** 241,246 ****
X--- 250,256 ----
X  		if(multi > 0) multi = 0; else multi = -1;
X  		flags.botl = 1;
X  		u.ugrave_arise = -1;
X+ 		killer = 0;
X  		return;
X  	}
X  #endif /* WIZARD || EXPLORE_MODE */
X***************
X*** 254,274 ****
X  #endif /* NO_SIGNAL /* */
X  	upmon = player_mon();
X  	if(u.ugrave_arise > -1) /* create no corpse */ ;
X! 	else if(*st1 == 's' && st1[2] == 'o') 
X  		(mk_named_object(STATUE, upmon, u.ux, u.uy, plname,
X  					strlen(plname)))->spe = 0;
X  	else
X  		(void) mk_named_object(CORPSE, upmon, u.ux, u.uy, plname,
X  							strlen(plname));
X! 	if(*st1 == 'q' && u.uhp < 1){
X! 		st1 = "died";
X! 		killer = "quit while already on Charon's boat";
X  	}
X- 	if(*st1 == 's' && st1[2] == 'a') killer = "starvation"; else
X- 	if(*st1 == 'd' && st1[1] == 'r') killer = "drowning"; else
X- 	if(*st1 == 'p') killer = "panic"; else
X- 	if(*st1 == 't') killer = "trickery"; else
X- 	if(!index("bcds", *st1)) killer = st1;
X  	taken = paybill();
X  	paygd();
X  	clearlocks();
X--- 264,281 ----
X  #endif /* NO_SIGNAL /* */
X  	upmon = player_mon();
X  	if(u.ugrave_arise > -1) /* create no corpse */ ;
X! 	else if(how == STONED)
X  		(mk_named_object(STATUE, upmon, u.ux, u.uy, plname,
X  					strlen(plname)))->spe = 0;
X  	else
X  		(void) mk_named_object(CORPSE, upmon, u.ux, u.uy, plname,
X  							strlen(plname));
X! 
X! 	if(how == QUIT && u.uhp < 1) {
X! 		how = DIED;
X! 		Strcpy(buf, "quit while already on Charon's boat");
X! 		killer = buf;
X  	}
X  	taken = paybill();
X  	paygd();
X  	clearlocks();
X***************
X*** 277,283 ****
X  	if(invent) {
X  	    if(taken)
X  		pline("Do you want to see what you had when you %s? ",
X! 			(*st1=='q') ? "quit" : "died");
X  	    else
X  		pline("Do you want your possessions identified? ");
X  	    /* New dump format by maartenj@cs.vu.nl */
X--- 284,290 ----
X  	if(invent) {
X  	    if(taken)
X  		pline("Do you want to see what you had when you %s? ",
X! 			(how == QUIT) ? "quit" : "died");
X  	    else
X  		pline("Do you want your possessions identified? ");
X  	    /* New dump format by maartenj@cs.vu.nl */
X***************
X*** 306,312 ****
X  	    }
X  	}
X  
X! 	if(index("bcds", *st1)){
X  #ifdef WIZARD
X  	    if(wizard) {
X  		pline("Save bones? ");
X--- 313,319 ----
X  	    }
X  	}
X  
X! 	if(how < GENOCIDED) {
X  #ifdef WIZARD
X  	    if(wizard) {
X  		pline("Save bones? ");
X***************
X*** 316,330 ****
X  		savebones();
X  	    if(!flags.notombstone) outrip();
X  	}
X! 	if(*st1 == 'c') killer = st1;		/* after outrip() */
X! 	if(*st1 == 's' && st1[2] == 'o') {
X! 		Sprintf(buf, "turned to stone by %s",killer);
X  		/* No a or an; topten.c will do that. */
X  		killer = buf;
X- 		st1 = "turned to stone";
X  	}
X! 	Strcpy(buf1, st1);
X! 	if(u.uhave_amulet) Strcat(killer," (with the Amulet)");
X  	settty(NULL);	/* does a clear_screen() */
X  	Strcpy(buf2, plname);
X  	if('a' <= buf2[0] && buf2[0] <= 'z') buf2[0] += 'A'-'a';
X--- 323,335 ----
X  		savebones();
X  	    if(!flags.notombstone) outrip();
X  	}
X! 	if(how == STONING) {
X! 		Strcpy(buf, "turned to stone by ");
X! 		Strcat(buf, killer);
X  		/* No a or an; topten.c will do that. */
X  		killer = buf;
X  	}
X! 	if(u.uhave_amulet) Strcat(killer, " (with the Amulet)");
X  	settty(NULL);	/* does a clear_screen() */
X  	Strcpy(buf2, plname);
X  	if('a' <= buf2[0] && buf2[0] <= 'z') buf2[0] += 'A'-'a';
X***************
X*** 331,337 ****
X  	if(!done_stopprint)
X  	    Printf("Goodbye %s the %s...\n\n", buf2,
X  #ifdef ENDGAME
X! 		   *st1 != 'a' ? pl_character : "Demigod");
X  #else
X  		   pl_character);
X  #endif
X--- 336,342 ----
X  	if(!done_stopprint)
X  	    Printf("Goodbye %s the %s...\n\n", buf2,
X  #ifdef ENDGAME
X! 		   how != ASCENDED ? pl_character : "Demigod");
X  #else
X  		   pl_character);
X  #endif
X***************
X*** 339,345 ****
X  	  tmp = u.ugold - u.ugold0;
X  	  if(tmp < 0)
X  		tmp = 0;
X! 	  if(*st1 == 'd' || *st1 == 'b')
X  		tmp -= tmp/10;
X  	  u.urexp += tmp;
X  	  u.urexp += 50 * maxdlevel;
X--- 344,350 ----
X  	  tmp = u.ugold - u.ugold0;
X  	  if(tmp < 0)
X  		tmp = 0;
X! 	  if(how < PANICKED)
X  		tmp -= tmp/10;
X  	  u.urexp += tmp;
X  	  u.urexp += 50 * maxdlevel;
X***************
X*** 346,361 ****
X  	  if(maxdlevel > 20)
X  		u.urexp += 1000*((maxdlevel > 30) ? 10 : maxdlevel - 20);
X  #ifdef ENDGAME
X! 	  if(*st1 == 'a') u.urexp *= 2;
X  #endif
X  	}
X! 	if(*st1 == 'e') {
X  		register struct monst *mtmp;
X  		register struct obj *otmp;
X  		long i;
X  		register unsigned int worthlessct = 0;
X  
X- 		killer = st1;
X  		keepdogs();
X  		mtmp = mydogs;
X  		if(mtmp) {
X--- 351,365 ----
X  	  if(maxdlevel > 20)
X  		u.urexp += 1000*((maxdlevel > 30) ? 10 : maxdlevel - 20);
X  #ifdef ENDGAME
X! 	  if(how == ASCENDED) u.urexp *= 2;
X  #endif
X  	}
X! 	if(how == ESCAPED) {
X  		register struct monst *mtmp;
X  		register struct obj *otmp;
X  		long i;
X  		register unsigned int worthlessct = 0;
X  
X  		keepdogs();
X  		mtmp = mydogs;
X  		if(mtmp) {
X***************
X*** 400,413 ****
X  		if(worthlessct)
X  		  Printf("        %u worthless piece%s of colored glass,\n",
X  			worthlessct, plur((long)worthlessct));
X- 		if(u.uhave_amulet) killer = "escaped (with Amulet)";
X- 		else killer = "escaped";
X  	} else
X  		if(!done_stopprint) {
X! 		    Printf("You %s ", 
X! 			!strcmp(st1, "tricked") ? "were tricked" : st1);
X  #ifdef ENDGAME
X! 		    if (*st1 != 'a') {
X  			if(dlevel == ENDLEVEL)
X  			     Printf("in the endgame ");
X  		    	else Printf("on dungeon level %d ", dlevel);
X--- 404,414 ----
X  		if(worthlessct)
X  		  Printf("        %u worthless piece%s of colored glass,\n",
X  			worthlessct, plur((long)worthlessct));
X  	} else
X  		if(!done_stopprint) {
X! 		    Printf("You %s ", ends[how]);
X  #ifdef ENDGAME
X! 		    if (how != ASCENDED) {
X  			if(dlevel == ENDLEVEL)
X  			     Printf("in the endgame ");
X  		    	else Printf("on dungeon level %d ", dlevel);
X***************
X*** 422,433 ****
X  	    u.ugold, plur(u.ugold), moves, plur(moves));
X  	if(!done_stopprint)
X    Printf("You were level %u with a maximum of %d hit points when you %s.\n",
X! 	    u.ulevel, u.uhpmax, buf1);
X! 	if(*st1 == 'e' && !done_stopprint){
X  		getret();	/* all those pieces of coloured glass ... */
X  		cls();
X  	}
X! #if defined(WIZARD) || defined(EXPLORE_MODE)
X  	if(wizard || discover)
X  		Printf("\nSince you were in %s mode, the score list \
X  will not be checked.\n", wizard ? "wizard" : "discover");
X--- 423,434 ----
X  	    u.ugold, plur(u.ugold), moves, plur(moves));
X  	if(!done_stopprint)
X    Printf("You were level %u with a maximum of %d hit points when you %s.\n",
X! 	    u.ulevel, u.uhpmax, ends[how]);
X! 	if(how == ESCAPED && !done_stopprint){
X  		getret();	/* all those pieces of coloured glass ... */
X  		cls();
X  	}
X! #if (defined(WIZARD) || defined(EXPLORE_MODE)) && !defined(LOGFILE)
X  	if(wizard || discover)
X  		Printf("\nSince you were in %s mode, the score list \
X  will not be checked.\n", wizard ? "wizard" : "discover");
X*** src/Old/lock.c	Wed Aug 16 12:23:18 1989
X--- src/lock.c	Wed Aug 16 10:36:10 1989
X***************
X*** 142,147 ****
X--- 142,150 ----
X  	return((xlock.usedtime = 0));
X  }
X  
X+ void
X+ reset_pick() { xlock.usedtime = 0; }
X+ 
X  int
X  pick_lock(pick) /* pick a lock with a given object */
X  	register struct	obj	*pick;
X***************
X*** 184,190 ****
X  	    if(levl[x][y].omask)
X  	    for(otmp = fobj; otmp; otmp = otmp->nobj)
X  		if((otmp->ox == x) && (otmp->oy == y))
X! 		    if(Is_box(otmp)) {
X  			pline("There is %s here, %s the lock? ",
X  			doname(otmp), (!otmp->olocked) ? "close" :
X  			((picktyp == LOCK_PICK) ? "pick" : "open" ));
X--- 187,195 ----
X  	    if(levl[x][y].omask)
X  	    for(otmp = fobj; otmp; otmp = otmp->nobj)
X  		if((otmp->ox == x) && (otmp->oy == y))
X! 		    if(Is_box(otmp) &&
X! 		       /* credit cards are only good for unlocking */
X! 		       (picktyp != CREDIT_CARD || otmp->olocked)) {
X  			pline("There is %s here, %s the lock? ",
X  			doname(otmp), (!otmp->olocked) ? "close" :
X  			((picktyp == LOCK_PICK) ? "pick" : "open" ));
X***************
X*** 232,238 ****
X  #else
X  		    mtmp->isshk)
X  #endif
X! 		    pline("\"No checks, no credit, no problem.\"");
X  		else
X  		    kludge("I don't think %s would appreciate that.", mon_nam(mtmp));
X  		return(0);
X--- 237,243 ----
X  #else
X  		    mtmp->isshk)
X  #endif
X! 		    verbalize("No checks, no credit, no problem.");
X  		else
X  		    kludge("I don't think %s would appreciate that.", mon_nam(mtmp));
X  		return(0);
X***************
X*** 259,264 ****
X--- 264,275 ----
X  		    pline("This door is broken.");
X  		    return(0);
X  		default:
X+ 		    /* credit cards are only good for unlocking */
X+ 		    if(picktyp == CREDIT_CARD && !(door->doormask & D_LOCKED)) {
X+ 			You("can't lock a door with a credit card.");
X+ 			return(0);
X+ 		    }
X+ 
X  		    pline("%sock it? ", (door->doormask & D_LOCKED) ? "Unl" : "L" );
X  
X  		    c = yn();
X***************
X*** 356,361 ****
X--- 367,373 ----
X  doopen() {		/* try to open a door */
X  	register int x, y;
X  	register struct rm *door;
X+ 	struct monst *mtmp;
X  
X  	if(!getdir(1)) return(0);
X  
X***************
X*** 363,373 ****
X  	y = u.uy + u.dy;
X  	if((x == u.ux) && (y == u.uy)) return(0);
X  
X  	door = &levl[x][y];
X  
X  	if(!IS_DOOR(door->typ)) {
X  #ifdef STRONGHOLD
X! 		if (is_drawbridge_wall(x,y) >= 0) {
X  		    pline("There is no obvious way to open the drawbridge.");
X  		    return(0);
X  		}
X--- 375,392 ----
X  	y = u.uy + u.dy;
X  	if((x == u.ux) && (y == u.uy)) return(0);
X  
X+ 	if(levl[x][y].mmask && (mtmp = m_at(x,y))->mimic && 
X+ 				mtmp->mappearance == DOOR_SYM &&
X+ 				!Protection_from_shape_changers) {
X+ 		stumble_onto_mimic(mtmp);
X+ 		return(1);
X+ 	}
X+ 
X  	door = &levl[x][y];
X  
X  	if(!IS_DOOR(door->typ)) {
X  #ifdef STRONGHOLD
X! 		if (is_db_wall(x,y)) {
X  		    pline("There is no obvious way to open the drawbridge.");
X  		    return(0);
X  		}
X***************
X*** 431,436 ****
X--- 450,456 ----
X  doclose() {		/* try to close a door */
X  	register int x, y;
X  	register struct rm *door;
X+ 	struct monst *mtmp;
X  
X  	if(!getdir(1)) return(0);
X  
X***************
X*** 440,445 ****
X--- 460,473 ----
X  		You("are in the way!");
X  		return(1);
X  	}
X+ 
X+ 	if(levl[x][y].mmask && (mtmp = m_at(x,y))->mimic && 
X+ 				mtmp->mappearance == DOOR_SYM &&
X+ 				!Protection_from_shape_changers) {
X+ 		stumble_onto_mimic(mtmp);
X+ 		return(1);
X+ 	}
X+ 
X  	door = &levl[x][y];
X  
X  	if(!IS_DOOR(door->typ)) {
X***************
X*** 592,597 ****
X--- 620,649 ----
X  		if(door->doormask & D_LOCKED) {
X  		    door->doormask = D_CLOSED | (door->doormask & D_TRAPPED);
X  		    if(cansee(x,y)) pline("The door unlocks!");
X+ 		} else res = 0;
X+ 		break;
X+ 	    case WAN_STRIKING:
X+ #ifdef SPELLS
X+ 	    case SPE_FORCE_BOLT:
X+ #endif
X+ 		if(door->doormask & (D_LOCKED | D_CLOSED)) {
X+ 		    if(door->doormask & D_TRAPPED) {
X+ 			if (levl[x][y].mmask)
X+ 			    (void) mb_trapped(m_at(x,y));
X+ 			else if (flags.verbose)
X+ 			    if (cansee(x,y))
X+ 			       pline("KABOOM!!	You see a door explode.");
X+ 			    else if (flags.soundok)
X+ 			       You("hear a distant explosion.");
X+ 			door->doormask = D_NODOOR;
X+ 			break;
X+ 		    }
X+ 		    door->doormask = D_BROKEN;
X+ 		    if (flags.verbose)
X+ 			if (cansee(x,y))
X+ 			    pline("The door crashes open!");
X+ 			else if (flags.soundok)
X+ 			    You("hear a crashing sound.");
X  		} else res = 0;
X  		break;
X  	    default:	impossible("magic (%d) attempted on door.", otmp->otyp);
X*** src/Old/mcastu.c	Wed Aug 16 12:25:17 1989
X--- src/mcastu.c	Tue Aug 15 22:58:26 1989
X***************
X*** 35,41 ****
X  {
X  	int	dmg = 0, ml = mtmp->m_lev;
X  
X! 	if(mtmp->mcan || mtmp->mspec_used) {  /* could not attack */
X  	    cursetxt(mtmp);
X  	    return(0);
X  	} else {
X--- 35,41 ----
X  {
X  	int	dmg = 0, ml = mtmp->m_lev;
X  
X! 	if(mtmp->mcan || mtmp->mspec_used || !ml) {  /* could not attack */
X  	    cursetxt(mtmp);
X  	    return(0);
X  	} else {
X***************
X*** 105,111 ****
X  				You("have an out of body experience.");
X  			    else  {
X  				killer = "touch of death";
X! 				done("died");
X  			    }
X  			} else {
X  				if(Antimagic) shieldeff(u.ux, u.uy);
X--- 105,111 ----
X  				You("have an out of body experience.");
X  			    else  {
X  				killer = "touch of death";
X! 				done(DIED);
X  			    }
X  			} else {
X  				if(Antimagic) shieldeff(u.ux, u.uy);
X***************
X*** 166,172 ****
X  		    case 5:		/* make invisible if not */
X  		    case 4:
X  			if(!mtmp->minvis) {
X! 			    if(canseemon(mtmp) && !See_invisible)
X  				pline("%s suddenly disappears!",
X  				      Monnam(mtmp));
X  			    mtmp->minvis = 1;
X--- 166,172 ----
X  		    case 5:		/* make invisible if not */
X  		    case 4:
X  			if(!mtmp->minvis) {
X! 			    if(canseemon(mtmp) && !See_invisible && !Telepat)
X  				pline("%s suddenly disappears!",
X  				      Monnam(mtmp));
X  			    mtmp->minvis = 1;
X*** src/Old/mhitm.c	Wed Aug 16 12:25:35 1989
X--- src/mhitm.c	Wed Aug  9 19:21:58 1989
X***************
X*** 19,38 ****
X  static int mdamagem P((struct monst *,struct monst *,struct attack *));
X  static void mswingsm P((struct monst *, struct monst *, struct obj *));
X  
X- static boolean
X- m_incompat(magr, mdef)
X- /* This must work like in mhitu.c.  Specifically, if it's a shopkeeper
X-  * polymorphed into a monster of a specific gender, the specific gender
X-  * overrides.  Thus, do not use is_female(), since then a female shopkeeper
X-  * polymorphed into an incubus, or any shopkeeper turned into something
X-  * genderless, would be treated improperly.
X-  * This nonsense could be avoided if every monster had a gender field...
X-  */
X- register struct monst *magr, *mdef;
X- {
X- 	return(gender(magr) != 1-gender(mdef));
X- }
X- 
X  static void
X  noises(magr, mattk)
X  	register struct monst *magr;
X--- 19,24 ----
X***************
X*** 60,70 ****
X  	if(vis) {
X  		if(mdef->mimic) seemimic(mdef);
X  		if(magr->mimic) seemimic(magr);
X! 		if (sp_melee(magr) && !magr->mcan &&
X! 			    (is_nymph(magr) || !m_incompat(magr,mdef))) {
X  			Sprintf(buf, "%s pretends to be friendly to",
X  								Monnam(magr));
X! 		} else
X  			Sprintf(buf,"%s misses", Monnam(magr));
X  		pline("%s %s.", buf, mon_nam(mdef));
X  	} else  noises(magr, mattk);
X--- 46,55 ----
X  	if(vis) {
X  		if(mdef->mimic) seemimic(mdef);
X  		if(magr->mimic) seemimic(magr);
X! 		if (could_seduce(magr,mdef,mattk) && !magr->mcan)
X  			Sprintf(buf, "%s pretends to be friendly to",
X  								Monnam(magr));
X! 		else
X  			Sprintf(buf,"%s misses", Monnam(magr));
X  		pline("%s %s.", buf, mon_nam(mdef));
X  	} else  noises(magr, mattk);
X***************
X*** 195,215 ****
X  	register struct monst *magr,*mdef;
X  	struct	attack *mattk;
X  {
X- 
X  	if(vis){
X  		char buf[BUFSZ];
X  		if(mdef->mimic) seemimic(mdef);
X  		if(magr->mimic) seemimic(magr);
X! 		if(sp_melee(magr) && !magr->mcan) {
X! 			if(!is_nymph(magr) && m_incompat(magr,mdef))
X! 				goto strike;
X  			Sprintf(buf, "%s %s", Monnam(magr),
X  				mdef->mblinded ? "talks to" : "smiles at");
X  			pline("%s %s %s.", buf, mon_nam(mdef),
X! 				m_incompat(magr,mdef) ?
X  					"engagingly" : "seductively");
X  		} else {
X- 	strike:
X  		    switch (mattk->aatyp) {
X  			case AT_BITE:
X  				Sprintf(buf,"%s bites", Monnam(magr));
X--- 180,198 ----
X  	register struct monst *magr,*mdef;
X  	struct	attack *mattk;
X  {
X  	if(vis){
X+ 		int compat;
X  		char buf[BUFSZ];
X+ 
X  		if(mdef->mimic) seemimic(mdef);
X  		if(magr->mimic) seemimic(magr);
X! 		if((compat = could_seduce(magr,mdef,mattk)) && !magr->mcan) {
X  			Sprintf(buf, "%s %s", Monnam(magr),
X  				mdef->mblinded ? "talks to" : "smiles at");
X  			pline("%s %s %s.", buf, mon_nam(mdef),
X! 				compat == 2 ?
X  					"engagingly" : "seductively");
X  		} else {
X  		    switch (mattk->aatyp) {
X  			case AT_BITE:
X  				Sprintf(buf,"%s bites", Monnam(magr));
X***************
X*** 282,287 ****
X--- 265,273 ----
X  	if((tmp = mdamagem(magr, mdef, mattk)) == 2) {
X  		levl[mx][my].mmask = 0;
X  		levl[magr->mx][magr->my].mmask = 1;
X+ 		/* if mdamagem left a corpse it erased magr's symbol */
X+ 		unpmon(magr);
X+ 		pmon(magr);
X  		return(2);	/* defender died */
X  	} else {		/* defender survived */
X  		if(cansee(mdef->mx, mdef->my))
X***************
X*** 317,323 ****
X  	if(dist2(magr->mx, magr->my, u.ux, u.uy) < 3)
X  		(void) mdamageu(magr, d((int)mattk->damn, (int)mattk->damd));
X  
X! 	mondied(magr);
X  	return(2);
X  }
X  
X--- 303,309 ----
X  	if(dist2(magr->mx, magr->my, u.ux, u.uy) < 3)
X  		(void) mdamageu(magr, d((int)mattk->damn, (int)mattk->damd));
X  
X! 	mondead(magr);
X  	return(2);
X  }
X  
X*** src/Old/uhitm.c	Wed Aug 16 12:47:32 1989
X--- src/uhitm.c	Wed Aug 16 10:34:15 1989
X***************
X*** 87,110 ****
X  	}
X  
X  	if(mtmp->mimic && !Protection_from_shape_changers) {
X! 		if(!u.ustuck && !mtmp->mflee && dmgtype(mtmp->data,AD_STCK))
X! 			u.ustuck = mtmp;
X! 		if (levl[u.ux+u.dx][u.uy+u.dy].scrsym == DOOR_SYM)
X! #ifdef SPELLS
X! 		{
X! 		    if (okdoor(u.ux+u.dx, u.uy+u.dy))
X! #endif
X! 			pline("The door actually was %s.", defmonnam(mtmp));
X! #ifdef SPELLS
X! 		    else
X! 			pline("That spellbook was %s.", defmonnam(mtmp));
X! 		}
X! #endif
X! 		else if (levl[u.ux+u.dx][u.uy+u.dy].scrsym == GOLD_SYM)
X! 			pline("That gold was %s!", defmonnam(mtmp));
X! 		else
X! 			pline("Wait!  That's %s!", defmonnam(mtmp));
X! 		wakeup(mtmp);	/* clears mtmp->mimic */
X  		return(TRUE);
X  	}
X  
X--- 87,93 ----
X  	}
X  
X  	if(mtmp->mimic && !Protection_from_shape_changers) {
X! 		stumble_onto_mimic(mtmp);
X  		return(TRUE);
X  	}
X  
X***************
X*** 127,132 ****
X--- 110,162 ----
X  	return(FALSE);
X  }
X  
X+ schar
X+ find_roll_to_hit(mtmp)
X+ register struct monst *mtmp;
X+ {
X+ 	schar tmp;
X+ 	struct permonst *mdat = mtmp->data;
X+ 
X+ #ifdef POLYSELF
X+ 	tmp = Luck + mdat->ac + abon() +
X+ 		     ((u.umonnum >= 0) ? uasmon->mlevel : u.ulevel);
X+ #else
X+ 	tmp = Luck + u.ulevel + mdat->ac + abon();
X+ #endif
X+ /*	it is unchivalrous to attack the defenseless or from behind */
X+ 	if (pl_character[0] == 'K' && u.ualigntyp == U_LAWFUL &&
X+ 	    (mtmp->mfroz || mtmp->msleep || mtmp->mflee) &&
X+ 	    u.ualign > -10) adjalign(-1);
X+ 
X+ /*	Adjust vs. (and possibly modify) monster state.		*/
X+ 
X+ 	if(mtmp->mstun) tmp += 2;
X+ 	if(mtmp->mflee) tmp += 2;
X+ 
X+ 	if(mtmp->msleep) {
X+ 		mtmp->msleep = 0;
X+ 		tmp += 2;
X+ 	}
X+ 	if(mtmp->mfroz) {
X+ 		tmp += 4;
X+ 		if(!rn2(10)) mtmp->mfroz = 0;
X+ 	}
X+ 	if (is_orc(mtmp->data) && pl_character[0]=='E') tmp++;
X+ 
X+ /*	with a lot of luggage, your agility diminishes */
X+ 	tmp -= (inv_weight() + 40)/20;
X+ 	if(u.utrap) tmp -= 3;
X+ #ifdef POLYSELF
X+ /*	Some monsters have a combination of weapon attacks and non-weapon
X+  *	attacks.  It is therefore wrong to add hitval to tmp; we must add it
X+  *	only for the specific attack (in hmonas()).
X+  */
X+ 	if(uwep && u.umonnum == -1) tmp += hitval(uwep, mdat);
X+ #else
X+ 	if(uwep) tmp += hitval(uwep, mdat);
X+ #endif
X+ 	return tmp;
X+ }
X  
X  /* try to attack; return FALSE if monster evaded */
X  /* u.dx and u.dy must be set */
X***************
X*** 188,233 ****
X  			return(TRUE);
X  		}
X  	}
X- 	tmp = Luck + mdat->ac + abon() +
X- 		     ((u.umonnum >= 0) ? uasmon->mlevel : u.ulevel);
X- #else
X- 	tmp = Luck + u.ulevel + mdat->ac + abon();
X  #endif
X  
X! /*	it is unchivalrous to attack the defenseless or from behind */
X! 	if (pl_character[0] == 'K' && u.ualigntyp == U_LAWFUL &&
X! 	    (mtmp->mfroz || mtmp->msleep || mtmp->mflee) &&
X! 	    u.ualign > -10) adjalign(-1);
X! 
X! /*	Adjust vs. (and possibly modify) monster state.		*/
X! 
X! 	if(mtmp->mstun) tmp += 2;
X! 	if(mtmp->mflee) tmp += 2;
X! 
X! 	if(mtmp->msleep) {
X! 		mtmp->msleep = 0;
X! 		tmp += 2;
X! 	}
X! 	if(mtmp->mfroz) {
X! 		tmp += 4;
X! 		if(!rn2(10)) mtmp->mfroz = 0;
X! 	}
X! 	if (is_orc(mtmp->data) && pl_character[0]=='E') tmp++;
X! 
X! /*	with a lot of luggage, your agility diminishes */
X! 	tmp -= (inv_weight() + 40)/20;
X! 	if(u.utrap) tmp -= 3;
X! 
X! #ifdef POLYSELF
X! 	if(u.umonnum >= 0) (void) hmonas(mtmp, tmp);
X! 	else {
X! #endif
X! 		if(uwep) tmp += hitval(uwep, mdat);
X! 		(void) hitum(mtmp, tmp);
X  #ifdef POLYSELF
X! 	}
X  #endif
X! 
X  	return(TRUE);
X  }
X  
X--- 218,231 ----
X  			return(TRUE);
X  		}
X  	}
X  #endif
X  
X! 	tmp = find_roll_to_hit(mtmp);
X  #ifdef POLYSELF
X! 	if (u.umonnum >= 0) (void) hmonas(mtmp, tmp);
X! 	else
X  #endif
X! 	    (void) hitum(mtmp, tmp);
X  	return(TRUE);
X  }
X  
X***************
X*** 246,252 ****
X  	if(!mhit) {
X  	    if(!Blind && flags.verbose) You("miss %s.", mon_nam(mon));
X  	    else			You("miss it.");
X! 	    if(is_human(mon->data) && !(mon->msleep || mon->mfroz))
X  		wakeup(mon);
X  	} else {
X  	    /* we hit the monster; be careful: it might die! */
X--- 244,250 ----
X  	if(!mhit) {
X  	    if(!Blind && flags.verbose) You("miss %s.", mon_nam(mon));
X  	    else			You("miss it.");
X! 	    if(!mon->msleep && !mon->mfroz)
X  		wakeup(mon);
X  	} else {
X  	    /* we hit the monster; be careful: it might die! */
X***************
X*** 289,295 ****
X  	boolean mhit = !((tmp <= rnd(20)) && !u.uswallow);
X  
X  	malive = known_hitum(mon, mhit);
X! 	(void) passive(mon, mhit, malive);
X  	return(malive);
X  }
X  
X--- 287,293 ----
X  	boolean mhit = !((tmp <= rnd(20)) && !u.uswallow);
X  
X  	malive = known_hitum(mon, mhit);
X! 	(void) passive(mon, mhit, malive, FALSE);
X  	return(malive);
X  }
X  
X***************
X*** 300,308 ****
X  register int thrown;
X  {
X  	register int tmp;
X  	boolean hittxt = FALSE, destroyed = FALSE;
X  	boolean get_dmg_bonus = TRUE;
X! 	boolean ispoisoned = FALSE, needpoismsg = FALSE;
X  
X  	wakeup(mon);
X  	if(!obj) {
X--- 298,325 ----
X  register int thrown;
X  {
X  	register int tmp;
X+ 	/* Why all these booleans?  This stuff has to be done in the
X+ 	 *      following order:
X+ 	 * 1) Know what we're attacking with, and print special hittxt for
X+ 	 *	unusual cases.
X+ 	 * 2a) Know whether we did damage (depends on 1)
X+ 	 * 2b) Know if it's poisoned (depends on 1)
X+ 	 * 2c) Know whether we get a normal damage bonus or not (depends on 1)
X+ 	 * 3a) Know what the value of the damage bonus is (depends on 2c)
X+ 	 * 3b) Know how much poison damage was taken (depends on 2b) and if the
X+ 	 *	poison instant-killed it
X+ 	 * 4) Know if it was killed (requires knowing 3a, 3b) except by instant-
X+ 	 *	kill poison
X+ 	 * 5) Print hit message (depends on 1 and 4)
X+ 	 * 6a) Print poison message (must be done after 5)
X+ 	 * 6b) Rust weapon (must be done after 5)
X+ 	 * 7) Possibly kill monster (must be done after 6a, 6b)
X+ 	 * 8) Instant-kill from poison (can happen anywhere between 5 and 9)
X+ 	 * 9) Hands not glowing (must be done after 7 and 8)
X+ 	 */
X  	boolean hittxt = FALSE, destroyed = FALSE;
X  	boolean get_dmg_bonus = TRUE;
X! 	boolean ispoisoned = FALSE, needpoismsg = FALSE, poiskilled = FALSE;
X  
X  	wakeup(mon);
X  	if(!obj) {
X***************
X*** 502,512 ****
X  		needpoismsg = TRUE;
X  	    else if (rn2(10))
X  		tmp += rnd(6);
X! 	    else {
X! 		pline("The poison was deadly...");
X! 		xkilled(mon,0);
X! 		return FALSE;
X! 	    }
X  	}
X  	if(tmp < 1) tmp = 1;
X  
X--- 519,525 ----
X  		needpoismsg = TRUE;
X  	    else if (rn2(10))
X  		tmp += rnd(6);
X! 	    else poiskilled = TRUE;
X  	}
X  	if(tmp < 1) tmp = 1;
X  
X***************
X*** 545,551 ****
X  	if (needpoismsg)
X  		kludge("The poison doesn't seem to affect %s.", mon_nam(mon));
X  
X! 	if (destroyed)
X  		killed(mon);	/* takes care of messages */
X  	else if(u.umconf && !thrown) {
X  		if(!Blind) {
X--- 558,568 ----
X  	if (needpoismsg)
X  		kludge("The poison doesn't seem to affect %s.", mon_nam(mon));
X  
X! 	if (poiskilled) {
X! 		pline("The poison was deadly...");
X! 		xkilled(mon, 0);
X! 		return FALSE;
X! 	} else if (destroyed)
X  		killed(mon);	/* takes care of messages */
X  	else if(u.umconf && !thrown) {
X  		if(!Blind) {
X***************
X*** 579,585 ****
X  }
X  
X  #ifdef POLYSELF
X! static int
X  damageum(mdef, mattk)
X  register struct monst *mdef;
X  register struct attack *mattk;
X--- 596,603 ----
X  }
X  
X  #ifdef POLYSELF
X! 
X! int
X  damageum(mdef, mattk)
X  register struct monst *mdef;
X  register struct attack *mattk;
X***************
X*** 589,598 ****
X  
X  	stoned = FALSE;
X  	if (is_demon(uasmon) && !rn2(13) && !uwep
X! #ifdef HARD
X  		&& u.umonnum != PM_SUCCUBUS && u.umonnum != PM_INCUBUS
X  		&& u.umonnum != PM_BALROG
X! #endif
X  	    ) {
X  	    struct monst *dtmp;
X  	    pline("Some hell-p has arrived!");
X--- 607,616 ----
X  
X  	stoned = FALSE;
X  	if (is_demon(uasmon) && !rn2(13) && !uwep
X! # ifdef HARD
X  		&& u.umonnum != PM_SUCCUBUS && u.umonnum != PM_INCUBUS
X  		&& u.umonnum != PM_BALROG
X! # endif
X  	    ) {
X  	    struct monst *dtmp;
X  	    pline("Some hell-p has arrived!");
X***************
X*** 617,625 ****
X  			if(thick_skinned(mdef->data)) tmp = 0;
X  		break;
X  	    case AD_FIRE:
X! #ifdef GOLEMS
X  		golemeffects(mdef, AD_FIRE, tmp);
X! #endif /* GOLEMS */
X  		if(resists_fire(pd)) {
X  		    shieldeff(mdef->mx, mdef->my);
X  		    tmp = 0;
X--- 635,643 ----
X  			if(thick_skinned(mdef->data)) tmp = 0;
X  		break;
X  	    case AD_FIRE:
X! # ifdef GOLEMS
X  		golemeffects(mdef, AD_FIRE, tmp);
X! # endif /* GOLEMS */
X  		if(resists_fire(pd)) {
X  		    shieldeff(mdef->mx, mdef->my);
X  		    tmp = 0;
X***************
X*** 627,641 ****
X  		    if(!Blind) pline("%s is on fire!", Monnam(mdef));
X  		    tmp += destroy_mitem(mdef, SCROLL_SYM, AD_FIRE);
X  		    tmp += destroy_mitem(mdef, POTION_SYM, AD_FIRE);
X! #ifdef SPELLS
X  		    tmp += destroy_mitem(mdef, SPBOOK_SYM, AD_FIRE);
X! #endif
X  		}
X  		break;
X  	    case AD_COLD:
X! #ifdef GOLEMS
X  		golemeffects(mdef, AD_COLD, tmp);
X! #endif /* GOLEMS */
X  		if(resists_cold(pd)) {
X  		    shieldeff(mdef->mx, mdef->my);
X  		    tmp = 0;
X--- 645,659 ----
X  		    if(!Blind) pline("%s is on fire!", Monnam(mdef));
X  		    tmp += destroy_mitem(mdef, SCROLL_SYM, AD_FIRE);
X  		    tmp += destroy_mitem(mdef, POTION_SYM, AD_FIRE);
X! # ifdef SPELLS
X  		    tmp += destroy_mitem(mdef, SPBOOK_SYM, AD_FIRE);
X! # endif
X  		}
X  		break;
X  	    case AD_COLD:
X! # ifdef GOLEMS
X  		golemeffects(mdef, AD_COLD, tmp);
X! # endif /* GOLEMS */
X  		if(resists_cold(pd)) {
X  		    shieldeff(mdef->mx, mdef->my);
X  		    tmp = 0;
X***************
X*** 645,653 ****
X  		}
X  		break;
X  	    case AD_ELEC:
X! #ifdef GOLEMS
X  		golemeffects(mdef, AD_ELEC, tmp);
X! #endif /* GOLEMS */
X  		if(resists_elec(pd)) {
X  		    shieldeff(mdef->mx, mdef->my);
X  		    tmp = 0;
X--- 663,671 ----
X  		}
X  		break;
X  	    case AD_ELEC:
X! # ifdef GOLEMS
X  		golemeffects(mdef, AD_ELEC, tmp);
X! # endif /* GOLEMS */
X  		if(resists_elec(pd)) {
X  		    shieldeff(mdef->mx, mdef->my);
X  		    tmp = 0;
X***************
X*** 665,673 ****
X  		}
X  		tmp = 0;	/* no damage if this fails */
X  		break;
X! #ifdef SEDUCE
X  	    case AD_SSEX:
X! #endif
X  	    case AD_SEDU:
X  	    case AD_SITM:
X  		if(mdef->minvent) {
X--- 683,691 ----
X  		}
X  		tmp = 0;	/* no damage if this fails */
X  		break;
X! # ifdef SEDUCE
X  	    case AD_SSEX:
X! # endif
X  	    case AD_SEDU:
X  	    case AD_SITM:
X  		if(mdef->minvent) {
X***************
X*** 710,718 ****
X  				kludge("%s finishes taking off his suit.",
X  							Monnam(mdef));
X  				You("steal a %s.", xname(stealoid));
X! #ifdef ARMY
X  				mdef->data = &mons[PM_UNARMORED_SOLDIER];
X! #endif
X  			}
X  		   } else {
X  		   	   otmp = mdef->minvent;
X--- 728,736 ----
X  				kludge("%s finishes taking off his suit.",
X  							Monnam(mdef));
X  				You("steal a %s.", xname(stealoid));
X! # ifdef ARMY
X  				mdef->data = &mons[PM_UNARMORED_SOLDIER];
X! # endif
X  			}
X  		   } else {
X  		   	   otmp = mdef->minvent;
X***************
X*** 751,757 ****
X  		break;
X  	    case AD_CURS:
X  		if (night() && !rn2(10) && !mdef->mcan) {
X! #ifdef GOLEMS
X  		    if (mdef->data == &mons[PM_CLAY_GOLEM]) {
X  			if (!Blind)
X  			    pline("Some writing vanishes from %s's head!",
X--- 769,775 ----
X  		break;
X  	    case AD_CURS:
X  		if (night() && !rn2(10) && !mdef->mcan) {
X! # ifdef GOLEMS
X  		    if (mdef->data == &mons[PM_CLAY_GOLEM]) {
X  			if (!Blind)
X  			    pline("Some writing vanishes from %s's head!",
X***************
X*** 759,765 ****
X  			xkilled(mdef, 0);
X  			return 2;
X  		      }
X! #endif /* GOLEMS */
X  		    mdef->mcan = 1;
X  		    You("chuckle.");
X  		}
X--- 777,783 ----
X  			xkilled(mdef, 0);
X  			return 2;
X  		      }
X! # endif /* GOLEMS */
X  		    mdef->mcan = 1;
X  		    You("chuckle.");
X  		}
X***************
X*** 779,795 ****
X  		tmp = 0;
X  		break;
X  	    case AD_RUST:
X! #ifdef GOLEMS
X  		if (pd == &mons[PM_IRON_GOLEM]) {
X  			kludge("%s falls to pieces!", Monnam(mdef));
X  			xkilled(mdef,0);
X  			return(2);
X  		}
X! #endif /* GOLEMS */
X  		tmp = 0;
X  		break;
X  	    case AD_DCAY:
X! #ifdef GOLEMS
X  		if (pd == &mons[PM_WOOD_GOLEM] ||
X  		    pd == &mons[PM_LEATHER_GOLEM]) {
X  			kludge("%s falls to pieces!", Monnam(mdef));
X--- 797,813 ----
X  		tmp = 0;
X  		break;
X  	    case AD_RUST:
X! # ifdef GOLEMS
X  		if (pd == &mons[PM_IRON_GOLEM]) {
X  			kludge("%s falls to pieces!", Monnam(mdef));
X  			xkilled(mdef,0);
X  			return(2);
X  		}
X! # endif /* GOLEMS */
X  		tmp = 0;
X  		break;
X  	    case AD_DCAY:
X! # ifdef GOLEMS
X  		if (pd == &mons[PM_WOOD_GOLEM] ||
X  		    pd == &mons[PM_LEATHER_GOLEM]) {
X  			kludge("%s falls to pieces!", Monnam(mdef));
X***************
X*** 796,802 ****
X  			xkilled(mdef,0);
X  			return(2);
X  		}
X! #endif /* GOLEMS */
X  	    case AD_DRST:
X  	    case AD_DRDX:
X  	    case AD_DRCO:
X--- 814,820 ----
X  			xkilled(mdef,0);
X  			return(2);
X  		}
X! # endif /* GOLEMS */
X  	    case AD_DRST:
X  	    case AD_DRDX:
X  	    case AD_DRCO:
X***************
X*** 827,833 ****
X  	if((mdef->mhp -= tmp) < 1) {
X  
X  	    if(mdef->mtame) {
X! 		if(!Blind) You("killed your %s!", mon_nam(mdef));
X  		else	You("feel embarrassed for a moment.");
X  	    } else {
X  		if(!Blind && flags.verbose)  pline("%s is killed!", Monnam(mdef));
X--- 845,851 ----
X  	if((mdef->mhp -= tmp) < 1) {
X  
X  	    if(mdef->mtame) {
X! 		if(!Blind) You("killed your %s!", lmonnam(mdef) + 4);
X  		else	You("feel embarrassed for a moment.");
X  	    } else {
X  		if(!Blind && flags.verbose)  pline("%s is killed!", Monnam(mdef));
X***************
X*** 863,873 ****
X  			 killed(mdef);
X  			 return(2);
X  		    }
X! #ifdef GOLEMS
X  		} else if (is_golem(mdef->data)) {
X  		    golemeffects(mdef, AD_COLD, d(6,6));
X  		    shieldeff(mdef->mx, mdef->my);
X! #endif /* GOLEMS */
X  		} else {
X  		    shieldeff(mdef->mx, mdef->my);
X  		    kludge("The blast doesn't seem to affect %s.",
X--- 881,891 ----
X  			 killed(mdef);
X  			 return(2);
X  		    }
X! # ifdef GOLEMS
X  		} else if (is_golem(mdef->data)) {
X  		    golemeffects(mdef, AD_COLD, d(6,6));
X  		    shieldeff(mdef->mx, mdef->my);
X! # endif /* GOLEMS */
X  		} else {
X  		    shieldeff(mdef->mx, mdef->my);
X  		    kludge("The blast doesn't seem to affect %s.",
X***************
X*** 894,910 ****
X  	 * after exactly 1 round of attack otherwise.  -KAA
X  	 */
X  
X! #ifdef WORM
X  	if(mdef->wormno) return 0;
X! #endif
X  	if(u.uhunger < 1500 && !u.uswallow) {
X  
X  	    if(mdef->data->mlet != S_COCKATRICE) {
X! #ifdef LINT	/* static char msgbuf[BUFSZ]; */
X  		char msgbuf[BUFSZ];
X! #else
X  		static char msgbuf[BUFSZ];
X! #endif
X  /* TODO: get the symbol display also to work (monster symbol is removed from
X   * the screen and you moved onto it, then you get moved back and it gets
X   * moved back if the monster survives--just like when monsters swallow you.
X--- 912,928 ----
X  	 * after exactly 1 round of attack otherwise.  -KAA
X  	 */
X  
X! # ifdef WORM
X  	if(mdef->wormno) return 0;
X! # endif
X  	if(u.uhunger < 1500 && !u.uswallow) {
X  
X  	    if(mdef->data->mlet != S_COCKATRICE) {
X! # ifdef LINT	/* static char msgbuf[BUFSZ]; */
X  		char msgbuf[BUFSZ];
X! # else
X  		static char msgbuf[BUFSZ];
X! # endif
X  /* TODO: get the symbol display also to work (monster symbol is removed from
X   * the screen and you moved onto it, then you get moved back and it gets
X   * moved back if the monster survives--just like when monsters swallow you.
X***************
X*** 949,957 ****
X  				kludge("%s seems unhurt.", Monnam(mdef));
X  				dam = 0;
X  			    }
X! #ifdef GOLEMS
X  			    golemeffects(mdef,(int)mattk->adtyp,dam);
X! #endif
X  			} else dam = 0;
X  			break;
X  		    case AD_COLD:
X--- 967,975 ----
X  				kludge("%s seems unhurt.", Monnam(mdef));
X  				dam = 0;
X  			    }
X! # ifdef GOLEMS
X  			    golemeffects(mdef,(int)mattk->adtyp,dam);
X! # endif
X  			} else dam = 0;
X  			break;
X  		    case AD_COLD:
X***************
X*** 961,969 ****
X  				dam = 0;
X  			    } else
X  				kludge("%s is freezing to death!",Monnam(mdef));
X! #ifdef GOLEMS
X  			    golemeffects(mdef,(int)mattk->adtyp,dam);
X! #endif
X  			} else dam = 0;
X  			break;
X  		    case AD_FIRE:
X--- 979,987 ----
X  				dam = 0;
X  			    } else
X  				kludge("%s is freezing to death!",Monnam(mdef));
X! # ifdef GOLEMS
X  			    golemeffects(mdef,(int)mattk->adtyp,dam);
X! # endif
X  			} else dam = 0;
X  			break;
X  		    case AD_FIRE:
X***************
X*** 973,981 ****
X  				dam = 0;
X  			    } else
X  				kludge("%s is burning to a crisp!",Monnam(mdef));
X! #ifdef GOLEMS
X  			    golemeffects(mdef,(int)mattk->adtyp,dam);
X! #endif
X  			} else dam = 0;
X  			break;
X  		}
X--- 991,999 ----
X  				dam = 0;
X  			    } else
X  				kludge("%s is burning to a crisp!",Monnam(mdef));
X! # ifdef GOLEMS
X  			    golemeffects(mdef,(int)mattk->adtyp,dam);
X! # endif
X  			} else dam = 0;
X  			break;
X  		}
X***************
X*** 994,1022 ****
X  		kludge("You bite into %s", mon_nam(mdef));
X  		You("turn to stone...");
X  		killer = "poor choice of food";
X! 		done("stoned");
X  	    }
X  	}
X  	return(0);
X  }
X  
X! static void
X! missum(mdef)
X  register struct monst *mdef;
X  {
X! #ifdef POLYSELF
X! 	if (u.usym==S_NYMPH
X! #  ifdef SEDUCE
X! || ((u.umonnum==PM_INCUBUS || u.umonnum==PM_SUCCUBUS) && !incompatible(mdef))
X! #  endif
X! 									)
X  		kludge("You pretend to be friendly to %s.", mon_nam(mdef));
X  	else
X! #endif
X! 	if(!Blind && flags.verbose)  You("miss %s.", mon_nam(mdef));
X! 	else	    You("miss it.");
X! 	if(is_human(mdef->data) && !(mdef->msleep || mdef->mfroz))
X! 		wakeup(mdef);
X  }
X  
X  static boolean
X--- 1012,1035 ----
X  		kludge("You bite into %s", mon_nam(mdef));
X  		You("turn to stone...");
X  		killer = "poor choice of food";
X! 		done(STONING);
X  	    }
X  	}
X  	return(0);
X  }
X  
X! void
X! missum(mdef,mattk)
X  register struct monst *mdef;
X+ register struct attack *mattk;
X  {
X! 	if (could_seduce(&youmonst, mdef, mattk))
X  		kludge("You pretend to be friendly to %s.", mon_nam(mdef));
X+ 	else if(!Blind && flags.verbose)
X+ 		You("miss %s.", mon_nam(mdef));
X  	else
X! 		You("miss it.");
X! 	wakeup(mdef);
X  }
X  
X  static boolean
X***************
X*** 1031,1036 ****
X--- 1044,1050 ----
X  
X  	for(i = 0; i < NATTK; i++) {
X  
X+ 	    sum[i] = 0;
X  	    mattk = &(uasmon->mattk[i]);
X  	    switch(mattk->aatyp) {
X  		case AT_WEAP:
X***************
X*** 1054,1082 ****
X  			if (dhit && mattk->adtyp != AD_SPEL
X  				&& mattk->adtyp != AD_PHYS)
X  				sum[i] = damageum(mon,mattk);
X- 			else sum[i] = 0;
X  			break;
X  		case AT_CLAW:
X  			if (i==0 && uwep && humanoid(uasmon)) goto use_weapon;
X  		case AT_KICK:
X  		case AT_BITE:
X  		case AT_STNG:
X  		case AT_TUCH:
X  		case AT_BUTT:
X! 			if (i==0 && uwep && (u.usym==S_LICH
X! 				)) goto use_weapon;
X  			if(dhit = (tmp > rnd(20) || u.uswallow)) {
X! /* <----- <----- <----- <----- <----- <----- <----- <----- <----- */
X! if (!u.uswallow && (u.usym==S_NYMPH
X! #ifdef SEDUCE
X!   || ((u.umonnum==PM_INCUBUS || u.umonnum==PM_SUCCUBUS) && !incompatible(mon))
X! #endif
X! 									)) {
X! 		kludge("You %s %s %s.", mon->mblinded ? "talk to" : "smile at",
X! 			mon_nam(mon),
X! 			incompatible(mon) ? "engagingly" : "seductively");
X! }
X! /* <----- <----- <----- <----- <----- <----- <----- <----- <----- */
X  				else if (mattk->aatyp == AT_KICK)
X  					kludge("You kick %s.", mon_nam(mon));
X  				else if (mattk->aatyp == AT_BITE)
X--- 1068,1099 ----
X  			if (dhit && mattk->adtyp != AD_SPEL
X  				&& mattk->adtyp != AD_PHYS)
X  				sum[i] = damageum(mon,mattk);
X  			break;
X  		case AT_CLAW:
X  			if (i==0 && uwep && humanoid(uasmon)) goto use_weapon;
X+ # ifdef SEDUCE
X+ 			/* succubi/incubi are humanoid, but their _second_
X+ 			 * attack is AT_CLAW, not their first...
X+ 			 */
X+ 			if (i==1 && uwep && (u.umonnum == PM_SUCCUBUS ||
X+ 				u.umonnum == PM_INCUBUS)) goto use_weapon;
X+ # endif
X  		case AT_KICK:
X  		case AT_BITE:
X  		case AT_STNG:
X  		case AT_TUCH:
X  		case AT_BUTT:
X! 			if (i==0 && uwep && (u.usym==S_LICH)) goto use_weapon;
X  			if(dhit = (tmp > rnd(20) || u.uswallow)) {
X! 				int compat;
X! 
X! 				if (!u.uswallow &&
X! 				    (compat = could_seduce(&youmonst,
X! 							    mon, mattk)))
X! 				pline("You %s %s %s.",
X! 				    mon->mblinded ? "talk to" : "smile at",
X! 				    Blind ? "it" : mon_nam(mon),
X! 				    compat == 2 ? "engagingly" : "seductively");
X  				else if (mattk->aatyp == AT_KICK)
X  					kludge("You kick %s.", mon_nam(mon));
X  				else if (mattk->aatyp == AT_BITE)
X***************
X*** 1089,1098 ****
X  					kludge("You touch %s.", mon_nam(mon));
X  				else kludge("You hit %s.", mon_nam(mon));
X  				sum[i] = damageum(mon, mattk);
X! 			} else {
X! 				missum(mon);
X! 				sum[i] = 0;
X! 			}
X  			break;
X  
X  		case AT_HUGS:
X--- 1106,1113 ----
X  					kludge("You touch %s.", mon_nam(mon));
X  				else kludge("You hit %s.", mon_nam(mon));
X  				sum[i] = damageum(mon, mattk);
X! 			} else
X! 				missum(mon, mattk);
X  			break;
X  
X  		case AT_HUGS:
X***************
X*** 1100,1118 ****
X  			 * already grabbed in a previous attack
X  			 */
X  			dhit = 1;
X! 			if (sticks(mon->data)) sum[i] = 0;
X! 			else if (mon==u.ustuck) {
X! 			    kludge("%s is being %s.", Monnam(mon),
X! #ifdef GOLEMS
X! 				u.umonnum==PM_ROPE_GOLEM ? "choked":
X! #endif
X! 				"crushed");
X! 			    sum[i] = damageum(mon, mattk);
X! 			} else if(sum[i-1] && sum[i-2]) {
X! 			    kludge("You grab %s!", mon_nam(mon));
X! 			    u.ustuck = mon;
X! 			    sum[i] = damageum(mon, mattk);
X! 			} else sum[i] = 0;
X  			break;
X  
X  		case AT_EXPL:	/* automatic hit if next to */
X--- 1115,1133 ----
X  			 * already grabbed in a previous attack
X  			 */
X  			dhit = 1;
X! 			if (!sticks(mon->data))
X! 			    if (mon==u.ustuck) {
X! 				kludge("%s is being %s.", Monnam(mon),
X! # ifdef GOLEMS
X! 				    u.umonnum==PM_ROPE_GOLEM ? "choked":
X! # endif
X! 				    "crushed");
X! 				sum[i] = damageum(mon, mattk);
X! 			    } else if(sum[i-1] && sum[i-2]) {
X! 				kludge("You grab %s!", mon_nam(mon));
X! 				u.ustuck = mon;
X! 				sum[i] = damageum(mon, mattk);
X! 			    }
X  			break;
X  
X  		case AT_EXPL:	/* automatic hit if next to */
X***************
X*** 1123,1132 ****
X  		case AT_ENGL:
X  			if((dhit = (tmp > rnd(20+i))))
X  				sum[i]= gulpum(mon,mattk);
X! 			else {
X! 				missum(mon);
X! 				sum[i] = 0;
X! 			}
X  			break;
X  
X  		case AT_MAGC:
X--- 1138,1145 ----
X  		case AT_ENGL:
X  			if((dhit = (tmp > rnd(20+i))))
X  				sum[i]= gulpum(mon,mattk);
X! 			else
X! 				missum(mon, mattk);
X  			break;
X  
X  		case AT_MAGC:
X***************
X*** 1139,1145 ****
X  				)) goto use_weapon;
X  
X  		case AT_NONE:
X- 			sum[i] = 0;
X  			continue;
X  			/* Not break--avoid passive attacks from enemy */
X  
X--- 1152,1157 ----
X***************
X*** 1149,1162 ****
X  		case AT_BREA:
X  		case AT_SPIT:
X  		case AT_GAZE:	/* all done using #monster command */
X! 			sum[i] = dhit = 0;
X  			break;
X  	    }
X  	    if (dhit == -1)
X  		rehumanize();
X! 	    if(sum[i] == 2) return(passive(mon, 1, 0)); /* defender dead */
X  	    else {
X! 		(void) passive(mon, sum[i], 1);
X  		nsum |= sum[i];
X  	    }
X  	    if (uasmon == &playermon)
X--- 1161,1175 ----
X  		case AT_BREA:
X  		case AT_SPIT:
X  		case AT_GAZE:	/* all done using #monster command */
X! 			dhit = 0;
X  			break;
X  	    }
X  	    if (dhit == -1)
X  		rehumanize();
X! 	    if(sum[i] == 2) return(passive(mon, 1, 0, (mattk->aatyp==AT_KICK)));
X! 							/* defender dead */
X  	    else {
X! 		(void) passive(mon, sum[i], 1, (mattk->aatyp==AT_KICK));
X  		nsum |= sum[i];
X  	    }
X  	    if (uasmon == &playermon)
X***************
X*** 1167,1181 ****
X  	return(nsum);
X  }
X  
X! #endif
X  
X  /*	Special (passive) attacks on you by monsters done here.		*/
X  
X  int
X! passive(mon, mhit, malive)
X  register struct monst *mon;
X  register boolean mhit;
X  register int malive;
X  {
X  	register struct permonst *ptr = mon->data;
X  	register int i, tmp;
X--- 1180,1195 ----
X  	return(nsum);
X  }
X  
X! #endif /* POLYSELF */
X  
X  /*	Special (passive) attacks on you by monsters done here.		*/
X  
X  int
X! passive(mon, mhit, malive, kicked)
X  register struct monst *mon;
X  register boolean mhit;
X  register int malive;
X+ boolean kicked;
X  {
X  	register struct permonst *ptr = mon->data;
X  	register int i, tmp;
X***************
X*** 1201,1207 ****
X  			mdamageu(mon, tmp);
X  		if(!rn2(30)) corrode_armor();
X  	    }
X! 	    if(mhit && !rn2(6)) corrode_weapon();
X  	    break;
X  	  case AD_MAGM:
X  	    /* wrath of gods for attacking Oracle */
X--- 1215,1226 ----
X  			mdamageu(mon, tmp);
X  		if(!rn2(30)) corrode_armor();
X  	    }
X! 	    if(mhit && !rn2(6)) {
X! 		if (kicked) {
X! 		    if (uarmf)
X! 			(void) rust_dmg(uarmf, xname(uarmf), 1, TRUE);
X! 		} else corrode_weapon();
X! 	    }
X  	    break;
X  	  case AD_MAGM:
X  	    /* wrath of gods for attacking Oracle */
X***************
X*** 1306,1309 ****
X--- 1325,1357 ----
X  	    }
X  	}
X  	return(malive | mhit);
X+ }
X+ 
X+ /* Note: caller must ascertain mtmp->mimic... */
X+ void
X+ stumble_onto_mimic(mtmp)
X+ register struct monst *mtmp;
X+ {
X+ 	if(!u.ustuck && !mtmp->mflee && dmgtype(mtmp->data,AD_STCK))
X+ 		u.ustuck = mtmp;
X+ 	if (Blind) goto generic;
X+ 	else if (levl[u.ux+u.dx][u.uy+u.dy].scrsym == DOOR_SYM)
X+ #ifdef SPELLS
X+ 	{
X+ 		if (IS_ROCK(levl[u.ux+u.dx][u.uy+u.dy].typ) ||
X+ 		    IS_DOOR(levl[u.ux+u.dx][u.uy+u.dy].typ))
X+ #endif
X+ 			pline("The door actually was %s.", defmonnam(mtmp));
X+ #ifdef SPELLS
X+ 		else
X+ 			pline("That spellbook was %s.", defmonnam(mtmp));
X+ 	}
X+ #endif
X+ 	else if (levl[u.ux+u.dx][u.uy+u.dy].scrsym == GOLD_SYM)
X+ 		pline("That gold was %s!", defmonnam(mtmp));
X+ 	else {
X+ generic:
X+ 		pline("Wait!  That's %s!", defmonnam(mtmp));
X+ 	}
X+ 	wakeup(mtmp);	/* clears mtmp->mimic */
X  }
X*** src/Old/unixmain.c	Wed Aug 16 12:48:29 1989
X--- src/unixmain.c	Tue Aug 15 22:05:14 1989
X***************
X*** 67,74 ****
X  	}
X  #endif /* CHDIR /**/
X  	/* Set the default values of the presentation characters */
X! 	(void) memcpy((char *) &showsyms, 
X! 		(char *) &defsyms, sizeof(struct symbols));
X  	initoptions();
X  	whoami();
X  	/*
X--- 67,74 ----
X  	}
X  #endif /* CHDIR /**/
X  	/* Set the default values of the presentation characters */
X! 	(void) memcpy((genericptr_t) &showsyms,
X! 		(genericptr_t) &defsyms, sizeof(struct symbols));
X  	initoptions();
X  	whoami();
X  	/*
X***************
X*** 240,247 ****
X  		/* get shopkeeper set properly if restore is in shop */
X  		(void) inshop();
X  #ifdef EXPLORE_MODE
X! 		if (discover) {
X  			You("are in non-scoring discovery mode.");
X  			pline("Do you want to keep the save file? ");
X  			if(yn() == 'n')
X  				(void) unlink(SAVEF);
X--- 240,250 ----
X  		/* get shopkeeper set properly if restore is in shop */
X  		(void) inshop();
X  #ifdef EXPLORE_MODE
X! 		if (discover)
X  			You("are in non-scoring discovery mode.");
X+ #endif
X+ #if defined(EXPLORE_MODE) || defined(WIZARD)
X+ 		if (discover || wizard) {
X  			pline("Do you want to keep the save file? ");
X  			if(yn() == 'n')
X  				(void) unlink(SAVEF);
X***************
X*** 305,311 ****
X  #endif
X  			    if(u.uhp < 1) {
X  				You("die...");
X! 				done("died");
X  			    }
X  #ifdef POLYSELF
X  			if (u.mtimedone) {
X--- 308,314 ----
X  #endif
X  			    if(u.uhp < 1) {
X  				You("die...");
X! 				done(DIED);
X  			    }
X  #ifdef POLYSELF
X  			if (u.mtimedone) {
X*** src/Old/unixtty.c	Wed Aug 16 12:48:50 1989
X--- src/unixtty.c	Tue Aug 15 22:59:01 1989
X***************
X*** 37,42 ****
X--- 37,44 ----
X  #define CBRKMASK	ICANON
X  #define CBRKON		! /* reverse condition */
X  #define OSPEED(x)	((x).c_cflag & CBAUD)
X+ #define inputflags	c_iflag
X+ #define STRIPHI		ISTRIP
X  #define GTTY(x)		(ioctl(0, TCGETA, x))
X  /* STTY now modified to run under Sys V R3.	- may have to be #ifdef'ed */
X  #define STTY(x)		(ioctl(0, TCSETAW, x))	/* TCSETAF? TCSETAW? */
X***************
X*** 59,64 ****
X--- 61,68 ----
X  #define cbrkflgs	sg_flags
X  #define CBRKMASK	CBREAK
X  #define CBRKON		/* empty */
X+ #define inputflags	sg_flags	/* don't know how enabling meta bits */
X+ #define STRIPHI		0		/* should actually be done on BSD */
X  #define OSPEED(x)	(x).sg_ospeed
X  #define GTTY(x)		(gtty(0, x))
X  #define STTY(x)		(stty(0, x))
X***************
X*** 118,123 ****
X--- 122,128 ----
X  		perror("NetHack (settty)");
X  	flags.echo = (inittyb.echoflgs & ECHO) ? ON : OFF;
X  	flags.cbreak = (CBRKON(inittyb.cbrkflgs & CBRKMASK)) ? ON : OFF;
X+ 	curttyb.inputflags |= STRIPHI;
X  	setioctls();
X  }
X  
X***************
X*** 148,153 ****
X--- 153,159 ----
X  #endif
X  		change++;
X  	}
X+ 	curttyb.inputflags &=~ STRIPHI;
X  	/* If an interrupt character is used, it will be overriden and
X  	 * set to ^C.
X  	 */
X*** src/Old/unixunix.c	Wed Aug 16 12:49:07 1989
X--- src/unixunix.c	Tue Aug  1 20:39:25 1989
X***************
X*** 331,342 ****
X  	/* avoid problems with 14 character file name limit */
X  # ifdef COMPRESS
X  	if(strlen(s) > 10)
X! 		/* leave room for .e from error and .Z from compress */
X  		s[10] = '\0';
X  # else
X! 	if(strlen(s) > 12)
X! 		/* leave room for .e from error */
X! 		s[12] = '\0';
X  # endif
X  #endif
X  }
X--- 331,343 ----
X  	/* avoid problems with 14 character file name limit */
X  # ifdef COMPRESS
X  	if(strlen(s) > 10)
X! 		/* leave room for .e from error and .Z from compress
X! 		 * appended to save files */
X  		s[10] = '\0';
X  # else
X! 	if(strlen(s) > 11)
X! 		/* leave room for .nn appended to level files */
X! 		s[11] = '\0';
X  # endif
X  #endif
X  }
END_OF_FILE
if test 54146 -ne `wc -c <'patch02d'`; then
    echo shar: \"'patch02d'\" unpacked with wrong size!
fi
# end of 'patch02d'
fi
echo shar: End of archive 4 \(of 7\).
cp /dev/null ark4isdone
MISSING=""
for I in 1 2 3 4 5 6 7 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 7 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
