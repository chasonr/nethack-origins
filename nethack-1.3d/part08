Relay-Version: version B 2.10 5/3/83; site utzoo.UUCP
Path: utzoo!mnetor!uunet!seismo!rochester!cornell!uw-beaver!tektronix!tekgen!tekred!games-request
From: games-request@tekred.TEK.COM
Newsgroups: comp.sources.games
Subject: v02i008:  nethack - display oriented dungeons & dragons, Part08/16
Message-ID: <1450@tekred.TEK.COM>
Date: Tue, 28-Jul-87 13:49:55 EDT
Article-I.D.: tekred.1450
Posted: Tue Jul 28 13:49:55 1987
Date-Received: Fri, 31-Jul-87 01:14:29 EDT
Sender: billr@tekred.TEK.COM
Lines: 2336
Approved: billr@tekred.TEK.COM

Submitted by: mike@genat.UUCP (Mike Stephenson)
Comp.sources.games: Volume 2, Issue 8
Archive-name: nethack/Part08



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 8 (of 16)."
# Contents:  eat.c lev.c mhitu.c u_init.c undo.sh
# Wrapped by billr@tekred on Tue Jul 28 09:49:34 1987
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f eat.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"eat.c\"
else
echo shar: Extracting \"eat.c\" \(13123 characters\)
sed "s/^X//" >eat.c <<'END_OF_eat.c'
X/*	SCCS Id: @(#)eat.c	1.3	87/07/14
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* eat.c - version 1.0.3 */
X
X#include	"hack.h"
X#ifdef KAA
Xchar POISONOUS[] = "ADKSVabhks&";
X#else
Xchar POISONOUS[] = "ADKSVabhks";
X#endif
Xextern char *nomovemsg;
Xextern int (*afternmv)();
Xextern int (*occupation)();
Xextern char *occtxt;
Xextern struct obj *splitobj(), *addinv();
X
X/* hunger texts used on bottom line (each 8 chars long) */
X#define	SATIATED	0
X#define NOT_HUNGRY	1
X#define	HUNGRY		2
X#define	WEAK		3
X#define	FAINTING	4
X#define FAINTED		5
X#define STARVED		6
X
Xchar *hu_stat[] = {
X	"Satiated",
X	"        ",
X	"Hungry  ",
X	"Weak    ",
X	"Fainting",
X	"Fainted ",
X	"Starved "
X};
X
Xinit_uhunger(){
X	u.uhunger = 900;
X	u.uhs = NOT_HUNGRY;
X}
X
Xstruct { char *txt; int nut; } tintxts[] = {
X	"It contains salmon - not bad!",	60,
X	"It contains first quality peaches - what a surprise!",	40,
X	"It contains apple juice - perhaps not what you hoped for.", 20,
X	"It contains some nondescript substance, tasting awfully.", 500,
X	"It contains rotten meat. You vomit.", -50,
X	"It turns out to be empty.",	0
X};
X#define	TTSZ	SIZE(tintxts)
X
Xstatic struct {
X	struct obj *tin;
X	int usedtime, reqtime;
X} tin;
X
Xopentin(){
X	register int r;
X
X	if(!carried(tin.tin))		/* perhaps it was stolen? */
X		return(0);		/* %% probably we should use tinoid */
X	if(tin.usedtime++ >= 50) {
X		pline("You give up your attempt to open the tin.");
X		return(0);
X	}
X	if(tin.usedtime < tin.reqtime)
X		return(1);		/* still busy */
X
X	pline("You succeed in opening the tin.");
X	useup(tin.tin);
X	r = rn2(2*TTSZ);
X	if(r < TTSZ) {
X	    pline(tintxts[r].txt);
X	    lesshungry(tintxts[r].nut);
X	    /* check for vomiting added by GAN 01/16/87 */
X	    if(tintxts[r].nut < 0 && Sick) {
X		Sick = 0;
X		pline("What a relief!");
X	    }
X	    if(r == 0) {			/* Salmon */
X		Glib = rnd(15);
X		pline("Eating salmon made your fingers very slippery.");
X	    }
X	} else {
X	    pline("It contains spinach - this makes you feel like %s!",
X		Hallucination ? "Swee'pea" : "Popeye");
X
X	    lesshungry(600);
X	    gainstr(0);
X	}
X	return(0);
X}
X
XMeatdone(){
X	u.usym = '@';
X	prme();
X}
X
Xdoeat(){
X	register struct obj *otmp;
X	register struct objclass *ftmp;
X	register tmp;
X
X	/* Is there some food (probably a heavy corpse) here on the ground? */
X	if(!Levitation)
X	for(otmp = fobj; otmp; otmp = otmp->nobj) {
X		if(otmp->ox == u.ux && otmp->oy == u.uy &&
X		   otmp->olet == FOOD_SYM) {
X			pline("There %s %s here; eat %s? [ny] ",
X				(otmp->quan == 1) ? "is" : "are",
X				doname(otmp),
X				(otmp->quan == 1) ? "it" : "one");
X			if(readchar() == 'y') {
X				if(otmp->quan != 1)
X					(void) splitobj(otmp, 1);
X				freeobj(otmp);
X				otmp = addinv(otmp);
X				addtobill(otmp);
X				if(Invisible) newsym(u.ux, u.uy);
X				goto gotit;
X			}
X		}
X	}
X	otmp = getobj("%", "eat");
X	if(!otmp) return(0);
Xgotit:
X	if(otmp->otyp == TIN) {
X		if(uwep) {
X			switch(uwep->otyp) {
X			case CAN_OPENER:
X				tmp = 1;
X				break;
X			case DAGGER:
X			case CRYSKNIFE:
X				tmp = 3;
X				break;
X			case PICK_AXE:
X			case AXE:
X				tmp = 6;
X				break;
X			default:
X				goto no_opener;
X			}
X			pline("Using your %s you try to open the tin.",
X				aobjnam(uwep, (char *) 0));
X		} else {
X		no_opener:
X			pline("It is not so easy to open this tin.");
X			if(Glib) {
X				pline("The tin slips out of your hands.");
X				if(otmp->quan > 1) {
X					register struct obj *obj;
X					extern struct obj *splitobj();
X
X					obj = splitobj(otmp, 1);
X					if(otmp == uwep) setuwep(obj);
X				}
X				dropx(otmp);
X				return(1);
X			}
X			tmp = 10 + rn2(1 + 500/((int)(u.ulevel + u.ustr)));
X		}
X		tin.reqtime = tmp;
X		tin.usedtime = 0;
X		tin.tin = otmp;
X#ifdef DGK
X		set_occupation(opentin, "opening the tin", 0);
X#else
X		occupation = opentin;
X		occtxt = "opening the tin";
X#endif
X		return(1);
X	}
X	ftmp = &objects[otmp->otyp];
X	multi = -ftmp->oc_delay;
X	if(otmp->otyp >= CORPSE && eatcorpse(otmp)) goto eatx;
X#ifdef DGKMOD
X	if(!rn2(7) && otmp->otyp != FORTUNE_COOKIE && otmp->otyp != DEAD_LIZARD) {
X#else
X	if(!rn2(7) && otmp->otyp != FORTUNE_COOKIE) {
X#endif
X#ifdef KAA
X		if (otmp->otyp == DEAD_VIOLET_FUNGUS)
X			pline("Seems rather stale though...");
X		else
X#endif
X		pline("Blecch!  Rotten food!");
X		if(!rn2(4)) {
X			if (Hallucination) pline("You feel rather trippy.");
X			else
X				pline("You feel rather light headed.");
X			HConfusion += d(2,4);
X		} else if(!rn2(4) && !Blind) {
X			pline("Everything suddenly goes dark.");
X			Blind = d(2,10);
X			seeoff(0);
X		} else if(!rn2(3)) {
X			if(Blind)
X			  pline("The world spins and you slap against the floor.");
X			else
X			  pline("The world spins and goes dark.");
X			nomul(-rnd(10));
X			nomovemsg = "You are conscious again.";
X		}
X		lesshungry(ftmp->nutrition / 4);
X	} else {
X		if(u.uhunger >= 1500) choke(ftmp);
X
X		switch(otmp->otyp){
X		case FOOD_RATION:
X			if(u.uhunger <= 200)
X			    if (Hallucination)
X				pline("Oh wow, like superior man!");
X			    else
X				pline("That food really hit the spot!");
X			else if(u.uhunger <= 700)
X				pline("That satiated your stomach!");
X#ifdef DGKMOD
X	/* Have lesshungry() report when you're nearly full so all eating
X	 * warns when you're about to choke.
X	 */
X			lesshungry(ftmp->nutrition);
X#else
X			else {
X	pline("You're having a hard time getting all that food down.");
X				multi -= 2;
X			}
X			lesshungry(ftmp->nutrition);
X			if(multi < 0) nomovemsg = "You finished your meal.";
X#endif /* DGKMOD /**/
X			break;
X		case TRIPE_RATION:
X			if (u.usym != '@')
X			    pline("That tripe ration was surprisingly good!");
X			else {
X			    pline("Yak - dog food!");
X			    more_experienced(1,0);
X			    flags.botl = 1;
X			}
X			if(rn2(2) && u.usym == '@'){
X				pline("You vomit.");
X				morehungry(20);
X				if(Sick) {
X					Sick = 0;	/* David Neves */
X					pline("What a relief!");
X				}
X			} else	lesshungry(ftmp->nutrition);
X			break;
X		default:
X			if(u.usym == '@' && otmp->otyp >= CORPSE) {
X#ifdef KAA
X			    if(otmp->otyp != DEAD_VIOLET_FUNGUS)
X#endif
X			    pline("That %s tasted terrible!",ftmp->oc_name);
X			} else
X			pline("That %s was delicious!",ftmp->oc_name);
X			lesshungry(ftmp->nutrition);
X#ifdef DGKMOD
X			/* Relief from cockatrices -dgk */
X			if (otmp->otyp == DEAD_LIZARD) {
X				if (Stoned) {
X					Stoned = 0;
X					pline("You feel more limber!");
X				}
X				if (HConfusion > 2)
X					HConfusion = 2;
X			}
X#else
X			if(otmp->otyp == DEAD_LIZARD && (HConfusion > 2))
X				HConfusion = 2;
X#endif /* DGKMOD /**/
X			else
X#ifdef QUEST
X			if(otmp->otyp == CARROT && !Blind){
X				u.uhorizon++;
X				setsee();
X				pline("Your vision improves.");
X			} else
X#endif
X#ifdef KAA
X			if(otmp->otyp == CARROT && Blind) Blind=1;
X			else
X#endif
X			if(otmp->otyp == FORTUNE_COOKIE) {
X			  if(Blind) {
X			    pline("This cookie has a scrap of paper inside!");
X			    pline("What a pity, that you cannot read it!");
X			  } else
X			    outrumor();
X			} else
X			if(otmp->otyp == LUMP_OF_ROYAL_JELLY) {
X				/* This stuff seems to be VERY healthy! */
X				gainstr(1);
X				u.uhp += rnd(20);
X				if(u.uhp > u.uhpmax) {
X					if(!rn2(17)) u.uhpmax++;
X					u.uhp = u.uhpmax;
X				}
X				heal_legs();
X			}
X			break;
X		}
X	}
Xeatx:
X	if(multi<0 && !nomovemsg){
X		static char msgbuf[BUFSZ];
X		(void) sprintf(msgbuf, "You finished eating the %s.",
X				ftmp->oc_name);
X		nomovemsg = msgbuf;
X	}
X	useup(otmp);
X	return(1);
X}
X
X/* called in main.c */
Xgethungry(){
X	--u.uhunger;
X	if(moves % 2) {
X		if(HRegeneration) u.uhunger--;
X		if(Hunger) u.uhunger--;
X		/* a3:  if(Hunger & LEFT_RING) u.uhunger--;
X			if(Hunger & RIGHT_RING) u.uhunger--;
X		   etc. */
X	}
X	if(moves % 20 == 0) {			/* jimt@asgb */
X		if(uleft) u.uhunger--;
X		if(uright) u.uhunger--;
X	}
X	newuhs(TRUE);
X}
X
X/* called after vomiting and after performing feats of magic */
Xmorehungry(num) register num; {
X	u.uhunger -= num;
X	newuhs(TRUE);
X}
X
X/* called after eating something (and after drinking fruit juice) */
Xlesshungry(num) register num; {
X	u.uhunger += num;
X	if(u.uhunger >= 2000) choke(FALSE);
X#ifdef DGKMOD
X	else {
X	    /* Have lesshungry() report when you're nearly full so all eating
X	     * warns when you're about to choke.
X	     */
X	    if (u.uhunger >= 1500) {
X		pline("You're having a hard time getting all of it down.");
X		multi -= 2;
X		nomovemsg = "You're finally finished.";
X	    }
X	}
X#endif /* DGKMOD /**/
X	newuhs(FALSE);
X}
X
Xunfaint(){
X	u.uhs = FAINTING;
X	flags.botl = 1;
X}
X
Xnewuhs(incr) boolean incr; {
X	register int newhs, h = u.uhunger;
X
X	newhs = (h > 1000) ? SATIATED :
X		(h > 150) ? NOT_HUNGRY :
X		(h > 50) ? HUNGRY :
X		(h > 0) ? WEAK : FAINTING;
X
X	if(newhs == FAINTING) {
X		if(u.uhs == FAINTED) newhs = FAINTED;
X		if(u.uhs <= WEAK || rn2(20-u.uhunger/10) >= 19) {
X			if(u.uhs != FAINTED && multi >= 0 /* %% */) {
X				pline("You faint from lack of food.");
X				nomul(-10+(u.uhunger/10));
X				nomovemsg = "You regain consciousness.";
X				afternmv = unfaint;
X				newhs = FAINTED;
X			}
X		} else
X		if(u.uhunger < -(int)(200 + 25*u.ulevel)) {
X			u.uhs = STARVED;
X			flags.botl = 1;
X			bot();
X			pline("You die from starvation.");
X			done("starved");
X		}
X	}
X
X	if(newhs != u.uhs) {
X		if(newhs >= WEAK && u.uhs < WEAK)
X			losestr(1);	/* this may kill you -- see below */
X		else
X		if(newhs < WEAK && u.uhs >= WEAK && u.ustr < u.ustrmax)
X			losestr(-1);
X		switch(newhs){
X		case HUNGRY:
X			if (Hallucination) {
X			    pline((!incr) ?
X				"You now have a lesser case of the munchies." :
X				"You are getting the munchies.");
X			} else
X			    pline((!incr) ? "You only feel hungry now." :
X				  (u.uhunger < 145) ? "You feel hungry." :
X				   "You are beginning to feel hungry.");
X			break;
X		case WEAK:
X			if (Hallucination)
X			    pline((!incr) ?
X				  "You still have the munchies." :
X				  "The munchies are starting to interfere with your motor capabilities.");
X			else
X			    pline((!incr) ? "You feel weak now." :
X				  (u.uhunger < 45) ? "You feel weak." :
X				   "You are beginning to feel weak.");
X			break;
X		}
X		u.uhs = newhs;
X		flags.botl = 1;
X		if(u.uhp < 1) {
X			pline("You die from hunger and exhaustion.");
X			killer = "exhaustion";
X			done("starved");
X		}
X	}
X}
X
X#define	CORPSE_I_TO_C(otyp)	(char) ((otyp >= DEAD_ACID_BLOB)\
X		     ?  'a' + (otyp - DEAD_ACID_BLOB)\
X		     :	'@' + (otyp - DEAD_HUMAN))
Xpoisonous(otmp)
Xregister struct obj *otmp;
X{
X#ifdef KAA
X	if(otmp->otyp == DEAD_DEMON) return(1);
X#endif
X	return(index(POISONOUS, CORPSE_I_TO_C(otmp->otyp)) != 0);
X}
X
X/* returns 1 if some text was printed */
Xeatcorpse(otmp) register struct obj *otmp; {
X#ifdef KAA
Xregister char let;
X#else
Xregister char let = CORPSE_I_TO_C(otmp->otyp);
X#endif
Xregister tp = 0;
X#ifdef KAA
X	if(otmp->otyp == DEAD_DEMON) let='&';
X	else if (otmp->otyp == DEAD_GIANT) let='9';
X	else let = CORPSE_I_TO_C(otmp->otyp);
X#endif
X	if(let != 'a' && moves > otmp->age + 50 + rn2(100)) {
X		tp++;
X		pline("Ulch -- that meat was tainted!");
X		pline("You get very sick.");
X		Sick = 10 + rn2(10);
X		u.usick_cause = objects[otmp->otyp].oc_name;
X	} else if(index(POISONOUS, let) && rn2(5)){
X		tp++;
X		pline("Ecch -- that must have been poisonous!");
X		if(!Poison_resistance){
X			losestr(rnd(4));
X			losehp(rnd(15), "poisonous corpse");
X		} else
X			pline("You don't seem affected by the poison.");
X	} else if(index("ELNOPQRUuxz", let) && rn2(5)){
X		tp++;
X		pline("You feel sick.");
X		losehp(rnd(8), "cadaver");
X	}
X	switch(let) {
X	case 'L':
X	case 'N':
X	case 't':
X#ifdef KAA
X	case 'Q':
X#endif
X		HTeleportation |= INTRINSIC;
X		break;
X	case 'W':
X		pluslvl();
X		break;
X	case 'n':
X		u.uhp = u.uhpmax;
X		flags.botl = 1;
X		/* fall into next case */
X	case '@':
X		pline("You cannibal! You will be sorry for this!");
X		/* not tp++; */
X		/* fall into next case */
X	case 'd':
X		Aggravate_monster |= INTRINSIC;
X		break;
X	case 'I':
X		if(!Invis) {
X			HInvis = 50+rn2(100);
X			if(!See_invisible)
X				newsym(u.ux, u.uy);
X		} else {
X			HInvis |= INTRINSIC;
X			HSee_invisible |= INTRINSIC;
X		}
X		/* fall into next case */
X	case 'y':
X#ifdef QUEST
X		u.uhorizon++;
X#endif
X		/* fall into next case */
X	case 'B':
X		HConfusion += 50;
X		break;
X	case 'D':
X		HFire_resistance |= INTRINSIC;
X		break;
X	case 'E':
X		HTelepat |= INTRINSIC;
X		break;
X	case 'F':
X	case 'Y':
X		HCold_resistance |= INTRINSIC;
X		break;
X#ifdef KAA
X	case '9':
X		gainstr(1);
X		break;
X#endif
X	case 'k':
X	case 's':
X		HPoison_resistance |= INTRINSIC;
X		break;
X	case 'c':
X		if (u.usym != 'c') {
X
X			pline("You turn to stone.");
X			killer = "dead cockatrice";
X			done("died");
X		}
X		break;
X	case 'a':
X	  if(Stoned) {
X	      pline("What a pity - you just destroyed a future piece of art!");
X	      tp++;
X	      Stoned = 0;
X	  }
X	  break;
X#ifdef KAA
X	case 'v':
X		pline ("Oh wow!  Great stuff!");
X		Hallucination += 200;
X		setsee();
X		break;
X#endif
X	case 'M':
X		if(u.usym == '@') {
X		    pline("You cannot resist the temptation to mimic a treasure chest.");
X		    tp++;
X		    nomul(-30);
X		    afternmv = Meatdone;
X		    nomovemsg = "You now again prefer mimicking a human.";
X		    u.usym = '$';
X		    prme();
X		}
X		break;
X	}
X	return(tp);
X}
X
X/* added by GAN 01/28/87 */
Xchoke(food)
Xregister struct objclass *food;
X{
X	/* only happens if you were satiated */
X	if(u.uhs != SATIATED) return;
X
X	if(food)	killer = food->oc_name;
X	else		killer = "exuberant appetite";
X	pline("You choke over your food.");
X	pline("You die...");
X	done("choked");
X}
END_OF_eat.c
if test 13123 -ne `wc -c <eat.c`; then
    echo shar: \"eat.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f lev.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"lev.c\"
else
echo shar: Extracting \"lev.c\" \(12696 characters\)
sed "s/^X//" >lev.c <<'END_OF_lev.c'
X/*	SCCS Id: @(#)lev.c	1.3	87/07/14
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* lev.c - version 1.0.3 */
X
X#include <stdio.h>
X#include "hack.h"
X#include "mkroom.h"
Xextern struct monst *restmonchn();
Xextern struct obj *restobjchn();
Xextern struct obj *billobjs;
Xextern char *itoa();
Xextern char SAVEF[];
Xextern int hackpid;
Xextern xchar dlevel;
Xextern char nul[];
X
X#ifndef NOWORM
X#include	"wseg.h"
Xextern struct wseg *wsegs[32], *wheads[32];
Xextern long wgrowtime[32];
X#endif
X
X#ifdef DGK
Xstruct finfo fileinfo[MAXLEVEL+1];
Xlong bytes_counted;
Xint count_only;
X#else
Xboolean level_exists[MAXLEVEL+1];
X#endif
X
X#ifdef DGK
Xsavelev(fd, lev, mode)
Xint fd, mode;
Xxchar lev;
X{
X	if (mode & COUNT) {
X		count_only = TRUE;
X		bytes_counted = 0;
X		savelev0(fd, lev);
X		while (bytes_counted > freediskspace(levels))
X			if (!swapout_oldest())
X				return FALSE;
X	}
X	if (mode & WRITE) {
X		count_only = FALSE;
X		bytes_counted = 0;
X		savelev0(fd, lev);
X	}
X	fileinfo[lev].where = ACTIVE;
X	fileinfo[lev].time = moves;
X	fileinfo[lev].size = bytes_counted;
X	return TRUE;
X}
X
Xsavelev0(fd,lev)
X#else
Xsavelev(fd,lev)
X#endif
Xint fd;
Xxchar lev;
X{
X#ifndef NOWORM
X	register struct wseg *wtmp, *wtmp2;
X	register tmp;
X#endif
X
X	if(fd < 0) panic("Save on bad file!");	/* impossible */
X#ifndef DGK
X	if(lev >= 0 && lev <= MAXLEVEL)
X		level_exists[lev] = TRUE;
X#endif
X	bwrite(fd,(char *) &hackpid,sizeof(hackpid));
X	bwrite(fd,(char *) &lev,sizeof(lev));
X	bwrite(fd,(char *) levl,sizeof(levl));
X#ifdef DGK
X	bwrite(fd, (char *) &symbol, sizeof(symbol));
X#endif
X	bwrite(fd,(char *) &moves,sizeof(long));
X	bwrite(fd,(char *) &xupstair,sizeof(xupstair));
X	bwrite(fd,(char *) &yupstair,sizeof(yupstair));
X	bwrite(fd,(char *) &xdnstair,sizeof(xdnstair));
X	bwrite(fd,(char *) &ydnstair,sizeof(ydnstair));
X	savemonchn(fd, fmon);
X	savegoldchn(fd, fgold);
X	savetrapchn(fd, ftrap);
X	saveobjchn(fd, fobj);
X	saveobjchn(fd, billobjs);
X	billobjs = 0;
X	save_engravings(fd);
X#ifndef QUEST
X	bwrite(fd,(char *) rooms,sizeof(rooms));
X	bwrite(fd,(char *) doors,sizeof(doors));
X#endif
X	fgold = 0;
X	ftrap = 0;
X	fmon = 0;
X	fobj = 0;
X#ifndef NOWORM
X	bwrite(fd,(char *) wsegs,sizeof(wsegs));
X	for(tmp=1; tmp<32; tmp++){
X		for(wtmp = wsegs[tmp]; wtmp; wtmp = wtmp2){
X			wtmp2 = wtmp->nseg;
X			bwrite(fd,(char *) wtmp,sizeof(struct wseg));
X		}
X#ifdef DGK
X		if (!count_only)
X#endif
X			wsegs[tmp] = 0;
X	}
X	bwrite(fd,(char *) wgrowtime,sizeof(wgrowtime));
X#endif /* NOWORM /**/
X#ifdef DGK
X	if (count_only)	return(0);
X#endif
X	billobjs = 0;
X	fgold = 0;
X	ftrap = 0;
X	fmon = 0;
X	fobj = 0;
X}
X
Xbwrite(fd,loc,num)
Xregister fd;
Xregister char *loc;
Xregister unsigned num;
X{
X#ifdef DGK
X	bytes_counted += num;
X	if (!count_only)
X#endif
X/* lint wants the 3rd arg of write to be an int; lint -p an unsigned */
X	    if(write(fd, loc, (int) num) != num)
X		panic("cannot write %u bytes to file #%d", num, fd);
X}
X
Xsaveobjchn(fd,otmp)
Xregister fd;
Xregister struct obj *otmp;
X{
X	register struct obj *otmp2;
X	unsigned xl;
X	int minusone = -1;
X
X	while(otmp) {
X		otmp2 = otmp->nobj;
X		xl = otmp->onamelth;
X		bwrite(fd, (char *) &xl, sizeof(int));
X		bwrite(fd, (char *) otmp, xl + sizeof(struct obj));
X#ifdef DGK
X		if (!count_only)
X#endif
X			free((char *) otmp);
X		otmp = otmp2;
X	}
X	bwrite(fd, (char *) &minusone, sizeof(int));
X}
X
X#ifdef MSDOS
X/* We don't want to save any pointers in any files, so convert
X * the pointers to indices before writing the monsters to disk -dgk
X */
Xsavemonchn(fd,mtmp)
Xregister fd;
Xregister struct monst *mtmp;
X{
X	register struct monst *mtmp2;
X	unsigned xl;
X	int minusone = -1;
X	struct permonst *permonstp;
X	int monsindex;
X	extern struct permonst li_dog, dog, la_dog;
X#ifdef KAA
X	extern struct permonst hell_hound;
X# ifdef HARD
X	extern struct permonst d_lord, d_prince;
X# endif
X#endif
X
X	while(mtmp) {
X		mtmp2 = mtmp->nmon;
X		xl = mtmp->mxlth + mtmp->mnamelth;
X		bwrite(fd, (char *) &xl, sizeof(int));
X		/* store an index where the pointer used to be */
X		permonstp = mtmp->data;
X		if (permonstp == &li_dog)
X			monsindex = -1;		/* fake index */
X		else if (permonstp == &dog)
X			monsindex = -2;		/* fake index */
X		else if (permonstp == &la_dog)
X			monsindex = -3;		/* fake index */
X#ifdef KAA
X		else if (permonstp == &hell_hound)
X			monsindex = -4;
X# ifdef HARD
X		else if (permonstp == &d_lord)
X			monsindex = -5;
X
X		else if (permonstp == &d_prince)
X			monsindex = -6;
X# endif
X#endif
X		else			
X			monsindex = permonstp - &mons[0];
X		*((int *)&mtmp->data) = monsindex;
X		bwrite(fd, (char *) mtmp, xl + sizeof(struct monst));
X		mtmp->data = permonstp;		/* restore the pointer */
X		if(mtmp->minvent) saveobjchn(fd,mtmp->minvent);
X#ifdef DGK
X		if (!count_only)
X#endif
X			free((char *) mtmp);
X		mtmp = mtmp2;
X	}
X	bwrite(fd, (char *) &minusone, sizeof(int));
X}
X#else
X
Xsavemonchn(fd,mtmp)
Xregister fd;
Xregister struct monst *mtmp;
X{
X	register struct monst *mtmp2;
X	unsigned xl;
X	int minusone = -1;
X	struct permonst *monbegin = &mons[0];
X
X	bwrite(fd, (char *) &monbegin, sizeof(monbegin));
X
X	while(mtmp) {
X		mtmp2 = mtmp->nmon;
X		xl = mtmp->mxlth + mtmp->mnamelth;
X		bwrite(fd, (char *) &xl, sizeof(int));
X		bwrite(fd, (char *) mtmp, xl + sizeof(struct monst));
X		if(mtmp->minvent) saveobjchn(fd,mtmp->minvent);
X		free((char *) mtmp);
X		mtmp = mtmp2;
X	}
X	bwrite(fd, (char *) &minusone, sizeof(int));
X}
X#endif
X
Xsavegoldchn(fd,gold)
Xregister fd;
Xregister struct gold *gold;
X{
X	register struct gold *gold2;
X	while(gold) {
X		gold2 = gold->ngold;
X		bwrite(fd, (char *) gold, sizeof(struct gold));
X#ifdef DGK
X		if (!count_only)
X#endif
X			free((char *) gold);
X		gold = gold2;
X	}
X	bwrite(fd, nul, sizeof(struct gold));
X}
X
Xsavetrapchn(fd,trap)
Xregister fd;
Xregister struct trap *trap;
X{
X	register struct trap *trap2;
X	while(trap) {
X		trap2 = trap->ntrap;
X		bwrite(fd, (char *) trap, sizeof(struct trap));
X#ifdef DGK
X		if (!count_only)
X#endif
X			free((char *) trap);
X		trap = trap2;
X	}
X	bwrite(fd, nul, sizeof(struct trap));
X}
X
Xgetlev(fd,pid,lev)
Xint fd,pid;
Xxchar lev;
X{
X	register struct gold *gold;
X	register struct trap *trap;
X#ifndef NOWORM
X	register struct wseg *wtmp;
X#endif
X	register tmp;
X	long omoves;
X	int hpid;
X	xchar dlvl;
X#ifdef DGK
X	struct symbols osymbol;
X	int x, y, up, dn, lt, rt;
X	uchar osym, nsym;
X#endif
X
X#ifdef MSDOS
X	setmode(fd,O_BINARY);
X#endif
X	/* First some sanity checks */
X	mread(fd, (char *) &hpid, sizeof(hpid));
X	mread(fd, (char *) &dlvl, sizeof(dlvl));
X	if((pid && pid != hpid) || (lev && dlvl != lev)) {
X		pline("Strange, this map is not as I remember it.");
X		pline("Somebody is trying some trickery here ...");
X		pline("This game is void ...");
X		done("tricked");
X	}
X
X	fgold = 0;
X	ftrap = 0;
X	mread(fd, (char *) levl, sizeof(levl));
X#ifdef DGK
X	/* Corners are poorly implemented.  They only exist in the
X	 * scrsym field of each dungeon element.  So we have to go
X	 * through the previous level, looking for scrsym with the
X	 * old corner values, checking to make sure that they are
X	 * where corners should be, then replace them with the scrsym
X	 * of the new GRAPHICS character set.  Ugly.
X	 */
X	mread(fd, (char *) &osymbol, sizeof(osymbol));
X	if (memcmp((char *) &osymbol, (char *) &symbol, sizeof (symbol))) {
X		for (x = 0; x < COLNO; x++)
X			for (y = 0; y < ROWNO; y++) {
X				osym = levl[x][y].scrsym;
X				nsym = 0;
X				switch (levl[x][y].typ) {
X				case 0:
X				case SCORR:
X					break;
X				case ROOM:
X					if (osym == osymbol.room)
X						nsym = symbol.room;
X					break;
X				case DOOR:
X					if (osym == osymbol.door)
X						nsym = symbol.door;
X					break;
X				case CORR:
X					if (osym == osymbol.corr)
X						nsym = symbol.corr;
X					break;
X				case VWALL:
X					if (osym == osymbol.vwall)
X						nsym = symbol.vwall;
X					break;
X				case SDOOR:
X					if (osym == osymbol.vwall)
X						nsym = symbol.vwall;
X					else if (osym == osymbol.hwall)
X						nsym = symbol.hwall;
X					break;
X				/* Now the ugly stuff */
X				case HWALL:
X				  up = (y > 0) ? levl[x][y-1].typ : 0;
X				  dn = (y < ROWNO-1) ?levl[x][y+1].typ : 0;
X				  lt = (x > 0) ? levl[x-1][y].typ : 0;
X				  rt = (x < COLNO-1) ?levl[x+1][y].typ : 0;
X				  up = up && (up == VWALL || up == DOOR
X					|| up == SDOOR);
X				  dn = dn && (dn == VWALL || dn == DOOR
X					|| dn == SDOOR);
X				  lt = lt && (lt == HWALL || lt == DOOR
X					|| lt == SDOOR);
X				  rt = rt && (rt == HWALL || rt == DOOR
X					|| rt == SDOOR);
X				  if (rt && dn && osym == osymbol.tlcorn)
X					nsym = symbol.tlcorn;
X				  else if (lt && dn && osym == osymbol.trcorn)
X					nsym = symbol.trcorn;
X				  else if (rt && up && osym == osymbol.blcorn)
X					nsym = symbol.blcorn;
X				  else if (lt && up && osym == osymbol.brcorn)
X					nsym = symbol.brcorn;
X				  else if (osym == osymbol.hwall)
X					nsym = symbol.hwall;
X				  break;
X				default:
X					break;
X				}
X				if (nsym)
X					levl[x][y].scrsym = nsym;
X			}
X	}
X#endif
X	mread(fd, (char *)&omoves, sizeof(omoves));
X	mread(fd, (char *)&xupstair, sizeof(xupstair));
X	mread(fd, (char *)&yupstair, sizeof(yupstair));
X	mread(fd, (char *)&xdnstair, sizeof(xdnstair));
X	mread(fd, (char *)&ydnstair, sizeof(ydnstair));
X
X	fmon = restmonchn(fd);
X
X	/* regenerate animals while on another level */
X	{ long tmoves = (moves > omoves) ? moves-omoves : 0;
X	  register struct monst *mtmp, *mtmp2;
X	  extern char genocided[];
X
X	  for(mtmp = fmon; mtmp; mtmp = mtmp2) {
X		long newhp;		/* tmoves may be very large */
X
X		mtmp2 = mtmp->nmon;
X		if(index(genocided, mtmp->data->mlet)) {
X			mondead(mtmp);
X			continue;
X		}
X
X		if(mtmp->mtame && tmoves > 250) {
X			mtmp->mtame = 0;
X			mtmp->mpeaceful = 0;
X		}
X
X		newhp = mtmp->mhp +
X			(index(MREGEN, mtmp->data->mlet) ? tmoves : tmoves/20);
X		if(newhp > mtmp->mhpmax)
X			mtmp->mhp = mtmp->mhpmax;
X		else
X			mtmp->mhp = newhp;
X	  }
X	}
X
X	setgd();
X	gold = newgold();
X	mread(fd, (char *)gold, sizeof(struct gold));
X	while(gold->gx) {
X		gold->ngold = fgold;
X		fgold = gold;
X		gold = newgold();
X		mread(fd, (char *)gold, sizeof(struct gold));
X	}
X	free((char *) gold);
X	trap = newtrap();
X	mread(fd, (char *)trap, sizeof(struct trap));
X	while(trap->tx) {
X		trap->ntrap = ftrap;
X		ftrap = trap;
X		trap = newtrap();
X		mread(fd, (char *)trap, sizeof(struct trap));
X	}
X	free((char *) trap);
X	fobj = restobjchn(fd);
X	billobjs = restobjchn(fd);
X	rest_engravings(fd);
X#ifndef QUEST
X	mread(fd, (char *)rooms, sizeof(rooms));
X	mread(fd, (char *)doors, sizeof(doors));
X#endif
X#ifndef NOWORM
X	mread(fd, (char *)wsegs, sizeof(wsegs));
X	for(tmp = 1; tmp < 32; tmp++) if(wsegs[tmp]){
X		wheads[tmp] = wsegs[tmp] = wtmp = newseg();
X		while(1) {
X			mread(fd, (char *)wtmp, sizeof(struct wseg));
X			if(!wtmp->nseg) break;
X			wheads[tmp]->nseg = wtmp = newseg();
X			wheads[tmp] = wtmp;
X		}
X	}
X	mread(fd, (char *)wgrowtime, sizeof(wgrowtime));
X#endif
X}
X
Xmread(fd, buf, len)
Xregister fd;
Xregister char *buf;
Xregister unsigned len;
X{
X	register int rlen;
X	extern boolean restoring;
X
X	rlen = read(fd, buf, (int) len);
X	if(rlen != len){
X		pline("Read %d instead of %u bytes.\n", rlen, len);
X		if(restoring) {
X			(void) unlink(SAVEF);
X			error("Error restoring old game.");
X		}
X		panic("Error reading level file.");
X	}
X}
X
Xmklev()
X{
X	extern boolean in_mklev;
X
X	if(getbones()) return;
X
X	in_mklev = TRUE;
X	makelevel();
X	in_mklev = FALSE;
X}
X
X#ifdef DGK
Xswapin_file(lev) {
X	char to[PATHLEN], from[PATHLEN];
X
X	sprintf(from, "%s%s", permbones, alllevels);
X	sprintf(to, "%s%s", levels, alllevels);
X	name_file(from, lev);
X	name_file(to, lev);
X	while (fileinfo[lev].size > freediskspace(to)) 
X		if (!swapout_oldest())
X			return FALSE;
X#ifdef WIZARD
X	if (wizard) {
X		pline("Swapping in `%s'", from);
X		fflush(stdout);
X	}
X#endif
X	copyfile(from, to);
X	(void) unlink(from);
X	fileinfo[lev].where = ACTIVE;
X	return TRUE;
X}
X
X
Xswapout_oldest() {
X	char to[PATHLEN], from[PATHLEN];
X	int i, oldest;
X	long oldtime;
X
X	if (!ramdisk)
X		return FALSE;
X	for (i = 1, oldtime = 0, oldest = 0; i <= maxdlevel; i++)
X		if (fileinfo[i].where == ACTIVE
X		&& (!oldtime || fileinfo[i].time < oldtime)) {
X			oldest = i;
X			oldtime = fileinfo[i].time;
X		}
X	if (!oldest)
X		return FALSE;
X	sprintf(from, "%s%s", levels, alllevels);
X	sprintf(to, "%s%s", permbones, alllevels);
X	name_file(from, oldest);
X	name_file(to, oldest);
X#ifdef WIZARD
X	if (wizard) {
X		pline("Swapping out `%s'.", from);
X		fflush(stdout);
X	}
X#endif
X	copyfile(from, to);
X	unlink(from);
X	fileinfo[oldest].where = SWAPPED;
X	return TRUE;
X}
X
Xcopyfile(from, to)
Xchar *from, *to;
X{
X	char buf[BUFSIZ];
X	int nfrom, nto, fdfrom, fdto;
X
X	if ((fdfrom = open(from, O_RDONLY | O_BINARY | O_CREAT, FMASK)) < 0)
X		panic("Can't copy from %s !?", from);
X	if ((fdto = open(to, O_WRONLY | O_BINARY | O_CREAT, FMASK)) < 0)
X		panic("Can't copy to %s", to);
X	do {
X		nfrom = read(fdfrom, buf, BUFSIZ);
X		nto = write(fdto, buf, nfrom);
X		if (nto != nfrom)
X			panic("Copyfile failed!");
X	} while (nfrom == BUFSIZ);
X	close(fdfrom);
X	close(fdto);
X}
X#endif
END_OF_lev.c
if test 12696 -ne `wc -c <lev.c`; then
    echo shar: \"lev.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f mhitu.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"mhitu.c\"
else
echo shar: Extracting \"mhitu.c\" \(12925 characters\)
sed "s/^X//" >mhitu.c <<'END_OF_mhitu.c'
X/*	SCCS Id: @(#)mhitu.c	1.3	87/07/14
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* mhitu.c - version 1.0.3 */
X
X#include	"hack.h"
Xextern struct monst *makemon();
X#ifdef KAA
Xextern char pl_character[];
X#endif
X
X/*
X * mhitu: monster hits you
X *	  returns 1 if monster dies (e.g. 'y', 'F'), 0 otherwise
X */
Xmhitu(mtmp)
Xregister struct monst *mtmp;
X{
X	register struct permonst *mdat = mtmp->data;
X	register int tmp, ctmp;
X
X	nomul(0);
X
X	/* If swallowed, can only be affected by hissers and by u.ustuck */
X	if(u.uswallow) {
X		if(mtmp != u.ustuck) {
X			if(mdat->mlet == 'c' && !rn2(13)) {
X				pline("Outside, you hear %s's hissing!",
X					monnam(mtmp));
X				pline("%s gets turned to stone!",
X					Monnam(u.ustuck));
X				pline("And the same fate befalls you.");
X				done_in_by(mtmp);
X				/* "notreached": not return(1); */
X			}
X			return(0);
X		}
X		switch(mdat->mlet) {	/* now mtmp == u.ustuck */
X		case ',':
X			youswld(mtmp, (u.uac > 0) ? u.uac+4 : 4,
X				5, Monnam(mtmp));
X			break;
X		case '\'':
X			youswld(mtmp,rnd(6),7,Monnam(mtmp));
X			break;
X		case 'P':
X			youswld(mtmp,d(2,4),12,Monnam(mtmp));
X			break;
X		default:
X			/* This is not impossible! */
X#ifdef DGKMOD
X			/* If the swallowing monster changes into a monster
X			 * that is not capable of swallowing you, you get
X			 * regurgitated - dgk
X			 */
X			pline("You get regurgitated!");
X			u.ux = mtmp->mx;
X			u.uy = mtmp->my;
X			u.uswallow = 0;
X			u.ustuck = 0;
X			mnexto(mtmp);
X			setsee();
X			docrt();
X			break;
X#else
X			pline("The mysterious monster totally digests you.");
X			u.uhp = 0;
X#endif /* DGKMOD /**/
X		}
X		if(u.uhp < 1) done_in_by(mtmp);
X		return(0);
X	}
X
X	if(mdat->mlet == 'c' && Stoned)
X		return(0);
X
X	/* make eels visible the moment they hit/miss us */
X	if(mdat->mlet == ';' && mtmp->minvis && cansee(mtmp->mx,mtmp->my)){
X		mtmp->minvis = 0;
X		pmon(mtmp);
X	}
X	if(!index("1&DuxynNF",mdat->mlet))
X		tmp = hitu(mtmp,d(mdat->damn,mdat->damd));
X	else
X		tmp = 0;
X	if(index(UNDEAD, mdat->mlet) && midnight())
X		tmp += hitu(mtmp,d(mdat->damn,mdat->damd));
X
X	ctmp = tmp && !mtmp->mcan &&
X	  (!uarm || objects[uarm->otyp].a_can < rnd(3) || !rn2(50));
X	switch(mdat->mlet) {
X	case '1':
X		if(wiz_hit(mtmp)) return(1);	/* he disappeared */
X		break;
X	case '&':
X		demon_hit(mtmp);
X		break;
X	case ',':
X		if(tmp) justswld(mtmp,Monnam(mtmp));
X		break;
X	case '\'':
X		if (tmp) justswld(mtmp,Monnam(mtmp));
X		break;
X	case ';':
X		if(ctmp) {
X			if(!u.ustuck && !rn2(10)) {
X				pline("%s swings itself around you!",
X					Monnam(mtmp));
X				u.ustuck = mtmp;
X			} else if(u.ustuck == mtmp &&
X			    levl[mtmp->mx][mtmp->my].typ == POOL) {
X				pline("%s drowns you ...", Monnam(mtmp));
X				done("drowned");
X			}
X		}
X		break;
X	case 'A':
X		if(ctmp && rn2(2)) {
X		    if(Poison_resistance)
X			pline("The sting doesn't seem to affect you.");
X		    else {
X			pline("You feel weaker!");
X			losestr(1);
X		    }
X		}
X		break;
X	case 'C':
X		(void) hitu(mtmp,rnd(6));
X		break;
X	case 'c':
X		if(!rn2(5)) {
X		    if (mtmp->mcan)
X			pline("You hear a cough from %s!", monnam(mtmp));
X		    else {
X			pline("You hear %s's hissing!", monnam(mtmp));
X			if(!rn2(20) || (flags.moonphase == NEW_MOON
X			    && !carrying(DEAD_LIZARD) && u.usym != 'c')) {
X				Stoned = 5;
X				/* pline("You get turned to stone!"); */
X				/* done_in_by(mtmp); */
X			}
X		    }
X		}
X		break;
X	case 'D':
X		if(rn2(6) || mtmp->mcan) {
X			(void) hitu(mtmp,d(3,10));
X			(void) hitu(mtmp,rnd(8));
X			(void) hitu(mtmp,rnd(8));
X			break;
X		}
X		kludge("%s breathes fire!",Monnam(mtmp));
X		buzz(-1,mtmp->mx,mtmp->my,u.ux-mtmp->mx,u.uy-mtmp->my);
X		break;
X	case 'd':
X		(void) hitu(mtmp,d(2, (flags.moonphase == FULL_MOON) ? 3 : 4));
X		break;
X	case 'e':
X		(void) hitu(mtmp,d(3,6));
X		break;
X	case 'F':
X		if(mtmp->mcan) break;
X		kludge("%s explodes!", Monnam(mtmp));
X		if(Cold_resistance) pline("You don't seem affected by it.");
X		else {
X			xchar dn;
X			if(17-(u.ulevel/2) > rnd(20)) {
X				pline("You get blasted!");
X				dn = 6;
X			} else {
X				pline("You duck the blast...");
X				dn = 3;
X			}
X			losehp_m(d(dn,6), mtmp);
X		}
X		mondead(mtmp);
X		return(1);
X	case 'g':
X		if(ctmp && multi >= 0 && !rn2(3)) {
X		/* fix so we don't know what hit us when blind  KAA */
X		    if (Blind)
X			pline("You are frozen by its juices!");
X		    else
X			pline("You are frozen by %s's juices!",monnam(mtmp));
X		    nomul(-rnd(10));
X		}
X		break;
X	case 'h':
X		if(ctmp && multi >= 0 && !rn2(5)) {
X		    nomul(-rnd(10));
X		    if (Blind)
X			pline("You are put to sleep by its bite!");
X		    else
X			pline("You are put to sleep by %s's bite!",monnam(mtmp));
X		}
X		break;
X	case 'j':
X		tmp = hitu(mtmp,rnd(3));
X		tmp &= hitu(mtmp,rnd(3));
X		if(tmp){
X			(void) hitu(mtmp,rnd(4));
X			(void) hitu(mtmp,rnd(4));
X		}
X		break;
X	case 'k':
X		if((hitu(mtmp,rnd(4)) || !rn2(3)) && ctmp){
X			poisoned("bee's sting",mdat->mname);
X		}
X		break;
X	case 'L':
X#ifdef KAA
X		if (u.usym=='L') break;
X#endif
X		if(!mtmp->mcan && tmp) stealgold(mtmp);
X		break;
X	case 'N':
X#ifdef KAA
X		if (u.usym=='N') {
X			if (mtmp->minvent)
X	pline("%s brags about the goods some dungeon explorer provided.",
X	Monnam(mtmp));
X			else
X	pline("%s makes some remarks about how difficult theft is lately.",
X	Monnam(mtmp));
X			rloc(mtmp);
X		} else
X#endif
X		if(mtmp->mcan && !Blind) {
X		pline("%s tries to seduce you, but you seem not interested.",
X			Amonnam(mtmp, "plain"));
X			if(rn2(3)) rloc(mtmp);
X		} else if(steal(mtmp)) {
X			rloc(mtmp);
X			mtmp->mflee = 1;
X		}
X		break;
X	case 'n':
X		if(!uwep
X#ifdef KAA
X		   && u.usym == '@'
X#endif
X		   && !uarm && !uarmh && !uarms && !uarmg) {
X		    pline("%s hits! (I hope you don't mind)",
X			Monnam(mtmp));
X			u.uhp += rnd(7);
X			if(!rn2(7)) u.uhpmax++;
X			if(u.uhp > u.uhpmax) u.uhp = u.uhpmax;
X			flags.botl = 1;
X			if(!rn2(50)) rloc(mtmp);
X		} else {
X#ifdef KAA
X			if (pl_character[0] == 'P' && u.usym == '@') {
X			    if (!(moves % 5))
X				pline("Doc, I can't help you unless you cooperate.");
X			} else {
X#endif
X				(void) hitu(mtmp,d(2,6));
X				(void) hitu(mtmp,d(2,6));
X#ifdef KAA
X			}
X#endif
X		}
X		break;
X	case 'o':
X		tmp = hitu(mtmp,rnd(6));
X		if(hitu(mtmp,rnd(6)) && tmp &&	/* hits with both paws */
X		    !u.ustuck && rn2(2)) {
X			u.ustuck = mtmp;
X			kludge("%s has grabbed you!", Monnam(mtmp));
X			losehp_m(d(2,8), mtmp);
X		} else if(u.ustuck == mtmp) {
X			losehp_m(d(2,8), mtmp);
X			pline("You are being crushed.");
X		}
X		break;
X	case 'P':
X		if(ctmp && !rn2(4))
X			justswld(mtmp,Monnam(mtmp));
X		else
X			(void) hitu(mtmp,d(2,4));
X		break;
X	case 'Q':
X#ifdef KAA
X		if(ctmp) {
X			pline("Your position suddenly seems very uncertain!");
X			tele();
X		}
X#else
X		(void) hitu(mtmp,rnd(2));
X		(void) hitu(mtmp,rnd(2));
X#endif
X		break;
X	case 'R':
X		if(ctmp && uarmh && !uarmh->rustfree &&
X		   (int) uarmh->spe >= -1) {
X			pline("Your helmet rusts!");
X			uarmh->spe--;
X		} else
X		if(ctmp && uarm && !uarm->rustfree &&	/* Mike Newton */
X		 uarm->otyp < STUDDED_LEATHER_ARMOR &&
X		 (int) uarm->spe >= -1) {
X			pline("Your armor rusts!");
X			uarm->spe--;
X		}
X		break;
X	case 'S':
X		if(ctmp && !rn2(8)) {
X			poisoned("snake's bite",mdat->mname);
X		}
X		break;
X	case 's':
X		if(ctmp && !rn2(8)) {
X			poisoned("scorpion's sting",mdat->mname);
X		}
X		(void) hitu(mtmp,rnd(8));
X		(void) hitu(mtmp,rnd(8));
X		break;
X	case 'T':
X		(void) hitu(mtmp,rnd(6));
X		(void) hitu(mtmp,rnd(6));
X		break;
X	case 't':
X		if(!rn2(5)) rloc(mtmp);
X		break;
X	case 'u':
X		mtmp->mflee = 1;
X		break;
X	case 'U':
X		(void) hitu(mtmp,d(3,4));
X		(void) hitu(mtmp,d(3,4));
X		break;
X	case 'v':
X		if(ctmp && !u.ustuck) u.ustuck = mtmp;
X		break;
X	case 'V':
X		if(tmp)  losehp_m(4, mtmp);
X		if(ctmp) losexp();
X		break;
X	case 'W':
X		if(ctmp) losexp();
X		break;
X#ifndef NOWORM
X	case 'w':
X		if(tmp) wormhit(mtmp);
X#endif
X		break;
X	case 'X':
X		(void) hitu(mtmp,rnd(5));
X		(void) hitu(mtmp,rnd(5));
X		(void) hitu(mtmp,rnd(5));
X		break;
X	case 'x':
X		{ register long side = rn2(2) ? RIGHT_SIDE : LEFT_SIDE;
X#ifdef KAA
X		  if (mtmp->mcan)
X		    pline("%s nuzzles against your %s leg!",
X			  Monnam(mtmp), (side==RIGHT_SIDE)?"right":"left");
X		  else {
X#endif
X		    pline("%s pricks your %s leg!",
X			  Monnam(mtmp), (side==RIGHT_SIDE)?"right":"left");
X		    set_wounded_legs(side, rnd(50));
X		    losehp_m(2, mtmp);
X#ifdef KAA
X		  }
X#endif
X		  break;
X		}
X	case 'y':
X		if(mtmp->mcan) break;
X		mondead(mtmp);
X		if(!Blind && (u.usym != 'y')) {
X			pline("You are blinded by a blast of light!");
X			Blind = d(4,12);
X			seeoff(0);
X		}
X		return(1);
X	case 'Y':
X		(void) hitu(mtmp,rnd(6));
X		break;
X	}
X	if(u.uhp < 1) done_in_by(mtmp);
X	return(0);
X}
X
Xhitu(mtmp,dam)
Xregister struct monst *mtmp;
Xregister dam;
X{
X	register tmp, res;
X
X	nomul(0);
X	if (mtmp->mfroz || mtmp->mhp <= 0) return(0);
X	/* If you are a 'a' or 'E' the monster might not get a second hit */
X	if(u.uswallow) return(0);
X
X	if(mtmp->mhide && mtmp->mundetected) {
X		mtmp->mundetected = 0;
X		if(!Blind) {
X			register struct obj *obj;
X			extern char * Xmonnam();
X			if(obj = o_at(mtmp->mx,mtmp->my))
X				pline("%s was hidden under %s!",
X					Xmonnam(mtmp), doname(obj));
X		}
X	}
X
X	tmp = u.uac;
X	/* give people with Ac = -10 at least some vulnerability */
X	if(tmp < 0) {
X		dam += tmp;		/* decrease damage */
X		if(dam <= 0) dam = 1;
X		tmp = -rn2(-tmp);
X	}
X	tmp += mtmp->data->mlevel;
X	if(multi < 0) tmp += 4;
X	if((Invis && mtmp->data->mlet != 'I') || !mtmp->mcansee) tmp -= 2;
X	if(mtmp->mtrapped) tmp -= 2;
X	if(tmp <= rnd(20)) {
X		if(Blind) pline("It misses.");
X		else pline("%s misses.",Monnam(mtmp));
X		res = 0;
X	} else {
X		if(Blind) pline("It hits!");
X		else pline("%s hits!",Monnam(mtmp));
X		if (u.usym == 'a' && !rn2(4)) {
X			pline("%s is splashed by your acid!",Monnam(mtmp));
X			mtmp->mhp -= rnd(10);
X			if(mtmp->mhp <= 0) {
X				pline("%s dies!",Monnam(mtmp));
X				xkilled(mtmp,0);
X			}
X		}
X		losehp_m(dam, mtmp);
X		res = 1;
X	}
X	stop_occupation();
X	if(u.usym=='E' && mtmp->mcansee && rn2(2)) {
X		pline("%s is frozen by your gaze!",Monnam(mtmp));
X		mtmp->mfroz = 1;
X	}
X	return(res);
X}
X
X#define	Athome	(Inhell && !mtmp->cham)
X
X#ifdef HARD
Xdemon_talk(mtmp)		/* returns 1 if we pay him off. */
Xregister struct monst *mtmp;
X{
X	char	*xmonnam(), *Xmonnam();
X	int	demand, offer;
X
X	if(!strcmp(mtmp->data->mname, "demon")) {  /* not for regular '&'s */
X
X	    pline("%s mutters something about awful working conditions.",
X		  Xmonnam(mtmp));
X	    return(0);
X	}
X
X	if(u.usym == '&') {	/* Won't blackmail their own. */
X
X	    pline("%s says, 'Good hunting %s.' and vanishes",
X		  Xmonnam(mtmp), flags.female ? "Sister" : "Brother");
X	    mondead(mtmp);
X	    return(1);
X	}
X
X	demand = (u.ugold * (rnd(80) + 20 * Athome)) / 100;
X	if(!demand)  {		/* you have no gold */
X	    mtmp->mpeaceful = 0;
X	    return(0);
X	} else {
X	    char buf[80];
X
X	    pline("%s demands %d Zorkmids for safe passage.",
X		  Xmonnam(mtmp), demand);
X	    pline("how many will you offer him?");
X	    getlin(buf);
X	    sscanf(buf, "%d", &offer);
X
X	    if(offer >= u.ugold) {
X		pline("You give %s all your gold.", xmonnam(mtmp));
X		offer = u.ugold;
X	    } else pline("You give %s %d Zorkmids.", xmonnam(mtmp), offer);
X	    u.ugold -= offer;
X
X	    if(offer >= demand) {
X		pline("%s vanishes laughing about cowardly mortals.",
X		      Xmonnam(mtmp));
X	    } else {
X		if(rnd(40) > (demand - offer)) {
X		    pline("%s scowls at you menacingly, then vanishes.",
X			  Xmonnam(mtmp));
X		} else {
X		    pline("%s gets angry...", Xmonnam(mtmp));
X		    mtmp->mpeaceful = 0;
X		    return(0);
X		}
X	    }
X	}
X	mondead(mtmp);
X	return(1);
X}
X#endif
X
Xdemon_hit(mtmp)
Xregister struct monst *mtmp;
X{
X	register struct	obj	*otmp;
X	int	onum, nobj = 0,
X		ml = mtmp->data->mlevel;
X
X	if(!mtmp->cham && !mtmp->mcan && !rn2(13)) {
X		(void) makemon(PM_DEMON,u.ux,u.uy);
X	} else {
X	    switch((!mtmp->mcan) ? rn2(ml - 5 - !Athome) : 0)   {
X#ifdef HARD
X		case 12:
X		case 11:
X		case 10:
X		case 9:			/* the wiz */
X			(void) hitu(mtmp, 1);
X			pline("Oh no, he's using the touch of death!");
X			if (rn2(ml) > 12)  {
X
X			    if(Confusion)
X				pline("You have an out of body experience.");
X			    else  {
X				killer = "touch of death";
X				done("died");
X			    }
X			} else pline("Lucky for you, it didn't work!");
X			break;
X		case 8:			/* demon princes */
X			(void) hitu(mtmp, 1);
X			if(!destroy_arm()) pline("Your skin itches.");
X			break;
X		case 7:
X			(void) hitu(mtmp, 1);
X			for (otmp = invent; otmp; otmp = otmp->nobj)  nobj++;
X			onum = rn2(nobj);
X			for(otmp = invent; onum != 0; onum--) otmp = otmp->nobj;
X			otmp->cursed++;
X			break;
X		case 6:			/* demon lords */
X			(void) hitu(mtmp, 1);
X			pline("You suddenly feel weaker!");
X			losestr(rnd(ml - 6));
X			break;
X		case 5:
X			(void) hitu(mtmp, 1);
X			if (Confusion)	pline("Hey, that tickles!");
X			else		pline("Huh, What? Where am I?");
X			HConfusion += rn1(7, 16);
X			break;
X#endif /* HARD /**/
X		default:		/* demons and chamelons as demons */
X			(void) hitu(mtmp,d(2,5 + Athome));
X			(void) hitu(mtmp,d(2,5 + Athome));
X			(void) hitu(mtmp,rnd(2 + Athome));
X			(void) hitu(mtmp,rnd(2 + Athome));
X			(void) hitu(mtmp,rn1(4,1 + Athome));
X			break;
X	    }
X	}
X	return(0);
X} 
END_OF_mhitu.c
if test 12925 -ne `wc -c <mhitu.c`; then
    echo shar: \"mhitu.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f u_init.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"u_init.c\"
else
echo shar: Extracting \"u_init.c\" \(11925 characters\)
sed "s/^X//" >u_init.c <<'END_OF_u_init.c'
X/*	SCCS Id: @(#)u_init.c	1.3	87/07/14
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* u_init.c - version 1.0.3   */
X
X#include <stdio.h>
X#include <signal.h>
X#include "hack.h"
X#define Strcpy	(void) strcpy
X#define	Strcat	(void) strcat
X#define	UNDEF_TYP	0
X#define	UNDEF_SPE	'\177'
Xextern struct obj *addinv();
Xextern char *eos();
Xextern char plname[];
X
Xstruct you zerou;
Xchar pl_character[PL_CSIZ];
Xchar *(roles[]) = {	/* must all have distinct first letter */
X			/* roles[4] & [7] may be changed for females */
X	"Archeologist", "Tourist", "Fighter", "Knight", "Cave-man",
X#ifdef NEWCLASS
X	"Samurai", "Ninja", "Priest",
X#endif
X#ifdef KAA
X	"Valkyrie", "Elf", "Healer",
X#endif
X	"Wizard"
X};
X#define	NR_OF_ROLES	SIZE(roles)
Xchar rolesyms[NR_OF_ROLES + 1];		/* filled by u_init() */
X
Xstruct trobj {
X	uchar trotyp;
X	schar trspe;
X	char trolet;
X	Bitfield(trquan,6);
X	Bitfield(trknown,1);
X};
X
X#ifdef WIZARD
Xstruct trobj Extra_objs[] = {
X	{ 0, 0, 0, 0, 0 },
X	{ 0, 0, 0, 0, 0 }
X};
X#endif
X
Xstruct trobj Cave_man[] = {
X#ifdef KAA
X	{ CLUB, 1, WEAPON_SYM, 1, 1 },
X#else
X	{ MACE, 1, WEAPON_SYM, 1, 1 },
X#endif
X	{ BOW, 1, WEAPON_SYM, 1, 1 },
X	{ ARROW, 0, WEAPON_SYM, 25, 1 },	/* quan is variable */
X	{ LEATHER_ARMOR, 0, ARMOR_SYM, 1, 1 },
X	{ 0, 0, 0, 0, 0}
X};
X
Xstruct trobj Fighter[] = {
X	{ TWO_HANDED_SWORD, 0, WEAPON_SYM, 1, 1 },
X	{ RING_MAIL, 0, ARMOR_SYM, 1, 1 },
X	{ 0, 0, 0, 0, 0 }
X};
X
Xstruct trobj Knight[] = {
X	{ LONG_SWORD, 0, WEAPON_SYM, 1, 1 },
X	{ SPEAR, 2, WEAPON_SYM, 1, 1 },
X	{ RING_MAIL, 1, ARMOR_SYM, 1, 1 },
X	{ HELMET, 0, ARMOR_SYM, 1, 1 },
X	{ SHIELD, 0, ARMOR_SYM, 1, 1 },
X	{ PAIR_OF_GLOVES, 0, ARMOR_SYM, 1, 1 },
X	{ 0, 0, 0, 0, 0 }
X};
X
X#ifdef KAA
Xstruct trobj Elf[] = {
X	{ SHORT_SWORD, 0, WEAPON_SYM, 1, 1 },
X	{ BOW, 0, WEAPON_SYM, 1, 1 },
X	{ ARROW, 0, WEAPON_SYM, 25, 1 },
X	{ UNDEF_TYP, 0, ARMOR_SYM, 1, 1 },
X	{ 0, 0, 0, 0, 0 }
X};
X
Xstruct trobj Valkyrie[] = {
X	{ LONG_SWORD, 1, WEAPON_SYM, 1, 1 },
X	{ SHIELD, 3, ARMOR_SYM, 1, 1 },
X	{ FOOD_RATION, 0, FOOD_SYM, 1, 1 },
X	{ 0, 0, 0, 0, 0 }
X};
X
Xstruct trobj Healer[] = {
X	{ STETHOSCOPE, 0, TOOL_SYM, 1, 0 },
X	{ POT_HEALING, 0, POTION_SYM, 4, 0 },
X	{ POT_EXTRA_HEALING, 0, POTION_SYM, 4, 0 },
X	{ APPLE, 0, FOOD_SYM, 5, 0 },
X	{ 0, 0, 0, 0, 0}
X};
X#endif /* KAA /**/
X
Xstruct trobj Archeologist[] = {
X	{ STUDDED_LEATHER_ARMOR, 0, ARMOR_SYM, 1, 1 },
X	{ UNDEF_TYP, 0, POTION_SYM, 2, 0 },
X	{ FOOD_RATION, 0, FOOD_SYM, 3, 1 },
X	{ PICK_AXE, UNDEF_SPE, TOOL_SYM, 1, 0 },
X	{ ICE_BOX, 0, TOOL_SYM, 1, 0 },
X	{ 0, 0, 0, 0, 0}
X};
X
Xstruct trobj Tinopener[] = {
X	{ CAN_OPENER, 0, TOOL_SYM, 1, 1 },
X	{ 0, 0, 0, 0, 0 }
X};
X
X#ifdef MARKER
Xstruct trobj Magicmarker[] = {
X	{ MAGIC_MARKER, 50, TOOL_SYM, 1, 0 },
X	{ 0, 0, 0, 0, 0 }
X};
X#endif
X
X#ifdef WALKIES
Xstruct trobj Leash[] = {
X	{ LEASH, 0, CHAIN_SYM, 1, 0 },
X	{ 0, 0, 0, 0, 0 }
X};
X#endif
X
Xstruct trobj Tourist[] = {
X	{ UNDEF_TYP, 0, FOOD_SYM, 10, 1 },
X	{ POT_EXTRA_HEALING, 0, POTION_SYM, 2, 0 },
X	{ EXPENSIVE_CAMERA, 0, TOOL_SYM, 1, 1 },
X	{ DART, 2, WEAPON_SYM, 25, 1 },	/* quan is variable */
X	{ 0, 0, 0, 0, 0 }
X};
X
Xstruct trobj Wizard[] = {
X	{ ELVEN_CLOAK, 0, ARMOR_SYM, 1, 1 },
X	{ UNDEF_TYP, UNDEF_SPE, WAND_SYM, 2, 0 },
X	{ UNDEF_TYP, UNDEF_SPE, RING_SYM, 2, 0 },
X	{ UNDEF_TYP, UNDEF_SPE, POTION_SYM, 2, 0 },
X	{ UNDEF_TYP, UNDEF_SPE, SCROLL_SYM, 3, 0 },
X#ifdef SPELLS
X	{ UNDEF_TYP, UNDEF_SPE, SPBOOK_SYM, 1, 0 },
X#endif
X	{ 0, 0, 0, 0, 0 }
X};
X
X#ifdef NEWCLASS
Xstruct	trobj	Samurai[] = {
X	{ KATANA, 0, WEAPON_SYM, 1, 1 },
X	{ BOW,    1, WEAPON_SYM, 1, 1 },
X	{ ARROW,  0, WEAPON_SYM, 25, 1 },	/* quan is variable */
X	{ SPLINT_MAIL, 0, ARMOR_SYM, 1, 1},
X	{ 0, 0, 0, 0, 0 }
X};
X
Xstruct	trobj	Ninja[] = {
X	{ KATANA, 0, WEAPON_SYM, 1, 1 },
X	{ SHURIKEN, 0, WEAPON_SYM, 25, 1 },	/* quan is variable */
X	{ LEATHER_ARMOR, 1, ARMOR_SYM, 1, 1},
X	{ 0, 0, 0, 0, 0 }
X};
X
Xstruct	trobj	Priest[] = {
X	{ CHAIN_MAIL, 0, ARMOR_SYM, 1, 1 },
X	{ SHIELD, 0, ARMOR_SYM, 1, 1 },
X	{ MACE, 1, WEAPON_SYM, 1, 1 },
X#ifdef SPELLS
X	{ UNDEF_TYP, UNDEF_SPE, SPBOOK_SYM, 2, 0 },
X#endif
X	{ 0, 0, 0, 0, 0 }
X};
X#endif /* NEWCLASS /**/
X
Xu_init(){
Xregister int i;
Xchar exper = 'y', pc;
Xextern char readchar();
X	if(flags.female)  {	/* should have been set in HACKOPTIONS */
X		roles[4] = "Cave-woman";
X#ifdef NEWCLASS
X		roles[7] = "Priestess";
X#endif
X	}
X	for(i = 0; i < NR_OF_ROLES; i++)
X		rolesyms[i] = roles[i][0];
X	rolesyms[i] = 0;
X
X	if(pc = pl_character[0]) {
X		if('a' <= pc && pc <= 'z') pc += 'A'-'a';
X		if((i = role_index(pc)) >= 0)
X			goto got_suffix;	/* implies experienced */
X		printf("\nUnknown role: %c\n", pc);
X		pl_character[0] = pc = 0;
X	}
X
X	printf("\nShall I pick a character for you (yes, no, or quit) ? [ynq] ");
X
X	while(!index("yYnNqQ", (exper = readchar())))	bell();
X
X	printf("%c\n", exper);		/* echo */
X
X	if (index("qQ", exper)) exit(0);
X
X	if(index("Yy", exper)) {
X		exper = 0;
X		goto beginner;
X	}
X
X	printf("\n Tell me what kind of character you are:\n");
X	printf(" Are you");
X	for(i = 0; i < NR_OF_ROLES; i++) {
X		printf(" %s %s", index("AEIOU",roles[i][0]) ? "an" : "a", roles[i]);
X		if((((i + 1) % 4) == 0) && (i != NR_OF_ROLES -1)) printf(",\n\t");
X		else if(i < NR_OF_ROLES - 2)	printf(",");
X		if(i == NR_OF_ROLES - 2)	printf(" or");
X	}
X	printf("? [%s or q(quit)] ", rolesyms);
X
X	while(pc = readchar()) {
X		if (pc == 'q' || pc == 'Q') exit(0);
X		if('a' <= pc && pc <= 'z') pc += 'A'-'a';
X		if((i = role_index(pc)) >= 0) {
X			printf("%c\n", pc);	/* echo */
X			(void) fflush(stdout);	/* should be seen */
X			break;
X		}
X		if(pc == '\n') break;
X		bell();
X	}
X	if(pc == '\n')	pc = 0;
X
Xbeginner:
X	if(!pc) {
X		i = rn2(NR_OF_ROLES);
X		pc = rolesyms[i];
X		printf("\nThis game you will be %s %s%s.\n",
X			(exper || index("AEIOU", roles[i][0])) ? "an" : "a",
X			exper ? "experienced " : "", roles[i]);
X		getret();
X		/* give him some feedback in case mklev takes much time */
X		(void) putchar('\n');
X		(void) fflush(stdout);
X	}
X	if(exper) {
X		roles[i][0] = pc;
X	}
X
Xgot_suffix:
X
X	(void) strncpy(pl_character, roles[i], PL_CSIZ-1);
X	pl_character[PL_CSIZ-1] = 0;
X	flags.beginner = 1;
X	u = zerou;
X	u.usym = '@';
X	u.ulevel = 1;
X#ifdef SPELLS
X	u.uen = u.uenmax = 1;
X#endif
X#ifdef PRAYERS
X	u.ublesscnt = 300;			/* no prayers just yet */
X	u.ublessed = 0;				/* not worthy yet */
X	u.ugangr   = 0;				/* gods not angry */
X#endif
X#ifdef KAA
X	u.mh = u.mhmax = u.umonnum = u.mtimedone = 0;
X#endif
X	init_uhunger();
X#ifdef QUEST
X	u.uhorizon = 6;
X#endif
X	uarm = uarm2 = uarmh = uarms = uarmg = uwep = uball = uchain =
X	uleft = uright = 0;
X#ifdef SPELLS
X	for (i = 0; i <= MAXSPELL; i++) spl_book[i].sp_id = NO_SPELL;
X#endif
X	switch(pc) {
X	case 'c':
X	case 'C':
X		Cave_man[2].trquan = 12 + rnd(9)*rnd(9);
X		u.uhp = u.uhpmax = 16;
X		u.ustr = u.ustrmax = 18;
X		ini_inv(Cave_man);
X		break;
X	case 't':
X	case 'T':
X#ifdef KAA
X		objects[POT_EXTRA_HEALING].oc_name_known=1;
X#endif
X		Tourist[3].trquan = 20 + rnd(20);
X		u.ugold = u.ugold0 = rnd(1000);
X		u.uhp = u.uhpmax = 10;
X		u.ustr = u.ustrmax = 8;
X		ini_inv(Tourist);
X		if(!rn2(25)) ini_inv(Tinopener);
X#ifdef MARKER
X		else if(!rn2(25)) ini_inv(Magicmarker);
X#endif
X#ifdef WALKIES
X		else if(!rn2(25)) ini_inv(Leash);
X#endif
X		break;
X	case 'w':
X	case 'W':
X		for(i=1; i<=4; i++) if(!rn2(5))
X			Wizard[i].trquan += rn2(3) - 1;
X		u.uhp = u.uhpmax = 15;
X		u.ustr = u.ustrmax = 16;
X#ifdef SPELLS
X		u.uen = u.uenmax += rn2(4);
X#endif
X		ini_inv(Wizard);
X#ifdef MARKER
X		if(!rn2(5)) ini_inv(Magicmarker);
X#endif
X		break;
X	case 'a':
X	case 'A':
X		Fast = INTRINSIC;
X		Stealth = INTRINSIC;
X		u.uhp = u.uhpmax = 12;
X		u.ustr = u.ustrmax = 10;
X		ini_inv(Archeologist);
X		if(!rn2(10)) ini_inv(Tinopener);
X#ifdef MARKER
X		else if(!rn2(10)) ini_inv(Magicmarker);
X#endif
X		break;
X#ifdef KAA
X	case 'e':
X	case 'E':
X		Elf[2].trquan = 15+rnd(20);
X		Elf[3].trotyp = (rn2(2) ? ELFIN_CHAIN_MAIL : ELVEN_CLOAK);
X		Fast = INTRINSIC;
X		HSee_invisible = INTRINSIC;
X		u.uhp = u.uhpmax = 16;
X		u.ustr = u.ustrmax = 16;
X		ini_inv(Elf);
X		break;
X	case 'v':
X	case 'V':
X		Stealth = INTRINSIC;
X		HCold_resistance = INTRINSIC;
X		flags.female = TRUE;
X		u.uhp = u.uhpmax = 16;
X		u.ustr = u.ustrmax = 17;
X		ini_inv(Valkyrie);
X		break;
X	case 'h':
X	case 'H':
X		objects[POT_HEALING].oc_name_known=1;
X		objects[POT_EXTRA_HEALING].oc_name_known=1;
X		HPoison_resistance = INTRINSIC;
X		u.uhp = u.uhpmax = 16;
X		u.ustr = u.ustrmax = 15;
X		ini_inv(Healer);
X		break;
X#endif
X	case 'k':
X	case 'K':
X		u.uhp = u.uhpmax = 12;
X		u.ustr = u.ustrmax = 10;
X		ini_inv(Knight);
X		break;
X	case 'f':
X	case 'F':
X		u.uhp = u.uhpmax = 14;
X		u.ustr = u.ustrmax = 17;
X		ini_inv(Fighter);
X		break;
X#ifdef NEWCLASS
X	case 's':
X	case 'S':
X		Fast = INTRINSIC;
X		u.uhp = u.uhpmax = 16;
X		u.ustr = u.ustrmax = 16;
X		Samurai[2].trquan = 12 + rnd(9)*rnd(9);
X		ini_inv(Samurai);
X		break;
X	case 'n':
X	case 'N':
X		Fast = INTRINSIC;
X		Stealth = INTRINSIC;
X		u.uhp = u.uhpmax = 15;
X		u.ustr = u.ustrmax = 10;
X		Ninja[1].trquan = 12 + rnd(9)*rnd(9);
X		ini_inv(Ninja);
X		break;
X	case 'p':
X	case 'P':
X		u.uhp = u.uhpmax = 13;
X		u.ustr = u.ustrmax = 15;
X# ifdef SPELLS
X		u.uen = u.uenmax += rn2(4);
X# endif
X		ini_inv(Priest);
X# ifdef MARKER
X		if(!rn2(10)) ini_inv(Magicmarker);
X# endif
X		break;
X#endif /* NEWCLASS /**/
X	default:	/* impossible */
X		u.uhp = u.uhpmax = 12;
X		u.ustr = u.ustrmax = 16;
X	}
X	find_ac();
X	if(!rn2(20)) {
X		register int d = rn2(7) - 2;	/* biased variation */
X		u.ustr += d;
X		u.ustrmax += d;
X	}
X
X#ifdef WIZARD
X	if(wizard) wiz_inv();
X#endif
X
X	/* make sure he can carry all he has - especially for T's */
X	while(inv_weight() > 0 && u.ustr < 118)
X		u.ustr++, u.ustrmax++;
X}
X
Xini_inv(trop) register struct trobj *trop; {
Xregister struct obj *obj;
Xextern struct obj *mkobj();
X	while(trop->trolet) {
X		obj = mkobj(trop->trolet);
X		obj->known = trop->trknown;
X		/* not obj->dknown = 1; - let him look at it at least once */
X		obj->cursed = 0;
X		if(obj->olet == WEAPON_SYM){
X			obj->quan = trop->trquan;
X			trop->trquan = 1;
X		}
X		if(trop->trspe != UNDEF_SPE)
X			obj->spe = trop->trspe;
X		if(trop->trotyp != UNDEF_TYP)
X			obj->otyp = trop->trotyp;
X		else
X			if(obj->otyp == WAN_WISHING)	/* gitpyr!robert */
X				obj->otyp = WAN_DEATH;
X		obj->owt = weight(obj);	/* defined after setting otyp+quan */
X		obj = addinv(obj);
X		if(obj->olet == ARMOR_SYM){
X			switch(obj->otyp){
X			case SHIELD:
X				if(!uarms) setworn(obj, W_ARMS);
X				break;
X			case HELMET:
X				if(!uarmh) setworn(obj, W_ARMH);
X				break;
X			case PAIR_OF_GLOVES:
X				if(!uarmg) setworn(obj, W_ARMG);
X				break;
X			case ELVEN_CLOAK:
X				if(!uarm2)
X					setworn(obj, W_ARM);
X				break;
X			default:
X				if(!uarm) setworn(obj, W_ARM);
X			}
X		}
X		/* below changed by GAN 01/09/87 to allow wielding of
X		 * pick-axe or can-opener if there is no weapon
X		 */
X		if(obj->olet == WEAPON_SYM || obj->otyp == PICK_AXE ||
X		   obj->otyp == CAN_OPENER)
X			if(!uwep) setuwep(obj);
X#ifndef PYRAMID_BUG
X		if(--trop->trquan) continue;	/* make a similar object */
X#else
X		if(trop->trquan) {		/* check if zero first */
X			--trop->trquan;
X			if(trop->trquan)
X				continue;	/* make a similar object */
X		}
X#endif
X		trop++;
X	}
X}
X
X#ifdef WIZARD
Xwiz_inv(){
Xregister struct trobj *trop = &Extra_objs[0];
Xextern char *getenv();
Xregister char *ep = getenv("INVENT");
Xregister int type;
X	while(ep && *ep) {
X		type = atoi(ep);
X		ep = index(ep, ',');
X		if(ep) while(*ep == ',' || *ep == ' ') ep++;
X		if(type <= 0 || type > NROFOBJECTS) continue;
X		trop->trotyp = type;
X		trop->trolet = objects[type].oc_olet;
X		trop->trspe = 4;
X		trop->trknown = 1;
X		trop->trquan = 1;
X		ini_inv(trop);
X	}
X	/* give him a wand of wishing by default */
X	trop->trotyp = WAN_WISHING;
X	trop->trolet = WAND_SYM;
X	trop->trspe = 20;
X	trop->trknown = 1;
X	trop->trquan = 1;
X	ini_inv(trop);
X}
X#endif /* WIZARD /**/
X
Xplnamesuffix() {
Xregister char *p;
X	if(p = rindex(plname, '-')) {
X		*p = 0;
X		pl_character[0] = p[1];
X		pl_character[1] = 0;
X		if(!plname[0]) {
X			askname();
X			plnamesuffix();
X		}
X	}
X}
X
Xrole_index(pc)
Xchar pc;
X{		/* must be called only from u_init() */
X		/* so that rolesyms[] is defined */
X	register char *cp;
X
X	if(cp = index(rolesyms, pc))
X		return(cp - rolesyms);
X	return(-1);
X}
END_OF_u_init.c
if test 11925 -ne `wc -c <u_init.c`; then
    echo shar: \"u_init.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f undo.sh -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"undo.sh\"
else
echo shar: Extracting \"undo.sh\" \(52 characters\)
sed "s/^X//" >undo.sh <<'END_OF_undo.sh'
X#! /bin/csh -f
Xforeach i (NetHack.??)
Xunshar $i
Xend
END_OF_undo.sh
if test 52 -ne `wc -c <undo.sh`; then
    echo shar: \"undo.sh\" unpacked with wrong size!
fi
chmod +x undo.sh
# end of overwriting check
fi
echo shar: End of archive 8 \(of 16\).
cp /dev/null ark8isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 16 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
