Relay-Version: version B 2.10 5/3/83; site utzoo.UUCP
Path: utzoo!mnetor!uunet!seismo!rochester!cornell!uw-beaver!tektronix!tekgen!tekred!games-request
From: games-request@tekred.TEK.COM
Newsgroups: comp.sources.games
Subject: v02i012:  nethack - display oriented dungeons & dragons, Part12/16
Message-ID: <1454@tekred.TEK.COM>
Date: Tue, 28-Jul-87 14:51:48 EDT
Article-I.D.: tekred.1454
Posted: Tue Jul 28 14:51:48 1987
Date-Received: Fri, 31-Jul-87 01:25:10 EDT
Sender: billr@tekred.TEK.COM
Lines: 2361
Approved: billr@tekred.TEK.COM

Submitted by: mike@genat.UUCP (Mike Stephenson)
Comp.sources.games: Volume 2, Issue 12
Archive-name: nethack/Part12



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 12 (of 16)."
# Contents:  Makefile.xenix do.c do_wear.c gold.h mkshop.c pager.c
#   prisym.c
# Wrapped by billr@tekred on Tue Jul 28 09:49:42 1987
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f Makefile.xenix -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"Makefile.xenix\"
else
echo shar: Extracting \"Makefile.xenix\" \(8830 characters\)
sed "s/^X//" >Makefile.xenix <<'END_OF_Makefile.xenix'
X#	Hack or Quest Makefile.
X#	SCCS Id: @(#)Makefile.xenix	1.3	87/07/14
X
X# if you are cross-compiling (eg. from Xenix into a Dos enviornment)
X# you will have to redefine these filenames.
XMAIN = unixmain.c
XTTY  = unixtty.c
XUNIX = unixunix.c
X
X# on some systems the termcap library is in -ltermcap
XTERMLIB = -ltermlib
X# TERMLIB = /lib/Llibtermlib.a
X# CRT0   = /lib/crt0.o
XCRT0   =
XLIBS = ${TERMLIB} -lc
X# LIBS = ${TERMLIB} /lib/Llibc.a
X
X# make NetHack
XGAME = nethack
XGAMEUID = games
XGAMEGRP = bin
XGAMEDIR = /usr/games/lib/$(GAME)dir
XSHELLDIR = /usr/games
XMANDIR  = /usr/catman/man6
XCFLAGS = -O -Ml -c
XLFLAGS = -Ml
XHACKCSRC = apply.c bones.c decl.c\
X	cmd.c do.c dothrow.c do_name.c do_wear.c dog.c dogmove.c eat.c end.c\
X	engrave.c fight.c fountain.c hack.c invent.c ioctl.c lev.c main.c\
X	makemon.c mhitu.c mklev.c mkmaze.c mkobj.c mkshop.c\
X	mon.c monmove.c monst.c o_init.c objnam.c options.c\
X	pager.c polyself.c potion.c pray.c pri.c prisym.c read.c rip.c\
X	rumors.c save.c search.c shk.c shknam.c sit.c spell.c steal.c\
X	termcap.c timeout.c topl.c topten.c track.c trap.c tty.c unix.c\
X	u_init.c vault.c wield.c wizard.c worm.c worn.c write.c zap.c\
X	version.c rnd.c alloc.c
X
XCSOURCES = $(HACKCSRC) makedefs.c
X
XHSOURCES = hack.h mfndpos.h config.h edog.h eshk.h extern.h\
X	flag.h func_tab.h gold.h mkroom.h monst.h obj.h\
X	objclass.h objects.h permonst.h rm.h spell.h trap.h wseg.h you.h
X
XSOURCES = $(CSOURCES) $(HSOURCES)
X
XAUX = help hh nethack.6 nethack.sh
XVARAUX = data rumors
X
XDISTR = $(SOURCES) $(AUX) $(VARAUX) README.OLD README\
X	Makefile.unix Makefile.xenix Makefile.pc Make.ini
X
XHOBJ = apply.o bones.o decl.o cmd.o do.o dothrow.o do_name.o do_wear.o dog.o\
X	dogmove.o eat.o end.o engrave.o fight.o fountain.o hack.o\
X	invent.o ioctl.o lev.o main.o makemon.o mhitu.o mklev.o\
X	mkmaze.o mkobj.o mkshop.o mon.o monmove.o monst.o\
X	o_init.o objnam.o options.o pager.o polyself.o potion.o pray.o\
X	pri.o prisym.o read.o rip.o rumors.o save.o search.o shk.o shknam.o\
X	sit.o spell.o steal.o termcap.o timeout.o topl.o topten.o track.o\
X	trap.o tty.o unix.o u_init.o vault.o wield.o wizard.o worm.o worn.o\
X	write.o zap.o version.o rnd.o alloc.o
X
X$(GAME):	specifics $(HOBJ) Makefile
X	@echo "Loading ..."
X	@cc $(LFLAGS) -o $(GAME) $(CRT0) $(HOBJ) $(LIBS)
X
Xall:	$(GAME) lint
X	@echo "Done."
X
Xmakedefs:	makedefs.c alloc.o config.h
X	cc ${CFLAGS} -o makedefs alloc.o makedefs.c
X
XRUMORFILES= rumors.base rumors.kaa rumors.mrx
X
Xrumors:	config.h $(RUMORFILES) makedefs
X	./makedefs -r
X
Xdata:	config.h data.base makedefs
X	./makedefs -d
X
Xdate.h:	$(SOURCES) makedefs
X	./makedefs -D
X
Xtrap.h:	config.h makedefs
X	./makedefs -t
X
Xonames.h:	makedefs objects.h
X	./makedefs -o
X
Xspecifics:	main.o tty.o unix.o
X
Xmain.o: main.c
X	cc ${CFLAGS} -NT MAIN -ND DMAIN main.c
X
Xmain.c:	unixmain.c hack.h
X	cp ${MAIN} main.c
X
Xtty.o:	tty.c
X	cc ${CFLAGS} -NT MAIN -ND DMAIN tty.c
X
Xtty.c:	unixtty.c extern.h
X	cp ${TTY} tty.c
X
Xunix.o:	unix.c
X	cc ${CFLAGS} -NT MAIN -ND DMAIN unix.c
X
Xunix.c:	unixunix.c hack.h mkroom.h
X	cp ${UNIX} unix.c
X
Xlint:
X# lint cannot have -p here because (i) capitals are meaningful:
X# [Ww]izard, (ii) identifiers may coincide in the first six places:
X# doweararm() versus dowearring().
X# _flsbuf comes from <stdio.h>, a bug in the system libraries.
X	@echo lint -axbh -DLINT ...
X	@lint -axbh -DLINT $(HACKCSRC) | sed '/_flsbuf/d'
X
X
Xdiff:
X	@- for i in $(SOURCES) $(AUX) ; do \
X		cmp -s $$i $D/$$i || \
X		( echo diff $D/$$i $$i ; diff $D/$$i $$i ; echo ) ; done
X
Xdistribution: Makefile
X	@- for i in READ_ME $(SOURCES) $(AUX) Makefile date.h onames.h\
X		; do \
X		cmp -s $$i $D/$$i || \
X		( echo cp $$i $D ; cp $$i $D ) ; done
X# the distribution directory also contains the empty files perm and record.
X
Xinitial:
X	-rm -rf $(GAMEDIR)
X	-mkdir $(SHELLDIR)
X	mkdir $(GAMEDIR) $(GAMEDIR)/save
X	touch $(GAMEDIR)/perm
X	touch $(GAMEDIR)/record
X	chown $(GAMEUID) $(GAMEDIR) $(GAMEDIR)/*
X	chgrp $(GAMEGRP) $(GAMEDIR) $(GAMEDIR)/*
X	chmod 666 $(GAMEDIR)/*
X	chmod 777 $(GAMEDIR) $(GAMEDIR)/save
X
Xinstall: $(VARAUX)
X	-rm -f $(GAMEDIR)/$(GAME)
X	-rm -f $(GAMEDIR)/bones*
X	-rm -f $(GAMEDIR)/save/*
X	cp help hh rumors data $(GAMEDIR)
X	cp $(GAME).sh $(SHELLDIR)/$(GAME)
X	cp $(GAME) $(GAMEDIR)/$(GAME)
X	chown $(GAMEUID) $(SHELLDIR)/$(GAME) $(GAMEDIR)/*
X	chgrp $(GAMEGRP) $(SHELLDIR)/$(GAME) $(GAMEDIR)/*
X	chmod 0755 $(SHELLDIR)/$(GAME)
X	chmod 04755 $(GAMEDIR)/$(GAME)
X	-cp nethack.6 $(MANDIR)
X
Xclean:
X	rm -f *.o
X
Xspotless: clean
X	rm -f a.out core $(GAME) makedefs
X	rm -f Makefile $(VARAUX) main.c tty.c unix.c
X
Xalloc.o:
X	cc ${CFLAGS} -NT MAIN -ND DMAIN -c alloc.c
Xbones.o:  hack.h
X	cc ${CFLAGS} -NT MAIN -ND DMAIN -c bones.c
Xdecl.o:  hack.h mkroom.h
X	cc ${CFLAGS} -NT MAIN -ND DMAIN -c decl.c
Xend.o:  hack.h
X	cc ${CFLAGS} -NT MAIN -ND DMAIN -c end.c
Xhack.o:  hack.h
X	cc ${CFLAGS} -NT MAIN -ND DMAIN -c hack.c
Xioctl.o:  config.h
X	cc ${CFLAGS} -NT MAIN -ND DMAIN -c ioctl.c
Xo_init.o:  config.h objects.h onames.h
X	cc ${CFLAGS} -NT MAIN -ND DMAIN -c o_init.c
Xobjnam.o:  hack.h
X	cc ${CFLAGS} -NT MAIN -ND DMAIN -c objnam.c
Xrnd.o:
X	cc ${CFLAGS} -NT MAIN -ND DMAIN -c rnd.c
Xu_init.o:  hack.h
X	cc ${CFLAGS} -NT MAIN -ND DMAIN -c u_init.c
Xversion.o:  hack.h date.h
X	cc ${CFLAGS} -NT MAIN -ND DMAIN -c version.c
Xapply.o:  hack.h edog.h mkroom.h
X	cc ${CFLAGS} -NT AUX1 -ND DAUX1 -c apply.c
Xcmd.o:  hack.h func_tab.h
X	cc ${CFLAGS} -NT AUX1 -ND DAUX1 -c cmd.c
Xdo.o:  hack.h
X	cc ${CFLAGS} -NT AUX1 -ND DAUX1 -c do.c
Xdothrow.o:  hack.h
X	cc ${CFLAGS} -NT AUX1 -ND DAUX1 -c dothrow.c
Xdo_name.o:  hack.h
X	cc ${CFLAGS} -NT AUX1 -ND DAUX1 -c do_name.c
Xdo_wear.o:  hack.h
X	cc ${CFLAGS} -NT AUX1 -ND DAUX1 -c do_wear.c
Xdog.o:  hack.h edog.h mkroom.h
X	cc ${CFLAGS} -NT AUX1 -ND DAUX1 -c dog.c
Xdogmove.o:  hack.h mfndpos.h
X	cc ${CFLAGS} -NT AUX1 -ND DAUX1 -c dogmove.c
Xeat.o:  hack.h
X	cc ${CFLAGS} -NT AUX1 -ND DAUX1 -c eat.c
Xengrave.o:  hack.h
X	cc ${CFLAGS} -NT AUX2 -ND DAUX2 -c engrave.c
Xfight.o:  hack.h
X	cc ${CFLAGS} -NT AUX2 -ND DAUX2 -c fight.c
Xfountain.o:  hack.h
X	cc ${CFLAGS} -NT AUX2 -ND DAUX2 -c fountain.c
Xinvent.o:  hack.h wseg.h
X	cc ${CFLAGS} -NT AUX2 -ND DAUX2 -c invent.c
Xlev.o:  hack.h mkroom.h wseg.h
X	cc ${CFLAGS} -NT AUX2 -ND DAUX2 -c lev.c
Xmakemon.o:  hack.h
X	cc ${CFLAGS} -NT AUX2 -ND DAUX2 -c makemon.c
Xmhitu.o:  hack.h
X	cc ${CFLAGS} -NT AUX2 -ND DAUX2 -c mhitu.c
Xmklev.o:  hack.h mkroom.h
X	cc ${CFLAGS} -NT AUX3 -ND DAUX3 -c mklev.c
Xmkmaze.o:  hack.h mkroom.h
X	cc ${CFLAGS} -NT AUX3 -ND DAUX3 -c mkmaze.c
Xmkobj.o:  hack.h
X	cc ${CFLAGS} -NT AUX3 -ND DAUX3 -c mkobj.c
Xmkshop.o:  hack.h mkroom.h eshk.h
X	cc ${CFLAGS} -NT AUX3 -ND DAUX3 -c mkshop.c
Xmon.o:  hack.h mfndpos.h
X	cc ${CFLAGS} -NT AUX3 -ND DAUX3 -c mon.c
Xmonmove.o:  hack.h mfndpos.h
X	cc ${CFLAGS} -NT AUX3 -ND DAUX3 -c monmove.c
Xmonst.o:  hack.h eshk.h
X	cc ${CFLAGS} -NT AUX3 -ND DAUX3 -c monst.c
Xoptions.o:  config.h hack.h
X	cc ${CFLAGS} -NT AUX3 -ND DAUX3 -c options.c
Xpager.o:  hack.h
X	cc ${CFLAGS} -NT AUX3 -ND DAUX3 -c pager.c
Xpolyself.o: hack.h
X	cc ${CFLAGS} -NT AUX4 -ND DAUX4 -c polyself.c
Xpotion.o:  hack.h
X	cc ${CFLAGS} -NT AUX4 -ND DAUX4 -c potion.c
Xpray.o: hack.h
X	cc ${CFLAGS} -NT AUX4 -ND DAUX4 -c pray.c
Xpri.o:  hack.h
X	cc ${CFLAGS} -NT AUX4 -ND DAUX4 -c pri.c
Xprisym.o:  hack.h wseg.h
X	cc ${CFLAGS} -NT AUX4 -ND DAUX4 -c prisym.c
Xread.o:  hack.h
X	cc ${CFLAGS} -NT AUX4 -ND DAUX4 -c read.c
Xrip.o:  hack.h
X	cc ${CFLAGS} -NT AUX4 -ND DAUX4 -c rip.c
Xrumors.o:  hack.h
X	cc ${CFLAGS} -NT AUX4 -ND DAUX4 -c rumors.c
Xsave.o:  hack.h
X	cc ${CFLAGS} -NT AUX4 -ND DAUX4 -c save.c
Xsearch.o:  hack.h
X	cc ${CFLAGS} -NT AUX4 -ND DAUX4 -c search.c
Xshk.o:  hack.h mfndpos.h mkroom.h eshk.h
X	cc ${CFLAGS} -NT AUX5 -ND DAUX5 -c shk.c
Xshknam.o:  hack.h
X	cc ${CFLAGS} -NT AUX5 -ND DAUX5 -c shknam.c
Xsit.o:  hack.h
X	cc ${CFLAGS} -NT AUX5 -ND DAUX5 -c sit.c
Xspell.o:  hack.h
X	cc ${CFLAGS} -NT AUX5 -ND DAUX5 -c spell.c
Xsteal.o:  hack.h
X	cc ${CFLAGS} -NT AUX5 -ND DAUX5 -c steal.c
Xtermcap.o:  config.h flag.h
X	cc ${CFLAGS} -NT AUX5 -ND DAUX5 -c termcap.c
Xtimeout.o:  hack.h
X	cc ${CFLAGS} -NT AUX5 -ND DAUX5 -c timeout.c
Xtopl.o:  hack.h
X	cc ${CFLAGS} -NT AUX5 -ND DAUX5 -c topl.c
Xtopten.o:  hack.h
X	cc ${CFLAGS} -NT AUX5 -ND DAUX5 -c topten.c
Xtrack.o:  hack.h
X	cc ${CFLAGS} -NT AUX5 -ND DAUX5 -c track.c
Xtrap.o:  hack.h mkroom.h
X	cc ${CFLAGS} -NT AUX6 -ND DAUX6 -c trap.c
Xvault.o:  hack.h mkroom.h
X	cc ${CFLAGS} -NT AUX6 -ND DAUX6 -c vault.c
Xwield.o:  hack.h
X	cc ${CFLAGS} -NT AUX6 -ND DAUX6 -c wield.c
Xwizard.o:  hack.h
X	cc ${CFLAGS} -NT AUX6 -ND DAUX6 -c wizard.c
Xworm.o:  hack.h wseg.h
X	cc ${CFLAGS} -NT AUX6 -ND DAUX6 -c worm.c
Xworn.o:  hack.h
X	cc ${CFLAGS} -NT AUX6 -ND DAUX6 -c worn.c
Xwrite.o:  hack.h
X	cc ${CFLAGS} -NT AUX6 -ND DAUX6 -c write.c
Xzap.o:  hack.h
X	cc ${CFLAGS} -NT AUX6 -ND DAUX6 -c zap.c
Xextern.h: config.h
X	touch extern.h
Xhack.h:  config.h objclass.h monst.h gold.h trap.h obj.h flag.h rm.h permonst.h spell.h onames.h extern.h you.h
X	touch hack.h
Xobjects.h:  config.h objclass.h
X	touch objects.h
END_OF_Makefile.xenix
if test 8830 -ne `wc -c <Makefile.xenix`; then
    echo shar: \"Makefile.xenix\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f do.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"do.c\"
else
echo shar: Extracting \"do.c\" \(8441 characters\)
sed "s/^X//" >do.c <<'END_OF_do.c'
X/*	SCCS Id: @(#)do.c	1.3	87/07/14
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* do.c - version 1.0.3 */
X
X/* Contains code for 'd', 'D' (drop), '>', '<' (up, down) and 't' (throw) */
X
X#include "hack.h"
X
Xextern struct obj *splitobj(), *addinv();
Xextern boolean hmon();
Xextern boolean level_exists[];
Xextern struct monst youmonst;
Xextern char *Doname();
Xextern char *nomovemsg;
Xint	identify();
X#ifdef KAA
Xextern char *xname();
X#endif
X
Xdodrop() {
X	return(drop(getobj("0$#", "drop")));
X}
X
Xstatic
Xdrop(obj) register struct obj *obj; {
X	if(!obj) return(0);
X	if(obj->olet == '$') {		/* pseudo object */
X		register long amount = OGOLD(obj);
X
X		if(amount == 0)
X			pline("You didn't drop any gold pieces.");
X/* Fix bug with dropping huge amounts of gold read as negative    KAA */
X		else if(amount < 0) {
X			u.ugold += amount;
X	pline("The LRS would be very interested to know you have that much.");
X		} else {
X			/* uswallow test added by GAN 01/29/87 */
X			pline("You dropped %ld gold piece%s.",
X				 amount, plur(amount));
X			if(u.uswallow)
X				(u.ustuck)->mgold += amount;
X			else {
X				mkgold(amount, u.ux, u.uy);
X				if(Invisible) newsym(u.ux, u.uy);
X			}
X		}
X		free((char *) obj);
X		return(1);
X	}
X	if(obj->owornmask & (W_ARMOR | W_RING)){
X		pline("You cannot drop something you are wearing.");
X		return(0);
X	}
X	if(obj == uwep) {
X		if(uwep->cursed) {
X			pline("Your weapon is welded to your hand!");
X			return(0);
X		}
X		setuwep((struct obj *) 0);
X	}
X	pline("You dropped %s.", doname(obj));
X	dropx(obj);
X	return(1);
X}
X
X/* Called in several places - should not produce texts */
Xdropx(obj)
Xregister struct obj *obj;
X{
X	freeinv(obj);
X	dropy(obj);
X}
X
Xdropy(obj)
Xregister struct obj *obj;
X{
X	if(obj->otyp == CRYSKNIFE)
X		obj->otyp = WORM_TOOTH;
X	/* uswallow check done by GAN 01/29/87 */
X	if(u.uswallow)
X		mpickobj(u.ustuck,obj);
X	else  {
X		obj->ox = u.ux;
X		obj->oy = u.uy;
X		/* Blind check added by GAN 02/18/87 */
X		if(Blind)  {
X#ifdef KAA
X			if(obj->olet != ')')
X#endif
X			    obj->dknown = index("/=!?*",obj->olet) ? 0 : 1;
X			obj->known = 0;
X		}
X		obj->nobj = fobj;
X		fobj = obj;
X		if(Invisible) newsym(u.ux,u.uy);
X		subfrombill(obj);
X		stackobj(obj);
X	}
X}
X
X/* drop several things */
Xdoddrop() {
X	return(ggetobj("drop", drop, 0));
X}
X
Xdodown()
X{
X	if(u.ux != xdnstair || u.uy != ydnstair) {
X		pline("You can't go down here.");
X		return(0);
X	}
X	if(u.ustuck) {
X		pline("You are being held, and cannot go down.");
X		return(1);
X	}
X	if(Levitation) {
X		pline("You're floating high above the stairs.");
X		return(0);
X	}
X
X	goto_level(dlevel+1, TRUE);
X	return(1);
X}
X
Xdoup()
X{
X	if(u.ux != xupstair || u.uy != yupstair) {
X		pline("You can't go up here.");
X		return(0);
X	}
X	if(u.ustuck) {
X		pline("You are being held, and cannot go up.");
X		return(1);
X	}
X	if(!Levitation && inv_weight() + 5 > 0) {
X		pline("Your load is too heavy to climb the stairs.");
X		return(1);
X	}
X
X	goto_level(dlevel-1, TRUE);
X	return(1);
X}
X
Xgoto_level(newlevel, at_stairs)
Xregister int newlevel;
Xregister boolean at_stairs;
X{
X	register fd;
X	register boolean up = (newlevel < dlevel);
X
X	if(newlevel <= 0) done("escaped");    /* in fact < 0 is impossible */
X	if(newlevel > MAXLEVEL) newlevel = MAXLEVEL;	/* strange ... */
X	if(newlevel == dlevel) return;	      /* this can happen */
X
X	glo(dlevel);
X#ifdef DGK
X	/* Use O_TRUNC to force the file to be shortened if it already
X	 * exists and is currently longer.
X	 */
X	fd = open(lock, O_WRONLY | O_BINARY | O_CREAT | O_TRUNC, FMASK);
X#else
X	fd = creat(lock, FMASK);
X#endif
X	if(fd < 0) {
X		/*
X		 * This is not quite impossible: e.g., we may have
X		 * exceeded our quota. If that is the case then we
X		 * cannot leave this level, and cannot save either.
X		 * Another possibility is that the directory was not
X		 * writable.
X		 */
X#ifdef DGK
X		pline("Cannot create level file '%s'.", lock);
X#else
X		pline("A mysterious force prevents you from going %s.",
X			up ? "up" : "down");
X#endif
X		return;
X	}
X
X#ifdef DGK
X	if (!savelev(fd, dlevel, COUNT)) {
X		(void) close(fd);
X		(void) unlink(lock);
X		pline("HACK is out of disk space for making levels!");
X		pline("You can save, quit, or continue playing.");
X		return;
X	}
X#endif
X	if(Punished) unplacebc();
X	u.utrap = 0;				/* needed in level_tele */
X	u.ustuck = 0;				/* idem */
X	keepdogs();
X	seeoff(1);
X	if(u.uswallow)				/* idem */
X		u.uswldtim = u.uswallow = 0;
X	flags.nscrinh = 1;
X	u.ux = FAR;				/* hack */
X	(void) inshop();			/* probably was a trapdoor */
X
X#ifdef DGK
X	savelev(fd,dlevel, WRITE);
X#else
X	savelev(fd,dlevel);
X#endif
X	(void) close(fd);
X
X	dlevel = newlevel;
X	if(maxdlevel < dlevel)
X		maxdlevel = dlevel;
X	glo(dlevel);
X#ifdef MSDOS
X	/* If the level has no where yet, it hasn't been made
X	 */
X	if(!fileinfo[dlevel].where)
X#else
X	if(!level_exists[dlevel])
X#endif
X		mklev();
X	else {
X		extern int hackpid;
X#ifdef DGK
X		/* If not currently accessible, swap it in.
X		 */
X		if (fileinfo[dlevel].where != ACTIVE)
X			swapin_file(dlevel);
X
X		if((fd = open(lock, O_RDONLY | O_BINARY)) < 0) {
X#else
X		if((fd = open(lock,0)) < 0) {
X#endif
X			pline("Cannot open %s .", lock);
X			pline("Probably someone removed it.");
X			done("tricked");
X		}
X		getlev(fd, hackpid, dlevel);
X		(void) close(fd);
X	}
X
X	if(at_stairs) {
X	    if(up) {
X		u.ux = xdnstair;
X		u.uy = ydnstair;
X		if(!u.ux) {		/* entering a maze from below? */
X		    u.ux = xupstair;	/* this will confuse the player! */
X		    u.uy = yupstair;
X		}
X/* Remove bug which crashes with levitation/punishment  KAA */
X		if(Punished) {
X		    if(!Levitation) 
X			pline("With great effort you climb the stairs.");
X		    placebc(1);
X		}
X	    } else {
X		u.ux = xupstair;
X		u.uy = yupstair;
X		if(inv_weight() + 5 > 0 || Punished){
X			pline("You fall down the stairs.");	/* %% */
X			losehp(rnd(3), "fall");
X			if(Punished) {
X			    if(uwep != uball && rn2(3)){
X				pline("... and are hit by the iron ball.");
X				losehp(rnd(20), "iron ball");
X			    }
X			    placebc(1);
X			}
X			selftouch("Falling, you");
X		}
X	    }
X	    { register struct monst *mtmp = m_at(u.ux, u.uy);
X	      if(mtmp)
X		mnexto(mtmp);
X	    }
X	} else {	/* trapdoor or level_tele */
X	    do {
X		u.ux = rnd(COLNO-1);
X		u.uy = rn2(ROWNO);
X	    } while(levl[u.ux][u.uy].typ != ROOM ||
X			m_at(u.ux,u.uy));
X	    if(Punished){
X		if(uwep != uball && !up /* %% */ && rn2(5)){
X			pline("The iron ball falls on your head.");
X			losehp(rnd(25), "iron ball");
X		}
X		placebc(1);
X	    }
X	    selftouch("Falling, you");
X	}
X	(void) inshop();
X	initrack();
X
X	losedogs();
X	{ register struct monst *mtmp;
X	  if(mtmp = m_at(u.ux, u.uy)) mnexto(mtmp);	/* riv05!a3 */
X	}
X	flags.nscrinh = 0;
X	setsee();
X	seeobjs();	/* make old cadavers disappear - riv05!a3 */
X	docrt();
X	pickup(1);
X	if (!Blind) read_engr_at(u.ux,u.uy);
X}
X
Xdonull() {
X	return(1);	/* Do nothing, but let other things happen */
X}
X
X#if defined(KAA) && defined(KOPS)
Xwipeoff()
X{
X	u.ucreamed -= 4;
X	if(u.ucreamed > 0)  {
X		Blind -= 4;
X		if(Blind <= 1) {
X			pline("You've got the glop off.");
X			u.ucreamed = 0;
X			Blind = 1;
X			return(0);
X		}
X		return(1);		/* still busy */
X	}
X	pline("You're face feels clean now.");
X	u.ucreamed = 0;
X	return(0);
X}
X	
Xdowipe()
X{
X	if(u.ucreamed)  {
X#ifdef DGKMOD
X		set_occupation(wipeoff, "wiping off your face", 0);
X#else
X		occupation = wipeoff;
X		occtxt = "wiping off your face";
X#endif
X		return(1);
X	}
X	pline("You're face is already clean.");
X	return(1);
X}
X#endif
X
X/* split obj so that it gets size num */
X/* remainder is put in the object structure delivered by this call */
Xstruct obj *
Xsplitobj(obj, num) register struct obj *obj; register int num; {
Xregister struct obj *otmp;
X	otmp = newobj(0);
X	*otmp = *obj;		/* copies whole structure */
X	otmp->o_id = flags.ident++;
X	otmp->onamelth = 0;
X	obj->quan = num;
X	obj->owt = weight(obj);
X	otmp->quan -= num;
X	otmp->owt = weight(otmp);	/* -= obj->owt ? */
X	obj->nobj = otmp;
X	if(obj->unpaid) splitbill(obj,otmp);
X	return(otmp);
X}
X
Xmore_experienced(exp,rexp)
Xregister int exp, rexp;
X{
X	extern char pl_character[];
X
X	u.uexp += exp;
X	u.urexp += 4*exp + rexp;
X	if(exp) flags.botl = 1;
X	if(u.urexp >= ((pl_character[0] == 'W') ? 1000 : 2000))
X		flags.beginner = 0;
X}
X
Xset_wounded_legs(side, timex)
Xregister long side;
Xregister int timex;
X{
X	if(!Wounded_legs || (Wounded_legs & TIMEOUT))
X		Wounded_legs |= side + timex;
X	else
X		Wounded_legs |= side;
X}
X
Xheal_legs()
X{
X	if(Wounded_legs) {
X		if((Wounded_legs & BOTH_SIDES) == BOTH_SIDES)
X			pline("Your legs feel somewhat better.");
X		else
X			pline("Your leg feels somewhat better.");
X		Wounded_legs = 0;
X	}
X}
END_OF_do.c
if test 8441 -ne `wc -c <do.c`; then
    echo shar: \"do.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f do_wear.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"do_wear.c\"
else
echo shar: Extracting \"do_wear.c\" \(8787 characters\)
sed "s/^X//" >do_wear.c <<'END_OF_do_wear.c'
X/*	SCCS Id: @(#)do_wear.c	1.3	87/07/14
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* do_wear.c - version 1.0.3 */
X
X#include <stdio.h>
X#include "hack.h"
Xextern char *nomovemsg;
Xextern char quitchars[];
Xextern char *Doname();
X
Xoff_msg(otmp) register struct obj *otmp; {
X	pline("You were wearing %s.", doname(otmp));
X}
X
Xdoremarm() {
X	register struct obj *otmp;
X	if(!uarm && !uarmh && !uarms && !uarmg) {
X		pline("Not wearing any armor.");
X		return(0);
X	}
X	otmp = (!uarmh && !uarms && !uarmg) ? uarm :
X		(!uarms && !uarm && !uarmg) ? uarmh :
X		(!uarmh && !uarm && !uarmg) ? uarms :
X		(!uarmh && !uarm && !uarms) ? uarmg :
X		getobj("[", "take off");
X	if(!otmp) return(0);
X	if(!(otmp->owornmask & (W_ARMOR - W_ARM2))) {
X		pline("You can't take that off.");
X		return(0);
X	}
X	if( otmp == uarmg && uwep && uwep->cursed ) {	/* myers@uwmacc */
X pline("You seem not able to take off the gloves while holding your weapon.");
X		return(0);
X	}
X	(void) armoroff(otmp);
X	return(1);
X}
X
Xdoremring() {
X	if(!uleft && !uright){
X		pline("Not wearing any ring.");
X		return(0);
X	}
X	if(!uleft)
X		return(dorr(uright));
X	if(!uright)
X		return(dorr(uleft));
X	if(uleft && uright) while(1) {
X		char answer;
X
X		pline("What ring, Right or Left? [ rl?]");
X		if(index(quitchars, (answer = readchar())))
X			return(0);
X		switch(answer) {
X		case 'l':
X		case 'L':
X			return(dorr(uleft));
X		case 'r':
X		case 'R':
X			return(dorr(uright));
X		case '?':
X			(void) doprring();
X			/* might look at morc here %% */
X		}
X	}
X	/* NOTREACHED */
X#ifdef lint
X	return(0);
X#endif
X}
X
Xdorr(otmp) register struct obj *otmp; {
X	if(cursed(otmp)) return(0);
X	ringoff(otmp);
X	off_msg(otmp);
X	return(1);
X}
X
Xcursed(otmp) register struct obj *otmp; {
X	if(otmp->cursed){
X		pline("You can't. It appears to be cursed.");
X		return(1);
X	}
X	return(0);
X}
X
Xarmoroff(otmp) register struct obj *otmp; {
Xregister int delay = -objects[otmp->otyp].oc_delay;
X	if(cursed(otmp)) return(0);
X	setworn((struct obj *) 0, otmp->owornmask & W_ARMOR);
X	if(delay) {
X		nomul(delay);
X		switch(otmp->otyp) {
X		case HELMET:
X			nomovemsg = "You finished taking off your helmet.";
X			break;
X		case PAIR_OF_GLOVES:
X			nomovemsg = "You finished taking off your gloves";
X			break;
X		default:
X			nomovemsg = "You finished taking off your suit.";
X		}
X	} else {
X		off_msg(otmp);
X	}
X	return(1);
X}
X
Xdoweararm() {
X	register struct obj *otmp;
X	register int delay;
X	register int err = 0;
X	long mask = 0;
X
X#ifdef KAA
X	if(!index("@enozCGHIKLNOTUVWXYZ&",u.usym)) {
X		pline("Don't even bother.");
X		return(0);
X	}
X#endif
X	otmp = getobj("[", "wear");
X	if(!otmp) return(0);
X	if(otmp->owornmask & W_ARMOR) {
X		pline("You are already wearing that!");
X		return(0);
X	}
X	if(otmp->otyp == HELMET){
X		if(uarmh) {
X			pline("You are already wearing a helmet.");
X			err++;
X		} else
X			mask = W_ARMH;
X	} else if(otmp->otyp == SHIELD){
X		if(uarms) pline("You are already wearing a shield."), err++;
X		if(uwep && uwep->otyp == TWO_HANDED_SWORD)
X	pline("You cannot wear a shield and wield a two handed sword."), err++;
X		if(!err) mask = W_ARMS;
X	} else if(otmp->otyp == PAIR_OF_GLOVES) {
X		if(uarmg) {
X			pline("You are already wearing gloves.");
X			err++;
X		} else
X		if(uwep && uwep->cursed) {
X			pline("You cannot wear gloves over your weapon.");
X			err++;
X		} else
X			mask = W_ARMG;
X	} else {
X#ifdef KAA
X		if(cantweararm(u.usym)) {
X			pline("You can't wear armor!");
X			return(0);
X		}
X#endif
X		if(uarm) {
X			if(otmp->otyp != ELVEN_CLOAK || uarm2) {
X				pline("You are already wearing some armor.");
X				err++;
X			}
X		}
X		if(!err) mask = W_ARM;
X	}
X	if(welded(otmp)) {
X		if(!err++)
X			pline("%s is welded to your hand.", Doname(uwep));
X	}
X	if(err) return(0);
X	setworn(otmp, mask);
X	if(otmp == uwep)
X		setuwep((struct obj *) 0);
X	delay = -objects[otmp->otyp].oc_delay;
X	if(delay){
X		nomul(delay);
X		nomovemsg = "You finished your dressing manoeuvre.";
X	}
X	otmp->known = 1;
X	return(1);
X}
X
Xdowearring() {
X	register struct obj *otmp;
X	long mask = 0;
X	long oldprop;
X
X	if(uleft && uright){
X		pline("There are no more ring-fingers to fill.");
X		return(0);
X	}
X	otmp = getobj("=", "wear");
X	if(!otmp) return(0);
X	if(otmp->owornmask & W_RING) {
X		pline("You are already wearing that!");
X		return(0);
X	}
X	if(otmp == uleft || otmp == uright) {
X		pline("You are already wearing that.");
X		return(0);
X	}
X	if(welded(otmp)) {
X		pline("%s is welded to your hand.", Doname(uwep));
X		return(0);
X	}
X	if(uleft) mask = RIGHT_RING;
X	else if(uright) mask = LEFT_RING;
X	else do {
X		char answer;
X
X		pline("What ring-finger, Right or Left? ");
X		if(index(quitchars, (answer = readchar())))
X			return(0);
X		switch(answer){
X		case 'l':
X		case 'L':
X			mask = LEFT_RING;
X			break;
X		case 'r':
X		case 'R':
X			mask = RIGHT_RING;
X			break;
X		}
X	} while(!mask);
X	setworn(otmp, mask);
X	if(otmp == uwep)
X		setuwep((struct obj *) 0);
X	oldprop = u.uprops[PROP(otmp->otyp)].p_flgs;
X	u.uprops[PROP(otmp->otyp)].p_flgs |= mask;
X	switch(otmp->otyp){
X	case RIN_LEVITATION:
X		if(!oldprop) float_up();
X		break;
X	case RIN_GAIN_STRENGTH:
X		u.ustr += otmp->spe;
X		u.ustrmax += otmp->spe;
X		if(u.ustr > 118) u.ustr = 118;
X		if(u.ustrmax > 118) u.ustrmax = 118;
X		flags.botl = 1;
X		break;
X	case RIN_INCREASE_DAMAGE:
X		u.udaminc += otmp->spe;
X		break;
X	case RIN_PROTECTION_FROM_SHAPE_CHAN:
X#ifdef DGKMOD
X		/* If you're no longer protected, let the chameleons
X		 * change shape again -dgk
X		 */
X		restartcham();
X#else
X		rescham();
X#endif /* DGKMOD /**/
X		break;
X	}
X	prinv(otmp);
X	return(1);
X}
X
Xringoff(obj)
Xregister struct obj *obj;
X{
Xregister long mask;
X	mask = obj->owornmask & W_RING;
X	setworn((struct obj *) 0, obj->owornmask);
X	if(!(u.uprops[PROP(obj->otyp)].p_flgs & mask))
X		impossible("Strange... I didnt know you had that ring.");
X	u.uprops[PROP(obj->otyp)].p_flgs &= ~mask;
X	switch(obj->otyp) {
X	case RIN_FIRE_RESISTANCE:
X		/* Bad luck if the player is in hell... --jgm */
X		if (!Fire_resistance && dlevel >= 30) {
X			pline("The flames of Hell burn you to a crisp.");
X			killer = "stupidity in hell";
X			done("burned");
X		}
X		break;
X	case RIN_LEVITATION:
X		if(!Levitation) {	/* no longer floating */
X			float_down();
X		}
X		break;
X	case RIN_GAIN_STRENGTH:
X		u.ustr -= obj->spe;
X		u.ustrmax -= obj->spe;
X		if(u.ustr > 118) u.ustr = 118;
X		if(u.ustrmax > 118) u.ustrmax = 118;
X		flags.botl = 1;
X		break;
X	case RIN_INCREASE_DAMAGE:
X		u.udaminc -= obj->spe;
X		break;
X	}
X}
X
Xfind_ac(){
Xregister int uac = 10;
X#ifdef KAA
X	if (u.mtimedone) uac = mons[u.umonnum].ac;
X#endif
X	if(uarm) uac -= ARM_BONUS(uarm);
X	if(uarm2) uac -= ARM_BONUS(uarm2);
X	if(uarmh) uac -= ARM_BONUS(uarmh);
X	if(uarms) uac -= ARM_BONUS(uarms);
X	if(uarmg) uac -= ARM_BONUS(uarmg);
X	if(uleft && uleft->otyp == RIN_PROTECTION) uac -= uleft->spe;
X	if(uright && uright->otyp == RIN_PROTECTION) uac -= uright->spe;
X#ifdef PRAYERS
X	if (Protection & INTRINSIC) uac -= u.ublessed;
X#endif
X	if(uac != u.uac){
X		u.uac = uac;
X		flags.botl = 1;
X	}
X}
X
Xglibr(){
Xregister struct obj *otmp;
Xint xfl = 0;
X	if(!uarmg) if(uleft || uright) {
X		/* Note: at present also cursed rings fall off */
X		/* changed 10/30/86 by GAN */
X		pline("Your %s off your fingers.",
X#ifdef HARD
X			((uleft && !uleft->cursed) && (uright && !uright->cursed)) ? "rings slip" : "ring slips");
X#else
X			(uleft && uright) ? "rings slip" : "ring slips");
X#endif
X		xfl++;
X		if((otmp = uleft) != Null(obj)){
X			ringoff(uleft);
X			dropx(otmp);
X		}
X		if((otmp = uright) != Null(obj)){
X			ringoff(uright);
X			dropx(otmp);
X		}
X	}
X	if(((otmp = uwep) != Null(obj))
X#ifdef HARD
X	   && !otmp->cursed
X#endif
X	) {
X		/* Note: at present also cursed weapons fall */
X		/* changed 10/30/86 by GAN */
X		setuwep((struct obj *) 0);
X		dropx(otmp);
X		pline("Your weapon %sslips from your hands.",
X			xfl ? "also " : "");
X	}
X}
X
Xstruct obj *
Xsome_armor(){
Xregister struct obj *otmph = uarm;
X	if(uarmh && (!otmph || !rn2(4))) otmph = uarmh;
X	if(uarmg && (!otmph || !rn2(4))) otmph = uarmg;
X	if(uarms && (!otmph || !rn2(4))) otmph = uarms;
X	return(otmph);
X}
X
Xcorrode_armor(){
Xregister struct obj *otmph = some_armor();
X	if(otmph){
X		if(otmph->rustfree ||
X		   otmph->otyp == CRYSTAL_PLATE_MAIL ||
X		   otmph->otyp == ELVEN_CLOAK ||
X		   otmph->otyp == LEATHER_ARMOR ||
X		   otmph->otyp == STUDDED_LEATHER_ARMOR) {
X			pline("Your %s not affected!",
X				aobjnam(otmph, "are"));
X			return;
X		}
X		pline("Your %s!", aobjnam(otmph, "corrode"));
X		otmph->spe--;
X	}
X}
X
Xstatic
Xremarm(obj) register struct obj *obj; {
X	if(!obj || obj->olet != '[')
X		return(0);
X	(void) marmoroff(obj);
X	return(1);
X}
X
Xstatic
Xmarmoroff(otmp) register struct obj *otmp; {
Xregister int delay = -objects[otmp->otyp].oc_delay;
X	if(cursed(otmp)) return(0);
X	setworn((struct obj *) 0, otmp->owornmask & W_ARMOR);
X	if(delay)
X		nomul(delay);
X	off_msg(otmp);
X	nomovemsg = "You finished taking off your armor.";
X	return(1);
X}
X
Xdoddoremarm() {
X	return(ggetobj("take off",remarm,0));
X}
END_OF_do_wear.c
if test 8787 -ne `wc -c <do_wear.c`; then
    echo shar: \"do_wear.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f gold.h -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"gold.h\"
else
echo shar: Extracting \"gold.h\" \(311 characters\)
sed "s/^X//" >gold.h <<'END_OF_gold.h'
X/*	SCCS Id: @(#)gold.h	1.3	87/07/14
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* gold.h - version 1.0.2 */
X
Xstruct gold {
X	struct gold *ngold;
X	xchar gx,gy;
X	long amount;
X};
X
Xextern struct gold *fgold;
Xstruct gold *g_at();
X#define newgold()	(struct gold *) alloc(sizeof(struct gold))
END_OF_gold.h
if test 311 -ne `wc -c <gold.h`; then
    echo shar: \"gold.h\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f mkshop.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"mkshop.c\"
else
echo shar: Extracting \"mkshop.c\" \(7823 characters\)
sed "s/^X//" >mkshop.c <<'END_OF_mkshop.c'
X/*	SCCS Id: @(#)mkshop.c	1.3	87/07/14
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* mkshop.c - version 1.0.3 */
X
X#ifndef QUEST
X#include "hack.h"
X#include "mkroom.h"
X#include "eshk.h"
X#define	ESHK	((struct eshk *)(&(shk->mextra[0])))
Xextern struct monst *makemon();
Xextern struct obj *mkobj_at();
Xextern int nroom;
Xextern char shtypes[];	/* = "=/+)%?!["; 9 types: 8 specialized, 1 mixed */
X#ifdef SPELLS
Xschar shprobs[] = { 3,3,3,5,5,10,10,14,47 };	/* their probabilities */
X#else
Xschar shprobs[] = { 3,3,5,5,10,10,14,50 };	/* their probabilities */
X#endif
X
Xmkshop(){
Xregister struct mkroom *sroom;
Xregister int sh,sx,sy,i = -1;
Xregister char let;
Xint roomno;
Xregister struct monst *shk;
X#ifdef WIZARD
X	/* first determine shoptype */
X	if(wizard){
X		extern char *getenv();
X		register char *ep = getenv("SHOPTYPE");
X		if(ep){
X			if(*ep == 'z' || *ep == 'Z'){
X				mkzoo(ZOO);
X				return;
X			}
X			if(*ep == 'm' || *ep == 'M'){
X				mkzoo(MORGUE);
X				return;
X			}
X			if(*ep == 'b' || *ep == 'B'){
X				mkzoo(BEEHIVE);
X				return;
X			}
X#ifdef NEWCLASS
X			if(*ep == 't' || *ep == 'T'){
X				mkzoo(COURT);
X				return;
X			}
X#endif
X			if(*ep == 's' || *ep == 'S'){
X				mkswamp();
X				return;
X			}
X			for(i=0; shtypes[i]; i++)
X				if(*ep == shtypes[i]) break;
X			goto gottype;
X		}
X	}
Xgottype:
X#endif
X	for(sroom = &rooms[0], roomno = 0; ; sroom++, roomno++){
X		if(sroom->hx < 0) return;
X		if(sroom - rooms >= nroom) {
X			pline("rooms not closed by -1?");
X			return;
X		}
X		if(sroom->rtype) continue;
X		if(!sroom->rlit || has_dnstairs(sroom) || has_upstairs(sroom))
X			continue;
X		if(
X#ifdef WIZARD
X		   (wizard && getenv("SHOPTYPE") && sroom->doorct != 0) ||
X#endif
X			sroom->doorct == 1) break;
X	}
X
X	if(i < 0) {			/* shoptype not yet determined */
X	    register int j;
X
X	    for(j = rn2(100), i = 0; (j -= shprobs[i])>= 0; i++)
X		if(!shtypes[i]) break;			/* superfluous */
X	    if(isbig(sroom) && i + SHOPBASE == WANDSHOP)
X		i = GENERAL-SHOPBASE;
X	}
X	sroom->rtype = i + SHOPBASE;
X	let = shtypes[i];
X	sh = sroom->fdoor;
X	sx = doors[sh].x;
X	sy = doors[sh].y;
X	if(sx == sroom->lx-1) sx++; else
X	if(sx == sroom->hx+1) sx--; else
X	if(sy == sroom->ly-1) sy++; else
X	if(sy == sroom->hy+1) sy--; else {
X#ifdef WIZARD
X	    /* This is said to happen sometimes, but I've never seen it. */
X	    if(wizard) {
X		register int j = sroom->doorct;
X		extern int doorindex;
X
X		pline("Where is shopdoor?");
X		pline("Room at (%d,%d),(%d,%d).", sroom->lx, sroom->ly,
X			sroom->hx, sroom->hy);
X		pline("doormax=%d doorct=%d fdoor=%d",
X			doorindex, sroom->doorct, sh);
X		while(j--) {
X			pline("door [%d,%d]", doors[sh].x, doors[sh].y);
X			sh++;
X		}
X		more();
X	    }
X#endif
X	    return;
X	}
X	if(!(shk = makemon(PM_SHK,sx,sy))) return;
X	shk->isshk = shk->mpeaceful = 1;
X	shk->msleep = 0;
X	shk->mtrapseen = ~0;	/* we know all the traps already */
X	ESHK->shoproom = roomno;
X	ESHK->shoplevel = dlevel;
X	ESHK->shd = doors[sh];
X	ESHK->shk.x = sx;
X	ESHK->shk.y = sy;
X	ESHK->robbed = 0;
X	ESHK->visitct = 0;
X	ESHK->following = 0;
X	shk->mgold = 1000 + 30*rnd(100);	/* initial capital */
X	ESHK->billct = 0;
X	findname(ESHK->shknam, let);
X	for(sx = sroom->lx; sx <= sroom->hx; sx++)
X	for(sy = sroom->ly; sy <= sroom->hy; sy++){
X		register struct monst *mtmp;
X		if((sx == sroom->lx && doors[sh].x == sx-1) ||
X		   (sx == sroom->hx && doors[sh].x == sx+1) ||
X		   (sy == sroom->ly && doors[sh].y == sy-1) ||
X		   (sy == sroom->hy && doors[sh].y == sy+1)) continue;
X		if(rn2(100) < dlevel && !m_at(sx,sy) &&
X		   (mtmp = makemon(PM_MIMIC, sx, sy))){
X			mtmp->mimic = 1;
X			mtmp->mappearance =
X			    (let && rn2(10) < dlevel) ? let : ']';
X			continue;
X		}
X		(void) mkobj_at(let, sx, sy);
X	}
X}
X
Xmkzoo(type)
Xint type;
X{
X	register struct mkroom *sroom;
X	register struct monst *mon;
X	register int sh,sx,sy,i;
X	int goldlim = 500 * dlevel;
X	int moct = 0;
X	struct permonst *morguemon();
X#ifdef NEWCLASS
X	struct permonst *courtmon();
X#endif
X
X	i = nroom;
X	for(sroom = &rooms[rn2(nroom)]; ; sroom++) {
X		if(sroom == &rooms[nroom])
X			sroom = &rooms[0];
X		if(!i-- || sroom->hx < 0)
X			return;
X		if(sroom->rtype)			continue;
X		if(type == MORGUE && sroom->rlit)	continue;
X		if(has_upstairs(sroom) || (has_dnstairs(sroom) && rn2(3)))
X			continue;
X		if(sroom->doorct == 1 || !rn2(5))
X			break;
X	}
X	sroom->rtype = type;
X	sh = sroom->fdoor;
X	for(sx = sroom->lx; sx <= sroom->hx; sx++)
X	    for(sy = sroom->ly; sy <= sroom->hy; sy++){
X		if((sx == sroom->lx && doors[sh].x == sx-1) ||
X		   (sx == sroom->hx && doors[sh].x == sx+1) ||
X		   (sy == sroom->ly && doors[sh].y == sy-1) ||
X		   (sy == sroom->hy && doors[sh].y == sy+1)) continue;
X		mon = makemon(
X#ifdef NEWCLASS
X		   (type == COURT) ? courtmon() :
X#endif
X		   (type == MORGUE) ? morguemon() :
X		   (type == BEEHIVE) ? PM_KILLER_BEE : (struct permonst *) 0,
X		   sx, sy);
X		if(mon) mon->msleep = 1;
X		switch(type) {
X		case ZOO:
X		   i = sq(dist2(sx,sy,doors[sh].x,doors[sh].y));
X		   if(i >= goldlim) i = 5*dlevel;
X		   goldlim -= i;
X		   mkgold((long)(10 + rn2(i)), sx, sy);
X		   break;
X		case MORGUE:
X		   /* Usually there is one dead body in the morgue */
X		   if(!moct && rn2(3)) {
X			mksobj_at(CORPSE, sx, sy);
X			moct++;
X		   }
X		   break;
X		case BEEHIVE:
X		   if(!rn2(3)) mksobj_at(LUMP_OF_ROYAL_JELLY, sx, sy);
X		   break;
X		}
X	}
X#ifdef NEWCLASS
X	if(type == COURT)  {
X
X		sx = sroom->lx + (rn2(sroom->hx - sroom->lx));
X		sy = sroom->ly + (rn2(sroom->hy - sroom->ly));
X		levl[sx][sy].typ = THRONE;
X		levl[sx][sy].scrsym = THRONE_SYM;
X		mkgold((long) rn1(50 * dlevel,10), sx, sy);
X	}
X#endif
X
X}
X
Xstruct permonst *
Xmorguemon()
X{
X	extern struct permonst pm_ghost;
X	register int i = rn2(100), hd = rn2(dlevel);
X
X	if(hd > 10 && i < 10) return(PM_DEMON);
X	if(hd > 8 && i > 85) return(PM_VAMPIRE);
X	return((i < 40) ? PM_GHOST : (i < 60) ? PM_WRAITH : PM_ZOMBIE);
X}
X
Xmkswamp()	/* Michiel Huisjes & Fred de Wilde */
X{
X	register struct mkroom *sroom;
X	register int sx,sy,i,eelct = 0;
X	extern struct permonst pm_eel;
X
X	for(i=0; i<5; i++) {		/* 5 tries */
X		sroom = &rooms[rn2(nroom)];
X		if(sroom->hx < 0 || sroom->rtype ||
X		   has_upstairs(sroom) || has_dnstairs(sroom))
X			continue;
X
X		/* satisfied; make a swamp */
X		sroom->rtype = SWAMP;
X		for(sx = sroom->lx; sx <= sroom->hx; sx++)
X		for(sy = sroom->ly; sy <= sroom->hy; sy++)
X		if((sx+sy)%2 && !o_at(sx,sy) && !t_at(sx,sy)
X			     && !m_at(sx,sy) && !nexttodoor(sx,sy)){
X			levl[sx][sy].typ = POOL;
X			levl[sx][sy].scrsym = POOL_SYM;
X			if(!eelct || !rn2(4)) {
X				(void) makemon(PM_EEL, sx, sy);
X				eelct++;
X			}
X		}
X	}
X}
X
Xnexttodoor(sx,sy)
Xregister sx,sy;
X{
X	register dx,dy;
X	register struct rm *lev;
X	for(dx = -1; dx <= 1; dx++) for(dy = -1; dy <= 1; dy++)
X		if((lev = &levl[sx+dx][sy+dy])->typ == DOOR ||
X		    lev->typ == SDOOR || lev->typ == LDOOR)
X			return(1);
X	return(0);
X}
X
Xhas_dnstairs(sroom)
Xregister struct mkroom *sroom;
X{
X	return(sroom->lx <= xdnstair && xdnstair <= sroom->hx &&
X		   sroom->ly <= ydnstair && ydnstair <= sroom->hy);
X}
X
Xhas_upstairs(sroom)
Xregister struct mkroom *sroom;
X{
X	return(sroom->lx <= xupstair && xupstair <= sroom->hx &&
X		   sroom->ly <= yupstair && yupstair <= sroom->hy);
X}
X
Xisbig(sroom)
Xregister struct mkroom *sroom;
X{
X	register int area = (sroom->hx - sroom->lx) * (sroom->hy - sroom->ly);
X	return( area > 20 );
X}
X
Xdist2(x0,y0,x1,y1){
X	return((x0-x1)*(x0-x1) + (y0-y1)*(y0-y1));
X}
X
Xsq(a) int a; {
X	return(a*a);
X}
X#endif /* QUEST /**/
X
X#ifdef NEWCLASS
Xstruct permonst *
Xcourtmon()
X{
X	int     i = rn2(60) + rn2(3*dlevel);
X
X	if (i > 100)		return(PM_DRAGON);
X	else if (i > 95)	return(PM_XORN);
X	else if (i > 85)	return(PM_TROLL);
X	else if (i > 75)	return(PM_ETTIN);
X	else if (i > 60)	return(PM_CENTAUR);
X	else if (i > 45)	return(PM_ORC);
X	else if (i > 30)	return(PM_HOBGOBLIN);
X#ifdef KOPS
X	else			return(PM_GNOME);
X#else
X	else if (i > 15)	return(PM_GNOME);
X	else			return(PM_KOBOLD);
X#endif
X}
X#endif /* NEWCLASS /**/
END_OF_mkshop.c
if test 7823 -ne `wc -c <mkshop.c`; then
    echo shar: \"mkshop.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f pager.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"pager.c\"
else
echo shar: Extracting \"pager.c\" \(8734 characters\)
sed "s/^X//" >pager.c <<'END_OF_pager.c'
X/*	SCCS Id: @(#)pager.c	1.3	87/07/14
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* pager.c - version 1.0.3 */
X
X/* This file contains the command routine dowhatis() and a pager. */
X/* Also readmail() and doshell(), and generally the things that
X   contact the outside world. */
X
X#include	<stdio.h>
X#include	<signal.h>
X#include	 "hack.h"
Xextern int CO, LI;	/* usually COLNO and ROWNO+2 */
Xextern char *CD;
Xextern char quitchars[];
Xextern char *getenv(), *getlogin();
Xint done1();
X
Xdowhatis()
X{
X	FILE *fp;
X	char bufr[BUFSZ+6];
X	register char *buf = &bufr[6], *ep, q;
X	extern char readchar();
X
X	if(!(fp = fopen(DATAFILE, "r")))
X		pline("Cannot open data file!");
X	else {
X		pline("Specify what? ");
X		q = readchar();
X#ifdef DGKMOD
X		if (index(quitchars, q))
X			return(0);
X#endif
X		if(q != '\t')
X		while(fgets(buf,BUFSZ,fp))
X		    if(*buf == q) {
X			ep = index(buf, '\n');
X			if(ep) *ep = 0;
X			/* else: bad data file */
X			/* Expand tab 'by hand' */
X			if(buf[1] == '\t'){
X				buf = bufr;
X				buf[0] = q;
X				(void) strncpy(buf+1, "       ", 7);
X			}
X			pline(buf);
X			if(ep[-1] == ';') {
X				pline("More info? ");
X				if(readchar() == 'y') {
X					page_more(fp,1); /* does fclose() */
X					return(0);
X				}
X			}
X			(void) fclose(fp); 	/* kopper@psuvax1 */
X			return(0);
X		    }
X		pline("I've never heard of such things.");
X		(void) fclose(fp);
X	}
X	return(0);
X}
X
X/* make the paging of a file interruptible */
Xstatic int got_intrup;
X
Xintruph(){
X	got_intrup++;
X}
X
X/* simple pager, also used from dohelp() */
Xpage_more(fp,strip)
XFILE *fp;
Xint strip;	/* nr of chars to be stripped from each line (0 or 1) */
X{
X	register char *bufr, *ep;
X#ifdef DGK
X	/* There seems to be a bug in ANSI.SYS  The first tab character
X	 * after a clear screen sequence is not expanded correctly.  Thus
X	 * expand the tabs by hand -dgk
X	 */
X	int tabstop = 8, spaces;
X	char buf[BUFSIZ], *bufp, *bufrp;
X
X	set_pager(0);
X	bufr = (char *) alloc((unsigned) CO);
X	while (fgets(buf, BUFSIZ, fp) && (!strip || *buf == '\t')){
X		bufp = buf;
X		bufrp = bufr;
X		while (*bufp && *bufp != '\n') {
X			if (*bufp == '\t') {
X				spaces = tabstop - (bufrp - bufr) % tabstop;
X				while (spaces--)
X					*bufrp++ = ' ';
X				bufp++;
X			} else
X				*bufrp++ = *bufp++;
X		}
X		*bufrp = '\0';
X#else
X	int (*prevsig)() = signal(SIGINT, intruph);
X
X	set_pager(0);
X	bufr = (char *) alloc((unsigned) CO);
X	bufr[CO-1] = 0;
X	while(fgets(bufr,CO-1,fp) && (!strip || *bufr == '\t')){
X		ep = index(bufr, '\n');
X		if(ep)
X			*ep = 0;
X#endif /* DGK /**/
X		if(page_line(bufr+strip)) {
X			set_pager(2);
X			goto ret;
X		}
X	}
X	set_pager(1);
Xret:
X	free(bufr);
X	(void) fclose(fp);
X#ifndef DGK
X	(void) signal(SIGINT, prevsig);
X	got_intrup = 0;
X#endif
X}
X
Xstatic boolean whole_screen = TRUE;
X#define	PAGMIN	12	/* minimum # of lines for page below level map */
X
Xset_whole_screen() {	/* called in termcap as soon as LI is known */
X	whole_screen = (LI-ROWNO-2 <= PAGMIN || !CD);
X}
X
X#ifdef NEWS
Xreadnews() {
X	register int ret;
X
X	whole_screen = TRUE;	/* force a docrt(), our first */
X	ret = page_file(NEWS, TRUE);
X	set_whole_screen();
X	return(ret);		/* report whether we did docrt() */
X}
X#endif
X
Xset_pager(mode)
Xregister int mode;	/* 0: open  1: wait+close  2: close */
X{
X	static boolean so;
X	if(mode == 0) {
X		if(!whole_screen) {
X			/* clear topline */
X			clrlin();
X			/* use part of screen below level map */
X			curs(1, ROWNO+4);
X		} else {
X			cls();
X		}
X		so = flags.standout;
X		flags.standout = 1;
X	} else {
X		if(mode == 1) {
X			curs(1, LI);
X			more();
X		}
X		flags.standout = so;
X		if(whole_screen)
X			docrt();
X		else {
X			curs(1, ROWNO+4);
X			cl_eos();
X		}
X	}
X}
X
Xpage_line(s)		/* returns 1 if we should quit */
Xregister char *s;
X{
X	extern char morc;
X
X	if(cury == LI-1) {
X		if(!*s)
X			return(0);	/* suppress blank lines at top */
X		putchar('\n');
X		cury++;
X		cmore("q\033");
X		if(morc) {
X			morc = 0;
X			return(1);
X		}
X		if(whole_screen)
X			cls();
X		else {
X			curs(1, ROWNO+4);
X			cl_eos();
X		}
X	}
X	puts(s);
X	cury++;
X	return(0);
X}
X
X/*
X * Flexible pager: feed it with a number of lines and it will decide
X * whether these should be fed to the pager above, or displayed in a
X * corner.
X * Call:
X *	cornline(0, title or 0)	: initialize
X *	cornline(1, text)	: add text to the chain of texts
X *	cornline(2, morcs)	: output everything and cleanup
X *	cornline(3, 0)		: cleanup
X */
X
Xcornline(mode, text)
Xint mode;
Xchar *text;
X{
X	static struct line {
X		struct line *next_line;
X		char *line_text;
X	} *texthead, *texttail;
X	static int maxlen;
X	static int linect;
X	register struct line *tl;
X
X	if(mode == 0) {
X		texthead = 0;
X		maxlen = 0;
X		linect = 0;
X		if(text) {
X			cornline(1, text);	/* title */
X			cornline(1, "");	/* blank line */
X		}
X		return;
X	}
X
X	if(mode == 1) {
X	    register int len;
X
X	    if(!text) return;	/* superfluous, just to be sure */
X	    linect++;
X	    len = strlen(text);
X	    if(len > maxlen)
X		maxlen = len;
X	    tl = (struct line *)
X		alloc((unsigned)(len + sizeof(struct line) + 1));
X	    tl->next_line = 0;
X	    tl->line_text = (char *)(tl + 1);
X	    (void) strcpy(tl->line_text, text);
X	    if(!texthead)
X		texthead = tl;
X	    else
X		texttail->next_line = tl;
X	    texttail = tl;
X	    return;
X	}
X
X	/* --- now we really do it --- */
X	if(mode == 2 && linect == 1)			    /* topline only */
X		pline(texthead->line_text);
X	else
X	if(mode == 2) {
X	    register int curline, lth;
X
X	    if(flags.toplin == 1) more();	/* ab@unido */
X	    remember_topl();
X
X	    lth = CO - maxlen - 2;		   /* Use full screen width */
X	    if (linect < LI && lth >= 10) {		     /* in a corner */
X		home ();
X		cl_end ();
X		flags.toplin = 0;
X		curline = 1;
X		for (tl = texthead; tl; tl = tl->next_line) {
X		    curs (lth, curline);
X		    if(curline > 1)
X			cl_end ();
X		    putsym(' ');
X		    putstr (tl->line_text);
X		    curline++;
X		}
X		curs (lth, curline);
X		cl_end ();
X		cmore (text);
X		home ();
X		cl_end ();
X		docorner (lth, curline-1);
X	    } else {					/* feed to pager */
X		set_pager(0);
X		for (tl = texthead; tl; tl = tl->next_line) {
X		    if (page_line (tl->line_text)) {
X			set_pager(2);
X			goto cleanup;
X		    }
X		}
X		if(text) {
X			cgetret(text);
X			set_pager(2);
X		} else
X			set_pager(1);
X	    }
X	}
X
Xcleanup:
X	while(tl = texthead) {
X		texthead = tl->next_line;
X		free((char *) tl);
X	}
X}
X
Xdohelp()
X{
X	char c;
X
X	pline ("Long or short help? ");
X	while (((c = readchar ()) != 'l') && (c != 's') && !index(quitchars,c))
X		bell ();
X	if (!index(quitchars, c))
X		(void) page_file((c == 'l') ? HELP : SHELP, FALSE);
X	return(0);
X}
X
Xpage_file(fnam, silent)	/* return: 0 - cannot open fnam; 1 - otherwise */
Xregister char *fnam;
Xboolean silent;
X{
X#ifdef DEF_PAGER			/* this implies that UNIX is defined */
X      {
X	/* use external pager; this may give security problems */
X
X	register int fd = open(fnam, 0);
X
X	if(fd < 0) {
X		if(!silent) pline("Cannot open %s.", fnam);
X		return(0);
X	}
X	if(child(1)){
X		extern char *catmore;
X
X		/* Now that child() does a setuid(getuid()) and a chdir(),
X		   we may not be able to open file fnam anymore, so make
X		   it stdin. */
X		(void) close(0);
X		if(dup(fd)) {
X			if(!silent) printf("Cannot open %s as stdin.\n", fnam);
X		} else {
X			execl(catmore, "page", (char *) 0);
X			if(!silent) printf("Cannot exec %s.\n", catmore);
X		}
X		exit(1);
X	}
X	(void) close(fd);
X      }
X#else
X      {
X	FILE *f;			/* free after Robert Viduya */
X
X	if ((f = fopen (fnam, "r")) == (FILE *) 0) {
X		if(!silent) {
X			home(); perror (fnam); flags.toplin = 1;
X			pline ("Cannot open %s.", fnam);
X		}
X		return(0);
X	}
X	page_more(f, 0);
X      }
X#endif /* DEF_PAGER /**/
X
X	return(1);
X}
X
X#ifdef UNIX
X#ifdef SHELL
Xdosh(){
Xregister char *str;
X	if(child(0)) {
X		if(str = getenv("SHELL"))
X			execl(str, str, (char *) 0);
X		else
X			execl("/bin/sh", "sh", (char *) 0);
X		pline("sh: cannot execute.");
X		exit(1);
X	}
X	return(0);
X}
X#endif /* SHELL /**/
X
X#ifdef NOWAITINCLUDE
Xunion wait {		/* used only for the cast  (union wait *) 0  */
X	int w_status;
X	struct {
X		unsigned short w_Termsig:7;
X		unsigned short w_Coredump:1;
X		unsigned short w_Retcode:8;
X	} w_T;
X};
X
X#else
X
X#ifdef BSD
X#include	<sys/wait.h>
X#else
X#include	<wait.h>
X#endif
X#endif /* NOWAITINCLUDE /**/
X
Xchild(wt) {
Xregister int f = fork();
X	if(f == 0){		/* child */
X		settty((char *) 0);		/* also calls end_screen() */
X		(void) setuid(getuid());
X		(void) setgid(getgid());
X#ifdef CHDIR
X		(void) chdir(getenv("HOME"));
X#endif
X		return(1);
X	}
X	if(f == -1) {	/* cannot fork */
X		pline("Fork failed. Try again.");
X		return(0);
X	}
X	/* fork succeeded; wait for child to exit */
X	(void) signal(SIGINT,SIG_IGN);
X	(void) signal(SIGQUIT,SIG_IGN);
X	(void) wait((union wait *) 0);
X	gettty();
X	setftty();
X	(void) signal(SIGINT,done1);
X#ifdef WIZARD
X	if(wizard) (void) signal(SIGQUIT,SIG_DFL);
X#endif
X	if(wt) getret();
X	docrt();
X	return(0);
X}
X#endif /* UNIX /**/
END_OF_pager.c
if test 8734 -ne `wc -c <pager.c`; then
    echo shar: \"pager.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f prisym.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"prisym.c\"
else
echo shar: Extracting \"prisym.c\" \(7614 characters\)
sed "s/^X//" >prisym.c <<'END_OF_prisym.c'
X/*	SCCS Id: @(#)prisym.c	1.3	87/07/14
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* prisym.c - version 1.0 */
X
X#include <stdio.h>
X#include "hack.h"
X
Xextern xchar scrlx, scrhx, scrly, scrhy; /* corners from pri.c */
X
Xatl(x,y,ch)
Xregister x,y;
X{
X	register struct rm *crm = &levl[x][y];
X
X	if(x<0 || x>COLNO-1 || y<0 || y>ROWNO-1){
X		impossible("atl(%d,%d,%c)",x,y,ch);
X		return;
X	}
X	if(crm->seen && crm->scrsym == ch) return;
X	crm->scrsym = ch;
X	crm->new = 1;
X	on_scr(x,y);
X}
X
Xon_scr(x,y)
Xregister x,y;
X{
X	if(x < scrlx) scrlx = x;
X	if(x > scrhx) scrhx = x;
X	if(y < scrly) scrly = y;
X	if(y > scrhy) scrhy = y;
X}
X
X/* call: (x,y) - display
X	(-1,0) - close (leave last symbol)
X	(-1,-1)- close (undo last symbol)
X	(-1,let)-open: initialize symbol
X	(-2,let)-change let
X*/
X
Xtmp_at(x,y) schar x,y; {
Xstatic schar prevx, prevy;
Xstatic char let;
X	if((int)x == -2){	/* change let call */
X		let = y;
X		return;
X	}
X	if((int)x == -1 && (int)y >= 0){	/* open or close call */
X		let = y;
X		prevx = -1;
X		return;
X	}
X	if(prevx >= 0 && cansee(prevx,prevy)) {
X		delay_output();
X		prl(prevx, prevy);	/* in case there was a monster */
X		at(prevx, prevy, levl[prevx][prevy].scrsym);
X	}
X	if(x >= 0){	/* normal call */
X		if(cansee(x,y)) at(x,y,let);
X		prevx = x;
X		prevy = y;
X	} else {	/* close call */
X		let = 0;
X		prevx = -1;
X	}
X}
X
X/* like the previous, but the symbols are first erased on completion */
XTmp_at(x,y) schar x,y; {
Xstatic char let;
Xstatic xchar cnt;
Xstatic coord tc[COLNO];		/* but watch reflecting beams! */
Xregister xx,yy;
X	if((int)x == -1) {
X		if(y > 0) {	/* open call */
X			let = y;
X			cnt = 0;
X			return;
X		}
X		/* close call (do not distinguish y==0 and y==-1) */
X		while(cnt--) {
X			xx = tc[cnt].x;
X			yy = tc[cnt].y;
X			prl(xx, yy);
X			at(xx, yy, levl[xx][yy].scrsym);
X		}
X		cnt = let = 0;	/* superfluous */
X		return;
X	}
X	if((int)x == -2) {	/* change let call */
X		let = y;
X		return;
X	}
X	/* normal call */
X	if(cansee(x,y)) {
X		if(cnt) delay_output();
X		at(x,y,let);
X		tc[cnt].x = x;
X		tc[cnt].y = y;
X		if(++cnt >= COLNO) panic("Tmp_at overflow?");
X		levl[x][y].new = 0;	/* prevent pline-nscr erasing --- */
X	}
X}
X
Xcurs_on_u(){
X	curs(u.ux, u.uy+2);
X}
X
Xpru()
X{
X	if(u.udispl && (Invisible || u.udisx != u.ux || u.udisy != u.uy))
X		/* if(! levl[u.udisx][u.udisy].new) */
X			if(!vism_at(u.udisx, u.udisy))
X				newsym(u.udisx, u.udisy);
X	if(Invisible) {
X		u.udispl = 0;
X		prl(u.ux,u.uy);
X	} else
X	if(!u.udispl || u.udisx != u.ux || u.udisy != u.uy) {
X		atl(u.ux, u.uy, u.usym);
X		u.udispl = 1;
X		u.udisx = u.ux;
X		u.udisy = u.uy;
X	}
X	levl[u.ux][u.uy].seen = 1;
X}
X
X#ifndef NOWORM
X#include	"wseg.h"
Xextern struct wseg *m_atseg;
X#endif
X
X/* print a position that is visible for @ */
Xprl(x,y)
X{
X	register struct rm *room;
X	register struct monst *mtmp;
X	register struct obj *otmp;
X	register struct trap *ttmp;
X
X	if(x == u.ux && y == u.uy && (!Invisible)) {
X		pru();
X		return;
X	}
X	if(!isok(x,y)) return;
X	room = &levl[x][y];
X	if((!room->typ) ||
X	   (IS_ROCK(room->typ) && levl[u.ux][u.uy].typ == CORR))
X		return;
X	if((mtmp = m_at(x,y)) && !mtmp->mhide &&
X		(!mtmp->minvis || See_invisible)) {
X#ifndef NOWORM
X		if(m_atseg)
X			pwseg(m_atseg);
X		else
X#endif
X		pmon(mtmp);
X	}
X	else if((otmp = o_at(x,y)) && room->typ != POOL)
X		atl(x,y,Hallucination ? rndobjsym() : otmp->olet);
X#ifdef SPIDERS
X	else if((!mtmp || mtmp->data == PM_SPIDER) &&
X		  (ttmp = t_at(x,y)) && ttmp->ttyp == WEB)
X		atl(x,y,WEB_SYM);
X#endif
X	else if(mtmp && (!mtmp->minvis || See_invisible)) {
X		/* must be a hiding monster, but not hiding right now */
X		/* assume for the moment that long worms do not hide */
X		pmon(mtmp);
X	}
X	else if(g_at(x,y) && room->typ != POOL)
X		atl(x,y,Hallucination ? rndobjsym() : '$');
X	else if(!room->seen || room->scrsym == ' ') {
X		room->new = room->seen = 1;
X		newsym(x,y);
X		on_scr(x,y);
X	}
X	room->seen = 1;
X}
X
Xchar
Xnews0(x,y)
Xregister xchar x,y;
X{
X	register struct obj *otmp;
X	register struct trap *ttmp;
X	struct rm *room;
X	register char tmp;
X
X	room = &levl[x][y];
X	if(!room->seen) tmp = ' ';
X	else if(room->typ == POOL) tmp = POOL_SYM;
X	else if(!Blind && (otmp = o_at(x,y)))
X		tmp = Hallucination ? rndobjsym() : otmp->olet;
X	else if(!Blind && g_at(x,y))
X		tmp = Hallucination ? rndobjsym() : '$';
X	else if(x == xupstair && y == yupstair) tmp = '<';
X	else if(x == xdnstair && y == ydnstair) tmp = '>';
X#ifdef SPIDERS
X	else if((ttmp = t_at(x,y)) && ttmp->ttyp == WEB) tmp = WEB_SYM;
X	else if(ttmp && ttmp->tseen) tmp ='^';
X#else
X	else if((ttmp = t_at(x,y)) && ttmp->tseen) tmp = '^';
X#endif
X	else switch(room->typ) {
X	case SCORR:
X	case SDOOR:
X		tmp = room->scrsym;	/* %% wrong after killing mimic ! */
X		break;
X#ifdef DGK
X	case HWALL:
X		tmp = room->scrsym;	/* OK for corners only */
X		if (!IS_CORNER(tmp))
X			tmp = symbol.hwall;
X		break;
X	case VWALL:
X		tmp = symbol.vwall;
X		break;
X	case LDOOR:
X	case DOOR:
X		tmp = symbol.door;
X		break;
X	case CORR:
X		tmp = symbol.corr;
X		break;
X	case ROOM:
X		if(room->lit || cansee(x,y) || Blind) tmp = symbol.room;
X		else tmp = ' ';
X		break;
X#else
X	case HWALL:
X		tmp = '-';
X		break;
X	case VWALL:
X		tmp = '|';
X		break;
X	case LDOOR:
X	case DOOR:
X		tmp = '+';
X		break;
X	case CORR:
X		tmp = CORR_SYM;
X		break;
X	case ROOM:
X		if(room->lit || cansee(x,y) || Blind) tmp = '.';
X		else tmp = ' ';
X		break;
X#endif
X#ifdef FOUNTAINS
X	case FOUNTAIN:
X		tmp = FOUNTAIN_SYM;
X		break;
X#endif
X#ifdef NEWCLASS
X	case THRONE:
X		tmp = THRONE_SYM;
X		break;
X#endif
X/*
X	case POOL:
X		tmp = POOL_SYM;
X		break;
X*/
X	default:
X		tmp = ERRCHAR;
X	}
X	return(tmp);
X}
X
Xnewsym(x,y)
Xregister x,y;
X{
X	atl(x,y,news0(x,y));
X}
X
X/* used with wand of digging (or pick-axe): fill scrsym and force display */
X/* also when a POOL evaporates */
Xmnewsym(x,y)
Xregister x,y;
X{
X	register struct rm *room;
X	char newscrsym;
X
X	if(!vism_at(x,y)) {
X		room = &levl[x][y];
X		newscrsym = news0(x,y);
X		if(room->scrsym != newscrsym) {
X			room->scrsym = newscrsym;
X			room->seen = 0;
X		}
X	}
X}
X
Xnosee(x,y)
Xregister x,y;
X{
X	register struct rm *room;
X
X	if(!isok(x,y)) return;
X	room = &levl[x][y];
X#ifdef DGK
X	if(room->scrsym == symbol.room && !room->lit && !Blind) {
X#else
X	if(room->scrsym == '.' && !room->lit && !Blind) {
X#endif
X		room->scrsym = ' ';
X		room->new = 1;
X		on_scr(x,y);
X	}
X}
X
X#ifndef QUEST
Xprl1(x,y)
Xregister x,y;
X{
X	if(u.dx) {
X		if(u.dy) {
X			prl(x-(2*u.dx),y);
X			prl(x-u.dx,y);
X			prl(x,y);
X			prl(x,y-u.dy);
X			prl(x,y-(2*u.dy));
X		} else {
X			prl(x,y-1);
X			prl(x,y);
X			prl(x,y+1);
X		}
X	} else {
X		prl(x-1,y);
X		prl(x,y);
X		prl(x+1,y);
X	}
X}
X
Xnose1(x,y)
Xregister x,y;
X{
X	if(u.dx) {
X		if(u.dy) {
X			nosee(x,u.uy);
X			nosee(x,u.uy-u.dy);
X			nosee(x,y);
X			nosee(u.ux-u.dx,y);
X			nosee(u.ux,y);
X		} else {
X			nosee(x,y-1);
X			nosee(x,y);
X			nosee(x,y+1);
X		}
X	} else {
X		nosee(x-1,y);
X		nosee(x,y);
X		nosee(x+1,y);
X	}
X}
X#endif /* QUEST /**/
X
Xvism_at(x,y)
Xregister x,y;
X{
X	register struct monst *mtmp;
X
X	if(x == u.ux && y == u.uy && !Invisible) return(1);
X
X	if(mtmp = m_at(x,y)) return((Blind && Telepat) || canseemon(mtmp));
X
X	return(0);
X}
X
X#ifdef NEWSCR
Xpobj(obj) register struct obj *obj; {
Xregister int show = (!obj->oinvis || See_invisible) &&
X		cansee(obj->ox,obj->oy);
X	if(obj->odispl){
X		if(obj->odx != obj->ox || obj->ody != obj->oy || !show)
X		if(!vism_at(obj->odx,obj->ody)){
X			newsym(obj->odx, obj->ody);
X			obj->odispl = 0;
X		}
X	}
X	if(show && !vism_at(obj->ox,obj->oy)){
X		atl(obj->ox,obj->oy,obj->olet);
X		obj->odispl = 1;
X		obj->odx = obj->ox;
X		obj->ody = obj->oy;
X	}
X}
X#endif /* NEWSCR /**/
X
Xunpobj(obj) register struct obj *obj; {
X/* 	if(obj->odispl){
X		if(!vism_at(obj->odx, obj->ody))
X			newsym(obj->odx, obj->ody);
X		obj->odispl = 0;
X	}
X*/
X	if(!vism_at(obj->ox,obj->oy))
X		newsym(obj->ox,obj->oy);
X}
END_OF_prisym.c
if test 7614 -ne `wc -c <prisym.c`; then
    echo shar: \"prisym.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
echo shar: End of archive 12 \(of 16\).
cp /dev/null ark12isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 16 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit.o:
