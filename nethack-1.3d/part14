Relay-Version: version B 2.10 5/3/83; site utzoo.UUCP
Path: utzoo!mnetor!uunet!seismo!columbia!rutgers!sri-spam!ames!ucbcad!ucbvax!decvax!tektronix!tekgen!tekred!games-request
From: games-request@tekred.TEK.COM
Newsgroups: comp.sources.games
Subject: v02i014:  nethack - display oriented dungeons & dragons, Part14/16
Message-ID: <1456@tekred.TEK.COM>
Date: Tue, 28-Jul-87 14:54:02 EDT
Article-I.D.: tekred.1456
Posted: Tue Jul 28 14:54:02 1987
Date-Received: Thu, 30-Jul-87 07:26:31 EDT
Sender: billr@tekred.TEK.COM
Lines: 2061
Approved: billr@tekred.TEK.COM

Submitted by: mike@genat.UUCP (Mike Stephenson)
Comp.sources.games: Volume 2, Issue 14
Archive-name: nethack/Part14



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 14 (of 16)."
# Contents:  Makefile.unix help ioctl.c nethack.6 o_init.c polyself.c
#   shknam.c steal.c unixtty.c worm.c
# Wrapped by billr@tekred on Tue Jul 28 09:49:47 1987
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f Makefile.unix -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"Makefile.unix\"
else
echo shar: Extracting \"Makefile.unix\" \(6967 characters\)
sed "s/^X//" >Makefile.unix <<'END_OF_Makefile.unix'
X#	Hack or Quest Makefile.
X#	SCCS Id: @(#)Makefile.unix	1.3	87/07/14
X
X# if you are cross-compiling (eg. from Xenix into a Dos enviornment)
X# you will have to redefine these filenames.
XMAIN = unixmain.c
XTTY  = unixtty.c
XUNIX = unixunix.c
X
X# on some systems the termcap library is in -ltermcap
XTERMLIB = -ltermlib
X
X# make NetHack
XGAME = nethack
XGAMEUID = games
XGAMEGRP = bin
X#	GAMEDIR also appears in config.h as "HACKDIR".
XGAMEDIR = /usr/games/lib/$(GAME)dir
XSHELLDIR = /usr/games
XMANDIR  = /usr/man/man6
XCFLAGS = -O
XLFLAGS = -X
X
XHACKCSRC = alloc.c apply.c bones.c cmd.c decl.c do.c do_name.c do_wear.c\
X	dog.c dogmove.c dothrow.c eat.c end.c engrave.c fight.c fountain.c\
X	hack.c invent.c ioctl.c lev.c main.c makemon.c mhitu.c\
X	mklev.c mkmaze.c mkobj.c mkshop.c mon.c monmove.c monst.c o_init.c\
X	objnam.c options.c pager.c polyself.c potion.c pray.c pri.c\
X	prisym.c read.c rip.c rnd.c rumors.c save.c search.c shk.c shknam.c\
X	sit.c spell.c steal.c termcap.c timeout.c topl.c topten.c track.c\
X	trap.c tty.c u_init.c unix.c vault.c version.c wield.c wizard.c\
X	worm.c worn.c write.c zap.c
X
XCSOURCES = $(HACKCSRC) makedefs.c
X
XHSOURCES = hack.h mfndpos.h config.h edog.h eshk.h extern.h\
X	flag.h func_tab.h gold.h mkroom.h monst.h obj.h objclass.h\
X	objects.h permonst.h rm.h spell.h trap.h wseg.h you.h
X
XSOURCES = $(CSOURCES) $(HSOURCES)
X
XAUX = help hh nethack.6 nethack.sh
XVARAUX = data rumors
X
XDISTR = $(SOURCES) $(AUX) $(VARAUX) README.OLD README\
X	Makefile Makefile.pc Make.ini
X
XHOBJ = alloc.o apply.o bones.o cmd.o decl.o do.o do_name.o do_wear.o\
X	dog.o dogmove.o dothrow.o eat.o end.o engrave.o fight.o fountain.o\
X	hack.o invent.o ioctl.o lev.o main.o makemon.o mhitu.o\
X	mklev.o mkmaze.o mkobj.o mkshop.o mon.o monmove.o monst.o o_init.o\
X	objnam.o options.o pager.o polyself.o potion.o pray.o pri.o\
X	prisym.o read.o rip.o rnd.o rumors.o save.o search.o shk.o shknam.o\
X	sit.o spell.o steal.o termcap.o timeout.o topl.o topten.o track.o\
X	trap.o tty.o u_init.o unix.o vault.o version.o wield.o wizard.o\
X	worm.o worn.o write.o zap.o
X
X$(GAME):	specifics $(HOBJ) Makefile
X	@echo "Loading ..."
X	@ld $(LFLAGS) -o $(GAME) /lib/crt0.o $(HOBJ) $(TERMLIB) -lc
X
Xall:	$(GAME) lint
X	@echo "Done."
X
Xmakedefs:	makedefs.c alloc.o config.h
X	cc -o makedefs alloc.o makedefs.c
X
XRUMORFILES= rumors.base rumors.kaa rumors.mrx
X
Xrumors:	config.h $(RUMORFILES) makedefs
X	makedefs -r
X
Xdata:	config.h data.base makedefs
X	makedefs -d
X
Xdate.h:	$(SOURCES) makedefs
X	makedefs -D
X
Xtrap.h:	config.h makedefs
X	makedefs -t
X
Xonames.h:	makedefs objects.h
X	makedefs -o
X
Xspecifics:	main.o tty.o unix.o
X
Xmain.o:
X
Xmain.c:	unixmain.c hack.h
X	cp $(MAIN) main.c
X
Xtty.o:
X
Xtty.c:	unixtty.c extern.h
X	cp $(TTY) tty.c
X
Xunix.o:
X
Xunix.c:	unixunix.c hack.h mkroom.h
X	cp $(UNIX) unix.c
X
Xlint:
X# lint cannot have -p here because (i) capitals are meaningful:
X# [Ww]izard, (ii) identifiers may coincide in the first six places:
X# doweararm() versus dowearring().
X# _flsbuf comes from <stdio.h>, a bug in the system libraries.
X	@echo lint -axbh -DLINT ...
X	@lint -axbh -DLINT $(HACKCSRC) | sed '/_flsbuf/d'
X
X
Xdiff:
X	@- for i in $(SOURCES) $(AUX) ; do \
X		cmp -s $$i $D/$$i || \
X		( echo diff $D/$$i $$i ; diff $D/$$i $$i ; echo ) ; done
X
Xdistribution: Makefile
X	@- for i in READ_ME $(SOURCES) $(AUX) Makefile date.h onames.h\
X		; do \
X		cmp -s $$i $D/$$i || \
X		( echo cp $$i $D ; cp $$i $D ) ; done
X# the distribution directory also contains the empty files perm and record.
X
Xinitial:
X	-rm -rf $(GAMEDIR)
X	-mkdir $(SHELLDIR)
X	mkdir $(GAMEDIR) $(GAMEDIR)/save
X	touch $(GAMEDIR)/perm
X	touch $(GAMEDIR)/record
X	chown $(GAMEUID) $(GAMEDIR) $(GAMEDIR)/*
X	chgrp $(GAMEGRP) $(GAMEDIR) $(GAMEDIR)/*
X	chmod 666 $(GAMEDIR)/*
X	chmod 777 $(GAMEDIR) $(GAMEDIR)/save
X
Xinstall: $(VARAUX)
X	-rm -f $(GAMEDIR)/$(GAME)
X	-rm -f $(GAMEDIR)/bones*
X	-rm -f $(GAMEDIR)/save/*
X	cp help hh rumors data $(GAMEDIR)
X	cp $(GAME).sh $(SHELLDIR)/$(GAME)
X	cp $(GAME) $(GAMEDIR)/$(GAME)
X	chown $(GAMEUID) $(SHELLDIR)/$(GAME) $(GAMEDIR)/*
X	chgrp $(GAMEGRP) $(SHELLDIR)/$(GAME) $(GAMEDIR)/*
X	chmod 0755 $(SHELLDIR)/$(GAME)
X	chmod 04755 $(GAMEDIR)/$(GAME)
X	-cp nethack.6 $(MANDIR)
X
Xclean:
X	rm -f *.o
X
Xspotless: clean
X	rm -f a.out core $(GAME) makedefs
X	rm -f Makefile $(VARAUX) main.c tty.c unix.c
X
Xdepend:
X# For the moment we are lazy and disregard /usr/include files because
X# the sources contain them conditionally. Perhaps we should use cpp.
X#		( /bin/grep '^#[ 	]*include' $$i | sed -n \
X#			-e 's,<\(.*\)>,"/usr/include/\1",' \
X#
X	for i in ${CSOURCES}; do \
X		( /bin/grep '^#[ 	]*include[ 	]*"' $$i | sed -n \
X			-e 's/[^"]*"\([^"]*\)".*/\1/' \
X			-e H -e '$$g' -e '$$s/\n/ /g' \
X			-e '$$s/.*/'$$i': &/' -e '$$s/\.c:/.o:/p' \
X			>> makedep); done
X	for i in ${HSOURCES}; do \
X		( /bin/grep '^#[ 	]*include[ 	]*"' $$i | sed -n \
X			-e 's/[^"]*"\([^"]*\)".*/\1/' \
X			-e H -e '$$g' -e '$$s/\n/ /g' \
X			-e '$$s/.*/'$$i': &\
X				touch '$$i/p \
X			>> makedep); done
X	@echo '/^# DO NOT DELETE THIS LINE/+2,$$d' >eddep
X	@echo '$$r makedep' >>eddep
X	@echo 'w' >>eddep
X	@cp Makefile Makefile.bak
X	ed - Makefile < eddep
X	@rm -f eddep makedep
X	@echo '# DEPENDENCIES MUST END AT END OF FILE' >> Makefile
X	@echo '# IF YOU PUT STUFF HERE IT WILL GO AWAY' >> Makefile
X	@echo '# see make depend above' >> Makefile
X	- diff Makefile Makefile.bak
X	@rm -f Makefile.bak
X
X# DO NOT DELETE THIS LINE
X
Xdecl.o:  hack.h mkroom.h
Xapply.o:  hack.h edog.h mkroom.h
Xbones.o:  hack.h
Xhack.o:  hack.h
Xcmd.o:  hack.h func_tab.h
Xdo.o:  hack.h
Xdo_name.o:  hack.h
Xdo_wear.o:  hack.h
Xdog.o:  hack.h edog.h mkroom.h
Xdogmove.o:  hack.h mfndpos.h edog.h mkroom.h
Xdothrow.o:  hack.h
Xeat.o:  hack.h
Xend.o:  hack.h
Xengrave.o:  hack.h
Xfight.o:  hack.h
Xfountain.o:  hack.h
Xinvent.o:  hack.h wseg.h
Xioctl.o:  config.h
Xlev.o:  hack.h mkroom.h wseg.h
Xmakemon.o:  hack.h
Xmhitu.o:  hack.h
Xmklev.o:  hack.h mkroom.h
Xmkmaze.o:  hack.h mkroom.h
Xmkobj.o:  hack.h
Xmkshop.o:  hack.h mkroom.h eshk.h
Xmon.o:  hack.h mfndpos.h
Xmonmove.o:  hack.h mfndpos.h
Xmonst.o:  hack.h eshk.h
Xo_init.o:  config.h objects.h onames.h
Xobjnam.o:  hack.h
Xoptions.o:  config.h hack.h
Xpager.o:  hack.h
Xpolyself.o: hack.h
Xpotion.o:  hack.h
Xpray.o:  hack.h
Xpri.o:  hack.h
Xprisym.o:  hack.h wseg.h
Xread.o:  hack.h
Xrip.o:  hack.h
Xrumors.o:  hack.h
Xsave.o:  hack.h
Xsearch.o:  hack.h
Xshk.o:  hack.h mfndpos.h mkroom.h eshk.h
Xshknam.o:  hack.h
Xsit.o: hack.h
Xspell.o:  hack.h
Xsteal.o:  hack.h
Xtermcap.o:  config.h flag.h
Xtimeout.o:  hack.h
Xtopl.o:  hack.h
Xtopten.o:  hack.h
Xtrack.o:  hack.h
Xtrap.o:  hack.h mkroom.h
Xu_init.o:  hack.h
Xvault.o:  hack.h mkroom.h
Xwield.o:  hack.h
Xwizard.o:  hack.h
Xworm.o:  hack.h wseg.h
Xworn.o:  hack.h
Xwrite.o:  hack.h
Xzap.o:  hack.h
Xversion.o:  hack.h date.h
Xextern.h: config.h spell.h obj.h you.h
X	touch extern.h
Xhack.h:  config.h objclass.h monst.h gold.h trap.h obj.h flag.h rm.h permonst.h spell.h onames.h extern.h you.h
X	touch hack.h
Xobjects.h:  config.h objclass.h
X	touch objects.h
X# DEPENDENCIES MUST END AT END OF FILE
X# IF YOU PUT STUFF HERE IT WILL GO AWAY
X# see make depend above
END_OF_Makefile.unix
if test 6967 -ne `wc -c <Makefile.unix`; then
    echo shar: \"Makefile.unix\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f help -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"help\"
else
echo shar: Extracting \"help\" \(5443 characters\)
sed "s/^X//" >help <<'END_OF_help'
X	Welcome to NetHack!		   ( description of version 1.0 )
X
X	NetHack is a Dungeons and Dragons like game where you (the adventurer)
Xdescend into the depths of the dungeon in search of the Amulet of Yendor
X(reputed to be hidden on the twentieth level).	You are accompanied by a
Xlittle dog that can help you in many ways and can be trained to do all
Xsorts of things. On the way you will find useful (or useless) items, (quite
Xpossibly with magic properties) and assorted monsters.	You attack a monster
Xby trying to move into the space a monster is in (but often it is much
Xwiser to leave it alone).
X
X	Unlike most adventure games, which give you a verbal description of
Xyour location, hack gives you a visual image of the dungeon level you are on.
X
X	Hack uses the following symbols:
X		A to Z and a to z:  monsters.  You can find out what a letter
Xrepresents by saying "/ (letter)", as in "/A", which will tell you that 'A'
Xis a giant ant.
X		- and |	 These form the walls of a room (or maze).
X		.  this is the floor of a room.
X		#  this is a corridor.
X		>  this is the staircase to the next level.
X		<  the staircase to the previous level.
X		`  A large boulder.
X		@  You (usually).
X		^  A trap.
X		)  A weapon of some sort.
X		(  Some other useful object (key, rope, dynamite, camera, ...)
X		[  A suit of armor.
X		%  A piece of food (not necessarily healthy ...).
X		/  A wand.
X		=  A ring.
X		?  A scroll.
X		!  A magic potion.
X		+  A spellbook containing a spell you can learn;
X		   (but usually a doorway).
X		}  A pool of water
X		{  A fountain (your dungeon may not have these).
X		\  An opulant throne (You may not have this either).
X		$  A pile or pot of gold.
X
XCommands:
X	Hack knows the following commands:
X	?	help: print this list.
X	Q	Quit the game.
X	S	Save the game.
X	!	Escape to a shell.
X	^Z	Suspend the game.
X	<	up: go up the staircase (if you are standing on it).
X	>	down: go down (just like up).
X	kjhlyubn - go one step in the direction indicated.
X		k: north (i.e., to the top of the screen),
X		j: south, h: west, l: east, y: ne, u: nw, b: se, n: sw.
X	KJHLYUBN - Go in that direction until you hit a wall or run
X		into something.
X	m	(followed by one of kjhlyubn): move without picking up
X		any objects.
X	M	(followed by one of KJHLYUBN): Move far, no pickup.
X	g	(followed by one of kjhlyubn): move until something
X		interesting is found.
X	G	(followed by one of KJHLYUBN): as previous, but forking
X		of corridors is not considered interesting.
X	i	print your inventory.
X	I	print selected parts of your inventory, like in
X		I* - print all gems in inventory;
X		IU - print all unpaid items;
X		IX - print all used up items that are on your shopping bill;
X		I$ - count your money.
X	s	search for secret doors and traps around you.
X	^	ask for the type of a trap you found earlier.
X	)	ask for current wielded weapon.
X	[	ask for current armor.
X	=	ask for current rings.
X	$	count how many gold pieces you are carrying.
X	.	rest, do nothing.
X	,	pick up some things.
X	:	look at what is here.
X	^T	teleport.
X	^R	redraw the screen.
X	^P	repeat last message
X		(subsequent ^P's repeat earlier messages).
X	/	(followed by any symbol): tell what this symbol represents.
X	\	tell what has been discovered.
X	e	eat food.
X	w	wield weapon. w- means: wield nothing, use bare hands.
X	q	drink (quaff) a potion.
X	r	read a scroll.
X	T	Takeoff armor.
X	R	Remove Ring.
X	W	Wear armor.
X	P	Put on a ring.
X	X	transcribe (learn) a spell.
X	x	print a list of know spells.
X	z	zap a wand.
X	t	throw an object or shoot an arrow.
X	p	pay your shopping bill.
X	d	drop something. d7a: drop seven items of object a.
X	D	Drop several things.
X		In answer to the question "What kinds of things do you
X		want to drop? [!%= au]" you should give zero or more
X		object symbols possibly followed by 'a' and/or 'u'.
X		'a' means: drop all such objects, without asking for
X			confirmation.
X		'u' means: drop only unpaid objects (when in a shop).
X	a	use, apply - Generic command for using a key to lock
X		or unlock a door, using a camera, using a rope, etc.
X	c	call: name a certain object or class of objects.
X	C	Call: Name an individual monster.
X	E	Engrave: Write a message in the dust on the floor.
X		E- means: use fingers for writing.
X	O	Set options. You will be asked to enter an option line.
X		If this is empty, the current options are reported.
X		Otherwise it should be a list of options separated by commas.
X		Possible boolean options are: oneline, time, news, tombstone,
X		rest_on_space, fixinvlet, beginner, male, female.
X		They can be negated by prefixing them with '!' or "no".
X		A string option is name; it supplies the answer to the question
X		"Who are you?"; it may have a suffix.
X		A compound option is endgame; it is followed by a description
X		of what parts of the list of topscorers should be printed
X		when the game is finished.
X		Usually one will not want to use the 'O' command, but instead
X		put a HACKOPTIONS="...." line in one's environment.
X	v	print version number.
X
X	You can put a number before a command to repeat it that many times,
X	as in "20s" or "40.".
X
X	At present, some information is displayed on the bottom line.
X	You see on what dungeon level you are, how many hit points you have
X	now (and will have when fully recovered), what your armor class is
X	(the lower the better), your strength, experience level and the
X	state of your stomach.	Optionally, you may or may not see other
X	information such as magical energy, how much gold you have, etc.
X
X	Have Fun, and Good Hacking!
X
X
X
END_OF_help
if test 5443 -ne `wc -c <help`; then
    echo shar: \"help\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f ioctl.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"ioctl.c\"
else
echo shar: Extracting \"ioctl.c\" \(1363 characters\)
sed "s/^X//" >ioctl.c <<'END_OF_ioctl.c'
X/*	SCCS Id: @(#)ioctl.c	1.3	87/07/14
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* hack.ioctl.c - version 1.0.2 */
X
X/* This cannot be part of hack.tty.c (as it was earlier) since on some
X   systems (e.g. MUNIX) the include files <termio.h> and <sgtty.h>
X   define the same constants, and the C preprocessor complains. */
X#include <stdio.h>
X#include "config.h"
X#ifdef BSD
X#include	<sgtty.h>
Xstruct ltchars ltchars, ltchars0;
X#else
X#include	<termio.h>	/* also includes part of <sgtty.h> */
Xstruct termio termio;
X#endif
X
Xgetioctls() {
X#ifdef BSD
X	(void) ioctl(fileno(stdin), (int) TIOCGLTC, (char *) &ltchars);
X	(void) ioctl(fileno(stdin), (int) TIOCSLTC, (char *) &ltchars0);
X#else
X	(void) ioctl(fileno(stdin), (int) TCGETA, &termio);
X#endif
X}
X
Xsetioctls() {
X#ifdef BSD
X	(void) ioctl(fileno(stdin), (int) TIOCSLTC, (char *) &ltchars);
X#else
X	(void) ioctl(fileno(stdin), (int) TCSETA, &termio);
X#endif
X}
X
X#ifdef SUSPEND		/* implies BSD */
Xdosuspend() {
X#include	<signal.h>
X#ifdef SIGTSTP
X	if(signal(SIGTSTP, SIG_IGN) == SIG_DFL) {
X		settty((char *) 0);
X		(void) signal(SIGTSTP, SIG_DFL);
X		(void) kill(0, SIGTSTP);
X		gettty();
X		setftty();
X		docrt();
X	} else {
X		pline("I don't think your shell has job control.");
X	}
X#else SIGTSTP
X	pline("Sorry, it seems we have no SIGTSTP here. Try ! or S.");
X#endif
X	return(0);
X}
X#endif /* SUSPEND /**/
END_OF_ioctl.c
if test 1363 -ne `wc -c <ioctl.c`; then
    echo shar: \"ioctl.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f nethack.6 -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"nethack.6\"
else
echo shar: Extracting \"nethack.6\" \(4636 characters\)
sed "s/^X//" >nethack.6 <<'END_OF_nethack.6'
X.TH NETHACK 6 "7 March 1987"
X.UC 4
X.SH NAME
Xhack \- Exploring The Dungeons of Doom
X.SH SYNOPSIS
X.B /usr/games/nethack
X.B /usr/games/netquest
X[
X.B \-d
X.I directory
X]
X[
X.B \-n
X]
X[
X.B \-u
X.I playername
X]
X.br
X.B /usr/games/nethack
X.B /usr/games/netquest
X[
X.B \-d
X.I directory
X]
X.B \-s
X[
X.B \-X
X]
X[
X.I playernames
X]
X.SH DESCRIPTION
X.PP
X.I NetHack
Xis a display oriented dungeons & dragons - like game.
XBoth display and command structure resemble rogue.
X(For a game with the same structure but entirely different display -
Xa real cave instead of dull rectangles - try NetQuest.)
X.PP
XTo get started you really only need to know two commands.  The command
X.B ?
Xwill give you a list of the available commands and the command
X.B /
Xwill identify the things you see on the screen.
X.PP
XTo win the game (as opposed to merely playing to beat other people high
Xscores) you must locate the Amulet of Yendor which is somewhere below
Xthe 20th level of the dungeon and get it out.  Nobody has achieved this
Xyet and if somebody does, he will probably go down in history as a hero
Xamong heros.
X.PP
XWhen the game ends, either by your death, when you quit, or if you escape
Xfrom the caves,
X.I hack
Xwill give you (a fragment of) the list of top scorers.  The scoring
Xis based on many aspects of your behaviour but a rough estimate is
Xobtained by taking the amount of gold you've found in the cave plus four
Xtimes your (real) experience. Precious stones may be worth a lot of gold
Xwhen brought to the exit.
XThere is a 10% penalty for getting yourself killed.
X.PP
XThe administration of the game is kept in the directory specified with the
X.B \-d
Xoption, or, if no such option is given, in the directory specified by
Xthe environment variable HACKDIR, or, if no such variable exists, in
Xthe current directory. This same directory contains several auxiliary
Xfiles such as lockfiles and the list of topscorers and a subdirectory
X.I save
Xwhere games are saved.
XThe game administrator may however choose to install hack with a fixed
Xplaying ground, usually /usr/games/lib/nethackdir.
X.PP
XThe
X.B \-n
Xoption suppresses printing of the news.
X.PP
XThe
X.B \-u
X.I playername
Xoption supplies the answer to the question "Who are you?".
XWhen
X.I playername
Xhas as suffix one of
X.B \-T \-S \-K \-F \-C \-W \-N \-A \-P \-V \-E \-H
Xthen this supplies the answer to the question "What kind of character ... ?".
X.PP
XThe
X.B \-s
Xoption will print out the list of your scores. It may be followed by arguments
X.B \-X
Xwhere X is one of the letters C, F, K, S, T, W, N, A, P, V, E, H to print the
Xscores of Cave(wo)men, Fighters, Knights, Samurai, Tourists, Wizards, Ninjas,
XArchaeologists, Priest(esse)s, Valkyries, Elves, or Healers.
XIt may also be followed by one or more player names to print the scores of the
Xplayers mentioned.
X.SH AUTHORS
XJay Fenlason (+ Kenny Woodland, Mike Thome and Jon Payne) wrote the
Xoriginal hack, very much like rogue (but full of bugs).
X.br
XAndries Brouwer continuously deformed their sources into the current
Xversion - in fact an entirely different game.
X.br
XMike Stephenson has continued the perversion of sources adding various
Xwarped character classes and sadistic traps with the help of many strange
Xpeople who reside in that place between the worlds, the Usenet Zone.
X.br
XDon Kneller, Gil Neiger, Scott Turner and Ken Arromdee deserve special
Xmention in this regard.
X.br
XThe resulting mess is now called NetHack (or NetQuest), to denote its
Xdevelopment by the Usenet.  Andries Brouwer has made this request for the
Xdistinction, as he may eventually release a new version of his own.
X.SH FILES
X.DT
X.ta \w'data, rumors\ \ \ 'u
Xnethack		The hack program.
X.br
Xnetquest	The quest program.
X.br
Xdata, rumors	Data files used by hack.
X.br
Xhelp, hh	Help data files.
X.br
Xrecord	The list of topscorers.
X.br
Xsave	A subdirectory containing the saved
X.br
X	games.
X.br
Xbones_dd	Descriptions of the ghost and
X.br
X	belongings of a deceased adventurer.
X.br
Xxlock.dd	Description of a dungeon level.
X.br
Xsafelock	Lock file for xlock.
X.br
Xrecord_lock	Lock file for record.
X.SH ENVIRONMENT
X.DT
X.ta \w'HACKPAGER, PAGER\ \ \ 'u
XUSER or LOGNAME	Your login name.
X.br
XHOME		Your home directory.
X.br
XSHELL		Your shell.
X.br
XTERM		The type of your terminal.
X.br
XHACKPAGER, PAGER	Pager used instead of default pager.
X.br
XMAIL	Mailbox file.
X.br
XMAILREADER	Reader used instead of default
X.br
X	(probably /bin/mail or /usr/ucb/mail).
X.br
XHACKDIR	Playground.
X.br
XHACKOPTIONS	String predefining several hack options
X.br
X	(see help file).
X.br
X
XSeveral other environment variables are used in debugging (wizard) mode,
Xlike GENOCIDED, INVENT, MAGIC and SHOPTYPE.
X.SH BUGS
X.PP
XProbably infinite.
END_OF_nethack.6
if test 4636 -ne `wc -c <nethack.6`; then
    echo shar: \"nethack.6\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f o_init.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"o_init.c\"
else
echo shar: Extracting \"o_init.c\" \(5427 characters\)
sed "s/^X//" >o_init.c <<'END_OF_o_init.c'
X/*	SCCS Id: @(#)o_init.c	1.3	87/07/14
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* o_init.c - version 1.0.3 */
X
X#include	"config.h"		/* for typedefs */
X#include	"objects.h"
X#include	"onames.h"		/* for LAST_GEM */
Xextern char *index();
X
Xint
Xletindex(let) register char let; {
Xregister int i = 0;
Xregister char ch;
X	while((ch = obj_symbols[i++]) != 0)
X		if(ch == let) return(i);
X	return(0);
X}
X
Xinit_objects(){
Xregister int i, j, first, last, sum, end, tmp_i;
Xregister char let, *tmp;
X	/* init base; if probs given check that they add up to 100, 
X	   otherwise compute probs; shuffle descriptions */
X	end = SIZE(objects);
X#ifdef MSDOS
X	/* Assign indices to all oc_descr_i first */
X	for (i = 0; i < end; i++)
X		objects[i].oc_descr_i = i;
X#endif
X	first = 0;
X	while( first < end ) {
X		let = objects[first].oc_olet;
X		last = first+1;
X		while(last < end && objects[last].oc_olet == let
X				 && objects[last].oc_name != NULL) last++;
X		i = letindex(let);
X		if((!i && let != ILLOBJ_SYM) || bases[i] != 0)
X			error("initialization error");
X		bases[i] = first;
X
X		if(let == GEM_SYM) setgemprobs();
X	check:
X		sum = 0;
X		for(j = first; j < last; j++) sum += objects[j].oc_prob;
X		if(sum == 0) {
X			for(j = first; j < last; j++)
X			    objects[j].oc_prob = (100+j-first)/(last-first);
X			goto check;
X		}
X		if(sum != 100)
X			error("init-prob error for %c (%d%%)", let, sum);
X
X		if(objects[first].oc_descr != NULL && let != TOOL_SYM){
X			/* shuffle, also some additional descriptions */
X			while(last < end && objects[last].oc_olet == let)
X				last++;
X			j = last;
X			while(--j > first) {
X				i = first + rn2(j+1-first);
X				tmp = objects[j].oc_descr;
X				objects[j].oc_descr = objects[i].oc_descr;
X				objects[i].oc_descr = tmp;
X#ifdef MSDOS
X	/* keep track of where the description came from */
X				tmp_i = objects[j].oc_descr_i;
X				objects[j].oc_descr_i = objects[i].oc_descr_i;
X				objects[i].oc_descr_i = tmp_i;
X#endif
X			}
X		}
X		first = last;
X	}
X}
X
Xprobtype(let) register char let; {
Xregister int i = bases[letindex(let)];
Xregister int prob = rn2(100);
X	while((prob -= objects[i].oc_prob) >= 0) i++;
X	if(objects[i].oc_olet != let || !objects[i].oc_name)
X		panic("probtype(%c) error, i=%d", let, i);
X	return(i);
X}
X
Xsetgemprobs()
X{
X	register int j,first;
X	extern xchar dlevel;
X
X	first = bases[letindex(GEM_SYM)];
X
X	for(j = 0; j < 9-dlevel/3; j++)
X		objects[first+j].oc_prob = 0;
X	first += j;
X	if(first >= LAST_GEM || first >= SIZE(objects) ||
X	    objects[first].oc_olet != GEM_SYM ||
X	    objects[first].oc_name == NULL)
X		printf("Not enough gems? - first=%d j=%d LAST_GEM=%d\n",
X			first, j, LAST_GEM);
X	for(j = first; j < LAST_GEM; j++)
X		objects[j].oc_prob = (20+j-first)/(LAST_GEM-first);
X}
X
Xoinit()			/* level dependent initialization */
X{
X	setgemprobs();
X}
X
Xextern long *alloc();
X
Xsavenames(fd) register fd; {
Xregister int i;
Xunsigned len;
X	bwrite(fd, (char *) bases, sizeof bases);
X	bwrite(fd, (char *) objects, sizeof objects);
X	/* as long as we use only one version of Hack/Quest we
X	   need not save oc_name and oc_descr, but we must save
X	   oc_uname for all objects */
X	for(i=0; i < SIZE(objects); i++) {
X		if(objects[i].oc_uname) {
X			len = strlen(objects[i].oc_uname)+1;
X			bwrite(fd, (char *) &len, sizeof len);
X			bwrite(fd, objects[i].oc_uname, len);
X		}
X	}
X}
X
Xrestnames(fd) register fd; {
Xregister int i;
Xunsigned len;
X#ifdef MSDOS
X	char *oc_descr[NROFOBJECTS + 1], *oc_name;
X
X	mread(fd, (char *) bases, sizeof bases);
X
X	/* Read in objects 1 at a time, correcting oc_name pointer and
X	 * saving pointer to current description.
X	 */
X	for (i = 0; i < SIZE(objects); i++) {
X		oc_name = objects[i].oc_name;
X		oc_descr[i] = objects[i].oc_descr;
X		mread(fd, (char *) &objects[i], sizeof (struct objclass));
X		objects[i].oc_name = oc_name;
X	}
X
X	/* Convert from saved indices into pointers */
X	for (i = 0; i < SIZE(objects); i++)
X		objects[i].oc_descr = oc_descr[objects[i].oc_descr_i];
X#else
X	mread(fd, (char *) bases, sizeof bases);
X	mread(fd, (char *) objects, sizeof objects);
X#endif
X	for(i=0; i < SIZE(objects); i++) if(objects[i].oc_uname) {
X		mread(fd, (char *) &len, sizeof len);
X		objects[i].oc_uname = (char *) alloc(len);
X		mread(fd, objects[i].oc_uname, len);
X	}
X}
X
Xdodiscovered()				/* free after Robert Viduya */
X{
X    extern char *typename();
X    register int i, end;
X    int	ct = 0;
X#ifdef DGKMOD
X    char class = -1;
X    extern char *let_to_name();
X#endif
X
X    cornline(0, "Discoveries");
X
X    end = SIZE(objects);
X    for (i = 0; i < end; i++) {
X	if (interesting_to_discover (i)) {
X	    ct++;
X#ifdef DGKMOD
X	    if (objects[i].oc_olet != class) {
X		class = objects[i].oc_olet;
X		cornline(1, let_to_name(class));
X	    }
X#endif
X	    cornline(1, typename(i));
X	}
X    }
X    if (ct == 0) {
X	pline ("You haven't discovered anything yet...");
X	cornline(3, (char *) 0);
X    } else
X	cornline(2, (char *) 0);
X
X    return(0);
X}
X
Xinteresting_to_discover(i)
Xregister int i;
X{
X    return(
X	objects[i].oc_uname != NULL ||
X	 (objects[i].oc_name_known && objects[i].oc_descr != NULL)
X    );
X}
X
Xinit_corpses() {
X
X#ifdef KOPS
X	strcpy(objects[DEAD_KOP].oc_name, "dead Kop");
X#endif
X#ifdef SPIDERS
X	strcpy(objects[DEAD_GIANT_SPIDER].oc_name, "dead giant spider");
X#endif
X#ifdef ROCKMOLE
X	strcpy(objects[DEAD_ROCKMOLE].oc_name, "dead rockmole");
X#endif
X#ifndef KAA
X	strcpy(objects[DEAD_QUASIT].oc_name, "dead quasit");
X	strcpy(objects[DEAD_VIOLET_FUNGI].oc_name, "dead violet fungi");
X#endif
X	return(0);
X}
END_OF_o_init.c
if test 5427 -ne `wc -c <o_init.c`; then
    echo shar: \"o_init.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f polyself.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"polyself.c\"
else
echo shar: Extracting \"polyself.c\" \(5723 characters\)
sed "s/^X//" >polyself.c <<'END_OF_polyself.c'
X/*	SCCS Id: @(#)polyself.c	1.3	87/07/14
X/* Polymorph self routine.  Called in zap.c. Copyright 1987 by Ken Arromdee */
X
X#include "hack.h"
X
X#ifdef KAA
X
Xextern char genocided[];
Xextern char pl_character[PL_CSIZ];
Xextern char plname[PL_NSIZ];
X
Xextern long newuexp();
X
Xpolyself()
X{
X     char buf[BUFSZ];
X     int tmp, tmp2, mntmp;
X
X     if (rn2(5)-3 > u.uluck) {
X	  pline("You shudder for a moment.");
X	  losehp(rn2(30),"system shock");
X	  return;
X     }
X     mntmp = rn2(CMNUM);
X/* We want to disallow certain monsters, but also allow humans. */
X     if (index("w:",mons[mntmp].mlet) || !rn2(5)) {
X	  if (!rn2(10)) flags.female = !flags.female;
X	  tmp = u.uhpmax;
X	  tmp2 = u.ulevel;
X	  u.usym = '@';
X	  prme();
X	  u.mtimedone = u.mh = u.mhmax = 0;
X	  u.ulevel = u.ulevel-2+rn2(5);
X	  if (u.ulevel > 127 || u.ulevel == 0) u.ulevel = 1;
X	  if (u.ulevel > 14) u.ulevel = 14;
X	  if (u.ulevel == 1) u.uexp = rnd(10);
X	  else {  /* For the new experience level, random EXP. */
X	       u.ulevel--;     
X	       u.uexp = newuexp();
X	       u.uexp += rn2(u.uexp);
X	       u.ulevel++;
X	  }
X	  u.uhpmax = (u.uhpmax-10)*u.ulevel/tmp2 + 19 - rn2(19);
X/* If it was u.uhpmax*u.ulevel/tmp+9-rn2(19), then a 1st level character
X   with 16 hp who polymorphed into a 3rd level one would have an average
X   of 48 hp.  */
X	  u.uhp = u.uhp*u.uhpmax/tmp;
X	  tmp = u.ustrmax;
X	  u.ustrmax += (rn2(5)-2);
X	  if (u.ustrmax > 118) u.ustrmax = 118;
X	  if (u.ustrmax < 3) u.ustrmax = 3;
X	  u.ustr = u.ustr * u.ustrmax / tmp;
X	  if (u.ustr < 3) u.ustr = 3;  /* > 118 is impossible */
X	  u.uhunger = 500 + rn2(500);
X	  Sick = 0;
X	  Stoned = 0;
X	  if (u.uhp <= 0 || u.uhpmax <= 0) {
X	       killer="unsuccessful polymorph";
X	       done("died");
X	  }
X	  pline("You feel like a new %sman!", flags.female ? "wo" : "");
Xnewname:  more();
X	  do {
X	       pline("What is your new name? ");
X	       getlin(buf);
X	  } while (buf[0]=='\033' || buf[0]==0);
X	  if (!strcmp(plname,buf)) {
X	       pline("That is the same as your old name!");
X	       goto newname;
X	  }
X	  (void)strncpy(plname, buf, sizeof(plname)-1);
X	  flags.botl = 1;
X	  find_ac();
X     } else {
X	  if (index(genocided,mons[mntmp].mlet)) {
X	       pline("You feel rather %sish.",mons[mntmp].mname);
X	       return;
X	  }
X	  u.umonnum = mntmp;
X	  u.usym = mons[mntmp].mlet;
X	  if (u.usym == 'D') u.mhmax = 80;
X	  else if (!(mons[mntmp].mlevel)) u.mhmax = rnd(4);
X	  else u.mhmax = d(mons[mntmp].mlevel,8);
X	  u.mh = u.mhmax;
X	  pline("You turn into a%s %s!", index("aeioOU",u.usym) ? "n" : "",
X	       mons[mntmp].mname);
X	  break_armor(u.usym);
X	  drop_weapon(u.usym);
X	  prme();
X	  u.mtimedone = 500 + rn2(500);
X	  flags.botl = 1;
X	  if (u.usym == 'D')
X	       pline("Use the command #breathe to breathe.");
X	  if (u.usym == 'N')
X	       pline("Use the command #remove if you have to remove an iron ball.");
X	  find_ac();
X     }
X     if (Inhell && !Fire_resistance) {
X	  pline("You burn to a crisp.");
X	  killer = "unwise polymorph";
X	  done("died");
X     }
X}
X
Xbreak_armor(turninto)
Xchar turninto;
X{
X     struct obj *otmp;
X     if (uarm) {
X	  if (index("CDMPRUXYdejlouz,'9", turninto)) {
X	       pline("The transformation causes you to break out of your armor!");
X	       if (uarm2) useup(uarm2);
X	       useup(uarm);
X	  } else if (index("abcfghikpqrstvxyABEFJQS", turninto)) {
X	       pline("Your armor falls around you!");
X	       if (otmp = uarm2) {
X		    setworn((struct obj *)0,otmp->owornmask & W_ARM2);
X		    dropx(otmp);
X	       }
X	       otmp = uarm;
X	       setworn((struct obj *)0, otmp->owornmask & W_ARM);
X	       dropx(otmp);
X	  }
X     }
X     if (!index("enozCGHIKLNOTUVWXYZ&',", turninto)) {
X	  if (otmp = uarmg) {
X	       pline("You drop your gloves!");
X	       setworn((struct obj *)0, otmp->owornmask & W_ARMG);
X	       dropx(otmp);
X	       drop_weapon('a'); /* the 'a' is dummy to ensure dropping */
X	  }
X	  if (otmp = uarms) {
X	       pline("You can no longer hold your shield!");
X	       setworn((struct obj *)0, otmp->owornmask & W_ARMS);
X	       dropx(otmp);
X	  }
X	  if (otmp = uarmh) {
X	       pline("Your helmet falls to the floor!");
X	       setworn((struct obj *)0, otmp->owornmask & W_ARMH);
X	       dropx(otmp);
X	  }
X     }
X}
X
Xdrop_weapon(turninto) 
Xchar turninto;
X{
X     struct obj *otmp;
X     if (otmp = uwep) {
X	  if (cantwield(turninto)) {
X	       pline("You find you must drop your weapon!");
X	       setuwep((struct obj *)0);
X	       dropx(otmp);
X	  }
X     }
X}
X
Xcantwield(c)  /* creature type c cannot wield a weapon */
Xchar c;
X{
X     return(!!index("abcdfgjklpqrsuvxyABEFJPRS',",c));
X}
X
Xcantweararm(c)   /* creature type c cannot wear armor */
Xchar c;
X{
X     return(!index("@nGHIKLNOTVWZ&',",c));
X}
X
Xrehumanize()
X{
X     u.mh = u.mhmax = u.mtimedone = 0;
X     u.usym = '@';
X     prme();
X     pline("You return to %sn form!", (pl_character[0]=='E')?"elve":"huma");
X     if (!Fire_resistance && Inhell) {
X	  pline("You burn to a crisp.");
X	  killer = "dissipating polymorph spell";
X	  done("died");
X     }
X     flags.botl = 1;
X     find_ac();
X}
X
Xdobreathe()
X{
X     if (u.usym == 'D') {
X	  if(!getdir(1)) return(0);
X	  if (rn2(4))
X	       pline("You exhale a bit of smoke.");
X	  else buzz(10, u.ux, u.uy, u.dx, u.dy);
X     /* Changes must be made in zap.c to accommodate this. */
X     } else pline("You do not have the ability to breathe fire!");
X     return(1);
X}
X
Xdoremove()
X{
X     if (!Punished) {
X	  pline("You do not have a ball attached to your leg!");
X	  return(0);
X     }
X     if(u.usym != 'N')
X	  pline("You are not capable of removing a locked chain!");
X     else {
X	  Punished = 0;
X	  uchain->spe = 0;
X	  uball->spe = 0;
X	  uchain->owornmask &= ~W_CHAIN;
X	  uball->owornmask &= ~W_BALL;
X	  uchain = uball = (struct obj *)0;
X     }
X     return(1);
X}
X#endif
END_OF_polyself.c
if test 5723 -ne `wc -c <polyself.c`; then
    echo shar: \"polyself.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f shknam.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"shknam.c\"
else
echo shar: Extracting \"shknam.c\" \(4285 characters\)
sed "s/^X//" >shknam.c <<'END_OF_shknam.c'
X/*	SCCS Id: @(#)shknam.c	1.3	87/07/14
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* shknam.c - version 1.0.2 */
X
X#include "hack.h"
X
Xchar *shkliquors[] = {
X	/* Ukraine */
X	"Njezjin", "Tsjernigof", "Gomel", "Ossipewsk", "Gorlowka",
X	/* N. Russia */
X	"Konosja", "Weliki Oestjoeg", "Syktywkar", "Sablja",
X	"Narodnaja", "Kyzyl",
X	/* Silezie */
X	"Walbrzych", "Swidnica", "Klodzko", "Raciborz", "Gliwice",
X	"Brzeg", "Krnov", "Hradec Kralove",
X	/* Schweiz */
X	"Leuk", "Brig", "Brienz", "Thun", "Sarnen", "Burglen", "Elm",
X	"Flims", "Vals", "Schuls", "Zum Loch",
X	0
X};
X
Xchar *shkbooks[] = {
X	/* Eire */
X	"Skibbereen", "Kanturk", "Rath Luirc", "Ennistymon", "Lahinch",
X	"Loughrea", "Croagh", "Maumakeogh", "Ballyjamesduff",
X	"Kinnegad", "Lugnaquillia", "Enniscorthy", "Gweebarra",
X	"Kittamagh", "Nenagh", "Sneem", "Ballingeary", "Kilgarvan",
X	"Cahersiveen", "Glenbeigh", "Kilmihil", "Kiltamagh",
X	"Droichead Atha", "Inniscrone", "Clonegal", "Lisnaskea",
X	"Culdaff", "Dunfanaghy", "Inishbofin", "Kesh",
X	0
X};
X
Xchar *shkarmors[] = {
X	/* Turquie */
X	"Demirci", "Kalecik", "Boyabai", "Yildizeli", "Gaziantep",
X	"Siirt", "Akhalataki", "Tirebolu", "Aksaray", "Ermenak",
X	"Iskenderun", "Kadirli", "Siverek", "Pervari", "Malasgirt",
X	"Bayburt", "Ayancik", "Zonguldak", "Balya", "Tefenni",
X	"Artvin", "Kars", "Makharadze", "Malazgirt", "Midyat",
X	"Birecik", "Kirikkale", "Alaca", "Polatli", "Nallihan",
X	0
X};
X
Xchar *shkwands[] = {
X	/* Wales */
X	"Yr Wyddgrug", "Trallwng", "Mallwyd", "Pontarfynach",
X	"Rhaeader", "Llandrindod", "Llanfair-ym-muallt",
X	"Y-Fenni", "Measteg", "Rhydaman", "Beddgelert",
X	"Curig", "Llanrwst", "Llanerchymedd", "Caergybi",
X	/* Scotland */
X	"Nairn", "Turriff", "Inverurie", "Braemar", "Lochnagar",
X	"Kerloch", "Beinn a Ghlo", "Drumnadrochit", "Morven",
X	"Uist", "Storr", "Sgurr na Ciche", "Cannich", "Gairloch",
X	"Kyleakin", "Dunvegan",
X	0
X};
X
Xchar *shkrings[] = {
X	/* Hollandse familienamen */
X	"Feyfer", "Flugi", "Gheel", "Havic", "Haynin", "Hoboken",
X	"Imbyze", "Juyn", "Kinsky", "Massis", "Matray", "Moy",
X	"Olycan", "Sadelin", "Svaving", "Tapper", "Terwen", "Wirix",
X	"Ypey",
X	/* Skandinaviske navne */
X	"Rastegaisa", "Varjag Njarga", "Kautekeino", "Abisko",
X	"Enontekis", "Rovaniemi", "Avasaksa", "Haparanda",
X	"Lulea", "Gellivare", "Oeloe", "Kajaani", "Fauske",
X	0
X};
X
Xchar *shkfoods[] = {
X	/* Indonesia */
X	"Djasinga", "Tjibarusa", "Tjiwidej", "Pengalengan",
X	"Bandjar", "Parbalingga", "Bojolali", "Sarangan",
X	"Ngebel", "Djombang", "Ardjawinangun", "Berbek",
X	"Papar", "Baliga", "Tjisolok", "Siboga", "Banjoewangi",
X	"Trenggalek", "Karangkobar", "Njalindoeng", "Pasawahan",
X	"Pameunpeuk", "Patjitan", "Kediri", "Pemboeang", "Tringanoe",
X	"Makin", "Tipor", "Semai", "Berhala", "Tegal", "Samoe",
X	0
X};
X
Xchar *shkweapons[] = {
X	/* Perigord */
X	"Voulgezac", "Rouffiac", "Lerignac", "Touverac", "Guizengeard",
X	"Melac", "Neuvicq", "Vanzac", "Picq", "Urignac", "Corignac",
X	"Fleac", "Lonzac", "Vergt", "Queyssac", "Liorac", "Echourgnac",
X	"Cazelon", "Eypau", "Carignan", "Monbazillac", "Jonzac",
X	"Pons", "Jumilhac", "Fenouilledes", "Laguiolet", "Saujon",
X	"Eymoutiers", "Eygurande", "Eauze", "Labouheyre",
X	0
X};
X
Xchar *shkgeneral[] = {
X	/* Suriname */
X	"Hebiwerie", "Possogroenoe", "Asidonhopo", "Manlobbi",
X	"Adjama", "Pakka Pakka", "Kabalebo", "Wonotobo",
X	"Akalapi", "Sipaliwini",
X	/* Greenland */
X	"Annootok", "Upernavik", "Angmagssalik",
X	/* N. Canada */
X	"Aklavik", "Inuvik", "Tuktoyaktuk",
X	"Chicoutimi", "Ouiatchouane", "Chibougamau",
X	"Matagami", "Kipawa", "Kinojevis",
X	"Abitibi", "Maganasipi",
X	/* Iceland */
X	"Akureyri", "Kopasker", "Budereyri", "Akranes", "Bordeyri",
X	"Holmavik",
X	0
X};
X
Xstruct shk_nx {
X	char x;
X	char **xn;
X} shk_nx[] = {
X	{ POTION_SYM,	shkliquors },
X	{ SCROLL_SYM,	shkbooks },
X	{ ARMOR_SYM,	shkarmors },
X	{ WAND_SYM,	shkwands },
X	{ RING_SYM,	shkrings },
X	{ FOOD_SYM,	shkfoods },
X	{ WEAPON_SYM,	shkweapons },
X	{ 0,		shkgeneral }
X};
X
Xfindname(nampt, let) char *nampt; char let; {
Xregister struct shk_nx *p = shk_nx;
Xregister char **q;
Xregister int i;
X	while(p->x && p->x != let) p++;
X	q = p->xn;
X	for(i=0; i<dlevel; i++) if(!q[i]){
X		/* Not enough names, try general name */
X		if(let) findname(nampt, 0);
X		else (void) strcpy(nampt, "Dirk");
X		return;
X	}
X	(void) strncpy(nampt, q[i], PL_NSIZ);
X	nampt[PL_NSIZ-1] = 0;
X}
END_OF_shknam.c
if test 4285 -ne `wc -c <shknam.c`; then
    echo shar: \"shknam.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f steal.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"steal.c\"
else
echo shar: Extracting \"steal.c\" \(5079 characters\)
sed "s/^X//" >steal.c <<'END_OF_steal.c'
X/*	SCCS Id: @(#)steal.c	1.3	87/07/14
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* steal.c - version 1.0.3 */
X
X#include "hack.h"
X
Xlong		/* actually returns something that fits in an int */
Xsomegold(){
X	return( (u.ugold < 100) ? u.ugold :
X		(u.ugold > 10000) ? rnd(10000) : rnd((int) u.ugold) );
X}
X
Xstealgold(mtmp)  register struct monst *mtmp; {
Xregister struct gold *gold = g_at(u.ux, u.uy);
Xregister long tmp;
X	if(gold && ( !u.ugold || gold->amount > u.ugold || !rn2(5))) {
X		mtmp->mgold += gold->amount;
X		freegold(gold);
X		if(Invisible) newsym(u.ux, u.uy);
X		pline("%s quickly snatches some gold from between your feet!",
X			Monnam(mtmp));
X		if(!u.ugold || !rn2(5)) {
X			rloc(mtmp);
X			mtmp->mflee = 1;
X		}
X	} else if(u.ugold) {
X		u.ugold -= (tmp = somegold());
X		pline("Your purse feels lighter.");
X		mtmp->mgold += tmp;
X		rloc(mtmp);
X		mtmp->mflee = 1;
X		flags.botl = 1;
X	}
X}
X
X/* steal armor after he finishes taking it off */
Xunsigned stealoid;		/* object to be stolen */
Xunsigned stealmid;		/* monster doing the stealing */
Xstealarm(){
X	register struct monst *mtmp;
X	register struct obj *otmp;
X
X	for(otmp = invent; otmp; otmp = otmp->nobj)
X	  if(otmp->o_id == stealoid) {
X	    for(mtmp = fmon; mtmp; mtmp = mtmp->nmon)
X	      if(mtmp->m_id == stealmid) {
X		if(dist(mtmp->mx,mtmp->my) < 3) {
X		  freeinv(otmp);
X		  pline("%s steals %s!", Monnam(mtmp), doname(otmp));
X		  mpickobj(mtmp,otmp);
X		  mtmp->mflee = 1;
X		  rloc(mtmp);
X		}
X		break;
X	      }
X	    break;
X	  }
X	stealoid = 0;
X}
X
X/* returns 1 when something was stolen */
X/* (or at least, when N should flee now) */
X/* avoid stealing the object stealoid */
Xsteal(mtmp)
Xstruct monst *mtmp;
X{
X	register struct obj *otmp;
X	register tmp;
X	register named = 0;
X
X	if(!invent){
X	    if(Blind)
X	      pline("Somebody tries to rob you, but finds nothing to steal.");
X	    else
X	      pline("%s tries to rob you, but she finds nothing to steal!",
X		Monnam(mtmp));
X	    return(1);	/* let her flee */
X	}
X	tmp = 0;
X	for(otmp = invent; otmp; otmp = otmp->nobj) if(otmp != uarm2)
X		tmp += ((otmp->owornmask & (W_ARMOR | W_RING)) ? 5 : 1);
X	tmp = rn2(tmp);
X	for(otmp = invent; otmp; otmp = otmp->nobj) if(otmp != uarm2)
X		if((tmp -= ((otmp->owornmask & (W_ARMOR | W_RING)) ? 5 : 1))
X			< 0) break;
X	if(!otmp) {
X		impossible("Steal fails!");
X		return(0);
X	}
X	if(otmp->o_id == stealoid)
X		return(0);
X	if((otmp->owornmask & (W_ARMOR | W_RING))){
X		switch(otmp->olet) {
X		case RING_SYM:
X			ringoff(otmp);
X			break;
X		case ARMOR_SYM:
X			if(multi < 0 || otmp == uarms){
X			  setworn((struct obj *) 0, otmp->owornmask & W_ARMOR);
X			  break;
X			}
X		{ int curssv = otmp->cursed;
X			otmp->cursed = 0;
X			stop_occupation();
X			if(flags.female)
X				pline("%s charms you.  You gladly hand over your humble garments.",
X				Monnam(mtmp));
X			else
X				pline("%s seduces you and %s off your %s.",
X				Amonnam(mtmp, Blind ? "gentle" : "beautiful"),
X				otmp->cursed ? "helps you to take"
X					    : "you start taking",
X				(otmp == uarmg) ? "gloves" :
X				(otmp == uarmh) ? "helmet" : "armor");
X			named++;
X			(void) armoroff(otmp);
X			otmp->cursed = curssv;
X			if(multi < 0){
X				extern char *nomovemsg;
X				extern int (*afternmv)();
X				/*
X				multi = 0;
X				nomovemsg = 0;
X				afternmv = 0;
X				*/
X				stealoid = otmp->o_id;
X				stealmid = mtmp->m_id;
X				afternmv = stealarm;
X				return(0);
X			}
X			break;
X		}
X		default:
X			impossible("Tried to steal a strange worn thing.");
X		}
X	}
X	else if(otmp == uwep) setuwep((struct obj *) 0);
X
X	if(Punished && otmp == uball){
X		Punished = 0;
X		freeobj(uchain);
X		free((char *) uchain);
X		uchain = (struct obj *) 0;
X		uball->spe = 0;
X		uball = (struct obj *) 0;	/* superfluous */
X	}
X	freeinv(otmp);
X	pline("%s stole %s.", named ? "She" : Monnam(mtmp), doname(otmp));
X	mpickobj(mtmp,otmp);
X	return((multi < 0) ? 0 : 1);
X}
X
Xmpickobj(mtmp,otmp)
Xregister struct monst *mtmp;
Xregister struct obj *otmp;
X{
X	otmp->nobj = mtmp->minvent;
X	mtmp->minvent = otmp;
X}
X
Xstealamulet(mtmp)
Xregister struct monst *mtmp;
X{
X	register struct obj *otmp;
X
X	for(otmp = invent; otmp; otmp = otmp->nobj) {
X	    if(otmp->olet == AMULET_SYM) {
X		/* might be an imitation one */
X		if(otmp == uwep) setuwep((struct obj *) 0);
X		freeinv(otmp);
X		mpickobj(mtmp,otmp);
X		pline("%s stole %s!", Monnam(mtmp), doname(otmp));
X		return(1);
X	    }
X	}
X	return(0);
X}
X
X/* release the objects the killed animal has stolen */
Xrelobj(mtmp,show)
Xregister struct monst *mtmp;
Xregister show;
X{
X	register struct obj *otmp, *otmp2;
X
X	for(otmp = mtmp->minvent; otmp; otmp = otmp2){
X		otmp->ox = mtmp->mx;
X		otmp->oy = mtmp->my;
X		otmp2 = otmp->nobj;
X		otmp->nobj = fobj;
X		fobj = otmp;
X		stackobj(fobj);
X		if(show & cansee(mtmp->mx,mtmp->my))
X			atl(otmp->ox,otmp->oy,Hallucination?rndobjsym() : otmp->olet);
X	}
X	mtmp->minvent = (struct obj *) 0;
X	if(mtmp->mgold || mtmp->data->mlet == 'L') {
X		register long tmp;
X
X		tmp = (mtmp->mgold > 10000) ? 10000 : mtmp->mgold;
X		mkgold((long)(tmp + d(dlevel,30)), mtmp->mx, mtmp->my);
X		if(show & cansee(mtmp->mx,mtmp->my))
X			atl(mtmp->mx,mtmp->my, Hallucination ? rndobjsym() : '$');
X	}
X}
END_OF_steal.c
if test 5079 -ne `wc -c <steal.c`; then
    echo shar: \"steal.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f unixtty.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"unixtty.c\"
else
echo shar: Extracting \"unixtty.c\" \(6815 characters\)
sed "s/^X//" >unixtty.c <<'END_OF_unixtty.c'
X/*	SCCS Id: @(#)unixtty.c	1.3	87/07/14
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* tty.c - (Unix) version 1.0.3 */
X/* With thanks to the people who sent code for SYSV - hpscdi!jon,
X   arnold@ucsf-cgl, wcs@bo95b, cbcephus!pds and others. */
X
X#include	<stdio.h>
X#include	"extern.h"
X#include	"flag.h"
X
X#define	ON	1
X#define OFF	0
X#define	BUFSZ	256
X
X
X/*
X * The distinctions here are not BSD - rest but rather USG - rest, as
X * BSD still has the old sgttyb structure, but SYSV has termio. Thus:
X */
X#ifdef BSD
X#define	V7
X#else
X#define USG
X#endif
X
X/*
X * Some systems may have getchar() return EOF for various reasons, and
X * we should not quit before seeing at least NR_OF_EOFS consecutive EOFs.
X */
X#ifndef BSD
X#define	NR_OF_EOFS	20
X#endif
X
X
X#ifdef USG
X
X#include	<termio.h>
X#define termstruct	termio
X#define kill_sym	c_cc[VKILL]
X#define erase_sym	c_cc[VERASE]
X#define EXTABS		TAB3
X#define tabflgs		c_oflag
X#define echoflgs	c_lflag
X#define cbrkflgs	c_lflag
X#define CBRKMASK	ICANON
X#define CBRKON		! /* reverse condition */
X#define OSPEED(x)	((x).c_cflag & CBAUD)
X#define GTTY(x)		(ioctl(0, TCGETA, x))
X#define STTY(x)		(ioctl(0, TCSETA, x))	/* TCSETAF? TCSETAW? */
X
X#else	/* V7 */
X
X#include	<sgtty.h>
X#define termstruct	sgttyb
X#define	kill_sym	sg_kill
X#define	erase_sym	sg_erase
X#define EXTABS		XTABS
X#define tabflgs		sg_flags
X#define echoflgs	sg_flags
X#define cbrkflgs	sg_flags
X#define CBRKMASK	CBREAK
X#define CBRKON		/* empty */
X#define OSPEED(x)	(x).sg_ospeed
X#define GTTY(x)		(gtty(0, x))
X#define STTY(x)		(stty(0, x))
X
X#endif
X
Xextern short ospeed;
Xstatic char erase_char, kill_char;
Xstatic boolean settty_needed = FALSE;
Xstruct termstruct inittyb, curttyb;
X
X/*
X * Get initial state of terminal, set ospeed (for termcap routines)
X * and switch off tab expansion if necessary.
X * Called by startup() in termcap.c and after returning from ! or ^Z
X */
Xgettty(){
X	if(GTTY(&inittyb) < 0)
X		perror("Hack (gettty)");
X	curttyb = inittyb;
X	ospeed = OSPEED(inittyb);
X	erase_char = inittyb.erase_sym;
X	kill_char = inittyb.kill_sym;
X	getioctls();
X
X	/* do not expand tabs - they might be needed inside a cm sequence */
X	if(curttyb.tabflgs & EXTABS) {
X		curttyb.tabflgs &= ~EXTABS;
X		setctty();
X	}
X	settty_needed = TRUE;
X}
X
X/* reset terminal to original state */
Xsettty(s) char *s; {
X	clear_screen();
X	end_screen();
X	if(s) printf(s);
X	(void) fflush(stdout);
X	if(STTY(&inittyb) < 0)
X		perror("Hack (settty)");
X	flags.echo = (inittyb.echoflgs & ECHO) ? ON : OFF;
X	flags.cbreak = (CBRKON(inittyb.cbrkflgs & CBRKMASK)) ? ON : OFF;
X	setioctls();
X}
X
Xsetctty(){
X	if(STTY(&curttyb) < 0)
X		perror("Hack (setctty)");
X}
X
X
Xsetftty(){
Xregister int ef = 0;			/* desired value of flags & ECHO */
Xregister int cf = CBRKON(CBRKMASK);	/* desired value of flags & CBREAK */
Xregister int change = 0;
X	flags.cbreak = ON;
X	flags.echo = OFF;
X	/* Should use (ECHO|CRMOD) here instead of ECHO */
X	if((curttyb.echoflgs & ECHO) != ef){
X		curttyb.echoflgs &= ~ECHO;
X/*		curttyb.echoflgs |= ef;					*/
X		change++;
X	}
X	if((curttyb.cbrkflgs & CBRKMASK) != cf){
X		curttyb.cbrkflgs &= ~CBRKMASK;
X		curttyb.cbrkflgs |= cf;
X#ifdef USG
X		/* be satisfied with one character; no timeout */
X		curttyb.c_cc[VMIN] = 1;		/* was VEOF */
X		curttyb.c_cc[VTIME] = 0;	/* was VEOL */
X#endif
X		change++;
X	}
X	if(change){
X		setctty();
X	}
X	start_screen();
X}
X
X
X/* fatal error */
X/*VARARGS1*/
Xerror(s,x,y) char *s; {
X	if(settty_needed)
X		settty((char *) 0);
X	printf(s,x,y);
X	putchar('\n');
X	exit(1);
X}
X
X/*
X * Read a line closed with '\n' into the array char bufp[BUFSZ].
X * (The '\n' is not stored. The string is closed with a '\0'.)
X * Reading can be interrupted by an escape ('\033') - now the
X * resulting string is "\033".
X */
Xgetlin(bufp)
Xregister char *bufp;
X{
X	register char *obufp = bufp;
X	register int c;
X
X	flags.toplin = 2;		/* nonempty, no --More-- required */
X	for(;;) {
X		(void) fflush(stdout);
X		if((c = getchar()) == EOF) {
X			*bufp = 0;
X			return;
X		}
X		if(c == '\033') {
X			*obufp = c;
X			obufp[1] = 0;
X			return;
X		}
X		if(c == erase_char || c == '\b') {
X			if(bufp != obufp) {
X				bufp--;
X				putstr("\b \b"); /* putsym converts \b */
X			} else	bell();
X		} else if(c == '\n') {
X			*bufp = 0;
X			return;
X		} else if(' ' <= c && c < '\177') {
X				/* avoid isprint() - some people don't have it
X				   ' ' is not always a printing char */
X			*bufp = c;
X			bufp[1] = 0;
X			putstr(bufp);
X			if(bufp-obufp < BUFSZ-1 && bufp-obufp < COLNO)
X				bufp++;
X		} else if(c == kill_char || c == '\177') { /* Robert Viduya */
X				/* this test last - @ might be the kill_char */
X			while(bufp != obufp) {
X				bufp--;
X				putstr("\b \b");
X			}
X		} else
X			bell();
X	}
X}
X
Xgetret() {
X	cgetret("");
X}
X
Xcgetret(s)
Xregister char *s;
X{
X	putsym('\n');
X	if(flags.standout)
X		standoutbeg();
X	putstr("Hit ");
X	putstr(flags.cbreak ? "space" : "return");
X	putstr(" to continue: ");
X	if(flags.standout)
X		standoutend();
X	xwaitforspace(s);
X}
X
Xchar morc;	/* tell the outside world what char he used */
X
Xxwaitforspace(s)
Xregister char *s;	/* chars allowed besides space or return */
X{
Xregister int c;
X
X	morc = 0;
X
X	while((c = readchar()) != '\n') {
X	    if(flags.cbreak) {
X		if(c == ' ') break;
X		if(s && index(s,c)) {
X			morc = c;
X			break;
X		}
X		bell();
X	    }
X	}
X}
X
Xstatic int last_multi;
X
Xchar *
Xparse()
X{
X	static char inline[COLNO];
X	register foo;
X
X	multi = 0;
X	flags.move = 1;
X	if(!Invisible) curs_on_u(); else home();
X	while((foo = readchar()) >= '0' && foo <= '9') {
X		multi = 10*multi+foo-'0';
X#ifdef DGKMOD
X		if (multi < 0 || multi > LARGEST_INT)
X			multi = LARGEST_INT;
X		if (multi > 9) {
X			remember_topl();
X			home();
X			cl_end();
X			printf("Count: %d", multi);
X		}
X#endif
X		last_multi = multi;
X	}
X# ifdef REDO
X	if (foo == DOAGAIN || in_doagain)
X		multi = last_multi;
X	else {
X		savech(0);	/* reset input queue */
X		savech(foo);
X	}
X# endif
X	if(multi) {
X		multi--;
X		save_cm = inline;
X	}
X	inline[0] = foo;
X	inline[1] = 0;
X	if(foo == 'g' || foo == 'G'){
X		inline[1] = getchar();
X#ifdef QUEST
X		if(inline[1] == foo) inline[2] = getchar(); else
X#endif
X		inline[2] = 0;
X	}
X	if(foo == 'm' || foo == 'M'){
X		inline[1] = getchar();
X		inline[2] = 0;
X	}
X	clrlin();
X	return(inline);
X}
X
Xchar
Xreadchar() {
X	register int sym;
X
X	(void) fflush(stdout);
X	if((sym = getchar()) == EOF)
X#ifdef NR_OF_EOFS
X	{ /*
X	   * Some SYSV systems seem to return EOFs for various reasons
X	   * (?like when one hits break or for interrupted systemcalls?),
X	   * and we must see several before we quit.
X	   */
X		register int cnt = NR_OF_EOFS;
X		while (cnt--) {
X		    clearerr(stdin);	/* omit if clearerr is undefined */
X		    if((sym = getchar()) != EOF) goto noteof;
X		}
X		end_of_input();
X	     noteof:	;
X	}
X#else
X		end_of_input();
X#endif /* NR_OF_EOFS /**/
X	if(flags.toplin == 1)
X		flags.toplin = 2;
X	return((char) sym);
X}
X
Xend_of_input()
X{
X	settty("End of input?\n");
X	clearlocks();
X	exit(0);
X}
END_OF_unixtty.c
if test 6815 -ne `wc -c <unixtty.c`; then
    echo shar: \"unixtty.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f worm.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"worm.c\"
else
echo shar: Extracting \"worm.c\" \(4392 characters\)
sed "s/^X//" >worm.c <<'END_OF_worm.c'
X/*	SCCS Id: @(#)worm.c	1.3	87/07/14
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* worm.c - version 1.0.2 */
X
X#include "hack.h"
X#ifndef NOWORM
X#include "wseg.h"
X
Xstruct wseg *wsegs[32];	/* linked list, tail first */
Xstruct wseg *wheads[32];
Xlong wgrowtime[32];
X
Xgetwn(mtmp) struct monst *mtmp; {
Xregister tmp;
X	for(tmp=1; tmp<32; tmp++) if(!wsegs[tmp]) {
X		mtmp->wormno = tmp;
X		return(1);
X	}
X	return(0);	/* level infested with worms */
X}
X
X/* called to initialize a worm unless cut in half */
Xinitworm(mtmp) struct monst *mtmp; {
Xregister struct wseg *wtmp;
Xregister tmp = mtmp->wormno;
X	if(!tmp) return;
X	wheads[tmp] = wsegs[tmp] = wtmp = newseg();
X	wgrowtime[tmp] = 0;
X	wtmp->wx = mtmp->mx;
X	wtmp->wy = mtmp->my;
X/*	wtmp->wdispl = 0; */
X	wtmp->nseg = 0;
X}
X
Xworm_move(mtmp) struct monst *mtmp; {
Xregister struct wseg *wtmp, *whd;
Xregister tmp = mtmp->wormno;
X	wtmp = newseg();
X	wtmp->wx = mtmp->mx;
X	wtmp->wy = mtmp->my;
X	wtmp->nseg = 0;
X/*	wtmp->wdispl = 0; */
X	(whd = wheads[tmp])->nseg = wtmp;
X	wheads[tmp] = wtmp;
X	if(cansee(whd->wx,whd->wy)){
X		unpmon(mtmp);
X		atl(whd->wx, whd->wy, '~');
X		whd->wdispl = 1;
X	} else	whd->wdispl = 0;
X	if(wgrowtime[tmp] <= moves) {
X		if(!wgrowtime[tmp]) wgrowtime[tmp] = moves + rnd(5);
X		else wgrowtime[tmp] += 2+rnd(15);
X		mtmp->mhpmax += 3;
X		mtmp->mhp += 3;
X		return;
X	}
X	whd = wsegs[tmp];
X	wsegs[tmp] = whd->nseg;
X	remseg(whd);
X}
X
Xworm_nomove(mtmp) register struct monst *mtmp; {
Xregister tmp;
Xregister struct wseg *wtmp;
X	tmp = mtmp->wormno;
X	wtmp = wsegs[tmp];
X	if(wtmp == wheads[tmp]) return;
X	if(wtmp == 0 || wtmp->nseg == 0) panic("worm_nomove?");
X	wsegs[tmp] = wtmp->nseg;
X	remseg(wtmp);
X	mtmp->mhp -= 3;	/* mhpmax not changed ! */
X}
X
Xwormdead(mtmp) register struct monst *mtmp; {
Xregister tmp = mtmp->wormno;
Xregister struct wseg *wtmp, *wtmp2;
X	if(!tmp) return;
X	mtmp->wormno = 0;
X	for(wtmp = wsegs[tmp]; wtmp; wtmp = wtmp2){
X		wtmp2 = wtmp->nseg;
X		remseg(wtmp);
X	}
X	wsegs[tmp] = 0;
X}
X
Xwormhit(mtmp) register struct monst *mtmp; {
Xregister tmp = mtmp->wormno;
Xregister struct wseg *wtmp;
X	if(!tmp) return;	/* worm without tail */
X	for(wtmp = wsegs[tmp]; wtmp; wtmp = wtmp->nseg)
X		(void) hitu(mtmp,1);
X}
X
Xwormsee(tmp) register unsigned tmp; {
Xregister struct wseg *wtmp = wsegs[tmp];
X	if(!wtmp) panic("wormsee: wtmp==0");
X	for(; wtmp->nseg; wtmp = wtmp->nseg)
X		if(!cansee(wtmp->wx,wtmp->wy) && wtmp->wdispl){
X			newsym(wtmp->wx, wtmp->wy);
X			wtmp->wdispl = 0;
X		}
X}
X
Xpwseg(wtmp) register struct wseg *wtmp; {
X	if(!wtmp->wdispl){
X		atl(wtmp->wx, wtmp->wy, '~');
X		wtmp->wdispl = 1;
X	}
X}
X
Xcutworm(mtmp,x,y,weptyp)
Xregister struct monst *mtmp;
Xregister xchar x,y;
Xregister uchar weptyp;		/* uwep->otyp or 0 */
X{
X	register struct wseg *wtmp, *wtmp2;
X	register struct monst *mtmp2;
X	register tmp,tmp2;
X	if(mtmp->mx == x && mtmp->my == y) return;	/* hit headon */
X
X	/* cutting goes best with axe or sword */
X	tmp = rnd(20);
X	if(weptyp == LONG_SWORD || weptyp == TWO_HANDED_SWORD ||
X	   weptyp == SCIMITAR || weptyp == SHORT_SWORD ||
X	   weptyp == BROAD_SWORD || weptyp == AXE || weptyp == KATANA)
X		tmp += 5;
X	if(tmp < 12) return;
X
X	/* if tail then worm just loses a tail segment */
X	tmp = mtmp->wormno;
X	wtmp = wsegs[tmp];
X	if(wtmp->wx == x && wtmp->wy == y){
X		wsegs[tmp] = wtmp->nseg;
X		remseg(wtmp);
X		return;
X	}
X
X	/* cut the worm in two halves */
X	mtmp2 = newmonst(0);
X	*mtmp2 = *mtmp;
X	mtmp2->mxlth = mtmp2->mnamelth = 0;
X
X	/* sometimes the tail end dies */
X	if(rn2(3) || !getwn(mtmp2)){
X		monfree(mtmp2);
X		tmp2 = 0;
X	} else {
X		tmp2 = mtmp2->wormno;
X		wsegs[tmp2] = wsegs[tmp];
X		wgrowtime[tmp2] = 0;
X	}
X	do {
X		if(wtmp->nseg->wx == x && wtmp->nseg->wy == y){
X			if(tmp2) wheads[tmp2] = wtmp;
X			wsegs[tmp] = wtmp->nseg->nseg;
X			remseg(wtmp->nseg);
X			wtmp->nseg = 0;
X			if(tmp2){
X				pline("You cut the worm in half.");
X				mtmp2->mhpmax = mtmp2->mhp =
X					d(mtmp2->data->mlevel, 8);
X				mtmp2->mx = wtmp->wx;
X				mtmp2->my = wtmp->wy;
X				mtmp2->nmon = fmon;
X				fmon = mtmp2;
X				unpmon(mtmp2);			/* MRS */
X				pmon(mtmp2);
X			} else {
X				pline("You cut off part of the worm's tail.");
X				remseg(wtmp);
X			}
X			mtmp->mhp /= 2;
X			return;
X		}
X		wtmp2 = wtmp->nseg;
X		if(!tmp2) remseg(wtmp);
X		wtmp = wtmp2;
X	} while(wtmp->nseg);
X	panic("Cannot find worm segment");
X}
X
Xremseg(wtmp) register struct wseg *wtmp; {
X	if(wtmp->wdispl)
X		newsym(wtmp->wx, wtmp->wy);
X	free((char *) wtmp);
X}
X#endif /* NOWORM /**/
END_OF_worm.c
if test 4392 -ne `wc -c <worm.c`; then
    echo shar: \"worm.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
echo shar: End of archive 14 \(of 16\).
cp /dev/null ark14isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 16 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive. "Di "Di
