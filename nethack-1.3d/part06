Relay-Version: version B 2.10 5/3/83; site utzoo.UUCP
Path: utzoo!mnetor!uunet!seismo!rutgers!sri-spam!ames!ucbcad!zen!ucbvax!decvax!tektronix!tekgen!tekred!games-request
From: games-request@tekred.TEK.COM
Newsgroups: comp.sources.games
Subject: v02i006:  nethack - display oriented dungeons and dragons, Part06/16
Message-ID: <1448@tekred.TEK.COM>
Date: Tue, 28-Jul-87 13:48:11 EDT
Article-I.D.: tekred.1448
Posted: Tue Jul 28 13:48:11 1987
Date-Received: Thu, 30-Jul-87 06:48:34 EDT
Sender: billr@tekred.TEK.COM
Lines: 1941
Approved: billr@tekred.TEK.COM

Submitted by: mike@genat.UUCP (Mike Stephenson)
Comp.sources.games: Volume 2, Issue 6
Archive-name: nethack/Part06



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 6 (of 16)."
# Contents:  fight.c mkmaze.c objects.h read.c
# Wrapped by billr@tekred on Tue Jul 28 09:49:28 1987
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f fight.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"fight.c\"
else
echo shar: Extracting \"fight.c\" \(15365 characters\)
sed "s/^X//" >fight.c <<'END_OF_fight.c'
X/*	SCCS Id: @(#)fight.c	1.3	87/07/14
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* fight.c - version 1.0.3 */
X
X#include	<stdio.h>
X#include	"hack.h"
X
Xextern struct permonst li_dog, dog, la_dog;
Xextern char *exclam(), *hcolor(), *xname();
Xextern struct obj *mkobj_at();
X#ifdef KAA
Xextern boolean stoned;
Xextern boolean unweapon;
Xextern char *nomovemsg, *defmonnam();
Xextern struct monst *mkmon_at();
X#endif
X
Xstatic boolean far_noise;
Xstatic long noisetime;
X
X/* hitmm returns 0 (miss), 1 (hit), or 2 (kill) */
Xhitmm(magr,mdef) register struct monst *magr,*mdef; {
Xregister struct permonst *pa = magr->data, *pd = mdef->data;
Xint hit;
Xschar tmp;
Xboolean vis;
X	if(index("Eauy", pa->mlet)) return(0);
X	if(magr->mfroz) return(0);		/* riv05!a3 */
X	tmp = pd->ac + pa->mlevel;
X	if(mdef->mconf || mdef->mfroz || mdef->msleep){
X		tmp += 4;
X		if(mdef->msleep) mdef->msleep = 0;
X	}
X	hit = (tmp > rnd(20));
X	if(hit) mdef->msleep = 0;
X	vis = (cansee(magr->mx,magr->my) && cansee(mdef->mx,mdef->my));
X	if(vis){
X		char buf[BUFSZ];
X		if(mdef->mimic) seemimic(mdef);
X		if(magr->mimic) seemimic(magr);
X		(void) sprintf(buf,"%s %s", Monnam(magr),
X			hit ? "hits" : "misses");
X		pline("%s %s.", buf, monnam(mdef));
X	} else {
X		boolean farq = (dist(magr->mx, magr->my) > 15);
X		if(farq != far_noise || moves-noisetime > 10) {
X			far_noise = farq;
X			noisetime = moves;
X			pline("You hear some noises%s.",
X				farq ? " in the distance" : "");
X		}
X	}
X	if(hit){
X		if(magr->data->mlet == 'c' && !magr->cham) {
X			magr->mhpmax += 3;
X			if(vis) pline("%s is turned to stone!", Monnam(mdef));
X			else if(mdef->mtame)
X     pline("You have a peculiarly sad feeling for a moment, then it passes.");
X			monstone(mdef);
X			hit = 2;
X		} else
X		if((mdef->mhp -= d(pa->damn,pa->damd)) < 1) {
X			magr->mhpmax += 1 + rn2(pd->mlevel+1);
X			if(magr->mtame && magr->mhpmax > 8*pa->mlevel){
X				if(pa == &li_dog) magr->data = pa = &dog;
X				else if(pa == &dog) magr->data = pa = &la_dog;
X			}
X			if(vis) pline("%s is killed!", Monnam(mdef));
X			else if(mdef->mtame)
X		pline("You have a sad feeling for a moment, then it passes.");
X			mondied(mdef);
X			hit = 2;
X		}
X		/* fixes a bug where max monster hp could overflow. */
X		if(magr->mhpmax <= 0) magr->mhpmax = 127;
X	}
X#ifdef KAA
X	if(hit == 1 && magr->data->mlet == 'Q') {
X		rloc(mdef);
X		if(vis && !cansee(mdef->mx,mdef->my))
X			pline("%s suddenly disappears!",Monnam(mdef));
X	}
X#endif
X	return(hit);
X}
X
X/* drop (perhaps) a cadaver and remove monster */
Xmondied(mdef) register struct monst *mdef; {
Xregister struct permonst *pd = mdef->data;
X#ifdef KOPS
X	if(letter(pd->mlet) && rn2(3) && pd->mlet != 'K'){
X#else
X	if(letter(pd->mlet) && rn2(3)){
X#endif
X		if (pd->mlet == '1') panic("mondied: making obj '1'");
X		(void) mkobj_at(pd->mlet,mdef->mx,mdef->my);
X		if(cansee(mdef->mx,mdef->my)){
X			unpmon(mdef);
X			atl(mdef->mx,mdef->my,fobj->olet);
X		}
X		stackobj(fobj);
X	}
X	mondead(mdef);
X}
X
X/* drop a rock and remove monster */
Xmonstone(mdef) register struct monst *mdef; {
X	extern char mlarge[];
X	if(index(mlarge, mdef->data->mlet))
X		mksobj_at(ENORMOUS_ROCK, mdef->mx, mdef->my);
X	else
X		mksobj_at(ROCK, mdef->mx, mdef->my);
X	if(cansee(mdef->mx, mdef->my)){
X		unpmon(mdef);
X		atl(mdef->mx,mdef->my,fobj->olet);
X	}
X	mondead(mdef);
X}
X		
X
Xfightm(mtmp) register struct monst *mtmp; {
Xregister struct monst *mon;
X	for(mon = fmon; mon; mon = mon->nmon) if(mon != mtmp) {
X		if(DIST(mon->mx,mon->my,mtmp->mx,mtmp->my) < 3)
X		    if(rn2(4))
X			return(hitmm(mtmp,mon));
X	}
X	return(-1);
X}
X
X/* u is hit by sth, but not a monster */
Xthitu(tlev,dam,name)
Xregister tlev,dam;
Xregister char *name;
X{
Xchar buf[BUFSZ];
X	setan(name,buf);
X	if(u.uac + tlev <= rnd(20)) {
X		if(Blind) pline("It misses.");
X		else pline("You are almost hit by %s!", buf);
X		return(0);
X	} else {
X		if(Blind) pline("You are hit!");
X		else pline("You are hit by %s!", buf);
X		losehp(dam,name);
X		return(1);
X	}
X}
X
X#ifdef KAA
Xchar mlarge[] = "bCDdegIlmnoPSsTUwY',&9";
X#else
Xchar mlarge[] = "bCDdegIlmnoPSsTUwY',&";
X#endif
X
Xboolean
Xhmon(mon,obj,thrown)	/* return TRUE if mon still alive */
Xregister struct monst *mon;
Xregister struct obj *obj;
Xregister thrown;
X{
X	register tmp;
X	boolean hittxt = FALSE;
X
X#ifdef KAA
X	stoned = FALSE;		/* this refers to the thing hit, not you */
X#endif
X	if(!obj){
X#ifdef KAA
X/* Note that c, y, and F can never wield weapons anyway */
X	  if (u.usym == 'c' && mon->data->mlet != 'c') {
X	       pline("You turn %s to stone!", monnam(mon));
X	       stoned = TRUE;
X	       xkilled(mon,0);
X	       return(FALSE);
X	  } else if (u.usym == 'y' && mon->data->mlet != 'y') {
X	       pline("%s is blinded by your flash of light!",Monnam(mon));
X	       if (!mon->mblinded) {
X		    mon->mblinded += rn2(25);
X		    mon->mcansee = 0;
X	       }
X	       rehumanize();
X	       return(TRUE);
X	  } else if (u.usym == 'F') {
X	       pline("You explode!");
X	       if (!index("gFY",mon->data->mlet)) {
X		    pline("%s gets blasted!", Monnam(mon));
X		    mon->mhp -= d(6,6);
X		    rehumanize();
X		    if (mon->mhp <= 0) {
X			 killed(mon);
X			 return(FALSE);
X		    } else return(TRUE);
X	       } else {
X		    pline("The blast doesn't seem to affect %s.", monnam(mon));
X		    rehumanize();
X		    return(TRUE);
X	       }
X	  } else if (index("P,'", u.usym) && u.uhunger < 1500
X		  && !u.uswallow && mon->data->mlet != 'c') {
X	       static char msgbuf[BUFSZ];
X	       pline("You swallow %s whole!", monnam(mon));
X	       u.uhunger += 20*mon->mhpmax;
X	       newuhs(FALSE);
X	       xkilled(mon,2);
X	       if (tmp = mon->mhpmax/5) {
X		    nomul(-tmp);
X		    (void)sprintf(msgbuf, "You finished digesting %s.",
X			 monnam(mon));
X		    nomovemsg = msgbuf;
X	       }
X	       return(FALSE);
X	  } else if (u.usym != '@') {
X	       if (u.usym == '&' && !rn2(5)) {
X		    struct monst *dtmp;
X		    pline("Some hell-p has arrived!");
X		    dtmp = mkmon_at('&',u.ux,u.uy);
X		    (void)tamedog(dtmp,(struct obj *)0);
X	       }
X	       tmp = d(mons[u.umonnum].damn, mons[u.umonnum].damd);
X	  } else
X#endif
X		tmp = rnd(2);	/* attack with bare hands */
X#ifdef KAA
X		if (mon->data->mlet == 'c' && !uarmg && u.usym != 'c'){
X#else
X		if(mon->data->mlet == 'c' && !uarmg){
X#endif
X			pline("You hit the cockatrice with your bare hands.");
X			pline("You turn to stone ...");
X			done_in_by(mon);
X		}
X	} else if(obj->olet == WEAPON_SYM || obj->otyp == PICK_AXE) {
X	    if(obj == uwep && (obj->otyp > SPEAR || obj->otyp < BOOMERANG))
X		tmp = rnd(2);
X	    else {
X		if(index(mlarge, mon->data->mlet)) {
X		    tmp = rnd(objects[obj->otyp].wldam);
X		    switch (obj->otyp) {
X			case SLING_BULLET:
X			case CROSSBOW_BOLT:
X			case MORNING_STAR:
X			case PARTISAN:
X			case BROAD_SWORD:	tmp += 1; break;
X
X			case FLAIL:
X			case RANSEUR:
X			case VOULGE:		tmp += rnd(4); break;
X
X			case HALBERD:
X			case SPETUM:		tmp += rnd(6); break;
X
X			case BARDICHE:
X			case TRIDENT:		tmp += d(2,4); break;
X
X			case TWO_HANDED_SWORD: 
X			case KATANA: 		tmp += d(2,6); break;
X		    }
X		} else {
X		    tmp = rnd(objects[obj->otyp].wsdam);
X		    switch (obj->otyp) {
X			case SLING_BULLET:
X			case CROSSBOW_BOLT:
X			case MACE:
X			case FLAIL:
X			case SPETUM:
X			case TRIDENT:		tmp += 1; break;
X
X			case BARDICHE:
X			case BILL_GUISARME:
X			case GUISARME:
X			case LUCERN_HAMMER:
X			case MORNING_STAR:
X			case RANSEUR:
X			case BROAD_SWORD:
X			case VOULGE:		tmp += rnd(4); break;
X		    }
X		}
X		tmp += obj->spe;
X#ifdef KAA
X		if(obj->olet == WEAPON_SYM && obj->dknown && index("VWZ &",
X				mon->data->mlet)) tmp += rn2(4);
X#endif
X		if(!thrown && obj == uwep && obj->otyp == BOOMERANG
X		 && !rn2(3)){
X		  pline("As you hit %s, the boomerang breaks into splinters.",
X				monnam(mon));
X			freeinv(obj);
X			setworn((struct obj *) 0, obj->owornmask);
X			obfree(obj, (struct obj *) 0);
X			tmp++;
X		}
X	    }
X	    if(mon->data->mlet == 'O' && obj->otyp == TWO_HANDED_SWORD &&
X		!strcmp(ONAME(obj), "Orcrist"))
X		tmp += rnd(10);
X	} else	switch(obj->otyp) {
X		case HEAVY_IRON_BALL:
X			tmp = rnd(25); break;
X		case ENORMOUS_ROCK:
X			tmp = rnd(20); break;
X		case EXPENSIVE_CAMERA:
X	pline("You succeed in destroying your camera. Congratulations!");
X			freeinv(obj);
X			if(obj->owornmask)
X				setworn((struct obj *) 0, obj->owornmask);
X			obfree(obj, (struct obj *) 0);
X			return(TRUE);
X		case DEAD_COCKATRICE:
X			pline("You hit %s with the cockatrice corpse.",
X				monnam(mon));
X			if(mon->data->mlet == 'c') {
X				tmp = 1;
X				hittxt = TRUE;
X#ifdef KAA
X				stoned = TRUE;
X				xkilled(mon,0);
X#endif
X				break;
X			}
X			pline("%s is turned to stone!", Monnam(mon));
X			killed(mon);
X			return(FALSE);
X		case CLOVE_OF_GARLIC:		/* no effect against demons */
X			if(index(UNDEAD, mon->data->mlet))
X				mon->mflee = 1;
X			tmp = 1;
X			break;
X		default:
X			/* non-weapons can damage because of their weight */
X			/* (but not too much) */
X			tmp = obj->owt/10;
X			if(tmp < 1) tmp = 1;
X			else tmp = rnd(tmp);
X			if(tmp > 6) tmp = 6;
X		}
X
X	/****** NOTE: perhaps obj is undefined!! (if !thrown && BOOMERANG) */
X
X	tmp += u.udaminc + dbon();
X	if(u.uswallow) {
X		if((tmp -= u.uswldtim) <= 0) {
X			pline("Your arms are no longer able to hit.");
X			return(TRUE);
X		}
X	}
X	if(tmp < 1) tmp = 1;
X	mon->mhp -= tmp;
X	if(mon->mhp < 1) {
X		killed(mon);
X		return(FALSE);
X	}
X	if(mon->mtame && (!mon->mflee || mon->mfleetim)) {
X		mon->mflee = 1;			/* Rick Richardson */
X		mon->mfleetim += 10*rnd(tmp);
X	}
X
X	if(!hittxt) {
X		if(thrown)
X			/* this assumes that we cannot throw plural things */
X			hit( xname(obj)  /* or: objects[obj->otyp].oc_name */,
X				mon, exclam(tmp) );
X		else if(Blind)
X			pline("You hit it.");
X		else
X			pline("You hit %s%s", monnam(mon), exclam(tmp));
X	}
X
X	if(u.umconf && !thrown) {
X		if(!Blind) {
X			pline("Your hands stop glowing %s.",
X			Hallucination ? hcolor() : "blue");
X		}
X		if (!resist(mon, '+', 0, NOTELL)) mon->mconf = 1;
X		if(!mon->mfroz && !mon->msleep && !Blind && mon->mconf)
X			pline("%s appears confused.",Monnam(mon));
X		u.umconf = 0;
X	}
X	if(!thrown && rn2(2) && index("VW",u.usym) &&
X	   !index("VW",mon->data->mlet)){
X		int tmp=d(2,6);
X		pline("%s suddenly seems weaker!",Monnam(mon));
X		mon->mhpmax -= tmp;
X		if ((mon->mhp -= tmp) <= 0) {
X			pline("%s dies!",Monnam(mon));
X			xkilled(mon,0);
X			return(FALSE);
X		}
X	}
X	return(TRUE);	/* mon still alive */
X}
X
X/* try to attack; return FALSE if monster evaded */
X/* u.dx and u.dy must be set */
Xattack(mtmp)
Xregister struct monst *mtmp;
X{
X	schar tmp;
X	boolean malive = TRUE;
X	register struct permonst *mdat;
X	mdat = mtmp->data;
X
X#ifdef KAA
X	if(unweapon) {
X		unweapon=FALSE;
X		if(uwep)
X			pline("You begin bashing monsters with your %s.",
X				aobjnam(uwep,(char *)0));
X	}
X#endif
X	u_wipe_engr(3);   /* andrew@orca: prevent unlimited pick-axe attacks */
X
X	if(mdat->mlet == 'L' && !mtmp->mfroz && !mtmp->msleep &&
X	   !mtmp->mconf && mtmp->mcansee && !rn2(7) &&
X	   (m_move(mtmp, 0) == 2 /* he died */ || /* he moved: */
X		mtmp->mx != u.ux+u.dx || mtmp->my != u.uy+u.dy))
X		return(FALSE);
X#ifdef SAFE_ATTACK
X	/* This section of code provides protection against accidentally
X	 * hitting peaceful (like '@') and tame (like 'd') monsters.
X	 * There is protection only if you're not blind, confused or
X	 * invisible.
X	 */
X	/*  changes by wwp 5/16/85 */
X	if (!Blind && !Confusion && !Hallucination
X	    && mdat->mlet == 'd' && mtmp->mtame) {
X		mtmp->mflee = 1;			
X		mtmp->mfleetim = rnd(6);
X		pline("You stop to avoid hitting your dog");
X		return(TRUE);
X	}
X	if (flags.confirm && (mtmp->mpeaceful || mtmp->mtame) && ! Confusion
X	    && !Hallucination && !Invisible)
X
X		if (Blind ? Telepat : (!mtmp->minvis || See_invisible)) {
X			pline("Really attack?");
X			(void) fflush(stdout);
X			if (readchar() != 'y') {
X				flags.move = 0;
X				return(TRUE);
X			}
X		}
X#endif /* SAFE_ATTACK /**/
X
X	if(mtmp->mimic){
X		if(!u.ustuck && !mtmp->mflee) u.ustuck = mtmp;
X#ifdef DGK
X		if (levl[u.ux+u.dx][u.uy+u.dy].scrsym == symbol.door)
X		    if (okdoor(u.ux+u.dx, u.uy+u.dy))
X			pline("The door actually was %s.", defmonnam(mtmp));
X		    else  pline("That spellbook was %s.", defmonnam(mtmp));
X		else if (levl[u.ux+u.dx][u.uy+u.dy].scrsym == '$')
X			pline("The chest was %s!", defmonnam(mtmp));
X		else
X			pline("Wait! That's %s!",defmonnam(mtmp));
X#else
X		switch(levl[u.ux+u.dx][u.uy+u.dy].scrsym){
X		case '+':
X			if (okdoor(u.ux+u.dx, u.uy+u.dy))
X				pline("The door actually was %s.", defmonnam(mtmp));
X			else	pline("That spellbook was %s.", defmonnam(mtmp));
X			break;
X		case '$':
X			pline("The chest was %s!", defmonnam(mtmp));
X			break;
X		default:
X			pline("Wait! That's %s!",defmonnam(mtmp));
X		}
X#endif
X		wakeup(mtmp);	/* clears mtmp->mimic */
X		return(TRUE);
X	}
X
X	wakeup(mtmp);
X
X	if(mtmp->mhide && mtmp->mundetected){
X		register struct obj *obj;
X
X		mtmp->mundetected = 0;
X		if((obj = o_at(mtmp->mx,mtmp->my)) && !Blind)
X			pline("Wait! There's %s hiding under %s!",
X				defmonnam(mtmp), doname(obj));
X		return(TRUE);
X	}
X#ifdef KAA
X	tmp = u.uluck + (u.mtimedone ? mons[u.umonnum].mlevel : u.ulevel) +
X			mdat->ac + abon();
X	if (u.usym=='y' || u.usym=='F') tmp=100;
X	if (index("uEa",u.usym)) return(TRUE);
X#endif
X	if(uwep) {
X#ifdef KAA	/* Blessed weapons used against undead or demons */
X		if(uwep->olet == WEAPON_SYM && uwep->dknown && index("VWZ &",
X			mtmp->data->mlet)) tmp += 2;
X#endif
X		if(uwep->olet == WEAPON_SYM || uwep->otyp == PICK_AXE)
X			tmp += uwep->spe;
X		if(uwep->otyp == TWO_HANDED_SWORD) tmp -= 1;
X		else if(uwep->otyp == KATANA) tmp += 1;
X		else if(uwep->otyp == DAGGER ||
X			uwep->otyp == SHURIKEN) tmp += 2;
X		else if(uwep->otyp == CRYSKNIFE) tmp += 3;
X		else if(uwep->otyp == SPEAR &&
X			index("XDne", mdat->mlet)) tmp += 2;
X	}
X	if(mtmp->msleep) {
X		mtmp->msleep = 0;
X		tmp += 2;
X	}
X	if(mtmp->mfroz) {
X		tmp += 4;
X		if(!rn2(10)) mtmp->mfroz = 0;
X	}
X	if(mtmp->mflee) tmp += 2;
X	if(u.utrap) tmp -= 3;
X
X	/* with a lot of luggage, your agility diminishes */
X	tmp -= (inv_weight() + 40)/20;
X
X	if(tmp <= rnd(20) && !u.uswallow){
X		if(Blind) pline("You miss it.");
X		else pline("You miss %s.",monnam(mtmp));
X	} else {
X		/* we hit the monster; be careful: it might die! */
X
X		if((malive = hmon(mtmp,uwep,0)) == TRUE) {
X		/* monster still alive */
X			if(!rn2(25) && mtmp->mhp < mtmp->mhpmax/2) {
X				mtmp->mflee = 1;
X				if(!rn2(3)) mtmp->mfleetim = rnd(100);
X				if(u.ustuck == mtmp && !u.uswallow)
X					u.ustuck = 0;
X			}
X#ifndef NOWORM
X			if(mtmp->wormno)
X				cutworm(mtmp, u.ux+u.dx, u.uy+u.dy,
X					uwep ? uwep->otyp : 0);
X#endif
X		}
X		if(mdat->mlet == 'a') {
X			if(rn2(2)) {
X				if (Blind) pline("You are splashed!");
X				else	   pline("You are splashed by %s's acid!",monnam(mtmp));
X				if (u.usym != 'a') {
X					losehp_m(rnd(6), mtmp);
X					if(!rn2(30)) corrode_armor();
X				}
X			}
X			if(!rn2(6)) corrode_weapon();
X		}
X	}
X#ifdef KAA
X	if (malive) if (u.usym=='N' && mtmp->minvent) {
X		struct obj *otmp, *addinv();
X		otmp = mtmp->minvent;
X		mtmp->minvent = otmp->nobj;
X		otmp = addinv(otmp);
X		pline("You steal:");
X		prinv(otmp);
X	} else if (u.usym=='L' && mtmp->mgold) {
X		u.ugold += mtmp->mgold;
X		mtmp->mgold = 0;
X		pline("Your purse feels heavier.");
X	} else if (u.usym=='Q') rloc(mtmp);
X#endif
X	if(malive && mdat->mlet == 'E' && canseemon(mtmp)
X	   && !mtmp->mcan && rn2(3)) {
X	    if(mtmp->mcansee) {
X	      pline("You are frozen by %s's gaze!",monnam(mtmp));
X	      nomul((u.ulevel > 6 || rn2(4)) ? rn1(20,-21) : -200);
X	    } else {
X	      pline("%s cannot defend itself.", Amonnam(mtmp,"blinded"));
X	      if(!rn2(500)) if((int)u.uluck > LUCKMIN) u.uluck--;
X	    }
X	}
X	return(TRUE);
X}
END_OF_fight.c
if test 15365 -ne `wc -c <fight.c`; then
    echo shar: \"fight.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f mkmaze.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"mkmaze.c\"
else
echo shar: Extracting \"mkmaze.c\" \(4084 characters\)
sed "s/^X//" >mkmaze.c <<'END_OF_mkmaze.c'
X/*	SCCS Id: @(#)mkmaze.c	1.3	87/07/14
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* mkmaze.c - version 1.0.2 */
X
X#include "hack.h"
X#include "mkroom.h"		/* not really used */
Xextern struct monst *makemon();
Xextern struct permonst pm_wizard;
Xextern struct obj *mkobj_at();
Xextern coord mazexy();
Xstruct permonst hell_hound =
X	{ "hell hound", 'd', 12, 14, 2, 20, 3, 6, 0 };
X
Xmakemaz()
X{
X	int x,y;
X	register zx,zy;
X	coord mm;
X	boolean al = (dlevel >= 30 && !flags.made_amulet);
X
X	for(x = 2; x < COLNO-1; x++)
X		for(y = 2; y < ROWNO-1; y++)
X			levl[x][y].typ = (x%2 && y%2) ? 0 : HWALL;
X	if(al) {
X	    register struct monst *mtmp;
X
X	    zx = 2*(COLNO/4) - 1;
X	    zy = 2*(ROWNO/4) - 1;
X	    for(x = zx-2; x < zx+4; x++) for(y = zy-2; y <= zy+2; y++) {
X		levl[x][y].typ =
X		    (y == zy-2 || y == zy+2 || x == zx-2 || x == zx+3) ? POOL :
X		    (y == zy-1 || y == zy+1 || x == zx-1 || x == zx+2) ? HWALL:
X		    ROOM;
X	    }
X	    (void) mkobj_at(AMULET_SYM, zx, zy);
X	    flags.made_amulet = 1;
X	    walkfrom(zx+4, zy);
X	    if(mtmp = makemon(&hell_hound, zx, zy))
X		mtmp->msleep = 1;
X	    if(mtmp = makemon(PM_WIZARD, zx+1, zy)) {
X		mtmp->msleep = 1;
X		flags.no_of_wizards = 1;
X	    }
X	} else {
X	    mm = mazexy();
X	    zx = mm.x;
X	    zy = mm.y;
X	    walkfrom(zx,zy);
X	    (void) mksobj_at(WAN_WISHING, zx, zy);
X	    (void) mkobj_at(ROCK_SYM, zx, zy);	/* put a rock on top of it */
X	}
X
X	for(x = 2; x < COLNO-1; x++)
X		for(y = 2; y < ROWNO-1; y++) {
X			switch(levl[x][y].typ) {
X#ifdef DGK
X			case HWALL:
X				levl[x][y].scrsym = symbol.hwall;
X				break;
X			case ROOM:
X				levl[x][y].scrsym = symbol.room;
X				break;
X#else
X			case HWALL:
X				levl[x][y].scrsym = '-';
X				break;
X			case ROOM:
X				levl[x][y].scrsym = '.';
X				break;
X#endif /* DGK /**/
X			}
X		}
X	for(x = rn1(8,11); x; x--) {
X		mm = mazexy();
X		(void) mkobj_at(rn2(2) ? GEM_SYM : 0, mm.x, mm.y);
X	}
X	for(x = rn1(10,2); x; x--) {
X		mm = mazexy();
X		(void) mkobj_at(ROCK_SYM, mm.x, mm.y);
X	}
X	mm = mazexy();
X	(void) makemon(PM_MINOTAUR, mm.x, mm.y);
X	for(x = rn1(5,7); x; x--) {
X		mm = mazexy();
X		(void) makemon((struct permonst *) 0, mm.x, mm.y);
X	}
X	for(x = rn1(6,7); x; x--) {
X		mm = mazexy();
X		mkgold(0L,mm.x,mm.y);
X	}
X	for(x = rn1(6,7); x; x--)
X		mktrap(0,1,(struct mkroom *) 0);
X	mm = mazexy();
X	levl[(xupstair = mm.x)][(yupstair = mm.y)].scrsym = '<';
X	levl[xupstair][yupstair].typ = STAIRS;
X	xdnstair = ydnstair = 0;
X}
X
X#ifdef DGK
X/* Make the mazewalk iterative by faking a stack.  This is needed to
X * ensure the mazewalk is successful in the limited stack space of
X * the program.  This iterative version uses the mimumum amount of stack
X * that is totally safe.
X */
Xwalkfrom(x,y)
Xint x,y;
X{
X#define CELLS (ROWNO * COLNO) / 4		/* a maze cell is 4 squares */
X	char mazex[CELLS + 1], mazey[CELLS + 1];	/* char's are OK */
X	int q, a, dir, pos;
X	int dirs[4];
X
X	pos = 1;
X	mazex[pos] = (char) x;
X	mazey[pos] = (char) y;
X	while (pos) {
X		x = (int) mazex[pos];
X		y = (int) mazey[pos];
X		levl[x][y].typ = ROOM;
X		q = 0;
X		for (a = 0; a < 4; a++)
X			if(okay(x, y, a)) dirs[q++]= a;
X		if (!q)
X			pos--;
X		else {
X			dir = dirs[rn2(q)];
X			move(&x, &y, dir);
X			levl[x][y].typ = ROOM;
X			move(&x, &y, dir);
X			pos++;
X			if (pos > CELLS)
X				panic("Overflow in walkfrom");
X			mazex[pos] = (char) x;
X			mazey[pos] = (char) y;
X		}
X	}
X}
X#else
X
Xwalkfrom(x,y) int x,y; {
Xregister int q,a,dir;
Xint dirs[4];
X	levl[x][y].typ = ROOM;
X	while(1) {
X		q = 0;
X		for(a = 0; a < 4; a++)
X			if(okay(x,y,a)) dirs[q++]= a;
X		if(!q) return;
X		dir = dirs[rn2(q)];
X		move(&x,&y,dir);
X		levl[x][y].typ = ROOM;
X		move(&x,&y,dir);
X		walkfrom(x,y);
X	}
X}
X#endif /* DGK /**/
X
Xmove(x,y,dir)
Xregister int *x, *y;
Xregister int dir;
X{
X	switch(dir){
X		case 0: --(*y); break;
X		case 1: (*x)++; break;
X		case 2: (*y)++; break;
X		case 3: --(*x); break;
X	}
X}
X
Xokay(x,y,dir)
Xint x,y;
Xregister int dir;
X{
X	move(&x,&y,dir);
X	move(&x,&y,dir);
X	if(x<3 || y<3 || x>COLNO-3 || y>ROWNO-3 || levl[x][y].typ != 0)
X		return(0);
X	else
X		return(1);
X}
X
Xcoord
Xmazexy(){
X	coord mm;
X	mm.x = 3 + 2*rn2(COLNO/2 - 2);
X	mm.y = 3 + 2*rn2(ROWNO/2 - 2);
X	return mm;
X}
END_OF_mkmaze.c
if test 4084 -ne `wc -c <mkmaze.c`; then
    echo shar: \"mkmaze.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f objects.h -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"objects.h\"
else
echo shar: Extracting \"objects.h\" \(15108 characters\)
sed "s/^X//" >objects.h <<'END_OF_objects.h'
X/*	SCCS Id: @(#)objects.h	1.3	87/07/14
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* def.objects.h - version 1.0.3 */
X
X/* objects have letter " % ) ( 0 _ ` [ ! ? / = * + */
X#include "config.h"
X#include "objclass.h"
X#define	NULL	(char *)0
X
Xstruct objclass objects[] = {
X
X	{ "strange object", NULL, NULL, 1, 0,
X		ILLOBJ_SYM, 0, 0, 0, 0, 0, 0 },
X	{ "amulet of Yendor", NULL, NULL, 1, 0,
X		AMULET_SYM, 100, 0, 2, 0, 0, 0 },
X
X#define	FOOD(name,prob,delay,weight,nutrition)	{ name, NULL, NULL, 1, 1,\
X		FOOD_SYM, prob, delay, weight, 0, 0, nutrition }
X
X/* dog eats foods 0-4 but prefers 1 above 0,2,3,4 */
X/* food 4 can be read */
X/* food 5 improves your vision */
X/* food 6 makes you stronger (like Popeye) */
X/* foods CORPSE up to CORPSE+52 are cadavers */
X
X	FOOD("food ration", 	46, 5, 4, 800),
X	FOOD("tripe ration",	16, 1, 2, 200),
X	FOOD("pancake",		3, 1, 1, 200),
X	FOOD("dead lizard",	3, 0, 1, 40),
X	FOOD("fortune cookie",	7, 0, 1, 40),
X	FOOD("carrot",		2, 0, 1, 50),
X	FOOD("slice of pizza",	5, 0, 1, 250),
X	FOOD("cream pie",	3, 0, 1, 100),
X	FOOD("tin",		7, 0, 1, 0),
X	FOOD("orange",		1, 0, 1, 80),
X	FOOD("apple",		1, 0, 1, 50),
X	FOOD("pear",		1, 0, 1, 50),
X	FOOD("melon",		1, 0, 1, 100),
X	FOOD("banana",		1, 0, 1, 80),
X	FOOD("candy bar",	1, 0, 1, 100),
X	FOOD("egg",		1, 0, 1, 80),
X	FOOD("clove of garlic",	1, 0, 1, 40),
X	FOOD("lump of royal jelly", 0, 0, 1, 200),
X
X	FOOD("dead human",	0, 4, 40, 400),
X	FOOD("dead giant ant",	0, 1, 3, 30),
X	FOOD("dead giant bat",	0, 1, 3, 30),
X	FOOD("dead centaur",	0, 5, 50, 500),
X	FOOD("dead dragon",	0, 15, 150, 1500),
X	FOOD("dead floating eye",	0, 1, 1, 10),
X	FOOD("dead freezing sphere",	0, 1, 1, 10),
X	FOOD("dead gnome",	0, 1, 10, 100),
X	FOOD("dead hobgoblin",	0, 2, 20, 200),
X	FOOD("dead stalker",	0, 4, 40, 400),
X	FOOD("dead jackal",	0, 1, 10, 100),
X	FOOD("dead kobold",	0, 1, 10, 100),
X	FOOD("dead leprechaun",	0, 4, 40, 400),
X	FOOD("dead mimic",	0, 4, 40, 400),
X	FOOD("dead nymph",	0, 4, 40, 400),
X	FOOD("dead orc",	0, 2, 20, 200),
X	FOOD("dead purple worm",	0, 7, 70, 700),
X	FOOD("dead quantum mechanic", 0, 2, 20, 200),
X	FOOD("dead rust monster",	0, 5, 50, 500),
X	FOOD("dead snake",	0, 1, 10, 100),
X	FOOD("dead troll",	0, 4, 40, 400),
X	FOOD("dead umber hulk",	0, 5, 50, 500),
X	FOOD("dead vampire",	0, 4, 40, 400),
X	FOOD("dead wraith",	0, 1, 1, 10),
X	FOOD("dead xorn",	0, 7, 70, 700),
X	FOOD("dead yeti",	0, 7, 70, 700),
X	FOOD("dead zombie",	0, 1, 3, 30),
X	FOOD("dead acid blob",	0, 1, 3, 30),
X	FOOD("dead giant beetle",	0, 1, 1, 10),
X	FOOD("dead cockatrice",	0, 1, 3, 30),
X	FOOD("dead dog",	0, 2, 20, 200),
X	FOOD("dead ettin",	0, 1, 3, 30),
X	FOOD("dead fog cloud",	0, 1, 1, 10),
X	FOOD("dead gelatinous cube",	0, 1, 10, 100),
X	FOOD("dead homunculus",	0, 2, 20, 200),
X	FOOD("dead imp",	0, 1, 1, 10),
X	FOOD("dead jaguar",	0, 3, 30, 300),
X	FOOD("dead killer bee",	0, 1, 1, 10),
X	FOOD("dead leocrotta",	0, 5, 50, 500),
X	FOOD("dead minotaur",	0, 7, 70, 700),
X	FOOD("dead nurse",	0, 4, 40, 400),
X	FOOD("dead owlbear",	0, 7, 70, 700),
X	FOOD("dead piercer",	0, 2, 20, 200),
X	FOOD("dead quivering blob",	0, 1, 10, 100),
X	FOOD("dead giant rat",	0, 1, 3, 30),
X	FOOD("dead giant scorpion",	0, 1, 10, 100),
X	FOOD("dead tengu",	0, 3, 30, 300),
X	FOOD("dead unicorn",	0, 3, 30, 300),
X	FOOD("dead violet fungus",	0, 1, 10, 100),
X	FOOD("dead long worm",	0, 5, 50, 500),
X/* %% wt of long worm should be proportional to its length */
X	FOOD("dead xan",	0, 3, 30, 300),
X	FOOD("dead yellow light",	0, 1, 1, 10),
X	FOOD("dead zruty",	0, 6, 60, 600),
X	FOOD("dead giant",	0, 7, 70, 700),
X	FOOD("dead demon",	0, 8, 80, 800),
X
X/* weapons ... - ROCK come several at a time */
X/* weapons ... - (DART-1) are shot using idem+(BOW-ARROW) */
X/* weapons AXE, SWORD, KATANA, THSWORD are good for worm-cutting */
X/* weapons (PICK-)AXE, DAGGER, CRYSKNIFE are good for tin-opening */
X#define WEAPON(name,prob,wt,sdam,ldam)	{ name, NULL, NULL, 1, 0 /*%%*/,\
X		WEAPON_SYM, prob, 0, wt, sdam, ldam, 0 }
X
X/* Note: for weapons that don't do an even die of damage (i.e. 2-7 or 3-18)
X * the extra damage is added on in fight.c, not here! */
X
X	WEAPON("arrow",		6, 0, 6, 6),
X	WEAPON("sling bullet",	6, 0, 4, 6),
X	WEAPON("crossbow bolt",	6, 0, 4, 6),
X	WEAPON("dart",		6, 0, 3, 2),
X	WEAPON("shuriken",	3, 0, 8, 6),
X	WEAPON("rock",		4, 1, 3, 3),
X	WEAPON("boomerang",	1, 3, 9, 9),
X	WEAPON("mace",		6, 3, 6, 7), /* +1 small */
X	WEAPON("axe",		5, 3, 6, 4),
X	WEAPON("flail",		5, 3, 6, 5), /* +1 small, +1d4 large */
X	WEAPON("long sword",	5, 3, 8, 12),
X	WEAPON("two handed sword",	4, 4, 12, 6), /* +2d6 large */
X	WEAPON("dagger",	4, 3, 4, 3),
X	WEAPON("worm tooth",	0, 4, 2, 2),
X	WEAPON("crysknife",	0, 3, 10, 10),
X	WEAPON("aklys",		1, 3, 6, 3), 
X	WEAPON("bardiche",	1, 3, 4, 4), /* +1d4 small, +2d4 large */
X	WEAPON("bec de corbin",	1, 3, 8, 6),
X	WEAPON("bill-guisarme",	1, 3, 4, 10), /* +1d4 small */
X	WEAPON("club",		1, 3, 6, 3),
X	WEAPON("fauchard",	1, 3, 6, 8),
X	WEAPON("glaive",	1, 3, 6, 10),
X	WEAPON("guisarme",	1, 3, 4, 8), /* +1d4 small */
X	WEAPON("halberd",	1, 3, 10, 6), /* +1d6 large */
X	WEAPON("lucern hammer",	1, 3, 4, 6), /* +1d4 small */
X	WEAPON("javelin",	1, 3, 6, 6),
X	WEAPON("katana",	1, 3, 12, 12),
X	WEAPON("lance",		1, 3, 6, 8),
X	WEAPON("morning star",	1, 3, 4, 6), /* +d4 small, +1 large */
X	WEAPON("partisan",	1, 3, 6, 6), /* +1 large */
X	WEAPON("ranseur",	1, 3, 4, 4), /* +d4 both */
X	WEAPON("scimitar",	1, 3, 8, 8), 
X	WEAPON("spetum",	1, 3, 6, 6), /* +1 small, +d6 large */
X	WEAPON("broad sword",	1, 3, 4, 6), /* +d4 small, +1 large */
X	WEAPON("short sword",	1, 3, 6, 8),
X	WEAPON("trident",	1, 3, 6, 4), /* +1 small, +2d4 large */
X	WEAPON("voulge",	1, 3, 4, 4), /* +d4 both */
X	WEAPON("spear",		4, 3, 6, 8),
X	WEAPON("bow",		4, 3, 4, 6),
X	WEAPON("sling",		4, 3, 6, 6),
X	WEAPON("crossbow",	5, 3, 4, 6),
X
X#ifdef WALKIES
X	{ "whistle", "whistle", NULL, 0, 0, TOOL_SYM, 70, 0, 2, 0, 0, 0 },
X	{ "leash", NULL, NULL, 1, 0, TOOL_SYM, 20, 0, 20, 0, 0, 0 },
X#else
X	{ "whistle", "whistle", NULL, 0, 0, TOOL_SYM, 90, 0, 2, 0, 0, 0 },
X	{ "leash", NULL, NULL, 1, 0, TOOL_SYM, 0, 0, 20, 0, 0, 0 },
X#endif
X	{ "magic whistle", "whistle", NULL, 0, 0,
X		TOOL_SYM, 10, 0, 2, 0, 0, 0 },
X	{ "expensive camera", NULL, NULL, 1, 1,
X		TOOL_SYM, 0, 0, 3, 0, 0, 0 },
X	{ "ice box", "large box", NULL, 0, 0,
X		TOOL_SYM, 0, 0, 40, 0, 0, 0 },
X	{ "pick-axe", NULL, NULL, 1, 1,
X		TOOL_SYM, 0, 0, 5, 6, 3, 0 },
X	{ "magic marker", NULL, NULL, 1, 0,
X		TOOL_SYM, 0, 0, 1, 0, 0, 0 },
X	{ "stethoscope", NULL, NULL, 1, 0,
X		TOOL_SYM, 0, 0, 3, 0, 0, 0 },
X	{ "can opener", NULL, NULL, 1, 1,
X		TOOL_SYM, 0, 0, 1, 0, 0, 0 },
X	{ "heavy iron ball", NULL, NULL, 1, 0,
X		BALL_SYM, 100, 0, 20, 0, 0, 0 },
X	{ "iron chain", NULL, NULL, 1, 0,
X		CHAIN_SYM, 100, 0, 20, 0, 0, 0 },
X#ifdef KAA
X	/* Because giants can throw rocks */
X	{ "enormous rock", NULL, NULL, 1, 0,
X		ROCK_SYM, 100, 0, 200 /* > MAX_CARR_CAP */, 0, 20, 20 },
X#else
X	{ "enormous rock", NULL, NULL, 1, 0,
X		ROCK_SYM, 100, 0, 250 /* > MAX_CARR_CAP */, 0, 0, 0 },
X#endif
X
X#define ARMOR(name,prob,delay,weight,ac,can)	{ name, NULL, NULL, 1, 0,\
X		ARMOR_SYM, prob, delay, weight, ac, can, 0 }
X/* Originally, weight was always 8, which is ridiculous.  (Plate mail weighs
X   the same as a pair of gloves?) */
X	ARMOR("helmet",			 3, 1, 2, 9, 0),
X	ARMOR("plate mail",		 5, 5, 9, 3, 2),
X	ARMOR("splint mail",		 7, 5, 8, 4, 1),
X	ARMOR("banded mail",		 9, 5, 8, 4, 0),
X	ARMOR("chain mail",		10, 5, 6, 5, 1),
X	ARMOR("scale mail",		10, 5, 5, 6, 0),
X	ARMOR("ring mail",		12, 5, 3, 7, 0),
X	/* the armors below do not rust */
X	ARMOR("studded leather armor",	12, 3, 3, 7, 1),
X	ARMOR("elfin chain mail",	 1, 1, 2, 5, 3),
X	ARMOR("bronze plate mail",	 6, 5, 9, 4, 0),
X	ARMOR("crystal plate mail",	 1, 5, 9, 3, 2),
X	ARMOR("leather armor",		15, 3, 2, 8, 0),
X	ARMOR("elven cloak",		 5, 0, 2, 9, 3),
X	ARMOR("shield",			 3, 0, 2, 9, 0),
X	ARMOR("pair of gloves",		 1, 1, 2, 9, 0),
X
X#define POTION(name,color)	{ name, color, NULL, 0, 1,\
X		POTION_SYM, 0, 0, 2, 0, 0, 0 }
X
X	POTION("restore strength",	"orange"),
X	POTION("gain energy", "cyan"),
X	POTION("booze",		"bubbly"),
X	POTION("invisibility",	"glowing"),
X	POTION("fruit juice",	"smoky"),
X	POTION("healing",	"pink"),
X	POTION("paralysis",	"puce"),
X	POTION("monster detection",	"purple"),
X	POTION("object detection",	"yellow"),
X	POTION("sickness",	"white"),
X	POTION("confusion",	"swirly"),
X	POTION("gain strength",	"purple-red"),
X	POTION("speed",		"ruby"),
X	POTION("blindness",	"dark green"),
X	POTION("gain level",	"emerald"),
X	POTION("extra healing",	"sky blue"),
X	POTION("levitation",	"brown"),
X	POTION("hallucination",	"brilliant blue"),
X	POTION("holy water",	"clear"),
X	POTION(NULL,	"magenta"),
X	POTION(NULL,	"ebony"),
X
X#define SCROLL(name,text,prob) { name, text, NULL, 0, 1,\
X		SCROLL_SYM, prob, 0, 3, 0, 0, 0 }
X	SCROLL("mail",	"KIRJE", 0),
X	SCROLL("enchant armor", "ZELGO MER", 6),
X	SCROLL("destroy armor", "JUYED AWK YACC", 5),
X	SCROLL("confuse monster", "NR 9", 5),
X	SCROLL("scare monster", "XIXAXA XOXAXA XUXAXA", 4),
X	SCROLL("blank paper", "READ ME", 3),
X	SCROLL("remove curse", "PRATYAVAYAH", 6),
X	SCROLL("enchant weapon", "DAIYEN FOOELS", 6),
X	SCROLL("damage weapon", "HACKEM MUCHE", 5),
X	SCROLL("create monster", "LEP GEX VEN ZEA", 5),
X	SCROLL("taming", "PRIRUTSENIE", 1),
X	SCROLL("genocide", "ELBIB YLOH",2),
X	SCROLL("light", "VERR YED HORRE", 10),
X	SCROLL("teleportation", "VENZAR BORGAVVE", 5),
X	SCROLL("gold detection", "THARR", 4),
X	SCROLL("food detection", "YUM YUM", 1),
X	SCROLL("identify", "KERNOD WEL", 18),
X	SCROLL("magic mapping", "ELAM EBOW", 5),
X	SCROLL("amnesia", "DUAM XNAHT", 3),
X	SCROLL("fire", "ANDOVA BEGARIN", 5),
X	SCROLL("punishment", "VE FORBRYDERNE", 1),
X	SCROLL(NULL, "VELOX NEB", 0),
X	SCROLL(NULL, "FOOBIE BLETCH", 0),
X	SCROLL(NULL, "TEMOV", 0),
X	SCROLL(NULL, "GARVEN DEH", 0),
X
X#define	WAND(name,metal,prob,flags)	{ name, metal, NULL, 0, 0,\
X		WAND_SYM, prob, 0, 3, flags, 0, 0 }
X
X	WAND("light",	"iridium",		10,	NODIR),
X	WAND("secret door detection",	"tin",	5,	NODIR),
X	WAND("create monster",	"platinum",	5,	NODIR),
X	WAND("wishing",		"glass",	1,	NODIR),
X#ifdef KAA
X	WAND("striking",	"zinc",		7,	IMMEDIATE),
X	WAND("nothing",		"uranium",	2,	IMMEDIATE),
X#else
X	WAND("striking",	"zinc",		9,	IMMEDIATE),
X	WAND("nothing",		"uranium",	0,	IMMEDIATE),
X#endif 
X	WAND("slow monster",	"balsa",	5,	IMMEDIATE),
X	WAND("speed monster",	"copper",	5,	IMMEDIATE),
X	WAND("undead turning",	"silver",	5,	IMMEDIATE),
X	WAND("polymorph",	"brass",	5,	IMMEDIATE),
X	WAND("cancellation",	"maple",	5,	IMMEDIATE),
X	WAND("teleportation",	"pine",		5,	IMMEDIATE),
X#ifdef PROBING
X	WAND("make invisible",	"marble",	7,	IMMEDIATE),
X	WAND("probing",		"oak",		2,	IMMEDIATE),
X#else
X	WAND("make invisible",	"marble",	9,	IMMEDIATE),
X	WAND("probing",		"oak",		0,	IMMEDIATE),
X#endif
X	WAND("digging",		"iron",		5,	RAY),
X	WAND("magic missile",	"aluminium",	10,	RAY),
X	WAND("fire",		"steel",	5,	RAY),
X	WAND("sleep",		"curved",	5,	RAY),
X	WAND("cold",		"short",	5,	RAY),
X	WAND("death",		"long",		1,	RAY),
X	WAND(NULL,		"ebony",	0,	0),
X	WAND(NULL,		"runed",	0,	0),
X
X#ifdef SPELLS
X/* books */
X#define SPELL(name,desc,prob,delay,flags,level)	{ name, desc, NULL, 0, 0, SPBOOK_SYM, prob, delay, 5, flags, 0, level }
X	SPELL("magic missile", "parchment", 4, 3, RAY, 2),
X	SPELL("fireball", "shining", 2, 6, RAY, 4),
X	SPELL("sleep", "glowing", 6, 1, RAY, 1),
X	SPELL("cone of cold", "mottled", 1, 8, RAY, 5),
X	SPELL("finger of death", "ragged", 1, 10, RAY, 7),
X
X	SPELL("healing", "yellow", 6, 2, NODIR, 1),
X	SPELL("detect monsters", "light green", 5, 1, NODIR, 1),
X	SPELL("force bolt", "dark blue", 4, 2, IMMEDIATE, 1),
X	SPELL("light", "copper", 5, 1, NODIR, 1),
X	SPELL("confuse monster", "white", 5, 2, IMMEDIATE, 2),
X	SPELL("cure blindness", "red", 3, 2, IMMEDIATE, 2),
X	SPELL("slow monster", "dark brown", 4, 2, IMMEDIATE, 2),
X	SPELL("create monster", "light brown", 4, 3, NODIR, 2),
X	SPELL("detect food", "pink", 5, 3, NODIR, 2),
X	SPELL("haste self", "light blue", 3, 4, NODIR, 3),
X	SPELL("cause fear", "black", 4, 3, NODIR, 3),
X	SPELL("cure sickness", "rusty", 3, 3, NODIR, 3),
X	SPELL("detect unseen", "dark green", 4, 4, NODIR, 3),
X	SPELL("extra healing", "magenta", 3, 5, NODIR, 3),
X	SPELL("charm monster", "silver", 3, 3, IMMEDIATE, 3),
X	SPELL("levitation", "indigo", 3, 4, NODIR, 4),
X	SPELL("restore strength", "plaid", 2, 5, NODIR, 4),
X	SPELL("invisibility", "orange", 3, 5, NODIR, 4),
X	SPELL("detect treasure", "bronze", 3, 5, NODIR, 4),
X	SPELL("dig", "cloth", 2, 6, RAY, 5),
X	SPELL("remove curse", "grey", 2, 5, NODIR, 5),
X	SPELL("magic mapping", "purple", 2, 7, NODIR, 5),
X	SPELL("identify", "violet", 1, 8, NODIR, 5),
X	SPELL("turn undead", "turquoise", 1, 8, IMMEDIATE, 6),
X	SPELL("polymorph", "cyan", 1, 8, IMMEDIATE, 6),
X	SPELL("create familiar", "tan", 1, 7, NODIR, 6),
X	SPELL("teleport away", "paper", 2, 6, IMMEDIATE, 6),
X	SPELL("cancellation", "leather", 1, 8, IMMEDIATE, 7),
X	SPELL("genocide", "gold", 1, 10, NODIR, 7),
X/* randomization */
X	SPELL(NULL, "dog eared", 0, 0, 0, 0),
X	SPELL(NULL, "thick", 0, 0, 0, 0),
X	SPELL(NULL, "thin", 0, 0, 0, 0),
X	SPELL(NULL, "stained", 0, 0, 0, 0),
X#endif /* SPELLS /**/
X
X#define	RING(name,stone,spec)	{ name, stone, NULL, 0, 0,\
X		RING_SYM, 0, 0, 1, spec, 0, 0 }
X
X	RING("adornment",	"engagement",	0),
X	RING("teleportation",	"wooden",	0),
X	RING("regeneration",	"black onyx",	0),
X	RING("searching",	"topaz",	0),
X	RING("see invisible",	"pearl",	0),
X	RING("stealth",		"sapphire",	0),
X	RING("levitation",	"moonstone",	0),
X	RING("poison resistance", "agate",	0),
X	RING("aggravate monster", "tiger eye",	0),
X	RING("hunger",		"shining",	0),
X	RING("fire resistance",	"gold",		0),
X	RING("cold resistance",	"copper",	0),
X	RING("protection from shape changers", "diamond", 0),
X	RING("conflict",	"jade",		0),
X	RING("gain strength",	"ruby",		SPEC),
X	RING("increase damage",	"silver",	SPEC),
X	RING("protection",	"granite",	SPEC),
X	RING("warning",		"wire",		0),
X	RING("teleport control", "iron",	0),
X	RING(NULL,		"ivory",	0),
X	RING(NULL,		"blackened",	0),
X
X/* gems ************************************************************/
X#define	GEM(name,color,prob,gval)	{ name, color, NULL, 0, 1,\
X		GEM_SYM, prob, 0, 1, 0, 0, gval }
X	GEM("dilithium crystal", "lavender", 1, 4500),
X	GEM("diamond", "blue", 1, 4000),
X	GEM("ruby", "red", 1, 3500),
X	GEM("sapphire", "blue", 1, 3000),
X	GEM("emerald", "green", 1, 2500),
X	GEM("turquoise", "green", 1, 2000),
X	GEM("aquamarine", "blue", 1, 1500),
X	GEM("tourmaline", "green", 1, 1000),
X	GEM("topaz", "yellow", 1, 900),
X	GEM("opal", "yellow", 1, 800),
X	GEM("garnet", "dark", 1, 700),
X	GEM("amethyst", "violet", 1, 650),
X	GEM("agate", "green", 2, 600),
X	GEM("onyx", "white", 2, 550),
X	GEM("jasper", "yellowish brown", 2, 500),
X	GEM("jade", "green", 2, 450),
X	GEM("worthless piece of blue glass", "blue", 20, 0),
X	GEM("worthless piece of red glass", "red", 20, 0),
X	GEM("worthless piece of yellow glass", "yellow", 20, 0),
X	GEM("worthless piece of green glass", "green", 20, 0),
X	{ NULL, NULL, NULL, 0, 0, ILLOBJ_SYM, 0, 0, 0, 0, 0, 0 }
X};
X
Xchar obj_symbols[] = {
X	ILLOBJ_SYM, AMULET_SYM, FOOD_SYM, WEAPON_SYM, TOOL_SYM,
X	BALL_SYM, CHAIN_SYM, ROCK_SYM, ARMOR_SYM,
X	POTION_SYM, SCROLL_SYM, WAND_SYM,
X#ifdef SPELLS
X	SPBOOK_SYM,
X#endif
X	RING_SYM, GEM_SYM, 0 };
Xint bases[sizeof(obj_symbols)];
END_OF_objects.h
if test 15108 -ne `wc -c <objects.h`; then
    echo shar: \"objects.h\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f read.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"read.c\"
else
echo shar: Extracting \"read.c\" \(16877 characters\)
sed "s/^X//" >read.c <<'END_OF_read.c'
X/*	SCCS Id: @(#)read.c	1.3	87/07/14
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* hack.read.c - version 1.0.3 */
X
X#include "hack.h"
X
Xextern struct monst *makemon();
Xextern struct permonst pm_eel;
Xextern struct obj *mkobj_at();
Xchar *hcolor();
Xboolean	known; 
Xint identify();
X
Xdoread() {
X	register struct obj *scroll;
X	register boolean confused = (Confusion != 0);
X
X	known = FALSE;
X	scroll = getobj("#-?", "read");	/*  "#-" added by GAN 10/22/86 */
X	if(!scroll) return(0);
X	
X	/* below added to allow reading of fortune cookies */
X	if(scroll->otyp ==FORTUNE_COOKIE) {
X		if(Blind) {
X			pline("This cookie has a scrap of paper inside!");
X			pline("What a pity, that you cannot read it!");
X		} else
X			outrumor();
X		useup(scroll);
X		return(1);
X	}  else
X		if(scroll->olet != SCROLL_SYM) {
X			pline("That is a silly thing to read.");
X			return(0);
X		}
X
X	if(!scroll->dknown && Blind) {
X	    pline("Being blind, you cannot read the formula on the scroll.");
X	    return(0);
X	}
X	if(Blind)
X	  pline("As you pronounce the formula on it, the scroll disappears.");
X	else
X	  pline("As you read the scroll, it disappears.");
X	if(confused)
X	  if (Hallucination)
X	      pline("Being so trippy, you screw up ... ");
X	  else
X	      pline("Being confused, you mispronounce the magic words ... ");
X
X	if(!seffects(scroll))  {
X		if(!objects[scroll->otyp].oc_name_known) {
X		    if(known && !confused) {
X			objects[scroll->otyp].oc_name_known = 1;
X			more_experienced(0,10);
X		    } else if(!objects[scroll->otyp].oc_uname)
X			docall(scroll);
X		}
X#ifdef MARKER
X		if(!(scroll->otyp == SCR_BLANK_PAPER) || confused)
X#endif
X			useup(scroll);
X	}
X	return(1);
X}
X
Xseffects(sobj)
X	register struct obj	*sobj;
X{
X	register boolean confused = (Confusion != 0);
X
X	switch(sobj->otyp) {
X#ifdef MAIL
X	case SCR_MAIL:
X		readmail(/* scroll */);
X		break;
X#endif
X	case SCR_ENCHANT_ARMOR:
X	    {	extern struct obj *some_armor();
X		register struct obj *otmp = some_armor();
X		if(!otmp) {
X			strange_feeling(sobj,"Your skin glows then fades.");
X			return(1);
X		}
X		if(confused) {
X			pline("Your %s is covered by a shimmering %s %s!",
X				objects[otmp->otyp].oc_name, Hallucination ? hcolor() :
X				"gold", (otmp->otyp == SHIELD ? "layer" : "shield"));
X			otmp->rustfree = 1;
X			break;
X		}
X#ifdef KAA
X		if(otmp->spe > (otmp->otyp == ELFIN_CHAIN_MAIL ? 5 : 3)
X				&& rn2(otmp->spe)) {
X#else
X		if(otmp->spe > 3 && rn2(otmp->spe)) {
X#endif
X		pline("Your %s glows violently %s for a while, then evaporates.",
X			objects[otmp->otyp].oc_name,
X			Hallucination ? hcolor() : "green");
X			useup(otmp);
X			break;
X		}
X		pline("Your %s glows %s for a moment.",
X			objects[otmp->otyp].oc_name,
X			Hallucination ? hcolor() : "green");
X		otmp->cursed = 0;
X		otmp->spe++;
X		break;
X	    }
X	case SCR_DESTROY_ARMOR:
X		if(confused) {
X			register struct obj *otmp = some_armor();
X			if(!otmp) {
X				strange_feeling(sobj,"Your bones itch.");
X				return(1);
X			}
X			pline("Your %s glows %s for a moment.",
X				objects[otmp->otyp].oc_name,
X				Hallucination ? hcolor() : "purple");
X			otmp->rustfree = 0;
X			break;
X		}
X		if(!destroy_arm()) {
X			strange_feeling(sobj,"Your skin itches.");
X			return(1);
X		}
X		break;
X	case SCR_CONFUSE_MONSTER:
X#ifdef SPELLS
X	case SPE_CONFUSE_MONSTER:
X#endif
X		if(u.usym != '@') {
X			pline("You feel confused.");
X			HConfusion += rnd(100);
X		} else  if(confused) {
X			pline("Your hands begin to glow %s.",
X			Hallucination ? hcolor() : "purple");
X			HConfusion += rnd(100);
X		} else {
X			pline("Your hands begin to glow %s.",
X			Hallucination ? hcolor() : "blue");
X			u.umconf = 1;
X		}
X		break;
X	case SCR_SCARE_MONSTER:
X#ifdef SPELLS
X	case SPE_CAUSE_FEAR:
X#endif
X	    {	register int ct = 0;
X		register struct monst *mtmp;
X
X		for(mtmp = fmon; mtmp; mtmp = mtmp->nmon)
X		    if(cansee(mtmp->mx,mtmp->my)) {
X			if(confused)
X			    mtmp->mflee = mtmp->mfroz = mtmp->msleep = 0;
X			else
X			    if (! resist(mtmp, sobj->olet, 0, NOTELL))
X				mtmp->mflee = 1;
X			ct++;
X		    }
X		if(!ct)
X		    pline("You hear %s in the distance.",
X			   (confused) ? "sad wailing" : "maniacal laughter");
X#ifdef KAA
X		else
X		    pline ("You hear %s close by.",
X			   (confused) ? "sad wailing" : "maniacal laughter");
X#endif
X		break;
X	    }
X	case SCR_BLANK_PAPER:
X		if(confused)
X		    pline("You see strange patterns on this scroll.");
X		else  {
X		    pline("This scroll seems to be blank.");
X#ifdef MARKER
X		    pline("No, wait...");
X		    known = TRUE;
X#endif
X		}
X		break;
X	case SCR_REMOVE_CURSE:
X#ifdef SPELLS
X	case SPE_REMOVE_CURSE:
X#endif
X	    {	register struct obj *obj;
X		if(confused)
X		    if (Hallucination)
X			pline("You feel the power of the Force against you!");
X		    else
X			pline("You feel like you need some help.");
X		else
X		    if (Hallucination)
X			pline("You feel in touch with the Universal Oneness.");
X		    else
X			pline("You feel like someone is helping you.");
X		for(obj = invent; obj ; obj = obj->nobj)
X			if(obj->owornmask)
X				obj->cursed = confused;
X		if(Punished && !confused) {
X			Punished = 0;
X			freeobj(uchain);
X			unpobj(uchain);
X			free((char *) uchain);
X			uball->spe = 0;
X			uball->owornmask &= ~W_BALL;
X			uchain = uball = (struct obj *) 0;
X		}
X		break;
X	    }
X	case SCR_CREATE_MONSTER:
X#ifdef SPELLS
X	case SPE_CREATE_MONSTER:
X#endif
X	    {	register int cnt = 1;
X
X		if(!rn2(73)) cnt += rnd(4);
X		if(confused) cnt += 12;
X		while(cnt--)
X#ifdef WIZARD
X			if(wizard)  {
X				char buf[BUFSZ], cmlet;
X				struct permonst *crmonst;
X				
X				do {
X					pline("What monster to create? ");
X					getlin(buf);
X				} while(strlen(buf) != 1);
X				cmlet = buf[0];
X				for(crmonst = mons; crmonst->mlet != cmlet &&
X					crmonst != PM_EEL; crmonst++) ;
X				(void) makemon(crmonst, u.ux, u.uy);
X			} else
X#endif /* WIZARD /**/
X				(void) makemon(confused ? PM_ACID_BLOB :
X					(struct permonst *) 0, u.ux, u.uy);
X		break;
X	    }
X	case SCR_ENCHANT_WEAPON:
X		if(uwep && uwep->olet == WEAPON_SYM && confused) {
X		/* olet check added 10/25/86 GAN */
X			pline("Your %s covered by a shimmering %s shield!",
X				aobjnam(uwep, "are"),
X				Hallucination ? hcolor() : "gold");
X			uwep->rustfree = 1;
X		} else
X			if(!chwepon(sobj, 1))		/* tests for !uwep */
X				return(1);
X		break;
X	case SCR_DAMAGE_WEAPON:
X		if(uwep && uwep->olet == WEAPON_SYM && confused) {
X		/* olet check added 10/25/86 GAN */
X			pline("Your %s %s for a moment.",
X				aobjnam(uwep,"glow"),
X				Hallucination ? hcolor() : "purple");
X			uwep->rustfree = 0;
X		} else
X			if(!chwepon(sobj, -1))	/* tests for !uwep */
X				return(1);
X		break;
X	case SCR_TAMING:
X#ifdef SPELLS
X	case SPE_CHARM_MONSTER:
X#endif
X	    {	register int i,j;
X		register int bd = confused ? 5 : 1;
X		register struct monst *mtmp;
X
X		for(i = -bd; i <= bd; i++) for(j = -bd; j <= bd; j++)
X		if(mtmp = m_at(u.ux+i, u.uy+j))
X		    if(!resist(mtmp, sobj->olet, 0, NOTELL))
X			(void) tamedog(mtmp, (struct obj *) 0);
X		break;
X	    }
X	case SCR_GENOCIDE:
X		pline("You have found a scroll of genocide!");
X#ifdef SPELLS
X	case SPE_GENOCIDE:
X#endif
X		known = TRUE;
X		do_genocide();
X		break;
X	case SCR_LIGHT:
X		if(!Blind) known = TRUE;
X		litroom(!confused);
X		break;
X	case SCR_TELEPORTATION:
X		if(confused)
X			level_tele();
X		else {
X#ifdef QUEST
X			register int oux = u.ux, ouy = u.uy;
X			tele();
X			if(dist(oux, ouy) > 100) known = TRUE;
X#else
X			register int uroom = inroom(u.ux, u.uy);
X			tele();
X			if(uroom != inroom(u.ux, u.uy)) known = TRUE;
X#endif
X			if(Teleport_control)
X				known = TRUE;
X		}
X		break;
X	case SCR_GOLD_DETECTION:
X	    /* Unfortunately this code has become slightly less elegant,
X	       now that gold and traps no longer are of the same type. */
X	    if(confused) {
X		register struct trap *ttmp;
X
X		if(!ftrap) {
X			strange_feeling(sobj, "Your toes stop itching.");
X			return(1);
X		} else {
X			for(ttmp = ftrap; ttmp; ttmp = ttmp->ntrap)
X				if(ttmp->tx != u.ux || ttmp->ty != u.uy)
X					goto outtrapmap;
X			/* only under me - no separate display required */
X			pline("Your toes itch!");
X			break;
X		outtrapmap:
X			cls();
X			for(ttmp = ftrap; ttmp; ttmp = ttmp->ntrap)
X				at(ttmp->tx, ttmp->ty, Hallucination ? rndobjsym() : '$');
X			prme();
X			pline("You feel very greedy!");
X		}
X	    } else {
X		register struct gold *gtmp;
X
X		if(!fgold) {
X			strange_feeling(sobj, "You feel materially poor.");
X			return(1);
X		} else {
X			known = TRUE;
X			for(gtmp = fgold; gtmp; gtmp = gtmp->ngold)
X				if(gtmp->gx != u.ux || gtmp->gy != u.uy)
X					goto outgoldmap;
X			/* only under me - no separate display required */
X			pline("You notice some gold between your feet.");
X			break;
X		outgoldmap:
X			cls();
X			for(gtmp = fgold; gtmp; gtmp = gtmp->ngold)
X				at(gtmp->gx, gtmp->gy, Hallucination ? rndobjsym() : '$');
X			prme();
X			pline("You feel very greedy, and sense gold!");
X		}
X	    }
X		/* common sequel */
X		more();
X		docrt();
X		break;
X	case SCR_FOOD_DETECTION:
X#ifdef SPELLS
X	case SPE_DETECT_FOOD:
X#endif
X	    {	register ct = 0, ctu = 0;
X		register struct obj *obj;
X		register char foodsym = confused ? POTION_SYM : FOOD_SYM;
X
X		for(obj = fobj; obj; obj = obj->nobj)
X			if(obj->olet == foodsym) {
X				if(obj->ox == u.ux && obj->oy == u.uy) ctu++;
X				else ct++;
X			}
X		if(!ct && !ctu) {
X			strange_feeling(sobj,"Your nose twitches.");
X			return(1);
X		} else if(!ct) {
X			known = TRUE;
X			pline("You smell %s close nearby.",
X				confused ? "something" : "food");
X			
X		} else {
X			known = TRUE;
X			cls();
X			for(obj = fobj; obj; obj = obj->nobj)
X			    if(obj->olet == foodsym)
X				at(obj->ox, obj->oy, Hallucination ? rndobjsym() :
X				 FOOD_SYM);
X			prme();
X			pline("Your nose tingles and you smell %s!",
X				confused ? "something" : "food");
X			more();
X			docrt();
X		}
X		break;
X	    }
X	case SCR_IDENTIFY:
X		/* known = TRUE; */
X		if(confused)
X			pline("You identify this as an identify scroll.");
X		else
X			pline("This is an identify scroll.");
X		useup(sobj);
X		objects[SCR_IDENTIFY].oc_name_known = 1;
X#ifdef SPELLS
X	case SPE_IDENTIFY:
X#endif
X		if(!confused)
X		    while(!ggetobj("identify", identify, rn2(5) ? 1 : rn2(5)) && invent);
X		return(1);
X	case SCR_MAGIC_MAPPING:
X		known = TRUE;
X		pline("On this scroll %s a map!", confused ? "was" : "is");
X#ifdef SPELLS
X	case SPE_MAGIC_MAPPING:
X#endif
X		do_mapping();
X		break;
X	case SCR_AMNESIA:
X	    {	register int zx, zy;
X
X		known = TRUE;
X		for(zx = 0; zx < COLNO; zx++) for(zy = 0; zy < ROWNO; zy++)
X		    if(!confused || rn2(7))
X			if(!cansee(zx,zy))
X			    levl[zx][zy].seen = 0;
X		docrt();
X		pline("Who was that Maude person anyway?");
X#ifdef SPELLS
X		losespells();
X#endif
X		break;
X	    }
X	case SCR_FIRE:
X	    {	register int num;
X		register struct monst *mtmp;
X
X/* 
X * Note: This case was modified 11/4/86 by DKC to eliminate the problem with
X * reading a scroll of fire while confused or resistant to fire.  Formerly,
X * the code failed to initialize the variable "num" in these cases, resulting
X * in monsters being hit for a possibly large (and possibly negative) damage.
X * The actions taken now are: 
X * 				If the player is fire resistant, monsters
X * take the normal damage (1-6 except for Y's and F's), and the player is
X * unaffected.
X */
X		known = TRUE;
X		if(confused) {
X		    if(Fire_resistance)
X			pline("Oh look, what a pretty fire in your hands.");
X		    else {
X			pline("The scroll catches fire and you burn your hands.");
X			losehp(1, "scroll of fire");
X		    }
X		    break;
X		}
X		pline("The scroll erupts in a tower of flame!");
X		num = rnd(6);
X		if(Fire_resistance)
X			pline("You are uninjured.");
X		else {
X			u.uhpmax -= num;
X			losehp(num, "scroll of fire");
X		}
X		num = (2*num + 1)/3;
X		for(mtmp = fmon; mtmp; mtmp = mtmp->nmon) {
X		    if(dist(mtmp->mx,mtmp->my) < 3) {
X			mtmp->mhp -= num;		/* No saving throw! */
X			if(index("FY", mtmp->data->mlet))
X			    mtmp->mhp -= 3*num;	/* this might well kill 'F's */
X			if(mtmp->mhp < 1) {
X			    killed(mtmp);
X			    break;		/* primitive */
X			}
X		    }
X		}
X		break;
X	    }
X	case SCR_PUNISHMENT:
X		known = TRUE;
X		if(confused) {
X			pline("You feel guilty.");
X			break;
X		}
X		pline("You are being punished for your misbehaviour!");
X		if(Punished){
X			pline("Your iron ball gets heavier.");
X			uball->owt += 15;
X			break;
X		}
X		Punished = INTRINSIC;
X		setworn(mkobj_at(CHAIN_SYM, u.ux, u.uy), W_CHAIN);
X		setworn(mkobj_at(BALL_SYM, u.ux, u.uy), W_BALL);
X		uball->spe = 1;		/* special ball (see save) */
X		break;
X	default:
X		impossible("What weird effect is this? (%u)", sobj->otyp);
X	}
X	return(0);
X}
X
Xidentify(otmp)		/* also called by newmail() */
Xregister struct obj *otmp;
X{
X	objects[otmp->otyp].oc_name_known = 1;
X#ifdef KAA
X	otmp->known = 1;
X	if (otmp->olet != WEAPON_SYM) otmp->dknown = 1;
X/* Now, the dknown field is special for weapons, indicating blessing. */
X#else
X	otmp->known = otmp->dknown = 1;
X#endif
X	prinv(otmp);
X	return(1);
X}
X
Xlitroom(on)
Xregister boolean on;
X{
X	register num,zx,zy;
X
X	/* first produce the text (provided he is not blind) */
X	if(Blind) goto do_it;
X	if(!on) {
X		if(u.uswallow || !xdnstair || levl[u.ux][u.uy].typ == CORR ||
X		    !levl[u.ux][u.uy].lit) {
X			pline("It seems even darker in here than before.");
X			return;
X		} else
X			pline("It suddenly becomes dark in here.");
X	} else {
X		if(u.uswallow){
X			pline("%s's stomach is lit.", Monnam(u.ustuck));
X			return;
X		}
X		if(!xdnstair){
X			pline("Nothing Happens.");
X			return;
X		}
X#ifdef QUEST
X		pline("The cave lights up around you, then fades.");
X		return;
X#else
X		if(levl[u.ux][u.uy].typ == CORR) {
X		    pline("The corridor lights up around you, then fades.");
X		    return;
X		} else if(levl[u.ux][u.uy].lit) {
X		    pline("The light here seems better now.");
X		    return;
X		} else
X		    pline("The room is lit.");
X#endif
X	}
X
Xdo_it:
X#ifdef QUEST
X	return;
X#else
X	if(levl[u.ux][u.uy].lit == on)
X		return;
X	if(levl[u.ux][u.uy].typ == DOOR) {
X		if(IS_ROOM(levl[u.ux][u.uy+1].typ)) zy = u.uy+1;
X		else if(IS_ROOM(levl[u.ux][u.uy-1].typ)) zy = u.uy-1;
X		else zy = u.uy;
X		if(IS_ROOM(levl[u.ux+1][u.uy].typ)) zx = u.ux+1;
X		else if(IS_ROOM(levl[u.ux-1][u.uy].typ)) zx = u.ux-1;
X		else zx = u.ux;
X	} else {
X		zx = u.ux;
X		zy = u.uy;
X	}
X	for(seelx = u.ux; (num = levl[seelx-1][zy].typ) != CORR && num != 0;
X		seelx--);
X	for(seehx = u.ux; (num = levl[seehx+1][zy].typ) != CORR && num != 0;
X		seehx++);
X	for(seely = u.uy; (num = levl[zx][seely-1].typ) != CORR && num != 0;
X		seely--);
X	for(seehy = u.uy; (num = levl[zx][seehy+1].typ) != CORR && num != 0;
X		seehy++);
X	for(zy = seely; zy <= seehy; zy++)
X		for(zx = seelx; zx <= seehx; zx++) {
X			levl[zx][zy].lit = on;
X			if(!Blind && dist(zx,zy) > 2)
X				if(on) prl(zx,zy); else nosee(zx,zy);
X		}
X	if(!on) seehx = 0;
X#endif
X}
X
X/* Test whether we may genocide all monsters with symbol  ch  */
Xmonstersym(ch)				/* arnold@ucsfcgl */
Xregister char ch;
X{
X	register struct permonst *mp;
X
X	/*
X	 * can't genocide certain monsters
X	 */
X	if (index("12 &:", ch))	return FALSE;
X
X	if (ch == pm_eel.mlet)	return TRUE;
X	for (mp = mons; mp < &mons[CMNUM+2]; mp++)
X		if (mp->mlet == ch) return TRUE;
X
X	return FALSE;
X}
X
Xdo_genocide()
X
X{
X	extern char genocided[], fut_geno[];
X	char buf[BUFSZ];
X	register struct monst *mtmp, *mtmp2;
X
X	if(Confusion != 0)  *buf = u.usym;
X	else do {
X	    pline("What monster do you want to genocide (Type the letter)? ");
X	    getlin(buf);
X	}
X
X	while(strlen(buf) != 1 || !monstersym(*buf));
X
X	if(!index(fut_geno, *buf))  charcat(fut_geno, *buf);
X	if(!index(genocided, *buf)) charcat(genocided, *buf);
X	else {
X		pline("Such monsters do not exist in this world.");
X		return;
X	}
X	for(mtmp = fmon; mtmp; mtmp = mtmp2){
X		mtmp2 = mtmp->nmon;
X		if(mtmp->data->mlet == *buf)
X			mondead(mtmp);
X	}
X	pline("Wiped out all %c's.", Hallucination ? '@' : *buf);
X	/* Scare the hallucinating player */
X	if(*buf == '@') {
X		if(u.usym != '@') pline("You feel dead inside.");
X		killer = "scroll of genocide";
X		u.uhp = -1;
X	}
X#ifdef KAA
X	else if (*buf==u.usym) rehumanize();
X#endif
X}
X
Xdo_mapping()
X{
X	register struct rm *lev;
X	register int num, zx, zy;
X
X	for(zy = 0; zy < ROWNO; zy++)
X	    for(zx = 0; zx < COLNO; zx++) {
X
X		if((Confusion != 0) && rn2(7)) continue;
X		lev = &(levl[zx][zy]);
X		if((num = lev->typ) == 0)	continue;
X
X		if(num == SCORR) {
X			lev->typ = CORR;
X#ifdef DGK
X			lev->scrsym = symbol.corr;
X#else
X			lev->scrsym = CORR_SYM;
X#endif
X		} else	if(num == SDOOR) {
X			lev->typ = DOOR;
X#ifdef DGK
X			lev->scrsym = symbol.door;
X#else
X			lev->scrsym = '+';
X#endif
X		/* do sth in doors ? */
X		} else if(lev->seen) continue;
X#ifndef QUEST
X		if(num != ROOM)
X#endif
X		{
X			lev->seen = lev->new = 1;
X			if(lev->scrsym == ' ' || !lev->scrsym)	newsym(zx,zy);
X			else	on_scr(zx,zy);
X		}
X	    }
X}
X
Xdestroy_arm() {
X
X	if(uarm) {
X		pline("Your armor turns to dust and falls to the floor!");
X		useup(uarm);
X	} else if(uarmh) {
X		pline("Your helmet turns to dust and is blown away!");
X		useup(uarmh);
X	} else if(uarmg) {
X		pline("Your gloves vanish!");
X		useup(uarmg);
X		selftouch("You");
X	} else if(uarms) {
X		pline("Your shield crumbles away!");
X		useup(uarms);
X	} else  return(0);		/* could not destroy anything */
X
X	return(1);
X}
END_OF_read.c
if test 16877 -ne `wc -c <read.c`; then
    echo shar: \"read.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
echo shar: End of archive 6 \(of 16\).
cp /dev/null ark6isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 16 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
