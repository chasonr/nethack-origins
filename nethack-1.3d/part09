Relay-Version: version B 2.10 5/3/83; site utzoo.UUCP
Path: utzoo!mnetor!uunet!seismo!rochester!cornell!uw-beaver!tektronix!tekgen!tekred!games-request
From: games-request@tekred.TEK.COM
Newsgroups: comp.sources.games
Subject: v02i009:  nethack - display oriented dungeons & dragons, Part09/16
Message-ID: <1451@tekred.TEK.COM>
Date: Tue, 28-Jul-87 14:49:38 EDT
Article-I.D.: tekred.1451
Posted: Tue Jul 28 14:49:38 1987
Date-Received: Fri, 31-Jul-87 01:16:18 EDT
Sender: billr@tekred.TEK.COM
Lines: 2417
Approved: billr@tekred.TEK.COM

Submitted by: mike@genat.UUCP (Mike Stephenson)
Comp.sources.games: Volume 2, Issue 9
Archive-name: nethack/Part09



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 9 (of 16)."
# Contents:  engrave.c makedefs.c pri.c rumors.c unixmain.c
# Wrapped by billr@tekred on Tue Jul 28 09:49:36 1987
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f engrave.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"engrave.c\"
else
echo shar: Extracting \"engrave.c\" \(12451 characters\)
sed "s/^X//" >engrave.c <<'END_OF_engrave.c'
X/*	SCCS Id: @(#)engrave.c	1.3	87/07/14
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* engrave.c - version 1.0.2 */
X
X#include	"hack.h"
X
Xextern char *nomovemsg;
Xextern char nul[];
Xextern struct obj zeroobj;
X#ifdef KAA
Xextern char *xname();
X#endif
Xstruct engr {
X	struct engr *nxt_engr;
X	char *engr_txt;
X	xchar engr_x, engr_y;
X	unsigned engr_lth;	/* for save & restore; not length of text */
X	long engr_time;	/* moment engraving was (will be) finished */
X	xchar engr_type;
X#define	DUST	1
X#define	ENGRAVE	2
X#define	BURN	3
X#ifdef MARKER
X#define MARK	4
X#define POLY	5	/* temporary type - for polymorphing engraving */
X#else
X#define POLY	4	/* temporary type - for polymorphing engraving */
X#endif
X} *head_engr;
X
X/* random engravings */
X#ifdef KAA
Xchar *random_engr[] =
X#else
Xchar random_engr[][30] =
X#endif
X			 {"Elbereth", "ad ae?ar um",
X#ifdef NEWCLASS
X			 "?la? ?as he??",
X#endif
X			/* more added by Eric Backus */
X			"?ilroy wa? h?re", "?ala??iel", "Aba?don H?pe...",
X			"Fo? a ?ood time c?ll 6?6-4311"};
X#ifdef NEWCLASS
X#define RAND_ENGRS	7
X#else
X#define RAND_ENGRS	6
X#endif
X
Xstruct engr *
Xengr_at(x,y) register xchar x,y; {
Xregister struct engr *ep = head_engr;
X	while(ep) {
X		if(x == ep->engr_x && y == ep->engr_y)
X			return(ep);
X		ep = ep->nxt_engr;
X	}
X	return((struct engr *) 0);
X}
X
Xsengr_at(s,x,y) register char *s; register xchar x,y; {
Xregister struct engr *ep = engr_at(x,y);
Xregister char *t;
Xregister int n;
X	if(ep && ep->engr_time <= moves) {
X		t = ep->engr_txt;
X/*
X		if(!strcmp(s,t)) return(1);
X*/
X		n = strlen(s);
X		while(*t) {
X			if(!strncmp(s,t,n)) return(1);
X			t++;
X		}
X	}
X	return(0);
X}
X
Xu_wipe_engr(cnt)
Xregister int cnt;
X{
X	if(!u.uswallow && !Levitation)
X		wipe_engr_at(u.ux, u.uy, cnt);
X}
X
Xwipe_engr_at(x,y,cnt) register xchar x,y,cnt; {
Xregister struct engr *ep = engr_at(x,y);
Xregister int lth,pos;
Xchar ch;
X	if(ep){
X		if(ep->engr_type != DUST) {
X			cnt = rn2(1 + 50/(cnt+1)) ? 0 : 1;
X		}
X		lth = strlen(ep->engr_txt);
X		if(lth && cnt > 0 ) {
X			while(cnt--) {
X				pos = rn2(lth);
X				if((ch = ep->engr_txt[pos]) == ' ')
X					continue;
X				ep->engr_txt[pos] = (ch != '?') ? '?' : ' ';
X			}
X		}
X		while(lth && ep->engr_txt[lth-1] == ' ')
X			ep->engr_txt[--lth] = 0;
X		while(ep->engr_txt[0] == ' ')
X			ep->engr_txt++;
X		if(!ep->engr_txt[0]) del_engr(ep);
X	}
X}
X
Xread_engr_at(x,y) register int x,y; {
Xregister struct engr *ep = engr_at(x,y);
X	if(ep && ep->engr_txt[0]) {
X	    switch(ep->engr_type) {
X	    case DUST:
X		pline("Something is written here in the dust.");
X		break;
X	    case ENGRAVE:
X		pline("Something is engraved here on the floor.");
X		break;
X	    case BURN:
X		pline("Some text has been burned here in the floor.");
X#ifdef MARKER
X	    case MARK:
X		pline("There's some graffiti here on the floor.");
X		break;
X#endif
X		break;
X	    default:
X		impossible("Something is written in a very strange way.");
X	    }
X	    pline("You read: \"%s\".", ep->engr_txt);
X	}
X}
X
Xmake_engr_at(x,y,s)
Xregister int x,y;
Xregister char *s;
X{
X	register struct engr *ep;
X
X	if(ep = engr_at(x,y))
X	    del_engr(ep);
X	ep = (struct engr *)
X	    alloc((unsigned)(sizeof(struct engr) + strlen(s) + 1));
X	ep->nxt_engr = head_engr;
X	head_engr = ep;
X	ep->engr_x = x;
X	ep->engr_y = y;
X	ep->engr_txt = (char *)(ep + 1);
X	(void) strcpy(ep->engr_txt, s);
X	ep->engr_time = 0;
X	ep->engr_type = DUST;
X	ep->engr_lth = strlen(s) + 1;
X}
X/*
X *	freehand - returns true if player has a free hand
X */
Xint
Xfreehand(){
X
X	return(!uwep ||
X	   !uwep->cursed ||
X	   (uwep->otyp != TWO_HANDED_SWORD && (!uarms || !uarms->cursed)));
X/*	if ((uwep && uwep->otyp == TWO_HANDED_SWORD) ||
X	    (uwep && uarms))
X		return(0);
X	else
X		return(1);*/
X}
X
X
X
Xdoengrave(){
Xregister int len;
Xregister char *sp;
Xregister struct engr *ep, *oep = engr_at(u.ux,u.uy);
Xchar buf[BUFSZ];
Xxchar type;
Xint spct;		/* number of leading spaces */
Xregister struct obj *otmp;
X	multi = 0;
X
X	if(u.uswallow) {
X		pline("You're joking. Hahaha!");	/* riv05!a3 */
X		return(0);
X	}
X
X	/* one may write with finger, weapon or wand */
X	/* edited by GAN 10/20/86 so as not to change
X	 * weapon wielded.
X	 */
X	otmp = getobj("#-()/", "write with");
X	if(!otmp) return(0);
X
X#ifdef FREEHAND /* There's no reason you should be able to write with a wand
X		 * while both your hands are tied up.  Also, it's necessary to
X		 * prevent engraving with "worn" objects other than weapons.
X		 */
X	if (!freehand() && otmp != uwep) {
X#else
X	/* added by GAN 10/20/86 to require you to need a hand to
X	   write with.
X	 */
X	if(!(otmp->owornmask || otmp->olet == WAND_SYM) && !freehand())  {
X#endif
X		pline("You have no free hand to write with!");
X		return(0);
X	}
X#ifdef KAA
X	if (cantwield(u.usym)) {
X		pline("You can't even hold anything!");
X		return(0);
X	}
X	if(otmp != &zeroobj && index("][0`",otmp->olet)) {
X		pline("You can't engrave with such a large object!");
X		return(1);
X	}
X#endif
X
X	if(Levitation && otmp->olet != WAND_SYM){		/* riv05!a3 */
X		pline("You can't reach the floor!");
X		return(0);
X	}
X
X	if(otmp == &zeroobj) {
X		pline("You write in the dust with your fingers.");
X		type = DUST;
X	} else if(otmp->olet == WAND_SYM && zappable(otmp)) {
X		/* changed so any wand gets zapped out, but fire
X		 * wands become known.
X		 */
X		if((objects[otmp->otyp].bits & NODIR))  {
X			zapnodir(otmp);
X			type = DUST;
X		}  else  {
X			switch(otmp->otyp)  {
X			case WAN_FIRE:
X				if(!objects[otmp->otyp].oc_name_known) {
X					pline("The %s is a wand of fire!",
X					   xname(otmp));
X					objects[otmp->otyp].oc_name_known = 1;
X					more_experienced(0,10);
X				}
X				type = BURN;
X				break;
X			case WAN_DIGGING:
X				if(!objects[otmp->otyp].oc_name_known) {
X					pline("The %s is a wand of digging!",
X					   xname(otmp));
X					objects[otmp->otyp].oc_name_known = 1;
X					more_experienced(0,10);
X				}
X				type = ENGRAVE;
X				break;
X			case WAN_POLYMORPH:
X				if(oep)  {
X					del_engr(oep);
X					oep = 0;
X					type = POLY;
X				}  else
X					type = DUST;
X				break;
X			case WAN_COLD:
X				type = DUST;
X				if(!oep || (oep->engr_type != BURN))
X					break;
X			case WAN_CANCELLATION:
X			case WAN_MAKE_INVISIBLE:
X				if(!oep) {		/* Eric Backus */
X					type = DUST;
X					break;
X				}
X				del_engr(oep);
X				pline("The engraving on the floor vanishes!");
X				return(1);
X				break;
X			case WAN_TELEPORTATION:
X				if(!oep)
X					type = DUST;
X				else  {
X					register tx,ty;
X
X					do  {
X						tx = rn1(COLNO-3,2);
X						ty = rn2(ROWNO);
X					}  while(!goodpos(tx,ty));
X					oep->engr_x = tx;
X					oep->engr_y = ty;
X					pline("The engraving on the floor vanishes!");
X					return(1);
X				}
X				break;
X			default:
X				type = DUST;
X			}
X		}
X		if(type == DUST)
X			pline("You write in the dust with %s.",
X			   doname(otmp));
X	
X	} else {
X		if(otmp->otyp == DAGGER || otmp->otyp == TWO_HANDED_SWORD ||
X		otmp->otyp == CRYSKNIFE || otmp->otyp == KATANA ||
X		otmp->otyp == SCIMITAR || otmp->otyp == BROAD_SWORD ||
X		otmp->otyp == SHORT_SWORD ||
X		otmp->otyp == LONG_SWORD || otmp->otyp == AXE) {
X			type = ENGRAVE;
X			if((int)otmp->spe <= -3) {
X				pline("Your %s too dull for engraving.",
X					aobjnam(otmp, "are"));
X				type = DUST;
X				/* following messaged added 10/20/86 - GAN */
X				pline("You write in the dust with %s.",
X				   doname(otmp));
X			}  else
X				pline("You engrave with %s.", doname(otmp));
X#ifdef MARKER
X		} else if(otmp->otyp == MAGIC_MARKER)  {
X			if(otmp->spe <= 0)  {
X				pline("Your marker is dried out.");
X				pline("You write in the dust with the marker.");
X				type = DUST;
X			}  else  {
X				pline("You write with %s.", doname(otmp));
X				type = MARK;
X			}
X#endif
X		}  else  {
X			pline("You write in the dust with %s.",
X			   doname(otmp));
X			type = DUST;
X		}
X	}
X	
X	if(type != POLY && oep && oep->engr_type == DUST){
X		  pline("You wipe out the message that was written here.");
X		  del_engr(oep);
X		  oep = 0;
X	}
X	if(type == DUST && oep){
X	pline("You cannot wipe out the message that is %s in the rock.",
X		    (oep->engr_type == BURN) ? "burned" : (oep->engr_type == ENGRAVE)? "engraved" : "scribbled");
X		  return(1);
X	}
X	if(type == POLY)  {
X#ifdef MARKER
X		type = rnd(4);
X#else
X		type = rnd(3);
X#endif
X		strcpy(buf,random_engr[rn2(RAND_ENGRS)]);
X		switch(type){
X		case DUST:
X			pline("\"%s\" is now written on the ground.",buf);
X			break;
X		case ENGRAVE:
X			pline("\"%s\" is now engraved in the rock.",buf);
X			break;
X		case BURN:
X			pline("\"%s\" is now burned in the rock.",buf);
X			break;
X#ifdef MARKER
X		case MARK:
X			pline("\"%s\" is now scribbled on the rock.",buf);
X			break;
X#endif
X		default:
X			impossible("\"%s\" is now written in a very strange way.",
X			   buf);
X		}
X	}  else  {
X		pline("What do you want to %s on the floor here? ",
X		  (type == ENGRAVE) ? "engrave" : (type == BURN) ? "burn" : "write");
X		getlin(buf);
X		clrlin();
X	}
X	spct = 0;
X	sp = buf;
X	while(*sp == ' ') spct++, sp++;
X	len = strlen(sp);
X	if(!len || *buf == '\033') {
X		/* changed by GAN 11/01/86 to not recharge wand */
X		if(type == BURN)
X			pline("A few sparks fly from the wand of fire.");
X		else
X			if(otmp->otyp == WAN_DIGGING)
X				pline("Gravel flies up from the floor.");
X		return(1);
X	}
X	
X	switch(type) {
X	case DUST:
X	case BURN:
X		if(len > 15) {
X			multi = -(len/10);
X			nomovemsg = "You finished writing.";
X		}
X		break;
X	case ENGRAVE:
X#ifdef MARKER
X	case MARK:
X		{	int len2;
X		
X			if(type == ENGRAVE)
X				len2 = (otmp->spe + 3) * 2 + 1;
X			else
X				len2 = (otmp->spe) * 2;
X			nomovemsg = "You finished writing.";
X			if(type != MARK)
X#else
X		{	int len2 = (otmp->spe + 3) * 2 + 1;
X#endif
X			nomovemsg = "You finished engraving.";
X			if(otmp->olet != WAND_SYM)  {
X				if(otmp->olet == WEAPON_SYM)
X					pline("Your %s dull.",
X					       aobjnam(otmp, "get"));
X				if(len2 < len) {
X					len = len2;
X					sp[len] = 0;
X					if(type == ENGRAVE)  {
X						otmp->spe = -3;
X					}  else  {
X						pline("Your marker dries out!");
X						otmp->spe = 0;
X					}
X					/* next line added by GAN 10/20/86 */
X					pline("You only write \"%s\".", sp);
X					nomovemsg = "You cannot write more.";
X				} else
X					otmp->spe -= len/2;
X#ifdef MARKER
X				if(type == MARK)
X					multi = -(len/10);
X				else
X#endif
X					multi = -len;
X			}  else
X				multi = -(len/10);
X		}
X		break;
X	}
X	if(oep) len += strlen(oep->engr_txt) + spct;
X	ep = (struct engr *) alloc((unsigned)(sizeof(struct engr) + len + 1));
X	ep->nxt_engr = head_engr;
X	head_engr = ep;
X	ep->engr_x = u.ux;
X	ep->engr_y = u.uy;
X	sp = (char *)(ep + 1);	/* (char *)ep + sizeof(struct engr) */
X	ep->engr_txt = sp;
X	if(oep) {
X		(void) strcpy(sp, oep->engr_txt);
X		(void) strcat(sp, buf);
X		del_engr(oep);
X	} else
X		(void) strcpy(sp, buf);
X	ep->engr_lth = len+1;
X	ep->engr_type = type;
X	ep->engr_time = moves-multi;
X
X	/* kludge to protect pline against excessively long texts */
X	if(len > BUFSZ-20) sp[BUFSZ-20] = 0;
X	
X	/* cute messages for odd wands */
X	switch(otmp->otyp)  {
X	case WAN_SLOW_MONSTER:
X		pline("The bugs on the ground slow down!");
X		break;
X	case WAN_SPEED_MONSTER:
X		pline("The bugs on the ground speed up!");
X		break;
X	case WAN_MAGIC_MISSILE:
X		pline("The ground is riddled by bullet holes!");
X		break;
X	case WAN_SLEEP:
X	case WAN_DEATH:	/* can't tell sleep from death - Eric Backus */
X		pline("The bugs on the ground stop moving!");
X		break;
X	case WAN_COLD:
X		pline("A few ice cubes drop from your %s.",xname(otmp));
X		break;
X	case WAN_STRIKING:
X		pline("The %s unsuccessfully fights your attempt to write!",xname(otmp));
X	}
X
X	return(1);
X}
X
Xsave_engravings(fd) int fd; {
Xregister struct engr *ep = head_engr;
X	while(ep) {
X		if(!ep->engr_lth || !ep->engr_txt[0]){
X			ep = ep->nxt_engr;
X			continue;
X		}
X		bwrite(fd, (char *) & (ep->engr_lth), sizeof(ep->engr_lth));
X		bwrite(fd, (char *) ep, sizeof(struct engr) + ep->engr_lth);
X		ep = ep->nxt_engr;
X	}
X	bwrite(fd, (char *) nul, sizeof(unsigned));
X#ifdef DGK
X	if (!count_only)
X#endif
X		head_engr = 0;
X}
X
Xrest_engravings(fd) int fd; {
Xregister struct engr *ep;
Xunsigned lth;
X	head_engr = 0;
X	while(1) {
X		mread(fd, (char *) &lth, sizeof(unsigned));
X		if(lth == 0) return;
X		ep = (struct engr *) alloc(sizeof(struct engr) + lth);
X		mread(fd, (char *) ep, sizeof(struct engr) + lth);
X		ep->nxt_engr = head_engr;
X		ep->engr_txt = (char *) (ep + 1);	/* Andreas Bormann */
X		head_engr = ep;
X	}
X}
X
Xdel_engr(ep) register struct engr *ep; {
Xregister struct engr *ept;
X	if(ep == head_engr)
X		head_engr = ep->nxt_engr;
X	else {
X		for(ept = head_engr; ept; ept = ept->nxt_engr) {
X			if(ept->nxt_engr == ep) {
X				ept->nxt_engr = ep->nxt_engr;
X				goto fnd;
X			}
X		}
X		impossible("Error in del_engr?");
X		return;
X	fnd:	;
X	}
X	free((char *) ep);
X}
END_OF_engrave.c
if test 12451 -ne `wc -c <engrave.c`; then
    echo shar: \"engrave.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f makedefs.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"makedefs.c\"
else
echo shar: Extracting \"makedefs.c\" \(11657 characters\)
sed "s/^X//" >makedefs.c <<'END_OF_makedefs.c'
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* makedefs.c - NetHack version 1.0 */
X
Xstatic	char	SCCS_Id[] = "@(#)makedefs.c	1.3\t87/07/14";
X
X#include	"config.h"
X#include	<stdio.h>
X
X#ifdef MSDOS
X#undef	exit
X#endif
X
X/* construct definitions of object constants */
X#define	OBJ_FILE	"objects.h"
X#define	ONAME_FILE	"onames.h"
X#define	TRAP_FILE	"trap.h"
X#define	DATE_FILE	"date.h"
X#define	RUMOR_FILE	"rumors"
X#define	DATA_FILE	"data"
X
Xchar	inline[256], outline[256];
X
Xmain(argc, argv)
X	int	argc;
X	char	*argv[];
X{
X	char	*option;
X
X	if(argc == 2) {
X	    option = argv[1];
X	    switch (option[1]) {
X
X		case 'o':
X		case 'O':	do_objs();
X				break;
X		case 't':
X		case 'T':	do_traps();
X				break;
X		case 'r':
X		case 'R':	do_rumors();
X				break;
X
X		case 'd':	do_data();
X				break;
X
X		case 'D':	do_date();
X				break;
X		default:
X				fprintf(stderr, "Unknown option '%c'.\n", option[1]);
X				exit(1);
X	    }
X	    exit(0);
X	} else	fprintf(stderr, "Bad arg count (%d).\n", argc-1);
X	exit(1);
X}
X
Xdo_traps() {
Xint	ntrap, getpid();
Xchar	tmpfile[30];
XFILE	*freopen();
X
X	sprintf(tmpfile, "makedefs.%d", getpid());
X	if(freopen(tmpfile, "w+", stdout) == NULL) {
X
X		perror(tmpfile);
X		exit(1);
X	}
X	if(freopen(TRAP_FILE, "r+", stdin) == NULL) {
X
X		perror(TRAP_FILE);
X		exit(1);
X	}
X
X	while(gets(inline) != NULL) {
X
X	    puts(inline);
X	    if(!strncmp(inline, "/* DO NOT REMOVE THIS LINE */", 29)) break;
X	}
X	ntrap = 10;
X	printf("\n");
X
X#ifdef NEWTRAPS
X	printf("#define\tMGTRP\t\t%d\n", ntrap++);
X	printf("#define\tSQBRD\t\t%d\n", ntrap++);
X#endif
X#ifdef SPIDERS
X	printf("#define\tWEB\t\t%d\n", ntrap++);
X#endif
X#ifdef NEWCLASS
X	printf("#define\tSPIKED_PIT\t%d\n", ntrap++);
X	printf("#define\tLEVEL_TELEP\t%d\n", ntrap++);
X#endif
X#ifdef SPELLS
X	printf("#define\tANTI_MAGIC\t%d\n", ntrap++);
X#endif
X#ifdef KAA
X	printf("#define\tRUST_TRAP\t%d\n", ntrap++);
X#endif
X	printf("\n#define\tTRAPNUM\t%d\n", ntrap);
X	fclose(stdin);
X	fclose(stdout);
X	rename(tmpfile, TRAP_FILE);
X}
X
X
Xstruct	hline {
X	struct	hline	*next;
X	char	*line;
X}	*f_line;
X
Xdo_rumors(){
Xstruct	hline	*c_line;
Xchar	infile[30];
XFILE	*freopen();
X
X	if(freopen(RUMOR_FILE, "w+", stdout) == NULL) {
X
X		perror(RUMOR_FILE);
X		exit(1);
X	}
X	sprintf(infile, "%s.base", RUMOR_FILE);
X	if(freopen(infile, "r+", stdin) == NULL) {
X
X		perror(infile);
X		exit(1);
X	}
X
X	while(gets(inline) != NULL)	puts(inline);
X
X#ifdef KAA
X	sprintf(infile, "%s.kaa", RUMOR_FILE);
X	if(freopen(infile, "r+", stdin) == NULL)	perror(infile);
X
X	while(gets(inline) != NULL)	puts(inline);
X#endif
X
X#ifdef NEWCLASS
X	sprintf(infile, "%s.mrx", RUMOR_FILE);
X	if(freopen(infile, "r+", stdin) == NULL)	perror(infile);
X
X	while(gets(inline) != NULL)	puts(inline);
X#endif
X	fclose(stdin);
X	fclose(stdout);
X}
X
Xdo_date(){
Xint	getpid();
Xlong	clock, time();
Xchar	tmpfile[30], cbuf[30], *c, *ctime();
XFILE	*freopen();
X
X	sprintf(tmpfile, "makedefs.%d", getpid());
X	if(freopen(tmpfile, "w+", stdout) == NULL) {
X
X		perror(tmpfile);
X		exit(1);
X	}
X	if(freopen(DATE_FILE, "r+", stdin) == NULL) {
X
X		perror(DATE_FILE);
X		exit(1);
X	}
X
X	while(gets(inline) != NULL) {
X
X	    if(!strncmp(inline, "char datestring[] = ", 20)) break;
X	    puts(inline);
X	}
X	time(&clock);
X	strcpy(cbuf, ctime(&clock));
X	for(c = cbuf; *c != '\n'; c++);	*c = 0; /* strip off the '\n' */
X	printf("char datestring[] = %c%s%c;\n", '"', cbuf, '"');
X
X	fclose(stdin);
X	fclose(stdout);
X	rename(tmpfile, DATE_FILE);
X}
X
Xdo_data(){
Xint	getpid();
Xchar	tmpfile[30];
XFILE	*freopen();
X
X	sprintf(tmpfile, "%s.base", DATA_FILE);
X	if(freopen(tmpfile, "r+", stdin) == NULL) {
X
X		perror(tmpfile);
X		exit(1);
X	}
X	if(freopen(DATA_FILE, "w+", stdout) == NULL) {
X
X		perror(DATA_FILE);
X		exit(1);
X	}
X
X	while(gets(inline) != NULL) {
X#ifdef KOPS
X	    if(!strcmp(inline, "K	a kobold"))
X		printf("K\ta Keystone Kop\n");
X	    else
X#endif
X#ifdef KAA
X	    if(!strcmp(inline, "Q	a quasit"))
X		printf("Q\ta quantum mechanic\n");
X	    else
X#endif
X#ifdef ROCKMOLE
X	    if(!strcmp(inline, "r	a giant rat"))
X		printf("K\ta rockmole\n");
X	    else
X#endif
X#ifdef SPIDERS
X	    if(!strcmp(inline, "s	a scorpion"))
X		printf("s\ta giant spider\n");
X	    else
X#endif
X		puts(inline);
X	}
X#ifdef KAA
X	printf("9\ta giant\n");
X#endif
X
X	fclose(stdin);
X	fclose(stdout);
X}
X
X#define	LINSZ	1000
X#define	STRSZ	40
X
Xint	fd;
Xstruct	objdef {
X
X	struct	objdef	*next;
X	char	string[STRSZ];
X}	*more, *current;
X
Xdo_objs(){
Xregister int index = 0;
Xregister int propct = 0;
X#ifdef SPELLS
Xregister int nspell = 0;
X#endif
XFILE	*freopen();
Xregister char *sp;
Xchar	*limit();
Xint skip;
X
X	fd = open(OBJ_FILE, 0);
X	if(fd < 0) {
X		perror(OBJ_FILE);
X		exit(1);
X	}
X
X	if(freopen(ONAME_FILE, "w+", stdout) == NULL) {
X		perror(ONAME_FILE);
X		exit(1);
X	}
X
X	current = 0; newobj();
X	skipuntil("objects[] = {");
X
X	while(getentry(&skip)) {
X		if(!*(current->string)){
X			if (skip) index++;
X			continue;
X		}
X		for(sp = current->string; *sp; sp++)
X			if(*sp == ' ' || *sp == '\t' || *sp == '-')
X				*sp = '_';
X
X		/* Do not process duplicates caused by #ifdef/#else pairs. */
X		/* M. Stephenson					   */
X		if (! duplicate()) {
X
X		    if(!strncmp(current->string, "RIN_", 4))
X			    specprop(current->string+4, propct++);
X		    for(sp = current->string; *sp; sp++) capitalize(sp);
X		    /* avoid trouble with stupid C preprocessors */
X		    if(!strncmp(current->string, "WORTHLESS_PIECE_OF_", 19))
X			printf("/* #define\t%s\t%d */\n", current->string, index++);
X		    else  {
X#ifdef SPELLS
X			if(!strncmp(current->string, "SPE_", 4))  nspell++;
X			printf("#define\t%s\t%d\n", limit(current->string), index++);
X#else
X			if(strncmp(current->string, "SPE_", 4))
X			    printf("#define\t%s\t%d\n", limit(current->string), index++);
X#endif
X		    }
X		    newobj();
X		}
X	}
X	printf("\n#define	CORPSE		DEAD_HUMAN\n");
X#ifdef KOPS
X	printf("#define	DEAD_KOP		DEAD_KOBOLD\n");
X#endif
X#ifdef SPIDERS
X	printf("#define	DEAD_GIANT_SPIDER	DEAD_GIANT_SCORPION\n");
X#endif
X#ifdef ROCKMOLE
X	printf("#define	DEAD_ROCKMOLE		DEAD_GIANT_RAT\n");
X#endif
X#ifndef KAA
X	printf("#define DEAD_QUASIT		DEAD_QUANTUM_MECHANIC\n");
X	printf("#define DEAD_VIOLET_FUNGI	DEAD_VIOLET_FUNGUS\n");
X#endif
X	printf("#define	LAST_GEM	(JADE+1)\n");
X	printf("#define	LAST_RING	%d\n", propct);
X#ifdef SPELLS
X	printf("#define MAXSPELL	%d\n", nspell+1);
X#endif
X	printf("#define	NROFOBJECTS	%d\n", index-1);
X	exit(0);
X}
X
Xstatic	char	temp[32];
X
Xchar *
Xlimit(name)	/* limit a name to 30 characters length */
X	char	*name;
X{
X	strncpy(temp, name, 30);
X	temp[30] = 0;
X	return(temp);
X}
X
Xnewobj()
X{
X	extern	long	*alloc();
X
X	more = current;
X	current = (struct objdef *)alloc(sizeof(struct objdef));
X	current->next = more;
X}
X
Xstruct inherent {
X
X	char	*attrib,
X		*monsters;
X}	abilities[] = { "Regeneration", "TVi",
X			"See_invisible", "I",
X			"Poison_resistance", "abcghikqsuvxyADFQSVWXZ&",
X			"Fire_resistance", "gD&",
X			"Cold_resistance", "gFY",
X			"Teleportation", "LNt",
X			"Teleport_control", "t",
X			"", "" };
X
Xspecprop(name, count)
X
X	char	*name;
X	int	count;
X{
X	int	i;
X	char	*tname, *limit();
X
X	tname = limit(name);
X	capitalize(tname);
X	for(i = 0; strlen(abilities[i].attrib); i++)
X	    if(!strcmp(abilities[i].attrib, tname)) {
X
X		printf("#define\tH%s\tu.uprops[%d].p_flgs\n", tname, count);
X		printf("#define\t%s\t((H%s) || index(\"%s\", u.usym))\n",
X			tname, tname, abilities[i].monsters);
X		return(0);
X	    }
X
X	printf("#define\t%s\tu.uprops[%d].p_flgs\n", tname, count);
X	return(0);
X}
X
Xchar line[LINSZ], *lp = line, *lp0 = line, *lpe = line;
Xint xeof;
X
Xreadline(){
Xregister int n = read(fd, lp0, (line+LINSZ)-lp0);
X	if(n < 0){
X		printf("Input error.\n");
X		exit(1);
X	}
X	if(n == 0) xeof++;
X	lpe = lp0+n;
X}
X
Xchar
Xnextchar(){
X	if(lp == lpe){
X		readline();
X		lp = lp0;
X	}
X	return((lp == lpe) ? 0 : *lp++);
X}
X
Xskipuntil(s) char *s; {
Xregister char *sp0, *sp1;
Xloop:
X	while(*s != nextchar())
X		if(xeof) {
X			printf("Cannot skipuntil %s\n", s);
X			exit(1);
X		}
X	if(strlen(s) > lpe-lp+1){
X		register char *lp1, *lp2;
X		lp2 = lp;
X		lp1 = lp = lp0;
X		while(lp2 != lpe) *lp1++ = *lp2++;
X		lp2 = lp0;	/* save value */
X		lp0 = lp1;
X		readline();
X		lp0 = lp2;
X		if(strlen(s) > lpe-lp+1) {
X			printf("error in skipuntil");
X			exit(1);
X		}
X	}
X	sp0 = s+1;
X	sp1 = lp;
X	while(*sp0 && *sp0 == *sp1) sp0++, sp1++;
X	if(!*sp0){
X		lp = sp1;
X		return(1);
X	}
X	goto loop;
X}
X
Xgetentry(skip) int *skip; {
Xint inbraces = 0, inparens = 0, stringseen = 0, commaseen = 0;
Xint prefix = 0;
Xchar ch;
X#define	NSZ	10
Xchar identif[NSZ], *ip;
X	current->string[0] = current->string[4] = 0;
X	/* read until {...} or XXX(...) followed by ,
X	   skip comment and #define lines
X	   deliver 0 on failure
X	 */
X	while(1) {
X		ch = nextchar();
X	swi:
X		if(letter(ch)){
X			ip = identif;
X			do {
X				if(ip < identif+NSZ-1) *ip++ = ch;
X				ch = nextchar();
X			} while(letter(ch) || digit(ch));
X			*ip = 0;
X			while(ch == ' ' || ch == '\t') ch = nextchar();
X			if(ch == '(' && !inparens && !stringseen)
X				if(!strcmp(identif, "WAND") ||
X				   !strcmp(identif, "RING") ||
X				   !strcmp(identif, "POTION") ||
X				   !strcmp(identif, "SPELL") ||
X				   !strcmp(identif, "SCROLL"))
X				(void) strncpy(current->string, identif, 3),
X				current->string[3] = '_',
X				prefix = 4;
X		}
X		switch(ch) {
X		case '/':
X			/* watch for comment */
X			if((ch = nextchar()) == '*')
X				skipuntil("*/");
X			goto swi;
X		case '{':
X			inbraces++;
X			continue;
X		case '(':
X			inparens++;
X			continue;
X		case '}':
X			inbraces--;
X			if(inbraces < 0) return(0);
X			continue;
X		case ')':
X			inparens--;
X			if(inparens < 0) {
X				printf("too many ) ?");
X				exit(1);
X			}
X			continue;
X		case '\n':
X			/* watch for #define at begin of line */
X			if((ch = nextchar()) == '#'){
X				register char pch;
X				/* skip until '\n' not preceded by '\\' */
X				do {
X					pch = ch;
X					ch = nextchar();
X				} while(ch != '\n' || pch == '\\');
X				continue;
X			}
X			goto swi;
X		case ',':
X			if(!inparens && !inbraces){
X				if(prefix && !current->string[prefix]) {
X#ifndef SPELLS
X					*skip = strncmp(current->string, "SPE_", 4);
X#else
X					*skip = 1;
X#endif
X					current->string[0] = 0;
X				}
X				if(stringseen) return(1);
X				printf("unexpected ,\n");
X				exit(1);
X			}
X			commaseen++;
X			continue;
X		case '\'':
X			if((ch = nextchar()) == '\\') ch = nextchar();
X			if(nextchar() != '\''){
X				printf("strange character denotation?\n");
X				exit(1);
X			}
X			continue;
X		case '"':
X			{
X				register char *sp = current->string + prefix;
X				register char pch;
X				register int store = (inbraces || inparens)
X					&& !stringseen++ && !commaseen;
X				do {
X					pch = ch;
X					ch = nextchar();
X					if(store && sp < current->string+STRSZ)
X						*sp++ = ch;
X				} while(ch != '"' || pch == '\\');
X				if(store) *--sp = 0;
X				continue;
X			}
X		}
X	}
X}
X
Xduplicate() {
X
X	char	s[STRSZ];
X	register char	*c;
X	register struct	objdef	*testobj;
X
X	strcpy (s, current->string);
X	for(c = s; *c != 0; c++) capitalize(c);
X
X	for(testobj = more; testobj != 0; testobj = testobj->next)
X		if(! strcmp(s, testobj->string)) return(1);
X
X	return(0);
X}
X
Xcapitalize(sp) register char *sp; {
X	if('a' <= *sp && *sp <= 'z') *sp += 'A'-'a';
X}
X
Xletter(ch) register char ch; {
X	return( ('a' <= ch && ch <= 'z') ||
X		('A' <= ch && ch <= 'Z') );
X}
X
Xdigit(ch) register char ch; {
X	return( '0' <= ch && ch <= '9' );
X}
X
X/* a copy of the panic code from hack.pri.c, edited for standalone use */
X
Xboolean	panicking = 0;
X
Xpanic(str,a1,a2,a3,a4,a5,a6)
Xchar *str;
X{
X	if(panicking++) exit(1);    /* avoid loops - this should never happen*/
X	fputs(" ERROR:  ", stdout);
X	printf(str,a1,a2,a3,a4,a5,a6);
X#ifdef DEBUG
X# ifdef UNIX
X	if(!fork())
X		abort();	/* generate core dump */
X# endif
X#endif
X	exit(1);
X}
X
X#ifdef SYSV
Xrename(oldname, newname)
X	char	*oldname, *newname;
X{
X	if (strcmp(oldname, newname)) {
X
X		unlink(newname);
X		link(oldname, newname);
X		unlink(oldname);
X	}
X}
X#endif
END_OF_makedefs.c
if test 11657 -ne `wc -c <makedefs.c`; then
    echo shar: \"makedefs.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f pri.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"pri.c\"
else
echo shar: Extracting \"pri.c\" \(11689 characters\)
sed "s/^X//" >pri.c <<'END_OF_pri.c'
X/*	SCCS Id: @(#)pri.c	1.3	87/07/14
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* pri.c - version 1.0.3 */
X
X#include <stdio.h>
X#include "hack.h"
X
X#define DEBUG
Xxchar scrlx, scrhx, scrly, scrhy;	/* corners of new area on screen */
X
Xextern char *hu_stat[];	/* in eat.c */
Xextern char *CD;
X
Xswallowed()
X{
X	char *ulook = "|@|";
X	ulook[1] = u.usym;
X
X	cls();
X	curs(u.ux-1, u.uy+1);
X	fputs("/-\\", stdout);
X	curx = u.ux+2;
X	curs(u.ux-1, u.uy+2);
X	fputs(ulook, stdout);
X	curx = u.ux+2;
X	curs(u.ux-1, u.uy+3);
X	fputs("\\-/", stdout);
X	curx = u.ux+2;
X	u.udispl = 1;
X	u.udisx = u.ux;
X	u.udisy = u.uy;
X}
X
Xsetclipped(){
X	error("Hack needs a screen of size at least %d by %d.\n",
X		ROWNO+2, COLNO);
X}
X
X#ifdef DGK
Xstatic int multipleAts;		/* TRUE if we have many at()'s to do */
Xstatic int DECgraphics;		/* The graphics mode toggle */
X
X#define DECgraphicsON() ((void) putchar('\16'), DECgraphics = TRUE)
X#define DECgraphicsOFF() ((void) putchar('\17'), DECgraphics = FALSE)
X#endif
X
Xat(x,y,ch)
Xregister xchar x,y;
Xchar ch;
X{
X#ifndef lint
X	/* if xchar is unsigned, lint will complain about  if(x < 0)  */
X	if(x < 0 || x > COLNO-1 || y < 0 || y > ROWNO-1) {
X		impossible("At gets 0%o at %d %d.", ch, x, y);
X		return;
X	}
X#endif
X	if(!ch) {
X		impossible("At gets null at %d %d.", x, y);
X		return;
X	}
X	y += 2;
X	curs(x,y);
X#ifdef DGK
X	if (flags.DECRainbow) {
X		/* If there are going to be many at()s in a row without
X		 * intervention, only change the graphics mode when the
X		 * character changes between graphic and regular.
X		 */
X		if (multipleAts) {
X			if (ch & 0x80) {
X				if (!DECgraphics)
X					DECgraphicsON();
X				(void) putchar(ch ^ 0x80); /* Strip 8th bit */
X			} else {
X				if (DECgraphics)
X					DECgraphicsOFF();
X				(void) putchar(ch);
X			}
X		/* Otherwise, we don't know how many at()s will be happening
X		 * before printing of normal strings, so change to graphics
X		 * mode when necessary, then change right back.
X		 */
X		} else {
X			if (ch & 0x80) {
X				DECgraphicsON();
X				(void) putchar(ch ^ 0x80); /* Strip 8th bit */
X				DECgraphicsOFF();
X			} else
X				(void) putchar(ch);
X		}
X	} else
X#endif
X		(void) putchar(ch);
X	curx++;
X}
X
Xprme(){
X	if(!Invisible) at(u.ux,u.uy,u.usym);
X}
X
Xdoredraw()
X{
X	docrt();
X	return(0);
X}
X
Xdocrt()
X{
X	register x,y;
X	register struct rm *room;
X	register struct monst *mtmp;
X
X	if(u.uswallow) {
X		swallowed();
X		return;
X	}
X	cls();
X
X/* Some ridiculous code to get display of @ and monsters (almost) right */
X	if(!Invisible) {
X		levl[(u.udisx = u.ux)][(u.udisy = u.uy)].scrsym = u.usym;
X		levl[u.udisx][u.udisy].seen = 1;
X		u.udispl = 1;
X	} else	u.udispl = 0;
X
X	seemons();	/* reset old positions */
X	for(mtmp = fmon; mtmp; mtmp = mtmp->nmon)
X		mtmp->mdispl = 0;
X	seemons();	/* force new positions to be shown */
X/* This nonsense should disappear soon --------------------------------- */
X
X#ifdef DGK
X	/* For DEC Rainbows, we must translate each character to strip
X	 * out the 8th bit if necessary.
X	 */
X	if (flags.DECRainbow) {
X		multipleAts = TRUE;
X		for(y = 0; y < ROWNO; y++)
X			for(x = 0; x < COLNO; x++)
X				if((room = &levl[x][y])->new) {
X					room->new = 0;
X					at(x,y,room->scrsym);
X				} else if(room->seen)
X					at(x,y,room->scrsym);
X		multipleAts = FALSE;
X		if (DECgraphics)
X			DECgraphicsOFF();
X	} else {
X	/* Otherwise, line buffer the output to do the redraw in
X	 * about 2/3 of the time.
X	 */
X		for(y = 0; y < ROWNO; y++) {
X			char buf[COLNO+1];
X			int start, end;
X
X			memset(buf, ' ', COLNO);
X			for(x = 0, start = -1, end = -1; x < COLNO; x++)
X				if((room = &levl[x][y])->new) {
X					room->new = 0;
X					buf[x] = room->scrsym;
X					if (start < 0)
X						start = x;
X					end = x;
X				} else if(room->seen) {
X					buf[x] = room->scrsym;
X					if (start < 0)
X						start = x;
X					end = x;
X				}
X			if (end >= 0) {
X				buf[end + 1] = '\0';
X				curs(start, y + 2);
X				fputs(buf + start, stdout);
X				curx = end + 1;
X			}
X		}
X	}
X#else
X	for(y = 0; y < ROWNO; y++)
X		for(x = 0; x < COLNO; x++)
X			if((room = &levl[x][y])->new) {
X				room->new = 0;
X				at(x,y,room->scrsym);
X			} else if(room->seen)
X				at(x,y,room->scrsym);
X#endif
X	scrlx = COLNO;
X	scrly = ROWNO;
X	scrhx = scrhy = 0;
X	flags.botlx = 1;
X	bot();
X}
X
Xdocorner(xmin,ymax) register xmin,ymax; {
X	register x,y;
X	register struct rm *room;
X	register struct monst *mtmp;
X
X	if(u.uswallow) {	/* Can be done more efficiently */
X		swallowed();
X		return;
X	}
X
X	seemons();	/* reset old positions */
X	for(mtmp = fmon; mtmp; mtmp = mtmp->nmon)
X	    if(mtmp->mx >= xmin && mtmp->my < ymax)
X		mtmp->mdispl = 0;
X	seemons();	/* force new positions to be shown */
X
X#ifdef DGK
X	if (flags.DECRainbow)
X		multipleAts = TRUE;
X#endif
X	for(y = 0; y < ymax; y++) {
X		if(y > ROWNO && CD) break;
X		curs(xmin,y+2);
X		cl_end();
X		if(y < ROWNO) {
X		    for(x = xmin; x < COLNO; x++) {
X			if((room = &levl[x][y])->new) {
X				room->new = 0;
X				at(x,y,room->scrsym);
X			} else
X				if(room->seen)
X					at(x,y,room->scrsym);
X		    }
X		}
X	}
X#ifdef DGK
X	if (flags.DECRainbow) {
X		multipleAts = FALSE;
X		if (DECgraphics)
X			DECgraphicsOFF();
X	}
X#endif
X	if(ymax > ROWNO) {
X		cornbot(xmin-1);
X		if(ymax > ROWNO+1 && CD) {
X			curs(1,ROWNO+3);
X			cl_eos();
X		}
X	}
X}
X
X/* Trolls now regenerate thanks to KAA */
X
Xseeobjs(){
Xregister struct obj *obj, *obj2;
X	for(obj = fobj; obj; obj = obj2) {
X	    obj2 = obj->nobj;
X	    if(obj->olet == FOOD_SYM && obj->otyp >= CORPSE) {
X
X		if (obj->otyp == DEAD_TROLL && obj->age + 20 < moves) {
X			delobj(obj);
X			if (cansee(obj->ox, obj->oy)) 
X				pline("The troll rises from the dead!");
X			(void) makemon(&mons[38],obj->ox, obj->oy);
X		} else if (obj->age + 250 < moves) delobj(obj);
X	    }
X	}
X
X	for(obj = invent; obj; obj = obj2) {
X	    obj2 = obj->nobj;
X	    if(obj->olet == FOOD_SYM && obj->otyp >= CORPSE) {
X
X		if (obj->otyp == DEAD_TROLL && obj->age + 20 < moves) {
X		    if (obj == uwep)
X			pline("The dead troll writhes out of your grasp!");
X		    else
X			pline("You feel squirming in your backpack!");
X		    (void)makemon(&mons[38],u.ux,u.uy);
X		    useup(obj);
X		} else if (obj->age + 250 < moves) useup(obj);
X	    }
X	}
X}
X
Xseemons(){
Xregister struct monst *mtmp;
X	for(mtmp = fmon; mtmp; mtmp = mtmp->nmon){
X		if(mtmp->data->mlet == ';')
X			mtmp->minvis = (u.ustuck != mtmp &&
X					levl[mtmp->mx][mtmp->my].typ == POOL);
X		pmon(mtmp);
X#ifndef NOWORM
X		if(mtmp->wormno) wormsee(mtmp->wormno);
X#endif
X	}
X}
X
Xpmon(mon) register struct monst *mon; {
Xregister int show = (Blind && Telepat) || canseemon(mon);
X	if(mon->mdispl){
X		if(mon->mdx != mon->mx || mon->mdy != mon->my || !show)
X			unpmon(mon);
X	}
X
X/* If you're hallucinating, the monster must be redrawn even if it has
X   already been printed.  Problem: the monster must also be redrawn right
X   after hallucination is over, so it looks normal again.  Therefore 
X   code similar to pmon is in timeout.c. */
X	if(show && (!mon->mdispl || Hallucination)) {
X		if (Hallucination) 
X		atl(mon->mx,mon->my,
X			(!mon->mimic || Protection_from_shape_changers) ?
X				rndmonsym() :
X# ifdef DGK
X				(mon->mappearance==symbol.door) ? symbol.door
X# else
X				(mon->mappearance == DOOR_SYM) ? DOOR_SYM
X# endif
X				: rndobjsym());
X		else
X
X		atl(mon->mx,mon->my,
X		 (!mon->mappearance
X		  || u.uprops[PROP(RIN_PROTECTION_FROM_SHAPE_CHAN)].p_flgs
X		 ) ? mon->data->mlet : mon->mappearance);
X		mon->mdispl = 1;
X		mon->mdx = mon->mx;
X		mon->mdy = mon->my;
X	}
X}
X
Xunpmon(mon) register struct monst *mon; {
X	if(mon->mdispl){
X		newsym(mon->mdx, mon->mdy);
X		mon->mdispl = 0;
X	}
X}
X
Xnscr()
X{
X	register x,y;
X	register struct rm *room;
X
X	if(u.uswallow || u.ux == FAR || flags.nscrinh) return;
X	pru();
X	for(y = scrly; y <= scrhy; y++)
X		for(x = scrlx; x <= scrhx; x++)
X			if((room = &levl[x][y])->new) {
X				room->new = 0;
X				at(x,y,room->scrsym);
X			}
X	scrhx = scrhy = 0;
X	scrlx = COLNO;
X	scrly = ROWNO;
X}
X
X/* 100 suffices for bot(); no relation with COLNO */
Xchar oldbot[100], newbot[100];
Xcornbot(lth)
Xregister int lth;
X{
X	if(lth < sizeof(oldbot)) {
X		oldbot[lth] = 0;
X		flags.botl = 1;
X	}
X}
X
Xbot()
X{
Xregister char *ob = oldbot, *nb = newbot;
Xregister int i;
Xextern char *eos();
X	if(flags.botlx) *ob = 0;
X	flags.botl = flags.botlx = 0;
X	(void) sprintf(newbot,
X#ifdef GOLD_ON_BOTL
X# ifdef SPELLS
X		"Lev %-2d Gp %-5lu Hp %3d(%d) Ep %3d(%d) Ac %-2d  ",
X		dlevel, u.ugold,
X#  ifdef KAA
X		u.mtimedone ? u.mh : u.uhp, u.mtimedone ? u.mhmax : u.uhpmax,
X		u.uen, u.uenmax, u.uac);
X#  else
X		u.uhp, u.uhpmax, u.uen, u.uenmax, u.uac);
X#  endif
X# else
X		"Level %-2d  Gold %-5lu  Hp %3d(%d)  Ac %-2d  ",
X		dlevel, u.ugold,
X#  ifdef KAA
X		u.mtimedone ? u.mh : u.uhp, u.mtimedone ? u.mhmax : u.uhpmax,
X		u.uac);
X#  else
X		u.uhp, u.uhpmax, u.uac);
X#  endif
X# endif
X#else
X# ifdef SPELLS
X		"Level %-2d Hp %3d(%d) Energy %3d(%d) Ac %-2d ",
X		dlevel,
X#  ifdef KAA
X		u.mtimedone ? u.mhp : u.uhp, u.mtimedone ? u.mhmax, u.uhpmax,
X		u.uen, u.uenmax, u.uac);
X#  else
X		u.uhp, u.uhpmax, u.uen, u.uenmax, u.uac);
X#  endif
X# else
X		"Level %-2d   Hp %3d(%d)   Ac %-2d   ",
X		dlevel,
X#  ifdef KAA
X		u.mtimedone ? u.mhp : u.uhp, u.mtimedone ? u.mhmax, u.uhpmax,
X		u.uac);
X#  else
X		u.uhp, u.uhpmax, u.uac);
X#  endif
X# endif
X#endif
X#ifdef KAA
X	if (u.mtimedone)
X		(void) sprintf(eos(newbot), "HD %d", mons[u.umonnum].mlevel);
X	else
X#endif
X	    if(u.ustr>18) {
X		if(u.ustr>117)
X		    (void) strcat(newbot,"Str 18/**");
X		else
X		    (void) sprintf(eos(newbot), "Str 18/%02d",u.ustr-18);
X	    } else
X		(void) sprintf(eos(newbot), "Str %-2d   ",u.ustr);
X#ifdef EXP_ON_BOTL
X	(void) sprintf(eos(newbot), "  Exp %2d/%-5lu ", u.ulevel,u.uexp);
X#else
X	(void) sprintf(eos(newbot), "   Exp %2u  ", u.ulevel);
X#endif
X	(void) strcat(newbot, hu_stat[u.uhs]);
X	if(flags.time)
X	    (void) sprintf(eos(newbot), "  %ld", moves);
X	if(strlen(newbot) >= COLNO) {
X		register char *bp0, *bp1;
X		bp0 = bp1 = newbot;
X		do {
X			if(*bp0 != ' ' || bp0[1] != ' ' || bp0[2] != ' ')
X				*bp1++ = *bp0;
X		} while(*bp0++);
X	}
X	for(i = 1; i<COLNO; i++) {
X		if(*ob != *nb){
X			curs(i,ROWNO+2);
X			(void) putchar(*nb ? *nb : ' ');
X			curx++;
X		}
X		if(*ob) ob++;
X		if(*nb) nb++;
X	}
X	(void) strcpy(oldbot, newbot);
X}
X
X#if defined(WAN_PROBING) || defined(KAA)
Xmstatusline(mtmp) register struct monst *mtmp; {
X	pline("Status of %s: ", monnam(mtmp));
X	pline("Level %-2d  Gold %-5lu  Hp %3d(%d)",
X	    mtmp->data->mlevel, mtmp->mgold, mtmp->mhp, mtmp->mhpmax);
X	pline("Ac %-2d  Dam %d %s %s",
X	    mtmp->data->ac, (mtmp->data->damn + 1) * (mtmp->data->damd + 1),
X	    mtmp->mcan ? ", cancelled" : "" ,mtmp->mtame ? " (tame)" : "");
X}
X
Xextern char plname[];
Xustatusline() {
X	pline("Status of %s ", plname);
X	pline("Level %d, gold %lu, hit points %d(%d), AC %d.",
X# ifdef KAA
X		u.ulevel, u.ugold, u.mtimedone ? u.mh : u.uhp,
X		u.mtimedone ? u.mhmax : u.uhpmax, u.uac);
X# else
X		u.ulevel, u.ugold, u.uhp, u.uhpmax, u.uac);
X# endif
X}
X#endif
X
Xcls(){
X	if(flags.toplin == 1)
X		more();
X	flags.toplin = 0;
X
X	clear_screen();
X
X	flags.botlx = 1;
X}
X
Xrndmonsym() {
X	register int x;
X	if((x=rn2(58)) < 26)
X		return('a'+x);
X	else if (x<52)
X		return('A'+x-26);
X	else switch(x) {
X		case 52: return(';');
X		case 53: return('&');
X		case 54: return(':');
X		case 55: return('\'');
X		case 56: return(',');
X		case 57: return('9');
X		default: impossible("Bad random monster %d",x); return('{');
X	}
X}
X
Xrndobjsym() {
X	char *rndsym=")[!?%/=*($'";
X	return *(rndsym+rn2(11));
X}
X
Xchar *hcolors[] = { "ultraviolet","infrared","hot pink", "psychedelic",
X"bluish-orange","reddish-green","dark white","light black","loud",
X"salty","sweet","sour","bitter","luminescent","striped","polka-dotted",
X"square","round","triangular","brilliant","navy blue","cerise",
X"charteruse","copper","sea green","spiral","swirly","blotchy",
X"fluorescent green","burnt orange","indigo","amber","tan",
X"sky blue-pink","lemon yellow" };
X
Xchar *
Xhcolor() {
X	return hcolors[rn2(35)];
X}
END_OF_pri.c
if test 11689 -ne `wc -c <pri.c`; then
    echo shar: \"pri.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f rumors.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"rumors.c\"
else
echo shar: Extracting \"rumors.c\" \(2892 characters\)
sed "s/^X//" >rumors.c <<'END_OF_rumors.c'
X/*	SCCS Id: @(#)rumors.c	1.3	87/07/14
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* hack.rumors.c - version 1.0.3 */
X
X#include	<stdio.h>
X#include	"hack.h"		/* for RUMORFILE and BSD (index) */
X#ifdef DGK
X/* Rumors has been entirely rewritten to speed up the access.  This is
X * essential when working from floppies.  Using fseek() the way that's done
X * here means rumors following longer rumors are output more often than those
X * following shorter rumors.  Also, you may see the same rumor more than once
X * in a particular game (although the odds are highly against it), but
X * this also happens with real fortune cookies.  Besides, a person can
X * just read the rumor file if they desire.  -dgk
X */
Xlong rumors_size;
Xextern char *index();
Xextern long ftell();
X
Xoutrumor()
X{
X	char	line[COLNO];
X	char	*endp;
X	char	roomer[FILENAME];
X	FILE	*rumors;
X
X	if (rumors_size < 0)	/* We couldn't open RUMORFILE */
X		return;
X	if(rumors = fopen(RUMORFILE, "r")) {
X		if (!rumors_size) {	/* if this is the first outrumor() */
X			fseek(rumors, 0L, 2);
X			rumors_size = ftell(rumors);
X		}
X		fseek(rumors, rand() % rumors_size, 0);
X		fgets(line, COLNO, rumors);
X		if (!fgets(line, COLNO, rumors)) {	/* at EOF ? */
X			fseek(rumors, 0L, 0);		/* seek back to start */
X			fgets(line, COLNO, rumors);
X		}
X		if(endp = index(line, '\n')) *endp = 0;
X		pline("This cookie has a scrap of paper inside! It reads: ");
X		pline(line);
X		fclose(rumors);
X	} else {
X		pline("Can't open rumors file!");
X		rumors_size = -1;	/* don't try to open it again */
X	}
X}
X
X#else
X
X#define	CHARSZ	8			/* number of bits in a char */
Xextern long *alloc();
Xextern char *index();
Xint n_rumors = 0;
Xint n_used_rumors = -1;
Xchar *usedbits;
X
Xinit_rumors(rumf) register FILE *rumf; {
Xregister int i;
X	n_used_rumors = 0;
X	while(skipline(rumf)) n_rumors++;
X	rewind(rumf);
X	i = n_rumors/CHARSZ;
X	usedbits = (char *) alloc((unsigned)(i+1));
X	for( ; i>=0; i--) usedbits[i] = 0;
X}
X
Xskipline(rumf) register FILE *rumf; {
Xchar line[COLNO];
X	while(1) {
X		if(!fgets(line, sizeof(line), rumf)) return(0);
X		if(index(line, '\n')) return(1);
X	}
X}
X
Xoutline(rumf) register FILE *rumf; {
Xchar line[COLNO];
Xregister char *ep;
X	if(!fgets(line, sizeof(line), rumf)) return;
X	if((ep = index(line, '\n')) != 0) *ep = 0;
X	pline("This cookie has a scrap of paper inside! It reads: ");
X	pline(line);
X}
X
Xoutrumor(){
Xregister int rn,i;
Xregister FILE *rumf;
X	if(n_rumors <= n_used_rumors ||
X	  (rumf = fopen(RUMORFILE, "r")) == (FILE *) 0) return;
X	if(n_used_rumors < 0) init_rumors(rumf);
X	if(!n_rumors) goto none;
X	rn = rn2(n_rumors - n_used_rumors);
X	i = 0;
X	while(rn || used(i)) {
X		(void) skipline(rumf);
X		if(!used(i)) rn--;
X		i++;
X	}
X	usedbits[i/CHARSZ] |= (1 << (i % CHARSZ));
X	n_used_rumors++;
X	outline(rumf);
Xnone:
X	(void) fclose(rumf);
X}
X
Xused(i) register int i; {
X	return(usedbits[i/CHARSZ] & (1 << (i % CHARSZ)));
X}
X
X#endif /* DGK /**/
END_OF_rumors.c
if test 2892 -ne `wc -c <rumors.c`; then
    echo shar: \"rumors.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f unixmain.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"unixmain.c\"
else
echo shar: Extracting \"unixmain.c\" \(11886 characters\)
sed "s/^X//" >unixmain.c <<'END_OF_unixmain.c'
X/*	SCCS Id: @(#)unixmain.c	1.3	87/07/14
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* main.c - (Unix) version 1.0.3 */
X
X#include <stdio.h>
X#include <signal.h>
X#include "hack.h"
X
X#ifdef QUEST
X#define	gamename	"NetQuest"
X#else
X#define	gamename	"NetHack"
X#endif
X
Xextern char *getlogin(), *getenv();
Xextern char plname[PL_NSIZ], pl_character[PL_CSIZ];
X
Xint (*afternmv)();
Xint (*occupation)();
X
Xint done1();
Xint hangup();
X
Xint hackpid;				/* current pid */
Xint locknum;				/* max num of players */
X#ifdef DEF_PAGER
Xchar *catmore;				/* default pager */
X#endif
Xchar SAVEF[PL_NSIZ + 11] = "save/";	/* save/99999player */
Xchar *hname;		/* name of the game (argv[0] of call) */
Xchar obuf[BUFSIZ];	/* BUFSIZ is defined in stdio.h */
X
Xextern char *nomovemsg;
Xextern long wailmsg;
X
Xmain(argc,argv)
Xint argc;
Xchar *argv[];
X{
X	register int fd;
X#ifdef CHDIR
X	register char *dir;
X#endif
X
X	hname = argv[0];
X	hackpid = getpid();
X
X#ifdef CHDIR			/* otherwise no chdir() */
X	/*
X	 * See if we must change directory to the playground.
X	 * (Perhaps hack runs suid and playground is inaccessible
X	 *  for the player.)
X	 * The environment variable HACKDIR is overridden by a
X	 *  -d command line option (must be the first option given)
X	 */
X
X	dir = getenv("HACKDIR");
X	if(argc > 1 && !strncmp(argv[1], "-d", 2)) {
X		argc--;
X		argv++;
X		dir = argv[0]+2;
X		if(*dir == '=' || *dir == ':') dir++;
X		if(!*dir && argc > 1) {
X			argc--;
X			argv++;
X			dir = argv[0];
X		}
X		if(!*dir)
X		    error("Flag -d must be followed by a directory name.");
X	}
X#endif /* CHDIR /**/
X#ifdef DGKMOD
X	initoptions();
X#endif
X	whoami();
X	/*
X	 * Now we know the directory containing 'record' and
X	 * may do a prscore().
X	 */
X	if(argc > 1 && !strncmp(argv[1], "-s", 2)) {
X#ifdef CHDIR
X		chdirx(dir,0);
X#endif
X		prscore(argc, argv);
X		exit(0);
X	}
X
X	/*
X	 * It seems he really wants to play.
X	 * Remember tty modes, to be restored on exit.
X	 */
X	gettty();
X	setbuf(stdout,obuf);
X	setrandom();
X	startup();
X	init_corpses();	/* initialize optional corpse names */
X	cls();
X	u.uhp = 1;	/* prevent RIP on early quits */
X	u.ux = FAR;	/* prevent nscr() */
X	(void) signal(SIGHUP, hangup);
X
X	/*
X	 * Find the creation date of this game,
X	 * so as to avoid restoring outdated savefiles.
X	 */
X	gethdate(hname);
X
X	/*
X	 * We cannot do chdir earlier, otherwise gethdate will fail.
X	 */
X#ifdef CHDIR
X	chdirx(dir,1);
X#endif
X
X	/*
X	 * Process options.
X	 */
X	while(argc > 1 && argv[1][0] == '-'){
X		argv++;
X		argc--;
X		switch(argv[0][1]){
X#ifdef WIZARD
X		case 'D':
X			if(!strcmp(getlogin(), WIZARD))
X				wizard = TRUE;
X			else
X				printf("Sorry.\n");
X			break;
X#endif
X#ifdef NEWS
X		case 'n':
X			flags.nonews = TRUE;
X			break;
X#endif
X		case 'u':
X			if(argv[0][2])
X			  (void) strncpy(plname, argv[0]+2, sizeof(plname)-1);
X			else if(argc > 1) {
X			  argc--;
X			  argv++;
X			  (void) strncpy(plname, argv[0], sizeof(plname)-1);
X			} else
X				printf("Player name expected after -u\n");
X			break;
X		default:
X			/* allow -T for Tourist, etc. */
X			(void) strncpy(pl_character, argv[0]+1,
X				sizeof(pl_character)-1);
X
X			/* printf("Unknown option: %s\n", *argv); */
X		}
X	}
X
X	if(argc > 1)
X		locknum = atoi(argv[1]);
X#ifdef MAX_NR_OF_PLAYERS
X	if(!locknum || locknum > MAX_NR_OF_PLAYERS)
X		locknum = MAX_NR_OF_PLAYERS;
X#endif
X#ifdef DEF_PAGER
X	if(!(catmore = getenv("HACKPAGER")) && !(catmore = getenv("PAGER")))
X		catmore = DEF_PAGER;
X#endif
X#ifdef MAIL
X	getmailstatus();
X#endif
X#ifdef WIZARD
X	if(wizard) (void) strcpy(plname, "wizard"); else
X#endif
X	if(!*plname || !strncmp(plname, "player", 4)
X		    || !strncmp(plname, "games", 4))
X		askname();
X	plnamesuffix();		/* strip suffix from name; calls askname() */
X				/* again if suffix was whole name */
X				/* accepts any suffix */
X#ifdef WIZARD
X	if(!wizard) {
X#endif
X		/*
X		 * check for multiple games under the same name
X		 * (if !locknum) or check max nr of players (otherwise)
X		 */
X		(void) signal(SIGQUIT,SIG_IGN);
X		(void) signal(SIGINT,SIG_IGN);
X		if(!locknum)
X			(void) strcpy(lock,plname);
X		getlock();	/* sets lock if locknum != 0 */
X#ifdef WIZARD
X	} else {
X		register char *sfoo;
X		extern char genocided[], fut_geno[];
X		(void) strcpy(lock,plname);
X		if(sfoo = getenv("MAGIC"))
X			while(*sfoo) {
X				switch(*sfoo++) {
X				case 'n': (void) srand(*sfoo++);
X					break;
X				}
X			}
X		if(sfoo = getenv("GENOCIDED")){
X			if(*sfoo == '!'){
X				extern struct permonst mons[CMNUM+2];
X				register struct permonst *pm = mons;
X				register char *gp = genocided;
X
X				while(pm < mons+CMNUM+2){
X					if(!index(sfoo, pm->mlet))
X						*gp++ = pm->mlet;
X					pm++;
X				}
X				*gp = 0;
X			} else
X				(void) strcpy(genocided, sfoo);
X			(void) strcpy(fut_geno, genocided);
X		}
X	}
X#endif /* WIZARD /**/
X	setftty();
X	(void) sprintf(SAVEF, "save/%d%s", getuid(), plname);
X	regularize(SAVEF+5);		/* avoid . or / in name */
X	if((fd = open(SAVEF,0)) >= 0 &&
X	   (uptodate(fd) || unlink(SAVEF) == 666)) {
X		(void) signal(SIGINT,done1);
X		pline("Restoring old save file...");
X		(void) fflush(stdout);
X		if(!dorecover(fd))
X			goto not_recovered;
X		pline("Hello %s, welcome to %s!", plname, gamename);
X		flags.move = 0;
X	} else {
Xnot_recovered:
X		newgame();
X		/* give welcome message before pickup messages */
X		pline("Hello %s, welcome to %s!", plname, gamename);
X
X		pickup(1);
X		if(!Blind) read_engr_at(u.ux,u.uy);
X		flags.move = 1;
X	}
X
X	flags.moonphase = phase_of_the_moon();
X	if(flags.moonphase == FULL_MOON) {
X		pline("You are lucky! Full moon tonight.");
X		if(!u.uluck) u.uluck++;
X	} else if(flags.moonphase == NEW_MOON) {
X		pline("Be careful! New moon tonight.");
X	}
X
X	initrack();
X
X	for(;;) {
X		if(flags.move) {	/* actual time passed */
X
X			settrack();
X
X			if(moves%2 == 0 ||
X			  (!(Fast & ~INTRINSIC) && (!Fast || rn2(3)))) {
X				extern struct monst *makemon();
X				movemon();
X				if(!rn2(70))
X				    (void) makemon((struct permonst *)0, 0, 0);
X			}
X			if(Glib) glibr();
X			timeout();
X			++moves;
X#ifdef PRAYERS
X			if (u.ublesscnt)  u.ublesscnt--;
X#endif
X			if(flags.time) flags.botl = 1;
X#ifdef KAA
X			if(u.mtimedone)
X			    if(u.mh < 1) rehumanize();
X			else
X#endif
X			    if(u.uhp < 1) {
X				pline("You die...");
X				done("died");
X			    }
X			if(u.uhp*10 < u.uhpmax && moves-wailmsg > 50){
X			    wailmsg = moves;
X#ifdef KAA
X			    if(index("WEV", pl_character[0])) {
X				if (u.uhp == 1)
X				pline("%s is about to die.", pl_character);
X				else
X				pline("%s, your life force is running out.",
X					pl_character);
X			    } else {
X#endif
X				if(u.uhp == 1)
X				pline("You hear the wailing of the Banshee...");
X				else
X				pline("You hear the howling of the CwnAnnwn...");
X#ifdef KAA
X			    }
X#endif
X			}
X#ifdef KAA
X			if (u.mtimedone) {
X			    if (u.mh < u.mhmax) {
X				if (Regeneration || !(moves%20)) {
X					flags.botl = 1;
X					u.mh++;
X				}
X			    }
X			}
X#endif
X			if(u.uhp < u.uhpmax) {
X				if(u.ulevel > 9) {
X					if(HRegeneration || !(moves%3)) {
X					    flags.botl = 1;
X					    u.uhp += rnd((int) u.ulevel-9);
X					    if(u.uhp > u.uhpmax)
X						u.uhp = u.uhpmax;
X					}
X				} else if(HRegeneration ||
X					(!(moves%(22-u.ulevel*2)))) {
X					flags.botl = 1;
X					u.uhp++;
X				}
X			}
X#ifdef SPELLS
X			if ((u.uen<u.uenmax) && (!(moves%(21-u.ulevel/2)))) {
X				u.uen += rn2(u.ulevel/4 + 1) + 1;
X				if (u.uen > u.uenmax)  u.uen = u.uenmax;
X				flags.botl = 1;
X			}
X#endif
X			if(Teleportation && !rn2(85)) tele();
X			if(Searching && multi >= 0) (void) dosearch();
X			gethungry();
X			invault();
X			amulet();
X#ifdef HARD
X			if (u.udemigod) {
X
X				u.udg_cnt--;
X				if(u.udg_cnt <= 0) {
X
X					intervene();
X					u.udg_cnt = rn1(200, 50);
X				}
X			}
X#endif
X		}
X		if(multi < 0) {
X			if(!++multi){
X				pline(nomovemsg ? nomovemsg :
X					"You can move again.");
X				nomovemsg = 0;
X				if(afternmv) (*afternmv)();
X				afternmv = 0;
X			}
X		}
X
X		find_ac();
X#ifndef QUEST
X		if(!flags.mv || Blind)
X#endif
X		{
X			seeobjs();
X			seemons();
X			nscr();
X		}
X#ifdef DGK
X		if(flags.time) flags.botl = 1;
X#endif
X		if(flags.botl || flags.botlx) bot();
X
X		flags.move = 1;
X
X		if(multi >= 0 && occupation) {
X
X			if (monster_nearby())
X				stop_occupation();
X			else if ((*occupation)() == 0)
X				occupation = 0;
X			continue;
X		}
X
X		if(multi > 0) {
X#ifdef QUEST
X			if(flags.run >= 4) finddir();
X#endif
X			lookaround();
X			if(!multi) {	/* lookaround may clear multi */
X				flags.move = 0;
X				continue;
X			}
X			if(flags.mv) {
X				if(multi < COLNO && !--multi)
X					flags.mv = flags.run = 0;
X				domove();
X			} else {
X				--multi;
X				rhack(save_cm);
X			}
X		} else if(multi == 0) {
X#ifdef MAIL
X			ckmailstatus();
X#endif
X			rhack((char *) 0);
X		}
X		if(multi && multi%7 == 0)
X			(void) fflush(stdout);
X	}
X}
X
Xglo(foo)
Xregister foo;
X{
X	/* construct the string  xlock.n  */
X	register char *tf;
X
X	tf = lock;
X	while(*tf && *tf != '.') tf++;
X	(void) sprintf(tf, ".%d", foo);
X}
X
X/*
X * plname is filled either by an option (-u Player  or  -uPlayer) or
X * explicitly (-w implies wizard) or by askname.
X * It may still contain a suffix denoting pl_character.
X */
Xaskname(){
Xregister int c,ct;
X	printf("\nWho are you? ");
X	(void) fflush(stdout);
X	ct = 0;
X	while((c = getchar()) != '\n'){
X		if(c == EOF) error("End of input\n");
X		/* some people get confused when their erase char is not ^H */
X		if(c == '\010') {
X			if(ct) ct--;
X			continue;
X		}
X		if(c != '-')
X		if(c < 'A' || (c > 'Z' && c < 'a') || c > 'z') c = '_';
X		if(ct < sizeof(plname)-1) plname[ct++] = c;
X	}
X	plname[ct] = 0;
X	if(ct == 0) askname();
X}
X
X/*VARARGS1*/
Ximpossible(s,x1,x2)
Xregister char *s;
X{
X	pline(s,x1,x2);
X	pline("Program in disorder - perhaps you'd better Quit.");
X}
X
X#ifdef CHDIR
Xstatic
Xchdirx(dir, wr)
Xchar *dir;
Xboolean wr;
X{
X
X# ifdef SECURE
X	if(dir					/* User specified directory? */
X#  ifdef HACKDIR
X	       && strcmp(dir, HACKDIR)		/* and not the default? */
X#  endif
X		) {
X		(void) setuid(getuid());		/* Ron Wessels */
X		(void) setgid(getgid());
X	}
X# endif
X
X# ifdef HACKDIR
X	if(dir == NULL)
X		dir = HACKDIR;
X# endif
X
X	if(dir && chdir(dir) < 0) {
X		perror(dir);
X		error("Cannot chdir to %s.", dir);
X	}
X
X	/* warn the player if he cannot write the record file */
X	/* perhaps we should also test whether . is writable */
X	/* unfortunately the access systemcall is worthless */
X	if(wr) {
X	    register fd;
X
X	    if(dir == NULL)
X		dir = ".";
X	    if((fd = open(RECORD, 2)) < 0) {
X		printf("Warning: cannot write %s/%s", dir, RECORD);
X		getret();
X	    } else
X		(void) close(fd);
X	}
X}
X#endif /* CHDIR /**/
X
Xstop_occupation()
X{
X	if(occupation) {
X		pline("You stop %s.", occtxt);
X		occupation = 0;
X#ifdef REDO
X		multi = 0;
X		pushch(0);		
X#endif
X	}
X}
X
Xwhoami() {
X	/*
X	 * Who am i? Algorithm: 1. Use name as specified in HACKOPTIONS
X	 *			2. Use $USER or $LOGNAME	(if 1. fails)
X	 *			3. Use getlogin()		(if 2. fails)
X	 * The resulting name is overridden by command line options.
X	 * If everything fails, or if the resulting name is some generic
X	 * account like "games", "play", "player", "hack" then eventually
X	 * we'll ask him.
X	 * Note that we trust him here; it is possible to play under
X	 * somebody else's name.
X	 */
X	register char *s;
X
X#ifndef DGKMOD
X	initoptions();
X#endif
X	if(!*plname && (s = getenv("USER")))
X		(void) strncpy(plname, s, sizeof(plname)-1);
X	if(!*plname && (s = getenv("LOGNAME")))
X		(void) strncpy(plname, s, sizeof(plname)-1);
X	if(!*plname && (s = getlogin()))
X		(void) strncpy(plname, s, sizeof(plname)-1);
X}
X
Xnewgame() {
X	fobj = fcobj = invent = 0;
X	fmon = fallen_down = 0;
X	ftrap = 0;
X	fgold = 0;
X	flags.ident = 1;
X	init_objects();
X	u_init();
X
X	(void) signal(SIGINT,done1);
X	mklev();
X	u.ux = xupstair;
X	u.uy = yupstair;
X	(void) inshop();
X	setsee();
X	flags.botlx = 1;
X	{
X		register struct monst *mtmp;
X
X		/* Move the monster from under you or else
X		 * makedog() will fail when it calls makemon().
X		 * 			- ucsfcgl!kneller
X		 */
X		if (mtmp = m_at(u.ux, u.uy))  mnexto(mtmp);
X	}
X	(void) makedog();
X	seemons();
X#ifdef NEWS
X	if(flags.nonews || !readnews())
X		/* after reading news we did docrt() already */
X#endif
X		docrt();
X	return(0);
X}
END_OF_unixmain.c
if test 11886 -ne `wc -c <unixmain.c`; then
    echo shar: \"unixmain.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
echo shar: End of archive 9 \(of 16\).
cp /dev/null ark9isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 16 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit++;
