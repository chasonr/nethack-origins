Relay-Version: version B 2.10 5/3/83; site utzoo.UUCP
Path: utzoo!mnetor!uunet!seismo!columbia!rutgers!sri-spam!ames!ucbcad!ucbvax!decvax!tektronix!tekgen!tekred!games-request
From: games-request@tekred.TEK.COM
Newsgroups: comp.sources.games
Subject: v02i015:  nethack - display oriented dungeons & dragons, Part15/16
Message-ID: <1457@tekred.TEK.COM>
Date: Tue, 28-Jul-87 14:54:42 EDT
Article-I.D.: tekred.1457
Posted: Tue Jul 28 14:54:42 1987
Date-Received: Fri, 31-Jul-87 00:36:13 EDT
Sender: billr@tekred.TEK.COM
Lines: 2214
Approved: billr@tekred.TEK.COM

Submitted by: mike@genat.UUCP (Mike Stephenson)
Comp.sources.games: Volume 2, Issue 15
Archive-name: nethack/Part15



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 15 (of 16)."
# Contents:  Makefile.pc bones.c dog.c mkobj.c monst.c pctty.c pray.c
#   rumors.kaa search.c sit.c topl.c write.c you.h
# Wrapped by billr@tekred on Tue Jul 28 09:49:49 1987
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f Makefile.pc -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"Makefile.pc\"
else
echo shar: Extracting \"Makefile.pc\" \(3966 characters\)
sed "s/^X//" >Makefile.pc <<'END_OF_Makefile.pc'
X#
X#	SCCS Id: @(#)Makefile.pc	1.3	87/07/14
X# 	Makefile for NetHack (PC) version 1.0 written using
X#	Microsoft(tm) "C" v3.0 or better.
X# 
X# Large memory model, register bug, remove stack probes:
XWIZARD=
XV = 35
XCFLAGS = -AL -DREGBUG -DLINT_ARGS -DVER=$V $(WIZARD) -Ot -Gs
X
X# The game name
XGAME = hack.exe
X
X# The game directory
XGAMEDIR = \h
X
X# All object modules
XOBJS = decl.obj apply.obj bones.obj cmd.obj do.obj \
X	do_name.obj do_wear.obj dog.obj dogmove.obj eat.obj end.obj \
X	engrave.obj fight.obj fountain.obj hack.obj invent.obj \
X	lev.obj main.obj makemon.obj mhitu.obj mklev.obj \
X	mkmaze.obj mkobj.obj mkshop.obj mon.obj monmove.obj\
X	monst.obj o_init.obj objnam.obj options.obj \
X	pager.obj polyself.obj potion.obj pray.obj pri.obj prisym.obj\
X	read.obj rip.obj rumors.obj save.obj \
X	search.obj shk.obj shknam.obj sit.obj spell.obj steal.obj \
X	termcap.obj timeout.obj topl.obj topten.obj track.obj trap.obj \
X	tty.obj unix.obj u_init.obj vault.obj wield.obj \
X	wizard.obj worm.obj worn.obj write.obj zap.obj \
X	version.obj rnd.obj alloc.obj msdos.obj
X
X# The main target
X#
X$(GAME) : $(OBJS)
X	link $(OBJS), $(GAME) /NOIG /STACK:4000 /CP:1;
X
X#	variable auxilary files.
X#
XVARAUX = data rumors
X
Xinstall : $(GAME) $(VARAUX)
X	- exepack $(GAME) $(GAMEDIR)\$(GAME)
X	- exemod $(GAMEDIR)\$(GAME) /max 1
X
Xclean :
X	erase $(GAME)
X
Xspotless: clean
X	erase *.obj
X	erase main.c
X	erase tty.c
X	erase unix.c
X
Xsrcs :
X	copy makefile \tmp
X	copy *.c \tmp
X	copy *.h \tmp
X	copy \local\make\make.doc \tmp
X	copy \local\make\make.ini \tmp
X	copy \bin\make.exe \tmp
X	cd \tmp
X	time
X	touch *.*
X	arc m hack$Vs * *.*
X	cd $(CWD)
X
X
X#	Other dependencies
X#
XRUMORFILES= rumors.base rumors.kaa rumors.mrx
X
Xrumors :  config.h $(RUMORFILES) makedefs
X	./makedefs -r
X
Xdata :  config.h data.base makedefs
X	./makedefs -d
X
Xonames.h :  config.h objects.h makedefs
X	./makedefs -o
X
X#	Below is a kluge.  date.h should actually depend on any source
X#	module being changed. (but hack.h is close enough for most).
X#
Xdate.h :  hack.h makedefs
X	./makedefs -D
X
Xtrap.h :  config.h makedefs
X	./makedefs -t
X
Xmain.obj :
X
Xmain.c :  pcmain.c hack.h
X	copy pcmain.c main.c
X
Xtty.obj :
X
Xtty.c :  pctty.c hack.h msdos.h
X	copy pctty.c tty.c
X
Xunix.obj :
X
Xunix.c :  pcunix.c hack.h mkroom.h
X	copy pcunix.c unix.c
X
Xdecl.obj :  hack.h mkroom.h
Xapply.obj :  hack.h edog.h mkroom.h
Xbones.obj :  hack.h
Xhack.obj :  hack.h
Xcmd.obj :  hack.h func_tab.h msdos.h
Xdo.obj :  hack.h
Xdo_name.obj :  hack.h
Xdo_wear.obj :  hack.h
Xdog.obj :  hack.h edog.h mkroom.h
Xdogmove.obj :  hack.h mfndpos.h
Xeat.obj :  hack.h
Xend.obj :  hack.h
Xengrave.obj :  hack.h
Xfight.obj :  hack.h
Xfountain.obj :  hack.h
Xinvent.obj :  hack.h wseg.h
Xioctl.obj :  config.h
Xlev.obj :  hack.h mkroom.h wseg.h
Xmakemon.obj :  hack.h
Xmhitu.obj :  hack.h
Xmklev.obj :  hack.h mkroom.h
Xmkmaze.obj :  hack.h mkroom.h
Xmkobj.obj :  hack.h
Xmkshop.obj :  hack.h mkroom.h eshk.h
Xmon.obj :  hack.h mfndpos.h
Xmonmove.obj :  hack.h mfndpos.h
Xmonst.obj :  hack.h eshk.h
Xo_init.obj :  config.h objects.h onames.h
Xobjnam.obj :  hack.h
Xoptions.obj :  config.h hack.h
Xpager.obj :  hack.h
Xpolyself.obj :  hack.h
Xpotion.obj :  hack.h
Xpray.obj :  hack.h
Xpri.obj :  hack.h
Xprisym.obj :  hack.h wseg.h
Xread.obj :  hack.h
Xrip.obj :  hack.h
Xrumors.obj :  config.h
Xsave.obj :  hack.h
Xsearch.obj :  hack.h
Xshk.obj :  hack.h mfndpos.h mkroom.h eshk.h
Xshknam.obj :  hack.h
Xsit.obj :  hack.h
Xspell.obj:  hack.h
Xsteal.obj :  hack.h
Xtermcap.obj :  config.h flag.h
Xtimeout.obj :  hack.h
Xtopl.obj :  hack.h
Xtopten.obj :  hack.h
Xtrack.obj :  hack.h
Xtrap.obj :  hack.h mkroom.h
Xu_init.obj :  hack.h
Xvault.obj :  hack.h mkroom.h
Xversion.obj : hack.h date.h
Xwield.obj :  hack.h
Xwizard.obj :  hack.h
Xworm.obj :  hack.h wseg.h
Xworn.obj :  hack.h
Xwrite.obj :  hack.h
Xzap.obj :  hack.h
Xmsdos.obj : msdos.h
Xextern.h: config.h
X	touch extern.h
Xhack.h :  config.h objclass.h monst.h gold.h trap.h obj.h flag.h rm.h permonst.h onames.h spell.h extern.h you.h
X	touch hack.h
Xobjects.h :  config.h objclass.h
X	touch objects.h
END_OF_Makefile.pc
if test 3966 -ne `wc -c <Makefile.pc`; then
    echo shar: \"Makefile.pc\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f bones.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"bones.c\"
else
echo shar: Extracting \"bones.c\" \(3830 characters\)
sed "s/^X//" >bones.c <<'END_OF_bones.c'
X/*	SCCS Id: @(#)bones.c	1.3	87/07/14
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* bones.c - version 1.0.3 */
X
X#include "hack.h"
Xextern char plname[PL_NSIZ];
Xextern long somegold();
Xextern struct monst *makemon();
Xextern struct permonst pm_ghost;
X
X#ifdef DGK
Xchar bones[FILENAME];
X#else
Xchar bones[] = "bones_xx";
X#endif
X
X/* save bones and possessions of a deceased adventurer */
Xsavebones(){
Xregister fd;
Xregister struct obj *otmp;
Xregister struct trap *ttmp;
Xregister struct monst *mtmp;
X	if(dlevel <= 0 || dlevel > MAXLEVEL) return;
X	if(!rn2(1 + dlevel/2)	/* not so many ghosts on low levels */
X#ifdef WIZARD
X		&& !wizard
X#endif
X		) return;
X#ifdef DGK
X	name_file(bones, dlevel);
X#else
X	bones[6] = '0' + (dlevel/10);
X	bones[7] = '0' + (dlevel%10);
X#endif
X	if((fd = open(bones,0)) >= 0){
X		(void) close(fd);
X#ifdef WIZARD
X		if(wizard)
X			pline("Bones file already exists.");
X#endif
X		return;
X	}
X	/* drop everything; the corpse's possessions are usually cursed */
X	otmp = invent;
X	while(otmp){
X		otmp->ox = u.ux;
X		otmp->oy = u.uy;
X		otmp->age = 0;		/* very long ago */
X		otmp->owornmask = 0;
X		if(rn2(5)) otmp->cursed = 1;
X		if(!otmp->nobj){
X			otmp->nobj = fobj;
X			fobj = invent;
X			invent = 0;	/* superfluous */
X			break;
X		}
X		otmp = otmp->nobj;
X	}
X	/* spill any contained objects - added by GAN 03/23/87 */
X	otmp = fcobj;
X	while(otmp)  {
X		register struct obj *otmp2;
X
X		otmp2 = otmp->nobj;
X		spill_obj(otmp);
X		otmp = otmp2;
X	}
X	if(!(mtmp = makemon(PM_GHOST, u.ux, u.uy))) return;
X	mtmp->mx = u.ux;
X	mtmp->my = u.uy;
X	mtmp->msleep = 1;
X	(void) strcpy((char *) mtmp->mextra, plname);
X	mkgold(somegold() + d(dlevel,30), u.ux, u.uy);
X	for(mtmp = fmon; mtmp; mtmp = mtmp->nmon){
X		mtmp->m_id = 0;
X		if(mtmp->mtame) {
X			mtmp->mtame = 0;
X			mtmp->mpeaceful = 0;
X		}
X		mtmp->mlstmv = 0;
X		if(mtmp->mdispl) unpmon(mtmp);
X	}
X	for(ttmp = ftrap; ttmp; ttmp = ttmp->ntrap)
X		ttmp->tseen = 0;
X	for(otmp = fobj; otmp; otmp = otmp->nobj) {
X		otmp->o_id = 0;
X	     /* otmp->o_cnt_id = 0; - superfluous */
X		otmp->onamelth = 0;
X		otmp->known = 0;
X		otmp->invlet = 0;
X		if(otmp->olet == AMULET_SYM && !otmp->spe) {
X			otmp->spe = -1;      /* no longer the actual amulet */
X			otmp->cursed = 1;    /* flag as gotten from a ghost */
X		}
X	}
X#ifdef DGK
X	fd = open(bones, O_WRONLY | O_BINARY | O_CREAT, FMASK);
X#else
X	fd = creat(bones, FMASK);
X#endif
X	if(fd < 0) {
X#ifdef WIZARD
X		if(wizard)
X			pline("Cannot create bones file - creat failed");
X#endif
X		return;
X	}
X#ifdef DGK
X	savelev(fd,dlevel, COUNT | WRITE);
X#else
X	savelev(fd,dlevel);
X#endif
X	(void) close(fd);
X}
X
X/*
X * "spill" object out of box onto floor
X */
Xspill_obj(obj)
Xstruct obj *obj;
X{
X	struct obj *otmp;
X
X	for(otmp = fobj; otmp; otmp = otmp->nobj)
X		if(obj->o_cnt_id == otmp->o_id)  {
X			obj->ox = otmp->ox;
X			obj->oy = otmp->oy;
X			obj->age = 0;
X			if(rn2(5))
X				obj->cursed = 1;
X			obj->nobj = otmp->nobj;
X			otmp->nobj = obj;
X			return;
X		}
X}
X		
Xgetbones(){
Xregister fd,x,y,ok;
X	/* wizard check added by GAN 02/05/87 */
X	if(rn2(3)	/* only once in three times do we find bones */
X#ifdef WIZARD
X		&& !wizard
X#endif
X		) return(0);
X#ifdef DGK
X	name_file(bones, dlevel);
X#else
X	bones[6] = '0' + dlevel/10;
X	bones[7] = '0' + dlevel%10;
X#endif
X	if((fd = open(bones, 0)) < 0) return(0);
X	if((ok = uptodate(fd)) != 0){
X#ifdef WIZARD
X		if(wizard)  {
X			char buf[BUFSZ];
X			pline("Get bones? ");
X			getlin(buf);
X			if(buf[0] == 'n')  {
X				(void) close(fd);
X				return(0);
X			}
X		}
X#endif
X		getlev(fd, 0, dlevel);
X		for(x = 0; x < COLNO; x++) for(y = 0; y < ROWNO; y++)
X			levl[x][y].seen = levl[x][y].new = 0;
X	}
X	(void) close(fd);
X#ifdef WIZARD
X	if(wizard)  {
X		char buf[BUFSZ];
X		pline("Unlink bones? ");
X		getlin(buf);
X		if(buf[0] == 'n')
X			return(ok);
X	}
X#endif
X	if(unlink(bones) < 0){
X		pline("Cannot unlink %s .", bones);
X		return(0);
X	}
X	return(ok);
X}
END_OF_bones.c
if test 3830 -ne `wc -c <bones.c`; then
    echo shar: \"bones.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f dog.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"dog.c\"
else
echo shar: Extracting \"dog.c\" \(4228 characters\)
sed "s/^X//" >dog.c <<'END_OF_dog.c'
X/*	SCCS Id: @(#)dog.c	1.3	87/07/14
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* dog.c - version 1.0.3 */
X
X#include	"hack.h"
Xextern struct monst *makemon();
X#include "edog.h"
X#include "mkroom.h"
X
Xstruct permonst li_dog =
X	{ "little dog", 'd',2,18,6,0,1,6,sizeof(struct edog) };
Xstruct permonst dog =
X	{ "dog", 'd',4,16,5,0,1,6,sizeof(struct edog) };
Xstruct permonst la_dog =
X	{ "large dog", 'd',6,15,4,0,2,4,sizeof(struct edog) };
X
Xstruct monst *
Xmakedog(){
Xregister struct monst *mtmp = makemon(&li_dog,u.ux,u.uy);
X	if(!mtmp) return((struct monst *) 0); /* dogs were genocided */
X	initedog(mtmp);
X	return(mtmp);
X}
X
Xinitedog(mtmp) register struct monst *mtmp; {
X	mtmp->mtame = mtmp->mpeaceful = 1;
X#ifdef WALKIES
X	mtmp->mleashed = 0;
X#endif
X	EDOG(mtmp)->hungrytime = 1000 + moves;
X	EDOG(mtmp)->eattime = 0;
X	EDOG(mtmp)->droptime = 0;
X	EDOG(mtmp)->dropdist = 10000;
X	EDOG(mtmp)->apport = 10;
X	EDOG(mtmp)->whistletime = 0;
X}
X
X/* attach the monsters that went down (or up) together with @ */
Xstruct monst *mydogs = 0;
Xstruct monst *fallen_down = 0;	/* monsters that fell through a trapdoor */
X	/* they will appear on the next level @ goes to, even if he goes up! */
X
Xlosedogs(){
Xregister struct monst *mtmp;
X	while(mtmp = mydogs){
X		mydogs = mtmp->nmon;
X		mtmp->nmon = fmon;
X		fmon = mtmp;
X		mnexto(mtmp);
X	}
X	while(mtmp = fallen_down){
X		fallen_down = mtmp->nmon;
X		mtmp->nmon = fmon;
X#ifdef WALKIES
X		mtmp->mleashed = 0;
X#endif
X		fmon = mtmp;
X		rloc(mtmp);
X	}
X}
X
Xkeepdogs(){
Xregister struct monst *mtmp;
X	for(mtmp = fmon; mtmp; mtmp = mtmp->nmon)
X	    if(dist(mtmp->mx,mtmp->my) < 3 && follower(mtmp)
X		&& !mtmp->msleep && !mtmp->mfroz) {
X#ifdef DGKMOD
X		/* Bug "fix" for worm changing levels collapsing dungeon
X		 */
X		if (mtmp->data->mlet == 'w') {
X			if (canseemon(mtmp) || (Blind && Telepat))
X				pline("The worm can't fit down the stairwell!");
X#ifdef WALKIES
X			pline("The leash slides off the slimy worm!");
X			mtmp->mleashed = 0;
X#endif
X			continue;
X		}
X#endif
X		relmon(mtmp);
X		mtmp->nmon = mydogs;
X		mydogs = mtmp;
X		unpmon(mtmp);
X		keepdogs();	/* we destroyed the link, so use recursion */
X		return;		/* (admittedly somewhat primitive) */
X	}
X}
X
Xfall_down(mtmp) register struct monst *mtmp; {
X	relmon(mtmp);
X	mtmp->nmon = fallen_down;
X	fallen_down = mtmp;
X#ifdef WALKIES
X	if (mtmp->mleashed)  {
X
X		pline("The leash comes off!");
X		mtmp->mleashed = 0;
X	}
X#endif
X	unpmon(mtmp);
X	mtmp->mtame = 0;
X}
X
X/* return quality of food; the lower the better */
Xdogfood(obj) register struct obj *obj; {
X	switch(obj->olet) {
X	case FOOD_SYM:
X	    return(
X		(obj->otyp == TRIPE_RATION) ? DOGFOOD :
X		(obj->otyp < CARROT) ? ACCFOOD :
X		(obj->otyp < CORPSE) ? MANFOOD :
X		(poisonous(obj) || obj->age + 50 <= moves ||
X		    obj->otyp == DEAD_COCKATRICE)
X			? POISON : CADAVER
X	    );
X	default:
X	    if(!obj->cursed) return(APPORT);
X	    /* fall into next case */
X	case BALL_SYM:
X	case CHAIN_SYM:
X	case ROCK_SYM:
X	    return(UNDEF);
X	}
X}
X
X/* return roomnumber or -1 */
Xinroom(x,y) xchar x,y; {
X#ifndef QUEST
X	register struct mkroom *croom = &rooms[0];
X	while(croom->hx >= 0){
X		if(croom->hx >= x-1 && croom->lx <= x+1 &&
X		   croom->hy >= y-1 && croom->ly <= y+1)
X			return(croom - rooms);
X		croom++;
X	}
X#endif
X	return(-1);	/* not in room or on door */
X}
X
Xtamedog(mtmp, obj)
Xregister struct monst *mtmp;
Xregister struct obj *obj;
X{
X	register struct monst *mtmp2;
X
X	/* worst case, at least he'll be peaceful. */
X	mtmp->mpeaceful = 1;
X	if(flags.moonphase == FULL_MOON && night() && rn2(6))
X		return(0);
X
X	/* If we cannot tame him, at least he's no longer afraid. */
X	mtmp->mflee = 0;
X	mtmp->mfleetim = 0;
X	if(mtmp->mtame || mtmp->mfroz ||
X#ifndef NOWORM
X	   mtmp->wormno ||
X#endif
X	   mtmp->isshk || mtmp->isgd || index(" @12", mtmp->data->mlet))
X		return(0);			/* no tame long worms? */
X	if(obj) {
X		if(dogfood(obj) >= MANFOOD) return(0);
X		if(cansee(mtmp->mx,mtmp->my)){
X			pline("%s devours the %s.", Monnam(mtmp),
X				objects[obj->otyp].oc_name);
X		}
X		obfree(obj, (struct obj *) 0);
X	}
X	mtmp2 = newmonst(sizeof(struct edog) + mtmp->mnamelth);
X	*mtmp2 = *mtmp;
X	mtmp2->mxlth = sizeof(struct edog);
X	if(mtmp->mnamelth) (void) strcpy(NAME(mtmp2), NAME(mtmp));
X	initedog(mtmp2);
X	replmon(mtmp,mtmp2);
X	return(1);
X}
END_OF_dog.c
if test 4228 -ne `wc -c <dog.c`; then
    echo shar: \"dog.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f mkobj.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"mkobj.c\"
else
echo shar: Extracting \"mkobj.c\" \(3448 characters\)
sed "s/^X//" >mkobj.c <<'END_OF_mkobj.c'
X/*	SCCS Id: @(#)mkobj.c	1.3	87/07/14
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* mkobj.c - version 1.0.3 */
X
X#include "hack.h"
X#ifdef SPELLS
Xchar mkobjstr[] = "))[[!!!!????+%%%%/=**))[[!!!!????+%%%%/=**(%";
X#else
Xchar mkobjstr[] = "))[[!!!!????%%%%/=**))[[!!!!????%%%%/=**(%";
X#endif
X
Xstruct obj *mkobj(), *mksobj();
X
Xstruct obj *
Xmkobj_at(let,x,y)
Xregister let,x,y;
X{
X	register struct obj *otmp = mkobj(let);
X	otmp->ox = x;
X	otmp->oy = y;
X	otmp->nobj = fobj;
X	fobj = otmp;
X	return(otmp);
X}
X
Xmksobj_at(otyp,x,y)
Xregister otyp,x,y;
X{
X	register struct obj *otmp = mksobj(otyp);
X	otmp->ox = x;
X	otmp->oy = y;
X	otmp->nobj = fobj;
X	fobj = otmp;
X}
X
Xstruct obj *
Xmkobj(let) {
Xint realtype;
X	switch (let) {
X		case 0: {
X			realtype=probtype(mkobjstr[rn2(sizeof(mkobjstr)-1)]);
X			break;
X		}
X		case '9': { realtype = DEAD_GIANT; break; }
X		case '&': { realtype = DEAD_DEMON; break; }
X		default: realtype = letter(let) ?
X				CORPSE + ((let>'Z') ? (let-'a'+'Z'-'@'+1) : (let-'@'))
X			:	probtype(let);
X	}
X	return(mksobj(realtype));
X}
X	
X
Xstruct obj zeroobj;
X
Xstruct obj *
Xmksobj(otyp)
Xregister otyp;
X{
X	register struct obj *otmp;
X	char let = objects[otyp].oc_olet;
X
X	otmp = newobj(0);
X	*otmp = zeroobj;
X	otmp->age = moves;
X	otmp->o_id = flags.ident++;
X	otmp->quan = 1;
X	otmp->olet = let;
X	otmp->otyp = otyp;
X	otmp->dknown = index(
X#ifdef KAA
X#ifdef SPELLS
X	"/=!?*+)",
X#else
X	"/=!?*)",
X#endif
X#else
X#ifdef SPELLS
X	"/=!?*+",
X#else
X	"/=!?*",
X#endif
X#endif
X		    let) ? 0 : 1;
X	switch(let) {
X	case WEAPON_SYM:
X		otmp->quan = (otmp->otyp <= ROCK) ? rn1(6,6) : 1;
X		if(!rn2(11)) otmp->spe = rnd(3);
X		else if(!rn2(10)) {
X			otmp->cursed = 1;
X			otmp->spe = -rnd(3);
X		}
X		break;
X	case FOOD_SYM:
X		if(otmp->otyp >= CORPSE) break;
X#ifdef NOT_YET_IMPLEMENTED
X		/* if tins are to be identified, need to adapt doname() etc */
X		if(otmp->otyp == TIN)
X			otmp->spe = rnd(...);
X#endif
X		/* fall into next case */
X	case GEM_SYM:
X		otmp->quan = rn2(6) ? 1 : 2;
X	case TOOL_SYM:
X	case CHAIN_SYM:
X	case BALL_SYM:
X	case ROCK_SYM:
X	case POTION_SYM:
X	case SCROLL_SYM:
X	case AMULET_SYM:
X		break;
X#ifdef SPELLS
X	case SPBOOK_SYM:
X		if(!rn2(17)) otmp->cursed = 1;
X		break;
X#endif
X	case ARMOR_SYM:
X		if(!rn2(8)) otmp->cursed = 1;
X		if(!rn2(10)) otmp->spe = rnd(3);
X		else if(!rn2(9)) {
X			otmp->spe = -rnd(3);
X			otmp->cursed = 1;
X		}
X		break;
X	case WAND_SYM:
X		if(otmp->otyp == WAN_WISHING) otmp->spe = 3; else
X		otmp->spe = rn1(5,
X			(objects[otmp->otyp].bits & NODIR) ? 11 : 4);
X		break;
X	case RING_SYM:
X		if(objects[otmp->otyp].bits & SPEC) {
X			if(!rn2(3)) {
X				otmp->cursed = 1;
X				otmp->spe = -rnd(2);
X			} else otmp->spe = rnd(2);
X		} else if(otmp->otyp == RIN_TELEPORTATION ||
X			  otmp->otyp == RIN_AGGRAVATE_MONSTER ||
X			  otmp->otyp == RIN_HUNGER || !rn2(9))
X			otmp->cursed = 1;
X		break;
X	default:
X		panic("impossible mkobj %d", otmp->otyp);
X	}
X	otmp->owt = weight(otmp);
X	return(otmp);
X}
X
Xletter(c) {
X	return(('@' <= c && c <= 'Z') || ('a' <= c && c <= 'z'));
X}
X
Xweight(obj)
Xregister struct obj *obj;
X{
Xregister int wt = objects[obj->otyp].oc_weight;
X	return(wt ? wt*obj->quan : (obj->quan + 1)/2);
X}
X
Xmkgold(num,x,y)
Xregister long num;
X{
X	register struct gold *gold;
X	register long amount = (num ? num : 1 + (rnd(dlevel+2) * rnd(30)));
X
X	if(gold = g_at(x,y))
X		gold->amount += amount;
X	else {
X		gold = newgold();
X		gold->ngold = fgold;
X		gold->gx = x;
X		gold->gy = y;
X		gold->amount = amount;
X		fgold = gold;
X		/* do sth with display? */
X	}
X}
END_OF_mkobj.c
if test 3448 -ne `wc -c <mkobj.c`; then
    echo shar: \"mkobj.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f monst.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"monst.c\"
else
echo shar: Extracting \"monst.c\" \(3849 characters\)
sed "s/^X//" >monst.c <<'END_OF_monst.c'
X/*	SCCS Id: @(#)monst.c	1.3	87/07/14
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* monst.c - version 1.0.2 */
X
X#include "hack.h"
X#include "eshk.h"
Xextern char plname[PL_NSIZ];
X
Xstruct permonst mons[CMNUM+2] = {
X	{ "bat",		'B',  1, 22, 8,  0, 1,  4, 0 },
X	{ "gnome",		'G',  1,  6, 5,  0, 1,  6, 0 },
X	{ "hobgoblin",		'H',  1,  9, 5,  0, 1,  8, 0 },
X	{ "jackal",		'J',  0, 12, 7,  0, 1,  2, 0 },
X#ifdef KOPS
X	{ "Keystone Kop",       'K',  1,  6, 7, 10, 1,  4, 0 },
X#else
X	{ "kobold",		'K',  1,  6, 7,  0, 1,  4, 0 },
X#endif
X	{ "leprechaun",		'L',  5, 15, 8, 20, 1,  2, 0 },
X#ifndef ROCKMOLE
X	{ "giant rat",		'r',  0, 12, 7,  0, 1,  3, 0 },
X#endif
X	{ "acid blob",		'a',  2,  3, 8,  0, 0,  0, 0 },
X	{ "floating eye",	'E',  2,  1, 9, 10, 0,  0, 0 },
X	{ "homunculus",		'h',  2,  6, 6, 10, 1,  3, 0 },
X	{ "imp",		'i',  2,  6, 2, 20, 1,  4, 0 },
X	{ "orc",		'O',  2,  9, 6,  0, 1,  8, 0 },
X	{ "yellow light",	'y',  3, 15, 0,  0, 0,  0, 0 },
X	{ "zombie",		'Z',  2,  6, 8,  0, 1,  8, 0 },
X	{ "giant ant",		'A',  3, 18, 3,  0, 1,  6, 0 },
X#ifdef ROCKMOLE
X	{ "rock mole",          'r',  3,  3, 0, 20, 1,  6, 0 },
X#endif
X	{ "fog cloud",		'f',  3,  1, 0,  0, 1,  6, 0 },
X	{ "nymph",		'N',  6, 12, 9, 20, 1,  2, 0 },
X	{ "piercer",		'p',  3,  1, 3,  0, 2,  6, 0 },
X#ifdef KAA
X	{ "quantum mechanic",	'Q',  6, 12, 3, 10, 1,  4, 0 },
X#else
X	{ "quasit",		'Q',  3, 15, 3, 20, 1,  4, 0 },
X#endif
X	{ "quivering blob",	'q',  3,  1, 8,  0, 1,  8, 0 },
X#ifdef KAA
X	{ "violet fungus",	'v',  3,  1, 7,  0, 1,  4, 0 },
X#else
X	{ "violet fungi",	'v',  3,  1, 7,  0, 1,  4, 0 },
X#endif
X	{ "giant beetle",	'b',  4,  6, 4,  0, 3,  4, 0 },
X	{ "centaur",		'C',  4, 18, 4, 10, 1,  6, 0 },
X	{ "cockatrice",		'c',  4,  6, 6, 30, 1,  3, 0 },
X	{ "gelatinous cube",	'g',  4,  6, 8,  0, 2,  4, 0 },
X	{ "jaguar",		'j',  4, 15, 6,  0, 1,  8, 0 },
X	{ "killer bee",		'k',  4, 14, 4,  0, 2,  4, 0 },
X	{ "snake",		'S',  4, 15, 3,  0, 1,  6, 0 },
X	{ "freezing sphere",	'F',  2, 13, 4,  0, 0,  0, 0 },
X	{ "owlbear",		'o',  5, 12, 5,  0, 2,  6, 0 },
X	{ "rust monster",	'R', 10, 18, 3,  0, 0,  0, 0 },
X#ifdef SPIDERS
X	{ "giant spider",	's',  5, 15, 3,  0, 1,  4, 0 },
X#else
X	{ "scorpion",		's',  5, 15, 3,  0, 1,  4, 0 },
X#endif
X	{ "tengu",		't',  5, 13, 5, 30, 1,  7, 0 },
X	{ "wraith",		'W',  5, 12, 5, 15, 1,  6, 0 },
X#ifdef NOWORM
X	{ "wumpus",		'w',  8,  3, 2, 10, 3,  6, 0 },
X#else
X	{ "long worm",		'w',  8,  3, 5, 10, 1,  4, 0 },
X#endif
X	{ "large dog",		'd',  6, 15, 4,  0, 2,  4, 0 },
X	{ "leocrotta",		'l',  6, 18, 4, 10, 3,  6, 0 },
X	{ "mimic",		'M',  7,  3, 7,  0, 3,  4, 0 },
X	{ "troll",		'T',  7, 12, 4,  0, 2,  7, 0 },
X	{ "unicorn",		'u',  8, 24, 5, 70, 1, 10, 0 },
X	{ "yeti",		'Y',  5, 15, 6,  0, 1,  6, 0 },
X	{ "stalker",		'I',  8, 12, 3,  0, 4,  4, 0 },
X	{ "umber hulk",		'U',  9,  6, 2, 25, 2, 10, 0 },
X	{ "vampire",		'V',  8, 12, 1, 25, 1,  6, 0 },
X	{ "xorn",		'X',  8,  9,-2, 20, 4,  6, 0 },
X	{ "xan",		'x',  7, 18,-2,  0, 2,  4, 0 },
X	{ "zruty",		'z',  9,  8, 3,  0, 3,  6, 0 },
X	{ "chameleon",		':',  6,  5, 6, 10, 4,  2, 0 },
X	{ "giant",		'9',  9, 18, 5,  0, 2, 12, 0 },
X	{ "dragon",		'D', 10,  9,-1, 20, 3,  8, 0 },
X	{ "ettin",		'e', 10, 12, 3,  0, 2,  8, 0 },
X	{ "lurker above",	'\'',10,  3, 3,  0, 0,  0, 0 },
X	{ "nurse",		'n', 11,  6, 0,  0, 2,  6, 0 },
X	{ "trapper",		',', 12,  3, 3,  0, 0,  0, 0 },
X	{ "purple worm",	'P', 15,  9, 6, 20, 2,  8, 0 },
X	{ "demon",		'&', 10, 12,-4, 30, 1,  4, 0 },
X	{ "minotaur",		'm', 15, 15, 6,  0, 4, 10, 0 },
X	{ "shopkeeper", 	'@', 12, 18, 0, 50, 4,  8, sizeof(struct eshk) }
X};
X
Xstruct permonst pm_ghost = { "ghost", ' ', 10, 3, -5, 50, 1, 1, sizeof(plname) };
Xstruct permonst pm_wizard = { "wizard of Yendor", '1', 15, 12, -2, 70, 1, 12, 0 };
X#ifdef MAIL
Xstruct permonst pm_mail_daemon = { "mail daemon", '2', 100, 1, 10, 127, 0, 0, 0 };
X#endif
Xstruct permonst pm_eel = { "giant eel", ';', 15, 6, -3, 0, 3, 6, 0 };
X
END_OF_monst.c
if test 3849 -ne `wc -c <monst.c`; then
    echo shar: \"monst.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f pctty.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"pctty.c\"
else
echo shar: Extracting \"pctty.c\" \(3882 characters\)
sed "s/^X//" >pctty.c <<'END_OF_pctty.c'
X/*	SCCS Id: @(#)pctty.c	1.3	87/07/14
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* tty.c - (PC) version 1.0.3 */
X/* With thanks to the people who sent code for SYSV - hpscdi!jon,
X   arnold@ucsf-cgl, wcs@bo95b, cbcephus!pds and others. */
X
X#include <stdio.h>
X#include "hack.h"
X
Xstatic char erase_char, kill_char;
X
X/*
X * Get initial state of terminal, set ospeed (for termcap routines)
X * and switch off tab expansion if necessary.
X * Called by startup() in termcap.c and after returning from ! or ^Z
X */
Xgettty(){
X	erase_char = '\b';
X	kill_char = 21;		/* cntl-U */
X	flags.cbreak = TRUE;
X#ifdef DGK
X	disable_ctrlP();	/* turn off ^P processing */
X#endif
X}
X
X/* reset terminal to original state */
Xsettty(s) char *s; {
X	end_screen();
X	if(s) printf(s);
X	(void) fflush(stdout);
X#ifdef DGK
X	enable_ctrlP();		/* turn on ^P processing */
X#endif
X}
X
X
X/* fatal error */
X/*VARARGS1*/
Xerror(s,x,y) char *s; {
X	end_screen();
X	putchar('\n');
X	printf(s,x,y);
X	putchar('\n');
X	exit(1);
X}
X
X/*
X * Read a line closed with '\n' into the array char bufp[BUFSZ].
X * (The '\n' is not stored. The string is closed with a '\0'.)
X * Reading can be interrupted by an escape ('\033') - now the
X * resulting string is "\033".
X */
Xgetlin(bufp)
Xregister char *bufp;
X{
X	register char *obufp = bufp;
X	register int c;
X
X	flags.toplin = 2;		/* nonempty, no --More-- required */
X	for(;;) {
X		(void) fflush(stdout);
X		if((c = getchar()) == EOF) {
X			*bufp = 0;
X			return;
X		}
X		if(c == '\033') {
X			*obufp = c;
X			obufp[1] = 0;
X			return;
X		}
X		if(c == erase_char || c == '\b') {
X			if(bufp != obufp) {
X				bufp--;
X				putstr("\b \b"); /* putsym converts \b */
X			} else	bell();
X		} else if(c == '\n') {
X			*bufp = 0;
X			return;
X		} else if(' ' <= c && c < '\177') {
X				/* avoid isprint() - some people don't have it
X				   ' ' is not always a printing char */
X			*bufp = c;
X			bufp[1] = 0;
X			putstr(bufp);
X			if(bufp-obufp < BUFSZ-1 && bufp-obufp < COLNO)
X				bufp++;
X		} else if(c == kill_char || c == '\177') { /* Robert Viduya */
X				/* this test last - @ might be the kill_char */
X			while(bufp != obufp) {
X				bufp--;
X				putstr("\b \b");
X			}
X		} else
X			bell();
X	}
X}
X
Xgetret() {
X	cgetret("");
X}
X
Xcgetret(s)
Xregister char *s;
X{
X	putsym('\n');
X	if(flags.standout)
X		standoutbeg();
X	putstr("Hit ");
X	putstr(flags.cbreak ? "space" : "return");
X	putstr(" to continue: ");
X	if(flags.standout)
X		standoutend();
X	xwaitforspace(s);
X}
X
Xchar morc;	/* tell the outside world what char he used */
X
Xxwaitforspace(s)
Xregister char *s;	/* chars allowed besides space or return */
X{
Xregister int c;
X
X	morc = 0;
X	while((c = readchar()) != '\n') {
X	    if(flags.cbreak) {
X		if(c == ' ') break;
X		if(s && index(s,c)) {
X			morc = c;
X			break;
X		}
X		bell();
X	    }
X	}
X}
X
Xstatic int last_multi;
X
Xchar *
Xparse()
X{
X	static char inline[COLNO];
X	register foo;
X
X	flags.move = 1;
X	if(!Invisible) curs_on_u(); else home();
X	multi = 0;
X#ifdef DGK
X	while((foo = readchar()) >= '0' && foo <= '9') {
X		multi = 10*multi+foo-'0';
X		if (multi < 0 || multi > LARGEST_INT)
X			multi = LARGEST_INT;
X		if (multi > 9) {
X			remember_topl();
X			home();
X			cl_end();
X			printf("Count: %d", multi);
X		}
X		last_multi = multi;
X	}
X# ifdef REDO
X	if (foo == DOAGAIN || in_doagain)
X		multi = last_multi;
X	else {
X		savech(0);	/* reset input queue */
X		savech(foo);
X	}
X# endif
X
X#else /* DGK */
X
X	while((foo = readchar()) >= '0' && foo <= '9')
X		multi = 10*multi+foo-'0';
X
X#endif /* DGK */
X
X	if(multi) {
X		multi--;
X		save_cm = inline;
X	}
X	inline[0] = foo;
X	inline[1] = 0;
X	if(foo == 'g' || foo == 'G'){
X		inline[1] = getchar();
X		savech(inline[1]);
X		inline[2] = 0;
X	}
X	if(foo == 'm' || foo == 'M'){
X		inline[1] = getchar();
X		savech(inline[1]);
X		inline[2] = 0;
X	}
X	clrlin();
X	return(inline);
X}
X
Xchar
Xreadchar() {
X	register int sym;
X
X	(void) fflush(stdout);
X	sym = getchar();
X	if(flags.toplin == 1)
X		flags.toplin = 2;
X	return((char) sym);
X}
END_OF_pctty.c
if test 3882 -ne `wc -c <pctty.c`; then
    echo shar: \"pctty.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f pray.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"pray.c\"
else
echo shar: Extracting \"pray.c\" \(4040 characters\)
sed "s/^X//" >pray.c <<'END_OF_pray.c'
X/*	SCCS Id: @(#)pray.c	1.3	87/07/14
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* pray.c - version 1.0 */
X
X#include "hack.h"
X
Xextern char *nomovemsg;
X/*
X#ifdef KAA
Xextern char *xname();
X#endif
X*/
Xdopray() {		/* M. Stephenson (1.0.3b) */
X#ifdef PRAYERS
X	if (u.ublesscnt > 0)  {		/* disturbing the gods too much */
X
X		u.ublesscnt += 200;
X		u.uluck -= 3;
X		if (u.uluck < LUCKMIN)  u.uluck = LUCKMIN;
X		if (u.ugangr++)	angrygods();
X		else {			/* exactly one warning */
X			pline("A voice booms out: You have angered us,");
X			pline("Disturb us again at your own risk!");
X		}
X	} else  if (u.uluck < 0) angrygods();	/* a bad boy/girl */
X	else	pleased();	    		/* or a good boy/girl */
X#endif
X	nomovemsg = "You finished your prayer.";
X	nomul(-3);
X	return(1);
X}
X
X#ifdef PRAYERS
Xangrygods() {
X	register int	tmp;
X
X	pline ("You get the felling the gods are angry...");
X	tmp = u.ugangr + (u.uluck > 0) ? u.uluck : -u.uluck;
X	switch (tmp ? rn2(tmp): 0) {
X
X	    case 0:
X	    case 1:	pline("but nothing appears to happen.");
X			break;
X	    case 2:
X	    case 3:	pline("A voice booms out: You are arrogant, mortal.");
X			pline("You must relearn your lessons!");
X			if (u.ulevel > 1)	losexp();
X			else  {
X			    u.uexp = 0;
X			    flags.botl = 1;
X			}
X			break;
X	    case 4:
X	    case 5:
X	    case 6:	pline("A black glow surrounds you.");
X			rndcurse();
X			break;
X	    case 7:
X	    case 8:	pline("A voice booms out: You dare to call upon us?");
X			pline("Then, die mortal!");
X			mkmon_at('&', u.ux, u.uy);
X			break;
X				
X	    default:	pline("Suddenly, a bolt of lightning strikes you!");
X			pline("You are fried to a crisp.");
X			killer = "pissed off deity";
X			done("died");
X			break;
X	}
X	u.ublesscnt = 250;
X	return(0);
X}
X
Xpleased() {
X
X	char	*tmp, *hcolor();
X
X	u.ugangr--;
X	if (u.ugangr < 0) u.ugangr = 0;
X	pline("You feel the gods are pleased.");
X
X	switch(rn2((u.uluck + 6)/2))  {
X
X	    case 0:	pline("but nothing seems to happen.");
X			break;
X	    case 1:
X#ifdef KAA
X			if(!uwep) {
X			    pline("but nothing seems to happen.");
X			    break;
X			}
X			if(uwep->olet == WEAPON_SYM) {
X			    if (uwep->cursed) {
X				uwep->cursed=0;
X				pline("Your %s %s.", aobjnam(uwep,"softly glow"), 
X				Hallucination ? hcolor() : "amber");
X			    } else if(uwep->otyp >= ARROW && uwep->otyp <= SPEAR) {
X				uwep->dknown=1;
X				tmp = Hallucination ? hcolor() : "light blue";
X				pline("Your %s with a%s %s aura.", aobjnam(uwep,"softly glow"),
X				index("aeiou",*tmp) ? "n" : "", tmp);
X			    }
X			} else
X#endif
X				pline("but nothing seems to happen.");
X			break;
X	    case 2:
X	    case 3:
X			pline("A %s glow surrounds you",
X			      Hallucination ? hcolor() : "golden");
X			u.uhp = u.uhpmax += 5;
X			u.ustr = u.ustrmax;
X			if (u.uhunger < 900)	init_uhunger();
X			if (u.uluck < 0)	u.uluck = 0;
X			if (Blind)		Blind = 1;
X			break;
X	    case 4:
X	    case 5:	pline("A voice booms out: We are pleased with your progress,");
X			pline("and grant you the gift of");
X			if (!(HTelepat & INTRINSIC))  {
X				HTelepat = HTelepat || INTRINSIC;
X				pline ("Telepathy,");
X			} else if (!(Fast & INTRINSIC))  {
X				Fast = Fast || INTRINSIC;
X				pline ("Speed,");
X			} else if (!(Stealth & INTRINSIC))  {
X				Stealth = Stealth || INTRINSIC;
X				pline ("Stealth,");
X			} else {
X			    if (!(Protection & INTRINSIC))  {
X				Protection = Protection || INTRINSIC;
X				if (!u.ublessed)  u.ublessed = rnd(3) + 1;
X			    } else u.ublessed++;
X			    pline ("our protection,");
X			}
X			pline ("Use it wisely in our names!");
X			break;
X
X	    case 6:	pline ("An object appears at your feet!");
X			mkobj_at("+", u.ux, u.uy);
X			break;
X
X	    case 7:	pline("A voice booms out:  We crown thee...");
X			pline("The Hand of Elbereth!");
X			HInvis |= INTRINSIC;
X			HSee_invisible |= INTRINSIC;
X			HFire_resistance |= INTRINSIC;
X			HCold_resistance |= INTRINSIC;
X			HPoison_resistance |= INTRINSIC;
X			break;
X
X	    default:	impossible("Confused deity!");
X			break;
X	}
X	u.ublesscnt = 300;
X#ifdef HARD
X	u.ublesscnt += (u.udemigod * 1000);
X#endif
X	return(0);
X}
X#endif /* PRAYERS /**/
X
END_OF_pray.c
if test 4040 -ne `wc -c <pray.c`; then
    echo shar: \"pray.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f rumors.kaa -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"rumors.kaa\"
else
echo shar: Extracting \"rumors.kaa\" \(3523 characters\)
sed "s/^X//" >rumors.kaa <<'END_OF_rumors.kaa'
XYou should always be sure to learn about quantum mechanics.
XAn apple a day keeps the doctor away.
XA crystal plate mail will not rust.
XTry using your magic marker on wet scrolls!
XCrystal plate is the rarest of all.
XHealers are immune to the effects of nurses.
XBashing monsters with a bow is not such a good idea.
XWait!  That's a fortune!
XEver broken an egg against the ground?
XFinding traps is a lot like finding gold.
XFinding potions is a lot like finding food.
XRust traps are harmless if you are wearing an elven cloak.
XDon't bother trying to control teleports if you are not awake.
XEver gone into the morgue at midnight?
XWielding a dead cockatrice may actually work.
XLeaving the dungeon while hallucinating may get you arrested.
XDrinking potions of booze may land you in jail if you are under 21.
XA dilithium crystal is the most valuable mineral around.
XValkyrie comes from the north, and has commensurate abilities.
XElf has extra speed.
XGushes of water won't necessarily hit your head.
XPlaying Gauntlet might be enlightening in some situations.
XA short sword is not as good as a long sword.
XA bardiche is better than a sword.
XA trident is a nice thing to have.
XUsing a morning star in the evening has no effect.
XPolymorphing a shopkeeper might make you safer.
XYou cannot quench your thirst in a water trap.
XAfraid of nymphs?  Wear a ring of adornment.
XGiant bats turn into giant vampires.
XI wouldn't advise playing catch with a giant.
XAfraid of your valuables being stolen?  Carry more junk!
XHoly water has many uses.
XYou swallowed the fortune!!!
XYou hear the fortune cookie's hissing!
XA pie fight.  Now that's fun!
XMesses attract ants.
XWhy are you wasting time reading fortunes?
XHelp!  I'm being held prisoner in a fortune cookie factory!
XOnly elves can wear elfin chain mail.
XAre you SURE that's a wand of wishing?
XCroesus?  Who's he?
XIf you want a sex change, you must get it before the game.
XShopkeepers value money more than revenge.
XShopkeepers can't tell identical twins apart.
XYou're going into the morgue at midnight????
XDidn't your mother tell you not to eat food off the floor?
XTrolls are described as rubbery:  they keep bouncing back.
XMark your way with a magic marker.
XA magic marker is like a wand of digging, but less so.
XA dead cockatrice is just a dead lizard.
XYou need 512k to implement the magic memory vaults.
XEveryone's goal is to get to heaven.
XHeaven can wait.
XUnused potions are like unburned scrolls.
XEver read a tin of fire?
XYou may want to dip into a potion of bottled blessings.
XTridents are for use underwater.
XWe have new ways of detecting treachery...
XCave(wo)men all belong to the same club.
XIf you thought the wizard was bad, just wait till you meet the Warlord!
XYou are filled with a feeling of awwwww.
XValkyries, elves, and wizards need food badly.
XNetHack was modified by Miracleman (Ken Arromdee).
XYou may discover a fine spirit inside a potion bottle.
XLong live Phoenix!
XMost of the bugs in Hack are on the floor.
XWhat does a dead demon taste like?
XIf you kill a ghost, how will you find the body?
XA ring of dungeon master control is a great find.
XEver lifted a dead dragon?
XEver see your weapon glow plaid?
XPlaying AD&D may be helpful.
XWhat is a three sided die shaped like?
XWhat is a zero sided die shaped like?
XWhat is a cockatrice going to eat when it gets hungry?
XHitting a giant that is picking up a boulder may be difficult.
XA softly glowing weapon can kill a demon.
XThe orc swings his two handed sword named Elfrist at you.  You die...
XZap yourself and see what happens...
END_OF_rumors.kaa
if test 3523 -ne `wc -c <rumors.kaa`; then
    echo shar: \"rumors.kaa\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f search.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"search.c\"
else
echo shar: Extracting \"search.c\" \(3458 characters\)
sed "s/^X//" >search.c <<'END_OF_search.c'
X/*	SCCS Id: @(#)search.c	1.3	87/07/14
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* search.c - version 1.0.3 */
X
X#include "hack.h"
Xchar *rndmonnam(), *defmonnam();
X
Xextern struct monst *makemon();
X
Xfindit()	/* returns number of things found */
X{
X	int num;
X	register xchar zx,zy;
X	register struct trap *ttmp;
X	register struct monst *mtmp;
X	xchar lx,hx,ly,hy;
X
X	if(u.uswallow) return(0);
X	for(lx = u.ux; (num = levl[lx-1][u.uy].typ) && num != CORR; lx--) ;
X	for(hx = u.ux; (num = levl[hx+1][u.uy].typ) && num != CORR; hx++) ;
X	for(ly = u.uy; (num = levl[u.ux][ly-1].typ) && num != CORR; ly--) ;
X	for(hy = u.uy; (num = levl[u.ux][hy+1].typ) && num != CORR; hy++) ;
X	num = 0;
X	for(zy = ly; zy <= hy; zy++)
X		for(zx = lx; zx <= hx; zx++) {
X			if(levl[zx][zy].typ == SDOOR) {
X				levl[zx][zy].typ = DOOR;
X#ifdef DGK
X				atl(zx, zy, symbol.door);
X#else
X				atl(zx, zy, '+');
X#endif
X				num++;
X			} else if(levl[zx][zy].typ == SCORR) {
X				levl[zx][zy].typ = CORR;
X#ifdef DGK
X				atl(zx, zy, symbol.corr);
X#else
X				atl(zx, zy, CORR_SYM);
X#endif
X				num++;
X			} else if(ttmp = t_at(zx, zy)) {
X				if(ttmp->ttyp == PIERC){
X					(void) makemon(PM_PIERCER, zx, zy);
X					num++;
X					deltrap(ttmp);
X				} else if(!ttmp->tseen) {
X					ttmp->tseen = 1;
X					if(!vism_at(zx, zy))
X						atl(zx,zy,'^');
X					num++;
X				}
X			} else if(mtmp = m_at(zx,zy)) if(mtmp->mimic){
X				seemimic(mtmp);
X				num++;
X			}
X		}
X	return(num);
X}
X
Xdosearch()
X{
X	register xchar x,y;
X	register struct trap *trap;
X	register struct monst *mtmp;
X
X	if(u.uswallow)
X		pline("What are you looking for? The exit?");
X	else
X	for(x = u.ux-1; x < u.ux+2; x++)
X	for(y = u.uy-1; y < u.uy+2; y++) if(x != u.ux || y != u.uy) {
X		if(levl[x][y].typ == SDOOR) {
X			if(rn2(7)) continue;
X			levl[x][y].typ = DOOR;
X			levl[x][y].seen = 0;	/* force prl */
X			prl(x,y);
X			nomul(0);
X		} else if(levl[x][y].typ == SCORR) {
X			if(rn2(7)) continue;
X			levl[x][y].typ = CORR;
X			levl[x][y].seen = 0;	/* force prl */
X			prl(x,y);
X			nomul(0);
X		} else {
X		/* Be careful not to find anything in an SCORR or SDOOR */
X			if(mtmp = m_at(x,y)) if(mtmp->mimic){
X				seemimic(mtmp);
X				pline("You find %s.",defmonnam(mtmp));
X				return(1);
X			}
X			for(trap = ftrap; trap; trap = trap->ntrap)
X			if(trap->tx == x && trap->ty == y &&
X			   !trap->tseen && !rn2(8)) {
X				nomul(0);
X				if (trap->ttyp != PIERC)
X				pline("You find a%s.", traps[Hallucination ?
X				rn2(TRAPNUM-2) : trap->ttyp ]);
X
X				if(trap->ttyp == PIERC) {
X					deltrap(trap);
X					mtmp=makemon(PM_PIERCER,x,y);
X					pline("You find %s.", defmonnam(mtmp));
X					return(1);
X				}
X				trap->tseen = 1;
X				if(!vism_at(x,y)) atl(x,y,'^');
X			}
X		}
X	}
X	return(1);
X}
X
Xdoidtrap() {
Xregister struct trap *trap;
Xregister int x,y;
X	if(!getdir(1)) return(0);
X	x = u.ux + u.dx;
X	y = u.uy + u.dy;
X	for(trap = ftrap; trap; trap = trap->ntrap)
X		if(trap->tx == x && trap->ty == y && trap->tseen) {
X		    if(u.dz)
X			if((u.dz < 0) != (!xdnstair && trap->ttyp == TRAPDOOR))
X			    continue;
X			pline("That is a%s.",traps[ Hallucination ? rn2(TRAPNUM-2) :
X			trap->ttyp]);
X		    return(0);
X		}
X	pline("I can't see a trap there.");
X	return(0);
X}
X
Xwakeup(mtmp)
Xregister struct monst *mtmp;
X{
X	mtmp->msleep = 0;
X	setmangry(mtmp);
X	if(mtmp->mimic) seemimic(mtmp);
X}
X
X/* NOTE: we must check if(mtmp->mimic) before calling this routine */
Xseemimic(mtmp)
Xregister struct monst *mtmp;
X{
X		mtmp->mimic = 0;
X		mtmp->mappearance = 0;
X		unpmon(mtmp);
X		pmon(mtmp);
X}
END_OF_search.c
if test 3458 -ne `wc -c <search.c`; then
    echo shar: \"search.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f sit.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"sit.c\"
else
echo shar: Extracting \"sit.c\" \(3702 characters\)
sed "s/^X//" >sit.c <<'END_OF_sit.c'
X/*	SCCS Id: @(#)sit.c	1.3	87/07/14
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* sit.c - version 1.0 */
X
X#include "hack.h"
X
X#ifdef NEWCLASS
Xint	identify();
X
Xdosit() {
X	extern struct obj *readobjnam(), *addinv();
X	register struct	obj	*otmp;
X	struct	 obj	*sobj_at();
X	register int	cnt;
X
X	char	buf[BUFSZ];
X
X	if(Levitation)  {
X
X		pline("You are floating in the air, you can't sit!");
X	} else	if(IS_THRONE(levl[u.ux][u.uy].typ)) {
X
X		pline("As you sit in the opulant throne");
X		if (rnd(6) > 4)  {
X
X			switch (rnd(13))  {
X
X			    case 1:
X				pline("you feel suddenly weaker.");
X				if(Poison_resistance) {
X
X				    losestr(rn1(1,2));
X				    losehp(rnd(6), "cursed throne");
X				} else {
X
X				    losestr(rn1(4,3));
X				    losehp(rnd(10), "cursed throne");
X				}
X				break;
X			    case 2:
X				pline("you feel suddenly stronger.");
X				gainstr(0);
X				break;
X			    case 3:
X				pline("A massive charge of electricity shoots through your body!");
X				losehp(rnd(30), "electric chair");
X				break;
X			    case 4:
X				pline("you feel much, much better!");
X				if(u.uhp >= (u.uhpmax - 5))  u.uhpmax += 4;
X				u.uhp = u.uhpmax;
X				if (Blind) Blind = 1;
X				if (Sick)  Sick = 0;
X				flags.botl = 1;
X				break;
X			    case 5:
X				if (u.ugold <= 0)  {
X
X					pline("you feel a strange sensation.");
X				} else {
X					pline("you notice you have no gold!");
X					u.ugold = 0;
X					flags.botl = 1;
X				}
X				break;
X			    case 6:
X				if(u.uluck + rn2(5) < 0) {
X
X				    pline("you feel your luck is changing.");
X				    u.uluck++;
X				} else	    makewish();
X				break;
X			    case 7:
X				cnt = rnd(10);
X				pline("you hear a voice echo:");
X				pline("Your audience has been summoned, Sire!");
X				while(cnt--)
X				    (void) makemon(courtmon(), u.ux, u.uy);
X				break;
X			    case 8:
X				if (Confusion != 0)  {
X
X				    pline("you hear a voice echo:");
X				    pline("By your Imperious order Sire...");
X				}
X				do_genocide();
X				break;
X			    case 9:
X				pline("you hear a voice echo:");
X				pline("A curse upon you for sitting upon this most holy throne!");
X				if (u.uluck > 0)  {
X
X				    if(!Blind)	pline("a cloud of darkness falls upon you.");
X				    Blind += rn1(100,250);
X				    seeoff(0);
X				} else	    rndcurse();
X				break;
X			    case 10:
X				if (u.uluck < 0)  {
X
X					pline("an image forms in your mind.");
X					do_mapping();
X				} else  {
X
X					pline("your vision clarifies.");
X					HSee_invisible |= INTRINSIC;
X				}
X				break;
X			    case 11:
X				if (u.uluck < 0)  {
X
X				    pline("you feel threatened.");
X				    aggravate();
X				} else  {
X
X				    pline("you feel a wrenching sensation.");
X				    tele();		/* teleport him */
X				}
X				break;
X			    case 12:
X				pline("you are granted a gift of insight!");
X				while (!ggetobj("identify", identify, rn2(5))
X					&& invent);
X				break;
X			    case 13:
X				pline("your mind turns into a pretzel!");
X				HConfusion += rn1(7,16);
X				break;
X			    default:	impossible("throne effect");
X					break;
X			}
X		} else	pline("you feel somehow out of place...");
X
X		if (!rn2(3) && IS_THRONE(levl[u.ux][u.uy].typ))	{
X
X			pline("The throne vanishes in a puff of logic.");
X/*			levl[u.ux][u.uy].scrsym = '.'; */
X			levl[u.ux][u.uy].typ = ROOM;
X		}
X
X	} else	pline("Having fun sitting on the floor???");
X	return(1);
X}
X#endif /* NEWCLASS /**/
X
X#if defined(NEWCLASS) || defined(PRAYERS) || defined(HARD)
Xrndcurse() {			/* curse a few inventory items at random! */
X
X	int	nobj = 0;
X	int	cnt, onum;
X	struct	obj	*otmp;
X
X	for (otmp = invent; otmp; otmp = otmp->nobj)  nobj++;
X	    for (cnt = rnd(6); cnt > 0; cnt--)  {
X
X		onum = rn2(nobj);
X		for(otmp = invent; onum != 0; onum--)
X		    otmp = otmp->nobj;
X
X			otmp->cursed++;
X	    }
X}
X#endif
END_OF_sit.c
if test 3702 -ne `wc -c <sit.c`; then
    echo shar: \"sit.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f topl.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"topl.c\"
else
echo shar: Extracting \"topl.c\" \(3941 characters\)
sed "s/^X//" >topl.c <<'END_OF_topl.c'
X/*	SCCS Id: @(#)topl.c	1.3	87/07/14
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* topl.c - version 1.0.2 */
X
X#include <stdio.h>
X#include "hack.h"
Xextern char *eos();
Xextern int CO;
X
Xchar toplines[BUFSZ];
Xxchar tlx, tly;			/* set by pline; used by addtopl */
X
Xstruct topl {
X	struct topl *next_topl;
X	char *topl_text;
X} *old_toplines, *last_redone_topl;
X#define	OTLMAX	20		/* max nr of old toplines remembered */
X
Xdoredotopl(){
X	if(last_redone_topl)
X		last_redone_topl = last_redone_topl->next_topl;
X	if(!last_redone_topl)
X		last_redone_topl = old_toplines;
X	if(last_redone_topl){
X		(void) strcpy(toplines, last_redone_topl->topl_text);
X	}
X	redotoplin();
X	return(0);
X}
X
Xredotoplin() {
X	home();
X	if(index(toplines, '\n')) cl_end();
X	putstr(toplines);
X	cl_end();
X	tlx = curx;
X	tly = cury;
X	flags.toplin = 1;
X	if(tly > 1)
X		more();
X}
X
Xremember_topl() {
Xregister struct topl *tl;
Xregister int cnt = OTLMAX;
X	if(last_redone_topl &&
X	   !strcmp(toplines, last_redone_topl->topl_text)) return;
X	if(old_toplines &&
X	   !strcmp(toplines, old_toplines->topl_text)) return;
X	last_redone_topl = 0;
X	tl = (struct topl *)
X		alloc((unsigned)(strlen(toplines) + sizeof(struct topl) + 1));
X	tl->next_topl = old_toplines;
X	tl->topl_text = (char *)(tl + 1);
X	(void) strcpy(tl->topl_text, toplines);
X	old_toplines = tl;
X	while(cnt && tl){
X		cnt--;
X		tl = tl->next_topl;
X	}
X	if(tl && tl->next_topl){
X		free((char *) tl->next_topl);
X		tl->next_topl = 0;
X	}
X}
X
Xaddtopl(s) char *s; {
X	curs(tlx,tly);
X	if(tlx + strlen(s) > CO) putsym('\n');
X	putstr(s);
X	tlx = curx;
X	tly = cury;
X	flags.toplin = 1;
X}
X
Xxmore(s)
Xchar *s;	/* allowed chars besides space/return */
X{
X	if(flags.toplin) {
X		curs(tlx, tly);
X		if(tlx + 8 > CO) putsym('\n'), tly++;
X	}
X
X	if(flags.standout)
X		standoutbeg();
X	putstr("--More--");
X	if(flags.standout)
X		standoutend();
X
X	xwaitforspace(s);
X	if(flags.toplin && tly > 1) {
X		home();
X		cl_end();
X		docorner(1, tly-1);
X	}
X	flags.toplin = 0;
X}
X
Xmore(){
X	xmore("");
X}
X
Xcmore(s)
Xregister char *s;
X{
X	xmore(s);
X}
X
Xclrlin(){
X	if(flags.toplin) {
X		home();
X		cl_end();
X		if(tly > 1) docorner(1, tly-1);
X		remember_topl();
X	}
X	flags.toplin = 0;
X}
X
X/*VARARGS1*/
X/* Because the modified mstatusline has 9 arguments KAA */
Xpline(line,arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9)
Xregister char *line,*arg1,*arg2,*arg3,*arg4,*arg5,*arg6,*arg7,*arg8,*arg9;
X{
X	char pbuf[BUFSZ];
X	register char *bp = pbuf, *tl;
X	register int n,n0;
X
X	if(!line || !*line) return;
X	if(!index(line, '%')) (void) strcpy(pbuf,line); else
X	(void) sprintf(pbuf,line,arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
X	if(flags.toplin == 1 && !strcmp(pbuf, toplines)) return;
X	nscr();		/* %% */
X
X	/* If there is room on the line, print message on same line */
X	/* But messages like "You die..." deserve their own line */
X	n0 = strlen(bp);
X	if(flags.toplin == 1 && tly == 1 &&
X	    n0 + strlen(toplines) + 3 < CO-8 &&  /* leave room for --More-- */
X	    strncmp(bp, "You ", 4)) {
X		(void) strcat(toplines, "  ");
X		(void) strcat(toplines, bp);
X		tlx += 2;
X		addtopl(bp);
X		return;
X	}
X	if(flags.toplin == 1) more();
X	remember_topl();
X	toplines[0] = 0;
X	while(n0){
X		if(n0 >= CO){
X			/* look for appropriate cut point */
X			n0 = 0;
X			for(n = 0; n < CO; n++) if(bp[n] == ' ')
X				n0 = n;
X			if(!n0) for(n = 0; n < CO-1; n++)
X				if(!letter(bp[n])) n0 = n;
X			if(!n0) n0 = CO-2;
X		}
X		(void) strncpy((tl = eos(toplines)), bp, n0);
X		tl[n0] = 0;
X		bp += n0;
X
X		/* remove trailing spaces, but leave one */
X		while(n0 > 1 && tl[n0-1] == ' ' && tl[n0-2] == ' ')
X			tl[--n0] = 0;
X
X		n0 = strlen(bp);
X		if(n0 && tl[0]) (void) strcat(tl, "\n");
X	}
X	redotoplin();
X}
X
Xputsym(c) char c; {
X	switch(c) {
X	case '\b':
X		backsp();
X		return;
X	case '\n':
X		curx = 1;
X		cury++;
X		if(cury > tly) tly = cury;
X		break;
X	default:
X		if(curx == CO)
X			putsym('\n');	/* 1 <= curx <= CO; avoid CO */
X		else
X			curx++;
X	}
X	(void) putchar(c);
X}
X
Xputstr(s) register char *s; {
X	while(*s) putsym(*s++);
X}
END_OF_topl.c
if test 3941 -ne `wc -c <topl.c`; then
    echo shar: \"topl.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f write.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"write.c\"
else
echo shar: Extracting \"write.c\" \(3864 characters\)
sed "s/^X//" >write.c <<'END_OF_write.c'
X/*	SCCS Id: @(#)write.c	1.3	87/07/14
X/* write.c - version 1.0.3 */
X
X#include "hack.h"
X
Xextern char pl_character[];
X
X#ifdef MARKER
X
X/*
X * returns basecost of a scroll
X */
Xint
Xcost(scroll)
Xregister struct obj *scroll;
X{
X	switch(scroll->otyp)  {
X# ifdef MAIL
X	case SCR_MAIL:
X# endif
X		return(0);
X		break;
X	case SCR_LIGHT:
X	case SCR_GOLD_DETECTION:
X	case SCR_FOOD_DETECTION:
X	case SCR_MAGIC_MAPPING:
X	case SCR_AMNESIA:
X	case SCR_FIRE:
X		return(8);
X		break;
X	case SCR_DESTROY_ARMOR:
X	case SCR_DAMAGE_WEAPON:
X	case SCR_CREATE_MONSTER:
X	case SCR_PUNISHMENT:
X		return(10);
X		break;
X	case SCR_CONFUSE_MONSTER:
X		return(12);
X		break;
X	case SCR_IDENTIFY:
X		return(14);
X		break;
X	case SCR_ENCHANT_ARMOR:
X	case SCR_REMOVE_CURSE:
X	case SCR_ENCHANT_WEAPON:
X		return(16);
X		break;
X	case SCR_SCARE_MONSTER:
X	case SCR_TAMING:
X	case SCR_TELEPORTATION:
X		return(20);
X		break;
X	case SCR_GENOCIDE:
X		return(30);
X		break;
X	case SCR_BLANK_PAPER:
X	default:
X		impossible("You can't write such a weird scroll!");
X		return(1000);
X	}
X}
X
X
Xdowrite(pen)
X	register struct obj *pen;
X{
X	register struct obj *paper;
X	char namebuf[BUFSZ], scrbuf[BUFSZ];
X	register struct obj *newscroll;
X	extern struct obj *readobjnam(), *addinv();
X	int basecost, actualcost;
X	int newquan;
X	
X	if(!pen)
X		return(0);
X	if(pen->otyp != MAGIC_MARKER)  {
X		pline("You can't write with that!");
X		return(0);
X	}
X	
X	/* get paper to write on */
X	paper = getobj("?","write on");
X	if(!paper)
X		return(0);
X	if(!(objects[paper->otyp].oc_name_known))  {
X		pline("In your haste, you rip the scroll to pieces.");
X		useup(paper);
X		return(1);
X	}
X# ifndef KAA
X/* If this is included, the strategy would be to name all scrolls so that
X * you can test them for blankness with a magic marker.  This is tedious,
X * thus, let's make it easier. */
X	if(!(objects[paper->otyp].oc_name_known))  {
X		pline("In your haste, you rip the scroll to pieces.");
X		useup(paper);
X		return(0);
X	}
X# endif
X	if(paper->otyp != SCR_BLANK_PAPER)  {
X		pline("You fool, that scroll's not blank!");
X		return(0);
X	}
X	
X	/* what to write */
X	pline("What do you want to write? ");
X	getlin(namebuf);
X	if(namebuf[0] == '\033' || !namebuf[0])
X		return(0);
X	strcpy(scrbuf,"scroll of ");
X	strcat(scrbuf,namebuf);
X	newscroll = readobjnam(scrbuf);
X	if(newscroll->olet != SCROLL_SYM ||
X	   newscroll->otyp == SCR_BLANK_PAPER)  {
X		pline("You can't write that!");
X		pline("It's obscene!");
X		return(0);
X	}
X	
X	/* see if there's enough ink */
X	basecost = cost(newscroll);
X	if(pen->spe < basecost/2)  {
X		pline("You marker is too dried out to write that!");
X		obfree(newscroll, (struct obj *) 0);
X		return(0);
X	}
X	
X	/* we're really going to write now, so calculate
X	 * cost and useup old scroll
X	 */
X	actualcost = rn1(basecost/2,basecost/2);
X	useup(paper);
X	
X	/* dry out marker */
X	if(pen->spe < actualcost)  {
X		pline("Your marker dries out!");
X		pline("The scroll is now useless and disappears!");
X		pen->spe = 0;
X		obfree(newscroll, (struct obj *) 0);
X		return(1);
X	}
X	pen->spe -= actualcost;
X# ifdef KAA /* Since the KAA modification allows writing on unknown blank
X		paper, identify blank paper. */
X	objects[SCR_BLANK_PAPER].oc_name_known=1;
X# endif
X	
X	/* can't write if we don't know it - unless we're lucky */
X	if(!(objects[newscroll->otyp].oc_name_known) && 
X# ifdef KAA
X	   !(objects[newscroll->otyp].oc_uname) && 
X# endif
X	   ((pl_character[0] == 'W' && rn2(3)) ||
X	    (pl_character[0] != 'W' && rn2(10))))  {
X		pline("You don't know how to write that!");
X		pline("You write \"Shah was here!\" and the scroll disappears.");
X		obfree(newscroll, (struct obj *) 0);
X		return(1);
X	}
X	
X	/* and now you know it! */
X	objects[newscroll->otyp].oc_name_known = 1;
X	
X	/* success - don't forget to fool prinv() */
X	newscroll = addinv(newscroll);
X	newquan = newscroll->quan;
X	newscroll->quan = 1;
X	prinv(newscroll);
X	newscroll->quan = newquan;
X	
X	return(1);
X}
X# endif /* MARKER /**/
END_OF_write.c
if test 3864 -ne `wc -c <write.c`; then
    echo shar: \"write.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f you.h -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"you.h\"
else
echo shar: Extracting \"you.h\" \(3576 characters\)
sed "s/^X//" >you.h <<'END_OF_you.h'
X/*	SCCS Id: @(#)you.h	1.3	87/07/14
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* you.h - version 1 */
X
X#include "config.h"
X#include "onames.h"
X#include "permonst.h"
X
Xstruct prop {
X#define	TIMEOUT		007777	/* mask */
X#define	LEFT_RING	W_RINGL	/* 010000L */
X#define	RIGHT_RING	W_RINGR	/* 020000L */
X#define	INTRINSIC	040000L
X#define	LEFT_SIDE	LEFT_RING
X#define	RIGHT_SIDE	RIGHT_RING
X#define	BOTH_SIDES	(LEFT_SIDE | RIGHT_SIDE)
X	long p_flgs;
X	int (*p_tofn)();	/* called after timeout */
X};
X
Xstruct you {
X	xchar ux, uy;
X	schar dx, dy, dz;	/* direction of move (or zap or ... ) */
X	schar di;		/* direction of FF */
X	xchar ux0, uy0;		/* initial position FF */
X	xchar udisx, udisy;	/* last display pos */
X	char usym;		/* usually '@' */
X	schar uluck;
X#define	LUCKMAX		10	/* on moonlit nights 11 */
X#define	LUCKMIN		(-10)
X	int last_str_turn;	/* 0: none, 1: half turn, 2: full turn */
X				/* +: turn right, -: turn left */
X	unsigned udispl;	/* @ on display */
X	unsigned ulevel;	/* 1 - 14 */
X#ifdef QUEST
X	unsigned uhorizon;
X#endif
X	unsigned utrap;		/* trap timeout */
X	unsigned utraptype;	/* defined if utrap nonzero */
X#define	TT_BEARTRAP	0
X#define	TT_PIT		1
X#ifdef SPIDERS
X#define	TT_WEB		2
X#endif SPIDERS
X	unsigned uinshop;	/* used only in shk.c - (roomno+1) of shop */
X
X/* perhaps these #define's should also be generated by makedefs */
X#define	TELEPAT		LAST_RING		/* not a ring */
X#define	HTelepat	u.uprops[TELEPAT].p_flgs
X#define	Telepat		((HTelepat) || (u.usym == 'E'))
X#define	FAST		(LAST_RING+1)		/* not a ring */
X#define	Fast		u.uprops[FAST].p_flgs
X#define	CONFUSION	(LAST_RING+2)		/* not a ring */
X#define	HConfusion	u.uprops[CONFUSION].p_flgs
X#define Confusion	((HConfusion) || index("BIy", u.usym))
X#define	INVIS		(LAST_RING+3)		/* not a ring */
X#define	HInvis		u.uprops[INVIS].p_flgs
X#define Invis		((HInvis) || u.usym == 'I')
X#define Invisible	(Invis && !See_invisible)
X#define	GLIB		(LAST_RING+4)		/* not a ring */
X#define	Glib		u.uprops[GLIB].p_flgs
X#define	PUNISHED	(LAST_RING+5)		/* not a ring */
X#define	Punished	u.uprops[PUNISHED].p_flgs
X#define	SICK		(LAST_RING+6)		/* not a ring */
X#define	Sick		u.uprops[SICK].p_flgs
X#define	BLIND		(LAST_RING+7)		/* not a ring */
X#define	Blind		u.uprops[BLIND].p_flgs
X#define	WOUNDED_LEGS	(LAST_RING+8)		/* not a ring */
X#define Wounded_legs	u.uprops[WOUNDED_LEGS].p_flgs
X#define STONED		(LAST_RING+9)		/* not a ring */
X#define Stoned		u.uprops[STONED].p_flgs
X#define HALLUCINATION	(LAST_RING+10)		/* not a ring */
X#define Hallucination	u.uprops[HALLUCINATION].p_flgs
X#define PROP(x) (x-RIN_ADORNMENT)       /* convert ring to index in uprops */
X	unsigned umconf;
X	char *usick_cause;
X	struct prop uprops[LAST_RING+11];
X	int mh, mhmax, mtimedone, umonnum;	    /* for polymorph-self */
X#if defined(KOPS) && defined(KAA)
X	unsigned ucreamed;
X#endif
X	unsigned uswallow;		/* set if swallowed by a monster */
X	unsigned uswldtim;		/* time you have been swallowed */
X	unsigned uhs;			/* hunger state - see hack.eat.c */
X#ifdef HARD
X	unsigned udemigod;		/* once you kill the wiz */
X	unsigned udg_cnt;		/* how long you have been demigod */
X#endif
X	schar ustr,ustrmax;
X	schar udaminc;
X	schar uac;
X	int uhp,uhpmax;
X#ifdef SPELLS
X	int uen,uenmax;			/* magical energy - M. Stephenson */
X#endif
X#ifdef PRAYERS
X	int ugangr;			/* if the gods are angry at you */
X	int ublessed,ublesscnt;		/* blessing/duration from #pray */
X#endif
X	long int ugold,ugold0,uexp,urexp;
X	int uhunger;			/* refd only in eat.c and shk.c */
X	int uinvault;
X	struct monst *ustuck;
X	int nr_killed[CMNUM+2];		/* used for experience bookkeeping */
X};
END_OF_you.h
if test 3576 -ne `wc -c <you.h`; then
    echo shar: \"you.h\" unpacked with wrong size!
fi
# end of overwriting check
fi
echo shar: End of archive 15 \(of 16\).
cp /dev/null ark15isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 16 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
X#endif
