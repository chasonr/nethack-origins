Relay-Version: version B 2.10 5/3/83; site utzoo.UUCP
Path: utzoo!mnetor!uunet!seismo!columbia!rutgers!sri-spam!ames!ucbcad!ucbvax!decvax!tektronix!tekgen!tekred!games-request
From: games-request@tekred.TEK.COM
Newsgroups: comp.sources.games
Subject: v02i016:  nethack - display oriented dungeons & dragons, Part16/16
Message-ID: <1458@tekred.TEK.COM>
Date: Tue, 28-Jul-87 14:55:23 EDT
Article-I.D.: tekred.1458
Posted: Tue Jul 28 14:55:23 1987
Date-Received: Fri, 31-Jul-87 00:36:54 EDT
Sender: billr@tekred.TEK.COM
Lines: 1846
Approved: billr@tekred.TEK.COM

Submitted by: mike@genat.UUCP (Mike Stephenson)
Comp.sources.games: Volume 2, Issue 16
Archive-name: nethack/Part16



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 16 (of 16)."
# Contents:  Make.ini alloc.c decl.c edog.h eshk.h extern.h flag.h
#   func_tab.h hack.h hh mfndpos.h mkroom.h monst.h msdos.h
#   nansi.sys.uu nethack.sh netquest.sh obj.h objclass.h pcunix.c
#   permonst.h rip.c rm.h rnd.c rumors.mrx spell.h timeout.c track.c
#   version.c wseg.h
# Wrapped by billr@tekred on Tue Jul 28 09:49:52 1987
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f Make.ini -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"Make.ini\"
else
echo shar: Extracting \"Make.ini\" \(1759 characters\)
sed "s/^X//" >Make.ini <<'END_OF_Make.ini'
X#	SCCS Id: @(#)Make.ini	1.3	87/07/14
X# This is a sample `make.ini' file for NDMAKE v3.7.  You will probably want
X# to customize it for your system.
X
X
X
X# The order to search for rules and files is specified by .SUFFIXES
X.SUFFIXES : .exe .obj .c .for .asm
X
X# A few macros.
XCFLAGS = -A$(MODEL)
XMODEL = S
XSETARGV = $(LIB)\$(MODEL)SETARGV
XLIBS =
XBIN =
XLFLAGS =
X
X# A universally useful target.
Xclean:
X	+-erase *.bak
X	+-erase *.map
X
X# .BEFORE and .AFTER can be used to turn DPATH off and on.
X.BEFORE:; @+echo For help with ndmake, use the command `make -h'
X.AFTER:; @+echo All done.
X
X
X# DEFAULT RULES
X# To produce a `.obj' file from a `.asm' file using MASM.
X.asm.obj:; masm $*.asm;
X
X# To produce a `.obj' file from a `.c' file using Microsoft C. 
X.c.obj:; msc $(CFLAGS) -I\c $*.c
X
X# To produce a `.obj' file from a `.for' file using Microsoft Fortran.
X.for.obj:
X	for1 $*.for;
X	pas2
X
X# To produce a `.exe' file from an `.obj' file.  Note that there is a
X# problem because LIBS may be different for linking `.obj' files
X# produced by different compilers (C, FORTRAN, PASCAL, etc).  To avoid
X# this problem you may want to have the C compiler produce `.cbj' files,
X# the FORTRAN compiler produce `.fbj' files, etc.  Then you could write
X# specific rules for `.cbj.exe' and `.fbj.exe' which would use the correct
X# libraries.
X.obj.exe:
X	link $*.obj $(SETARGV), $@,, $(LIBS) $(LFLAGS);
X
X# To produce a `.exe' file from a `.asm' file.
X.asm.exe:
X	masm $*.asm;
X	link $*.obj, $@,, $(LIBS)
X	erase $*.obj
X
X# To produce a `.exe' file from a `.c' file.
X.c.exe:
X	msc $(CFLAGS) -I\c $*.c
X	link $*.obj $(SETARGV), $@,, $(LIBS) $(LFLAGS)
X	erase $*.obj
X
X# To produce a `.exe' file from a `.for' file.
X.for.exe:
X	for1 $*.for;
X	pas2
X	link $*.obj, $@,, $(LIB)\FORTRAN.LIB
X	erase $*.obj
END_OF_Make.ini
if test 1759 -ne `wc -c <Make.ini`; then
    echo shar: \"Make.ini\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f alloc.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"alloc.c\"
else
echo shar: Extracting \"alloc.c\" \(865 characters\)
sed "s/^X//" >alloc.c <<'END_OF_alloc.c'
X/*	SCCS Id: @(#)alloc.c	1.3	87/07/14
X/* alloc.c - version 1.0.2 */
X#ifdef LINT
X
X/*
X   a ridiculous definition, suppressing
X	"possible pointer alignment problem" for (long *) malloc()
X	"enlarg defined but never used"
X	"ftell defined (in <stdio.h>) but never used"
X   from lint
X*/
X#include <stdio.h>
Xlong *
Xalloc(n) unsigned n; {
Xlong dummy = ftell(stderr);
X	if(n) dummy = 0;	/* make sure arg is used */
X	return(&dummy);
X}
X
X#else
X
Xextern char *malloc();
Xextern char *realloc();
X
Xlong *
Xalloc(lth)
Xregister unsigned lth;
X{
X	register char *ptr;
X
X	if(!(ptr = malloc(lth)))
X		panic("Cannot get %d bytes", lth);
X	return((long *) ptr);
X}
X
X#ifndef DGK
Xlong *
Xenlarge(ptr,lth)
Xregister char *ptr;
Xregister unsigned lth;
X{
X	register char *nptr;
X
X	if(!(nptr = realloc(ptr,lth)))
X		panic("Cannot reallocate %d bytes", lth);
X	return((long *) nptr);
X}
X#endif
X
X#endif /* LINT /**/
END_OF_alloc.c
if test 865 -ne `wc -c <alloc.c`; then
    echo shar: \"alloc.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f decl.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"decl.c\"
else
echo shar: Extracting \"decl.c\" \(1992 characters\)
sed "s/^X//" >decl.c <<'END_OF_decl.c'
X/*	SCCS Id: @(#)decl.c	1.3	87/07/14
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* Decl.c - version 1.0.3 */
X
X#include	"hack.h"
Xchar nul[40];			/* contains zeros */
Xchar plname[PL_NSIZ];		/* player name */
X#ifdef DGK
Xchar hackdir[PATHLEN];		/* where rumors, help, record are */
Xchar levels[PATHLEN];		/* where levels are */
Xchar lock[FILENAME];		/* pathname of level files */
Xchar permbones[PATHLEN];	/* where permanent copy of bones go */
Xint ramdisk = FALSE;		/* whether to copy bones to levels or not */
Xstruct symbols symbol = {'|', '-', '-', '-', '-', '-', '+', '.', '#'};
Xint saveprompt = TRUE;
Xchar *alllevels = "levels.*";
Xchar *allbones = "bones.*";
Xchar *configfile = "HACK.CNF";	/* read by read_config_file() */
X#else
Xchar lock[PL_NSIZ+4] = "1lock";	/* long enough for login name .99 */
X#endif
X
Xboolean in_mklev, restoring;
Xstruct rm levl[COLNO][ROWNO]; /* level map */
X
X#ifndef QUEST
X#include "mkroom.h"
Xstruct mkroom rooms[MAXNROFROOMS+1];
Xcoord doors[DOORMAX];
X#endif
Xstruct monst *fmon = 0;
Xstruct trap *ftrap = 0;
Xstruct gold *fgold = 0;
Xstruct obj *fobj = 0, *fcobj = 0, *invent = 0, *uwep = 0, *uarm = 0,
X	*uarm2 = 0, *uarmh = 0, *uarms = 0, *uarmg = 0, *uright = 0,
X	*uleft = 0, *uchain = 0, *uball = 0;
Xstruct flag flags;
Xstruct you u;
X#ifdef SPELLS
Xstruct spell spl_book[MAXSPELL + 1];
X#endif
Xstruct rm levl[COLNO][ROWNO];	/* level map */
Xstruct monst youmonst;	/* dummy; used as return value for boomhit */
X
Xxchar dlevel = 1;
Xxchar xupstair, yupstair, xdnstair, ydnstair;
Xchar *save_cm = 0, *killer, *nomovemsg;
X
Xlong moves = 1;
Xlong wailmsg = 0;
Xint multi = 0;
Xchar	*occtxt;
X#ifdef DGKMOD
Xint	occtime;
X#endif
X#ifdef REDO
Xint	in_doagain;
X#endif
X
Xchar *HI, *HE;		/* set up in termcap.c */
X
Xchar genocided[60];
Xchar fut_geno[60];
X#ifdef KAA
Xboolean	stoned;				/* done to monsters hit by 'c' */
Xboolean	unweapon;
X#endif
X 
Xxchar curx,cury;
Xxchar seelx, seehx, seely, seehy;	/* corners of lit room */
X
Xcoord bhitpos;
X
Xchar quitchars[] = " \r\n\033";
END_OF_decl.c
if test 1992 -ne `wc -c <decl.c`; then
    echo shar: \"decl.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f edog.h -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"edog.h\"
else
echo shar: Extracting \"edog.h\" \(670 characters\)
sed "s/^X//" >edog.h <<'END_OF_edog.h'
X/*	SCCS Id: @(#)edog.h	1.3	87/07/14
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* edog.h - version 1.0.2 */
X
X/*	various types of food, the lower, the better liked.	*/
X
X#define	DOGFOOD	0
X#define	CADAVER	1
X#define	ACCFOOD	2
X#define	MANFOOD	3
X#define	APPORT	4
X#define	POISON	5
X#define	UNDEF	6
X
Xstruct edog {
X	long hungrytime;	/* at this time dog gets hungry */
X	long eattime;		/* dog is eating */
X	long droptime;		/* moment dog dropped object */
X	unsigned dropdist;		/* dist of drpped obj from @ */
X	unsigned apport;		/* amount of training */
X	long whistletime;		/* last time he whistled */
X};
X#define	EDOG(mp)	((struct edog *)(&(mp->mextra[0])))
END_OF_edog.h
if test 670 -ne `wc -c <edog.h`; then
    echo shar: \"edog.h\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f eshk.h -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"eshk.h\"
else
echo shar: Extracting \"eshk.h\" \(790 characters\)
sed "s/^X//" >eshk.h <<'END_OF_eshk.h'
X/*	SCCS Id: @(#)eshk.h	1.3	87/07/14
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* eshk.h - version 1.0.2 : added 'following' */
X
X#define	BILLSZ	200
Xstruct bill_x {
X	unsigned bo_id;
X	Bitfield(useup,1);
X	Bitfield(bquan,7);
X	unsigned price;		/* price per unit */
X};
X
Xstruct eshk {
X	long int robbed;	/* amount stolen by most recent customer */
X	boolean following;	/* following customer since he owes us sth */
X	schar shoproom;		/* index in rooms; set by inshop() */
X	coord shk;		/* usual position shopkeeper */
X	coord shd;		/* position shop door */
X	int shoplevel;		/* level of his shop */
X	int billct;
X	struct bill_x bill[BILLSZ];
X	int visitct;		/* nr of visits by most recent customer */
X	char customer[PL_NSIZ];	/* most recent customer */
X	char shknam[PL_NSIZ];
X};
END_OF_eshk.h
if test 790 -ne `wc -c <eshk.h`; then
    echo shar: \"eshk.h\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f extern.h -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"extern.h\"
else
echo shar: Extracting \"extern.h\" \(1290 characters\)
sed "s/^X//" >extern.h <<'END_OF_extern.h'
X/*	SCCS Id: @(#)extern.h	1.3	87/07/14
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* extern.h - version 1.0 */
X
X#include "config.h"
X
X#ifndef MSDOS
Xextern char *sprintf();
X#endif
X
Xextern long *alloc();
X
Xextern xchar xdnstair, ydnstair, xupstair, yupstair; /* stairs up and down. */
X
Xextern xchar dlevel;
X
X#ifdef SPELLS
X#include "spell.h"
Xextern	struct spell spl_book[];
X#endif
X
Xextern int occtime;
Xextern char *occtxt;		/* defined when occupation != NULL */
X
X#ifdef REDO
Xextern int in_doagain;
X#endif
X
Xextern char *HI, *HE;		/* set up in termcap.c */
X
X#include "obj.h"
Xextern struct obj *invent, *uwep, *uarm, *uarm2, *uarmh, *uarms, *uarmg, 
X	*uleft, *uright, *fcobj;
Xextern struct obj *uchain;	/* defined iff PUNISHED */
Xextern struct obj *uball;	/* defined if PUNISHED */
Xstruct obj *o_at(), *getobj(), *sobj_at();
X
Xextern char *traps[];
Xextern char *monnam(), *Monnam(), *amonnam(), *Amonnam(),
X	*doname(), *aobjnam();
Xextern char readchar();
Xextern char vowels[];
X
X#include "you.h"
X
Xextern struct you u;
X
Xextern xchar curx,cury;	/* cursor location on screen */
X
Xextern xchar seehx,seelx,seehy,seely; /* where to see*/
Xextern char *save_cm,*killer;
X
Xextern xchar dlevel, maxdlevel; /* dungeon level */
X
Xextern long moves;
X
Xextern int multi;
X
Xextern char lock[];
END_OF_extern.h
if test 1290 -ne `wc -c <extern.h`; then
    echo shar: \"extern.h\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f flag.h -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"flag.h\"
else
echo shar: Extracting \"flag.h\" \(2142 characters\)
sed "s/^X//" >flag.h <<'END_OF_flag.h'
X/*	SCCS Id: @(#)flag.h	1.3	87/07/14
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* flag.h - version 1.0.3 */
X
Xstruct flag {
X	unsigned ident;		/* social security number for each monster */
X	unsigned debug;		/* in debugging mode */
X#define	wizard	flags.debug
X	unsigned toplin;	/* a top line (message) has been printed */
X				/* 0: top line empty; 2: no --More-- reqd. */
X	unsigned cbreak;	/* in cbreak mode, rogue format */
X	unsigned standout;	/* use standout for --More-- */
X	unsigned nonull;	/* avoid sending nulls to the terminal */
X	unsigned time;		/* display elapsed 'time' */
X	unsigned nonews;	/* suppress news printing */
X	unsigned notombstone;
X	unsigned end_top, end_around;	/* describe desired score list */
X	unsigned end_own;		/* idem (list all own scores) */
X	unsigned no_rest_on_space;	/* spaces are ignored */
X	unsigned beginner;
X	unsigned female;
X	unsigned invlet_constant;	/* let objects keep their
X					   inventory symbol */
X	unsigned move;
X	unsigned mv;
X	unsigned run;		/* 0: h (etc), 1: H (etc), 2: fh (etc) */
X				/* 3: FH, 4: ff+, 5: ff-, 6: FF+, 7: FF- */
X	unsigned nopick;	/* do not pickup objects */
X	unsigned echo;		/* 1 to echo characters */
X	unsigned botl;		/* partially redo status line */
X	unsigned botlx;		/* print an entirely new bottom line */
X	unsigned nscrinh;	/* inhibit nscr() in pline(); */
X	unsigned made_amulet;
X	unsigned no_of_wizards;	/* 0, 1 or 2 (wizard and his shadow) */
X				/* reset from 2 to 1, but never to 0 */
X	unsigned moonphase;
X#define	NEW_MOON	0
X#define	FULL_MOON	4
X
X#ifdef SORTING
X	unsigned sortpack;	/* sorted inventory */
X#endif
X#ifdef SAFE_ATTACK
X	unsigned confirm;	/* confirm before hitting tame monsters */
X#endif
X#ifdef DGKMOD
X	unsigned silent;	/* whether the bell rings or not */
X	unsigned pickup;	/* whether you pickup or move and look */
X#endif
X#ifdef DGK
X	unsigned IBMBIOS;	/* whether we can use a BIOS call for
X				 * redrawing the screen and character input */
X	unsigned DECRainbow;	/* Used for DEC Rainbow graphics. */
X	unsigned rawio;		/* Whether can use rawio (IOCTL call) */
X	unsigned extra1;
X	unsigned extra2;
X#endif
X};
X
Xextern struct flag flags;
END_OF_flag.h
if test 2142 -ne `wc -c <flag.h`; then
    echo shar: \"flag.h\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f func_tab.h -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"func_tab.h\"
else
echo shar: Extracting \"func_tab.h\" \(360 characters\)
sed "s/^X//" >func_tab.h <<'END_OF_func_tab.h'
X/*	SCCS Id: @(#)func_tab.h	1.3	87/07/14
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* func_tab.h - version 1.0.2 */
X
Xstruct func_tab {
X	char f_char;
X	int (*f_funct)();
X	char *f_text;
X};
X
Xextern struct func_tab cmdlist[];
X
Xstruct ext_func_tab {
X	char *ef_txt, *ef_desc;
X	int (*ef_funct)();
X};
X
Xextern struct ext_func_tab extcmdlist[];
END_OF_func_tab.h
if test 360 -ne `wc -c <func_tab.h`; then
    echo shar: \"func_tab.h\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f hack.h -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"hack.h\"
else
echo shar: Extracting \"hack.h\" \(1134 characters\)
sed "s/^X//" >hack.h <<'END_OF_hack.h'
X/*	SCCS Id: @(#)hack.h	1.3	87/07/14
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* hack.h - version 1.0.3 */
X
X#include "config.h"
X
X#define	Null(type)	((struct type *) 0)
X
X#include	"objclass.h"
X
Xtypedef struct {
X	xchar x,y;
X} coord;
X
Xextern coord bhitpos;	/* place where thrown weapon falls to the ground */
X
X#include	"monst.h"	/* uses coord */
X#include	"gold.h"
X#include	"trap.h"
X#include	"obj.h"
X#include	"flag.h"
X
X#define	plur(x)	(((x) == 1) ? "" : "s")
X#define min(x,y) ((x) < (y) ? (x) : (y))
X
X#define	BUFSZ	256	/* for getlin buffers */
X#define	PL_NSIZ	32	/* name of player, ghost, shopkeeper */
X
X#include	"rm.h"
X
X#define Inhell		(dlevel >= 30)
X#define	newstring(x)	(char *) alloc((unsigned)(x))
X
X#ifdef SPELLS
X#include "spell.h"
X#define	NO_SPELL	0
X#endif
X
X#define	TELL	1
X#define NOTELL	0
X
X#define ON 1
X#define OFF 0
X
X#include "extern.h"
X
X#define DIST(x1,y1,x2,y2)       (((x1)-(x2))*((x1)-(x2)) + ((y1)-(y2))*((y1)-(y2)))
X
X#define	PL_CSIZ		20	/* sizeof pl_character */
X#define	MAX_CARR_CAP	120	/* so that boulders can be heavier */
X#define	MAXLEVEL	40
X#define	FAR	(COLNO+2)	/* position outside screen */
END_OF_hack.h
if test 1134 -ne `wc -c <hack.h`; then
    echo shar: \"hack.h\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f hh -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"hh\"
else
echo shar: Extracting \"hh\" \(2047 characters\)
sed "s/^X//" >hh <<'END_OF_hh'
Xy k u	Move commands:
X \|/		hykulnjb: single move in specified direction
Xh-+-l		HYKULNJB: repeated move in specified direction
X /|\			(until stopped by e.g. a wall)
Xb j n		g<dir>: fast movement in direction <dir>
X			(until something interesting is seen)
X		m<dir>: move without picking up objects
X
XMeta commands:
XQ	quit	leave the game
XS	save	save the game (to be continued later)
X!	sh	escape to some SHELL
X^Z	suspend suspend the game (independent of your current suspend char)
XO	set	set options
X?	help	print information
X/	whatis	give name (and sometimes more info) of specified monster
X\	known	print list of what's been discovered
Xv	version print version number
X^R	redraw	redraw the screen (^R denotes the symbol CTRL/R)
X^P	print	repeat last message  (subsequent ^P's repeat earlier messages)
X#		introduces a long command (# ? for list of long commands)
X
XGame commands:
X^T	teleport teleport
Xa	apply, use  use something (a key, camera, etc.)
Xc	call	give a name to a class of objects
Xd	drop	drop an object. d7a: drop seven items of object a.
Xe	eat	eat something
Xi	invent	list the inventory (all objects you are carrying)
XI	invent	list selected parts of the inventory
X		IU: list unpaid objects
X		IX: list unpaid but used up items
X		I$: count your money
Xp	pay	pay your bill
Xq	drink	quaff a potion
Xr	read	read a scroll
Xs	search	search for secret doors, hidden traps and monsters
Xt	throw	throw or shoot a weapon
Xw	wield	wield a weapon	(w-  wield nothing)
Xx	spells	print a list of know spells
XX	Xcribe	transcribe (learn) a spell
Xz	zap	zap a wand
XC	name	name an individual monster (e.g., baptize your dog)
XD	Drop	drop several things
XE	Engrave write a message in the dust on the floor  (E-  use fingers)
XP	wear	put on a ring
XR	remove	remove a ring
XT	remove	take off some armor
XW	wear	put on some armor
X<	up	go up the stairs
X>	down	go down the stairs
X^	trap_id identify a previously found trap
X),[,=		ask for current weapon, armor, rings, respectively
X$	gold	count your gold
X.	rest	wait a moment
X,	pickup	pick up all you can carry
X:	look	look at what is here
END_OF_hh
if test 2047 -ne `wc -c <hh`; then
    echo shar: \"hh\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f mfndpos.h -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"mfndpos.h\"
else
echo shar: Extracting \"mfndpos.h\" \(641 characters\)
sed "s/^X//" >mfndpos.h <<'END_OF_mfndpos.h'
X/*	SCCS Id: @(#)mfndpos.h	1.3	87/07/14
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* mfndpos.h - version 1.0.2 */
X 
X/* changed by GAN 02/06/87 to add nine extra bits for traps -
X * this because new traps make nine for traps insufficient
X */
X 
X#define ALLOW_TRAPS     0777777
X#define ALLOW_U         01000000
X#define ALLOW_M         02000000
X#define ALLOW_TM        04000000
X#define ALLOW_ALL       (ALLOW_U | ALLOW_M | ALLOW_TM | ALLOW_TRAPS)
X#define ALLOW_SSM       010000000
X#define ALLOW_ROCK      020000000
X#define NOTONL          040000000
X#define NOGARLIC        0100000000
X#define ALLOW_WALL      0200000000
END_OF_mfndpos.h
if test 641 -ne `wc -c <mfndpos.h`; then
    echo shar: \"mfndpos.h\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f mkroom.h -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"mkroom.h\"
else
echo shar: Extracting \"mkroom.h\" \(707 characters\)
sed "s/^X//" >mkroom.h <<'END_OF_mkroom.h'
X/*	SCCS Id: @(#)mkroom.h	1.3	87/07/14
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* mkroom.h - version 1.0.3 */
X
Xstruct mkroom {
X	schar lx,hx,ly,hy;	/* usually xchar, but hx may be -1 */
X	schar rtype,rlit,doorct,fdoor;
X};
X
X#define	MAXNROFROOMS	15
Xextern struct mkroom rooms[MAXNROFROOMS+1];
X
X#define	DOORMAX	100
Xextern coord doors[DOORMAX];
X
X/* various values of rtype */
X/* 0: ordinary room; 8-15: various shops */
X/* Note: some code assumes that >= 8 means shop, so be careful when adding
X   new roomtypes */
X
X#define COURT		 2
X#define	SWAMP		 3
X#define	VAULT		 4
X#define	BEEHIVE		 5
X#define	MORGUE		 6
X#define	ZOO		 7
X#define	SHOPBASE	 8
X#define	WANDSHOP	 9
X#define	GENERAL		15
END_OF_mkroom.h
if test 707 -ne `wc -c <mkroom.h`; then
    echo shar: \"mkroom.h\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f monst.h -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"monst.h\"
else
echo shar: Extracting \"monst.h\" \(2190 characters\)
sed "s/^X//" >monst.h <<'END_OF_monst.h'
X/*	SCCS Id: @(#)monst.h	1.3	87/07/14
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* monst.h - version 1.0.2 */
X
Xstruct monst {
X	struct monst *nmon;
X	struct permonst *data;
X	unsigned m_id;
X	xchar mx,my;
X	xchar mdx,mdy;		/* if mdispl then pos where last displayed */
X#define	MTSZ	4
X	coord mtrack[MTSZ];	/* monster track */
X	schar mhp,mhpmax;
X	char mappearance;	/* nonzero for undetected 'M's and for '1's */
X	Bitfield(mimic,1);	/* undetected mimic */
X	Bitfield(mdispl,1);	/* mdx,mdy valid */
X	Bitfield(minvis,1);	/* invisible */
X	Bitfield(cham,1);	/* shape-changer */
X	Bitfield(mhide,1);	/* hides beneath objects */
X	Bitfield(mundetected,1);	/* not seen in present hiding place */
X	Bitfield(mspeed,2);
X	Bitfield(msleep,1);
X	Bitfield(mfroz,1);
X	Bitfield(mconf,1);
X	Bitfield(mflee,1);	/* fleeing */
X	Bitfield(mfleetim,7);	/* timeout for mflee */
X	Bitfield(mcan,1);	/* has been cancelled */
X	Bitfield(mtame,1);	/* implies peaceful */
X	Bitfield(mpeaceful,1);	/* does not attack unprovoked */
X	Bitfield(isshk,1);	/* is shopkeeper */
X	Bitfield(isgd,1);	/* is guard */
X	Bitfield(mcansee,1);	/* cansee 1, temp.blinded 0, blind 0 */
X	Bitfield(mblinded,7);	/* cansee 0, temp.blinded n, blind 0 */
X	Bitfield(mtrapped,1);	/* trapped in a pit or bear trap */
X	Bitfield(mnamelth,6);	/* length of name (following mxlth) */
X#ifndef NOWORM
X	Bitfield(wormno,5);	/* at most 31 worms on any level */
X#endif
X#ifdef WALKIES
X	Bitfield(mleashed,1);	/* monster is on a leash */
X#endif
X	long mtrapseen;		/* bitmap of traps we've been trapped in */
X	long mlstmv;		/* prevent two moves at once */
X	struct obj *minvent;
X	long mgold;
X	unsigned mxlth;		/* length of following data */
X	/* in order to prevent alignment problems mextra should
X	   be (or follow) a long int */
X	long mextra[1];		/* monster dependent info */
X};
X
X#define newmonst(xl)	(struct monst *) alloc((unsigned)(xl) + sizeof(struct monst))
X
Xextern struct monst *fmon;
Xextern struct monst *fallen_down;
Xstruct monst *m_at();
X
X/* these are in mspeed */
X#define MSLOW 1 /* slow monster */
X#define MFAST 2 /* speeded monster */
X
X#define	NAME(mtmp)	(((char *) mtmp->mextra) + mtmp->mxlth)
X#define	MREGEN		"TVi1"
X#define	UNDEAD		"ZVW "
END_OF_monst.h
if test 2190 -ne `wc -c <monst.h`; then
    echo shar: \"monst.h\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f msdos.h -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"msdos.h\"
else
echo shar: Extracting \"msdos.h\" \(1203 characters\)
sed "s/^X//" >msdos.h <<'END_OF_msdos.h'
X/*	SCCS Id: @(#)msdos.h	1.3	87/07/14
X/* msdos.h - function declarations for msdos.c */
X
Xextern char *alllevels, *allbones;
Xextern char levels[], bones[], permbones[], SAVEF[], hackdir[];
Xextern int ramdisk, count_only;
X
X#define CTRL(ch) (ch & 0x37)
X#define ABORT CTRL('A')
X#define COUNT 0x1
X#define WRITE 0x2
X
X#ifdef LINT_ARGS		/* arg. checking enabled */
X
Xvoid	append_slash(char *);
Xvoid	chdrive(char *);
Xint	check_then_creat(char *, int);
Xvoid	copybones(int);
Xint	dosh();
Xint	dotogglepickup();
Xlong	filesize(char *);
Xvoid	flushout();
Xlong	freediskspace(char *);
Xvoid	gameDiskPrompt();
Xchar *	getlogin();
Xvoid	getreturn(char *);
Xchar *	getenv();
Xint	getuid();
Xchar *	let_to_name(char);
Xvoid	msexit(int);
Xvoid	msmsg(char *, );
Xvoid	name_file(char *, int);
Xvoid	pushch(char);
Xvoid	read_config_file();
X#ifdef DGK
Xint	savelev(int, xchar, int);
X#endif
Xint	saveDiskPrompt(int);
Xvoid	set_lock_and_bones();
Xint	tgetch();
X
X#else
X
Xextern long	filesize(), freediskspace();
Xextern char	*getlogin(), *let_to_name();
Xextern void	append_slash(), chdrive(), copybones();
Xextern void	gameDiskPrompt(), getreturn(), msexit(), msmsg(), name_file();
Xextern void	pushch(), read_config_file(), set_lock_and_bones();
X
X#endif
END_OF_msdos.h
if test 1203 -ne `wc -c <msdos.h`; then
    echo shar: \"msdos.h\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f nansi.sys.uu -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"nansi.sys.uu\"
else
echo shar: Extracting \"nansi.sys.uu\" \(3479 characters\)
sed "s/^X//" >nansi.sys.uu <<'END_OF_nansi.sys.uu'
Xbegin 644 ./nansi.sys.uu
XM_____Q.`RP#6`$-/3B`@("`@&ULR2DYA;G-I+G-Y<R!V,BXR.B!.97<@04Y3
XM22!D<FEV97(@*$,I($1A;FEE;"!+96=E;"P@4&%S861E;F$L($-!(#$Y.#8-
XM"AH``````0```QA/```````'```````````````#````````````6QL``'@`
XM````````=P``````H64`B]BT`)**Q[0`*]!"BL/^P/8F9P`"QX#4``/`E\-P
XM"2,!(P$?`28!-0%)`50!F`&8`2,!(P$NB1Y<`"Z,!EX`R_M04U%25597'@8N
XMQ1Y<`(I'`L1W#HM/$CP,=R"3T>.,R([8_Y>S`"[%'EP`#0`!B4<#!Q]?7EU:
XM65M8R^@*`.OF+L<&BP`!`,^X$PC#,\##XPJ+_E'HXP)9JN+X,\##Z",#=`O%
XM'EP`B$<-,\#K`[@``L/H#P.X``)T`C/`PS/`HX,`HX<`HXL`HX\`N$``CL`F
XMH1H`)J,<`#/`PP#['@904U%25597N0$`C,N.PX[;OG(!B`3H"@!?7EU:65M8
XM!Q_/C`9O`+A``([8H4D`+J)C`/[,+H@F90"@8@"8`\"3BX=0`"ZC9@"A8P`N
XMHW,`H4X`T>C1Z-'HT>B`Q+`N@#YC``=T`X#$"`X?HVT`CL#HJ_[H%`%R`^B?
XM`8L>=0"*)FL`CAYO`/SC(RZ#/F$``'50Z/4`<@/I#`&L/!QR(B[7JTK@]70$
XMZP3@YW1HC,B.V*!E`/[`*L*B9@#H+0$SP,,\&W0:/`UT+SP*=&`\"70+/`AT
XM$#P'=!CIP@#K>9#II`+IE`(N.A9E`'<#3T]"Z[CH(@(*P.NQ+J!E`/[`*L*T
XM`"OX*_@NBA9E`$(NBB9K``P!ZY1!+O8&8``!=05/3T+KABZ*%F4`0BOZ*_HN
XMH&0`+C@&9P!R!>@%`>L0+OX&9P`NH&4`M`!``\`#^"Z*)FL`#`'I4O\NH&4`
XM_L`JPE&U`(K(@.$']MF`P0@KT9RP(.@6`','\ZN=6>DL_P/1Z#P`2N+ZG5GI
XM'_\N@#YC``1R"BZ`/F,`!W0"^,/YP^CI_W,(Z?G^K#P<<@TNU^@.`$K@\W0&
XMZ?7^Z0;_Z5?_4E%34"Z@90#^P"K"+J)F`"Z+%F8`,]NT`LT0N0$`6%"*W+<`
XMM`G-$%A;65K#Z)S_<RJ+W]'KBQ9S`+`.[NL`0HK'[NL`2K`/[NL`0HK#[KA`
XM`([8+J%F`*-0`,.X%H_HGO_#M`#H9/]S%RZ*)FL`@.1_+H`^8P`'=0>`_`%U
XM`K0'PU!345+HVO^*_+`!M`:Q`+4`+HH690`NBC9D`,T06EE;6,.+-N`$"L!T
XM`K0`.S;>!'8.BPP[1/YT"X/N!"OQZ^P+]NL'@^X"*_$ZP,.Y!`"[?P"#PP2+
XM-POVX??#Z.W_="G_#TZ+;P(^B@*#[@%R&8'[@P!T$PK`=0__#SZ*(L<&@P`!
XM`(@F>`#K&[0`S18+P'3XZ(W_=0J)#H\`B3:1`.N[/`!TV</HH_]T"4Z+;P(^
XMB@+K&K0!S19T%PO`=0:T`,T6Z_#H6_]U!0/QBD3_@,P!PQ0%`P!04U%25597
XML+:Z0P#N2BZAAP3K`.Z&X.L`[KIA`.L`[%`,`^L`[@:X0`".P":+'FP`+@,>
XMB02Y__\FH6P`.\-_`N+V!U@D_.Y?7EU:65M8PP``,#`P,#`NB1YQ`"ZC80#I
XM-/TNBQYQ`"[_)F$`Z9D`X@6X`@7KX*P\6W7Q+HL>W`0NQ@<`+L8&VP0`X@6X
XM'07KQ:P\/70'/#]T`T[K!^(%N#`%Z[*L/#!R%CPY=Q(L,"Z(!R[&!ML$`>)B
XMN*@%ZY<\(G0$/"=U="ZB:@#B!;A>!>N$K"XZ!FH`=!,NB`<N.Q[>!(/3`.+K
XMN%X%Z6G_+L8'`.(&N(4%Z5W_K#P[=`)!3N*BN#`%Z4[_+L<&80```"Z*)FL`
XM+HL>=0#I:_VL/#!R&CPY=Q8L,"Z&!U*R"O;B6BX`!^+GN*@%Z1O_/#MU$"X[
XM'MX$@],`+L8&VP0`ZYX\0'*U/'IWL3Q:=@8\87*I+`9641X.'RQ`F`/`!44&
XMB\LNBS;<!"O.+O8&VP0!=`%!DZ!E`$`JPJ)F`+0`K`K`=0%`_Q<?65XNBB9K
XM`"Z+'G4`+L<&80````O2Z>7[U`H%,#"&X*J&X*K#30@`!_H&YP;M!J\&KP:O
XM!K`&KP9/!T8'(P@?"*\&KP91"*\&KP:O!J\&KP:O!J\&KP:O!J\&KP:O!J\&
XMKP:O!K`&KP:2"*\&KP:O!@H)'`=S!Z\&J`>O!J\&#0>O!A0'KP:O!J\&#@FO
XM!L,*P'0!2*)G`#/`@_D"<@:L"L!T`4BB9@"A9@`Z!F4`=@:@90"B9@`Z)F0`
XM=@:@9`"B9P#HK?G#``9F`.O;*`9F`',%Q@9F``#KS@`&9P#KR"@&9P!S!<8&
XM9P``Z[NA9@"C:`##H6@`HV8`ZZQ."\EU!,8$`$&L4;D6`)"[*PF#PP,Z!^#Y
XM=0N+1P$@!FL`""9K`%GBX,-2BPYF`(KUZQ0\`G4?QP9F````Z#?Y4C/)BC9D
XM`.@P_(K\BA9E`+@`!LT06L-74@:,R([`_;^``*!G`/[`Z+/^L#NJH&8`_L#H
XMJ/ZP4JJP#8D^B0"JN((`*\>CAP#\!UI?PPO)=%G\3DE)K0K`=`)!3E<&45;]
XM'@?H%OQU%H/!!(LNW@0!#MX$3HO^`_F+SBO-\Z1>68L^W@2#[P2+WRO9@^L0
XM.Q[<!'(2B4T#B44!XP:D@\8"XOJ)/MX$!U_\PP8>!_V+/N`$N`$`J[@`<JNP
XM$*J)/MX$!^ODM`;K`K0'BCYD`"H^9P`ZQW8"L`!0Z%_[BOQ8L0"*+F<`4HH6
XM90"*-F0`S1!:P[4!ZP*U`.BI^G,Y.L)V`HK"5Y&+Z;4`B_<#\0/Q]MD"RK4`
XM_/;$`70,A_[]B\%(`\`#^`/P!A_SI8O-Z`O[L"#SJ_Q?P['_/`=U!H@.8`#K
XM:SPK=4*T$KL0_\T0]\/\_G5:Z$WZ<U6T`*!C`,T0N!(1LP#-$+@`$K,@S1"T
XM`;D'!\T0BQ9S`+`*[NL`0K`'[L8&9``JZPFT`,T0Q@9D`!BX0``>CMBA20`?
XMHF,`_LR()F4`QP9F````Z(KWP[$`ZX:+'G4`XP].K4EU`HK@`MB`UP"()\,S
XMP(@'0_[`=?GK]```!P'_"`3X`07_@`?X<`B(`![X`!_X!"#X`B'X!B+X`2/X
XM!23X`R7X!RB/`"F/0"J/("N/8"R/$"V/4"Z/,"^/<#/`CMB[;`#'!Q<!C$\"
XMNZ0`QP=S`8Q/`@X?#@?\OW`)B3[<!(''``*)/MX$1[`0JK@`<JNX`0")/N`$
X9JXD^=0`SP*K^P'7[,\#%-EP`B7P.C$P0PP*)
X`
Xend
END_OF_nansi.sys.uu
if test 3479 -ne `wc -c <nansi.sys.uu`; then
    echo shar: \"nansi.sys.uu\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f nethack.sh -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"nethack.sh\"
else
echo shar: Extracting \"nethack.sh\" \(219 characters\)
sed "s/^X//" >nethack.sh <<'END_OF_nethack.sh'
X#!/bin/sh
X#	SCCS Id: @(#)nethack.sh	1.3	87/07/14
XHACKDIR=/usr/games/lib/nethackdir
XHACK=$HACKDIR/nethack
XMAXNROFPLAYERS=4
X
Xcd $HACKDIR
Xcase $1 in
X	-s*)
X		exec $HACK $@
X		;;
X	*)
X		exec $HACK $@ $MAXNROFPLAYERS
X		;;
Xesac
END_OF_nethack.sh
if test 219 -ne `wc -c <nethack.sh`; then
    echo shar: \"nethack.sh\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f netquest.sh -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"netquest.sh\"
else
echo shar: Extracting \"netquest.sh\" \(224 characters\)
sed "s/^X//" >netquest.sh <<'END_OF_netquest.sh'
X#!/bin/sh
X#	SCCS Id: @(#)netquest.sh	1.3	87/07/14
XQUESTDIR=/usr/games/lib/questdir
XQUEST=$HACKDIR/netquest
XMAXNROFPLAYERS=4
X
Xcd $QUESTDIR
Xcase $1 in
X	-s*)
X		exec $QUEST $@
X		;;
X	*)
X		exec $QUEST $@ $MAXNROFPLAYERS
X		;;
Xesac
END_OF_netquest.sh
if test 224 -ne `wc -c <netquest.sh`; then
    echo shar: \"netquest.sh\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f obj.h -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"obj.h\"
else
echo shar: Extracting \"obj.h\" \(1655 characters\)
sed "s/^X//" >obj.h <<'END_OF_obj.h'
X/*	SCCS Id: @(#)obj.h	1.3	87/07/14
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* obj.h - version 1.0.3 */
X
X#ifndef OBJ_H
X#define OBJ_H
X
Xstruct obj {
X	struct obj *nobj;
X	unsigned o_id;
X	unsigned o_cnt_id;		/* id of container object is in */
X	xchar ox,oy;
X	xchar odx,ody;
X	unsigned otyp;
X#ifdef DGK
X	unsigned int	owt;
X	unsigned int	quan;
X#else
X	uchar owt;
X	uchar quan;		/* use oextra for tmp gold objects */
X#endif
X	schar spe;		/* quality of weapon, armor or ring (+ or -)
X				   number of charges for wand ( >= -1 )
X				   special for uball and amulet %% BAH */
X	char olet;
X	char invlet;
X	Bitfield(oinvis,1);	/* not yet implemented */
X	Bitfield(odispl,1);
X	Bitfield(known,1);	/* exact nature known */
X	Bitfield(dknown,1);	/* color or text known */
X	Bitfield(cursed,1);
X	Bitfield(unpaid,1);	/* on some bill */
X	Bitfield(rustfree,1);
X	Bitfield(no_charge, 1);	/* if shk shouldn't charge for this */
X	Bitfield(onamelth,6);
X	long age;		/* creation date */
X	long owornmask;
X#define	W_ARM	01L
X#define	W_ARM2	02L
X#define	W_ARMH	04L
X#define	W_ARMS	010L
X#define	W_ARMG	020L
X#define	W_ARMOR		(W_ARM | W_ARM2 | W_ARMH | W_ARMS | W_ARMG)
X#define	W_RINGL	010000L	/* make W_RINGL = RING_LEFT (see uprop) */
X#define	W_RINGR	020000L
X#define	W_RING		(W_RINGL | W_RINGR)
X#define	W_WEP	01000L
X#define	W_BALL	02000L
X#define	W_CHAIN	04000L
X	long oextra[1];		/* used for name of ordinary objects - length
X				   is flexible; amount for tmp gold objects */
X};
X
Xextern struct obj *fobj;
X
X#define newobj(xl)	(struct obj *) alloc((unsigned)(xl) + sizeof(struct obj))
X#define	ONAME(otmp)	((char *) otmp->oextra)
X#define	OGOLD(otmp)	(otmp->oextra[0])
X
X#endif
END_OF_obj.h
if test 1655 -ne `wc -c <obj.h`; then
    echo shar: \"obj.h\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f objclass.h -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"objclass.h\"
else
echo shar: Extracting \"objclass.h\" \(2176 characters\)
sed "s/^X//" >objclass.h <<'END_OF_objclass.h'
X/*	SCCS Id: @(#)objclass.h	1.3	87/07/14
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* objclass.h - version 1.0.3 */
X
X/* definition of a class of objects */
X
Xstruct objclass {
X	char *oc_name;		/* actual name */
X	char *oc_descr;		/* description when name unknown */
X	char *oc_uname;		/* called by user */
X	Bitfield(oc_name_known,1);
X	Bitfield(oc_merge,1);	/* merge otherwise equal objects */
X	char oc_olet;
X	schar oc_prob;		/* probability for mkobj() */
X	schar oc_delay;		/* delay when using such an object */
X	uchar oc_weight;
X	schar oc_oc1, oc_oc2;
X	int oc_oi;
X#define	nutrition	oc_oi	/* for foods */
X#define	a_ac		oc_oc1	/* for armors - only used in ARM_BONUS */
X#define ARM_BONUS(obj)	((10 - objects[obj->otyp].a_ac) + obj->spe)
X#define	a_can		oc_oc2	/* for armors */
X#define bits		oc_oc1	/* for wands and rings */
X				/* wands */
X#define		NODIR		1
X#define		IMMEDIATE	2
X#define		RAY		4
X				/* rings */
X#define		SPEC		1	/* +n is meaningful */
X  /* Check the AD&D rules!  The FIRST is small monster damage. */
X#define	wsdam		oc_oc1	/* for weapons and PICK_AXE */
X#define	wldam		oc_oc2	/* for weapons and PICK_AXE */
X
X#define	g_val		oc_oi	/* for gems: value on exit */
X#ifdef MSDOS
X	int oc_descr_i;		/* where the description comes from */
X#endif
X#ifdef SPELLS
X#define spl_lev		oc_oi	/* for books: spell level */
X#endif
X};
X
Xextern struct objclass objects[];
X
X/* definitions of all object-symbols */
X
X#define	ILLOBJ_SYM	'\\'
X#define	AMULET_SYM	'"'
X#define	FOOD_SYM	'%'
X#define	WEAPON_SYM	')'
X#define	TOOL_SYM	'('
X#define	BALL_SYM	'0'
X#define	CHAIN_SYM	'_'
X#define	ROCK_SYM	'`'
X#define	ARMOR_SYM	'['
X#define	POTION_SYM	'!'
X#define	SCROLL_SYM	'?'
X#define	WAND_SYM	'/'
X#define	RING_SYM	'='
X#define	GEM_SYM		'*'
X#ifdef SPELLS
X#define	SPBOOK_SYM	'+'	/* actually SPELL-book */
X#endif
X/* Other places with explicit knowledge of object symbols:
X * ....shk.c:	char shtypes[] = "=/)%?![";
X * mklev.c:	"=/)%?![<>+"
X * mkobj.c:	char mkobjstr[] = "))[[!!!!????%%%%/=**+";
X * apply.c:   otmp = getobj("0#%", "put in");
X * eat.c:     otmp = getobj("%", "eat");
X * invent.c:          if(index("!%?[)=*(0/+\"", sym)){
X * invent.c:    || index("%?!*+",otmp->olet))){
X */
END_OF_objclass.h
if test 2176 -ne `wc -c <objclass.h`; then
    echo shar: \"objclass.h\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f pcunix.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"pcunix.c\"
else
echo shar: Extracting \"pcunix.c\" \(1850 characters\)
sed "s/^X//" >pcunix.c <<'END_OF_pcunix.c'
X/*	SCCS Id: @(#)pcunix.c	1.3	87/07/14
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* unix.c - version 1.0.3 */
X
X/* This file collects some Unix dependencies; pager.c contains some more */
X
X/*
X * The time is used for:
X *	- seed for rand()
X *	- year on tombstone and yymmdd in record file
X *	- phase of the moon (various monsters react to NEW_MOON or FULL_MOON)
X *	- night and midnight (the undead are dangerous at midnight)
X *	- determination of what files are "very old"
X */
X
X#include "hack.h"	/* mainly for index() which depends on BSD */
X
X#include	<sys/types.h>		/* for time_t */
X#include	<time.h>
X
Xextern time_t time();
X
Xsetrandom()
X{
X	(void) srand((int) time ((time_t *) 0));
X}
X
Xstruct tm *
Xgetlt()
X{
X	time_t date;
X	struct tm *localtime();
X
X	(void) time(&date);
X	return(localtime(&date));
X}
X
Xgetyear()
X{
X	return(1900 + getlt()->tm_year);
X}
X
Xchar *
Xgetdate()
X{
X	static char datestr[7];
X	register struct tm *lt = getlt();
X
X	(void) sprintf(datestr, "%2d%2d%2d",
X		lt->tm_year, lt->tm_mon + 1, lt->tm_mday);
X	if(datestr[2] == ' ') datestr[2] = '0';
X	if(datestr[4] == ' ') datestr[4] = '0';
X	return(datestr);
X}
X
Xphase_of_the_moon()			/* 0-7, with 0: new, 4: full */
X{					/* moon period: 29.5306 days */
X					/* year: 365.2422 days */
X	register struct tm *lt = getlt();
X	register int epact, diy, golden;
X
X	diy = lt->tm_yday;
X	golden = (lt->tm_year % 19) + 1;
X	epact = (11 * golden + 18) % 30;
X	if ((epact == 25 && golden > 11) || epact == 24)
X		epact++;
X
X	return( (((((diy + epact) * 6) + 11) % 177) / 22) & 7 );
X}
X
Xnight()
X{
X	register int hour = getlt()->tm_hour;
X
X	return(hour < 6 || hour > 21);
X}
X
Xmidnight()
X{
X	return(getlt()->tm_hour == 0);
X}
X
Xregularize(s)	/* normalize file name - we don't like ..'s or /'s */
Xregister char *s;
X{
X	register char *lp;
X
X	while((lp = index(s, '.')) || (lp = index(s, '/')))
X		*lp = '_';
X}
END_OF_pcunix.c
if test 1850 -ne `wc -c <pcunix.c`; then
    echo shar: \"pcunix.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f permonst.h -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"permonst.h\"
else
echo shar: Extracting \"permonst.h\" \(1206 characters\)
sed "s/^X//" >permonst.h <<'END_OF_permonst.h'
X/*	SCCS Id: @(#)permonst.h	1.3	87/07/14
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* permonst.h - version 1.0.2 */
X
Xstruct permonst {
X	char *mname,mlet;
X	schar mlevel,mmove,ac,mr,damn,damd;
X	unsigned pxlth;
X};
X
Xextern struct permonst mons[];
X#define PM_GNOME	&mons[1]
X#define PM_HOBGOBLIN	&mons[2]
X#ifndef KOPS
X#define PM_KOBOLD	&mons[4]
X#endif
X#define PM_ACID_BLOB	&mons[7]
X#ifdef ROCKMOLE
X#define PM_ORC		&mons[10]
X#define	PM_ZOMBIE	&mons[12]
X#else
X#define PM_ORC		&mons[11]
X#define	PM_ZOMBIE	&mons[13]
X#endif
X#define	PM_PIERCER	&mons[17]
X#define PM_CENTAUR	&mons[22]
X#define	PM_KILLER_BEE	&mons[26]
X#ifdef SPIDERS
X#define PM_SPIDER	&mons[31]
X#endif
X#define	PM_WRAITH	&mons[33]
X#define	PM_MIMIC	&mons[37]
X#define PM_TROLL	&mons[38]
X#define	PM_VAMPIRE	&mons[43]
X#define PM_XORN		&mons[44]
X#define	PM_CHAMELEON	&mons[47]
X#define PM_DRAGON	&mons[48]
X#define PM_ETTIN	&mons[49]
X/* The ones below changed to include giants. */
X#define	PM_DEMON	&mons[55]
X#define	PM_MINOTAUR	&mons[56]	/* last in mons array */
X#define	PM_SHK		&mons[57]	/* very last */
X#define	PM_GHOST	&pm_ghost
X#define	PM_EEL		&pm_eel
X#define	PM_WIZARD	&pm_wizard
X#define	CMNUM		56		/* number of common monsters */
END_OF_permonst.h
if test 1206 -ne `wc -c <permonst.h`; then
    echo shar: \"permonst.h\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f rip.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"rip.c\"
else
echo shar: Extracting \"rip.c\" \(1965 characters\)
sed "s/^X//" >rip.c <<'END_OF_rip.c'
X/*	SCCS Id: @(#)rip.c	1.3	87/07/14
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* hack.rip.c - version 1.0.2 */
X
X#include <stdio.h>
X#include "hack.h"
X
Xextern char plname[];
X
Xstatic char *rip[] = {
X"                       ----------",
X"                      /          \\",
X"                     /    REST    \\",
X"                    /      IN      \\",
X"                   /     PEACE      \\",
X"                  /                  \\",
X"                  |                  |",
X"                  |                  |",
X"                  |                  |",
X"                  |                  |",
X"                  |                  |",
X"                  |       1001       |",
X"                 *|     *  *  *      | *",
X"        _________)/\\\\_//(\\/(/\\)/\\//\\/|_)_______\n",
X0
X};
X
Xoutrip(){
X	register char **dp = rip;
X	register char *dpx;
X	char buf[BUFSZ];
X	register x,y;
X
X	cls();
X	(void) strcpy(buf, plname);
X	buf[16] = 0;
X	center(6, buf);
X	(void) sprintf(buf, "%ld AU", u.ugold);
X	center(7, buf);
X	(void) sprintf(buf, "killed by%s",
X		!strncmp(killer, "the ", 4) ? "" :
X		!strcmp(killer, "starvation") ? "" :
X		index(vowels, *killer) ? " an" : " a");
X	center(8, buf);
X	(void) strcpy(buf, killer);
X	if(strlen(buf) > 16) {
X	    register int i,i0,i1;
X		i0 = i1 = 0;
X		for(i = 0; i <= 16; i++)
X			if(buf[i] == ' ') i0 = i, i1 = i+1;
X		if(!i0) i0 = i1 = 16;
X		buf[i1 + 16] = 0;
X		center(10, buf+i1);
X		buf[i0] = 0;
X	}
X	center(9, buf);
X	(void) sprintf(buf, "%4d", getyear());
X	center(11, buf);
X	for(y=8; *dp; y++,dp++){
X		x = 0;
X		dpx = *dp;
X		while(dpx[x]) {
X			while(dpx[x] == ' ') x++;
X			curs(x,y);
X			while(dpx[x] && dpx[x] != ' '){
X				extern int done_stopprint;
X				if(done_stopprint)
X					return;
X				curx++;
X				(void) putchar(dpx[x++]);
X			}
X		}
X	}
X	getret();
X}
X
Xcenter(line, text) int line; char *text; {
Xregister char *ip,*op;
X	ip = text;
X	op = &rip[line][28 - ((strlen(text)+1)/2)];
X	while(*ip) *op++ = *ip++;
X}
END_OF_rip.c
if test 1965 -ne `wc -c <rip.c`; then
    echo shar: \"rip.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f rm.h -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"rm.h\"
else
echo shar: Extracting \"rm.h\" \(1904 characters\)
sed "s/^X//" >rm.h <<'END_OF_rm.h'
X/*	SCCS Id: @(#)rm.h	1.3	87/07/14
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* rm.h - version 1.0.2 */
X
X/* Level location types */
X#define	HWALL 1
X#define	VWALL 2
X#define	SDOOR 3
X#define	SCORR 4
X#define	LDOOR 5
X#define	POOL	6	/* not yet fully implemented */
X			/* this should in fact be a bit like lit */
X#define	DOOR 7
X#define	CORR 8
X#define	ROOM 9
X#define	STAIRS 10
X#define FOUNTAIN 11
X#define THRONE 12
X
X/*
X * Avoid using the level types in inequalities:
X *  these types are subject to change.
X * Instead, use one of the macros below.
X */
X#define	IS_WALL(typ)	((typ) <= VWALL)
X#define IS_ROCK(typ)	((typ) < POOL)		/* absolutely nonaccessible */
X#define	ACCESSIBLE(typ)	((typ) >= DOOR)			/* good position */
X#define	IS_ROOM(typ)		((typ) >= ROOM)		/* ROOM or STAIRS */
X#define	ZAP_POS(typ)		((typ) > DOOR)
X#define IS_POOL(typ)    ((typ) == POOL)
X#define IS_THRONE(typ)    ((typ) == THRONE)
X#define IS_FOUNTAIN(typ)        ((typ) == FOUNTAIN)
X
X/*
X * A few of the associated symbols are not hardwired.
X */
X#ifdef QUEST
X#define	CORR_SYM	':'
X#else
X#define	CORR_SYM	'#'
X#endif
X#define	POOL_SYM	'}'
X#define FOUNTAIN_SYM    '{'
X#define THRONE_SYM      '\\'
X#define WEB_SYM         '"'
X#define DOOR_SYM	'+'
X
X#define	ERRCHAR	']'
X
X/*
X * The structure describing a coordinate position.
X * Before adding fields, remember that this will significantly affect
X * the size of temporary files and save files.
X */
X#ifdef MSDOS
X/* Save disk space by using unsigned char's instead of unsigned ints
X */
Xstruct rm {
X	uchar scrsym;
X	uchar typ:5;
X	uchar new:1;
X	uchar seen:1;
X	uchar lit:1;
X};
X#else
Xstruct rm {
X	char scrsym;
X	Bitfield(typ,5);
X	Bitfield(new,1);
X	Bitfield(seen,1);
X	Bitfield(lit,1);
X};
X#endif /* MSDOS /**/
Xextern struct rm levl[COLNO][ROWNO];
X
X#ifdef DGK
X#define ACTIVE	1
X#define SWAPPED	2
X
Xstruct finfo {
X	int	where;
X	long	time;
X	long	size;
X};
Xextern struct finfo fileinfo[];
X#endif
END_OF_rm.h
if test 1904 -ne `wc -c <rm.h`; then
    echo shar: \"rm.h\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f rnd.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"rnd.c\"
else
echo shar: Extracting \"rnd.c\" \(419 characters\)
sed "s/^X//" >rnd.c <<'END_OF_rnd.c'
X/*	SCCS Id: @(#)rnd.c	1.3	87/07/14
X/* rnd.c - version 1.0.2 */
X
X#define RND(x)	((rand()>>3) % x)
X
Xrn1(x,y)	/* y <= rn1(x,y) < (y+x) */ 
Xregister x,y;
X{
X	return(RND(x)+y);
X}
X
Xrn2(x)		/* 0 <= rn2(x) < x */
Xregister x;
X{
X	return(RND(x));
X}
X
Xrnd(x)		/* 1 <= rnd(x) <= x */
Xregister x;
X{
X	return(RND(x)+1);
X}
X
Xd(n,x)		/* n <= d(n,x) <= (n*x) */
Xregister n,x;
X{
X	register tmp = n;
X
X	while(n--) tmp += RND(x);
X	return(tmp);
X}
END_OF_rnd.c
if test 419 -ne `wc -c <rnd.c`; then
    echo shar: \"rnd.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f rumors.mrx -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"rumors.mrx\"
else
echo shar: Extracting \"rumors.mrx\" \(1861 characters\)
sed "s/^X//" >rumors.mrx <<'END_OF_rumors.mrx'
XA Ninja is very stealthy.
XA Ninja knows how to backstab.
XA Ninja knows how to throw things.
XA Ninja knows how to use poison.
XA Priest can get the Gods to listen easily.
XA Priest can go to hell just like the rest of us.
XA Priest and a virgin you might be, but that unicorn won't care.
XA Priestess may be a virgin; then again...
XA Priestess may be a virgin, but who would believe that???
XA Samurai is fast on his feet.
XA Samurai is very good with a katana.
XA Samurai is just a fighter with a bent sword.
XA katana might cut a demon.
XA katana might slice a worm in two.
XDemon-lords are greedy.
XDemon-princes have very bad tempers.
XDemons *HATE* Priests and Priestesses.
XDemons are one thing, Demon-lords, on the other hand...
XGods expect the best from their priesthood.
XGods look down their noses at demi-gods.
XHave you been a demi-god yet?
XHave you ever seen a Demon-prince?
XHELL is a four letter word.
XIf you kill the wizard, you get promoted to demi-god.
XIf you're a Samurai, you must obey the Mikado.
XIf you're a Ninja, don't let the Mikado see you.
XKatanas are very sharp, watch you don't cut yourself.
XMulti-player Hack is a myth.
XNetHack is a fantasy, in fact you're dreaming.
XNetHack is addictive.  Too late, you're already hooked.
XOrcs go around poisoning the spikes in pits!
XSomeone has been spiking the pits.
XThe Gods don't appreciate pesky priesthood.
XThe Gods don't like competition.
XThe wizard gets quite an experience out of death.
XTry calling your katana Moulinette.
XTry calling your katana Snikersnee.
XWatch out for pits with spikes in them!
XWatch out, that piercer might have gotten back up on the ceiling.
XWatch out, the mimic may hide again.
XWatch out, the wizard might come back.
XWhat does a Demon-prince look like, anyway?
XWhat is this demi-god stuff anyway?
XYou might be able to bribe a Demon-lord.
XYou might be able to bribe a Demon-prince.
END_OF_rumors.mrx
if test 1861 -ne `wc -c <rumors.mrx`; then
    echo shar: \"rumors.mrx\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f spell.h -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"spell.h\"
else
echo shar: Extracting \"spell.h\" \(254 characters\)
sed "s/^X//" >spell.h <<'END_OF_spell.h'
X/*	SCCS Id: @(#)spell.h	1.3	87/07/14
X/* def.spells.h - version 1.0.0		M. Stephenson  07-07-86 */
X
X#ifndef SPELL_H
X#define SPELL_H
X
Xstruct	spell  {
X
X	int	sp_id;			/* spell id */
X	int	sp_lev;			/* power level */
X	int	sp_flags;		/* spfx flags */
X};
X
X#endif
END_OF_spell.h
if test 254 -ne `wc -c <spell.h`; then
    echo shar: \"spell.h\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f timeout.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"timeout.c\"
else
echo shar: Extracting \"timeout.c\" \(2086 characters\)
sed "s/^X//" >timeout.c <<'END_OF_timeout.c'
X/*	SCCS Id: @(#)timeout.c	1.3	87/07/14
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* timeout.c - version 1.0.3 */
X
X#include	"hack.h"
X
Xtimeout(){
Xregister struct prop *upp;
X#ifdef KAA
Xregister struct monst *mtmp;
X#endif
X	if(Stoned) stoned_dialogue();
X#ifdef KAA
X	if(u.mtimedone) if (!--u.mtimedone) rehumanize();
X# ifdef KOPS
X	if(u.ucreamed > 0) u.ucreamed--;
X# endif
X#endif
X	for(upp = u.uprops; upp < u.uprops+SIZE(u.uprops); upp++)
X	    if((upp->p_flgs & TIMEOUT) && !(--upp->p_flgs & TIMEOUT)) {
X		if(upp->p_tofn) (*upp->p_tofn)();
X		else switch(upp - u.uprops){
X		case STONED:
X			killer = "cockatrice";
X			done("died");
X			break;
X		case SICK:
X			pline("You die because of food poisoning.");
X			killer = u.usick_cause;
X			done("died");
X			break;
X		case FAST:
X			pline("You feel yourself slowing down.");
X			break;
X		case CONFUSION:
X			if (Hallucination) pline("You feel less trippy now.");
X			else
X				pline("You feel less confused now.");
X			break;
X		case BLIND:
X			if (Hallucination) pline("Oh like wow! What a rush.");
X			else		   pline("You can see again.");
X			setsee();
X			break;
X		case INVIS:
X			on_scr(u.ux,u.uy);
X			if (!See_invisible)
X				pline("You are no longer invisible.");
X			break;
X		case WOUNDED_LEGS:
X			heal_legs();
X			break;
X#ifdef KAA
X		case HALLUCINATION:
X			pline("Everything looks SO boring now.");
X			setsee();
X			for (mtmp=fmon; mtmp; mtmp=mtmp->nmon)
X				if ((Blind && Telepat) || canseemon(mtmp))
X					atl(mtmp->mx, mtmp->my, (!mtmp->mappearance || 
X					Protection_from_shape_changers) 
X					? mtmp->data->mlet : mtmp->mappearance);
X			break;
X#endif
X		}
X	}
X}
X
X/* He is being petrified - dialogue by inmet!tower */
Xchar *stoned_texts[] = {
X	"You are slowing down.",		/* 5 */
X	"Your limbs are stiffening.",		/* 4 */
X	"Your limbs have turned to stone.",	/* 3 */
X	"You have turned to stone.",		/* 2 */
X	"You are a statue."			/* 1 */
X};
X
Xstoned_dialogue()
X{
X	register long i = (Stoned & TIMEOUT);
X
X	if(i > 0 && i <= SIZE(stoned_texts))
X		pline(stoned_texts[SIZE(stoned_texts) - i]);
X	if(i == 5)
X		Fast = 0;
X	if(i == 3)
X		nomul(-3);
X}
END_OF_timeout.c
if test 2086 -ne `wc -c <timeout.c`; then
    echo shar: \"timeout.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f track.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"track.c\"
else
echo shar: Extracting \"track.c\" \(688 characters\)
sed "s/^X//" >track.c <<'END_OF_track.c'
X/*	SCCS Id: @(#)track.c	1.3	87/07/14
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* track.c - version 1.0.2 */
X
X#include "hack.h"
X
X#define	UTSZ	50
X
Xcoord utrack[UTSZ];
Xint utcnt = 0;
Xint utpnt = 0;
X
Xinitrack(){
X	utcnt = utpnt = 0;
X}
X
X/* add to track */
Xsettrack(){
X	if(utcnt < UTSZ) utcnt++;
X	if(utpnt == UTSZ) utpnt = 0;
X	utrack[utpnt].x = u.ux;
X	utrack[utpnt].y = u.uy;
X	utpnt++;
X}
X
Xcoord *
Xgettrack(x,y) register x,y; {
Xregister int i,cnt,dist;
Xcoord tc;
X	cnt = utcnt;
X	for(i = utpnt-1; cnt--; i--){
X		if(i == -1) i = UTSZ-1;
X		tc = utrack[i];
X		dist = (x-tc.x)*(x-tc.x) + (y-tc.y)*(y-tc.y);
X		if(dist < 3)
X			return(dist ? &(utrack[i]) : 0);
X	}
X	return(0);
X}
END_OF_track.c
if test 688 -ne `wc -c <track.c`; then
    echo shar: \"track.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f version.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"version.c\"
else
echo shar: Extracting \"version.c\" \(1672 characters\)
sed "s/^X//" >version.c <<'END_OF_version.c'
X/*	SCCS Id: @(#)version.c	1.3	87/07/14
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* version.c - Usenet version 1.0 */
X
X#include	"hack.h"
X#include	"date.h"
X
Xdoversion(){
X
X#ifdef BETA
X	pline("%s Net%s Beta Version %s - last edit %s.",
X#else
X	pline("%s Net%s Version %s - last edit %s.",
X#endif
X#ifdef UNIX
X		"Unix"
X#endif
X#ifdef MSDOS
X		"PC"
X#endif
X#ifdef QUEST
X		, "Quest"
X#else
X		, "Hack"
X#endif
X		, VERSION, datestring);
X	return(0);
X}
X
X#define pg_line(x)	if(page_line(x)) goto quit;
X
XdoMSCversion()
X{
X	char	buf[BUFSZ];
X
X	set_pager(0);
X	sprintf(buf, "Behold mortal, the origins of %s Net%s...",
X#ifdef UNIX
X		"Unix"
X#endif
X#ifdef MSDOS
X		"PC"
X#endif
X#ifdef QUEST
X		, "Quest");
X#else
X		, "Hack");
X#endif
X	pg_line("");
X	pg_line(buf); pg_line(""); pg_line("");
X
X	pg_line("The original HACK was written by Jay Fenlason with help from");
X	pg_line("Kenny Woodland, Mike Thome and Jon Payne.");
X
X	pg_line("");
X	pg_line("Andries Brouwer did a major re-write and published (at least)");
X	pg_line("two versions (1.0.2 and 1.0.3) to the Usenet.");
X
X	pg_line("");
X	pg_line("PC HACK 3.51K was an MSDOS(tm) version of HACK 1.03.");
X	pg_line("The PC implementation was done in Microsoft(tm) C by Don Kneller");
X	pg_line("and modified by Ken Arromdee.");
X
X	pg_line("");
X	pg_line("PC and UNIX HACK were merged by Mike Stephenson and Ken Arromdee");
X	pg_line("incorporating many modifications and features made by the above,");
X	pg_line("as well as the following honoured hackers:");
X
X	pg_line("");
X	pg_line("        Scott R. Turner");
X	pg_line("        Gil Neiger");
X	pg_line("        Eric Backus");
X	set_pager(1);
X	return(0);
Xquit:
X	set_pager(2);
X	return(0);
X}
END_OF_version.c
if test 1672 -ne `wc -c <version.c`; then
    echo shar: \"version.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f wseg.h -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"wseg.h\"
else
echo shar: Extracting \"wseg.h\" \(311 characters\)
sed "s/^X//" >wseg.h <<'END_OF_wseg.h'
X/*	SCCS Id: @(#)wseg.h	1.3	87/07/14
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* wseg.h - version 1.0.2 */
X
X#ifndef NOWORM
X/* worm structure */
Xstruct wseg {
X	struct wseg *nseg;
X	xchar wx,wy;
X	Bitfield(wdispl,1);
X};
X
X#define newseg()	(struct wseg *) alloc(sizeof(struct wseg))
X#endif
END_OF_wseg.h
if test 311 -ne `wc -c <wseg.h`; then
    echo shar: \"wseg.h\" unpacked with wrong size!
fi
# end of overwriting check
fi
echo shar: End of archive 16 \(of 16\).
cp /dev/null ark16isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 16 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
