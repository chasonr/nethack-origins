Relay-Version: version B 2.10 5/3/83; site utzoo.UUCP
Posting-Version: version B 2.10.1 6/24/83 (MC840302); site turing.UUCP
Path: utzoo!watmath!clyde!burl!ulysses!allegra!mit-eddie!godot!harvard!seismo!mcvax!turing!play
From: play@turing.UUCP
Newsgroups: net.sources
Subject: Hack update to version 1.0.1
Message-ID: <241@turing.UUCP>
Date: Mon, 21-Jan-85 21:44:28 EST
Article-I.D.: turing.241
Posted: Mon Jan 21 21:44:28 1985
Date-Received: Wed, 23-Jan-85 06:10:47 EST
Organization: CWI, Amsterdam
Lines: 1944
Apparently-To: rnews@mcvax.LOCAL

The following is a collection of diffs describing the difference of Hack 1.0
and Hack 1.0.1. No really important bugs have been fixed, and no indispensable
extensions have been added, so you may just ignore this posting. In fact, if
you don't have the program patch then you probably should. Otherwise, just
feed this file to patch (while in the Hack source directory), and in one or
two minutes patch will have updated all sources. Then say make.

Description of the main differences:
There is a command , : pickup.
There is a command ^T : teleport.
Hack now adds "with amulet" on the list of topscorers when appropriate.
(Still no cheers, total winner, etc. It is still too easy to go down and up.)
There is an environment variable HACKOPTIONS, and a new o command.
(Now you can tell Hack e.g. that space is not a command, and that you do not
want to see a tombstone.)
The lurker above now consistently has symbol '. (It didnt do anything in 1.0.)
There is a new type of trap. There is a new hunger state FAINTED.
There are texts written in the dust with obscure meaning. (Time to refresh
your Latin.) Some pieces of code where ungrammatical texts were generated
have been corrected. I have also included the fix that was posted for
terminals without ce. (I know, it looks terrible, dont flame me.)
I have not (yet) included conditional code for SVR2 since I cannot test it,
and many people were unable to get Hack running with the SVR2 mods that were
posted.

Index: Makefile
86a87,91
> mklv.engrave.o: hack.engrave.c mklev.h
> 	rm -f mklv.engrave.c
> 	ln hack.engrave.c mklv.engrave.c
> 	cc -c $(CFLAGS) -DMKLEV mklv.engrave.c
> 	rm -f mklv.engrave.c
90c95
< 	mklv.shknam.o mklv.makemon.o mklv.makemaz.o $(GOBJ)
---
> 	mklv.shknam.o mklv.makemon.o mklv.makemaz.o mklv.engrave.o $(GOBJ)
184c189
< hack.engrave.o:  hack.h
---
> hack.engrave.o:  mklev.h hack.h
213c218
< mklev.o:  mklev.h def.trap.h savelev.h
---
> mklev.o:  mklev.h def.trap.h hack.onames.h savelev.h
Index: config.h
Prereq: 1984.
1a2
> /* config.h version 1.0.1: added definition of HELP */
12a14
> #define	HELP	"help"	/* the file containing a description of the commands */
Index: data
5a6
>  	a dark part of a room
12c13
< %	a piece of food
---
> %%	a piece of food
22a24
> `	an enormous rock
26c28
< ~	a lurker above
---
> '	a lurker above
48c50,59
< D	a dragon
---
> D	a dragon;
> 	In the West the dragon was the natural  enemy  of  man.  Although
> 	preferring to live in bleak and desolate regions, whenever it was
> 	seen among men it left in its wake a  trail  of  destruction  and
> 	disease. Yet any attempt to slay this beast was a perilous under-
> 	taking. For the dragon's assailant had to contend not  only  with
> 	clouds  of  sulphurous fumes pouring from its fire-breathing nos-
> 	trils, but also with the thrashings of its tail, the most  deadly
> 	part of its serpent-like body.
> 	[From: Mythical Beasts by Deirdre Headon (The Leprechaun Library)]
193a205
> ~	the tail of a long worm
Index: date.h
2c2
< char datestring[] = "Mon Dec 17 1984";
---
> char datestring[] = "Mon Jan 21 1985";
Index: def.gen.h
Prereq: 1984.
1c1,2
< /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1984. */
---
> /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
> /* def.gen.h version 1.0.1: added ONCE flag */
6a8,9
> 				/* 0100: ONCE only */
> #define	TRAPTYPE	037
7a11
> #define	ONCE	0100
Index: def.trap.h
Prereq: 1984.
1c1,2
< /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1984. */
---
> /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
> /* def.trap.h version 1.0.1 - added ONCE flag */
14c15,16
< /* #define SEEN 32 - trap which has been seen */
---
> /* #define SEEN 040 - trap which has been seen */
> /* #define ONCE 0100 - once only trap */
Index: hack.apply.c
Prereq: 1984.
1c1,2
< /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1984. */
---
> /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
> /* hack.apply.c version 1.0.1 - "The flash awakens %s" (riv05!a3) */
42c43
< 			pline("The flash awakens the %s.", monnam(mtmp));
---
> 			pline("The flash awakens %s.", monnam(mtmp));
Index: hack.c
Prereq: 1984.
1c1,2
< /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1984. */
---
> /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
> /* hack.c version 1.0.1 - many small and unimportant changes */
92a94,113
> getdir()
> {
> 	char buf[2];
> 	register x;
> 
> 	pline("What direction?");
> 	buf[0] = readchar();
> 	buf[1] = 0;
> 	x = movecm(buf);
> 	if(x && Confusion) confdir();
> 	return(x);
> }
> 
> confdir()
> {
> 	register x = rn2(8);
> 	u.dx = xdir[x];
> 	u.dy = ydir[x];
> }
> 
141c162,163
< 	wipe_engr_at(u.ux, u.uy, rnd(5));
---
> 	if(!u.uswallow)
> 		wipe_engr_at(u.ux, u.uy, rnd(5));
147,157c169,183
< 	if(Confusion) {
< 		do {
< 			u.dx = rn1(3,-1);
< 			u.dy = rn1(3,-1);
< 			tmpr = &levl[u.ux+u.dx][u.uy+u.dy];
< 		} while((!u.dx && !u.dy) ||
< 			!isok(u.ux+u.dx, u.uy+u.dy) || tmpr->typ < DOOR);
< 	} else tmpr = &levl[u.ux+u.dx][u.uy+u.dy];
< 	if(!isok(u.ux+u.dx, u.uy+u.dy)){
< 		nomul(0);
< 		return;
---
> 	if(u.uswallow) {
> 		u.dx = u.dy = 0;
> 		u.ux = u.ustuck->mx;
> 		u.uy = u.ustuck->my;
> 	} else {
> 		if(Confusion) {
> 			do {
> 				confdir();
> 			} while(!isok(u.ux+u.dx, u.uy+u.dy) ||
> 				levl[u.ux+u.dx][u.uy+u.dy].typ < DOOR);
> 		}
> 		if(!isok(u.ux+u.dx, u.uy+u.dy)){
> 			nomul(0);
> 			return;
> 		}
180c206
< 	if((mtmp = m_at(u.ux+u.dx,u.uy+u.dy)) || u.uswallow) {
---
> 	if(u.uswallow || (mtmp = m_at(u.ux+u.dx,u.uy+u.dy))) {
290a317
> 	tmpr = &levl[u.ux+u.dx][u.uy+u.dy];
302c329,330
< 		    (levl[rx][ry].typ == DOOR && (!u.dx || !u.dy)))) {
---
> 		    (levl[rx][ry].typ == DOOR && (!u.dx || !u.dy))) &&
> 		    !sobj_at(ENORMOUS_ROCK, rx, ry)) {
310c338
< 			    switch(gtmp->gflag & ~SEEN) {
---
> 			    switch(gtmp->gflag & TRAPTYPE) {
328c356
< 			{ static int lastmovetime;
---
> 			{ static long lastmovetime;
437a466,478
> }
> 
> dopickup(){
> 	if(!g_at(u.ux,u.uy,fgold) && !o_at(u.ux,u.uy)) {
> 		pline("There is nothing here to pick up.");
> 		return(0);
> 	}
> 	if(Levitation) {
> 		pline("You cannot reach the floor.");
> 		return(1);
> 	}
> 	pickup();
> 	return(1);
Index: hack.cmdlist.c
Prereq: 1984.
1c1,2
< /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1984. */
---
> /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
> /* hack.cmdlist.c version 1.0.1 - added '^T': dotele() and ',': dopickup() */
7c8
< int doredraw(),doredotopl(),dodrop(),dodrink(),doread(),dosearch(),
---
> int doredraw(),doredotopl(),dodrop(),dodrink(),doread(),dosearch(),dopickup(),
9c10
< dosave(),dowield(),ddoinv(),dozap(),ddocall(),dowhatis(),doengrave(),
---
> dosave(),dowield(),ddoinv(),dozap(),ddocall(),dowhatis(),doengrave(),dotele(),
20d20
< 	'\022', doredraw,
21a22,23
> 	'\022', doredraw,
> 	'\024', dotele,
68a71
> 	',', dopickup,
Index: hack.do.c
Prereq: 1984.
1c1,3
< /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1984. */
---
> /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
> /* hack.do.c version 1.0.1 - check Levitation with POT_PARALYSIS
> 			   - added flags.no_rest_on_space */
72c74,77
< 		pline("Your feet are frozen to the floor!");
---
> 		if(Levitation)
> 			pline("You are motionlessly suspended.");
> 		else
> 			pline("Your feet are frozen to the floor!");
285c290,291
< 	if(!*cmd || *cmd == 0377)
---
> 	if(!*cmd || *cmd == 0377 || (flags.no_rest_on_space && *cmd == ' ')){
> 		flags.move = 0;
286a293
> 	}
362c369
< 		execl(catmore,"more","help",(char *)0);
---
> 		execl(catmore,"more",HELP,(char *)0);
459,460c466,467
< 	if(newlevel <= 0) done("escaped");	/* in fact < 0 is impossible */
< 	if(newlevel == dlevel) return;		/* this cannot happen either */
---
> 	if(newlevel <= 0) done("escaped");    /* in fact < 0 is impossible */
> 	if(newlevel == dlevel) return;	      /* this cannot happen either */
547a555,557
> 	{ register struct monst *mtmp;
> 	  if(mtmp = m_at(u.ux, u.uy)) mnexto(mtmp);	/* riv05!a3 */
> 	}
563,564c573,574
< 	obj = getobj("#)", "throw");	/* it is also possible to throw food */
< 					/* (or jewels, or iron balls ... ) */
---
> 	obj = getobj("#)", "throw");   /* it is also possible to throw food */
> 				       /* (or jewels, or iron balls ... ) */
680c690
< 			    register int side =
---
> 			    register long side =
700,708d709
< }
< 
< getdir()
< {
< char buf[2];
< 	pline("What direction?");
< 	buf[0] = readchar();
< 	buf[1] = 0;
< 	return(movecm(buf));
Index: hack.do_name.c
Prereq: 1984.
1c1,2
< /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1984. */
---
> /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
> /* hack.do_name.c version 1.0.1 - correction in call of xname() */
152a154
> 	struct obj otemp;
155c157
< 	register char *str = xname(obj);
---
> 	register char *str;
156a159,161
> 	otemp = *obj;
> 	otemp.quan = 1;
> 	str = xname(&otemp);
172c177,180
< 	if(mtmp->mnamelth && !vb) return(NAME(mtmp));
---
> 	if(mtmp->mnamelth && !vb) {
> 		(void) strcpy(buf, NAME(mtmp));
> 		return(buf);
> 	}
Index: hack.do_wear.c
Prereq: 1984.
1c1,2
< /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1984. */
---
> /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
> /* hack.do_wear.c version 1.0.1 - changed an int to long */
214c215
< register unsigned mask;
---
> register long mask;
Index: hack.dog.c
Prereq: 1984.
1c1,2
< /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1984. */
---
> /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
> /* hack.dog.c version 1.0.1 - "You feel worried about %s." (Adri Verhoef) */
135c136
< 		else	pline("You feel worried about your %s.", monnam(mtmp));
---
> 		else	pline("You feel worried about %s.", monnam(mtmp));
305c306,307
< 			edog->eattime = moves + objects[obj->otyp].oc_delay;
---
> 			edog->eattime =
> 			    moves + obj->quan * objects[obj->otyp].oc_delay;
307c309
< 				moves + 5*objects[obj->otyp].nutrition;
---
> 			    moves + 5*obj->quan * objects[obj->otyp].nutrition;
310c312
< 				pline("%s ate %s.", Monnam(mtmp), doname(obj));
---
> 			    pline("%s ate %s.", Monnam(mtmp), doname(obj));
378c380
< 	if(mtmp->mtame ||
---
> 	if(mtmp->mtame || mtmp->mfroz ||
Index: hack.eat.c
Prereq: 1984.
1c1,2
< /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1984. */
---
> /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
> /* hack.eat.c version 1.0.1 - added morehungry() and FAINTED */
13a15,16
> #define FAINTED		5
> #define STARVED		6
15c18
< char *hu_stat[5] = {
---
> char *hu_stat[] = {
20c23,25
< 	"Fainting"
---
> 	"Fainting",
> 	"Fainted ",
> 	"Starved "
78a84,90
> 				if(otmp->quan > 1) {
> 					register struct obj *obj;
> 					extern struct obj *splitobj();
> 
> 					obj = splitobj(otmp, 1);
> 					if(otmp == uwep) setuwep(obj);
> 				}
130c142
< 		pline("You're having a hard time getting all that food down.");
---
> 	pline("You're having a hard time getting all that food down.");
143c155
< 				lesshungry(-20);
---
> 				morehungry(20);
180,204d191
< lesshungry(num) register num; {
< /* called after eating something (and after drinking fruit juice) */
< 	register int newhunger;
< 
< 	newhunger = u.uhunger + num;
< 	if(u.uhunger <= 1000 && newhunger > 1000) {
< 		flags.botl = 1;
< 		u.uhs = SATIATED;
< 	} else if(u.uhunger <= 150 && newhunger > 150) {
< 		if(u.uhunger <= 50 && u.ustr < u.ustrmax) losestr(-1);
< 		flags.botl = 1;
< 		u.uhs = NOT_HUNGRY;
< 	} else if(u.uhunger <= 50 && newhunger > 50) {
< 		pline("You only feel hungry now.");
< 		if(u.ustr < u.ustrmax) losestr(-1);
< 		flags.botl = 1;
< 		u.uhs = HUNGRY;
< 	} else if(u.uhunger <= 0 && newhunger < 50) {
< 		pline("You feel weak now.");
< 		flags.botl = 1;
< 		u.uhs = WEAK;
< 	}
< 	u.uhunger = newhunger;
< }
< 
209,228c196,237
< 	if(u.uhunger <= 1000 && u.uhs == SATIATED) {
< 		u.uhs = NOT_HUNGRY;
< 		flags.botl = 1;
< 	} else if(u.uhunger <= 150 && u.uhs == NOT_HUNGRY) {
< 		pline("You are beginning to feel hungry.");
< 		u.uhs = HUNGRY;
< 		flags.botl = 1;
< 	} else if(u.uhunger <= 50 && u.uhs == HUNGRY) {
< 		pline("You are beginning to feel weak.");
< 		u.uhs = WEAK;
< 		losestr(1);
< 		flags.botl = 1;
< 	} else if(u.uhunger < 1 &&
< 		(u.uhs == WEAK || rn2(20-u.uhunger/10) >= 19)) {
< 		if(multi >= 0)	/* not fainted already */ {
< 			pline("You faint from lack of food.");
< 			nomul(-10+(u.uhunger/10));
< 		}
< 		if(u.uhs != FAINTING) {
< 			u.uhs = FAINTING;
---
> 	newuhs(TRUE);
> }
> 
> /* called after vomiting and after performing feats of magic */
> morehungry(num) register num; {
> 	u.uhunger -= num;
> 	newuhs(TRUE);
> }
> 
> /* called after eating something (and after drinking fruit juice) */
> lesshungry(num) register num; {
> 	u.uhunger += num;
> 	newuhs(FALSE);
> }
> 
> unfaint(){
> 	u.uhs = FAINTING;
> 	flags.botl = 1;
> }
> 
> newuhs(incr) boolean incr; {
> 	register int newhs, h = u.uhunger;
> 
> 	newhs = (h > 1000) ? SATIATED :
> 		(h > 150) ? NOT_HUNGRY :
> 		(h > 50) ? HUNGRY :
> 		(h > 0) ? WEAK : FAINTING;
> 
> 	if(newhs == FAINTING) {
> 		if(u.uhs == FAINTED)
> 			newhs = FAINTED;
> 		if(u.uhs <= WEAK || rn2(20-u.uhunger/10) >= 19) {
> 			if(u.uhs != FAINTED && multi >= 0 /* %% */) {
> 				pline("You faint from lack of food.");
> 				nomul(-10+(u.uhunger/10));
> 				nomovemsg = "You regain consciousness.";
> 				afternmv = unfaint;
> 				newhs = FAINTED;
> 			}
> 		} else
> 		if(u.uhunger < -(int)(200 + 25*u.ulevel)) {
> 			u.uhs = STARVED;
229a239,241
> 			bot();
> 			pline("You die from starvation.");
> 			done("starved");
231,233c243,264
< 	} else if(u.uhunger < -(int)(200 + 25*u.ulevel)) {
< 		pline("You die from starvation.");
< 		done("starved");
---
> 	}
> 
> 	if(newhs != u.uhs) {
> 		if(newhs >= WEAK && u.uhs < WEAK)
> 			losestr(1);
> 		else
> 		if(newhs < WEAK && u.uhs >= WEAK && u.ustr < u.ustrmax)
> 			losestr(-1);
> 		switch(newhs){
> 		case HUNGRY:
> 			pline((!incr) ? "You only feel hungry now." :
> 			      (u.uhunger < 145) ? "You feel hungry." :
> 				"You are beginning to feel hungry.");
> 			break;
> 		case WEAK:
> 			pline((!incr) ? "You feel weak now." :
> 			      (u.uhunger < 45) ? "You feel weak." :
> 				"You are beginning to feel weak.");
> 			break;
> 		}
> 		u.uhs = newhs;
> 		flags.botl = 1;
Index: hack.end.c
Prereq: 1984.
1c1,2
< /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1984. */
---
> /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
> /* hack.end.c version 1.0.1 - added "escaped with amulet" */
82c83,86
< 		outrip();
---
> 		if(!flags.notombstone)
> 			outrip();
> 		else
> 			more();
100a105
> 		killer = st1;
136c141,144
< 				if(otmp->spe >= 0) u.urexp *= 2;
---
> 				if(otmp->spe >= 0) {
> 					u.urexp *= 2;
> 					killer = "escaped (with amulet)";
> 				}
142d149
< 		killer=st1;
281,283c288,295
< 	  if(rank > 5 && (rank < rank0 - 4 || rank > rank0 + 4))
< 	      continue;
< 	  if(rank == rank0 - 4 && rank0 > 10) (void) putchar('\n');
---
> 	  if(rank > flags.end_top &&
> 	    (rank < rank0-flags.end_around || rank > rank0+flags.end_around)
> 	    && (!flags.end_own || strncmp(t1->str, t0->str, NAMSZ)))
> 	  	continue;
> 	  if(rank == rank0-flags.end_around &&
> 	     rank0 > flags.end_top+flags.end_around+1 &&
> 	     !flags.end_own)
> 		(void) putchar('\n');
321,324c333,339
< 	if(!strcmp("escaped", t1->death))
< 	  Sprintf(eos(linebuf), "escaped the dungeon [max level %d]",
< 	    t1->maxlvl);
< 	else {
---
> 	if(!strncmp("escaped", t1->death, 7)) {
> 	  if(!strcmp(" (with amulet)", t1->death+7))
> 	    Sprintf(eos(linebuf), "escaped the dungeon with amulet");
> 	  else
> 	    Sprintf(eos(linebuf), "escaped the dungeon [max level %d]",
> 	      t1->maxlvl);
> 	} else {
Index: hack.engrave.c
Prereq: 1984.
1,2c1,7
< /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1984. */
< 
---
> /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
> /* hack.engrave.c version 1.0.1 -
> 	corrected bug in rest_engravings(),
> 	added make_engr_at() */
> #ifdef MKLEV
> #include	"mklev.h"
> #else
3a9,10
> #endif MKLEV
> 
28a36
> #ifndef MKLEV
91a100
> #endif MKLEV
92a102,125
> #ifdef MKLEV
> make_engr_at(x,y,s)
> register int x,y;
> register char *s;
> {
> 	register struct engr *ep;
> 
> 	if(ep = engr_at(x,y))
> 	    del_engr(ep);
> 	ep = (struct engr *)
> 	    alloc((unsigned)(sizeof(struct engr) + strlen(s) + 1));
> 	ep->nxt_engr = head_engr;
> 	head_engr = ep;
> 	ep->engr_x = x;
> 	ep->engr_y = y;
> 	ep->engr_txt = (char *)(ep + 1);
> 	(void) strcpy(ep->engr_txt, s);
> 	ep->engr_time = 0;
> 	ep->engr_type = DUST;
> 	ep->engr_lth = strlen(s) + 1;
> }
> #endif MKLEV
> 
> #ifndef MKLEV
102a136,140
> 	if(u.uswallow) {
> 		pline("You're joking. Hahaha!");	/* riv05!a3 */
> 		return(0);
> 	}
> 
121a160,163
> 	if(Levitation && type != BURN){		/* riv05!a3 */
> 		pline("You can't reach the floor!");
> 		return(1);
> 	}
201a244
> #endif MKLEV
216a260
> #ifndef MKLEV
226a271
> 		ep->engr_txt = (char *) (ep + 1);	/* Andreas Bormann */
229a275
> #endif MKLEV
240a287
> #ifndef MKLEV
241a289
> #endif MKLEV
Index: hack.fight.c
Prereq: 1984.
1c1,2
< /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1984. */
---
> /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
> /* hack.fight.c version 1.0.1 - corrected symbol of lurker above */
16a18
> 	if(magr->mfroz) return(0);		/* riv05!a3 */
110a113,114
> 	if(u.uswallow) return(0);
> 
163c167
< char mlarge[] = "bCDdegIlmnoPSsTUwY~,&";
---
> char mlarge[] = "bCDdegIlmnoPSsTUwY\',&";
Index: hack.h
Prereq: 1984.
1c1,2
< /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1984. */
---
> /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
> /* hack.h version 1.0.1 - added some flags for HACKOPTIONS */
20a22,27
> 	unsigned time:1;	/* display elapsed 'time' */
> 	unsigned nonews:1;	/* suppress news printing */
> 	unsigned notombstone:1;
> 	unsigned end_top, end_around;	/* describe desired score list */
> 	unsigned end_own:1;		/* idem (list all own scores) */
> 	unsigned no_rest_on_space:1;	/* spaces are ignored */
Index: hack.lev.c
Prereq: 1984.
1c1,2
< /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1984. */
---
> /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
> /* hack.lev.c version 1.0.1 - somewhat more careful monster regeneration */
47a49,50
> 		long newhp;		/* tmoves may be very large */
> 
53,57c56,59
< 		if(index("ViT", mtmp->data->mlet))
< 			mtmp->mhp += tmoves;
< 		else
< 			mtmp->mhp += tmoves/20;
< 		if(mtmp->mhp > mtmp->orig_hp)
---
> 
> 		newhp = mtmp->mhp +
> 			(index("ViT", mtmp->data->mlet) ? tmoves : tmoves/20);
> 		if(newhp > mtmp->orig_hp)
58a61,62
> 		else
> 			mtmp->mhp = newhp;
Index: hack.main.c
Prereq: 1984.
1c1,2
< /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1984. */
---
> /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
> /* hack.main.c version 1.0.1 - some cosmetic changes */
33,35d33
< #ifdef NEWS
< 	int nonews = 0;
< #endif NEWS
59c57
< 			error("Flag -d must be followed by a directory name.");
---
> 		    error("Flag -d must be followed by a directory name.");
90a89
> 	initoptions();
104c103
< 			nonews++;
---
> 			flags.nonews = TRUE;
188c187
< 		if(!nonews)
---
> 		if(!flags.nonews)
230a230
> 			if(flags.time) flags.botl = 1;
299a300,301
> 		if(multi && multi%7 == 0)
> 			(void) fflush(stdout);
324a327,329
> 	if(unlink(safelock) == -1) {
> 		error("Cannot unlink safelock.");
> 	}
331c336
< 		if(write(fd, (char *) &pid, 2) != 2){
---
> 		if(write(fd, (char *) &pid, sizeof(pid)) != sizeof(pid)){
334c339
< 		if(close(fd) == -1){
---
> 		if(close(fd) == -1) {
338,340d342
< 	if(unlink(safelock) == -1){
< 		error("Cannot unlink safelock");
< 	}
372a375,379
> 		/* some people get confused when their erase char is not ^H */
> 		if(c == '\010') {
> 			if(ct) ct--;
> 			continue;
> 		}
Index: hack.makemon.c
Prereq: 1984.
1c1,2
< /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1984. */
---
> /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
> /* hack.makemon.c version 1.0.1 - newly created demons do not sleep */
93c94
< 		|| rn2(5)
---
> 		|| (ptr->mlet != '&' && ptr->mlet != 'w' && rn2(5))
Index: hack.mhitu.c
0a1,3
> /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
> /* hack.mhitu.c version 1.0.1 - corrected bug for 'R' (Mike Newton)
> 			      - also some separate code for swallowed (a3) */
15c18,50
< 	if(!index("&DuxynNF",mdat->mlet) && !u.uswallow)
---
> 
> 	/* If swallowed, can only be affected by hissers and by u.ustuck */
> 	if(u.uswallow) {
> 		if(mtmp != u.ustuck && mdat->mlet != 'c')
> 			return(0);
> 		switch(mdat->mlet) {
> 		case 'c':
> 			if(!rn2(13)) {
> 				pline("Outside, you hear %s's hissing!",
> 					monnam(mtmp));
> 				pline("%s gets turned to stone!",
> 					Monnam(u.ustuck));
> 				pline("And the same fate befalls you.");
> 				done_in_by(mtmp);
> 			}
> 			break;
> 		case ',':
> 			youswld(mtmp,4+u.uac,5,"The trapper");
> 			break;
> 		case '\'':
> 			youswld(mtmp,rnd(6),7,"The lurker above");
> 			break;
> 		case 'P':
> 			youswld(mtmp,d(2,4),12,"The purple worm");
> 			break;
> 		default:
> 			pline("The mysterious monster digests you.");
> 			u.uhp = 0;
> 		}
> 		if(u.uhp < 1) done_in_by(mtmp);
> 		return(0);
> 	}
> 	if(!index("&DuxynNF",mdat->mlet))
17c52,53
< 	else tmp = 0;
---
> 	else
> 		tmp = 0;
23c59
< 		if(!mtmp->cham && !mtmp->mcan && !rn2(15)) {
---
> 		if(!mtmp->cham && !mtmp->mcan && !rn2(13)) {
34,36c70
< 		if(u.uswallow)
< 			youswld(mtmp,4+u.uac,5,"The trapper");
< 		else if(tmp) justswld(mtmp,"The trapper");
---
> 		if(tmp) justswld(mtmp,"The trapper");
39,41c73
< 		if(u.uswallow)
< 			youswld(mtmp,rnd(6),7,"The lurker above");
< 		else if(tmp) justswld(mtmp,"The lurker above");
---
> 		if(tmp) justswld(mtmp,"The lurker above");
96c128
< kludge("You are frozen by %ss juices","the cube'");
---
> 			kludge("You are frozen by %ss juices","the cube'");
103c135,136
< kludge("You are put to sleep by %ss bite!","the homunculus'");
---
> 			kludge("You are put to sleep by %ss bite!",
> 				"the homunculus'");
149c182
< 		!u.ustuck && rn2(2)) {
---
> 		    !u.ustuck && rn2(2)) {
159,161c192
< 		if(u.uswallow)
< 			youswld(mtmp,d(2,4),12,"The purple worm");
< 		else if(ctmp && !rn2(4))
---
> 		if(ctmp && !rn2(4))
163c194,195
< 		else (void) hitu(mtmp,d(2,4));
---
> 		else
> 			(void) hitu(mtmp,d(2,4));
175c207
< 		if(ctmp && uarm && !uarmh->rustfree &&
---
> 		if(ctmp && uarm && !uarm->rustfree &&
224,226c256,258
< 		(void) hitu(mtmp,rnd(3));
< 		(void) hitu(mtmp,rnd(3));
< 		(void) hitu(mtmp,rnd(3));
---
> 		(void) hitu(mtmp,rnd(5));
> 		(void) hitu(mtmp,rnd(5));
> 		(void) hitu(mtmp,rnd(5));
229c261
< 		{ register int side = rn2(2) ? RIGHT_SIDE : LEFT_SIDE;
---
> 		{ register long side = rn2(2) ? RIGHT_SIDE : LEFT_SIDE;
Index: hack.mkobj.c
Prereq: 1984.
1c1,2
< /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1984. */
---
> /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
> /* hack.mkobj.c version 1.0.1 - mksobj() also in MKLEV */
24d24
< #ifndef MKLEV
34d33
< #endif MKLEV
Index: hack.mon.c
Prereq: 1984.
1c1,2
< /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1984. */
---
> /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
> /* hack.mon.c version 1.0.1 - some unimportant changes */
91a93
> 	u.uswldtim = 0;
467c469
< 				tt = 1 << (gtmp->gflag & ~SEEN);
---
> 				tt = 1 << (gtmp->gflag & TRAPTYPE);
520a523
> 			u.uswldtim = 0;
715a719
> 			/* perhaps we should clear mtmp->mtame here? */
Index: hack.monst.c
Prereq: 1984.
1c1,2
< /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1984. */
---
> /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
> /* hack.monst.c version 1.0.1 - corrected symbol for lurker above */
61c62
< 	{ "lurker above",	'~',10,3,3,0,0,0 },
---
> 	{ "lurker above",	'\'',10,3,3,0,0,0 },
65c66
< 	{ "demon",		'&',10,9,-4,1,4,0 },
---
> 	{ "demon",		'&',10,12,-4,1,4,0 },
Index: hack.options.c
Prereq: 1984.
1c1,2
< /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1984. */
---
> /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
> /* hack.options.c version 1.0.1 - added HACKOPTIONS */
5a7
> extern char *eos();
6a9,128
> initoptions()
> {
> 	register char *opts;
> 	extern char *getenv();
> 
> 	flags.time = flags.nonews = flags.notombstone = flags.end_own =
> 	flags.no_rest_on_space = FALSE;
> 	flags.end_top = 5;
> 	flags.end_around = 4;
> 	/* flags.oneline is set in hack.tty.c depending on the baudrate */
> 
> 	if(opts = getenv("HACKOPTIONS"))
> 		parseoptions(opts,TRUE);
> }
> 
> parseoptions(opts, from_env)
> register char *opts;
> boolean from_env;
> {
> 	register char *op,*op2;
> 	unsigned num;
> 	boolean negated;
> 
> 	if(op = index(opts, ',')) {
> 		*op++ = 0;
> 		parseoptions(op, from_env);
> 	}
> 	if(op = index(opts, ' ')) {
> 		op2 = op;
> 		while(*op++)
> 			if(*op != ' ') *op2++ = *op;
> 	}
> 	if(!*opts) return;
> 	negated = FALSE;
> 	while((*opts == '!') || !strncmp(opts, "no", 2)) {
> 		if(*opts == '!') opts++; else opts += 2;
> 		negated = !negated;
> 	}
> 	if(!strncmp(opts,"tombstone",4)) {
> 		flags.notombstone = negated;
> 		return;
> 	}
> 	if(!strncmp(opts,"news",4)) {
> 		flags.nonews = negated;
> 		return;
> 	}
> 	if(!strncmp(opts,"time",4)) {
> 		flags.time = !negated;
> 		flags.botl = 1;
> 		return;
> 	}
> 	if(!strncmp(opts,"oneline",1)) {
> 		flags.oneline = !negated;
> 		return;
> 	}
> 	if(!strncmp(opts,"restonspace",4)) {
> 		flags.no_rest_on_space = negated;
> 		return;
> 	}
> 	/* endgame:5t[op] 5a[round] o[wn] */
> 	if(!strncmp(opts,"endgame",3)) {
> 		op = index(opts,':');
> 		if(!op) goto bad;
> 		op++;
> 		while(*op) {
> 			num = 1;
> 			if(digit(*op)) {
> 				num = atoi(op);
> 				while(digit(*op)) op++;
> 			} else
> 			if(*op == '!') {
> 				negated = !negated;
> 				op++;
> 			}
> 			switch(*op) {
> 			case 't':
> 				flags.end_top = num;
> 				break;
> 			case 'a':
> 				flags.end_around = num;
> 				break;
> 			case 'o':
> 				flags.end_own = !negated;
> 				break;
> 			default:
> 				goto bad;
> 			}
> 			while(letter(*++op)) ;
> 			if(*op == '/') op++;
> 		}
> 		return;
> 	}
> bad:
> 	if(!from_env) {
> 		if(!strncmp(opts, "help", 4)) {
> 			pline("%s%s%s",
> "To set options use `HACKOPTIONS=\"<options>\"' in your environment, or ",
> "give the command 'o' followed by the line `<options>' while playing. ",
> "Here <options> is a list of <option>s separated by commas." );
> 			pline("%s%s",
> "Simple (boolean) options are oneline,rest_on_space,news,time,tombstone. ",
> "These can be negated by prefixing them with '!' or \"no\"." );
> 			pline("%s%s%s",
> "A compound option is endgame; it is followed by a description of what ",
> "parts of the scorelist you want to see. You might for example say: ",
> "`endgame:own scores/5 top scores/4 around my score'." );
> 			return;
> 		}
> 		pline("Bad option: %s.", opts);
> 		pline("Type `o help<cr>' for help.");
> 		return;
> 	}
> 	puts("Bad syntax in HACKOPTIONS.");
> 	puts("Use for example:");
> 	puts(
> "HACKOPTIONS=\"!restonspace,notombstone,endgame:own/5 topscorers/4 around me\""
> 	);
> 	getret();
> }
> 
9d130
< 	register flg = 1;
11d131
< 	register char *str;
13c133
< 	pline("What option do you want to set? [(!)eo] ");
---
> 	pline("What options do you want to set? ");
15,32c135,154
< 	str = buf;
< 	while(*str == ' ') str++;
< 	if(*str == '!') {
< 		flg = 0;
< 		str++;
< 	}
< 	switch(*str) {
< 	case 'e':
< 		flags.echo = flg;
< 		if(flg) echo(ON);
< 		else echo(OFF);
< 		break;
< 	case 'o':
< 		flags.oneline = flg;
< 		break;
< 	default:
< 		pline("Unknown option '%s'",str);
< 	}
---
> 	if(!buf[0]) {
> 	    (void) strcpy(buf,"HACKOPTIONS=");
> 	    if(flags.oneline) (void) strcat(buf,"oneline,");
> 	    if(flags.nonews) (void) strcat(buf,"nonews,");
> 	    if(flags.time) (void) strcat(buf,"time,");
> 	    if(flags.notombstone) (void) strcat(buf,"notombstone,");
> 	    if(flags.no_rest_on_space)
> 		(void) strcat(buf,"!rest_on_space,");
> 	    if(flags.end_top != 5 || flags.end_around != 4 || flags.end_own){
> 		(void) sprintf(eos(buf), "endgame: %d topscores/%d around me",
> 			flags.end_top, flags.end_around);
> 		if(flags.end_own) (void) strcat(buf, "/own scores");
> 	    } else {
> 		register char *eop = eos(buf);
> 		if(*--eop == ',') *eop = 0;
> 	    }
> 	    pline(buf);
> 	} else
> 	    parseoptions(buf, FALSE);
> 
Index: hack.pri.c
Prereq: 1984.
1c1,2
< /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1984. */
---
> /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
> /* hack.pri.c version 1.0.1 - tiny change in mnewsym() - added time */
333,334c334,340
< mnewsym(x,y) register x,y; {
< register struct monst *mtmp = m_at(x,y);
---
> mnewsym(x,y)
> register x,y;
> {
> 	register struct monst *mtmp = m_at(x,y);
> 	register struct rm *room;
> 	char newscrsym;
> 
337,338c343,348
< 		levl[x][y].scrsym = news0(x,y);
< 		levl[x][y].seen = 0;
---
> 		room = &levl[x][y];
> 		newscrsym = news0(x,y);
> 		if(room->scrsym != newscrsym) {
> 			room->scrsym = newscrsym;
> 			room->seen = 0;
> 		}
403c413
< register int csi = See_invisible;
---
> register int csi = (See_invisible != 0);
515a526
> extern char *eos();
518c529,530
< 	(void) sprintf(newbot, "Level %-2d  Gold %-5lu  Hp %3d(%d)  Ac %-2d  Str ",
---
> 	(void) sprintf(newbot,
> 		"Level %-2d  Gold %-5lu  Hp %3d(%d)  Ac %-2d  Str ",
521,524c533,539
< 		if(u.ustr>117) (void) strcat(newbot,"18/**");
< 		else (void) sprintf(newbot + strlen(newbot), "18/%02d",u.ustr-18);
< 	} else (void) sprintf(newbot + strlen(newbot), "%-2d   ",u.ustr);
< 	(void) sprintf(newbot + strlen(newbot), "  Exp %2d/%-5lu ", u.ulevel,u.uexp);
---
> 	    if(u.ustr>117)
> 		(void) strcat(newbot,"18/**");
> 	    else
> 		(void) sprintf(eos(newbot), "18/%02d",u.ustr-18);
> 	} else
> 	    (void) sprintf(eos(newbot), "%-2d   ",u.ustr);
> 	(void) sprintf(eos(newbot), "  Exp %2d/%-5lu ", u.ulevel,u.uexp);
525a541,550
> 	if(flags.time)
> 	    (void) sprintf(eos(newbot), "  %ld", moves);
> 	if(strlen(newbot) >= COLNO) {
> 		register char *bp0, *bp1;
> 		bp0 = bp1 = newbot;
> 		do {
> 			if(*bp0 != ' ' || bp0[1] != ' ' || bp0[2] != ' ')
> 				*bp1++ = *bp0;
> 		} while(*bp0++);
> 	}
Index: hack.read.c
Prereq: 1984.
1c1,2
< /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1984. */
---
> /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
> /* hack.read.c version 1.0.1 - tiny correction in SCR_MAGIC_MAPPING */
334c335,338
< 				  on_scr(zx,zy);
---
> 				  if(lev->scrsym == ' ')
> 				    newsym(zx,zy);
> 				  else
> 				    on_scr(zx,zy);
Index: hack.search.c
Prereq: 1984.
1c1,2
< /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1984. */
---
> /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
> /* hack.search.c version 1.0.1 - small correction in findit() */
4c5
< #include	"def.trap.h"
---
> #include "def.trap.h"
37c38
< 				} else if(!gtmp->gflag&SEEN) {
---
> 				} else if(!(gtmp->gflag & SEEN)) {
79c80
< 					traps[tgen->gflag]);
---
> 					traps[tgen->gflag & TRAPTYPE]);
103c104
< 			pline("That is a%s.", traps[tgen->gflag & ~SEEN]);
---
> 			pline("That is a%s.", traps[tgen->gflag & TRAPTYPE]);
Index: hack.shk.c
Prereq: 1984.
566c566
< 		int saveBlind = Blind;
---
> 		long saveBlind = Blind;
Index: hack.termcap.c
Prereq: 1984.
1c1,2
< /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1984. */
---
> /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
> /* hack.termcap.c version 1.0.1 - added no-CE fix (Harold Rynes) */
41c42
< 	if(!(CL = tgetstr("cl",&tbufptr)) || !(CE = tgetstr("ce",&tbufptr)) ||
---
> 	if(!(CL = tgetstr("cl",&tbufptr)) ||
44c45,47
< 		error("Hack needs CL, CE, UP, ND, and no OS.");
---
> 		error("Hack needs CL, UP, ND, and no OS.");
> 	/* If no CE then use spaces */
> 	CE = tgetstr("ce",&tbufptr);
121c124,134
< 	xputs(CE);
---
> 	if(CE)
> 		xputs(CE);
> 	else {	/* no-CE fix - Harold Rynes */
> 		/* this looks terrible, especially on a slow terminal
> 		   but is better than nothing */
> 		register i;
> 
> 		for(i=COLNO - curx; i > 0; --i)
> 			xputc(' ');
> 		cmov(curx,cury);
> 	}
Index: hack.trap.c
Prereq: 1984.
1c1,2
< /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1984. */
---
> /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
> /* hack.trap.c version 1.0.1 - added dotele(); */
25c26
< 		pline("You escape a%s.",traps[trap->gflag&037]);
---
> 		pline("You escape a%s.",traps[trap->gflag & TRAPTYPE]);
28c29
< 		switch(trap->gflag & ~SEEN) {
---
> 		switch(trap->gflag & TRAPTYPE) {
88,89c89,96
< 			newsym(u.ux,u.uy);
< 			tele();
---
> 			if(trap->gflag & ONCE) {
> 				deltrap(trap);
> 				newsym(u.ux,u.uy);
> 				vtele();
> 			} else {
> 				newsym(u.ux,u.uy);
> 				tele();
> 			}
119c126
< 	    register int tt = (gen->gflag & ~SEEN);
---
> 	    register int tt = (gen->gflag & TRAPTYPE);
224c231
< 		switch(trap->gflag & 037) {
---
> 		switch(trap->gflag & TRAPTYPE) {
236,240c243,264
< tele()
< {
< extern coord getpos();
< coord cc;
< register int nux,nuy;
---
> vtele() {
> #define	VAULT	6
> 	register struct mkroom *croom;
> 	for(croom = &rooms[0]; croom->hx >= 0; croom++)
> 	    if(croom->rtype == VAULT) {
> 		register x,y;
> 
> 		x = rn2(2) ? croom->lx : croom->hx;
> 		y = rn2(2) ? croom->ly : croom->hy;
> 		if(teleok(x,y)) {
> 		    teleds(x,y);
> 		    return;
> 		}
> 	    }
> 	tele();
> }
> 
> tele() {
> 	extern coord getpos();
> 	coord cc;
> 	register int nux,nuy;
> 
247,249c271,272
< 			nux = cc.x;
< 			nuy = cc.y;
< 			goto gotpos;
---
> 			teleds(cc.x, cc.y);
> 			return;
257c280,285
< gotpos:
---
> 	teleds(nux, nuy);
> }
> 
> teleds(nux, nuy)
> register int nux,nuy;
> {
280a309,329
> }
> 
> dotele() {
> 	extern char pl_character[];
> 
> 	if(
> #ifdef WIZARD
> 	   !wizard &&
> #endif WIZARD
> 		      (!Teleportation || u.ulevel < 6 ||
> 			(pl_character[0] != 'W' && u.ulevel < 10))) {
> 		pline("You are not able to teleport at will.");
> 		return(0);
> 	}
> 	if(u.uhunger <= 100 || u.ustr < 6) {
> 		pline("You miss the strength for a teleport spell.");
> 		return(1);
> 	}
> 	tele();
> 	morehungry(100);
> 	return(1);
Index: hack.version.c
Prereq: 1984.
1c1
< /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1984. */
---
> /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
6c6
< 	pline("%s 1.0 preliminary version - last edit %s.",
---
> 	pline("%s 1.0.1 - last edit %s.",
Index: hack.whatis.c
Prereq: 1984.
1c1,2
< /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1984. */
---
> /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
> /* hack.whatis.c version 1.0.1 - whatis asks for one char only. */
6,7c7
< dowhatis(str)
< register char *str;
---
> dowhatis()
11a12
> 	extern char readchar();
13,19c14,15
< 	pline("Specify what? ");
< 	getlin(bufr);
< 	str = bufr;
< 	while(*str == ' ') str++;
< 	q = *str;
< 	if(*(str+1)) pline("One character please.");
< 	else if(!(fp = fopen("data","r"))) pline("Cannot open data file!");
---
> 	if(!(fp = fopen("data","r")))
> 		pline("Cannot open data file!");
20a17,18
> 		pline("Specify what? ");
> 		q = readchar();
30c28
< 		pline("Unknown symbol.");
---
> 		pline("I've never heard of such things.");
Index: hack.wield.c
Prereq: 1984.
1c1,2
< /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1984. */
---
> /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
> /* hack.wield.c version 1.0.1 - evaporate%s */
79,80c80,81
< 	    pline("Your %s violently green for a while and then evaporates.",
< 		aobjnam(uwep, "glow"));
---
> 	    pline("Your %s violently green for a while and then evaporate%s.",
> 		aobjnam(uwep, "glow"), (uwep->quan == 1) ? "s" : "");
Index: help
1c1
< 	Welcome to HACK!
---
> 	Welcome to HACK!		   ( description of version 1.0.1 )
40a41
> 	S	Save the game.
61a63
> 	^T	teleport.
73a76
> 	z	zap a wand.
90c93,100
< 	o	set options. (see below)
---
> 	o	set options. You will be asked to enter an option line.
> 		If this is empty, the current options are reported.
> 		Otherwise it should be a list of options separated by commas.
> 		Possible boolean options are: oneline, time, news, tombstone;
> 		they can be negated by prefixing them with '!' or "no".
> 		A compound option is endgame; it is followed by a description
> 		of what parts of the list of topscorers should be printed
> 		when the game is finished.
95,102d104
< 
< 	Options:
< 		To turn an option on, say 'ox', where x is the optionletter.
< 	To turn it off, say 'o!x'.  The following options currently exist.
< 
< 	e	echo		Echo typed characters.
< 	o	oneline		Give inventories one line at a time
< 				(at the top of your screen).
Index: mklev.c
Prereq: 1984.
1c1,2
< /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1984. */
---
> /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
> /* mklev.c version 1.0.1 - new makecorridor() */
2a4,7
> #ifndef MKLEV
> #define	MKLEV
> #endif MKLEV
> 
5a11
> #include "hack.onames.h"	/* for SCR_TELEPORTATION */
19d24
< 
30a36
> int smeq[MAXNROFROOMS+1];
36c42
< schar nxcor,xx,yy,dx,dy,tx,ty; /* for corridors and other things... */
---
> schar nxcor;
42d47
< 
121,126c126,127
< 	croom = rooms;
< 	troom = croom+1;
< 	nxcor = 0;
< 	mkpos();
< 	do makecor();
< 	while (croom->hx > 0 && troom->hx > 0);
---
> 	makecorridors();
> 	make_niches();
136a138,139
> 			if(!rn2(3))
> 				makevtele();
198,201c201,203
< /* when croom and troom exist, find position for a door in croom
<    and direction for a corridor towards position [tx,ty] in the wall
<    of troom */
< mkpos()
---
> /* if allowable, create a door at [x,y] */
> okdoor(x,y)
> register x,y;
203c205,336
< coord cc,tt;
---
> 	if(levl[x-1][y].typ == DOOR || levl[x+1][y].typ == DOOR ||
> 	   levl[x][y+1].typ == DOOR || levl[x][y-1].typ == DOOR ||
> 	   levl[x-1][y].typ == SDOOR || levl[x+1][y].typ == SDOOR ||
> 	   levl[x][y-1].typ == SDOOR || levl[x][y+1].typ == SDOOR ||
> 	   (levl[x][y].typ != HWALL && levl[x][y].typ != VWALL) ||
> 	   doorindex >= DOORMAX)
> 		return(0);
> 	return(1);
> }
> 
> dodoor(x,y,aroom)
> register x,y;
> register struct mkroom *aroom;
> {
> 	if(doorindex >= DOORMAX) panic("DOORMAX exceeded?");
> 	if(!okdoor(x,y) && nxcor) return;
> 	dosdoor(x,y,aroom,rn2(8) ? DOOR : SDOOR);
> }
> 
> dosdoor(x,y,aroom,type)
> register x,y;
> register struct mkroom *aroom;
> register type;
> {
> 	register struct mkroom *broom;
> 	register tmp;
> 
> 	levl[x][y].typ = type;
> 	if(type == DOOR)
> 		levl[x][y].scrsym ='+';
> 	aroom->doorct++;
> 	broom = aroom+1;
> 	if(broom->hx < 0) tmp = doorindex; else
> 	for(tmp = doorindex; tmp > broom->fdoor; tmp--)
> 		doors[tmp] = doors[tmp-1];
> 	doorindex++;
> 	doors[tmp].x = x;
> 	doors[tmp].y = y;
> 	for( ; broom->hx >= 0; broom++) broom->fdoor++;
> }
> 
> /* Only called from makerooms() */
> maker(lowx,ddx,lowy,ddy)
> schar lowx,ddx,lowy,ddy;
> {
> 	register x, y, hix = lowx+ddx, hiy = lowy+ddy;
> 
> 	if(nroom >= MAXNROFROOMS) return(0);
> 	if(hix > COLNO-5) hix = COLNO-5;
> 	if(hiy > ROWNO-4) hiy = ROWNO-4;
> chk:
> 	if(hix <= lowx || hiy <= lowy) return(0);
> 
> 	/* check area around room (and make room smaller if necessary) */
> 	for(x = lowx-4; x <= hix+4; x++)
> 		for(y = lowy-3; y <= hiy+3; y++)
> 			if(levl[x][y].typ) {
> 				if(rn2(3)) return(0);
> 				lowx = x+5;
> 				lowy = y+4;
> 				goto chk;
> 			}
> 
> 	/* on low levels the room is lit (usually) */
> 	/* secret vaults are always lit */
> 	if((rnd(dlevel) < 10 && rn2(77)) || (ddx == 1 && ddy == 1))
> 		for(x = lowx-1; x <= hix+1; x++)
> 			for(y = lowy-1; y <= hiy+1; y++)
> 				levl[x][y].lit = 1;
> 	croom->lx = lowx;
> 	croom->hx = hix;
> 	croom->ly = lowy;
> 	croom->hy = hiy;
> 	croom->rtype = croom->doorct = croom->fdoor = 0;
> 	for(x = lowx-1; x <= hix+1; x++)
> 	    for(y = lowy-1; y <= hiy+1; y += (hiy-lowy+2)) {
> 		levl[x][y].scrsym = '-';
> 		levl[x][y].typ = HWALL;
> 	}
> 	for(x = lowx-1; x <= hix+1; x += (hix-lowx+2))
> 	    for(y = lowy; y <= hiy; y++) {
> 		levl[x][y].scrsym = '|';
> 		levl[x][y].typ = VWALL;
> 	}
> 	for(x = lowx; x <= hix; x++)
> 	    for(y = lowy; y <= hiy; y++) {
> 		levl[x][y].scrsym = '.';
> 		levl[x][y].typ = ROOM;
> 	}
> 	croom++;
> 	croom->hx = -1;
> 	smeq[nroom] = nroom;
> 	nroom++;
> 	return(1);
> }
> 
> makecorridors() {
> 	register a,b;
> 
> 	nxcor = 0;
> 	for(a = 0; a < nroom-1; a++)
> 		join(a, a+1);
> 	for(a = 0; a < nroom-2; a++)
> 	    if(smeq[a] != smeq[a+2])
> 		join(a, a+2);
> 	for(a = 0; a < nroom; a++)
> 	    for(b = 0; b < nroom; b++)
> 		if(smeq[a] != smeq[b])
> 		    join(a, b);
> 	if(nroom > 2)
> 	    for(nxcor = rn2(nroom) + 4; nxcor; nxcor--) {
> 		a = rn2(nroom);
> 		b = rn2(nroom-2);
> 		if(b >= a) b += 2;
> 		join(a, b);
> 	    }
> }
> 
> join(a,b)
> register a,b;
> {
> 	coord cc,tt;
> 	register tx, ty, xx, yy;
> 	register struct rm *crm;
> 	register dx, dy, dix, diy, cct;
> 
> 	croom = &rooms[a];
> 	troom = &rooms[b];
> 
> 	/* find positions cc and tt for doors in croom and troom
> 	   and direction for a corridor between them */
> 
236,243c369,394
< 	tx = tt.x;
< 	ty = tt.y;
< 	if(levl[xx+dx][yy+dy].typ) {
< 		if(nxcor) newloc();
< 		else {
< 			dodoor(xx,yy,croom);
< 			xx += dx;
< 			yy += dy;
---
> 	tx = tt.x - dx;
> 	ty = tt.y - dy;
> 	if(nxcor && levl[xx+dx][yy+dy].typ)
> 		return;
> 	dodoor(xx,yy,croom);
> 
> 	cct = 0;
> 	while(xx != tx || yy != ty) {
> 	    xx += dx;
> 	    yy += dy;
> 
> 	    /* loop: dig corridor at [xx,yy] and find new [xx,yy] */
> 	    if(cct++ > 500 || (nxcor && !rn2(35)))
> 		return;
> 
> 	    if(xx == COLNO-1 || xx == 0 || yy == 0 || yy == ROWNO-1)
> 		return;		/* impossible */
> 
> 	    crm = &levl[xx][yy];
> 	    if(!(crm->typ)) {
> 		if(rn2(100)) {
> 			crm->typ = CORR;
> 			crm->scrsym = CORR_SYM;
> 		} else {
> 			crm->typ = SCORR;
> 			crm->scrsym = ' ';
244a396,401
> 		if(nxcor && !rn2(50)) {
> 			mkobj_at(ROCK_SYM, xx, yy);
> 		}
> 	    } else
> 	    if(crm->typ != CORR && crm->typ != SCORR) {
> 		/* strange ... */
245a403,452
> 	    }
> 
> 	    /* find next corridor position */
> 	    dix = abs(xx-tx);
> 	    diy = abs(yy-ty);
> 
> 	    /* do we have to change direction ? */
> 	    if(dy && dix > diy) {
> 		register ddx = (xx > tx) ? -1 : 1;
> 
> 		crm = &levl[xx+ddx][yy];
> 		if(!crm->typ || crm->typ == CORR || crm->typ == SCORR) {
> 		    dx = ddx;
> 		    dy = 0;
> 		    continue;
> 		}
> 	    } else if(dx && diy > dix) {
> 		register ddy = (yy > ty) ? -1 : 1;
> 
> 		crm = &levl[xx][yy+ddy];
> 		if(!crm->typ || crm->typ == CORR || crm->typ == SCORR) {
> 		    dy = ddy;
> 		    dx = 0;
> 		    continue;
> 		}
> 	    }
> 
> 	    /* continue straight on? */
> 	    crm = &levl[xx+dx][yy+dy];
> 	    if(!crm->typ || crm->typ == CORR || crm->typ == SCORR)
> 		continue;
> 
> 	    /* no, what must we do now?? */
> 	    if(dx) {
> 		dx = 0;
> 		dy = (ty < yy) ? -1 : 1;
> 		crm = &levl[xx+dx][yy+dy];
> 		if(!crm->typ || crm->typ == CORR || crm->typ == SCORR)
> 		    continue;
> 		dy = -dy;
> 		continue;
> 	    } else {
> 		dy = 0;
> 		dx = (tx < xx) ? -1 : 1;
> 		crm = &levl[xx+dx][yy+dy];
> 		if(!crm->typ || crm->typ == CORR || crm->typ == SCORR)
> 		    continue;
> 		dx = -dx;
> 		continue;
> 	    }
247c454,461
< 	dodoor(xx,yy,croom);
---
> 
> 	/* we succeeded in digging the corridor */
> 	dodoor(tt.x, tt.y, troom);
> 
> 	if(smeq[a] < smeq[b])
> 		smeq[b] = smeq[a];
> 	else
> 		smeq[a] = smeq[b];
250,252c464
< /* if allowable, create a door at [x,y] */
< okdoor(x,y)
< register x,y;
---
> make_niches()
254,261c466,467
< 	if(levl[x-1][y].typ == DOOR || levl[x+1][y].typ == DOOR ||
< 	   levl[x][y+1].typ == DOOR || levl[x][y-1].typ == DOOR ||
< 	   levl[x-1][y].typ == SDOOR || levl[x+1][y].typ == SDOOR ||
< 	   levl[x][y-1].typ == SDOOR || levl[x][y+1].typ == SDOOR ||
< 	   (levl[x][y].typ != HWALL && levl[x][y].typ != VWALL) ||
< 	   doorindex >= DOORMAX)
< 		return(0);
< 	return(1);
---
> 	register int ct = rn2(nroom/2 + 1)+1;
> 	while(ct--) makeniche(FALSE);
264,266c470
< dodoor(x,y,aroom)
< register x,y;
< register struct mkroom *aroom;
---
> makevtele()
268,285c472
< 	register struct mkroom *broom;
< 	register tmp;
< 	if(doorindex >= DOORMAX) panic("DOORMAX exceeded?");
< 	if(!okdoor(x,y) && nxcor) return;
< 	if(!rn2(8)) levl[x][y].typ = SDOOR;
< 	else {
< 		levl[x][y].scrsym ='+';
< 		levl[x][y].typ = DOOR;
< 	}
< 	aroom->doorct++;
< 	broom = aroom+1;
< 	if(broom->hx < 0) tmp = doorindex; else
< 	for(tmp = doorindex; tmp > broom->fdoor; tmp--)
< 		doors[tmp] = doors[tmp-1];
< 	doorindex++;
< 	doors[tmp].x = x;
< 	doors[tmp].y = y;
< 	for( ; broom->hx >= 0; broom++) broom->fdoor++;
---
> 	makeniche(TRUE);
288c475,476
< newloc()
---
> makeniche(with_trap)
> boolean with_trap;
290,291c478,483
< 	register a,b;
< 	register int tryct = 0;
---
> 	register struct mkroom *aroom;
> 	register struct rm *rm;
> 	register int vct = 8;
> 	coord dd;
> 	register dy,xx,yy;
> 	register struct gen *gtmp;
293,298c485,509
< 	++croom;
< 	++troom;
< 	if(nxcor || croom->hx < 0 || troom->hx < 0) {
< 		if(nxcor++ > rn1(nroom,4)) {
< 			croom = &rooms[nroom];
< 			return;
---
> 	if(doorindex < DOORMAX)
> 	  while(vct--) {
> 	    aroom = &rooms[rn2(nroom-1)];
> 	    if(aroom->rtype != 0) continue;	/* not an ordinary room */
> 	    if(rn2(2)) {
> 		dy = 1;
> 		dd = finddpos(aroom->lx,aroom->hy+1,aroom->hx,aroom->hy+1);
> 	    } else {
> 		dy = -1;
> 		dd = finddpos(aroom->lx,aroom->ly-1,aroom->hx,aroom->ly-1);
> 	    }
> 	    xx = dd.x;
> 	    yy = dd.y;
> 	    if((rm = &levl[xx][yy+dy])->typ) continue;
> 	    if(with_trap || !rn2(4)) {
> 		rm->typ = SCORR;
> 		rm->scrsym = ' ';
> 		if(with_trap) {
> 		    gtmp = newgen();
> 		    gtmp->gx = xx;
> 		    gtmp->gy = yy+dy;
> 		    gtmp->gflag = TELEP_TRAP | ONCE;
> 		    gtmp->ngen = ftrap;
> 		    ftrap = gtmp;
> 		    make_engr_at(xx,yy-dy,"ad ae?ar um");
300,310c511,522
< 		do {
< 			if(++tryct > 100){
< 				printf("tryct overflow5\n");
< 				croom = &rooms[nroom];
< 				return;
< 			}
< 			a = rn2(nroom);
< 			b = rn2(nroom);
< 			croom = &rooms[a];
< 			troom = &rooms[b];
< 		} while(croom == troom || (troom == croom+1 && !rn2(3)));
---
> 		dosdoor(xx,yy,aroom,SDOOR);
> 	    } else {
> 		rm->typ = CORR;
> 		rm->scrsym = CORR_SYM;
> 		if(rn2(7))
> 		    dosdoor(xx,yy,aroom,rn2(5) ? SDOOR : DOOR);
> 		else {
> 		    mksobj_at(SCROLL_SYM,SCR_TELEPORTATION,xx,yy+dy);
> 		    if(!rn2(3)) mkobj_at(0,xx,yy+dy);
> 		}
> 	    }
> 	    return;
312d523
< 	mkpos();
374d584
< 			printf("tryct overflow7\n");
405,530d614
< }
< 
< maker(lowx,ddx,lowy,ddy)
< schar lowx,ddx,lowy,ddy;
< {
< 	register x, y, hix = lowx+ddx, hiy = lowy+ddy;
< 
< 	if(nroom >= MAXNROFROOMS) return(0);
< 	if(hix > COLNO-5) hix = COLNO-5;
< 	if(hiy > ROWNO-4) hiy = ROWNO-4;
< chk:
< 	if(hix <= lowx || hiy <= lowy) return(0);
< 
< 	/* check area around room (and make room smaller if necessary) */
< 	for(x = lowx-4; x <= hix+4; x++)
< 		for(y = lowy-3; y <= hiy+3; y++)
< 			if(levl[x][y].typ) {
< 				if(rn2(3)) return(0);
< 				lowx = x+5;
< 				lowy = y+4;
< 				goto chk;
< 			}
< 
< 	/* on low levels the room is lit (usually) */
< 	/* secret vaults are always lit */
< 	if((rnd(dlevel) < 10 && rn2(77)) || (ddx == 1 && ddy == 1))
< 		for(x = lowx-1; x <= hix+1; x++)
< 			for(y = lowy-1; y <= hiy+1; y++)
< 				levl[x][y].lit = 1;
< 	croom->lx = lowx;
< 	croom->hx = hix;
< 	croom->ly = lowy;
< 	croom->hy = hiy;
< 	croom->rtype = croom->doorct = croom->fdoor = 0;
< 	for(x = lowx-1; x <= hix+1; x++)
< 	    for(y = lowy-1; y <= hiy+1; y += (hiy-lowy+2)) {
< 		levl[x][y].scrsym = '-';
< 		levl[x][y].typ = HWALL;
< 	}
< 	for(x = lowx-1; x <= hix+1; x += (hix-lowx+2))
< 	    for(y = lowy; y <= hiy; y++) {
< 		levl[x][y].scrsym = '|';
< 		levl[x][y].typ = VWALL;
< 	}
< 	for(x = lowx; x <= hix; x++)
< 	    for(y = lowy; y <= hiy; y++) {
< 		levl[x][y].scrsym = '.';
< 		levl[x][y].typ = ROOM;
< 	}
< 	croom++;
< 	croom->hx = -1;
< 	nroom++;
< 	return(1);
< }
< 
< makecor() {
< 	register nx, ny;
< 	register struct rm *crm;
< 	register dix, diy, secondtry = 0;
< 
< tryagain:
< 	nx = xx + dx;
< 	ny = yy + dy;
< 
< 	if(nxcor && !rn2(35)) {
< 		newloc();
< 		return;
< 	}
< 	if(nx == COLNO-1 || nx == 0 || ny == 0 || ny == ROWNO-1) {
< 		if(nxcor) {
< 			newloc();
< 			return;
< 		} else {
< 			printf("something went wrong. we try again...\n");
< 		execl("./mklev",args[0],tfile,tspe,args[3],args[4],args[5],0);
< 			panic("cannot execute ./mklev\n");
< 		}
< 	}
< 
< 	dix = abs(nx-tx);
< 	diy = abs(ny-ty);
< 	if(dy && dix > diy) {
< 		dy = 0;
< 		dx = (nx > tx) ? -1 : 1;
< 	} else if(dx && diy > dix) {
< 		dx = 0;
< 		dy = (ny > ty) ? -1 : 1;
< 	}
< 
< 	crm = &levl[nx][ny];
< 	if(!(crm->typ)) {
< 		if(rn2(100)) {
< 			crm->typ = CORR;
< 			crm->scrsym = CORR_SYM;
< 		} else {
< 			crm->typ = SCORR;
< 			crm->scrsym = ' ';
< 		}
< 		xx = nx;
< 		yy = ny;
< 		if(nxcor && !rn2(50)) {
< 			mkobj_at(ROCK_SYM, nx, ny);
< 		}
< 		return;
< 	}
< 	if(crm->typ == CORR || crm->typ == SCORR) {
< 		xx = nx;
< 		yy = ny;
< 		return;
< 	}
< 	if(nx == tx && ny == ty) {
< 		dodoor(nx,ny,troom);
< 		newloc();
< 		return;
< 	}
< 	if(!secondtry++ && (nx != xx+dx || ny != yy+dy))
< 		goto tryagain;
< 	if(dx) {
< 		if(ty < ny) dy = -1;
< 		else dy = levl[nx+dx][ny-1].typ == ROOM?1:-1;
< 		dx = 0;
< 	} else {
< 		if(tx < nx) dx = -1;
< 		else dx = levl[nx-1][ny+dy].typ == ROOM?1:-1;
< 		dy = 0;
< 	}
Index: savelev.h
Prereq: 1984.
1c1,2
< /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1984. */
---
> /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
> /* savelev.h version 1.0.1 - also save engravings from MKLEV */
40d40
< 	bwrite(fd,(char *) nul, sizeof(unsigned));
44d43
< 	save_engravings(fd);
45a45
> 	save_engravings(fd);

That was all.
