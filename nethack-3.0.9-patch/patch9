Path: utzoo!utgpu!news-server.csri.toronto.edu!cs.utexas.edu!uunet!zephyr.ens.tek.com!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v10i045:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Patch9
Message-ID: <5860@tekred.CNA.TEK.COM>
Date: 28 Jun 90 23:18:04 GMT
Sender: news@tekred.CNA.TEK.COM
Lines: 1509
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 10, Issue 45
Archive-name: NetHack3/Patch9
Patch-To: NetHack3: Volume 7, Issue 56-93

	[Unpack in the top level NetHack source directory and apply
	 the patchfile using "patch -p <patches09".    -br]

[from the development team...]
[[Patchlevel 9 is in fact an amendment patch to Patchlevel 8.  It
contains fixes to some deadly bugs discovered thus far in the Pl8
code.  

Among the bugs fixed are a 0 dereference bug in the Amiga code, a
bug in the tins code, a bug in the inventory weight code, a level
files bug in the Mac code, an ST display bug, a bug in the maze's
bones level, a bug with chest traps, a bug in the restoring code, a
vault guard bug, a PC collapsing dungeon bug, and other more minor
bugs.]]

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of shell archive."
# Contents:  UPDATE9 patches09
# Wrapped by billr@saab on Thu Jun 28 16:13:19 1990
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'UPDATE9' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'UPDATE9'\"
else
echo shar: Extracting \"'UPDATE9'\" \(480 characters\)
sed "s/^X//" >'UPDATE9' <<'END_OF_FILE'
XPatchlevel 9 is in fact an amendment patch to Patchlevel 8.  It
Xcontains fixes to some deadly bugs discovered thus far in the Pl8
Xcode.  
X
XAmong the bugs fixed are a 0 dereference bug in the Amiga code, a
Xbug in the tins code, a bug in the inventory weight code, a level
Xfiles bug in the Mac code, an ST display bug, a bug in the maze's
Xbones level, a bug with chest traps, a bug in the restoring code, a
Xvault guard bug, a PC collapsing dungeon bug, and other more minor
Xbugs. 
X
END_OF_FILE
if test 480 -ne `wc -c <'UPDATE9'`; then
    echo shar: \"'UPDATE9'\" unpacked with wrong size!
fi
# end of 'UPDATE9'
fi
if test -f 'patches09' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'patches09'\"
else
echo shar: Extracting \"'patches09'\" \(43223 characters\)
sed "s/^X//" >'patches09' <<'END_OF_FILE'
X*** Install.ami.orig	Fri Jun  1 07:48:38 1990
X--- Install.ami	Tue Jun 26 09:36:23 1990
X***************
X*** 222,230 ****
X      wish to utilize it.
X  
X      Due to a problem with versions 5.04 and 5.05, you must make one change:
X!     edit the file Others:lev_lex.c.  At (or near) line 1002 is the definition
X      for the function yyunput.  Delete the word "register" from this line.
X!     Note that if you neglect to do this, you will get an Error 72 at line 318
X      of file lev_comp.l (this is the correct message - lev_lex.c is flex output).
X      Save the changed file.  Later compiler versions may or may not need this
X      fix.
X--- 222,230 ----
X      wish to utilize it.
X  
X      Due to a problem with versions 5.04 and 5.05, you must make one change:
X!     edit the file Others:lev_lex.c.  At (or near) line 1003 is the definition
X      for the function yyunput.  Delete the word "register" from this line.
X!     Note that if you neglect to do this, you will get an Error 72 at line 319
X      of file lev_comp.l (this is the correct message - lev_lex.c is flex output).
X      Save the changed file.  Later compiler versions may or may not need this
X      fix.
X*** Install.mac.orig	Sat Jun  2 00:09:20 1990
X--- Install.mac	Tue Jun 26 09:36:52 1990
X***************
X*** 157,163 ****
X      int yymorfg;                            int yymorfg;
X      extern char *yysptr, yysbuf[];          extern char *yysptr, *yysbuf;
X      int yytchar;                            int yytchar;
X!     File *yyin ={stdin}, *yyout ={stdout};  File *yyin =stdin, *yyout =stdout;
X      {... near the end ...}
X      {... If you're using LSC or THINKC4 comment out: ...}
X      {... #define NLSTATE yyprevious=YYNEWLINE ...}
X--- 157,163 ----
X      int yymorfg;                            int yymorfg;
X      extern char *yysptr, yysbuf[];          extern char *yysptr, *yysbuf;
X      int yytchar;                            int yytchar;
X!     FILE *yyin ={stdin}, *yyout ={stdout};  FILE *yyin =stdin, *yyout =stdout;
X      {... near the end ...}
X      {... If you're using LSC or THINKC4 comment out: ...}
X      {... #define NLSTATE yyprevious=YYNEWLINE ...}
X*** amiga.old/amiwbench.c	Tue Jun 26 09:30:59 1990
X--- amiga/amiwbench.c	Tue Jun 26 09:36:24 1990
X***************
X*** 117,123 ****
X  	strcat(origicon,".info");
X  
X  	argline[0]='\0';
X! 	for(x=0;p=dobj->do_ToolTypes[x];x++){
X  		lp=index(p,'=');
X  		if(!lp++){
X  			if((strncmp(p,"SCORES",6)==0) ||
X--- 117,123 ----
X  	strcat(origicon,".info");
X  
X  	argline[0]='\0';
X! 	if(dobj->do_ToolTypes)for(x=0;p=dobj->do_ToolTypes[x];x++){
X  		lp=index(p,'=');
X  		if(!lp++){
X  			if((strncmp(p,"SCORES",6)==0) ||
X*** auxil.old/Guidebook.mn	Tue Jun 26 09:31:07 1990
X--- auxil/Guidebook.mn	Tue Jun 26 09:36:45 1990
X***************
X*** 1026,1032 ****
X  .op IBMgraphics
X  options use predefined selections of graphics symbols, so you need not
X  go to the trouble of setting up a full graphics string for these common
X! cases.
X  
X  Note that this option string is now escape-processed in conventional C
X  fashion.  This means that `\\' is a prefix to take the following
X--- 1026,1034 ----
X  .op IBMgraphics
X  options use predefined selections of graphics symbols, so you need not
X  go to the trouble of setting up a full graphics string for these common
X! cases.  These two options also set up proper handling of graphics
X! characters for such terminals, so you should specify them as appropriate
X! even if you override the selections with your own graphics string.
X  
X  Note that this option string is now escape-processed in conventional C
X  fashion.  This means that `\\' is a prefix to take the following
X*** auxil.old/Guidebook.mss	Tue Jun 26 09:31:06 1990
X--- auxil/Guidebook.mss	Tue Jun 26 09:36:44 1990
X***************
X*** 431,437 ****
X  
X  ^P      Repeat previous message (subsequent ^P's repeat earlier messages).
X  
X! q       uaff (drink) a potion.
X  
X  Q       Quit the game.
X  
X--- 431,437 ----
X  
X  ^P      Repeat previous message (subsequent ^P's repeat earlier messages).
X  
X! q       Quaff (drink) a potion.
X  
X  Q       Quit the game.
X  
X***************
X*** 986,992 ****
X  
X          The DECgraphics and IBMgraphics options use predefined selections  of
X          graphics  symbols,  so you need not go to the trouble of setting up a
X!         full graphics string for these common cases.
X  
X          Note that this option string is now escape-processed in  conventional
X          C  fashion.    This  means that `\' is a prefix to take the following
X--- 986,995 ----
X  
X          The DECgraphics and IBMgraphics options use predefined selections  of
X          graphics  symbols,  so you need not go to the trouble of setting up a
X!         full graphics string  for these common cases.  These two options also
X! 	set up proper handling  of graphics characters for such terminals, so
X! 	you  should  specify  them  as appropriate  even if  you override the
X! 	selections with your own graphics string.
X  
X          Note that this option string is now escape-processed in  conventional
X          C  fashion.    This  means that `\' is a prefix to take the following
X*** auxil.old/Guidebook.tex	Tue Jun 26 09:31:07 1990
X--- auxil/Guidebook.tex	Tue Jun 26 09:36:46 1990
X***************
X*** 1105,1111 ****
X  The command to read a scroll is `{\tt r}'.
X  
X  %.hn 2
X! \subsection{Potions (`{\tt !}')}
X  
X  %.pg
X  Potions are distinguished by the color of the liquid inside the flask.
X--- 1105,1111 ----
X  The command to read a scroll is `{\tt r}'.
X  
X  %.hn 2
X! \subsection*{Potions (`{\tt !}')}
X  
X  %.pg
X  Potions are distinguished by the color of the liquid inside the flask.
X***************
X*** 1283,1288 ****
X--- 1283,1289 ----
X      setenv NETHACKOPTIONS "female,!pickup,name:Blue Meanie,fruit:papaya"
X  \end{verbatim}
X  %.ed
X+ 
X  \nd in {\it csh}, or
X  %.sd
X  \begin{verbatim}
X***************
X*** 1290,1295 ****
X--- 1291,1297 ----
X      export NETHACKOPTIONS
X  \end{verbatim}
X  %.ed
X+ 
X  \nd in {\it sh\/} or {\it ksh}.
X  
X  %.hn 2
X***************
X*** 1360,1366 ****
X  {\it IBMgraphics}
X  options use predefined selections of graphics symbols, so you need not
X  go to the trouble of setting up a full graphics string for these common
X! cases.
X  
X  Note that this option string is now escape-processed in conventional C
X  fashion.  This means that `\verb+\+' is a prefix to take the following
X--- 1362,1370 ----
X  {\it IBMgraphics}
X  options use predefined selections of graphics symbols, so you need not
X  go to the trouble of setting up a full graphics string for these common
X! cases.  These two options also set up proper handling of graphics
X! characters for such terminals, so you should specify them as appropriate
X! even if you override the selections with your own graphics string.
X  
X  Note that this option string is now escape-processed in conventional C
X  fashion.  This means that `\verb+\+' is a prefix to take the following
X*** include.old/extern.h	Tue Jun 26 09:31:17 1990
X--- include/extern.h	Tue Jun 26 09:36:38 1990
X***************
X*** 1325,1331 ****
X  E void FDECL(drain_en, (int));
X  #endif
X  E int NDECL(dountrap);
X! E void FDECL(chest_trap, (struct obj *,int));
X  E void NDECL(wake_nearby);
X  E void FDECL(deltrap, (struct trap *));
X  E struct trap *FDECL(t_at, (int,int));
X--- 1325,1331 ----
X  E void FDECL(drain_en, (int));
X  #endif
X  E int NDECL(dountrap);
X! E boolean FDECL(chest_trap, (struct obj *,int));
X  E void NDECL(wake_nearby);
X  E void FDECL(deltrap, (struct trap *));
X  E struct trap *FDECL(t_at, (int,int));
X*** include.old/patchlevel.h	Tue Jun 26 09:31:19 1990
X--- include/patchlevel.h	Tue Jun 26 10:00:25 1990
X***************
X*** 97,100 ****
X   *  and a number of simple fixes and consistency extensions
X   */
X  
X! #define PATCHLEVEL	8
X--- 97,107 ----
X   *  and a number of simple fixes and consistency extensions
X   */
X  
X! /*
X!  *  Patch 9, June 26, 1990
X!  *  clear up some confusing documentation
X!  *  smooth some more rough edges in various ports
X!  *  and fix a couple more bugs
X!  */
X! 
X! #define PATCHLEVEL	9
X*** include.old/system.h	Tue Jun 26 09:31:19 1990
X--- include/system.h	Tue Jun 26 09:36:49 1990
X***************
X*** 254,260 ****
X  # define Vsprintf (void) vsprintf
X  #endif
X  
X! #ifdef TOS
X  E int FDECL(tgetent, (const char *,const char *));
X  E int FDECL(tgetnum, (const char *));
X  E int FDECL(tgetflag, (const char *));
X--- 254,260 ----
X  # define Vsprintf (void) vsprintf
X  #endif
X  
X! #ifdef MSDOS
X  E int FDECL(tgetent, (const char *,const char *));
X  E int FDECL(tgetnum, (const char *));
X  E int FDECL(tgetflag, (const char *));
X*** include.old/vault.h	Tue Jun 26 09:31:20 1990
X--- include/vault.h	Tue Jun 26 09:36:49 1990
X***************
X*** 16,21 ****
X--- 16,22 ----
X  	xchar ogx, ogy;		/* guard's last position */
X  	xchar gdlevel;		/* level guard was created on */
X  	xchar warncnt;		/* number of warnings to follow */
X+ 	int vroom;		/* room number of the vault */
X  	unsigned gddone:1;
X  	struct fakecorridor fakecorr[FCSIZ];
X  };
X*** mac.old/mac.c	Tue Jun 26 09:31:29 1990
X--- mac/mac.c	Tue Jun 26 09:36:47 1990
X***************
X*** 1116,1122 ****
X  #define	MORE_INFO_BUTTON	2
X  
X  	DialogPtr	theDialog;
X- 	DialogRecord	space;
X  	Rect	rect;
X  	Handle	theControl;
X  	short	type,itemHit;
X--- 1116,1121 ----
X***************
X*** 1131,1137 ****
X  	}
X  
X  	GetPort(&oldPort);
X! 	theDialog = GetNewDialog(129, &space,(WindowPtr)-1);
X  	if (!prompt) {
X  		HideDItem(theDialog, OK_BUTTON);
X  		HideDItem(theDialog, MORE_INFO_BUTTON);
X--- 1130,1136 ----
X  	}
X  
X  	GetPort(&oldPort);
X! 	theDialog = GetNewDialog(129, (Ptr)NULL,(WindowPtr)-1);
X  	if (!prompt) {
X  		HideDItem(theDialog, OK_BUTTON);
X  		HideDItem(theDialog, MORE_INFO_BUTTON);
X*** others.old/Makefile.ovl	Tue Jun 26 09:31:37 1990
X--- others/Makefile.ovl	Tue Jun 26 09:36:50 1990
X***************
X*** 61,68 ****
X  #
X  ###############################################################################
X  # Use the first line if you are using EXESMURF or the second for EXEMOD.
X! EXEFLAGS = /max3000 /min3000
X! # EXEFLAGS = /max BB8 /min BB8
X  ###############################################################################
X  #
X  # *****************************************************************************
X--- 61,68 ----
X  #
X  ###############################################################################
X  # Use the first line if you are using EXESMURF or the second for EXEMOD.
X! EXEFLAGS = /max4500 /min4500
X! # EXEFLAGS = /max 1194 /min 1194
X  ###############################################################################
X  #
X  # *****************************************************************************
X*** others.old/NetHack.cnf	Tue Jun 26 09:31:37 1990
X--- others/NetHack.cnf	Tue Jun 26 09:36:46 1990
X***************
X*** 70,76 ****
X  #
X  # If you merely set the IBMgraphics option as above, NetHack will use IBM
X  # extended ASCII for dungeon characters.  If you don't like the selections,
X! # you can make up your own via the graphics option (and not set IBMgraphics).
X  #
X  # An example using the IBM graphics character set:
X  #	   ' '  |   -   .   .   `   '   -   -   -   -   -   |   -   \   /   .   -   |   +   .   #   <   >   ^   "   }   {   #   \   _   <   >   #   #
X--- 70,78 ----
X  #
X  # If you merely set the IBMgraphics option as above, NetHack will use IBM
X  # extended ASCII for dungeon characters.  If you don't like the selections,
X! # you can make up your own via the graphics option, but you should still set
X! # IBMgraphics if you are using IBM graphics characters to get the correct
X! # processing.
X  #
X  # An example using the IBM graphics character set:
X  #	   ' '  |   -   .   .   `   '   -   -   -   -   -   |   -   \   /   .   -   |   +   .   #   <   >   ^   "   }   {   #   \   _   <   >   #   #
X***************
X*** 86,91 ****
X  # (aka ANSI ruling character set '0') for dungeon characters.  If you don't
X  # like the selections, you can make up your own via the graphics option,
X  # adding 128 to the value of any line-drawing character you want to use.
X! # (In such a case, do not set DECgraphics.)
X  #
X  #GRAPHICS= 032 248 241 236 235 237 234 238 246 247 245 244 248 241 092 047 254 241 248 043 254 225
X--- 88,93 ----
X  # (aka ANSI ruling character set '0') for dungeon characters.  If you don't
X  # like the selections, you can make up your own via the graphics option,
X  # adding 128 to the value of any line-drawing character you want to use.
X! # (But you should still set DECgraphics to get the correct processing.)
X  #
X  #GRAPHICS= 032 248 241 236 235 237 234 238 246 247 245 244 248 241 092 047 254 241 248 043 254 225
X*** others.old/msdos.c	Tue Jun 26 09:31:37 1990
X--- others/msdos.c	Tue Jun 26 09:36:32 1990
X***************
X*** 1411,1416 ****
X--- 1411,1418 ----
X  	char *s;
X  	static char newhe[] = "\033q\033b\017\033c0";
X  
X+ 	if (!flags.IBMBIOS)
X+ 		return;
X  	init_aline();
X  	numcolors = 1 << (((unsigned char *) _a_line)[1]);
X  	if (numcolors == 2) {			/* mono */
X*** src.old/apply.c	Tue Jun 26 09:31:43 1990
X--- src/apply.c	Tue Jun 26 09:36:26 1990
X***************
X*** 1182,1187 ****
X--- 1182,1189 ----
X  		return;
X  	}
X  	if(can = mksobj(TIN,FALSE)) {
X+ 	    int savequan;
X+ 
X  	    can->corpsenm = corpse->corpsenm;
X  	    can->quan = 1; /*Defeat the occasional creation of pairs of tins */
X  	    can->owt = weight(can);
X***************
X*** 1190,1199 ****
X  	    can->cursed = obj->cursed;
X  	    can->blessed = obj->blessed;
X  	    can = addinv(can);
X! 	    You("now have %s.", doname(can));
X  	    if (carried(corpse)) useup(corpse);
X  	    else useupf(corpse);
X! 	} else pline("Tinning failed.");
X  }
X  
X  int
X--- 1192,1211 ----
X  	    can->cursed = obj->cursed;
X  	    can->blessed = obj->blessed;
X  	    can = addinv(can);
X! 	    savequan = can->quan;
X! 	    can->quan = 1;
X! 	    if (inv_cnt() <= 52) {
X! 		prinv(can);
X! 		can->quan = savequan;
X! 	    } else {
X! 		pline("You make, but cannot pick up, %s.", doname(can));
X! 		/* can->quan = savequan; */
X! 		/* unnecessary since savequan = quan = 1 here */
X! 		dropx(can);
X! 	    }
X  	    if (carried(corpse)) useup(corpse);
X  	    else useupf(corpse);
X! 	} else impossible("Tinning failed.");
X  }
X  
X  int
X*** src.old/dokick.c	Tue Jun 26 09:31:44 1990
X--- src/dokick.c	Tue Jun 26 09:36:40 1990
X***************
X*** 374,386 ****
X  		if (!kickobj->olocked && (!rn2(3) ||
X  					(martial() && !rn2(2)))) {
X  		    pline("The lid slams open, then falls shut.");
X! 		    if(otrp) chest_trap(kickobj, LEG);
X  		    return(1);
X  		} else if (kickobj->olocked && 
X  				(!rn2(5) || (martial() && !rn2(2)))) {
X  		    You("break open the lock!");
X  		    kickobj->olocked = 0;
X! 	            if(otrp) chest_trap(kickobj, LEG);
X  		    return(1);
X  		}
X  		/* let it fall through to the next cases... */
X--- 374,386 ----
X  		if (!kickobj->olocked && (!rn2(3) ||
X  					(martial() && !rn2(2)))) {
X  		    pline("The lid slams open, then falls shut.");
X! 		    if(otrp) (void) chest_trap(kickobj, LEG);
X  		    return(1);
X  		} else if (kickobj->olocked && 
X  				(!rn2(5) || (martial() && !rn2(2)))) {
X  		    You("break open the lock!");
X  		    kickobj->olocked = 0;
X! 	            if(otrp) (void) chest_trap(kickobj, LEG);
X  		    return(1);
X  		}
X  		/* let it fall through to the next cases... */
X*** src.old/end.c	Tue Jun 26 09:31:45 1990
X--- src/end.c	Tue Jun 26 09:36:31 1990
X***************
X*** 194,200 ****
X  	(void) puts(" Suddenly, the dungeon collapses.");
X  #if defined(WIZARD) && !defined(MSDOS)
X  	if(!wizard) {
X! 	    pline("Report error to %s and it may be possible to rebuild.",WIZARD);
X  	    more();
X  	}
X  #ifdef VMS
X--- 194,205 ----
X  	(void) puts(" Suddenly, the dungeon collapses.");
X  #if defined(WIZARD) && !defined(MSDOS)
X  	if(!wizard) {
X! 	    pline("Report error to %s and it may be possible to rebuild.",
X! # ifdef WIZARD_NAME	/*(KR1ED)*/
X! 		WIZARD_NAME);
X! # else
X! 		WIZARD);
X! # endif
X  	    more();
X  	}
X  #ifdef VMS
X***************
X*** 641,650 ****
X--- 646,668 ----
X  #  if defined(UNIX) || defined(VMS)
X  	(void) signal(SIGHUP,SIG_IGN);
X  #  endif
X+ #  ifdef MACOS
X+ 	Str255 fileName;
X+ 	int oldVolume;
X+ 	struct term_info *t;
X+ 	extern WindowPtr HackWindow;
X+ 
X+ 	t = (term_info *)GetWRefCon(HackWindow);
X+ 	(void)GetVol(&fileName, &oldVolume);
X+ 	(void)SetVol(0L, t->system.sysVRefNum);
X+ #  endif
X  	for(x = maxdlevel; x >= 0; x--) {
X  		glo(x);
X  		(void) unlink(lock);	/* not all levels need be present */
X  	}
X+ #  ifdef MACOS
X+ 	(void)SetVol(0L, oldVolume);
X+ #  endif
X  # endif
X  #endif
X  }
X*** src.old/hack.c	Tue Jun 26 09:31:45 1990
X--- src/hack.c	Tue Jun 26 09:36:33 1990
X***************
X*** 1122,1128 ****
X  		if (u.usym==S_NYMPH) carrcap = MAX_CARR_CAP;
X  		else if (!uasmon->cwt)
X  			carrcap = (carrcap * uasmon->mlevel * 6)/45;
X! 		else carrcap = (carrcap * uasmon->cwt / 45);
X  	}
X  #endif
X  	if(Levitation) 			/* pugh@cornell */
X--- 1122,1130 ----
X  		if (u.usym==S_NYMPH) carrcap = MAX_CARR_CAP;
X  		else if (!uasmon->cwt)
X  			carrcap = (carrcap * uasmon->mlevel * 6)/45;
X! 		else if (!strongmonst(uasmon)
X! 			|| (strongmonst(uasmon) && (uasmon->cwt > 45)))
X! 			carrcap = (carrcap * uasmon->cwt / 45);
X  	}
X  #endif
X  	if(Levitation) 			/* pugh@cornell */
X*** src.old/lock.c	Tue Jun 26 09:31:46 1990
X--- src/lock.c	Tue Jun 26 09:36:41 1990
X***************
X*** 76,82 ****
X  		  (!xlock.box->olocked) ? "lock" :
X  		  (xlock.picktyp == LOCK_PICK) ? "pick" : "open" );
X  	    xlock.box->olocked = !xlock.box->olocked;
X! 	    if(xlock.box->otrapped)	chest_trap(xlock.box, FINGER);
X  	}
X  	return((xlock.usedtime = 0));
X  }
X--- 76,83 ----
X  		  (!xlock.box->olocked) ? "lock" :
X  		  (xlock.picktyp == LOCK_PICK) ? "pick" : "open" );
X  	    xlock.box->olocked = !xlock.box->olocked;
X! 	    if(xlock.box->otrapped)	
X! 		(void) chest_trap(xlock.box, FINGER);
X  	}
X  	return((xlock.usedtime = 0));
X  }
X*** src.old/mail.c	Tue Jun 26 09:31:47 1990
X--- src/mail.c	Tue Jun 26 09:36:28 1990
X***************
X*** 227,236 ****
X  
X  static void
X  newmail() {
X  	/* deliver a scroll of mail */
X  	register boolean invload =
X  		((inv_weight() + (int)objects[SCR_MAIL].oc_weight) > 0 ||
X! 			 inv_cnt() >= 52 || Fumbling);
X  	register struct monst *md = makemon(&mons[PM_MAIL_DAEMON], u.ux, u.uy);
X  
X  	if(!md)	return;
X--- 227,237 ----
X  
X  static void
X  newmail() {
X+ 	struct obj *obj;
X  	/* deliver a scroll of mail */
X  	register boolean invload =
X  		((inv_weight() + (int)objects[SCR_MAIL].oc_weight) > 0 ||
X! 			 Fumbling);
X  	register struct monst *md = makemon(&mons[PM_MAIL_DAEMON], u.ux, u.uy);
X  
X  	if(!md)	return;
X***************
X*** 251,265 ****
X  	if(dist(md->mx,md->my) > 2)
X  		verbalize("Catch!");
X  	more();
X! 	if(invload) {
X! 		struct obj *obj = mksobj_at(SCR_MAIL,u.ux,u.uy);
X! 		obj->known = obj->dknown = TRUE;
X! 		makeknown(SCR_MAIL);
X  		stackobj(fobj);		
X  		verbalize("Oops!");
X  	} else {
X! 		/* set known and do prinv() */
X! 		(void) identify(addinv(mksobj(SCR_MAIL,FALSE)));
X  	}
X  # endif /* NO_MAILREADER */
X  
X--- 252,271 ----
X  	if(dist(md->mx,md->my) > 2)
X  		verbalize("Catch!");
X  	more();
X! 	obj = mksobj(SCR_MAIL, FALSE);
X! 	obj->known = obj->dknown = TRUE;
X! 	makeknown(SCR_MAIL);
X! 	if (!invload) obj = addinv(obj);
X! 	if(invload || inv_cnt() > 52) {
X! 		if (invload) dropy(obj);
X! 		else dropx(obj);
X  		stackobj(fobj);		
X  		verbalize("Oops!");
X  	} else {
X! 		int savequan = obj->quan;
X! 		obj->quan = 1;
X! 		prinv(obj);
X! 		obj->quan = savequan;
X  	}
X  # endif /* NO_MAILREADER */
X  
X*** src.old/makemon.c	Tue Jun 26 09:31:47 1990
X--- src/makemon.c	Tue Jun 26 09:36:22 1990
X***************
X*** 201,209 ****
X  		    (void)mongets(mtmp, IRON_SHOES);
X  		    if (rn2(4) == 0) {
X  			(void)mongets(mtmp, SHORT_SWORD);
X! 			(void)mongets(mtmp,
X! 			    (rn2(3) == 0) ? AXE : TWO_HANDED_SWORD);
X! 			(void)mongets(mtmp, LARGE_SHIELD);
X  			if (rn2(3) == 0)
X  			    (void)mongets(mtmp, DWARVISH_MITHRIL_COAT);
X  		    } else {
X--- 201,211 ----
X  		    (void)mongets(mtmp, IRON_SHOES);
X  		    if (rn2(4) == 0) {
X  			(void)mongets(mtmp, SHORT_SWORD);
X! 			if (rn2(2)) (void)mongets(mtmp, TWO_HANDED_SWORD);
X! 			else {
X! 				(void)mongets(mtmp, AXE);
X! 				(void)mongets(mtmp, LARGE_SHIELD);
X! 			}
X  			if (rn2(3) == 0)
X  			    (void)mongets(mtmp, DWARVISH_MITHRIL_COAT);
X  		    } else {
X***************
X*** 716,722 ****
X  	if (x == u.ux && y == u.uy) return 0;
X  	if (mdat) {
X  	    if (IS_POOL(levl[x][y].typ))
X! 		if (mdat == &playermon && HLevitation)	return 1;
X  		else	return (is_flyer(mdat) || is_swimmer(mdat));
X  	    if (passes_walls(mdat)) return 1;
X  	}
X--- 718,725 ----
X  	if (x == u.ux && y == u.uy) return 0;
X  	if (mdat) {
X  	    if (IS_POOL(levl[x][y].typ))
X! 		if (mdat == &playermon && (HLevitation || Wwalking))
X! 			return 1;
X  		else	return (is_flyer(mdat) || is_swimmer(mdat));
X  	    if (passes_walls(mdat)) return 1;
X  	}
X*** src.old/mhitu.c	Tue Jun 26 09:31:47 1990
X--- src/mhitu.c	Tue Jun 26 09:36:27 1990
X***************
X*** 1127,1133 ****
X  		kludge("%s engulfs you!", Monnam(mtmp));
X  		stop_occupation();
X  		if (u.utrap) {
X! 			You("are released from the trap!");
X  			u.utrap = 0;
X  		}
X  #ifdef WALKIES
X--- 1127,1134 ----
X  		kludge("%s engulfs you!", Monnam(mtmp));
X  		stop_occupation();
X  		if (u.utrap) {
X! 			You("are released from the %s!",
X! 				u.utraptype==TT_WEB ? "web" : "trap");
X  			u.utrap = 0;
X  		}
X  #ifdef WALKIES
X*** src.old/mon.c	Tue Jun 26 09:31:49 1990
X--- src/mon.c	Tue Jun 26 09:36:35 1990
X***************
X*** 499,506 ****
X  	 * and human weights (weight of a human=45).  Limits for corpseless
X  	 * monsters are arbitrary.
X  	 */
X! 	maxload = (mtmp->data->cwt ? mtmp->data->cwt : mtmp->data->mlevel*6)
X! 		* MAX_CARR_CAP / 45;
X  	if (!strongmonst(mtmp->data)) maxload /= 2;
X  
X  	return maxload;
X--- 499,511 ----
X  	 * and human weights (weight of a human=45).  Limits for corpseless
X  	 * monsters are arbitrary.
X  	 */
X! 	if (!mtmp->data->cwt)
X! 		maxload = MAX_CARR_CAP * (mtmp->data->mlevel * 6) / 45;
X! 	else if (!strongmonst(mtmp->data)
X! 		|| (strongmonst(mtmp->data) && (mtmp->data->cwt > 45)))
X! 		maxload = MAX_CARR_CAP * mtmp->data->cwt / 45;
X! 	else	maxload = MAX_CARR_CAP;	/* strong monsters w/ cwt <= 45 */
X! 
X  	if (!strongmonst(mtmp->data)) maxload /= 2;
X  
X  	return maxload;
X*** src.old/monst.c	Tue Jun 26 09:31:48 1990
X--- src/monst.c	Tue Jun 26 09:36:37 1990
X***************
X*** 869,887 ****
X  #ifdef KOPS
X  	{ "Keystone Kop", S_KOP, 1, 6, 7, 10, 9, (G_GENO | G_LGROUP | G_NOGEN),
X  	  { { AT_WEAP, AD_PHYS, 1, 4 }, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X! 	  20, 200, 0, MS_ARREST, MZ_HUMAN, M1_HUMANOID | M1_COLLECT,
X  	  M2_HUMAN | M2_WANDER | M2_HOSTILE, C(BLUE) },
X  	{ "Kop Sergeant", S_KOP, 2, 8, 6, 10, 10, (G_GENO | G_SGROUP | G_NOGEN),
X  	  { { AT_WEAP, AD_PHYS, 1, 6 }, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X! 	  20, 200, 0, MS_ARREST, MZ_HUMAN, M1_HUMANOID | M1_COLLECT,
X  	  M2_HUMAN | M2_WANDER | M2_HOSTILE | M2_STRONG, C(BLUE) },
X  	{ "Kop Lieutenant", S_KOP, 3, 10, 5, 20, 11, (G_GENO | G_NOGEN),
X  	  { { AT_WEAP, AD_PHYS, 1, 8 }, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X! 	  20, 200, 0, MS_ARREST, MZ_HUMAN, M1_HUMANOID | M1_COLLECT,
X  	  M2_HUMAN | M2_WANDER | M2_HOSTILE | M2_STRONG, C(CYAN) },
X  	{ "Kop Kaptain", S_KOP, 4, 12, 4, 20, 12, (G_GENO | G_NOGEN),
X  	  { { AT_WEAP, AD_PHYS, 2, 6 }, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X! 	  20, 200, 0, MS_ARREST, MZ_HUMAN, M1_HUMANOID | M1_COLLECT,
X  	  M2_HUMAN | M2_WANDER | M2_HOSTILE | M2_STRONG, C(HI_LORD) },
X  #endif
X  /*	Liches	 */
X--- 869,887 ----
X  #ifdef KOPS
X  	{ "Keystone Kop", S_KOP, 1, 6, 7, 10, 9, (G_GENO | G_LGROUP | G_NOGEN),
X  	  { { AT_WEAP, AD_PHYS, 1, 4 }, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X! 	  45, 200, 0, MS_ARREST, MZ_HUMAN, M1_HUMANOID | M1_COLLECT,
X  	  M2_HUMAN | M2_WANDER | M2_HOSTILE, C(BLUE) },
X  	{ "Kop Sergeant", S_KOP, 2, 8, 6, 10, 10, (G_GENO | G_SGROUP | G_NOGEN),
X  	  { { AT_WEAP, AD_PHYS, 1, 6 }, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X! 	  45, 200, 0, MS_ARREST, MZ_HUMAN, M1_HUMANOID | M1_COLLECT,
X  	  M2_HUMAN | M2_WANDER | M2_HOSTILE | M2_STRONG, C(BLUE) },
X  	{ "Kop Lieutenant", S_KOP, 3, 10, 5, 20, 11, (G_GENO | G_NOGEN),
X  	  { { AT_WEAP, AD_PHYS, 1, 8 }, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X! 	  45, 200, 0, MS_ARREST, MZ_HUMAN, M1_HUMANOID | M1_COLLECT,
X  	  M2_HUMAN | M2_WANDER | M2_HOSTILE | M2_STRONG, C(CYAN) },
X  	{ "Kop Kaptain", S_KOP, 4, 12, 4, 20, 12, (G_GENO | G_NOGEN),
X  	  { { AT_WEAP, AD_PHYS, 2, 6 }, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X! 	  45, 200, 0, MS_ARREST, MZ_HUMAN, M1_HUMANOID | M1_COLLECT,
X  	  M2_HUMAN | M2_WANDER | M2_HOSTILE | M2_STRONG, C(HI_LORD) },
X  #endif
X  /*	Liches	 */
X*** src.old/options.c	Tue Jun 26 09:31:49 1990
X--- src/options.c	Tue Jun 26 09:36:48 1990
X***************
X*** 687,693 ****
X  	unsigned num;
X  	char *op;
X  	char tmp_name[256];
X- 	DialogRecord	dlgR;
X  	DialogPtr optionDlg;
X  	DialogTHndl	th, centreDlgBox();
X  	boolean done = FALSE;
X--- 687,692 ----
X***************
X*** 713,719 ****
X  	
X  	th = centreDlgBox(130, FALSE);
X  
X! 	optionDlg = GetNewDialog(130, (Ptr)&dlgR, (WindowPtr)-1);
X  /* set initial values of text items */
X  	ITEMTEXT(PLAYER_NAME,plname);
X  	if(*dogname) ITEMTEXT(DOG_NAME,dogname);
X--- 712,718 ----
X  	
X  	th = centreDlgBox(130, FALSE);
X  
X! 	optionDlg = GetNewDialog(130, (Ptr)NULL, (WindowPtr)-1);
X  /* set initial values of text items */
X  	ITEMTEXT(PLAYER_NAME,plname);
X  	if(*dogname) ITEMTEXT(DOG_NAME,dogname);
X*** src.old/pickup.c	Tue Jun 26 09:31:50 1990
X--- src/pickup.c	Tue Jun 26 09:36:42 1990
X***************
X*** 325,331 ****
X  int
X  doloot() {	/* loot a container on the floor. */
X  
X! 	register struct obj *cobj;
X  	register int c;
X  
X  	if (Levitation) {
X--- 325,331 ----
X  int
X  doloot() {	/* loot a container on the floor. */
X  
X! 	register struct obj *cobj, *nobj;
X  	register int c;
X  
X  	if (Levitation) {
X***************
X*** 332,338 ****
X  		You("cannot reach the floor.");
X  		return(0);
X  	}
X! 	for(cobj = level.objects[u.ux][u.uy]; cobj; cobj = cobj->nexthere) {
X  		if(Is_container(cobj)) {
X  
X  		    pline("There is %s here, loot it? ", doname(cobj));
X--- 332,340 ----
X  		You("cannot reach the floor.");
X  		return(0);
X  	}
X! 	for(cobj = level.objects[u.ux][u.uy]; cobj; cobj = nobj) {
X! 	        nobj = cobj->nexthere;
X! 
X  		if(Is_container(cobj)) {
X  
X  		    pline("There is %s here, loot it? ", doname(cobj));
X***************
X*** 355,361 ****
X  		    }
X  
X  		    You("carefully open the %s...", xname(cobj));
X! 		    if(cobj->otrapped) chest_trap(cobj, FINGER);
X  		    if(multi < 0) return 0; /* a paralysis trap */
X  
X  		    use_container(cobj, 0);
X--- 357,364 ----
X  		    }
X  
X  		    You("carefully open the %s...", xname(cobj));
X! 		    if(cobj->otrapped && chest_trap(cobj, FINGER)) /* don't use obj if obj dies */
X! 		      continue;
X  		    if(multi < 0) return 0; /* a paralysis trap */
X  
X  		    use_container(cobj, 0);
X*** src.old/restore.c	Tue Jun 26 09:31:52 1990
X--- src/restore.c	Tue Jun 26 09:36:47 1990
X***************
X*** 269,274 ****
X--- 269,277 ----
X  #ifdef TEXTCOLOR
X  	flags.use_color = oldflags.use_color;
X  #endif
X+ 	/* these come from the current environment; ignore saved values */
X+ 	flags.echo = oldflags.echo;
X+ 	flags.cbreak = oldflags.cbreak;
X  
X  	mread(fd, (genericptr_t) &dlevel, sizeof dlevel);
X  	mread(fd, (genericptr_t) &maxdlevel, sizeof maxdlevel);
X***************
X*** 882,887 ****
X--- 885,899 ----
X  		}
X  	}
X  #endif
X+ 	if(ghostly && lev > medusa_level && lev < stronghold_level &&
X+ 						xdnstair == 0) {
X+ 		coord cc;
X+ 
X+ 		mazexy(&cc);
X+ 		xdnstair = cc.x;
X+ 		ydnstair = cc.y;
X+ 		levl[cc.x][cc.y].typ = STAIRS;
X+ 	}
X  }
X  
X  #ifdef ZEROCOMP
X*** src.old/termcap.c	Tue Jun 26 09:31:53 1990
X--- src/termcap.c	Tue Jun 26 09:36:32 1990
X***************
X*** 196,202 ****
X  		/* strictly, SE should be 2, and UE should be 24,
X  		   but we can't trust all ANSI emulators to be
X  		   that complete.  -3. */
X! #   if !defined(MSDOS) || defined(TERMLIB)
X  		AS = "\016";
X  		AE = "\017";
X  #   endif
X--- 196,202 ----
X  		/* strictly, SE should be 2, and UE should be 24,
X  		   but we can't trust all ANSI emulators to be
X  		   that complete.  -3. */
X! #   if !defined(MSDOS) || (defined(TERMLIB) && defined(AMIGA))
X  		AS = "\016";
X  		AE = "\017";
X  #   endif
X***************
X*** 336,341 ****
X--- 336,345 ----
X  	free((genericptr_t)tptr);
X  # ifdef TEXTCOLOR
X  	init_hilite();
X+ #  if defined(TOS) && defined(__GNUC__)
X+ 	if (!strcmp(term, "builtin"))
X+ 		HE="\033q\033b3\033c0";	/* to turn off colors, too */
X+ #  endif
X  # endif
X  #endif /* TERMLIB */
X  }
X***************
X*** 769,775 ****
X  {
X  #  ifdef TOS
X  	int c;
X- 	static char unhilite[] = "\033q\033b3\033c0";
X  #  else
X  	int backg = BLACK, foreg = WHITE, len;
X  	register int c, color;
X--- 773,778 ----
X***************
X*** 789,795 ****
X  	hilites[ORANGE_COLORED] = "\033b3\033c1";
X  	hilites[YELLOW] = "\033b1\033c3";
X  	hilites[WHITE] = "\033b0\033c3";
X- 	HE = unhilite;	/* to turn off the color stuff too */
X  #  else /* TOS */
X  	/* find the background color, HI[len] == 'm' */
X  	len = strlen(HI) - 1;
X--- 792,797 ----
X*** src.old/trap.c	Tue Jun 26 09:31:54 1990
X--- src/trap.c	Tue Jun 26 09:36:40 1990
X***************
X*** 1586,1592 ****
X  								: u.ulevel;
X  			    if(confused || Fumbling || rnd(75+dlevel/2) > ch) {
X  				You("set it off!");
X! 				chest_trap(otmp, FINGER);
X  			    } else {
X  				You("disarm it!");
X  				otmp->otrapped = 0;
X--- 1586,1592 ----
X  								: u.ulevel;
X  			    if(confused || Fumbling || rnd(75+dlevel/2) > ch) {
X  				You("set it off!");
X! 				(void) chest_trap(otmp, FINGER);
X  			    } else {
X  				You("disarm it!");
X  				otmp->otrapped = 0;
X***************
X*** 1649,1655 ****
X  }
X  
X  /* only called when the player is doing something to the chest directly */
X! void
X  chest_trap(obj, bodypart)
X  register struct obj *obj;
X  register int bodypart;
X--- 1649,1655 ----
X  }
X  
X  /* only called when the player is doing something to the chest directly */
X! boolean
X  chest_trap(obj, bodypart)
X  register struct obj *obj;
X  register int bodypart;
X***************
X*** 1657,1663 ****
X  	register struct obj *otmp,*otmp2;
X  	char	buf[80];
X  
X! 	if(Luck > -13 && rn2(13+Luck) > 7) return;
X  
X  	otmp = obj;
X  	switch(rn2(20) ? ((Luck >= 13) ? 0 : rn2(13-Luck)) : rn2(26)) {
X--- 1657,1663 ----
X  	register struct obj *otmp,*otmp2;
X  	char	buf[80];
X  
X! 	if(Luck > -13 && rn2(13+Luck) > 7) return FALSE;
X  
X  	otmp = obj;
X  	switch(rn2(20) ? ((Luck >= 13) ? 0 : rn2(13-Luck)) : rn2(26)) {
X***************
X*** 1678,1684 ****
X  
X  			losehp(d(6,6), buf, KILLED_BY_AN);
X  			wake_nearby();
X! 			return;
X  		case 20:
X  		case 19:
X  		case 18:
X--- 1678,1684 ----
X  
X  			losehp(d(6,6), buf, KILLED_BY_AN);
X  			wake_nearby();
X! 			return TRUE;
X  		case 20:
X  		case 19:
X  		case 18:
X***************
X*** 1746,1751 ****
X--- 1746,1753 ----
X  	}
X  	bot(); 			/* to get immediate botl re-display */
X  	otmp->otrapped = 0;		/* these traps are one-shot things */
X+ 
X+ 	return FALSE;
X  }
X  
X  #endif /* OVLB */
X*** src.old/uhitm.c	Tue Jun 26 09:31:54 1990
X--- src/uhitm.c	Tue Jun 26 09:36:27 1990
X***************
X*** 748,754 ****
X  	    case AD_SITM:
X  		if(mdef->minvent) {
X  		    struct obj *otmp, *addinv(), *stealoid;
X- 		    int isize = inv_cnt();
X  
X  		    stealoid = (struct obj *)0;
X  		    if(is_mercenary(pd) && could_seduce(&youmonst,mdef,mattk)){
X--- 748,753 ----
X***************
X*** 764,786 ****
X  			while(mdef->minvent) {
X  				otmp = mdef->minvent;
X  				mdef->minvent = otmp->nobj;
X  				if (!stolen && otmp==stealoid) {
X! 					if(isize < 52) {
X! 						otmp = addinv(otmp);
X! 						/* might not increase isize */
X! 						isize = inv_cnt();
X! 					} else dropy(otmp);
X  					stealoid = otmp;
X  					stolen = TRUE;
X  				} else {
X! 					if(isize < 52) {
X! 						otmp = addinv(otmp);
X! 						isize = inv_cnt();
X  						You("steal: ");
X  						prinv(otmp);
X- 					} else {
X- 						dropy(otmp);
X- 						You("steal %s.", doname(otmp));
X  					}
X  				}
X  			}
X--- 763,784 ----
X  			while(mdef->minvent) {
X  				otmp = mdef->minvent;
X  				mdef->minvent = otmp->nobj;
X+ 				/* set dknown to insure proper merge */
X+ 				if (!Blind) otmp->dknown = 1;
X  				if (!stolen && otmp==stealoid) {
X! 					otmp = addinv(otmp);
X! 					if(inv_cnt() > 52)
X! 						dropx(otmp);
X  					stealoid = otmp;
X  					stolen = TRUE;
X  				} else {
X! 					otmp = addinv(otmp);
X! 					if(inv_cnt() > 52) {
X! 						dropx(otmp);
X! 						You("steal %s.", doname(otmp));
X! 					} else {
X  						You("steal: ");
X  						prinv(otmp);
X  					}
X  				}
X  			}
X***************
X*** 795,810 ****
X  # endif
X  			}
X  		   } else {
X! 		   	   otmp = mdef->minvent;
X! 			   mdef->minvent = otmp->nobj;
X! 			   if(isize < 52) {
X! 				otmp = addinv(otmp);
X  				You("steal: ");
X  				prinv(otmp);
X! 			   } else {
X! 				dropy(otmp);
X! 				You("steal %s.", doname(otmp));
X! 			   }
X  		   }
X  		}
X  		tmp = 0;
X--- 793,809 ----
X  # endif
X  			}
X  		   } else {
X! 			otmp = mdef->minvent;
X! 			mdef->minvent = otmp->nobj;
X! 			if (!Blind) otmp->dknown = 1;
X! 			otmp = addinv(otmp);
X! 			if(inv_cnt() > 52) {
X! 				dropx(otmp);
X! 				You("steal %s.", doname(otmp));
X! 			} else {
X  				You("steal: ");
X  				prinv(otmp);
X! 			}
X  		   }
X  		}
X  		tmp = 0;
X*** src.old/vault.c	Tue Jun 26 09:31:55 1990
X--- src/vault.c	Tue Jun 26 09:36:50 1990
X***************
X*** 168,173 ****
X--- 168,174 ----
X  	EGD(guard)->ogx = x;
X  	EGD(guard)->ogy = y;
X  	EGD(guard)->gdlevel = dlevel;
X+ 	EGD(guard)->vroom = inroom(x, y);
X  	EGD(guard)->warncnt = 0;
X  
X  	if(!cansee(guard->mx, guard->my)) {
X***************
X*** 466,478 ****
X  void
X  paygd() {
X  
X! 	struct monst *guard;
X! 	register int i;
X  	int gx,gy;
X  	char buf[BUFSZ];
X  
X! 	guard = findgd();
X! 	if (!u.ugold || !guard) return;
X  
X  	if (u.uinvault) {
X  	    Your("%ld zorkmid%s goes into the Magic Memory Vault.",
X--- 467,477 ----
X  void
X  paygd() {
X  
X! 	register struct monst *grd = findgd();
X  	int gx,gy;
X  	char buf[BUFSZ];
X  
X! 	if (!u.ugold || !grd) return;
X  
X  	if (u.uinvault) {
X  	    Your("%ld zorkmid%s goes into the Magic Memory Vault.",
X***************
X*** 480,500 ****
X  	    mkgold(u.ugold, u.ux, u.uy);
X  	    u.ugold = 0L;
X  	} else {
X! 	    if(guard->mpeaceful) { /* he has no "right" to your gold */
X! 		mongone(guard);
X  		return;
X  	    }
X! 	    mnexto(guard);
X! 	    pmon(guard);
X! 	    pline("%s remits your gold to the vault.", Monnam(guard));
X! 	    for(i=0; i<=nroom; i++)
X! 		if (rooms[i].rtype==VAULT) break;
X! 	    if (i > nroom) {
X! 		impossible("no vault?");
X! 		return;
X! 	    }
X! 	    gx = rooms[i].lx + rn2(2);
X! 	    gy = rooms[i].ly + rn2(2);
X  	    mkgold(u.ugold, gx, gy);
X  	    u.ugold = 0L;
X  	    Sprintf(buf,
X--- 479,493 ----
X  	    mkgold(u.ugold, u.ux, u.uy);
X  	    u.ugold = 0L;
X  	} else {
X! 	    if(grd->mpeaceful) { /* he has no "right" to your gold */
X! 		mongone(grd);
X  		return;
X  	    }
X! 	    mnexto(grd);
X! 	    pmon(grd);
X! 	    pline("%s remits your gold to the vault.", Monnam(grd));
X! 	    gx = rooms[EGD(grd)->vroom].lx + rn2(2);
X! 	    gy = rooms[EGD(grd)->vroom].ly + rn2(2);
X  	    mkgold(u.ugold, gx, gy);
X  	    u.ugold = 0L;
X  	    Sprintf(buf,
X***************
X*** 502,508 ****
X  		player_mon()->mname, plname);
X  	    make_engr_at(gx, gy, buf);
X  	}
X! 	mongone(guard);
X  }
X  
X  #ifdef SOUNDS
X--- 495,501 ----
X  		player_mon()->mname, plname);
X  	    make_engr_at(gx, gy, buf);
X  	}
X! 	mongone(grd);
X  }
X  
X  #ifdef SOUNDS
X*** src.old/zap.c	Tue Jun 26 09:31:56 1990
X--- src/zap.c	Tue Jun 26 09:36:30 1990
X***************
X*** 1730,1736 ****
X  					destroy_item(POTION_SYM, AD_COLD);
X  				    break;
X  				case 4:		/* death */
X! 				    if(type == -24) { /* disintegration */
X  					if (Disint_resistance) {
X  					    You("are not disintegrated.");
X  					    break;
X--- 1730,1740 ----
X  					destroy_item(POTION_SYM, AD_COLD);
X  				    break;
X  				case 4:		/* death */
X! 				    if(type == -24
X! #ifdef POLYSELF
X! 					|| type == 24
X! #endif
X! 						) { /* disintegration */
X  					if (Disint_resistance) {
X  					    You("are not disintegrated.");
X  					    break;
X***************
X*** 2169,2175 ****
X  	char buf[BUFSZ];
X  	register struct obj *otmp;
X  	unsigned wishquan, mergquan;
X- 	register boolean dropit = (inv_cnt() >= 52);
X  	int tries = 0;
X  
X  retry:
X--- 2173,2178 ----
X***************
X*** 2188,2199 ****
X  		return; /* for safety; should never happen */
X  	}
X  	if (otmp != &zeroobj) {
X! 	    if(dropit) {
X  	        pline("Oops!  The %s to the floor!", aobjnam(otmp, "drop"));
X! 	        dropy(otmp);
X  	    } else {
X- 	    	wishquan = otmp->quan;
X- 	    	otmp = addinv(otmp);
X  	    	mergquan = otmp->quan;
X  	    	otmp->quan = wishquan; /* to fool prinv() */
X  	    	prinv(otmp);
X--- 2191,2203 ----
X  		return; /* for safety; should never happen */
X  	}
X  	if (otmp != &zeroobj) {
X! 	    if (!Blind) otmp->dknown = 1; /* needed for merge to work */
X! 	    wishquan = otmp->quan;
X! 	    otmp = addinv(otmp);
X! 	    if(inv_cnt() > 52) {
X  	        pline("Oops!  The %s to the floor!", aobjnam(otmp, "drop"));
X! 	        dropx(otmp);
X  	    } else {
X  	    	mergquan = otmp->quan;
X  	    	otmp->quan = wishquan; /* to fool prinv() */
X  	    	prinv(otmp);
X*** vms.old/lev_lex.h	Tue Jun 26 09:32:01 1990
X--- vms/lev_lex.h	Tue Jun 26 09:36:51 1990
X***************
X*** 5,11 ****
X   * src/lev_main.c, where stdin & stdout are still correctly defined.
X   */
X  #ifdef VAXC
X! # module lev_lex "3.0.8"
X  #endif
X  
X  #include <stdio.h>
X--- 5,11 ----
X   * src/lev_main.c, where stdin & stdout are still correctly defined.
X   */
X  #ifdef VAXC
X! # module lev_lex "3.0.9"
X  #endif
X  
X  #include <stdio.h>
X*** vms.old/vmsbuild.com	Tue Jun 26 09:32:01 1990
X--- vms/vmsbuild.com	Tue Jun 26 09:36:51 1990
X***************
X*** 1,4 ****
X! $ ! vms/vmsbuild.com -- compile and link NetHack 3.0 patchlevel 8	[pr]
X  $ !
X  $ ! usage:
X  $ !   $ set default [.src]	!or [-.src] if starting from [.vms]
X--- 1,4 ----
X! $ ! vms/vmsbuild.com -- compile and link NetHack 3.0 patchlevel 9	[pr]
X  $ !
X  $ ! usage:
X  $ !   $ set default [.src]	!or [-.src] if starting from [.vms]
X***************
X*** 121,127 ****
X  $ cc makedefs.c
X  $ link makedefs.obj,monst.obj,objects.obj,vmsmisc.obj,-
X  	'vaxcrtl''gnulib',sys$input:/Opt
X! identification="makedefs 3.0.8"
X  $ milestone "makedefs"
X  $! create some build-time files
X  $ makedefs -p	!pm.h
X--- 121,127 ----
X  $ cc makedefs.c
X  $ link makedefs.obj,monst.obj,objects.obj,vmsmisc.obj,-
X  	'vaxcrtl''gnulib',sys$input:/Opt
X! identification="makedefs 3.0.9"
X  $ milestone "makedefs"
X  $! create some build-time files
X  $ makedefs -p	!pm.h
X***************
X*** 172,178 ****
X  $ link/Exe=nethack 'nethacklib'/Lib/Incl=(vmsmain,allmain,vmsunix,vmstty,decl),-
X  	sys$disk:[]monst.obj,objects.obj,-	!(data-only modules, like decl)
X  	sys$input:/Opt,'vaxcrtl''gnulib'
X! identification="NetHack 3.0.8"
X  $ milestone "NetHack"
X  $     if c_opt.eq.10 then  goto done	!"LINK" only
X  $special:
X--- 172,178 ----
X  $ link/Exe=nethack 'nethacklib'/Lib/Incl=(vmsmain,allmain,vmsunix,vmstty,decl),-
X  	sys$disk:[]monst.obj,objects.obj,-	!(data-only modules, like decl)
X  	sys$input:/Opt,'vaxcrtl''gnulib'
X! identification="NetHack 3.0.9"
X  $ milestone "NetHack"
X  $     if c_opt.eq.10 then  goto done	!"LINK" only
X  $special:
X***************
X*** 188,194 ****
X  $ link lev_comp.obj,lev_lex.obj,lev_main.obj,-
X  	monst.obj,objects.obj,alloc.obj,panic.obj,vmsmisc.obj,-
X  	'vaxcrtl''gnulib',sys$input:/Opt
X! identification="lev_comp 3.0.8"
X  $ milestone "lev_comp"
X  $!
X  $done:
X--- 188,194 ----
X  $ link lev_comp.obj,lev_lex.obj,lev_main.obj,-
X  	monst.obj,objects.obj,alloc.obj,panic.obj,vmsmisc.obj,-
X  	'vaxcrtl''gnulib',sys$input:/Opt
X! identification="lev_comp 3.0.9"
X  $ milestone "lev_comp"
X  $!
X  $done:
X*** vms.old/vmsmain.c	Tue Jun 26 09:32:01 1990
X--- vms/vmsmain.c	Tue Jun 26 09:33:01 1990
X***************
X*** 14,21 ****
X  int hackpid = 0;				/* current pid */
X  int locknum = 0;				/* max num of players */
X  
X! static void whoami();
X! static void byebye();
X  
X  int
X  main(argc,argv)
X--- 14,25 ----
X  int hackpid = 0;				/* current pid */
X  int locknum = 0;				/* max num of players */
X  
X! static void NDECL(whoami);
X! static void NDECL(byebye);
X! #ifndef SAVE_ON_FATAL_ERROR
X! static long FDECL(vms_handler,(long [],long []));
X! #include <ssdef.h>      /* system service status codes */
X! #endif
X  
X  int
X  main(argc,argv)
X***************
X*** 99,104 ****
X--- 103,112 ----
X  	cls();
X  	u.uhp = 1;	/* prevent RIP on early quits */
X  	u.ux = FAR;	/* prevent nscr() */
X+ #ifndef SAVE_ON_FATAL_ERROR
X+ 	/* used to clear hangup stuff while still giving standard traceback */
X+ 	VAXC$ESTABLISH(vms_handler);
X+ #endif
X  	(void) signal(SIGHUP, (SIG_RET_TYPE) hangup);
X  
X  	/*
X***************
X*** 403,405 ****
X--- 411,435 ----
X      (void) chdir(getenv("PATH"));
X  #endif
X  }
X+ 
X+ #ifndef SAVE_ON_FATAL_ERROR
X+ /* Condition handler to prevent byebye's hangup simulation
X+    from saving the game after a fatal error has occurred.  */
X+ static long
X+ vms_handler(sigargs, mechargs)
X+ long sigargs[], mechargs[];     /* [0] is argc, [1..argc] are the real args */
X+ {
X+     extern boolean hu;          /* src/save.c */
X+     long condition = sigargs[1];
X+ 
X+     if (condition == SS$_ACCVIO         /* access violation */
X+      || condition >= SS$_ASTFLT && condition <= SS$_TBIT
X+      || condition >= SS$_ARTRES && condition <= SS$_INHCHME) {
X+ 	if (wizard)
X+ 	    abort();    /* enter the debugger */
X+ 	else
X+ 	    hu = TRUE;  /* pretend that hangup has already been attempted */
X+     }
X+     return SS$_RESIGNAL;
X+ }
X+ #endif
X*** vms.old/vmstty.c	Thu May 24 20:20:31 1990
X--- vms/vmstty.c	Tue Jun 26 22:46:12 1990
X***************
X*** 21,27
X  
X  extern short ospeed;
X  char erase_char, intr_char, kill_char;
X! static boolean settty_needed = FALSE;
X  #ifndef MAIL
X  static	    /* else global ('extern' in mail.c) */
X  #endif
X
X--- 21,27 -----
X  
X  extern short ospeed;
X  char erase_char, intr_char, kill_char;
X! static boolean settty_needed = FALSE,  bombing = FALSE;
X  #ifndef MAIL
X  static	    /* else global ('extern' in mail.c) */
X  #endif
X***************
X*** 109,115
X  
X  static void
X  resettty(){			/* atexit() routine */
X!     if (settty_needed)
X  	settty((char *)NULL);
X      (void) SYS$DASSGN(tt_chan),  tt_chan = 0;
X  }
X
X--- 109,116 -----
X  
X  static void
X  resettty(){			/* atexit() routine */
X!     if (settty_needed) {
X! 	bombing = TRUE;     /* don't clear screen; preserve traceback info */
X  	settty((char *)NULL);
X      }
X      (void) SYS$DASSGN(tt_chan),  tt_chan = 0;
X***************
X*** 111,116
X  resettty(){			/* atexit() routine */
X      if (settty_needed)
X  	settty((char *)NULL);
X      (void) SYS$DASSGN(tt_chan),  tt_chan = 0;
X  }
X  
X
X--- 112,118 -----
X      if (settty_needed) {
X  	bombing = TRUE;     /* don't clear screen; preserve traceback info */
X  	settty((char *)NULL);
X+     }
X      (void) SYS$DASSGN(tt_chan),  tt_chan = 0;
X  }
X  
X***************
X*** 167,176
X  settty(s)
X  char *s;
X  {
X! 	clear_screen();
X! 	end_screen();
X! 	if(s) Printf(s);
X! 	(void) fflush(stdout);
X  #ifdef MAIL	/* this is essential, or lib$spawn & lib$attach will fail */
X  	SMG$DISABLE_BROADCAST_TRAPPING(&pasteboard_id);
X  #endif
X
X--- 169,179 -----
X  settty(s)
X  char *s;
X  {
X! 	if (!bombing) {
X! 	    end_screen();
X! 	    if(s) Printf(s);
X! 	    (void) fflush(stdout);
X! 	}
X  #ifdef MAIL	/* this is essential, or lib$spawn & lib$attach will fail */
X  	SMG$DISABLE_BROADCAST_TRAPPING(&pasteboard_id);
X  #endif
END_OF_FILE
if test 43223 -ne `wc -c <'patches09'`; then
    echo shar: \"'patches09'\" unpacked with wrong size!
fi
# end of 'patches09'
fi
echo shar: End of shell archive.
exit 0
