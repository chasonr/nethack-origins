Path: utzoo!utgpu!jarvis.csri.toronto.edu!mailrus!csd4.csd.uwm.edu!cs.utexas.edu!uunet!zephyr.ens.tek.com!tekgen!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v08i021:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Patch3f
Message-ID: <4540@tekred.CNA.TEK.COM>
Date: 7 Sep 89 21:52:04 GMT
Sender: nobody@tekred.CNA.TEK.COM
Lines: 2071
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 8, Issue 21
Archive-name: NetHack3/Patch3f
Patch-To: NetHack3: Volume 7, Issue 56-93

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 6 (of 6)."
# Contents:  patch03f
# Wrapped by billr@saab on Thu Sep  7 14:39:31 1989
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'patch03f' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'patch03f'\"
else
echo shar: Extracting \"'patch03f'\" \(55124 characters\)
sed "s/^X//" >'patch03f' <<'END_OF_FILE'
X*** src/Old/potion.c	Wed Sep  6 15:56:36 1989
X--- src/potion.c	Fri Sep  1 19:18:24 1989
X***************
X*** 130,142 ****
X  static void
X  ghost_from_bottle()
X  {
X! 	register struct monst *mtmp;
X! 
X! 	if(!(mtmp = makemon(&mons[PM_GHOST],u.ux,u.uy))){
X  		pline("This bottle turns out to be empty.");
X  		return;
X  	}
X- 	mnexto(mtmp);
X  	pline("As you open the bottle, an enormous ghost emerges!");
X  	if(flags.verbose)
X  	    You("are frightened to death, and unable to move.");
X--- 130,139 ----
X  static void
X  ghost_from_bottle()
X  {
X! 	if(!makemon(&mons[PM_GHOST], u.ux, u.uy)){
X  		pline("This bottle turns out to be empty.");
X  		return;
X  	}
X  	pline("As you open the bottle, an enormous ghost emerges!");
X  	if(flags.verbose)
X  	    You("are frightened to death, and unable to move.");
X***************
X*** 876,881 ****
X--- 873,879 ----
X  			    obj->spe > -6 && !rn2(10)) {
X  				Your("%s somewhat.", aobjnam(obj,"rust"));
X  				obj->spe--;
X+ 				goto poof;
X  			} else if (obj->olet == POTION_SYM) {
X  				Your("%s.", aobjnam(obj,"dilute"));
X  				if (obj->spe == -1) {
X***************
X*** 883,892 ****
X  					obj->blessed = obj->cursed = 0;
X  					obj->otyp = POT_WATER;
X  				} else obj->spe--;
X  			} else if (obj->olet == SCROLL_SYM &&
X  				   obj->otyp != SCR_BLANK_PAPER) {
X! 				if (!Blind) pline("The scroll fades.");
X  				obj->otyp = SCR_BLANK_PAPER;
X  			} else
X  				Your("%s wet.", aobjnam(obj,"get"));
X  		}
X--- 881,899 ----
X  					obj->blessed = obj->cursed = 0;
X  					obj->otyp = POT_WATER;
X  				} else obj->spe--;
X+ 				goto poof;
X  			} else if (obj->olet == SCROLL_SYM &&
X+ #ifdef MAIL
X+ 				   obj->otyp != SCR_MAIL &&
X+ #endif
X  				   obj->otyp != SCR_BLANK_PAPER) {
X! 				if (!Blind) {
X! 					if (obj->quan == 1)
X! 						pline("The scroll fades.");
X! 					else pline("The scrolls fade.");
X! 				}
X  				obj->otyp = SCR_BLANK_PAPER;
X+ 				goto poof;
X  			} else
X  				Your("%s wet.", aobjnam(obj,"get"));
X  		}
X***************
X*** 979,1009 ****
X  		return;
X  	}
X  
X! 	mnexto(mtmp);
X! 	if (!Blind)
X  		pline("In a cloud of smoke, %s emerges!", defmonnam(mtmp));
X- 	else	You("smell acrid fumes.");
X- 	if (!Blind)
X  		pline("%s speaks.", Monnam(mtmp));
X! 	else	pline("Something speaks.");
X  
X  	switch (obj->blessed ? 0 : obj->cursed ? 4 : rn2(5)) {
X! 	case 0 : pline("\"I am in your debt.  I will grant one wish!\"");
X  		makewish();
X  		mongone(mtmp);
X  		break;
X! 	case 1 : pline("\"Thank you for freeing me!\"");
X  		(void) tamedog(mtmp, (struct obj *)0);
X  		break;
X! 	case 2 : pline("\"You freed me!\"");
X  		mtmp->mpeaceful = 1;
X  		break;
X! 	case 3 : pline("\"It is about time!\"");
X  		pline("The %s vanishes.",
X  			Hallucination ? rndmonnam() : "djinni");
X  		mongone(mtmp);
X  		break;
X! 	default: pline("\"You disturbed me, fool!\"");
X  		break;
X  	}
X  }
X--- 986,1016 ----
X  		return;
X  	}
X  
X! 	if (!Blind) {
X  		pline("In a cloud of smoke, %s emerges!", defmonnam(mtmp));
X  		pline("%s speaks.", Monnam(mtmp));
X! 	} else {
X! 		You("smell acrid fumes.");
X! 		pline("Something speaks.");
X! 	}
X  
X  	switch (obj->blessed ? 0 : obj->cursed ? 4 : rn2(5)) {
X! 	case 0 : verbalize("I am in your debt.  I will grant one wish!");
X  		makewish();
X  		mongone(mtmp);
X  		break;
X! 	case 1 : verbalize("Thank you for freeing me!");
X  		(void) tamedog(mtmp, (struct obj *)0);
X  		break;
X! 	case 2 : verbalize("You freed me!");
X  		mtmp->mpeaceful = 1;
X  		break;
X! 	case 3 : verbalize("It is about time!");
X  		pline("The %s vanishes.",
X  			Hallucination ? rndmonnam() : "djinni");
X  		mongone(mtmp);
X  		break;
X! 	default: verbalize("You disturbed me, fool!");
X  		break;
X  	}
X  }
X*** src/Old/pray.c	Wed Sep  6 15:57:30 1989
X--- src/pray.c	Wed Aug 30 19:03:12 1989
X***************
X*** 250,257 ****
X  			    what = rightglow;
X  		    } else if (uamul && uamul->cursed) /* amulet */
X  			    otmp = uamul;
X- 		    else if (ublindf && ublindf->cursed) /* blindfold */
X- 			    otmp = ublindf;
X  		    else if (welded(uwep)) otmp = uwep;
X  		    else {
X  			    for(otmp=invent; otmp; otmp=otmp->nobj)
X--- 250,255 ----
X***************
X*** 378,391 ****
X  			    else {
X  				if (Reflecting & W_AMUL) {
X  				    pline("It reflects from your medallion.");
X- #if defined(EXPLORE_MODE) || defined(WIZARD)
X  				    makeknown(AMULET_OF_REFLECTION);
X- #endif
X  				} else {
X  				    pline("It reflects from your shield.");
X- 	/* No ifdef here since they could survive with an amulet of
X- 	 * life saving which wasn't possible above.
X- 	 */
X  				    makeknown(SHIELD_OF_REFLECTION);
X  				}
X  			    }
X--- 376,384 ----
X***************
X*** 713,725 ****
X     Sacrificing a food ration got you max luck instantly, making the
X     gods as easy to please as an angry dog!
X  
X!    Now only accepts corpses, based on their level (presumably, how hard
X!    they were to kill).  Human sacrifice, as well as sacrificing unicorns
X!    of your alignment, is strongly discouraged.  (We can't tell whether a dog
X!    corpse was tame, so you can still sacrifice it.)
X   */
X  
X! #define MAXVALUE 17	/* Highest corpse value */
X  
X  	if (otmp->otyp == CORPSE) {
X  	    register struct permonst *mtmp = &mons[otmp->corpsenm];
X--- 706,718 ----
X     Sacrificing a food ration got you max luck instantly, making the
X     gods as easy to please as an angry dog!
X  
X!    Now only accepts corpses, based on the games evaluation of their
X!    toughness.  Human sacrifice, as well as sacrificing unicorns of
X!    your alignment, is strongly discouraged.  (We can't tell whether
X!    a pet corpse was tame, so you can still sacrifice it.)
X   */
X  
X! #define MAXVALUE 33	/* Highest corpse value (approx.) */
X  
X  	if (otmp->otyp == CORPSE) {
X  	    register struct permonst *mtmp = &mons[otmp->corpsenm];
X***************
X*** 990,996 ****
X  #if defined(ALTARS) && defined(NAMED_ITEMS)
X  		/* The player can gain an artifact */
X  		if(!rn2(10)) {
X! 			otmp = mk_aligned_artifact((int)(levl[u.ux][u.uy].altarmask & ~A_SHRINE) - 1);
X  			if(otmp) {
X  			    dropy(otmp);
X  			    pline("An object appears at your %s!",
X--- 983,989 ----
X  #if defined(ALTARS) && defined(NAMED_ITEMS)
X  		/* The player can gain an artifact */
X  		if(!rn2(10)) {
X! 			otmp = mk_aligned_artifact((unsigned)(levl[u.ux][u.uy].altarmask & ~A_SHRINE));
X  			if(otmp) {
X  			    dropy(otmp);
X  			    pline("An object appears at your %s!",
X***************
X*** 1001,1007 ****
X  #endif
X  		change_luck((value * LUCKMAX) / (MAXVALUE * 2));
X  		if (u.uluck != saved_luck) {
X! 		    You(Hallucination ?
X  		"see crabgrass at your %s.  A funny thing in a dungeon." :
X  		"glimpse a four-leaf clover at your %s.",
X  			makeplural(body_part(FOOT)));
X--- 994,1002 ----
X  #endif
X  		change_luck((value * LUCKMAX) / (MAXVALUE * 2));
X  		if (u.uluck != saved_luck) {
X! 		    if (Blind)
X! 			You("think you stepped on something.");
X! 		    else You(Hallucination ?
X  		"see crabgrass at your %s.  A funny thing in a dungeon." :
X  		"glimpse a four-leaf clover at your %s.",
X  			makeplural(body_part(FOOT)));
X*** src/Old/pri.c	Wed Sep  6 15:58:20 1989
X--- src/pri.c	Fri Sep  1 14:30:01 1989
X***************
X*** 10,18 ****
X  #include "epri.h"
X  #endif
X  
X! static void hilite P((uchar, uchar));
X  static void cornbot P((int));
X! static boolean ismnst P((char));
X  #if !defined(DECRAINBOW) && !defined(UNIX)
X  #  define g_putch  (void) putchar
X  #endif
X--- 10,18 ----
X  #include "epri.h"
X  #endif
X  
X! static void hilite P((UCHAR_P, UCHAR_P));
X  static void cornbot P((int));
X! static boolean ismnst P((CHAR_P));
X  #if !defined(DECRAINBOW) && !defined(UNIX)
X  #  define g_putch  (void) putchar
X  #endif
X***************
X*** 134,140 ****
X  		 * will still hilite the doorway symbol.  -3.
X  		 */
X  		if (!vism_at(x,y) &&
X! 		    (!levl[x][y].omask && !levl[x][y].gmask || is_pool(x,y)))
X  		    typ = AT_MAP;
X  
X  	y += 2;
X--- 134,140 ----
X  		 * will still hilite the doorway symbol.  -3.
X  		 */
X  		if (!vism_at(x,y) &&
X! 		    (!OBJ_AT(x, y) && !levl[x][y].gmask || is_pool(x,y)))
X  		    typ = AT_MAP;
X  
X  	y += 2;
X*** src/Old/priest.c	Wed Sep  6 15:58:58 1989
X--- src/priest.c	Fri Sep  1 19:27:07 1989
X***************
X*** 220,226 ****
X  		    (void) mongets(priest, rn2(2) ? CLOAK_OF_PROTECTION
X  						  : CLOAK_OF_MAGIC_RESISTANCE);
X  #ifdef NAMED_ITEMS
X! 		    otmp = mk_aligned_artifact(EPRI(priest)->shralign);
X  		    if(otmp) {
X  			otmp->spe = rnd(4);
X  			mpickobj(priest, otmp);
X--- 220,226 ----
X  		    (void) mongets(priest, rn2(2) ? CLOAK_OF_PROTECTION
X  						  : CLOAK_OF_MAGIC_RESISTANCE);
X  #ifdef NAMED_ITEMS
X! 		    otmp = mk_aligned_artifact((unsigned)EPRI(priest)->shralign + 1);
X  		    if(otmp) {
X  			otmp->spe = rnd(4);
X  			mpickobj(priest, otmp);
X***************
X*** 358,364 ****
X  
X  		    if(!(mtmp = makemon(&mons[PM_GHOST],u.ux,u.uy))) return;
X  		    pline("An enormous ghost appears next to you!");
X- 		    mnexto(mtmp);
X  		    mtmp->mpeaceful = 0;
X  		    if(flags.verbose)
X  		        You("are frightened to death, and unable to move.");
X--- 358,363 ----
X*** src/Old/prisym.c	Wed Sep  6 15:59:22 1989
X--- src/prisym.c	Sun Aug 20 14:26:30 1989
X***************
X*** 218,224 ****
X  		return;
X  	if(room->mmask) mtmp = m_at(x,y);
X  	if(mtmp && !mtmp->mhide &&
X! 		(!mtmp->minvis || See_invisible || Telepat)) {
X  #ifdef WORM
X  		if(m_atseg)
X  			pwseg(m_atseg);
X--- 218,224 ----
X  		return;
X  	if(room->mmask) mtmp = m_at(x,y);
X  	if(mtmp && !mtmp->mhide &&
X! 		(!mtmp->minvis || See_invisible)) {
X  #ifdef WORM
X  		if(m_atseg)
X  			pwseg(m_atseg);
X***************
X*** 226,232 ****
X  #endif
X  		pmon(mtmp);
X  	}
X! 	else if(room->omask && !is_pool(x,y)) {
X  		otmp = o_at(x,y);
X  		atl(x,y,Hallucination ? rndobjsym() : otmp->olet);
X  	}
X--- 226,232 ----
X  #endif
X  		pmon(mtmp);
X  	}
X! 	else if(OBJ_AT(x, y) && !is_pool(x,y)) {
X  		otmp = o_at(x,y);
X  		atl(x,y,Hallucination ? rndobjsym() : otmp->olet);
X  	}
X***************
X*** 235,241 ****
X  	else if((!mtmp || mtmp->data == &mons[PM_GIANT_SPIDER]) &&
X  		  (ttmp = t_at(x,y)) && ttmp->ttyp == WEB)
X  		atl(x,y,(char)WEB_SYM);
X! 	else if(mtmp && (!mtmp->minvis || See_invisible || Telepat)) {
X  		/* must be a hiding monster, but not hiding right now */
X  		/* assume for the moment that long worms do not hide */
X  		pmon(mtmp);
X--- 235,241 ----
X  	else if((!mtmp || mtmp->data == &mons[PM_GIANT_SPIDER]) &&
X  		  (ttmp = t_at(x,y)) && ttmp->ttyp == WEB)
X  		atl(x,y,(char)WEB_SYM);
X! 	else if(mtmp && (!mtmp->minvis || See_invisible)) {
X  		/* must be a hiding monster, but not hiding right now */
X  		/* assume for the moment that long worms do not hide */
X  		pmon(mtmp);
X***************
X*** 262,268 ****
X  	/* note: a zero scrsym means to ignore the presence of objects */
X  	if(!room->seen) tmp = STONE_SYM;
X  	else if(room->typ == POOL || room->typ == MOAT) tmp = POOL_SYM;
X! 	else if(room->omask && !Blind && room->scrsym) {
X  		otmp = o_at(x,y);
X  		tmp = Hallucination ? rndobjsym() : otmp->olet;
X  	}
X--- 262,268 ----
X  	/* note: a zero scrsym means to ignore the presence of objects */
X  	if(!room->seen) tmp = STONE_SYM;
X  	else if(room->typ == POOL || room->typ == MOAT) tmp = POOL_SYM;
X! 	else if(OBJ_AT(x, y) && !Blind && room->scrsym) {
X  		otmp = o_at(x,y);
X  		tmp = Hallucination ? rndobjsym() : otmp->olet;
X  	}
X*** src/Old/read.c	Wed Sep  6 15:59:45 1989
X--- src/read.c	Tue Sep  5 12:06:53 1989
X***************
X*** 601,607 ****
X  			Your("mind releases itself from mundane concerns.");
X  		else if (!strncmp(plname, "Maud", 4))
X  			pline("As your mind turns inward on itself, you forget everything else.");
X! 		else if (flags.female)
X  			pline("Who was that Maud person anyway?");
X  		else
X  			pline("Thinking of Maud you forget everything else.");
X--- 601,607 ----
X  			Your("mind releases itself from mundane concerns.");
X  		else if (!strncmp(plname, "Maud", 4))
X  			pline("As your mind turns inward on itself, you forget everything else.");
X! 		else if (rn2(2))
X  			pline("Who was that Maud person anyway?");
X  		else
X  			pline("Thinking of Maud you forget everything else.");
X*** src/Old/restore.c	Wed Sep  6 16:00:22 1989
X--- src/restore.c	Fri Aug 25 15:56:10 1989
X***************
X*** 99,105 ****
X  	off_t differ;
X  
X  	mread(fd, (genericptr_t)&monbegin, sizeof(monbegin));
X! #ifndef MSDOS
X  	differ = (genericptr_t)(&mons[0]) - (genericptr_t)(monbegin);
X  #else
X  	differ = (long)(&mons[0]) - (long)(monbegin);
X--- 99,105 ----
X  	off_t differ;
X  
X  	mread(fd, (genericptr_t)&monbegin, sizeof(monbegin));
X! #if !defined(MSDOS) && !defined(M_XENIX)
X  	differ = (genericptr_t)(&mons[0]) - (genericptr_t)(monbegin);
X  #else
X  	differ = (long)(&mons[0]) - (long)(monbegin);
X***************
X*** 118,130 ****
X  		mread(fd, (genericptr_t) mtmp, (unsigned) xl + sizeof(struct monst));
X  		if(!mtmp->m_id)
X  			mtmp->m_id = flags.ident++;
X! #ifndef MSDOS
X! 		/*ANSI type for differ is ptrdiff_t - long may be wrong*/
X! 		/*for segmented architecture - may be better to cast pointers*/
X! 		/*to (struct permonst *) rather than (genericptr_t)*/
X! 		/*this code handles save file -  so any bug should glow*/
X! 		/*probably best not to keep lint from complaining*/
X! /*#ifdef LINT	/*possible compiler/hardware dependency - */
X  /*		if (differ) mtmp->data = NULL;*/
X  /*#else*/
X  		mtmp->data = (struct permonst *)
X--- 118,132 ----
X  		mread(fd, (genericptr_t) mtmp, (unsigned) xl + sizeof(struct monst));
X  		if(!mtmp->m_id)
X  			mtmp->m_id = flags.ident++;
X! #if !defined(MSDOS) && !defined(M_XENIX)
X! 		/* ANSI type for differ is ptrdiff_t --
X! 		 * long may be wrong for segmented architecture --
X! 		 * may be better to cast pointers to (struct permonst *)
X! 		 * rather than (genericptr_t)
X! 		 * this code handles save file -- so any bug should glow
X! 		 * probably best not to keep lint from complaining
X! 		 */
X! /*#ifdef LINT	/* possible compiler/hardware dependency - */
X  /*		if (differ) mtmp->data = NULL;*/
X  /*#else*/
X  		mtmp->data = (struct permonst *)
X***************
X*** 731,737 ****
X  int
X  mread(fd, buf, len)
X  int fd;
X! register genericptr_t buf;
X  register unsigned len;
X  {
X      /*register int readlen = 0;*/
X--- 733,739 ----
X  int
X  mread(fd, buf, len)
X  int fd;
X! genericptr_t buf;
X  register unsigned len;
X  {
X      /*register int readlen = 0;*/
X***************
X*** 739,749 ****
X      while (len--) {
X        if (inrunlength > 0) {
X  	  inrunlength--;
X! 	  *((char *)buf)++ = '\0';
X        } else {
X  	  register short ch = mgetc();
X  	  if (ch < 0) return -1; /*readlen;*/
X! 	  if ((*((char *)buf)++ = ch) == RLESC) {
X  	      inrunlength = mgetc();
X  	  }
X        }
X--- 741,751 ----
X      while (len--) {
X        if (inrunlength > 0) {
X  	  inrunlength--;
X! 	  *(*((char **)&buf))++ = '\0';
X        } else {
X  	  register short ch = mgetc();
X  	  if (ch < 0) return -1; /*readlen;*/
X! 	  if ((*(*(char **)&buf)++ = ch) == RLESC) {
X  	      inrunlength = mgetc();
X  	  }
X        }
X*** src/Old/rip.c	Wed Sep  6 16:00:54 1989
X--- src/rip.c	Mon Aug 28 15:52:36 1989
X***************
X*** 48,55 ****
X  	center(7, buf);
X  	Sprintf(buf, "killed by%s",
X  		!strncmp(killer, "the ", 4) ? "" :
X! 		!strcmp(killer, "starvation") ? "" :
X!  		!strcmp(killer, "strangulation") ? "" :
X  		!strncmp(killer, "Mr.", 3) ? "" :
X  		!strncmp(killer, "Ms.", 3) ? "" :
X  		index(vowels, *killer) ? " an" : " a");
X--- 48,55 ----
X  	center(7, buf);
X  	Sprintf(buf, "killed by%s",
X  		!strncmp(killer, "the ", 4) ? "" :
X! 		(!strcmp(eos(killer)-4, "tion") && *(eos(killer)-5)!='o') ? "" :
X! 		!strcmp(killer, "contaminated water") ? "" :
X  		!strncmp(killer, "Mr.", 3) ? "" :
X  		!strncmp(killer, "Ms.", 3) ? "" :
X  		index(vowels, *killer) ? " an" : " a");
X*** src/Old/rnd.c	Wed Sep  6 16:01:12 1989
X--- src/rnd.c	Thu Aug 17 23:21:18 1989
X***************
X*** 33,39 ****
X  
X  int
X  rnl(x)		/* 0 <= rnl(x) < x; somtimes subtracting Luck */
X! register x;	/* good luck approaches 0, bad luck approaches (x-1) */
X  {
X  	register int i = RND(x);
X  
X--- 33,39 ----
X  
X  int
X  rnl(x)		/* 0 <= rnl(x) < x; somtimes subtracting Luck */
X! register int x;	/* good luck approaches 0, bad luck approaches (x-1) */
X  {
X  	register int i = RND(x);
X  
X*** src/Old/save.c	Wed Sep  6 16:01:41 1989
X--- src/save.c	Sat Sep  2 15:01:18 1989
X***************
X*** 452,462 ****
X  void
X  bwrite(fd, loc, num)
X  register int fd;
X! register genericptr_t loc;
X  register unsigned num;
X  {
X        bwritefd = fd;
X!       for (; num; num--, ((char *)loc)++) {
X  	      if (*((char *)loc) == RLESC) { /* One more char in run */
X  		  if (++outrunlength == 0xFF) {
X  		      flushoutrun(outrunlength);
X--- 452,462 ----
X  void
X  bwrite(fd, loc, num)
X  register int fd;
X! genericptr_t loc;
X  register unsigned num;
X  {
X        bwritefd = fd;
X!       for (; num; num--, (*(char **)&loc)++) {
X  	      if (*((char *)loc) == RLESC) { /* One more char in run */
X  		  if (++outrunlength == 0xFF) {
X  		      flushoutrun(outrunlength);
X***************
X*** 685,691 ****
X  char *from, *to;
X  {
X  #ifdef TOS
X- 	extern int _copyfile();
X  
X  	if (_copyfile(from, to))
X  		panic("Can't copy %s to %s\n", from, to);
X--- 685,690 ----
X*** src/Old/search.c	Wed Sep  6 16:02:07 1989
X--- src/search.c	Tue Sep  5 12:07:13 1989
X***************
X*** 158,164 ****
X  				    return(1);
X  				}
X  				trap->tseen = 1;
X! 				if(!vism_at(x,y)) atl(x,y,(char) TRAP_SYM);
X  			    }
X  		    }
X  		}
X--- 158,166 ----
X  				    return(1);
X  				}
X  				trap->tseen = 1;
X! 				if(!vism_at(x,y))
X! 					atl(x,y,(char) ((trap->ttyp==WEB)
X! 						? WEB_SYM : TRAP_SYM));
X  			    }
X  		    }
X  		}
X*** src/Old/shk.c	Wed Sep  6 16:02:26 1989
X--- src/shk.c	Thu Aug 31 14:46:56 1989
X***************
X*** 704,713 ****
X  			}
X  
X  			if (invent) {
X- 			    levl[ox][oy].omask = 1;
X  			    for(otmp = invent; otmp; otmp = otmp->nobj) {
X! 				otmp->ox = ox;
X! 				otmp->oy = oy;
X  				otmp->age = 0;
X  			    }
X  
X--- 704,711 ----
X  			}
X  
X  			if (invent) {
X  			    for(otmp = invent; otmp; otmp = otmp->nobj) {
X! 				place_object(otmp, ox, oy);
X  				otmp->age = 0;
X  			    }
X  
X***************
X*** 1298,1309 ****
X  
X  void
X  pay_for_door(x,y,dmgstr)
X! register int x, y;
X! register char *dmgstr;
X  {
X! 	register struct monst *mtmp;
X! 	register int roomno = inroom(x, y);
X! 	register int damage = (ACURR(A_STR) > 18) ? 400 : 20 * ACURR(A_STR);
X  
X  	/* make sure this function is not used in the wrong place */
X  	if(!(IS_DOOR(levl[x][y].typ) && in_shop(x, y))) return;
X--- 1296,1307 ----
X  
X  void
X  pay_for_door(x,y,dmgstr)
X! int x, y;
X! char *dmgstr;
X  {
X! 	struct monst *mtmp;
X! 	int roomno = inroom(x, y);
X! 	register int damage;
X  
X  	/* make sure this function is not used in the wrong place */
X  	if(!(IS_DOOR(levl[x][y].typ) && in_shop(x, y))) return;
X***************
X*** 1351,1360 ****
X  	shopkeeper->my = y;
X  	pmon(shopkeeper);
X  
X! 	if(um_dist(x, y, 1)) goto chase;
X  
X! 	if(u.ugold < (long) damage || !rn2(50)) {
X! chase:
X  		if(um_dist(x, y, 1))
X  		    pline("%s shouts: \"Who dared %s my door?\"",
X  				shkname(shopkeeper), dmgstr);
X--- 1349,1357 ----
X  	shopkeeper->my = y;
X  	pmon(shopkeeper);
X  
X! 	damage = (ACURR(A_STR) > 18) ? 400 : 20 * ACURR(A_STR);
X  
X! 	if(um_dist(x, y, 1) || u.ugold < (long) damage || !rn2(50)) {
X  		if(um_dist(x, y, 1))
X  		    pline("%s shouts: \"Who dared %s my door?\"",
X  				shkname(shopkeeper), dmgstr);
X*** src/Old/spell.c	Wed Sep  6 16:04:23 1989
X--- src/spell.c	Fri Aug 25 01:39:36 1989
X***************
X*** 128,135 ****
X  register struct obj *spellbook;
X  {
X  	register int	 booktype = spellbook->otyp;
X- 	register boolean oops	  = !spellbook->blessed && (spellbook->cursed ||
X- rn2(20) > (ACURR(A_INT) + 4 + (int)(u.ulevel/2) - 2*objects[booktype].spl_lev));
X  
X  	if (delay && spellbook == book)
X  		You("continue your efforts to memorize the spell.");
X--- 128,133 ----
X***************
X*** 194,200 ****
X  		return(0);
X  	}
X  
X! 		if (oops) {
X  			cursed_book(objects[booktype].spl_lev);
X  			nomul(delay);			/* study time */
X  			delay = 0;
X--- 192,201 ----
X  		return(0);
X  	}
X  
X! 		if(!spellbook->blessed &&
X! 			(spellbook->cursed ||
X! 			    rn2(20) > (ACURR(A_INT) + 4 + (int)(u.ulevel/2)
X! 					- 2*objects[booktype].spl_lev))) {
X  			cursed_book(objects[booktype].spl_lev);
X  			nomul(delay);			/* study time */
X  			delay = 0;
X*** src/Old/steal.c	Wed Sep  6 16:04:58 1989
X--- src/steal.c	Sun Aug 20 14:26:37 1989
X***************
X*** 242,254 ****
X  	register struct obj *otmp, *otmp2;
X  
X  	for(otmp = mtmp->minvent; otmp; otmp = otmp2){
X! 		otmp->ox = mtmp->mx;
X! 		otmp->oy = mtmp->my;
X  		otmp2 = otmp->nobj;
X  		otmp->nobj = fobj;
X  		if (flooreffects(otmp,mtmp->mx,mtmp->my)) continue;
X  		fobj = otmp;
X- 		levl[otmp->ox][otmp->oy].omask = 1;
X  		stackobj(fobj);
X  		if(show & cansee(mtmp->mx,mtmp->my))
X  			atl(otmp->ox,otmp->oy,Hallucination?rndobjsym() : otmp->olet);
X--- 242,252 ----
X  	register struct obj *otmp, *otmp2;
X  
X  	for(otmp = mtmp->minvent; otmp; otmp = otmp2){
X! 		place_object(otmp, mtmp->mx, mtmp->my);
X  		otmp2 = otmp->nobj;
X  		otmp->nobj = fobj;
X  		if (flooreffects(otmp,mtmp->mx,mtmp->my)) continue;
X  		fobj = otmp;
X  		stackobj(fobj);
X  		if(show & cansee(mtmp->mx,mtmp->my))
X  			atl(otmp->ox,otmp->oy,Hallucination?rndobjsym() : otmp->olet);
X*** src/Old/termcap.c	Wed Sep  6 16:05:17 1989
X--- src/termcap.c	Mon Aug 28 16:34:14 1989
X***************
X*** 63,79 ****
X  startup()
X  {
X  #ifdef TERMLIB
X! 	register char *term;
X  	register char *tptr;
X  	char *tbufptr, *pc;
X  #endif
X  	register int i;
X  
X  #ifdef TERMLIB
X! 	if(!(term = getenv("TERM")))
X  #endif
X! #if defined(TOS) && defined(__GNUC__)	/* library has a default */
X! 		term = "st52";
X  #else
X  # ifdef ANSI_DEFAULT
X  #  ifdef TOS
X--- 63,124 ----
X  startup()
X  {
X  #ifdef TERMLIB
X! 	register char *term = getenv("TERM");
X  	register char *tptr;
X  	char *tbufptr, *pc;
X  #endif
X  	register int i;
X  
X+ 	/* Set the default map symbols */
X+ 	(void) memcpy((genericptr_t) &showsyms, 
X+ 		(genericptr_t) &defsyms, sizeof(struct symbols));
X+ 
X+ #if !defined(AMIGA) && !defined(TOS)
X+ # if defined(TERMLIB) || !(defined(DECRAINBOW) || defined(OS2))
X+ #  define IBMXASCII
X+ # endif
X+ #endif
X+ 
X+ #ifdef IBMXASCII
X+ 	/*
X+ 	 * If we're on an IBM box, default to the nice IBM Extended ASCII
X+ 	 * line-drawing characters (codepage 437).
X+ 	 *
X+ 	 * OS/2 defaults to a multilingual character set (codepage 850,
X+ 	 * corresponding to the ISO 8859 character set.  We should probably
X+ 	 * do a VioSetCp() call to set the codepage to 437.
X+ 	 *
X+ 	 * Someday we should do a full terminfo(4) check for ACS forms
X+ 	 * characters.
X+ 	 */
X+ # if !defined(MSDOS) || defined(DECRAINBOW) || defined(OS2)
X+ 	if (strncmp("AT", term, 2) == 0)
X+ # endif
X+ 	{
X+ 	    showsyms.vwall = 0xb3;	/* meta-3, vertical rule */
X+ 	    showsyms.hwall = 0xc4;	/* meta-D, horizontal rule */
X+ 	    showsyms.tlcorn = 0xda;	/* meta-Z, top left corner */
X+ 	    showsyms.trcorn = 0xbf;	/* meta-?, top right corner */
X+ 	    showsyms.blcorn = 0xc0;	/* meta-@, bottom left */
X+ 	    showsyms.brcorn = 0xd9;	/* meta-Y, bottom right */
X+ 	    showsyms.crwall = 0xc5;	/* meta-E, cross */
X+ 	    showsyms.tuwall = 0xc1;	/* meta-A, T up */
X+ 	    showsyms.tdwall = 0xc2;	/* meta-B, T down */
X+ 	    showsyms.tlwall = 0xb4;	/* meta-4, T left */
X+ 	    showsyms.trwall = 0xc3;	/* meta-C, T right */
X+ 	    showsyms.vbeam = 0xb3;	/* meta-3, vertical rule */
X+ 	    showsyms.hbeam = 0xc4;	/* meta-D, horizontal rule */
X+ 	    showsyms.room = 0xfa;	/* meta-z, centered dot */
X+ 	    showsyms.pool = 0xf7;	/* meta-w, approx. equals */
X+ 	}
X+ #endif /* IBMXASCII */
X+ #undef IBMXASCII
X+ 
X  #ifdef TERMLIB
X! 	if(!term)
X  #endif
X! #if defined(TOS) && defined(__GNUC__) && defined(TERMLIB)
X! 		term = "st52";		/* library has a default */
X  #else
X  # ifdef ANSI_DEFAULT
X  #  ifdef TOS
X***************
X*** 568,573 ****
X--- 613,619 ----
X  {
X  	int erret;
X  	char *setf, *scratch;
X+ 	register int c;
X  	extern int setupterm();
X  	extern char *tparm(), *tigetstr();
X  
X*** src/Old/timeout.c	Wed Sep  6 16:05:46 1989
X--- src/timeout.c	Sun Aug 20 14:26:38 1989
X***************
X*** 131,137 ****
X  			/* call this only when a move took place.  */
X  			/* otherwise handle fumbling msgs locally. */
X  			if (!Levitation && u.umoved) {
X! 			    if (levl[u.ux][u.uy].omask)
X  				You("trip over something.");
X  			    else
X  				switch (rn2(4)) {
X--- 131,137 ----
X  			/* call this only when a move took place.  */
X  			/* otherwise handle fumbling msgs locally. */
X  			if (!Levitation && u.umoved) {
X! 			    if (OBJ_AT(u.ux, u.uy))
X  				You("trip over something.");
X  			    else
X  				switch (rn2(4)) {
X*** src/Old/topten.c	Wed Sep  6 16:06:17 1989
X--- src/topten.c	Fri Sep  1 14:31:03 1989
X***************
X*** 11,20 ****
X  #include <fcntl.h>	/* Ralf Brown */
X  #endif
X  
X- static char *itoa P((int)), *ordin P((int));
X- static void outheader();
X- static int outentry P((int,struct toptenentry *,int));
X- 
X  #define newttentry() (struct toptenentry *) alloc(sizeof(struct toptenentry))
X  #define	NAMSZ	10
X  #define	DTHSZ	60
X--- 11,16 ----
X***************
X*** 36,41 ****
X--- 32,41 ----
X  	char date[7];		/* yymmdd */
X  } *tt_head;
X  
X+ static char *itoa P((int)), *ordin P((int));
X+ static void outheader();
X+ static int outentry P((int,struct toptenentry *,int));
X+ 
X  void
X  topten(){
X  	int uid = getuid();
X***************
X*** 339,345 ****
X  	      t1->maxlvl);
X  #ifdef ENDGAME
X  	} else if(!strncmp("ascended", t1->death, 8)) {
X! 	   Strcat(linebuf, "ascended to demigod-hood");
X  #endif
X  	} else {
X  	  if(!strncmp(t1->death,"quit",4)) {
X--- 339,347 ----
X  	      t1->maxlvl);
X  #ifdef ENDGAME
X  	} else if(!strncmp("ascended", t1->death, 8)) {
X! 	   Strcat(linebuf, "ascended to demigod");
X! 	   if (t1->sex == 'F') Strcat(linebuf, "dess");
X! 	   Strcat(linebuf, "-hood");
X  #endif
X  	} else {
X  	  if(!strncmp(t1->death,"quit",4)) {
X***************
X*** 376,382 ****
X  	if(iskilled) Sprintf(eos(linebuf), " by %s%s",
X  	  (!strncmp(t1->death, "trick", 5) || !strncmp(t1->death, "the ", 4)
X  	   || !strncmp(t1->death, "Mr. ", 4) || !strncmp(t1->death, "Ms. ", 4)
X! 	   || !strncmp(eos(t1->death)-5, "ation", 5)
X  	   ) ? "" :
X  	  index(vowels,*t1->death) ? "an " : "a ",
X  	  t1->death);
X--- 378,385 ----
X  	if(iskilled) Sprintf(eos(linebuf), " by %s%s",
X  	  (!strncmp(t1->death, "trick", 5) || !strncmp(t1->death, "the ", 4)
X  	   || !strncmp(t1->death, "Mr. ", 4) || !strncmp(t1->death, "Ms. ", 4)
X! 	   || !strcmp(t1->death, "contaminated water")
X! 	   || (!strncmp(eos(t1->death)-4,"tion",4) && *(eos(t1->death)-5)!='o')
X  	   ) ? "" :
X  	  index(vowels,*t1->death) ? "an " : "a ",
X  	  t1->death);
X***************
X*** 689,696 ****
X  		return((struct obj *) 0);
X  	} else {
X  		otmp->corpsenm = classmon(tt->plchar, (tt->sex == 'F'));
X! 		otmp->owt = mons[otmp->corpsenm].cwt;
X  		otmp = oname(otmp, tt->name, 0);
X  		free((genericptr_t) tt);
X  		return otmp;
X  	}
X--- 692,701 ----
X  		return((struct obj *) 0);
X  	} else {
X  		otmp->corpsenm = classmon(tt->plchar, (tt->sex == 'F'));
X! 		otmp->owt = weight(otmp);
X! 		/* Note: oname() is safe since otmp is first in chain */
X  		otmp = oname(otmp, tt->name, 0);
X+ 		fobj = otmp;
X  		free((genericptr_t) tt);
X  		return otmp;
X  	}
X*** src/Old/trap.c	Wed Sep  6 16:06:59 1989
X--- src/trap.c	Sat Sep  2 15:05:29 1989
X***************
X*** 31,37 ****
X  		case 0:
X  		case 2: vulnerable = is_flammable(otmp); break;
X  		case 1: vulnerable = is_rustprone(otmp); break;
X! 		case 3: vulnerable = (otmp->otyp == BRONZE_PLATE_MAIL); break;
X  	}
X  
X  	if (!print && (!vulnerable || otmp->rustfree || otmp->spe < -2))
X--- 31,37 ----
X  		case 0:
X  		case 2: vulnerable = is_flammable(otmp); break;
X  		case 1: vulnerable = is_rustprone(otmp); break;
X! 		case 3: vulnerable = is_corrodeable(otmp); break;
X  	}
X  
X  	if (!print && (!vulnerable || otmp->rustfree || otmp->spe < -2))
X***************
X*** 78,84 ****
X  		break;
X  	    case STATUE_TRAP:	    /* create a "living" statue */
X  		ttmp->pm = rndmonnum();
X! 		(void) mkstatue(&mons[ttmp->pm], x, y);
X  		break;
X  	    default:
X  		ttmp->pm = -1;
X--- 78,84 ----
X  		break;
X  	    case STATUE_TRAP:	    /* create a "living" statue */
X  		ttmp->pm = rndmonnum();
X! 		(void) mkcorpstat(STATUE, &mons[ttmp->pm], x, y);
X  		break;
X  	    default:
X  		ttmp->pm = -1;
X***************
X*** 201,207 ****
X  		    pline("A bear trap closes on your %s!",
X  			body_part(FOOT));
X  #ifdef POLYSELF
X! 		    if(u.umonnum == PM_OWLBEAR)
X  			You("howl in anger!");
X  #endif
X  		    break;
X--- 201,207 ----
X  		    pline("A bear trap closes on your %s!",
X  			body_part(FOOT));
X  #ifdef POLYSELF
X! 		    if(u.umonnum == PM_OWLBEAR || u.umonnum == PM_BUGBEAR)
X  			You("howl in anger!");
X  #endif
X  		    break;
X***************
X*** 305,311 ****
X  		    break;
X  		case TELEP_TRAP:
X  		    if(trap->once) {
X- 			deltrap(trap);
X  #ifdef ENDGAME
X  			if(dlevel == ENDLEVEL) {
X  			    You("feel a wrenching sensation.");
X--- 305,310 ----
X***************
X*** 316,321 ****
X--- 315,321 ----
X  			    shieldeff(u.ux, u.uy);
X  			    You("feel a wrenching sensation.");
X  			} else {
X+ 			    deltrap(trap);
X  			    newsym(u.ux, u.uy);
X  			    vtele();
X  			}
X***************
X*** 625,631 ****
X  	/* A bug fix for dumb messages by ab@unido.
X  	 */
X  	    int in_sight = cansee(mtmp->mx,mtmp->my)
X! 			   && (!mtmp->minvis || See_invisible || Telepat);
X  
X  	    if(mtmp->mtrapseen & (1 << tt)) {
X  		/* he has been in such a trap - perhaps he escapes */
X--- 625,631 ----
X  	/* A bug fix for dumb messages by ab@unido.
X  	 */
X  	    int in_sight = cansee(mtmp->mx,mtmp->my)
X! 			   && (!mtmp->minvis || See_invisible);
X  
X  	    if(mtmp->mtrapseen & (1 << tt)) {
X  		/* he has been in such a trap - perhaps he escapes */
X***************
X*** 639,645 ****
X  				  pline("%s is caught in a bear trap!",
X  					Monnam(mtmp));
X  				else
X! 				    if(mtmp->data == &mons[PM_OWLBEAR]
X  					&& flags.soundok)
X  			    You("hear the roaring of an angry bear!");
X  				mtmp->mtrapped = 1;
X--- 639,646 ----
X  				  pline("%s is caught in a bear trap!",
X  					Monnam(mtmp));
X  				else
X! 				    if((mtmp->data == &mons[PM_OWLBEAR]
X! 					|| mtmp->data == &mons[PM_BUGBEAR])
X  					&& flags.soundok)
X  			    You("hear the roaring of an angry bear!");
X  				mtmp->mtrapped = 1;
X***************
X*** 894,900 ****
X  		default:
X  			dotrap(trap);
X  	}
X! 	if(!flags.nopick && (levl[u.ux][u.uy].omask || levl[u.ux][u.uy].gmask))
X  	    pickup(1);
X  	return 0;
X  }
X--- 895,901 ----
X  		default:
X  			dotrap(trap);
X  	}
X! 	if(!flags.nopick && (OBJ_AT(u.ux, u.uy) || levl[u.ux][u.uy].gmask))
X  	    pickup(1);
X  	return 0;
X  }
X***************
X*** 962,968 ****
X  	u.uy = nuy;
X  #ifdef POLYSELF
X  	if (hides_under(uasmon))
X! 		u.uundetected = (levl[nux][nuy].omask || levl[nux][nuy].gmask);
X  	else 
X  		u.uundetected = 0;
X  	if (u.usym == S_MIMIC_DEF) u.usym = S_MIMIC;
X--- 963,969 ----
X  	u.uy = nuy;
X  #ifdef POLYSELF
X  	if (hides_under(uasmon))
X! 		u.uundetected = (OBJ_AT(nux, nuy) || levl[nux][nuy].gmask);
X  	else 
X  		u.uundetected = 0;
X  	if (u.usym == S_MIMIC_DEF) u.usym = S_MIMIC;
X***************
X*** 1071,1079 ****
X  		impossible("Where are your chain and ball??");
X  		return;
X  	}
X! 	uball->ox = uchain->ox = u.ux;
X! 	uball->oy = uchain->oy = u.uy;
X! 	levl[u.ux][u.uy].omask = 1;
X  	if(attach){
X  		uchain->nobj = fobj;
X  		fobj = uchain;
X--- 1072,1079 ----
X  		impossible("Where are your chain and ball??");
X  		return;
X  	}
X! 	place_object(uball, u.ux, u.uy);
X! 	place_object(uchain, u.ux, u.uy);
X  	if(attach){
X  		uchain->nobj = fobj;
X  		fobj = uchain;
X***************
X*** 1170,1175 ****
X--- 1170,1178 ----
X  		dlevel = 0;
X  		killer = "long fall";
X  		done(DIED);
X+ #ifdef WIZARD
X+ 		return;  
X+ #endif
X  #ifdef WALKIES
X  	    } else {
X  		You("shudder for a moment...");
X***************
X*** 1252,1263 ****
X  	     case 19:
X  		    /* tame nearby monsters */
X  		   {   register int i,j;
X- 		       register boolean confused = (Confusion != 0);
X- 		       register int bd = confused ? 5 : 1;
X  
X  		       /* below pline added by GAN 10/30/86 */
X  		       adjattrib(A_CHA,1,FALSE);
X! 		       for(i = -bd; i <= bd; i++) for(j = -bd; j <= bd; j++)
X  		       if(levl[u.ux+i][u.uy+j].mmask)
X  			   (void) tamedog(m_at(u.ux+i, u.uy+j), (struct obj *)0);
X  		       break;
X--- 1255,1264 ----
X  	     case 19:
X  		    /* tame nearby monsters */
X  		   {   register int i,j;
X  
X  		       /* below pline added by GAN 10/30/86 */
X  		       adjattrib(A_CHA,1,FALSE);
X! 		       for(i = -1; i <= 1; i++) for(j = -1; j <= 1; j++)
X  		       if(levl[u.ux+i][u.uy+j].mmask)
X  			   (void) tamedog(m_at(u.ux+i, u.uy+j), (struct obj *)0);
X  		       break;
X***************
X*** 1266,1292 ****
X  	     case 20:
X  		    /* uncurse stuff */
X  		   {  register struct obj *obj;
X- 		      register boolean confused = (Confusion != 0);
X  
X  			/* below plines added by GAN 10/30/86 */
X! 			if (confused)
X! 			    if (Hallucination)
X! 				You("feel the power of the Force against you!");
X! 			    else
X! 				You("feel like you need some help.");
X  			else
X! 			    if (Hallucination)
X! 				You("feel in touch with the Universal Oneness.");
X! 			    else
X! 				You("feel like someone is helping you.");
X! 		       for(obj = invent; obj ; obj = obj->nobj)
X! 			       if(obj->owornmask)
X! 				    if(confused)
X! 					curse(obj);
X! 				    else
X  					obj->cursed = 0;
X! 		       if(Punished && !confused)
X! 			    unpunish();
X  		       break;
X  		   }
X  	     default: break;
X--- 1267,1282 ----
X  	     case 20:
X  		    /* uncurse stuff */
X  		   {  register struct obj *obj;
X  
X  			/* below plines added by GAN 10/30/86 */
X! 			if (Hallucination)
X! 			    You("feel in touch with the Universal Oneness.");
X  			else
X! 			    You("feel like someone is helping you.");
X! 			for(obj = invent; obj ; obj = obj->nobj)
X! 			       if(obj->owornmask || obj->otyp == LOADSTONE)
X  					obj->cursed = 0;
X! 		       if(Punished) unpunish();
X  		       break;
X  		   }
X  	     default: break;
X***************
X*** 1375,1381 ****
X  	y = u.uy + u.dy;
X  
X  	if(!u.dx && !u.dy) {
X! 	    if(levl[x][y].omask)
X  		for(otmp = fobj; otmp; otmp = otmp->nobj)
X  		    if((otmp->ox == x) && (otmp->oy == y))
X  			if(Is_box(otmp)) {
X--- 1365,1371 ----
X  	y = u.uy + u.dy;
X  
X  	if(!u.dx && !u.dy) {
X! 	    if(OBJ_AT(x, y))
X  		for(otmp = fobj; otmp; otmp = otmp->nobj)
X  		    if((otmp->ox == x) && (otmp->oy == y))
X  			if(Is_box(otmp)) {
X***************
X*** 1660,1671 ****
X  		}
X  	}
X  	if (obj && (!strike || d_override)) {
X! 		obj->ox = mon->mx;
X! 		obj->oy = mon->my;
X  		obj->nobj = fobj;
X  		fobj = obj;
X  		stackobj(fobj);
X- 		levl[obj->ox][obj->oy].omask = 1;
X  	} else if (obj) free ((genericptr_t)obj);
X  
X  	return trapkilled;
X--- 1650,1659 ----
X  		}
X  	}
X  	if (obj && (!strike || d_override)) {
X! 		place_object(obj, mon->mx, mon->my);
X  		obj->nobj = fobj;
X  		fobj = obj;
X  		stackobj(fobj);
X  	} else if (obj) free ((genericptr_t)obj);
X  
X  	return trapkilled;
X*** src/Old/u_init.c	Wed Sep  6 16:08:03 1989
X--- src/u_init.c	Sun Sep  3 11:54:51 1989
X***************
X*** 182,188 ****
X  #else
X  #  define W_MULTEND	5
X  #endif
X! 	{ DAGGER, 0, WEAPON_SYM, 1, 1, 1 },	/* for dealing with ghosts */
X  	{ CLOAK_OF_MAGIC_RESISTANCE, 0, ARMOR_SYM, 1, 1, UNDEF_BLESS },
X  	{ UNDEF_TYP, UNDEF_SPE, WAND_SYM, 1, 1, UNDEF_BLESS },
X  	{ UNDEF_TYP, UNDEF_SPE, RING_SYM, 2, 1, UNDEF_BLESS },
X--- 182,188 ----
X  #else
X  #  define W_MULTEND	5
X  #endif
X! 	{ ATHAME, 1, WEAPON_SYM, 1, 1, 1 },	/* for dealing with ghosts */
X  	{ CLOAK_OF_MAGIC_RESISTANCE, 0, ARMOR_SYM, 1, 1, UNDEF_BLESS },
X  	{ UNDEF_TYP, UNDEF_SPE, WAND_SYM, 1, 1, UNDEF_BLESS },
X  	{ UNDEF_TYP, UNDEF_SPE, RING_SYM, 2, 1, UNDEF_BLESS },
X***************
X*** 498,504 ****
X  		ini_inv(Wishing);
X  #endif
X  	find_ac();			/* get initial ac value */
X! 	init_attr((pick != 'y') ? 69 : 72);	/* init attribute values */
X  	max_rank_sz();			/* set max str size for class ranks */
X  /*
X   *	Do we really need this?
X--- 498,504 ----
X  		ini_inv(Wishing);
X  #endif
X  	find_ac();			/* get initial ac value */
X! 	init_attr((pick != 'Y') ? 69 : 72);	/* init attribute values */
X  	max_rank_sz();			/* set max str size for class ranks */
X  /*
X   *	Do we really need this?
X***************
X*** 507,512 ****
X--- 507,513 ----
X  	    if(!rn2(20)) {
X  		register int xd = rn2(7) - 2;	/* biased variation */
X  		adjattrib(i, xd, TRUE);
X+ 		if (ABASE(i) < AMAX(i)) AMAX(i) = ABASE(i);
X  	    }
X  
X  	/* make sure he can carry all he has - especially for T's */
X*** src/Old/uhitm.c	Wed Sep  6 16:08:46 1989
X--- src/uhitm.c	Wed Sep  6 11:54:03 1989
X***************
X*** 96,102 ****
X  		if (!(Blind ? Telepat : (HTelepat & WORN_HELMET))) {
X  		    register struct obj *obj;
X  
X! 		    if(levl[mtmp->mx][mtmp->my].omask == 1) {
X  			if(obj = o_at(mtmp->mx,mtmp->my))
X  				pline("Wait!  There's %s hiding under %s!",
X  					defmonnam(mtmp), doname(obj));
X--- 96,103 ----
X  		if (!(Blind ? Telepat : (HTelepat & WORN_HELMET))) {
X  		    register struct obj *obj;
X  
X! 		    if(Blind) pline("Wait!  There's a hidden monster there!");
X! 		    else if(OBJ_AT(mtmp->mx, mtmp->my)) {
X  			if(obj = o_at(mtmp->mx,mtmp->my))
X  				pline("Wait!  There's %s hiding under %s!",
X  					defmonnam(mtmp), doname(obj));
X***************
X*** 284,290 ****
X  int tmp;
X  {
X  	static int malive;
X! 	boolean mhit = !((tmp <= rnd(20)) && !u.uswallow);
X  
X  	malive = known_hitum(mon, mhit);
X  	(void) passive(mon, mhit, malive, FALSE);
X--- 285,291 ----
X  int tmp;
X  {
X  	static int malive;
X! 	boolean mhit = (tmp > rnd(20) || u.uswallow);
X  
X  	malive = known_hitum(mon, mhit);
X  	(void) passive(mon, mhit, malive, FALSE);
X***************
X*** 460,465 ****
X--- 461,467 ----
X  			if(mon->msleep) mon->msleep = 0;
X  			setmangry(mon);
X  			mon->mcansee = 0;
X+ 			tmp = rnd(25) + 20;
X  			if((mon->mblinded + tmp) > 127) mon->mblinded = 127;
X  			else mon->mblinded += tmp;
X  			hittxt = TRUE;
X***************
X*** 628,633 ****
X--- 630,637 ----
X  		mdef->mstun = 1;
X  		/* fall through to next case */
X  	    case AD_WERE:	    /* no effect on monsters */
X+ 	    case AD_HEAL:
X+ 	    case AD_LEGS:
X  	    case AD_PHYS:
X  		if(mattk->aatyp == AT_WEAP) {
X  			if(uwep) tmp = 0;
X***************
X*** 709,715 ****
X  				if (!stolen && otmp==stealoid) {
X  					if(isize < 52) {
X  						otmp = addinv(otmp);
X! 						isize++;
X  					} else dropy(otmp);
X  					stealoid = otmp;
X  					stolen = TRUE;
X--- 713,720 ----
X  				if (!stolen && otmp==stealoid) {
X  					if(isize < 52) {
X  						otmp = addinv(otmp);
X! 						/* might not increase isize */
X! 						isize = inv_cnt();
X  					} else dropy(otmp);
X  					stealoid = otmp;
X  					stolen = TRUE;
X***************
X*** 716,725 ****
X  				} else {
X  					if(isize < 52) {
X  						otmp = addinv(otmp);
X! 						isize++;
X! 					} else dropy(otmp);
X! 					You("steal: ");
X! 					prinv(otmp);
X  				}
X  			}
X  			if (!stolen)
X--- 721,733 ----
X  				} else {
X  					if(isize < 52) {
X  						otmp = addinv(otmp);
X! 						isize = inv_cnt();
X! 						You("steal: ");
X! 						prinv(otmp);
X! 					} else {
X! 						dropy(otmp);
X! 						You("steal %s.", doname(otmp));
X! 					}
X  				}
X  			}
X  			if (!stolen)
X***************
X*** 727,733 ****
X  			else {
X  				kludge("%s finishes taking off his suit.",
X  							Monnam(mdef));
X! 				You("steal a %s.", xname(stealoid));
X  # ifdef ARMY
X  				mdef->data = &mons[PM_UNARMORED_SOLDIER];
X  # endif
X--- 735,741 ----
X  			else {
X  				kludge("%s finishes taking off his suit.",
X  							Monnam(mdef));
X! 				You("steal %s!", doname(stealoid));
X  # ifdef ARMY
X  				mdef->data = &mons[PM_UNARMORED_SOLDIER];
X  # endif
X***************
X*** 735,744 ****
X  		   } else {
X  		   	   otmp = mdef->minvent;
X  			   mdef->minvent = otmp->nobj;
X! 			   if(isize < 52) otmp = addinv(otmp);
X! 			   else dropy(otmp);
X! 			   You("steal: ");
X! 			   prinv(otmp);
X  		   }
X  		}
X  		tmp = 0;
X--- 743,756 ----
X  		   } else {
X  		   	   otmp = mdef->minvent;
X  			   mdef->minvent = otmp->nobj;
X! 			   if(isize < 52) {
X! 				otmp = addinv(otmp);
X! 				You("steal: ");
X! 				prinv(otmp);
X! 			   } else {
X! 				dropy(otmp);
X! 				You("steal %s.", doname(otmp));
X! 			   }
X  		   }
X  		}
X  		tmp = 0;
X***************
X*** 789,795 ****
X  			kludge("%s suddenly seems weaker!", Monnam(mdef));
X  			mdef->mhpmax -= xtmp;
X  			if ((mdef->mhp -= xtmp) <= 0 || !mdef->m_lev--) {
X! 				kludge("%s dies.", Monnam(mdef));
X  				xkilled(mdef,0);
X  				return(2);
X  			}
X--- 801,807 ----
X  			kludge("%s suddenly seems weaker!", Monnam(mdef));
X  			mdef->mhpmax -= xtmp;
X  			if ((mdef->mhp -= xtmp) <= 0 || !mdef->m_lev--) {
X! 				kludge("%s dies!", Monnam(mdef));
X  				xkilled(mdef,0);
X  				return(2);
X  			}
X***************
X*** 837,842 ****
X--- 849,860 ----
X  		if (!sticks(mdef->data))
X  		    u.ustuck = mdef; /* it's now stuck to you */
X  		break;
X+ 	    case AD_PLYS:
X+ 		if (!mdef->mfroz && !rn2(3) && tmp < mdef->mhp) {
X+ 		    if (!Blind) pline("%s is frozen by you!", Monnam(mdef));
X+ 		    mdef->mfroz = 1;
X+ 		}
X+ 		break;
X  	    default:	tmp = 0;
X  			break;
X  	}
X***************
X*** 1059,1065 ****
X  	 * attack.  Is this really desirable?
X  	 */
X  			if(uwep) tmp += hitval(uwep, mon->data);
X! 			dhit = !((tmp <= rnd(20)) && !u.uswallow);
X  			/* Enemy dead, before any special abilities used */
X  			if (!known_hitum(mon,dhit)) return 0;
X  			/* Do not print "You hit" message, since known_hitum
X--- 1077,1083 ----
X  	 * attack.  Is this really desirable?
X  	 */
X  			if(uwep) tmp += hitval(uwep, mon->data);
X! 			dhit = (tmp > rnd(20) || u.uswallow);
X  			/* Enemy dead, before any special abilities used */
X  			if (!known_hitum(mon,dhit)) return 0;
X  			/* Do not print "You hit" message, since known_hitum
X*** src/Old/unixmain.c	Wed Sep  6 16:09:59 1989
X--- src/unixmain.c	Fri Aug 25 15:14:07 1989
X***************
X*** 66,74 ****
X  		    error("Flag -d must be followed by a directory name.");
X  	}
X  #endif /* CHDIR /**/
X! 	/* Set the default values of the presentation characters */
X! 	(void) memcpy((genericptr_t) &showsyms,
X! 		(genericptr_t) &defsyms, sizeof(struct symbols));
X  	initoptions();
X  	whoami();
X  	/*
X--- 66,81 ----
X  		    error("Flag -d must be followed by a directory name.");
X  	}
X  #endif /* CHDIR /**/
X! 
X! 	/*
X! 	 *  Remember tty modes, to be restored on exit.
X! 	 *
X! 	 *  Note that getty() must be called before startup() due to ordering
X! 	 *  of LI/CO settings, and startup() must be called before initoptions()
X! 	 *  due to ordering of graphics settings.
X! 	 */
X! 	gettty();
X! 	startup();
X  	initoptions();
X  	whoami();
X  	/*
X***************
X*** 80,96 ****
X  		chdirx(dir,0);
X  #endif
X  		prscore(argc, argv);
X  		exit(0);
X  	}
X  
X  	/*
X  	 * It seems he really wants to play.
X- 	 * Remember tty modes, to be restored on exit.
X  	 */
X- 	gettty();
X  	setbuf(stdout,obuf);
X  	setrandom();
X- 	startup();
X  	cls();
X  	u.uhp = 1;	/* prevent RIP on early quits */
X  	u.ux = FAR;	/* prevent nscr() */
X--- 87,102 ----
X  		chdirx(dir,0);
X  #endif
X  		prscore(argc, argv);
X+ 		getret();
X+ 		settty(NULL);
X  		exit(0);
X  	}
X  
X  	/*
X  	 * It seems he really wants to play.
X  	 */
X  	setbuf(stdout,obuf);
X  	setrandom();
X  	cls();
X  	u.uhp = 1;	/* prevent RIP on early quits */
X  	u.ux = FAR;	/* prevent nscr() */
X*** src/Old/vault.c	Wed Sep  6 16:10:50 1989
X--- src/vault.c	Thu Aug 31 14:47:54 1989
X***************
X*** 146,154 ****
X  
X  int
X  gd_move(){
X! 	register int x, y, dx, dy, gx, gy, nx, ny, typ, i;
X! 	register struct fakecorridor *fcp;
X  	register struct rm *crm;
X  	if(!guard || gdlevel != dlevel){
X  		impossible("Where is the guard?");
X  		return(2);	/* died */
X--- 146,156 ----
X  
X  int
X  gd_move(){
X! 	int x, y, nx, ny;
X! 	int dx, dy, gx, gy, typ, i;
X! 	struct fakecorridor *fcp;
X  	register struct rm *crm;
X+ 
X  	if(!guard || gdlevel != dlevel){
X  		impossible("Where is the guard?");
X  		return(2);	/* died */
X*** src/Old/version.c	Wed Sep  6 16:11:20 1989
X--- src/version.c	Mon Aug 21 12:24:19 1989
X***************
X*** 5,11 ****
X  #include	"hack.h"
X  #include	"date.h"
X  #ifndef BETA
X! #include	"patchlevel.h"
X  #endif
X  
X  int
X--- 5,15 ----
X  #include	"hack.h"
X  #include	"date.h"
X  #ifndef BETA
X! #ifdef MSDOS
X! # include	"patchlev.h"
X! #else
X! # include	"patchlevel.h"
X! #endif
X  #endif
X  
X  int
X*** src/Old/weapon.c	Wed Sep  6 16:11:53 1989
X--- src/weapon.c	Thu Aug 31 15:17:40 1989
X***************
X*** 38,43 ****
X--- 38,45 ----
X  	    case ORCISH_DAGGER:
X  #endif
X  	    case DAGGER:
X+ 	    case SCALPEL:
X+ 	    case ATHAME:
X  	    case SHURIKEN:		tmp += 2; break;
X  #ifdef WORM
X  	    case CRYSKNIFE:		tmp += 3; break;
X***************
X*** 83,89 ****
X  #ifdef TOLKIEN
X  		case ELVEN_BROADSWORD:
X  #endif
X! 		case BROADSWORD:	tmp += 1; break;
X  
X  		case FLAIL:
X  		case RANSEUR:
X--- 85,91 ----
X  #ifdef TOLKIEN
X  		case ELVEN_BROADSWORD:
X  #endif
X! 		case BROADSWORD:	tmp++; break;
X  
X  		case FLAIL:
X  		case RANSEUR:
X***************
X*** 107,115 ****
X  	    switch (otmp->otyp) {
X  		case CROSSBOW_BOLT:
X  		case MACE:
X  		case FLAIL:
X  		case SPETUM:
X! 		case TRIDENT:		tmp += 1; break;
X  
X  		case BARDICHE:
X  		case BILL_GUISARME:
X--- 109,118 ----
X  	    switch (otmp->otyp) {
X  		case CROSSBOW_BOLT:
X  		case MACE:
X+ 		case WAR_HAMMER:
X  		case FLAIL:
X  		case SPETUM:
X! 		case TRIDENT:		tmp++; break;
X  
X  		case BARDICHE:
X  		case BILL_GUISARME:
X***************
X*** 225,234 ****
X  #endif
X  		  break;
X  		case WP_SLING:
X! 		  no_propellor = (m_carrying(mtmp, SLING) != 0);
X  		  break;
X  		case WP_CROSSBOW:
X! 		  no_propellor = (m_carrying(mtmp, CROSSBOW) != 0);
X  		}
X  	      }
X  	    if (!no_propellor) {
X--- 228,237 ----
X  #endif
X  		  break;
X  		case WP_SLING:
X! 		  no_propellor = !(m_carrying(mtmp, SLING));
X  		  break;
X  		case WP_CROSSBOW:
X! 		  no_propellor = !(m_carrying(mtmp, CROSSBOW));
X  		}
X  	      }
X  	    if (!no_propellor) {
X***************
X*** 268,275 ****
X  #ifdef KOPS
X  	  {RUBBER_HOSE,0},
X  #endif /* KOPS */
X! 	  {ELVEN_DAGGER,0}, {DAGGER,0}, {ORCISH_DAGGER,0}, {SCALPEL,0},
X! 	  {KNIFE,0},
X  #ifdef WORM
X  	  {WORM_TOOTH,0},
X  #endif
X--- 271,278 ----
X  #ifdef KOPS
X  	  {RUBBER_HOSE,0},
X  #endif /* KOPS */
X! 	  {WAR_HAMMER,0}, {ELVEN_DAGGER,0}, {DAGGER,0}, {ORCISH_DAGGER,0},
X! 	  {ATHAME,0}, {SCALPEL,0}, {KNIFE,0},
X  #ifdef WORM
X  	  {WORM_TOOTH,0},
X  #endif
X***************
X*** 291,297 ****
X  #ifdef KOPS
X  	  {RUBBER_HOSE,0},
X  #endif /* KOPS */
X! 	  {DAGGER,0}, {SCALPEL,0}, {KNIFE,0},
X  #ifdef WORM
X  	  {WORM_TOOTH,0},
X  #endif
X--- 294,300 ----
X  #ifdef KOPS
X  	  {RUBBER_HOSE,0},
X  #endif /* KOPS */
X! 	  {WAR_HAMMER,0}, {DAGGER,0}, {ATHAME,0}, {SCALPEL,0}, {KNIFE,0},
X  #ifdef WORM
X  	  {WORM_TOOTH,0},
X  #endif
X*** src/Old/were.c	Wed Sep  6 16:12:27 1989
X--- src/were.c	Tue Sep  5 22:05:15 1989
X***************
X*** 22,49 ****
X  	    } else if(!rn2(30)) new_were(mon);
X  }
X  
X  void
X  new_were(mon)
X  register struct monst *mon;
X  {
X! 	int pm;
X! 
X! 	switch((pm = monsndx(mon->data))) {
X  
X! 	    case PM_WEREWOLF:	pm = PM_WOLFWERE;
X! 				break;
X! 	    case PM_WOLFWERE:	pm = PM_WEREWOLF;
X! 				break;
X! 	    case PM_WEREJACKAL:	pm = PM_JACKALWERE;
X! 				break;
X! 	    case PM_JACKALWERE:	pm = PM_WEREJACKAL;
X! 				break;
X! 	    case PM_WERERAT:	pm = PM_RATWERE;
X! 				break;
X! 	    case PM_RATWERE:	pm = PM_WERERAT;
X! 				break;
X! 	    default:	impossible("unknown lycanthrope %s.", mon->data->mname);
X! 			return;
X  	}
X  
X  	if(canseemon(mon))
X--- 22,52 ----
X  	    } else if(!rn2(30)) new_were(mon);
X  }
X  
X+ static int
X+ counter_were(pm)
X+ int pm;
X+ {
X+ 	switch(pm) {
X+ 	    case PM_WEREWOLF:	return(PM_WOLFWERE);
X+ 	    case PM_WOLFWERE:	return(PM_WEREWOLF);
X+ 	    case PM_WEREJACKAL:	return(PM_JACKALWERE);
X+ 	    case PM_JACKALWERE:	return(PM_WEREJACKAL);
X+ 	    case PM_WERERAT:	return(PM_RATWERE);
X+ 	    case PM_RATWERE:	return(PM_WERERAT);
X+ 	    default:		return(0);
X+ 	}
X+ }
X+ 
X  void
X  new_were(mon)
X  register struct monst *mon;
X  {
X! 	register int pm;
X  
X! 	pm = counter_were(monsndx(mon->data));
X! 	if(!pm) {
X! 	    impossible("unknown lycanthrope %s.", mon->data->mname);
X! 	    return;
X  	}
X  
X  	if(canseemon(mon))
X*** src/Old/worm.c	Wed Sep  6 16:13:11 1989
X--- src/worm.c	Thu Aug 31 14:48:45 1989
X***************
X*** 146,158 ****
X  
X  void
X  cutworm(mtmp, x, y, weptyp)
X! register struct monst *mtmp;
X! register xchar x,y;
X! register unsigned weptyp;		/* uwep->otyp or 0 */
X  {
X  	register struct wseg *wtmp, *wtmp2;
X! 	register struct monst *mtmp2;
X! 	register int tmp, tmp2;
X  
X  	if(mtmp->mx == x && mtmp->my == y) return;	/* hit headon */
X  
X--- 146,158 ----
X  
X  void
X  cutworm(mtmp, x, y, weptyp)
X! struct monst *mtmp;
X! xchar x,y;
X! unsigned weptyp;		/* uwep->otyp or 0 */
X  {
X  	register struct wseg *wtmp, *wtmp2;
X! 	struct monst *mtmp2;
X! 	int tmp, tmp2;
X  
X  	if(mtmp->mx == x && mtmp->my == y) return;	/* hit headon */
X  
X*** src/Old/worn.c	Wed Sep  6 16:13:43 1989
X--- src/worn.c	Fri Sep  1 14:31:53 1989
X***************
X*** 5,11 ****
X  #include "hack.h"
X  
X  static const char crispy[] = "The flames of Hell burn you to a crisp.";
X! static void set_armor_intrinsic P((struct obj *,boolean));
X  
X  const struct worn {
X  	long w_mask;
X--- 5,11 ----
X  #include "hack.h"
X  
X  static const char crispy[] = "The flames of Hell burn you to a crisp.";
X! static void set_armor_intrinsic P((struct obj *,long,BOOLEAN_P));
X  
X  const struct worn {
X  	long w_mask;
X***************
X*** 49,55 ****
X  		    u.uprops[objects[oobj->otyp].oc_oprop].p_flgs = 
X  			    u.uprops[objects[oobj->otyp].oc_oprop].p_flgs & 
X  				~wp->w_mask;
X! 		    set_armor_intrinsic(oobj, 0);
X  		}
X  		*(wp->w_obj) = obj;
X  		if(obj) {
X--- 49,55 ----
X  		    u.uprops[objects[oobj->otyp].oc_oprop].p_flgs = 
X  			    u.uprops[objects[oobj->otyp].oc_oprop].p_flgs & 
X  				~wp->w_mask;
X! 		    set_armor_intrinsic(oobj, wp->w_mask, 0);
X  		}
X  		*(wp->w_obj) = obj;
X  		if(obj) {
X***************
X*** 57,63 ****
X  		    u.uprops[objects[obj->otyp].oc_oprop].p_flgs = 
X  			    u.uprops[objects[obj->otyp].oc_oprop].p_flgs | 
X  				wp->w_mask;
X! 		    set_armor_intrinsic(obj, 1);
X  		}
X  	}
X  	/* A kludge to solve the problem of someone gaining fire resistance
X--- 57,63 ----
X  		    u.uprops[objects[obj->otyp].oc_oprop].p_flgs = 
X  			    u.uprops[objects[obj->otyp].oc_oprop].p_flgs | 
X  				wp->w_mask;
X! 		    set_armor_intrinsic(obj, wp->w_mask, 1);
X  		}
X  	}
X  	/* A kludge to solve the problem of someone gaining fire resistance
X***************
X*** 98,104 ****
X  				u.uprops[objects[obj->otyp].oc_oprop].p_flgs & 
X  					~wp->w_mask;
X  			obj->owornmask &= ~wp->w_mask;
X! 			set_armor_intrinsic(obj, 0);
X  		}
X  	/* See comments above in setworn().  The major difference is the
X  	 * need to check AMULET_SYM so if someone goes to Hell without
X--- 98,104 ----
X  				u.uprops[objects[obj->otyp].oc_oprop].p_flgs & 
X  					~wp->w_mask;
X  			obj->owornmask &= ~wp->w_mask;
X! 			set_armor_intrinsic(obj, wp->w_mask, 0);
X  		}
X  	/* See comments above in setworn().  The major difference is the
X  	 * need to check AMULET_SYM so if someone goes to Hell without
X***************
X*** 129,136 ****
X  }
X  
X  static void
X! set_armor_intrinsic(obj,on)
X  register struct obj *obj;
X  boolean on;
X  {
X  	long *mask;
X--- 129,137 ----
X  }
X  
X  static void
X! set_armor_intrinsic(obj,maskbit,on)
X  register struct obj *obj;
X+ long maskbit;	/* people can do funny things like wield armor */
X  boolean on;
X  {
X  	long *mask;
X***************
X*** 162,167 ****
X  		default:
X  			return;
X  	}
X! 	if (on) *mask |= WORN_ARMOR;
X! 	else *mask &= ~WORN_ARMOR;
X  }
X--- 163,168 ----
X  		default:
X  			return;
X  	}
X! 	if (on) *mask |= maskbit;
X! 	else *mask &= ~maskbit;
X  }
X*** src/Old/write.c	Wed Sep  6 16:14:24 1989
X--- src/write.c	Wed Aug 30 18:39:58 1989
X***************
X*** 39,44 ****
X--- 39,45 ----
X  	case SCR_ENCHANT_ARMOR:
X  	case SCR_REMOVE_CURSE:
X  	case SCR_ENCHANT_WEAPON:
X+ 	case SCR_CHARGING:
X  		return(16);
X  /*		break; */
X  	case SCR_SCARE_MONSTER:
X*** src/Old/zap.c	Wed Sep  6 16:14:59 1989
X--- src/zap.c	Tue Sep  5 21:34:29 1989
X***************
X*** 33,39 ****
X  
X  	"blast of missiles",	/* Dragon breath equivalents 20-29*/
X  	"blast of fire",
X! 	"blast of sleeping gas",
X  	"blast of frost",
X  	"blast of disintegration",
X  	"blast of lightning",
X--- 33,39 ----
X  
X  	"blast of missiles",	/* Dragon breath equivalents 20-29*/
X  	"blast of fire",
X! 	"blast of sleep gas",
X  	"blast of frost",
X  	"blast of disintegration",
X  	"blast of lightning",
X***************
X*** 582,588 ****
X  #ifdef POLYSELF
X  		    polyself();
X  #else
X! 		    You("shudder for a moment.");
X  #endif
X  		    break;
X  		case WAN_CANCELLATION:
X--- 582,588 ----
X  #ifdef POLYSELF
X  		    polyself();
X  #else
X! 		    newman();
X  #endif
X  		    break;
X  		case WAN_CANCELLATION:
X***************
X*** 723,729 ****
X  				(void)close_drawbridge(u.ux, u.uy);
X  		    else
X  #endif
X! 		    if (levl[u.ux][u.uy].omask) {
X  			register struct obj *otmp,*otmp2;
X  
X  			/* changed by GAN to hit all objects there */
X--- 723,729 ----
X  				(void)close_drawbridge(u.ux, u.uy);
X  		    else
X  #endif
X! 		    if (OBJ_AT(u.ux, u.uy)) {
X  			register struct obj *otmp,*otmp2;
X  
X  			/* changed by GAN to hit all objects there */
X***************
X*** 781,791 ****
X  			if(u.uswallow) {
X  				register struct monst *mtmp = u.ustuck;
X  
X! 				You("pierce %s's stomach wall!",
X! 					mon_nam(mtmp));
X  				mtmp->mhp = 1;	/* almost dead */
X! 				unstuck(mtmp);
X! 				mnexto(mtmp);
X  				break;
X  			}
X  			if(u.dz) {
X--- 781,789 ----
X  			if(u.uswallow) {
X  				register struct monst *mtmp = u.ustuck;
X  
X! 				You("pierce %s's stomach wall!", mon_nam(mtmp));
X  				mtmp->mhp = 1;	/* almost dead */
X! 				regurgitates(mtmp);
X  				break;
X  			}
X  			if(u.dz) {
X***************
X*** 982,988 ****
X  			range -= 3;
X  		}
X  		/* modified by GAN to hit all objects */
X! 		if(fhito && levl[bhitpos.x][bhitpos.y].omask){
X  		    int hitanything = 0;
X  		    otmp = fobj;
X  		    /* Fix for polymorph bug, Tim Wright */
X--- 980,986 ----
X  			range -= 3;
X  		}
X  		/* modified by GAN to hit all objects */
X! 		if(fhito && OBJ_AT(bhitpos.x, bhitpos.y)){
X  		    int hitanything = 0;
X  		    otmp = fobj;
X  		    /* Fix for polymorph bug, Tim Wright */
X***************
X*** 1198,1204 ****
X  	register struct obj *obj, *obj2;
X  	register int scrquan, i, cnt = 0;
X  
X! 	if(levl[x][y].omask)
X  	for(obj = fobj; obj; obj = obj2) {
X  	    obj2 = obj->nobj;
X  	    /* Bug fix - KAA */
X--- 1196,1202 ----
X  	register struct obj *obj, *obj2;
X  	register int scrquan, i, cnt = 0;
X  
X! 	if(OBJ_AT(x, y))
X  	for(obj = fobj; obj; obj = obj2) {
X  	    obj2 = obj->nobj;
X  	    /* Bug fix - KAA */
X***************
X*** 1392,1398 ****
X  			   break;
X  			}
X  		}
X! 		if(levl[sx][sy].omask && abstype == 1)
X  			if(burn_floor_scrolls(sx,sy) && cansee(sx,sy))  {
X  			    mnewsym(sx,sy);
X  			    if(!Blind)
X--- 1390,1396 ----
X  			   break;
X  			}
X  		}
X! 		if(OBJ_AT(sx, sy) && abstype == 1)
X  			if(burn_floor_scrolls(sx,sy) && cansee(sx,sy))  {
X  			    mnewsym(sx,sy);
X  			    if(!Blind)
X***************
X*** 1616,1627 ****
X  		tx = rn1(COLNO-3,2);
X  		ty = rn2(ROWNO);
X  	} while(!goodpos(tx,ty,(struct permonst *)0));
X! 	obj->ox = tx;
X! 	obj->oy = ty;
X! 	set_omask(otx,oty);
X  	if(cansee(otx,oty))
X  		newsym(otx,oty);
X- 	levl[tx][ty].omask = 1;
X  	if(cansee(tx,ty))
X  		newsym(tx,ty);
X  }
X--- 1614,1622 ----
X  		tx = rn1(COLNO-3,2);
X  		ty = rn2(ROWNO);
X  	} while(!goodpos(tx,ty,(struct permonst *)0));
X! 	move_object(obj, tx, ty);
X  	if(cansee(otx,oty))
X  		newsym(otx,oty);
X  	if(cansee(tx,ty))
X  		newsym(tx,ty);
X  }
X
END_OF_FILE
if test 55124 -ne `wc -c <'patch03f'`; then
    echo shar: \"'patch03f'\" unpacked with wrong size!
fi
# end of 'patch03f'
fi
echo shar: End of archive 6 \(of 6\).
cp /dev/null ark6isdone
MISSING=""
for I in 1 2 3 4 5 6 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 6 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
