Path: utzoo!utgpu!jarvis.csri.toronto.edu!mailrus!csd4.csd.uwm.edu!cs.utexas.edu!uunet!zephyr.ens.tek.com!tekgen!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v08i020:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Patch3e
Message-ID: <4539@tekred.CNA.TEK.COM>
Date: 7 Sep 89 21:51:14 GMT
Sender: nobody@tekred.CNA.TEK.COM
Lines: 2133
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 8, Issue 20
Archive-name: NetHack3/Patch3e
Patch-To: NetHack3: Volume 7, Issue 56-93

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 5 (of 6)."
# Contents:  patch03e
# Wrapped by billr@saab on Thu Sep  7 14:39:17 1989
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'patch03e' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'patch03e'\"
else
echo shar: Extracting \"'patch03e'\" \(55646 characters\)
sed "s/^X//" >'patch03e' <<'END_OF_FILE'
X*** src/Old/mkroom.c	Wed Sep  6 16:34:25 1989
X--- src/mkroom.c	Sat Aug 26 18:37:04 1989
X***************
X*** 237,243 ****
X  			break;
X  		    case MORGUE:
X  			if(!rn2(5))
X! 			    (void) mk_tt_corpse(sx, sy);
X  			if(!rn2(10))	/* lots of treasure buried with dead */
X  			    (void) mksobj_at((rn2(3)) ? LARGE_BOX : CHEST, sx, sy);
X  			break;
X--- 237,243 ----
X  			break;
X  		    case MORGUE:
X  			if(!rn2(5))
X! 			    (void) mk_tt_object(CORPSE, sx, sy);
X  			if(!rn2(10))	/* lots of treasure buried with dead */
X  			    (void) mksobj_at((rn2(3)) ? LARGE_BOX : CHEST, sx, sy);
X  			break;
X***************
X*** 295,301 ****
X  		sroom->rtype = SWAMP;
X  		for(sx = sroom->lx; sx <= sroom->hx; sx++)
X  		for(sy = sroom->ly; sy <= sroom->hy; sy++)
X! 		if(levl[sx][sy].omask == 0 && levl[sx][sy].gmask == 0 &&
X  		   levl[sx][sy].mmask == 0 &&
X  		   !t_at(sx,sy) && !nexttodoor(sx,sy)) {
X  		    if((sx+sy)%2) {
X--- 295,301 ----
X  		sroom->rtype = SWAMP;
X  		for(sx = sroom->lx; sx <= sroom->hx; sx++)
X  		for(sy = sroom->ly; sy <= sroom->hy; sy++)
X! 		if(!OBJ_AT(sx, sy) && levl[sx][sy].gmask == 0 &&
X  		   levl[sx][sy].mmask == 0 &&
X  		   !t_at(sx,sy) && !nexttodoor(sx,sy)) {
X  		    if((sx+sy)%2) {
X***************
X*** 333,343 ****
X  
X  	yy -= dy;
X  	if(ACCESSIBLE(levl[xx-1][yy].typ))
X! 		(void) mkstatue(&mons[PM_FOREST_CENTAUR], xx-1, yy);
X  	if(ACCESSIBLE(levl[xx][yy].typ))
X! 		(void) mkstatue(&mons[PM_MOUNTAIN_CENTAUR], xx, yy);
X  	if(ACCESSIBLE(levl[xx+1][yy].typ))
X! 		(void) mkstatue(&mons[PM_PLAINS_CENTAUR], xx+1, yy);
X  # ifdef FOUNTAINS
X  	mkfount(0,sroom);
X  # endif
X--- 333,343 ----
X  
X  	yy -= dy;
X  	if(ACCESSIBLE(levl[xx-1][yy].typ))
X! 		(void) mkcorpstat(STATUE, &mons[PM_FOREST_CENTAUR], xx-1, yy);
X  	if(ACCESSIBLE(levl[xx][yy].typ))
X! 		(void) mkcorpstat(STATUE, &mons[PM_MOUNTAIN_CENTAUR], xx, yy);
X  	if(ACCESSIBLE(levl[xx+1][yy].typ))
X! 		(void) mkcorpstat(STATUE, &mons[PM_PLAINS_CENTAUR], xx+1, yy);
X  # ifdef FOUNTAINS
X  	mkfount(0,sroom);
X  # endif
X*** src/Old/mon.c	Wed Sep  6 16:34:46 1989
X--- src/mon.c	Fri Sep  1 19:53:54 1989
X***************
X*** 90,96 ****
X  		obj->owt = weight(obj);
X  		break;
X  	    case PM_STONE_GOLEM:
X! 		obj = mkstatue(mdat, x, y);
X  		break;
X  	    case PM_WOOD_GOLEM:
X  		pieces = d(2,4);
X--- 90,96 ----
X  		obj->owt = weight(obj);
X  		break;
X  	    case PM_STONE_GOLEM:
X! 		obj = mkcorpstat(STATUE, mdat, x, y);
X  		break;
X  	    case PM_WOOD_GOLEM:
X  		pieces = d(2,4);
X***************
X*** 106,112 ****
X  	    default:
X  		if (mdat->geno & G_NOCORPSE)
X  			return (struct obj *)0;
X! 		else obj = mkcorpse_at(mdat, x, y);
X  		break;
X  	}
X  	/* All special cases should precede the G_NOCORPSE check */
X--- 106,112 ----
X  	    default:
X  		if (mdat->geno & G_NOCORPSE)
X  			return (struct obj *)0;
X! 		else obj = mkcorpstat(CORPSE, mdat, x, y);
X  		break;
X  	}
X  	/* All special cases should precede the G_NOCORPSE check */
X***************
X*** 275,281 ****
X  	register struct obj *otmp;
X  
X  	/* Eats gold if it is there */
X! 	while(gold = g_at(mtmp->mx, mtmp->my)){
X  		if (cansee(mtmp->mx, mtmp->my) && flags.verbose)
X  			pline("%s eats some gold!", Monnam(mtmp));
X  		mtmp->meating = (int)((gold->amount + 500L)/1000L);
X--- 275,281 ----
X  	register struct obj *otmp;
X  
X  	/* Eats gold if it is there */
X! 	if(gold = g_at(mtmp->mx, mtmp->my)){
X  		if (cansee(mtmp->mx, mtmp->my) && flags.verbose)
X  			pline("%s eats some gold!", Monnam(mtmp));
X  		mtmp->meating = (int)((gold->amount + 500L)/1000L);
X***************
X*** 287,293 ****
X  	/* Eats topmost metal object if it is there */
X  	for (otmp = fobj; otmp; otmp = otmp->nobj)
X  	    if (otmp->ox == mtmp->mx && otmp->oy == mtmp->my &&
X! 		objects[otmp->otyp].oc_material == METAL) {
X  		    if (cansee(mtmp->mx,mtmp->my) && flags.verbose)
X  			pline("%s eats %s!", Monnam(mtmp),
X  				distant_name(otmp,doname));
X--- 287,294 ----
X  	/* Eats topmost metal object if it is there */
X  	for (otmp = fobj; otmp; otmp = otmp->nobj)
X  	    if (otmp->ox == mtmp->mx && otmp->oy == mtmp->my &&
X! 		objects[otmp->otyp].oc_material > WOOD &&
X! 		objects[otmp->otyp].oc_material < MINERAL) {
X  		    if (cansee(mtmp->mx,mtmp->my) && flags.verbose)
X  			pline("%s eats %s!", Monnam(mtmp),
X  				distant_name(otmp,doname));
X***************
X*** 299,313 ****
X  			mtmp->mhp += objects[otmp->otyp].oc_weight;
X  			if (mtmp->mhp > mtmp->mhpmax) mtmp->mhp = mtmp->mhpmax;
X  		    }
X! 		    if((uball && otmp == uball) ||
X! 		       (uchain && otmp == uchain)) unpunish();
X! 		    freeobj(otmp);
X  		    /* Left behind a pile? */
X  		    if(rnd(25) < 3) (void) mksobj_at(ROCK, mtmp->mx, mtmp->my);
X  		    newsym(mtmp->mx, mtmp->my);
X  		    break;
X  	    }
X- 	set_omask(mtmp->mx, mtmp->my);
X  }
X  
X  void
X--- 300,317 ----
X  			mtmp->mhp += objects[otmp->otyp].oc_weight;
X  			if (mtmp->mhp > mtmp->mhpmax) mtmp->mhp = mtmp->mhpmax;
X  		    }
X! 		    if(otmp == uball) {
X! 			unpunish();
X! 			freeobj(otmp);
X! 		    } else if(otmp == uchain)
X! 			unpunish();	/* frees uchain */
X! 		    else
X! 			freeobj(otmp);
X  		    /* Left behind a pile? */
X  		    if(rnd(25) < 3) (void) mksobj_at(ROCK, mtmp->mx, mtmp->my);
X  		    newsym(mtmp->mx, mtmp->my);
X  		    break;
X  	    }
X  }
X  
X  void
X***************
X*** 317,323 ****
X  	register struct obj *otmp, *otmp2;
X  
X  	/* Eats organic, glass, or wood objects if there */
X! 	/* Engulfs anything else, metal and rock */
X  	for (otmp = fobj; otmp; otmp = otmp2) {
X  	    otmp2 = otmp->nobj;
X  	    if (otmp->ox == mtmp->mx && otmp->oy == mtmp->my) {
X--- 321,327 ----
X  	register struct obj *otmp, *otmp2;
X  
X  	/* Eats organic, glass, or wood objects if there */
X! 	/* Engulfs others, except huge rocks and metal attached to player */
X  	for (otmp = fobj; otmp; otmp = otmp2) {
X  	    otmp2 = otmp->nobj;
X  	    if (otmp->ox == mtmp->mx && otmp->oy == mtmp->my) {
X***************
X*** 333,339 ****
X  			if (mtmp->mhp > mtmp->mhpmax) mtmp->mhp = mtmp->mhpmax;
X  		    }
X  		    delobj(otmp);		/* munch */
X! 		} else if (otmp->olet != ROCK_SYM && otmp->olet != BALL_SYM) {
X  		    if (cansee(mtmp->mx, mtmp->my) && flags.verbose)
X  			pline("%s engulfs %s.", Monnam(mtmp),
X  				distant_name(otmp,doname));
X--- 337,344 ----
X  			if (mtmp->mhp > mtmp->mhpmax) mtmp->mhp = mtmp->mhpmax;
X  		    }
X  		    delobj(otmp);		/* munch */
X! 		} else if (otmp->olet != ROCK_SYM &&
X! 					otmp != uball && otmp != uchain) {
X  		    if (cansee(mtmp->mx, mtmp->my) && flags.verbose)
X  			pline("%s engulfs %s.", Monnam(mtmp),
X  				distant_name(otmp,doname));
X***************
X*** 344,350 ****
X  	    /* Engulf & devour is instant, so don't set meating */
X  	    newsym(mtmp->mx, mtmp->my);
X  	}
X- 	set_omask(mtmp->mx, mtmp->my);
X  }
X  
X  void
X--- 349,354 ----
X***************
X*** 353,359 ****
X  {
X  	register struct gold *gold;
X  
X! 	while(gold = g_at(mtmp->mx, mtmp->my)){
X  		mtmp->mgold += gold->amount;
X  		if (cansee(mtmp->mx, mtmp->my) && flags.verbose)
X  			pline("%s picks up some gold.", Monnam(mtmp));
X--- 357,363 ----
X  {
X  	register struct gold *gold;
X  
X! 	if(gold = g_at(mtmp->mx, mtmp->my)){
X  		mtmp->mgold += gold->amount;
X  		if (cansee(mtmp->mx, mtmp->my) && flags.verbose)
X  			pline("%s picks up some gold.", Monnam(mtmp));
X***************
X*** 361,367 ****
X  		if(levl[mtmp->mx][mtmp->my].scrsym == GOLD_SYM)
X  			newsym(mtmp->mx, mtmp->my);
X  	}
X- 	set_omask(mtmp->mx, mtmp->my);
X  }
X  
X  /* Now includes giants which pick up enormous rocks.  KAA */
X--- 365,370 ----
X***************
X*** 385,391 ****
X  		newsym(mtmp->mx, mtmp->my);
X  		return;	/* pick only one object */
X  	      }
X- 	set_omask(mtmp->mx, mtmp->my);
X  }
X  
X  int
X--- 388,393 ----
X***************
X*** 474,480 ****
X  		mpickobj(mtmp, otmp);
X  		if(index(str, (char) levl[mtmp->mx][mtmp->my].scrsym))
X  			newsym(mtmp->mx, mtmp->my);
X- 		set_omask(mtmp->mx, mtmp->my);
X  		return;			/* pick only one object */
X  	    }
X  }
X--- 476,481 ----
X***************
X*** 771,776 ****
X--- 772,778 ----
X  			u.ux = mtmp->mx;
X  			u.uy = mtmp->my;
X  			u.uswallow = 0;
X+ 			u.uswldtim = 0;
X  			setsee();
X  			docrt();
X  		}
X***************
X*** 1059,1073 ****
X  	mtmp->minvis = !!(mdat->mlet == S_STALKER);
X  	mtmp->mhide = !!hides_under(mdat);
X  	if (!mtmp->mhide) mtmp->mundetected = 0;
X! 	if (u.ustuck == mtmp
X  #ifdef POLYSELF
X! 			&& !sticks(uasmon)
X  #endif
X! 			&& !sticks(mdat))
X! 		u.ustuck = 0;
X  #ifdef WORM
X  	if(mdat == &mons[PM_LONG_WORM] && getwn(mtmp)) initworm(mtmp);
X- 			/* perhaps we should clear mtmp->mtame here? */
X  #endif
X  	unpmon(mtmp);	/* necessary for 'I' and to force pmon */
X  	pmon(mtmp);
X--- 1061,1087 ----
X  	mtmp->minvis = !!(mdat->mlet == S_STALKER);
X  	mtmp->mhide = !!hides_under(mdat);
X  	if (!mtmp->mhide) mtmp->mundetected = 0;
X! 	if (u.ustuck == mtmp) {
X! 		if(u.uswallow) {
X! 			if(!attacktype(mdat,AT_ENGL)) {
X! 				/* cf. digging out of monster with wand */
X! 				You("break out of %s's stomach!",
X! 					mon_nam(mtmp));
X! 				mtmp->mhp = 1;	/* almost dead */
X! 				regurgitates(mtmp);
X! 			}
X! 		} else {
X! 			if(!sticks(mdat)
X  #ifdef POLYSELF
X! 				&& !sticks(uasmon)
X  #endif
X! 				)
X! 				unstuck(mtmp);
X! 		}
X! 	}
X! 
X  #ifdef WORM
X  	if(mdat == &mons[PM_LONG_WORM] && getwn(mtmp)) initworm(mtmp);
X  #endif
X  	unpmon(mtmp);	/* necessary for 'I' and to force pmon */
X  	pmon(mtmp);
X*** src/Old/mondata.c	Wed Sep  6 16:35:40 1989
X--- src/mondata.c	Sun Aug 20 14:26:12 1989
X***************
X*** 96,104 ****
X  canseemon(mtmp)
X  	register struct monst *mtmp;
X  {
X! 	return((!mtmp->minvis || See_invisible || Telepat)
X  		&& (!mtmp->mhide ||
X! 		    (levl[mtmp->mx][mtmp->my].omask == 0 &&
X  		     levl[mtmp->mx][mtmp->my].gmask == 0))
X  		&& cansee(mtmp->mx, mtmp->my));
X  }
X--- 96,104 ----
X  canseemon(mtmp)
X  	register struct monst *mtmp;
X  {
X! 	return((!mtmp->minvis || See_invisible)
X  		&& (!mtmp->mhide ||
X! 		    (!OBJ_AT(mtmp->mx, mtmp->my) &&
X  		     levl[mtmp->mx][mtmp->my].gmask == 0))
X  		&& cansee(mtmp->mx, mtmp->my));
X  }
X***************
X*** 305,314 ****
X  int little_to_big(montype)
X  int montype;
X  {
X! 	register int *i;
X  	
X! 	for(i=grownups[0]; *i >= 0; i++)
X! 		if(montype == *i) return *(i+1);
X  	return montype;
X  }
X  
X--- 305,314 ----
X  int little_to_big(montype)
X  int montype;
X  {
X! 	register int i;
X  	
X! 	for(i=0; grownups[i][0] >= 0; i++)
X! 		if(montype == grownups[i][0]) return grownups[i][1];
X  	return montype;
X  }
X  
X***************
X*** 315,324 ****
X  int big_to_little(montype)
X  int montype;
X  {
X! 	register int *i;
X  	
X! 	for(i=grownups[0]; *i >= 0; i++)
X! 		if(montype == *(i+1)) return *i;
X  	return montype;
X  }
X  
X--- 315,324 ----
X  int big_to_little(montype)
X  int montype;
X  {
X! 	register int i;
X  	
X! 	for(i=0; grownups[i][0] >= 0; i++)
X! 		if(montype == grownups[i][1]) return grownups[i][0];
X  	return montype;
X  }
X  
X*** src/Old/monmove.c	Wed Sep  6 16:36:09 1989
X--- src/monmove.c	Sat Aug 26 16:47:10 1989
X***************
X*** 118,131 ****
X  		    sobj_at(SCR_SCARE_MONSTER, x, y) != (struct obj *)0);
X  }
X  
X  /* returns 1 if monster died moving, 0 otherwise */
X  int
X  dochug(mtmp)
X! 	register struct monst *mtmp;
X  {
X  	register struct permonst *mdat = mtmp->data;
X! 	register int tmp=0, inrange, nearby, scared, seescaryx,
X! 		seescaryy;
X  
X  /*	Pre-movement adjustments	*/
X  
X--- 118,176 ----
X  		    sobj_at(SCR_SCARE_MONSTER, x, y) != (struct obj *)0);
X  }
X  
X+ static void
X+ distfleeck(mtmp,inrange,nearby,scared)
X+ register struct monst *mtmp;
X+ int *inrange, *nearby, *scared;
X+ {
X+ 	int seescaryx, seescaryy;
X+ 
X+ 	*inrange = (dist2(mtmp->mx, mtmp->my, mtmp->mux, mtmp->muy) <=
X+ 							(BOLT_LIM * BOLT_LIM));
X+ 	*nearby = (dist2(mtmp->mx, mtmp->my, mtmp->mux, mtmp->muy) < 3);
X+ 
X+ 	/* Note: if your image is displaced, the monster sees the Elbereth
X+ 	 * at your displaced position, thus never attacking your displaced
X+ 	 * position, but possibly attacking you by accident.  If you are
X+ 	 * invisible, it sees the Elbereth at your real position, thus never
X+ 	 * running into you by accident but possibly attacking the spot
X+ 	 * where it guesses you are.
X+ 	 */
X+ 	if (Invis && !perceives(mtmp->data)) {
X+ 		seescaryx = mtmp->mux;
X+ 		seescaryy = mtmp->muy;
X+ 	} else {
X+ 		seescaryx = u.ux;
X+ 		seescaryy = u.uy;
X+ 	}
X+ 	*scared = (*nearby && onscary(seescaryx, seescaryy, mtmp));
X+ 
X+ 	if(*scared && !mtmp->mflee) {
X+ #ifdef POLYSELF
X+ 		if (!sticks(uasmon))
X+ #endif
X+ 			unstuck(mtmp);	/* monster lets go when fleeing */
X+ 		mtmp->mflee = 1;
X+ #ifdef STUPID
X+ 		if (rn2(7))
X+ 		    mtmp->mfleetim = rnd(10);
X+ 		else
X+ 		    mtmp->mfleetim = rnd(100);
X+ #else
X+ 		mtmp->mfleetim = (rn2(7) ? rnd(10) : rnd(100));
X+ #endif
X+ 	}
X+ 
X+ }
X+ 
X  /* returns 1 if monster died moving, 0 otherwise */
X  int
X  dochug(mtmp)
X! register struct monst *mtmp;
X  {
X  	register struct permonst *mdat = mtmp->data;
X! 	register int tmp=0;
X! 	int inrange, nearby, scared;
X  
X  /*	Pre-movement adjustments	*/
X  
X***************
X*** 179,218 ****
X  	if(mtmp->iswiz)
X  		(void) wiz_get_amulet(mtmp);
X  
X! 	inrange = (dist2(mtmp->mx, mtmp->my, mtmp->mux, mtmp->muy) <=
X! 							(BOLT_LIM * BOLT_LIM));
X! 	nearby = (dist2(mtmp->mx, mtmp->my, mtmp->mux, mtmp->muy) < 3);
X! 	/* Note: if your image is displaced, the monster sees the Elbereth
X! 	 * at your displaced position, thus never attacking your displaced
X! 	 * position, but possibly attacking you by accident.  If you are
X! 	 * invisible, it sees the Elbereth at your real position, thus never
X! 	 * running into you by accident but possibly attacking the spot
X! 	 * where it guesses you are.
X! 	 */
X! 	if (Invis && !perceives(mdat)) {
X! 		seescaryx = mtmp->mux;
X! 		seescaryy = mtmp->muy;
X! 	} else {
X! 		seescaryx = u.ux;
X! 		seescaryy = u.uy;
X! 	}
X! 	scared = (nearby && onscary(seescaryx, seescaryy, mtmp));
X! 
X! 	if(scared && !mtmp->mflee) {
X! #ifdef POLYSELF
X! 		if (!sticks(uasmon))
X! #endif
X! 			unstuck(mtmp);	/* monster lets go when fleeing */
X! 		mtmp->mflee = 1;
X! #ifdef STUPID
X! 		if (rn2(7))
X! 		    mtmp->mfleetim = rnd(10);
X! 		else
X! 		    mtmp->mfleetim = rnd(100);
X! #else
X! 		mtmp->mfleetim = (rn2(7) ? rnd(10) : rnd(100));
X! #endif
X! 	}
X  
X  #ifdef HARD	/* Demonic Blackmail!!! */
X  	if(nearby && is_demon(mdat) && mtmp->mpeaceful && !mtmp->mtame) {
X--- 224,231 ----
X  	if(mtmp->iswiz)
X  		(void) wiz_get_amulet(mtmp);
X  
X! 	/* check distance and scariness of attacks */
X! 	distfleeck(mtmp,&inrange,&nearby,&scared);
X  
X  #ifdef HARD	/* Demonic Blackmail!!! */
X  	if(nearby && is_demon(mdat) && mtmp->mpeaceful && !mtmp->mtame) {
X***************
X*** 245,252 ****
X  	   (!mtmp->mcansee && !rn2(4)) || mtmp->mpeaceful) {
X  
X  		tmp = m_move(mtmp, 0);
X! 		nearby = (dist(mtmp->mx, mtmp->my) < 3);	/* recalc */
X! 		scared = (nearby && onscary(seescaryx, seescaryy, mtmp));
X  		switch (tmp) {
X  
X  		    case 0:	/* no movement, but it can still attack you */
X--- 258,265 ----
X  	   (!mtmp->mcansee && !rn2(4)) || mtmp->mpeaceful) {
X  
X  		tmp = m_move(mtmp, 0);
X! 		distfleeck(mtmp,&inrange,&nearby,&scared);	/* recalc */
X! 
X  		switch (tmp) {
X  
X  		    case 0:	/* no movement, but it can still attack you */
X***************
X*** 264,283 ****
X   		    case 2:	/* monster died */
X   			return(1);
X   		}
X- 
X- 		inrange = (dist2(mtmp->mx, mtmp->my, mtmp->mux, mtmp->muy) <=
X- 							(BOLT_LIM * BOLT_LIM));
X- 		if(scared && !mtmp->mflee) {
X- 			mtmp->mflee = 1;
X- #ifdef STUPID
X- 			if (rn2(7))
X- 			    mtmp->mfleetim = rnd(10);
X- 			else
X- 			    mtmp->mfleetim = rnd(100);
X- #else
X- 			mtmp->mfleetim = (rn2(7) ? rnd(10) : rnd(100));
X- #endif
X- 		}
X  	}
X  
X  /*	Now, attack the player if possible - one attack set per monst	*/
X--- 277,282 ----
X***************
X*** 340,346 ****
X  	    if(i == 1) return(0);	/* still in trap, so didn't move */
X  	}
X  	if(mtmp->mhide &&
X! 	   (levl[mtmp->mx][mtmp->my].omask || levl[mtmp->mx][mtmp->my].gmask) &&
X  	   rn2(10))
X  	    return(0);		/* do not leave hiding place */
X  	if(mtmp->meating) {
X--- 339,345 ----
X  	    if(i == 1) return(0);	/* still in trap, so didn't move */
X  	}
X  	if(mtmp->mhide &&
X! 	   (OBJ_AT(mtmp->mx, mtmp->my) || levl[mtmp->mx][mtmp->my].gmask) &&
X  	   rn2(10))
X  	    return(0);		/* do not leave hiding place */
X  	if(mtmp->meating) {
X***************
X*** 662,668 ****
X  		if(ptr == &mons[PM_ROCK_MOLE]) meatgold(mtmp);
X  		if(likegold && (!abstain || !rn2(10))) mpickgold(mtmp);
X  	    }
X! 	    if(levl[mtmp->mx][mtmp->my].omask == 1) {
X  		/* Maybe a rock mole just ate some metal object */
X  		if(ptr == &mons[PM_ROCK_MOLE]) meatgold(mtmp);
X  		/* Maybe a cube ate just about anything */
X--- 661,667 ----
X  		if(ptr == &mons[PM_ROCK_MOLE]) meatgold(mtmp);
X  		if(likegold && (!abstain || !rn2(10))) mpickgold(mtmp);
X  	    }
X! 	    if(OBJ_AT(mtmp->mx, mtmp->my)) {
X  		/* Maybe a rock mole just ate some metal object */
X  		if(ptr == &mons[PM_ROCK_MOLE]) meatgold(mtmp);
X  		/* Maybe a cube ate just about anything */
X***************
X*** 675,681 ****
X  		    if(likerock || likegems) mpickgems(mtmp);
X  		}
X  	    }
X! 	    if(mtmp->mhide) mtmp->mundetected = (levl[mtmp->mx][mtmp->my].omask
X  					|| levl[mtmp->mx][mtmp->my].gmask);
X  
X  	    /* set also in domove(), hack.c */
X--- 674,680 ----
X  		    if(likerock || likegems) mpickgems(mtmp);
X  		}
X  	    }
X! 	    if(mtmp->mhide) mtmp->mundetected = (OBJ_AT(mtmp->mx, mtmp->my)
X  					|| levl[mtmp->mx][mtmp->my].gmask);
X  
X  	    /* set also in domove(), hack.c */
X*** src/Old/monst.c	Wed Sep  6 16:36:54 1989
X--- src/monst.c	Wed Sep  6 16:08:22 1989
X***************
X*** 72,83 ****
X  	  M2_WANDER | M2_NOLIMBS | M2_AMORPHOUS },
X  	{ "gelatinous cube", S_BLOB, 6, 6, 8, 0, 0, (G_GENO | 2),
X  	  { { AT_TUCH, AD_PLYS, 2, 4 }, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X! 	  10, 100, 0, MS_SILENT, M1_BIG | M1_NOEYES | M1_NOHANDS |
X  	  M1_FIRE_RES | M1_COLD_RES | M1_ELEC_RES | M1_SLEE_RES,
X  	  M2_WANDER | M2_HOSTILE | M2_NOLIMBS | M2_OMNIVORE },
X  	{ "quivering blob", S_BLOB, 5, 1, 8, 0, 0, (G_GENO | 2),
X  	  { { AT_TUCH, AD_PHYS, 1, 8 }, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X! 	  10, 100, 0, MS_SILENT, M1_NOEYES | M1_NOHANDS | M1_POIS_RES,
X  	  M2_WANDER | M2_HOSTILE | M2_NOLIMBS },
X  /*	cockatrice	*/
X  	{ "cockatrice", S_COCKATRICE, 5, 6, 6, 30, 0, (G_GENO | 5),
X--- 72,83 ----
X  	  M2_WANDER | M2_NOLIMBS | M2_AMORPHOUS },
X  	{ "gelatinous cube", S_BLOB, 6, 6, 8, 0, 0, (G_GENO | 2),
X  	  { { AT_TUCH, AD_PLYS, 2, 4 }, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X! 	  30, 300, 0, MS_SILENT, M1_BIG | M1_NOEYES | M1_NOHANDS |
X  	  M1_FIRE_RES | M1_COLD_RES | M1_ELEC_RES | M1_SLEE_RES,
X  	  M2_WANDER | M2_HOSTILE | M2_NOLIMBS | M2_OMNIVORE },
X  	{ "quivering blob", S_BLOB, 5, 1, 8, 0, 0, (G_GENO | 2),
X  	  { { AT_TUCH, AD_PHYS, 1, 8 }, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X! 	  20, 200, 0, MS_SILENT, M1_NOEYES | M1_NOHANDS | M1_POIS_RES,
X  	  M2_WANDER | M2_HOSTILE | M2_NOLIMBS },
X  /*	cockatrice	*/
X  	{ "cockatrice", S_COCKATRICE, 5, 6, 6, 30, 0, (G_GENO | 5),
X***************
X*** 897,903 ****
X  	  { { AT_WEAP, AD_SLEE, 1, 8 }, { AT_CLAW, AD_DREN, 0, 0 },
X  	    NO_ATTK, NO_ATTK, NO_ATTK },
X  	  35, 200, 0, MS_SILENT, M1_HUMANOID | M1_POIS | M1_COLLECT,
X! 	  M2_HOSTILE | M2_HUMAN },
X  /*	Rust Monster	*/
X  	{ "rust monster", S_RUSTMONST, 5, 18, 2, 0, 0, (G_GENO | 2),
X  	  { { AT_TUCH, AD_RUST, 0, 0 }, { AT_TUCH, AD_RUST, 0, 0 }, NO_ATTK,
X--- 897,903 ----
X  	  { { AT_WEAP, AD_SLEE, 1, 8 }, { AT_CLAW, AD_DREN, 0, 0 },
X  	    NO_ATTK, NO_ATTK, NO_ATTK },
X  	  35, 200, 0, MS_SILENT, M1_HUMANOID | M1_POIS | M1_COLLECT,
X! 	  M2_HOSTILE },
X  /*	Rust Monster	*/
X  	{ "rust monster", S_RUSTMONST, 5, 18, 2, 0, 0, (G_GENO | 2),
X  	  { { AT_TUCH, AD_RUST, 0, 0 }, { AT_TUCH, AD_RUST, 0, 0 }, NO_ATTK,
X*** src/Old/mthrowu.c	Wed Sep  6 16:38:45 1989
X--- src/mthrowu.c	Sun Aug 20 14:26:18 1989
X***************
X*** 75,86 ****
X  		create = !rn2(3);
X  	else create = 1;
X  	if (create && !flooreffects(obj,x,y)) {
X! 		obj->ox = x;
X! 		obj->oy = y;
X  		obj->nobj = fobj;
X  		fobj = obj;
X  		stackobj(fobj);
X- 		levl[x][y].omask = 1;
X  	} else free((genericptr_t)obj);
X  }
X  
X--- 75,84 ----
X  		create = !rn2(3);
X  	else create = 1;
X  	if (create && !flooreffects(obj,x,y)) {
X! 		place_object(obj, x, y);
X  		obj->nobj = fobj;
X  		fobj = obj;
X  		stackobj(fobj);
X  	} else free((genericptr_t)obj);
X  }
X  
X***************
X*** 111,123 ****
X  		tmp_at(-3, (int)AT_OBJ);
X  	}
X  	while(range-- > 0) { /* Actually the loop is always exited by break */
X  		bhitpos.x += dx;
X  		bhitpos.y += dy;
X  		if(levl[bhitpos.x][bhitpos.y].mmask) {
X  		    mtmp = m_at(bhitpos.x,bhitpos.y);
X  
X  		    if(mtmp->data->ac + 8 + obj->spe <= rnd(20)) {
X! 			miss(distant_name(singleobj,xname), mtmp);
X  			if (!range) { /* Last position; object drops */
X  			    drop_throw(singleobj, 0, mtmp->mx, mtmp->my);
X  			    break;
X--- 109,125 ----
X  		tmp_at(-3, (int)AT_OBJ);
X  	}
X  	while(range-- > 0) { /* Actually the loop is always exited by break */
X+ 		boolean vis;
X+ 
X  		bhitpos.x += dx;
X  		bhitpos.y += dy;
X+ 		vis = cansee(bhitpos.x, bhitpos.y);
X  		if(levl[bhitpos.x][bhitpos.y].mmask) {
X  		    mtmp = m_at(bhitpos.x,bhitpos.y);
X  
X  		    if(mtmp->data->ac + 8 + obj->spe <= rnd(20)) {
X! 			if (!vis) pline("It is missed.");
X! 			else miss(distant_name(singleobj,xname), mtmp);
X  			if (!range) { /* Last position; object drops */
X  			    drop_throw(singleobj, 0, mtmp->mx, mtmp->my);
X  			    break;
X***************
X*** 127,141 ****
X  			if (damage < 1) damage = 1;
X  			if (obj->otyp==ACID_VENOM && resists_acid(mtmp->data))
X  			    damage = 0;
X! 			hit(distant_name(singleobj,xname), mtmp,exclam(damage));
X  			if (obj->opoisoned) {
X! 			    if (resists_poison(mtmp->data))
X! 				kludge("The poison doesn't seem to affect %s.",
X  								mon_nam(mtmp));
X! 			    else {
X  				if (rn2(30)) damage += rnd(6);
X  				else {
X! 				    pline("The poison was deadly...");
X  				    damage = mtmp->mhp;
X  				}
X  			    }
X--- 129,147 ----
X  			if (damage < 1) damage = 1;
X  			if (obj->otyp==ACID_VENOM && resists_acid(mtmp->data))
X  			    damage = 0;
X! 			if (!vis) pline("It is hit%s", exclam(damage));
X! 			else hit(distant_name(singleobj,xname),
X! 							mtmp,exclam(damage));
X  			if (obj->opoisoned) {
X! 			    if (resists_poison(mtmp->data)) {
X! 				if (vis)
X! 				  pline("The poison doesn't seem to affect %s.",
X  								mon_nam(mtmp));
X! 			    } else {
X  				if (rn2(30)) damage += rnd(6);
X  				else {
X! 				    if (vis)
X! 					pline("The poison was deadly...");
X  				    damage = mtmp->mhp;
X  				}
X  			    }
X***************
X*** 142,161 ****
X  			}
X  			if (obj->otyp==ACID_VENOM && cansee(mtmp->mx,mtmp->my)){
X  			    if (resists_acid(mtmp->data)) {
X! 				pline("%s is unaffected.", Monnam(mtmp));
X  				damage = 0;
X! 			    } else pline("The acid burns %s!", mon_nam(mtmp));
X  			}
X  			mtmp->mhp -= damage;
X  			if(mtmp->mhp < 1) {
X! 			    if (cansee(mtmp->mx, mtmp->my))
X! 				pline("%s is killed!", Monnam(mtmp));
X  			    mondied(mtmp);
X  			}
X  
X  			if((obj->otyp == CREAM_PIE) ||
X  			   (obj->otyp == BLINDING_VENOM)) {
X! 			    if (cansee(mtmp->mx, mtmp->my))
X  				pline("%s is blinded by the %s.",
X  				      Monnam(mtmp), xname(singleobj));
X  			    if(mtmp->msleep) mtmp->msleep = 0;
X--- 148,169 ----
X  			}
X  			if (obj->otyp==ACID_VENOM && cansee(mtmp->mx,mtmp->my)){
X  			    if (resists_acid(mtmp->data)) {
X! 				pline("%s is unaffected.", vis ? Monnam(mtmp)
X! 					: "It");
X  				damage = 0;
X! 			    } else if (vis)
X! 				pline("The acid burns %s!", mon_nam(mtmp));
X! 			    else pline("It is burned!");
X  			}
X  			mtmp->mhp -= damage;
X  			if(mtmp->mhp < 1) {
X! 			    pline("%s is killed!", vis ? Monnam(mtmp) : "It");
X  			    mondied(mtmp);
X  			}
X  
X  			if((obj->otyp == CREAM_PIE) ||
X  			   (obj->otyp == BLINDING_VENOM)) {
X! 			    if (vis)
X  				pline("%s is blinded by the %s.",
X  				      Monnam(mtmp), xname(singleobj));
X  			    if(mtmp->msleep) mtmp->msleep = 0;
X***************
X*** 277,282 ****
X--- 285,305 ----
X  		if(!URETREATING(x,y) ||
X  		   !rn2(BOLT_LIM-movedist(x,mtmp->mux,y,mtmp->muy)))
X  		{
X+ 		    int savequan = otmp->quan;
X+ 		    char *verb = "throws";
X+ 
X+ 		    if (otmp->otyp == ARROW
X+ #ifdef TOLKIEN
X+ 			|| otmp->otyp == ELVEN_ARROW
X+ 			|| otmp->otyp == ORCISH_ARROW
X+ #endif
X+ 			|| otmp->otyp == CROSSBOW_BOLT) verb = "shoots";
X+ 		    otmp->quan = 1;
X+ 		    if (canseemon(mtmp))
X+ 			pline("%s %s a%s %s!", Monnam(mtmp), verb,
X+ 				index(vowels,*(xname(otmp))) ? "n" : "",
X+ 				xname(otmp));
X+ 		    otmp->quan = savequan;
X  		    m_throw(mtmp->mx, mtmp->my, sgn(tbx), sgn(tby), 
X  			movedist(mtmp->mx,mtmp->mux,mtmp->my,mtmp->muy), otmp);
X  		    if (!otmp->quan) m_useup(mtmp, otmp);
X***************
X*** 308,314 ****
X  		 * attack...
X  		 */
X  		if(!rn2(BOLT_LIM-movedist(mtmp->mx,mtmp->mux,mtmp->my,mtmp->muy))) {
X! 
X  		    m_throw(mtmp->mx, mtmp->my, sgn(tbx), sgn(tby), 
X  			movedist(mtmp->mx,mtmp->mux,mtmp->my,mtmp->muy), otmp);
X  		    nomul(0);
X--- 331,338 ----
X  		 * attack...
X  		 */
X  		if(!rn2(BOLT_LIM-movedist(mtmp->mx,mtmp->mux,mtmp->my,mtmp->muy))) {
X! 		    if (canseemon(mtmp))
X! 			pline("%s spits venom!", Monnam(mtmp));
X  		    m_throw(mtmp->mx, mtmp->my, sgn(tbx), sgn(tby), 
X  			movedist(mtmp->mx,mtmp->mux,mtmp->my,mtmp->muy), otmp);
X  		    nomul(0);
X*** src/Old/o_init.c	Wed Sep  6 15:52:19 1989
X--- src/o_init.c	Fri Sep  1 13:27:18 1989
X***************
X*** 219,225 ****
X  	mread(fd, (genericptr_t) bases, sizeof bases);
X  	mread(fd, (genericptr_t) disco, sizeof disco);
X  	mread(fd, (genericptr_t) objects, sizeof(struct objclass) * TOTAL_OBJS);
X! #ifndef MSDOS
X  	differ = (genericptr_t)&objects[0] - (genericptr_t)then;
X  #else
X  	differ = (long)&objects[0] - (long)then;
X--- 219,225 ----
X  	mread(fd, (genericptr_t) bases, sizeof bases);
X  	mread(fd, (genericptr_t) disco, sizeof disco);
X  	mread(fd, (genericptr_t) objects, sizeof(struct objclass) * TOTAL_OBJS);
X! #if !defined(MSDOS) && !defined(M_XENIX)
X  	differ = (genericptr_t)&objects[0] - (genericptr_t)then;
X  #else
X  	differ = (long)&objects[0] - (long)then;
X***************
X*** 226,232 ****
X  #endif
X  	for(i=0; i < TOTAL_OBJS; i++) {
X  		if (objects[i].oc_name) {
X! #ifndef MSDOS
X  			objects[i].oc_name += differ;
X  #else
X  			objects[i].oc_name =
X--- 226,232 ----
X  #endif
X  	for(i=0; i < TOTAL_OBJS; i++) {
X  		if (objects[i].oc_name) {
X! #if !defined(MSDOS) && !defined(M_XENIX)
X  			objects[i].oc_name += differ;
X  #else
X  			objects[i].oc_name =
X***************
X*** 234,240 ****
X  #endif
X  		}
X  		if (objects[i].oc_descr) {
X! #ifndef MSDOS
X  			objects[i].oc_descr += differ;
X  #else
X  			objects[i].oc_descr =
X--- 234,240 ----
X  #endif
X  		}
X  		if (objects[i].oc_descr) {
X! #if !defined(MSDOS) && !defined(M_XENIX)
X  			objects[i].oc_descr += differ;
X  #else
X  			objects[i].oc_descr =
X*** src/Old/objnam.c	Wed Sep  6 15:53:23 1989
X--- src/objnam.c	Tue Sep  5 21:35:34 1989
X***************
X*** 6,11 ****
X--- 6,12 ----
X  #include <ctype.h>	/* for isalpha() */
X  
X  #define	PREFIX	30
X+ #define SCHAR_MAX 127
X  
X  /*	We want the player to be able to learn what key goes in what lock.  */
X  const char *keystr[N_LOX] = { "round", "square", "triangular", "oval",
X***************
X*** 830,839 ****
X  #ifdef TUTTI_FRUTTI
X  	struct fruit *f;
X  	int ftype = current_fruit;
X- #endif
X- 	char let;
X- 	char *un, *dn, *an;
X- 	char *name=0;
X  	char fruitbuf[BUFSZ];
X  	/* We want to check for fruits last so that, for example, someone
X  	 * who names their fruit "katana" and wishes for a katana gets a real
X--- 831,836 ----
X***************
X*** 840,845 ****
X--- 837,846 ----
X  	 * one.  But, we have to keep around the old buf since in the meantime
X  	 * we have deleted "empty", "+6", etc...
X  	 */
X+ #endif
X+ 	char let;
X+ 	char *un, *dn, *an;
X+ 	char *name=0;
X  #ifdef WIZARD
X  	int fake=0;
X  #endif
X***************
X*** 886,892 ****
X--- 887,895 ----
X  		} else break;
X  	}
X  	if(!cnt) cnt = 1;		/* %% what with "gems" etc. ? */
X+ #ifdef TUTTI_FRUTTI
X  	Strcpy(fruitbuf, bp);
X+ #endif
X  	if(!strncmp(bp, "empty ", 6)) {
X  		contents = EMPTY;
X  		bp += 6;
X***************
X*** 922,927 ****
X--- 925,942 ----
X  			}
X  		}
X  	}
X+ /*
X+    otmp->spe is type schar; so we don't want spe to be any bigger or smaller.
X+    also, spe should always be positive  -- some cheaters may try to confuse
X+    atoi()
X+ */
X+ 	if (spe < 0) {
X+ 		spesgn = -1;	/* cheaters get what they deserve */
X+ 		spe = abs(spe);
X+ 	}
X+ 	if (spe > SCHAR_MAX)
X+ 		spe = SCHAR_MAX;
X+ 
X  	/* now we have the actual name, as delivered by xname, say
X  		green potions called whisky
X  		scrolls labeled "QWERTY"
X***************
X*** 1288,1294 ****
X  		if (spe > otmp->spe) spe = otmp->spe;
X  	}
X  
X! 	if (spesgn == -1) spe = -spe;
X  
X  	/* set otmp->spe.  This may, or may not, use spe... */
X  	switch (typ) {
X--- 1303,1309 ----
X  		if (spe > otmp->spe) spe = otmp->spe;
X  	}
X  
X! 	if (spesgn == -1 && spe > 0) spe = -spe;
X  
X  	/* set otmp->spe.  This may, or may not, use spe... */
X  	switch (typ) {
X***************
X*** 1322,1331 ****
X  			break;
X  		case WAN_WISHING:
X  #ifdef WIZARD
X! 			if (!wizard)
X  #endif
X! 				otmp->spe = (rn2(10) ? -1 : 0); break;
X  			/* fall through, if wizard */
X  		default: otmp->spe = spe;
X  	}
X  
X--- 1337,1360 ----
X  			break;
X  		case WAN_WISHING:
X  #ifdef WIZARD
X! 			if (!wizard) {
X  #endif
X! 				otmp->spe = (rn2(10) ? -1 : 0);
X! 				break;
X! #ifdef WIZARD
X! 			}
X! 			/* fall through (twice), if wizard */
X! #endif
X! 		case MAGIC_LAMP:
X! #ifdef WIZARD
X! 			if (!wizard) {
X! #endif
X! 				otmp->spe = 0;
X! 				break;
X! #ifdef WIZARD
X! 			}
X  			/* fall through, if wizard */
X+ #endif
X  		default: otmp->spe = spe;
X  	}
X  
X***************
X*** 1338,1349 ****
X  				otmp->corpsenm = mntmp;
X  			break;
X  		case FIGURINE:
X! 			if (!is_dlord(&mons[mntmp]) && !is_dprince(&mons[mntmp])
X! 					&& !is_human(&mons[mntmp])
X! #ifdef WORM
X! 					&& mntmp != PM_LONG_WORM
X! #endif
X! 					)
X  				otmp->corpsenm = mntmp;
X  			break;
X  		case EGG: if (lays_eggs(&mons[mntmp]) || mntmp==PM_KILLER_BEE)
X--- 1367,1374 ----
X  				otmp->corpsenm = mntmp;
X  			break;
X  		case FIGURINE:
X! 			if (!(mons[mntmp].geno & G_UNIQ)
X! 			    && !is_human(&mons[mntmp]))
X  				otmp->corpsenm = mntmp;
X  			break;
X  		case EGG: if (lays_eggs(&mons[mntmp]) || mntmp==PM_KILLER_BEE)
X*** src/Old/options.c	Wed Sep  6 15:54:14 1989
X--- src/options.c	Thu Aug 31 20:16:21 1989
X***************
X*** 131,144 ****
X  }
X  
X  void
X  parseoptions(opts, from_env)
X  register char *opts;
X  boolean from_env;
X  {
X  	register char *op;
X- /*
X- 	register char *op2;
X- */
X  	unsigned num;
X  	boolean negated;
X  
X--- 131,192 ----
X  }
X  
X  void
X+ assign_graphics(graph_ints,glth)
X+ register unsigned int *graph_ints;
X+ register int glth;
X+ {
X+ #define SETPCHAR(f, n)	showsyms.f = (glth > n) ? graph_ints[n] : defsyms.f
X+ 	SETPCHAR(stone, 0);
X+ 	SETPCHAR(vwall, 1);
X+ 	SETPCHAR(hwall, 2);
X+ 	SETPCHAR(tlcorn, 3);
X+ 	SETPCHAR(trcorn, 4);
X+ 	SETPCHAR(blcorn, 5);
X+ 	SETPCHAR(brcorn, 6);
X+ 	SETPCHAR(crwall, 7);
X+ 	SETPCHAR(tuwall, 8);
X+ 	SETPCHAR(tdwall, 9);
X+ 	SETPCHAR(tlwall, 10);
X+ 	SETPCHAR(trwall, 11);
X+ 	SETPCHAR(vbeam, 12);
X+ 	SETPCHAR(hbeam, 13);
X+ 	SETPCHAR(lslant, 14);
X+ 	SETPCHAR(rslant, 15);
X+ 	SETPCHAR(door, 16);
X+ 	SETPCHAR(room, 17);
X+ 	SETPCHAR(corr, 18);
X+ 	SETPCHAR(upstair, 19);
X+ 	SETPCHAR(dnstair, 20);
X+ 	SETPCHAR(trap, 21);
X+ 	SETPCHAR(web, 22);
X+ 	SETPCHAR(pool, 23);
X+ #ifdef FOUNTAINS
X+ 	SETPCHAR(fountain, 24);
X+ #endif
X+ #ifdef SINKS
X+ 	SETPCHAR(sink, 25);
X+ #endif
X+ #ifdef THRONES
X+ 	SETPCHAR(throne, 26);
X+ #endif
X+ #ifdef ALTARS
X+ 	SETPCHAR(altar, 27);
X+ #endif
X+ #ifdef STRONGHOLD
X+ 	SETPCHAR(upladder, 28);
X+ 	SETPCHAR(dnladder, 29);
X+ 	SETPCHAR(dbvwall, 30);
X+ 	SETPCHAR(dbhwall, 31);
X+ #endif
X+ #undef SETPCHAR
X+ }
X+ 
X+ void
X  parseoptions(opts, from_env)
X  register char *opts;
X  boolean from_env;
X  {
X  	register char *op;
X  	unsigned num;
X  	boolean negated;
X  
X***************
X*** 146,158 ****
X  		*op++ = 0;
X  		parseoptions(op, from_env);
X  	}
X! /*
X! 	if(op = index(opts, ' ')) {
X! 		op2 = op;
X! 		while(*op++)
X! 			if(*op != ' ') *op2++ = *op;
X! 	}
X! */
X  	if(!*opts) return;
X  	negated = FALSE;
X  	while((*opts == '!') || !strncmp(opts, "no", 2)) {
X--- 194,200 ----
X  		*op++ = 0;
X  		parseoptions(op, from_env);
X  	}
X! 
X  	if(!*opts) return;
X  	negated = FALSE;
X  	while((*opts == '!') || !strncmp(opts, "no", 2)) {
X***************
X*** 213,219 ****
X  		return;
X  	}
X  
X! 	if (!strncmp(opts, "numb", 4)) {
X  		flags.num_pad = !negated;
X  		return;
X  	}
X--- 255,261 ----
X  		return;
X  	}
X  
X! 	if (!strncmp(opts, "num", 3)) {
X  		flags.num_pad = !negated;
X  		return;
X  	}
X***************
X*** 327,332 ****
X--- 369,377 ----
X  
X  	/* graphics:string */
X  	if (!strncmp(opts, "gr", 2)) {
X+ 		unsigned int translate[MAXPCHARS+1];
X+ 		int i, lth;
X+ 
X  		if(!from_env) {
X  #ifdef MSDOS
X  		  pline("\"graphics\" settable only from %s.", configfile);
X***************
X*** 341,390 ****
X  		else
X  		    opts = op + 1;
X  		escapes(opts, opts);
X! #define SETPCHAR(f, n)	showsyms.f = (strlen(opts) > n) ? opts[n] : defsyms.f
X! 		SETPCHAR(stone, 0);
X! 		SETPCHAR(vwall, 1);
X! 		SETPCHAR(hwall, 2);
X! 		SETPCHAR(tlcorn, 3);
X! 		SETPCHAR(trcorn, 4);
X! 		SETPCHAR(blcorn, 5);
X! 		SETPCHAR(brcorn, 6);
X! 		SETPCHAR(crwall, 7);
X! 		SETPCHAR(tuwall, 8);
X! 		SETPCHAR(tdwall, 9);
X! 		SETPCHAR(tlwall, 10);
X! 		SETPCHAR(trwall, 11);
X! 		SETPCHAR(vbeam, 12);
X! 		SETPCHAR(hbeam, 13);
X! 		SETPCHAR(lslant, 14);
X! 		SETPCHAR(rslant, 15);
X! 		SETPCHAR(door, 16);
X! 		SETPCHAR(room, 17);
X! 		SETPCHAR(corr, 18);
X! 		SETPCHAR(upstair, 19);
X! 		SETPCHAR(dnstair, 20);
X! 		SETPCHAR(trap, 21);
X! 		SETPCHAR(web, 22);
X! 		SETPCHAR(pool, 23);
X! #ifdef FOUNTAINS
X! 		SETPCHAR(fountain, 24);
X! #endif
X! #ifdef SINKS
X! 		SETPCHAR(sink, 25);
X! #endif
X! #ifdef THRONES
X! 		SETPCHAR(throne, 26);
X! #endif
X! #ifdef ALTARS
X! 		SETPCHAR(altar, 27);
X! #endif
X! #ifdef STRONGHOLD
X! 		SETPCHAR(upladder, 28);
X! 		SETPCHAR(dnladder, 29);
X! 		SETPCHAR(dbvwall, 30);
X! 		SETPCHAR(dbhwall, 31);
X! #endif
X! #undef SETPCHAR
X  		return;
X  	}
X  
X--- 386,398 ----
X  		else
X  		    opts = op + 1;
X  		escapes(opts, opts);
X! 
X! 		lth = strlen(opts);
X! 		if(lth > MAXPCHARS) lth = MAXPCHARS;
X! 		/* match the form obtained from PC configuration files */
X! 		for(i = 0; i < lth; i++)
X! 			translate[i] = opts[i];
X! 		assign_graphics(translate,lth);
X  		return;
X  	}
X  
X***************
X*** 398,422 ****
X  			if(digit(*op)) {
X  				num = atoi(op);
X  				while(digit(*op)) op++;
X! 			} else
X! 			if(*op == '!') {
X  				negated = !negated;
X  				op++;
X  			}
X  			switch(*op) {
X! 			case 't':
X! 				flags.end_top = num;
X! 				break;
X! 			case 'a':
X! 				flags.end_around = num;
X! 				break;
X! 			case 'o':
X! 				flags.end_own = !negated;
X! 				break;
X! 			default:
X! 				goto bad;
X  			}
X! 			while(letter(*++op)) ;
X  			if(*op == '/') op++;
X  		}
X  		return;
X--- 406,431 ----
X  			if(digit(*op)) {
X  				num = atoi(op);
X  				while(digit(*op)) op++;
X! 			} else if(*op == '!') {
X  				negated = !negated;
X  				op++;
X  			}
X+ 			while(*op == ' ') op++;
X+ 
X  			switch(*op) {
X! 				case 't':
X! 					flags.end_top = num;
X! 					break;
X! 				case 'a':
X! 					flags.end_around = num;
X! 					break;
X! 				case 'o':
X! 					flags.end_own = !negated;
X! 					break;
X! 				default:
X! 					goto bad;
X  			}
X! 			while(letter(*++op) || *op == ' ') ;
X  			if(*op == '/') op++;
X  		}
X  		return;
X*** src/Old/pager.c	Wed Sep  6 15:54:41 1989
X--- src/pager.c	Mon Sep  4 20:39:17 1989
X***************
X*** 20,29 ****
X  static char hc = 0;
X  
X  static void page_more();
X  
X- const char nonlets[] = { S_EEL, S_CHAMELEON, S_DEMON, S_GHOST, S_HUMAN,
X- 	S_GOLEM, 0 };
X- 
X  int
X  dowhatis()
X  {
X--- 20,28 ----
X  static char hc = 0;
X  
X  static void page_more();
X+ static boolean clear_help P((CHAR_P));
X+ static boolean valid_help P((CHAR_P));
X  
X  int
X  dowhatis()
X  {
X***************
X*** 155,161 ****
X  					  (type == A_NEUTRAL) ? "(neutral)" :
X  					  "(lawful)");
X  			    } else
X! 			    if (q == CHAIN_SYM && levl[cc.x][cc.y].omask)
X  				    pline("(chain)");
X  			    else
X  #endif
X--- 154,160 ----
X  					  (type == A_NEUTRAL) ? "(neutral)" :
X  					  "(lawful)");
X  			    } else
X! 			    if (q == CHAIN_SYM && OBJ_AT(cc.x, cc.y))
X  				    pline("(chain)");
X  			    else
X  #endif
X***************
X*** 176,182 ****
X  			    }
X  #ifdef SPELLS
X  			    else
X! 			    if (q == SPBOOK_SYM && levl[cc.x][cc.y].omask)
X  				    pline("(spellbook)");
X  #endif
X  #ifdef STRONGHOLD
X--- 175,181 ----
X  			    }
X  #ifdef SPELLS
X  			    else
X! 			    if (q == SPBOOK_SYM && OBJ_AT(cc.x, cc.y))
X  				    pline("(spellbook)");
X  #endif
X  #ifdef STRONGHOLD
X***************
X*** 203,218 ****
X  				u.mtimedone ? mons[u.umonnum].mname :
X  #endif
X  				pl_character, plname);
X! 			} else if((q >= 'A' && q <= 'z') || index(nonlets,q)) {
X! 			    for(mtmp = fmon; mtmp; mtmp = mtmp->nmon)
X! 				if(mtmp->mx == cc.x && mtmp->my == cc.y) {
X! 				    pline("(%s%s)",
X! 					mtmp->mtame ? "tame " :
X! 					  mtmp->mpeaceful ? "peaceful " : "",
X! 					strncmp(lmonnam(mtmp), "the ", 4)
X! 					  ? lmonnam(mtmp) : lmonnam(mtmp)+4);
X! 				    break;
X! 				}
X  			}
X  			if(ep[-1] == ';') {
X  				pline("More info? ");
X--- 202,215 ----
X  				u.mtimedone ? mons[u.umonnum].mname :
X  #endif
X  				pl_character, plname);
X! 			} else if(levl[cc.x][cc.y].mmask) {
X! 			    mtmp = m_at(cc.x,cc.y);
X! 			    if (q == mtmp->data->mlet)
X! 				pline("(%s%s)",
X! 				    mtmp->mtame ? "tame " :
X! 				      mtmp->mpeaceful ? "peaceful " : "",
X! 				    strncmp(lmonnam(mtmp), "the ", 4)
X! 				      ? lmonnam(mtmp) : lmonnam(mtmp)+4);
X  			}
X  			if(ep[-1] == ';') {
X  				pline("More info? ");
X***************
X*** 241,247 ****
X  {
X  	FILE *fp;
X  	char bufr[BUFSZ+6];
X! 	register char *buf = &bufr[6], *ep, q, ctrl;
X  #ifdef OS2_CODEVIEW
X  	char tmp[PATHLEN];
X  
X--- 238,244 ----
X  {
X  	FILE *fp;
X  	char bufr[BUFSZ+6];
X! 	register char *buf = &bufr[6], *ep, q, ctrl, meta;
X  #ifdef OS2_CODEVIEW
X  	char tmp[PATHLEN];
X  
X***************
X*** 264,285 ****
X  #ifdef UNIX
X  	intron();
X  #endif
X! 	if (q == '\033') ctrl = '[';
X! 	else if (q != unctrl(q)) ctrl = q - 1 + 'A';
X! 	else ctrl = 0;
X  	while(fgets(buf,BUFSZ,fp))
X! 	    if ((!ctrl && *buf==q) || (ctrl && *buf=='^' && *(buf+1)==ctrl)) {
X  		ep = index(buf, '\n');
X  		if(ep) *ep = 0;
X! 		if(!ctrl && buf[1] == '\t'){
X  			buf = bufr;
X  			buf[0] = q;
X  			(void) strncpy(buf+1, "       ", 7);
X- 		} else if (ctrl && buf[2] == '\t'){
X- 			buf = bufr + 1;
X- 			buf[0] = '^';
X- 			buf[1] = ctrl;
X- 			(void) strncpy(buf+2, "      ", 6);
X  		}
X  		pline(buf);
X  		(void) fclose(fp);
X--- 261,286 ----
X  #ifdef UNIX
X  	intron();
X  #endif
X! 	ctrl = ((q <= '\033') ? (q - 1 + 'A') : 0);
X! 	meta = ((0x80 & q) ? (0x7f & q) : 0);
X  	while(fgets(buf,BUFSZ,fp))
X! 	    if ((ctrl && *buf=='^' && *(buf+1)==ctrl) ||
X! 		(meta && *buf=='M' && *(buf+1)=='-' && *(buf+2)==meta) ||
X! 		*buf==q) {
X  		ep = index(buf, '\n');
X  		if(ep) *ep = 0;
X! 		if (ctrl && buf[2] == '\t'){
X! 			buf = bufr + 1;
X! 			(void) strncpy(buf, "^?      ", 8);
X! 			buf[1] = ctrl;
X! 		} else if (meta && buf[3] == '\t'){
X! 			buf = bufr + 2;
X! 			(void) strncpy(buf, "M-?     ", 8);
X! 			buf[2] = meta;
X! 		} else if(buf[1] == '\t'){
X  			buf = bufr;
X  			buf[0] = q;
X  			(void) strncpy(buf+1, "       ", 7);
X  		}
X  		pline(buf);
X  		(void) fclose(fp);
X***************
X*** 539,545 ****
X  		    curx = curx + strlen(tl->line_text);
X  		    curline++;
X  		}
X! 		if(hmenu) hc = lowc(readchar()); /* help menu display */
X  #if defined(MSDOS) && !defined(AMIGA)
X  		cmov (lth, curline);
X  #else
X--- 540,550 ----
X  		    curx = curx + strlen(tl->line_text);
X  		    curline++;
X  		}
X! 		if(hmenu) {	/* help menu display */
X! 			do 
X! 				hc = lowc(readchar());
X! 			while (!valid_help(hc));
X! 		}
X  #if defined(MSDOS) && !defined(AMIGA)
X  		cmov (lth, curline);
X  #else
X***************
X*** 547,555 ****
X  #endif
X  		cl_end ();
X  		if (!hmenu) cmore (text);
X! 		home ();
X! 		cl_end ();
X! 		docorner (lth, curline-1);
X  	    } else {					/* feed to pager */
X  		set_pager(0);
X  		for (tl = texthead; tl; tl = tl->next_line) {
X--- 552,562 ----
X  #endif
X  		cl_end ();
X  		if (!hmenu) cmore (text);
X! 		if (!hmenu || clear_help(hc)) {
X! 		    home ();
X! 		    cl_end ();
X! 		    docorner (lth, curline-1);
X! 		}
X  	    } else {					/* feed to pager */
X  		set_pager(0);
X  		for (tl = texthead; tl; tl = tl->next_line) {
X***************
X*** 622,642 ****
X  	cornline(-1,"");
X  }
X  
X! int
X! dohelp()
X  {
X! 	char c;
X  
X! 	do {
X! 	    help_menu();
X! 	    c = hc;
X! #ifdef WIZARD
X! 	} while ((c < 'a' || c > (wizard ? 'j' : 'i')) && !index(quitchars,c));
X  #else
X! 	} while ((c < 'a' || c > 'i') && !index(quitchars,c));
X  #endif
X! 	if (!index(quitchars, c)) {
X! 		switch(c) {
X  			case 'a':  (void) page_file(HELP, FALSE);  break;
X  			case 'b':  (void) page_file(SHELP, FALSE);  break;
X  			case 'c':  (void) dohistory();  break;
X--- 629,668 ----
X  	cornline(-1,"");
X  }
X  
X! static boolean
X! clear_help(c)
X! char c;
X  {
X! 	/* those valid_help characters which do not correspond to help routines
X! 	 * that redraw the whole screen on their own.  if we always clear the
X! 	 * help menu, we end up restoring the part of the maze underneath the
X! 	 * help menu when the last page of a long help file is displayed with
X! 	 * an external pager.
X! 	 */
X! 	return(index(quitchars,c) || c == 'd' || c == 'e'
X! #ifdef WIZARD
X! 		|| c == 'j'
X! #endif
X! 		);
X! }
X  
X! static boolean
X! valid_help(c)
X! char c;
X! {
X! #ifdef WIZARD
X! 	return ((c >= 'a' && c <= (wizard ? 'j' : 'i')) || index(quitchars,c));
X  #else
X! 	return ((c >= 'a' && c <= 'i') || index(quitchars,c));
X  #endif
X! }
X! 
X! int
X! dohelp()
X! {
X! 	help_menu();
X! 	if (!index(quitchars, hc)) {
X! 		switch(hc) {
X  			case 'a':  (void) page_file(HELP, FALSE);  break;
X  			case 'b':  (void) page_file(SHELP, FALSE);  break;
X  			case 'c':  (void) dohistory();  break;
X***************
X*** 768,774 ****
X  #ifdef WIZARD
X  	if(wizard) (void) signal(SIGQUIT,SIG_DFL);
X  #endif
X! 	if(wt) getret();
X  	docrt();
X  	return(0);
X  }
X--- 794,808 ----
X  #ifdef WIZARD
X  	if(wizard) (void) signal(SIGQUIT,SIG_DFL);
X  #endif
X! 	if(wt) {
X! 		boolean so;
X! 
X! 		cmov(1, LI);	/* get prompt in reasonable place */
X! 		so = flags.standout;
X! 		flags.standout = 1;
X! 		more();
X! 		flags.standout = so;
X! 	}
X  	docrt();
X  	return(0);
X  }
X*** src/Old/pickup.c	Wed Sep  6 15:55:37 1989
X--- src/pickup.c	Tue Sep  5 21:35:42 1989
X***************
X*** 270,278 ****
X  			    if(obj->spe) obj->spe = 0;
X  		    break;
X  		}
X  		freeobj(obj);
X  		if(Invisible) newsym(u.ux,u.uy);
X- 		addtobill(obj, TRUE);       /* sets obj->unpaid if necessary */
X  		if(wt > -5) You("have a little trouble lifting");
X  		{ int pickquan = obj->quan;
X  		  int mergquan;
X--- 270,278 ----
X  			    if(obj->spe) obj->spe = 0;
X  		    break;
X  		}
X+ 		addtobill(obj, TRUE);       /* sets obj->unpaid if necessary */
X  		freeobj(obj);
X  		if(Invisible) newsym(u.ux,u.uy);
X  		if(wt > -5) You("have a little trouble lifting");
X  		{ int pickquan = obj->quan;
X  		  int mergquan;
X***************
X*** 287,293 ****
X  		}
X  	    }
X  	}
X- 	set_omask(u.ux, u.uy);
X  }
X  
X  int
X--- 287,292 ----
X***************
X*** 300,306 ****
X  		pline("You cannot reach the floor.");
X  		return(0);
X  	}
X! 	if(levl[u.ux][u.uy].omask)
X  	for(cobj = fobj; cobj; cobj = cobj->nobj) {
X  
X  	    if(cobj->ox == u.ux && cobj->oy == u.uy)
X--- 299,305 ----
X  		pline("You cannot reach the floor.");
X  		return(0);
X  	}
X! 	if(OBJ_AT(u.ux, u.uy))
X  	for(cobj = fobj; cobj; cobj = cobj->nobj) {
X  
X  	    if(cobj->ox == u.ux && cobj->oy == u.uy)
X***************
X*** 466,476 ****
X  
X  	for(otmp = invent; otmp; otmp = otmp->nobj) {
X  	    cobj = otmp;
X! 	    if(Is_container(otmp))
X  		for(ootmp=fcobj,nxobj=(fcobj ? fcobj->nobj : 0); ootmp;
X  			    ootmp=nxobj,nxobj=(ootmp ? ootmp->nobj : 0) )
X  		    if(ootmp->cobj == cobj)
X  			(void)out_container(ootmp);
X  	}
X  	return;
X  }
X--- 465,477 ----
X  
X  	for(otmp = invent; otmp; otmp = otmp->nobj) {
X  	    cobj = otmp;
X! 	    if(Is_container(otmp)) {
X! 		current_container = otmp;
X  		for(ootmp=fcobj,nxobj=(fcobj ? fcobj->nobj : 0); ootmp;
X  			    ootmp=nxobj,nxobj=(ootmp ? ootmp->nobj : 0) )
X  		    if(ootmp->cobj == cobj)
X  			(void)out_container(ootmp);
X+ 	    }
X  	}
X  	return;
X  }
X*** src/Old/polyself.c	Wed Sep  6 15:56:02 1989
X--- src/polyself.c	Tue Sep  5 22:05:00 1989
X***************
X*** 5,139 ****
X  #include "hack.h"
X  
X  #ifdef POLYSELF
X- 
X  static void break_armor(), drop_weapon();
X  static void skinback();
X  static void uunstick();
X  
X  void
X! polyself()
X  {
X  	char buf[BUFSZ];
X- 	int tmp, tmp2, mntmp = -1;
X- 	int tries=0;
X- 	boolean draconian = (uarm && uarm->otyp==DRAGON_SCALE_MAIL &&
X- 		uarm->corpsenm >= PM_GREY_DRAGON &&
X- 		uarm->corpsenm <= PM_YELLOW_DRAGON);
X- 	/* We have to calculate sticky in multiple places since we might go
X- 	 * through any one of them without going through the others.
X- 	 */
X- 	boolean sticky = sticks(uasmon) && u.ustuck && !u.uswallow;
X- 
X- 	if(!Polymorph_control && !draconian) {
X- 	    if (rn2(20) > ACURR(A_CON)) {
X- 		You("shudder for a moment.");
X- 		losehp(rn2(30),"system shock");
X- 		return;
X- 	    }
X- 	}
X- 
X- 	if (Polymorph_control) {
X- 		do {
X- 			pline("Become what kind of monster? [type the name] ");
X- 			getlin(buf);
X- 			mntmp = name_to_mon(buf);
X- 			if (mntmp < 0)
X- 				pline("I've never heard of such monsters.");
X- 			else if (!polyok(&mons[mntmp]))
X- 				You("cannot polymorph into that.");
X- 			else break;
X- 		} while(++tries < 5);
X- 		if (tries==5) pline(thats_enough_tries);
X- 	} else if (draconian)
X- 		mntmp = uarm->corpsenm;
X  
X! 	if (mntmp < 0) {
X! 		tries = 0;
X! 		do {
X! 			mntmp = rn2(PM_CHAMELEON);
X! 			/* All valid monsters are from 0 to PM_CHAMELEON-1 */
X! 		} while(!polyok(&mons[mntmp]) && tries++ < 200);
X  	}
X! 
X! 	if (draconian && mntmp==uarm->corpsenm) {
X! 		if (!(mons[uarm->corpsenm].geno & G_GENOD)) {
X! 			You("merge with your scaly armor.");
X! 			uskin = uarm;
X! 			uarm = (struct obj *)0;
X! 		}
X  	}
X! 	/* The below polyok() should never fail unless just about everything
X! 	 * was genocided...
X! 	 */
X! 	if (!polyok(&mons[mntmp]) || !rn2(5)) {
X! 		if (!rn2(10)) {
X! 			flags.female = !flags.female;
X! 			max_rank_sz();
X! 			if (pl_character[0]=='P')
X! 				Strcpy(pl_character+6, flags.female?"ess":"");
X! 			if (pl_character[0]=='C')
X! 				Strcpy(pl_character+5,
X! 				flags.female ? "woman" : "man");
X! 		}
X! 		if (u.umonnum != -1) {
X! 			u.acurr = u.macurr;	/* restore old attribs */
X! 			u.amax = u.mamax;
X! 		}
X! 	    tmp = u.uhpmax;
X! 	    tmp2 = u.ulevel;
X! 	    u.usym = S_HUMAN;
X! 	    u.umonnum = -1;
X! 	    if (u.uundetected) u.uundetected = 0;
X! 	    prme();
X! 	    u.mtimedone = u.mh = u.mhmax = 0;
X! 	    u.ulevel = u.ulevel-2+rn2(5);
X! 	    if (u.ulevel > 127 || u.ulevel == 0) u.ulevel = 1;
X! 	    if (u.ulevel > MAXULEV) u.ulevel = MAXULEV;
X  
X! 	    for(tmp = u.ulevel; tmp != tmp2; tmp += (tmp2 < u.ulevel) ? -1 : 1)
X  		adjabil((tmp2 > u.ulevel) ? -1 : 1);
X! 	    tmp = u.uhpmax;
X  
X! 	    /* random experience points for the new experience level */
X! 	    u.uexp = rndexp();
X  #ifndef LINT
X! 	    u.uhpmax = (u.uhpmax-10)*(long)u.ulevel/tmp2 + 19 - rn2(19);
X  #endif
X  /* If it was u.uhpmax*u.ulevel/tmp+9-rn2(19), then a 1st level character
X     with 16 hp who polymorphed into a 3rd level one would have an average
X     of 48 hp.  */
X  #ifndef LINT
X! 	    u.uhp = u.uhp * (long)u.uhpmax/tmp;
X  #endif
X  #ifdef SPELLS
X! 	    tmp = u.uenmax;
X! #ifndef LINT
X! 	    u.uenmax = u.uenmax * (long)u.ulevel/tmp2 + 9 - rn2(19);
X! #endif
X! 	    if (u.uenmax < 0) u.uenmax = 0;
X! #ifndef LINT
X! 	    u.uen = (tmp ? u.uen * (long)u.uenmax / tmp : u.uenmax);
X! #endif
X! #endif
X! 	    (void)redist_attr();
X! 	    u.uhunger = rn1(500,500);
X! 	    Sick = 0;
X! 	    Stoned = 0;
X! 	    if (u.uhp <= 0 || u.uhpmax <= 0) {
X! 
X  		if(Polymorph_control) {
X  		    if (u.uhp <= 0) u.uhp = 1;
X  		    if (u.uhpmax <= 0) u.uhpmax = 1;
X  		} else {
X  		    Your("new form doesn't seem healthy enough to survive.");
X  		    killer="unsuccessful polymorph";
X  		    done(DIED);
X  		}
X! 	    }
X! 	    set_uasmon();
X! 	    You("feel like a new %sman!", flags.female ? "wo" : "");
X  #ifdef WIZARD
X! 	    if(!wizard) {
X  #endif
X  newname:	more();
X  		do {
X--- 5,96 ----
X  #include "hack.h"
X  
X  #ifdef POLYSELF
X  static void break_armor(), drop_weapon();
X  static void skinback();
X  static void uunstick();
X+ static boolean sticky;
X+ #endif
X  
X  void
X! newman()
X  {
X+ 	int tmp, tmp2;
X  	char buf[BUFSZ];
X  
X! 	if (!rn2(10)) {
X! 		flags.female = !flags.female;
X! 		max_rank_sz();
X! 		if (pl_character[0]=='P')
X! 			Strcpy(pl_character+6, flags.female?"ess":"");
X! 		if (pl_character[0]=='C')
X! 			Strcpy(pl_character+5, flags.female ? "woman" : "man");
X  	}
X! #ifdef POLYSELF
X! 	if (u.umonnum != -1) {
X! 		u.acurr = u.macurr;	/* restore old attribs */
X! 		u.amax = u.mamax;
X  	}
X! 	u.usym = S_HUMAN;
X! 	u.umonnum = -1;
X! 	if (u.uundetected) u.uundetected = 0;
X! 	prme();
X! 	u.mtimedone = u.mh = u.mhmax = 0;
X! #endif
X! 	tmp = u.uhpmax;
X! 	tmp2 = u.ulevel;
X! 	u.ulevel = u.ulevel-2+rn2(5);
X! 	if (u.ulevel > 127 || u.ulevel == 0) u.ulevel = 1;
X! 	if (u.ulevel > MAXULEV) u.ulevel = MAXULEV;
X  
X! 	for(tmp = u.ulevel; tmp != tmp2; tmp += (tmp2 < u.ulevel) ? -1 : 1)
X  		adjabil((tmp2 > u.ulevel) ? -1 : 1);
X! 	tmp = u.uhpmax;
X  
X! 	/* random experience points for the new experience level */
X! 	u.uexp = rndexp();
X  #ifndef LINT
X! 	u.uhpmax = (u.uhpmax-10)*(long)u.ulevel/tmp2 + 19 - rn2(19);
X  #endif
X  /* If it was u.uhpmax*u.ulevel/tmp+9-rn2(19), then a 1st level character
X     with 16 hp who polymorphed into a 3rd level one would have an average
X     of 48 hp.  */
X  #ifndef LINT
X! 	u.uhp = u.uhp * (long)u.uhpmax/tmp;
X  #endif
X  #ifdef SPELLS
X! 	tmp = u.uenmax;
X! #  ifndef LINT
X! 	u.uenmax = u.uenmax * (long)u.ulevel/tmp2 + 9 - rn2(19);
X! #  endif
X! 	if (u.uenmax < 0) u.uenmax = 0;
X! #  ifndef LINT
X! 	u.uen = (tmp ? u.uen * (long)u.uenmax / tmp : u.uenmax);
X! #  endif
X! #endif
X! 	redist_attr();
X! 	u.uhunger = rn1(500,500);
X! 	Sick = 0;
X! 	Stoned = 0;
X! 	if (u.uhp <= 0 || u.uhpmax <= 0) {
X! #ifdef POLYSELF
X  		if(Polymorph_control) {
X  		    if (u.uhp <= 0) u.uhp = 1;
X  		    if (u.uhpmax <= 0) u.uhpmax = 1;
X  		} else {
X+ #endif
X  		    Your("new form doesn't seem healthy enough to survive.");
X  		    killer="unsuccessful polymorph";
X  		    done(DIED);
X+ #ifdef POLYSELF
X  		}
X! #endif
X! 	}
X! #ifdef POLYSELF
X! 	set_uasmon();
X! #endif
X! 	You("feel like a new %sman!", flags.female ? "wo" : "");
X  #ifdef WIZARD
X! 	if(!wizard) {
X  #endif
X  newname:	more();
X  		do {
X***************
X*** 148,160 ****
X  		Sprintf(SAVEF, "save/%d%s", getuid(), plname);
X  		regularize(SAVEF+5);		/* avoid . or / in name */
X  #ifdef WIZARD
X! 	    }
X  #endif
X! 	    flags.botl = 1;
X! 	    skinback();
X! 	    find_ac();
X! 	    if (sticky) uunstick();
X! 	} else if(!polymon(mntmp)) return;
X  
X  	if (!uarmg) selftouch("No longer petrify-resistant, you");
X  	if (Inhell && !Fire_resistance) {
X--- 105,195 ----
X  		Sprintf(SAVEF, "save/%d%s", getuid(), plname);
X  		regularize(SAVEF+5);		/* avoid . or / in name */
X  #ifdef WIZARD
X! 	}
X! #endif
X! 	flags.botl = 1;
X! #ifdef POLYSELF
X! 	skinback();
X! 	find_ac();
X! 	if (sticky) uunstick();
X  #endif
X! }
X! 
X! #ifdef POLYSELF
X! void
X! polyself()
X! {
X! 	char buf[BUFSZ];
X! 	int mntmp = -1;
X! 	int tries=0;
X! 	boolean draconian = (uarm && uarm->otyp==DRAGON_SCALE_MAIL &&
X! 		uarm->corpsenm >= PM_GREY_DRAGON &&
X! 		uarm->corpsenm <= PM_YELLOW_DRAGON);
X! 	boolean iswere = (u.ulycn > -1 || is_were(uasmon));
X! 	boolean isvamp = (u.usym == S_VAMPIRE || u.umonnum == PM_VAMPIRE_BAT);
X! 	/* We have to calculate sticky in multiple places since we might go
X! 	 * through any one of them without going through the others.
X! 	 */
X! 	sticky = sticks(uasmon) && u.ustuck && !u.uswallow;
X! 
X! 	if(!Polymorph_control && !draconian && !iswere && !isvamp) {
X! 	    if (rn2(20) > ACURR(A_CON)) {
X! 		You("shudder for a moment.");
X! 		losehp(rn2(30),"system shock");
X! 		return;
X! 	    }
X! 	}
X! 
X! 	if (Polymorph_control) {
X! 		do {
X! 			pline("Become what kind of monster? [type the name] ");
X! 			getlin(buf);
X! 			mntmp = name_to_mon(buf);
X! 			if (mntmp < 0)
X! 				pline("I've never heard of such monsters.");
X! 			else if (!polyok(&mons[mntmp]))
X! 				You("cannot polymorph into that.");
X! 			else break;
X! 		} while(++tries < 5);
X! 		if (tries==5) pline(thats_enough_tries);
X! 	} else if (draconian || iswere || isvamp) {
X! 		/* special changes that don't require polyok() */
X! 		if (draconian) {
X! 			mntmp = uarm->corpsenm;
X! 			if (!(mons[mntmp].geno & G_GENOD)) {
X! 				You("merge with your scaly armor.");
X! 				uskin = uarm;
X! 				uarm = (struct obj *)0;
X! 			}
X! 		} else if (iswere) {
X! 			if (is_were(uasmon))
X! 				mntmp = PM_HUMAN; /* Illegal; force newman() */
X! 			else
X! 				mntmp = u.ulycn;
X! 		} else {
X! 			if (u.usym == S_VAMPIRE)
X! 				mntmp = PM_VAMPIRE_BAT;
X! 			else
X! 				mntmp = PM_VAMPIRE;
X! 		}
X! 		if (polymon(mntmp))
X! 			return;
X! 	}
X! 
X! 	if (mntmp < 0) {
X! 		tries = 0;
X! 		do {
X! 			mntmp = rn2(PM_CHAMELEON);
X! 			/* All valid monsters are from 0 to PM_CHAMELEON-1 */
X! 		} while(!polyok(&mons[mntmp]) && tries++ < 200);
X! 	}
X! 
X! 	/* The below polyok() fails either if everything is genocided, or if
X! 	 * we deliberately chose something illegal to force newman().
X! 	 */
X! 	if (!polyok(&mons[mntmp]) || !rn2(5))
X! 		newman();
X! 	else if(!polymon(mntmp)) return;
X  
X  	if (!uarmg) selftouch("No longer petrify-resistant, you");
X  	if (Inhell && !Fire_resistance) {
X***************
X*** 169,175 ****
X  	int	mntmp;
X  {
X  	int	tmp;
X! 	boolean sticky = sticks(uasmon) && u.ustuck && !u.uswallow;
X  
X  	if (mons[mntmp].geno & G_GENOD) {
X  		You("feel rather %s-ish.",mons[mntmp].mname);
X--- 204,210 ----
X  	int	mntmp;
X  {
X  	int	tmp;
X! 	sticky = sticks(uasmon) && u.ustuck && !u.uswallow;
X  
X  	if (mons[mntmp].geno & G_GENOD) {
X  		You("feel rather %s-ish.",mons[mntmp].mname);
X***************
X*** 228,234 ****
X  	break_armor();
X  	drop_weapon(1);
X  	if (u.uundetected && !hides_under(uasmon)) u.uundetected = 0;
X! 	else if (hides_under(uasmon) && (levl[u.ux][u.uy].omask ||
X  			levl[u.ux][u.uy].gmask))
X  		u.uundetected = 1;
X  	prme();
X--- 263,269 ----
X  	break_armor();
X  	drop_weapon(1);
X  	if (u.uundetected && !hides_under(uasmon)) u.uundetected = 0;
X! 	else if (hides_under(uasmon) && (OBJ_AT(u.ux, u.uy) ||
X  			levl[u.ux][u.uy].gmask))
X  		u.uundetected = 1;
X  	prme();
X***************
X*** 347,353 ****
X  void
X  rehumanize()
X  {
X! 	boolean sticky = sticks(uasmon) && u.ustuck && !u.uswallow;
X  
X  	u.mh = u.mhmax = u.mtimedone = 0;
X   	u.acurr = u.macurr;		/* restore old strength */
X--- 382,388 ----
X  void
X  rehumanize()
X  {
X! 	sticky = sticks(uasmon) && u.ustuck && !u.uswallow;
X  
X  	u.mh = u.mhmax = u.mtimedone = 0;
X   	u.acurr = u.macurr;		/* restore old strength */
X***************
X*** 423,435 ****
X  	if (u.uswallow) {
X  		You("release web fluid inside %s.", mon_nam(u.ustuck));
X  		pline("%s regurgitates you!", Monnam(u.ustuck));
X! 		u.ux = u.ustuck->mx;
X! 		u.uy = u.ustuck->my;
X! 		mnexto(u.ustuck);
X! 		u.uswallow = 0;
X! 		u.ustuck = 0;
X! 		setsee();
X! 		docrt();
X  		return(1);
X  	}
X  	if (u.utrap) {
X--- 458,464 ----
X  	if (u.uswallow) {
X  		You("release web fluid inside %s.", mon_nam(u.ustuck));
X  		pline("%s regurgitates you!", Monnam(u.ustuck));
X! 		regurgitates(u.ustuck);
X  		return(1);
X  	}
X  	if (u.utrap) {
X***************
X*** 507,513 ****
X  		looked = 1;
X  		if (Invis && !perceives(mtmp->data))
X  		    pline("%s seems not to notice your gaze.", Monnam(mtmp));
X! 		else if (mtmp->minvis && !See_invisible && !Telepat)
X  		    You("can't see where to gaze at %s.", Monnam(mtmp));
X  		else if (mtmp->mimic)
X  		    continue;
X--- 536,542 ----
X  		looked = 1;
X  		if (Invis && !perceives(mtmp->data))
X  		    pline("%s seems not to notice your gaze.", Monnam(mtmp));
X! 		else if (mtmp->minvis && !See_invisible)
X  		    You("can't see where to gaze at %s.", Monnam(mtmp));
X  		else if (mtmp->mimic)
X  		    continue;
X
END_OF_FILE
if test 55646 -ne `wc -c <'patch03e'`; then
    echo shar: \"'patch03e'\" unpacked with wrong size!
fi
# end of 'patch03e'
fi
echo shar: End of archive 5 \(of 6\).
cp /dev/null ark5isdone
MISSING=""
for I in 1 2 3 4 5 6 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 6 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
