Path: utzoo!utgpu!jarvis.csri.toronto.edu!mailrus!csd4.csd.uwm.edu!gem.mps.ohio-state.edu!ginosko!uunet!zephyr.ens.tek.com!tekgen!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v08i018:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Patch3c
Message-ID: <4537@tekred.CNA.TEK.COM>
Date: 7 Sep 89 21:49:38 GMT
Sender: nobody@tekred.CNA.TEK.COM
Lines: 2176
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 8, Issue 18
Archive-name: NetHack3/Patch3c
Patch-To: NetHack3: Volume 7, Issue 56-93

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 3 (of 6)."
# Contents:  patch03c
# Wrapped by billr@saab on Thu Sep  7 14:38:47 1989
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'patch03c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'patch03c'\"
else
echo shar: Extracting \"'patch03c'\" \(56862 characters\)
sed "s/^X//" >'patch03c' <<'END_OF_FILE'
X*** src/Old/apply.c	Wed Sep  6 15:38:11 1989
X--- src/apply.c	Tue Sep  5 18:52:45 1989
X***************
X*** 482,491 ****
X  		register char *digtxt;
X  		register struct obj *obj;
X  
X! 		if(obj = sobj_at(BOULDER, dpx, dpy)) {
X! 			fracture_rock(obj);
X! 			digtxt = "The boulder falls apart.";
X! 		} else if(obj = sobj_at(STATUE, dpx, dpy)) {
X  			if (break_statue(obj))
X  				digtxt = "The statue shatters.";
X  			else
X--- 482,488 ----
X  		register char *digtxt;
X  		register struct obj *obj;
X  
X! 		if(obj = sobj_at(STATUE, dpx, dpy)) {
X  			if (break_statue(obj))
X  				digtxt = "The statue shatters.";
X  			else
X***************
X*** 493,498 ****
X--- 490,498 ----
X  				 * printed a message and updated the screen
X  				 */
X  				digtxt = NULL;
X+ 		} else if(obj = sobj_at(BOULDER, dpx, dpy)) {
X+ 			fracture_rock(obj);
X+ 			digtxt = "The boulder falls apart.";
X  		} else if(!lev->typ || lev->typ == SCORR) {
X  			lev->typ = CORR;
X  			digtxt = "You succeeded in cutting away some rock.";
X***************
X*** 585,591 ****
X  		if(Invisible) newsym(ttmp->tx,ttmp->ty);
X  		pline("You've made a hole in the floor.");
X  		if(!u.ustuck && !Levitation) {			/* KAA */
X! 			if(inshop())
X  				shopdig(1);
X  #ifdef WALKIES
X  			if(!next_to_u())
X--- 585,591 ----
X  		if(Invisible) newsym(ttmp->tx,ttmp->ty);
X  		pline("You've made a hole in the floor.");
X  		if(!u.ustuck && !Levitation) {			/* KAA */
X! 			if(in_shop(u.ux, u.uy))
X  				shopdig(1);
X  #ifdef WALKIES
X  			if(!next_to_u())
X***************
X*** 704,722 ****
X  				dig_level = dlevel;
X  				dig_effort = 0;
X  			    	You("start %s.",
X- 				   isclosedoor ? "chopping at the door" :
X  				   sobj_at(STATUE, rx, ry) ?
X  						"chipping the statue" :
X  				   sobj_at(BOULDER, rx, ry) ?
X  						"hitting the boulder" :
X  						"digging");
X  			} else
X  				You("continue %s.",
X- 				   isclosedoor ? "chopping at the door" :
X  				   sobj_at(STATUE, rx, ry) ?
X  						"chipping the statue" :
X  				   sobj_at(BOULDER, rx, ry) ?
X  						"hitting the boulder" :
X  						"digging");
X  			did_dig_msg = FALSE;
X  			set_occupation(dig, "digging", 0);
X--- 704,722 ----
X  				dig_level = dlevel;
X  				dig_effort = 0;
X  			    	You("start %s.",
X  				   sobj_at(STATUE, rx, ry) ?
X  						"chipping the statue" :
X  				   sobj_at(BOULDER, rx, ry) ?
X  						"hitting the boulder" :
X+ 				   isclosedoor ? "chopping at the door" :
X  						"digging");
X  			} else
X  				You("continue %s.",
X  				   sobj_at(STATUE, rx, ry) ?
X  						"chipping the statue" :
X  				   sobj_at(BOULDER, rx, ry) ?
X  						"hitting the boulder" :
X+ 				   isclosedoor ? "chopping at the door" :
X  						"digging");
X  			did_dig_msg = FALSE;
X  			set_occupation(dig, "digging", 0);
X***************
X*** 732,738 ****
X  			dig_level = dlevel;
X  			dig_effort = 0;
X  			You("start digging in the floor.");
X! 			if(inshop())
X  				shopdig(0);
X  		} else
X  			You("continue digging in the floor.");
X--- 732,738 ----
X  			dig_level = dlevel;
X  			dig_effort = 0;
X  			You("start digging in the floor.");
X! 			if(in_shop(u.ux, u.uy))
X  				shopdig(0);
X  		} else
X  			You("continue digging in the floor.");
X***************
X*** 1031,1036 ****
X--- 1031,1037 ----
X  
X  	if(!obj || (obj != uwep && !wield_tool(obj))) return 0;
X  
X+ 	/* now uwep is obj */
X  	if (uwep->otyp == MAGIC_LAMP) {
X  	    if (uwep->spe > 0 && !rn2(3)) {
X  		uwep->spe = 0;
X*** src/Old/artifact.c	Wed Sep  6 15:38:48 1989
X--- src/artifact.c	Sat Sep  2 12:15:16 1989
X***************
X*** 15,24 ****
X  
X  { LONG_SWORD,	 "Excalibur",	(SPFX_NOGEN | SPFX_SEEK | SPFX_DEFN |
X  								SPFX_SEARCH), 0,
X!   { 0, AD_PHYS, 5, 10 }, { 0, AD_DRLI, 0, 0} },
X  
X  { KATANA,	 "Snickersnee",	SPFX_RESTR, 0,
X!   { 0, AD_PHYS, 0, 8 }, NO_ATTK },
X  
X  /*	Ah, never shall I forget the cry, 
X   *		or the shriek that shrieked he,
X--- 15,24 ----
X  
X  { LONG_SWORD,	 "Excalibur",	(SPFX_NOGEN | SPFX_SEEK | SPFX_DEFN |
X  								SPFX_SEARCH), 0,
X!   { 0, AD_PHYS, 5, 10 }, { 0, AD_DRLI, 0, 0}, A_LAW },
X  
X  { KATANA,	 "Snickersnee",	SPFX_RESTR, 0,
X!   { 0, AD_PHYS, 0, 8 }, NO_ATTK, A_LAW },
X  
X  /*	Ah, never shall I forget the cry, 
X   *		or the shriek that shrieked he,
X***************
X*** 30,87 ****
X   */
X  
X  { AXE,		 "Cleaver",	SPFX_RESTR, 0,
X!   { 0, AD_PHYS, 3, 12 }, NO_ATTK },
X  
X  /*  Special purpose swords - various types */
X  
X  { TWO_HANDED_SWORD, "Orcrist",	SPFX_DCLAS, S_ORC,
X!   { 0, AD_PHYS, 5, 0 }, NO_ATTK },
X  
X  #ifdef TOLKIEN
X  { ELVEN_DAGGER,	 "Sting",	(SPFX_WARN | SPFX_DCLAS), S_ORC,
X!   { 0, AD_PHYS, 5, 0 }, NO_ATTK },
X  #else
X  { DAGGER,	 "Sting",	(SPFX_WARN | SPFX_DCLAS), S_ORC,
X!   { 0, AD_PHYS, 5, 0 }, NO_ATTK },
X  #endif
X  
X  { LONG_SWORD,	 "Frost Brand", (SPFX_RESTR | SPFX_ATTK | SPFX_DEFN), 0,
X!   { 0, AD_COLD, 5, 0 }, { 0, AD_COLD, 0, 0 } },
X  
X  { LONG_SWORD,	 "Fire Brand",	(SPFX_RESTR | SPFX_ATTK | SPFX_DEFN), 0,
X!   { 0, AD_FIRE, 5, 0 }, { 0, AD_FIRE, 0, 0 } },
X  
X  /* Stormbringer only has a 2 because it can drain a level, providing 8 more */
X  { BROADSWORD,	 "Stormbringer", (SPFX_RESTR | SPFX_ATTK | SPFX_DEFN |
X  								SPFX_DRLI), 0,
X!   { 0, AD_DRLI, 5, 2 }, { 0, AD_DRLI, 0, 0 } },
X  
X  { LONG_SWORD,	 "Sunsword",	(SPFX_RESTR | SPFX_DCLAS), 0, /* undead */
X!   { 0, AD_PHYS, 5, 0 }, NO_ATTK },
X  
X  { BROADSWORD,	 "Dragonbane",	(SPFX_RESTR | SPFX_DCLAS), S_DRAGON,
X!   { 0, AD_PHYS, 5, 0 }, NO_ATTK },
X  
X  { LONG_SWORD,	 "Demonbane",	(SPFX_RESTR | SPFX_DCLAS), 0, /* demons */
X!   { 0, AD_PHYS, 5, 0 }, NO_ATTK },
X  
X  { LONG_SWORD,	 "Werebane",	(SPFX_RESTR | SPFX_DCLAS), 0, /* weres */
X!   { 0, AD_PHYS, 5, 0 }, NO_ATTK },
X  
X  { LONG_SWORD,	 "Giantslayer", (SPFX_RESTR | SPFX_DCLAS), 0, /* giants */
X!   { 0, AD_PHYS, 5, 0 }, NO_ATTK },
X  
X! { LUCERN_HAMMER, "Ogresmasher",	(SPFX_RESTR | SPFX_DCLAS),  S_OGRE,
X!   { 0, AD_PHYS, 5, 0 }, NO_ATTK },
X  
X! { LUCERN_HAMMER, "Thunderfist",	(SPFX_RESTR | SPFX_ATTK),  0,
X!   { 0, AD_ELEC, 5, 24 }, NO_ATTK },
X  
X  { MORNING_STAR,	 "Trollsbane", (SPFX_RESTR | SPFX_DCLAS), S_TROLL,
X!   { 0, AD_PHYS, 5, 0 }, NO_ATTK },
X  
X  /*	ARRAY TERMINATOR	*/
X! { 0,  "", 0, 0, NO_ATTK, NO_ATTK }
X  };
X  
X  void
X--- 30,100 ----
X   */
X  
X  { AXE,		 "Cleaver",	SPFX_RESTR, 0,
X!   { 0, AD_PHYS, 3, 12 }, NO_ATTK, A_CHAOS },
X  
X+ #ifdef TOLKIEN
X+ { ORCISH_DAGGER, "Grimtooth",	SPFX_RESTR, 0,
X+   { 0, AD_PHYS, 2, 6 }, NO_ATTK, A_CHAOS },
X+ #else
X+ { DAGGER,	 "Grimtooth",	SPFX_RESTR, 0,
X+   { 0, AD_PHYS, 2, 6 }, NO_ATTK, A_CHAOS },
X+ #endif
X+ 
X  /*  Special purpose swords - various types */
X  
X  { TWO_HANDED_SWORD, "Orcrist",	SPFX_DCLAS, S_ORC,
X!   { 0, AD_PHYS, 5, 0 }, NO_ATTK, A_LAW },
X  
X  #ifdef TOLKIEN
X  { ELVEN_DAGGER,	 "Sting",	(SPFX_WARN | SPFX_DCLAS), S_ORC,
X!   { 0, AD_PHYS, 5, 0 }, NO_ATTK, A_LAW },
X  #else
X  { DAGGER,	 "Sting",	(SPFX_WARN | SPFX_DCLAS), S_ORC,
X!   { 0, AD_PHYS, 5, 0 }, NO_ATTK, A_LAW },
X  #endif
X  
X  { LONG_SWORD,	 "Frost Brand", (SPFX_RESTR | SPFX_ATTK | SPFX_DEFN), 0,
X!   { 0, AD_COLD, 5, 0 }, { 0, AD_COLD, 0, 0 }, A_NEUTRAL },
X  
X  { LONG_SWORD,	 "Fire Brand",	(SPFX_RESTR | SPFX_ATTK | SPFX_DEFN), 0,
X!   { 0, AD_FIRE, 5, 0 }, { 0, AD_FIRE, 0, 0 }, A_NEUTRAL },
X  
X  /* Stormbringer only has a 2 because it can drain a level, providing 8 more */
X  { BROADSWORD,	 "Stormbringer", (SPFX_RESTR | SPFX_ATTK | SPFX_DEFN |
X  								SPFX_DRLI), 0,
X!   { 0, AD_DRLI, 5, 2 }, { 0, AD_DRLI, 0, 0 }, A_CHAOS },
X  
X  { LONG_SWORD,	 "Sunsword",	(SPFX_RESTR | SPFX_DCLAS), 0, /* undead */
X!   { 0, AD_PHYS, 5, 0 }, NO_ATTK, A_LAW },
X  
X  { BROADSWORD,	 "Dragonbane",	(SPFX_RESTR | SPFX_DCLAS), S_DRAGON,
X!   { 0, AD_PHYS, 5, 0 }, NO_ATTK, A_NEUTRAL },
X  
X  { LONG_SWORD,	 "Demonbane",	(SPFX_RESTR | SPFX_DCLAS), 0, /* demons */
X!   { 0, AD_PHYS, 5, 0 }, NO_ATTK, A_LAW },
X  
X+ /* A silver weapon would be appropriate, if we had one. */
X  { LONG_SWORD,	 "Werebane",	(SPFX_RESTR | SPFX_DCLAS), 0, /* weres */
X!   { 0, AD_PHYS, 5, 0 }, NO_ATTK, A_LAW },
X  
X  { LONG_SWORD,	 "Giantslayer", (SPFX_RESTR | SPFX_DCLAS), 0, /* giants */
X!   { 0, AD_PHYS, 5, 0 }, NO_ATTK, A_NEUTRAL },
X  
X! /* Another interesting weapon would be the dwarven hammer or axe with the
X!  * boomerang-like power of returning to the wielder's hand, if the code
X!  * were written to add such an ability.
X!  */
X! { WAR_HAMMER, "Ogresmasher",	(SPFX_RESTR | SPFX_DCLAS),  S_OGRE,
X!   { 0, AD_PHYS, 5, 0 }, NO_ATTK, A_LAW },
X  
X! { WAR_HAMMER, "Mjollnir",	(SPFX_RESTR | SPFX_ATTK),  0,
X!   { 0, AD_ELEC, 5, 24 }, NO_ATTK, A_LAW }, /* Mjo:llnir */
X  
X  { MORNING_STAR,	 "Trollsbane", (SPFX_RESTR | SPFX_DCLAS), S_TROLL,
X!   { 0, AD_PHYS, 5, 0 }, NO_ATTK, A_LAW },
X  
X  /*	ARRAY TERMINATOR	*/
X! { 0,  "", 0, 0, NO_ATTK, NO_ATTK, 0 }
X  };
X  
X  void
X***************
X*** 157,163 ****
X  # if defined(THEOLOGY) && defined(ALTARS)
X  struct obj *
X  mk_aligned_artifact(align)
X! int align;
X  {
X  	register struct artifact *artif;
X  	register struct obj *otmp;
X--- 170,176 ----
X  # if defined(THEOLOGY) && defined(ALTARS)
X  struct obj *
X  mk_aligned_artifact(align)
X! unsigned align;
X  {
X  	register struct artifact *artif;
X  	register struct obj *otmp;
X*** src/Old/attrib.c	Wed Sep  6 15:39:06 1989
X--- src/attrib.c	Tue Sep  5 21:34:05 1989
X***************
X*** 375,381 ****
X  	}
X  }
X  
X- #ifdef POLYSELF
X  void
X  redist_attr() {
X  
X--- 375,380 ----
X***************
X*** 393,399 ****
X  	    if (ABASE(i) < attrmin.a[i]) ABASE(i) = attrmin.a[i];
X  	}
X  }
X- #endif
X  
X  void
X  adjabil(flag)
X--- 392,397 ----
X*** src/Old/bones.c	Wed Sep  6 15:39:26 1989
X--- src/bones.c	Thu Aug 31 19:09:46 1989
X***************
X*** 133,140 ****
X  	/* drop everything; the corpse's possessions are usually cursed */
X  	otmp = invent;
X  	while(otmp) {
X! 		otmp->ox = u.ux;
X! 		otmp->oy = u.uy;
X  		otmp->owornmask = 0;
X  #ifdef TUTTI_FRUTTI
X  		if(otmp->otyp == SLIME_MOLD) goodfruit(otmp->spe);
X--- 133,139 ----
X  	/* drop everything; the corpse's possessions are usually cursed */
X  	otmp = invent;
X  	while(otmp) {
X! 		place_object(otmp, u.ux, u.uy);
X  		otmp->owornmask = 0;
X  #ifdef TUTTI_FRUTTI
X  		if(otmp->otyp == SLIME_MOLD) goodfruit(otmp->spe);
X***************
X*** 144,160 ****
X  			otmp->nobj = fobj;
X  			fobj = invent;
X  			invent = 0;	/* superfluous */
X- 			levl[u.ux][u.uy].omask = 1;
X  			break;
X  		}
X  		otmp = otmp->nobj;
X  	}
X  	if (u.ugrave_arise == -1) {
X! 		if(!(mtmp = makemon(&mons[PM_GHOST], u.ux, u.uy))) return;
X  		Strcpy((char *) mtmp->mextra, plname);
X  	} else {
X- 		in_mklev = TRUE;
X- 	/* tricks makemon() into allowing monster creation on your square */
X  		mons[u.ugrave_arise].pxlth += strlen(plname);
X  		mtmp = makemon(&mons[u.ugrave_arise], u.ux, u.uy);
X  		mons[u.ugrave_arise].pxlth -= strlen(plname);
X--- 143,160 ----
X  			otmp->nobj = fobj;
X  			fobj = invent;
X  			invent = 0;	/* superfluous */
X  			break;
X  		}
X  		otmp = otmp->nobj;
X  	}
X+ 	in_mklev = TRUE;
X+ 	/* tricks makemon() into allowing monster creation on your square */
X  	if (u.ugrave_arise == -1) {
X! 		mtmp = makemon(&mons[PM_GHOST], u.ux, u.uy);
X! 		in_mklev = FALSE;
X! 		if (!mtmp) return;
X  		Strcpy((char *) mtmp->mextra, plname);
X  	} else {
X  		mons[u.ugrave_arise].pxlth += strlen(plname);
X  		mtmp = makemon(&mons[u.ugrave_arise], u.ux, u.uy);
X  		mons[u.ugrave_arise].pxlth -= strlen(plname);
X***************
X*** 279,284 ****
X--- 279,288 ----
X  	register int fd;
X  	register int ok;
X  
X+ #ifdef EXPLORE_MODE
X+ 	if(discover)		/* save bones files for real games */
X+ 		return(0);
X+ #endif
X  	/* wizard check added by GAN 02/05/87 */
X  	if(rn2(3)	/* only once in three times do we find bones */
X  #ifdef WIZARD
X*** src/Old/cmd.c	Wed Sep  6 15:39:48 1989
X--- src/cmd.c	Wed Aug 30 13:10:33 1989
X***************
X*** 559,570 ****
X  	{0,0,0}
X  };
X  #undef M
X- #undef C
X  
X  const struct ext_func_tab extcmdlist[] = {
X  	"chat", "talk to someone", dotalk,	/* converse? */
X  	"dip", "dip an object into something", dodip,
X! 	"force", "force the lock on a chest", doforce,
X  	"jump", "jump to a location", dojump,
X  	"loot", "loot a box on the floor", doloot,
X  #ifdef POLYSELF
X--- 559,569 ----
X  	{0,0,0}
X  };
X  #undef M
X  
X  const struct ext_func_tab extcmdlist[] = {
X  	"chat", "talk to someone", dotalk,	/* converse? */
X  	"dip", "dip an object into something", dodip,
X! 	"force", "force a lock", doforce,
X  	"jump", "jump to a location", dojump,
X  	"loot", "loot a box on the floor", doloot,
X  #ifdef POLYSELF
X***************
X*** 578,596 ****
X  	"rub", "rub a lamp", dorub,
X  	"sit", "sit down", dosit,
X  	"turn", "turn undead", doturn,
X! 	"untrap", "untrap a trapped object", dountrap,
X! 	"wipe", "wipe your face off", dowipe,
X  	"?", "get this list of extended commands", doextlist,
X  	NULL, NULL, donull
X  };
X  
X! char
X  unctrl(sym)
X  char sym;
X  {
X!     return (sym >= ('A' & 037) && sym <= ('Z' & 037)) ? sym + 0140 : sym;
X  }
X  
X  void
X  rhack(cmd)
X  register char *cmd;
X--- 577,608 ----
X  	"rub", "rub a lamp", dorub,
X  	"sit", "sit down", dosit,
X  	"turn", "turn undead", doturn,
X! 	"untrap", "untrap something", dountrap,
X! 	"wipe", "wipe off your face", dowipe,
X  	"?", "get this list of extended commands", doextlist,
X  	NULL, NULL, donull
X  };
X  
X! #ifdef STUPID_CPP
X! static char
X  unctrl(sym)
X  char sym;
X  {
X! 	return (sym >= C('a') && sym <= C('z')) ? sym + 0140 : sym;
X  }
X  
X+ static char
X+ unmeta(sym)
X+ char sym;
X+ {
X+ 	return (sym & 0x7f);
X+ }
X+ #else
X+ #define unctrl(c)	((c) <= C('z') ? (0x60 | (c)) : (c))
X+ #define unmeta(c)	(0x7f & (c))
X+ #endif
X+ 
X+ 
X  void
X  rhack(cmd)
X  register char *cmd;
X***************
X*** 631,637 ****
X  		domove();
X  		return;
X  	}
X! 	if(!flags.num_pad && movecmd(lowc(*cmd))) {
X  		flags.run = 1;
X  	rush:
X  		if(firsttime){
X--- 643,649 ----
X  		domove();
X  		return;
X  	}
X! 	if(movecmd(flags.num_pad ? unmeta(*cmd) : lowc(*cmd))) {
X  		flags.run = 1;
X  	rush:
X  		if(firsttime){
X*** src/Old/do.c	Wed Sep  6 15:40:48 1989
X--- src/do.c	Mon Aug 28 15:54:42 1989
X***************
X*** 318,330 ****
X  	if(u.uswallow)
X  		mpickobj(u.ustuck,obj);
X  	else  {
X- 		obj->ox = u.ux;
X- 		obj->oy = u.uy;
X  		obj->nobj = fobj;
X  		fobj = obj;
X! 		levl[u.ux][u.uy].omask = 1;
X  		if(Invisible) newsym(u.ux,u.uy);
X! 		subfrombill(obj);
X  		stackobj(obj);
X  	}
X  }
X--- 318,328 ----
X  	if(u.uswallow)
X  		mpickobj(u.ustuck,obj);
X  	else  {
X  		obj->nobj = fobj;
X  		fobj = obj;
X! 		place_object(obj, u.ux, u.uy);
X  		if(Invisible) newsym(u.ux,u.uy);
X! 		if(obj != uball) subfrombill(obj);
X  		stackobj(obj);
X  	}
X  }
X***************
X*** 360,371 ****
X  		return(1);
X  	}
X  	if(Levitation) {
X- #ifdef STRONGHOLD
X  		pline("You're floating high above the %s.",
X! 		      levl[u.ux][u.uy].typ == STAIRS ? "stairs" : "ladder");
X! #else
X! 		pline("You're floating high above the stairs.");
X  #endif
X  		return(0);
X  	}
X  
X--- 358,369 ----
X  		return(1);
X  	}
X  	if(Levitation) {
X  		pline("You're floating high above the %s.",
X! 			levl[u.ux][u.uy].typ == STAIRS ? "stairs" :
X! #ifdef STRONGHOLD
X! 			levl[u.ux][u.uy].typ == LADDER ? "ladder" :
X  #endif
X+ 			"trapdoor");
X  		return(0);
X  	}
X  
X***************
X*** 726,732 ****
X  	setsee();
X  	seeobjs();	/* make old cadavers disappear - riv05!a3 */
X  	docrt();
X! 	if(!flags.nopick && (levl[u.ux][u.uy].omask || levl[u.ux][u.uy].gmask))
X  	    pickup(1);
X  	else read_engr_at(u.ux,u.uy);
X  #ifdef HARD
X--- 724,730 ----
X  	setsee();
X  	seeobjs();	/* make old cadavers disappear - riv05!a3 */
X  	docrt();
X! 	if(!flags.nopick && (OBJ_AT(u.ux, u.uy) || levl[u.ux][u.uy].gmask))
X  	    pickup(1);
X  	else read_engr_at(u.ux,u.uy);
X  #ifdef HARD
X*** src/Old/dog.c	Wed Sep  6 15:42:02 1989
X--- src/dog.c	Wed Aug 30 18:49:01 1989
X***************
X*** 260,266 ****
X  		case CARROT:
X  		    return (herbi ? DOGFOOD : MANFOOD);
X  		default:
X! #ifdef SLIME_MOLD
X  		    return (obj->otyp > SLIME_MOLD ?
X  #else
X  		    return (obj->otyp > CLOVE_OF_GARLIC ?
X--- 260,266 ----
X  		case CARROT:
X  		    return (herbi ? DOGFOOD : MANFOOD);
X  		default:
X! #ifdef TUTTI_FRUTTI
X  		    return (obj->otyp > SLIME_MOLD ?
X  #else
X  		    return (obj->otyp > CLOVE_OF_GARLIC ?
X***************
X*** 308,315 ****
X  	mtmp->mflee = 0;
X  	mtmp->mfleetim = 0;
X  	if(mtmp->mtame || mtmp->mfroz ||
X! #ifdef WORM
X! 	   mtmp->wormno ||
X  #endif
X  	   mtmp->isshk || mtmp->isgd ||
X  #if defined(ALTARS) && defined(THEOLOGY)
X--- 308,315 ----
X  	mtmp->mflee = 0;
X  	mtmp->mfleetim = 0;
X  	if(mtmp->mtame || mtmp->mfroz ||
X! #ifdef MEDUSA
X! 	   mtmp->data == &mons[PM_MEDUSA] ||
X  #endif
X  	   mtmp->isshk || mtmp->isgd ||
X  #if defined(ALTARS) && defined(THEOLOGY)
X***************
X*** 321,328 ****
X  	   is_human(mtmp->data) || is_demon(mtmp->data))
X  #endif
X  		return(0);
X- 	/* no tame long worms so they don't try to follow you down stairs
X- 	   or get in your way */
X  	if(obj) {
X  		if(dogfood(mtmp, obj) >= MANFOOD) return(0);
X  		if(cansee(mtmp->mx,mtmp->my))
X--- 321,326 ----
X*** src/Old/dogmove.c	Wed Sep  6 15:42:19 1989
X--- src/dogmove.c	Tue Sep  5 10:23:58 1989
X***************
X*** 247,253 ****
X  		/* dog eschews cursed objects */
X  		/* but likes dog food */
X  		obj = fobj;
X! 		if(levl[nx][ny].omask) 
X  		  while(obj){
X  		    if(obj->ox != nx || obj->oy != ny)
X  			goto nextobj;
X--- 247,253 ----
X  		/* dog eschews cursed objects */
X  		/* but likes dog food */
X  		obj = fobj;
X! 		if(OBJ_AT(nx, ny)) 
X  		  while(obj){
X  		    if(obj->ox != nx || obj->oy != ny)
X  			goto nextobj;
X*** src/Old/dokick.c	Wed Sep  6 15:42:37 1989
X--- src/dokick.c	Tue Sep  5 21:34:52 1989
X***************
X*** 263,269 ****
X  		}
X  		/* stop on a zorkmid */
X  		if(levl[bhitpos.x][bhitpos.y].gmask ||
X! 		     	    levl[bhitpos.x][bhitpos.y].omask) {
X  			tmp_at(-1, -1); /* close call */
X  			return (struct monst *)0;
X  		}
X--- 263,269 ----
X  		}
X  		/* stop on a zorkmid */
X  		if(levl[bhitpos.x][bhitpos.y].gmask ||
X! 		     	    OBJ_AT(bhitpos.x, bhitpos.y)) {
X  			tmp_at(-1, -1); /* close call */
X  			return (struct monst *)0;
X  		}
X***************
X*** 281,293 ****
X  #ifdef KICK
X  static int
X  kick_object(x, y)
X! register int x, y;
X  {
X! 	register int range, odx, ody, cnt = 0;
X  	register struct monst *mon;
X! 	register struct gold *gold;
X  	register struct obj *otmp, *obj;
X! 	register boolean costly = FALSE;
X  
X  	/* if a pile, the "top" object gets kicked */
X  	for (otmp = fobj; otmp; otmp = otmp->nobj)
X--- 281,293 ----
X  #ifdef KICK
X  static int
X  kick_object(x, y)
X! int x, y;
X  {
X! 	int range, odx, ody, cnt = 0;
X  	register struct monst *mon;
X! 	struct gold *gold;
X  	register struct obj *otmp, *obj;
X! 	boolean costly = FALSE;
X  
X  	/* if a pile, the "top" object gets kicked */
X  	for (otmp = fobj; otmp; otmp = otmp->nobj)
X***************
X*** 321,339 ****
X  		long zm;
X  		gold = g_at(x, y);
X  		zm = gold->amount;
X  		if(range < 2 || zm > 300L) /* arbitrary */
X  		    return(0);
X! 		else {
X! 		    freegold(gold);
X! 		    if(!levl[x][y].mmask) newsym(x, y);
X! 		    if(mon = ghit(u.dx, u.dy, range)) {
X  			setmangry(mon); /* not a means for payment to shk */
X  			if(ghitm(mon, zm)) /* was it caught? */
X  			    return(1);
X- 		    }
X- 		    mkgold(zm, bhitpos.x, bhitpos.y);
X- 		    if(cansee(bhitpos.x, bhitpos.y)) prl(bhitpos.x,bhitpos.y);
X  		}
X  		return(1);
X  	}
X  
X--- 321,358 ----
X  		long zm;
X  		gold = g_at(x, y);
X  		zm = gold->amount;
X+ 		if(IS_ROCK(levl[x][y].typ)) {
X+ 			if ((!martial() && rn2(20) > ACURR(A_DEX))
X+ #ifdef POLYSELF
X+ 				|| IS_ROCK(levl[u.ux][u.uy].typ)
X+ #endif
X+ 								) {
X+ 				pline("%s doesn't come loose.",
X+ 					Blind ? "It" : "The gold");
X+ 				return(!rn2(3) || martial());
X+ 			}
X+ 			pline("%s comes loose.", Blind ? "It" : "The gold");
X+ 			freegold(gold);
X+ 			newsym(x, y);
X+ 			mkgold(zm, u.ux, u.uy);
X+ 			if (Invisible
X+ #ifdef POLYSELF
X+ 					&& !u.uundetected
X+ #endif
X+ 						) newsym(u.ux, u.uy);
X+ 			return(1);
X+ 		}
X  		if(range < 2 || zm > 300L) /* arbitrary */
X  		    return(0);
X! 		freegold(gold);
X! 		newsym(x, y);
X! 		if(mon = ghit(u.dx, u.dy, range)) {
X  			setmangry(mon); /* not a means for payment to shk */
X  			if(ghitm(mon, zm)) /* was it caught? */
X  			    return(1);
X  		}
X+ 		mkgold(zm, bhitpos.x, bhitpos.y);
X+ 		if(cansee(bhitpos.x, bhitpos.y)) prl(bhitpos.x,bhitpos.y);
X  		return(1);
X  	}
X  
X***************
X*** 378,388 ****
X  		    You("smash the %s!", xname(obj));
X  		    if(costly) addtobill(obj, FALSE);
X  		    potionbreathe(obj);
X! 		    delobj(obj);	/* takes care of omask */
X  		    return(1);
X  		}
X  	}
X  
X  	/* too heavy to move. make sure not to call bhit  */
X  	/* in this function when range < 2 (a display bug */
X  	/* results otherwise).  			  */
X--- 397,434 ----
X  		    You("smash the %s!", xname(obj));
X  		    if(costly) addtobill(obj, FALSE);
X  		    potionbreathe(obj);
X! 		    delobj(obj);
X  		    return(1);
X  		}
X  	}
X  
X+ 	if(IS_ROCK(levl[x][y].typ)) {
X+ 		if ((!martial() && rn2(20) > ACURR(A_DEX))
X+ #ifdef POLYSELF
X+ 				|| IS_ROCK(levl[u.ux][u.uy].typ)
X+ #endif
X+ 								) {
X+ 			if (Blind) pline("It doesn't come loose.");
X+ 			else pline("The %s do%sn't come loose.",
X+ 				distant_name(obj, xname),
X+ 				(obj->quan==1) ? "es" : "");
X+ 			return(!rn2(3) || martial());
X+ 		}
X+ 		if (Blind) pline("It comes loose.");
X+ 		else pline("The %s come%s loose.", distant_name(obj, xname),
X+ 			(obj->quan==1) ? "s" : "");
X+ 		move_object(obj, u.ux, u.uy);
X+ 		newsym(x, y);
X+ 		stackobj(obj);
X+ 		if (Invisible
X+ #ifdef POLYSELF
X+ 				&& !u.uundetected
X+ #endif
X+ 						) newsym(u.ux, u.uy);
X+ 		if (costly && !costly_spot(u.ux, u.uy)) addtobill(obj, FALSE);
X+ 		return(1);
X+ 	}
X+ 
X  	/* too heavy to move. make sure not to call bhit  */
X  	/* in this function when range < 2 (a display bug */
X  	/* results otherwise).  			  */
X***************
X*** 393,409 ****
X  	    return(0);
X  	}
X  
X! 	if(cnt > 1) {
X! 		/* Needed to fool bhit's display-cleanup to show */
X! 		/* immediately the next object in the pile.  We  */
X! 		/* know here that the object will move, so there */
X! 		/* is no need to worry about omask.		 */
X! 		obj->ox = u.ux;
X! 		obj->oy = u.uy;
X! 	} else {
X! 		levl[x][y].omask = 0;
X! 		if(!levl[x][y].gmask) newsym(x, y);
X! 	}
X  
X  	mon = bhit(u.dx, u.dy, range, obj->olet,
X  			(int (*)()) 0, (int (*)()) 0, obj);
X--- 439,450 ----
X  	    return(0);
X  	}
X  
X! 	/* Needed to fool bhit's display-cleanup to show immediately	*/
X! 	/* the next object in the pile.  We know here that the object	*/
X! 	/* will move, so there is no need to worry about the location,	*/
X! 	/* which merely needs to be something other than ox, oy.	*/
X! 	move_object(obj, u.ux, u.uy);
X! 	if(cnt == 1 && !levl[x][y].mmask) newsym(x, y);
X  
X  	mon = bhit(u.dx, u.dy, range, obj->olet,
X  			(int (*)()) 0, (int (*)()) 0, obj);
X***************
X*** 417,425 ****
X  		if(thitmonst(mon, obj)) return(1);
X  	}
X  	if(costly && !costly_spot(bhitpos.x,bhitpos.y)) addtobill(obj, FALSE);
X! 	obj->ox = bhitpos.x;
X! 	obj->oy = bhitpos.y;
X! 	levl[obj->ox][obj->oy].omask = 1;
X  	stackobj(obj);
X  	if(!levl[obj->ox][obj->oy].mmask) newsym(obj->ox, obj->oy);
X  	return(1);
X--- 458,464 ----
X  		if(thitmonst(mon, obj)) return(1);
X  	}
X  	if(costly && !costly_spot(bhitpos.x,bhitpos.y)) addtobill(obj, FALSE);
X! 	move_object(obj, bhitpos.x, bhitpos.y);
X  	stackobj(obj);
X  	if(!levl[obj->ox][obj->oy].mmask) newsym(obj->ox, obj->oy);
X  	return(1);
X***************
X*** 498,504 ****
X  		return(1);
X  	}
X  
X! 	if((maploc->omask || maploc->gmask) && !Levitation) {
X  		if(kick_object(x, y)) return(1);
X  		else goto ouch;
X  	}
X--- 537,543 ----
X  		return(1);
X  	}
X  
X! 	if((OBJ_AT(x, y) || maploc->gmask) && !Levitation) {
X  		if(kick_object(x, y)) return(1);
X  		else goto ouch;
X  	}
X*** src/Old/dothrow.c	Wed Sep  6 15:43:02 1989
X--- src/dothrow.c	Mon Aug 21 14:52:34 1989
X***************
X*** 160,171 ****
X  		if(obj->otyp == CRYSKNIFE)
X  			obj->otyp = WORM_TOOTH;
X  #endif
X- 		obj->ox = bhitpos.x;
X- 		obj->oy = bhitpos.y;
X  		obj->nobj = fobj;
X  		fobj = obj;
X! 		levl[bhitpos.x][bhitpos.y].omask = 1;
X! 		if(obj->unpaid && costly_spot(bhitpos.x, bhitpos.y))
X  			subfrombill(obj);
X  		stackobj(obj);
X  		if(obj == uball &&
X--- 160,171 ----
X  		if(obj->otyp == CRYSKNIFE)
X  			obj->otyp = WORM_TOOTH;
X  #endif
X  		obj->nobj = fobj;
X  		fobj = obj;
X! 		place_object(obj, bhitpos.x, bhitpos.y);
X! 		if(obj != uball && costly_spot(bhitpos.x, bhitpos.y) &&
X! 		   !(mon && mon->isshk && bhitpos.x == mon->mx &&
X! 		     bhitpos.y == mon->my && !(obj->unpaid)))
X  			subfrombill(obj);
X  		stackobj(obj);
X  		if(obj == uball &&
X*** src/Old/eat.c	Wed Sep  6 15:43:23 1989
X--- src/eat.c	Wed Sep  6 15:12:34 1989
X***************
X*** 461,466 ****
X--- 461,467 ----
X  				tmp = 1;
X  				break;
X  			case DAGGER:
X+ 			case ATHAME:
X  #ifdef WORM
X  			case CRYSKNIFE:
X  #endif
X***************
X*** 541,547 ****
X  #endif
X  			if(rn2(2)
X  #ifdef POLYSELF
X! 				&& u.usym == S_HUMAN
X  #endif
X  							){
X  				You("vomit.");
X--- 542,548 ----
X  #endif
X  			if(rn2(2)
X  #ifdef POLYSELF
X! 				&& !carnivorous(uasmon)
X  #endif
X  							){
X  				You("vomit.");
X***************
X*** 568,573 ****
X--- 569,589 ----
X  				    "Yum!  Your fave fruit!");
X  			else
X  #endif
X+ #ifdef UNIX
X+ 			if (otmp->otyp == APPLE || otmp->otyp == PEAR) {
X+ 			    if (!Hallucination)
X+ 				pline("Core dumped.");
X+ 			    else {
X+ 	/* This is based on an old Usenet joke, a fake a.out manual page */
X+ 				int x = rnd(100);
X+ 				if (x <= 75)
X+ 				    pline("Segmentation fault -- core dumped.");
X+ 				else if (x <= 99)
X+ 				    pline("Bus error -- core dumped.");
X+ 				else pline("Yo' mama -- core dumped.");
X+ 			    }
X+ 			} else
X+ #endif
X  			{
X  			    int oldquan = otmp->quan;
X  			    otmp->quan = 1;
X***************
X*** 751,756 ****
X--- 767,773 ----
X  			flags.botl = 1;
X  			bot();
X  			You("die from starvation.");
X+ 			killer = "starvation";
X  			done(STARVING);
X  		}
X  	}
X***************
X*** 795,811 ****
X  struct obj *
X  floorfood(verb,corpseonly)
X  char *verb;
X! int corpseonly;
X  {
X  	register struct obj *otmp;
X  
X  	/* Is there some food (probably a heavy corpse) here on the ground? */
X  	if(!Levitation && !u.uswallow) {
X! 	if(levl[u.ux][u.uy].omask)
X  	    for(otmp = fobj; otmp; otmp = otmp->nobj) {
X  		if(otmp->ox == u.ux && otmp->oy == u.uy &&
X! 		   (otmp->otyp==CORPSE ||
X! 		   (!corpseonly && otmp->olet == FOOD_SYM))) {
X  			pline("There %s %s here; %s %s? ",
X  				(otmp->quan == 1) ? "is" : "are",
X  				doname(otmp), verb,
X--- 812,827 ----
X  struct obj *
X  floorfood(verb,corpseonly)
X  char *verb;
X! boolean corpseonly;
X  {
X  	register struct obj *otmp;
X  
X  	/* Is there some food (probably a heavy corpse) here on the ground? */
X  	if(!Levitation && !u.uswallow) {
X! 	if(OBJ_AT(u.ux, u.uy))
X  	    for(otmp = fobj; otmp; otmp = otmp->nobj) {
X  		if(otmp->ox == u.ux && otmp->oy == u.uy &&
X! 		   (corpseonly ? otmp->otyp==CORPSE : otmp->olet==FOOD_SYM)) {
X  			pline("There %s %s here; %s %s? ",
X  				(otmp->quan == 1) ? "is" : "are",
X  				doname(otmp), verb,
X*** src/Old/end.c	Wed Sep  6 15:43:49 1989
X--- src/end.c	Tue Sep  5 21:35:16 1989
X***************
X*** 336,342 ****
X  	if(!done_stopprint)
X  	    Printf("Goodbye %s the %s...\n\n", buf2,
X  #ifdef ENDGAME
X! 		   how != ASCENDED ? pl_character : "Demigod");
X  #else
X  		   pl_character);
X  #endif
X--- 336,343 ----
X  	if(!done_stopprint)
X  	    Printf("Goodbye %s the %s...\n\n", buf2,
X  #ifdef ENDGAME
X! 		   how != ASCENDED ? pl_character : 
X! 		   flags.female ? "Demigoddess" : "Demigod");
X  #else
X  		   pl_character);
X  #endif
X***************
X*** 354,360 ****
X  	  if(how == ASCENDED) u.urexp *= 2;
X  #endif
X  	}
X! 	if(how == ESCAPED) {
X  		register struct monst *mtmp;
X  		register struct obj *otmp;
X  		long i;
X--- 355,365 ----
X  	  if(how == ASCENDED) u.urexp *= 2;
X  #endif
X  	}
X! 	if(how == ESCAPED
X! #ifdef ENDGAME
X! 			|| how == ASCENDED
X! #endif
X! 					) {
X  		register struct monst *mtmp;
X  		register struct obj *otmp;
X  		long i;
X***************
X*** 372,382 ****
X--- 377,399 ----
X  				mtmp = mtmp->nmon;
X  			}
X  			if(!done_stopprint)
X+ #ifdef ENDGAME
X+ 		    Printf("\n%s with %ld points,\n",
X+ 			how==ASCENDED ? "went to your reward"
X+ 				: "escaped from the dungeon",
X+ #else
X  		    Printf("\nescaped from the dungeon with %ld points,\n",
X+ #endif
X  			u.urexp);
X  		} else
X  		if(!done_stopprint)
X+ #ifdef ENDGAME
X+ 		  Printf("You %s with %ld points,\n",
X+ 			how==ASCENDED ? "went to your reward"
X+ 				: "escaped from the dungeon",
X+ #else
X  		  Printf("You escaped from the dungeon with %ld points,\n",
X+ #endif
X  		    u.urexp);
X  		get_all_from_box(); /* don't forget things in boxes and bags */
X  		for(otmp = invent; otmp; otmp = otmp->nobj) {
X***************
X*** 425,431 ****
X    Printf("You were level %u with a maximum of %d hit points when you %s.\n",
X  	    u.ulevel, u.uhpmax, ends[how]);
X  	if(how == ESCAPED && !done_stopprint){
X! 		getret();	/* all those pieces of coloured glass ... */
X  		cls();
X  	}
X  #if (defined(WIZARD) || defined(EXPLORE_MODE)) && !defined(LOGFILE)
X--- 442,448 ----
X    Printf("You were level %u with a maximum of %d hit points when you %s.\n",
X  	    u.ulevel, u.uhpmax, ends[how]);
X  	if(how == ESCAPED && !done_stopprint){
X! 		getret();	/* all those pieces of colored glass ... */
X  		cls();
X  	}
X  #if (defined(WIZARD) || defined(EXPLORE_MODE)) && !defined(LOGFILE)
X*** src/Old/engrave.c	Wed Sep  6 15:44:12 1989
X--- src/engrave.c	Fri Sep  1 14:29:05 1989
X***************
X*** 4,11 ****
X  
X  #include	"hack.h"
X  
X- static void del_engr P((struct engr *));
X- 
X  struct engr {
X  	struct engr *nxt_engr;
X  	char *engr_txt;
X--- 4,9 ----
X***************
X*** 20,25 ****
X--- 18,25 ----
X  #define POLY	5	/* temporary type - for polymorphing engraving */
X  } *head_engr;
X  
X+ static void del_engr P((struct engr *));
X+ 
X  /* random engravings */
X  const char *random_engr[] =
X  			 {"Elbereth", "ad ae?ar um",
X***************
X*** 443,449 ****
X  			nomovemsg = "You finish writing.";
X  			if(type != MARK)
X  			nomovemsg = "You finish engraving.";
X! 			if(otmp->olet != WAND_SYM)  {
X  				if(otmp->olet == WEAPON_SYM)
X  					Your("%s dull.",
X  					       aobjnam(otmp, "get"));
X--- 443,449 ----
X  			nomovemsg = "You finish writing.";
X  			if(type != MARK)
X  			nomovemsg = "You finish engraving.";
X! 			if(otmp->olet != WAND_SYM && otmp->otyp != ATHAME)  {
X  				if(otmp->olet == WEAPON_SYM)
X  					Your("%s dull.",
X  					       aobjnam(otmp, "get"));
X*** src/Old/hack.c	Wed Sep  6 15:45:35 1989
X--- src/hack.c	Wed Sep  6 11:53:58 1989
X***************
X*** 78,84 ****
X  	register struct obj *otmp;
X  	register struct trap *ttmp;
X  	register struct	monst *mtmp;
X- 	xchar oldrx, oldry;
X  
X  #ifdef POLYSELF
X  	if (passes_walls(uasmon)) return 0;
X--- 78,83 ----
X***************
X*** 150,161 ****
X  				delobj(otmp);
X  				continue;
X  			}
X! 			oldrx = otmp->ox;
X! 			oldry = otmp->oy;
X! 			otmp->ox = rx;
X! 			otmp->oy = ry;
X! 			set_omask(oldrx, oldry);
X! 			levl[rx][ry].omask = 1;
X  			/* pobj(otmp); */
X  			if(cansee(rx,ry)) atl(rx,ry,otmp->olet);
X  			newsym(u.ux+u.dx, u.uy+u.dy);
X--- 149,155 ----
X  				delobj(otmp);
X  				continue;
X  			}
X! 			move_object(otmp, rx, ry);
X  			/* pobj(otmp); */
X  			if(cansee(rx,ry)) atl(rx,ry,otmp->olet);
X  			newsym(u.ux+u.dx, u.uy+u.dy);
X***************
X*** 208,224 ****
X  register struct obj *obj;
X  register xchar ox, oy;
X  {
X- 	register xchar ox2 = obj->ox, oy2= obj->oy;
X- 
X  	/* Some dirty programming to get display right */
X  	freeobj(obj);
X  	unpobj(obj);
X  	obj->nobj = fobj;
X  	fobj = obj;
X! 	obj->ox = ox;
X! 	obj->oy = oy;
X! 	set_omask(ox2,oy2);
X! 	levl[ox][oy].omask = 1;
X  }
X  
X  #ifdef SINKS
X--- 202,213 ----
X  register struct obj *obj;
X  register xchar ox, oy;
X  {
X  	/* Some dirty programming to get display right */
X  	freeobj(obj);
X  	unpobj(obj);
X  	obj->nobj = fobj;
X  	fobj = obj;
X! 	move_object(obj, ox, oy);
X  }
X  
X  #ifdef SINKS
X***************
X*** 234,240 ****
X  # endif
X  		You("crash to the floor!");
X  		losehp((rn1(10, 20 - (int)ACURR(A_CON))),"fall onto a sink");
X! 		if(levl[u.ux][u.uy].omask)
X  		for(obj=fobj; obj; obj=obj->nobj)
X  		    if(obj->ox == u.ux && obj->oy == u.uy &&
X  		       obj->olet == WEAPON_SYM) {
X--- 223,229 ----
X  # endif
X  		You("crash to the floor!");
X  		losehp((rn1(10, 20 - (int)ACURR(A_CON))),"fall onto a sink");
X! 		if(OBJ_AT(u.ux, u.uy))
X  		for(obj=fobj; obj; obj=obj->nobj)
X  		    if(obj->ox == u.ux && obj->oy == u.uy &&
X  		       obj->olet == WEAPON_SYM) {
X***************
X*** 304,310 ****
X  domove() {
X  	register struct monst *mtmp = (struct monst *)0;
X  	register struct rm *tmpr,*ust;
X! 	register xchar x,y,xx,yy;
X  	struct trap *trap;
X  
X  	u_wipe_engr(rnd(5));
X--- 293,299 ----
X  domove() {
X  	register struct monst *mtmp = (struct monst *)0;
X  	register struct rm *tmpr,*ust;
X! 	register xchar x,y;
X  	struct trap *trap;
X  
X  	u_wipe_engr(rnd(5));
X***************
X*** 315,326 ****
X  		return;
X  	}
X  	if(u.uswallow) {
X  		u.dx = u.dy = 0;
X  		xx = u.ux;
X  		yy = u.uy;
X  		x = u.ux = u.ustuck->mx;
X  		y = u.uy = u.ustuck->my;
X! 		if(xx != u.ustuck->mx || yy != u.ustuck->my) newsym(xx,yy);
X  	} else {
X  		x = u.ux + u.dx;
X  		y = u.uy + u.dy;
X--- 304,318 ----
X  		return;
X  	}
X  	if(u.uswallow) {
X+ 		register xchar xx,yy;
X+ 
X  		u.dx = u.dy = 0;
X  		xx = u.ux;
X  		yy = u.uy;
X  		x = u.ux = u.ustuck->mx;
X  		y = u.uy = u.ustuck->my;
X! 		if(xx != x || yy != y) newsym(xx,yy);
X! 		mtmp = u.ustuck;
X  	} else {
X  		x = u.ux + u.dx;
X  		y = u.uy + u.dy;
X***************
X*** 369,399 ****
X  #endif
X  			}
X  		}
X  	}
X  
X  	u.ux0 = u.ux;
X  	u.uy0 = u.uy;
X- 	/* attack monster */
X  	tmpr = &levl[x][y];
X! 	if (tmpr->mmask) {
X! 		mtmp = m_at(x,y);
X! 		/* Don't attack if you're running */
X! 		if (flags.run && !mtmp->mimic &&
X! 		    (Blind ? Telepat : (!mtmp->minvis || See_invisible))) {
X! 			nomul(0);
X! 			flags.move = 0;
X! 			return;
X! 		}
X! 	}
X! 	if(mtmp || u.uswallow) {
X  		nomul(0);
X  		gethungry();
X  		if(multi < 0) return;	/* we just fainted */
X  
X  		/* try to attack; note that it might evade */
X! 		if(attack(u.uswallow ? u.ustuck : mtmp))
X! 			return;
X  	}
X  	/* not attacking an animal, so we try to move */
X  #ifdef POLYSELF
X  	if(!uasmon->mmove) {
X--- 361,393 ----
X  #endif
X  			}
X  		}
X+ 		if (levl[x][y].mmask) {
X+ 			mtmp = m_at(x,y);
X+ 			/* Don't attack if you're running */
X+ 			if (flags.run && !mtmp->mimic &&
X+ 				    (Blind ? Telepat :
X+ 					    (!mtmp->minvis || See_invisible))) {
X+ 				nomul(0);
X+ 				flags.move = 0;
X+ 				return;
X+ 			}
X+ 		}
X  	}
X  
X  	u.ux0 = u.ux;
X  	u.uy0 = u.uy;
X  	tmpr = &levl[x][y];
X! 
X! 	/* attack monster */
X! 	if(mtmp) {
X  		nomul(0);
X  		gethungry();
X  		if(multi < 0) return;	/* we just fainted */
X  
X  		/* try to attack; note that it might evade */
X! 		if(attack(mtmp)) return;
X  	}
X+ 
X  	/* not attacking an animal, so we try to move */
X  #ifdef POLYSELF
X  	if(!uasmon->mmove) {
X***************
X*** 449,455 ****
X  #endif
X  	ust = &levl[u.ux][u.uy];
X  	if(bad_rock(x,y) ||
X! 	   (u.dx && u.dy && (IS_DOOR(tmpr->typ) || IS_DOOR(ust->typ)))){
X  		flags.move = 0;
X  		nomul(0);
X  		return;
X--- 443,453 ----
X  #endif
X  	ust = &levl[u.ux][u.uy];
X  	if(bad_rock(x,y) ||
X! 	   (u.dx && u.dy
X! #ifdef POLYSELF
X! 			&& !passes_walls(uasmon)
X! #endif
X! 			&& (IS_DOOR(tmpr->typ) || IS_DOOR(ust->typ)))){
X  		flags.move = 0;
X  		nomul(0);
X  		return;
X***************
X*** 492,500 ****
X  
X  		movobj(uball, uchain->ox, uchain->oy);
X  		unpobj(uball);		/* BAH %% */
X! 		uchain->ox = u.ux;
X! 		uchain->oy = u.uy;
X! 		ust->omask = 1;
X  		nomul(-2);
X  		nomovemsg = "";
X  	nodrag:	;
X--- 490,496 ----
X  
X  		movobj(uball, uchain->ox, uchain->oy);
X  		unpobj(uball);		/* BAH %% */
X! 		place_object(uchain, u.ux, u.uy);
X  		nomul(-2);
X  		nomovemsg = "";
X  	nodrag:	;
X***************
X*** 571,577 ****
X  	}
X  #ifdef POLYSELF
X  	if (hides_under(uasmon))
X! 	    u.uundetected = (levl[u.ux][u.uy].omask || levl[u.ux][u.uy].gmask);
X  	else if (u.dx || u.dy) { /* i.e. piercer */
X  	    if (u.usym == S_MIMIC_DEF)
X  		u.usym = S_MIMIC;
X--- 567,573 ----
X  	}
X  #ifdef POLYSELF
X  	if (hides_under(uasmon))
X! 	    u.uundetected = (OBJ_AT(u.ux, u.uy) || levl[u.ux][u.uy].gmask);
X  	else if (u.dx || u.dy) { /* i.e. piercer */
X  	    if (u.usym == S_MIMIC_DEF)
X  		u.usym = S_MIMIC;
X***************
X*** 648,654 ****
X  			dosinkfall();
X  #endif
X  		if(!flags.nopick &&
X! 		   (levl[u.ux][u.uy].omask || levl[u.ux][u.uy].gmask))
X  			pickup(1);
X  		else read_engr_at(u.ux,u.uy);
X  		if(trap = t_at(u.ux,u.uy))
X--- 644,650 ----
X  			dosinkfall();
X  #endif
X  		if(!flags.nopick &&
X! 		   (OBJ_AT(u.ux, u.uy) || levl[u.ux][u.uy].gmask))
X  			pickup(1);
X  		else read_engr_at(u.ux,u.uy);
X  		if(trap = t_at(u.ux,u.uy))
X***************
X*** 669,675 ****
X  			  Blind ? "feel" : "see");
X  		return(1);
X  	}
X! 	if(levl[u.ux][u.uy].omask == 0 && levl[u.ux][u.uy].gmask == 0) {
X  		pline("There is nothing here to pick up.");
X  		return(0);
X  	}
X--- 665,671 ----
X  			  Blind ? "feel" : "see");
X  		return(1);
X  	}
X! 	if(!OBJ_AT(u.ux, u.uy) && levl[u.ux][u.uy].gmask == 0) {
X  		pline("There is nothing here to pick up.");
X  		return(0);
X  	}
X***************
X*** 696,702 ****
X  	for(x = u.ux-1; x <= u.ux+1; x++) for(y = u.uy-1; y <= u.uy+1; y++) {
X  		if(x == u.ux && y == u.uy) continue;
X  		if(levl[x][y].mmask && (mtmp = m_at(x,y)) && !mtmp->mimic &&
X! 		    (!mtmp->minvis || See_invisible || Telepat) && !mtmp->mundetected) {
X  			if((flags.run != 1 && !mtmp->mtame) || (x == u.ux+u.dx && y == u.uy+u.dy))
X  				goto stop;
X  		} else mtmp = 0;
X--- 692,698 ----
X  	for(x = u.ux-1; x <= u.ux+1; x++) for(y = u.uy-1; y <= u.uy+1; y++) {
X  		if(x == u.ux && y == u.uy) continue;
X  		if(levl[x][y].mmask && (mtmp = m_at(x,y)) && !mtmp->mimic &&
X! 		    (!mtmp->minvis || See_invisible) && !mtmp->mundetected) {
X  			if((flags.run != 1 && !mtmp->mtame) || (x == u.ux+u.dx && y == u.uy+u.dy))
X  				goto stop;
X  		} else mtmp = 0;
X***************
X*** 800,806 ****
X  		   !mtmp->mtame && !mtmp->mpeaceful &&
X  		   !noattacks(mtmp->data) &&
X  		   !mtmp->mfroz && !mtmp->msleep &&  /* aplvax!jcn */
X! 		   (!mtmp->minvis || See_invisible || Telepat) &&
X  		   !onscary(u.ux, u.uy, mtmp))
X  			return(1);
X  	}
X--- 796,802 ----
X  		   !mtmp->mtame && !mtmp->mpeaceful &&
X  		   !noattacks(mtmp->data) &&
X  		   !mtmp->mfroz && !mtmp->msleep &&  /* aplvax!jcn */
X! 		   (!mtmp->minvis || See_invisible) &&
X  		   !onscary(u.ux, u.uy, mtmp))
X  			return(1);
X  	}
X*** src/Old/invent.c	Wed Sep  6 15:46:23 1989
X--- src/invent.c	Tue Sep  5 21:34:56 1989
X***************
X*** 201,226 ****
X  {
X  	register struct obj *otmp;
X  	register int found = 0;
X- 	register struct rm *lev = &levl[obj->ox][obj->oy];
X  
X-   	lev->omask = 0;
X- 
X  	if(obj == fobj) {
X  		fobj = fobj->nobj;
X  		found = 1;
X  	}
X! 	for(otmp = fobj; otmp; otmp = otmp->nobj) {
X   	    if (otmp->nobj == obj) {
X  		otmp->nobj = obj->nobj;
X  		found = 1;
X  	    }
X- 	    if (otmp->ox == obj->ox && otmp->oy == obj->oy) {
X- 		lev->omask = 1;
X- 	    }
X- 	}
X    	if (!found) panic("error in freeobj");
X  #ifdef POLYSELF
X! 	if (!levl[u.ux][u.uy].omask && !levl[u.ux][u.uy].gmask) {
X  		u.uundetected = 0;
X  		if (!Invisible) pru();
X  	}
X--- 201,220 ----
X  {
X  	register struct obj *otmp;
X  	register int found = 0;
X  
X  	if(obj == fobj) {
X  		fobj = fobj->nobj;
X  		found = 1;
X  	}
X! 	for(otmp = fobj; otmp; otmp = otmp->nobj)
X   	    if (otmp->nobj == obj) {
X  		otmp->nobj = obj->nobj;
X  		found = 1;
X  	    }
X    	if (!found) panic("error in freeobj");
X+ 	remove_object(obj);
X  #ifdef POLYSELF
X! 	if (!OBJ_AT(u.ux, u.uy) && !levl[u.ux][u.uy].gmask) {
X  		u.uundetected = 0;
X  		if (!Invisible) pru();
X  	}
X***************
X*** 244,250 ****
X  	}
X  	free((genericptr_t) gold);
X  #ifdef POLYSELF
X! 	if (!levl[u.ux][u.uy].omask && !levl[u.ux][u.uy].gmask) {
X  		u.uundetected = 0;
X  		if (!Invisible) pru();
X  	}
X--- 238,244 ----
X  	}
X  	free((genericptr_t) gold);
X  #ifdef POLYSELF
X! 	if (!OBJ_AT(u.ux, u.uy) && !levl[u.ux][u.uy].gmask) {
X  		u.uundetected = 0;
X  		if (!Invisible) pru();
X  	}
X***************
X*** 294,300 ****
X  {
X  	register struct obj *otmp;
X  
X! 	if(levl[x][y].omask)
X  	    for(otmp = fobj; otmp; otmp = otmp->nobj)
X  		if(otmp->ox == x && otmp->oy == y && otmp->otyp == n)
X  		    return(otmp);
X--- 288,294 ----
X  {
X  	register struct obj *otmp;
X  
X! 	if(OBJ_AT(x, y))
X  	    for(otmp = fobj; otmp; otmp = otmp->nobj)
X  		if(otmp->ox == x && otmp->oy == y && otmp->otyp == n)
X  		    return(otmp);
X***************
X*** 895,901 ****
X      	char stuff[BUFSZ];
X      	register int stct;
X      	register struct obj *otmp;
X!     	boolean billx = inshop() && doinvbill(0);
X      	boolean unpd = FALSE;
X  
X  	if (!invent && !u.ugold && !billx) {
X--- 889,895 ----
X      	char stuff[BUFSZ];
X      	register int stct;
X      	register struct obj *otmp;
X!     	boolean billx = in_shop(u.ux, u.uy) && doinvbill(0);
X      	boolean unpd = FALSE;
X  
X  	if (!invent && !u.ugold && !billx) {
X***************
X*** 1139,1145 ****
X  		return( (obj->corpsenm == otmp->corpsenm) &&
X  			(!ONAME(obj) || !strcmp(ONAME(obj), ONAME(otmp))) );
X  
X! 	else if(obj->known == otmp->known) {
X  		return(objects[obj->otyp].oc_merge);
X  	} else return(FALSE);
X  }
X--- 1133,1139 ----
X  		return( (obj->corpsenm == otmp->corpsenm) &&
X  			(!ONAME(obj) || !strcmp(ONAME(obj), ONAME(otmp))) );
X  
X! 	else if(obj->known == otmp->known || !uses_known(otmp)) {
X  		return(objects[obj->otyp].oc_merge);
X  	} else return(FALSE);
X  }
X*** src/Old/ioctl.c	Wed Sep  6 15:47:11 1989
X--- src/ioctl.c	Fri Aug 25 16:02:36 1989
X***************
X*** 16,21 ****
X--- 16,24 ----
X  #else
X  #include	<termio.h>	/* also includes part of <sgtty.h> */
X  struct termio termio;
X+ #ifdef AMIX
X+ #include <sys/ioctl.h>
X+ #endif /* AMIX */
X  #endif
X  
X  void
X***************
X*** 26,32 ****
X  #else
X  	(void) ioctl(fileno(stdin), (int) TCGETA, &termio);
X  #endif
X! #ifdef TIOCGWINSZ
X  	{
X  		/*
X  		 * ttysize is found on Suns and BSD
X--- 29,35 ----
X  #else
X  	(void) ioctl(fileno(stdin), (int) TCGETA, &termio);
X  #endif
X! #if defined(TIOCGWINSZ) && (defined(BSD) || defined(ULTRIX))
X  	{
X  		/*
X  		 * ttysize is found on Suns and BSD
X***************
X*** 34,48 ****
X  		 */
X  		struct winsize ttsz;
X  
X! 		(void) ioctl(fileno(stdin), (int) TIOCGWINSZ, (char *) &ttsz);
X! 		/*
X! 		 * Use the kernel's values for lines and columns if it has
X! 		 * any idea.
X! 		 */
X! 		if (ttsz.ws_row)
X! 			LI = ttsz.ws_row;
X! 		if (ttsz.ws_col)
X! 			CO = ttsz.ws_col;
X  	}
X  #endif
X  }
X--- 37,53 ----
X  		 */
X  		struct winsize ttsz;
X  
X! 		if (ioctl(fileno(stdin), (int)TIOCGWINSZ, (char *)&ttsz) != -1)
X! 		  {
X! 		    /*
X! 		     * Use the kernel's values for lines and columns if it has
X! 		     * any idea.
X! 		     */
X! 		    if (ttsz.ws_row)
X! 		      LI = ttsz.ws_row;
X! 		    if (ttsz.ws_col)
X! 		      CO = ttsz.ws_col;
X! 		  }
X  	}
X  #endif
X  }
X*** src/Old/lev_comp.l	Wed Sep  6 15:48:33 1989
X--- src/lev_comp.l	Mon Sep  4 23:41:56 1989
X***************
X*** 3,12 ****
X--- 3,18 ----
X  /*	Copyright (c) 1989 by Jean-Christophe Collet */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X+ #define LEV_LEX_C
X+ 
X  #include "hack.h"
X  #include "lev_comp.h"
X  #include "sp_lev.h"
X  
X+ #ifdef MSDOS
X+ #undef exit
X+ #endif
X+ 
X  int line_number = 1;
X  
X  /* This is *** UGLY *** but I can't think a better way to do it
X***************
X*** 23,31 ****
X  MAZE		return MAZE_ID;
X  LEVEL		return LEVEL_ID;
X  GEOMETRY	return GEOMETRY_ID;
X! ^MAP$		{ BEGIN MAPC; }
X  <MAPC>[-|}{+SK\\#. ]*\n	{ line_number++; yymore(); }	
X! <MAPC>ENDMAP$	{ BEGIN 0;
X  		  yytext[yyleng-7] = 0; /* Discard \nENDMAP */
X  		  yylval.map = (char *) alloc(strlen(yytext)+1);
X  		  strcpy(yylval.map, yytext+1);
X--- 29,37 ----
X  MAZE		return MAZE_ID;
X  LEVEL		return LEVEL_ID;
X  GEOMETRY	return GEOMETRY_ID;
X! ^MAP\n		{ BEGIN MAPC; }
X  <MAPC>[-|}{+SK\\#. ]*\n	{ line_number++; yymore(); }	
X! <MAPC>ENDMAP\n	{ BEGIN 0;
X  		  yytext[yyleng-7] = 0; /* Discard \nENDMAP */
X  		  yylval.map = (char *) alloc(strlen(yytext)+1);
X  		  strcpy(yylval.map, yytext+1);
X*** src/Old/lev_comp.y	Wed Sep  6 15:48:48 1989
X--- src/lev_comp.y	Sat Sep  2 15:05:38 1989
X***************
X*** 53,59 ****
X  	"trapdoor",	TRAPDOOR,
X  	"teleport",	TELEP_TRAP,
X  	"pit",		PIT,
X! 	"sleeping gas",	SLP_GAS_TRAP,
X  	"magic",	MGTRP,
X  	"board",	SQBRD,
X  	"web",		WEB,
X--- 53,59 ----
X  	"trapdoor",	TRAPDOOR,
X  	"teleport",	TELEP_TRAP,
X  	"pit",		PIT,
X! 	"sleep gas",	SLP_GAS_TRAP,
X  	"magic",	MGTRP,
X  	"board",	SQBRD,
X  	"web",		WEB,
X*** src/Old/lock.c	Wed Sep  6 15:50:04 1989
X--- src/lock.c	Tue Aug 29 18:11:47 1989
X***************
X*** 130,138 ****
X  			otmp->nobj = xlock.box->nobj;
X  			xlock.box->nobj = otmp;
X  			otmp->cobj = (struct obj *)0;
X! 			otmp->ox = u.ux;
X! 			otmp->oy = u.uy;
X! 			levl[u.ux][u.uy].omask = 1;
X  			stackobj(otmp);
X  		    }
X  		} else probj = otmp;
X--- 130,136 ----
X  			otmp->nobj = xlock.box->nobj;
X  			xlock.box->nobj = otmp;
X  			otmp->cobj = (struct obj *)0;
X! 			place_object(otmp, u.ux, u.uy);
X  			stackobj(otmp);
X  		    }
X  		} else probj = otmp;
X***************
X*** 184,190 ****
X  	y = u.uy + u.dy;
X  	if((x == u.ux) && (y == u.uy)) { /* pick the lock on a container */
X  	    c = 'n';			/* in case there are no boxes here */
X! 	    if(levl[x][y].omask)
X  	    for(otmp = fobj; otmp; otmp = otmp->nobj)
X  		if((otmp->ox == x) && (otmp->oy == y))
X  		    if(Is_box(otmp) &&
X--- 182,188 ----
X  	y = u.uy + u.dy;
X  	if((x == u.ux) && (y == u.uy)) { /* pick the lock on a container */
X  	    c = 'n';			/* in case there are no boxes here */
X! 	    if(OBJ_AT(x, y))
X  	    for(otmp = fobj; otmp; otmp = otmp->nobj)
X  		if((otmp->ox == x) && (otmp->oy == y))
X  		    if(Is_box(otmp) &&
X***************
X*** 331,337 ****
X  
X  	/* A lock is made only for the honest man, the thief will break it. */
X  	xlock.box = (struct obj *)0;
X! 	if(levl[u.ux][u.uy].omask)
X  	for(otmp = fobj; otmp; otmp = otmp->nobj)
X  	    if((otmp->ox == u.ux) && (otmp->oy == u.uy))
X  		if(Is_box(otmp)) {
X--- 329,335 ----
X  
X  	/* A lock is made only for the honest man, the thief will break it. */
X  	xlock.box = (struct obj *)0;
X! 	if(OBJ_AT(u.ux, u.uy))
X  	for(otmp = fobj; otmp; otmp = otmp->nobj)
X  	    if((otmp->ox == u.ux) && (otmp->oy == u.uy))
X  		if(Is_box(otmp)) {
X***************
X*** 438,444 ****
X  			"Some creature" : Monnam(m_at(x,y)));
X  		return(TRUE);
X  	}
X! 	if (levl[x][y].omask || levl[x][y].gmask) {
X  obj:
X  		pline("Something's in the way.");
X  		return(TRUE);
X--- 436,442 ----
X  			"Some creature" : Monnam(m_at(x,y)));
X  		return(TRUE);
X  	}
X! 	if (OBJ_AT(x, y) || levl[x][y].gmask) {
X  obj:
X  		pline("Something's in the way.");
X  		return(TRUE);
X***************
X*** 555,563 ****
X  	register struct rm *door = &levl[x][y];
X  	boolean res = 1;
X  
X- 	if(obstructed(x,y))
X- 		return 0;
X- 
X  	if(door->typ == SDOOR) {
X  	    if(otmp->otyp == WAN_OPENING
X  #ifdef SPELLS
X--- 553,558 ----
X***************
X*** 595,600 ****
X--- 590,596 ----
X  #ifdef SPELLS
X  	    case SPE_WIZARD_LOCK:
X  #endif
X+ 		if(obstructed(x,y)) return 0;
X  		if (cansee(x,y))
X  		switch (door->doormask & ~D_TRAPPED) {
X  			case D_CLOSED:
X*** src/Old/mail.c	Wed Sep  6 16:29:55 1989
X--- src/mail.c	Tue Sep  5 21:34:20 1989
X***************
X*** 53,59 ****
X  
X  # ifdef UNIX
X  static struct stat omstat,nmstat;
X! static char *mailbox;
X  static long laststattime;
X  
X  #  ifdef BSD
X--- 53,59 ----
X  
X  # ifdef UNIX
X  static struct stat omstat,nmstat;
X! static char *mailbox = NULL;
X  static long laststattime;
X  
X  #  ifdef BSD
X***************
X*** 65,71 ****
X  
X  void
X  getmailstatus() {
X! 	if(!(mailbox = getenv("MAIL"))) {
X  #  ifdef MAILPATH
X  		mailbox = (char *) alloc(sizeof(MAILPATH)+8);
X  		Strcpy(mailbox, MAILPATH);
X--- 65,71 ----
X  
X  void
X  getmailstatus() {
X! 	if(!mailbox && !(mailbox = getenv("MAIL"))) {
X  #  ifdef MAILPATH
X  		mailbox = (char *) alloc(sizeof(MAILPATH)+8);
X  		Strcpy(mailbox, MAILPATH);
X***************
X*** 180,186 ****
X  		makeknown(SCR_MAIL);
X  		stackobj(fobj);		
X  		verbalize("Oops!");
X- 		more();
X  	} else {
X  		/* set known and do prinv() */
X  		(void) identify(addinv(mksobj(SCR_MAIL,FALSE)));
X--- 180,185 ----
X*** src/Old/makedefs.c	Wed Sep  6 16:30:13 1989
X--- src/makedefs.c	Fri Sep  1 14:25:57 1989
X***************
X*** 63,69 ****
X  char	in_line[256];
X  extern char *gets P((char *));
X  void do_objs(), do_traps(), do_data(), do_date(), do_permonst(), do_rumors();
X! char *limit P((char *,boolean));
X  FILE *_freopen();
X  
X  int
X--- 63,69 ----
X  char	in_line[256];
X  extern char *gets P((char *));
X  void do_objs(), do_traps(), do_data(), do_date(), do_permonst(), do_rumors();
X! char *limit P((char *,BOOLEAN_P));
X  FILE *_freopen();
X  
X  int
X*** src/Old/makemon.c	Wed Sep  6 16:30:35 1989
X--- src/makemon.c	Thu Aug 31 19:09:29 1989
X***************
X*** 542,548 ****
X  		    (ptr == &mons[PM_GIANT_EEL])) && rn2(5))
X  			mtmp->msleep = 1;
X  	} else {
X! 		if(x == u.ux && y == u.uy && ptr->mlet != S_GHOST) {
X  			mnexto(mtmp);
X  			if (ptr->mlet == S_MIMIC) {
X  				set_mimic_sym(mtmp);
X--- 542,548 ----
X  		    (ptr == &mons[PM_GIANT_EEL])) && rn2(5))
X  			mtmp->msleep = 1;
X  	} else {
X! 		if(x == u.ux && y == u.uy) {
X  			mnexto(mtmp);
X  			if (ptr->mlet == S_MIMIC) {
X  				set_mimic_sym(mtmp);
X***************
X*** 1079,1085 ****
X  	roomno = inroom(mtmp->mx, mtmp->my);
X  	if (levl[mtmp->mx][mtmp->my].gmask)
X  		sym = GOLD_SYM;
X! 	else if (levl[mtmp->mx][mtmp->my].omask)
X  		sym = o_at(mtmp->mx,mtmp->my)->olet;
X  	else if (IS_DOOR(levl[mtmp->mx][mtmp->my].typ) ||
X  		 IS_WALL(levl[mtmp->mx][mtmp->my].typ))
X--- 1079,1085 ----
X  	roomno = inroom(mtmp->mx, mtmp->my);
X  	if (levl[mtmp->mx][mtmp->my].gmask)
X  		sym = GOLD_SYM;
X! 	else if (OBJ_AT(mtmp->mx, mtmp->my))
X  		sym = o_at(mtmp->mx,mtmp->my)->olet;
X  	else if (IS_DOOR(levl[mtmp->mx][mtmp->my].typ) ||
X  		 IS_WALL(levl[mtmp->mx][mtmp->my].typ))
X*** src/Old/mcastu.c	Wed Sep  6 16:31:19 1989
X--- src/mcastu.c	Thu Aug 17 23:20:50 1989
X***************
X*** 166,172 ****
X  		    case 5:		/* make invisible if not */
X  		    case 4:
X  			if(!mtmp->minvis) {
X! 			    if(canseemon(mtmp) && !See_invisible && !Telepat)
X  				pline("%s suddenly disappears!",
X  				      Monnam(mtmp));
X  			    mtmp->minvis = 1;
X--- 166,172 ----
X  		    case 5:		/* make invisible if not */
X  		    case 4:
X  			if(!mtmp->minvis) {
X! 			    if(canseemon(mtmp) && !See_invisible)
X  				pline("%s suddenly disappears!",
X  				      Monnam(mtmp));
X  			    mtmp->minvis = 1;
X*** src/Old/mhitm.c	Wed Sep  6 16:31:36 1989
X--- src/mhitm.c	Thu Aug 31 15:17:32 1989
X***************
X*** 15,21 ****
X  static int hitmm P((struct monst *,struct monst *,struct attack *));
X  static int gazemm P((struct monst *,struct monst *,struct attack *));
X  static int gulpmm P((struct monst *,struct monst *,struct attack *));
X! static int explmm P((struct monst *,struct attack *));
X  static int mdamagem P((struct monst *,struct monst *,struct attack *));
X  static void mswingsm P((struct monst *, struct monst *, struct obj *));
X  
X--- 15,21 ----
X  static int hitmm P((struct monst *,struct monst *,struct attack *));
X  static int gazemm P((struct monst *,struct monst *,struct attack *));
X  static int gulpmm P((struct monst *,struct monst *,struct attack *));
X! static int explmm P((struct monst *,struct monst *,struct attack *));
X  static int mdamagem P((struct monst *,struct monst *,struct attack *));
X  static void mswingsm P((struct monst *, struct monst *, struct obj *));
X  
X***************
X*** 153,159 ****
X  
X  		case AT_EXPL:	/* automatic hit if next to */
X  			strike = -1;
X! 			sum[i] = explmm(magr, mattk);
X  			break;
X  
X  		case AT_ENGL:
X--- 153,159 ----
X  
X  		case AT_EXPL:	/* automatic hit if next to */
X  			strike = -1;
X! 			sum[i] = explmm(magr, mdef, mattk);
X  			break;
X  
X  		case AT_ENGL:
X***************
X*** 284,308 ****
X  }
X  
X  static int
X! explmm(magr, mattk)
X! 	register struct monst *magr;
X  	register struct	attack *mattk;
X  {
X- 	register struct monst *mon;
X  
X  	if(cansee(magr->mx, magr->my))
X  		pline("%s explodes!", Monnam(magr));
X  	else	noises(magr, mattk);
X  
X! 	for(mon = fmon; mon; mon = mon->nmon)
X! 	    if(mon != magr) {
X! 		if(dist2(mon->mx, mon->my, magr->mx, magr->my) < 3)
X! 		    (void) mdamagem(magr, mon, mattk);
X! 	    }
X! 
X! 	if(dist2(magr->mx, magr->my, u.ux, u.uy) < 3)
X! 		(void) mdamageu(magr, d((int)mattk->damn, (int)mattk->damd));
X  
X  	mondead(magr);
X  	return(2);
X  }
X--- 284,302 ----
X  }
X  
X  static int
X! explmm(magr, mdef, mattk)
X! 	register struct monst *magr, *mdef;
X  	register struct	attack *mattk;
X  {
X  
X  	if(cansee(magr->mx, magr->my))
X  		pline("%s explodes!", Monnam(magr));
X  	else	noises(magr, mattk);
X  
X! 	(void) mdamagem(magr, mdef, mattk);
X  
X+ 	if(magr->mtame)
X+ 		You("have a sad feeling for a moment, then it passes.");
X  	mondead(magr);
X  	return(2);
X  }
X***************
X*** 325,330 ****
X--- 319,328 ----
X  		if (magr->mcan) break;
X  		if(vis) pline("%s staggers for a moment.", Monnam(mdef));
X  		mdef->mstun = 1;
X+ 		/* fall through */
X+ 	    case AD_WERE:
X+ 	    case AD_HEAL:
X+ 	    case AD_LEGS:
X  	    case AD_PHYS:
X  		if (mattk->aatyp == AT_KICK && thick_skinned(mdef->data))
X  			tmp = 0;
X***************
X*** 657,665 ****
X  	Strcpy(buf, mon_nam(mdef));
X  	if (!flags.verbose || Blind || otemp->olet != WEAPON_SYM) return;
X  	pline("%s %s %s %s at %s.", Monnam(magr),
X! 	      (otemp->otyp == SPEAR ||
X! 	       otemp->otyp == LANCE ||
X! 	       otemp->otyp == GLAIVE ||
X  	       otemp->otyp == TRIDENT) ? "thrusts" : "swings",
X  	      is_female(magr) ? "her" :
X  	      is_human(magr->data) ? "his" : "its",
X--- 655,664 ----
X  	Strcpy(buf, mon_nam(mdef));
X  	if (!flags.verbose || Blind || otemp->olet != WEAPON_SYM) return;
X  	pline("%s %s %s %s at %s.", Monnam(magr),
X! 	      ((otemp->otyp >= SPEAR &&
X! 	        otemp->otyp <= LANCE) ||
X! 	       (otemp->otyp >= PARTISAN &&
X! 	        otemp->otyp <= SPETUM) ||
X  	       otemp->otyp == TRIDENT) ? "thrusts" : "swings",
X  	      is_female(magr) ? "her" :
X  	      is_human(magr->data) ? "his" : "its",
X*** src/Old/mhitu.c	Wed Sep  6 16:32:08 1989
X--- src/mhitu.c	Sat Sep  2 15:05:22 1989
X***************
X*** 84,92 ****
X  {
X  	if (!flags.verbose || Blind || otemp->olet != WEAPON_SYM) return;
X  	pline("%s %s %s %s.", Monnam(mtmp),
X! 	      (otemp->otyp == SPEAR ||
X! 	       otemp->otyp == LANCE ||
X! 	       otemp->otyp == GLAIVE ||
X  	       otemp->otyp == TRIDENT) ? "thrusts" : "swings",
X  	      is_female(mtmp) ? "her" :
X  	      is_human(mtmp->data) ? "his" : "its",
X--- 84,93 ----
X  {
X  	if (!flags.verbose || Blind || otemp->olet != WEAPON_SYM) return;
X  	pline("%s %s %s %s.", Monnam(mtmp),
X! 	      ((otemp->otyp >= SPEAR &&
X! 	        otemp->otyp <= LANCE) ||
X! 	       (otemp->otyp >= PARTISAN &&
X! 	        otemp->otyp <= SPETUM) ||
X  	       otemp->otyp == TRIDENT) ? "thrusts" : "swings",
X  	      is_female(mtmp) ? "her" :
X  	      is_human(mtmp->data) ? "his" : "its",
X***************
X*** 145,161 ****
X  		Monnam(mtmp));
X  }
X  
X! static void
X  regurgitates(mtmp)
X  register struct monst *mtmp;
X  {
X! 	u.ux = mtmp->mx;
X! 	u.uy = mtmp->my;
X! 	u.uswallow = 0;
X! 	u.ustuck = 0;
X  	mnexto(mtmp);
X! 	setsee();
X! 	docrt();
X  	spoteffects();
X  	/* to cover for a case where mtmp is not in a next square */
X  	if(um_dist(mtmp->mx,mtmp->my,1))
X--- 146,158 ----
X  		Monnam(mtmp));
X  }
X  
X! void
X  regurgitates(mtmp)
X  register struct monst *mtmp;
X  {
X! 	unstuck(mtmp);
X  	mnexto(mtmp);
X! 	pru();
X  	spoteffects();
X  	/* to cover for a case where mtmp is not in a next square */
X  	if(um_dist(mtmp->mx,mtmp->my,1))
X***************
X*** 246,252 ****
X  		     pline("Wait, %s!  There's a %s named %s hiding under %s!",
X  			mtmp->mnamelth ? NAME(mtmp) : mtmp->data->mname,
X  			uasmon->mname, plname,
X! 			levl[u.ux][u.uy].omask ? doname(o_at(u.ux,u.uy)) :
X  			"some gold");
X  		    prme();
X  		}
X--- 243,249 ----
X  		     pline("Wait, %s!  There's a %s named %s hiding under %s!",
X  			mtmp->mnamelth ? NAME(mtmp) : mtmp->data->mname,
X  			uasmon->mname, plname,
X! 			OBJ_AT(u.ux, u.uy) ? doname(o_at(u.ux,u.uy)) :
X  			"some gold");
X  		    prme();
X  		}
X***************
X*** 467,473 ****
X  	    if(!(Blind ? Telepat : (HTelepat & WORN_HELMET))) {
X  		register struct obj *obj;
X  
X! 		if(levl[mtmp->mx][mtmp->my].omask == 1) {
X  		    if(obj = o_at(mtmp->mx,mtmp->my))
X  			pline("%s was hidden under %s!",
X  				  Xmonnam(mtmp), doname(obj));
X--- 464,470 ----
X  	    if(!(Blind ? Telepat : (HTelepat & WORN_HELMET))) {
X  		register struct obj *obj;
X  
X! 		if(OBJ_AT(mtmp->mx, mtmp->my)) {
X  		    if(obj = o_at(mtmp->mx,mtmp->my))
X  			pline("%s was hidden under %s!",
X  				  Xmonnam(mtmp), doname(obj));
X***************
X*** 816,822 ****
X  		 * is, no matter what covers it.
X  		 */
X  		getbronze = (mdat == &mons[PM_BLACK_PUDDING] &&
X! 			     uarm && uarm->otyp == BRONZE_PLATE_MAIL);
X  		while (1) {
X  		    switch(rn2(5)) {
X  		    case 0:
X--- 813,819 ----
X  		 * is, no matter what covers it.
X  		 */
X  		getbronze = (mdat == &mons[PM_BLACK_PUDDING] &&
X! 			     uarm && is_corrodeable(uarm));
X  		while (1) {
X  		    switch(rn2(5)) {
X  		    case 0:
X***************
X*** 1520,1526 ****
X  #endif
X  				break;
X  			case 4: You("feel exhausted.");
X! 				losehp(5+rnd(10), "bout of exhaustion");
X  				break;
X  		}
X  	} else {
X--- 1517,1523 ----
X  #endif
X  				break;
X  			case 4: You("feel exhausted.");
X! 				losehp(5+rnd(10), "exhaustion");
X  				break;
X  		}
X  	} else {
X
END_OF_FILE
if test 56862 -ne `wc -c <'patch03c'`; then
    echo shar: \"'patch03c'\" unpacked with wrong size!
fi
# end of 'patch03c'
fi
echo shar: End of archive 3 \(of 6\).
cp /dev/null ark3isdone
MISSING=""
for I in 1 2 3 4 5 6 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 6 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
