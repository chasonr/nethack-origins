Path: utzoo!utgpu!jarvis.csri.toronto.edu!mailrus!csd4.csd.uwm.edu!cs.utexas.edu!uunet!zephyr.ens.tek.com!tekgen!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v08i016:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Patch3a
Message-ID: <4535@tekred.CNA.TEK.COM>
Date: 7 Sep 89 21:47:38 GMT
Sender: nobody@tekred.CNA.TEK.COM
Lines: 2000
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 8, Issue 16
Archive-name: NetHack3/Patch3a
Patch-To: NetHack3: Volume 7, Issue 56-93

	[Here is the 3rd patch to NetHack3, in 6 parts (3a-3f). This
	 should be unpacked in the top level NetHack source directory,
	 then run the do_patch3.sh shell script (if you're on Unix). -br]
[[The main changes included in patch kit 3 are as follows:

A few new objects were added to objects.c, so old save/bones files 
should be thrown out.

Prototypes were adapted to satisfy ANSI C.  Hopefully, we will not see
anymore postings which helpfully fix prototypes for ANSI, while breaking
them for the MSDOS compilers they were, originally, set up for.

Use of $(MAKE), and a better use of $PAGER, in scripts.

Improvements to OS/2 and TOS code, including their Makefiles.

Graphics setting was centralized.

Alignment was added to artifacts, and their suitability was improved.

Discover mode games no longer use up bones files.

Some excess 'register's that were giving Xenix trouble were removed.

We settled an (amusing) argument over "rights" to available bits which
was responsible (unintentionally) for ring-wielding bestowing
long-lasting intrinsic attributes.  

In addition, many bugs were fixed.  Among those were the problems
with polymorphing creatures that swallowed you, finishing with
containers, having chains eaten, external pagers, statue weights, wishing
loopholes, parsing endgame options, and monsters growing up.

In other words, this is a nuts and bolts patch, nothing dramatic but
lots of cleanup.]]

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 6)."
# Contents:  do_patch3.sh patch03a
# Wrapped by billr@saab on Thu Sep  7 14:37:49 1989
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'do_patch3.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'do_patch3.sh'\"
else
echo shar: Extracting \"'do_patch3.sh'\" \(453 characters\)
sed "s/^X//" >'do_patch3.sh' <<'END_OF_FILE'
X#! /bin/sh
X# script to call patch to apply diff files
X# make sure all of the patch files (and this file) are in your top level
X# NetHack directory
X#
Xecho "applying patch3a"
Xpatch -p <patch03a
Xecho "applying patch3b"
Xpatch -p <patch03b
Xecho "applying patch3c"
Xpatch -p <patch03c
Xecho "applying patch3d"
Xpatch -p <patch03d
Xecho "applying patch3e"
Xpatch -p <patch03e
Xecho "applying patch3f"
Xpatch -p <patch03f
Xecho "all patches applied, check for rejects"
END_OF_FILE
if test 453 -ne `wc -c <'do_patch3.sh'`; then
    echo shar: \"'do_patch3.sh'\" unpacked with wrong size!
fi
chmod +x 'do_patch3.sh'
# end of 'do_patch3.sh'
fi
if test -f 'patch03a' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'patch03a'\"
else
echo shar: Extracting \"'patch03a'\" \(55369 characters\)
sed "s/^X//" >'patch03a' <<'END_OF_FILE'
X*** ./Old/Install.dos	Wed Sep  6 15:20:30 1989
X--- ./Install.dos	Mon Sep  4 23:42:21 1989
X***************
X*** 1,5 ****
X! Instructions for installing NetHack 3.0 on an MS-DOS system
X! ===========================================================
X  
X  1.  Make sure all the NetHack files are in the appropriate directory structure.
X      You should have a main directory with subdirectories src, include, auxil,
X--- 1,5 ----
X! Instructions for installing NetHack 3.0 on an MS-DOS or TOS system
X! ==================================================================
X  
X  1.  Make sure all the NetHack files are in the appropriate directory structure.
X      You should have a main directory with subdirectories src, include, auxil,
X***************
X*** 15,29 ****
X      have to run a program such as Rahul Dhesi's 'flip' to convert them.
X  
X  2.  Move everything from the others directory to your src directory; you'll
X!     be needing it, especially pc*.c.  PC NetHack needs msdos.c, ST NetHack
X!     needs tos.c.
X  
X  3.  You should have several Makefiles in your src directory now.  If you are
X      using Microsoft C, rename Makefile.pc to Makefile; if Turbo C, rename
X      Makefile.tcc to Makefile, and also rename Maketcc.ini to Make.ini.
X      NDMake can find Make.ini anywhere on your PATH, so you may relocate it
X!     if you wish.  If you are using another compiler, you will have to adapt
X!     one of the Makefiles and the Make.ini file to your needs.  Good luck.
X  
X      As for the other Makefiles, I would delete them to make space, but you may
X      want to keep them around for comparison in case something goes wrong.  Two
X--- 15,31 ----
X      have to run a program such as Rahul Dhesi's 'flip' to convert them.
X  
X  2.  Move everything from the others directory to your src directory; you'll
X!     be needing it, especially pc*.c.  PC NetHack needs msdos.c, as does
X!     ST NetHack.
X  
X  3.  You should have several Makefiles in your src directory now.  If you are
X      using Microsoft C, rename Makefile.pc to Makefile; if Turbo C, rename
X      Makefile.tcc to Makefile, and also rename Maketcc.ini to Make.ini.
X      NDMake can find Make.ini anywhere on your PATH, so you may relocate it
X!     if you wish.  If you're using the GCC on an Atari ST system, rename
X!     Makefile.st to Makefile.  If you are using another compiler, you will
X!     have to adapt one of the Makefiles (and the Make.ini file, if you're
X!     using NDMake) to your needs.  Good luck.
X  
X      As for the other Makefiles, I would delete them to make space, but you may
X      want to keep them around for comparison in case something goes wrong.  Two
X***************
X*** 32,39 ****
X  
X  4.  Go to the include subdirectory and edit config.h according to the comments
X      to match your system and desired set of features.  Similarly edit
X!     pcconf.h.
X  
X      The base size of the executable, with no extra features, will be around
X      520K in size.  Anything over 540K is likely not to work.  With MicroSoft
X      C, here is an incomplete list of the costs of various additional features
X--- 34,47 ----
X  
X  4.  Go to the include subdirectory and edit config.h according to the comments
X      to match your system and desired set of features.  Similarly edit
X!     pcconf.h.  For Atari ST users, edit tosconf.h.  If you're an ST owner
X!     using something other than the GCC, it's possible that you might
X!     want to define the symbol OLD_TOS and use oldtos.c instead of msdos.c.
X!     This is *not* guaranteed to work, so be prepared to make some changes
X!     either way.
X  
X+     (ST owners can also skip this section, since the complete game will fit
X+      in <1 megabyte, and nothing you do is likely to make it work on a 520).
X      The base size of the executable, with no extra features, will be around
X      520K in size.  Anything over 540K is likely not to work.  With MicroSoft
X      C, here is an incomplete list of the costs of various additional features
X***************
X*** 97,102 ****
X--- 105,114 ----
X      occupied for a long time.  If all goes well, you will get an executable.
X      If you tried to compile in too many features, you probably will not get
X      a working one, and have to start over.
X+ 
X+     TOS users: if you're short on memory (and GCC users will be short on
X+     memory if they only have 2 megabytes) you might want to type
X+     'make -n all >script' and then use the Gulam command 'source script'.
X  
X  8.  Edit NetHack.cnf to reflect your particular setup, following the comments.
X      Then move the file to your game directory, along with the termcap file.
X*** ./Old/Makefile.top	Wed Sep  6 15:20:53 1989
X--- ./Makefile.top	Sun Sep  3 17:28:31 1989
X***************
X*** 31,53 ****
X  AUX = $(AUXHELP) $(VARAUX) $(SPEC_LEVS) license
X  
X  $(GAME):
X! 	( cd src ; make )
X  
X  all:	$(GAME) Guidebook data rumors spec_levs
X  	@echo "Done."
X  
X  Guidebook:
X! 	( cd auxil ; make Guidebook )
X  
X  data:
X! 	( cd auxil ; make data )
X  
X  rumors:
X! 	( cd auxil ; make rumors )
X  
X  spec_levs:
X! 	( cd src ; make lev_comp )
X! 	( cd auxil ; make spec_levs )
X  	
X  update: $(GAME) data rumors spec_levs
X  # copy over new versions of the game files
X--- 31,53 ----
X  AUX = $(AUXHELP) $(VARAUX) $(SPEC_LEVS) license
X  
X  $(GAME):
X! 	( cd src ; $(MAKE) )
X  
X  all:	$(GAME) Guidebook data rumors spec_levs
X  	@echo "Done."
X  
X  Guidebook:
X! 	( cd auxil ; $(MAKE) Guidebook )
X  
X  data:
X! 	( cd auxil ; $(MAKE) data )
X  
X  rumors:
X! 	( cd auxil ; $(MAKE) rumors )
X  
X  spec_levs:
X! 	( cd src ; $(MAKE) lev_comp )
X! 	( cd auxil ; $(MAKE) spec_levs )
X  	
X  update: $(GAME) data rumors spec_levs
X  # copy over new versions of the game files
X***************
X*** 56,61 ****
X--- 56,62 ----
X  	mv $(GAMEDIR)/$(GAME) $(GAMEDIR)/$(GAME).old
X  	cp src/$(GAME) $(GAMEDIR)
X  	sed -e 's;/usr/games/lib/nethackdir;$(GAMEDIR);' \
X+ 		-e 's;HACKDIR/nethack;HACKDIR/$(GAME);' \
X  		< auxil/nethack.sh \
X  		> $(SHELLDIR)/$(GAME)
X  # correct the permissions on the new versions
X***************
X*** 82,87 ****
X--- 83,89 ----
X  	( cd auxil ; cp $(AUX) $(GAMEDIR) )
X  	cp src/$(GAME) $(GAMEDIR)
X  	sed -e 's;/usr/games/lib/nethackdir;$(GAMEDIR);' \
X+ 		-e 's;HACKDIR/nethack;HACKDIR/$(GAME);' \
X  		< auxil/nethack.sh \
X  		> $(SHELLDIR)/$(GAME)
X  # set up the permissions
X***************
X*** 98,107 ****
X  # 'make clean' removes all the .o files, but leaves around all the executables
X  # and compiled data files
X  clean:
X! 	( cd src ; make clean )
X  
X  # 'make spotless' returns the source tree to near-distribution condition.
X  # it removes .o files, executables, and compiled data files
X  spotless:
X! 	( cd src ; make spotless )
X! 	( cd auxil ; make spotless )
X--- 100,109 ----
X  # 'make clean' removes all the .o files, but leaves around all the executables
X  # and compiled data files
X  clean:
X! 	( cd src ; $(MAKE) clean )
X  
X  # 'make spotless' returns the source tree to near-distribution condition.
X  # it removes .o files, executables, and compiled data files
X  spotless:
X! 	( cd src ; $(MAKE) spotless )
X! 	( cd auxil ; $(MAKE) spotless )
X*** ./Old/README	Wed Sep  6 15:21:16 1989
X--- ./README	Sat Sep  2 15:01:34 1989
X***************
X*** 85,94 ****
X  	IBM PC compatibles running MicroSoft C or Turbo C under MS-DOS
X  	Commodore Amiga (probably -- there have been some changes since
X  		the Amiga port was done, but we believe it should still work)
X! 
X!     There are also many hooks for an Atari TOS port, but we have not had a
X!     chance to test the 3.0 code on an Atari.  Undoubtedly, some tweaks will 
X!     have to be made.
X  
X  			- - - - - - - - - - -
X  
X--- 85,91 ----
X  	IBM PC compatibles running MicroSoft C or Turbo C under MS-DOS
X  	Commodore Amiga (probably -- there have been some changes since
X  		the Amiga port was done, but we believe it should still work)
X! 	Atari 1040ST under TOS
X  
X  			- - - - - - - - - - -
X  
X*** amiga/Old/amidos.c	Wed Sep  6 15:22:09 1989
X--- amiga/amidos.c	Thu Aug 31 20:28:51 1989
X***************
X*** 485,493 ****
X  	    append_slash(SAVEF);
X  	} else if (!strncmp(buf, "GRAPHICS", 4)) {
X  	    unsigned int translate[MAXPCHARS+1]; /* for safety */
X! 	    int  i;
X  
X! 	    if ((i = sscanf(bufp,
X  		 "%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d",
X  				&translate[0], &translate[1], &translate[2],
X  				&translate[3], &translate[4], &translate[5],
X--- 485,493 ----
X  	    append_slash(SAVEF);
X  	} else if (!strncmp(buf, "GRAPHICS", 4)) {
X  	    unsigned int translate[MAXPCHARS+1]; /* for safety */
X! 	    int  lth;
X  
X! 	    if ((lth = sscanf(bufp,
X  		 "%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d",
X  				&translate[0], &translate[1], &translate[2],
X  				&translate[3], &translate[4], &translate[5],
X***************
X*** 502,551 ****
X  		    msmsg ("Syntax error in GRAPHICS\n");
X  		    getreturn("to continue");
X  	    } /* Yuck! Worked only with low-byte first!!! */
X! #define SETPCHAR(f, n)	showsyms.f = (i > n) ? translate[n] : defsyms.f
X! 			SETPCHAR(stone, 0);
X! 			SETPCHAR(vwall, 1);
X! 			SETPCHAR(hwall, 2);
X! 			SETPCHAR(tlcorn, 3);
X! 			SETPCHAR(trcorn, 4);
X! 			SETPCHAR(blcorn, 5);
X! 			SETPCHAR(brcorn, 6);
X! 			SETPCHAR(crwall, 7);
X! 			SETPCHAR(tuwall, 8);
X! 			SETPCHAR(tdwall, 9);
X! 			SETPCHAR(tlwall, 10);
X! 			SETPCHAR(trwall, 11);
X! 			SETPCHAR(vbeam, 12);
X! 			SETPCHAR(hbeam, 13);
X! 			SETPCHAR(lslant, 14);
X! 			SETPCHAR(rslant, 15);
X! 			SETPCHAR(door, 16);
X! 			SETPCHAR(room, 17);
X! 			SETPCHAR(corr, 18);
X! 			SETPCHAR(upstair, 19);
X! 			SETPCHAR(dnstair, 20);
X! 			SETPCHAR(trap, 21);
X! 			SETPCHAR(web, 22);
X! 			SETPCHAR(pool, 23);
X! #ifdef FOUNTAINS
X! 			SETPCHAR(fountain, 24);
X! #endif
X! #ifdef SINKS
X! 			SETPCHAR(sink, 25);
X! #endif
X! #ifdef THRONES
X! 			SETPCHAR(throne, 26);
X! #endif
X! #ifdef ALTARS
X! 			SETPCHAR(altar, 27);
X! #endif
X! #ifdef STRONGHOLD
X! 			SETPCHAR(upladder, 28);
X! 			SETPCHAR(dnladder, 29);
X! 			SETPCHAR(dbvwall, 30);
X! 			SETPCHAR(dbhwall, 31);
X! #endif
X! #undef SETPCHAR
X  	} else if (!strncmp(buf, "PATH", 4)) {
X  	    strncpy(PATH, bufp, PATHLEN);
X  
X--- 502,508 ----
X  		    msmsg ("Syntax error in GRAPHICS\n");
X  		    getreturn("to continue");
X  	    } /* Yuck! Worked only with low-byte first!!! */
X! 	    assign_graphics(translate, lth);
X  	} else if (!strncmp(buf, "PATH", 4)) {
X  	    strncpy(PATH, bufp, PATHLEN);
X  
X*** auxil/Old/cmdhelp	Wed Sep  6 15:25:23 1989
X--- auxil/cmdhelp	Mon Aug 28 16:40:55 1989
X***************
X*** 79,85 ****
X  !	Do a shell escape (only if defined)
X  \	Show what object types have been discovered
X  .	Rest one move while doing nothing
X!  	Rest one move while doing nothing (if option restonspace set)
X  :	Look at what is on the floor
X  @	Toggle the pickup option on/off
X  )	Show the weapon currently wielded
X--- 79,85 ----
X  !	Do a shell escape (only if defined)
X  \	Show what object types have been discovered
X  .	Rest one move while doing nothing
X!  	Rest one move while doing nothing (if rest_on_space option is on)
X  :	Look at what is on the floor
X  @	Toggle the pickup option on/off
X  )	Show the weapon currently wielded
X***************
X*** 90,92 ****
X--- 90,106 ----
X  $	Count your gold
X  +	List known spells (only if defined)
X  #	Perform an extended command
X+ M-c	Talk to someone
X+ M-d	Dip an object into something
X+ M-f	Force a lock
X+ M-j	Jump to another location
X+ M-l	Loot a box on the floor
X+ M-m	Use a monster's special ability (only if defined)
X+ M-N	Name an item or type of object
X+ M-o	Offer a sacrifice to the gods (only if defined)
X+ M-p	Pray to the gods for help (only if defined)
X+ M-r	Rub a lamp
X+ M-s	Sit down
X+ M-t	Turn undead
X+ M-u	Untrap something (usually a trapped object)
X+ M-w	Wipe off your face
X*** auxil/Old/data.base	Wed Sep  6 15:25:37 1989
X--- auxil/data.base	Wed Aug 30 18:39:53 1989
X***************
X*** 11,17 ****
X  |	a wall
X  +	a door
X  .	the floor of a room
X! 	a dark part of a room
X  #	a corridor
X  <	a way to the previous level
X  >	a way to the next level
X--- 11,17 ----
X  |	a wall
X  +	a door
X  .	the floor of a room
X!  	a dark part of a room (or a ghost)
X  #	a corridor
X  <	a way to the previous level
X  >	a way to the next level
X*** auxil/Old/nethack.sh	Wed Sep  6 15:27:08 1989
X--- auxil/nethack.sh	Tue Sep  5 21:10:12 1989
X***************
X*** 6,31 ****
X  MAXNROFPLAYERS=4
X  
X  # see if we can find the full path name of PAGER, so help files work properly
X  # ideas from brian@radio.astro.utoronto.ca
X! if test $PAGER
X  then
X! 	if test ! -x $PAGER
X  	then
X  		IFS=:
X  		for i in $PATH
X  		do
X! 			if test -x $i/$PAGER
X  			then
X! 				PAGER=$i/$PAGER
X! 				export PAGER
X  				break
X  			fi
X  		done
X  		IFS=' 	'
X  	fi
X! 	if test ! -x $PAGER
X  	then
X  		echo Cannot find $PAGER -- unsetting PAGER.
X  		unset PAGER
X  	fi
X  fi
X--- 6,47 ----
X  MAXNROFPLAYERS=4
X  
X  # see if we can find the full path name of PAGER, so help files work properly
X+ # assume that if someone sets up a special variable (HACKPAGER) for NetHack,
X+ # it will already be in a form acceptable to NetHack
X  # ideas from brian@radio.astro.utoronto.ca
X! if test \( "xxx$PAGER" != xxx \) -a \( "xxx$HACKPAGER" = xxx \)
X  then
X! 
X! 	HACKPAGER=$PAGER
X! 
X! #	use only the first word of the pager variable
X! #	this prevents problems when looking for file names with trailing
X! #	options, but also makes the options unavailable for later use from
X! #	NetHack
X! 	for i in $HACKPAGER
X! 	do
X! 		HACKPAGER=$i
X! 		break
X! 	done
X! 
X! 	if test ! -f $HACKPAGER
X  	then
X  		IFS=:
X  		for i in $PATH
X  		do
X! 			if test -f $i/$HACKPAGER
X  			then
X! 				HACKPAGER=$i/$HACKPAGER
X! 				export HACKPAGER
X  				break
X  			fi
X  		done
X  		IFS=' 	'
X  	fi
X! 	if test ! -f $HACKPAGER
X  	then
X  		echo Cannot find $PAGER -- unsetting PAGER.
X+ 		unset HACKPAGER
X  		unset PAGER
X  	fi
X  fi
X*** auxil/Old/oracles	Wed Sep  6 15:27:29 1989
X--- auxil/oracles	Thu Aug 31 15:17:16 1989
X***************
X*** 72,74 ****
X--- 72,82 ----
X  Eat a floating eye, blind thyself, and use a mirror in thine own direction,
X  and provided thou art lucky, thou shalt know the approximate locations of
X  thine enemies.
X+ -----
X+ In the nethermost recesses of the dungeon, there standeth a castle, wherein
X+ layeth a wand of wishes.  If thou wouldst gain entry, bear with thee an
X+ instrument of music, for the drawbridge may be charmed down with the proper
X+ melody.  What notes comprise it only the gods know, but a musical mastermind
X+ may yet succeed by witful improvization.  However, the less perspicacious are
X+ not without recourse, should they be prepared to circumambulate the castle to
X+ the postern.
X*** include/Old/config.h	Wed Sep  6 16:56:24 1989
X--- include/config.h	Tue Sep  5 14:05:18 1989
X***************
X*** 19,25 ****
X  #else
X  /* #define MSDOS	/* define for MS-DOS and most other micros */
X  /* #define AMIGA	/* define for Commodore-Amiga */
X! /* #define TOS		/* for Atari 520/1040 */
X  
X  /* #define STUPID	/* avoid some complicated expressions if
X  			   your C compiler chokes on them */
X--- 19,25 ----
X  #else
X  /* #define MSDOS	/* define for MS-DOS and most other micros */
X  /* #define AMIGA	/* define for Commodore-Amiga */
X! /* #define TOS		/* define for Atari 1040ST */
X  
X  /* #define STUPID	/* avoid some complicated expressions if
X  			   your C compiler chokes on them */
X*** include/Old/extern.h	Wed Sep  6 16:57:47 1989
X--- include/extern.h	Wed Sep  6 15:10:37 1989
X***************
X*** 18,23 ****
X--- 18,24 ----
X  E long *alloc P((unsigned int));
X  #endif
X  
X+ #if !defined(MAKEDEFS_C) && !defined(LEV_LEX_C)
X  /* ### apply.c ### */
X  
X  E int doapply();
X***************
X*** 32,40 ****
X  E void unleash_all();
X  E boolean next_to_u();
X  E struct obj *get_mleash P((struct monst *));
X! E void check_leash P((xchar,xchar));
X  #endif
X! E boolean um_dist P((xchar,xchar,xchar));
X  
X  /* ### artifact.c ### */
X  
X--- 33,41 ----
X  E void unleash_all();
X  E boolean next_to_u();
X  E struct obj *get_mleash P((struct monst *));
X! E void check_leash P((XCHAR_P,XCHAR_P));
X  #endif
X! E boolean um_dist P((XCHAR_P,XCHAR_P,XCHAR_P));
X  
X  /* ### artifact.c ### */
X  
X***************
X*** 44,50 ****
X  E boolean spec_ability P((struct obj *,unsigned));
X  E int restr_name P((struct obj *,char *));
X  # if defined(THEOLOGY) && defined(ALTARS)
X! E struct obj *mk_aligned_artifact P((int));
X  # endif
X  E int defends P((int,struct obj *));
X  E int spec_abon P((struct obj *,struct permonst *));
X--- 45,51 ----
X  E boolean spec_ability P((struct obj *,unsigned));
X  E int restr_name P((struct obj *,char *));
X  # if defined(THEOLOGY) && defined(ALTARS)
X! E struct obj *mk_aligned_artifact P((unsigned));
X  # endif
X  E int defends P((int,struct obj *));
X  E int spec_abon P((struct obj *,struct permonst *));
X***************
X*** 53,68 ****
X  
X  /* ### attrib.c ### */
X  
X! E void adjattrib P((int,int,boolean));
X! E void change_luck P((schar));
X! E int stone_luck P((boolean));
X  E void gainstr P((struct obj *,int));
X  E void losestr P((int));
X  E void restore_attrib();
X  E void init_attr P((int));
X- #ifdef POLYSELF
X  E void redist_attr();
X- #endif
X  E void adjabil P((int));
X  E int newhp();
X  E schar acurr();
X--- 54,67 ----
X  
X  /* ### attrib.c ### */
X  
X! E void adjattrib P((int,int,BOOLEAN_P));
X! E void change_luck P((SCHAR_P));
X! E int stone_luck P((BOOLEAN_P));
X  E void gainstr P((struct obj *,int));
X  E void losestr P((int));
X  E void restore_attrib();
X  E void init_attr P((int));
X  E void redist_attr();
X  E void adjabil P((int));
X  E int newhp();
X  E schar acurr();
X***************
X*** 80,96 ****
X  E void set_occupation P((int(*)(),char *,int));
X  #ifdef REDO
X  E char pgetchar();
X! E void pushch P((char));
X! E void savech P((char));
X  #endif
X- E char unctrl P((char));
X  E void rhack P((char *));
X! E char lowc P((char));
X  E void enlightenment();
X! E int xytod P((schar,schar));
X  E void dtoxy P((coord *,int));
X! E int movecmd P((char));
X! E int getdir P((boolean));
X  E void confdir();
X  E int isok P((int,int));
X  E int doextlist();
X--- 79,94 ----
X  E void set_occupation P((int(*)(),char *,int));
X  #ifdef REDO
X  E char pgetchar();
X! E void pushch P((CHAR_P));
X! E void savech P((CHAR_P));
X  #endif
X  E void rhack P((char *));
X! E char lowc P((CHAR_P));
X  E void enlightenment();
X! E int xytod P((SCHAR_P,SCHAR_P));
X  E void dtoxy P((coord *,int));
X! E int movecmd P((CHAR_P));
X! E int getdir P((BOOLEAN_P));
X  E void confdir();
X  E int isok P((int,int));
X  E int doextlist();
X***************
X*** 103,109 ****
X  E int is_drawbridge_wall P((int, int));
X  E boolean is_db_wall P((int, int));
X  E boolean find_drawbridge P((int *, int*));
X! E boolean create_drawbridge P((int, int, int, boolean));
X  E void open_drawbridge P((int, int));
X  E void close_drawbridge P((int, int));
X  E void destroy_drawbridge P((int, int));
X--- 101,107 ----
X  E int is_drawbridge_wall P((int, int));
X  E boolean is_db_wall P((int, int));
X  E boolean find_drawbridge P((int *, int*));
X! E boolean create_drawbridge P((int, int, int, BOOLEAN_P));
X  E void open_drawbridge P((int, int));
X  E void close_drawbridge P((int, int));
X  E void destroy_drawbridge P((int, int));
X***************
X*** 131,137 ****
X  E int doddrop();
X  E int dodown();
X  E int doup();
X! E void goto_level P((int,boolean));
X  E int donull();
X  E int dowipe();
X  E struct obj *splitobj P((struct obj *,int));
X--- 129,135 ----
X  E int doddrop();
X  E int dodown();
X  E int doup();
X! E void goto_level P((int,BOOLEAN_P));
X  E int donull();
X  E int dowipe();
X  E struct obj *splitobj P((struct obj *,int));
X***************
X*** 193,199 ****
X  E void reset_remarm();
X  E int doddoremarm();
X  E int destroy_arm P((struct obj *));
X! E void adj_abon P((struct obj *,schar));
X  
X  /* ### dog.c ### */
X  
X--- 191,197 ----
X  E void reset_remarm();
X  E int doddoremarm();
X  E int destroy_arm P((struct obj *));
X! E void adj_abon P((struct obj *,SCHAR_P));
X  
X  /* ### dog.c ### */
X  
X***************
X*** 204,210 ****
X  E void keepdogs();
X  E void fall_down P((struct monst *,int));
X  E int dogfood P((struct monst *,struct obj *));
X! E int inroom P((xchar,xchar));
X  E int tamedog P((struct monst *,struct obj *));
X  
X  /* ### dogmove.c ### */
X--- 202,208 ----
X  E void keepdogs();
X  E void fall_down P((struct monst *,int));
X  E int dogfood P((struct monst *,struct obj *));
X! E int inroom P((XCHAR_P,XCHAR_P));
X  E int tamedog P((struct monst *,struct obj *));
X  
X  /* ### dogmove.c ### */
X***************
X*** 214,220 ****
X  /* ### dokick.c ### */
X  
X  E boolean ghitm P((struct monst *,long));
X! E boolean bad_kick_throw_pos P((xchar,xchar));
X  E struct monst *ghit P((int,int,int));
X  E int dokick();
X  
X--- 212,218 ----
X  /* ### dokick.c ### */
X  
X  E boolean ghitm P((struct monst *,long));
X! E boolean bad_kick_throw_pos P((XCHAR_P,XCHAR_P));
X  E struct monst *ghit P((int,int,int));
X  E int dokick();
X  
X***************
X*** 223,229 ****
X  E int dothrow();
X  E int throwit P((struct obj *));
X  E int thitmonst P((struct monst *,struct obj *));
X! E int breaks P((struct obj *,boolean));
X  
X  /* ### eat.c ### */
X  
X--- 221,227 ----
X  E int dothrow();
X  E int throwit P((struct obj *));
X  E int thitmonst P((struct monst *,struct obj *));
X! E int breaks P((struct obj *,BOOLEAN_P));
X  
X  /* ### eat.c ### */
X  
X***************
X*** 233,241 ****
X  E void gethungry();
X  E void morehungry P((int));
X  E void lesshungry P((int));
X! E void newuhs P((boolean));
X  E void vomit();
X! E struct obj *floorfood P((char *,int));
X  
X  /* ### end.c ### */
X  
X--- 231,239 ----
X  E void gethungry();
X  E void morehungry P((int));
X  E void lesshungry P((int));
X! E void newuhs P((BOOLEAN_P));
X  E void vomit();
X! E struct obj *floorfood P((char *,BOOLEAN_P));
X  
X  /* ### end.c ### */
X  
X***************
X*** 242,248 ****
X  E int done1();
X  E int done2();
X  E void done_in_by P((struct monst *));
X! E void panic P((char *,...));
X  E void done P((int));
X  E void clearlocks();
X  #ifdef NOSAVEONHANGUP
X--- 240,246 ----
X  E int done1();
X  E int done2();
X  E void done_in_by P((struct monst *));
X! E void panic V((char *,...));
X  E void done P((int));
X  E void clearlocks();
X  #ifdef NOSAVEONHANGUP
X***************
X*** 252,261 ****
X  /* ### engrave.c ### */
X  
X  #ifdef ELBERETH
X! E int sengr_at P((char *,xchar,xchar));
X  #endif
X  E void u_wipe_engr P((int));
X! E void wipe_engr_at P((xchar,xchar,xchar));
X  E void read_engr_at P((int,int));
X  E void make_engr_at P((int,int,char *));
X  E int freehand();
X--- 250,259 ----
X  /* ### engrave.c ### */
X  
X  #ifdef ELBERETH
X! E int sengr_at P((char *,XCHAR_P,XCHAR_P));
X  #endif
X  E void u_wipe_engr P((int));
X! E void wipe_engr_at P((XCHAR_P,XCHAR_P,XCHAR_P));
X  E void read_engr_at P((int,int));
X  E void make_engr_at P((int,int,char *));
X  E int freehand();
X***************
X*** 308,321 ****
X  
X  E void unsee();
X  E void seeoff P((int));
X! E void movobj P((struct obj *,xchar,xchar));
X! E boolean may_dig P((xchar,xchar));
X  E void domove();
X  E void spoteffects();
X  E int dopickup();
X  E void lookaround();
X  E int monster_nearby();
X! E int cansee P((xchar,xchar));
X  E int sgn P((int));
X  E void getcorners
X  	P((xchar *,xchar *,xchar *,xchar *,xchar *,xchar *,xchar *,xchar *));
X--- 306,319 ----
X  
X  E void unsee();
X  E void seeoff P((int));
X! E void movobj P((struct obj *,XCHAR_P,XCHAR_P));
X! E boolean may_dig P((XCHAR_P,XCHAR_P));
X  E void domove();
X  E void spoteffects();
X  E int dopickup();
X  E void lookaround();
X  E int monster_nearby();
X! E int cansee P((XCHAR_P,XCHAR_P));
X  E int sgn P((int));
X  E void getcorners
X  	P((xchar *,xchar *,xchar *,xchar *,xchar *,xchar *,xchar *,xchar *));
X***************
X*** 365,373 ****
X  E int doprring();
X  E int dopramulet();
X  E int doprtool();
X! E int digit P((char));
X  E void useupf P((struct obj *));
X! E char *let_to_name P((char));
X  E void reassign();
X  
X  /* ### ioctl.c ### */
X--- 363,371 ----
X  E int doprring();
X  E int dopramulet();
X  E int doprtool();
X! E int digit P((CHAR_P));
X  E void useupf P((struct obj *));
X! E char *let_to_name P((CHAR_P));
X  E void reassign();
X  
X  /* ### ioctl.c ### */
X***************
X*** 403,415 ****
X  /* ### makemon.c ### */
X  
X  E struct monst *makemon P((struct permonst *,int,int));
X! E void enexto P((coord *,xchar,xchar,struct permonst *));
X  E int goodpos P((int,int, struct permonst *));
X  E void rloc P((struct monst *));
X  E struct monst *mkmon_at P((char *,int,int));
X  E void init_monstr();
X  E struct permonst *rndmonst();
X! E struct permonst *mkclass P((char));
X  E int adj_lev P((struct permonst *));
X  E struct permonst *grow_up P((struct monst *));
X  E int mongets P((struct monst *,int));
X--- 401,413 ----
X  /* ### makemon.c ### */
X  
X  E struct monst *makemon P((struct permonst *,int,int));
X! E void enexto P((coord *,XCHAR_P,XCHAR_P,struct permonst *));
X  E int goodpos P((int,int, struct permonst *));
X  E void rloc P((struct monst *));
X  E struct monst *mkmon_at P((char *,int,int));
X  E void init_monstr();
X  E struct permonst *rndmonst();
X! E struct permonst *mkclass P((CHAR_P));
X  E int adj_lev P((struct permonst *));
X  E struct permonst *grow_up P((struct monst *));
X  E int mongets P((struct monst *,int));
X***************
X*** 439,444 ****
X--- 437,443 ----
X  #ifdef POLYSELF
X  E struct monst *cloneu();
X  #endif
X+ E void regurgitates P((struct monst *));
X  E int mattacku P((struct monst *));
X  E void mdamageu P((struct monst *,int));
X  E int could_seduce P((struct monst *,struct monst *,struct attack *));
X***************
X*** 454,460 ****
X  E boolean place_oracle P((struct mkroom *,int *,int *,int *));
X  #endif
X  E void mklev();
X! E int okdoor P((xchar,xchar));
X  E void dodoor P((int,int,struct mkroom *));
X  E void mktrap P((int,int,struct mkroom *));
X  E void mkfount P((int,struct mkroom *));
X--- 453,459 ----
X  E boolean place_oracle P((struct mkroom *,int *,int *,int *));
X  #endif
X  E void mklev();
X! E int okdoor P((XCHAR_P,XCHAR_P));
X  E void dodoor P((int,int,struct mkroom *));
X  E void mktrap P((int,int,struct mkroom *));
X  E void mkfount P((int,struct mkroom *));
X***************
X*** 462,468 ****
X  /* ### mkmaze.c ### */
X  
X  #if defined(WALLIFIED_MAZE) || defined(STRONGHOLD)
X! E void wallification P((int,int,int,int,boolean));
X  #endif
X  E void walkfrom P((int,int));
X  E void makemaz();
X--- 461,467 ----
X  /* ### mkmaze.c ### */
X  
X  #if defined(WALLIFIED_MAZE) || defined(STRONGHOLD)
X! E void wallification P((int,int,int,int,BOOLEAN_P));
X  #endif
X  E void walkfrom P((int,int));
X  E void makemaz();
X***************
X*** 472,498 ****
X  
X  /* ### mkobj.c ### */
X  
X! E struct obj *mkobj_at P((char,int,int));
X  E struct obj *mksobj_at P((int,int,int));
X! E struct obj *mkobj P((char,boolean));
X  E int rndmonnum();
X! E struct obj *mksobj P((int,boolean));
X  E int letter P((int));
X  E int weight P((struct obj *));
X  E void mkgold P((long,int,int));
X! E struct obj *mkcorpse_at P((struct permonst *,int,int));
X! E struct obj *mk_tt_corpse P((int,int));
X! E struct obj *mkstatue P((struct permonst *,int,int));
X! E struct obj *mk_named_object P((int, struct permonst *,int,int,char *,int));
X! #ifdef MEDUSA
X! E struct obj *mk_tt_statue P((int,int));
X! #endif
X  E void bless P((struct obj *));
X  E void curse P((struct obj *));
X  E void blessorcurse P((struct obj *,int));
X  E boolean is_flammable P((struct obj *));
X  E boolean is_rustprone P((struct obj *));
X! E void set_omask P((xchar,xchar));
X  
X  /* ### mkroom.c ### */
X  
X--- 471,499 ----
X  
X  /* ### mkobj.c ### */
X  
X! E struct obj *mkobj_at P((CHAR_P,int,int));
X  E struct obj *mksobj_at P((int,int,int));
X! E struct obj *mkobj P((CHAR_P,BOOLEAN_P));
X  E int rndmonnum();
X! E struct obj *mksobj P((int,BOOLEAN_P));
X  E int letter P((int));
X  E int weight P((struct obj *));
X  E void mkgold P((long,int,int));
X! E struct obj *mkcorpstat P((int,struct permonst *,int,int));
X! E struct obj *mk_tt_object P((int,int,int));
X! E struct obj *mk_named_object P((int,struct permonst *,int,int,char *,int));
X  E void bless P((struct obj *));
X  E void curse P((struct obj *));
X  E void blessorcurse P((struct obj *,int));
X+ #ifdef STUPID_CPP
X  E boolean is_flammable P((struct obj *));
X  E boolean is_rustprone P((struct obj *));
X! E boolean is_corrodeable P((struct obj *));
X! #endif
X! E boolean OBJ_AT P((int,int));
X! E void place_object P((struct obj *,int,int));
X! E void move_object P((struct obj *,int,int));
X! E void remove_object P((struct obj *));
X  
X  /* ### mkroom.c ### */
X  
X***************
X*** 527,538 ****
X  E void unstuck P((struct monst *));
X  E void killed P((struct monst *));
X  E void xkilled P((struct monst *,int));
X! E void kludge P((char *,char *,...));
X  E void rescham();
X  E void restartcham();
X  E int newcham P((struct monst *,struct permonst *));
X  E void mnexto P((struct monst *));
X! E void mnearto P((struct monst *, xchar, xchar, boolean));
X  E void setmangry P((struct monst *));
X  E int disturb P((struct monst *));
X  E void mondied P((struct monst *));
X--- 528,539 ----
X  E void unstuck P((struct monst *));
X  E void killed P((struct monst *));
X  E void xkilled P((struct monst *,int));
X! E void kludge V((char *,char *,...));
X  E void rescham();
X  E void restartcham();
X  E int newcham P((struct monst *,struct permonst *));
X  E void mnexto P((struct monst *));
X! E void mnearto P((struct monst *, XCHAR_P, XCHAR_P, BOOLEAN_P));
X  E void setmangry P((struct monst *));
X  E int disturb P((struct monst *));
X  E void mondied P((struct monst *));
X***************
X*** 599,605 ****
X  E void set_lock_and_bones();
X  E void append_slash P((char *));
X  E void getreturn P((char *));
X! E void msmsg P((char *,...));
X  E void chdrive P((char *));
X  # ifndef TOS
X  E void disable_ctrlP();
X--- 600,606 ----
X  E void set_lock_and_bones();
X  E void append_slash P((char *));
X  E void getreturn P((char *));
X! E void msmsg V((char *,...));
X  E void chdrive P((char *));
X  # ifndef TOS
X  E void disable_ctrlP();
X***************
X*** 614,620 ****
X  # endif
X  #endif /* MSDOS */
X  #ifdef TOS
X! E int _copyfile P((int, int));
X  E int kbhit();
X  #endif /* TOS */
X  
X--- 615,621 ----
X  # endif
X  #endif /* MSDOS */
X  #ifdef TOS
X! E int _copyfile P((char *, char *));
X  E int kbhit();
X  #endif /* TOS */
X  
X***************
X*** 624,630 ****
X  E int thrwmu P((struct monst *));
X  E int spitmu P((struct monst *));
X  E int breamu P((struct monst *,struct attack *));
X! E boolean linedup P((xchar,xchar,xchar,xchar));
X  E boolean lined_up P((struct monst *));
X  E struct obj *m_carrying P((struct monst *,int));
X  E void m_useup P((struct monst *,struct obj *));
X--- 625,631 ----
X  E int thrwmu P((struct monst *));
X  E int spitmu P((struct monst *));
X  E int breamu P((struct monst *,struct attack *));
X! E boolean linedup P((XCHAR_P,XCHAR_P,XCHAR_P,XCHAR_P));
X  E boolean lined_up P((struct monst *));
X  E struct obj *m_carrying P((struct monst *,int));
X  E void m_useup P((struct monst *,struct obj *));
X***************
X*** 637,643 ****
X  
X  /* ### o_init.c ### */
X  
X! E int letindex P((char));
X  E void init_objects();
X  E void oinit();
X  E void savenames P((int));
X--- 638,644 ----
X  
X  /* ### o_init.c ### */
X  
X! E int letindex P((CHAR_P));
X  E void init_objects();
X  E void oinit();
X  E void savenames P((int));
X***************
X*** 661,667 ****
X  /* ### options.c ### */
X  
X  E void initoptions();
X! E void parseoptions P((char *,boolean));
X  E int doset();
X  E int dotogglepickup();
X  E void option_help();
X--- 662,669 ----
X  /* ### options.c ### */
X  
X  E void initoptions();
X! E void assign_graphics P((unsigned int *, int));
X! E void parseoptions P((char *,BOOLEAN_P));
X  E int doset();
X  E int dotogglepickup();
X  E void option_help();
X***************
X*** 682,688 ****
X  E void cornline P((int,char *));
X  E int dohelp();
X  E int dohistory();
X! E int page_file P((char *,boolean));
X  #ifdef UNIX
X  #ifdef SHELL
X  E int dosh();
X--- 684,690 ----
X  E void cornline P((int,char *));
X  E int dohelp();
X  E int dohistory();
X! E int page_file P((char *,BOOLEAN_P));
X  #ifdef UNIX
X  #ifdef SHELL
X  E int dosh();
X***************
X*** 696,704 ****
X  E int (*occupation)();
X  E int (*afternmv)();
X  E void askname();
X! E void impossible P((char *,...));
X  #ifdef CHDIR
X! E void chdirx P((char *,boolean));
X  #endif /* CHDIR */
X  E void stop_occupation();
X  #endif /* MSDOS */
X--- 698,706 ----
X  E int (*occupation)();
X  E int (*afternmv)();
X  E void askname();
X! E void impossible V((char *,...));
X  #ifdef CHDIR
X! E void chdirx P((char *,BOOLEAN_P));
X  #endif /* CHDIR */
X  E void stop_occupation();
X  #endif /* MSDOS */
X***************
X*** 708,714 ****
X  #ifdef MSDOS
X  E void gettty();
X  E void settty P((char *));
X! E void error P((char *,...));
X  #endif /* MSDOS */
X  
X  /* ### pcunix.c ### */
X--- 710,716 ----
X  #ifdef MSDOS
X  E void gettty();
X  E void settty P((char *));
X! E void error V((char *,...));
X  #endif /* MSDOS */
X  
X  /* ### pcunix.c ### */
X***************
X*** 739,744 ****
X--- 741,747 ----
X  
X  /* ### polyself.c ### */
X  
X+ E void newman();
X  #ifdef POLYSELF
X  E void polyself();
X  E int polymon P((int));
X***************
X*** 761,775 ****
X  
X  /* ### potion.c ### */
X  
X! E void make_confused P((long,boolean));
X! E void make_stunned P((long,boolean));
X! E void make_blinded P((long,boolean));
X! E void make_sick P((long,boolean));
X! E void make_hallucinated P((long,boolean));
X  E int dodrink();
X  E int dopotion P((struct obj *));
X  E int peffects P((struct obj *));
X! E void healup P((int,int,boolean,boolean));
X  E void strange_feeling P((struct obj *,char *));
X  E void potionhit P((struct monst *,struct obj *));
X  E void potionbreathe P((struct obj *));
X--- 764,778 ----
X  
X  /* ### potion.c ### */
X  
X! E void make_confused P((long,BOOLEAN_P));
X! E void make_stunned P((long,BOOLEAN_P));
X! E void make_blinded P((long,BOOLEAN_P));
X! E void make_sick P((long,BOOLEAN_P));
X! E void make_hallucinated P((long,BOOLEAN_P));
X  E int dodrink();
X  E int dopotion P((struct obj *));
X  E int peffects P((struct obj *));
X! E void healup P((int,int,BOOLEAN_P,BOOLEAN_P));
X  E void strange_feeling P((struct obj *,char *));
X  E void potionhit P((struct monst *,struct obj *));
X  E void potionbreathe P((struct obj *));
X***************
X*** 789,795 ****
X  E int doturn();
X  #ifdef ALTARS
X  E char *a_gname();
X! E char *a_gname_at P((xchar,xchar));
X  # ifdef THEOLOGY
X  E void altar_wrath P((int,int));
X  # endif
X--- 792,798 ----
X  E int doturn();
X  #ifdef ALTARS
X  E char *a_gname();
X! E char *a_gname_at P((XCHAR_P,XCHAR_P));
X  # ifdef THEOLOGY
X  E void altar_wrath P((int,int));
X  # endif
X***************
X*** 799,807 ****
X  
X  E void swallowed();
X  E void setclipped();
X! E void at P((xchar,xchar,uchar,uchar));
X  E void prme();
X! E void shieldeff P((xchar,xchar));
X  E int doredraw();
X  E void docrt();
X  E void docorner P((int,int));
X--- 802,810 ----
X  
X  E void swallowed();
X  E void setclipped();
X! E void at P((XCHAR_P,XCHAR_P,UCHAR_P,UCHAR_P));
X  E void prme();
X! E void shieldeff P((XCHAR_P,XCHAR_P));
X  E int doredraw();
X  E void docrt();
X  E void docorner P((int,int));
X***************
X*** 822,829 ****
X  
X  /* ### priest.c ### */
X  
X! E int move_special P((struct monst *,schar,schar,boolean,boolean,
X! 			xchar,xchar,xchar,xchar));
X  #if defined(ALTARS) && defined(THEOLOGY)
X  E struct mkroom *in_temple P((int,int));
X  E int pri_move P((struct monst *));
X--- 825,832 ----
X  
X  /* ### priest.c ### */
X  
X! E int move_special P((struct monst *,SCHAR_P,SCHAR_P,BOOLEAN_P,BOOLEAN_P,
X! 			XCHAR_P,XCHAR_P,XCHAR_P,XCHAR_P));
X  #if defined(ALTARS) && defined(THEOLOGY)
X  E struct mkroom *in_temple P((int,int));
X  E int pri_move P((struct monst *));
X***************
X*** 839,845 ****
X  
X  /* ### prisym.c ### */
X  
X! E void atl P((int,int,char));
X  E void on_scr P((int,int));
X  E void tmp_at P((int,int));
X  E void Tmp_at2 P((int,int));
X--- 842,848 ----
X  
X  /* ### prisym.c ### */
X  
X! E void atl P((int,int,CHAR_P));
X  E void on_scr P((int,int));
X  E void tmp_at P((int,int));
X  E void Tmp_at2 P((int,int));
X***************
X*** 846,852 ****
X  E void curs_on_u();
X  E void pru();
X  E void prl P((int,int));
X! E uchar news0 P((xchar,xchar));
X  E void newsym P((int,int));
X  E void mnewsym P((int,int));
X  E void nosee P((int,int));
X--- 849,855 ----
X  E void curs_on_u();
X  E void pru();
X  E void prl P((int,int));
X! E uchar news0 P((XCHAR_P,XCHAR_P));
X  E void newsym P((int,int));
X  E void mnewsym P((int,int));
X  E void nosee P((int,int));
X***************
X*** 862,868 ****
X  
X  E int doread();
X  E int seffects P((struct obj *));
X! E void litroom P((boolean));
X  E void do_genocide P((int));
X  E void do_mapping();
X  E void do_vicinity_map();
X--- 865,871 ----
X  
X  E int doread();
X  E int seffects P((struct obj *));
X! E void litroom P((BOOLEAN_P));
X  E void do_genocide P((int));
X  E void do_mapping();
X  E void do_vicinity_map();
X***************
X*** 878,884 ****
X  /* ### restore.c ### */
X  
X  E int dorecover P((int));
X! E void getlev P((int,int,xchar,boolean));
X  #ifdef ZEROCOMP
X  E void minit();
X  E int mread P((int,genericptr_t,unsigned int));
X--- 881,887 ----
X  /* ### restore.c ### */
X  
X  E int dorecover P((int));
X! E void getlev P((int,int,XCHAR_P,BOOLEAN_P));
X  #ifdef ZEROCOMP
X  E void minit();
X  E int mread P((int,genericptr_t,unsigned int));
X***************
X*** 904,910 ****
X  
X  /* ### rumors.c ### */
X  
X! E void outrumor P((int,boolean));
X  #ifdef ORACLE
X  E int doconsult P((struct monst *));
X  #endif
X--- 907,913 ----
X  
X  /* ### rumors.c ### */
X  
X! E void outrumor P((int,BOOLEAN_P));
X  #ifdef ORACLE
X  E int doconsult P((struct monst *));
X  #endif
X***************
X*** 917,926 ****
X  #endif /* NOSAVEONHANGUP */
X  E int dosave0();
X  #if defined(DGK) && !defined(OLD_TOS)
X! E boolean savelev P((int,xchar,int));
X  E boolean swapin_file P((int));
X  #else /* DGK && !OLD_TOS */
X! E void savelev P((int, xchar));
X  #endif /* DGK && !OLD_TOS */
X  #ifdef ZEROCOMP
X  E void bflush P((int));
X--- 920,929 ----
X  #endif /* NOSAVEONHANGUP */
X  E int dosave0();
X  #if defined(DGK) && !defined(OLD_TOS)
X! E boolean savelev P((int,XCHAR_P,int));
X  E boolean swapin_file P((int));
X  #else /* DGK && !OLD_TOS */
X! E void savelev P((int, XCHAR_P));
X  #endif /* DGK && !OLD_TOS */
X  #ifdef ZEROCOMP
X  E void bflush P((int));
X***************
X*** 952,964 ****
X  E void make_happy_shk P((struct monst *));
X  E boolean paybill();
X  E void pay_for_door P((int,int,char *));
X! E void addtobill P((struct obj *,boolean));
X  E void splitbill P((struct obj *,struct obj *));
X  E void subfrombill P((struct obj *));
X  E int doinvbill P((int));
X  E int shkcatch P((struct obj *));
X  E int shk_move P((struct monst *));
X! E int online P((xchar,xchar));
X  E boolean is_fshk P((struct monst *));
X  E void shopdig P((int));
X  E boolean in_shop P((int,int));
X--- 955,967 ----
X  E void make_happy_shk P((struct monst *));
X  E boolean paybill();
X  E void pay_for_door P((int,int,char *));
X! E void addtobill P((struct obj *,BOOLEAN_P));
X  E void splitbill P((struct obj *,struct obj *));
X  E void subfrombill P((struct obj *));
X  E int doinvbill P((int));
X  E int shkcatch P((struct obj *));
X  E int shk_move P((struct monst *));
X! E int online P((XCHAR_P,XCHAR_P));
X  E boolean is_fshk P((struct monst *));
X  E void shopdig P((int));
X  E boolean in_shop P((int,int));
X***************
X*** 1002,1008 ****
X  #ifdef SPELLS
X  E int study_book P((struct obj *));
X  E int docast();
X! E int spelleffects P((int, boolean));
X  E void losespells();
X  E int dovspell();
X  #endif /* SPELLS */
X--- 1005,1011 ----
X  #ifdef SPELLS
X  E int study_book P((struct obj *));
X  E int docast();
X! E int spelleffects P((int, BOOLEAN_P));
X  E void losespells();
X  E int dovspell();
X  #endif /* SPELLS */
X***************
X*** 1023,1029 ****
X  E void end_screen();
X  E void curs P((int,int));
X  E void cmov P((int,int));
X! E void xputc P((char));
X  E void xputs P((char *));
X  E void cl_end();
X  E void clear_screen();
X--- 1026,1032 ----
X  E void end_screen();
X  E void curs P((int,int));
X  E void cmov P((int,int));
X! E void xputc P((CHAR_P));
X  E void xputs P((char *));
X  E void cl_end();
X  E void clear_screen();
X***************
X*** 1057,1069 ****
X  E void more();
X  E void cmore P((char *));
X  E void clrlin();
X! E void pline P((const char *,...));
X! E void Norep P((const char *,...));
X! E void You P((const char *,...));
X! E void Your P((const char *,...));
X! E void putsym P((char));
X  E void putstr P((char *));
X! E char yn_function P((char *,char));
X  
X  /* ### topten.c ### */
X  
X--- 1060,1072 ----
X  E void more();
X  E void cmore P((char *));
X  E void clrlin();
X! E void pline V((const char *,...));
X! E void Norep V((const char *,...));
X! E void You V((const char *,...));
X! E void Your V((const char *,...));
X! E void putsym P((CHAR_P));
X  E void putstr P((char *));
X! E char yn_function P((char *,CHAR_P));
X  
X  /* ### topten.c ### */
X  
X***************
X*** 1080,1086 ****
X  
X  /* ### trap.c ### */
X  
X! E boolean rust_dmg P((struct obj *,char *,int,boolean));
X  E struct trap *maketrap P((int,int,int));
X  E int teleok P((int,int));
X  E void dotrap P((struct trap *));
X--- 1083,1089 ----
X  
X  /* ### trap.c ### */
X  
X! E boolean rust_dmg P((struct obj *,char *,int,BOOLEAN_P));
X  E struct trap *maketrap P((int,int,int));
X  E int teleok P((int,int));
X  E void dotrap P((struct trap *));
X***************
X*** 1120,1126 ****
X  E boolean hmon P((struct monst *,struct obj *,int));
X  E int damageum P((struct monst *, struct attack *));
X  E void missum P((struct monst *, struct attack *));
X! E int passive P((struct monst *,boolean,int,boolean));
X  E void stumble_onto_mimic P((struct monst *));
X  
X  /* ### unixmain.c ### */
X--- 1123,1129 ----
X  E boolean hmon P((struct monst *,struct obj *,int));
X  E int damageum P((struct monst *, struct attack *));
X  E void missum P((struct monst *, struct attack *));
X! E int passive P((struct monst *,BOOLEAN_P,int,BOOLEAN_P));
X  E void stumble_onto_mimic P((struct monst *));
X  
X  /* ### unixmain.c ### */
X***************
X*** 1130,1136 ****
X  E int (*afternmv)();
X  E void glo P((int));
X  E void askname();
X! E void impossible P((char *,...));
X  E void stop_occupation();
X  #endif /* UNIX */
X  
X--- 1133,1139 ----
X  E int (*afternmv)();
X  E void glo P((int));
X  E void askname();
X! E void impossible V((char *,...));
X  E void stop_occupation();
X  #endif /* UNIX */
X  
X***************
X*** 1142,1148 ****
X  E void setftty();
X  E void intron();
X  E void introff();
X! E void error P((char *, char *, char *));
X  #endif /* UNIX */
X  
X  /* ### unixunix.c ### */
X--- 1145,1151 ----
X  E void setftty();
X  E void intron();
X  E void introff();
X! E void error V((char *,...));
X  #endif /* UNIX */
X  
X  /* ### unixunix.c ### */
X***************
X*** 1187,1193 ****
X  
X  E void were_change P((struct monst *));
X  E void new_were P((struct monst *));
X! E boolean were_summon P((struct permonst *,boolean));
X  #ifdef POLYSELF
X  E void you_were();
X  #endif /* POLYSELF */
X--- 1190,1196 ----
X  
X  E void were_change P((struct monst *));
X  E void new_were P((struct monst *));
X! E boolean were_summon P((struct permonst *,BOOLEAN_P));
X  #ifdef POLYSELF
X  E void you_were();
X  #endif /* POLYSELF */
X***************
X*** 1200,1206 ****
X  E void corrode_weapon();
X  E int chwepon P((struct obj *,int));
X  E int welded P((struct obj *));
X! E void weldmsg P((struct obj *,boolean));
X  
X  /* ### wizard.c ### */
X  
X--- 1203,1209 ----
X  E void corrode_weapon();
X  E int chwepon P((struct obj *,int));
X  E int welded P((struct obj *));
X! E void weldmsg P((struct obj *,BOOLEAN_P));
X  
X  /* ### wizard.c ### */
X  
X***************
X*** 1227,1233 ****
X  E void wormdead P((struct monst *));
X  E void wormhit P((struct monst *));
X  E void wormsee P((unsigned int));
X! E void cutworm P((struct monst *,xchar,xchar,unsigned));
X  #endif /* WORM */
X  
X  /* ### worn.c ### */
X--- 1230,1236 ----
X  E void wormdead P((struct monst *));
X  E void wormhit P((struct monst *));
X  E void wormsee P((unsigned int));
X! E void cutworm P((struct monst *,XCHAR_P,XCHAR_P,unsigned));
X  #endif /* WORM */
X  
X  /* ### worn.c ### */
X***************
X*** 1241,1247 ****
X  
X  /* ### zap.c ### */
X  
X! E struct monst *revive P((struct obj *,boolean));
X  E int zappable P((struct obj *));
X  E void zapnodir P((struct obj *));
X  E int dozap();
X--- 1244,1250 ----
X  
X  /* ### zap.c ### */
X  
X! E struct monst *revive P((struct obj *,BOOLEAN_P));
X  E int zappable P((struct obj *));
X  E void zapnodir P((struct obj *));
X  E int dozap();
X***************
X*** 1250,1265 ****
X  E char *exclam P((int));
X  E void hit P((char *,struct monst *,char *));
X  E void miss P((char *,struct monst *));
X! E struct monst *bhit P((int,int,int,char,int(*)(),int(*)(),struct obj *));
X  E struct monst *boomhit P((int,int));
X! E void buzz P((int,int,xchar,xchar,int,int));
X  E void rloco P((struct obj *));
X  E void fracture_rock P((struct obj *));
X  E boolean break_statue P((struct obj *));
X  E void destroy_item P((int,int));
X  E int destroy_mitem P((struct monst *,int,int));
X! E int resist P((struct monst *,char,int,int));
X  E void makewish();
X  
X  #undef E
X  
X--- 1253,1270 ----
X  E char *exclam P((int));
X  E void hit P((char *,struct monst *,char *));
X  E void miss P((char *,struct monst *));
X! E struct monst *bhit P((int,int,int,CHAR_P,int(*)(),int(*)(),struct obj *));
X  E struct monst *boomhit P((int,int));
X! E void buzz P((int,int,XCHAR_P,XCHAR_P,int,int));
X  E void rloco P((struct obj *));
X  E void fracture_rock P((struct obj *));
X  E boolean break_statue P((struct obj *));
X  E void destroy_item P((int,int));
X  E int destroy_mitem P((struct monst *,int,int));
X! E int resist P((struct monst *,CHAR_P,int,int));
X  E void makewish();
X+ 
X+ #endif /* !MAKEDEFS_C && !LEV_LEX_C */
X  
X  #undef E
X  
X*** include/Old/global.h	Wed Sep  6 16:59:13 1989
X--- include/global.h	Tue Sep  5 14:04:42 1989
X***************
X*** 64,69 ****
X--- 64,93 ----
X  #define	Bitfield(x,n)	uchar x
X  #endif
X  
X+ /*
X+  * According to ANSI, prototypes for old-style declarations must widen the
X+  * arguments to int.  However, the MSDOS compilers accept shorter arguments
X+  * (char, short, etc.) in prototypes and do typechecking with them.  Therefore
X+  * this mess to allow the better typechecking while also allowing some
X+  * prototypes for the ANSI compilers so people quit trying to fix the prototypes
X+  * to match the standard and thus lose the typechecking.
X+  */
X+ #if defined(MSDOS) && !(defined(AMIGA) || defined(TOS))
X+ # define CHAR_P char
X+ # define SCHAR_P schar
X+ # define UCHAR_P uchar
X+ # define XCHAR_P xchar
X+ # define BOOLEAN_P boolean
X+ #else
X+ # ifdef __STDC__
X+ #  define CHAR_P int
X+ #  define SCHAR_P int
X+ #  define UCHAR_P int
X+ #  define XCHAR_P int
X+ #  define BOOLEAN_P int
X+ # endif
X+ #endif
X+ 
X  
X  #define	SIZE(x)	(int)(sizeof(x) / sizeof(x[0]))
X  
X*** include/Old/hack.h	Wed Sep  6 16:59:45 1989
X--- include/hack.h	Wed Sep  6 16:42:01 1989
X***************
X*** 75,80 ****
X--- 75,84 ----
X  #include	"rm.h"
X  #endif
X  
X+ #ifndef EXTERN_H
X+ #include	"extern.h"
X+ #endif
X+ 
X  #ifdef STRONGHOLD
X  # define Inhell		(dlevel > stronghold_level && dlevel <= MAXLEVEL)
X  #else
X*** include/Old/msdos.h	Wed Sep  6 17:01:19 1989
X--- include/msdos.h	Sat Aug 26 14:13:12 1989
X***************
X*** 15,22 ****
X  extern int count_only;
X  #endif
X  
X! #define CTRL(ch) (ch & 0x37)
X! #define ABORT CTRL('A')
X  #define COUNT 0x1
X  #define WRITE 0x2
X  
X--- 15,23 ----
X  extern int count_only;
X  #endif
X  
X! #define C(c)  (0x1f & (c))
X! #define M(c)  (0x80 | (c))
X! #define ABORT C('a')
X  #define COUNT 0x1
X  #define WRITE 0x2
X  
X*** include/Old/obj.h	Wed Sep  6 17:01:30 1989
X--- include/obj.h	Sat Sep  2 15:05:43 1989
X***************
X*** 45,50 ****
X--- 45,61 ----
X  	Bitfield(onamelth,6);
X  	long age;		/* creation date */
X  	long owornmask;
X+ 
X+ /* note that TIMEOUT in you.h is defined as 07777L; no bits for items that
X+  * confer properties may overlap that mask, or timeout.c will happily rearrange
X+  * the bits behind the back of the property code
X+  * shirts, balls, and chains are currently safe
X+  */
X+ #define	W_BALL	02000L
X+ #define	W_CHAIN	04000L
X+ #define	W_RINGL	010000L	/* make W_RINGL = RING_LEFT (see uprop) */
X+ #define	W_RINGR	020000L
X+ #define	W_RING	(W_RINGL | W_RINGR)
X  #define	W_ARM	040000L
X  #define	W_ARMC	0100000L
X  #define	W_ARMH	0200000L
X***************
X*** 53,70 ****
X  #define	W_ARMF	02000000L
X  #define	W_AMUL	04000000L
X  #define	W_TOOL	010000000L	/* wearing another tool (see uprop) */
X  #ifdef SHIRT
X! #define	W_ARMU	020000000L
X  #define	W_ARMOR	(W_ARM | W_ARMC | W_ARMH | W_ARMS | W_ARMG | W_ARMF | W_ARMU)
X  #else
X  #define	W_ARMOR	(W_ARM | W_ARMC | W_ARMH | W_ARMS | W_ARMG | W_ARMF)
X  #endif
X- #define	W_RINGL	010000L	/* make W_RINGL = RING_LEFT (see uprop) */
X- #define	W_RINGR	020000L
X- #define	W_RING	(W_RINGL | W_RINGR)
X- #define	W_WEP	01000L
X- #define	W_BALL	02000L
X- #define	W_CHAIN	04000L
X  	long oextra[1];		/* used for name of ordinary objects - length
X  				   is flexible; amount for tmp gold objects */
X  };
X--- 64,76 ----
X  #define	W_ARMF	02000000L
X  #define	W_AMUL	04000000L
X  #define	W_TOOL	010000000L	/* wearing another tool (see uprop) */
X+ #define	W_WEP	020000000L
X  #ifdef SHIRT
X! #define	W_ARMU	01000L
X  #define	W_ARMOR	(W_ARM | W_ARMC | W_ARMH | W_ARMS | W_ARMG | W_ARMF | W_ARMU)
X  #else
X  #define	W_ARMOR	(W_ARM | W_ARMC | W_ARMH | W_ARMS | W_ARMG | W_ARMF)
X  #endif
X  	long oextra[1];		/* used for name of ordinary objects - length
X  				   is flexible; amount for tmp gold objects */
X  };
X***************
X*** 75,81 ****
X  #define	ONAME(otmp)	((char *) otmp->oextra)
X  #define	OGOLD(otmp)	(otmp->oextra[0])
X  
X! # ifndef STUPID_CPP	/* otherwise these macros are functions in lock.c */
X  #define Is_container(otmp)	(otmp->otyp >= ICE_BOX && otmp->otyp <= BAG_OF_TRICKS)
X  #define Is_box(otmp)	(otmp->otyp == LARGE_BOX || otmp->otyp == CHEST)
X  #define Is_mbag(otmp)	(otmp->otyp == BAG_OF_HOLDING || otmp->otyp == BAG_OF_TRICKS)
X--- 81,89 ----
X  #define	ONAME(otmp)	((char *) otmp->oextra)
X  #define	OGOLD(otmp)	(otmp->oextra[0])
X  
X! # ifndef STUPID_CPP	/* otherwise these macros are functions */
X! /* #define OBJ_AT(x,y)	(levl[x][y].omask) */
X! 
X  #define Is_container(otmp)	(otmp->otyp >= ICE_BOX && otmp->otyp <= BAG_OF_TRICKS)
X  #define Is_box(otmp)	(otmp->otyp == LARGE_BOX || otmp->otyp == CHEST)
X  #define Is_mbag(otmp)	(otmp->otyp == BAG_OF_HOLDING || otmp->otyp == BAG_OF_TRICKS)
X***************
X*** 82,87 ****
X--- 90,99 ----
X  
X  #define is_sword(otmp)	(otmp->otyp >= SHORT_SWORD && otmp->otyp <= KATANA)
X  #define bimanual(otmp)	(otmp->olet == WEAPON_SYM && objects[otmp->otyp].oc_bimanual)
X+ 
X+ #define is_flammable(otmp)	(objects[otmp->otyp].oc_material == WOOD || objects[otmp->otyp].oc_material == 0)
X+ #define is_rustprone(otmp)	(objects[otmp->otyp].oc_material == METAL)
X+ #define is_corrodeable(otmp)	(objects[otmp->otyp].oc_material == COPPER)
X  # endif /* STUPID_CPP */
X  
X  #endif /* OBJ_H /**/
X*** include/Old/objclass.h	Wed Sep  6 17:01:42 1989
X--- include/objclass.h	Wed Aug 30 18:20:41 1989
X***************
X*** 18,27 ****
X  #define oc_bulky	oc_bool	/* for armor */
X  #define oc_charged	oc_bool	/* for rings & tools: allow +n or (n) */
X  	Bitfield(oc_material,4);
X! #define GLASS	1
X! #define WOOD	2
X! #define METAL	4
X! #define MINERAL	8
X  	uchar oc_oprop; 	/* property (invis, &c.) conveyed */
X  	char oc_olet;
X  	int oc_prob;		/* probability for mkobj() */
X--- 18,32 ----
X  #define oc_bulky	oc_bool	/* for armor */
X  #define oc_charged	oc_bool	/* for rings & tools: allow +n or (n) */
X  	Bitfield(oc_material,4);
X! #define GLASS		1
X! #define WOOD		2
X! #define COPPER		3 /* Cu */
X! #define METAL		4 /* Fe */
X! #define SILVER		5 /* Ag */
X! #define GOLD		6 /* Au */
X! #define PLATINUM	7 /* Pt */
X! #define MITHRIL		8
X! #define MINERAL		15
X  	uchar oc_oprop; 	/* property (invis, &c.) conveyed */
X  	char oc_olet;
X  	int oc_prob;		/* probability for mkobj() */
X*** include/Old/patchlevel.h	Wed Sep  6 17:01:53 1989
X--- include/patchlevel.h	Wed Sep  6 16:55:29 1989
X***************
X*** 20,23 ****
X   *  fix various minor bugs, and do further code cleaning
X   */
X  
X! #define PATCHLEVEL	2
X--- 20,32 ----
X   *  fix various minor bugs, and do further code cleaning
X   */
X  
X! /*
X!  *  Patch 3, September 6, 1989
X!  *  extend prototypes to ANSI compilers in addition to the previous MSDOS ones
X!  *  move object-on-floor references into functions in preparation for planned
X!  *	data structures to allow faster access and better colors
X!  *  fix some more bugs, and extend the portability of things added in earlier
X!  *	patches
X!  */
X! 
X! #define PATCHLEVEL	3
X*** include/Old/pcconf.h	Wed Sep  6 17:02:06 1989
X--- include/pcconf.h	Fri Sep  1 14:06:41 1989
X***************
X*** 103,110 ****
X  #  define HI_ZAP	BLUE	/* blue zaps! */
X  #endif
X  
X- #ifndef EXTERN_H
X- #include "extern.h"
X  #endif
X- 
X- #endif /* PCCONF_H /* */
X--- 103,106 ----
X*** include/Old/system.h	Wed Sep  6 17:03:05 1989
X--- include/system.h	Fri Sep  1 14:10:08 1989
X***************
X*** 109,117 ****
X--- 109,123 ----
X  E char *memcpy();
X  #endif
X  #ifdef MSDOS
X+ # if defined(TOS) && defined(__GNUC__)
X+ E int memcmp P((const char *,const char *,size_t));
X+ E char *memcpy P((char *,const char *,size_t));
X+ E char *memset P((char*,int,size_t));
X+ # else
X  E int memcmp P((char *,char *,unsigned int));
X  E char *memcpy P((char *,char *,unsigned int));
X  E char *memset P((char*,int,int));
X+ # endif /* TOS */
X  #endif
X  
X  #if defined(BSD) && defined(ultrix)	/* i.e., old versions of Ultrix */
X*** include/Old/tradstdc.h	Wed Sep  6 17:03:26 1989
X--- include/tradstdc.h	Fri Sep  1 13:53:24 1989
X***************
X*** 19,37 ****
X  
X  /* Used for robust ANSI parameter forward declarations:
X   * int sprintf P((char *, const char *, ...));
X   */
X  
X- /* However, if you do use a prototype in declaring a function but define
X-  * the function in an old-style manner, the compiler might (justifiably) barf.
X-  * Since we have to define functions in the old-style manner to accommodate
X-  * traditional compilers, we don't want to use prototypes if the ANSI-standard
X-  * compiler barfs on these.
X-  */
X- #ifdef __GNUC__ /* add other compilers as the need arises */
X- # define P(s)		()
X- #else
X  # define P(s)		s
X! #endif
X  
X  # ifdef __TURBOC__	/* Cover for stupid Turbo C */
X  #  define genericptr_t	void *
X--- 19,37 ----
X  
X  /* Used for robust ANSI parameter forward declarations:
X   * int sprintf P((char *, const char *, ...));
X+  *
X+  * P() is used to surround parameter list for functions with a fixed number
X+  * of arguments; V() is used for varying numbers of arguments.  Separate
X+  * macros are needed because ANSI will mix old-style declarations with
X+  * prototypes, except in the case of varargs.
X   */
X  
X  # define P(s)		s
X! # ifdef MSDOS
X! #  define V(s)		s
X! # else
X! #  define V(s)		()
X! # endif
X  
X  # ifdef __TURBOC__	/* Cover for stupid Turbo C */
X  #  define genericptr_t	void *
X***************
X*** 47,52 ****
X--- 47,53 ----
X  #else /* __STDC__ */	/* a "traditional" C  compiler */
X  
X  # define P(s)		()
X+ # define V(s)		()
X  
X  # ifndef genericptr_t
X  #  ifdef AMIGA
X*** include/Old/unixconf.h	Wed Sep  6 17:03:54 1989
X--- include/unixconf.h	Mon Sep  4 13:28:23 1989
X***************
X*** 156,163 ****
X  #  define HI_ZAP	BLUE	/* blue zaps! */
X  #endif
X  
X- #ifndef EXTERN_H
X- #include "extern.h"
X  #endif
X- 
X- #endif /* UNIXCONF_H /* */
X--- 156,159 ----
X*** include/Old/you.h	Wed Sep  6 17:04:25 1989
X--- include/you.h	Wed Sep  6 16:42:00 1989
X***************
X*** 34,40 ****
X  #define	WORN_AMUL	W_AMUL	/* 04000000L */
X  #define	WORN_BLINDF	W_TOOL	/* 010000000L */
X  #ifdef SHIRT
X! #define	WORN_SHIRT	W_ARMU	/* 020000000L */
X  #endif
X  #define	INTRINSIC	040000000L
X  
X--- 34,40 ----
X  #define	WORN_AMUL	W_AMUL	/* 04000000L */
X  #define	WORN_BLINDF	W_TOOL	/* 010000000L */
X  #ifdef SHIRT
X! #define	WORN_SHIRT	W_ARMU	/* 01000L */
X  #endif
X  #define	INTRINSIC	040000000L
X  
X
END_OF_FILE
if test 55369 -ne `wc -c <'patch03a'`; then
    echo shar: \"'patch03a'\" unpacked with wrong size!
fi
# end of 'patch03a'
fi
echo shar: End of archive 1 \(of 6\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 4 5 6 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 6 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
