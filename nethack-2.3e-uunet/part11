#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 11 (of 13)."
# Contents:  Fixes.2.2 Makefile.3B2 Makefile.att Makefile.unix
#   Makefile.xpc do_name.c dogmove.c dothrow.c end.c fountain.c hack.h
#   mkshop.c polyself.c prisym.c
# Wrapped by billr@tekred on Mon Jun 20 11:39:22 1988
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f Fixes.2.2 -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"Fixes.2.2\"
else
echo shar: Extracting \"Fixes.2.2\" \(8320 characters\)
sed "s/^X//" >Fixes.2.2 <<'END_OF_Fixes.2.2'
X		NetHack Fixes List	Revision 2.2
X
XGuidebook.mn	New file "Guide to the Mazes of Menace". By Eric Raymond.
XGuidebook	A file for preparation using the "mn" macros supplied with
X		the 2.11 news release, as well as an ascii version of the
X		same. 
X
XNetHack.cnf	Sample configuration file for the PC. (creps@silver)
X
XMakefiles	Corrected problem in which the linking was done on build and
X(unix/xenix)	on install. (Contributed by Janet Walz - walz@mimsy)
X
XMakefile.att	Added a makefile for the AT&T Unix PC using shared libraries.
X		(Contributed by ahby@umn-cs)
X
XMakefile.pc	Streamlined compilation of main.o, tty.o, and unix.o
XMakefile.tcc	(Contributed by polder@cs.vu.nl).
X
Xdata.base	deletion of duplicate lines and spelling fixes. (sweet@scubed)
X
Xinvent.c	REDO problem with "What do you want to..." text fixed.
X		down stairway identification fixed.
X		Alloc "buf" to allow for variable length HI/HE. (tom@uw-warp)
X
Xengrave.c	Correction to "feel" code. (mike@genat)
X		Corrected switch for message determination. (patrickm@hpisof0)
X		BURN'ed engravings made un-erasable again. (kyrimis@princeton)
X
Xpri.c		Added colour highliting functions (sweet@scubed)
X
Xprisym.c	changed "symbol.room" to "ROOM_SYM" (one I missed)
X		(Ralf.Brown@b.gp.cs.cmu.edu)
X		Changed "dirlet()" to return an int. (maartenj@cs.vu.nl)
X
Xmsdos.c		Changed "symbol" to "showsyms" (Ralf.Brown@b.gp.cs.cmu.edu)
X		Fixed up REDO & IBMBIOS stuff. (Kevin Sweet - sweet@scubed)
X
Xdo.c		Dropping gold asked for only when gold posessed. (walz@mimsy)
X		Potential unsigned value problem fixed (u.ucreamed)
X		Added leash dropping code. (maartenj@cs.vu.nl)
X		Blind modifications for blindfolding.  (eric@snark)
X		Value wrap fixed for u.ucreamed
X
Xfight.c		Dog's name now used in hitting avoidence message. (walz@mimsy)
X		Variable initialization fixed w.r.t. #ifdef / #else.
X		(Reported by Erwin Unruh - unruh@infbs)
X		Added giant rats and kobolds back into code. (sweet@scubed)
X
Xspell.c		Potential unsigned value problem fixed (u.ulevel).
X		Typos corrected. (Tom May - tom@uw-warp)
X		Blind modifications for blindfolding.  (eric@snark)
X
Xshk.c		"inshop" crash bug corrected (many sources).
X		extern declaration of carrying() moved to avoid a Turbo-C
X		type mismatch msg. (Ralf.Brown@b.gp.cs.cmu.edu)
X		Added new "online()" which executes faster. (tom@uw-warp)
X		Blind modifications for blindfolding.  (eric@snark)
X		Added item pricing shopkeeper talk.
X		(Idea from a hacked up 1.0.1 source sent in by michael@stb)
X		Cleaned up Kops code. (sweet@scubed)
X
Xmhitu.c		Argument mismatches fixed. (walz@mimsy)
X		Scorpion/spider mixup fix. (William LeFebvre - phil@rice.edu)
X		Blind modifications for blindfolding.  (eric@snark)
X
Xpotion.c	Argument mismatch fixed. (walz@mimsy)
X		Blind modifications for blindfolding.  (eric@snark)
X		Poison handling made more dependant on poison resistance.
X		(From an idea by Steve Creps - creps@silver)
X
Xmklev.c		Fixed up installation of vamp traps. (sweet@scubed)
X
Xmakemon.c	Monster creation location bug fixed. (walz@mimsy)
X		Monster creation crash fixed. (many sources)
X		Monster posessions bug fixed. (S. Wrammerfors stewr@obelix)
X		Added giant rats and kobolds back into code. (sweet@scubed)
X
Xhack.c		"Elbereth" effectiveness increased under "HARD" option to
X		be reasonable. (walz@mimsy)
X		Declaration of "register struct monst *m_at()" fixed. (many)
X		Typo fixed. (tom@uw-warp)
X		Fixed scroll of scare monster pickup problems (and giveaway)
X		(polder@cs.vu.nl)
X		Documentation modifications for blindfolding.  (eric@snark)
X
Xioctl.c		ioctl call for SET changed to function properly under
X
Xunixtty.c	Sys V R3 mods.  (tom@uw-warp)
X
Xdecl.c		in_doagain initialized. (many sources)
X
Xwield.c		Ability to remove cursed weapons w. w- removed. (many sources)
X
Xoptions.c	Major rewrite of options help.  Now uses pager.  (mike@genat)
X		Rewrote GRAPHICS setup. (maartenj@cs.vu.nl)
X		Allowed reassignment of inventory order #ifdef DGK
X		(polder@cs.vu.nl)
X
Xpray.c		Fixed mk_obj of spellbook under all conditions to make book
X		if "SPELLS" defined, and scroll otherwise. (unruh@infbs)
X		Fixed typo in "gods angry" text. (tom@uw-warp)
X		Fixed blessing code. (Simon Brown - simon@its63b)
X		Blind modifications for blindfolding.  (eric@snark)
X
Xzap.c		Potion of invis. breakage message improved. (unruh@infbs)
X		Added WAN_PROBING to "zapyourself".
X		Changed "dirlet()" to return an int. (maartenj@cs.vu.nl)
X		Fixed cancellation code to work properly on wands (spe
X		set to -1 instead of 0) this means no infinite wands of
X		wishing. (Ron Wessels - ron@utcsri)
X		Fixed bug in "buzz()" causing crash when destroying a
X		trapper from inside with a wand/spell.  (mike@genat)
X		Added fcn to destroy wands with zero charges. (sweet@scubed)
X
Xpcmain.c	Added a routine to zero out the fileinfo array in order to
X		prevent crashes on level change. (ralf@b.gp.cs.cmu.edu)
X		Added chdir to HACKDIR before looking for .CNF file.
X		Added call "uptodate(savefile)". (polder@cs.vu.nl)
X
Xpager.c		changed "cornline()" to use xputs for HI/HE. (tom@uw-warp)
X		added choice for dowhatis() to allow letter or cursor object
X		selection. (polder@cs.vu.nl)
X
Xcmd.c		Added ^W (wish) and ^I (ident-all) commands for WIZARD-mode.
X		(Paul Polderman - polder@cs.vu.nl)
X		Added "Z" as alternate to "# cast" (Eric Raymond - eric@snark)
X
Xu_init.c	Expanded a tab which didn't show in raw mode.
X		Changed trobj.trotyp to "unsigned short" to avoid >255
X		problems. (Maarten Jan Huisjes - maartenj@cs.vu.nl)
X		Removed wand of wishing from WIZARD's inventory (due to
X		the above cmd additions). (polder@cs.vu.nl)
X		Fixed declaration of leash. (simon@its63b)
X		Beefed up Wizard class.
X		Added Wakizashi for Samurai.
X		Added holy water for Priest(ess)es.
X		Modifications to provide blindfolds.  (eric@snark)
X
Xend.c		changed inventory identification on death to list form.
X		(polder@cs.vu.nl)
X		added hallucination effects to done_in_by()
X		added posession of amulet flag for scoreboard (sweet@scubed)
X
Xwizard.c	corrected "nasties" decl. (maartenj@cs.vu.nl)
X		Blind modifications for blindfolding.  (eric@snark)
X
Xdo_wear.c	Prot. from shape changers logic fixed. (maartenj@cs.vu.nl)
X
Xlev.c		Prot. from shape changers logic fixed. (maartenj@cs.vu.nl)
X
Xmon.c		Inserted cast to fix compiler warning. (maartenj@cs.vu.nl)
X		Nymphs now leave potions of object detection when killed.
X		Kops now don't leave treasure behind. (sweet@scubed)
X
Xtopl.c		Changed size of "toplines" to avoid overflow in "parseoptions"
X		when help is asked for. (probably n/a) (maartenj@cs.vu.nl)
X
Xtopten.c	Added longer death descriptions, including name of
X		shopkeeper who killed character.  (many sources)
X
Xtermcap.c	Changed allocation of HI/HO for copying SI/SO to allow room
X		for null.  (maartenj@cs.vu.nl)
X		Added PCHack 3.61 termcap stuff.
X		Added colour highliting code. (sweet@scubed)
X
Xversion.c	Expanded a tab for rawmode io. (maartenj@cs.vu.nl)
X
Xobjnam.c	Allow the WIZARD to wish for really excessive objects.
X		(polder@cs.vu.nl)
X
Xmakedefs.c	Added "freopen" which works (MSC 4.0 drops first couple
X		of lines).  Solves missing #define AMULET... problem.
X		(Nathan Glasser - nathan@mit-eddie)
X
Xrnd.c		Changed around random number generation:
X		BSD uses "random()". (Paul Eggert - eggert@grand)
X		SYSV uses "lrand48()". (mike@genat from above)
X
Xeat.c		Changed "choke()" code to waste food rather than choke on
X		it #ifndef HARD. (Allan Pratt - apratt@atari)
X		Blind modifications for blindfolding.  (eric@snark)
X
Xobjects.h	added blindfold object (tool).  (eric@snark)
X
Xyou.h		changed Blind/BLIND to Blinded/Blinded
X		added Blindfolded/BLINDFOLDED
X		redefined Blind in terms of above parameters.  (eric@snark)
X
Xapply.c		added blindfold code.  (eric@snark)
X
Xtimeout.c	Blind modifications for blindfolding.  (eric@snark)
X
Xsit.c		Blind modifications for blindfolding.  (eric@snark)
X
Xtrap.c		Blind modifications for blindfolding.  (eric@snark)
X		Level teleportation to hell fixed so that it will not
X		do so unless character has Fire_resistance. (many sources)
X		Added polymorph trap. (many sources)
X
Xmonmove.c	added check on presence of "fobj" before atl() call
X		to avoid potential segmentation problem with ROCKMOLE.
X		(Reported by Doug Rudoff - doug@wiley)
X
Xvarious files	Fixed typos.  Also converted British English words to
X		American English for uniformity.  (Original list of typos
X		submitted by Steve Creps - creps@silver)
END_OF_Fixes.2.2
if test 8320 -ne `wc -c <Fixes.2.2`; then
    echo shar: \"Fixes.2.2\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f Makefile.3B2 -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"Makefile.3B2\"
else
echo shar: Extracting \"Makefile.3B2\" \(7625 characters\)
sed "s/^X//" >Makefile.3B2 <<'END_OF_Makefile.3B2'
X#	Hack or Quest Makefile.
X#	SCCS Id: @(#)Makefile.unix	2.3	87/12/12
X
X#
X#	In config.h, define "UNIX", "SYSV", and "TERMINFO".
X#
X#	Also, "typedef short int" for schar and uchar.
X#
X
X# if you are cross-compiling (eg. from Xenix into a Dos enviornment)
X# you will have to redefine these filenames.
XMAIN = unixmain.c
XTTY  = unixtty.c
XUNIX = unixunix.c
X
X# flags may have to be changed as required
XCFLAGS = -O
XLFLAGS =
X
X# on some systems the termcap library is in -ltermcap
XTERMLIB = -ltermlib
XLLIBS   = -lmalloc
X
X# make NetHack
XGAME     = nethack
XGAMEUID  = games
XGAMEGRP  = bin
X
X#	GAMEDIR also appears in config.h as "HACKDIR".
XGAMEDIR  = /usr/games/lib/$(GAME)dir
XSHELLDIR = /usr/games
XMANDIR   = /usr/man/man6
XMANEXT   = 6
X
XHACKCSRC = alloc.c apply.c bones.c cmd.c decl.c do.c do_name.c do_wear.c\
X	dog.c dogmove.c dothrow.c eat.c end.c engrave.c fight.c fountain.c\
X	hack.c invent.c ioctl.c lev.c main.c makemon.c mhitu.c\
X	mklev.c mkmaze.c mkobj.c mkshop.c mon.c monmove.c monst.c o_init.c\
X	objnam.c options.c pager.c polyself.c potion.c pray.c pri.c\
X	prisym.c read.c rip.c rnd.c rumors.c save.c search.c shk.c shknam.c\
X	sit.c spell.c steal.c termcap.c timeout.c topl.c topten.c track.c\
X	trap.c tty.c u_init.c unix.c vault.c version.c wield.c wizard.c\
X	worm.c worn.c write.c zap.c
X
XCSOURCES = $(HACKCSRC) makedefs.c
X
XHSOURCES = config.h date.h edog.h eshk.h extern.h flag.h func_tab.h\
X	gen.h gold.h hack.h mfndpos.h mkroom.h monst.h msdos.h\
X	obj.h objclass.h objects.h onames.h permonst.h rm.h\
X	spell.h trap.h wseg.h you.h
X
XSOURCES = $(CSOURCES) $(HSOURCES)
X
XSPECIFICS = main.o tty.o unix.o
XAUX = help hh nethack.6 nethack.sh
XVARAUX = data rumors
X
XDISTR = $(SOURCES) $(AUX) $(VARAUX) README.OLD README\
X	Makefile Makefile.pc Make.ini
X
XHOBJ = alloc.o apply.o bones.o cmd.o decl.o do.o do_name.o do_wear.o\
X	dog.o dogmove.o dothrow.o eat.o end.o engrave.o fight.o fountain.o\
X	hack.o invent.o ioctl.o lev.o main.o makemon.o mhitu.o\
X	mklev.o mkmaze.o mkobj.o mkshop.o mon.o monmove.o monst.o o_init.o\
X	objnam.o options.o pager.o polyself.o potion.o pray.o pri.o\
X	prisym.o read.o rip.o rnd.o rumors.o save.o search.o shk.o shknam.o\
X	sit.o spell.o steal.o termcap.o timeout.o topl.o topten.o track.o\
X	trap.o tty.o u_init.o unix.o vault.o version.o wield.o wizard.o\
X	worm.o worn.o write.o zap.o
X
X$(GAME):	$(SPECIFICS) $(HOBJ) Makefile
X	@echo "Loading ..."
X	@cc $(LFLAGS) -o $(GAME) $(HOBJ) $(TERMLIB) $(LLIBS)
X
Xall:	$(GAME) Guidebook lint
X	@echo "Done."
X
XGuidebook:	Guidebook.mn
X	nroff -mn Guidebook.mn > Guidebook
X
Xmakedefs:	makedefs.c alloc.o config.h
X	cc ${CFLAGS} -o makedefs alloc.o makedefs.c
X
XRUMORFILES= rumors.base rumors.kaa rumors.mrx
X
Xrumors:	config.h $(RUMORFILES) makedefs
X	./makedefs -r
X
Xdata:	config.h data.base makedefs
X	./makedefs -d
X
Xdate.h:	$(SOURCES) makedefs
X	./makedefs -D
X
Xtrap.h:	config.h makedefs
X	./makedefs -t
X
Xonames.h:	makedefs objects.h
X	./makedefs -o
X
Xmain.o:
X
Xmain.c:	unixmain.c hack.h
X	cp $(MAIN) main.c
X
Xtty.o:
X
Xtty.c:	unixtty.c hack.h func_tab.h
X	cp $(TTY) tty.c
X
Xunix.o:
X
Xunix.c:	unixunix.c hack.h mkroom.h
X	cp $(UNIX) unix.c
X
Xlint:
X# lint cannot have -p here because (i) capitals are meaningful:
X# [Ww]izard, (ii) identifiers may coincide in the first six places:
X# doweararm() versus dowearring().
X# _flsbuf comes from <stdio.h>, a bug in the system libraries.
X	@echo lint -axbh -DLINT ...
X	@lint -axbh -DLINT $(HACKCSRC) | sed '/_flsbuf/d'
X
X
Xdiff:
X	@- for i in $(SOURCES) $(AUX) ; do \
X		cmp -s $$i $D/$$i || \
X		( echo diff $D/$$i $$i ; diff $D/$$i $$i ; echo ) ; done
X
Xdistribution: Makefile
X	@- for i in READ_ME $(SOURCES) $(AUX) Makefile date.h onames.h\
X		; do \
X		cmp -s $$i $D/$$i || \
X		( echo cp $$i $D ; cp $$i $D ) ; done
X# the distribution directory also contains the empty files perm and record.
X
Xinitial:
X	-rm -rf $(GAMEDIR)
X	-mkdir $(SHELLDIR)
X	mkdir $(GAMEDIR) $(GAMEDIR)/save
X	touch $(GAMEDIR)/perm
X	touch $(GAMEDIR)/record
X	touch $(GAMEDIR)/logfile
X	chown $(GAMEUID) $(SHELLDIR)/$(GAME) $(GAMEDIR) $(GAMEDIR)/*
X	chgrp $(GAMEGRP) $(SHELLDIR)/$(GAME) $(GAMEDIR) $(GAMEDIR)/*
X	chmod 666 $(GAMEDIR)/*
X	chmod 777 $(GAMEDIR) $(GAMEDIR)/save
X
Xinstall: $(VARAUX) $(GAME)
X	-mkdir $(GAMEDIR)
X	-mkdir $(GAMEDIR)/save
X	-rm -f $(GAMEDIR)/$(GAME)
X	-rm -f $(GAMEDIR)/bones* $(GAMEDIR)/alock* $(GAMEDIR)/wizard*
X	-rm -f $(GAMEDIR)/save/*
X	touch $(GAMEDIR)/perm $(GAMEDIR)/record
X	cp help hh rumors data $(GAMEDIR)
X	cp $(GAME).sh $(SHELLDIR)/$(GAME)
X	cp $(GAME) $(GAMEDIR)/$(GAME)
X	chown $(GAMEUID) $(SHELLDIR)/$(GAME) $(GAMEDIR)/*
X	chgrp $(GAMEGRP) $(SHELLDIR)/$(GAME) $(GAMEDIR)/*
X	chmod 0755 $(SHELLDIR)/$(GAME)
X	chmod 04755 $(GAMEDIR)/$(GAME)
X	-cp nethack.6 $(MANDIR)/$(GAME).$(MANEXT)
X
Xdebug:
X	ln $(GAMEDIR)/$(GAME) a.out
X	ln $(GAMEDIR)/core core
X
Xtags: $(SOURCES)
X	@echo ctags -tw ...
X	@ctags -tw $(SOURCES)
X  
Xclean:
X	rm -f *.o
X
Xspotless: clean
X	rm -f a.out core $(GAME) makedefs
X	rm -f Makefile $(VARAUX) main.c tty.c unix.c
X
Xdepend:
X# For the moment we are lazy and disregard /usr/include files because
X# the sources contain them conditionally. Perhaps we should use cpp.
X#		( /bin/grep '^#[ 	]*include' $$i | sed -n \
X#			-e 's,<\(.*\)>,"/usr/include/\1",' \
X#
X	for i in ${CSOURCES}; do \
X		( /bin/grep '^#[ 	]*include[ 	]*"' $$i | sed -n \
X			-e 's/[^"]*"\([^"]*\)".*/\1/' \
X			-e H -e '$$g' -e '$$s/\n/ /g' \
X			-e '$$s/.*/'$$i': &/' -e '$$s/\.c:/.o:/p' \
X			>> makedep); done
X	for i in ${HSOURCES}; do \
X		( /bin/grep '^#[ 	]*include[ 	]*"' $$i | sed -n \
X			-e 's/[^"]*"\([^"]*\)".*/\1/' \
X			-e H -e '$$g' -e '$$s/\n/ /g' \
X			-e '$$s/.*/'$$i': &\
X				touch '$$i/p \
X			>> makedep); done
X	@echo '/^# DO NOT DELETE THIS LINE/+2,$$d' >eddep
X	@echo '$$r makedep' >>eddep
X	@echo 'w' >>eddep
X	@cp Makefile Makefile.bak
X	ed - Makefile < eddep
X	@rm -f eddep makedep
X	@echo '# DEPENDENCIES MUST END AT END OF FILE' >> Makefile
X	@echo '# IF YOU PUT STUFF HERE IT WILL GO AWAY' >> Makefile
X	@echo '# see make depend above' >> Makefile
X	- diff Makefile Makefile.bak
X	@rm -f Makefile.bak
X
X# DO NOT DELETE THIS LINE
X
Xdecl.o:  hack.h mkroom.h
Xapply.o:  hack.h edog.h mkroom.h
Xbones.o:  hack.h
Xhack.o:  hack.h
Xcmd.o:  hack.h func_tab.h
Xdo.o:  hack.h
Xdo_name.o:  hack.h
Xdo_wear.o:  hack.h
Xdog.o:  hack.h edog.h mkroom.h
Xdogmove.o:  hack.h mfndpos.h edog.h mkroom.h
Xdothrow.o:  hack.h
Xeat.o:  hack.h
Xend.o:  hack.h
Xengrave.o:  hack.h
Xfight.o:  hack.h
Xfountain.o:  hack.h mkroom.h
Xinvent.o:  hack.h wseg.h
Xioctl.o:  config.h
Xlev.o:  hack.h mkroom.h wseg.h
Xmakemon.o:  hack.h
Xmhitu.o:  hack.h
Xmklev.o:  hack.h mkroom.h
Xmkmaze.o:  hack.h mkroom.h
Xmkobj.o:  hack.h
Xmkshop.o:  hack.h mkroom.h eshk.h
Xmon.o:  hack.h mfndpos.h
Xmonmove.o:  hack.h mfndpos.h
Xmonst.o:  hack.h eshk.h
Xo_init.o:  config.h objects.h onames.h
Xobjnam.o:  hack.h
Xoptions.o:  hack.h
Xpager.o:  hack.h
Xpolyself.o: hack.h
Xpotion.o:  hack.h
Xpray.o:  hack.h
Xpri.o:  hack.h
Xprisym.o:  hack.h wseg.h
Xread.o:  hack.h
Xrip.o:  hack.h
Xrumors.o:  hack.h
Xsave.o:  hack.h
Xsearch.o:  hack.h
Xshk.o:  hack.h mfndpos.h mkroom.h eshk.h
Xshknam.o:  hack.h
Xsit.o: hack.h
Xspell.o:  hack.h
Xsteal.o:  hack.h
Xtermcap.o:  hack.h
Xtimeout.o:  hack.h
Xtopl.o:  hack.h
Xtopten.o:  hack.h
Xtrack.o:  hack.h
Xtrap.o:  hack.h edog.h mkroom.h
Xu_init.o:  hack.h
Xvault.o:  hack.h mkroom.h
Xwield.o:  hack.h
Xwizard.o:  hack.h
Xworm.o:  hack.h wseg.h
Xworn.o:  hack.h
Xwrite.o:  hack.h
Xzap.o:  hack.h
Xversion.o:  hack.h date.h
Xextern.h: config.h spell.h obj.h
X	touch extern.h
Xhack.h: extern.h flag.h gold.h monst.h objclass.h rm.h trap.h you.h 
X	touch hack.h
Xobjects.h:  config.h objclass.h
X	touch objects.h
Xyou.h: config.h onames.h permonst.h 
X	touch you.h
X# DEPENDENCIES MUST END AT END OF FILE
X# IF YOU PUT STUFF HERE IT WILL GO AWAY
X# see make depend above
END_OF_Makefile.3B2
if test 7625 -ne `wc -c <Makefile.3B2`; then
    echo shar: \"Makefile.3B2\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f Makefile.att -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"Makefile.att\"
else
echo shar: Extracting \"Makefile.att\" \(7040 characters\)
sed "s/^X//" >Makefile.att <<'END_OF_Makefile.att'
X#	Hack or Quest Makefile.
X#	SCCS Id: @(#)Makefile.att	2.3	88/02/12
X
Xinclude $(MAKEINC)/Makepre.h
X
X# if you are cross-compiling (eg. from Xenix into a Dos enviornment)
X# you will have to redefine these filenames.
XMAIN = unixmain.c
XTTY  = unixtty.c
XUNIX = unixunix.c
X
X# on some systems the termcap library is in -ltermcap
X#TERMLIB = -ltermlib
XTERMLIB =
X
X# make NetHack
XGAME = nethack
XGAMEUID = games
XGAMEGRP = bin
X#	GAMEDIR also appears in config.h as "HACKDIR".
XGAMEDIR = /usr/games/lib/$(GAME)dir
XSHELLDIR = /usr/games
XMANDIR  = /usr/man/man6
XCFLAGS = -O
XLFLAGS =
X
XHACKCSRC = alloc.c apply.c bones.c cmd.c decl.c do.c do_name.c do_wear.c\
X	dog.c dogmove.c dothrow.c eat.c end.c engrave.c fight.c fountain.c\
X	hack.c invent.c ioctl.c lev.c main.c makemon.c mhitu.c\
X	mklev.c mkmaze.c mkobj.c mkshop.c mon.c monmove.c monst.c o_init.c\
X	objnam.c options.c pager.c polyself.c potion.c pray.c pri.c\
X	prisym.c read.c rip.c rnd.c rumors.c save.c search.c shk.c shknam.c\
X	sit.c spell.c steal.c termcap.c timeout.c topl.c topten.c track.c\
X	trap.c tty.c u_init.c unix.c vault.c version.c wield.c wizard.c\
X	worm.c worn.c write.c zap.c
X
XCSOURCES = $(HACKCSRC) makedefs.c
X
XHSOURCES = hack.h mfndpos.h config.h edog.h eshk.h extern.h\
X	flag.h func_tab.h gold.h mkroom.h monst.h obj.h objclass.h\
X	objects.h permonst.h rm.h spell.h trap.h wseg.h you.h
X
XSOURCES = $(CSOURCES) $(HSOURCES)
X
XAUX = help hh nethack.6 nethack.sh
XVARAUX = data rumors
XSPECIFICS = main.o tty.o unix.o
X
X
XDISTR = $(SOURCES) $(AUX) $(VARAUX) README.OLD README\
X	Makefile Makefile.pc Make.ini
X
XHOBJ = alloc.o apply.o bones.o cmd.o decl.o do.o do_name.o do_wear.o\
X	dog.o dogmove.o dothrow.o eat.o end.o engrave.o fight.o fountain.o\
X	hack.o invent.o ioctl.o lev.o main.o makemon.o mhitu.o\
X	mklev.o mkmaze.o mkobj.o mkshop.o mon.o monmove.o monst.o o_init.o\
X	objnam.o options.o pager.o polyself.o potion.o pray.o pri.o\
X	prisym.o read.o rip.o rnd.o rumors.o save.o search.o shk.o shknam.o\
X	sit.o spell.o steal.o termcap.o timeout.o topl.o topten.o track.o\
X	trap.o tty.o u_init.o unix.o vault.o version.o wield.o wizard.o\
X	worm.o worn.o write.o zap.o
X
X$(GAME):	$(SPECIFICS) $(HOBJ) Makefile
X	@echo "Loading ..."
X	@ld $(LFLAGS) $(SHAREDLIB) -o $(GAME) $(HOBJ) $(TERMLIB)
X
Xall:	$(GAME) lint
X	@echo "Done."
X
Xmakedefs:	makedefs.c alloc.o config.h
X	cc ${CFLAGS} -o makedefs alloc.o makedefs.c
X
XRUMORFILES= rumors.base rumors.kaa rumors.mrx
X
Xrumors:	config.h $(RUMORFILES) makedefs
X	makedefs -r
X
Xdata:	config.h data.base makedefs
X	makedefs -d
X
Xdate.h:	$(SOURCES) makedefs
X	makedefs -D
X
Xtrap.h:	config.h makedefs
X	makedefs -t
X
Xonames.h:	makedefs objects.h
X	makedefs -o
X
Xmain.o:
X
Xmain.c:	unixmain.c hack.h
X	cp $(MAIN) main.c
X
Xtty.o:
X
Xtty.c:	unixtty.c extern.h
X	cp $(TTY) tty.c
X
Xunix.o:
X
Xunix.c:	unixunix.c hack.h mkroom.h
X	cp $(UNIX) unix.c
X
Xlint:
X# lint cannot have -p here because (i) capitals are meaningful:
X# [Ww]izard, (ii) identifiers may coincide in the first six places:
X# doweararm() versus dowearring().
X# _flsbuf comes from <stdio.h>, a bug in the system libraries.
X	@echo lint -axbh -DLINT ...
X	@lint -axbh -DLINT $(HACKCSRC) | sed '/_flsbuf/d'
X
X
Xdiff:
X	@- for i in $(SOURCES) $(AUX) ; do \
X		cmp -s $$i $D/$$i || \
X		( echo diff $D/$$i $$i ; diff $D/$$i $$i ; echo ) ; done
X
Xdistribution: Makefile
X	@- for i in READ_ME $(SOURCES) $(AUX) Makefile date.h onames.h\
X		; do \
X		cmp -s $$i $D/$$i || \
X		( echo cp $$i $D ; cp $$i $D ) ; done
X# the distribution directory also contains the empty files perm and record.
X
Xinitial:
X	-rm -rf $(GAMEDIR)
X	-mkdir $(SHELLDIR)
X	mkdir $(GAMEDIR) $(GAMEDIR)/save
X	touch $(GAMEDIR)/perm
X	touch $(GAMEDIR)/record
X	touch $(GAMEDIR)/logfile
X	chown $(GAMEUID) $(GAMEDIR) $(GAMEDIR)/*
X	chgrp $(GAMEGRP) $(GAMEDIR) $(GAMEDIR)/*
X	chmod 666 $(GAMEDIR)/*
X	chmod 777 $(GAMEDIR) $(GAMEDIR)/save
X
Xinstall: $(VARAUX)
X	-rm -f $(GAMEDIR)/$(GAME)
X	-rm -f $(GAMEDIR)/bones*
X	-rm -f $(GAMEDIR)/save/*
X	cp help hh rumors data $(GAMEDIR)
X	cp $(GAME).sh $(SHELLDIR)/$(GAME)
X	cp $(GAME) $(GAMEDIR)/$(GAME)
X	chown $(GAMEUID) $(SHELLDIR)/$(GAME) $(GAMEDIR)/*
X	chgrp $(GAMEGRP) $(SHELLDIR)/$(GAME) $(GAMEDIR)/*
X	chmod 0755 $(SHELLDIR)/$(GAME)
X	chmod 04755 $(GAMEDIR)/$(GAME)
X	-cp nethack.6 $(MANDIR)
X
Xclean:
X	rm -f *.o
X
Xspotless: clean
X	rm -f a.out core $(GAME) makedefs
X	rm -f Makefile $(VARAUX) main.c tty.c unix.c
X
Xdepend:
X# For the moment we are lazy and disregard /usr/include files because
X# the sources contain them conditionally. Perhaps we should use cpp.
X#		( /bin/grep '^#[ 	]*include' $$i | sed -n \
X#			-e 's,<\(.*\)>,"/usr/include/\1",' \
X#
X	for i in ${CSOURCES}; do \
X		( /bin/grep '^#[ 	]*include[ 	]*"' $$i | sed -n \
X			-e 's/[^"]*"\([^"]*\)".*/\1/' \
X			-e H -e '$$g' -e '$$s/\n/ /g' \
X			-e '$$s/.*/'$$i': &/' -e '$$s/\.c:/.o:/p' \
X			>> makedep); done
X	for i in ${HSOURCES}; do \
X		( /bin/grep '^#[ 	]*include[ 	]*"' $$i | sed -n \
X			-e 's/[^"]*"\([^"]*\)".*/\1/' \
X			-e H -e '$$g' -e '$$s/\n/ /g' \
X			-e '$$s/.*/'$$i': &\
X				touch '$$i/p \
X			>> makedep); done
X	@echo '/^# DO NOT DELETE THIS LINE/+2,$$d' >eddep
X	@echo '$$r makedep' >>eddep
X	@echo 'w' >>eddep
X	@cp Makefile Makefile.bak
X	ed - Makefile < eddep
X	@rm -f eddep makedep
X	@echo '# DEPENDENCIES MUST END AT END OF FILE' >> Makefile
X	@echo '# IF YOU PUT STUFF HERE IT WILL GO AWAY' >> Makefile
X	@echo '# see make depend above' >> Makefile
X	- diff Makefile Makefile.bak
X	@rm -f Makefile.bak
X
X# DO NOT DELETE THIS LINE
X
Xdecl.o:  hack.h mkroom.h
Xapply.o:  hack.h edog.h mkroom.h
Xbones.o:  hack.h
Xhack.o:  hack.h
Xcmd.o:  hack.h func_tab.h
Xdo.o:  hack.h
Xdo_name.o:  hack.h
Xdo_wear.o:  hack.h
Xdog.o:  hack.h edog.h mkroom.h
Xdogmove.o:  hack.h mfndpos.h edog.h mkroom.h
Xdothrow.o:  hack.h
Xeat.o:  hack.h
Xend.o:  hack.h
Xengrave.o:  hack.h
Xfight.o:  hack.h
Xfountain.o:  hack.h mkroom.h
Xinvent.o:  hack.h wseg.h
Xioctl.o:  config.h
Xlev.o:  hack.h mkroom.h wseg.h
Xmakemon.o:  hack.h
Xmhitu.o:  hack.h
Xmklev.o:  hack.h mkroom.h
Xmkmaze.o:  hack.h mkroom.h
Xmkobj.o:  hack.h
Xmkshop.o:  hack.h mkroom.h eshk.h
Xmon.o:  hack.h mfndpos.h
Xmonmove.o:  hack.h mfndpos.h
Xmonst.o:  hack.h eshk.h
Xo_init.o:  config.h objects.h onames.h
Xobjnam.o:  hack.h
Xoptions.o:  hack.h
Xpager.o:  hack.h
Xpolyself.o: hack.h
Xpotion.o:  hack.h
Xpray.o:  hack.h
Xpri.o:  hack.h
Xprisym.o:  hack.h wseg.h
Xread.o:  hack.h
Xrip.o:  hack.h
Xrumors.o:  hack.h
Xsave.o:  hack.h
Xsearch.o:  hack.h
Xshk.o:  hack.h mfndpos.h mkroom.h eshk.h
Xshknam.o:  hack.h
Xsit.o: hack.h
Xspell.o:  hack.h
Xsteal.o:  hack.h
Xtermcap.o:  hack.h
Xtimeout.o:  hack.h
Xtopl.o:  hack.h
Xtopten.o:  hack.h
Xtrack.o:  hack.h
Xtrap.o:  hack.h edog.h mkroom.h
Xu_init.o:  hack.h
Xvault.o:  hack.h mkroom.h
Xwield.o:  hack.h
Xwizard.o:  hack.h
Xworm.o:  hack.h wseg.h
Xworn.o:  hack.h
Xwrite.o:  hack.h
Xzap.o:  hack.h
Xversion.o:  hack.h date.h
Xextern.h: config.h spell.h obj.h
X	touch extern.h
Xhack.h: extern.h flag.h gold.h monst.h objclass.h rm.h trap.h you.h 
X	touch hack.h
Xobjects.h:  config.h objclass.h
X	touch objects.h
Xyou.h: config.h onames.h permonst.h 
X	touch you.h
X# DEPENDENCIES MUST END AT END OF FILE
X# IF YOU PUT STUFF HERE IT WILL GO AWAY
X# see make depend above
END_OF_Makefile.att
if test 7040 -ne `wc -c <Makefile.att`; then
    echo shar: \"Makefile.att\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f Makefile.unix -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"Makefile.unix\"
else
echo shar: Extracting \"Makefile.unix\" \(7502 characters\)
sed "s/^X//" >Makefile.unix <<'END_OF_Makefile.unix'
X#	Hack or Quest Makefile.
X#	SCCS Id: @(#)Makefile.unix	2.3	88/02/12
X
X# if you are cross-compiling (eg. from Xenix into a Dos enviornment)
X# you will have to redefine these filenames.
XMAIN = unixmain.c
XTTY  = unixtty.c
XUNIX = unixunix.c
X
X# flags may have to be changed as required
XCFLAGS = -O
XLFLAGS =
X
X# on some systems the termcap library is in -ltermcap
XTERMLIB = -ltermlib
X
X# make NetHack
XGAME     = nethack
XGAMEUID  = games
XGAMEGRP  = bin
X
X#	GAMEDIR also appears in config.h as "HACKDIR".
XGAMEDIR  = /usr/games/lib/$(GAME)dir
XSHELLDIR = /usr/games
XMANDIR   = /usr/man/man6
XMANEXT   = 6
X
XHACKCSRC = alloc.c apply.c bones.c cmd.c decl.c do.c do_name.c do_wear.c\
X	dog.c dogmove.c dothrow.c eat.c end.c engrave.c fight.c fountain.c\
X	hack.c invent.c ioctl.c lev.c main.c makemon.c mhitu.c\
X	mklev.c mkmaze.c mkobj.c mkshop.c mon.c monmove.c monst.c o_init.c\
X	objnam.c options.c pager.c polyself.c potion.c pray.c pri.c\
X	prisym.c read.c rip.c rnd.c rumors.c save.c search.c shk.c shknam.c\
X	sit.c spell.c steal.c termcap.c timeout.c topl.c topten.c track.c\
X	trap.c tty.c u_init.c unix.c vault.c version.c wield.c wizard.c\
X	worm.c worn.c write.c zap.c
X
XCSOURCES = $(HACKCSRC) makedefs.c
X
XHSOURCES = config.h date.h edog.h eshk.h extern.h flag.h func_tab.h\
X	gen.h gold.h hack.h mfndpos.h mkroom.h monst.h msdos.h\
X	obj.h objclass.h objects.h onames.h permonst.h rm.h\
X	spell.h trap.h wseg.h you.h
X
XSOURCES = $(CSOURCES) $(HSOURCES)
X
XSPECIFICS = main.o tty.o unix.o
XAUX = help hh nethack.6 nethack.sh
XVARAUX = data rumors
X
XDISTR = $(SOURCES) $(AUX) $(VARAUX) README.OLD README\
X	Makefile Makefile.pc Make.ini
X
XHOBJ = alloc.o apply.o bones.o cmd.o decl.o do.o do_name.o do_wear.o\
X	dog.o dogmove.o dothrow.o eat.o end.o engrave.o fight.o fountain.o\
X	hack.o invent.o ioctl.o lev.o main.o makemon.o mhitu.o\
X	mklev.o mkmaze.o mkobj.o mkshop.o mon.o monmove.o monst.o o_init.o\
X	objnam.o options.o pager.o polyself.o potion.o pray.o pri.o\
X	prisym.o read.o rip.o rnd.o rumors.o save.o search.o shk.o shknam.o\
X	sit.o spell.o steal.o termcap.o timeout.o topl.o topten.o track.o\
X	trap.o tty.o u_init.o unix.o vault.o version.o wield.o wizard.o\
X	worm.o worn.o write.o zap.o
X
X$(GAME):	$(SPECIFICS) $(HOBJ) Makefile
X	@echo "Loading ..."
X	@cc $(LFLAGS) -o $(GAME) $(HOBJ) $(TERMLIB)
X
Xall:	$(GAME) Guidebook lint
X	@echo "Done."
X
XGuidebook:	Guidebook.mn
X	nroff -mn Guidebook.mn > Guidebook
X
Xmakedefs:	makedefs.c alloc.o config.h
X	cc $(CFLAGS) -o makedefs alloc.o makedefs.c
X
XRUMORFILES= rumors.base rumors.kaa rumors.mrx
X
Xrumors:	config.h $(RUMORFILES) makedefs
X	./makedefs -r
X
Xdata:	config.h data.base makedefs
X	./makedefs -d
X
Xdate.h:	$(SOURCES) makedefs
X	./makedefs -D
X
Xtrap.h:	config.h makedefs
X	./makedefs -t
X
Xonames.h:	makedefs objects.h
X	./makedefs -o
X
Xmain.o:
X
Xmain.c:	unixmain.c hack.h
X	cp $(MAIN) main.c
X
Xtty.o:
X
Xtty.c:	unixtty.c hack.h func_tab.h
X	cp $(TTY) tty.c
X
Xunix.o:
X
Xunix.c:	unixunix.c hack.h mkroom.h
X	cp $(UNIX) unix.c
X
Xlint:
X# lint cannot have -p here because (i) capitals are meaningful:
X# [Ww]izard, (ii) identifiers may coincide in the first six places:
X# doweararm() versus dowearring().
X# _flsbuf comes from <stdio.h>, a bug in the system libraries.
X	@echo lint -axbh -DLINT ...
X	@lint -axbh -DLINT $(HACKCSRC) | sed '/_flsbuf/d'
X
X
Xdiff:
X	@- for i in $(SOURCES) $(AUX) ; do \
X		cmp -s $$i $D/$$i || \
X		( echo diff $D/$$i $$i ; diff $D/$$i $$i ; echo ) ; done
X
Xdistribution: Makefile
X	@- for i in READ_ME $(SOURCES) $(AUX) Makefile date.h onames.h\
X		; do \
X		cmp -s $$i $D/$$i || \
X		( echo cp $$i $D ; cp $$i $D ) ; done
X# the distribution directory also contains the empty files perm and record.
X
Xinitial:
X	-rm -rf $(GAMEDIR)
X	-mkdir $(SHELLDIR)
X	mkdir $(GAMEDIR) $(GAMEDIR)/save
X	touch $(GAMEDIR)/perm
X	touch $(GAMEDIR)/record
X	touch $(GAMEDIR)/logfile
X	chown $(GAMEUID) $(SHELLDIR)/$(GAME) $(GAMEDIR) $(GAMEDIR)/*
X	chgrp $(GAMEGRP) $(SHELLDIR)/$(GAME) $(GAMEDIR) $(GAMEDIR)/*
X	chmod 666 $(GAMEDIR)/*
X	chmod 777 $(GAMEDIR) $(GAMEDIR)/save
X
Xinstall: $(VARAUX) $(GAME)
X	strip $(GAME)
X	-mkdir $(GAMEDIR)
X	-mkdir $(GAMEDIR)/save
X	-rm -f $(GAMEDIR)/$(GAME)
X	-rm -f $(GAMEDIR)/bones* $(GAMEDIR)/alock* $(GAMEDIR)/wizard*
X	-rm -f $(GAMEDIR)/save/*
X	touch $(GAMEDIR)/perm $(GAMEDIR)/record
X	cp help hh rumors data $(GAMEDIR)
X	cp $(GAME).sh $(SHELLDIR)/$(GAME)
X	cp $(GAME) $(GAMEDIR)/$(GAME)
X	chown $(GAMEUID) $(SHELLDIR)/$(GAME) $(GAMEDIR)/*
X	chgrp $(GAMEGRP) $(SHELLDIR)/$(GAME) $(GAMEDIR)/*
X	chmod 0755 $(SHELLDIR)/$(GAME)
X	chmod 04755 $(GAMEDIR)/$(GAME)
X	-cp nethack.6 $(MANDIR)/$(GAME).$(MANEXT)
X
Xdebug:
X	ln $(GAMEDIR)/$(GAME) a.out
X	ln $(GAMEDIR)/core core
X
Xtags: $(SOURCES)
X	@echo ctags -tw ...
X	@ctags -tw $(SOURCES)
X  
Xclean:
X	rm -f *.o
X
Xspotless: clean
X	rm -f a.out core $(GAME) makedefs
X	rm -f Makefile $(VARAUX) main.c tty.c unix.c
X
Xdepend:
X# For the moment we are lazy and disregard /usr/include files because
X# the sources contain them conditionally. Perhaps we should use cpp.
X#		( /bin/grep '^#[ 	]*include' $$i | sed -n \
X#			-e 's,<\(.*\)>,"/usr/include/\1",' \
X#
X	for i in ${CSOURCES}; do \
X		( /bin/grep '^#[ 	]*include[ 	]*"' $$i | sed -n \
X			-e 's/[^"]*"\([^"]*\)".*/\1/' \
X			-e H -e '$$g' -e '$$s/\n/ /g' \
X			-e '$$s/.*/'$$i': &/' -e '$$s/\.c:/.o:/p' \
X			>> makedep); done
X	for i in ${HSOURCES}; do \
X		( /bin/grep '^#[ 	]*include[ 	]*"' $$i | sed -n \
X			-e 's/[^"]*"\([^"]*\)".*/\1/' \
X			-e H -e '$$g' -e '$$s/\n/ /g' \
X			-e '$$s/.*/'$$i': &\
X				touch '$$i/p \
X			>> makedep); done
X	@echo '/^# DO NOT DELETE THIS LINE/+2,$$d' >eddep
X	@echo '$$r makedep' >>eddep
X	@echo 'w' >>eddep
X	@cp Makefile Makefile.bak
X	ed - Makefile < eddep
X	@rm -f eddep makedep
X	@echo '# DEPENDENCIES MUST END AT END OF FILE' >> Makefile
X	@echo '# IF YOU PUT STUFF HERE IT WILL GO AWAY' >> Makefile
X	@echo '# see make depend above' >> Makefile
X	- diff Makefile Makefile.bak
X	@rm -f Makefile.bak
X
X# DO NOT DELETE THIS LINE
X
Xdecl.o:  hack.h mkroom.h
Xapply.o:  hack.h edog.h mkroom.h
Xbones.o:  hack.h
Xhack.o:  hack.h
Xcmd.o:  hack.h func_tab.h
Xdo.o:  hack.h
Xdo_name.o:  hack.h
Xdo_wear.o:  hack.h
Xdog.o:  hack.h edog.h mkroom.h
Xdogmove.o:  hack.h mfndpos.h edog.h mkroom.h
Xdothrow.o:  hack.h
Xeat.o:  hack.h
Xend.o:  hack.h
Xengrave.o:  hack.h
Xfight.o:  hack.h
Xfountain.o:  hack.h mkroom.h
Xinvent.o:  hack.h wseg.h
Xioctl.o:  config.h
Xlev.o:  hack.h mkroom.h wseg.h
Xmakemon.o:  hack.h
Xmhitu.o:  hack.h
Xmklev.o:  hack.h mkroom.h
Xmkmaze.o:  hack.h mkroom.h
Xmkobj.o:  hack.h
Xmkshop.o:  hack.h mkroom.h eshk.h
Xmon.o:  hack.h mfndpos.h
Xmonmove.o:  hack.h mfndpos.h
Xmonst.o:  hack.h eshk.h
Xo_init.o:  config.h objects.h onames.h
Xobjnam.o:  hack.h
Xoptions.o:  hack.h
Xpager.o:  hack.h
Xpolyself.o: hack.h
Xpotion.o:  hack.h
Xpray.o:  hack.h
Xpri.o:  hack.h
Xprisym.o:  hack.h wseg.h
Xread.o:  hack.h
Xrip.o:  hack.h
Xrumors.o:  hack.h
Xsave.o:  hack.h
Xsearch.o:  hack.h
Xshk.o:  hack.h mfndpos.h mkroom.h eshk.h
Xshknam.o:  hack.h
Xsit.o: hack.h
Xspell.o:  hack.h
Xsteal.o:  hack.h
Xtermcap.o:  hack.h
Xtimeout.o:  hack.h
Xtopl.o:  hack.h
Xtopten.o:  hack.h
Xtrack.o:  hack.h
Xtrap.o:  hack.h edog.h mkroom.h
Xu_init.o:  hack.h
Xvault.o:  hack.h mkroom.h
Xwield.o:  hack.h
Xwizard.o:  hack.h
Xworm.o:  hack.h wseg.h
Xworn.o:  hack.h
Xwrite.o:  hack.h
Xzap.o:  hack.h
Xversion.o:  hack.h date.h
Xextern.h: config.h spell.h obj.h
X	touch extern.h
Xhack.h: extern.h flag.h gold.h monst.h objclass.h rm.h trap.h you.h 
X	touch hack.h
Xobjects.h:  config.h objclass.h
X	touch objects.h
Xyou.h: config.h onames.h permonst.h 
X	touch you.h
X# DEPENDENCIES MUST END AT END OF FILE
X# IF YOU PUT STUFF HERE IT WILL GO AWAY
X# see make depend above
END_OF_Makefile.unix
if test 7502 -ne `wc -c <Makefile.unix`; then
    echo shar: \"Makefile.unix\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f Makefile.xpc -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"Makefile.xpc\"
else
echo shar: Extracting \"Makefile.xpc\" \(7056 characters\)
sed "s/^X//" >Makefile.xpc <<'END_OF_Makefile.xpc'
X
X
X   Here is my makefile stuff for PC NetHack. It works with NDmake 4.3
Xand contains four files. makefile is the makefile for NetHack.
Xlinkit.bat is a batch file to link it, and nethack.lnk is used by
Xlinkit.bat. Finally there is another makefile for creating termlib.lib.
XHope this comes in handy for someone.
X
X-	-	-	-	-	-	-	-	-
XSteve Creps on the VAX 8650 running Ultrix 2.0-1 at Indiana University.
X	creps@silver.bacs.indiana.edu
X"F-14 Tomcat! There IS no substitute."
X
X
X
Xmakefile
X#
X#      SCCS Id: @(#)Makefile.pc        2.2
X# 	Makefile for NetHack (PC) version 1.0 written using
X#	Microsoft(tm) "C" v3.0 or better.
X# 
X# Large memory model, register bug, remove stack probes:
XCC = msc
XLINK = link
XMODEL = L
XCFLAGS = /A$(MODEL) /DREGBUG /DLINT_ARGS /Ot /Gt48
XLIBS = l:\
XLFLAGS =
XSETARGV = $(LIBS)$(MODEL)SETARGV
X 
X# The game name
XGAME = nethack
X 
X# The game directory
XGAMEDIR = c:\games\nethack
X 
X# All object modules
XOBJS = o\decl.obj o\apply.obj o\bones.obj o\cmd.obj o\do.obj o\dothrow.obj \
X	o\do_name.obj o\do_wear.obj o\dog.obj o\dogmove.obj o\eat.obj \
X	o\end.obj o\engrave.obj o\fight.obj o\fountain.obj o\hack.obj \
X	o\invent.obj o\lev.obj o\pcmain.obj o\makemon.obj o\mhitu.obj \
X	o\mklev.obj o\mkmaze.obj o\mkobj.obj o\mkshop.obj o\mon.obj \
X	o\monmove.obj o\monst.obj o\o_init.obj o\objnam.obj o\options.obj \
X	o\pager.obj o\polyself.obj o\potion.obj o\pray.obj o\pri.obj \
X	o\prisym.obj o\read.obj o\rip.obj o\rumors.obj o\save.obj \
X	o\search.obj o\shk.obj o\shknam.obj o\sit.obj o\spell.obj o\steal.obj \
X	o\termcap.obj o\timeout.obj o\topl.obj o\topten.obj o\track.obj \
X	o\trap.obj o\pctty.obj o\pcunix.obj o\u_init.obj o\vault.obj \
X	o\wield.obj o\wizard.obj o\worm.obj o\worn.obj o\write.obj o\zap.obj \
X	o\version.obj o\rnd.obj o\alloc.obj o\msdos.obj
X 
X.c.obj:; $(CC) $*.c, o\$*.obj $(CFLAGS);
X.c.exe:;
X	$(CC) $*.c, o\$*.obj $(CFLAGS);
X	$(LINK) o\$*.obj $(SETARGV), $@,, $(LIBS) $(LFLAGS);
X 
X# The main target
X#
X$(GAME) : $(GAME).exe
X 
X$(GAME).exe : $(GAMEDIR)\$(GAME).exe
X 
X$(GAMEDIR)\$(GAME).exe : $(OBJS)
X	- .\linkit
X 
X#	variable auxilary files.
X#
XVARAUX = $(GAMEDIR)\data $(GAMEDIR)\rumors
X 
Xinstall : $(GAMEDIR)\$(GAME).exe $(VARAUX)
X	- exepack $(GAME).exe $(GAMEDIR)\$(GAME).exe
X	- exemod $(GAMEDIR)\$(GAME).exe /max 1
X 
Xclean :
X	erase $(GAME)
X 
Xspotless : clean
X	erase o\*.obj
X 
X#	Other dependencies
X#
Xo :
X	mkdir o
X 
XRUMORFILES= rumors.bas rumors.kaa rumors.mrx
X 
Xmakedefs : makedefs.exe
X 
Xo\makedefs.obj : makedefs.c config.h
X 
Xo\alloc.obj : alloc.c
X 
Xmakedefs.exe :  o\makedefs.obj o\alloc.obj
X	$(LINK) o\makedefs.obj o\alloc.obj;
X 
Xrumors :  config.h $(RUMORFILES) makedefs.exe
X	makedefs -r
X 
X$(GAMEDIR)\rumors : rumors
X	mv rumors $(GAMEDIR)
X 
Xdata :  config.h data.bas makedefs.exe
X	makedefs -d
X 
X$(GAMEDIR)\data : data
X	mv data $(GAMEDIR)
X 
Xhack.h :  config.h objclass.h monst.h gold.h trap.h obj.h flag.h rm.h \
X	permonst.h onames.h spell.h extern.h you.h
X	touch hack.h
X 
Xobjects.h :  config.h objclass.h
X	touch objects.h
X 
Xonames.h :  config.h objects.h makedefs.exe
X       makedefs -o
X 
Xextern.h : config.h
X	touch extern.h
X 
X#	Below is a kludge.  date.h should actually depend on any source
X#	module being changed. (but hack.h is close enough for most).
X#
Xdate.h :  hack.h makedefs.exe
X       makedefs -D
X 
Xtrap.h :  config.h makedefs.exe
X       makedefs -t
X 
Xo\pcmain.obj : pcmain.c hack.h
Xo\pctty.obj : pctty.c hack.h
Xo\pcunix.obj : pcunix.c hack.h mkroom.h
Xo\decl.obj :  hack.h mkroom.h decl.c
Xo\apply.obj :  hack.h edog.h mkroom.h apply.c
Xo\bones.obj :  hack.h bones.c
Xo\hack.obj :  hack.h hack.c
Xo\cmd.obj :  hack.h func_tab.h msdos.h cmd.c
Xo\do.obj :  hack.h do.c
Xo\do_name.obj :  hack.h do_name.c
Xo\do_wear.obj :  hack.h do_wear.c
Xo\dog.obj :  hack.h edog.h mkroom.h dog.c
Xo\dogmove.obj :  hack.h mfndpos.h dogmove.c
Xo\dothrow.obj :  hack.h dothrow.c
Xo\eat.obj :  hack.h eat.c
Xo\end.obj :  hack.h end.c
Xo\engrave.obj :  hack.h engrave.c
Xo\fight.obj :  hack.h fight.c
Xo\fountain.obj :  hack.h fountain.c
Xo\invent.obj :  hack.h wseg.h invent.c
Xo\ioctl.obj :  config.h ioctl.c
Xo\lev.obj :  hack.h mkroom.h wseg.h lev.c
Xo\makemon.obj :  hack.h makemon.c
Xo\mhitu.obj :  hack.h mhitu.c
Xo\mklev.obj :  hack.h mkroom.h mklev.c
Xo\mkmaze.obj :  hack.h mkroom.h mkmaze.c
Xo\mkobj.obj :  hack.h mkobj.c
Xo\mkshop.obj :  hack.h mkroom.h eshk.h mkshop.c
Xo\mon.obj :  hack.h mfndpos.h mon.c
Xo\monmove.obj :  hack.h mfndpos.h monmove.c
Xo\monst.obj :  hack.h eshk.h monst.c
Xo\o_init.obj :  config.h objects.h onames.h o_init.c
Xo\objnam.obj :  hack.h objnam.c
Xo\options.obj :  config.h hack.h options.c
Xo\pager.obj :  hack.h pager.c
Xo\polyself.obj :  hack.h polyself.c
Xo\potion.obj :  hack.h potion.c
Xo\pray.obj :  hack.h pray.c
Xo\pri.obj :  hack.h pri.c
Xo\prisym.obj :  hack.h wseg.h prisym.c
Xo\read.obj :  hack.h read.c
Xo\rip.obj :  hack.h rip.c
Xo\rumors.obj :  config.h rumors.c
Xo\save.obj :  hack.h save.c
Xo\search.obj :  hack.h search.c
Xo\shk.obj :  hack.h mfndpos.h mkroom.h eshk.h shk.c
Xo\shknam.obj :  hack.h shknam.c
Xo\sit.obj :  hack.h sit.c
Xo\spell.obj :  hack.h spell.c
Xo\steal.obj :  hack.h steal.c
Xo\termcap.obj :  config.h flag.h termcap.c
Xo\timeout.obj :  hack.h timeout.c
Xo\topl.obj :  hack.h topl.c
Xo\topten.obj :  hack.h topten.c
Xo\track.obj :  hack.h track.c
Xo\trap.obj :  hack.h mkroom.h trap.c
Xo\u_init.obj :  hack.h u_init.c
Xo\vault.obj :  hack.h mkroom.h vault.c
Xo\version.obj : hack.h date.h version.c
Xo\wield.obj :  hack.h wield.c
Xo\wizard.obj :  hack.h wizard.c
Xo\worm.obj :  hack.h wseg.h worm.c
Xo\worn.obj :  hack.h worn.c
Xo\write.obj :  hack.h write.c
Xo\zap.obj :  hack.h zap.c
Xo\msdos.obj : msdos.h msdos.c
X
X
X
X
X
X
Xlinkit.bat
Xecho on
Xlink @nethack.lnk,nethack.exe,nethack.map,ltermlib.lib /NOIG /STACK:0xf00 /SEGMENTS:400 /EXEPACK
X
X
X
X
X
Xnethack.lnk
Xo\decl.obj o\apply.obj o\bones.obj o\cmd.obj +
Xo\do.obj o\dothrow.obj o\do_name.obj o\do_wear.obj +
Xo\dog.obj o\dogmove.obj o\eat.obj o\end.obj +
Xo\engrave.obj o\fight.obj o\fountain.obj o\hack.obj +
Xo\invent.obj o\lev.obj o\pcmain.obj o\makemon.obj +
Xo\mhitu.obj o\mklev.obj o\mkmaze.obj o\mkobj.obj +
Xo\mkshop.obj o\mon.obj o\monmove.obj o\monst.obj +
Xo\o_init.obj o\objnam.obj o\options.obj o\pager.obj +
Xo\polyself.obj o\potion.obj o\pray.obj o\pri.obj +
Xo\prisym.obj o\read.obj o\rip.obj o\rumors.obj +
Xo\save.obj o\search.obj o\shk.obj o\shknam.obj +
Xo\sit.obj o\spell.obj o\steal.obj o\termcap.obj +
Xo\timeout.obj o\topl.obj o\topten.obj o\track.obj +
Xo\trap.obj o\pctty.obj o\pcunix.obj o\u_init.obj +
Xo\vault.obj o\wield.obj o\wizard.obj o\worm.obj +
Xo\worn.obj o\write.obj o\zap.obj o\version.obj +
Xo\rnd.obj o\alloc.obj o\msdos.obj
X
X
X
X
Xmakefile (for termlib)
X#
XMODEL	=	L
XCFLAGS	=	/A$(MODEL) /DDGK
X#
XTSOURCES =	testtcp.c 
XLSOURCES =	tgetent.c tgetflag.c tgetnum.c tgetstr.c tgoto.c \
X		tputs.c isdigit.c fgetlr.c
X#
XTOBJECTS =	testtcp.obj
XLOBJECTS =	tgetent.obj tgetflag.obj tgetnum.obj tgetstr.obj \
X		tgoto.obj tputs.obj isdigit.obj fgetlr.obj
X#
X$(MODEL) : $(MODEL)termlib.lib
X 
X$(MODEL)termlib : $(MODEL)termlib.lib
X 
X$(MODEL)termlib.lib :	$(LOBJECTS)
X	lib $(MODEL)termlib.lib tgetent+tgetflag+tgetnum+tgetstr+tgoto+tputs+isdigit+fgetlr
X 
X
X
END_OF_Makefile.xpc
if test 7056 -ne `wc -c <Makefile.xpc`; then
    echo shar: \"Makefile.xpc\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f do_name.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"do_name.c\"
else
echo shar: Extracting \"do_name.c\" \(7539 characters\)
sed "s/^X//" >do_name.c <<'END_OF_do_name.c'
X/*	SCCS Id: @(#)do_name.c	2.3	88/02/11
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X
X#include <stdio.h>
X#include "hack.h"
Xextern char plname[];
Xextern char *rndmonnam();
Xextern void savech();
X
Xgetpos(cc,force,goal)
Xcoord	*cc;
Xint force; char *goal;
X{
Xregister cx,cy,i,c;
Xextern char sdir[];		/* defined in hack.c */
Xextern schar xdir[], ydir[];	/* idem */
Xextern char *visctrl();		/* see below */
X	pline("(For instructions type a ?)");
X	cx = u.ux;
X	cy = u.uy;
X	curs(cx,cy+2);
X	while((c = readchar()) != '.'){
X		for(i=0; i<8; i++) if(sdir[i] == c){
X			if(1 <= cx + xdir[i] && cx + xdir[i] <= COLNO)
X				cx += xdir[i];
X			if(0 <= cy + ydir[i] && cy + ydir[i] <= ROWNO-1)
X				cy += ydir[i];
X			goto nxtc;
X		}
X		if(c == '?'){
X			pline("Use [hjkl] to move the cursor to %s.", goal);
X			pline("Type a . when you are at the right place.");
X		} else {
X			pline("Unknown direction: '%s' (%s).",
X				visctrl(c),
X				force ? "use hjkl or ." : "aborted");
X			if(force) goto nxtc;
X			cc->x = -1;
X			cc->y = 0;
X			return(0);
X		}
X	nxtc:	;
X		curs(cx,cy+2);
X	}
X	cc->x = cx;
X	cc->y = cy;
X	return(0);
X}
X
Xdo_mname(){
Xchar buf[BUFSZ];
Xcoord cc;
Xregister int cx,cy,lth,i;
Xregister struct monst *mtmp, *mtmp2;
Xextern char *lmonnam();
X	getpos(&cc, 0, "the monster you want to name");
X	cx = cc.x;
X	cy = cc.y;
X	if(cx < 0) return(0);
X#ifdef DGKMOD
X	if (cx == u.ux && cy == u.uy) {
X		pline("This ugly monster is called %s and cannot be renamed.",
X		plname);
X		return(1);
X	}
X	if (!cansee(cx, cy) || !(mtmp = m_at(cx, cy)) || mtmp->mimic) {
X		pline("I see no monster there.");
X		return(1);
X	}
X#else
X	mtmp = m_at(cx,cy);
X	if(!mtmp){
X	    if(cx == u.ux && cy == u.uy)
X		pline("This ugly monster is called %s and cannot be renamed.",
X		    plname);
X	    else
X		pline("There is no monster there.");
X	    return(1);
X	}
X	if(mtmp->mimic){
X	    pline("I see no monster there.");
X	    return(1);
X	}
X	if(!cansee(cx,cy)) {
X	    pline("I cannot see a monster there.");
X	    return(1);
X	}
X#endif
X	pline("What do you want to call %s? ", lmonnam(mtmp));
X	getlin(buf);
X	clrlin();
X	if(!*buf || *buf == '\033')
X		return(1);
X	lth = strlen(buf)+1;
X	if(lth > 63){
X		buf[62] = 0;
X		lth = 63;
X	}
X	mtmp2 = newmonst(mtmp->mxlth + lth);
X	*mtmp2 = *mtmp;
X	for(i=0; i<mtmp->mxlth; i++)
X		((char *) mtmp2->mextra)[i] = ((char *) mtmp->mextra)[i];
X	mtmp2->mnamelth = lth;
X	(void) strcpy(NAME(mtmp2), buf);
X	replmon(mtmp,mtmp2);
X	return(1);
X}
X
X/*
X * This routine changes the address of  obj . Be careful not to call it
X * when there might be pointers around in unknown places. For now: only
X * when  obj  is in the inventory.
X */
Xdo_oname(obj)
X	register struct obj *obj;
X{
X	char buf[BUFSZ];
X
X	pline("What do you want to name %s? ", doname(obj));
X	getlin(buf);
X	clrlin();
X	if(!*buf || *buf == '\033')	return;
X#ifdef RPH
X	if(!strcmp(buf, "Excalibur")) {
X		pline("Somehow you can't seem to engrave that word.");
X		return;
X	}
X#endif
X	oname(obj, buf);
X}
X
Xoname(obj, buf)
X	register struct obj *obj;
X	char	*buf;
X{
Xregister struct obj *otmp, *otmp2;
Xregister int	lth;
X
X	lth = strlen(buf)+1;
X	if(lth > 63){
X		buf[62] = 0;
X		lth = 63;
X	}
X	otmp2 = newobj(lth);
X	*otmp2 = *obj;
X	otmp2->onamelth = lth;
X	(void) strcpy(ONAME(otmp2), buf);
X
X	setworn((struct obj *) 0, obj->owornmask);
X	setworn(otmp2, otmp2->owornmask);
X
X	/* do freeinv(obj); etc. by hand in order to preserve
X	   the position of this object in the inventory */
X	if(obj == invent) invent = otmp2;
X	else for(otmp = invent; ; otmp = otmp->nobj){
X		if(!otmp)
X			panic("oname: cannot find obj.");
X		if(otmp->nobj == obj){
X			otmp->nobj = otmp2;
X			break;
X		}
X	}
X	/* obfree(obj, otmp2);	/* now unnecessary: no pointers on bill */
X	free((char *) obj);	/* let us hope nobody else saved a pointer */
X}
X
Xddocall()
X{
X	register struct obj *obj;
X	char	ch;
X
X#ifdef REDO
X	if (!in_doagain)
X#endif
X		pline("Do you want to name an individual object? [ny] ");
X	switch(ch = readchar()) {
X	case '\033':
X		break;
X	case 'y':
X#ifdef REDO
X		savech(ch);
X#endif
X		obj = getobj("#", "name");
X		if(obj) do_oname(obj);
X		break;
X	default:
X#ifdef REDO
X		savech(ch);
X#endif
X#ifdef KAA
X		obj = getobj("?!=/*", "call");
X#else
X		obj = getobj("?!=/", "call");
X#endif
X		if(obj) docall(obj);
X	}
X	return(0);
X}
X
Xdocall(obj)
Xregister struct obj *obj;
X{
X	char buf[BUFSZ];
X	struct obj otemp;
X	register char **str1;
X	extern char *xname();
X	register char *str;
X
X	otemp = *obj;
X	otemp.quan = 1;
X	otemp.onamelth = 0;
X	str = xname(&otemp);
X	pline("Call %s %s: ", index(vowels,*str) ? "an" : "a", str);
X	getlin(buf);
X	clrlin();
X	if(!*buf || *buf == '\033')
X		return;
X	str = newstring(strlen(buf)+1);
X	(void) strcpy(str,buf);
X	str1 = &(objects[obj->otyp].oc_uname);
X	if(*str1) free(*str1);
X	*str1 = str;
X}
X
Xchar *ghostnames[] = {		/* these names should have length < PL_NSIZ */
X	/* Capitalize the names for asthetics -dgk
X	 */
X	"Adri", "Andries", "Andreas", "Bert", "David", "Dirk", "Emile",
X	"Frans", "Fred", "Greg", "Hether", "Jay", "John", "Jon", "Karnov",
X	"Kay", "Kenny", "Kevin", "Maud", "Michiel", "Mike", "Peter", "Robert",
X	"Ron", "Tom", "Wilmar", "Nick Danger", "Phoenix", "Miracleman",
X	"Stephan"
X};
X
Xchar *
Xxmonnam(mtmp, vb) register struct monst *mtmp; int vb; {
Xstatic char buf[BUFSZ];		/* %% */
Xextern char *shkname();
X	if(mtmp->mnamelth && !vb) {
X		(void) strcpy(buf, NAME(mtmp));
X		return(buf);
X	}
X	switch(mtmp->data->mlet) {
X	case ' ':
X		{ register char *gn = (char *) mtmp->mextra;
X		  if(!*gn) {		/* might also look in scorefile */
X		    gn = ghostnames[rn2(SIZE(ghostnames))];
X		    if(!rn2(2)) (void)
X		      strcpy((char *) mtmp->mextra, !rn2(5) ? plname : gn);
X		  }
X		  (void) sprintf(buf, "%s's ghost", gn);
X		}
X		break;
X	case '@':
X		if(mtmp->isshk) {
X			(void) strcpy(buf, shkname(mtmp));
X			break;
X		}
X#ifdef STOOGES
X		if(mtmp->isstooge) {
X			(void) strcpy(buf, mtmp->data->mname);
X			break;
X		}
X#endif
X		/* fall into next case */
X	default:
X		(void) sprintf(buf, "the %s%s",
X			mtmp->minvis ? "invisible " : "",
X			(Hallucination ? rndmonnam() : mtmp->data->mname));
X	}
X	if(vb && mtmp->mnamelth) {
X		(void) strcat(buf, " called ");
X		(void) strcat(buf, NAME(mtmp));
X	}
X	return(buf);
X}
X
Xchar *
Xlmonnam(mtmp) register struct monst *mtmp; {
X	return(xmonnam(mtmp, 1));
X}
X
Xchar *
Xmonnam(mtmp) register struct monst *mtmp; {
X	return(xmonnam(mtmp, 0));
X}
X
Xchar *
XMonnam(mtmp) register struct monst *mtmp; {
Xregister char *bp = monnam(mtmp);
X	if('a' <= *bp && *bp <= 'z') *bp += ('A' - 'a');
X	return(bp);
X}
X
Xchar *
Xamonnam(mtmp,adj)
Xregister struct monst *mtmp;
Xregister char *adj;
X{
X	register char *bp = monnam(mtmp);
X	static char buf[BUFSZ];		/* %% */
X
X	if(!strncmp(bp, "the ", 4)) bp += 4;
X	(void) sprintf(buf, "the %s %s", adj, bp);
X	return(buf);
X}
X
Xchar *
XAmonnam(mtmp, adj)
Xregister struct monst *mtmp;
Xregister char *adj;
X{
X	register char *bp = amonnam(mtmp,adj);
X
X	*bp = 'T';
X	return(bp);
X}
X
Xchar *
XXmonnam(mtmp) register struct monst *mtmp; {
Xregister char *bp = Monnam(mtmp);
X	if(!strncmp(bp, "The ", 4)) {
X#ifdef KAA
X		if(index("AEIOUaeio",*(bp+4))) {
X			bp += 1; *(bp+1) = 'n';
X		} else
X#endif
X			bp += 2;
X		*bp = 'A';
X	}
X	return(bp);
X}
X
Xchar *
Xdefmonnam(mtmp) register struct monst *mtmp; {
Xregister char *bp = Xmonnam(mtmp);
X	if (!strncmp(bp,"A ",2) || !strncmp(bp,"An ",3))
X		*bp = 'a';
X	return(bp);
X}
X
Xchar *
Xrndmonnam() {  /* Random name of monster type, if hallucinating */
Xint x;
X	if ((x=rn2(CMNUM+2)) != CMNUM+1) return (&mons[x])->mname;
X	return("giant eel");
X}
X
Xchar *
Xvisctrl(c)
Xchar c;
X{
Xstatic char ccc[3];
X	if(c < 040) {
X		ccc[0] = '^';
X		ccc[1] = c + 0100;
X		ccc[2] = 0;
X	} else {
X		ccc[0] = c;
X		ccc[1] = 0;
X	}
X	return(ccc);
X}
END_OF_do_name.c
if test 7539 -ne `wc -c <do_name.c`; then
    echo shar: \"do_name.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f dogmove.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"dogmove.c\"
else
echo shar: Extracting \"dogmove.c\" \(7691 characters\)
sed "s/^X//" >dogmove.c <<'END_OF_dogmove.c'
X/*	SCCS Id: @(#)dogmove.c	1.4	87/08/08
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* dogmove.c - version 1.0 */
X
X#include	"hack.h"
X#include "mfndpos.h"
X#include "mkroom.h"
X#include "edog.h"
X
X/* return 0 (no move), 1 (move) or 2 (dead) */
Xdog_move(mtmp, after) register struct monst *mtmp; {
X#ifndef REGBUG
Xregister
X#endif
X	 int nx,ny,omx,omy,appr,nearer,j;
Xint udist,chi,i,whappr;
Xregister struct monst *mtmp2;
Xregister struct permonst *mdat = mtmp->data;
Xregister struct edog *edog = EDOG(mtmp);
Xstruct obj *obj;
Xstruct trap *trap;
Xxchar cnt,chcnt,nix,niy;
Xschar dogroom,uroom;
Xxchar gx,gy,gtyp,otyp;	/* current goal */
Xcoord poss[9];
Xlong info[9];
X#define GDIST(x,y) ((x-gx)*(x-gx) + (y-gy)*(y-gy))
X#define DDIST(x,y) ((x-omx)*(x-omx) + (y-omy)*(y-omy))
X
X	if(moves <= edog->eattime) return(0);	/* dog is still eating */
X	omx = mtmp->mx;
X	omy = mtmp->my;
X	whappr = (moves - EDOG(mtmp)->whistletime < 5);
X	if(moves > edog->hungrytime + 500 && !mtmp->mconf){
X		mtmp->mconf = 1;
X		mtmp->mhpmax /= 3;
X		if(mtmp->mhp > mtmp->mhpmax)
X			mtmp->mhp = mtmp->mhpmax;
X		if(cansee(omx,omy))
X			pline("%s is confused from hunger.", Monnam(mtmp));
X		else	pline("You feel worried about %s.", monnam(mtmp));
X	} else
X	if(moves > edog->hungrytime + 750 || mtmp->mhp < 1){
X#ifdef WALKIES
X		if(mtmp->mleashed) {
X			mtmp->mleashed = 0;
X			pline("Your leash goes slack...");
X		}
X#endif
X		if(cansee(omx,omy))
X			pline("%s dies%s.", Monnam(mtmp),
X			      (mtmp->mhp >= 1) ? "" : " from hunger");
X		else
X			pline("You have a sad feeling for a moment, then it passes.");
X		mondied(mtmp);
X		return(2);
X	}
X	dogroom = inroom(omx,omy);
X	uroom = inroom(u.ux,u.uy);
X	udist = dist(omx,omy);
X
X	/* maybe we tamed him while being swallowed --jgm */
X	if(!udist) return(0);
X
X	/* if we are carrying sth then we drop it (perhaps near @) */
X	/* Note: if apport == 1 then our behaviour is independent of udist */
X	if(mtmp->minvent){
X		if(!rn2(udist) || !rn2((int) edog->apport))
X		if(rn2(10) < edog->apport){
X			relobj(mtmp, (int) mtmp->minvis);
X			if(edog->apport > 1) edog->apport--;
X			edog->dropdist = udist;		/* hpscdi!jon */
X			edog->droptime = moves;
X		}
X	} else {
X		if(obj = o_at(omx,omy)) if(!index("0_", obj->olet)){
X		    if((otyp = dogfood(obj)) <= CADAVER){
X			nix = omx;
X			niy = omy;
X			goto eatobj;
X		    }
X		    if(obj->owt < 10*mtmp->data->mlevel)
X		    if(rn2(20) < edog->apport+3)
X		    if(rn2(udist) || !rn2((int) edog->apport)){
X			freeobj(obj);
X			unpobj(obj);
X			/* if(levl[omx][omy].scrsym == obj->olet)
X				newsym(omx,omy); */
X			mpickobj(mtmp,obj);
X		    }
X		}
X	}
X
X	gtyp = UNDEF;	/* no goal as yet */
X	gx = gy = 0;	/* suppress 'used before set' message */
X#ifdef WALKIES
X	/* If he's on a leash, he's not going anywhere. */
X	if(mtmp->mleashed) {
X
X		gtyp = APPORT;
X		gx = u.ux;
X		gy = u.uy;
X	} else
X#endif
X	/* first we look for food */
X	    for(obj = fobj; obj; obj = obj->nobj) {
X		otyp = dogfood(obj);
X		if(otyp > gtyp || otyp == UNDEF) continue;
X		if(inroom(obj->ox,obj->oy) != dogroom) continue;
X		if(otyp < MANFOOD &&
X		 (dogroom >= 0 || DDIST(obj->ox,obj->oy) < 10)) {
X			if(otyp < gtyp || (otyp == gtyp &&
X				DDIST(obj->ox,obj->oy) < DDIST(gx,gy))){
X				gx = obj->ox;
X				gy = obj->oy;
X				gtyp = otyp;
X			}
X		} else
X		if(gtyp == UNDEF && dogroom >= 0 &&
X		   uroom == dogroom &&
X		   !mtmp->minvent && edog->apport > rn2(8)){
X			gx = obj->ox;
X			gy = obj->oy;
X			gtyp = APPORT;
X		}
X	    }
X
X	if(gtyp == UNDEF ||
X	  (gtyp != DOGFOOD && gtyp != APPORT && moves < edog->hungrytime)){
X		if(dogroom < 0 || dogroom == uroom){
X			gx = u.ux;
X			gy = u.uy;
X#ifndef QUEST
X		} else {
X			int tmp = rooms[dogroom].fdoor;
X			    cnt = rooms[dogroom].doorct;
X
X			gx = gy = FAR;	/* random, far away */
X			while(cnt--){
X			    if(dist(gx,gy) >
X				dist(doors[tmp].x, doors[tmp].y)){
X					gx = doors[tmp].x;
X					gy = doors[tmp].y;
X				}
X				tmp++;
X			}
X			/* here gx == FAR e.g. when dog is in a vault */
X			if(gx == FAR || (gx == omx && gy == omy)){
X				gx = u.ux;
X				gy = u.uy;
X			}
X#endif
X		}
X		appr = (udist >= 9) ? 1 : (mtmp->mflee) ? -1 : 0;
X		if(after && udist <= 4 && gx == u.ux && gy == u.uy)
X			return(0);
X		if(udist > 1){
X			if(!IS_ROOM(levl[u.ux][u.uy].typ) || !rn2(4) ||
X			   whappr ||
X			   (mtmp->minvent && rn2((int) edog->apport)))
X				appr = 1;
X		}
X		/* if you have dog food he'll follow you more closely */
X		if(appr == 0){
X			obj = invent;
X			while(obj){
X				if(obj->otyp == TRIPE_RATION){
X					appr = 1;
X					break;
X				}
X				obj = obj->nobj;
X			}
X		}
X	} else	appr = 1;	/* gtyp != UNDEF */
X	if(mtmp->mconf) appr = 0;
X
X	if(gx == u.ux && gy == u.uy && (dogroom != uroom || dogroom < 0)) {
X	extern coord *gettrack();
X	register coord *cp;
X		cp = gettrack(omx,omy);
X		if(cp){
X			gx = cp->x;
X			gy = cp->y;
X		}
X	}
X
X	nix = omx;
X	niy = omy;
X	cnt = mfndpos(mtmp,poss,info,ALLOW_M | ALLOW_TRAPS);
X	chcnt = 0;
X	chi = -1;
X	for(i=0; i<cnt; i++){
X		nx = poss[i].x;
X		ny = poss[i].y;
X#ifdef WALKIES
X		/* if leashed, we drag him along. */
X		if(dist(nx, ny) > 4 && mtmp->mleashed) continue;
X#endif
X		if(info[i] & ALLOW_M) {
X			mtmp2 = m_at(nx,ny);
X			if(mtmp2)
X			    if(mtmp2->data->mlevel >= mdat->mlevel+2 ||
X			       mtmp2->data->mlet == 'c')
X				continue;
X			if(after) return(0); /* hit only once each move */
X
X			if(hitmm(mtmp, mtmp2) == 1 && rn2(4) &&
X			  mtmp2->mlstmv != moves &&
X			  hitmm(mtmp2,mtmp) == 2) return(2);
X			return(0);
X		}
X
X		/* dog avoids traps */
X		/* but perhaps we have to pass a trap in order to follow @ */
X		if((info[i] & ALLOW_TRAPS) && (trap = t_at(nx,ny))){
X			if(!trap->tseen && rn2(40)) continue;
X			if(rn2(10)) continue;
X		}
X
X		/* dog eschewes cursed objects */
X		/* but likes dog food */
X		obj = fobj;
X		while(obj){
X		    if(obj->ox != nx || obj->oy != ny)
X			goto nextobj;
X		    if(obj->cursed) goto nxti;
X		    if(obj->olet == FOOD_SYM &&
X			(otyp = dogfood(obj)) < MANFOOD &&
X			(otyp < ACCFOOD || edog->hungrytime <= moves)){
X			/* Note: our dog likes the food so much that he
X			might eat it even when it conceals a cursed object */
X			nix = nx;
X			niy = ny;
X			chi = i;
X		     eatobj:
X			edog->eattime =
X			    moves + obj->quan * objects[obj->otyp].oc_delay;
X			if(edog->hungrytime < moves)
X			    edog->hungrytime = moves;
X			edog->hungrytime +=
X			    5*obj->quan * objects[obj->otyp].nutrition;
X			mtmp->mconf = 0;
X			if(cansee(nix,niy))
X			    pline("%s ate %s.", Monnam(mtmp), doname(obj));
X			/* perhaps this was a reward */
X			if(otyp != CADAVER)
X			edog->apport += 200/(edog->dropdist+moves-edog->droptime);
X			delobj(obj);
X			goto newdogpos;
X		    }
X		nextobj:
X		    obj = obj->nobj;
X		}
X
X		for(j=0; j<MTSZ && j<cnt-1; j++)
X			if(nx == mtmp->mtrack[j].x && ny == mtmp->mtrack[j].y)
X				if(rn2(4*(cnt-j))) goto nxti;
X
X/* Some stupid C compilers cannot compute the whole expression at once. */
X		nearer = GDIST(nx,ny);
X		nearer -= GDIST(nix,niy);
X		nearer *= appr;
X		if((nearer == 0 && !rn2(++chcnt)) || nearer<0 ||
X			(nearer > 0 && !whappr &&
X				((omx == nix && omy == niy && !rn2(3))
X				|| !rn2(12))
X			)){
X			nix = nx;
X			niy = ny;
X			if(nearer < 0) chcnt = 0;
X			chi = i;
X		}
X	nxti:	;
X	}
Xnewdogpos:
X	if(nix != omx || niy != omy){
X		if(info[chi] & ALLOW_U){
X			(void) hitu(mtmp, d(mdat->damn, mdat->damd)+1);
X			return(0);
X		}
X		mtmp->mx = nix;
X		mtmp->my = niy;
X		for(j=MTSZ-1; j>0; j--) mtmp->mtrack[j] = mtmp->mtrack[j-1];
X		mtmp->mtrack[0].x = omx;
X		mtmp->mtrack[0].y = omy;
X	}
X#ifdef WALKIES
X	  /* an incredible kluge, but the only way to keep pooch near
X	   * after he spends time eating or in a trap, etc...
X	   */
X	  else  if(mtmp->mleashed && dist(omx, omy) > 4) mnexto(mtmp);
X#endif
X
X	if(mintrap(mtmp) == 2)	{		/* he died */
X#ifdef WALKIES
X		mtmp->mleashed = 0;
X#endif
X		return(2);
X	}
X	pmon(mtmp);
X	return(1);
X}
END_OF_dogmove.c
if test 7691 -ne `wc -c <dogmove.c`; then
    echo shar: \"dogmove.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f dothrow.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"dothrow.c\"
else
echo shar: Extracting \"dothrow.c\" \(6895 characters\)
sed "s/^X//" >dothrow.c <<'END_OF_dothrow.c'
X/*	SCCS Id: @(#)dothrow.c	2.3	88/02/02
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X
X/* Contains code for 't' (throw) */
X
X#include "hack.h"
X
Xextern struct obj *splitobj(), *addinv();
Xextern boolean hmon();
Xextern struct monst youmonst;
Xextern char *Doname();
X#ifdef KAA
Xextern char *xname();
X#endif
X
Xstruct monst *bhit(), *boomhit();
Xdothrow()
X{
X	register struct obj *obj;
X
X	obj = getobj("#)", "throw");   /* it is also possible to throw food */
X				       /* (or jewels, or iron balls ... ) */
X	if(!obj || !getdir(1))	       /* ask "in what direction?" */
X		return(0);
X	if(obj->owornmask & (W_ARMOR | W_RING)){
X		pline("You can't throw something you are wearing.");
X		return(0);
X	}
X#ifdef KAA
X	if(obj->otyp == ENORMOUS_ROCK && u.usym != '9') {
X		pline("It's too heavy.");
X		return(1);
X	}
X	if(!u.dx && !u.dy && !u.dz) {
X		pline("You cannot throw an object at yourself.");
X		return(0);
X	}
X#endif
X	u_wipe_engr(2);
X
X	if(obj == uwep){
X		if(obj->cursed){
X			pline("Your weapon is welded to your hand.");
X			return(1);
X		}
X		if(obj->quan > 1)
X			setuwep(splitobj(obj, 1));
X		else
X			setuwep((struct obj *) 0);
X	}
X	else if(obj->quan > 1)
X		(void) splitobj(obj, 1);
X	freeinv(obj);
X	return(throwit(obj));
X}
X
Xthrowit(obj)
X	register struct obj *obj;
X{
X	register struct monst *mon;
X
X	if(u.uswallow) {
X		mon = u.ustuck;
X		bhitpos.x = mon->mx;
X		bhitpos.y = mon->my;
X	} else if(u.dz) {
X	  if(u.dz < 0) {
X	    pline("%s hits the ceiling, then falls back on top of your head.",
X		Doname(obj));		/* note: obj->quan == 1 */
X	    if(obj->olet == POTION_SYM)
X		potionhit(&youmonst, obj);
X	    else {
X		if(uarmh) pline("Fortunately, you are wearing a helmet!");
X		losehp(uarmh ? 1 : rnd((int)(obj->owt)), "falling object");
X		dropy(obj);
X	    }
X	  } else hitfloor(obj);
X	  return(1);
X
X	} else if(obj->otyp == BOOMERANG) {
X		mon = boomhit(u.dx, u.dy);
X		if(mon == &youmonst) {		/* the thing was caught */
X			(void) addinv(obj);
X			return(1);
X		}
X	} else {
X		if(obj->otyp == PICK_AXE && shkcatch(obj))
X		    return(1);
X
X		mon = bhit(u.dx, u.dy, (obj->otyp == ICE_BOX) ? 1 :
X			(!Punished || obj != uball) ? 8 : !u.ustuck ? 5 : 1,
X			obj->olet,
X			(int (*)()) 0, (int (*)()) 0, obj);
X	}
X	if(mon) {
X		/* awake monster if sleeping */
X		wakeup(mon);
X		if(thitmonst(mon, obj)) return(1);
X	}
X	if(!u.uswallow)  {
X		/* the code following might become part of dropy() */
X		if(obj->otyp == CRYSKNIFE)
X			obj->otyp = WORM_TOOTH;
X		obj->ox = bhitpos.x;
X		obj->oy = bhitpos.y;
X		obj->nobj = fobj;
X		fobj = obj;
X		/* prevent him from throwing articles to the exit and escaping */
X		/* subfrombill(obj); */
X		stackobj(obj);
X		if(Punished && obj == uball &&
X			(bhitpos.x != u.ux || bhitpos.y != u.uy)){
X			freeobj(uchain);
X			unpobj(uchain);
X			if(u.utrap){
X				if(u.utraptype == TT_PIT)
X					pline("The ball pulls you out of the pit!");
X#ifdef SPIDERS
X				else if(u.utraptype == TT_WEB)  {
X					pline("The ball pulls you out of the web!");
X					pline("The web is destroyed!");
X					deltrap(t_at(u.ux,u.uy));
X				}
X#endif
X				else  {
X				register long side =
X					rn2(3) ? LEFT_SIDE : RIGHT_SIDE;
X				pline("The ball pulls you out of the bear trap.");
X				pline("Your %s leg is severely damaged.",
X					(side == LEFT_SIDE) ? "left" : "right");                                set_wounded_legs(side, 500+rn2(1000));
X				losehp(2, "thrown ball");
X				}
X				u.utrap = 0;
X			}        
X			unsee();
X			uchain->nobj = fobj;
X			fobj = uchain;
X			u.ux = uchain->ox = bhitpos.x - u.dx;
X			u.uy = uchain->oy = bhitpos.y - u.dy;
X			setsee();
X			(void) inshop();
X		}
X		if(cansee(bhitpos.x, bhitpos.y)) prl(bhitpos.x,bhitpos.y);
X	}  else  
X		mpickobj(u.ustuck,obj);
X	return(1);
X}
X
Xhitfloor(obj)
X	register struct obj *obj;
X{
X	pline("%s hits the floor.", Doname(obj));
X	if(obj->otyp == EXPENSIVE_CAMERA) {
X		pline("It is shattered in a thousand pieces!");
X		obfree(obj, Null(obj));
X#ifdef RPH
X	} else	if(obj->otyp == MIRROR) {
X	    	pline ("The mirror shatters.  That's seven years bad luck!");
X		obfree(obj, Null(obj));
X		change_luck(-2);
X#endif	
X	} else	if(obj->otyp == EGG) {
X		pline("\"Splash!\"");
X		obfree(obj, Null(obj));
X#ifdef KAA
X	} else	if(obj->otyp == CREAM_PIE) {
X		pline("What a mess!");
X		obfree(obj, Null(obj));
X#endif
X	} else	if(obj->olet == POTION_SYM) {
X		pline("The flask breaks, and you smell a peculiar odor ...");
X		potionbreathe(obj);
X		obfree(obj, Null(obj));
X	} else
X		dropy(obj);
X}
X
Xthitmonst(mon, obj)
X	register struct monst *mon;
X	register struct obj   *obj;
X{
X	register int	tmp;
X
X	if(obj->olet == WEAPON_SYM) {
X		tmp = -1+u.ulevel+mon->data->ac+abon();
X		if(obj->otyp < DART) {
X			if(!uwep ||
X			    uwep->otyp != obj->otyp+(BOW-ARROW))
X				tmp -= 4;
X			else {
X				tmp += uwep->spe;
X			}
X		} else
X		if(obj->otyp == BOOMERANG) tmp += 4;
X		tmp += obj->spe;
X		if(u.uswallow || tmp >= rnd(20)) {
X			if(hmon(mon,obj,1) == TRUE){
X			  /* mon still alive */
X#ifndef NOWORM
X			  cutworm(mon,bhitpos.x,bhitpos.y,obj->otyp);
X#endif
X			} else mon = 0;
X			/* weapons thrown disappear sometimes */
X			if(obj->otyp < BOOMERANG && rn2(3)) {
X				/* check bill; free */
X				obfree(obj, (struct obj *) 0);
X				return(1);
X			}
X		} else miss(objects[obj->otyp].oc_name, mon);
X	} else if(obj->otyp == HEAVY_IRON_BALL) {
X		tmp = -1+u.ulevel+mon->data->ac+abon();
X		if(!Punished || obj != uball) tmp += 2;
X		if(u.utrap) tmp -= 2;
X		if(u.uswallow || tmp >= rnd(20)) {
X			if(hmon(mon,obj,1) == FALSE)
X				mon = 0;	/* he died */
X		} else miss("iron ball", mon);
X#ifdef KAA
X	} else if (obj->otyp == ENORMOUS_ROCK) {
X		tmp = 15+mon->data->ac;  /* Very likely to hit! */
X		if (hmon(mon, obj, 1) == FALSE)	mon=0;
X		else miss("enormous rock",mon);
X	} else if(obj->otyp == CREAM_PIE &&
X		(u.ulevel > rn2(10)) || u.ustuck == mon) {
X		pline("The cream pie splashes over %s%s!",monnam(mon),
X			index("aEfgy",mon->data->mlet) ? "" : "'s face");
X		obfree(obj, (struct obj *) 0);
X		if(mon->msleep) mon->msleep = 0;
X		setmangry(mon);
X		mon->mcansee = 0;
X		mon->mblinded += rnd(25);
X		if (mon->mblinded <= 0) mon->mblinded = 127;
X		return(1);
X#endif
X	} else if(obj->olet == POTION_SYM && u.ulevel > rn2(15)) {
X		potionhit(mon, obj);
X		return(1);
X	} else {
X		pline("The %s misses %s.",xname(obj), 
X		cansee(bhitpos.x,bhitpos.y) ? monnam(mon) : "it");
X
X		if(obj->olet == FOOD_SYM && mon->data->mlet == 'd')
X			if(tamedog(mon,obj)) return(1);
X		if(obj->olet == GEM_SYM && mon->data->mlet == 'u' &&
X			!mon->mtame){
X			char buf[BUFSZ];
X			char *nogood = " is not interested in your junk.";
X			char *addluck = " graciously accepts your gift.";
X	
X			strcpy(buf,Monnam(mon));
X 
X			if(obj->dknown &&
X			   objects[obj->otyp].oc_name_known)  {
X				if(objects[obj->otyp].g_val > 0)  {
X					change_luck(5);
X					strcat(buf,addluck);
X				}  else
X					strcat(buf,nogood);
X			}  else  {  /* value unknown to @ */
X				change_luck(1);
X				strcat(buf,addluck);
X			}
X			pline(buf);
X			mpickobj(mon, obj);
X			rloc(mon);
X			return(1);
X		}
X	}
X	return(0);
X}
END_OF_dothrow.c
if test 6895 -ne `wc -c <dothrow.c`; then
    echo shar: \"dothrow.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f end.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"end.c\"
else
echo shar: Extracting \"end.c\" \(8023 characters\)
sed "s/^X//" >end.c <<'END_OF_end.c'
X/*	SCCS Id: @(#)end.c	2.3	87/12/16
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X
X#include <stdio.h>
X#include <signal.h>
X#include "hack.h"
X#define	Sprintf	(void) sprintf
Xextern char plname[], pl_character[], SAVEF[];
X
Xxchar maxdlevel = 1;
Xint done_stopprint;
Xint done_hup;
X
X
Xdone1()
X{
X	(void) signal(SIGINT,SIG_IGN);
X#if defined(WIZARD) && defined(UNIX) && !defined(KJSMODS)
X	if(wizard) {
X	    pline("Dump core?");
X	    if(readchar() == 'y') {
X		(void) signal(SIGINT,done1);
X		abort();
X	    }
X	}
X#endif
X	pline("Really quit?");
X	if(readchar() != 'y') {
X		(void) signal(SIGINT,done1);
X		clrlin();
X		(void) fflush(stdout);
X		if(multi > 0) nomul(0);
X		return(0);
X	}
X	done("quit");
X	/* NOTREACHED */
X}
X
Xdone_intr(){
X	done_stopprint++;
X	(void) signal(SIGINT, SIG_IGN);
X#ifdef UNIX
X	(void) signal(SIGQUIT, SIG_IGN);
X#endif
X}
X
X#ifdef UNIX
Xdone_hangup(){
X	done_hup++;
X	(void) signal(SIGHUP, SIG_IGN);
X	done_intr();
X}
X#endif
X
Xdone_in_by(mtmp)
Xregister struct monst *mtmp;
X{
X	static char buf[BUFSZ];
X	extern char *eos(), *shkname();
X
X	pline("You die ...");
X	Sprintf(buf, "");
X	if (mtmp->minvis)
X		Sprintf(eos(buf), "invisible ");
X	if (Hallucination)
X		Sprintf(eos(buf), "hallucinogen-distorted ");
X
X	if(mtmp->data->mlet == ' ') {
X		register char *gn = (char *) mtmp->mextra;
X		if (!Hallucination && !mtmp->minvis && *gn)
X			Sprintf(eos(buf), "the ");
X		Sprintf(eos(buf), (*gn ? "ghost of %s" : "ghost%s"), gn);
X	} else if(mtmp->isshk) {
X		Sprintf(eos(buf), "%s %s, the shopkeeper)",
X			(rn2(2) ? "Mr." : "Ms."), shkname(mtmp));
X	} else Sprintf(eos(buf), "%s", mtmp->data->mname);
X	if (mtmp->mnamelth) Sprintf(eos(buf), " called %s", NAME(mtmp));
X	killer = buf;
X	done("died");
X}
X
X/*VARARGS1*/
Xboolean panicking;
X
Xpanic(str,a1,a2,a3,a4,a5,a6)
Xchar *str;
X{
X	if(panicking++) abort();    /* avoid loops - this should never happen*/
X				    /* was exit(1) */
X	home(); cls();
X	puts(" Suddenly, the dungeon collapses.");
X#ifdef WIZARD
X	pline("Report error to %s and it may be possible to rebuild.",WIZARD);
X	more();
X	(void) sprintf (SAVEF, "%s.e", SAVEF);
X	dosave0(0);
X#endif	
X	fputs(" ERROR:  ", stdout);
X	printf(str,a1,a2,a3,a4,a5,a6);
X	more();				/* contains a fflush() */
X#ifdef WIZARD
X# ifdef UNIX
X	if (wizard)	abort();	/* generate core dump */
X# endif
X#endif
X	done("panicked");
X}
X
X/* called with arg "died", "drowned", "escaped", "quit", "choked", "panicked",
X   "burned", "starved" or "tricked" */
X/* Be careful not to call panic from here! */
Xdone(st1)
Xregister char *st1;
X{
X#ifdef DIAGS
X	char	c;
X#endif
X#ifdef WIZARD
X	extern char	*nomovemsg;
X
X	if(wizard && index("bcds", *st1)){
X		char buf[BUFSZ];
X		pline("Die? ");
X		getlin(buf);
X		if(index("yY",buf[0])) goto die;
X		u.uswldtim = 0;
X		if(u.uhpmax < 0) u.uhpmax = 100;	/* arbitrary */
X		u.uhp = u.uhpmax;
X		pline("Ok, so you don't die.");
X		nomovemsg = "You survived that attempt on your life.";
X		flags.move = 0;
X		if(multi > 0) multi = 0; else multi = -1;
X		flags.botl = 1;
X		return;
X	}
X#endif /* WIZARD /**/
Xdie:
X	(void) signal(SIGINT, done_intr);
X#ifdef UNIX
X	(void) signal(SIGQUIT, done_intr);
X	(void) signal(SIGHUP, done_hangup);
X#endif
X	if(*st1 == 'q' && u.uhp < 1){
X		st1 = "died";
X		killer = "quit while already on Charon's boat";
X	}
X	if(*st1 == 's') killer = "starvation"; else
X	if(*st1 == 'd' && st1[1] == 'r') killer = "drowning"; else
X	if(*st1 == 'p') killer = "panic"; else
X	if(*st1 == 't') killer = "trickery"; else
X	if(!index("bcd", *st1)) killer = st1;
X	paybill();
X	clearlocks();
X	if(flags.toplin == 1) more();
X#ifdef DIAGS
X	pline("Do you want to have your possessions identified? [Yynq] ");
X	/* New dump format by maartenj@cs.vu.nl */
X	if ((c = readchar()) == 'y' || c == 'Y') {
X	    struct obj *obj;
X
X	    for(obj = invent; obj && !done_stopprint; obj = obj->nobj) {
X		objects[obj->otyp].oc_name_known = 1;
X# ifdef KAA
X		obj->known = 1;
X		if (obj->olet != WEAPON_SYM) obj->dknown = 1;
X# else
X		obj->known = obj->dknown = 1;
X# endif /* KAA */
X	    }
X	    doinv((char *) 0);
X	}
X	if (c == 'q' || c == 'Y')  done_stopprint++;
X#endif
X	if(index("bcds", *st1)){
X#ifdef WIZARD
X	    if(wizard) {
X		char buf[BUFSZ];
X		pline("Save bones? ");
X		getlin(buf);
X		if(buf[0] == 'y') savebones();
X	    }  else
X#endif
X		savebones();
X		if(!flags.notombstone) outrip();
X	}
X	if(*st1 == 'c') killer = st1;		/* after outrip() */
X#ifdef KJSMODS
X	if(with_amulet()) (void) strcat(killer," (with amulet)");
X#endif 
X	settty((char *) 0);	/* does a clear_screen() */
X	if(!done_stopprint)
X	    printf("Goodbye %s %s...\n\n", (Badged) ? "Officer" : pl_character, plname);
X	{ long int tmp;
X	  tmp = u.ugold - u.ugold0;
X	  if(tmp < 0)
X		tmp = 0;
X	  if(*st1 == 'd' || *st1 == 'b')
X		tmp -= tmp/10;
X	  u.urexp += tmp;
X	  u.urexp += 50 * maxdlevel;
X	  if(maxdlevel > 20)
X		u.urexp += 1000*((maxdlevel > 30) ? 10 : maxdlevel - 20);
X	}
X	if(*st1 == 'e') {
X		extern struct monst *mydogs;
X		register struct monst *mtmp;
X		register struct obj *otmp;
X#ifdef DGKMOD
X		long i;
X#else
X		register int i;
X#endif
X		register unsigned worthlessct = 0;
X		boolean has_amulet = FALSE;
X
X		killer = st1;
X		keepdogs();
X		mtmp = mydogs;
X		if(mtmp) {
X			if(!done_stopprint) printf("You");
X			while(mtmp) {
X				if(!done_stopprint)
X					printf(" and %s", monnam(mtmp));
X				if(mtmp->mtame)
X					u.urexp += mtmp->mhp;
X				mtmp = mtmp->nmon;
X			}
X			if(!done_stopprint)
X		    printf("\nescaped from the dungeon with %ld points,\n",
X			u.urexp);
X		} else
X		if(!done_stopprint)
X		  printf("You escaped from the dungeon with %ld points,\n",
X		    u.urexp);
X		for(otmp = invent; otmp; otmp = otmp->nobj) {
X			if(otmp->olet == GEM_SYM){
X				objects[otmp->otyp].oc_name_known = 1;
X#ifdef DGKMOD
X				i = (long) otmp->quan *
X					objects[otmp->otyp].g_val;
X#else
X				i = otmp->quan*objects[otmp->otyp].g_val;
X#endif
X				if(i == 0) {
X					worthlessct += otmp->quan;
X					continue;
X				}
X				u.urexp += i;
X#ifndef DGKMOD
X				if(!done_stopprint)
X				  printf("\t%s (worth %d Zorkmids),\n",
X#else
X				printf("        %s (worth %ld Zorkmids),\n",
X#endif
X				    doname(otmp), i);
X			} else if(otmp->olet == AMULET_SYM) {
X				otmp->known = 1;
X				i = (otmp->spe < 0) ? 2 : 5000;
X				u.urexp += i;
X#ifndef DGKMOD
X				if(!done_stopprint)
X				  printf("\t%s (worth %d Zorkmids),\n",
X#else
X				printf("        %s (worth %d Zorkmids),\n",
X#endif
X				    doname(otmp), i);
X				if(otmp->spe >= 0) {
X					has_amulet = TRUE;
X					killer = "escaped (with amulet)";
X				}
X			}
X		}
X		if(worthlessct)
X#ifndef DGKMOD
X		  if(!done_stopprint)
X		    printf("\t%u worthless piece%s of colored glass,\n",
X#else
X		  printf("        %u worthless piece%s of colored glass,\n",
X#endif
X			worthlessct, plur(worthlessct));
X		if(has_amulet) u.urexp *= 2;
X	} else
X		if(!done_stopprint)
X		  printf("You %s on dungeon level %d with %ld points,\n",
X		    st1, dlevel, u.urexp);
X	if(!done_stopprint)
X	  printf("and %ld piece%s of gold, after %ld move%s.\n",
X	    u.ugold, plur(u.ugold), moves, plur(moves));
X	if(!done_stopprint)
X  printf("You were level %u with a maximum of %d hit points when you %s.\n",
X	    u.ulevel, u.uhpmax, st1);
X	if(*st1 == 'e' && !done_stopprint){
X		getret();	/* all those pieces of coloured glass ... */
X		cls();
X	}
X#ifdef MSDOSCOLOR
X	end_screen();
X#endif
X#ifdef WIZARD
X	if(!wizard)
X#endif
X		topten();
X	if(done_stopprint) printf("\n\n");
X#ifdef APOLLO
X	getret();
X#endif
X	exit(0);
X}
Xclearlocks(){
X#ifdef DGK
X	eraseall(levels, alllevels);
X	if (ramdisk)
X		eraseall(permbones, alllevels);
X#else
X# ifdef UNIX
Xregister x;
X	(void) signal(SIGHUP,SIG_IGN);
X	for(x = maxdlevel; x >= 0; x--) {
X		glo(x);
X		(void) unlink(lock);	/* not all levels need be present */
X	}
X# endif
X#endif
X}
X
X#ifdef NOSAVEONHANGUP
Xhangup()
X{
X	(void) signal(SIGINT, SIG_IGN);
X	clearlocks();
X	exit(1);
X}
X#endif
X
X/* it is the callers responsibility to check that there is room for c */
Xcharcat(s,c) register char *s, c; {
X	while(*s) s++;
X	*s++ = c;
X	*s = 0;
X}
X
X#ifdef KJSMODS
Xwith_amulet()
X{
X	register struct obj *otmp;
X	for(otmp = invent; otmp; otmp = otmp->nobj) {
X		if(otmp->olet == AMULET_SYM) { 
X			if(otmp->spe >= 0) return(1);
X		}
X	}
X	return(0);
X}
X#endif 
END_OF_end.c
if test 8023 -ne `wc -c <end.c`; then
    echo shar: \"end.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f fountain.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"fountain.c\"
else
echo shar: Extracting \"fountain.c\" \(8213 characters\)
sed "s/^X//" >fountain.c <<'END_OF_fountain.c'
X/*	SCCS Id: @(#)fountain.c	2.3	88/01/21
X/* fountain.c  v 1.4.4 */
X
X/*
X * Revision 1.4.4  88/02/11  08:31:00  M. Stephenson
X * Implemented "coins" fixes by woodbury@bme.unc.edu
X * Fixed minor bugs.
X *
X * Revision 1.4.3  87/11/25  19:16:00  M. Stephenson
X * Implemented levitation bug fixes.
X *
X * Revision 1.4.3  87/11/25  19:16:00  M. Stephenson
X * Implemented levitation bug fixes.
X *
X * Revision 1.4.2  87/10/19  11:48:00  M. Stephenson
X * Implementation of KJS bug fixes.
X *
X * Revision 1.4.1  87/05/20  11:53:00  M. Stephenson
X * Implementation of KAA bug fixes.
X *
X * Revision 1.4    87/05/04  17:39:00  M. Stephenson
X * Integration of independent modifications
X *
X * Revision 1.3    87/03/02            Eric Backus
X * Rearranged, and dipfountain added
X * 
X * Revision 1.2    87/03/01  13:59:59  gil
X * patches
X * 
X * Revision 1.1    87/02/11  15:14:10  gil
X * Initial revision
X *
X */
X
X/* Code for drinking from fountains.   */
X/* Scott R. Turner, srt@ucla, 10/27/86 */
X
X#include "hack.h"
X
Xextern struct monst *mkmon_at();
Xextern struct obj *mkobj_at();
Xextern char genocided[];
X
X#ifdef FOUNTAINS
X#define somex() ((int)(rand()%(croom->hx-croom->lx+1))+croom->lx)
X#define somey() ((int)(rand()%(croom->hy-croom->ly+1))+croom->ly)
X
Xdowatersnakes() /* Fountain of snakes! */ {
X	register int num = rnd(6);
X	if (!index(genocided, 'S')) {
X
X		pline("Good Lord!  An endless stream of snakes pours forth!");
X		while(num-- > 0) (void) mkmon_at('S',u.ux,u.uy);
X	} else
X		pline("The fountain bubbles furiously for a moment, then calms.");
X}
X
Xdowaterdemon() /* Water demon */ {
Xregister struct monst *mtmp;
X
X	if((mtmp = mkmon_at('&',u.ux,u.uy))) {
X	    pline("You have unleashed a water demon!");
X
X	/* Give those on low levels a (slightly) better chance of survival */
X	    if ( rnd(100) > (80 + dlevel)) {
X		pline("Grateful for his release, he grants you a wish!");
X		makewish();
X		mondied(mtmp);
X	    }
X	}
X}
X
Xdowaternymph() /* Water Nymph */ {
X	register struct monst *mtmp;
X	if((mtmp = mkmon_at('N',u.ux,u.uy))) {
X
X		pline("You have attracted a water nymph!");
X		mtmp->msleep = 0;
X	} else
X		pline("A large bubble rises to the surface and pops.");
X}
X
X#include	"mkroom.h"
X
Xdogushforth() /* Gushing forth in this room */ {
Xregister int num = rnd(10);
Xregister xchar mx,my;
Xregister int tryct = 0;
Xregister int uroom = inroom(u.ux, u.uy);
Xregister struct mkroom *croom = &rooms[uroom];
Xregister int madepool = 0;
X
X	if(croom->hx < 0 || has_upstairs(croom) ||
X	   has_dnstairs(croom))  {
X		pline("Your thirst is quenched.");
X		return;
X	}
X	while(num--) {
X	    do {
X		if(++tryct > 200)  {
X		    if(madepool)
X			pline("Water gushes forth from the overflowing fountain!");
X		    else
X			pline("Your thirst is quenched.");
X		    return;
X		}
X		mx = somex();
X		my = somey();
X	    } while(nexttodoor(mx,my) || !((mx+my)%2) ||
X		    (mx == u.ux && my == u.uy) ||
X		    (IS_POOL(levl[mx][my].typ)));
X		       
X	    /* Put a pool at mx, my */
X		     
X	    levl[mx][my].typ = POOL;
X	    atl(mx,my,POOL_SYM);
X	    madepool = 1;
X	}
X
X	pline("Water gushes forth from the overflowing fountain!");
X}
X
Xdofindgem() /* Find a gem in the sparkling waters. */ {
X
X	if (!Blind) pline("You spot a gem in the sparkling waters!");
X	mkobj_at('*',u.ux,u.uy);
X}
X
Xdryup(){
X	if (!rn2(3) && (levl[u.ux][u.uy].typ == FOUNTAIN)) {
X		pline("The fountain dries up!");
X		levl[u.ux][u.uy].typ = ROOM;
X		if(Invis) newsym(u.ux, u.uy);
X	}
X}
X
Xdrinkfountain() {
X
X	/* What happens when you drink from a fountain? */
X	register int fate = rnd(30);
X
X	if(Levitation) 	pline("You are floating high above the fountain.");
X	else if (fate < 10) {
X		pline("The cool draught refreshes you.");
X		lesshungry(rnd(10));
X	} else {
X	    switch (fate) {
X
X		case 20: /* Foul water */
X
X			pline("The water is foul!  You gag and vomit.");
X			morehungry(rnd(20)+10);
X			if(Sick)  {
X				Sick = 0;
X				pline("What a relief!");
X			}
X			break;
X
X		case 21: /* Poisonous */
X
X			pline("The water is contaminated!");
X			if (Poison_resistance) {
X			   pline("Perhaps it is run off from the nearby orange farm.");
X			   losehp(rnd(4),"unrefrigerated orange juice");
X			   break;
X			}
X			losestr(rn1(4,3));
X			losehp(rnd(10),"contaminated water");
X			break;
X	
X		case 22: /* Fountain of snakes! */
X			dowatersnakes();
X			break;
X
X		case 23: /* Water demon */
X			dowaterdemon();
X			break;
X
X		case 24: /* Curse an item... */ {
X			register struct obj *obj;
X
X			pline("This water's no good!");
X			morehungry(rnd(20)+10);
X			for(obj = invent; obj ; obj = obj->nobj)
X				if (!rn2(5))	obj->cursed++;
X			break;
X			}
X			 
X		case 25: /* See invisible */
X
X			pline("You see an image of someone stalking you.");
X			pline("But it disappears.");
X			HSee_invisible |= INTRINSIC;
X			break;
X
X		case 26: /* See Monsters */ {
X			register struct monst *mtmp;
X
X			  if(!fmon) pline("You feel oddly disturbed.");
X			  else {
X			    cls();
X			    for(mtmp = fmon; mtmp; mtmp = mtmp->nmon)
X				if(mtmp->mx > 0)
X				    at(mtmp->mx,mtmp->my,mtmp->data->mlet);
X			    prme();
X			    pline("You sense the presence of monsters.");
X			    more();
X			    docrt();
X			  }
X			}
X			break;
X
X		case 27: /* Find a gem in the sparkling waters. */
X			dofindgem();
X			break;
X
X		case 28: /* Water Nymph */
X			dowaternymph();
X			break;
X
X		case 29: /* Scare */ {
X			register struct monst *mtmp;
X
X			pline("This water gives you bad breath!");
X			for(mtmp = fmon; mtmp; mtmp = mtmp->nmon) 
X				mtmp->mflee = 1;
X			}
X			break;
X
X		case 30: /* Gushing forth in this room */
X			dogushforth();
X			break;
X		default:
X			break;
X	    }
X	}
X	dryup();
X}
X
Xdipfountain(obj)
Xregister struct obj *obj;
X{
X	register int fate = rnd(30);
X
X	if(Levitation) 	pline("You are floating high above the fountain.");
X	else if(fate<10)
X		if(!obj->rustfree &&
X			/* Only swords affected here */
X			(obj->otyp == LONG_SWORD ||
X			obj->otyp == KATANA ||
X			obj->otyp == BROAD_SWORD ||
X			obj->otyp == SHORT_SWORD ||
X			obj->otyp == TWO_HANDED_SWORD)) {
X			if(obj->spe > -6) {
X				pline("Your weapon rusts somewhat.");
X				obj->spe--;
X			} else pline("Your weapon looks quite rusted.");
X		} else pline("Well, it looks wet now.");
X	else if(fate<14)
X		if(obj->otyp == LONG_SWORD
X#ifndef RPH
X		   && !strcmp(ONAME(obj), "Excalibur")
X#endif
X		) {
X			/* The lady of the lake acts! - Eric Backus */
X			/* Be *REAL* nice to him */
X	pline("A murky hand from the depths reaches up to bless the sword.");
X	pline("As the hand retreats, the fountain disappears!");
X#ifndef RPH
X			if(obj->spe < 5) obj->spe = 5;
X#else
X			/* otherwise +rnd(10) / +5 "Super"sword */
X			oname(obj, "Excalibur");
X#endif
X#ifdef KAA
X			obj->dknown = 1;	/* blessed */
X#endif
X			obj->cursed = 0;
X			obj->rustfree = 1;
X			levl[u.ux][u.uy].typ = ROOM;
X			if(Invis) newsym(u.ux, u.uy);
X			return(0);
X		} else pline ("Well, it looks wet now.");
X	else {
X	    switch (fate) {
X		case 16: /* Curse the item */
X			pline("Well, it looks wet now.");
X			obj->cursed = 1;
X			break;
X		case 17:
X		case 18:
X		case 19:
X		case 20: /* Uncurse the item */
X			if(obj->cursed) {
X			    pline("The water glows for a moment.");
X			    obj->cursed = 0;
X			} else {
X			    pline("A feeling of loss comes over you.");
X			}
X			break;
X		case 21: /* Water Demon */
X			dowaterdemon();
X			break;
X		case 22: /* Water Nymph */
X			dowaternymph();
X			break;
X		case 23: /* An Endless Stream Of Snakes */
X			dowatersnakes();
X			break;
X		case 24: /* Find a gem */
X			dofindgem();
X			break;
X		case 25: /* Water gushes forth */
X			dogushforth();
X			break;
X		case 26: /* Strange feeling */
X			pline("A strange tingling runs up your arm.");
X			break;
X		case 27: /* Strange feeling */
X			pline("You feel a sudden chill.");
X			break;
X		case 28: /* Strange feeling */
X		pline("An urge to take a bath overwhelms you.");
X			if (u.ugold > 10) {
X			     	u.ugold -= somegold()/10;
X			  pline("You lost some of your gold in the fountain!");
X	 		}
X			break;
X		case 29: /* You see coins */
X
X		/* We make fountains have more coins the closer you are to the
X		 * surface.  After all, there will have been more people going
X		 * by.  Just like a shopping mall!  Chris Woodbury  */
X
X			mkgold((long)(rnd((MAXLEVEL-dlevel)*2)+5),u.ux,u.uy);
X		pline("Far below you, you see coins glistening in the water.");
X			break;
X		default:
X			break;
X	    }
X	}
X	dryup();
X	return(0);
X}
X#endif
END_OF_fountain.c
if test 8213 -ne `wc -c <fountain.c`; then
    echo shar: \"fountain.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f hack.h -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"hack.h\"
else
echo shar: Extracting \"hack.h\" \(1653 characters\)
sed "s/^X//" >hack.h <<'END_OF_hack.h'
X/*	SCCS Id: @(#)hack.h	2.3	87/12/12
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X
X#ifndef HACK_H
X#define HACK_H
X
X#ifdef __TURBOC__
X/* work around the case-insensitivity of the DOS linker */
X#define Amonnam Amonnam_
X#define Xmonnam Xmonnam_
X#define Monnam Monnam_
X#define POISONOUS POISONOUS_
X#define Doname Doname_
X#define Tmp_at Tmp_at_
X/* rename the next two functions because they clash with the Turbo C library */
X#define getdate getdate_
X#define itoa itoa_
X#endif
X
X#include "extern.h"
X
X#define	Null(type)	((struct type *) 0)
X
X#include	"objclass.h"
X
Xtypedef struct {
X	xchar x,y;
X} coord;
X
Xextern coord bhitpos;	/* place where thrown weapon falls to the ground */
X
X#include	"monst.h"	/* uses coord */
X#include	"gold.h"
X#include	"trap.h"
X#include	"flag.h"
X
X#define	plur(x)	(((x) == 1) ? "" : "s")
X#define min(x,y) ((x) < (y) ? (x) : (y))
X
X#define	BUFSZ	256	/* for getlin buffers */
X#define	PL_NSIZ	32	/* name of player, ghost, shopkeeper */
X
X#include	"rm.h"
X
X#define Inhell		(dlevel >= 30)
X#define	newstring(x)	(char *) alloc((unsigned)(x))
X
X#ifdef SPELLS
X#define	NO_SPELL	0
X#endif
X
X#define	TELL	1
X#define NOTELL	0
X
X#define ON 1
X#define OFF 0
X
X#ifdef GENIX
X#define DIST	jhndist
X/*	genix compiler chokes on DIST macro below - jhn*/
X#else
X#define DIST(x1,y1,x2,y2)       (((x1)-(x2))*((x1)-(x2)) + ((y1)-(y2))*((y1)-(y2)))
X#endif
X
X#define	PL_CSIZ		20	/* sizeof pl_character */
X#ifdef HARD
X#define	MAX_CARR_CAP	120	/* so that boulders can be heavier */
X#else
X#define	MAX_CARR_CAP	500
X#endif
X#ifdef RPH
X#define	MAXLEVEL	60
X#else
X#define	MAXLEVEL	40
X#endif
X#define	FAR	(COLNO+2)	/* position outside screen */
X
X#endif /* HACK_H /**/
END_OF_hack.h
if test 1653 -ne `wc -c <hack.h`; then
    echo shar: \"hack.h\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f mkshop.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"mkshop.c\"
else
echo shar: Extracting \"mkshop.c\" \(7297 characters\)
sed "s/^X//" >mkshop.c <<'END_OF_mkshop.c'
X/*	SCCS Id: @(#)mkshop.c	2.3	87/12/12
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X
X/*
X * Entry points:
X *	mkroom() -- make and stock a room of a given type
X *	nexttodoor() -- return TRUE if adjacent to a door
X *	has_dnstairs() -- return TRUE if given room has a down staircase
X *	has_upstairs() -- return TRUE if given room has an up staircase
X *	dist2() -- Euclidean square-of-distance function
X *	courtmon() -- generate a court monster
X *
X * (note: this module should become mkroom.c in the next major release)
X */
X#ifndef QUEST
X#include "hack.h"
X#include "mkroom.h"
Xextern struct monst *makemon();
Xextern struct permonst pm_soldier;
Xextern struct obj *mkobj_at(), *mksobj_at();
Xextern void stock_room();
Xextern int nroom;
X
Xstatic boolean
Xisbig(sroom)
Xregister struct mkroom *sroom;
X{
X	register int area = (sroom->hx - sroom->lx) * (sroom->hy - sroom->ly);
X	return( area > 20 );
X}
X
Xvoid
Xmkroom(roomtype)
X/* make and stock a room of a given type */
Xint	roomtype;
X{
X    void mkshop(), mkzoo(), mkswamp();
X
X    if (roomtype >= SHOPBASE)
X	mkshop();	/* someday, we should be able to specify shop type */
X    else switch(roomtype)
X    {
X    case COURT: mkzoo(COURT); break;
X    case ZOO: mkzoo(ZOO); break;
X    case BEEHIVE: mkzoo(BEEHIVE); break;
X    case MORGUE: mkzoo(MORGUE); break;
X    case BARRACKS: mkzoo(BARRACKS); break;
X    case SWAMP: mkswamp(); break;
X    default:	impossible("Tried to make a room of type %d.", roomtype);
X    }
X}
X
Xstatic void
Xmkshop(){
Xregister struct mkroom *sroom;
Xint roomno, i = -1;
X#ifdef WIZARD
Xextern char *getenv();
X
X	/* first determine shoptype */
X	if(wizard){
X		register char *ep = getenv("SHOPTYPE");
X		if(ep){
X			if(*ep == 'z' || *ep == 'Z'){
X				mkzoo(ZOO);
X				return;
X			}
X			if(*ep == 'm' || *ep == 'M'){
X				mkzoo(MORGUE);
X				return;
X			}
X			if(*ep == 'b' || *ep == 'B'){
X				mkzoo(BEEHIVE);
X				return;
X			}
X#ifdef NEWCLASS
X			if(*ep == 't' || *ep == 'T'){
X				mkzoo(COURT);
X				return;
X			}
X#endif
X#ifdef SAC
X			if(*ep == '3'){
X				mkzoo(BARRACKS);
X				return;
X			}
X#endif /* SAC */
X			if(*ep == 's' || *ep == 'S'){
X				mkswamp();
X				return;
X			}
X			for(i=0; shtypes[i].name; i++)
X				if(*ep == shtypes[i].symb) goto gottype;
X			i = -1;
X		}
X	}
Xgottype:
X#endif
X	for(sroom = &rooms[0], roomno = 0; ; sroom++, roomno++){
X		if(sroom->hx < 0) return;
X		if(sroom - rooms >= nroom) {
X			pline("rooms not closed by -1?");
X			return;
X		}
X		if(sroom->rtype != OROOM) continue;
X		if(!sroom->rlit || has_dnstairs(sroom) || has_upstairs(sroom))
X			continue;
X		if(
X#ifdef WIZARD
X		   (wizard && getenv("SHOPTYPE") && sroom->doorct != 0) ||
X#endif
X			sroom->doorct == 1) break;
X	}
X
X	if(i < 0) {			/* shoptype not yet determined */
X	    register int j;
X
X	    /* pick a shop type at random */
X	    for(j = rn2(100), i = 0; j -= shtypes[i].prob; i++)
X		if (j < 0)	break;
X
X	    /* big rooms cannot be wand or book shops,
X	     * - so make them general stores
X	     */
X	    if(isbig(sroom) && (shtypes[i].symb == WAND_SYM
X#ifdef SPELLS
X				|| shtypes[i].symb == SPBOOK_SYM
X#endif
X								)) i = 0;
X	}
X	sroom->rtype = SHOPBASE + i;
X
X	/* stock the room with a shopkeeper and artifacts */
X	stock_room(&(shtypes[i]), sroom);
X}
X
Xstatic void
Xmkzoo(type)
Xint type;
X{
X	register struct mkroom *sroom;
X	register struct monst *mon;
X	register int sh,sx,sy,i;
X	int goldlim = 500 * dlevel;
X	int moct = 0;
X	struct permonst *morguemon();
X#ifdef NEWCLASS
X	struct permonst *courtmon();
X#endif
X
X	i = nroom;
X	for(sroom = &rooms[rn2(nroom)]; ; sroom++) {
X		if(sroom == &rooms[nroom])
X			sroom = &rooms[0];
X		if(!i-- || sroom->hx < 0)
X			return;
X		if(sroom->rtype != OROOM)	continue;
X		if(has_upstairs(sroom) || (has_dnstairs(sroom) && rn2(3)))
X			continue;
X		if(sroom->doorct == 1 || !rn2(5))
X			break;
X	}
X	sroom->rtype = type;
X	sh = sroom->fdoor;
X	for(sx = sroom->lx; sx <= sroom->hx; sx++)
X	    for(sy = sroom->ly; sy <= sroom->hy; sy++){
X		if((sx == sroom->lx && doors[sh].x == sx-1) ||
X		   (sx == sroom->hx && doors[sh].x == sx+1) ||
X		   (sy == sroom->ly && doors[sh].y == sy-1) ||
X		   (sy == sroom->hy && doors[sh].y == sy+1)) continue;
X		mon = makemon(
X#ifdef NEWCLASS
X		   (type == COURT) ? courtmon() :
X#endif
X#ifdef SAC
X		   (type == BARRACKS) ? PM_SOLDIER :
X#endif
X		   (type == MORGUE) ? morguemon() :
X		   (type == BEEHIVE) ? PM_KILLER_BEE : (struct permonst *) 0,
X		   sx, sy);
X		if(mon) mon->msleep = 1;
X		switch(type) {
X		case ZOO:
X		   i = sq(dist2(sx,sy,doors[sh].x,doors[sh].y));
X		   if(i >= goldlim) i = 5*dlevel;
X		   goldlim -= i;
X		   mkgold((long)(10 + rn2(i)), sx, sy);
X		   break;
X		case MORGUE:
X		   /* Usually there is one dead body in the morgue */
X		   if(!moct && rn2(3)) {
X			mksobj_at(CORPSE, sx, sy);
X			moct++;
X		   }
X		   break;
X		case BEEHIVE:
X		   if(!rn2(3)) mksobj_at(LUMP_OF_ROYAL_JELLY, sx, sy);
X		   break;
X		}
X	}
X#ifdef NEWCLASS
X	if(type == COURT)  {
X
X		sx = sroom->lx + (rn2(sroom->hx - sroom->lx));
X		sy = sroom->ly + (rn2(sroom->hy - sroom->ly));
X		levl[sx][sy].typ = THRONE;
X		levl[sx][sy].scrsym = THRONE_SYM;
X		mkgold((long) rn1(50 * dlevel,10), sx, sy);
X	}
X#endif
X
X}
X
Xstatic struct permonst *
Xmorguemon()
X{
X	extern struct permonst pm_ghost;
X	register int i = rn2(100), hd = rn2(dlevel);
X
X	if(hd > 10 && i < 10) return(PM_DEMON);
X	if(hd > 8 && i > 85) return(PM_VAMPIRE);
X	return((i < 40) ? PM_GHOST : (i < 60) ? PM_WRAITH : PM_ZOMBIE);
X}
X
Xstatic void
Xmkswamp()	/* Michiel Huisjes & Fred de Wilde */
X{
X	register struct mkroom *sroom;
X	register int sx,sy,i,eelct = 0;
X	extern struct permonst pm_eel;
X
X	for(i=0; i<5; i++) {		/* 5 tries */
X		sroom = &rooms[rn2(nroom)];
X		if(sroom->hx < 0 || sroom->rtype != OROOM ||
X		   has_upstairs(sroom) || has_dnstairs(sroom))
X			continue;
X
X		/* satisfied; make a swamp */
X		sroom->rtype = SWAMP;
X		for(sx = sroom->lx; sx <= sroom->hx; sx++)
X		for(sy = sroom->ly; sy <= sroom->hy; sy++)
X		if((sx+sy)%2 && !o_at(sx,sy) && !t_at(sx,sy)
X			     && !m_at(sx,sy) && !nexttodoor(sx,sy)){
X			levl[sx][sy].typ = POOL;
X			levl[sx][sy].scrsym = POOL_SYM;
X			if(!eelct || !rn2(4)) {
X				(void) makemon(PM_EEL, sx, sy);
X				eelct++;
X			}
X		}
X	}
X}
X
Xboolean
Xnexttodoor(sx,sy)
Xregister sx,sy;
X{
X	register dx,dy;
X	register struct rm *lev;
X	for(dx = -1; dx <= 1; dx++) for(dy = -1; dy <= 1; dy++)
X		if((lev = &levl[sx+dx][sy+dy])->typ == DOOR ||
X		    lev->typ == SDOOR || lev->typ == LDOOR)
X			return(TRUE);
X	return(FALSE);
X}
X
Xboolean
Xhas_dnstairs(sroom)
Xregister struct mkroom *sroom;
X{
X	return(sroom->lx <= xdnstair && xdnstair <= sroom->hx &&
X		   sroom->ly <= ydnstair && ydnstair <= sroom->hy);
X}
X
Xboolean
Xhas_upstairs(sroom)
Xregister struct mkroom *sroom;
X{
X	return(sroom->lx <= xupstair && xupstair <= sroom->hx &&
X		   sroom->ly <= yupstair && yupstair <= sroom->hy);
X}
X
Xint
Xdist2(x0,y0,x1,y1){
X	return((x0-x1)*(x0-x1) + (y0-y1)*(y0-y1));
X}
X
Xstatic int
Xsq(a) int a; {
X	return(a*a);
X}
X#endif /* QUEST /**/
X
X#ifdef NEWCLASS
Xstruct permonst *
Xcourtmon()
X{
X	int     i = rn2(60) + rn2(3*dlevel);
X
X	if (i > 100)		return(PM_DRAGON);
X	else if (i > 95)	return(PM_XORN);
X	else if (i > 85)	return(PM_TROLL);
X	else if (i > 75)	return(PM_ETTIN);
X	else if (i > 60)	return(PM_CENTAUR);
X	else if (i > 45)	return(PM_ORC);
X	else if (i > 30)	return(PM_HOBGOBLIN);
X#ifdef KOPS
X	else			return(PM_GNOME);
X#else
X	else if (i > 15)	return(PM_GNOME);
X	else			return(PM_KOBOLD);
X#endif
X}
X#endif /* NEWCLASS /**/
END_OF_mkshop.c
if test 7297 -ne `wc -c <mkshop.c`; then
    echo shar: \"mkshop.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f polyself.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"polyself.c\"
else
echo shar: Extracting \"polyself.c\" \(6671 characters\)
sed "s/^X//" >polyself.c <<'END_OF_polyself.c'
X/*	SCCS Id: @(#)polyself.c	2.3	88/01/21
X/* Polymorph self routine.  Called in zap.c. Copyright 1987 by Ken Arromdee */
X
X#include "hack.h"
X
X#ifdef KAA
X
Xextern char genocided[];
Xextern char pl_character[PL_CSIZ];
Xextern char plname[PL_NSIZ];
X
Xextern long newuexp();
X
Xpolyself()
X{
X	char buf[BUFSZ];
X	int tmp, tmp2, mntmp;
X
X#ifdef BVH
X	if(!Polymorph_control) {
X#endif
X	    if (rn2(5)-3 > u.uluck) {
X		pline("You shudder for a moment.");
X		losehp(rn2(30),"system shock");
X		return;
X	    }
X#ifdef BVH
X	} else {
X	    char buf[BUFSZ];
X	    int i;
X
X	    pline("Type the letter of the monster to become: ");
X	    getlin(buf);
X	    for(i=0; i<CMNUM; ++i)
X		if(mons[i].mlet == *buf) {
X		    mntmp = i;
X		    goto gotone;
X		}
X	}
X#endif
X	mntmp = rn2(CMNUM);
Xgotone:
X/* We want to disallow certain monsters, but also allow humans. */
X	if (index("w:",mons[mntmp].mlet) || !rn2(5)) {
X	    if (!rn2(10)) flags.female = !flags.female;
X	    tmp = u.uhpmax;
X	    tmp2 = u.ulevel;
X	    u.usym = '@';
X	    prme();
X	    u.mtimedone = u.mh = u.mhmax = 0;
X	    u.ulevel = u.ulevel-2+rn2(5);
X	    if (u.ulevel > 127 || u.ulevel == 0) u.ulevel = 1;
X	    if (u.ulevel > 14) u.ulevel = 14;
X	    if (u.ulevel == 1) u.uexp = rnd(10);
X	    else {  /* For the new experience level, random EXP. */
X		u.ulevel--;     
X		u.uexp = newuexp();
X		u.uexp += rn2(u.uexp);
X		u.ulevel++;
X	    }
X	    u.uhpmax = (u.uhpmax-10)*u.ulevel/tmp2 + 19 - rn2(19);
X/* If it was u.uhpmax*u.ulevel/tmp+9-rn2(19), then a 1st level character
X   with 16 hp who polymorphed into a 3rd level one would have an average
X   of 48 hp.  */
X	    u.uhp = u.uhp*u.uhpmax/tmp;
X	    tmp = u.ustrmax;
X	    u.ustrmax += (rn2(5)-2);
X	    if (u.ustrmax > 118) u.ustrmax = 118;
X	    if (u.ustrmax < 3) u.ustrmax = 3;
X	    u.ustr = u.ustr * u.ustrmax / tmp;
X	    if (u.ustr < 3) u.ustr = 3;  /* > 118 is impossible */
X	    u.uhunger = 500 + rn2(500);
X	    Sick = 0;
X	    Stoned = 0;
X	    if (u.uhp <= 0 || u.uhpmax <= 0) {
X#ifdef BVH
X		if(Polymorph_control) {
X		    u.uhp = (u.uhp <= 0) ? 1 : u.uhp;
X		    u.uhpmax = (u.uhpmax <= 0) ? 1  : u.uhpmax;
X		} else {
X#endif
X		    killer="unsuccessful polymorph";
X		    done("died");
X#ifdef BVH
X		}
X#endif
X	    }
X	    pline("You feel like a new %sman!", flags.female ? "wo" : "");
Xnewname:    more();
X	    do {
X		pline("What is your new name? ");
X		getlin(buf);
X	    } while (buf[0]=='\033' || buf[0]==0);
X	    if (!strcmp(plname,buf)) {
X		pline("That is the same as your old name!");
X		goto newname;
X	    }
X	    (void)strncpy(plname, buf, sizeof(plname)-1);
X	    flags.botl = 1;
X	    find_ac();
X	} else {
X	    if (index(genocided,mons[mntmp].mlet)) {
X		pline("You feel rather %sish.",mons[mntmp].mname);
X		return;
X	    }
X	    if(u.usym == '@') {
X		u.mstr = u.ustr;
X		u.mstrmax = u.ustrmax;
X	    }
X	    u.umonnum = mntmp;
X	    u.usym = mons[mntmp].mlet;
X	    if(index("CDelmoPTUVXYz9", u.usym)) u.ustr = u.ustrmax = 118;
X	    if (u.usym == 'D') u.mhmax = 80;
X	    else if (!(mons[mntmp].mlevel)) u.mhmax = rnd(4);
X	    else u.mhmax = d(mons[mntmp].mlevel,8);
X	    u.mh = u.mhmax;
X	    pline("You turn into a%s %s!", index("aeioOU",u.usym) ? "n" : "",
X		  mons[mntmp].mname);
X	    break_armor(u.usym);
X	    drop_weapon(u.usym);
X	    prme();
X	    u.mtimedone = 500 + rn2(500);
X	    flags.botl = 1;
X	    if (u.usym == 'D')
X		pline("Use the command #breathe to breathe fire.");
X	    if (u.usym == 'N')
X		pline("Use the command #remove if you have to remove an iron ball.");
X	    find_ac();
X	}
X	if (Inhell && !Fire_resistance) {
X	    pline("You burn to a crisp.");
X	    killer = "unwise polymorph";
X	    done("died");
X	}
X}
X
Xbreak_armor(turninto)
Xchar turninto;
X{
X     struct obj *otmp;
X     if (uarm) {
X	if (index("CDMPRUXYdejlouz,'9", turninto)) {
X	    pline("The transformation causes you to %s out of your armor!",
X		   (uarm2 || uarm->otyp != ELVEN_CLOAK) ? "break" : "tear");
X#ifdef SHIRT
X	    if (uarmu) useup(uarmu);
X#endif
X	    if (uarm2) useup(uarm2);
X	    useup(uarm);
X	} else	if (index("abcfghikpqrstvxyABEFJQS", turninto)) {
X		pline("Your armor falls around you!");
X		if (otmp = uarm2) {
X		    setworn((struct obj *)0,otmp->owornmask & W_ARM2);
X		    dropx(otmp);
X		}
X		otmp = uarm;
X		setworn((struct obj *)0, otmp->owornmask & W_ARM);
X		dropx(otmp);
X	}
X     }
X#ifdef SHIRT
X     else if (uarmu) {
X		pline("The transformation causes you to tear out of your shirt!");
X		if (uarmu) useup(uarmu);
X	}
X#endif
X     if (!index("enozCGHIKLNOTUVWXYZ&',", turninto)) {
X	  if (otmp = uarmg) {
X	       pline("You drop your gloves!");
X	       setworn((struct obj *)0, otmp->owornmask & W_ARMG);
X	       dropx(otmp);
X	       drop_weapon('a'); /* the 'a' is dummy to ensure dropping */
X	  }
X	  if (otmp = uarms) {
X	       pline("You can no longer hold your shield!");
X	       setworn((struct obj *)0, otmp->owornmask & W_ARMS);
X	       dropx(otmp);
X	  }
X	  if (otmp = uarmh) {
X	       pline("Your helmet falls to the floor!");
X	       setworn((struct obj *)0, otmp->owornmask & W_ARMH);
X	       dropx(otmp);
X	  }
X     }
X}
X
Xdrop_weapon(turninto) 
Xchar turninto;
X{
X     struct obj *otmp;
X     if (otmp = uwep) {
X	  if (cantwield(turninto)) {
X	       pline("You find you must drop your weapon!");
X	       setuwep((struct obj *)0);
X	       dropx(otmp);
X	  }
X     }
X}
X
Xcantwield(c)  /* creature type c cannot wield a weapon */
Xchar c;
X{
X     return(!!index("abcdfgjklpqrsuvxyABEFJPRS',",c));
X}
X
Xcantweararm(c)   /* creature type c cannot wear armor */
Xchar c;
X{
X     return(!index("@nGHIKLNOTVWZ&',",c));
X}
X
Xhumanoid(c)   /* creature type c has hands */
Xchar c;
X{
X	return(!!index("@ehintCGHIKLMNOQTVWZ&",c));
X}
X
Xrehumanize()
X{
X	u.mh = u.mhmax = u.mtimedone = 0;
X	u.ustr = u.mstr;
X	u.ustrmax = u.mstrmax;
X	u.usym = '@';
X	prme();
X	pline("You return to %sn form!",(pl_character[0]=='E')?"elve":"huma");
X
X	if (u.uhp < 1)	done("died");
X	if (!Fire_resistance && Inhell) {
X	    pline("You burn to a crisp.");
X	    killer = "dissipating polymorph spell";
X	   done("died");
X	}
X	flags.botl = 1;
X	find_ac();
X}
X
Xdobreathe()
X{
X     if (u.usym == 'D') {
X	  if(!getdir(1)) return(0);
X	  if (rn2(4))
X	       pline("You exhale a bit of smoke.");
X	  else buzz(20, u.ux, u.uy, u.dx, u.dy);
X     /* Changes must be made in zap.c to accommodate this. */
X     } else pline("You do not have the ability to breathe fire!");
X     return(1);
X}
X
Xdoremove()
X{
X     if (!Punished) {
X	  pline("You do not have a ball attached to your leg!");
X	  return(0);
X     }
X     if(u.usym != 'N')
X	  pline("You are not capable of removing a locked chain!");
X     else {
X	  Punished = 0;
X	  uchain->spe = 0;
X	  uball->spe = 0;
X	  uchain->owornmask &= ~W_CHAIN;
X	  uball->owornmask &= ~W_BALL;
X	  uchain = uball = (struct obj *)0;
X     }
X     return(1);
X}
X#endif
END_OF_polyself.c
if test 6671 -ne `wc -c <polyself.c`; then
    echo shar: \"polyself.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f prisym.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"prisym.c\"
else
echo shar: Extracting \"prisym.c\" \(7322 characters\)
sed "s/^X//" >prisym.c <<'END_OF_prisym.c'
X/*	SCCS Id: @(#)prisym.c	2.3	88/03/29
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X
X#include <stdio.h>
X#include "hack.h"
X
Xextern xchar scrlx, scrhx, scrly, scrhy; /* corners from pri.c */
X
Xatl(x,y,ch)
Xregister x,y;
X{
X	register struct rm *crm = &levl[x][y];
X
X	if(x<0 || x>COLNO-1 || y<0 || y>ROWNO-1){
X		impossible("atl(%d,%d,%c)",x,y,ch);
X		return;
X	}
X	if(crm->seen && crm->scrsym == ch) return;
X	crm->scrsym = ch;
X	crm->new = 1;
X	on_scr(x,y);
X}
X
Xon_scr(x,y)
Xregister x,y;
X{
X	if(x < scrlx) scrlx = x;
X	if(x > scrhx) scrhx = x;
X	if(y < scrly) scrly = y;
X	if(y > scrhy) scrhy = y;
X}
X
X/* call: (x,y) - display
X	(-1,0) - close (leave last symbol)
X	(-1,-1)- close (undo last symbol)
X	(-1,let)-open: initialize symbol
X	(-2,let)-change let
X*/
X
Xtmp_at(x,y) int x,y; {
Xstatic schar prevx, prevy;
Xstatic char let;
X	if((int)x == -2){	/* change let call */
X		let = y;
X		return;
X	}
X	if((int)x == -1 && (int)y >= 0){	/* open or close call */
X		let = y;
X		prevx = -1;
X		return;
X	}
X	if(prevx >= 0 && cansee(prevx,prevy)) {
X		delay_output();
X		prl(prevx, prevy);	/* in case there was a monster */
X		at(prevx, prevy, levl[prevx][prevy].scrsym);
X	}
X	if(x >= 0){	/* normal call */
X		if(cansee(x,y)) at(x,y,let);
X		prevx = x;
X		prevy = y;
X	} else {	/* close call */
X		let = 0;
X		prevx = -1;
X	}
X}
X
X/* like the previous, but the symbols are first erased on completion */
XTmp_at(x,y) int x,y; {
Xstatic char let;
Xstatic xchar cnt;
Xstatic coord tc[COLNO];		/* but watch reflecting beams! */
Xregister xx,yy;
X	if((int)x == -1) {
X		if(y > 0) {	/* open call */
X			let = y;
X			cnt = 0;
X			return;
X		}
X		/* close call (do not distinguish y==0 and y==-1) */
X		while(cnt--) {
X			xx = tc[cnt].x;
X			yy = tc[cnt].y;
X			prl(xx, yy);
X			at(xx, yy, levl[xx][yy].scrsym);
X		}
X		cnt = let = 0;	/* superfluous */
X		return;
X	}
X	if((int)x == -2) {	/* change let call */
X		let = y;
X		return;
X	}
X	/* normal call */
X	if(cansee(x,y)) {
X		if(cnt) delay_output();
X		at(x,y,let);
X		tc[cnt].x = x;
X		tc[cnt].y = y;
X		if(++cnt >= COLNO) panic("Tmp_at overflow?");
X		levl[x][y].new = 0;	/* prevent pline-nscr erasing --- */
X	}
X}
X
Xcurs_on_u(){
X	curs(u.ux, u.uy+2);
X}
X
Xpru()
X{
X	if(u.udispl && (Invisible || u.udisx != u.ux || u.udisy != u.uy))
X		/* if(! levl[u.udisx][u.udisy].new) */
X			if(!vism_at(u.udisx, u.udisy))
X				newsym(u.udisx, u.udisy);
X	if(Invisible) {
X		u.udispl = 0;
X		prl(u.ux,u.uy);
X	} else
X	if(!u.udispl || u.udisx != u.ux || u.udisy != u.uy) {
X		atl(u.ux, u.uy, u.usym);
X		u.udispl = 1;
X		u.udisx = u.ux;
X		u.udisy = u.uy;
X	}
X	levl[u.ux][u.uy].seen = 1;
X}
X
X#ifndef NOWORM
X#include	"wseg.h"
Xextern struct wseg *m_atseg;
X#endif
X
X/* print a position that is visible for @ */
Xprl(x,y)
X{
X	register struct rm *room;
X	register struct monst *mtmp;
X	register struct obj *otmp;
X	register struct trap *ttmp;
X
X	if(x == u.ux && y == u.uy && (!Invisible)) {
X		pru();
X		return;
X	}
X	if(!isok(x,y)) return;
X	room = &levl[x][y];
X	if((!room->typ) ||
X	   (IS_ROCK(room->typ) && levl[u.ux][u.uy].typ == CORR))
X		return;
X	if((mtmp = m_at(x,y)) && !mtmp->mhide &&
X		(!mtmp->minvis || See_invisible)) {
X#ifndef NOWORM
X		if(m_atseg)
X			pwseg(m_atseg);
X		else
X#endif
X		pmon(mtmp);
X	}
X	else if((otmp = o_at(x,y)) && room->typ != POOL)
X		atl(x,y,Hallucination ? rndobjsym() : otmp->olet);
X#ifdef SPIDERS
X	else if((!mtmp || mtmp->data == PM_SPIDER) &&
X		  (ttmp = t_at(x,y)) && ttmp->ttyp == WEB)
X		atl(x,y,WEB_SYM);
X#endif
X	else if(mtmp && (!mtmp->minvis || See_invisible)) {
X		/* must be a hiding monster, but not hiding right now */
X		/* assume for the moment that long worms do not hide */
X		pmon(mtmp);
X	}
X	else if(g_at(x,y) && room->typ != POOL)
X		atl(x,y,Hallucination ? rndobjsym() : GOLD_SYM);
X	else if(!room->seen || room->scrsym == STONE_SYM) {
X		room->new = room->seen = 1;
X		newsym(x,y);
X		on_scr(x,y);
X	}
X	room->seen = 1;
X}
X
Xchar
Xnews0(x,y)
Xregister xchar x,y;
X{
X	register struct obj *otmp;
X	register struct trap *ttmp;
X	struct rm *room;
X	register char tmp;
X
X	room = &levl[x][y];
X	if(!room->seen) tmp = STONE_SYM;
X	else if(room->typ == POOL) tmp = POOL_SYM;
X	else if(!Blind && (otmp = o_at(x,y)))
X		tmp = Hallucination ? rndobjsym() : otmp->olet;
X	else if(!Blind && g_at(x,y))
X		tmp = Hallucination ? rndobjsym() : GOLD_SYM;
X	else if(x == xupstair && y == yupstair) tmp = UP_SYM;
X	else if(x == xdnstair && y == ydnstair) tmp = DN_SYM;
X#ifdef SPIDERS
X	else if((ttmp = t_at(x,y)) && ttmp->ttyp == WEB) tmp = WEB_SYM;
X	else if(ttmp && ttmp->tseen) tmp = TRAP_SYM;
X#else
X	else if((ttmp = t_at(x,y)) && ttmp->tseen) tmp = TRAP_SYM;
X#endif
X	else switch(room->typ) {
X	case SCORR:
X	case SDOOR:
X		tmp = room->scrsym;	/* %% wrong after killing mimic ! */
X		break;
X	case HWALL:
X		tmp = room->scrsym;	/* OK for corners only */
X		if (!IS_CORNER(tmp))
X			tmp = HWALL_SYM;
X		break;
X	case VWALL:
X		tmp = VWALL_SYM;
X		break;
X	case LDOOR:
X	case DOOR:
X		tmp = DOOR_SYM;
X		break;
X	case CORR:
X		tmp = CORR_SYM;
X		break;
X	case ROOM:
X		if(room->lit || cansee(x,y) || Blind) tmp = ROOM_SYM;
X		else tmp = STONE_SYM;
X		break;
X#ifdef FOUNTAINS
X	case FOUNTAIN:
X		tmp = FOUNTAIN_SYM;
X		break;
X#endif
X#ifdef NEWCLASS
X	case THRONE:
X		tmp = THRONE_SYM;
X		break;
X#endif
X#ifdef SINKS
X	case SINK:
X		tmp = SINK_SYM;
X		break;
X#endif
X/*
X	case POOL:
X		tmp = POOL_SYM;
X		break;
X*/
X	default:
X		tmp = ERRCHAR;
X	}
X	return(tmp);
X}
X
Xnewsym(x,y)
Xregister x,y;
X{
X	atl(x,y,news0(x,y));
X}
X
X/* used with wand of digging (or pick-axe): fill scrsym and force display */
X/* also when a POOL evaporates */
Xmnewsym(x,y)
Xregister x,y;
X{
X	register struct rm *room;
X	char newscrsym;
X
X	if(!vism_at(x,y)) {
X		room = &levl[x][y];
X		newscrsym = news0(x,y);
X		if(room->scrsym != newscrsym) {
X			room->scrsym = newscrsym;
X			room->seen = 0;
X		}
X	}
X}
X
Xnosee(x,y)
Xregister x,y;
X{
X	register struct rm *room;
X
X	if(!isok(x,y)) return;
X	room = &levl[x][y];
X	if(room->scrsym == ROOM_SYM && !room->lit && !Blind) {
X		room->scrsym = ' ';
X		room->new = 1;
X		on_scr(x,y);
X	}
X}
X
X#ifndef QUEST
Xprl1(x,y)
Xregister x,y;
X{
X	if(u.dx) {
X		if(u.dy) {
X			prl(x-(2*u.dx),y);
X			prl(x-u.dx,y);
X			prl(x,y);
X			prl(x,y-u.dy);
X			prl(x,y-(2*u.dy));
X		} else {
X			prl(x,y-1);
X			prl(x,y);
X			prl(x,y+1);
X		}
X	} else {
X		prl(x-1,y);
X		prl(x,y);
X		prl(x+1,y);
X	}
X}
X
Xnose1(x,y)
Xregister x,y;
X{
X	if(u.dx) {
X		if(u.dy) {
X			nosee(x,u.uy);
X			nosee(x,u.uy-u.dy);
X			nosee(x,y);
X			nosee(u.ux-u.dx,y);
X			nosee(u.ux,y);
X		} else {
X			nosee(x,y-1);
X			nosee(x,y);
X			nosee(x,y+1);
X		}
X	} else {
X		nosee(x-1,y);
X		nosee(x,y);
X		nosee(x+1,y);
X	}
X}
X#endif /* QUEST /**/
X
Xvism_at(x,y)
Xregister x,y;
X{
X	register struct monst *mtmp;
X
X	if(x == u.ux && y == u.uy && !Invisible) return(1);
X
X	if(mtmp = m_at(x,y)) return((Blind && Telepat) || canseemon(mtmp));
X
X	return(0);
X}
X
X#ifdef NEWSCR
Xpobj(obj) register struct obj *obj; {
Xregister int show = (!obj->oinvis || See_invisible) &&
X		cansee(obj->ox,obj->oy);
X	if(obj->odispl){
X		if(obj->odx != obj->ox || obj->ody != obj->oy || !show)
X		if(!vism_at(obj->odx,obj->ody)){
X			newsym(obj->odx, obj->ody);
X			obj->odispl = 0;
X		}
X	}
X	if(show && !vism_at(obj->ox,obj->oy)){
X		atl(obj->ox,obj->oy,obj->olet);
X		obj->odispl = 1;
X		obj->odx = obj->ox;
X		obj->ody = obj->oy;
X	}
X}
X#endif /* NEWSCR /**/
X
Xunpobj(obj) register struct obj *obj; {
X/* 	if(obj->odispl){
X		if(!vism_at(obj->odx, obj->ody))
X			newsym(obj->odx, obj->ody);
X		obj->odispl = 0;
X	}
X*/
X	if(!vism_at(obj->ox,obj->oy))
X		newsym(obj->ox,obj->oy);
X}
END_OF_prisym.c
if test 7322 -ne `wc -c <prisym.c`; then
    echo shar: \"prisym.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
echo shar: End of archive 11 \(of 13\).
cp /dev/null ark11isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 13 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
