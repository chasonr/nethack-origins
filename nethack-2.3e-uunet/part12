#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 12 (of 13)."
# Contents:  Hackers.doc MANIFEST.2.3 Makefile.pc Makefile.tcc
#   Makefile.xenix README.2.3 dog.c help mkmaze.c mkobj.c monst.c
#   nansi_sys.uu nethack.6 pctty.c sit.c steal.c topl.c vault.c worm.c
#   you.h
# Wrapped by billr@tekred on Mon Jun 20 11:39:26 1988
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f Hackers.doc -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"Hackers.doc\"
else
echo shar: Extracting \"Hackers.doc\" \(5279 characters\)
sed "s/^X//" >Hackers.doc <<'END_OF_Hackers.doc'
X                   NetHack Programmers' Guidelines
X
X                            M. Stephenson
X
X                             18-Feb-1988
X
X
X	Introduction:
X
X     This document is intended as a guide for programmers making changes
Xand additions to the existing NetHack code-base.  It outlines (approximately)
Xmy design philosophy and rules for inclusion of additions and changes to
Xthe code.  Please read it through and keep the basic concepts in mind when
Xwriting new code for the game.
X
X
X	Bug Fixes:
X
X     I'll gladly accept almost ***anything*** in the form of a bug fix.
XPlease make sure you test your fix out before sending it in, however.  Include
Xin the submission, how it was tested, as well as any side effects you may have
Xnoticed due to or in spite of the changes, as they may indicate deficiencies
Xin the code to me.
X
X
X	Enhancements:
X
X     Please remember that this is supposed to be a D&D(tm) type game.  Not
Xa modern day or space type adventure.  Not that I will automatically reject
Xadditions to the game of that type.  I would simply like them to be presented
Xin a form similar to that which exists now.  You can usually take any concept
Xfor a game like this and modify it into a fantasy setting.
X
X     NEVER NEVER NEVER make something hardware dependent.  Remember that for
Xall of those people out there with a beautiful "xyz" 20" 256 color super
Xterminal there are dozens of poor folk with plain old dumb ttys.  Therefore,
Xmake all uses of special characters, graphics and attributes TOTALLY optional.
X
X     If you are adding a brand new concept to the game, please try to do so
Xin a new file (eg. fountains produced fountain.c, spells produced spell.c).
X
X
X	Code Reduction:
X
X     Yes, yes, yes...  If there is any way you can reduce the code while
Xmaintaining portability and flexibility, please do so.  Part of the work I
Xwill be doing on 3.0 will concern three major sets of modifications:
X
X	- making some of the "optional" code standard, hence reducing out
X	  other code in #ifdef / #else / #endif sets.
X
X	- attempting to merge DOS & Unix code into one routine whenever
X	  possible.
X
X	- reorganization of routines into more source modules.
X
X     Please test your results as completely as possible.
X
X
X	Responses to E-Mail:
X
X     I try to respond to E-Mail coming into my account.  For any large fix
Xor fixes requiring two or three separate files, I will usually generate a
Xresponse.  I don't, however, respond to every bug fix due to time, or some-
Xtimes due to the fact that the mail I send back bounces twice or three times
Xwhile I am trying to get through.  If you don't get a response from me, and
Xreally want one, either indicate it in the mail, or, failing a response, send
Xa message through rec.games.hack.  My Rnmail usually gets things through.
X
X
X	Additional OS Compatibility:
X
X     I am interested in getting NetHack working on as many machines as is
Xpossible.  MS-DOS, Unix V Rn and BSD4.n are known supported now.  I have the
Xmods for OS/9 in my posession, and they will be included in 3.0.  If you have
Xmods for any other type of OS, please send them in as soon as possible.  Try
Xto use the existing code as much as possible, and introduce new copies of
Xexisting files only when the alternative is an unreadable mess in the
Xoriginal.
X
X	A Small Wish-List:
X
X     Here are some things I would like to see in the game, for 3.0, and if
Xanyone out there would like to make a stab at programming one of them, please
Xdrop me some mail (my ***NEW*** address is at the bottom of this file) and
XI will try to get you in touch with anyone else expressing like interests.
X
X	- True curses implementation of the display.
X	  (termcap implementation will have to remain for backward
X	   compatibility)
X
X	- More monsters!  My initial algorithm is as follows:
X
X	  - any given letter code will represent a "class" of monster
X	    types.
X
X	  - modify the generation code to generate stronger monster
X	    types as the dungeon and player level increases.
X
X	  - optionally, a game difficulty parameter can be introduced
X	    into the code here (using HARD???).
X
X	  - replace all of those uses of the letter code as monster
X	    designation with a code returned from a single routine
X	    which will determine monster type and a set of equates.
X
X	  - add a command to "#look" and be told what monsters (and
X	    possibly objects) are in the room with you.  This means
X	    you won't have to engage with a monster to find out what
X	    it is.
X
X	- Artifacts (including "intelligent" or "aware" weapons).  This
X	  could really be a lot of fun; especially if you have talking
X	  artifacts to cause you trouble, wake up sleeping monsters, etc.
X
X	- More asynchronous events, especially strange sounds.  A real
X	  dungeon would not be deathly silent, except in the area of
X	  a morgue :-).  There should be the sounds of various things
X	  going on, like the bubbling of a fountain in the room you
X	  haven't gone into yet, the dripping of water in a swamp, a
X	  low rumble of conversation inside a throne room, etc...
X
X	- How about locked doors, locked chests, a "key" tool, and a
X	  "thief" character class?
X
X						Mike Stephenson
X
XMail:	Genamation Inc.		Phone:	(416) 475-9434
X	351 Steelcase Rd. W
X	Markham, Ontario.	UUCP:	uunet!{mnetor,utzoo}!genat!genpyr!mike
X	Canada   L3R 3W1
END_OF_Hackers.doc
if test 5279 -ne `wc -c <Hackers.doc`; then
    echo shar: \"Hackers.doc\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f MANIFEST.2.3 -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"MANIFEST.2.3\"
else
echo shar: Extracting \"MANIFEST.2.3\" \(4264 characters\)
sed "s/^X//" >MANIFEST.2.3 <<'END_OF_MANIFEST.2.3'
X
XUpdate 2.3 Manifest
X
X     This file contains a list of all files required to perform an update
Xof your program.  Files in the manifest can be divided into three separate
Xcatagories.
X
X     1) New files which are, of course, included in full.
X
X     2) Patches to existing files in cases where the length of the
X        patch file does not exceed that of the updated source code.
X
X     3) Updated source modules in cases where the patch file would
X        have been longer.  These are included in full.
X
X     In addition, there is a shell script which will allow you to back up
Xcopies of files in category (3) above to "filename.orig" format files.
X
X
X    New Files Included in this Release:
X
X        MANIFEST.2.3 - this file.
X
X        Fixes.2.3
X        README.2.3
X        Hackers.doc
X        nansi.doc
X        Makefile.3B2
X        Spoilers.mm	(split into .a & .b)
X        food.tbl
X        fount.tbl
X        monster.tbl
X        weapon.tbl
X
X    Updates to Existing Files:
X
X	Update.2.3	(split into parts .a thru .g)
X
X        Makefile.att - patch file (51 lines).
X        Makefile.unix - patch file (68 lines).
X        Makefile.xenix - patch file (19 lines).
X        apply.c - patch file (232 lines).
X        cmd.c - patch file (434 lines).
X        config.h - patch file (177 lines).
X        do.c - patch file (180 lines).
X        do_name.c - patch file (53 lines).
X        do_wear.c - patch file (180 lines).
X        dog.c - patch file (46 lines).
X        dothrow.c - patch file (102 lines).
X        eat.c - patch file (33 lines).
X        end.c - patch file (228 lines).
X        engrave.c - patch file (90 lines).
X        fight.c - patch file (250 lines).
X        fountain.c - patch file (119 lines).
X        hack.c - patch file (121 lines).
X        hack.h - patch file (49 lines).
X        hh - patch file (20 lines).
X        invent.c - patch file (162 lines).
X        lev.c - patch file (279 lines).
X        makedefs.c - patch file (117 lines).
X        makemon.c - patch file (279 lines).
X        mhitu.c - patch file (322 lines).
X        mklev.c - patch file (409 lines).
X        mkmaze.c - patch file (50 lines).
X        mkobj.c - patch file (33 lines).
X        mkshop.c - patch file (312 lines).
X        mon.c - patch file (341 lines).
X        monmove.c - patch file (73 lines).
X        monst.c - patch file (87 lines).
X        monst.h - patch file (36 lines).
X        msdos.c - patch file (32 lines).
X        objclass.h - patch file (34 lines).
X        objects.h - patch file (266 lines).
X        objnam.c - patch file (264 lines).
X        options.c - patch file (108 lines).
X        pager.c - patch file (248 lines).
X        pcmain.c - patch file (131 lines).
X        pctty.c - patch file (44 lines).
X        polyself.c - patch file (154 lines).
X        potion.c - patch file (89 lines).
X        pray.c - patch file (546 lines).
X        pri.c - patch file (54 lines).
X        prisym.c - patch file (35 lines).
X        read.c - patch file (35 lines).
X        rip.c - patch file (70 lines).
X        rm.h - patch file (127 lines).
X        save.c - patch file (277 lines).
X        shk.c - patch file (206 lines).
X        shknam.c - patch file (88 lines).
X        sit.c - patch file (125 lines).
X        spell.c - patch file (225 lines).
X        steal.c - patch file (79 lines).
X        trap.c - patch file (177 lines).
X        u_init.c - patch file (213 lines).
X        unixmain.c - patch file (114 lines).
X        unixtty.c - patch file (32 lines).
X        unixunix.c - patch file (70 lines).
X        version.c - patch file (32 lines).
X        wizard.c - patch file (90 lines).
X        worn.c - patch file (46 lines).
X        you.h - patch file (72 lines).
X        zap.c - patch file (696 lines).
X
X
X    Existing Files Re-released in Full:
X
X        decl.c - released in full as decl.c.new.
X        extern.h - released in full as extern.h.new.
X        mkroom.h - released in full as mkroom.h.new.
X        nethack.cnf - released in full as nethack.cnf.new.
X        o_init.c - released in full as o_init.c.new.
X        obj.h - released in full as obj.h.new.
X        permonst.h - released in full as permonst.h.new.
X        rnd.c - released in full as rnd.c.new.
X        termcap.c - released in full as termcap.c.new.
X        topten.c - released in full as topten.c.new.
END_OF_MANIFEST.2.3
if test 4264 -ne `wc -c <MANIFEST.2.3`; then
    echo shar: \"MANIFEST.2.3\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f Makefile.pc -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"Makefile.pc\"
else
echo shar: Extracting \"Makefile.pc\" \(4450 characters\)
sed "s/^X//" >Makefile.pc <<'END_OF_Makefile.pc'
X#	SCCS Id: @(#)Makefile.pc	2.2	87/11/11
X# 	Makefile for NetHack (PC) version 1.0 written using
X#	Microsoft(tm) "C" v3.0 or better.
X# 
X# Large memory model, register bug, remove stack probes:
XWIZARD=
XV = 35
XCFLAGS = -A$(MODEL) -DREGBUG -DLINT_ARGS -DVER=$V $(WIZARD) -Ot -Gs -Gt100
X
XLIBS =
XLFLAGS =
XMODEL = L
XSETARGV = $(LIB)\$(MODEL)SETARGV
X.SUFFIXES: .exe .obj .c
X.c.obj:; cl $(CFLAGS) -c $*.c
X.c.exe:;
X    cl $(CFLAGS) -c $*.c
X    link $*.obj $(SETARGV), $@,, $(LIBS) $(LFLAGS);
X
X# The game name
XGAME = hack.exe
X
X# The game directory
XGAMEDIR = \h
X
X# All object modules
XOBJS = decl.obj apply.obj bones.obj cmd.obj do.obj dothrow.obj\
X	do_name.obj do_wear.obj dog.obj dogmove.obj eat.obj end.obj \
X	engrave.obj fight.obj fountain.obj hack.obj invent.obj \
X	lev.obj main.obj makemon.obj mhitu.obj mklev.obj \
X	mkmaze.obj mkobj.obj mkshop.obj mon.obj monmove.obj\
X	monst.obj o_init.obj objnam.obj options.obj \
X	pager.obj polyself.obj potion.obj pray.obj pri.obj prisym.obj\
X	read.obj rip.obj rumors.obj save.obj \
X	search.obj shk.obj shknam.obj sit.obj spell.obj steal.obj \
X	termcap.obj timeout.obj topl.obj topten.obj track.obj trap.obj \
X	tty.obj unix.obj u_init.obj vault.obj wield.obj \
X	wizard.obj worm.obj worn.obj write.obj zap.obj \
X	version.obj rnd.obj alloc.obj msdos.obj
X
X# The main target - you may want to try both of these alternatives.
X#
X$(GAME) : $(OBJS)
X#	link $(OBJS), $(GAME) /NOIG /STACK:4000 /CP:1;
X#	link $(OBJS), $(GAME) /NOIG /STACK:0xa00 /CP:1;
X
X
X#	variable auxilary files.
X#
XVARAUX = data rumors
X
Xinstall : $(GAME) $(VARAUX)
X	- exepack $(GAME) $(GAMEDIR)\$(GAME)
X	- exemod $(GAMEDIR)\$(GAME) /max 1
X
Xclean :
X	erase $(GAME)
X
Xspotless: clean
X	erase *.obj
X	erase main.c
X	erase tty.c
X	erase unix.c
X
Xsrcs :
X	copy makefile \tmp
X	copy *.c \tmp
X	copy *.h \tmp
X	copy \local\make\make.doc \tmp
X	copy \local\make\make.ini \tmp
X	copy \bin\make.exe \tmp
X	cd \tmp
X	time
X	touch *.*
X	arc m hack$Vs * *.*
X	cd $(CWD)
X
X
X#	Other dependencies
X#
XRUMORFILES= rumors.bas rumors.kaa rumors.mrx
X
Xmakedefs.exe:	makedefs.c alloc.obj config.h
X	cl -AL makedefs.c alloc.obj
X
X
Xrumors :  config.h $(RUMORFILES) makedefs.exe
X	makedefs.exe -r
X
Xdata :  config.h data.bas makedefs.exe
X	makedefs.exe -d
X
Xonames.h :  config.h objects.h makedefs.exe
X	makedefs.exe -o
X
X#	Below is a kluge.  date.h should actually depend on any source
X#	module being changed. (but hack.h is close enough for most).
X#
Xdate.h :  hack.h makedefs.exe
X	makedefs.exe -D
X
Xtrap.h :  config.h makedefs.exe
X	makedefs.exe -t
X
Xmain.obj :  pcmain.c hack.h
X	$(CC) $(CFLAGS) -Fo$@ -c pcmain.c
X
Xtty.obj :  pctty.c hack.h msdos.h
X	$(CC) $(CFLAGS) -Fo$@ -c pctty.c
X
Xunix.obj :  pcunix.c hack.h mkroom.h
X	$(CC) $(CFLAGS) -Fo$@ -c pcunix.c
X
Xdecl.obj :  hack.h mkroom.h
Xapply.obj :  hack.h edog.h mkroom.h
Xbones.obj :  hack.h
Xhack.obj :  hack.h
Xcmd.obj :  hack.h func_tab.h
Xdo.obj :  hack.h
Xdo_name.obj :  hack.h
Xdo_wear.obj :  hack.h
Xdog.obj :  hack.h edog.h mkroom.h
Xdogmove.obj :  hack.h mfndpos.h edog.h mkroom.h
Xdothrow.obj :  hack.h
Xeat.obj :  hack.h
Xend.obj :  hack.h
Xengrave.obj :  hack.h
Xfight.obj :  hack.h
Xfountain.obj :  hack.h mkroom.h
Xinvent.obj :  hack.h wseg.h
Xioctl.obj :  config.h
Xlev.obj :  hack.h mkroom.h wseg.h
Xmakemon.obj :  hack.h
Xmhitu.obj :  hack.h
Xmklev.obj :  hack.h mkroom.h
Xmkmaze.obj :  hack.h mkroom.h
Xmkobj.obj :  hack.h
Xmkshop.obj :  hack.h mkroom.h eshk.h
Xmon.obj :  hack.h mfndpos.h
Xmonmove.obj :  hack.h mfndpos.h
Xmonst.obj :  hack.h eshk.h
Xmsdos.obj : msdos.h
Xo_init.obj :  config.h objects.h onames.h
Xobjnam.obj :  hack.h
Xoptions.obj :  hack.h
Xpager.obj :  hack.h
Xpolyself.obj : hack.h
Xpotion.obj :  hack.h
Xpray.obj :  hack.h
Xpri.obj :  hack.h
Xprisym.obj :  hack.h wseg.h
Xread.obj :  hack.h
Xrip.obj :  hack.h
Xrumors.obj :  hack.h
Xsave.obj :  hack.h
Xsearch.obj :  hack.h
Xshk.obj :  hack.h mfndpos.h mkroom.h eshk.h
Xshknam.obj :  hack.h
Xsit.obj : hack.h
Xspell.obj :  hack.h
Xsteal.obj :  hack.h
Xtermcap.obj :  hack.h
Xtimeout.obj :  hack.h
Xtopl.obj :  hack.h
Xtopten.obj :  hack.h
Xtrack.obj :  hack.h
Xtrap.obj :  hack.h edog.h mkroom.h
Xu_init.obj :  hack.h
Xvault.obj :  hack.h mkroom.h
Xwield.obj :  hack.h
Xwizard.obj :  hack.h
Xworm.obj :  hack.h wseg.h
Xworn.obj :  hack.h
Xwrite.obj :  hack.h
Xzap.obj :  hack.h
Xversion.obj :  hack.h date.h
Xextern.h: config.h spell.h obj.h
X	touch extern.h
Xhack.h: extern.h flag.h gold.h monst.h objclass.h rm.h trap.h you.h 
X	touch hack.h
Xobjects.h:  config.h objclass.h
X	touch objects.h
Xyou.h: config.h onames.h permonst.h 
X	touch you.h
END_OF_Makefile.pc
if test 4450 -ne `wc -c <Makefile.pc`; then
    echo shar: \"Makefile.pc\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f Makefile.tcc -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"Makefile.tcc\"
else
echo shar: Extracting \"Makefile.tcc\" \(4329 characters\)
sed "s/^X//" >Makefile.tcc <<'END_OF_Makefile.tcc'
X#	SCCS Id: @(#)Makefile.tcc	2.2	87/11/11
X# 	Makefile for NetHack (PC) version 1.0 written using
X#	Turbo C v1.0
X# 
X# Unfortunately, large model is limited to a total of 64K global data
X# Huge memory model, remove stack probes, optimize for space:
XWIZARD=
XV = 14
XCFLAGS = -m$(MODEL) -DLINT_ARGS -DVER=$(V) $(WIZARD) -N- -Z -K- -O -w-pro -w-nod
X
X# The game name
XGAME = hack.exe
X
X# The game directory
XGAMEDIR = .
X
X# The directory containing the libraries
XLIBDIR = c:\c\lib
X
X# All object modules
XOBJS = decl.obj apply.obj bones.obj cmd.obj do.obj dothrow.obj\
X	do_name.obj do_wear.obj dog.obj dogmove.obj eat.obj end.obj \
X	engrave.obj fight.obj fountain.obj hack.obj invent.obj \
X	lev.obj main.obj makemon.obj mhitu.obj mklev.obj \
X	mkmaze.obj mkobj.obj mkshop.obj mon.obj monmove.obj\
X	monst.obj o_init.obj objnam.obj options.obj \
X	pager.obj polyself.obj potion.obj pray.obj pri.obj prisym.obj\
X	read.obj rip.obj rumors.obj save.obj \
X	search.obj shk.obj shknam.obj sit.obj spell.obj steal.obj \
X	termcap.obj timeout.obj topl.obj topten.obj track.obj trap.obj \
X	tty.obj unix.obj u_init.obj vault.obj wield.obj \
X	wizard.obj worm.obj worn.obj write.obj zap.obj \
X	version.obj rnd.obj alloc.obj msdos.obj
X
X# The main target
X#
X$(GAME) : $(OBJS)
X	link /x:400 $(LIBDIR)\c0$(MODEL).obj @objs.lnk,$(GAME),,$(LIBDIR)\c$(MODEL).lib
X
X#	variable auxilary files.
X#
XVARAUX = data rumors
X
Xinstall : $(GAME) $(VARAUX)
X	- exepack $(GAME) $(GAMEDIR)\$(GAME)
X	- exemod $(GAMEDIR)\$(GAME) /max 1
X
Xclean :
X	erase $(GAME)
X
Xspotless: clean
X	erase *.obj
X	erase main.c
X	erase tty.c
X	erase unix.c
X
Xsrcs :
X	copy makefile \tmp
X	copy *.c \tmp
X	copy *.h \tmp
X	copy \local\make\make.doc \tmp
X	copy \local\make\make.ini \tmp
X	copy \bin\make.exe \tmp
X	cd \tmp
X	time
X	touch *.*
X	arc m hack$Vs * *.*
X	cd $(CWD)
X
X
X#	Other dependencies
X#
XRUMORFILES= rumors.bas rumors.kaa rumors.mrx
X
Xmakedefs.exe:	makedefs.c alloc.obj config.h
X	cl -AL makedefs.c alloc.obj
X
X
Xrumors :  config.h $(RUMORFILES) makedefs.exe
X	makedefs.exe -r
X
Xdata :  config.h data.bas makedefs.exe
X	makedefs.exe -d
X
Xonames.h :  config.h objects.h makedefs.exe
X	makedefs.exe -o
X
X#	Below is a kluge.  date.h should actually depend on any source
X#	module being changed. (but hack.h is close enough for most).
X#
Xdate.h :  hack.h makedefs.exe
X	makedefs.exe -D
X
Xtrap.h :  config.h makedefs.exe
X	makedefs.exe -t
X
Xmain.obj :  pcmain.c hack.h
X	$(CC) $(CFLAGS) -Fo$@ -c pcmain.c
X
Xtty.obj :  pctty.c hack.h msdos.h
X	$(CC) $(CFLAGS) -Fo$@ -c pctty.c
X
Xunix.obj :  pcunix.c hack.h mkroom.h
X	$(CC) $(CFLAGS) -Fo$@ -c pcunix.c
X
Xdecl.obj :  hack.h mkroom.h
Xapply.obj :  hack.h edog.h mkroom.h
Xbones.obj :  hack.h
Xhack.obj :  hack.h
Xcmd.obj :  hack.h func_tab.h
Xdo.obj :  hack.h
Xdo_name.obj :  hack.h
Xdo_wear.obj :  hack.h
Xdog.obj :  hack.h edog.h mkroom.h
Xdogmove.obj :  hack.h mfndpos.h edog.h mkroom.h
Xdothrow.obj :  hack.h
Xeat.obj :  hack.h
Xend.obj :  hack.h
Xengrave.obj :  hack.h
Xfight.obj :  hack.h
Xfountain.obj :  hack.h mkroom.h
Xinvent.obj :  hack.h wseg.h
Xioctl.obj :  config.h
Xlev.obj :  hack.h mkroom.h wseg.h
Xmakemon.obj :  hack.h
Xmhitu.obj :  hack.h
Xmklev.obj :  hack.h mkroom.h
Xmkmaze.obj :  hack.h mkroom.h
Xmkobj.obj :  hack.h
Xmkshop.obj :  hack.h mkroom.h eshk.h
Xmon.obj :  hack.h mfndpos.h
Xmonmove.obj :  hack.h mfndpos.h
Xmonst.obj :  hack.h eshk.h
Xmsdos.obj : msdos.h
Xo_init.obj :  config.h objects.h onames.h
Xobjnam.obj :  hack.h
Xoptions.obj :  hack.h
Xpager.obj :  hack.h
Xpolyself.obj : hack.h
Xpotion.obj :  hack.h
Xpray.obj :  hack.h
Xpri.obj :  hack.h
Xprisym.obj :  hack.h wseg.h
Xread.obj :  hack.h
Xrip.obj :  hack.h
X	tcc -c $(CFLAGS) -d- rip.c
Xrumors.obj :  hack.h
Xsave.obj :  hack.h
Xsearch.obj :  hack.h
Xshk.obj :  hack.h mfndpos.h mkroom.h eshk.h
Xshknam.obj :  hack.h
Xsit.obj : hack.h
Xspell.obj :  hack.h
Xsteal.obj :  hack.h
Xtermcap.obj :  hack.h
Xtimeout.obj :  hack.h
Xtopl.obj :  hack.h
Xtopten.obj :  hack.h
Xtrack.obj :  hack.h
Xtrap.obj :  hack.h edog.h mkroom.h
Xu_init.obj :  hack.h
Xvault.obj :  hack.h mkroom.h
Xwield.obj :  hack.h
Xwizard.obj :  hack.h
Xworm.obj :  hack.h wseg.h
Xworn.obj :  hack.h
Xwrite.obj :  hack.h
Xzap.obj :  hack.h
Xversion.obj :  hack.h date.h
Xextern.h: config.h spell.h obj.h
X	touch extern.h
Xhack.h: extern.h flag.h gold.h monst.h objclass.h rm.h trap.h you.h 
X	touch hack.h
Xobjects.h:  config.h objclass.h
X	touch objects.h
Xyou.h: config.h onames.h permonst.h 
X	touch you.h
END_OF_Makefile.tcc
if test 4329 -ne `wc -c <Makefile.tcc`; then
    echo shar: \"Makefile.tcc\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f Makefile.xenix -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"Makefile.xenix\"
else
echo shar: Extracting \"Makefile.xenix\" \(6193 characters\)
sed "s/^X//" >Makefile.xenix <<'END_OF_Makefile.xenix'
X#	Hack or Quest Makefile.
X#	SCCS Id: @(#)Makefile.xenix	2.1	87/10/08
X
X# if you are cross-compiling (eg. from Xenix into a Dos enviornment)
X# you will have to redefine these filenames.
XMAIN = unixmain.c
XTTY  = unixtty.c
XUNIX = unixunix.c
X
X# on some systems the termcap library is in -ltermcap
XTERMLIB = -ltermlib
XCRT0   =
XLIBS = ${TERMLIB} 
X
X# flags may have to be changed as required
XCFLAGS = -LARGE -Ml
XLFLAGS = -Ml
X
X# make NetHack
XGAME     = nethack
XGAMEUID  = games
XGAMEGRP  = bin
XGAMEDIR  = /usr/games/lib/$(GAME)dir
XSHELLDIR = /usr/games
XMANDIR   = /usr/man/manl
XMANEXT   = l
X
XHACKCSRC = apply.c bones.c decl.c\
X	cmd.c do.c dothrow.c do_name.c do_wear.c dog.c dogmove.c eat.c end.c\
X	engrave.c fight.c fountain.c hack.c invent.c ioctl.c lev.c main.c\
X	makemon.c mhitu.c mklev.c mkmaze.c mkobj.c mkshop.c\
X	mon.c monmove.c monst.c o_init.c objnam.c options.c\
X	pager.c polyself.c potion.c pray.c pri.c prisym.c read.c rip.c\
X	rumors.c save.c search.c shk.c shknam.c sit.c spell.c steal.c\
X	termcap.c timeout.c topl.c topten.c track.c trap.c tty.c unix.c\
X	u_init.c vault.c wield.c wizard.c worm.c worn.c write.c zap.c\
X	version.c rnd.c alloc.c
X
XCSOURCES = $(HACKCSRC) makedefs.c
X
XHSOURCES = hack.h mfndpos.h config.h edog.h eshk.h extern.h\
X	flag.h func_tab.h gold.h mkroom.h monst.h obj.h\
X	objclass.h objects.h permonst.h rm.h spell.h trap.h wseg.h you.h
X
XSOURCES = $(CSOURCES) $(HSOURCES)
X
XAUX = help hh nethack.6 nethack.sh
XVARAUX = data rumors
XSPECIFICS = main.o tty.o unix.o
X
XDISTR = $(SOURCES) $(AUX) $(VARAUX) README.OLD README\
X	Makefile.unix Makefile.xenix Makefile.pc Make.ini
X
XHOBJ = apply.o bones.o decl.o cmd.o do.o dothrow.o do_name.o do_wear.o dog.o\
X	dogmove.o eat.o end.o engrave.o fight.o fountain.o hack.o\
X	invent.o ioctl.o lev.o main.o makemon.o mhitu.o mklev.o\
X	mkmaze.o mkobj.o mkshop.o mon.o monmove.o monst.o\
X	o_init.o objnam.o options.o pager.o polyself.o potion.o pray.o\
X	pri.o prisym.o read.o rip.o rumors.o save.o search.o shk.o shknam.o\
X	sit.o spell.o steal.o termcap.o timeout.o topl.o topten.o track.o\
X	trap.o tty.o unix.o u_init.o vault.o wield.o wizard.o worm.o worn.o\
X	write.o zap.o version.o rnd.o alloc.o
X
X.c.o:
X	cc -O -c -Gt24 ${CFLAGS} $*.c
X
X$(GAME):	$(SPECIFICS) $(HOBJ) Makefile
X	cc $(LFLAGS) -m hack.map -o $(GAME) /lib/Lsignal.o $(CRT0) $(HOBJ) $(LIBS) -SEG#256
X
X	
Xall:	$(GAME) lint
X	@echo "Done."
X
Xmakedefs:	makedefs.c Salloc.o config.h
X	cc -O -o makedefs Salloc.o makedefs.c
X
XSalloc.o:	alloc.c
X	cp alloc.c Salloc.c
X	cc -O -c Salloc.c
Xpc: 
X	cd dos; make
X
XRUMORFILES= rumors.base rumors.kaa rumors.mrx
X
Xrumors:	config.h $(RUMORFILES) makedefs
X	./makedefs -r
X
Xdata:	config.h data.base makedefs
X	./makedefs -d
X
Xdate.h:	$(SOURCES) makedefs
X	./makedefs -D
X
Xtrap.h:	config.h makedefs
X	./makedefs -t
X
Xonames.h:	makedefs objects.h
X	./makedefs -o
X
Xmain.o: main.c
X
Xmain.c:	unixmain.c hack.h
X	cp ${MAIN} main.c
X
Xtty.o:	tty.c
X	cc ${CFLAGS} -c tty.c
X
Xtty.c:	unixtty.c extern.h
X	cp ${TTY} tty.c
X
Xunix.c:	unixunix.c hack.h mkroom.h
X	cp ${UNIX} unix.c
X
Xlint:
X# lint cannot have -p here because (i) capitals are meaningful:
X# [Ww]izard, (ii) identifiers may coincide in the first six places:
X# doweararm() versus dowearring().
X# _flsbuf comes from <stdio.h>, a bug in the system libraries.
X	@echo lint -axbh -DLINT ...
X	@lint -axbh -DLINT $(HACKCSRC) | sed '/_flsbuf/d'
X
X
Xdiff:
X	@- for i in $(SOURCES) $(AUX) ; do \
X		cmp -s $$i $D/$$i || \
X		( echo diff $D/$$i $$i ; diff $D/$$i $$i ; echo ) ; done
X
Xdistribution: Makefile
X	@- for i in READ_ME $(SOURCES) $(AUX) Makefile date.h onames.h\
X		; do \
X		cmp -s $$i $D/$$i || \
X		( echo cp $$i $D ; cp $$i $D ) ; done
X# the distribution directory also contains the empty files perm and record.
X
Xinitial:
X	-rm -rf $(GAMEDIR)
X	-mkdir $(SHELLDIR)
X	mkdir $(GAMEDIR) $(GAMEDIR)/save
X	touch $(GAMEDIR)/perm
X	touch $(GAMEDIR)/record
X	touch $(GAMEDIR)/logfile
X	chown $(GAMEUID) $(GAMEDIR) $(GAMEDIR)/*
X	chgrp $(GAMEGRP) $(GAMEDIR) $(GAMEDIR)/*
X	chmod 666 $(GAMEDIR)/*
X	chmod 777 $(GAMEDIR) $(GAMEDIR)/save
X
Xinstall: $(VARAUX) $(GAME)
X	-rm -f $(GAMEDIR)/$(GAME)
X	-rm -f $(GAMEDIR)/bones* $(GAMEDIR)/alock* $(GAMEDIR)/wizard*
X	-rm -f $(GAMEDIR)/save/*
X	cp help hh rumors data $(GAMEDIR)
X	cp $(GAME).sh $(SHELLDIR)/$(GAME)
X	cp $(GAME) $(GAMEDIR)/$(GAME)
X	chown $(GAMEUID) $(SHELLDIR)/$(GAME) $(GAMEDIR) $(GAMEDIR)/*
X	chgrp $(GAMEGRP) $(SHELLDIR)/$(GAME) $(GAMEDIR) $(GAMEDIR)/*
X	chmod 0755 $(SHELLDIR)/$(GAME)
X	chmod 04755 $(GAMEDIR)/$(GAME)
X	-cp nethack.6 $(MANDIR)/$(GAME).$(MANEXT)
X
Xdebug:
X	ln $(GAMEDIR)/$(GAME) a.out
X	ln $(GAMEDIR)/core core
X
Xclean:
X	rm -f *.o
X
Xspotless: clean
X	rm -f a.out core $(GAME) makedefs
X	rm -f Makefile $(VARAUX) main.c tty.c unix.c
X
Xdecl.o:  hack.h mkroom.h
Xapply.o:  hack.h edog.h mkroom.h
Xbones.o:  hack.h
Xhack.o:  hack.h
Xcmd.o:  hack.h func_tab.h
Xdo.o:  hack.h
Xdo_name.o:  hack.h
Xdo_wear.o:  hack.h
Xdog.o:  hack.h edog.h mkroom.h
Xdogmove.o:  hack.h mfndpos.h edog.h mkroom.h
Xdothrow.o:  hack.h
Xeat.o:  hack.h
Xend.o:  hack.h
Xengrave.o:  hack.h
Xfight.o:  hack.h
Xfountain.o:  hack.h mkroom.h
Xinvent.o:  hack.h wseg.h
Xioctl.o:  config.h
Xlev.o:  hack.h mkroom.h wseg.h
Xmakemon.o:  hack.h
Xmhitu.o:  hack.h
Xmklev.o:  hack.h mkroom.h
Xmkmaze.o:  hack.h mkroom.h
Xmkobj.o:  hack.h
Xmkshop.o:  hack.h mkroom.h eshk.h
Xmon.o:  hack.h mfndpos.h
Xmonmove.o:  hack.h mfndpos.h
Xmonst.o:  hack.h eshk.h
Xo_init.o:  config.h objects.h onames.h
Xobjnam.o:  hack.h
Xoptions.o:  hack.h
Xpager.o:  hack.h
Xpolyself.o: hack.h
Xpotion.o:  hack.h
Xpray.o:  hack.h
Xpri.o:  hack.h
Xprisym.o:  hack.h wseg.h
Xread.o:  hack.h
Xrip.o:  hack.h
Xrumors.o:  hack.h
Xsave.o:  hack.h
Xsearch.o:  hack.h
Xshk.o:  hack.h mfndpos.h mkroom.h eshk.h
Xshknam.o:  hack.h
Xsit.o: hack.h
Xspell.o:  hack.h
Xsteal.o:  hack.h
Xtermcap.o:  hack.h
Xtimeout.o:  hack.h
Xtopl.o:  hack.h
Xtopten.o:  hack.h
Xtrack.o:  hack.h
Xtrap.o:  hack.h edog.h mkroom.h
Xu_init.o:  hack.h
Xvault.o:  hack.h mkroom.h
Xwield.o:  hack.h
Xwizard.o:  hack.h
Xworm.o:  hack.h wseg.h
Xworn.o:  hack.h
Xwrite.o:  hack.h
Xzap.o:  hack.h
Xversion.o:  hack.h date.h
Xextern.h: config.h spell.h obj.h
X	touch extern.h
Xhack.h: extern.h flag.h gold.h monst.h objclass.h rm.h trap.h you.h 
X	touch hack.h
Xobjects.h:  config.h objclass.h
X	touch objects.h
Xyou.h: config.h onames.h permonst.h 
X	touch you.h
END_OF_Makefile.xenix
if test 6193 -ne `wc -c <Makefile.xenix`; then
    echo shar: \"Makefile.xenix\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f README.2.3 -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"README.2.3\"
else
echo shar: Extracting \"README.2.3\" \(6694 characters\)
sed "s/^X//" >README.2.3 <<'END_OF_README.2.3'
X			    NetHack V2.3 README
X
X	This file contains information on the 2.3 release of NetHack.  For
Xinformation on previous releases, see the README and README.OLD files.  For
Xa detailed history of the game, see the README.ORIG file, which contains
Xthree separate readme files, dating back to the original release of the game
X(then named "hack") by Jay Fenlason.
X
X			HOW TO INSTALL THIS RELEASE
X
X	To install this release, unpack all of the shar kits.  You will find
Xyou have a bunch of completely new files, a second bunch of files with a
X".new" suffix (these are all files which have been released fully, since the
Xpatch file to update them would have been larger than the file itself), a set
Xof update patches - context diffs, and finally a shell script to pull every-
Xthing together.
X
X	Next ***BACK EVERYTHING UP***.  I don't want to receive irate mail
Xabout missing files due to some finger error.
X
X	Read "Update.sh".  This script will be used once - and only once -
Xto perform the copies and cat's required to make the update.   Once it has
Xbeen run, all of your ".new" files will be moved onto their corresponding
X".c" and ".h" files, and the originals will be backed up with a ".orig"
Xsuffix.  All of the files which were shipped in parts will be concatenated
Xinto one file.  And finally Update.sh will be removed. 
X
X	Next run patch(1) with the file Update.2.3 as it's stdin.  This will
Xpatch the remaining files up to 2.3e standard.  Gods help you if you've done
Xany patching on your own.  It probably won't work in that case.  Best bet is
Xto start with a virgin 2.2 release.
X
X	Finally, copy "Makefile.<whatever>" to "Makefile", modify "config.h"
Xto suit and run "make".  Install it as you wish.
X
X
X			    Release Discription
X
X	This release of the game contains a large number of bug fixes, as
Xwell as several new features.  There has been a large amount of play-testing
Xdone on this release.  For a detailed list of bug fixes, and additions look
Xat the file "Fixes.2.3".  I cannot guarantee that every modification done has
Xbeen included, but I have done my best to chronicle the changes and fixes
Xmade there.  Here are the high points:
X
X  1)	New flags in "config.h":
X
X	SAC		Soldiers & barracks code
X	SHIRT		Hawaiian shirt code
X	THEOLOGY	Smarter gods & sacrifices
X	STOOGES		Three wild and crazy guys
X	SINKS		Kitchen Sinks
X
X	SCORE_ON_BOTL	Score (not exactly # of exp) on the bottom line.
X
X	In addition, in an MSDOS enviornment:
X
X	TERMLIB		enable use of termcap file c:\etc\termcap
X			or .\termcap.cnf for MSDOS
X
X	Of the above, I haven't tested TERMLIB.  If you find bugs in these,
Xsend me the reports.
X
X  2)	New objects:
X
X	Hawaiian shirts (sort of armor - especially for tourists).
X
X	Kitchen Sinks - for the dropping of rings, of course...
X
X	Wand of Lightning
X
X	Ring of Shock Resistance (to balance above)
X
X	A named weapon (dagger or short sword) "Sting" a la Tolkien.
X
X	Lamps and Magic Lamps
X
X	A Badge to identify you as an "Officer".
X
X  3)	New Files:
X
X	A new makefile for the ATT 3B2
X
X	A "Spoilers" manual in mm format and tables for the manual.
X
X	The long-awaited documentation on nansi.sys - nansi.doc.
X
X  4)	Major game changes:
X
X	- Shop generation has been cleaned up.  There are now up to four
X	different types of object inside.  There has also been modifications
X	to room generation to make things cleaner.
X
X	- A new type of room, the barracks (a lair for soldiers) has been
X	added.  In addition, the soldier has been made just a little less
X	deadly to compensate for the large numbers present.
X
X	- A new type of trap, the landmine, (which will be renamed to con-
X	form with a fantasy setting in the future) has been added.
X
X	- A change to shopkeepers has them getting angry more easily if you
X	are wearing a badge, and have robbed them.
X
X	- The "dragon" has been split up into several sub-types.  They now
X	have all sorts of breath weapons - NOTE: a slight bug - eating any
X	of the dead dragon types still gives you intrinsic fire resistance.
X
X	- A new wand, and compensating ring have been added (Lightning).
X
X	- The "Giant Eel" has been replaced with an "Electric Eel".
X
X	- The wand zapping code has been re-written (mostly in buzz()) so
X	that support for new zap effects will be easier in the future.
X
X	- Chameleon shape changes are now dependant on the level for more
X	challenge.
X
X	- An optional "logfile" has been added for game debugging.
X
X	- Some interesting changes to the "pray" code have been added.
X
X	- The restmonchn() code has been merged between Unix and MS-DOS.
X	This results in a fair sized reduction in size and complexity of
X	that particular module.  Please send me any bug reports as I have
X	only tested it on the Unix side.
X
X	- The colour <--> gemstone type code has been fixed so that the
X	colour of an unknown stone now approximates the gem type.
X
X	- For those who like a little fun, three STOOGES have been added
X	(optionally) to the game.  They will show up and fight with each
X	other, producing more of a disturbance than any serious trouble.
X
X	- Lamps have been added.  When applied, they will light a room.
X
X	- Magic lamps have a djinn inside.  Glowing potions may too.
X
X	- A new monster, the Gremlin, can multiply in water, and will
X	potentially steal your hard won inate attributes.
X
X  5)	Minor game changes:
X
X	- The fountain code has been modified to allow coins to fall into or
X	be recovered from a fountain.
X
X	- In wizard mode, the wizard player can now map the level, list all
X	of his/her attributes, and can do a detect for all traps and doors.
X
X	- When wishing, you are no longer limited by the x3/+3 rule.  However,
X	you can't be sure that a "greedy" wish will produce the desired
X	results, the object might be cursed.
X
X	- You can now optionally print your score on the bottom line.  The
X	score printed is close to what would show up on your tombstone.
X
X	- A fix to allow multiple machine play via NFS on a shared playground
X	has been made.  This won't affect us single machine players.
X
X	- The time between prayers is now random.
X
X	- Wizard and Medusa levels are now dependant on the MAXLEVEL param.
X
X	- The spell list is now displayed in the corner.
X
X  6)	Future additions:
X
X	See the "Hackers.doc" file.  I am going to make the next release
Xa major modification of the code (3.0).  It will include as many alternate
XOSs supported as I can get patches for.  It will also be constrained towards
Xa "fantasy" approach to the game.
X
XPLEASE NOTE MY NEW UUCP ADDRESS BELOW!!!
X						Mike Stephenson
X
Xps:	Sorry this one took so long.  I'm going to fix up an alternative
X	to handle releases in the future.
X
XMail:	Genamation Inc.		Phone:	(416) 475-9434
X	351 Steelcase Rd. W
X	Markham, Ontario.	UUCP:	uunet!{mnetor,utzoo}!genat!genpyr!mike
X	Canada   L3R 3W1
END_OF_README.2.3
if test 6694 -ne `wc -c <README.2.3`; then
    echo shar: \"README.2.3\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f dog.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"dog.c\"
else
echo shar: Extracting \"dog.c\" \(4576 characters\)
sed "s/^X//" >dog.c <<'END_OF_dog.c'
X/*	SCCS Id: @(#)dog.c	2.3	88/03/29
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X
X#include	"hack.h"
Xextern struct monst *makemon();
X#include "edog.h"
X#include "mkroom.h"
X
X#ifdef	DOGNAME
Xchar dogname[63];
X#endif	/* DOGNAME */
X
Xstruct permonst li_dog =
X	{ "little dog", 'd',2,18,6,0,1,6,sizeof(struct edog) };
Xstruct permonst dog =
X	{ "dog", 'd',4,16,5,0,1,6,sizeof(struct edog) };
Xstruct permonst la_dog =
X	{ "large dog", 'd',6,15,4,0,2,4,sizeof(struct edog) };
X
Xstruct monst *
Xmakedog(){
Xregister struct monst *mtmp = makemon(&li_dog,u.ux,u.uy);
X	if(!mtmp) return((struct monst *) 0); /* dogs were genocided */
X#ifdef	DOGNAME
X	if (dogname[0]) {
X		register struct monst *mtmp2;
X		mtmp->mnamelth = strlen(dogname);
X		mtmp2 = newmonst(sizeof(struct edog) + mtmp->mnamelth);
X		*mtmp2 = *mtmp;
X		strcpy(NAME(mtmp2), dogname);
X		replmon(mtmp, mtmp2);
X		mtmp = mtmp2;
X		dogname[0] = '\0';	/* name only first dog */
X	}
X#endif	/* DOGNAME */
X	initedog(mtmp);
X	return(mtmp);
X}
X
Xinitedog(mtmp) register struct monst *mtmp; {
X	mtmp->mtame = mtmp->mpeaceful = 1;
X#ifdef WALKIES
X	mtmp->mleashed = 0;
X#endif
X	EDOG(mtmp)->hungrytime = 1000 + moves;
X	EDOG(mtmp)->eattime = 0;
X	EDOG(mtmp)->droptime = 0;
X	EDOG(mtmp)->dropdist = 10000;
X	EDOG(mtmp)->apport = 10;
X	EDOG(mtmp)->whistletime = 0;
X}
X
X/* attach the monsters that went down (or up) together with @ */
Xstruct monst *mydogs = 0;
Xstruct monst *fallen_down = 0;	/* monsters that fell through a trapdoor */
X	/* they will appear on the next level @ goes to, even if he goes up! */
X
Xlosedogs(){
Xregister struct monst *mtmp;
X	while(mtmp = mydogs){
X		mydogs = mtmp->nmon;
X		mtmp->nmon = fmon;
X		fmon = mtmp;
X		mnexto(mtmp);
X	}
X	while(mtmp = fallen_down){
X		fallen_down = mtmp->nmon;
X		mtmp->nmon = fmon;
X#ifdef WALKIES
X		mtmp->mleashed = 0;
X#endif
X		fmon = mtmp;
X		rloc(mtmp);
X	}
X}
X
Xkeepdogs(){
Xregister struct monst *mtmp;
X	for(mtmp = fmon; mtmp; mtmp = mtmp->nmon)
X	    if(dist(mtmp->mx,mtmp->my) < 3 && follower(mtmp)
X		&& !mtmp->msleep && !mtmp->mfroz) {
X#ifdef DGKMOD
X		/* Bug "fix" for worm changing levels collapsing dungeon
X		 */
X		if (mtmp->data->mlet == 'w') {
X			if (canseemon(mtmp) || (Blind && Telepat))
X				pline("The worm can't fit down the stairwell!");
X#ifdef WALKIES
X			pline("The leash slides off the slimy worm!");
X			mtmp->mleashed = 0;
X#endif
X			continue;
X		}
X#endif
X		relmon(mtmp);
X		mtmp->nmon = mydogs;
X		mydogs = mtmp;
X		unpmon(mtmp);
X		keepdogs();	/* we destroyed the link, so use recursion */
X		return;		/* (admittedly somewhat primitive) */
X	}
X}
X
Xfall_down(mtmp) register struct monst *mtmp; {
X	relmon(mtmp);
X	mtmp->nmon = fallen_down;
X	fallen_down = mtmp;
X#ifdef WALKIES
X	if (mtmp->mleashed)  {
X
X		pline("The leash comes off!");
X		mtmp->mleashed = 0;
X	}
X#endif
X	unpmon(mtmp);
X	mtmp->mtame = 0;
X}
X
X/* return quality of food; the lower the better */
Xdogfood(obj) register struct obj *obj; {
X	switch(obj->olet) {
X	case FOOD_SYM:
X	    return(
X		(obj->otyp == TRIPE_RATION) ? DOGFOOD :
X		(obj->otyp < CARROT) ? ACCFOOD :
X		(obj->otyp < CORPSE) ? MANFOOD :
X		(poisonous(obj) || obj->age + 50 <= moves ||
X		    obj->otyp == DEAD_COCKATRICE)
X			? POISON : CADAVER
X	    );
X	default:
X	    if(!obj->cursed) return(APPORT);
X	    /* fall into next case */
X	case BALL_SYM:
X	case CHAIN_SYM:
X	case ROCK_SYM:
X	    return(UNDEF);
X	}
X}
X
X/* return roomnumber or -1 */
Xinroom(x,y) xchar x,y; {
X#ifndef QUEST
X	register struct mkroom *croom = &rooms[0];
X	while(croom->hx >= 0){
X		if(croom->hx >= x-1 && croom->lx <= x+1 &&
X		   croom->hy >= y-1 && croom->ly <= y+1)
X			return(croom - rooms);
X		croom++;
X	}
X#endif
X	return(-1);	/* not in room or on door */
X}
X
Xtamedog(mtmp, obj)
Xregister struct monst *mtmp;
Xregister struct obj *obj;
X{
X	register struct monst *mtmp2;
X
X	/* worst case, at least he'll be peaceful. */
X	mtmp->mpeaceful = 1;
X	if(flags.moonphase == FULL_MOON && night() && rn2(6))
X		return(0);
X
X	/* If we cannot tame him, at least he's no longer afraid. */
X	mtmp->mflee = 0;
X	mtmp->mfleetim = 0;
X	if(mtmp->mtame || mtmp->mfroz ||
X#ifndef NOWORM
X	   mtmp->wormno ||
X#endif
X	   mtmp->isshk || mtmp->isgd || index(" @12", mtmp->data->mlet))
X		return(0);			/* no tame long worms? */
X	if(obj) {
X		if(dogfood(obj) >= MANFOOD) return(0);
X		if(cansee(mtmp->mx,mtmp->my)){
X			pline("%s devours the %s.", Monnam(mtmp),
X				objects[obj->otyp].oc_name);
X		}
X		obfree(obj, (struct obj *) 0);
X	}
X	mtmp2 = newmonst(sizeof(struct edog) + mtmp->mnamelth);
X	*mtmp2 = *mtmp;
X	mtmp2->mxlth = sizeof(struct edog);
X	if(mtmp->mnamelth) (void) strcpy(NAME(mtmp2), NAME(mtmp));
X	initedog(mtmp2);
X	replmon(mtmp,mtmp2);
X	return(1);
X}
END_OF_dog.c
if test 4576 -ne `wc -c <dog.c`; then
    echo shar: \"dog.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f help -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"help\"
else
echo shar: Extracting \"help\" \(5999 characters\)
sed "s/^X//" >help <<'END_OF_help'
X	Welcome to NetHack!		   ( description of version 1.0 )
X
X	NetHack is a Dungeons and Dragons like game where you (the adventurer)
Xdescend into the depths of the dungeon in search of the Amulet of Yendor
X(reputed to be hidden on the twentieth level).	You are accompanied by a
Xlittle dog that can help you in many ways and can be trained to do all
Xsorts of things. On the way you will find useful (or useless) items, (quite
Xpossibly with magic properties) and assorted monsters.	You attack a monster
Xby trying to move into the space a monster is in (but often it is much
Xwiser to leave it alone).
X
X	Unlike most adventure games, which give you a verbal description of
Xyour location, hack gives you a visual image of the dungeon level you are on.
X
X	Hack uses the following symbols:
X		A to Z and a to z:  monsters.  You can find out what a letter
Xrepresents by saying "/ (letter)", as in "/A", which will tell you that 'A'
Xis a giant ant.
X		- and |	 These form the walls of a room (or maze).
X		.  this is the floor of a room.
X		#  this is a corridor.
X		>  this is the staircase to the next level.
X		<  the staircase to the previous level.
X		`  A large boulder.
X		@  You (usually).
X		^  A trap.
X		)  A weapon of some sort.
X		(  Some other useful object (key, rope, dynamite, camera, ...)
X		[  A suit of armor.
X		%  A piece of food (not necessarily healthy ...).
X		/  A wand.
X		=  A ring.
X		?  A scroll.
X		!  A magic potion.
X		+  A spellbook containing a spell you can learn;
X		   (but usually a doorway).
X		}  A pool of water
X		{  A fountain (your dungeon may not have these).
X		\  An opulent throne (You may not have this either).
X		$  A pile or pot of gold.
X
XCommands:
X	Hack knows the following commands:
X	?	help: print this list.
X	Q	Quit the game.
X	S	Save the game.
X	!	Escape to a shell.
X	^Z	Suspend the game.
X	<	up: go up the staircase (if you are standing on it).
X	>	down: go down (just like up).
X	kjhlyubn - go one step in the direction indicated.
X		k: north (i.e., to the top of the screen),
X		j: south, h: west, l: east, y: ne, u: nw, b: se, n: sw.
X	KJHLYUBN - Go in that direction until you hit a wall or run
X		into something.
X	m	(followed by one of kjhlyubn): move without picking up
X		any objects.
X	M	(followed by one of KJHLYUBN): Move far, no pickup.
X	g	(followed by one of kjhlyubn): move until something
X		interesting is found.
X	G	(followed by one of KJHLYUBN): as previous, but forking
X		of corridors is not considered interesting.
X	i	print your inventory.
X	I	print selected parts of your inventory, like in
X		I* - print all gems in inventory;
X		IU - print all unpaid items;
X		IX - print all used up items that are on your shopping bill;
X		I$ - count your money.
X	s	search for secret doors and traps around you.
X	^	ask for the type of a trap you found earlier.
X	)	ask for current wielded weapon.
X	[	ask for current armor.
X	=	ask for current rings.
X	$	count how many gold pieces you are carrying.
X	.	rest, do nothing.
X	,	pick up some things.
X	:	look at what is here.
X	^T	teleport.
X	^R	redraw the screen.
X	^P	repeat last message
X		(subsequent ^P's repeat earlier messages).
X	/	(followed by any symbol): tell what this symbol represents.
X		If you see fancy graphics on your screen it may ask you to
X		specify a location rather than taking a symbol argument.
X	\	tell what has been discovered.
X	e	eat food.
X	w	wield weapon. w- means: wield nothing, use bare hands.
X	q	drink (quaff) a potion.
X	r	read a scroll.
X	P	Put on a ring.
X	R	Remove Ring.
X	W	Wear armor.
X	T	Takeoff armor.
X	A	Remove some or all armor.
X	X	transcribe (learn) a spell.
X	x	print a list of know spells.
X	z	zap a wand.
X	Z	cast a spell.
X	t	throw an object or shoot an arrow.
X	p	pay your shopping bill.
X	d	drop something. d7a: drop seven items of object a.
X	D	Drop several things.
X		In answer to the question "What kinds of things do you
X		want to drop? [!%= au]" you should give zero or more
X		object symbols possibly followed by 'a' and/or 'u'.
X		'a' means: drop all such objects, without asking for
X			confirmation.
X		'u' means: drop only unpaid objects (when in a shop).
X	a	use, apply - Generic command for using a key to lock
X		or unlock a door, using a camera, using a rope, etc.
X	c	call: name a certain object or class of objects.
X	C	Call: Name an individual monster.
X	E	Engrave: Write a message in the dust on the floor.
X		E- means: use fingers for writing.
X	O	Set options. You will be asked to enter an option line.
X		If this is empty, the current options are reported.
X		Otherwise it should be a list of options separated by commas.
X		Possible boolean options are: oneline, time, news, tombstone,
X		rest_on_space, fixinvlet, beginner, male, female.
X		They can be negated by prefixing them with '!' or "no".
X		A string option is name; it supplies the answer to the question
X		"Who are you?"; it may have a suffix.
X		A compound option is endgame; it is followed by a description
X		of what parts of the list of topscorers should be printed
X		when the game is finished.
X		Usually one will not want to use the 'O' command, but instead
X		put a HACKOPTIONS="...." line in one's environment.
X	v	prints the version number.
X	V	prints a longer identification of the version, including the
X		history of the game.
X	#	introduces one of the "extended" commands.  To get a list of
X		the commands you can use with "#" type "#?".  The extended
X		commands you can use depends upon what options the game was
X		compiled with, along with your class and what type of monster
X		you most closely resemble at a given moment.
X
X	You can put a number before a command to repeat it that many times,
X	as in "20s" or "40.".
X
X	At present, some information is displayed on the bottom line.
X	You see on what dungeon level you are, how many hit points you have
X	now (and will have when fully recovered), what your armor class is
X	(the lower the better), your strength, experience level and the
X	state of your stomach.	Optionally, you may or may not see other
X	information such as magical energy, how much gold you have, etc.
X
X	Have Fun, and Good Hacking!
X
X
X
END_OF_help
if test 5999 -ne `wc -c <help`; then
    echo shar: \"help\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f mkmaze.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"mkmaze.c\"
else
echo shar: Extracting \"mkmaze.c\" \(4441 characters\)
sed "s/^X//" >mkmaze.c <<'END_OF_mkmaze.c'
X/*	SCCS Id: @(#)mkmaze.c	2.3	88/03/31
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X
X#include "hack.h"
X#include "mkroom.h"		/* not really used */
Xextern struct monst *makemon(), *mkmon_at();
Xextern struct permonst pm_wizard;
Xextern struct obj *mkobj_at(), *mksobj_at();
Xstruct permonst hell_hound =
X	{ "hell hound", 'd', 12, 14, 2, 20, 3, 6, 0 };
X
Xmakemaz()
X{
X	int x,y;
X	register zx,zy;
X	coord mm;
X	boolean al = (dlevel >= 30 && !flags.made_amulet);
X
X	for(x = 2; x < COLNO-1; x++)
X		for(y = 2; y < ROWNO-1; y++)
X			levl[x][y].typ = (x%2 && y%2) ? 0 : HWALL;
X#ifndef RPH
X	if(al) {
X#else	/* make decoy wizard levels */
X	if((dlevel == u.wiz_level) ||
X	   (!rn2(3) && (dlevel > u.medusa_level+1))) {
X#endif
X	    register struct monst *mtmp;
X
X	    zx = 2*(COLNO/4) - 1;
X	    zy = 2*(ROWNO/4) - 1;
X	    for(x = zx-2; x < zx+4; x++) for(y = zy-2; y <= zy+2; y++) {
X		levl[x][y].typ =
X		    (y == zy-2 || y == zy+2 || x == zx-2 || x == zx+3) ? POOL :
X		    (y == zy-1 || y == zy+1 || x == zx-1 || x == zx+2) ? HWALL:
X		    ROOM;
X	    }
X#ifdef RPH
X	    if (dlevel == u.wiz_level) {
X#endif		
X		    (void) mkobj_at(AMULET_SYM, zx, zy);
X		    flags.made_amulet = 1;
X		    walkfrom(zx+4, zy);
X		    if(mtmp = makemon(&hell_hound, zx, zy))
X			mtmp->msleep = 1;
X		    if(mtmp = makemon(PM_WIZARD, zx+1, zy)) {
X			mtmp->msleep = 1;
X			flags.no_of_wizards = 1;
X		    }
X#ifdef RPH
X	    } else {
X		struct obj *ot;
X	    	/* make a cheap plastic imitation */
X	    	if (ot = mkobj_at(AMULET_SYM, zx, zy))
X		    ot-> spe = -1;
X		walkfrom(zx+4,zy);
X		if (mtmp = makemon(&hell_hound, zx, zy))
X		    mtmp->msleep = 1;
X		mkmon_at ('&', zx+1,zy);
X	    }
X#endif
X	} else {
X	    mazexy(&mm);
X	    zx = mm.x;
X	    zy = mm.y;
X	    walkfrom(zx,zy);
X#ifdef RPH
X	    if (!rn2(10) || (dlevel == u.medusa_level + 1))
X#endif
X		(void) mksobj_at(WAN_WISHING, zx, zy);
X	    (void) mkobj_at(ROCK_SYM, zx, zy);	/* put a rock on top of it */
X	}
X
X	for(x = 2; x < COLNO-1; x++)
X		for(y = 2; y < ROWNO-1; y++) {
X			switch(levl[x][y].typ) {
X			case HWALL:
X				levl[x][y].scrsym = HWALL_SYM;
X				break;
X			case ROOM:
X				levl[x][y].scrsym = ROOM_SYM;
X				break;
X			}
X		}
X	for(x = rn1(8,11); x; x--) {
X		mazexy(&mm);
X		(void) mkobj_at(rn2(2) ? GEM_SYM : 0, mm.x, mm.y);
X	}
X	for(x = rn1(10,2); x; x--) {
X		mazexy(&mm);
X		(void) mkobj_at(ROCK_SYM, mm.x, mm.y);
X	}
X	mazexy(&mm);
X	(void) makemon(PM_MINOTAUR, mm.x, mm.y);
X	for(x = rn1(5,7); x; x--) {
X		mazexy(&mm);
X		(void) makemon((struct permonst *) 0, mm.x, mm.y);
X	}
X	for(x = rn1(6,7); x; x--) {
X		mazexy(&mm);
X		mkgold(0L,mm.x,mm.y);
X	}
X	for(x = rn1(6,7); x; x--)
X		mktrap(0,1,(struct mkroom *) 0);
X	mazexy(&mm);
X	levl[(xupstair = mm.x)][(yupstair = mm.y)].scrsym = UP_SYM;
X	levl[xupstair][yupstair].typ = STAIRS;
X	xdnstair = ydnstair = 0;
X}
X
X#ifdef DGK
X/* Make the mazewalk iterative by faking a stack.  This is needed to
X * ensure the mazewalk is successful in the limited stack space of
X * the program.  This iterative version uses the mimumum amount of stack
X * that is totally safe.
X */
Xwalkfrom(x,y)
Xint x,y;
X{
X#define CELLS (ROWNO * COLNO) / 4		/* a maze cell is 4 squares */
X	char mazex[CELLS + 1], mazey[CELLS + 1];	/* char's are OK */
X	int q, a, dir, pos;
X	int dirs[4];
X
X	pos = 1;
X	mazex[pos] = (char) x;
X	mazey[pos] = (char) y;
X	while (pos) {
X		x = (int) mazex[pos];
X		y = (int) mazey[pos];
X		levl[x][y].typ = ROOM;
X		q = 0;
X		for (a = 0; a < 4; a++)
X			if(okay(x, y, a)) dirs[q++]= a;
X		if (!q)
X			pos--;
X		else {
X			dir = dirs[rn2(q)];
X			move(&x, &y, dir);
X			levl[x][y].typ = ROOM;
X			move(&x, &y, dir);
X			pos++;
X			if (pos > CELLS)
X				panic("Overflow in walkfrom");
X			mazex[pos] = (char) x;
X			mazey[pos] = (char) y;
X		}
X	}
X}
X#else
X
Xwalkfrom(x,y) int x,y; {
Xregister int q,a,dir;
Xint dirs[4];
X	levl[x][y].typ = ROOM;
X	while(1) {
X		q = 0;
X		for(a = 0; a < 4; a++)
X			if(okay(x,y,a)) dirs[q++]= a;
X		if(!q) return;
X		dir = dirs[rn2(q)];
X		move(&x,&y,dir);
X		levl[x][y].typ = ROOM;
X		move(&x,&y,dir);
X		walkfrom(x,y);
X	}
X}
X#endif /* DGK /**/
X
Xmove(x,y,dir)
Xregister int *x, *y;
Xregister int dir;
X{
X	switch(dir){
X		case 0: --(*y); break;
X		case 1: (*x)++; break;
X		case 2: (*y)++; break;
X		case 3: --(*x); break;
X	}
X}
X
Xokay(x,y,dir)
Xint x,y;
Xregister int dir;
X{
X	move(&x,&y,dir);
X	move(&x,&y,dir);
X	if(x<3 || y<3 || x>COLNO-3 || y>ROWNO-3 || levl[x][y].typ != 0)
X		return(0);
X	else
X		return(1);
X}
X
Xmazexy(cc)
Xcoord	*cc;
X{
X	cc->x = 3 + 2*rn2(COLNO/2 - 2);
X	cc->y = 3 + 2*rn2(ROWNO/2 - 2);
X	return(0);
X}
END_OF_mkmaze.c
if test 4441 -ne `wc -c <mkmaze.c`; then
    echo shar: \"mkmaze.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f mkobj.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"mkobj.c\"
else
echo shar: Extracting \"mkobj.c\" \(4271 characters\)
sed "s/^X//" >mkobj.c <<'END_OF_mkobj.c'
X/*	SCCS Id: @(#)mkobj.c	2.3	88/02/11
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X
X#include "hack.h"
X#ifdef SPELLS
Xchar mkobjstr[] = "))[[!!!!????+%%%%/=**))[[!!!!????+%%%%/=**(%";
X#else
Xchar mkobjstr[] = "))[[!!!!????%%%%/=**))[[!!!!????%%%%/=**(%";
X#endif
X
Xstruct obj *mkobj(), *mksobj();
X
Xstruct obj *
Xmkobj_at(let,x,y)
Xregister int let,x,y;
X{
X	register struct obj *otmp = mkobj(let);
X	otmp->ox = x;
X	otmp->oy = y;
X	otmp->nobj = fobj;
X	fobj = otmp;
X	return(otmp);
X}
X
Xstruct obj *
Xmksobj_at(otyp,x,y)
Xregister int otyp,x,y;
X{
X	register struct obj *otmp = mksobj(otyp);
X	otmp->ox = x;
X	otmp->oy = y;
X	otmp->nobj = fobj;
X	return((fobj = otmp));
X}
X
X#ifdef RPH
Xstruct obj *
Xmk_named_obj_at (let, x, y, nm, lth)	/* used for named corpses */
Xregister let, x, y;
Xchar * nm;
Xregister int lth;
X{
X	register struct obj *otmp;
X	register struct obj *obj2;
X
X	if (lth == 0)  return (mkobj_at (let,x,y));
X
X	otmp =  mkobj(let);
X	obj2 = newobj(lth);
X	*obj2 = *otmp;
X	obj2->onamelth = lth;
X	(void) strcpy (ONAME(obj2), nm);
X	free( (char *)otmp);
X	obj2->ox = x;
X	obj2->oy = y;
X	obj2->nobj = fobj;
X	fobj = obj2;
X	return(obj2);
X}
X#endif
X
Xstruct obj *
Xmkobj(let) {
Xint realtype;
X	switch (let) {
X		case RANDOM_SYM: {
X			realtype=probtype(mkobjstr[rn2(sizeof(mkobjstr)-1)]);
X			break;
X		}
X		case '3': { realtype = DEAD_SOLDIER; break; }
X		case '9': { realtype = DEAD_GIANT; break; }
X		case '&': { realtype = DEAD_DEMON; break; }
X		default: realtype = letter(let) ?
X				CORPSE + ((let>'Z') ? (let-'a'+'Z'-'@'+1) : (let-'@'))
X			:	probtype(let);
X	}
X	return(mksobj(realtype));
X}
X	
X
Xstruct obj zeroobj;
X
Xstruct obj *
Xmksobj(otyp)
Xregister otyp;
X{
X	register struct obj *otmp;
X	char let = objects[otyp].oc_olet;
X
X	otmp = newobj(0);
X	*otmp = zeroobj;
X	otmp->age = moves;
X	otmp->o_id = flags.ident++;
X	otmp->quan = 1;
X	otmp->olet = let;
X	otmp->otyp = otyp;
X	otmp->dknown = index(
X#ifdef KAA
X#ifdef SPELLS
X	"/=!?*+)",
X#else
X	"/=!?*)",
X#endif
X#else
X#ifdef SPELLS
X	"/=!?*+",
X#else
X	"/=!?*",
X#endif
X#endif
X		    let) ? 0 : 1;
X	switch(let) {
X	case WEAPON_SYM:
X		otmp->quan = (otmp->otyp <= ROCK) ? rn1(6,6) : 1;
X		if(!rn2(11)) otmp->spe = rne(2);
X		else if(!rn2(10)) {
X			otmp->cursed = 1;
X			otmp->spe = -rne(2);
X		}
X		break;
X	case FOOD_SYM:
X		if(otmp->otyp >= CORPSE) break;
X#ifdef NOT_YET_IMPLEMENTED
X		/* if tins are to be identified, need to adapt doname() etc */
X		if(otmp->otyp == TIN)
X			otmp->spe = rnd(...);
X#endif
X		/* fall into next case */
X	case GEM_SYM:
X		otmp->quan = rn2(6) ? 1 : 2;
X	case TOOL_SYM:
X		if(otmp->otyp == LAMP) otmp->spe = rnd(10);
X		else if(otmp->otyp == MAGIC_LAMP) otmp->spe = 1;
X		else if(otmp->otyp == MAGIC_MARKER) otmp->spe = rnd(100);
X	case CHAIN_SYM:
X	case BALL_SYM:
X	case ROCK_SYM:
X	case POTION_SYM:
X	case SCROLL_SYM:
X	case AMULET_SYM:
X		break;
X#ifdef SPELLS
X	case SPBOOK_SYM:
X		if(!rn2(17)) otmp->cursed = 1;
X		break;
X#endif
X	case ARMOR_SYM:
X		if(!rn2(8)) otmp->cursed = 1;
X		if(!rn2(10)) otmp->spe = rne(2);
X		else if(!rn2(9)) {
X			otmp->spe = -rne(2);
X			otmp->cursed = 1;
X		}
X		break;
X	case WAND_SYM:
X#ifdef HARD
X		if(otmp->otyp == WAN_WISHING) otmp->spe = rnd(3); else
X#else		
X		if(otmp->otyp == WAN_WISHING) otmp->spe = 3; else
X#endif		
X		otmp->spe = rn1(5,
X			(objects[otmp->otyp].bits & NODIR) ? 11 : 4);
X		break;
X	case RING_SYM:
X		if(objects[otmp->otyp].bits & SPEC) {
X			if(!rn2(3)) {
X				otmp->cursed = 1;
X				otmp->spe = -rne(3);
X			} else otmp->spe = rne(3);
X		} else if(otmp->otyp == RIN_TELEPORTATION ||
X			  otmp->otyp == RIN_POLYMORPH ||
X			  otmp->otyp == RIN_AGGRAVATE_MONSTER ||
X			  otmp->otyp == RIN_HUNGER || !rn2(9))
X			otmp->cursed = 1;
X		break;
X	default:
X		panic("impossible mkobj %d, sym '%c'.", otmp->otyp, let);
X	}
X	otmp->owt = weight(otmp);
X	return(otmp);
X}
X
Xletter(c) {
X	return(('@' <= c && c <= 'Z') || ('a' <= c && c <= 'z'));
X}
X
Xweight(obj)
Xregister struct obj *obj;
X{
Xregister int wt = objects[obj->otyp].oc_weight;
X	return(wt ? wt*obj->quan : (obj->quan + 1)/2);
X}
X
Xmkgold(num,x,y)
Xregister long num;
X{
X	register struct gold *gold;
X	register long amount = (num ? num : 1 + (rnd(dlevel+2) * rnd(30)));
X
X	if(gold = g_at(x,y))
X		gold->amount += amount;
X	else {
X		gold = newgold();
X		gold->ngold = fgold;
X		gold->gx = x;
X		gold->gy = y;
X		gold->amount = amount;
X		fgold = gold;
X		/* do sth with display? */
X	}
X}
END_OF_mkobj.c
if test 4271 -ne `wc -c <mkobj.c`; then
    echo shar: \"mkobj.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f monst.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"monst.c\"
else
echo shar: Extracting \"monst.c\" \(4477 characters\)
sed "s/^X//" >monst.c <<'END_OF_monst.c'
X/*	SCCS Id: @(#)monst.c	2.3	87/12/16
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X
X#include "hack.h"
X#include "eshk.h"
X#include "edog.h"
Xextern char plname[PL_NSIZ];
X
Xstruct permonst mons[CMNUM+2] = {
X	{ "bat",		'B',  1, 22, 8,  0, 1,  4, 0 },
X	{ "gnome",		'G',  1,  6, 5,  0, 1,  6, 0 },
X	{ "hobgoblin",		'H',  1,  9, 5,  0, 1,  8, 0 },
X	{ "jackal",		'J',  0, 12, 7,  0, 1,  2, 0 },
X#ifdef KOPS
X	{ "Keystone Kop",       'K',  1,  6, 7, 10, 1,  4, 0 },
X#else
X	{ "kobold",		'K',  1,  6, 7,  0, 1,  4, 0 },
X#endif
X#ifndef ROCKMOLE
X	{ "giant rat",		'r',  0, 12, 7,  0, 1,  3, 0 },
X#endif
X	{ "acid blob",		'a',  2,  3, 8,  0, 0,  0, 0 },
X	{ "floating eye",	'E',  2,  1, 9, 10, 0,  0, 0 },
X	{ "homunculus",		'h',  2,  6, 6, 10, 1,  3, 0 },
X	{ "imp",		'i',  2,  6, 2, 20, 1,  4, 0 },
X	{ "leprechaun",		'L',  5, 15, 8, 20, 1,  2, 0 },
X	{ "orc",		'O',  2,  9, 6,  0, 1,  8, 0 },
X	{ "yellow light",	'y',  3, 15, 0,  0, 0,  0, 0 },
X	{ "zombie",		'Z',  2,  6, 8,  0, 1,  8, 0 },
X	{ "giant ant",		'A',  3, 18, 3,  0, 1,  6, 0 },
X#ifdef ROCKMOLE
X	{ "rock mole",          'r',  3,  3, 0, 20, 1,  6, 0 },
X#endif
X	{ "fog cloud",		'f',  3,  1, 0,  0, 1,  6, 0 },
X	{ "nymph",		'N',  6, 12, 9, 20, 1,  2, 0 },
X	{ "piercer",		'p',  3,  1, 3,  0, 2,  6, 0 },
X#ifdef KAA
X	{ "quantum mechanic",	'Q',  6, 12, 3, 10, 1,  4, 0 },
X#else
X	{ "quasit",		'Q',  3, 15, 3, 20, 1,  4, 0 },
X#endif
X	{ "quivering blob",	'q',  3,  1, 8,  0, 1,  8, 0 },
X#ifdef KAA
X	{ "violet fungus",	'v',  3,  1, 7,  0, 1,  4, 0 },
X#else
X	{ "violet fungi",	'v',  3,  1, 7,  0, 1,  4, 0 },
X#endif
X	{ "giant beetle",	'b',  4,  6, 4,  0, 3,  4, 0 },
X	{ "centaur",		'C',  4, 18, 4, 10, 1,  6, 0 },
X	{ "cockatrice",		'c',  4,  6, 6, 30, 1,  3, 0 },
X	{ "gelatinous cube",	'g',  4,  6, 8,  0, 2,  4, 0 },
X	{ "jaguar",		'j',  4, 15, 6,  0, 1,  8, 0 },
X	{ "killer bee",		'k',  4, 14, 4,  0, 2,  4, 0 },
X	{ "snake",		'S',  4, 15, 3,  0, 1,  6, 0 },
X	{ "freezing sphere",	'F',  2, 13, 4,  0, 0,  0, 0 },
X	{ "owlbear",		'o',  5, 12, 5,  0, 2,  6, 0 },
X	{ "rust monster",	'R', 10, 18, 3,  0, 0,  0, 0 },
X#ifdef SPIDERS
X	{ "giant spider",	's',  5, 15, 3,  0, 1,  4, 0 },
X#else
X	{ "scorpion",		's',  5, 15, 3,  0, 1,  4, 0 },
X#endif
X	{ "tengu",		't',  5, 13, 5, 30, 1,  7, 0 },
X	{ "wraith",		'W',  5, 12, 5, 15, 1,  6, 0 },
X#ifdef NOWORM
X	{ "wumpus",		'w',  8,  3, 2, 10, 3,  6, 0 },
X#else
X	{ "long worm",		'w',  8,  3, 5, 10, 1,  4, 0 },
X#endif
X	{ "large dog",		'd',  6, 15, 4,  0, 2,  4, 0 },
X	{ "leocrotta",		'l',  6, 18, 4, 10, 3,  6, 0 },
X	{ "mimic",		'M',  7,  3, 7,  0, 3,  4, 0 },
X	{ "troll",		'T',  7, 12, 4,  0, 2,  7, 0 },
X	{ "unicorn",		'u',  8, 24, 5, 70, 1, 10, 0 },
X	{ "yeti",		'Y',  5, 15, 6,  0, 1,  6, 0 },
X	{ "stalker",		'I',  8, 12, 3,  0, 4,  4, 0 },
X	{ "umber hulk",		'U',  9,  6, 2, 25, 2, 10, 0 },
X	{ "vampire",		'V',  8, 12, 1, 25, 1,  6, 0 },
X	{ "xorn",		'X',  8,  9,-2, 20, 4,  6, 0 },
X	{ "xan",		'x',  7, 18,-2,  0, 2,  4, 0 },
X	{ "zruty",		'z',  9,  8, 3,  0, 3,  6, 0 },
X	{ "chameleon",		':',  6,  5, 6, 10, 4,  2, 0 },
X	{ "giant",		'9',  9, 18, 5,  0, 2, 12, 0 },
X	{ "dragon",		'D', 10,  9,-1, 20, 3,  8, 0 },
X	{ "ettin",		'e', 10, 12, 3,  0, 2,  8, 0 },
X	{ "lurker above",	'\'',10,  3, 3,  0, 0,  0, 0 },
X	{ "nurse",		'n', 11,  6, 0,  0, 2,  6, 0 },
X	{ "trapper",		',', 12,  3, 3,  0, 0,  0, 0 },
X	{ "purple worm",	'P', 15,  9, 6, 20, 2,  8, 0 },
X	{ "demon",		'&', 10, 12,-4, 30, 1,  4, 0 },
X	{ "minotaur",		'm', 15, 15, 6,  0, 4, 10, 0 },
X	{ "shopkeeper", 	'@', 12, 18, 0, 50, 4,  8, sizeof(struct eshk) }
X};
X
Xstruct permonst pm_ghost = { "ghost", ' ', 10, 3, -5, 50, 1, 1, sizeof(plname) };
X#ifdef SAC
Xstruct permonst pm_soldier = { "soldier", '3', 12, 4, -3, 15, 10, 4, 0 };
Xstruct permonst pm_wizard = { "wizard of Yendor", '1', 20, 12, -8, 100, 2, 12, 0 };
X#else
Xstruct permonst pm_wizard = { "wizard of Yendor", '1', 15, 12, -2, 70, 1, 12, 0 };
X#endif
X#ifdef RPH
Xstruct permonst pm_medusa = {"medusa", '8', 15, 12, 2, 50, 1, 8, 0};
X#endif
X#ifdef MAIL
Xstruct permonst pm_mail_daemon = { "mail daemon", '2', 100, 1, 10, 127, 0, 0, 0 };
X#endif
Xstruct permonst pm_eel    = {"electric eel", ';', 15, 6, -3, 0, 3, 6, 0};
Xstruct permonst pm_djinni = {"djinni",  '&', 10, 12, 0, 30, 2, 8, 0};
Xstruct permonst pm_gremlin= {"gremlin", 'G', 3, 12, 2, 25, 1, 8, 0};
X#ifdef STOOGES
Xstruct permonst pm_larry  = {"Larry",   '@', 3, 12, 10, 0, 1, 6, 0};
Xstruct permonst pm_curly  = {"Curly",   '@', 3, 12, 10, 0, 1, 6, 0};
Xstruct permonst pm_moe    = {"Moe",     '@', 3, 12, 10, 0, 1, 6, 0};
X#endif
END_OF_monst.c
if test 4477 -ne `wc -c <monst.c`; then
    echo shar: \"monst.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f nansi_sys.uu -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"nansi_sys.uu\"
else
echo shar: Extracting \"nansi_sys.uu\" \(3476 characters\)
sed "s/^X//" >nansi_sys.uu <<'END_OF_nansi_sys.uu'
Xbegin 644 ./nansi.sys
XM_____Q.`RP#6`$-/3B`@("`@&ULR2DYA;G-I+G-Y<R!V,BXR.B!.97<@04Y3
XM22!D<FEV97(@*$,I($1A;FEE;"!+96=E;"P@4&%S861E;F$L($-!(#$Y.#8-
XM"AH``````0```QA/```````'```````````````#````````````6QL``'@`
XM````````=P``````H64`B]BT`)**Q[0`*]!"BL/^P/8F9P`"QX#4``/`E\-P
XM"2,!(P$?`28!-0%)`50!F`&8`2,!(P$NB1Y<`"Z,!EX`R_M04U%25597'@8N
XMQ1Y<`(I'`L1W#HM/$CP,=R"3T>.,R([8_Y>S`"[%'EP`#0`!B4<#!Q]?7EU:
XM65M8R^@*`.OF+L<&BP`!`,^X$PC#,\##XPJ+_E'HXP)9JN+X,\##Z",#=`O%
XM'EP`B$<-,\#K`[@``L/H#P.X``)T`C/`PS/`HX,`HX<`HXL`HX\`N$``CL`F
XMH1H`)J,<`#/`PP#['@904U%25597N0$`C,N.PX[;OG(!B`3H"@!?7EU:65M8
XM!Q_/C`9O`+A``([8H4D`+J)C`/[,+H@F90"@8@"8`\"3BX=0`"ZC9@"A8P`N
XMHW,`H4X`T>C1Z-'HT>B`Q+`N@#YC``=T`X#$"`X?HVT`CL#HJ_[H%`%R`^B?
XM`8L>=0"*)FL`CAYO`/SC(RZ#/F$``'50Z/4`<@/I#`&L/!QR(B[7JTK@]70$
XMZP3@YW1HC,B.V*!E`/[`*L*B9@#H+0$SP,,\&W0:/`UT+SP*=&`\"70+/`AT
XM$#P'=!CIP@#K>9#II`+IE`(N.A9E`'<#3T]"Z[CH(@(*P.NQ+J!E`/[`*L*T
XM`"OX*_@NBA9E`$(NBB9K``P!ZY1!+O8&8``!=05/3T+KABZ*%F4`0BOZ*_HN
XMH&0`+C@&9P!R!>@%`>L0+OX&9P`NH&4`M`!``\`#^"Z*)FL`#`'I4O\NH&4`
XM_L`JPE&U`(K(@.$']MF`P0@KT9RP(.@6`','\ZN=6>DL_P/1Z#P`2N+ZG5GI
XM'_\N@#YC``1R"BZ`/F,`!W0"^,/YP^CI_W,(Z?G^K#P<<@TNU^@.`$K@\W0&
XMZ?7^Z0;_Z5?_4E%34"Z@90#^P"K"+J)F`"Z+%F8`,]NT`LT0N0$`6%"*W+<`
XMM`G-$%A;65K#Z)S_<RJ+W]'KBQ9S`+`.[NL`0HK'[NL`2K`/[NL`0HK#[KA`
XM`([8+J%F`*-0`,.X%H_HGO_#M`#H9/]S%RZ*)FL`@.1_+H`^8P`'=0>`_`%U
XM`K0'PU!345+HVO^*_+`!M`:Q`+4`+HH690`NBC9D`,T06EE;6,.+-N`$"L!T
XM`K0`.S;>!'8.BPP[1/YT"X/N!"OQZ^P+]NL'@^X"*_$ZP,.Y!`"[?P"#PP2+
XM-POVX??#Z.W_="G_#TZ+;P(^B@*#[@%R&8'[@P!T$PK`=0__#SZ*(L<&@P`!
XM`(@F>`#K&[0`S18+P'3XZ(W_=0J)#H\`B3:1`.N[/`!TV</HH_]T"4Z+;P(^
XMB@+K&K0!S19T%PO`=0:T`,T6Z_#H6_]U!0/QBD3_@,P!PQ0%`P!04U%25597
XML+:Z0P#N2BZAAP3K`.Z&X.L`[KIA`.L`[%`,`^L`[@:X0`".P":+'FP`+@,>
XMB02Y__\FH6P`.\-_`N+V!U@D_.Y?7EU:65M8PP``,#`P,#`NB1YQ`"ZC80#I
XM-/TNBQYQ`"[_)F$`Z9D`X@6X`@7KX*P\6W7Q+HL>W`0NQ@<`+L8&VP0`X@6X
XM'07KQ:P\/70'/#]T`T[K!^(%N#`%Z[*L/#!R%CPY=Q(L,"Z(!R[&!ML$`>)B
XMN*@%ZY<\(G0$/"=U="ZB:@#B!;A>!>N$K"XZ!FH`=!,NB`<N.Q[>!(/3`.+K
XMN%X%Z6G_+L8'`.(&N(4%Z5W_K#P[=`)!3N*BN#`%Z4[_+L<&80```"Z*)FL`
XM+HL>=0#I:_VL/#!R&CPY=Q8L,"Z&!U*R"O;B6BX`!^+GN*@%Z1O_/#MU$"X[
XM'MX$@],`+L8&VP0`ZYX\0'*U/'IWL3Q:=@8\87*I+`9641X.'RQ`F`/`!44&
XMB\LNBS;<!"O.+O8&VP0!=`%!DZ!E`$`JPJ)F`+0`K`K`=0%`_Q<?65XNBB9K
XM`"Z+'G4`+L<&80````O2Z>7[U`H%,#"&X*J&X*K#30@`!_H&YP;M!J\&KP:O
XM!K`&KP9/!T8'(P@?"*\&KP91"*\&KP:O!J\&KP:O!J\&KP:O!J\&KP:O!J\&
XMKP:O!K`&KP:2"*\&KP:O!@H)'`=S!Z\&J`>O!J\&#0>O!A0'KP:O!J\&#@FO
XM!L,*P'0!2*)G`#/`@_D"<@:L"L!T`4BB9@"A9@`Z!F4`=@:@90"B9@`Z)F0`
XM=@:@9`"B9P#HK?G#``9F`.O;*`9F`',%Q@9F``#KS@`&9P#KR"@&9P!S!<8&
XM9P``Z[NA9@"C:`##H6@`HV8`ZZQ."\EU!,8$`$&L4;D6`)"[*PF#PP,Z!^#Y
XM=0N+1P$@!FL`""9K`%GBX,-2BPYF`(KUZQ0\`G4?QP9F````Z#?Y4C/)BC9D
XM`.@P_(K\BA9E`+@`!LT06L-74@:,R([`_;^``*!G`/[`Z+/^L#NJH&8`_L#H
XMJ/ZP4JJP#8D^B0"JN((`*\>CAP#\!UI?PPO)=%G\3DE)K0K`=`)!3E<&45;]
XM'@?H%OQU%H/!!(LNW@0!#MX$3HO^`_F+SBO-\Z1>68L^W@2#[P2+WRO9@^L0
XM.Q[<!'(2B4T#B44!XP:D@\8"XOJ)/MX$!U_\PP8>!_V+/N`$N`$`J[@`<JNP
XM$*J)/MX$!^ODM`;K`K0'BCYD`"H^9P`ZQW8"L`!0Z%_[BOQ8L0"*+F<`4HH6
XM90"*-F0`S1!:P[4!ZP*U`.BI^G,Y.L)V`HK"5Y&+Z;4`B_<#\0/Q]MD"RK4`
XM_/;$`70,A_[]B\%(`\`#^`/P!A_SI8O-Z`O[L"#SJ_Q?P['_/`=U!H@.8`#K
XM:SPK=4*T$KL0_\T0]\/\_G5:Z$WZ<U6T`*!C`,T0N!(1LP#-$+@`$K,@S1"T
XM`;D'!\T0BQ9S`+`*[NL`0K`'[L8&9``JZPFT`,T0Q@9D`!BX0``>CMBA20`?
XMHF,`_LR()F4`QP9F````Z(KWP[$`ZX:+'G4`XP].K4EU`HK@`MB`UP"()\,S
XMP(@'0_[`=?GK]```!P'_"`3X`07_@`?X<`B(`![X`!_X!"#X`B'X!B+X`2/X
XM!23X`R7X!RB/`"F/0"J/("N/8"R/$"V/4"Z/,"^/<#/`CMB[;`#'!Q<!C$\"
XMNZ0`QP=S`8Q/`@X?#@?\OW`)B3[<!(''``*)/MX$1[`0JK@`<JNX`0")/N`$
X9JXD^=0`SP*K^P'7[,\#%-EP`B7P.C$P0PP*)
X`
Xend
END_OF_nansi_sys.uu
if test 3476 -ne `wc -c <nansi_sys.uu`; then
    echo shar: \"nansi_sys.uu\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f nethack.6 -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"nethack.6\"
else
echo shar: Extracting \"nethack.6\" \(4669 characters\)
sed "s/^X//" >nethack.6 <<'END_OF_nethack.6'
X.TH NETHACK 6 "21 September 1987"
X.UC 4
X.SH NAME
Xhack \- Exploring The Mazes of Menace
X.SH SYNOPSIS
X.B /usr/games/net[hack quest]
X[
X.B \-d
X.I directory
X]
X[
X.B \-n
X]
X[
X.B \-u
X.I playername
X]
X.br
X.B /usr/games/net[hack quest]
X[
X.B \-d
X.I directory
X]
X.B \-s
X[
X.B \-X
X]
X[
X.I playernames
X]
X.SH DESCRIPTION
X.PP
X.I NetHack
Xis a display oriented Dungeons & Dragons(tm) - like game.
XBoth display and command structure resemble rogue.
X(For a game with the same structure but entirely different display -
Xa real cave instead of dull rectangles - try NetQuest.)
X.PP
XTo get started you really only need to know two commands.  The command
X.B ?
Xwill give you a list of the available commands and the command
X.B /
Xwill identify the things you see on the screen.
X.PP
XTo win the game (as opposed to merely playing to beat other people high
Xscores) you must locate the Amulet of Yendor which is somewhere below
Xthe 20th level of the dungeon and get it out.  Nobody has achieved this
Xyet and if somebody does, he will probably go down in history as a hero
Xamong heros.
X.PP
XWhen the game ends, either by your death, when you quit, or if you escape
Xfrom the caves,
X.I hack
Xwill give you (a fragment of) the list of top scorers.  The scoring
Xis based on many aspects of your behavior but a rough estimate is
Xobtained by taking the amount of gold you've found in the cave plus four
Xtimes your (real) experience. Precious stones may be worth a lot of gold
Xwhen brought to the exit.
XThere is a 10% penalty for getting yourself killed.
X.PP
XThe administration of the game is kept in the directory specified with the
X.B \-d
Xoption, or, if no such option is given, in the directory specified by
Xthe environment variable HACKDIR, or, if no such variable exists, in
Xthe current directory. This same directory contains several auxiliary
Xfiles such as lockfiles and the list of topscorers and a subdirectory
X.I save
Xwhere games are saved.
XThe game administrator may however choose to install hack with a fixed
Xplaying ground, usually /usr/games/lib/nethackdir.
X.PP
XThe
X.B \-n
Xoption suppresses printing of the news.
X.PP
XThe
X.B \-u
X.I playername
Xoption supplies the answer to the question "Who are you?".
XWhen
X.I playername
Xhas as suffix one of
X.B \-T \-S \-K \-F \-C \-W \-N \-A \-P \-V \-E \-H
Xthen this supplies the answer to the question "What kind of character ... ?".
X.PP
XThe
X.B \-s
Xoption will print out the list of your scores. It may be followed by arguments
X.B \-X
Xwhere X is one of the letters C, B, K, S, T, W, N, A, P, V, E, H to print the
Xscores of Cave(wo)men, Barbarians, Knights, Samurai, Tourists, Wizards,
XNinjas, Archaeologists, Priest(esse)s, Valkyries, Elves, or Healers.
XIt may also be followed by one or more player names to print the scores of the
Xplayers mentioned.
X.SH AUTHORS
X.PP
XJay Fenlason (+ Kenny Woodland, Mike Thome and Jon Payne) wrote the
Xoriginal hack, very much like rogue (but full of bugs).
X.PP
XAndries Brouwer continuously deformed their sources into the current
Xversion - in fact an entirely different game.
X.PP
XMike Stephenson has continued the perversion of sources adding various
Xwarped character classes and sadistic traps with the help of many strange
Xpeople who reside in that place between the worlds, the Usenet Zone.
X.PP
XDon Kneller, Gil Neiger, Scott Turner and Ken Arromdee deserve special
Xmention in this regard.
X.PP
XThe resulting mess is now called NetHack (or NetQuest), to denote its
Xdevelopment by the Usenet.  Andries Brouwer has made this request for the
Xdistinction, as he may eventually release a new version of his own.
X.SH FILES
X.DT
X.ta \w'data, rumors\ \ \ 'u
Xnethack		The hack program.
X.br
Xnetquest	The quest program.
X.br
Xdata, rumors	Data files used by hack.
X.br
Xhelp, hh	Help data files.
X.br
Xrecord	The list of topscorers.
X.br
Xsave	A subdirectory containing the saved
X.br
X	games.
X.br
Xbones_dd	Descriptions of the ghost and
X.br
X	belongings of a deceased adventurer.
X.br
Xxlock.dd	Description of a dungeon level.
X.br
Xsafelock	Lock file for xlock.
X.br
Xrecord_lock	Lock file for record.
X.SH ENVIRONMENT
X.DT
X.ta \w'HACKPAGER, PAGER\ \ \ 'u
XUSER or LOGNAME	Your login name.
X.br
XHOME		Your home directory.
X.br
XSHELL		Your shell.
X.br
XTERM		The type of your terminal.
X.br
XHACKPAGER, PAGER	Pager used instead of default pager.
X.br
XMAIL	Mailbox file.
X.br
XMAILREADER	Reader used instead of default
X.br
X	(probably /bin/mail or /usr/ucb/mail).
X.br
XHACKDIR	Playground.
X.br
XHACKOPTIONS	String predefining several hack options
X.br
X	(see help file).
X.br
X
XSeveral other environment variables are used in debugging (wizard) mode,
Xlike GENOCIDED, INVENT, MAGIC and SHOPTYPE.
X.SH BUGS
X.PP
XProbably infinite.
X.PP
XDungeons & Dragons is a Trademark of TSR Inc.
END_OF_nethack.6
if test 4669 -ne `wc -c <nethack.6`; then
    echo shar: \"nethack.6\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f pctty.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"pctty.c\"
else
echo shar: Extracting \"pctty.c\" \(5791 characters\)
sed "s/^X//" >pctty.c <<'END_OF_pctty.c'
X/*	SCCS Id: @(#)pctty.c	2.3	87/12/12
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* tty.c - (PC) version */
X
X/* With thanks to the people who sent code for SYSV - hpscdi!jon,
X * arnold@ucsf-cgl, wcs@bo95b, cbcephus!pds and others.
X */
X
X#include <stdio.h>
X#include "hack.h"
X#include "func_tab.h"
X
Xextern void savech();
X
Xstatic char erase_char, kill_char;
X
X/*
X * Get initial state of terminal, set ospeed (for termcap routines)
X * and switch off tab expansion if necessary.
X * Called by startup() in termcap.c and after returning from ! or ^Z
X */
Xgettty(){
X	erase_char = '\b';
X	kill_char = 21;		/* cntl-U */
X	flags.cbreak = TRUE;
X#ifdef DGK
X	disable_ctrlP();	/* turn off ^P processing */
X#endif
X}
X
X/* reset terminal to original state */
Xsettty(s) char *s; {
X	end_screen();
X	if(s) printf(s);
X	(void) fflush(stdout);
X#ifdef DGK
X	enable_ctrlP();		/* turn on ^P processing */
X#endif
X}
X
X
X/* fatal error */
X/*VARARGS1*/
Xerror(s,x,y) char *s; {
X	end_screen();
X	putchar('\n');
X	printf(s,x,y);
X	putchar('\n');
X	exit(1);
X}
X
X/*
X * Read a line closed with '\n' into the array char bufp[BUFSZ].
X * (The '\n' is not stored. The string is closed with a '\0'.)
X * Reading can be interrupted by an escape ('\033') - now the
X * resulting string is "\033".
X */
Xgetlin(bufp)
Xregister char *bufp;
X{
X	register char *obufp = bufp;
X	register int c;
X
X	flags.toplin = 2;		/* nonempty, no --More-- required */
X	for(;;) {
X		(void) fflush(stdout);
X		if((c = getchar()) == EOF) {
X			*bufp = 0;
X			return;
X		}
X		if(c == '\033') {
X			*obufp = c;
X			obufp[1] = 0;
X			return;
X		}
X		if(c == erase_char || c == '\b') {
X			if(bufp != obufp) {
X				bufp--;
X				putstr("\b \b"); /* putsym converts \b */
X			} else	bell();
X		} else if(c == '\n') {
X			*bufp = 0;
X			return;
X		} else if(' ' <= c && c < '\177') {
X				/* avoid isprint() - some people don't have it
X				   ' ' is not always a printing char */
X			*bufp = c;
X			bufp[1] = 0;
X			putstr(bufp);
X			if(bufp-obufp < BUFSZ-1 && bufp-obufp < COLNO)
X				bufp++;
X		} else if(c == kill_char || c == '\177') { /* Robert Viduya */
X				/* this test last - @ might be the kill_char */
X			while(bufp != obufp) {
X				bufp--;
X				putstr("\b \b");
X			}
X		} else
X			bell();
X	}
X}
X
Xgetret() {
X	cgetret("");
X}
X
Xcgetret(s)
Xregister char *s;
X{
X	putsym('\n');
X	if(flags.standout)
X		standoutbeg();
X	putstr("Hit ");
X	putstr(flags.cbreak ? "space" : "return");
X	putstr(" to continue: ");
X	if(flags.standout)
X		standoutend();
X	xwaitforspace(s);
X}
X
Xchar morc;	/* tell the outside world what char he used */
X
Xxwaitforspace(s)
Xregister char *s;	/* chars allowed besides space or return */
X{
Xregister int c;
X
X	morc = 0;
X	while((c = readchar()) != '\n') {
X	    if(flags.cbreak) {
X		if(c == ' ') break;
X		if(s && index(s,c)) {
X			morc = c;
X			break;
X		}
X		bell();
X	    }
X	}
X}
X
Xstatic int last_multi;
X
Xchar *
Xparse()
X{
X	static char inline[COLNO];
X	register foo;
X
X	flags.move = 1;
X	if(!Invisible) curs_on_u(); else home();
X	multi = 0;
X#ifdef DGK
X	while((foo = readchar()) >= '0' && foo <= '9') {
X		multi = 10*multi+foo-'0';
X		if (multi < 0 || multi > LARGEST_INT)
X			multi = LARGEST_INT;
X		if (multi > 9) {
X			remember_topl();
X			home();
X			cl_end();
X			printf("Count: %d", multi);
X		}
X		last_multi = multi;
X	}
X# ifdef REDO
X	if (foo == DOAGAIN || in_doagain)
X		multi = last_multi;
X	else {
X		savech(0);	/* reset input queue */
X		savech(foo);
X	}
X# endif
X
X#else /* DGK */
X
X	while((foo = readchar()) >= '0' && foo <= '9')
X		multi = 10*multi+foo-'0';
X
X#endif /* DGK */
X
X	if(multi) {
X		multi--;
X		save_cm = inline;
X	}
X	inline[0] = foo;
X	inline[1] = 0;
X	if(foo == 'g' || foo == 'G'){
X		inline[1] = getchar();
X#ifdef REDO
X		savech(inline[1]);
X#endif
X		inline[2] = 0;
X	}
X	if(foo == 'm' || foo == 'M'){
X		inline[1] = getchar();
X#ifdef REDO
X		savech(inline[1]);
X#endif
X		inline[2] = 0;
X	}
X	clrlin();
X	return(inline);
X}
X
Xchar
Xreadchar() {
X	register int sym;
X
X	(void) fflush(stdout);
X	sym = getchar();
X	if(flags.toplin == 1)
X		flags.toplin = 2;
X	return((char) sym);
X}
X#ifdef COM_COMPL
X/* Read in an extended command - doing command line completion for
X * when enough character have been entered to make a unique command.
X * This is just a modified getlin().   -jsb
X */
Xget_ext_cmd(bufp)
Xregister char *bufp;
X{
X	register char *obufp = bufp;
X	register int c;
X	int com_index, index;
X
X	flags.toplin = 2;		/* nonempty, no --More-- required */
X
X	for(;;) {
X		(void) fflush(stdout);
X		if((c = readchar()) == EOF) {
X			*bufp = 0;
X			return;
X		}
X		if(c == '\033') {
X			*obufp = c;
X			obufp[1] = 0;
X			return;
X		}
X		if(c == erase_char || c == '\b') {
X			if(bufp != obufp) {
X				bufp--;
X				putstr("\b \b"); /* putsym converts \b */
X			} else	bell();
X		} else if(c == '\n') {
X			*bufp = 0;
X			return;
X		} else if(' ' <= c && c < '\177') {
X				/* avoid isprint() - some people don't have it
X				   ' ' is not always a printing char */
X			*bufp = c;
X			bufp[1] = 0;
X			index = 0;
X			com_index = -1;
X
X			while(extcmdlist[index].ef_txt != (char *) 0){
X				if(!strncmp(obufp, extcmdlist[index].ef_txt,
X				strlen(obufp)))
X					if(com_index == -1) /* No matches yet*/
X					    com_index = index;
X					else /* More than 1 match */
X					    com_index = -2;
X				index++;
X			}
X			if(com_index >= 0){
X				strcpy(obufp,
X				extcmdlist[com_index].ef_txt);
X				/* finish print our string */
X				putstr(bufp);
X				bufp = obufp; /* reset it */
X				if(strlen(obufp) < BUFSIZ-1 &&
X				 strlen(obufp) < COLNO)
X					/* set bufp at the end of our
X					 * string
X					 */
X					bufp += strlen(obufp);
X			} else {
X				putstr(bufp);
X				if(bufp-obufp < BUFSZ-1 && bufp-obufp < COLNO)
X					bufp++;
X			}
X		} else if(c == kill_char || c == '\177') { /* Robert Viduya */
X				/* this test last - @ might be the kill_char */
X			while(bufp != obufp) {
X				bufp--;
X				putstr("\b \b");
X			}
X		} else
X			bell();
X	}
X
X}
X#endif /* COM_COMPL /* */
END_OF_pctty.c
if test 5791 -ne `wc -c <pctty.c`; then
    echo shar: \"pctty.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f sit.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"sit.c\"
else
echo shar: Extracting \"sit.c\" \(5262 characters\)
sed "s/^X//" >sit.c <<'END_OF_sit.c'
X/*	SCCS Id: @(#)sit.c	2.3	88/02/02
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X
X#include "hack.h"
X
X#ifdef NEWCLASS
Xint	identify();
Xextern struct monst *makemon();
Xextern struct permonst *courtmon();
X
Xdosit() {
X	extern struct obj *readobjnam(), *addinv();
X	struct	 obj	*sobj_at();
X	register int	cnt;
X
X	if(Levitation)  {
X
X		pline("You are floating in the air, you can't sit!");
X	} else	if(IS_THRONE(levl[u.ux][u.uy].typ)) {
X
X		pline("As you sit in the opulent throne");
X		if (rnd(6) > 4)  {
X
X			switch (rnd(13))  {
X
X			    case 1:
X				pline("you feel suddenly weaker.");
X				if(Poison_resistance) {
X
X				    losestr(rn1(1,2));
X				    losehp(rnd(6), "cursed throne");
X				} else {
X
X				    losestr(rn1(4,3));
X				    losehp(rnd(10), "cursed throne");
X				}
X				break;
X			    case 2:
X				pline("you feel suddenly stronger.");
X				gainstr(0);
X				break;
X			    case 3:
X				pline("A%s charge of electricity shoots through your body!",
X				      (Shock_resistance) ? "" : " massive");
X				if(Shock_resistance)
X					losehp(rnd(6), "electric chair");
X				else	losehp(rnd(30), "electric chair");
X				break;
X			    case 4:
X				pline("you feel much, much better!");
X				if(u.uhp >= (u.uhpmax - 5))  u.uhpmax += 4;
X				u.uhp = u.uhpmax;
X				if (Blinded) Blinded = 1;
X				if (Sick)  Sick = 0;
X				heal_legs();
X				flags.botl = 1;
X				break;
X			    case 5:
X				if (u.ugold <= 0)  {
X
X					pline("you feel a strange sensation.");
X				} else {
X					pline("you notice you have no gold!");
X					u.ugold = 0;
X					flags.botl = 1;
X				}
X				break;
X			    case 6:
X				if(u.uluck + rn2(5) < 0) {
X
X				    pline("you feel your luck is changing.");
X				    change_luck(1);
X				} else	    makewish();
X				break;
X			    case 7:
X				cnt = rnd(10);
X				pline("you hear a voice echo:");
X				pline("Your audience has been summoned, Sire!");
X				while(cnt--)
X				    (void) makemon(courtmon(), u.ux, u.uy);
X				break;
X			    case 8:
X				if (Confusion != 0)  {
X
X				    pline("you hear a voice echo:");
X				    pline("By your Imperious order Sire...");
X				}
X				do_genocide();
X				break;
X			    case 9:
X				pline("you hear a voice echo:");
X				pline("A curse upon you for sitting upon this most holy throne!");
X				if (u.uluck > 0)  {
X
X				    if(!Blind)	pline("a cloud of darkness falls upon you.");
X				    Blinded += rn1(100,250);
X				    seeoff(0);
X				} else	    rndcurse();
X				break;
X			    case 10:
X				if (u.uluck < 0)  {
X
X					pline("an image forms in your mind.");
X					do_mapping();
X				} else  {
X
X					pline("your vision clarifies.");
X					HSee_invisible |= INTRINSIC;
X				}
X				break;
X			    case 11:
X				if (u.uluck < 0)  {
X
X				    pline("you feel threatened.");
X				    aggravate();
X				} else  {
X
X				    pline("you feel a wrenching sensation.");
X				    tele();		/* teleport him */
X				}
X				break;
X			    case 12:
X				pline("you are granted a gift of insight!");
X				while (!ggetobj("identify", identify, rn2(5))
X					&& invent);
X				break;
X			    case 13:
X				pline("your mind turns into a pretzel!");
X				HConfusion += rn1(7,16);
X				break;
X			    default:	impossible("throne effect");
X					break;
X			}
X		} else	pline("you feel somehow out of place...");
X
X		if (!rn2(3) && IS_THRONE(levl[u.ux][u.uy].typ))	{
X
X			pline("The throne vanishes in a puff of logic.");
X/*			levl[u.ux][u.uy].scrsym = ROOM_SYM; */
X			levl[u.ux][u.uy].typ = ROOM;
X		}
X
X	} else	pline("Having fun sitting on the floor???");
X	return(1);
X}
X#endif /* NEWCLASS /**/
X
X#if defined(NEWCLASS) || defined(PRAYERS) || defined(HARD)
Xrndcurse() {			/* curse a few inventory items at random! */
X
X	int	nobj = 0;
X	int	cnt, onum;
X	struct	obj	*otmp;
X
X	for (otmp = invent; otmp; otmp = otmp->nobj)  nobj++;
X	    for (cnt = rnd(6); cnt > 0; cnt--)  {
X
X		onum = rn2(nobj);
X		for(otmp = invent; onum != 0; onum--)
X		    otmp = otmp->nobj;
X
X			otmp->cursed++;
X	    }
X}
X#endif
X
Xattrcurse() {			/* remove a random INTRINSIC ability */
X	switch(rnd(10)) {
X	case 1 : if (HFire_resistance & INTRINSIC) {
X			HFire_resistance &= ~INTRINSIC;
X			if (Inhell && !Fire_resistance) {
X			    pline("You burn to a crisp.");
X			    killer = "gremlin curse";
X			    done("died");
X			} else pline("You feel warmer!");
X			break;
X		}
X	case 2 : if (HTeleportation & INTRINSIC) {
X			HTeleportation &= ~INTRINSIC;
X			pline("You don't feel jumpy!");
X			break;
X		}
X	case 3 : if (HPoison_resistance & INTRINSIC) {
X			HPoison_resistance &= ~INTRINSIC;
X			pline("You feel a little sick!");
X			break;
X		}
X	case 4 : if (HTelepat & INTRINSIC) {
X			HTelepat &= ~INTRINSIC;
X			pline("Your senses fail!");
X			break;
X		}
X	case 5 : if (HCold_resistance & INTRINSIC) {
X			HCold_resistance &= ~INTRINSIC;
X			pline("You feel colder!");
X			break;
X		}
X	case 6 : if (HInvis & INTRINSIC) {
X			HInvis &= ~INTRINSIC;
X			pline("You feel paranoid!");
X			break;
X		}
X	case 7 : if (HSee_invisible & INTRINSIC) {
X			HSee_invisible &= ~INTRINSIC;
X			pline("You think you see something!");
X			break;
X		}
X	case 8 : if (Fast & INTRINSIC) {
X			Fast &= ~INTRINSIC;
X			pline("You feel slower!");
X			break;
X		}
X	case 9 : if (Stealth & INTRINSIC) {
X			Stealth &= ~INTRINSIC;
X			pline("You feel clumsy!");
X			break;
X		}
X	case 10: if (Protection & INTRINSIC) {
X			Protection &= ~INTRINSIC;
X			pline("You feel vulnerable!");
X			break;
X		}
X	default: break;
X	}
X}
END_OF_sit.c
if test 5262 -ne `wc -c <sit.c`; then
    echo shar: \"sit.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f steal.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"steal.c\"
else
echo shar: Extracting \"steal.c\" \(5272 characters\)
sed "s/^X//" >steal.c <<'END_OF_steal.c'
X/*	SCCS Id: @(#)steal.c	2.3	88/01/21
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X
X#include "hack.h"
X
Xlong		/* actually returns something that fits in an int */
Xsomegold(){
X	return( (u.ugold < 100) ? u.ugold :
X		(u.ugold > 10000) ? rnd(10000) : rnd((int) u.ugold) );
X}
X
Xstealgold(mtmp)  register struct monst *mtmp; {
Xregister struct gold *gold = g_at(u.ux, u.uy);
Xregister long tmp;
X	if(gold && ( !u.ugold || gold->amount > u.ugold || !rn2(5))) {
X		mtmp->mgold += gold->amount;
X		freegold(gold);
X		if(Invisible) newsym(u.ux, u.uy);
X		pline("%s quickly snatches some gold from between your feet!",
X			Monnam(mtmp));
X		if(!u.ugold || !rn2(5)) {
X			rloc(mtmp);
X			mtmp->mflee = 1;
X		}
X	} else if(u.ugold) {
X		u.ugold -= (tmp = somegold());
X		pline("Your purse feels lighter.");
X		mtmp->mgold += tmp;
X		rloc(mtmp);
X		mtmp->mflee = 1;
X		flags.botl = 1;
X	}
X}
X
X/* steal armor after he finishes taking it off */
Xunsigned stealoid;		/* object to be stolen */
Xunsigned stealmid;		/* monster doing the stealing */
Xstealarm(){
X	register struct monst *mtmp;
X	register struct obj *otmp;
X
X	for(otmp = invent; otmp; otmp = otmp->nobj)
X	  if(otmp->o_id == stealoid) {
X	    for(mtmp = fmon; mtmp; mtmp = mtmp->nmon)
X	      if(mtmp->m_id == stealmid) {
X		if(dist(mtmp->mx,mtmp->my) < 3) {
X		  freeinv(otmp);
X		  pline("%s steals %s!", Monnam(mtmp), doname(otmp));
X		  mpickobj(mtmp,otmp);
X		  mtmp->mflee = 1;
X		  rloc(mtmp);
X		}
X		break;
X	      }
X	    break;
X	  }
X	stealoid = 0;
X}
X
X/* returns 1 when something was stolen */
X/* (or at least, when N should flee now) */
X/* avoid stealing the object stealoid */
Xsteal(mtmp)
Xstruct monst *mtmp;
X{
X	register struct obj *otmp;
X	register tmp;
X	register named = 0;
X
X	if(!invent){
X	    if(Blind)
X	      pline("Somebody tries to rob you, but finds nothing to steal.");
X	    else
X	      pline("%s tries to rob you, but she finds nothing to steal!",
X		Monnam(mtmp));
X	    return(1);	/* let her flee */
X	}
X	tmp = 0;
X	for(otmp = invent; otmp; otmp = otmp->nobj) if(otmp != uarm2)
X		tmp += ((otmp->owornmask & (W_ARMOR | W_RING)) ? 5 : 1);
X	tmp = rn2(tmp);
X	for(otmp = invent; otmp; otmp = otmp->nobj) if(otmp != uarm2)
X		if((tmp -= ((otmp->owornmask & (W_ARMOR | W_RING)) ? 5 : 1))
X			< 0) break;
X	if(!otmp) {
X		impossible("Steal fails!");
X		return(0);
X	}
X	if(otmp->o_id == stealoid)
X		return(0);
X	if((otmp->owornmask & (W_ARMOR | W_RING))){
X		switch(otmp->olet) {
X		case RING_SYM:
X			ringoff(otmp);
X			break;
X		case ARMOR_SYM:
X			if(multi < 0 || otmp == uarms){
X			  setworn((struct obj *) 0, otmp->owornmask & W_ARMOR);
X			  break;
X			}
X		{ int curssv = otmp->cursed;
X			otmp->cursed = 0;
X			stop_occupation();
X			if(flags.female)
X			    pline("%s charms you.  You gladly %s your %s.",
X				  Monnam(mtmp),
X				  curssv ? "hand over"
X				         : "let her take",
X#ifdef SHIRT
X				  (otmp == uarmu) ? "shirt" :
X#endif
X				  (otmp == uarmg) ? "gloves" :
X				  (otmp == uarmh) ? "helmet" : "armor");
X			else
X				pline("%s seduces you and %s off your %s.",
X				Amonnam(mtmp, Blind ? "gentle" : "beautiful"),
X				curssv	? "helps you to take"
X					: "you start taking",
X#ifdef SHIRT
X				(otmp == uarmu) ? "shirt" :
X#endif
X				(otmp == uarmg) ? "gloves" :
X				(otmp == uarmh) ? "helmet" : "armor");
X			named++;
X			(void) armoroff(otmp);
X			otmp->cursed = curssv;
X			if(multi < 0){
X				extern char *nomovemsg;
X				extern int (*afternmv)();
X				/*
X				multi = 0;
X				nomovemsg = 0;
X				afternmv = 0;
X				*/
X				stealoid = otmp->o_id;
X				stealmid = mtmp->m_id;
X				afternmv = stealarm;
X				return(0);
X			}
X			break;
X		}
X		default:
X			impossible("Tried to steal a strange worn thing.");
X		}
X	}
X	else if(otmp == uwep) setuwep((struct obj *) 0);
X
X	if(Punished && otmp == uball){
X		Punished = 0;
X		freeobj(uchain);
X		free((char *) uchain);
X		uchain = (struct obj *) 0;
X		uball->spe = 0;
X		uball = (struct obj *) 0;	/* superfluous */
X	}
X	freeinv(otmp);
X	pline("%s stole %s.", named ? "She" : Monnam(mtmp), doname(otmp));
X	mpickobj(mtmp,otmp);
X	return((multi < 0) ? 0 : 1);
X}
X
Xmpickobj(mtmp,otmp)
Xregister struct monst *mtmp;
Xregister struct obj *otmp;
X{
X	otmp->nobj = mtmp->minvent;
X	mtmp->minvent = otmp;
X}
X
Xstealamulet(mtmp)
Xregister struct monst *mtmp;
X{
X	register struct obj *otmp;
X
X	for(otmp = invent; otmp; otmp = otmp->nobj) {
X	    if(otmp->olet == AMULET_SYM) {
X		/* might be an imitation one */
X		if(otmp == uwep) setuwep((struct obj *) 0);
X		freeinv(otmp);
X		mpickobj(mtmp,otmp);
X		pline("%s stole %s!", Monnam(mtmp), doname(otmp));
X		return(1);
X	    }
X	}
X	return(0);
X}
X
X/* release the objects the killed animal has stolen */
Xrelobj(mtmp,show)
Xregister struct monst *mtmp;
Xregister show;
X{
X	register struct obj *otmp, *otmp2;
X
X	for(otmp = mtmp->minvent; otmp; otmp = otmp2){
X		otmp->ox = mtmp->mx;
X		otmp->oy = mtmp->my;
X		otmp2 = otmp->nobj;
X		otmp->nobj = fobj;
X		fobj = otmp;
X		stackobj(fobj);
X		if(show & cansee(mtmp->mx,mtmp->my))
X			atl(otmp->ox,otmp->oy,Hallucination?rndobjsym() : otmp->olet);
X	}
X	mtmp->minvent = (struct obj *) 0;
X	if(mtmp->mgold || mtmp->data->mlet == 'L') {
X		register long tmp;
X
X		tmp = (mtmp->mgold > 10000) ? 10000 : mtmp->mgold;
X		mkgold((long)(tmp + d(dlevel,30)), mtmp->mx, mtmp->my);
X		if(show & cansee(mtmp->mx,mtmp->my))
X			atl(mtmp->mx,mtmp->my, Hallucination ? rndobjsym() : GOLD_SYM);
X	}
X}
END_OF_steal.c
if test 5272 -ne `wc -c <steal.c`; then
    echo shar: \"steal.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f topl.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"topl.c\"
else
echo shar: Extracting \"topl.c\" \(4000 characters\)
sed "s/^X//" >topl.c <<'END_OF_topl.c'
X/*	SCCS Id: @(#)topl.c	2.0	87/09/15
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X
X#include <stdio.h>
X#include "hack.h"
X#ifdef GENIX
X#define	void	int	/* jhn - mod to prevent compiler from bombing */
X#endif
X
Xextern char *eos();
Xextern int CO;
X
Xchar toplines[BUFSIZ];
Xxchar tlx, tly;			/* set by pline; used by addtopl */
X
Xstruct topl {
X	struct topl *next_topl;
X	char *topl_text;
X} *old_toplines, *last_redone_topl;
X#define	OTLMAX	20		/* max nr of old toplines remembered */
X
Xdoredotopl(){
X	if(last_redone_topl)
X		last_redone_topl = last_redone_topl->next_topl;
X	if(!last_redone_topl)
X		last_redone_topl = old_toplines;
X	if(last_redone_topl){
X		(void) strcpy(toplines, last_redone_topl->topl_text);
X	}
X	redotoplin();
X	return(0);
X}
X
Xredotoplin() {
X	home();
X	if(index(toplines, '\n')) cl_end();
X	putstr(toplines);
X	cl_end();
X	tlx = curx;
X	tly = cury;
X	flags.toplin = 1;
X	if(tly > 1)
X		more();
X}
X
Xremember_topl() {
Xregister struct topl *tl;
Xregister int cnt = OTLMAX;
X	if(last_redone_topl &&
X	   !strcmp(toplines, last_redone_topl->topl_text)) return;
X	if(old_toplines &&
X	   !strcmp(toplines, old_toplines->topl_text)) return;
X	last_redone_topl = 0;
X	tl = (struct topl *)
X		alloc((unsigned)(strlen(toplines) + sizeof(struct topl) + 1));
X	tl->next_topl = old_toplines;
X	tl->topl_text = (char *)(tl + 1);
X	(void) strcpy(tl->topl_text, toplines);
X	old_toplines = tl;
X	while(cnt && tl){
X		cnt--;
X		tl = tl->next_topl;
X	}
X	if(tl && tl->next_topl){
X		free((char *) tl->next_topl);
X		tl->next_topl = 0;
X	}
X}
X
Xaddtopl(s) char *s; {
X	curs(tlx,tly);
X	if(tlx + strlen(s) > CO) putsym('\n');
X	putstr(s);
X	tlx = curx;
X	tly = cury;
X	flags.toplin = 1;
X}
X
Xxmore(s)
Xchar *s;	/* allowed chars besides space/return */
X{
X	if(flags.toplin) {
X		curs(tlx, tly);
X		if(tlx + 8 > CO) putsym('\n'), tly++;
X	}
X
X	if(flags.standout)
X		standoutbeg();
X	putstr("--More--");
X	if(flags.standout)
X		standoutend();
X
X	xwaitforspace(s);
X	if(flags.toplin && tly > 1) {
X		home();
X		cl_end();
X		docorner(1, tly-1);
X	}
X	flags.toplin = 0;
X}
X
Xmore(){
X	xmore("");
X}
X
Xcmore(s)
Xregister char *s;
X{
X	xmore(s);
X}
X
Xclrlin(){
X	if(flags.toplin) {
X		home();
X		cl_end();
X		if(tly > 1) docorner(1, tly-1);
X		remember_topl();
X	}
X	flags.toplin = 0;
X}
X
X/*VARARGS1*/
X/* Because the modified mstatusline has 9 arguments KAA */
Xpline(line,arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9)
Xregister char *line,*arg1,*arg2,*arg3,*arg4,*arg5,*arg6,*arg7,*arg8,*arg9;
X{
X	char pbuf[BUFSZ];
X	register char *bp = pbuf, *tl;
X	register int n,n0;
X
X	if(!line || !*line) return;
X	if(!index(line, '%')) (void) strcpy(pbuf,line); else
X	(void) sprintf(pbuf,line,arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
X	if(flags.toplin == 1 && !strcmp(pbuf, toplines)) return;
X	nscr();		/* %% */
X
X	/* If there is room on the line, print message on same line */
X	/* But messages like "You die..." deserve their own line */
X	n0 = strlen(bp);
X	if(flags.toplin == 1 && tly == 1 &&
X	    n0 + strlen(toplines) + 3 < CO-8 &&  /* leave room for --More-- */
X	    strncmp(bp, "You ", 4)) {
X		(void) strcat(toplines, "  ");
X		(void) strcat(toplines, bp);
X		tlx += 2;
X		addtopl(bp);
X		return;
X	}
X	if(flags.toplin == 1) more();
X	remember_topl();
X	toplines[0] = 0;
X	while(n0){
X		if(n0 >= CO){
X			/* look for appropriate cut point */
X			n0 = 0;
X			for(n = 0; n < CO; n++) if(bp[n] == ' ')
X				n0 = n;
X			if(!n0) for(n = 0; n < CO-1; n++)
X				if(!letter(bp[n])) n0 = n;
X			if(!n0) n0 = CO-2;
X		}
X		(void) strncpy((tl = eos(toplines)), bp, n0);
X		tl[n0] = 0;
X		bp += n0;
X
X		/* remove trailing spaces, but leave one */
X		while(n0 > 1 && tl[n0-1] == ' ' && tl[n0-2] == ' ')
X			tl[--n0] = 0;
X
X		n0 = strlen(bp);
X		if(n0 && tl[0]) (void) strcat(tl, "\n");
X	}
X	redotoplin();
X}
X
Xputsym(c) char c; {
X	switch(c) {
X	case '\b':
X		backsp();
X		return;
X	case '\n':
X		curx = 1;
X		cury++;
X		if(cury > tly) tly = cury;
X		break;
X	default:
X		if(curx == CO)
X			putsym('\n');	/* 1 <= curx <= CO; avoid CO */
X		else
X			curx++;
X	}
X	(void) putchar(c);
X}
X
Xputstr(s) register char *s; {
X	while(*s) putsym(*s++);
X}
END_OF_topl.c
if test 4000 -ne `wc -c <topl.c`; then
    echo shar: \"topl.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f vault.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"vault.c\"
else
echo shar: Extracting \"vault.c\" \(5953 characters\)
sed "s/^X//" >vault.c <<'END_OF_vault.c'
X/*	SCCS Id: @(#)vault.c	2.1	87/10/17
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X
X#include	"hack.h"
X#ifdef QUEST
Xsetgd(/* mtmp */) /* struct monst *mtmp; */ {}
Xgd_move() { return(2); }
Xgddead(mtmp) struct monst *mtmp; {}
Xreplgd(mtmp,mtmp2) struct monst *mtmp, *mtmp2; {}
Xinvault(){}
X
X#else
X
X
X#include "mkroom.h"
Xextern struct monst *makemon();
X#define	FCSIZ	(ROWNO+COLNO)
Xstruct fakecorridor {
X	xchar fx,fy,ftyp;
X};
X
Xstruct egd {
X	int fcbeg, fcend;	/* fcend: first unused pos */
X	xchar gdx, gdy;		/* goal of guard's walk */
X	unsigned gddone:1;
X	struct fakecorridor fakecorr[FCSIZ];
X};
X
Xstruct permonst pm_guard =
X	{ "guard", '@', 12, 12, -1, 40, 4, 10, sizeof(struct egd) };
X
Xstatic struct monst *guard;
Xstatic int gdlevel;
X#define	EGD	((struct egd *)(&(guard->mextra[0])))
X
Xstatic
Xrestfakecorr()
X{
X	register fcx,fcy,fcbeg;
X	register struct rm *crm;
X
X	while((fcbeg = EGD->fcbeg) < EGD->fcend) {
X		fcx = EGD->fakecorr[fcbeg].fx;
X		fcy = EGD->fakecorr[fcbeg].fy;
X		if((u.ux == fcx && u.uy == fcy) || cansee(fcx,fcy) ||
X		   m_at(fcx,fcy))
X			return;
X		crm = &levl[fcx][fcy];
X		crm->typ = EGD->fakecorr[fcbeg].ftyp;
X		if(!crm->typ) crm->seen = 0;
X		newsym(fcx,fcy);
X		EGD->fcbeg++;
X	}
X	/* it seems he left the corridor - let the guard disappear */
X	mondead(guard);
X	guard = 0;
X}
X
Xstatic
Xgoldincorridor()
X{
X	register int fci;
X
X	for(fci = EGD->fcbeg; fci < EGD->fcend; fci++)
X		if(g_at(EGD->fakecorr[fci].fx, EGD->fakecorr[fci].fy))
X			return(1);
X	return(0);
X}
X
Xsetgd(){
Xregister struct monst *mtmp;
X	for(mtmp = fmon; mtmp; mtmp = mtmp->nmon) if(mtmp->isgd){
X		guard = mtmp;
X		gdlevel = dlevel;
X		return;
X	}
X	guard = 0;
X}
X
Xinvault(){
Xregister tmp = inroom(u.ux, u.uy);
X    if(tmp < 0 || rooms[tmp].rtype != VAULT) {
X	u.uinvault = 0;
X	return;
X    }
X    if(++u.uinvault % 50 == 0 && (!guard || gdlevel != dlevel)) {
X	char buf[BUFSZ];
X	register x,y,dd,gx,gy;
X
X	/* first find the goal for the guard */
X	for(dd = 1; (dd < ROWNO || dd < COLNO); dd++) {
X	  for(y = u.uy-dd; y <= u.uy+dd; y++) {
X	    if(y < 0 || y > ROWNO-1) continue;
X	    for(x = u.ux-dd; x <= u.ux+dd; x++) {
X	      if(y != u.uy-dd && y != u.uy+dd && x != u.ux-dd)
X		x = u.ux+dd;
X	      if(x < 0 || x > COLNO-1) continue;
X	      if(levl[x][y].typ == CORR) goto fnd;
X	    }
X	  }
X	}
X	impossible("Not a single corridor on this level??");
X	tele();
X	return;
Xfnd:
X	gx = x; gy = y;
X
X	/* next find a good place for a door in the wall */
X	x = u.ux; y = u.uy;
X	while(levl[x][y].typ == ROOM) {
X		register int dx,dy;
X
X		dx = (gx > x) ? 1 : (gx < x) ? -1 : 0;
X		dy = (gy > y) ? 1 : (gy < y) ? -1 : 0;
X		if(abs(gx-x) >= abs(gy-y))
X			x += dx;
X		else
X			y += dy;
X	}
X
X	/* make something interesting happen */
X	if(!(guard = makemon(&pm_guard,x,y))) return;
X	guard->isgd = guard->mpeaceful = 1;
X	EGD->gddone = 0;
X	gdlevel = dlevel;
X	if(!cansee(guard->mx, guard->my)) {
X		mondead(guard);
X		guard = 0;
X		return;
X	}
X
X	pline("Suddenly one of the Vault's guards enters!");
X	pmon(guard);
X	do {
X		pline("\"Hello stranger, who are you?\" - ");
X		getlin(buf);
X	} while (!letter(buf[0]));
X
X	if(!strcmp(buf, "Croesus") || !strcmp(buf, "Kroisos")) {
X		pline("\"Oh, yes - of course. Sorry to have disturbed you.\"");
X		mondead(guard);
X		guard = 0;
X		return;
X	}
X	clrlin();
X	pline("\"I don't know you.\"");
X	if(!u.ugold)
X	    pline("\"Please follow me.\"");
X	else {
X	    pline("\"Most likely all that gold was stolen from this vault.\"");
X	    pline("\"Please drop your gold (say d$ ) and follow me.\"");
X	}
X	EGD->gdx = gx;
X	EGD->gdy = gy;
X	EGD->fcbeg = 0;
X	EGD->fakecorr[0].fx = x;
X	EGD->fakecorr[0].fy = y;
X	EGD->fakecorr[0].ftyp = levl[x][y].typ;
X	levl[x][y].typ = DOOR;
X	EGD->fcend = 1;
X    }
X}
X
Xgd_move(){
Xregister int x,y,dx,dy,gx,gy,nx,ny,typ;
Xregister struct fakecorridor *fcp;
Xregister struct rm *crm;
X	if(!guard || gdlevel != dlevel){
X		impossible("Where is the guard?");
X		return(2);	/* died */
X	}
X	if(u.ugold || goldincorridor())
X		return(0);	/* didnt move */
X	if(dist(guard->mx,guard->my) > 1 || EGD->gddone) {
X		restfakecorr();
X		return(0);	/* didnt move */
X	}
X	x = guard->mx;
X	y = guard->my;
X	/* look around (hor & vert only) for accessible places */
X	for(nx = x-1; nx <= x+1; nx++) for(ny = y-1; ny <= y+1; ny++) {
X	    if(nx == x || ny == y) if(nx != x || ny != y)
X	    if(isok(nx,ny))
X	    if(!IS_WALL(typ = (crm = &levl[nx][ny])->typ) && typ != POOL) {
X		register int i;
X		for(i = EGD->fcbeg; i < EGD->fcend; i++)
X			if(EGD->fakecorr[i].fx == nx &&
X			   EGD->fakecorr[i].fy == ny)
X				goto nextnxy;
X		if((i = inroom(nx,ny)) >= 0 && rooms[i].rtype == VAULT)
X			goto nextnxy;
X		/* seems we found a good place to leave him alone */
X		EGD->gddone = 1;
X		if(ACCESSIBLE(typ)) goto newpos;
X		crm->typ = (typ == SCORR) ? CORR : DOOR;
X		goto proceed;
X	    }
X    nextnxy:	;
X	}
X	nx = x;
X	ny = y;
X	gx = EGD->gdx;
X	gy = EGD->gdy;
X	dx = (gx > x) ? 1 : (gx < x) ? -1 : 0;
X	dy = (gy > y) ? 1 : (gy < y) ? -1 : 0;
X	if(abs(gx-x) >= abs(gy-y)) nx += dx; else ny += dy;
X
X	while((typ = (crm = &levl[nx][ny])->typ) != 0) {
X	/* in view of the above we must have IS_WALL(typ) or typ == POOL */
X	/* must be a wall here */
X		if(isok(nx+nx-x,ny+ny-y) && typ != POOL &&
X#ifdef RPH
X		    SPACE_POS(levl[nx+nx-x][ny+ny-y].typ)){
X#else
X		    ZAP_POS(levl[nx+nx-x][ny+ny-y].typ)){
X#endif
X			crm->typ = DOOR;
X			goto proceed;
X		}
X		if(dy && nx != x) {
X			nx = x; ny = y+dy;
X			continue;
X		}
X		if(dx && ny != y) {
X			ny = y; nx = x+dx; dy = 0;
X			continue;
X		}
X		/* I don't like this, but ... */
X		crm->typ = DOOR;
X		goto proceed;
X	}
X	crm->typ = CORR;
Xproceed:
X	if(cansee(nx,ny)) {
X		mnewsym(nx,ny);
X		prl(nx,ny);
X	}
X	fcp = &(EGD->fakecorr[EGD->fcend]);
X	if(EGD->fcend++ == FCSIZ) panic("fakecorr overflow");
X	fcp->fx = nx;
X	fcp->fy = ny;
X	fcp->ftyp = typ;
Xnewpos:
X	if(EGD->gddone) nx = ny = 0;
X	guard->mx = nx;
X	guard->my = ny;
X	pmon(guard);
X	restfakecorr();
X	return(1);
X}
X
Xgddead(){
X	guard = 0;
X}
X
Xreplgd(mtmp,mtmp2)
Xregister struct monst *mtmp, *mtmp2;
X{
X	if(mtmp == guard)
X		guard = mtmp2;
X}
X
X#endif /* QUEST /**/
END_OF_vault.c
if test 5953 -ne `wc -c <vault.c`; then
    echo shar: \"vault.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f worm.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"worm.c\"
else
echo shar: Extracting \"worm.c\" \(4392 characters\)
sed "s/^X//" >worm.c <<'END_OF_worm.c'
X/*	SCCS Id: @(#)worm.c	1.4	87/08/08
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* worm.c - version 1.0.2 */
X
X#include "hack.h"
X#ifndef NOWORM
X#include "wseg.h"
X
Xstruct wseg *wsegs[32];	/* linked list, tail first */
Xstruct wseg *wheads[32];
Xlong wgrowtime[32];
X
Xgetwn(mtmp) struct monst *mtmp; {
Xregister tmp;
X	for(tmp=1; tmp<32; tmp++) if(!wsegs[tmp]) {
X		mtmp->wormno = tmp;
X		return(1);
X	}
X	return(0);	/* level infested with worms */
X}
X
X/* called to initialize a worm unless cut in half */
Xinitworm(mtmp) struct monst *mtmp; {
Xregister struct wseg *wtmp;
Xregister tmp = mtmp->wormno;
X	if(!tmp) return;
X	wheads[tmp] = wsegs[tmp] = wtmp = newseg();
X	wgrowtime[tmp] = 0;
X	wtmp->wx = mtmp->mx;
X	wtmp->wy = mtmp->my;
X/*	wtmp->wdispl = 0; */
X	wtmp->nseg = 0;
X}
X
Xworm_move(mtmp) struct monst *mtmp; {
Xregister struct wseg *wtmp, *whd;
Xregister tmp = mtmp->wormno;
X	wtmp = newseg();
X	wtmp->wx = mtmp->mx;
X	wtmp->wy = mtmp->my;
X	wtmp->nseg = 0;
X/*	wtmp->wdispl = 0; */
X	(whd = wheads[tmp])->nseg = wtmp;
X	wheads[tmp] = wtmp;
X	if(cansee(whd->wx,whd->wy)){
X		unpmon(mtmp);
X		atl(whd->wx, whd->wy, '~');
X		whd->wdispl = 1;
X	} else	whd->wdispl = 0;
X	if(wgrowtime[tmp] <= moves) {
X		if(!wgrowtime[tmp]) wgrowtime[tmp] = moves + rnd(5);
X		else wgrowtime[tmp] += 2+rnd(15);
X		mtmp->mhpmax += 3;
X		mtmp->mhp += 3;
X		return;
X	}
X	whd = wsegs[tmp];
X	wsegs[tmp] = whd->nseg;
X	remseg(whd);
X}
X
Xworm_nomove(mtmp) register struct monst *mtmp; {
Xregister tmp;
Xregister struct wseg *wtmp;
X	tmp = mtmp->wormno;
X	wtmp = wsegs[tmp];
X	if(wtmp == wheads[tmp]) return;
X	if(wtmp == 0 || wtmp->nseg == 0) panic("worm_nomove?");
X	wsegs[tmp] = wtmp->nseg;
X	remseg(wtmp);
X	mtmp->mhp -= 3;	/* mhpmax not changed ! */
X}
X
Xwormdead(mtmp) register struct monst *mtmp; {
Xregister tmp = mtmp->wormno;
Xregister struct wseg *wtmp, *wtmp2;
X	if(!tmp) return;
X	mtmp->wormno = 0;
X	for(wtmp = wsegs[tmp]; wtmp; wtmp = wtmp2){
X		wtmp2 = wtmp->nseg;
X		remseg(wtmp);
X	}
X	wsegs[tmp] = 0;
X}
X
Xwormhit(mtmp) register struct monst *mtmp; {
Xregister tmp = mtmp->wormno;
Xregister struct wseg *wtmp;
X	if(!tmp) return;	/* worm without tail */
X	for(wtmp = wsegs[tmp]; wtmp; wtmp = wtmp->nseg)
X		(void) hitu(mtmp,1);
X}
X
Xwormsee(tmp) register unsigned tmp; {
Xregister struct wseg *wtmp = wsegs[tmp];
X	if(!wtmp) panic("wormsee: wtmp==0");
X	for(; wtmp->nseg; wtmp = wtmp->nseg)
X		if(!cansee(wtmp->wx,wtmp->wy) && wtmp->wdispl){
X			newsym(wtmp->wx, wtmp->wy);
X			wtmp->wdispl = 0;
X		}
X}
X
Xpwseg(wtmp) register struct wseg *wtmp; {
X	if(!wtmp->wdispl){
X		atl(wtmp->wx, wtmp->wy, '~');
X		wtmp->wdispl = 1;
X	}
X}
X
Xcutworm(mtmp,x,y,weptyp)
Xregister struct monst *mtmp;
Xregister xchar x,y;
Xregister uchar weptyp;		/* uwep->otyp or 0 */
X{
X	register struct wseg *wtmp, *wtmp2;
X	register struct monst *mtmp2;
X	register tmp,tmp2;
X	if(mtmp->mx == x && mtmp->my == y) return;	/* hit headon */
X
X	/* cutting goes best with axe or sword */
X	tmp = rnd(20);
X	if(weptyp == LONG_SWORD || weptyp == TWO_HANDED_SWORD ||
X	   weptyp == SCIMITAR || weptyp == SHORT_SWORD ||
X	   weptyp == BROAD_SWORD || weptyp == AXE || weptyp == KATANA)
X		tmp += 5;
X	if(tmp < 12) return;
X
X	/* if tail then worm just loses a tail segment */
X	tmp = mtmp->wormno;
X	wtmp = wsegs[tmp];
X	if(wtmp->wx == x && wtmp->wy == y){
X		wsegs[tmp] = wtmp->nseg;
X		remseg(wtmp);
X		return;
X	}
X
X	/* cut the worm in two halves */
X	mtmp2 = newmonst(0);
X	*mtmp2 = *mtmp;
X	mtmp2->mxlth = mtmp2->mnamelth = 0;
X
X	/* sometimes the tail end dies */
X	if(rn2(3) || !getwn(mtmp2)){
X		monfree(mtmp2);
X		tmp2 = 0;
X	} else {
X		tmp2 = mtmp2->wormno;
X		wsegs[tmp2] = wsegs[tmp];
X		wgrowtime[tmp2] = 0;
X	}
X	do {
X		if(wtmp->nseg->wx == x && wtmp->nseg->wy == y){
X			if(tmp2) wheads[tmp2] = wtmp;
X			wsegs[tmp] = wtmp->nseg->nseg;
X			remseg(wtmp->nseg);
X			wtmp->nseg = 0;
X			if(tmp2){
X				pline("You cut the worm in half.");
X				mtmp2->mhpmax = mtmp2->mhp =
X					d(mtmp2->data->mlevel, 8);
X				mtmp2->mx = wtmp->wx;
X				mtmp2->my = wtmp->wy;
X				mtmp2->nmon = fmon;
X				fmon = mtmp2;
X				unpmon(mtmp2);			/* MRS */
X				pmon(mtmp2);
X			} else {
X				pline("You cut off part of the worm's tail.");
X				remseg(wtmp);
X			}
X			mtmp->mhp /= 2;
X			return;
X		}
X		wtmp2 = wtmp->nseg;
X		if(!tmp2) remseg(wtmp);
X		wtmp = wtmp2;
X	} while(wtmp->nseg);
X	panic("Cannot find worm segment");
X}
X
Xremseg(wtmp) register struct wseg *wtmp; {
X	if(wtmp->wdispl)
X		newsym(wtmp->wx, wtmp->wy);
X	free((char *) wtmp);
X}
X#endif /* NOWORM /**/
END_OF_worm.c
if test 4392 -ne `wc -c <worm.c`; then
    echo shar: \"worm.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f you.h -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"you.h\"
else
echo shar: Extracting \"you.h\" \(4061 characters\)
sed "s/^X//" >you.h <<'END_OF_you.h'
X/*	SCCS Id: @(#)you.h	2.3	87/12/12
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X
X#ifndef YOU_H
X#define YOU_H
X
X#include "config.h"
X#include "onames.h"
X#include "permonst.h"
X
Xstruct prop {
X
X#define	TIMEOUT		007777	/* mask */
X#define	LEFT_RING	W_RINGL	/* 010000L */
X#define	RIGHT_RING	W_RINGR	/* 020000L */
X#define	INTRINSIC	040000L
X#define	LEFT_SIDE	LEFT_RING
X#define	RIGHT_SIDE	RIGHT_RING
X#define	BOTH_SIDES	(LEFT_SIDE | RIGHT_SIDE)
X
X	long p_flgs;
X	int (*p_tofn)();	/* called after timeout */
X};
X
Xstruct you {
X	xchar ux, uy;
X	schar dx, dy, dz;	/* direction of move (or zap or ... ) */
X	schar di;		/* direction of FF */
X	xchar ux0, uy0;		/* initial position FF */
X	xchar udisx, udisy;	/* last display pos */
X	char usym;		/* usually '@' */
X	schar uluck;
X#define	LUCKMAX		10	/* on moonlit nights 11 */
X#define	LUCKMIN		(-10)
X	int last_str_turn;	/* 0: none, 1: half turn, 2: full turn */
X				/* +: turn right, -: turn left */
X	unsigned udispl;	/* @ on display */
X	unsigned ulevel;	/* 1 - 14 */
X#ifdef QUEST
X	unsigned uhorizon;
X#endif
X	unsigned utrap;		/* trap timeout */
X	unsigned utraptype;	/* defined if utrap nonzero */
X#define	TT_BEARTRAP	0
X#define	TT_PIT		1
X#ifdef SPIDERS
X#define	TT_WEB		2
X#endif
X	unsigned uinshop;	/* used only in shk.c - (roomno+1) of shop */
X
X/* perhaps these #define's should also be generated by makedefs */
X#define	TELEPAT		LAST_RING		/* not a ring */
X#define	HTelepat	u.uprops[TELEPAT].p_flgs
X#define	Telepat		((HTelepat) || (u.usym == 'E'))
X#define	FAST		(LAST_RING+1)		/* not a ring */
X#define	Fast		u.uprops[FAST].p_flgs
X#define	CONFUSION	(LAST_RING+2)		/* not a ring */
X#define	HConfusion	u.uprops[CONFUSION].p_flgs
X#define Confusion	((HConfusion) || index("BIy", u.usym))
X#define	INVIS		(LAST_RING+3)		/* not a ring */
X#define	HInvis		u.uprops[INVIS].p_flgs
X#define Invis		((HInvis) || u.usym == 'I')
X#define Invisible	(Invis && !See_invisible)
X#define	GLIB		(LAST_RING+4)		/* not a ring */
X#define	Glib		u.uprops[GLIB].p_flgs
X#define	PUNISHED	(LAST_RING+5)		/* not a ring */
X#define	Punished	u.uprops[PUNISHED].p_flgs
X#define	SICK		(LAST_RING+6)		/* not a ring */
X#define	Sick		u.uprops[SICK].p_flgs
X#define	BLINDED		(LAST_RING+7)		/* not a ring */
X#define	Blinded		u.uprops[BLINDED].p_flgs
X#define	WOUNDED_LEGS	(LAST_RING+8)		/* not a ring */
X#define Wounded_legs	u.uprops[WOUNDED_LEGS].p_flgs
X#define STONED		(LAST_RING+9)		/* not a ring */
X#define Stoned		u.uprops[STONED].p_flgs
X#define HALLUCINATION	(LAST_RING+10)		/* not a ring */
X#define Hallucination	u.uprops[HALLUCINATION].p_flgs
X#define	BLINDFOLDED	(LAST_RING+11)		/* not a ring */
X#define	Blindfolded	u.uprops[BLINDFOLDED].p_flgs
X#define Blind		(Blinded || Blindfolded)
X#define	BADGED		(LAST_RING+12)		/* not a ring */
X#define	Badged		u.uprops[BADGED].p_flgs
X#define LAST_PROP	(BADGED)		/* the last property */
X#define PROP(x) (x-RIN_ADORNMENT)       /* convert ring to index in uprops */
X	struct prop uprops[LAST_PROP+1];
X
X	unsigned umconf;
X	char *usick_cause;
X	int mh, mhmax, mtimedone, umonnum;	/* for polymorph-self */
X	schar mstr, mstrmax;			/* for saving ustr/ustrmax */
X#if defined(KOPS) && defined(KAA)
X	unsigned ucreamed;
X#endif
X	unsigned uswallow;		/* set if swallowed by a monster */
X	unsigned uswldtim;		/* time you have been swallowed */
X	unsigned uhs;			/* hunger state - see hack.eat.c */
X#ifdef HARD
X	unsigned udemigod;		/* once you kill the wiz */
X	unsigned udg_cnt;		/* how long you have been demigod */
X#endif
X#ifdef RPH
X	int medusa_level;		/* level of wiz and medusa */
X	int wiz_level;
X#endif
X#ifdef STOOGES
X	int stooge_level;
X#endif
X	schar ustr,ustrmax;
X	schar udaminc;
X	schar uac;
X	int uhp,uhpmax;
X#ifdef SPELLS
X	int uen,uenmax;			/* magical energy - M. Stephenson */
X#endif
X#ifdef PRAYERS
X	int ugangr;			/* if the gods are angry at you */
X	int ublessed,ublesscnt;		/* blessing/duration from #pray */
X#endif
X	long int ugold,ugold0,uexp,urexp;
X	int uhunger;			/* refd only in eat.c and shk.c */
X	int uinvault;
X	struct monst *ustuck;
X	int nr_killed[CMNUM+2];		/* used for experience bookkeeping */
X};
X
X#endif /* YOU_H /**/
END_OF_you.h
if test 4061 -ne `wc -c <you.h`; then
    echo shar: \"you.h\" unpacked with wrong size!
fi
# end of overwriting check
fi
echo shar: End of archive 12 \(of 13\).
cp /dev/null ark12isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 13 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
