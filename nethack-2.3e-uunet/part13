#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 13 (of 13)."
# Contents:  Make.ini Maketcc.ini NetHack.cnf Newstuff/bugfix1
#   Newstuff/bugfix2 alloc.c bones.c decl.c edog.h eshk.h extern.h
#   flag.h fount.tbl func_tab.h gen.h gold.h hh ioctl.c mfndpos.h
#   mkroom.h monst.h monster.tbl msdos.h nethack.cnf nethack.sh
#   netquest.sh nfs.fix obj.h objclass.h pcunix.c permonst.h rip.c
#   rm.h rnd.c rumors.c rumors.mrx search.c termcap.cnf timeout.c
#   track.c trap.h version.c weapon.tbl wield.c worn.c write.c wseg.h
# Wrapped by billr@tekred on Mon Jun 20 11:39:31 1988
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f Make.ini -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"Make.ini\"
else
echo shar: Extracting \"Make.ini\" \(1759 characters\)
sed "s/^X//" >Make.ini <<'END_OF_Make.ini'
X#	SCCS Id: @(#)Make.ini	1.4	87/08/08
X# This is a sample `make.ini' file for NDMAKE v3.7.  You will probably want
X# to customize it for your system.
X
X
X
X# The order to search for rules and files is specified by .SUFFIXES
X.SUFFIXES : .exe .obj .c .for .asm
X
X# A few macros.
XCFLAGS = -A$(MODEL)
XMODEL = S
XSETARGV = $(LIB)\$(MODEL)SETARGV
XLIBS =
XBIN =
XLFLAGS =
X
X# A universally useful target.
Xclean:
X	+-erase *.bak
X	+-erase *.map
X
X# .BEFORE and .AFTER can be used to turn DPATH off and on.
X.BEFORE:; @+echo For help with ndmake, use the command `make -h'
X.AFTER:; @+echo All done.
X
X
X# DEFAULT RULES
X# To produce a `.obj' file from a `.asm' file using MASM.
X.asm.obj:; masm $*.asm;
X
X# To produce a `.obj' file from a `.c' file using Microsoft C. 
X.c.obj:; msc $(CFLAGS) -I\c $*.c
X
X# To produce a `.obj' file from a `.for' file using Microsoft Fortran.
X.for.obj:
X	for1 $*.for;
X	pas2
X
X# To produce a `.exe' file from an `.obj' file.  Note that there is a
X# problem because LIBS may be different for linking `.obj' files
X# produced by different compilers (C, FORTRAN, PASCAL, etc).  To avoid
X# this problem you may want to have the C compiler produce `.cbj' files,
X# the FORTRAN compiler produce `.fbj' files, etc.  Then you could write
X# specific rules for `.cbj.exe' and `.fbj.exe' which would use the correct
X# libraries.
X.obj.exe:
X	link $*.obj $(SETARGV), $@,, $(LIBS) $(LFLAGS);
X
X# To produce a `.exe' file from a `.asm' file.
X.asm.exe:
X	masm $*.asm;
X	link $*.obj, $@,, $(LIBS)
X	erase $*.obj
X
X# To produce a `.exe' file from a `.c' file.
X.c.exe:
X	msc $(CFLAGS) -I\c $*.c
X	link $*.obj $(SETARGV), $@,, $(LIBS) $(LFLAGS)
X	erase $*.obj
X
X# To produce a `.exe' file from a `.for' file.
X.for.exe:
X	for1 $*.for;
X	pas2
X	link $*.obj, $@,, $(LIB)\FORTRAN.LIB
X	erase $*.obj
END_OF_Make.ini
if test 1759 -ne `wc -c <Make.ini`; then
    echo shar: \"Make.ini\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f Maketcc.ini -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"Maketcc.ini\"
else
echo shar: Extracting \"Maketcc.ini\" \(1759 characters\)
sed "s/^X//" >Maketcc.ini <<'END_OF_Maketcc.ini'
X#	SCCS Id: @(#)Maketcc.ini	1.4	87/08/08
X# This is a sample `make.ini' file for NDMAKE v3.7.  You will probably want
X# to customize it for your system.
X
X
X
X# The order to search for rules and files is specified by .SUFFIXES
X#.SUFFIXES : .exe .obj .c .for .asm
X
X# A few macros.
XCFLAGS = -m$(MODEL)
XMODEL = h
XLIBS = c:\c\lib\emu.lib c:\c\lib\math$(MODEL).lib c:\c\lib\c$(MODEL).lib
XBIN =
XLFLAGS =
X
X# A universally useful target.
X#clean:
X#	+-erase *.bak
X#	+-erase *.map
X
X# .BEFORE and .AFTER can be used to turn DPATH off and on.
X#.BEFORE:; @+echo For help with ndmake, use the command `make -h'
X#.AFTER:; @+echo All done.
X
X
X# DEFAULT RULES
X# To produce a `.obj' file from a `.asm' file using MASM.
X.asm.obj:
X	masm $*.asm;
X
X# To produce a `.obj' file from a `.c' file using Microsoft C. 
X.c.obj:
X	tcc -c $(CFLAGS) $*.c
X
X# To produce a `.obj' file from a `.for' file using Microsoft Fortran.
X.for.obj:
X	for1 $*.for;
X	pas2
X
X# To produce a `.exe' file from an `.obj' file.  Note that there is a
X# problem because LIBS may be different for linking `.obj' files
X# produced by different compilers (C, FORTRAN, PASCAL, etc).  To avoid
X# this problem you may want to have the C compiler produce `.cbj' files,
X# the FORTRAN compiler produce `.fbj' files, etc.  Then you could write
X# specific rules for `.cbj.exe' and `.fbj.exe' which would use the correct
X# libraries.
X.obj.exe:
X	tlink c:\c\lib\c0$(MODEL).obj $*.obj,$@,,$(LIBS) $(LFLAGS);
X
X# To produce a `.exe' file from a `.asm' file.
X.asm.exe:
X	masm $*.asm;
X	tlink $*.obj, $@,, $(LIBS)
X	erase $*.obj
X
X# To produce a `.exe' file from a `.c' file.
X.c.exe:
X	tcc $(CFLAGS) $*.c
X	erase $*.obj
X
X# To produce a `.exe' file from a `.for' file.
X.for.exe:
X	for1 $*.for;
X	pas2
X	link $*.obj, $@,, $(LIB)\FORTRAN.LIB
X	erase $*.obj
END_OF_Maketcc.ini
if test 1759 -ne `wc -c <Maketcc.ini`; then
    echo shar: \"Maketcc.ini\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f NetHack.cnf -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"NetHack.cnf\"
else
echo shar: Extracting \"NetHack.cnf\" \(2296 characters\)
sed "s/^X//" >NetHack.cnf <<'END_OF_NetHack.cnf'
X# A '#' at the beginning of a line means the rest of the line is a comment.
X
X# This configuration file is set up for three cases, a person with a hard
X# disk as drive C:, 1 person with two floppy disks, and several people
X# with two floppy disks.  The default configuration is the second one.
X# To change configuration, comment out the unwanted configurations, and
X# remove the comment from the configuration you want.
X
X# I use OPTIONS=name:NickD-W, silent, rawio, IBMBIOS
X
X# A hard disk configuration.
X#
XHACKDIR=c:\games\nethack
XSAVE=c:\games\nethack\bones;n
X#RAMDISK=d:
XLEVELS=c:\games\nethack\bones
XOPTIONS=name:Steve,dogname:Bodacious,rest_on_space,time,IBMBIOS,packorder:%/=?!+)[(*0,endgame:10 t / 2 a,rawio,nopickup
X
X# A 2-floppy configuration.
X#
X# HACKDIR=a:\
X# LEVELS=b:\
X# SAVE=b:\
X# OPTIONS=name:Steve-s,rest_on_space,time,IBMBIOS,packorder:%/=?!+)[(*0,endgame:10 t / 2 a,rawio,nopickup
X# RAMDISK=c:
X
X# The 17 GRAPHICS characters (0-16) are:
X# stone, vertical wall, horizontal wall, top left corner, top right corner
X# bottom left corner, bottom right corner, door, floor, corridor, up stairs,
X# down stairs, trap, pool, fountain, throne, web
X# An example using the IBM graphics character set.
XGRAPHICS = 039 179 196 218 191 192 217 206 250 176 060 062 094 247 202 198 157
X
X
X#     Special section for DEC Rainbow owners.
X#
X#  You *must* include the option `DECRainbow' in the OPTIONS line
X#  if you want to use line-drawing charcters.  Also, you must *not*
X#  use the option `rawio' or your system will hang!
X#
X#  You can select the "Rainbow line-drawing character set"
X#  for drawing the dungeon.  For *graphics* characters,
X#  128 has been added to the decimal value of the character.
X#  Adding 128 lets PC HACK know you want it to use the line-drawing
X#  character set.  Non-graphical characters are indicated by
X#  their decimal value.  You can mix both types of characters in
X#  the GRAPHICS line.
X#
X#  A recommended configuration for the Rainbow using the
X#  line-drawing character set, two floppies and no ramdisk is:
X# SAVE=b:\
X# LEVELS=b:\
X# OPTIONS=name:YourName,DECRainbow
X# GRAPHICS = 248 241 236 235 237 234 238 254 225
X# this example lists options 1-9, as in the PC Hack version. You should modify
X# it (if using a DECRainbow) to have options 0-16 for PC Nethack. --sac
X
X
END_OF_NetHack.cnf
if test 2296 -ne `wc -c <NetHack.cnf`; then
    echo shar: \"NetHack.cnf\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f Newstuff/bugfix1 -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"Newstuff/bugfix1\"
else
echo shar: Extracting \"Newstuff/bugfix1\" \(1430 characters\)
sed "s/^X//" >Newstuff/bugfix1 <<'END_OF_Newstuff/bugfix1'
X
XI got it to compile under Turbo C 1.5.  These are the changes I needed
Xto make it compile:
X
Xtopten.c : I wrote a little link() procedure for the LOGFILE code.
XBasically the pseudo-link() only looks to see if the lock file exists,
Xand if not, creates it.
X
Xmakedefs.c : Either use a -DMSDOS, or (like I did for portability),
Xadd an #ifdef __MSDOS__, #define MSDOS, #endif.
X
Xmkshop.c : Add a void mkzoo(), mkswamp() in mkshop() after the #ifdef
XWIZARD.
X
Xrip.c : Add ", 3" parameter to the strncmp(.., "Mr."/"Ms.") calls.
X
XThen it compiled, but put little H's all over the screen.  I found the
Xbug in tgoto.c in the termcap code.  Just add a *out = 0 before it
Xreturns.
X
XTwo other little mites:
X
Xmsdos.c : the read_config_file() still reads 17 GRAPHICS values, just
Xexpand it in the obvious places if you want to customize the sink
Xsymbol.
X
Xpray.c : THEOLOGY knows about cursed armor, but doesn't know about
XHawaiian shirts.  You can add uarmu to the end of the uarm... if's,
Xenclosed in #IFDEF SHIRT of course.
X
XOne big mite:
X
XAll these changes made, it runs real pretty, but it goes catatonic
Xwhen i go downstairs from the first level.  I'm looking for this one.
XI'll post the diffs for these problems when I get it working.
X-- 
X"...billions and billions..."			| Mike Threepoint (D-ro 3)
X			-- not Carl Sagan	| linhart@topaz.rutgers.edu
X"...hundreds if not thousands..."		| FidoNet 1:107/513
X			-- Pnews		| AT&T +1 (201)878-0937
X
X
END_OF_Newstuff/bugfix1
if test 1430 -ne `wc -c <Newstuff/bugfix1`; then
    echo shar: \"Newstuff/bugfix1\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f Newstuff/bugfix2 -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"Newstuff/bugfix2\"
else
echo shar: Extracting \"Newstuff/bugfix2\" \(879 characters\)
sed "s/^X//" >Newstuff/bugfix2 <<'END_OF_Newstuff/bugfix2'
X
XIn article <1625@silver.bacs.indiana.edu> creps@silver (I) write:
X>
X>   Also I'm presently trying to fix a bug in the dragon code,
X>"The colored dragon breathes xxxxxx" where "xxxxxx" is just garbage.
X>I'm looking in mhitu.c right now. I may fix other things if I think of them.
X
X   I got this one fixed last night. It was caused by passing three arguments
Xto the kludge() routine, which is only defined with two arguments. This
Xroutine probably should have been a macro instead of a subroutine, but I
Xjust took the call to kludge() out of mhitu.c, and replaced it with a
Xcall to pline() containing a '(Blind) ? "It" : Monnam(...)'.
X
X-	-	-	-	-	-	-	-	-	-
XSteve Creps, Indiana University, Bloomington, "home of the Hoosiers"
X	creps@silver.bacs.indiana.edu (192.12.206.2)
X	{pur-ee,ihnp4!inuxc,rutgers,pyramid}!iuvax!silver!creps
X	creps@iubacs.bitnet (forwarded)
X"As seen on MTV"
X
X
END_OF_Newstuff/bugfix2
if test 879 -ne `wc -c <Newstuff/bugfix2`; then
    echo shar: \"Newstuff/bugfix2\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f alloc.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"alloc.c\"
else
echo shar: Extracting \"alloc.c\" \(865 characters\)
sed "s/^X//" >alloc.c <<'END_OF_alloc.c'
X/*	SCCS Id: @(#)alloc.c	1.4	87/08/08
X/* alloc.c - version 1.0.2 */
X#ifdef LINT
X
X/*
X   a ridiculous definition, suppressing
X	"possible pointer alignment problem" for (long *) malloc()
X	"enlarg defined but never used"
X	"ftell defined (in <stdio.h>) but never used"
X   from lint
X*/
X#include <stdio.h>
Xlong *
Xalloc(n) unsigned n; {
Xlong dummy = ftell(stderr);
X	if(n) dummy = 0;	/* make sure arg is used */
X	return(&dummy);
X}
X
X#else
X
Xextern char *malloc();
Xextern char *realloc();
X
Xlong *
Xalloc(lth)
Xregister unsigned lth;
X{
X	register char *ptr;
X
X	if(!(ptr = malloc(lth)))
X		panic("Cannot get %d bytes", lth);
X	return((long *) ptr);
X}
X
X#ifndef DGK
Xlong *
Xenlarge(ptr,lth)
Xregister char *ptr;
Xregister unsigned lth;
X{
X	register char *nptr;
X
X	if(!(nptr = realloc(ptr,lth)))
X		panic("Cannot reallocate %d bytes", lth);
X	return((long *) nptr);
X}
X#endif
X
X#endif /* LINT /**/
END_OF_alloc.c
if test 865 -ne `wc -c <alloc.c`; then
    echo shar: \"alloc.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f bones.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"bones.c\"
else
echo shar: Extracting \"bones.c\" \(3830 characters\)
sed "s/^X//" >bones.c <<'END_OF_bones.c'
X/*	SCCS Id: @(#)bones.c	1.4	87/08/08
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* bones.c - version 1.0.3 */
X
X#include "hack.h"
Xextern char plname[PL_NSIZ];
Xextern long somegold();
Xextern struct monst *makemon();
Xextern struct permonst pm_ghost;
X
X#ifdef DGK
Xchar bones[FILENAME];
X#else
Xchar bones[] = "bones_xx";
X#endif
X
X/* save bones and possessions of a deceased adventurer */
Xsavebones(){
Xregister fd;
Xregister struct obj *otmp;
Xregister struct trap *ttmp;
Xregister struct monst *mtmp;
X	if(dlevel <= 0 || dlevel > MAXLEVEL) return;
X	if(!rn2(1 + dlevel/2)	/* not so many ghosts on low levels */
X#ifdef WIZARD
X		&& !wizard
X#endif
X		) return;
X#ifdef DGK
X	name_file(bones, dlevel);
X#else
X	bones[6] = '0' + (dlevel/10);
X	bones[7] = '0' + (dlevel%10);
X#endif
X	if((fd = open(bones,0)) >= 0){
X		(void) close(fd);
X#ifdef WIZARD
X		if(wizard)
X			pline("Bones file already exists.");
X#endif
X		return;
X	}
X	/* drop everything; the corpse's possessions are usually cursed */
X	otmp = invent;
X	while(otmp){
X		otmp->ox = u.ux;
X		otmp->oy = u.uy;
X		otmp->age = 0;		/* very long ago */
X		otmp->owornmask = 0;
X		if(rn2(5)) otmp->cursed = 1;
X		if(!otmp->nobj){
X			otmp->nobj = fobj;
X			fobj = invent;
X			invent = 0;	/* superfluous */
X			break;
X		}
X		otmp = otmp->nobj;
X	}
X	/* spill any contained objects - added by GAN 03/23/87 */
X	otmp = fcobj;
X	while(otmp)  {
X		register struct obj *otmp2;
X
X		otmp2 = otmp->nobj;
X		spill_obj(otmp);
X		otmp = otmp2;
X	}
X	if(!(mtmp = makemon(PM_GHOST, u.ux, u.uy))) return;
X	mtmp->mx = u.ux;
X	mtmp->my = u.uy;
X	mtmp->msleep = 1;
X	(void) strcpy((char *) mtmp->mextra, plname);
X	mkgold(somegold() + d(dlevel,30), u.ux, u.uy);
X	for(mtmp = fmon; mtmp; mtmp = mtmp->nmon){
X		mtmp->m_id = 0;
X		if(mtmp->mtame) {
X			mtmp->mtame = 0;
X			mtmp->mpeaceful = 0;
X		}
X		mtmp->mlstmv = 0;
X		if(mtmp->mdispl) unpmon(mtmp);
X	}
X	for(ttmp = ftrap; ttmp; ttmp = ttmp->ntrap)
X		ttmp->tseen = 0;
X	for(otmp = fobj; otmp; otmp = otmp->nobj) {
X		otmp->o_id = 0;
X	     /* otmp->o_cnt_id = 0; - superfluous */
X		otmp->onamelth = 0;
X		otmp->known = 0;
X		otmp->invlet = 0;
X		if(otmp->olet == AMULET_SYM && !otmp->spe) {
X			otmp->spe = -1;      /* no longer the actual amulet */
X			otmp->cursed = 1;    /* flag as gotten from a ghost */
X		}
X	}
X#ifdef DGK
X	fd = open(bones, O_WRONLY | O_BINARY | O_CREAT, FMASK);
X#else
X	fd = creat(bones, FMASK);
X#endif
X	if(fd < 0) {
X#ifdef WIZARD
X		if(wizard)
X			pline("Cannot create bones file - creat failed");
X#endif
X		return;
X	}
X#ifdef DGK
X	savelev(fd,dlevel, COUNT | WRITE);
X#else
X	savelev(fd,dlevel);
X#endif
X	(void) close(fd);
X}
X
X/*
X * "spill" object out of box onto floor
X */
Xspill_obj(obj)
Xstruct obj *obj;
X{
X	struct obj *otmp;
X
X	for(otmp = fobj; otmp; otmp = otmp->nobj)
X		if(obj->o_cnt_id == otmp->o_id)  {
X			obj->ox = otmp->ox;
X			obj->oy = otmp->oy;
X			obj->age = 0;
X			if(rn2(5))
X				obj->cursed = 1;
X			obj->nobj = otmp->nobj;
X			otmp->nobj = obj;
X			return;
X		}
X}
X		
Xgetbones(){
Xregister fd,x,y,ok;
X	/* wizard check added by GAN 02/05/87 */
X	if(rn2(3)	/* only once in three times do we find bones */
X#ifdef WIZARD
X		&& !wizard
X#endif
X		) return(0);
X#ifdef DGK
X	name_file(bones, dlevel);
X#else
X	bones[6] = '0' + dlevel/10;
X	bones[7] = '0' + dlevel%10;
X#endif
X	if((fd = open(bones, 0)) < 0) return(0);
X	if((ok = uptodate(fd)) != 0){
X#ifdef WIZARD
X		if(wizard)  {
X			char buf[BUFSZ];
X			pline("Get bones? ");
X			getlin(buf);
X			if(buf[0] == 'n')  {
X				(void) close(fd);
X				return(0);
X			}
X		}
X#endif
X		getlev(fd, 0, dlevel);
X		for(x = 0; x < COLNO; x++) for(y = 0; y < ROWNO; y++)
X			levl[x][y].seen = levl[x][y].new = 0;
X	}
X	(void) close(fd);
X#ifdef WIZARD
X	if(wizard)  {
X		char buf[BUFSZ];
X		pline("Unlink bones? ");
X		getlin(buf);
X		if(buf[0] == 'n')
X			return(ok);
X	}
X#endif
X	if(unlink(bones) < 0){
X		pline("Cannot unlink %s .", bones);
X		return(0);
X	}
X	return(ok);
X}
END_OF_bones.c
if test 3830 -ne `wc -c <bones.c`; then
    echo shar: \"bones.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f decl.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"decl.c\"
else
echo shar: Extracting \"decl.c\" \(2357 characters\)
sed "s/^X//" >decl.c <<'END_OF_decl.c'
X/*	SCCS Id: @(#)decl.c	2.3	87/12/16
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X
X#include	"hack.h"
Xchar nul[40];			/* contains zeros */
Xchar plname[PL_NSIZ];		/* player name */
X
X#ifdef GRAPHICS
Xstruct symbols defsyms = {
X    ' ', '|', '-', '-', '-', '-', '-', '+', '.', '#', '<', '>', '^',
X# ifdef FOUNTAINS
X    '}', '{',
X# endif
X# ifdef NEWCLASS
X    '\\',
X# endif
X# ifdef SPIDERS
X    '"',
X# endif
X#ifdef SINKS
X    '#',
X#endif
X};
X
Xstruct symbols showsyms;	/* will contain the symbols actually used */
X
X#endif	/* GRAPHICS /**/
X
X#ifdef DGK
Xchar hackdir[PATHLEN];		/* where rumors, help, record are */
Xchar levels[PATHLEN];		/* where levels are */
Xchar lock[FILENAME];		/* pathname of level files */
Xchar permbones[PATHLEN];	/* where permanent copy of bones go */
Xint ramdisk = FALSE;		/* whether to copy bones to levels or not */
Xint saveprompt = TRUE;
Xchar *alllevels = "levels.*";
Xchar *allbones = "bones.*";
Xchar *configfile = "NetHack.cnf";	/* read by read_config_file() */
X#else
Xchar lock[PL_NSIZ+4] = "1lock";		/* long enough for login name .99 */
X#endif
X
Xboolean in_mklev, restoring;
Xstruct rm levl[COLNO][ROWNO];		/* level map */
X
X#ifndef QUEST
X#include "mkroom.h"
Xstruct mkroom rooms[MAXNROFROOMS+1];
Xcoord doors[DOORMAX];
X#endif
X
Xstruct monst *fmon = 0;
Xstruct trap *ftrap = 0;
Xstruct gold *fgold = 0;
Xstruct obj *fobj = 0, *fcobj = 0, *invent = 0, *uwep = 0, *uarm = 0,
X#ifdef SHIRT
X        *uarmu = 0,		/* under-wear, so to speak */
X#endif
X	*uarm2 = 0, *uarmh = 0, *uarms = 0, *uarmg = 0, *uright = 0,
X	*uleft = 0, *uchain = 0, *uball = 0;
Xstruct flag flags;
Xstruct you u;
X
X#ifdef SPELLS
Xstruct spell spl_book[MAXSPELL + 1];
X#endif
X
Xstruct monst youmonst;	/* dummy; used as return value for boomhit */
X
Xxchar dlevel = 1;
Xxchar xupstair, yupstair, xdnstair, ydnstair;
Xchar *save_cm = 0, *killer, *nomovemsg;
X
Xlong moves = 1;
Xlong wailmsg = 0;
Xint multi = 0;
Xchar	*occtxt;
X#ifdef DGKMOD
Xint	occtime;
X#endif
X#ifdef REDO
Xint	in_doagain = FALSE;
X#endif
X
Xchar *HI, *HE;		/* set up in termcap.c */
X#ifdef MSDOSCOLOR
Xchar *HI_MON, *HI_OBJ;	/* set up in termcap.c */
X#endif
X
Xchar genocided[60];
Xchar fut_geno[60];
X#ifdef KAA
Xboolean	stoned;				/* done to monsters hit by 'c' */
Xboolean	unweapon;
X#endif
X 
Xxchar curx,cury;
Xxchar seelx, seehx, seely, seehy;	/* corners of lit room */
X
Xcoord bhitpos;
X
Xchar quitchars[] = " \r\n\033";
END_OF_decl.c
if test 2357 -ne `wc -c <decl.c`; then
    echo shar: \"decl.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f edog.h -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"edog.h\"
else
echo shar: Extracting \"edog.h\" \(670 characters\)
sed "s/^X//" >edog.h <<'END_OF_edog.h'
X/*	SCCS Id: @(#)edog.h	1.4	87/08/08
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* edog.h - version 1.0.2 */
X
X/*	various types of food, the lower, the better liked.	*/
X
X#define	DOGFOOD	0
X#define	CADAVER	1
X#define	ACCFOOD	2
X#define	MANFOOD	3
X#define	APPORT	4
X#define	POISON	5
X#define	UNDEF	6
X
Xstruct edog {
X	long hungrytime;	/* at this time dog gets hungry */
X	long eattime;		/* dog is eating */
X	long droptime;		/* moment dog dropped object */
X	unsigned dropdist;		/* dist of drpped obj from @ */
X	unsigned apport;		/* amount of training */
X	long whistletime;		/* last time he whistled */
X};
X#define	EDOG(mp)	((struct edog *)(&(mp->mextra[0])))
END_OF_edog.h
if test 670 -ne `wc -c <edog.h`; then
    echo shar: \"edog.h\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f eshk.h -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"eshk.h\"
else
echo shar: Extracting \"eshk.h\" \(742 characters\)
sed "s/^X//" >eshk.h <<'END_OF_eshk.h'
X/*	SCCS Id: @(#)eshk.h	2.1	87/09/28
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X
X#define	BILLSZ	200
X
Xstruct bill_x {
X	unsigned bo_id;
X	unsigned price;		/* price per unit */
X	Bitfield(useup,1);
X	Bitfield(bquan,7);
X};
X
Xstruct eshk {
X	long int robbed;	/* amount stolen by most recent customer */
X	boolean following;	/* following customer since he owes us sth */
X	schar shoproom;		/* index in rooms; set by inshop() */
X	coord shk;		/* usual position shopkeeper */
X	coord shd;		/* position shop door */
X	int shoplevel;		/* level of his shop */
X	int billct;
X	struct bill_x bill[BILLSZ];
X	int visitct;		/* nr of visits by most recent customer */
X	char customer[PL_NSIZ];	/* most recent customer */
X	char shknam[PL_NSIZ];
X};
END_OF_eshk.h
if test 742 -ne `wc -c <eshk.h`; then
    echo shar: \"eshk.h\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f extern.h -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"extern.h\"
else
echo shar: Extracting \"extern.h\" \(1501 characters\)
sed "s/^X//" >extern.h <<'END_OF_extern.h'
X/*	SCCS Id: @(#)extern.h	2.3	87/12/12
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X
X#include "config.h"
X
X/*
X *	I have been told, that in Sys V R3.1, this has to be commented out.
X */
X#ifndef MSDOS
Xextern char *sprintf();
X#endif
X
Xextern long *alloc();
X
Xextern xchar xdnstair, ydnstair, xupstair, yupstair; /* stairs up and down. */
X
Xextern xchar dlevel;
X
X#ifdef SPELLS
X#include "spell.h"
Xextern	struct spell spl_book[];	/* sized in decl.c */
X#endif
X
Xextern int occtime;
Xextern char *occtxt;		/* defined when occupation != NULL */
X
X#ifdef REDO
Xextern int in_doagain;
X#endif
X
Xextern char *HI, *HE;		/* set up in termcap.c */
X#ifdef MSDOSCOLOR
Xextern char *HI_MON, *HI_OBJ;	/* set up in termcap.c */
X#endif
X
X#include "obj.h"
Xextern struct obj *invent, *uwep, *uarm, *uarm2, *uarmh, *uarms, *uarmg, 
X#ifdef SHIRT
X	*uarmu, /* under-wear, so to speak */
X#endif
X	*uleft, *uright, *fcobj;
Xextern struct obj *uchain;	/* defined iff PUNISHED */
Xextern struct obj *uball;	/* defined if PUNISHED */
Xstruct obj *o_at(), *getobj(), *sobj_at();
X
Xextern char *traps[];
Xextern char *monnam(), *Monnam(), *amonnam(), *Amonnam(),
X	*doname(), *aobjnam();
Xextern char readchar();
Xextern char vowels[];
X
X#include "you.h"
X
Xextern struct you u;
X
Xextern xchar curx,cury;	/* cursor location on screen */
X
Xextern xchar seehx,seelx,seehy,seely; /* where to see*/
Xextern char *save_cm,*killer;
X
Xextern xchar dlevel, maxdlevel; /* dungeon level */
X
Xextern long moves;
X
Xextern int multi;
X
Xextern char lock[];
END_OF_extern.h
if test 1501 -ne `wc -c <extern.h`; then
    echo shar: \"extern.h\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f flag.h -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"flag.h\"
else
echo shar: Extracting \"flag.h\" \(2142 characters\)
sed "s/^X//" >flag.h <<'END_OF_flag.h'
X/*	SCCS Id: @(#)flag.h	1.4	87/08/08
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* flag.h - version 1.0.3 */
X
Xstruct flag {
X	unsigned ident;		/* social security number for each monster */
X	unsigned debug;		/* in debugging mode */
X#define	wizard	flags.debug
X	unsigned toplin;	/* a top line (message) has been printed */
X				/* 0: top line empty; 2: no --More-- reqd. */
X	unsigned cbreak;	/* in cbreak mode, rogue format */
X	unsigned standout;	/* use standout for --More-- */
X	unsigned nonull;	/* avoid sending nulls to the terminal */
X	unsigned time;		/* display elapsed 'time' */
X	unsigned nonews;	/* suppress news printing */
X	unsigned notombstone;
X	unsigned end_top, end_around;	/* describe desired score list */
X	unsigned end_own;		/* idem (list all own scores) */
X	unsigned no_rest_on_space;	/* spaces are ignored */
X	unsigned beginner;
X	unsigned female;
X	unsigned invlet_constant;	/* let objects keep their
X					   inventory symbol */
X	unsigned move;
X	unsigned mv;
X	unsigned run;		/* 0: h (etc), 1: H (etc), 2: fh (etc) */
X				/* 3: FH, 4: ff+, 5: ff-, 6: FF+, 7: FF- */
X	unsigned nopick;	/* do not pickup objects */
X	unsigned echo;		/* 1 to echo characters */
X	unsigned botl;		/* partially redo status line */
X	unsigned botlx;		/* print an entirely new bottom line */
X	unsigned nscrinh;	/* inhibit nscr() in pline(); */
X	unsigned made_amulet;
X	unsigned no_of_wizards;	/* 0, 1 or 2 (wizard and his shadow) */
X				/* reset from 2 to 1, but never to 0 */
X	unsigned moonphase;
X#define	NEW_MOON	0
X#define	FULL_MOON	4
X
X#ifdef SORTING
X	unsigned sortpack;	/* sorted inventory */
X#endif
X#ifdef SAFE_ATTACK
X	unsigned confirm;	/* confirm before hitting tame monsters */
X#endif
X#ifdef DGKMOD
X	unsigned silent;	/* whether the bell rings or not */
X	unsigned pickup;	/* whether you pickup or move and look */
X#endif
X#ifdef DGK
X	unsigned IBMBIOS;	/* whether we can use a BIOS call for
X				 * redrawing the screen and character input */
X	unsigned DECRainbow;	/* Used for DEC Rainbow graphics. */
X	unsigned rawio;		/* Whether can use rawio (IOCTL call) */
X	unsigned extra1;
X	unsigned extra2;
X#endif
X};
X
Xextern struct flag flags;
END_OF_flag.h
if test 2142 -ne `wc -c <flag.h`; then
    echo shar: \"flag.h\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f fount.tbl -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"fount.tbl\"
else
echo shar: Extracting \"fount.tbl\" \(1943 characters\)
sed "s/^X//" >fount.tbl <<'END_OF_fount.tbl'
X.S 9 10
X.TS H
Xtab (#), center, expand, box;
Xc c
Xl | l.
XMessage#Effect
X_
X.TH
X``Good Lord!  An endless stream of snakes pours forth!''#3-4 snakes appear
X``The fountain bubbles furiously for a moment, then calms.''#makemon failed
X_
X``You have unleashed a water demon!''#Infrequent, but dangerous
X``Grateful for his release, he grants you a wish!''#Very unlikely (3%)
X_
X``You have attracted a water nymph!''#Nymph appears, will steal
X``A large bubble rises to the surface and pops.''#makemon failed
X_
X``Water gushes forth from the overflowing fountain!''#Drowning pools
X_
X``You spot a gem in the sparkling waters!''#Real gem appears
X_
X``The fountain dries up!''#Usually happens after 2-5 dips
X_
X``The cool draught refreshes you.''#Decreases hunger
X_
X``The water is foul!  You gag and vomit.''#Hunger
X``What a relief!''#Cures if already sick
X_
X``The water is contaminated!''#Poison damage, - strength
X``Perhaps it is run off from the nearby orange farm.''#If poison resistant
X_
X``This water's no good!''#Curses an object, hunger
X_
X``You see an image of someone stalking you. But it disappears.''#Permanent see invisible
X_
X``You sense the presence of monsters.''#Detect monster
X``You feel oddly disturbed.''#If no monsters
X_
X``This water gives you bad breath!''#Cause fear
X_
X``Your weapon rusts somewhat.''#-1 damage (swords only)
X``Your weapon looks quite rusted.''#If < -6 already
X_
X``A murky hand from the depths reaches up to bless the sword.''#+5 Excalibur
X``As the hand retreats, the fountain disappears!''
X_
X``Well, it looks wet now.''#Sword may be stickeycursed
X``The water glows for a moment.''#Lift curse from weapon
X``A feeling of loss comes over you.''#Missed lift curse
X_
X``Your thirst is quenched.''#No effect
X``A strange tingling runs up your arm.''#No effect
X``You feel a sudden chill.''#No effect
X``An urge to take a bath nearly overwhelms you.''#No effect
X``Far below you, you see coins glistening in the water.''#No effect
X.TE
X.S
END_OF_fount.tbl
if test 1943 -ne `wc -c <fount.tbl`; then
    echo shar: \"fount.tbl\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f func_tab.h -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"func_tab.h\"
else
echo shar: Extracting \"func_tab.h\" \(360 characters\)
sed "s/^X//" >func_tab.h <<'END_OF_func_tab.h'
X/*	SCCS Id: @(#)func_tab.h	1.4	87/08/08
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* func_tab.h - version 1.0.2 */
X
Xstruct func_tab {
X	char f_char;
X	int (*f_funct)();
X	char *f_text;
X};
X
Xextern struct func_tab cmdlist[];
X
Xstruct ext_func_tab {
X	char *ef_txt, *ef_desc;
X	int (*ef_funct)();
X};
X
Xextern struct ext_func_tab extcmdlist[];
END_OF_func_tab.h
if test 360 -ne `wc -c <func_tab.h`; then
    echo shar: \"func_tab.h\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f gen.h -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"gen.h\"
else
echo shar: Extracting \"gen.h\" \(446 characters\)
sed "s/^X//" >gen.h <<'END_OF_gen.h'
X/*	SCCS Id: @(#)gen.h	1.4	87/08/08
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* gen.h version 1.0.1: added ONCE flag */
X
Xstruct gen {
X	struct gen *ngen;
X	xchar gx,gy;
X	unsigned gflag;		/* 037: trap type; 040: SEEN flag */
X				/* 0100: ONCE only */
X#define	TRAPTYPE	037
X#define	SEEN	040
X#define	ONCE	0100
X};
Xextern struct gen *fgold, *ftrap;
Xstruct gen *g_at();
X#define newgen()	(struct gen *) alloc(sizeof(struct gen))
END_OF_gen.h
if test 446 -ne `wc -c <gen.h`; then
    echo shar: \"gen.h\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f gold.h -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"gold.h\"
else
echo shar: Extracting \"gold.h\" \(311 characters\)
sed "s/^X//" >gold.h <<'END_OF_gold.h'
X/*	SCCS Id: @(#)gold.h	1.4	87/08/08
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* gold.h - version 1.0.2 */
X
Xstruct gold {
X	struct gold *ngold;
X	xchar gx,gy;
X	long amount;
X};
X
Xextern struct gold *fgold;
Xstruct gold *g_at();
X#define newgold()	(struct gold *) alloc(sizeof(struct gold))
END_OF_gold.h
if test 311 -ne `wc -c <gold.h`; then
    echo shar: \"gold.h\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f hh -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"hh\"
else
echo shar: Extracting \"hh\" \(2141 characters\)
sed "s/^X//" >hh <<'END_OF_hh'
Xy k u	Move commands:
X \|/		hykulnjb: single move in specified direction
Xh-+-l		HYKULNJB: repeated move in specified direction
X /|\			  (until stopped by e.g. a wall)
Xb j n		g<dir>:   fast movement in direction <dir>
X			  (until something interesting is seen)
X		m<dir>:   move without picking up objects
X
XMeta commands:
XQ	quit	leave the game
XS	save	save the game (to be continued later)
X!	sh	escape to some SHELL
X^Z	suspend suspend the game (independent of your current suspend char)
XO	set	set options
X?	help	print information
X/	whatis	give name (and sometimes more info) of specified monster
X\	known	print list of what's been discovered
Xv	version	print version number
XV	history	print game history.
X^R	redraw	redraw the screen (^R denotes the symbol CTRL/R)
X^P	print	repeat last message  (subsequent ^P's repeat earlier messages)
X#		introduces a long command (# ? for list of long commands)
X
XGame commands:
X^T	teleport teleport
Xa	apply, use  use something (a key, camera, etc.)
Xc	call	give a name to a class of objects
Xd	drop	drop an object. d7a: drop seven items of object a.
Xe	eat	eat something
Xi	invent	list the inventory (all objects you are carrying)
XI	invent	list selected parts of the inventory
X		IU: list unpaid objects
X		IX: list unpaid but used up items
X		I$: count your money
Xp	pay	pay your bill
Xq	drink	quaff a potion
Xr	read	read a scroll
Xs	search	search for secret doors, hidden traps and monsters
Xt	throw	throw or shoot a weapon
Xw	wield	wield a weapon	(w-  wield nothing)
Xx	spells	print a list of know spells
XX	Xcribe	transcribe (learn) a spell
Xz	zap	zap a wand
XZ	cast	cast a spell
XC	name	name an individual monster (e.g., baptize your dog)
XD	Drop	drop several things
XE	Engrave write a message in the dust on the floor  (E-  use fingers)
XP	wear	put on a ring
XR	remove	remove a ring
XW	wear	put on some armor
XT	remove	take off some armor
XA	remove	take off some or all armor
X<	up	go up the stairs
X>	down	go down the stairs
X^	trap_id identify a previously found trap
X),[,=		ask for current weapon, armor, rings, respectively
X$	gold	count your gold
X.	rest	wait a moment
X,	pickup	pick up all you can carry
X:	look	look at what is here
END_OF_hh
if test 2141 -ne `wc -c <hh`; then
    echo shar: \"hh\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f ioctl.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"ioctl.c\"
else
echo shar: Extracting \"ioctl.c\" \(1399 characters\)
sed "s/^X//" >ioctl.c <<'END_OF_ioctl.c'
X/*	SCCS Id: @(#)ioctl.c	2.0	87/09/18
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X
X/* This cannot be part of hack.tty.c (as it was earlier) since on some
X   systems (e.g. MUNIX) the include files <termio.h> and <sgtty.h>
X   define the same constants, and the C preprocessor complains. */
X#include <stdio.h>
X#include "config.h"
X#ifdef BSD
X#include	<sgtty.h>
Xstruct ltchars ltchars, ltchars0;
X#else
X#include	<termio.h>	/* also includes part of <sgtty.h> */
Xstruct termio termio;
X#endif
X
Xgetioctls() {
X#ifdef BSD
X	(void) ioctl(fileno(stdin), (int) TIOCGLTC, (char *) &ltchars);
X	(void) ioctl(fileno(stdin), (int) TIOCSLTC, (char *) &ltchars0);
X#else
X	(void) ioctl(fileno(stdin), (int) TCGETA, &termio);
X#endif
X}
X
Xsetioctls() {
X#ifdef BSD
X	(void) ioctl(fileno(stdin), (int) TIOCSLTC, (char *) &ltchars);
X#else
X	/* Now modified to run under Sys V R3.	- may have to be #ifdef'ed */
X	(void) ioctl(fileno(stdin), (int) TCSETAW, &termio);
X#endif
X}
X
X#ifdef SUSPEND		/* implies BSD */
Xdosuspend() {
X#include	<signal.h>
X#ifdef SIGTSTP
X	if(signal(SIGTSTP, SIG_IGN) == SIG_DFL) {
X		settty((char *) 0);
X		(void) signal(SIGTSTP, SIG_DFL);
X		(void) kill(0, SIGTSTP);
X		gettty();
X		setftty();
X		docrt();
X	} else {
X		pline("I don't think your shell has job control.");
X	}
X#else SIGTSTP
X	pline("Sorry, it seems we have no SIGTSTP here. Try ! or S.");
X#endif
X	return(0);
X}
X#endif /* SUSPEND /**/
END_OF_ioctl.c
if test 1399 -ne `wc -c <ioctl.c`; then
    echo shar: \"ioctl.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f mfndpos.h -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"mfndpos.h\"
else
echo shar: Extracting \"mfndpos.h\" \(641 characters\)
sed "s/^X//" >mfndpos.h <<'END_OF_mfndpos.h'
X/*	SCCS Id: @(#)mfndpos.h	1.4	87/08/08
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* mfndpos.h - version 1.0.2 */
X 
X/* changed by GAN 02/06/87 to add nine extra bits for traps -
X * this because new traps make nine for traps insufficient
X */
X 
X#define ALLOW_TRAPS     0777777
X#define ALLOW_U         01000000
X#define ALLOW_M         02000000
X#define ALLOW_TM        04000000
X#define ALLOW_ALL       (ALLOW_U | ALLOW_M | ALLOW_TM | ALLOW_TRAPS)
X#define ALLOW_SSM       010000000
X#define ALLOW_ROCK      020000000
X#define NOTONL          040000000
X#define NOGARLIC        0100000000
X#define ALLOW_WALL      0200000000
END_OF_mfndpos.h
if test 641 -ne `wc -c <mfndpos.h`; then
    echo shar: \"mfndpos.h\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f mkroom.h -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"mkroom.h\"
else
echo shar: Extracting \"mkroom.h\" \(2085 characters\)
sed "s/^X//" >mkroom.h <<'END_OF_mkroom.h'
X/*	SCCS Id: @(#)mkroom.h	2.3	87/12/12
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X
X/* mkroom.h - types and structures for room and shop initialization */
X
Xstruct mkroom {
X	schar lx,hx,ly,hy;	/* usually xchar, but hx may be -1 */
X	schar rtype,rlit,doorct,fdoor;
X};
X
Xstruct shclass {
X	char	*name;	/* name of the shop type */
X	char	symb;	/* this identifies the shop type */
X    	int	prob;	/* the shop type probability in % */
X	schar	dist;	/* artifact placement type */
X#define D_SCATTER	0	/* normal placement */
X#define D_SHOP		1	/* shop-like placement */
X#define D_TEMPLE	2	/* temple-like placement */
X	struct itp {
X	    int	iprob;	/* probability of an item type */
X	    int itype;	/* item type: if >=0 a class, if < 0 a specific item */
X	} iprobs[5];
X	char **shknms;	/* string list of shopkeeper names for this type */
X};
Xextern struct shclass shtypes[];	/* defined in shknam.c */
X
X#define	MAXNROFROOMS	15
Xextern struct mkroom rooms[MAXNROFROOMS+1];
X
X#define	DOORMAX	100
Xextern coord doors[DOORMAX];
X
X/* values for rtype in the room definition structure */
X#define OROOM		 0	/* ordinary room */
X#define COURT		 2	/* contains a throne */
X#define	SWAMP		 3	/* contains pools */
X#define	VAULT		 4	/* contains piles of gold */
X#define	BEEHIVE		 5	/* contains killer bees and royal jelly */
X#define	MORGUE		 6	/* contains corpses, undead and ghosts */
X#define BARRACKS	 7	/* contains soldiers and their gear */
X#define	ZOO		 8	/* floor covered with treasure and monsters */
X#define	SHOPBASE	 9	/* everything above this is a shop */
X
X#define IS_SHOP(x)	((x).rtype >= SHOPBASE)
X
X/* mkshop.c entry points (should become mkroom.c in next major release) */
Xextern void mkroom();		/* make and stock a room of a given type */
Xextern boolean nexttodoor();	/* TRUE if adjacent to a door */
Xextern boolean has_dnstairs();	/* TRUE if given room has a down staircase */
Xextern boolean has_upstairs();	/* TRUE if given room has an up staircase */
Xextern int dist2();		/* Euclidean square-of-distance function */
Xextern struct permonst *courtmon();	/* generate a court monster */
END_OF_mkroom.h
if test 2085 -ne `wc -c <mkroom.h`; then
    echo shar: \"mkroom.h\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f monst.h -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"monst.h\"
else
echo shar: Extracting \"monst.h\" \(2349 characters\)
sed "s/^X//" >monst.h <<'END_OF_monst.h'
X/*	SCCS Id: @(#)monst.h	2.3	88/02/11
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X
Xstruct monst {
X	struct monst *nmon;
X	struct permonst *data;
X	unsigned m_id;
X	xchar mx,my;
X	xchar mdx,mdy;		/* if mdispl then pos where last displayed */
X#define	MTSZ	4
X	coord mtrack[MTSZ];	/* monster track */
X	schar mhp,mhpmax;
X	char mappearance;	/* nonzero for undetected 'M's and for '1's */
X	Bitfield(mimic,1);	/* undetected mimic */
X	Bitfield(mdispl,1);	/* mdx,mdy valid */
X	Bitfield(minvis,1);	/* invisible */
X	Bitfield(cham,1);	/* shape-changer */
X	Bitfield(mhide,1);	/* hides beneath objects */
X	Bitfield(mundetected,1);	/* not seen in present hiding place */
X	Bitfield(mspeed,2);
X	Bitfield(mflee,1);	/* fleeing */
X	Bitfield(mfleetim,7);	/* timeout for mflee */
X	Bitfield(msleep,1);
X	Bitfield(mfroz,1);
X	Bitfield(mconf,1);
X	Bitfield(mcan,1);	/* has been cancelled */
X	Bitfield(mtame,1);	/* implies peaceful */
X	Bitfield(mpeaceful,1);	/* does not attack unprovoked */
X	Bitfield(isshk,1);	/* is shopkeeper */
X	Bitfield(isgd,1);	/* is guard */
X	Bitfield(mcansee,1);	/* cansee 1, temp.blinded 0, blind 0 */
X	Bitfield(mblinded,7);	/* cansee 0, temp.blinded n, blind 0 */
X	Bitfield(mtrapped,1);	/* trapped in a pit or bear trap */
X	Bitfield(mnamelth,6);	/* length of name (following mxlth) */
X#ifndef NOWORM
X	Bitfield(wormno,5);	/* at most 31 worms on any level */
X#endif
X#ifdef WALKIES
X	Bitfield(mleashed,1);	/* monster is on a leash */
X#endif
X	Bitfield(dragon,3);	/* multiple dragon type */
X	Bitfield(isdjinni,1);	/* is djinni */
X	Bitfield(isgremlin,1);	/* is gremlin */
X#ifdef STOOGES
X	Bitfield(isstooge,1);	/* is stooge */
X#endif
X	long mtrapseen;		/* bitmap of traps we've been trapped in */
X	long mlstmv;		/* prevent two moves at once */
X	struct obj *minvent;
X	long mgold;
X	unsigned mxlth;		/* length of following data */
X	/* in order to prevent alignment problems mextra should
X	   be (or follow) a long int */
X	long mextra[1];		/* monster dependent info */
X};
X
X#define newmonst(xl)	(struct monst *) alloc((unsigned)(xl) + sizeof(struct monst))
X
Xextern struct monst *fmon;
Xextern struct monst *fallen_down;
Xstruct monst *m_at();
X
X/* these are in mspeed */
X#define MSLOW 1 /* slow monster */
X#define MFAST 2 /* speeded monster */
X
X#define	NAME(mtmp)	(((char *) mtmp->mextra) + mtmp->mxlth)
X#define	MREGEN		"TVi1"
X#define	UNDEAD		"ZVW "
END_OF_monst.h
if test 2349 -ne `wc -c <monst.h`; then
    echo shar: \"monst.h\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f monster.tbl -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"monster.tbl\"
else
echo shar: Extracting \"monster.tbl\" \(2364 characters\)
sed "s/^X//" >monster.tbl <<'END_OF_monster.tbl'
XThe descriptions are as follows:
X.VL 10
X.LI \fImlev\fR
XMonster's level.
X.LI \fImmove\fR
XNon-Spelunkers have a \fImmove\fR of 12.
X.LI \fIac\fR
XMonster's armor class.
X.LI Damage
XMonster's basic attack on you.  Note that quasits, jaguars, dragons,
Xetc. have extra attacks.
X.LI *
XWhether monster is large.  Determines weapon damage.
X.LI \(dg
XMonsters specific to NetHack.
X.LE
X.TS H
Xtab (#),center,expand,box;
Xc c c c c c c
Xc l | n n n | l n.
XSymbol#Monster#\fImlev\fR#\fImmove\fR#\fIac\fR#Damage#XP
X_
X.TH
XA#giant ant*#3#18#3#1d6#16
XB#bat#1#22#8#1d4#2
XC#centaur*#4#18#4#1d6#17
XD#dragon*#10#9#-1#3d10+2(1d8)#257
XE#floating eye#2#1#9#0d0#5
XF#freezing sphere#2#13#4#6d6#5
XG#gnome#1#6#5#1d6#2
XH#hobgoblin#1#9#5#1d8#2
XI#invisible stalker*#8#12#3#4d4#131
XJ#jackal#0#12#7#1d2#1
XK#keystone kop\(dg#1#6#7#1d4#
XK#kobold#1#6#7#1d4#2
XL#leprechaun#5#15#8#1d2#26
XM#mimic#7#3#7#3d4#100
XN#nymph#6#12#9#1d2#37
XO#orc#2#9#6#1d8#5
XP#purple worm*#15#9#6#2d8#411
XQ#quantum mechanic\(dg#6#12#3#1d4#
XQ#quasit#3#15#3#1d4+2(1d2)#10
XR#rust monster#10#18#3#0d0#171
XS#snake*#4#15#3#1d6#25
XT#troll*#7#12#4#2d6+2(1d6)#114
XU#umber hulk*#9#6#2#2d10+2(3d4)#169
XV#vampire*#8#12#1#1d6#199
XW#wraith#5#12#5#1d6#36
XX#xorn#8#9#-2#4d6+3(1d6)#149
XY#yeti*#5#15#6#2(1d6)#26
XZ#zombie#2#6#8#1d8#5
Xa#acid blob#2#3#8#0d0#9
Xb#giant beetle*#4#6#4#3d4#17
Xc#cockatrice#4#6#6#1d3#25
Xd#dog#4#16#5#1d6#17
Xd#large dog*#6#15#4#2d4#37
Xd#little dog#2#18#6#1d6#17
Xe#ettin*#10#12#3#2d8+3d#241
Xf#fog cloud#3#1#0#1d6#24
Xg#gelatinous cube*#4#6#8#2d4#17
Xh#homunculus#2#6#6#1d3#5
Xi#imp#2#6#2#1d4#15
Xj#jaguar#4#15#6#1d8+2(1d3)+2(1d4)#17
Xk#killer bee#4#14#4#2d4#17
Xl#leocrotta*#6#18#4#3d6#37
Xm#minotaur*#15#15#6#4d8#276
Xn#nurse*#11#6#0#1d3#208
Xo#owlbear*#5#12#5#2d6+2(1d6)+2d8#26
Xp#piercer#3#1#3#2d6#10
Xq#quivering blob#3#1#8#1d8#10
Xr#giant rat#0#12#7#1d3#1
Xr#rockmole\(dg#3#3#0#1d6#
Xs#giant spider\(dg*#5#15#3#1d4#
Xs#giant scorpion*#5#15#3#1d4+2(1d8)#36
Xt#tengu#5#13#5#1d7#26
Xu#unicorn#8#24#5#1d10#115
Xv#violet fungi#3#1#7#1d4#10
Xw#long worm*#8#3#5#1d4#115
Xw#wumpus*#8#3#2#3d6#
Xx#xan#7#18#-2#2d4#118
Xy#yellow light#3#15#0#0d0#24
Xz#zruty#9#8#3#3d6#132
X #ghost*#10#3#-5#?#265
X&#demon*#10#9#-4#1d4#263
X,#trapper*#12#3#3#0d0#303
X1#wizard of yendor*#15#12#-2#1d12#
X2#mail daemon#\-#\-#\-#n/a#
X9#giant\(dg*#9#18#5#2d12#
X:#chameleon#6#5#6#4d2#49
X;#giant eel\(dg*#15#6#-3#3d6#
X@#shopkeeper#10#18#0#4d8#40#165
X~#lurker above*#10#3#3#0d0#151
X.TE
END_OF_monster.tbl
if test 2364 -ne `wc -c <monster.tbl`; then
    echo shar: \"monster.tbl\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f msdos.h -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"msdos.h\"
else
echo shar: Extracting \"msdos.h\" \(1206 characters\)
sed "s/^X//" >msdos.h <<'END_OF_msdos.h'
X/*	SCCS Id: @(#)msdos.h	1.4	87/08/08
X/* msdos.h - function declarations for msdos.c */
X
Xextern char *alllevels, *allbones;
Xextern char levels[], bones[], permbones[], SAVEF[], hackdir[];
Xextern int ramdisk, count_only;
X
X#define CTRL(ch) (ch & 0x37)
X#define ABORT CTRL('A')
X#define COUNT 0x1
X#define WRITE 0x2
X
X#ifdef LINT_ARGS		/* arg. checking enabled */
X
Xvoid	append_slash(char *);
Xvoid	chdrive(char *);
Xint	check_then_creat(char *, int);
Xvoid	copybones(int);
Xint	dosh();
Xint	dotogglepickup();
Xlong	filesize(char *);
Xvoid	flushout();
Xlong	freediskspace(char *);
Xvoid	gameDiskPrompt();
Xchar *	getlogin();
Xvoid	getreturn(char *);
Xchar *	getenv();
Xint	getuid();
Xchar *	let_to_name(char);
Xvoid	msexit(int);
Xvoid	msmsg(char *, ...);
Xvoid	name_file(char *, int);
Xvoid	pushch(char);
Xvoid	read_config_file();
X#ifdef DGK
Xint	savelev(int, xchar, int);
X#endif
Xint	saveDiskPrompt(int);
Xvoid	set_lock_and_bones();
Xint	tgetch();
X
X#else
X
Xextern long	filesize(), freediskspace();
Xextern char	*getlogin(), *let_to_name();
Xextern void	append_slash(), chdrive(), copybones();
Xextern void	gameDiskPrompt(), getreturn(), msexit(), msmsg(), name_file();
Xextern void	pushch(), read_config_file(), set_lock_and_bones();
X
X#endif
END_OF_msdos.h
if test 1206 -ne `wc -c <msdos.h`; then
    echo shar: \"msdos.h\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f nethack.cnf -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"nethack.cnf\"
else
echo shar: Extracting \"nethack.cnf\" \(618 characters\)
sed "s/^X//" >nethack.cnf <<'END_OF_nethack.cnf'
X#
X#	nethack.cnf	for NetHack release 2.3
X#
XHACKDIR=c:\games\nethack
XSAVE=c:\games\nethack\save
XLEVELS=c:\games\nethack\save
XOPTIONS=male,rawio,IBMBIOS,no rest_on_space,time,packorder:"/!?=)[%(*0
XOPTIONS=silent,endgame:10t/0a
X# The 9 GRAPHICS characters are:
X# vertical wall, horizontal wall, top left corner, top right corner
X# bottom left corner, bottom right corner, door, floor, corridor
X# An example using the IBM graphics character set.
X# from hack.35: GRAPHICS = 186 205 201 187 200 188 206 249 177
X# from hack.36: GRAPHICS = 179 196 218 191 192 217 206 250 176
XGRAPHICS = 032 186 205 201 187 200 188 206 249 177
END_OF_nethack.cnf
if test 618 -ne `wc -c <nethack.cnf`; then
    echo shar: \"nethack.cnf\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f nethack.sh -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"nethack.sh\"
else
echo shar: Extracting \"nethack.sh\" \(219 characters\)
sed "s/^X//" >nethack.sh <<'END_OF_nethack.sh'
X#!/bin/sh
X#	SCCS Id: @(#)nethack.sh	1.4	87/08/08
XHACKDIR=/usr/games/lib/nethackdir
XHACK=$HACKDIR/nethack
XMAXNROFPLAYERS=4
X
Xcd $HACKDIR
Xcase $1 in
X	-s*)
X		exec $HACK $@
X		;;
X	*)
X		exec $HACK $@ $MAXNROFPLAYERS
X		;;
Xesac
END_OF_nethack.sh
if test 219 -ne `wc -c <nethack.sh`; then
    echo shar: \"nethack.sh\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f netquest.sh -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"netquest.sh\"
else
echo shar: Extracting \"netquest.sh\" \(224 characters\)
sed "s/^X//" >netquest.sh <<'END_OF_netquest.sh'
X#!/bin/sh
X#	SCCS Id: @(#)netquest.sh	1.4	87/08/08
XQUESTDIR=/usr/games/lib/questdir
XQUEST=$HACKDIR/netquest
XMAXNROFPLAYERS=4
X
Xcd $QUESTDIR
Xcase $1 in
X	-s*)
X		exec $QUEST $@
X		;;
X	*)
X		exec $QUEST $@ $MAXNROFPLAYERS
X		;;
Xesac
END_OF_netquest.sh
if test 224 -ne `wc -c <netquest.sh`; then
    echo shar: \"netquest.sh\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f nfs.fix -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"nfs.fix\"
else
echo shar: Extracting \"nfs.fix\" \(859 characters\)
sed "s/^X//" >nfs.fix <<'END_OF_nfs.fix'
X
X
X
XThere is a bug in nethack 2.2 which shows up when the playground is
Xon a networked filesystem visible to several machines. The symptom is
Xa "Can't open alock. Perhaps someone removed it." error when attempting
Xto save a game or go up a level. The problem lies in the veryold() routine
Xin unix.c which looks to see if the process which created the lock file is
Xstill running, and if not removes it. Well, on a network the chances are
Xthat the process won't running on the current machine, but will be running
Xon another. My solution was just to remove the check for the existing pid
Xand replace it with a return 0. Perhaps better would be another #define
Xfor NETWORKED?
X--keenan ross		UUCP:     {bellcore,ima,ihnp4}!inmet!keenan
X Intermetrics, Inc.	INTERNET: ima!inmet!keenan@CCA-UNIX.ARPA
X 733 Concord Ave.
X Cambridge, MA  02138	PHONE:    (617) 661-1840
X
X
END_OF_nfs.fix
if test 859 -ne `wc -c <nfs.fix`; then
    echo shar: \"nfs.fix\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f obj.h -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"obj.h\"
else
echo shar: Extracting \"obj.h\" \(1800 characters\)
sed "s/^X//" >obj.h <<'END_OF_obj.h'
X/*	SCCS Id: @(#)obj.h	2.3	88/01/21
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X
X#ifndef OBJ_H
X#define OBJ_H
X
Xstruct obj {
X	struct obj *nobj;
X	unsigned o_id;
X	unsigned o_cnt_id;		/* id of container object is in */
X	xchar ox,oy;
X	xchar odx,ody;
X	unsigned otyp;
X#ifdef DGK
X	unsigned int	owt;
X	unsigned int	quan;
X#else
X	uchar owt;
X	uchar quan;		/* use oextra for tmp gold objects */
X#endif
X	schar spe;		/* quality of weapon, armor or ring (+ or -)
X				   number of charges for wand ( >= -1 )
X				   special for uball and amulet %% BAH */
X	char olet;
X	char invlet;
X	Bitfield(oinvis,1);	/* not yet implemented */
X	Bitfield(odispl,1);
X	Bitfield(known,1);	/* exact nature known */
X	Bitfield(dknown,1);	/* color or text known */
X	Bitfield(cursed,1);
X	Bitfield(unpaid,1);	/* on some bill */
X	Bitfield(rustfree,1);
X	Bitfield(no_charge, 1);	/* if shk shouldn't charge for this */
X	Bitfield(onamelth,6);
X	long age;		/* creation date */
X	long owornmask;
X#define	W_ARM	01L
X#define	W_ARM2	02L
X#define	W_ARMH	04L
X#define	W_ARMS	010L
X#define	W_ARMG	020L
X#define	W_TOOL	040L	/* wearing a blindfold or badge */
X#ifdef SHIRT
X#define W_ARMU  0100L
X#define W_ARMOR		(W_ARM | W_ARM2 | W_ARMH | W_ARMS | W_ARMG | W_ARMU)
X#else
X#define	W_ARMOR		(W_ARM | W_ARM2 | W_ARMH | W_ARMS | W_ARMG)
X#endif
X#define	W_RINGL	010000L	/* make W_RINGL = RING_LEFT (see uprop) */
X#define	W_RINGR	020000L
X#define	W_RING		(W_RINGL | W_RINGR)
X#define	W_WEP	01000L
X#define	W_BALL	02000L
X#define	W_CHAIN	04000L
X	long oextra[1];		/* used for name of ordinary objects - length
X				   is flexible; amount for tmp gold objects */
X};
X
Xextern struct obj *fobj;
X
X#define newobj(xl)	(struct obj *) alloc((unsigned)(xl) + sizeof(struct obj))
X#define	ONAME(otmp)	((char *) otmp->oextra)
X#define	OGOLD(otmp)	(otmp->oextra[0])
X
X#endif
END_OF_obj.h
if test 1800 -ne `wc -c <obj.h`; then
    echo shar: \"obj.h\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f objclass.h -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"objclass.h\"
else
echo shar: Extracting \"objclass.h\" \(2152 characters\)
sed "s/^X//" >objclass.h <<'END_OF_objclass.h'
X/*	SCCS Id: @(#)objclass.h	2.3	88/01/24
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X
X/* definition of a class of objects */
X
Xstruct objclass {
X	char *oc_name;		/* actual name */
X	char *oc_descr;		/* description when name unknown */
X	char *oc_uname;		/* called by user */
X	Bitfield(oc_name_known,1);
X	Bitfield(oc_merge,1);	/* merge otherwise equal objects */
X	char oc_olet;
X	schar oc_prob;		/* probability for mkobj() */
X	schar oc_delay;		/* delay when using such an object */
X	uchar oc_weight;
X	schar oc_oc1, oc_oc2;
X	int oc_oi;
X#define	nutrition	oc_oi	/* for foods */
X#define	a_ac		oc_oc1	/* for armors - only used in ARM_BONUS */
X#define ARM_BONUS(obj)	((10 - objects[obj->otyp].a_ac) + obj->spe)
X#define	a_can		oc_oc2	/* for armors */
X#define bits		oc_oc1	/* for wands and rings */
X				/* wands */
X#define		NODIR		1
X#define		IMMEDIATE	2
X#define		RAY		4
X				/* rings */
X#define		SPEC		1	/* +n is meaningful */
X  /* Check the AD&D rules!  The FIRST is small monster damage. */
X#define	wsdam		oc_oc1	/* for weapons and PICK_AXE */
X#define	wldam		oc_oc2	/* for weapons and PICK_AXE */
X
X#define	g_val		oc_oi	/* for gems: value on exit */
X
X#ifdef SPELLS
X#define spl_lev		oc_oi	/* for books: spell level */
X#endif
X};
X
Xextern struct objclass objects[];
X
X/* definitions of all object-symbols */
X
X#define	RANDOM_SYM	'\0'	/* used for generating random objects */
X#define	ILLOBJ_SYM	'\\'
X#define	AMULET_SYM	'"'
X#define	FOOD_SYM	'%'
X#define	WEAPON_SYM	')'
X#define	TOOL_SYM	'('
X#define	BALL_SYM	'0'
X#define	CHAIN_SYM	'_'
X#define	ROCK_SYM	'`'
X#define	ARMOR_SYM	'['
X#define	POTION_SYM	'!'
X#define	SCROLL_SYM	'?'
X#define	WAND_SYM	'/'
X#define	RING_SYM	'='
X#define	GEM_SYM		'*'
X#define	GOLD_SYM	'$'
X#ifdef SPELLS
X#define	SPBOOK_SYM	'+'	/* actually SPELL-book */
X#endif
X/* Other places with explicit knowledge of object symbols:
X * mklev.c:	"=/)%?![<>+"	(used for calculating Amulet apperances)
X * mkobj.c:	char mkobjstr[] = "))[[!!!!????%%%%/=**+";
X * apply.c:   otmp = getobj("0#%", "put in");
X * eat.c:     otmp = getobj("%", "eat");
X * invent.c:          if(index("!%?[)=*(0/+\"", sym)){
X * invent.c:    || index("%?!*+",otmp->olet))){
X */
END_OF_objclass.h
if test 2152 -ne `wc -c <objclass.h`; then
    echo shar: \"objclass.h\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f pcunix.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"pcunix.c\"
else
echo shar: Extracting \"pcunix.c\" \(3611 characters\)
sed "s/^X//" >pcunix.c <<'END_OF_pcunix.c'
X/*	SCCS Id: @(#)pcunix.c	1.4	87/08/08
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* unix.c - version 1.0.3 */
X
X/* This file collects some Unix dependencies; pager.c contains some more */
X
X/*
X * The time is used for:
X *	- seed for rand()
X *	- year on tombstone and yymmdd in record file
X *	- phase of the moon (various monsters react to NEW_MOON or FULL_MOON)
X *	- night and midnight (the undead are dangerous at midnight)
X *	- determination of what files are "very old"
X */
X
X#include <stdio.h>	/* mainly for NULL */
X#include "hack.h"	/* mainly for index() which depends on BSD */
X
X#ifndef __TURBOC__  /* Turbo C has time_t in time.h */
X#include	<sys/types.h>		/* for time_t */
X#endif
X#include	<time.h>
X#include        <sys/stat.h>
X
Xextern time_t time();
Xstatic struct stat buf, hbuf;
X
Xsetrandom()
X{
X	(void) srand((int) time ((time_t *) 0));
X}
X
Xstruct tm *
Xgetlt()
X{
X	time_t date;
X	struct tm *localtime();
X
X	(void) time(&date);
X	return(localtime(&date));
X}
X
Xgetyear()
X{
X	return(1900 + getlt()->tm_year);
X}
X
Xchar *
Xgetdate()
X{
X	static char datestr[7];
X	register struct tm *lt = getlt();
X
X	(void) sprintf(datestr, "%2d%2d%2d",
X		lt->tm_year, lt->tm_mon + 1, lt->tm_mday);
X	if(datestr[2] == ' ') datestr[2] = '0';
X	if(datestr[4] == ' ') datestr[4] = '0';
X	return(datestr);
X}
X
Xphase_of_the_moon()			/* 0-7, with 0: new, 4: full */
X{					/* moon period: 29.5306 days */
X					/* year: 365.2422 days */
X	register struct tm *lt = getlt();
X	register int epact, diy, golden;
X
X	diy = lt->tm_yday;
X	golden = (lt->tm_year % 19) + 1;
X	epact = (11 * golden + 18) % 30;
X	if ((epact == 25 && golden > 11) || epact == 24)
X		epact++;
X
X	return( (((((diy + epact) * 6) + 11) % 177) / 22) & 7 );
X}
X
Xnight()
X{
X	register int hour = getlt()->tm_hour;
X
X	return(hour < 6 || hour > 21);
X}
X
Xmidnight()
X{
X	return(getlt()->tm_hour == 0);
X}
X
Xgethdate(name) char *name; {
X/* old version - for people short of space */
X/*
X/* register char *np;
X/*      if(stat(name, &hbuf))
X/*              error("Cannot get status of %s.",
X/*                      (np = rindex(name, '/')) ? np+1 : name);
X/*
X/* version using PATH from: seismo!gregc@ucsf-cgl.ARPA (Greg Couch) */
X
X/*
X * The problem with   #include  <sys/param.h> is that this include file
X * does not exist on all systems, and moreover, that it sometimes includes
X * <sys/types.h> again, so that the compiler sees these typedefs twice.
X */
X#define         MAXPATHLEN      1024
X
Xregister char *np, *path;
Xchar filename[MAXPATHLEN+1];
X
X    if (index(name, '/') != NULL || (path = getenv("PATH")) == NULL)
X        path = "";
X
X    for (;;) {
X        if ((np = index(path, ':')) == NULL)
X            np = path + strlen(path);       /* point to end str */
X        if (np - path <= 1)                     /* %% */
X            (void) strcpy(filename, name);
X        else {
X            (void) strncpy(filename, path, np - path);
X            filename[np - path] = '/';
X            (void) strcpy(filename + (np - path) + 1, name);
X        }
X        if (stat(filename, &hbuf) == 0)
X            return;
X        if (*np == '\0')
X        path = "";
X        path = np + 1;
X    }
X    error("Cannot get status of %s.", (np = rindex(name, '/')) ? np+1 : name);
X}
X
Xuptodate(fd) {
X    if(fstat(fd, &buf)) {
X        pline("Cannot get status of saved level? ");
X        return(0);
X    }
X    if(buf.st_mtime < hbuf.st_mtime) {
X        pline("Saved level is out of date. ");
X        return(0);
X    }
X    return(1);
X}
X
Xregularize(s)	/* normalize file name - we don't like ..'s or /'s */
Xregister char *s;
X{
X	register char *lp;
X
X	while((lp = index(s, '.')) || (lp = index(s, '/')))
X		*lp = '_';
X}
END_OF_pcunix.c
if test 3611 -ne `wc -c <pcunix.c`; then
    echo shar: \"pcunix.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f permonst.h -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"permonst.h\"
else
echo shar: Extracting \"permonst.h\" \(1431 characters\)
sed "s/^X//" >permonst.h <<'END_OF_permonst.h'
X/*	SCCS Id: @(#)permonst.h	2.3	87/12/16
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X
Xstruct permonst {
X	char *mname,mlet;
X	schar mlevel,mmove,ac,mr,damn,damd;
X	unsigned pxlth;
X};
X
Xextern struct permonst mons[];
X#define PM_GNOME	&mons[1]
X#define PM_HOBGOBLIN	&mons[2]
X#ifndef KOPS
X#define PM_KOBOLD	&mons[4]
X#endif
X#define PM_ACID_BLOB	&mons[7]
X#ifdef ROCKMOLE
X#define PM_ORC		&mons[10]
X#define	PM_ZOMBIE	&mons[12]
X#else
X#define PM_ORC		&mons[11]
X#define	PM_ZOMBIE	&mons[13]
X#endif
X#define	PM_PIERCER	&mons[17]
X#define PM_CENTAUR	&mons[22]
X#define	PM_KILLER_BEE	&mons[26]
X#ifdef SPIDERS
X#define PM_SPIDER	&mons[31]
X#endif
X#define	PM_WRAITH	&mons[33]
X#define	PM_MIMIC	&mons[37]
X#define PM_TROLL	&mons[38]
X#define	PM_VAMPIRE	&mons[43]
X#define PM_XORN		&mons[44]
X#define	PM_CHAMELEON	&mons[47]
X#define PM_DRAGON	&mons[48]
X#define PM_ETTIN	&mons[49]
X/* The ones below changed to include giants. */
X#define	PM_DEMON	&mons[55]
X
X#define	PM_MINOTAUR	&mons[56]	/* last in mons array */
X#define	PM_SHK		&mons[57]	/* very last */
X
X#define	PM_GHOST	&pm_ghost
X#define	PM_EEL		&pm_eel
X#define	PM_WIZARD	&pm_wizard
X#ifdef RPH
X#define PM_MEDUSA	&pm_medusa
X#endif
X#ifdef SAC
X#define PM_SOLDIER	&pm_soldier
X#endif
X#define	CMNUM		56		/* number of common monsters */
X#ifdef STOOGES
X#define PM_LARRY	&pm_larry
X#define PM_CURLY	&pm_curly
X#define PM_MOE		&pm_moe
X#endif
X#define PM_DJINNI	&pm_djinni
X#define PM_GREMLIN	&pm_gremlin
END_OF_permonst.h
if test 1431 -ne `wc -c <permonst.h`; then
    echo shar: \"permonst.h\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f rip.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"rip.c\"
else
echo shar: Extracting \"rip.c\" \(2242 characters\)
sed "s/^X//" >rip.c <<'END_OF_rip.c'
X/*	SCCS Id: @(#)rip.c	2.3	88/02/11
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X
X#include <stdio.h>
X#include "hack.h"
X#ifdef GENIX
X#define	void	int	/* jhn - mod to prevent compiler from bombing */
X#endif
X
Xextern char plname[];
X
Xstatic char *rip[] = {
X"                       ----------",
X"                      /          \\",
X"                     /    REST    \\",
X"                    /      IN      \\",
X"                   /     PEACE      \\",
X"                  /                  \\",
X"                  |                  |",
X"                  |                  |",
X"                  |                  |",
X"                  |                  |",
X"                  |                  |",
X"                  |       1001       |",
X"                 *|     *  *  *      | *",
X"        _________)/\\\\_//(\\/(/\\)/\\//\\/|_)_______\n",
X0
X};
X
Xoutrip(){
X	register char **dp = rip;
X	register char *dpx;
X	char buf[BUFSZ];
X	register x,y;
X
X	cls();
X	(void) sprintf(buf,"%s%s", (Badged) ? "Officer " : "", plname);
X	buf[16] = 0;
X	center(6, buf);
X	(void) sprintf(buf, "%ld AU", u.ugold);
X	center(7, buf);
X	(void) sprintf(buf, "killed by%s",
X		!strncmp(killer, "the ", 4) ? "" :
X		!strcmp(killer, "starvation") ? "" :
X		!strncmp(killer, "Mr.") ? "" :
X		!strncmp(killer, "Ms.") ? "" :
X#ifdef STOOGES
X		!strcmp(killer, "Larry") ? "" :
X		!strcmp(killer, "Curly") ? "" :
X		!strcmp(killer, "Moe") ? "" :
X#endif
X		index(vowels, *killer) ? " an" : " a");
X	center(8, buf);
X	(void) strcpy(buf, killer);
X	if(strlen(buf) > 16) {
X	    register int i,i0,i1;
X		i0 = i1 = 0;
X		for(i = 0; i <= 16; i++)
X			if(buf[i] == ' ') i0 = i, i1 = i+1;
X		if(!i0) i0 = i1 = 16;
X		buf[i1 + 16] = 0;
X		center(10, buf+i1);
X		buf[i0] = 0;
X	}
X	center(9, buf);
X	(void) sprintf(buf, "%4d", getyear());
X	center(11, buf);
X	for(y=8; *dp; y++,dp++){
X		x = 0;
X		dpx = *dp;
X		while(dpx[x]) {
X			while(dpx[x] == ' ') x++;
X			curs(x,y);
X			while(dpx[x] && dpx[x] != ' '){
X				extern int done_stopprint;
X				if(done_stopprint)
X					return;
X				curx++;
X				(void) putchar(dpx[x++]);
X			}
X		}
X	}
X	getret();
X}
X
Xcenter(line, text) int line; char *text; {
Xregister char *ip,*op;
X	ip = text;
X	op = &rip[line][28 - ((strlen(text)+1)/2)];
X	while(*ip) *op++ = *ip++;
X}
END_OF_rip.c
if test 2242 -ne `wc -c <rip.c`; then
    echo shar: \"rip.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f rm.h -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"rm.h\"
else
echo shar: Extracting \"rm.h\" \(4030 characters\)
sed "s/^X//" >rm.h <<'END_OF_rm.h'
X/*	SCCS Id: @(#)rm.h	2.3	88/03/29
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X
X/*
X * The dungeon presentation graphics code and data structures were rewritten
X * and generalized for NetHack's release 2 by Eric S. Raymond (eric@snark)
X * building on Don G. Kneller's MS-DOS implementation. See options.c for
X * the code that permits the user to set the contents of the symbol structure.
X */
X
X/* Level location types */
X#define	HWALL 1
X#define	VWALL 2
X#define	SDOOR 3
X#define	SCORR 4
X#define	LDOOR 5
X#define	POOL	6	/* not yet fully implemented */
X			/* this should in fact be a bit like lit */
X#define	DOOR	  7
X#define	CORR	  8
X#define	ROOM	  9
X#define	STAIRS 	 10
X#define FOUNTAIN 11
X#define THRONE	 12
X#define	SINK	 13
X
X/*
X * Avoid using the level types in inequalities:
X *  these types are subject to change.
X * Instead, use one of the macros below.
X */
X#define	IS_WALL(typ)	((typ) <= VWALL)
X#define IS_ROCK(typ)	((typ) < POOL)		/* absolutely nonaccessible */
X#define	ACCESSIBLE(typ)	((typ) >= DOOR)			/* good position */
X#define	IS_ROOM(typ)		((typ) >= ROOM)		/* ROOM or STAIRS */
X#ifdef RPH
X/* zappable positions include 1 in 5 doors. */
X#define ZAP_POS(typ)	((typ) >= POOL || (((typ) == DOOR) && !rn2(5)))
X#define SPACE_POS(typ)	((typ) > DOOR)
X#else
X#define	ZAP_POS(typ)		((typ) > DOOR)
X#endif
X#define IS_POOL(typ)    ((typ) == POOL)
X#define IS_THRONE(typ)    ((typ) == THRONE)
X#define IS_FOUNTAIN(typ)        ((typ) == FOUNTAIN)
X#define IS_SINK(typ)	((typ) == SINK)
X
X/*
X * The level-map symbols may be compiled in or defined at initialization time
X */
X#ifndef GRAPHICS
X
X#define STONE_SYM	' '
X#define VWALL_SYM	'|'
X#define HWALL_SYM	'-'
X#define TLCORN_SYM	'+'
X#define TRCORN_SYM	'+'
X#define BLCORN_SYM	'+'
X#define BRCORN_SYM	'+'
X#define DOOR_SYM	'+'
X#define ROOM_SYM	'.'
X#ifdef QUEST
X# define	CORR_SYM	':'
X#else
X# define	CORR_SYM	'#'
X#endif
X#define UP_SYM		'<'
X#define DN_SYM		'>'
X#define TRAP_SYM	'^'
X#define	POOL_SYM	'}'
X#define FOUNTAIN_SYM    '{'
X#define THRONE_SYM      '\\'
X#define WEB_SYM         '"'
X#define SINK_SYM	'#'
X#else /* GRAPHICS */
X
X/* screen symbols for using character graphics. */
Xstruct symbols {
X    unsigned char stone, vwall, hwall, tlcorn, trcorn, blcorn, brcorn;
X    unsigned char door, room, corr, upstair, dnstair, trap;
X#ifdef FOUNTAINS
X    unsigned char pool, fountain;
X#endif
X#ifdef NEWCLASS
X    unsigned char throne;
X#endif
X#ifdef SPIDERS
X    unsigned char web;
X#endif
X#ifdef SINKS
X    unsigned char sink;
X#endif
X};
Xextern struct symbols showsyms, defsyms;
X
X#define STONE_SYM	showsyms.stone
X#define VWALL_SYM	showsyms.vwall
X#define HWALL_SYM	showsyms.hwall
X#define TLCORN_SYM	showsyms.tlcorn
X#define TRCORN_SYM	showsyms.trcorn
X#define BLCORN_SYM	showsyms.blcorn
X#define BRCORN_SYM	showsyms.brcorn
X#define DOOR_SYM	showsyms.door
X#define ROOM_SYM	showsyms.room
X#define	CORR_SYM	showsyms.corr
X#define UP_SYM		showsyms.upstair
X#define DN_SYM		showsyms.dnstair
X#define TRAP_SYM	showsyms.trap
X#define	POOL_SYM	showsyms.pool
X#define FOUNTAIN_SYM    showsyms.fountain
X#define THRONE_SYM      showsyms.throne
X#define WEB_SYM         showsyms.web
X#define SINK_SYM	showsyms.sink
X#endif
X
X#define	ERRCHAR	']'
X
X#define MAXPCHARS	17	/* maximum number of mapped characters */
X
X#define IS_CORNER(x)	((x) == TLCORN_SYM || (x) == TRCORN_SYM \
X			 || (x) == BLCORN_SYM || (x) == BRCORN_SYM)
X
X/*
X * The structure describing a coordinate position.
X * Before adding fields, remember that this will significantly affect
X * the size of temporary files and save files.
X */
X#ifdef MSDOS
X/* Save disk space by using unsigned char's instead of unsigned ints
X */
Xstruct rm {
X	uchar scrsym;
X	unsigned typ:5;
X	unsigned new:1;
X	unsigned seen:1;
X	unsigned lit:1;
X};
X#else
Xstruct rm {
X	char scrsym;
X	Bitfield(typ,5);
X	Bitfield(new,1);
X	Bitfield(seen,1);
X	Bitfield(lit,1);
X};
X#endif /* MSDOS /**/
Xextern struct rm levl[COLNO][ROWNO];
X
X#ifdef DGK
X#define ACTIVE	1
X#define SWAPPED	2
X
Xstruct finfo {
X	int	where;
X	long	time;
X	long	size;
X};
Xextern struct finfo fileinfo[];
X#define ZFINFO	{ 0, 0L, 0L }
X#endif
END_OF_rm.h
if test 4030 -ne `wc -c <rm.h`; then
    echo shar: \"rm.h\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f rnd.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"rnd.c\"
else
echo shar: Extracting \"rnd.c\" \(897 characters\)
sed "s/^X//" >rnd.c <<'END_OF_rnd.c'
X/*	SCCS Id: @(#)rnd.c	2.3	87/12/12
X */
X#include	"config.h"
X/* rand() is either random() or lrand48() - see config.h. */
X#ifdef UNIX
X#define RND(x)	(rand() % (x))
X#else
X/* Good luck: the bottom order bits are cyclic. */
X#define RND(x)	((rand()>>3) % (x))
X#endif
X
Xrn1(x,y)	/* y <= rn1(x,y) < (y+x) */ 
Xregister x,y;
X{
X	return(RND(x)+y);
X}
X
Xrn2(x)		/* 0 <= rn2(x) < x */
Xregister x;
X{
X	return(RND(x));
X}
X
Xrnd(x)		/* 1 <= rnd(x) <= x */
Xregister x;
X{
X	return(RND(x)+1);
X}
X
Xd(n,x)		/* n <= d(n,x) <= (n*x) */
Xregister n,x;
X{
X	register tmp = n;
X
X	while(n--) tmp += RND(x);
X	return(tmp);
X}
X
Xrne(x)          /* by stewr 870807 */
Xregister x;
X{
X        register tmp = 1;
X	while(!rn2(x)) tmp++;
X	return(tmp);
X}
X
Xrnz(i)
Xint i;
X{
X	register long x = i;
X        register long tmp = 1000;
X	tmp += rn2(1000);
X	tmp *= rne(4);
X	if (rn2(2)) { x *= tmp; x /= 1000; }
X	else { x *= 1000; x /= tmp; }
X	return((int)x);
X}
END_OF_rnd.c
if test 897 -ne `wc -c <rnd.c`; then
    echo shar: \"rnd.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f rumors.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"rumors.c\"
else
echo shar: Extracting \"rumors.c\" \(2892 characters\)
sed "s/^X//" >rumors.c <<'END_OF_rumors.c'
X/*	SCCS Id: @(#)rumors.c	1.4	87/08/08
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* hack.rumors.c - version 1.0.3 */
X
X#include	<stdio.h>
X#include	"hack.h"		/* for RUMORFILE and BSD (index) */
X#ifdef DGK
X/* Rumors has been entirely rewritten to speed up the access.  This is
X * essential when working from floppies.  Using fseek() the way that's done
X * here means rumors following longer rumors are output more often than those
X * following shorter rumors.  Also, you may see the same rumor more than once
X * in a particular game (although the odds are highly against it), but
X * this also happens with real fortune cookies.  Besides, a person can
X * just read the rumor file if they desire.  -dgk
X */
Xlong rumors_size;
Xextern char *index();
Xextern long ftell();
X
Xoutrumor()
X{
X	char	line[COLNO];
X	char	*endp;
X	char	roomer[FILENAME];
X	FILE	*rumors;
X
X	if (rumors_size < 0)	/* We couldn't open RUMORFILE */
X		return;
X	if(rumors = fopen(RUMORFILE, "r")) {
X		if (!rumors_size) {	/* if this is the first outrumor() */
X			fseek(rumors, 0L, 2);
X			rumors_size = ftell(rumors);
X		}
X		fseek(rumors, rand() % rumors_size, 0);
X		fgets(line, COLNO, rumors);
X		if (!fgets(line, COLNO, rumors)) {	/* at EOF ? */
X			fseek(rumors, 0L, 0);		/* seek back to start */
X			fgets(line, COLNO, rumors);
X		}
X		if(endp = index(line, '\n')) *endp = 0;
X		pline("This cookie has a scrap of paper inside! It reads: ");
X		pline(line);
X		fclose(rumors);
X	} else {
X		pline("Can't open rumors file!");
X		rumors_size = -1;	/* don't try to open it again */
X	}
X}
X
X#else
X
X#define	CHARSZ	8			/* number of bits in a char */
Xextern long *alloc();
Xextern char *index();
Xint n_rumors = 0;
Xint n_used_rumors = -1;
Xchar *usedbits;
X
Xinit_rumors(rumf) register FILE *rumf; {
Xregister int i;
X	n_used_rumors = 0;
X	while(skipline(rumf)) n_rumors++;
X	rewind(rumf);
X	i = n_rumors/CHARSZ;
X	usedbits = (char *) alloc((unsigned)(i+1));
X	for( ; i>=0; i--) usedbits[i] = 0;
X}
X
Xskipline(rumf) register FILE *rumf; {
Xchar line[COLNO];
X	while(1) {
X		if(!fgets(line, sizeof(line), rumf)) return(0);
X		if(index(line, '\n')) return(1);
X	}
X}
X
Xoutline(rumf) register FILE *rumf; {
Xchar line[COLNO];
Xregister char *ep;
X	if(!fgets(line, sizeof(line), rumf)) return;
X	if((ep = index(line, '\n')) != 0) *ep = 0;
X	pline("This cookie has a scrap of paper inside! It reads: ");
X	pline(line);
X}
X
Xoutrumor(){
Xregister int rn,i;
Xregister FILE *rumf;
X	if(n_rumors <= n_used_rumors ||
X	  (rumf = fopen(RUMORFILE, "r")) == (FILE *) 0) return;
X	if(n_used_rumors < 0) init_rumors(rumf);
X	if(!n_rumors) goto none;
X	rn = rn2(n_rumors - n_used_rumors);
X	i = 0;
X	while(rn || used(i)) {
X		(void) skipline(rumf);
X		if(!used(i)) rn--;
X		i++;
X	}
X	usedbits[i/CHARSZ] |= (1 << (i % CHARSZ));
X	n_used_rumors++;
X	outline(rumf);
Xnone:
X	(void) fclose(rumf);
X}
X
Xused(i) register int i; {
X	return(usedbits[i/CHARSZ] & (1 << (i % CHARSZ)));
X}
X
X#endif /* DGK /**/
END_OF_rumors.c
if test 2892 -ne `wc -c <rumors.c`; then
    echo shar: \"rumors.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f rumors.mrx -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"rumors.mrx\"
else
echo shar: Extracting \"rumors.mrx\" \(1861 characters\)
sed "s/^X//" >rumors.mrx <<'END_OF_rumors.mrx'
XA Ninja is very stealthy.
XA Ninja knows how to backstab.
XA Ninja knows how to throw things.
XA Ninja knows how to use poison.
XA Priest can get the Gods to listen easily.
XA Priest can go to hell just like the rest of us.
XA Priest and a virgin you might be, but that unicorn won't care.
XA Priestess may be a virgin; then again...
XA Priestess may be a virgin, but who would believe that???
XA Samurai is fast on his feet.
XA Samurai is very good with a katana.
XA Samurai is just a fighter with a bent sword.
XA katana might cut a demon.
XA katana might slice a worm in two.
XDemon-lords are greedy.
XDemon-princes have very bad tempers.
XDemons *HATE* Priests and Priestesses.
XDemons are one thing, Demon-lords, on the other hand...
XGods expect the best from their priesthood.
XGods look down their noses at demi-gods.
XHave you been a demi-god yet?
XHave you ever seen a Demon-prince?
XHELL is a four letter word.
XIf you kill the wizard, you get promoted to demi-god.
XIf you're a Samurai, you must obey the Mikado.
XIf you're a Ninja, don't let the Mikado see you.
XKatanas are very sharp, watch you don't cut yourself.
XMulti-player Hack is a myth.
XNetHack is a fantasy, in fact you're dreaming.
XNetHack is addictive.  Too late, you're already hooked.
XOrcs go around poisoning the spikes in pits!
XSomeone has been spiking the pits.
XThe Gods don't appreciate pesky priesthood.
XThe Gods don't like competition.
XThe wizard gets quite an experience out of death.
XTry calling your katana Moulinette.
XTry calling your katana Snikersnee.
XWatch out for pits with spikes in them!
XWatch out, that piercer might have gotten back up on the ceiling.
XWatch out, the mimic may hide again.
XWatch out, the wizard might come back.
XWhat does a Demon-prince look like, anyway?
XWhat is this demi-god stuff anyway?
XYou might be able to bribe a Demon-lord.
XYou might be able to bribe a Demon-prince.
END_OF_rumors.mrx
if test 1861 -ne `wc -c <rumors.mrx`; then
    echo shar: \"rumors.mrx\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f search.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"search.c\"
else
echo shar: Extracting \"search.c\" \(3589 characters\)
sed "s/^X//" >search.c <<'END_OF_search.c'
X/*	SCCS Id: @(#)search.c	2.1	87/11/10
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X
X#include "hack.h"
Xchar *rndmonnam(), *defmonnam();
X
Xextern struct monst *makemon();
X
Xfindit()	/* returns number of things found */
X{
X	int num;
X	register xchar zx,zy;
X	register struct trap *ttmp;
X	register struct monst *mtmp;
X	xchar lx,hx,ly,hy;
X
X	if(u.uswallow) return(0);
X	for(lx = u.ux; (num = levl[lx-1][u.uy].typ) && num != CORR; lx--) ;
X	for(hx = u.ux; (num = levl[hx+1][u.uy].typ) && num != CORR; hx++) ;
X	for(ly = u.uy; (num = levl[u.ux][ly-1].typ) && num != CORR; ly--) ;
X	for(hy = u.uy; (num = levl[u.ux][hy+1].typ) && num != CORR; hy++) ;
X	num = 0;
X	for(zy = ly; zy <= hy; zy++)
X		for(zx = lx; zx <= hx; zx++) {
X			if(levl[zx][zy].typ == SDOOR) {
X				levl[zx][zy].typ = DOOR;
X				atl(zx, zy, DOOR_SYM);
X				num++;
X			} else if(levl[zx][zy].typ == SCORR) {
X				levl[zx][zy].typ = CORR;
X				atl(zx, zy, CORR_SYM);
X				num++;
X			} else if(ttmp = t_at(zx, zy)) {
X				if(ttmp->ttyp == PIERC){
X					(void) makemon(PM_PIERCER, zx, zy);
X					num++;
X					deltrap(ttmp);
X				} else if(!ttmp->tseen) {
X					ttmp->tseen = 1;
X					if(!vism_at(zx, zy))
X						atl(zx,zy,TRAP_SYM);
X					num++;
X				}
X			} else if(mtmp = m_at(zx,zy)) if(mtmp->mimic){
X				seemimic(mtmp);
X				num++;
X			}
X		}
X	return(num);
X}
X
Xdosearch()
X{
X	register xchar x,y;
X	register struct trap *trap;
X	register struct monst *mtmp;
X#ifdef BVH	/* if weapon is Excalibur give the user the sword's
X		 * magic bonus (+ or -) to search for hidden objects.
X		 */
X	int fund = (uwep && !strcmp(ONAME(uwep),"Excalibur")) ?
X			((uwep->spe > 5) ? 5 : uwep->spe) : 0;
X#endif
X
X	if(u.uswallow)
X		pline("What are you looking for? The exit?");
X	else
X	for(x = u.ux-1; x < u.ux+2; x++)
X	for(y = u.uy-1; y < u.uy+2; y++) if(x != u.ux || y != u.uy) {
X		if(levl[x][y].typ == SDOOR) {
X			if(rn2(7-fund)) continue;
X			levl[x][y].typ = DOOR;
X			levl[x][y].seen = 0;	/* force prl */
X			prl(x,y);
X			nomul(0);
X		} else if(levl[x][y].typ == SCORR) {
X			if(rn2(7-fund)) continue;
X			levl[x][y].typ = CORR;
X			levl[x][y].seen = 0;	/* force prl */
X			prl(x,y);
X			nomul(0);
X		} else {
X		/* Be careful not to find anything in an SCORR or SDOOR */
X			if(mtmp = m_at(x,y)) if(mtmp->mimic){
X				seemimic(mtmp);
X				pline("You find %s.",defmonnam(mtmp));
X				return(1);
X			}
X			for(trap = ftrap; trap; trap = trap->ntrap)
X			if(trap->tx == x && trap->ty == y &&
X			   !trap->tseen && !rn2(8)) {
X				nomul(0);
X				if (trap->ttyp != PIERC)
X				pline("You find a%s.", traps[Hallucination ?
X				rn2(TRAPNUM-2) : trap->ttyp ]);
X
X				if(trap->ttyp == PIERC) {
X				    deltrap(trap);
X				    if((mtmp=makemon(PM_PIERCER,x,y)))
X					pline("You find %s.", defmonnam(mtmp));
X				    return(1);
X				}
X				trap->tseen = 1;
X				if(!vism_at(x,y)) atl(x,y,TRAP_SYM);
X			}
X		}
X	}
X	return(1);
X}
X
Xdoidtrap() {
Xregister struct trap *trap;
Xregister int x,y;
X	if(!getdir(1)) return(0);
X	x = u.ux + u.dx;
X	y = u.uy + u.dy;
X	for(trap = ftrap; trap; trap = trap->ntrap)
X		if(trap->tx == x && trap->ty == y && trap->tseen) {
X		    if(u.dz)
X			if((u.dz < 0) != (!xdnstair && trap->ttyp == TRAPDOOR))
X			    continue;
X			pline("That is a%s.",traps[ Hallucination ? rn2(TRAPNUM-2) :
X			trap->ttyp]);
X		    return(0);
X		}
X	pline("I can't see a trap there.");
X	return(0);
X}
X
Xwakeup(mtmp)
Xregister struct monst *mtmp;
X{
X	mtmp->msleep = 0;
X	setmangry(mtmp);
X	if(mtmp->mimic) seemimic(mtmp);
X}
X
X/* NOTE: we must check if(mtmp->mimic) before calling this routine */
Xseemimic(mtmp)
Xregister struct monst *mtmp;
X{
X		mtmp->mimic = 0;
X		mtmp->mappearance = 0;
X		unpmon(mtmp);
X		pmon(mtmp);
X}
END_OF_search.c
if test 3589 -ne `wc -c <search.c`; then
    echo shar: \"search.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f termcap.cnf -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"termcap.cnf\"
else
echo shar: Extracting \"termcap.cnf\" \(862 characters\)
sed "s/^X//" >termcap.cnf <<'END_OF_termcap.cnf'
X#
X# ibm-pc with color monitor: orange foreground, blue background
X#			     highlight is intense red on blue
X#			     underline is intense red on blue
X#
Xibmpc:\
X	:co#80:\
X	:li#24:\
X	:cl=\E[2J:\
X	:bs:\
X	:ho=\E[H:\
X	:cm=\E[%i%2;%2H:\
X	:up=\E[A:\
X	:xd=\E[B:\
X	:nd=\E[C:\
X	:bc=\E[D:\
X	:ce=\E[K:\
X	:ti=\E[0;33;44m:\
X	:te=\E[0;33;44m:\
X	:so=\E[1;31;44m:\
X	:se=\E[0;33;44m:\
X	:us=\E[1;31;44m:\
X	:ue=\E[0;33;44m:\
X	:al=\E[L:\
X	:dl=\E[M:
X#
X# Monochrome IBMPC.
X#	This is a termcap for the NANSI.SYS device driver.
X#	It is the same as the ANSI termcap, except NANSI supports
X#	line insert (al) and delete (dl) while ANSI does not.
X#
Xibmpc-mono:\
X	:co#80:\
X	:li#24:\
X	:cl=\E[2J:\
X	:bs:\
X	:ho=\E[H:\
X	:cm=\E[%i%2;%2H:\
X	:up=\E[A:\
X	:xd=\E[B:\
X	:nd=\E[C:\
X	:bc=\E[D:\
X	:ce=\E[K:\
X	:ti=\E[m:\
X	:te=\E[m:\
X	:so=\E[1m:\
X	:se=\E[m:\
X	:us=\E[1m:\
X	:ue=\E[m:\
X	:al=\E[L:\
X	:dl=\E[M:
END_OF_termcap.cnf
if test 862 -ne `wc -c <termcap.cnf`; then
    echo shar: \"termcap.cnf\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f timeout.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"timeout.c\"
else
echo shar: Extracting \"timeout.c\" \(2056 characters\)
sed "s/^X//" >timeout.c <<'END_OF_timeout.c'
X/*	SCCS Id: @(#)timeout.c	2.0	87/09/18
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X
X#include	"hack.h"
X
Xtimeout(){
Xregister struct prop *upp;
X#ifdef KAA
Xregister struct monst *mtmp;
X#endif
X	if(Stoned) stoned_dialogue();
X#ifdef KAA
X	if(u.mtimedone) if (!--u.mtimedone) rehumanize();
X# ifdef KOPS
X	if(u.ucreamed > 0) u.ucreamed--;
X# endif
X#endif
X	for(upp = u.uprops; upp < u.uprops+SIZE(u.uprops); upp++)
X	    if((upp->p_flgs & TIMEOUT) && !(--upp->p_flgs & TIMEOUT)) {
X		if(upp->p_tofn) (*upp->p_tofn)();
X		else switch(upp - u.uprops){
X		case STONED:
X			killer = "cockatrice";
X			done("died");
X			break;
X		case SICK:
X			pline("You die because of food poisoning.");
X			killer = u.usick_cause;
X			done("died");
X			break;
X		case FAST:
X			pline("You feel yourself slowing down.");
X			break;
X		case CONFUSION:
X			if (Hallucination) pline("You feel less trippy now.");
X			else
X				pline("You feel less confused now.");
X			break;
X		case BLINDED:
X			if (Hallucination) pline("Oh like wow! What a rush.");
X			else		   pline("You can see again.");
X			setsee();
X			break;
X		case INVIS:
X			on_scr(u.ux,u.uy);
X			if (!See_invisible)
X				pline("You are no longer invisible.");
X			break;
X		case WOUNDED_LEGS:
X			heal_legs();
X			break;
X#ifdef KAA
X		case HALLUCINATION:
X			pline("Everything looks SO boring now.");
X			setsee();
X			for (mtmp=fmon; mtmp; mtmp=mtmp->nmon)
X				if ((Blind && Telepat) || canseemon(mtmp))
X					atl(mtmp->mx, mtmp->my, (!mtmp->mappearance || 
X					Protection_from_shape_changers) 
X					? mtmp->data->mlet : mtmp->mappearance);
X			break;
X#endif
X		}
X	}
X}
X
X/* He is being petrified - dialogue by inmet!tower */
Xchar *stoned_texts[] = {
X	"You are slowing down.",		/* 5 */
X	"Your limbs are stiffening.",		/* 4 */
X	"Your limbs have turned to stone.",	/* 3 */
X	"You have turned to stone.",		/* 2 */
X	"You are a statue."			/* 1 */
X};
X
Xstoned_dialogue()
X{
X	register long i = (Stoned & TIMEOUT);
X
X	if(i > 0 && i <= SIZE(stoned_texts))
X		pline(stoned_texts[SIZE(stoned_texts) - i]);
X	if(i == 5)
X		Fast = 0;
X	if(i == 3)
X		nomul(-3);
X}
END_OF_timeout.c
if test 2056 -ne `wc -c <timeout.c`; then
    echo shar: \"timeout.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f track.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"track.c\"
else
echo shar: Extracting \"track.c\" \(688 characters\)
sed "s/^X//" >track.c <<'END_OF_track.c'
X/*	SCCS Id: @(#)track.c	1.4	87/08/08
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* track.c - version 1.0.2 */
X
X#include "hack.h"
X
X#define	UTSZ	50
X
Xcoord utrack[UTSZ];
Xint utcnt = 0;
Xint utpnt = 0;
X
Xinitrack(){
X	utcnt = utpnt = 0;
X}
X
X/* add to track */
Xsettrack(){
X	if(utcnt < UTSZ) utcnt++;
X	if(utpnt == UTSZ) utpnt = 0;
X	utrack[utpnt].x = u.ux;
X	utrack[utpnt].y = u.uy;
X	utpnt++;
X}
X
Xcoord *
Xgettrack(x,y) register x,y; {
Xregister int i,cnt,dist;
Xcoord tc;
X	cnt = utcnt;
X	for(i = utpnt-1; cnt--; i--){
X		if(i == -1) i = UTSZ-1;
X		tc = utrack[i];
X		dist = (x-tc.x)*(x-tc.x) + (y-tc.y)*(y-tc.y);
X		if(dist < 3)
X			return(dist ? &(utrack[i]) : 0);
X	}
X	return(0);
X}
END_OF_track.c
if test 688 -ne `wc -c <track.c`; then
    echo shar: \"track.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f trap.h -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"trap.h\"
else
echo shar: Extracting \"trap.h\" \(1012 characters\)
sed "s/^X//" >trap.h <<'END_OF_trap.h'
X/*	SCCS Id: @(#)trap.h	1.4	87/08/08
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* trap.h - version 1.0.2 */
X
Xstruct trap {
X	struct trap *ntrap;
X	xchar tx,ty;
X	Bitfield(ttyp,5);
X	Bitfield(tseen,1);
X	Bitfield(once,1);
X};
X
Xextern struct trap *ftrap;
Xstruct trap *t_at();
X#define newtrap()	(struct trap *) alloc(sizeof(struct trap))
X
X/* Standard Hack traps. */
X#define NO_TRAP         0
X#define BEAR_TRAP       1
X#define ARROW_TRAP      2
X#define DART_TRAP       3
X#define TRAPDOOR        4
X#define TELEP_TRAP      5
X#define PIT             6
X#define SLP_GAS_TRAP    7
X#define PIERC           8
X#define MIMIC           9
X
X/* Defines below this line are automatically added by makedefs (-t option) */
X/* if you add any additional code below the next line, it will disappear.  */
X/* DO NOT REMOVE THIS LINE */
X
X#define	MGTRP		10
X#define	SQBRD		11
X#define	WEB		12
X#define	SPIKED_PIT	13
X#define	LEVEL_TELEP	14
X#define	ANTI_MAGIC	15
X#define	RUST_TRAP	16
X#define	POLY_TRAP	17
X
X#define	TRAPNUM	18
END_OF_trap.h
if test 1012 -ne `wc -c <trap.h`; then
    echo shar: \"trap.h\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f version.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"version.c\"
else
echo shar: Extracting \"version.c\" \(1951 characters\)
sed "s/^X//" >version.c <<'END_OF_version.c'
X/*	SCCS Id: @(#)version.c	2.3	88/02/11
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X
X#include	"hack.h"
X#include	"date.h"
X
Xdoversion(){
X
X#ifdef BETA
X	pline("%s Net%s Beta Version %s - last build %s.",
X#else
X	pline("%s Net%s Version %s - last build %s.",
X#endif
X#ifdef UNIX
X		"Unix"
X#endif
X#ifdef MSDOS
X		"PC"
X#endif
X#ifdef QUEST
X		, "Quest"
X#else
X		, "Hack"
X#endif
X		, VERSION, datestring);
X	return(0);
X}
X
X#ifdef DGKMOD
X
X#define pg_line(x)	if(page_line(x)) goto quit;
X
XdoMSCversion()
X{
X	char	buf[BUFSZ];
X
X	set_pager(0);
X	sprintf(buf, "Behold mortal, the origins of %s Net%s...",
X#ifdef UNIX
X		"Unix"
X#endif
X#ifdef MSDOS
X		"PC"
X#endif
X#ifdef QUEST
X		, "Quest");
X#else
X		, "Hack");
X#endif
X	pg_line("");
X	pg_line(buf); pg_line(""); pg_line("");
X
X	pg_line("The original HACK was written by Jay Fenlason with help from");
X	pg_line("Kenny Woodland, Mike Thome and Jon Payne.");
X
X	pg_line("");
X	pg_line("Andries Brouwer did a major re-write and published (at least)");
X	pg_line("two versions (1.0.2 and 1.0.3) to the Usenet.");
X
X	pg_line("");
X	pg_line("PC HACK 3.51K was an MSDOS(tm) version of HACK 1.03.");
X	pg_line("The PC implementation was done in Microsoft(tm) C by Don Kneller");
X	pg_line("and modified by Ken Arromdee.");
X
X	pg_line("");
X	pg_line("PC and UNIX HACK were merged by Mike Stephenson and Ken Arromdee");
X	pg_line("incorporating many modifications and features made by the above,");
X	pg_line("as well as the following honored hackers:");
X
X	pg_line("");
X	pg_line("    Scott R. Turner    Tom Almy           John S. Bien");
X	pg_line("    Gil Neiger         Ralf Brown         Eric S. Raymond");
X	pg_line("    Eric Backus        Roland McGrath     Greg Laskin");
X	pg_line("    Bruce Holloway     Richard P. Hughey  Kevin Sweet");
X	pg_line("    Steve Linhart      Bruce Mewborne     Janet Walz");
X	pg_line("    and...             The Unknown Hacker");
X	set_pager(1);
X	return(0);
Xquit:
X	set_pager(2);
X	return(0);
X}
X
X#endif
END_OF_version.c
if test 1951 -ne `wc -c <version.c`; then
    echo shar: \"version.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f weapon.tbl -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"weapon.tbl\"
else
echo shar: Extracting \"weapon.tbl\" \(1487 characters\)
sed "s/^X//" >weapon.tbl <<'END_OF_weapon.tbl'
X.VL 10
X.LI Key:
XC=Chance, W=Weight, SD=Small damage, LD=Large damage
X*=pole arm, \(dg=NetHack only
X.LI Notes:
XPole arms consist of a 5-9 foot pole capped with the implement described.
X.LE
X.TS H
Xtab (#),center,box;
Xc c c c c c
Xl | n n n n | l.
XName#C#W#SD#LD#Description
X_
X.TH
Xarrow#6#0#6#6
Xsling bullet#6#0#4#6#see sling
Xcrossbow bolt#6#0#4#6
Xdart#6#0#3#2
Xshuriken#3#0#8#6#throwing star
Xrock#4#1#3#3
Xboomerang#1#3#9#9
Xmace#6#3#6#7#
Xaxe#5#3#6#4
Xflail#5#3#6#5#stick w/spiked ball & chain
Xlong sword#5#3#8#12#3-4' sword
Xtwo handed sword#4#4#12#12#5-6' sword (no shield)
Xdagger#4#3#4#3
Xworm tooth#0#4#2#2#see crysknife
Xcrysknife#0#3#10#10#enchanted worm tooth
Xaklys#1#3#6#3#spear-thrower
Xbardiche*#1#3#4#4#5' shaft with wide axe
Xbec de corbin*#1#3#8#6#axe head/spike
Xbill-guisarme*#1#3#4#10#spearhead/hook
Xclub#1#3#6#3
Xfauchard*#1#3#6#8#sickle blade
Xglaive*#1#3#6#10#straight blade
Xguisarme*#1#3#4#8#sharp pruning hook
Xhalberd*#1#3#10#6#spearhead with axe
Xlucern hammer*#1#3#4#6#forward & down-curving spikes
Xjavelin#1#3#6#6
Xkatana#1#3#12#12#japanese sword
Xlance*#1#3#6#8
Xmorning star#1#3#4#6#spiked ball on stick
Xpartisan*#1#3#6#6#spearhead w/double axe
Xranseur*#1#3#4#4#broad spearhead w/hilt
Xscimitar#1#3#8#8#large knife
Xspetum*#1#3#6#6#spearhead w/catching blades
Xbroad sword#1#3#4#6#3-4' chopping sword
Xshort sword#1#3#6#8#2-3' sword
Xtrident#1#3#6#4#three-pronged fork
Xvoulge*#1#3#4#4#single-edge blade
Xspear#4#3#6#8
Xbow#4#3#4#6
Xsling#4#3#6#6#uses bullets or rocks
Xcrossbow#5#3#4#6
X.TE
END_OF_weapon.tbl
if test 1487 -ne `wc -c <weapon.tbl`; then
    echo shar: \"weapon.tbl\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f wield.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"wield.c\"
else
echo shar: Extracting \"wield.c\" \(3472 characters\)
sed "s/^X//" >wield.c <<'END_OF_wield.c'
X/*	SCCS Id: @(#)wield.c	2.1	87/11/09
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X
X#include	"hack.h"
Xextern struct obj zeroobj;
Xextern char *hcolor();
X#ifdef KAA
Xextern boolean unweapon;
X#endif
X
Xsetuwep(obj) register struct obj *obj; {
X	setworn(obj, W_WEP);
X}
X
Xdowield()
X{
X	register struct obj *wep;
X	register int res = 0;
X
X	multi = 0;
X#ifdef KAA
X	if (cantwield(u.usym)) {
X		pline("Don't be ridiculous!");
X		return(0);
X	}
X#endif
X	if(!(wep = getobj("#-)", "wield"))) /* nothing */;
X	else if(wep == &zeroobj) {
X	  if(uwep == 0) {
X	    pline("You are already empty handed.");
X	  } else if (welded(uwep))
X		pline("The %s welded to your hand!",aobjnam(uwep,"are"));
X	  	else  {
X	  	  setuwep((struct obj *) 0);
X	  	  res++;
X	  	  pline("You are empty handed.");
X	  	}
X	} else if(uwep == wep)
X		pline("You are already wielding that!");
X	else if(welded(uwep))
X		pline("The %s welded to your hand!",
X			aobjnam(uwep, "are"));
X	/* Prevent wielding a cockatrice in pack when not wearing gloves KAA*/
X	else if (!uarmg && wep->otyp == DEAD_COCKATRICE) {
X		pline("You wield the dead cockatrice in your bare hands.");
X		pline("You turn to stone ...");
X		killer="dead cockatrice";
X		done("died");
X	} else if(uarms && wep->otyp == TWO_HANDED_SWORD)
X	pline("You cannot wield a two-handed sword and wear a shield.");
X	else if(wep->owornmask & (W_ARMOR | W_RING))
X		pline("You cannot wield that!");
X	else {
X		setuwep(wep);
X		res++;
X		if(welded(uwep))
X		    pline("The %s %s to your hand!",
X			aobjnam(uwep, "weld"),
X			(uwep->quan == 1) ? "itself" : "themselves"); /* a3 */
X		else prinv(uwep);
X	}
X#ifdef KAA
X	if(res && uwep)
X		unweapon = (uwep->otyp >= BOW || uwep->otyp <= BOOMERANG) ? 
X		TRUE : FALSE;
X#endif
X	return(res);
X}
X
Xcorrode_weapon(){
X	if(!uwep || uwep->olet != WEAPON_SYM) return;	/* %% */
X	if(uwep->rustfree)
X		pline("Your %s not affected.", aobjnam(uwep, "are"));
X	else if (uwep->spe > -6) {
X		pline("Your %s!", aobjnam(uwep, "corrode"));
X		uwep->spe--;
X	} else	pline("Your %s quite rusted now.", aobjnam(uwep, "look"));
X}
X
Xchwepon(otmp,amount)
Xregister struct obj *otmp;
Xregister amount;
X{
Xregister char *color = (amount < 0) ? "black" : "green";
Xregister char *time;
X
X	if(Hallucination) color=hcolor();
X	if(!uwep || uwep->olet != WEAPON_SYM) {
X		strange_feeling(otmp,
X			(amount > 0) ? "Your hands twitch."
X				     : "Your hands itch.");
X		return(0);
X	}
X
X	if(uwep->otyp == WORM_TOOTH && amount > 0) {
X		uwep->otyp = CRYSKNIFE;
X		pline("Your weapon seems sharper now.");
X		uwep->cursed = 0;
X		return(1);
X	}
X
X	if(uwep->otyp == CRYSKNIFE && amount < 0) {
X		uwep->otyp = WORM_TOOTH;
X		pline("Your weapon looks duller now.");
X		return(1);
X	}
X
X	/* there is a (soft) upper limit to uwep->spe */
X	if(amount > 0 && uwep->spe > 5 && rn2(3)) {
X	    pline("Your %s violently %s for a while and then evaporate%s.",
X		aobjnam(uwep,"glow"),Hallucination ? hcolor() : "green",
X		plur(uwep->quan));
X
X	    while(uwep)		/* let all of them disappear */
X				/* note: uwep->quan = 1 is nogood if unpaid */
X		useup(uwep);
X	    return(1);
X	}
X	if(!rn2(6)) amount *= 2;
X	time = (amount*amount == 1) ? "moment" : "while";
X	pline("Your %s %s for a %s.",
X		aobjnam(uwep, "glow"), color, time);
X	uwep->spe += amount;
X	if(amount > 0) uwep->cursed = 0;
X	return(1);
X}
X
Xint
Xwelded(obj) register struct obj *obj;  {
X	return(obj && obj == uwep && obj->cursed &&
X	       (obj->olet == WEAPON_SYM || obj->otyp == HEAVY_IRON_BALL ||
X		obj->otyp == CAN_OPENER || obj->otyp == PICK_AXE));
X}
END_OF_wield.c
if test 3472 -ne `wc -c <wield.c`; then
    echo shar: \"wield.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f worn.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"worn.c\"
else
echo shar: Extracting \"worn.c\" \(1394 characters\)
sed "s/^X//" >worn.c <<'END_OF_worn.c'
X/*	SCCS Id: @(#)worn.c	2.3	88/01/21
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X
X#include "hack.h"
X
Xstruct worn {
X	long w_mask;
X	struct obj **w_obj;
X} worn[] = {
X	{ W_ARM, &uarm },
X	{ W_ARM2, &uarm2 },
X	{ W_ARMH, &uarmh },
X	{ W_ARMS, &uarms },
X	{ W_ARMG, &uarmg },
X	{ W_ARMU, &uarmu },
X	{ W_RINGL, &uleft },
X	{ W_RINGR, &uright },
X	{ W_WEP, &uwep },
X	{ W_BALL, &uball },
X	{ W_CHAIN, &uchain },
X	{ 0, 0 }
X};
X
Xsetworn(obj, mask)
Xregister struct obj *obj;
Xlong mask;
X{
X	register struct worn *wp;
X	register struct obj *oobj;
X
X	for(wp = worn; wp->w_mask; wp++) if(wp->w_mask & mask) {
X		oobj = *(wp->w_obj);
X		if(oobj && !(oobj->owornmask & wp->w_mask))
X			impossible("Setworn: mask = %ld.", wp->w_mask);
X		if(oobj) oobj->owornmask &= ~wp->w_mask;
X		if(obj && oobj && wp->w_mask == W_ARM){
X			if(uarm2) {
X				impossible("Setworn: uarm2 set?");
X			} else
X				setworn(uarm, W_ARM2);
X		}
X		*(wp->w_obj) = obj;
X		if(obj) obj->owornmask |= wp->w_mask;
X	}
X	if(uarm2 && !uarm) {
X		uarm = uarm2;
X		uarm2 = 0;
X		uarm->owornmask ^= (W_ARM | W_ARM2);
X	}
X}
X
X/* called e.g. when obj is destroyed */
Xsetnotworn(obj) register struct obj *obj; {
X	register struct worn *wp;
X
X	for(wp = worn; wp->w_mask; wp++)
X		if(obj == *(wp->w_obj)) {
X			*(wp->w_obj) = 0;
X			obj->owornmask &= ~wp->w_mask;
X		}
X	if(uarm2 && !uarm) {
X		uarm = uarm2;
X		uarm2 = 0;
X		uarm->owornmask ^= (W_ARM | W_ARM2);
X	}
X}
END_OF_worn.c
if test 1394 -ne `wc -c <worn.c`; then
    echo shar: \"worn.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f write.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"write.c\"
else
echo shar: Extracting \"write.c\" \(3837 characters\)
sed "s/^X//" >write.c <<'END_OF_write.c'
X/*	SCCS Id: @(#)write.c	2.0	87/09/16
X */
X
X#include "hack.h"
X
Xextern char pl_character[];
X
X#ifdef MARKER
X
X/*
X * returns basecost of a scroll
X */
Xint
Xcost(scroll)
Xregister struct obj *scroll;
X{
X	switch(scroll->otyp)  {
X# ifdef MAIL
X	case SCR_MAIL:
X		return(0);
X		break;
X# endif
X	case SCR_LIGHT:
X	case SCR_GOLD_DETECTION:
X	case SCR_FOOD_DETECTION:
X	case SCR_MAGIC_MAPPING:
X	case SCR_AMNESIA:
X	case SCR_FIRE:
X		return(8);
X		break;
X	case SCR_DESTROY_ARMOR:
X	case SCR_DAMAGE_WEAPON:
X	case SCR_CREATE_MONSTER:
X	case SCR_PUNISHMENT:
X		return(10);
X		break;
X	case SCR_CONFUSE_MONSTER:
X		return(12);
X		break;
X	case SCR_IDENTIFY:
X		return(14);
X		break;
X	case SCR_ENCHANT_ARMOR:
X	case SCR_REMOVE_CURSE:
X	case SCR_ENCHANT_WEAPON:
X		return(16);
X		break;
X	case SCR_SCARE_MONSTER:
X	case SCR_TAMING:
X	case SCR_TELEPORTATION:
X		return(20);
X		break;
X	case SCR_GENOCIDE:
X		return(30);
X		break;
X	case SCR_BLANK_PAPER:
X	default:
X		impossible("You can't write such a weird scroll!");
X	}
X	return(1000);
X}
X
X
Xdowrite(pen)
X	register struct obj *pen;
X{
X	register struct obj *paper;
X	char namebuf[BUFSZ], scrbuf[BUFSZ];
X	register struct obj *newscroll;
X	extern struct obj *readobjnam(), *addinv();
X	int basecost, actualcost;
X	int newquan;
X	
X	if(!pen)
X		return(0);
X	if(pen->otyp != MAGIC_MARKER)  {
X		pline("You can't write with that!");
X		return(0);
X	}
X	
X	/* get paper to write on */
X	paper = getobj("?","write on");
X	if(!paper)
X		return(0);
X	if(!(objects[paper->otyp].oc_name_known))  {
X		pline("In your haste, you rip the scroll to pieces.");
X		useup(paper);
X		return(1);
X	}
X# ifndef KAA
X/* If this is included, the strategy would be to name all scrolls so that
X * you can test them for blankness with a magic marker.  This is tedious,
X * thus, let's make it easier. */
X	if(!(objects[paper->otyp].oc_name_known))  {
X		pline("In your haste, you rip the scroll to pieces.");
X		useup(paper);
X		return(0);
X	}
X# endif
X	if(paper->otyp != SCR_BLANK_PAPER)  {
X		pline("You fool, that scroll's not blank!");
X		return(0);
X	}
X	
X	/* what to write */
X	pline("What do you want to write? ");
X	getlin(namebuf);
X	if(namebuf[0] == '\033' || !namebuf[0])
X		return(0);
X	strcpy(scrbuf,"scroll of ");
X	strcat(scrbuf,namebuf);
X	newscroll = readobjnam(scrbuf);
X	if(newscroll->olet != SCROLL_SYM ||
X	   newscroll->otyp == SCR_BLANK_PAPER)  {
X		pline("You can't write that!");
X		pline("It's obscene!");
X		return(0);
X	}
X	
X	/* see if there's enough ink */
X	basecost = cost(newscroll);
X	if(pen->spe < basecost/2)  {
X		pline("You marker is too dried out to write that!");
X		obfree(newscroll, (struct obj *) 0);
X		return(0);
X	}
X	
X	/* we're really going to write now, so calculate
X	 * cost and useup old scroll
X	 */
X	actualcost = rn1(basecost/2,basecost/2);
X	useup(paper);
X	
X	/* dry out marker */
X	if(pen->spe < actualcost)  {
X		pline("Your marker dries out!");
X		pline("The scroll is now useless and disappears!");
X		pen->spe = 0;
X		obfree(newscroll, (struct obj *) 0);
X		return(1);
X	}
X	pen->spe -= actualcost;
X# ifdef KAA /* Since the KAA modification allows writing on unknown blank
X		paper, identify blank paper. */
X	objects[SCR_BLANK_PAPER].oc_name_known=1;
X# endif
X	
X	/* can't write if we don't know it - unless we're lucky */
X	if(!(objects[newscroll->otyp].oc_name_known) && 
X# ifdef KAA
X	   !(objects[newscroll->otyp].oc_uname) && 
X# endif
X	   ((pl_character[0] == 'W' && rn2(3)) ||
X	    (pl_character[0] != 'W' && rn2(10))))  {
X		pline("You don't know how to write that!");
X		pline("You write \"Shah was here!\" and the scroll disappears.");
X		obfree(newscroll, (struct obj *) 0);
X		return(1);
X	}
X	
X	/* and now you know it! */
X	objects[newscroll->otyp].oc_name_known = 1;
X	
X	/* success - don't forget to fool prinv() */
X	newscroll = addinv(newscroll);
X	newquan = newscroll->quan;
X	newscroll->quan = 1;
X	prinv(newscroll);
X	newscroll->quan = newquan;
X	
X	return(1);
X}
X# endif /* MARKER /**/
END_OF_write.c
if test 3837 -ne `wc -c <write.c`; then
    echo shar: \"write.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f wseg.h -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"wseg.h\"
else
echo shar: Extracting \"wseg.h\" \(311 characters\)
sed "s/^X//" >wseg.h <<'END_OF_wseg.h'
X/*	SCCS Id: @(#)wseg.h	1.4	87/08/08
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* wseg.h - version 1.0.2 */
X
X#ifndef NOWORM
X/* worm structure */
Xstruct wseg {
X	struct wseg *nseg;
X	xchar wx,wy;
X	Bitfield(wdispl,1);
X};
X
X#define newseg()	(struct wseg *) alloc(sizeof(struct wseg))
X#endif
END_OF_wseg.h
if test 311 -ne `wc -c <wseg.h`; then
    echo shar: \"wseg.h\" unpacked with wrong size!
fi
# end of overwriting check
fi
echo shar: End of archive 13 \(of 13\).
cp /dev/null ark13isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 13 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
