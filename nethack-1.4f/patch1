Relay-Version: version B 2.10 5/3/83; site utzoo.UUCP
Path: utzoo!mnetor!uunet!husc6!mit-eddie!uw-beaver!tektronix!tekgen!tekred!games-request
From: games-request@tekred.TEK.COM
Newsgroups: comp.sources.games
Subject: v02i032:  nethack - display oriented dungeons & dragons, Patch1
Message-ID: <1511@tekred.TEK.COM>
Date: Fri, 14-Aug-87 18:15:24 EDT
Article-I.D.: tekred.1511
Posted: Fri Aug 14 18:15:24 1987
Date-Received: Sun, 16-Aug-87 22:18:08 EDT
Sender: billr@tekred.TEK.COM
Lines: 3268
Approved: billr@tekred.TEK.COM
Summary: nethack official patch

Submitted by: mike@genat.UUCP (Mike Stephenson)
Comp.sources.games: Volume 2, Issue 32
Archive-name: nethack/Patch1

	[This is the first official patch for the previously posted
	 nethack game.  Send additional bugs/fixes to Mike.   -br]

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of shell archive."
# Contents:  README.NEW Fixes.1.4 Manifest.upd Makefile.tcc Maketcc.ini
#   update.patches
# Wrapped by billr@tekred on Fri Aug 14 15:09:29 1987
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f README.NEW -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"README.NEW\"
else
echo shar: Extracting \"README.NEW\" \(2441 characters\)
sed "s/^X//" >README.NEW <<'END_OF_README.NEW'
X			NetHack Release 1.4 README
X
X	Hi there folks.  Here is the new release of NetHack.  What I have
Xdone over the past few weeks is to collect and implement all of the bug fixes
Xand modifications (there were even a few additions!) to the code.
X
X	To implement this update, unpack the files in the same directory as
Xyour original ***UNADULTERATED*** 1.3d sources.  It is imperitive that you
Xhaven't patched any of the source since the update is done in a very simple
Xway by ed (approximately 150Kb size is saved doing it this way).  Since ed is
Xbeing used to apply the patches, they will be applied by absolute line number,
Xnot by context.  As a result, any additional or missing lines in your code
Xcould (almost certainly will) cause the patches to be applied in the wrong
Xplaces.
X
X	You can (with some difficulty) apply the patches by hand.  It is
Xeasier to do this with a multi-window editor like Emacs.
X
X	There are a couple of additional "Make" files included to extend
Xthe portability to include the Turbo "C" compiler.  These files have "tcc"
Xin the name.
X
X	The file Manifest gives a list of the files which will be modified
Xduring the update process.
X
X	The Fixes.1.4 file gives a more or less complete list of bug fixes.
X
X	The update is provided in a form which can be run as a shell script.
XEither "sh" or "csh" can be used.  Simply type "[c]sh update.patches".  You
Xwill require "cp" and "ed".  Each of the (68) files it modifies will be
Xprocessed as follows:
X
X	cp $file $file.orig
X	ed $file
X
X	... modifications made ...
X
X	w
X	q
X
X	There *are* a few bugs still in the code.  Here's a list of the ones
XI know about:
X
X	1)	There is still something wrong with mkmon().  It won't make
X		"B"'s and it seems to be responsible for some of those deep
X	in the dungeon crashes.
X
X	2)	The leash code (as I explained in the README for the initial
X		release) is very crude.  It won't handle the case of you
X	dropping the leash while it is still attached to the dog.  If you do,
X	the game still considers you and the dog to be "attached".
X
X	3)	I have modified the files to build on Xenix and Dos, but have
X		not tested them.  There may be a few minor glitches left.
X
X	I will be going to England for three weeks starting on the 19th of
XAugust.  As a result, the mail is going to stack up here.  I will take all
Xof the patches and fixes when I get back and put together an update for a
X1.5 (or maybe 2.0) release.
X
X			Happy Hacking!!!
X						Mike Stephenson
END_OF_README.NEW
if test 2441 -ne `wc -c <README.NEW`; then
    echo shar: \"README.NEW\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f Fixes.1.4 -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"Fixes.1.4\"
else
echo shar: Extracting \"Fixes.1.4\" \(2796 characters\)
sed "s/^X//" >Fixes.1.4 <<'END_OF_Fixes.1.4'
X		NetHack Fixes List	Revision 1.4
X
Xdogmove.c:	Death code fixed so dog with <1 hp doesn't "die of hunger".
X		Slack leash message not invoked unless leash attached.
X		Added "DOGNAME" option (thanks to Roland McGrath).
X
Xu_init.c:	Priest(esse)s start off with their weapon blessed.
X
Xspell.c:	Allows high level characters to cast spells upon themselves
Xzap.c:		(such as polymorph).
X
Xpray.c:		allows for de-cursing worn rings as well as weapons.
X		Knights, Priests and Priestesses can now "#turn" undead
X		(UNDEAD = "VWZ &").
X		fixed bugs in blessings bestowed by gods.
X
Xread.c:		SPE_CAUSE_FEAR does not give a "You hear..." message unless no
X		monsters are nearby.
X		fix to bug in "do_genocide" which allowed player to wipe out
X		all '@'s and survive.
X
Xpolyself.c:	fix to rehumanize to catch players who wipe out '@'s while
X		in polymorphed form as they de-polymorph.
X
Xwield.c:	bug causing segmentation fault on "w-" followed by "w[weapon]"
X		fixed by chuq@sun
X
Xtrap.c:		similar null pointer problem corrected.
X
Xmake.exe.uu:	correction of names at top of uuencoded files which caused the
Xnansi.sys.uu:	original files to be overwritten by the decoded files when
X		uudecode was invoked. (found by len@elxsi).
X
Xnethack.6:	general beautification and appropriate acknowledgement of
X		trademarks to avoid getting sued. :-) (thanks chuq)
X
Xhelp:		addition of "V" and "#" commands to help text.
X
Xinvent.c:	fix to REDO bug inhibiting the appearance of the item usage
X		prompt.
X
Xmakedefs.c:	added "{", "\" and corrected Rockmole definition in "data".
X		fixed things for Dos users (file open modes, etc.)
X
Xcmd.c:		added #[command] auto-substitution.
X
Xtermcap.c:	fixed termlib / curses dependencies.
X		fixed null padding bug on output of SO/SE/HI/HE.
X
Xpcmain.c:	many fixes by Ralf Brown (ralf@b.gp.cs.cmu.edu) to allow the
Xpcunix.c:	program to be compiled using the Turbo C compiler in a Dos
XMakefile.tcc:	enviornment.
X
Xengrave.c:	engravings burned or engraved into the floor (as opposed to
X		those made with finger or marker) can be felt out when blind.
X		(inspired by Stefan Wrammerfors).
X
Xmon.c:		fixed "monster looked at a strange trap" bug for 16 bit
X		machines (long vs. int problem reported by mike@cimcor). 
X
Xfight.c:	hitmm() fixed to return 0 (no hit) if either monster passed
X		in is non-existant.  This fixes a number of null reference
X		problems (ex. monmove.c[~360]).
X		Misc zero reference errors fixed by Paul Eggert. eggert@grand
X
XMakefile.xenix:	New version (that works) supplied by Greg Laskin greg@smash
X
Xfountain.c:	Misc zero reference errors fixed by Paul Eggert. eggert@grand
Xsearch.c:
X
Xoptions.c:	New options added for GRAPHICS, DOGNAME, and new routine
X		added to allow easier sorting of string parameters (":,"
X		are considered to be string terminators for copying in
X		name, and dogname).
END_OF_Fixes.1.4
if test 2796 -ne `wc -c <Fixes.1.4`; then
    echo shar: \"Fixes.1.4\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f Manifest.upd -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"Manifest.upd\"
else
echo shar: Extracting \"Manifest.upd\" \(562 characters\)
sed "s/^X//" >Manifest.upd <<'END_OF_Manifest.upd'
XMakefile.pc
XMakefile.unix
XMakefile.xenix
Xapply.c
Xcmd.c
Xconfig.h
Xdata.base
Xdecl.c
Xdo.c
Xdo_name.c
Xdog.c
Xdogmove.c
Xeat.c
Xend.c
Xengrave.c
Xfight.c
Xfountain.c
Xhack.c
Xhack.h
Xhelp
Xhh
Xinvent.c
Xlev.c
Xmakedefs.c
Xmakemon.c
Xmklev.c
Xmkmaze.c
Xmkobj.c
Xmon.c
Xmsdos.c
Xmsdos.h
Xnethack.6
Xo_init.c
Xobjclass.h
Xobjects.h
Xoptions.c
Xpager.c
Xpcmain.c
Xpctty.c
Xpcunix.c
Xpolyself.c
Xpotion.c
Xpray.c
Xpri.c
Xprisym.c
Xread.c
Xrip.c
Xrm.h
Xrnd.c
Xsave.c
Xsearch.c
Xshk.c
Xsit.c
Xspell.c
Xsteal.c
Xtermcap.c
Xtopl.c
Xtopten.c
Xtrap.c
Xu_init.c
Xunixmain.c
Xunixtty.c
Xversion.c
Xwield.c
Xwizard.c
Xwrite.c
Xyou.h
Xzap.c
END_OF_Manifest.upd
if test 562 -ne `wc -c <Manifest.upd`; then
    echo shar: \"Manifest.upd\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f Makefile.tcc -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"Makefile.tcc\"
else
echo shar: Extracting \"Makefile.tcc\" \(4358 characters\)
sed "s/^X//" >Makefile.tcc <<'END_OF_Makefile.tcc'
X#
X#	SCCS Id: @(#)Makefile.tcc	1.4	87/08/08
X# 	Makefile for NetHack (PC) version 1.0 written using
X#	Turbo C v1.0
X# 
X# Unfortunately, large model is limited to a total of 64K global data
X# Huge memory model, remove stack probes, optimize for space:
XWIZARD=
XV = 14
XCFLAGS = -m$(MODEL) -DLINT_ARGS -DVER=$(V) $(WIZARD) -N- -Z -K- -O -w-pro -w-nod
X
X# The game name
XGAME = hack.exe
X
X# The game directory
XGAMEDIR = .
X
X# The directory containing the libraries
XLIBDIR = c:\c\lib
X
X# All object modules
XOBJS = decl.obj apply.obj bones.obj cmd.obj do.obj dothrow.obj\
X	do_name.obj do_wear.obj dog.obj dogmove.obj eat.obj end.obj \
X	engrave.obj fight.obj fountain.obj hack.obj invent.obj \
X	lev.obj main.obj makemon.obj mhitu.obj mklev.obj \
X	mkmaze.obj mkobj.obj mkshop.obj mon.obj monmove.obj\
X	monst.obj o_init.obj objnam.obj options.obj \
X	pager.obj polyself.obj potion.obj pray.obj pri.obj prisym.obj\
X	read.obj rip.obj rumors.obj save.obj \
X	search.obj shk.obj shknam.obj sit.obj spell.obj steal.obj \
X	termcap.obj timeout.obj topl.obj topten.obj track.obj trap.obj \
X	tty.obj unix.obj u_init.obj vault.obj wield.obj \
X	wizard.obj worm.obj worn.obj write.obj zap.obj \
X	version.obj rnd.obj alloc.obj msdos.obj
X
X# The main target
X#
X$(GAME) : $(OBJS)
X	link /x:400 $(LIBDIR)\c0$(MODEL).obj @objs.lnk,$(GAME),,$(LIBDIR)\c$(MODEL).lib
X
X#	variable auxilary files.
X#
XVARAUX = data rumors
X
Xinstall : $(GAME) $(VARAUX)
X	- exepack $(GAME) $(GAMEDIR)\$(GAME)
X	- exemod $(GAMEDIR)\$(GAME) /max 1
X
Xclean :
X	erase $(GAME)
X
Xspotless: clean
X	erase *.obj
X	erase main.c
X	erase tty.c
X	erase unix.c
X
Xsrcs :
X	copy makefile \tmp
X	copy *.c \tmp
X	copy *.h \tmp
X	copy \local\make\make.doc \tmp
X	copy \local\make\make.ini \tmp
X	copy \bin\make.exe \tmp
X	cd \tmp
X	time
X	touch *.*
X	arc m hack$Vs * *.*
X	cd $(CWD)
X
X
X#	Other dependencies
X#
XRUMORFILES= rumors.bas rumors.kaa rumors.mrx
X
Xmakedefs.exe:	makedefs.c alloc.obj config.h
X	cl -AL makedefs.c alloc.obj
X
X
Xrumors :  config.h $(RUMORFILES) makedefs.exe
X	makedefs.exe -r
X
Xdata :  config.h data.bas makedefs.exe
X	makedefs.exe -d
X
Xonames.h :  config.h objects.h makedefs.exe
X	makedefs.exe -o
X
X#	Below is a kluge.  date.h should actually depend on any source
X#	module being changed. (but hack.h is close enough for most).
X#
Xdate.h :  hack.h makedefs.exe
X	makedefs.exe -D
X
Xtrap.h :  config.h makedefs.exe
X	makedefs.exe -t
X
Xmain.obj : main.c
X
Xmain.c :  pcmain.c hack.h
X	copy pcmain.c main.c
X	touch main.c
X
Xtty.obj : tty.c
X
Xtty.c :  pctty.c hack.h msdos.h
X	copy pctty.c tty.c
X	touch tty.c
X
Xunix.obj : unix.c
X
Xunix.c :  pcunix.c hack.h mkroom.h
X	copy pcunix.c unix.c
X	touch unix.c
X
Xdecl.obj :  hack.h mkroom.h
Xapply.obj :  hack.h edog.h mkroom.h
Xbones.obj :  hack.h
Xhack.obj :  hack.h
Xcmd.obj :  hack.h func_tab.h msdos.h
Xdo.obj :  hack.h
Xdo_name.obj :  hack.h
Xdo_wear.obj :  hack.h
Xdog.obj :  hack.h edog.h mkroom.h
Xdogmove.obj :  hack.h mfndpos.h
Xdothrow.obj :  hack.h
Xeat.obj :  hack.h
Xend.obj :  hack.h
Xengrave.obj :  hack.h
Xfight.obj :  hack.h
Xfountain.obj :  hack.h
Xinvent.obj :  hack.h wseg.h
Xioctl.obj :  config.h
Xlev.obj :  hack.h mkroom.h wseg.h
Xmakemon.obj :  hack.h
Xmhitu.obj :  hack.h
Xmklev.obj :  hack.h mkroom.h
Xmkmaze.obj :  hack.h mkroom.h
Xmkobj.obj :  hack.h
Xmkshop.obj :  hack.h mkroom.h eshk.h
Xmon.obj :  hack.h mfndpos.h
Xmonmove.obj :  hack.h mfndpos.h
Xmonst.obj :  hack.h eshk.h
Xo_init.obj :  config.h objects.h onames.h
Xobjnam.obj :  hack.h
Xoptions.obj :  config.h hack.h
Xpager.obj :  hack.h
Xpolyself.obj :  hack.h
Xpotion.obj :  hack.h
Xpray.obj :  hack.h
Xpri.obj :  hack.h
Xprisym.obj :  hack.h wseg.h
Xread.obj :  hack.h
Xrip.obj :  hack.h
X	tcc -c $(CFLAGS) -d- rip.c
Xrumors.obj :  config.h
Xsave.obj :  hack.h
Xsearch.obj :  hack.h
Xshk.obj :  hack.h mfndpos.h mkroom.h eshk.h
Xshknam.obj :  hack.h
Xsit.obj :  hack.h
Xspell.obj:  hack.h
Xsteal.obj :  hack.h
Xtermcap.obj :  config.h flag.h
Xtimeout.obj :  hack.h
Xtopl.obj :  hack.h
Xtopten.obj :  hack.h
Xtrack.obj :  hack.h
Xtrap.obj :  hack.h mkroom.h
Xu_init.obj :  hack.h
Xvault.obj :  hack.h mkroom.h
Xversion.obj : hack.h date.h
Xwield.obj :  hack.h
Xwizard.obj :  hack.h
Xworm.obj :  hack.h wseg.h
Xworn.obj :  hack.h
Xwrite.obj :  hack.h
Xzap.obj :  hack.h
Xmsdos.obj : msdos.h
Xextern.h: config.h
X	touch extern.h
Xhack.h :  config.h objclass.h monst.h gold.h trap.h obj.h flag.h rm.h permonst.h onames.h spell.h extern.h you.h
X	touch hack.h
Xobjects.h :  config.h objclass.h
X	touch objects.h
END_OF_Makefile.tcc
if test 4358 -ne `wc -c <Makefile.tcc`; then
    echo shar: \"Makefile.tcc\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f Maketcc.ini -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"Maketcc.ini\"
else
echo shar: Extracting \"Maketcc.ini\" \(1759 characters\)
sed "s/^X//" >Maketcc.ini <<'END_OF_Maketcc.ini'
X#	SCCS Id: @(#)Maketcc.ini	1.4	87/08/08
X# This is a sample `make.ini' file for NDMAKE v3.7.  You will probably want
X# to customize it for your system.
X
X
X
X# The order to search for rules and files is specified by .SUFFIXES
X#.SUFFIXES : .exe .obj .c .for .asm
X
X# A few macros.
XCFLAGS = -m$(MODEL)
XMODEL = h
XLIBS = c:\c\lib\emu.lib c:\c\lib\math$(MODEL).lib c:\c\lib\c$(MODEL).lib
XBIN =
XLFLAGS =
X
X# A universally useful target.
X#clean:
X#	+-erase *.bak
X#	+-erase *.map
X
X# .BEFORE and .AFTER can be used to turn DPATH off and on.
X#.BEFORE:; @+echo For help with ndmake, use the command `make -h'
X#.AFTER:; @+echo All done.
X
X
X# DEFAULT RULES
X# To produce a `.obj' file from a `.asm' file using MASM.
X.asm.obj:
X	masm $*.asm;
X
X# To produce a `.obj' file from a `.c' file using Microsoft C. 
X.c.obj:
X	tcc -c $(CFLAGS) $*.c
X
X# To produce a `.obj' file from a `.for' file using Microsoft Fortran.
X.for.obj:
X	for1 $*.for;
X	pas2
X
X# To produce a `.exe' file from an `.obj' file.  Note that there is a
X# problem because LIBS may be different for linking `.obj' files
X# produced by different compilers (C, FORTRAN, PASCAL, etc).  To avoid
X# this problem you may want to have the C compiler produce `.cbj' files,
X# the FORTRAN compiler produce `.fbj' files, etc.  Then you could write
X# specific rules for `.cbj.exe' and `.fbj.exe' which would use the correct
X# libraries.
X.obj.exe:
X	tlink c:\c\lib\c0$(MODEL).obj $*.obj,$@,,$(LIBS) $(LFLAGS);
X
X# To produce a `.exe' file from a `.asm' file.
X.asm.exe:
X	masm $*.asm;
X	tlink $*.obj, $@,, $(LIBS)
X	erase $*.obj
X
X# To produce a `.exe' file from a `.c' file.
X.c.exe:
X	tcc $(CFLAGS) $*.c
X	erase $*.obj
X
X# To produce a `.exe' file from a `.for' file.
X.for.exe:
X	for1 $*.for;
X	pas2
X	link $*.obj, $@,, $(LIB)\FORTRAN.LIB
X	erase $*.obj
END_OF_Maketcc.ini
if test 1759 -ne `wc -c <Maketcc.ini`; then
    echo shar: \"Maketcc.ini\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f update.patches -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"update.patches\"
else
echo shar: Extracting \"update.patches\" \(43078 characters\)
sed "s/^X//" >update.patches <<'END_OF_update.patches'
Xcp Makefile.pc Makefile.pc.orig
Xed Makefile.pc <<ED_EOF
X114a
Xdothrow.obj :  hack.h
X.
X103a
X	touch unix.c
X.
X100c
Xunix.obj : unix.c
X.
X98a
X	touch tty.c
X.
X95c
Xtty.obj : tty.c
X.
X93a
X	touch main.c
X.
X90c
Xmain.obj : main.c
X.
X87,88c
Xtrap.h :  config.h makedefs.exe
X	makedefs.exe -t
X.
X84,85c
Xdate.h :  hack.h makedefs.exe
X	makedefs.exe -D
X.
X80a
Xdata :  config.h data.bas makedefs.exe
X	makedefs.exe -d
X
Xonames.h :  config.h objects.h makedefs.exe
X	makedefs.exe -o
X
X.
X78,79c
Xrumors :  config.h $(RUMORFILES) makedefs.exe
X	makedefs.exe -r
X.
X75,76d
X72,73c
Xmakedefs.exe:	makedefs.c alloc.obj config.h
X	cl -AL makedefs.c alloc.obj
X.
X70c
XRUMORFILES= rumors.bas rumors.kaa rumors.mrx
X.
X18c
XOBJS = decl.obj apply.obj bones.obj cmd.obj do.obj dothrow.obj\
X.
X10a
XLIBS =
XLFLAGS =
XMODEL = L
XSETARGV = $(LIB)\$(MODEL)SETARGV
X.SUFFIXES: .exe .obj .c
X.c.obj:; cl $(CFLAGS) -c $*.c
X.c.exe:;
X    cl $(CFLAGS) -c $*.c
X    link $*.obj $(SETARGV), $@,, $(LIBS) $(LFLAGS);
X
X.
X9c
XCFLAGS = -A$(MODEL) -DREGBUG -DLINT_ARGS -DVER=$V $(WIZARD) -Ot -Gs -Gt100
X.
X2c
X#	SCCS Id: @(#)Makefile.pc	1.4	87/08/08
X.
Xw
Xq
XED_EOF
X
Xcp Makefile.unix Makefile.unix.orig
Xed Makefile.unix <<ED_EOF
X146a
X
Xtags: $(SOURCES)
X	@echo ctags -tw ...
X	@ctags -tw $(SOURCES)
X  
X.
X137a
X	touch $(GAMEDIR)/perm $(GAMEDIR)/record
X.
X134c
Xinstall: $(VARAUX) $(GAME)
X	-mkdir $(GAMEDIR)
X	-mkdir $(GAMEDIR)/save
X.
X83c
X	./makedefs -o
X.
X80c
X	./makedefs -t
X.
X77c
X	./makedefs -D
X.
X74c
X	./makedefs -d
X.
X71c
X	./makedefs -r
X.
X60c
X	@cc $(LFLAGS) -o $(GAME) $(HOBJ) $(TERMLIB)
X.
X22c
XLFLAGS =
X.
X2c
X#	SCCS Id: @(#)Makefile.unix	1.4	87/08/08
X.
Xw
Xq
XED_EOF
X
Xcp Makefile.xenix Makefile.xenix.orig
Xed Makefile.xenix <<ED_EOF
X288d
X286d
X284d
X282d
X280d
X278d
X276d
X274d
X272d
X270d
X268d
X266d
X264d
X262d
X260d
X258d
X256d
X254d
X252d
X250d
X248d
X246d
X244d
X242d
X240d
X238d
X236d
X234d
X232d
X230d
X228d
X226d
X224d
X222d
X220d
X218d
X216d
X214d
X212d
X210d
X208d
X206d
X204d
X202d
X200d
X198d
X196d
X194d
X192d
X190d
X188d
X186d
X184d
X182d
X180d
X176,178d
X174d
X172d
X170d
X168d
X166d
X164d
X161,162d
X103,105d
X98c
X	cc ${CFLAGS} -c tty.c
X.
X92d
X71a
XSalloc.o:	alloc.c
X	cp alloc.c Salloc.c
X	cc -O -c Salloc.c
Xpc: 
X	cd dos; make
X
X.
X69,70c
Xmakedefs:	makedefs.c Salloc.o config.h
X	cc -O -o makedefs Salloc.o makedefs.c
X.
X65a
X	
X.
X63,64c
X	cc $(LFLAGS) -m hack.map -o $(GAME) /lib/Lsignal.o $(CRT0) $(HOBJ) $(LIBS) -SEG#256
X.
X61a
X.c.o:
X	cc -O -c -Gt24 ${CFLAGS} $*.c
X
X.
X24,25c
XMANDIR  = 
XCFLAGS = -LARGE -Ml
X.
X15,16c
XLIBS = ${TERMLIB} 
X.
X12,13d
X2c
X#	SCCS Id: @(#)Makefile.xenix	1.4	87/08/08
X.
Xw
Xq
XED_EOF
X
Xcp apply.c apply.c.orig
Xed apply.c <<ED_EOF
X187d
X183,185d
X1c
X/*	SCCS Id: @(#)apply.c	1.4	87/08/08
X.
Xw
Xq
XED_EOF
X
Xcp cmd.c cmd.c.orig
Xed cmd.c <<ED_EOF
X348a
X#endif
X.
X347a
X#ifdef COM_COMPL
X	get_ext_cmd(buf);
X#else
X.
X249c
X	if(!*cmd || *cmd == (char)0377 || (flags.no_rest_on_space && *cmd == ' ')){
X.
X247c
X	if(!*cmd || *cmd == (char)0377) {
X.
X214a
X	"turn", "turn undead", doturn,
X.
X196c
X	{GOLD_SYM, doprgold},
X.
X123c
X#endif /* REDO */
X.
X84c
Xextern int in_doagain;
X.
X40c
X#ifdef DGKMOD
X.
X16c
Xint dosit(), doturn();
X.
X1c
X/*	SCCS Id: @(#)cmd.c	1.4	87/08/08
X.
Xw
Xq
XED_EOF
X
Xcp config.h config.h.orig
Xed config.h <<ED_EOF
X206a
X#define COM_COMPL	/* Command line completion by John S. Bien */
X#define GRAPHICS	/* Funky screen character support (Eric S. Raymond) */
X#define HACKOPTIONS	/* Support DGK-style HACKOPTIONS processing (ESR) */
X.
X187c
X
X#define	DOGNAME		/* Name of your first dog as an option */ 
X.
X170,177d
X147a
X * otherwise:
X *	#define	Bitfield(x,n)	unsigned x:n
X.
X108a
X#define memcpy(d, s, n)		bcopy(s, d, n)
X#define memcmp(s1, s2, n)	bcmp(s2, s1, n)
X.
X35,37c
X/* #define TERMINFO		/* uses "curses" rather than termcap */
X
X#ifdef __TURBOC__
X#define	alloc	malloc
X#define	signal	ssignal
X.
X29c
X#define VERSION	"1.4f"	/* version number. */
X.
X24a
X/* #define	GENIX		/* Yet Another Unix Clone */
X.
X14d
X1c
X/*	SCCS Id: @(#)config.h	1.4	87/08/08
X.
Xw
Xq
XED_EOF
X
Xcp data.base data.base.orig
Xed data.base <<ED_EOF
X25c
X`	an enormous rock
X.
X1,2c
X	NetHack & Quest data file - version 1.1
X@	human (or you in human guise)
X.
Xw
Xq
XED_EOF
X
Xcp decl.c decl.c.orig
Xed decl.c <<ED_EOF
X14d
X7a
X
X#ifdef GRAPHICS
Xstruct symbols defsyms = {
X    ' ', '|', '-', '-', '-', '-', '-', '+', '.', '#', '<', '>', '^',
X#ifdef FOUNTAINS
X    '}', '{',
X#endif
X#ifdef NEWCLASS
X    '\\',
X#endif
X#ifdef SPIDERS
X    '"',
X#endif
X};
X#endif
Xstruct symbols showsyms;	/* will contain the symbols actually used */
X
X.
X1c
X/*	SCCS Id: @(#)decl.c	1.4	87/08/08
X.
Xw
Xq
XED_EOF
X
Xcp do.c do.c.orig
Xed do.c <<ED_EOF
X301c
X	read_engr_at(u.ux,u.uy);
X.
X27c
X	if(obj->olet == GOLD_SYM) {		/* pseudo object */
X.
X1c
X/*	SCCS Id: @(#)do.c	1.4	87/08/08
X.
Xw
Xq
XED_EOF
X
Xcp do_name.c do_name.c.orig
Xed do_name.c <<ED_EOF
X215,221c
X	"Ron", "Tom", "Wilmar", "Nick Danger", "Phoenix", "Miracleman",
X	"Stephan"
X.
X209d
X55c
X	getpos(&cc, 0, "the monster you want to name");
X.
X44,46c
X	cc->x = cx;
X	cc->y = cy;
X	return(0);
X.
X37,39c
X			cc->x = -1;
X			cc->y = 0;
X			return(0);
X.
X16d
X10,11c
Xgetpos(cc,force,goal)
Xcoord	*cc;
Xint force; char *goal;
X{
X.
X1c
X/*	SCCS Id: @(#)do_name.c	1.4	87/08/08
X.
Xw
Xq
XED_EOF
X
Xcp dog.c dog.c.orig
Xed dog.c <<ED_EOF
X20a
X#ifdef	DOGNAME
X	if (dogname[0]) {
X		register struct monst *mtmp2;
X		mtmp->mnamelth = strlen(dogname);
X		mtmp2 = newmonst(sizeof(struct edog) + mtmp->mnamelth);
X		*mtmp2 = *mtmp;
X		strcpy(NAME(mtmp2), dogname);
X		replmon(mtmp, mtmp2);
X		mtmp = mtmp2;
X	}
X#endif	/* DOGNAME */
X.
X9a
X#ifdef	DOGNAME
Xchar dogname[63];
X#endif	/* DOGNAME */
X
X.
X1c
X/*	SCCS Id: @(#)dog.c	1.4	87/08/08
X.
Xw
Xq
XED_EOF
X
Xcp dogmove.c dogmove.c.orig
Xed dogmove.c <<ED_EOF
X198,199c
X			if(mtmp2)
X			    if(mtmp2->data->mlevel >= mdat->mlevel+2 ||
X			       mtmp2->data->mlet == 'c')
X.
X51c
X		if(cansee(omx,omy))
X			pline("%s dies%s.", Monnam(mtmp),
X			      (mtmp->mhp >= 1) ? "" : " from hunger");
X		else
X			pline("You have a sad feeling for a moment, then it passes.");
X.
X48,49c
X		if(mtmp->mleashed) {
X			mtmp->mleashed = 0;
X			pline("Your leash goes slack...");
X		}
X.
X44,46d
X1c
X/*	SCCS Id: @(#)dogmove.c	1.4	87/08/08
X.
Xw
Xq
XED_EOF
X
Xcp eat.c eat.c.orig
Xed eat.c <<ED_EOF
X560c
X		    u.usym = GOLD_SYM;
X.
X1c
X/*	SCCS Id: @(#)eat.c	1.4	87/08/08
X.
Xw
Xq
XED_EOF
X
Xcp end.c end.c.orig
Xed end.c <<ED_EOF
X67a
X		killer = buf;
X      } else if(mtmp->isshk) {         /* stewr 870807 */
X	        Sprintf(buf, "shopkeeper, %s %s",
X			rn2(2) ? "Mr." : "Ms.", shkname(mtmp));
X.
X57a
Xextern char *shkname();
X.
X1c
X/*	SCCS Id: @(#)end.c	1.4	87/08/08
X.
Xw
Xq
XED_EOF
X
Xcp engrave.c engrave.c.orig
Xed engrave.c <<ED_EOF
X391c
X	        /* kludge by stewr 870708 */
X	for (sptmp = sp, tmp=0; !(tmp == len); sptmp++,tmp++) {
X	        if (((type == DUST) && !rn2(25))
X		     || (Blind && !rn2(12))
X		     || (Confusion && !rn2(3))) {
X		         *sptmp = '!' + rn2(93); /* ASCII-code only */
X		       }
X	      }
X
X.
X175,176c
Xregister int len, tmp;
Xregister char *sp, *sptmp;
X.
X132c
X	    if (canfeel)
X		pline("You %s: \"%s\".",
X		      (Blind) ? "feel the words" : "read",  ep->engr_txt);
X.
X130a
X		canfeel = 1;
X.
X125c
X		if(!Blind) pline("There's some graffiti here on the floor.");
X		canfeel = 0;
X.
X122a
X		canfeel = 1;
X.
X119a
X		canfeel = 1;
X.
X116c
X		if(!Blind) pline("Something is written here in the dust.");
X		canfeel = 0;
X.
X112a
Xregister int	canfeel;
X.
X1c
X/*	SCCS Id: @(#)engrave.c	1.4	87/08/08
X.
Xw
Xq
XED_EOF
X
Xcp fight.c fight.c.orig
Xed fight.c <<ED_EOF
X456,469d
X451,452c
X		    else
X			pline("That spellbook was %s.", defmonnam(mtmp));
X		}
X		else if (levl[u.ux+u.dx][u.uy+u.dy].scrsym == GOLD_SYM)
X.
X447,448c
X		if (levl[u.ux+u.dx][u.uy+u.dy].scrsym == DOOR_SYM)
X		{
X.
X217,218c
X		    if((dtmp = mkmon_at('&',u.ux,u.uy)))
X			(void)tamedog(dtmp,(struct obj *)0);
X.
X26a
X	if(!magr || !mdef) return(0);		/* mike@genat */
X.
X1c
X/*	SCCS Id: @(#)fight.c	1.4	87/08/08
X.
Xw
Xq
XED_EOF
X
Xcp fountain.c fountain.c.orig
Xed fountain.c <<ED_EOF
X61d
X58c
X	if((mtmp = mkmon_at('N',u.ux,u.uy))) {
X.
X47,52c
X	if((mtmp = mkmon_at('&',u.ux,u.uy))) {
X	    pline("You have unleashed a water demon!");
X	    if (rnd(100)>97) {
X		pline("Grateful for his release, he grants you a wish!");
X		makewish();
X		mondied(mtmp);
X	    }
X.
X1c
X/*	SCCS Id: @(#)fountain.c	1.4	87/08/08
X.
Xw
Xq
XED_EOF
X
Xcp hack.c hack.c.orig
Xed hack.c <<ED_EOF
X1034a
X#else
X	        carrcap = 5*u.ulevel;      /* New strength stewr 870807 */
X		if (u.ustr < 19) carrcap += 5*u.ustr;
X		if (u.ustr > 18) carrcap += u.ustr - 18 + 90;
X		if (u.ustr > 68) carrcap += u.ustr - 68;
X		if (u.ustr > 93) carrcap += u.ustr - 93;
X		if (u.ustr > 108) carrcap += 2*(u.ustr - 108);
X		if (u.ustr > 113) carrcap += 5*(u.ustr - 113);
X		if (u.ustr == 118) carrcap += 100;
X#endif
X.
X1033a
X#ifdef HARD
X.
X704,742d
X692c
X		} else if (sym == TRAP_SYM) {
X.
X676c
X		} else if (sym == CORR_SYM) {
X.
X672c
X		else if (sym == DOOR_SYM) {
X.
X669,670c
X		if (sym == VWALL_SYM || sym == HWALL_SYM
X		    || sym == ROOM_SYM || sym == STONE_SYM
X		    || IS_CORNER(sym))
X.
X665d
X515c
X	if(all || index(olets, GOLD_SYM))
X.
X465c
X		if(g_at(u.ux,u.uy)) ilets[iletct++] = GOLD_SYM;
X.
X105,106c
X			if((mtmp = m_at(rx,ry))) {
X			    if(canseemon(mtmp))
X				pline("There's %s on the other side.", monnam(mtmp));
X			    else
X				pline("You hear a monster behind the rock.");
X.
X96a
X	register struct	monst *mtmp, *m_at();
X.
X82,86c
X				if(!lev->lit && lev->scrsym == ROOM_SYM)
X.
X39,44c
X		if(!lev->lit && lev->scrsym == ROOM_SYM) {
X			lev->scrsym = STONE_SYM;
X.
X7c
Xstatic	char	SCCS_Id[] = "@(#)hack.c	1.4\t87/08/08";
X.
Xw
Xq
XED_EOF
X
Xcp hack.h hack.h.orig
Xed hack.h <<ED_EOF
X50a
X#else
X#define	MAX_CARR_CAP	500
X#endif
X.
X49a
X#ifdef HARD
X.
X47a
X#endif
X.
X46a
X#ifdef GENIX
X#define DIST	jhndist
X/*	genix compiler chokes on DIST macro below - jhn*/
X#else
X.
X6a
X#ifdef __TURBOC__
X/* work around the case-insensitivity of the DOS linker */
X#define Amonnam Amonnam_
X#define Xmonnam Xmonnam_
X#define Monnam Monnam_
X#define POISONOUS POISONOUS_
X#define Doname Doname_
X#define Tmp_at Tmp_at_
X/* rename the next two functions because they clash with the Turbo C library */
X#define getdate getdate_
X#define itoa itoa_
X#endif
X
X
X.
X1c
X/*	SCCS Id: @(#)hack.h	1.4	87/08/08
X.
Xw
Xq
XED_EOF
X
Xcp help help.orig
Xed help <<ED_EOF
X124c
X	v	prints the version number.
X	V	prints a longer identification of the version, including the
X		history of the game.
X	#	introduces one of the "extended" commands.  To get a list of
X		the commands you can use with "#" type "#?".  The extended
X		commands you can use depends upon what options the game was
X		compiled with, along with your class and what type of monster
X		you most closely resemble at a given moment.
X.
X91c
X	T	Takeoff armor.
X	A	Remove some or all armor.
X.
X88c
X	P	Put on a ring.
X.
X82a
X		If you see fancy graphics on your screen it may ask you to
X		specify a location rather than taking a symbol argument.
X.
Xw
Xq
XED_EOF
X
Xcp hh hh.orig
Xed hh <<ED_EOF
X49a
XT	remove	take off some armor
XA	remove	take off some or all armor
X.
X48d
X18c
Xv	version	print version number
XV	history	print game history.
X.
X4,7c
X /|\			  (until stopped by e.g. a wall)
Xb j n		g<dir>:   fast movement in direction <dir>
X			  (until something interesting is seen)
X		m<dir>:   move without picking up objects
X.
Xw
Xq
XED_EOF
X
Xcp invent.c invent.c.orig
Xed invent.c <<ED_EOF
X1024c
X	if (HI && HE)
X	    Sprintf(buf, "%s%s%s", HI, names[pos - obj_symbols], HE);
X	else
X	    Sprintf(buf, "%s", names[pos - obj_symbols]);
X.
X792,793c
X#ifdef KAA
X    read_engr_at(u.ux, u.uy); /* Eric Backus */
X.
X778,783d
X745c
X	if(c == GOLD_SYM)
X.
X717c
X	if(u.ugold) stuff[stct++] = GOLD_SYM;
X.
X507c
X		if(sym == GOLD_SYM) {
X.
X481c
X		if(allowgold) ilets[iletct++] = GOLD_SYM;
X.
X400c
X		if(ilet == GOLD_SYM) {
X.
X396a
X		}
X.
X395c
X		if(index(quitchars,ilet)) {
X			pline("Never mind.");
X.
X380c
X		}
X.
X374c
X		} else {
X.
X369c
X		if(!buf[0]) {
X.
X317c
X	if(allowgold) *bp++ = GOLD_SYM;
X.
X313c
X	if(*let == GOLD_SYM) let++, allowgold = TRUE;
X.
X282c
X	otmp->olet = GOLD_SYM;
X.
X1c
X/*	SCCS Id: @(#)invent.c	1.4	87/08/08
X.
Xw
Xq
XED_EOF
X
Xcp lev.c lev.c.orig
Xed lev.c <<ED_EOF
X374c
X					nsym = showsyms.hwall;
X.
X372c
X					nsym = showsyms.brcorn;
X.
X370c
X					nsym = showsyms.blcorn;
X.
X368c
X					nsym = showsyms.trcorn;
X.
X366c
X					nsym = showsyms.tlcorn;
X.
X349c
X						nsym = showsyms.hwall;
X.
X347c
X						nsym = showsyms.vwall;
X.
X343c
X						nsym = showsyms.vwall;
X.
X339c
X						nsym = showsyms.corr;
X.
X335c
X						nsym = showsyms.door;
X.
X331c
X						nsym = showsyms.room;
X.
X320c
X	if (memcmp((char *) &osymbol, (char *) &showsyms, sizeof (struct symbols))) {
X.
X311c
X#ifdef GRAPHICS
X.
X289c
X#ifdef GRAPHICS
X.
X94,97c
X#ifdef DGK
X	if (!count_only)
X#endif
X	{
X		fgold = 0;
X		ftrap = 0;
X		fmon = 0;
X		fobj = 0;
X	}
X.
X75,76c
X#ifdef GRAPHICS
X	bwrite(fd, (char *) &showsyms, sizeof(struct symbols));
X.
X1c
X/*	SCCS Id: @(#)lev.c	1.4	87/08/08
X.
Xw
Xq
XED_EOF
X
Xcp makedefs.c makedefs.c.orig
Xed makedefs.c <<ED_EOF
X592a
X}
X#endif
X
X#ifdef __TURBOC__
Xint getpid() {
X	return(1);
X.
X583c
X#if defined(SYSV) || defined(GENIX)
X.
X255c
X	if(freopen(ONAME_FILE, WRMODE, stdout) == NULL) {
X.
X223d
X218a
X		printf("{\ta fountain\n");
X	    } else
X#endif
X#ifdef NEWCLASS
X	    if(!strcmp(inline, "^	a trap")) {
X		puts(inline);
X		printf("\\\tan opulant throne.\n");
X	    } else
X#endif
X		puts(inline);
X.
X217a
X#ifdef	SPELLS
X	    if (!strcmp(inline, "+	a door"))
X		printf("+\ta door (or a spell book)\n");
X	    else
X#endif
X#ifdef	FOUNTAINS
X	    if(!strcmp(inline, "}	water filled area")) {
X.
X215a
X	    else if (!strcmp(inline, "\"	an amulet"))
X		printf("\"\tan amulet (or a web)\n");
X.
X210c
X		printf("r\ta rockmole\n");
X.
X191c
X	if(freopen(DATA_FILE, WRMODE, stdout) == NULL) {
X.
X186c
X	if(freopen(tmpfile, RDMODE, stdin) == NULL) {
X.
X176a
X#ifdef MSDOS
X	remove(DATE_FILE);
X#endif
X.
X159c
X	if(freopen(DATE_FILE, RDMODE, stdin) == NULL) {
X.
X154c
X	if(freopen(tmpfile, WRMODE, stdout) == NULL) {
X.
X139c
X	if(freopen(infile, RDMODE, stdin) == NULL)	perror(infile);
X.
X132c
X	if(freopen(infile, RDMODE, stdin) == NULL)	perror(infile);
X.
X122c
X#endif
X	if(freopen(infile, RDMODE, stdin) == NULL) {
X.
X120a
X#ifdef MSDOS
X	sprintf(infile, "%s.bas", RUMOR_FILE);
X#else
X.
X116c
X	if(freopen(RUMOR_FILE, WRMODE, stdout) == NULL) {
X.
X101a
X#ifdef MSDOS
X	remove(TRAP_FILE);
X#endif
X.
X68c
X	if(freopen(TRAP_FILE, RDMODE, stdin) == NULL) {
X.
X63c
X	if(freopen(tmpfile, WRMODE, stdout) == NULL) {
X.
X10a
X#define	alloc	malloc
X#define RDMODE	"r"
X#define WRMODE	"w"
X#else
X#define RDMODE	"r+"
X#define WRMODE	"w+"
X.
X4c
Xstatic	char	SCCS_Id[] = "@(#)makedefs.c	1.4\t87/08/08";
X.
Xw
Xq
XED_EOF
X
Xcp makemon.c makemon.c.orig
Xed makemon.c <<ED_EOF
X248c
X	cc->x = foo[rn2(tfoo-foo)].x;
X	cc->y = foo[rn2(tfoo-foo)].y;
X	return(0);
X.
X210,211c
Xenexto(cc, xx,yy)
Xcoord	*cc;
X.
X149c
X			enexto(&mm, mm.x, mm.y);
X.
X143d
X1c
X/*	SCCS Id: @(#)makemon.c	1.4	87/08/08
X.
Xw
Xq
XED_EOF
X
Xcp mklev.c mklev.c.orig
Xed mklev.c <<ED_EOF
X874c
X		      mazexy(&mm);
X.
X872d
X847c
X			mazexy(&mm);
X.
X845d
X826,830c
X			fakegold ? '$' : fakedoor ? DOOR_SYM :
X.
X815c
X				mazexy(&mm);
X.
X813d
X731d
X727,729d
X717c
X		rm->scrsym = STONE_SYM;
X.
X709c
X		finddpos(&dd, aroom->lx, aroom->ly-1, aroom->hx, aroom->ly-1);
X.
X706c
X		finddpos(&dd, aroom->lx, aroom->hy+1, aroom->hx, aroom->hy+1);
X.
X575c
X			crm->scrsym = STONE_SYM;
X.
X570d
X566,568d
X539,540c
X		finddpos(&cc, croom->lx, yy, croom->hx, yy);
X		finddpos(&tt, troom->lx, ty, troom->hx, ty);
X.
X532,533c
X		finddpos(&cc, xx, croom->ly, xx, croom->hy);
X		finddpos(&tt, tx, troom->ly, tx, troom->hy);
X.
X526c
X		finddpos(&tt, troom->lx, ty, troom->hx, ty);
X.
X524c
X		finddpos(&cc, croom->lx, yy, croom->hx, yy);
X.
X518,519c
X		finddpos(&cc, xx, croom->ly, xx, croom->hy);
X		finddpos(&tt, tx, troom->ly, tx, troom->hy);
X.
X446,466c
X	levl[lowx-1][lowy-1].scrsym = TLCORN_SYM;
X	levl[hix+1][lowy-1].scrsym = TRCORN_SYM;
X	levl[lowx-1][hiy+1].scrsym = BLCORN_SYM;
X	levl[hix+1][hiy+1].scrsym = BRCORN_SYM;
X.
X443c
X		levl[x][y].scrsym = ROOM_SYM;
X.
X438c
X		levl[x][y].scrsym = VWALL_SYM;
X.
X433c
X		levl[x][y].scrsym = HWALL_SYM;
X.
X430d
X359,363c
X		levl[x][y].scrsym = DOOR_SYM;
X.
X355c
X	if(!IS_WALL(levl[x][y].typ))	/* avoid SDOORs with DOOR_SYM as scrsym */
X.
X315,317c
X	cc->x = x;
X	cc->y = y;
X	return(0);
X.
X294,296c
Xfinddpos(cc, xl,yl,xh,yh)
Xcoord	*cc;
Xint	xl,yl,xh,yh;
X{
X.
X79c
X	levl[xupstair][yupstair].scrsym = UP_SYM;
X.
X70c
X	levl[xdnstair][ydnstair].scrsym = DN_SYM;
X.
X28c
Xextern xchar xdnstair,xupstair,ydnstair,yupstair;
X.
X21c
Xextern coord doors[DOORMAX];
X.
X19c
Xextern struct mkroom rooms[MAXNROFROOMS+1];
X.
X1c
X/*	SCCS Id: @(#)mklev.c	1.4	87/08/08
X.
Xw
Xq
XED_EOF
X
Xcp mkmaze.c mkmaze.c.orig
Xed mkmaze.c <<ED_EOF
X182,187c
Xmazexy(cc)
Xcoord	*cc;
X{
X	cc->x = 3 + 2*rn2(COLNO/2 - 2);
X	cc->y = 3 + 2*rn2(ROWNO/2 - 2);
X	return(0);
X.
X93,94c
X	mazexy(&mm);
X	levl[(xupstair = mm.x)][(yupstair = mm.y)].scrsym = UP_SYM;
X.
X88c
X		mazexy(&mm);
X.
X84c
X		mazexy(&mm);
X.
X81c
X	mazexy(&mm);
X.
X78c
X		mazexy(&mm);
X.
X74c
X		mazexy(&mm);
X.
X63,70d
X61c
X				levl[x][y].scrsym = ROOM_SYM;
X.
X58c
X				levl[x][y].scrsym = HWALL_SYM;
X.
X56d
X45c
X	    mazexy(&mm);
X.
X10d
X1c
X/*	SCCS Id: @(#)mkmaze.c	1.4	87/08/08
X.
Xw
Xq
XED_EOF
X
Xcp mkobj.c mkobj.c.orig
Xed mkobj.c <<ED_EOF
X134,135c
X				otmp->spe = -rne(3);
X			} else otmp->spe = rne(3);
X.
X121c
X			otmp->spe = -rne(2);
X.
X119c
X		if(!rn2(10)) otmp->spe = rne(2);
X.
X91c
X			otmp->spe = -rne(2);
X.
X88c
X		if(!rn2(11)) otmp->spe = rne(2);
X.
X1c
X/*	SCCS Id: @(#)mkobj.c	1.4	87/08/08
X.
Xw
Xq
XED_EOF
X
Xcp mon.c mon.c.orig
Xed mon.c <<ED_EOF
X710c
X		mtmp->mappearance = (levl[mtmp->mx][mtmp->my].typ == DOOR) ? DOOR_SYM : GOLD_SYM;
X.
X653c
X	enexto(&mm, u.ux, u.uy);
X.
X651d
X262c
X				tt = 1L << ttmp->ttyp;
X.
X260c
X		  register long tt;
X.
X171c
X		if(levl[mtmp->mx][mtmp->my].scrsym == GOLD_SYM)
X.
X62a
X#endif
X.
X60a
X#ifdef HARD
X.
X1c
X/*	SCCS Id: @(#)mon.c	1.4	87/08/08
X.
Xw
Xq
XED_EOF
X
Xcp msdos.c msdos.c.orig
Xed msdos.c <<ED_EOF
X257c
X	char	*dta, buf[PATHLEN];
X.
X238a
X#endif
X.
X226c
X#ifndef __TURBOC__
X/* Get disk transfer area, Turbo C already has getdta */
X.
X1c
X/*	SCCS Id: @(#)msdos.c	1.4	87/08/08
X.
Xw
Xq
XED_EOF
X
Xcp msdos.h msdos.h.orig
Xed msdos.h <<ED_EOF
X31c
Xvoid	msmsg(char *, ...);
X.
X1c
X/*	SCCS Id: @(#)msdos.h	1.4	87/08/08
X.
Xw
Xq
XED_EOF
X
Xcp nethack.6 nethack.6.orig
Xed nethack.6 <<ED_EOF
X170a
X.PP
XDungeons & Dragons is a Trademark of TSR Inc.
X.
X110c
X.PP
X.
X107c
X.PP
X.
X103c
X.PP
X.
X100c
X.PP
X.
X97a
X.PP
X.
X36c
Xis a display oriented Dungeons & Dragons(tm) - like game.
X.
X20,21c
X.B /usr/games/net[hack quest]
X.
X6,7c
X.B /usr/games/net[hack quest]
X.
Xw
Xq
XED_EOF
X
Xcp o_init.c o_init.c.orig
Xed o_init.c <<ED_EOF
X21a
X
X	/* bug fix to prevent "initialization error" abort on Intel Xenix.
X	 * reported by mikew@semike
X	 */
X        for(i = 0; i != sizeof(obj_symbols); i++)
X                bases[i] = 0;
X
X.
X1c
X/*	SCCS Id: @(#)o_init.c	1.4	87/08/08
X.
Xw
Xq
XED_EOF
X
Xcp objclass.h objclass.h.orig
Xed objclass.h <<ED_EOF
X60a
X#define	GOLD_SYM	'$'
X.
X1c
X/*	SCCS Id: @(#)objclass.h	1.4	87/08/08
X.
Xw
Xq
XED_EOF
X
Xcp objects.h objects.h.orig
Xed objects.h <<ED_EOF
X185a
X# endif
X#else
X# ifdef KAA
X	{ "enormous rock", NULL, NULL, 1, 0,
X		ROCK_SYM, 100, 0, 400 /* > MAX_CARR_CAP */, 0, 20, 20 },
X# else
X	{ "enormous rock", NULL, NULL, 1, 0,
X		ROCK_SYM, 100, 0, 550 /* > MAX_CARR_CAP */, 0, 0, 0 },
X# endif
X.
X183c
X# else
X.
X180a
X#ifdef HARD
X# ifdef KAA
X.
X179d
X1c
X/*	SCCS Id: @(#)objects.h	1.4	87/08/08
X.
Xw
Xq
XED_EOF
X
Xcp options.c options.c.orig
Xed options.c <<ED_EOF
X393a
X
Xnmcpy(dest, source, maxlen)
X	char	*dest, *source;
X	int	maxlen;
X{
X	char	*cs, *cd;
X	int	count;
X
X	cd = dest;
X	cs = source;
X	for(count = 1; count < maxlen; count++) {
X		if(*cs == ',') break;
X		*cd++ = *cs++;
X	}
X	*cd = 0;
X}
X.
X304c
X"and engame.", "", "");
X.
X295a
X#ifdef	DOGNAME
X" dogname, which gives the name of your (first) dog (e.g. dogname:Rover)",
X#endif	/* DOGNAME */
X.
X294c
X			pline("%s%s%s%s",
X.
X278c
X#ifdef GRAPHICS
X"engame, and graphics.", "", "");
X#else
X"and engame.", "", "");
X#endif
X.
X269a
X#ifdef	DOGNAME
X" dogname, which gives the name of your (first) dog (e.g. dogname:Rover)",
X#endif	/* DOGNAME */
X.
X268c
X			pline("%s%s%s%s",
X.
X255a
X#ifdef	DOGNAME
X	if(!strncmp(opts, "dogname", 3)) {
X		extern char dogname[];
X		op = index(opts, ':');
X		if (!op) goto bad;
X		nmcpy(dogname, ++op, 62);
X		return;
X	}
X#endif	/* DOGNAME */
X.
X222a
X#ifdef GRAPHICS
X	/* graphics:string */
X	if(!strncmp(opts,"graphics",4)) {
X		char buf[MAXPCHARS];
X		if(!from_env) {
X#ifdef DGK
X		  pline("'graphics' only settable from %s.", configfile);
X#else
X		  pline("The graphics string can be set only from HACKOPTIONS.");
X#endif
X		  return;
X		}
X		op = index(opts,':');
X		if(!op)
X		    goto bad;
X		else
X		    opts++;
X/*
X * You could have problems here if you configure FOUNTAINS, SPIDERS or NEWCLASS
X * in or out and forget to change the tail entries in your graphics string.
X */
X#define SETPCHAR(f, n)	showsyms.f = (strlen(opts) > n) ? opts[n] : defsyms.f
X		SETPCHAR(stone, 0);
X		SETPCHAR(vwall, 1);
X		SETPCHAR(hwall, 2);
X		SETPCHAR(tlcorn, 3);
X		SETPCHAR(trcorn, 4);
X		SETPCHAR(blcorn, 5);
X		SETPCHAR(brcorn, 6);
X		SETPCHAR(door, 7);
X		SETPCHAR(room, 8);
X		SETPCHAR(corr, 9);
X		SETPCHAR(upstair, 10);
X		SETPCHAR(dnstair, 11);
X		SETPCHAR(trap, 12);
X#ifdef FOUNTAINS
X		SETPCHAR(pool, 13);
X		SETPCHAR(fountain, 14);
X#endif
X#ifdef NEWCLASS
X		SETPCHAR(throne, 15);
X#endif
X#ifdef SPIDERS
X		SETPCHAR(web, 16);
X#endif
X#undef SETPCHAR
X		return;
X	}
X#endif /* GRAPHICS */
X
X.
X219c
X		nmcpy(plname, op+1, sizeof(plname)-1);
X.
X36c
X#endif
X#ifdef HACKOPTIONS
X.
X1c
X/*	SCCS Id: @(#)options.c	1.4	87/08/08
X.
Xw
Xq
XED_EOF
X
Xcp pager.c pager.c.orig
Xed pager.c <<ED_EOF
X422c
X	(void) wait((int *) 0);
X.
X385,403d
X43a
X#endif
X.
X42a
X#ifdef GRAPHICS
X				buf[0] = r;
X#else
X.
X29a
X#else
X		coord	cc; extern coord getpos();
X		char	r;	
X
X		pline("Please move the cursor to the unknown object.");
X		getpos(&cc, TRUE, "the unknown object");
X		r = levl[cc.x][cc.y].scrsym;
X
X		if (r == showsyms.stone) q = defsyms.stone;
X		else if (r == showsyms.vwall) q = defsyms.vwall;
X		else if (r == showsyms.hwall) q = defsyms.hwall;
X		else if (r == showsyms.tlcorn) q = defsyms.tlcorn;
X		else if (r == showsyms.trcorn) q = defsyms.trcorn;
X		else if (r == showsyms.blcorn) q = defsyms.blcorn;
X		else if (r == showsyms.brcorn) q = defsyms.brcorn;
X		else if (r == showsyms.door) q = defsyms.door;
X		else if (r == showsyms.room) q = defsyms.room;
X		else if (r == showsyms.corr) q = defsyms.corr;
X		else if (r == showsyms.upstair) q = defsyms.upstair;
X		else if (r == showsyms.dnstair) q = defsyms.dnstair;
X		else if (r == showsyms.trap) q = defsyms.trap;
X#ifdef FOUNTAINS
X		else if (r == showsyms.pool) q = defsyms.pool;
X		else if (r == showsyms.fountain) q = defsyms.fountain;
X#endif
X#ifdef NEWCLASS
X		else if (r == showsyms.throne) q = defsyms.throne;
X#endif
X#ifdef SPIDERS
X		else if (r == showsyms.web) q = defsyms.web;
X		else
X		    q = r;
X#endif
X#endif /* GRAPHICS */
X.
X27a
X#ifndef GRAPHICS
X.
X1c
X/*	SCCS Id: @(#)pager.c	1.4	87/08/08
X.
Xw
Xq
XED_EOF
X
Xcp pcmain.c pcmain.c.orig
Xed pcmain.c <<ED_EOF
X363a
X			if (!rn2(4)) u_wipe_engr(rnd(3));
X.
X254c
X		read_engr_at(u.ux,u.uy);
X.
X54a
X
X#ifdef GRAPHICS
X	/* Set the default values of the presentation characters */
X	memcpy((char *) &showsyms, (char *) &defsyms, sizeof(struct symbols));
X#endif
X.
X1c
X/*	SCCS Id: @(#)pcmain.c	1.4	87/08/08
X.
Xw
Xq
XED_EOF
X
Xcp pctty.c pctty.c.orig
Xed pctty.c <<ED_EOF
X205a
X#ifdef COM_COMPL
X/* Read in an extended command - doing command line completion for
X * when enough character have been entered to make a unique command.
X * This is just a modified getlin().   -jsb
X */
Xget_ext_cmd(bufp)
Xregister char *bufp;
X{
X	register char *obufp = bufp;
X	register int c;
X	int com_index, index;
X
X	flags.toplin = 2;		/* nonempty, no --More-- required */
X
X	for(;;) {
X		(void) fflush(stdout);
X		if((c = readchar()) == EOF) {
X			*bufp = 0;
X			return;
X		}
X		if(c == '\033') {
X			*obufp = c;
X			obufp[1] = 0;
X			return;
X		}
X		if(c == erase_char || c == '\b') {
X			if(bufp != obufp) {
X				bufp--;
X				putstr("\b \b"); /* putsym converts \b */
X			} else	bell();
X		} else if(c == '\n') {
X			*bufp = 0;
X			return;
X		} else if(' ' <= c && c < '\177') {
X				/* avoid isprint() - some people don't have it
X				   ' ' is not always a printing char */
X			*bufp = c;
X			bufp[1] = 0;
X			index = 0;
X			com_index = -1;
X
X			while(extcmdlist[index].ef_txt != (char *) 0){
X				if(!strncmp(obufp, extcmdlist[index].ef_txt,
X				strlen(obufp)))
X					if(com_index == -1) /* No matches yet*/
X					    com_index = index;
X					else /* More than 1 match */
X					    com_index = -2;
X				index++;
X			}
X			if(com_index >= 0){
X				strcpy(obufp,
X				extcmdlist[com_index].ef_txt);
X				/* finish print our string */
X				putstr(bufp);
X				bufp = obufp; /* reset it */
X				if(strlen(obufp) < BUFSIZ-1 &&
X				 strlen(obufp) < COLNO)
X					/* set bufp at the end of our
X					 * string
X					 */
X					bufp += strlen(obufp);
X			} else {
X				putstr(bufp);
X				if(bufp-obufp < BUFSZ-1 && bufp-obufp < COLNO)
X					bufp++;
X			}
X		} else if(c == kill_char || c == '\177') { /* Robert Viduya */
X				/* this test last - @ might be the kill_char */
X			while(bufp != obufp) {
X				bufp--;
X				putstr("\b \b");
X			}
X		} else
X			bell();
X	}
X
X}
X#endif COM_COMPL
X.
X8a
X#include "func_tab.h"
X.
X1c
X/*	SCCS Id: @(#)pctty.c	1.4	87/08/08
X.
Xw
Xq
XED_EOF
X
Xcp pcunix.c pcunix.c.orig
Xed pcunix.c <<ED_EOF
X80a
X}
X
Xgethdate(name) char *name; {
X/* old version - for people short of space */
X/*
X/* register char *np;
X/*      if(stat(name, &hbuf))
X/*              error("Cannot get status of %s.",
X/*                      (np = rindex(name, '/')) ? np+1 : name);
X/*
X/* version using PATH from: seismo!gregc@ucsf-cgl.ARPA (Greg Couch) */
X
X/*
X * The problem with   #include  <sys/param.h> is that this include file
X * does not exist on all systems, and moreover, that it sometimes includes
X * <sys/types.h> again, so that the compiler sees these typedefs twice.
X */
X#define         MAXPATHLEN      1024
X
Xregister char *np, *path;
Xchar filename[MAXPATHLEN+1];
X
X    if (index(name, '/') != NULL || (path = getenv("PATH")) == NULL)
X        path = "";
X
X    for (;;) {
X        if ((np = index(path, ':')) == NULL)
X            np = path + strlen(path);       /* point to end str */
X        if (np - path <= 1)                     /* %% */
X            (void) strcpy(filename, name);
X        else {
X            (void) strncpy(filename, path, np - path);
X            filename[np - path] = '/';
X            (void) strcpy(filename + (np - path) + 1, name);
X        }
X        if (stat(filename, &hbuf) == 0)
X            return;
X        if (*np == '\0')
X        path = "";
X        path = np + 1;
X    }
X    error("Cannot get status of %s.", (np = rindex(name, '/')) ? np+1 : name);
X}
X
Xuptodate(fd) {
X    if(fstat(fd, &buf)) {
X        pline("Cannot get status of saved level? ");
X        return(0);
X    }
X    if(buf.st_mtime < hbuf.st_mtime) {
X        pline("Saved level is out of date. ");
X        return(0);
X    }
X    return(1);
X.
X21a
Xstatic struct stat buf, hbuf;
X.
X19a
X#include        <sys/stat.h>
X.
X18a
X#endif
X.
X17a
X#ifndef __TURBOC__  /* Turbo C has time_t in time.h */
X.
X15a
X#include <stdio.h>	/* mainly for NULL */
X.
X1c
X/*	SCCS Id: @(#)pcunix.c	1.4	87/08/08
X.
Xw
Xq
XED_EOF
X
Xcp polyself.c polyself.c.orig
Xed polyself.c <<ED_EOF
X175a
X
X     if (u.uhp < 1)	done("died");
X.
X1c
X/*	SCCS Id: @(#)polyself.c	1.4	87/08/08
X.
Xw
Xq
XED_EOF
X
Xcp potion.c potion.c.orig
Xed potion.c <<ED_EOF
X588,595c
X	if(u.ustr > 118)	u.ustr = 118;
X	if(u.ustr > u.ustrmax)	u.ustrmax = u.ustr;
X.
X586c
X	if (inc) u.ustr++;
X	else {
X	         if (u.ustr < 18) u.ustr += (rn2(4) ? 1 : rnd(6) );
X		 else if (u.ustr < 103) u.ustr += rnd(10);
X		 else u.ustr++;
X	       }
X.
X562a
X#ifdef HARD
X	else	if (!rn2(4)) useup(potion);
X#endif
X.
X306c
X		if (u.mh > u.mhmax) u.mh = (u.mhmax + nxtra);
X.
X1c
X/*	SCCS Id: @(#)potion.c	1.4	87/08/08
X.
Xw
Xq
XED_EOF
X
Xcp pray.c pray.c.orig
Xed pray.c <<ED_EOF
X161a
X#ifdef NEWCLASS
Xdoturn() {	/* Knights & Priest(esse)s only please */
X
X	register struct monst *mtmp;
X	register int	xlev = 6;
X	extern char	pl_character[];
X
X	if((pl_character[0] != 'P') &&
X	   (pl_character[0] != 'K')) {
X
X		pline("You don't know how to turn undead!");
X		return(0);
X	}
X	if (Inhell) {
X
X		pline("Being in hell, your gods won't help you.");
X		aggravate();
X		return(0);
X	}
X	pline("Calling upon your gods, you chant an arcane formula.");
X	for(mtmp = fmon; mtmp; mtmp = mtmp->nmon)
X	    if(cansee(mtmp->mx,mtmp->my)) {
X		if(index(UNDEAD,mtmp->data->mlet) ||
X		   ((mtmp->data->mlet == '&') && (u.ulevel > 10))) {
X
X		    if(Confusion) {
X			pline("Unfortunately, your voice falters.");
X			mtmp->mflee = mtmp->mfroz = mtmp->msleep = 0;
X		    } else if (! resist(mtmp, '+', 0, TELL))
X			switch (mtmp->data->mlet) {
X			    case 'V':   xlev += 2;
X			    case 'W':   xlev += 4;
X			    case 'Z':   if(u.ulevel >= xlev)  {
X					    if(!resist(mtmp, '+', 0, NOTELL)) {
X						pline("You destroy the %s", monnam(mtmp));
X						mondied(mtmp);
X					    } else	mtmp->mflee = 1;
X					} else	mtmp->mflee = 1;
X					break;
X			    default:    mtmp->mflee = 1;
X					break;
X			}
X		   }
X	    }
X	    nomul(-5);
X	    return(1);
X}
X#endif /* NEWCLASS /**/
X.
X140c
X			mkobj_at('+', u.ux, u.uy);
X.
X131c
X				Protection |= INTRINSIC;
X.
X127c
X				Stealth |= INTRINSIC;
X.
X124c
X				Fast |= INTRINSIC;
X.
X121c
X				HTelepat |= INTRINSIC;
X.
X115a
X			flags.botl = 1;
X.
X91a
X#ifdef KAA
X.
X89c
X			    if(uleft->cursed) {
X				pline("your left hand glows amber.");
X				uleft->cursed = 0;
X			    } else if(uright->cursed) {
X				pline("your right hand glows amber.");
X				uleft->cursed = 0;
X			    } else    pline("but nothing seems to happen.");
X.
X87d
X1c
X/*	SCCS Id: @(#)pray.c	1.4	87/08/08
X.
Xw
Xq
XED_EOF
X
Xcp pri.c pri.c.orig
Xed pri.c <<ED_EOF
X404c
X		u.mtimedone ? u.mh : u.uhp, u.mtimedone ? u.mhmax, u.uhpmax,
X.
X395c
X		u.mtimedone ? u.mh : u.uhp, u.mtimedone ? u.mhmax, u.uhpmax,
X.
X312d
X308,310d
X6a
X#ifdef GENIX
X#define	void	int	/* jhn - mod to prevent compiler from bombing */
X#endif
X.
X1c
X/*	SCCS Id: @(#)pri.c	1.4	87/08/08
X.
Xw
Xq
XED_EOF
X
Xcp prisym.c prisym.c.orig
Xed prisym.c <<ED_EOF
X248d
X245,246c
X		if(room->lit || cansee(x,y) || Blind) tmp = ROOM_SYM;
X		else tmp = STONE_SYM;
X.
X224,241d
X221c
X		tmp = DOOR_SYM;
X.
X217c
X		tmp = VWALL_SYM;
X.
X214c
X			tmp = HWALL_SYM;
X.
X210d
X203c
X	else if((ttmp = t_at(x,y)) && ttmp->tseen) tmp = TRAP_SYM;
X.
X201c
X	else if(ttmp && ttmp->tseen) tmp = TRAP_SYM;
X.
X196,198c
X		tmp = Hallucination ? rndobjsym() : GOLD_SYM;
X	else if(x == xupstair && y == yupstair) tmp = UP_SYM;
X	else if(x == xdnstair && y == ydnstair) tmp = DN_SYM;
X.
X191c
X	if(!room->seen) tmp = STONE_SYM;
X.
X172,173c
X		atl(x,y,Hallucination ? rndobjsym() : GOLD_SYM);
X	else if(!room->seen || room->scrsym == STONE_SYM) {
X.
X1c
X/*	SCCS Id: @(#)prisym.c	1.4	87/08/08
X.
Xw
Xq
XED_EOF
X
Xcp read.c read.c.orig
Xed read.c <<ED_EOF
X673c
X			if(lev->scrsym == STONE_SYM || !lev->scrsym)
X				newsym(zx,zy);
X.
X661,665c
X			lev->scrsym = DOOR_SYM;
X.
X658d
X654,656d
X633a
X		killer = "scroll of genocide";
X	/* A polymorphed character will die as soon as he is rehumanized. */
X		if(u.usym != '@')	pline("You feel dead inside.");
X		else			done("died");
X.
X631,632d
X602,604c
Xdo_genocide() {
X.
X345c
X				at(gtmp->gx, gtmp->gy, Hallucination ? rndobjsym() : GOLD_SYM);
X.
X324c
X				at(ttmp->tx, ttmp->ty, Hallucination ? rndobjsym() : GOLD_SYM);
X.
X166,168c
X# ifdef SPELLS
X		    else if(sobj->otyp == SCR_SCARE_MONSTER)
X# endif
X			pline ("You hear %s close by.",
X			       (confused) ? "sad wailing" : "maniacal laughter");
X.
X164c
X			  (confused) ? "sad wailing" : "maniacal laughter");
X.
X79c
X	    {
X.
X69a
X	extern struct obj *some_armor();
X.
X1c
X/*	SCCS Id: @(#)read.c	1.4	87/08/08
X.
Xw
Xq
XED_EOF
X
Xcp rip.c rip.c.orig
Xed rip.c <<ED_EOF
X6a
X#ifdef GENIX
X#define	void	int	/* jhn - mod to prevent compiler from bombing */
X#endif
X.
X1c
X/*	SCCS Id: @(#)rip.c	1.4	87/08/08
X.
Xw
Xq
XED_EOF
X
Xcp rm.h rm.h.orig
Xed rm.h <<ED_EOF
X60,63c
X	unsigned typ:5;
X	unsigned new:1;
X	unsigned seen:1;
X	unsigned lit:1;
X.
X49a
X#define MAXPCHARS	17	/* maximum number of mapped characters */
X
X#define IS_CORNER(x)	((x) == TLCORN_SYM || (x) == TRCORN_SYM \
X			 || (x) == BLCORN_SYM || (x) == BRCORN_SYM)
X
X.
X47a
X/* screen symbols for using character graphics. */
Xstruct symbols {
X    unsigned char stone, vwall, hwall, tlcorn, trcorn, blcorn, brcorn;
X    unsigned char door, room, corr, upstair, dnstair, trap;
X#ifdef FOUNTAINS
X    unsigned char pool, fountain;
X#endif
X#ifdef NEWCLASS
X    unsigned char throne;
X#endif
X#ifdef SPIDERS
X    unsigned char web;
X#endif
X};
Xextern struct symbols showsyms, defsyms;
X
X#define STONE_SYM	showsyms.stone
X#define VWALL_SYM	showsyms.vwall
X#define HWALL_SYM	showsyms.hwall
X#define TLCORN_SYM	showsyms.tlcorn
X#define TRCORN_SYM	showsyms.trcorn
X#define BLCORN_SYM	showsyms.blcorn
X#define BRCORN_SYM	showsyms.brcorn
X#define DOOR_SYM	showsyms.door
X#define ROOM_SYM	showsyms.room
X#define	CORR_SYM	showsyms.corr
X#define UP_SYM		showsyms.upstair
X#define DN_SYM		showsyms.dnstair
X#define TRAP_SYM	showsyms.trap
X#define	POOL_SYM	showsyms.pool
X#define FOUNTAIN_SYM    showsyms.fountain
X#define THRONE_SYM      showsyms.throne
X#define WEB_SYM         showsyms.web
X#endif
X
X.
X46c
X#else /* GRAPHICS */
X.
X41a
X#define UP_SYM		'<'
X#define DN_SYM		'>'
X#define TRAP_SYM	'^'
X.
X40c
X# define	CORR_SYM	'#'
X.
X38c
X# define	CORR_SYM	':'
X.
X36a
X#ifndef GRAPHICS
X
X#define STONE_SYM	' '
X#define VWALL_SYM	'|'
X#define HWALL_SYM	'-'
X#define TLCORN_SYM	'+'
X#define TRCORN_SYM	'+'
X#define BLCORN_SYM	'+'
X#define BRCORN_SYM	'+'
X#define DOOR_SYM	'+'
X#define ROOM_SYM	'.'
X.
X35c
X * The level-map symbols may be compiled in or defined at initialization time
X.
X4a
X/*
X * The dungeon presentation graphics code and data structures were rewritten
X * and generalized for NetHack's release 2 by Eric S. Raymond (eric@snark)
X * building on Don G. Kneller's MS-DOS implementation. See options.c for
X * the code that permits the user to set the contents of the symbol structure.
X */
X
X.
X1c
X/*	SCCS Id: @(#)rm.h	1.4	87/08/08
X.
Xw
Xq
XED_EOF
X
Xcp rnd.c rnd.c.orig
Xed rnd.c <<ED_EOF
X30a
X}
X
Xrne(x)          /* by stewr 870807 */
Xregister x;
X{
X        register tmp = 1;
X	while(!rn2(x)) tmp++;
X	return(tmp);
X}
X
Xrnz(x)
Xregister x;
X{
X        register tmp = 1000;
X	tmp += rn2(1000);
X	tmp *= rne(4);
X	if (rn2(2)) { x *= tmp; x /= 1000; }
X	else { x *= 1000; x /= tmp; }
X	return(x);
X.
X1c
X/*	SCCS Id: @(#)rnd.c	1.4	87/08/08
X.
Xw
Xq
XED_EOF
X
Xcp save.c save.c.orig
Xed save.c <<ED_EOF
X379c
X			mtmp->data = &d_prince;
X.
X376c
X			mtmp->data = &d_lord;
X.
X49a
X#endif
X.
X48a
X#ifndef __TURBOC__
X.
X1c
X/*	SCCS Id: @(#)save.c	1.4	87/08/08
X.
Xw
Xq
XED_EOF
X
Xcp search.c search.c.orig
Xed search.c <<ED_EOF
X106c
X				if(!vism_at(x,y)) atl(x,y,TRAP_SYM);
X.
X103c
X				    return(1);
X.
X100,101c
X				    deltrap(trap);
X				    if((mtmp=makemon(PM_PIERCER,x,y)))
X.
X50c
X						atl(zx,zy,TRAP_SYM);
X.
X40d
X36,38d
X28,32c
X				atl(zx, zy, DOOR_SYM);
X.
X1c
X/*	SCCS Id: @(#)search.c	1.4	87/08/08
X.
Xw
Xq
XED_EOF
X
Xcp shk.c shk.c.orig
Xed shk.c <<ED_EOF
X249,250c
X		    box = carrying(ICE_BOX) != (struct obj *)0;
X		    pick = carrying(PICK_AXE) != (struct obj *)0;
X.
X242a
X		    struct obj *carrying();
X.
X1c
X/*	SCCS Id: @(#)shk.c	1.4	87/08/08
X.
Xw
Xq
XED_EOF
X
Xcp sit.c sit.c.orig
Xed sit.c <<ED_EOF
X137c
X/*			levl[u.ux][u.uy].scrsym = ROOM_SYM; */
X.
X53a
X				heal_legs();
X.
X1c
X/*	SCCS Id: @(#)sit.c	1.4	87/08/08
X.
Xw
Xq
XED_EOF
X
Xcp spell.c spell.c.orig
Xed spell.c <<ED_EOF
X256c
X		healup(rnd(8), 0, 0, 0);
X.
X231,232c
X		if (!(objects[pseudo->otyp].bits & NODIR)) {
X			getdir(1);
X			if(!u.dx && !u.dy && !u.dz && (u.ulevel > 8)) {
X			    if((damage = zapyourself(pseudo)))
X				losehp(damage, "self-inflicted injury");
X			} else	weffects(pseudo);
X		} else weffects(pseudo);
X.
X206c
X		if (Hallucination)
X			pline("Far out... a light show!");
X		else	pline("The air around you crackles as you goof up.");
X.
X204c
X	if (confused ||
X	    (rn2(10) + u.ulevel + u.uluck - spellev(spell)) <= 0) {
X.
X182c
X	register int	 spell, energy, damage;
X.
X164,174c
X	default:
X		rndcurse();
X.
X123c
X	switch(rn2(level)) {
X.
X1,2c
X/*	SCCS Id: @(#)spell.c	1.4	87/08/08
X/* spell.c - version 1.0.1		M. Stephenson 07-04-86 */
X.
Xw
Xq
XED_EOF
X
Xcp steal.c steal.c.orig
Xed steal.c <<ED_EOF
X203c
X			atl(mtmp->mx,mtmp->my, Hallucination ? rndobjsym() : GOLD_SYM);
X.
X1c
X/*	SCCS Id: @(#)steal.c	1.4	87/08/08
X.
Xw
Xq
XED_EOF
X
Xcp termcap.c termcap.c.orig
Xed termcap.c <<ED_EOF
X301,302c
X#ifdef TERMINFO
X		tputs("$<50>", 1, xputs);
X#else
X		tputs("50", 1, xputs);
X#endif
X.
X106,107c
X	/* Get rid of padding numbers for HI and HE.  Hope they
X	 * aren't really needed!!!  HI and HE are ouputted to the
X	 * pager as a string - so how can you send it NULLS???
X	 *  -jsb
X	 */
X	    HI = (char *) alloc(strlen(SO));
X	    HE = (char *) alloc(strlen(SE));
X	    i = 0;
X	    while(isdigit(SO[i])) i++;
X	    strcpy(HI, &SO[i]);
X	    i = 0;
X	    while(isdigit(SE[i])) i++;
X	    strcpy(HE, &SE[i]);
X.
X57a
X	register int i;
X.
X14a
X#endif
X.
X13c
X# endif
X.
X11c
X#ifndef TERMINFO
X# ifndef lint
X.
X7a
X#ifdef GENIX
X#define	void	int	/* jhn - mod to prevent compiler from bombing */
X#endif
X
X.
X5a
X#include <ctype.h>	/* for isdigit() */
X.
X1c
X/*	SCCS Id: @(#)termcap.c	1.4	87/08/08
X.
Xw
Xq
XED_EOF
X
Xcp topl.c topl.c.orig
Xed topl.c <<ED_EOF
X6a
X#ifdef GENIX
X#define	void	int	/* jhn - mod to prevent compiler from bombing */
X#endif
X
X.
X1c
X/*	SCCS Id: @(#)topl.c	1.4	87/08/08
X.
Xw
Xq
XED_EOF
X
Xcp topten.c topten.c.orig
Xed topten.c <<ED_EOF
X49c
X#define HUP
X.
X6a
X#ifdef GENIX
X#define	void	int	/* jhn - mod to prevent compiler from bombing */
X#endif
X
X.
X1c
X/*	SCCS Id: @(#)topten.c	1.4	87/08/08
X.
Xw
Xq
XED_EOF
X
Xcp trap.c trap.c.orig
Xed trap.c <<ED_EOF
X647c
X	    newlevel = rnz(dlevel + 3);	/* 5 - 24 */
X.
X645c
X	    newlevel = rn2(5) ? rnz(dlevel + 3) : 30;
X.
X562c
X	read_engr_at(u.ux,u.uy);
X.
X523c
X		    getpos(&cc, 1, "the desired position"); /* 1: force valid */
X.
X507d
X173c
X				if (uwep && uwep->otyp == TWO_HANDED_SWORD) goto two_hand;
X.
X1c
X/*	SCCS Id: @(#)trap.c	1.4	87/08/08
X.
Xw
Xq
XED_EOF
X
Xcp u_init.c u_init.c.orig
Xed u_init.c <<ED_EOF
X396a
X# ifdef KAA
X		uwep->dknown = 1;	/* bless his primary weapon */
X# endif
X.
X221c
X		if (pc == 'q' || pc == 'Q') {
X
X			clearlocks();
X			settty((char *) 0);
X			exit(0);
X		}
X.
X203c
X	if (index("qQ", exper)) {
X		clearlocks();
X		settty((char *) 0);
X		exit(0);
X	}
X.
X7a
X#ifdef GENIX
X#define	void	int
X#endif
X
X.
X1c
X/*	SCCS Id: @(#)u_init.c	1.4	87/08/08
X.
Xw
Xq
XED_EOF
X
Xcp unixmain.c unixmain.c.orig
Xed unixmain.c <<ED_EOF
X568a
X
X#ifdef GENIX
Xjhndist(x1,y1,x2,y2)
X{
X	int x,y;
X	x=x1-x2;
X	y=y1-y2;
X	return (x*x + y*y);
X}
X#endif
X.
X334a
X			if (!rn2(4)) u_wipe_engr(rnd(3));
X.
X237c
X		read_engr_at(u.ux,u.uy);
X.
X72c
X#ifdef GRAPHICS
X	/* Set the default values of the presentation characters */
X	memcpy((char *) &showsyms, (char *) &defsyms, sizeof(struct symbols));
X#endif
X#ifdef HACKOPTIONS
X.
X1c
X/*	SCCS Id: @(#)unixmain.c	1.4	87/08/08
X.
Xw
Xq
XED_EOF
X
Xcp unixtty.c unixtty.c.orig
Xed unixtty.c <<ED_EOF
X331a
X
X#ifdef COM_COMPL
X/* Read in an extended command - doing command line completion for
X * when enough character have been entered to make a unique command.
X * This is just a modified getlin().   -jsb
X */
Xget_ext_cmd(bufp)
Xregister char *bufp;
X{
X	register char *obufp = bufp;
X	register int c;
X	int com_index, index;
X
X	flags.toplin = 2;		/* nonempty, no --More-- required */
X
X	for(;;) {
X		(void) fflush(stdout);
X		if((c = readchar()) == EOF) {
X			*bufp = 0;
X			return;
X		}
X		if(c == '\033') {
X			*obufp = c;
X			obufp[1] = 0;
X			return;
X		}
X		if(c == erase_char || c == '\b') {
X			if(bufp != obufp) {
X				bufp--;
X				putstr("\b \b"); /* putsym converts \b */
X			} else	bell();
X		} else if(c == '\n') {
X			*bufp = 0;
X			return;
X		} else if(' ' <= c && c < '\177') {
X				/* avoid isprint() - some people don't have it
X				   ' ' is not always a printing char */
X			*bufp = c;
X			bufp[1] = 0;
X			index = 0;
X			com_index = -1;
X
X			while(extcmdlist[index].ef_txt != (char *) 0){
X				if(!strncmp(obufp, extcmdlist[index].ef_txt,
X				strlen(obufp)))
X					if(com_index == -1) /* No matches yet*/
X					    com_index = index;
X					else /* More than 1 match */
X					    com_index = -2;
X				index++;
X			}
X			if(com_index >= 0){
X				strcpy(obufp,
X				extcmdlist[com_index].ef_txt);
X				/* finish print our string */
X				putstr(bufp);
X				bufp = obufp; /* reset it */
X				if(strlen(obufp) < BUFSIZ-1 &&
X				 strlen(obufp) < COLNO)
X					/* set bufp at the end of our
X					 * string
X					 */
X					bufp += strlen(obufp);
X			} else {
X				putstr(bufp);
X				if(bufp-obufp < BUFSZ-1 && bufp-obufp < COLNO)
X					bufp++;
X			}
X		} else if(c == kill_char || c == '\177') { /* Robert Viduya */
X				/* this test last - @ might be the kill_char */
X			while(bufp != obufp) {
X				bufp--;
X				putstr("\b \b");
X			}
X		} else
X			bell();
X	}
X
X}
X#endif COM_COMPL
X.
X9a
X#include	"func_tab.h"
X.
X1c
X/*	SCCS Id: @(#)unixtty.c	1.4	87/08/08
X.
Xw
Xq
XED_EOF
X
Xcp version.c version.c.orig
Xed version.c <<ED_EOF
X78a
X
X#endif
X.
X70,72c
X	pg_line("    Scott R. Turner    Tom Almy          John S. Bien");
X	pg_line("    Gil Neiger         Ralf Brown	  Eric S. Raymond");
X	pg_line("    Eric Backus        Roland McGrath    Greg Laskin");
X.
X29a
X#ifdef DGKMOD
X
X.
X1c
X/*	SCCS Id: @(#)version.c	1.4	87/08/08
X.
Xw
Xq
XED_EOF
X
Xcp wield.c wield.c.orig
Xed wield.c <<ED_EOF
X129c
X	return(obj && obj == uwep && obj->cursed &&
X.
X43c
X	else if (!uarmg && wep->otyp == DEAD_COCKATRICE) {
X.
X34,41d
X29c
X	else if(wep == &zeroobj) {
X	  if(uwep == 0){
X	    pline("You are already empty handed.");
X	  } else {
X	    setuwep((struct obj *) 0);
X	    res++;
X	    pline("You are empty handed.");
X	  }
X	} else if(uwep == wep)
X.
X1c
X/*	SCCS Id: @(#)wield.c	1.4	87/08/08
X.
Xw
Xq
XED_EOF
X
Xcp wizard.c wizard.c.orig
Xed wizard.c <<ED_EOF
X421,423c
X		if((mtmp = mkmon_at(nasties[rn2(nastynum)], u.ux, u.uy)))  {
X
X			mtmp->msleep = 0;
X			mtmp->mpeaceful = 0;
X		}
X.
X417c
X	nastynum = sizeof(nasties) - 1;
X.
X215c
X#endif /* KAA /**/
X.
X211c
X# endif /* KOPS /**/
X.
X71c
X	if(!carrying(AMULET_SYM)) {
X.
X1c
X/*	SCCS Id: @(#)wizard.c	1.4	87/08/08
X.
Xw
Xq
XED_EOF
X
Xcp write.c write.c.orig
Xed write.c <<ED_EOF
X22a
X# endif
X.
X20d
X1c
X/*	SCCS Id: @(#)write.c	1.4	87/08/08
X.
Xw
Xq
XED_EOF
X
Xcp you.h you.h.orig
Xed you.h <<ED_EOF
X44c
X#endif
X.
X1c
X/*	SCCS Id: @(#)you.h	1.4	87/08/08
X.
Xw
Xq
XED_EOF
X
Xcp zap.c zap.c.orig
Xed zap.c <<ED_EOF
X629c
X		(dx == dy) ? '\\' : (dx && dy) ? '/' : dx ? HWALL_SYM : VWALL_SYM;
X.
X347,348c
X		default: impossible("object %d used?",obj->otyp);
X	}
X.
X343,345c
X#ifdef SPELLS
X		case SPE_LIGHT:
X		    pline("You've blinded yourself!");
X		    Blind += rnd(100);
X		    break;		
X		case SPE_DIG:
X		case SPE_TURN_UNDEAD:
X		case SPE_DETECT_UNSEEN:
X#endif
X		case WAN_DIGGING:
X		case WAN_UNDEAD_TURNING:
X		case WAN_NOTHING:
X.
X340d
X337c
X		case WAN_DEATH:
X#ifdef SPELLS
X		case SPE_FINGER_OF_DEATH:
X#endif
X		    killer = "death ray";
X.
X334c
X		case WAN_TELEPORTATION:
X#ifdef SPELLS
X		case SPE_TELEPORT_AWAY:
X#endif
X.
X331c
X		case WAN_SLOW_MONSTER:
X#ifdef SPELLS
X		case SPE_SLOW_MONSTER:
X#endif
X.
X327a
X#ifdef SPELLS
X		case SPE_SLEEP:
X#endif
X.
X310c
X		case WAN_CANCELLATION:
X#ifdef SPELLS
X		case SPE_CANCELLATION:
X#endif
X.
X307a
X#ifdef SPELLS
X		case SPE_POLYMORPH:
X#endif
X.
X306c
X		case WAN_POLYMORPH:
X.
X304a
X#ifdef SPELLS
X		case SPE_MAGIC_MISSILE:
X#endif
X		    damage = d(4,6);
X		    pline("Idiot!  You've shot yourself!"); 
X.
X301,303c
X		case WAN_MAGIC_MISSILE:
X.
X299a
X#ifdef SPELLS
X		case SPE_CONE_OF_COLD:
X#endif
X		    pline("You imitate a popsicle!");
X		    if (!Cold_resistance) damage=d(12,6);
X.
X296,298c
X		case WAN_COLD:
X.
X292a
X#ifdef SPELLS
X		case SPE_FIREBALL:
X#endif
X		    pline("You've set light to yourself!");
X		    if (!Fire_resistance) damage=d(12,6);
X.
X289,291c
X		case WAN_FIRE:
X.
X287d
X284,285c
X	switch(obj->otyp) {
X		case WAN_STRIKING:
X#ifdef SPELLS
X		case SPE_FORCE_BOLT:
X#endif
X		    pline("You magically bash yourself!");
X.
X132a
X	        /* Amulets gets cheap   stewr 870807 */
X		if (obj->otyp == AMULET_OF_YENDOR) otmp2->spe = obj->spe;
X		/* Wands of wishing max 3 stewr 870808 */
X		if ((otmp2->otyp == WAN_WISHING) 
X		    && (obj->spe > 3)) otmp2->spe = 3;
X.
X1c
X/*	SCCS Id: @(#)zap.c	1.4	87/08/08
X.
Xw
Xq
XED_EOF
END_OF_update.patches
if test 43078 -ne `wc -c <update.patches`; then
    echo shar: \"update.patches\" unpacked with wrong size!
fi
# end of overwriting check
fi
echo shar: End of shell archive.
exit 0
