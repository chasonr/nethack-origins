Path: utzoo!utgpu!jarvis.csri.toronto.edu!mailrus!tut.cis.ohio-state.edu!gem.mps.ohio-state.edu!ginosko!uunet!zephyr.ens.tek.com!tektronix!tekgen!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v07i072:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Part17/38
Message-ID: <4325@tekred.CNA.TEK.COM>
Date: 24 Jul 89 05:05:03 GMT
Sender: nobody@tekred.CNA.TEK.COM
Lines: 2201
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 7, Issue 72
Archive-name: NetHack3/Part17



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 17 (of 38)."
# Contents:  include/extern.h include/you.h src/restore.c
# Wrapped by billr@saab on Sun Jul 23 21:33:00 1989
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'include/extern.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/extern.h'\"
else
echo shar: Extracting \"'include/extern.h'\" \(29514 characters\)
sed "s/^X//" >'include/extern.h' <<'END_OF_FILE'
X/*	SCCS Id: @(#)extern.h	3.0	88/10/18 */
X/* 	Copyright (c)   Steve Creps, 1988. 		 */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#ifndef EXTERN_H
X#define EXTERN_H
X
X#if defined(MSDOS) && !defined(__TURBOC__)
X/* MSC include files do not contain "extern" keyword */
X#define E
X#else
X#define E extern
X#endif
X
X/* ### alloc.c ### */
X
X#ifndef __TURBOC__
XE long *alloc P((unsigned int));
X#endif
X
X/* ### apply.c ### */
X
XE int doapply();
XE int holetime();
XE void dighole();
XE int dorub();
XE int dojump();
X#ifdef WALKIES
XE int number_leashed();
XE void o_unleash P((struct obj *));
XE void m_unleash P((struct monst *));
XE void unleash_all();
XE boolean next_to_u();
XE struct obj *get_mleash P((struct monst *));
XE void check_leash P((xchar,xchar));
X#endif
XE boolean um_dist P((xchar,xchar,xchar));
X
X/* ### artifact.c ### */
X
X#ifdef NAMED_ITEMS
XE void mkartifact P((struct obj **));
XE boolean is_artifact P((struct obj *));
XE boolean spec_ability P((struct obj *,unsigned));
XE int restr_name P((struct obj *,char *));
X# if defined(THEOLOGY) && defined(ALTARS)
XE struct obj *mk_aligned_artifact P((int));
X# endif
XE int defends P((int,struct obj *));
XE int spec_abon P((struct obj *,struct permonst *));
XE int spec_dbon P((struct obj *,struct permonst *,int));
X#endif
X
X/* ### attrib.c ### */
X
XE void adjattrib P((int,int,boolean));
XE void change_luck P((schar));
XE int stone_luck P((boolean));
XE void gainstr P((struct obj *,int));
XE void losestr P((int));
XE void restore_attrib();
XE void init_attr P((int));
X#ifdef POLYSELF
XE void redist_attr();
X#endif
XE void adjabil P((int));
XE int newhp();
XE schar acurr();
XE void adjalign P((int));
X
X/* ### bones.c ### */
X
XE void savebones();
XE int getbones();
XE void name_file P((char *,int));
X
X/* ### cmd.c ### */
X
XE void set_occupation P((int(*)(),char *,int));
X#ifdef REDO
XE char pgetchar();
XE void pushch P((char));
XE void savech P((char));
X#endif
XE char unctrl P((char));
XE void rhack P((char *));
XE char lowc P((char));
XE void enlightenment();
XE int xytod P((schar,schar));
XE void dtoxy P((coord *,int));
XE int movecmd P((char));
XE int getdir P((boolean));
XE void confdir();
XE int isok P((int,int));
XE int doextlist();
X
X/* ### dbridge.c ### */
X
XE boolean is_pool P((int,int));
X#ifdef STRONGHOLD
XE void initsym P((int,int));
XE int is_drawbridge_wall P((int, int));
XE boolean is_db_wall P((int, int));
XE boolean find_drawbridge P((int *, int*));
XE boolean create_drawbridge P((int, int, int, boolean));
XE void open_drawbridge P((int, int));
XE void close_drawbridge P((int, int));
XE void destroy_drawbridge P((int, int));
X#endif	/* STRONGHOLD /**/
X
X/* ### decl.c ### */
X
X/* ### demon.c ### */
X
XE void dsummon P((struct permonst *));
XE int demon_talk P((struct monst *));
XE long bribe P((struct monst *));
XE int dprince ();
XE int dlord ();
XE int ndemon ();
X
X/* ### do.c ### */
X
XE int dodrop();
XE boolean flooreffects P((struct obj *,int,int));
XE void doaltarobj P((struct obj *));
XE boolean canletgo P((struct obj *,char *));
XE void dropx P((struct obj *));
XE void dropy P((struct obj *));
XE int doddrop();
XE int dodown();
XE int doup();
XE void goto_level P((int,boolean));
XE int donull();
XE int dowipe();
XE struct obj *splitobj P((struct obj *,int));
XE void set_wounded_legs P((long,int));
XE void heal_legs();
X
X/* ### do_name.c ### */
X
XE void getpos P((coord *,int,char *));
XE int do_mname();
XE struct obj *oname P((struct obj *,char *,int));
XE int ddocall();
XE void docall P((struct obj *));
XE char *x_monnam P((struct monst *,int));
XE char *lmonnam P((struct monst *));
XE char *mon_nam P((struct monst *));
XE char *Monnam P((struct monst *));
XE char *a_monnam P((struct monst *,char *));
XE char *Amonnam P((struct monst *,char *));
XE char *Xmonnam P((struct monst *));
XE char *defmonnam P((struct monst *));
XE char *rndmonnam();
X#ifdef REINCARNATION
XE char *roguename();
X#endif
X
X/* ### do_wear.c ### */
X
XE void off_msg P((struct obj *));
XE boolean is_helmet P((struct obj *));
XE boolean is_gloves P((struct obj *));
XE boolean is_boots P((struct obj *));
XE boolean is_cloak P((struct obj *));
XE boolean is_shield P((struct obj *));
XE void set_wear();
XE int Armor_off();
XE int Armor_gone();
XE int Helmet_off();
XE int Gloves_off();
XE int Boots_off();
XE int Cloak_off();
XE int Shield_off();
XE void Amulet_off();
XE void Ring_on P((struct obj *));
XE void Ring_off P((struct obj *));
XE void Ring_gone P((struct obj *));
XE void Blindf_on P((struct obj *));
XE void Blindf_off P((struct obj *));
XE int dotakeoff();
XE int doremring();
XE int cursed P((struct obj *));
XE int armoroff P((struct obj *));
XE int dowear();
XE int doputon();
XE void find_ac();
XE void glibr();
XE struct obj *some_armor();
XE void corrode_armor();
XE int doddoremarm();
XE void adj_abon P((struct obj *,schar));
X
X/* ### dog.c ### */
X
XE void initedog P((struct monst *));
XE void make_familiar P((struct obj *));
XE struct monst *makedog();
XE void losedogs();
XE void keepdogs();
XE void fall_down P((struct monst *,int));
XE int dogfood P((struct monst *,struct obj *));
XE int inroom P((xchar,xchar));
XE int tamedog P((struct monst *,struct obj *));
X
X/* ### dogmove.c ### */
X
XE int dog_move P((struct monst *,int));
X
X/* ### dokick.c ### */
X
XE boolean ghitm P((struct monst *,long));
XE boolean bad_kick_throw_pos P((xchar,xchar));
XE struct monst *ghit P((int,int,int));
XE int dokick();
X
X/* ### dothrow.c ### */
X
XE int dothrow();
XE int throwit P((struct obj *));
XE int thitmonst P((struct monst *,struct obj *));
XE int breaks P((struct obj *,boolean));
X
X/* ### eat.c ### */
X
XE void init_uhunger();
XE int Hear_again();
XE int doeat();
XE void gethungry();
XE void morehungry P((int));
XE void lesshungry P((int));
XE void newuhs P((boolean));
XE void vomit();
XE struct obj *floorfood P((char *,int));
X
X/* ### end.c ### */
X
XE int done1();
XE int done2();
XE void done_in_by P((struct monst *));
XE void panic P((char *,...));
XE void done P((char *));
XE void clearlocks();
X#ifdef NOSAVEONHANGUP
XE void hangup();
X#endif
X
X/* ### engrave.c ### */
X
X#ifdef ELBERETH
XE int sengr_at P((char *,xchar,xchar));
X#endif
XE void u_wipe_engr P((int));
XE void wipe_engr_at P((xchar,xchar,xchar));
XE void read_engr_at P((int,int));
XE void make_engr_at P((int,int,char *));
XE int freehand();
XE int doengrave();
XE void save_engravings P((int));
XE void rest_engravings P((int));
X
X/* ### exper.c ### */
X
XE long newuexp P((unsigned));
XE int experience P((struct monst *,int));
XE void more_experienced P((int,int));
XE void losexp();
XE void newexplevel();
XE void pluslvl();
XE long rndexp();
X
X/* ### extralev.c ### */
X
X#ifdef REINCARNATION
XE void makeroguerooms();
XE void corr P((int,int));
XE void makerogueghost();
X#endif
X
X/* ### fountain.c ### */
X
X#ifdef FOUNTAINS
XE void dryup();
XE void drinkfountain();
XE void dipfountain P((struct obj *));
X#endif /* FOUNTAINS */
X#ifdef SINKS
XE void drinksink();
X#endif
X
X/* ### getline.c ### */
X
XE void getlin P((char *));
XE void getret();
XE void cgetret P((char *));
XE void xwaitforspace P((char *));
XE char *parse();
XE char readchar();
X#ifdef COM_COMPL
XE void get_ext_cmd P((char *));
X#endif /* COM_COMPL */
X
X/* ### hack.c ### */
X
XE void unsee();
XE void seeoff P((int));
XE void movobj P((struct obj *,xchar,xchar));
XE boolean may_dig P((xchar,xchar));
XE void domove();
XE void spoteffects();
XE int dopickup();
XE void lookaround();
XE int monster_nearby();
XE int cansee P((xchar,xchar));
XE int sgn P((int));
XE void getcorners
X	P((xchar *,xchar *,xchar *,xchar *,xchar *,xchar *,xchar *,xchar *));
XE void setsee();
XE void nomul P((int));
XE void losehp P((int,char *));
XE int weight_cap();
XE int inv_weight();
XE int inv_cnt();
XE int little_to_big P((int));
XE int big_to_little P((int));     
X#ifdef STUPID_CPP	/* otherwise these functions are macros in hack.h */
XE char yn();
XE char ynq();
XE char ynaq();
XE char nyaq();
XE char *plur P((long));
XE void makeknown P((unsigned));
X#endif
X
X/* ### invent.c ### */
X
XE struct obj *addinv P((struct obj *));
XE void useup P((struct obj *));
XE void freeinv P((struct obj *));
XE void delobj P((struct obj *));
XE void freeobj P((struct obj *));
XE void freegold P((struct gold *));
XE struct monst *m_at P((int,int));
XE struct obj *o_at P((int,int));
XE struct obj *sobj_at P((int,int,int));
XE int carried P((struct obj *));
XE struct obj *carrying P((int));
XE struct obj *o_on P((unsigned int,struct obj *));
XE struct gold *g_at P((int,int));
XE struct obj *getobj P((char *,char *));
XE int ggetobj P((char *,int(*)(),int));
XE int askchain P((struct obj *,int,char *,int,int(*)(),int(*)(),int,char *));
XE void prinv P((struct obj *));
XE int ddoinv();
XE void doinv P((char *));
XE int dotypeinv();
XE int dolook();
XE void stackobj P((struct obj *));
XE int doprgold();
XE int doprwep();
XE int doprarm();
XE int doprring();
XE int dopramulet();
XE int doprtool();
XE int digit P((char));
XE void useupf P((struct obj *));
XE char *let_to_name P((char));
XE void reassign();
X
X/* ### ioctl.c ### */
X
X#ifdef UNIX
XE void getioctls();
XE void setioctls();
X#ifdef SUSPEND
XE int dosuspend();
X#endif /* SUSPEND */
X#endif /* UNIX */
X
X/* ### lock.c ### */
X
XE int pick_lock P((struct obj *));
XE int doforce();
XE int boxlock P((struct obj *,struct obj *));
XE int doorlock P((struct obj *,int,int));
XE int doopen();
XE int doclose();
X
X/* ### makemon.c ### */
X
XE struct monst *makemon P((struct permonst *,int,int));
XE void enexto P((coord *,xchar,xchar));
XE int goodpos P((int,int));
XE void rloc P((struct monst *));
XE struct monst *mkmon_at P((char *,int,int));
XE void init_monstr();
XE struct permonst *rndmonst();
XE struct permonst *mkclass P((char));
XE int adj_lev P((struct permonst *));
XE struct permonst *grow_up P((struct monst *));
XE int mongets P((struct monst *,int));
X#ifdef REINCARNATION
XE struct permonst *roguemon();
X#endif
X#ifdef GOLEMS
XE int golemhp P((int));
X#endif /* GOLEMS */
XE boolean peace_minded P((struct permonst *));
XE void set_malign P((struct monst *));
XE void set_mimic_sym P((struct monst *));
X
X/* ### mcastu.c ### */
X
XE int castmu P((struct monst *,struct attack *));
XE int buzzmu P((struct monst *,struct attack *));
X
X/* ### mhitm.c ### */
X
XE int fightm P((struct monst *));
XE int mattackm P((struct monst *,struct monst *));
XE int noattacks P((struct permonst *));
X
X/* ### mhitu.c ### */
X
X#ifdef POLYSELF
XE boolean incompatible P((struct monst *));
XE struct monst *cloneu();
X#endif
XE boolean is_nymph P((struct monst *));
XE boolean sp_melee P((struct monst *));
XE int mattacku P((struct monst *));
XE void mdamageu P((struct monst *,int));
X#ifdef SEDUCE
XE void doseduce P((struct monst *));
X#endif
X
X/* ### mklev.c ### */
X
XE int somex P((struct mkroom *));
XE int somey P((struct mkroom *));
X#ifdef ORACLE
XE boolean place_oracle P((struct mkroom *,int *,int *,int *));
X#endif
XE void mklev();
XE int okdoor P((xchar,xchar));
XE void dodoor P((int,int,struct mkroom *));
XE void mktrap P((int,int,struct mkroom *));
XE void mkfount P((int,struct mkroom *));
X
X/* ### mkmaze.c ### */
X
X#if defined(WALLIFIED_MAZE) || defined(STRONGHOLD)
XE void wallification P((int,int,int,int,boolean));
X#endif
XE void walkfrom P((int,int));
XE void makemaz();
XE void move P((int *,int *,int));
XE void mazexy P((coord *));
XE void bound_digging();
X
X/* ### mkobj.c ### */
X
XE struct obj *mkobj_at P((char,int,int));
XE struct obj *mksobj_at P((int,int,int));
XE struct obj *mkobj P((char,boolean));
XE int rndmonnum();
XE struct obj *mksobj P((int,boolean));
XE int letter P((int));
XE int weight P((struct obj *));
XE void mkgold P((long,int,int));
XE struct obj *mkcorpse_at P((struct permonst *,int,int));
XE struct obj *mk_tt_corpse P((int,int));
XE struct obj *mkstatue P((struct permonst *,int,int));
XE struct obj *mk_named_object P((int, struct permonst *,int,int,char *,int));
X#ifdef MEDUSA
XE struct obj *mk_tt_statue P((int,int));
X#endif
XE void bless P((struct obj *));
XE void curse P((struct obj *));
XE void blessorcurse P((struct obj *,int));
XE boolean is_flammable P((struct obj *));
XE boolean is_rustprone P((struct obj *));
XE void set_omask P((xchar,xchar));
X
X/* ### mkroom.c ### */
X
XE void mkroom P((int));
XE void shrine_pos P((int *, int*, struct mkroom *));
XE boolean nexttodoor P((int,int));
XE boolean has_dnstairs P((struct mkroom *));
XE boolean has_upstairs P((struct mkroom *));
XE int dist2 P((int,int,int,int));
XE struct permonst *courtmon();
XE int bcsign P((struct obj *));
X
X/* ### mon.c ### */
X
XE void movemon();
XE void meatgold P((struct monst *));
XE void meatobj P((struct monst *));
XE void mpickgold P((struct monst *));
XE void mpickgems P((struct monst *));
XE int curr_mon_load P((struct monst *));
XE int max_mon_load P((struct monst *));
XE boolean can_carry P((struct monst *,struct obj *));
XE void mpickstuff P((struct monst *,char *));
XE int mfndpos P((struct monst *,coord *,long *,long));
XE int dist P((int,int));
XE void poisontell P((int));
XE void poisoned P((char *,int,char *));
XE void mondead P((struct monst *));
XE void replmon P((struct monst *,struct monst *));
XE void relmon P((struct monst *));
XE void monfree P((struct monst *));
XE void unstuck P((struct monst *));
XE void killed P((struct monst *));
XE void xkilled P((struct monst *,int));
XE void kludge P((char *,char *,...));
XE void rescham();
XE void restartcham();
XE int newcham P((struct monst *,struct permonst *));
XE void mnexto P((struct monst *));
XE void mnearto P((struct monst *, xchar, xchar, boolean));
XE void setmangry P((struct monst *));
XE int disturb P((struct monst *));
XE void mondied P((struct monst *));
XE void mongone P((struct monst *));
XE void monstone P((struct monst *));
X#ifdef GOLEMS
XE void golemeffects P((struct monst *, int, int));
X#endif /* GOLEMS */
X
X/* ### mondata.c ### */
X
XE boolean attacktype P((struct permonst *,int));
XE boolean resists_ston P((struct permonst *));
XE boolean resists_drli P((struct permonst *));
XE boolean ranged_attk P((struct permonst *));
XE boolean can_track P((struct permonst *));
X#ifdef POLYSELF
XE boolean breakarm P((struct permonst *));
XE boolean sliparm P((struct permonst *));
X#endif
XE boolean sticks P((struct permonst *));
XE boolean canseemon P((struct monst *));
XE boolean dmgtype P((struct permonst *,int));
XE int monsndx P((struct permonst *));
XE int name_to_mon P((char *));
X#ifdef POLYSELF
XE boolean webmaker P((struct permonst *));
X#endif
XE boolean is_female P((struct monst *));
XE int gender P((struct monst *));
XE boolean levl_follower P((struct monst *));
XE struct permonst *player_mon();
X
X/* ### monmove.c ### */
X
XE int dochugw P((struct monst *));
XE boolean onscary P((int,int,struct monst *));
XE int dochug P((struct monst *));
XE int m_move P((struct monst *,int));
XE void set_apparxy P((struct monst *));
XE boolean mdig_tunnel P((struct monst *));
X
X/* ### monst.c ### */
X
X/* ### msdos.c ### */
X
X#ifdef MSDOS
XE void flushout();
XE int tgetch();
XE int dosh();
XE long freediskspace P((char *));
XE long filesize P((char *));
XE void eraseall P((char *,char *));
XE void copybones P((int));
XE void playwoRAMdisk();
XE int saveDiskPrompt P((int));
XE void gameDiskPrompt();
XE void read_config_file();
XE void set_lock_and_bones();
XE void append_slash P((char *));
XE void getreturn P((char *));
XE void msmsg P((char *,...));
XE void chdrive P((char *));
XE void disable_ctrlP();
XE void enable_ctrlP();
XE FILE *fopenp P((char *,char *));
XE void msexit P((int));
X#endif /* MSDOS */
X
X/* ### mthrowu.c ### */
X
XE int thitu P((int,int,char *));
XE int thrwmu P((struct monst *));
XE int spitmu P((struct monst *));
XE int breamu P((struct monst *,struct attack *));
XE boolean linedup P((xchar,xchar,xchar,xchar));
XE boolean lined_up P((struct monst *));
XE struct obj *m_carrying P((struct monst *,int));
XE void m_useup P((struct monst *,struct obj *));
X
X/* ### music.c ### */
X
X#ifdef MUSIC
XE int do_play_instrument P((struct obj *));
X#endif /* MUSIC /**/
X
X/* ### o_init.c ### */
X
XE int letindex P((char));
XE void init_objects();
XE void oinit();
XE void savenames P((int));
XE void restnames P((int));
XE int dodiscovered();
X
X/* ### objnam.c ### */
X
XE char *typename P((int));
XE char *distant_name P((struct obj *, char *(*)(struct obj *)));
XE char *xname P((struct obj *));
XE char *doname P((struct obj *));
XE void setan P((char *,char *));
XE char *aobjnam P((struct obj *,char *));
XE char *Doname2 P((struct obj *));
XE void lcase P((char *));
XE char *makeplural P((char *));
XE struct obj *readobjnam P((char *));
XE boolean uses_known P((struct obj *));
X
X/* ### options.c ### */
X
XE void initoptions();
XE void parseoptions P((char *,boolean));
XE int doset();
XE int dotogglepickup();
XE void option_help();
XE int fruitadd P((char *));
X
X/* ### pager.c ### */
X
XE int dowhatis();
XE int dowhatdoes();
XE void set_whole_screen();
X#ifdef NEWS
XE int readnews();
X#endif /* NEWS */
XE void set_pager P((int));
XE int page_line P((char *));
XE void cornline P((int,char *));
XE int dohelp();
XE int dohistory();
XE int page_file P((char *,boolean));
X#ifdef UNIX
X#ifdef SHELL
XE int dosh();
X#endif /* SHELL */
XE int child P((int));
X#endif /* UNIX */
X
X/* ### pcmain.c ### */
X
X#ifdef MSDOS
XE int (*occupation)();
XE int (*afternmv)();
XE void askname();
XE void impossible P((char *,...));
X#ifdef CHDIR
XE void chdirx P((char *,char));
X#endif /* CHDIR */
XE void stop_occupation();
X#endif /* MSDOS */
X
X/* ### pctty.c ### */
X
X#ifdef MSDOS
XE void gettty();
XE void settty P((char *));
XE void error P((char *,...));
X#endif /* MSDOS */
X
X/* ### pcunix.c ### */
X
X#ifdef MSDOS
X#ifndef TOS
XE void setrandom();
XE int getyear();
XE char *getdate();
XE int phase_of_the_moon();
XE int night();
XE int midnight();
XE void gethdate P((char *));
XE int uptodate P((int));
X#endif /* TOS */
XE void regularize P((char *));
X#endif /* MSDOS */
X
X/* ### pickup.c ### */
X
XE void pickup P((int));
XE int doloot();
XE void get_all_from_box();
XE void use_container P((struct obj *, int));
XE void inc_cwt P((struct obj *, struct obj *));
XE void delete_contents P((struct obj *));
XE void dec_cwt P((struct obj *, struct obj *));
X
X/* ### polyself.c ### */
X
X#ifdef POLYSELF
XE void polyself();
XE int polymon P((int));
XE void rehumanize();
XE int dobreathe();
XE int dospit();
XE int doremove();
XE int dospinweb();
XE int dosummon();
XE int doconfuse();
XE int dohide();
X#endif
XE char *body_part P((int));
XE int poly_gender();
X#ifdef POLYSELF
X#ifdef GOLEMS
XE void ugolemeffects P((int, int));
X#endif /* GOLEMS */
X#endif
X
X/* ### potion.c ### */
X
XE void make_confused P((long,boolean));
XE void make_stunned P((long,boolean));
XE void make_blinded P((long,boolean));
XE void make_sick P((long,boolean));
XE void make_hallucinated P((long,boolean));
XE int dodrink();
XE int dopotion P((struct obj *));
XE int peffects P((struct obj *));
XE void healup P((int,int,boolean,boolean));
XE void strange_feeling P((struct obj *,char *));
XE void potionhit P((struct monst *,struct obj *));
XE void potionbreathe P((struct obj *));
XE int dodip();
XE void djinni_from_bottle P((struct obj *));
XE int monster_detect P((struct obj *));
XE int object_detect P((struct obj *));
X
X/* ### pray.c ### */
X
X# ifdef THEOLOGY
XE int dosacrifice();
XE int dopray();
XE char *u_gname();
X#endif
XE int doturn();
X#ifdef ALTARS
XE char *a_gname();
XE char *a_gname_at P((xchar,xchar));
X# ifdef THEOLOGY
XE void altar_wrath P((int,int));
X# endif
X#endif
X
X/* ### pri.c ### */
X
XE void swallowed();
XE void setclipped();
XE void at P((xchar,xchar,uchar,uchar));
XE void prme();
XE void shieldeff P((xchar,xchar));
XE int doredraw();
XE void docrt();
XE void docorner P((int,int));
XE void seeglds();
XE void seeobjs();
XE void seemons();
XE void pmon P((struct monst *));
XE void unpmon P((struct monst *));
XE void nscr();
XE void bot();
XE void mstatusline P((struct monst *));
XE void ustatusline();
XE void cls();
XE void max_rank_sz();
XE char rndmonsym();
XE char rndobjsym();
XE const char *hcolor();
X
X/* ### priest.c ### */
X
XE int move_special P((struct monst *,schar,schar,boolean,boolean,
X			xchar,xchar,xchar,xchar));
X#if defined(ALTARS) && defined(THEOLOGY)
XE struct mkroom *in_temple P((int,int));
XE int pri_move P((struct monst *));
XE void priestini P((int,int,int,int));
XE char *priestname P((struct monst *));
XE boolean p_coaligned P((struct monst *));
XE void intemple();
XE void priest_talk P((struct monst *));
XE boolean u_in_sanctuary P((struct mkroom *));
XE void ghod_hitsu();
XE void angry_priest();
X#endif
X
X/* ### prisym.c ### */
X
XE void atl P((int,int,char));
XE void on_scr P((int,int));
XE void tmp_at P((int,int));
XE void Tmp_at2 P((int,int));
XE void curs_on_u();
XE void pru();
XE void prl P((int,int));
XE uchar news0 P((xchar,xchar));
XE void newsym P((int,int));
XE void mnewsym P((int,int));
XE void nosee P((int,int));
XE void prl1 P((int,int));
XE void nose1 P((int,int));
XE int vism_at P((int,int));
X#ifdef NEWSCR
XE void pobj P((struct obj *));
X#endif /* NEWSCR */
XE void unpobj P((struct obj *));
X
X/* ### read.c ### */
X
XE int doread();
XE int seffects P((struct obj *));
XE int identify P((struct obj *));
XE void litroom P((boolean));
XE void do_genocide P((int));
XE void do_mapping();
XE void do_vicinity_map();
XE int destroy_arm P((struct obj *));
XE int trap_detect P((struct obj *));
XE int gold_detect P((struct obj *));
XE int food_detect P((struct obj *));
XE void punish P((struct obj *));
XE void unpunish();
XE boolean cant_create P((int *));
X#if defined(WIZARD) || defined(EXPLORE_MODE)
XE boolean create_particular();
X#endif
X
X/* ### restore.c ### */
X
XE int dorecover P((int));
XE void getlev P((int,int,xchar,boolean));
X#ifdef ZEROCOMP
XE void minit();
XE int mread P((int,genericptr_t,unsigned int));
X#else
XE void mread P((int,genericptr_t,unsigned int));
X#endif
X
X/* ### rip.c ### */
X
XE void outrip();
X
X/* ### rnd.c ### */
X
XE int rn1 P((int,int));
XE int rn2 P((int));
XE int rnl P((int));
XE int rnd P((int));
XE int d P((int,int));
XE int rne P((int));
X#ifdef THEOLOGY
XE int rnz P((int));
X#endif
X
X/* ### rumors.c ### */
X
XE void outrumor P((int,boolean));
X#ifdef ORACLE
XE int doconsult P((struct monst *));
X#endif
X
X/* ### save.c ### */
X
XE int dosave();
X#ifndef NOSAVEONHANGUP
XE int hangup();
X#endif /* NOSAVEONHANGUP */
XE int dosave0();
X#if defined(DGK) && !defined(TOS)
XE boolean savelev P((int,xchar,int));
XE boolean swapin_file P((int));
X#else /* DGK && !TOS */
XE void savelev P((int, xchar));
X#endif /* DGK && !TOS */
X#ifdef ZEROCOMP
XE void bflush P((int));
X#endif
XE void bwrite P((int,genericptr_t,unsigned int));
XE void savefruitchn P((int));
X
X/* ### search.c ### */
X
XE int findit();
XE int dosearch();
XE int dosearch0 P((int));
XE int doidtrap();
XE void wakeup P((struct monst *));
XE void seemimic P((struct monst *));
X
X/* ### shk.c ### */
X
XE char *shkname P((struct monst *));
XE void shkdead P((struct monst *));
XE void replshk P((struct monst *,struct monst *));
XE int inshop();
XE int inhishop P((struct monst *));
XE void obfree P((struct obj *,struct obj *));
XE int dopay();
XE void home_shk P((struct monst *));
XE void make_happy_shk P((struct monst *));
XE boolean paybill();
XE void pay_for_door P((int,int,char *));
XE void addtobill P((struct obj *,boolean));
XE void splitbill P((struct obj *,struct obj *));
XE void subfrombill P((struct obj *));
XE int doinvbill P((int));
XE int shkcatch P((struct obj *));
XE int shk_move P((struct monst *));
XE int online P((xchar,xchar));
XE boolean is_fshk P((struct monst *));
XE void shopdig P((int));
XE boolean in_shop P((int,int));
XE boolean costly_spot P((int,int));
XE void check_unpaid P((struct obj *));
X
X/* ### shknam.c ### */
X
XE void stock_room P((struct shclass *,struct mkroom *));
XE int saleable P((int,struct obj *));
XE int get_shop_item P((int));
X
X/* ### sit.c ### */
X
X#if defined(THRONES) || defined(SPELLS)
XE void take_gold();
X#endif
XE int dosit();
XE void rndcurse();
XE void attrcurse();
X
X/* ### sp_lev.c ### */
X
X#ifdef STRONGHOLD
XE boolean load_special P((char *));
X#endif /* STRONGHOLD /**/
X
X/* ### sounds.c ### */
X
XE void verbalize P((char *));
X#ifdef SOUNDS
XE void dosounds();
XE void growl P((struct monst *));
XE void yelp P((struct monst *));
XE void whimper P((struct monst *));
X#endif
XE int dotalk();
X
X/* ### spell.c ### */
X
X#ifdef SPELLS
XE int study_book P((struct obj *));
XE int docast();
XE int spelleffects P((int, boolean));
XE void losespells();
XE int dovspell();
X#endif /* SPELLS */
X
X/* ### steal.c ### */
X
XE long somegold();
XE void stealgold P((struct monst *));
XE int steal P((struct monst *));
XE void mpickobj P((struct monst *,struct obj *));
XE void stealamulet P((struct monst *));
XE void relobj P((struct monst *,int));
X
X/* ### termcap.c ### */
X
XE void startup();
XE void start_screen();
XE void end_screen();
XE void curs P((int,int));
XE void cmov P((int,int));
XE void xputc P((char));
XE void xputs P((char *));
XE void cl_end();
XE void clear_screen();
XE void home();
XE void standoutbeg();
XE void standoutend();
XE void revbeg();
X#if 0
XE void boldbeg();
XE void blinkbeg();
XE void dimbeg();
X#endif
XE void m_end();
XE void backsp();
XE void bell();
XE void graph_on();
XE void graph_off();
XE void delay_output();
XE void cl_eos();
X
X/* ### timeout.c ### */
X
XE void timeout();
XE void hatch_eggs();
X
X/* ### topl.c ### */
X
XE int doredotopl();
XE void remember_topl();
XE void addtopl P((char *));
XE void more();
XE void cmore P((char *));
XE void clrlin();
XE void pline P((const char *,...));
XE void You P((const char *,...));
XE void Your P((const char *,...));
XE void putsym P((char));
XE void putstr P((char *));
XE char yn_function P((char *,char));
X
X/* ### topten.c ### */
X
XE void topten();
XE char *eos P((char *));
XE void prscore P((int,char **));
XE struct obj *tt_oname P((struct obj *));
X
X/* ### track.c ### */
X
XE void initrack();
XE void settrack();
XE coord *gettrack P((int,int));
X
X/* ### trap.c ### */
X
XE boolean rust_dmg P((struct obj *,char *,int,boolean));
XE struct trap *maketrap P((int,int,int));
XE int teleok P((int,int));
XE void dotrap P((struct trap *));
XE int mintrap P((struct monst *));
XE void selftouch P((char *));
XE void float_up();
XE int float_down();
XE void tele();
XE void teleds P((int,int));
XE int dotele();
XE void placebc P((int));
XE void unplacebc();
XE void level_tele();
XE void drown();
X#ifdef SPELLS
XE void drain_en P((int));
X#endif
XE int dountrap();
XE void chest_trap P((struct obj *,int));
XE void wake_nearby();
XE void deltrap P((struct trap *));
XE struct trap *t_at P((int,int));
XE void b_trapped();
XE boolean unconscious();
X
X/* ### u_init.c ### */
X
XE void u_init();
XE void plnamesuffix();
X
X/* ### uhitm.c ### */
X
XE struct monst *clone_mon P((struct monst *));
XE boolean special_case P((struct monst *));
XE boolean attack P((struct monst *));
XE boolean hmon P((struct monst *,struct obj *,int));
X
X/* ### unixmain.c ### */
X
X#ifdef UNIX
XE int (*occupation)();
XE int (*afternmv)();
XE void glo P((int));
XE void askname();
XE void impossible P((char *,...));
XE void stop_occupation();
X#endif /* UNIX */
X
X/* ### unixtty.c ### */
X
X#ifdef UNIX
XE void gettty();
XE void settty P((char *));
XE void setftty();
XE void intron();
XE void introff();
XE void error P((char *, char *, char *));
X#endif /* UNIX */
X
X/* ### unixunix.c ### */
X
X#ifdef UNIX
XE void setrandom();
XE int getyear();
XE char *getdate();
XE int phase_of_the_moon();
XE int night();
XE int midnight();
XE void gethdate P((char *));
XE int uptodate P((int));
XE void getlock();
X#ifdef MAIL
XE void getmailstatus();
XE void ckmailstatus();
XE void readmail();
X#endif /* MAIL */
XE void regularize P((char *));
X#endif /* UNIX */
X
X/* ### vault.c ### */
X
XE void setgd();
XE void invault();
XE int gd_move();
XE void gddead();
XE void replgd P((struct monst *,struct monst *));
XE void paygd();
X
X/* ### version.c ### */
X
XE int doversion();
X
X/* ### weapon.c ### */
X
XE int hitval P((struct obj *,struct permonst *));
XE int dmgval P((struct obj *,struct permonst *));
XE void set_uasmon();
XE struct obj *select_rwep P((struct monst *));
XE struct obj *select_hwep P((struct monst *));
XE int abon();
XE int dbon();
X
X/* ### were.c ### */
X
XE void were_change P((struct monst *));
XE void new_were P((struct monst *));
XE boolean were_summon P((struct permonst *,boolean));
X#ifdef POLYSELF
XE void you_were();
X#endif /* POLYSELF */
X
X/* ### wield.c ### */
X
XE void setuwep P((struct obj *));
XE void uwepgone();
XE int dowield();
XE void corrode_weapon();
XE int chwepon P((struct obj *,int));
XE int welded P((struct obj *));
XE void weldmsg P((struct obj *,boolean));
X
X/* ### wizard.c ### */
X
XE void amulet();
XE int mon_has_amulet P((struct monst *));
XE int wiz_get_amulet P((struct monst *));
XE void aggravate();
XE void clonewiz();
X#ifdef HARD
XE void nasty();
XE void resurrect();
XE void intervene();
XE void wizdead P((struct monst *));
X#endif /* HARD */
XE void cuss P((struct monst *));
X
X/* ### worm.c ### */
X
X#ifdef WORM
XE int getwn P((struct monst *));
XE void initworm P((struct monst *));
XE void worm_move P((struct monst *));
XE void worm_nomove P((struct monst *));
XE void wormdead P((struct monst *));
XE void wormhit P((struct monst *));
XE void wormsee P((unsigned int));
XE void cutworm P((struct monst *,xchar,xchar,uchar));
X#endif /* WORM */
X
X/* ### worn.c ### */
X
XE void setworn P((struct obj *,long));
XE void setnotworn P((struct obj *));
X
X/* ### write.c ### */
X
XE void dowrite P((struct obj *));
X
X/* ### zap.c ### */
X
XE struct monst *revive P((struct obj *,boolean));
XE int zappable P((struct obj *));
XE void zapnodir P((struct obj *));
XE int dozap();
XE int zapyourself P((struct obj *));
XE void weffects P((struct obj *));
XE char *exclam P((int));
XE void hit P((char *,struct monst *,char *));
XE void miss P((char *,struct monst *));
XE struct monst *bhit P((int,int,int,char,int(*)(),int(*)(),struct obj *));
XE struct monst *boomhit P((int,int));
XE void buzz P((int,int,xchar,xchar,int,int));
XE void rloco P((struct obj *));
XE void fracture_rock P((struct obj *));
XE boolean break_statue P((struct obj *));
XE void destroy_item P((int,int));
XE int destroy_mitem P((struct monst *,int,int));
XE int resist P((struct monst *,char,int,int));
XE void makewish();
X
X#undef E
X
X#endif /* EXTERN_H /**/
END_OF_FILE
if test 29514 -ne `wc -c <'include/extern.h'`; then
    echo shar: \"'include/extern.h'\" unpacked with wrong size!
fi
# end of 'include/extern.h'
fi
if test -f 'include/you.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/you.h'\"
else
echo shar: Extracting \"'include/you.h'\" \(4384 characters\)
sed "s/^X//" >'include/you.h' <<'END_OF_FILE'
X/*	SCCS Id: @(#)you.h	3.0	88/04/25
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#ifndef YOU_H
X#define YOU_H
X
X#ifndef ATTRIB_H
X#include "attrib.h"
X#endif
X#ifndef MONST_H
X#include "monst.h"
X#endif
X#ifndef YOUPROP_H
X#include "youprop.h"
X#endif
X
Xstruct prop {
X
X#define	TIMEOUT		007777	/* mask */
X
X#define	LEFT_RING	W_RINGL	/* 010000L */
X#define	RIGHT_RING	W_RINGR	/* 020000L */
X#define	LEFT_SIDE	LEFT_RING
X#define	RIGHT_SIDE	RIGHT_RING
X#define	BOTH_SIDES	(LEFT_SIDE | RIGHT_SIDE)
X
X#define WORN_ARMOR	W_ARM	/* 040000L */
X#define WORN_CLOAK	W_ARMC	/* 0100000L */
X#define WORN_HELMET	W_ARMH	/* 0200000L */
X#define WORN_SHIELD	W_ARMS	/* 0400000L */
X#define WORN_GLOVES	W_ARMG	/* 01000000L */
X#define WORN_BOOTS	W_ARMF	/* 02000000L */
X#define	WORN_AMUL	W_AMUL	/* 04000000L */
X#define	WORN_BLINDF	W_TOOL	/* 010000000L */
X#ifdef SHIRT
X#define	WORN_SHIRT	W_ARMU	/* 020000000L */
X#endif
X#define	INTRINSIC	040000000L
X
X
X	long p_flgs;
X	int (*p_tofn)();	/* called after timeout */
X};
X
Xstruct you {
X	xchar ux, uy;
X	schar dx, dy, dz;	/* direction of move (or zap or ... ) */
X	schar di;		/* direction of FF */
X	xchar ux0, uy0;		/* initial position FF */
X	xchar udisx, udisy;	/* last display pos */
X	uchar usym;		/* usually '@' */
X	int last_str_turn;	/* 0: none, 1: half turn, 2: full turn */
X				/* +: turn right, -: turn left */
X	boolean umoved;		/* changed map location (post-move) */
X	unsigned udispl;	/* @ on display */
X	unsigned ulevel;	/* 1 - MAXULEV */
X	unsigned utrap;		/* trap timeout */
X	unsigned utraptype;	/* defined if utrap nonzero */
X#define	TT_BEARTRAP	0
X#define	TT_PIT		1
X#define	TT_WEB		2
X	unsigned uinshop;	/* used only in shk.c - (roomno+1) of shop */
X	int	 uhunger;	/* refd only in eat.c and shk.c */
X	unsigned uhs;		/* hunger state - see eat.c */
X
X	struct prop uprops[LAST_PROP+1];
X
X	unsigned umconf;
X	char *usick_cause;
X/* For messages referring to hands, eyes, feet, etc... when polymorphed */
X#define ARM 0
X#define EYE 1
X#define FACE 2
X#define FINGER 3
X#define FINGERTIP 4
X#define FOOT 5
X#define HAND 6
X#define HANDED 7
X#define HEAD 8
X#define LEG 9
X#define LIGHT_HEADED 10
X#define NECK 11
X#define TOE 12
X#ifdef POLYSELF
X	int mh, mhmax, mtimedone, umonnum;	/* for polymorph-self */
X	struct attribs	macurr,			/* for monster attribs */
X			mamax;			/* for monster attribs */
X	int ulycn;				/* lycanthrope type */
X#endif
X	unsigned ucreamed;
X	unsigned uswallow;		/* set if swallowed by a monster */
X	unsigned uswldtim;		/* time you have been swallowed */
X#ifdef POLYSELF
X	Bitfield(uundetected,1);	/* if you're a hiding monster/piercer */
X#endif
X#if defined(THEOLOGY) && defined(ELBERETH)
X	Bitfield(uhand_of_elbereth,1);	/* if you become Hand of Elbereth */
X#endif
X#ifdef MEDUSA
X	Bitfield(ukilled_medusa,1);	/* if you kill the medusa */
X#endif
X	Bitfield(uhave_amulet,1);	/* you're carrying the Amulet */
X#ifdef HARD
X	Bitfield(udemigod,1);		/* once you kill the wiz */
X	unsigned udg_cnt;		/* how long you have been demigod */
X#endif
X	struct	attribs	acurr,		/* your current attributes (eg. str) */
X			abon,		/* your bonus attributes (eg. str) */
X			amax,		/* your max attributes (eg. str) */
X			atemp,		/* used for temporary loss/gain */
X			atime;		/* used for loss/gain countdown */
X#define U_CHAOTIC      -1		/* the value range of ualigntyp */
X#define U_NEUTRAL	0
X#define U_LAWFUL	1
X	int 	ualign;			/* running alignment score */
X	schar 	ualigntyp;		/* basic character alignment */
X#ifdef THEOLOGY
X#define CONVERT 	2
X	schar   ualignbase[CONVERT];	/* for ualigntyp conversion record */
X#endif
X	schar uluck, moreluck;		/* luck and luck bonus */
X#define	LUCKADD		3	/* added value when carrying luck stone */
X#define Luck	(u.uluck + u.moreluck)
X#define	LUCKMAX		10	/* on moonlit nights 11 */
X#define	LUCKMIN		(-10)
X	schar	udaminc;
X	schar	uac;
X	int	uhp,uhpmax;
X#ifdef SPELLS
X	int	uen, uenmax;		/* magical energy - M. Stephenson */
X#endif
X#ifdef THEOLOGY
X	int ugangr;			/* if the gods are angry at you */
X	int ublessed, ublesscnt;	/* blessing/duration from #pray */
X#endif
X	long	ugold, ugold0;
X	long	uexp, urexp;
X#ifdef ALTARS
X	long 	ucleansed;	/* to record moves when player was cleansed */
X#endif
X	int uinvault;
X	struct monst *ustuck;
X	int ugrave_arise; /* you die and become something aside from a ghost */
X	int nr_killed[NUMMONS]; 	/* used for experience bookkeeping */
X};
X
X#endif /* YOU_H /**/
END_OF_FILE
if test 4384 -ne `wc -c <'include/you.h'`; then
    echo shar: \"'include/you.h'\" unpacked with wrong size!
fi
# end of 'include/you.h'
fi
if test -f 'src/restore.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/restore.c'\"
else
echo shar: Extracting \"'src/restore.c'\" \(18280 characters\)
sed "s/^X//" >'src/restore.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)restore.c	3.0	88/10/25
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include "hack.h"
X#include "lev.h"
X
X#ifdef WORM
X#include "wseg.h"
X#endif
X
Xboolean restoring = FALSE;
Xstatic struct fruit *oldfruit;
Xstatic long omoves;
X
X/*
X * "stuff" objects back into containers (relink the fcobj list).
X */
Xstatic void
Xstuff_objs(cobj)
Xregister struct obj *cobj;
X{
X	register struct obj *otmp, *otmp2;
X
X	for(; cobj; cobj = cobj->nobj)
X	    if(Is_container(cobj))
X
X		for(otmp = cobj->nobj;
X		    otmp && otmp->cobj == (struct obj *) -1; otmp = otmp2) {
X
X		    otmp2 = otmp->nobj;
X
X		    otmp->cobj = cobj;
X		    cobj->nobj = otmp2;
X		    otmp->nobj = fcobj;
X		    fcobj = otmp;
X		}
X}
X
Xstatic struct obj *
Xrestobjchn(fd, ghostly)
Xregister int fd;
Xboolean ghostly;
X{
X	register struct obj *otmp, *otmp2;
X	register struct obj *first = 0;
X	register struct fruit *oldf;
X	int xl;
X#ifdef LINT
X	/* suppress "used before set" warning from lint */
X	otmp2 = 0;
X#endif
X	while(1) {
X		mread(fd, (genericptr_t) &xl, sizeof(xl));
X		if(xl == -1) break;
X		otmp = newobj(xl);
X		if(!first) first = otmp;
X		else otmp2->nobj = otmp;
X		mread(fd, (genericptr_t) otmp, (unsigned) xl + sizeof(struct obj));
X		if(!otmp->o_id) otmp->o_id = flags.ident++;
X		if(ghostly && otmp->otyp == SLIME_MOLD) {
X			for(oldf=oldfruit; oldf; oldf=oldf->nextf)
X				if (oldf->fid == otmp->spe) break;
X			if(!oldf) impossible("no old fruit?");
X			else otmp->spe = fruitadd(oldf->fname);
X		}
X	/* Ghost levels get object age shifted from old player's clock to
X	 * new player's clock.  Assumption: new player arrived immediately
X	 * after old player died.
X	 */
X		if (ghostly) otmp->age = moves-omoves+otmp->age;
X		otmp2 = otmp;
X	}
X	if(first && otmp2->nobj){
X		impossible("Restobjchn: error reading objchn.");
X		otmp2->nobj = 0;
X	}
X
X	stuff_objs(first);
X	return(first);
X}
X
Xstatic struct monst *
Xrestmonchn(fd, ghostly)
Xregister int fd;
Xboolean ghostly;
X{
X	register struct monst *mtmp, *mtmp2;
X	register struct monst *first = 0;
X	int xl;
X
X	struct permonst *monbegin;
X	off_t differ;
X
X	mread(fd, (genericptr_t)&monbegin, sizeof(monbegin));
X#ifndef MSDOS
X	differ = (genericptr_t)(&mons[0]) - (genericptr_t)(monbegin);
X#else
X	differ = (long)(&mons[0]) - (long)(monbegin);
X#endif
X
X#ifdef LINT
X	/* suppress "used before set" warning from lint */
X	mtmp2 = 0;
X#endif
X	while(1) {
X		mread(fd, (genericptr_t) &xl, sizeof(xl));
X		if(xl == -1) break;
X		mtmp = newmonst(xl);
X		if(!first) first = mtmp;
X		else mtmp2->nmon = mtmp;
X		mread(fd, (genericptr_t) mtmp, (unsigned) xl + sizeof(struct monst));
X		if(!mtmp->m_id)
X			mtmp->m_id = flags.ident++;
X#ifndef MSDOS
X		/*ANSI type for differ is ptrdiff_t - long may be wrong*/
X		/*for segmented architecture - may be better to cast pointers*/
X		/*to (struct permonst *) rather than (genericptr_t)*/
X		/*this code handles save file -  so any bug should glow*/
X		/*probably best not to keep lint from complaining*/
X/*#ifdef LINT	/*possible compiler/hardware dependency - */
X/*		if (differ) mtmp->data = NULL;*/
X/*#else*/
X		mtmp->data = (struct permonst *)
X			((genericptr_t)mtmp->data + differ);
X/*#endif	/*LINT*/
X#else
X		mtmp->data = (struct permonst *)
X			((long) mtmp->data + differ);
X#endif
X		if(mtmp->minvent)
X			mtmp->minvent = restobjchn(fd, ghostly);
X		mtmp2 = mtmp;
X	}
X	if(first && mtmp2->nmon){
X		impossible("Restmonchn: error reading monchn.");
X		mtmp2->nmon = 0;
X	}
X	return(first);
X}
X
Xstatic void
Xrestgenoinfo(fd)
Xregister int fd;
X{
X	register int i;
X
X	for (i = 0; i < NUMMONS; i++)
X		mread(fd, (genericptr_t) &(mons[i].geno), sizeof(unsigned));
X}
X
Xint
Xdorecover(fd)
Xregister int fd;
X{
X	register int nfd;
X	int tmp;		/* not a register ! */
X	xchar ltmp;
X	unsigned int mid;		/* idem */
X	struct obj *otmp;
X	struct fruit *fruit;
X#ifdef MSDOS
X	struct flag oldflags;
X
X	oldflags = flags;	/* Save flags set in the config file */
X#endif
X#ifdef ZEROCOMP
X	minit();
X#endif
X	restoring = TRUE;
X	getlev(fd, 0, (xchar)0, FALSE);
X	invent = restobjchn(fd, FALSE);
X	for(otmp = invent; otmp; otmp = otmp->nobj)
X		if(otmp->owornmask)
X			setworn(otmp, otmp->owornmask);
X	fallen_down = restmonchn(fd, FALSE);
X	restgenoinfo(fd);
X	mread(fd, (genericptr_t) &tmp, sizeof tmp);
X#ifdef WIZARD
X	if(!wizard)
X#endif
X	    if(tmp != getuid()) {		/* strange ... */
X		(void) close(fd);
X		(void) unlink(SAVEF);
X		(void) puts("Saved game was not yours.");
X		restoring = FALSE;
X		return(0);
X	    }
X	mread(fd, (genericptr_t) &flags, sizeof(struct flag));
X	/* Some config file OPTIONS take precedence over those in save file.
X	 */
X#ifdef MSDOS
X#ifdef DGK
X	flags.rawio = oldflags.rawio;
X#ifdef DECRAINBOW
X	flags.DECRainbow = oldflags.DECRainbow;
X#endif /* DECRAINBOW */
X	flags.IBMBIOS = oldflags.IBMBIOS;
X#endif
X#endif
X	mread(fd, (genericptr_t) &dlevel, sizeof dlevel);
X	mread(fd, (genericptr_t) &maxdlevel, sizeof maxdlevel);
X	mread(fd, (genericptr_t) &moves, sizeof moves);
X	mread(fd, (genericptr_t) &wiz_level, sizeof wiz_level);
X	mread(fd, (genericptr_t) &medusa_level, sizeof medusa_level);
X#ifdef ORACLE
X	mread(fd, (genericptr_t) &oracle_level, sizeof oracle_level);
X#endif
X#ifdef REINCARNATION
X	mread(fd, (genericptr_t) &rogue_level, sizeof rogue_level);
X	if (dlevel==rogue_level)
X		savesyms = showsyms;
X#endif
X#ifdef STRONGHOLD
X	mread(fd, (genericptr_t) &stronghold_level, sizeof stronghold_level);
X	mread(fd, (genericptr_t) &tower_level, sizeof tower_level);
X	mread(fd, (genericptr_t) tune, sizeof tune);
X#  ifdef MUSIC
X	mread(fd, (genericptr_t) &music_heard, sizeof music_heard);
X#  endif
X#endif
X	mread(fd, (genericptr_t) &is_maze_lev, sizeof is_maze_lev);
X	mread(fd, (genericptr_t) &u, sizeof(struct you));
X#ifdef SPELLS
X	mread(fd, (genericptr_t) spl_book, sizeof(struct spell) * (MAXSPELL + 1));
X#endif
X	if(u.ustuck)
X		mread(fd, (genericptr_t) &mid, sizeof mid);
X	mread(fd, (genericptr_t) pl_character, sizeof pl_character);
X	mread(fd, (genericptr_t) pl_fruit, sizeof pl_fruit);
X	mread(fd, (genericptr_t) &current_fruit, sizeof current_fruit);
X	ffruit = 0;
X	while (fruit = newfruit(),
X	       mread(fd, (genericptr_t)fruit, sizeof(struct fruit)),
X	       fruit->fid) {
X		fruit->nextf = ffruit;
X		ffruit = fruit;
X	}
X	free((genericptr_t) fruit);
X
X	restnames(fd);
X#ifdef DGK
X	msmsg("\n");
X	cl_end();
X	msmsg("You got as far as level %d%s.\n", maxdlevel,
X		flags.debug ? " in WIZARD mode" :
X		flags.explore ? " in discovery mode" : "");
X	cl_end();
X	msmsg("Restoring: ");
X#endif
X	while(1) {
X#ifdef ZEROCOMP
X		if(mread(fd, (genericptr_t) &ltmp, sizeof ltmp) < 0)
X#else
X		if(read(fd, (genericptr_t) &ltmp, sizeof ltmp) != sizeof ltmp)
X#endif
X			break;
X		getlev(fd, 0, ltmp, FALSE);
X		glo(ltmp);
X#ifdef DGK
X		msmsg(".");
X#endif
X#if defined(MSDOS) && !defined(TOS)
X		nfd = open(lock, O_WRONLY | O_BINARY | O_CREAT | O_TRUNC, FCMASK);
X#else
X		nfd = creat(lock, FCMASK);
X#endif
X		if (nfd < 0)	panic("Cannot open temp file %s!\n", lock);
X#if defined(DGK) && !defined(TOS)
X		if (!savelev(nfd, ltmp, COUNT | WRITE)) {
X
X			/* The savelev can't proceed because the size required
X			 * is greater than the available disk space.
X			 */
X			msmsg("\nNot enough space on `%s' to restore your game.\n",
X				levels);
X
X			/* Remove levels and bones that may have been created.
X			 */
X			(void) close(nfd);
X			eraseall(levels, alllevels);
X			eraseall(levels, allbones);
X
X			/* Perhaps the person would like to play without a
X			 * RAMdisk.
X			 */
X			if (ramdisk) {
X				/* PlaywoRAMdisk may not return, but if it does
X				 * it is certain that ramdisk will be 0.
X				 */
X				playwoRAMdisk();
X				/* Rewind save file and try again */
X				(void) lseek(fd, (off_t)0, 0);
X				return dorecover(fd);
X			} else {
X				msmsg("Be seeing you...\n");
X				exit(0);
X			}
X		}
X#else
X		savelev(nfd, ltmp);
X#endif
X#ifdef ZEROCOMP
X		bflush(nfd);
X#endif
X		(void) close(nfd);
X	}
X#ifdef BSD
X	(void) lseek(fd, 0L, 0);
X#else
X	(void) lseek(fd, (off_t)0, 0);
X#endif
X#ifdef ZEROCOMP
X	minit();
X#endif
X	getlev(fd, 0, (xchar)0, FALSE);
X	(void) close(fd);
X#ifdef EXPLORE_MODE
X	if(!discover)
X#endif
X		(void) unlink(SAVEF);
X#ifdef REINCARNATION
X	/* this can't be done earlier because we need to check the initial
X	 * showsyms against the one saved in each of the non-rogue levels */
X	if (dlevel==rogue_level)
X		showsyms = defsyms;
X#endif
X	if(u.ustuck) {
X		register struct monst *mtmp;
X
X		for(mtmp = fmon; mtmp; mtmp = mtmp->nmon)
X			if(mtmp->m_id == mid) goto monfnd;
X		panic("Cannot find the monster ustuck.");
X	monfnd:
X		u.ustuck = mtmp;
X	}
X	setsee();  /* only to recompute seelx etc. - these weren't saved */
X#ifdef DGK
X	gameDiskPrompt();
X#endif
X	max_rank_sz(); /* to recompute mrank_sz (pri.c) */
X#ifdef POLYSELF
X	set_uasmon();
X#endif
X	/* take care of iron ball & chain */
X	for(otmp = fobj; otmp; otmp = otmp->nobj)
X		if(otmp->owornmask)
X			setworn(otmp, otmp->owornmask);
X	docrt();
X	restoring = FALSE;
X	return(1);
X}
X
Xvoid
Xgetlev(fd, pid, lev, ghostly)
Xint fd, pid;
Xxchar lev;
Xboolean ghostly;
X{
X	register struct gold *gold;
X	register struct trap *trap;
X#ifdef WORM
X	register struct wseg *wtmp;
X	register int tmp;
X#endif
X	long nhp;
X	int hpid;
X	xchar dlvl;
X	struct symbols osymbol;
X	int x, y;
X	uchar osym, nsym;
X#ifdef TOS
X	short tlev;
X#endif
X
X#ifdef MSDOS
X	setmode(fd, O_BINARY);	    /* is this required for TOS??? */
X#endif
X	/* Load the old fruit info.  We have to do it first, so the infor-
X	 * mation is available when restoring the objects.  
X	 */
X	if (ghostly) {
X		struct fruit *fruit;
X
X		oldfruit = 0;
X		while (fruit = newfruit(),
X		       mread(fd, (genericptr_t)fruit, sizeof(struct fruit)),
X		       fruit->fid) {
X			fruit->nextf = oldfruit;
X			oldfruit = fruit;
X		}
X		free((genericptr_t) fruit);
X	}
X
X	/* First some sanity checks */
X	mread(fd, (genericptr_t) &hpid, sizeof(hpid));
X#ifdef TOS
X	mread(fd, (genericptr_t) &tlev, sizeof(tlev));
X	dlvl=tlev&0xff;
X#else
X	mread(fd, (genericptr_t) &dlvl, sizeof(dlvl));
X#endif
X	if((pid && pid != hpid) || (lev && dlvl != lev)) {
X		pline("Strange, this map is not as I remember it.");
X		pline("Somebody is trying some trickery here...");
X		pline("This game is void.");
X		done("tricked");
X	}
X
X	mread(fd, (genericptr_t) levl, sizeof(levl));
X	mread(fd, (genericptr_t) &osymbol, sizeof(osymbol));
X	if (memcmp((genericptr_t) &osymbol,
X		   (genericptr_t) &showsyms, sizeof (struct symbols))
X#ifdef REINCARNATION
X		&& dlvl != rogue_level
X		/* rogue level always uses default syms, and showsyms will still
X		 * have its initial value from environment when restoring a
X		 * game */
X#endif
X	    ) {
X		for (x = 0; x < COLNO; x++)
X			for (y = 0; y < ROWNO; y++) {
X				osym = levl[x][y].scrsym;
X				nsym = 0;
X				switch (levl[x][y].typ) {
X				case STONE:
X				case SCORR:
X					if (osym == osymbol.stone)
X						nsym = showsyms.stone;
X					break;
X				case ROOM:
X#ifdef STRONGHOLD
X				case DRAWBRIDGE_DOWN:
X#endif /* STRONGHOLD /**/
X					if (osym == osymbol.room)
X						nsym = showsyms.room;
X					break;
X				case DOOR:
X					if (osym == osymbol.door)
X						nsym = showsyms.door;
X					break;
X				case CORR:
X					if (osym == osymbol.corr)
X						nsym = showsyms.corr;
X					break;
X				case VWALL:
X					if (osym == osymbol.vwall)
X						nsym = showsyms.vwall;
X#ifdef STRONGHOLD
X					else if (osym == osymbol.dbvwall)
X						nsym = showsyms.dbvwall;
X#endif
X					break;
X				case HWALL:
X					if (osym == osymbol.hwall)
X						nsym = showsyms.hwall;
X#ifdef STRONGHOLD
X					else if (osym == osymbol.dbhwall)
X						nsym = showsyms.dbhwall;
X#endif
X					break;
X				case TLCORNER:
X					if (osym == osymbol.tlcorn)
X						nsym = showsyms.tlcorn;
X					break;
X				case TRCORNER:
X					if (osym == osymbol.trcorn)
X						nsym = showsyms.trcorn;
X					break;
X				case BLCORNER:
X					if (osym == osymbol.blcorn)
X						nsym = showsyms.blcorn;
X					break;
X				case BRCORNER:
X					if (osym == osymbol.brcorn)
X						nsym = showsyms.brcorn;
X					break;
X				case SDOOR:
X					if (osym == osymbol.vwall)
X						nsym = showsyms.vwall;
X					else if (osym == osymbol.hwall)
X						nsym = showsyms.hwall;
X					break;
X				case CROSSWALL:
X					if (osym == osymbol.crwall)
X						nsym = showsyms.crwall;
X					break;
X				case TUWALL:
X					if (osym == osymbol.tuwall)
X						nsym = showsyms.tuwall;
X					break;
X				case TDWALL:
X					if (osym == osymbol.tdwall)
X						nsym = showsyms.tdwall;
X					break;
X				case TLWALL:
X					if (osym == osymbol.tlwall)
X						nsym = showsyms.tlwall;
X					break;
X				case TRWALL:
X					if (osym == osymbol.trwall)
X						nsym = showsyms.trwall;
X					break;
X				case STAIRS:
X					if (osym == osymbol.upstair)
X						nsym = showsyms.upstair;
X					else if (osym == osymbol.dnstair)
X						nsym = showsyms.dnstair;
X					break;
X#ifdef STRONGHOLD
X				case LADDER:
X					if (osym == osymbol.upladder)
X						nsym = showsyms.upladder;
X					else if (osym == osymbol.dnladder)
X						nsym = showsyms.dnladder;
X					break;
X#endif /* STRONGHOLD /**/
X				case POOL:
X				case MOAT:
X#ifdef STRONGHOLD
X				case DRAWBRIDGE_UP:
X#endif /* STRONGHOLD /**/
X					if (osym == osymbol.pool)
X						nsym = showsyms.pool;
X					break;
X#ifdef FOUNTAINS
X				case FOUNTAIN:
X					if (osym == osymbol.fountain)
X						nsym = showsyms.fountain;
X					break;
X#endif /* FOUNTAINS /**/
X#ifdef THRONES
X				case THRONE:
X					if (osym == osymbol.throne)
X						nsym = showsyms.throne;
X					break;
X#endif /* THRONES /**/
X#ifdef SINKS
X				case SINK:
X					if (osym == osymbol.sink)
X						nsym = showsyms.sink;
X					break;
X#endif /* SINKS /**/
X#ifdef ALTARS
X				case ALTAR:
X					if (osym == osymbol.altar)
X						nsym = showsyms.altar;
X					break;
X#endif /* ALTARS /**/
X				default:
X					break;
X				}
X				if (nsym)
X					levl[x][y].scrsym = nsym;
X			}
X	}
X
X	mread(fd, (genericptr_t)&omoves, sizeof(omoves));
X	mread(fd, (genericptr_t)&xupstair, sizeof(xupstair));
X	mread(fd, (genericptr_t)&yupstair, sizeof(yupstair));
X	mread(fd, (genericptr_t)&xdnstair, sizeof(xdnstair));
X	mread(fd, (genericptr_t)&ydnstair, sizeof(ydnstair));
X#ifdef STRONGHOLD
X	mread(fd, (genericptr_t)&xupladder, sizeof(xupladder));
X	mread(fd, (genericptr_t)&yupladder, sizeof(yupladder));
X	mread(fd, (genericptr_t)&xdnladder, sizeof(xdnladder));
X	mread(fd, (genericptr_t)&ydnladder, sizeof(ydnladder));
X#endif
X	mread(fd, (genericptr_t)&fountsound, sizeof(fountsound));
X	mread(fd, (genericptr_t)&sinksound, sizeof(sinksound));
X	fmon = restmonchn(fd, ghostly);
X
X	/* regenerate animals while on another level */
X	{ long tmoves = (moves > omoves) ? moves-omoves : 0;
X	  register struct monst *mtmp, *mtmp2;
X
X	  for(mtmp = fmon; mtmp; mtmp = mtmp2) {
X
X		mtmp2 = mtmp->nmon;
X		if(mtmp->data->geno & G_GENOD) {
X			mondead(mtmp);
X			continue;
X		}
X
X		if (ghostly) {
X			/* reset peaceful/malign relative to new character */
X			if(!mtmp->isshk)
X				/* shopkeepers will reset based on name */
X				mtmp->mpeaceful = peace_minded(mtmp->data);
X			set_malign(mtmp);
X		} else if (mtmp->mtame && tmoves > 250)
X		  	mtmp->mtame = mtmp->mpeaceful = 0;
X
X		/* restore shape changers - Maarten Jan Huisjes */
X		if (mtmp->data == &mons[PM_CHAMELEON]
X		    && !Protection_from_shape_changers
X		    && !mtmp->cham)
X			mtmp->cham = 1;
X		else if(Protection_from_shape_changers) {
X			if (mtmp->cham) {
X				mtmp->cham = 0;
X				(void) newcham(mtmp, &mons[PM_CHAMELEON]);
X			} else if(is_were(mtmp->data) && !is_human(mtmp->data))
X				(void) new_were(mtmp);
X		}
X
X		if (!ghostly) {
X			nhp = mtmp->mhp +
X				(regenerates(mtmp->data) ? tmoves : tmoves/20);
X			if(nhp > mtmp->mhpmax)
X				mtmp->mhp = mtmp->mhpmax;
X			else
X#ifdef LINT	/* (long)newhp -> (schar = short int) mhp; ok in context of text above */
X				mtmp->mhp = 0;
X#else
X				mtmp->mhp = nhp;
X#endif
X		}
X	  }
X	}
X
X	setgd();
X	fgold = 0;
X	while(gold = newgold(),
X	      mread(fd, (genericptr_t)gold, sizeof(struct gold)),
X	      gold->gx) {
X		gold->ngold = fgold;
X		fgold = gold;
X	}
X	free((genericptr_t) gold);
X	ftrap = 0;
X	while (trap = newtrap(),
X	       mread(fd, (genericptr_t)trap, sizeof(struct trap)),
X	       trap->tx) {
X		trap->ntrap = ftrap;
X		ftrap = trap;
X	}
X	free((genericptr_t) trap);
X	fobj = restobjchn(fd, ghostly);
X	billobjs = restobjchn(fd, ghostly);
X	rest_engravings(fd);
X	mread(fd, (genericptr_t)rooms, sizeof(rooms));
X	mread(fd, (genericptr_t)doors, sizeof(doors));
X#ifdef WORM
X	mread(fd, (genericptr_t)wsegs, sizeof(wsegs));
X	for(tmp = 1; tmp < 32; tmp++) if(wsegs[tmp]){
X		wheads[tmp] = wsegs[tmp] = wtmp = newseg();
X		while(1) {
X			mread(fd, (genericptr_t)wtmp, sizeof(struct wseg));
X			if(!wtmp->nseg) break;
X			wheads[tmp]->nseg = wtmp = newseg();
X			wheads[tmp] = wtmp;
X		}
X	}
X	mread(fd, (genericptr_t)wgrowtime, sizeof(wgrowtime));
X#endif
X	/* Now get rid of all the temp fruits... */
X	if (ghostly) {
X		struct fruit *fruit;
X
X		while(oldfruit) {
X			fruit = oldfruit->nextf;
X			free((genericptr_t) oldfruit);
X			oldfruit = fruit;
X		}
X	}
X}
X
X#ifdef ZEROCOMP
X#define RLESC '\0' 	/* Leading character for run of RLESC's */
X
Xstatic unsigned char inbuf[BUFSZ];
Xstatic unsigned short inbufp = 0;
Xstatic unsigned short inbufsz = 0;
Xstatic short inrunlength = -1;
Xstatic int mreadfd;
X
Xstatic int
Xmgetc()
X{
X    if (inbufp >= inbufsz) {
X      inbufsz = read(mreadfd, (genericptr_t)inbuf, (int)sizeof inbuf);
X      if (!inbufsz) {
X	  if (inbufp > sizeof inbuf)
X	      error("EOF on file #%d.\n", mreadfd);
X	  inbufp = 1 + sizeof inbuf;  /* exactly one warning :-) */
X	  return -1;
X      }
X      inbufp = 0;
X    }
X    return inbuf[inbufp++];
X}
X
Xvoid
Xminit()
X{
X    inbufsz = 0;
X    inbufp = 0;
X    inrunlength = -1;
X}
X
Xint
Xmread(fd, buf, len)
Xint fd;
Xregister genericptr_t buf;
Xregister unsigned len;
X{
X    /*register int readlen = 0;*/
X    mreadfd = fd;
X    while (len--) {
X      if (inrunlength > 0) {
X	  inrunlength--;
X	  *((char *)buf)++ = '\0';
X      } else {
X	  register short ch = mgetc();
X	  if (ch < 0) return -1; /*readlen;*/
X	  if ((*((char *)buf)++ = ch) == RLESC) {
X	      inrunlength = mgetc();
X	  }
X      }
X      /*readlen++;*/
X    }
X    return 0; /*readlen;*/
X}
X
X#else /* ZEROCOMP */
X
Xvoid
Xmread(fd, buf, len)
Xregister int fd;
Xregister genericptr_t buf;
Xregister unsigned int len;
X{
X	register int rlen;
X
X#if defined(BSD) || defined(ULTRIX)
X	rlen = read(fd, buf, (int) len);
X	if(rlen != len){
X#else /* e.g. SYSV, __TURBOC__ */
X	rlen = read(fd, buf, (unsigned) len);
X	if((unsigned)rlen != len){
X#endif
X		pline("Read %d instead of %u bytes.\n", rlen, len);
X		if(restoring) {
X			(void) unlink(SAVEF);
X			error("Error restoring old game.");
X		}
X		panic("Error reading level file.");
X	}
X}
X#endif /* ZEROCOMP */
END_OF_FILE
if test 18280 -ne `wc -c <'src/restore.c'`; then
    echo shar: \"'src/restore.c'\" unpacked with wrong size!
fi
# end of 'src/restore.c'
fi
echo shar: End of archive 17 \(of 38\).
cp /dev/null ark17isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 38 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
