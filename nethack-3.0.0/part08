Path: utzoo!utgpu!jarvis.csri.toronto.edu!mailrus!csd4.milw.wisc.edu!cs.utexas.edu!uunet!zephyr.ens.tek.com!tektronix!tekgen!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v07i063:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Part08/38
Message-ID: <4316@tekred.CNA.TEK.COM>
Date: 24 Jul 89 05:00:54 GMT
Sender: nobody@tekred.CNA.TEK.COM
Lines: 1454
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 7, Issue 63
Archive-name: NetHack3/Part08



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 8 (of 38)."
# Contents:  src/monst.c2 src/save.c
# Wrapped by billr@saab on Sun Jul 23 21:32:51 1989
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'src/monst.c2' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/monst.c2'\"
else
echo shar: Extracting \"'src/monst.c2'\" \(35010 characters\)
sed "s/^X//" >'src/monst.c2' <<'END_OF_FILE'
X/*	Leprechauns	*/
X	{ "leprechaun", S_LEPRECHAUN, 5, 15, 8, 20, 0, (G_GENO | 4),
X	  { { AT_CLAW, AD_PHYS, 1, 2 }, { AT_CLAW, AD_SGLD, 0, 0 },
X	    NO_ATTK, NO_ATTK, NO_ATTK },
X	  30, 300, 0, MS_LAUGH, M1_HUMANOID | M1_TPORT | M1_GREEDY,
X	  M2_HOSTILE },
X/* 	Mummies		*/
X	{ "kobold mummy", S_MUMMY, 3, 8, 6, 20, -2, (G_GENO | G_NOCORPSE | 1),
X	  { { AT_CLAW, AD_PHYS, 1, 4 }, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X	  10, 20, 0, MS_SILENT,
X	  M1_HUMANOID | M1_UNDEAD | M1_POIS, M2_HOSTILE },
X	{ "gnome mummy", S_MUMMY, 4, 10, 6, 20, -3, (G_GENO | G_NOCORPSE | 1),
X	  { { AT_CLAW, AD_PHYS, 1, 6 }, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X	  20, 25, 0, MS_SILENT,
X	  M1_HUMANOID | M1_UNDEAD | M1_POIS, M2_HOSTILE },
X	{ "orc mummy", S_MUMMY, 5, 10, 5, 20, -4, (G_GENO | G_NOCORPSE | 1),
X	  { { AT_CLAW, AD_PHYS, 1, 6 }, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X	  30, 30, 0, MS_SILENT, M1_HUMANOID | M1_UNDEAD | M1_POIS |
X	  M1_GREEDY | M1_JEWELS, M2_HOSTILE | M2_ORC },
X	{ "elf mummy", S_MUMMY, 6, 12, 4, 30, -5, (G_GENO | G_NOCORPSE | 1),
X	  { { AT_CLAW, AD_PHYS, 2, 4 }, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X	  35, 35, 0, MS_SILENT, M1_HUMANOID | M1_UNDEAD | M1_POIS | M1_SLEE_RES,
X	  M2_HOSTILE | M2_ELF },
X	{ "human mummy", S_MUMMY, 6, 12, 4, 30, -5, (G_GENO | G_NOCORPSE | 1),
X	  { { AT_CLAW, AD_PHYS, 2, 4 }, { AT_CLAW, AD_PHYS, 2, 4 },
X	    NO_ATTK, NO_ATTK, NO_ATTK },
X	  40, 40, 0, MS_SILENT,
X	  M1_HUMANOID | M1_UNDEAD | M1_POIS, M2_HOSTILE },
X	{ "ettin mummy", S_MUMMY, 7, 12, 4, 30, -6, (G_GENO | G_NOCORPSE | 1),
X	  { { AT_CLAW, AD_PHYS, 2, 6 }, { AT_CLAW, AD_PHYS, 2, 6 },
X	    NO_ATTK, NO_ATTK, NO_ATTK }, 70, 50, 0, MS_SILENT,
X	  M1_HUMANOID | M1_UNDEAD | M1_POIS | M1_BIG,
X	  M2_HOSTILE | M2_STRONG },
X	{ "giant mummy", S_MUMMY, 8, 14, 3, 30, -7, (G_GENO | G_NOCORPSE | 1),
X	  { { AT_CLAW, AD_PHYS, 3, 4 }, { AT_CLAW, AD_PHYS, 3, 4 },
X	    NO_ATTK, NO_ATTK, NO_ATTK }, 70, 50, 0, MS_SILENT,
X	  M1_HUMANOID | M1_UNDEAD | M1_POIS | M1_BIG | M1_JEWELS,
X	  M2_HOSTILE | M2_GIANT | M2_STRONG },
X/*	Nymphs	*/
X	{ "wood nymph", S_NYMPH, 3, 12, 9, 20, 0, (G_GENO | 2),
X	  { { AT_CLAW, AD_SITM, 0, 0 }, { AT_CLAW, AD_SEDU, 0, 0 },
X	    NO_ATTK, NO_ATTK, NO_ATTK }, 30, 300, 0, MS_SEDUCE,
X	  M1_HUMANOID | M1_TPORT | M1_COLLECT | M1_FEM, M2_HOSTILE },
X	{ "water nymph", S_NYMPH, 3, 12, 9, 20, 0, (G_GENO | 2),
X	  { { AT_CLAW, AD_SITM, 0, 0 }, { AT_CLAW, AD_SEDU, 0, 0 },
X	    NO_ATTK, NO_ATTK, NO_ATTK }, 30, 300, 0, MS_SEDUCE,
X	  M1_HUMANOID | M1_TPORT | M1_COLLECT | M1_FEM | M1_SWIM,
X	  M2_HOSTILE },
X	{ "mountain nymph", S_NYMPH, 3, 12, 9, 20, 0, (G_GENO | 2),
X	  { { AT_CLAW, AD_SITM, 0, 0 }, { AT_CLAW, AD_SEDU, 0, 0 },
X	    NO_ATTK, NO_ATTK, NO_ATTK }, 30, 300, 0, MS_SEDUCE,
X	  M1_HUMANOID | M1_TPORT | M1_COLLECT | M1_FEM, M2_HOSTILE },
X/*	Ogres	*/
X	{ "ogre", S_OGRE, 5, 10, 5, 0, -3, (G_SGROUP | G_GENO | 1),
X	  { { AT_WEAP, AD_PHYS, 2, 5 }, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X	  60, 500, 0, MS_GRUNT,
X	  M1_BIG | M1_HUMANOID | M1_GREEDY | M1_JEWELS | M1_COLLECT,
X	  M2_STRONG },
X	{ "ogre lord", S_OGRE, 7, 12, 3, 30, -5, (G_GENO | 2),
X	  { { AT_WEAP, AD_PHYS, 2, 6 }, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X	  70, 700, 0, MS_GRUNT,
X	  M1_BIG | M1_HUMANOID | M1_GREEDY | M1_JEWELS | M1_COLLECT | M1_LORD,
X	  M2_STRONG },
X	{ "ogre king", S_OGRE, 7, 14, 4, 60, -7, (G_GENO | 2),
X	  { { AT_WEAP, AD_PHYS, 3, 5 }, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X	  70, 750, 0, MS_GRUNT,
X	  M1_BIG | M1_HUMANOID | M1_GREEDY | M1_JEWELS | M1_COLLECT | M1_PRINCE,
X	  M2_STRONG },
X/*	Puddings */
X	{ "gray ooze", S_PUDDING, 3, 1, 8, 0, 0, (G_GENO | 2),
X	  { { AT_BITE, AD_RUST, 2, 8 }, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X	  50, 500, 0, MS_SILENT, M1_NOEYES | M1_NOHANDS | M1_POIS_RES, 
X	  M2_HOSTILE | M2_NOLIMBS | M2_OMNIVORE | M2_AMORPHOUS },
X	{ "brown pudding", S_PUDDING, 5, 3, 8, 0, 0, (G_GENO | 1),
X	  { { AT_BITE, AD_DCAY, 0, 0 }, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X	  50, 500, 0, MS_SILENT, M1_NOEYES | M1_NOHANDS | M1_POIS_RES |
X	  M1_COLD_RES | M1_ELEC_RES,
X	  M2_HOSTILE | M2_NOLIMBS | M2_OMNIVORE | M2_AMORPHOUS },
X	{ "black pudding", S_PUDDING, 10, 6, 6, 0, 0, (G_GENO | 1),
X	  { { AT_BITE, AD_RUST, 3, 8 }, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X	  50, 500, 0, MS_SILENT, M1_NOEYES | M1_NOHANDS | M1_POIS_RES |
X	  M1_COLD_RES | M1_ELEC_RES,
X	  M2_HOSTILE | M2_NOLIMBS | M2_OMNIVORE | M2_AMORPHOUS },
X/*	Quantum Mechanics	*/
X	{ "quantum mechanic", S_QUANTMECH, 7, 12, 3, 10, 0, (G_GENO | 3),
X	  { { AT_CLAW, AD_TLPT, 1, 4 }, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X	  2, 20, 0, MS_SILENT, M1_ANIMAL | M1_HUMANOID | M1_POIS, M2_HOSTILE },
X	{ "mad scientist", S_QUANTMECH, 8, 12, 2, 20, 0, (G_GENO | 2),
X	  { { AT_WEAP, AD_SLEE, 1, 8 }, { AT_CLAW, AD_DREN, 0, 0 },
X	    NO_ATTK, NO_ATTK, NO_ATTK },
X	  35, 200, 0, MS_SILENT, M1_HUMANOID | M1_POIS | M1_COLLECT,
X	  M2_HOSTILE | M2_HUMAN },
X/*	Rust Monster	*/
X	{ "rust monster", S_RUSTMONST, 5, 18, 2, 0, 0, (G_GENO | 2),
X	  { { AT_TUCH, AD_RUST, 0, 0 }, { AT_TUCH, AD_RUST, 0, 0 }, NO_ATTK,
X	    NO_ATTK, NO_ATTK },
X	  50, 500, 0, MS_SILENT, M1_SWIM | M1_ANIMAL | M1_NOHANDS, M2_HOSTILE },
X/*	Snakes	*/
X	{ "garter snake", S_SNAKE, 1, 8, 8, 0, 0, (G_LGROUP | G_GENO | 1),
X	  { { AT_BITE, AD_PHYS, 1, 2 }, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X	  5, 60, 0, MS_HISS,
X	  M1_VSMALL | M1_SWIM | M1_ANIMAL | M1_NOHANDS | M1_EGGS, M2_CONCEAL |
X	  M2_NOLIMBS | M2_CARNIVORE },
X	{ "snake", S_SNAKE, 4, 15, 3, 0, 0, (G_GENO | 2),
X	  { { AT_BITE, AD_DRST, 1, 6 }, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X	  10, 80, 0, MS_HISS, M1_VSMALL | M1_SWIM | M1_ANIMAL | M1_NOHANDS |
X	  M1_EGGS | M1_POIS | M1_POIS_RES, M2_HOSTILE | M2_CONCEAL |
X	  M2_NOLIMBS | M2_CARNIVORE },
X	{ "pit viper", S_SNAKE, 6, 15, 2, 0, 0, (G_GENO | 1),
X	  { { AT_BITE, AD_DRST, 1, 4 }, { AT_BITE, AD_DRST, 1, 4 },
X	    NO_ATTK, NO_ATTK, NO_ATTK }, 5, 60, 0, MS_HISS, M1_VSMALL |
X	  M1_SWIM | M1_ANIMAL | M1_NOHANDS | M1_EGGS | M1_POIS | M1_POIS_RES,
X	  M2_HOSTILE | M2_CONCEAL | M2_NOLIMBS | M2_CARNIVORE },
X	{ "cobra", S_SNAKE, 6, 18, 2, 0, 0, (G_GENO | 1),
X	  { { AT_BITE, AD_DRST, 2, 4 }, { AT_SPIT, AD_BLND, 0, 0 },
X	    NO_ATTK, NO_ATTK, NO_ATTK }, 15, 100, 0, MS_HISS, M1_VSMALL |
X	  M1_SWIM | M1_ANIMAL | M1_NOHANDS | M1_EGGS | M1_POIS | M1_POIS_RES,
X	  M2_HOSTILE | M2_CONCEAL | M2_NOLIMBS | M2_CARNIVORE },
X	{ "python", S_SNAKE, 6, 3, 5, 0, 0, (G_GENO | 1),
X	  { { AT_BITE, AD_DRST, 1, 4 }, { AT_HUGS, AD_WRAP, 2, 4 },
X	    NO_ATTK, NO_ATTK, NO_ATTK }, 15, 100, 0, MS_HISS, M1_BIG |
X	  M1_SWIM | M1_ANIMAL | M1_NOHANDS | M1_EGGS | M1_POIS | M1_POIS_RES,
X	  M2_HOSTILE | M2_STRONG | M2_NOLIMBS | M2_CARNIVORE },
X	{ "water moccasin", S_SNAKE, 4, 15, 3, 0, 0,
X	  (G_GENO | G_NOGEN | G_LGROUP),
X	  { { AT_BITE, AD_DRST, 1, 6 }, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X	  10, 100, 0, MS_HISS, M1_VSMALL | M1_SWIM | M1_ANIMAL | M1_NOHANDS |
X	  M1_EGGS | M1_POIS | M1_POIS_RES, M2_HOSTILE | M2_CONCEAL |
X	  M2_NOLIMBS | M2_CARNIVORE },
X/*	Trolls	*/
X	{ "troll", S_TROLL, 7, 12, 4, 0, -3, (G_GENO | 2),
X	  { { AT_CLAW, AD_PHYS, 4, 2 }, { AT_CLAW, AD_PHYS, 4, 2 },
X	    { AT_BITE, AD_PHYS, 2, 6 }, NO_ATTK, NO_ATTK },
X	  40, 400, 0, MS_GRUNT, M1_BIG | M1_HUMANOID | M1_REGEN | M1_STALK,
X	  M2_STRONG | M2_CARNIVORE | M2_HOSTILE },
X	{ "ice troll", S_TROLL, 9, 10, 2, 20, -3, (G_GENO | 1),
X	  { { AT_CLAW, AD_PHYS, 2, 6 }, { AT_CLAW, AD_COLD, 2, 6 },
X	    { AT_BITE, AD_PHYS, 2, 6 }, NO_ATTK, NO_ATTK },
X	  40, 300, 0, MS_GRUNT,
X	  M1_BIG | M1_HUMANOID | M1_COLD_RES | M1_REGEN | M1_STALK,
X	  M2_STRONG | M2_CARNIVORE | M2_HOSTILE },
X	{ "rock troll", S_TROLL, 9, 12, 0, 0, -3, (G_GENO | 1),
X	  { { AT_CLAW, AD_PHYS, 2, 8 }, { AT_WEAP, AD_PHYS, 3, 6 },
X	    { AT_BITE, AD_PHYS, 2, 6 }, NO_ATTK, NO_ATTK },
X	  40, 300, 0, MS_GRUNT,
X	  M1_BIG | M1_HUMANOID | M1_REGEN | M1_STALK | M1_COLLECT,
X	  M2_STRONG | M2_CARNIVORE | M2_HOSTILE },
X	{ "water troll", S_TROLL, 11, 14, 4, 40, -3, (G_NOGEN | G_GENO),
X	  { { AT_CLAW, AD_PHYS, 2, 8 }, { AT_CLAW, AD_PHYS, 2, 8 },
X	    { AT_BITE, AD_PHYS, 2, 6 }, NO_ATTK, NO_ATTK },
X	  40, 400, 0, MS_GRUNT,
X	  M1_BIG | M1_SWIM | M1_HUMANOID | M1_REGEN | M1_STALK,
X	  M2_STRONG | M2_CARNIVORE | M2_HOSTILE },
X#ifdef TOLKIEN
X	{ "Olog-hai", S_TROLL, 13, 12, -4, 0, -7, (G_GENO | 1),
X	  { { AT_CLAW, AD_PHYS, 2, 8 }, { AT_WEAP, AD_PHYS, 3, 6 },
X	    { AT_BITE, AD_PHYS, 2, 6 }, NO_ATTK, NO_ATTK },
X	  40, 400, 0, MS_GRUNT,
X	  M1_BIG | M1_HUMANOID | M1_REGEN | M1_STALK | M1_COLLECT,
X	  M2_STRONG | M2_CARNIVORE | M2_HOSTILE },
X#endif
X/*	Umber Hulk	*/
X	{ "umber hulk", S_UMBER, 9, 6, 2, 25, 0, (G_GENO | 2),
X	  { { AT_CLAW, AD_PHYS, 3, 4 }, { AT_CLAW, AD_PHYS, 3, 4 },
X	    { AT_BITE, AD_PHYS, 2, 5 }, { AT_GAZE, AD_CONF, 0, 0 }, NO_ATTK },
X	  50, 500, 0, MS_SILENT, M1_BIG, M2_STRONG | M2_TUNNEL | M2_CARNIVORE },
X/*	Vampires	*/
X	{ "vampire", S_VAMPIRE, 10, 12, 1, 25, -8, (G_GENO | 1),
X	  { { AT_CLAW, AD_PHYS, 1, 6 }, { AT_BITE, AD_DRLI, 1, 6 },
X	    NO_ATTK, NO_ATTK, NO_ATTK }, 40, 400, 0, MS_VAMPIRE,
X	  M1_FLY | M1_HUMANOID | M1_UNDEAD | M1_POIS | M1_REGEN |
X	  M1_STALK, M2_HOSTILE | M2_STRONG | M2_NASTY },
X	{ "vampire lord", S_VAMPIRE, 12, 14, 0, 50, -9, (G_GENO | 1),
X	  { { AT_CLAW, AD_PHYS, 1, 8 }, { AT_BITE, AD_DRLI, 1, 8 },
X	    NO_ATTK, NO_ATTK, NO_ATTK }, 40, 400, 0, MS_VAMPIRE,
X	  M1_FLY | M1_HUMANOID | M1_UNDEAD | M1_POIS | M1_REGEN |
X	  M1_STALK | M1_LORD, M2_HOSTILE | M2_STRONG | M2_NASTY },
X	{ "Vlad the Impaler", S_VAMPIRE, 14, 18, -3, 80, -10,
X	  (G_NOGEN | G_NOCORPSE | G_UNIQ),
X	  { { AT_WEAP, AD_PHYS, 1, 6 }, { AT_BITE, AD_DRLI, 1, 6 },
X	    NO_ATTK, NO_ATTK, NO_ATTK }, 40, 400, PL_NSIZ, MS_VAMPIRE,
X	  M1_NOPOLY | M1_FLY | M1_HUMANOID | M1_UNDEAD | M1_POIS |
X	  M1_REGEN | M1_STALK | M1_PRINCE, 
X	  M2_HOSTILE | M2_PNAME | M2_STRONG | M2_NASTY },
X/*	Wraiths 	*/
X	{ "barrow wight", S_WRAITH, 3, 12, 5, 5, -3, (G_GENO | G_NOCORPSE | 1),
X	  { { AT_CLAW, AD_PHYS, 1, 4 }, { AT_MAGC, AD_SPEL, 0, 0 },
X	    { AT_WEAP, AD_DRLI, 0, 0 }, NO_ATTK, NO_ATTK }, 0, 0, 0, MS_SILENT,
X	  M1_HUMANOID | M1_UNDEAD | M1_POIS_RES | M1_STALK | M1_COLLECT, 
X	  M2_HOSTILE },
X	{ "wraith", S_WRAITH, 6, 12, 4, 15, -6, (G_GENO | 2),
X	  { { AT_TUCH, AD_DRLI, 1, 6 }, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X	  0, 0, 0, MS_SILENT, 
X	  M1_FLY | M1_HUMANOID | M1_UNDEAD | M1_POIS_RES | M1_STALK, 
X	  M2_HOSTILE },
X#ifdef TOLKIEN
X	{ "Nazgul", S_WRAITH, 13, 12, 0, 25, -17, (G_GENO | G_NOCORPSE | 1),
X	  { { AT_WEAP, AD_DRLI, 1, 4 }, { AT_BREA, AD_SLEE, 0, 0 },
X	    NO_ATTK, NO_ATTK, NO_ATTK }, 0, 0, 0, MS_SILENT,
X	  M1_HUMANOID | M1_UNDEAD | M1_POIS_RES | M1_STALK | M1_COLLECT, 
X	  M2_STRONG },
X#endif
X/*	Xorn	*/
X	{ "xorn", S_XORN, 8, 9,-2, 20, 0, (G_GENO | 1),
X	  { { AT_CLAW, AD_PHYS, 1, 3 }, { AT_CLAW, AD_PHYS, 1, 3 },
X	    { AT_CLAW, AD_PHYS, 1, 3 }, { AT_BITE, AD_PHYS, 4, 6 },
X	    NO_ATTK }, 70, 700, 0, MS_SILENT,
X	  M1_BIG | M1_WALLWALK | M1_FIRE_RES | M1_COLD_RES | M1_STON_RES,
X	  M2_HOSTILE | M2_STRONG | M2_THICK_HIDE },
X/*	Yeti	*/
X	{ "yeti", S_YETI, 5, 15, 6, 0, 0, (G_GENO | 2),
X	  { { AT_CLAW, AD_PHYS, 1, 6 }, { AT_CLAW, AD_PHYS, 1, 6 },
X	    { AT_BITE, AD_PHYS, 1, 4 }, NO_ATTK, NO_ATTK },
X	  70, 700, 0, MS_GROWL, M1_BIG | M1_ANIMAL | M1_HUMANOID | M1_COLD_RES,
X	  M2_HOSTILE | M2_STRONG | M2_CARNIVORE },
X/*	Zombies 	*/
X	{ "kobold zombie", S_ZOMBIE, 0, 6, 10, 0, -2, (G_GENO | G_NOCORPSE | 1),
X	  { { AT_CLAW, AD_PHYS, 1, 4 }, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X	  10, 0, 0, MS_SILENT, M1_HUMANOID | M1_UNDEAD | M1_POIS |
X	  M1_POIS_RES | M1_STALK, M2_HOSTILE },
X	{ "gnome zombie", S_ZOMBIE, 1, 6, 10, 0, -2, (G_GENO | G_NOCORPSE | 1),
X	  { { AT_CLAW, AD_PHYS, 1, 5 }, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X	  20, 0, 0, MS_SILENT, M1_HUMANOID | M1_UNDEAD | M1_POIS |
X	  M1_POIS_RES | M1_STALK, M2_HOSTILE },
X	{ "orc zombie", S_ZOMBIE, 2, 6, 9, 0, -3,
X	  (G_GENO | G_SGROUP | G_NOCORPSE | 1),
X	  { { AT_CLAW, AD_PHYS, 1, 6 }, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X	  30, 0, 0, MS_SILENT, M1_HUMANOID | M1_UNDEAD | M1_POIS_RES |
X	  M1_STALK | M1_GREEDY | M1_JEWELS, M2_HOSTILE | M2_ORC },
X	{ "elf zombie", S_ZOMBIE, 3, 6, 9, 0, -3,
X	  (G_GENO | G_SGROUP | G_NOCORPSE | 1),
X	  { { AT_CLAW, AD_PHYS, 1, 7 }, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X	  35, 0, 0, MS_SILENT, M1_HUMANOID | M1_UNDEAD | M1_POIS_RES |
X	  M1_STALK | M1_SLEE_RES, M2_HOSTILE | M2_ELF },
X	{ "human zombie", S_ZOMBIE, 4, 6, 8, 0, -3,
X	  (G_GENO | G_SGROUP | G_NOCORPSE | 1),
X	  { { AT_CLAW, AD_PHYS, 1, 8 }, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X	  40, 0, 0, MS_SILENT,
X	  M1_HUMANOID | M1_UNDEAD | M1_POIS_RES | M1_STALK, M2_HOSTILE },
X	{ "ettin zombie", S_ZOMBIE, 6, 8, 6, 0, -4, (G_GENO | G_NOCORPSE | 1),
X	  { { AT_CLAW, AD_PHYS, 1, 10 }, { AT_CLAW, AD_PHYS, 1, 10 },
X	    NO_ATTK, NO_ATTK, NO_ATTK }, 70, 0, 0, MS_SILENT,
X	  M1_BIG | M1_HUMANOID | M1_UNDEAD | M1_POIS_RES | M1_STALK,
X	  M2_HOSTILE | M2_STRONG },
X	{ "giant zombie", S_ZOMBIE, 8, 8, 6, 0, -4, (G_GENO | G_NOCORPSE | 1),
X	  { { AT_CLAW, AD_PHYS, 2, 8 }, { AT_CLAW, AD_PHYS, 2, 8 },
X	    NO_ATTK, NO_ATTK, NO_ATTK }, 70, 0, 0, MS_SILENT,
X	  M1_BIG | M1_HUMANOID | M1_UNDEAD | M1_POIS_RES | M1_STALK |
X	  M1_JEWELS, M2_HOSTILE | M2_GIANT | M2_STRONG },
X/*	Golems	*/
X#ifdef GOLEMS
X	{ "straw golem", S_GOLEM, 3, 12, 10, 0, 0, (G_GENO | G_NOCORPSE | 1),
X	  { { AT_CLAW, AD_PHYS, 1, 2 }, { AT_CLAW, AD_PHYS, 1, 2 },
X	    NO_ATTK, NO_ATTK, NO_ATTK }, 10, 0, 0, MS_SILENT,
X	  M1_BIG | M1_HUMANOID | M1_POIS_RES, M2_HOSTILE },
X	{ "rope golem", S_GOLEM, 4, 9, 8, 0, 0, (G_GENO | G_NOCORPSE | 1),
X	  { { AT_CLAW, AD_PHYS, 1, 6 }, { AT_HUGS, AD_PHYS, 6, 1 },
X	    NO_ATTK, NO_ATTK, NO_ATTK }, 20, 0, 0, MS_SILENT,
X	  M1_BIG | M1_HUMANOID | M1_POIS_RES, M2_HOSTILE },
X	{ "leather golem", S_GOLEM, 6, 6, 6, 0, 0, (G_GENO | G_NOCORPSE | 1),
X	  { { AT_CLAW, AD_PHYS, 1, 6 }, { AT_CLAW, AD_PHYS, 1, 6 },
X	    NO_ATTK, NO_ATTK, NO_ATTK }, 40, 0, 0, MS_SILENT,
X	  M1_BIG | M1_HUMANOID | M1_POIS_RES, M2_HOSTILE },
X	{ "wood golem", S_GOLEM, 7, 3, 4, 0, 0, (G_GENO | G_NOCORPSE | 1),
X	  { { AT_CLAW, AD_PHYS, 3, 4 }, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X	  50, 0, 0, MS_SILENT, M1_BIG | M1_HUMANOID | M1_POIS_RES,
X	  M2_HOSTILE | M2_THICK_HIDE },
X	{ "flesh golem", S_GOLEM, 9, 8, 9, 30, 0, (G_GENO | 1),
X	  { { AT_CLAW, AD_PHYS, 2, 8 }, { AT_CLAW, AD_PHYS, 2, 8 },
X	    NO_ATTK, NO_ATTK, NO_ATTK },
X	  60, 600, 0, MS_SILENT, M1_BIG | M1_HUMANOID | M1_POIS_RES |
X	  M1_FIRE_RES | M1_COLD_RES | M1_ELEC_RES, M2_HOSTILE | M2_STRONG },
X	{ "clay golem", S_GOLEM, 11, 7, 7, 40, 0, (G_GENO | G_NOCORPSE | 1),
X	  { { AT_CLAW, AD_PHYS, 3, 10 }, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X	  75, 0, 0, MS_SILENT, M1_BIG | M1_HUMANOID | M1_POIS_RES,
X	  M2_HOSTILE | M2_STRONG | M2_THICK_HIDE },
X	{ "stone golem", S_GOLEM, 14, 6, 5, 50, 0, (G_GENO | G_NOCORPSE | 1),
X	  { { AT_CLAW, AD_PHYS, 3, 8 }, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X	  90, 0, 0, MS_SILENT, M1_BIG | M1_HUMANOID | M1_POIS_RES | M1_STON_RES,
X	  M2_HOSTILE | M2_STRONG | M2_THICK_HIDE },
X	{ "iron golem", S_GOLEM, 18, 6, 3, 60, 0, (G_GENO | G_NOCORPSE | 1),
X	  { { AT_WEAP, AD_PHYS, 4, 10 }, { AT_BREA, AD_DRST, 4, 6 },
X	    NO_ATTK, NO_ATTK, NO_ATTK },
X	  100, 0, 0, MS_SILENT, M1_BIG | M1_HUMANOID | M1_POIS |
X	  M1_FIRE_RES | M1_COLD_RES | M1_ELEC_RES | M1_COLLECT,
X	  M2_HOSTILE | M2_STRONG | M2_THICK_HIDE },
X#endif /* GOLEMS */
X/*	Humans		*/
X	{ "human", S_HUMAN, 0, 12, 10, 0, 0, G_NOGEN,
X	  { {AT_WEAP, AD_PHYS, 1, 6}, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X	  35, 400, 0, MS_HUMANOID, M1_NOPOLY | M1_HUMANOID | M1_COLLECT,
X	  M2_HUMAN | M2_PEACEFUL | M2_STRONG }, /* for corpses */
X	{ "wererat", S_HUMAN, 2, 12, 7, 10, -7, 1,
X	  { { AT_WEAP, AD_PHYS, 2, 4 }, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X	  35, 400, 0, MS_SILENT, M1_NOPOLY | M1_HUMANOID | M1_WERE | M1_POIS |
X	  M1_REGEN | M1_COLLECT, M2_HOSTILE | M2_HUMAN },
X	{ "werejackal", S_HUMAN, 2, 12, 7, 10, -7, 1,
X	  { { AT_WEAP, AD_PHYS, 2, 4 }, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X	  35, 400, 0, MS_BARK, M1_NOPOLY | M1_HUMANOID | M1_WERE | M1_POIS |
X	  M1_REGEN | M1_COLLECT, M2_HOSTILE | M2_HUMAN },
X	{ "werewolf", S_HUMAN, 5, 12, 6, 20, -7, 1,
X	  { { AT_WEAP, AD_PHYS, 2, 4 }, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X	  35, 400, 0, MS_BARK, M1_NOPOLY | M1_HUMANOID | M1_WERE | M1_POIS |
X	  M1_REGEN | M1_COLLECT, M2_HOSTILE | M2_HUMAN },
X#ifdef TOLKIEN
X	{ "Woodland-elf", S_HUMAN, 4, 12, 5, 10, 5, (G_GENO | G_SGROUP | 2),
X	  { { AT_WEAP, AD_PHYS, 2, 4 }, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X	  35, 350, 0, MS_HUMANOID, M1_HUMANOID | M1_COLLECT | M1_SLEE_RES,
X	  M2_ELF },
X	{ "Green-elf", S_HUMAN, 5, 12, 5, 10, 6, (G_GENO | G_SGROUP | 2),
X	  { { AT_WEAP, AD_PHYS, 2, 4 }, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X	  35, 350, 0, MS_HUMANOID, M1_HUMANOID | M1_COLLECT | M1_SLEE_RES,
X	  M2_ELF },
X	{ "Grey-elf", S_HUMAN, 6, 12, 5, 10, 7, (G_GENO | G_SGROUP | 2),
X	  { { AT_WEAP, AD_PHYS, 2, 4 }, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X	  35, 350, 0, MS_HUMANOID, M1_HUMANOID | M1_COLLECT | M1_SLEE_RES,
X	  M2_ELF },
X#endif
X	{ "elf-lord", S_HUMAN, 8, 12, 5, 20, 9, (G_GENO | G_SGROUP | 2),
X	  { { AT_WEAP, AD_PHYS, 2, 4 }, { AT_WEAP, AD_PHYS, 2, 4 },
X	    NO_ATTK, NO_ATTK, NO_ATTK },
X	  35, 350, 0, MS_HUMANOID, M1_HUMANOID | M1_LORD | M1_COLLECT |
X	  M1_SLEE_RES, M2_ELF | M2_STRONG },
X	{ "Elvenking", S_HUMAN, 9, 12, 5, 25, 10, (G_GENO | 1),
X	  { { AT_WEAP, AD_PHYS, 2, 4 }, { AT_WEAP, AD_PHYS, 2, 4},
X	    NO_ATTK, NO_ATTK, NO_ATTK },
X	  35, 350, 0, MS_HUMANOID, M1_HUMANOID | M1_PRINCE | M1_COLLECT |
X	  M1_SLEE_RES, M2_ELF | M2_STRONG },
X	{ "nurse", S_HUMAN, 11, 6, 0, 0, 0, (G_GENO | 3),
X	  { { AT_CLAW, AD_HEAL, 2, 6 }, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X	  35, 400, 0, MS_NURSE, M1_NOPOLY | M1_HUMANOID | M1_POIS_RES,
X	  M2_HUMAN | M2_HOSTILE },
X	{ "shopkeeper", S_HUMAN, 12, 18, 0, 50, 0, G_NOGEN,
X	  { { AT_WEAP, AD_PHYS, 4, 4 }, { AT_WEAP, AD_PHYS, 4, 4 }, NO_ATTK,
X	    NO_ATTK, NO_ATTK }, 40, 400, sizeof(struct eshk), MS_SELL,
X	  M1_NOPOLY | M1_HUMANOID | M1_MAGIC | M1_COLLECT,
X	  M2_HUMAN | M2_PEACEFUL | M2_STRONG },
X	{ "guard", S_HUMAN, 12, 12, -1, 40, 10, G_NOGEN,
X	  { { AT_WEAP, AD_PHYS, 4, 10 }, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X	  45, 400, sizeof(struct egd), MS_GUARD,
X	  M1_NOPOLY | M1_HUMANOID | M1_COLLECT,
X	  M2_HUMAN | M2_MERC | M2_PEACEFUL | M2_STRONG },
X#if defined(ALTARS) && defined(THEOLOGY)
X	{ "temple priest", S_HUMAN, 12, 12, 0, 50, 1, G_NOGEN,
X	  { { AT_WEAP, AD_PHYS, 4, 10 }, { AT_KICK, AD_PHYS, 1, 4 },
X	    { AT_MAGC, AD_CLRC, 0, 0 }, NO_ATTK, NO_ATTK },
X	  45, 400, sizeof(struct epri), MS_PRIEST, 
X	  M1_NOPOLY | M1_HUMANOID | M1_ELEC_RES | M1_COLLECT, 
X	  M2_HUMAN | M2_PEACEFUL },
X	{ "temple priestess", S_HUMAN, 12, 12, 0, 50, 1, G_NOGEN,
X	  { { AT_WEAP, AD_PHYS, 4, 10 }, { AT_KICK, AD_PHYS, 1, 4 },
X	    { AT_MAGC, AD_CLRC, 0, 0 }, NO_ATTK, NO_ATTK },
X	  45, 400, sizeof(struct epri), MS_PRIEST,
X	  M1_NOPOLY | M1_HUMANOID | M1_ELEC_RES | M1_COLLECT | M1_FEM, 
X	  M2_HUMAN | M2_PEACEFUL },
X#endif
X#ifdef ARMY
X	{ "unarmored soldier", S_HUMAN, 6, 4, 10, 0, -2, G_NOGEN,
X	  { { AT_WEAP, AD_PHYS, 1, 8 }, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X	  45, 400, 0, MS_SOLDIER,
X	  M1_NOPOLY | M1_HUMANOID | M1_STALK | M1_COLLECT,
X	  M2_HUMAN | M2_MERC | M2_HOSTILE | M2_STRONG },
X	{ "soldier", S_HUMAN, 6, 4, 3, 0, -2, (G_SGROUP | G_GENO | 1),
X	  { { AT_WEAP, AD_PHYS, 1, 8 }, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X	  45, 400, 0, MS_SOLDIER,
X	  M1_NOPOLY | M1_HUMANOID | M1_STALK | M1_COLLECT,
X	  M2_HUMAN | M2_MERC | M2_HOSTILE | M2_STRONG },
X	{ "sergeant", S_HUMAN, 8, 4, 0, 5, -3, (G_SGROUP | G_GENO | 1),
X	  { { AT_WEAP, AD_PHYS, 2, 6 }, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X	  45, 400, 0, MS_SOLDIER,
X	  M1_NOPOLY | M1_HUMANOID | M1_STALK | M1_COLLECT,
X	  M2_HUMAN | M2_MERC | M2_HOSTILE | M2_STRONG },
X	{ "lieutenant", S_HUMAN, 10, 4, -2, 15, -4, (G_GENO | 1),
X	  { { AT_WEAP, AD_PHYS, 3, 4 }, { AT_WEAP, AD_PHYS, 3, 4 },
X	    NO_ATTK, NO_ATTK, NO_ATTK }, 45, 400, 0, MS_SOLDIER,
X	  M1_NOPOLY | M1_HUMANOID | M1_STALK | M1_COLLECT,
X	  M2_HUMAN | M2_MERC | M2_HOSTILE | M2_STRONG },
X	{ "captain", S_HUMAN, 12, 4, -3, 15, -5, (G_GENO | 1),
X	  { { AT_WEAP, AD_PHYS, 4, 4 }, { AT_WEAP, AD_PHYS, 4, 4 },
X	    NO_ATTK, NO_ATTK, NO_ATTK }, 45, 400, 0, MS_SOLDIER,
X	  M1_NOPOLY | M1_HUMANOID | M1_STALK | M1_COLLECT,
X	  M2_HUMAN | M2_MERC | M2_HOSTILE | M2_STRONG },
X#endif
X	{ "Wizard of Yendor", S_HUMAN, 30, 12, -8, 100, -20, G_NOGEN,
X	  { { AT_CLAW, AD_SAMU, 2, 12 }, { AT_MAGC, AD_SPEL, 0, 0 },
X	    { AT_BITE, AD_CUSS, 0, 0 }, NO_ATTK, NO_ATTK }, 40, 400, PL_NSIZ,
X	  MS_CUSS, M1_NOPOLY | M1_FLY | M1_HUMANOID | M1_POIS_RES |
X	  M1_FIRE_RES | M1_REGEN | M1_SEE_INVIS | M1_TPORT |
X	  M1_TPORT_CONTROL | M1_MAGIC,
X	  M2_HUMAN | M2_PNAME | M2_HOSTILE | M2_STRONG | M2_NASTY },
X#ifdef MEDUSA
X	{ "Medusa", S_HUMAN, 20, 12, 2, 50, -15, G_NOGEN | G_UNIQ,
X	  { { AT_CLAW, AD_PHYS, 1, 8 }, { AT_GAZE, AD_STON, 0, 0 },
X	    { AT_BITE, AD_DRST, 1, 6 }, { AT_WEAP, AD_PHYS, 2, 4 }, NO_ATTK },
X	  40, 400, 0, MS_HISS,
X	  M1_NOPOLY | M1_BIG | M1_HUMANOID | M1_POIS | M1_POIS_RES |
X	  M1_STON_RES | M1_FEM, M2_HOSTILE | M2_STRONG | M2_PNAME },
X#endif
X#ifdef ORACLE
X	{ "oracle", S_HUMAN, 12, 0, 0, 50, 0, G_NOGEN | G_UNIQ,
X	  { { AT_NONE, AD_MAGM, 0, 4 }, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X	  35, 400, 0, MS_ORACLE, M1_NOPOLY | M1_HUMANOID | M1_FEM,
X	  M2_HUMAN | M2_PEACEFUL },
X#endif
X#ifdef CHARON
X	{ "Charon", S_HUMAN, 76, 18, -5, 120, 0,
X	  (G_HELL | G_NOCORPSE | G_NOGEN | G_UNIQ),
X	  { { AT_WEAP, AD_PHYS, 1, 8 }, { AT_TUCH, AD_PLYS, 1, 8 },
X	    NO_ATTK, NO_ATTK, NO_ATTK }, 0, 0, PL_NSIZ, MS_FERRY,
X	  M1_NOPOLY | M1_HUMANOID | M1_POIS_RES | M1_FIRE_RES | M1_COLLECT,
X	  M2_HUMAN | M2_PEACEFUL },
X#endif
X/*	Ghost		*/
X	{ "ghost", S_GHOST, 10, 3, -5, 50, -5, (G_NOCORPSE | G_NOGEN),
X	  { { AT_TUCH, AD_PHYS, 1, 1 }, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X	  0, 0, PL_NSIZ, MS_SILENT, M1_NOPOLY | M1_FLY | M1_WALLWALK |
X	  M1_HUMANOID | M1_UNDEAD | M1_STALK | M1_POIS_RES, M2_HOSTILE },
X/*	(major) Demons	*/
X	{ "water demon", S_DEMON, 8, 12,-4, 30, -7, (G_NOCORPSE | G_NOGEN),
X	  { { AT_WEAP, AD_PHYS, 1, 3 }, { AT_CLAW, AD_PHYS, 1, 3 },
X	    { AT_BITE, AD_PHYS, 1, 3 }, NO_ATTK, NO_ATTK },
X	  60, 0, 0, MS_SILENT, M1_SWIM | M1_POIS | M1_FIRE_RES |
X	  M1_STALK | M1_COLLECT, M2_DEMON | M2_HOSTILE | M2_NASTY },
X#ifndef HARD /* generic type */
X	{ "demon", S_DEMON, 10, 12,-4, 30, -7, (G_NOCORPSE | 1),
X	  { { AT_WEAP, AD_PHYS, 1, 4 }, { AT_CLAW, AD_PHYS, 1, 4 },
X	    { AT_BITE, AD_PHYS, 1, 4 }, NO_ATTK, NO_ATTK },
X	  60, 0, 0, MS_JEER, M1_POIS | M1_FIRE_RES | M1_STALK | M1_COLLECT,
X	  M2_DEMON | M2_HOSTILE | M2_NASTY },
X#else	/* used in hell for bigger, badder demons! */
X	/* standard demons & devils */
X	{ "horned devil", S_DEMON, 6, 9, -5, 50, 11, (G_HELL | G_NOCORPSE | 2),
X	  { { AT_WEAP, AD_PHYS, 1, 4 }, { AT_CLAW, AD_PHYS, 1, 4 },
X	    { AT_BITE, AD_PHYS, 2, 3 }, { AT_STNG, AD_PHYS, 1, 3 }, NO_ATTK },
X	  0, 0, 0, MS_SILENT, M1_POIS | M1_FIRE_RES | M1_STALK,
X	  M2_DEMON | M2_HOSTILE | M2_NASTY | M2_THICK_HIDE },
X#ifdef SEDUCE
X	{ "succubus", S_DEMON, 6, 12, 0, 70, -9, (G_NOCORPSE | 1),
X	  { { AT_BITE, AD_SSEX, 0, 0 }, { AT_CLAW, AD_PHYS, 1, 3 },
X	    { AT_CLAW, AD_PHYS, 1, 3 }, NO_ATTK }, 0, 0, 0, MS_SEDUCE,
X	  M1_HUMANOID | M1_FLY | M1_POIS | M1_FIRE_RES | M1_STALK | M1_FEM,
X	  M2_DEMON | M2_HOSTILE | M2_NASTY },
X	{ "incubus", S_DEMON, 6, 12, 0, 70, -9, (G_NOCORPSE | 1),
X	  { { AT_BITE, AD_SSEX, 0, 0 }, { AT_CLAW, AD_PHYS, 1, 3 },
X	    { AT_CLAW, AD_PHYS, 1, 3 }, NO_ATTK }, 0, 0, 0, MS_SEDUCE,
X	  M1_HUMANOID | M1_FLY | M1_POIS | M1_FIRE_RES | M1_STALK,
X	  M2_DEMON | M2_HOSTILE | M2_NASTY },
X#else
X	{ "succubus", S_DEMON, 6, 12, 0, 70, -9, (G_NOCORPSE | 1),
X	  { { AT_CLAW, AD_PHYS, 1, 3 }, { AT_CLAW, AD_PHYS, 1, 3 },
X	    { AT_BITE, AD_DRLI, 2, 6 }, NO_ATTK }, 0, 0, 0, MS_SEDUCE,
X	  M1_HUMANOID | M1_FLY | M1_POIS | M1_FIRE_RES | M1_STALK | M1_FEM,
X	  M2_DEMON | M2_HOSTILE | M2_NASTY },
X	{ "incubus", S_DEMON, 6, 12, 0, 70, -9, (G_NOCORPSE | 1),
X	  { { AT_CLAW, AD_PHYS, 1, 3 }, { AT_CLAW, AD_PHYS, 1, 3 },
X	    { AT_BITE, AD_DRLI, 2, 6 }, NO_ATTK }, 0, 0, 0, MS_SEDUCE,
X	  M1_HUMANOID | M1_FLY | M1_POIS | M1_FIRE_RES | M1_STALK,
X	  M2_DEMON | M2_HOSTILE | M2_NASTY },
X#endif
X	{ "erinyes", S_DEMON, 7, 12, 2, 30, 10,
X	  (G_HELL | G_NOCORPSE | G_SGROUP | 2),
X	  { { AT_WEAP, AD_DRST, 2, 4 }, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X	  0, 0, 0, MS_SILENT, M1_HUMANOID | M1_POIS | M1_FIRE_RES | M1_STALK |
X	  M1_COLLECT | M1_FEM, M2_DEMON | M2_HOSTILE | M2_STRONG | M2_NASTY },
X	{ "marilith", S_DEMON, 7, 12, -6, 80, -12, (G_HELL | G_NOCORPSE | 1),
X	  { { AT_WEAP, AD_PHYS, 2, 4 }, { AT_WEAP, AD_PHYS, 2, 4 },
X	    { AT_WEAP, AD_PHYS, 2, 4 }, { AT_WEAP, AD_PHYS, 2, 4 },
X	    { AT_WEAP, AD_PHYS, 2, 4 }, }, 0, 0, 0, MS_SILENT, M1_HUMANOID |
X	  M1_POIS | M1_FIRE_RES | M1_STALK | M1_COLLECT | M1_FEM,
X	  M2_DEMON | M2_HOSTILE | M2_NASTY },
X	{ "barbed devil", S_DEMON, 8, 12, 0, 35, 8,
X	  (G_HELL | G_NOCORPSE | G_SGROUP | 2),
X	  { { AT_CLAW, AD_PHYS, 2, 4 }, { AT_CLAW, AD_PHYS, 2, 4 },
X	    { AT_STNG, AD_PHYS, 3, 4 }, NO_ATTK, NO_ATTK },
X	  0, 0, 0, MS_SILENT, M1_POIS | M1_FIRE_RES | M1_STALK,
X	  M2_DEMON | M2_HOSTILE | M2_NASTY | M2_THICK_HIDE },
X	{ "vrock", S_DEMON, 8, 12, 0, 50, -9,
X	  (G_HELL | G_NOCORPSE | G_SGROUP | 2),
X	  { { AT_CLAW, AD_PHYS, 1, 4 }, { AT_CLAW, AD_PHYS, 1, 4 },
X	    { AT_CLAW, AD_PHYS, 1, 8 }, { AT_CLAW, AD_PHYS, 1, 8 },
X	    { AT_BITE, AD_PHYS, 1, 6 }, },
X	  0, 0, 0, MS_SILENT, M1_POIS | M1_FIRE_RES | M1_STALK,
X	  M2_DEMON | M2_HOSTILE | M2_NASTY },
X	{ "hezrou", S_DEMON, 9, 6, -2, 55, -10,
X	  (G_HELL | G_NOCORPSE | G_SGROUP | 2),
X	  { { AT_CLAW, AD_PHYS, 1, 3 }, { AT_CLAW, AD_PHYS, 1, 3 },
X	    { AT_BITE, AD_PHYS, 4, 4 }, NO_ATTK, NO_ATTK }, 0, 0, 0, MS_SILENT,
X	  M1_HUMANOID | M1_POIS | M1_FIRE_RES | M1_STALK,
X	  M2_DEMON | M2_HOSTILE | M2_NASTY },
X	{ "bone devil", S_DEMON, 9, 15, -1, 40, -9,
X	  (G_HELL | G_NOCORPSE | G_SGROUP | 2),
X	  { { AT_WEAP, AD_PHYS, 3, 4 }, { AT_STNG, AD_DRST, 2, 4 },
X	    NO_ATTK, NO_ATTK, NO_ATTK }, 0, 0, 0, MS_SILENT,
X	  M1_POIS | M1_FIRE_RES | M1_STALK | M1_COLLECT,
X	  M2_DEMON | M2_HOSTILE | M2_NASTY },
X	{ "nalfeshnee", S_DEMON, 11, 9, -1, 65, -11, (G_HELL | G_NOCORPSE | 1),
X	  { { AT_CLAW, AD_PHYS, 1, 4 }, { AT_CLAW, AD_PHYS, 1, 4 },
X	    { AT_BITE, AD_PHYS, 2, 4 }, { AT_MAGC, AD_SPEL, 0, 0 }, NO_ATTK },
X	  0, 0, 0, MS_SILENT, M1_HUMANOID | M1_POIS | M1_FIRE_RES | M1_STALK,
X	  M2_DEMON | M2_HOSTILE | M2_NASTY },
X	{ "ice devil", S_DEMON, 11, 6, -4, 55, -12, (G_HELL | G_NOCORPSE | 2),
X	  { { AT_CLAW, AD_PHYS, 1, 4 }, { AT_CLAW, AD_PHYS, 1, 4 },
X	    { AT_BITE, AD_PHYS, 2, 4 }, { AT_STNG, AD_COLD, 3, 4 }, NO_ATTK },
X	  0, 0, 0, MS_SILENT, M1_POIS | M1_FIRE_RES | M1_COLD_RES | M1_STALK,
X	  M2_DEMON | M2_HOSTILE | M2_NASTY },
X	{ "pit fiend", S_DEMON, 13, 6, -3, 65, -13, (G_HELL | G_NOCORPSE | 2),
X	  { { AT_WEAP, AD_PHYS, 4, 2 }, { AT_WEAP, AD_PHYS, 4, 2 },
X	    { AT_HUGS, AD_PHYS, 2, 4 }, NO_ATTK, NO_ATTK }, 0, 0, 0, MS_GROWL,
X	  M1_POIS | M1_FIRE_RES | M1_STALK | M1_COLLECT,
X	  M2_DEMON | M2_HOSTILE | M2_NASTY },
X	{ "balrog", S_DEMON, 16, 5, -2, 75, -14, (G_HELL | G_NOCORPSE | 1),
X	  { { AT_WEAP, AD_PHYS, 8, 4 }, { AT_WEAP, AD_PHYS, 4, 6 },
X	    NO_ATTK, NO_ATTK, NO_ATTK },
X	  0, 0, 0, MS_SILENT, M1_FLY | M1_BIG | M1_COLLECT | M1_STALK |
X	  M1_POIS | M1_FIRE_RES, M2_DEMON | M2_HOSTILE | M2_STRONG | M2_NASTY },
X	/* Named demon lords & princes plus Arch-Devils */
X	{ "Juiblex", S_DEMON, 50, 3, -7, 65, -15,
X	  (G_HELL | G_NOCORPSE | G_NOGEN | G_UNIQ),
X	  { { AT_ENGL, AD_DISE, 4, 10 }, { AT_SPIT, AD_ACID, 3, 6 },
X	    NO_ATTK, NO_ATTK, NO_ATTK }, 0, 0, PL_NSIZ, MS_GURGLE, M1_NOPOLY |
X	  M1_FLY | M1_NOHANDS | M1_POIS | M1_FIRE_RES | M1_STALK | M1_LORD,
X	  M2_DEMON | M2_HOSTILE | M2_PNAME | M2_NASTY | M2_AMORPHOUS },
X	{ "Yeenoghu", S_DEMON, 56, 18, -5, 80, -15,
X	  (G_HELL | G_NOCORPSE | G_NOGEN | G_UNIQ),
X	  { { AT_WEAP, AD_PHYS, 3, 6 }, { AT_WEAP, AD_CONF, 2, 8 },
X	    { AT_WEAP, AD_PLYS, 1, 6 }, { AT_MAGC, AD_MAGM, 2, 6 }, NO_ATTK },
X	  0, 0, PL_NSIZ, MS_ORC, M1_NOPOLY | M1_FLY | M1_POIS |
X	  M1_FIRE_RES | M1_STALK | M1_COLLECT | M1_LORD,
X	  M2_DEMON | M2_HOSTILE | M2_PNAME | M2_NASTY },
X	{ "Orcus", S_DEMON, 66, 9, -6, 85, -20,
X	  (G_HELL | G_NOCORPSE | G_NOGEN | G_UNIQ),
X	  { { AT_MAGC, AD_SPEL, 8, 6 }, { AT_WEAP, AD_PHYS, 3, 6 },
X	    { AT_CLAW, AD_PHYS, 3, 4 }, { AT_CLAW, AD_PHYS, 3, 4 },
X	    { AT_STNG, AD_DRST, 2, 4 }, }, 0, 0, PL_NSIZ, MS_ORC,
X	  M1_NOPOLY | M1_FLY | M1_POIS | M1_FIRE_RES | M1_STALK |
X	  M1_COLLECT | M1_PRINCE, M2_DEMON | M2_HOSTILE | M2_PNAME | M2_NASTY },
X	{ "Geryon", S_DEMON, 72, 3, -3, 75, 15,
X	  (G_HELL | G_NOCORPSE | G_NOGEN | G_UNIQ),
X	  { { AT_CLAW, AD_PHYS, 3, 6 }, { AT_CLAW, AD_PHYS, 3, 6 },
X	    { AT_STNG, AD_DRST, 2, 4 }, NO_ATTK, NO_ATTK }, 0, 0, PL_NSIZ,
X	  MS_JEER, M1_NOPOLY | M1_FLY | M1_POIS | M1_FIRE_RES |
X	  M1_STALK | M1_PRINCE, M2_DEMON | M2_HOSTILE | M2_PNAME | M2_NASTY },
X	{ "Dispater", S_DEMON, 78, 15, -2, 80, 15,
X	  (G_HELL | G_NOCORPSE | G_NOGEN | G_UNIQ),
X	  { { AT_WEAP, AD_PHYS, 4, 6 }, { AT_MAGC, AD_SPEL, 6, 6 },
X	    NO_ATTK, NO_ATTK, NO_ATTK }, 0, 0, PL_NSIZ, MS_JEER,
X	  M1_NOPOLY | M1_FLY | M1_HUMANOID | M1_POIS |
X	  M1_FIRE_RES | M1_STALK | M1_COLLECT | M1_PRINCE,
X	  M2_DEMON | M2_HOSTILE | M2_PNAME | M2_NASTY },
X	{ "Baalzebul", S_DEMON, 89, 9, -5, 85, 20,
X	  (G_HELL | G_NOCORPSE | G_NOGEN | G_UNIQ),
X	  { { AT_BITE, AD_DRST, 2, 6 }, { AT_GAZE, AD_STUN, 2, 6 },
X	    NO_ATTK, NO_ATTK, NO_ATTK }, 0, 0, PL_NSIZ, MS_JEER,
X	  M1_NOPOLY | M1_FLY | M1_POIS | M1_FIRE_RES | M1_STALK |
X	  M1_PRINCE, M2_DEMON | M2_HOSTILE | M2_PNAME | M2_NASTY },
X	{ "Asmodeus", S_DEMON, 105, 12, -7, 90, 20,
X	  (G_HELL | G_NOCORPSE | G_NOGEN | G_UNIQ),
X	  { { AT_CLAW, AD_PHYS, 4, 4 }, { AT_MAGC, AD_COLD, 6, 6 },
X	    NO_ATTK, NO_ATTK, NO_ATTK }, 0, 0, PL_NSIZ, MS_JEER,
X	  M1_NOPOLY | M1_FLY | M1_HUMANOID | M1_POIS |
X	  M1_FIRE_RES | M1_COLD_RES | M1_STALK | M1_PRINCE,
X	  M2_DEMON | M2_HOSTILE | M2_PNAME | M2_STRONG | M2_NASTY },
X	{ "Demogorgon", S_DEMON, 106, 15, -8, 95, -20,
X	  (G_HELL | G_NOCORPSE | G_NOGEN | G_UNIQ),
X	  { { AT_MAGC, AD_SPEL, 8, 6 }, { AT_STNG, AD_DRLI, 1, 4 },
X	    { AT_CLAW, AD_DISE, 1, 6 }, { AT_CLAW, AD_DISE, 1, 6 },
X	    NO_ATTK }, 0, 0, PL_NSIZ, MS_GROWL, M1_NOPOLY | M1_FLY |
X	  M1_NOHANDS | M1_POIS | M1_FIRE_RES | M1_STALK |
X	  M1_PRINCE, M2_DEMON | M2_HOSTILE | M2_PNAME | M2_NASTY },
X#endif
X#ifdef MAIL
X	{ "mail daemon", S_DEMON, 56, 24, 10, 127, 0, (G_NOGEN | G_NOCORPSE),
X	  { NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK }, 0, 0, 0, MS_SILENT,
X	  M1_NOPOLY | M1_FLY | M1_SWIM | M1_HUMANOID | M1_POIS | M1_FIRE_RES |
X	  M1_COLD_RES | M1_SLEE_RES | M1_STALK, M2_PEACEFUL },
X/* Neither rain nor sleet nor gloom of night shall stay this courier... */
X#endif
X	{ "djinni", S_DEMON, 7, 12, 4, 30, 0, (G_NOGEN | G_NOCORPSE),
X	  { { AT_WEAP, AD_PHYS, 2, 8 }, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X	  0, 0, 0, MS_DJINNI,
X	  M1_NOPOLY | M1_FLY | M1_POIS | M1_STALK | M1_COLLECT, 0 },
X/*	eels		*/
X	{ "giant eel", S_EEL, 5, 9, -1, 0, 0, (G_GENO | G_NOGEN),
X	  { { AT_BITE, AD_PHYS, 3, 6 }, { AT_TUCH, AD_WRAP, 0, 0 },
X	    NO_ATTK, NO_ATTK, NO_ATTK }, 10, 250, 0, MS_SILENT,
X	  M1_BIG | M1_VSMALL | M1_SWIM | M1_ANIMAL | M1_NOHANDS | M1_NOPOLY |
X	  M1_EGGS, M2_HOSTILE | M2_NOLIMBS | M2_CARNIVORE },
X	{ "electric eel", S_EEL, 7, 10, -3, 0, 0, (G_GENO | G_NOGEN),
X	  { { AT_BITE, AD_ELEC, 4, 6 }, { AT_TUCH, AD_WRAP, 0, 0 },
X	  NO_ATTK, NO_ATTK, NO_ATTK }, 10, 250, 0, MS_SILENT,
X	  M1_BIG | M1_VSMALL | M1_SWIM | M1_ANIMAL | M1_NOHANDS | M1_NOPOLY |
X	  M1_EGGS | M1_ELEC_RES, M2_HOSTILE | M2_NOLIMBS | M2_CARNIVORE },
X/*	kraken	*/
X	{ "kraken", S_EEL, 20, 3, 6, 0, -3, (G_GENO | G_NOGEN),
X	  { { AT_CLAW, AD_PHYS, 2, 4 }, { AT_CLAW, AD_PHYS, 2, 4 },
X	    { AT_HUGS, AD_WRAP, 2, 6 }, { AT_BITE, AD_PHYS, 5, 4 }, NO_ATTK },
X	  1, 10, 0, MS_SILENT,
X	  M1_BIG | M1_SWIM | M1_ANIMAL | M1_NOHANDS | M1_NOPOLY,
X	  M2_HOSTILE | M2_STRONG | M2_CARNIVORE },
X/*	chameleon	*/
X	{ "chameleon", S_CHAMELEON, 6, 5, 6, 10, 0, (G_GENO | 2),
X	  { { AT_BITE, AD_PHYS, 4, 2 }, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X	  1, 10, 0, MS_SILENT, M1_VSMALL | M1_ANIMAL,
X	  M2_HOSTILE | M2_CARNIVORE },
X
X/*	character classes */
X	{ "archeologist", S_HUMAN, 1, 10, 10, 1, 3, G_NOGEN,
X	  { {AT_WEAP, AD_PHYS, 1, 6}, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X	  45, 400, 0, MS_HUMANOID, M1_NOPOLY | M1_HUMANOID | M1_COLLECT,
X	  M2_HUMAN | M2_STRONG | M2_TUNNEL | M2_NEEDPICK },
X	{ "barbarian", S_HUMAN, 1, 10, 10, 1, -3, G_NOGEN,
X	  { {AT_WEAP, AD_PHYS, 1, 6}, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X	  45, 400, 0, MS_HUMANOID, M1_NOPOLY | M1_HUMANOID | M1_COLLECT |
X	  M1_POIS_RES, M2_HUMAN | M2_STRONG },
X	{ "caveman", S_HUMAN, 1, 10, 10, 0, 1, G_NOGEN,
X	  { {AT_WEAP, AD_PHYS, 2, 4}, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X	  45, 400, 0, MS_HUMANOID, M1_NOPOLY | M1_HUMANOID | M1_COLLECT,
X	  M2_HUMAN | M2_STRONG | M2_CARNIVORE },
X	{ "cavewoman", S_HUMAN, 1, 10, 10, 0, 1, G_NOGEN,
X	  { {AT_WEAP, AD_PHYS, 2, 4}, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X	  45, 400, 0, MS_HUMANOID, M1_NOPOLY | M1_HUMANOID | M1_COLLECT | M1_FEM,
X	  M2_HUMAN | M2_STRONG | M2_CARNIVORE },
X	{ "elf", S_HUMAN, 1, 12, 10, 2, 3, G_NOGEN,
X	  { {AT_WEAP, AD_PHYS, 1, 8}, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X	  45, 400, 0, MS_HUMANOID, M1_NOPOLY | M1_HUMANOID | M1_COLLECT |
X	  M1_SLEE_RES | M1_SEE_INVIS, M2_ELF | M2_STRONG },
X	{ "healer", S_HUMAN, 1, 10, 10, 1, 3, G_NOGEN,
X	  { {AT_WEAP, AD_PHYS, 1, 6}, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X	  45, 400, 0, MS_HUMANOID, M1_NOPOLY | M1_HUMANOID | M1_COLLECT |
X	  M1_POIS_RES, M2_HUMAN | M2_STRONG },
X	{ "knight", S_HUMAN, 1, 10, 10, 1, 3, G_NOGEN,
X	  { {AT_WEAP, AD_PHYS, 1, 6}, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X	  45, 400, 0, MS_HUMANOID, M1_NOPOLY | M1_HUMANOID | M1_COLLECT,
X	  M2_HUMAN | M2_STRONG },
X	{ "priest", S_HUMAN, 1, 10, 10, 2, 0, G_NOGEN,
X	  { {AT_WEAP, AD_PHYS, 1, 6}, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X	  45, 400, 0, MS_HUMANOID, M1_NOPOLY | M1_HUMANOID | M1_COLLECT,
X	  M2_HUMAN | M2_STRONG },
X	{ "priestess", S_HUMAN, 1, 10, 10, 2, 0, G_NOGEN,
X	  { {AT_WEAP, AD_PHYS, 1, 6}, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X	  45, 400, 0, MS_HUMANOID, M1_NOPOLY | M1_HUMANOID | M1_COLLECT | M1_FEM,
X	  M2_HUMAN | M2_STRONG },
X	{ "rogue", S_HUMAN, 1, 10, 10, 1, -3, G_NOGEN,
X	  { {AT_WEAP, AD_PHYS, 1, 6}, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X	  45, 400, 0, MS_HUMANOID, M1_NOPOLY | M1_HUMANOID | M1_COLLECT |
X	  M1_GREEDY, M2_HUMAN | M2_STRONG },
X	{ "samurai", S_HUMAN, 1, 10, 10, 1, 3, G_NOGEN,
X	  { {AT_WEAP, AD_PHYS, 1, 8}, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X	  45, 400, 0, MS_HUMANOID, M1_NOPOLY | M1_HUMANOID | M1_COLLECT,
X	  M2_HUMAN | M2_STRONG },
X	{ "tourist", S_HUMAN, 1, 10, 10, 1, 0, G_NOGEN,
X	  { {AT_WEAP, AD_PHYS, 1, 6}, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X	  45, 400, 0, MS_HUMANOID, M1_NOPOLY | M1_HUMANOID | M1_COLLECT,
X	  M2_HUMAN | M2_STRONG },
X	{ "valkyrie", S_HUMAN, 1, 10, 10, 1, -1, G_NOGEN,
X	  { {AT_WEAP, AD_PHYS, 1, 8}, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X	  45, 400, 0, MS_HUMANOID, M1_NOPOLY | M1_HUMANOID | M1_COLLECT | 
X	  M1_COLD_RES | M1_FEM, M2_HUMAN | M2_STRONG },
X	{ "wizard", S_HUMAN, 1, 10, 10, 3, 0, G_NOGEN,
X	  { {AT_WEAP, AD_PHYS, 1, 6}, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X	  45, 400, 0, MS_HUMANOID,
X	  M1_NOPOLY | M1_HUMANOID | M1_MAGIC | M1_COLLECT,
X	  M2_HUMAN | M2_STRONG },
X
X/*	ARRAY TERMINATOR	*/
X	{ "", 0, 0, 0, 0, 0, 0, 0,
X	  { NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X	  0, 0, 0, 0, 0, 0 }
X};
END_OF_FILE
if test 35010 -ne `wc -c <'src/monst.c2'`; then
    echo shar: \"'src/monst.c2'\" unpacked with wrong size!
fi
# end of 'src/monst.c2'
fi
if test -f 'src/save.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/save.c'\"
else
echo shar: Extracting \"'src/save.c'\" \(17421 characters\)
sed "s/^X//" >'src/save.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)save.c	3.0	89/04/13
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X/* block some unused #defines to avoid overloading some cpp's */
X#define MONATTK_H
X#include "hack.h"
X#include "lev.h"
X
X#ifdef WORM
X#include "wseg.h"
X#endif
X
X#ifndef TOS
X#include <signal.h>
X#endif /* !TOS */
X#ifdef EXPLORE_MODE
X#include <fcntl.h>
X#endif /* EXPLORE_MODE */
X
Xboolean hu;		/* set during hang-up */
X
X#if defined(DGK) && !defined(TOS)
Xstruct finfo fileinfo[MAXLEVEL+1];
Xlong bytes_counted;
Xint count_only;
X#else
Xboolean level_exists[MAXLEVEL+1];
X#endif
X
X#if defined(DGK) && !defined(TOS)
Xstatic void savelev0();
X#endif /* DGK && !TOS */
Xstatic void saveobjchn();
Xstatic void savemonchn();
Xstatic void savegoldchn();
Xstatic void savetrapchn();
Xstatic void savegenoinfo();
X#if defined(DGK) && !defined(TOS)
Xstatic boolean swapout_oldest();
Xstatic void copyfile();
X#endif /* defined(DGK) && !defined(TOS) */
Xstatic void spill_objs();
X
Xint
Xdosave(){
X	pline("Really save? ");	/* especially useful if COMPRESS defined */
X	if(yn() == 'n') {
X		clrlin();
X		(void) fflush(stdout);
X		if(multi > 0) nomul(0);
X	} else {
X#ifdef EXPLORE_MODE
X		if(!discover) {
X	pline("Do you want to create a non-scoring, restartable save file? ");
X			if(yn() == 'y')  discover = TRUE;
X		}
X#endif
X		clear_screen();
X		(void) fflush(stdout);
X		hu = FALSE;
X		if(dosave0()) {
X			settty("Be seeing you...\n");
X			exit(0);
X		} else (void)doredraw();
X	}
X	return 0;
X}
X
X#ifndef NOSAVEONHANGUP
Xint
Xhangup(){
X	hu = TRUE;
X	(void) dosave0();
X	exit(1);
X	return 0;
X}
X#endif
X
X/* returns 1 if save successful */
Xint
Xdosave0() {
X	register int fd, ofd;
X	int tmp;		/* not register ! */
X	xchar ltmp;
X#if defined(DGK) && !defined(TOS)
X	long fds, needed;
X	int mode;
X#endif
X#ifdef COMPRESS
X	char	cmd[80];
X#endif
X#ifdef UNIX
X	(void) signal(SIGHUP, SIG_IGN);
X#endif
X#if !defined(__TURBOC__) && !defined(TOS)
X	(void) signal(SIGINT, SIG_IGN);
X#endif
X
X#ifdef MSDOS
X# ifdef DGK
X	if(!hu && !saveDiskPrompt(0))	return 0;
X# endif
X# ifdef EXPLORE_MODE
X	if(!hu) {
X
X	    fd = open(SAVEF, O_RDONLY);
X	    if (fd > 0) {
X		(void) close(fd);
X		clrlin();
X		pline("There seems to be an old save file.  Overwrite it? ");
X		if (yn() == 'n') return 0;
X	    }
X	}
X# endif
X# ifdef TOS
X	fd = creat(SAVEF, FCMASK);
X# else
X	fd = open(SAVEF, O_WRONLY | O_BINARY | O_CREAT | O_TRUNC, FCMASK);
X# endif
X#else /* MSDOS */
X# ifdef EXPLORE_MODE
X	if(!hu) {
X	    fd = open(SAVEF, O_RDONLY);
X	    if (fd > 0) {
X		(void) close(fd);
X		clrlin();
X		pline("There seems to be an old save file.  Overwrite it? ");
X		if (yn() == 'n') return 0;
X	    }
X	}
X# endif
X	fd = creat(SAVEF, FCMASK);
X#endif /* MSDOS */
X	if(fd < 0) {
X		if(!hu) pline("Cannot open save file.");
X		(void) unlink(SAVEF);		/* ab@unido */
X		return(0);
X	}
X	if(flags.moonphase == FULL_MOON)	/* ut-sally!fletcher */
X		change_luck(-1);		/* and unido!ab */
X	home();
X	cl_end();
X#if defined(DGK) && !defined(TOS)
X	if(!hu) msmsg("Saving: ");
X	mode = COUNT;
Xagain:
X	savelev(fd, dlevel, mode);
X	/* count_only will be set properly by savelev */
X#else
X	savelev(fd,dlevel);
X#endif
X	saveobjchn(fd, invent);
X	savemonchn(fd, fallen_down);
X	savegenoinfo(fd);
X	tmp = getuid();
X	bwrite(fd, (genericptr_t) &tmp, sizeof tmp);
X	bwrite(fd, (genericptr_t) &flags, sizeof(struct flag));
X	bwrite(fd, (genericptr_t) &dlevel, sizeof dlevel);
X	bwrite(fd, (genericptr_t) &maxdlevel, sizeof maxdlevel);
X	bwrite(fd, (genericptr_t) &moves, sizeof moves);
X	bwrite(fd, (genericptr_t) &wiz_level, sizeof wiz_level);
X	bwrite(fd, (genericptr_t) &medusa_level, sizeof medusa_level);
X#ifdef ORACLE
X	bwrite(fd, (genericptr_t) &oracle_level, sizeof oracle_level);
X#endif
X#ifdef REINCARNATION
X	bwrite(fd, (genericptr_t) &rogue_level, sizeof rogue_level);
X#endif
X#ifdef STRONGHOLD
X	bwrite(fd, (genericptr_t) &stronghold_level, sizeof stronghold_level);
X	bwrite(fd, (genericptr_t) &tower_level, sizeof tower_level);
X	bwrite(fd, (genericptr_t) tune, sizeof tune);
X#  ifdef MUSIC
X	bwrite(fd, (genericptr_t) &music_heard, sizeof music_heard);
X#  endif
X#endif
X	bwrite(fd, (genericptr_t) &is_maze_lev, sizeof is_maze_lev);
X	bwrite(fd, (genericptr_t) &u, sizeof(struct you));
X#ifdef SPELLS
X	bwrite(fd, (genericptr_t) spl_book, sizeof(struct spell) * (MAXSPELL + 1));
X#endif
X	if(u.ustuck)
X		bwrite(fd, (genericptr_t) &(u.ustuck->m_id), sizeof u.ustuck->m_id);
X	bwrite(fd, (genericptr_t) pl_character, sizeof pl_character);
X	bwrite(fd, (genericptr_t) pl_fruit, sizeof pl_fruit);
X	bwrite(fd, (genericptr_t) &current_fruit, sizeof current_fruit);
X	savefruitchn(fd);
X	savenames(fd);
X#if defined(DGK) && !defined(TOS)
X	if (mode == COUNT) {
X# ifdef ZEROCOMP
X		bflush(fd);
X# endif
X		/* make sure there is enough disk space */
X		needed = bytes_counted;
X		for (ltmp = 1; ltmp <= maxdlevel; ltmp++)
X			if (ltmp != dlevel && fileinfo[ltmp].where)
X				needed += fileinfo[ltmp].size + (sizeof ltmp);
X		fds = freediskspace(SAVEF);
X		if(needed > fds) {
X		    if(!hu) {
X			pline("There is insufficient space on SAVE disk.");
X			pline("Require %ld bytes but only have %ld.", needed,
X				fds);
X		    }
X		    flushout();
X		    (void) close(fd);
X		    (void) unlink(SAVEF);
X		    return 0;
X		}
X		mode = WRITE;
X		goto again;
X	}
X#endif
X	for(ltmp = (xchar)1; ltmp <= maxdlevel; ltmp++) {
X#if defined(DGK) && !defined(TOS)
X		if (ltmp == dlevel || !fileinfo[ltmp].where) continue;
X		if (fileinfo[ltmp].where != ACTIVE)
X			swapin_file(ltmp);
X#else
X		if(ltmp == dlevel || !level_exists[ltmp]) continue;
X#endif
X		glo(ltmp);
X#ifdef DGK
X		if(!hu) msmsg(".");
X#endif
X		if((ofd = open(lock, OMASK)) < 0) {
X		    if(!hu) pline("Error while saving: cannot read %s.", lock);
X		    (void) close(fd);
X		    (void) unlink(SAVEF);
X		    if(!hu) done("tricked");
X		    return(0);
X		}
X#ifdef ZEROCOMP
X		minit();
X#endif
X		getlev(ofd, hackpid, ltmp, FALSE);
X		(void) close(ofd);
X		bwrite(fd, (genericptr_t) &ltmp, sizeof ltmp);  /* level number */
X#if defined(DGK) && !defined(TOS)
X		savelev(fd, ltmp, WRITE);			/* actual level */
X#else
X		savelev(fd, ltmp);			/* actual level */
X#endif
X		(void) unlink(lock);
X	}
X#ifdef ZEROCOMP
X	bflush(fd);
X#endif
X	(void) close(fd);
X	glo(dlevel);
X	(void) unlink(lock);	/* get rid of current level --jgm */
X	glo(0);
X	(void) unlink(lock);
X#ifdef COMPRESS
X	Strcpy(cmd, COMPRESS);
X	Strcat(cmd, " ");
X# ifdef COMPRESS_OPTIONS
X	Strcat(cmd, COMPRESS_OPTIONS);
X	Strcat(cmd, " ");
X# endif
X	Strcat(cmd, SAVEF);
X	(void) system(cmd);
X#endif
X	return(1);
X}
X
X#if defined(DGK) && !defined(TOS)
Xboolean
Xsavelev(fd, lev, mode)
Xint fd;
Xxchar lev;
Xint mode;
X{
X	if (mode & COUNT) {
X# ifdef ZEROCOMP /* should be superfluous */
X		if (!count_only)	/* did we just write? */
X			bflush(0);
X		/*dbg();*/
X# endif
X		count_only = TRUE;
X		bytes_counted = 0;
X		savelev0(fd, lev);
X		while (bytes_counted > freediskspace(levels))
X			if (!swapout_oldest())
X				return FALSE;
X	}
X	if (mode & WRITE) {
X# ifdef ZEROCOMP
X		if (mode & COUNT)	/* did we just count? */
X			bflush(fd);
X# endif
X		count_only = FALSE;
X		bytes_counted = 0;
X		savelev0(fd, lev);
X	}
X	fileinfo[lev].where = ACTIVE;
X	fileinfo[lev].time = moves;
X	fileinfo[lev].size = bytes_counted;
X	return TRUE;
X}
X
Xstatic
Xvoid
Xsavelev0(fd,lev)
X#else
Xvoid
Xsavelev(fd,lev)
X#endif
Xint fd;
Xxchar lev;
X{
X#ifdef WORM
X	register struct wseg *wtmp;
X	register int tmp;
X#endif
X#ifdef TOS
X	short tlev;
X#endif
X
X	if(fd < 0) panic("Save on bad file!");	/* impossible */
X#if !defined(DGK) || defined(TOS)
X	if(lev >= 0 && lev <= MAXLEVEL)
X		level_exists[lev] = TRUE;
X#endif
X	bwrite(fd,(genericptr_t) &hackpid,sizeof(hackpid));
X#ifdef TOS
X	tlev=lev;
X	bwrite(fd,(genericptr_t) &tlev,sizeof(tlev));
X#else
X	bwrite(fd,(genericptr_t) &lev,sizeof(lev));
X#endif
X	bwrite(fd,(genericptr_t) levl,sizeof(levl));
X#ifdef REINCARNATION
X	if(dlevel == rogue_level && lev != rogue_level)
X		/* save the symbols actually used to represent the level, not
X		 * those in use for the current level (the default symbols used
X		 * for rogue), since we will need to know whether to update
X		 * the display of the screen when the game is restored under
X		 * a potentially different value of showsyms from the
X		 * environment */
X		/* if a game is saved off the rogue level, the usual showsyms
X		 * will be written out for the rogue level too, but they will
X		 * be ignored on restore so it doesn't matter */
X		bwrite(fd, (genericptr_t) &savesyms, sizeof(struct symbols));
X	else
X#endif
X		bwrite(fd, (genericptr_t) &showsyms, sizeof(struct symbols));
X	bwrite(fd,(genericptr_t) &moves,sizeof(long));
X	bwrite(fd,(genericptr_t) &xupstair,sizeof(xupstair));
X	bwrite(fd,(genericptr_t) &yupstair,sizeof(yupstair));
X	bwrite(fd,(genericptr_t) &xdnstair,sizeof(xdnstair));
X	bwrite(fd,(genericptr_t) &ydnstair,sizeof(ydnstair));
X#ifdef STRONGHOLD
X	bwrite(fd,(genericptr_t) &xupladder,sizeof(xupladder));
X	bwrite(fd,(genericptr_t) &yupladder,sizeof(yupladder));
X	bwrite(fd,(genericptr_t) &xdnladder,sizeof(xdnladder));
X	bwrite(fd,(genericptr_t) &ydnladder,sizeof(ydnladder));
X#endif
X	bwrite(fd,(genericptr_t) &fountsound,sizeof(fountsound));
X	bwrite(fd,(genericptr_t) &sinksound,sizeof(sinksound));
X	savemonchn(fd, fmon);
X	savegoldchn(fd, fgold);
X	savetrapchn(fd, ftrap);
X
X	saveobjchn(fd, fobj);
X	saveobjchn(fd, billobjs);
X
X	save_engravings(fd);
X	bwrite(fd,(genericptr_t) rooms,sizeof(rooms));
X	bwrite(fd,(genericptr_t) doors,sizeof(doors));
X#ifdef WORM
X	bwrite(fd,(genericptr_t) wsegs,sizeof(wsegs));
X	for(tmp=1; tmp<32; tmp++){
X		for(wtmp = wsegs[tmp]; wtmp; wtmp = wtmp->nseg){
X			bwrite(fd,(genericptr_t) wtmp,sizeof(struct wseg));
X		}
X#if defined(DGK) && !defined(TOS)
X		if (!count_only)
X#endif
X			wsegs[tmp] = 0;
X	}
X	bwrite(fd,(genericptr_t) wgrowtime,sizeof(wgrowtime));
X#endif /* WORM /**/
X#if defined(DGK) && !defined(TOS)
X	if (count_only)	return;
X#endif
X	billobjs = 0;
X	fgold = 0;
X	ftrap = 0;
X	fmon = 0;
X	fobj = 0;
X}
X
X#ifdef ZEROCOMP
X
X#define RLESC '\0'    /* Leading character for run of LRESC's */
X#define flushoutrun(ln) bputc(RLESC); bputc(ln); ln = -1;
X
Xstatic unsigned char outbuf[BUFSZ];
Xstatic unsigned short outbufp = 0;
Xstatic short outrunlength = -1;
Xstatic int bwritefd;
X
X/*dbg()
X{
X   if(!hu) printf("outbufp %d outrunlength %d\n", outbufp,outrunlength);
X}*/
X
Xstatic void bputc(c)
Xunsigned char c;
X{
X# ifdef DGK
X    bytes_counted++;
X    if (count_only)
X      return;
X# endif
X    if (outbufp >= BUFSZ) {
X      (void) write(bwritefd, outbuf, (int) BUFSZ);
X      outbufp = 0;
X    }
X    outbuf[outbufp++] = c;
X}
X
Xvoid
Xbflush(fd)  /* flush run and buffer */
Xregister int fd;
X{
X      bwritefd = fd;
X      if (outrunlength >= 0) {    /* flush run */
X	  flushoutrun(outrunlength);
X      }
X      if (outbufp) {
X#ifdef	DGK
X	  if (!count_only)    /* flush buffer */
X#endif
X		  (void) write(fd, outbuf, outbufp);
X	  outbufp = 0;
X      }
X      /*printf("bflush()"); getret();*/
X}
X
Xvoid
Xbwrite(fd, loc, num)
Xregister int fd;
Xregister genericptr_t loc;
Xregister unsigned num;
X{
X      bwritefd = fd;
X      for (; num; num--, ((char *)loc)++) {
X	      if (*((char *)loc) == RLESC) { /* One more char in run */
X		  if (++outrunlength == 0xFF) {
X		      flushoutrun(outrunlength);
X		  }
X	      } else { /* end of run */
X		  if (outrunlength >= 0) {    /* flush run */
X		      flushoutrun(outrunlength);
X		  }
X		  bputc(*((char *)loc));
X	      }
X      }
X}
X
X#else /* ZEROCOMP */
X
Xvoid
Xbwrite(fd,loc,num)
Xregister int fd;
Xregister genericptr_t loc;
Xregister unsigned num;
X{
X#if defined(DGK) && !defined(TOS)
X	bytes_counted += num;
X	if (!count_only)
X#endif
X/* lint wants the 3rd arg of write to be an int; lint -p an unsigned */
X#if defined(BSD) || defined(ULTRIX)
X	    if(write(fd, loc, (int)num) != (int)num) {
X#else /* e.g. SYSV, __TURBOC__ */
X	    if(write(fd, loc, num) != num) {
X#endif
X		if(!hu) panic("cannot write %u bytes to file #%d", num, fd);
X		else	exit(1);
X	    }
X}
X#endif /* ZEROCOMP */
X
Xstatic void
Xsaveobjchn(fd,otmp)
Xregister int fd;
Xregister struct obj *otmp;
X{
X	register struct obj *otmp2;
X	unsigned int xl;
X	int minusone = -1;
X
X	while(otmp) {
X	    if(Is_container(otmp))	/* unlink contained objects */
X		spill_objs(otmp);	/* (this rearranges the list) */
X
X	    otmp2 = otmp->nobj;
X	    xl = otmp->onamelth;
X	    bwrite(fd, (genericptr_t) &xl, sizeof(int));
X	    bwrite(fd, (genericptr_t) otmp, xl + sizeof(struct obj));
X#if defined(DGK) && !defined(TOS)
X	    if (!count_only)
X#endif
X		free((genericptr_t) otmp);
X	    otmp = otmp2;
X	}
X	bwrite(fd, (genericptr_t) &minusone, sizeof(int));
X}
X
Xstatic void
Xsavemonchn(fd,mtmp)
Xregister int fd;
Xregister struct monst *mtmp;
X{
X	register struct monst *mtmp2;
X	unsigned int xl;
X	int minusone = -1;
X	struct permonst *monbegin = &mons[0];
X
X	bwrite(fd, (genericptr_t) &monbegin, sizeof(monbegin));
X
X	while(mtmp) {
X		mtmp2 = mtmp->nmon;
X		xl = mtmp->mxlth + mtmp->mnamelth;
X		bwrite(fd, (genericptr_t) &xl, sizeof(int));
X		bwrite(fd, (genericptr_t) mtmp, xl + sizeof(struct monst));
X		if(mtmp->minvent) saveobjchn(fd,mtmp->minvent);
X#if defined(DGK) && !defined(TOS)
X		if (!count_only)
X#endif
X		free((genericptr_t) mtmp);
X		mtmp = mtmp2;
X	}
X	bwrite(fd, (genericptr_t) &minusone, sizeof(int));
X}
X
Xstatic void
Xsavegoldchn(fd,gold)
Xregister int fd;
Xregister struct gold *gold;
X{
X	register struct gold *gold2;
X	while(gold) {
X		gold2 = gold->ngold;
X		bwrite(fd, (genericptr_t) gold, sizeof(struct gold));
X#if defined(DGK) && !defined(TOS)
X		if (!count_only)
X#endif
X			free((genericptr_t) gold);
X		gold = gold2;
X	}
X	bwrite(fd, (genericptr_t)nul, sizeof(struct gold));
X}
X
Xstatic void
Xsavetrapchn(fd,trap)
Xregister int fd;
Xregister struct trap *trap;
X{
X	register struct trap *trap2;
X	while(trap) {
X		trap2 = trap->ntrap;
X		bwrite(fd, (genericptr_t) trap, sizeof(struct trap));
X#if defined(DGK) && !defined(TOS)
X		if (!count_only)
X#endif
X			free((genericptr_t) trap);
X		trap = trap2;
X	}
X	bwrite(fd, (genericptr_t)nul, sizeof(struct trap));
X}
X
X/* save all the fruit names and ID's; this is used only in saving whole games
X * (not levels) and in saving bones levels.  When saving a bones level,
X * we only want to save the fruits which exist on the bones level; the bones
X * level routine marks nonexistent fruits by making the fid negative.
X */
Xvoid
Xsavefruitchn(fd)
Xregister int fd;
X{
X	register struct fruit *f2;
X	while(ffruit) {
X		f2 = ffruit->nextf;
X		if (ffruit->fid >= 0)
X			bwrite(fd, (genericptr_t) ffruit, sizeof(struct fruit));
X		free((genericptr_t) ffruit);
X		ffruit = f2;
X	}
X	bwrite(fd, (genericptr_t)nul, sizeof(struct fruit));
X}
X
Xstatic void
Xsavegenoinfo(fd)
Xregister int fd;
X{
X	register int i;
X
X	for (i = 0; i < NUMMONS; i++)
X		bwrite(fd, (genericptr_t) &(mons[i].geno), sizeof(unsigned));
X}
X
X#if defined(DGK) && !defined(TOS)
Xboolean
Xswapin_file(lev)
Xint lev;
X{
X	char to[PATHLEN], from[PATHLEN];
X
X	Sprintf(from, "%s%s", permbones, alllevels);
X	Sprintf(to, "%s%s", levels, alllevels);
X	name_file(from, lev);
X	name_file(to, lev);
X	while (fileinfo[lev].size > freediskspace(to))
X		if (!swapout_oldest())
X			return FALSE;
X#ifdef WIZARD
X	if (wizard) {
X		pline("Swapping in `%s'", from);
X		(void) fflush(stdout);
X	}
X#endif
X	copyfile(from, to);
X	(void) unlink(from);
X	fileinfo[lev].where = ACTIVE;
X	return TRUE;
X}
X
Xstatic boolean
Xswapout_oldest() {
X	char to[PATHLEN], from[PATHLEN];
X	int i, oldest;
X	long oldtime;
X
X	if (!ramdisk)
X		return FALSE;
X	for (i = 1, oldtime = 0, oldest = 0; i <= maxdlevel; i++)
X		if (fileinfo[i].where == ACTIVE
X		&& (!oldtime || fileinfo[i].time < oldtime)) {
X			oldest = i;
X			oldtime = fileinfo[i].time;
X		}
X	if (!oldest)
X		return FALSE;
X	Sprintf(from, "%s%s", levels, alllevels);
X	Sprintf(to, "%s%s", permbones, alllevels);
X	name_file(from, oldest);
X	name_file(to, oldest);
X#ifdef WIZARD
X	if (wizard) {
X		pline("Swapping out `%s'.", from);
X		(void) fflush(stdout);
X	}
X#endif
X	copyfile(from, to);
X	(void) unlink(from);
X	fileinfo[oldest].where = SWAPPED;
X	return TRUE;
X}
X
Xstatic
Xvoid
Xcopyfile(from, to)
Xchar *from, *to;
X{
X	char buf[BUFSIZ];
X	int nfrom, nto, fdfrom, fdto;
X
X	if ((fdfrom = open(from, O_RDONLY | O_BINARY, FCMASK)) < 0)
X		panic("Can't copy from %s !?", from);
X	if ((fdto = open(to, O_WRONLY | O_BINARY | O_CREAT | O_TRUNC, FCMASK)) < 0)
X		panic("Can't copy to %s", to);
X	do {
X		nfrom = read(fdfrom, buf, BUFSIZ);
X		nto = write(fdto, buf, nfrom);
X		if (nto != nfrom)
X			panic("Copyfile failed!");
X	} while (nfrom == BUFSIZ);
X	(void) close(fdfrom);
X	(void) close(fdto);
X}
X#endif
X
X/*
X * "spill" objects out of containers (unlinking from the fcobj list).
X *
X * The objects will be rearranged, and properly aged.  When we restore, they
X * can be put back into their containers.  By the time all of the calls to
X * saveobjchn() been made, the fcobj list should be empty.  Thus it need not
X * be saved, and doing so could cause some strange addressing problems.
X *
X * NOTE:  The cobj field is set to -1.  It will be used as a flag to indicate
X *	  that this object was previously in a container.
X */
X
Xstatic void
Xspill_objs(cobj)
Xregister struct obj *cobj;
X{
X	register struct obj *otmp, *otmp2, *probj;
X
X#ifdef LINT
X	probj = (struct obj *)0;    /* suppress "used before set" error */
X#endif
X	for(otmp = fcobj; otmp; otmp = otmp2) {
X
X	    otmp2 = otmp->nobj;
X	    if(otmp->cobj == cobj) {
X
X		if(cobj->cursed && rn2(2))	otmp->cursed = 1;
X	/*
X	 * Place all of the objects in a given container after that container
X	 * in the list.  On restore, they should be able to be picked up and
X	 * put back in.
X	 */
X		if(otmp == fcobj) fcobj = otmp2;
X		else		  probj->nobj = otmp2;
X
X		otmp->nobj = cobj->nobj;
X		cobj->nobj = otmp;
X		otmp->cobj = (struct obj *)-1;
X	    } else probj = otmp;
X	}
X
X}
END_OF_FILE
if test 17421 -ne `wc -c <'src/save.c'`; then
    echo shar: \"'src/save.c'\" unpacked with wrong size!
fi
# end of 'src/save.c'
fi
echo shar: End of archive 8 \(of 38\).
cp /dev/null ark8isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 38 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
