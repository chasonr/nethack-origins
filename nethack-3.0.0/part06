Path: utzoo!utgpu!jarvis.csri.toronto.edu!mailrus!csd4.milw.wisc.edu!cs.utexas.edu!uunet!zephyr.ens.tek.com!tektronix!tekgen!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v07i061:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Part06/38
Message-ID: <4314@tekred.CNA.TEK.COM>
Date: 24 Jul 89 05:00:14 GMT
Sender: nobody@tekred.CNA.TEK.COM
Lines: 2003
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 7, Issue 61
Archive-name: NetHack3/Part06



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 6 (of 38)."
# Contents:  auxil/data.base src/trap.c
# Wrapped by billr@saab on Sun Jul 23 21:32:49 1989
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'auxil/data.base' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'auxil/data.base'\"
else
echo shar: Extracting \"'auxil/data.base'\" \(13532 characters\)
sed "s/^X//" >'auxil/data.base' <<'END_OF_FILE'
X	NetHack data file - version 3.0
X@	human;
X		These strange creatures live mostly on the  surface  of  the
X		earth, gathering together in societies of various forms, but
X		occasionally a stray will descend into the depths and commit
X		mayhem  among  the  dungeon  residents who, naturally, often
X		resent the intrusion of such beasts.  They  are  capable  of
X		using  weapons  and  magic,  and it is even rumored that the
X		Wizard of Yendor is a member of this species.
X-	a wall
X|	a wall
X+	a door
X.	the floor of a room
X	a dark part of a room
X#	a corridor
X<	a way to the previous level
X>	a way to the next level
X}	water filled area
X)	a weapon
X[	a suit or piece of armor
X%	a piece of food
X?	a scroll
X/	a wand
X=	a ring
X!	a potion
X(	a useful item (pick-axe, key, lamp, etc.)
X*	a gem or rock
X$	a pile of gold;
X		A metal of characteristic yellow colour, the  most  precious
X		metal  used as a common commercial medium of exchange.  Sym-
X		bol, Au; at.  no. 79; at. wt. 197.2.  It is the most  malle-
X		able  and  ductile  of  all metals, and very heavy (sp. gr.,
X		19.3).  It is quite unalterable by heat, moisture, and  most
X		corrosive  agents,  and therefore well suited for its use in
X		coin and jewelry.
X		      [ Webster's New International Dictionary of the
X			English Language, Second Edition ]
X"	an amulet (or a web)
X^	a trap
X0	an iron ball
X_	an iron chain
X`	a boulder or statue
Xa	an ant or other insect
Xb	a blob
Xc	a cockatrice;
X		Once in a great while, when the positions of the  stars  are
X		just right, a seven-year-old rooster will lay an egg.  Then,
X		along will come a snake, to coil around the egg, or a  toad,
X		to  squat  upon  the  egg, keeping it warm and helping it to
X		hatch.  When it hatches, out comes a creature called  basil-
X		isk, or cockatrice, the most deadly of all creatures. A sin-
X		gle glance from its yellow, piercing toad's eyes  will  kill
X		both man  and beast.  Its power of destruction is said to be
X		so great that sometimes simply to hear its  hiss  can  prove
X		fatal.  Its  breath is so venomous  that it causes all vege-
X		tation to wither.
X		There is, however, one  creature  which  can  withstand  the
X		basilisk's deadly gaze, and this is the weasel. No one knows
X		why this is so, but although the fierce weasel can slay  the
X		basilisk, it will itself be killed in the struggle.  Perhaps
X		the weasel knows the basilisk's fatal weakness:  if it  ever
X		sees  its own reflection in a mirror it will perish instant-
X		ly.  But even a dead basilisk is dangerous, for  it is  said
X		that merely touching its lifeless body can cause a person to
X		sicken and die.
X				[Mythical Beasts by Deirdre Headon
X				 (The Leprechaun Library) and other sources]
Xd	a dog or other canine
Xe	an eye or sphere
Xf	a feline
Xg	a gremlin;
X		The  gremlin is a highly  intelligent and  completely   evil
X		creature.   It lives to torment  other creatures and will go
X		to great lengths to inflict pain or cause injury.
Xh	a humanoid;
X		Humanoids  are all approximately  the size of a human,   and
X		may  be  mistaken for one  at a distance.  They  are usually
X		of a tribal  nature, and will  fiercely defend their  lairs.
X		Usually   hostile, they  may even band  together to raid and
X		pillage human settlements.
Xi	an imp or minor demon;
X		 ... imps ... little creatures of two feet high  that  could
X		gambol and jump prodigiously; ...
X				   [The Charwoman's Shadow, by Lord Dunsany]
X	
X		An 'imp' is an off-shoot or cutting.  Thus an 'ymp tree' was
X		a grafted tree, or one grown from a cutting, not from seed.
X		'Imp' properly means a small devil, an off-shoot  of  Satan,
X		but  the distinction between goblins or bogles and imps from
X		hell is hard to make, and many in the  Celtic  countries  as
X		well as the English Puritans regarded all fairies as devils.
X		The fairies of tradition often hover  uneasily  between  the
X		ghostly and the diabolic state.
X				 [Katharine Briggs, A Dictionary of Fairies]
Xk	a kobold;
X		The race of kobolds are reputed to be an artificial creation
X		of a master wizard (demi-god?).  They are about 3' tall with
X		a vaguely dog-like face.  They bear a violent dislike of the
X		Elven race, and  will go out  of their way to  cause trouble
X		for Elves at any time.
Xl	a lich;
X		Once in a great  while, an evil master wizard or priest will
X		manage through use of great magics to extend his or her life
X		far beyond the normal  span of a human.  The usual effect of
X		this is to transform the human, over time, into an undead of
X		great magical power.  A Lich  hates life in any form; even a
X		touch from one of these  creatures will cause a numbing cold
X		in the victim.  They all posess the capability to use magic.
Xm	a mimic
Xn	a naga;
X		The naga is a mystical creature with the body of a snake and
X		the head of a man or woman.  They will fiercely  protect the
X		territory they consider their own.  Some nagas can be forced
X		to serve as a guardian by a spell caster of great power.
Xo	an orc
Xp	a piercer;
X		Ye Piercer doth look like unto  a  stalactyte,  and  hangeth
X		from  the  roofs of caves and caverns.  Unto the height of a
X		man, and thicker than a man's thigh do  they  grow,  and  in
X		groups  do they hang.  If a creature doth pass beneath them,
X		they will by its heat and noise perceive it, and  fall  upon
X		it  to kill and devour it, though in any other way they move
X		but exceeding slow.
X						   [ the Bestiary of Xygag ]
Xq	a quadruped;
X		The woodlands and other regions  are inhabited by multitudes
X		of four-legged creatures  which cannot be simply classified.
X		They might not have fiery breath  or deadly stings,  but ad-
X		venturers  have  nevertheless  met their end  numerous times
X		due to the claws, hooves, or bites of such animals.
X	
X		...the leucrocotta, a wild beast of extraordinary swiftness,
X		the size of the wild ass, with the legs of a Stag, the neck,
X		tail, and breast of a lion,  the head of a badger,  a cloven
X		hoof, the mouth slit up as far as the ears,  and one contin-
X		uous bone  instead of  teeth;  it is said,  too,  that  this
X		animal can imitate the human voice.
X				 [Curious Creatures in Zoology, John Ashton]
Xr	a rodent
Xs	a spider
Xt	a trapper or lurker above
Xu	a unicorn;
X		Men have always sought the elusive unicorn, for  the  single
X		twisted  horn  which projected from its forehead was thought
X		to be a powerful talisman.  It was said that the unicorn had
X		simply  to  dip  the tip of its horn in a muddy pool for the
X		water to become pure.  Men also believed that to  drink from
X		this horn was a protection against all sickness, and that if
X		the horn was ground to a powder it would act as an  antidote
X		to all poisons.  Less than 200 years ago in France, the horn
X		of a unicorn was used in a ceremony to test the  royal  food
X		for poison.
X		Although only the size of a small horse, the  unicorn  is  a
X		very  fierce  beast,  capable  of killing an elephant with a
X		single thrust from its horn.  Its  fleetness  of  foot  also
X		makes  this solitary creature difficult to capture. However,
X		it can be tamed and captured by a maiden. Made gentle by the
X		sight  of a virgin, the unicorn can be lured to lay its head
X		in her lap, and in this docile mood, the maiden  may  secure
X		it with a golden rope.
X		[Mythical Beasts by Deirdre Headon (The Leprechaun Library)]
Xv	a vortex
Xw	a worm;
X		[The crysknife] is manufactured in two forms from teeth tak-
X		en  from dead sandworms.  The two forms are "fixed" and "un-
X		fixed." An unfixed  knife  requires  proximity  to  a  human
X		body's  electrical  field  to prevent disintegration.  Fixed
X		knives are treated for storage.  All are about  20  centime-
X		ters long.
X						[ Dune, by Frank Herbert ]
Xx	a xan;
X		They sent their friend the mosquito [xan] ahead of  them  to
X		find  out  what lay ahead.  "Since you are the one who sucks
X		the blood of men walking along paths," they told the mosqui-
X		to,  "go  and  sting the men of Xibalba."  The mosquito flew
X		down the dark road to the Underworld.  Entering the house of
X		the Lords of Death, he stung the first person that he saw...
X	
X		The mosquito stung this man as well, and when he yelled, the
X		man  next  to him asked, "Gathered Blood, what's wrong?"  So
X		he flew along the row stinging all the seated men  until  he
X		knew the names of all twelve.
X				[ Popul Vuh, as translated by Ralph Nelson ]
Xy	a yellow light
Xz	a zruty;
X		The zruty are  wild and gigantic beings,  living in the wil-
X		dernesses of the Tatra mountains.
XA	a giant ape
XB	a giant bat
XC	a centaur;
X		Of all the monsters put together by  the  Greek  imagination
X		the  Centaurs (Kentauroi) constituted a class in themselves.
X		Despite a strong streak  of  sensuality  in  their  make-up,
X		their  normal  behaviour  was  moral, and they took a kindly
X		thought of man's welfare. The attempted outrage of Nessos on
X		Deianeira,  and  that  of the whole tribe of Centaurs on the
X		Lapith women,  are more than offset  by the  hospitality  of
X		Pholos and  by  the  wisdom of Cheiron,  physician, prophet,
X		lyrist,  and the instructor of Achilles.  Further,  the Cen-
X		taurs  were  peculiar in that their nature, which united the
X		body of a horse with the trunk and head of a  man,  involved
X		an  unthinkable  duplication  of  vital organs and important
X		members.  So grotesque a combination seems almost  un-Greek.
X		These  strange creatures  were said to live in the caves and
X		clefts of the mountains, myths associating  them  especially
X		with the hills of Thessaly and the range of Erymanthos.
X			       [Mythology of all races, Vol. 1, pp. 270-271]
XD	a dragon;
X		In the West  the dragon was  the  natural  enemy   of   man.
X		Although  preferring  to live in bleak and desolate regions,
X		whenever it was seen among men it left in its wake a   trail
X		of   destruction   and disease. Yet any attempt to slay this
X		beast was a perilous undertaking. For the dragon's assailant
X		had  to  contend not  only  with clouds of  sulphurous fumes
X		pouring from its fire-breathing nostrils, but also with  the
X		thrashings  of  its  tail,  the  most   deadly  part  of its
X		serpent-like body.
X		     [Mythical Beasts by Deirdre Headon (The Leprechaun Library)]
XE	an elemental;
X		Elementals are manifestations of the  basic  nature  of  the
X		universe.   There  are four known forms of elementals:  air,
X		fire, water, and earth.  Some mystics  have  postulated  the
X		necessity  for  a fifth type, the spirit elemental, but none
X		have ever been encountered, at least on this  plane  of  ex-
X		istence.
XF	a fungus or mold
XG	a gnome;
X		...  And then a gnome came by,  carrying a bundle,   an  old
X		fellow three times  as large as an imp  and wearing  clothes
X		of a sort, especially a hat.  And he was  clearly   just  as
X		frightened   as  the  imps  though  he could not go so fast.
X		Ramon Alonzo saw that there must be some great trouble  that
X		was  vexing  magical  things;   and,  since gnomes speak the
X		language of men, and will answer if spoken  to  gently,   he
X		raised  his  hat,   and  asked  of the gnome  his name.  The
X		gnome did not  stop  his  hasty  shuffle  a  moment   as  he
X		answered 'Alaraba' and grabbed the rim of his hat but forgot
X		to doff it.
X		'What is the trouble, Alaraba?' said Ramon Alonzo.
X		'White magic. Run!' said the gnome ...
X				       [The Charwoman's Shadow, by Lord Dunsany.]
XH	a giant humanoid;
X		Giants have always walked the earth, though they are rare in
X		these times.  They range in size from  little over nine feet
X		to a towering twenty feet or more.  The larger ones use huge
X		boulders as weapons, hurling them over large distances.  All
X		types of giants share a love for men  -  roasted, boiled, or
X		fried.  Their table manners are legendary.
XI	an invisible stalker
XJ	a jelly
XK	a Keystone Kop
XL	a leprechaun;
X		The Irish Leprechaun is the Faeries' shoemaker and is  known
X		under  various names  in different parts of Ireland:  Cluri-
X		caune in Cork, Lurican in Kerry, Lurikeen in Kildare and Lu-
X		rigadaun  in  Tipperary.  Although he works for the Faeries,
X		the Leprechaun is not of the same species.  He is small, has
X		dark  skin  and wears strange clothes.  His nature has some-
X		thing of the manic-depressive about it:  first he  is  quite
X		happy, whistling merrily as he nails a sole on to a shoe;  a
X		few minutes later, he is sullen and  morose,  drunk  on  his
X		home-made heather ale.  The Leprechaun's two great loves are
X		tobacco and whiskey, and he is a first-rate con-man,  impos-
X		sible  to  out-fox.  No  one, no matter how clever, has ever
X		managed to cheat him out of his hidden pot of  gold  or  his
X		magic shilling.  At the last minute he always thinks of some
X		way to divert his captor's attention  and  vanishes  in  the
X		twinkling  of  an eye.
X					 [A Field Guide to the Little People
X					by Nancy Arrowsmith & George Moorse]
XM	a mummy
XN	a nymph
XO	an ogre
XP	a pudding or ooze;
X		These giant amoeboid creatures look like nothing  more  than
X		puddles  of  slime,  but they both live and move, feeding on
X		metal or wood as well as the occasional dungeon explorer  to
X		supplement their diet.
XQ	a quantum mechanic;
X		These creatures are not native to this universe;  they  seem
X		to have strangely derived powers, and unknown motives.
XR	a rust monster;
X		These strange creatures live on a   diet  of  metals.   They
X		will  turn  a  suit  of  armour into so much useless  rusted
X		scrap in no time at all.
XS	a snake
XT	a troll
XU	an umber hulk
XV	a vampire
XW	a wraith
XX	a xorn
XY	a yeti
XZ	a zombie
X&	a demon
X:	a chameleon
X;	a giant eel
END_OF_FILE
if test 13532 -ne `wc -c <'auxil/data.base'`; then
    echo shar: \"'auxil/data.base'\" unpacked with wrong size!
fi
# end of 'auxil/data.base'
fi
if test -f 'src/trap.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/trap.c'\"
else
echo shar: Extracting \"'src/trap.c'\" \(38220 characters\)
sed "s/^X//" >'src/trap.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)trap.c	3.0	88/10/22
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include	"hack.h"
X#include	"edog.h"
X#include	"trapname.h"
X
Xvoid domagictrap();
Xstatic boolean thitm();
X
X/* Generic rust-armor function.  Returns TRUE if a message was printed;
X * "print", if set, means to print a message (and thus to return TRUE) even
X * if the item could not be rusted; otherwise a message is printed and TRUE is
X * returned only for rustable items.
X */
Xboolean
Xrust_dmg(otmp, ostr, type, print)
Xregister struct obj *otmp;
Xregister char *ostr;
Xint type;
Xboolean print;
X{
X	static const char *gook[] = { "slag", "rust", "rot", "corrosion" };
X	static const char *action[] = { "smolder", "rust", "rot", "corrode" };
X	boolean vulnerable = FALSE;
X	boolean plural;
X
X	if (!otmp) return(FALSE);
X	switch(type) {
X		case 0:
X		case 2: vulnerable = is_flammable(otmp); break;
X		case 1: vulnerable = is_rustprone(otmp); break;
X		case 3: vulnerable = (otmp->otyp == BRONZE_PLATE_MAIL); break;
X	}
X
X	if (!print && (!vulnerable || otmp->rustfree || otmp->spe < -2))
X		return FALSE;
X
X	plural = is_gloves(otmp) || is_boots(otmp);
X
X	if (!vulnerable)
X		Your("%s %s not affected!", ostr, plural ? "are" : "is");
X	else if (otmp->spe >= -2) {
X		if (otmp->rustfree)
X			pline("The %s on your %s vanishes instantly!",
X						gook[type], ostr);
X		else if (otmp->blessed && !rnl(4))
X			pline("Somehow, your %s %s not affected!", ostr,
X					plural ? "are" : "is");
X		else {
X			Your("%s %s%s!", ostr, action[type],
X				plural ? "" : "s");
X			otmp->spe--;
X			adj_abon(otmp, -1);
X		}
X	} else Your("%s look%s quite rusted.", ostr, plural ? "" : "s");
X	return(TRUE);
X}
X
Xstruct trap *
Xmaketrap(x,y,typ)
Xregister int x, y, typ;
X{
X	register struct trap *ttmp;
X	register struct permonst *ptr;
X
X	ttmp = newtrap();
X	ttmp->ttyp = typ;
X	ttmp->tx = x;
X	ttmp->ty = y;
X	switch(typ) {
X	    case MONST_TRAP:	    /* create a monster in "hiding" */
X		if(rn2(5) && (ptr = mkclass(S_PIERCER)))
X			ttmp->pm = monsndx(ptr);
X		else
X			ttmp->pm = rndmonnum();
X		break;
X	    case STATUE_TRAP:	    /* create a "living" statue */
X		ttmp->pm = rndmonnum();
X		(void) mkstatue(&mons[ttmp->pm], x, y);
X		break;
X	    default:
X		ttmp->pm = -1;
X		break;
X	}
X	ttmp->tseen = 0;
X	ttmp->once = 0;
X	ttmp->ntrap = ftrap;
X	ftrap = ttmp;
X	return(ttmp);
X}
X
Xint
Xteleok(x, y)
Xregister int x, y;
X{				/* might throw him into a POOL
X				 * removed by GAN 10/20/86
X				 */
X#ifdef STUPID
X	boolean	tmp1, tmp2, tmp3;
X#  ifdef POLYSELF
X	tmp1 = isok(x,y) && (!IS_ROCK(levl[x][y].typ) ||
X		passes_walls(uasmon)) && !levl[x][y].mmask;
X#  else
X	tmp1 = isok(x,y) && !IS_ROCK(levl[x][y].typ) && !levl[x][y].mmask;
X#  endif
X	tmp2 = !sobj_at(BOULDER,x,y) && !t_at(x,y);
X	tmp3 = !(is_pool(x,y) &&
X	       !(Levitation || Wwalking
X#ifdef POLYSELF
X		 || is_flyer(uasmon)
X#endif
X		)) &&
X	       !(IS_DOOR(levl[x][y].typ) &&
X		     (levl[x][y].doormask & (D_LOCKED | D_CLOSED)));
X	return(tmp1 && tmp2 && tmp3);
X#else
X	return( isok(x,y) &&
X#  ifdef POLYSELF
X		(!IS_ROCK(levl[x][y].typ) || passes_walls(uasmon)) &&
X#  else
X		!IS_ROCK(levl[x][y].typ) &&
X#  endif
X		!levl[x][y].mmask &&
X		!sobj_at(BOULDER,x,y) && !t_at(x,y) &&
X		!(is_pool(x,y) &&
X		!(Levitation || Wwalking
X#ifdef POLYSELF
X		  || is_flyer(uasmon)
X#endif
X		  )) &&
X		!(IS_DOOR(levl[x][y].typ) &&
X		     (levl[x][y].doormask & (D_LOCKED | D_CLOSED)))
X	);
X#endif
X	/* Note: gold is permitted (because of vaults) */
X}
X
Xstatic void
Xvtele() {
X	register struct mkroom *croom;
X
X	for(croom = &rooms[0]; croom->hx >= 0; croom++)
X	    if(croom->rtype == VAULT) {
X		register int x, y;
X
X		x = rn2(2) ? croom->lx : croom->hx;
X		y = rn2(2) ? croom->ly : croom->hy;
X		if(teleok(x,y)) {
X		    teleds(x,y);
X		    return;
X		}
X	    }
X	tele();
X}
X
Xvoid
Xdotrap(trap)
Xregister struct trap *trap;
X{
X	register int ttype = trap->ttyp;
X	register struct monst *mtmp;
X	register struct obj *otmp;
X
X	nomul(0);
X	if(trap->tseen && !Fumbling && !(ttype == PIT
X	   || ttype == SPIKED_PIT
X#ifdef SPELLS
X	   || ttype == ANTI_MAGIC
X#endif
X		) && !rn2(5))
X		You("escape a%s.", traps[ttype]);
X	else {
X	    trap->tseen = 1;
X	    if(Invisible && ttype != MONST_TRAP)
X		newsym(trap->tx,trap->ty);
X	    switch(ttype) {
X		case SLP_GAS_TRAP:
X		    if(Sleep_resistance) {
X			You("are enveloped in a cloud of gas!");
X			break;
X		    }
X		    pline("A cloud of gas puts you to sleep!");
X		    flags.soundok = 0;
X		    nomul(-rnd(25));
X		    afternmv = Hear_again;
X		    break;
X		case BEAR_TRAP:
X		    if(Levitation
X#ifdef POLYSELF
X			|| is_flyer(uasmon)
X#endif
X			) {
X			You("%s over a bear trap.",
X			      Levitation ? "float" : "fly");
X			break;
X		    }
X		    u.utrap = 4 + rn2(4);
X		    u.utraptype = TT_BEARTRAP;
X		    pline("A bear trap closes on your %s!",
X			body_part(FOOT));
X#ifdef POLYSELF
X		    if(u.umonnum == PM_OWLBEAR)
X			You("howl in anger!");
X#endif
X		    break;
X		case STATUE_TRAP:
X		    for(otmp=fobj; otmp; otmp=otmp->nobj) {
X			if(otmp->otyp == STATUE && otmp->ox == u.ux &&
X				otmp->oy == u.uy && otmp->corpsenm == trap->pm)
X			    if(mtmp=makemon(&mons[trap->pm],u.ux,u.uy)) {
X				pline("The statue comes to life!");
X				delobj(otmp);
X				break;
X			    }
X		    }
X		    deltrap(trap);
X		    break;
X		case MONST_TRAP:
X		    if(mtmp=makemon(&mons[trap->pm],u.ux,u.uy)) {
X		      switch(mtmp->data->mlet) {
X			case S_PIERCER:
X			    pline("%s suddenly drops from the ceiling!",
X				  Xmonnam(mtmp));
X			    if(uarmh)
X				pline("Its blow glances off your helmet.");
X			    else
X				(void) thitu(3,d(4,6),"falling piercer");
X			    break;
X			default:	/* monster surprises you. */
X			    pline("%s attacks you by surprise!",
X				  Xmonnam(mtmp));
X			    break;
X		      }
X		    }
X		    deltrap(trap);
X		    break;
X		case ARROW_TRAP:
X		    pline("An arrow shoots out at you!");
X		    if(!thitu(8,rnd(6),"arrow")){
X			(void) mksobj_at(ARROW, u.ux, u.uy);
X			fobj->quan = 1;
X			fobj->owt = weight(fobj);
X		    }
X		    break;
X		case TRAPDOOR:
X		    if(is_maze_lev
X#ifdef STRONGHOLD
X		 	 && (dlevel > stronghold_level)
X#endif /* STRONGHOLD /**/
X		      ) {
X	pline("A trap door in the ceiling opens and a rock falls on your %s!",
X				body_part(HEAD));
X			if(uarmh)
X			    pline("Fortunately, you are wearing a helmet!");
X			losehp(uarmh ? 2 : d(2,10),"falling rock");
X			(void) mksobj_at(ROCK, u.ux, u.uy);
X			fobj->quan = 1;
X			fobj->owt = weight(fobj);
X			stackobj(fobj);
X			if(Invisible) newsym(u.ux, u.uy);
X		    } else {
X			register int newlevel = dlevel + 1;
X			while(!rn2(4) && newlevel < 29) newlevel++;
X			pline("A trap door opens up under you!");
X			if(Levitation || u.ustuck || dlevel == MAXLEVEL
X#ifdef POLYSELF
X					|| is_flyer(uasmon)
X#endif
X#ifdef ENDGAME
X					|| dlevel == ENDLEVEL
X#endif
X							) {
X			    You("don't fall in.");
X			    break;
X			}
X#ifdef WALKIES
X			if(!next_to_u())
X			    You("are jerked back by your pet!");
X			else {
X#endif
X			    unsee();
X			    (void) fflush(stdout);
X			    goto_level(newlevel, FALSE);
X#ifdef WALKIES
X			}
X#endif
X		    }
X		    break;
X		case DART_TRAP:
X		    pline("A little dart shoots out at you!");
X		    if(thitu(7,rnd(3),"little dart")) {
X			if(!rn2(6)) poisoned("dart",A_CON,"poison dart");
X		    } else {
X			(void) mksobj_at(DART, u.ux, u.uy);
X			fobj->quan = 1;
X			fobj->opoisoned = 1;
X			fobj->owt = weight(fobj);
X		    }
X		    break;
X		case TELEP_TRAP:
X		    if(trap->once) {
X			deltrap(trap);
X#ifdef ENDGAME
X			if(dlevel == ENDLEVEL) {
X			    You("feel a wrenching sensation.");
X			    break;
X			}
X#endif
X			if(Antimagic) {
X			    shieldeff(u.ux, u.uy);
X			    You("feel a wrenching sensation.");
X			} else {
X			    newsym(u.ux, u.uy);
X			    vtele();
X			}
X		    } else {
X#ifdef ENDGAME
X			if(dlevel == ENDLEVEL) {
X			    pline("A shiver runs down your spine...");
X			    break;
X			}
X#endif
X			if(Antimagic) {
X			    shieldeff(u.ux, u.uy);
X			    You("feel a wrenching sensation.");
X			} else {
X			    newsym(u.ux, u.uy);
X			    tele();
X			}
X		    }
X		    break;
X		case RUST_TRAP:
X#ifdef POLYSELF
X#ifdef GOLEMS
X		    if (u.umonnum == PM_IRON_GOLEM) {
X			pline("A gush of water hits you!");
X			You("are covered with rust!");
X			rehumanize();
X			break;
X		    }
X#endif /* GOLEMS */
X#endif
X		/* Unlike monsters, traps cannot aim their rust attacks at
X		 * you, so instead of looping through and taking either the
X		 * first rustable one or the body, we take whatever we get,
X		 * even if it is not rustable.
X		 */
X		    switch (rn2(5)) {
X			case 0:
X			    pline("A gush of water hits you on the %s!",
X					body_part(HEAD));
X			    (void) rust_dmg(uarmh, "helmet", 1, TRUE);
X			    break;
X			case 1:
X			    pline("A gush of water hits your left %s!",
X					body_part(ARM));
X			    if (rust_dmg(uarms, "shield", 1, TRUE)) break;
X			    if (uwep && bimanual(uwep))
X				goto two_hand;
X			    /* Two goto statements in a row--aaarrrgggh! */
Xglovecheck:		    (void) rust_dmg(uarmg, "gauntlets", 1, TRUE);
X			    /* Not "metal gauntlets" since it gets called
X			     * even if it's leather for the message
X			     */
X			    break;
X			case 2:
X			    pline("A gush of water hits your right %s!",
X					body_part(ARM));
Xtwo_hand:		    corrode_weapon();
X			    goto glovecheck;
X			default:
X			    pline("A gush of water hits you!");
X			    if (uarmc) (void) rust_dmg(uarmc, "cloak", 1, TRUE);
X			    else if (uarm)
X				(void) rust_dmg(uarm, "armor", 1, TRUE);
X#ifdef SHIRT
X			    else if (uarmu)
X				(void) rust_dmg(uarmu, "shirt", 1, TRUE);
X#endif
X		    }
X		    break;
X		case PIT:
X		    if (Levitation
X#ifdef POLYSELF
X			|| is_flyer(uasmon) || u.umonnum == PM_WUMPUS
X#endif
X			) {
X			pline("A pit opens up under you!");
X			You("don't fall in!");
X			break;
X		    }
X		    You("fall into a pit!");
X#ifdef POLYSELF
X		    if (!passes_walls(uasmon))
X#endif
X			u.utrap = rn1(6,2);
X		    u.utraptype = TT_PIT;
X		    losehp(rnd(6),"fall into a pit");
X		    selftouch("Falling, you");
X		    break;
X		case SPIKED_PIT:
X		    if (Levitation
X#ifdef POLYSELF
X			|| is_flyer(uasmon) || u.umonnum == PM_WUMPUS
X#endif
X			) {
X			pline("A pit full of spikes opens up under you!");
X			You("don't fall in!");
X			break;
X		    }
X		    You("fall into a pit!");
X		    You("land on a set of sharp iron spikes!");
X#ifdef POLYSELF
X		    if (!passes_walls(uasmon))
X#endif
X			u.utrap = rn1(6,2);
X		    u.utraptype = TT_PIT;
X		    losehp(rnd(10),"fall onto iron spikes");
X		    if(!rn2(6)) poisoned("spikes",A_STR,"poison spikes");
X		    selftouch("Falling, you");
X		    break;
X		case LEVEL_TELEP:
X		    pline("You have %s onto a level teleport trap!",
X#ifdef POLYSELF
X			is_flyer(uasmon) ? "flown" :
X			(Levitation || nolimbs(uasmon)) ? "moved" : "stepped");
X#else
X			Levitation ? "moved" : "stepped");
X#endif
X		    if(Antimagic)
X			shieldeff(u.ux, u.uy);
X		    if(Antimagic
X#ifdef ENDGAME
X				|| dlevel == ENDLEVEL
X#endif
X							) {
X			You("feel a wrenching sensation.");
X			break;
X		    }
X		    if(!Blind)
X		      You("are momentarily blinded by a flash of light.");
X		    else
X			You("are momentarily disoriented.");
X		    deltrap(trap);
X		    newsym(u.ux,u.uy);
X		    level_tele();
X		    break;
X#ifdef SPELLS
X		case ANTI_MAGIC:
X		    if(Antimagic) {
X			shieldeff(u.ux, u.uy);
X			You("feel momentarily lethargic.");
X		    } else drain_en(rnd((int)u.ulevel) + 1);
X		    break;
X#endif
X#ifdef POLYSELF
X		case POLY_TRAP:
X		    if(Antimagic) {
X			shieldeff(u.ux, u.uy);
X			You("feel momentarily different.");
X			/* Trap did nothing; don't remove it --KAA */
X		    } else {
X			You("feel a change coming over you.");
X			polyself();
X			deltrap(trap);
X		    }
X		    break;
X#endif
X		case MGTRP:	    /* A magic trap. */
X		    if (!rn2(30)) {
X			You("are caught in a magical explosion!");
X			losehp(rnd(10), "magical explosion");
X#ifdef SPELLS
X			Your("body absorbs some of the magical energy!");
X			u.uen = (u.uenmax += 2);
X#endif
X			deltrap(trap);
X			if(Invisible) newsym(u.ux,u.uy);
X		    } else domagictrap();
X		    break;
X		case SQBRD:	    /* Stepped on a squeaky board. */
X		    if (Levitation
X#ifdef POLYSELF
X			|| is_flyer(uasmon)
X#endif
X			) {
X			if (Hallucination) You("notice a crease in the linoleum.");
X			else You("notice a loose board below you.");
X		    } else {
X			pline("A board underfoot gives off a loud squeak!");
X			wake_nearby();
X		    }
X		    break;
X		case WEB: /* Our luckless player has stumbled into a web. */
X
X		    pline("You've %s into a spider web!",
X			  Levitation ? "floated" :
X#ifdef POLYSELF
X			  is_flyer(uasmon) ? "flown" :
X#endif
X			  "stumbled");
X		    u.utraptype = TT_WEB;
X
X		    /* Time stuck in the web depends on your strength. */
X
X		    if (ACURR(A_STR) == 3) u.utrap = rn1(6,6);
X		    else if (ACURR(A_STR) < 6) u.utrap = rn1(6,4);
X		    else if (ACURR(A_STR) < 9) u.utrap = rn1(4,4);
X		    else if (ACURR(A_STR) < 12) u.utrap = rn1(4,2);
X		    else if (ACURR(A_STR) < 15) u.utrap = rn1(2,2);
X		    else if (ACURR(A_STR) < 18) u.utrap = rnd(2);
X		    else if (ACURR(A_STR) < 69) u.utrap = 1;
X		    else {
X			u.utrap = 0;
X			You("tear through the web!");
X			deltrap(trap);
X	   		if(Invisible) newsym(u.ux,u.uy);
X		    }
X		    break;
X
X		case LANDMINE: {
X#		ifndef LINT
X		    register struct monst *mtmp = fmon;
X#		endif /* LINT */
X
X		    if (Levitation
X#ifdef POLYSELF
X						|| is_flyer(uasmon)
X#endif
X								) {
X			You("see a trigger in a pile of soil below you!");
X			if (rn2(3)) break;
X			pline("KAABLAMM!!!  The air currents set it off!");
X		    } else {
X#ifdef POLYSELF
X			pline("KAABLAMM!!!  You %s a land mine!",
X				nolimbs(uasmon) ? "encountered" : "stepped on");
X#else
X			pline("KAABLAMM!!!  You stepped on a land mine!");
X#endif
X			set_wounded_legs(LEFT_SIDE, 40 + rnd(35));
X			set_wounded_legs(RIGHT_SIDE, 40 + rnd(35));
X		    }
X		    losehp(rnd(16), "land mine");
X		    /* wake everything on the level */
X		    while(mtmp) {
X			if(mtmp->msleep) mtmp->msleep = 0;
X			mtmp = mtmp->nmon;
X		    }
X		    deltrap(t_at(u.ux, u.uy)); /* mines only explode once */
X		    if(Invisible) newsym(u.ux,u.uy);
X		    }
X		    break;
X		default:
X		    impossible("You hit a trap of type %u", trap->ttyp);
X	    }
X	}
X}
X
X#ifdef WALKIES
Xstatic boolean
Xteleport_pet(mtmp)
Xregister struct monst *mtmp;
X{
X	register struct obj *otmp;
X
X	if(mtmp->mleashed) {
X	    otmp = get_mleash(mtmp);
X	    if(!otmp)
X		impossible("%s is leashed, without a leash.", Monnam(mtmp));
X	    if(otmp->cursed) {
X# ifdef SOUNDS
X		yelp(mtmp);
X# endif
X		return FALSE;
X	    } else {
X		Your("leash goes slack.");
X		m_unleash(mtmp);
X		return TRUE;
X	    }
X	}
X	return TRUE;
X}
X#endif
X
Xint
Xmintrap(mtmp)
Xregister struct monst *mtmp;
X{
X	register struct trap *trap = t_at(mtmp->mx, mtmp->my);
X	register int newlev, wasintrap = mtmp->mtrapped;
X	register boolean trapkilled = FALSE, tdoor = FALSE;
X	struct obj *otmp;
X
X	if(!trap) {
X		mtmp->mtrapped = 0;	/* perhaps teleported? */
X	} else if(wasintrap) {
X		if(!rn2(40)) mtmp->mtrapped = 0;
X	} else {
X	    register int tt = trap->ttyp;
X
X	/* A bug fix for dumb messages by ab@unido.
X	 */
X	    int in_sight = cansee(mtmp->mx,mtmp->my)
X			   && (!mtmp->minvis || See_invisible);
X
X	    if(mtmp->mtrapseen & (1 << tt)) {
X		/* he has been in such a trap - perhaps he escapes */
X		if(rn2(4)) return(0);
X	    }
X	    mtmp->mtrapseen |= (1 << tt);
X	    switch (tt) {
X		case BEAR_TRAP:
X			if(bigmonst(mtmp->data)) {
X				if(in_sight)
X				  pline("%s is caught in a bear trap!",
X					Monnam(mtmp));
X				else
X				    if(mtmp->data == &mons[PM_OWLBEAR]
X					&& flags.soundok)
X			    You("hear the roaring of an angry bear!");
X				mtmp->mtrapped = 1;
X			}
X			break;
X#ifdef POLYSELF
X		case POLY_TRAP:
X		    if(!resist(mtmp, WAND_SYM, 0, NOTELL))
X			(void) newcham(mtmp, (struct permonst *)0);
X		    break;
X#endif
X		case RUST_TRAP:
X			if(in_sight)
X				pline("A gush of water hits %s!", mon_nam(mtmp));
X#ifdef GOLEMS
X			if (mtmp->data == &mons[PM_IRON_GOLEM]) {
X				if (in_sight) pline("%s falls to pieces!",
X								Monnam(mtmp));
X				else if(mtmp->mtame)
X				     pline("May %s rust in peace.",
X								mon_nam(mtmp));
X				mondied(mtmp);
X				trapkilled = TRUE;
X			}
X#endif /* GOLEMS */
X			break;
X		case PIT:
X		case SPIKED_PIT:
X			/* there should be a mtmp/data -> floating */
X			if(!is_flyer(mtmp->data) /* ab */
X			   && mtmp->data != &mons[PM_WUMPUS] /* 3. */) {
X				if (!passes_walls(mtmp->data))
X				  mtmp->mtrapped = 1;
X				if(in_sight)
X				  pline("%s falls into a pit!", Monnam(mtmp));
X				if(thitm(0, mtmp, (struct obj *)0,
X				  rnd((tt==PIT) ? 6 : 10)))
X				  trapkilled = TRUE;
X			}
X			break;
X		case SLP_GAS_TRAP:
X			if(!resists_sleep(mtmp->data) &&
X			   !mtmp->msleep && !mtmp->mfroz) {
X				mtmp->msleep = 1;
X				if(in_sight)
X				  pline("%s suddenly falls asleep!",
X					Monnam(mtmp));
X			}
X			break;
X		case TELEP_TRAP:
X#ifdef WALKIES
X			if(teleport_pet(mtmp)) {
X#endif
X			    rloc(mtmp);
X			    if(in_sight && !cansee(mtmp->mx,mtmp->my))
X				pline("%s suddenly disappears!",
X					Monnam(mtmp));
X#ifdef WALKIES
X			}
X#endif
X			break;
X		case ARROW_TRAP:
X			otmp = mksobj(ARROW, FALSE);
X			otmp->quan = 1;
X			otmp->owt = weight(otmp);
X			if(thitm(8, mtmp, otmp, 0)) trapkilled = TRUE;
X			break;
X		case DART_TRAP:
X			otmp = mksobj(DART, FALSE);
X			otmp->quan = 1;
X			otmp->owt = weight(otmp);
X			if(thitm(7, mtmp, otmp, 0)) trapkilled = TRUE;
X			break;
X		case TRAPDOOR:
X			if(is_maze_lev
X#ifdef STRONGHOLD
X			   && (dlevel > stronghold_level && dlevel < MAXLEVEL)
X#endif
X			  ) {
X				otmp = mksobj(ROCK, FALSE);
X				otmp->quan = 1;
X				otmp->owt = weight(otmp);
X				if(thitm(0, mtmp, otmp, d(2, 10)))
X					trapkilled = TRUE;
X				break;
X			}
X			tdoor = TRUE;
X			/* Fall through */
X		case LEVEL_TELEP:
X			if(!is_flyer(mtmp->data)
X#ifdef WORM
X				&& !mtmp->wormno
X			    /* long worms cannot be allowed to change levels */
X#endif
X			    ){
X#ifdef WALKIES
X			    if(teleport_pet(mtmp)) {
X#endif
X				if(tdoor)
X				    fall_down(mtmp, dlevel+1);
X				else {
X				    newlev = rnd(3);
X				    if(!rn2(2)) newlev = -(newlev);
X				    newlev = dlevel + newlev;
X				    if(newlev > MAXLEVEL) {
X					if(dlevel != MAXLEVEL)
X					    newlev = MAXLEVEL;
X					else newlev = MAXLEVEL - rnd(3);
X				    }
X				    if(newlev < 1) {
X					if(dlevel != 1) newlev = 1;
X					else newlev = 1 + rnd(3);
X				    }
X				    fall_down(mtmp, newlev);
X				}
X				if(in_sight)
X		pline("Suddenly, %s disappears out of sight.", mon_nam(mtmp));
X				return(2);	/* no longer on this level */
X#ifdef WALKIES
X			    }
X#endif
X			}
X			break;
X		case MONST_TRAP:
X		case STATUE_TRAP:
X			break;
X		case MGTRP:
X			/* A magic trap.  Monsters immune. */
X			break;
X		case SQBRD: {
X			register struct monst *ztmp = fmon;
X
X			if(is_flyer(mtmp->data)) break;
X			/* Stepped on a squeaky board. */
X			if (in_sight)
X			   pline("%s steps on a squeaky board.", Monnam(mtmp));
X			else
X			   You("hear a distant squeak.");
X			/* Wake up nearby monsters. */
X		       while(ztmp) {
X			 if(dist2(mtmp->mx,mtmp->my,ztmp->mx,ztmp->my) < 40)
X			       if(ztmp->msleep) ztmp->msleep = 0;
X			 ztmp = ztmp->nmon;
X		       }
X			break;
X		}
X	       case WEB:
X		       /* Monster in a web. */
X			/* in_sight check and confused bear by Eric Backus */
X		       if(mtmp->data->mlet != S_SPIDER) {
X			 if(in_sight)
X				pline("%s is caught in a web!", Monnam(mtmp));
X			  else
X			    if(mtmp->data == &mons[PM_OWLBEAR])
X			      You("hear the roaring of a confused bear!");
X			 mtmp->mtrapped = 1;
X		       }
X		      break;
X#ifdef SPELLS
X		case ANTI_MAGIC:	break;
X#endif
X		case LANDMINE: {
X			register struct monst *mntmp = fmon;
X
X			if(rn2(3))
X				break; /* monsters usually don't set it off */
X			if(in_sight)
X				pline("KAABLAMM!!!  %s steps on a land mine!",
X				      Monnam(mtmp));
X			else if (flags.soundok)
X				pline("Kaablamm!  You hear an explosion in the distance!");
X			deltrap(t_at(mtmp->mx, mtmp->my));
X			if(thitm(0, mtmp, (struct obj *)0, rnd(16)))
X				trapkilled = TRUE;
X			/* wake everything on the level */
X			while(mntmp) {
X				if(mntmp->msleep)
X					mntmp->msleep = 0;
X				mntmp = mntmp->nmon;
X			}
X			break;
X		}
X		default:
X			impossible("Some monster encountered a strange trap of type %d.",tt);
X	    }
X	}
X	if(trapkilled) return 2;
X	else return mtmp->mtrapped;
X}
X
Xvoid
Xselftouch(arg)
Xchar *arg;
X{
X	if(uwep && (uwep->otyp == CORPSE && uwep->corpsenm == PM_COCKATRICE)
X#ifdef POLYSELF
X			&& !resists_ston(uasmon)
X#endif
X	){
X		pline("%s touch the cockatrice corpse.", arg);
X		You("turn to stone...");
X		killer = "cockatrice corpse accident";
X		done("stoned");
X	}
X}
X
Xvoid
Xfloat_up() {
X	if(u.utrap) {
X		if(u.utraptype == TT_PIT) {
X			u.utrap = 0;
X			You("float up, out of the pit!");
X		} else {
X			You("float up, only your %s is still stuck.",
X				body_part(LEG));
X		}
X	} else
X		if (Hallucination)
X			pline("Oh wow!  You're floating in the air!");
X		else
X			You("start to float in the air!");
X}
X
Xint
Xfloat_down() {
X	register struct trap *trap;
X
X	if(Levitation) return(0); /* maybe another ring/potion/boots */
X
X	/* check for falling into pool - added by GAN 10/20/86 */
X	if(is_pool(u.ux,u.uy) && !(Wwalking
X#ifdef POLYSELF
X				    || is_flyer(uasmon)
X#endif
X				    ))
X		drown();
X
X	You("float gently to the ground.");
X	if(trap = t_at(u.ux,u.uy))
X		switch(trap->ttyp) {
X		case MONST_TRAP:
X		case STATUE_TRAP:
X			break;
X		case TRAPDOOR:
X			if(is_maze_lev
X#ifdef STRONGHOLD
X			   && (dlevel >= stronghold_level || dlevel < MAXLEVEL)
X#endif
X			   || u.ustuck) break;
X			/* fall into next case */
X		default:
X			dotrap(trap);
X	}
X	if(!flags.nopick && (levl[u.ux][u.uy].omask || levl[u.ux][u.uy].gmask))
X	    pickup(1);
X	return 0;
X}
X
X
Xvoid
Xtele() {
X	coord cc;
X	register int nux,nuy;
X
X#ifdef STRONGHOLD
X	/* Disable teleportation in stronghold && Vlad's Tower */
X	if(dlevel == stronghold_level ||
X# ifdef ENDGAME
X	   dlevel == ENDLEVEL ||
X# endif
X	   (dlevel >= tower_level && dlevel <= tower_level + 2)) {
X# ifdef WIZARD
X		if (!wizard) {
X# endif
X		    pline("A mysterious force prevents you from teleporting!");
X		    return;
X# ifdef WIZARD
X		}
X# endif
X	}
X#endif /* STRONGHOLD /**/
X	if((u.uhave_amulet || dlevel == wiz_level) && !rn2(3)) {
X	    You("feel disoriented for a moment.");
X	    return;
X	}
X	if(Teleport_control) {
X	    if (unconscious())
X		pline("Being unconscious, you cannot control your teleport.");
X	    else {
X		    pline("To what position do you want to be teleported?");
X		    getpos(&cc, 1, "the desired position"); /* 1: force valid */
X		    /* possible extensions: introduce a small error if
X		       magic power is low; allow transfer to solid rock */
X		    if(teleok(cc.x, cc.y)){
X			teleds(cc.x, cc.y);
X			return;
X		    }
X		    pline("Sorry...");
X		}
X	}
X	do {
X		nux = rnd(COLNO-1);
X		nuy = rn2(ROWNO);
X	} while(!teleok(nux, nuy));
X	teleds(nux, nuy);
X}
X
Xvoid
Xteleds(nux, nuy)
Xregister int nux,nuy;
X{
X	if(Punished) unplacebc();
X	unsee();
X	u.utrap = 0;
X	u.ustuck = 0;
X	u.ux = nux;
X	u.uy = nuy;
X#ifdef POLYSELF
X	if (hides_under(uasmon))
X		u.uundetected = (levl[nux][nuy].omask || levl[nux][nuy].gmask);
X	else 
X		u.uundetected = 0;
X	if (u.usym == S_MIMIC_DEF) u.usym = S_MIMIC;
X#endif
X	setsee();
X	if(Punished) placebc(1);
X	if(u.uswallow){
X		u.uswldtim = u.uswallow = 0;
X		docrt();
X	}
X	nomul(0);
X	spoteffects();
X}
X
Xint
Xdotele()
X{
X	struct trap *trap;
X#ifdef SPELLS
X	boolean castit = FALSE;
X	register int sp_no;
X#endif
X
X	trap = t_at(u.ux, u.uy);
X	if (trap && (!trap->tseen || trap->ttyp != TELEP_TRAP || trap->once))
X		trap = 0;
X
X	if (trap) 
X		You("jump onto the teleportation trap...");
X	else if(!Teleportation ||
X	   (u.ulevel < (pl_character[0] == 'W' ? 8 : 12)
X#ifdef POLYSELF
X	    && !can_teleport(uasmon)
X#endif
X	   )
X	  ) {
X#ifdef SPELLS
X		/* Try to use teleport away spell. */
X		castit = objects[SPE_TELEPORT_AWAY].oc_name_known;
X		if (castit) {
X		    for (sp_no = 0; sp_no < MAXSPELL &&
X				spl_book[sp_no].sp_id != NO_SPELL &&
X				spl_book[sp_no].sp_id != SPE_TELEPORT_AWAY; sp_no++);
X
X		    if (sp_no == MAXSPELL ||
X			spl_book[sp_no].sp_id != SPE_TELEPORT_AWAY)
X			    castit = FALSE;
X		}
X#endif
X#ifdef WIZARD
X		if (!wizard) {
X#endif
X#ifdef SPELLS
X		    if (!castit) {
X			if (!Teleportation)
X			    You("don't know that spell.");
X			else
X#endif
X			    You("are not able to teleport at will.");
X			return(0);
X#ifdef SPELLS
X		    }
X#endif
X#ifdef WIZARD
X		}
X#endif
X	}
X
X	if(!trap && (u.uhunger <= 100 || ACURR(A_STR) < 6)) {
X		You("lack the strength for a teleport spell.");
X#ifdef WIZARD
X		if(!wizard)
X#endif
X		return(1);
X	}
X
X#ifdef SPELLS
X	if (castit)
X# ifdef WIZARD
X		if (!spelleffects(++sp_no, TRUE) && !wizard) return(0);
X# else
X		return spelleffects(++sp_no, TRUE);
X# endif
X#endif
X
X#ifdef WALKIES
X	if(next_to_u()) {
X#endif
X		tele();
X#ifdef WALKIES
X		(void) next_to_u();
X	} else {
X		You("shudder for a moment.");
X		return(0);
X	}
X#endif
X	if (!trap) morehungry(100);
X	return(1);
X}
X
Xvoid
Xplacebc(attach)
Xint attach;
X{
X	if(!uchain || !uball){
X		impossible("Where are your chain and ball??");
X		return;
X	}
X	uball->ox = uchain->ox = u.ux;
X	uball->oy = uchain->oy = u.uy;
X	levl[u.ux][u.uy].omask = 1;
X	if(attach){
X		uchain->nobj = fobj;
X		fobj = uchain;
X		if(!carried(uball)){
X			uball->nobj = fobj;
X			fobj = uball;
X		}
X	}
X}
X
Xvoid
Xunplacebc(){
X	if(!carried(uball)){
X		freeobj(uball);
X		unpobj(uball);
X	}
X	freeobj(uchain);
X	unpobj(uchain);
X}
X
Xvoid
Xlevel_tele() {
Xregister int newlevel;
X#ifdef WALKIES
Xregister boolean pet_by_u = next_to_u();
X#endif
X
X	if(u.uhave_amulet
X#ifdef ENDGAME
X		|| dlevel == ENDLEVEL
X#endif
X	) {
X	    You("feel very disoriented for a moment.");
X	    return;
X	}
X	if(Teleport_control
X#ifdef WIZARD
X	   || wizard
X#endif
X		) {
X	    char buf[BUFSZ];
X
X	    do {
X	      pline("To what level do you want to teleport? [type a number] ");
X	      getlin(buf);
X	    } while(!digit(buf[0]) && (buf[0] != '-' || !digit(buf[1])));
X	    newlevel = atoi(buf);
X	} else {
X	    newlevel = rn2(5) | !Fire_resistance ? rnd(dlevel + 3) :
X#ifdef STRONGHOLD
X		stronghold_level + 1;
X#else
X		HELLLEVEL;
X#endif
X	    if(dlevel == newlevel)
X		if(is_maze_lev) newlevel--; else newlevel++;
X	}
X	if(newlevel < 0) {
X#ifdef WALKIES
X	    if(pet_by_u) {
X#endif
X		if(newlevel <= -10) {
X			You("arrive in heaven.");
X			pline("\"You are here a bit early, but we'll let you in.\"");
X			killer = "visit to heaven";
X			done("died");
X		} else	if (newlevel == -9) {
X			You("feel deliriously happy. ");
X			pline("(In fact, you're on Cloud 9!) ");
X			more();
X		} else
X#ifndef STRONGHOLD
X			newlevel = 0;
X#else
X			newlevel = 1;
X#endif
X		You("are now high above the clouds...");
X		if(Levitation) {
X		    You("float gently down to earth.");
X#ifndef STRONGHOLD
X		    done("escaped");
X#endif
X		}
X#ifdef POLYSELF
X		if(is_flyer(uasmon)) {
X		    You("fly down to earth.");
X# ifndef STRONGHOLD
X		    done("escaped");
X# endif
X		}
X#endif
X		pline("Unfortunately, you don't know how to fly.");
X		You("plummet a few thousand feet to your death.");
X		dlevel = 0;
X		killer = "long fall";
X		done("died");
X#ifdef WALKIES
X	    } else {
X		You("shudder for a moment...");
X		return;
X	    }
X#endif
X	}
X	/* calls done("escaped") if newlevel==0 */
X#ifdef WALKIES
X	if(!pet_by_u)
X	    You("shudder for a moment...");
X	else
X#endif
X	    goto_level(newlevel, FALSE);
X}
X
Xvoid
Xdomagictrap() {
X	register int fate = rnd(20);
X
X	/* What happened to the poor sucker? */
X
X	if (fate < 10) {
X
X	  /* Most of the time, it creates some monsters. */
X	  register int cnt = rnd(4);
X
X	  /* below checks for blindness added by GAN 10/30/86 */
X	  if (!Blind)  {
X		You("are momentarily blinded by a flash of light!");
X		make_blinded((long)rn1(5,10),FALSE);
X	  }  else
X		You("hear a deafening roar!");
X	  while(cnt--)
X	   (void) makemon((struct permonst *) 0, u.ux, u.uy);
X	}
X	else
X	  switch (fate) {
X
X	     case 10:
X	     case 11:
X		      /* sometimes nothing happens */
X			break;
X	     case 12:
X		      /* a flash of fire */
X		      {
X			register int num;
X
X			/* changed to be in conformance with
X			 * SCR_FIRE by GAN 11/02/86
X			 */
X
X			pline("A tower of flame bursts from the floor!");
X			if(Fire_resistance) {
X				shieldeff(u.ux, u.uy);
X				You("are uninjured.");
X				break;
X			} else {
X				num = rnd(6);
X				u.uhpmax -= num;
X				losehp(num,"a burst of flame");
X				break;
X			}
X		      }
X
X	     /* odd feelings */
X	     case 13:   pline("A shiver runs up and down your spine!");
X			break;
X	     case 14:   You("hear distant howling.");
X			break;
X	     case 15:   You("suddenly yearn for your distant homeland.");
X			break;
X	     case 16:   Your("pack shakes violently!");
X			break;
X	     case 17:	You("smell charred flesh.");
X			break;
X
X	     /* very occasionally something nice happens. */
X
X	     case 19:
X		    /* tame nearby monsters */
X		   {   register int i,j;
X		       register boolean confused = (Confusion != 0);
X		       register int bd = confused ? 5 : 1;
X
X		       /* below pline added by GAN 10/30/86 */
X		       adjattrib(A_CHA,1,FALSE);
X		       for(i = -bd; i <= bd; i++) for(j = -bd; j <= bd; j++)
X		       if(levl[u.ux+i][u.uy+j].mmask)
X			   (void) tamedog(m_at(u.ux+i, u.uy+j), (struct obj *)0);
X		       break;
X		   }
X
X	     case 20:
X		    /* uncurse stuff */
X		   {  register struct obj *obj;
X		      register boolean confused = (Confusion != 0);
X
X			/* below plines added by GAN 10/30/86 */
X			if (confused)
X			    if (Hallucination)
X				You("feel the power of the Force against you!");
X			    else
X				You("feel like you need some help.");
X			else
X			    if (Hallucination)
X				You("feel in touch with the Universal Oneness.");
X			    else
X				You("feel like someone is helping you.");
X		       for(obj = invent; obj ; obj = obj->nobj)
X			       if(obj->owornmask)
X				    if(confused)
X					curse(obj);
X				    else
X					obj->cursed = 0;
X		       if(Punished && !confused)
X			    unpunish();
X		       break;
X		   }
X	     default: break;
X	  }
X}
X
Xvoid
Xdrown() {
X	register struct obj *obj;
X
X	/* Scrolls and potions get affected by the water */
X	for(obj = invent; obj; obj = obj->nobj) {
X		if(obj->olet == SCROLL_SYM && rn2(12) > u.uluck)
X			obj->otyp = SCR_BLANK_PAPER;
X		if(obj->olet == POTION_SYM && rn2(12) > u.uluck) {
X			if (obj->spe == -1) {
X				obj->otyp = POT_WATER;
X				obj->blessed = obj->cursed = 0;
X				obj->spe = 0;
X			} else obj->spe--;
X		}
X	}
X
X#ifdef POLYSELF
X	if(u.usym == S_GREMLIN && rn2(3)) {
X		struct monst *mtmp;
X		if(mtmp = cloneu()) {
X			mtmp->mhpmax = (u.mhmax /= 2);
X			You("multiply.");
X		}
X	}
X
X	if(is_swimmer(uasmon)) return;
X#endif
X
X	You("fell into %s!",
X	      levl[u.ux][u.uy].typ == POOL ? "a pool" : "the moat");
X	You("can't swim!");
X	if(
X#ifdef WIZARD
X	wizard ||
X#endif
X	rn2(3) < u.uluck+2) {
X		You("attempt a teleport spell.");	/* utcsri!carroll */
X		(void) dotele();
X		if(!is_pool(u.ux,u.uy)) return;
X	}
X	You("drown.");
X	killer = levl[u.ux][u.uy].typ == POOL ? "pool of water" : "moat";
X	done("drowned");
X}
X
X#ifdef SPELLS
Xvoid
Xdrain_en(n)
Xregister int n;
X{
X	if (!u.uenmax) return;
X	You("feel your magical energy drain away!");
X	u.uen -= n;
X	if(u.uen < 0)  {
X		u.uenmax += u.uen;
X		if(u.uenmax < 0) u.uenmax = 0;
X		u.uen = 0;
X	}
X	flags.botl = 1;
X}
X#endif
X
Xint
Xdountrap() {	/* disarm a trapped object */
X	register struct obj *otmp;
X	register boolean confused = (Confusion > 0);
X	register int x,y;
X	int ch;
X	struct trap *ttmp;
X
X#ifdef POLYSELF
X	if(nohands(uasmon)) {
X	    pline("And just how do you expect to do that?");
X	    return(0);
X	}
X#endif
X	if(!getdir(TRUE)) return(0);
X	x = u.ux + u.dx;
X	y = u.uy + u.dy;
X
X	if(!u.dx && !u.dy) {
X	    if(levl[x][y].omask)
X		for(otmp = fobj; otmp; otmp = otmp->nobj)
X		    if((otmp->ox == x) && (otmp->oy == y))
X			if(Is_box(otmp)) {
X			    pline("There is %s here, check for traps? ",
X				  doname(otmp));
X
X			    switch (ynq()) {
X				case 'q': return(0);
X				case 'n': continue;
X			    }
X
X			    if((otmp->otrapped && !confused && rn2(44-dlevel*2) < 10)
X			       || confused && !rn2(3)) {
X				You("find a trap on the %s!  Disarm it? ",
X				       xname(otmp));
X
X				switch (ynq()) {
X				    case 'q': return(1);
X				    case 'n': continue;
X				}
X
X				if(otmp->otrapped) {
X				    ch = 15 +
X					 (pl_character[0] == 'R') ? u.ulevel*3 :
X					 u.ulevel;
X				    if(confused || Fumbling || rnd(75+dlevel/2) > ch) {
X					You("set it off!");
X					chest_trap(otmp, FINGER);
X				    } else {
X					You("disarm it!");
X					otmp->otrapped = 0;
X				    }
X				} else pline("That %s was not trapped.",
X					     doname(otmp));
X				return(1);
X			    } else {
X				You("find no traps on the %s.",
X				    xname(otmp));
X				return(1);
X			    }
X			}
X	    if ((ttmp = t_at(x,y)) && ttmp->tseen)
X		You("cannot disable this trap.");
X	    else
X		You("know of no traps here.");
X	    return(0);
X	}
X
X	if (!IS_DOOR(levl[x][y].typ)) {
X	    if ((ttmp = t_at(x,y)) && ttmp->tseen)
X		You("cannot disable that trap.");
X	    else
X		You("know of no traps there.");
X	    return(0);
X	}
X
X	switch (levl[x][y].doormask) {
X	    case D_NODOOR:
X		You("%s no door there.", Blind ? "feel" : "see");
X		return(0);
X	    case D_ISOPEN:
X		pline("This door is safely open.");
X		return(0);
X	    case D_BROKEN:
X		pline("This door is broken.");
X		return(0);
X	}
X
X	if ((levl[x][y].doormask & D_TRAPPED && !confused &&
X	     rn2(44-dlevel*2) < 10)
X	    || confused && !rn2(3)) {
X		You("find a trap on the door!  Disarm it? ");
X		if (ynq() != 'y') return(1);
X		if (levl[x][y].doormask & D_TRAPPED) {
X		    ch = 15 +
X			 (pl_character[0] == 'R') ? u.ulevel*3 :
X			 u.ulevel;
X		    if(confused || Fumbling || rnd(75+dlevel/2) > ch) {
X			    You("set it off!");
X			    b_trapped("door");
X		    } else {
X			    You("disarm it!");
X			    levl[x][y].doormask &= ~D_TRAPPED;
X		    }
X		} else pline("This door was not trapped.");
X		return(1);
X	} else {
X		You("find no traps on the door.");
X		return(1);
X	}
X}
X
X/* this is only called when the player is doing something to the chest
X * -- i.e., the player and the chest are in the same position */
Xvoid
Xchest_trap(obj, bodypart)
Xregister struct obj *obj;
Xregister int bodypart;
X{
X	register struct obj *otmp,*otmp2;
X	char	buf[80];
X
X	if(rn2(13+u.uluck) > 7) return;
X
X	otmp = obj;
X	switch(rn2(13-u.uluck)) {	/* which trap? */
X		case 23:
X		case 22:
X		case 21:
X			pline("The %s explodes!", xname(obj));
X			Sprintf(buf, "exploding %s", xname(obj));
X
X			delete_contents(obj);
X			for(otmp = fobj; otmp; otmp = otmp2) {
X			    otmp2 = otmp->nobj;
X			    if((otmp->ox == u.ux) && (otmp->oy == u.uy))
X				delobj(otmp);
X			}
X
X			losehp(d(6,6), buf);
X			wake_nearby();
X			return;
X		case 20:
X		case 19:
X		case 18:
X		case 17:
X			pline("A cloud of noxious gas billows from the %s.",
X			      xname(obj));
X			poisoned("gas cloud", A_STR, "cloud of poison gas");
X			break;
X		case 16:
X		case 15:
X		case 14:
X		case 13:
X			pline("A tower of flame erupts from the %s",
X			      xname(obj));
X			if(Fire_resistance) {
X			    shieldeff(u.ux, u.uy);
X			    You("don't seem to be affected.");
X			} else	losehp(d(4, 6), "tower of flame");
X			destroy_item(SCROLL_SYM, AD_FIRE);
X#ifdef SPELLS
X			destroy_item(SPBOOK_SYM, AD_FIRE);
X#endif
X			destroy_item(POTION_SYM, AD_FIRE);
X			break;
X		case 12:
X		case 10:
X		case 9:
X			You("are jolted by a surge of electricity!");
X			if(Shock_resistance)  {
X			    shieldeff(u.ux, u.uy);
X			    You("don't seem to be affected.");
X			} else	losehp(d(4, 4), "electric shock");
X			destroy_item(RING_SYM, AD_ELEC);
X			destroy_item(WAND_SYM, AD_ELEC);
X			break;
X		case 8:
X		case 7:
X		case 6:
X			pline("Suddenly you are frozen in place!");
X			nomovemsg = "You can move again.";
X			multi = -d(5, 6);
X			break;
X		case 5:
X		case 4:
X		case 3:
X			pline("A cloud of %s gas billows from the %s",
X			      hcolor(), xname(obj));
X			if(!Stunned)
X			    if (Hallucination)
X				pline("What a groovy feeling!");
X			    else
X				You("stagger and your vision blurs...");
X			make_stunned(HStun + rn1(7, 16),FALSE);
X			make_hallucinated(Hallucination + rn1(5, 16),FALSE);
X			break;
X		default:
X			You("feel a needle prick your %s.",body_part(bodypart));
X			poisoned("needle", A_CON, "a poisoned needle");
X			break;
X	}
X	otmp->otrapped = 0;		/* these traps are one-shot things */
X}
X
Xvoid
Xwake_nearby() {			/* Wake up nearby monsters. */
X	register struct monst *mtmp;
X
X	for(mtmp = fmon; mtmp; mtmp = mtmp->nmon) {
X	    if(dist(mtmp->mx,mtmp->my) < u.ulevel*20) {
X		if(mtmp->msleep)  mtmp->msleep = 0;
X		if(mtmp->mtame)   EDOG(mtmp)->whistletime = moves;
X	    }
X	}
X}
X
Xstruct trap *
Xt_at(x,y)
Xregister int x, y;
X{
X	register struct trap *trap = ftrap;
X	while(trap) {
X		if(trap->tx == x && trap->ty == y) return(trap);
X		trap = trap->ntrap;
X	}
X	return((struct trap *)0);
X}
X
Xvoid
Xdeltrap(trap)
Xregister struct trap *trap;
X{
X	register struct trap *ttmp;
X
X	if(trap == ftrap)
X		ftrap = ftrap->ntrap;
X	else {
X		for(ttmp = ftrap; ttmp->ntrap != trap; ttmp = ttmp->ntrap) ;
X		ttmp->ntrap = trap->ntrap;
X	}
X	free((genericptr_t) trap);
X}
X
Xvoid
Xb_trapped(item)		/* used for doors. can be used */
Xregister char *item;    /* for anything else that opens */
X{
X	register int dmg = rn2(15) + rnd((int)u.ulevel);
X
X	pline("KABOOM!!  The %s was booby-trapped!", item);
X	make_stunned(HStun + dmg, TRUE);
X	losehp(dmg, "explosion");
X}
X
X/* Monster is hit by trap. */
X/* Note: doesn't work if both obj and d_override are null */
Xstatic boolean
Xthitm(tlev, mon, obj, d_override)
Xregister int tlev;
Xregister struct monst *mon;
Xregister struct obj *obj;
Xint d_override;
X{
X	register int strike;
X	register boolean trapkilled = FALSE;
X
X	if (d_override) strike = 1;
X	else if (obj) strike = (mon->data->ac + tlev + obj->spe <= rnd(20));
X	else strike = (mon->data->ac + tlev <= rnd(20));
X
X	/* Actually more accurate than thitu, which doesn't take
X	 * obj->spe into account.
X	 */
X	if(!strike) {
X		if (cansee(mon->mx, mon->my))
X			pline("%s is almost hit by %s!", Monnam(mon),
X								doname(obj));
X	} else {
X		int dam = 1;
X
X		if (obj && cansee(mon->mx, mon->my))
X			pline("%s is hit by %s!", Monnam(mon), doname(obj));
X		if (d_override) dam = d_override;
X		else if (obj) {
X			dam = dmgval(obj, mon->data);
X			if (dam < 1) dam = 1;
X		}
X		if ((mon->mhp -= dam) <= 0) {
X			if (cansee(mon->mx, mon->my))
X				pline("%s is killed!", Monnam(mon));
X			else if (mon->mtame)
X	You("have a sad feeling for a moment, then it passes.");
X			mondied(mon);
X			trapkilled = TRUE;
X		}
X	}
X	if (obj && (!strike || d_override)) {
X		obj->ox = mon->mx;
X		obj->oy = mon->my;
X		obj->nobj = fobj;
X		fobj = obj;
X		stackobj(fobj);
X		levl[obj->ox][obj->oy].omask = 1;
X	} else if (obj) free ((genericptr_t)obj);
X
X	return trapkilled;
X}
X
Xboolean
Xunconscious()
X{
X	return (multi < 0 && (!nomovemsg ||
X	      !strncmp(nomovemsg,"You wake", 8) ||
X	      !strncmp(nomovemsg,"You awake", 9) ||
X	      !strncmp(nomovemsg,"You regain con", 15) ||
X	      !strncmp(nomovemsg,"You are consci", 15)));
X}
END_OF_FILE
if test 38220 -ne `wc -c <'src/trap.c'`; then
    echo shar: \"'src/trap.c'\" unpacked with wrong size!
fi
# end of 'src/trap.c'
fi
echo shar: End of archive 6 \(of 38\).
cp /dev/null ark6isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 38 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
