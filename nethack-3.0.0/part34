Path: utzoo!utgpu!jarvis.csri.toronto.edu!mailrus!csd4.milw.wisc.edu!cs.utexas.edu!uunet!zephyr.ens.tek.com!tektronix!tekgen!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v07i089:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Part34/38
Message-ID: <4346@tekred.CNA.TEK.COM>
Date: 24 Jul 89 19:09:27 GMT
Sender: nobody@tekred.CNA.TEK.COM
Lines: 1953
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 7, Issue 89
Archive-name: NetHack3/Part34



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 34 (of 38)."
# Contents:  Porting amiga/Install.ami auxil/license auxil/nethack.6
#   include/decl.h include/youprop.h src/exper.c src/search.c
#   src/sit.c src/timeout.c
# Wrapped by billr@saab on Sun Jul 23 21:33:20 1989
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'Porting' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Porting'\"
else
echo shar: Extracting \"'Porting'\" \(5724 characters\)
sed "s/^X//" >'Porting' <<'END_OF_FILE'
X  NetHack Porting Guidelines		v 3.0			89-05-05
X
X
X     1.0	Introduction
X
X	This document goes through the steps required to port NetHack to a
Xnew machine.  The basic steps in porting the program are:
X
X	1.  Get the code onto your machine.  The current directory setup
X	    consists of one directory each for general and UNIX source
X	    files (src), include files (include), auxiliary files (auxil),
X	    files specific to the Amiga (amiga), and files specific to
X	    other OSs like MSDOS and TOS (other).  A full list of the
X	    files may be found in the top-level file "Files".
X
X	2.  Modify the appropriate include files to customize NetHack to
X	    your system.
X
X	3.  Add, if required, a OS specific copy of "main.c", "tty.c" and
X	    "unix.c".
X
X	4.  Possibly add a OS specific library (see "msdos.c" and "tos.c"
X	    as examples) and a OS specific "*conf.h" file (see unixconf.h,
X	    pcconf.h, tosconf.h, etc. as examples).
X
X	5.  Modify the top level makefile and the "src" makefile if required.
X	    Then run an initial compile.  You are bound to get some errors.
X	    You should be able to fix them in a fairly simple fashion.  If
X	    things seem to be getting too complex, take a step back, and
X	    possibly send me some mail.  I might be able to help.
X
X	6.  Mail all of your fixes to me in a contextual form so that I can
X	    easily integrate them into the code.
X
X	One general rule of thumb exists.  Always add code.  Don't delete
Xsomebody else's code for yours - it won't work on his machine if you do.
XAlways add your OS specific code inside #ifdef / #else / #endif constructs
Xso that it will be able to be folded back into the original code easily.
X
X
X     2.0	Include Files
X
X     2.1	config.h
X
X	The file "config.h" is a master configuration file that determines
Xthe basic features of the game, as well as many of the security options.
XIt is intended that end users configure the game by editing "config.h" and
Xan appropriate "*conf.h" file, so any #defines for individual preferences
Xshould be added to those files.  OS-specific #defines that are not intended
Xto be changed should also go in "*conf.h"; try to find the most appropriate
Xplace for other #defines.
X
X	The following sections may require modification:
X
X     -	Section 1:	OS selection.
X			You may have to put a #define for your OS here.
X			If your OS is yet another UNIX variant, put the
X			#define in unixconf.h instead.
X
X     -	Section 2:	Global parameters and filenames.
X			You will have to customize the game to the
X			setup on your system.
X
X     -	Section 3:	Type definitions.
X			These will have to be matched to your compiler.
X
X     2.2	global.h
X
X	This file defines things specific to NetHack that should not
Xrequire modification by an end user.  For a new port, you may have to add
Xautomatic inclusion of another auxiliary config file (*conf.h) which you
Xwrote for your system.
X
X     2.3	extern.h
X
X	If you create any new source modules or new functions in old modules,
Xyou must enter the names of the new external references (the functions defined
Xthere for external use) in this file.
X
X     2.4	system.h
X
X	This file contains references for all hooks into the OS (via the
Xstandard "C" libraries).  Depending on what your standard library looks like,
Xyou may have to put new entries into this file.
X
X
X     3.0	Source files
X
X	The first step in getting the game up is to get the "makedefs"
Xprogram running.  This program is used to create the appropriate configuration
Xspecific files for the game.
X
X	Once "makedefs" has been built, the rest of the game can be compiled.
XYou will probably have to create an OS specific module to handle things you
Xwant to use, like a mouse or a ram-disk.
X
X	Please note that the dependancies in the "src" makefile for the
X"makedefs" program are deliberately wrong.  Don't try to fix them, you'll
Xjust create a dependancy loop as "makedefs" is considered to be dependant
Xon some of the header files it creates when "make" searches back through
Xother header files it includes.
X
X     3.1	Makefile
X
X	This distribution provides makefiles for several kinds of systems.
XThere are joint makefiles for the various varieties of UNIX, makefiles for
XMSDOS, and a makefile for Amigas.  You may have to create a new makefile for
Xyour specific machine.  If possible, however, add to one of those provided.
X
X     3.2	termcap.c
X
X	If your system doesn't run off of a termcaps or terminfo database, you
Xwill have to put the appropriate terminal control strings into termcap.c.  This
Xhas already been done for DOS, and these mods can be used as an example.
X
X     3.3	main.c
X
X	You may need to create a new "main.c" module.  If you do, call it
X[OS]main.c where the [OS] is replaced with the name of the OS you are porting
Xto.  This file contains the mainline module, which reads options from the
Xcommand line and processes them.  It also contains the master game turn loop
Xand various functions associated with game startup.
X
X     3.4	tty.c
X
X	You may need to create a new "tty.c" module.  If you do, call it
X[OS]tty.c where the [OS] is replaced with the name of the OS you are porting
Xto.  This file contains the terminal/console interface routines, and is used
Xfor raw io, etc.  If your system isn't Unix, you will most certainly have to
Xre-write it.
X
X     3.5	unix.c
X
X	You may need to create a new "unix.c" module.  If you do, call it
X[OS]unix.c where the [OS] is replaced with the name of the OS you are porting
Xto.  This file contains some OS dependancies concerning time and filename
Xcreation.
X
X
X	The object of the NetHack development project is to get the game
Xworking on as many different types of hardware and under as many different
Xoperating systems as is practical.  Any assistance will be appreciated.
X
X						Mike Stephenson
END_OF_FILE
if test 5724 -ne `wc -c <'Porting'`; then
    echo shar: \"'Porting'\" unpacked with wrong size!
fi
# end of 'Porting'
fi
if test -f 'amiga/Install.ami' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'amiga/Install.ami'\"
else
echo shar: Extracting \"'amiga/Install.ami'\" \(5037 characters\)
sed "s/^X//" >'amiga/Install.ami' <<'END_OF_FILE'
X
XCompilation and installation instructions for NetHack on the Amiga
X==================================================================
X						   by Olaf Seibert
XTo Play Only:
X------------
X
X	1.  Need one megabyte.
X	2.  Wait for the binary distribution on comp.binaries.amiga.
X
XTo Build:
X--------
X
XRequirements:
X
X	1a. Harddisk with 3M of free space; or
X	1b. Two floppy drives and enough memory for an >= 1M ramdisk
X	    and make/cpp/compiler/assembler resident; or
X	1c. Three floppy drives and enough memory for a +- 200K ramdisk
X	    and make/cpp/compiler/assembler resident.
X
X	2.  With 1b and 1c you also need at least 4 empty floppies.
X
Xand Optionally
X
X	1.  A CPP that handles #if defined(SYMBOL). A Decus CPP,
X	    available on a Fish disk, will do fine;
X	2.  Same as 1, modified to write all #define-s at the end
X	    of the output file
X	3.  A modified Make (originally from net.sources, also from a Fish
X	    disk), modified to search several directories when trying to
X	    apply a default rule, and to allow colons (:) in target names.
X	4.  A file zapper, to learn that stupid Manx 3.6 compiler that if it
X	    doesn't know signed, const, and volatile, it shouldn't look for
X	    them. Patch those 'keywords' to someting like __gned, __nst, and
X	    __latile.
X	5.  Rez (by Jim Goodnow) is highly recommended.
X
X
XFirst, read the Unix installation instructions; the organization on the
XAmiga is similar, with the differences stated below:
X
XFor floppy users (as I am), source is split over two diskettes, SRC1 and
XSRC2. The first contains roughly [a-l]*.c, the second [m-z]*.c. Include
Xfiles are in the Assigned directory INCLUDE:, on SRC1:include. You may want
Xto rename hack.h to _hack.h, see below. Amiga specific files are in AMIGA:,
Xin SRC1:amiga. The modified stdio.h and friends also go there. There must
Xalso be an AUXIL: somewhere.
X
XOn a harddisk, you can either Assign SRC1: and SRC2: to the same directory,
Xor change the makefile slightly.
X
XSet up the compiler environment such that it will look for #include files
Xfirst in AMIGA: and INCLUDE:, and only last in the default include file
Xdirectory. For convenience, you may copy time.h and ctype.h to AMIGA:, to
Xsave a few disk swaps. It is expected that time_t is defined in time.h; if
Xit is not, change system.h. You don't want to define Bitfield in config.h
Xto use real bitfields; the Manx compiler is too buggy in that area. [It
Xevaluates the lhs of bitfield op= expr twice, including side-effects, and
Xif the lhs is too complicated, it messes up a few registers as well; as in
Xpush d1; do something else with d1; pop it back in d0; use d1 instead of
Xd0]. You also don't want COMPRESS, but do want ZEROCOMP. Of course, since I
Xwrote that part.
X
XThis is the initialization script file that I use:
X
X	rez cpp dme cc -l as -n make
X	assign amiga: src1:amiga include: src1:include	; assumes ARP.
X	set INCLUDE=!include:!amiga:!SYS:include CLIB=SYS2:lib
X	copy c:delete ram:c
X	copy c:setdate ram:c
X	ares delete remove		; assumes ARP.
X	type <nil: to ram:c/dme 	; to defeat Ash/Shell-Seg
X	type <nil: to ram:c/cc		;   in combination with Rez.
X	type <nil: to ram:c/as
X	type <nil: to ram:c/make
X
XIf you put everything in the right place, CD to the place where you want
Xthe object files to appear (i.e. the RAM disk or your fast harddisk), and
Xtype Make, assuming you first put the Amiga makefile there. The process
Xwill then do about the following:
X
X- Make makedefs, which makes a few header files
X- Pre-CPP include:_hack.h to include:hack.h, which also leaves a copy in
X  the current directory. The idea of this is, that we pre-include
X  everything that hack.h includes. You need the modified CPP for that,
X  since we don't want to loose all #defines in the process.
X- Then the amiga specific files are compiled. One of them makes use of a
X  precompiled set of all Amiga header files. You can easily leave out this
X  compiler option.
X- The other files are compiled, using a separate CPP.
X- Finally, things are linked, to an executable of about 650K including
X  wack symbols. Doing this in the 1M ram disk is tricky but possible.
X  Use a second CLI/Shell to delete object files during the second linking
X  pass.
X
XIf everything works the first time, this process takes no less than three
Xhours, using setup 1b and a 2.5M Amiga 1000 with 68000.
X
XIf you have a different setup than I have, you might change the appropriate
Xthings appropriately :-)
X
XI haven't provided a makefile for the auxiliary files, see Makefile.auxil
Xand the directory listing below for that.
X
X     hack (dir)
X       8				   2088
X  castle			      1945
X  cmdhelp			      3035
X  data				     11612
X  endgame			       987
X  hack.font			       264
X  help				      5799
X  hh				      2606
X  history			      1503
X  license			      4417
X  NetHack			    654324  #
X  NetHack.cnf			      1990  #
X  opthelp			      3549
X  oracles			      3370
X  perm					 0
X  record			       197  #
X  rumors			     16899
X  tower1			       369
X  tower2			       337
X  tower3			       371
X
X# These sizes may vary
X
XHappy NetHacking!
X
X-Olaf Seibert
END_OF_FILE
if test 5037 -ne `wc -c <'amiga/Install.ami'`; then
    echo shar: \"'amiga/Install.ami'\" unpacked with wrong size!
fi
# end of 'amiga/Install.ami'
fi
if test -f 'auxil/license' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'auxil/license'\"
else
echo shar: Extracting \"'auxil/license'\" \(4902 characters\)
sed "s/^X//" >'auxil/license' <<'END_OF_FILE'
X		    NETHACK GENERAL PUBLIC LICENSE
X		    (Copyright 1989, M. Stephenson)
X
X		(Based on the BISON general public license,
X		   copyright 1988 Richard M. Stallman)
X
X Everyone is permitted to copy and distribute verbatim copies of this
X license, but changing it is not allowed.  You can also use this wording to
X make the terms for other programs.
X
X  The license agreements of most software companies keep you at the mercy of
Xthose companies.  By contrast, our general public license is intended to give
Xeveryone the right to share NetHack.  To make sure that you get the rights we
Xwant you to have, we need to make restrictions that forbid anyone to deny you
Xthese rights or to ask you to surrender the rights.  Hence this license
Xagreement.
X
X  Specifically, we want to make sure that you have the right to give away
Xcopies of NetHack, that you receive source code or else can get it if you
Xwant it, that you can change NetHack or use pieces of it in new free
Xprograms, and that you know you can do these things.
X
X  To make sure that everyone has such rights, we have to forbid you to
Xdeprive anyone else of these rights.  For example, if you distribute copies
Xof NetHack, you must give the recipients all the rights that you have.  You
Xmust make sure that they, too, receive or can get the source code.  And you
Xmust tell them their rights.
X
X  Also, for our own protection, we must make certain that everyone finds out
Xthat there is no warranty for NetHack.  If NetHack is modified by someone
Xelse and passed on, we want its recipients to know that what they have is
Xnot what we distributed.
X
X  Therefore we (Mike Stephenson and other holders of NetHack copyrights) make
Xthe following terms which say what you must do to be allowed to distribute or
Xchange NetHack.
X
X
X			COPYING POLICIES
X
X  1. You may copy and distribute verbatim copies of NetHack source code as
Xyou receive it, in any medium, provided that you keep intact the notices on
Xall files that refer to copyrights, to this License Agreement, and to the
Xabsence of any warranty; and give any other recipients of the NetHack
Xprogram a copy of this License Agreement along with the program.
X
X  2. You may modify your copy or copies of NetHack or any portion of it, and
Xcopy and distribute such modifications under the terms of Paragraph 1 above
X(including distributing this License Agreement), provided that you also do the
Xfollowing:
X
X    a) cause the modified files to carry prominent notices stating that you
X    changed the files and the date of any change; and
X
X    b) cause the whole of any work that you distribute or publish, that in
X    whole or in part contains or is a derivative of NetHack or any part
X    thereof, to be licensed at no charge to all third parties on terms
X    identical to those contained in this License Agreement (except that you
X    may choose to grant more extensive warranty protection to some or all
X    third parties, at your option)
X
X    c) You may charge a distribution fee for the physical act of
X    transferring a copy, and you may at your option offer warranty protection
X    in exchange for a fee.
X
X  3. You may copy and distribute NetHack (or a portion or derivative of it,
Xunder Paragraph 2) in object code or executable form under the terms of
XParagraphs 1 and 2 above provided that you also do one of the following:
X
X    a) accompany it with the complete machine-readable source code, which
X    must be distributed under the terms of Paragraphs 1 and 2 above; or,
X
X    b) accompany it with full information as to how to obtain the complete
X    machine-readable source code from an appropriate archive site.  (This
X    alternative is allowed only for noncommercial distribution.)
X
XFor these purposes, complete source code means either the full source
Xdistribution as originally released over Usenet or updated copies of the
Xfiles in this distribution used to create the object code or executable.
X
X  4. You may not copy, sublicense, distribute or transfer NetHack except as
Xexpressly provided under this License Agreement.  Any attempt otherwise to
Xcopy, sublicense, distribute or transfer NetHack is void and your rights to
Xuse the program under this License agreement shall be automatically
Xterminated.  However, parties who have received computer software programs
Xfrom you with this License Agreement will not have their licenses terminated
Xso long as such parties remain in full compliance.
X
X
XStated plainly:  You are prohibited by the terms of this License Agreement from
Xusing NetHack for gainful purposes.  You are permitted to modify NetHack, or 
Xotherwise use parts of NetHack, provided that you comply with the conditions 
Xspecified above; in particular, your modified NetHack or program containing
Xparts of NetHack must remain freely available as provided in this License
XAgreement.  In other words, go ahead and share NetHack, but don't try to stop
Xanyone else from sharing it farther.
END_OF_FILE
if test 4902 -ne `wc -c <'auxil/license'`; then
    echo shar: \"'auxil/license'\" unpacked with wrong size!
fi
# end of 'auxil/license'
fi
if test -f 'auxil/nethack.6' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'auxil/nethack.6'\"
else
echo shar: Extracting \"'auxil/nethack.6'\" \(5386 characters\)
sed "s/^X//" >'auxil/nethack.6' <<'END_OF_FILE'
X.TH NETHACK 6 "28 March 1989"
X.UC 4
X.SH NAME
Xnethack \- Exploring The Mazes of Menace
X.SH SYNOPSIS
X.B nethack
X[
X.B \-d
X.I directory
X]
X[
X.B \-n
X]
X[
X.B \-[ABCEHKPRSTVW]
X]
X[
X.B \-[DX]
X]
X[
X.B \-u
X.I playername
X]
X.br
X.B nethack
X[
X.B \-d
X.I directory
X]
X.B \-s
X[
X.B \-[ABCEHKPRSTVW]
X]
X[
X.I playernames
X]
X.SH DESCRIPTION
X.PP
X.I NetHack
Xis a display oriented Dungeons & Dragons(tm) - like game.
XBoth display and command structure resemble rogue.
X.PP
XTo get started you really only need to know two commands.  The command
X.B ?
Xwill give you a list of the available commands (as well as other information)
Xand the command
X.B /
Xwill identify the things you see on the screen.
X.PP
XTo win the game (as opposed to merely playing to beat other people's high
Xscores) you must locate the Amulet of Yendor which is somewhere below
Xthe 20th level of the dungeon and get it out.
XNobody has achieved this yet; anybody who does will probably go down
Xin history as a hero among heros.
X.PP
XWhen the game ends, whether by your dying, quitting, or escaping
Xfrom the caves,
X.I NetHack
Xwill give you (a fragment of) the list of top scorers.
XThe scoring is based on many aspects of your behavior, but a rough estimate
Xis obtained by taking the amount of gold you've found in the cave plus four
Xtimes your (real) experience.
XPrecious stones may be worth a lot of gold when brought to the exit.
XThere is a 10% penalty for getting yourself killed.
X.PP
XThe environment variable NETHACKOPTIONS can be used to initialize many
Xrun-time options.
XThe ? command provides a description of these options and syntax.
X.PP
XThe
X.B \-u
X.I playername
Xoption supplies the answer to the question "Who are you?".
XIt overrides any name from NETHACKOPTIONS, USER, LOGNAME, or getlogin(),
Xwhich will otherwise be tried in order.
XIf none of these provides a useful name, the player will be asked for one.
XA
X.I playername
Xsuffix or a separate option consisting of one of
X.B "\-A \-B \-C \-E \-H \-K \-P \-R \-S \-T \-V \-W"
Xcan be used to determine the character role.
X.PP
XThe
X.B \-s
Xoption alone will print out the list of your scores.
XIt may be followed by arguments
X.B "\-A \-B \-C \-E \-H \-K \-P \-R \-S \-T \-V \-W"
Xto print the
Xscores of Archeologists, Barbarians, Cave(wo)men, Elves, Healers, Knights,
XPriest(esse)s, Rogues, Samurai, Tourists, Valkyries, or Wizards.
XIt may also be followed by one or more player names to print the scores of the
Xplayers mentioned, or by 'all' to print out all scores.
X.PP
XThe
X.B \-n
Xoption suppresses printing of any news from the game administrator.
X.PP
XThe
X.B \-D
Xor
X.B \-X
Xoption will start the game in a special non-scoring discovery mode
X(or in debugging (wizard) mode if the player is the game administrator).
X.PP
XThe
X.B \-d
Xoption, which must be the first argument if it appears,
Xsupplies a directory which is to serve as the playground.
XIt overrides the value from HACKDIR or the directory specified by the game
Xadministrator during compilation (usually /usr/games/lib/nethackdir).
XThis option is usually only useful to the game administrator.
XThe playground must contain several auxiliary files such as help files,
Xthe list of top scorers, and a subdirectory
X.I save
Xwhere games are saved.
X.SH AUTHORS
X.PP
XJay Fenlason (+ Kenny Woodland, Mike Thome and Jon Payne) wrote the
Xoriginal hack, very much like rogue (but full of bugs).
X.PP
XAndries Brouwer continuously deformed their sources into an entirely
Xdifferent game.
X.PP
XMike Stephenson has continued the perversion of sources, adding various
Xwarped character classes and sadistic traps with the help of many strange
Xpeople who reside in that place between the worlds, the Usenet Zone.
XA number of these miscreants are immortalized in the historical
Xroll of dishonor and various other places.
X.PP
XThe resulting mess is now called NetHack, to denote its
Xdevelopment by the Usenet.  Andries Brouwer has made this request for the
Xdistinction, as he may eventually release a new version of his own.
X.SH FILES
X.PP
XAll files are in the playground, normally /usr/games/lib/nethackdir.
X.br
X.DT
X.ta \w'tower1, tower2, tower3\ \ \ 'u
Xnethack		The program itself.
X.br
Xdata, oracles, rumors	Data files used by NetHack.
X.br
Xhelp, hh	Help data files.
X.br
Xcmdhelp, opthelp	More help data files.
X.br
Xcastle, endgame	Predefined special levels.
X.br
Xtower1, tower2, tower3	More special levels.
X.br
Xhistory	A short history of NetHack.
X.br
Xlicense	Rules governing redistribution.
X.br
Xrecord	The list of top scorers.
X.br
Xlogfile	An extended list of games played.
X.br
Xsave	A subdirectory containing the saved
X.br
X	games.
X.br
Xbones.dd	Descriptions of the ghost and
X.br
X	belongings of a deceased
X.br
X	adventurer.
X.br
Xxlock.dd	Description of a dungeon level.
X.br
Xperm, safelock	Lock files for xlock.dd.
X.br
Xrecord_lock	Lock file for record.
X.br
Xlogfile_lock	Lock file for logfile.
X.SH ENVIRONMENT
X.DT
X.ta \w'HACKPAGER or PAGER\ \ \ 'u
XUSER or LOGNAME	Your login name.
X.br
XHOME		Your home directory.
X.br
XSHELL		Your shell.
X.br
XTERM		The type of your terminal.
X.br
XHACKPAGER or PAGER	Replacement for default pager.
X.br
XMAIL	Mailbox file.
X.br
XMAILREADER	Replacement for default reader
X.br
X	(probably /bin/mail or /usr/ucb/mail).
X.br
XHACKDIR	Playground.
X.br
XNETHACKOPTIONS	String predefining several NetHack
X.br
X	options.
X.br
X
XIn addition, SHOPTYPE is used in debugging (wizard) mode.
X.SH BUGS
X.PP
XProbably infinite.
X
X
X.PP
XDungeons & Dragons is a Trademark of TSR Inc.
END_OF_FILE
if test 5386 -ne `wc -c <'auxil/nethack.6'`; then
    echo shar: \"'auxil/nethack.6'\" unpacked with wrong size!
fi
# end of 'auxil/nethack.6'
fi
if test -f 'include/decl.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/decl.h'\"
else
echo shar: Extracting \"'include/decl.h'\" \(3963 characters\)
sed "s/^X//" >'include/decl.h' <<'END_OF_FILE'
X/*	SCCS Id: @(#)decl.h	3.0	88/10/24
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#ifndef DECL_H
X#define DECL_H
X
X#define E extern
X
XE int bases[];
XE int warnlevel;	/* defined in mon.c */
XE int occtime;
XE int nroom;
XE int multi;
XE int hackpid;
X#ifdef UNIX
XE int locknum;
X#ifdef DEF_PAGER
XE char *catmore;
X#endif	/* DEF_PAGER */
X#endif	/* UNIX */
XE char SAVEF[];
XE char *hname;
XE const char *hu_stat[];	/* defined in eat.c */
XE int medusa_level;
XE int bigroom_level;
X#ifdef REINCARNATION
XE int rogue_level;
X#endif
X#ifdef ORACLE
XE int oracle_level;
X#endif
X#ifdef STRONGHOLD
XE int stronghold_level, tower_level;
X#endif
XE int wiz_level;
XE boolean is_maze_lev;
X
XE xchar xdnstair, ydnstair, xupstair, yupstair; /* stairs up and down. */
X#ifdef STRONGHOLD
XE xchar xdnladder, ydnladder, xupladder, yupladder; /* ladders up and down. */
X#endif
XE xchar scrlx, scrhx, scrly, scrhy; /* corners of new area on screen. pri.c */
XE xchar dlevel;
XE xchar maxdlevel; /* dungeon level */
XE int done_stopprint;
XE int done_hup;
XE xchar curx,cury;	/* cursor location on screen */
XE xchar seehx, seelx, seehy, seely; /* where to see */
XE xchar seehx2, seelx2, seehy2, seely2; /* where to see */
XE xchar fountsound, sinksound;	/* numbers of noisy things */
X
XE char pl_character[PL_CSIZ];
XE char pl_fruit[PL_FSIZ];
XE int current_fruit;
XE struct fruit *ffruit;
X#ifdef STRONGHOLD
XE char tune[6];
X#  ifdef MUSIC
XE schar music_heard;
X#  endif
X#endif
X
XE const char quitchars[];
XE const char vowels[];
XE const char ynchars[];
XE const char ynqchars[];
XE const char ynaqchars[];
XE const char nyaqchars[];
XE int smeq[];
XE int doorindex;
XE char *save_cm;
XE char *killer;
XE char inv_order[];
XE char plname[PL_NSIZ];
XE char dogname[];
XE char catname[];
XE const char sdir[], ndir[];	/* defined in hack.c */
XE char *occtxt;		/* defined when occupation != NULL */
XE char *nomovemsg;
XE const char nul[];
XE char *HI, *HE, *AS, *AE;	/* set up in termcap.c */
XE char *CD;			/* set up in termcap.c */
XE int CO, LI;			/* set up in termcap.c: COLNO and ROWNO+3 */
XE char *traps[];
X#ifndef MAKEDEFS_C  /* avoid conflict with lock() */
XE char lock[];
X#endif
XE char morc;
X
XE const schar xdir[], ydir[];	/* idem */
XE schar tbx, tby;		/* set in mthrowu.c */
XE int dig_effort;	/* apply.c, hack.c */
XE uchar dig_level;
XE coord dig_pos;
XE boolean dig_down;
X
XE long moves;
XE long wailmsg;
X
XE boolean unweapon;
XE boolean stoned;
XE boolean in_mklev;
X#ifdef KOPS
XE boolean allow_kops;
X#endif
X
X#ifdef SPELLS
X#ifndef SPELLS_H
X#include "spell.h"
X#endif
XE struct spell spl_book[];	/* sized in decl.c */
X#endif
X
X#ifdef REDO
XE int in_doagain;
X#endif
X
X#ifdef MSDOSCOLOR
XE char *HI_RED, *HI_YELLOW, *HI_GREEN, *HI_BLUE, *HI_WHITE; /* termcap.c */
X#endif
X
X#ifndef OBJ_H
X#include "obj.h"
X#endif
X
XE struct obj *invent, *uarm, *uarmc, *uarmh, *uarms, *uarmg, *uarmf,
X#ifdef SHIRT
X	*uarmu, /* under-wear, so to speak */
X#endif
X#ifdef POLYSELF
X	*uskin,
X#endif
X	*uamul, *uleft, *uright, *ublindf, *fcobj, *uwep;
X
XE struct obj *uchain;	/* defined iff PUNISHED */
XE struct obj *uball;	/* defined if PUNISHED */
X
X#ifndef YOU_H
X#include "you.h"
X#endif
X
XE struct you u;
X
X#ifndef MAKEDEFS_C
X#ifndef ONAMES_H
X#include "onames.h"
X#endif
X#ifndef PM_H
X#include "pm.h"
X#endif
X#endif /* MAKEDEFS_C */
X
XE struct permonst playermon, *uasmon;	/* also decl'd extern in permonst.h */
X					/* init'd in monst.c */
XE struct obj zeroobj;		/* init'd and defined in decl.c */
X
XE struct monst youmonst;	/* init'd and defined in decl.c */
X
XE const char obj_symbols[];		/* init'd in objects.h */
X
XE struct obj *billobjs;
X
XE const char black[];
XE const char amber[];
X#ifdef THEOLOGY
XE const char golden[];
X#endif
XE const char light_blue[];
XE const char red[];
XE const char green[];
XE const char silver[];
XE const char blue[];
XE const char purple[];
XE const char white[];
X
XE const char nothing_happens[];
XE const char thats_enough_tries[];
X
X#undef E
X
X#endif /* DECL_H /**/
END_OF_FILE
if test 3963 -ne `wc -c <'include/decl.h'`; then
    echo shar: \"'include/decl.h'\" unpacked with wrong size!
fi
# end of 'include/decl.h'
fi
if test -f 'include/youprop.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/youprop.h'\"
else
echo shar: Extracting \"'include/youprop.h'\" \(4834 characters\)
sed "s/^X//" >'include/youprop.h' <<'END_OF_FILE'
X/*	SCCS Id: @(#)youprop.h	3.0	89/06/24
X/* NetHack may be freely redistributed.  See license for details. */
X/* Copyright (c) 1989 Mike Threepoint */
X
X#ifndef YOUPROP_H
X#define YOUPROP_H
X
X#ifndef PROP_H
X#include "prop.h"
X#endif
X#ifndef PERMONST_H
X#include "permonst.h"
X#endif
X#ifndef MONDATA_H
X#include "mondata.h"
X#endif
X#ifndef PM_H
X#include "pm.h"
X#endif
X
X#ifndef NAMED_ITEMS
X# define defends(attk,uwep)	0
X#endif
X
X/* two pseudo-properties */
X#define Blindfolded	(ublindf)
X#define Punished	(uball)
X
X/* perhaps these #define's should also be generated by makedefs */
X#define HFire_resistance	u.uprops[FIRE_RES].p_flgs
X#ifdef POLYSELF
X#define Fire_resistance	((HFire_resistance) || resists_fire(uasmon) || defends(AD_FIRE,uwep))
X#else
X#define Fire_resistance	((HFire_resistance) || defends(AD_FIRE,uwep))
X#endif
X
X#define HSleep_resistance	u.uprops[SLEEP_RES].p_flgs
X#ifdef POLYSELF
X#define Sleep_resistance	((HSleep_resistance) || resists_sleep(uasmon))
X#else
X#define Sleep_resistance	HSleep_resistance
X#endif
X
X#define HCold_resistance	u.uprops[COLD_RES].p_flgs
X#ifdef POLYSELF
X#define Cold_resistance	((HCold_resistance) || resists_cold(uasmon) || defends(AD_COLD,uwep))
X#else
X#define Cold_resistance	((HCold_resistance) || defends(AD_COLD,uwep))
X#endif
X
X#define HDisint_resistance	u.uprops[DISINT_RES].p_flgs
X#ifdef POLYSELF
X#define Disint_resistance	((HDisint_resistance) || resists_disint(uasmon))
X#else
X#define Disint_resistance	HDisint_resistance
X#endif
X
X#define HShock_resistance	u.uprops[SHOCK_RES].p_flgs
X#ifdef POLYSELF
X#define Shock_resistance	((HShock_resistance) || resists_elec(uasmon) || defends(AD_ELEC,uwep))
X#else
X#define Shock_resistance	((HShock_resistance) || defends(AD_ELEC,uwep))
X#endif
X
X#define HPoison_resistance	u.uprops[POISON_RES].p_flgs
X#ifdef POLYSELF
X#define Poison_resistance	((HPoison_resistance) || resists_poison(uasmon))
X#else
X#define Poison_resistance	(HPoison_resistance)
X#endif
X
X#define Adornment		u.uprops[ADORNED].p_flgs
X
X#define HRegeneration		u.uprops[REGENERATION].p_flgs
X#ifdef POLYSELF
X#define Regeneration		((HRegeneration) || regenerates(uasmon))
X#else
X#define Regeneration		(HRegeneration)
X#endif
X
X#define Searching		u.uprops[SEARCHING].p_flgs
X
X#define HSee_invisible		u.uprops[SEE_INVIS].p_flgs
X#ifdef POLYSELF
X#define See_invisible		((HSee_invisible) || perceives(uasmon))
X#else
X#define See_invisible		(HSee_invisible)
X#endif
X
X#define HInvis			u.uprops[INVIS].p_flgs
X#ifdef POLYSELF
X#define Invis			((HInvis) || u.usym == S_STALKER)
X#else
X#define Invis			(HInvis)
X#endif
X#define Invisible		(Invis && !See_invisible)
X
X#define HTeleportation		u.uprops[TELEPORT].p_flgs
X#ifdef POLYSELF
X#define Teleportation		((HTeleportation) || can_teleport(uasmon))
X#else
X#define Teleportation		(HTeleportation)
X#endif
X
X#define HTeleport_control	u.uprops[TELEPORT_CONTROL].p_flgs
X#ifdef POLYSELF
X#define Teleport_control	((HTeleport_control) || control_teleport(uasmon))
X#else
X#define Teleport_control	(HTeleport_control)
X#endif
X
X#define Polymorph		u.uprops[POLYMORPH].p_flgs
X#define Polymorph_control	u.uprops[POLYMORPH_CONTROL].p_flgs
X
X#define HLevitation		u.uprops[LEVITATION].p_flgs
X#ifdef POLYSELF
X#define Levitation		((HLevitation) || is_floater(uasmon))
X#else
X#define Levitation		(HLevitation)
X#endif
X
X#define Stealth 		u.uprops[STEALTH].p_flgs
X#define Aggravate_monster	u.uprops[AGGRAVATE_MONSTER].p_flgs
X#define Conflict		u.uprops[CONFLICT].p_flgs
X#define Protection		u.uprops[PROTECTION].p_flgs
X#define Protection_from_shape_changers	u.uprops[PROT_FROM_SHAPE_CHANGERS].p_flgs
X#define Warning 		u.uprops[WARNING].p_flgs
X
X#define HTelepat		u.uprops[TELEPAT].p_flgs
X#ifdef POLYSELF
X#define Telepat 		((HTelepat) || (u.umonnum == PM_FLOATING_EYE))
X#else
X#define Telepat 		(HTelepat)
X#endif
X
X#define Fast			u.uprops[FAST].p_flgs
X
X#define HStun			u.uprops[STUN].p_flgs
X#ifdef POLYSELF
X#define Stunned 	((HStun) || u.usym == S_BAT || u.usym == S_STALKER)
X#else
X#define Stunned 		(HStun)
X#endif
X
X#define HConfusion		u.uprops[CONFUSION].p_flgs
X#define Confusion		(HConfusion)
X
X#define Sick			u.uprops[SICK].p_flgs
X#define Blinded 		u.uprops[BLINDED].p_flgs
X#define Blind			(Blinded || Blindfolded)
X#define Sleeping		u.uprops[SLEEPING].p_flgs
X#define Wounded_legs		u.uprops[WOUNDED_LEGS].p_flgs
X#define Stoned			u.uprops[STONED].p_flgs
X#define Strangled		u.uprops[STRANGLED].p_flgs
X#define Hallucination		u.uprops[HALLUC].p_flgs
X#define Fumbling		u.uprops[FUMBLING].p_flgs
X#define Jumping 		u.uprops[JUMPING].p_flgs
X#define Wwalking		u.uprops[WWALKING].p_flgs
X#define Hunger			u.uprops[HUNGER].p_flgs
X#define Glib			u.uprops[GLIB].p_flgs
X#define Reflecting		u.uprops[REFLECTING].p_flgs
X#define Lifesaved		u.uprops[LIFESAVED].p_flgs
X#define Antimagic		u.uprops[ANTIMAGIC].p_flgs
X#define Displaced		u.uprops[DISPLACED].p_flgs
X#define Clairvoyant		u.uprops[CLAIRVOYANT].p_flgs
X
X#endif /* YOUPROP_H /**/
END_OF_FILE
if test 4834 -ne `wc -c <'include/youprop.h'`; then
    echo shar: \"'include/youprop.h'\" unpacked with wrong size!
fi
# end of 'include/youprop.h'
fi
if test -f 'src/exper.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/exper.c'\"
else
echo shar: Extracting \"'src/exper.c'\" \(4751 characters\)
sed "s/^X//" >'src/exper.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)exper.c	3.0	89/04/21
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include "hack.h"
X
X#ifdef LINT
X#define	NEW_SCORING
X#endif
Xlong
Xnewuexp(lev)
Xregister unsigned lev;
X{
X#ifdef LINT	/* long conversion */
X	return(0L * lev);
X#else
X	if(lev < 10) return (10L*(1L << lev));
X	if(lev < 20) return (10000L*(1L << lev-10));
X	return (10000000L*(lev-19));
X#endif
X}
X
Xint
Xexperience(mtmp, nk)	/* return # of exp points for mtmp after nk killed */
X	register struct	monst *mtmp;
X	register int	nk;
X{
X	register struct permonst *ptr = mtmp->data;
X	int	i, tmp, tmp2;
X
X	tmp = 1 + mtmp->m_lev * mtmp->m_lev;
X
X/*	For higher ac values, give extra experience */
X	if(ptr->ac < 3) tmp += (7 - ptr->ac) * (ptr->ac < 0) ? 2 : 1;
X
X/*	For very fast monsters, give extra experience */
X	if(ptr->mmove >= 12) tmp += (ptr->mmove >= 18) ? 5 : 3;
X
X/*	For each "special" attack type give extra experience */
X	for(i = 0; i < NATTK; i++) {
X
X	    tmp2 = ptr->mattk[i].aatyp;
X	    if(tmp2 > AT_BUTT) {
X
X		if(tmp2 == AT_WEAP) tmp += 5;
X		else if(tmp2 == AT_MAGC) tmp += 10;
X		else tmp += 3;
X	    }
X	}
X
X/*	For each "special" damage type give extra experience */
X	for(i = 0; i < NATTK; i++) {
X
X	    tmp2 = ptr->mattk[i].adtyp;
X	    if(tmp2 > AD_PHYS && tmp2 < AD_BLND) tmp += 2*mtmp->m_lev;
X	    else if((tmp2 == AD_DRLI) || (tmp2 == AD_STON)) tmp += 50;
X	    else if(tmp != AD_PHYS) tmp += mtmp->m_lev;
X		/* extra heavy damage bonus */
X	    if((ptr->mattk[i].damd * ptr->mattk[i].damn) > 23)
X		tmp += mtmp->m_lev;
X	}
X
X/*	For certain "extra nasty" monsters, give even more */
X	if(extra_nasty(ptr)) tmp += (7*mtmp->m_lev);
X	if(ptr->mlet == S_EEL) tmp += 1000;
X
X/*	For higher level monsters, an additional bonus is given */
X	if(mtmp->m_lev > 8) tmp += 50;
X
X#ifdef NEW_SCORING
X	/* ------- recent addition: make nr of points decrease
X		   when this is not the first of this kind */
X	{ unsigned ul = u.ulevel;
X	  int ml = mtmp->m_lev;
X	/* points are given based on present and future level */
X	  if(ul < MAXULEV)
X	    for(tmp2 = 0; !tmp2 || ul + tmp2 <= ml; tmp2++)
X		if(u.uexp + 1 + (tmp + ((tmp2 <= 0) ? 0 : 4<<(tmp2-1)))/nk
X		    >= newuexp(ul) )
X			if(++ul == MAXULEV) break;
X
X	  tmp2 = ml - ul -1;
X	  tmp = (tmp + ((tmp2 < 0) ? 0 : 4<<tmp2))/nk;
X	  if(tmp <= 0) tmp = 1;
X	}
X	/* note: ul is not necessarily the future value of u.ulevel */
X	/* ------- end of recent valuation change ------- */
X#endif /* NEW_SCORING /**/
X
X#ifdef MAIL
X	/* Mail daemons put up no fight. */
X	if(mtmp->data == &mons[PM_MAIL_DAEMON]) tmp = 1;
X#endif
X
X	return(tmp);
X}
X
Xvoid
Xmore_experienced(exp, rexp)
X	register int exp, rexp;
X{
X	u.uexp += exp;
X	u.urexp += 4*exp + rexp;
X	if(exp) flags.botl = 1;
X	if(u.urexp >= ((pl_character[0] == 'W') ? 1000 : 2000))
X		flags.beginner = 0;
X}
X
Xvoid
Xlosexp() {	/* hit by drain life attack */
X
X	register int num;
X
X#ifdef POLYSELF
X	if(resists_drli(uasmon)) return;
X#endif
X
X	if(u.ulevel > 1) {
X		pline("Goodbye level %u.", u.ulevel--);
X		adjabil(-1);	/* remove intrinsic abilities */
X	} else
X		u.uhp = -1;
X	num = newhp();
X	u.uhp -= num;
X	u.uhpmax -= num;
X#ifdef SPELLS
X	num = rnd((int)u.ulevel/2+1) + 1;		/* M. Stephenson */
X	u.uen -= num;
X	if (u.uen < 0)		u.uen = 0;
X	u.uenmax -= num;
X	if (u.uenmax < 0)	u.uenmax = 0;
X#endif
X	u.uexp = newuexp(u.ulevel) - 1;
X	flags.botl = 1;
X}
X
X/*
X * Make experience gaining similar to AD&D(tm), whereby you can at most go
X * up by one level at a time, extra expr possibly helping you along.
X * After all, how much real experience does one get shooting a wand of death
X * at a dragon created with a wand of polymorph??
X */
Xvoid
Xnewexplevel() {
X
X	register int tmp;
X
X	if(u.ulevel < MAXULEV && u.uexp >= newuexp(u.ulevel)) {
X
X		u.ulevel++;
X		if (u.uexp >= newuexp(u.ulevel)) u.uexp = newuexp(u.ulevel) - 1;
X		pline("Welcome to experience level %u.", u.ulevel);
X		set_uasmon();	/* set up for the new level. */
X		adjabil(1);	/* give new intrinsic abilities */
X		tmp = newhp();
X		u.uhpmax += tmp;
X		u.uhp += tmp;
X#ifdef SPELLS
X		tmp = rnd((int)ACURR(A_WIS)/2+1) + 1; /* M. Stephenson */
X		u.uenmax += tmp;
X		u.uen += tmp;
X#endif
X		flags.botl = 1;
X	}
X}
X
Xvoid
Xpluslvl() {
X	register int num;
X
X	You("feel more experienced.");
X	num = newhp();
X	u.uhpmax += num;
X	u.uhp += num;
X#ifdef SPELLS
X	num = rnd((int)ACURR(A_WIS)/2+1) + 1;	/* M. Stephenson */
X	u.uenmax += num;
X	u.uen += num;
X#endif
X	if(u.ulevel < MAXULEV) {
X		u.uexp = newuexp(u.ulevel);
X		pline("Welcome to experience level %u.", ++u.ulevel);
X		adjabil(1);
X	}
X	flags.botl = 1;
X}
X
Xlong
Xrndexp()
X{
X	register long minexp,maxexp;
X
X	if(u.ulevel == 1)
X		return rn2((int)newuexp(1));
X	else {
X		minexp = newuexp(u.ulevel - 1);
X		maxexp = newuexp(u.ulevel);
X		return(minexp + rn2((int)(maxexp - minexp)));
X	}
X}
END_OF_FILE
if test 4751 -ne `wc -c <'src/exper.c'`; then
    echo shar: \"'src/exper.c'\" unpacked with wrong size!
fi
# end of 'src/exper.c'
fi
if test -f 'src/search.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/search.c'\"
else
echo shar: Extracting \"'src/search.c'\" \(4561 characters\)
sed "s/^X//" >'src/search.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)search.c	3.0	88/04/13
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include "hack.h"
X#ifdef NAMED_ITEMS
X#  include "artifact.h"
X#endif
X
Xstatic void
Xfindone(zx,zy,num)
Xxchar zx,zy;
Xint *num;
X{
X	register struct trap *ttmp;
X	register struct monst *mtmp;
X
X	if(levl[zx][zy].typ == SDOOR) {
X		levl[zx][zy].typ = DOOR;
X		levl[zx][zy].seen = 0;
X		prl(zx, zy);
X		(*num)++;
X	} else if(levl[zx][zy].typ == SCORR) {
X		levl[zx][zy].typ = CORR;
X		levl[zx][zy].seen = 0;
X		prl(zx, zy);
X		(*num)++;
X	} else if(ttmp = t_at(zx, zy)) {
X		if(ttmp->ttyp == MONST_TRAP) {
X			(void) makemon(&mons[ttmp->pm], zx, zy);
X			(*num)++;
X			deltrap(ttmp);
X		} else if(!ttmp->tseen && ttmp->ttyp != STATUE_TRAP) {
X			ttmp->tseen = 1;
X			if(!vism_at(zx, zy))
X		    atl(zx,zy,(char)((ttmp->ttyp==WEB) ? WEB_SYM : TRAP_SYM));
X			(*num)++;
X		}
X	} else if(levl[zx][zy].mmask) {
X		mtmp = m_at(zx,zy);
X		if(mtmp->mimic) {
X		        seemimic(mtmp);
X		        (*num)++;
X		}
X	}
X}
X
Xint
Xfindit()	/* returns number of things found */
X{
X	int num;
X	register xchar zx,zy;
X	xchar lx,hx,ly,hy;
X	xchar lx2,hx2,ly2,hy2;
X
X	if(u.uswallow) return(0);
X	if(inroom(u.ux,u.uy) < 0) {
X		lx = u.ux - 1;
X		hx = u.ux + 1;
X		ly = u.uy - 1;
X		hy = u.uy + 1;
X		lx2 = ly2 = 1;
X		hx2 = hy2 = 0;
X	} else
X		getcorners(&lx,&hx,&ly,&hy,&lx2,&hx2,&ly2,&hy2);
X	num = 0;
X	for(zy = ly; zy <= hy; zy++)
X		for(zx = lx; zx <= hx; zx++)
X			findone(zx,zy,&num);
X	for(zy = ly2; zy <= hy2; zy++)
X		for(zx = lx2; zx <= hx2; zx++)
X			findone(zx,zy,&num);
X	return(num);
X}
X
Xint
Xdosearch()
X{
X	return(dosearch0(0));
X}
X
Xint
Xdosearch0(aflag)
Xregister int aflag;
X{
X	register xchar x, y;
X	register struct trap *trap;
X	register struct monst *mtmp;
X	register struct obj *otmp;
X
X#ifdef NAMED_ITEMS
X	int fund = (spec_ability(uwep, SPFX_SEARCH)) ?
X			((uwep->spe > 5) ? 5 : uwep->spe) : 0;
X#endif /* NAMED_ITEMS */
X
X	if(u.uswallow) {
X		if (!aflag)
X			pline("What are you looking for?  The exit?");
X	} else
X	    for(x = u.ux-1; x < u.ux+2; x++)
X	      for(y = u.uy-1; y < u.uy+2; y++)
X		if(x != u.ux || y != u.uy) {
X		    if(levl[x][y].typ == SDOOR) {
X#ifdef NAMED_ITEMS
X			if(rnl(7-fund)) continue;
X#else
X			if(rnl(7)) continue;
X#endif
X			levl[x][y].typ = DOOR;
X			levl[x][y].seen = 0;	/* force prl */
X			nomul(0);
X			prl(x,y);
X		    } else if(levl[x][y].typ == SCORR) {
X#ifdef NAMED_ITEMS
X			if(rnl(7-fund)) continue;
X#else
X			if(rnl(7)) continue;
X#endif
X			levl[x][y].typ = CORR;
X			levl[x][y].seen = 0;	/* force prl */
X			nomul(0);
X			prl(x,y);
X		    } else {
X		/* Be careful not to find anything in an SCORR or SDOOR */
X			if(levl[x][y].mmask) {
X			    mtmp = m_at(x,y);
X			    if(!aflag && mtmp->mimic) {
X				seemimic(mtmp);
X				You("find %s.", defmonnam(mtmp));
X				return(1);
X			    }
X			}
X
X			for(trap = ftrap; trap; trap = trap->ntrap)
X			    if(trap->tx == x && trap->ty == y &&
X				!trap->tseen && !rnl(8)) {
X				nomul(0);
X				if(trap->ttyp != MONST_TRAP &&
X				   trap->ttyp != STATUE_TRAP)
X				You("find a%s.", traps[Hallucination ?
X				rn2(TRAPNUM-3)+2 : trap->ttyp ]);
X
X				if(trap->ttyp == MONST_TRAP) {
X				    if((mtmp=makemon(&mons[trap->pm], x, y)))
X					You("find %s.", defmonnam(mtmp));
X				    deltrap(trap);
X				    return(1);
X				} else if(trap->ttyp == STATUE_TRAP) {
X				    if((otmp = sobj_at(STATUE, x, y)))
X				      if(otmp->corpsenm == trap->pm) {
X					    
X					if((mtmp=makemon(&mons[trap->pm], x, y)))
X					    You("find %s posing as a statue.",
X						  defmonnam(mtmp));
X					delobj(otmp);
X				      }
X				    deltrap(trap);
X				    return(1);
X				}
X				trap->tseen = 1;
X				if(!vism_at(x,y)) atl(x,y,(char) TRAP_SYM);
X			    }
X		    }
X		}
X	return(1);
X}
X
Xint
Xdoidtrap() {
X	register struct trap *trap;
X	register int x,y;
X
X	if(!getdir(1)) return 0;
X	x = u.ux + u.dx;
X	y = u.uy + u.dy;
X	for(trap = ftrap; trap; trap = trap->ntrap)
X		if(trap->tx == x && trap->ty == y && trap->tseen) {
X		    if(u.dz)
X			if((u.dz < 0) != (is_maze_lev && trap->ttyp == TRAPDOOR))
X			    continue;
X			pline("That is a%s.",traps[ Hallucination ? rn2(TRAPNUM-3)+2 :
X			trap->ttyp]);
X		    return 0;
X		}
X	pline("I can't see a trap there.");
X	return 0;
X}
X
Xvoid
Xwakeup(mtmp)
Xregister struct monst *mtmp;
X{
X	mtmp->msleep = 0;
X	mtmp->meating = 0;	/* assume there's no salvagable food left */
X	setmangry(mtmp);
X	if(mtmp->mimic) seemimic(mtmp);
X}
X
X/* NOTE: we must check if(mtmp->mimic) before calling this routine */
Xvoid
Xseemimic(mtmp)
Xregister struct monst *mtmp;
X{
X		mtmp->mimic = 0;
X		mtmp->mappearance = 0;
X		unpmon(mtmp);
X		pmon(mtmp);
X}
END_OF_FILE
if test 4561 -ne `wc -c <'src/search.c'`; then
    echo shar: \"'src/search.c'\" unpacked with wrong size!
fi
# end of 'src/search.c'
fi
if test -f 'src/sit.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/sit.c'\"
else
echo shar: Extracting \"'src/sit.c'\" \(5423 characters\)
sed "s/^X//" >'src/sit.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)sit.c	3.0	89/06/12
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include "hack.h"
X
X#if defined(THRONES) || defined(SPELLS)
Xvoid
Xtake_gold()
X{
X	if (u.ugold <= 0)  {
X		You("feel a strange sensation.");
X	} else {
X		You("notice you have no gold!");
X		u.ugold = 0;
X		flags.botl = 1;
X	}
X}
X#endif
X
Xint
Xdosit() {
X#ifdef THRONES
X	register int cnt;
X#endif
X
X	if(Levitation)  {
X	    pline("There's nothing to sit on up here.");
X#ifdef THRONES
X	} else  if(IS_THRONE(levl[u.ux][u.uy].typ)) {
X
X	    if (rnd(6) > 4)  {
X		switch (rnd(13))  {
X		    case 1:
X			adjattrib(rn2(A_MAX), -rn1(4,3), FALSE);
X			losehp(rnd(10), "cursed throne");
X			break;
X		    case 2:
X			adjattrib(rn2(A_MAX), 1, FALSE);
X			break;
X		    case 3:
X		pline("A%s charge of electricity shoots through your body!",
X			      (Shock_resistance) ? "" : " massive");
X			if(Shock_resistance)
X				losehp(rnd(6), "electric chair");
X			else	losehp(rnd(30), "electric chair");
X			break;
X		    case 4:
X			You("feel much, much better!");
X			if(u.uhp >= (u.uhpmax - 5))  u.uhpmax += 4;
X			u.uhp = u.uhpmax;
X			make_blinded(0L,TRUE);
X			make_sick(0L,FALSE);
X			heal_legs();
X			flags.botl = 1;
X			break;
X		    case 5:
X			take_gold();
X			break;
X		    case 6:
X			if(u.uluck + rn2(5) < 0) {
X			    You("feel your luck is changing.");
X			    change_luck(1);
X			} else	    makewish();
X			break;
X		    case 7:
X			cnt = rnd(10);
X			You("hear a voice echo:");
X			pline("\"Thy audience hath been summoned, Sire!\"");
X			while(cnt--)
X			    (void) makemon(courtmon(), u.ux, u.uy);
X			break;
X		    case 8:
X			You("hear a voice echo:");
X			pline("\"By thy Imperious order, Sire...\"");
X			do_genocide(1);
X			break;
X		    case 9:
X			You("hear a voice echo:");
X	pline("\"A curse upon thee for sitting upon this most holy throne!\"");
X			if (u.uluck > 0)  {
X			    make_blinded(Blinded + rn1(100,250),TRUE);
X			} else	    rndcurse();
X			break;
X		    case 10:
X			if (u.uluck < 0 || (HSee_invisible & INTRINSIC))  {
X				pline("An image forms in your mind.");
X				do_mapping();
X			} else  {
X				Your("vision clarifies.");
X				HSee_invisible |= INTRINSIC;
X			}
X			break;
X		    case 11:
X			if (u.uluck < 0)  {
X			    You("feel threatened.");
X			    aggravate();
X			} else  {
X
X			    You("feel a wrenching sensation.");
X			    tele();		/* teleport him */
X			}
X			break;
X		    case 12:
X			You("are granted a gift of insight!");
X			while (!ggetobj("identify", identify, rn2(5))
X				&& invent);
X			break;
X		    case 13:
X			Your("mind turns into a pretzel!");
X			make_confused(HConfusion + rn1(7,16),FALSE);
X			break;
X		    default:	impossible("throne effect");
X				break;
X		}
X	    } else	You("feel somehow out of place...");
X
X	    if (!rn2(3) && IS_THRONE(levl[u.ux][u.uy].typ))	{
X		pline("The throne vanishes in a puff of logic.");
X/*		levl[u.ux][u.uy].scrsym = ROOM_SYM; */
X		levl[u.ux][u.uy].typ = ROOM;
X		if(Invisible) newsym(u.ux,u.uy);
X	    }
X#endif
X#ifdef POLYSELF
X	} else if (lays_eggs(uasmon) || u.umonnum == PM_QUEEN_BEE) {
X		struct obj *uegg;
X
X		if (u.uhunger < objects[EGG].nutrition) {
X			You("are too weak to lay an egg.");
X			return 0;
X		}
X
X		uegg = mksobj(EGG, 0);
X		uegg->spe = 1;
X		uegg->quan = 1;
X		uegg->owt = weight(uegg);
X		uegg->corpsenm =
X		    (u.umonnum==PM_QUEEN_BEE ? PM_KILLER_BEE : monsndx(uasmon));
X		uegg->known = uegg->dknown = 1;
X		You("lay an egg.");
X		dropy(uegg);
X		stackobj(uegg);
X		morehungry(objects[EGG].nutrition);
X#endif
X	} else
X		pline("Having fun sitting on the floor?");
X	return(1);
X}
X
Xvoid
Xrndcurse() {			/* curse a few inventory items at random! */
X
X	int	nobj = 0;
X	int	cnt, onum;
X	struct	obj	*otmp;
X
X	if(Antimagic) {
X	    shieldeff(u.ux, u.uy);
X	    You("feel a malignant aura surround you.");
X	}
X
X	for (otmp = invent; otmp; otmp = otmp->nobj)  nobj++;
X	    if (nobj) for (cnt = rnd(6/((!!Antimagic) + 1)); cnt > 0; cnt--)  {
X
X		onum = rn2(nobj);
X		for(otmp = invent; onum != 0; onum--)
X		    otmp = otmp->nobj;
X		if(otmp->blessed)
X			otmp->blessed = 0;
X		else
X			otmp->cursed++;
X	    }
X}
X
Xvoid
Xattrcurse() {			/* remove a random INTRINSIC ability */
X	switch(rnd(10)) {
X	case 1 : if (HFire_resistance & INTRINSIC) {
X			HFire_resistance &= ~INTRINSIC;
X			if (Inhell && !Fire_resistance) {
X			    You("burn to a crisp.");
X			    killer = "gremlin curse";
X			    done("died");
X			} else You("feel warmer.");
X			break;
X		}
X	case 2 : if (HTeleportation & INTRINSIC) {
X			HTeleportation &= ~INTRINSIC;
X			You("feel less jumpy.");
X			break;
X		}
X	case 3 : if (HPoison_resistance & INTRINSIC) {
X			HPoison_resistance &= ~INTRINSIC;
X			You("feel a little sick!");
X			break;
X		}
X	case 4 : if (HTelepat & INTRINSIC) {
X			HTelepat &= ~INTRINSIC;
X			Your("senses fail!");
X			break;
X		}
X	case 5 : if (HCold_resistance & INTRINSIC) {
X			HCold_resistance &= ~INTRINSIC;
X			You("feel cooler.");
X			break;
X		}
X	case 6 : if (HInvis & INTRINSIC) {
X			HInvis &= ~INTRINSIC;
X			You("feel paranoid.");
X			break;
X		}
X	case 7 : if (HSee_invisible & INTRINSIC) {
X			HSee_invisible &= ~INTRINSIC;
X			You("thought you saw something!");
X			break;
X		}
X	case 8 : if (Fast & INTRINSIC) {
X			Fast &= ~INTRINSIC;
X			You("feel slower.");
X			break;
X		}
X	case 9 : if (Stealth & INTRINSIC) {
X			Stealth &= ~INTRINSIC;
X			You("feel clumsy.");
X			break;
X		}
X	case 10: if (Protection & INTRINSIC) {
X			Protection &= ~INTRINSIC;
X			You("feel vulnerable.");
X			break;
X		}
X	default: break;
X	}
X}
END_OF_FILE
if test 5423 -ne `wc -c <'src/sit.c'`; then
    echo shar: \"'src/sit.c'\" unpacked with wrong size!
fi
# end of 'src/sit.c'
fi
if test -f 'src/timeout.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/timeout.c'\"
else
echo shar: Extracting \"'src/timeout.c'\" \(5670 characters\)
sed "s/^X//" >'src/timeout.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)timeout.c	3.0	87/07/06
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include	"hack.h"
X
X/* He is being petrified - dialogue by inmet!tower */
Xstatic const char *stoned_texts[] = {
X	"You are slowing down.",		/* 5 */
X	"Your limbs are stiffening.",		/* 4 */
X	"Your limbs have turned to stone.",	/* 3 */
X	"You have turned to stone.",		/* 2 */
X	"You are a statue."			/* 1 */
X};
X
Xstatic void
Xstoned_dialogue() {
X	register long i = (Stoned & TIMEOUT);
X
X	if(i > 0 && i <= SIZE(stoned_texts))
X		pline(stoned_texts[SIZE(stoned_texts) - i]);
X	if(i == 5)
X		Fast &= ~(TIMEOUT|INTRINSIC);
X	if(i == 3)
X		nomul(-3);
X}
X
Xstatic const char *choke_texts[] = {
X	"You find it hard to breathe.",
X	"You're gasping for air.",
X	"You can no longer breathe.",
X	"You're turning blue.",
X	"You suffocate."
X};
X
Xstatic void
Xchoke_dialogue()
X{
X	register long i = (Strangled & TIMEOUT);
X
X	if(i > 0 && i <= SIZE(choke_texts))
X		pline(choke_texts[SIZE(choke_texts) - i]);
X}
X
Xvoid
Xtimeout()
X{
X	register struct prop *upp;
X	int sleeptime;
X
X	if(Stoned) stoned_dialogue();
X	if(Strangled) choke_dialogue();
X#ifdef POLYSELF
X	if(u.mtimedone) if(!--u.mtimedone) rehumanize();
X#endif
X	if(u.ucreamed) u.ucreamed--;
X	if(u.uluck && moves % (u.uhave_amulet
X#ifdef THEOLOGY
X		|| u.ugangr
X#endif
X		? 300 : 600) == 0) {
X	/* Cursed luckstones stop bad luck from timing out; blessed luckstones
X	 * stop good luck from timing out; normal luckstones stop both;
X	 * neither is stopped if you don't have a luckstone.
X	 */
X	    register int time_luck = stone_luck(FALSE);
X	    boolean nostone = !carrying(LUCKSTONE);
X
X	    if(u.uluck > 0 && (nostone || time_luck < 0))
X		u.uluck--;
X	    else if(u.uluck < 0 && (nostone || time_luck > 0))
X		u.uluck++;
X	}
X
X	for(upp = u.uprops; upp < u.uprops+SIZE(u.uprops); upp++)
X	    if((upp->p_flgs & TIMEOUT) && !(--upp->p_flgs & TIMEOUT)) {
X		if(upp->p_tofn) (*upp->p_tofn)();
X		else switch(upp - u.uprops){
X		case STONED:
X			killer = "cockatrice";
X			done("stoned");
X			break;
X		case SICK:
X			You("die from food poisoning.");
X			killer = u.usick_cause;
X			done("died");
X			break;
X		case FAST:
X			You("feel yourself slowing down.");
X			break;
X		case CONFUSION:
X			HConfusion = 1; /* So make_confused works properly */
X			make_confused(0L, TRUE);
X			break;
X		case STUN:
X			HStun = 1;
X			make_stunned(0L, TRUE);
X			break;
X		case BLINDED:
X			Blinded = 1;
X			make_blinded(0L, TRUE);
X			break;
X		case INVIS:
X			on_scr(u.ux,u.uy);
X			if (!Invis && !See_invisible)
X				You("are no longer invisible.");
X			break;
X		case WOUNDED_LEGS:
X			heal_legs();
X			break;
X		case HALLUC:
X			Hallucination = 1;
X			make_hallucinated(0L, TRUE);
X			break;
X		case SLEEPING:
X			if (unconscious() || Sleep_resistance)
X				Sleeping += rnd(100);
X			else {
X				You("fall asleep.");
X				sleeptime = rnd(20);
X				nomul(-sleeptime);
X				nomovemsg = "You wake up.";
X				Sleeping = sleeptime + rnd(100);
X			}
X			break;
X		case STRANGLED:
X			killer = "strangulation";
X			done("died");
X			break;
X		case FUMBLING:
X			/* call this only when a move took place.  */
X			/* otherwise handle fumbling msgs locally. */
X			if (!Levitation && u.umoved) {
X			    if (levl[u.ux][u.uy].omask)
X				You("trip over something.");
X			    else
X				switch (rn2(4)) {
X				    case 1:
X					if (ACCESSIBLE(levl[u.ux][u.uy].typ)) { /* not POOL or STONE */
X					    if (Hallucination) pline("A rock bites your foot.");
X					    else You("trip over a rock.");
X					    break;
X					}
X				    case 2:
X					if (Hallucination) You("slip on a banana peel.");
X					else You("slip and nearly fall.");
X					break;
X				    case 3:
X					You("flounder.");
X					break;
X				    default:
X					You("stumble.");
X				}
X			    nomul(-2);
X			    nomovemsg = "";
X			}
X			Fumbling = rnd(20);
X			break;
X		}
X	}
X}
X
Xstatic const char slithy[] = { S_SNAKE, S_NAGA, S_WORM, 0 };
X
Xstatic void
Xhatch_it(otmp)		/* hatch the egg "otmp" if possible */
Xregister struct obj *otmp;
X{
X	register struct monst *mtmp;
X#ifdef POLYSELF
X	int yours = otmp->spe;
X#endif
X
X	if(moves-otmp->age > 200)  /* very old egg - it's dead */
X	    otmp->corpsenm = -1;
X#ifdef LINT	/* long conv. ok */
X	else if(rnd(150) > 150) {
X#else
X	else if(rnd((int)(moves-otmp->age)) > 150) {
X#endif
X	    mtmp = makemon(&mons[big_to_little(otmp->corpsenm)], u.ux, u.uy);
X	    useup(otmp);
X	    if(mtmp) {
X
X		if(Blind)
X		    You("feel something %s from your pack!",
X			  (index(slithy, mtmp->data->mlet)) ?
X			  "slither" : "drop");
X		else
X		    pline("A%s %s just %s out of your pack!",
X			  (index(vowels, *(mtmp->data->mname))) ? "n" : "",
X			  mtmp->data->mname,
X			  (index(slithy, mtmp->data->mlet)) ?
X			  "slithered" : "dropped");
X
X#ifdef POLYSELF
X		if (yours) {
X		    pline("Its cries sound like \"%s.\"",
X			flags.female ? "mommy" : "daddy");
X		    (void) tamedog(mtmp, (struct obj *)0);
X		    return;
X		}
X#endif
X		if(mtmp->data->mlet == S_DRAGON) {
X		    pline("\"Gleep!\"");		/* Mything eggs :-) */
X		    (void) tamedog(mtmp, (struct obj *)0);
X		}
X	    }
X	}
X}
X
Xvoid
Xhatch_eggs()	    /* hatch any eggs that have been too long in pack */
X{
X	register struct obj *otmp,/* *ctmp, /* use of ctmp commented out below*/
X		*otmp2;
X
X	for(otmp = invent; otmp; otmp = otmp2) {
X
X	    otmp2 = otmp->nobj;	    /* otmp may hatch */
X	    if(otmp->otyp == EGG && otmp->corpsenm >= 0) hatch_it(otmp);
X	}
X
X/*	Not yet - there's a slight problem with "useup" on contained objs.
X	for(otmp = fcobj; otmp; otmp = otmp2) {
X
X	    otmp2 = otmp->nobj;
X	    for(ctmp = invent; ctmp; ctmp = ctmp->nobj)
X		if(otmp->cobj == ctmp)
X		    if(ctmp->otyp != ICE_BOX)
X			if(otmp->otyp == EGG && otmp->corpsenm >= 0)
X			    hatch_it(otmp);
X	}
X*/
X}
END_OF_FILE
if test 5670 -ne `wc -c <'src/timeout.c'`; then
    echo shar: \"'src/timeout.c'\" unpacked with wrong size!
fi
# end of 'src/timeout.c'
fi
echo shar: End of archive 34 \(of 38\).
cp /dev/null ark34isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 38 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
