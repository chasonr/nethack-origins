Path: utzoo!utgpu!jarvis.csri.toronto.edu!mailrus!tut.cis.ohio-state.edu!cs.utexas.edu!uunet!zephyr.ens.tek.com!tektronix!tekgen!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v07i085:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Part30/38
Message-ID: <4342@tekred.CNA.TEK.COM>
Date: 24 Jul 89 19:07:31 GMT
Sender: nobody@tekred.CNA.TEK.COM
Lines: 2390
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 7, Issue 85
Archive-name: NetHack3/Part30



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 30 (of 38)."
# Contents:  include/func_tab.h src/do_name.c src/extralev.c
#   src/fountain.c src/makedefs.c src/prisym.c
# Wrapped by billr@saab on Sun Jul 23 21:33:13 1989
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'include/func_tab.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/func_tab.h'\"
else
echo shar: Extracting \"'include/func_tab.h'\" \(507 characters\)
sed "s/^X//" >'include/func_tab.h' <<'END_OF_FILE'
X/*	SCCS Id: @(#)func_tab.h	3.0	88/10/15
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X/* func_tab.h - version 1.0.2 */
X
X#ifndef FUNC_TAB_H
X#define FUNC_TAB_H
X
Xstruct func_tab {
X	char f_char;
X	int (*f_funct)();
X	char *f_text;
X};
X
Xextern const struct func_tab cmdlist[];
X
Xstruct ext_func_tab {
X	char *ef_txt, *ef_desc;
X	int (*ef_funct)();
X};
X
Xextern const struct ext_func_tab extcmdlist[];
X
X#endif /* FUNC_TAB_H /**/
END_OF_FILE
if test 507 -ne `wc -c <'include/func_tab.h'`; then
    echo shar: \"'include/func_tab.h'\" unpacked with wrong size!
fi
# end of 'include/func_tab.h'
fi
if test -f 'src/do_name.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/do_name.c'\"
else
echo shar: Extracting \"'src/do_name.c'\" \(9873 characters\)
sed "s/^X//" >'src/do_name.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)do_name.c	3.0	88/11/24
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include "hack.h"
X
Xstatic
Xchar *
Xvisctrl(c)
Xchar c;
X{
X#ifdef LINT	/* static char ccc[3]; */
X	char ccc[3];
X#else
X	static char ccc[3];
X#endif
X
X	if(c < 040) {
X		ccc[0] = '^';
X		ccc[1] = c + 0100;
X		ccc[2] = 0;
X	} else {
X		ccc[0] = c;
X		ccc[1] = 0;
X	}
X	return(ccc);
X}
X
Xvoid
Xgetpos(cc,force,goal)
Xcoord	*cc;
Xint force; char *goal;
X{
X	register int cx, cy, i, c;
X	char *sdp = flags.num_pad ? ndir : sdir;
X	if(flags.verbose) pline("(For instructions type a ?)");
X	cx = u.ux;
X	cy = u.uy;
X	curs(cx,cy+2);
X	while((c = readchar()) != '.'){
X		for(i=0; i<8; i++) if(sdp[i] == c){
X			if(1 <= cx + xdir[i] && cx + xdir[i] <= COLNO)
X				cx += xdir[i];
X			if(0 <= cy + ydir[i] && cy + ydir[i] <= ROWNO-1)
X				cy += ydir[i];
X			goto nxtc;
X		}
X		if(c == '?'){
X		    if(flags.verbose) {
X			pline("Use [%s] to move the cursor to %s.",
X			      flags.num_pad ? "2468" : "hjkl", goal);
X			pline("Type a . when you are at the right place.");
X		    }
X		} else {
X			pline("Unknown direction: '%s' (%s).",
X				visctrl(c),
X				force ?
X				    flags.num_pad ? "use 2468 or ." :
X						    "use hjkl or ." :
X				    "aborted");
X			if(force) goto nxtc;
X			cc->x = -1;
X			cc->y = 0;
X			return;
X		}
X	nxtc:	;
X		curs(cx,cy+2);
X	}
X	cc->x = cx;
X	cc->y = cy;
X	return;
X}
X
Xint
Xdo_mname(){
X	char buf[BUFSZ];
X	coord cc;
X	register int cx,cy,lth,i;
X	register struct monst *mtmp, *mtmp2;
X	register char *curr;
X	boolean blank;
X
X	getpos(&cc, 0, "the monster you want to name");
X	cx = cc.x;
X	cy = cc.y;
X	if(cx < 0) return(0);
X	if (cx == u.ux && cy == u.uy) {
X		pline("This %s creature is called %s and cannot be renamed.",
X		ACURR(A_CHA) > 14 ?
X		(flags.female ? "beautiful" : "handsome") :
X		"ugly",
X		plname);
X		return(0);
X	}
X	if (!cansee(cx, cy) || !levl[cx][cy].mmask ||
X	    (mtmp = m_at(cx, cy))->mimic) {
X		pline("I see no monster there.");
X		return(0);
X	}
X	pline("What do you want to call %s? ", lmonnam(mtmp));
X	getlin(buf);
X	clrlin();
X	if(!*buf || *buf == '\033') return(0);
X
X	/* unnames monster if all spaces */
X	for (curr = buf, blank = 1; *curr; blank = (*curr++ == ' '));
X	if(blank) *buf = '\0';
X
X 	if(type_is_pname(mtmp->data)) {
X 	    pline("%s doesn't like being called names!", Monnam(mtmp));
X 	    if(!mtmp->mtame) {
X 		pline("%s gets %sangry!", Monnam(mtmp),
X 		      mtmp->mpeaceful ? "" : "very ");
X 		mtmp->mpeaceful = mtmp->msleep = 0;
X 	    }
X 	    return(0);
X 	}
X	lth = strlen(buf)+1;
X	if(lth > 63){
X		buf[62] = 0;
X		lth = 63;
X	}
X	mtmp2 = newmonst(mtmp->mxlth + lth);
X	*mtmp2 = *mtmp;
X	for(i=0; i<mtmp->mxlth; i++)
X		((char *) mtmp2->mextra)[i] = ((char *) mtmp->mextra)[i];
X	mtmp2->mnamelth = lth;
X	Strcpy(NAME(mtmp2), buf);
X	replmon(mtmp,mtmp2);
X	return(0);
X}
X
X/*
X * This routine changes the address of  obj . Be careful not to call it
X * when there might be pointers around in unknown places. For now: only
X * when  obj  is in the inventory.
X */
Xstatic
Xvoid
Xdo_oname(obj)
Xregister struct obj *obj;
X{
X	char buf[BUFSZ];
X	register char *curr;
X	boolean blank;
X
X	pline("What do you want to name %s? ", doname(obj));
X	getlin(buf);
X	clrlin();
X	if(!*buf || *buf == '\033')	return;
X
X	/* unnames item if all spaces */
X	for (curr = buf, blank = 1; *curr; blank = (*curr++ == ' '));
X	if(blank) *buf = '\0';
X
X#ifdef NAMED_ITEMS
X	if(is_artifact(obj) || restr_name(obj, buf))
X		pline("Somehow you can't seem to engrave that word.");
X	else
X#endif
X		(void)oname(obj, buf, 1);
X}
X
Xstruct obj *
Xoname(obj, buf, ininv)
Xregister struct obj *obj;
Xchar	*buf;
Xregister int ininv;
X{
X	register struct obj *otmp, *otmp2;
X	register int	lth;
X
X	lth = *buf ? strlen(buf)+1 : 0;
X	if(lth > 63){
X		buf[62] = 0;
X		lth = 63;
X	}
X	otmp2 = newobj(lth);
X	*otmp2 = *obj;
X	otmp2->onamelth = lth;
X#ifdef __GNUC__
X	/* Without the following line, the program gives anything an empty
X	 * name when I try to #name it.  Probably a compiler bug, but at the
X	 * point where I discovered this, there's no time to check to make
X	 * sure.
X	 */
X	if (buf) (void)donull();
X#endif
X	if(lth) Strcpy(ONAME(otmp2), buf);
X
X	setworn((struct obj *)0, obj->owornmask);
X	setworn(otmp2, otmp2->owornmask);
X
X	if (ininv) {
X		/* do freeinv(obj); etc. by hand in order to preserve
X		   the position of this object in the inventory */
X		if(obj == invent) invent = otmp2;
X		else for(otmp = invent; ; otmp = otmp->nobj){
X			if(!otmp)
X				panic("oname: cannot find obj.");
X			if(otmp->nobj == obj){
X				otmp->nobj = otmp2;
X				break;
X			}
X		}
X	}
X	/* obfree(obj, otmp2);	/* now unnecessary: no pointers on bill */
X	free((genericptr_t) obj);	/* let us hope nobody else saved a pointer */
X	return otmp2;
X}
X
Xstatic const char callable[] = {
X	SCROLL_SYM, POTION_SYM, WAND_SYM, RING_SYM, AMULET_SYM, GEM_SYM,
X#ifdef SPELLS
X	SPBOOK_SYM,
X#endif
X	ARMOR_SYM, 0 };
X
Xint
Xddocall()
X{
X	register struct obj *obj;
X#ifdef REDO
X	char	ch;
X
X	if (!in_doagain)
X#endif
X		pline("Name an individual object? ");
X	switch(
X#ifdef REDO
X		ch = 
X#endif
X		ynq()) {
X	case 'q':
X		break;
X	case 'y':
X#ifdef REDO
X		savech(ch);
X#endif
X		obj = getobj("#", "name");
X		if(obj) do_oname(obj);
X		break;
X	default:
X#ifdef REDO
X		savech(ch);
X#endif
X		obj = getobj(callable, "call");
X		if(obj) docall(obj);
X	}
X	return 0;
X}
X
Xvoid
Xdocall(obj)
Xregister struct obj *obj;
X{
X	char buf[BUFSZ];
X	struct obj otemp;
X	register char **str1;
X	register char *str;
X	boolean blank;
X
X	otemp = *obj;
X	otemp.quan = 1;
X	otemp.onamelth = 0;
X	if (otemp.corpsenm) { /* kludge, meaning it's sink water */
X		pline("Call a stream of %s fluid: ",
X				objects[otemp.otyp].oc_descr);
X	} else {
X		str = xname(&otemp);
X		pline("Call %s %s: ", index(vowels,*str) ? "an" : "a", str);
X	}
X	getlin(buf);
X	clrlin();
X	if(!*buf || *buf == '\033')
X		return;
X
X	/* clear old name */
X	str1 = &(objects[obj->otyp].oc_uname);
X	if(*str1) free(*str1);
X
X	/* uncalls item if all spaces */
X	for (str = buf, blank = 1; *str; blank = (*str++ == ' '));
X	if(blank) *buf = '\0';
X	if (!*buf) {
X		*str1 = NULL;
X		return;
X	}
X
X	str = (char *) alloc((unsigned)strlen(buf)+1);
X	Strcpy(str,buf);
X	*str1 = str;
X}
X
Xconst char *ghostnames[] = {
X	/* these names should have length < PL_NSIZ */
X	/* Capitalize the names for aesthetics -dgk */
X	"Adri", "Andries", "Andreas", "Bert", "David", "Dirk", "Emile",
X	"Frans", "Fred", "Greg", "Hether", "Jay", "John", "Jon", "Karnov",
X	"Kay", "Kenny", "Kevin", "Maud", "Michiel", "Mike", "Peter", "Robert",
X	"Ron", "Tom", "Wilmar", "Nick Danger", "Phoenix", "Miracleman",
X	"Stephan", "Lance Braccus", "Shadowhawk"
X};
X
Xchar *
Xx_monnam(mtmp, vb)
Xregister struct monst *mtmp;
Xint vb;
X{
X#ifdef LINT	/* static char buf[BUFSZ]; */
X	char buf[BUFSZ];
X#else
X	static char buf[BUFSZ];
X#endif
X	boolean isinvis = (mtmp->minvis && mtmp->data != &mons[PM_STALKER]
X				&& mtmp->data != &mons[PM_GHOST]);
X
X	buf[0] = '\0';
X#if defined(ALTARS) && defined(THEOLOGY)
X	if(mtmp->ispriest) return(priestname(mtmp));
X#endif
X	if(mtmp->isshk) {
X		Strcpy(buf, shkname(mtmp));
X		if (mtmp->data == &mons[PM_SHOPKEEPER] && !mtmp->minvis)
X		    return(buf);
X		/* For normal shopkeepers, just 'Asidonhopo'.
X		 * For unusual ones, 'Asidonhopo the invisible shopkeeper'
X		 * or 'Asidonhopo the blue dragon'.
X		 */
X		Strcat(buf, " ");
X	} else if(mtmp->mnamelth && !vb) {
X		if(isinvis) {
X		    Strcpy(buf, "the invisible ");
X		    Strcat(buf, NAME(mtmp));
X		} else 
X		    Strcpy(buf, NAME(mtmp));
X		return(buf);
X	}
X
X	switch(mtmp->data->mlet) {
X	    case S_GHOST:
X		{ register char *gn = (char *) mtmp->mextra;
X		  if(!*gn) {		/* might also look in scorefile */
X		    gn = ghostnames[rn2(SIZE(ghostnames))];
X			Strcpy((char *) mtmp->mextra, !rn2(5) ? plname : gn);
X		  }
X		  Sprintf(buf, "%s's ghost", gn);
X		}
X		break;
X	    default:
X		if (mtmp->minvis)
X			Strcat(buf, "the invisible ");
X		else if (!type_is_pname(mtmp->data) || Hallucination
X				|| mtmp->data == &mons[PM_WIZARD_OF_YENDOR])
X			Strcat(buf, "the ");
X		Strcat(buf, Hallucination ? rndmonnam() : mtmp->data->mname);
X	}
X	if(vb && mtmp->mnamelth) {
X		Strcat(buf, " called ");
X		Strcat(buf, NAME(mtmp));
X	}
X	return(buf);
X}
X
Xchar *
Xlmonnam(mtmp)
Xregister struct monst *mtmp;
X{
X	return(x_monnam(mtmp, 1));
X}
X
Xchar *
Xmon_nam(mtmp)
Xregister struct monst *mtmp;
X{
X	return(x_monnam(mtmp, 0));
X}
X
Xchar *
XMonnam(mtmp)
Xregister struct monst *mtmp;
X{
X	register char *bp = mon_nam(mtmp);
X
X	if('a' <= *bp && *bp <= 'z') *bp += ('A' - 'a');
X	return(bp);
X}
X
Xchar *
Xa_monnam(mtmp,adj)
Xregister struct monst *mtmp;
Xregister char *adj;
X{
X	register char *bp = mon_nam(mtmp);
X#ifdef LINT	/* static char buf[BUFSZ]; */
X	char buf[BUFSZ];
X#else
X	static char buf[BUFSZ];
X#endif
X
X	if(!strncmp(bp, "the ", 4)) bp += 4;
X	Sprintf(buf, "the %s %s", adj, bp);
X	return(buf);
X}
X
Xchar *
XAmonnam(mtmp, adj)
Xregister struct monst *mtmp;
Xregister char *adj;
X{
X	register char *bp = a_monnam(mtmp,adj);
X
X	*bp = 'T';
X	return(bp);
X}
X
Xchar *
XXmonnam(mtmp)
Xregister struct monst *mtmp;
X{
X	register char *bp = Monnam(mtmp);
X
X	if(!strncmp(bp, "The ", 4) && !type_is_pname(mtmp->data)) {
X		if(index(vowels,*(bp+4))) {
X			*((++bp)+1) = 'n';
X		} else
X			bp += 2;
X		*bp = 'A';
X	}
X	return(bp);
X}
X
Xchar *
Xdefmonnam(mtmp)
Xregister struct monst *mtmp;
X{
X	register char *bp = Xmonnam(mtmp);
X
X	if (!strncmp(bp,"A ",2) || !strncmp(bp,"An ",3)) *bp = 'a';
X	return(bp);
X}
X
Xchar *
Xrndmonnam() {  /* Random name of monster type, if hallucinating */
X	int name;
X
X	do {
X		name = rn2(PM_CHAMELEON);
X		/* chameleon: last monster before player classes */
X	} while(type_is_pname(&mons[name]) || (mons[name].geno & G_NOGEN));
X	return(mons[name].mname);
X}
X
X#ifdef REINCARNATION
Xchar *
Xroguename() /* Name of a Rogue player */
X{
X	char *i, *opts;
X
X	if(opts = getenv("ROGUEOPTS")) {
X		for(i=opts; *i; i++)
X			if (!strncmp("name=",i,5)) {
X				char *j;
X				if (j=index(i+5,','))
X					*j = (char)0;
X				return i+5;
X			}
X	}
X	return rn2(3) ? (rn2(2) ? "Michael Toy" : "Kenneth Arnold")
X		: "Glenn Wichman";
X}
X#endif
X
END_OF_FILE
if test 9873 -ne `wc -c <'src/do_name.c'`; then
    echo shar: \"'src/do_name.c'\" unpacked with wrong size!
fi
# end of 'src/do_name.c'
fi
if test -f 'src/extralev.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/extralev.c'\"
else
echo shar: Extracting \"'src/extralev.c'\" \(9819 characters\)
sed "s/^X//" >'src/extralev.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)extralev.c	3.0	88/04/11			*/
X/*	Copyright 1988, 1989 by Ken Arromdee				*/
X/* NetHack may be freely redistributed.  See license for details. */
X
X/* block some unused #defines to avoid overloading some cpp's */
X#define MONATTK_H
X#include "hack.h"
X
X#ifdef REINCARNATION
X
Xstruct rogueroom {
X	xchar rlx, rly;
X	xchar dx, dy;
X	boolean real;
X	uchar doortable;
X	int nroom; /* Only meaningful for "real" rooms */
X};
X#define UP 1
X#define DOWN 2
X#define LEFT 4
X#define RIGHT 8
X
Xstatic struct rogueroom r[3][3];
X
Xstatic
Xvoid
Xroguejoin(x1,y1,x2,y2, horiz)
Xint x1,y1,x2,y2;
Xint horiz;
X{
X	register int x,y,middle;
X#define MAX(a,b) (((a) > (b)) ? (a) : (b))
X#define MIN(a,b) (((a) < (b)) ? (a) : (b))
X	if (horiz) {
X		middle = x1 + rn2(x2-x1+1);
X		for(x=MIN(x1,middle); x<=MAX(x1,middle); x++)
X			corr(x, y1);
X		for(y=MIN(y1,y2); y<=MAX(y1,y2); y++)
X			corr(middle,y);
X		for(x=MIN(middle,x2); x<=MAX(middle,x2); x++)
X			corr(x, y2);
X	} else {
X		middle = y1 + rn2(y2-y1+1);
X		for(y=MIN(y1,middle); y<=MAX(y1,middle); y++)
X			corr(x1, y);
X		for(x=MIN(x1,x2); x<=MAX(x1,x2); x++)
X			corr(x, middle);
X		for(y=MIN(middle,y2); y<=MAX(middle,y2); y++)
X			corr(x2,y);
X	}
X}
X
Xstatic
Xvoid
Xroguecorr(x, y, dir)
Xint x,y,dir;
X{
X	register int fromx, fromy, tox, toy;
X
X	if (dir==DOWN) {
X		r[x][y].doortable &= ~DOWN;
X		if (!r[x][y].real) {
X			fromx = r[x][y].rlx; fromy = r[x][y].rly;
X			fromx += 1 + 26*x; fromy += 7*y;
X		} else {
X			fromx = r[x][y].rlx + rn2(r[x][y].dx);
X			fromy = r[x][y].rly + r[x][y].dy;
X			fromx += 1 + 26*x; fromy += 7*y;
X			if (!IS_WALL(levl[fromx][fromy].typ))
X				impossible("down: no wall at %d,%d?",fromx,
X									fromy);
X			dodoor(fromx, fromy, &rooms[r[x][y].nroom]);
X			levl[fromx][fromy].doormask = D_NODOOR;
X			fromy++;
X		}
X		if(y >= 2) {
X			impossible("down door from %d,%d going nowhere?",x,y);
X			return;
X		}
X		y++;
X		r[x][y].doortable &= ~UP;
X		if (!r[x][y].real) {
X			tox = r[x][y].rlx; toy = r[x][y].rly;
X			tox += 1 + 26*x; toy += 7*y;
X		} else {
X			tox = r[x][y].rlx + rn2(r[x][y].dx);
X			toy = r[x][y].rly - 1;
X			tox += 1 + 26*x; toy += 7*y;
X			if (!IS_WALL(levl[tox][toy].typ))
X				impossible("up: no wall at %d,%d?",tox,toy);
X			dodoor(tox, toy, &rooms[r[x][y].nroom]);
X			levl[tox][toy].doormask = D_NODOOR;
X			toy--;
X		}
X		roguejoin(fromx, fromy, tox, toy, FALSE);
X		return;
X	} else if (dir == RIGHT) {
X		r[x][y].doortable &= ~RIGHT;
X		if (!r[x][y].real) {
X			fromx = r[x][y].rlx; fromy = r[x][y].rly;
X			fromx += 1 + 26*x; fromy += 7*y;
X		} else {
X			fromx = r[x][y].rlx + r[x][y].dx;
X			fromy = r[x][y].rly + rn2(r[x][y].dy);
X			fromx += 1 + 26*x; fromy += 7*y;
X			if (!IS_WALL(levl[fromx][fromy].typ))
X				impossible("down: no wall at %d,%d?",fromx,
X									fromy);
X			dodoor(fromx, fromy, &rooms[r[x][y].nroom]);
X			levl[fromx][fromy].doormask = D_NODOOR;
X			fromx++;
X		}
X		if(x >= 2) {
X			impossible("right door from %d,%d going nowhere?",x,y);
X			return;
X		}
X		x++;
X		r[x][y].doortable &= ~LEFT;
X		if (!r[x][y].real) {
X			tox = r[x][y].rlx; toy = r[x][y].rly;
X			tox += 1 + 26*x; toy += 7*y;
X		} else {
X			tox = r[x][y].rlx - 1;
X			toy = r[x][y].rly + rn2(r[x][y].dy);
X			tox += 1 + 26*x; toy += 7*y;
X			if (!IS_WALL(levl[tox][toy].typ))
X				impossible("left: no wall at %d,%d?",tox,toy);
X			dodoor(tox, toy, &rooms[r[x][y].nroom]);
X			levl[tox][toy].doormask = D_NODOOR;
X			tox--;
X		}
X		roguejoin(fromx, fromy, tox, toy, TRUE);
X		return;
X	} else impossible("corridor in direction %d?",dir);
X}
X			
X/* Modified walkfrom() from mkmaze.c */
Xstatic
Xvoid
Xminiwalk(x, y)
Xint x,y;
X{
X	register int q, dir;
X	int dirs[4];
X
X	while(1) {
X		q = 0;
X#define doorhere (r[x][y].doortable)
X		if (x>0 && (!(doorhere & LEFT)) &&
X					(!r[x-1][y].doortable || !rn2(10)))
X			dirs[q++] = 0;
X		if (x<2 && (!(doorhere & RIGHT)) &&
X					(!r[x+1][y].doortable || !rn2(10)))
X			dirs[q++] = 1;
X		if (y>0 && (!(doorhere & UP)) &&
X					(!r[x][y-1].doortable || !rn2(10)))
X			dirs[q++] = 2;
X		if (y<2 && (!(doorhere & DOWN)) &&
X					(!r[x][y+1].doortable || !rn2(10)))
X			dirs[q++] = 3;
X	/* Rogue levels aren't just 3 by 3 mazes; they have some extra
X	 * connections, thus that 1/10 chance
X	 */
X		if (!q) return;
X		dir = dirs[rn2(q)];
X		switch(dir) { /* Move in direction */
X			case 0: doorhere |= LEFT;
X				x--;
X				doorhere |= RIGHT;
X				break;
X			case 1: doorhere |= RIGHT;
X				x++;
X				doorhere |= LEFT;
X				break;
X			case 2: doorhere |= UP;
X				y--;
X				doorhere |= DOWN;
X				break;
X			case 3: doorhere |= DOWN;
X				y++;
X				doorhere |= UP;
X				break;
X		}
X		miniwalk(x,y);
X	}
X}
X
Xvoid
Xmakeroguerooms() {
X	register struct mkroom *croom;
X	register int x,y;
X	int x2, y2;
X	/* Rogue levels are structured 3 by 3, with each section containing
X	 * a room or an intersection.  The minimum width is 2 each way.
X	 * One difference between these and "real" Rogue levels: real Rogue
X	 * uses 24 rows and NetHack only 23.  So we cheat a bit by making the
X	 * second row of rooms not as deep.
X	 *
X	 * Each normal space has 6/7 rows and 25 columns in which a room may
X	 * actually be placed.  Walls go from rows 0-5/6 and columns 0-24.
X	 * Not counting walls, the room may go in
X	 * rows 1-5 and columns 1-23 (numbering starting at 0).  A room
X	 * coordinate of this type may be converted to a level coordinate
X	 * by adding 1+28*x to the column, and 7*y to the row.  (The 1
X	 * is because column 0 isn't used [we only use 1-78]).
X	 * Room height may be 2-4 (2-5 on last row), length 2-23 (not
X	 * counting walls)
X	 */
X#define here r[x][y]
X
X	nroom = 0;
X	for(y=0; y<3; y++) for(x=0; x<3; x++) {
X		/* Note: we want to insure at least 1 room.  So, if the
X		 * first 8 are all dummies, force the last to be a room.
X		 */
X		if (!rn2(5) && (nroom || (x<2 && y<2))) {
X			/* Arbitrary: dummy rooms may only go where real
X			 * ones do.
X			 */
X			here.real = FALSE;
X			here.rlx = rn1(22, 2);
X			here.rly = rn1((y==2)?4:3, 2);
X		} else {
X			here.real = TRUE;
X			here.dx = rn1(22, 2); /* 2-23 long, plus walls */
X			here.dy = rn1((y==2)?4:3, 2); /* 2-5 high, plus walls */
X
X			/* boundaries of room floor */
X			here.rlx = rnd(23 - here.dx + 1);
X			here.rly = rnd(((y==2) ? 5 : 4)- here.dy + 1);
X			nroom++;
X		}
X		here.doortable = 0;
X	}
X	miniwalk(rn2(3), rn2(3));
X	nroom = 0;
X	for(y=0; y<3; y++) for(x=0; x<3; x++) {
X		if (here.real) { /* Make a room */
X			r[x][y].nroom = nroom;
X			croom = &rooms[nroom];
X			/* Illumination.  Strictly speaking, it should be lit
X			 * only if above level 10, but since Rogue rooms are
X			 * only encountered below level 10...
X			 */
X			if (!rn2(7)) {
X				for(x2 = 1+26*x+here.rlx-1;
X				    x2 <= 1+26*x+here.rlx+here.dx; x2++)
X				for(y2 = 7*y+here.rly-1;
X				    y2 <= 7*y+here.rly+here.dy; y2++)
X					levl[x2][y2].lit = 1;
X				croom->rlit = 1;
X			} else croom->rlit = 0;
X			croom->lx = 1 + 26*x + here.rlx;
X			croom->ly = 7*y + here.rly;
X			croom->hx = 1 + 26*x + here.rlx + here.dx - 1;
X			croom->hy = 7*y + here.rly + here.dy - 1;
X			/* Walls, doors, and floors. */
X#define lowx croom->lx
X#define lowy croom->ly
X#define hix croom->hx
X#define hiy croom->hy
X			for(x2 = lowx-1; x2 <= hix+1; x2++)
X			    for(y2 = lowy-1; y2 <= hiy+1; y2 += (hiy-lowy+2)) {
X				levl[x2][y2].scrsym = HWALL_SYM;
X				levl[x2][y2].typ = HWALL;
X			}
X			for(x2 = lowx-1; x2 <= hix+1; x2 += (hix-lowx+2))
X			    for(y2 = lowy; y2 <= hiy; y2++) {
X				levl[x2][y2].scrsym = VWALL_SYM;
X				levl[x2][y2].typ = VWALL;
X			}
X			for(x2 = lowx; x2 <= hix; x2++)
X			    for(y2 = lowy; y2 <= hiy; y2++) {
X				levl[x2][y2].scrsym = ROOM_SYM;
X				levl[x2][y2].typ = ROOM;
X			}
X			levl[lowx-1][lowy-1].typ = TLCORNER;
X			levl[hix+1][lowy-1].typ = TRCORNER;
X			levl[lowx-1][hiy+1].typ = BLCORNER;
X			levl[hix+1][hiy+1].typ = BRCORNER;
X			levl[lowx-1][lowy-1].scrsym = TLCORN_SYM;
X			levl[hix+1][lowy-1].scrsym = TRCORN_SYM;
X			levl[lowx-1][hiy+1].scrsym = BLCORN_SYM;
X			levl[hix+1][hiy+1].scrsym = BRCORN_SYM;
X
X			/* Misc. */
X			smeq[nroom] = nroom;
X			croom->rtype = OROOM;
X			croom++;
X			croom->hx = -1;
X			nroom++;
X		}
X	}
X
X	/* Now, add connecting corridors. */
X	for(y=0; y<3; y++) for(x=0; x<3; x++) {
X		if (here.doortable & DOWN)
X			roguecorr(x, y, DOWN);
X		if (here.doortable & RIGHT)
X			roguecorr(x, y, RIGHT);
X		if (here.doortable & LEFT)
X			impossible ("left end of %d, %d never connected?",x,y);
X		if (here.doortable & UP)
X			impossible ("up end of %d, %d never connected?",x,y);
X	}
X}
X
Xvoid
Xcorr(x,y)
X{
X	if (rn2(50)) {
X		levl[x][y].typ = CORR;
X		levl[x][y].scrsym = CORR_SYM;
X	} else {
X		levl[x][y].typ = SCORR;
X		levl[x][y].scrsym = STONE_SYM;
X	}
X}
X
Xvoid
Xmakerogueghost()
X{
X	register struct monst *ghost;
X	struct obj *ghostobj;
X	struct mkroom *croom;
X	int x,y;
X
X	if (!nroom) return; /* Should never happen */
X	croom = &rooms[rn2(nroom)];
X	x = somex(croom); y = somey(croom);
X	if (!(ghost = makemon(&mons[PM_GHOST], x, y)))
X		return;
X	ghost->msleep = 1;
X	Strcpy((char *)ghost->mextra, roguename());
X
X	if (rn2(4)) {
X		ghostobj = mksobj_at(FOOD_RATION,x,y);
X		ghostobj->quan = rnd(7);
X		ghostobj->owt = weight(ghostobj);
X	}
X	if (rn2(2)) {
X		ghostobj = mksobj_at(MACE,x,y);
X		ghostobj->spe = rnd(3);
X		if (rn2(4)) curse(ghostobj);
X	} else {
X		ghostobj = mksobj_at(TWO_HANDED_SWORD,x,y);
X		ghostobj->spe = rnd(5) - 2;
X		if (rn2(4)) curse(ghostobj);
X	}
X	ghostobj = mksobj_at(BOW,x,y);
X	ghostobj->spe = 1;
X	if (rn2(4)) curse(ghostobj);
X
X	ghostobj = mksobj_at(ARROW,x,y);
X	ghostobj->spe = 0;
X	ghostobj->quan = rn1(10,25);
X	ghostobj->owt = weight(ghostobj);
X	if (rn2(4)) curse(ghostobj);
X
X	if (rn2(2)) {
X		ghostobj = mksobj_at(RING_MAIL,x,y);
X		ghostobj->spe = rn2(3);
X		if (!rn2(3)) ghostobj->rustfree = 1;
X		if (rn2(4)) curse(ghostobj);
X	} else {
X		ghostobj = mksobj_at(PLATE_MAIL,x,y);
X		ghostobj->spe = rnd(5) - 2;
X		if (!rn2(3)) ghostobj->rustfree = 1;
X		if (rn2(4)) curse(ghostobj);
X	}
X	if (rn2(2)) {
X		ghostobj = mksobj_at(AMULET_OF_YENDOR,x,y);
X		ghostobj->spe = -1;
X		ghostobj->known = TRUE;
X	}
X}
X#endif /* REINCARNATION /**/
END_OF_FILE
if test 9819 -ne `wc -c <'src/extralev.c'`; then
    echo shar: \"'src/extralev.c'\" unpacked with wrong size!
fi
# end of 'src/extralev.c'
fi
if test -f 'src/fountain.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/fountain.c'\"
else
echo shar: Extracting \"'src/fountain.c'\" \(10150 characters\)
sed "s/^X//" >'src/fountain.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)fountain.c	3.0	88/12/22
X/* Code for drinking from fountains.   */
X/* Scott R. Turner, srt@ucla, 10/27/86 */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include "hack.h"
X
X#ifdef FOUNTAINS
X
Xstatic
Xvoid
Xdowatersnakes() /* Fountain of snakes! */ {
X	register int num = rnd(6);
X	if (!(mons[PM_WATER_MOCCASIN].geno & G_GENOD)) {	/* && chgd to &*/
X
X		pline("Good Lord!  An endless stream of snakes pours forth!");
X		while(num-- > 0) (void) makemon(&mons[PM_WATER_MOCCASIN],u.ux,u.uy);
X	} else
X		pline("The fountain bubbles furiously for a moment, then calms.");
X}
X
Xstatic
Xvoid
Xdowaterdemon() /* Water demon */ {
Xregister struct monst *mtmp;
X
X	if((mtmp = makemon(&mons[PM_WATER_DEMON],u.ux,u.uy))) {
X	    You("have unleashed %s!", defmonnam(mtmp));
X
X	/* Give those on low levels a (slightly) better chance of survival */
X	    if ( rnd(100) > (80 + dlevel)) {
X		pline("Grateful for his release, he grants you a wish!");
X		makewish();
X		mongone(mtmp);
X	    }
X	}
X}
X
Xstatic
Xvoid
Xdowaternymph() /* Water Nymph */ {
X	register struct monst *mtmp;
X	if((mtmp = makemon(&mons[PM_WATER_NYMPH],u.ux,u.uy))) {
X
X		You("have attracted %s!", defmonnam(mtmp));
X		mtmp->msleep = 0;
X	} else
X		pline("A large bubble rises to the surface and pops.");
X}
X
X
Xstatic
Xvoid
Xdogushforth(drinking) /* Gushing forth in this room */
Xint drinking;
X{
Xregister int num = rnd(10);
Xregister xchar mx,my;
Xregister int tryct = 0;
Xregister int uroom = inroom(u.ux, u.uy);
Xregister struct mkroom *croom = &rooms[uroom];
Xregister int madepool = 0;
X
X	if(croom->hx < 0 || has_upstairs(croom) ||
X	   has_dnstairs(croom))  {
X		if (drinking) Your("thirst is quenched.");
X		else pline("Water sprays all over you.");
X		return;
X	}
X	while(num--) {
X	    do {
X		if(++tryct > 200)  {
X		    if(madepool)
X			pline("Water gushes forth from the overflowing fountain!");
X		    else if (drinking) Your("thirst is quenched.");
X		else pline("Water sprays all over you.");
X		    return;
X		}
X		mx = somex(croom);
X		my = somey(croom);
X	    } while(nexttodoor(mx,my) || !((mx+my)%2) ||
X		    (mx == u.ux && my == u.uy) ||
X		    (IS_POOL(levl[mx][my].typ)));
X		       
X	    /* Put a pool at mx, my */
X		     
X	    levl[mx][my].typ = POOL;
X	    levl[mx][my].doormask = 0;
X	    if(!Blind) atl(mx,my,(char) POOL_SYM);
X	    madepool = 1;
X	}
X
X	pline("Water gushes forth from the overflowing fountain!");
X}
X
Xstatic
Xvoid
Xdofindgem() /* Find a gem in the sparkling waters. */ {
X
X	if (!Blind) You("spot a gem in the sparkling waters!");
X	(void) mkobj_at(GEM_SYM,u.ux,u.uy);
X	levl[u.ux][u.uy].doormask = T_LOOTED;
X}
X
Xvoid
Xdryup(){
X	if (!rn2(3) && (levl[u.ux][u.uy].typ == FOUNTAIN)) {
X		pline("The fountain dries up!");
X		levl[u.ux][u.uy].typ = ROOM;
X		levl[u.ux][u.uy].doormask = 0;
X		if(Invisible) newsym(u.ux, u.uy);
X		fountsound--;
X	}
X}
X
Xvoid
Xdrinkfountain() {
X
X	/* What happens when you drink from a fountain? */
X	register int fate = rnd(30);
X
X	if(Levitation)	{
X		You("are floating high above the fountain.");
X		return;
X	}
X	else if (fate < 10) {
X		pline("The cool draught refreshes you.");
X		lesshungry(rnd(10));
X	} else {
X	    switch (fate) {
X
X		case 19: /* Self-knowledge */
X
X			You("feel self-knowledgable...");
X			more();
X			enlightenment();
X			pline("The feeling subsides.");
X			break;
X
X		case 20: /* Foul water */
X
X			pline("The water is foul!  You gag and vomit.");
X			morehungry(rnd(20)+10);
X			vomit();
X			break;
X
X		case 21: /* Poisonous */
X
X			pline("The water is contaminated!");
X			if (Poison_resistance) {
X	   pline("Perhaps it is runoff from the nearby %s farm.", pl_fruit);
X			   losehp(rnd(4),"unrefrigerated sip of juice");
X			   break;
X			}
X			losestr(rn1(4,3));
X			losehp(rnd(10),"contaminated water");
X			break;
X	
X		case 22: /* Fountain of snakes! */
X
X			dowatersnakes();
X			break;
X
X		case 23: /* Water demon */
X			dowaterdemon();
X			break;
X
X		case 24: /* Curse an item... */ {
X			register struct obj *obj;
X
X			pline("This water's no good!");
X			morehungry(rnd(20)+10);
X			for(obj = invent; obj ; obj = obj->nobj)
X				if (!rn2(5))	curse(obj);
X			break;
X			}
X			 
X		case 25: /* See invisible */
X
X			You("see an image of someone stalking you.");
X			pline("But it disappears.");
X			HSee_invisible |= INTRINSIC;
X			break;
X
X		case 26: /* See Monsters */
X
X			(void) monster_detect((struct obj *)0);
X			break;
X
X		case 27: /* Find a gem in the sparkling waters. */
X
X			if (levl[u.ux][u.uy].doormask == 0) {
X				dofindgem();
X				break;
X			}
X
X		case 28: /* Water Nymph */
X
X			dowaternymph();
X			break;
X
X		case 29: /* Scare */ {
X			register struct monst *mtmp;
X
X			pline("This water gives you bad breath!");
X			for(mtmp = fmon; mtmp; mtmp = mtmp->nmon) 
X				mtmp->mflee = 1;
X			}
X			break;
X
X		case 30: /* Gushing forth in this room */
X
X			dogushforth(TRUE);
X			break;
X
X		default:
X
X			pline("This tepid water is tasteless.");
X			break;
X	    }
X	}
X	dryup();
X}
X
Xvoid
Xdipfountain(obj)
Xregister struct obj *obj;
X{
X	register int fate = rnd(30);
X
X	if(Levitation)	You("are floating high above the fountain.");
X	else if(fate<10)
X		if(!obj->rustfree && is_sword(obj)) {
X			if(obj->spe > -6) {
X				Your("sword rusts somewhat.");
X				obj->spe--;
X			} else Your("sword looks quite rusted.");
X		} else pline("Well, it looks wet now.");
X	else if(fate<14)
X		if(obj->otyp == LONG_SWORD
X#ifndef NAMED_ITEMS
X		   && !strcmp(ONAME(obj), "Excalibur")
X#endif
X		   && u.ulevel >= 5
X		) {
X			/* The lady of the lake acts! - Eric Backus */
X			/* Be *REAL* nice to him */
X	pline("A murky hand from the depths reaches up to bless the sword.");
X	pline("As the hand retreats, the fountain disappears!");
X
X#ifndef NAMED_ITEMS
X			if(obj->spe < 5) obj->spe = 5;
X#else
X			/* otherwise +rnd(10) / +5 "Super"sword */
X			obj = oname(obj, "Excalibur", 1);
X#endif
X			bless(obj);
X			obj->rustfree = 1;
X			levl[u.ux][u.uy].typ = ROOM;
X			if(Invisible) newsym(u.ux, u.uy);
X			fountsound--;
X			return;
X		} else pline ("Well, it looks wet now.");
X	else {
X	    switch (fate) {
X		case 16: /* Curse the item */
X			pline("Well, it looks wet now.");
X			curse(obj);
X			break;
X		case 17:
X		case 18:
X		case 19:
X		case 20: /* Uncurse the item */
X			if(obj->cursed) {
X			    if (!Blind)
X				pline("The water glows for a moment.");
X			    obj->cursed = 0;
X			} else {
X			    pline("A feeling of loss comes over you.");
X			}
X			break;
X		case 21: /* Water Demon */
X			dowaterdemon();
X			break;
X		case 22: /* Water Nymph */
X			dowaternymph();
X			break;
X		case 23: /* An Endless Stream Of Snakes */
X			dowatersnakes();
X			break;
X		case 24: /* Find a gem */
X			dofindgem();
X			break;
X		case 25: /* Water gushes forth */
X			dogushforth(FALSE);
X			break;
X		case 26: /* Strange feeling */
X			pline("A strange tingling runs up your %s.",
X							body_part(ARM));
X			break;
X		case 27: /* Strange feeling */
X			You("feel a sudden chill.");
X			break;
X		case 28: /* Strange feeling */
X			pline("An urge to take a bath overwhelms you.");
X			if (u.ugold > 10) {
X			     	u.ugold -= somegold()/10;
X			  You("lost some of your gold in the fountain!");
X			  levl[u.ux][u.uy].doormask = 0;
X	 		}
X			break;
X		case 29: /* You see coins */
X
X		/* We make fountains have more coins the closer you are to the
X		 * surface.  After all, there will have been more people going
X		 * by.  Just like a shopping mall!  Chris Woodbury  */
X
X			mkgold((long)(rnd((MAXLEVEL-dlevel)*2)+5),u.ux,u.uy);
X		pline("Far below you, you see coins glistening in the water.");
X			break;
X		default:
X			break;
X	    }
X	}
X	dryup();
X	return;
X}
X#endif
X
X#ifdef SINKS
Xvoid
Xdrinksink()
X{
X	if (Levitation) {
X		You("are floating high above the sink.");
X		return;
X	}
X	switch(rn2(20)) {
X		static struct obj *otmp;
X		case 0: You("take a sip of very cold water.");
X			break;
X		case 1: You("take a sip of very warm water.");
X			break;
X		case 2: You("take a sip of scalding hot water.");
X			if (Fire_resistance)
X				pline("It seems quite tasty.");
X			else losehp(rnd(6), "sip of boiling water");
X			break;
X		case 3: if (mons[PM_SEWER_RAT].geno & G_GENOD)
X				pline("The sink seems quite dirty.");
X			else {
X				static struct monst *mtmp;
X
X				mtmp = makemon(&mons[PM_SEWER_RAT], u.ux, u.uy);
X				pline("Eek!  There's %s in the sink!",
X					Blind ? "something squirmy" :
X					defmonnam(mtmp));
X			}
X			break;
X		case 4: do {
X				otmp = mkobj(POTION_SYM,FALSE);
X			} while(otmp->otyp == POT_WATER);
X			otmp->cursed = otmp->blessed = 0;
X			if (Blind)
X				pline("The sink emits some odd liquid.");
X			else
X				pline("The sink emits a stream of %s water.",
X				    Hallucination ? hcolor() :
X				    objects[otmp->otyp].oc_descr);
X			otmp->dknown = !(Blind || Hallucination);
X			otmp->quan++; /* Avoid panic upon useup() */
X			otmp->corpsenm = 1; /* kludge for docall() */
X			(void) dopotion(otmp);
X			obfree(otmp, (struct obj *)0);
X			break;
X		case 5: if (levl[u.ux][u.uy].doormask == 0) {
X			    You("find a ring in the sink!");
X			    (void) mkobj_at(RING_SYM, u.ux, u.uy);
X			    levl[u.ux][u.uy].doormask = T_LOOTED;
X			} else pline("Some dirty water backs up in the drain.");
X			break;
X		case 6: pline("The pipes break!  Water spurts out!");
X			sinksound--;
X			levl[u.ux][u.uy].doormask = 0;
X#ifdef FOUNTAINS
X			levl[u.ux][u.uy].typ = FOUNTAIN;
X			fountsound++;
X#else
X			levl[u.ux][u.uy].typ = ROOM;
X#endif
X			if (Invisible) newsym(u.ux,u.uy);
X			break;
X		case 7: pline("The water moves as though of its own will!");
X			if (!makemon(&mons[PM_WATER_ELEMENTAL], u.ux, u.uy))
X				pline("But it quiets down.");
X			break;
X		case 8: pline("Yuk, this water tastes awful.");
X			more_experienced(1,0);
X			newexplevel();
X			break;
X		case 9: pline("Gaggg... this tastes like sewage!  You vomit.");
X			morehungry(rnd(30-ACURR(A_CON))+10);
X			vomit();
X			break;
X#ifdef POLYSELF
X		case 10: pline("This water contains toxic wastes!");
X			You("undergo a freakish metamorphosis!");
X			polyself();
X			break;
X#endif
X		/* more odd messages --JJB */
X		case 11: You("hear clanking from the pipes....");
X			break;
X		case 12: You("hear snatches of song from among the sewers...");
X			break;
X		case 19: if (Hallucination) {
X				pline("A murky hand reaches up out of the drain... --oops--");
X				break;
X			}
X		default: You("take a sip of %s water.",
X			rn2(3) ? (rn2(2) ? "cold" : "warm") : "hot");
X	}
X}
X#endif /* SINKS /**/
END_OF_FILE
if test 10150 -ne `wc -c <'src/fountain.c'`; then
    echo shar: \"'src/fountain.c'\" unpacked with wrong size!
fi
# end of 'src/fountain.c'
fi
if test -f 'src/makedefs.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/makedefs.c'\"
else
echo shar: Extracting \"'src/makedefs.c'\" \(9602 characters\)
sed "s/^X//" >'src/makedefs.c' <<'END_OF_FILE'
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X/* makedefs.c - NetHack version 3.0 */
X
X#define MAKEDEFS_C
X
X#define EXTERN_H
X#include	"config.h"
X#include	"permonst.h"
X#include	"objclass.h"
X#ifdef NULL
X#undef NULL
X#endif /* NULL */
X#define NULL	((genericptr_t)0)
X
X#ifndef LINT
Xstatic	const char	SCCS_Id[] = "@(#)makedefs.c\t3.0\t89/01/10";
X#endif
X
X#ifdef MSDOS
X# define freopen _freopen
X# undef	exit
Xextern void exit P((int));
X# define RDMODE	"r"
X# define WRMODE	"w"
X#else
X# define RDMODE  "r+"
X# define WRMODE  "w+"
X#endif
X#if defined(SYSV) || defined(GENIX) || defined(UNIXDEBUG)
Xvoid rename();
X#endif
X#ifdef AMIGA
X# undef freopen
X# undef printf
X# undef puts
X# undef fflush
X# define fflush FFLUSH
X# undef fputs
X# undef fprintf
X#endif
X
X/* construct definitions of object constants */
X
X#ifdef AMIGA
X# define MONST_FILE	 "include:pm.h"
X# define ONAME_FILE	 "include:onames.h"
X# define TRAP_FILE	 "include:trap.h"
X# define DATE_FILE	 "include:date.h"
X# define DATA_FILE	 "auxil:data"
X# define RUMOR_FILE	 "auxil:rumors"
X#else
X# define MONST_FILE	 "../include/pm.h"
X# define ONAME_FILE	 "../include/onames.h"
X# define TRAP_FILE	 "../include/trap.h"
X# define DATE_FILE	 "../include/date.h"
X# define DATA_FILE	 "../auxil/data"
X# define RUMOR_FILE	 "../auxil/rumors"
X#endif
X
Xchar	in_line[256];
Xextern char *gets P((char *));
Xvoid do_objs(), do_traps(), do_data(), do_date(), do_permonst(), do_rumors();
Xchar *limit P((char *,boolean));
XFILE *_freopen();
X
Xint
Xmain(argc, argv)
Xint	argc;
Xchar	*argv[];
X{
X	char	*option;
X
X	if(argc == 2) {
X	    option = argv[1];
X	    switch (option[1]) {
X
X		case 'o':
X		case 'O':	do_objs();
X				break;
X		case 't':
X		case 'T':	do_traps();
X				break;
X
X		case 'd':
X		case 'D':	do_data();
X				break;
X
X		case 'v':
X		case 'V':	do_date();
X				break;
X
X		case 'p':
X		case 'P':	do_permonst();
X				break;
X
X		case 'r':
X		case 'R':	do_rumors();
X				break;
X
X		default:
X				(void) fprintf(stderr, "Unknown option '%c'.\n", option[1]);
X				(void) fflush(stderr);
X				exit(1);
X	    }
X	    exit(0);
X	} else	(void) fprintf(stderr, "Bad arg count (%d).\n", argc-1);
X	(void) fflush(stderr);
X	exit(1);
X/*NOTREACHED*/
X#ifdef MSDOS
X	return 0;
X#endif
X}
X
Xvoid
Xdo_traps() {
X	int	ntrap;
X	char	tempfile[30];
X
X	Sprintf(tempfile, "makedefs.%d", getpid());
X	if(freopen(tempfile, WRMODE, stdout) == (FILE *)0) {
X		perror(tempfile);
X		exit(1);
X	}
X
X	if(freopen(TRAP_FILE, RDMODE, stdin) == (FILE *)0) {
X		perror(TRAP_FILE);
X		exit(1);
X	}
X
X	while(gets(in_line) != NULL) {
X	    (void) puts(in_line);
X	    if(!strncmp(in_line, "/* DO NOT REMOVE THIS LINE */", 29)) break;
X	}
X	ntrap = 10;
X	Printf("\n");
X	Printf("#define\tMGTRP\t\t%d\n", ntrap++);
X	Printf("#define\tSQBRD\t\t%d\n", ntrap++);
X	Printf("#define\tWEB\t\t%d\n", ntrap++);
X	Printf("#define\tSPIKED_PIT\t%d\n", ntrap++);
X	Printf("#define\tLEVEL_TELEP\t%d\n", ntrap++);
X#ifdef SPELLS
X	Printf("#define\tANTI_MAGIC\t%d\n", ntrap++);
X#endif
X	Printf("#define\tRUST_TRAP\t%d\n", ntrap++);
X#ifdef POLYSELF
X	Printf("#define\tPOLY_TRAP\t%d\n", ntrap++);
X#endif
X	Printf("#define\tLANDMINE\t%d\n", ntrap++);
X	Printf("\n#define\tTRAPNUM\t%d\n", ntrap);
X	Printf("\n#endif /* TRAP_H /**/\n");
X	(void) fclose(stdin);
X	(void) fclose(stdout);
X#ifdef MSDOS
X	remove(TRAP_FILE);
X#endif
X	rename(tempfile, TRAP_FILE);
X	return;
X}
X
X
Xvoid
Xdo_rumors(){
X	char	infile[30];
X	FILE	*freopen();
X	long	true_rumor_size;
X
X	if(freopen(RUMOR_FILE, WRMODE, stdout) == (FILE *)0) {
X		perror(RUMOR_FILE);
X		exit(1);
X	}
X
X	Sprintf(infile, "%s.tru", RUMOR_FILE);
X	if(freopen(infile, RDMODE, stdin) == (FILE *)0) {
X		perror(infile);
X		exit(1);
X	}
X
X	/* get size of true rumors file */
X	(void) fseek(stdin, 0L, 2);
X	true_rumor_size = ftell(stdin);
X	(void) fwrite((genericptr_t)&true_rumor_size,sizeof(long),1,stdout);
X	(void) fseek(stdin, 0L, 0);
X
X	/* copy true rumors */
X	while(gets(in_line) != NULL)	 (void) puts(in_line);
X
X	Sprintf(infile, "%s.fal", RUMOR_FILE);
X	if(freopen(infile, RDMODE, stdin) == (FILE *)0) {
X		perror(infile);
X		exit(1);
X	}
X
X	/* copy false rumors */
X	while(gets(in_line) != NULL)	 (void) puts(in_line);
X
X	(void) fclose(stdin);
X	(void) fclose(stdout);
X	return;
X}
X
X#ifdef SYSV
Xextern long time();
X#endif
X
Xvoid
Xdo_date(){
X	long	clock;
X	char	cbuf[30], *c;
X
X	if(freopen(DATE_FILE, WRMODE, stdout) == (FILE *)0) {
X		perror(DATE_FILE);
X		exit(1);
X	}
X	Printf("/*\tSCCS Id: @(#)date.h\t3.0\t88/11/20 */\n\n");
X
X	(void) time(&clock);
X	Strcpy(cbuf, ctime(&clock));
X	for(c = cbuf; *c != '\n'; c++);	*c = 0; /* strip off the '\n' */
X	Printf("const char datestring[] = \"%s\";\n", cbuf);
X
X	(void) fclose(stdout);
X	return;
X}
X
Xvoid
Xdo_data(){
X	char	tempfile[30];
X
X	Sprintf(tempfile, "%s.base", DATA_FILE);
X	if(freopen(tempfile, RDMODE, stdin) == (FILE *)0) {
X		perror(tempfile);
X		exit(1);
X	}
X
X	if(freopen(DATA_FILE, WRMODE, stdout) == (FILE *)0) {
X		perror(DATA_FILE);
X		exit(1);
X	}
X
X	while(gets(in_line) != NULL) {
X#ifdef  SINKS
X	    if(!strcmp(in_line, "#\ta corridor"))
X		Printf("#\ta corridor (or a kitchen sink)\n");
X	    else
X#endif
X#ifdef	ALTARS
X	    if(!strcmp(in_line, "_\tan iron chain"))
X		Printf("_\tan iron chain (or an altar)\n");
X	    else
X#endif
X#ifdef	SPELLS
X	    if(!strcmp(in_line, "+\ta door"))
X		Printf("+\ta door (or a spell book)\n");
X	    else
X#endif
X#ifdef	FOUNTAINS
X	    if(!strcmp(in_line, "}\twater filled area")) {
X		(void) puts(in_line);
X		Printf("{\ta fountain\n");
X	    } else
X#endif
X#ifdef	THRONES
X	    if(!strcmp(in_line, "^\ta trap")) {
X		(void) puts(in_line);
X		Printf("\\\tan opulent throne\n");
X	    } else
X#endif
X	    if(!strcmp(in_line, ";\ta giant eel")) {
X		(void) puts(in_line);
X#ifdef	WORM
X		Printf("~\tthe tail of a long worm\n");
X#endif
X#ifdef	GOLEMS
XPrintf("'\ta golem\n");
XPrintf("\t\tThese creatures, not quite living but not  really  nonliving\n");
XPrintf("\t\teither,   are   created from inanimate materials by powerful\n");
XPrintf("\t\tmages or priests.\n");
X#endif
X	    } else
X	      (void) puts(in_line);
X	}
X	(void) fclose(stdin);
X	(void) fclose(stdout);
X	return;
X}
X
Xvoid
Xdo_permonst() {
X
X	int	i;
X	char	*c;
X
X	if(freopen(MONST_FILE, WRMODE, stdout) == (FILE *)0) {
X		perror(MONST_FILE);
X		exit(1);
X	}
X	Printf("/*\tSCCS Id: @(#)pm.h\t3.0\t88/11/20 */\n\n");
X	Printf("#ifndef PM_H\n#define PM_H\n");
X
X	for(i = 0; mons[i].mlet; i++) {
X		Printf("\n#define\tPM_");
X		for(c = mons[i].mname; *c; c++) {
X		    if((*c >= 'a') && (*c <= 'z')) *c -= (char)('a' - 'A');
X		    else if(*c == ' ' || *c == '-')	*c = '_';
X		}
X		Printf("%s\t%d", mons[i].mname, i);
X	}
X	Printf("\n\n#define\tNUMMONS\t%d\n", i);
X	Printf("\n#endif /* PM_H /**/\n");
X	(void) fclose(stdout);
X	return;
X}
X
Xstatic	char	temp[32];
X
Xchar *
Xlimit(name,pref)	/* limit a name to 30 characters length */
Xchar	*name;
Xboolean	pref;
X{
X	(void) strncpy(temp, name, pref ? 26 : 30);
X	temp[pref ? 26 : 30] = 0;
X	return temp;
X}
X
Xvoid
Xdo_objs() {
X
X	register int i = 0, sum = 0;
X	register char *c;
X#ifdef SPELLS
X	register int nspell = 0;
X#endif
X	register boolean prefix = 0;
X	register char let = '\0';
X	boolean	sumerr = FALSE;
X
X	if(freopen(ONAME_FILE, WRMODE, stdout) == (FILE *)0) {
X		perror(ONAME_FILE);
X		exit(1);
X	}
X	Printf("/*\tSCCS Id: @(#)onames.h\t3.0\t89/01/10 */\n\n");
X	Printf("#ifndef ONAMES_H\n#define ONAMES_H\n\n");
X
X	for(i = 0; !i || objects[i].oc_olet != ILLOBJ_SYM; i++) {
X		if (!(c = objects[i].oc_name)) continue;
X
X		/* make sure probabilities add up to 1000 */
X		if(objects[i].oc_olet != let) {
X			if (sum && sum != 1000) {
X			    (void) fprintf(stderr, "prob error for %c (%d%%)", let, sum);
X			    (void) fflush(stderr);
X			    sumerr = TRUE;
X			}
X			let = objects[i].oc_olet;
X			sum = 0;
X		}
X
X		for(; *c; c++) {
X		    if((*c >= 'a') && (*c <= 'z')) *c -= (char)('a' - 'A');
X		    else if(*c == ' ' || *c == '-')	*c = '_';
X		}
X
X		switch (let) {
X		    case WAND_SYM:
X			Printf("#define\tWAN_"); prefix = 1; break;
X		    case RING_SYM:
X			Printf("#define\tRIN_"); prefix = 1; break;
X		    case POTION_SYM:
X			Printf("#define\tPOT_"); prefix = 1; break;
X#ifdef SPELLS
X		    case SPBOOK_SYM:
X			Printf("#define\tSPE_"); prefix = 1; nspell++; break;
X#endif
X		    case SCROLL_SYM:
X			Printf("#define\tSCR_"); prefix = 1; break;
X		    case GEM_SYM:
X			/* avoid trouble with stupid C preprocessors */
X			if(objects[i].oc_material == GLASS) {
X			    Printf("/* #define\t%s\t%d */\n", objects[i].oc_name, i);
X			    continue;
X			}
X		    default:
X			Printf("#define\t");
X		}
X		Printf("%s\t%d\n", limit(objects[i].oc_name, prefix), i);
X		prefix = 0;
X
X		sum += objects[i].oc_prob;
X	}
X	Printf("#define\tLAST_GEM\t(JADE+1)\n");
X#ifdef SPELLS
X	Printf("#define\tMAXSPELL\t%d\n", nspell+1);
X#endif
X	Printf("#define\tNROFOBJECTS\t%d\n", i-1);
X	Printf("\n#endif /* ONAMES_H /**/\n");
X	(void) fclose(stdout);
X	if (sumerr) exit(1);
X	return;
X}
X
X#if defined(SYSV) || defined(GENIX) || defined(UNIXDEBUG)
Xvoid
Xrename(oldname, newname)
Xchar	*oldname, *newname;
X{
X	if (strcmp(oldname, newname)) {
X		(void) unlink(newname);
X		(void) link(oldname, newname);
X		(void) unlink(oldname);
X	}
X	return;
X}
X#endif
X
X#ifdef MSDOS
X# ifndef AMIGA
X/* Get around bug in freopen when opening for writing	*/
X/* Supplied by Nathan Glasser (nathan@mit-eddie)	*/
X#undef freopen
XFILE *
X_freopen(fname, fmode, fp)
Xchar *fname, *fmode;
XFILE *fp;
X{
X    if (!strncmp(fmode,"w",1))
X    {
X	FILE *tmpfp;
X
X	if ((tmpfp = fopen(fname,fmode)) == (FILE *)0)
X	    return (FILE *)0;
X	if (dup2(fileno(tmpfp),fileno(fp)) < 0)
X	    return (FILE *)0;
X	(void) fclose(tmpfp);
X	return fp;
X    }
X    else
X	return freopen(fname,fmode,fp);
X}
X# endif /* AMIGA */
X
X# if defined(__TURBOC__) || defined(AMIGA)
Xint
Xgetpid()
X{
X	return 1;
X}
X# endif
X#endif /* MSDOS */
END_OF_FILE
if test 9602 -ne `wc -c <'src/makedefs.c'`; then
    echo shar: \"'src/makedefs.c'\" unpacked with wrong size!
fi
# end of 'src/makedefs.c'
fi
if test -f 'src/prisym.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/prisym.c'\"
else
echo shar: Extracting \"'src/prisym.c'\" \(10421 characters\)
sed "s/^X//" >'src/prisym.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)prisym.c	3.0	88/11/09
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include "hack.h"
X
X#ifdef WORM
X#include "wseg.h"
X#include "lev.h"
X
Xstatic void pwseg P((struct wseg *));
X#endif
X
Xvoid
Xatl(x,y,ch)
Xregister int x, y;
Xchar ch;
X{
X	register struct rm *crm = &levl[x][y];
X
X	if(x<0 || x>COLNO-1 || y<0 || y>ROWNO-1){
X		impossible("atl(%d,%d,%c)",x,y,ch);
X		return;
X	}
X	if(crm->seen && crm->scrsym == ch) return;
X	/* crm->scrsym = (uchar) ch; */
X	/* wrong if characters are signed but uchar is larger than char,
X	 * and ch, when passed, was greater than 127.
X	 * We probably should _really_ go around changing atl to take a
X	 * uchar for its third argument...
X	 */
X	crm->scrsym = (uchar)((unsigned char) ch);
X	crm->new = 1;
X	on_scr(x,y);
X}
X
Xvoid
Xon_scr(x,y)
Xregister int x, y;
X{
X	if(x < scrlx) scrlx = x;
X	if(x > scrhx) scrhx = x;
X	if(y < scrly) scrly = y;
X	if(y > scrhy) scrhy = y;
X}
X
X/* call: (x,y) - display
X	(-1,0) - close (leave last symbol)
X	(-1,-1)- close (undo last symbol)
X	(-1,let)-open: initialize symbol
X	(-2,let)-change let
X	(-3,let)-set color
X*/
X
Xvoid
Xtmp_at(x, y)
Xint x, y;
X{
X#ifdef LINT	/* static schar prevx, prevy; static char let; */
Xschar prevx=0, prevy=0;
Xuchar let;
Xuchar col;
X#else
Xstatic schar prevx, prevy;
Xstatic uchar let;
Xstatic uchar col;
X#endif
X
X	switch ((int)x) {
X	    case -2:		/* change let call */
X		let = y;
X		return;
X	    case -1:		/* open or close call */
X		if ((int)y >= 0) {
X		    let = y;
X		    prevx = -1;
X		    col = AT_ZAP;
X		    return;
X		}
X		break;
X	    case -3:		/* set color call */
X		col = y;
X		return;
X	}
X	if(prevx >= 0 && cansee(prevx,prevy)) {
X		delay_output();
X		prl(prevx, prevy);	/* in case there was a monster */
X		at(prevx, prevy, levl[prevx][prevy].scrsym, AT_APP);
X	}
X	if(x >= 0){	/* normal call */
X		if(cansee(x,y)) at(x,y,let,col);
X		prevx = x;
X		prevy = y;
X	} else {	/* close call */
X		let = 0;
X		prevx = -1;
X	}
X}
X
X/* like the previous, but the symbols are first erased on completion */
Xvoid
XTmp_at2(x, y)
Xint x, y;
X{
X#ifdef LINT	/* static char let; static xchar cnt; static coord tc[COLNO]; */
Xuchar let;
Xxchar cnt;
Xcoord tc[COLNO];	/* but watch reflecting beams! */
X# ifdef MSDOSCOLOR
Xuchar col;
X# endif
X#else
Xstatic uchar let;
Xstatic xchar cnt;
Xstatic coord tc[COLNO];	/* but watch reflecting beams! */
X# ifdef MSDOSCOLOR
Xstatic uchar col;
X# endif
X#endif
Xregister int xx,yy;
X	switch((int)x) {
X	    case -1:
X		if(y > 0) {	/* open call */
X			let = y;
X			cnt = 0;
X#ifdef MSDOSCOLOR
X			col = AT_ZAP;
X#endif
X			return;
X		}
X		/* close call (do not distinguish y==0 and y==-1) */
X		while(cnt--) {
X			xx = tc[cnt].x;
X			yy = tc[cnt].y;
X			prl(xx, yy);
X			at(xx, yy, levl[xx][yy].scrsym, AT_APP);
X		}
X		cnt = let = 0;	/* superfluous */
X		return;
X	    case -2:		/* change let call */
X		let = y;
X		return;
X#ifdef MSDOSCOLOR
X	    case -3:		/* set color call */
X		col = y;
X		return;
X#endif
X	}
X	/* normal call */
X	if(cansee(x,y)) {
X		if(cnt) delay_output();
X#ifdef MSDOSCOLOR
X		at(x,y,let,col);
X#else
X		at(x,y,let,AT_ZAP);
X#endif
X		tc[cnt].x = x;
X		tc[cnt].y = y;
X		if(++cnt >= COLNO) panic("Tmp_at2 overflow?");
X		levl[x][y].new = 0;	/* prevent pline-nscr erasing --- */
X	}
X}
X
Xvoid
Xcurs_on_u()
X{
X	curs(u.ux, u.uy+2);
X}
X
Xvoid
Xpru()
X{
X	if(u.udispl && (Invisible || u.udisx != u.ux || u.udisy != u.uy))
X		/* if(! levl[u.udisx][u.udisy].new) */
X			if(!vism_at(u.udisx, u.udisy))
X				newsym(u.udisx, u.udisy);
X	if(Invisible
X#ifdef POLYSELF
X			|| u.uundetected
X#endif
X					) {
X		u.udispl = 0;
X		prl(u.ux,u.uy);
X	} else
X	if(!u.udispl || u.udisx != u.ux || u.udisy != u.uy) {
X		atl(u.ux, u.uy, (char) u.usym);
X		u.udispl = 1;
X		u.udisx = u.ux;
X		u.udisy = u.uy;
X	}
X	levl[u.ux][u.uy].seen = 1;
X}
X
X/* print a position that is visible for @ */
Xvoid
Xprl(x,y)
X{
X	register struct rm *room;
X	register struct monst *mtmp = (struct monst *)0;
X	register struct obj *otmp;
X	register struct trap *ttmp;
X
X	if(x == u.ux && y == u.uy && !Invisible
X#ifdef POLYSELF
X						&& !u.uundetected
X#endif
X								) {
X		pru();
X		return;
X	}
X	if(!isok(x,y)) return;
X	room = &levl[x][y];
X	if((!room->typ) ||
X	   (IS_ROCK(room->typ) && levl[u.ux][u.uy].typ == CORR &&
X				  !levl[u.ux][u.uy].lit))
X	    /* the only lit corridor squares should be the entrances to
X	     * outside castle areas */
X		return;
X	if(room->mmask) mtmp = m_at(x,y);
X	if(mtmp && !mtmp->mhide &&
X		(!mtmp->minvis || See_invisible)) {
X#ifdef WORM
X		if(m_atseg)
X			pwseg(m_atseg);
X		else
X#endif
X		pmon(mtmp);
X	}
X	else if(room->omask && !is_pool(x,y)) {
X		otmp = o_at(x,y);
X		atl(x,y,Hallucination ? rndobjsym() : otmp->olet);
X	}
X	else if(room->gmask && !is_pool(x,y))
X		atl(x,y,Hallucination ? rndobjsym() : GOLD_SYM);
X	else if((!mtmp || mtmp->data == &mons[PM_GIANT_SPIDER]) &&
X		  (ttmp = t_at(x,y)) && ttmp->ttyp == WEB)
X		atl(x,y,(char)WEB_SYM);
X	else if(mtmp && (!mtmp->minvis || See_invisible)) {
X		/* must be a hiding monster, but not hiding right now */
X		/* assume for the moment that long worms do not hide */
X		pmon(mtmp);
X	}
X	else if(!room->seen || room->scrsym == STONE_SYM) {
X		room->new = room->seen = 1;
X		newsym(x,y);
X		on_scr(x,y);
X	}
X	room->seen = 1;
X}
X
Xuchar
Xnews0(x,y)
Xregister xchar x,y;
X{
X	register struct obj *otmp;
X	register struct trap *ttmp;
X	struct rm *room;
X	register uchar tmp;	/* don't compare char with uchar -- OIS */
X	register int croom;
X
X	room = &levl[x][y];
X	/* note: a zero scrsym means to ignore the presence of objects */
X	if(!room->seen) tmp = STONE_SYM;
X	else if(room->typ == POOL || room->typ == MOAT) tmp = POOL_SYM;
X	else if(room->omask && !Blind && room->scrsym) {
X		otmp = o_at(x,y);
X		tmp = Hallucination ? rndobjsym() : otmp->olet;
X	}
X	else if(room->gmask && !Blind && room->scrsym) 
X		tmp = Hallucination ? rndobjsym() : GOLD_SYM;
X	else if(x == xupstair && y == yupstair) tmp = UP_SYM;
X	else if(x == xdnstair && y == ydnstair) tmp = DN_SYM;
X#ifdef STRONGHOLD
X	else if(x == xupladder && y == yupladder) tmp = UPLADDER_SYM;
X	else if(x == xdnladder && y == ydnladder) tmp = DNLADDER_SYM;
X#endif
X	else if((ttmp = t_at(x,y)) && ttmp->ttyp == WEB) tmp = WEB_SYM;
X	else if(ttmp && ttmp->tseen) tmp = TRAP_SYM;
X	else switch(room->typ) {
X	case SCORR:
X		tmp = STONE_SYM;
X		break;
X	case SDOOR:
X		croom = inroom(x,y);
X		if(croom == -1) {
X#ifdef STRONGHOLD
X			if(IS_WALL(levl[x-1][y].typ)) tmp = HWALL_SYM;
X			else tmp = VWALL_SYM;
X			break;
X#else
X			impossible("door %d %d not in room",x,y);
X#endif
X		}
X		if(rooms[croom].lx-1 == x || rooms[croom].hx+1 == x)
X			tmp = VWALL_SYM;
X		else	/* SDOORs aren't created on corners */
X			tmp = HWALL_SYM;
X  		break;
X	case HWALL:
X#ifdef STRONGHOLD
X		if (is_maze_lev && is_drawbridge_wall(x,y) >= 0) tmp = DB_HWALL_SYM;
X		else
X#endif
X		tmp = HWALL_SYM;
X		break;
X	case VWALL:
X#ifdef STRONGHOLD
X		if (is_maze_lev && is_drawbridge_wall(x,y) >= 0) tmp = DB_VWALL_SYM;
X		else
X#endif
X		tmp = VWALL_SYM;
X		break;
X	case TLCORNER:
X		tmp = TLCORN_SYM;
X		break;
X	case TRCORNER:
X		tmp = TRCORN_SYM;
X		break;
X	case BLCORNER:
X		tmp = BLCORN_SYM;
X		break;
X	case BRCORNER:
X		tmp = BRCORN_SYM;
X		break;
X	case DOOR:
X		tmp = DOOR_SYM;
X		break;
X	case CORR:
X		tmp = CORR_SYM;
X		break;
X#ifdef STRONGHOLD
X	case DRAWBRIDGE_UP:
X		if((room->drawbridgemask & DB_UNDER) == DB_MOAT) tmp = POOL_SYM;
X		else tmp = ROOM_SYM;
X		break;
X	case DRAWBRIDGE_DOWN:
X#endif /* STRONGHOLD /**/
X	case ROOM:
X		if(room->lit || cansee(x,y) || Blind) tmp = ROOM_SYM;
X		else tmp = STONE_SYM;
X		break;
X#ifdef POLYSELF
X	case STONE:
X		tmp = STONE_SYM;
X		break;
X#endif
X#ifdef FOUNTAINS
X	case FOUNTAIN:
X		tmp = FOUNTAIN_SYM;
X		break;
X#endif
X#ifdef THRONES
X	case THRONE:
X		tmp = THRONE_SYM;
X		break;
X#endif
X#ifdef SINKS
X	case SINK:
X		tmp = SINK_SYM;
X		break;
X#endif
X#ifdef ALTARS
X	case ALTAR:
X		tmp = ALTAR_SYM;
X		break;
X#endif
X	case CROSSWALL:
X		tmp = CRWALL_SYM;
X		break;
X	case TUWALL:
X		tmp = TUWALL_SYM;
X		break;
X	case TDWALL:
X		tmp = TDWALL_SYM;
X		break;
X	case TLWALL:
X		tmp = TLWALL_SYM;
X		break;
X	case TRWALL:
X		tmp = TRWALL_SYM;
X		break;
X/*
X	case POOL:
X		tmp = POOL_SYM;
X		break;
X*/
X	default:
X		tmp = ERRCHAR;
X	}
X	return(tmp);
X}
X
Xvoid
Xnewsym(x,y)
Xregister int x, y;
X{
X	atl(x,y,(char)news0(x,y));
X}
X
X/* used with wand of digging (or pick-axe): fill scrsym and force display */
X/* also when a POOL evaporates */
Xvoid
Xmnewsym(x, y)
Xregister int x, y;
X{
X	register struct rm *room;
X	uchar newscrsym;	/* OIS */
X
X	if(!vism_at(x,y)) {
X		room = &levl[x][y];
X		newscrsym = news0(x,y);
X		if(room->scrsym != newscrsym) {
X			room->scrsym = newscrsym;
X			room->seen = 0;
X		}
X	}
X}
X
Xvoid
Xnosee(x,y)
Xregister int x, y;
X{
X	register struct rm *room;
X
X	if(!isok(x,y)) return;
X	room = &levl[x][y];
X	if(room->scrsym == ROOM_SYM && !room->lit && !Blind) {
X		room->scrsym = STONE_SYM;	/* was ' ' -- OIS */
X		room->new = 1;
X		on_scr(x,y);
X	}
X}
X
Xvoid
Xprl1(x,y)
Xregister int x, y;
X{
X	if(u.dx) {
X		if(u.dy) {
X			prl(x-(2*u.dx),y);
X			prl(x-u.dx,y);
X			prl(x,y);
X			prl(x,y-u.dy);
X			prl(x,y-(2*u.dy));
X		} else {
X			prl(x,y-1);
X			prl(x,y);
X			prl(x,y+1);
X		}
X	} else {
X		prl(x-1,y);
X		prl(x,y);
X		prl(x+1,y);
X	}
X}
X
Xvoid
Xnose1(x,y)
Xregister int x, y;
X{
X	if(u.dx) {
X		if(u.dy) {
X			nosee(x,u.uy);
X			nosee(x,u.uy-u.dy);
X			nosee(x,y);
X			nosee(u.ux-u.dx,y);
X			nosee(u.ux,y);
X		} else {
X			nosee(x,y-1);
X			nosee(x,y);
X			nosee(x,y+1);
X		}
X	} else {
X		nosee(x-1,y);
X		nosee(x,y);
X		nosee(x+1,y);
X	}
X}
X
Xint
Xvism_at(x,y)
Xregister int x, y;
X{
X	if(x == u.ux && y == u.uy && !Invisible) return(1);
X
X	if(levl[x][y].mmask)
X		if (Blind && Telepat || canseemon(m_at(x,y)))
X		    return(1);
X		else return ((HTelepat & WORN_HELMET) &&
X			     (dist(x, y) <= (BOLT_LIM * BOLT_LIM)));
X	return(0);
X}
X
X#ifdef NEWSCR
Xvoid
Xpobj(obj)
Xregister struct obj *obj;
X{
X	register int show = (!obj->oinvis || See_invisible) &&
X		cansee(obj->ox,obj->oy);
X	if(obj->odispl){
X		if(obj->odx != obj->ox || obj->ody != obj->oy || !show)
X		if(!vism_at(obj->odx,obj->ody)){
X			newsym(obj->odx, obj->ody);
X			obj->odispl = 0;
X		}
X	}
X	if(show && !vism_at(obj->ox,obj->oy)){
X		atl(obj->ox,obj->oy,obj->olet);
X		obj->odispl = 1;
X		obj->odx = obj->ox;
X		obj->ody = obj->oy;
X	}
X}
X#endif /* NEWSCR /**/
X
Xvoid
Xunpobj(obj)
Xregister struct obj *obj;
X{
X/* 	if(obj->odispl){
X		if(!vism_at(obj->odx, obj->ody))
X			newsym(obj->odx, obj->ody);
X		obj->odispl = 0;
X	}
X*/
X	if(!vism_at(obj->ox,obj->oy))
X		newsym(obj->ox,obj->oy);
X}
X
X#ifdef WORM
Xstatic void
Xpwseg(wtmp)
Xregister struct wseg *wtmp;
X{
X	if(!wtmp->wdispl){
X		atl(wtmp->wx, wtmp->wy, S_WORM_TAIL);
X		wtmp->wdispl = 1;
X	}
X}
X#endif
END_OF_FILE
if test 10421 -ne `wc -c <'src/prisym.c'`; then
    echo shar: \"'src/prisym.c'\" unpacked with wrong size!
fi
# end of 'src/prisym.c'
fi
echo shar: End of archive 30 \(of 38\).
cp /dev/null ark30isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 38 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
