Path: utzoo!attcan!utgpu!jarvis.csri.toronto.edu!mailrus!csd4.milw.wisc.edu!cs.utexas.edu!uunet!zephyr.ens.tek.com!tektronix!tekgen!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v07i078:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Part23/38
Message-ID: <4335@tekred.CNA.TEK.COM>
Date: 24 Jul 89 19:03:58 GMT
Sender: nobody@tekred.CNA.TEK.COM
Lines: 2007
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 7, Issue 78
Archive-name: NetHack3/Part23



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 23 (of 38)."
# Contents:  src/Makefile.src src/lock.c src/topten.c src/unixtty.c
# Wrapped by billr@saab on Sun Jul 23 21:33:06 1989
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'src/Makefile.src' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/Makefile.src'\"
else
echo shar: Extracting \"'src/Makefile.src'\" \(15831 characters\)
sed "s/^X//" >'src/Makefile.src' <<'END_OF_FILE'
X#	Hack Makefile.
X#	SCCS Id: @(#)Makefile.unix	3.0	88/10/17
X
X# This makefile replaces the previous Makefile.unix, Makefile.xenix,
X# Makefile.3B2, Makefile.att, and Makefile.tos.
X# Set SYSTEM to one of:
X#	'Sysunix'	-- generic UNIX
X#	'Sysxenix'	-- 286 Xenix (386 Xenix can use Sysunix)
X#	'Sys3B2'	-- AT&T 3B2, 3B5, etc.
X#	'Sysatt'	-- AT&T UNIXPC, 7300, 3B1
X#	'Systos'	-- Atari
X#	'SysV-AT'	-- Microport 286 UNIX (put -DDUMB in CFLAGS)
XSYSTEM = Sysunix
X
X#
X# Make sure that your bourne shell is specified here, as you have to spawn
X# some of the commands (eg. depend) in bourne shell for them to work.
X#
XSHELL=/bin/sh
X
X# if you are cross-compiling (eg. from Xenix into a Dos enviornment) you will
X# have to redefine this filename prefix (which is used to select the filenames
X# *main.c, *tty.c, and *unix.c for the target environment)
X#
X# possible values are 'unix' and 'pc'
X# Systos wants 'pc'; everything else normally wants 'unix'
XTARG = unix
X
X# flags may have to be changed as required
X# flags for 286 Xenix:
X# CFLAGS = -O -Gt24 -LARGE -Ml -I../include
X# LFLAGS = -Ml
X# flags for 286 Microport SysV-AT
X# CFLAGS = -DDUMB -Ml -I../include
X# LFLAGS = -Ml
X# flags for debugging:
X# CFLAGS = -g -I../include
X
XCFLAGS = -O -I../include
XLFLAGS =
X
X# object files for makedefs
XMAKEOBJS = makedefs.o monst.o objects.o panic.o
X# objects files for makedefs for 286 Xenix
X# MAKEOBJS = Smakedefs.o Smonst.o Sobjects.o Spanic.o
X
X# object files for special levels compiler
XSPLEVOBJS = lev_comp.o lev_lex.o lev_main.o alloc.o monst.o objects.o panic.o
X# object files for special levels compiler for 286 Xenix
X# SPLEVOBJS = Slev_comp.o Slev_lex.o Slev_main.o Salloc.o Smonst.o Sobjects.o \
X#	      Spanic.o
X
X# on some systems the termcap library is in -ltermcap or -lcurses
X# Sysatt uses shared library in lieu of this option
X# TERMLIB = -ltermcap
X# TERMLIB = -lcurses
XTERMLIB = -ltermlib
X
X# yacc/lex programs to use to generate lev_comp.c, lev_comp.h, and lev_lex.c.
X# if, instead of yacc/lex you have bison/flex, comment/uncomment the following.
XYACC     = yacc
XLEX      = lex
X#YACC     = bison
X#LEX      = flex
X
X# make NetHack
XGAME     = nethack
X
X# if you defined RANDOM in unixconf.h/pcconf.h since your system did not come
X# with a reasonable random number generator -- also remember to get random.c
X# into the src directory
X# RANDOBJ = random.o
XRANDOBJ =
X
X# nothing below this line should have to be changed
X#
X# other things that have to be reconfigured are in config.h,
X# {unixconf.h, pcconf.h, tosconf.h}, and possibly system.h
X
XHACKCSRC = alloc.c apply.c artifact.c attrib.c bones.c cmd.c dbridge.c decl.c\
X	   demon.c do.c do_name.c do_wear.c dog.c dogmove.c dokick.c dothrow.c\
X 	   eat.c end.c engrave.c exper.c extralev.c fountain.c getline.c hack.c\
X	   invent.c ioctl.c lock.c mail.c makemon.c mcastu.c mhitm.c mhitu.c\
X	   mklev.c mkmaze.c mkobj.c mkroom.c mon.c mondata.c monmove.c monst.c\
X	   mthrowu.c music.c o_init.c objects.c objnam.c options.c pager.c\
X	   pickup.c polyself.c potion.c pray.c pri.c priest.c prisym.c read.c\
X 	   restore.c rip.c rnd.c rumors.c save.c search.c shk.c shknam.c sit.c\
X	   sounds.c sp_lev.c spell.c steal.c termcap.c timeout.c topl.c topten.c\
X	   track.c trap.c u_init.c uhitm.c vault.c version.c weapon.c were.c\
X	   wield.c wizard.c worm.c worn.c write.c zap.c
X
X# all .c files but msdos.c, tos.c, *main.c, *tty.c, *unix.c, (system specific)
X# and makedefs.c, lev_comp.c, panic.c (not part of any nethack)
X
XCSOURCES = $(HACKCSRC) $(TARG)main.c $(TARG)main.c $(TARG)main.c makedefs.c panic.c
X
XHACKINCL = artifact.h attrib.h config.h coord.h decl.h edog.h epri.h eshk.h\
X	   extern.h flag.h func_tab.h global.h gold.h hack.h lev.h mfndpos.h\
X	   mkroom.h monattk.h mondata.h monflag.h monst.h monsym.h msdos.h\
X	   obj.h objclass.h permonst.h prop.h rm.h sp_lev.h spell.h tradstdc.h\
X	   trapname.h vault.h wseg.h you.h youprop.h
X
X# all .h files except date.h, onames.h, pm.h & trap.h which would cause
X# dependency loops if run through "make depend".
X
XHSOURCES = $(HACKINCL) date.h onames.h pm.h trap.h
X
XSOURCES = $(CSOURCES) $(HSOURCES)
X
XHOBJ = alloc.o apply.o artifact.o attrib.o bones.o cmd.o dbridge.o decl.o\
X	demon.o do.o do_name.o do_wear.o dog.o dogmove.o dokick.o dothrow.o\
X 	eat.o end.o engrave.o exper.o extralev.o fountain.o getline.o hack.o\
X	invent.o ioctl.o lock.o mail.o main.o makemon.o mcastu.o mhitm.o\
X	mhitu.o mklev.o mkmaze.o mkobj.o mkroom.o mon.o mondata.o monmove.o\
X	monst.o mthrowu.o music.o o_init.o objects.o objnam.o options.o pager.o\
X	pickup.o polyself.o potion.o pray.o pri.o priest.o prisym.o read.o\
X	restore.o rip.o rnd.o rumors.o save.o search.o shk.o shknam.o sit.o\
X	sounds.o sp_lev.o spell.o steal.o termcap.o timeout.o topl.o topten.o\
X	track.o trap.o tty.o u_init.o uhitm.o unix.o vault.o version.o\
X	weapon.o were.o wield.o wizard.o worm.o worn.o write.o zap.o $(RANDOBJ)
X
X# the .o files from the HACKCSRC list, plus main.o tty.o unix.o
X
X$(GAME):	$(SYSTEM)
X	@echo "$(GAME) is up to date."
X
XSysunix:	$(HOBJ) Makefile
X	@echo "Loading ..."
X	@$(CC) $(LFLAGS) -o $(GAME) $(HOBJ) $(TERMLIB)
X	@touch Sysunix
X
XSysxenix:	$(HOBJ) Makefile
X	@echo "Loading ..."
X	@$(CC) $(LFLAGS) -m hack.map -o $(GAME) /lib/Lsignal.o $(HOBJ) $(TERMLIB) -SEG#256
X	@touch Sysxenix
X
XSys3B2:	$(HOBJ) Makefile
X	@echo "Loading ..."
X	@$(CC) $(LFLAGS) -o $(GAME) $(HOBJ) $(TERMLIB) -lmalloc
X	@touch Sys3B2
X
XSysatt:	$(HOBJ) Makefile
X	@echo "Loading ..."
X	@$(LD) $(LFLAGS) /lib/crt0s.o /lib/shlib.ifile -o $(GAME) $(HOBJ)
X	@touch Sysatt
X
XSystos:	$(HOBJ) tos.o Makefile
X	@echo "Loading ..."
X	@$(CC) $(LFLAGS) -o $(GAME) $(HOBJ) tos.o $(TERMLIB)
X	@touch Systos
X
XSysV-AT:	DUMB.Setup $(HOBJ) Makefile
X	@echo "Loading ..."
X	@$(CC) $(LFLAGS) -o $(GAME) $(HOBJ) $(TERMLIB)
X	@touch SysV-AT
X
XDUMB.Setup:	../include/extern.h
X	cp ../include/extern.h ../include/extern.h.BAK 
X	cat ../include/extern.h | \
X		sed -e '/^E\ int\ /!b' \
X			-e '/[^;/ 	]$$/N' \
X			-e '/[(][*]occupation[)]/b' \
X			-e '/[(][*]afternmv[)]/b' \
X			-e '/float_down/b' \
X			-e '/done1/b' \
X			-e '/identify/b' \
X			-e '/Hear_again/b' \
X			-e '/hangup/b' \
X			-e 's/^\(.*\)$$/\/\* \1 \/\*\*\//' | \
X		sed -e '/^E\ void\ /!b' \
X			-e '/[^;/ 	]$$/N' \
X			-e 's/^\(.*\)$$/\/\* \1 \/\*\*\//' \
X				>../include/extern.DUMB 
X	cp ../include/extern.DUMB ../include/extern.h 
X	@touch DUMB.Setup
X
Xall:	$(GAME)
X
X#
X#	Please note:	The dependency lines for the modules here are
X#			deliberately incorrect.  Including "hack.h" in
X#			the dependency list would cause a dependency
X#			loop.
X#
Xmakedefs:	$(MAKEOBJS)
X	$(CC) $(LFLAGS) -o makedefs $(MAKEOBJS)
X
Xmakedefs.o:  ../include/config.h ../include/permonst.h
X
Xlev_comp:  $(SPLEVOBJS)
X	$(CC) $(LFLAGS) -o lev_comp $(SPLEVOBJS)
X
Xlev_comp.o:  ../include/hack.h ../include/sp_lev.h
X
Xlev_lex.o:   ../include/lev_comp.h ../include/hack.h ../include/sp_lev.h
X
Xlev_main.o:  ../include/hack.h ../include/sp_lev.h
X
X../include/lev_comp.h: lev_comp.c
X
Xlev_comp.c: lev_comp.y
X	$(YACC) -d lev_comp.y
X	mv y.tab.c lev_comp.c
X	mv y.tab.h ../include/lev_comp.h
X
Xlev_lex.c: lev_comp.l
X	$(LEX) lev_comp.l
X	mv lex.yy.c lev_lex.c
X
X# special stuff for 286 Xenix makedefs & lev_comp
X
XSmakedefs.o:	makedefs.c ../include/config.h ../include/permonst.h
X	cp makedefs.c Smakedefs.c
X	$(CC) -O -c Smakedefs.c
X
XSlev_comp.o:  lev_comp.c ../include/hack.h ../include/sp_lev.h
X	cp lev_comp.c Slev_comp.c
X	$(CC) -O -c Slev_comp.c
X
XSlev_lex.o: lev_lex.c ../include/hack.h ../include/sp_lev.h ../include/lev_comp.h
X	cp lev_lex.c Slev_lex.c
X	$(CC) -O -c Slev_lex.c
X
XSlev_main.o: lev_main.c ../include/hack.h ../include/sp_lev.h
X	cp lev_main.c Slev_main.c
X	$(CC) -O -c Slev_main.c
X
XSalloc.o:	alloc.c
X	cp alloc.c Salloc.c
X	$(CC) -O -c Salloc.c
X
XSmonst.o:	monst.c ../include/config.h ../include/permonst.h \
X		../include/monsym.h ../include/epri.h ../include/eshk.h \
X		../include/vault.h
X	cp monst.c Smonst.c
X	$(CC) -O -c Smonst.c
X
XSobjects.o:	objects.c ../include/config.h ../include/obj.h \
X		../include/objclass.h ../include/prop.h
X	cp objects.c Sobjects.c
X	$(CC) -O -c Sobjects.c
X
XSpanic.o:	panic.c
X	cp panic.c Spanic.c
X	$(CC) -O -c Spanic.c
X
X#
X#	The following include files depend on makedefs to be created.
X#	As a result, they are not defined in HACKINCL, instead, their
X#	dependencies are explicitly outlined here.
X#
X
X#
X#	date.h should be remade any time any of the source or include code
X#	is modified.  Unfortunately, this would make the contents of this
X#	file far more complex.  Since "hack.h" depends on most of the include
X#	files, we kludge around this by making date.h dependent on hack.h,
X#	even though it doesn't include this file.
X#
X../include/date.h:	$(CSOURCES) ../include/hack.h makedefs
X	./makedefs -v
X
X../include/trap.h:	../include/config.h makedefs
X	./makedefs -t
X
X../include/onames.h:	makedefs
X	./makedefs -o
X
X../include/pm.h:	makedefs
X	./makedefs -p
X
X#
X#	The following programs vary depending on what OS you are using.
X#	As a result, they are not defined in HACKSRC, and their dependancies
X#	are explicitly outlined here.
X#
Xmain.o:	../include/hack.h $(TARG)main.c
X	$(CC) $(CFLAGS) -c $(TARG)main.c
X	mv $(TARG)main.o main.o
X
Xtty.o:	../include/hack.h $(TARG)tty.c
X	$(CC) $(CFLAGS) -c $(TARG)tty.c
X	mv $(TARG)tty.o tty.o
X
Xunix.o:	../include/hack.h $(TARG)unix.c
X	$(CC) $(CFLAGS) -c $(TARG)unix.c
X	mv $(TARG)unix.o unix.o
X
Xlint:
X# lint cannot have -p here because (i) capitals are meaningful:
X# [Ww]izard, (ii) identifiers may coincide in the first six places:
X# doweararm() versus dowearring().
X# _flsbuf comes from <stdio.h>, a bug in the system libraries.
X	@echo lint -axbh -DLINT ...
X	@lint -axbh -I../include -DLINT $(HACKCSRC) $(TARG)main.c $(TARG)tty.c $(TARG)unix.c | sed '/_flsbuf/d'
X
X
Xdiff:
X	@- for i in $(SOURCES) ; do \
X		cmp -s $$i $D/$$i || \
X		( echo diff $D/$$i $$i ; diff $D/$$i $$i ; echo ) ; done
X
Xtags: $(CSOURCES)
X	@echo ctags -tw ...
X	@ctags -tw $(CSOURCES)
X	@( cd ../include ; ctags -tw $(HSOURCES) )
X  
Xclean:
X	rm -f *.o
X
Xspotless: clean
X	rm -f a.out core $(GAME) lev_comp makedefs
X	rm -f ../include/onames.h ../include/pm.h
X	touch ../include/onames.h ../include/pm.h
X	touch makedefs.c
X#(make sure files exist and have timestamps in the right order for next compile)
X
X
Xdepend:
X# For the moment we are lazy and disregard /usr/include files because
X# the sources contain them conditionally. Perhaps we should use cpp.
X#		( /bin/grep '^#[ 	]*include' $$i | sed -n \
X#			-e 's,<\(.*\)>,"/usr/include/\1",' \
X#
X#
X	for i in ${HACKCSRC}; do \
X		( /bin/grep '^#[ 	]*include[ 	]*"' $$i | sed -n \
X			-e 's/[^"]*"\([^"]*\)".*/\1/' \
X			-e 's/.*\.h/..\/include\/&/' \
X			-e H -e '$$g' -e '$$s/\n/ /g' \
X			-e '$$s/.*/'$$i': &/' -e '$$s/\.c:/.o:/p' \
X			>> makedep); done
X	for i in ${HACKINCL}; do \
X		( /bin/grep '^#[ 	]*include[ 	]*"' ../include/$$i | sed -n \
X			-e 's/[^"]*"\([^"]*\)".*/\1/' \
X			-e 's/.*\.h/..\/include\/&/' \
X			-e H -e '$$g' -e '$$s/\n/ /g' \
X			-e '$$s/.*/..\/include\/'$$i': &\
X				touch ..\/include\/'$$i/p \
X			>> makedep); done
X	@echo '/^# DO NOT DELETE THIS LINE/+2,$$d' >eddep
X	@echo '$$r makedep' >>eddep
X	@echo 'w' >>eddep
X	@cp Makefile Makefile.bak
X	ed - Makefile < eddep
X	@rm -f eddep makedep
X	@echo '# DEPENDENCIES MUST END AT END OF FILE' >> Makefile
X	@echo '# IF YOU PUT STUFF HERE IT WILL GO AWAY' >> Makefile
X	@echo '# see make depend above' >> Makefile
X	- diff Makefile Makefile.bak
X	@rm -f Makefile.bak
X
X# PC dependency for Systos that won't be made on a UNIX system
Xtos.o:	../include/hack.h ../include/osbind.h
X
X# DO NOT DELETE THIS LINE
X
Xalloc.o:  ../include/config.h
Xapply.o:  ../include/hack.h ../include/edog.h
Xartifact.o:  ../include/hack.h ../include/artifact.h
Xattrib.o:  ../include/hack.h
Xbones.o:  ../include/hack.h
Xcmd.o:  ../include/hack.h ../include/func_tab.h
Xdbridge.o:  ../include/hack.h
Xdecl.o:  ../include/hack.h
Xdemon.o:  ../include/hack.h
Xdo.o:  ../include/hack.h
Xdo_name.o:  ../include/hack.h
Xdo_wear.o:  ../include/hack.h
Xdog.o:  ../include/hack.h ../include/edog.h
Xdogmove.o:  ../include/hack.h ../include/mfndpos.h ../include/edog.h
Xdokick.o:  ../include/hack.h ../include/eshk.h
Xdothrow.o:  ../include/hack.h
Xeat.o:  ../include/hack.h
Xend.o:  ../include/hack.h ../include/eshk.h
Xengrave.o:  ../include/hack.h
Xexper.o:  ../include/hack.h
Xextralev.o:  ../include/hack.h
Xfountain.o:  ../include/hack.h
Xgetline.o:  ../include/hack.h ../include/func_tab.h
Xhack.o:  ../include/hack.h
Xinvent.o:  ../include/hack.h ../include/lev.h ../include/wseg.h
Xioctl.o:  ../include/hack.h
Xlock.o:  ../include/hack.h
Xmail.o:  ../include/hack.h
Xmakemon.o:  ../include/hack.h
Xmcastu.o:  ../include/hack.h
Xmhitm.o:  ../include/hack.h ../include/artifact.h
Xmhitu.o:  ../include/hack.h ../include/artifact.h ../include/edog.h
Xmklev.o:  ../include/hack.h
Xmkmaze.o:  ../include/hack.h
Xmkobj.o:  ../include/hack.h
Xmkroom.o:  ../include/hack.h
Xmon.o:  ../include/hack.h ../include/mfndpos.h ../include/artifact.h
Xmondata.o:  ../include/hack.h ../include/eshk.h ../include/epri.h
Xmonmove.o:  ../include/hack.h ../include/mfndpos.h ../include/artifact.h
Xmonst.o:  ../include/config.h ../include/permonst.h ../include/monsym.h ../include/eshk.h ../include/vault.h ../include/epri.h
Xmthrowu.o:  ../include/hack.h
Xmusic.o:  ../include/hack.h
Xo_init.o:  ../include/hack.h
Xobjects.o:  ../include/config.h ../include/obj.h ../include/objclass.h ../include/prop.h
Xobjnam.o:  ../include/hack.h
Xoptions.o:  ../include/hack.h
Xpager.o:  ../include/hack.h
Xpickup.o:  ../include/hack.h
Xpolyself.o:  ../include/hack.h
Xpotion.o:  ../include/hack.h
Xpray.o:  ../include/hack.h
Xpri.o:  ../include/hack.h
Xpriest.o:  ../include/hack.h ../include/mfndpos.h ../include/eshk.h ../include/epri.h
Xprisym.o:  ../include/hack.h ../include/wseg.h ../include/lev.h
Xread.o:  ../include/hack.h
Xrestore.o:  ../include/hack.h ../include/lev.h ../include/wseg.h
Xrip.o:  ../include/hack.h
Xrnd.o:  ../include/hack.h
Xrumors.o:  ../include/hack.h
Xsave.o:  ../include/hack.h ../include/lev.h ../include/wseg.h
Xsearch.o:  ../include/hack.h ../include/artifact.h
Xshk.o:  ../include/hack.h ../include/eshk.h
Xshknam.o:  ../include/hack.h ../include/eshk.h
Xsit.o:  ../include/hack.h
Xsounds.o:  ../include/hack.h ../include/edog.h ../include/eshk.h
Xsp_lev.o:  ../include/hack.h ../include/sp_lev.h
Xspell.o:  ../include/hack.h
Xsteal.o:  ../include/hack.h
Xtermcap.o:  ../include/hack.h
Xtimeout.o:  ../include/hack.h
Xtopl.o:  ../include/hack.h
Xtopten.o:  ../include/hack.h
Xtrack.o:  ../include/hack.h
Xtrap.o:  ../include/hack.h ../include/edog.h ../include/trapname.h
Xu_init.o:  ../include/hack.h
Xuhitm.o:  ../include/hack.h ../include/artifact.h
Xvault.o:  ../include/hack.h ../include/vault.h
Xversion.o:  ../include/hack.h ../include/date.h
Xweapon.o:  ../include/hack.h
Xwere.o:  ../include/hack.h
Xwield.o:  ../include/hack.h
Xwizard.o:  ../include/hack.h
Xworm.o:  ../include/hack.h ../include/wseg.h
Xworn.o:  ../include/hack.h
Xwrite.o:  ../include/hack.h
Xzap.o:  ../include/hack.h
X../include/config.h:  ../include/tradstdc.h ../include/global.h
X			touch ../include/config.h
X../include/decl.h:  ../include/spell.h ../include/obj.h ../include/you.h ../include/onames.h ../include/pm.h
X			touch ../include/decl.h
X../include/global.h:  ../include/coord.h ../include/unixconf.h ../include/pcconf.h ../include/tosconf.h ../include/amiconf.h
X			touch ../include/global.h
X../include/hack.h:  ../include/config.h ../include/decl.h ../include/monsym.h ../include/mkroom.h ../include/objclass.h ../include/gold.h ../include/trap.h ../include/flag.h ../include/rm.h
X			touch ../include/hack.h
X../include/permonst.h:  ../include/monattk.h ../include/monflag.h
X			touch ../include/permonst.h
X../include/you.h:  ../include/attrib.h ../include/monst.h ../include/youprop.h
X			touch ../include/you.h
X../include/youprop.h:  ../include/prop.h ../include/permonst.h ../include/mondata.h ../include/pm.h
X			touch ../include/youprop.h
X# DEPENDENCIES MUST END AT END OF FILE
X# IF YOU PUT STUFF HERE IT WILL GO AWAY
X# see make depend above
END_OF_FILE
if test 15831 -ne `wc -c <'src/Makefile.src'`; then
    echo shar: \"'src/Makefile.src'\" unpacked with wrong size!
fi
# end of 'src/Makefile.src'
fi
if test -f 'src/lock.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/lock.c'\"
else
echo shar: Extracting \"'src/lock.c'\" \(15150 characters\)
sed "s/^X//" >'src/lock.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)lock.c	3.0	88/10/22
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include	"hack.h"
X
Xstatic struct {
X	int	door_or_box, picktyp;
X	struct rm  *door;
X	struct obj *box;
X	int chance, usedtime;
X} xlock;
X
Xstatic
Xint
Xpicklock() {	/* try to open/close a lock */
X
X	if(!xlock.door_or_box) {	/* box */
X
X	    if((xlock.box->ox != u.ux) || (xlock.box->oy != u.uy)) {
X		return((xlock.usedtime = 0));		/* you or it moved */
X	    }
X	} else {		/* door */
X	    if(xlock.door != &(levl[u.ux+u.dx][u.uy+u.dy])) {
X		return((xlock.usedtime = 0));		/* you moved */
X	    }
X	    switch (xlock.door->doormask) {
X		case D_NODOOR:
X		    pline("This doorway has no door.");
X		    return((xlock.usedtime = 0));
X		case D_ISOPEN:
X		    pline("Picking the lock of an open door is pointless.");
X		    return((xlock.usedtime = 0));
X		case D_BROKEN:
X		    pline("This door is broken.");
X		    return((xlock.usedtime = 0));
X	    }
X	}
X
X	if(xlock.usedtime++ >= 50
X#ifdef POLYSELF
X	   || nohands(uasmon)
X#endif
X	   ) {
X	    You("give up your attempt to %s the lock.",
X		  (xlock.door_or_box ? !(xlock.door->doormask & D_LOCKED) :
X		   !xlock.box->olocked) ? "lock" :
X		  ((xlock.picktyp == LOCK_PICK) ? "pick" : "open" ));
X
X	    return((xlock.usedtime = 0));
X	}
X
X	if(rn2(100) > xlock.chance) return(1);		/* still busy */
X
X	if(xlock.door_or_box) {
X	    You("succeed in %sing the lock.",
X		  !(xlock.door->doormask & D_LOCKED) ? "lock" :
X		  ((xlock.picktyp == LOCK_PICK) ? "pick" : "open" ));
X	    if(xlock.door->doormask & D_TRAPPED) {
X		    b_trapped("door");
X		    xlock.door->doormask = D_NODOOR;
X	    } else if(xlock.door->doormask == D_LOCKED)
X		xlock.door->doormask = D_CLOSED;
X	    else xlock.door->doormask = D_LOCKED;
X	} else {
X	    You("succeed in %sing the lock.",
X		  (!xlock.box->olocked) ? "lock" :
X		  (xlock.picktyp == LOCK_PICK) ? "pick" : "open" );
X	    xlock.box->olocked = !xlock.box->olocked;
X	    if(xlock.box->otrapped)	chest_trap(xlock.box, FINGER);
X	}
X	return((xlock.usedtime = 0));
X}
X
Xstatic
Xint
Xforcelock() {	/* try to force a locked chest */
X
X	register struct obj *otmp, *otmp2;
X	register struct obj *probj = fcobj;  /* initialize to make lint happy */
X
X	if((xlock.box->ox != u.ux) || (xlock.box->oy != u.uy))
X		return((xlock.usedtime = 0));		/* you or it moved */
X
X	if(xlock.usedtime++ >= 50 || !uwep
X#ifdef POLYSELF
X	   || nohands(uasmon)
X#endif
X	   ) {
X	    You("give up your attempt to force the lock.");
X
X	    return((xlock.usedtime = 0));
X	}
X
X	if(xlock.picktyp) {	/* blade */
X
X	    if(rn2(1000-uwep->spe) > 992 && !uwep->cursed) {
X		/* for a +0 weapon, probability that it survives an unsuccessful
X		 * attempt to force the lock is (.992)^50 = .67
X		 */
X		pline("%sour %s broke!",
X		      (uwep->quan > 1) ? "One of y" : "Y", xname(uwep));
X		useup(uwep);
X		You("give up your attempt to force the lock.");
X		return((xlock.usedtime = 0));
X	    }
X	} else			/* blunt */
X	    wake_nearby();	/* due to hammering on the container */
X
X	if(rn2(100) > xlock.chance) return(1);		/* still busy */
X
X	You("succeed in forcing the lock.");
X	xlock.box->olocked = !xlock.box->olocked;
X	if(!xlock.picktyp && !rn2(3)) {
X
X	    pline("In fact, you've totally destroyed the %s.",
X		  xname(xlock.box));
X	    for(otmp = fcobj; otmp; otmp = otmp2) {
X
X		otmp2 = otmp->nobj;
X		if(otmp->cobj == xlock.box) {
X
X		    /* unlink it from the "contained" list */
X		    if(otmp == fcobj) fcobj = otmp2;
X		    else	      probj->nobj = otmp2;
X
X		    if(!rn2(3) || otmp->olet == POTION_SYM)
X			free((genericptr_t) otmp);
X		    else { /* spill it onto the floor */
X			otmp->nobj = xlock.box->nobj;
X			xlock.box->nobj = otmp;
X			otmp->cobj = (struct obj *)0;
X			otmp->ox = u.ux;
X			otmp->oy = u.uy;
X			levl[u.ux][u.uy].omask = 1;
X			stackobj(otmp);
X		    }
X		} else probj = otmp;
X	    }
X	    delobj(xlock.box);
X	}
X	return((xlock.usedtime = 0));
X}
X
Xint
Xpick_lock(pick) /* pick a lock with a given object */
X	register struct	obj	*pick;
X{
X	register int x, y, picktyp, c, ch;
X	register struct rm	*door;
X	register struct obj	*otmp;
X
X	picktyp = pick->otyp;
X	if(xlock.usedtime && picktyp == xlock.picktyp) {
X
X	    You("resume your attempt to %s the lock.",
X		  (xlock.door_or_box ? !(xlock.door->doormask & D_LOCKED) :
X		   !xlock.box->olocked) ? "lock" :
X		  ((xlock.picktyp == LOCK_PICK) ? "pick" : "open" ));
X
X	    set_occupation(picklock,
X			   (picktyp == LOCK_PICK) ? "picking the lock" :
X						    "opening the lock",  0);
X	    return(1);
X	}
X
X#ifdef POLYSELF
X	if(nohands(uasmon)) {
X		You("can't hold a %s - you have no hands!");
X		return(0);
X	}
X#endif
X	if((picktyp != LOCK_PICK && picktyp != CREDIT_CARD &&
X	    picktyp != SKELETON_KEY && picktyp != KEY)) {
X		impossible("picking lock with object %d?", picktyp);
X		return(0);
X	}
X	if(!getdir(1)) return(0);
X
X	x = u.ux + u.dx;
X	y = u.uy + u.dy;
X	if((x == u.ux) && (y == u.uy)) { /* pick the lock on a container */
X	    c = 'n';			/* in case there are no boxes here */
X	    if(levl[x][y].omask)
X	    for(otmp = fobj; otmp; otmp = otmp->nobj)
X		if((otmp->ox == x) && (otmp->oy == y))
X		    if(Is_box(otmp)) {
X			pline("There is %s here, %s the lock? ",
X			doname(otmp), (!otmp->olocked) ? "close" :
X			((picktyp == LOCK_PICK) ? "pick" : "open" ));
X
X			c = ynq();
X			if(c == 'q') return(0);
X			if(c == 'n') continue;
X
X			if(picktyp == KEY && otmp->spe != pick->spe) {
X				pline("The %s won't fit the lock.",xname(pick));
X				return(1);
X			}
X			switch(picktyp) {
X			    case CREDIT_CARD:
X				ch = ACURR(A_DEX)+(20*(pl_character[0] == 'R'));
X				break;
X			    case LOCK_PICK:
X				ch = 4*ACURR(A_DEX)+(25*(pl_character[0] == 'R'));
X				break;
X			    case SKELETON_KEY:
X				ch = 75 + ACURR(A_DEX);
X				break;
X			    case KEY:
X				ch = 1000;
X				break;
X			    default:	ch = 0;
X			}
X			if(otmp->cursed) ch /= 2;
X
X			xlock.door_or_box = 0;
X			xlock.picktyp = picktyp;
X			xlock.box = otmp;
X			break;
X		    }
X	    if(c != 'y')
X		return(0);		/* decided against all boxes */
X	} else {			/* pick the lock in a door */
X	    struct monst *mtmp;
X
X	    door = &levl[x][y];
X	    if (door->mmask && canseemon(mtmp = m_at(x,y)) && !mtmp->mimic) {
X		if (picktyp == CREDIT_CARD &&
X#ifdef ORACLE
X		    (mtmp->isshk || mtmp->data == &mons[PM_ORACLE]))
X#else
X		    mtmp->isshk)
X#endif
X		    pline("\"No checks, no credit, no problem.\"");
X		else
X		    kludge("I don't think %s would appreciate that.", mon_nam(mtmp));
X		return(0);
X	    }
X	    if(!IS_DOOR(door->typ)) {
X#ifdef STRONGHOLD
X		if (is_drawbridge_wall(x,y) >= 0)
X		    You("%s no lock on the drawbridge.",
X				Blind ? "feel" : "see");
X		else
X#endif
X		You("%s no door there.",
X				Blind ? "feel" : "see");
X		return(0);
X	    }
X	    switch (door->doormask) {
X		case D_NODOOR:
X		    pline("This doorway has no door.");
X		    return(0);
X		case D_ISOPEN:
X		    pline("Picking the lock of an open door is pointless.");
X		    return(0);
X		case D_BROKEN:
X		    pline("This door is broken.");
X		    return(0);
X		default:
X		    pline("%sock it? ", (door->doormask & D_LOCKED) ? "Unl" : "L" );
X
X		    c = yn();
X		    if(c == 'n') return(0);
X
X		    switch(picktyp) {
X			case CREDIT_CARD:
X			    ch = 2*ACURR(A_DEX)+(20*(pl_character[0] == 'R'));
X			    break;
X			case LOCK_PICK:
X			    ch = 3*ACURR(A_DEX)+(30*(pl_character[0] == 'R'));
X			    break;
X			case SKELETON_KEY:
X			    ch = 70 + ACURR(A_DEX);
X			    break;
X			case KEY:
X			    pline("The %s won't fit the door.", xname(pick));
X			    return(1);
X			default:    ch = 0;
X		    }
X		    xlock.door_or_box = 1;
X		    xlock.door = door;
X	    }
X	}
X	flags.move = 0;
X	xlock.chance = ch;
X	xlock.picktyp = picktyp;
X	xlock.usedtime = 0;
X	set_occupation(picklock,
X		       (picktyp == LOCK_PICK) ? "picking the lock" :
X						"opening the lock",  0);
X	return(1);
X}
X
Xint
Xdoforce() {		/* try to force a chest with your weapon */
X
X	register struct obj *otmp;
X	register int c, picktyp;
X
X	if(!uwep ||	/* proper type test */
X	   (uwep->olet != WEAPON_SYM && uwep->olet != ROCK_SYM &&
X						uwep->otyp != PICK_AXE) ||
X	   (uwep->otyp < DAGGER) ||
X	   (uwep->otyp > VOULGE && uwep->olet != ROCK_SYM &&
X						uwep->otyp != PICK_AXE)
X	  ) {
X	    You("can't force anything without a %sweapon.",
X		  (uwep) ? "proper " : "");
X	    return(0);
X	}
X
X	picktyp = (uwep->otyp >= DAGGER && uwep->otyp <= KATANA);
X	if(xlock.usedtime && xlock.box && picktyp == xlock.picktyp) {
X	    You("resume your attempt to force the lock.");
X	    set_occupation(forcelock, "forcing the lock", 0);
X	    return(1);
X	}
X
X	/* A lock is made only for the honest man, the thief will break it. */
X	xlock.box = (struct obj *)0;
X	if(levl[u.ux][u.uy].omask)
X	for(otmp = fobj; otmp; otmp = otmp->nobj)
X	    if((otmp->ox == u.ux) && (otmp->oy == u.uy))
X		if(Is_box(otmp)) {
X		  if(otmp->olocked)
X		    pline("There is %s here, force the lock? ", doname(otmp));
X		  else {
X		    pline("There is a %s here, but it's already unlocked.",
X			  xname(otmp));
X		    continue;
X		  }
X
X		  c = ynq();
X		  if(c == 'q') return(0);
X		  if(c == 'n') continue;
X
X		  if(picktyp)
X		    You("force your %s into a crack and pry.", xname(uwep));
X		  else
X		    You("start bashing it with your %s.", xname(uwep));
X		  xlock.box = otmp;
X		  xlock.chance = objects[otmp->otyp].wldam * 2;
X		  xlock.picktyp = picktyp;
X		  xlock.usedtime = 0;
X		  break;
X		}
X
X	if(xlock.box)	set_occupation(forcelock, "forcing the lock", 0);
X	else		You("decide not to force the issue.");
X	return(1);
X}
X
Xint
Xdoopen() {		/* try to open a door */
X	register int x, y;
X	register struct rm *door;
X
X	if(!getdir(1)) return(0);
X
X	x = u.ux + u.dx;
X	y = u.uy + u.dy;
X	if((x == u.ux) && (y == u.uy)) return(0);
X
X	door = &levl[x][y];
X
X	if(!IS_DOOR(door->typ)) {
X#ifdef STRONGHOLD
X		if (is_drawbridge_wall(x,y) >= 0) {
X		    pline("There is no obvious way to open the drawbridge.");
X		    return(0);
X		}
X#endif
X		You("%s no door there.",
X				Blind ? "feel" : "see");
X		return(0);
X	}
X
X	if(!(door->doormask & D_CLOSED)) {
X	  switch(door->doormask) {
X	     case D_BROKEN: pline("This door is broken."); break;
X	     case D_NODOOR: pline("This doorway has no door."); break;
X	     case D_ISOPEN: pline("This door is already open."); break;
X	     default:	    pline("This door is locked."); break;
X	  }
X	  return(0);
X	}
X
X#ifdef POLYSELF
X	if(verysmall(uasmon)) {
X	    pline("You're too small to pull the door open.");
X	    return(0);
X	}
X#endif
X	/* door is known to be CLOSED */
X	if (rnl(20) < (ACURR(A_STR)+ACURR(A_DEX)+ACURR(A_CON))/3) {
X	    pline("The door opens.");
X	    if(door->doormask & D_TRAPPED) {
X		b_trapped("door");
X		door->doormask = D_NODOOR;
X	    } else
X		door->doormask = D_ISOPEN;
X	} else {
X	    pline("The door resists!");
X	}
X
X	return(1);
X}
X
Xstatic
Xboolean
Xobstructed(x,y)
Xregister int x, y;
X{
X	if(levl[x][y].mmask) {
X		if (m_at(x,y)->mimic) goto obj;	  
X		pline("%s stands in the way!", Blind ?
X			"Some creature" : Monnam(m_at(x,y)));
X		return(TRUE);
X	}
X	if (levl[x][y].omask || levl[x][y].gmask) {
Xobj:
X		pline("Something's in the way.");
X		return(TRUE);
X	}
X	return(FALSE);
X}
X
Xint
Xdoclose() {		/* try to close a door */
X	register int x, y;
X	register struct rm *door;
X
X	if(!getdir(1)) return(0);
X
X	x = u.ux + u.dx;
X	y = u.uy + u.dy;
X	if((x == u.ux) && (y == u.uy)) {
X		You("are in the way!");
X		return(1);
X	}
X	door = &levl[x][y];
X
X	if(!IS_DOOR(door->typ)) {
X#ifdef STRONGHOLD
X		if (door->typ == DRAWBRIDGE_DOWN)
X		    pline("There is no obvious way to close the drawbridge.");
X		else
X#endif
X		You("%s no door there.",
X				Blind ? "feel" : "see");
X		return(0);
X	}
X
X	if(door->doormask == D_NODOOR) {
X	    pline("This doorway has no door.");
X	    return(0);
X	}
X
X	if(obstructed(x, y)) return(0);
X
X	if(door->doormask == D_BROKEN) {
X	    pline("This door is broken.");
X	    return(0);
X	}
X
X	if(door->doormask & (D_CLOSED | D_LOCKED)) {
X	    pline("This door is already closed.");
X	    return(0);
X	}
X
X	if(door->doormask == D_ISOPEN) {
X#ifdef POLYSELF
X	    if(verysmall(uasmon)) {
X		 pline("You're too small to push the door closed.");
X		 return(0);
X 	    }
X#endif
X	    if (rn2(25) < (ACURR(A_STR)+ACURR(A_DEX)+ACURR(A_CON))/3) {
X		pline("The door closes.");
X		door->doormask = D_CLOSED;
X	    }
X	    else pline("The door resists!");
X	}
X
X	return(1);
X}
X
Xint
Xboxlock(obj, otmp)	/* box obj was hit with spell effect otmp */
X			/* returns 1 if something happened */
X	register struct obj *obj, *otmp;	/* obj *is* a box */
X{
X	register boolean res;
X
X	switch(otmp->otyp) {
X	    case WAN_LOCKING:
X#ifdef SPELLS
X	    case SPE_WIZARD_LOCK:
X#endif
X			if(!obj->olocked) {
X				pline("Klunk!");
X				obj->olocked = !(obj->olocked);
X				res = 1;
X			} else	res = 0;
X			break;
X	    case WAN_OPENING:
X#ifdef SPELLS
X	    case SPE_KNOCK:
X#endif
X			if(obj->olocked) {
X				pline("Klick!");
X				obj->olocked = !(obj->olocked);
X				res = 1;
X			} else	res = 0;
X			break;
X	}
X	return(res);
X}
X
Xint
Xdoorlock(otmp,x,y)	/* door was hit with spell effect otmp */
X	register struct obj *otmp;
X	int x, y;
X{
X	register struct rm *door = &levl[x][y];
X	boolean res = 1;
X
X	if(obstructed(x,y))
X		return 0;
X
X	if(door->typ == SDOOR) {
X	    if(otmp->otyp == WAN_OPENING
X#ifdef SPELLS
X	       || otmp->otyp == SPE_KNOCK
X#endif /* SPELLS /**/
X	      ) {
X		door->typ = DOOR;
X		door->doormask = D_CLOSED | (door->doormask & D_TRAPPED);
X		if(cansee(x,y)) {
X		    pline("A section of the wall opens up!");
X		    newsym(x,y);
X		}
X		return(1);
X	    } else
X		return(0);
X	}
X
X#ifdef STRONGHOLD
X	/* make sure it isn't an open drawbridge */
X	if (is_maze_lev && find_drawbridge(&x,&y)) {
X	    if(otmp->otyp == WAN_OPENING
X#ifdef SPELLS
X	       || otmp->otyp == SPE_KNOCK
X#endif /* SPELLS /**/
X	      )
X		    (void) open_drawbridge(x,y);
X	    else
X		    (void) close_drawbridge(x,y);
X	    return 1;
X	}
X#endif
X
X	switch(otmp->otyp) {
X	    case WAN_LOCKING:
X#ifdef SPELLS
X	    case SPE_WIZARD_LOCK:
X#endif
X		if (cansee(x,y))
X		switch (door->doormask & ~D_TRAPPED) {
X			case D_CLOSED:
X				pline("The door locks!");
X				break;
X			case D_ISOPEN:
X				pline("The door swings shut, and locks!");
X				break;
X			case D_BROKEN:
X				pline("The broken door reassembles and locks!");
X				break;
X			case D_NODOOR:
X	pline("A cloud of dust springs up and assembles itself into a door!");
X				break;
X			default: res = 0;
X		}
X		door->doormask = D_LOCKED | (door->doormask & D_TRAPPED);
X		break;
X	    case WAN_OPENING:
X#ifdef SPELLS
X	    case SPE_KNOCK:
X#endif
X		if(door->doormask & D_LOCKED) {
X		    door->doormask = D_CLOSED | (door->doormask & D_TRAPPED);
X		    if(cansee(x,y)) pline("The door unlocks!");
X		} else res = 0;
X		break;
X	    default:	impossible("magic (%d) attempted on door.", otmp->otyp);
X	}
X	return res;
X}
X
X#ifdef STUPID_CPP	/* otherwise these functions are macros in obj.h */
Xint
XIs_container(otmp) struct obj * otmp; {
X	return(otmp->otyp >= ICE_BOX && otmp->otyp <= BAG_OF_TRICKS);
X}
X
Xint
XIs_box(otmp) struct obj * otmp; {
X	return(otmp->otyp == LARGE_BOX || otmp->otyp == CHEST);
X}
X
Xint
XIs_mbag(otmp) struct obj * otmp; {
X	return(otmp->otyp == BAG_OF_HOLDING || otmp->otyp == BAG_OF_TRICKS);
X}
X
Xint
Xis_sword(otmp) struct obj * otmp; {
X	return(otmp->otyp >= SHORT_SWORD && otmp->otyp <= KATANA);
X}
X
Xint
Xbimanual(otmp) struct obj * otmp; {
X	return(otmp->olet == WEAPON_SYM && objects[otmp->otyp].oc_bimanual);
X}
X#endif /* STUPID_CPP */
END_OF_FILE
if test 15150 -ne `wc -c <'src/lock.c'`; then
    echo shar: \"'src/lock.c'\" unpacked with wrong size!
fi
# end of 'src/lock.c'
fi
if test -f 'src/topten.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/topten.c'\"
else
echo shar: Extracting \"'src/topten.c'\" \(15837 characters\)
sed "s/^X//" >'src/topten.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)topten.c	3.0	88/11/24
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X/* block some unused #defines to avoid overloading some cpp's */
X#define MONATTK_H
X#include "hack.h"
X
X#include <errno.h>      /* George Barbanis */
X
Xstatic char *itoa P((int)), *ordin P((int));
Xstatic void outheader();
Xstatic int outentry P((int,struct toptenentry *,int));
X
X#define newttentry() (struct toptenentry *) alloc(sizeof(struct toptenentry))
X#define	NAMSZ	10
X#define	DTHSZ	60
X#define	PERSMAX	 3		/* entries per name/uid per char. allowed */
X#define	POINTSMIN	1	/* must be > 0 */
X#define	ENTRYMAX	100	/* must be >= 10 */
X#ifndef MSDOS
X#define	PERS_IS_UID		/* delete for PERSMAX per name; now per uid */
X#endif
Xstruct toptenentry {
X	struct toptenentry *tt_next;
X	long int points;
X	int level,maxlvl,hp,maxhp;
X	int uid;
X	char plchar;
X	char sex;
X	char name[NAMSZ+1];
X	char death[DTHSZ+1];
X	char date[7];		/* yymmdd */
X} *tt_head;
X
Xvoid
Xtopten(){
X	int uid = getuid();
X	int rank, rank0 = -1, rank1 = 0;
X	int occ_cnt = PERSMAX;
X	register struct toptenentry *t0, *t1, *tprev;
X	char *recfile = RECORD;
X#ifdef UNIX
X	char *reclock = "record_lock";
X#endif
X	int sleepct = 300;
X	FILE *rfile;
X	register int flg = 0;
X#ifdef LOGFILE
X	char *lgfile = LOGFILE;
X	FILE *lfile;
X#ifdef UNIX
X	char *loglock = "logfile_lock";
X	int sleeplgct = 30;
X#endif /* UNIX */
X#endif /* LOGFILE */
X
X#ifdef MSDOS
X#define HUP
X#else
X#define	HUP	if(!done_hup)
X#endif
X
X#ifdef UNIX
X	while(link(recfile, reclock) == -1) {
X		HUP perror(reclock);
X		if(!sleepct--) {
X			HUP (void) puts("I give up.  Sorry.");
X			HUP (void) puts("Perhaps there is an old record_lock around?");
X			return;
X		}
X		HUP Printf("Waiting for access to record file. (%d)\n",
X			sleepct);
X		HUP (void) fflush(stdout);
X#if defined(SYSV) || defined(ULTRIX)
X		(void)
X#endif
X		    sleep(1);
X	}
X#endif
X	if(!(rfile = fopen(recfile,"r"))){
X		HUP (void) puts("Cannot open record file!");
X		goto unlock;
X	}
X	HUP (void) putchar('\n');
X
X	/* create a new 'topten' entry */
X	t0 = newttentry();
X	t0->level = dlevel;
X	t0->maxlvl = maxdlevel;
X	t0->hp = u.uhp;
X	t0->maxhp = u.uhpmax;
X	t0->points = u.urexp;
X	t0->plchar = pl_character[0];
X	t0->sex = (flags.female ? 'F' : 'M');
X	t0->uid = uid;
X	(void) strncpy(t0->name, plname, NAMSZ);
X	(t0->name)[NAMSZ] = 0;
X	(void) strncpy(t0->death, killer, DTHSZ);
X	(t0->death)[DTHSZ] = 0;
X	Strcpy(t0->date, getdate());
X
X	/* assure minimum number of points */
X	if(t0->points < POINTSMIN) t0->points = 0;
X#ifdef LOGFILE		/* used for debugging (who dies of what, where) */
X#ifdef UNIX
X	while(link(lgfile, loglock) == -1) {
X		extern int errno;
X
X		if (errno == ENOENT) /* If no such file, do not keep log */
X			goto lgend;  /* George Barbanis */
X		HUP perror(loglock);
X		if(!sleeplgct--) {
X			HUP (void) puts("I give up.  Sorry.");
X			HUP (void) puts("Perhaps there is an old logfile_lock around?");
X			goto lgend;
X		}
X		HUP Printf("Waiting for access to log file. (%d)\n",
X 			sleeplgct);
X		HUP (void) fflush(stdout);
X#if defined(SYSV) || defined(ULTRIX)
X		(void)
X#endif
X		    sleep(1);
X	}
X#endif /* UNIX */
X	if(!(lfile = fopen(lgfile,"a"))){
X		HUP (void) puts("Cannot open log file!");
X		goto lgend;
X	}
X	(void) fprintf(lfile,"%6s %d %d %d %d %d %ld %c%c %s,%s\n",
X	    t0->date, t0->uid,
X	    t0->level, t0->maxlvl,
X	    t0->hp, t0->maxhp, t0->points,
X	    t0->plchar, t0->sex, t0->name, t0->death);
X	(void) fclose(lfile);
X#ifdef UNIX
X	(void) unlink(loglock);
X#endif /* UNIX */
X      lgend:;
X#endif /* LOGFILE */
X
X	t1 = tt_head = newttentry();
X	tprev = 0;
X	/* rank0: -1 undefined, 0 not_on_list, n n_th on list */
X	for(rank = 1; ; ) {
X#ifdef TOS
X	    char k1[2],k2[2];
X	    if(fscanf(rfile, "%6s %d %d %d %d %d %ld %1s%1s %s %s]",
X#else
X	    if(fscanf(rfile, "%6s %d %d %d %d %d %ld %c%c %[^,],%[^\n]",
X#endif
X		t1->date, &t1->uid,
X		&t1->level, &t1->maxlvl,
X		&t1->hp, &t1->maxhp, &t1->points,
X#ifdef TOS
X		k1, k2,
X#else
X		&t1->plchar, &t1->sex,
X#endif
X		t1->name, t1->death) != 11 || t1->points < POINTSMIN)
X			t1->points = 0;
X
X#ifdef TOS
X	    t1->plchar=k1[0];
X	    t1->sex=k2[0];
X#endif
X	    if(rank0 < 0 && t1->points < t0->points) {
X		rank0 = rank++;
X		if(tprev == 0)
X			tt_head = t0;
X		else
X			tprev->tt_next = t0;
X		t0->tt_next = t1;
X		occ_cnt--;
X		flg++;		/* ask for a rewrite */
X	    } else tprev = t1;
X
X	    if(t1->points == 0) break;
X	    if(
X#ifdef PERS_IS_UID
X		t1->uid == t0->uid &&
X#else
X		strncmp(t1->name, t0->name, NAMSZ) == 0 &&
X#endif
X		t1->plchar == t0->plchar && --occ_cnt <= 0) {
X		    if(rank0 < 0) {
X			rank0 = 0;
X			rank1 = rank;
X	HUP Printf("You didn't beat your previous score of %ld points.\n\n",
X				t1->points);
X		    }
X		    if(occ_cnt < 0) {
X			flg++;
X			continue;
X		    }
X		}
X	    if(rank <= ENTRYMAX) {
X		t1 = t1->tt_next = newttentry();
X		rank++;
X	    }
X	    if(rank > ENTRYMAX) {
X		t1->points = 0;
X		break;
X	    }
X	}
X	if(flg) {	/* rewrite record file */
X		(void) fclose(rfile);
X		if(!(rfile = fopen(recfile,"w"))){
X			HUP (void) puts("Cannot write record file\n");
X			goto unlock;
X		}
X
X		if(!done_stopprint) if(rank0 > 0){
X		    if(rank0 <= 10)
X			(void) puts("You made the top ten list!\n");
X		    else
X		Printf("You reached the %d%s place on the top %d list.\n\n",
X			rank0, ordin(rank0), ENTRYMAX);
X		}
X	}
X	if(rank0 == 0) rank0 = rank1;
X	if(rank0 <= 0) rank0 = rank;
X	if(!done_stopprint) outheader();
X	t1 = tt_head;
X	for(rank = 1; t1->points != 0; rank++, t1 = t1->tt_next) {
X	  if(flg) (void) fprintf(rfile,"%6s %d %d %d %d %d %ld %c%c %s,%s\n",
X	    t1->date, t1->uid,
X	    t1->level, t1->maxlvl,
X	    t1->hp, t1->maxhp, t1->points,
X	    t1->plchar, t1->sex, t1->name, t1->death);
X	  if(done_stopprint) continue;
X	  if(rank > flags.end_top &&
X	    (rank < rank0-flags.end_around || rank > rank0+flags.end_around)
X	    && (!flags.end_own ||
X#ifdef PERS_IS_UID
X				  t1->uid != t0->uid
X#else
X				  strncmp(t1->name, t0->name, NAMSZ)
X#endif
X		)) continue;
X	  if(rank == rank0-flags.end_around &&
X	     rank0 > flags.end_top+flags.end_around+1 &&
X	     !flags.end_own)
X		(void) putchar('\n');
X	  if(rank != rank0)
X		(void) outentry(rank, t1, 0);
X	  else if(!rank1)
X		(void) outentry(rank, t1, 1);
X	  else {
X		int t0lth = outentry(0, t0, -1);
X		int t1lth = outentry(rank, t1, t0lth);
X		if(t1lth > t0lth) t0lth = t1lth;
X		(void) outentry(0, t0, t0lth);
X	  }
X	}
X	if(rank0 >= rank) if(!done_stopprint)
X		(void) outentry(0, t0, 1);
X	(void) fclose(rfile);
Xunlock:	;
X#ifdef UNIX
X	(void) unlink(reclock);
X#endif
X}
X
Xstatic void
Xoutheader() {
X	char linebuf[BUFSZ];
X	register char *bp;
X
X	Strcpy(linebuf, " No  Points   Name");
X	bp = eos(linebuf);
X	while(bp < linebuf + COLNO - 9) *bp++ = ' ';
X	Strcpy(bp, "Hp [max]");
X	(void) puts(linebuf);
X}
X
X/* so>0: standout line; so=0: ordinary line; so<0: no output, return lth */
Xstatic int
Xoutentry(rank, t1, so)
Xregister struct toptenentry *t1;
Xregister int rank, so;
X{
X	register boolean quit = FALSE, iskilled = FALSE, starv = FALSE,
X		isstoned = FALSE;
X	char linebuf[BUFSZ];
X	linebuf[0] = 0;
X	if(rank) Sprintf(eos(linebuf), " %2d", rank);
X		else Sprintf(eos(linebuf), "   ");
X	Sprintf(eos(linebuf), " %7ld  %.10s", t1->points, t1->name);
X	Sprintf(eos(linebuf), "-%c ", t1->plchar);
X	if(!strncmp("escaped", t1->death, 7)) {
X	  if(!strcmp(" (with amulet)", t1->death+7))
X	    Sprintf(eos(linebuf), "escaped the dungeon with amulet");
X	  else
X	    Sprintf(eos(linebuf), "escaped the dungeon [max level %d]",
X	      t1->maxlvl);
X#ifdef ENDGAME
X	} else if(!strncmp("ascended", t1->death, 8)) {
X	   Sprintf(eos(linebuf), "ascended to demigod-hood");
X#endif
X	} else {
X	  if(!strncmp(t1->death,"quit",4)) {
X		quit = TRUE;
X		Sprintf(eos(linebuf), "quit");
X	  } else if(!strcmp(t1->death,"choked"))
X		Sprintf(eos(linebuf), "choked on %s food",
X			(t1->sex == 'F') ? "her" : "his");
X	  else if(!strncmp(t1->death,"starv",5)) {
X		Sprintf(eos(linebuf), "starved to death");
X		starv = TRUE;
X	  } else if(!strncmp(t1->death, "turned to stone by ",19)) {
X		Sprintf(eos(linebuf), "was petrified");
X		isstoned = TRUE;
X	  } else {
X		Sprintf(eos(linebuf), "was killed");
X		iskilled = TRUE;
X	  }
X#ifdef ENDLEVEL
X	  if (t1->level == ENDLEVEL)
X		Strcpy(eos(linebuf), " in the endgame");
X	  else
X#endif
X	    Sprintf(eos(linebuf), " on%s level %d",
X	      (iskilled || isstoned || starv) ? "" : " dungeon", t1->level);
X	  if(t1->maxlvl != t1->level)
X	    Sprintf(eos(linebuf), " [max %d]", t1->maxlvl);
X	  if(quit && t1->death[4]) Sprintf(eos(linebuf), t1->death + 4);
X	}
X	if(iskilled) Sprintf(eos(linebuf), " by %s%s",
X	  (!strncmp(t1->death, "trick", 5) || !strncmp(t1->death, "the ", 4)
X	   || !strncmp(t1->death, "Mr. ", 4) || !strncmp(t1->death, "Ms. ", 4)
X	   ) ? "" :
X	  index(vowels,*t1->death) ? "an " : "a ",
X	  t1->death);
X	if (isstoned) Sprintf(eos(linebuf), " by %s%s", index(vowels,
X		*(t1->death + 19)) ? "an " : "a ", t1->death + 19);
X	Sprintf(eos(linebuf), ".");
X	if(t1->maxhp) {
X	  register char *bp = eos(linebuf);
X	  char hpbuf[10];
X	  int hppos;
X	  int lngr = strlen(linebuf);
X	  Sprintf(hpbuf, (t1->hp > 0) ? itoa(t1->hp) : "-");
X	  hppos = COLNO - 7 - strlen(hpbuf);
X	  if (lngr >= hppos) hppos = (2*COLNO) - 7 - strlen(hpbuf);
X	  if(bp <= linebuf + hppos) {
X	    /* pad any necessary blanks to the hit point entry */
X	    while(bp < linebuf + hppos) *bp++ = ' ';
X	    Strcpy(bp, hpbuf);
X	    if(t1->maxhp < 10)
X		 Sprintf(eos(bp), "   [%d]", t1->maxhp);
X	    else if(t1->maxhp < 100)
X		 Sprintf(eos(bp), "  [%d]", t1->maxhp);
X	    else Sprintf(eos(bp), " [%d]", t1->maxhp);
X	  }
X	}
X	if(so == 0) (void) puts(linebuf);
X	else if(so > 0) {
X	  register char *bp = eos(linebuf);
X	  if(so >= COLNO) so = COLNO-1;
X	  while(bp < linebuf + so) *bp++ = ' ';
X	  *bp = 0;
X	  standoutbeg();
X	  (void) fputs(linebuf,stdout);
X	  standoutend();
X	  (void) putchar('\n');
X	}
X	return(strlen(linebuf));
X}
X
Xstatic char *
Xitoa(a) int a; {
X#ifdef LINT	/* static char buf[12]; */
Xchar buf[12];
X#else
Xstatic char buf[12];
X#endif
X	Sprintf(buf,"%d",a);
X	return(buf);
X}
X
Xstatic char *
Xordin(n)
Xint n; {
X	register int dd = n%10;
X
X#if ENTRYMAX > 110
X	return((dd==0 || dd>3 || (n/10)%10==1) ? "th" :
X#else
X	return((dd==0 || dd>3 || n/10==1) ? "th" :
X#endif
X	       (dd==1) ? "st" : (dd==2) ? "nd" : "rd");
X}
X
Xchar *
Xeos(s)
Xregister char *s;
X{
X	while(*s) s++;
X	return(s);
X}
X
X/*
X * Called with args from main if argc >= 0. In this case, list scores as
X * requested. Otherwise, find scores for the current player (and list them
X * if argc == -1).
X */
Xvoid
Xprscore(argc,argv)
Xint argc;
Xchar **argv;
X{
X	char **players;
X	int playerct;
X	int rank;
X	register struct toptenentry *t1, *t2;
X	char *recfile = RECORD;
X	FILE *rfile;
X	register int flg = 0, i;
X#ifdef nonsense
X	long total_score = 0L;
X	char totchars[10];
X	int totcharct = 0;
X#endif
X	int outflg = (argc >= -1);
X#ifdef PERS_IS_UID
X	int uid = -1;
X#else
X	char *player0;
X#endif
X
X	if(!(rfile = fopen(recfile,"r"))){
X		(void) puts("Cannot open record file!");
X		return;
X	}
X
X	if(argc > 1 && !strncmp(argv[1], "-s", 2)){
X		if(!argv[1][2]){
X			argc--;
X			argv++;
X		} else if(!argv[1][3] && index("ABCEHKPRSTVW", argv[1][2])) {
X			argv[1]++;
X			argv[1][0] = '-';
X		} else	argv[1] += 2;
X	}
X	if(argc <= 1){
X#ifdef PERS_IS_UID
X		uid = getuid();
X		playerct = 0;
X#else
X		player0 = plname;
X		if(!*player0)
X			player0 = "hackplayer";
X		playerct = 1;
X		players = &player0;
X#endif
X	} else {
X		playerct = --argc;
X		players = ++argv;
X	}
X	if(outflg) (void) putchar('\n');
X
X	t1 = tt_head = newttentry();
X	for(rank = 1; ; rank++) {
X#ifdef TOS
X	  char k1[2], k2[2];
X	  if(fscanf(rfile, "%6s %d %d %d %d %d %ld %1s%1s %s %s]",
X#else
X	  if(fscanf(rfile, "%6s %d %d %d %d %d %ld %c%c %[^,],%[^\n]",
X#endif
X		t1->date, &t1->uid,
X		&t1->level, &t1->maxlvl,
X		&t1->hp, &t1->maxhp, &t1->points,
X#ifdef TOS
X		k1, k2,
X#else
X		&t1->plchar, &t1->sex,
X#endif
X		t1->name, t1->death) != 11)
X			t1->points = 0;
X	  if(t1->points == 0) break;
X#ifdef TOS
X	  t1->plchar=k1[0];
X	  t1->sex=k2[0];
X#endif
X#ifdef PERS_IS_UID
X	  if(!playerct && t1->uid == uid)
X		flg++;
X	  else
X#endif
X	  for(i = 0; i < playerct; i++){
X		if(strcmp(players[i], "all") == 0 ||
X		   strncmp(t1->name, players[i], NAMSZ) == 0 ||
X		  (players[i][0] == '-' &&
X		   players[i][1] == t1->plchar &&
X		   players[i][2] == 0) ||
X		  (digit(players[i][0]) && rank <= atoi(players[i])))
X			flg++;
X	  }
X	  t1 = t1->tt_next = newttentry();
X	}
X	(void) fclose(rfile);
X	if(!flg) {
X	    if(outflg) {
X		Printf("Cannot find any entries for ");
X		if(playerct < 1) Printf("you.\n");
X		else {
X		  if(playerct > 1) Printf("any of ");
X		  for(i=0; i<playerct; i++)
X			Printf("%s%s", players[i], (i<playerct-1)?", ":".\n");
X		  Printf("Call is: %s -s [-role] [maxrank] [playernames]\n", hname);
X		}
X	    }
X	    return;
X	}
X
X	if(outflg) outheader();
X	t1 = tt_head;
X	for(rank = 1; t1->points != 0; rank++, t1 = t2) {
X		t2 = t1->tt_next;
X#ifdef PERS_IS_UID
X		if(!playerct && t1->uid == uid)
X			goto outwithit;
X		else
X#endif
X		for(i = 0; i < playerct; i++){
X			if(strcmp(players[i], "all") == 0 ||
X			   strncmp(t1->name, players[i], NAMSZ) == 0 ||
X			  (players[i][0] == '-' &&
X			   players[i][1] == t1->plchar &&
X			   players[i][2] == 0) ||
X			  (digit(players[i][0]) && rank <= atoi(players[i]))){
X			outwithit:
X				if(outflg)
X				    (void) outentry(rank, t1, 0);
X#ifdef nonsense
X				total_score += t1->points;
X				if(totcharct < sizeof(totchars)-1)
X				    totchars[totcharct++] = t1->plchar;
X#endif
X				break;
X			}
X		}
X		free((genericptr_t) t1);
X	}
X#ifdef nonsense
X	totchars[totcharct] = 0;
X
X	/* We would like to determine whether he is experienced. However,
X	   the information collected here only tells about the scores/roles
X	   that got into the topten (top 100?). We should maintain a
X	   .hacklog or something in his home directory. */
X	flags.beginner = (total_score < 6000);
X	for(i=0; i<6; i++)
X	    if(!index(totchars, "ABCEHKPRSTVW"[i])) {
X		flags.beginner = 1;
X		if(!pl_character[0]) pl_character[0] = "ABCEHKPRSTVW"[i];
X		break;
X	}
X#endif /* nonsense /**/
X}
X
Xstatic int
Xclassmon(plch, fem)
Xchar plch;
Xboolean fem;
X{
X	switch (plch) {
X		case 'A': return PM_ARCHEOLOGIST;
X		case 'B': return PM_BARBARIAN;
X		case 'C': return (fem ? PM_CAVEWOMAN : PM_CAVEMAN);
X		case 'E': return PM_ELF;
X		case 'H': return PM_HEALER;
X		case 'F':	/* accept old Fighter class */
X		case 'K': return PM_KNIGHT;
X		case 'P': return (fem ? PM_PRIESTESS : PM_PRIEST);
X		case 'R': return PM_ROGUE;
X		case 'N':	/* accept old Ninja class */
X		case 'S': return PM_SAMURAI;
X		case 'T': return PM_TOURIST;
X		case 'V': return PM_VALKYRIE;
X		case 'W': return PM_WIZARD;
X		default: impossible("What weird class is this? (%c)", plch);
X			return PM_HUMAN_ZOMBIE;
X	}
X}
X
X/*
X * Get a random player name and class from the high score list,
X * and attach them to an object (for statues or morgue corpses).
X */
Xstruct obj *
Xtt_oname(otmp)
Xstruct obj *otmp;
X{
X	int rank;
X	register int i;
X	register struct toptenentry *tt;
X	char *recfile = RECORD;
X	FILE *rfile;
X
X	if (!otmp) return((struct obj *) 0);
X
X	if(!(rfile = fopen(recfile,"r")))
X		panic("Cannot open record file!");
X
X	tt = newttentry();
X	rank = rnd(10);
Xpickentry:
X	for(i = rank; i; i--) {
X#ifdef TOS
X	  char k1[2], k2[2];
X	  if(fscanf(rfile, "%6s %d %d %d %d %d %ld %1s%1s %s %s]",
X#else
X	  if(fscanf(rfile, "%6s %d %d %d %d %d %ld %c%c %[^,],%[^\n]",
X#endif
X		tt->date, &tt->uid,
X		&tt->level, &tt->maxlvl,
X		&tt->hp, &tt->maxhp, &tt->points,
X#ifdef TOS
X		k1, k2,
X#else
X		&tt->plchar, &tt->sex,
X#endif
X		tt->name, tt->death) != 11)
X			tt->points = 0;
X	  if(tt->points == 0) break;
X#ifdef TOS
X	  tt->plchar=k1[0];
X	  tt->sex=k2[0];
X#endif
X	}
X	(void) fclose(rfile);
X
X	if(tt->points == 0) {
X		if(rank > 1) {
X			rank = 1;
X			goto pickentry;
X		}
X		free((genericptr_t) tt);
X		return((struct obj *) 0);
X	} else {
X		otmp->corpsenm = classmon(tt->plchar, (tt->sex == 'F'));
X		otmp->owt = mons[otmp->corpsenm].cwt;
X		otmp = oname(otmp, tt->name, 0);
X		free((genericptr_t) tt);
X		return otmp;
X	}
X}
END_OF_FILE
if test 15837 -ne `wc -c <'src/topten.c'`; then
    echo shar: \"'src/topten.c'\" unpacked with wrong size!
fi
# end of 'src/topten.c'
fi
if test -f 'src/unixtty.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/unixtty.c'\"
else
echo shar: Extracting \"'src/unixtty.c'\" \(4576 characters\)
sed "s/^X//" >'src/unixtty.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)unixtty.c	3.0	88/05/03
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X/* tty.c - (Unix) version */
X
X/* With thanks to the people who sent code for SYSV - hpscdi!jon,
X * arnold@ucsf-cgl, wcs@bo95b, cbcephus!pds and others.
X */
X
X/* block some unused #defines to avoid overloading some cpp's */
X#define MONATTK_H
X#define ONAMES_H
X#include "hack.h"
X
X/*
X * The distinctions here are not BSD - rest but rather USG - rest, as
X * BSD still has the old sgttyb structure, but SYSV has termio. Thus:
X */
X#if defined(BSD) || defined(ULTRIX)
X#define	V7
X#else
X#define USG
X#endif
X
X
X#ifdef USG
X
X#include	<termio.h>
X#define termstruct	termio
X#define kill_sym	c_cc[VKILL]
X#define erase_sym	c_cc[VERASE]
X#define intr_sym	c_cc[VINTR]
X#define EXTABS		TAB3
X#define tabflgs		c_oflag
X#define echoflgs	c_lflag
X#define cbrkflgs	c_lflag
X#define CBRKMASK	ICANON
X#define CBRKON		! /* reverse condition */
X#define OSPEED(x)	((x).c_cflag & CBAUD)
X#define GTTY(x)		(ioctl(0, TCGETA, x))
X/* STTY now modified to run under Sys V R3.	- may have to be #ifdef'ed */
X#define STTY(x)		(ioctl(0, TCSETAW, x))	/* TCSETAF? TCSETAW? */
X#define GTTY2(x)	1
X#define STTY2(x)	1
X#define nonesuch	0
X#define inittyb2	inittyb
X#define curttyb2	curttyb
X
X#else	/* V7 */
X
X#include	<sgtty.h>
X#define termstruct	sgttyb
X#define	kill_sym	sg_kill
X#define	erase_sym	sg_erase
X#define	intr_sym	t_intrc
X#define EXTABS		XTABS
X#define tabflgs		sg_flags
X#define echoflgs	sg_flags
X#define cbrkflgs	sg_flags
X#define CBRKMASK	CBREAK
X#define CBRKON		/* empty */
X#define OSPEED(x)	(x).sg_ospeed
X#define GTTY(x)		(gtty(0, x))
X#define STTY(x)		(stty(0, x))
X#define GTTY2(x)	(ioctl(0, TIOCGETC, (char *)x))
X#define STTY2(x)	(ioctl(0, TIOCSETC, (char *)x))
X#define nonesuch	-1
Xstruct tchars inittyb2, curttyb2;
X
X#endif
X
Xextern short ospeed;
Xchar erase_char, intr_char, kill_char;
Xstatic boolean settty_needed = FALSE;
Xstruct termstruct inittyb, curttyb;
X
Xstatic void
Xsetctty(){
X	if(STTY(&curttyb) < 0 || STTY2(&curttyb2) < 0)
X		perror("NetHack (setctty)");
X}
X
X/*
X * Get initial state of terminal, set ospeed (for termcap routines)
X * and switch off tab expansion if necessary.
X * Called by startup() in termcap.c and after returning from ! or ^Z
X */
Xvoid
Xgettty(){
X	if(GTTY(&inittyb) < 0 || GTTY2(&inittyb2) < 0)
X		perror("NetHack (gettty)");
X	curttyb = inittyb;
X	curttyb2 = inittyb2;
X	ospeed = OSPEED(inittyb);
X	erase_char = inittyb.erase_sym;
X	kill_char = inittyb.kill_sym;
X	intr_char = inittyb2.intr_sym;
X	getioctls();
X
X	/* do not expand tabs - they might be needed inside a cm sequence */
X	if(curttyb.tabflgs & EXTABS) {
X		curttyb.tabflgs &= ~EXTABS;
X		setctty();
X	}
X	settty_needed = TRUE;
X}
X
X/* reset terminal to original state */
Xvoid
Xsettty(s)
Xchar *s;
X{
X	clear_screen();
X	end_screen();
X	if(s) Printf(s);
X	(void) fflush(stdout);
X	if(STTY(&inittyb) < 0 || STTY2(&inittyb2) < 0)
X		perror("NetHack (settty)");
X	flags.echo = (inittyb.echoflgs & ECHO) ? ON : OFF;
X	flags.cbreak = (CBRKON(inittyb.cbrkflgs & CBRKMASK)) ? ON : OFF;
X	setioctls();
X}
X
Xvoid
Xsetftty(){
Xregister int ef = 0;			/* desired value of flags & ECHO */
X#ifdef LINT	/* cf = CBRKON(CBRKMASK); const expr to initialize is ok */
Xregister int cf = 0;
X#else
Xregister int cf = CBRKON(CBRKMASK);	/* desired value of flags & CBREAK */
X#endif
Xregister int change = 0;
X	flags.cbreak = ON;
X	flags.echo = OFF;
X	/* Should use (ECHO|CRMOD) here instead of ECHO */
X	if((curttyb.echoflgs & ECHO) != ef){
X		curttyb.echoflgs &= ~ECHO;
X/*		curttyb.echoflgs |= ef;					*/
X		change++;
X	}
X	if((curttyb.cbrkflgs & CBRKMASK) != cf){
X		curttyb.cbrkflgs &= ~CBRKMASK;
X		curttyb.cbrkflgs |= cf;
X#ifdef USG
X		/* be satisfied with one character; no timeout */
X		curttyb.c_cc[VMIN] = 1;		/* was VEOF */
X		curttyb.c_cc[VTIME] = 0;	/* was VEOL */
X#endif
X		change++;
X	}
X	/* If an interrupt character is used, it will be overriden and
X	 * set to ^C.
X	 */
X	if(intr_char != nonesuch && curttyb2.intr_sym != '\003') {
X	    curttyb2.intr_sym = '\003';
X	    change++;
X	}
X
X	if(change) setctty();
X	start_screen();
X}
X
Xvoid
Xintron() {		/* enable kbd interupts if enabled when game started */
X
X	if(intr_char != nonesuch && curttyb2.intr_sym != '\003') {
X	    curttyb2.intr_sym = '\003';
X	    setctty();
X	}
X}
X
Xvoid
Xintroff() {		/* disable kbd interrupts if required*/
X
X	if(curttyb2.intr_sym != nonesuch) {
X	    curttyb2.intr_sym = nonesuch;
X	    setctty();
X	}
X}
X
X
X/* fatal error */
X/*VARARGS1*/
Xvoid
Xerror(s, x, y)
Xchar *s, *x, *y;
X{
X	if(settty_needed)
X		settty(NULL);
X	Printf(s,x,y);
X	(void) putchar('\n');
X	exit(1);
X}
END_OF_FILE
if test 4576 -ne `wc -c <'src/unixtty.c'`; then
    echo shar: \"'src/unixtty.c'\" unpacked with wrong size!
fi
# end of 'src/unixtty.c'
fi
echo shar: End of archive 23 \(of 38\).
cp /dev/null ark23isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 38 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
