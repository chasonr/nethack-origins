Path: utzoo!utgpu!jarvis.csri.toronto.edu!mailrus!tut.cis.ohio-state.edu!cs.utexas.edu!uunet!zephyr.ens.tek.com!tektronix!tekgen!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v07i090:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Part35/38
Message-ID: <4347@tekred.CNA.TEK.COM>
Date: 24 Jul 89 19:10:05 GMT
Sender: nobody@tekred.CNA.TEK.COM
Lines: 1904
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 7, Issue 90
Archive-name: NetHack3/Part35



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 35 (of 38)."
# Contents:  Install.unix amiga/amitcap.c auxil/lev_comp.6
#   auxil/oracles include/global.h include/mondata.h include/monflag.h
#   include/system.h others/termcap src/demon.c src/worn.c src/write.c
# Wrapped by billr@saab on Sun Jul 23 21:33:21 1989
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'Install.unix' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Install.unix'\"
else
echo shar: Extracting \"'Install.unix'\" \(3864 characters\)
sed "s/^X//" >'Install.unix' <<'END_OF_FILE'
XInstructions for installing NetHack 3.0 on a UNIX system
X========================================================
X
X1.  Make sure all the NetHack files are in the appropriate directory structure.
X    You should have a main directory with subdirectories src, include, auxil,
X    amiga, and others.  If you do not follow this structure, the Makefiles
X    will not function properly.  All the UNIX .c files and the source Makefile
X    belong in src; all the .h files belong in include; other assorted files
X    belong in auxil.  The UNIX version does not use any files from amiga or
X    others, except possibly for random.c from others, as explained in step 6.
X    (A more detailed explanation of the directory structure may be found in
X    Files, which should be in the top directory.)
X
X2.  Your Makefiles may still have tags on the end of them.  Makefile.top should
X    become Makefile in the top directory, Makefile.src Makefile in the src
X    subdirectory, and Makefile.auxil Makefile in the auxil subdirectory.
X
X3.  Go to the include subdirectory and edit config.h according to the comments
X    to match your system and desired set of features.  Similarly edit
X    unixconf.h.
X
X4.  If you want to, look through system.h.  This file attempts to match the
X    types for system calls and library routines with various flavors of
X    operating systems.  Leaving this file alone is unlikely to cause worse
X    problems than lint errors, but it's worth checking if you get compile
X    errors, especially if you have an unusual system.
X
X5.  Go to the src subdirectory and look at the top of topten.c.  You may want
X    to change the definitions of PERSMAX and PERS_IS_UID here to get different
X    behavior from the high score list.
X
X6.  Edit the top section of the src Makefile.  (If you are doing a full
X    recompile, or if you got your files from someplace besides the official
X    distribution, type 'touch makedefs.c' to make sure certain files (onames.h,
X    pm.h) get remade instead of relying on the potentially troublesome
X    timestamps.)  If you elected to use the provided (BSD) random routines,
X    move or link random.c into the src subdirectory from others.  Then type
X    'make' in src and go get a cup of coffee or take a nap.  You should now
X    have created the game executable.
X
X7.  Go back to the main directory and edit that Makefile, explaining where you
X    want everything to be installed.  The Makefile assumes you want to run
X    NetHack setuid 'games' to cut down on possible tampering; it's fairly
X    straightforward to comment out the appropriate chmod if you don't want that,
X    or to change any of the rest of the procedure.  Also edit auxil/nethack.sh
X    at this point.  Type 'make spec_levs' from the main directory to set up
X    files for some of the special levels.  Then become root if necessary and
X    type 'make install'.  Everything should now be set.
X
XNotes:
X
X1.  No, your old save files and bones files will not work with NetHack 3.0.
X    Don't bother trying to keep them.  The old score list will work fine; the
X    only problem is that you may have trouble beating your old scores in this
X    version.
X
X2.  If you insisted on doing the final installation by hand, you probably
X    forgot to make a save directory.  If you don't go back and do this, you
X    won't be able to save games.
X
X3.  To install an update of this version of NetHack after changing something,
X    type 'make update' from the main directory.  If you created the new
X    version yourself, it should be safe to use 'make update' as long as you
X    did not add, delete, or reorder monsters or objects and you did not change
X    the format of saved level files.  If you did any of these things, you
X    should also remove any saved games and bones levels.  (Trying to use such
X    files often produces amusing but useless confusions on the game's part.)
END_OF_FILE
if test 3864 -ne `wc -c <'Install.unix'`; then
    echo shar: \"'Install.unix'\" unpacked with wrong size!
fi
# end of 'Install.unix'
fi
if test -f 'amiga/amitcap.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'amiga/amitcap.c'\"
else
echo shar: Extracting \"'amiga/amitcap.c'\" \(4528 characters\)
sed "s/^X//" >'amiga/amitcap.c' <<'END_OF_FILE'
X/*    SCCS Id: @(#)amitcap.c    3.0    89/07/18
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X/* block some unused #defines to avoid overloading some cpp's */
X#define MONATTK_H
X#include "hack.h"       /* for ROWNO, COLNO, *HI, *HE, *AS, *AE */
X
Xstatic char HO[] = "\233H";         /* Home         CSI H */
Xstatic char CL[] = "\f";            /* Clear        FF */
Xstatic char CE[] = "\233K";         /* Erase EOL    CSI K */
Xstatic char UP[] = "\x0B";          /* Cursor up    VT */
Xstatic char ND[] = "\233C";         /* Cursor right CSI C */
Xstatic char XD[] = "\233B";         /* Cursor down  CSI B */
Xstatic char BC[] = "\b";            /* Cursor left  BS */
Xstatic char MR[] = "\2337m";        /* Reverse on   CSI 7 m */
Xstatic char ME[] = "\2330m";        /* Reverse off  CSI 0 m */
X
X#ifdef MSDOSCOLOR    /* creps@silver.bacs.indiana.edu */
Xstatic char SO[] = "\23333m";       /* Standout: Color #3 (orange) */
Xstatic char SE[] = "\2330m";
X#else
Xstatic char SO[] = "\2337m";        /* Inverse video */
Xstatic char SE[] = "\2330m";
X#endif
X
X
Xvoid
Xstartup()
X{
X    (void) Initialize();        /* This opens screen, window, console, &c */
X
X    CO = COLNO;
X    LI = ROWNO+3;               /* used in pri.c and pager.c */
X
X    set_whole_screen();
X
X    CD = "\233J";               /* used in pager.c */
X
X#ifdef MSDOSCOLOR
X    /*
X     * We need 5 different 'colors', but in a 4-color screen we really
X     * cannot make these available, even more so because we use the user's
X     * preferred Workbench colors. Instead, we use different combinations
X     * of the 4 possible colors. For orientation: default colors are
X     * white (1) on blue (0), and a orange (3) cursor on a black (2) character.
X     */
X    HI_GREEN  = "\23331;42m";   /* White on Black */
X    HI_RED    = "\23333;42m";   /* Orange on Black */
X    HI_YELLOW = "\23333;40m";   /* Orange on Blue */
X    HI_BLUE   = "\23333;41m";   /* Orange on White */
X    HI_WHITE  = "\23330;41m";   /* Blue on White */
X
X    HI = "\2331m";              /* Bold (hilight) */
X    HE = "\2330m";              /* Plain */
X#else
X    HI = "\2334m";              /* Underline */
X    HE = "\2330m";              /* Plain */
X#endif
X}
X
Xvoid
Xstart_screen()
X{
X}
X
Xvoid
Xend_screen()
X{
X    clear_screen();
X}
X
X/* Cursor movements */
Xextern xchar curx, cury;
X
Xvoid
Xcurs(x, y)
Xregister int x, y;
X{
X    if (x != curx || y != cury) {
X        /* Test a few simple cases */
X        if (x == 1) {
X            if (y == cury) {
X                putchar('\r');
X                goto done;
X            }
X            if (y == cury+1) {
X                putchar('\n');  /* console.device is in crmod mode */
X                goto done;
X            }
X        } else if (x == curx) {
X            if (y == cury-1) {
X                putchar('\x0B');
X                goto done;
X            }
X            if (y == cury+1) {
X                xputs(XD);
X                goto done;
X            }
X        } else if (y == cury) {
X            if (x == curx-1) {
X                putchar('\b');
X                goto done;
X            }
X            if (x == curx+1) {
X                xputs(ND);
X                goto done;
X            }
X        }
X        {
X            static char CM[] = "\233--;--H";
X            CM[1] = '0' + y/10;   /* Assumes 0 <= y < 100 */
X            CM[2] = '0' + y%10;
X            CM[4] = '0' + x/10;   /* Assumes 0 <= x < 100 */
X            CM[5] = '0' + x%10;
X            xputs(CM);
X        }
X
Xdone:
X        cury = y;
X        curx = x;
X    }
X}
X
Xvoid
Xcl_end()
X{
X    xputs(CE);
X}
X
Xvoid
Xclear_screen()
X{
X    xputs(CL);
X    home();
X}
X
Xvoid
Xhome()
X{
X    xputs(HO);
X    curx = cury = 1;
X}
X
Xvoid
Xstandoutbeg()
X{
X    xputs(SO);
X}
X
Xvoid
Xstandoutend()
X{
X    xputs(SE);
X}
X
Xvoid
Xrevbeg()
X{
X        xputs(MR);
X}
X
X#if 0   /* if you need one of these, uncomment it */
Xvoid
Xboldbeg()
X{
X        xputs("\2331m");        /* CSI 1 m */
X}
X
Xvoid
Xblinkbeg()
X{
X        /* No blink available */
X}
X
Xvoid
Xdimbeg()
X/* not in most termcap entries */
X{
X        /* No dim available, use italics */
X        xputs("\2333m");        /* CSI 3 m */
X}
X#endif
X
Xvoid
Xm_end()
X{
X        xputs(ME);
X}
X
Xvoid
Xbacksp()
X{
X    xputs(BC);
X}
X
Xvoid
Xbell()
X{
X    if (flags.silent) return;
X    (void) putchar('\007');        /* curx does not change */
X    (void) fflush(stdout);
X}
X
Xvoid
Xdelay_output() {
X    /* delay 50 ms */
X    (void) fflush(stdout);
X    Delay(2L);
X}
X
Xvoid
Xcl_eos()
X{                /* must only be called with curx = 1 */
X    xputs(CD);
X}
END_OF_FILE
if test 4528 -ne `wc -c <'amiga/amitcap.c'`; then
    echo shar: \"'amiga/amitcap.c'\" unpacked with wrong size!
fi
# end of 'amiga/amitcap.c'
fi
if test -f 'auxil/lev_comp.6' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'auxil/lev_comp.6'\"
else
echo shar: Extracting \"'auxil/lev_comp.6'\" \(4224 characters\)
sed "s/^X//" >'auxil/lev_comp.6' <<'END_OF_FILE'
X.TH LEV_COMP 6 "5 JULY 1989"
X.UC 4
X.SH NAME
Xlev_comp \- NetHack special levels compiler
X.SH SYNOPSIS
X.B lev_comp
X[
X.I files
X]
X.SH DESCRIPTION
X.PP
X.I Lev_comp
Xis a special level compiler for NetHack version 3.0 and higher.
XIt takes description files as arguments and produces level files that can be
Xloaded by NetHack at runtime.
XIf no arguments are given, it reads standard input.
X.PP
XThe purpose of this tool is to provide NetHack administrators and implementors
Xwith a convenient way for adding special levels to the game,
Xor modifying existing ones,
Xwithout having to recompile the entire world.
XAt this time, the special levels code is not fully implemented,
Xas the decision to load the special levels is hard-coded in the game.
XIn a future release, it is expected to be a run-time decision.
X.SH GRAMMAR
X.PP
X.LP
X.nf
X.ta +8n +8n +8n +8n
X
Xfile		: /* nothing */
X		| levels
X
Xlevels		: level
X		| levels level
X
Xlevel		: maze_level
X
Xmaze_level	: maze_definition regions
X
Xmaze_definition	: "MAZE" ':' filename
X
Xfilename	: STRING
X
Xregions		: region
X		| regions region
X
Xregion		: map_definition reg_initialization map_details
X
Xmap_definition	: map_geometry map
X
Xmap_geometry	: "GEOMETRY" ':' hjustif ',' vjustif
X
Xhjustif		: "left" | "center" | "right"
X
Xvjustif		: "top" | "center" | "bottom"
X
Xmap		: "MAP\\n" map_lines "ENDMAP"
X
Xmap_lines	: map_line
X		| map_lines map_line
X
Xmap_line	: map_chars '\\n'
X
Xmap_chars	: map_char
X		| map_chars map_char
X
Xmap_char	: '-' | '|' | '{' | '}' | '+' | 'S'
X		| 'K' | '\\' | '#' | '.' | ' '
X
Xreg_initialization : /* nothing */
X		   | reg_initialization init_reg
X
Xinit_reg	: "RANDOM_OBJECTS" ':' object_list
X		| "RANDOM_PLACES" ':' place_list
X		| "RANDOM_MONSTERS" ':' monster_list
X
Xobject_list	: object
X		| object_list ',' object
X
Xplace_list	: place
X		| place_list ',' place
X
Xmonster_list	: monster
X		| monster_list ',' monster
X
Xmap_details	: /* nothing */
X		: map_details map_detail
X
Xmap_detail	: monster_detail
X		| object_detail
X		| door_detail
X		| trap_detail
X		| drawbridge_detail
X		| region_detail
X		| altar_detail
X		| mazewalk_detail
X		| ladder_detail
X		| diggable_detail
X
Xmonster_detail	: "MONSTER" ':' monster_c ',' m_name ',' coordinate
X
Xobject_detail	: "OBJECT" ':' object_c ',' o_name ',' coordinate
X
Xdoor_detail	: "DOOR" ':' door_state ',' coordinate
X
Xtrap_detail	: "TRAP" ':' trap_name ',' coordinate
X
Xdrawbridge_detail : "DRAWBRIDGE" ':' coordinate ',' direction ',' open
X
Xmazewalk_detail	: "MAZEWALK" ':' coordinate ',' direction
X
Xladder_detail	: "LADDER" ':' coordinate ',' up_or_down
X
Xdiggable_detail	: "NON_DIGGABLE" ':' rectangle
X
Xaltar_detail	: "ALTAR" ':' coordinate ',' alignment ',' altar_type
X
Xregion_detail	: "REGION" ':' rectangle ',' light_state ',' room_type
X
Xmonster_c	: CHAR
X		| "random"
X		| m_register
X
Xobject_c	: CHAR
X		| "random"
X		| o_register
X
Xm_name		: STRING
X		| "random"
X
Xo_name		: STRING
X		| "random"
X
Xtrap_name	: STRING
X		| "random"
X
Xlight_state	: "lit" | "unlit"
X		| "random"
X
Xroom_type	: STRING
X		| "random"
X
Xcoordinate	: place
X		| p_register
X		| "random"
X
Xdoor_state	: "open" | "closed" | "locked" | "broken" | "nodoor"
X		| "random"
X
Xopen_or_closed	: "open" | "closed"
X
Xalignment	: "law" | "neutral" | "chaos"
X		| a_register
X		| "random"
X
Xaltar_type	: "shrine" | "altar"
X		| "random"
X
Xp_register	: "place" '[' INTEGER ']'
X
Xo_register	: "object" '[' INTEGER ']'
X
Xm_register	: "monster" '[' INTEGER ']'
X
Xa_register	: "altar" '[' { 0 | 1 | 2 } ']'
X
Xplace		: '(' INTEGER ',' INTEGER ')'
X
Xrectangle	: '(' INTEGER ',' INTEGER ',' INTEGER ',' INTEGER ')'
X.fi
X.PP
X.I NOTE:
X.br
XLines beginning with '#' are considered comments.
X
X.SH EXAMPLE
X.PP
XHere is an example of a description file (a very simple one):
X.LP
X.nf
X.ta +8n +8n +8n
XMAZE : "fortress"
XGEOMETRY : center , center
XMAP
X}}}}}}}}}}}}}
X}}}|-----|}}}
X}}}|.....|}}}
X}|--.....--|}
X}|.........|}
X}|--.....--|}
X}}}|.....|}}}
X}}}|-----|}}}
X}}}}}}}}}}}}}
XENDMAP
XMONSTER: '@',"wizard of yendor", (6,4)
X# a random dragon somewhere
XMONSTER: 'D', random, random
X# a random trap in the EAST part
XTRAP: random, (10,4)
X.fi
X.PP
XThis example will produce a file named "fortress" that can be integrated into
Xone of the numerous mazes of the game...
X
X.SH AUTHOR
X.PP
XJean-christophe Collet.
X.SH BUGS
X.PP
XProbably infinite.
END_OF_FILE
if test 4224 -ne `wc -c <'auxil/lev_comp.6'`; then
    echo shar: \"'auxil/lev_comp.6'\" unpacked with wrong size!
fi
# end of 'auxil/lev_comp.6'
fi
if test -f 'auxil/oracles' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'auxil/oracles'\"
else
echo shar: Extracting \"'auxil/oracles'\" \(3868 characters\)
sed "s/^X//" >'auxil/oracles' <<'END_OF_FILE'
XIf thy wand hath run out of charges, thou mayest zap it again and again; though
Xnothing will happen at first, thy persistence shall surely be rewarded, as
Xone last charge shall be wrested from it!
X-----
XTo complete thy quest, thou needest enter the infernal regions.  If thou hast
Xnot immunity to fire, such a trip will surely prove to be thy last; prepare
Xthyself in advance.
X-----
XThough the shopkeepers be wary, thieves have nevertheless stolen much by using
Xtheir digging wands to hasten exits through the pavement.
X-----
XIf thou hast had trouble with rust on thy armor or weapons, thou shouldst know
Xthat thou canst prevent this by, while in a confused state, reading the magical
Xparchments which normally are used to cause their enchantment.
X-----
XBehold the cockatrice, a mighty creature which can petrify anything normal it
Xcomes across--save the wise adventurer who eats a dead lizard or blob of acid
Xwhen he feels himself slowly turning to stone.
X-----
XWhile some armor protects against magical attacks, few types compare to the
Xitems which come from the elven regions, though iron or crystalline plate
Xmail have similar good qualities.
X-----
XIt is well known among travelers that extra-healing draughts may clear thy
Xsenses when thou art addled by hallucinations.  But never forget, the lowly
Xpotion which makes one sick may be used for the same purpose.
X-----
XIf thou hast been confused, thy head may be set straight if thou eatest a
Xdead lizard and waitest, or drinkest water of the utmost holiness.
X-----
XIf thou wishest to reach deep levels, thou must be able to control thy tele-
Xports, and be confused, and read the scroll which usually teleports thyself
Xaround on the level.  Daring adventurers have also performed the same feat
Xsans need for scrolls or potions by stepping on the correct type of trap.
X-----
XMost all adventurers who come this way hope to pass the medusa.  To do this,
Xthe best advice is to keep thine eyes blindfolded and to cause the creature
Xto espy its own reflection in a mirror.
X-----
XAnd when it is written, "ad aerarium," diligent searching will often reveal
Xthe way to a trap which sends one to the Magic Memory Vault, where the riches
Xof Croesus are stored; however, escaping from the vault with its gold is much
Xharder than getting in.
X-----
XIt is well known that wily shopkeepers doth raise their prices whene'er they
Xespy the garish apparel of the approaching tourist or the countenance of a
Xdisfavored patron.  Prices favor the gentle of manner and the fair of face.
XThe boor mayst expect unprofitable transactions.
X-----
XThe cliche of the kitchen sink swallowing any unfortunate rings that contact
Xits pernicious surface doth reflect greater truth as many homilies, yet
Xeven so, few hath developed the skill to identify enchanted rings by the
Xtransfigurations effected upon the voracious device's frame.
X-----
XThe meat of enchanted creatures will ofttimes convey magical properties
Xunto the consumer.  A fresh corpse of floating eye doth fetch a high
Xprice among wizards for its utility for to develop Telepathy, by which
Xthe sightless mayst locate surrounding minds.
X-----
XThe detection of blessings and curses is in the domain of the gods.  They will
Xmake this information available to mortals who request it at their places of
Xworship, or elsewhere for those mortals who devote themselves to the service
Xof the gods.
X-----
XThe elven dagger Sting is famed for its abilities against all creatures of the
Xorcish race.  It will glow when such monsters approach, and cause them special
Xinjury.
X-----
XAdventurers searching for Medusa or the Wizard of Yendor needst not wait until
Xtheir dungeon level corresponds with their enemies' to know their location.
XEat a floating eye, blind thyself, and use a mirror in thine own direction,
Xand provided thou art lucky, thou shalt know the approximate locations of
Xthine enemies.
END_OF_FILE
if test 3868 -ne `wc -c <'auxil/oracles'`; then
    echo shar: \"'auxil/oracles'\" unpacked with wrong size!
fi
# end of 'auxil/oracles'
fi
if test -f 'include/global.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/global.h'\"
else
echo shar: Extracting \"'include/global.h'\" \(3668 characters\)
sed "s/^X//" >'include/global.h' <<'END_OF_FILE'
X/*	SCCS Id: @(#)global.h	3.0	89/07/12
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#ifndef GLOBAL_H
X#define	GLOBAL_H
X
X#include <stdio.h>
X
X
X/* #define BETA		/* if a beta-test copy  [MRS] */
X#define VERSION	"3.0e"	/* version number. */
X
X/*
X * Files expected to exist in the playground directory.
X */
X
X#define RECORD	"record"  /* the file containing the list of topscorers */
X#define	HELP	"help"	  /* the file containing command descriptions */
X#define	SHELP	"hh"	  /* abbreviated form of the same */
X#define	RUMORFILE	"rumors"	/* a file with fortune cookies */
X#define ORACLEFILE	"oracles"	/* a file with oracular information */
X#define	DATAFILE	"data"	/* a file giving the meaning of symbols used */
X#define CMDHELPFILE	"cmdhelp"	/* file telling what commands do */
X#define HISTORY		"history"	/* a file giving nethack's history */
X#define LICENSE		"license"	/* file with license information */
X#define OPTIONFILE	"opthelp"	/* a file explaining runtime options */
X
X
X
X/* Assorted definitions that may depend on selections in config.h. */
X
X/*
X * for DUMB preprocessor and compiler, e.g., cpp and pcc supplied
X * with Microport SysV/AT, which have small symbol tables;
X * DUMB if needed is defined in CFLAGS
X */
X#ifdef DUMB
X#ifdef BITFIELDS
X#undef BITFIELDS
X#endif
X#ifndef STUPID
X#define STUPID
X#endif
X#ifndef STUPID_CPP
X#define STUPID_CPP
X#endif
X#endif	/* DUMB */
X
X/*
X * type xchar: small integers in the range 0 - 127, usually coordinates
X * although they are nonnegative they must not be declared unsigned
X * since otherwise comparisons with signed quantities are done incorrectly
X */
Xtypedef schar	xchar;
Xtypedef	xchar	boolean;		/* 0 or 1 */
X
X#define	TRUE	((boolean)1)
X#define	FALSE	((boolean)0)
X
X#ifdef BITFIELDS
X#define	Bitfield(x,n)	unsigned x:n
X#else
X#define	Bitfield(x,n)	uchar x
X#endif
X
X
X#define	SIZE(x)	(int)(sizeof(x) / sizeof(x[0]))
X
X/* (No, LARGEST_INT doesn't have to correspond to the largest integer on
X * a particular machine.)
X */
X#define LARGEST_INT	((1 << 15) - 1)
X
X
X#ifdef STRONGHOLD
X# ifdef ALTARS
X#  ifdef THEOLOGY
X#define ENDGAME
X#  endif
X# endif
X#endif
X
X#ifdef REDO
X#define Getchar pgetchar
X#endif
X
X/*
X * Automatic inclusions for the subsidiary files.
X * Please don't change the order.  It does matter.
X */
X
X#ifndef COORD_H
X#include "coord.h"
X#endif
X#if defined(UNIX) && !defined(UNIXCONF_H)
X# include "unixconf.h"
X#endif
X
X#if defined(MSDOS) && !defined(PCCONF_H)
X# include "pcconf.h"
X#endif
X
X#if defined(TOS) && !defined(TOSCONF_H)
X# include "tosconf.h"
X#endif
X
X#if defined(AMIGA) && !defined(AMICONF_H)
X# include "amiconf.h"
X#endif
X
X
X
X/*
X * Configurable internal parameters.
X *
X * Please be very careful if you are going to change one of these.  Any
X * changes in these parameters, unless properly done, can render the
X * executable inoperative.
X */
X
X/* size of terminal screen is (at least) (ROWNO+3) by COLNO */
X#define	COLNO	80
X#define	ROWNO	21
X
X#define	MAXNROFROOMS	20	/* max number of rooms per level */
X#define	DOORMAX		120	/* max number of doors per level */
X
X#define	BUFSZ		256	/* for getlin buffers */
X
X#define	PL_NSIZ		32	/* name of player, ghost, shopkeeper */
X#define	PL_CSIZ		20	/* sizeof pl_character */
X#define PL_FSIZ		32	/* fruit name */
X
X#define	MAXLEVEL	50	/* max number of levels in the dungeon */
X#ifdef ENDGAME
X#define ENDLEVEL (MAXLEVEL+1)	/* endgame level */
X#endif
X#define HELLLEVEL	30	/* first hell level (varies ifdef STRONGHOLD) */
X#define	MAXULEV		30	/* max character experience level */
X
X#define	MAXMONNO	120	/* geno monst after this number killed */
X#define MHPMAX		500	/* maximum monster hp */
X
X#endif /* GLOBAL_H /**/
END_OF_FILE
if test 3668 -ne `wc -c <'include/global.h'`; then
    echo shar: \"'include/global.h'\" unpacked with wrong size!
fi
# end of 'include/global.h'
fi
if test -f 'include/mondata.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/mondata.h'\"
else
echo shar: Extracting \"'include/mondata.h'\" \(4502 characters\)
sed "s/^X//" >'include/mondata.h' <<'END_OF_FILE'
X/*	SCCS Id: @(#)mondata.h	3.0	89/03/06
X/* NetHack may be freely redistributed.  See license for details. */
X/* Copyright (c) 1989 Mike Threepoint */
X
X#ifndef MONDATA_H
X#define MONDATA_H
X
X# ifndef STUPID_CPP	/* otherwise these macros are functions in mondata.c */
X
X#define bigmonst(ptr)		(((ptr)->mflags1 & M1_BIG) != 0L)
X#define verysmall(ptr)		(((ptr)->mflags1 & M1_VSMALL) != 0L)
X#define is_flyer(ptr)		(((ptr)->mflags1 & M1_FLY) != 0L)
X#define is_floater(ptr) 	((ptr)->mlet == S_EYE)
X#define is_swimmer(ptr) 	(((ptr)->mflags1 & M1_SWIM) != 0L)
X#define passes_walls(ptr)	(((ptr)->mflags1 & M1_WALLWALK) != 0L)
X#define noncorporeal(ptr)	((ptr)->mlet == S_GHOST)
X#define is_animal(ptr)		(((ptr)->mflags1 & M1_ANIMAL) != 0L)
X#define humanoid(ptr)		(((ptr)->mflags1 & M1_HUMANOID) != 0L)
X#define is_undead(ptr)		(((ptr)->mflags1 & M1_UNDEAD) != 0L)
X#define is_were(ptr)		(((ptr)->mflags1 & M1_WERE) != 0L)
X#define haseyes(ptr)		(((ptr)->mflags1 & M1_NOEYES) == 0L)
X#define nohands(ptr)		(((ptr)->mflags1 & M1_NOHANDS) != 0L)
X#define lays_eggs(ptr)		(((ptr)->mflags1 & M1_EGGS) != 0L)
X#define poisonous(ptr)		(((ptr)->mflags1 & M1_POIS) != 0L)
X#define resists_poison(ptr)	(((ptr)->mflags1 & (M1_POIS | M1_POIS_RES)) != 0L)
X#define resists_fire(ptr)	(((ptr)->mflags1 & M1_FIRE_RES) != 0L)
X#define resists_cold(ptr)	(((ptr)->mflags1 & M1_COLD_RES) != 0L)
X#define resists_acid(ptr)	dmgtype(ptr, AD_ACID)
X#define resists_elec(ptr)	(((ptr)->mflags1 & M1_ELEC_RES) != 0L)
X#define resists_sleep(ptr)	(((ptr)->mflags1 & (M1_SLEE_RES | M1_UNDEAD)) != 0L)
X#define resists_disint(ptr)	((ptr) == &mons[PM_BLACK_DRAGON] || (ptr) == &mons[PM_BABY_BLACK_DRAGON])
X#define regenerates(ptr)	(((ptr)->mflags1 & M1_REGEN) != 0L)
X#define perceives(ptr)		(((ptr)->mflags1 & M1_SEE_INVIS) != 0L)
X#define can_teleport(ptr)	(((ptr)->mflags1 & M1_TPORT) != 0L)
X#define control_teleport(ptr)	(((ptr)->mflags1 & M1_TPORT_CONTROL) != 0L)
X#define is_armed(ptr)		attacktype(ptr, AT_WEAP)
X#define likes_gold(ptr) 	(((ptr)->mflags1 & M1_GREEDY) != 0L)
X#define likes_gems(ptr) 	(((ptr)->mflags1 & M1_JEWELS) != 0L)
X#define likes_objs(ptr) 	(((ptr)->mflags1 & M1_COLLECT) != 0L || \
X					is_armed(ptr))
X#define likes_magic(ptr)	(((ptr)->mflags1 & M1_MAGIC) != 0L)
X#define hides_under(ptr)	(((ptr)->mflags2 & M2_CONCEAL) != 0L)
X#define is_hider(ptr)		(((ptr)->mflags2 & M2_HIDE) != 0L)
X#ifdef POLYSELF
X#define polyok(ptr)		(((ptr)->mflags1 & M1_NOPOLY) == 0L)
X#endif /* POLYSELF */
X#define tunnels(ptr)		(((ptr)->mflags2 & M2_TUNNEL) != 0L)
X#define needspick(ptr)		(((ptr)->mflags2 & M2_NEEDPICK) != 0L)
X#define is_elf(ptr)		(((ptr)->mflags2 & M2_ELF) != 0L)
X#define is_dwarf(ptr)		(((ptr)->mflags2 & M2_DWARF) != 0L)
X#define is_giant(ptr)		(((ptr)->mflags2 & M2_GIANT) != 0L)
X#ifdef GOLEMS
X#define is_golem(ptr)		((ptr)->mlet == S_GOLEM)
X#endif /* GOLEMS */
X#define is_orc(ptr)		(((ptr)->mflags2 & M2_ORC) != 0L)
X#define is_human(ptr)		(((ptr)->mflags2 & M2_HUMAN) != 0L)
X#define is_demon(ptr)		(((ptr)->mflags2 & M2_DEMON) != 0L)
X#define is_mercenary(ptr)	(((ptr)->mflags2 & M2_MERC) != 0L)
X#define throws_rocks(ptr)	(((ptr)->mflags2 & M2_ROCKTHROW) != 0L)
X#define is_wanderer(ptr)	(((ptr)->mflags2 & M2_WANDER) != 0L)
X#define is_lord(ptr)		(((ptr)->mflags1 & M1_LORD) != 0L)
X#define is_prince(ptr)		(((ptr)->mflags1 & M1_PRINCE) != 0L)
X#ifdef HARD
X#define is_ndemon(ptr)		(is_demon(ptr) && \
X			 (((ptr)->mflags1 & (M1_LORD | M1_PRINCE)) == 0L))
X#else /* HARD */
X#define is_ndemon(ptr)		(ptr == &mons[PM_DEMON])
X#endif /* HARD */
X#define is_dlord(ptr)		(is_demon(ptr) && is_lord(ptr))
X#define is_dprince(ptr)		(is_demon(ptr) && is_prince(ptr))
X#define type_is_pname(ptr)	(((ptr)->mflags2 & M2_PNAME) != 0L)
X#define always_hostile(ptr)	(((ptr)->mflags2 & M2_HOSTILE) != 0L)
X#define always_peaceful(ptr)	(((ptr)->mflags2 & M2_PEACEFUL) != 0L)
X#define strongmonst(ptr)	(((ptr)->mflags2 & M2_STRONG) != 0L)
X#define extra_nasty(ptr)	(((ptr)->mflags2 & M2_NASTY) != 0L)
X#ifdef POLYSELF
X#define can_breathe(ptr)	attacktype(ptr, AT_BREA)
X#define cantwield(ptr)		(nohands(ptr) || verysmall(ptr))
X#define cantweararm(ptr)	(breakarm(ptr) || sliparm(ptr))
X#define nolimbs(ptr)		(((ptr)->mflags2 & M2_NOLIMBS) != 0L)
X#endif /* POLYSELF */
X#define carnivorous(ptr)	(((ptr)->mflags2 & M2_CARNIVORE) != 0L)
X#define herbivorous(ptr)	(((ptr)->mflags2 & M2_HERBIVORE) != 0L)
X#define thick_skinned(ptr)	(((ptr)->mflags2 & M2_THICK_HIDE) != 0L)
X#define amorphous(ptr)		(((ptr)->mflags2 & M2_AMORPHOUS) != 0L)
X
X# endif /* STUPID_CPP */
X
X#endif /* MONDATA_H */
END_OF_FILE
if test 4502 -ne `wc -c <'include/mondata.h'`; then
    echo shar: \"'include/mondata.h'\" unpacked with wrong size!
fi
# end of 'include/mondata.h'
fi
if test -f 'include/monflag.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/monflag.h'\"
else
echo shar: Extracting \"'include/monflag.h'\" \(4248 characters\)
sed "s/^X//" >'include/monflag.h' <<'END_OF_FILE'
X/*	SCCS Id: @(#)monflag.h	3.0	89/06/23
X/* NetHack may be freely redistributed.  See license for details. */
X/* Copyright (c) 1989 Mike Threepoint */
X
X#ifndef MONFLAG_H
X#define MONFLAG_H
X
X#define MS_SILENT	0	/* makes no sound */
X#define MS_SQEEK	1	/* squeaks, as a rodent */
X#define MS_SQAWK	2	/* squawks, as a bird */
X#define MS_HISS 	3	/* hisses */
X#define MS_BUZZ 	4	/* buzzes (killer bee) */
X#define MS_GRUNT	5	/* grunts (or speaks own language) */
X#define MS_GROWL	6	/* growls */
X#define MS_BARK 	7	/* if full moon, may howl */
X#define MS_MEW		8	/* mews or hisses */
X#define MS_ROAR 	9	/* roars */
X#define MS_NEIGH	10	/* neighs, as an equine */
X#define MS_WAIL 	11	/* wails, as a tortured soul */
X#define MS_GURGLE	12	/* gurgles, as liquid or through saliva */
X#define MS_SHRIEK	15	/* wakes up others */
X#define MS_IMITATE	18	/* imitates others (leocrotta) */
X#define MS_MUMBLE	19	/* says something or other */
X#define MS_SEDUCE	20	/* "Hello, sailor." (Nymphs) */
X#ifdef KOPS
X#define MS_ARREST	21	/* "Stop in the name of the law!" (Kops) */
X#endif
X#define MS_LAUGH	22	/* grins, smiles, giggles, and laughs */
X#define MS_JEER 	23	/* berates you */
X#ifdef HARD
X#define MS_BRIBE	24	/* asks for money, or berates you */
X#endif
X#define MS_CUSS 	25	/* really berates you (the Wiz) */
X#ifdef ORACLE
X#define MS_ORACLE	26	/* do a consultation */
X#endif
X#ifdef ALTARS
X#define MS_PRIEST	27	/* ask for contribution; do cleansing */
X#endif
X#define MS_GUARD	28	/* "Please drop that gold and follow me." */
X#define MS_NURSE	29	/* "Take off your shirt, please." */
X#define MS_SELL 	30	/* demand payment, complain about shoplifters */
X#define MS_DJINNI	31	/* "Thank you for freeing me!" */
X#ifdef ARMY
X#define MS_SOLDIER	32	/* army expressions */
X#endif
X#define MS_VAMPIRE	33	/* vampiric seduction, Vlad's exclamations */
X#define MS_HUMANOID	34	/* generic traveling companion */
X#define MS_ORC		MS_GRUNT	/* other intelligent brutes */
X
X#define M1_BIG		0x00000001L
X#define M1_VSMALL	0x00000002L
X#define M1_FLY		0x00000004L
X#define M1_SWIM		0x00000008L
X#define M1_WALLWALK	0x00000010L
X#define M1_ANIMAL	0x00000020L
X#define M1_HUMANOID	0x00000040L
X#define M1_UNDEAD	0x00000080L
X#define M1_WERE		0x00000100L
X#define M1_NOEYES	0x00000200L
X#define M1_NOHANDS	0x00000400L
X#define M1_NOPOLY	0x00000800L
X#define M1_EGGS		0x00001000L
X#define M1_POIS		0x00002000L
X#define M1_POIS_RES	0x00004000L
X#define M1_FIRE_RES	0x00008000L
X#define M1_COLD_RES	0x00010000L
X#define M1_ELEC_RES	0x00020000L
X#define M1_SLEE_RES	0x00040000L
X#define M1_STON_RES	0x00080000L
X#define M1_REGEN	0x00100000L
X#define M1_SEE_INVIS	0x00200000L
X#define M1_TPORT	0x00400000L
X#define M1_TPORT_CONTROL 0x00800000L
X#define M1_GREEDY	0x01000000L
X#define M1_JEWELS	0x02000000L
X#define M1_MAGIC	0x04000000L
X#define M1_COLLECT	0x08000000L
X#define M1_LORD		0x10000000L
X#define M1_PRINCE	0x20000000L
X#define M1_STALK	0x40000000L
X#define M1_FEM		0x80000000L
X
X#define M2_TUNNEL	0x00000001L	/* can tunnel through rock */
X#define M2_NEEDPICK	0x00000002L	/* needs pick to tunnel */
X#define M2_CONCEAL	0x00000004L	/* hides under objects */
X#define M2_HIDE 	0x00000008L	/* blends in with ceiling, &c. */
X#define M2_ELF		0x00000010L	/* is an elf */
X#define M2_DWARF	0x00000020L	/* is a dwarf */
X#define M2_GIANT	0x00000040L	/* is a giant */
X#define M2_ORC		0x00000080L	/* is an orc */
X#define M2_HUMAN	0x00000100L	/* is a human */
X#define M2_DEMON	0x00000200L	/* is a demon */
X#define M2_MERC 	0x00000400L	/* is a guard or soldier */
X#define M2_ROCKTHROW	0x00000800L	/* throws boulders */
X#define M2_WANDER	0x00001000L	/* wanders randomly */
X#define M2_PNAME	0x00002000L	/* monster name is a proper name */
X#define M2_HOSTILE	0x00004000L	/* always starts hostile */
X#define M2_PEACEFUL	0x00010000L	/* always starts peaceful */
X#define M2_STRONG	0x00020000L	/* strong (or big) monster */
X#define M2_NASTY	0x00040000L	/* extra-nasty monster (more xp) */
X#define M2_NOLIMBS	0x00080000L	/* no rings or kicking */
X#define M2_CARNIVORE	0x00100000L	/* eats corpses */
X#define M2_HERBIVORE	0x00200000L	/* eats fruits */
X#define M2_OMNIVORE	0x00300000L	/* eats both */
X#define M2_THICK_HIDE	0x01000000L	/* has thick hide or scales */
X#define M2_AMORPHOUS	0x02000000L	/* fluid; can slide under doors */
X
X#endif /* MONFLAG_H */
END_OF_FILE
if test 4248 -ne `wc -c <'include/monflag.h'`; then
    echo shar: \"'include/monflag.h'\" unpacked with wrong size!
fi
# end of 'include/monflag.h'
fi
if test -f 'include/system.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/system.h'\"
else
echo shar: Extracting \"'include/system.h'\" \(4557 characters\)
sed "s/^X//" >'include/system.h' <<'END_OF_FILE'
X/*	SCCS Id: @(#)system.h 3.0	88/10/10 */
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#ifndef SYSTEM_H
X#define SYSTEM_H
X
X#define E extern
X
X#ifdef AMIGA
X#define _SIZE_T
Xtypedef unsigned int	size_t;
X#else
X# include <sys/types.h>
X#endif
X
X#ifdef ULTRIX
X/* The Ultrix v3.0 <sys/types.h> seems to be very wrong. */
X#define off_t long
X#define time_t long
X#endif
X
X/* some old <sys/types.h> may not define off_t and size_t; if your system is
X * one of these, define them here
X */
X#ifdef MSDOS
X# ifndef _SIZE_T
X#define _SIZE_T
Xtypedef unsigned int	size_t;
X# endif
X# ifdef __TURBOC__
Xtypedef long  off_t;
X# endif
X#endif
X
X/* You may want to change this to fit your system, as this is almost
X * impossible to get right automatically.
X * This is the type of signal handling functions.
X */
X#if defined(__STDC__) || defined(ULTRIX)
X	/* also SVR3 and later, Sun4.0 and later */
X#define SIG_RET_TYPE void (*)()
X#else
X	/* BSD, SIII, SVR2 and earlier, Sun3.5 and earlier */
X#define SIG_RET_TYPE int (*)()
X#endif
X
X#if defined(BSD) || defined(ULTRIX) || defined(RANDOM)
XE long random();
XE void srandom P((unsigned int));
X#else
XE long lrand48();
XE void srand48();
X#endif /* BSD || ULTRIX || RANDOM */
X
X#if !defined(BSD) || defined(ultrix)
X			/* real BSD wants all these to return int */
X# ifndef MSDOS
XE void exit P((int));
X# endif /* MSDOS */
XE void free P((genericptr_t));
XE void perror P((const char *));
X#endif
X
X#if defined(BSD) || defined(ULTRIX)
XE int qsort();
X#else
XE void qsort P((genericptr_t,size_t,size_t,int(*)(genericptr_t,genericptr_t)));
X#endif
X
X#ifdef ULTRIX
XE long lseek P((int,off_t,int));
X  /* Ultrix 3.0 man page mistakenly says it returns an int. */
XE int write P((int,char *,int));
X#else
XE long lseek P((int,long,int));
XE int write P((int,genericptr_t,unsigned));
X#ifdef MSDOS
XE int close P((int));
XE int read P((int,genericptr_t,unsigned int));
XE int open P((const char *,int,...));
XE int dup2 P((int, int));
XE int setmode P((int,int));
XE int kbhit P((void));
X#endif
X#endif /* ULTRIX */
X
X#ifdef MSDOS
XE int chdir P((char *));
XE char *getcwd P((char *,int));
X#endif
X
X/* both old & new versions of Ultrix want these, but real BSD does not */
X#ifdef ultrix
XE void abort();
XE void bcopy();
X#endif
X#ifdef MSDOS
XE void abort P((void));
XE void _exit P((int));
XE int system P((const char *));
X#endif
X
X#ifdef SYSV
XE char *memcpy();
X#endif
X#ifdef MSDOS
XE int memcmp P((char *,char *,unsigned int));
XE char *memcpy P((char *,char *,unsigned int));
XE char *memset P((char*,int,int));
X#endif
X
X#if defined(BSD) && defined(ultrix)	/* i.e., old versions of Ultrix */
XE void sleep();
X#endif
X#if defined(ULTRIX) || defined(SYSV)
XE unsigned sleep();
X#endif
X
XE char *getenv P((const char *));
XE char *getlogin();
XE int getpid();
X
X/*# string(s).h #*/
X
XE char	*strcpy P((char *,const char *));
XE char	*strncpy P((char *,const char *,size_t));
XE char	*strcat P((char *,const char *));
XE char	*strncat P((char *,const char *,size_t));
X
X#if defined(SYSV) || defined(MSDOS)
XE char	*strchr P((const char *,int));
XE char	*strrchr P((const char *,int));
X#else /* BSD */
XE char	*index P((const char *,int));
XE char	*rindex P((const char *,int));
X#endif
X
X
XE int	strcmp P((const char *,const char *));
XE int	strncmp P((const char *,const char *,size_t));
X#ifdef MSDOS
XE size_t strlen P((const char *));
X#else
XE int	strlen();
X#endif
X
X/* Old varieties of BSD have char *sprintf().
X * Newer varieties of BSD have int sprintf() but allow for the old char *.
X * Several varieties of SYSV and PC systems also have int sprintf().
X * If your system doesn't agree with this breakdown, you may want to change
X * this declaration, especially if your machine treats the types differently.
X */
X#if defined(BSD) || defined(ULTRIX)
X#define OLD_SPRINTF
XE char *sprintf();
X#else
XE int sprintf P((char *,const char *,...));
X#endif
X
X#define Sprintf	(void) sprintf
X#define Strcat	(void) strcat
X#define Strcpy	(void) strcpy
X#define Printf  (void) printf
X
XE int tgetent P((char *,char *));
XE int tgetnum P((char *));
XE int tgetflag P((char *));
XE char *tgetstr P((char *,char **));
XE char *tgoto P((char *,int,int));
XE void tputs P((char *,int,int (*)()));
X
XE genericptr_t malloc P((size_t));
X
X/* time functions */
X
XE struct tm *localtime P((const time_t *));
X
X#if (defined(ULTRIX) || defined(SYSV) || defined(MSDOS)) && !defined(AMIGA)
XE time_t time P((time_t *));
X#else
XE long time P((time_t *));
X#endif /* ULTRIX */
X
X#ifdef MSDOS
XE int abs P((int));
XE int atoi P((char *));
X#endif
X
X#undef E
X
X#endif /* SYSTEM_H */
END_OF_FILE
if test 4557 -ne `wc -c <'include/system.h'`; then
    echo shar: \"'include/system.h'\" unpacked with wrong size!
fi
# end of 'include/system.h'
fi
if test -f 'others/termcap' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'others/termcap'\"
else
echo shar: Extracting \"'others/termcap'\" \(4611 characters\)
sed "s/^X//" >'others/termcap' <<'END_OF_FILE'
X#
X#	MS/PC-DOS ANSI.SYS termcap
X#
Xansi|color|ansi-color|ibm|ibmpc|ANSI.SYS color:\
X	:co#80:li#24:bs:pt:bl=^G:le=^H:do=^J:\
X	:cl=\E[H\E[2J:ce=\E[K:\
X	:ho=\E[H:cm=\E[%i%d;%dH:\
X	:up=\E[A:do=\E[B:le=\E[C:ri=\E[D:nd=\E[C:\
X	:ti=\E[0;44m:te=\E[0m:\
X	:so=\E[1;35;44m:se=\E[0;44m:\
X	:us=\E[1;31;44m:ue=\E[0;44m:\
X	:mb=\E[5m:md=\E[1m:me=\E[0;44m:
Xmono|ansi-mono|ANSI.SYS:\
X	:co#80:li#24:bs:pt:bl=^G:le=^H:do=^J:\
X	:cl=\E[H\E[2J:ce=\E[K:\
X	:ho=\E[H:cm=\E[%i%d;%dH:\
X	:up=\E[A:do=\E[B:le=\E[C:ri=\E[D:nd=\E[C:\
X	:so=\E[1m:se=\E[m:us=\E[4m:ue=\E[m:\
X	:mb=\E[5m:md=\E[1m:me=\E[m:
X#
X#	This is a termcap for NNANSI.SYS (New & Improved NANSI.SYS),
X#	a faster and more complete public domain replacement for
X#	ANSI.SYS, and two other ANSI.SYS replacements, NANSI.SYS and
X#	ZANSI.SYS.
X#
X#	NANSI and ZANSI support line insert (al) and delete (dl)
X#	and character insert (ic) and delete (dc) where ANSI.SYS
X#	does not.  NNANSI.SYS also supports clear to end of display
X#	(cd), does reverse video (mr) properly, and emulates SGR
X#	more fully, allowing correct end sequences for standout (se)
X#	and end of underline (ue).
X#
Xnnansi-mono|NNANSI.SYS:\
X	:co#80:li#25:bs:pt:bl=^G:le=^H:do=^J:\
X	:cl=\E[2J:cd=\E[J:ce=\E[K:\
X	:ho=\E[H:cm=\E[%i%d;%dH:\
X	:up=\E[A:do=\E[B:le=\E[C:ri=\E[D:nd=\E[C:\
X	:so=\E[1m:se=\E[2m:\
X	:us=\E[4m:ue=\E[24m:\
X	:mb=\E[5m:md=\E[1m:mh=\E[2m:mr=\E[7m:me=\E[m:\
X	:al=\E[L:dl=\E[M:ic=\E[@:dc=\E[P:
Xnnansi|NNANSI.SYS color:\
X	:co#80:li#25:bs:pt:bl=^G:le=^H:do=^J:\
X	:cl=\E[2J:cd=\E[J:ce=\E[K:\
X	:ho=\E[H:cm=\E[%i%d;%dH:\
X	:up=\E[A:do=\E[B:le=\E[C:ri=\E[D:nd=\E[C:\
X	:ti=\E[0;44m:te=\E[0m:\
X	:so=\E[1;35;44m:se=\E[2;37m:\
X	:us=\E[4m:ue=\E[24m:\
X	:mb=\E[5m:md=\E[1m:mh=\E[2m:mr=\E[7m:me=\E[0;44m:\
X	:al=\E[L:dl=\E[M:ic=\E[@:dc=\E[P:
Xnansi-mono|zansi-mono|N/ZANSI.SYS:\
X	:co#80:li#25:bs:pt:bl=^G:le=^H:do=^J:\
X	:cl=\E[2J:ce=\E[K:\
X	:ho=\E[H:cm=\E[%i%d;%dH:\
X	:up=\E[A:do=\E[B:le=\E[C:ri=\E[D:nd=\E[C:\
X	:ti=\E[0m:te=\E[0m:\
X	:so=\E[1;35m:se=\E[0m:\
X	:us=\E[1;31m:ue=\E[0m:\
X	:mb=\E[5m:md=\E[1m:mr=\E[7m:me=\E[m:\
X	:al=\E[L:dl=\E[M:ic=\E[@:dc=\E[P:
Xnansi|zansi|N/ZANSI.SYS color:\
X	:co#80:li#25:bs:pt:bl=^G:le=^H:do=^J:\
X	:cl=\E[2J:ce=\E[K:\
X	:ho=\E[H:cm=\E[%i%d;%dH:\
X	:up=\E[A:do=\E[B:le=\E[C:ri=\E[D:nd=\E[C:\
X	:ti=\E[0;44m:te=\E[0m:\
X	:so=\E[1;35;44m:se=\E[0;44m:\
X	:us=\E[1;31;44m:ue=\E[0;44m:\
X	:mb=\E[5m:md=\E[1m:mr=\E[7m:me=\E[0;44m:\
X	:al=\E[L:dl=\E[M:ic=\E[@:dc=\E[P:
X#
X# For ST NetHack:
X#
Xvt52|atari|DEC VT52:\
X	:co#80:li#24:bs:pt:bl=^G:le=^H:do=^J:\
X	:cl=\EH\EJ:ce=\EK:cd=\EJ:\
X	:ho=\EH:cm=\EY%+ %+ :\
X	:up=\EA:do=\EB:le=\EC:ri=\ED:nd=\EC:\
X	:ku=\EA:kd=\EB:kl=\EC:kr=\ED:kb=^H:\
X	:sr=\EI:as=\EF:ae=\EG:
X#
X# For Amiga NetHack:
X#
Xvt100|amiga|DEC VT100:\
X	:co#80:li#24:bs:pt:am:mi:bl=^G:le=^H:do=^J:xo:vt#3:\
X	:cl=50\EH\E[J:ce=3\E[K:cd=50\E[J:\
X	:ho=\E[H:cm=5\E[%i%d;%dH:cs=\E[%i%d;%dr:\
X	:up=\E[A:do=\E[B:le=\E[C:ri=\E[D:nd=\E[C:\
X	:UP=\E[%dA:DO=\E[%dB:LE=\E[%dC:RI=\E[%dD:\
X	:so=2\E[7m:se=2\E[m:us=2\E[4m:ue=2\E[m:\
X	:mb=2\E[5m:md=2\E[1m:mr=2\E[7m:me=2\E[m:\
X	:ti=4\E(B\E)0:as=^N:ae=^O:\
X	:ks=\E[?1h\E=:ke=\E[?11\E>:ku=\E[A:kd=\E[B:kl=\E[C:kr=\E[D:kb=^H:\
X	:kn#4:k1=\EOP:k2=\EOQ:k3=\EOR:k4=\EOS:\
X	:sc=\E7:ec=\E8:sr=5\EM:
X#
X# VT102 (or higher) emulators can add:
X#	:im=\E[4h:ei=\E[4l:al=\E[L:dl=\E[M:dc=\E[P:
X#
X#
X# For really complete ANSI emulations (FANSI-CONSOLE?):
X#
XAX|ANSI X3.64|full ANSI X3.64 (1977) standard:\
X	:co#80:li#24:bs:pt:am:mi:bl=^G:le=^H:\
X	:cl=\E[2J:ce=\E[K:cd=\E[J:\
X	:ho=\E[H:cm=\E[%i%d;%dH:cs=\E[%i%d;%dr:\
X	:up=\E[A:do=\E[B:le=\E[C:ri=\E[D:nd=\E[C:\
X	:UP=\E[%dA:DO=\E[%dB:LE=\E[%dC:RI=\E[%dD:\
X	:so=\E[7m:se=\E[m:us=\E[4m:ue=\E[m:\
X	:mb=\E[5m:md=\E[1m:mr=\E[7m:me=\E[m:as=^N:ae=^O:\
X	:ku=\E[A:kd=\E[B:kl=\E[C:kr=\E[D:kb=^H:\
X	:kn#4:k1=\EOP:k2=\EOQ:k3=\EOR:k4=\EOS:\
X	:im=\E[4h:ei=\E[4l:al=\E[L:dl=\E[M:ic=\E[@:dc=\E[P:sf=\ED:sr=\EM:
X#
X# Display hacker's tool
X#
Xdebug|debugging entry:\
X	:ae=<ae>:AL=<AL%d>:al=<al>:am:as=<as>:bl=<bl>:bs:bt=<bt>:bw:CC=<CC>:\
X	:cd=<cd>:ce=<ce>:ch=<ch%d>:cl=<cl>:cm=<cm%d,%d>:co#80:cr=<cr>:\
X	:cs=<cs%d,%d>:ct=<ct>:cv=<cv%d>:da:db:DC=<DC%d>:dc=<dc>:DL=<DL%d>:\
X	:dl=<dl>:dm=<dm>:DO=<DO%d>:do=<do>:ds=<ds>:ec=<ec%d>:ed=<ed>:ei=<ei>:\
X	:es:fs=<fs>:ho=<ho>:hs:IC=<IC%d>:ic=<ic>:im=<im>:ip=<ip>:is=<is>:\
X	:it#8:ke=<ke>:LE=<LE%d>:le=<le>:li#24:ll=<ll>:mb=<mb>:md=<md>:me=<me>:\
X	:mh=<mh>:mi:mk=<mk>:mm=<mm>:mo=<mo>:mp=<mp>:mr=<mr>:ms=<ms>:nd=<nd>:\
X	:nw=<nw>:pc=<pc>:pf=<pf>:pO=<pO%d>:po=<po>:ps=<ps>:rc=<rc>:RI=<RI%d>:\
X	:rp=<rp%.%d>:rs=<rs>:sc=<sc>:se=<se>:SF=<SF%d>:sf=<sf>:so=<so>:\
X	:SR=<SR%d>:sr=<sr>:st=<st>:ta=<ta>:te=<te>:ti=<ti>:uc=<uc>:ue=<ue>:\
X	:UP=<UP%d>:up=<up>:us=<us>:vb=<vb>:ve=<ve>:vi=<vi>:vs=<vs>:
X#
Xdumb:\
X	:am:bl=^G:co#80:do=^J:nl=^M^J:
END_OF_FILE
if test 4611 -ne `wc -c <'others/termcap'`; then
    echo shar: \"'others/termcap'\" unpacked with wrong size!
fi
# end of 'others/termcap'
fi
if test -f 'src/demon.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/demon.c'\"
else
echo shar: Extracting \"'src/demon.c'\" \(3669 characters\)
sed "s/^X//" >'src/demon.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)demon.c	3.0	88/11/14
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include	"hack.h"
X
Xvoid
Xdsummon(ptr)		/* summon demon */
X	register struct permonst *ptr;
X{
X	register int dtype, cnt = 0;
X
X	if(is_dprince(ptr) || (ptr == &mons[PM_WIZARD_OF_YENDOR])) {
X
X	    dtype = (!rn2(20)) ? dprince() : (!rn2(4)) ? dlord() : ndemon();
X	    cnt = (!rn2(4) && !is_dprince(&mons[dtype])) ? 2 : 1;
X
X	} else if(is_dlord(ptr)) {
X
X	    dtype = (!rn2(50)) ? dprince() : (!rn2(20)) ? dlord() : ndemon();
X	    cnt = (!rn2(4) && is_ndemon(&mons[dtype])) ? 2 : 1;
X
X	} else if(is_ndemon(ptr)) {
X
X	    dtype = (!rn2(20)) ? dlord() : ndemon();
X	    cnt = 1;
X	}
X
X	if(!dtype) return;
X
X	while(cnt > 0) {
X
X	    (void)makemon(&mons[dtype], u.ux, u.uy);
X	    cnt--;
X	}
X	return;
X}
X
X#ifdef HARD
X#define	Athome	(Inhell && !mtmp->cham)
X
Xint
Xdemon_talk(mtmp)		/* returns 1 if he won't attack. */
Xregister struct monst *mtmp;
X{
X	char	*x_monnam(), *Xmonnam();
X	long	demand, offer;
X
X#ifdef NAMED_ITEMS
X	if(uwep && is_artifact(uwep) && !strcmp(ONAME(uwep), "Excalibur")) {
X
X	    pline("%s looks very angry.", Xmonnam(mtmp));
X	    return mtmp->mpeaceful = mtmp->mtame = 0;
X	}
X#endif /* NAMED_ITEMS */
X
X	if(is_ndemon(mtmp->data)) {  /* not for regular '&'s */
X
X	    pline("%s mutters something about awful working conditions.",
X		  Xmonnam(mtmp));
X	    return(0);
X	}
X
X	/* Slight advantage given. */
X	if(is_dprince(mtmp->data) && mtmp->minvis) {
X	    mtmp->minvis = 0;
X	    if (!Blind) pline("%s appears before you.", Xmonnam(mtmp));
X	    pmon(mtmp);
X	}
X	if(u.usym == S_DEMON) {	/* Won't blackmail their own. */
X
X	    pline("%s says, \"Good hunting %s.\" and vanishes.",
X		  Xmonnam(mtmp), flags.female ? "Sister" : "Brother");
X	    rloc(mtmp);
X	    return(1);
X	}
X	demand = (u.ugold * (rnd(80) + 20 * Athome)) / 100;
X	if(!demand)  		/* you have no gold */
X	    return mtmp->mpeaceful = 0;
X	else {
X
X	    pline("%s demands %ld Zorkmids for safe passage.",
X		  Xmonnam(mtmp), demand);
X
X	    if((offer = bribe(mtmp)) >= demand) {
X		pline("%s vanishes laughing about cowardly mortals.",
X		      Xmonnam(mtmp));
X	    } else {
X		if((long)rnd(40) > (demand - offer)) {
X		    pline("%s scowls at you menacingly, then vanishes.",
X			  Xmonnam(mtmp));
X		} else {
X		    pline("%s gets angry...", Xmonnam(mtmp));
X		    return mtmp->mpeaceful = 0;
X		}
X	    }
X	}
X	mongone(mtmp);
X	return(1);
X}
X#endif
X
X#if defined(HARD) || (defined(ALTARS) && defined(SOUNDS))
Xlong
Xbribe(mtmp)
X
X	struct monst *mtmp;
X{
X	char buf[80];
X	long offer;
X
X	pline("How much will you offer? ");
X	getlin(buf);
X	(void) sscanf(buf, "%ld", &offer);
X
X/*Michael Paddon -- fix for negative offer to monster*/	/*JAR880815 - */
X 	if(offer < 0L) {
X 		You("try to shortchange %s, but fumble.", 
X 			x_monnam(mtmp, 0));
X 		offer = 0L;
X 	} else if(offer >= u.ugold) {
X		You("give %s all your gold.", x_monnam(mtmp, 0));
X		offer = u.ugold;
X	} else You("give %s %ld Zorkmids.", x_monnam(mtmp, 0), offer);
X
X	u.ugold -= offer;
X	return(offer);
X}
X#endif
X
Xint
Xdprince() {
X#ifdef HARD
X	int	tryct;
X	struct	permonst *ptr;
X
X	for(tryct = 0; tryct < 20; tryct++)
X	    if(is_dprince((ptr = mkclass(S_DEMON))))
X		return(monsndx(ptr));
X
X#endif
X	return(dlord());
X}
X
Xint
Xdlord() {
X#ifdef HARD
X	int	tryct;
X	struct	permonst *ptr;
X
X	for(tryct = 0; tryct < 20; tryct++)
X	    if(is_dlord((ptr = mkclass(S_DEMON))))
X		return(monsndx(ptr));
X
X#endif
X	return(ndemon());
X}
X
Xint
Xndemon() {
X#ifndef HARD
X	return(PM_DEMON);
X#else
X	int	tryct;
X	struct	permonst *ptr;
X
X	for(tryct = 0; tryct < 20; tryct++)
X	    if(is_ndemon((ptr = mkclass(S_DEMON))))
X		return(monsndx(ptr));
X
X	return(0);
X#endif
X}
END_OF_FILE
if test 3669 -ne `wc -c <'src/demon.c'`; then
    echo shar: \"'src/demon.c'\" unpacked with wrong size!
fi
# end of 'src/demon.c'
fi
if test -f 'src/worn.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/worn.c'\"
else
echo shar: Extracting \"'src/worn.c'\" \(4329 characters\)
sed "s/^X//" >'src/worn.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)worn.c	3.0	88/12/23
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include "hack.h"
X
Xstatic const char crispy[] = "The flames of Hell burn you to a crisp.";
Xstatic void set_armor_intrinsic P((struct obj *,boolean));
X
Xconst struct worn {
X	long w_mask;
X	struct obj **w_obj;
X} worn[] = {
X	{ W_ARM, &uarm },
X	{ W_ARMC, &uarmc },
X	{ W_ARMH, &uarmh },
X	{ W_ARMS, &uarms },
X	{ W_ARMG, &uarmg },
X	{ W_ARMF, &uarmf },
X#ifdef SHIRT
X	{ W_ARMU, &uarmu },
X#endif
X	{ W_RINGL, &uleft },
X	{ W_RINGR, &uright },
X	{ W_WEP, &uwep },
X	{ W_AMUL, &uamul },
X	{ W_TOOL, &ublindf },
X	{ W_BALL, &uball },
X	{ W_CHAIN, &uchain },
X	{ 0, 0 }
X};
X
Xvoid
Xsetworn(obj, mask)
Xregister struct obj *obj;
Xlong mask;
X{
X	register struct worn *wp;
X	register struct obj *oobj;
X
X	for(wp = worn; wp->w_mask; wp++) if(wp->w_mask & mask) {
X		oobj = *(wp->w_obj);
X		if(oobj && !(oobj->owornmask & wp->w_mask))
X			impossible("Setworn: mask = %ld.", wp->w_mask);
X		if(oobj) {
X		    oobj->owornmask &= ~wp->w_mask;
X		    /* leave as "x = x <op> y", here and below, for broken
X		     * compilers */
X		    u.uprops[objects[oobj->otyp].oc_oprop].p_flgs = 
X			    u.uprops[objects[oobj->otyp].oc_oprop].p_flgs & 
X				~wp->w_mask;
X		    set_armor_intrinsic(oobj, 0);
X		}
X		*(wp->w_obj) = obj;
X		if(obj) {
X		    obj->owornmask |= wp->w_mask;
X		    u.uprops[objects[obj->otyp].oc_oprop].p_flgs = 
X			    u.uprops[objects[obj->otyp].oc_oprop].p_flgs | 
X				wp->w_mask;
X		    set_armor_intrinsic(obj, 1);
X		}
X	}
X	/* A kludge to solve the problem of someone gaining fire resistance
X	 * only from an item, then entering Hell and removing/unwielding it.
X	 * Checking this every time setworn gets called is a bit of an
X	 * overkill. --KAA
X	 */
X	if (Inhell && !Fire_resistance) {
X		pline(crispy);
X		killer = "loss of fire protection";
X		done("burned");
X		/* If we're here they survived with life saving, so put the
X		 * weapon they just unwielded back in their hands...
X		 */
X		if (oobj->otyp != DRAGON_SCALE_MAIL
X				&& oobj->otyp != RIN_FIRE_RESISTANCE
X#ifdef NAMED_ITEMS
X				&& !defends(AD_FIRE, oobj)
X#endif
X				&& oobj->corpsenm != PM_RED_DRAGON)
X			impossible("lost FR from a non-FR item?");
X		setworn(oobj, mask);
X	}
X}
X
X/* called e.g. when obj is destroyed */
Xvoid
Xsetnotworn(obj)
Xregister struct obj *obj;
X{
X	register struct worn *wp;
X
X	if (!obj) return;
X	for(wp = worn; wp->w_mask; wp++)
X		if(obj == *(wp->w_obj)) {
X			*(wp->w_obj) = 0;
X			u.uprops[objects[obj->otyp].oc_oprop].p_flgs = 
X				u.uprops[objects[obj->otyp].oc_oprop].p_flgs & 
X					~wp->w_mask;
X			obj->owornmask &= ~wp->w_mask;
X			set_armor_intrinsic(obj, 0);
X		}
X	/* See comments above in setworn().  The major difference is the
X	 * need to check AMULET_SYM so if someone goes to Hell without
X	 * being fire resistant, then dies, when their amulet saves them
X	 * and disintegrates this code will not be triggered. --KAA
X	 */
X	if (Inhell && !Fire_resistance && obj->olet != AMULET_SYM) {
X		pline(crispy);
X		killer = "loss of fire protection";
X		done("burned");
X		/* Survived with lifesaving, etc...; there's no general way
X		 * to undo the setnotworn()--we can't re-wear/wield the
X		 * item since it might have been stolen, disintegrated, etc....
X		 */
X#if defined(WIZARD) || defined(EXPLORE_MODE)
X		while(1) {
X			/* keep doing it until they finally decide they really
X			 * _do_ want to die, since we can't possibly continue
X			 * the game from this point...
X			 */
X#endif
X			You("are still burning and die again...");
X			done("burned");
X#if defined(WIZARD) || defined(EXPLORE_MODE)
X		}
X#endif
X	}
X}
X
Xstatic void
Xset_armor_intrinsic(obj,on)
Xregister struct obj *obj;
Xboolean on;
X{
X	long *mask;
X
X	if (obj->otyp != DRAGON_SCALE_MAIL) return;
X	switch(obj->corpsenm) {
X		case PM_GREY_DRAGON:
X			mask = &Antimagic;
X			break;
X		case PM_RED_DRAGON:
X			mask = &HFire_resistance;
X			break;
X		case PM_WHITE_DRAGON:
X			mask = &HCold_resistance;
X			break;
X		case PM_BLUE_DRAGON:
X			mask = &HShock_resistance;
X			break;
X		case PM_GREEN_DRAGON:
X			mask = &HPoison_resistance;
X			break;
X		case PM_ORANGE_DRAGON:
X			mask = &HSleep_resistance;
X			break;
X		case PM_BLACK_DRAGON:
X			mask = &HDisint_resistance;
X			break;
X		case PM_YELLOW_DRAGON:
X		default:
X			return;
X	}
X	if (on) *mask |= WORN_ARMOR;
X	else *mask &= ~WORN_ARMOR;
X}
END_OF_FILE
if test 4329 -ne `wc -c <'src/worn.c'`; then
    echo shar: \"'src/worn.c'\" unpacked with wrong size!
fi
# end of 'src/worn.c'
fi
if test -f 'src/write.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/write.c'\"
else
echo shar: Extracting \"'src/write.c'\" \(3562 characters\)
sed "s/^X//" >'src/write.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)write.c	3.0	89/01/10
X */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include "hack.h"
X
X/*
X * returns basecost of a scroll
X */
Xstatic int
Xcost(scroll)
Xregister struct obj *scroll;
X{
X	switch(scroll->otyp)  {
X# ifdef MAIL
X	case SCR_MAIL:
X		return(2);
X/*		break; */
X# endif
X	case SCR_LIGHT:
X	case SCR_GOLD_DETECTION:
X	case SCR_FOOD_DETECTION:
X	case SCR_MAGIC_MAPPING:
X	case SCR_AMNESIA:
X	case SCR_FIRE:
X		return(8);
X/*		break; */
X	case SCR_DESTROY_ARMOR:
X	case SCR_CREATE_MONSTER:
X	case SCR_PUNISHMENT:
X		return(10);
X/*		break; */
X	case SCR_CONFUSE_MONSTER:
X		return(12);
X/*		break; */
X	case SCR_IDENTIFY:
X		return(14);
X/*		break; */
X	case SCR_ENCHANT_ARMOR:
X	case SCR_REMOVE_CURSE:
X	case SCR_ENCHANT_WEAPON:
X		return(16);
X/*		break; */
X	case SCR_SCARE_MONSTER:
X	case SCR_TAMING:
X	case SCR_TELEPORTATION:
X		return(20);
X/*		break; */
X	case SCR_GENOCIDE:
X		return(30);
X/*		break; */
X	case SCR_BLANK_PAPER:
X	default:
X		impossible("You can't write such a weird scroll!");
X	}
X	return(1000);
X}
X
Xstatic const char write_on[] = { SCROLL_SYM, 0 };
X
Xvoid
Xdowrite(pen)
Xregister struct obj *pen;
X{
X	register struct obj *paper;
X	char namebuf[BUFSZ], scrbuf[BUFSZ];
X	register struct obj *newscroll;
X	int basecost, actualcost;
X	int newquan;
X	int curseval;
X	
X	if(!pen)
X		return;
X	if(pen->otyp != MAGIC_MARKER)  {
X		You("can't write with that!");
X		return;
X	}
X	
X	/* get paper to write on */
X	paper = getobj(write_on,"write on");
X	if(!paper)
X		return;
X	if(!(objects[paper->otyp].oc_name_known))  {
X		pline("In your haste, you rip the scroll to pieces.");
X		useup(paper);
X		return;
X	}
X	if(paper->otyp != SCR_BLANK_PAPER)  {
X		You("fool, that scroll's not blank!");
X		return;
X	}
X	
X	/* what to write */
X	pline("What type of scroll do you want to write? ");
X	getlin(namebuf);
X	if(namebuf[0] == '\033' || !namebuf[0])
X		return;
X	Strcpy(scrbuf,"scroll of ");
X	Strcat(scrbuf,namebuf);
X	newscroll = readobjnam(scrbuf);
X
X	newscroll->bknown = (paper->bknown && pen->bknown);
X	/* do this now, before we useup() the paper */
X
X	if(newscroll->olet != SCROLL_SYM ||
X	   newscroll->otyp == SCR_BLANK_PAPER)  {
X		You("can't write that!");
X		pline("It's obscene!");
X		return;
X	}
X	
X	/* see if there's enough ink */
X	basecost = cost(newscroll);
X	if(pen->spe < basecost/2)  {
X		Your("marker is too dry to write that!");
X		obfree(newscroll, (struct obj *) 0);
X		return;
X	}
X	
X	/* we're really going to write now, so calculate
X	 * cost and useup old scroll
X	 */
X	actualcost = rn1(basecost/2,basecost/2);
X	curseval = bcsign(pen) + bcsign(paper);
X	useup(paper);
X	
X	/* dry out marker */
X	if(pen->spe < actualcost)  {
X		Your("marker dries out!");
X		pline("The scroll is now useless and disappears!");
X		pen->spe = 0;
X		obfree(newscroll, (struct obj *) 0);
X		return;
X	}
X	pen->spe -= actualcost;
X	
X	/* can't write if we don't know it - unless we're lucky */
X	if(!(objects[newscroll->otyp].oc_name_known) && 
X	   !(objects[newscroll->otyp].oc_uname) && 
X	   (rnl(pl_character[0] == 'W' ? 3 : 15))) {
X		You("don't know how to write that!");
X		You("write \"%s was here!\" and the scroll disappears.",
X			plname);
X		obfree(newscroll, (struct obj *) 0);
X		return;
X	}
X	
X	/* and now you know it! */
X	makeknown(newscroll->otyp);
X	
X	/* success - don't forget to fool prinv() */
X	newscroll = addinv(newscroll);
X	newquan = newscroll->quan;
X	newscroll->quan = 1;
X	newscroll->blessed = (curseval > 0);
X	newscroll->cursed = (curseval < 0);
X	prinv(newscroll);
X	newscroll->quan = newquan;
X#ifdef MAIL
X	if (newscroll->otyp == SCR_MAIL) newscroll->spe = 1;
X#endif
X	newscroll->known = 1;
X}
END_OF_FILE
if test 3562 -ne `wc -c <'src/write.c'`; then
    echo shar: \"'src/write.c'\" unpacked with wrong size!
fi
# end of 'src/write.c'
fi
echo shar: End of archive 35 \(of 38\).
cp /dev/null ark35isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 38 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
