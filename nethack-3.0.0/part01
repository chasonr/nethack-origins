Path: utzoo!utgpu!jarvis.csri.toronto.edu!mailrus!csd4.milw.wisc.edu!cs.utexas.edu!uunet!zephyr.ens.tek.com!tektronix!tekgen!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v07i056:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Part01/38
Message-ID: <4310@tekred.CNA.TEK.COM>
Date: 24 Jul 89 04:47:23 GMT
Sender: nobody@tekred.CNA.TEK.COM
Lines: 1752
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 7, Issue 56
Archive-name: NetHack3/Part01

	[Part38 should be unpacked last to concatenate the two halves
	 of monst.c together. Other than that the archives may be
	 unpacked in any order.	-br]

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 38)."
# Contents:  README MANIFEST amiga auxil include include/osbind.h
#   others src src/lev_comp.c
# Wrapped by billr@saab on Sun Jul 23 21:32:45 1989
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(6172 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
X
X		NetHack 3.0 -- General information
X
XNetHack 3.0 is a new generation of the dungeon exploration game NetHack.
XIt is a distant descendent of Hack, and a direct descendent of NetHack 2.3.
XIt is the product of a year-long, very intensive, international team
Xeffort.  Many parts of 2.3 were rewritten for NetHack 3.0, and many new
Xfeatures were added.  Judged by size alone, with all options enabled,
XNetHack 3.0 is twice as big as 2.3.
X
XWhile aiming at retaining the general atmosphere of NetHack 2.3, we sought
Xto open up new directions of development for the game.  Alignment, both for
Xplayer characters and for monsters, was introduced.  Player character
Xattributes were added and integrated into the game.  Special compiled
Xlevels were added, and these open up endless future possibilities.  An
Xendgame was written, for a climactic ending.  The code for monsters and
Xobjects was massively rewritten, and many new creatures and items were
Xadded.  The self-polymorph code was debugged and greatly enriched.  Shops,
Xtoo, were enhanced.  There are now doors in doorways and chests that may
Xcontain valuables, both of which may be closed or locked.  New commands to
Xopen or kick doors and force locks on chests were added.  You can also use
Xkicking as an attack mode, and you can kick objects around if it pleases
Xyou.  You will discover the rest for yourselves...
X
XTo compensate for the massive additions, we rewrote the code around some
Xnew map fields for an increase in speed up to, if not beyond, that of 2.3.
XThe code is now organized, and nearly lint-free.
X
XWe dedicate the game to the many unknown hackers, both past and future, who
Xcontribute so much to the game.
X
X			- - - - - - - - - - -
X
XPlease read items (1), (2) and (3) BEFORE doing anything with your new code.
X
X1.  Unpack the code in a dedicated new directory.  We will refer to that
X    directory as the 'Top' directory.  It makes no difference what you
X    call it.
X
X2.  If there is no flaw in the packaging, FIVE sub-directories will be
X    automatically created, and files will be deposited in them: 
X
X    a.  A 'src' directory, which will contain general *.c files.
X    b.  An 'include' directory, which will contain general *.h files.
X    c.  An 'auxil' directory, which will contain a variety of data files.
X    d.  An 'amiga' directory, which will contain the Amiga-specific files.
X    e.  An 'others' directory, which will contain MSDOS and TOS files.
X
X    The names of these directories should not be changed, unless you are
X    ready to go through the makefiles and the makedefs program and change
X    all the directory references in them.
X
X3.  Having unpacked, you should have a file called 'Files' in your Top
X    directory.  This file contains the list of all the files you now SHOULD 
X    have in each directory.  Please check the files in each directory 
X    against this list to make sure that you have a complete set.
X
X4.  Before you do anything else, please read carefully the file called
X    'license' in the auxil subdirectory.  It is expected that you comply
X    with the terms of that license, and we are very serious about it.  In
X    particular, you are prohibited by the terms of the license from using
X    NetHack 3.0 for gainful purposes.   
X
X5.  If everything is in order, you can now turn to trying to get the program
X    to compile and run on your particular system.  It is worth mentioning
X    that the default configuration is Ultrix (simply because the code was
X    housed on such a system).  It is also worth mentioning here that NetHack
X    3.0 is a huge program by comparison with 2.3.  If you intend to run it
X    on a small machine, you'll have to make hard choices among the options
X    available in config.h.
X
X    The files Install.* were written to guide you in configuring the program
X    for your operating system.  Reading them, and the man page, should answer
X    most of your questions.
X
X    At the time of this release, NetHack 3.0 is known to run on:
X
X	DEC vaxen running Ultrix and BSD
X	Sun-3s running SunOS 4.0
X	Encore Multimax running UMAX 4.2
X	Bull XPS100 running System V R2.2 or R3.1
X	AT&T 3B4000 running System V
X	AT&T 3B1 running System V (3.51)
X	286 box running Microport SysV/AT (not extensively tested)
X	IBM PC compatibles running MicroSoft C or Turbo C under MS-DOS
X	Commodore Amiga (probably -- there have been some changes since
X		the Amiga port was done, but we believe it should still work)
X
X    There are also many hooks for an Atari TOS port, but we have not had a
X    chance to test the 3.0 code on an Atari.  Undoubtedly, some tweaks will 
X    have to be made.
X
X			- - - - - - - - - - -
X
XIf you have problems building the game, or you find bugs in it, the 
Xdevelopment team may be reached as
X 
X		    nethack-bugs@linc.cis.upenn.edu.  
X
XPatches especially should be directed to this address.  If you've changed 
Xsomething to get NetHack to run on your system, it's likely that others have
Xdone it by making slightly different modifications.  By routing your patches
Xthrough the development team, we should be able to avoid making everyone else
Xchoose among variant patches claiming to do the same thing, to keep most of
Xthe copies of 3.0 synchronized by means of official patches, and to maintain
Xthe painfully-created file organization.  (Remember the mess when everybody
Xjust posted their own patches to 2.3?  There were no archived bug-fixes to
Xgive people who got 2.3 after its initial release, so the same bugs kept being
Xdiscovered by new batches of people.  Please cooperate to keep this from
Xhappening to 3.0.)
X
XIt is inevitable that we will reject some proposed additions of new features
Xeither because they do not fit our conception of the game, or because they 
Xrequire more code than we consider they're worth.  If we reject your feature,
Xyou are free, of course, to post the patches to the net yourself and let the
Xmarketplace decide its worth.
X
XAll of this amounts to the following:  If you decide to apply a free-lanced
Xpatch to your 3.0 code, you are on your own.  In our own patches, including
Xthose which will update to 3.1, we will assume that your code is synchronized
Xwith ours.
X
X		  -- Good luck, and happy Hacking --
X
END_OF_FILE
if test 6172 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
echo shar: Extracting \"'MANIFEST'\" \(6314 characters\)
sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X Files                     36	
X Install.dos               24	
X Install.unix              35	
X MANIFEST                   1	This shipping list
X Makefile.top              37	
X Porting                   34	
X README                     1	
X amiga                      1	
X amiga/Install.ami         34	
X amiga/Makefile.ami        29	
X amiga/NetHack.cnf         37	
X amiga/ami.lnk              3	
X amiga/amidos.c            22	
X amiga/amifont.uu          38	
X amiga/amifont8.uu         36	
X amiga/amimenu.c           33	
X amiga/amitcap.c           35	
X amiga/amitty.c            37	
X amiga/amiunix.c           36	
X amiga/amiwind.c           25	
X amiga/fcntl.h             38	
X amiga/signal.h            11	
X amiga/stdio.h             15	
X auxil                      1	
X auxil/Guidebook.mn         4	
X auxil/Makefile.auxil      38	
X auxil/castle.des          32	
X auxil/cmdhelp             36	
X auxil/data.base            6	
X auxil/endgame.des         36	
X auxil/help                33	
X auxil/hh                  16	
X auxil/history             37	
X auxil/lev_comp.6          35	
X auxil/license             34	
X auxil/nethack.6           34	
X auxil/nethack.sh          10	
X auxil/opthelp             36	
X auxil/oracles             35	
X auxil/rumors.fal          31	
X auxil/rumors.tru          31	
X auxil/tower.des           36	
X include                    1	
X include/amiconf.h         37	
X include/artifact.h        37	
X include/attrib.h          20	
X include/config.h          32	
X include/coord.h           14	
X include/decl.h            34	
X include/edog.h            37	
X include/epri.h            37	
X include/eshk.h            37	
X include/extern.h          17	
X include/flag.h            37	
X include/func_tab.h        30	
X include/global.h          35	
X include/gold.h            38	
X include/hack.h            37	
X include/lev.h             38	
X include/lev_comp.h        37	
X include/mfndpos.h         37	
X include/mkroom.h          22	
X include/monattk.h         36	
X include/mondata.h         35	
X include/monflag.h         35	
X include/monst.h           36	
X include/monsym.h          37	
X include/msdos.h           37	
X include/obj.h             36	
X include/objclass.h        32	
X include/osbind.h           1	
X include/patchlevel.h      19	
X include/pcconf.h          33	
X include/permonst.h        37	
X include/prop.h            37	
X include/rm.h              33	
X include/sp_lev.h          37	
X include/spell.h           38	
X include/system.h          35	
X include/tosconf.h         37	
X include/tradstdc.h        37	
X include/trap.h            37	
X include/trapname.h        37	
X include/unixconf.h        36	
X include/vault.h           37	
X include/wseg.h            37	
X include/you.h             17	
X include/youprop.h         34	
X others                     1	
X others/Make.ini           37	
X others/Makefile.pc        31	
X others/Makefile.tcc        4	
X others/Maketcc.ini        36	
X others/NetHack.cnf        36	
X others/msdos.c            22	
X others/pcmain.c           27	
X others/pctty.c            37	
X others/pcunix.c           36	
X others/random.c           26	
X others/termcap            35	
X others/tos.c              22	
X src                        1	
X src/Makefile.src          23	
X src/alloc.c               13	
X src/apply.c               16	
X src/artifact.c            18	
X src/attrib.c              28	
X src/bones.c               32	
X src/cmd.c                 11	
X src/dbridge.c              3	
X src/decl.c                33	
X src/demon.c               35	
X src/do.c                  12	
X src/do_name.c             30	
X src/do_wear.c             12	
X src/dog.c                 29	
X src/dogmove.c             31	
X src/dokick.c              24	
X src/dothrow.c             28	
X src/eat.c                 16	
X src/end.c                 28	
X src/engrave.c             26	
X src/exper.c               34	
X src/extralev.c            30	
X src/fountain.c            30	
X src/getline.c             33	
X src/hack.c                21	
X src/invent.c              15	
X src/ioctl.c               37	
X src/lev_comp.c             1	
X src/lev_comp.l            36	
X src/lev_comp.y            20	
X src/lev_lex.c             15	
X src/lev_main.c            37	
X src/lock.c                23	
X src/mail.c                33	
X src/makedefs.c            30	
X src/makemon.c             18	
X src/mcastu.c              31	
X src/mhitm.c               10	
X src/mhitu.c                3	
X src/mklev.c               20	
X src/mkmaze.c              27	
X src/mkobj.c               26	
X src/mkroom.c              29	
X src/mon.c                 13	
X src/mondata.c             24	
X src/monmove.c             14	
X src/monst.c1               5	
X src/monst.c2               8	
X src/mthrowu.c             29	
X src/music.c                5	
X src/o_init.c               2	
X src/objects.c             19	
X src/objnam.c               9	
X src/options.c             18	
X src/pager.c               24	
X src/panic.c               37	
X src/pickup.c               7	
X src/polyself.c            13	
X src/potion.c              21	
X src/pray.c                11	
X src/pri.c                 19	
X src/priest.c              25	
X src/prisym.c              30	
X src/read.c                14	
X src/restore.c             17	
X src/rip.c                 37	
X src/rnd.c                 37	
X src/rumors.c              32	
X src/save.c                 8	
X src/search.c              34	
X src/shk.c                  7	
X src/shknam.c              26	
X src/sit.c                 34	
X src/sounds.c              25	
X src/sp_lev.c              27	
X src/spell.c               29	
X src/steal.c               31	
X src/termcap.c             28	
X src/timeout.c             34	
X src/topl.c                33	
X src/topten.c              23	
X src/track.c               21	
X src/trap.c                 6	
X src/u_init.c               9	
X src/uhitm.c               10	
X src/unixmain.c            27	
X src/unixtty.c             23	
X src/unixunix.c            32	
X src/vault.c               32	
X src/version.c             37	
X src/weapon.c              25	
X src/were.c                37	
X src/wield.c               33	
X src/wizard.c              32	
X src/worm.c                28	
X src/worn.c                35	
X src/write.c               35	
X src/zap.c                  2	
END_OF_FILE
if test 6314 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
fi
# end of 'MANIFEST'
fi
if test ! -d 'amiga' ; then
    echo shar: Creating directory \"'amiga'\"
    mkdir 'amiga'
fi
if test ! -d 'auxil' ; then
    echo shar: Creating directory \"'auxil'\"
    mkdir 'auxil'
fi
if test ! -d 'include' ; then
    echo shar: Creating directory \"'include'\"
    mkdir 'include'
fi
if test -f 'include/osbind.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/osbind.h'\"
else
echo shar: Extracting \"'include/osbind.h'\" \(234 characters\)
sed "s/^X//" >'include/osbind.h' <<'END_OF_FILE'
X/*	SCCS Id: @(#)osbind.h	3.0	88/07/22
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#ifndef OSBIND_H
X#define OSBIND_H
X
X#endif /* OSBIND_H */
END_OF_FILE
if test 234 -ne `wc -c <'include/osbind.h'`; then
    echo shar: \"'include/osbind.h'\" unpacked with wrong size!
fi
# end of 'include/osbind.h'
fi
if test ! -d 'others' ; then
    echo shar: Creating directory \"'others'\"
    mkdir 'others'
fi
if test ! -d 'src' ; then
    echo shar: Creating directory \"'src'\"
    mkdir 'src'
fi
if test -f 'src/lev_comp.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/lev_comp.c'\"
else
echo shar: Extracting \"'src/lev_comp.c'\" \(32317 characters\)
sed "s/^X//" >'src/lev_comp.c' <<'END_OF_FILE'
X
X# line 1 "lev_comp.y"
X 
X/*	SCCS Id: @(#)lev_comp.c	3.0	89/07/02
X/*	Copyright (c) 1989 by Jean-Christophe Collet */
X/* NetHack may be freely redistributed.  See license for details. */
X
X/*
X * This file contains the Level Compiler code
X * It may handle special mazes & special room-levels
X */
X
X/* block some unused #defines to avoid overloading some cpp's */
X#define MONDATA_H
X#include "hack.h"
X#include "sp_lev.h"
X#include <fcntl.h>
X
X#ifdef AMIGA
Xchar *fgets();
X# define    alloc   malloc
X# undef     fopen
X# undef     printf
X# undef     Printf
X# define    Printf  printf
X# define    memset(addr,val,len)    setmem(addr,len,val)
X#endif
X
X#ifdef MSDOS
X# undef exit
X#endif
X
X#define MAX_REGISTERS	10
X#define ERR		(-1)
X
Xstruct reg {
X	int x1, y1;
X	int x2, y2;
X}		current_region;
X
Xstruct coord {
X	int x;
X	int y;
X}		current_coord;
X
Xstruct {
X	char *name;
X	short type;
X} trap_types[TRAPNUM-1] = {
X	"monster",	MONST_TRAP,
X	"statue",	STATUE_TRAP,
X	"bear",		BEAR_TRAP,
X	"arrow",	ARROW_TRAP,
X	"dart",		DART_TRAP,
X	"trapdoor",	TRAPDOOR,
X	"teleport",	TELEP_TRAP,
X	"pit",		PIT,
X	"sleeping gas",	SLP_GAS_TRAP,
X	"magic",	MGTRP,
X	"board",	SQBRD,
X	"web",		WEB,
X	"spiked pit",	SPIKED_PIT,
X	"level teleport",LEVEL_TELEP,
X#ifdef SPELLS
X	"anti magic",	ANTI_MAGIC,
X#endif
X	"rust",		RUST_TRAP
X#ifdef POLYSELF
X	, "polymorph",	POLY_TRAP
X#endif
X#ifdef ARMY
X	, "land mine",	LANDMINE
X#endif
X  };
X
Xstruct {
X	char *name;
X	int type;
X} room_types[SHOPBASE-1] = {
X	/* for historical reasons, room types are not contiguous numbers */
X	/* (type 1 is skipped) */
X	"ordinary",	OROOM,
X#ifdef THRONES
X	"throne",	COURT,
X#endif
X	"swamp",	SWAMP,
X	"vault",	VAULT,
X	"beehive",	BEEHIVE,
X	"morgue",	MORGUE,
X#ifdef ARMY
X	"barracks",	BARRACKS,
X#endif
X	"zoo",		ZOO,
X	"temple",	TEMPLE,
X	"shop",		SHOPBASE,
X};
X
Xshort db_dirs[4] = {
X	DB_NORTH,
X	DB_EAST,
X	DB_SOUTH,
X	DB_WEST
X};
X
X#ifdef ALTARS
Xstatic altar *tmpaltar[256];
X#endif /* ALTARS /**/
Xstatic lad *tmplad[256];
Xstatic dig *tmpdig[256];
Xstatic char *tmpmap[ROWNO];
Xstatic region *tmpreg[16];
Xstatic door *tmpdoor[256];
Xstatic trap *tmptrap[256];
Xstatic monster *tmpmonst[256];
Xstatic object *tmpobj[256];
Xstatic drawbridge *tmpdb[256];
Xstatic walk *tmpwalk[256];
Xstatic mazepart *tmppart[10];
Xstatic room *tmproom[MAXNROFROOMS];
Xstatic specialmaze maze;
X
Xstatic char olist[MAX_REGISTERS], mlist[MAX_REGISTERS];
Xstatic struct coord plist[MAX_REGISTERS];
Xstatic int n_olist = 0, n_mlist = 0, n_plist = 0;
X
Xunsigned int nreg = 0, ndoor = 0, ntrap = 0, nmons = 0, nobj = 0;
Xunsigned int ndb = 0, nwalk = 0, npart = 0, ndig = 0, nlad = 0;
X#ifdef ALTARS
Xunsigned int naltar = 0;
X#endif /* ALTARS /*/
X
Xunsigned int max_x_map, max_y_map;
X
Xextern int fatal_error;
Xextern char* fname;
X
Xboolean check_monster_char(), check_object_char();
Xvoid scan_map(), store_part(), write_maze();
X
X
X# line 140 "lev_comp.y"
Xtypedef union 
X{
X	int	i;
X	char*	map;
X} YYSTYPE;
X# define CHAR 257
X# define INTEGER 258
X# define MAZE_ID 259
X# define LEVEL_ID 260
X# define GEOMETRY_ID 261
X# define OBJECT_ID 262
X# define MONSTER_ID 263
X# define TRAP_ID 264
X# define DOOR_ID 265
X# define DRAWBRIDGE_ID 266
X# define MAZEWALK_ID 267
X# define REGION_ID 268
X# define RANDOM_OBJECTS_ID 269
X# define RANDOM_MONSTERS_ID 270
X# define RANDOM_PLACES_ID 271
X# define ALTAR_ID 272
X# define LADDER_ID 273
X# define NON_DIGGABLE_ID 274
X# define ROOM_ID 275
X# define DOOR_STATE 276
X# define LIGHT_STATE 277
X# define DIRECTION 278
X# define RANDOM_TYPE 279
X# define O_REGISTER 280
X# define M_REGISTER 281
X# define P_REGISTER 282
X# define A_REGISTER 283
X# define ALIGNMENT 284
X# define LEFT_OR_RIGHT 285
X# define CENTER 286
X# define TOP_OR_BOT 287
X# define ALTAR_TYPE 288
X# define UP_OR_DOWN 289
X# define STRING 290
X# define MAP_ID 291
X#define yyclearin yychar = -1
X#define yyerrok yyerrflag = 0
Xextern int yychar;
Xextern short yyerrflag;
X#ifndef YYMAXDEPTH
X#define YYMAXDEPTH 150
X#endif
XYYSTYPE yylval, yyval;
X# define YYERRCODE 256
X
X# line 617 "lev_comp.y"
X
X
X/* 
X * Find the type of a room in the table, knowing its name.
X */
X
Xint
Xget_room_type(s)
Xchar *s;
X{
X	register int i;
X	
X	for(i=0; i < SHOPBASE -1; i++)
X	    if (!strcmp(s, room_types[i].name))
X		return room_types[i].type;
X	return ERR;
X}
X
X/* 
X * Find the type of a trap in the table, knowing its name.
X */
X
Xint
Xget_trap_type(s)
Xchar *s;
X{
X	register int i;
X	
X	for(i=0; i < TRAPNUM - 1; i++)
X	    if(!strcmp(s,trap_types[i].name))
X		return(trap_types[i].type);
X	return ERR;
X}
X
X/* 
X * Find the index of a monster in the table, knowing its name.
X */
X
Xint
Xget_monster_id(s, c)
Xchar *s;
Xchar c;
X{
X	register int i;
X	
X	for(i=0; mons[i].mname[0]; i++)
X	    if(!strncmp(s, mons[i].mname, strlen(mons[i].mname))
X	       && c == mons[i].mlet)
X		return i;
X	return ERR;
X}
X
X/* 
X * Find the index of an object in the table, knowing its name.
X */
X
Xint
Xget_object_id(s, c)
Xchar *s;
Xchar c;
X{
X	register int i;
X	
X	for(i=0; i<=NROFOBJECTS;i++)
X	    if(objects[i].oc_name &&
X	       !strncmp(s, objects[i].oc_name, strlen(objects[i].oc_name))
X	       && c == objects[i].oc_olet)
X		return i;
X	return ERR;
X}
X
X/* 
X * Is the character 'c' a valid monster class ?
X */
X
Xboolean
Xcheck_monster_char(c)
Xchar c;
X{
X	register int i;
X	
X	for(i=0; mons[i].mname[0]; i++)
X	    if( c ==  mons[i].mlet)
X		return 1;
X	return(0);
X}
X
X/* 
X * Is the character 'c' a valid object class ?
X */
X
Xboolean
Xcheck_object_char(c)
Xchar c;
X{
X	register int i;
X	
X	for(i=0; i<=NROFOBJECTS;i++)
X	    if( c == objects[i].oc_olet)
X		return 1;
X	return 0;
X}
X
X/* 
X * Yep! LEX gives us the map in a raw mode.
X * Just analyze it here.
X */
X
Xvoid scan_map(map)
Xchar *map;
X{
X	register int i, len;
X	register char *s1, *s2;
X	int max_len = 0;
X	int max_hig = 0;
X	
X	/* First : find the max width of the map */
X
X	s1 = map;
X	while (s1 && *s1) {
X		s2 = index(s1, '\n');
X		if (s2) {
X			if (s2-s1 > max_len)
X			    max_len = s2-s1;
X			s1 = s2 + 1;
X		} else {
X			if (strlen(s1) > max_len)
X			    max_len = strlen(s1);
X			s1 = (char *) 0;
X		}
X	}
X
X	/* Then parse it now */
X
X	while (map && *map) {
X		tmpmap[max_hig] = (char *) alloc(max_len);
X		s1 = index(map, '\n');
X		if (s1) {
X			len = s1 - map;
X			s1++;
X		} else {
X			len = strlen(map);
X			s1 = map + len;
X		}
X		for(i=0; i<len; i++)
X		    switch(map[i]) {
X			  case '-' : tmpmap[max_hig][i] = HWALL; break;
X			  case '|' : tmpmap[max_hig][i] = VWALL; break;
X			  case '+' : tmpmap[max_hig][i] = DOOR; break;
X			  case 'S' : tmpmap[max_hig][i] = SDOOR; break;
X			  case '{' : 
X#ifdef FOUNTAINS
X			      tmpmap[max_hig][i] = FOUNTAIN;
X#else
X			      tmpmap[max_hig][i] = ROOM;
X			      yywarning("Fountains are not allowed in this version!  Ignoring...");
X#endif
X			      break;
X			  case '\\' : 
X#ifdef THRONES
X			      tmpmap[max_hig][i] = THRONE;
X#else
X			      tmpmap[max_hig][i] = ROOM;
X			      yywarning("Thrones are not allowed in this version!  Ignoring...");
X#endif
X			      break;
X			  case 'K' : 
X#ifdef SINKS
X			      tmpmap[max_hig][i] = SINK;
X#else
X			      tmpmap[max_hig][i] = ROOM;
X			      yywarning("Sinks are not allowed in this version!  Ignoring...");
X#endif
X			      break;
X			  case '}' : tmpmap[max_hig][i] = MOAT; break;
X			  case '#' : tmpmap[max_hig][i] = CORR; break;
X			  default  : tmpmap[max_hig][i] = ROOM; break;
X		    }
X		while(i < max_len)
X		    tmpmap[max_hig][i++] = ROOM;
X		map = s1;
X		max_hig++;
X	}
X
X	/* Memorize boundaries */
X
X	max_x_map = max_len - 1;
X	max_y_map = max_hig - 1;
X
X	/* Store the map into the mazepart structure */
X
X	tmppart[npart]->xsize = max_len;
X	tmppart[npart]->ysize = max_hig;
X	tmppart[npart]->map = (char **) alloc(max_hig*sizeof(char *));
X	for(i = 0; i< max_hig; i++)
X	    tmppart[npart]->map[i] = tmpmap[i];
X}
X
X/* 
X * Here we want to store the maze part we just got.
X */
X
Xvoid
Xstore_part()
X{
X	register int i;
X
X	/* Ok, We got the whole part, now we store it. */
X	
X	/* The Regions */
X
X	if(tmppart[npart]->nreg = nreg) {
X		tmppart[npart]->regions = (region**)alloc(sizeof(region*) * nreg);
X		for(i=0;i<nreg;i++)
X		    tmppart[npart]->regions[i] = tmpreg[i];
X	}
X	nreg = 0;
X
X	/* the doors */
X
X	if(tmppart[npart]->ndoor = ndoor) {
X		tmppart[npart]->doors = (door **)alloc(sizeof(door *) * ndoor);
X		for(i=0;i<ndoor;i++)
X		    tmppart[npart]->doors[i] = tmpdoor[i];
X	}
X	ndoor = 0;
X
X	/* the traps */
X
X	if(tmppart[npart]->ntraps = ntrap) {
X		tmppart[npart]->traps = (trap **)alloc(sizeof(trap*) * ntrap);
X		for(i=0;i<ntrap;i++)
X		    tmppart[npart]->traps[i] = tmptrap[i];
X	}
X	ntrap = 0;
X
X	/* the monsters */
X
X	if(tmppart[npart]->nmonster = nmons) {
X		tmppart[npart]->monsters = (monster**)alloc(sizeof(monster*)*nmons);
X		for(i=0;i<nmons;i++)
X		    tmppart[npart]->monsters[i] = tmpmonst[i];
X	}
X	nmons = 0;
X
X	/* the objects */
X
X	if(tmppart[npart]->nobjects = nobj) {
X		tmppart[npart]->objects = (object**)alloc(sizeof(object*)*nobj);
X		for(i=0;i<nobj;i++)
X		    tmppart[npart]->objects[i] = tmpobj[i];
X	}
X	nobj = 0;
X
X	/* the drawbridges */
X
X	if(tmppart[npart]->ndrawbridge = ndb) {
X		tmppart[npart]->drawbridges = (drawbridge**)alloc(sizeof(drawbridge*)*ndb);
X		for(i=0;i<ndb;i++)
X		    tmppart[npart]->drawbridges[i] = tmpdb[i];
X	}
X	ndb = 0;
X
X	/* The walkmaze directives */
X
X	if(tmppart[npart]->nwalk = nwalk) {
X		tmppart[npart]->walks = (walk**)alloc(sizeof(walk*)*nwalk);
X		for(i=0;i<nwalk;i++)
X		    tmppart[npart]->walks[i] = tmpwalk[i];
X	}
X	nwalk = 0;
X
X	/* The non_diggable directives */
X
X	if(tmppart[npart]->ndig = ndig) {
X		tmppart[npart]->digs = (dig **) alloc(sizeof(dig*) * ndig);
X		for(i=0;i<ndig;i++)
X		    tmppart[npart]->digs[i] = tmpdig[i];
X	}
X	ndig = 0;
X
X	/* The ladders */
X
X	if(tmppart[npart]->nlad = nlad) {
X		tmppart[npart]->lads = (lad **) alloc(sizeof(lad*) * nlad);
X		for(i=0;i<nlad;i++)
X		    tmppart[npart]->lads[i] = tmplad[i];
X	}
X	nlad = 0;
X#ifdef ALTARS
X	/* The altars */
X
X	if(tmppart[npart]->naltar = naltar) {
X		tmppart[npart]->altars = (altar**)alloc(sizeof(altar*) * naltar);
X		for(i=0;i<naltar;i++)
X		    tmppart[npart]->altars[i] = tmpaltar[i];
X	}
X	naltar = 0;
X#endif /* ALTARS /**/
X	npart++;
X	n_plist = n_mlist = n_olist = 0;
X}
X
X/* 
X * Here we write the structure of the maze in the specified file (fd).
X * Also, we have to free the memory allocated via alloc()
X */
X
Xvoid
Xwrite_maze(fd, maze)
Xint fd;
Xspecialmaze *maze;
X{
X	char c;
X	short i,j;
X	mazepart *pt;
X
X	c = 2;
X	(void) write(fd, &c, 1);	/* Header for special mazes */
X	(void) write(fd, &(maze->numpart), 1);	/* Number of parts */
X	for(i=0;i<maze->numpart;i++) {
X	    pt = maze->parts[i];
X
X	    /* First, write the map */
X
X	    (void) write(fd, &(pt->halign), 1);
X	    (void) write(fd, &(pt->valign), 1);
X	    (void) write(fd, &(pt->xsize), 1);
X	    (void) write(fd, &(pt->ysize), 1);
X	    for(j=0;j<pt->ysize;j++) {
X		    (void) write(fd, pt->map[j], pt->xsize);
X		    free(pt->map[j]);
X	    }
X	    free(pt->map);
X
X	    /* The random registers */
X	    (void) write(fd, &(pt->nrobjects), 1);
X	    if(pt->nrobjects) {
X		    (void) write(fd, pt->robjects, pt->nrobjects);
X		    free(pt->robjects);
X	    }
X	    (void) write(fd, &(pt->nloc), 1);
X	    if(pt->nloc) {
X		(void) write(fd,pt->rloc_x, pt->nloc);
X		(void) write(fd,pt->rloc_y, pt->nloc);
X		free(pt->rloc_x);
X		free(pt->rloc_y);
X	    }
X	    (void) write(fd,&(pt->nrmonst), 1);
X	    if(pt->nrmonst) {
X		    (void) write(fd, pt->rmonst, pt->nrmonst);
X		    free(pt->rmonst);
X	    }
X
X	    /* subrooms */
X	    (void) write(fd, &(pt->nreg), 1);
X	    for(j=0;j<pt->nreg;j++) {
X		    (void) write(fd,(genericptr_t) pt->regions[j], sizeof(region));
X		    free(pt->regions[j]);
X	    }
X	    if(pt->nreg > 0)
X		free(pt->regions);
X
X	    /* the doors */
X	    (void) write(fd,&(pt->ndoor),1);
X	    for(j=0;j<pt->ndoor;j++) {
X		    (void) write(fd,(genericptr_t) pt->doors[j], sizeof(door));
X		    free(pt->doors[j]);
X	    }
X	    if (pt->ndoor > 0)
X		free(pt->doors);
X
X	    /* The traps */
X	    (void) write(fd,&(pt->ntraps), 1);
X	    for(j=0;j<pt->ntraps;j++) {
X		    (void) write(fd,(genericptr_t) pt->traps[j], sizeof(trap));
X		    free(pt->traps[j]);
X	    }
X	    if (pt->ntraps)
X		free(pt->traps);
X
X	    /* The monsters */
X	    (void) write(fd, &(pt->nmonster), 1);
X	    for(j=0;j<pt->nmonster;j++) {
X		    (void) write(fd,(genericptr_t) pt->monsters[j], sizeof(monster));
X		    free(pt->monsters[j]);
X	    }
X	    if (pt->nmonster > 0)
X		free(pt->monsters);
X
X	    /* The objects */
X	    (void) write(fd, &(pt->nobjects), 1);
X	    for(j=0;j<pt->nobjects;j++) {
X		    (void) write(fd,(genericptr_t) pt->objects[j], sizeof(object));
X		    free(pt->objects[j]);
X	    }
X	    if(pt->nobjects > 0)
X		free(pt->objects);
X
X	    /* The drawbridges */
X	    (void) write(fd, &(pt->ndrawbridge),1);
X	    for(j=0;j<pt->ndrawbridge;j++) {
X		    (void) write(fd,(genericptr_t) pt->drawbridges[j], sizeof(drawbridge));
X		    free(pt->drawbridges[j]);
X	    }
X	    if(pt->ndrawbridge > 0)
X		free(pt->drawbridges);
X
X	    /* The mazewalk directives */
X	    (void) write(fd, &(pt->nwalk), 1);
X	    for(j=0; j<pt->nwalk; j++) {
X		    (void) write(fd,(genericptr_t) pt->walks[j], sizeof(walk));
X		    free(pt->walks[j]);
X	    }
X	    if (pt->nwalk > 0)
X		free(pt->walks);
X
X	    /* The non_diggable directives */
X	    (void) write(fd, &(pt->ndig), 1);
X	    for(j=0;j<pt->ndig;j++) {
X		    (void) write(fd,(genericptr_t) pt->digs[j], sizeof(dig));
X		    free(pt->digs[j]);
X	    }
X	    if (pt->ndig > 0)
X		free(pt->digs);
X
X	    /* The ladders */
X	    (void) write(fd, &(pt->nlad), 1);
X	    for(j=0;j<pt->nlad;j++) {
X		    (void) write(fd,(genericptr_t) pt->lads[j], sizeof(lad));
X		    free(pt->lads[j]);
X	    }
X	    if (pt->nlad > 0)
X		free(pt->lads);
X#ifdef ALTARS
X	    /* The altars */
X	    (void) write(fd, &(pt->naltar), 1);
X	    for(j=0;j<pt->naltar;j++) {
X		    (void) write(fd,(genericptr_t) pt->altars[j], sizeof(altar));
X		    free(pt->altars[j]);
X	    }
X	    if (pt->naltar > 0)
X		free(pt->altars);
X#endif /* ALTARS /**/
X	    free(pt);
X	}
X}
Xshort yyexca[] ={
X-1, 1,
X	0, -1,
X	-2, 0,
X	};
X# define YYNPROD 86
X# define YYLAST 251
Xshort yyact[]={
X
X 164, 130, 126,  91,  16,  19, 168, 146,  69,  72,
X 145,  19,  19,  19,  19, 167,  75,  74,  26,  27,
X 143, 137,  12, 138, 144, 141,  65,  87, 134,   6,
X  88,  78, 173,  80,  40,  39,  42,  41,  43,  46,
X  44, 170, 169, 155,  45,  47,  48, 147,  83,  85,
X  22,  24,  23, 135, 131, 127, 116, 105,  72,  65,
X  18,  92,  71,  86, 171, 153,  67,  93, 151, 149,
X 157,  64, 114, 110, 108,  97,  62,  61,  60,  59,
X  58,  57,  56,  55,  54,  53,  51,  50,  49,  17,
X  13, 172, 165, 156, 154, 152, 150, 148, 139, 122,
X 119, 118, 117, 115, 113, 112, 111, 109, 107, 106,
X 104, 103,  52, 174, 158,  69,  77,  90,  68,  98,
X   9,  99, 100, 101,   3, 142,  82,   7,  94,  14,
X  84,  79, 166, 140, 162, 136,  89,  81, 102,  76,
X  38,  37,  36,  35,  34,  33,  32,  31,  30,  29,
X  28,  70,  66,  63,  21,  73,  25,  11,  20,  15,
X  10,   8,   4,   2,   1, 128, 124,   5, 125, 123,
X 129, 121,  68, 132, 133, 120,   0,   0,   0,   0,
X   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
X   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
X   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
X 159,   0, 160,   0,   0, 163, 161,   0,   0,   0,
X   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
X   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
X   0,   0,   0,   0,   0,   0,   0,  95,   0,   0,
X  96 };
Xshort yypact[]={
X
X-230,-1000,-230,-1000,-1000,-239,  32,-1000,-239,-1000,
X-1000,-287,  31,-285,-1000,-219,-1000,-267,-1000,-1000,
X-228,-1000,  30,  29,  28,  68,-1000,-1000,-1000,-1000,
X-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,  27,
X  26,  25,  24,  23,  22,  21,  20,  19,  18,-198,
X  75,-199,-270,-248,-231,-249,-276, -32,  79, -32,
X -32, -32,  79,  67,-1000,-1000,  66,-1000,-1000,-201,
X  65,-1000,-1000,-1000,-1000,-1000,  64,-1000,-1000,-1000,
X -17,  63,-1000,-1000,-1000, -18,  62,-1000,-1000,  61,
X-1000,-1000,  60,-1000,-1000,-1000, -19,  59,-202,  58,
X  57,  56,-1000,-198,  75,  55,-199,-277,-203,-278,
X-204, -32, -32,-250,-205,-256,  54,-259,-268,-282,
X-1000,-1000,-211,-1000,  53,-1000,-1000, -24,  52,-1000,
X-1000, -25,-1000,-1000,  51, -28,  50,-1000,-1000,-215,
X  49,-1000,-1000,-1000, -21,-1000,-1000,  73, -32,-1000,
X -32,-1000,-249,-1000,-279,  48,-273,-216,-1000,-1000,
X-1000,-1000,-1000,-1000,-1000,-217,-1000,-1000,-1000, -29,
X  47,-1000,-226,  72,-1000 };
Xshort yypgo[]={
X
X   0,  60, 167, 166, 165, 164, 163, 124, 162, 161,
X 120, 160, 159, 158, 157, 156, 155, 154, 153, 152,
X 151,  71,  62,  66, 150, 149, 148, 147, 146, 145,
X 144, 143, 142, 141, 140, 139,  61, 137,  63, 136,
X  75, 135, 134, 133, 132, 131, 130,  67, 128, 125 };
Xshort yyr1[]={
X
X   0,   5,   5,   6,   6,   7,   8,   2,   9,   9,
X  10,  11,  14,  15,  15,  16,  16,  12,  12,  17,
X  17,  17,  18,  18,  20,  20,  19,  19,  13,  13,
X  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,
X  25,  26,  27,  28,  29,  32,  33,  34,  30,  31,
X  35,  35,  35,  37,  37,  37,   3,   3,   4,   4,
X  39,  39,  42,  42,  36,  36,  36,  38,  38,  41,
X  41,  43,  43,  43,  44,  44,  48,  46,  45,  49,
X  23,  22,  21,   1,  47,  40 };
Xshort yyr2[]={
X
X   0,   0,   1,   1,   2,   1,   2,   3,   1,   2,
X   3,   2,   5,   1,   1,   1,   1,   0,   2,   3,
X   3,   3,   1,   3,   1,   3,   1,   3,   0,   2,
X   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
X   7,   7,   5,   5,   7,   5,   5,   3,   7,   7,
X   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
X   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
X   1,   1,   1,   1,   1,   1,   4,   4,   4,   4,
X   1,   1,   1,   1,   5,   9 };
Xshort yychk[]={
X
X-1000,  -5,  -6,  -7,  -8,  -2, 259,  -7,  -9, -10,
X -11, -14, 261,  58, -10, -12, 291,  58,  -1, 290,
X -13, -17, 269, 271, 270, -15, 285, 286, -24, -25,
X -26, -27, -28, -29, -30, -31, -32, -33, -34, 263,
X 262, 265, 264, 266, 268, 272, 267, 273, 274,  58,
X  58,  58,  44,  58,  58,  58,  58,  58,  58,  58,
X  58,  58,  58, -18, -21, 257, -19, -23, -47,  40,
X -20, -22, 257, -16, 287, 286, -35, -22, 279, -45,
X 281, -37, -21, 279, -46, 280, -38, 276, 279, -39,
X  -1, 279, -36, -47, -48, 279, 282, -40,  40, -36,
X -36, -36, -40,  44,  44, 258,  44,  44,  91,  44,
X  91,  44,  44,  44,  91,  44, 258,  44,  44,  44,
X -21, -23,  44, -22,  -3,  -1, 279, 258,  -4,  -1,
X 279, 258, -36, -36, 278, 258, -41, 277, 279,  44,
X -43, 284, -49, 279, 283, 278, 289, 258,  44,  93,
X  44,  93,  44,  93,  44, 258,  44,  91,  41, -36,
X -36, -38, -42,  -1, 279,  44, -44, 288, 279, 258,
X 258,  93,  44, 258,  41 };
Xshort yydef[]={
X
X   1,  -2,   2,   3,   5,   0,   0,   4,   6,   8,
X  17,   0,   0,   0,   9,  28,  11,   0,   7,  83,
X  10,  18,   0,   0,   0,   0,  13,  14,  29,  30,
X  31,  32,  33,  34,  35,  36,  37,  38,  39,   0,
X   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
X   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
X   0,   0,   0,  19,  22,  82,  20,  26,  80,   0,
X  21,  24,  81,  12,  15,  16,   0,  50,  51,  52,
X   0,   0,  53,  54,  55,   0,   0,  67,  68,   0,
X  60,  61,   0,  64,  65,  66,   0,   0,   0,   0,
X   0,   0,  47,   0,   0,   0,   0,   0,   0,   0,
X   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
X  23,  27,   0,  25,   0,  56,  57,   0,   0,  58,
X  59,   0,  42,  43,   0,   0,   0,  69,  70,   0,
X   0,  71,  72,  73,   0,  45,  46,   0,   0,  78,
X   0,  77,   0,  76,   0,   0,   0,   0,  84,  40,
X  41,  44,  48,  62,  63,   0,  49,  74,  75,   0,
X   0,  79,   0,   0,  85 };
X#ifndef lint
Xstatic char yaccpar_sccsid[] = "@(#)yaccpar	4.1	(Berkeley)	2/11/83";
X#endif not lint
X
X#
X# define YYFLAG -1000
X# define YYERROR goto yyerrlab
X# define YYACCEPT return(0)
X# define YYABORT return(1)
X
X/*	parser for yacc output	*/
X
X#ifdef YYDEBUG
Xint yydebug = 0; /* 1 for debugging */
X#endif
XYYSTYPE yyv[YYMAXDEPTH]; /* where the values are stored */
Xint yychar = -1; /* current input token number */
Xint yynerrs = 0;  /* number of errors */
Xshort yyerrflag = 0;  /* error recovery flag */
X
Xyyparse() {
X
X	short yys[YYMAXDEPTH];
X	short yyj, yym;
X	register YYSTYPE *yypvt;
X	register short yystate, *yyps, yyn;
X	register YYSTYPE *yypv;
X	register short *yyxi;
X
X	yystate = 0;
X	yychar = -1;
X	yynerrs = 0;
X	yyerrflag = 0;
X	yyps= &yys[-1];
X	yypv= &yyv[-1];
X
X yystack:    /* put a state and value onto the stack */
X
X#ifdef YYDEBUG
X	if( yydebug  ) printf( "state %d, char 0%o\n", yystate, yychar );
X#endif
X		if( ++yyps> &yys[YYMAXDEPTH] ) { yyerror( "yacc stack overflow" ); return(1); }
X		*yyps = yystate;
X		++yypv;
X		*yypv = yyval;
X
X yynewstate:
X
X	yyn = yypact[yystate];
X
X	if( yyn<= YYFLAG ) goto yydefault; /* simple state */
X
X	if( yychar<0 ) if( (yychar=yylex())<0 ) yychar=0;
X	if( (yyn += yychar)<0 || yyn >= YYLAST ) goto yydefault;
X
X	if( yychk[ yyn=yyact[ yyn ] ] == yychar ){ /* valid shift */
X		yychar = -1;
X		yyval = yylval;
X		yystate = yyn;
X		if( yyerrflag > 0 ) --yyerrflag;
X		goto yystack;
X		}
X
X yydefault:
X	/* default state action */
X
X	if( (yyn=yydef[yystate]) == -2 ) {
X		if( yychar<0 ) if( (yychar=yylex())<0 ) yychar = 0;
X		/* look through exception table */
X
X		for( yyxi=yyexca; (*yyxi!= (-1)) || (yyxi[1]!=yystate) ; yyxi += 2 ) ; /* VOID */
X
X		while( *(yyxi+=2) >= 0 ){
X			if( *yyxi == yychar ) break;
X			}
X		if( (yyn = yyxi[1]) < 0 ) return(0);   /* accept */
X		}
X
X	if( yyn == 0 ){ /* error */
X		/* error ... attempt to resume parsing */
X
X		switch( yyerrflag ){
X
X		case 0:   /* brand new error */
X
X			yyerror( "syntax error" );
X		yyerrlab:
X			++yynerrs;
X
X		case 1:
X		case 2: /* incompletely recovered error ... try again */
X
X			yyerrflag = 3;
X
X			/* find a state where "error" is a legal shift action */
X
X			while ( yyps >= yys ) {
X			   yyn = yypact[*yyps] + YYERRCODE;
X			   if( yyn>= 0 && yyn < YYLAST && yychk[yyact[yyn]] == YYERRCODE ){
X			      yystate = yyact[yyn];  /* simulate a shift of "error" */
X			      goto yystack;
X			      }
X			   yyn = yypact[*yyps];
X
X			   /* the current yyps has no shift onn "error", pop stack */
X
X#ifdef YYDEBUG
X			   if( yydebug ) printf( "error recovery pops state %d, uncovers %d\n", *yyps, yyps[-1] );
X#endif
X			   --yyps;
X			   --yypv;
X			   }
X
X			/* there is no state on the stack with an error shift ... abort */
X
X	yyabort:
X			return(1);
X
X
X		case 3:  /* no shift yet; clobber input char */
X
X#ifdef YYDEBUG
X			if( yydebug ) printf( "error recovery discards char %d\n", yychar );
X#endif
X
X			if( yychar == 0 ) goto yyabort; /* don't discard EOF, quit */
X			yychar = -1;
X			goto yynewstate;   /* try again in the same state */
X
X			}
X
X		}
X
X	/* reduction by production yyn */
X
X#ifdef YYDEBUG
X		if( yydebug ) printf("reduce %d\n",yyn);
X#endif
X		yyps -= yyr2[yyn];
X		yypvt = yypv;
X		yypv -= yyr2[yyn];
X		yyval = yypv[1];
X		yym=yyn;
X			/* consult goto table to find next state */
X		yyn = yyr1[yyn];
X		yyj = yypgo[yyn] + *yyps + 1;
X		if( yyj>=YYLAST || yychk[ yystate = yyact[yyj] ] != -yyn ) yystate = yyact[yypgo[yyn]];
X		switch(yym){
X			
Xcase 6:
X# line 170 "lev_comp.y"
X{
X			  int fout, i;
X
X			  if (fatal_error > 0)
X				  fprintf(stderr,"%s : %d errors detected. No output created!\n", fname, fatal_error);
X			  else {
X				  fout = open(yypvt[-1].map, O_WRONLY | O_CREAT
X#ifdef MSDOS
X					      | O_BINARY
X#endif /* MSDOS */
X					      , 0644);
X				  if (fout < 0) {
X					  yyerror("Can't open output file!!");
X					  exit(1);
X				  }
X				  maze.numpart = npart;
X				  maze.parts = (mazepart**) alloc(sizeof(mazepart*)*npart);
X				  for(i=0;i<npart;i++)
X				      maze.parts[i] = tmppart[i];
X				  write_maze(fout, &maze);
X				  (void) close(fout);
X				  npart = 0;
X			  }
X		  } break;
Xcase 7:
X# line 196 "lev_comp.y"
X{
X			  yyval.map = yypvt[-0].map;
X		  } break;
Xcase 10:
X# line 204 "lev_comp.y"
X{
X			store_part();
X		  } break;
Xcase 11:
X# line 209 "lev_comp.y"
X{
X			tmppart[npart] = (mazepart *) alloc(sizeof(mazepart));
X			tmppart[npart]->halign = yypvt[-1].i % 10;
X			tmppart[npart]->valign = yypvt[-1].i / 10;
X			tmppart[npart]->nrobjects = 0;
X			tmppart[npart]->nloc = 0;
X			tmppart[npart]->nrmonst = 0;
X			scan_map(yypvt[-0].map);
X		  } break;
Xcase 12:
X# line 220 "lev_comp.y"
X{
X			  yyval.i = yypvt[-2].i + ( yypvt[-0].i * 10 );
X		  } break;
Xcase 19:
X# line 234 "lev_comp.y"
X{
X			  if (tmppart[npart]->nrobjects)
X			      yyerror("Object registers already initialized!");
X			  else {
X				  tmppart[npart]->robjects = (char *) alloc(n_olist);
X				  memcpy(tmppart[npart]->robjects, olist, n_olist);
X				  tmppart[npart]->nrobjects = n_olist;
X			  }
X		  } break;
Xcase 20:
X# line 244 "lev_comp.y"
X{
X			  if (tmppart[npart]->nloc)
X			      yyerror("Location registers already initialized!");
X			  else {
X				  register int i;
X				  tmppart[npart]->rloc_x = (char *) alloc(n_plist);
X				  tmppart[npart]->rloc_y = (char *) alloc(n_plist);
X				  for(i=0;i<n_plist;i++) {
X					  tmppart[npart]->rloc_x[i] = plist[i].x;
X					  tmppart[npart]->rloc_y[i] = plist[i].y;
X				  }
X				  tmppart[npart]->nloc = n_plist;
X			  }
X		  } break;
Xcase 21:
X# line 259 "lev_comp.y"
X{
X			  if (tmppart[npart]->nrmonst)
X			      yyerror("Monster registers already initialized!");
X			  else {
X				  tmppart[npart]->rmonst = (char *) alloc(n_mlist);
X				  memcpy(tmppart[npart]->rmonst, mlist, n_mlist);
X				  tmppart[npart]->nrmonst = n_mlist;
X			  }
X		  } break;
Xcase 22:
X# line 270 "lev_comp.y"
X{
X			  if (n_olist < MAX_REGISTERS)
X			      olist[n_olist++] = yypvt[-0].i;
X			  else
X			      yyerror("Object list too long!");
X		  } break;
Xcase 23:
X# line 277 "lev_comp.y"
X{
X			  if (n_olist < MAX_REGISTERS)
X			      olist[n_olist++] = yypvt[-0].i;
X			  else
X			      yyerror("Object list too long!");
X		  } break;
Xcase 24:
X# line 285 "lev_comp.y"
X{
X			  if (n_mlist < MAX_REGISTERS)
X			      mlist[n_mlist++] = yypvt[-0].i;
X			  else
X			      yyerror("Monster list too long!");
X		  } break;
Xcase 25:
X# line 292 "lev_comp.y"
X{
X			  if (n_mlist < MAX_REGISTERS)
X			      mlist[n_mlist++] = yypvt[-0].i;
X			  else
X			      yyerror("Monster list too long!");
X		  } break;
Xcase 26:
X# line 300 "lev_comp.y"
X{
X			  if (n_plist < MAX_REGISTERS)
X			      plist[n_plist++] = current_coord;
X			  else
X			      yyerror("Location list too long!");
X		  } break;
Xcase 27:
X# line 307 "lev_comp.y"
X{
X			  if (n_plist < MAX_REGISTERS)
X			      plist[n_plist++] = current_coord;
X			  else
X			      yyerror("Location list too long!");
X		  } break;
Xcase 40:
X# line 329 "lev_comp.y"
X{
X			  int token;
X
X			  tmpmonst[nmons] = (monster *) alloc(sizeof(monster));
X			  tmpmonst[nmons]->x = current_coord.x;
X			  tmpmonst[nmons]->y = current_coord.y;
X			  tmpmonst[nmons]->class = yypvt[-4].i;
X			  if (!yypvt[-2].map)
X			      tmpmonst[nmons]->id = -1;
X			  else {
X				  token = get_monster_id(yypvt[-2].map, (char) yypvt[-4].i);  
X				  if (token == ERR) {
X				      yywarning("Illegal monster name!  Making random monster.");
X				      tmpmonst[nmons]->id = -1;
X				  } else
X				      tmpmonst[nmons]->id = token;
X			  }
X			  nmons++;
X		  } break;
Xcase 41:
X# line 350 "lev_comp.y"
X{
X			  int token;
X
X			  tmpobj[nobj] = (object *) alloc(sizeof(object));
X			  tmpobj[nobj]->x = current_coord.x;
X			  tmpobj[nobj]->y = current_coord.y;
X			  tmpobj[nobj]->class = yypvt[-4].i;
X			  if (!yypvt[-2].map)
X			      tmpobj[nobj]->id = -1;
X			  else {
X				  token = get_object_id(yypvt[-2].map, (char) yypvt[-4].i);
X				  if (token == ERR) {
X				      yywarning("Illegal object name!  Making random object.");
X				      tmpobj[nobj]->id = -1;
X				  } else
X				      tmpobj[nobj]->id = token;
X			  }
X			  nobj++;
X		  } break;
Xcase 42:
X# line 371 "lev_comp.y"
X{
X			tmpdoor[ndoor] = (door *) alloc(sizeof(door));
X			tmpdoor[ndoor]->x = current_coord.x;
X			tmpdoor[ndoor]->y = current_coord.y;
X			tmpdoor[ndoor]->mask = yypvt[-2].i;
X			ndoor++;
X		  } break;
Xcase 43:
X# line 380 "lev_comp.y"
X{
X			tmptrap[ntrap] = (trap *) alloc(sizeof(trap));
X			tmptrap[ntrap]->x = current_coord.x;
X			tmptrap[ntrap]->y = current_coord.y;
X			tmptrap[ntrap]->type = yypvt[-2].i;
X			ntrap++;
X		  } break;
Xcase 44:
X# line 389 "lev_comp.y"
X{
X			tmpdb[ndb] = (drawbridge *) alloc(sizeof(drawbridge));
X			tmpdb[ndb]->x = current_coord.x;
X			tmpdb[ndb]->y = current_coord.y;
X			tmpdb[ndb]->dir = db_dirs[yypvt[-2].i];
X			if ( yypvt[-0].i == D_ISOPEN )
X			  tmpdb[ndb]->open = 1;
X			else if ( yypvt[-0].i == D_CLOSED )
X			  tmpdb[ndb]->open = 0;
X			else
X			  yyerror("A drawbridge can only be open or closed!");
X			ndb++;
X		   } break;
Xcase 45:
X# line 404 "lev_comp.y"
X{
X			tmpwalk[nwalk] = (walk *) alloc(sizeof(walk));
X			tmpwalk[nwalk]->x = current_coord.x;
X			tmpwalk[nwalk]->y = current_coord.y;
X			tmpwalk[nwalk]->dir = yypvt[-0].i;
X			nwalk++;
X		  } break;
Xcase 46:
X# line 413 "lev_comp.y"
X{
X			tmplad[nlad] = (lad *) alloc(sizeof(lad));
X			tmplad[nlad]->x = current_coord.x;
X			tmplad[nlad]->y = current_coord.y;
X			tmplad[nlad]->up = yypvt[-0].i;
X			nlad++;
X		  } break;
Xcase 47:
X# line 422 "lev_comp.y"
X{
X			tmpdig[ndig] = (dig *) alloc(sizeof(dig));
X			tmpdig[ndig]->x1 = current_region.x1;
X			tmpdig[ndig]->y1 = current_region.y1;
X			tmpdig[ndig]->x2 = current_region.x2;
X			tmpdig[ndig]->y2 = current_region.y2;
X			ndig++;
X		  } break;
Xcase 48:
X# line 432 "lev_comp.y"
X{
X			tmpreg[nreg] = (region *) alloc(sizeof(region));
X			tmpreg[nreg]->x1 = current_region.x1;
X			tmpreg[nreg]->y1 = current_region.y1;
X			tmpreg[nreg]->x2 = current_region.x2;
X			tmpreg[nreg]->y2 = current_region.y2;
X			tmpreg[nreg]->rlit = yypvt[-2].i;
X			tmpreg[nreg]->rtype = yypvt[-0].i;
X			nreg++;
X		  } break;
Xcase 49:
X# line 444 "lev_comp.y"
X{
X#ifndef ALTARS
X			yywarning("Altars are not allowed in this version!  Ignoring...");
X#else
X			tmpaltar[naltar] = (altar *) alloc(sizeof(altar));
X			tmpaltar[naltar]->x = current_coord.x;
X			tmpaltar[naltar]->y = current_coord.y;
X			tmpaltar[naltar]->align = yypvt[-2].i;
X			tmpaltar[naltar]->shrine = yypvt[-0].i;
X			naltar++;
X#endif /* ALTARS */
X		  } break;
Xcase 51:
X# line 459 "lev_comp.y"
X{
X			  yyval.i = - MAX_REGISTERS - 1;
X		  } break;
Xcase 54:
X# line 466 "lev_comp.y"
X{
X			  yyval.i = - MAX_REGISTERS - 1;
X		  } break;
Xcase 57:
X# line 473 "lev_comp.y"
X{
X			  yyval.map = (char *) 0;
X		  } break;
Xcase 59:
X# line 479 "lev_comp.y"
X{
X			  yyval.map = (char *) 0;
X		  } break;
Xcase 60:
X# line 484 "lev_comp.y"
X{
X		  	int token = get_trap_type(yypvt[-0].map);
X			if (token == ERR)
X				yyerror("unknown trap type!");
X			yyval.i = token;
X		  } break;
Xcase 62:
X# line 493 "lev_comp.y"
X{
X			int token = get_room_type(yypvt[-0].map);
X			if (token == ERR) {
X				yywarning("Unknown room type!  Making ordinary room...");
X				yyval.i = OROOM;
X			} else
X				yyval.i = token;
X		  } break;
Xcase 66:
X# line 506 "lev_comp.y"
X{
X			  current_coord.x = current_coord.y = -MAX_REGISTERS-1;
X		  } break;
Xcase 73:
X# line 519 "lev_comp.y"
X{
X			  yyval.i = - MAX_REGISTERS - 1;
X		  } break;
Xcase 76:
X# line 527 "lev_comp.y"
X{
X			if ( yypvt[-1].i >= MAX_REGISTERS ) {
X				yyerror("Register Index overflow!");
X			} else {
X				current_coord.x = current_coord.y = - yypvt[-1].i - 1;
X			}
X		  } break;
Xcase 77:
X# line 536 "lev_comp.y"
X{
X			if ( yypvt[-1].i >= MAX_REGISTERS ) {
X				yyerror("Register Index overflow!");
X			} else {
X				yyval.i = - yypvt[-1].i - 1;
X			}
X		  } break;
Xcase 78:
X# line 545 "lev_comp.y"
X{
X			if ( yypvt[-1].i >= MAX_REGISTERS ) {
X				yyerror("Register Index overflow!");
X			} else {
X				yyval.i = - yypvt[-1].i - 1;
X			}
X		  } break;
Xcase 79:
X# line 554 "lev_comp.y"
X{
X			if ( yypvt[-1].i >= 3 ) {
X				yyerror("Register Index overflow!");
X			} else {
X				yyval.i = - yypvt[-1].i - 1;
X			}
X		  } break;
Xcase 81:
X# line 565 "lev_comp.y"
X{
X			if (check_monster_char(yypvt[-0].i))
X				yyval.i = yypvt[-0].i ;
X			else {
X				yyerror("unknown monster class!");
X				yyval.i = ERR;
X			}
X		  } break;
Xcase 82:
X# line 575 "lev_comp.y"
X{
X			char c;
X
X			c = yypvt[-0].i;
X#ifndef SPELLS
X			if ( c == '+') {
X				c = '?';
X				yywarning("Spellbooks are not allowed in this version! (converted into scroll)");
X			}
X#endif
X			if (check_object_char(c))
X				yyval.i = c;
X			else {
X				yyerror("Unknown char class!");
X				yyval.i = ERR;
X			}
X		  } break;
Xcase 84:
X# line 595 "lev_comp.y"
X{
X		        if (yypvt[-3].i < 0 || yypvt[-3].i > max_x_map ||
X			    yypvt[-1].i < 0 || yypvt[-1].i > max_y_map)
X			    yyerror("Coordinates out of map range!");
X			current_coord.x = yypvt[-3].i;
X			current_coord.y = yypvt[-1].i;
X		  } break;
Xcase 85:
X# line 604 "lev_comp.y"
X{
X		        if (yypvt[-7].i < 0 || yypvt[-7].i > max_x_map ||
X			    yypvt[-5].i < 0 || yypvt[-5].i > max_y_map ||
X			    yypvt[-3].i < 0 || yypvt[-3].i > max_x_map ||
X			    yypvt[-1].i < 0 || yypvt[-1].i > max_y_map)
X			    yyerror("Region out of map range!");
X			current_region.x1 = yypvt[-7].i;
X			current_region.y1 = yypvt[-5].i;
X			current_region.x2 = yypvt[-3].i;
X			current_region.y2 = yypvt[-1].i;
X		  } break; 
X		}
X		goto yystack;  /* stack new state and value */
X
X	}
END_OF_FILE
if test 32317 -ne `wc -c <'src/lev_comp.c'`; then
    echo shar: \"'src/lev_comp.c'\" unpacked with wrong size!
fi
# end of 'src/lev_comp.c'
fi
echo shar: End of archive 1 \(of 38\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 38 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
