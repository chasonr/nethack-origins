Path: utzoo!utgpu!jarvis.csri.toronto.edu!mailrus!csd4.milw.wisc.edu!lll-winken!uunet!zephyr.ens.tek.com!tektronix!tekgen!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v07i066:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Part11/38
Message-ID: <4319@tekred.CNA.TEK.COM>
Date: 24 Jul 89 05:02:53 GMT
Sender: nobody@tekred.CNA.TEK.COM
Lines: 2031
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 7, Issue 66
Archive-name: NetHack3/Part11



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 11 (of 38)."
# Contents:  amiga/signal.h src/cmd.c src/pray.c
# Wrapped by billr@saab on Sun Jul 23 21:32:54 1989
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'amiga/signal.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'amiga/signal.h'\"
else
echo shar: Extracting \"'amiga/signal.h'\" \(115 characters\)
sed "s/^X//" >'amiga/signal.h' <<'END_OF_FILE'
X#ifndef SIGNAL_H
X#define SIGNAL_H
X
X#define SIG_IGN     1
X#define SIG_DFL     0
X#define signal(x,y) SIG_IGN
X
X#endif
END_OF_FILE
if test 115 -ne `wc -c <'amiga/signal.h'`; then
    echo shar: \"'amiga/signal.h'\" unpacked with wrong size!
fi
# end of 'amiga/signal.h'
fi
if test -f 'src/cmd.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/cmd.c'\"
else
echo shar: Extracting \"'src/cmd.c'\" \(17734 characters\)
sed "s/^X//" >'src/cmd.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)cmd.c	3.0	88/10/24
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include	"hack.h"
X#include	"func_tab.h"
X
X#ifdef DUMB	/* stuff commented out in extern.h, but needed here */
Xextern int doapply(); /**/
Xextern int dorub(); /**/
Xextern int dojump(); /**/
Xextern int doextlist(); /**/
Xextern int dodrop(); /**/
Xextern int doddrop(); /**/
Xextern int dodown(); /**/
Xextern int doup(); /**/
Xextern int donull(); /**/
Xextern int dowipe(); /**/
Xextern int do_mname(); /**/
Xextern int ddocall(); /**/
Xextern int dotakeoff(); /**/
Xextern int doremring(); /**/
Xextern int dowear(); /**/
Xextern int doputon(); /**/
Xextern int doddoremarm(); /**/
Xextern int dokick(); /**/
Xextern int dothrow(); /**/
Xextern int doeat(); /**/
Xextern int done2(); /**/
Xextern int doengrave(); /**/
Xextern int dopickup(); /**/
Xextern int ddoinv(); /**/
Xextern int dotypeinv(); /**/
Xextern int dolook(); /**/
Xextern int doprgold(); /**/
Xextern int doprwep(); /**/
Xextern int doprarm(); /**/
Xextern int doprring(); /**/
Xextern int dopramulet(); /**/
Xextern int doprtool(); /**/
Xextern int dosuspend(); /**/
Xextern int doforce(); /**/
Xextern int doopen(); /**/
Xextern int doclose(); /**/
Xextern int dosh(); /**/
Xextern int dodiscovered(); /**/
Xextern int doset(); /**/
Xextern int dotogglepickup(); /**/
Xextern int dowhatis(); /**/
Xextern int dowhatdoes(); /**/
Xextern int dohelp(); /**/
Xextern int dohistory(); /**/
Xextern int dosh(); /**/
Xextern int doloot(); /**/
Xextern int dodrink(); /**/
Xextern int dodip(); /**/
Xextern int dosacrifice(); /**/
Xextern int dopray(); /**/
Xextern int doturn(); /**/
Xextern int doredraw(); /**/
Xextern int doread(); /**/
Xextern int dosave(); /**/
Xextern int dosave0(); /**/
Xextern int dosearch(); /**/
Xextern int dosearch0 P((int)); /**/
Xextern int doidtrap(); /**/
Xextern int dopay(); /**/
Xextern int dosit(); /**/
Xextern int dotalk(); /**/
Xextern int docast(); /**/
Xextern int dovspell(); /**/
Xextern int doredotopl(); /**/
Xextern int dotele(); /**/
Xextern int dountrap(); /**/
Xextern int doversion(); /**/
Xextern int dowield(); /**/
Xextern int dozap(); /**/
X#endif /* DUMB */
X
Xstatic int (*timed_occ_fn)();
X#ifdef POLYSELF
Xstatic int domonability();
X#endif
X
X/* Count down by decrementing multi */
Xstatic int
Xtimed_occupation() {
X	(*timed_occ_fn)();
X	if (multi > 0)
X		multi--;
X	return multi > 0;
X}
X
X/* If a time is given, use it to timeout this function, otherwise the
X * function times out by its own means.
X */
Xvoid
Xset_occupation(fn, txt, xtime)
Xint (*fn)();
Xchar *txt;
Xint xtime;
X{
X	if (xtime) {
X		occupation = timed_occupation;
X		timed_occ_fn = fn;
X	} else
X		occupation = fn;
X	occtxt = txt;
X	occtime = 0;
X	return;
X}
X
X#ifdef REDO
X/* Provide a means to redo the last command.  The flag `in_doagain' is set
X * to true while redoing the command.  This flag is tested in commands that
X * require additional input (like `throw' which requires a thing and a
X * direction), and the input prompt is not shown.  Also, while in_doagain is
X * TRUE, no keystrokes can be saved into the saveq.
X */
X#define BSIZE 20
Xstatic char pushq[BSIZE], saveq[BSIZE];
Xstatic int phead, ptail, shead, stail;
X
Xstatic char
Xpopch() {
X	/* If occupied, return 0, letting tgetch know a character should
X	 * be read from the keyboard.  If the character read is not the
X	 * ABORT character (as checked in pcmain.c), that character will be
X	 * pushed back on the pushq.
X	 */
X	if (occupation) return 0;
X	if (in_doagain) return (shead != stail) ? saveq[stail++] : 0;
X	else		return (phead != ptail) ? pushq[ptail++] : 0;
X}
X
Xchar
Xpgetchar() {		/* curtesy of aeb@cwi.nl */
X	register int ch;
X
X	if(!(ch = popch()))
X		ch = tgetch();
X	return(ch);
X}
X
X/* A ch == 0 resets the pushq */
Xvoid
Xpushch(ch)
Xchar ch;
X{
X	if (!ch)
X		phead = ptail = 0;
X	if (phead < BSIZE)
X		pushq[phead++] = ch;
X	return;
X}
X
X/* A ch == 0 resets the saveq.  Only save keystrokes when not
X * replaying a previous command.
X */
Xvoid
Xsavech(ch)
Xchar ch;
X{
X	if (!in_doagain) {
X		if (!ch)
X			phead = ptail = shead = stail = 0;
X		else if (shead < BSIZE)
X			saveq[shead++] = ch;
X	}
X	return;
X}
X#endif /* REDO */
X
Xstatic int
Xdoextcmd()	/* here after # - now read a full-word command */
X{
X	char buf[BUFSZ];
X	register struct ext_func_tab *efp = extcmdlist;
Xagain:
X	pline("# ");
X#ifdef COM_COMPL
X	get_ext_cmd(buf);
X#else
X	getlin(buf);
X#endif
X	clrlin();
X	if(buf[0] == '\0' || buf[0] == '\033')
X		return 0;
X	if(buf[0] == '?') {
X		(void) doextlist();
X		goto again;
X	}
X	while(efp->ef_txt) {
X		if(!strcmp(efp->ef_txt, buf))
X			return (*(efp->ef_funct))();
X		efp++;
X	}
X	pline("%s: unknown extended command.", buf);
X	return 0;
X}
X
Xint
Xdoextlist()	/* here after #? - now list all full-word commands */
X{
X	register struct ext_func_tab *efp = extcmdlist;
X	char     buf[BUFSZ];
X
X	set_pager(0);
X	if(page_line("") ||
X	   page_line("            Extended Commands List") ||
X	   page_line("") ||
X	   page_line("    Press '#', then type (first letter only):") ||
X	   page_line(""))					 goto quit;
X
X	while(efp->ef_txt) {
X
X		Sprintf(buf, "    %-8s  - %s.", efp->ef_txt, efp->ef_desc);
X		if(page_line(buf)) goto quit;
X		efp++;
X	}
X	set_pager(1);
X	return 0;
Xquit:
X	set_pager(2);
X	return 0;
X}
X
X#ifdef POLYSELF
Xstatic int
Xdomonability()
X{
X	if (can_breathe(uasmon)) return dobreathe();
X	else if (attacktype(uasmon, AT_SPIT)) return dospit();
X	else if (u.usym == S_NYMPH) return doremove();
X	else if (u.usym == S_UMBER) return doconfuse();
X	else if (is_were(uasmon)) return dosummon();
X	else if (webmaker(uasmon)) return dospinweb();
X	else if (is_hider(uasmon)) return dohide();
X	else if (u.umonnum >= 0)
X		pline("Any special ability you may have is purely reflexive.");
X	else You("don't have a special ability!");
X	return 0;
X}
X#endif
X
X#ifdef WIZARD
Xstatic int
Xwiz_wish()	/* Unlimited wishes for wizard mode by Paul Polderman */
X{
X	if (wizard)	makewish();
X	else		pline("Unavailable command '^W'.");
X	return 0;
X}
X
Xstatic int
Xwiz_identify()
X{
X	struct obj *obj;
X
X	if (!wizard)
X		pline("Unavailable command '^I'.");
X	else {
X		for (obj = invent; obj; obj = obj->nobj)
X			if (!objects[obj->otyp].oc_name_known || !obj->known
X						|| !obj->dknown || !obj->bknown)
X				(void) identify(obj);
X	}
X	return 0;
X}
X
Xstatic int
Xwiz_map()
X{
X	if (wizard)	do_mapping();
X	else		pline("Unavailable command '^F'.");
X	return 0;
X}
X
Xstatic int
Xwiz_genesis()
X{
X	if (wizard)	(void) create_particular();
X	else		pline("Unavailable command '^G'.");
X	return 0;
X}
X
Xstatic int
Xwiz_where()
X{
X	if (wizard) {
X		pline("Medusa:%d  Wiz:%d  Big:%d", medusa_level, wiz_level, bigroom_level);
X#ifdef STRONGHOLD
X#  ifdef MUSIC
X		pline("Castle:%d (tune %s)  Tower:%d-%d", 
X		      stronghold_level, tune, tower_level, tower_level+2);
X#  else
X		pline("Castle:%d  Tower:%d-%d",
X		      stronghold_level, tower_level, tower_level+2);
X#  endif
X#endif
X#ifdef REINCARNATION
X		pline("Rogue:%d", rogue_level);
X#endif
X#ifdef ORACLE
X		pline("Oracle:%d", oracle_level);
X#endif
X	}
X	else	pline("Unavailable command '^O'.");
X	return 0;
X}
X
Xstatic int
Xwiz_detect()
X{
X	if(wizard)  (void) findit();
X	else	    pline("Unavailable command '^E'.");
X	return 0;
X}
X
Xstatic int
Xwiz_level_tele()
X{
X	if (wizard)	level_tele();
X	else		pline("Unavailable command '^V'.");
X	return 0;
X}
X
X#endif /* WIZARD */
X
Xvoid
Xenlightenment() {
X
X	cornline(0, "Current Attributes:");
X
X	if (u.ualign == 0) cornline(1, "You are nominally aligned.");
X	else if (u.ualign > 3) cornline(1, "You are stridently aligned.");
X	else if (u.ualign > 0) cornline(1, "You are haltingly aligned.");
X	else cornline(1, "You have strayed.");
X
X	if (Adornment) cornline(1, "You are adorned.");
X	if (Teleportation) cornline(1, "You can teleport.");
X	if (Regeneration) cornline(1, "You regenerate.");
X	if (Searching) cornline(1, "You have automatic searching.");
X	if (See_invisible) cornline(1, "You see invisible.");
X	if (Stealth) cornline(1, "You are stealthy.");
X	if (Levitation) cornline(1, "You are levitating.");
X	if (Hunger) cornline(1, "You have hunger.");
X	if (Aggravate_monster) cornline(1, "You aggravate monsters.");
X	if (Poison_resistance) cornline(1, "You are poison resistant.");
X	if (Fire_resistance) cornline(1, "You are fire resistant.");
X	if (Cold_resistance) cornline(1, "You are cold resistant.");
X	if (Shock_resistance) cornline(1, "You are shock resistant.");
X	if (Sleep_resistance) cornline(1, "You are sleep resistant.");
X	if (Disint_resistance) cornline(1, "You are disintegration-resistant.");
X	if (Protection_from_shape_changers)
X		cornline(1, "You are protected from shape changers.");
X	if (Conflict) cornline(1, "You cause conflict.");
X	if (Protection) cornline(1, "You are protected.");
X	if (Warning) cornline(1, "You are warned.");
X	if (Teleport_control) cornline(1, "You have teleport control.");
X	if (Polymorph) cornline(1, "You are polymorphing.");
X	if (Polymorph_control) cornline(1, "You have polymorph control.");
X	if (Telepat) cornline(1, "You are telepathic.");
X	if (Fast) cornline(1, "You are fast.");
X	/* if (Stunned) cornline(1, "You are stunned."); */
X	/* if (Confusion) cornline(1, "You are confused."); */
X	/* if (Sick) cornline(1, "You are sick."); */
X	/* if (Blinded) cornline(1, "You are blinded."); */
X	if (Invisible) cornline(1, "You are invisible.");
X	else if (Invis) cornline(1, "You are invisible to others.");
X	if (Wounded_legs) {
X		char buf[41];
X
X		Sprintf(buf, "You have wounded %s.",
X						makeplural(body_part(LEG)));
X		cornline(1, buf);
X	}
X	if (Stoned) cornline(1, "You are turning to stone.");
X	/* if (Hallucination) cornline(1, "You are hallucinating."); */
X	if (Glib) {
X		char buf[41];
X
X		Sprintf(buf, "You have slippery %s.",
X						makeplural(body_part(FINGER)));
X		cornline(1, buf);
X	}
X	if (Reflecting) cornline(1, "You have reflection.");
X	if (Strangled) cornline(1, "You are being strangled.");
X	if (Lifesaved) cornline(1, "Your life will be saved.");
X	if (Fumbling) cornline(1, "You fumble.");
X	if (Jumping) cornline(1, "You can jump.");
X	if (Wwalking) cornline(1, "You can walk on water.");
X	if (Antimagic) cornline(1, "You are magic-protected.");
X	if (Displaced) cornline(1, "You are displaced.");
X	if (Clairvoyant) cornline(1, "You are clairvoyant.");
X	if (stone_luck(TRUE) > 0) cornline(1, "You have extra luck.");
X	if (stone_luck(TRUE) < 0) cornline(1, "You have reduced luck.");
X	if (carrying(LUCKSTONE)) {
X		if (stone_luck(FALSE) <= 0)
X			cornline(1, "Bad luck does not time out for you.");
X		if (stone_luck(FALSE) >= 0)
X			cornline(1, "Good luck does not time out for you.");
X	}
X
X	cornline(2, "");
X	return;
X}
X
X#if defined(WIZARD) || defined(EXPLORE_MODE)
Xstatic int
Xwiz_attributes()
X{
X	if (wizard || discover)
X		enlightenment();
X	else
X		pline("Unavailable command '^X'.");
X	return 0;
X}
X#endif /* WIZARD || EXPLORE_MODE */
X
Xconst struct func_tab cmdlist[]={
X	{'\004', /* ^D */ dokick},	/* "D" is for door!...? */
X#ifdef WIZARD
X	{'\005', /* ^E */ wiz_detect},
X	{'\006', /* ^F */ wiz_map},
X	{'\007', /* ^G */ wiz_genesis},
X	{'\011', /* ^I */ wiz_identify},
X	{'\017', /* ^O */ wiz_where},
X#endif
X	{'\020', /* ^P */ doredotopl},
X	{'\022', /* ^R */ doredraw},
X	{'\024', /* ^T */ dotele},
X#ifdef WIZARD
X	{'\026', /* ^V */ wiz_level_tele},
X	{'\027', /* ^W */ wiz_wish},
X#endif
X#if defined(WIZARD) || defined(EXPLORE_MODE)
X	{'\030', /* ^X */ wiz_attributes},
X#endif
X#ifdef SUSPEND
X	{'\032', /* ^Z */ dosuspend},
X#endif
X	{'a', doapply},
X	{'A', doddoremarm},
X/*	'b', 'B' : go sw */
X	{'c', doclose},
X	{'C', do_mname},
X	{'d', dodrop},
X	{'D', doddrop},
X	{'e', doeat},
X	{'E', doengrave},
X/* Soon to be
X	{'f', dofight, "fighting"},
X	{'F', doFight, "fighting"},
X */
X/*	'g', 'G' : multiple go */
X/*	'h', 'H' : go west */
X	{'h', dohelp}, /* if number_pad is set */
X	{'i', ddoinv},
X	{'I', dotypeinv},		/* Robert Viduya */
X/*	'j', 'J', 'k', 'K', 'l', 'L', 'm', 'M', 'n', 'N' : move commands */
X	{'j', dojump}, /* if number_pad is on */
X	{'k', dokick}, /* if number_pad is on */
X	{'l', doloot}, /* if number_pad is on */
X/*	'n' prefixes a count if number_pad is on */
X	{'N', ddocall}, /* if number_pad is on */
X	{'o', doopen},
X	{'O', doset},
X	{'p', dopay},
X	{'P', doputon},
X	{'q', dodrink},
X	{'Q', done2},
X	{'r', doread},
X	{'R', doremring},
X	{'s', dosearch, "searching"},
X	{'S', dosave},
X	{'t', dothrow},
X	{'T', dotakeoff},
X/*	'u', 'U' : go ne */
X	{'u', dountrap}, /* if number_pad is on */
X	{'v', doversion},
X	{'V', dohistory},
X	{'w', dowield},
X	{'W', dowear},
X#ifdef SPELLS
X	{'x', dovspell},			/* Mike Stephenson */
X#endif
X/*	'y', 'Y' : go nw */
X	{'z', dozap},
X#ifdef SPELLS
X	{'Z', docast},
X#endif
X	{'<', doup},
X	{'>', dodown},
X	{'/', dowhatis},
X	{'&', dowhatdoes},
X	{'?', dohelp},
X#ifdef SHELL
X	{'!', dosh},
X#endif
X	{'.', donull, "waiting"},
X	{' ', donull, "waiting"},
X	{',', dopickup},
X	{':', dolook},
X	{'^', doidtrap},
X	{'\\', dodiscovered},		/* Robert Viduya */
X	{'@', dotogglepickup},
X	{WEAPON_SYM,  doprwep},
X	{ARMOR_SYM,  doprarm},
X	{RING_SYM,  doprring},
X	{AMULET_SYM, dopramulet},
X	{TOOL_SYM, doprtool},
X	{GOLD_SYM, doprgold},
X#ifdef SPELLS
X	{SPBOOK_SYM, dovspell},			/* Mike Stephenson */
X#endif
X	{'#', doextcmd},
X	{0,0,0}
X};
X
Xconst struct ext_func_tab extcmdlist[] = {
X	"chat", "talk to someone", dotalk,	/* converse? */
X	"dip", "dip an object into something", dodip,
X	"force", "force the lock on a chest", doforce,
X	"jump", "jump to a location", dojump,
X	"loot", "loot a box on the floor", doloot,
X#ifdef POLYSELF
X	"monster", "use a monster's special ability", domonability,
X#endif
X	"name", "name an item or type of object", ddocall,
X#ifdef THEOLOGY
X	"offer", "offer a sacrifice to the gods", dosacrifice,
X	"pray", "pray to the gods for help", dopray,
X#endif
X	"rub", "rub a lamp", dorub,
X	"sit", "sit down", dosit,
X	"turn", "turn undead", doturn,
X	"untrap", "untrap a trapped object", dountrap,
X	"wipe", "wipe your face off", dowipe,
X	"?", "get this list of extended commands", doextlist,
X	NULL, NULL, donull
X};
X
Xchar
Xunctrl(sym)
Xchar sym;
X{
X    return (sym >= ('A' & 037) && sym <= ('Z' & 037)) ? sym + 0140 : sym;
X}
X
Xvoid
Xrhack(cmd)
Xregister char *cmd;
X{
X	register struct func_tab *tlist = cmdlist;
X	boolean firsttime = FALSE;
X	register int res;
X
X	if(!cmd) {
X		firsttime = TRUE;
X		flags.nopick = 0;
X		cmd = parse();
X	}
X	if(*cmd == (char)033) {
X		flags.move = 0;
X		return;
X	}
X#ifdef REDO
X	if (*cmd == DOAGAIN && !in_doagain && saveq[0]) {
X		in_doagain = TRUE;
X		stail = 0;
X		rhack(NULL);	/* read and execute command */
X		in_doagain = FALSE;
X		return;
X	}
X	/* Special case of *cmd == ' ' handled better below */
X	if(!*cmd || *cmd == (char)0377) {
X#else
X	if(!*cmd || *cmd == (char)0377 || (flags.no_rest_on_space && *cmd == ' ')){
X#endif
X		bell();
X		flags.move = 0;
X		return;		/* probably we just had an interrupt */
X	}
X	if(movecmd(*cmd)) {
X	walk:
X		if(multi) flags.mv = 1;
X		domove();
X		return;
X	}
X	if(!flags.num_pad && movecmd(lowc(*cmd))) {
X		flags.run = 1;
X	rush:
X		if(firsttime){
X			if(!multi) multi = COLNO;
X			u.last_str_turn = 0;
X		}
X		flags.mv = 1;
X		domove();
X		return;
X	}
X	if(*cmd == 'g' && movecmd(cmd[1])) {
X		flags.run = 2;
X		goto rush;
X	}
X	if(((*cmd == 'G' || (flags.num_pad && *cmd == '5')) && 
X	    movecmd(lowc(cmd[1]))) || movecmd(unctrl(*cmd))) {
X		flags.run = 3;
X		goto rush;
X	}
X	if(*cmd == 'm' && movecmd(cmd[1])) {
X		flags.run = 0;
X		flags.nopick = 1;
X		goto walk;
X	}
X	if(*cmd == 'M' && movecmd(lowc(cmd[1]))) {
X		flags.run = 1;
X		flags.nopick = 1;
X		goto rush;
X	}
X	while(tlist->f_char) {
X		if(*cmd == tlist->f_char){
X			/* Special case of *cmd == ' ' handled here */
X			if (*cmd == ' ' && flags.no_rest_on_space)
X				break;
X
X			/* Now control-A can stop lengthy commands */
X			/* in the PC version only -- use ^C-N otherwise */
X			if (tlist->f_text && !occupation && multi)
X				set_occupation(tlist->f_funct, tlist->f_text,
X					multi);
X			res = (*(tlist->f_funct))();
X			if(!res) {
X				flags.move = 0;
X				multi = 0;
X			}
X			return;
X		}
X		tlist++;
X	}
X	{ char expcmd[10];
X	  register char *cp = expcmd;
X	  while(*cmd && cp-expcmd < sizeof(expcmd)-2) {
X		if(*cmd >= 040 && *cmd < 0177)
X			*cp++ = *cmd++;
X		else {
X			*cp++ = '^';
X			*cp++ = *cmd++ ^ 0100;
X		}
X	  }
X	  *cp++ = 0;
X	  pline("Unknown command '%s'.", expcmd);
X	}
X	multi = flags.move = 0;
X	return;
X}
X
Xchar
Xlowc(sym)
Xchar sym;
X{
X    return (sym >= 'A' && sym <= 'Z') ? sym+'a'-'A' : sym;
X}
X
X/* 'rogue'-like direction commands */
Xconst char sdir[] = "hykulnjb><";
Xconst char ndir[] = "47896321><";
Xconst schar xdir[10] = { -1,-1, 0, 1, 1, 1, 0,-1, 0, 0 };
Xconst schar ydir[10] = {  0,-1,-1,-1, 0, 1, 1, 1, 0, 0 };
Xconst schar zdir[10] = {  0, 0, 0, 0, 0, 0, 0, 0, 1,-1 };
X
X#ifdef WALKIES
Xint
Xxytod(x, y)	/* convert an x,y pair into a direction code */
Xschar x, y;
X{
X	register int dd;
X
X	for(dd = 0; dd < 8; dd++)
X	    if(x == xdir[dd] && y == ydir[dd]) return dd;
X
X	return -1;
X}
X
Xvoid
Xdtoxy(cc,dd)	/* convert a direction code into an x,y pair */
Xcoord *cc;
Xregister int dd;
X{
X	cc->x = xdir[dd];
X	cc->y = ydir[dd];
X	return;
X}
X#endif /* WALKIES */
X
Xint
Xmovecmd(sym)	/* also sets u.dz, but returns false for <> */
Xchar sym;
X{
X	register char *dp, *sdp = flags.num_pad ? ndir : sdir;
X
X	u.dz = 0;
X	if(!(dp = index(sdp, sym))) return 0;
X	u.dx = xdir[dp-sdp];
X	u.dy = ydir[dp-sdp];
X	u.dz = zdir[dp-sdp];
X	return !u.dz;
X}
X
Xint
Xgetdir(s)
Xboolean s;
X{
X	char dirsym;
X
X#ifdef REDO
X	if (!in_doagain)
X#endif
X	    if(s) pline("In what direction? ");
X	dirsym = readchar();
X#ifdef REDO
X	savech(dirsym);
X#endif
X	if(dirsym == '.' || dirsym == 's')
X		u.dx = u.dy = u.dz = 0;
X	else if(!movecmd(dirsym) && !u.dz) {
X		if(!index(quitchars, dirsym))
X			pline("What a strange direction!");
X		return 0;
X	}
X	if(!u.dz && (Stunned || (Confusion && !rn2(5)))) confdir();
X	return 1;
X}
X
Xvoid
Xconfdir()
X{
X	register int x = rn2(8);
X	u.dx = xdir[x];
X	u.dy = ydir[x];
X	return;
X}
X
Xint
Xisok(x,y)
Xregister int x, y;
X{
X	/* x corresponds to curx, so x==1 is the first column. Ach. %% */
X	return x >= 1 && x <= COLNO-1 && y >= 0 && y <= ROWNO-1;
X}
END_OF_FILE
if test 17734 -ne `wc -c <'src/cmd.c'`; then
    echo shar: \"'src/cmd.c'\" unpacked with wrong size!
fi
# end of 'src/cmd.c'
fi
if test -f 'src/pray.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/pray.c'\"
else
echo shar: Extracting \"'src/pray.c'\" \(33283 characters\)
sed "s/^X//" >'src/pray.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)pray.c	3.0	89/01/10
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include "hack.h"
X
X#ifdef THEOLOGY
X
X#define ALIGNLIM 	(5L + (moves/200L))
X
Xstruct ghods {
X
X	char	classlet;
X	char	*law, *balance, *chaos;
X}  gods[] = {
X
X'A', /* Central American */	"Quetzalcotl", "Camaxtli", "Huhetotl",
X'B', /* Celtic */		"Nuada", "Dagda", "Morrigan",
X'C', /* Babylonian */		"Anu", "Ishtar", "Anshar",
X'E', /* Elven */		"Solonor Thelandira",
X				"Aerdrie Faenya", "Erevan Ilesere",
X'H', /* Greek */		"Athena", "Hermes", "Poseidon",
X'K', /* Celtic */		"Lugh", "Brigit", "Macannan Mac Lir",
X#ifdef NAMED_ITEMS
X/* It'd look funny if someone got a sword to steal souls for Arioch but Arioch
X * goes with the wrong character class...
X */
X'P', /* Hyborian */		"Mitra", "Crom", "Set",
X#else
X'P', /* Melnibonean */		"Donblas", "Grome", "Arioch",
X#endif
X'R', /* Nehwon */		"Votishal", "Death", "Rat God",
X'S', /* Japanese */		"Amaterasu Omikami", "Raiden", "Susanowo",
X'T', /* Chinese */		"Shan Lai Ching", "Chih Sung-tzu", "Huan Ti",
X'V', /* Norse */		"Tyr", "Balder", "Loki",
X'W', /* Egyptian */		"Ptah", "Thoth", "Anhur",
X0,0,0,0
X};
X
X#define TROUBLE_STONED 1
X#define TROUBLE_STRANGLED 2
X#define TROUBLE_SICK 3
X#define TROUBLE_STARVING 4
X#define TROUBLE_HIT 5
X#define TROUBLE_STUCK_IN_WALL 6
X
X#define TROUBLE_PUNISHED (-1)
X#define TROUBLE_LYCANTHROPE (-2)
X#define TROUBLE_CURSED_ITEMS (-3)
X#define TROUBLE_HUNGRY (-4)
X#define TROUBLE_POISONED (-5)
X#define TROUBLE_HALLUCINATION (-6)
X#define TROUBLE_BLIND (-7)
X#define TROUBLE_WOUNDED_LEGS (-8)
X#define TROUBLE_STUNNED (-9)
X#define TROUBLE_CONFUSED (-10)
X
X/* We could force rehumanize of polyselfed people, but we can't tell
X   unintentional shape changes from the other kind. Oh well. */
X
X/* Return 0 if nothing particular seems wrong, positive numbers for
X   serious trouble, and negative numbers for comparative annoyances. This
X   returns the worst problem. There may be others, and the gods may fix
X   more than one.
X
XThis could get as bizarre as noting surrounding opponents, (or hostile dogs),
Xbut that's really hard.
X */
X
X#define ugod_is_angry() (u.ualign < 0)
X#ifdef ALTARS
X#define on_altar()	IS_ALTAR(levl[u.ux][u.uy].typ)
X#define on_shrine()	((levl[u.ux][u.uy].altarmask & A_SHRINE) != 0)
X#endif
X
Xstatic int
Xin_trouble()
X{
X	register struct obj *otmp;
X	int i, j, count=0;
X
X/* Borrowed from eat.c */
X
X#define	SATIATED	0
X#define NOT_HUNGRY	1
X#define	HUNGRY		2
X#define	WEAK		3
X#define	FAINTING	4
X#define FAINTED		5
X#define STARVED		6
X
X	if(Stoned) return(TROUBLE_STONED);
X	if(Strangled) return(TROUBLE_STRANGLED);
X	if(Sick) return(TROUBLE_SICK);
X	if(u.uhs >= WEAK) return(TROUBLE_STARVING);
X	if(u.uhp < 5 || (u.uhp*7 < u.uhpmax)) return(TROUBLE_HIT);
X	for (i= -1; i<=1; i++) for(j= -1; j<=1; j++) {
X		if (!i && !j) continue;
X		if (!isok(u.ux+i, u.uy+j) || IS_ROCK(levl[u.ux+i][u.uy+j].typ))
X			count++;
X	}
X	if(count==8
X#ifdef POLYSELF
X	    && !passes_walls(uasmon)
X#endif
X	    ) return(TROUBLE_STUCK_IN_WALL);
X	if(Punished) return(TROUBLE_PUNISHED);
X#ifdef POLYSELF
X	if(u.ulycn >= 0) return(TROUBLE_LYCANTHROPE);
X#endif
X	for(otmp=invent; otmp; otmp=otmp->nobj)
X		if((otmp->otyp==LOADSTONE || otmp->otyp==LUCKSTONE) &&
X			otmp->cursed) 
X		    return(TROUBLE_CURSED_ITEMS);
X	if((uarmh && uarmh->cursed) ||	/* helmet */
X	   (uarms && uarms->cursed) ||	/* shield */
X	   (uarmg && uarmg->cursed) ||	/* gloves */
X	   (uarm && uarm->cursed) ||	/* armor */
X	   (uarmc && uarmc->cursed) ||	/* cloak */
X	   (uarmf && uarmf->cursed) ||	/* boots */
X#ifdef SHIRT
X	   (uarmu && uarmu->cursed) ||  /* shirt */
X#endif
X	   (uwep && (uwep->olet == WEAPON_SYM || uwep->otyp==PICK_AXE
X		|| uwep->otyp==TIN_OPENER || uwep->otyp==HEAVY_IRON_BALL) &&
X		(uwep->cursed)) ||
X	   (uleft && uleft->cursed) ||
X	   (uright && uright->cursed) ||
X	   (uamul && uamul->cursed) ||
X	   (ublindf && ublindf->cursed))
X
X	   return(TROUBLE_CURSED_ITEMS);
X
X	if(u.uhs >= HUNGRY) return(TROUBLE_HUNGRY);
X	for(i=0; i<A_MAX; i++)
X	    if(ABASE(i) < AMAX(i)) return(TROUBLE_POISONED);
X	if(Hallucination) return(TROUBLE_HALLUCINATION);
X	if(Blinded > 1) return(TROUBLE_BLIND);
X	if(Wounded_legs) return (TROUBLE_WOUNDED_LEGS);
X	if(HStun) return (TROUBLE_STUNNED);
X	if(HConfusion) return (TROUBLE_CONFUSED);
X
X	return(0);
X}
X
Xstatic void
Xfix_worst_trouble(trouble)
Xregister int trouble;
X{
X	int i;
X	u.ublesscnt += rnz(100);
X	switch (trouble) {
X	    case TROUBLE_STONED:
X		    You("feel more limber.");
X		    Stoned = 0;
X		    break;
X	    case TROUBLE_STRANGLED:
X		    You("can breathe again.");
X		    Strangled = 0;
X		    break;
X	    case TROUBLE_HUNGRY:
X	    case TROUBLE_STARVING:
X		    Your("stomach feels content.");
X		    init_uhunger ();
X		    losestr(-1);
X		    flags.botl = 1;
X		    break;
X	    case TROUBLE_SICK:
X		    You("feel better.");
X		    make_sick(0L,FALSE);
X		    break;
X	    case TROUBLE_HIT:
X		    if (!Blind) {
X			const char *tmp = Hallucination ? hcolor() : golden;
X			pline("A%s %s glow surrounds you.",
X			      index(vowels,*tmp) ? "n" : "", tmp);
X		    } else You("feel much better.");
X		    u.uhp = u.uhpmax += 5;
X		    flags.botl = 1;
X		    break;
X	    case TROUBLE_STUCK_IN_WALL:
X		    Your("surroundings change.");
X		    tele();
X		    break;
X	    case TROUBLE_PUNISHED:
X		    Your("chain disappears.");
X		    unpunish();
X		    break;
X#ifdef POLYSELF
X	    case TROUBLE_LYCANTHROPE:
X		    You("feel purified.");
X		    if(uasmon == &mons[u.ulycn] && !Polymorph_control)
X			rehumanize();
X		    u.ulycn = -1;       /* now remove the curse */
X		    break;
X#endif
X	    case TROUBLE_CURSED_ITEMS:
X		    {	struct obj *otmp;
X			char * what;
X			otmp = (struct obj *)0;
X			what = NULL;
X			if (uarmh && uarmh->cursed) 	/* helmet */
X			    otmp = uarmh;
X			else if (uarms && uarms->cursed) /* shield */
X			    otmp = uarms;
X			else if (uarmg && uarmg->cursed) /* gloves */
X			    otmp = uarmg;
X			else if (uarm && uarm->cursed) /* armor */
X			    otmp = uarm;
X			else if (uarmc && uarmc->cursed) /* cloak */
X			    otmp = uarmc;
X			else if (uarmf && uarmf->cursed) /* boots */
X			    otmp = uarmf;
X#ifdef SHIRT
X			else if (uarmu && uarmu->cursed) /* shirt */
X			    otmp = uarmu;
X#endif
X			else if (uleft && uleft->cursed) {
X			    otmp = uleft;
X			    what = "left ring softly glows";
X			} else if (uright && uright->cursed) {
X			    otmp = uright;
X			    what = "right ring softly glows";
X			} else if (uamul && uamul->cursed) /* amulet */
X			    otmp = uamul;
X			else if (ublindf && ublindf->cursed) /* blindfold */
X			    otmp = ublindf;
X			else if (welded(uwep)) otmp = uwep;
X			else {
X			    for(otmp=invent; otmp; otmp=otmp->nobj)
X				if ((otmp->otyp==LOADSTONE ||
X				     otmp->otyp==LUCKSTONE) && otmp->cursed)
X					break;
X			}
X
X			otmp->cursed = 0;
X			otmp->bknown = 1;
X			if (!Blind)
X			    Your("%s %s.",
X				   what ? what : aobjnam (otmp, "softly glow"),
X				   Hallucination ? hcolor() : amber);
X			break;
X		    }
X	    case TROUBLE_HALLUCINATION:
X		    pline ("Looks like you are back in Kansas.");
X		    make_hallucinated(0L,FALSE);
X		    break;
X	    case TROUBLE_BLIND:
X		    pline ("Your %s feel better.", makeplural(body_part(EYE)));
X		    make_blinded(0L,FALSE);
X		    break;
X	    case TROUBLE_POISONED:
X		    if (Hallucination)
X			pline("There's a tiger in your tank.");
X		    else
X			You("feel in good health again.");
X		    for(i=0; i<A_MAX; i++) {
X			if(ABASE(i) < AMAX(i)) {
X				ABASE(i) = AMAX(i);
X				flags.botl = 1;
X			}
X		    }
X		    break;
X	    case TROUBLE_WOUNDED_LEGS:
X		    heal_legs();
X		    break;
X	    case TROUBLE_STUNNED:
X		    make_stunned(0L,TRUE);
X		    break;
X	    case TROUBLE_CONFUSED:
X		    make_confused(0L,TRUE);
X		    break;
X	}
X}
X
Xstatic void
Xangrygods() {
X	register int	tmp;
X
X	u.ublessed = 0;
X
X	/* changed from tmp = u.ugangr + abs (u.uluck) -- rph */
X	tmp =  3*u.ugangr +
X	       (u.uluck > 0 || u.ualign > 3 ? -u.uluck/3 : -u.uluck);
X	if (tmp < 0) tmp = 0; /* possible if bad alignment but good luck */
X	tmp =  (tmp > 15 ? 15 : tmp);  /* lets be a little reasonable */
X	switch (tmp ? rn2(tmp): 0) {
X
X	    case 0:
X	    case 1:	if (Hallucination)
X			    You("feel %sholy dread.",
X				  u.ualigntyp == U_CHAOTIC ? "an un" : "a ");
X			else You("feel that %s is %s.",
X#  ifdef ALTARS
X				   on_altar() ? a_gname() : u_gname(),
X#  else
X				   u_gname(),
X#  endif
X				   u.ualigntyp == U_NEUTRAL ? "offended" : "angry");
X			break;
X	    case 2:
X	    case 3:
X# ifdef POLYSELF
X			pline("A voice booms out:  \"Thou %s, %s.\"",
X			      ugod_is_angry() ? "hast strayed from the path" :
X					        "art arrogant",
X			      u.usym == S_HUMAN ? "mortal" : "creature");
X# else
X			pline("A voice booms out:  \"Thou %s, mortal.\"",
X			      ugod_is_angry() ? "hast strayed from the path" :
X					        "art arrogant");
X# endif
X			pline("\"Thou must relearn thy lessons!\"");
X			adjattrib(A_WIS, -1, FALSE);
X			if (u.ulevel > 1) {
X			    losexp();
X			    if(u.uhp < 1) u.uhp = 1;
X			    if(u.uhpmax < 1) u.uhpmax = 1;
X			} else  {
X			    u.uexp = 0;
X			    flags.botl = 1;
X			}
X			break;
X	    case 6:	if (!Punished) {
X			    punish((struct obj *)0);
X			    break;
X			} /* else fall thru */
X	    case 4:
X	    case 5:	if (!Blind) {
X			    const char *temp = Hallucination ? hcolor() : black;
X			    pline("A%s %s glow surrounds you.",
X				  index(vowels,*temp) ? "n" : "", temp);
X			}
X			rndcurse();
X			break;
X	    case 7:
X	    case 8:	pline("A voice booms out:  \"Thou durst call upon me?\"");
X# ifdef POLYSELF
X			pline("\"Then die, %s!\"",
X			      u.usym == S_HUMAN ? "mortal" : "creature");
X# else
X			pline("\"Then die, mortal!\"");
X# endif
X			(void) makemon(&mons[ndemon()], u.ux, u.uy);
X			break;
X
X	    default:	pline("Suddenly, a bolt of lightning strikes you!");
X			if (Reflecting) {
X			    shieldeff(u.ux, u.uy);
X			    if (Blind)
X				pline("For some reason you're unaffected.");
X			    else {
X				if (Reflecting & W_AMUL) {
X				    pline("It reflects from your medallion.");
X#if defined(EXPLORE_MODE) || defined(WIZARD)
X				    makeknown(AMULET_OF_REFLECTION);
X#endif
X				} else {
X				    pline("It reflects from your shield.");
X	/* No ifdef here since they could survive with an amulet of
X	 * life saving which wasn't possible above.
X	 */
X				    makeknown(SHIELD_OF_REFLECTION);
X				}
X			    }
X	You("hear a cosmic sigh, and sense a decision being made.");
X	pline("A wide-angle disintegration beam hits you!");
X	goto ohno;
X			} else if (Shock_resistance) {
X				shieldeff(u.ux, u.uy);
X				pline("It seems not to affect you.");
X			pline("However, the ensuing disintegration beam does.");
Xohno:
X				if (Disint_resistance) {
X	You("bask in the disintegration beam for a minute...");
X	pline("A voice rings out:  \"I believe it not!\"");
X					break;
X				}
X			}
X			You("fry to a crisp.");
X			killer = "holy wrath";
X			done("died");
X			break;
X	}
X	u.ublesscnt = rnz(300);
X	return;
X}
X
Xstatic void
Xpleased() {
X	char	*tmp;
X	int trouble = in_trouble ();	/* what's your worst difficulty? */
X	int pat_on_head = 0;
X
X	if (u.ugangr > 0) u.ugangr--;
X	You("feel that %s is pleased.",
X#ifndef ALTARS
X		   u_gname());
X#else
X		   on_altar() ? a_gname() : u_gname());
X
X	/* not your deity */
X	if (on_altar() &&
X	    (levl[u.ux][u.uy].altarmask & ~A_SHRINE) != u.ualigntyp + 1) {
X		adjalign(-1);
X		return;
X	} else if (u.ualign < 2) adjalign(1);
X#endif
X
X
X	/* depending on your luck, the gods will:
X	   - fix your worst problem if it's major.
X	   - fix all your major problems.
X	   - fix your worst problem if it's minor.
X	   - fix all of your problems.
X	   - do you a gratuitous favor.
X
X	   if you make it to the the last category, you roll randomly again
X	   to see what they do for you.
X
X	   If your luck is at least 0, then you are guaranteed rescued
X	   from your worst major problem. */
X
X	if (!trouble) pat_on_head = 1;
X	else {
X#ifdef ALTARS
X	    int action = rn1(on_altar() ? 3 + on_shrine() : 2, u.uluck+1);
X
X	    if (!on_altar()) action = max(action,2);
X#else
X	    int action = rn1(4,u.uluck+1);
X#endif
X
X	    switch(min(action,5)) {
X		case 5: pat_on_head = 1;
X		case 4: do fix_worst_trouble(trouble);
X			while(trouble = in_trouble());
X			break;
X
X		case 3: fix_worst_trouble(trouble);
X		case 2: while((trouble = in_trouble()) > 0)
X			    fix_worst_trouble(trouble);
X			break;
X
X		case 1: if (trouble > 0) fix_worst_trouble(trouble);
X	    }
X	}
X
X    if(pat_on_head)
X	switch(rn2((u.uluck + 6)>>1))  {
X
X	    case 0:	break;
X	    case 1:
X			if(uwep && (uwep->olet == WEAPON_SYM || uwep->otyp
X				== PICK_AXE) && (!uwep->blessed)) {
X			    if (uwep->cursed) {
X				uwep->cursed = 0;
X				uwep->bknown = 1;
X				if (!Blind)
X				    Your("%s %s.",
X					  aobjnam(uwep, "softly glow"),
X					  Hallucination ? hcolor() : amber);
X			    } else if(uwep->otyp < BOW) {
X				uwep->blessed = uwep->bknown = 1;
X				if (!Blind) {
X				    tmp = Hallucination ? hcolor() : light_blue;
X				    Your("%s with a%s %s aura.",
X					  aobjnam(uwep, "softly glow"),
X					  index(vowels,*tmp) ? "n" : "", tmp);
X				}
X			    }
X			}
X			break;
X	    case 3:
X#if defined(STRONGHOLD) && defined(MUSIC)
X			/* takes 2 hints to get the music to enter the Stronghold */
X			if (flags.soundok) {
X			    if(music_heard < 1) {
X				pline("A voice booms out:  \"Hark, mortal!\"");
X				verbalize("To enter the castle, thou must play the right tune!");
X				music_heard++;
X				break;
X			    } else if (music_heard < 2) {
X				You("hear a divine music...");
X				pline("It sounds like:  \"%s\".", tune);
X				music_heard++;
X				break;
X			    }
X			}
X			/* Otherwise, falls into next case */
X#endif
X	    case 2:	if (!Blind) {
X			    tmp = Hallucination ? hcolor() : golden;
X			    You("are surrounded by a%s %s glow.",
X				  index(vowels,*tmp) ? "n" : "", tmp);
X			}
X			u.uhp = u.uhpmax += 5;
X			ABASE(A_STR) = AMAX(A_STR);
X			if (u.uhunger < 900)	init_uhunger();
X			if (u.uluck < 0)	u.uluck = 0;
X			make_blinded(0L,TRUE);
X			flags.botl = 1;
X			break;
X	    case 4:
X		{	register struct obj *otmp;
X
X			tmp = Hallucination ? hcolor() : light_blue;
X			if (Blind)
X				You("feel the power of %s.", u_gname());
X			else You("are surrounded by a%s %s aura.",
X					index(vowels,*tmp) ? "n" : "", tmp);
X			for(otmp=invent; otmp; otmp=otmp->nobj) {
X				if (otmp->cursed) {
X				    otmp->cursed = 0;
X				    if (!Blind)
X					Your("%s %s.",
X					      aobjnam(otmp, "softly glow"),
X					      Hallucination ? hcolor() : amber);
X				}
X			}
X			break;
X		}
X	    case 5:	pline("A voice booms out:  \"Thou hast pleased me with thy progress,\"");
X			pline("\"and thus I grant thee the gift of ");
X			if (!(HTelepat & INTRINSIC))  {
X				HTelepat |= INTRINSIC;
X				addtopl("Telepathy!\"");
X			} else if (!(Fast & INTRINSIC))  {
X				Fast |= INTRINSIC;
X				addtopl("Speed!\"");
X			} else if (!(Stealth & INTRINSIC))  {
X				Stealth |= INTRINSIC;
X				addtopl("Stealth!\"");
X			} else {
X			    if (!(Protection & INTRINSIC))  {
X				Protection |= INTRINSIC;
X				if (!u.ublessed)  u.ublessed = rnd(3) + 1;
X			    } else u.ublessed++;
X			    addtopl("our protection!\"");
X			}
X			pline ("\"Use it wisely in my name!\"");
X			break;
X
X	    case 7:
X#ifdef ELBERETH
X			if (u.ualign > 3 && !u.uhand_of_elbereth) {
X			    u.uhand_of_elbereth = TRUE;
X			    HSee_invisible |= INTRINSIC;
X			    HFire_resistance |= INTRINSIC;
X			    HCold_resistance |= INTRINSIC;
X			    HPoison_resistance |= INTRINSIC;
X			    if (u.ualigntyp != U_CHAOTIC) {
X			        pline("A voice booms out:  \"I crown thee...\"");
X				pline("\"The Hand of Elbereth!\"");
X#ifdef NAMED_ITEMS
X				if(uwep && (uwep->otyp == LONG_SWORD)) {
X					bless(uwep);
X					uwep->bknown = 1;
X					uwep->rustfree = 1;
X					(void)oname(uwep, "Excalibur", 1);
X				}
X#endif
X			    } else {
X				register struct obj *obj;
X				pline("A voice booms out:  \"Thou art chosen to steal souls for Arioch!\"");
X				/* This does the same damage as Excalibur.
X				 * Disadvantages: doesn't do bonuses to undead;
X				 * doesn't aid searching.
X				 * Advantages: part of that bonus is a level
X				 * drain.
X				 * Disadvantage: player cannot start with a
X				 * +5 weapon and turn it into a Stormbringer.
X				 * Advantage: they don't need to already have a
X				 * sword of the right type to get it...
X				 */
X				if (Blind)
X				    pline("Something appears at your %s.",
X					makeplural(body_part(FOOT)));
X				else
X				    pline("A %s sword appears at your %s!",
X					Hallucination ? hcolor() : "black",
X					makeplural(body_part(FOOT)));
X				obj = mksobj(BROADSWORD, FALSE);
X				obj = oname(obj, "Stormbringer", 0);
X				obj->rustfree = 1;
X				obj->cursed = 0;
X				obj->blessed = 1;
X			/* Why bless it?  Why not.  After all, chaotic gods
X			 * will bless regular weapons.  And blessed really
X			 * means given sanctified to a deity, which is certainly
X			 * sensible even for Stormbringer and a chaotic deity...
X			 */
X				obj->spe = 1;
X				dropy(obj);
X			    }
X			    break;
X			}
X#endif
X
X	    case 6:	pline ("An object appears at your %s!",
X				makeplural(body_part(FOOT)));
X#ifdef SPELLS
X			(void) mkobj_at(SPBOOK_SYM, u.ux, u.uy);
X#else
X			(void) mkobj_at(SCROLL_SYM, u.ux, u.uy);
X#endif
X			break;
X
X	    default:	impossible("Confused deity!");
X			break;
X	}
X	u.ublesscnt = rnz(350);
X#ifdef HARD
X# ifndef ELBERETH
X	u.ublesscnt += (u.udemigod * rnz(1000));
X# else
X	u.ublesscnt += ((u.udemigod + u.uhand_of_elbereth) * rnz(1000));
X# endif
X#endif
X	return;
X}
X
Xstatic void
Xgods_upset()
X{
X#ifdef HARD
X	u.ugangr++;
X	angrygods();
X#else
X	if (u.ugangr++)	angrygods();
X	else {			/* exactly one warning */
X#ifdef ALTARS
X		pline("The voice of %s booms out:  \"Thou hast angered me.\"",
X				a_gname());
X#else
X		pline("A voice booms out:  \"Thou hast angered me.\"");
X#endif
X		pline("\"Disturb me again at thine own risk!\"");
X	}
X#endif
X}
X
X#ifdef ENDGAME
Xstatic const char sacrifice_types[] = { FOOD_SYM, AMULET_SYM, 0 };
X#endif
X
Xstatic void
Xconsume_offering(otmp)
Xregister struct obj *otmp;
X{
X	if (Hallucination)
X    pline ("Your sacrifice sprouts wings and a propeller and roars away!");
X	else pline ("Your sacrifice is consumed in a %s!",
X		    u.ualigntyp == U_LAWFUL ? "flash of light" : "burst of flame");
X	useup(otmp);
X}
X
Xint
Xdosacrifice()
X{
X	register struct obj *otmp;
X	int value = 0;
X
X#ifdef ALTARS
X	if (!on_altar()) {
X		You("are not standing on an altar.");
X		return 0;
X	}
X#endif /* ALTARS /**/
X
X#ifdef ENDGAME
X	if (dlevel == ENDLEVEL) {
X		if (!(otmp = getobj(sacrifice_types, "sacrifice"))) return 0;
X	} else
X		if (!(otmp = floorfood("sacrifice", 0))) return 0;
X#else
X	if (!(otmp = floorfood("sacrifice", 0))) return 0;
X#endif
X/*
X   Was based on nutritional value and aging behavior (< 50 moves).
X   Sacrificing a food ration got you max luck instantly, making the
X   gods as easy to please as an angry dog!
X
X   Now only accepts corpses, based on their level (presumably, how hard
X   they were to kill).  Human sacrifice, as well as sacrificing unicorns
X   of your alignment, is strongly discouraged.  (We can't tell whether a dog
X   corpse was tame, so you can still sacrifice it.)
X */
X
X#define MAXVALUE 17	/* Highest corpse value */
X
X	if (otmp->otyp == CORPSE) {
X	    register struct permonst *mtmp = &mons[otmp->corpsenm];
X
X	    if (otmp->corpsenm == PM_ACID_BLOB || (moves <= otmp->age + 50))
X		value = mtmp->mlevel + 1; /* only fresh kills */
X
X	    if (is_human(mtmp)) { /* Human sacrifice! */
X#ifdef POLYSELF
X		if (is_demon(uasmon))
X		    You("find the idea very satisfying.");
X		else
X#endif
X			if (u.ualigntyp != U_CHAOTIC)
X		    pline("You'll regret this infamous offense!");
X#ifdef ALTARS
X		if (levl[u.ux][u.uy].altarmask & ~A_SHRINE) {
X			/* curse the lawful/neutral altar */
X			pline("The altar is stained with human blood.");
X			levl[u.ux][u.uy].altarmask = A_CHAOS;
X			angry_priest();
X		} else {
X			register struct monst *dmon;
X			const char *color = Hallucination ? hcolor() : black;
X    /* Human sacrifice on a chaotic altar is equivalent to demon summoning */
X    pline("The blood floods over the altar, which vanishes in a%s %s cloud!",
X				index(vowels, *color) ? "n" : "", color);
X			levl[u.ux][u.uy].typ = ROOM;
X			if(Invisible) newsym(u.ux, u.uy);
X			if(dmon = makemon(&mons[dlord()], u.ux, u.uy)) {
X				You("have summoned a demon lord!");
X				if (u.ualigntyp == U_CHAOTIC) 
X					dmon->mpeaceful = 1;
X				You("are terrified, and unable to move.");
X				nomul(-3);
X			} else pline("The cloud dissipates.");
X		}
X#endif
X		if (u.ualigntyp != U_CHAOTIC) {
X			adjalign(-5);
X			u.ugangr += 3;
X			adjattrib(A_WIS, -1, TRUE);
X			if (!Inhell) angrygods();
X			change_luck(-5);
X		} else adjalign(5);
X		useup(otmp);
X		return(1);
X	    } else if (is_undead(mtmp)) { /* Not demons--no demon corpses */
X		if (u.ualigntyp != U_CHAOTIC)
X			value += 1;
X	    } else if (mtmp->mlet == S_UNICORN) {
X		int unicalign;
X
X		if (mtmp == &mons[PM_BLACK_UNICORN]) unicalign = -1;
X		else if (mtmp == &mons[PM_GREY_UNICORN]) unicalign = 0;
X		else if (mtmp == &mons[PM_WHITE_UNICORN]) unicalign = 1;
X		if (unicalign == u.ualigntyp) {
X		    pline("Such an action is an insult to %s!", (unicalign== -1)
X				? "chaos" : unicalign ? "law" : "neutrality");
X		    adjattrib(A_WIS, -1, TRUE);
X		    value = -5;
X		} else if ((unicalign == -u.ualigntyp) ||
X						(!u.ualigntyp && unicalign)) {
X		    if (u.ualign < ALIGNLIM)
X			You("feel stridently %s!", (u.ualigntyp== U_CHAOTIC) ?
X			    "chaotic" : u.ualigntyp ? "lawful" : "neutral");
X		    else You("feel you are thoroughly on the right path.");
X		    u.ualign = ALIGNLIM;
X		    value += 3;
X		}
X	    }
X	}
X#ifdef ENDGAME
X	if (otmp->otyp == AMULET_OF_YENDOR) {
X	    if (dlevel != ENDLEVEL) {
X		if (otmp->spe == 0) {
X		    if (Hallucination)
X			You("feel homesick.");
X		    else
X			You("feel an urge to return to the surface.");
X		    return (1);
X		}
X	    } else
X		if (otmp->spe < 0) {  /* fake! */
X		    if (flags.soundok)
X			You("hear a nearby thunderclap.");
X		    if (!otmp->known) {
X			You("realize you have made a %s.",
X			      Hallucination ? "boo-boo" : "mistake");
X			otmp->known = 1;
X			return (1);
X		    } else {
X			/* don't you dare try to fool the gods */
X			change_luck(-3);
X			u.ugangr += 3;
X			value = -3;
X		    }
X		}
X		else {
X		    /* The final Test.	Did you win? */
X		    if(uamul && uamul->otyp == otmp->otyp) Amulet_off();
X		    useup(otmp);    /* well, it's gone now */
X		    You("offer the Amulet to %s...", a_gname());
X		    if (u.ualigntyp !=
X			    (levl[u.ux][u.uy].altarmask & ~A_SHRINE) - 1) {
X			/* And the opposing team picks him up and
X			       carries him off on their shoulders */
X		       pline("%s accepts your gift, and gains dominion over %s...",
X				  a_gname(), u_gname());
X			pline("%s is enraged...", u_gname());
X			pline("Fortunately, %s permits you to live...", a_gname());
X			pline("A cloud of %s smoke surrounds you...",
X				Hallucination ? hcolor() : "orange");
X			done("escaped");
X		    } else {	    /* super big win */
X	    pline("An invisible choir sings, and you are bathed in radiance...");
X	    pline("\"Congratulations, mortal!  In return for thy service,");
X			pline("\"I grant thee the gift of Immortality!\"");
X			You("ascend to the status of Demigod...");
X			done("ascended");
X		    }
X		}
X	}
X#endif /* ENDGAME */
X
X#ifndef ALTARS	/* No altars in shops */
X	if (otmp->unpaid && u.ualigntyp != U_CHAOTIC) {
X	    You("realize sacrificing what is not yours is a very chaotic act.");
X	    value = -3;
X	}
X#endif
X
X	if (value == 0
X#ifndef ALTARS
X		       || Inhell
X#endif
X	   ) {
X	    pline(nothing_happens);
X	    return (1);
X	}
X
X	if (value < 0)  /* I don't think the gods are gonna like this... */
X	    gods_upset();
X	else {
X
X	    int saved_anger = u.ugangr;
X	    int saved_cnt = u.ublesscnt;
X	    int saved_luck = u.uluck;
X	    boolean consumed = FALSE;
X#ifdef ALTARS
X	    /* Sacrificing at an altar of a different alignment */
X	    if (u.ualigntyp != (levl[u.ux][u.uy].altarmask & ~A_SHRINE) - 1) {
X		/* Is this a conversion ? */
X		if(ugod_is_angry()) {
X		    if(u.ualignbase[0] == u.ualignbase[1]) {
X			consume_offering(otmp);
X			You("have a strong feeling that %s is angry...",
X					u_gname());
X			pline("%s accepts your allegiance.",a_gname());
X			You("have a sudden sense of a new direction.");
X			/* The player wears a helm of opposite alignment? */
X			if (uarmh && uarmh->otyp == HELM_OF_OPPOSITE_ALIGNMENT)
X			    u.ualignbase[0] =
X				(levl[u.ux][u.uy].altarmask & ~A_SHRINE) - 1;
X			else
X			    u.ualigntyp = u.ualignbase[0] =
X				(levl[u.ux][u.uy].altarmask & ~A_SHRINE) - 1;
X			flags.botl = 1;
X			/* Beware, Conversion is costly */
X			change_luck(-3);
X			u.ublesscnt += 300;
X			adjalign((int)(u.ualignbase[1] * (ALIGNLIM / 2)));
X		    } else {
X			pline("%s rejects your sacrifice!",a_gname());
X			pline("The voice of %s booms:  \"Suffer, infidel!\"",
X					u_gname());
X			adjalign(-5);
X			u.ugangr += 3;
X			adjattrib(A_WIS, -2, TRUE);
X			if (!Inhell) angrygods();
X			change_luck(-5);
X		    }
X		    return(1);
X 		} else {
X		    consume_offering(otmp);
X		    consumed = TRUE;
X		    You("sense a conflict between %s and %s.",
X					u_gname(), a_gname());
X		    if (rn2(8 + (int)u.ulevel) > 5) {
X			You("feel the power of %s increase.",
X					u_gname());
X			change_luck(1);
X			levl[u.ux][u.uy].altarmask &= A_SHRINE;
X			/* the following accommodates stupid compilers */
X			levl[u.ux][u.uy].altarmask =
X				levl[u.ux][u.uy].altarmask | (u.ualigntyp + 1);
X			if (!Blind)
X			    pline("The newly consecrated altar glows %s.",
X				Hallucination ? hcolor() :
X				u.ualigntyp == U_LAWFUL ? white :
X				u.ualigntyp ? black : "gray");
X		    } else {
X			pline("Unluckily, you feel the power of %s decrease.",
X					u_gname());
X			change_luck(-1);
X		    }
X		    return(1);
X		}
X	    }
X#endif
X	    if(!consumed) consume_offering(otmp);
X	    /* OK, you get brownie points. */
X	    if(u.ugangr) {
X		u.ugangr -= ((value * (u.ualigntyp == U_CHAOTIC ? 2 : 3)) / MAXVALUE);
X		if(u.ugangr < 0) u.ugangr = 0;
X		if(u.ugangr != saved_anger) {
X		    if (u.ugangr) {
X			if(Hallucination)
X			    pline("The gods seem %s.", hcolor());
X			else pline("The gods seem slightly mollified.");
X
X			if ((int)u.uluck < 0) change_luck(1);
X		    } else {
X			if (Hallucination)
X			    pline("The gods seem cosmic (not a new fact).");
X			else pline ("The gods seem mollified.");
X
X			if ((int)u.uluck < 0) u.uluck = 0;
X		    }
X		} else {  /* not satisfied yet */
X			if (Hallucination)
X			    pline("The gods seem tall.");
X			else You("have a feeling of inadequacy.");
X		}
X	    }
X	    else if (u.ublesscnt > 0) {
X		u.ublesscnt -= ((value * (u.ualigntyp == U_CHAOTIC ? 500 : 300))
X				/ MAXVALUE);
X		if(u.ublesscnt < 0) u.ublesscnt = 0;
X		if(u.ublesscnt != saved_cnt) {
X
X		    if (u.ublesscnt) {
X			if (Hallucination)
X		    You("realize that the gods are not like you and I.");
X			else
X		    	    You("have a hopeful feeling.");
X			if ((int)u.uluck < 0) change_luck(1);
X		    } else {
X			if (Hallucination)
X		    pline("Overall, there is a smell of fried onions.");
X			else
X			    You("have a feeling of reconciliation.");
X			if ((int)u.uluck < 0) u.uluck = 0;
X		    }
X		}
X	    } else {
X		/* you were already in pretty good standing */
X#if defined(ALTARS) && defined(NAMED_ITEMS)
X		/* The player can gain an artifact */
X		if(!rn2(10)) {
X			otmp = mk_aligned_artifact((int)(levl[u.ux][u.uy].altarmask & ~A_SHRINE) - 1);
X			if(otmp) {
X			    dropy(otmp);
X			    pline("An object appears at your %s!",
X				  makeplural(body_part(FOOT)));
X			    return(1);
X			}
X		}
X#endif
X		change_luck((value * LUCKMAX) / (MAXVALUE * 2));
X		if (u.uluck != saved_luck) {
X		    You(Hallucination ?
X		"see crabgrass at your %s.  A funny thing in a dungeon." :
X		"glimpse a four-leaf clover at your %s.",
X			makeplural(body_part(FOOT)));
X		}
X	    }
X	}
X	return(1);
X}
X
Xint
Xdopray() {		/* M. Stephenson (1.0.3b) */
X	int trouble = in_trouble();
X#ifdef ALTARS
X   	int aligntyp =
X		on_altar() ?
X			(int)(levl[u.ux][u.uy].altarmask & ~A_SHRINE) - 1 :
X			u.ualigntyp;
X   	int align;
X
X	if (u.ualigntyp && u.ualigntyp == -aligntyp) align = -u.ualign;
X		/* Opposite alignment altar */
X	else if (u.ualigntyp != aligntyp) align = u.ualign / 2;
X		/* Different (but non-opposite) alignment altar */
X	else align = u.ualign;
X#else
X  	int aligntyp = u.ualigntyp;
X  	int align = u.ualign;
X#endif
X
X#ifdef POLYSELF
X	if (is_undead(uasmon)) {
X		if (aligntyp == 1 || (aligntyp == 0 && !rn2(10))) {
X			pline(aligntyp == 1 ?
X			      "\"Vile creature, thou durst call upon me?\"" :
X			      "\"Walk no more, perversion of nature!\"");
X			You("feel like you are falling apart.");
X			rehumanize();
X			losehp(rnd(20), "residual undead turning effect");
X			return(1);
X		}
X	}
X	if (is_demon(uasmon) && (aligntyp != -1)) {
X	    pline("The very idea of praying to a %s god is repugnant to you.",
X			u.ualigntyp ? "lawful" : "neutral");
X	    return(0);
X	}
X#endif
X	if (Inhell && u.ualigntyp != U_CHAOTIC) {
X		pline("Since you are in hell, %s won't help you.",
X#  ifdef ALTARS
X			on_altar() ?  a_gname() :
X#  endif
X						u_gname());
X		aggravate();
X		return(0);
X	}
X
X#ifdef WIZARD
X	if (wizard) {
X		pline("Force the gods to be pleased? ");
X		if (yn() == 'y') {
X			u.ublesscnt = 0;
X			if (u.uluck < 0) u.uluck = 0;
X			u.ugangr = 0;
X			if (align < 1) align = 1;
X		}
X	}
X#endif
X	if ((!trouble && (u.ublesscnt > 0)) ||
X	    ((trouble < 0) && (u.ublesscnt > 100)) /* minor difficulties */ ||
X	    ((trouble > 0) && (u.ublesscnt > 200)) /* big trouble */
X	    ) {
X		u.ublesscnt += rnz(250);
X		change_luck(-3);
X		gods_upset();
X	} else if ((int)u.uluck < 0 || u.ugangr || align < 0)
X		angrygods();			/* naughty */
X	else	if (align >= 0) pleased();	/* nice */
X	nomovemsg = "You finish your prayer.";
X	nomul(-3);
X	return(1);
X}
X#endif /* THEOLOGY */
X
Xint
Xdoturn()
X{	/* Knights & Priest(esse)s only please */
X
X	register struct monst *mtmp;
X	register int	xlev = 6;
X
X	if((pl_character[0] != 'P') &&
X	   (pl_character[0] != 'K')) {
X
X		You("don't know how to turn undead!");
X		return(0);
X	}
X#if defined(POLYSELF) || defined(THEOLOGY)
X	if (
X#  ifdef POLYSELF
X		(u.ualigntyp != U_CHAOTIC && (is_demon(uasmon) || is_undead(uasmon)))
X#  endif
X#  if defined(POLYSELF) && defined(THEOLOGY)
X		||
X#  endif
X#  ifdef THEOLOGY
X		u.ugangr > 6 /* "Die, mortal!" */
X#  endif
X		) {
X
X		pline("For some reason, the gods seem not to listen to you.");
X		aggravate();
X		return(0);
X	}
X#endif
X	if (Inhell && u.ualigntyp != U_CHAOTIC) {
X#ifdef THEOLOGY
X		pline("Since you are in hell, %s won't help you.", u_gname());
X#else
X		pline("Since you are in hell, the gods won't help you.");
X#endif
X		aggravate();
X		return(0);
X	}
X#ifdef THEOLOGY
X	pline("Calling upon %s, you chant an arcane formula.", u_gname());
X#else
X	pline("Calling upon the gods, you chant an arcane formula.");
X#endif
X	for(mtmp = fmon; mtmp; mtmp = mtmp->nmon)
X	    if(cansee(mtmp->mx,mtmp->my)) {
X		if(!mtmp->mtame && !mtmp->mpeaceful && (is_undead(mtmp->data) ||
X		   (is_demon(mtmp->data) && (u.ulevel > (MAXULEV/2))))) {
X
X		    if(Confusion) {
X			pline("Unfortunately, your voice falters.");
X			mtmp->mflee = mtmp->mfroz = mtmp->msleep = 0;
X		    } else if (! resist(mtmp, '\0', 0, TELL))
X			switch (mtmp->data->mlet) {
X			    /* this is intentional, lichs are tougher
X			       than zombies. */
X			    case S_LICH:    xlev += 2;
X			    case S_GHOST:   xlev += 2;
X			    case S_VAMPIRE: xlev += 2;
X			    case S_WRAITH:  xlev += 2;
X			    case S_MUMMY:   xlev += 2;
X			    case S_ZOMBIE:
X				mtmp->mflee = 1; /* at least */
X				if(u.ulevel >= xlev)  {
X				    if(!resist(mtmp, '\0', 0, NOTELL)) {
X					if(u.ualigntyp == U_CHAOTIC) {
X					    mtmp->mpeaceful = 1; /* make them friendly */
X					} else { /* damn them */
X					    You("destroy %s!", mon_nam(mtmp));
X					    mondied(mtmp);
X					}
X				    }
X				}
X				break;
X			    default:    mtmp->mflee = 1;
X					break;
X			}
X		   }
X	    }
X	    nomul(-5);
X	    return(1);
X}
X
X#ifdef ALTARS
Xchar *
Xa_gname()
X{
X	return(a_gname_at(u.ux, u.uy));
X}
X
Xchar *
Xa_gname_at(x,y)     /* returns the name of an altar's deity */
Xxchar x, y;
X{
X	register int align;
X
X	if(!IS_ALTAR(levl[x][y].typ)) return((char *)0);
X
X	align = levl[x][y].altarmask & ~A_SHRINE;
X# ifdef THEOLOGY
X       {struct ghods *aghod;
X
X	for(aghod=gods; aghod->classlet; aghod++)
X	    if(aghod->classlet == pl_character[0])
X		switch(align) {
X		case A_CHAOS:	return(aghod->chaos);
X		case A_NEUTRAL:	return(aghod->balance);
X		case A_LAW:	return(aghod->law);
X		default: impossible("unknown altar alignment.");
X			 return("Balance");
X		}
X	impossible("Altar to unknown character's god?");
X	return("someone");
X       }
X# else
X	switch(align) {
X	case A_CHAOS:	return("Chaos");
X	case A_NEUTRAL:	return("Balance");
X	case A_LAW:	return("Law");
X	default: impossible("unknown altar alignment.");
X		 return("Balance");
X	}
X# endif /* THEOLOGY */
X}
X
X# ifdef THEOLOGY
Xvoid
Xaltar_wrath(x, y)
Xregister int x, y;
X{
X    	if(!strcmp(a_gname_at(x,y), u_gname())) {
X	    pline("%s's voice booms:  \"How darest thou desecrate my altar!\"", 
X					a_gname_at(x,y));
X	    adjattrib(A_WIS, -1, FALSE);
X	} else {
X	    pline("A voice whispers in your ear:  \"Thou shalt pay, infidel!\"");
X	    change_luck(-1);
X	}
X}
X# endif /* THEOLOGY */
X#endif /* ALTARS */
X
X#ifdef THEOLOGY
Xchar *
Xu_gname() {  /* returns the name of the player's deity */
X	register struct ghods *aghod;
X
X	for(aghod=gods; aghod->classlet; aghod++)
X	    if(aghod->classlet == pl_character[0])
X		switch(u.ualigntyp) {
X		case  1: return(aghod->law);
X		case  0: return(aghod->balance);
X		case -1: return(aghod->chaos);
X		default: impossible("unknown character alignment.");
X			 return("Balance");
X		}
X	impossible("atheist player?");
X	return("someone");
X}
X#endif /* THEOLOGY */
END_OF_FILE
if test 33283 -ne `wc -c <'src/pray.c'`; then
    echo shar: \"'src/pray.c'\" unpacked with wrong size!
fi
# end of 'src/pray.c'
fi
echo shar: End of archive 11 \(of 38\).
cp /dev/null ark11isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 38 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
