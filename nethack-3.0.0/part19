Path: utzoo!utgpu!jarvis.csri.toronto.edu!mailrus!tut.cis.ohio-state.edu!gem.mps.ohio-state.edu!ginosko!uunet!zephyr.ens.tek.com!tektronix!tekgen!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v07i074:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Part19/38
Message-ID: <4327@tekred.CNA.TEK.COM>
Date: 24 Jul 89 05:05:50 GMT
Sender: nobody@tekred.CNA.TEK.COM
Lines: 1886
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 7, Issue 74
Archive-name: NetHack3/Part19



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 19 (of 38)."
# Contents:  include/patchlevel.h src/objects.c src/pri.c
# Wrapped by billr@saab on Sun Jul 23 21:33:02 1989
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'include/patchlevel.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/patchlevel.h'\"
else
echo shar: Extracting \"'include/patchlevel.h'\" \(21 characters\)
sed "s/^X//" >'include/patchlevel.h' <<'END_OF_FILE'
X#define PATCHLEVEL	0
END_OF_FILE
if test 21 -ne `wc -c <'include/patchlevel.h'`; then
    echo shar: \"'include/patchlevel.h'\" unpacked with wrong size!
fi
# end of 'include/patchlevel.h'
fi
if test -f 'src/objects.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/objects.c'\"
else
echo shar: Extracting \"'src/objects.c'\" \(27292 characters\)
sed "s/^X//" >'src/objects.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)objects.c	3.0	89/04/14
X/* NetHack may be freely redistributed.  See license for details. */
X/* Copyright (c) Mike Threepoint, 1989 (890110) */
X
X/* since this file is also used in auxiliary programs, don't include all the 
X * function declarations for all of nethack
X */
X#define EXTERN_H
X#include "config.h"
X#include "obj.h"
X#include "objclass.h"
X#include "prop.h"
X
X/* objects have letter " % ) ( 0 _ ` [ ! ? / = * + . */
X
Xstruct objclass objects[] = {
X
X	{ "strange object", NULL, NULL, 1,0,0,0, 0,
X		ILLOBJ_SYM, 0, 0, 0, 0, 0, 0, 0 },
X/* amulets ... - THE Amulet comes last because it is special */
X#define AMULET(name,desc,power,prob,weight)	{ name, desc, NULL,\
X		0,0,0,METAL, power, AMULET_SYM, prob, 0, weight, 100, 0, 0, 0 }
X
X	AMULET("amulet of esp", 	  "circular",	TELEPAT,    190, 2),
X	AMULET("amulet of life saving",   "spherical",	LIFESAVED,   90, 2),
X	AMULET("amulet of strangulation", "oval",	STRANGLED,  150, 2),
X	AMULET("amulet of restful sleep", "triangular",	SLEEPING,   150, 2),
X	AMULET("amulet versus poison",	  "pyramidal",	POISON_RES, 180, 2),
X	AMULET("amulet of change",	  "square",	0,	    150, 2),
X								/* POLYMORPH */
X	AMULET("amulet of reflection",	  "hexagonal",	REFLECTING,  90, 2),
X	{ "Amulet of Yendor", NULL, NULL, 1,0,0,METAL, 0,
X		AMULET_SYM, 0, 0, 2, 3500, 0, 0, 0 },
X#undef AMULET
X
X#define FOOD(name,prob,delay,wt,tin,nutrition)	{ name, NULL, NULL, 1,1,0,tin,\
X	    0, FOOD_SYM, prob, delay, wt, nutrition/20 + 5, 0, 0, nutrition }
X
X/* dog eats foods 0-4 but prefers tripe rations above all others */
X/* fortune cookies can be read */
X/* carrots improve your vision */
X/* +0 tins contain monster meat */
X/* +1 tins (of spinach) make you stronger (like Popeye) */
X/* food CORPSE is a cadaver of some type */
X
X	/* meat */
X#ifdef TOLKIEN
X	FOOD("tripe ration",	   145, 1, 2, 0, 200),
X#else
X	FOOD("tripe ration",	   150, 1, 2, 0, 200),
X#endif
X	FOOD("dead lizard",	    35, 0, 1, 0,  40),
X	FOOD("corpse",		     0, 0, 0, 0,   0),
X	FOOD("egg",		    75, 0, 1, 0,  80),
X	/* fruits & veggies */
X	FOOD("apple",		    10, 0, 1, 0,  50),
X	FOOD("orange",		     7, 0, 1, 0,  80),
X	FOOD("pear",		     7, 0, 1, 0,  50),
X	FOOD("melon",		     7, 0, 1, 0, 100),
X	FOOD("banana",		     7, 0, 1, 0,  80),
X	FOOD("slime mold",	    75, 0, 1, 0, 250),
X	FOOD("carrot",		    15, 0, 1, 0,  50),
X	FOOD("clove of garlic",      5, 0, 1, 0,  40),
X	/* human food */
X	FOOD("lump of royal jelly",  0, 0, 1, 0, 200),
X	FOOD("cream pie",	    25, 0, 1, 0, 100),
X	FOOD("candy bar",	     7, 0, 1, 0, 100),
X	FOOD("fortune cookie",	    55, 0, 1, 0,  40),
X#ifdef TOLKIEN
X	FOOD("pancake", 	    25, 1, 1, 0, 200),
X	FOOD("lembas wafer",	    20, 1, 1, 0, 800),
X	FOOD("cram ration",	    20, 1, 3, 0, 600),
X	FOOD("food ration",	   385, 5, 4, 0, 800),
X#else
X	FOOD("pancake", 	    40, 1, 1, 0, 200),
X	FOOD("food ration",	   405, 5, 4, 0, 800),
X#endif
X#ifdef ARMY
X	FOOD("K-ration",	     0, 1, 1, 0, 400),
X	FOOD("C-ration",	     0, 1, 1, 0, 300),
X#endif
X	FOOD("tin",		    75, 0, 1, METAL, 0),
X#undef FOOD
X
X/* weapons ... - ROCK come several at a time */
X/* weapons ... - (DART-1) are shot using idem+(BOW-ARROW) */
X/* weapons AXE, SWORD, KATANA, THSWORD are good for worm-cutting */
X/* weapons (PICK-)AXE, DAGGER, CRYSKNIFE are good for tin-opening */
X#define WEAPON(name,app,kn,mg,bi,prob,wt,cost,sdam,ldam,metal) { name, app, \
X	NULL, kn,mg,bi,metal, 0, WEAPON_SYM, prob, 0, wt, cost, sdam, ldam, 0 }
X#define PROJECTILE(name,app,kn,bi,prob,wt,cost,sdam,ldam,metal,prop) { name, \
X	app, NULL, kn,1,bi,metal, 0, WEAPON_SYM, prob, 0, wt, cost, sdam, \
X	ldam, prop }
X#define BOW(name,app,kn,bi,prob,wt,cost,sdam,ldam,metal,prop) { name, app, \
X	NULL, kn,0,bi,metal, 0, WEAPON_SYM, prob, 0, wt, cost, sdam, ldam, \
X	-(prop) }
X
X/* Note: for weapons that don't do an even die of damage (i.e. 2-7 or 3-18)
X * the extra damage is added on in weapon.c, not here! */
X
X/* missiles */
X#ifdef TOLKIEN
XPROJECTILE("arrow",		NULL,		1, 0, 45, 0,  2, 6, 6,
X		   METAL, WP_BOW),
XPROJECTILE("elven arrow",	"runed arrow",	0, 0, 10, 0,  2, 7, 6,
X		   METAL, WP_BOW),
XPROJECTILE("orcish arrow",	"black arrow",	0, 0, 11, 0,  2, 5, 6,
X		   METAL, WP_BOW),
X#else
XPROJECTILE("arrow",		NULL,		1, 0, 66, 0,  2, 6, 6,
X		   METAL, WP_BOW),
X#endif
XPROJECTILE("crossbow bolt",	NULL,		1, 0, 60, 0,  2, 4, 6,
X		   METAL, WP_CROSSBOW),
X
XWEAPON("dart",		NULL,		1, 1, 0, 60, 0,  2, 3, 2, METAL),
XWEAPON("shuriken",	"throwing star",0, 1, 0, 30, 0,  2, 8, 6, METAL),
XWEAPON("boomerang",	NULL,		1, 1, 0, 15, 3, 50, 9, 9, WOOD),
X
X/* spears */
X#ifdef TOLKIEN
XWEAPON("spear", 	NULL,		1, 1, 0, 55, 3,  8, 6, 8, METAL),
XWEAPON("elven spear",	"runed spear",	0, 1, 0, 10, 3,  8, 7, 8, METAL),
XWEAPON("orcish spear",	"black spear",	0, 1, 0, 13, 3,  8, 5, 8, METAL),
XWEAPON("dwarvish spear","shiny spear",	0, 1, 0, 12, 3,  8, 8, 8, METAL),
X#else
XWEAPON("spear", 	NULL,		1, 1, 0, 90, 3,  8, 6, 8, METAL),
X#endif
XWEAPON("javelin",	"throwing spear",0,1, 0, 10, 3,  8, 6, 6, METAL),
XWEAPON("trident",	NULL,		1, 0, 0,  8, 4,  6, 6, 4, METAL),
X						/* +1 small, +2d4 large */
XWEAPON("lance", 	NULL,		1, 0, 0,  8, 4, 20, 6, 8, METAL),
X
X/* blades */
X#ifdef TOLKIEN
XWEAPON("dagger",	NULL,		1, 1, 0, 25, 2, 20, 4, 3, METAL),
XWEAPON("elven dagger",	"large runed knife", 0, 1, 0,  8, 2, 20, 5, 3, METAL),
XWEAPON("orcish dagger", "large black knife", 0, 1, 0, 10, 2, 20, 3, 3, METAL),
X#else
XWEAPON("dagger",	NULL,		1, 1, 0, 43, 2, 20, 4, 3, METAL),
X#endif
XWEAPON("scalpel",	NULL,		1, 1, 0,  0, 1, 20, 4, 3, METAL),
XWEAPON("knife", 	NULL,		1, 1, 0, 25, 2, 15, 3, 3, METAL),
XWEAPON("axe",		NULL,		1, 0, 0, 50, 3, 50, 6, 4, METAL),
X#ifdef WORM
XWEAPON("worm tooth",	NULL,		1, 0, 0,  0, 3,  2, 2, 2, METAL),
XWEAPON("crysknife",	NULL,		1, 0, 0,  0, 3,100,10,10, METAL),
X#endif
X
X/* swords */
X#ifdef TOLKIEN
XWEAPON("short sword",		NULL,	1, 0, 0,  6, 3, 80, 6, 8, METAL),
XWEAPON("elven short sword",	"short runed sword",
X					0, 0, 0,  2, 3, 80, 8, 8, METAL),
XWEAPON("orcish short sword",	"short black sword",
X					0, 0, 0,  3, 3, 80, 5, 8, METAL),
XWEAPON("dwarvish short sword",	"short shiny sword",
X					0, 0, 0,  2, 3, 80, 7, 8, METAL),
X#else
XWEAPON("short sword",		NULL,	1, 0, 0, 13, 3, 80, 6, 8, METAL),
X#endif
XWEAPON("scimitar", "curved sword",	0, 0, 0,  6, 4, 80, 8, 8, METAL),
X#ifdef TOLKIEN
XWEAPON("broadsword", "wide sword",	0, 0, 0,  8, 4, 80, 4, 6, METAL),
X						/* +d4 small, +1 large */
XWEAPON("elven broadsword",	"wide runed sword",
X					0, 0, 0,  4, 4, 80, 6, 6, METAL),
X						/* +d4 small, +1 large */
X#else
XWEAPON("broadsword", "wide sword",	0, 0, 0, 12, 4, 80, 4, 6, METAL),
X						/* +d4 small, +1 large */
X#endif
XWEAPON("long sword",		NULL,	1, 0, 0, 60, 4, 80, 8, 12, METAL),
X#ifdef TOLKIEN
XWEAPON("two-handed sword",	NULL,	1, 0, 1, 25, 5, 80,12,	6, METAL),
X						/* +2d6 large */
XWEAPON("dwarvish mattock",	"huge shiny sword",
X					0, 0, 1, 15, 6, 80,12,	8, METAL),
X						/* +2d6 large */
X#else
XWEAPON("two-handed sword",	NULL,	1, 0, 1, 40, 5, 80,12,	6, METAL),
X						/* +2d6 large */
X#endif
XWEAPON("katana", "samurai sword",	0, 0, 0,  6, 4,100,10, 12, METAL),
X
X/* blunt */
XWEAPON("mace",		NULL,		1, 0, 0, 55, 4, 150, 6, 6, METAL),
X						/* +1 small */
XWEAPON("morning star",	NULL,		1, 0, 0, 12, 4, 120, 4, 6, METAL),
X						/* +d4 small, +1 large */
XWEAPON("club",		NULL,		1, 0, 0, 10, 3, 100, 6, 3, WOOD),
X#ifdef KOPS
XWEAPON("rubber hose",	NULL,		1, 0, 0,  0, 2, 100, 6, 3, 0),
X#endif
XWEAPON("quarterstaff",	"staff",	0, 0, 1, 10, 3, 150, 6, 6, WOOD),
X
X/* two-piece */
XWEAPON("aklys", "thonged club", 	0, 0, 0,  8, 3, 30, 6, 3, METAL),
XWEAPON("flail", 	NULL,		1, 0, 0, 40, 3, 30, 6, 4, METAL),
X						/* +1 small, +1d4 large */
X/* whip */
XWEAPON("bullwhip",	NULL,		1, 0, 0,  5, 2, 20, 2, 1, 0),
X
X/* polearms */
XWEAPON("bardiche", "large poleaxe",	0, 0, 1,  8, 3, 70, 4, 4, METAL),
X						/* +1d4 small, +2d4 large */
XWEAPON("bec de corbin","beaked poleaxe",0, 0, 1,  8, 3, 16, 8, 6, METAL),
XWEAPON("bill-guisarme","hooked polearm",0, 0, 1,  8, 3, 60, 4,10, METAL),
X						/* +1d4 small */
XWEAPON("fauchard",	"sickle",	0, 0, 1, 11, 3, 30, 6, 8, METAL),
XWEAPON("glaive",	"pike", 	0, 0, 1, 15, 3, 60, 6,10, METAL),
XWEAPON("guisarme",	"pruning hook", 0, 0, 1, 11, 3, 50, 4, 8, METAL),
X						/* +1d4 small */
XWEAPON("halberd",	"long poleaxe", 0, 0, 1, 16, 3, 90,10, 6, METAL),
X						/* +1d6 large */
XWEAPON("lucern hammer", "hammerhead polearm", 0, 0, 1, 10, 3, 70, 4, 6, METAL),
X						/* +1d4 small */
XWEAPON("partisan", "vulgar polearm",	0, 0, 1, 10, 3,100, 6, 6, METAL),
X						/* +1 large */
XWEAPON("ranseur", "hilted polearm",	0, 0, 1, 10, 3, 40, 4, 4, METAL),
X						/* +d4 both */
XWEAPON("spetum", "forked polearm",	0, 0, 1, 10, 3, 30, 6, 6, METAL),
X						/* +1 small, +d6 large */
XWEAPON("voulge", "poleaxe",		0, 0, 1,  8, 3, 20, 4, 4, METAL),
X						/* +d4 both */
X/* bows */
X#ifdef TOLKIEN
XBOW("bow",	  NULL, 	1, 0, 24, 3, 120, 4, 6, 0, WP_BOW),
XBOW("elven bow",  "runed bow",	0, 0, 12, 3, 120, 5, 6, 0, WP_BOW),
XBOW("orcish bow", "black bow",	0, 0, 12, 3, 120, 3, 6, 0, WP_BOW),
X#else
XBOW("bow",	  NULL, 	1, 0, 48, 3, 120, 4, 6, 0, WP_BOW),
X#endif
XBOW("sling", 	  NULL,	    	1, 0, 40, 2,  20, 6, 6, 0, WP_SLING),
XBOW("crossbow",	  NULL,		1, 0, 45, 3,  40, 4, 6, 0, WP_CROSSBOW),
X#undef WEAPON
X#undef PROJECTILE
X#undef BOW
X
X/* tools ... - PICK AXE comes last because it has special characteristics */
X#define TOOL(name,desc,kn,charge,prob,weight,cost,material) { name, desc, NULL,\
X	kn,0,charge,material, 0, TOOL_SYM, prob, 0, weight, cost, 0, 0, 0 }
X
X#ifdef WALKIES
X	TOOL("leash",		NULL,		1, 0,  70,  3,	20, 0),
X#endif
X#ifdef MEDUSA
X	TOOL("blindfold",	NULL,		1, 0,  55,  2,	20, 0),
X	TOOL("mirror",		NULL,		1, 0,  50,  3,	40, GLASS),
X#else
X	TOOL("blindfold",	NULL,		1, 0, 105,  2,	20, 0),
X#endif
X	TOOL("tinning kit",	NULL,		1, 0,  15, 10,	30, METAL),
X	TOOL("lock pick",	NULL,		1, 0,  55,  2,	20, METAL),
X	TOOL("credit card",	NULL,		1, 0,	5,  1,	10, 0),
X#ifdef WALKIES
X	TOOL("key",		NULL,		1, 0, 100,  1,	10, METAL),
X#else
X	TOOL("key",		NULL,		1, 0, 155,  1,	10, METAL),
X#endif
X	TOOL("skeleton key",	"key",		0, 0,  60,  1,	10, METAL),
X	TOOL("expensive camera", NULL,		1, 0,	5,  3, 200, 0),
X	TOOL("magic marker",	NULL,		1, 1,  15,  1,	50, 0),
X	TOOL("stethoscope",	NULL,		1, 0,  15,  2,	80, 0),
X	TOOL("tin opener",	NULL,		1, 0,  25,  1,	30, METAL),
X#ifdef WALKIES
X	TOOL("lamp",		NULL,		1, 1,  90, 10,	50, 0),
X#else
X	TOOL("lamp",		NULL,		1, 1, 105, 10,	50, 0),
X#endif
X	TOOL("magic lamp",	"lamp", 	0, 1,  20, 10,	50, 0),
X	TOOL("crystal ball",	NULL,		1, 1,  35, 15,	60, GLASS),
X	TOOL("figurine",	NULL,		1, 0,  35,  5,	80, MINERAL),
X	TOOL("ice box", 	NULL,		1, 0,	5, 40, 400, 0),
X	TOOL("large box",	NULL,		1, 0,  40, 40, 400, WOOD),
X	TOOL("chest",		NULL,		1, 0,  35, 40, 500, WOOD),
X	TOOL("sack",		"bag",		0, 0,  40,  3, 200, 0),
X	TOOL("bag of holding",	"bag",		0, 0,  20,  3, 250, 0),
X	TOOL("bag of tricks",	"bag",		0, 1,  20,  3, 250, 0),
X#ifndef MUSIC
X	TOOL("whistle", 	NULL,		1, 0, 120,  2,	10, METAL),
X	TOOL("magic whistle",	"whistle",	0, 0,  50,  2,	10, METAL),
X#else
X	TOOL("whistle", 	NULL,		1, 0, 105,  2,	10, METAL),
X	TOOL("magic whistle",	"whistle",	0, 0,  30,  2,	10, METAL),
X	TOOL("flute",		NULL,		1, 0,	6,  3,	12, WOOD),
X	TOOL("magic flute",	"flute",	0, 1,	2,  3,	12, WOOD),
X	TOOL("horn",		NULL,	 	1, 0,	5,  4,	15, METAL),
X	TOOL("frost horn",	"horn", 	0, 1,	2,  4,	15, METAL),
X	TOOL("fire horn",	"horn", 	0, 1,	2,  4,	15, METAL),
X	TOOL("harp",		NULL,	 	1, 0,	4, 10,	50, METAL),
X	TOOL("magic harp",	"harp", 	0, 1,	2, 10,	50, METAL),
X	TOOL("bugle",		NULL,		1, 0,	6,  3,	15, METAL),
X	TOOL("drum",		NULL,	 	1, 0,	4,  4,	25, 0),
X	TOOL("drum of earthquake", "drum",	0, 1,	2,  4,	25, 0),
X#endif
X#undef TOOL
X	{ "pick-axe", NULL, NULL, 1,0,1,METAL, 0, TOOL_SYM, 20,
X						0, 10, 50, 6, 3, 0 },
X	{ "blinding venom", "splash of venom", NULL, 0,1,0,0, 0, VENOM_SYM, 500,
X						0, 0, 0, 0, 0, 0 },
X	{ "acid venom", "splash of venom", NULL, 0,1,0,0, 0, VENOM_SYM, 500,
X				0, 0, 0, 6, 6, 0 }, /* +d6 small or large */
X
X	{ "heavy iron ball", NULL, NULL, 1,0,0,METAL, 0,
X		BALL_SYM, 1000, 0, 20, 10, 0, 0, 0 },
X	{ "iron chain", NULL, NULL, 1,0,0,METAL, 0,
X		CHAIN_SYM, 1000, 0, 20, 0, 0, 0, 0 },
X
X	/* Note: boulders and rocks normally do not appear at random; the
X	 * probabilities only come into effect when you try to polymorph them.
X	 */
X	{ "boulder", NULL, NULL, 1,0,0,MINERAL, 0,
X		ROCK_SYM, 100, 0, 200 /* > MAX_CARR_CAP */, 0, 20, 20, 0 },
X	{ "statue", NULL, NULL, 1,0,0,MINERAL, 0,
X		ROCK_SYM, 900, 0, 250, 0, 20, 20, 0 },
X
X#define ARMOR(name,desc,kn,blk,power,prob,delay,weight,cost,ac,can,metal)  {\
X	name, desc, NULL, kn,0,blk,metal, power, ARMOR_SYM, prob,\
X	delay, weight, cost, ac, can, 0 }
X#ifdef TOLKIEN
XARMOR("elven leather helm", "leather hat", 0, 0, 0,  6, 1, 2,  10, 9, 0, 0),
XARMOR("orcish helm", "black cap",	   0, 0, 0,  6, 1, 3,  10, 9, 0, METAL),
XARMOR("dwarvish iron helm", "hard hat",    0, 0, 0,  6, 1, 3,  10, 8, 0, METAL),
X#else
XARMOR("orcish helm", "black cap",	   0, 0, 0, 18, 1, 3,  10, 9, 0, METAL),
X#endif
XARMOR("fedora", NULL,			   1, 0, 0,  0, 1, 1,  10, 9, 0, 0),
XARMOR("helmet", "rusty pot",		   0, 0, 0, 12, 1, 2,  10, 9, 0, METAL),
XARMOR("helm of brilliance", "plumed hat",	   0, 0, 0,  6, 1, 2,  15, 9, 0, METAL),
XARMOR("helm of opposite alignment", "crested helmet",
X					   0, 0, 0,  6, 1, 2,  15, 9, 0, METAL),
XARMOR("helm of telepathy", "visored helmet",
X				0, 0, TELEPAT, 2, 1, 2, 15, 9, 0, METAL),
X
X/* non-metal and (METAL | 1) armors do not rust */
XARMOR("dragon scale mail", NULL,  1, 1, 0,  0, 5, 5,1000, 1, 0, 0),
XARMOR("plate mail", NULL,	  1, 1, 0, 44, 5, 9, 400, 3, 2, METAL),
XARMOR("crystal plate mail", NULL, 1, 1, 0, 10, 5, 9, 820, 3, 2, 0),
X#ifdef SHIRT
XARMOR("bronze plate mail", NULL,  1, 1, 0, 25, 5, 9, 600, 4, 0, (METAL | 1)),
X#else
XARMOR("bronze plate mail", NULL,  1, 1, 0, 35, 5, 9, 600, 4, 0, (METAL | 1)),
X#endif
XARMOR("splint mail", NULL,	1, 1, 0, 66, 5, 8,  80, 4, 1, METAL),
XARMOR("banded mail", NULL,	1, 1, 0, 76, 5, 8,  90, 4, 0, METAL),
X#ifdef TOLKIEN
XARMOR("dwarvish mithril-coat", NULL, 1, 0, 0, 10, 1, 2, 160, 4, 3, (METAL | 1)),
XARMOR("elven mithril-coat", NULL, 1, 0, 0, 15, 1, 2, 160, 5, 3, (METAL | 1)),
XARMOR("chain mail", NULL,	1, 0, 0, 76, 5, 6,  75, 5, 1, METAL),
XARMOR("orcish chain mail", "black chain mail",
X					0, 0, 0, 20, 5, 6,  75, 5, 1, METAL),
X#else
XARMOR("dwarvish mithril-coat", NULL, 1, 0, 0, 25, 1, 2, 160, 4, 3, (METAL | 1)),
XARMOR("chain mail", NULL,	1, 0, 0, 96, 5, 6,  75, 5, 1, METAL),
X#endif
XARMOR("scale mail", NULL,	1, 0, 0, 76, 5, 5,  45, 6, 0, METAL),
XARMOR("studded leather armor", NULL,
X					1, 0, 0, 76, 3, 3,  15, 7, 1, 0),
X#ifdef TOLKIEN
XARMOR("ring mail", NULL,	1, 0, 0, 76, 5, 4,  30, 7, 0, METAL),
XARMOR("orcish ring mail", "black ring mail",
X					0, 0, 0, 20, 5, 5,  75, 8, 1, METAL),
X#else
XARMOR("ring mail", NULL,	1, 0, 0, 96, 5, 4,  30, 7, 0, METAL),
X#endif
XARMOR("leather armor", NULL,	1, 0, 0, 97, 3, 2,   5, 8, 0, 0),
X
X/*  'cope' is not a spelling mistake... leave it be */
XARMOR("mummy wrapping", NULL,
X				1, 0, 0,	     0, 0, 2,  5, 10, 2, 0),
X#ifdef TOLKIEN
XARMOR("elven cloak", "ornamental cope",
X				0, 0, STEALTH,	    12, 0, 2, 35,  9, 3, 0),
XARMOR("orcish cloak", "black mantelet",
X				0, 0, 0,	    12, 0, 2, 35, 10, 3, 0),
XARMOR("dwarvish cloak", "colorful hooded cloak",
X				0, 0, 0,	    12, 0, 2, 35, 10, 3, 0),
X#else
XARMOR("elven cloak", "ornamental cope",
X				0, 0, STEALTH,	    36, 0, 2, 35,  9, 3, 0),
X#endif
XARMOR("cloak of protection", "tattered cape",
X				0, 0, PROTECTION,   12, 0, 2, 15,  7, 3, 0),
XARMOR("cloak of invisibility", "opera hood",
X				0, 0, INVIS,	    12, 0, 2, 35,  9, 3, 0),
XARMOR("cloak of magic resistance", "faded pall",
X				0, 0, ANTIMAGIC,     2, 0, 2, 25,  9, 3, 0),
XARMOR("cloak of displacement", "piece of cloth",
X				0, 0, DISPLACED,    12, 0, 2, 15,  9, 3, 0),
X
X#ifdef TOLKIEN
XARMOR("small shield", NULL,
X				1, 0, 0,	   6, 0, 2, 10,  9, 0, METAL),
XARMOR("elven shield", "blue and green shield",
X				0, 0, 0,	   2, 0, 2, 15,  8, 0, METAL),
XARMOR("Uruk-hai shield", "white-handed shield",
X				0, 0, 0,	   2, 0, 4, 10,  9, 0, METAL),
XARMOR("orcish shield", "red-eyed shield",
X				0, 0, 0,	   2, 0, 3, 10,  9, 0, METAL),
XARMOR("large shield", NULL,
X				1, 1, 0,	   7, 0, 4, 15,  8, 0, METAL),
XARMOR("dwarvish roundshield", "large round shield",
X				0, 0, 0,	   4, 0, 4, 15,  8, 0, METAL),
X#else
XARMOR("small shield", NULL,
X				1, 0, 0,	  12, 0, 2, 10,  9, 0, METAL),
XARMOR("large shield", NULL,
X				1, 1, 0,	  11, 0, 4, 15,  8, 0, METAL),
X#endif
XARMOR("shield of reflection", "polished silver shield",
X				0, 0, REFLECTING,  3, 0, 3, 50, 8, 0, (METAL | 1)),
X
X#ifdef SHIRT
XARMOR("Hawaiian shirt", NULL,	1, 0, 0, 10, 0, 2, 5, 10, 0, 0),
X#endif
X
XARMOR("leather gloves", "old gloves",
X				0, 0, 0,	   16, 1, 2, 10, 9, 0, 0),
XARMOR("gauntlets of fumbling", "padded gloves",
X				0, 0, FUMBLING,    8, 1, 2, 10, 9, 0, 0),
XARMOR("gauntlets of power", "riding gloves",
X				0, 0, 0,	   8, 1, 2, 10, 9, 0, METAL),
XARMOR("gauntlets of dexterity", "fencing gloves",
X				0, 0, 0,	   8, 1, 2, 10, 9, 0, 0),
X
XARMOR("low boots", "walking shoes",
X				0, 0, 0,	   25, 2, 3, 20, 9, 0, 0),
XARMOR("iron shoes", "hard shoes",
X				0, 0, 0,	    7, 2, 5, 20, 8, 0, METAL),
XARMOR("high boots", "jackboots",
X				0, 0, 0,	   15, 2, 4, 50, 8, 0, 0),
XARMOR("speed boots", "combat boots",
X				0, 0, FAST,	   12, 2, 4, 30, 9, 0, 0),
XARMOR("water walking boots", "jungle boots",
X				0, 0, WWALKING,    12, 2, 4, 30, 9, 0, 0),
XARMOR("jumping boots", "hiking boots",
X				0, 0, JUMPING,	   12, 2, 4, 30, 9, 0, 0),
XARMOR("elven boots", "mud boots",
X				0, 0, STEALTH,	   12, 2, 3,  8, 9, 0, 0),
XARMOR("fumble boots", "riding boots",
X				0, 0, FUMBLING,    12, 2, 4, 15, 9, 0, 0),
XARMOR("levitation boots", "snow boots",
X				0, 0, LEVITATION,  12, 2, 4, 15, 9, 0, 0),
X#undef ARMOR
X
X#define POTION(name,color,power,prob)	{ name, color, NULL, 0,1,0,0, power,\
X		POTION_SYM, prob, 0, 2, 100, 0, 0, 0 }
X
X#ifdef SPELLS
X	POTION("fruit juice",		"smoky",	0,	45),
X	POTION("booze", 		"bubbly",	0,	45),
X	POTION("gain energy",		"ebony", 	0,	45),
X#else
X	POTION("fruit juice",		"smoky",	0,	70),
X	POTION("booze", 		"bubbly",	0,	65),
X#endif
X	POTION("gain ability",		"swirly",	0,	45),
X	POTION("restore ability",	"pink",		0,	45),
X	POTION("sickness",		"ruby",		SICK,	45),
X	POTION("confusion",		"orange",	CONFUSION, 45),
X	POTION("blindness",		"yellow",	BLINDED, 45),
X	POTION("paralysis",		"emerald", 	0,	45),
X	POTION("speed", 		"dark green", 	FAST,	45),
X	POTION("levitation",		"cyan",		LEVITATION, 45),
X	POTION("hallucination", 	"brilliant blue", HALLUC, 45),
X	POTION("invisibility",		"sky blue",	INVIS,	45),
X	POTION("see invisible", 	"magenta",	SEE_INVIS, 45),
X	POTION("healing",		"purple", 	0,	65),
X	POTION("extra healing", 	"purple-red",	0,	50),
X	POTION("gain level",		"puce",	0,	20),
X	POTION("enlightenment",		"brown",	0,	20),
X	POTION("monster detection",	"white",	0,	45),
X	POTION("object detection",	"glowing",	0,	45),
X	POTION("water", 		"clear",	0,	125),
X#undef POTION
X
X#define SCROLL(name,text,prob,cost) { name, text, NULL, 0,1,0,0, 0,\
X		SCROLL_SYM, prob, 0, 3, cost, 0, 0, 0 }
X#ifdef MAIL
X	SCROLL("mail",			"KIRJE",	     0,   0),
X#endif
X	SCROLL("enchant armor", 	"ZELGO MER",	    63,  80),
X	SCROLL("destroy armor", 	"JUYED AWK YACC",   45, 100),
X	SCROLL("confuse monster",	"NR 9", 	    53, 100),
X	SCROLL("scare monster", 	"XIXAXA XOXAXA XUXAXA", 35, 100),
X	SCROLL("blank paper",		"READ ME",	    28,  80),
X	SCROLL("remove curse",		"PRATYAVAYAH",	    65,  80),
X	SCROLL("enchant weapon",	"DAIYEN FOOELS",    85,  60),
X	SCROLL("create monster",	"LEP GEX VEN ZEA",  45, 100),
X	SCROLL("taming",		"PRIRUTSENIE",	    15, 200),
X	SCROLL("genocide",		"ELBIB YLOH",	    15, 200),
X	SCROLL("light", 		"VERR YED HORRE",   95,  50),
X	SCROLL("teleportation", 	"VENZAR BORGAVVE",  55, 100),
X	SCROLL("gold detection",	"THARR",	    33, 100),
X	SCROLL("food detection",	"YUM YUM",	    25, 100),
X	SCROLL("identify",		"KERNOD WEL",	    185, 20),
X	SCROLL("magic mapping", 	"ELAM EBOW",	    45, 100),
X	SCROLL("amnesia",		"DUAM XNAHT",	    35, 100),
X	SCROLL("fire",			"ANDOVA BEGARIN",   48, 100),
X	SCROLL("punishment",		"VE FORBRYDERNE",   15, 200),
X	SCROLL("charging",		"HACKEM MUCHE",     15, 200),
X	SCROLL(NULL,			"VELOX NEB",	     0, 100),
X	SCROLL(NULL,			"FOOBIE BLETCH",     0, 100),
X	SCROLL(NULL,			"TEMOV",	     0, 100),
X	SCROLL(NULL,			"GARVEN DEH",	     0, 100),
X#undef SCROLL
X
X#define WAND(name,typ,prob,cost,flags,metal)	{ name, typ, NULL,\
X		0,0,0,metal, 0, WAND_SYM, prob, 0, 3, cost, flags, 0, 0 }
X
X	WAND("light",		"glass",	95, 100, NODIR,     GLASS),
X	WAND("secret door detection", "balsa",	50, 150, NODIR,     WOOD),
X	WAND("create monster",	"maple",	45, 200, NODIR,     WOOD),
X	WAND("wishing", 	"pine",		 5, 500, NODIR,     WOOD),
X	WAND("striking",	"oak",	 	75, 150, IMMEDIATE, WOOD),
X	WAND("nothing", 	"ebony",	25, 100, IMMEDIATE, WOOD),
X	WAND("make invisible",	"marble",	45, 150, IMMEDIATE, MINERAL),
X	WAND("slow monster",	"tin",		55, 150, IMMEDIATE, METAL),
X	WAND("speed monster",	"brass",	55, 150, IMMEDIATE, METAL),
X	WAND("undead turning",	"copper",	55, 150, IMMEDIATE, METAL),
X	WAND("polymorph",	"silver",	45, 200, IMMEDIATE, METAL),
X	WAND("cancellation",	"platinum",	45, 200, IMMEDIATE, METAL),
X	WAND("teleportation",	"iridium", 	45, 200, IMMEDIATE, METAL),
X#ifdef PROBING
X	WAND("probing", 	"uranium",	30, 150, IMMEDIATE, METAL),
X	WAND("opening", 	"zinc",		25, 150, IMMEDIATE, METAL),
X	WAND("locking", 	"aluminum",	25, 150, IMMEDIATE, METAL),
X#else
X	WAND("opening", 	"zinc",		40, 150, IMMEDIATE, METAL),
X	WAND("locking", 	"aluminum",	40, 150, IMMEDIATE, METAL),
X#endif
X	WAND("digging", 	"iron", 	55, 150, RAY,	    METAL),
X	WAND("magic missile",	"steel",	50, 150, RAY,	    METAL),
X	WAND("fire",		"hexagonal",	40, 175, RAY,	    METAL),
X	WAND("sleep",		"runed",	50, 175, RAY,	    METAL),
X	WAND("cold",		"short",	40, 175, RAY,	    METAL),
X	WAND("death",		"long", 	 5, 500, RAY,	    METAL),
X	WAND("lightning",	"curved",	40, 175, RAY,	    METAL),
X	WAND(NULL,		"forked",	 0, 150, 0,	    METAL),
X	WAND(NULL,		"spiked",	 0, 150, 0,	    METAL),
X	WAND(NULL,		"jeweled",	 0, 150, 0,	    METAL),
X#undef WAND
X
X#ifdef SPELLS
X/* books */
X#define SPELL(name,desc,prob,delay,level,flags) { name, desc, NULL,\
X	0,1,0,0, 0, SPBOOK_SYM, prob, delay, 5, level*100, flags, 0, level }
X
X	SPELL("magic missile",	 "parchment",	45,  3, 2, RAY),
X	SPELL("fireball",	 "vellum",	20,  6, 4, RAY),
X	SPELL("sleep",		 "dog eared",	50,  1, 1, RAY),
X	SPELL("cone of cold",	 "ragged",	10,  8, 5, RAY),
X	SPELL("finger of death", "stained",	 5, 10, 7, RAY),
X	SPELL("light",		 "cloth",	45,  1, 1, NODIR),
X	SPELL("detect monsters", "leather", 	45,  1, 1, NODIR),
X	SPELL("healing",	 "white",	40,  2, 1, NODIR),
X	SPELL("knock",		 "pink",	40,  1, 1, IMMEDIATE),
X	SPELL("force bolt",	 "red",		40,  2, 1, IMMEDIATE),
X	SPELL("confuse monster", "orange",	37,  2, 2, IMMEDIATE),
X	SPELL("cure blindness",  "yellow", 	27,  2, 2, IMMEDIATE),
X	SPELL("slow monster",	 "light green",	37,  2, 2, IMMEDIATE),
X	SPELL("wizard lock",	 "dark green",	35,  3, 2, IMMEDIATE),
X	SPELL("create monster",  "turquoise",	37,  3, 2, NODIR),
X	SPELL("detect food",	 "cyan",	37,  3, 2, NODIR),
X	SPELL("cause fear",	 "light blue",	25,  3, 3, NODIR),
X	SPELL("clairvoyance",	 "dark blue",	15,  3, 3, NODIR),
X	SPELL("cure sickness",	 "indigo",	32,  3, 3, NODIR),
X	SPELL("charm monster",	 "magenta",	20,  3, 3, IMMEDIATE),
X	SPELL("haste self",	 "purple",	33,  4, 3, NODIR),
X	SPELL("detect unseen",	 "violet",	25,  4, 3, NODIR),
X	SPELL("levitation",	 "tan",		25,  4, 4, NODIR),
X	SPELL("extra healing",	 "plaid",	32,  5, 3, NODIR),
X	SPELL("restore ability", "light brown",	25,  5, 4, NODIR),
X	SPELL("invisibility",	 "dark brown",	32,  5, 4, NODIR),
X	SPELL("detect treasure", "grey",	25,  5, 4, NODIR),
X	SPELL("remove curse",	 "black",	25,  5, 5, NODIR),
X	SPELL("dig",		 "mottled",	22,  6, 5, RAY),
X	SPELL("magic mapping",	 "rusty",	18,  7, 5, NODIR),
X	SPELL("identify",	 "bronze",	25,  8, 5, NODIR),
X	SPELL("turn undead",	 "copper",	17,  8, 6, IMMEDIATE),
X	SPELL("polymorph",	 "silver",	12,  8, 6, IMMEDIATE),
X	SPELL("teleport away",	 "gold",	15,  6, 6, IMMEDIATE),
X	SPELL("create familiar", "glittering", 	10,  7, 6, NODIR),
X	SPELL("cancellation",	 "shining",	12,  8, 7, IMMEDIATE),
X	SPELL("genocide",	 "glowing",	 5, 10, 7, NODIR),
X	SPELL(NULL,		 "dull",	 0,  0, 0, 0),
X	SPELL(NULL,		 "thin",	 0,  0, 0, 0),
X	SPELL(NULL,		 "thick",	 0,  0, 0, 0),
X#undef SPELL
X#endif /* SPELLS /**/
X
X#define RING(name,stone,power,spec,metal) { name, stone, NULL, 0,0,spec,metal,\
X		power, RING_SYM, 0, 0, 1, 100, spec, 0, 0 }
X
X	RING("adornment",	"wooden",	ADORNED,	1, WOOD),
X	RING("gain strength",	"granite",	0,		1, MINERAL),
X	RING("increase damage", "hematite",	0,		1, MINERAL),
X	RING("protection",	"black onyx",	PROTECTION,	1, MINERAL),
X	RING("regeneration",	"moonstone",	REGENERATION,	0, MINERAL),
X	RING("searching",	"tiger eye",	SEARCHING,	0, MINERAL),
X	RING("stealth", 	"jade",		STEALTH,	0, MINERAL),
X	RING("levitation",	"agate",	LEVITATION,	0, MINERAL),
X	RING("hunger",		"topaz",	HUNGER, 	0, MINERAL),
X	RING("aggravate monster", "sapphire",	AGGRAVATE_MONSTER, 0, METAL),
X	RING("conflict",	"ruby", 	CONFLICT,	0, METAL),
X	RING("warning", 	"diamond", 	WARNING,	0, METAL),
X	RING("poison resistance", "pearl",	POISON_RES,	0, METAL),
X	RING("fire resistance", "iron",		FIRE_RES,	0, METAL),
X	RING("cold resistance", "brass",	COLD_RES,	0, METAL),
X	RING("shock resistance", "copper",	SHOCK_RES,	0, METAL),
X	RING("teleportation",	"silver",	TELEPORT,	0, METAL),
X	RING("teleport control", "gold",	TELEPORT_CONTROL, 0, METAL),
X#ifdef POLYSELF
X	RING("polymorph",	"ivory",	POLYMORPH,	0, 0),
X	RING("polymorph control","blackened",	POLYMORPH_CONTROL, 0, METAL),
X#endif
X	RING("invisibility",	"wire",	INVIS,		0, METAL),
X	RING("see invisible",	"engagement",	SEE_INVIS,	0, METAL),
X	RING("protection from shape changers", "shining",
X					PROT_FROM_SHAPE_CHANGERS, 0, METAL),
X#undef RING
X
X/* gems ************************************************************/
X#define GEM(name,color,prob,wt,gval,glass) { name, color, NULL, 0,1,0,glass, 0,\
X		GEM_SYM, prob, 0, wt, gval, 3, 3, WP_SLING }
X	GEM("dilithium crystal", "white",	 3, 1, 4500, MINERAL),
X	GEM("diamond", "white", 		 4, 1, 4000, MINERAL),
X	GEM("ruby", "red",			 5, 1, 3500, MINERAL),
X	GEM("sapphire", "blue", 		 6, 1, 3000, MINERAL),
X	GEM("emerald", "green", 		 7, 1, 2500, MINERAL),
X	GEM("turquoise", "green",		 8, 1, 2000, MINERAL),
X	GEM("aquamarine", "green",		10, 1, 1500, MINERAL),
X	GEM("amber", "yellowish brown", 	11, 1, 1000, MINERAL),
X	GEM("topaz", "yellowish brown", 	13, 1,	900, MINERAL),
X	GEM("opal", "white",			15, 1,	800, MINERAL),
X	GEM("garnet", "red",			17, 1,	700, MINERAL),
X	GEM("amethyst", "violet",		18, 1,	600, MINERAL),
X	GEM("jasper", "red",			20, 1,	500, MINERAL),
X	GEM("fluorite", "violet",		21, 1,	400, MINERAL),
X	GEM("jade", "green",			22, 1,	300, MINERAL),
X	GEM("worthless piece of white glass", "white",	158, 1, 0, GLASS),
X	GEM("worthless piece of blue glass", "blue",	158, 1, 0, GLASS),
X	GEM("worthless piece of red glass", "red",	158, 1, 0, GLASS),
X	GEM("worthless piece of yellowish brown glass", "yellowish brown",
X						158, 1, 0, GLASS),
X	GEM("worthless piece of green glass", "green",	158, 1, 0, GLASS),
X	GEM("luckstone", "grey",		 10, 1,  60, MINERAL),
X	GEM("loadstone", "grey",		 10, 50,  1, MINERAL),
X	{ "rock", NULL, NULL, 1,1,0,MINERAL, 0,
X		GEM_SYM, 10, 0, 1, 0, 3, 3, WP_SLING },
X#undef GEM
X
X	{ NULL, NULL, NULL, 0,0,0,0, 0, ILLOBJ_SYM, 0, 0, 0, 0, 0, 0, 0 }
X};
END_OF_FILE
if test 27292 -ne `wc -c <'src/objects.c'`; then
    echo shar: \"'src/objects.c'\" unpacked with wrong size!
fi
# end of 'src/objects.c'
fi
if test -f 'src/pri.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/pri.c'\"
else
echo shar: Extracting \"'src/pri.c'\" \(23540 characters\)
sed "s/^X//" >'src/pri.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)pri.c	3.0	89/06/16
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X/* block some unused #defines to avoid overloading some cpp's */
X#define MONATTK_H
X#include "hack.h"
X#include <ctype.h>  /* for isalpha() */
X
Xstatic void hilite P((uchar, uchar));
Xstatic void cornbot P((int));
Xstatic boolean ismnst P((char));
X#if !defined(DECRAINBOW) && !defined(UNIX)
X#  define g_putch  (void) putchar
X#endif
X
X#ifndef g_putch
Xstatic boolean GFlag = FALSE; /* graphic flag */
X#endif
X
X/* 100 suffices for bot(); must be larger than COLNO */
X#define MAXCO 100
Xstatic char oldbot1[MAXCO], newbot1[MAXCO];
Xstatic char oldbot2[MAXCO], newbot2[MAXCO];
Xstatic const char *dispst = "*0#@#0#*0#@#0#*0#@#0#*0#@#0#*0#@#0#*";
Xstatic int mrank_sz = 0;  /* loaded by max_rank_sz (called in u_init) */
X
Xvoid
Xswallowed(first)
Xregister int first;
X{
X	if(first) cls();
X	else {
X		curs(u.ustuck->mdx-1, u.ustuck->mdy+1);
X		(void) fputs("   ", stdout);
X		curx = u.ustuck->mdx+2;
X		curs(u.ustuck->mdx-1, u.ustuck->mdy+2);
X		(void) fputs("   ", stdout);
X		curx = u.ustuck->mdx+2;
X		curs(u.ustuck->mdx-1, u.ustuck->mdy+3);
X		(void) fputs("   ", stdout);
X		curx = u.ustuck->mdx+2;
X	}
X	curs(u.ux-1, u.uy+1);
X	(void) fputs("/-\\", stdout);
X	curx = u.ux+2;
X	curs(u.ux-1, u.uy+2);
X	(void) putchar('|');
X	hilite(u.usym, AT_MON);
X	(void) putchar('|');
X	curx = u.ux+2;
X	curs(u.ux-1, u.uy+3);
X	(void) fputs("\\-/", stdout);
X	curx = u.ux+2;
X	u.udispl = 1;
X	u.udisx = u.ux;
X	u.udisy = u.uy;
X}
X
Xvoid
Xsetclipped()
X{
X	error("NetHack needs a screen of size at least %d by %d.\n",
X		ROWNO+3, COLNO);
X}
X
X/*
X *  Allow for a different implementation than this...
X */
X
X#ifndef g_putch
X
Xstatic void
Xg_putch(ch)
Xuchar ch;
X{
X	if (ch & 0x80) {
X		if (!GFlag) {
X			graph_on();
X			GFlag = TRUE;
X		}
X		(void) putchar(ch ^ 0x80); /* Strip 8th bit */
X	} else {
X		if (GFlag) {
X			graph_off();
X			GFlag = FALSE;
X		}
X		(void) putchar(ch);
X	}
X}
X
X#endif
X
Xstatic boolean
Xshowmon(mon)
Xregister struct monst *mon;
X{
X	register boolean show = (Blind && Telepat) || canseemon(mon);
X
X	if (!show && (HTelepat & WORN_HELMET))
X		show = (dist(mon->mx, mon->my) <= (BOLT_LIM * BOLT_LIM));
X	return(show);
X}
X
Xvoid
Xat(x,y,ch,typ)
Xregister xchar x,y;
Xuchar ch,typ;
X{
X#ifndef LINT
X	/* if xchar is unsigned, lint will complain about  if(x < 0)  */
X	if(x < 0 || x > COLNO-1 || y < 0 || y > ROWNO-1) {
X		impossible("At gets 0%o at %d %d.", ch, x, y);
X		return;
X	}
X#endif
X	if(!ch) {
X		impossible("At gets null at %d %d.", x, y);
X		return;
X	}
X
X	if (typ == AT_APP
X#ifndef MSDOS
X	    && flags.standout
X#endif
X	   )
X		/* don't hilite if this isn't a monster or object.
X		 *
X		 * not complete; a scroll dropped by some monster
X		 * on an unseen doorway which is later magic mapped
X		 * will still hilite the doorway symbol.  -3.
X		 */
X		if (!vism_at(x,y) &&
X		    (!levl[x][y].omask && !levl[x][y].gmask || is_pool(x,y)))
X		    typ = AT_MAP;
X
X	y += 2;
X	curs(x,y);
X
X	hilite(ch,typ);
X	curx++;
X}
X
Xvoid
Xprme(){
X	if(!Invisible
X#ifdef POLYSELF
X			&& !u.uundetected
X#endif
X					) at(u.ux,u.uy,u.usym,AT_U);
X}
X
Xvoid
Xshieldeff(x, y)		/* produce a magical shield effect at x,y */
X	register xchar x, y;
X{
X	register char *ch;
X	register struct monst *mtmp = 0;
X
X	if((x != u.ux) || (y != u.uy)) {
X	    if(!(mtmp = m_at(x, y))) {
X
X		impossible("shield effect at %d,%d", x, y);
X		return;
X	    }
X	    if(!showmon(mtmp)) return;
X	}
X
X	for(ch = dispst; *ch; ch++)  {
X		at(x, y, (uchar) *ch, AT_ZAP);
X		(void) fflush(stdout);
X		delay_output();
X		delay_output();
X	}
X
X	nomul(0);
X	if(!mtmp) {
X		if(Invisible) {
X			prl(x, y);
X			at(x, y, levl[x][y].scrsym, AT_APP);
X		} else prme();
X	} else {
X		mtmp->mdispl = 0;	/* make sure it gets redrawn */
X		prl(x, y);
X		if(mtmp->minvis)
X			at(x, y, levl[x][y].scrsym, AT_APP);
X		else	at(x, y, (uchar) mtmp->data->mlet, AT_MON);
X	}
X
X	return;
X}
X
Xint
Xdoredraw()
X{
X	docrt();
X	return 0;
X}
X
Xvoid
Xdocrt()
X{
X	register int x,y;
X	register struct rm *room;
X	register struct monst *mtmp;
X
X	if(u.uswallow) {
X		swallowed(1);
X		return;
X	}
X	cls();
X
X/* Some ridiculous code to get display of @ and monsters (almost) right */
X	if(!Invisible
X#ifdef POLYSELF
X			|| u.uundetected
X#endif
X					) {
X		levl[(u.udisx = u.ux)][(u.udisy = u.uy)].scrsym = u.usym;
X		levl[u.udisx][u.udisy].seen = 1;
X		u.udispl = 1;
X	} else	u.udispl = 0;
X
X	seemons();	/* reset old positions */
X	for(mtmp = fmon; mtmp; mtmp = mtmp->nmon)
X		mtmp->mdispl = 0;
X	seemons();	/* force new positions to be shown */
X
X#if defined(DGK) && !defined(MSDOSCOLOR)
X	/* Otherwise, line buffer the output to do the redraw in
X	 * about 2/3 of the time.
X	 */
X		for(y = 0; y < ROWNO; y++) {
X			char buf[COLNO+1];
X			int start, end;
X#ifdef TOS
X			setmem(buf, COLNO, ' ');
X#else
X			memset(buf, ' ', COLNO);
X#endif /* TOS */
X			for(x = 0, start = -1, end = -1; x < COLNO; x++)
X				if((room = &levl[x][y])->new) {
X					room->new = 0;
X					buf[x] = room->scrsym;
X					if (start < 0)
X						start = x;
X					end = x;
X				} else if(room->seen) {
X					buf[x] = room->scrsym;
X					if (start < 0)
X						start = x;
X					end = x;
X				}
X			if (end >= 0) {
X				buf[end + 1] = '\0';
X				curs(start, y + 2);
X				(void) fputs(buf + start, stdout);
X				curx = end + 1;
X			}
X		}
X#else /* DGK && !MSDOSCOLOR */
X	for(y = 0; y < ROWNO; y++)
X		for(x = 0; x < COLNO; x++)
X			if((room = &levl[x][y])->new) {
X				room->new = 0;
X				at(x,y,room->scrsym,AT_APP);
X			} else if(room->seen)
X				at(x,y,room->scrsym,AT_APP);
X#endif /* DGK && !MSDOSCOLOR */
X#ifndef g_putch
X	if (GFlag) {
X		graph_off();
X		GFlag = FALSE;
X	}
X#endif
X	scrlx = COLNO;
X	scrly = ROWNO;
X	scrhx = scrhy = 0;
X	cornbot(0);
X	bot();
X}
X
Xstatic void
Xcornbot(lth)
Xregister int lth;
X{
X	oldbot1[lth] = 0;
X	oldbot2[lth] = 0;
X	flags.botl = 1;
X}
X
Xvoid
Xdocorner(xmin, ymax)
Xregister int xmin, ymax;
X{
X	register int x, y;
X	register struct rm *room;
X	register struct monst *mtmp;
X
X	if(u.uswallow) {	/* Can be done more efficiently */
X		swallowed(1);
X		return;
X	}
X
X	seemons();	/* reset old positions */
X	for(mtmp = fmon; mtmp; mtmp = mtmp->nmon)
X	    if(mtmp->mx >= xmin && mtmp->my < ymax)
X		mtmp->mdispl = 0;
X	seemons();	/* force new positions to be shown */
X
X	for(y = 0; y < ymax; y++) {
X		if(y > ROWNO+1 && CD) break;
X		curs(xmin,y+2);
X		cl_end();
X		if(y < ROWNO) {
X		    for(x = xmin; x < COLNO; x++) {
X			if((room = &levl[x][y])->new) {
X				room->new = 0;
X				at(x,y,room->scrsym,AT_APP);
X			} else
X				if(room->seen)
X					at(x,y,room->scrsym,AT_APP);
X		    }
X		}
X	}
X#ifndef g_putch
X	if (GFlag) {
X		graph_off();
X		GFlag = FALSE;
X	}
X#endif
X	/* Note:          y values: 0 to ymax-1
X	 * screen positions from y: 2 to ymax+1
X	 *            whole screen: 1 to ROWNO+3
X	 *                top line: 1
X	 *         dungeon display: 2 to ROWNO+1
X	 *       first bottom line: ROWNO+2
X	 *      second bottom line: ROWNO+3
X	 *         lines on screen: ROWNO+3
X	 */
X	if(ymax > ROWNO) {
X		cornbot(xmin-1);
X		if(ymax > ROWNO+2 && CD) {	/* clear portion of long */
X			curs(1,ROWNO+4);	/* screen below status lines */
X			cl_eos();
X		}
X	}
X}
X
Xvoid
Xseeglds()
X{
X	register struct gold *gold, *gold2;
X
X	for(gold = fgold; gold; gold = gold2) {
X	    gold2 = gold->ngold;
X	    if(Hallucination && cansee(gold->gx,gold->gy))
X		if(!(gold->gx == u.ux && gold->gy == u.uy) || Invisible)
X		    atl(gold->gx,gold->gy,rndobjsym());
X	}
X}
X
X/* Trolls now regenerate thanks to KAA */
X
Xvoid
Xseeobjs()
X{
X	register struct obj *obj, *obj2;
X
X	for(obj = fobj; obj; obj = obj2) {
X	    obj2 = obj->nobj;
X
X	    if(Hallucination && cansee(obj->ox,obj->oy))
X		if(!(obj->ox == u.ux && obj->oy == u.uy) || Invisible)
X		    atl(obj->ox,obj->oy,rndobjsym());
X
X	    if(obj->olet == FOOD_SYM && obj->otyp == CORPSE) {
X
X		if(mons[obj->corpsenm].mlet == S_TROLL &&
X		    obj->age + 20 < moves) {
X			boolean visible = cansee(obj->ox,obj->oy);
X			struct monst *mtmp = revive(obj, FALSE);
X
X			if (mtmp && visible)
X				pline("%s rises from the dead!", Monnam(mtmp));
X		} else if (obj->age + 250 < moves) delobj(obj);
X	    }
X	}
X
X	for(obj = invent; obj; obj = obj2) {
X	    obj2 = obj->nobj;
X	    if(obj->otyp == CORPSE) {
X		if(mons[obj->corpsenm].mlet == S_TROLL
X			    && obj->age + 20 < moves) {
X		    boolean wielded = (obj==uwep);
X		    struct monst *mtmp = revive(obj, TRUE);
X
X		    if (mtmp && wielded)
X			pline("The %s %s writhes out of your grasp!",
X				mtmp->data->mname, xname(obj));
X		    else if (mtmp)
X			You("feel squirming in your backpack!");
X		} else if (obj->age + 250 < moves) useup(obj);
X	    }
X	}
X}
X
Xvoid
Xseemons()
X{
X	register struct monst *mtmp;
X
X	for(mtmp = fmon; mtmp; mtmp = mtmp->nmon) {
X	    if(mtmp->data->mlet == S_EEL)
X		mtmp->minvis = (u.ustuck != mtmp && is_pool(mtmp->mx,mtmp->my));
X	    pmon(mtmp);
X#ifdef WORM
X	    if(mtmp->wormno) wormsee(mtmp->wormno);
X#endif
X	}
X}
X
Xvoid
Xpmon(mon)
Xregister struct monst *mon;
X{
X	register int show = showmon(mon);
X
X	if(mon->mdispl)
X	    if(mon->mdx != mon->mx || mon->mdy != mon->my || !show)
X		unpmon(mon);
X
X/* If you're hallucinating, the monster must be redrawn even if it has
X * already been printed.
X */
X	if(show && (!mon->mdispl || Hallucination)) {
X	    if (Hallucination)
X	    atl(mon->mx,mon->my,
X		(char) ((!mon->mimic || Protection_from_shape_changers) ?
X		rndmonsym() : (mon->mappearance == DOOR_SYM) ?
X		DOOR_SYM : rndobjsym()));
X	    else
X
X		atl(mon->mx,mon->my,
X		    (!mon->mappearance ||
X		     Protection_from_shape_changers) ?
X		     mon->data->mlet : mon->mappearance);
X		mon->mdispl = 1;
X		mon->mdx = mon->mx;
X		mon->mdy = mon->my;
X	}
X#ifndef g_putch
X	if (GFlag) {
X		graph_off();
X		GFlag = FALSE;
X	}
X#endif
X}
X
Xvoid
Xunpmon(mon)
Xregister struct monst *mon;
X{
X	if(mon->mdispl) {
X		newsym(mon->mdx, mon->mdy);
X		mon->mdispl = 0;
X	}
X}
X
Xvoid
Xnscr() {
X	register int x, y;
X	register struct rm *room;
X
X	if(u.uswallow || u.ux == FAR || flags.nscrinh) return;
X	pru();
X	for(y = scrly; y <= scrhy; y++)
X		for(x = scrlx; x <= scrhx; x++)
X			if((room = &levl[x][y])->new) {
X				room->new = 0;
X				at(x,y,room->scrsym,AT_APP);
X			}
X#ifndef g_putch
X	if (GFlag) {
X		graph_off();
X		GFlag = FALSE;
X	}
X#endif
X	scrhx = scrhy = 0;
X	scrlx = COLNO;
X	scrly = ROWNO;
X}
X
X/* Make sure that there are 18 entries in the rank arrays. */
X/* 0 and even entries are male ranks, odd entries are female. */
X
Xstatic const char *mage_ranks[] = {
X	"Evoker",
X	"Evoker",
X	"Conjurer",
X	"Conjurer",
X	"Thaumaturge",
X	"Thaumaturge",
X	"Magician",
X	"Magician",
X	"Enchanter",
X	"Enchanter",
X	"Sorcerer",
X	"Sorceress",
X	"Necromancer",
X	"Necromancer",
X	"Wizard",
X	"Wizard",
X	"Mage",
X	"Mage"
X};
X
Xstatic const char *priest_ranks[] = {
X	"Aspirant",
X	"Aspirant",
X	"Acolyte",
X	"Acolyte",
X	"Adept",
X	"Adept",
X	"Priest",
X	"Priestess",
X	"Curate",
X	"Curate",
X	"Canon",
X	"Canoness",
X	"Lama",
X	"Lama",
X	"Patriarch",
X	"Matriarch",
X	"High Priest",
X	"High Priestess"
X};
X
Xstatic const char *thief_ranks[] = {
X	"Footpad",
X	"Footpad",
X	"Cutpurse",
X	"Cutpurse",
X	"Rogue",
X	"Rogue",
X	"Pilferer",
X	"Pilferer",
X	"Robber",
X	"Robber",
X	"Burglar",
X	"Burglar",
X	"Filcher",
X	"Filcher",
X	"Magsman",
X	"Magswoman",
X	"Thief",
X	"Thief"
X};
X
Xstatic const char *fighter_ranks[] = {
X	"Stripling",
X	"Stripling",
X	"Skirmisher",
X	"Skirmisher",
X	"Fighter",
X	"Fighter",
X	"Man-at-arms",
X	"Woman-at-arms",
X	"Warrior",
X	"Warrior",
X	"Swashbuckler",
X	"Swashbuckler",
X	"Hero",
X	"Heroine",
X	"Champion",
X	"Champion",
X	"Lord",
X	"Lady"
X};
X
Xstatic const char *tourist_ranks[] = {
X	"Rambler",
X	"Rambler",
X	"Sightseer",
X	"Sightseer",
X	"Excursionist",
X	"Excursionist",
X	"Peregrinator",
X	"Peregrinator",
X	"Traveler",
X	"Traveler",
X	"Journeyer",
X	"Journeyer",
X	"Voyager",
X	"Voyager",
X	"Explorer",
X	"Explorer",
X	"Adventurer",
X	"Adventurer"
X};
X
Xstatic const char *nomad_ranks[] = {
X	"Troglodyte",
X	"Troglodyte",
X	"Aborigine",
X	"Aborigine",
X	"Wanderer",
X	"Wanderer",
X	"Vagrant",
X	"Vagrant",
X	"Wayfarer",
X	"Wayfarer",
X	"Roamer",
X	"Roamer",
X	"Nomad",
X	"Nomad",
X	"Rover",
X	"Rover",
X	"Pioneer",
X	"Pioneer"
X};
X
Xstatic const char *knight_ranks[] = {
X	"Gallant",
X	"Gallant",
X	"Esquire",
X	"Esquire",
X	"Bachelor",
X	"Bachelor",
X	"Sergeant",
X	"Sergeant",
X	"Knight",
X	"Knight",
X	"Banneret",
X	"Banneret",
X	"Chevalier",
X	"Chevalier",
X	"Seignieur",
X	"Seignieur",
X	"Paladin",
X	"Paladin"
X};
X
Xstatic const char *archeo_ranks[] = {
X	"Digger",
X	"Digger",
X	"Field Worker",
X	"Field Worker",
X	"Investigator",
X	"Investigator",
X	"Exhumer",
X	"Exhumer",
X	"Excavator",
X	"Excavator",
X	"Spelunker",
X	"Spelunker",
X	"Speleologist",
X	"Speleologist",
X	"Collector",
X	"Collector",
X	"Curator",
X	"Curator"
X};
X
Xstatic const char *healer_ranks[] = {
X	"Pre-Med",
X	"Pre-Med",
X	"Med Student",
X	"Med Student",
X	"Medic",
X	"Medic",
X	"Intern",
X	"Intern",
X	"Doctor",
X	"Doctor",
X	"Physician",
X	"Physician",
X	"Specialist",
X	"Specialist",
X	"Surgeon",
X	"Surgeon",
X	"Chief Surgeon",
X	"Chief Surgeon"
X};
X
Xstatic const char *barbarian_ranks[] = {
X	"Plunderer",
X	"Plunderess",
X	"Pillager",
X	"Pillager",
X	"Bandit",
X	"Bandit",
X	"Brigand",
X	"Brigand",
X	"Raider",
X	"Raider",
X	"Reaver",
X	"Reaver",
X	"Slayer",
X	"Slayer",
X	"Chieftain",
X	"Chieftainess",
X	"Conqueror",
X	"Conqueress"
X};
X
Xstatic const char *ninja_ranks[] = {
X	"Chigo",
X	"Chigo",
X	"Bushi",
X	"Bushi",
X	"Genin",
X	"Genin",
X	"Genin",
X	"Genin",
X	"Chunin",
X	"Chunin",
X	"Chunin",
X	"Chunin",
X	"Jonin",
X	"Jonin",
X	"Jonin",
X	"Jonin",
X	"Jonin",
X	"Jonin",
X};
X
Xstatic const char *elf_ranks[] = {
X	"Edhel",
X	"Elleth",
X	"Edhel",
X	"Elleth", 	/* elf-maid */
X	"Ohtar", 	/* warrior */
X	"Ohtie",
X	"Kano", 	/* commander (Q.) ['a] */
X	"Kanie", 	/* educated guess, until further research- SAC */
X	"Arandur", 	/* king's servant, minister (Q.) - educated guess */
X	"Aranduriel", 	/* educated guess */
X	"Hir", 		/* lord (S.) */
X	"Hiril", 	/* lady (S.) ['ir] */
X	"Aredhel", 	/* noble elf (S.) */
X	"Arwen", 	/* noble maiden (S.) */
X	"Ernil", 	/* prince (S.) */
X	"Elentariel", 	/* elf-maiden (Q.) */
X	"Elentar", 	/* Star-king (Q.) */
X	"Elentari", 	/* Star-queen (Q.) */ /* Elbereth (S.) */
X};
X
Xstatic const char **
Xrank_array() {
X	register const char **ranks;
X
X	switch(pl_character[0]) {
X		case 'A':  ranks = archeo_ranks; break;
X		case 'B':  ranks = barbarian_ranks; break;
X		case 'C':  ranks = nomad_ranks; break;
X		case 'E':  ranks = elf_ranks; break;
X		case 'H':  ranks = healer_ranks; break;
X		case 'K':  ranks = knight_ranks; break;
X		case 'P':  ranks = priest_ranks; break;
X		case 'R':  ranks = thief_ranks; break;
X		case 'S':  ranks = ninja_ranks; break;
X		case 'T':  ranks = tourist_ranks; break;
X		case 'V':  ranks = fighter_ranks; break;
X		case 'W':  ranks = mage_ranks; break;
X		default:   ranks = 0; break;
X	}
X	return(ranks);
X}
X
Xstatic char *
Xrank() {
X	register int place;
X	register const char **ranks = rank_array();
X
X	if(u.ulevel < 3) place = 0;
X	else if(u.ulevel <  6) place =  2;
X	else if(u.ulevel < 10) place =  4;
X	else if(u.ulevel < 14) place =  6;
X	else if(u.ulevel < 18) place =  8;
X	else if(u.ulevel < 22) place = 10;
X	else if(u.ulevel < 26) place = 12;
X	else if(u.ulevel < 30) place = 14;
X	else place = 16;
X	if(flags.female) place++;
X
X	if (!!ranks) return(ranks[place]);
X	return(pl_character);
X}
X
Xvoid
Xmax_rank_sz() {
X	register int i, maxr = 0;
X	register const char **ranks = rank_array();
X
X	if (!!ranks) {
X		for(i = flags.female; i < 18; i += 2)
X			if(strlen(ranks[i]) > maxr) maxr = strlen(ranks[i]);
X		mrank_sz = maxr;
X	}
X	else mrank_sz = strlen(pl_character);
X}
X
Xstatic void
Xfillbot(row,oldbot,newbot)
Xint row;
Xchar *oldbot, *newbot;
X{
X	register char *ob = oldbot, *nb = newbot;
X	register int i;
X	int fillcol;
X
X	fillcol = min(CO, MAXCO-1);
X
X	/* compress in case line too long */
X	if(strlen(newbot) >= fillcol) {
X		register char *bp0 = newbot, *bp1 = newbot;
X
X		do {
X			if(*bp0 != ' ' || bp0[1] != ' ' || bp0[2] != ' ')
X				*bp1++ = *bp0;
X		} while(*bp0++);
X	}
X	newbot[fillcol] = '\0';
X
X	for(i = 1; i < fillcol; i++) {
X		if(!*nb) {
X			if(*ob || flags.botlx) {
X				/* last char printed may be in middle of line */
X				curs(strlen(newbot)+1,row);
X				cl_end();
X			}
X			break;
X		}
X		if(*ob != *nb) {
X			curs(i,row);
X			(void) putchar(*nb);
X			curx++;
X		}
X		if(*ob) ob++;
X		nb++;
X	}
X	Strcpy(oldbot, newbot);
X}
X
Xstatic void
Xbot1()
X{
X	register int i,j;
X
X	Strcpy(newbot1, plname);
X	if('a' <= newbot1[0] && newbot1[0] <= 'z') newbot1[0] += 'A'-'a';
X	newbot1[10] = 0;
X	Sprintf(eos(newbot1)," the ");
X#ifdef POLYSELF
X	if (u.mtimedone) {
X		char mbot[BUFSZ];
X		int k = 0;
X
X		Strcpy(mbot, mons[u.umonnum].mname);
X		while(mbot[k] != 0) {
X		    if ((k == 0 || (k > 0 && mbot[k-1] == ' ')) &&
X					'a' <= mbot[k] && mbot[k] <= 'z')
X			mbot[k] += 'A' - 'a';
X		    k++;
X		}
X		Sprintf(eos(newbot1), mbot);
X	} else
X		Sprintf(eos(newbot1), rank());
X#else
X	Sprintf(eos(newbot1), rank());
X#endif
X	Sprintf(eos(newbot1),"  ");
X	i = mrank_sz + 15;
X	j = strlen(newbot1);
X	if((i - j) > 0)
X	      do { Sprintf(eos(newbot1)," "); /* pad with spaces */
X		   i--;
X	      } while((i - j) > 0);
X	if(ACURR(A_STR)>18) {
X		if(ACURR(A_STR)>118)
X		    Sprintf(eos(newbot1),"St:%2d ",ACURR(A_STR)-100);
X		else if(ACURR(A_STR)<118)
X		    Sprintf(eos(newbot1), "St:18/%02d ",ACURR(A_STR)-18);
X		else
X		    Sprintf(eos(newbot1),"St:18/** ");
X	} else
X		Sprintf(eos(newbot1), "St:%-1d ",ACURR(A_STR));
X	Sprintf(eos(newbot1),
X		"Dx:%-1d Co:%-1d In:%-1d Wi:%-1d Ch:%-1d",
X		ACURR(A_DEX), ACURR(A_CON), ACURR(A_INT), ACURR(A_WIS), ACURR(A_CHA));
X	Sprintf(eos(newbot1), (u.ualigntyp == U_CHAOTIC) ? "  Chaotic" :
X			(u.ualigntyp == U_NEUTRAL) ? "  Neutral" : "  Lawful");
X#ifdef SCORE_ON_BOTL
X	Sprintf(eos(newbot1)," S:%lu"
X	    ,(u.ugold - u.ugold0 > 0 ? u.ugold - u.ugold0 : 0)
X	    + u.urexp + (50 * maxdlevel)
X	    + (maxdlevel > 20? 1000*((maxdlevel > 30) ? 10 : maxdlevel - 20) :0));
X#endif
X	fillbot(ROWNO+2, oldbot1, newbot1);
X}
X
Xstatic void
Xbot2()
X{
X#ifdef ENDGAME
X	if(dlevel == ENDLEVEL)
X		Sprintf(newbot2, "EndLevel ");
X	else
X#endif
X#ifdef SPELLS
X		Sprintf(newbot2, "Dlvl:%-2d ", dlevel);
X#else
X		Sprintf(newbot2, "Level:%-1d ", dlevel);
X#endif
X	Sprintf(eos(newbot2),
X#ifdef SPELLS
X		"G:%-2ld HP:%d(%d) Pw:%d(%d) AC:%-2d",
X		u.ugold,
X# ifdef POLYSELF
X		u.mtimedone ? u.mh : u.uhp, u.mtimedone ? u.mhmax : u.uhpmax,
X		u.uen, u.uenmax, u.uac);
X# else
X		u.uhp, u.uhpmax, u.uen, u.uenmax, u.uac);
X# endif
X#else
X		"Gold:%-1lu HP:%d(%d) AC:%-1d",
X		u.ugold,
X# ifdef POLYSELF
X		u.mtimedone ? u.mh : u.uhp, u.mtimedone ? u.mhmax : u.uhpmax,
X		u.uac);
X# else
X		u.uhp, u.uhpmax, u.uac);
X# endif
X#endif
X#ifdef POLYSELF
X	if (u.mtimedone)
X		Sprintf(eos(newbot2), " HD:%d", mons[u.umonnum].mlevel);
X	else
X#endif
X#ifdef EXP_ON_BOTL
X	Sprintf(eos(newbot2), " Xp:%u/%-1ld", u.ulevel,u.uexp);
X#else
X	Sprintf(eos(newbot2), " Exp:%u", u.ulevel);
X#endif
X	if(flags.time)
X	    Sprintf(eos(newbot2), " T:%ld", moves);
X	if(strcmp(hu_stat[u.uhs], "        ")) {
X		Sprintf(eos(newbot2), " ");
X		Strcat(newbot2, hu_stat[u.uhs]);
X	}
X	if(Confusion)	   Sprintf(eos(newbot2), " Conf");
X	if(Sick)	   Sprintf(eos(newbot2), " Sick");
X	if(Blinded)	   Sprintf(eos(newbot2), " Blind");
X	if(Stunned)	   Sprintf(eos(newbot2), " Stun");
X	if(Hallucination)  Sprintf(eos(newbot2), " Hallu");
X	fillbot(ROWNO+3, oldbot2, newbot2);
X}
X
Xvoid
Xbot() {
Xregister char *ob1 = oldbot1, *ob2 = oldbot2;
X	if(flags.botlx) *ob1 = *ob2 = 0;
X	bot1();
X	bot2();
X	flags.botl = flags.botlx = 0;
X}
X
X
Xvoid
Xmstatusline(mtmp)
Xregister struct monst *mtmp;
X{
X	pline("Status of %s (%s): ", mon_nam(mtmp),
X		(mtmp->data->maligntyp <= -1) ? "chaotic" :
X		mtmp->data->maligntyp ? "lawful" : "neutral");
X	pline("Level %d  Gold %lu  HP %d(%d)",
X	    mtmp->m_lev, mtmp->mgold, mtmp->mhp, mtmp->mhpmax);
X	pline("AC %d%s%s", mtmp->data->ac,
X	    mtmp->mcan ? ", cancelled" : "" ,mtmp->mtame ? ", tame" : "");
X}
X
Xvoid
Xustatusline()
X{
X	pline("Status of %s (%s%s):", plname,
X		(u.ualign > 3) ? "stridently " :
X		(u.ualign == 3) ? "" :
X		(u.ualign >= 1) ? "haltingly " :
X		(u.ualign == 0) ? "nominally " :
X				"insufficiently ",
X		(u.ualigntyp == U_CHAOTIC) ? "chaotic" :
X		u.ualigntyp ? "lawful" : "neutral");
X	pline("Level %d  Gold %lu  HP %d(%d)  AC %d",
X# ifdef POLYSELF
X		u.mtimedone ? mons[u.umonnum].mlevel : u.ulevel,
X		u.ugold, u.mtimedone ? u.mh : u.uhp,
X		u.mtimedone ? u.mhmax : u.uhpmax, u.uac);
X# else
X		u.ulevel, u.ugold, u.uhp, u.uhpmax, u.uac);
X# endif
X}
X
Xvoid
Xcls()
X{
X	extern xchar tlx, tly;
X
X	if(flags.toplin == 1)
X		more();
X	flags.toplin = 0;
X
X	clear_screen();
X
X	tlx = tly = 1;
X
X	flags.botlx = 1;
X}
X
Xchar
Xrndmonsym()
X{
X	return(mons[rn2(NUMMONS - 1)].mlet);
X}
X
Xstatic const char objsyms[] = {
X	WEAPON_SYM, ARMOR_SYM, POTION_SYM, SCROLL_SYM, WAND_SYM,
X#ifdef SPELLS
X	SPBOOK_SYM,
X#endif
X	RING_SYM, AMULET_SYM, FOOD_SYM, TOOL_SYM, GEM_SYM, GOLD_SYM, ROCK_SYM };
X
Xchar
Xrndobjsym()
X{
X	return objsyms[rn2(SIZE(objsyms))];
X}
X
Xstatic const char *hcolors[] = {
X			"ultraviolet", "infrared", "hot pink", "psychedelic",
X			"bluish-orange", "reddish-green", "dark white",
X			"light black", "loud", "salty", "sweet", "sour",
X			"bitter", "luminescent", "striped", "polka-dotted",
X			"square", "round", "triangular", "brilliant",
X			"navy blue", "cerise", "chartreuse", "mauve",
X			"lime green", "copper", "sea green", "spiral",
X			"swirly", "blotchy", "fluorescent green",
X			"burnt orange", "indigo", "amber", "tan",
X			"sky blue-pink", "lemon yellow", "off-white",
X			"paisley", "plaid", "argyle", "incandescent"};
X
Xconst char *
Xhcolor()
X{
X	return hcolors[rn2(SIZE(hcolors))];
X}
X
X/*  Bug: if a level character is the same as an object/monster, it may be
X *  hilited, because we use a kludge to figure out if a character is an
X *  object/monster symbol.  It's smarter than it was in 2.3, but you
X *  can still fool it (ex. if an object is in a doorway you have not seen,
X *  and you look at a map, the '+' will be taken as a spellbook symbol).
X *
X *  The problem is that whenever a portion of the map needs to be redrawn
X *  (by ^R, after an inventory dropover, after regurgitation...), the
X *  levl[][].scrsym field is used to redraw the map.  A great duplication
X *  of code would be needed to trace back every scrsym to find out what color
X *  it should be.
X *
X *  What is really needed is a levl[][].color field; the color be figured
X *  out at the same time as the screen symbol, and be restored with
X *  redraws.  Unfortunately, as this requires much time and testing,
X *  it will have to wait for NetHack 3.1.  -3.
X */
X
Xstatic void
Xhilite(let,typ)
Xuchar let, typ;
X{
X
X	if (let == ' '
X#ifndef MSDOS
X	    || !flags.standout
X#endif
X	    ) {
X		/* don't hilite spaces; it's pointless colorwise,
X		   and also hilites secret corridors and dark areas. -3. */
X		g_putch(let);
X		return;
X	}
X
X	if (!typ) {
X		char *isobjct = index(obj_symbols, (char) let);
X
X		if (let == GOLD_SYM)
X			typ = AT_GLD;
X#ifdef MSDOSCOLOR
X		else if (let == POOL_SYM)
X			if (HI_BLUE == HI) typ = AT_MAP;
X			else typ = AT_BLUE;
X#endif
X		else if (isobjct != NULL || let == S_MIMIC_DEF)
X			/* is an object */
X			typ = AT_OBJ;
X		else if (ismnst((char) let))
X			/* is a monster */
X			typ = AT_MON;
X	}
X#ifndef MSDOSCOLOR
X	if (typ == AT_MON) revbeg();
X#else
X	switch (typ) {
X	    case AT_MON:
X		xputs(let != S_MIMIC_DEF ? HI_MON : HI_OBJ);
X		break;
X	    case AT_OBJ:
X		xputs(let == GOLD_SYM ? HI_GOLD : HI_OBJ);
X		break;
X	    case AT_MAP:
X		if (!(typ = (let == POOL_SYM)))
X		    break;
X	    case AT_BLUE:
X		xputs(HI_BLUE);
X		break;
X	    case AT_ZAP:
X		xputs(HI_ZAP);
X		break;
X	    case AT_RED:
X		xputs(HI_RED);
X		break;
X	    case AT_WHITE:
X		xputs(HI_WHITE);
X		break;
X	}
X#endif
X
X	g_putch(let);
X
X#ifdef MSDOSCOLOR
X	if (typ) xputs(HE);
X#else
X	if (typ == AT_MON) m_end();
X#endif
X}
X
Xstatic boolean
Xismnst(let)
Xchar let;
X{
X	register int ct;
X	register struct permonst *ptr;
X
X	if (let & 0x80) return 0;
X	if (isalpha(let)) return 1; /* for speed */
X
X	for (ct = 0 ; ct < NUMMONS; ct++) {
X		ptr = &mons[ct];
X		if(ptr->mlet == let) return 1;
X	}
X#ifdef WORM
X	if (let == S_WORM_TAIL) return 1;
X#endif
X	return 0;
X}
END_OF_FILE
if test 23540 -ne `wc -c <'src/pri.c'`; then
    echo shar: \"'src/pri.c'\" unpacked with wrong size!
fi
# end of 'src/pri.c'
fi
echo shar: End of archive 19 \(of 38\).
cp /dev/null ark19isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 38 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
