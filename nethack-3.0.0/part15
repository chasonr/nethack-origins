Path: utzoo!utgpu!jarvis.csri.toronto.edu!mailrus!csd4.milw.wisc.edu!lll-winken!uunet!zephyr.ens.tek.com!tektronix!tekgen!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v07i070:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Part15/38
Message-ID: <4323@tekred.CNA.TEK.COM>
Date: 24 Jul 89 05:04:15 GMT
Sender: nobody@tekred.CNA.TEK.COM
Lines: 2570
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 7, Issue 70
Archive-name: NetHack3/Part15



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 15 (of 38)."
# Contents:  amiga/stdio.h src/invent.c src/lev_lex.c
# Wrapped by billr@saab on Sun Jul 23 21:32:58 1989
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'amiga/stdio.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'amiga/stdio.h'\"
else
echo shar: Extracting \"'amiga/stdio.h'\" \(1780 characters\)
sed "s/^X//" >'amiga/stdio.h' <<'END_OF_FILE'
X/* Copyright (C) 1982, 1984, 1986 by Manx Software Systems */
X#ifndef _STDIO_H
X#define _STDIO_H
X
X#define fgetc getc
X#define fputc putc
X#ifndef NULL
X#define NULL 0L
X#endif
X#define EOF -1
X
X
X#define BUFSIZ 1024
X#define MAXSTREAM       20
X
X#define _BUSY   0x01
X#define _ALLBUF 0x02
X#define _DIRTY  0x04
X#define _EOF    0x08
X#define _IOERR  0x10
X#define _TEMP   0x20    /* temporary file (delete on close) */
X
Xtypedef struct {
X        char *_bp;              /* current position in buffer */
X        char *_bend;            /* last character in buffer + 1 */
X        char *_buff;            /* address of buffer */
X        char _flags;            /* open mode, etc. */
X        char _unit;             /* token returned by open */
X        char _bytbuf;           /* single byte buffer for unbuffer streams */
X        short _buflen;          /* length of buffer */
X        char *_tmpname;         /* name of file for temporaries */
X} FILE;
X
Xextern FILE Cbuffs[];
XFILE *fopen();
Xlong ftell();
X
X#define stdin       (&Cbuffs[0])
X#define stdout      (&Cbuffs[1])
X#define stderr      (&Cbuffs[2])
X#define feof(fp) (((fp)->_flags&_EOF)!=0)
X#define ferror(fp) (((fp)->_flags&_IOERR)!=0)
X#define clearerr(fp) ((fp)->_flags &= ~(_IOERR|_EOF))
X#define fileno(fp) ((fp)->_unit)
X#define rewind(fp) fseek(fp, 0L, 0)
X
X#define P_tmpdir        ""
X#define L_tmpnam        40
X
X/*
X *  The following must be done for NetHack:
X */
X
X#define FFLUSH(fp) flsh_(fp,-1)     /* Was fflush */
X
XFILE *freopen();
Xchar *gets();
X
X#define getchar()   WindowGetchar()
X#define putchar(c)  WindowPutchar(c)
X#define puts(s)     WindowPuts(s)
X#define fputs(s,f)  WindowFPuts(s)
X#define printf      WindowPrintf
X#define fflush(fp)  WindowFlush()
X
X#define xputs(s)    WindowFPuts(s)
X#define xputc(c)    WindowPutchar(c)
X
X#endif
END_OF_FILE
if test 1780 -ne `wc -c <'amiga/stdio.h'`; then
    echo shar: \"'amiga/stdio.h'\" unpacked with wrong size!
fi
# end of 'amiga/stdio.h'
fi
if test -f 'src/invent.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/invent.c'\"
else
echo shar: Extracting \"'src/invent.c'\" \(29364 characters\)
sed "s/^X//" >'src/invent.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)invent.c	3.0	88/10/22
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include	"hack.h"
X
X#ifdef WORM
X#include "lev.h"
X#include "wseg.h"
X#endif
X
X#define	NOINVSYM	'#'
X
Xstatic boolean mergable();
X
Xint lastinvnr = 51;	/* 0 ... 51 */
Xstatic char *xprname();
X
Xchar inv_order[] = {
X	AMULET_SYM, WEAPON_SYM, ARMOR_SYM, FOOD_SYM, SCROLL_SYM,
X#ifdef SPELLS
X	SPBOOK_SYM,
X#endif
X	POTION_SYM, RING_SYM, WAND_SYM, TOOL_SYM, GEM_SYM,
X	ROCK_SYM, BALL_SYM, CHAIN_SYM, 0 };
X
Xstatic void
Xassigninvlet(otmp)
Xregister struct obj *otmp;
X{
X	boolean inuse[52];
X	register int i;
X	register struct obj *obj;
X
X	for(i = 0; i < 52; i++) inuse[i] = FALSE;
X	for(obj = invent; obj; obj = obj->nobj) if(obj != otmp) {
X		i = obj->invlet;
X		if('a' <= i && i <= 'z') inuse[i - 'a'] = TRUE; else
X		if('A' <= i && i <= 'Z') inuse[i - 'A' + 26] = TRUE;
X		if(i == otmp->invlet) otmp->invlet = 0;
X	}
X	if((i = otmp->invlet) &&
X	    (('a' <= i && i <= 'z') || ('A' <= i && i <= 'Z')))
X		return;
X	for(i = lastinvnr+1; i != lastinvnr; i++) {
X		if(i == 52) { i = -1; continue; }
X		if(!inuse[i]) break;
X	}
X	otmp->invlet = (inuse[i] ? NOINVSYM :
X			(i < 26) ? ('a'+i) : ('A'+i-26));
X	lastinvnr = i;
X}
X
X/* merge obj with otmp and delete obj if types agree */
Xstatic int
Xmerged(otmp, obj, lose)
Xregister struct obj *otmp, *obj;
Xregister int lose;
X{
X	if(mergable(otmp, obj)) {
X		/* Approximate age: we do it this way because if we were to
X		 * do it "accurately" (merge only when ages are identical)
X		 * we'd wind up never merging any corpses.
X		 * otmp->age = otmp->age*(1-proportion) + obj->age*proportion;
X		 */
X		otmp->age = ((otmp->age*otmp->quan) + (obj->age*obj->quan))
X			/ (otmp->quan + obj->quan);
X		otmp->quan += obj->quan;
X		otmp->owt += obj->owt;
X		if(lose) freeobj(obj);
X		obfree(obj,otmp);	/* free(obj), bill->otmp */
X		return(1);
X	} else	return(0);
X}
X
Xstruct obj *
Xaddinv(obj)
Xregister struct obj *obj;
X{
X	register struct obj *otmp;
X
X	if (obj->otyp == AMULET_OF_YENDOR && !obj->spe) {
X		if (u.uhave_amulet) impossible ("already have amulet?");
X		u.uhave_amulet = 1;
X	}
X	/* merge or attach to end of chain */
X	if(!invent) {
X		invent = obj;
X		otmp = 0;
X	} else
X	for(otmp = invent; /* otmp */; otmp = otmp->nobj) {
X		if(merged(otmp, obj, 0)) {
X			obj = otmp;
X			goto added;
X		}
X		if(!otmp->nobj) {
X			otmp->nobj = obj;
X			break;
X		}
X	}
X	obj->nobj = 0;
X
X	if(flags.invlet_constant) {
X		assigninvlet(obj);
X		/*
X		 * The ordering of the chain is nowhere significant
X		 * so in case you prefer some other order than the
X		 * historical one, change the code below.
X		 */
X		if(otmp) {	/* find proper place in chain */
X			otmp->nobj = 0;
X			if((invent->invlet ^ 040) > (obj->invlet ^ 040)) {
X				obj->nobj = invent;
X				invent = obj;
X			} else
X			for(otmp = invent; ; otmp = otmp->nobj) {
X			    if(!otmp->nobj ||
X				(otmp->nobj->invlet ^ 040) > (obj->invlet ^ 040)){
X				obj->nobj = otmp->nobj;
X				otmp->nobj = obj;
X				break;
X			    }
X			}
X		}
X	}
X
Xadded:
X	if (obj->otyp == LUCKSTONE) {
X		/* new luckstone must be in inventory by this point
X		 * for correct calculation */
X		if (stone_luck(TRUE) >= 0) u.moreluck = LUCKADD;
X		else u.moreluck = -LUCKADD;
X		flags.botl = 1;
X	}
X	return(obj);
X}
X
Xvoid
Xuseup(obj)
Xregister struct obj *obj;
X{
X	if(obj->quan > 1){
X		obj->quan--;
X		obj->owt = weight(obj);
X	} else {
X		setnotworn(obj);
X		freeinv(obj);
X		obfree(obj, (struct obj *) 0);
X	}
X}
X
Xvoid
Xfreeinv(obj)
Xregister struct obj *obj;
X{
X	register struct obj *otmp;
X
X	if(obj == invent)
X		invent = invent->nobj;
X	else {
X		for(otmp = invent; otmp->nobj != obj; otmp = otmp->nobj)
X			if(!otmp->nobj) panic("freeinv");
X		otmp->nobj = obj->nobj;
X	}
X	if (obj->otyp == AMULET_OF_YENDOR && !obj->spe) {
X		if (!u.uhave_amulet) impossible ("don't have amulet?");
X		u.uhave_amulet = 0;
X	}
X	if (obj->otyp == LOADSTONE)
X		curse(obj);
X	if (obj->otyp == LUCKSTONE) {
X		if (!carrying(LUCKSTONE)) u.moreluck = 0;
X		else if (stone_luck(TRUE) >= 0) u.moreluck = LUCKADD;
X		else u.moreluck = -LUCKADD;
X		flags.botl = 1;
X	}
X}
X
X/* destroy object in fobj chain (if unpaid, it remains on the bill) */
Xvoid
Xdelobj(obj)
Xregister struct obj *obj;
X{
X#ifdef WALKIES
X	if(obj->otyp == LEASH && obj->leashmon != 0) o_unleash(obj);
X#endif
X	freeobj(obj);
X	unpobj(obj);
X
X/*	if contained in something else, decrease the container weight */
X	if(obj->cobj) dec_cwt(obj->cobj, obj);
X
X	obfree(obj, (struct obj *) 0);
X}
X
X/* unlink obj from chain starting with fobj */
Xvoid
Xfreeobj(obj)
Xregister struct obj *obj;
X{
X	register struct obj *otmp;
X	register int found = 0;
X	register struct rm *lev = &levl[obj->ox][obj->oy];
X
X  	lev->omask = 0;
X
X	if(obj == fobj) {
X		fobj = fobj->nobj;
X		found = 1;
X	}
X	for(otmp = fobj; otmp; otmp = otmp->nobj) {
X 	    if (otmp->nobj == obj) {
X		otmp->nobj = obj->nobj;
X		found = 1;
X	    }
X	    if (otmp->ox == obj->ox && otmp->oy == obj->oy) {
X		lev->omask = 1;
X	    }
X	}
X  	if (!found) panic("error in freeobj");
X#ifdef POLYSELF
X	if (!levl[u.ux][u.uy].omask && !levl[u.ux][u.uy].gmask) {
X		u.uundetected = 0;
X		if (!Invisible) pru();
X	}
X#endif
X}
X
X/* Note: freegold throws away its argument! */
Xvoid
Xfreegold(gold)
Xregister struct gold *gold;
X{
X	register struct gold *gtmp;
X
X	levl[gold->gx][gold->gy].gmask = 0;
X
X	if(gold == fgold) fgold = gold->ngold;
X	else {
X		for(gtmp = fgold; gtmp->ngold != gold; gtmp = gtmp->ngold)
X			if(!gtmp) panic("error in freegold");
X		gtmp->ngold = gold->ngold;
X	}
X	free((genericptr_t) gold);
X#ifdef POLYSELF
X	if (!levl[u.ux][u.uy].omask && !levl[u.ux][u.uy].gmask) {
X		u.uundetected = 0;
X		if (!Invisible) pru();
X	}
X#endif
X}
X
Xstruct monst *
Xm_at(x,y)
Xregister int x, y;
X{
X	register struct monst *mtmp;
X#ifdef WORM
X	register struct wseg *wtmp;
X	m_atseg = 0;
X#endif
X
X	for(mtmp = fmon; mtmp; mtmp = mtmp->nmon){
X		if(mtmp->mx == x && mtmp->my == y)
X			return(mtmp);
X#ifdef WORM
X		if(mtmp->wormno){
X		    for(wtmp = wsegs[mtmp->wormno]; wtmp; wtmp = wtmp->nseg)
X		    if(wtmp->wx == x && wtmp->wy == y){
X			m_atseg = wtmp;
X			return(mtmp);
X		    }
X		}
X#endif
X	}
X	return((struct monst *)0);
X}
X
Xstruct obj *
Xo_at(x,y)
Xregister int x, y;
X{
X	register struct obj *otmp;
X
X	for(otmp = fobj; otmp; otmp = otmp->nobj)
X		if(otmp->ox == x && otmp->oy == y) return(otmp);
X	return((struct obj *)0);
X}
X
Xstruct obj *
Xsobj_at(n,x,y)
Xregister int n, x, y;
X{
X	register struct obj *otmp;
X
X	if(levl[x][y].omask)
X	    for(otmp = fobj; otmp; otmp = otmp->nobj)
X		if(otmp->ox == x && otmp->oy == y && otmp->otyp == n)
X		    return(otmp);
X	return((struct obj *)0);
X}
X
Xint
Xcarried(obj)
Xregister struct obj *obj;
X{
X	register struct obj *otmp;
X
X	for(otmp = invent; otmp; otmp = otmp->nobj)
X		if(otmp == obj) return(1);
X	return(0);
X}
X
Xstruct obj *
Xcarrying(type)
Xregister int type;
X{
X	register struct obj *otmp;
X
X	for(otmp = invent; otmp; otmp = otmp->nobj)
X		if(otmp->otyp == type)
X			return(otmp);
X	return((struct obj *) 0);
X}
X
Xstruct obj *
Xo_on(id, objchn)
Xunsigned int id;
Xregister struct obj *objchn;
X{
X	while(objchn) {
X		if(objchn->o_id == id) return(objchn);
X		objchn = objchn->nobj;
X	}
X	return((struct obj *) 0);
X}
X
Xstruct gold *
Xg_at(x,y)
Xregister int x, y;
X{
X	register struct gold *gold = fgold;
X	while(gold) {
X		if(gold->gx == x && gold->gy == y) return(gold);
X		gold = gold->ngold;
X	}
X	return((struct gold *)0);
X}
X
X/* make dummy object structure containing gold - for temporary use only */
Xstatic
Xstruct obj *
Xmkgoldobj(q)
Xregister long q;
X{
X	register struct obj *otmp;
X
X	otmp = newobj(0);
X	/* should set o_id etc. but otmp will be freed soon */
X	otmp->olet = GOLD_SYM;
X	u.ugold -= q;
X	OGOLD(otmp) = q;
X	flags.botl = 1;
X	return(otmp);
X}
X
X/*
X * getobj returns:
X *	struct obj *xxx:	object to do something with.
X *	(struct obj *) 0	error return: no object.
X *	&zeroobj		explicitly no object (as in w-).
X */
Xstruct obj *
Xgetobj(let,word)
Xregister char *let,*word;
X{
X	register struct obj *otmp;
X	register char ilet,ilet1,ilet2;
X	char buf[BUFSZ];
X	char lets[BUFSZ];
X	register int foo = 0, foo2;
X	register char *bp = buf;
X	xchar allowcnt = 0;	/* 0, 1 or 2 */
X	boolean allowgold = FALSE, usegold = FALSE;
X		/* usegold is needed so that they are given a different message
X		 * if gold is prohibited because it's inappropriate, or because
X		 * it's appropriate if only they had any.
X		 */
X	boolean allowall = FALSE;
X	boolean allownone = FALSE;
X	xchar foox = 0;
X	long cnt;
X
X	if(*let == '0') let++, allowcnt = 1;
X	if(*let == GOLD_SYM) let++,
X		usegold = TRUE, allowgold = (u.ugold ? TRUE : FALSE);
X	if(*let == '#') let++, allowall = TRUE;
X	if(*let == '-') let++, allownone = TRUE;
X	if(allownone) *bp++ = '-';
X	if(allowgold) *bp++ = GOLD_SYM;
X	if(bp > buf && bp[-1] == '-') *bp++ = ' ';
X
X	ilet = 'a';
X	for(otmp = invent; otmp; otmp = otmp->nobj){
X	    if(!*let || index(let, otmp->olet)) {
X		bp[foo++] = flags.invlet_constant ? otmp->invlet : ilet;
X
X		/* ugly check: remove inappropriate things */
X		if((!strcmp(word, "take off") &&
X		    (!(otmp->owornmask & (W_ARMOR | W_RING | W_AMUL | W_TOOL))
X		     || (otmp==uarm && uarmc)
X#ifdef SHIRT
X		     || (otmp==uarmu && (uarm || uarmc))
X#endif
X		    ))
X		|| (!strcmp(word, "wear") &&
X		     (otmp->owornmask & (W_ARMOR | W_RING | W_AMUL | W_TOOL)))
X							/* already worn */
X		|| (!strcmp(word, "wield") &&
X		    (otmp->owornmask & W_WEP))
X		    ) {
X			foo--;
X			foox++;
X		}
X
X		/* Second ugly check; unlike the first it won't trigger an
X		 * "else" in "you don't have anything else to ___".
X		 */
X		if ((!strcmp(word, "wear") &&
X		    (otmp->olet == TOOL_SYM && otmp->otyp != BLINDFOLD))
X		|| (!strcmp(word, "can") &&
X		    (otmp->otyp != CORPSE))
X		|| (!strcmp(word, "write with") &&
X		    (otmp->olet == TOOL_SYM && otmp->otyp != MAGIC_MARKER))
X		|| (!strcmp(word, "rub") &&
X		    (otmp->olet == TOOL_SYM &&
X		     otmp->otyp != LAMP && otmp->otyp != MAGIC_LAMP))
X		    )
X			foo--;
X	    }
X	    if(ilet == 'z') ilet = 'A'; else ilet++;
X	}
X	bp[foo] = 0;
X	if(foo == 0 && bp > buf && bp[-1] == ' ') *--bp = 0;
X	Strcpy(lets, bp);	/* necessary since we destroy buf */
X	if(foo > 5) {			/* compactify string */
X		foo = foo2 = 1;
X		ilet2 = bp[0];
X		ilet1 = bp[1];
X		while(ilet = bp[++foo2] = bp[++foo]){
X			if(ilet == ilet1+1){
X				if(ilet1 == ilet2+1)
X					bp[foo2 - 1] = ilet1 = '-';
X				else if(ilet2 == '-') {
X					bp[--foo2] = ++ilet1;
X					continue;
X				}
X			}
X			ilet2 = ilet1;
X			ilet1 = ilet;
X		}
X	}
X	if(!foo && !allowall && !allowgold && !allownone) {
X		You("don't have anything %sto %s.",
X			foox ? "else " : "", word);
X		return((struct obj *)0);
X	}
X	for(;;) {
X		if(!buf[0]) {
X#ifdef REDO
X		    if(!in_doagain)
X#endif
X			pline("What do you want to %s? [*] ", word);
X		} else {
X#ifdef REDO
X		    if(!in_doagain)
X#endif
X			pline("What do you want to %s? [%s or ?*] ",
X				word, buf);
X		}
X		cnt = 0;
X		ilet = readchar();
X		while(digit(ilet) && allowcnt) {
X#ifdef REDO
X			if (ilet != '?' && ilet != '*')	savech(ilet);
X#endif
X			cnt = 10*cnt + (ilet - '0');
X			allowcnt = 2;	/* signal presence of cnt */
X			ilet = readchar();
X		}
X		if(digit(ilet)) {
X			pline("No count allowed with this command.");
X			continue;
X		}
X		if(index(quitchars,ilet)) {
X		    if(flags.verbose)
X			pline("Never mind.");
X		    return((struct obj *)0);
X		}
X		if(ilet == '-') {
X			return(allownone ? &zeroobj : (struct obj *) 0);
X		}
X		if(ilet == GOLD_SYM) {
X			if(!usegold){
X				You("cannot %s gold.", word);
X				return(struct obj *)0;
X			} else if (!allowgold) {
X				You("are not carrying any gold.");
X				return(struct obj *)0;
X			}
X			if(!(allowcnt == 2 && cnt < u.ugold))
X				cnt = u.ugold;
X			return(mkgoldobj(cnt));
X		}
X		if(allowcnt == 2 && !strcmp(word,"throw")) {
X			/* permit counts for throwing gold, but don't accept
X			 * counts for other things since the throw code will
X			 * split off a single item anyway */
X			allowcnt = 1;
X			if(cnt != 1) {
X			    pline("You can only throw one item at a time.");
X			    continue;
X			}
X		}
X		if(ilet == '?') {
X			doinv(lets);
X			if(!(ilet = morc)) continue;
X			/* he typed a letter (not a space) to more() */
X		} else if(ilet == '*') {
X			doinv(NULL);
X			if(!(ilet = morc)) continue;
X			/* ... */
X		}
X#ifdef REDO
X		if (ilet != '?' && ilet != '*')	savech(ilet);
X#endif
X		if(flags.invlet_constant) {
X			for(otmp = invent; otmp; otmp = otmp->nobj)
X				if(otmp->invlet == ilet) break;
X		} else {
X			if(ilet >= 'A' && ilet <= 'Z') ilet += 'z'-'A'+1;
X			ilet -= 'a';
X			for(otmp = invent; otmp && ilet;
X					ilet--, otmp = otmp->nobj) ;
X		}
X		if(!otmp) {
X			You("don't have that object.");
X			continue;
X		}
X		if(cnt < 0 || otmp->quan < cnt) {
X			You("don't have that many!  You have only %u."
X			, otmp->quan);
X			continue;
X		}
X		break;
X	}
X	if(!allowall && let && !index(let,otmp->olet)) {
X		pline("That is a silly thing to %s.",word);
X		return((struct obj *)0);
X	}
X	if(allowcnt == 2) {	/* cnt given */
X		if(cnt == 0) return (struct obj *)0;
X		if(cnt != otmp->quan) {
X			register struct obj *obj;
X#ifdef LINT	/*splitobj for (long )cnt > 30000 && sizeof(int) == 2*/
X			obj = (struct obj *)0;
X#else
X			if (sizeof(int) == 2)
X				obj = splitobj(otmp,
X					(int )(cnt >30000 ? 30000 : cnt));
X			else
X				obj = splitobj(otmp, (int) cnt);
X#endif
X			if(otmp == uwep) setuwep(obj);
X		}
X	}
X	return(otmp);
X}
X
Xstatic int
Xckunpaid(otmp)
Xregister struct obj *otmp;
X{
X	return((int)(otmp->unpaid));
X}
X
Xstatic boolean
Xwearing_armor() {
X	return(uarm || uarmc || uarmf || uarmg || uarmh || uarms
X#ifdef SHIRT
X		|| uarmu
X#endif
X		);
X}
X
Xstatic boolean
Xis_worn(otmp)
Xregister struct obj *otmp;
X{
X    return(!!(otmp->owornmask & (W_ARMOR | W_RING | W_AMUL | W_TOOL | W_WEP)));
X}
X
Xstatic const char removeables[] =
X	{ ARMOR_SYM, WEAPON_SYM, RING_SYM, AMULET_SYM, TOOL_SYM, ' ', 0 };
X
X/* interactive version of getobj - used for Drop, Identify and */
X/* Takeoff (A). Return the number of times fn was called successfully */
Xint
Xggetobj(word, fn, mx)
Xregister char *word;
Xregister int (*fn)(), mx;
X{
X	char buf[BUFSZ];
X	register char *ip;
X	register char sym;
X	register int oletct = 0, iletct = 0;
X	register boolean allflag = FALSE;
X	char olets[20], ilets[20];
X	int (*ckfn)() = (int (*)()) 0;
X	xchar allowgold = (u.ugold && !strcmp(word, "drop")) ? 1 : 0; /* BAH */
X	register boolean takeoff = !strcmp(word, "take off");
X
X	if(takeoff && !wearing_armor() && !uwep && !uamul &&
X			!uleft && !uright && !ublindf) {
X		You("are not wearing anything.");
X		return(0);
X	}
X	if(!invent && !allowgold){
X		You("have nothing to %s.", word);
X		return(0);
X	} else {
X		register struct obj *otmp = invent;
X		register int uflg = 0;
X
X		if(allowgold) ilets[iletct++] = GOLD_SYM;
X		ilets[iletct] = 0;
X		while(otmp) {
X			if(!index(ilets, otmp->olet)){
X			    if(!takeoff || is_worn(otmp))
X				ilets[iletct++] = otmp->olet;
X			    ilets[iletct] = 0;
X			}
X			if(otmp->unpaid) uflg = 1;
X			otmp = otmp->nobj;
X		}
X		ilets[iletct++] = ' ';
X		if(uflg && !takeoff) ilets[iletct++] = 'u';
X		if(invent && !takeoff) ilets[iletct++] = 'a';
X		ilets[iletct] = 0;
X	}
X	pline("What kinds of thing do you want to %s? [%s] ",
X		word, ilets);
X	getlin(buf);
X	if(buf[0] == '\033') {
X		clrlin();
X		return(0);
X	}
X	ip = buf;
X	olets[0] = 0;
X	while(sym = *ip++){
X		if(sym == ' ') continue;
X		if(takeoff) {
X		    if(!index(removeables,sym)) {
X			pline("Not applicable.");
X			return(0);
X		    } else if(sym == ARMOR_SYM && !wearing_armor()) {
X			You("are not wearing any armor.");
X			return(0);
X		    } else if(sym == WEAPON_SYM && !uwep) {
X			You("are not wielding anything.");
X			return(0);
X		    } else if(sym == RING_SYM && !uright && !uleft) {
X			You("are not wearing rings.");
X			return(0);
X		    } else if(sym == AMULET_SYM && !uamul) {
X			You("are not wearing an amulet.");
X			return(0);
X		    } else if(sym == TOOL_SYM && !ublindf) {
X			You("are not wearing a blindfold.");
X			return(0);
X		    }
X		}
X		if(sym == GOLD_SYM) {
X			if(allowgold == 1)
X				(*fn)(mkgoldobj(u.ugold));
X			else if(!u.ugold)
X				You("have no gold.");
X			allowgold = 2;
X		} else if(sym == 'a' || sym == 'A')
X			allflag = TRUE;
X		else if(sym == 'u' || sym == 'U')
X			ckfn = ckunpaid;
X		else if(index(inv_order, sym)) {
X			if(!index(olets, sym)) {
X				olets[oletct++] = sym;
X				olets[oletct] = 0;
X			}
X		} else You("don't have any %c's.", sym);
X	}
X	if(allowgold == 2 && !oletct)
X		return(1);	/* he dropped gold (or at least tried to) */
X	else
X		return(askchain(invent, TRUE, olets, allflag, fn, ckfn, mx, word));
X}
X
X/*
X * Walk through the chain starting at objchn and ask for all objects
X * with olet in olets (if nonNULL) and satisfying ckfn (if nonNULL)
X * whether the action in question (i.e., fn) has to be performed.
X * If allflag then no questions are asked. Max gives the max nr of
X * objects to be treated. Return the number of objects treated.
X * If ininv is TRUE, the objects are in the player's inventory.
X */
Xint
Xaskchain(objchn, ininv, olets, allflag, fn, ckfn, mx, word)
Xregister struct obj *objchn;
Xregister int ininv, allflag, mx;
Xregister char *olets, *word;
Xregister int (*fn)(), (*ckfn)();
X{
X	register struct obj *otmp, *otmp2;
X	register char sym, ilet;
X	register int cnt = 0, dud = 0;
X	register boolean takeoff, nodot;
X
X	takeoff = !strcmp(word, "take off");
X	nodot = (!strcmp(word, "nodot") || !strcmp(word, "drop") ||
X	   		!strcmp(word, "identify") || takeoff);
X	/* changes so the askchain is interrogated in the order specified.
X	 * For example, if a person specifies =/ then first all rings will be
X	 * asked about followed by all wands -dgk
X	 */
Xnextclass:
X	ilet = 'a'-1;
X	for(otmp = (ininv ? invent : objchn); otmp; otmp = otmp2){
X		if(ilet == 'z') ilet = 'A'; else ilet++;
X		otmp2 = otmp->nobj;
X		if (olets && *olets && otmp->olet != *olets) continue;
X		if(takeoff && !is_worn(otmp)) continue;
X		if(ckfn && !(*ckfn)(otmp)) continue;
X		if(!allflag) {
X			if(ininv) {
X			    if (nodot)
X				 pline(xprname(otmp, ilet, FALSE));
X			    else pline(xprname(otmp, ilet, TRUE));
X			}
X			else
X			    pline(doname(otmp));
X			addtopl("? ");
X			sym = nyaq();
X		}
X		else	sym = 'y';
X
X		switch(sym){
X		case 'a':
X			allflag = 1;
X		case 'y':
X			cnt += (*fn)(otmp);
X			if(--mx == 0) goto ret;
X		case 'n':
X			if(nodot) dud++;
X		default:
X			break;
X		case 'q':
X			goto ret;
X		}
X	}
X	if (olets && *olets && *++olets)
X		goto nextclass;
X	if(!takeoff && (dud || cnt)) pline("That was all.");
X	else if(!dud && !cnt) pline("No applicable objects.");
Xret:
X	return(cnt);
X}
X
Xstatic char
Xobj_to_let(obj)	/* should of course only be called for things in invent */
Xregister struct obj *obj;
X{
X	register struct obj *otmp;
X	register char ilet;
X
X	if(flags.invlet_constant)
X		return(obj->invlet);
X	ilet = 'a';
X	for(otmp = invent; otmp && otmp != obj; otmp = otmp->nobj)
X		if(++ilet > 'z') ilet = 'A';
X	return(otmp ? ilet : NOINVSYM);
X}
X
Xvoid
Xprinv(obj)
Xregister struct obj *obj;
X{
X	pline(xprname(obj, obj_to_let(obj), TRUE));
X}
X
Xstatic char *
Xxprname(obj,let,dot)
Xregister struct obj *obj;
Xregister char let;
Xregister boolean dot;
X{
X#ifdef LINT	/* handle static char li[BUFSZ]; */
X	char li[BUFSZ];
X#else
X	static char li[BUFSZ];
X#endif
X
X	Sprintf(li, "%c - %s",
X		(flags.invlet_constant ? obj->invlet : let),
X		doname(obj));
X	if(dot) Sprintf(eos(li),".");
X	return(li);
X}
X
Xint
Xddoinv()
X{
X	doinv(NULL);
X	return 0;
X}
X
X/* called with 0 or "": all objects in inventory */
X/* otherwise: all objects with (serial) letter in lets */
Xvoid
Xdoinv(lets)
Xregister char *lets;
X{
X	register struct obj *otmp;
X	register char ilet;
X	int ct = 0;
X	char any[BUFSZ];
X	char *invlet = inv_order;
X	int classcount = 0;
X
X	morc = 0;		/* just to be sure */
X
X	if(!invent){
X		pline("Not carrying anything.");
X		return;
X	}
X	if (lets != NULL) {
X		for(ct=0; lets[ct]; ct++) {
X			if (ct >= 52) {
X				impossible("bad lets contents");
X				break;
X			}
X		}
X		if (ct==1) {
X			ilet = 'a';
X			for(otmp = invent; otmp; otmp = otmp->nobj) {
X				if(flags.invlet_constant) ilet = otmp->invlet;
X
X				if (ilet == lets[0])
X					pline(xprname(otmp, lets[0], TRUE));
X
X				if(!flags.invlet_constant)
X					if(++ilet > 'z') ilet = 'A';
X			}
X			return;
X		}
X	}
X	ct = 0;
X
X	cornline(0, NULL);
Xnextclass:
X	classcount = 0;
X	ilet = 'a';
X	for(otmp = invent; otmp; otmp = otmp->nobj) {
X		if(flags.invlet_constant) ilet = otmp->invlet;
X		if(!lets || !*lets || index(lets, ilet)) {
X			if (!flags.sortpack || otmp->olet == *invlet) {
X				if (flags.sortpack && !classcount) {
X					cornline(1, let_to_name(*invlet));
X					classcount++;
X				}
X				cornline(1, xprname(otmp, ilet, TRUE));
X				any[ct++] = ilet;
X			}
X		}
X		if(!flags.invlet_constant) if(++ilet > 'z') ilet = 'A';
X	}
X	if (flags.sortpack && *++invlet) goto nextclass;
X	any[ct] = 0;
X	cornline(2, any);
X}
X
Xint
Xdotypeinv()				/* free after Robert Viduya */
X/* Changed to one type only, so he doesn't have to type cr */
X{
X    	char c, ilet;
X    	char stuff[BUFSZ];
X    	register int stct;
X    	register struct obj *otmp;
X    	boolean billx = inshop() && doinvbill(0);
X    	boolean unpd = FALSE;
X
X	if (!invent && !u.ugold && !billx) {
X	    You("aren't carrying anything.");
X	    return 0;
X	}
X
X	stct = 0;
X	if(u.ugold) stuff[stct++] = GOLD_SYM;
X	stuff[stct] = 0;
X	for(otmp = invent; otmp; otmp = otmp->nobj) {
X	    if (!index (stuff, otmp->olet)) {
X		stuff[stct++] = otmp->olet;
X		stuff[stct] = 0;
X	    }
X	    if(otmp->unpaid)
X		unpd = TRUE;
X	}
X	if(unpd) stuff[stct++] = 'u';
X	if(billx) stuff[stct++] = 'x';
X	stuff[stct] = 0;
X
X	if(stct > 1) {
X#ifdef REDO
X	  if (!in_doagain)
X#endif
X	    pline ("What type of object do you want an inventory of? [%s] ",
X			stuff);
X	    c = readchar();
X#ifdef REDO
X	    savech(c);
X#endif
X	    if(index(quitchars,c)) {
X	    	    clrlin();
X	    	    return 0;
X	    }
X	} else
X	    c = stuff[0];
X
X	if(c == GOLD_SYM)
X	    return(doprgold());
X
X	if(c == 'x' || c == 'X') {
X	    if(billx)
X		(void) doinvbill(1);
X	    else
X		pline("No used-up objects on the shopping bill.");
X	    return(0);
X	}
X
X	if((c == 'u' || c == 'U') && !unpd) {
X		You("are not carrying any unpaid objects.");
X		return(0);
X	}
X
X	stct = 0;
X	ilet = 'a';
X	for (otmp = invent; otmp; otmp = otmp -> nobj) {
X	    if(flags.invlet_constant) ilet = otmp->invlet;
X	    if (c == otmp -> olet || (c == 'u' && otmp -> unpaid))
X		stuff[stct++] = ilet;
X	    if(!flags.invlet_constant) if(++ilet > 'z') ilet = 'A';
X	}
X	stuff[stct] = '\0';
X	if(stct == 0)
X		You("have no such objects.");
X	else
X		doinv (stuff);
X
X	return(0);
X}
X
X/* look at what is here */
Xint
Xdolook() {
X    	register struct obj *otmp, *otmp0;
X    	register struct gold *gold;
X    	char *verb = Blind ? "feel" : "see";
X    	int ct = 0;
X    	int fd = 0;
X
X    	read_engr_at(u.ux, u.uy); /* Eric Backus */
X    	if(!u.uswallow) {
X		otmp0 = o_at(u.ux, u.uy);
X		gold = g_at(u.ux, u.uy);
X    	}  else  {
X		You("%s no objects here.", verb);
X		return(!!Blind);
X    	}
X
X	if(IS_DOOR(levl[u.ux][u.uy].typ))  {
X		fd++;
X		switch(levl[u.ux][u.uy].doormask) {
X		    case D_NODOOR:
X			pline("There is a doorway here."); break;
X		    case D_ISOPEN:
X			pline("There is an open door here."); break;
X		    case D_BROKEN:
X			pline("There is a broken door here."); break;
X		    default:
X			pline("There is a closed door here.");
X		}
X	}
X    	/* added by GAN 10/30/86 */
X#ifdef FOUNTAINS
X    	if(IS_FOUNTAIN(levl[u.ux][u.uy].typ))  {
X		fd++;
X		pline("There is a fountain here.");
X    	}
X#endif
X#ifdef THRONES
X    	if(IS_THRONE(levl[u.ux][u.uy].typ))  {
X		fd++;
X		pline("There is an opulent throne here.");
X    	}
X#endif
X#ifdef SINKS
X    	if(IS_SINK(levl[u.ux][u.uy].typ))  {
X		fd++;
X		pline("There is a kitchen sink here.");
X    	}
X#endif
X#ifdef ALTARS
X    	if(IS_ALTAR(levl[u.ux][u.uy].typ))  {
X		char *al;
X
X		fd++;
X		switch (levl[u.ux][u.uy].altarmask & ~A_SHRINE) {
X			case 0: al = "chaotic"; break;
X			case 1: al = "neutral"; break;
X			default: al = "lawful"; break;
X		}
X		pline("There is an altar to %s here (%s).", a_gname(), al);
X    	}
X#endif
X
X    	if(u.ux == xupstair && u.uy == yupstair)  {
X		fd++;
X		pline("There is a stairway up here.");
X    	}
X    	if(u.ux == xdnstair && u.uy == ydnstair)  {
X		fd++;
X		pline("There is a stairway down here.");
X    	}
X#ifdef STRONGHOLD
X    	if(u.ux == xupladder && u.uy == yupladder)	{
X		fd++;
X		pline("There is a ladder up here.");
X    	}
X    	if(u.ux == xdnladder && u.uy == ydnladder)	{
X		fd++;
X		pline("There is a ladder down here.");
X    	}
X    	if (levl[u.ux][u.uy].typ == DRAWBRIDGE_DOWN) {
X		fd++;
X		pline("There is a lowered drawbridge here.");
X    	}
X#endif /* STRONGHOLD /**/
X
X    	if(Blind)  {
X		You("try to feel what is lying here on the floor.");
X	 	if(Levitation)  {
X			pline("But you can't reach it!");
X			return(0);
X	 	}
X    	}
X
X    	if(!otmp0 && !gold) {
X		if(Blind || !fd)
X			You("%s no objects here.", verb);
X		return(!!Blind);
X    	}
X
X    	cornline(0, "Things that are here:");
X    	for(otmp = otmp0; otmp; otmp = otmp->nobj) {
X		if(otmp->ox == u.ux && otmp->oy == u.uy) {
X	    		ct++;
X	    		cornline(1, doname(otmp));
X
X	    		if(Blind  && !uarmg &&
X#ifdef POLYSELF
X			!resists_ston(uasmon) &&
X#endif
X	       		(otmp->otyp == CORPSE && otmp->corpsenm == PM_COCKATRICE)) {
X			    pline("Touching the dead cockatrice is a fatal mistake...");
X			    You("turn to stone...");
X			    killer = "dead cockatrice";
X		 	    done("stoned");
X	    		}
X		}
X    	}
X
X    	if(gold) {
X		char gbuf[30];
X
X		Sprintf(gbuf, "%ld gold piece%s",
X			gold->amount, plur(gold->amount));
X		if(!ct++)
X	    		You("%s here %s.", verb, gbuf);
X		else
X	    		cornline(1, gbuf);
X    	}
X
X    	if(ct == 1 && !gold) {
X		You("%s here %s.", verb, doname(otmp0));
X		cornline(3, NULL);
X    	}
X    	if(ct > 1)
X		cornline(2, NULL);
X    	return(!!Blind);
X}
X
Xvoid
Xstackobj(obj)
Xregister struct obj *obj;
X{
X	register struct obj *otmp = fobj;
X	for(otmp = fobj; otmp; otmp = otmp->nobj) if(otmp != obj)
X		if(otmp->ox == obj->ox && otmp->oy == obj->oy &&
X			merged(obj,otmp,1))
X				break;
X	return;
X}
X
Xstatic boolean
Xmergable(otmp, obj)	/* returns TRUE if obj  & otmp can be merged */
X	register struct obj *otmp, *obj;
X{
X	if(obj->otyp != otmp->otyp || obj->unpaid != otmp->unpaid ||
X	   obj->spe != otmp->spe || obj->dknown != otmp->dknown ||
X	   (obj->bknown != otmp->bknown && pl_character[0] != 'P') ||
X	   obj->cursed != otmp->cursed || obj->blessed != otmp->blessed ||
X	   obj->no_charge != otmp->no_charge || 
X	   obj->otrapped != otmp->otrapped)
X	    return(FALSE);
X
X	else if((obj->olet==WEAPON_SYM || obj->olet==ARMOR_SYM) &&
X		obj->rustfree != otmp->rustfree) return FALSE;
X
X	else if(obj->otyp == CORPSE || obj->otyp == EGG || obj->otyp == TIN)
X		return( (obj->corpsenm == otmp->corpsenm) &&
X			(!ONAME(obj) || !strcmp(ONAME(obj), ONAME(otmp))) );
X
X	else if(obj->known == otmp->known) {
X		return(objects[obj->otyp].oc_merge);
X	} else return(FALSE);
X}
X
Xint
Xdoprgold(){
X	if(!u.ugold)
X		You("do not carry any gold.");
X	else
X		You("are carrying %ld gold piece%s.", u.ugold, plur(u.ugold));
X	return 0;
X}
X
Xint
Xdoprwep()
X{
X	if(!uwep) You("are empty %s.", body_part(HANDED));
X	else prinv(uwep);
X	return 0;
X}
X
Xint
Xdoprarm(){
X	if(!wearing_armor())
X		You("are not wearing any armor.");
X	else {
X#ifdef SHIRT
X		char lets[8];
X#else
X		char lets[7];
X#endif
X		register int ct = 0;
X
X#ifdef SHIRT
X		if(uarmu) lets[ct++] = obj_to_let(uarmu);
X#endif
X		if(uarm) lets[ct++] = obj_to_let(uarm);
X		if(uarmc) lets[ct++] = obj_to_let(uarmc);
X		if(uarmh) lets[ct++] = obj_to_let(uarmh);
X		if(uarms) lets[ct++] = obj_to_let(uarms);
X		if(uarmg) lets[ct++] = obj_to_let(uarmg);
X		if(uarmf) lets[ct++] = obj_to_let(uarmf);
X		lets[ct] = 0;
X		doinv(lets);
X	}
X	return 0;
X}
X
Xint
Xdoprring(){
X	if(!uleft && !uright)
X		You("are not wearing any rings.");
X	else {
X		char lets[3];
X		register int ct = 0;
X
X		if(uleft) lets[ct++] = obj_to_let(uleft);
X		if(uright) lets[ct++] = obj_to_let(uright);
X		lets[ct] = 0;
X		doinv(lets);
X	}
X	return 0;
X}
X
Xint
Xdopramulet(){
X	if (!uamul)
X		You("are not wearing an amulet.");
X	else
X		prinv(uamul);
X	return 0;
X}
X
Xint
Xdoprtool(){
X	register struct obj *otmp;
X	register int ct=0;
X	char lets[3]; /* Maximum: pick-axe, blindfold */
X
X	for(otmp = invent; otmp; otmp = otmp->nobj) {
X		if (((otmp->owornmask & W_TOOL) && otmp->olet==TOOL_SYM)
X		   || (otmp==uwep &&
X		   (otmp->otyp==PICK_AXE || otmp->otyp==TIN_OPENER)))
X			lets[ct++] = obj_to_let(otmp);
X	}
X	lets[ct] = 0;
X	if (!ct) You("are not using any tools.");
X	else doinv(lets);
X	return 0;
X}
X
Xint
Xdigit(c)
Xchar c;
X{
X	return(c >= '0' && c <= '9');
X}
X
X/*
X * useupf(obj)
X * uses up an object that's on the floor
X */
Xvoid
Xuseupf(obj)
Xregister struct obj *obj;
X{
X	if(obj->quan > 1)  {
X		obj->quan--;
X		obj->owt = weight(obj);
X	}  else delobj(obj);
X}
X
X/*
X * Convert from a symbol to a string for printing object classes
X *
X * Names from objects.h
X * char obj_symbols[] = {
X *	ILLOBJ_SYM, AMULET_SYM, FOOD_SYM, WEAPON_SYM, TOOL_SYM,
X *	BALL_SYM, CHAIN_SYM, ROCK_SYM, ARMOR_SYM, POTION_SYM, SCROLL_SYM,
X *	WAND_SYM, [SPBOOK_SYM], RING_SYM, GEM_SYM, 0 };
X */
X
Xstatic const char *names[] = {
X	"Illegal objects", "Amulets", "Comestibles", "Weapons",
X	"Tools", "Iron balls", "Chains", "Boulders/Statues", "Armor",
X	"Potions", "Scrolls", "Wands",
X#ifdef SPELLS
X	"Spellbooks",
X#endif
X	"Rings", "Gems"};
X
Xchar *
Xlet_to_name(let)
Xchar let;
X{
X	char *pos = index(obj_symbols, let);
X	/* arbitrary buffer size by Tom May (tom@uw-warp) */
X	static char *buf = NULL;
X
X	if (buf == NULL)
X	    buf = (char *) alloc ((unsigned)(strlen(HI)+strlen(HE)+15+1));
X
X	if (pos == NULL) pos = obj_symbols;
X	if (HI && HE)
X	    Sprintf(buf, "%s%s%s", HI, names[pos - obj_symbols], HE);
X	else
X	    Sprintf(buf, "%s", names[pos - obj_symbols]);
X	return (buf);
X}
X
Xvoid
Xreassign()
X{
X	register int i;
X	register struct obj *obj;
X
X	for(obj = invent, i = 0; obj; obj = obj->nobj, i++)
X		obj->invlet = (i < 26) ? ('a'+i) : ('A'+i-26);
X	lastinvnr = i;
X}
END_OF_FILE
if test 29364 -ne `wc -c <'src/invent.c'`; then
    echo shar: \"'src/invent.c'\" unpacked with wrong size!
fi
# end of 'src/invent.c'
fi
if test -f 'src/lev_lex.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/lev_lex.c'\"
else
echo shar: Extracting \"'src/lev_lex.c'\" \(20064 characters\)
sed "s/^X//" >'src/lev_lex.c' <<'END_OF_FILE'
X# include "stdio.h"
X# define U(x) x
X# define NLSTATE yyprevious=YYNEWLINE
X# define BEGIN yybgin = yysvec + 1 +
X# define INITIAL 0
X# define YYLERR yysvec
X# define YYSTATE (yyestate-yysvec-1)
X# define YYOPTIM 1
X# define YYLMAX 200
X# define output(c) putc(c,yyout)
X# define input() (((yytchar=yysptr>yysbuf?U(*--yysptr):getc(yyin))==10?(yylineno++,yytchar):yytchar)==EOF?0:yytchar)
X# define unput(c) {yytchar= (c);if(yytchar=='\n')yylineno--;*yysptr++=yytchar;}
X# define yymore() (yymorfg=1)
X# define ECHO fprintf(yyout, "%s",yytext)
X# define REJECT { nstr = yyreject(); goto yyfussy;}
Xint yyleng; extern char yytext[];
Xint yymorfg;
Xextern char *yysptr, yysbuf[];
Xint yytchar;
XFILE *yyin ={stdin}, *yyout ={stdout};
Xextern int yylineno;
Xstruct yysvf { 
X	struct yywork *yystoff;
X	struct yysvf *yyother;
X	int *yystops;};
Xstruct yysvf *yyestate;
Xextern struct yysvf yysvec[], *yybgin;
X/*	SCCS Id: @(#)lev_lex.c	3.0	89/07/02
X/*	Copyright (c) 1989 by Jean-Christophe Collet */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include "hack.h"
X#include "lev_comp.h"
X#include "sp_lev.h"
X
Xint line_number = 1;
X
X/* This is *** UGLY *** but I can't think a better way to do it
X * I really need a huge buffer to scan maps...
X */
X
X#undef YYLMAX
X#define YYLMAX	2048
X
X# define MAPC 2
X# define YYNEWLINE 10
Xyylex(){
Xint nstr; extern int yyprevious;
Xwhile((nstr = yylook()) >= 0)
Xyyfussy: switch(nstr){
Xcase 0:
Xif(yywrap()) return(0); break;
Xcase 1:
X	{ line_number++; }
Xbreak;
Xcase 2:
X	return MAZE_ID;
Xbreak;
Xcase 3:
X	return LEVEL_ID;
Xbreak;
Xcase 4:
Xreturn GEOMETRY_ID;
Xbreak;
Xcase 5:
X	{ BEGIN MAPC; }
Xbreak;
Xcase 6:
X{ line_number++; yymore(); }
Xbreak;
Xcase 7:
X{ BEGIN 0;
X		  yytext[yyleng-7] = 0; /* Discard \nENDMAP */
X		  yylval.map = (char *) alloc(strlen(yytext)+1);
X		  strcpy(yylval.map, yytext+1);
X		  return MAP_ID;
X		}
Xbreak;
Xcase 8:
X	return OBJECT_ID;
Xbreak;
Xcase 9:
X	return MONSTER_ID;
Xbreak;
Xcase 10:
X	return TRAP_ID;
Xbreak;
Xcase 11:
X	return DOOR_ID;
Xbreak;
Xcase 12:
Xreturn DRAWBRIDGE_ID;
Xbreak;
Xcase 13:
Xreturn MAZEWALK_ID;
Xbreak;
Xcase 14:
X	return REGION_ID;
Xbreak;
Xcase 15:
Xreturn RANDOM_OBJECTS_ID;
Xbreak;
Xcase 16:
Xreturn RANDOM_MONSTERS_ID;
Xbreak;
Xcase 17:
Xreturn RANDOM_PLACES_ID;
Xbreak;
Xcase 18:
X	return ALTAR_ID;
Xbreak;
Xcase 19:
X	return LADDER_ID;
Xbreak;
Xcase 20:
Xreturn NON_DIGGABLE_ID;
Xbreak;
Xcase 21:
X	return ROOM_ID;
Xbreak;
Xcase 22:
X	{ yylval.i=D_ISOPEN; return DOOR_STATE; }
Xbreak;
Xcase 23:
X	{ yylval.i=D_CLOSED; return DOOR_STATE; }
Xbreak;
Xcase 24:
X	{ yylval.i=D_LOCKED; return DOOR_STATE; }
Xbreak;
Xcase 25:
X	{ yylval.i=D_NODOOR; return DOOR_STATE; }
Xbreak;
Xcase 26:
X	{ yylval.i=D_BROKEN; return DOOR_STATE; }
Xbreak;
Xcase 27:
X	{ yylval.i=W_NORTH; return DIRECTION; }
Xbreak;
Xcase 28:
X	{ yylval.i=W_EAST; return DIRECTION; }
Xbreak;
Xcase 29:
X	{ yylval.i=W_SOUTH; return DIRECTION; }
Xbreak;
Xcase 30:
X	{ yylval.i=W_WEST; return DIRECTION; }
Xbreak;
Xcase 31:
X	{ yylval.i = -1; return RANDOM_TYPE; }
Xbreak;
Xcase 32:
X	return O_REGISTER;
Xbreak;
Xcase 33:
X	return M_REGISTER;
Xbreak;
Xcase 34:
X	return P_REGISTER;
Xbreak;
Xcase 35:
X	return A_REGISTER;
Xbreak;
Xcase 36:
X	{ yylval.i=1; return LEFT_OR_RIGHT; }
Xbreak;
Xcase 37:
X	{ yylval.i=3; return LEFT_OR_RIGHT; }
Xbreak;
Xcase 38:
X	{ yylval.i=2; return CENTER; }
Xbreak;
Xcase 39:
X	{ yylval.i=1; return TOP_OR_BOT; }
Xbreak;
Xcase 40:
X	{ yylval.i=3; return TOP_OR_BOT; }
Xbreak;
Xcase 41:
X	{ yylval.i=1; return LIGHT_STATE; }
Xbreak;
Xcase 42:
X	{ yylval.i=0; return LIGHT_STATE; }
Xbreak;
Xcase 43:
X	{ yylval.i=A_LAW; return ALIGNMENT; }
Xbreak;
Xcase 44:
X	{ yylval.i=A_NEUTRAL; return ALIGNMENT; }
Xbreak;
Xcase 45:
X	{ yylval.i=A_CHAOS; return ALIGNMENT; }
Xbreak;
Xcase 46:
X	{ yylval.i=1; return ALTAR_TYPE; }
Xbreak;
Xcase 47:
X	{ yylval.i=0; return ALTAR_TYPE; }
Xbreak;
Xcase 48:
X	{ yylval.i=1; return UP_OR_DOWN; }
Xbreak;
Xcase 49:
X	{ yylval.i=0; return UP_OR_DOWN; }
Xbreak;
Xcase 50:
X	{ yylval.i=atoi(yytext); return INTEGER; }
Xbreak;
Xcase 51:
X{ yytext[yyleng-1] = 0; /* Discard the trailing \" */
X		  yylval.map = (char *) alloc(strlen(yytext+1)+1);
X		  strcpy(yylval.map, yytext+1); /* Discard the first \" */
X		  return STRING; }
Xbreak;
Xcase 52:
X	{ line_number++; }
Xbreak;
Xcase 53:
X	;
Xbreak;
Xcase 54:
X	{ yylval.i = yytext[1]; return CHAR; }
Xbreak;
Xcase 55:
X	{ return yytext[0]; }
Xbreak;
Xcase -1:
Xbreak;
Xdefault:
Xfprintf(yyout,"bad switch yylook %d",nstr);
X} return(0); }
X/* end of yylex */
Xint yyvstop[] ={
X0,
X
X55,
X0,
X
X53,
X55,
X0,
X
X52,
X0,
X
X55,
X0,
X
X55,
X0,
X
X50,
X55,
X0,
X
X55,
X0,
X
X55,
X0,
X
X55,
X0,
X
X55,
X0,
X
X55,
X0,
X
X55,
X0,
X
X55,
X0,
X
X55,
X0,
X
X55,
X0,
X
X55,
X0,
X
X55,
X0,
X
X55,
X0,
X
X55,
X0,
X
X55,
X0,
X
X55,
X0,
X
X55,
X0,
X
X55,
X0,
X
X55,
X0,
X
X55,
X0,
X
X55,
X0,
X
X55,
X0,
X
X55,
X0,
X
X55,
X0,
X
X55,
X0,
X
X55,
X0,
X
X55,
X0,
X
X6,
X52,
X0,
X
X53,
X55,
X0,
X
X55,
X0,
X
X55,
X0,
X
X55,
X0,
X
X53,
X0,
X
X51,
X0,
X
X50,
X0,
X
X48,
X0,
X
X1,
X0,
X
X6,
X0,
X
X53,
X0,
X
X1,
X6,
X0,
X
X54,
X0,
X
X43,
X0,
X
X41,
X0,
X
X39,
X0,
X
X-5,
X0,
X
X11,
X0,
X
X2,
X0,
X
X21,
X0,
X
X10,
X0,
X
X49,
X0,
X
X28,
X0,
X
X36,
X0,
X
X22,
X0,
X
X30,
X0,
X
X5,
X0,
X
X18,
X0,
X
X3,
X0,
X
X35,
X0,
X
X47,
X0,
X
X45,
X0,
X
X27,
X0,
X
X34,
X0,
X
X37,
X0,
X
X29,
X0,
X
X42,
X0,
X
X19,
X0,
X
X8,
X0,
X
X14,
X0,
X
X40,
X0,
X
X26,
X0,
X
X38,
X0,
X
X23,
X0,
X
X24,
X0,
X
X25,
X0,
X
X32,
X0,
X
X31,
X0,
X
X46,
X0,
X
X-7,
X0,
X
X9,
X0,
X
X33,
X0,
X
X44,
X0,
X
X7,
X0,
X
X4,
X0,
X
X13,
X0,
X
X12,
X0,
X
X20,
X0,
X
X17,
X0,
X
X15,
X0,
X
X16,
X0,
X0};
X# define YYTYPE int
Xstruct yywork { YYTYPE verify, advance; } yycrank[] ={
X0,0,	0,0,	1,5,	0,0,	
X0,0,	0,0,	0,0,	0,0,	
X8,43,	0,0,	1,6,	1,7,	
X9,45,	0,0,	6,42,	0,0,	
X8,43,	8,43,	0,0,	0,0,	
X9,45,	9,0,	41,94,	0,0,	
X0,0,	0,0,	0,0,	0,0,	
X0,0,	0,0,	0,0,	0,0,	
X0,0,	1,6,	0,0,	1,8,	
X1,5,	6,42,	0,0,	8,43,	
X1,9,	8,44,	8,43,	9,45,	
X41,95,	9,45,	9,45,	41,95,	
X45,96,	1,10,	0,0,	0,0,	
X0,0,	0,0,	0,0,	8,43,	
X0,0,	0,0,	0,0,	9,45,	
X0,0,	0,0,	0,0,	0,0,	
X0,0,	0,0,	1,11,	14,51,	
X15,53,	1,12,	13,50,	14,52,	
X1,13,	17,56,	36,89,	49,99,	
X51,101,	1,14,	1,15,	1,16,	
X1,17,	11,47,	15,54,	1,18,	
X12,48,	1,19,	16,55,	12,49,	
X2,5,	18,57,	19,60,	40,93,	
X47,97,	18,58,	48,98,	50,100,	
X2,6,	2,7,	1,20,	1,21,	
X1,22,	1,23,	1,24,	18,59,	
X24,68,	34,86,	52,102,	53,103,	
X54,104,	1,25,	1,26,	1,27,	
X1,28,	1,29,	20,61,	1,30,	
X1,31,	1,32,	1,33,	2,6,	
X1,34,	2,8,	2,35,	23,67,	
X21,62,	26,73,	2,9,	21,63,	
X29,78,	32,83,	2,5,	55,105,	
X2,5,	2,5,	28,76,	2,10,	
X10,46,	10,46,	10,46,	10,46,	
X10,46,	10,46,	10,46,	10,46,	
X10,46,	10,46,	22,64,	27,74,	
X28,77,	22,65,	56,106,	30,79,	
X2,11,	22,66,	31,81,	2,12,	
X57,107,	27,75,	2,13,	30,80,	
X58,108,	31,82,	2,5,	2,14,	
X2,36,	2,16,	2,17,	59,109,	
X25,69,	2,18,	2,5,	2,19,	
X25,70,	33,84,	60,110,	33,85,	
X25,71,	62,113,	61,111,	2,5,	
X63,114,	64,115,	25,72,	65,116,	
X2,20,	2,21,	2,22,	2,23,	
X2,24,	61,112,	66,117,	3,37,	
X67,118,	68,119,	69,120,	2,25,	
X2,26,	2,27,	2,28,	2,29,	
X35,87,	2,30,	2,31,	2,32,	
X2,33,	70,121,	2,34,	71,122,	
X35,87,	35,88,	2,5,	2,5,	
X2,5,	3,38,	72,123,	73,124,	
X3,39,	74,125,	75,126,	76,128,	
X3,9,	77,129,	78,130,	79,131,	
X80,132,	81,133,	82,134,	83,135,	
X84,136,	86,137,	89,138,	35,87,	
X75,127,	35,87,	35,87,	93,139,	
X97,140,	98,141,	99,142,	95,94,	
X89,103,	100,143,	101,144,	102,145,	
X103,146,	104,147,	3,11,	35,87,	
X105,148,	3,12,	3,40,	106,149,	
X3,13,	107,150,	108,151,	109,152,	
X110,153,	3,14,	3,15,	3,16,	
X3,17,	95,95,	111,154,	3,18,	
X95,95,	3,19,	112,155,	113,156,	
X114,157,	115,158,	116,159,	117,160,	
X118,161,	119,162,	121,163,	123,164,	
X124,165,	4,37,	3,20,	3,21,	
X3,22,	3,23,	3,24,	125,166,	
X126,167,	127,168,	128,169,	129,170,	
X130,171,	3,25,	3,26,	3,27,	
X3,28,	3,29,	131,172,	3,30,	
X3,31,	3,32,	3,33,	4,38,	
X3,34,	132,173,	4,41,	133,174,	
X134,175,	136,176,	4,9,	137,177,	
X138,178,	139,179,	4,39,	140,180,	
X4,39,	4,39,	142,181,	143,182,	
X144,183,	145,184,	146,185,	147,186,	
X148,187,	149,188,	150,189,	151,190,	
X154,191,	155,192,	156,193,	157,194,	
X158,195,	159,196,	160,197,	164,198,	
X4,11,	165,199,	166,200,	4,12,	
X4,40,	167,201,	4,13,	168,202,	
X169,203,	171,204,	4,39,	4,14,	
X4,36,	4,16,	4,17,	172,205,	
X173,206,	4,18,	4,39,	4,19,	
X174,207,	175,208,	176,209,	179,210,	
X181,211,	182,212,	183,213,	4,39,	
X185,214,	186,215,	38,42,	38,90,	
X4,20,	4,21,	4,22,	4,23,	
X4,24,	187,216,	188,217,	189,218,	
X190,219,	193,220,	194,221,	4,25,	
X4,26,	4,27,	4,28,	4,29,	
X195,222,	4,30,	4,31,	4,32,	
X4,33,	38,91,	4,34,	39,90,	
X38,92,	197,223,	4,39,	4,39,	
X4,39,	198,224,	199,225,	200,226,	
X38,92,	201,227,	38,92,	38,92,	
X203,228,	205,229,	207,230,	210,231,	
X211,232,	212,233,	214,234,	215,235,	
X216,236,	39,92,	218,237,	225,238,	
X39,92,	226,239,	231,240,	232,241,	
X233,242,	234,243,	236,244,	241,248,	
X39,92,	244,249,	39,92,	39,92,	
X237,245,	245,250,	237,246,	237,247,	
X38,92,	246,251,	247,252,	248,253,	
X249,254,	250,255,	251,256,	252,257,	
X38,92,	254,258,	255,259,	256,260,	
X257,261,	258,262,	259,263,	260,264,	
X261,265,	38,92,	263,266,	264,267,	
X265,268,	266,269,	267,270,	269,271,	
X39,92,	0,0,	0,0,	0,0,	
X0,0,	0,0,	0,0,	0,0,	
X39,92,	0,0,	0,0,	0,0,	
X0,0,	0,0,	0,0,	0,0,	
X0,0,	39,92,	0,0,	0,0,	
X0,0,	0,0,	0,0,	0,0,	
X38,92,	38,92,	38,92,	0,0,	
X0,0,	0,0,	0,0,	0,0,	
X0,0,	0,0,	0,0,	0,0,	
X0,0,	0,0,	0,0,	0,0,	
X0,0,	0,0,	0,0,	0,0,	
X0,0,	0,0,	0,0,	0,0,	
X39,92,	39,92,	39,92,	0,0,	
X0,0};
Xstruct yysvf yysvec[] ={
X0,	0,	0,
Xyycrank+-1,	0,		0,	
Xyycrank+-87,	0,		0,	
Xyycrank+-181,	yysvec+1,	0,	
Xyycrank+-267,	yysvec+2,	0,	
Xyycrank+0,	0,		yyvstop+1,
Xyycrank+5,	0,		yyvstop+3,
Xyycrank+0,	0,		yyvstop+6,
Xyycrank+-7,	0,		yyvstop+8,
Xyycrank+-11,	0,		yyvstop+10,
Xyycrank+88,	0,		yyvstop+12,
Xyycrank+5,	0,		yyvstop+15,
Xyycrank+5,	0,		yyvstop+17,
Xyycrank+1,	0,		yyvstop+19,
Xyycrank+2,	0,		yyvstop+21,
Xyycrank+3,	0,		yyvstop+23,
Xyycrank+7,	0,		yyvstop+25,
Xyycrank+7,	0,		yyvstop+27,
Xyycrank+24,	0,		yyvstop+29,
Xyycrank+8,	0,		yyvstop+31,
Xyycrank+6,	0,		yyvstop+33,
Xyycrank+13,	0,		yyvstop+35,
Xyycrank+45,	0,		yyvstop+37,
Xyycrank+12,	0,		yyvstop+39,
Xyycrank+7,	0,		yyvstop+41,
Xyycrank+71,	0,		yyvstop+43,
Xyycrank+14,	0,		yyvstop+45,
Xyycrank+46,	0,		yyvstop+47,
Xyycrank+36,	0,		yyvstop+49,
Xyycrank+20,	0,		yyvstop+51,
Xyycrank+54,	0,		yyvstop+53,
Xyycrank+50,	0,		yyvstop+55,
Xyycrank+18,	0,		yyvstop+57,
Xyycrank+63,	0,		yyvstop+59,
Xyycrank+4,	0,		yyvstop+61,
Xyycrank+-199,	0,		yyvstop+63,
Xyycrank+9,	yysvec+15,	yyvstop+65,
Xyycrank+0,	0,		yyvstop+67,
Xyycrank+353,	0,		yyvstop+70,
Xyycrank+377,	0,		yyvstop+73,
Xyycrank+13,	0,		yyvstop+75,
Xyycrank+-12,	yysvec+35,	yyvstop+77,
Xyycrank+0,	yysvec+6,	yyvstop+79,
Xyycrank+0,	yysvec+8,	0,	
Xyycrank+0,	0,		yyvstop+81,
Xyycrank+9,	0,		0,	
Xyycrank+0,	yysvec+10,	yyvstop+83,
Xyycrank+8,	0,		0,	
Xyycrank+15,	0,		0,	
Xyycrank+10,	0,		0,	
Xyycrank+16,	0,		0,	
Xyycrank+8,	0,		0,	
Xyycrank+20,	0,		0,	
Xyycrank+17,	0,		0,	
Xyycrank+30,	0,		0,	
Xyycrank+53,	0,		0,	
Xyycrank+76,	0,		0,	
Xyycrank+78,	0,		0,	
Xyycrank+89,	0,		0,	
Xyycrank+88,	0,		0,	
Xyycrank+109,	0,		0,	
Xyycrank+73,	0,		0,	
Xyycrank+61,	0,		0,	
Xyycrank+69,	0,		0,	
Xyycrank+71,	0,		0,	
Xyycrank+86,	0,		0,	
Xyycrank+79,	0,		0,	
Xyycrank+73,	0,		0,	
Xyycrank+78,	0,		0,	
Xyycrank+75,	0,		0,	
Xyycrank+103,	0,		0,	
Xyycrank+91,	0,		0,	
Xyycrank+115,	0,		0,	
Xyycrank+105,	0,		0,	
Xyycrank+100,	0,		0,	
Xyycrank+118,	0,		0,	
Xyycrank+113,	0,		0,	
Xyycrank+120,	0,		0,	
Xyycrank+125,	0,		0,	
Xyycrank+113,	0,		0,	
Xyycrank+121,	0,		0,	
Xyycrank+111,	0,		0,	
Xyycrank+109,	0,		0,	
Xyycrank+115,	0,		0,	
Xyycrank+120,	0,		0,	
Xyycrank+0,	0,		yyvstop+85,
Xyycrank+114,	0,		0,	
Xyycrank+0,	yysvec+35,	0,	
Xyycrank+0,	0,		yyvstop+87,
Xyycrank+150,	0,		0,	
Xyycrank+0,	0,		yyvstop+89,
Xyycrank+0,	yysvec+38,	yyvstop+91,
Xyycrank+0,	yysvec+39,	0,	
Xyycrank+167,	0,		0,	
Xyycrank+0,	0,		yyvstop+93,
Xyycrank+-229,	yysvec+35,	0,	
Xyycrank+0,	0,		yyvstop+96,
Xyycrank+171,	0,		0,	
Xyycrank+155,	0,		0,	
Xyycrank+151,	0,		0,	
Xyycrank+164,	0,		0,	
Xyycrank+174,	0,		0,	
Xyycrank+174,	0,		0,	
Xyycrank+175,	0,		0,	
Xyycrank+162,	0,		0,	
Xyycrank+153,	0,		0,	
Xyycrank+182,	0,		0,	
Xyycrank+185,	0,		0,	
Xyycrank+181,	0,		0,	
Xyycrank+178,	0,		0,	
Xyycrank+176,	0,		0,	
Xyycrank+159,	0,		0,	
Xyycrank+169,	0,		0,	
Xyycrank+151,	0,		0,	
Xyycrank+161,	0,		0,	
Xyycrank+153,	0,		0,	
Xyycrank+159,	0,		0,	
Xyycrank+156,	0,		0,	
Xyycrank+162,	0,		0,	
Xyycrank+157,	0,		0,	
Xyycrank+0,	0,		yyvstop+98,
Xyycrank+158,	0,		0,	
Xyycrank+0,	0,		yyvstop+100,
Xyycrank+168,	0,		0,	
Xyycrank+161,	0,		0,	
Xyycrank+167,	0,		0,	
Xyycrank+173,	0,		0,	
Xyycrank+169,	0,		0,	
Xyycrank+185,	0,		0,	
Xyycrank+177,	0,		0,	
Xyycrank+189,	0,		0,	
Xyycrank+194,	0,		0,	
Xyycrank+197,	0,		0,	
Xyycrank+198,	0,		0,	
Xyycrank+188,	0,		0,	
Xyycrank+0,	0,		yyvstop+102,
Xyycrank+200,	0,		0,	
Xyycrank+191,	0,		0,	
Xyycrank+298,	0,		yyvstop+104,
Xyycrank+232,	0,		0,	
Xyycrank+229,	0,		0,	
Xyycrank+0,	0,		yyvstop+106,
Xyycrank+248,	0,		0,	
Xyycrank+246,	0,		0,	
Xyycrank+247,	0,		0,	
Xyycrank+241,	0,		0,	
Xyycrank+231,	0,		yyvstop+108,
Xyycrank+235,	0,		0,	
Xyycrank+252,	0,		0,	
Xyycrank+254,	0,		0,	
Xyycrank+243,	0,		0,	
Xyycrank+244,	0,		0,	
Xyycrank+0,	0,		yyvstop+110,
Xyycrank+0,	0,		yyvstop+112,
Xyycrank+214,	0,		0,	
Xyycrank+211,	0,		0,	
Xyycrank+215,	0,		0,	
Xyycrank+226,	0,		0,	
Xyycrank+227,	0,		0,	
Xyycrank+214,	0,		0,	
Xyycrank+229,	0,		0,	
Xyycrank+0,	0,		yyvstop+114,
Xyycrank+0,	0,		yyvstop+116,
Xyycrank+0,	0,		yyvstop+118,
Xyycrank+230,	0,		0,	
Xyycrank+217,	0,		0,	
Xyycrank+220,	0,		0,	
Xyycrank+226,	0,		0,	
Xyycrank+235,	0,		0,	
Xyycrank+241,	0,		0,	
Xyycrank+0,	0,		yyvstop+120,
Xyycrank+240,	0,		0,	
Xyycrank+236,	0,		0,	
Xyycrank+232,	0,		0,	
Xyycrank+242,	0,		0,	
Xyycrank+249,	0,		0,	
Xyycrank+238,	0,		0,	
Xyycrank+0,	0,		yyvstop+122,
Xyycrank+0,	0,		yyvstop+124,
Xyycrank+290,	0,		0,	
Xyycrank+0,	0,		yyvstop+126,
Xyycrank+274,	0,		0,	
Xyycrank+273,	0,		0,	
Xyycrank+276,	0,		0,	
Xyycrank+0,	0,		yyvstop+128,
Xyycrank+295,	0,		0,	
Xyycrank+292,	0,		0,	
Xyycrank+296,	0,		0,	
Xyycrank+286,	0,		0,	
Xyycrank+294,	0,		0,	
Xyycrank+294,	0,		0,	
Xyycrank+0,	0,		yyvstop+130,
Xyycrank+0,	0,		yyvstop+132,
Xyycrank+264,	0,		0,	
Xyycrank+264,	0,		0,	
Xyycrank+266,	0,		0,	
Xyycrank+0,	0,		yyvstop+134,
Xyycrank+289,	0,		0,	
Xyycrank+293,	0,		0,	
Xyycrank+293,	0,		0,	
Xyycrank+298,	0,		0,	
Xyycrank+283,	0,		0,	
Xyycrank+0,	0,		yyvstop+136,
Xyycrank+284,	0,		0,	
Xyycrank+0,	0,		yyvstop+138,
Xyycrank+292,	0,		0,	
Xyycrank+0,	0,		yyvstop+140,
Xyycrank+301,	0,		0,	
Xyycrank+0,	0,		yyvstop+142,
Xyycrank+0,	0,		yyvstop+144,
Xyycrank+323,	0,		0,	
Xyycrank+331,	0,		0,	
Xyycrank+323,	0,		0,	
Xyycrank+0,	0,		yyvstop+146,
Xyycrank+330,	0,		0,	
Xyycrank+325,	0,		0,	
Xyycrank+337,	0,		0,	
Xyycrank+0,	0,		yyvstop+148,
Xyycrank+315,	0,		0,	
Xyycrank+0,	0,		yyvstop+150,
Xyycrank+0,	0,		yyvstop+152,
Xyycrank+0,	0,		yyvstop+154,
Xyycrank+0,	0,		yyvstop+156,
Xyycrank+0,	0,		yyvstop+158,
Xyycrank+0,	0,		yyvstop+160,
Xyycrank+297,	0,		0,	
Xyycrank+305,	0,		0,	
Xyycrank+0,	0,		yyvstop+162,
Xyycrank+0,	0,		yyvstop+164,
Xyycrank+0,	0,		yyvstop+166,
Xyycrank+0,	0,		yyvstop+168,
Xyycrank+404,	0,		yyvstop+170,
Xyycrank+347,	0,		0,	
Xyycrank+327,	0,		0,	
Xyycrank+342,	0,		0,	
Xyycrank+0,	0,		yyvstop+172,
Xyycrank+347,	0,		0,	
Xyycrank+347,	0,		0,	
Xyycrank+0,	0,		yyvstop+174,
Xyycrank+0,	0,		yyvstop+176,
Xyycrank+0,	0,		yyvstop+178,
Xyycrank+348,	0,		0,	
Xyycrank+0,	0,		yyvstop+180,
Xyycrank+0,	0,		yyvstop+182,
Xyycrank+356,	0,		0,	
Xyycrank+346,	0,		0,	
Xyycrank+363,	0,		0,	
Xyycrank+354,	0,		0,	
Xyycrank+362,	0,		0,	
Xyycrank+366,	0,		0,	
Xyycrank+355,	0,		0,	
Xyycrank+360,	0,		0,	
Xyycrank+370,	0,		0,	
Xyycrank+0,	0,		yyvstop+184,
Xyycrank+361,	0,		0,	
Xyycrank+355,	0,		0,	
Xyycrank+370,	0,		0,	
Xyycrank+373,	0,		0,	
Xyycrank+372,	0,		0,	
Xyycrank+358,	0,		0,	
Xyycrank+376,	0,		0,	
Xyycrank+375,	0,		0,	
Xyycrank+0,	0,		yyvstop+186,
Xyycrank+377,	0,		0,	
Xyycrank+363,	0,		0,	
Xyycrank+365,	0,		0,	
Xyycrank+367,	0,		0,	
Xyycrank+367,	0,		0,	
Xyycrank+0,	0,		yyvstop+188,
Xyycrank+368,	0,		0,	
Xyycrank+0,	0,		yyvstop+190,
Xyycrank+0,	0,		yyvstop+192,
X0,	0,	0};
Xstruct yywork *yytop = yycrank+502;
Xstruct yysvf *yybgin = yysvec+1;
Xchar yymatch[] ={
X00  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
X01  ,011 ,012 ,01  ,01  ,01  ,01  ,01  ,
X01  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
X01  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
X040 ,01  ,'"' ,'#' ,01  ,01  ,01  ,01  ,
X01  ,01  ,01  ,'#' ,01  ,'#' ,'#' ,01  ,
X'0' ,'0' ,'0' ,'0' ,'0' ,'0' ,'0' ,'0' ,
X'0' ,'0' ,01  ,01  ,01  ,01  ,01  ,01  ,
X01  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
X01  ,01  ,01  ,'#' ,01  ,01  ,01  ,01  ,
X01  ,01  ,01  ,'#' ,01  ,01  ,01  ,01  ,
X01  ,01  ,01  ,01  ,'#' ,01  ,01  ,01  ,
X01  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
X01  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
X01  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
X01  ,01  ,01  ,'#' ,'#' ,'#' ,01  ,01  ,
X0};
Xchar yyextra[] ={
X0,0,0,0,0,1,0,1,
X0,0,0,0,0,0,0,0,
X0,0,0,0,0,0,0,0,
X0,0,0,0,0,0,0,0,
X0,0,0,0,0,0,0,0,
X0,0,0,0,0,0,0,0,
X0,0,0,0,0,0,0,0,
X0};
X/*	ncform	4.1	83/08/11	*/
X
Xint yylineno =1;
X# define YYU(x) x
X# define NLSTATE yyprevious=YYNEWLINE
Xchar yytext[YYLMAX];
Xstruct yysvf *yylstate [YYLMAX], **yylsp, **yyolsp;
Xchar yysbuf[YYLMAX];
Xchar *yysptr = yysbuf;
Xint *yyfnd;
Xextern struct yysvf *yyestate;
Xint yyprevious = YYNEWLINE;
Xyylook(){
X	register struct yysvf *yystate, **lsp;
X	register struct yywork *yyt;
X	struct yysvf *yyz;
X	int yych;
X	struct yywork *yyr;
X# ifdef LEXDEBUG
X	int debug;
X# endif
X	char *yylastch;
X	/* start off machines */
X# ifdef LEXDEBUG
X	debug = 0;
X# endif
X	if (!yymorfg)
X		yylastch = yytext;
X	else {
X		yymorfg=0;
X		yylastch = yytext+yyleng;
X		}
X	for(;;){
X		lsp = yylstate;
X		yyestate = yystate = yybgin;
X		if (yyprevious==YYNEWLINE) yystate++;
X		for (;;){
X# ifdef LEXDEBUG
X			if(debug)fprintf(yyout,"state %d\n",yystate-yysvec-1);
X# endif
X			yyt = yystate->yystoff;
X			if(yyt == yycrank){		/* may not be any transitions */
X				yyz = yystate->yyother;
X				if(yyz == 0)break;
X				if(yyz->yystoff == yycrank)break;
X				}
X			*yylastch++ = yych = input();
X		tryagain:
X# ifdef LEXDEBUG
X			if(debug){
X				fprintf(yyout,"char ");
X				allprint(yych);
X				putchar('\n');
X				}
X# endif
X			yyr = yyt;
X			if ( (int)yyt > (int)yycrank){
X				yyt = yyr + yych;
X				if (yyt <= yytop && yyt->verify+yysvec == yystate){
X					if(yyt->advance+yysvec == YYLERR)	/* error transitions */
X						{unput(*--yylastch);break;}
X					*lsp++ = yystate = yyt->advance+yysvec;
X					goto contin;
X					}
X				}
X# ifdef YYOPTIM
X			else if((int)yyt < (int)yycrank) {		/* r < yycrank */
X				yyt = yyr = yycrank+(yycrank-yyt);
X# ifdef LEXDEBUG
X				if(debug)fprintf(yyout,"compressed state\n");
X# endif
X				yyt = yyt + yych;
X				if(yyt <= yytop && yyt->verify+yysvec == yystate){
X					if(yyt->advance+yysvec == YYLERR)	/* error transitions */
X						{unput(*--yylastch);break;}
X					*lsp++ = yystate = yyt->advance+yysvec;
X					goto contin;
X					}
X				yyt = yyr + YYU(yymatch[yych]);
X# ifdef LEXDEBUG
X				if(debug){
X					fprintf(yyout,"try fall back character ");
X					allprint(YYU(yymatch[yych]));
X					putchar('\n');
X					}
X# endif
X				if(yyt <= yytop && yyt->verify+yysvec == yystate){
X					if(yyt->advance+yysvec == YYLERR)	/* error transition */
X						{unput(*--yylastch);break;}
X					*lsp++ = yystate = yyt->advance+yysvec;
X					goto contin;
X					}
X				}
X			if ((yystate = yystate->yyother) && (yyt= yystate->yystoff) != yycrank){
X# ifdef LEXDEBUG
X				if(debug)fprintf(yyout,"fall back to state %d\n",yystate-yysvec-1);
X# endif
X				goto tryagain;
X				}
X# endif
X			else
X				{unput(*--yylastch);break;}
X		contin:
X# ifdef LEXDEBUG
X			if(debug){
X				fprintf(yyout,"state %d char ",yystate-yysvec-1);
X				allprint(yych);
X				putchar('\n');
X				}
X# endif
X			;
X			}
X# ifdef LEXDEBUG
X		if(debug){
X			fprintf(yyout,"stopped at %d with ",*(lsp-1)-yysvec-1);
X			allprint(yych);
X			putchar('\n');
X			}
X# endif
X		while (lsp-- > yylstate){
X			*yylastch-- = 0;
X			if (*lsp != 0 && (yyfnd= (*lsp)->yystops) && *yyfnd > 0){
X				yyolsp = lsp;
X				if(yyextra[*yyfnd]){		/* must backup */
X					while(yyback((*lsp)->yystops,-*yyfnd) != 1 && lsp > yylstate){
X						lsp--;
X						unput(*yylastch--);
X						}
X					}
X				yyprevious = YYU(*yylastch);
X				yylsp = lsp;
X				yyleng = yylastch-yytext+1;
X				yytext[yyleng] = 0;
X# ifdef LEXDEBUG
X				if(debug){
X					fprintf(yyout,"\nmatch ");
X					sprint(yytext);
X					fprintf(yyout," action %d\n",*yyfnd);
X					}
X# endif
X				return(*yyfnd++);
X				}
X			unput(*yylastch);
X			}
X		if (yytext[0] == 0  /* && feof(yyin) */)
X			{
X			yysptr=yysbuf;
X			return(0);
X			}
X		yyprevious = yytext[0] = input();
X		if (yyprevious>0)
X			output(yyprevious);
X		yylastch=yytext;
X# ifdef LEXDEBUG
X		if(debug)putchar('\n');
X# endif
X		}
X	}
Xyyback(p, m)
X	int *p;
X{
Xif (p==0) return(0);
Xwhile (*p)
X	{
X	if (*p++ == m)
X		return(1);
X	}
Xreturn(0);
X}
X	/* the following are only used in the lex library */
Xyyinput(){
X	return(input());
X	}
Xyyoutput(c)
X  int c; {
X	output(c);
X	}
Xyyunput(c)
X   int c; {
X	unput(c);
X	}
END_OF_FILE
if test 20064 -ne `wc -c <'src/lev_lex.c'`; then
    echo shar: \"'src/lev_lex.c'\" unpacked with wrong size!
fi
# end of 'src/lev_lex.c'
fi
echo shar: End of archive 15 \(of 38\).
cp /dev/null ark15isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 38 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
