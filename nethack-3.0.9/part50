Path: utzoo!utgpu!news-server.csri.toronto.edu!cs.utexas.edu!mailrus!cornell!uw-beaver!zephyr.ens.tek.com!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v10i095:  nethack3p9 -  display oriented dungeons & dragons (Ver. 3.0i), Part50/56
Message-ID: <5955@tekred.CNA.TEK.COM>
Date: 13 Jul 90 19:44:00 GMT
Sender: news@tekred.CNA.TEK.COM
Lines: 1921
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 10, Issue 95
Archive-name: nethack3p9/Part50
Supersedes: NetHack3: Volume 7, Issue 56-93



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 50 (of 56)."
# Contents:  amiga/amiunix.c auxil/castle.des include/system.h
#   others/atarifnt.uue others/ovlmgr.uu src/rumors.c src/timeout.c
#   src/worm.c
# Wrapped by billr@saab on Wed Jul 11 17:12:11 1990
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'amiga/amiunix.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'amiga/amiunix.c'\"
else
echo shar: Extracting \"'amiga/amiunix.c'\" \(3500 characters\)
sed "s/^X//" >'amiga/amiunix.c' <<'END_OF_FILE'
X/*    SCCS Id: @(#)amiunix.c    3.0    89/05/02
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X/* This file collects some Unix dependencies; pager.c contains some more */
X
X/*
X * The time is used for:
X *    - seed for rand()
X *    - year on tombstone and yymmdd in record file
X *    - phase of the moon (various monsters react to NEW_MOON or FULL_MOON)
X *    - night and midnight (the undead are dangerous at midnight)
X *    - determination of what files are "very old"
X */
X
X/* block some unused #defines to avoid overloading some cpp's */
X#define MONDATA_H
X#include "hack.h"   /* mainly for index() which depends on BSD */
X
X#define     NOSTAT
X
X#ifndef NOSTAT
X#include    <stat.h>
Xstatic struct stat buf, hbuf;
X#endif
X
Xextern time_t time();
X
Xstatic struct tm *NDECL(getlt);
X
Xvoid
Xsetrandom()
X{
X	(void) Srand((unsigned int) time ((time_t *) 0));
X}
X
Xstatic struct tm *
Xgetlt()
X{
X	time_t date;
X	struct tm *localtime();
X
X	(void) time((long *)(&date));
X	return(localtime(&date));
X}
X
Xint
Xgetyear()
X{
X	return(1900 + getlt()->tm_year);
X}
X
Xchar *
Xgetdate()
X{
X#ifdef LINT	/* static char datestr[7]; */
X	char datestr[7];
X#else
X	static char datestr[7];
X#endif
X	register struct tm *lt = getlt();
X
X	Sprintf(datestr, "%2d%2d%2d",
X		lt->tm_year, lt->tm_mon + 1, lt->tm_mday);
X	if(datestr[2] == ' ') datestr[2] = '0';
X	if(datestr[4] == ' ') datestr[4] = '0';
X	return(datestr);
X}
X
Xint
Xphase_of_the_moon()                     /* 0-7, with 0: new, 4: full */
X{					/* moon period: 29.5306 days */
X					/* year: 365.2422 days */
X	register struct tm *lt = getlt();
X	register int epact, diy, golden;
X
X	diy = lt->tm_yday;
X	golden = (lt->tm_year % 19) + 1;
X	epact = (11 * golden + 18) % 30;
X	if ((epact == 25 && golden > 11) || epact == 24)
X		epact++;
X
X	return( (((((diy + epact) * 6) + 11) % 177) / 22) & 7 );
X}
X
Xint
Xnight()
X{
X	register int hour = getlt()->tm_hour;
X
X	return(hour < 6 || hour > 21);
X}
X
Xint
Xmidnight()
X{
X	return(getlt()->tm_hour == 0);
X}
X
Xvoid
Xgethdate(name)
Xchar *name;
X{
X#ifndef NOSTAT
X/* old version - for people short of space */
X/*
X/* register char *np;
X/*	if(stat(name, &hbuf))
X/*		error("Cannot get status of %s.",
X/*			(np = rindex(name, '/')) ? np+1 : name);
X/*
X/* version using PATH from: seismo!gregc@ucsf-cgl.ARPA (Greg Couch) */
X
X/*
X * The problem with   #include	<sys/param.h> is that this include file
X * does not exist on all systems, and moreover, that it sometimes includes
X * <sys/types.h> again, so that the compiler sees these typedefs twice.
X */
X#define 	MAXPATHLEN	80
X
Xextern char PATH[];	/* In amigaDOS.c */
X
Xregister char *np, *path;
Xchar filename[MAXPATHLEN+1];
X
X    if (index(name, '/') != NULL || (path = PATH) == NULL)
X	path = "";
X
X    for (;;) {
X	if ((np = index(path, ':')) == NULL)
X	    np = path + strlen(path);       /* point to end str */
X	if (np - path <= 1)                     /* %% */
X	    (void) strcpy(filename, name);
X	else {
X	    (void) strncpy(filename, path, np - path);
X	    filename[np - path] = '/';
X	    (void) strcpy(filename + (np - path) + 1, name);
X	}
X	if (stat(filename, &hbuf) == 0)
X	    return;
X	if (*np == '\0')
X	path = "";
X	path = np + 1;
X    }
X    error("Cannot get status of %s.", (np = rindex(name, '/')) ? np+1 : name);
X#endif
X}
X
Xint
Xuptodate(fd)
X{
X    return(1);
X}
X
Xvoid
Xregularize(s)    /* normalize file name - we don't like :'s or /'s */
Xregister char *s;
X{
X    register char *lp;
X
X    while((lp = index(s, ':')) || (lp = index(s, '/')))
X	*lp = '_';
X}
END_OF_FILE
if test 3500 -ne `wc -c <'amiga/amiunix.c'`; then
    echo shar: \"'amiga/amiunix.c'\" unpacked with wrong size!
fi
# end of 'amiga/amiunix.c'
fi
if test -f 'auxil/castle.des' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'auxil/castle.des'\"
else
echo shar: Extracting \"'auxil/castle.des'\" \(7219 characters\)
sed "s/^X//" >'auxil/castle.des' <<'END_OF_FILE'
X#	SCCS Id: @(#)castle.des	3.0	89/07/02
X#	Copyright (c) 1989 by Jean-Christophe Collet
X# NetHack may be freely redistributed.  See license for details.
X#
X# This is the stronghold level :
X# there are several ways to enter it :
X#	- opening the drawbridge (wand of opening, knock spell, playing
X#	  the appropriate tune)
X#
X#	- enter via the back entry (this suppose a ring of levitation, boots
X#	  of water walking, etc.)
X#
X# Note : If you don't play the right tune, you get indications like in the
X#	 MasterMind game...
X#
X# To motivate the player : there are 4 storerooms (armors, weapons, food and
X# gems) and a wand of wishing in one of the 4 towers...
X
XMAZE:"castle"
XGEOMETRY:center,center
XMAP
X}}}}}}}}}                                             }}}}}}}}}
X}-------}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}-------}
X}|     |-----------------------------------------------|     |}
X}|     +                                               +     |}
X}-------------------------------+-----------------------------}
X}}}}}}|        |          +           |       S S       |}}}}}}
X     }|        |          |           |       | |       |}     
X     }|        ------------           ---------S---------}     
X     }|   {    +          +         \ S                 +      
X     }|        ------------           ---------S---------}     
X     }|        |          |           |       | |       |}     
X}}}}}}|        |          +           |       S S       |}}}}}}
X}-------------------------------+-----------------------------}
X}|     +                                               +     |}
X}|     |-----------------------------------------------|     |}
X}-------}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}-------}
X}}}}}}}}}                                             }}}}}}}}}
XENDMAP
X# Random registers initialisation
XRANDOM_OBJECTS:'[',')','*','%'
XRANDOM_PLACES:(04,02),(58,02),(04,14),(58,14)
XRANDOM_MONSTERS:'L','N','E','H','M','O','R','T','X','Z'
X# Doors
XDOOR:closed,(07,03)
XDOOR:closed,(55,03)
XDOOR:locked,(32,04)
XDOOR:locked,(26,05)
XDOOR:locked,(46,05)
XDOOR:locked,(48,05)
XDOOR:locked,(47,07)
XDOOR:closed,(15,08)
XDOOR:closed,(26,08)
XDOOR:locked,(38,08)
XDOOR:locked,(56,08)
XDOOR:locked,(47,09)
XDOOR:locked,(26,11)
XDOOR:locked,(46,11)
XDOOR:locked,(48,11)
XDOOR:locked,(32,12)
XDOOR:closed,(07,13)
XDOOR:closed,(55,13)
X# The drawbridge
XDRAWBRIDGE:(05,08),east,closed
X# Storeroom number 1
XOBJECT:object[0],random,(39,05)
XOBJECT:object[0],random,(40,05)
XOBJECT:object[0],random,(41,05)
XOBJECT:object[0],random,(42,05)
XOBJECT:object[0],random,(43,05)
XOBJECT:object[0],random,(44,05)
XOBJECT:object[0],random,(45,05)
XOBJECT:object[0],random,(39,06)
XOBJECT:object[0],random,(40,06)
XOBJECT:object[0],random,(41,06)
XOBJECT:object[0],random,(42,06)
XOBJECT:object[0],random,(43,06)
XOBJECT:object[0],random,(44,06)
XOBJECT:object[0],random,(45,06)
X# Storeroom number 2
XOBJECT:object[1],random,(49,05)
XOBJECT:object[1],random,(50,05)
XOBJECT:object[1],random,(51,05)
XOBJECT:object[1],random,(52,05)
XOBJECT:object[1],random,(53,05)
XOBJECT:object[1],random,(54,05)
XOBJECT:object[1],random,(55,05)
XOBJECT:object[1],random,(49,06)
XOBJECT:object[1],random,(50,06)
XOBJECT:object[1],random,(51,06)
XOBJECT:object[1],random,(52,06)
XOBJECT:object[1],random,(53,06)
XOBJECT:object[1],random,(54,06)
XOBJECT:object[1],random,(55,06)
X# Storeroom number 3
XOBJECT:object[2],random,(39,10)
XOBJECT:object[2],random,(40,10)
XOBJECT:object[2],random,(41,10)
XOBJECT:object[2],random,(42,10)
XOBJECT:object[2],random,(43,10)
XOBJECT:object[2],random,(44,10)
XOBJECT:object[2],random,(45,10)
XOBJECT:object[2],random,(39,11)
XOBJECT:object[2],random,(40,11)
XOBJECT:object[2],random,(41,11)
XOBJECT:object[2],random,(42,11)
XOBJECT:object[2],random,(43,11)
XOBJECT:object[2],random,(44,11)
XOBJECT:object[2],random,(45,11)
X# Storeroom number 4
XOBJECT:object[3],random,(49,10)
XOBJECT:object[3],random,(50,10)
XOBJECT:object[3],random,(51,10)
XOBJECT:object[3],random,(52,10)
XOBJECT:object[3],random,(53,10)
XOBJECT:object[3],random,(54,10)
XOBJECT:object[3],random,(55,10)
XOBJECT:object[3],random,(49,11)
XOBJECT:object[3],random,(50,11)
XOBJECT:object[3],random,(51,11)
XOBJECT:object[3],random,(52,11)
XOBJECT:object[3],random,(53,11)
XOBJECT:object[3],random,(54,11)
XOBJECT:object[3],random,(55,11)
X# THE WAND OF WISHING in 1 of the 4 towers
XOBJECT:'/',"wishing",place[0]
X# The treasure of the lord
XOBJECT:'(',"chest",(37,08)
X# Traps
XTRAP:"trapdoor",(40,08)
XTRAP:"trapdoor",(44,08)
XTRAP:"trapdoor",(48,08)
XTRAP:"trapdoor",(52,08)
XTRAP:"trapdoor",(55,08)
X# Soldiers guarding the entry hall
XMONSTER:'@',"soldier",(08,06)
XMONSTER:'@',"soldier",(09,05)
XMONSTER:'@',"soldier",(11,05)
XMONSTER:'@',"soldier",(12,06)
XMONSTER:'@',"soldier",(08,10)
XMONSTER:'@',"soldier",(09,11)
XMONSTER:'@',"soldier",(11,11)
XMONSTER:'@',"soldier",(12,10)
XMONSTER:'@',"lieutenant",(09,08)
X# Soldiers guarding the towers
XMONSTER:'@',"soldier",(03,02)
XMONSTER:'@',"soldier",(05,02)
XMONSTER:'@',"soldier",(57,02)
XMONSTER:'@',"soldier",(59,02)
XMONSTER:'@',"soldier",(03,14)
XMONSTER:'@',"soldier",(05,14)
XMONSTER:'@',"soldier",(57,14)
XMONSTER:'@',"soldier",(59,14)
X# The four dragons that are guarding the storerooms
XMONSTER:'D',random,(47,05)
XMONSTER:'D',random,(47,06)
XMONSTER:'D',random,(47,10)
XMONSTER:'D',random,(47,11)
X# Eels in the moat
XMONSTER:';',"giant eel",(05,07)
XMONSTER:';',"giant eel",(05,09)
XMONSTER:';',"giant eel",(57,07)
XMONSTER:';',"giant eel",(57,09)
X# The throne room and the court monsters
XMONSTER:monster[0],random,(27,05)
XMONSTER:monster[1],random,(30,05)
XMONSTER:monster[2],random,(33,05)
XMONSTER:monster[3],random,(36,05)
XMONSTER:monster[4],random,(28,06)
XMONSTER:monster[5],random,(31,06)
XMONSTER:monster[6],random,(34,06)
XMONSTER:monster[7],random,(37,06)
XMONSTER:monster[8],random,(27,07)
XMONSTER:monster[9],random,(30,07)
XMONSTER:monster[0],random,(33,07)
XMONSTER:monster[1],random,(36,07)
XMONSTER:monster[2],random,(28,08)
XMONSTER:monster[3],random,(31,08)
XMONSTER:monster[4],random,(34,08)
XMONSTER:monster[5],random,(27,09)
XMONSTER:monster[6],random,(30,09)
XMONSTER:monster[7],random,(33,09)
XMONSTER:monster[8],random,(36,09)
XMONSTER:monster[9],random,(28,10)
XMONSTER:monster[0],random,(31,10)
XMONSTER:monster[1],random,(34,10)
XMONSTER:monster[2],random,(37,10)
XMONSTER:monster[3],random,(27,11)
XMONSTER:monster[4],random,(30,11)
XMONSTER:monster[5],random,(33,11)
XMONSTER:monster[6],random,(36,11)
X# MazeWalks
XMAZEWALK:(00,10),west
XMAZEWALK:(62,06),east
X# Non diggable walls
XNON_DIGGABLE:(00,00,62,16)
X# Subrooms:
X#   Throne room
XREGION:(27,05,37,11),lit,"throne"
X#   Antechamber
XREGION:(07,05,14,11),lit,"ordinary"
X#   Storerooms
XREGION:(39,05,45,06),lit,"ordinary"
XREGION:(39,10,45,11),lit,"ordinary"
XREGION:(49,05,55,06),lit,"ordinary"
XREGION:(49,10,55,11),lit,"ordinary"
X#   Corners
XREGION:(02,02,06,03),lit,"ordinary"
XREGION:(56,02,60,03),lit,"ordinary"
XREGION:(02,13,06,14),lit,"ordinary"
XREGION:(56,13,60,14),lit,"ordinary"
X#   Barracks
XREGION:(16,05,25,06),lit,"ordinary"
XREGION:(16,10,25,11),lit,"ordinary"
X#   Outside
XREGION:(00,05,05,11),lit,"ordinary"
XREGION:(57,05,62,11),lit,"ordinary"
X#   Hallways
X#REGION:(08,03,54,03),unlit,"ordinary"
X#REGION:(08,13,54,13),unlit,"ordinary"
X#REGION:(16,08,25,08),unlit,"ordinary"
X#REGION:(39,08,55,08),unlit,"ordinary"
END_OF_FILE
if test 7219 -ne `wc -c <'auxil/castle.des'`; then
    echo shar: \"'auxil/castle.des'\" unpacked with wrong size!
fi
# end of 'auxil/castle.des'
fi
if test -f 'include/system.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/system.h'\"
else
echo shar: Extracting \"'include/system.h'\" \(7724 characters\)
sed "s/^X//" >'include/system.h' <<'END_OF_FILE'
X/*	SCCS Id: @(#)system.h 3.0	88/10/10 */
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#ifndef SYSTEM_H
X#define SYSTEM_H
X
X#define E extern
X
X/* some old <sys/types.h> may not define off_t and size_t; if your system is
X * one of these, define them by hand below
X */
X#ifndef VAXC
X#if !defined(THINKC4) && !defined(AMIGA) && !defined(MACOS)
X# include <sys/types.h>
X#endif
X#else   /*VAXC*/
X#include <types.h>
X#endif  /*VAXC*/
X
X#if defined(TOS) && defined(__GNUC__) && !defined(_SIZE_T)
X# define _SIZE_T
X#endif
X
X#if defined(MSDOS) || ((defined(AMIGA) || defined(MACOS)) && !defined(THINKC4))
X# ifndef _SIZE_T
X#  define _SIZE_T
X#  if !(defined(MSDOS) && defined(_SIZE_T_DEFINED)) /* MSC 5.1 */
Xtypedef unsigned int	size_t;
X#  endif
X# endif
X#endif
X
X#ifdef ULTRIX
X/* The Ultrix v3.0 <sys/types.h> seems to be very wrong. */
X# define time_t long
X#endif
X#if defined(ULTRIX) || defined(VMS)
X# define off_t long
X#endif
X#if defined(AZTEC) || defined(THINKC4) || (defined(MSDOS) && defined(__TURBOC__))
Xtypedef long	off_t;
X#endif
X
X
X/* You may want to change this to fit your system, as this is almost
X * impossible to get right automatically.
X * This is the type of signal handling functions.
X */
X#if defined(__STDC__) || defined(ULTRIX)
X	/* also SVR3 and later, Sun4.0 and later */
X# define SIG_RET_TYPE void (*)()
X#else
X	/* BSD, SIII, SVR2 and earlier, Sun3.5 and earlier */
X# define SIG_RET_TYPE int (*)()
X#endif
X
X#if defined(BSD) || defined(ULTRIX) || defined(RANDOM)
XE long random();
XE void FDECL(srandom, (unsigned int));
X#else
XE long lrand48();
XE void srand48();
X#endif /* BSD || ULTRIX || RANDOM */
X
X#if !defined(BSD) || defined(ultrix)
X			/* real BSD wants all these to return int */
X# ifndef MSDOS
XE void FDECL(exit, (int));
X# endif /* MSDOS */
XE void FDECL(free, (genericptr_t));
X# if defined(AMIGA) && !defined(AZTEC_50)
XE int FDECL(perror, (const char *));
X# else
X#  ifndef MACOS
XE void FDECL(perror, (const char *));
X#  endif
X# endif
X#endif
X#if defined(BSD) || defined(ULTRIX) || (defined(MACOS) && !defined(THINKC4))
XE int qsort();
X#else
X# ifndef LATTICE
XE void FDECL(qsort, (genericptr_t,size_t,size_t,int(*)(genericptr_t,genericptr_t)));
X# endif
X#endif
X
X#ifndef AZTEC_50	/* Already defined in include files */
X#ifdef ULTRIX
XE long FDECL(lseek, (int,off_t,int));
X  /* Ultrix 3.0 man page mistakenly says it returns an int. */
XE int FDECL(write, (int,char *,int));
X#else
XE long FDECL(lseek, (int,long,int));
XE int FDECL(write, (int,genericptr_t,unsigned));
X#endif /* ULTRIX */
XE int FDECL(unlink, (const char *));
X
X#ifdef MSDOS
XE int FDECL(close, (int));
XE int FDECL(read, (int,genericptr_t,unsigned int));
XE int FDECL(open, (const char *,int,...));
XE int FDECL(dup2, (int, int));
XE int FDECL(setmode, (int,int));
XE int FDECL(kbhit, (void));
XE int FDECL(chdir, (char *));
XE char *FDECL(getcwd, (char *,int));
X#endif
X#endif  /* AZTEC_50 */
X
X#ifdef TOS
XE int FDECL(creat, (const char *, int));
X#endif
X
X/* both old & new versions of Ultrix want these, but real BSD does not */
X#ifdef ultrix
XE void abort();
XE void bcopy();
X#endif
X#ifdef MSDOS
XE void FDECL(abort, (void));
XE void FDECL(_exit, (int));
XE int FDECL(system, (const char *));
X#endif
X#ifdef HPUX
XE long FDECL(fork, (void));
X#endif
X
X#ifdef SYSV
XE char *memcpy();
X#endif
X#ifdef HPUX
XE void *FDECL(memcpy, (char *,char *,int));
XE int FDECL(memcmp, (char *,char *,int));
XE void *FDECL(memset, (char*,int,int));
X#endif
X#ifdef MSDOS
X# if defined(TOS) && defined(__GNUC__)
XE int FDECL(memcmp, (const char *,const char *,size_t));
XE char *FDECL(memcpy, (char *,const char *,size_t));
XE char *FDECL(memset, (char*,int,size_t));
X# else
X#  ifndef LATTICE
X#    ifdef MSC
Xvoid * _CDECL memcpy(void *, const void *, size_t);
Xvoid * _CDECL memset(void *, int, size_t);
X#    else
XE int FDECL(memcmp, (char *,char *,unsigned int));
XE char *FDECL(memcpy, (char *,char *,unsigned int));
XE char *FDECL(memset, (char*,int,int));
X#    endif
X#  endif
X# endif /* TOS */
X#endif
X
X#if defined(BSD) && defined(ultrix)	/* i.e., old versions of Ultrix */
XE void sleep();
X#endif
X#if defined(ULTRIX) || defined(SYSV)
XE unsigned sleep();
X#endif
X#if defined(HPUX)
XE unsigned int FDECL(sleep, (unsigned int));
X#endif
X
XE char *FDECL(getenv, (const char *));
XE char *getlogin();
X#ifdef HPUX
XE long FDECL(getuid, (void));
XE long FDECL(getgid, (void));
XE long FDECL(getpid, (void));
X#else
XE int FDECL(getpid, (void));
X#endif
X
X/*# string(s).h #*/
X
XE char	*FDECL(strcpy, (char *,const char *));
XE char	*FDECL(strncpy, (char *,const char *,size_t));
XE char	*FDECL(strcat, (char *,const char *));
XE char	*FDECL(strncat, (char *,const char *,size_t));
X
X#if defined(SYSV) || defined(MSDOS) || defined(AMIGA) || defined(THINK_C) || defined(VMS) || defined(HPUX)
XE char	*FDECL(strchr, (const char *,int));
XE char	*FDECL(strrchr, (const char *,int));
X#else /* BSD */
XE char	*FDECL(index, (const char *,int));
XE char	*FDECL(rindex, (const char *,int));
X#endif
X
X
XE int	FDECL(strcmp, (const char *,const char *));
XE int	FDECL(strncmp, (const char *,const char *,size_t));
X#ifdef MSDOS
XE size_t FDECL(strlen, (const char *));
X#else
X# ifdef HPUX
XE unsigned int	FDECL(strlen, (char *));
X# else
X#  ifdef THINKC4
XE size_t	FDECL(strlen, (char *));
X#  else
XE int	FDECL(strlen, (char *));
X#  endif /* THINKC4 */
X# endif /* HPUX */
X#endif /* MSDOS */
X
X/* Old varieties of BSD have char *sprintf().
X * Newer varieties of BSD have int sprintf() but allow for the old char *.
X * Several varieties of SYSV and PC systems also have int sprintf().
X * If your system doesn't agree with this breakdown, you may want to change
X * this declaration, especially if your machine treats the types differently.
X */
X#if (defined(BSD) || defined(ULTRIX)) && !defined(DGUX) && !defined(NeXT)
X# define OLD_SPRINTF
XE char *sprintf();
X#else
X# if !defined(TOS) && !defined(AZTEC_50) /* problem with prototype mismatches */
XE int FDECL(sprintf, (char *,const char *,...));
X# endif
X#endif
X
X#ifdef NEED_VARARGS
X# if defined(USE_STDARG) || defined(USE_VARARGS)
XE int FDECL(vsprintf, (char *, const char *, va_list));
XE int FDECL(vprintf, (const char *, va_list));
X# else
X#  define vprintf	printf
X#  define vsprintf	sprintf
X#  define vpline	pline
X# endif
X#endif /* NEED_VARARGS */
X
X#define Sprintf	(void) sprintf
X#define Strcat	(void) strcat
X#define Strcpy	(void) strcpy
X
X#if defined(MACOS) && defined(CUSTOM_IO)
X# undef printf
X# undef puts
X# undef putchar
X# undef putc
X# define printf  (void) mprintf
X# define puts	 mputs
X# define putchar mputc
X# define putc	 mputc
X# define Printf  (void) mprintf
X#else
X# define Printf  (void) printf
X#endif
X
X#ifdef NEED_VARARGS
X# define Vprintf (void) vprintf
X# define Vsprintf (void) vsprintf
X#endif
X
X#ifdef MSDOS
XE int FDECL(tgetent, (const char *,const char *));
XE int FDECL(tgetnum, (const char *));
XE int FDECL(tgetflag, (const char *));
XE char *FDECL(tgetstr, (const char *,char **));
XE char *FDECL(tgoto, (const char *,int,int));
XE void FDECL(tputs, (const char *,int,int (*)()));
X#else
XE int FDECL(tgetent, (char *,char *));
XE int FDECL(tgetnum, (char *));
XE int FDECL(tgetflag, (char *));
XE char *FDECL(tgetstr, (char *,char **));
XE char *FDECL(tgoto, (char *,int,int));
XE void FDECL(tputs, (char *,int,int (*)()));
X#endif
X
X#ifndef MACOS
XE genericptr_t FDECL(malloc, (size_t));
X#endif
X
X/* time functions */
X
X#ifndef MACOS
X# ifndef LATTICE
XE struct tm *FDECL(localtime, (const time_t *));
X# endif
X
X# if defined(ULTRIX) || defined(SYSV) || defined(MSDOS) || defined(VMS)
XE time_t FDECL(time, (time_t *));
X# else
XE long FDECL(time, (time_t *));
X# endif /* ULTRIX */
X#endif
X
X#ifdef MSDOS
X# ifdef abs
X# undef abs
X# endif
XE int FDECL(abs, (int));
XE int FDECL(atoi, (const char *));
X#endif
X
X#undef E
X
X#endif /* SYSTEM_H */
END_OF_FILE
if test 7724 -ne `wc -c <'include/system.h'`; then
    echo shar: \"'include/system.h'\" unpacked with wrong size!
fi
# end of 'include/system.h'
fi
if test -f 'others/atarifnt.uue' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'others/atarifnt.uue'\"
else
echo shar: Extracting \"'others/atarifnt.uue'\" \(7164 characters\)
sed "s/^X//" >'others/atarifnt.uue' <<'END_OF_FILE'
Xtable
X !"#$%&'()*+,-./0123456789:;<=>?
X@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_
Xbegin 644 hackfnt.arc
XM&@A(04-+1DY4+E!21P  E!,  #\48JO>BQ\=   ,8#0  #" S4 ,! ! &@!Bz
XM8 "#D!2 > .  !Q_P%!5= 'D!0(GN10.X('EB9,Z1L+0"<,&1!DY<M[(T0$By
XMC9LY=<R823,F31DW=$"T*=-&9IX&"@8B.<<#APF*($8L&[@!CY*0 #8 ,J-@x
XM!+^!"1=J?;$ I$-.)@" 6 . 0;1U "B\!< A"3P< TPPP,//&"$0*RI" K *w
XM  (1 PP$&MA0$B B@4HJ"401@#<0.:@BD@((#P%8A,18&0<(QPX$!ISL R( v
XM0%(/ %0 H ' !XH!V HC&$%L8,$1P32#,>*5L<@-B,#H(!<(N' 8XIH'SYK<u
XM!(@ Y  Y=DX=#(:KFME N X-*_(1P#2_ <,WF7E$(!(#<@@@K;7W(!9 &R0Bt
XM, '%__P##@"R -*&#2XL\<TP5@E1Q L#D/5# 3\0X$00WGS%0%J=./-"9ED1s
XM\B%5<(R8%1UF 2" -!FVA4<"*O @$@8O4&AA$%P\D18>3.CQSX057EA26DQ\r
XMPP$/)REU#@XPB$ 1!G0 0$(: &!033IT8:&$"0KPY1<)0XR@#%5_4<F"$A"<q
XMX00#$  0A!D\,( " %( $( 9-,@)P!$JFL&"GE809 8)>O90D1D<"*$)%H((p
XM\1T&9O C)HDD(,.H$I#R \9 B%1Z::9HFB&+HHQ*\Q4@$&2 !" R (!$,"!Lo
XMB<0;",#!#S"!4 -(-<!H.6E6<)#PE9V:0"$(& 1(D<04@3 0@5IG&. L  G@n
XM.9D;[(#APK0@G$'!M-5J  8#W$8+KAD(,*OLM>P(L0$8"*1J 3#1,GNM,T),m
XM8$< (PQ#%1UHGB%!I5*81\>GD8;JCA"2@"  %H 4R0 ')RW% P@\ZO " !H l
XM>>.0 !1) ))U+(4#""D*H,^.3/PP0)!!@"PRQ76  @!Z5/%1,5,HZ_(//"#Dk
XMD3,#:   P3_2<!4"'[[!\8\Z8(@0]-!%(X"TTDP#,('34"N !!XJ.N$S("5-j
XMG14>)LS)@#4:4< V708,0A\>,3@X(80P0Z%CR-^,G"0D)$00%@$8 ("#0CD i
XMH9 +/!B@4 E@R- J) ;$PX.,"_&PD$(&M E) 0B(=+E"&Q0."08%@,(T'ZM_h
XMKA !"\P)">$ , W)#6UN"HD&#F PX.P&% X&!U4"L"D&8.C$0&W"(P^ 3@ Xg
XM()(!LTNN4 %@Z#Z Y &(!(,>>IC1N4A;C)[Y["3$-E D(N%#EPT#F>] UAY(f
XM#PD"A1M^^.?^>,\ '_YP1_<,@P<<I$X7 M"!#@2!"USH8G-@ T #L%$EG?C e
XM#&S @ &2]SH#\  #// # _S  3^8KP!-P0 ?>( '/_CA@GXP #/ 8 PXK1 ?d
XM/O"#3FIH!C]X@#UM@H/Q . XZ7F' <#87^\P (/XF8$!/# ##. 711C R8H?c
XM!( )I<@#*RX$ QXP P8<P(#9@>\@C&G(0L!G*"UB@ E,>"(?],"Z+YAO).@#b
XM !5:PSX9@0,$/O!! $PH(S^X@7A?[%__%@*!IOC  Q#P0=; 8(#>#80-68,!a
XM#/#0/Q#B@ ,X\(<Q B C!P !"*DS!O4&8 Q@ ,,8FU,<$><$J1YB$ ,,L*+Iz
XM$N,'#+APA"'<7/0   X_K-"%?/##0GHH0QKV<"'\<.$.=>)#]ASN<)MR'&R.y
XMF$2%',!TP6/B0'182PP03R?E7(@? ( /=(K1# ?! 9P\@('9P1&-:@%!_N"Xx
XM3@ LDG 04(8QC%&%.VJ. .E306O6N4YPQ& ,-A@ (;7H!OAE;IW]4Q$$_- 2w
XM"&RTDW!P0 8P@ $!$"%K>$!"_GA  A;00!?^L,8 Q/@ .* 2%*I<2"M?N3DAv
XM N  T*C@/\# !AR8$P=97(@!S"#/B8$!#DL5HSG]  <SF$.'9G #&):I06R u
XMP1UFF-T,:\E#!B / X<C7C:+MRD  ,-TW^0<29OX/(4TX'+KI"#EHMA%='+Nt
XMCB,8@>D(8(;N84-S QA(0 4AB"@85)WPI,(9W+A.6&3 !S:XX.ATTBHSB,&Ss
XM @ #;(QI!F/ @'7@,$8O/UDZ#/@ DTH1Y_-(8(XS2((?DAC ,'B0@%,V !8Yr
XM9:4K83D /LC2!6V"U% 98-3,[9(!3'TB![(759+BP _R%$98";#5F7;UJW8(q
XMZP#&NL,HFA4&&# (%%?H@P]*$@<,8$9Z+\<'2>9PFCV<JQAJJ;D$X$"=?@"#p
XM'0Z[3,CZP8IB; I?S9##_)D@+9F+8@_\@ UE)M9HRM"%+J+P WX< !P!ZO _o
XMSA&;,_# #KX$ "8:D%D^F.$?//B'&5 ,@7O8PPQ@.+ \^R($8V# &M9X92]!n
XM6;K:X>!P'T ">@<R#!(,(AC6X(<N#! )'B  "#CXK2 2J -=-% 0&O9#!',Pm
XMH%KR 0-PJ.< _L'0MHC1K#S@P[A"2%(A<H !VNAA\ECGAEX: !Y@\$=X%\*,l
XM-)?W@TQ,;T5RF,S/P9<;&/"',@^ 7^RB51[(ZZ$/9M?H ?QWICC^@S<L'%8#k
XMP("</KBN+9>:/Q:P  ,:@$4.^_P/;XA7L<H0A2H T.$'P"/$_/B'OZA0#A]Hj
XMX;IM.8 -;! ,/\#X'W9H+P0RP0T<\R.]805 HXS! TE(XI5:=$":?:DX1B(!i
XM#$@82"#.\61CX ,'5+;R0#J BX'PP76L<]Q"#E=!!J-9S6S68I7<@$L0&A.*h
XM/B#I@,AH#3/(V>%\Z+,& 6T-'4+3J#JQ!@CK20!C#&2IR;/EF_$1Z;!BKY;6g
XM,"\\P.@+'H2<>MP5KYIUPH<-V/I^8(!!G&,(J85$6XP'68@-L+%4-YAA&S>_f
XM<$!%(0M>\^,#^ #V/XRF@EJ8 \8R(L !,#L(9\?8#@Y@:B80(6=4,*"&,!"$e
XM'VKH[;ZX$)0D]4-K%@*-K]'U'(&HK37TH0M&=(*%'N! #CBQ95SH8"$(U(4.d
XM*GD >,P( /\PM3>JM/$9H1B7;#! +\4W$#B0\,<Z3%[VT&D KU;<EOC@ ,KGc
XMJF:/UP;'[GSSRAL^NZ>B/(H86+D'.$&"D&\ZYE\$,!_VT$Z<^P-2KNVY1'5(b
XM5QC((+ULN* =W+"-"NM0)'H0A2X  '41_RC8 $ !%7HQ#QGS "/?R&P.GVV a
XMI>+@'8C ,0K.+L5&L8%AMU4M6E5?.!^()*B?0P+#X%*2( ^2P B!P /X  $2z
XMD >>H$K L$JJI$I^  $/X#Y?!'D&8 .31U))-0"ZA'FLQGF&8VG<$'HX%G+?y
XM90Q&YV+8T#LZX0\?A%YF)1(HN'DC]V/;!08?%(/(9U2' WO*A#T6IF8N! ;_x
XM4'P)<&IBM'F0)44N9'08@ TVH$-VX ??8'WPM! *H N[YFO>)V+#  $JP $[w
XMH 4]A!' L&S)Q'X>Q 9F4&U@@ (8@':-@@+X!VYHUCL+D348  770P),Q0&Zv
XM8 _6@ W#0%4<P %QX @0*($&H$I/] 'L<#VVQ R4)U55HDM6%$-2)#XD13QIu
XM!@P[J()F,$,L"'O,$#QP(H-G58/+!'O>@4X,@ TZ6'LP>'Y5-%< ( 0ZD3RUt
XM-SLSAV/8@ UAA0 'AGSOM!!&!V#3X S0)UX#9HR;PX6,]5/@$(;!1F)4@ 'Ss
XMX ;#\ _^  _P@%G!\&(QUGZ*=F-S" -H5T.J8 9 )F3($SRV*$L\($0!V$7,r
XM90[&@ 4O9C04T(B/J%.1N%0"@!"6Z&*8"$KP5#B9QD0B9T5+)#T#(@[BI56Fq
XMB(J_J :K""D\ %9G%3PB\8LXYDMO)E\U5'NL&)(AA%[B- PF&8R$$XM@4(PFp
XMAU5=I$+*.#O21$D&H $8,'3;A9/5.  *,%"BLSEX!4\J\ ]7%8Y\0(XV\ >#o
XM "<RTGY,X'%B(&<H0%1_  +)Y [&Q >IM4Y?I%<CHT8HE#]\X [N  <\T"8,n
XM& :&@$"&ET")IP.?%Q8#D#^%TS^YA$;(HTP$,$('9D(D-2,ZA$P!UIAKMW9Zm
XMQ@?ZUTLUY$L>8 !@TS]#Z%IPP@#.P ,U9&$YY@&6R6"])$YL!@D+@%C45&M#l
XMF$.]] ?IY4LAA%7M%6#2\GRQ9ICB2$TBH0"LLY2)A5CI0P4OY&S_P ?\P \Vk
XM, 8Y-#KMQP:NQP:;X@\XT 5&PP-L,)<;Y7%%B FO8SH-T$3[,P!!( BKLYZUj
XMLT)&XY> "0!V0$1M!9$\Z$)Q<CDZ9U2[!$(.QT(!%D4FI%HUY'(V8 QG]D&"i
XMT(29N9FU45]?M%1QPFT%6E]@P <.D' +JGF\"  \L&D*X)H])&J(%4@>]$'_h
XM@#QPT%X?"CT>2DD8\ /YTUZ\P M_H)/!>3V(Y:$+D5"7LPQLQIS\$$C)))T&g
XM<)Y@X'C]DQZ>,P#P$$G@^47Z* $-X3D1X &8XP!-! E:JA KT$^V@SWZ=@#Kf
XMU#L#TA:<LSR0L%'7 P2ZHWEH.0 ?D)"O PCSP:4[:IQZM$Z)4%<!8@,<D![Fe
XM<P#E1@#S83L#\#MQ!0DG< %4H! .H$:1ZJ4H=3V4Y$VV<Z2<LS\08#LID*>8d
XM8P"A T\!8ACS83Y"J1!PYH$C-D@D18ZIPP<&P#H(ZCIXT'B"4T'%8U3B=CT"c
XM\$$A!$P3143&<SDJ!* O!"<@5Z%Q%D*5Y@% @ =-NE9J15)@H$2]HX\S9592b
XM!)&?&)'+(Z/=ZD5_R0&(X@%E1  T0!N?HY0;@ WKVAH \ <PL*Y/! !ZX$)Ya
XM\%@(]3K^ DTS@$@C@3D#(#WP1#S^)#H#<6>U(2-,M#R+>60#<601Q%*@E G"z
XMIEL\$*C D$H2Z$J1Z'%@<(&Q4T'1=TL.N4ON)UW4A4ZX!  (%D48U%UB9 #6y
XMZ0Z#5@!DI1/!XQV'DQYKU41MY1W>!$YJYAT.^Y"%\Y#/0U>%@P</"71?I -Fx
XM8 /H-3M8@ 7&.A#,(%\VP 99RP.M88M96R4!-0S#\ +\FE "D$,(("/PL '+w
XM-@,3Y0<VL $U!@ VT#]F !M5<CDV@ $04%6]M!!+) .P!0!LP 8,P+<D8 ]Ov
XM, S^D D&, T\8 '^\ T>JU,@.U L1(D35$'^0%3--1+/17#!$V?C@D[JI$%&u
XM)XM<I9F!9G'<15;FE6@&P8/L%6?OA7SLL$+U55]8Q4.%.P"8MH4C$3\>.IZ^t
XM1&&6R%<ZYW"<LU0B48R*"S_/$T(4M+PP@ /*T N]\*D$BU@CID<G, Z(LD[<s
XM\ !WX /,@)7/8P--D0GA90;^T+ULL$5F4$ /IT6Y5&1,(+$/D$'\-@SL%@SGr
XMP \\P B6"P'8L V_96_X)JO>\1^TI+@?)$0D%7#KA $H1BZ9EZ#^![-MP0!Jq
XMX'![%G%^!@=@<'HNMD*K]T&SXW$P '(Z@6 DE4'^8'*S6%KF18.>0 /)<SDGp
XMRH-P\FF7 P8VYYJ?<Z$JM)]1Y&(7Y%I\L&Q3N &7XP;4YPTD!4\8%@JEP'WXo
XMX&M2![,J4 =[\ ]5" #&\ >8I47/9@?FR@;4Q@=BD$&+"RDZQ U4<'K%6SIHn
XM23AL  /+ P#G, Q/-@SYD D/7('>\ ^_59"L=) NA!! 53R9!P,=6'D+$8*:m
XMMU16%#R;0U)])HLJ*+NI*&"95TNN2(.[=$')<V NBP>WR%T]*(_(-SL,0 /4l
XM9  ^T'XY%GR@Q@=_4'P(D'-5Q(H^=\.$O 8$QP8VL%1V8 =9>#E># %Z$ HAk
XMX6M05\9(0 7=@+[R.XYKZ -TRW[090SO@ PX-LAY+%[,T,<<]+!3" "M4B78j
XM@$D1)(B0FPGS, QP,(9IY@$9@ F2/(&L!@$$@%PBX0\,21?R)$X1:470]8EFi
XMA4L'9CSB99VF:)T\1%3N%))BY!TD:9,X!@-37)LKR5TMR5Y7FUAB$$4YUD,Fh
XMU%U&&&!&60 7=$60<FK*YP;ME7,,, P:][46AQO4J'0*T NM0)P>&F/G  ,Jg
XMX%I^, ;+R0_E> ?O*YU0M*!R"(=Y'$4DP XX8 V$.R.VR 0'H8\%0 (;BU3Gf
XM< X@, PXL'(;X("RFF]ZO4(>@*5DALD88 3SV:LDC % <)OYV45- ;..XQT7e
XMM$(M! ::): %"@8V "?)=YD^)  .*DD?VD42"I(5Z@,7FJ'8IGG9JD4(T%Z_d
XM][:40TU86**__*&^I$*2?3D[/1!2Q "&\ D8\*[MI4XW>GU<B+9.K:?("0##c
XM\ ?+^0_."3\3)2W;:P=RQ@;829O^B0>G=4%:)*6#M:5M68T$4(%MU8BJZJC[b
XMTP"ZHP-9P]:7"@D'X(<BL3\EW:GXI#L'L*, \  E30"GI-MP$IPN=-P]JKS+a
XM-!!3A[!WI*U@@ _IYE:-)!)@X#DEO0!DH -<< 9N4 =<P 9S5P!G, 9C\ 5Cz
XM\ 9M  <?_@5?, <K(0=T$ -S-S)?  =A( =S4 8U/G<#$ "<\ 4U?@;SN1#=y
XM(Q9PX.-R$.(B,>0#L %T@ 9A, 9KD%5TX (Z+@"X$.(C7N(G7N6XH.)B$ 8Wx
XM3A]B@0<JW@9A8!,#4>72\ 4+P1(V409*O@%\H.)E@ =I$"4J(A)63N)OP 9Rw
XM\ 5D$ 9^N35L/@!$4 1&$ 15$.> H.)H@.-P\.5^61 JSN(U'B4I7A1N\ : v
XM+N@B,0!%7@9T4.=XKN.4_A-VD 8QX09Q3@B53@=K, =IH =QC@A?\!)RL.EBu
XMON2,<.MV'B4+P>5?8.9H'NQZK@]?8!-WKN=Z#@^W'N@K 1;'$>IN0 :O$^>#t
XM(1(0$,T,@  Z@ +2H@ *X  (H  &H  0( .KQ !"8*)6P  ZP $0X #C3@$ s
X# !H r
X q
Xend
END_OF_FILE
if test 7164 -ne `wc -c <'others/atarifnt.uue'`; then
    echo shar: \"'others/atarifnt.uue'\" unpacked with wrong size!
fi
# end of 'others/atarifnt.uue'
fi
if test -f 'others/ovlmgr.uu' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'others/ovlmgr.uu'\"
else
echo shar: Extracting \"'others/ovlmgr.uu'\" \(7707 characters\)
sed "s/^X//" >'others/ovlmgr.uu' <<'END_OF_FILE'
Xbegin 666 ovlmgr.obj
XM@ P "F]V;&UG<BY!4TW$EA4   904U!314<&3U9,5$),!$-/1$6%F H     
XM "P  @$!+I@*       0  ,! 4F8!P!H:1D$ 0%QC$8 !R0D24Y43D\ "20D
XM3U9,0D%310 *)"1-4$=33D]63  +)"1-4$=33D)!4T4 !B0D34%)3@ &)"1#
XM1U-.  8D)$-/5DP T9 0   #"20D3U9,24Y)5$$. )B(!   H@'1H!0  @  
XM                     $J@(  #             /__________        
XM  #_____2:(/  ,< !   0 !     O__'J &  ,\    &Z(/  ,^ !   0 !
XM     O___* 2  -> /__                [Z &  -L!   YYP( ,0   ,#
XM;@0@H@\  VX*$  !  $    "___"H 8  XX*  "_HF8  Y * 0    )-6@$ 
XM   "   !     @   0    (   $    "   !     @   0    (   $    "
XM   !     @   0    (   $    "   !     @   0    (   $    "  "*
XMH  $ Y ,__\                                       !%34U86%A8
XM,   !   ,S@V('-P96-I9FEC(&-O9&4@96YA8FQE9"X-"B1#;VYV96YT:6]N
XM86P@;65M;W)Y(&%V86EL86)L93H@)$@@<&%R86=R87!H<RX-"B1%35,@;65M
XM;W)Y(&%V86EL86)L93H@)$@@,39++7!A9V5S+@T*)$YO="!E;F]U9V@@9G)E
XM92!M96UO<GD@;&5F="!T;R!R=6X@=&AI<R!P<F]G<F%M+B1);G1E<FYA;"!M
XM96UO<GD@86QL;V-A=&EO;B!F86EL=7)E+B1);F%C8V5S<VEB;&4@15A%(&9I
XM;&4N($-A;AMT(&QO860@;W9E<FQA>7,N)$EN8V]R<F5C="!$3U,@=F5R<VEO
XM;BX@375S="!B92 S+C P(&]R(&QA=&5R+B1%35,@;65M;W)Y(&UA;F%G97(@
XM97)R;W(N)%5N:VYO=VX@97)R;W(A)!M;,&T;6TL-"AM;2QM;,6U/5DQ-1U(Z
XM&ULP;2 D&UM+#0H;6TL@(" @(" @("@D&UM+#0H;6TL')%!345)65U4>!OR,
XMV 40 "ZC  "T,,TA/ -S!; !Z0  CAX  +[__T:#/ !U^H/&!+  M#V+ULTA
XM<P6P ND  "ZC  "T-;!GS2&,R([8OPH O@  N0@ \Z:P '4"L/\NH@  =1*T
XM0<UG+HD>  "T0LUG+HD>  "X   NHP  N   CMB+'@  +HD>  "+'@  +HD>
XM  "T2,TA<P/I   NHP  #A\S[3/_,_;H   NH0  +@,&  ".P#/ )J,  ":C
XM   FH@  )J(  ";'!@  __\NH0  T>#1X-'@T>#1X"Z+%@  "])T#M'JT>K1
XMZM'J0BT@  /"+BL&   FHP  +H,^    = 8[QW("B_@NH0  T>#1X-'@T> F
XMHP  )HDN   N RX  (O5BLZ*\C+M,M+1XM'1L "T0LTA+J$  $@N.P8  '0#
XMZ0  +J$  "ZC  ".P";&!@   ";'!@(    FQP8$    )L<&!@   ":)/@@ 
XM \<NHP  5RZ.!@  Z   )L<&  #__R: )@  _5+H  !87PO =05'.]=R+R['
XM!@     NQP8     OP  +L<%__^#QP8NH0  +HD%+HD^  ".P";&!@  !>L%
XML /I  "X  ".V*   #+DT>#1X"ZC  #H   NBPX  +@  ([ C,B.V+L  +X 
XM +\  ":*!#+D P8  (D%)HL'*P8  (E% H/'!(/# D;BX@<?75]>6EE;6.H 
XM    +HDV   NC!X  %X?4%/\K#+DB]BM+J,  (O&+HLV  "#EIPQ L0"  ,#
XML0W$!  # X4-Q 8  P,P#<0(  ,#A0W$"@ # V$-Q P  P-A#<0.  ,#WPW$
XM$  # X4-Q!(  P/Y#<04  ,#^0W$%@ # _D-Q!@  P/Y#<0:  ,#^0W$'  #
XM _D-Q!X  P/Y#<7"  ,#: "%SP # P$8Q=,  0$L (7N  ,# 1C%\@ # Q@ 
XMQ@(  P.P#,81  ,#O S&'  # VH QB4  P.X#,HH)@("QBP  P-D ,HO)@<'
XMQC4F!@;&.@ # V( QCXF!P?&0P # V  ADP  P,.$,90  ,#&@"&6P # ]X7
XMQE\  P,: ,9D  ,#J@K&;  " @0 QG   @(& ,9T! ("QG@  @(! ,9]  ("
XM" #&@P # Y0*QI(  P.2"L:I  ,#F K&K0 " @P QK(  P.J"L:_  ,#F K&
XMRP " @X QM   @(* ,;5  ,#E K&[0 # V  QO,  P.J"H;X  ,#Z@[&_  #
XM V0 QP   P,\ ,<H  ,#9@#'+@ # QH AS$  P.7%L<V  ("" #'/00" H="
XM  ,#_Q7'4@0# \=9  ,# @#'7@ # VX$QVH  P,: ,=R  ,#; 3'>00" H>!
XM  ,# 1C+A"8! <>))@$!QY,  P.."H>6  ,#^1C'FP # V( RYXF! 3'IR8$
XM!,>J)@,#QZT  P-L ,>V  ,#&@#'OP # V0 S]<F!07'W@ # Q  Q^,  P,2
XM ,?R  ,#! #'^0 # VP$7*  ! .,$,8&+HQ<_"Z)1/[1X]'C@<,  "Z.'RZ+
XM1P(NC!PNB38  "Z+-@  1BZ)-@  B38  "Z+-@  ='^)-@  ]@8   %T??X&
XM   #!@  +J,  "Z+-@  +HX>  !;6)TN_QX  )PNC!X  "Z)-@  +HLV   N
XMCAS^#@  @^X&+HX<+O]T B[_= 0NB38  "Z+-@  1BZ)-@  B38  "Z+-@  
XM=#>)-@  ]@8   %T-"Z+-@  +HX>  #/1BZ)-@  Z0  ]@8   )T"U"A  #H
XM  !8Z0  Z   Z0  1BZ)-@  Z\'V!@   G0*4*$  .@  %CKN^@  .NV4%%2
XM4U565QX&C-B.P": /@   '4*)J$  .@  .L$D.@   4! ":C  ".V":+%@  
XMBLZ*\C+M,M+1XM'1)J$  %%2 ]"#T0"T0K  +HL>  #-(7)(,](FBPX  -'A
XMT>'1X='AM#_-(7(S6EFT0K  +HL>  #-(7(DN0 "N@  'HS(CMBT/\TA'W(2
XMZ   !Q^ #@   5]>75M:65C#L 3I  "^  "+[H'%  (NBTP&XUV,WRXK/@  
XM+@-T&#OU<@/H   NBAQ&._5R ^@  "Z*/$8[]7(#Z   +HH$1COU<@/H   N
XMBB1&+@,&   #QX[ )HL'+@,&   N.P8  '()+CL&  !S @/')HD'XJ[#4U%7
XM51X&N0 "N@  C,B.V"Z+'@  M#_-(7,#Z0  O@  !Q]=7UE;PU-14E9751XN
XMCAX  #/ B]"+Z(O8+HL.  #VAP  !'4P]H<   )U!_:'   !="(NBS8  "Z+
XM/@  *[<  !N_   [UW(&=0H[QG,&B\:+UXOK@\,0XL0+[74%L 7I  #1[='M
XMT>W1[8S8 \4?75]>6EE;PX#\2W0/@/Q,= 4N_RX  +  Z0  "L!U\E!14E-5
XM5E<&'BZ.!@  +HL.  "[$ !))O:'   "=1<F]H<   %T%2:+AP  +0$ +CL&
XM  !R!B: IP  _H/#$.+6+L<&  #__RZA   ]__]T#H[ )HX&!  FQP8"    
XMN1  O@  +HL$/?__= N.P+1)S2$NQP3__X/& N+HZ   B^S_=A:='P=?7EU;
XM6EE8+HP6   NB28  ,TA+HX6   NBR8  %!14E-55E<&'HOLG(]&%N@  .@ 
XM !\'7UY=6UI96,\FBQX  (/K 8O3)@,6  "#P@$FH0  /?__=!#H   F@ X 
XM  (NH0  ZUF0+J$  .M2D([8.]AS"3O"<TWH  #K\0,&"  [V',W]@8   %T
XM!^@   ,&"  [PG(EC-B+RRO(=!(&Z   )H .   !Z   C,".V <FBPX  (/!
XM >LZD*$"  :<V@+$$  # VP Q!\  P-L!,0D! ,#Q"H$ P/$+@ " @0 Q#, 
XM P," ,0Y  ("!@#$/00" L1$  (" 0#$2  " @( Q$P  P,& ,11  ,#$ #$
XM5@ # Q( Q%X  P,$ ,1D  ,#$@#$:0 # Q  Q&X  P-L!,1U  (" 0#$B  #
XM VP$Q(T$ P/$DP0# \27  ("! #$G  # P( Q*(  @(& ,2F! ("Q*X  P,0
XM ,2S  ,#$@#$N@ # P( A+T  P/#$,3!! ("Q,@  @(( (3+  ,#+!>$SP #
XM \X0A-(  P.!$835  ,#SA#$VP # P( Q.$$ @+$Z  " @@ A.L  P,L%X3Q
XM  ,#@1'%!0 " @$ Q0P  @(, (4/  ,#DQ2%%0 # P44Q1P  @(" ,4C  ("
XM"@#%,P " @X Q4,  P,8 ,5.  ("# #%9P # Q@ Q7$  P.0"H6   ,#(A+%
XMA@0" H64  ,# 1C%EP # Y *Q:H  P-D (6U  ,#CQ*%P  # X\2A<L  P./
XM$H76  ,#CQ+%WP # V@ Q>L  P-H ,7P  ,#9 #%]P # V8 Q@T  P.0"L86
XM  ,#& "&'P # QT2QB(  P.0"L8U  ,#&@#&0@ # V  QD8$ @+&300" L94
XM! ("QEP$ P/&80 # P( QF4  @($ ,9I  ("!@"&AP # P$8QJH  P,, (:O
XM  ,# 1C&P0 # QH QL8  P-@ ,;/! ("QM<$ @+&WP " @( QN<  P,< ,;N
XM! ("QOD  P-> ,;_  ,#' #'&  # QP AS,  P,T&<='  ,#% #'3  # Q8 
XMQU,  P,4 ,=8  ,#%@"':@ # _\5AVT  P/Y&,=\  (" @#'A@ " @P QXT 
XM @(( (>5  ,#+!?'F@0" L>?  ,#:@#'I@ # SP A[8  P,^%8?*  ,#/A6'
XMW@ # ]H4A^<  P-^%<?Q  ("# #IH  $ X@4"\!T NNIL ;I   FQP8  /__
XM)H F  #]B\B#P0'H   [T7,/Z   .]%S".@  .@  .OJZP&0!H .   !Z   
XM<@D>C,".V.@  !\'C 8& (S8PXS8 \&.P*$( "O!=C")#@@ )J,( *$" ":C
XM @",!@( )HP>!  FQ@8    FH0( "\!T"AZ.V(P&!  ?^,/YPRZA   STNL8
XMD([8]@8   %U"SD." !R!8L6" ##H0( "\!UY</V!@   702!HX&!@ F@"8 
XM /XF@"8  /T'ZR60CMB )@  _O8&   "= N )@  _:$  .@  *$  "T! ([8
XMZP&04@: )@  _J$$  O =#*.P";V!@   74H)@,&" ",VCO0=1VA"  F 08(
XM *$" ":C @ +P'0&CMB,!@0 C,".V*$"  O =#".P";V!@   74FC-@#!@@ 
XMC,([PG4:)J$(  $&"  FH0( HP( "\!T!X[ )HP>! " )@  _@=:C-C#45-6
XM5QX&,](NH0  CMBA @ +P'7WO@  OP  N1  M$B[___-(8/[$'))M$C-(7)#
XM+CL&  !R-#O3<P*+TRZ)!([ )L8&    )L<& @   ";'!@8    FC!X$ ":)
XM'@@ C 8" (/& H[8ZP8NB06#QP+BJ[X  +D0 "Z+!#W__W0+CL"T2<TA+L<$
XM__^#Q@+BZ <?7UY;6<,STBZ /@  _W0!PR['!@  __^_  "+V;D0 "Z+!3W_
XM_W01Z   .\-S6(/' N+LB\LSTL.+R[L$ +1#45<&S6<'7UD*Y'0#,]+#+HD5
XM)HD6   F@ X   *+PN@  "ZA  ".V,8&    QP8"    QP8$    QP8&    
XMN@ 0B18( ,.+RX[>B] NBP4FHP  )H .   "PRX[!@  =0'#4U(>!N@  "ZA
XM   STC/VCMCV!@   70-C@8& ": #@   ^L,D*$( #O0<P2+T(S>H0( "\!U
XMV(O"!Q]:6\,&4U%2+J,  (O0M$0RP#/;4LUG6@KD=4^T1+ !NP$ 4LUG6@KD
XM=4"T1+ "NP( 4LUG6@KD=3&T1+ #NP, S6<*Y'4D+HX&   NBPX  #/;)O:'
XM   "= 8F@*<  /Z#PQ#B[5I96P?#L ?K))!1'HS(CMBZ   NBQX  +D< +0_
XMS2%R!SO!=0,?6<.P".L!D#+D4 X?B]C1XX'#  "+%X/Z_W1D4KH  +0)S2%:
XMM G-(;0)N@  S2%84.@  +0"LCK-(;B!,.@  +0"LCK-(;@ H"XK!@  Z   
XMM *R.LTAO@  N1  ,\ N@SS_= HN P8  (/& N+PZ   M *R*<TAN@  M G-
XM(>@  "ZA   ]__]T*IQZ 80)  ,# 1C$#@ " @@ Q!4$ @*$'@ # QD5A"4 
XM P.7%H0L  ,#MQ*$+P # UH5A#T  P/:%(1'  ,#?A7$DP # SP Q,4$ @+$
XMRP0" L36! ("Q-L$ @+$X@0" L3F  ("" "$Z0 # RP7Q.P  @(" ,6!  ,#
XM/ #%C0 # QP Q9   P-N"L6J  ,#&@#%ZP # VX*QA0  P.\#,8=  ,#7@#&
XM(@ # SX AC(  P,L%\9>  ("" #&8P0" H9I  ,#<A?&;0 # VH QIL  @((
XM ,:@! ("QJ<  P-> (:Q  ,#<A?&M0 # VH QLL$ @+&\  # UX QS   P,:
XM ,<U  ,#8 #'/ 0" L=$! ("QUT  P.0"L=B  ,#& #'A  # Y ,QX\  P,(
XM#L>=  ,#)0Z'I  # \X8A[   P/.&,>^  ,#&@"'P0 # \X8Q\H  P,^ ,?:
XM  ,#N@R'X@ # \X8Q^L  P,W#H?R  ,#-!G']@ # QH BJ#I  .$& :.P+1)
XMS2&Y$ "^   NBP0]__]T!H[ M$G-(8/& N+MN1  O@  +HL4@_K_= 2T1<UG
XM@\8"XN\NBQX  (/[_W0$M#[-(5BT3,TA4(;@Z   6.L!D%#0Z-#HT.C0Z.@ 
XM %CK 9 D#P0P/#IR @0'BM"T LTAPQXSP([8+HLV  #ZBP0NHP  BT0"+J, 
XM +@  (D$C$P"OH0 BP0NHP  BT0"+J,  +@  (D$C$P"^Q_#'C/ CMB^A #Z
XM+J$  #W__W0)B00NH0  B40"+HLV   NH0  /?__= J)!"ZA  ")1 +['\.J
XMG'@ Q L  P,< ,0D  ,#/@#$.@ # Q@ A$X  P/8&(1>  ,#Z!C$?0 # XX*
XMQ(0  P,( ,2+  ,#"@#$C@ # VL0Q)P  P,, ,2C  ,##@#$I@ # RD3Q+L 
XF P,, ,3&  ,##@#$S@ # XX*Q-(  P,( ,3=  ,#"@!/B@(  '0#
X 
Xend
END_OF_FILE
if test 7707 -ne `wc -c <'others/ovlmgr.uu'`; then
    echo shar: \"'others/ovlmgr.uu'\" unpacked with wrong size!
fi
# end of 'others/ovlmgr.uu'
fi
if test -f 'src/rumors.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/rumors.c'\"
else
echo shar: Extracting \"'src/rumors.c'\" \(7483 characters\)
sed "s/^X//" >'src/rumors.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)rumors.c	3.0	89/02/08
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X/* hack.rumors.c - version 1.0.3 */
X
X#include	"hack.h"		/* for RUMORFILE and BSD (index) */
X
X/* Rumors has been entirely rewritten to speed up the access.  This is
X * essential when working from floppies.  Using fseek() the way that's done
X * here means rumors following longer rumors are output more often than those
X * following shorter rumors.  Also, you may see the same rumor more than once
X * in a particular game (although the odds are highly against it), but
X * this also happens with real fortune cookies.  Besides, a person can
X * just read the rumor file if they desire.  -dgk
X */
X
X/* The rumors file consists of a long giving the number of bytes of useful/true
X * rumors, followed by the true rumors (one per line), followed by the useless/
X * false/misleading/cute rumors (one per line).
X */
X
X/* The oracle file consists of a number of multiple-line records, separated
X * (but not terminated) by "-----" lines.
X */
Xstatic void NDECL(init_rumors);
X#ifdef ORACLE
Xstatic void NDECL(outoracle);
X#endif
Xlong first_rumor = sizeof(long);
Xlong true_rumor_size, false_rumor_size, end_rumor_file;
X#ifdef ORACLE
Xlong oracle_size;
X#endif
X
Xstatic void
Xinit_rumors()
X{
X	register FILE *fp;
X
X#ifdef OS2_CODEVIEW
X	{
X	char tmp[PATHLEN];
X
X	Strcpy(tmp,hackdir);
X	append_slash(tmp);
X	Strcat(tmp,RUMORFILE);
X	if(fp = fopen(tmp, "r")) {
X#else
X# ifdef MACOS
X	if(!(fp = fopen(RUMORFILE, "r")))
X		fp = openFile(RUMORFILE, "r");
X	if (fp) {
X# else
X	if(fp = fopen(RUMORFILE, "r")) {
X# endif
X#endif
X	    (void) fread((genericptr_t)&true_rumor_size,sizeof(long),1,fp);
X	    (void) fseek(fp, 0L, 2);
X	    end_rumor_file = ftell(fp);
X	    false_rumor_size = (end_rumor_file-sizeof(long)) - true_rumor_size;
X	    (void) fclose(fp);
X	} else {
X		pline("Can't open rumors file!");
X		end_rumor_file = -1;	/* don't try to open it again */
X	}
X#ifdef OS2_CODEVIEW
X	}
X#endif
X#ifdef ORACLE
X#ifdef OS2_CODEVIEW
X	{
X	char tmp[PATHLEN];
X
X	Strcpy(tmp,hackdir);
X	append_slash(tmp);
X	Strcat(tmp,ORACLEFILE);
X	if(fp = fopen(tmp, "r")) {
X#else
X# ifdef MACOS
X	if(!(fp = fopen(ORACLEFILE, "r")))
X		fp = openFile(ORACLEFILE, "r");
X	if (fp) {
X# else
X	if(fp = fopen(ORACLEFILE, "r")) {
X# endif
X#endif
X	    (void) fseek(fp, 0L, 2);
X	    oracle_size = ftell(fp);
X	    (void) fclose(fp);
X	} else {
X		pline("Can't open oracles file!");
X		oracle_size = -1;	/* don't try to open it again */
X	}
X#ifdef OS2_CODEVIEW
X	}
X#endif
X#endif
X}
X
X
Xvoid
Xoutrumor(truth,cookie)
Xint truth; /* 1=true, -1=false, 0=either */
Xboolean cookie;
X{
X	static const char fortune_msg[] =
X		"This cookie has a scrap of paper inside.";
X	char	line[COLNO];
X	char	*endp;
X	FILE	*rumors;
X	long tidbit, beginning;
X
X	if (cookie && Blind) {
X		pline(fortune_msg);
X		pline("What a pity that you cannot read it!");
X		return;
X	}
X	if (end_rumor_file < 0) /* We couldn't open RUMORFILE */
X		return;
X#ifdef OS2_CODEVIEW
X	{
X	char tmp[PATHLEN];
X
X	Strcpy(tmp,hackdir);
X	append_slash(tmp);
X	Strcat(tmp,RUMORFILE);
X	if(rumors = fopen(tmp, "r")) {
X#else
X# ifdef MACOS
X	if(!(rumors = fopen(RUMORFILE, "r")))
X		rumors = openFile(RUMORFILE, "r");
X	if (rumors) {
X# else
X	if(rumors = fopen(RUMORFILE, "r")) {
X# endif
X#endif
X		if (!end_rumor_file) {	/* if this is the first outrumor() */
X			init_rumors();
X		}
X		if (!truth) truth = (rn2(100) >= 50 ? 1 : -1);
X		/* otherwise, 50% chance of being true */
X		switch(truth) {
X		    case 1: beginning = first_rumor;
X			tidbit = Rand() % true_rumor_size;
X			break;
X		    case -1: beginning = first_rumor + true_rumor_size;
X			tidbit = true_rumor_size + Rand() % false_rumor_size;
X			break;
X		    default:
X			impossible("strange truth value for rumor");
X			tidbit = 0; beginning = first_rumor;
X			break;
X		}
X		(void) fseek(rumors, first_rumor + tidbit, 0);
X		(void) fgets(line, COLNO, rumors);
X		if (!fgets(line, COLNO, rumors) || (truth == 1 &&
X		    (ftell(rumors) > true_rumor_size + sizeof(long)))) {
X			/* reached end of rumors -- go back to beginning */
X			(void) fseek(rumors, beginning, 0);
X			(void) fgets(line, COLNO, rumors);
X		}
X		if (endp = index(line, '\n')) *endp = 0;
X		if (cookie) {
X			pline(fortune_msg);
X			pline("It reads:");
X		} else pline("Tidbit of information #%ld: ",tidbit);
X		pline(line);
X		(void) fclose(rumors);
X	} else {
X		pline("Can't open rumors file!");
X		end_rumor_file = -1;	/* don't try to open it again */
X	}
X#ifdef OS2_CODEVIEW
X	}
X#endif
X}
X
X#ifdef ORACLE
Xstatic void
Xoutoracle()
X{
X	char	line[COLNO];
X	char	*endp;
X	FILE	*oracles;
X
X	if (oracle_size < 0)	/* We couldn't open ORACLEFILE */
X		return;
X#ifdef OS2_CODEVIEW
X	{
X    char tmp[PATHLEN];
X
X    Strcpy(tmp,hackdir);
X    append_slash(tmp);
X    Strcat(tmp,ORACLEFILE);
X	if(oracles = fopen(tmp, "r")) {
X#else
X# ifdef MACOS
X	if(!(oracles = fopen(ORACLEFILE, "r")))
X		oracles = openFile(ORACLEFILE, "r");
X	if (oracles) {
X# else
X	if(oracles = fopen(ORACLEFILE, "r")) {
X# endif
X#endif
X		if (!oracle_size) {	/* if this is the first outrumor() */
X			init_rumors();
X		}
X		(void) fseek(oracles, Rand() % oracle_size, 0);
X		(void) fgets(line, COLNO, oracles);
X		while (1)
X		    if (!fgets(line, COLNO, oracles)) {
X			/* reached end of oracle info -- go back to beginning */
X			(void) fseek(oracles, 0L, 0);
X			break;
X		    } else if (!strncmp(line,"-----",5)) {
X			/* found end of an oracle proclamation */
X			break;
X		    }
X		pline("The Oracle meditates for a moment and then intones: ");
X		cornline(0,NULL);
X		while (fgets(line, COLNO, oracles) && strncmp(line,"-----",5)) {
X			if (endp = index(line, '\n')) *endp = 0;
X			cornline(1,line);
X		}
X		cornline(2,"");
X		(void) fclose(oracles);
X	} else {
X		pline("Can't open oracles file!");
X		oracle_size = -1;	/* don't try to open it again */
X	}
X#ifdef OS2_CODEVIEW
X	}
X#endif
X}
X
Xint
Xdoconsult(oracl)
Xregister struct monst *oracl;
X{
X	register char ans;
X
X	multi = 0;
X	(void) inshop();
X
X	if(!oracl) {
X		pline("There is no one here to consult.");
X		return(0);
X	}
X	if(!oracl->mpeaceful) {
X		pline("The Oracle is in no mood for consultations.");
X		return(0);
X	} else {
X		if(!u.ugold) {
X			You("have no money.");
X			return(0);
X		}
X		pline("\"Wilt thou settle for a minor consultation?\"  (50 zorkmids) ");
X		ans = ynq();
X		if(ans == 'y') {
X			if(u.ugold < 50) {
X			    You("don't even have enough money for that!");
X			    return(0);
X			}
X			u.ugold -= 50;
X			oracl->mgold += 50;
X			flags.botl = 1;
X			outrumor(1, FALSE);
X			return(1);
X		} else if(ans == 'q') return(0);
X		else {
X			pline("\"Then dost thou desire a major one?\"  (1000 zorkmids) ");
X			if (yn() != 'y') return(0);
X		}
X		if(u.ugold < 1000) {
X		pline("The Oracle scornfully takes all your money and says:");
Xcornline(0,NULL);
Xcornline(1,"\"...it is rather disconcerting to be confronted with the");
Xcornline(1,"following theorem from [Baker, Gill, and Solovay, 1975].");
Xcornline(1,"");
Xcornline(1,"Theorem 7.18  There exist recursive languages A and B such that");
Xcornline(1,"  (1)  P(A) == NP(A), and");
Xcornline(1,"  (2)  P(B) != NP(B)");
Xcornline(1,"");
Xcornline(1,"This provides impressive evidence that the techniques that are");
Xcornline(1,"currently available will not suffice for proving that P != NP or");
Xcornline(1,"that P == NP.\"  [Garey and Johnson, p. 185.]");
Xcornline(2,"");
X		    oracl->mgold += u.ugold;
X		    u.ugold = 0;
X		    flags.botl = 1;
X		    return(1);
X		}
X		u.ugold -= 1000;
X		oracl->mgold += 1000;
X		flags.botl = 1;
X		outoracle();
X		return(1);
X	}
X}
X
X#endif
END_OF_FILE
if test 7483 -ne `wc -c <'src/rumors.c'`; then
    echo shar: \"'src/rumors.c'\" unpacked with wrong size!
fi
# end of 'src/rumors.c'
fi
if test -f 'src/timeout.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/timeout.c'\"
else
echo shar: Extracting \"'src/timeout.c'\" \(7116 characters\)
sed "s/^X//" >'src/timeout.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)timeout.c	3.0	89/11/20
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include	"hack.h"
X
XSTATIC_DCL void NDECL(stoned_dialogue);
XSTATIC_DCL void NDECL(vomiting_dialogue);
XSTATIC_DCL void NDECL(choke_dialogue);
XSTATIC_DCL void FDECL(hatch_it, (struct obj*));
X
X#ifdef OVLB
X
X/* He is being petrified - dialogue by inmet!tower */
Xstatic const char NEARDATA *stoned_texts[] = {
X	"You are slowing down.",		/* 5 */
X	"Your limbs are stiffening.",		/* 4 */
X	"Your limbs have turned to stone.",	/* 3 */
X	"You have turned to stone.",		/* 2 */
X	"You are a statue."			/* 1 */
X};
X
XSTATIC_OVL void
Xstoned_dialogue() {
X	register long i = (Stoned & TIMEOUT);
X
X	if(i > 0 && i <= SIZE(stoned_texts))
X		pline(stoned_texts[SIZE(stoned_texts) - i]);
X	if(i == 5)
X		Fast &= ~(TIMEOUT|INTRINSIC);
X	if(i == 3)
X		nomul(-3);
X}
X
X/* He is getting sicker and sicker prior to vomiting */
Xstatic const char NEARDATA *vomiting_texts[] = {
X	"You are feeling mildly nauseous.",	/* 11 */
X	"You feel slightly confused.",		/* 8 */
X	"You can't seem to think straight.",	/* 5 */
X	"You feel incredibly sick.",		/* 2 */
X	"You suddenly vomit!"			/* 0 */
X};
X
XSTATIC_OVL void
Xvomiting_dialogue() {
X	register long i = (Vomiting & TIMEOUT) / 3L;
X
X	if(!((Vomiting & TIMEOUT) % 3L) &&
X	   i >= 0 && i < SIZE(vomiting_texts))
X		pline(vomiting_texts[SIZE(vomiting_texts) - i]);
X
X	switch((int)i) {
X
X	    case 0:	vomit(); morehungry(20); break;
X	    case 2:	make_confused(HConfusion + d(2,4), FALSE);
X	    case 3:	make_stunned(HStun + d(2,4), FALSE);
X	    default:	break;
X	}
X}
X
Xstatic const char NEARDATA *choke_texts[] = {
X	"You find it hard to breathe.",
X	"You're gasping for air.",
X	"You can no longer breathe.",
X	"You're turning %s.",
X	"You suffocate."
X};
X
XSTATIC_OVL void
Xchoke_dialogue()
X{
X	register long i = (Strangled & TIMEOUT);
X
X	if(i > 0 && i <= SIZE(choke_texts))
X		pline(choke_texts[SIZE(choke_texts) - i], Hallucination ?
X			hcolor() : blue);
X}
X
X#endif /* OVLB */
X#ifdef OVL0
X
Xvoid
Xtimeout()
X{
X	register struct prop *upp;
X	int sleeptime;
X
X	if(Stoned) stoned_dialogue();
X	if(Vomiting) vomiting_dialogue();
X	if(Strangled) choke_dialogue();
X#ifdef POLYSELF
X	if(u.mtimedone) if(!--u.mtimedone) rehumanize();
X#endif
X	if(u.ucreamed) u.ucreamed--;
X	if(u.uluck && moves % (u.uhave_amulet
X#ifdef THEOLOGY
X		|| u.ugangr
X#endif
X		? 300 : 600) == 0) {
X	/* Cursed luckstones stop bad luck from timing out; blessed luckstones
X	 * stop good luck from timing out; normal luckstones stop both;
X	 * neither is stopped if you don't have a luckstone.
X	 */
X	    register int time_luck = stone_luck(FALSE);
X	    boolean nostone = !carrying(LUCKSTONE);
X
X	    if(u.uluck > 0 && (nostone || time_luck < 0))
X		u.uluck--;
X	    else if(u.uluck < 0 && (nostone || time_luck > 0))
X		u.uluck++;
X	}
X
X	for(upp = u.uprops; upp < u.uprops+SIZE(u.uprops); upp++)
X	    if((upp->p_flgs & TIMEOUT) && !(--upp->p_flgs & TIMEOUT)) {
X		if(upp->p_tofn) (*upp->p_tofn)();
X		else switch(upp - u.uprops){
X		case STONED:
X			if (!killer) {
X				killer_format = KILLED_BY_AN;
X				killer = "cockatrice";
X			} done(STONING);
X			break;
X		case VOMITING:
X			make_vomiting(0L, TRUE);
X			break;
X		case SICK:
X			You("die from your illness.");
X			killer_format = KILLED_BY_AN;
X			killer = u.usick_cause;
X			done(POISONING);
X			break;
X		case FAST:
X			You("feel yourself slowing down.");
X			break;
X		case CONFUSION:
X			HConfusion = 1; /* So make_confused works properly */
X			make_confused(0L, TRUE);
X			break;
X		case STUN:
X			HStun = 1;
X			make_stunned(0L, TRUE);
X			break;
X		case BLINDED:
X			Blinded = 1;
X			make_blinded(0L, TRUE);
X			break;
X		case INVIS:
X			on_scr(u.ux,u.uy);
X			if (!Invis && !See_invisible)
X				You("are no longer invisible.");
X			break;
X		case WOUNDED_LEGS:
X			heal_legs();
X			break;
X		case HALLUC:
X			Hallucination = 1;
X			make_hallucinated(0L, TRUE);
X			break;
X		case SLEEPING:
X			if (unconscious() || Sleep_resistance)
X				Sleeping += rnd(100);
X			else {
X				You("fall asleep.");
X				sleeptime = rnd(20);
X				nomul(-sleeptime);
X				nomovemsg = "You wake up.";
X				Sleeping = sleeptime + rnd(100);
X			}
X			break;
X		case STRANGLED:
X			killer_format = KILLED_BY;
X			killer = "strangulation";
X			done(DIED);
X			break;
X		case FUMBLING:
X			/* call this only when a move took place.  */
X			/* otherwise handle fumbling msgs locally. */
X			if (!Levitation && u.umoved) {
X			    if (OBJ_AT(u.ux, u.uy))
X				You("trip over something.");
X			    else
X				switch (rn2(4)) {
X				    case 1:
X					if (ACCESSIBLE(levl[u.ux][u.uy].typ)) { /* not POOL or STONE */
X					    if (Hallucination) pline("A rock bites your foot.");
X					    else You("trip over a rock.");
X					    break;
X					}
X				    case 2:
X					if (Hallucination) You("slip on a banana peel.");
X					else You("slip and nearly fall.");
X					break;
X				    case 3:
X					You("flounder.");
X					break;
X				    default:
X					You("stumble.");
X				}
X			    nomul(-2);
X			    nomovemsg = "";
X			}
X			Fumbling = rnd(20);
X			break;
X		}
X	}
X}
X
X#endif /* OVL0 */
X#ifdef OVLB
X
XSTATIC_OVL void
Xhatch_it(otmp)		/* hatch the egg "otmp" if possible */
Xregister struct obj *otmp;
X{
X	register struct monst *mtmp;
X#ifdef POLYSELF
X	int yours = otmp->spe;
X#endif
X
X	if(monstermoves-otmp->age > 200)  /* very old egg - it's dead */
X	    otmp->corpsenm = -1;
X#ifdef LINT	/* long conv. ok */
X	else if(rnd(150) > 150) {
X#else
X	else if(rnd((int)(monstermoves-otmp->age)) > 150) {
X#endif
X	    mtmp = makemon(&mons[big_to_little(otmp->corpsenm)], u.ux, u.uy);
X	    useup(otmp);
X	    if(mtmp) {
X
X		if(Blind)
X		    You("feel something %s from your pack!",
X			locomotion(mtmp->data, "drop"));
X		else
X		    You("see %s %s out of your pack!",
X			an(mtmp->data->mname),
X			locomotion(mtmp->data, "drop"));
X
X#ifdef POLYSELF
X		if (yours) {
X		    struct monst *mtmp2;
X
X		    pline("Its cries sound like \"%s.\"",
X			flags.female ? "mommy" : "daddy");
X		    if (mtmp2 = tamedog(mtmp, (struct obj *)0))
X			mtmp = mtmp2;
X		    mtmp->mtame = 20;
X		    while(otmp = (mtmp->minvent)) {
X			mtmp->minvent = otmp->nobj;
X			free((genericptr_t)otmp);
X		    }
X		    return;
X		}
X#endif
X		if(mtmp->data->mlet == S_DRAGON) {
X		    struct monst *mtmp2;
X
X		    verbalize("Gleep!");		/* Mything eggs :-) */
X		    if (mtmp2 = tamedog(mtmp, (struct obj *)0))
X			mtmp = mtmp2;
X		    while(otmp = (mtmp->minvent)) {
X			mtmp->minvent = otmp->nobj;
X			free((genericptr_t)otmp);
X		    }
X		}
X	    }
X	}
X}
X
X#endif /* OVLB */
X#ifdef OVL1
X
Xvoid
Xhatch_eggs()	    /* hatch any eggs that have been too long in pack */
X{
X	register struct obj *otmp,/* *ctmp, /* use of ctmp commented out below*/
X		*otmp2;
X
X	for(otmp = invent; otmp; otmp = otmp2) {
X
X	    otmp2 = otmp->nobj;	    /* otmp may hatch */
X	    if(otmp->otyp == EGG && otmp->corpsenm >= 0) hatch_it(otmp);
X	}
X
X/*	Not yet - there's a slight problem with "useup" on contained objs.
X	for(otmp = fcobj; otmp; otmp = otmp2) {
X
X	    otmp2 = otmp->nobj;
X	    for(ctmp = invent; ctmp; ctmp = ctmp->nobj)
X		if(otmp->cobj == ctmp)
X		    if(ctmp->otyp != ICE_BOX)
X			if(otmp->otyp == EGG && otmp->corpsenm >= 0)
X			    hatch_it(otmp);
X	}
X*/
X}
X
X#endif /* OVL1 */
END_OF_FILE
if test 7116 -ne `wc -c <'src/timeout.c'`; then
    echo shar: \"'src/timeout.c'\" unpacked with wrong size!
fi
# end of 'src/timeout.c'
fi
if test -f 'src/worm.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/worm.c'\"
else
echo shar: Extracting \"'src/worm.c'\" \(7031 characters\)
sed "s/^X//" >'src/worm.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)worm.c	3.0	88/11/11
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include "hack.h"
X
X#ifdef WORM
X#include "wseg.h"
X
Xstatic void FDECL(remseg,(struct monst *,struct wseg *));
X
X/* Each tailed worm has a wormno.  This is used as an index for the following
X * arrays:
X * wsegs: the start of a a linked list of segments, located at the tail.
X * wheads: the end of a linked list of segments, located at the head.  Putting
X *	the tail of the list at the head of the worm and vice versa is an
X *	endless source of confusion, but necessary.  From now on, we will use
X *	"start" and "end" to refer to the list, and "head" and "tail" to refer
X *	to the worm.
X * wgrowtime: obvious.
X *
X * When a worm is moved, we add a new segment at the head (end of the list)
X * and (unless we want it to grow) delete the segment at the tail (beginning
X * of the list).  This new head segment is located in the same square as
X * the actual head of the worm (thus requiring a special case when setting
X * level.monsters upon worm movement).  If we do want to grow the worm, we
X * don't delete the tail segment, and we give the worm extra hit points,
X * which possibly go into its maximum.
X *
X * Non-moving worms (worm_nomove) shrink instead of grow as their tails keep
X * going while their heads are stopped short.  Delete the tail segment,
X * and remove hit points from the worm.
X */
Xstruct wseg *wsegs[32] = DUMMY, *wheads[32] = DUMMY, *m_atseg = 0;
Xlong wgrowtime[32] = DUMMY;
X
Xint
Xgetwn(mtmp)
Xstruct monst *mtmp;
X{
X	register int tmp;
X
X	for(tmp = 1; tmp < 32; tmp++)
X	    if(!wsegs[tmp]) {
X		mtmp->wormno = tmp;
X		return(1);
X	    }
X	return(0);	/* level infested with worms */
X}
X
X/* called to initialize a worm unless cut in half */
Xvoid
Xinitworm(mtmp)
Xstruct monst *mtmp;
X{
X	register struct wseg *wtmp;
X	register int tmp = mtmp->wormno;
X
X	if(!tmp) return;
X	wheads[tmp] = wsegs[tmp] = wtmp = newseg();
X	wgrowtime[tmp] = 0;
X	wtmp->wx = mtmp->mx;
X	wtmp->wy = mtmp->my;
X/*	wtmp->wdispl = 0; */
X	wtmp->nseg = 0;
X}
X
Xstatic void
Xremseg(mtmp,wtmp)
Xstruct monst *mtmp;
Xregister struct wseg *wtmp;
X{
X	if (mtmp->mx != wtmp->wx || mtmp->my != wtmp->wy)
X		remove_monster(wtmp->wx, wtmp->wy);
X	if(wtmp->wdispl) newsym(wtmp->wx, wtmp->wy);
X	free((genericptr_t) wtmp);
X}
X
Xvoid
Xworm_move(mtmp)
Xstruct monst *mtmp;
X{
X	register struct wseg *wtmp, *whd;
X	register int tmp = mtmp->wormno;
X
X	wtmp = newseg();
X	wtmp->wx = mtmp->mx;
X	wtmp->wy = mtmp->my;
X	wtmp->nseg = 0;
X/*	wtmp->wdispl = 0; */
X	(whd = wheads[tmp])->nseg = wtmp;
X	wheads[tmp] = wtmp;
X	if(cansee(whd->wx,whd->wy)){
X		unpmon(mtmp);
X		atl(whd->wx, whd->wy, S_WORM_TAIL);
X		whd->wdispl = 1;
X	} else	whd->wdispl = 0;
X	if(wgrowtime[tmp] <= moves) {
X		if(!wgrowtime[tmp]) wgrowtime[tmp] = moves + rnd(5);
X		else wgrowtime[tmp] = wgrowtime[tmp]+2+rnd(15);
X		mtmp->mhp += 3;
X		if (mtmp->mhp > MHPMAX) mtmp->mhp = MHPMAX;
X		if (mtmp->mhp > mtmp->mhpmax) mtmp->mhpmax = mtmp->mhp;
X		return;
X	}
X	whd = wsegs[tmp];
X	wsegs[tmp] = whd->nseg;
X	remseg(mtmp, whd);
X}
X
Xvoid
Xworm_nomove(mtmp)
Xregister struct monst *mtmp;
X{
X	register int tmp;
X	register struct wseg *wtmp;
X
X	tmp = mtmp->wormno;
X	wtmp = wsegs[tmp];
X	if(wtmp == wheads[tmp]) return;
X	if(wtmp == 0 || wtmp->nseg == 0) panic("worm_nomove?");
X	wsegs[tmp] = wtmp->nseg;
X	remseg(mtmp, wtmp);
X	if (mtmp->mhp > 3) mtmp->mhp -= 3;	/* mhpmax not changed ! */
X	else mtmp->mhp = 1;
X}
X
Xvoid
Xwormdead(mtmp)
Xregister struct monst *mtmp;
X{
X	register int tmp = mtmp->wormno;
X	register struct wseg *wtmp, *wtmp2;
X
X	if(!tmp) return;
X	mtmp->wormno = 0;
X	for(wtmp = wsegs[tmp]; wtmp; wtmp = wtmp2) {
X		wtmp2 = wtmp->nseg;
X		remseg(mtmp, wtmp);
X	}
X	wsegs[tmp] = 0;
X}
X
Xvoid
Xwormhit(mtmp)
Xregister struct monst *mtmp;
X{
X	register int tmp = mtmp->wormno;
X	register struct wseg *wtmp;
X
X	if(!tmp) return;	/* worm without tail */
X	for(wtmp = wsegs[tmp]; wtmp; wtmp = wtmp->nseg)
X		if (dist(wtmp->wx, wtmp->wy) < 3) (void) mattacku(mtmp);
X}
X
Xvoid
Xwormsee(tmp)
Xregister unsigned int tmp;
X{
X	register struct wseg *wtmp = wsegs[tmp];
X
X	if(!wtmp) panic("wormsee: wtmp==0");
X
X	for(; wtmp->nseg; wtmp = wtmp->nseg)
X		if(!cansee(wtmp->wx,wtmp->wy) && wtmp->wdispl) {
X			newsym(wtmp->wx, wtmp->wy);
X			wtmp->wdispl = 0;
X		}
X		else if (cansee(wtmp->wx, wtmp->wy) && !wtmp->wdispl) {
X			atl(wtmp->wx, wtmp->wy, S_WORM_TAIL);
X			wtmp->wdispl = 1;
X		}
X}
X
Xvoid
Xcutworm(mtmp, x, y, weptyp)
Xstruct monst *mtmp;
Xxchar x,y;
Xunsigned weptyp;		/* uwep->otyp or 0 */
X{
X	register struct wseg *wtmp, *wtmp2;
X	struct monst *mtmp2;
X	int tmp, tmp2;
X
X	if(mtmp->mx == x && mtmp->my == y) return;	/* hit headon */
X
X	/* cutting goes best with axe or sword */
X	tmp = rnd(20);
X	if(weptyp >= SHORT_SWORD && weptyp <= KATANA ||
X	   weptyp == AXE)
X		tmp += 5;
X
X	if(tmp < 12) return;
X
X	/* if tail then worm just loses a tail segment */
X	tmp = mtmp->wormno;
X	wtmp = wsegs[tmp];
X	if(wtmp->wx == x && wtmp->wy == y){
X		wsegs[tmp] = wtmp->nseg;
X		remseg(mtmp, wtmp);
X		return;
X	}
X
X	/* cut the worm in two halves */
X	mtmp2 = newmonst(0);
X	*mtmp2 = *mtmp;
X	mtmp2->mxlth = mtmp2->mnamelth = 0;
X
X	/* sometimes the tail end dies */
X	if(rn2(3) || !getwn(mtmp2)){
X		monfree(mtmp2);
X		place_worm_seg(mtmp, mtmp2->mx, mtmp2->my);
X			/* since mtmp is still on that spot */
X		tmp2 = 0;
X	} else {
X		tmp2 = mtmp2->wormno;
X		wsegs[tmp2] = wsegs[tmp];
X		wgrowtime[tmp2] = 0;
X	}
X	/* do-loop: go from the tail to the head.  Segments close to the tail
X	 * either die or become part of worm 2.  We stop at the hit segment
X	 * and this loop never goes down the entire length of the worm.
X	 */
X	do {
X	    /* The segment immediately next to (tailwards) the one hit, */
X	    /* becoes the head of the new second worm.  Note: at this point, */
X	    /* wtmp->nseg is the one you hit, wtmp is immediately tailwards, */
X	    /* and wtmp->nseg->nseg is immediately headwards. */
X	    if(wtmp->nseg->wx == x && wtmp->nseg->wy == y){
X		if(tmp2) wheads[tmp2] = wtmp;
X		wsegs[tmp] = wtmp->nseg->nseg;
X		remseg(mtmp, wtmp->nseg);
X		wtmp->nseg = 0;
X		if(tmp2) {
X		    kludge("You cut %s in half.", mon_nam(mtmp));
X		/* devalue the monster level of both halves of the worm */
X		    mtmp->m_lev = (mtmp->m_lev <= 3) ? 2 : mtmp->m_lev - 2;
X		    mtmp2->m_lev = mtmp->m_lev;
X		/* calculate the mhp on the new (lower) monster level */
X		    mtmp2->mhpmax = mtmp2->mhp = d((int)mtmp2->m_lev, 8);
X		    place_monster(mtmp2, wtmp->wx, wtmp->wy);
X		    mtmp2->nmon = fmon;
X		    fmon = mtmp2;
X		    mtmp2->mdispl = 0;
X		    pmon(mtmp2);
X		} else {
X			if (Blind) You("cut off part of its tail.");
X			else You("cut off part of %s's tail.", mon_nam(mtmp));
X			remseg(mtmp, wtmp);
X		}
X		mtmp->mhp /= 2;
X		return;
X	    }
X	/* Worm segments which are closer to the tail than the one you hit, */
X	/* get either deleted or transferred from the old to new worms */
X	    wtmp2 = wtmp->nseg;
X	    if(!tmp2) remseg(mtmp, wtmp);
X	    else place_worm_seg(mtmp2, wtmp->wx, wtmp->wy);
X	    wtmp = wtmp2;
X	} while(wtmp->nseg);
X	panic("Cannot find worm segment");
X}
X
X#endif /* WORM /**/
END_OF_FILE
if test 7031 -ne `wc -c <'src/worm.c'`; then
    echo shar: \"'src/worm.c'\" unpacked with wrong size!
fi
# end of 'src/worm.c'
fi
echo shar: End of archive 50 \(of 56\).
cp /dev/null ark50isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 56 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
    echo Building monst.c from monst.c1 and monst.c2
    cat src/monst.c1 src/monst.c2 > src/monst.c
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
