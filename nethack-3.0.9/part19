Path: utzoo!utgpu!news-server.csri.toronto.edu!cs.utexas.edu!wuarchive!mit-eddie!uw-beaver!zephyr.ens.tek.com!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v10i064:  nethack3p9 -  display oriented dungeons & dragons (Ver. 3.0i), Part19/56
Message-ID: <5920@tekred.CNA.TEK.COM>
Date: 12 Jul 90 00:36:10 GMT
Sender: news@tekred.CNA.TEK.COM
Lines: 2435
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 10, Issue 64
Archive-name: nethack3p9/Part19
Supersedes: NetHack3: Volume 7, Issue 56-93



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 19 (of 56)."
# Contents:  src/do_wear.c src/panic.c vms/vmstermcap.c
# Wrapped by billr@saab on Wed Jul 11 17:11:17 1990
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'src/do_wear.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/do_wear.c'\"
else
echo shar: Extracting \"'src/do_wear.c'\" \(36025 characters\)
sed "s/^X//" >'src/do_wear.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)do_wear.c	3.0	88/05/10
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include "hack.h"
X
X#ifdef OVLB
X
Xstatic int NEARDATA todelay;
X
X#endif /*OVLB */
X
X#ifndef OVLB
X
XSTATIC_DCL long takeoff_mask, taking_off;
X
X#else /* OVLB */
X
XSTATIC_OVL long NEARDATA takeoff_mask = 0L, NEARDATA taking_off = 0L;
X
Xstatic const long NEARDATA takeoff_order[] = { WORN_BLINDF, 1L, /* weapon */
X	WORN_SHIELD, WORN_GLOVES, LEFT_RING, RIGHT_RING, WORN_CLOAK,
X	WORN_HELMET, WORN_AMUL, WORN_ARMOR,
X#ifdef SHIRT
X	WORN_SHIRT,
X#endif
X	WORN_BOOTS, 0L };
X
Xstatic void FDECL(on_msg, (struct obj *));
XSTATIC_PTR int NDECL(Armor_on);
XSTATIC_PTR int NDECL(Boots_on);
Xstatic int NDECL(Cloak_on);
XSTATIC_PTR int NDECL(Helmet_on);
XSTATIC_PTR int NDECL(Gloves_on);
Xstatic void NDECL(Amulet_on);
Xstatic void FDECL(Ring_off_or_gone, (struct obj *, BOOLEAN_P));
XSTATIC_PTR int FDECL(select_off, (struct obj *));
Xstatic struct obj *NDECL(do_takeoff);
XSTATIC_PTR int NDECL(take_off);
X
Xvoid
Xoff_msg(otmp) register struct obj *otmp; {
X	if(flags.verbose)
X	    You("were wearing %s.", doname(otmp));
X}
X
X/* for items that involve no delay */
Xstatic void
Xon_msg(otmp) register struct obj *otmp; {
X	if(flags.verbose)
X	    You("are now wearing %s.", an(xname(otmp)));
X}
X
X#endif /* OVLB */
X#ifdef OVL2
X
Xboolean
Xis_boots(otmp) register struct obj *otmp; {
X	return(otmp->otyp >= LOW_BOOTS &&
X	   	otmp->otyp <= LEVITATION_BOOTS);
X}
X
Xboolean
Xis_helmet(otmp) register struct obj *otmp; {
X#ifdef TOLKIEN
X	return(otmp->otyp >= ELVEN_LEATHER_HELM &&
X		otmp->otyp <= HELM_OF_TELEPATHY);
X#else
X	return(otmp->otyp >= ORCISH_HELM &&
X		otmp->otyp <= HELM_OF_TELEPATHY);
X#endif
X}
X
X#endif /* OVLB */
X#ifdef OVL2
X
Xboolean
Xis_gloves(otmp) register struct obj *otmp; {
X	return(otmp->otyp >= LEATHER_GLOVES &&
X	   	otmp->otyp <= GAUNTLETS_OF_DEXTERITY);
X}
X
X#endif /* OVL2 */
X#ifdef OVLB
X
Xboolean
Xis_cloak(otmp) register struct obj *otmp; {
X	return(otmp->otyp >= MUMMY_WRAPPING &&
X		otmp->otyp <= CLOAK_OF_DISPLACEMENT);
X}
X
Xboolean
Xis_shield(otmp) register struct obj *otmp; {
X	return(otmp->otyp >= SMALL_SHIELD &&
X	   	otmp->otyp <= SHIELD_OF_REFLECTION);
X}
X
X/*
X * The Type_on() functions should be called *after* setworn().
X * The Type_off() functions call setworn() themselves.
X */
X
XSTATIC_PTR
Xint
XBoots_on() {
X    long oldprop =
X		u.uprops[objects[uarmf->otyp].oc_oprop].p_flgs & ~(WORN_BOOTS | TIMEOUT);
X
X    switch(uarmf->otyp) {
X	case LOW_BOOTS:
X	case IRON_SHOES:
X	case HIGH_BOOTS:
X	case WATER_WALKING_BOOTS:
X	case JUMPING_BOOTS:
X		break;
X	case SPEED_BOOTS:
X		if (!oldprop) {
X			makeknown(uarmf->otyp);
X			You("feel yourself speed up.");
X		}
X		break;
X	case ELVEN_BOOTS:
X		if (!oldprop) {
X			makeknown(uarmf->otyp);
X			You("walk very quietly.");
X		}
X		break;
X	case FUMBLE_BOOTS:
X		if (!oldprop)
X			Fumbling += rnd(20);
X		break;
X	case LEVITATION_BOOTS:
X		if (!oldprop) {
X			makeknown(uarmf->otyp);
X			float_up();
X		}
X		break;
X	default: impossible("Unknown type of boots (%d)", uarmf->otyp);
X    }
X    return 0;
X}
X
Xint
XBoots_off() {
X    register struct obj *obj = uarmf;
X	/* For levitation, float_down() returns if Levitation, so we
X	 * must do a setworn() _before_ the levitation case.
X	 */
X    long oldprop =
X		u.uprops[objects[uarmf->otyp].oc_oprop].p_flgs & ~(WORN_BOOTS | TIMEOUT);
X
X    setworn((struct obj *)0, W_ARMF);
X    switch(obj->otyp) {
X	case SPEED_BOOTS:
X		if (!oldprop) {
X			makeknown(obj->otyp);
X			You("feel yourself slow down.");
X		}
X		break;
X	case WATER_WALKING_BOOTS:
X		if(is_pool(u.ux,u.uy) && !Levitation
X#ifdef POLYSELF
X		    && !is_flyer(uasmon)
X#endif
X		    ) {
X			makeknown(obj->otyp);
X			/* make boots known in case you survive the drowning */
X			drown();
X		}
X		break;
X	case ELVEN_BOOTS:
X		if (!oldprop) {
X			makeknown(obj->otyp);
X			You("sure are noisy.");
X		}
X		break;
X	case FUMBLE_BOOTS:
X		if (!oldprop)
X			Fumbling = 0;
X		break;
X	case LEVITATION_BOOTS:
X		if (!oldprop) {
X			(void) float_down();
X			makeknown(obj->otyp);
X		}
X		break;
X	case LOW_BOOTS:
X	case IRON_SHOES:
X	case HIGH_BOOTS:
X	case JUMPING_BOOTS:
X		break;
X	default: impossible("Unknown type of boots (%d)", obj->otyp);
X    }
X    return 0;
X}
X
Xstatic int
XCloak_on() {
X    long oldprop = u.uprops[objects[uarmc->otyp].oc_oprop].p_flgs & ~WORN_CLOAK;
X
X    switch(uarmc->otyp) {
X	case ELVEN_CLOAK:
X	case CLOAK_OF_PROTECTION:
X	case CLOAK_OF_DISPLACEMENT:
X		makeknown(uarmc->otyp);
X		break;
X	case MUMMY_WRAPPING:
X#ifdef TOLKIEN
X	case ORCISH_CLOAK:
X	case DWARVISH_CLOAK:
X#endif
X	case CLOAK_OF_MAGIC_RESISTANCE:
X		break;
X	case CLOAK_OF_INVISIBILITY:
X		if (!oldprop && !See_invisible && !Blind) {
X			makeknown(uarmc->otyp);
X			pline("Suddenly you cannot see yourself.");
X		}
X		break;
X	default: impossible("Unknown type of cloak (%d)", uarmc->otyp);
X    }
X    return 0;
X}
X
Xint
XCloak_off() {
X    long oldprop = u.uprops[objects[uarmc->otyp].oc_oprop].p_flgs & ~WORN_CLOAK;
X
X    switch(uarmc->otyp) {
X	case MUMMY_WRAPPING:
X	case ELVEN_CLOAK:
X#ifdef TOLKIEN
X	case ORCISH_CLOAK:
X	case DWARVISH_CLOAK:
X#endif
X	case CLOAK_OF_PROTECTION:
X	case CLOAK_OF_MAGIC_RESISTANCE:
X	case CLOAK_OF_DISPLACEMENT:
X		break;
X	case CLOAK_OF_INVISIBILITY:
X		if (!oldprop && !See_invisible && !Blind) {
X			makeknown(uarmc->otyp);
X			pline("Suddenly you can see yourself.");
X		}
X		break;
X	default: impossible("Unknown type of cloak (%d)", uarmc->otyp);
X    }
X    setworn((struct obj *)0, W_ARMC);
X    return 0;
X}
X
XSTATIC_PTR
Xint
XHelmet_on() {
X    switch(uarmh->otyp) {
X	case FEDORA:
X	case HELMET:
X#ifdef TOLKIEN
X	case ELVEN_LEATHER_HELM:
X	case DWARVISH_IRON_HELM:
X#endif
X	case ORCISH_HELM:
X	case HELM_OF_TELEPATHY:
X		break;
X	case HELM_OF_BRILLIANCE:
X		if (uarmh->spe) {
X			ABON(A_INT) += uarmh->spe;
X			ABON(A_WIS) += uarmh->spe;
X			flags.botl = 1;
X			makeknown(uarmh->otyp);
X		}
X		break;
X	case HELM_OF_OPPOSITE_ALIGNMENT:
X		if (u.ualigntyp == U_NEUTRAL) u.ualigntyp = rn2(2) ? -1 : 1;
X		else u.ualigntyp = -(u.ualigntyp);
X		makeknown(uarmh->otyp);
X		flags.botl = 1;
X		break;
X	default: impossible("Unknown type of helm (%d)", uarmh->otyp);
X    }
X    return 0;
X}
X
Xint
XHelmet_off() {
X    switch(uarmh->otyp) {
X	case FEDORA:
X	case HELMET:
X#ifdef TOLKIEN
X	case ELVEN_LEATHER_HELM:
X	case DWARVISH_IRON_HELM:
X#endif
X	case ORCISH_HELM:
X	case HELM_OF_TELEPATHY:
X		break;
X	case HELM_OF_BRILLIANCE:
X		if (uarmh->spe) {
X			ABON(A_INT) -= uarmh->spe;
X			ABON(A_WIS) -= uarmh->spe;
X			flags.botl = 1;
X		}
X		break;
X	case HELM_OF_OPPOSITE_ALIGNMENT:
X#ifdef THEOLOGY
X		u.ualigntyp = u.ualignbase[0];
X#else
X		if (pl_character[0] == 'P' ||
X		    pl_character[0] == 'T' ||
X		    pl_character[0] == 'W')
X			u.ualigntyp = U_NEUTRAL;
X		else u.ualigntyp = -(u.ualigntyp);
X#endif
X		flags.botl = 1;
X		break;
X	default: impossible("Unknown type of helm (%d)", uarmh->otyp);
X    }
X    setworn((struct obj *)0, W_ARMH);
X    return 0;
X}
X
XSTATIC_PTR
Xint
XGloves_on() {
X    long oldprop =
X	u.uprops[objects[uarmg->otyp].oc_oprop].p_flgs & ~(WORN_GLOVES | TIMEOUT);
X
X    switch(uarmg->otyp) {
X	case LEATHER_GLOVES:
X		break;
X	case GAUNTLETS_OF_FUMBLING:
X		if (!oldprop)
X			Fumbling += rnd(20);
X		break;
X	case GAUNTLETS_OF_POWER:
X		makeknown(uarmg->otyp);
X		flags.botl = 1; /* taken care of in attrib.c */
X		break;
X	case GAUNTLETS_OF_DEXTERITY:
X		if (uarmg->spe) makeknown(uarmg->otyp);
X		ABON(A_DEX) += uarmg->spe;
X		flags.botl = 1;
X		break;
X	default: impossible("Unknown type of gloves (%d)", uarmg->otyp);
X    }
X    return 0;
X}
X
Xint
XGloves_off() {
X    long oldprop =
X	u.uprops[objects[uarmg->otyp].oc_oprop].p_flgs & ~(WORN_GLOVES | TIMEOUT);
X
X    switch(uarmg->otyp) {
X	case LEATHER_GLOVES:
X		break;
X	case GAUNTLETS_OF_FUMBLING:
X		if (!oldprop)
X			Fumbling = 0;
X		break;
X	case GAUNTLETS_OF_POWER:
X		makeknown(uarmg->otyp);
X		flags.botl = 1; /* taken care of in attrib.c */
X		break;
X	case GAUNTLETS_OF_DEXTERITY:
X		if (uarmg->spe) makeknown(uarmg->otyp);
X		ABON(A_DEX) -= uarmg->spe;
X		flags.botl = 1;
X		break;
X	default: impossible("Unknown type of gloves (%d)", uarmg->otyp);
X    }
X    setworn((struct obj *)0, W_ARMG);
X    if (uwep && uwep->otyp == CORPSE && uwep->corpsenm == PM_COCKATRICE) {
X	/* Prevent wielding cockatrice when not wearing gloves */
X	You("wield the cockatrice corpse in your bare %s.",
X	    makeplural(body_part(HAND)));
X	You("turn to stone...");
X	killer_format = KILLED_BY_AN;
X	killer = "cockatrice corpse";
X	done(STONING);
X    }
X    return 0;
X}
X
X/*
Xstatic int
XShield_on() {
X    switch(uarms->otyp) {
X	case SMALL_SHIELD:
X#ifdef TOLKIEN
X	case ELVEN_SHIELD:
X	case URUK_HAI_SHIELD:
X	case ORCISH_SHIELD:
X	case DWARVISH_ROUNDSHIELD:
X#endif
X	case LARGE_SHIELD:
X	case SHIELD_OF_REFLECTION:
X		break;
X	default: impossible("Unknown type of shield (%d)", uarms->otyp);
X    }
X    return 0;
X}
X*/
X
Xint
XShield_off() {
X/*
X    switch(uarms->otyp) {
X	case SMALL_SHIELD:
X#ifdef TOLKIEN
X	case ELVEN_SHIELD:
X	case URUK_HAI_SHIELD:
X	case ORCISH_SHIELD:
X	case DWARVISH_ROUNDSHIELD:
X#endif
X	case LARGE_SHIELD:
X	case SHIELD_OF_REFLECTION:
X		break;
X	default: impossible("Unknown type of shield (%d)", uarms->otyp);
X    }
X*/
X    setworn((struct obj *)0, W_ARMS);
X    return 0;
X}
X
X/* This must be done in worn.c, because one of the possible intrinsics conferred
X * is fire resistance, and we have to immediately set HFire_resistance in worn.c
X * since worn.c will check it before returning.
X */
XSTATIC_PTR
Xint
XArmor_on()
X{
X    return 0;
X}
X
Xint
XArmor_off()
X{
X    setworn((struct obj *)0, W_ARM);
X    return 0;
X}
X
X/* The gone functions differ from the off functions in that if you die from
X * taking it off and have life saving, you still die.
X */
Xint
XArmor_gone()
X{
X    setnotworn(uarm);
X    return 0;
X}
X
Xstatic void
XAmulet_on()
X{
X    char buf[BUFSZ];
X
X    switch(uamul->otyp) {
X	case AMULET_OF_ESP:
X	case AMULET_OF_LIFE_SAVING:
X	case AMULET_VERSUS_POISON:
X	case AMULET_OF_REFLECTION:
X		break;
X	case AMULET_OF_CHANGE:
X		makeknown(AMULET_OF_CHANGE);
X		flags.female = !flags.female;
X		max_rank_sz();
X		/* Don't use same message as polymorph */
X		You("are suddenly very %s!", flags.female ? "feminine"
X			: "masculine");
X		if (pl_character[0]=='P')
X			Strcpy(pl_character+6, flags.female? "ess":"");
X		if (pl_character[0]=='C')
X			Strcpy(pl_character+5, flags.female ? "woman" : "man");
X#ifdef WIZARD
X		if (!wizard) {
X#endif
Xnewname:	more();
X		do {
X		    pline("What shall you be called, %s? ",
X			flags.female ? "madam" : "sir");
X		    getlin(buf);
X		} while (buf[0]=='\033' || buf[0]==0);
X		if (!strcmp(plname,buf)) {
X		    pline("Sorry, that name no longer seems appropriate!");
X		    goto newname;
X		}
X		flags.botl = 1;
X		(void)strncpy(plname, buf, sizeof(plname)-1);
X#ifdef VMS
X		Sprintf(SAVEF, "[.save]%d%s", getuid(), plname);
X		regularize(SAVEF+7);
X		Strcat(SAVEF, ";1");
X#else
X# ifdef MSDOS
X		(void)strcpy(SAVEF, SAVEP);
X		{
X			int i = strlen(SAVEF);
X			(void)strncat(SAVEF, plname, 8);
X			regularize(SAVEF+i);
X		}
X		(void)strcat(SAVEF, ".sav");
X# else
X		Sprintf(SAVEF, "save/%d%s", getuid(), plname);
X		regularize(SAVEF+5);		/* avoid . or / in name */
X# endif
X#endif
X#ifdef WIZARD
X		}
X#endif
X		pline("The amulet disintegrates!");
X		useup(uamul);
X		break;
X	case AMULET_OF_STRANGULATION:
X		makeknown(AMULET_OF_STRANGULATION);
X		pline("It constricts your throat!");
X		Strangled = 6;
X		break;
X	case AMULET_OF_RESTFUL_SLEEP:
X		Sleeping = rnd(100);
X		break;
X	case AMULET_OF_YENDOR:
X		break;
X    }
X}
X
Xvoid
XAmulet_off()
X{
X    switch(uamul->otyp) {
X	case AMULET_OF_ESP:
X	case AMULET_OF_LIFE_SAVING:
X	case AMULET_VERSUS_POISON:
X	case AMULET_OF_REFLECTION:
X		break;
X	case AMULET_OF_CHANGE:
X		impossible("Wearing an amulet of change?");
X		break;
X	case AMULET_OF_STRANGULATION:
X		if (Strangled) {
X			You("can breathe more easily!");
X			Strangled = 0;
X		}
X		break;
X	case AMULET_OF_RESTFUL_SLEEP:
X		Sleeping = 0;
X		break;
X	case AMULET_OF_YENDOR:
X		break;
X    }
X    setworn((struct obj *)0, W_AMUL);
X}
X
Xvoid
XRing_on(obj)
Xregister struct obj *obj;
X{
X    long oldprop = u.uprops[objects[obj->otyp].oc_oprop].p_flgs & ~W_RING;
X
X    switch(obj->otyp){
X	case RIN_TELEPORTATION:
X	case RIN_REGENERATION:
X	case RIN_SEARCHING:
X	case RIN_STEALTH:
X	case RIN_HUNGER:
X	case RIN_AGGRAVATE_MONSTER:
X	case RIN_POISON_RESISTANCE:
X	case RIN_FIRE_RESISTANCE:
X	case RIN_COLD_RESISTANCE:
X	case RIN_SHOCK_RESISTANCE:
X	case RIN_CONFLICT:
X	case RIN_WARNING:
X	case RIN_TELEPORT_CONTROL:
X#ifdef POLYSELF
X	case RIN_POLYMORPH:
X	case RIN_POLYMORPH_CONTROL:
X#endif
X		break;
X	case RIN_SEE_INVISIBLE:
X		if (Invis && !oldprop
X#ifdef POLYSELF
X				&& !perceives(uasmon)
X#endif
X							&& !Blind) {
X			newsym(u.ux,u.uy);
X			pline("Suddenly you can see yourself.");
X			makeknown(RIN_SEE_INVISIBLE);
X		}
X		break;
X	case RIN_INVISIBILITY:
X		if (!oldprop && !See_invisible && !Blind) {
X			makeknown(RIN_INVISIBILITY);
X			Your("body takes on a %s transparency...",
X				Hallucination ? "normal" : "strange");
X		}
X		break;
X	case RIN_ADORNMENT:
X		ABON(A_CHA) += obj->spe;
X		flags.botl = 1;
X		if (obj->spe || objects[RIN_ADORNMENT].oc_name_known) {
X			makeknown(RIN_ADORNMENT);
X			obj->known = 1;
X		}
X		break;
X	case RIN_LEVITATION:
X		if(!oldprop) {
X			float_up();
X			makeknown(RIN_LEVITATION);
X			obj->known = 1;
X		}
X		break;
X	case RIN_GAIN_STRENGTH:
X		ABON(A_STR) += obj->spe;
X		flags.botl = 1;
X		if (obj->spe || objects[RIN_GAIN_STRENGTH].oc_name_known) {
X			makeknown(RIN_GAIN_STRENGTH);
X			obj->known = 1;
X		}
X		break;
X	case RIN_INCREASE_DAMAGE:
X		u.udaminc += obj->spe;
X		break;
X	case RIN_PROTECTION_FROM_SHAPE_CHAN:
X		rescham();
X		break;
X	case RIN_PROTECTION:
X		flags.botl = 1;
X		if (obj->spe || objects[RIN_PROTECTION].oc_name_known) {
X			makeknown(RIN_PROTECTION);
X			obj->known = 1;
X		}
X		break;
X    }
X}
X
Xstatic void
XRing_off_or_gone(obj,gone)
Xregister struct obj *obj;
Xboolean gone;
X{
X    register long mask = obj->owornmask & W_RING;
X
X    if(!(u.uprops[objects[obj->otyp].oc_oprop].p_flgs & mask))
X	impossible("Strange... I didn't know you had that ring.");
X    if(gone) setnotworn(obj);
X    else setworn((struct obj *)0, obj->owornmask);
X    switch(obj->otyp) {
X	case RIN_TELEPORTATION:
X	case RIN_REGENERATION:
X	case RIN_SEARCHING:
X	case RIN_STEALTH:
X	case RIN_HUNGER:
X	case RIN_AGGRAVATE_MONSTER:
X	case RIN_POISON_RESISTANCE:
X	case RIN_FIRE_RESISTANCE:
X	case RIN_COLD_RESISTANCE:
X	case RIN_SHOCK_RESISTANCE:
X	case RIN_CONFLICT:
X	case RIN_WARNING:
X	case RIN_TELEPORT_CONTROL:
X#ifdef POLYSELF
X	case RIN_POLYMORPH:
X	case RIN_POLYMORPH_CONTROL:
X#endif
X		break;
X	case RIN_SEE_INVISIBLE:
X		if (Invisible && !Blind) {
X			pline("Suddenly you cannot see yourself.");
X			makeknown(RIN_SEE_INVISIBLE);
X		}
X		break;
X	case RIN_INVISIBILITY:
X		if (!(Invisible & ~W_RING) && !See_invisible && !Blind) {
X			Your("body seems to unfade...");
X			makeknown(RIN_INVISIBILITY);
X		}
X		break;
X	case RIN_ADORNMENT:
X		ABON(A_CHA) -= obj->spe;
X		flags.botl = 1;
X		break;
X	case RIN_LEVITATION:
X		(void) float_down();
X		if (!Levitation) makeknown(RIN_LEVITATION);
X		break;
X	case RIN_GAIN_STRENGTH:
X		ABON(A_STR) -= obj->spe;
X		flags.botl = 1;
X		break;
X	case RIN_INCREASE_DAMAGE:
X		u.udaminc -= obj->spe;
X		break;
X	case RIN_PROTECTION_FROM_SHAPE_CHAN:
X		/* If you're no longer protected, let the chameleons
X		 * change shape again -dgk
X		 */
X		restartcham();
X		break;
X    }
X}
X
Xvoid
XRing_off(obj)
Xstruct obj *obj;
X{
X	Ring_off_or_gone(obj,FALSE);
X}
X
Xvoid
XRing_gone(obj)
Xstruct obj *obj;
X{
X	Ring_off_or_gone(obj,TRUE);
X}
X
Xvoid
XBlindf_on(otmp) 
Xregister struct obj *otmp;
X{
X	setworn(otmp, W_TOOL);
X	on_msg(otmp);
X	seeoff(0);
X}
X
Xvoid
XBlindf_off(otmp) 
Xregister struct obj *otmp;
X{
X	setworn((struct obj *)0, otmp->owornmask);
X	off_msg(otmp);
X	if (!Blinded)	make_blinded(1L,FALSE); /* See on next move */
X	else		You("still cannot see.");
X}
X
X/* called in main to set intrinsics of worn start-up items */
Xvoid
Xset_wear() {
X	if (uarm)  (void) Armor_on();
X	if (uarmc) (void) Cloak_on();
X	if (uarmf) (void) Boots_on();
X	if (uarmg) (void) Gloves_on();
X	if (uarmh) (void) Helmet_on();
X/*	if (uarms) (void) Shield_on(); */
X}
X
Xboolean
Xdonning(otmp)
Xregister struct obj *otmp;
X{
X    return (otmp == uarmf && (afternmv == Boots_on || afternmv == Boots_off))
X	|| (otmp == uarmh && (afternmv == Helmet_on || afternmv == Helmet_off))
X	|| (otmp == uarmg && (afternmv == Gloves_on || afternmv == Gloves_off))
X	|| (otmp == uarm && (afternmv == Armor_on || afternmv == Armor_off));
X}
X
Xvoid
Xcancel_don()
X{
X	/* the piece of armor we were donning/doffing has vanished, so stop
X	 * wasting time on it (and don't dereference it when donning would
X	 * otherwise finish)
X	 */
X	afternmv = 0;
X	nomovemsg = NULL;
X	multi = 0;
X}
X
Xstatic const char NEARDATA clothes[] = {ARMOR_SYM, 0};
Xstatic const char NEARDATA accessories[] = {RING_SYM, AMULET_SYM, TOOL_SYM, 0};
X
Xint
Xdotakeoff() {
X#ifdef __GNULINT__
X	register struct obj *otmp = 0;
X		/* suppress "may be used uninitialized" warning */
X#else
X	register struct obj *otmp;
X#endif
X	int armorpieces = 0;
X
X#define MOREARM(x) if (x) { armorpieces++; otmp = x; }
X	MOREARM(uarmh);
X	MOREARM(uarms);
X	MOREARM(uarmg);
X	MOREARM(uarmf);
X	if (uarmc) {
X		armorpieces++;
X		otmp = uarmc;
X	} else if (uarm) {
X		armorpieces++;
X		otmp = uarm;
X#ifdef SHIRT
X	} else if (uarmu) {
X		armorpieces++;
X		otmp = uarmu;
X#endif
X	}
X	if (!armorpieces) {
X		pline("Not wearing any armor.");
X		return 0;
X	}
X	if (armorpieces > 1)
X		otmp = getobj(clothes, "take off");
X	if (otmp == 0) return(0);
X	if (!(otmp->owornmask & W_ARMOR)) {
X		You("are not wearing that.");
X		return(0);
X	}
X	if (((otmp == uarm) && (uarmc))
X#ifdef SHIRT
X				|| ((otmp == uarmu) && (uarmc || uarm))
X#endif
X								) {
X		You("can't take that off.");
X		return(0);
X	}
X	if(otmp == uarmg && welded(uwep)) {
X    You("seem unable to take off the gloves while holding your %s.",
X	  is_sword(uwep) ? "sword" : "weapon");
X		uwep->bknown = 1;
X		return(0);
X	}
X	if(otmp == uarmg && Glib) {
X    You("can't remove the slippery gloves with your slippery fingers.");
X		return(0);
X	}
X	if(otmp == uarmf && u.utrap && u.utraptype == TT_BEARTRAP) {  /* -3. */
X		pline("The bear trap prevents you from pulling your foot out.");
X		return(0);
X	}
X	reset_remarm();			/* since you may change ordering */
X	(void) armoroff(otmp);
X	return(1);
X}
X
Xint
Xdoremring() {
X#ifdef __GNULINT__
X	register struct obj *otmp = 0;
X		/* suppress "may be used uninitialized" warning */
X#else
X	register struct obj *otmp;
X#endif
X	int Accessories = 0;
X
X#define MOREACC(x) if (x) { Accessories++; otmp = x; }
X	MOREACC(uleft);
X	MOREACC(uright);
X	MOREACC(uamul);
X	MOREACC(ublindf);
X
X	if(!Accessories) {
X		pline("Not wearing any accessories.");
X		return(0);
X	}
X	if (Accessories != 1) otmp = getobj(accessories, "take off");
X	if(!otmp) return(0);
X	if(!(otmp->owornmask & (W_RING | W_AMUL | W_TOOL))) {
X		You("are not wearing that.");
X		return(0);
X	}
X	if(cursed(otmp)) return(0);
X	if(otmp->olet == RING_SYM) {
X#ifdef POLYSELF
X		if (nolimbs(uasmon)) {
X			pline("It seems to be stuck.");
X			return(0);
X		}
X#endif
X		if (uarmg && uarmg->cursed) {
X			uarmg->bknown = 1;
XYou("seem unable to remove your ring without taking off your gloves.");
X			return(0);
X		}
X		if (welded(uwep) && bimanual(uwep)) {
X			uwep->bknown = 1;
XYou("seem unable to remove the ring while your hands hold your %s.",
X				is_sword(uwep) ? "sword" : "weapon");
X			return(0);
X		}
X		if (welded(uwep) && otmp==uright) {
X			uwep->bknown = 1;
XYou("seem unable to remove the ring while your right hand holds your %s.",
X				is_sword(uwep) ? "sword" : "weapon");
X			return(0);
X		}
X		/* Sometimes we want to give the off_msg before removing and
X		 * sometimes after; for instance, "you were wearing a moonstone
X		 * ring (on right hand)" is desired but "you were wearing a
X		 * square amulet (being worn)" is not because of the redundant
X		 * "being worn".
X		 */
X		off_msg(otmp);
X		Ring_off(otmp);
X	} else if(otmp->olet == AMULET_SYM) {
X		Amulet_off();
X		off_msg(otmp);
X	} else Blindf_off(otmp); /* does its own off_msg */
X	return(1);
X}
X
Xint
Xcursed(otmp) register struct obj *otmp; {
X	/* Curses, like chickens, come home to roost. */
X	if(otmp->cursed){
X		You("can't.  %s to be cursed.",
X			(is_boots(otmp) || is_gloves(otmp) || otmp->quan > 1)
X			? "They seem" : "It seems");
X		otmp->bknown = 1;
X		return(1);
X	}
X	return(0);
X}
X
Xint
Xarmoroff(otmp) register struct obj *otmp; {
X	register int delay = -objects[otmp->otyp].oc_delay;
X
X	if(cursed(otmp)) return(0);
X	if(delay) {
X		nomul(delay);
X		if (is_helmet(otmp)) {
X			nomovemsg = "You finish taking off your helmet.";
X			afternmv = Helmet_off;
X		     }
X		else if (is_gloves(otmp)) {
X			nomovemsg = "You finish taking off your gloves.";
X			afternmv = Gloves_off;
X		     }
X		else if (is_boots(otmp)) {
X			nomovemsg = "You finish taking off your boots.";
X			afternmv = Boots_off;
X		     }
X		else {
X			nomovemsg = "You finish taking off your suit.";
X			afternmv = Armor_off;
X		}
X	} else {
X		/* Be warned!  We want off_msg after removing the item to
X		 * avoid "You were wearing ____ (being worn)."  However, an
X		 * item which grants fire resistance might cause some trouble
X		 * if removed in Hell and lifesaving puts it back on; in this
X		 * case the message will be printed at the wrong time (after
X		 * the messages saying you died and were lifesaved).  Luckily,
X		 * no cloak, shield, or fast-removable armor grants fire
X		 * resistance, so we can safely do the off_msg afterwards.
X		 * Rings do grant fire resistance, but for rings we want the
X		 * off_msg before removal anyway so there's no problem.  Take
X		 * care in adding armors granting fire resistance; this code
X		 * might need modification.
X		 */
X		if(is_cloak(otmp))
X			(void) Cloak_off();
X		else if(is_shield(otmp))
X			(void) Shield_off();
X		else setworn((struct obj *)0, otmp->owornmask & W_ARMOR);
X		off_msg(otmp);
X	}
X	takeoff_mask = taking_off = 0L;
X	return(1);
X}
X
Xint
Xdowear() {
X	register struct obj *otmp;
X	register int delay;
X	register int err = 0;
X	long mask = 0;
X
X#ifdef POLYSELF
X	/* cantweararm checks for suits of armor */
X	/* verysmall or nohands checks for shields, gloves, etc... */
X	if ((verysmall(uasmon) || nohands(uasmon))) {
X		pline("Don't even bother.");
X		return(0);
X	}
X#endif
X	otmp = getobj(clothes, "wear");
X	if(!otmp) return(0);
X#ifdef POLYSELF
X	if (cantweararm(uasmon) && !is_shield(otmp) &&
X			!is_helmet(otmp) && !is_gloves(otmp) &&
X			!is_boots(otmp)) {
X		pline("The %s will not fit on your body.",
X			is_cloak(otmp) ? "cloak" :
X# ifdef SHIRT
X			otmp->otyp == HAWAIIAN_SHIRT ? "shirt" :
X# endif
X			"suit");
X		return(0);
X	}
X#endif
X	if(otmp->owornmask & W_ARMOR) {
X		You("are already wearing that!");
X		return(0);
X	}
X	if(is_helmet(otmp)) {
X		if(uarmh) {
X			You("are already wearing a helmet.");
X			err++;
X		} else
X			mask = W_ARMH;
X	} else if(is_shield(otmp)){
X		if(uarms) {
X			You("are already wearing a shield.");
X			err++;
X		}
X		if(uwep && bimanual(uwep)) {
X		You("cannot hold a shield and wield a two-handed %s.",
X		      is_sword(uwep) ? "sword" : "weapon");
X			err++;
X		}
X		if(!err) mask = W_ARMS;
X	} else if(is_boots(otmp)) {
X		   if(uarmf) {
X			You("are already wearing boots.");
X			err++;
X		   } else
X			mask = W_ARMF;
X	} else if(is_gloves(otmp)) {
X		if(uarmg) {
X			You("are already wearing gloves.");
X			err++;
X		} else
X		if(uwep && uwep->cursed) {
X			You("cannot wear gloves over your %s.",
X			      is_sword(uwep) ? "sword" : "weapon");
X			err++;
X		} else
X			mask = W_ARMG;
X#ifdef SHIRT
X	} else if( otmp->otyp == HAWAIIAN_SHIRT ) {
X		if (uarm || uarmc || uarmu) {
X			if(!uarm && !uarmc) /* then uarmu */
X			   You("are already wearing a shirt.");
X			else
X			   You("can't wear that over your %s.",
X				 (uarm && !uarmc) ? "armor" : "cloak");
X			err++;
X		} else
X			mask = W_ARMU;
X#endif
X	} else if(is_cloak(otmp)) {
X		if(uarmc) {
X			You("are already wearing a cloak.");
X			err++;
X		} else
X			mask = W_ARMC;
X	} else {
X		if(uarmc) {
X			You("cannot wear armor over a cloak.");
X			err++;
X		} else if(uarm) {
X			You("are already wearing some armor.");
X			err++;
X		}
X		if(!err) mask = W_ARM;
X	}
X/* Unnecessary since now only weapons and special items like pick-axes get
X * welded to your hand, not armor
X	if(welded(otmp)) {
X		if(!err++)
X			weldmsg(otmp, FALSE);
X	}
X */
X	if(err) return(0);
X
X	otmp->known = 1;
X	if(otmp == uwep)
X		setuwep((struct obj *)0);
X	setworn(otmp, mask);
X	delay = -objects[otmp->otyp].oc_delay;
X	if(delay){
X		nomul(delay);
X		if(is_boots(otmp)) afternmv = Boots_on;
X		if(is_helmet(otmp)) afternmv = Helmet_on;
X		if(is_gloves(otmp)) afternmv = Gloves_on;
X		if(otmp == uarm) afternmv = Armor_on;
X		nomovemsg = "You finish your dressing maneuver.";
X	} else {
X		if(is_cloak(otmp)) (void) Cloak_on();
X/*		if(is_shield(otmp)) (void) Shield_on(); */
X		on_msg(otmp);
X	}
X	takeoff_mask = taking_off = 0L;
X	return(1);
X}
X
Xint
Xdoputon() {
X	register struct obj *otmp;
X	long mask = 0;
X
X	if(uleft && uright && uamul && ublindf) {
X#ifdef POLYSELF
X		Your("%s%s are full, and you're already wearing an amulet and a blindfold.",
X			(humanoid(uasmon) || u.usym==S_CENTAUR) ? "ring-" : "",
X			makeplural(body_part(FINGER)));
X#else
X		Your("ring-fingers are full, and you're already wearing an amulet and a blindfold.");
X#endif
X		return(0);
X	}
X	otmp = getobj(accessories, "wear");
X	if(!otmp) return(0);
X	if(otmp->owornmask & (W_RING | W_AMUL | W_TOOL)) {
X		You("are already wearing that!");
X		return(0);
X	}
X	if(welded(otmp)) {
X		weldmsg(otmp, TRUE);
X		return(0);
X	}
X	if(otmp == uwep)
X		setuwep((struct obj *)0);
X	if(otmp->olet == RING_SYM) {
X#ifdef POLYSELF
X		if(nolimbs(uasmon)) {
X			You("cannot make the ring stick to your body.");
X			return(0);
X		}
X#endif
X		if(uleft && uright){
X#ifdef POLYSELF
X			pline("There are no more %s%s to fill.",
X				(humanoid(uasmon) || u.usym==S_CENTAUR)
X					? "ring-" : "",
X				makeplural(body_part(FINGER)));
X#else
X			pline("There are no more ring-fingers to fill.");
X#endif
X			return(0);
X		}
X		if(uleft) mask = RIGHT_RING;
X		else if(uright) mask = LEFT_RING;
X		else do {
X			char answer;
X
X#ifdef POLYSELF
X			pline("What %s%s, Right or Left? ",
X				(humanoid(uasmon) || u.usym==S_CENTAUR)
X					? "ring-" : "",
X				body_part(FINGER));
X#else
X			pline("What ring-finger, Right or Left? ");
X#endif
X			if(index(quitchars, (answer = readchar())))
X				return(0);
X			switch(answer){
X			case 'l':
X			case 'L':
X				mask = LEFT_RING;
X				break;
X			case 'r':
X			case 'R':
X				mask = RIGHT_RING;
X				break;
X			}
X		} while(!mask);
X		if (uarmg && uarmg->cursed) {
X			uarmg->bknown = 1;
X		    You("cannot remove your gloves to put on the ring.");
X			return(0);
X		}
X		if (welded(uwep) && bimanual(uwep)) {
X			/* welded will set bknown */
X	    You("cannot free your weapon hands to put on the ring.");
X			return(0);
X		}
X		if (welded(uwep) && mask==RIGHT_RING) {
X			/* welded will set bknown */
X	    You("cannot free your weapon hand to put on the ring.");
X			return(0);
X		}
X		setworn(otmp, mask);
X		Ring_on(otmp);
X	} else if (otmp->olet == AMULET_SYM) {
X		if(uamul) {
X			You("are already wearing an amulet.");
X			return(0);
X		}
X		setworn(otmp, W_AMUL);
X		if (otmp->otyp == AMULET_OF_CHANGE) {
X			Amulet_on();
X			/* Don't do a prinv() since the amulet is now gone */
X			return(1);
X		}
X		Amulet_on();
X	} else {	/* it's a blindfold */
X		if (ublindf) {
X			You("are already wearing a blindfold.");
X			return(0);
X		}
X		if (otmp->otyp != BLINDFOLD) {
X			You("can't wear that!");
X			return(0);
X		}
X		Blindf_on(otmp);
X		return(1);
X	}
X	prinv(otmp);
X	return(1);
X}
X
X#endif /* OVLB */
X
X#define ARM_BONUS(obj)	((10 - objects[obj->otyp].a_ac) + obj->spe)
X
X#ifdef OVL0
X
Xvoid
Xfind_ac() {
X	register int uac = 10;
X#ifdef POLYSELF
X	if (u.mtimedone) uac = mons[u.umonnum].ac;
X#endif
X	if(uarm) uac -= ARM_BONUS(uarm);
X	if(uarmc) uac -= ARM_BONUS(uarmc);
X	if(uarmh) uac -= ARM_BONUS(uarmh);
X	if(uarmf) uac -= ARM_BONUS(uarmf);
X	if(uarms) uac -= ARM_BONUS(uarms);
X	if(uarmg) uac -= ARM_BONUS(uarmg);
X#ifdef SHIRT
X	if(uarmu) uac -= ARM_BONUS(uarmu);
X#endif
X	if(uleft && uleft->otyp == RIN_PROTECTION) uac -= uleft->spe;
X	if(uright && uright->otyp == RIN_PROTECTION) uac -= uright->spe;
X#ifdef THEOLOGY
X	if (Protection & INTRINSIC) uac -= u.ublessed;
X#endif
X	if(uac != u.uac){
X		u.uac = uac;
X		flags.botl = 1;
X	}
X}
X
X#endif /* OVL0 */
X#ifdef OVLB
X
Xvoid
Xglibr()
X{
X	register struct obj *otmp;
X	int xfl = 0;
X#ifdef HARD
X	boolean leftfall, rightfall;
X
X	leftfall = (uleft && !uleft->cursed && (!uwep || !uwep->cursed
X		|| !bimanual(uwep)));
X	rightfall = (uright && !uright->cursed && (!uwep || !uwep->cursed));
X#else
X#define leftfall uleft
X#define rightfall uright
X#endif
X	if(!uarmg) if(leftfall || rightfall)
X#ifdef POLYSELF
X				if(!nolimbs(uasmon))
X#endif
X						{
X		/* Note: at present also cursed rings fall off */
X		/* changed 10/30/86 by GAN */
X		Your("%s off your %s.",
X			(leftfall && rightfall) ? "rings slip" : "ring slips",
X			makeplural(body_part(FINGER)));
X		xfl++;
X		if(leftfall) {
X			otmp = uleft;
X			Ring_off(uleft);
X			dropx(otmp);
X		}
X		if(rightfall) {
X			otmp = uright;
X			Ring_off(uright);
X			dropx(otmp);
X		}
X	}
X	if(((otmp = uwep) != (struct obj *)0)
X#ifdef HARD
X	   && !otmp->cursed
X#endif
X	) {
X		/* Note: at present also cursed weapons fall */
X		/* changed 10/30/86 by GAN */
X		Your("%s %sslips from your %s.",
X			is_sword(uwep) ? "sword" : "weapon",
X			xfl ? "also " : "",
X			makeplural(body_part(HAND)));
X		setuwep((struct obj *)0);
X		dropx(otmp);
X	}
X}
X
Xstruct obj *
Xsome_armor(){
Xregister struct obj *otmph = (uarmc ? uarmc : uarm);
X	if(uarmh && (!otmph || !rn2(4))) otmph = uarmh;
X	if(uarmg && (!otmph || !rn2(4))) otmph = uarmg;
X	if(uarmf && (!otmph || !rn2(4))) otmph = uarmf;
X	if(uarms && (!otmph || !rn2(4))) otmph = uarms;
X#ifdef SHIRT
X	if(!uarm && !uarmc && uarmu && (!otmph || !rn2(4))) otmph = uarmu;
X#endif
X	return(otmph);
X}
X
Xvoid
Xcorrode_armor(){
Xregister struct obj *otmph = some_armor();
X
X	if (otmph && otmph != uarmf) {
X	    if (otmph->rustfree || objects[otmph->otyp].oc_material != METAL ||
X		otmph->otyp >= LEATHER_ARMOR) {
X			Your("%s not affected!",
X				aobjnam(otmph, "are"));
X			return;
X	    }
X	    Your("%s!", aobjnam(otmph, "corrode"));
X	    otmph->spe--;
X	    adj_abon(otmph, -1);
X	}
X}
X
XSTATIC_PTR
Xint
Xselect_off(otmp)
Xregister struct obj *otmp;
X{
X	if(!otmp) return(0);
X	if(cursed(otmp)) return(0);
X#ifdef POLYSELF
X	if(otmp->olet==RING_SYM && nolimbs(uasmon)) return(0);
X#endif
X	if(welded(uwep) && (otmp==uarmg || otmp==uright || (otmp==uleft
X			&& bimanual(uwep))))
X		return(0);
X	if(uarmg && uarmg->cursed && (otmp==uright || otmp==uleft)) {
X		uarmg->bknown = 1;
X		return(0);
X	}
X	if((otmp==uarm 
X#ifdef SHIRT
X			|| otmp==uarmu
X#endif
X					) && uarmc && uarmc->cursed) {
X		uarmc->bknown = 1;
X		return(0);
X	}
X#ifdef SHIRT
X	if(otmp==uarmu && uarm && uarm->cursed) {
X		uarm->bknown = 1;
X		return(0);
X	}
X#endif
X
X	if(otmp == uarm) takeoff_mask |= WORN_ARMOR;
X	else if(otmp == uarmc) takeoff_mask |= WORN_CLOAK;
X	else if(otmp == uarmf) takeoff_mask |= WORN_BOOTS;
X	else if(otmp == uarmg) takeoff_mask |= WORN_GLOVES;
X	else if(otmp == uarmh) takeoff_mask |= WORN_HELMET;
X	else if(otmp == uarms) takeoff_mask |= WORN_SHIELD;
X#ifdef SHIRT
X	else if(otmp == uarmu) takeoff_mask |= WORN_SHIRT;
X#endif
X	else if(otmp == uleft) takeoff_mask |= LEFT_RING;
X	else if(otmp == uright) takeoff_mask |= RIGHT_RING;
X	else if(otmp == uamul) takeoff_mask |= WORN_AMUL;
X	else if(otmp == ublindf) takeoff_mask |= WORN_BLINDF;
X	else if(otmp == uwep) takeoff_mask |= 1L;	/* WIELDED_WEAPON */
X
X	else impossible("select_off: %s???", doname(otmp));
X
X	return(0);
X}
X
Xstatic struct obj *
Xdo_takeoff() {
X
X	register struct obj *otmp = 0;
X
X	if (taking_off == 1L) { /* weapon */
X	  if(!cursed(uwep)) {
X	    setuwep((struct obj *) 0);
X	    You("are empty %s.", body_part(HANDED));
X	  }
X	} else if (taking_off ==  WORN_ARMOR) {
X	  otmp = uarm;
X	  if(!cursed(otmp)) (void) Armor_off();
X	} else if (taking_off == WORN_CLOAK) {
X	  otmp = uarmc;
X	  if(!cursed(otmp)) (void) Cloak_off();
X	} else if (taking_off == WORN_BOOTS) {
X	  otmp = uarmf;
X	  if(!cursed(otmp)) (void) Boots_off();
X	} else if (taking_off == WORN_GLOVES) {
X	  otmp = uarmg;
X	  if(!cursed(otmp)) (void) Gloves_off();
X	} else if (taking_off == WORN_HELMET) {
X	  otmp = uarmh;
X	  if(!cursed(otmp)) (void) Helmet_off();
X	} else if (taking_off == WORN_SHIELD) {
X	  otmp = uarms;
X	  if(!cursed(otmp)) (void) Shield_off();
X#ifdef SHIRT
X	} else if (taking_off == WORN_SHIRT) {
X	  otmp = uarmu;
X	  if(!cursed(otmp))
X	    setworn((struct obj *)0, uarmu->owornmask & W_ARMOR);
X#endif
X	} else if (taking_off == WORN_AMUL) {
X	  otmp = uamul;
X	  if(!cursed(otmp)) Amulet_off();
X	} else if (taking_off == LEFT_RING) {
X	  otmp = uleft;
X	  if(!cursed(otmp)) Ring_off(uleft);
X	} else if (taking_off == RIGHT_RING) {
X	  otmp = uright;
X	  if(!cursed(otmp)) Ring_off(uright);
X	} else if (taking_off == WORN_BLINDF) {
X	  if(!cursed(ublindf)) {
X	    setworn((struct obj *)0, ublindf->owornmask);
X	    if(!Blinded) make_blinded(1L,FALSE); /* See on next move */
X	    else	 You("still cannot see.");
X	  }
X	} else impossible("do_takeoff: taking off %lx", taking_off);
X
X	return(otmp);
X}
X
XSTATIC_PTR
Xint
Xtake_off() {
X
X	register int i;
X	register struct obj *otmp;
X
X	if(taking_off) {
X	    if(todelay > 0) {
X
X		todelay--;
X		return(1);	/* still busy */
X	    } else if((otmp = do_takeoff())) off_msg(otmp);
X
X	    takeoff_mask &= ~taking_off;
X	    taking_off = 0L;
X	}
X
X	for(i = 0; takeoff_order[i]; i++)
X	    if(takeoff_mask & takeoff_order[i]) {
X
X		taking_off = takeoff_order[i];
X		break;
X	    }
X
X	otmp = (struct obj *) 0;
X
X	if (taking_off == 0L) {
X	  You("finish disrobing.");
X	  return 0;
X	} else if (taking_off == 1L) {
X	  todelay = 1;
X	} else if (taking_off == WORN_ARMOR) {
X	  otmp = uarm;
X	} else if (taking_off == WORN_CLOAK) {
X	  otmp = uarmc;
X	} else if (taking_off == WORN_BOOTS) {
X	  otmp = uarmf;
X	} else if (taking_off == WORN_GLOVES) {
X	  otmp = uarmg;
X	} else if (taking_off == WORN_HELMET) {
X	  otmp = uarmh;
X	} else if (taking_off == WORN_SHIELD) {
X	  otmp = uarms;
X#ifdef SHIRT
X	} else if (taking_off == WORN_SHIRT) {
X	  otmp = uarmu;
X#endif
X	} else if (taking_off == WORN_AMUL) {
X	  todelay = 1;
X	} else if (taking_off == LEFT_RING) {
X	  todelay = 1;
X	} else if (taking_off == RIGHT_RING) {
X	  todelay = 1;
X	} else if (taking_off == WORN_BLINDF) {
X	  todelay = 2;
X	} else {
X	  impossible("take_off: taking off %lx", taking_off);
X	  return 0;	/* force done */
X	}
X
X	if(otmp) todelay = objects[otmp->otyp].oc_delay;
X	set_occupation(take_off, "disrobing", 0);
X	return(1);		/* get busy */
X}
X
X#endif /* OVLB */
X#ifdef OVL1
X
Xvoid
Xreset_remarm() { taking_off = takeoff_mask =0L; }
X
X#endif /* OVL1 */
X#ifdef OVLB
X
Xint
Xdoddoremarm() {
X
X	if(taking_off || takeoff_mask) {
X
X	    You("continue disrobing.");
X	    set_occupation(take_off, "disrobing", 0);
X	    return(take_off());
X	}
X
X	(void) ggetobj("take off", select_off, 0);
X	if(takeoff_mask) return(take_off());
X	else		 return(0);
X}
X
Xint
Xdestroy_arm(atmp)
Xregister struct obj *atmp;
X{
X	register struct obj *otmp;
X
X	if((otmp = uarmc) && (!atmp || atmp == uarmc)) {
X		Your("cloak crumbles and turns to dust!");
X		(void) Cloak_off();
X		useup(otmp);
X	} else if((otmp = uarm) && (!atmp || atmp == uarm)) {
X		/* may be disintegrated by spell or dragon breath... */
X		if (donning(otmp)) cancel_don();
X		Your("armor turns to dust and falls to the floor!");
X		(void) Armor_gone();
X		useup(otmp);
X#ifdef SHIRT
X	} else if((otmp = uarmu) && (!atmp || atmp == uarmu)) {
X		Your("shirt crumbles into tiny threads and falls apart!");
X		useup(otmp);
X#endif
X	} else if((otmp = uarmh) && (!atmp || atmp == uarmh)) {
X		if (donning(otmp)) cancel_don();
X		Your("helmet turns to dust and is blown away!");
X		(void) Helmet_off();
X		useup(otmp);
X	} else if((otmp = uarmg) && (!atmp || atmp == uarmg)) {
X		if (donning(otmp)) cancel_don();
X		Your("gloves vanish!");
X		(void) Gloves_off();
X		useup(otmp);
X		selftouch("You");
X	} else if((otmp = uarmf) && (!atmp || atmp == uarmf)) {
X		if (donning(otmp)) cancel_don();
X		Your("boots disintegrate!");
X		(void) Boots_off();
X		useup(otmp);
X	} else if((otmp =uarms) && (!atmp || atmp == uarms)) {
X		Your("shield crumbles away!");
X		(void) Shield_off();
X		useup(otmp);
X	} else 	return(0);		/* could not destroy anything */
X
X	return(1);
X}
X
Xvoid
Xadj_abon(otmp, delta)
Xregister struct obj *otmp;
Xregister schar delta;
X{
X	if (uarmg && otmp->otyp == GAUNTLETS_OF_DEXTERITY) {
X		ABON(A_DEX) += (delta);
X		flags.botl = 1;
X	}
X	if (uarmh && otmp->otyp == HELM_OF_BRILLIANCE) {
X		ABON(A_INT) += (delta);
X		ABON(A_WIS) += (delta);
X		flags.botl = 1;
X	}
X}
X
X#endif /* OVLB */
END_OF_FILE
if test 36025 -ne `wc -c <'src/do_wear.c'`; then
    echo shar: \"'src/do_wear.c'\" unpacked with wrong size!
fi
# end of 'src/do_wear.c'
fi
if test -f 'src/panic.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/panic.c'\"
else
echo shar: Extracting \"'src/panic.c'\" \(892 characters\)
sed "s/^X//" >'src/panic.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)panic.c	3.0	89/11/15
X * Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985.
X *
X *	This code was adapted from the code in end.c to run in a standalone
X *	mode for the makedefs / drg code.
X */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#define NEED_VARARGS
X#include	"config.h"
X
X#ifdef MSDOS
X#undef exit
Xextern void FDECL(exit, (int));
X#endif
X#ifdef AZTEC
X#define abort() exit()
X#endif
X 
X/*VARARGS1*/
Xboolean panicking;
X
Xvoid
Xpanic VA_DECL(char *,str)
X	VA_START(str);
X	VA_INIT(str, char *);
X	if(panicking++)
X#ifdef SYSV
X	    (void)
X#endif
X		abort();    /* avoid loops - this should never happen*/
X
X	(void) fputs(" ERROR:  ", stderr);
X	Vprintf(str,VA_ARGS);
X	(void) fflush(stderr);
X#if defined(UNIX) || defined(VMS)
X# ifdef SYSV
X		(void)
X# endif
X		    abort();	/* generate core dump */
X#endif
X	VA_END();
X	exit(1);		/* redundant */
X	return;
X}
END_OF_FILE
if test 892 -ne `wc -c <'src/panic.c'`; then
    echo shar: \"'src/panic.c'\" unpacked with wrong size!
fi
# end of 'src/panic.c'
fi
if test -f 'vms/vmstermcap.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vms/vmstermcap.c'\"
else
echo shar: Extracting \"'vms/vmstermcap.c'\" \(18405 characters\)
sed "s/^X//" >'vms/vmstermcap.c' <<'END_OF_FILE'
X/* Work-alike for termcap, plus extra features.
X   Copyright (C) 1985, 1986 Free Software Foundation, Inc.
X
X		       NO WARRANTY
X
X  BECAUSE THIS PROGRAM IS LICENSED FREE OF CHARGE, WE PROVIDE ABSOLUTELY
XNO WARRANTY, TO THE EXTENT PERMITTED BY APPLICABLE STATE LAW.  EXCEPT
XWHEN OTHERWISE STATED IN WRITING, FREE SOFTWARE FOUNDATION, INC,
XRICHARD M. STALLMAN AND/OR OTHER PARTIES PROVIDE THIS PROGRAM "AS IS"
XWITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
XBUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
XFITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY
XAND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE PROGRAM PROVE
XDEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR
XCORRECTION.
X
X IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW WILL RICHARD M.
XSTALLMAN, THE FREE SOFTWARE FOUNDATION, INC., AND/OR ANY OTHER PARTY
XWHO MAY MODIFY AND REDISTRIBUTE THIS PROGRAM AS PERMITTED BELOW, BE
XLIABLE TO YOU FOR DAMAGES, INCLUDING ANY LOST PROFITS, LOST MONIES, OR
XOTHER SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
XUSE OR INABILITY TO USE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR
XDATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY THIRD PARTIES OR
XA FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS) THIS
XPROGRAM, EVEN IF YOU HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH
XDAMAGES, OR FOR ANY CLAIM BY ANY OTHER PARTY.
X
X		GENERAL PUBLIC LICENSE TO COPY
X
X  1. You may copy and distribute verbatim copies of this source file
Xas you receive it, in any medium, provided that you conspicuously and
Xappropriately publish on each copy a valid copyright notice "Copyright
X(C) 1986 Free Software Foundation, Inc."; and include following the
Xcopyright notice a verbatim copy of the above disclaimer of warranty
Xand of this License.  You may charge a distribution fee for the
Xphysical act of transferring a copy.
X
X  2. You may modify your copy or copies of this source file or
Xany portion of it, and copy and distribute such modifications under
Xthe terms of Paragraph 1 above, provided that you also do the following:
X
X    a) cause the modified files to carry prominent notices stating
X    that you changed the files and the date of any change; and
X
X    b) cause the whole of any work that you distribute or publish,
X    that in whole or in part contains or is a derivative of this
X    program or any part thereof, to be licensed at no charge to all
X    third parties on terms identical to those contained in this
X    License Agreement (except that you may choose to grant more extensive
X    warranty protection to some or all third parties, at your option).
X
X    c) You may charge a distribution fee for the physical act of
X    transferring a copy, and you may at your option offer warranty
X    protection in exchange for a fee.
X
XMere aggregation of another unrelated program with this program (or its
Xderivative) on a volume of a storage or distribution medium does not bring
Xthe other program under the scope of these terms.
X
X  3. You may copy and distribute this program (or a portion or derivative
Xof it, under Paragraph 2) in object code or executable form under the terms
Xof Paragraphs 1 and 2 above provided that you also do one of the following:
X
X    a) accompany it with the complete corresponding machine-readable
X    source code, which must be distributed under the terms of
X    Paragraphs 1 and 2 above; or,
X
X    b) accompany it with a written offer, valid for at least three
X    years, to give any third party free (except for a nominal
X    shipping charge) a complete machine-readable copy of the
X    corresponding source code, to be distributed under the terms of
X    Paragraphs 1 and 2 above; or,
X
X    c) accompany it with the information you received as to where the
X    corresponding source code may be obtained.  (This alternative is
X    allowed only for noncommercial distribution and only if you
X    received the program in object code or executable form alone.)
X
XFor an executable file, complete source code means all the source code for
Xall modules it contains; but, as a special exception, it need not include
Xsource code for modules which are standard libraries that accompany the
Xoperating system on which the executable file runs.
X
X  4. You may not copy, sublicense, distribute or transfer this program
Xexcept as expressly provided under this License Agreement.  Any attempt
Xotherwise to copy, sublicense, distribute or transfer this program is void and
Xyour rights to use the program under this License agreement shall be
Xautomatically terminated.  However, parties who have received computer
Xsoftware programs from you with this License Agreement will not have
Xtheir licenses terminated so long as such parties remain in full compliance.
X
X  5. If you wish to incorporate parts of this program into other free
Xprograms whose distribution conditions are different, write to the Free
XSoftware Foundation at 675 Mass Ave, Cambridge, MA 02139.  We have not yet
Xworked out a simple rule that can be stated here, but we will often permit
Xthis.  We will be guided by the two goals of preserving the free status of
Xall derivatives of our free software and of promoting the sharing and reuse of
Xsoftware.
X
X
XIn other words, you are welcome to use, share and improve this program.
XYou are forbidden to forbid anyone else to use, share and improve
Xwhat you give them.   Help stamp out software-hoarding!  */
X
X
X
X/* BUFSIZE is the initial size allocated for the buffer
X   for reading the termcap file.
X   It is not a limit.
X   Make it large normally for speed.
X   Make it variable when debugging, so can exercise
X   increasing the space dynamically.  */
X
X#ifdef emacs
X#include "config.h"
X#endif
X
X#ifndef BUFSIZE
X#ifdef DEBUG
X#define BUFSIZE bufsize
X
Xint bufsize = 128;
X#else
X#define BUFSIZE 2048
X#endif
X#endif
X
X#ifndef emacs
Xstatic
Xmemory_out ()
X{
X  write (2, "Virtual memory exhausted\n", 25);
X  exit (1);
X}
X
Xstatic int
Xxmalloc (size)
X     int size;
X{
X  register tem = malloc (size);
X  if (!tem)
X    memory_out ();
X  return tem;
X}
X
Xstatic int
Xxrealloc (ptr, size)
X     int ptr;
X     int size;
X{
X  register tem = realloc (ptr, size);
X  if (!tem)
X    memory_out ();
X  return tem;
X}
X#endif /* not emacs */
X
X/* Looking up capabilities in the entry already found */
X
X/* The pointer to the data made by tgetent is left here
X   for tgetnum, tgetflag and tgetstr to find.  */
X
Xstatic char *term_entry;
X
Xstatic char *tgetst1 ();
X
X/* This is the main subroutine that is used to search
X   an entry for a particular capability */
X
Xstatic char *
Xfind_capability (bp, cap)
X     register char *bp, *cap;
X{
X  for (; *bp; bp++)
X    if (bp[0] == ':'
X	&& bp[1] == cap[0]
X	&& bp[2] == cap[1])
X      return &bp[4];
X  return 0;
X}
X
Xint
Xtgetnum (cap)
X     char *cap;
X{
X  register char *ptr = find_capability (term_entry, cap);
X  if (!ptr || ptr[-1] != '#')
X    return -1;
X  return atoi (ptr);
X}
X
Xint
Xtgetflag (cap)
X     char *cap;
X{
X  register char *ptr = find_capability (term_entry, cap);
X  return 0 != ptr && ptr[-1] == ':';
X}
X
X/* Look up a string-valued capability `cap'.
X   If `area' is nonzero, it points to a pointer to a block in which
X   to store the string.  That pointer is advanced over the space used.
X   If `area' is zero, space is allocated with `malloc'.  */
X
Xchar *
Xtgetstr (cap, area)
X     char *cap;
X     char **area;
X{
X  register char *ptr = find_capability (term_entry, cap);
X  if (!ptr || (ptr[-1] != '=' && ptr[-1] != '~'))
X    return 0;
X  return tgetst1 (ptr, area);
X}
X
X/* Table, indexed by a character in range 0100 to 0140 with 0100 subtracted,
X   gives meaning of character following \, or a space if no special meaning.
X   Eight characters per line within the string.  */
X
Xstatic char esctab[]
X  = " \007\010  \033\014 \
X      \012 \
X  \015 \011 \013 \
X        ";
X
X/* Given a pointer to a string value inside a termcap entry (`ptr'),
X   copy the value and process \ and ^ abbreviations.
X   Copy into block that *area points to,
X   or to newly allocated storage if area is 0.  */
X
Xstatic char *
Xtgetst1 (ptr, area)
X     char *ptr;
X     char **area;
X{
X  register char *p, *r;
X  register int c;
X  register int size;
X  char *ret;
X  register int c1;
X
X  if (!ptr)
X    return 0;
X
X  /* `ret' gets address of where to store the string */
X  if (!area)
X    {
X      /* Compute size of block needed (may overestimate) */
X      p = ptr;
X      while ((c = *p++) && c != ':' && c != '\n');
X      ret = (char *) xmalloc (p - ptr + 1);
X    }
X  else
X    ret = *area;
X
X  /* Copy the string value, stopping at null or colon.  */
X  /* Also process ^ and \ abbreviations.  */
X  p = ptr;
X  r = ret;
X  while ((c = *p++) && c != ':' && c != '\n')
X    {
X      if (c == '^')
X	c = *p++ & 037;
X      else if (c == '\\')
X	{
X	  c = *p++;
X	  if (c >= '0' && c <= '7')
X	    {
X	      c -= '0';
X	      size = 0;
X
X	      while (++size < 3 && (c1 = *p) >= '0' && c1 <= '7')
X		{
X		  c *= 8;
X		  c += c1 - '0';
X		  p++;
X		}
X	    }
X	  else if (c >= 0100 && c < 0200)
X	    {
X	      c1 = esctab[(c & ~040) - 0100];
X	      if (c1 != ' ')
X		c = c1;
X	    }
X	}
X      *r++ = c;
X    }
X  *r = 0;
X  /* Update *area */
X  if (area)
X    *area = r + 1;
X  return ret;
X}
X
X/* Outputting a string with padding */
X
Xshort ospeed;
Xchar PC;
X
X/* Actual baud rate if positive;
X   - baud rate / 100 if negative.  */
X
Xstatic short speeds[] =
X  {
X#ifdef VMS
X    0, 50, 75, 110, 134, 150, -3, -6, -12, -18,
X    -20, -24, -36, -48, -72, -96, -192
X#else /* not VMS */
X    0, 50, 75, 110, 135, 150, -2, -3, -6, -12,
X    -18, -24, -48, -96, -192, -384
X#endif /* not VMS */
X  };
X
Xtputs (string, nlines, outfun)
X     register char *string;
X     int nlines;
X     register int (*outfun) ();
X{
X  register int padcount = 0;
X
X  if (string == (char *) 0)
X    return;
X  while (*string >= '0' && *string <= '9')
X    {
X      padcount += *string++ - '0';
X      padcount *= 10;
X    }
X  if (*string == '.')
X    {
X      string++;
X      padcount += *string++ - '0';
X    }
X  if (*string == '*')
X    {
X      string++;
X      padcount *= nlines;
X    }
X  while (*string)
X    (*outfun) (*string++);
X
X  /* padcount is now in units of tenths of msec.  */
X  padcount *= speeds[ospeed];
X  padcount += 500;
X  padcount /= 1000;
X  if (speeds[ospeed] < 0)
X    padcount = -padcount;
X  else
X    {
X      padcount += 50;
X      padcount /= 100;
X    }
X
X  while (padcount-- > 0)
X    (*outfun) (PC);
X}
X
X/* Finding the termcap entry in the termcap data base */
X
Xstruct buffer
X  {
X    char *beg;
X    int size;
X    char *ptr;
X    int ateof;
X    int full;
X  };
X
X/* Forward declarations of static functions */
X
Xstatic int scan_file ();
Xstatic char *gobble_line ();
Xstatic int compare_contin ();
Xstatic int name_match ();
X
X#ifdef VMS
X
X#include <rmsdef.h>
X#include <fab.h>
X#include <nam.h>
X
Xstatic int
Xlegal_filename_p (fn)
X     char *fn;
X{
X  struct FAB fab = cc$rms_fab;
X  struct NAM nam = cc$rms_nam;
X  char esa[NAM$C_MAXRSS];
X
X  fab.fab$l_fna = fn;
X  fab.fab$b_fns = strlen(fn);
X  fab.fab$l_nam = &nam;
X  fab.fab$l_fop = FAB$M_NAM;
X
X  nam.nam$l_esa = esa;
X  nam.nam$b_ess = sizeof esa;
X
X  return SYS$PARSE(&fab, 0, 0) == RMS$_NORMAL;
X}
X
X#endif /* VMS */
X
X/* Find the termcap entry data for terminal type `name'
X   and store it in the block that `bp' points to.
X   Record its address for future use.
X
X   If `bp' is zero, space is dynamically allocated.  */
X
Xint
Xtgetent (bp, name)
X     char *bp, *name;
X{
X  register char *tem;
X  register int fd;
X  struct buffer buf;
X  register char *bp1;
X  char *bp2;
X  char *term;
X  int malloc_size = 0;
X  register int c;
X  char *tcenv;			/* TERMCAP value, if it contais :tc=.  */
X  char *indirect = 0;		/* Terminal type in :tc= in TERMCAP value.  */
X  int filep;
X
X  tem = (char *) getenv ("TERMCAP");
X  if (tem && *tem == 0) tem = 0;
X
X#ifdef VMS
X  filep = tem && legal_filename_p (tem);
X#else
X  filep = tem && (*tem == '/');
X#endif /* VMS */
X
X  /* If tem is non-null and starts with / (in the un*x case, that is),
X     it is a file name to use instead of /etc/termcap.
X     If it is non-null and does not start with /,
X     it is the entry itself, but only if
X     the name the caller requested matches the TERM variable.  */
X
X  if (tem && !filep && !strcmp (name, getenv ("TERM")))
X    {
X      indirect = tgetst1 (find_capability (tem, "tc"), 0);
X      if (!indirect)
X	{
X	  if (!bp)
X	    bp = tem;
X	  else
X	    strcpy (bp, tem);
X	  goto ret;
X	}
X      else
X	{			/* we will need to read /etc/termcap */
X	  tcenv = tem;
X 	  tem = 0;
X	}
X    }
X  else
X    indirect = (char *) 0;
X
X  if (!tem)
X#ifdef VMS
X    tem = "emacs_library:[etc]termcap.dat";
X#else
X    tem = "/etc/termcap";
X#endif
X
X  /* Here we know we must search a file and tem has its name.  */
X
X  fd = open (tem, 0, 0);
X  if (fd < 0)
X    return -1;
X
X  buf.size = BUFSIZE;
X  buf.beg = (char *) xmalloc (buf.size);
X  term = indirect ? indirect : name;
X
X  if (!bp)
X    {
X      malloc_size = indirect ? strlen (tcenv) + 1 : buf.size;
X      bp = (char *) xmalloc (malloc_size);
X    }
X  bp1 = bp;
X
X  if (indirect)			/* copy the data from the environment variable */
X    {
X      strcpy (bp, tcenv);
X      bp1 += strlen (tcenv);
X    }
X
X  while (term)
X    {
X      /* Scan file, reading it via buf, till find start of main entry */
X      if (scan_file (term, fd, &buf) == 0)
X	return 0;
X
X      /* Free old `term' if appropriate.  */
X      if (term != name)
X	free (term);
X
X      /* If `bp' is malloc'd by us, make sure it is big enough.  */
X      if (malloc_size)
X	{
X	  malloc_size = bp1 - bp + buf.size;
X	  tem = (char *) xrealloc (bp, malloc_size);
X	  bp1 += tem - bp;
X	  bp = tem;
X	}
X
X      bp2 = bp1;
X
X      /* Copy the line of the entry from buf into bp.  */
X      tem = buf.ptr;
X      while ((*bp1++ = c = *tem++) && c != '\n')
X	/* Drop out any \ newline sequence. */
X	if (c == '\\' && *tem == '\n')
X	  {
X	    bp1--;
X	    tem++;
X	  }
X      *bp1 = 0;
X
X      /* Does this entry refer to another terminal type's entry?  */
X      /* If something is found, copy it into heap and null-terminate it */
X      term = tgetst1 (find_capability (bp2, "tc"), 0);
X    }
X
X  close (fd);
X  free (buf.beg);
X
X  if (malloc_size)
X    {
X      bp = (char *) xrealloc (bp, bp1 - bp + 1);
X    }
X
X ret:
X  term_entry = bp;
X  if (malloc_size)
X    return (int) bp;
X  return 1;
X}
X
X/* Given file open on `fd' and buffer `bufp',
X   scan the file from the beginning until a line is found
X   that starts the entry for terminal type `string'.
X   Returns 1 if successful, with that line in `bufp',
X   or returns 0 if no entry found in the file.  */
X
Xstatic int
Xscan_file (string, fd, bufp)
X     char *string;
X     int fd;
X     register struct buffer *bufp;
X{
X  register char *tem;
X  register char *end;
X
X  bufp->ptr = bufp->beg;
X  bufp->full = 0;
X  bufp->ateof = 0;
X  *bufp->ptr = 0;
X
X  lseek (fd, 0L, 0);
X
X  while (!bufp->ateof)
X    {
X      /* Read a line into the buffer */
X      end = 0;
X      do
X	{
X	  /* if it is continued, append another line to it,
X	     until a non-continued line ends */
X	  end = gobble_line (fd, bufp, end);
X	}
X      while (!bufp->ateof && end[-2] == '\\');
X
X      if (*bufp->ptr != '#'
X	  && name_match (bufp->ptr, string))
X	return 1;
X
X      /* Discard the line just processed */
X      bufp->ptr = end;
X    }
X  return 0;
X}
X
X/* Return nonzero if NAME is one of the names specified
X   by termcap entry LINE.  */
X
Xstatic int
Xname_match (line, name)
X     char *line, *name;
X{
X  register char *tem;
X
X  if (!compare_contin (line, name))
X    return 1;
X  /* This line starts an entry.  Is it the right one?  */
X  for (tem = line; *tem && *tem != '\n' && *tem != ':'; tem++)
X    if (*tem == '|' && !compare_contin (tem + 1, name))
X      return 1;
X
X  return 0;
X}
X
Xstatic int
Xcompare_contin (str1, str2)
X     register char *str1, *str2;
X{
X  register int c1, c2;
X  while (1)
X    {
X      c1 = *str1++;
X      c2 = *str2++;
X      while (c1 == '\\' && *str1 == '\n')
X	{
X	  str1++;
X	  while ((c1 = *str1++) == ' ' || c1 == '\t');
X	}
X      if (c2 == '\0')		/* end of type being looked up */
X	{
X	  if (c1 == '|' || c1 == ':') /* If end of name in data base, */
X	    return 0;		/* we win. */
X	  else
X	    return 1;
X        }
X      else if (c1 != c2)
X	return 1;
X    }
X}
X
X/* Make sure that the buffer <- `bufp' contains a full line
X   of the file open on `fd', starting at the place `bufp->ptr'
X   points to.  Can read more of the file, discard stuff before
X   `bufp->ptr', or make the buffer bigger.
X
X   Returns the pointer to after the newline ending the line,
X   or to the end of the file, if there is no newline to end it.
X
X   Can also merge on continuation lines.  If `append_end' is
X   nonzero, it points past the newline of a line that is
X   continued; we add another line onto it and regard the whole
X   thing as one line.  The caller decides when a line is continued.  */
X
Xstatic char *
Xgobble_line (fd, bufp, append_end)
X     int fd;
X     register struct buffer *bufp;
X     char *append_end;
X{
X  register char *end;
X  register int nread;
X  register char *buf = bufp->beg;
X  register char *tem;
X
X  if (append_end == 0)
X    append_end = bufp->ptr;
X
X  while (1)
X    {
X      end = append_end;
X      while (*end && *end != '\n') end++;
X      if (*end)
X        break;
X      if (bufp->ateof)
X	return buf + bufp->full;
X      if (bufp->ptr == buf)
X	{
X	  if (bufp->full == bufp->size)
X	    {
X	      bufp->size *= 2;
X	      tem = (char *) xrealloc (buf, bufp->size);
X	      bufp->ptr += tem - buf;
X	      append_end += tem - buf;
X	      bufp->beg = buf = tem;
X	    }
X	}
X      else
X	{
X	  append_end -= bufp->ptr - buf;
X	  bcopy (bufp->ptr, buf, bufp->full -= bufp->ptr - buf);
X	  bufp->ptr = buf;
X	}
X      if (!(nread = read (fd, buf + bufp->full, bufp->size - bufp->full)))
X	bufp->ateof = 1;
X      bufp->full += nread;
X      if (bufp->full != bufp->size)
X	buf[bufp->full] = 0;
X    }
X  return end + 1;
X}
X
X#ifdef TEST
X
X#include <stdio.h>
X
Xmain (argc, argv)
X     int argc;
X     char **argv;
X{
X  char *term;
X  char *buf;
X
X  term = argv[1];
X  printf ("TERM: %s\n", term);
X
X  buf = (char *) tgetent (0, term);
X  if ((int) buf <= 0)
X    {
X      printf ("No entry.\n");
X      return 0;
X    }
X
X  printf ("Entry: %s\n", buf);
X
X  tprint ("cm");
X  tprint ("AL");
X
X  printf ("co: %d\n", tgetnum ("co"));
X  printf ("am: %d\n", tgetflag ("am"));
X}
X
Xtprint (cap)
X     char *cap;
X{
X  char *x = tgetstr (cap, 0);
X  register char *y;
X
X  printf ("%s: ", cap);
X  if (x)
X    {
X      for (y = x; *y; y++)
X	if (*y <= ' ' || *y == 0177)
X	  printf ("\\%0o", *y);
X	else
X	  putchar (*y);
X      free (x);
X    }
X  else
X    printf ("none");
X  putchar ('\n');
X}
X
X#endif /* TEST */
END_OF_FILE
if test 18405 -ne `wc -c <'vms/vmstermcap.c'`; then
    echo shar: \"'vms/vmstermcap.c'\" unpacked with wrong size!
fi
# end of 'vms/vmstermcap.c'
fi
echo shar: End of archive 19 \(of 56\).
cp /dev/null ark19isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 56 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
