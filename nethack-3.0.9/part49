Path: utzoo!utgpu!news-server.csri.toronto.edu!cs.utexas.edu!wuarchive!mailrus!cornell!uw-beaver!zephyr.ens.tek.com!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v10i094:  nethack3p9 -  display oriented dungeons & dragons (Ver. 3.0i), Part49/56
Message-ID: <5954@tekred.CNA.TEK.COM>
Date: 13 Jul 90 19:43:12 GMT
Sender: news@tekred.CNA.TEK.COM
Lines: 2490
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 10, Issue 94
Archive-name: nethack3p9/Part49
Supersedes: NetHack3: Volume 7, Issue 56-93



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 49 (of 56)."
# Contents:  include/rm.h src/getline.c src/topl.c src/unixunix.c
#   vms/vmsbuild.com vms/vmstty.c vms/vmsunix.c
# Wrapped by billr@saab on Wed Jul 11 17:12:09 1990
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'include/rm.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/rm.h'\"
else
echo shar: Extracting \"'include/rm.h'\" \(8424 characters\)
sed "s/^X//" >'include/rm.h' <<'END_OF_FILE'
X/*	SCCS Id: @(#)rm.h	3.0	88/10/25
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#ifndef RM_H
X#define RM_H
X
X/*
X * The dungeon presentation graphics code and data structures were rewritten
X * and generalized for NetHack's release 2 by Eric S. Raymond (eric@snark)
X * building on Don G. Kneller's MS-DOS implementation. See options.c for
X * the code that permits the user to set the contents of the symbol structure.
X *
X * The door representation was changed by Ari Huttunen(ahuttune@niksula.hut.fi)
X */
X
X/*
X * TLCORNER	TDWALL		TRCORNER
X * +- 		-+- 		-+
X * |  		 |  	 	 |
X *
X * TRWALL	CROSSWALL	TLWALL		HWALL
X * |  		 |  		 |
X * +- 		-+- 		-+		---
X * |  		 |  		 |
X *
X * BLCORNER	TUWALL		BRCORNER	VWALL
X * |  		 |  		 |		|
X * +- 		-+- 		-+		|
X */
X
X/* Level location types */
X#define STONE		0
X#define HWALL		1
X#define VWALL		2
X#define TLCORNER	3
X#define TRCORNER	4
X#define BLCORNER	5
X#define BRCORNER	6
X#define CROSSWALL	7	/* For pretty mazes and special levels */
X#define TUWALL		8
X#define TDWALL		9
X#define TLWALL		10
X#define TRWALL		11
X#define SDOOR		12
X#define SCORR		13
X#define POOL		14
X#define MOAT		15	/* pool that doesn't boil, adjust messages */
X#define DRAWBRIDGE_UP	16
X#define DOOR		17
X#define CORR		18
X#define ROOM		19
X#define STAIRS		20
X#define LADDER		21
X#define FOUNTAIN	22
X#define THRONE		23
X#define SINK		24
X#define ALTAR		25
X#define DRAWBRIDGE_DOWN	26
X
X/*
X * Avoid using the level types in inequalities:
X * these types are subject to change.
X * Instead, use one of the macros below.
X */
X#ifndef STUPID_CPP	/* otherwise these macros are functions in prisym.c */
X#define IS_WALL(typ)	((typ) && (typ) <= TRWALL)
X#define IS_STWALL(typ)	((typ) <= TRWALL)	/* STONE <= (typ) <= TRWALL */
X#define IS_ROCK(typ)	((typ) < POOL)		/* absolutely nonaccessible */
X#define IS_DOOR(typ)	((typ) == DOOR)
X#define ACCESSIBLE(typ)	((typ) >= DOOR)		/* good position */
X#define IS_ROOM(typ)	((typ) >= ROOM)		/* ROOM, STAIRS, furniture.. */
X#define ZAP_POS(typ)	((typ) >= POOL)
X#define SPACE_POS(typ)	((typ) > DOOR)
X#define IS_POOL(typ)	((typ) >= POOL && (typ) <= DRAWBRIDGE_UP)
X#define IS_THRONE(typ)	((typ) == THRONE)
X#define IS_FOUNTAIN(typ) ((typ) == FOUNTAIN)
X#define IS_SINK(typ)	((typ) == SINK)
X#define IS_ALTAR(typ)	((typ) == ALTAR)
X#define IS_DRAWBRIDGE(typ) ((typ) == DRAWBRIDGE_UP || (typ) == DRAWBRIDGE_DOWN)
X#define IS_FURNITURE(typ) ((typ) >= STAIRS && (typ) <= ALTAR)
X#endif
X
X/*
X * The level-map symbols may be compiled in or defined at initialization time
X */
X
X/* screen symbols for using character graphics. */
X#define S_stone		0
X#define S_vwall		1
X#define S_hwall		2
X#define S_tlcorn	3
X#define S_trcorn	4
X#define S_blcorn	5
X#define S_brcorn	6
X#define S_crwall	7
X#define S_tuwall	8
X#define S_tdwall	9
X#define S_tlwall	10
X#define S_trwall	11
X#define S_vbeam		12
X#define S_hbeam		13
X#define S_lslant	14
X#define S_rslant	15
X#define S_ndoor		16
X#define S_vodoor	17
X#define S_hodoor	18
X#define S_cdoor		19
X#define S_room		20
X#define S_corr		21
X#define S_upstair	22
X#define S_dnstair	23
X#define S_trap		24
X#define S_web		25
X#define S_pool		26
X#define S_fountain	27
X#define S_sink		28
X#define S_throne	29
X#define S_altar		30
X#define S_upladder	31
X#define S_dnladder	32
X#define S_dbvwall	33
X#define S_dbhwall	34
X
X#define MAXPCHARS	35	/* maximum number of mapped characters */
X
Xtypedef uchar symbol_array[MAXPCHARS];
X
Xextern symbol_array showsyms;
Xextern const char *explainsyms[MAXPCHARS];  /* tells what the characters are */
X#ifdef REINCARNATION
Xextern symbol_array savesyms;
X#endif
Xextern symbol_array defsyms;
X
X#define STONE_SYM	showsyms[S_stone]
X#define VWALL_SYM	showsyms[S_vwall]
X#define HWALL_SYM	showsyms[S_hwall]
X#define TLCORN_SYM	showsyms[S_tlcorn]
X#define TRCORN_SYM	showsyms[S_trcorn]
X#define BLCORN_SYM	showsyms[S_blcorn]
X#define BRCORN_SYM	showsyms[S_brcorn]
X#define CRWALL_SYM	showsyms[S_crwall]
X#define TUWALL_SYM	showsyms[S_tuwall]
X#define TDWALL_SYM	showsyms[S_tdwall]
X#define TLWALL_SYM	showsyms[S_tlwall]
X#define TRWALL_SYM	showsyms[S_trwall]
X#define VBEAM_SYM	showsyms[S_vbeam]
X#define HBEAM_SYM	showsyms[S_hbeam]
X#define LSLANT_SYM	showsyms[S_lslant]
X#define RSLANT_SYM	showsyms[S_rslant]
X#define NO_DOOR_SYM	showsyms[S_ndoor]
X#define H_OPEN_DOOR_SYM	showsyms[S_hodoor]
X#define V_OPEN_DOOR_SYM	showsyms[S_vodoor]
X#define CLOSED_DOOR_SYM	showsyms[S_cdoor]
X#define ROOM_SYM	showsyms[S_room]
X#define	CORR_SYM	showsyms[S_corr]
X#define UP_SYM		showsyms[S_upstair]
X#define DN_SYM		showsyms[S_dnstair]
X#define TRAP_SYM	showsyms[S_trap]
X#define WEB_SYM		showsyms[S_web]
X#define	POOL_SYM	showsyms[S_pool]
X#define FOUNTAIN_SYM	showsyms[S_fountain]
X#define SINK_SYM	showsyms[S_sink]
X#define THRONE_SYM	showsyms[S_throne]
X#define ALTAR_SYM	showsyms[S_altar]
X#define UPLADDER_SYM	showsyms[S_upladder]
X#define DNLADDER_SYM	showsyms[S_dnladder]
X#define DB_VWALL_SYM	showsyms[S_dbvwall]
X#define DB_HWALL_SYM	showsyms[S_dbhwall]
X
X#define	ERRCHAR	']'
X
X/*
X * The 5 possible states of doors
X */
X
X#define D_NODOOR	0
X#define D_BROKEN	1
X#define D_ISOPEN	2
X#define D_CLOSED	4
X#define D_LOCKED	8
X#define D_TRAPPED	16
X
X/*
X * The 3 possible alignments for altars
X */
X#define A_CHAOS		0
X#define A_NEUTRAL	1
X#define A_LAW		2
X
X/*
X * Some altars are considered as shrines, so we need a flag.
X */
X#define A_SHRINE	4
X
X/*
X * Thrones should only be looted once.
X */
X#define T_LOOTED	1
X
X/*
X * The four directions for a DrawBridge.
X */
X#define DB_NORTH	0
X#define DB_SOUTH	1
X#define DB_EAST 	2
X#define DB_WEST 	4
X#define DB_DIR		7	/* mask for direction */
X
X/*
X * What's under a drawbridge.
X */
X#define DB_MOAT		0
X#define DB_FLOOR	8
X#define DB_ICE		16
X#define DB_UNDER	24	/* mask for underneath */
X
X/* 
X * Some walls may be non diggable.
X */
X#define W_DIGGABLE	0
X#define W_NONDIGGABLE	1
X#define W_GATEWAY	16	/* is a drawbridge wall */
X
X/*
X * Ladders (in Vlad's tower) may be up or down.
X */
X#define LA_UP		1
X#define LA_DOWN 	2
X
X/*
X * Room areas may be iced pools,
X */
X#define ICED_POOL	8
X#define ICED_MOAT	16
X
X
X/*
X * at() display character types, in order of precedence.
X */
X#ifndef MAXCOLORS
X#define MAXCOLORS	1
X#endif
X 
X#define AT_APP		(uchar)0
X/* 1-MAXCOLORS are specific overrides, see color.h */
X/* non-specific */
X#define AT_ZAP		(uchar)(MAXCOLORS+1)
X#define AT_MON		(uchar)(MAXCOLORS+2)
X#define AT_U		AT_MON
X#define AT_OBJ		(uchar)(MAXCOLORS+3)
X#define AT_GLD		AT_OBJ
X#define AT_MAP		(uchar)(MAXCOLORS+4)
X
X/*
X * The structure describing a coordinate position.
X * Before adding fields, remember that this will significantly affect
X * the size of temporary files and save files.
X */
Xstruct rm {
X	uchar scrsym;
X	Bitfield(typ,5);
X	Bitfield(new,1);
X	Bitfield(seen,1);
X	Bitfield(lit,1);
X	Bitfield(doormask,5);
X	Bitfield(gmask,1);
X};
X
X#define altarmask	doormask
X#define diggable	doormask
X#define ladder		doormask
X#define drawbridgemask	doormask
X#define looted		doormask
X#define icedpool	doormask
X
X#ifdef MACOS
Xtypedef struct
X{
X    struct rm		**locations;
X    struct obj		***objects;
X    struct monst	***monsters;
X    struct obj		*objlist;
X    struct monst	*monlist;
X}
Xdlevel_t;
X#else
Xtypedef struct
X{
X    struct rm		locations[COLNO][ROWNO];
X#ifndef MICROPORT_BUG
X    struct obj		*objects[COLNO][ROWNO];
X    struct monst	*monsters[COLNO][ROWNO];
X#else
X    struct obj		*objects[1][ROWNO];
X    char		*yuk1[COLNO-1][ROWNO];
X    struct monst	*monsters[1][ROWNO];
X    char		*yuk2[COLNO-1][ROWNO];
X#endif
X    struct obj		*objlist;
X    struct monst	*monlist;
X}
Xdlevel_t;
X#endif
X
Xextern dlevel_t	level;	/* structure describing the current level */
X
X/*
X * Macros for compatibility with old code. Someday these will go away.
X */
X#define levl		level.locations
X#define fobj		level.objlist
X#define fmon		level.monlist
X
X#ifndef STUPID_CPP	/* otherwise these macros are functions */
X#define OBJ_AT(x, y)	(level.objects[x][y] != (struct obj *)0)
X/*
X * Macros for encapsulation of level.monsters references.
X */
X#define MON_AT(x, y)	(level.monsters[x][y] != (struct monst *)0)
X#define place_monster(m, x, y)	m->mx=x,m->my=y,level.monsters[m->mx][m->my]=m
X#define place_worm_seg(m, x, y) level.monsters[x][y] = m
X#define remove_monster(x, y)	level.monsters[x][y] = (struct monst *)0
X#define m_at(x, y)		level.monsters[x][y]
X#endif	/* STUPID_CPP */
X
X#if defined(DGK) && !defined(OLD_TOS)
X#define ACTIVE	1
X#define SWAPPED	2
X
Xstruct finfo {
X	int	where;
X	long	time;
X	long	size;
X};
Xextern struct finfo fileinfo[];
X#define ZFINFO	{ 0, 0L, 0L }
X#endif
X
X#endif /* RM_H /**/
END_OF_FILE
if test 8424 -ne `wc -c <'include/rm.h'`; then
    echo shar: \"'include/rm.h'\" unpacked with wrong size!
fi
# end of 'include/rm.h'
fi
if test -f 'src/getline.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/getline.c'\"
else
echo shar: Extracting \"'src/getline.c'\" \(7548 characters\)
sed "s/^X//" >'src/getline.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)getline.c	3.0	89/06/16
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include "hack.h"
X#include "func_tab.h"
X
X/*
X * Some systems may have getchar() return EOF for various reasons, and
X * we should not quit before seeing at least NR_OF_EOFS consecutive EOFs.
X */
X#if defined(SYSV) || defined(DGUX)
X#define	NR_OF_EOFS	20
X#endif
X#ifdef MACOS
Xextern short macflags;
X#endif
X#ifdef OVL1
X
Xchar morc = 0;	/* tell the outside world what char he used */
X
X#endif /* OVL1 */
X
Xextern char erase_char, kill_char;	/* from appropriate tty.c file */
X
X#ifdef OVL1
X
X/*
X * Read a line closed with '\n' into the array char bufp[BUFSZ].
X * (The '\n' is not stored. The string is closed with a '\0'.)
X * Reading can be interrupted by an escape ('\033') - now the
X * resulting string is "\033".
X */
Xvoid
Xgetlin(bufp)
Xregister char *bufp;
X{
X	register char *obufp = bufp;
X	register int c;
X#ifdef MACOS
X	short	tmpflags;
X	
X	tmpflags = macflags;
X	macflags &= ~fDoNonKeyEvt;
X#endif
X	flags.toplin = 2;		/* nonempty, no --More-- required */
X	for(;;) {
X		(void) fflush(stdout);
X		if((c = Getchar()) == EOF) {
X			*bufp = 0;
X#ifdef MACOS
X	macflags = tmpflags;
X#endif
X			return;
X		}
X		if(c == '\033') {
X			*obufp = c;
X			obufp[1] = 0;
X#ifdef MACOS
X	macflags = tmpflags;
X#endif
X			return;
X		}
X		if(c == erase_char || c == '\b') {
X			if(bufp != obufp) {
X				bufp--;
X				putstr("\b \b");/* putsym converts \b */
X			} else	bell();
X		} else if(c == '\n') {
X			*bufp = 0;
X#ifdef MACOS
X	macflags = tmpflags;
X#endif
X			return;
X		} else if(' ' <= c && c < '\177' && 
X			    (bufp-obufp < BUFSZ-1 || bufp-obufp < COLNO)) {
X				/* avoid isprint() - some people don't have it
X				   ' ' is not always a printing char */
X			*bufp = c;
X			bufp[1] = 0;
X			putstr(bufp);
X			bufp++;
X		} else if(c == kill_char || c == '\177') { /* Robert Viduya */
X				/* this test last - @ might be the kill_char */
X			while(bufp != obufp) {
X				bufp--;
X				if(curx == 1 && cury > 1) {
X					putstr("\b \b\b");
X					curx = CO;
X				} else putstr("\b \b");
X			}
X		} else
X			bell();
X	}
X#ifdef MACOS
X	macflags = tmpflags;
X#endif
X}
X
X#endif /* OVL1 */
X#ifdef OVLB
X
Xvoid
Xgetret() {
X	cgetret("");
X}
X
Xvoid
Xcgetret(s)
Xregister const char *s;
X{
X	putsym('\n');
X	if(flags.standout)
X		standoutbeg();
X	putstr("Hit ");
X	putstr(flags.cbreak ? "space" : "return");
X	putstr(" to continue: ");
X	if(flags.standout)
X		standoutend();
X	xwaitforspace(s);
X}
X
X#endif /* OVLB */
X#ifdef OVL1
X
Xvoid
Xxwaitforspace(s)
Xregister const char *s;	/* chars allowed besides space or return */
X{
X	register int c;
X#ifdef MACOS
X	short	tmpflags;
X#endif
X
X	morc = 0;
X#ifdef MACOS
X	flags.wantspace = TRUE;
X	tmpflags = macflags;
X	macflags &= ~fDoNonKeyEvt;
X	HideCursor();
X#endif
X
X	while((c = readchar()) != '\n') {
X#ifdef MACOS
X		if(c == '\r' || c == 0x3 || c == 'p') break;
X#endif
X	    if(flags.cbreak) {
X			if(c == ' ') break;
X			if(s && index(s,c)) {
X				morc = c;
X				break;
X			}
X			bell();
X	    }
X	}
X
X#ifdef MACOS
X	ShowCursor();
X	flags.wantspace = FALSE;
X	macflags = tmpflags;
X#endif
X}
X
X#endif /* OVL1 */
X#ifdef OVL0
X
Xstatic int NEARDATA last_multi;
X
Xchar *
Xparse()
X{
X#ifdef LINT	/* static char in_line[COLNO]; */
X	char in_line[COLNO];
X#else
X	static char in_line[COLNO];
X#endif
X	register int foo, cnt = 0;
X	boolean prezero = FALSE;
X
X	multi = 0;
X	flags.move = 1;
X	curs_on_u();
X
X	if (!flags.num_pad || (foo = readchar()) == 'n')
X	    do {
X	    	foo = readchar();
X	    	if(foo >= '0' && foo <= '9') {
X				multi = 10*multi+foo-'0';
X				if (multi < 0 || multi > LARGEST_INT)
X					multi = LARGEST_INT;
X				if (multi > 9) {
X					remember_topl();
X					home();
X					cl_end();
X					Printf("Count: %d", multi);
X				}
X				last_multi = multi;
X				if(!cnt && foo == '0') prezero = TRUE;
X				cnt++;
X		    }
X		    if (foo == '\033') {   /* esc cancels count (TH) */
X				remember_topl();
X				home();
X				cl_end();
X				multi = last_multi = 0;
X		    }
X		} while(foo >= '0' && foo <= '9');
X# ifdef REDO
X	if (foo == DOAGAIN || in_doagain)
X		multi = last_multi;
X	else {
X		savech(0);	/* reset input queue */
X		savech(foo);
X	}
X# endif
X	if(multi) {
X		multi--;
X		save_cm = in_line;
X	}
X	in_line[0] = foo;
X	in_line[1] = 0;
X	if(foo == 'g' || foo == 'G' || (flags.num_pad && foo == '5')){
X		in_line[1] = Getchar();
X#ifdef REDO
X		savech(in_line[1]);
X#endif
X		in_line[2] = 0;
X	}
X	if(foo == 'm' || foo == 'M'){
X		in_line[1] = Getchar();
X#ifdef REDO
X		savech(in_line[1]);
X#endif
X		in_line[2] = 0;
X	}
X	clrlin();
X	if(prezero) in_line[0] = '\033';
X	return(in_line);
X}
X
X#endif /* OVL0 */
X#ifdef OVLB
X
X#ifdef UNIX
Xstatic void
Xend_of_input()
X{
X	settty("End of input?\n");
X	clearlocks();
X	exit(0);
X}
X#endif
X
X#endif /* OVLB */
X#ifdef OVL0
X
Xchar
Xreadchar() {
X	register int sym;
X
X	(void) fflush(stdout);
X#ifdef UNIX
X	if((sym = Getchar()) == EOF)
X# ifdef NR_OF_EOFS
X	{ /*
X	   * Some SYSV systems seem to return EOFs for various reasons
X	   * (?like when one hits break or for interrupted systemcalls?),
X	   * and we must see several before we quit.
X	   */
X		register int cnt = NR_OF_EOFS;
X		while (cnt--) {
X		    clearerr(stdin);	/* omit if clearerr is undefined */
X		    if((sym = Getchar()) != EOF) goto noteof;
X		}
X		end_of_input();
X	     noteof:	;
X	}
X# else
X		end_of_input();
X# endif /* NR_OF_EOFS /**/
X#else
X	sym = Getchar();
X#endif /* UNIX */
X	if(flags.toplin == 1)
X		flags.toplin = 2;
X	return((char) sym);
X}
X
X#endif /* OVL0 */
X#ifdef OVL2
X
X#ifdef COM_COMPL
X/* Read in an extended command - doing command line completion for
X * when enough characters have been entered to make a unique command.
X * This is just a modified getlin().   -jsb
X */
Xvoid
Xget_ext_cmd(bufp)
Xregister char *bufp;
X{
X	register char *obufp = bufp;
X	register int c;
X	int com_index, oindex;
X#ifdef MACOS
X	short tmpflags;
X	
X	tmpflags = macflags & ~(fExtCmdSeq1 | fExtCmdSeq2 | fExtCmdSeq3);
X	macflags &= ~fDoNonKeyEvt;
X#endif
X
X	flags.toplin = 2;		/* nonempty, no --More-- required */
X
X	for(;;) {
X		(void) fflush(stdout);
X		if((c = readchar()) == EOF) {
X			*bufp = 0;
X#ifdef MACOS
X			macflags = tmpflags;
X#endif
X			return;
X		}
X		if(c == '\033') {
X			*obufp = c;
X			obufp[1] = 0;
X#ifdef MACOS
X			macflags = tmpflags;
X#endif
X			return;
X		}
X		if(c == erase_char || c == '\b') {
X			if(bufp != obufp) {
X				bufp--;
X				putstr("\b \b"); /* putsym converts \b */
X			} else	bell();
X		} else if(c == '\n') {
X			*bufp = 0;
X#ifdef MACOS
X			macflags = tmpflags;
X#endif
X			return;
X		} else if(' ' <= c && c < '\177') {
X				/* avoid isprint() - some people don't have it
X				   ' ' is not always a printing char */
X			*bufp = c;
X			bufp[1] = 0;
X			oindex = 0;
X			com_index = -1;
X
X			while(extcmdlist[oindex].ef_txt != NULL){
X				if(!strncmp(obufp, extcmdlist[oindex].ef_txt,
X				    strlen(obufp)))
X					if(com_index == -1) /* No matches yet*/
X					    com_index = oindex;
X					else /* More than 1 match */
X					    com_index = -2;
X				oindex++;
X			}
X			if(com_index >= 0){
X				Strcpy(obufp, extcmdlist[com_index].ef_txt);
X				/* finish printing our string */
X				putstr(bufp);
X				bufp = obufp; /* reset it */
X				if(strlen(obufp) < BUFSIZ-1 &&
X				 strlen(obufp) < COLNO)
X					/* set bufp at the end of our string */
X					bufp += strlen(obufp);
X			} else {
X				putstr(bufp);
X				if(bufp-obufp < BUFSZ-1 && bufp-obufp < COLNO)
X					bufp++;
X			}
X		} else if(c == kill_char || c == '\177') { /* Robert Viduya */
X				/* this test last - @ might be the kill_char */
X			while(bufp != obufp) {
X				bufp--;
X				putstr("\b \b");
X			}
X		} else
X			bell();
X	}
X#ifdef MACOS
X	macflags = tmpflags;
X#endif
X
X}
X#endif /* COM_COMPL */
X
X#endif /* OVL2 */
END_OF_FILE
if test 7548 -ne `wc -c <'src/getline.c'`; then
    echo shar: \"'src/getline.c'\" unpacked with wrong size!
fi
# end of 'src/getline.c'
fi
if test -f 'src/topl.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/topl.c'\"
else
echo shar: Extracting \"'src/topl.c'\" \(7568 characters\)
sed "s/^X//" >'src/topl.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)topl.c	3.0	89/01/09
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#define NEED_VARARGS /* Uses ... */	/* comment line for pre-compiled headers */
X#include "hack.h"
X
XSTATIC_VAR char NEARDATA toplines[BUFSIZ];
X
X#ifndef OVLB
XSTATIC_DCL boolean no_repeat;
X#else /* OVLB */
XSTATIC_OVL boolean no_repeat = FALSE;
X#endif /* OVLB */
X
Xextern xchar tlx, tly;
X#ifdef OVLB
Xxchar tlx, tly;			/* set by pline; used by addtopl */
X#endif /* OVLB */
X
XSTATIC_DCL void NDECL(redotoplin);
XSTATIC_DCL void FDECL(xmore,(const char *));
XSTATIC_VAR struct topl {
X	struct topl *next_topl;
X	char *topl_text;
X} *old_toplines, *last_redone_topl;
X
X#define	OTLMAX	20		/* max nr of old toplines remembered */
X
X#ifdef OVL1
X
XSTATIC_OVL void
Xredotoplin() {
X	home();
X	if(index(toplines, '\n')) cl_end();
X	if((*toplines & 0x80) && AS) {
X		/* kludge for the / command, the only time we ever want a */
X		/* graphics character on the top line */
X		putstr(AS);
X		xputc(*toplines);
X		putstr(AE);
X		putstr(toplines+1);
X	} else putstr(toplines);
X	cl_end();
X	tlx = curx;
X	tly = cury;
X	flags.toplin = 1;
X	if(tly > 1)
X		more();
X}
X
X#endif /* OVL1 */
X#ifdef OVLB
X
Xint
Xdoredotopl(){
X	if(last_redone_topl)
X		last_redone_topl = last_redone_topl->next_topl;
X	if(!last_redone_topl)
X		last_redone_topl = old_toplines;
X	if(last_redone_topl){
X		Strcpy(toplines, last_redone_topl->topl_text);
X	}
X	redotoplin();
X	return 0;
X}
X
X#endif /* OVLB */
X#ifdef OVL1
X
Xvoid
Xremember_topl() {
X	register struct topl *tl;
X	register int cnt = OTLMAX;
X	if(last_redone_topl &&
X	   !strcmp(toplines, last_redone_topl->topl_text)) return;
X	if(old_toplines &&
X	   !strcmp(toplines, old_toplines->topl_text)) return;
X	last_redone_topl = 0;
X	tl = (struct topl *)
X		alloc((unsigned)(strlen(toplines) + sizeof(struct topl) + 3));
X	tl->next_topl = old_toplines;
X	tl->topl_text = (char *)(tl + 1);
X	Strcpy(tl->topl_text, toplines);
X	old_toplines = tl;
X	while(cnt && tl){
X		cnt--;
X		tl = tl->next_topl;
X	}
X	if(tl && tl->next_topl){
X		free((genericptr_t) tl->next_topl);
X		tl->next_topl = 0;
X	}
X}
X
Xvoid
Xaddtopl(s)
Xconst char *s;
X{
X	curs(tlx,tly);
X	if(tlx + strlen(s) > CO) putsym('\n');
X	putstr(s);
X	tlx = curx;
X	tly = cury;
X	flags.toplin = 1;
X}
X
X#endif /* OVL1 */
X#ifdef OVL2
X
XSTATIC_OVL void
Xxmore(s)
Xconst char *s;	/* allowed chars besides space/return */
X{
X	if(flags.toplin) {
X		curs(tlx, tly);
X		if(tlx + 8 > CO) putsym('\n'), tly++;
X	}
X
X	if(flags.standout)
X		standoutbeg();
X	putstr("--More--");
X	if(flags.standout)
X		standoutend();
X
X	xwaitforspace(s);
X	if(flags.toplin && tly > 1) {
X		home();
X		cl_end();
X		docorner(1, tly-1);
X		tlx = tly = 1;
X		curs(tlx, tly);
X	}
X	flags.toplin = 0;
X}
X
Xvoid
Xmore(){
X	xmore("");
X}
X
X#endif /* OVL2 */
X#ifdef OVLB
X
Xvoid
Xcmore(s)
Xregister const char *s;
X{
X	xmore(s);
X}
X
X#endif /* OVLB */
X#ifdef OVL1
X
Xvoid
Xclrlin(){
X	if(flags.toplin) {
X		home();
X		cl_end();
X		if(tly > 1) {
X			docorner(1, tly-1);
X			tlx = tly = 1;
X		}
X		remember_topl();
X	}
X	flags.toplin = 0;
X}
X
X#endif /* OVL1 */
X#ifdef OVLB
X
X/*VARARGS1*/
X/* Note that these declarations rely on knowledge of the internals
X * of the variable argument handling stuff in "tradstdc.h"
X */
X
X#if defined(USE_STDARG) || defined(USE_VARARGS)
Xvoid
Xpline VA_DECL(const char *, line)
X	VA_START(line);
X	VA_INIT(line, char *);
X	vpline(line, VA_ARGS);
X	VA_END();
X}
X
X# ifdef USE_STDARG
Xvoid
Xvpline(const char *line, va_list the_args) {
X# else
Xvoid
Xvpline(line, the_args) const char *line; va_list the_args; {
X# endif
X
X#else  /* USE_STDARG | USE_VARARG */
X
Xvoid
Xpline VA_DECL(const char *, line)
X#endif
X
X	char pbuf[BUFSZ];
X	register char *bp = pbuf, *tl;
X	register int n,n0;
X/* Do NOT use VA_START and VA_END in here... see above */
X
X	if(!line || !*line) return;
X	if(!index(line, '%')) Strcpy(pbuf,line); else
X	Vsprintf(pbuf,line,VA_ARGS);
X	if(no_repeat && flags.toplin == 1 && !strcmp(pbuf, toplines)) return;
X	nscr();		/* %% */
X
X	/* If there is room on the line, print message on same line */
X	/* But messages like "You die..." deserve their own line */
X	n0 = strlen(bp);
X	if(flags.toplin == 1 && tly == 1 &&
X	    n0 + strlen(toplines) + 3 < CO-8 &&  /* leave room for --More-- */
X	    strncmp(bp, "You die", 7)) {
X		Strcat(toplines, "  ");
X		Strcat(toplines, bp);
X		tlx += 2;
X		addtopl(bp);
X		return;
X	}
X	if(flags.toplin == 1 && !strcmp(pbuf, toplines) &&
X	    (n0 + strlen(toplines) + 3 >= CO-8)) {
X		more();
X		home();
X		putstr("");
X		cl_end();
X		goto again;
X	}
X	if(flags.toplin == 1) more();
X	else if(tly > 1) {	/* for when flags.toplin == 2 && tly > 1 */
X		docorner(1, tly-1);	/* reset tly = 1 if redraw screen */
X		tlx = tly = 1;	/* from home--cls() and docorner(1,n) */
X	}
Xagain:
X	remember_topl();
X	toplines[0] = 0;
X	while(n0){
X		if(n0 >= CO){
X			/* look for appropriate cut point */
X			n0 = 0;
X			for(n = 0; n < CO; n++) if(bp[n] == ' ')
X				n0 = n;
X			if(!n0) for(n = 0; n < CO-1; n++)
X				if(!letter(bp[n])) n0 = n;
X			if(!n0) n0 = CO-2;
X		}
X		(void) strncpy((tl = eos(toplines)), bp, n0);
X		tl[n0] = 0;
X		bp += n0;
X
X		/* remove trailing spaces, but leave one */
X		while(n0 > 1 && tl[n0-1] == ' ' && tl[n0-2] == ' ')
X			tl[--n0] = 0;
X
X		n0 = strlen(bp);
X		if(n0 && tl[0]) Strcat(tl, "\n");
X	}
X	redotoplin();
X}
X
X/*VARARGS1*/
Xvoid
XNorep VA_DECL(const char *, line)
X	VA_START(line);
X	VA_INIT(line, const char *);
X	no_repeat = TRUE;
X	vpline(line, VA_ARGS);
X	no_repeat = FALSE;
X	VA_END();
X	return;
X}
X
X/*VARARGS1*/
Xvoid
XYou VA_DECL(const char *, line)
X	char *tmp;
X	VA_START(line);
X	VA_INIT(line, const char *);
X	tmp = (char *)alloc((unsigned int)(strlen(line) + 5));
X	Strcpy(tmp, "You ");
X	Strcat(tmp, line);
X	vpline(tmp, VA_ARGS);
X	free(tmp);
X	VA_END();
X	return;
X}
X
X/*VARARGS1*/
Xvoid
XYour VA_DECL(const char *,line)
X	char *tmp;
X	VA_START(line);
X	VA_INIT(line, const char *);
X	tmp = (char *)alloc((unsigned int)(strlen(line) + 6));
X	Strcpy(tmp, "Your ");
X	Strcat(tmp, line);
X	vpline(tmp, VA_ARGS);
X	free(tmp);
X	VA_END();
X	return;
X}
X
X/*ARGSUSED*/
X/*VARARGS2*/
Xvoid
Xkludge  VA_DECL2(const char *, str, const char *, arg)
X#ifdef VA_NEXT
X	char *other1, *other2, *other3;
X#endif
X	VA_START(arg);
X	VA_INIT(str, const char *);
X	VA_INIT(arg, const char *);
X#ifdef VA_NEXT
X	VA_NEXT(other1, char *);
X	VA_NEXT(other2, char *);
X	VA_NEXT(other3, char *);
X# define OTHER_ARGS other1,other2,other3
X#else
X# define OTHER_ARGS arg1,arg2,arg3
X#endif
X	if(Blind || !flags.verbose) {
X		if(*str == '%') pline(str,"It",OTHER_ARGS);
X		else pline(str,"it",OTHER_ARGS);
X	} else pline(str,arg,OTHER_ARGS);
X	VA_END();
X}
X
X#endif /* OVLB */
X#ifdef OVL0
X
Xvoid
Xputsym(c)
Xchar c;
X{
X	switch(c) {
X	case '\b':
X		backsp();
X		curx--;
X		if(curx == 1 && cury > 1)
X			curs(CO, cury-1);
X		return;
X	case '\n':
X		curx = 1;
X		cury++;
X		if(cury > tly) tly = cury;
X		break;
X	default:
X		if(curx == CO)
X			putsym('\n');	/* 1 <= curx <= CO; avoid CO */
X		curx++;
X	}
X	(void) putchar(c);
X}
X
Xvoid
Xputstr(s)
Xregister const char *s;
X{
X	while(*s) putsym(*s++);
X}
X
X#endif /* OVL0 */
X#ifdef OVL2
X
Xchar
Xyn_function(resp, def)
Xconst char *resp;
Xchar def;
X/*
X *   Generic yes/no function
X */
X{
X	register char q;
X	char rtmp[8];
X
X	Sprintf(rtmp, "[%s] ", resp);
X	addtopl(rtmp);
X
X	do {
X		q = lowc(readchar());
X
X		if (index(quitchars, q)) q = def;
X		else if (!index(resp, q)) {
X			bell();
X			q = (char)0;
X		}
X	} while(!q);
X
X	Sprintf(rtmp, "%c", q);
X	addtopl(rtmp);
X	flags.toplin = 2;
X
X	return q;
X}
X
X#endif /* OVL2 */
X#ifdef OVLB
X
X/*VARARGS1*/
Xvoid
Ximpossible VA_DECL(const char *, s)
X	VA_START(s);
X	VA_INIT(s, const char *);
X	vpline(s,VA_ARGS);
X	pline("Program in disorder - perhaps you'd better Quit.");
X	VA_END();
X}
X
X#endif /* OVLB */
END_OF_FILE
if test 7568 -ne `wc -c <'src/topl.c'`; then
    echo shar: \"'src/topl.c'\" unpacked with wrong size!
fi
# end of 'src/topl.c'
fi
if test -f 'src/unixunix.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/unixunix.c'\"
else
echo shar: Extracting \"'src/unixunix.c'\" \(8318 characters\)
sed "s/^X//" >'src/unixunix.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)unixunix.c	3.0	88/04/13
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X/* This file collects some Unix dependencies; pager.c contains some more */
X
X/*
X * The time is used for:
X *	- seed for rand()
X *	- year on tombstone and yymmdd in record file
X *	- phase of the moon (various monsters react to NEW_MOON or FULL_MOON)
X *	- night and midnight (the undead are dangerous at midnight)
X *	- determination of what files are "very old"
X */
X
X/* block some unused #defines to avoid overloading some cpp's */
X#define MONATTK_H
X#define MONFLAG_H
X#include "hack.h"	/* mainly for index() which depends on BSD */
X
X#include <errno.h>
X#include <sys/stat.h>
X#ifdef NO_FILE_LINKS
X#include <fcntl.h>
X#endif
X
Xvoid
Xsetrandom()
X{
X#if defined(SYSV) || defined(DGUX)
X	(void) Srand((long) time ((time_t *) 0));
X#else
X#ifdef ULTRIX
X	Srand((int)time((time_t *)0));
X#else
X	(void) Srand((int) time ((long *) 0));
X#endif /* ULTRIX */
X#endif /* SYSV */
X
X}
X
Xstatic struct tm *
Xgetlt()
X{
X	time_t date;
X
X#ifdef BSD
X	(void) time((long *)(&date));
X#else
X	(void) time(&date);
X#endif
X#if defined(ULTRIX) || defined(BSD)
X	return(localtime((long *)(&date)));
X#else
X	return(localtime(&date));
X#endif /* ULTRIX */
X}
X
Xint
Xgetyear()
X{
X	return(1900 + getlt()->tm_year);
X}
X
Xchar *
Xgetdate()
X{
X#ifdef LINT	/* static char datestr[7]; */
X	char datestr[7];
X#else
X	static char datestr[7];
X#endif
X	register struct tm *lt = getlt();
X
X	Sprintf(datestr, "%2d%2d%2d",
X		lt->tm_year, lt->tm_mon + 1, lt->tm_mday);
X	if(datestr[2] == ' ') datestr[2] = '0';
X	if(datestr[4] == ' ') datestr[4] = '0';
X	return(datestr);
X}
X
Xint
Xphase_of_the_moon()			/* 0-7, with 0: new, 4: full */
X{					/* moon period: 29.5306 days */
X					/* year: 365.2422 days */
X	register struct tm *lt = getlt();
X	register int epact, diy, goldn;
X
X	diy = lt->tm_yday;
X	goldn = (lt->tm_year % 19) + 1;
X	epact = (11 * goldn + 18) % 30;
X	if ((epact == 25 && goldn > 11) || epact == 24)
X		epact++;
X
X	return( (((((diy + epact) * 6) + 11) % 177) / 22) & 7 );
X}
X
Xint
Xnight()
X{
X	register int hour = getlt()->tm_hour;
X
X	return(hour < 6 || hour > 21);
X}
X
Xint
Xmidnight()
X{
X	return(getlt()->tm_hour == 0);
X}
X
Xstatic struct stat buf, hbuf;
X
Xvoid
Xgethdate(name) char *name; {
X/* old version - for people short of space */
X/*
X/* register char *np;
X/*	if(stat(name, &hbuf))
X/*		error("Cannot get status of %s.",
X/*			(np = rindex(name, '/')) ? np+1 : name);
X/*
X/* version using PATH from: seismo!gregc@ucsf-cgl.ARPA (Greg Couch) */
X
X
X/*
X * The problem with   #include	<sys/param.h>   is that this include file
X * does not exist on all systems, and moreover, that it sometimes includes
X * <sys/types.h> again, so that the compiler sees these typedefs twice.
X */
X#define		MAXPATHLEN	1024
X
Xregister char *np, *path;
Xchar filename[MAXPATHLEN+1];
X	if (index(name, '/') != NULL || (path = getenv("PATH")) == NULL)
X		path = "";
X
X	for (;;) {
X		if ((np = index(path, ':')) == NULL)
X			np = path + strlen(path);	/* point to end str */
X		if (np - path <= 1)			/* %% */
X			Strcpy(filename, name);
X		else {
X			(void) strncpy(filename, path, np - path);
X			filename[np - path] = '/';
X			Strcpy(filename + (np - path) + 1, name);
X		}
X		if (stat(filename, &hbuf) == 0)
X			return;
X		if (*np == '\0')
X			break;
X		path = np + 1;
X	}
X	error("Cannot get status of %s.",
X		(np = rindex(name, '/')) ? np+1 : name);
X}
X
Xint
Xuptodate(fd)
Xint fd;
X{
X	if(fstat(fd, &buf)) {
X		pline("Cannot get status of saved level? ");
X		return(0);
X	}
X	if(buf.st_mtime < hbuf.st_mtime) {
X		pline("Saved level is out of date. ");
X		return(0);
X	}
X	return(1);
X}
X
X/* see whether we should throw away this xlock file */
Xstatic int
Xveryold(fd)
Xint fd;
X{
X	time_t date;
X
X	if(fstat(fd, &buf)) return(0);			/* cannot get status */
X	if(buf.st_size != sizeof(int)) return(0);	/* not an xlock file */
X#ifdef BSD
X	(void) time((long *)(&date));
X#else
X	(void) time(&date);
X#endif
X	if(date - buf.st_mtime < 3L*24L*60L*60L) {	/* recent */
X		extern int errno;
X		int lockedpid;	/* should be the same size as hackpid */
X
X		if(read(fd, (char *)&lockedpid, sizeof(lockedpid)) !=
X			sizeof(lockedpid))
X			/* strange ... */
X			return(0);
X
X		/* From: Rick Adams <seismo!rick>
X		/* This will work on 4.1cbsd, 4.2bsd and system 3? & 5.
X		/* It will do nothing on V7 or 4.1bsd. */
X#ifndef NETWORK
X		/* It will do a VERY BAD THING if the playground is shared
X		   by more than one machine! -pem */
X  		if(!(kill(lockedpid, 0) == -1 && errno == ESRCH))
X#endif
X			return(0);
X	}
X	(void) close(fd);
X	return(1);
X}
X
Xstatic int
Xeraseoldlocks()
X{
X	register int i;
X
X	for(i = 1; i <= MAXLEVEL+1; i++) {		/* try to remove all */
X		glo(i);
X		(void) unlink(lock);
X	}
X	glo(0);
X	if(unlink(lock)) return(0);			/* cannot remove it */
X	return(1);					/* success! */
X}
X
Xvoid
Xgetlock()
X{
X	extern int errno;
X	register int i = 0, fd, c;
X#ifdef NO_FILE_LINKS
X	int hlockfd ;
X	int sleepct = 20 ;
X#endif
X
X#ifdef HARD
X	/* idea from rpick%ucqais@uccba.uc.edu
X	 * prevent automated rerolling of characters
X	 * test input (fd0) so that tee'ing output to get a screen dump still
X	 * works
X	 * also incidentally prevents development of any hack-o-matic programs
X	 */
X	if (!isatty(0))
X		error("You must play from a terminal.");
X#endif
X
X	(void) fflush(stdout);
X
X	/* we ignore QUIT and INT at this point */
X#ifdef NO_FILE_LINKS
X	while ((hlockfd = open(LLOCK,O_RDONLY|O_CREAT|O_EXCL,0644)) == -1) {
X	    if (--sleepct) {
X		Printf( "Lock file in use.  %d retries left.\n",sleepct);
X		(void) fflush(stdout);
X# if defined(SYSV) || defined(ULTRIX)
X		(void)
X# endif
X		    sleep(1);
X	    } else {
X		Printf("I give up!  Try again later.\n");
X		getret();
X		error("");
X	    }
X	}
X	(void) close(hlockfd);
X
X#else	/* NO_FILE_LINKS */
X	if (link(HLOCK, LLOCK) == -1) {
X		register int errnosv = errno;
X
X		perror(HLOCK);
X		Printf("Cannot link %s to %s\n", LLOCK, HLOCK);
X		switch(errnosv) {
X		case ENOENT:
X		    Printf("Perhaps there is no (empty) file %s ?\n", HLOCK);
X		    break;
X		case EACCES:
X		    Printf("It seems you don't have write permission here.\n");
X		    break;
X		case EEXIST:
X		    Printf("(Try again or rm %s.)\n", LLOCK);
X		    break;
X		default:
X		    Printf("I don't know what is wrong.");
X		}
X		getret();
X		error("");
X		/*NOTREACHED*/
X	}
X#endif /* NO_FILE_LINKS */
X
X	regularize(lock);
X	glo(0);
X
X	if(locknum) {
X		if(locknum > 25) locknum = 25;
X
X		do {
X			lock[0] = 'a' + i++;
X
X			if((fd = open(lock, 0)) == -1) {
X			    if(errno == ENOENT) goto gotlock; /* no such file */
X			    perror(lock);
X			    (void) unlink(LLOCK);
X			    error("Cannot open %s", lock);
X			}
X
X			if(veryold(fd) /* closes fd if true */
X							&& eraseoldlocks())
X				goto gotlock;
X			(void) close(fd);
X		} while(i < locknum);
X
X		(void) unlink(LLOCK);
X		error("Too many hacks running now.");
X	} else {
X		if((fd = open(lock, 0)) == -1) {
X			if(errno == ENOENT) goto gotlock;    /* no such file */
X			perror(lock);
X			(void) unlink(LLOCK);
X			error("Cannot open %s", lock);
X		}
X
X		if(veryold(fd) /* closes fd if true */ && eraseoldlocks())
X			goto gotlock;
X		(void) close(fd);
X
X		Printf("\nThere is already a game in progress under your name.");
X		Printf("\nDestroy old game? [yn] ");
X		(void) fflush(stdout);
X		c = Getchar();
X		while (Getchar() != '\n') ; /* eat rest of line and newline */
X		if(c == 'y' || c == 'Y')
X			if(eraseoldlocks())
X				goto gotlock;
X			else {
X				(void) unlink(LLOCK);
X				error("Couldn't destroy old game.");
X			}
X		else {
X			(void) unlink(LLOCK);
X			error("");
X		}
X	}
Xgotlock:
X	fd = creat(lock, FCMASK);
X	if(unlink(LLOCK) == -1)
X		error("Cannot unlink %s.", LLOCK);
X	if(fd == -1) {
X		error("cannot creat lock file.");
X	} else {
X		if(write(fd, (char *) &hackpid, sizeof(hackpid))
X		    != sizeof(hackpid)){
X			error("cannot write lock");
X		}
X		if(close(fd) == -1) {
X			error("cannot close lock");
X		}
X	}
X}	
X
Xvoid
Xregularize(s)	/* normalize file name - we don't like .'s, /'s, spaces */
Xregister char *s;
X{
X	register char *lp;
X
X	while((lp=index(s, '.')) || (lp=index(s, '/')) || (lp=index(s,' ')))
X		*lp = '_';
X#ifdef SYSV
X	/* avoid problems with 14 character file name limit */
X# ifdef COMPRESS
X	if(strlen(s) > 10)
X		/* leave room for .e from error and .Z from compress
X		 * appended to save files */
X		s[10] = '\0';
X# else
X	if(strlen(s) > 11)
X		/* leave room for .nn appended to level files */
X		s[11] = '\0';
X# endif
X#endif
X}
END_OF_FILE
if test 8318 -ne `wc -c <'src/unixunix.c'`; then
    echo shar: \"'src/unixunix.c'\" unpacked with wrong size!
fi
# end of 'src/unixunix.c'
fi
if test -f 'vms/vmsbuild.com' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vms/vmsbuild.com'\"
else
echo shar: Extracting \"'vms/vmsbuild.com'\" \(8030 characters\)
sed "s/^X//" >'vms/vmsbuild.com' <<'END_OF_FILE'
X$ ! vms/vmsbuild.com -- compile and link NetHack 3.0 patchlevel 9	[pr]
X$ !
X$ ! usage:
X$ !   $ set default [.src]	!or [-.src] if starting from [.vms]
X$ !   $ @[-.vms]vmsbuild  [compiler-option]  [link-option]  [cc-switches]
X$ ! options:
X$ !	compiler-option :  either "VAXC" or "GNUC" or ""	!default VAXC
X$ !	link-option	:  either "SHARE[able]" or "LIB[rary]"	!default SHARE
X$ !	cc-switches	:  optional qualifiers for CC (such as "/noOpt/Debug")
X$ ! notes:
X$ !	If the symbol "CC" is defined, compiler-option is not used.
X$ !	The link-option refers to VAXCRTL (C Run-Time Library) handling;
X$ !	  to specify it while letting compiler-option default, use "" as
X$ !	  the compiler-option.
X$ !	To re-link without compiling, use "LINK" as special 'compiler-option';
X$ !	  to re-link with GNUC library, 'CC' must begin with "G" (or "g").
X$ !	Default wizard definition moved to include/vmsconf.h.
X$
X$	vaxc_ = "CC/NOLIST/OPTIMIZE=NOINLINE"	    !vaxc v3.x (2.x fixed below)
X$	gnuc_ = "GCC/CC1=""-fwritable-strings"""
X$	gnulib = "gnu_cc:[000000]gcclib/Library"    !(not used w/ vaxc)
X$ ! common CC options (/obj=file doesn't work for GCC 1.36, use rename instead)
X$	c_c_  = "/INCLUDE=[-.INCLUDE]"	!/DEFINE=(""WIZARD=""""GENTZEL"""""")
X$	if f$extract(1,3,f$getsyi("VERSION")).lts."4.6" then -
X$		c_c_ = c_c_ + "/DEFINE=(""VERYOLD_VMS"")"
X$ ! miscellaneous setup
X$	ivqual = %x00038240	!DCL-W-IVQUAL (used to check for ancient vaxc)
X$	abort := exit %x1000002A
X$ ! validate first parameter
X$	p1 := 'p1'
X$	c_opt = f$locate("|"+p1, "|VAXC|GNUC|LINK|SPECIAL|") !5
X$     if (c_opt/5)*5 .eq. c_opt then  goto p1_ok
X$	copy sys$input: sys$error:	!p1 usage
X%first arg is compiler option; it must be one of
X       "VAXC" -- use VAX C to compile everything
X   or  "GNUC" -- use GNU C to compile everything
X   or  "LINK" -- skip compilation, just relink nethack.exe
X   or  "SPEC[IAL]" -- just compile and link lev_comp.exe
X   or    ""   -- default operation (VAXC unless 'CC' is defined)
X
XNote: if a DCL symbol for CC is defined, "VAXC" and "GNUC" are no-ops.
X      If the symbol value begins with "G" (or "g"), then the GNU C
X      library will be included in all link operations.  Do not rebuild
X      lev_comp with "SPECIAL" unless you have a CC symbol setup with
X      the proper options.
X$	abort
X$p1_ok:
X$ ! validate second parameter
X$	p2 := 'p2'
X$	l_opt = f$locate("|"+p2, "|SHAREABLE|LIBRARY__|") !10
X$     if (l_opt/10)*10 .eq. l_opt then	goto p2_ok
X$	copy sys$input: sys$error:	!p2 usage
X%second arg is VAXCRTL handling; it must be one of
X       "SHAREABLE" -- link with SYS$SHARE:VAXCRTL.EXE/SHAREABLE
X   or   "LIBRARY"  -- link with SYS$LIBRARY:VAXCRTL.OLB/LIBRARY
X   or      ""      -- default operation (use shareable image)
X
XNote: for MicroVMS 4.x, "SHAREABLE" (which is the default) is required.
X$	abort
X$p2_ok:
X$ ! compiler setup; if a symbol for "CC" is already defined it will be used
X$     if f$type(cc).eqs."STRING" then  goto got_cc
X$	cc = vaxc_			!assume "VAXC" requested or defaulted
X$	if c_opt.eq.5 then  cc = gnuc_	!explicitly invoked w/ "GNUC" option
X$	if c_opt.ne.0 then  goto got_cc !"GNUC" or "LINK", skip compiler check
X$	! we want to prevent function inlining with vaxc v3.x (/opt=noinline)
X$	!   but we can't use noInline with v2.x, so need to determine version
X$	  set noOn
X$	  msgenv = f$environment("MESSAGE")
X$	  set message/noFacil/noSever/noIdent/noText
X$	  cc/noObject _NLA0:/Include=[]     !strip 'noinline' if error
X$	  sts = $status
X$	if sts then  goto reset_msg	!3.0 or later will check out OK
X$	! must be dealing with vaxc 2.x; ancient version (2.2 or earlier)
X$	!   can't handle /include='dir', needs c$include instead
X$	  cc = cc - "=NOINLINE" - ",NOINLINE" - "NOINLINE,"
X$	  if sts.ne.IVQUAL then  goto reset_msg
X$	    define/noLog c$include [-.INCLUDE]
X$	    c_c_ = "/DEFINE=(""ANCIENT_VAXC"")"
X$	    if f$extract(1,3,f$getsyi("VERSION")).lts."4.6" then -
X$		c_c_ = c_c_ - ")" + ",""VERYOLD_VMS"")"
X$reset_msg:
X$	  set message 'msgenv'
X$	  set On
X$got_cc:
X$	cc = cc + c_c_			!append common qualifiers
X$	if p3.nes."" then  cc = cc + p3 !append optional user preferences
X$	g := 'f$extract(0,1,cc)'
X$	if g.nes."G" then  gnulib = ""
X$	if g.eqs."G" then  gnulib = "," + gnulib
X$ ! linker setup; if a symbol for "LINK" is defined, we'll use it
X$	if f$type(link).nes."STRING" then  link = "LINK/NOMAP"
X$	if p4.nes."" then  link = link + p4 !append optional user preferences
X$	vaxcrtl = "sys$library:vaxcrtl.olb/Library"	!object library
X$     if l_opt.ne.0 then  goto vaxcrtl_ok
X$	vaxcrtl = "sys$disk:[]vaxcrtl.opt/Options"	!shareable image
X$     if f$search("vaxcrtl.opt").nes."" then  goto vaxcrtl_ok !assume its right
X$	create sys$disk:[]vaxcrtl.opt
Xsys$share:vaxcrtl/Shareable
Xsys$library:vaxcrtl/Library	!/Include=C$$TRANSLATE	!for link() substitute
X$vaxcrtl_ok:
X$ ! final setup
X$	nethacklib = "nethack.olb"
X$	milestone = "write sys$output f$fao("" !5%T "",0),"
X$     if c_opt.eq.10 then  goto link	!"LINK" requested, skip compilation
X$	rename	 := rename/New_Vers
X$	touch	 := set file/Truncate
X$	makedefs := $sys$disk:[]makedefs
X$	show symbol cc
X$!
X$!  compile and link makedefs, then nethack, finally lev_comp.
X$!
X$ milestone "<compiling...>"
X$ cc [-.vms]vmsmisc	!try simplest one first
X$ cc alloc.c
X$ if f$search("monst.c").eqs."" then  copy/Concat monst.c1+.c2 *.c
X$ cc monst.c
X$ milestone " (monst)"
X$ cc objects.c
X$     if c_opt.eq.15 then  goto special !"SPECIAL" requested, skip main build
X$ cc makedefs.c
X$ link makedefs.obj,monst.obj,objects.obj,vmsmisc.obj,-
X	'vaxcrtl''gnulib',sys$input:/Opt
Xidentification="makedefs 3.0.9"
X$ milestone "makedefs"
X$! create some build-time files
X$ makedefs -p	!pm.h
X$ makedefs -o	!onames.h
X$ makedefs -t	!trap.h
X$ makedefs -v	!date.h
X$! create new object library
X$ libr/Obj 'nethacklib'/Create=(Block=2000,Hist=2) vmsmisc.obj,alloc.obj/Insert
X$ if f$search(f$parse(".olb;-2",nethacklib)).nes."" then -
X$	purge/Keep=2 'nethacklib'
X$! compile most of the source files:
X$ c1 = "decl,version,[-.vms]vmsmain,[-.vms]vmsunix,[-.vms]vmstty," -
X      + "[-.others]random,[-.vms]vmstparam"
X$ c2 = "allmain,apply,artifact,attrib,bones,cmd,dbridge,demon,do,do_name," -
X      + "do_wear,dog,dogmove,dokick,dothrow,eat,end,engrave,exper,extralev"
X$ c3 = "fountain,getline,hack,invent,lock,mail,makemon,mcastu,mhitm,mhitu," -
X      + "mklev,mkmaze,mkobj,mkroom,mon,mondata,monmove,mthrowu,music,o_init"
X$ c4 = "objnam,options,pager,pickup,polyself,potion,pray,pri,priest,prisym," -
X      + "read,restore,rip,rnd,rumors,save,search,shk,shknam,sit,sounds,sp_lev"
X$ c5 = "spell,steal,termcap,timeout,topl,topten,track,trap,u_init,uhitm," -
X      + "vault,weapon,were,wield,wizard,worm,worn,write,zap"
X$! process all 5 lists of files
X$   i = 1
X$list_loop:
X$     list = c'i'	!get next list
X$     j = 0
X$file_loop:
X$	file = f$element(j,",",list)	!get next file
X$	if file.eqs."" .or. file.eqs."," then  goto list_done
X$	cc 'file'.c
X$	if f$extract(0,1,file).eqs."[" then -
X$		file = f$edit(f$parse(file,,,"NAME"),"LOWERCASE")
X$	libr/Obj 'nethacklib' 'file'.obj/Insert
X$	delete 'file'.obj;*
X$	milestone " (",file,")"
X$	j = j + 1
X$     goto file_loop
X$list_done:
X$     i = i + 1
X$   if i.le.5 then  goto list_loop
X$! one special case left
X$ cc [-.vms]vmstermcap.c -
X	/Define=("bcopy(s,d,n)=memcpy((d),(s),(n))","exit=vms_exit")
X$ libr/Obj 'nethacklib' vmstermcap.obj/Insert
X$!
X$link:
X$ milestone "<linking...>"
X$ link/Exe=nethack 'nethacklib'/Lib/Incl=(vmsmain,allmain,vmsunix,vmstty,decl),-
X	sys$disk:[]monst.obj,objects.obj,-	!(data-only modules, like decl)
X	sys$input:/Opt,'vaxcrtl''gnulib'
Xidentification="NetHack 3.0.9"
X$ milestone "NetHack"
X$     if c_opt.eq.10 then  goto done	!"LINK" only
X$special:
X$!
X$! build special level compiler
X$!
X$ cc lev_main.c
X$ cc lev_comp.c
X$ copy [-.vms]lev_lex.h stdio.*/Prot=(s:rwd,o:rwd)
X$ cc lev_lex.c
X$ rename stdio.h lev_lex.*
X$ cc panic.c
X$ link lev_comp.obj,lev_lex.obj,lev_main.obj,-
X	monst.obj,objects.obj,alloc.obj,panic.obj,vmsmisc.obj,-
X	'vaxcrtl''gnulib',sys$input:/Opt
Xidentification="lev_comp 3.0.9"
X$ milestone "lev_comp"
X$!
X$done:
X$ exit
END_OF_FILE
if test 8030 -ne `wc -c <'vms/vmsbuild.com'`; then
    echo shar: \"'vms/vmsbuild.com'\" unpacked with wrong size!
fi
# end of 'vms/vmsbuild.com'
fi
if test -f 'vms/vmstty.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vms/vmstty.c'\"
else
echo shar: Extracting \"'vms/vmstty.c'\" \(6558 characters\)
sed "s/^X//" >'vms/vmstty.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)vmstty.c	3.0	88/05/03
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X/* tty.c - (VMS) version */
X
X#define NEED_VARARGS
X#include "hack.h"
X
X#include	<descrip.h>
X#include	<iodef.h>
X#include	<smgdef.h>
X#include	<ttdef.h>
X#include <errno.h>
X
X#define vms_ok(sts) ((sts)&1)
X#define META(c)  ((c)|0x80)	/*(Same as DOS's M(c).)*/
X#define CTRL(c)  ((c)&0x1F)
X#define CMASK(c) (1<<CTRL(c))
X#define LIB$M_CLI_CTRLT CMASK('T')	/* 0x00100000 */
X#define LIB$M_CLI_CTRLY CMASK('Y')	/* 0x02000000 */
X
Xextern short ospeed;
Xchar erase_char, intr_char, kill_char;
Xstatic boolean settty_needed = FALSE,  bombing = FALSE;
X#ifndef MAIL
Xstatic	    /* else global ('extern' in mail.c) */
X#endif
X       unsigned long pasteboard_id = 0; /* for AST & broadcast-msg handling */
Xstatic unsigned long kb = 0;
X
Xint
Xvms_getchar()
X{
X    static volatile int recurse = 0;	/* SMG is not AST re-entrant! */
X    short key;
X
X    if (recurse++ == 0 && kb != 0) {
X	SMG$READ_KEYSTROKE(&kb, &key);
X	switch (key)
X	{
X	  case SMG$K_TRM_UP:
X	    key = 'k';
X	    break;
X	  case SMG$K_TRM_DOWN:
X	    key = 'j';
X	    break;
X	  case SMG$K_TRM_LEFT:
X	    key = 'h';
X	    break;
X	  case SMG$K_TRM_RIGHT:
X	    key = 'l';
X	    break;
X	  case '\r':
X	    key = '\n';
X	    break;
X	  default:
X	    if (key == '\007' || key == '\032' || key > 255)
X		key = '\033';
X	    break;
X	}
X    } else {
X	/* abnormal input--either SMG didn't initialize properly or
X	   vms_getchar() has been called recursively (via SIGINT handler).
X	 */
X	if (kb != 0)			/* must have been a recursive call */
X	    SMG$CANCEL_INPUT(&kb);	/*  from an interrupt handler	   */
X	key = getchar();
X    }
X    --recurse;
X    return (int)key;
X}
X
X#define TT_SPECIAL_HANDLING (TT$M_MECHTAB|TT$M_MECHFORM)
X#define Uword unsigned short
X#define Ubyte unsigned char
Xstruct _sm_iosb {		/* i/o status block for sense-mode qio */
X	Uword	  status;
X	Ubyte	  xmt_speed,  rcv_speed;
X	Ubyte	  cr_fill,  lf_fill,  parity;
X	unsigned   : 8;
X};
Xstruct _sm_bufr {		/* sense-mode characteristics buffer */
X	Ubyte	  class,  type;		/* class==DC$_TERM, type==(various) */
X	Uword	  buf_siz;		/* aka page width */
X#define page_width buf_siz		/* number of columns */
X	unsigned  tt_char  : 24;	/* primary characteristics */
X	Ubyte	  page_length;		/* number of lines */
X	unsigned  tt2_char : 32;	/* secondary characteristics */
X};
Xstatic struct {
X    struct _sm_iosb io;
X    struct _sm_bufr sm;
X} sg = {{0},{0}};
Xstatic unsigned short tt_chan = 0;
Xstatic unsigned long  tt_char_restore = 0, tt_char_active = 0;
Xstatic unsigned long  ctrl_mask = 0;
X
Xstatic void
Xsetctty(){
X    struct _sm_iosb iosb;
X    long status = SYS$QIOW(0, tt_chan, IO$_SETMODE, &iosb, (void(*)())0, 0,
X			   &sg.sm, sizeof sg.sm, 0, 0, 0, 0);
X    if (vms_ok(status))  status = iosb.status;
X    if (!vms_ok(status)) {
X	errno = EVMSERR,  vaxc$errno = status;
X	perror("NetHack (setctty: setmode)");
X    }
X}
X
Xstatic void
Xresettty(){			/* atexit() routine */
X    if (settty_needed) {
X	bombing = TRUE;     /* don't clear screen; preserve traceback info */
X	settty((char *)NULL);
X    }
X    (void) SYS$DASSGN(tt_chan),  tt_chan = 0;
X}
X
X/*
X * Get initial state of terminal, set ospeed (for termcap routines)
X * and switch off tab expansion if necessary.
X * Called by startup() in termcap.c and after returning from ! or ^Z
X */
Xvoid
Xgettty(){
X    long status;
X    $DESCRIPTOR(input_dsc, "TT");
X    unsigned long zero = 0;
X
X    if (tt_chan == 0) {		/* do this stuff once only */
X	status = SYS$ASSIGN(&input_dsc, &tt_chan, 0, 0);
X	if (!vms_ok(status)) {
X	    errno = EVMSERR,  vaxc$errno = status;
X	    perror("NetHack (gettty: $assign)");
X	}
X	atexit(resettty);   /* register an exit handler to reset things */
X    }
X    status = SYS$QIOW(0, tt_chan, IO$_SENSEMODE, &sg.io, (void(*)())0, 0,
X		      &sg.sm, sizeof sg.sm, 0, 0, 0, 0);
X    if (vms_ok(status))  status = sg.io.status;
X    if (!vms_ok(status)) {
X	errno = EVMSERR,  vaxc$errno = status;
X	perror("NetHack (gettty: sensemode)");
X    }
X    ospeed = sg.io.xmt_speed;
X    erase_char = '\177';	/* <rubout>, aka <delete> */
X    kill_char = CTRL('U');
X    intr_char = CTRL('C');
X    (void) LIB$ENABLE_CTRL(&zero, &ctrl_mask);
X    /* Use the systems's values for lines and columns if it has any idea. */
X    if (sg.sm.page_length)
X	LI = sg.sm.page_length;
X    if (sg.sm.page_width)
X	CO = sg.sm.page_width;
X    /* Determine whether TTDRIVER is doing tab and/or form-feed expansion;
X       if so, we want to suppress that but also restore it at final exit. */
X    if ((sg.sm.tt_char & TT_SPECIAL_HANDLING) != TT_SPECIAL_HANDLING) {
X	tt_char_restore = sg.sm.tt_char;
X	tt_char_active	= sg.sm.tt_char |= TT_SPECIAL_HANDLING;
X#if 0		/*[ defer until setftty() ]*/
X	setctty();
X#endif 0
X    } else	/* no need to take any action */
X	tt_char_restore = tt_char_active = 0;
X}
X
X/* reset terminal to original state */
Xvoid
Xsettty(s)
Xchar *s;
X{
X	if (!bombing) {
X	    end_screen();
X	    if(s) Printf(s);
X	    (void) fflush(stdout);
X	}
X#ifdef MAIL	/* this is essential, or lib$spawn & lib$attach will fail */
X	SMG$DISABLE_BROADCAST_TRAPPING(&pasteboard_id);
X#endif
X#if 0		/* let SMG's exit handler do the cleanup (as per doc) */
X	SMG$DELETE_PASTEBOARD(&pasteboard_id);
X	SMG$DELETE_VIRTUAL_KEYBOARD(&kb),  kb = 0;
X#endif 0
X	if (ctrl_mask)
X	    (void) LIB$ENABLE_CTRL(&ctrl_mask, 0);
X	flags.echo = ON;
X	flags.cbreak = OFF;
X	if (tt_char_restore != 0) {
X	    sg.sm.tt_char = tt_char_restore;
X	    setctty();
X	}
X	settty_needed = FALSE;
X}
X
X#ifdef MAIL
Xstatic void
Xbroadcast_ast(dummy)
X{
X	extern volatile int broadcasts;
X
X	broadcasts++;
X}
X#endif
X
Xvoid
Xsetftty(){
X	unsigned int mask = LIB$M_CLI_CTRLT | LIB$M_CLI_CTRLY;
X
X	flags.cbreak = ON;
X	flags.echo = OFF;
X	(void) LIB$DISABLE_CTRL(&mask, 0);
X	if (kb == 0) {		/* do this stuff once only */
X	SMG$CREATE_VIRTUAL_KEYBOARD(&kb);
X	SMG$CREATE_PASTEBOARD(&pasteboard_id, 0, 0, 0, 0);
X	}
X#ifdef MAIL
X	/* note side effect: also intercepts hangup notification */
X	SMG$SET_BROADCAST_TRAPPING(&pasteboard_id, broadcast_ast, 0);
X#endif
X	/* disable tab & form-feed expansion */
X	if (tt_char_active != 0) {
X	    sg.sm.tt_char = tt_char_active;
X	    setctty();
X	}
X	start_screen();
X	settty_needed = TRUE;
X}
X
X
Xvoid
Xintron() {		/* enable kbd interupts if enabled when game started */
X}
X
Xvoid
Xintroff() {		/* disable kbd interrupts if required*/
X}
X
X
X/* fatal error */
X/*VARARGS1*/
Xvoid
Xerror VA_DECL(const char *,s)
X	VA_START(s);
X	VA_INIT(s, const char *);
X	if(settty_needed)
X		settty(NULL);
X	Vprintf(s,VA_ARGS);
X	(void) putchar('\n');
X	VA_END();
X	exit(1);
X}
END_OF_FILE
if test 6558 -ne `wc -c <'vms/vmstty.c'`; then
    echo shar: \"'vms/vmstty.c'\" unpacked with wrong size!
fi
# end of 'vms/vmstty.c'
fi
if test -f 'vms/vmsunix.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vms/vmsunix.c'\"
else
echo shar: Extracting \"'vms/vmsunix.c'\" \(8331 characters\)
sed "s/^X//" >'vms/vmsunix.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)vmsunix.c	3.0	88/04/13
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X/* This file collects some Unix dependencies; pager.c contains some more */
X
X/*
X * The time is used for:
X *	- seed for rand()
X *	- year on tombstone and yymmdd in record file
X *	- phase of the moon (various monsters react to NEW_MOON or FULL_MOON)
X *	- night and midnight (the undead are dangerous at midnight)
X *	- determination of what files are "very old"
X */
X
X#include "hack.h"
X
X#include <rms.h>
X#include <jpidef.h>
X#include <ssdef.h>
X#include <errno.h>
X#include <signal.h>
X#undef off_t
X#ifndef VAXC
X#include <sys/stat.h>
X#else   VAXC
X#include <stat.h>
X#endif  VAXC
X#include <ctype.h>
X#ifdef no_c$$translate
X#include <errno.h>
X#define C$$TRANSLATE(status) (errno = EVMSERR,  vaxc$errno = (status))
X#else   /* must link with vaxcrtl object library (/lib or /incl=c$$translate) */
Xextern FDECL(C$$TRANSLATE, (unsigned long));
X#endif
Xextern unsigned long SYS$PARSE(), SYS$SEARCH(), SYS$ENTER(), SYS$REMOVE();
Xextern unsigned long SYS$SETPRV();
Xextern unsigned long LIB$GETJPI(), LIB$SPAWN(), LIB$ATTACH();
X
Xint FDECL(link, (const char *, const char *));
X
Xvoid
Xsetrandom()
X{
X	(void) Srand((long) time ((time_t *) 0));
X}
X
Xstatic struct tm *
Xgetlt()
X{
X	time_t date;
X
X	(void) time(&date);
X	return(localtime(&date));
X}
X
Xint
Xgetyear()
X{
X	return(1900 + getlt()->tm_year);
X}
X
Xchar *
Xgetdate()
X{
X	static char datestr[7];
X	register struct tm *lt = getlt();
X
X	Sprintf(datestr, "%2d%2d%2d",
X		lt->tm_year, lt->tm_mon + 1, lt->tm_mday);
X	if(datestr[2] == ' ') datestr[2] = '0';
X	if(datestr[4] == ' ') datestr[4] = '0';
X	return(datestr);
X}
X
Xint
Xphase_of_the_moon()			/* 0-7, with 0: new, 4: full */
X{					/* moon period: 29.5306 days */
X					/* year: 365.2422 days */
X	register struct tm *lt = getlt();
X	register int epact, diy, goldn;
X
X	diy = lt->tm_yday;
X	goldn = (lt->tm_year % 19) + 1;
X	epact = (11 * goldn + 18) % 30;
X	if ((epact == 25 && goldn > 11) || epact == 24)
X		epact++;
X
X	return( (((((diy + epact) * 6) + 11) % 177) / 22) & 7 );
X}
X
Xint
Xnight()
X{
X	register int hour = getlt()->tm_hour;
X
X	return(hour < 6 || hour > 21);
X}
X
Xint
Xmidnight()
X{
X	return(getlt()->tm_hour == 0);
X}
X
Xstatic struct stat buf, hbuf;
X
Xvoid
Xgethdate(name) char *name; {
X	register char *np;
X
X	if(stat(name, &hbuf))
X		error("Cannot get status of %s.",
X			(np = rindex(name, ']')) ? np+1 : name);
X}
X
Xint
Xuptodate(fd)
Xint fd;
X{
X	if(fstat(fd, &buf)) {
X		pline("Cannot get status of saved level? ");
X		return(0);
X	}
X	if(buf.st_mtime < hbuf.st_mtime) {
X		pline("Saved level is out of date. ");
X		return(0);
X	}
X	return(1);
X}
X
Xstatic int
Xveryold(fd)
Xint fd;
X{
X	register int i;
X	time_t date;
X
X	if(fstat(fd, &buf)) return(0);			/* cannot get status */
X	if(buf.st_size != sizeof(int)) return(0);	/* not an xlock file */
X	(void) time(&date);
X	if(date - buf.st_mtime < 3L*24L*60L*60L) {	/* recent */
X		int lockedpid;	/* should be the same size as hackpid */
X		int status, dummy, code = JPI$_PID;
X
X		if(read(fd, (char *)&lockedpid, sizeof(lockedpid)) !=
X			sizeof(lockedpid))
X			/* strange ... */
X			return(0);
X  		if(!(!((status = LIB$GETJPI(&code, &lockedpid, 0, &dummy)) & 1)
X		     && status == SS$_NONEXPR))
X			return(0);
X	}
X	(void) close(fd);
X	for(i = 1; i <= MAXLEVEL+1; i++) {		/* try to remove all */
X		glo(i);
X		(void) delete(lock);
X	}
X	glo(0);
X	if(delete(lock)) return(0);			/* cannot remove it */
X	return(1);					/* success! */
X}
X
Xvoid
Xgetlock()
X{
X	register int i = 0, fd;
X
X#ifdef HARD
X	/* idea from rpick%ucqais@uccba.uc.edu
X	 * prevent automated rerolling of characters
X	 * test input (fd0) so that tee'ing output to get a screen dump still
X	 * works
X	 * also incidentally prevents development of any hack-o-matic programs
X	 */
X	if (isatty(0) <= 0)
X		error("You must play from a terminal.");
X#endif
X
X	(void) fflush(stdout);
X
X	/* we ignore QUIT and INT at this point */
X	if (link(HLOCK, LLOCK) == -1) {
X		register int errnosv = errno;
X
X		perror(HLOCK);
X		Printf("Cannot link %s to %s\n", LLOCK, HLOCK);
X		switch(errnosv) {
X		case ENOENT:
X		    Printf("Perhaps there is no (empty) file %s ?\n", HLOCK);
X		    break;
X		case EACCES:
X		    Printf("It seems you don't have write permission here.\n");
X		    break;
X		case EEXIST:
X		    Printf("(Try again or rm %s.)\n", LLOCK);
X		    break;
X		default:
X		    Printf("I don't know what is wrong.");
X		}
X		getret();
X		error("");
X		/*NOTREACHED*/
X	}
X
X	regularize(lock);
X	glo(0);
X	if(locknum > 25) locknum = 25;
X
X	do {
X		if(locknum) lock[0] = 'a' + i++;
X
X		if((fd = open(lock, 0)) == -1) {
X			if(errno == ENOENT) goto gotlock;    /* no such file */
X			perror(lock);
X			(void) unlink(LLOCK);
X			error("Cannot open %s", lock);
X		}
X
X		if(veryold(fd))	/* if true, this closes fd and unlinks lock */
X			goto gotlock;
X		(void) close(fd);
X	} while(i < locknum);
X
X	(void) unlink(LLOCK);
X	error(locknum ? "Too many hacks running now."
X		      : "There is a game in progress under your name.");
Xgotlock:
X	fd = creat(lock, FCMASK);
X	if(unlink(LLOCK) == -1)
X		error("Cannot unlink %s.", LLOCK);
X	if(fd == -1) {
X		error("cannot creat lock file.");
X	} else {
X		if(write(fd, (char *) &hackpid, sizeof(hackpid))
X		    != sizeof(hackpid)){
X			error("cannot write lock");
X		}
X		if(close(fd) == -1) {
X			error("cannot close lock");
X		}
X	}
X}	
X
Xvoid
Xregularize(s)	/* normalize file name */
Xregister char *s;
X{
X	register char *lp;
X
X	for (lp = s; *lp; lp++)         /* note: '-' becomes '_' */
X	    if (!(isalpha(*lp) || isdigit(*lp) || *lp == '$'))
X			*lp = '_';
X}
X
Xint link(file, new)
Xconst char *file, *new;
X{
X    unsigned long status;
X    struct FAB fab;
X    struct NAM nam;
X    unsigned short fid[3];
X    char esa[NAM$C_MAXRSS];
X
X    fab = cc$rms_fab;
X    fab.fab$l_fop = FAB$M_OFP;
X    fab.fab$l_fna = file;
X    fab.fab$b_fns = strlen(file);
X    fab.fab$l_nam = &nam;
X
X    nam = cc$rms_nam;
X    nam.nam$l_esa = esa;
X    nam.nam$b_ess = NAM$C_MAXRSS;
X
X    if (!((status = SYS$PARSE(&fab)) & 1)
X	|| !((status = SYS$SEARCH(&fab)) & 1))
X    {
X	C$$TRANSLATE(status);
X	return -1;
X    }
X
X    fid[0] = nam.nam$w_fid[0];
X    fid[1] = nam.nam$w_fid[1];
X    fid[2] = nam.nam$w_fid[2];
X
X    fab.fab$l_fna = new;
X    fab.fab$b_fns = strlen(new);
X
X    if (!((status = SYS$PARSE(&fab)) & 1))
X    {
X	C$$TRANSLATE(status);
X	return -1;
X    }
X
X    nam.nam$w_fid[0] = fid[0];
X    nam.nam$w_fid[1] = fid[1];
X    nam.nam$w_fid[2] = fid[2];
X
X    nam.nam$l_esa = nam.nam$l_name;
X    nam.nam$b_esl = nam.nam$b_name + nam.nam$b_type + nam.nam$b_ver;
X
X    if (!((status = SYS$ENTER(&fab)) & 1))
X    {
X	C$$TRANSLATE(status);
X	return -1;
X    }
X
X    return 0;
X}
X
X#undef unlink
Xint unlink(file)
Xconst char *file;
X{
X    int status;
X    struct FAB fab = cc$rms_fab;
X    struct NAM nam = cc$rms_nam;
X    char esa[NAM$C_MAXRSS];
X
X    fab.fab$l_fop = FAB$M_DLT;
X    fab.fab$l_fna = (char *) file;
X    fab.fab$b_fns = strlen(file);
X    fab.fab$l_nam = &nam;
X    nam.nam$l_esa = esa;
X    nam.nam$b_ess = NAM$C_MAXRSS;
X
X    if (!((status = SYS$PARSE(&fab)) & 1)
X	|| !((status = SYS$REMOVE(&fab)) & 1))
X    {
X	C$$TRANSLATE(status);
X	return -1;
X    }
X
X    return 0;
X}
X
X#undef creat
Xint vms_creat(file, mode)
Xchar *file;
Xunsigned int mode;
X{
X    if (index(file, ';'))
X	(void) delete(file);
X    return creat(file, mode);
X}
X
X#undef getuid
Xint
Xvms_getuid()
X{
X    return (getgid() << 16) | getuid();
X}
X
X#if defined(CHDIR) || defined(SHELL)
Xunsigned int oprv[2];
X
Xvoid
Xprivoff()
X{
X    unsigned long prv[2] = { -1, -1 }, code = JPI$_PROCPRIV;
X
X    (void) SYS$SETPRV(0, prv, 0, oprv);
X    (void) LIB$GETJPI(&code, 0, 0, prv);
X    (void) SYS$SETPRV(1, prv, 0, 0);
X}
X
Xvoid
Xprivon()
X{
X    (void) SYS$SETPRV(1, oprv, 0, 0);
X}
X#endif  /*CHDIR || SHELL*/
X
X#ifdef SHELL
Xunsigned long dosh_pid = 0;
X
Xint
Xdosh()
X{
X	int status;
X
X	settty((char *) NULL);	/* also calls end_screen() */
X	(void) signal(SIGINT,SIG_DFL);
X	(void) signal(SIGQUIT,SIG_IGN);
X	if (!dosh_pid || !((status = LIB$ATTACH(&dosh_pid)) & 1))
X	{
X#ifdef CHDIR
X		(void) chdir(getenv("PATH"));
X#endif
X		privoff();
X		dosh_pid = 0;
X		status = LIB$SPAWN(0, 0, 0, 0, 0, &dosh_pid);
X		privon();
X#ifdef CHDIR
X		chdirx((char *) 0, 0);
X#endif
X	}
X	gettty();
X	setftty();
X	(void) signal(SIGINT, (SIG_RET_TYPE) done1);
X#ifdef WIZARD
X	if(wizard) (void) signal(SIGQUIT,SIG_DFL);
X#endif
X	docrt();
X	if (!(status & 1))
X	    pline("Spawn failed.  Try again.");
X	return 0;
X}
X#endif
END_OF_FILE
if test 8331 -ne `wc -c <'vms/vmsunix.c'`; then
    echo shar: \"'vms/vmsunix.c'\" unpacked with wrong size!
fi
# end of 'vms/vmsunix.c'
fi
echo shar: End of archive 49 \(of 56\).
cp /dev/null ark49isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 56 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
    echo Building monst.c from monst.c1 and monst.c2
    cat src/monst.c1 src/monst.c2 > src/monst.c
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
