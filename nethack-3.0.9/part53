Path: utzoo!utgpu!news-server.csri.toronto.edu!mailrus!cornell!uw-beaver!zephyr.ens.tek.com!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v10i098:  nethack3p9 -  display oriented dungeons & dragons (Ver. 3.0i), Part53/56
Message-ID: <5958@tekred.CNA.TEK.COM>
Date: 13 Jul 90 19:46:02 GMT
Sender: news@tekred.CNA.TEK.COM
Lines: 1987
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 10, Issue 98
Archive-name: nethack3p9/Part53
Supersedes: NetHack3: Volume 7, Issue 56-93



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 53 (of 56)."
# Contents:  Files Makefile.top auxil/lev_comp.6 auxil/opthelp
#   auxil/oracles include/global.h include/macconf.h include/mondata.h
#   include/tradstdc.h include/you.h src/alloc.c src/lev_main.c
#   src/worn.c
# Wrapped by billr@saab on Wed Jul 11 17:12:16 1990
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'Files' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Files'\"
else
echo shar: Extracting \"'Files'\" \(4583 characters\)
sed "s/^X//" >'Files' <<'END_OF_FILE'
XThis is a listing of all files in a full NetHack 3.0 distribution, organized
Xin their standard manner on a UNIX system.  It indicates which files are 
Xnecessary for which versions, so that you can tell which files may be deleted
Xfrom or not transferred to your system if you wish.
X
X
X(files in top directory)
XFiles           Install.ami     Install.dos     Install.mac     Install.ovl
XInstall.unix    Install.vms     Makefile.top    Porting         README
X
Xamiga:
X(files for Amiga version)
XGBinfo.uu       Makefile.ami    NHScore.uu      NHinfo.uu       NetHack.cnf
XNewGame.uu      ami.lnk         amidos.c        amifont.uu      amifont8.uu
Xamimenu.c       amitcap.c       amitty.c        amiunix.c       amiwbench.c
Xamiwind.c       compact.lat     dflticon.uu
X
Xauxil:
X(files for all versions)
XGuidebook.mn    Guidebook.mss   Guidebook.tex   castle.des      cmdhelp
Xdata.base       endgame.des     help            hh              history
Xlicense         opthelp         oracles         rumors.fal      rumors.tru
Xtmac.n          tower.des
X(files for UNIX versions)
XMakefile.auxil  lev_comp.6      nethack.6       nethack.sh
X(file for Macintosh version)
XMacHelp
X
Xinclude:
X(files for all versions)
XMacAlert.h      amiconf.h       artifact.h      attrib.h        color.h
Xconfig.h        coord.h         decl.h          def_os2.h       edog.h
Xepri.h          eshk.h          extern.h        flag.h          func_tab.h
Xglobal.h        gold.h          hack.h          lev.h           macconf.h
Xmfndpos.h       mkroom.h        monattk.h       mondata.h       monflag.h
Xmonst.h         monsym.h        msdos.h         obj.h           objclass.h
Xpatchlevel.h    pcconf.h        permonst.h      prop.h          rm.h
Xsp_lev.h        spell.h         system.h        termcap.h       tosconf.h
Xtradstdc.h      trampoli.h      trap.h          unixconf.h      vault.h
Xvmsconf.h       wseg.h          you.h           youprop.h
X(file for special level compiler (STRONGHOLD option))
Xlev_comp.h
X
Xmac:
X(files for Macintosh version)
XMD.proj.hqx     MD.rsrc.hqx     MacAlert.c      NH.proj.hqx     NH.rsrc.hqx
XSL.proj.hqx     Segments.mac    mac.c           macfile.c       macinit.c
X
Xothers:
X(files for MSDOS (and OS/2) version)
XMakefile.lib    Makefile.msc    Makefile.os2    Makefile.ovl    Makefile.pc
XMakefile.tcc    NetHack.cnf     exesmurf.c      exesmurf.uu     maintain.ovl
Xovlmgr.asm      ovlmgr.doc      ovlmgr.uu       splitf.c        splitf.uu
Xsuputils.ovl    termcap.uu      trampoli.c
X(file for MSDOS and VMS versions)
Xtermcap
X(files for MSDOS, Amiga, and Atari versions)
Xlev_lex.c       pcmain.c
X(files for MSDOS and Atari versions)
Xmsdos.c         pctty.c         pcunix.c
X(files for Atari version)
XMakefile.st     atari.cnf       atarifnt.uue
X(Berkeley random number file, which may be included in any version)
Xrandom.c
X
Xsrc:
X(files for all versions)
Xallmain.c       alloc.c         apply.c         artifact.c      attrib.c
Xbones.c         cmd.c           dbridge.c       decl.c          demon.c
Xdo.c            do_name.c       do_wear.c       dog.c           dogmove.c
Xdokick.c        dothrow.c       eat.c           end.c           engrave.c
Xexper.c         extralev.c      fountain.c      getline.c       hack.c
Xinvent.c        ioctl.c         lock.c          mail.c          makedefs.c
Xmakemon.c       mcastu.c        mhitm.c         mhitu.c         mklev.c
Xmkmaze.c        mkobj.c         mkroom.c        mon.c           mondata.c
Xmonmove.c       monst.c         mthrowu.c       music.c         o_init.c
Xobjects.c       objnam.c        options.c       pager.c         panic.c
Xpickup.c        polyself.c      potion.c        pray.c          pri.c
Xpriest.c        prisym.c        read.c          restore.c       rip.c
Xrnd.c           rumors.c        save.c          search.c        shk.c
Xshknam.c        sit.c           sounds.c        sp_lev.c        spell.c
Xsteal.c         termcap.c       timeout.c       topl.c          topten.c
Xtrack.c         trap.c          u_init.c        uhitm.c         vault.c
Xversion.c       weapon.c        were.c          wield.c         wizard.c
Xworm.c          worn.c          write.c         zap.c
X(files for special level compiler (STRONGHOLD option))
Xlev_comp.c      lev_comp.l      lev_comp.y      lev_lex.c       lev_main.c
X(files for UNIX versions)
XMakefile.src    unixmain.c      unixtty.c       unixunix.c
X
Xvms:
X(files for VMS version)
Xinstall.com     lev_lex.h       oldcrtl.c       spec_lev.com    vmsbuild.com
Xvmsmain.c       vmsmisc.c       vmstty.c        vmsunix.c
X(GNU termcap files that support VMS version)
Xvmstermcap.c    vmstparam.c
END_OF_FILE
if test 4583 -ne `wc -c <'Files'`; then
    echo shar: \"'Files'\" unpacked with wrong size!
fi
# end of 'Files'
fi
if test -f 'Makefile.top' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile.top'\"
else
echo shar: Extracting \"'Makefile.top'\" \(4110 characters\)
sed "s/^X//" >'Makefile.top' <<'END_OF_FILE'
X#	Hack Makefile.
X#	SCCS Id: @(#)Makefile.top	3.0	89/03/23
X
X# newer makes predefine $(MAKE) to 'make' and do smarter processing of
X# recursive make calls if $(MAKE) is used
X# these makes allow $(MAKE) to be overridden by the environment if someone
X# wants to (or has to) use something other than the standard make, so we do
X# not want to unconditionally set $(MAKE) here
X#
X# unfortunately, some older makes do not predefine $(MAKE); if you have one of
X# these, uncomment the following line
X# (you will know that you have one if you get complaints about unable to
X# execute things like 'data' and 'rumors')
X# MAKE = make
X
X# make NetHack
XGAME     = nethack
XGAMEUID  = games
XGAMEGRP  = bin
X
X# GAMEDIR also appears in config.h as "HACKDIR".
X#
X# note that 'make install' believes in creating a nice tidy GAMEDIR for
X# installation, free of debris from previous NetHack versions --
X# therefore there should not be anything in GAMEDIR that you want to keep
X# (if there is, you'll have to do the installation by hand or modify the
X# instructions)
XGAMEDIR  = /usr/games/lib/$(GAME)dir
XSHELLDIR = /usr/games
XMANDIR   = /usr/man/man6
XMANEXT   = 6
X
X# manual installation for most BSD-style systems
XGAMEMANCREATE = cp auxil/nethack.6
XLEVMANCREATE = cp auxil/lev_comp.6
X# manual installation for most SYSV-style systems
X# GAMEMANCREATE = nroff -man auxil/nethack.6 >
X# LEVMANCREATE = nroff -man auxil/lev_comp.6 >
X
XAUXHELP = help hh cmdhelp history opthelp oracles
XVARAUX = data rumors
XSPEC_LEVS = endgame castle tower1 tower2 tower3
XAUX = $(AUXHELP) $(VARAUX) $(SPEC_LEVS) license
X
X$(GAME):
X	( cd src ; $(MAKE) )
X
Xall:	$(GAME) Guidebook data rumors spec_levs
X	@echo "Done."
X
XGuidebook:
X	( cd auxil ; $(MAKE) Guidebook )
X
Xdata:
X	( cd auxil ; $(MAKE) data )
X
Xrumors:
X	( cd auxil ; $(MAKE) rumors )
X
Xspec_levs:
X	( cd src ; $(MAKE) lev_comp )
X	( cd auxil ; $(MAKE) spec_levs )
X	
Xupdate: $(GAME) data rumors spec_levs
X# copy over new versions of the game files
X	( cd auxil ; cp $(AUX) $(GAMEDIR) )
X#	(don't yank the old version out from under people who're playing it)
X	-mv $(GAMEDIR)/$(GAME) $(GAMEDIR)/$(GAME).old
X	cp src/$(GAME) $(GAMEDIR)
X	-rm -f $(SHELLDIR)/$(GAME)
X	sed -e 's;/usr/games/lib/nethackdir;$(GAMEDIR);' \
X		-e 's;HACKDIR/nethack;HACKDIR/$(GAME);' \
X		< auxil/nethack.sh \
X		> $(SHELLDIR)/$(GAME)
X# correct the permissions on the new versions
X	-( cd $(GAMEDIR) ; chown $(GAMEUID) $(AUX) $(GAME) ; \
X			chgrp $(GAMEGRP) $(AUX) $(GAME) ; \
X			chmod 644 $(AUX) )
X	-chown $(GAMEUID) $(SHELLDIR)/$(GAME)
X	chgrp $(GAMEGRP) $(SHELLDIR)/$(GAME)
X	chmod 0755 $(SHELLDIR)/$(GAME)
X	chmod 04755 $(GAMEDIR)/$(GAME)
X# touch time-sensitive files
X	-touch -c $(GAMEDIR)/bones* $(GAMEDIR)/?lock* $(GAMEDIR)/wizard*
X	-touch -c $(GAMEDIR)/save/*
X	touch $(GAMEDIR)/perm $(GAMEDIR)/record
X# and copy the man pages
X	-$(GAMEMANCREATE) $(MANDIR)/$(GAME).$(MANEXT)
X	-$(LEVMANCREATE) $(MANDIR)/lev_comp.$(MANEXT)
X
Xinstall: $(GAME) data rumors spec_levs
X# set up the directories
X	-mkdir $(SHELLDIR)
X	-rm -rf $(GAMEDIR)
X	-mkdir $(GAMEDIR) $(GAMEDIR)/save
X# create some files
X	touch $(GAMEDIR)/perm $(GAMEDIR)/record $(GAMEDIR)/logfile
X# copy over the game files
X	( cd auxil ; cp $(AUX) $(GAMEDIR) )
X	cp src/$(GAME) $(GAMEDIR)
X	-rm -f $(SHELLDIR)/$(GAME)
X	sed -e 's;/usr/games/lib/nethackdir;$(GAMEDIR);' \
X		-e 's;HACKDIR/nethack;HACKDIR/$(GAME);' \
X		< auxil/nethack.sh \
X		> $(SHELLDIR)/$(GAME)
X# set up the permissions
X	-chown $(GAMEUID) $(SHELLDIR)/$(GAME) $(GAMEDIR) $(GAMEDIR)/*
X	chgrp $(GAMEGRP) $(SHELLDIR)/$(GAME) $(GAMEDIR) $(GAMEDIR)/*
X	chmod 0755 $(SHELLDIR)/$(GAME)
X	chmod 644 $(GAMEDIR)/*
X	chmod 755 $(GAMEDIR) $(GAMEDIR)/save
X	chmod 04755 $(GAMEDIR)/$(GAME)
X# and copy the man pages
X	-$(GAMEMANCREATE) $(MANDIR)/$(GAME).$(MANEXT)
X	-$(LEVMANCREATE) $(MANDIR)/lev_comp.$(MANEXT)
X
X# 'make clean' removes all the .o files, but leaves around all the executables
X# and compiled data files
Xclean:
X	( cd src ; $(MAKE) clean )
X
X# 'make spotless' returns the source tree to near-distribution condition.
X# it removes .o files, executables, and compiled data files
Xspotless:
X	( cd src ; $(MAKE) spotless )
X	( cd auxil ; $(MAKE) spotless )
END_OF_FILE
if test 4110 -ne `wc -c <'Makefile.top'`; then
    echo shar: \"'Makefile.top'\" unpacked with wrong size!
fi
# end of 'Makefile.top'
fi
if test -f 'auxil/lev_comp.6' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'auxil/lev_comp.6'\"
else
echo shar: Extracting \"'auxil/lev_comp.6'\" \(4551 characters\)
sed "s/^X//" >'auxil/lev_comp.6' <<'END_OF_FILE'
X.TH LEV_COMP 6 "5 July 1989"
X.UC 4
X.SH NAME
Xlev_comp \- NetHack special levels compiler
X.SH SYNOPSIS
X.B lev_comp
X[
X.I files
X]
X.PP
XIf no arguments are given, it reads standard input.
X.SH DESCRIPTION
X.PP
X.I Lev_comp
Xis a special level compiler for NetHack version 3.0 and higher.  It
Xtakes description files as arguments and produces level files that can
Xbe loaded by NetHack at runtime.
X.PP
XThe purpose of this tool is to provide NetHack administrators and
Ximplementors with a convenient way for adding special levels to the
Xgame, or modifying existing ones, without having to recompile the
Xentire world.  At this time, the special levels code is not fully
Ximplemented, as the decision to load the special levels is hard-coded
Xin the game.  In a future release, it is expected to be a run-time
Xdecision.
X.SH GRAMMAR
X.PP
X.LP
X.nf
X.ta +8n +8n +8n +8n
X
Xfile		: /* nothing */
X		| levels
X
Xlevels		: level
X		| levels level
X
Xlevel		: maze_level
X
Xmaze_level	: maze_definition regions
X
Xmaze_definition	: "MAZE" ':' filename
X
Xfilename	: STRING
X
Xregions		: region
X		| regions region
X
Xregion		: map_definition reg_initialization map_details
X
Xmap_definition	: map_geometry map
X
Xmap_geometry	: "GEOMETRY" ':' hjustif ',' vjustif
X
Xhjustif		: "left" | "center" | "right"
X
Xvjustif		: "top" | "center" | "bottom"
X
Xmap		: "MAP\\n" map_lines "ENDMAP"
X
Xmap_lines	: map_line
X		| map_lines map_line
X
Xmap_line	: map_chars '\\n'
X
Xmap_chars	: map_char
X		| map_chars map_char
X
Xmap_char	: '-' | '|' | '{' | '}' | '+' | 'S'
X		| 'K' | '\\' | '#' | '.' | ' '
X
Xreg_initialization : /* nothing */
X		   | reg_initialization init_reg
X
Xinit_reg	: "RANDOM_OBJECTS" ':' object_list
X		| "RANDOM_PLACES" ':' place_list
X		| "RANDOM_MONSTERS" ':' monster_list
X
Xobject_list	: object
X		| object_list ',' object
X
Xplace_list	: place
X		| place_list ',' place
X
Xmonster_list	: monster
X		| monster_list ',' monster
X
Xmap_details	: /* nothing */
X		: map_details map_detail
X
Xmap_detail	: monster_detail
X		| object_detail
X		| door_detail
X		| trap_detail
X		| drawbridge_detail
X		| region_detail
X		| altar_detail
X		| mazewalk_detail
X		| ladder_detail
X		| diggable_detail
X
Xmonster_detail	: "MONSTER" ':' monster_c ',' m_name ',' coordinate
X
Xobject_detail	: "OBJECT" ':' object_c ',' o_name ',' coordinate
X
Xdoor_detail	: "DOOR" ':' door_state ',' coordinate
X
Xtrap_detail	: "TRAP" ':' trap_name ',' coordinate
X
Xdrawbridge_detail : "DRAWBRIDGE" ':' coordinate ',' direction ',' open
X
Xmazewalk_detail	: "MAZEWALK" ':' coordinate ',' direction
X
Xladder_detail	: "LADDER" ':' coordinate ',' up_or_down
X
Xdiggable_detail	: "NON_DIGGABLE" ':' rectangle
X
Xaltar_detail	: "ALTAR" ':' coordinate ',' alignment ',' altar_type
X
Xregion_detail	: "REGION" ':' rectangle ',' light_state ',' room_type
X
Xmonster_c	: CHAR
X		| "random"
X		| m_register
X
Xobject_c	: CHAR
X		| "random"
X		| o_register
X
Xm_name		: STRING
X		| "random"
X
Xo_name		: STRING
X		| "random"
X
Xtrap_name	: STRING
X		| "random"
X
Xlight_state	: "lit" | "unlit"
X		| "random"
X
Xroom_type	: STRING
X		| "random"
X
Xcoordinate	: place
X		| p_register
X		| "random"
X
Xdoor_state	: "open" | "closed" | "locked" | "broken" | "nodoor"
X		| "random"
X
Xopen_or_closed	: "open" | "closed"
X
Xalignment	: "law" | "neutral" | "chaos"
X		| a_register
X		| "random"
X
Xaltar_type	: "shrine" | "altar"
X		| "random"
X
Xp_register	: "place" '[' INTEGER ']'
X
Xo_register	: "object" '[' INTEGER ']'
X
Xm_register	: "monster" '[' INTEGER ']'
X
Xa_register	: "altar" '[' { 0 | 1 | 2 } ']'
X
Xplace		: '(' INTEGER ',' INTEGER ')'
X
Xrectangle	: '(' INTEGER ',' INTEGER ',' INTEGER ',' INTEGER ')'
X.fi
X.PP
X.I NOTE:
X.br
XLines beginning with '#' are considered comments.
X
X.SH EXAMPLE
X.PP
XHere is an example of a description file (a very simple one):
X.LP
X.nf
X.ta +8n +8n +8n
XMAZE : "fortress"
XGEOMETRY : center , center
XMAP
X}}}}}}}}}
X}}}|-|}}}
X}}|-.-|}}
X}|-...-|}
X}|.....|}
X}|-...-|}
X}}|-.-|}}
X}}}|-|}}}
X}}}}}}}}}
XENDMAP
XMONSTER: '@', "Wizard of Yendor", (4,4)
XOBJECT: '"', "Amulet of Yendor", (4,4)
X# a hell hound flanking the Wiz on a random side
XRANDOM_PLACES: (4,3), (4,5), (3,4), (5,4)
XMONSTER: 'd', "hell hound", place[0]
X# a chest on another random side
XOBJECT: '(', "chest", place[1]
X# a random dragon somewhere
XMONSTER: 'D', random, random
X# a random trap in the EAST end
XTRAP: random, (6,4)
X# an electric eel below the SOUTH end
XMONSTER: ';', "electric eel", (4,8)
X# make the walls non-diggable
XNON_DIGGABLE: (0,0,8,8)
X.fi
X.PP
XThis example will produce a file named "fortress" that can be integrated into
Xone of the numerous mazes of the game.
X
X.SH AUTHOR
X.PP
XJean-Christophe Collet.
X.SH BUGS
X.PP
XProbably infinite.
END_OF_FILE
if test 4551 -ne `wc -c <'auxil/lev_comp.6'`; then
    echo shar: \"'auxil/lev_comp.6'\" unpacked with wrong size!
fi
# end of 'auxil/lev_comp.6'
fi
if test -f 'auxil/opthelp' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'auxil/opthelp'\"
else
echo shar: Extracting \"'auxil/opthelp'\" \(4025 characters\)
sed "s/^X//" >'auxil/opthelp' <<'END_OF_FILE'
XBoolean options available in all versions (with default values in []):
X
Xconfirm		ask before hitting tame or peaceful monsters  [TRUE]
XDECgraphics	use DEC/VT line-drawing characters for the dungeon [FALSE]
X(fe)male	sex of the player (may only be set on startup)  [MALE]
Xfixinv		try to retain the same letter for the same object  [TRUE]
Xhelp		print all available info when using the / command [TRUE]
XIBMgraphics	use IBM extended characters for the dungeon [FALSE]
Xignintr		ignore interrupt signal, including breaks  [FALSE]
Xnumber_pad	use the number keys to move instead of yuhjklbn  [FALSE]
Xpickup		automatically pick up objects you move over  [TRUE]
Xrest_on_space	count the space bar as a rest character  [FALSE]
Xsafe_pet	prevent you from (knowingly) attacking your pet(s)  [TRUE]
Xsilent		don't use your terminal's bell sound  [TRUE]
Xsortpack	group similar kinds of objects in inventory  [TRUE]
Xtime		display elapsed game time, in moves  [FALSE]
Xtombstone	print tombstone when you die  [TRUE]
Xverbose		print more commentary during the game  [TRUE]
X
XThere are further Boolean options that exist in some versions of NetHack 3.0.
X(You can tell which options exist in your version by checking the short
Xoption help, which is reached by 'O?'.)
X 
XBoolean option if NEWS was set at compile time:
Xnews		print any news from game administrator on startup  [TRUE]
X
XBoolean options if you are using MS-DOS and DGK was set at compile time:
XIBM_BIOS	allow the use of IBM ROM BIOS calls  [FALSE]
Xrawio		allow the use of raw I/O (may only be set on startup)  [FALSE]
X
XBoolean options if DGK was not set at compile time:
Xnull		allow nulls to be sent to your terminal  [TRUE]
X		try turning this option off (forcing NetHack to use its own
X		delay code) if moving objects seem to teleport across rooms
Xstandout	use standout mode for --More-- on messages  [FALSE]
X
XBoolean option if TEXTCOLOR was set at compile time:
Xcolor		use different colors for objects on screen  [TRUE]
X
XAny Boolean option can be negated by prefixing it with a '!' or 'no'.
X
X 
X
X
X 
XCompound options are written as option_name:option_value.
XCompound options which can be set during the game are:
X
Xpackorder	a list of default symbols for kinds of objects that gives the
X		order in which your pack will be displayed
X		If you specify only some kinds of items, the others from the
X		default order will be appended to the end.  [")[%?+!=/(*`0_]
Xendgame		the parts of the score list you wish to see when the game ends
X		You choose a combination of top scores, scores around that of
X		the ending game, and all of your own scores.
X		[!own/3 top/2 around]
Xfruit		the name of a fruit you enjoy eating
X		(basically a whimsy which NetHack uses from time to time)
X		[slime mold]
X
XCompound options which may be set only on startup are:
X
Xname		the name of your character
X		[obtained by asking the system or the player]
Xdogname		the name of your first dog  [NONE]
Xcatname		the name of your first cat  [NONE]
X 
Xgraphics	a list of symbols to be used in place of the default ones for
X		drawing the dungeon
X		The symbols are subjected to a fair amount of processing, so
X		that you can use C-style escapes such as \n or \081 as well as
X		indicate control characters by ^x or meta characters by \Mx.
X		As usual, \ can force the next character to be taken literally.
X		Since many of the default symbols are overloaded, they are
X		given here by name instead of symbol, with some added notes.
X		[stone                               (solid rock, normally ' ')
X		vwall hwall tlcorn trcorn blcorn brcorn       (room boundaries)
X		crwall tuwall tdwall tlwall trwall  (wallified maze characters)
X		vbeam hbeam lslant rslant			    (zap beams)
X		ndoor vodoor hodoor cdoor   (no, vert-open, horiz-open, closed)
X		room corr upstair dnstair trap web pool
X		fountain sink throne altar
X		upladder dnladder vdbridge hdbridge]
X
XSome sample options lists are
X!pickup,!tombstone,name:Gandalf,endgame:own/3 top/2 around
Xfemale,nonews,dogname:Rover,graphics: |--------|||-\\/+.#<>\^\"}{#\\_<>##
Xrest_on_space,!verbose
END_OF_FILE
if test 4025 -ne `wc -c <'auxil/opthelp'`; then
    echo shar: \"'auxil/opthelp'\" unpacked with wrong size!
fi
# end of 'auxil/opthelp'
fi
if test -f 'auxil/oracles' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'auxil/oracles'\"
else
echo shar: Extracting \"'auxil/oracles'\" \(4396 characters\)
sed "s/^X//" >'auxil/oracles' <<'END_OF_FILE'
XIf thy wand hath run out of charges, thou mayst zap it again and again; though
Xnaught will happen at first, verily, thy persistence shall be rewarded, as
Xone last charge may yet be wrested from it!
X-----
XTo complete thy quest, thou needs must enter the infernal regions.  If thou
Xhast not immunity to fire, such a trip will surely prove to be thy last;
Xprepare thyself in advance.
X-----
XThough the shopkeepers be wary, thieves have nevertheless stolen much by using
Xtheir digging wands to hasten exits through the pavement.
X-----
XIf thou hast had trouble with rust on thy armor or weapons, thou shouldst know
Xthat thou canst prevent this by, while in a confused state, reading the magical
Xparchments which normally are used to cause their enchantment.
X-----
XBehold the cockatrice, whose diminutive stature belies its hidden might.  The
Xcockatrice can petrify any ordinary being it contacts--save those wise
Xadventurers who eat a dead lizard or blob of acid when they feel themselves
Xslowly turning to stone.
X-----
XWhile some armor protects against magical attacks, few types compare to the
Xitems which come from the elven regions, though iron or crystalline plate
Xmail have similar good qualities.
X-----
XIt is well known among travelers that extra-healing draughts may clear thy
Xsenses when thou art addled by hallucinations.  But never forget, the lowly
Xpotion which makes one sick may be used for the same purpose.
X-----
XIf thou hast been confused, thy head may be set straight if thou eatest a
Xdead lizard and waitest, or drinkest water of the utmost holiness.
X-----
XIf thou wishest to reach deep levels, thou must be able to control thy tele-
Xports, and be confused, and read the scroll which usually teleports thyself
Xaround on the level.  Daring adventurers have also performed the same feat
Xsans need for scrolls or potions by stepping on the correct type of trap.
X-----
XAlmost all adventurers who come this way hope to pass the dread Medusa.  To
Xdo this, the best advice is to keep thine eyes blindfolded and to cause the
Xcreature to espy its own reflection in a mirror.
X-----
XAnd where it is written "ad aerarium", diligent searching will often reveal
Xthe way to a trap which sends one to the Magic Memory Vault, where the riches
Xof Croesus are stored; however, escaping from the vault with its gold is much
Xharder than getting in.
X-----
XIt is well known that wily shopkeepers doth raise their prices whene'er they
Xespy the garish apparel of the approaching tourist or the countenance of a
Xdisfavored patron.  They favor the gentle of manner and the fair of face.
XThe boor may expect unprofitable transactions.
X-----
XThe cliche of the kitchen sink swallowing any unfortunate rings that contact
Xits pernicious surface reflecteth greater truth than many homilies, yet
Xeven so, few hath developed the skill to identify enchanted rings by the
Xtransfigurations effected upon the voracious device's frame.
X-----
XThe meat of enchanted creatures will ofttimes convey magical properties
Xunto the consumer.  A fresh corpse of floating eye doth fetch a high
Xprice among wizards for its utility in conferring Telepathy, by which
Xthe sightless may locate surrounding minds.
X-----
XThe detection of blessings and curses is in the domain of the gods.  They will
Xmake this information available to mortals who request it at their places of
Xworship, or elsewhere for those mortals who devote themselves to the service
Xof the gods.
X-----
XThe elven dagger Sting is famed for its abilities against all creatures of the
Xorcish race.  It will glow when such monsters approach, and cause them special
Xinjury.
X-----
XAdventurers searching for Medusa or the Wizard of Yendor needst not wait until
Xtheir dungeon level corresponds with their enemies' to know their location.
XEat a floating eye, blind thyself, and use a mirror in thine own direction,
Xand provided thou art lucky, thou shalt know the approximate locations of
Xthine enemies.
X-----
XIn the nethermost recesses of the dungeon, there standeth a castle, wherein
Xlayeth a wand of wishes.  If thou wouldst gain entry, bear with thee an
Xinstrument of music, for the drawbridge may be charmed down with the proper
Xmelody.  What notes comprise it only the gods know, but a musical mastermind
Xmay yet succeed by witful improvization.  However, the less perspicacious are
Xnot without recourse, should they be prepared to circumambulate the castle to
Xthe postern.
END_OF_FILE
if test 4396 -ne `wc -c <'auxil/oracles'`; then
    echo shar: \"'auxil/oracles'\" unpacked with wrong size!
fi
# end of 'auxil/oracles'
fi
if test -f 'include/global.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/global.h'\"
else
echo shar: Extracting \"'include/global.h'\" \(4792 characters\)
sed "s/^X//" >'include/global.h' <<'END_OF_FILE'
X/*	SCCS Id: @(#)global.h	3.0	89/11/08
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#ifndef GLOBAL_H
X#define	GLOBAL_H
X
X#include <stdio.h>
X
X
X/* #define BETA		/* if a beta-test copy  [MRS] */
X#define VERSION "3.0i"  /* version number. */
X
X/*
X * Files expected to exist in the playground directory.
X */
X
X#define RECORD		"record"  /* a file containing list of topscorers */
X#define	HELP		"help"	  /* a file containing command descriptions */
X#define	SHELP		"hh"	  	/* abbreviated form of the same */
X#define	RUMORFILE	"rumors"	/* a file with fortune cookies */
X#define ORACLEFILE	"oracles"	/* a file with oracular information */
X#define	DATAFILE	"data"	/* a file giving the meaning of symbols used */
X#define CMDHELPFILE	"cmdhelp"	/* file telling what commands do */
X#define HISTORY		"history"	/* a file giving nethack's history */
X#define LICENSE		"license"	/* file with license information */
X#define OPTIONFILE	"opthelp"	/* a file explaining runtime options */
X#ifdef MACOS
X#define MACHELP		"MacHelp"	/* file with Macintosh information */
X#endif
X
X
X/* Assorted definitions that may depend on selections in config.h. */
X
X/*
X * for DUMB preprocessor and compiler, e.g., cpp and pcc supplied
X * with Microport SysV/AT, which have small symbol tables;
X * DUMB if needed is defined in CFLAGS
X */
X#ifdef DUMB
X#ifdef BITFIELDS
X#undef BITFIELDS
X#endif
X#ifndef STUPID
X#define STUPID
X#endif
X#ifndef STUPID_CPP
X#define STUPID_CPP
X#endif
X#endif	/* DUMB */
X
X/*
X * type xchar: small integers in the range 0 - 127, usually coordinates
X * although they are nonnegative they must not be declared unsigned
X * since otherwise comparisons with signed quantities are done incorrectly
X */
Xtypedef schar	xchar;
Xtypedef	xchar	boolean;		/* 0 or 1 */
X
X#ifndef MACOS
X#ifndef TRUE		/* defined in some systems' native include files */
X#define	TRUE	((boolean)1)
X#define	FALSE	((boolean)0)
X#endif
X#endif
X
X#ifdef BITFIELDS
X#define	Bitfield(x,n)	unsigned x:n
X#else
X#define	Bitfield(x,n)	uchar x
X#endif
X
X/*
X * According to ANSI, prototypes for old-style declarations must widen the
X * arguments to int.  However, the MSDOS compilers accept shorter arguments
X * (char, short, etc.) in prototypes and do typechecking with them.  Therefore
X * this mess to allow the better typechecking while also allowing some
X * prototypes for the ANSI compilers so people quit trying to fix the prototypes
X * to match the standard and thus lose the typechecking.
X */
X#if (defined(MSDOS) && !defined(TOS)) || defined (AMIGA) || defined(THINKC4) || defined(VAXC)
X# define CHAR_P char
X# define SCHAR_P schar
X# define UCHAR_P uchar
X# define XCHAR_P xchar
X# define BOOLEAN_P boolean
X#else
X# ifdef __STDC__
X#  define CHAR_P int
X#  define SCHAR_P int
X#  define UCHAR_P int
X#  define XCHAR_P int
X#  define BOOLEAN_P int
X# endif
X#endif
X
X
X#define	SIZE(x)	(int)(sizeof(x) / sizeof(x[0]))
X
X/* (No, LARGEST_INT doesn't have to correspond to the largest integer on
X * a particular machine.)
X */
X#define LARGEST_INT	((1 << 15) - 1)
X
X
X#ifdef STRONGHOLD
X# ifdef ALTARS
X#  ifdef THEOLOGY
X#define ENDGAME
X#  endif
X# endif
X#endif
X
X#ifdef REDO
X#define Getchar pgetchar
X#endif
X
X/*
X * Automatic inclusions for the subsidiary files.
X * Please don't change the order.  It does matter.
X */
X
X#ifndef COORD_H
X#include "coord.h"
X#endif
X
X#if defined(VMS) && !defined(VMSCONF_H)
X# include "vmsconf.h"
X#endif
X
X#if defined(UNIX) && !defined(UNIXCONF_H)
X# include "unixconf.h"
X#endif
X
X#if defined(MSDOS) && !defined(PCCONF_H)
X# include "pcconf.h"
X#endif
X
X#if defined(TOS) && !defined(TOSCONF_H)
X# include "tosconf.h"
X#endif
X
X#if defined(AMIGA) && !defined(AMICONF_H)
X# include "amiconf.h"
X#endif
X
X#if defined(MACOS) && !defined(MACCONF_H)
X# include "macconf.h"
X#endif
X
X
X/*
X * Configurable internal parameters.
X *
X * Please be very careful if you are going to change one of these.  Any
X * changes in these parameters, unless properly done, can render the
X * executable inoperative.
X */
X
X/* size of terminal screen is (at least) (ROWNO+3) by COLNO */
X#define	COLNO	80
X#define	ROWNO	21
X
X#define	MAXNROFROOMS	20	/* max number of rooms per level */
X#define	DOORMAX		120	/* max number of doors per level */
X
X#define	BUFSZ		256	/* for getlin buffers */
X
X#define	PL_NSIZ		32	/* name of player, ghost, shopkeeper */
X#define	PL_CSIZ		20	/* sizeof pl_character */
X#define PL_FSIZ		32	/* fruit name */
X
X#define	MAXLEVEL	50	/* max number of levels in the dungeon */
X#ifdef ENDGAME
X#define ENDLEVEL (MAXLEVEL+1)	/* endgame level */
X#endif
X#define HELLLEVEL	30	/* first hell level (varies ifdef STRONGHOLD) */
X#define	MAXULEV		30	/* max character experience level */
X
X#define	MAXMONNO	120	/* geno monst after this number killed */
X#define MHPMAX		500	/* maximum monster hp */
X
X#endif /* GLOBAL_H /**/
END_OF_FILE
if test 4792 -ne `wc -c <'include/global.h'`; then
    echo shar: \"'include/global.h'\" unpacked with wrong size!
fi
# end of 'include/global.h'
fi
if test -f 'include/macconf.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/macconf.h'\"
else
echo shar: Extracting \"'include/macconf.h'\" \(4750 characters\)
sed "s/^X//" >'include/macconf.h' <<'END_OF_FILE'
X/*	SCCS Id: @(#)macconf.h	3.0	88/07/21 */
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* Copyright (c) Johnny Lee, 1989 		*/
X/* NetHack may be freely redistributed.  See license for details. */
X#ifdef MACOS
X#ifndef MACCONF_H
X#define MACCONF_H
X
X/*
X *  The following options are configurable:
X */
X
X#define RANDOM		/* have Berkeley random(3) */
X
X#define PATHLEN	220	/* maximum pathlength */
X#define FILENAME	31	/* maximum filename length (conservative) */
X
X#define glo(x)	name_file(lock, x)	/* name_file used for bones */
X#include "msdos.h"	/* contains necessary externs for [os_name].c */
Xextern char *configfile;
X#define NO_SIGNAL
X#define	perror(x)
X
X/*
X *  The remaining code shouldn't need modification.
X */
X
X#ifndef SYSTEM_H
X#include "system.h"
X#endif
X
X
X#ifdef RANDOM
X/* Use the high quality random number routines. */
X#define Rand()	random()
X#define Srand(seed)	srandom(seed)
X#else
X#define Rand()	rand()
X#define Srand(seed)	srand(seed)
X#endif /* RANDOM */
X
X#ifndef REDO
X#undef	Getchar
X#define Getchar tgetch
X#endif
X
X#ifdef THINK_C
X
X#define index	strchr
X#define rindex	strrchr
X#include <time.h>
X#define	FCMASK	O_WRONLY | O_BINARY | O_CREAT	/* file creation mask */
X
X#ifdef LSC
X#include	<types.h>
X#include	<io.h>
X#define	memcpy(x,y,j)	movmem(y,x,j)
X#define memset(x,y,j)	setmem(x,j,y)
Xextern char *malloc();
Xextern char	*calloc();
X#else
X#include	<Fcntl.h>
X#include	<Stddef.h>
X#include	<Stdlib.h>
X#include	<String.h>
X#undef getuid
X#ifdef CUSTOM_IO
X#ifdef stdout
X#undef stdout
X#define stdout (FILE *)NULL
X#endif
X#endif
X#endif
X
X#include	<pascal.h>
X#include	<Quickdraw.h>
X#include	<FontMgr.h>
X#include	<EventMgr.h>
X#include	<WindowMgr.h>
X#include	<MenuMgr.h>
X#include	<StdFilePkg.h>
X#include	<SegmentLdr.h>
X#include	<ToolboxUtil.h>
X#include	<OSUtil.h>
X#include	<DialogMgr.h>
X#include	<FileMgr.h>
X#include	<HFS.h>
X#include	<Color.h>
X#include	<ResourceMgr.h>
X
X#ifdef fflush
X#undef	fflush
X#define	fflush(x)
X#endif
X
X/* these two defines for variables in decl.c; they conflict with */
X/* variables in Quickdraw.h - the Quickdraw variables are never used in NH */
X#define	black	Black
X#define	white	White
X
X
X#else	/* Aztec and MPW */
X
X#ifdef AZTEC
X#include	<utime.h>	/* AZTEC 3.6c */
X#define	curs(x,y)	tcurs(x,y)
X#include	<Types.h>
X#define	CtoPstr	ctop
X#define	PtoCstr	ptoc
X#else
X#include	<Time.h>	/* MPW 3.0 */
X#include	<Strings.h>
X#define	CtoPstr	c2pstr
X#define	PtoCstr	p2cstr
X#endif
X
X
X#include	<Quickdraw.h>
X#include	<Fonts.h>
X#include	<Events.h>
X#include	<Windows.h>
X#include	<Menus.h>
X#include	<Packages.h>
X#include	<SegLoad.h>
X#include	<ToolUtils.h>
X#include	<OSUtils.h>
X#include	<Dialogs.h>
X#include	<Files.h>
X#include	<Resources.h>
X#ifdef MPW
X#include	<Script.h>
X#include	<SysEqu.h>
X#endif
X#include	<Signal.h>
X#include	<String.h>
X#include	<FCntl.h>
X#define	FCMASK	O_WRONLY | O_CREAT	/* file creation mask */
X#endif
X
X/* typdef and defines for special custom termcap routines */
Xtypedef struct term_info {
X	short	tcur_x,tcur_y;
X	short	fontNum,fontSize;
X	short	ascent,descent,height,charWidth;
X	short	maxRow,maxCol;
X	char	**screen;
X	char	**scrAttr;
X	char	curHilite;
X	char	curAttr;
X	short	inColor;
X	short	auxFileVRefNum;
X	short	recordVRefNum;
X	SysEnvRec	system;
X	char	*keyMap;
X	short	color[8];
X	CursHandle	cursor[9];  /* self-contained cursors */
X	Handle	shortMBarHandle,
X			fullMBarHandle;
X} term_info;
X
X#define TEXTCOLOR
X
X#define	appleMenu	101
X#define	fileMenu	102
X#define	editMenu	103
X#define	inventMenu	104
X#define actionMenu	105
X#define prepMenu	106
X#define	moveMenu	107
X#define extendMenu	108
X
X#ifdef THINK_C
X#define MAINGRAFPORT	thePort
X#define	ARROW_CURSOR	arrow
X#define	SCREEN_BITS	screenBits
X#else
X#define MAINGRAFPORT	qd.thePort
X#define	ARROW_CURSOR	qd.arrow
X#define	SCREEN_BITS	qd.screenBits
X#endif
X
X/* used in mac.c */
X#define Screen_Border	4
X#define	TOP_OFFSET		30
X#define	LEFT_OFFSET	10
X
X/* for macflags variable */
X#define	fMoveWRTMouse		0x400
X#define	fZoomOnContextSwitch		0x200
X#define	fUseCustomFont		0x100
X#define	fToggleNumPad		0x80
X#define	fInvertedScreen		0x40
X#define	fExtCmdSeq1			0x20
X#define	fExtCmdSeq2			0x10
X#define	fExtCmdSeq3			0x08
X#define	fDoNonKeyEvt		0x06
X#define	fDoMenus		0x02
X#define	fDoUpdate			0x01
X
X
X#define	CREATOR	'nh30'
X#define	EXPLORE_TYPE	'XPLR'
X#define	SAVE_TYPE	'SAVE'
X#define	BONES_TYPE	'BONE'
X#define	LEVEL_TYPE	'LEVL'
X#define	HACK_DATA	'HDTA'
X#define AUXIL_TYPE	'AUXL'
X#define TEXT_TYPE	'TEXT'
X#define MONST_DATA	101
X#define OBJECT_DATA	104
X#define	DEFAULT_DATA	100
X
X#define SEG_ZAP		0x0020
X#define SEG_SPELL	0x0010
X#define SEG_POTION	0x0008
X#define SEG_EAT		0x0004
X#define SEG_DO		0x0002
X#define SEG_APPLY	0x0001
Xextern long segments;	/* defined in mac.c */
X
X#include "extern.h"
X
X# ifndef MACALERT_H
X#  include "MacAlert.h"
X# endif
X
X#endif /* MACCONF_H /* */
X#endif /* MACOS / */
END_OF_FILE
if test 4750 -ne `wc -c <'include/macconf.h'`; then
    echo shar: \"'include/macconf.h'\" unpacked with wrong size!
fi
# end of 'include/macconf.h'
fi
if test -f 'include/mondata.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/mondata.h'\"
else
echo shar: Extracting \"'include/mondata.h'\" \(4813 characters\)
sed "s/^X//" >'include/mondata.h' <<'END_OF_FILE'
X/*	SCCS Id: @(#)mondata.h	3.0	89/11/21
X/* NetHack may be freely redistributed.  See license for details. */
X/* Copyright (c) 1989 Mike Threepoint */
X
X#ifndef MONDATA_H
X#define MONDATA_H
X
X# ifndef STUPID_CPP	/* otherwise these macros are functions in mondata.c */
X
X#define verysmall(ptr)		((ptr)->msize < MZ_SMALL)
X#define bigmonst(ptr)		((ptr)->msize >= MZ_LARGE)
X
X#define is_flyer(ptr)		(((ptr)->mflags1 & M1_FLY) != 0L)
X#define is_floater(ptr) 	((ptr)->mlet == S_EYE)
X#define is_swimmer(ptr) 	(((ptr)->mflags1 & M1_SWIM) != 0L)
X#define passes_walls(ptr)	(((ptr)->mflags1 & M1_WALLWALK) != 0L)
X#define amorphous(ptr)		(((ptr)->mflags1 & M1_AMORPHOUS) != 0L)
X#define noncorporeal(ptr)	((ptr)->mlet == S_GHOST)
X#define tunnels(ptr)		(((ptr)->mflags1 & M1_TUNNEL) != 0L)
X#define needspick(ptr)		(((ptr)->mflags1 & M1_NEEDPICK) != 0L)
X#define hides_under(ptr)	(((ptr)->mflags1 & M1_CONCEAL) != 0L)
X#define is_hider(ptr)		(((ptr)->mflags1 & M1_HIDE) != 0L)
X#define haseyes(ptr)		(((ptr)->mflags1 & M1_NOEYES) == 0L)
X#define nohands(ptr)		(((ptr)->mflags1 & M1_NOHANDS) != 0L)
X#define nolimbs(ptr)		(((ptr)->mflags1 & M1_NOLIMBS) == M1_NOLIMBS)
X#  ifdef POLYSELF
X#define polyok(ptr)		(((ptr)->mflags1 & M1_NOPOLY) == 0L)
X#  endif
X#define is_whirly(ptr)		((ptr)->mlet == S_VORTEX || (ptr) == &mons[PM_AIR_ELEMENTAL])
X#define humanoid(ptr)		(((ptr)->mflags1 & M1_HUMANOID) != 0L)
X#define is_animal(ptr)		(((ptr)->mflags1 & M1_ANIMAL) != 0L)
X#define slithy(ptr)		(((ptr)->mflags1 & M1_SLITHY) != 0L)
X#define thick_skinned(ptr)	(((ptr)->mflags1 & M1_THICK_HIDE) != 0L)
X#define resists_fire(ptr)	(((ptr)->mflags1 & M1_FIRE_RES) != 0L)
X#define resists_cold(ptr)	(((ptr)->mflags1 & M1_COLD_RES) != 0L)
X#define resists_disint(ptr)	((ptr) == &mons[PM_BLACK_DRAGON] || (ptr) == &mons[PM_BABY_BLACK_DRAGON])
X#define resists_elec(ptr)	(((ptr)->mflags1 & M1_ELEC_RES) != 0L)
X#define resists_acid(ptr)	(((ptr)->mflags1 & M1_ACID) != 0L)
X#define acidic(ptr)		(((ptr)->mflags1 & M1_ACID) != 0L)
X#define resists_poison(ptr)	(((ptr)->mflags1 & (M1_POIS | M1_POIS_RES)) != 0L)
X#define poisonous(ptr)		(((ptr)->mflags1 & M1_POIS) != 0L)
X#define regenerates(ptr)	(((ptr)->mflags1 & M1_REGEN) != 0L)
X#define perceives(ptr)		(((ptr)->mflags1 & M1_SEE_INVIS) != 0L)
X#define can_teleport(ptr)	(((ptr)->mflags1 & M1_TPORT) != 0L)
X#define control_teleport(ptr)	(((ptr)->mflags1 & M1_TPORT_CONTROL) != 0L)
X#define is_armed(ptr)		attacktype(ptr, AT_WEAP)
X#define likes_gold(ptr) 	(((ptr)->mflags1 & M1_GREEDY) != 0L)
X#define likes_gems(ptr) 	(((ptr)->mflags1 & M1_JEWELS) != 0L)
X#define likes_objs(ptr) 	(((ptr)->mflags1 & M1_COLLECT) != 0L || \
X					is_armed(ptr))
X#define likes_magic(ptr)	(((ptr)->mflags1 & M1_MAGIC) != 0L)
X#define is_undead(ptr)		(((ptr)->mflags2 & M2_UNDEAD) != 0L)
X#define resists_sleep(ptr)	(((ptr)->mflags1 & M1_SLEE_RES) != 0L || is_undead(ptr))
X#define is_were(ptr)		(((ptr)->mflags2 & M2_WERE) != 0L)
X#define is_elf(ptr)		(((ptr)->mflags2 & M2_ELF) != 0L)
X#define is_dwarf(ptr)		(((ptr)->mflags2 & M2_DWARF) != 0L)
X#define is_giant(ptr)		(((ptr)->mflags2 & M2_GIANT) != 0L)
X#  ifdef GOLEMS
X#define is_golem(ptr)		((ptr)->mlet == S_GOLEM)
X#  endif
X#define is_domestic(ptr)	(((ptr)->mflags2 & M2_DOMESTIC) != 0L)
X#define is_orc(ptr)		(((ptr)->mflags2 & M2_ORC) != 0L)
X#define is_human(ptr)		(((ptr)->mflags2 & M2_HUMAN) != 0L)
X#define is_demon(ptr)		(((ptr)->mflags2 & M2_DEMON) != 0L)
X#define is_mercenary(ptr)	(((ptr)->mflags2 & M2_MERC) != 0L)
X#define is_wanderer(ptr)	(((ptr)->mflags2 & M2_WANDER) != 0L)
X#define always_hostile(ptr)	(((ptr)->mflags2 & M2_HOSTILE) != 0L)
X#define always_peaceful(ptr)	(((ptr)->mflags2 & M2_PEACEFUL) != 0L)
X#define extra_nasty(ptr)	(((ptr)->mflags2 & M2_NASTY) != 0L)
X#define strongmonst(ptr)	(((ptr)->mflags2 & M2_STRONG) != 0L)
X#  ifdef POLYSELF
X#define can_breathe(ptr)	attacktype(ptr, AT_BREA)
X#define cantwield(ptr)		(nohands(ptr) || verysmall(ptr))
X#define cantweararm(ptr)	(breakarm(ptr) || sliparm(ptr))
X#  endif /* POLYSELF */
X#define carnivorous(ptr)	(((ptr)->mflags2 & M2_CARNIVORE) != 0L)
X#define herbivorous(ptr)	(((ptr)->mflags2 & M2_HERBIVORE) != 0L)
X#define metallivorous(ptr)	(((ptr)->mflags2 & M2_METALLIVORE) != 0L)
X#define lays_eggs(ptr)		(((ptr)->mflags2 & M2_EGGS) != 0L)
X#define throws_rocks(ptr)	(((ptr)->mflags2 & M2_ROCKTHROW) != 0L)
X#define type_is_pname(ptr)	(((ptr)->mflags2 & M2_PNAME) != 0L)
X#define is_lord(ptr)		(((ptr)->mflags2 & M2_LORD) != 0L)
X#define is_prince(ptr)		(((ptr)->mflags2 & M2_PRINCE) != 0L)
X#  ifdef INFERNO
X#define is_ndemon(ptr)		(is_demon(ptr) && \
X			(((ptr)->mflags2 & (M2_LORD | M2_PRINCE)) == 0L))
X#  else
X#define is_ndemon(ptr)		(ptr == &mons[PM_DEMON])
X#  endif
X#define is_dlord(ptr)		(is_demon(ptr) && is_lord(ptr))
X#define is_dprince(ptr)		(is_demon(ptr) && is_prince(ptr))
X
X# endif /* STUPID_CPP */
X
X#endif /* MONDATA_H */
END_OF_FILE
if test 4813 -ne `wc -c <'include/mondata.h'`; then
    echo shar: \"'include/mondata.h'\" unpacked with wrong size!
fi
# end of 'include/mondata.h'
fi
if test -f 'include/tradstdc.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/tradstdc.h'\"
else
echo shar: Extracting \"'include/tradstdc.h'\" \(4303 characters\)
sed "s/^X//" >'include/tradstdc.h' <<'END_OF_FILE'
X/*	SCCS Id: @(#)tradstdc.h	3.0	89/07/12
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#ifndef TRADSTDC_H
X#define	TRADSTDC_H
X
X#ifdef DUMB
X#undef void
X#define void	int
X#endif
X
X#ifdef APOLLO	/* the Apollo C compiler claims to be __STDC__, but isn't */
X#undef __STDC__
X#endif
X
X/*
X * ANSI X3J11 detection.
X * Makes substitutes for compatibility with the old C standard.
X */
X
X/* Decide how to handle variable parameter lists:
X * USE_STDARG means use the ANSI <stdarg.h> facilities (only ANSI compilers
X * should do this, and only if the library supports it).
X * USE_VARARGS means use the <varargs.h> facilities.  Again, this should only
X * be done if the library supports it.  ANSI is *not* required for this.
X * Otherwise, the kludgy old methods are used.
X * The defaults are USE_STDARG for ANSI compilers, and USE_OLDARGS for
X * others.
X */
X
X/* #define USE_VARARGS		/* use <varargs.h> instead of <stdarg.h> */
X/* #define USE_OLDARGS		/* don't use any variable argument facilites */
X
X#ifdef __STDC__
X# if defined(__GNUC__) && defined(VMS)
X#   define USE_OLDARGS          /* <stdarg.h> is missing for some versions */
X# endif
X# if !defined(USE_VARARGS) && !defined(USE_OLDARGS)
X#   define USE_STDARG
X# endif
X#endif
X
X#ifdef NEED_VARARGS		/* only define these if necessary */
X#ifdef USE_STDARG
X# include <stdarg.h>
X# define VA_DECL(typ1,var1)	(typ1 var1, ...) { va_list the_args;
X# define VA_DECL2(typ1,var1,typ2,var2)	\
X	(typ1 var1, typ2 var2, ...) { va_list the_args;
X# define VA_INIT(var1,typ1)
X# define VA_NEXT(var1,typ1)	var1 = va_arg(the_args, typ1)
X# define VA_ARGS		the_args
X# define VA_START(x)		va_start(the_args, x)
X# define VA_END()		va_end(the_args)
X#else
X# ifdef USE_VARARGS
X#  include <varargs.h>
X#  define VA_DECL(typ1,var1)	(va_alist) va_dcl {\
X		va_list the_args; typ1 var1;
X#  define VA_DECL2(typ1,var1,typ2,var2)	(va_alist) va_dcl {\
X		va_list the_args; typ1 var1; typ2 var2;
X#  define VA_ARGS		the_args
X#  define VA_START(x)		va_start(the_args)
X#  define VA_INIT(var1,typ1) 	var1 = va_arg(the_args, typ1)
X#  define VA_NEXT(var1,typ1)	var1 = va_arg(the_args,typ1)
X#  define VA_END()		va_end(the_args)
X# else
X#   define VA_ARGS	arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9
X#   define VA_DECL(typ1,var1)  (var1,VA_ARGS) typ1 var1; \
X	char *arg1,*arg2,*arg3,*arg4,*arg5,*arg6,*arg7,*arg8,*arg9; {
X#   define VA_DECL2(typ1,var1,typ2,var2)  (var1,var2,VA_ARGS) \
X	typ1 var1; typ2 var2;\
X	char *arg1,*arg2,*arg3,*arg4,*arg5,*arg6,*arg7,*arg8,*arg9; {
X#   define VA_START(x)
X#   define VA_INIT(var1,typ1)
X#   define VA_END()
X# endif
X#endif
X#endif /* NEED_VARARGS */
X
X
X/* Unfortunately amiga aztec 5.0 doesn't handle prototyping chars correctly */
X#if (defined(__STDC__) && !defined(AZTEC_50)) || defined(MSDOS) || defined(THINKC4)
X
X/* Used for robust ANSI parameter forward declarations:
X * int VDECL(sprintf, (char *, const char *, ...));
X *
X * NDECL() is used for functions with zero arguments;
X * FDECL() is used for functions with a fixed number of arguments;
X * VDECL() is used for functions with a variable number of arguments.
X * Separate macros are needed because ANSI will mix old-style declarations
X * with prototypes, except in the case of varargs, and the OVERLAY-specific
X * trampoli.* mechanism conflicts with the ANSI <<f(void)>> syntax.
X */
X
X# define NDECL(f)	f(void)	/* Must be overridden if OVERLAY set later */
X
X# define FDECL(f,p)	f p
X
X# if defined(MSDOS) || defined(USE_STDARG)
X#  define VDECL(f,p)	f p
X# else
X#  define VDECL(f,p)	f()
X# endif
X
X# ifdef __TURBOC__	/* Cover for stupid Turbo C */
X#  define genericptr_t	void *
X# else
Xtypedef void *		genericptr_t;
X#  ifndef __STDC__
X#   define const
X#   define signed
X#   define volatile
X#  endif
X# endif
X
X#else /* __STDC__ */	/* a "traditional" C  compiler */
X
X# define NDECL(f)	f()
X# define FDECL(f,p)	f()
X# define VDECL(f,p)	f()
X
X# ifndef genericptr_t
X#  if defined(AMIGA) || defined(HPUX)
Xtypedef void *		genericptr_t;
X#  else
Xtypedef char *		genericptr_t;
X#  endif
X# endif
X
X#ifndef AZTEC_50	/* Take out when aztec handles prototyping OK */
X# define const
X# define signed
X# define volatile
X#endif
X
X#endif /* __STDC__ */
X
X#ifdef __HC__	/* MetaWare High-C defaults to unsigned chars */
X# undef signed
X#endif
X
X#endif /* TRADSTDC_H /**/
END_OF_FILE
if test 4303 -ne `wc -c <'include/tradstdc.h'`; then
    echo shar: \"'include/tradstdc.h'\" unpacked with wrong size!
fi
# end of 'include/tradstdc.h'
fi
if test -f 'include/you.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/you.h'\"
else
echo shar: Extracting \"'include/you.h'\" \(4408 characters\)
sed "s/^X//" >'include/you.h' <<'END_OF_FILE'
X/*	SCCS Id: @(#)you.h	3.0	88/04/25
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#ifndef YOU_H
X#define YOU_H
X
X#ifndef ATTRIB_H
X#include "attrib.h"
X#endif
X#ifndef MONST_H
X#include "monst.h"
X#endif
X#ifndef YOUPROP_H
X#include "youprop.h"
X#endif
X
Xstruct prop {
X
X#define	TIMEOUT		007777	/* mask */
X
X#define	LEFT_RING	W_RINGL	/* 010000L */
X#define	RIGHT_RING	W_RINGR	/* 020000L */
X#define	LEFT_SIDE	LEFT_RING
X#define	RIGHT_SIDE	RIGHT_RING
X#define	BOTH_SIDES	(LEFT_SIDE | RIGHT_SIDE)
X
X#define WORN_ARMOR	W_ARM	/* 040000L */
X#define WORN_CLOAK	W_ARMC	/* 0100000L */
X#define WORN_HELMET	W_ARMH	/* 0200000L */
X#define WORN_SHIELD	W_ARMS	/* 0400000L */
X#define WORN_GLOVES	W_ARMG	/* 01000000L */
X#define WORN_BOOTS	W_ARMF	/* 02000000L */
X#define	WORN_AMUL	W_AMUL	/* 04000000L */
X#define	WORN_BLINDF	W_TOOL	/* 010000000L */
X#ifdef SHIRT
X#define	WORN_SHIRT	W_ARMU	/* 01000L */
X#endif
X#define	INTRINSIC	040000000L
X
X
X	long p_flgs;
X	int NDECL((*p_tofn));	/* called after timeout */
X};
X
Xstruct you {
X	xchar ux, uy;
X	schar dx, dy, dz;	/* direction of move (or zap or ... ) */
X	schar di;		/* direction of FF */
X	xchar ux0, uy0;		/* initial position FF */
X	xchar udisx, udisy;	/* last display pos */
X	uchar usym;		/* usually '@' */
X	int last_str_turn;	/* 0: none, 1: half turn, 2: full turn */
X				/* +: turn right, -: turn left */
X	boolean umoved;		/* changed map location (post-move) */
X	unsigned udispl;	/* @ on display */
X	unsigned ulevel;	/* 1 - MAXULEV */
X	unsigned utrap;		/* trap timeout */
X	unsigned utraptype;	/* defined if utrap nonzero */
X#define	TT_BEARTRAP	0
X#define	TT_PIT		1
X#define	TT_WEB		2
X	unsigned uinshop;	/* used only in shk.c - (roomno+1) of shop */
X	int	 uhunger;	/* refd only in eat.c and shk.c */
X	unsigned uhs;		/* hunger state - see eat.c */
X
X	struct prop uprops[LAST_PROP+1];
X
X	unsigned umconf;
X	const char *usick_cause;
X/* For messages referring to hands, eyes, feet, etc... when polymorphed */
X#define ARM 0
X#define EYE 1
X#define FACE 2
X#define FINGER 3
X#define FINGERTIP 4
X#define FOOT 5
X#define HAND 6
X#define HANDED 7
X#define HEAD 8
X#define LEG 9
X#define LIGHT_HEADED 10
X#define NECK 11
X#define SPINE 12
X#define TOE 13
X#ifdef POLYSELF
X	int mh, mhmax, mtimedone, umonnum;	/* for polymorph-self */
X	struct attribs	macurr,			/* for monster attribs */
X			mamax;			/* for monster attribs */
X	int ulycn;				/* lycanthrope type */
X#endif
X	unsigned ucreamed;
X	unsigned uswallow;		/* set if swallowed by a monster */
X	unsigned uswldtim;		/* time you have been swallowed */
X#ifdef POLYSELF
X	Bitfield(uundetected,1);	/* if you're a hiding monster/piercer */
X#endif
X#if defined(THEOLOGY) && defined(ELBERETH)
X	Bitfield(uhand_of_elbereth,1);	/* if you become Hand of Elbereth */
X#endif
X#ifdef MEDUSA
X	Bitfield(ukilled_medusa,1);	/* if you kill the medusa */
X#endif
X	Bitfield(uhave_amulet,1);	/* you're carrying the Amulet */
X#ifdef HARD
X	Bitfield(udemigod,1);		/* once you kill the wiz */
X	unsigned udg_cnt;		/* how long you have been demigod */
X#endif
X	struct	attribs	acurr,		/* your current attributes (eg. str) */
X			abon,		/* your bonus attributes (eg. str) */
X			amax,		/* your max attributes (eg. str) */
X			atemp,		/* used for temporary loss/gain */
X			atime;		/* used for loss/gain countdown */
X#define U_CHAOTIC      -1		/* the value range of ualigntyp */
X#define U_NEUTRAL	0
X#define U_LAWFUL	1
X	int 	ualign;			/* running alignment score */
X	schar 	ualigntyp;		/* basic character alignment */
X#ifdef THEOLOGY
X#define CONVERT 	2
X	schar   ualignbase[CONVERT];	/* for ualigntyp conversion record */
X#endif
X	schar uluck, moreluck;		/* luck and luck bonus */
X#define	LUCKADD		3	/* added value when carrying luck stone */
X#define Luck	(u.uluck + u.moreluck)
X#define	LUCKMAX		10	/* on moonlit nights 11 */
X#define	LUCKMIN		(-10)
X	schar	udaminc;
X	schar	uac;
X	int	uhp,uhpmax;
X#ifdef SPELLS
X	int	uen, uenmax;		/* magical energy - M. Stephenson */
X#endif
X#ifdef THEOLOGY
X	int ugangr;			/* if the gods are angry at you */
X	int ublessed, ublesscnt;	/* blessing/duration from #pray */
X#endif
X	long	ugold, ugold0;
X	long	uexp, urexp;
X#ifdef ALTARS
X	long 	ucleansed;	/* to record moves when player was cleansed */
X#endif
X	int uinvault;
X	struct monst *ustuck;
X	int ugrave_arise; /* you die and become something aside from a ghost */
X	int nr_killed[NUMMONS]; 	/* used for experience bookkeeping */
X};
X
X#endif /* YOU_H /**/
END_OF_FILE
if test 4408 -ne `wc -c <'include/you.h'`; then
    echo shar: \"'include/you.h'\" unpacked with wrong size!
fi
# end of 'include/you.h'
fi
if test -f 'src/alloc.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/alloc.c'\"
else
echo shar: Extracting \"'src/alloc.c'\" \(943 characters\)
sed "s/^X//" >'src/alloc.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)alloc.c	3.0	89/11/15
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X/* since this file is also used in auxiliary programs, don't include all the 
X * function declarations for all of nethack
X */
X#define EXTERN_H	/* comment line for pre-compiled headers */
X#include "config.h"
Xlong *FDECL(alloc,(unsigned int));
X
X#ifdef LINT
X/*
X   a ridiculous definition, suppressing
X	"possible pointer alignment problem" for (long *) malloc()
X   from lint
X*/
Xlong *
Xalloc(n) unsigned int n; {
Xlong dummy = ftell(stderr);
X	if(n) dummy = 0;	/* make sure arg is used */
X	return(&dummy);
X}
X
X#else
X#ifndef __TURBOC__
Xextern void VDECL(panic, (const char *,...));
X
Xlong *
Xalloc(lth)
Xregister unsigned int lth;
X{
X	register genericptr_t ptr;
X
X	if(!(ptr = malloc(lth)))
X		panic("Cannot get %d bytes", lth);
X	return((long *) ptr);
X}
X#endif
X
X
X#endif /* LINT /**/
END_OF_FILE
if test 943 -ne `wc -c <'src/alloc.c'`; then
    echo shar: \"'src/alloc.c'\" unpacked with wrong size!
fi
# end of 'src/alloc.c'
fi
if test -f 'src/lev_main.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/lev_main.c'\"
else
echo shar: Extracting \"'src/lev_main.c'\" \(3852 characters\)
sed "s/^X//" >'src/lev_main.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)lev_main.c	3.0	89/07/02
X/*	Copyright (c) 1989 by Jean-Christophe Collet */
X/* NetHack may be freely redistributed.  See license for details. */
X
X/*
X * This file contains the main function for the parser
X * and some useful functions needed by yacc
X */
X
X/* #include "hack.h"	/* uncomment for the Mac */
X
X#ifndef VMS
X# if defined(AMIGA) || defined(MSDOS)
X#  include "hack.h"
X#  undef exit
X#  ifdef MSDOS
Xextern void FDECL(exit, (int));
X#  endif
X# else
X#  include <stdio.h>
X# endif
X#else  /*VMS*/
X# ifdef ANCIENT_VAXC    /* need KR1ED setup */
X#  define GLOBAL_H      /* don't need other stuff */
X#include "config.h"
X# endif
X#include <stdio.h>
X# define exit vms_exit
X#endif /*VMS*/
X
X#define MAX_ERRORS	25
X
Xextern int line_number;
Xchar *fname = "(stdin)";
Xint fatal_error = 0;
X
X#ifdef LATTICE
Xlong *alloc(unsigned int);
X#ifdef exit
X#undef exit
X#endif
X#include <stdlib.h>
X#endif
X
X#ifdef	FDECL
Xint  FDECL (main, (int, char **));
Xint  NDECL (yyparse);
Xvoid FDECL (yyerror, (char *));
Xvoid FDECL (yywarning, (char *));
Xint  NDECL (yywrap);
X#endif
X
X#ifdef LSC
X_main(argc, argv)
X#else
Xmain(argc, argv) 
X#endif
Xint argc;
Xchar **argv;
X{
X	FILE *fin;
X	int i;
X
X#if defined(MACOS) && defined(SMALLDATA)
X# ifdef THINKC4
X#include <console.h>
X# endif
X#define YYLMAX	2048
X	extern char	*yysbuf, *yytext, *yysptr;
X	Handle temp;
X	Str255 name;
X	long	j;
X	extern struct permonst *mons;
X	extern struct objclass *objects;
X	char descrip[3][32];    /* 3 special level description files */
X
X	/* sub in the Nethack resource filename */
X	Strcpy((char *)name, "\021nethack.proj.rsrc");
X	yysbuf = (char *)alloc(YYLMAX);
X	yysptr = yysbuf;
X	yytext = (char *)alloc(YYLMAX);
X
X	(void)OpenResFile(name);
X	temp = GetResource(HACK_DATA, MONST_DATA);
X	if (temp) {
X		DetachResource(temp);
X		MoveHHi(temp);
X		HLock(temp);
X		i = GetHandleSize(temp);
X		mons = (struct permonst *)(*temp);
X	} else {
X		panic("Can't get MONST resource data.");
X	}
X	
X	temp = GetResource(HACK_DATA, OBJECT_DATA);
X	if (temp) {
X		DetachResource(temp);
X		MoveHHi(temp);
X		HLock(temp);
X		i = GetHandleSize(temp);
X		objects = (struct objclass *)(*temp);
X		for (j = 0; j< NROFOBJECTS+1; j++) {
X			objects[j].oc_name = sm_obj[j].oc_name;
X			objects[j].oc_descr = sm_obj[j].oc_descr;
X		}
X	} else {
X		panic("Can't get OBJECT resource data.");
X	}
X    Sprintf(descrip[1], "%s", ":auxil:castle.des");
X    Sprintf(descrip[2], "%s", ":auxil:endgame.des");
X    Sprintf(descrip[3], "%s", ":auxil:tower.des");
X    argc = 4;    /* argv[0] is irrelevant, argv[i] = descrip[i] */
X#else   /* !MACOS || !SMALLDATA */
X# ifdef VMS
X    extern FILE *yyin, *yyout;
X    yyin = stdin,  yyout = stdout;
X# endif
X#endif
X
X	if (argc == 1)		/* Read standard input */
X	    yyparse();
X	else 			/* Otherwise every argument is a filename */
X	    for(i=1; i<argc; i++) {
X#ifdef MACOS
X                    argv[i] = descrip[i];
X                    fprintf(stdout, "Working on %s\n", argv[i]);
X#endif
X#if defined(AZTEC_C)
X		    extern FILE *yyin;
X		    yyin = fin = fopen(argv[i], "r");
X#else
X		    fin = freopen(argv[i], "r", stdin);
X#endif
X		    fname = argv[i];
X		    if (!fin) 
X			fprintf(stderr,"Can't open %s\n", argv[i]);
X		    else
X			yyparse();
X		    line_number = 1;
X		    fatal_error = 0;
X	    }
X#ifndef VMS
X	return 0;
X#else
X	return 1;       /* vms success */
X#endif /*VMS*/
X}
X
X/* 
X * Each time the parser detects an error, it uses this function.
X * Here we take count of the errors. To continue farther than
X * MAX_ERRORS wouldn't be reasonable.
X */
X
Xvoid yyerror(s)
Xchar *s;
X{
X	fprintf(stderr,"%s : line %d : %s\n",fname,line_number, s);
X	if (++fatal_error > MAX_ERRORS) {
X		fprintf(stderr,"Too many errors, good bye!\n");
X		exit(1);
X	}
X}
X
X/* 
X * Just display a warning (that is : a non fatal error)
X */
X
Xvoid yywarning(s)
Xchar *s;
X{
X	fprintf(stderr,"%s : line %d : WARNING : %s\n",fname,line_number,s);
X}
X
Xyywrap()
X{
X       return 1;
X}
END_OF_FILE
if test 3852 -ne `wc -c <'src/lev_main.c'`; then
    echo shar: \"'src/lev_main.c'\" unpacked with wrong size!
fi
# end of 'src/lev_main.c'
fi
if test -f 'src/worn.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/worn.c'\"
else
echo shar: Extracting \"'src/worn.c'\" \(4661 characters\)
sed "s/^X//" >'src/worn.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)worn.c	3.0	89/11/15
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include "hack.h"
X
Xstatic const char crispy[] = "The flames of hell burn you to a crisp.";
Xstatic void FDECL(set_armor_intrinsic, (struct obj *,BOOLEAN_P));
X
Xconst struct worn {
X	long w_mask;
X	struct obj **w_obj;
X} worn[] = {
X	{ W_ARM, &uarm },
X	{ W_ARMC, &uarmc },
X	{ W_ARMH, &uarmh },
X	{ W_ARMS, &uarms },
X	{ W_ARMG, &uarmg },
X	{ W_ARMF, &uarmf },
X#ifdef SHIRT
X	{ W_ARMU, &uarmu },
X#endif
X	{ W_RINGL, &uleft },
X	{ W_RINGR, &uright },
X	{ W_WEP, &uwep },
X	{ W_AMUL, &uamul },
X	{ W_TOOL, &ublindf },
X	{ W_BALL, &uball },
X	{ W_CHAIN, &uchain },
X	{ 0, 0 }
X};
X
Xvoid
Xsetworn(obj, mask)
Xregister struct obj *obj;
Xlong mask;
X{
X	register const struct worn *wp;
X	register struct obj *oobj = 0;
X
X	for(wp = worn; wp->w_mask; wp++) if(wp->w_mask & mask) {
X		oobj = *(wp->w_obj);
X		if(oobj && !(oobj->owornmask & wp->w_mask))
X			impossible("Setworn: mask = %ld.", wp->w_mask);
X		if(oobj) {
X		    oobj->owornmask &= ~wp->w_mask;
X		    /* leave as "x = x <op> y", here and below, for broken
X		     * compilers */
X		    u.uprops[objects[oobj->otyp].oc_oprop].p_flgs = 
X			    u.uprops[objects[oobj->otyp].oc_oprop].p_flgs & 
X				~wp->w_mask;
X		    set_armor_intrinsic(oobj, 0);
X		}
X		*(wp->w_obj) = obj;
X		if(obj) {
X		    obj->owornmask |= wp->w_mask;
X		/* prevent getting intrinsics from wielding potions, etc... */
X		/* wp_mask should be same as mask at this point */
X		    if(obj->olet == WEAPON_SYM || mask != W_WEP) {
X			u.uprops[objects[obj->otyp].oc_oprop].p_flgs = 
X			    u.uprops[objects[obj->otyp].oc_oprop].p_flgs | 
X				wp->w_mask;
X			set_armor_intrinsic(obj, 1);
X		    }
X		}
X	}
X	/* A kludge to solve the problem of someone gaining fire resistance
X	 * only from an item, then entering Hell and removing/unwielding it.
X	 * Checking this every time setworn gets called is a bit of an
X	 * overkill. --KAA
X	 */
X	if (Inhell && !Fire_resistance) {
X		pline(crispy);
X		killer_format = NO_KILLER_PREFIX;
X		killer = self_pronoun("lost %s fire protection in hell","his");
X		done(BURNING);
X		/* If we're here they survived with life saving, so put the
X		 * weapon they just unwielded back in their hands...
X		 */
X		if (!oobj || (oobj->otyp != DRAGON_SCALE_MAIL
X				&& oobj->otyp != RIN_FIRE_RESISTANCE
X#ifdef NAMED_ITEMS
X				&& !defends(AD_FIRE, oobj)
X#endif
X				&& oobj->corpsenm != PM_RED_DRAGON))
X			impossible("lost FR from a non-FR item?");
X		setworn(oobj, mask);
X	}
X}
X
X/* called e.g. when obj is destroyed */
Xvoid
Xsetnotworn(obj)
Xregister struct obj *obj;
X{
X	register const struct worn *wp;
X
X	if (!obj) return;
X	for(wp = worn; wp->w_mask; wp++)
X		if(obj == *(wp->w_obj)) {
X			*(wp->w_obj) = 0;
X			u.uprops[objects[obj->otyp].oc_oprop].p_flgs = 
X				u.uprops[objects[obj->otyp].oc_oprop].p_flgs & 
X					~wp->w_mask;
X			obj->owornmask &= ~wp->w_mask;
X			set_armor_intrinsic(obj, 0);
X		}
X	/* See comments above in setworn().  The major difference is the
X	 * need to check AMULET_SYM so if someone goes to Hell without
X	 * being fire resistant, then dies, when their amulet saves them
X	 * and disintegrates this code will not be triggered. --KAA
X	 */
X	if (Inhell && !Fire_resistance && obj->olet != AMULET_SYM) {
X		pline(crispy);
X		killer_format = NO_KILLER_PREFIX;
X		killer = self_pronoun("lost %s fire protection in hell","his");
X		done(BURNING);
X		/* Survived with lifesaving, etc...; there's no general way
X		 * to undo the setnotworn()--we can't re-wear/wield the
X		 * item since it might have been stolen, disintegrated, etc....
X		 */
X#if defined(WIZARD) || defined(EXPLORE_MODE)
X		while(1) {
X			/* keep doing it until they finally decide they really
X			 * _do_ want to die, since we can't possibly continue
X			 * the game from this point...
X			 */
X#endif
X			You("are still burning and die again...");
X			done(BURNING);
X#if defined(WIZARD) || defined(EXPLORE_MODE)
X		}
X#endif
X	}
X}
X
Xstatic void
Xset_armor_intrinsic(obj,on)
Xregister struct obj *obj;
Xboolean on;
X{
X	long *mask;
X
X	if (obj->otyp != DRAGON_SCALE_MAIL) return;
X	switch(obj->corpsenm) {
X		case PM_GRAY_DRAGON:
X			mask = &Antimagic;
X			break;
X		case PM_RED_DRAGON:
X			mask = &HFire_resistance;
X			break;
X		case PM_WHITE_DRAGON:
X			mask = &HCold_resistance;
X			break;
X		case PM_BLUE_DRAGON:
X			mask = &HShock_resistance;
X			break;
X		case PM_GREEN_DRAGON:
X			mask = &HPoison_resistance;
X			break;
X		case PM_ORANGE_DRAGON:
X			mask = &HSleep_resistance;
X			break;
X		case PM_BLACK_DRAGON:
X			mask = &HDisint_resistance;
X			break;
X		case PM_YELLOW_DRAGON:
X		default:
X			return;
X	}
X	if (on) *mask |= WORN_ARMOR;
X	else *mask &= ~WORN_ARMOR;
X}
END_OF_FILE
if test 4661 -ne `wc -c <'src/worn.c'`; then
    echo shar: \"'src/worn.c'\" unpacked with wrong size!
fi
# end of 'src/worn.c'
fi
echo shar: End of archive 53 \(of 56\).
cp /dev/null ark53isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 56 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
    echo Building monst.c from monst.c1 and monst.c2
    cat src/monst.c1 src/monst.c2 > src/monst.c
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
