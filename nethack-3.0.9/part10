Path: utzoo!utgpu!news-server.csri.toronto.edu!cs.utexas.edu!samsung!dali.cs.montana.edu!milton!uw-beaver!zephyr.ens.tek.com!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v10i055:  nethack3p9 -  display oriented dungeons & dragons (Ver. 3.0i), Part10/56
Message-ID: <5910@tekred.CNA.TEK.COM>
Date: 12 Jul 90 00:30:19 GMT
Sender: news@tekred.CNA.TEK.COM
Lines: 2280
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 10, Issue 55
Archive-name: nethack3p9/Part10
Supersedes: NetHack3: Volume 7, Issue 56-93



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 10 (of 56)."
# Contents:  include/extern.h src/mkobj.c
# Wrapped by billr@saab on Wed Jul 11 17:11:03 1990
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'include/extern.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/extern.h'\"
else
echo shar: Extracting \"'include/extern.h'\" \(42801 characters\)
sed "s/^X//" >'include/extern.h' <<'END_OF_FILE'
X/*	SCCS Id: @(#)extern.h	3.0	89/11/22
X/* 	Copyright (c)   Steve Creps, 1988. 		 */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#ifndef EXTERN_H
X#define EXTERN_H
X
X#if defined(MSDOS) && defined(MSC)
X/* MSC include files do not contain "extern" keyword */
X#define E
X#else
X#define E extern
X#endif
X
X/* ### allmain.c ### */
X
XE int NDECL((*occupation));
XE int NDECL((*afternmv));
XE void NDECL(moveloop);
XE void NDECL(stop_occupation);
XE void NDECL(newgame);
X
X/* ### alloc.c ### */
X
X#ifndef __TURBOC__
XE long *FDECL(alloc, (unsigned int));
X#endif
X
X#if !defined(MAKEDEFS_C) && !defined(LEV_LEX_C)
X
X/* ### amiwbench.c ### */
X
X#ifdef AMIGA_WBENCH
XE void FDECL(ami_wbench_init,(int,char *[]));	
XE void NDECL(ami_wbench_args);
XE int FDECL(ami_wbench_getsave,(int));
XE void FDECL(ami_wbench_unlink,(char *));
XE int FDECL(ami_wbench_iconsize,(char *));
XE void FDECL(ami_wbench_iconwrite,(char *));
XE int FDECL(ami_wbench_badopt,(char *));
XE void NDECL(ami_wbench_cleanup);
X#endif /* AMIGA_WBENCH */
X
X/* ### apply.c ### */
X
X#ifdef OVERLAY
XE int NDECL(dig);
X#endif
XE int NDECL(doapply);
XE int NDECL(holetime);
XE void NDECL(dighole);
XE int NDECL(dorub);
XE int NDECL(dojump);
X#ifdef WALKIES
XE int NDECL(number_leashed);
XE void FDECL(o_unleash, (struct obj *));
XE void FDECL(m_unleash, (struct monst *));
XE void NDECL(unleash_all);
XE boolean NDECL(next_to_u);
XE struct obj *FDECL(get_mleash, (struct monst *));
XE void FDECL(check_leash, (XCHAR_P,XCHAR_P));
X#endif
XE boolean FDECL(um_dist, (XCHAR_P,XCHAR_P,XCHAR_P));
XE int FDECL(use_unicorn_horn, (struct obj *));
X
X/* ### artifact.c ### */
X
X#ifdef NAMED_ITEMS
XE void NDECL(init_exists);
XE void FDECL(mkartifact, (struct obj **));
XE boolean FDECL(is_artifact, (struct obj *));
XE boolean FDECL(exist_artifact, (struct obj *,const char *));
XE void FDECL(artifact_exists, (struct obj *,const char *,BOOLEAN_P));
XE boolean FDECL(spec_ability, (struct obj *,unsigned));
XE int FDECL(restr_name, (struct obj *,char *));
X# if defined(THEOLOGY) && defined(ALTARS)
XE struct obj *FDECL(mk_aligned_artifact, (unsigned));
X# endif
XE int FDECL(defends, (int,struct obj *));
XE int FDECL(spec_abon, (struct obj *,struct permonst *));
XE int FDECL(spec_dbon, (struct obj *,struct permonst *,int));
X#endif
X
X/* ### attrib.c ### */
X
XE void FDECL(adjattrib, (int,int,BOOLEAN_P));
XE void FDECL(change_luck, (SCHAR_P));
XE int FDECL(stone_luck, (BOOLEAN_P));
XE void FDECL(gainstr, (struct obj *,int));
XE void FDECL(losestr, (int));
XE void NDECL(restore_attrib);
XE void FDECL(init_attr, (int));
XE void NDECL(redist_attr);
XE void FDECL(adjabil, (int,int));
XE int NDECL(newhp);
XE schar FDECL(acurr, (int));
XE void FDECL(adjalign, (int));
X
X/* ### bones.c ### */
X
XE void NDECL(savebones);
XE int NDECL(getbones);
XE void FDECL(name_file, (char *,int));
X
X/* ### cmd.c ### */
X
X#ifdef OVERLAY
XE int NDECL(doextcmd);
X#ifdef POLYSELF
XE int NDECL(domonability);
X#endif /* POLYSELF */
XE int NDECL(timed_occupation);
X#if defined(WIZARD) || defined(EXPLORE_MODE)
XE int NDECL(wiz_attributes);
X#endif /* WIZARD */
X# ifdef EXPLORE_MODE
XE int NDECL(enter_explore_mode);
X# endif	/* EXPLORE_MODE */
X#ifdef WIZARD
XE int NDECL(wiz_detect);
XE int NDECL(wiz_genesis);
XE int NDECL(wiz_identify);
XE int NDECL(wiz_level_tele);
XE int NDECL(wiz_map);
XE int NDECL(wiz_where);
XE int NDECL(wiz_wish);
X#endif /* WIZARD */
X#endif /* OVERLAY */
XE void NDECL(reset_occupations);
XE void FDECL(set_occupation, (int NDECL((*)),const char *,int));
X#ifdef REDO
XE char NDECL(pgetchar);
XE void FDECL(pushch, (CHAR_P));
XE void FDECL(savech, (CHAR_P));
X#endif
XE void FDECL(rhack, (char *));
XE char FDECL(lowc, (CHAR_P));
XE void NDECL(enlightenment);
XE int FDECL(xytod, (SCHAR_P,SCHAR_P));
XE void FDECL(dtoxy, (coord *,int));
XE int FDECL(movecmd, (CHAR_P));
XE int FDECL(getdir, (BOOLEAN_P));
XE void NDECL(confdir);
XE int FDECL(isok, (int,int));
XE int NDECL(doextlist);
X
X/* ### dbridge.c ### */
X
XE boolean FDECL(is_pool, (int,int));
X#ifdef STRONGHOLD
XE void FDECL(initsym, (int,int));
XE int FDECL(is_drawbridge_wall, (int, int));
XE boolean FDECL(is_db_wall, (int, int));
XE boolean FDECL(find_drawbridge, (int *, int*));
XE boolean FDECL(create_drawbridge, (int, int, int, BOOLEAN_P));
XE void FDECL(open_drawbridge, (int, int));
XE void FDECL(close_drawbridge, (int, int));
XE void FDECL(destroy_drawbridge, (int, int));
X#endif	/* STRONGHOLD /**/
X
X/* ### decl.c ### */
X
X/* ### demon.c ### */
X
XE void FDECL(dsummon, (struct permonst *));
XE int FDECL(demon_talk, (struct monst *));
XE long FDECL(bribe, (struct monst *));
XE int NDECL(dprince);
XE int NDECL(dlord);
XE int NDECL(ndemon);
X
X/* ### do.c ### */
X
X#ifdef OVERLAY
XE int FDECL(drop, (struct obj *));
XE int NDECL(wipeoff);
X#endif
XE int NDECL(dodrop);
XE boolean FDECL(flooreffects, (struct obj *,int,int));
X#ifdef ALTARS
XE void FDECL(doaltarobj, (struct obj *));
X#endif
XE boolean FDECL(canletgo, (struct obj *,const char *));
XE void FDECL(dropx, (struct obj *));
XE void FDECL(dropy, (struct obj *));
XE int NDECL(doddrop);
XE int NDECL(dodown);
XE int NDECL(doup);
XE void FDECL(goto_level, (int,BOOLEAN_P,BOOLEAN_P));
XE int NDECL(donull);
XE int NDECL(dowipe);
XE struct obj *FDECL(splitobj, (struct obj *,int));
XE void FDECL(set_wounded_legs, (long,int));
XE void NDECL(heal_legs);
X
X/* ### do_name.c ### */
X
XE void FDECL(getpos, (coord *,int,const char *));
XE struct monst *FDECL(christen_monst, (struct monst *,const char *));
XE int NDECL(do_mname);
XE struct obj *FDECL(oname, (struct obj *,const char *,int));
XE int NDECL(ddocall);
XE void FDECL(docall, (struct obj *));
XE char *FDECL(x_monnam, (struct monst *,int));
XE char *FDECL(lmonnam, (struct monst *));
XE char *FDECL(mon_nam, (struct monst *));
XE char *FDECL(Monnam, (struct monst *));
XE char *FDECL(a_monnam, (struct monst *,const char *));
XE char *FDECL(a2_monnam, (struct monst *,const char *));
XE char *FDECL(Amonnam, (struct monst *,const char *));
XE char *FDECL(Xmonnam, (struct monst *));
XE char *FDECL(defmonnam, (struct monst *));
XE const char *NDECL(rndmonnam);
XE char *FDECL(self_pronoun, (const char *,const char *));
X#ifdef REINCARNATION
XE const char *NDECL(roguename);
X#endif
X
X/* ### do_wear.c ### */
X
X#ifdef OVERLAY
XE int NDECL(Armor_on);
XE int NDECL(Boots_on);
XE int NDECL(Gloves_on);
XE int NDECL(Helmet_on);
XE int FDECL(select_off, (struct obj *));
XE int NDECL(take_off);
X#endif
XE void FDECL(off_msg, (struct obj *));
XE boolean FDECL(is_helmet, (struct obj *));
XE boolean FDECL(is_gloves, (struct obj *));
XE boolean FDECL(is_boots, (struct obj *));
XE boolean FDECL(is_cloak, (struct obj *));
XE boolean FDECL(is_shield, (struct obj *));
XE void NDECL(set_wear);
XE boolean FDECL(donning, (struct obj *));
XE void NDECL(cancel_don);
XE int NDECL(Armor_off);
XE int NDECL(Armor_gone);
XE int NDECL(Helmet_off);
XE int NDECL(Gloves_off);
XE int NDECL(Boots_off);
XE int NDECL(Cloak_off);
XE int NDECL(Shield_off);
XE void NDECL(Amulet_off);
XE void FDECL(Ring_on, (struct obj *));
XE void FDECL(Ring_off, (struct obj *));
XE void FDECL(Ring_gone, (struct obj *));
XE void FDECL(Blindf_on, (struct obj *));
XE void FDECL(Blindf_off, (struct obj *));
XE int NDECL(dotakeoff);
XE int NDECL(doremring);
XE int FDECL(cursed, (struct obj *));
XE int FDECL(armoroff, (struct obj *));
XE int NDECL(dowear);
XE int NDECL(doputon);
XE void NDECL(find_ac);
XE void NDECL(glibr);
XE struct obj *NDECL(some_armor);
XE void NDECL(corrode_armor);
XE void NDECL(reset_remarm);
XE int NDECL(doddoremarm);
XE int FDECL(destroy_arm, (struct obj *));
XE void FDECL(adj_abon, (struct obj *,SCHAR_P));
X
X/* ### dog.c ### */
X
XE void FDECL(initedog, (struct monst *));
XE void FDECL(make_familiar, (struct obj *));
XE struct monst *NDECL(makedog);
XE void NDECL(losedogs);
XE void NDECL(keepdogs);
XE void FDECL(fall_down, (struct monst *,int));
XE int FDECL(dogfood, (struct monst *,struct obj *));
XE int FDECL(inroom, (XCHAR_P,XCHAR_P));
XE struct monst *FDECL(tamedog, (struct monst *,struct obj *));
X
X/* ### dogmove.c ### */
X
XE int FDECL(dog_move, (struct monst *,int));
X
X/* ### dokick.c ### */
X
XE boolean FDECL(ghitm, (struct monst *,long));
XE boolean FDECL(bad_kick_throw_pos, (XCHAR_P,XCHAR_P));
XE struct monst *FDECL(ghit, (int,int,int));
XE int NDECL(dokick);
X
X/* ### dothrow.c ### */
X
XE int NDECL(dothrow);
XE int FDECL(throwit, (struct obj *));
XE int FDECL(thitmonst, (struct monst *,struct obj *));
XE int FDECL(breaks, (struct obj *,BOOLEAN_P));
X
X/* ### eat.c ### */
X
X#ifdef OVERLAY
XE int NDECL(Meatdone);
XE int NDECL(eatfood);
XE int NDECL(opentin);
XE int NDECL(unfaint);
X#endif
X#ifdef POLYSELF
XE boolean FDECL(is_edible, (struct obj *));
X#endif
XE void NDECL(init_uhunger);
XE int NDECL(Hear_again);
XE void NDECL(reset_eat);
XE int NDECL(doeat);
XE void NDECL(gethungry);
XE void FDECL(morehungry, (int));
XE void FDECL(lesshungry, (int));
XE boolean NDECL(is_fainted);
XE void NDECL(reset_faint);
XE void NDECL(sync_hunger);
XE void FDECL(newuhs, (BOOLEAN_P));
XE struct obj *FDECL(floorfood, (const char *,BOOLEAN_P));
XE void NDECL(vomit);
XE int FDECL(eaten_stat, (int, struct obj *));
XE void FDECL(food_disappears, (struct obj *));
X
X/* ### end.c ### */
X
XE int NDECL(done1);
XE int NDECL(done2);
X#ifdef OVERLAY
XE int NDECL(done_intr);
X#endif
XE void FDECL(done_in_by, (struct monst *));
XE void VDECL(panic, (const char *,...));
XE void FDECL(done, (int));
XE void NDECL(clearlocks);
X#ifdef NOSAVEONHANGUP
XE void NDECL(hangup);
X#endif
X
X/* ### engrave.c ### */
X
X#ifdef ELBERETH
XE int FDECL(sengr_at, (const char *,XCHAR_P,XCHAR_P));
X#endif
XE void FDECL(u_wipe_engr, (int));
XE void FDECL(wipe_engr_at, (XCHAR_P,XCHAR_P,XCHAR_P));
XE void FDECL(read_engr_at, (int,int));
XE void FDECL(make_engr_at, (int,int,const char *));
XE int NDECL(freehand);
XE int NDECL(doengrave);
XE void FDECL(save_engravings, (int));
XE void FDECL(rest_engravings, (int));
X
X/* ### exper.c ### */
X
XE long FDECL(newuexp, (unsigned));
XE int FDECL(experience, (struct monst *,int));
XE void FDECL(more_experienced, (int,int));
XE void NDECL(losexp);
XE void NDECL(newexplevel);
XE void NDECL(pluslvl);
XE long NDECL(rndexp);
X
X/* ### extralev.c ### */
X
X#ifdef REINCARNATION
XE void NDECL(makeroguerooms);
XE void FDECL(corr, (int,int));
XE void NDECL(makerogueghost);
X#endif
X
X/* ### fountain.c ### */
X
X#ifdef FOUNTAINS
XE void NDECL(dryup);
XE void NDECL(drinkfountain);
XE void FDECL(dipfountain, (struct obj *));
X#endif /* FOUNTAINS */
X#ifdef SINKS
XE void NDECL(drinksink);
X#endif
X
X/* ### getline.c ### */
X
XE void FDECL(getlin, (char *));
XE void NDECL(getret);
XE void FDECL(cgetret, (const char *));
XE void FDECL(xwaitforspace, (const char *));
XE char *NDECL(parse);
XE char NDECL(readchar);
X#ifdef COM_COMPL
XE void FDECL(get_ext_cmd, (char *));
X#endif /* COM_COMPL */
X
X/* ### hack.c ### */
X
XE void NDECL(unsee);
XE void FDECL(seeoff, (int));
XE void FDECL(movobj, (struct obj *,XCHAR_P,XCHAR_P));
XE boolean FDECL(may_dig, (XCHAR_P,XCHAR_P));
XE void NDECL(domove);
XE void NDECL(spoteffects);
XE int NDECL(dopickup);
XE void NDECL(lookaround);
XE int NDECL(monster_nearby);
XE int FDECL(cansee, (XCHAR_P,XCHAR_P));
XE int FDECL(sgn, (int));
XE void FDECL(getcorners, (xchar *,xchar *,xchar *,xchar *,xchar *,xchar *,xchar *,xchar *));
XE void NDECL(setsee);
XE void FDECL(nomul, (int));
XE void FDECL(losehp, (int,const char *,BOOLEAN_P));
XE int NDECL(weight_cap);
XE int NDECL(inv_weight);
XE int NDECL(inv_cnt);
XE int FDECL(identify, (struct obj *));
X#ifdef STUPID_CPP	/* otherwise these functions are macros in hack.h */
XE char NDECL(yn);
XE char NDECL(ynq);
XE char NDECL(ynaq);
XE char NDECL(nyaq);
XE char *FDECL(plur, (long));
XE void FDECL(makeknown, (unsigned));
X#endif
X
X/* ### invent.c ### */
X
X#ifdef OVERLAY
XE int FDECL(ckunpaid, (struct obj *));
X#endif
XE struct obj *FDECL(addinv, (struct obj *));
XE void FDECL(useup, (struct obj *));
XE void FDECL(freeinv, (struct obj *));
XE void FDECL(delobj, (struct obj *));
XE void FDECL(freeobj, (struct obj *));
XE void FDECL(freegold, (struct gold *));
XE struct obj *FDECL(sobj_at, (int,int,int));
XE int FDECL(carried, (struct obj *));
XE struct obj *FDECL(carrying, (int));
XE boolean NDECL(have_lizard);
XE struct obj *FDECL(o_on, (unsigned int,struct obj *));
XE boolean FDECL(obj_here, (struct obj *,int,int));
XE struct gold *FDECL(g_at, (int,int));
XE struct obj *FDECL(getobj, (const char *,const char *));
XE int FDECL(ggetobj, (const char *,int FDECL((*),(struct obj *)),int));
XE int FDECL(askchain, (struct obj *,int,const char *,int,int FDECL((*),(struct obj *)),int FDECL((*),(struct obj *)),int,const char *));
XE void FDECL(prinv, (struct obj *));
XE int NDECL(ddoinv);
XE void FDECL(doinv, (const char *));
XE int NDECL(dotypeinv);
XE int NDECL(dolook);
XE void FDECL(stackobj, (struct obj *));
XE int NDECL(doprgold);
XE int NDECL(doprwep);
XE int NDECL(doprarm);
XE int NDECL(doprring);
XE int NDECL(dopramulet);
XE int NDECL(doprtool);
XE int FDECL(digit, (CHAR_P));
XE void FDECL(useupf, (struct obj *));
XE char *FDECL(let_to_name, (CHAR_P));
XE void NDECL(reassign);
X
X/* ### ioctl.c ### */
X
X#ifdef UNIX
XE void NDECL(getioctls);
XE void NDECL(setioctls);
X# ifdef SUSPEND
XE int NDECL(dosuspend);
X# endif /* SUSPEND */
X#endif /* UNIX */
X
X/* ### lock.c ### */
X
X#ifdef OVERLAY
XE int NDECL(forcelock);
XE int NDECL(picklock);
X#endif
XE void NDECL(reset_pick);
XE int FDECL(pick_lock, (struct obj *));
XE int NDECL(doforce);
XE int FDECL(boxlock, (struct obj *,struct obj *));
XE int FDECL(doorlock, (struct obj *,int,int));
XE int NDECL(doopen);
XE int NDECL(doclose);
X
X/* ### mac.c ### */
X/* All of these Mac-specific declarations LOOK like they should take the
X   NDECL() form, but don't be fooled: it's just that (at the time of
X   writing) the Mac C compilers are all pre-ANSI and the prototype
X   information isn't recorded here anyway. sps 89dec14
X*/
X#ifdef MACOS
XE int tgetch();
XE void gethdate();
XE int uptodate();
X# ifndef THINKC4
XE char *getenv();
XE int memcmp();
X# else
XE int kbhit();
X# endif
XE int mcurs();
XE int mputc();
XE int mputs();
XE int mprintf();
XE DialogTHndl centreDlgBox();
XE int about();
X#endif  /* MACOS */
X
X/* ### macfile.c ### */
X#ifdef MACOS
XE short findNamedFile();
XE FILE *openFile();
X#endif	/* MACOS */
X
X/* ### macinit.c ### */
X#ifdef MACOS
XE int initterm();
XE int freeterm();
XE int read_config_file();
XE int write_opts();
X#endif
X#ifdef SMALLDATA
XE void init_decl();
XE void free_decl();
X#endif  /* SMALLDATA */
X
X/* ### mail.c ### */
X
X#ifdef MAIL
X# ifdef UNIX
XE void NDECL(getmailstatus);
X# endif
XE void NDECL(ckmailstatus);
XE void NDECL(readmail);
X#endif /* MAIL */
X
X/* ### makemon.c ### */
X
XE struct monst *FDECL(makemon, (struct permonst *,int,int));
XE boolean FDECL(enexto, (coord *,XCHAR_P,XCHAR_P,struct permonst *));
XE int FDECL(goodpos, (int,int, struct permonst *));
XE void FDECL(rloc, (struct monst *));
XE void FDECL(vloc, (struct monst *));
XE void NDECL(init_monstr);
XE struct permonst *NDECL(rndmonst);
XE struct permonst *FDECL(mkclass, (CHAR_P));
XE int FDECL(adj_lev, (struct permonst *));
XE struct permonst *FDECL(grow_up, (struct monst *));
XE int FDECL(mongets, (struct monst *,int));
X#ifdef GOLEMS
XE int FDECL(golemhp, (int));
X#endif /* GOLEMS */
XE boolean FDECL(peace_minded, (struct permonst *));
XE void FDECL(set_malign, (struct monst *));
XE void FDECL(set_mimic_sym, (struct monst *));
X
X/* ### mcastu.c ### */
X
XE int FDECL(castmu, (struct monst *,struct attack *));
XE int FDECL(buzzmu, (struct monst *,struct attack *));
X
X/* ### mhitm.c ### */
X
XE int FDECL(fightm, (struct monst *));
XE int FDECL(mattackm, (struct monst *,struct monst *));
XE int FDECL(noattacks, (struct permonst *));
X
X/* ### mhitu.c ### */
X
X#ifdef POLYSELF
XE struct monst *NDECL(cloneu);
X#endif
XE void FDECL(expels, (struct monst *,struct permonst *,BOOLEAN_P));
XE int FDECL(mattacku, (struct monst *));
XE void FDECL(mdamageu, (struct monst *,int));
XE int FDECL(could_seduce, (struct monst *,struct monst *,struct attack *));
X#ifdef SEDUCE
XE int FDECL(doseduce, (struct monst *));
X#endif
X
X/* ### mklev.c ### */
X
XE int FDECL(somex, (struct mkroom *));
XE int FDECL(somey, (struct mkroom *));
X#ifdef OVERLAY
XE int FDECL(comp, (genericptr_t, genericptr_t));
X#endif
X#ifdef ORACLE
XE boolean FDECL(place_oracle, (struct mkroom *,int *,int *,int *));
X#endif
XE void NDECL(mklev);
XE int FDECL(okdoor, (XCHAR_P,XCHAR_P));
XE void FDECL(dodoor, (int,int,struct mkroom *));
XE void FDECL(mktrap, (int,int,struct mkroom *));
X#ifdef FOUNTAINS
XE void FDECL(mkfount, (int,struct mkroom *));
X#endif
X
X/* ### mkmaze.c ### */
X
X#if defined(WALLIFIED_MAZE) || defined(STRONGHOLD)
XE void FDECL(wallification, (int,int,int,int,BOOLEAN_P));
X#endif
XE void FDECL(walkfrom, (int,int));
XE void NDECL(makemaz);
XE void FDECL(move, (int *,int *,int));
XE void FDECL(mazexy, (coord *));
XE void NDECL(bound_digging);
X
X/* ### mkobj.c ### */
X
XE struct obj *FDECL(mkobj_at, (CHAR_P,int,int,BOOLEAN_P));
XE struct obj *FDECL(mksobj_at, (int,int,int));
XE struct obj *FDECL(mkobj, (CHAR_P,BOOLEAN_P));
XE int NDECL(rndmonnum);
XE struct obj *FDECL(mksobj, (int,BOOLEAN_P));
XE int FDECL(letter, (int));
XE int FDECL(weight, (struct obj *));
XE void FDECL(mkgold, (long,int,int));
XE struct obj *FDECL(mkcorpstat, (int,struct permonst *,int,int));
XE struct obj *FDECL(mk_tt_object, (int,int,int));
XE struct obj *FDECL(mk_named_object, (int,struct permonst *,int,int,char *,int));
XE void FDECL(bless, (struct obj *));
XE void FDECL(curse, (struct obj *));
XE void FDECL(blessorcurse, (struct obj *,int));
XE boolean FDECL(is_flammable, (struct obj *));
X#ifdef STUPID_CPP
XE boolean FDECL(is_rustprone, (struct obj *));
XE boolean FDECL(is_corrodeable, (struct obj *));
XE boolean FDECL(OBJ_AT, (int, int));
X#endif
XE void FDECL(place_object, (struct obj *,int,int));
XE void FDECL(move_object, (struct obj *,int,int));
XE void FDECL(remove_object, (struct obj *));
XE int FDECL(bcsign, (struct obj *));
X
X/* ### mkroom.c ### */
X
XE void FDECL(mkroom, (int));
X#if defined(ALTARS) && defined(THEOLOGY)
XE void FDECL(shrine_pos, (int *, int*, struct mkroom *));
X#endif
XE boolean FDECL(nexttodoor, (int,int));
XE boolean FDECL(has_dnstairs, (struct mkroom *));
XE boolean FDECL(has_upstairs, (struct mkroom *));
XE int FDECL(dist2, (int,int,int,int));
X#ifdef THRONES
XE struct permonst *NDECL(courtmon);
X#endif
X
X/* ### mon.c ### */
X
XE void NDECL(movemon);
XE void FDECL(meatgold, (struct monst *));
XE void FDECL(meatobj, (struct monst *));
XE void FDECL(mpickgold, (struct monst *));
XE void FDECL(mpickgems, (struct monst *));
XE int FDECL(curr_mon_load, (struct monst *));
XE int FDECL(max_mon_load, (struct monst *));
XE boolean FDECL(can_carry, (struct monst *,struct obj *));
XE void FDECL(mpickstuff, (struct monst *,const char *));
XE int FDECL(mfndpos, (struct monst *,coord *,long *,long));
XE int FDECL(dist, (int,int));
XE boolean FDECL(monnear, (struct monst *,int,int));
XE void FDECL(poisontell, (int));
XE void FDECL(poisoned, (const char *,int,const char *,int));
XE void FDECL(mondead, (struct monst *));
XE void FDECL(replmon, (struct monst *,struct monst *));
XE void FDECL(relmon, (struct monst *));
XE void FDECL(monfree, (struct monst *));
XE void FDECL(unstuck, (struct monst *));
XE void FDECL(killed, (struct monst *));
XE void FDECL(xkilled, (struct monst *,int));
XE void NDECL(rescham);
XE void NDECL(restartcham);
XE int FDECL(newcham, (struct monst *,struct permonst *));
XE void FDECL(mnexto, (struct monst *));
XE void FDECL(mnearto, (struct monst *, XCHAR_P, XCHAR_P, BOOLEAN_P));
XE void FDECL(setmangry, (struct monst *));
XE int FDECL(disturb, (struct monst *));
XE void FDECL(mondied, (struct monst *));
XE void FDECL(mongone, (struct monst *));
XE void FDECL(monstone, (struct monst *));
X#ifdef GOLEMS
XE void FDECL(golemeffects, (struct monst *, int, int));
X#endif /* GOLEMS */
X
X/* ### mondata.c ### */
X
XE boolean FDECL(attacktype, (struct permonst *,int));
XE boolean FDECL(resists_ston, (struct permonst *));
XE boolean FDECL(resists_drli, (struct permonst *));
XE boolean FDECL(ranged_attk, (struct permonst *));
XE boolean FDECL(can_track, (struct permonst *));
X#ifdef POLYSELF
XE boolean FDECL(breakarm, (struct permonst *));
XE boolean FDECL(sliparm, (struct permonst *));
X#endif
XE boolean FDECL(sticks, (struct permonst *));
XE boolean FDECL(canseemon, (struct monst *));
XE boolean FDECL(dmgtype, (struct permonst *,int));
XE int FDECL(monsndx, (struct permonst *));
XE int FDECL(name_to_mon, (char *));
X#ifdef POLYSELF
XE boolean FDECL(webmaker, (struct permonst *));
X#endif
XE boolean FDECL(is_female, (struct monst *));
XE int FDECL(gender, (struct monst *));
XE boolean FDECL(levl_follower, (struct monst *));
XE struct permonst *NDECL(player_mon);
XE int FDECL(little_to_big, (int));
XE int FDECL(big_to_little, (int));     
XE const char *FDECL(locomotion, (const struct permonst *,const char *));
X
X/* ### monmove.c ### */
X
XE boolean FDECL(mb_trapped, (struct monst *));
XE int FDECL(dochugw, (struct monst *));
XE boolean FDECL(onscary, (int,int,struct monst *));
XE int FDECL(dochug, (struct monst *));
XE int FDECL(m_move, (struct monst *,int));
XE boolean FDECL(closed_door, (int, int));
XE boolean FDECL(accessible, (int, int));
XE void FDECL(set_apparxy, (struct monst *));
XE boolean FDECL(mdig_tunnel, (struct monst *));
X#ifdef STUPID_CPP
XE boolean FDECL(MON_AT, (int, int));
XE void FDECL(place_monster, (struct monst *, int, int));
XE void FDECL(place_worm_seg, (struct monst *, int, int));
XE void FDECL(remove_monster, (int, int));
XE struct monst *FDECL(m_at, (int, int));
X#endif
X
X/* ### monst.c ### */
X
X/* ### msdos.c ### */
X
X#ifdef MSDOS
XE void NDECL(flushout);
XE int NDECL(tgetch);
XE int NDECL(dosh);
X# ifdef DGK
XE long FDECL(freediskspace, (char *));
XE long FDECL(filesize, (char *));
XE void FDECL(eraseall, (const char *,const char *));
XE void FDECL(copybones, (int));
XE void NDECL(playwoRAMdisk);
XE int FDECL(saveDiskPrompt, (int));
XE void NDECL(gameDiskPrompt);
X# endif
XE void NDECL(read_config_file);
XE void NDECL(set_lock_and_bones);
XE void FDECL(append_slash, (char *));
XE void FDECL(getreturn, (const char *));
XE void VDECL(msmsg, (const char *,...));
XE void FDECL(chdrive, (char *));
X# ifndef TOS
XE void NDECL(disable_ctrlP);
XE void NDECL(enable_ctrlP);
X# endif
X# ifdef DGK
XE FILE *FDECL(fopenp, (const char *,const char *));
X# endif
XE void FDECL(msexit, (int));
X# ifdef DGK
XE void NDECL(get_scr_size);
X#  ifndef TOS
XE void FDECL(gotoxy, (int,int));
X#  endif
X# endif
X#endif /* MSDOS */
X#ifdef TOS
XE int FDECL(_copyfile, (char *, char *));
XE int NDECL(kbhit);
XE void NDECL(restore_colors);
XE void NDECL(set_colors);
X#endif /* TOS */
X
X/* ### mthrowu.c ### */
X
XE int FDECL(thitu, (int,int,struct obj *,const char *));
XE int FDECL(thrwmu, (struct monst *));
XE int FDECL(spitmu, (struct monst *,struct attack *));
XE int FDECL(breamu, (struct monst *,struct attack *));
XE boolean FDECL(linedup, (XCHAR_P,XCHAR_P,XCHAR_P,XCHAR_P));
XE boolean FDECL(lined_up, (struct monst *));
XE struct obj *FDECL(m_carrying, (struct monst *,int));
XE void FDECL(m_useup, (struct monst *,struct obj *));
X
X/* ### music.c ### */
X
X#ifdef MUSIC
XE int FDECL(do_play_instrument, (struct obj *));
X#endif /* MUSIC /**/
X
X/* ### o_init.c ### */
X
XE int FDECL(letindex, (CHAR_P));
XE void NDECL(init_objects);
XE void NDECL(oinit);
XE void FDECL(savenames, (int));
XE void FDECL(restnames, (int));
XE int NDECL(dodiscovered);
X
X/* ### objnam.c ### */
X
XE char *FDECL(typename, (int));
XE char *FDECL(distant_name, (struct obj *, char *(*)(struct obj *)));
XE char *FDECL(xname, (struct obj *));
XE char *FDECL(doname, (struct obj *));
XE char *FDECL(singular, (struct obj *, char *(*)(struct obj *)));
XE char *FDECL(an, (const char *));
XE char *FDECL(An, (const char *));
XE char *FDECL(aobjnam, (struct obj *,const char *));
XE char *FDECL(Doname2, (struct obj *));
XE void FDECL(lcase, (char *));
XE char *FDECL(makeplural, (const char *));
XE char *FDECL(makesingular, (const char *));
XE struct obj *FDECL(readobjnam, (char *));
XE int FDECL(rnd_class, (int,int));
X
X/* ### options.c ### */
X
XE void NDECL(initoptions);
XE void FDECL(assign_graphics, (unsigned int *, int));
XE void NDECL(assign_ibm_graphics);
XE void NDECL(assign_dec_graphics);
XE void FDECL(parseoptions, (char *,BOOLEAN_P));
XE int NDECL(doset);
XE int NDECL(dotogglepickup);
XE void NDECL(option_help);
XE int FDECL(next_opt, (const char *));
X#ifdef TUTTI_FRUTTI
XE int FDECL(fruitadd, (char *));
X#endif
X
X/* ### pager.c ### */
X
XE int NDECL(dowhatis);
XE int NDECL(dowhatdoes);
XE void NDECL(set_whole_screen);
X#ifdef NEWS
XE int NDECL(readnews);
X#endif /* NEWS */
XE void FDECL(set_pager, (int));
XE int FDECL(page_line, (const char *));
XE void FDECL(cornline, (int,const char *));
XE int NDECL(dohelp);
XE int NDECL(dohistory);
XE int FDECL(page_file, (const char *,BOOLEAN_P));
X#ifdef UNIX
X# ifdef SHELL
XE int NDECL(dosh);
X# endif /* SHELL */
X# if defined(SHELL) || defined(DEF_PAGER) || defined(DEF_MAILREADER)
XE int FDECL(child, (int));
X# endif
X#endif /* UNIX */
X
X/* ### pcmain.c ### */
X
X#if defined(MSDOS) || defined(MACOS)
XE void NDECL(askname);
X# ifdef CHDIR
XE void FDECL(chdirx, (char *,BOOLEAN_P));
X# endif /* CHDIR */
X#endif /* MSDOS || MACOS */
X
X/* ### pctty.c ### */
X
X#if defined(MSDOS) || defined(MACOS)
XE void NDECL(gettty);
XE void FDECL(settty, (const char *));
XE void VDECL(error, (const char *,...));
X#endif /* MSDOS || MACOS  */
X
X/* ### pcunix.c ### */
X
X#if defined(MSDOS) || defined(MACOS)
X# ifndef OLD_TOS
XE void NDECL(setrandom);
XE int NDECL(getyear);
XE char *NDECL(getdate);
XE int NDECL(phase_of_the_moon);
XE int NDECL(night);
XE int NDECL(midnight);
XE void FDECL(gethdate, (char *));
XE int FDECL(uptodate, (int));
X# endif /* TOS */
XE void FDECL(regularize, (char *));
X#endif /* MSDOS */
X
X/* ### pickup.c ### */
X
X#ifdef OVERLAY
XE int FDECL(ck_bag, (struct obj *));
XE int FDECL(ck_container, (struct obj *));
XE int FDECL(in_container, (struct obj *));
XE int FDECL(out_container, (struct obj *));
X#endif
XE void FDECL(pickup, (int));
XE struct obj *FDECL(pick_obj, (struct obj *));
XE int NDECL(doloot);
XE void FDECL(use_container, (struct obj *, int));
XE void FDECL(inc_cwt, (struct obj *, struct obj *));
XE void FDECL(delete_contents, (struct obj *));
XE void FDECL(dec_cwt, (struct obj *, struct obj *));
X
X/* ### polyself.c ### */
X
XE void NDECL(newman);
X#ifdef POLYSELF
XE void NDECL(polyself);
XE int FDECL(polymon, (int));
XE void NDECL(rehumanize);
XE int NDECL(dobreathe);
XE int NDECL(dospit);
XE int NDECL(doremove);
XE int NDECL(dospinweb);
XE int NDECL(dosummon);
XE int NDECL(doconfuse);
XE int NDECL(dohide);
X#endif
XE const char *FDECL(body_part, (int));
XE int NDECL(poly_gender);
X#ifdef POLYSELF
X# ifdef GOLEMS
XE void FDECL(ugolemeffects, (int, int));
X# endif /* GOLEMS */
X#endif
X
X/* ### potion.c ### */
X
XE void FDECL(make_confused, (long,BOOLEAN_P));
XE void FDECL(make_stunned, (long,BOOLEAN_P));
XE void FDECL(make_blinded, (long,BOOLEAN_P));
XE void FDECL(make_sick, (long,BOOLEAN_P));
XE void FDECL(make_vomiting, (long,BOOLEAN_P));
XE void FDECL(make_hallucinated, (long,BOOLEAN_P));
XE int NDECL(dodrink);
XE int FDECL(dopotion, (struct obj *));
XE int FDECL(peffects, (struct obj *));
XE void FDECL(healup, (int,int,BOOLEAN_P,BOOLEAN_P));
XE void FDECL(strange_feeling, (struct obj *,const char *));
XE void FDECL(potionhit, (struct monst *,struct obj *));
XE void FDECL(potionbreathe, (struct obj *));
XE boolean FDECL(get_wet, (struct obj *));
XE int NDECL(dodip);
XE void FDECL(djinni_from_bottle, (struct obj *));
XE int FDECL(monster_detect, (struct obj *));
XE int FDECL(object_detect, (struct obj *));
XE int FDECL(trap_detect, (struct obj *));
X
X/* ### pray.c ### */
X
X# ifdef THEOLOGY
XE int NDECL(dosacrifice);
XE int NDECL(dopray);
XE const char *NDECL(u_gname);
X#endif /* THEOLOGY */
XE int NDECL(doturn);
X#ifdef ALTARS
XE const char *NDECL(a_gname);
XE const char *FDECL(a_gname_at, (XCHAR_P,XCHAR_P));
X# ifdef THEOLOGY
XE void FDECL(altar_wrath, (int,int));
X# endif
X#endif
X
X/* ### pri.c ### */
X
XE char *FDECL(eos, (char *));
XE void FDECL(swallowed, (int));
XE void NDECL(setclipped);
X#ifdef CLIPPING
XE void FDECL(cliparound, (int, int));
X#endif
XE boolean FDECL(showmon, (struct monst *));
XE void FDECL(at, (XCHAR_P,XCHAR_P,UCHAR_P,UCHAR_P));
XE void NDECL(prme);
XE void FDECL(shieldeff, (XCHAR_P,XCHAR_P));
XE int NDECL(doredraw);
XE void NDECL(docrt);
XE void FDECL(docorner, (int,int));
XE void NDECL(seeglds);
XE void NDECL(seeobjs);
XE void NDECL(seemons);
XE void FDECL(pmon, (struct monst *));
XE void FDECL(unpmon, (struct monst *));
XE void NDECL(nscr);
XE void NDECL(bot);
XE void FDECL(mstatusline, (struct monst *));
XE void NDECL(ustatusline);
XE void NDECL(cls);
XE void NDECL(max_rank_sz);
XE char NDECL(rndmonsym);
XE char NDECL(rndobjsym);
XE const char *NDECL(hcolor);
XE uchar FDECL(mimic_appearance, (struct monst *));
X
X/* ### priest.c ### */
X
XE int FDECL(move_special, (struct monst *,SCHAR_P,SCHAR_P,BOOLEAN_P,BOOLEAN_P,
X			XCHAR_P,XCHAR_P,XCHAR_P,XCHAR_P));
X#if defined(ALTARS) && defined(THEOLOGY)
XE struct mkroom *FDECL(in_temple, (int,int));
XE int FDECL(pri_move, (struct monst *));
XE void FDECL(priestini, (int,int,int,int));
XE char *FDECL(priestname, (struct monst *));
XE boolean FDECL(p_coaligned, (struct monst *));
XE void NDECL(intemple);
XE void FDECL(priest_talk, (struct monst *));
XE boolean FDECL(u_in_sanctuary, (struct mkroom *));
XE void NDECL(ghod_hitsu);
XE void NDECL(angry_priest);
X#endif
X
X/* ### prisym.c ### */
X
XE void FDECL(atl, (int,int,CHAR_P));
XE void FDECL(on_scr, (int,int));
XE void FDECL(tmp_at, (int,int));
XE void FDECL(Tmp_at2, (int,int));
XE void NDECL(curs_on_u);
XE void NDECL(pru);
XE void FDECL(prl, (int,int));
XE uchar FDECL(news0, (XCHAR_P,XCHAR_P));
XE void FDECL(newsym, (int,int));
XE void FDECL(mnewsym, (int,int));
XE void FDECL(nosee, (int,int));
XE void FDECL(prl1, (int,int));
XE void FDECL(nose1, (int,int));
XE int FDECL(vism_at, (int,int));
X#ifdef NEWSCR
XE void FDECL(pobj, (struct obj *));
X#endif /* NEWSCR */
XE void FDECL(unpobj, (struct obj *));
X#ifdef STUPID_CPP	/* otherwise these functions are macros in rm.h */
XE boolean FDECL(IS_WALL, (unsigned));
XE boolean FDECL(IS_STWALL, (unsigned));
XE boolean FDECL(IS_ROCK, (unsigned));
XE boolean FDECL(IS_DOOR, (unsigned));
XE boolean FDECL(ACCESSIBLE, (unsigned));
XE boolean FDECL(IS_ROOM, (unsigned));
XE boolean FDECL(ZAP_POS, (unsigned));
XE boolean FDECL(SPACE_POS, (unsigned));
XE boolean FDECL(IS_POOL, (unsigned));
XE boolean FDECL(IS_THRONE, (unsigned));
XE boolean FDECL(IS_FOUNTAIN, (unsigned));
XE boolean FDECL(IS_SINK, (unsigned));
XE boolean FDECL(IS_ALTAR, (unsigned));
XE boolean FDECL(IS_DRAWBRIDGE, (unsigned));
XE boolean FDECL(IS_FURNITURE, (unsigned));
X#endif /* STUPID_CPP */
X
X/* ### random.c ### */
X
X#ifdef RANDOM
XE void FDECL(srandom, (unsigned));
XE char * FDECL(initstate, (unsigned,char *,int));
XE char * FDECL(setstate, (char *));
XE long NDECL(random);
X#endif /* RANDOM */
X
X/* ### read.c ### */
X
XE int NDECL(doread);
XE int FDECL(seffects, (struct obj *));
XE void FDECL(litroom, (BOOLEAN_P));
XE void FDECL(do_genocide, (int));
XE void NDECL(do_mapping);
XE void NDECL(do_vicinity_map);
XE int FDECL(gold_detect, (struct obj *));
XE int FDECL(food_detect, (struct obj *));
XE void FDECL(punish, (struct obj *));
XE void NDECL(unpunish);
XE boolean FDECL(cant_create, (int *));
X#if defined(WIZARD) || defined(EXPLORE_MODE)
XE boolean NDECL(create_particular);
X#endif
X
X/* ### restore.c ### */
X
XE int FDECL(dorecover, (int));
XE void FDECL(getlev, (int,int,XCHAR_P,BOOLEAN_P));
X#ifdef ZEROCOMP
XE void NDECL(minit);
XE int FDECL(mread, (int,genericptr_t,unsigned int));
X#else
XE void FDECL(mread, (int,genericptr_t,unsigned int));
X#endif
X
X/* ### rip.c ### */
X
XE void NDECL(outrip);
X
X/* ### rnd.c ### */
X
XE int FDECL(rn1, (int,int));
XE int FDECL(rn2, (int));
XE int FDECL(rnl, (int));
XE int FDECL(rnd, (int));
XE int FDECL(d, (int,int));
XE int FDECL(rne, (int));
X#ifdef THEOLOGY
XE int FDECL(rnz, (int));
X#endif
X
X/* ### rumors.c ### */
X
XE void FDECL(outrumor, (int,BOOLEAN_P));
X#ifdef ORACLE
XE int FDECL(doconsult, (struct monst *));
X#endif
X
X/* ### save.c ### */
X
XE int NDECL(dosave);
X#ifndef NOSAVEONHANGUP
XE int NDECL(hangup);
X#endif /* NOSAVEONHANGUP */
XE int NDECL(dosave0);
X#if defined(DGK) && !defined(OLD_TOS)
XE boolean FDECL(savelev, (int,XCHAR_P,int));
XE boolean FDECL(swapin_file, (int));
X#else /* DGK && !OLD_TOS */
XE void FDECL(savelev, (int, XCHAR_P));
X#endif /* DGK && !OLD_TOS */
X#ifdef ZEROCOMP
XE void FDECL(bflush, (int));
X#endif
XE void FDECL(bwrite, (int,genericptr_t,unsigned int));
X#ifdef TUTTI_FRUTTI
XE void FDECL(savefruitchn, (int));
X#endif
X
X/* ### search.c ### */
X
XE int NDECL(findit);
XE int NDECL(dosearch);
XE int FDECL(dosearch0, (int));
XE int NDECL(doidtrap);
XE void FDECL(wakeup, (struct monst *));
XE void FDECL(seemimic, (struct monst *));
X
X/* ### shk.c ### */
X
XE char *FDECL(shkname, (struct monst *));
XE void FDECL(shkdead, (struct monst *));
XE void FDECL(replshk, (struct monst *,struct monst *));
XE int NDECL(inshop);
XE int FDECL(inhishop, (struct monst *));
X#ifdef SOUNDS
XE boolean FDECL(tended_shop, (struct mkroom *));
X#endif
XE void FDECL(obfree, (struct obj *,struct obj *));
XE int NDECL(dopay);
XE void FDECL(home_shk, (struct monst *));
XE void FDECL(make_happy_shk, (struct monst *));
XE boolean NDECL(paybill);
XE void FDECL(pay_for_door, (int,int,const char *));
XE void FDECL(addtobill, (struct obj *,BOOLEAN_P));
XE void FDECL(splitbill, (struct obj *,struct obj *));
XE void FDECL(subfrombill, (struct obj *));
XE void FDECL(sellobj, (struct obj *));
XE int FDECL(doinvbill, (int));
XE int FDECL(shkcatch, (struct obj *));
XE int FDECL(shk_move, (struct monst *));
XE int FDECL(online, (XCHAR_P,XCHAR_P));
XE boolean FDECL(is_fshk, (struct monst *));
XE void FDECL(shopdig, (int));
XE boolean FDECL(in_shop, (int,int));
XE boolean FDECL(costly_spot, (int,int));
XE void FDECL(check_unpaid, (struct obj *));
XE boolean FDECL(block_door, (int,int));
XE boolean FDECL(block_entry, (int,int));
X
X/* ### shknam.c ### */
X
XE void FDECL(stock_room, (const struct shclass *,struct mkroom *));
XE int FDECL(saleable, (int,struct obj *));
XE int FDECL(get_shop_item, (int));
X
X/* ### sit.c ### */
X
X#if defined(THRONES) || defined(SPELLS)
XE void NDECL(take_gold);
X#endif
XE int NDECL(dosit);
XE void NDECL(rndcurse);
XE void NDECL(attrcurse);
X
X/* ### sounds.c ### */
X
XE void FDECL(verbalize, (const char *));
X#ifdef SOUNDS
XE void NDECL(dosounds);
XE void FDECL(growl, (struct monst *));
XE void FDECL(yelp, (struct monst *));
XE void FDECL(whimper, (struct monst *));
X#endif
XE struct monst *FDECL(qname, (struct monst *));
XE int NDECL(dotalk);
X
X/* ### sp_lev.c ### */
X
X#ifdef STRONGHOLD
XE boolean FDECL(load_special, (const char *));
X#endif /* STRONGHOLD /**/
X
X/* ### spell.c ### */
X#ifdef SPELLS
X#ifdef OVERLAY
XE int NDECL(learn);
X#endif
XE int FDECL(study_book, (struct obj *));
XE int NDECL(docast);
XE int FDECL(spelleffects, (int, BOOLEAN_P));
XE void NDECL(losespells);
XE int NDECL(dovspell);
X#endif /* SPELLS */
X
X/* ### steal.c ### */
X
X#ifdef OVERLAY
XE int NDECL(stealarm);
X#endif
XE long NDECL(somegold);
XE void FDECL(stealgold, (struct monst *));
XE int FDECL(steal, (struct monst *));
XE void FDECL(mpickobj, (struct monst *,struct obj *));
XE void FDECL(stealamulet, (struct monst *));
XE void FDECL(relobj, (struct monst *,int));
X
X/* ### termcap.c ### */
X
XE void NDECL(startup);
XE void NDECL(start_screen);
XE void NDECL(end_screen);
X#ifdef CLIPPING
XE boolean FDECL(win_curs, (int,int));
X#endif
XE void FDECL(curs, (int,int));
XE void FDECL(cmov, (int,int));
XE void FDECL(xputc, (CHAR_P));
XE void FDECL(xputs, (const char *));
XE void NDECL(cl_end);
XE void NDECL(clear_screen);
XE void NDECL(home);
XE void NDECL(standoutbeg);
XE void NDECL(standoutend);
XE void NDECL(revbeg);
X#if 0
XE void NDECL(boldbeg);
XE void NDECL(blinkbeg);
XE void NDECL(dimbeg);
X#endif
XE void NDECL(m_end);
XE void NDECL(backsp);
XE void NDECL(bell);
XE void NDECL(graph_on);
XE void NDECL(graph_off);
XE void NDECL(delay_output);
XE void NDECL(cl_eos);
X
X/* ### timeout.c ### */
X
XE void NDECL(timeout);
XE void NDECL(hatch_eggs);
X
X/* ### topl.c ### */
X
XE int NDECL(doredotopl);
XE void NDECL(remember_topl);
XE void FDECL(addtopl, (const char *));
XE void NDECL(more);
XE void FDECL(cmore, (const char *));
XE void NDECL(clrlin);
X#ifdef NEED_VARARGS
X# if defined(USE_STDARG) || defined(USE_VARARGS)
XE void FDECL(vpline, (const char *, va_list));
X# endif
X#endif
XE void VDECL(pline, (const char *,...));
XE void VDECL(Norep, (const char *,...));
XE void VDECL(You, (const char *,...));
XE void VDECL(Your, (const char *,...));
XE void VDECL(kludge, (const char *,const char *,...));
XE void FDECL(putsym, (CHAR_P));
XE void FDECL(putstr, (const char *));
XE char FDECL(yn_function, (const char *,CHAR_P));
XE void VDECL(impossible, (const char *,...));
X
X/* ### topten.c ### */
X
XE void FDECL(topten, (int));
XE void FDECL(prscore, (int,char **));
XE struct obj *FDECL(tt_oname, (struct obj *));
X
X/* ### track.c ### */
X
XE void NDECL(initrack);
XE void NDECL(settrack);
XE coord *FDECL(gettrack, (int,int));
X
X/* ### trap.c ### */
X
XE boolean FDECL(rust_dmg, (struct obj *,const char *,int,BOOLEAN_P));
XE struct trap *FDECL(maketrap, (int,int,int));
XE int FDECL(teleok, (int,int));
XE void FDECL(fall_through, (BOOLEAN_P));
XE void FDECL(dotrap, (struct trap *));
XE int FDECL(mintrap, (struct monst *));
XE void FDECL(selftouch, (const char *));
XE void NDECL(float_up);
XE int NDECL(float_down);
XE void NDECL(tele);
XE void FDECL(teleds, (int,int));
XE int NDECL(dotele);
XE void FDECL(placebc, (int));
XE void NDECL(unplacebc);
XE void NDECL(level_tele);
XE void NDECL(drown);
X#ifdef SPELLS
XE void FDECL(drain_en, (int));
X#endif
XE int NDECL(dountrap);
XE boolean FDECL(chest_trap, (struct obj *,int));
XE void NDECL(wake_nearby);
XE void FDECL(deltrap, (struct trap *));
XE struct trap *FDECL(t_at, (int,int));
XE void FDECL(b_trapped, (const char *));
XE boolean NDECL(unconscious);
X
X/* ### u_init.c ### */
X
XE void NDECL(u_init);
XE void NDECL(plnamesuffix);
X
X/* ### uhitm.c ### */
X
XE struct monst *FDECL(clone_mon, (struct monst *));
XE boolean FDECL(special_case, (struct monst *));
XE schar FDECL(find_roll_to_hit, (struct monst *));
XE boolean FDECL(attack, (struct monst *));
XE boolean FDECL(hmon, (struct monst *,struct obj *,int));
X#ifdef POLYSELF
XE int FDECL(damageum, (struct monst *, struct attack *));
XE void FDECL(missum, (struct monst *, struct attack *));
X#endif
XE int FDECL(passive, (struct monst *,BOOLEAN_P,int,BOOLEAN_P));
XE void FDECL(stumble_onto_mimic, (struct monst *));
X
X/* ### unixmain.c ### */
X
X#ifdef UNIX
XE void FDECL(glo, (int));
XE void NDECL(askname);
X#endif /* UNIX */
X
X/* ### unixtty.c ### */
X
X#ifdef UNIX
XE void NDECL(gettty);
XE void FDECL(settty, (const char *));
XE void NDECL(setftty);
XE void NDECL(intron);
XE void NDECL(introff);
XE void VDECL(error, (const char *,...));
X#endif /* UNIX */
X
X/* ### unixunix.c ### */
X
X#ifdef UNIX
XE void NDECL(setrandom);
XE int NDECL(getyear);
XE char *NDECL(getdate);
XE int NDECL(phase_of_the_moon);
XE int NDECL(night);
XE int NDECL(midnight);
XE void FDECL(gethdate, (char *));
XE int FDECL(uptodate, (int));
XE void NDECL(getlock);
XE void FDECL(regularize, (char *));
X#endif /* UNIX */
X
X/* ### vault.c ### */
X
XE boolean FDECL(grddead, (struct monst *));
XE void NDECL(invault);
XE int FDECL(gd_move, (struct monst *));
XE void NDECL(paygd);
X#ifdef SOUNDS
XE boolean NDECL(gd_sound);
X#endif
X
X/* ### version.c ### */
X
XE int NDECL(doversion);
XE int NDECL(doextversion);
X#ifdef MSDOS
XE int FDECL(comp_times,(long));
X#endif
X
X/* ### vmsmain.c ### */
X
X#ifdef VMS
X# ifdef CHDIR
XE void FDECL(chdirx, (char *,BOOLEAN_P));
X# endif /* CHDIR */
XE void FDECL(glo, (int));
XE void NDECL(askname);
X#endif /* VMS */
X
X/* ### vmsmisc.c ### */
X
X#ifdef VMS
XE void NDECL(vms_abort);
XE void FDECL(vms_exit, (int));
X#endif /* VMS */
X
X/* ### vmstty.c ### */
X
X#ifdef VMS
XE void NDECL(gettty);
XE void FDECL(settty, (char *));
XE void NDECL(setftty);
XE void NDECL(intron);
XE void NDECL(introff);
XE void VDECL(error, (char *,...));
X#endif /* VMS */
X
X/* ### vmsunix.c ### */
X
X#ifdef VMS
XE void NDECL(setrandom);
XE int NDECL(getyear);
XE char *NDECL(getdate);
XE int NDECL(phase_of_the_moon);
XE int NDECL(night);
XE int NDECL(midnight);
XE void FDECL(gethdate, (char *));
XE int FDECL(uptodate, (int));
XE void NDECL(getlock);
XE void FDECL(regularize, (char *));
XE int FDECL(vms_creat, (char *,unsigned int));
XE int NDECL(vms_getuid);
XE void NDECL(privoff);
XE void NDECL(privon);
X# ifdef SHELL
XE int NDECL(dosh);
X# endif
X#endif /* VMS */
X
X/* ### weapon.c ### */
X
XE int FDECL(hitval, (struct obj *,struct permonst *));
XE int FDECL(dmgval, (struct obj *,struct permonst *));
XE void NDECL(set_uasmon);
XE struct obj *FDECL(select_rwep, (struct monst *));
XE struct obj *FDECL(select_hwep, (struct monst *));
XE int NDECL(abon);
XE int NDECL(dbon);
X
X/* ### were.c ### */
X
XE void FDECL(were_change, (struct monst *));
XE void FDECL(new_were, (struct monst *));
XE boolean FDECL(were_summon, (struct permonst *,BOOLEAN_P));
X#ifdef POLYSELF
XE void NDECL(you_were);
X#endif /* POLYSELF */
X
X/* ### wield.c ### */
X
XE void FDECL(setuwep, (struct obj *));
XE void NDECL(uwepgone);
XE int NDECL(dowield);
XE void NDECL(corrode_weapon);
XE int FDECL(chwepon, (struct obj *,int));
XE int FDECL(welded, (struct obj *));
XE void FDECL(weldmsg, (struct obj *,BOOLEAN_P));
X
X/* ### wizard.c ### */
X
XE void NDECL(amulet);
XE int FDECL(mon_has_amulet, (struct monst *));
XE int FDECL(wiz_get_amulet, (struct monst *));
XE void NDECL(aggravate);
XE void NDECL(clonewiz);
X#ifdef HARD
XE void NDECL(nasty);
XE void NDECL(resurrect);
XE void NDECL(intervene);
XE void FDECL(wizdead, (struct monst *));
X#endif /* HARD */
XE void FDECL(cuss, (struct monst *));
X
X/* ### worm.c ### */
X
X#ifdef WORM
XE int FDECL(getwn, (struct monst *));
XE void FDECL(initworm, (struct monst *));
XE void FDECL(worm_move, (struct monst *));
XE void FDECL(worm_nomove, (struct monst *));
XE void FDECL(wormdead, (struct monst *));
XE void FDECL(wormhit, (struct monst *));
XE void FDECL(wormsee, (unsigned int));
XE void FDECL(cutworm, (struct monst *,XCHAR_P,XCHAR_P,unsigned));
X#endif /* WORM */
X
X/* ### worn.c ### */
X
XE void FDECL(setworn, (struct obj *,long));
XE void FDECL(setnotworn, (struct obj *));
X
X/* ### write.c ### */
X
XE void FDECL(dowrite, (struct obj *));
X
X/* ### zap.c ### */
X
X#ifdef OVERLAY
XE int FDECL(bhito, (struct obj *, struct obj *));
XE int FDECL(bhitm, (struct monst *, struct obj *));
X#endif
XE struct monst *FDECL(revive, (struct obj *,BOOLEAN_P));
XE int FDECL(zappable, (struct obj *));
XE void FDECL(zapnodir, (struct obj *));
XE int NDECL(dozap);
XE int FDECL(zapyourself, (struct obj *));
XE void FDECL(weffects, (struct obj *));
XE const char *FDECL(exclam, (int));
XE void FDECL(hit, (const char *,struct monst *,const char *));
XE void FDECL(miss, (const char *,struct monst *));
XE struct monst *FDECL(bhit, (int,int,int,CHAR_P,int FDECL((*), (struct monst *, struct obj *)),
X  int FDECL((*), (struct obj *, struct obj *)),struct obj *));
XE struct monst *FDECL(boomhit, (int,int));
XE void FDECL(buzz, (int,int,XCHAR_P,XCHAR_P,int,int));
XE void FDECL(rlocgold, (struct gold *));
XE void FDECL(rloco, (struct obj *));
XE void FDECL(fracture_rock, (struct obj *));
XE boolean FDECL(break_statue, (struct obj *));
XE void FDECL(destroy_item, (int,int));
XE int FDECL(destroy_mitem, (struct monst *,int,int));
XE int FDECL(resist, (struct monst *,CHAR_P,int,int));
XE void NDECL(makewish);
X
X#endif /* !MAKEDEFS_C && !LEV_LEX_C */
X
X#undef E
X
X#endif /* EXTERN_H /**/
END_OF_FILE
if test 42801 -ne `wc -c <'include/extern.h'`; then
    echo shar: \"'include/extern.h'\" unpacked with wrong size!
fi
# end of 'include/extern.h'
fi
if test -f 'src/mkobj.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/mkobj.c'\"
else
echo shar: Extracting \"'src/mkobj.c'\" \(14111 characters\)
sed "s/^X//" >'src/mkobj.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)mkobj.c	3.0	89/11/08
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include "hack.h"
X
XSTATIC_DCL void FDECL(mkbox_cnts,(struct obj *));
X
Xstruct icp {
X    int  iprob; /* probability of an item type */
X    char ilet;	/* item class */
X};
X
X#ifdef OVL1
X
Xconst struct icp mkobjprobs[] = {
X{10, WEAPON_SYM},
X{10, ARMOR_SYM},
X{20, FOOD_SYM},
X{ 8, TOOL_SYM},
X{ 8, GEM_SYM},
X#ifdef SPELLS
X{16, POTION_SYM},
X{16, SCROLL_SYM},
X{ 4, SPBOOK_SYM},
X#else
X{18, POTION_SYM},
X{18, SCROLL_SYM},
X#endif
X{ 4, WAND_SYM},
X{ 3, RING_SYM},
X{ 1, AMULET_SYM}};
X
Xconst struct icp boxiprobs[] = {
X{18, GEM_SYM},
X#ifdef SPELLS
X{15, FOOD_SYM},
X{20, POTION_SYM},
X{20, SCROLL_SYM},
X{15, SPBOOK_SYM},
X#else
X{20, FOOD_SYM},
X{25, POTION_SYM},
X{25, SCROLL_SYM},
X#endif
X{ 6, WAND_SYM},
X{ 5, RING_SYM},
X{ 1, AMULET_SYM}};
X
X#ifdef REINCARNATION
Xconst struct icp rogueprobs[] = {
X{12, WEAPON_SYM},
X{12, ARMOR_SYM},
X{22, FOOD_SYM},
X{22, POTION_SYM},
X{22, SCROLL_SYM},
X{ 5, WAND_SYM},
X{ 5, RING_SYM}};
X#endif
X
Xconst struct icp hellprobs[] = {
X{20, WEAPON_SYM},
X{20, ARMOR_SYM},
X{16, FOOD_SYM},
X{12, TOOL_SYM},
X{10, GEM_SYM},
X{ 1, POTION_SYM},
X{ 1, SCROLL_SYM},
X{ 8, WAND_SYM},
X{ 8, RING_SYM},
X{ 4, AMULET_SYM}};
X
Xstatic int NEARDATA mksx=0, NEARDATA mksy=0;
X
Xstruct obj *
Xmkobj_at(let,x,y, artif)
Xchar let;
Xint x,y;
Xboolean artif;
X{
X	register struct obj *otmp;
X
X	mksx = x; mksy = y;
X	/* We need to know the X, Y coordinates while creating the object,
X	 * to insure shop boxes are empty.
X	 * Yes, this is a horrible kludge...
X	 */
X	otmp = mkobj(let,artif);
X	otmp->nobj = fobj;
X	fobj = otmp;
X	place_object(otmp, x, y);
X	mksx = mksy = 0;
X	return(otmp);
X}
X
Xstruct obj *
Xmksobj_at(otyp,x,y)
Xint otyp,x,y;
X{
X	register struct obj *otmp;
X
X	mksx = x; mksy = y;
X	otmp = mksobj(otyp,TRUE);
X	otmp->nobj = fobj;
X	place_object(otmp, x, y);
X	mksx = mksy = 0;
X	return((fobj = otmp));
X}
X
Xstruct obj *
Xmkobj(let, artif)
Xchar let;
Xboolean artif;
X{
X	register int tprob, i, prob = rnd(1000);
X
X	if(let == RANDOM_SYM) {
X		const struct icp *iprobs =
X#ifdef REINCARNATION
X				    (dlevel == rogue_level) ?
X				    (const struct icp *)rogueprobs :
X#endif
X				    Inhell ? (const struct icp *)hellprobs :
X				    (const struct icp *)mkobjprobs;
X
X		for(tprob = rnd(100);
X		    (tprob -= iprobs->iprob) > 0;
X		    iprobs++);
X		let = iprobs->ilet;
X	}
X
X	i = bases[letindex(let)];
X	while((prob -= objects[i].oc_prob) > 0) i++;
X
X	if(objects[i].oc_olet != let || !objects[i].oc_name)
X		panic("probtype error, let=%c i=%d", let, i);
X
X	return(mksobj(i, artif));
X}
X
XSTATIC_OVL
Xvoid
Xmkbox_cnts(box)
X/* Note: does not check to see if it overloaded the box capacity; usually
X * possible only with corpses in ice boxes.
X */
Xstruct obj *box;
X{
X	register int n;
X	register struct obj *otmp;
X
X	if(in_shop(mksx, mksy)) return; /* boxes are empty in shops */
X
X	switch(box->otyp) {
X		case ICE_BOX: 		n = 20; break;
X		case CHEST:		n = 5; break;
X		case LARGE_BOX:		n = 3; break;
X		case SACK:
X		case BAG_OF_HOLDING:	n = 1; break;
X		default:		n = 0; break;
X	}
X
X	for(n = rn2(n+1); n > 0; n--) {
X	    if (box->otyp == ICE_BOX) {
X		otmp = mksobj(CORPSE, TRUE);
X		/* Note: setting age to 0 is correct.  Age has a different
X		 * from usual meaning for objects stored in ice boxes. -KAA
X		 */
X		otmp->age = 0;
X	    } else {
X		register int tprob;
X		const struct icp *iprobs = boxiprobs;
X
X		for(tprob = rnd(100);
X		    (tprob -= iprobs->iprob) > 0;
X		    iprobs++);
X		otmp = mkobj(iprobs->ilet, TRUE);
X	    }
X	    if (otmp) {
X		otmp->cobj = box;
X		otmp->nobj = fcobj;
X		fcobj = otmp;
X		/* inc_cwt(box, otmp); --done by weight() */
X	    }
X	}
X	return;
X}
X
Xint
Xrndmonnum() {	/* select a random, common monster type */
X
X	register struct permonst *ptr;
X	register int	i;
X
X	/* Plan A: get a level-appropriate common monster */
X	ptr = rndmonst();
X	if (ptr) return(monsndx(ptr));
X
X	/* Plan B: get any common monster */
X	do {
X	    ptr = &mons[(i = rn2(NUMMONS))];
X	} while((ptr->geno & G_NOGEN) || (!Inhell && (ptr->geno & G_HELL)));
X
X	return(i);
X}
X
X#endif /* OVL1 */
X#ifdef OVLB
Xconst char dknowns[] = { WAND_SYM, RING_SYM, POTION_SYM, SCROLL_SYM, GEM_SYM,
X#ifdef SPELLS
XSPBOOK_SYM,
X#endif
XWEAPON_SYM, 0};
X
X/*ARGSUSED*/
Xstruct obj *
Xmksobj(otyp, artif)
Xint otyp;
Xboolean artif;
X{
X	int tryct;
X	struct obj *otmp;
X	char let = objects[otyp].oc_olet;
X
X	otmp = newobj(0);
X	*otmp = zeroobj;
X	otmp->age = monstermoves;
X	otmp->o_id = flags.ident++;
X	otmp->quan = 1;
X	otmp->olet = let;
X	otmp->otyp = otyp;
X	otmp->dknown = index(dknowns, let) ? 0 : 1;
X	if (!objects[otmp->otyp].oc_uses_known)
X		otmp->known = 1;
X	switch(let) {
X	case WEAPON_SYM:
X		otmp->quan = (otmp->otyp <= SHURIKEN) ? rn1(6,6) : 1;
X		if(!rn2(11)) {
X			otmp->spe = rne(3);
X			otmp->blessed = rn2(2);
X		} else if(!rn2(10)) {
X			curse(otmp);
X			otmp->spe = -rne(3);
X		} else	blessorcurse(otmp, 10);
X
X#ifdef NAMED_ITEMS
X		if(artif && !rn2(20)) mkartifact(&otmp);
X#endif
X		break;
X	case FOOD_SYM:
X		otmp->oeaten = 0;
X		if(otmp->otyp == CORPSE) {
X		    /* overridden by mkcorpstat() */
X		    do otmp->corpsenm = rndmonnum();
X		    while (mons[otmp->corpsenm].geno & G_NOCORPSE);
X		    break;
X		} else if(otmp->otyp == EGG) {
X		    if(!rn2(3)) {		/* "live" eggs */
X			register struct permonst *ptr;
X			for(tryct = 0;
X			    (!(ptr = rndmonst()) ||
X			    (!lays_eggs(ptr) && ptr != &mons[PM_KILLER_BEE])) &&
X				tryct < 100;
X			    tryct++);
X			if(tryct < 100)	otmp->corpsenm = monsndx(ptr);
X			else		otmp->corpsenm = -1; /* empty */
X		    } else		otmp->corpsenm = -1; /* empty */
X		} else if(otmp->otyp == TIN) {
X		    if(!rn2(6)) {
X			otmp->spe = 1;		/* spinach */
X			otmp->corpsenm = -1;
X		    } else do {
X			otmp->corpsenm = rndmonnum();
X		    } while (mons[otmp->corpsenm].geno & G_NOCORPSE);
X		    blessorcurse(otmp, 10);
X		}
X#ifdef TUTTI_FRUTTI
X		else if (otmp->otyp == SLIME_MOLD)
X		    otmp->spe = current_fruit;
X#endif
X		/* fall into next case */
X	case GEM_SYM:
X		if (otmp->otyp == LOADSTONE) curse(otmp);
X		else if (otmp->otyp == ROCK) otmp->quan = rn1(6,6);
X		else if (otmp->otyp != LUCKSTONE && !rn2(6)) otmp->quan = 2;
X		else otmp->quan = 1;
X		break;
X	case TOOL_SYM:
X	    switch(otmp->otyp) {
X		case LAMP:		otmp->spe = rnd(10);
X					blessorcurse(otmp, 5);
X					break;
X		case MAGIC_LAMP:	otmp->spe = 1;
X					otmp->recharged = 0;
X					blessorcurse(otmp, 2);
X					break;
X		case KEY:		/* key # index */
X		case SKELETON_KEY:	otmp->spe = rn2(N_LOX);
X					break;
X		case CHEST:		/* lock # index */
X		case LARGE_BOX:		otmp->spe = rn2(N_LOX);
X					otmp->olocked = !!(rn2(5));
X					otmp->otrapped = !(rn2(10));
X		case ICE_BOX:
X		case SACK:
X		case BAG_OF_HOLDING:	mkbox_cnts(otmp);
X					break;
X		case MAGIC_MARKER:	otmp->spe = rn1(70,30);
X					break;
X		case CRYSTAL_BALL:	otmp->spe = rnd(5);
X					blessorcurse(otmp, 2);
X					break;
X		case BAG_OF_TRICKS:	otmp->spe = rnd(20);
X					break;
X		case FIGURINE:	{	int tryct2 = 0;
X					do
X					    otmp->corpsenm = rndmonnum();
X					while(is_human(&mons[otmp->corpsenm])
X						&& tryct2++ < 30);
X					blessorcurse(otmp, 4);
X					break;
X				}
X#ifdef MUSIC
X		case MAGIC_FLUTE:
X		case MAGIC_HARP:
X		case FROST_HORN:
X		case FIRE_HORN:
X		case DRUM_OF_EARTHQUAKE:
X					otmp->spe = rn1(5,4);
X					break;
X#endif /* MUSIC /**/
X	    }
X	    break;
X	case AMULET_SYM:
X		if(rn2(10) && (otmp->otyp == AMULET_OF_STRANGULATION ||
X		   otmp->otyp == AMULET_OF_CHANGE ||
X		   otmp->otyp == AMULET_OF_RESTFUL_SLEEP)) {
X			curse(otmp);
X		} else	blessorcurse(otmp, 10);
X	case VENOM_SYM:
X	case CHAIN_SYM:
X	case BALL_SYM:
X		break;
X	case POTION_SYM:
X	case SCROLL_SYM:
X#ifdef MAIL
X		if (otmp->otyp != SCR_MAIL)
X#endif
X			blessorcurse(otmp, 4);
X		break;
X#ifdef SPELLS
X	case SPBOOK_SYM:
X		blessorcurse(otmp, 17);
X		break;
X#endif
X	case ARMOR_SYM:
X		if(rn2(10) && (otmp->otyp == FUMBLE_BOOTS ||
X		   otmp->otyp == LEVITATION_BOOTS ||
X		   otmp->otyp == HELM_OF_OPPOSITE_ALIGNMENT ||
X		   otmp->otyp == GAUNTLETS_OF_FUMBLING ||
X		   !rn2(11))) {
X			curse(otmp);
X			otmp->spe = -rne(3);
X		} else if(!rn2(10)) {
X			otmp->spe = rne(3);
X			otmp->blessed = rn2(2);
X		} else	blessorcurse(otmp, 10);
X		if(otmp->otyp == DRAGON_SCALE_MAIL)
X			otmp->corpsenm = PM_GRAY_DRAGON +
X			    rn2(PM_YELLOW_DRAGON-PM_GRAY_DRAGON+1);
X		break;
X	case WAND_SYM:
X#ifdef HARD
X		if(otmp->otyp == WAN_WISHING) otmp->spe = rnd(3); else
X#else		
X		if(otmp->otyp == WAN_WISHING) otmp->spe = 3; else
X#endif		
X		otmp->spe = rn1(5,
X			(objects[otmp->otyp].bits & NODIR) ? 11 : 4);
X		blessorcurse(otmp, 17);
X		otmp->recharged = 0; /* used to control recharging */
X		break;
X	case RING_SYM:
X		if(objects[otmp->otyp].oc_charged) {
X		    blessorcurse(otmp, 3);
X		    if(rn2(10)) {
X			if(rn2(10) && bcsign(otmp))
X			    otmp->spe = bcsign(otmp) * rne(3);
X			else otmp->spe = rn2(2) ? rne(3) : -rne(3);
X		    }
X		    if (otmp->spe < 0 && rn2(5)) curse(otmp);
X		} else if(rn2(10) && (otmp->otyp == RIN_TELEPORTATION ||
X#ifdef POLYSELF
X			  otmp->otyp == RIN_POLYMORPH ||
X#endif
X			  otmp->otyp == RIN_AGGRAVATE_MONSTER ||
X			  otmp->otyp == RIN_HUNGER || !rn2(9))) {
X			curse(otmp);
X		}
X		break;
X	case ROCK_SYM:
X		switch (otmp->otyp) {
X		    case STATUE:
X			/* contains book? */
X			otmp->spe = (rn2(dlevel/2 + 10) > 10);
X			/* overridden by mkcorpstat() */
X			otmp->corpsenm = rndmonnum();
X		}
X		break;
X	default:
X		impossible("impossible mkobj %d, sym '%c'.", otmp->otyp, let);
X		return (struct obj *)0;
X	}
X	otmp->owt = weight(otmp);
X	return(otmp);
X}
X
Xvoid
Xbless(otmp)
Xregister struct obj *otmp;
X{
X	otmp->cursed = 0;
X	otmp->blessed = 1;
X	if (otmp->otyp == LUCKSTONE) {
X		if (stone_luck(TRUE) >= 0) u.moreluck = LUCKADD;
X		else u.moreluck = -LUCKADD;
X	}
X	return;
X}
X
Xvoid
Xcurse(otmp)
Xregister struct obj *otmp;
X{
X	otmp->blessed = 0;
X	otmp->cursed = 1;
X	if (otmp->otyp == LUCKSTONE) {
X		if (stone_luck(TRUE) >= 0) u.moreluck = LUCKADD;
X		else u.moreluck = -LUCKADD;
X	}
X	return;
X}
X
X#endif /* OVLB */
X#ifdef OVL1
Xvoid
Xblessorcurse(otmp, chance)
Xregister struct obj *otmp;
Xregister int chance;
X{
X	if(otmp->blessed || otmp->cursed) return;
X
X	if(!rn2(chance))
X	    if(!rn2(2) || Inhell) { /* in hell, don't usually bless items */
X		curse(otmp);
X	    } else {
X		bless(otmp);
X	    }
X	return;
X}
X
X#endif /* OVL1 */
X#ifdef OVLB
Xint
Xbcsign(otmp)
Xregister struct obj *otmp;
X{
X	return(!!otmp->blessed - !!otmp->cursed);
X}
X
Xint
Xletter(c)
Xint c;
X{
X	return(('@' <= c && c <= 'Z') || ('a' <= c && c <= 'z'));
X}
X
X#endif /* OVLB */
X#ifdef OVL0
X
Xint
Xweight(obj)
Xregister struct obj *obj;
X{
X	register int wt = objects[obj->otyp].oc_weight;
X
X	if (Is_container(obj)) {
X		struct obj *contents;
X		obj->owt = wt;
X		for(contents=fcobj; contents; contents=contents->nobj) {
X			if (contents->cobj == obj)
X				inc_cwt(obj, contents);
X		}
X		return obj->owt;
X	}
X	if (obj->otyp == CORPSE && obj->corpsenm > -1)
X		return obj->quan * mons[obj->corpsenm].cwt;
X	else if (obj->otyp == STATUE && obj->corpsenm > -1)
X		return obj->quan * (mons[obj->corpsenm].cwt * 3 / 2);
X	return(wt ? wt*obj->quan : (obj->quan + 1)>>1);
X}
X
X#endif /* OVL0 */
X#ifdef OVLB
X
Xvoid
Xmkgold(num,x,y)
Xlong num;
Xint x, y;
X{
X	register struct gold *gold;
X	register long amount = (num ? num : 1 + (rnd(dlevel+2) * rnd(30)));
X
X	if(levl[x][y].gmask) {
X		gold = g_at(x,y);
X		gold->amount += amount;
X	} else {
X		gold = newgold();
X		gold->ngold = fgold;
X		gold->gx = x;
X		gold->gy = y;
X		gold->amount = amount;
X		fgold = gold;
X		levl[x][y].gmask = 1;
X		/* do sth with display? */
X	}
X	return;
X}
X
X#endif /* OVLB */
X#ifdef OVL1
Xstruct obj *
Xmkcorpstat(objtype, ptr, x, y)
Xint objtype;	/* CORPSE or STATUE */
Xregister struct permonst *ptr;
Xint x, y;
X{
X	register struct obj *otmp;
X
X	if(objtype != CORPSE && objtype != STATUE)
X		impossible("making corpstat type %d", objtype);
X	otmp = mksobj_at(objtype, x, y);
X	if(otmp)  {
X		if(ptr)	otmp->corpsenm = monsndx(ptr);
X		else	otmp->corpsenm = rndmonnum();
X		otmp->owt = weight(otmp);
X	}
X	return(otmp);
X}
X
X#endif /* OVL1 */
X#ifdef OVLB
Xstruct obj *
Xmk_tt_object(objtype, x, y)
Xint objtype; /* CORPSE or STATUE */
Xregister int x, y;
X{
X	register struct obj *otmp;
X
X	if(otmp = mksobj_at(objtype,x,y)) {
X		if((otmp = tt_oname(otmp)) && objtype == STATUE)
X			/* player statues never contain books */
X			otmp->spe = 0;
X	}
X	return(otmp);
X}
X
Xstruct obj *
Xmk_named_object(objtype, ptr, x, y, nm, lth)
Xint objtype; /* CORPSE or STATUE */
Xregister struct permonst *ptr;
Xint x, y;
Xchar * nm;
Xregister int lth;
X{
X	struct obj *otmp;
X
X	otmp = mkcorpstat(objtype,ptr,x,y);
X	if (lth > 0) {
X		/* Note: oname() is safe since otmp is first in both chains */
X		otmp = oname(otmp, nm, FALSE);
X		fobj = otmp;
X		level.objects[x][y] = otmp;
X	}
X	return(otmp);
X}
X
Xboolean
Xis_flammable(otmp)
Xregister struct obj *otmp;
X{
X	int otyp = otmp->otyp;
X
X	if (otyp == DRAGON_SCALE_MAIL && otmp->corpsenm == PM_RED_DRAGON)
X		return FALSE;
X	return((objects[otyp].oc_material == WOOD ||
X			objects[otyp].oc_material == 0));
X
X}
X
X#ifdef STUPID_CPP
Xboolean
Xis_rustprone(otmp)
Xregister struct obj *otmp;
X{
X	return(objects[otmp->otyp].oc_material == METAL);
X}
X
Xboolean
Xis_corrodeable(otmp)
Xregister struct obj *otmp;
X{
X	return(objects[otmp->otyp].oc_material == COPPER);
X}
X
Xboolean
XOBJ_AT(x, y)
Xint x, y;
X{
X	return(level.objects[x][y] != (struct obj *)0);
X}
X#endif
X
X#endif /* OVLB */
X#ifdef OVL1
X
X/*
X * These routines maintain the single-linked lists headed in level.objects[][]
X * and threaded through the nexthere fields in the object-instance structure.
X */
X
Xvoid
Xplace_object(otmp, x, y)
X/* put an object on top of the pile at the given location */
Xregister struct obj *otmp;
Xint x, y;
X{
X    otmp->nexthere = level.objects[x][y];
X    level.objects[x][y] = otmp;
X
X    /* set the new object's location */
X    otmp->ox = x;
X    otmp->oy = y;
X}
X
X#endif /* OVL1 */
X#ifdef OVLB
Xvoid
Xremove_object(otmp)
Xregister struct obj *otmp;
X{
X    register struct obj *odel;
X
X    if (otmp == level.objects[otmp->ox][otmp->oy])
X	level.objects[otmp->ox][otmp->oy] = otmp->nexthere;
X    else
X	for (odel = level.objects[otmp->ox][otmp->oy];
X						    odel; odel = odel->nexthere)
X	    if (odel->nexthere == otmp)
X		odel->nexthere = otmp->nexthere;
X}
X
Xvoid move_object(otmp, x, y)
Xregister struct obj *otmp;
Xint x, y;
X{
X    remove_object(otmp);
X    place_object(otmp, x, y);
X}
X
X#endif /* OVLB */
END_OF_FILE
if test 14111 -ne `wc -c <'src/mkobj.c'`; then
    echo shar: \"'src/mkobj.c'\" unpacked with wrong size!
fi
# end of 'src/mkobj.c'
fi
echo shar: End of archive 10 \(of 56\).
cp /dev/null ark10isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 56 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
