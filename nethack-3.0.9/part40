Path: utzoo!utgpu!news-server.csri.toronto.edu!mailrus!wuarchive!zaphod.mps.ohio-state.edu!samsung!dali.cs.montana.edu!milton!uw-beaver!zephyr.ens.tek.com!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v10i085:  nethack3p9 -  display oriented dungeons & dragons (Ver. 3.0i), Part40/56
Message-ID: <5945@tekred.CNA.TEK.COM>
Date: 13 Jul 90 19:37:43 GMT
Sender: news@tekred.CNA.TEK.COM
Lines: 2376
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 10, Issue 85
Archive-name: nethack3p9/Part40
Supersedes: NetHack3: Volume 7, Issue 56-93



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 40 (of 56)."
# Contents:  Porting src/end.c src/mondata.c src/sounds.c
# Wrapped by billr@saab on Wed Jul 11 17:11:53 1990
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'Porting' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Porting'\"
else
echo shar: Extracting \"'Porting'\" \(5724 characters\)
sed "s/^X//" >'Porting' <<'END_OF_FILE'
X  NetHack Porting Guidelines		v 3.0			89-05-05
X
X
X     1.0	Introduction
X
X	This document goes through the steps required to port NetHack to a
Xnew machine.  The basic steps in porting the program are:
X
X	1.  Get the code onto your machine.  The current directory setup
X	    consists of one directory each for general and UNIX source
X	    files (src), include files (include), auxiliary files (auxil),
X	    files specific to the Amiga (amiga), and files specific to
X	    other OSs like MSDOS and TOS (other).  A full list of the
X	    files may be found in the top-level file "Files".
X
X	2.  Modify the appropriate include files to customize NetHack to
X	    your system.
X
X	3.  Add, if required, a OS specific copy of "main.c", "tty.c" and
X	    "unix.c".
X
X	4.  Possibly add a OS specific library (see "msdos.c" and "tos.c"
X	    as examples) and a OS specific "*conf.h" file (see unixconf.h,
X	    pcconf.h, tosconf.h, etc. as examples).
X
X	5.  Modify the top level makefile and the "src" makefile if required.
X	    Then run an initial compile.  You are bound to get some errors.
X	    You should be able to fix them in a fairly simple fashion.  If
X	    things seem to be getting too complex, take a step back, and
X	    possibly send me some mail.  I might be able to help.
X
X	6.  Mail all of your fixes to me in a contextual form so that I can
X	    easily integrate them into the code.
X
X	One general rule of thumb exists.  Always add code.  Don't delete
Xsomebody else's code for yours - it won't work on his machine if you do.
XAlways add your OS specific code inside #ifdef / #else / #endif constructs
Xso that it will be able to be folded back into the original code easily.
X
X
X     2.0	Include Files
X
X     2.1	config.h
X
X	The file "config.h" is a master configuration file that determines
Xthe basic features of the game, as well as many of the security options.
XIt is intended that end users configure the game by editing "config.h" and
Xan appropriate "*conf.h" file, so any #defines for individual preferences
Xshould be added to those files.  OS-specific #defines that are not intended
Xto be changed should also go in "*conf.h"; try to find the most appropriate
Xplace for other #defines.
X
X	The following sections may require modification:
X
X     -	Section 1:	OS selection.
X			You may have to put a #define for your OS here.
X			If your OS is yet another UNIX variant, put the
X			#define in unixconf.h instead.
X
X     -	Section 2:	Global parameters and filenames.
X			You will have to customize the game to the
X			setup on your system.
X
X     -	Section 3:	Type definitions.
X			These will have to be matched to your compiler.
X
X     2.2	global.h
X
X	This file defines things specific to NetHack that should not
Xrequire modification by an end user.  For a new port, you may have to add
Xautomatic inclusion of another auxiliary config file (*conf.h) which you
Xwrote for your system.
X
X     2.3	extern.h
X
X	If you create any new source modules or new functions in old modules,
Xyou must enter the names of the new external references (the functions defined
Xthere for external use) in this file.
X
X     2.4	system.h
X
X	This file contains references for all hooks into the OS (via the
Xstandard "C" libraries).  Depending on what your standard library looks like,
Xyou may have to put new entries into this file.
X
X
X     3.0	Source files
X
X	The first step in getting the game up is to get the "makedefs"
Xprogram running.  This program is used to create the appropriate configuration
Xspecific files for the game.
X
X	Once "makedefs" has been built, the rest of the game can be compiled.
XYou will probably have to create an OS specific module to handle things you
Xwant to use, like a mouse or a ram-disk.
X
X	Please note that the dependancies in the "src" makefile for the
X"makedefs" program are deliberately wrong.  Don't try to fix them, you'll
Xjust create a dependancy loop as "makedefs" is considered to be dependant
Xon some of the header files it creates when "make" searches back through
Xother header files it includes.
X
X     3.1	Makefile
X
X	This distribution provides makefiles for several kinds of systems.
XThere are joint makefiles for the various varieties of UNIX, makefiles for
XMSDOS, and a makefile for Amigas.  You may have to create a new makefile for
Xyour specific machine.  If possible, however, add to one of those provided.
X
X     3.2	termcap.c
X
X	If your system doesn't run off of a termcaps or terminfo database, you
Xwill have to put the appropriate terminal control strings into termcap.c.  This
Xhas already been done for DOS, and these mods can be used as an example.
X
X     3.3	main.c
X
X	You may need to create a new "main.c" module.  If you do, call it
X[OS]main.c where the [OS] is replaced with the name of the OS you are porting
Xto.  This file contains the mainline module, which reads options from the
Xcommand line and processes them.  It also contains the master game turn loop
Xand various functions associated with game startup.
X
X     3.4	tty.c
X
X	You may need to create a new "tty.c" module.  If you do, call it
X[OS]tty.c where the [OS] is replaced with the name of the OS you are porting
Xto.  This file contains the terminal/console interface routines, and is used
Xfor raw io, etc.  If your system isn't Unix, you will most certainly have to
Xre-write it.
X
X     3.5	unix.c
X
X	You may need to create a new "unix.c" module.  If you do, call it
X[OS]unix.c where the [OS] is replaced with the name of the OS you are porting
Xto.  This file contains some OS dependancies concerning time and filename
Xcreation.
X
X
X	The object of the NetHack development project is to get the game
Xworking on as many different types of hardware and under as many different
Xoperating systems as is practical.  Any assistance will be appreciated.
X
X						Mike Stephenson
END_OF_FILE
if test 5724 -ne `wc -c <'Porting'`; then
    echo shar: \"'Porting'\" unpacked with wrong size!
fi
# end of 'Porting'
fi
if test -f 'src/end.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/end.c'\"
else
echo shar: Extracting \"'src/end.c'\" \(16435 characters\)
sed "s/^X//" >'src/end.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)end.c	3.0	88/05/03
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#define MONATTK_H	/* comment line for pre-compiled headers */
X#define NEED_VARARGS	/* comment line for pre-compiled headers */
X/* block some unused #defines to avoid overloading some cpp's */
X
X#include "hack.h"
X#ifndef NO_SIGNAL
X#include <signal.h>
X#endif
X
X#include "eshk.h"
X
Xvoid NDECL(end_box_display);
XSTATIC_PTR int NDECL(done_intr);
Xstatic void FDECL(disclose,(int,BOOLEAN_P));
X
Xstatic const char NEARDATA *deaths[] = {		/* the array of death */
X	"died", "choked", "poisoned", "starvation", "drowning",
X	"burning", "crushed", "turned to stone", "genocided",
X	"panic", "trickery",
X	"quit", "escaped", "ascended" };
X
Xstatic const char NEARDATA *ends[] = {		/* "when you..." */
X	"died", "choked", "were poisoned", "starved", "drowned",
X	"burned", "were crushed", "turned to stone", "were genocided",
X	"panicked", "were tricked",
X	"quit", "escaped", "ascended" };
X
Xint
Xdone1()
X{
X#ifndef NO_SIGNAL
X	(void) signal(SIGINT,SIG_IGN);
X#endif
X	if(flags.ignintr) {
X#ifndef NO_SIGNAL
X		(void) signal(SIGINT, (SIG_RET_TYPE) done1);
X#endif
X		clrlin();
X		curs_on_u();
X		(void) fflush(stdout);
X		if(multi > 0) nomul(0);
X		return 0;
X	}
X	return done2();
X}
X
Xint
Xdone2()
X{
X#ifdef MACOS
X	if(!flags.silent) SysBeep(1);
X	if(UseMacAlert(128) != 1) {
X#else
X	pline("Really quit? ");
X	if(yn() == 'n') {
X#endif
X#ifndef NO_SIGNAL
X		(void) signal(SIGINT, (SIG_RET_TYPE) done1);
X#endif
X		clrlin();
X		curs_on_u();
X		(void) fflush(stdout);
X		if(multi > 0) nomul(0);
X		multi = 0;
X		return 0;
X	}
X#if defined(WIZARD) && (defined(UNIX) || defined(VMS) || defined(LATTICE))
X	if(wizard) {
X# ifdef VMS
X	    pline("Enter debugger? ");
X# else
X#  ifdef LATTICE
X	    pline("Create SnapShot? ");
X#  else
X	    pline("Dump core? ");
X#  endif
X# endif
X/* KL - do I need to change the next 3 lines? */
X	    if(yn() == 'y') {
X		(void) signal(SIGINT, (SIG_RET_TYPE) done1);
X		settty(NULL);
X#ifdef AMIGA
X		Abort(0);
X#else
X# ifdef SYSV
X		(void)
X# endif
X		    abort();
X#endif
X	    }
X	}
X#endif
X#ifndef LINT
X	done(QUIT);
X#endif
X	return 0;
X}
X
XSTATIC_PTR
Xint
Xdone_intr(){
X	done_stopprint++;
X#ifndef NO_SIGNAL
X	(void) signal(SIGINT, SIG_IGN);
X# if defined(UNIX) || defined(VMS)
X	(void) signal(SIGQUIT, SIG_IGN);
X# endif
X#endif /* NO_SIGNAL /* */
X	return 0;
X}
X
X#if defined(UNIX) || defined(VMS)
Xstatic
Xint
Xdone_hangup(){
X	done_hup++;
X	(void)signal(SIGHUP, SIG_IGN);
X	(void)done_intr();
X	return 0;
X}
X#endif
X
Xvoid
Xdone_in_by(mtmp)
Xregister struct monst *mtmp;
X{
X	char buf[BUFSZ];
X
X	You("die...");
X	buf[0] = '\0';
X	if (mtmp->iswiz) {
X		Strcat(buf, "the ");
X		killer_format = KILLED_BY;
X	}
X	if (mtmp->minvis)
X		Strcat(buf, "invisible ");
X	if (Hallucination)
X		Strcat(buf, "hallucinogen-distorted ");
X
X	if(mtmp->data->mlet == S_GHOST) {
X		register char *gn = (char *) mtmp->mextra;
X		if (!Hallucination && !mtmp->minvis && *gn) {
X			Strcat(buf, "the ");
X			killer_format = KILLED_BY;
X		}
X		Sprintf(eos(buf), (*gn ? "ghost of %s" : "ghost%s"), gn);
X	} else if(mtmp->isshk) {
X		Sprintf(eos(buf), "%s %s, the shopkeeper",
X			(ESHK(mtmp)->ismale ? "Mr." : "Ms."), shkname(mtmp));
X		killer_format = KILLED_BY;
X	} else Strcat(buf, mtmp->data->mname);
X	if (mtmp->mnamelth) Sprintf(eos(buf), " called %s", NAME(mtmp));
X	killer = buf;
X	if (mtmp->data->mlet == S_WRAITH)
X		u.ugrave_arise = PM_WRAITH;
X	else if (mtmp->data->mlet == S_MUMMY)
X		u.ugrave_arise = (pl_character[0]=='E') ?
X						PM_ELF_MUMMY : PM_HUMAN_MUMMY;
X	else if (mtmp->data->mlet == S_VAMPIRE)
X		u.ugrave_arise = PM_VAMPIRE;
X	if (u.ugrave_arise > -1 && (mons[u.ugrave_arise].geno & G_GENOD))
X		u.ugrave_arise = -1;
X	if (mtmp->data->mlet == S_COCKATRICE)
X		done(STONING);
X	else
X		done(DIED);
X	return;
X}
X
X/*VARARGS1*/
Xboolean panicking;
Xextern boolean hu;	/* from save.c */
X
Xvoid
Xpanic VA_DECL(const char *, str)
X	VA_START(str);
X	VA_INIT(str, char *);
X
X	if(panicking++)
X#ifdef AMIGA
X	    Abort(0);
X#else
X# ifdef SYSV
X	    (void)
X# endif
X		abort();    /* avoid loops - this should never happen*/
X				    /* was exit(1) */
X#endif
X	home(); cls();
X	(void) puts(" Suddenly, the dungeon collapses.");
X#if defined(WIZARD) && !defined(MSDOS)
X	if(!wizard) {
X	    pline("Report error to %s and it may be possible to rebuild.",
X# ifdef WIZARD_NAME	/*(KR1ED)*/
X		WIZARD_NAME);
X# else
X		WIZARD);
X# endif
X	    more();
X	}
X#ifdef VMS
X	{
X		char *sem = rindex(SAVEF, ';');
X
X		if (sem)
X			*sem = '\0';
X	}
X	Strcat(SAVEF, ".e;1");
X#else
X	Strcat(SAVEF, ".e");
X#endif
X	hu = FALSE;
X	(void) dosave0();
X#endif
X#ifdef MACOS
X	puts(" ERROR:  ");
X#else
X	(void) fputs(" ERROR:  ", stdout);
X#endif
X#ifdef LATTICE
X	{
X	char pbuf[100];
X	vsprintf(pbuf,str,VA_ARGS);
X	(void)puts(pbuf);
X	}
X#else
X	Vprintf(str,VA_ARGS);
X#endif
X	more();				/* contains a fflush() */
X#if defined(WIZARD) && (defined(UNIX) || defined(VMS) || defined(LATTICE))
X	if (wizard)
X# ifdef AMIGA
X		Abort(0);
X# else
X#  ifdef SYSV
X		(void)
X#  endif
X		    abort();	/* generate core dump */
X# endif
X#endif
X	VA_END();
X	done(PANICKED);
X}
X
Xstatic void
Xdisclose(how,taken)
Xint how;
Xboolean taken;
X{
X#ifdef MACOS
X	int see_c;
X	char mac_buf[80];
X#endif
X	char	c;
X
X	if(invent) {
X#ifndef MACOS
X	    if(taken)
X		pline("Do you want to see what you had when you %s? ",
X			(how == QUIT) ? "quit" : "died");
X	    else
X		pline("Do you want your possessions identified? ");
X	    if ((c = yn_function(ynqchars,'y')) == 'y') {
X#else
X		{
X			extern short macflags;
X		
X			/* stop user from using menus, etc. */
X			macflags &= ~(fDoNonKeyEvt | fDoUpdate);
X		}
X	    if(taken)
X		Sprintf(mac_buf, "Do you want to see what you had when you %s? ",
X			(how == QUIT) ? "quit" : "died");
X	    else
X		Sprintf(mac_buf, "Do you want your possessions identified? ");
X		if(!flags.silent) SysBeep(1);
X	    if ((c = "qqynq"[UseMacAlertText(129,mac_buf)+1]) == 'y') {
X#endif
X	    /* New dump format by maartenj@cs.vu.nl */
X		struct obj *obj;
X
X		for(obj = invent; obj && !done_stopprint; obj = obj->nobj) {
X		    makeknown(obj->otyp);
X		    obj->known = obj->bknown = obj->dknown = 1;
X		}
X		doinv(NULL);
X		end_box_display();
X	    }
X	    if (c == 'q')  done_stopprint++;
X	    if (taken) {
X		/* paybill has already given the inventory locations 
X		 * in the shop and put it on the main object list
X		 */
X		struct obj *obj;
X
X		for(obj = invent; obj; obj = obj->nobj) {
X		    obj->owornmask = 0;
X		    if(rn2(5)) curse(obj);
X		}
X	        invent = (struct obj *) 0;
X	    }
X	}
X
X	if (!done_stopprint) {
X#ifdef MACOS
X		c = "qqynq"[UseMacAlertText(129, "Do you want to see your instrinsics ?")+1];
X#else
X	    pline("Do you want to see your intrinsics? ");
X	    c = yn_function(ynqchars, 'y');
X#endif
X	    if (c == 'y') enlightenment();
X	    if (c == 'q') done_stopprint++;
X	}
X
X}
X
X/* Be careful not to call panic from here! */
Xvoid
Xdone(how)
Xint how;
X{
X	struct permonst *upmon;
X	boolean taken;
X	char kilbuf[BUFSZ], buf2[BUFSZ];
X	/* kilbuf: used to copy killer in case it comes from something like
X	 *	xname(), which would otherwise get overwritten when we call
X	 *	xname() when listing possessions
X	 * buf2: same as player name, except it is capitalized
X	 */
X#ifdef ENDGAME
X	if (how == ASCENDED)
X		killer_format = NO_KILLER_PREFIX;
X#endif
X	/* Avoid killed by "a" burning or "a" starvation */
X	if (!killer && (how == STARVING || how == BURNING))
X		killer_format = KILLED_BY;
X	Strcpy(kilbuf, (!killer || how >= PANICKED ? deaths[how] : killer));
X	killer = kilbuf;
X#ifdef WIZARD
X	if (wizard && how == TRICKED) {
X		You("are a very tricky wizard, it seems.");
X		return;
X	}
X#endif
X	if(Lifesaved && how <= GENOCIDED) {
X		u.uswldtim = 0;
X		if(u.uhpmax < 0) u.uhpmax = 10;	/* arbitrary */
X		u.uhp = u.uhpmax;
X		adjattrib(A_CON, -1, TRUE);
X		pline("But wait...");
X		makeknown(AMULET_OF_LIFE_SAVING);
X		Your("medallion %s!",
X		      !Blind ? "begins to glow" : "feels warm");
X		You("feel much better!");
X		pline("The medallion crumbles to dust!");
X		useup(uamul);
X		if (u.uhunger < 500) u.uhunger = 500;
X		nomovemsg = "You survived that attempt on your life.";
X		curs_on_u();
X		flags.move = 0;
X		if(multi > 0) multi = 0; else multi = -1;
X		flags.botl = 1;
X		u.ugrave_arise = -1;
X		if (how == GENOCIDED)
X			pline("Unfortunately you are still genocided...");
X		else {
X			killer = 0;
X			return;
X		}
X	}
X#if defined(WIZARD) || defined(EXPLORE_MODE)
X	if((wizard || discover) && how <= GENOCIDED) {
X		pline("Die? ");
X		if(yn() == 'y') goto die;
X		u.uswldtim = 0;
X		if(u.uhpmax < 0) u.uhpmax = 100;	/* arbitrary */
X		u.uhp = u.uhpmax;
X		if (u.uhunger < 500) u.uhunger = 500;
X		pline("Ok, so you don't die.");
X		nomovemsg = "You survived that attempt on your life.";
X		curs_on_u();
X		flags.move = 0;
X		if(multi > 0) multi = 0; else multi = -1;
X		flags.botl = 1;
X		u.ugrave_arise = -1;
X		killer = 0;
X		return;
X	}
X#endif /* WIZARD || EXPLORE_MODE */
Xdie:
X#ifndef NO_SIGNAL
X	(void) signal(SIGINT, (SIG_RET_TYPE) done_intr);
X# if defined(UNIX) || defined(VMS)
X	(void) signal(SIGQUIT, (SIG_RET_TYPE) done_intr);
X	(void) signal(SIGHUP, (SIG_RET_TYPE) done_hangup);
X# endif
X#endif /* NO_SIGNAL /* */
X	upmon = player_mon();
X	if(u.ugrave_arise > -1) /* create no corpse */ ;
X	else if(how == STONED)
X		(mk_named_object(STATUE, upmon, u.ux, u.uy, plname,
X					strlen(plname)))->spe = 0;
X/*
X * If you're burned to a crisp, why leave a corpse?
X */
X	else if (how != BURNING)
X		(void) mk_named_object(CORPSE, upmon, u.ux, u.uy, plname,
X							strlen(plname));
X
X	if (how == QUIT) {
X		killer_format = NO_KILLER_PREFIX;
X		if (u.uhp < 1) {
X			how = DIED;
X/* note that killer is pointing at kilbuf */
X			Strcpy(kilbuf, "quit while already on Charon's boat");
X		}
X	}
X	if (how == ESCAPED || how == PANICKED)
X		killer_format = NO_KILLER_PREFIX;
X
X	/* paybill() must be called unconditionally, or strange things will
X	 * happen to bones levels */
X	taken = paybill();
X	paygd();
X	clearlocks();
X	if(flags.toplin == 1) more();
X
X	disclose(how,taken);
X
X	if(how < GENOCIDED) {
X#ifdef WIZARD
X	    if(wizard) {
X#ifdef MACOS
X		if(!flags.silent) SysBeep(20);
X		if(UseMacAlertText(128, "Save bones ?") == 1) savebones();
X#else
X		pline("Save bones? ");
X		if(yn() == 'y') savebones();
X#endif
X	    }  else
X#endif
X		if (how != PANICKED && how !=TRICKED)
X			savebones();
X	    if(!flags.notombstone) outrip();
X	}
X
X/* changing kilbuf really changes killer. we do it this way because
X   killer is declared a (const char *)
X*/
X	if(u.uhave_amulet) Strcat(kilbuf, " (with the Amulet)");
X	settty(NULL);	/* does a clear_screen() */
X	Strcpy(buf2, plname);
X	if('a' <= buf2[0] && buf2[0] <= 'z') buf2[0] += 'A'-'a';
X	if(!done_stopprint)
X	    Printf("Goodbye %s the %s...\n\n", buf2,
X#ifdef ENDGAME
X		   how != ASCENDED ? (const char *)pl_character :
X		   flags.female ? (const char *)"Demigoddess" : 
X			(const char *)"Demigod");
X#else
X		   pl_character);
X#endif
X	{ long int tmp;
X	  tmp = u.ugold - u.ugold0;
X	  if(tmp < 0)
X		tmp = 0;
X	  if(how < PANICKED)
X		tmp -= tmp/10;
X	  u.urexp += tmp;
X	  u.urexp += 50 * maxdlevel;
X	  if(maxdlevel > 20)
X		u.urexp += 1000*((maxdlevel > 30) ? 10 : maxdlevel - 20);
X#ifdef ENDGAME
X	  if(how == ASCENDED) u.urexp *= 2;
X#endif
X	}
X	if(how == ESCAPED
X#ifdef ENDGAME
X			|| how == ASCENDED
X#endif
X					) {
X		register struct monst *mtmp;
X		register struct obj *otmp, *otmp2, *prevobj;
X		struct obj *jewels = (struct obj *)0;
X		long i;
X		register unsigned int worthlessct = 0;
X#if defined(LINT) || defined(__GNULINT__)
X		prevobj = (struct obj *)0;
X#endif
X
X		/* put items that count into jewels chain
X		 * rewriting the fcobj and invent chains here is safe,
X		 * as they'll never be used again
X		 */
X		for(otmp = fcobj; otmp; otmp = otmp2) {
X			otmp2 = otmp->nobj;
X			if(carried(otmp->cobj)
X					&& ((otmp->olet == GEM_SYM &&
X					     otmp->otyp < LUCKSTONE)
X					    || otmp->olet == AMULET_SYM)) {
X				if(otmp == fcobj)
X					fcobj = otmp->nobj;
X				else
X					prevobj->nobj = otmp->nobj;
X				otmp->nobj = jewels;
X				jewels = otmp;
X			} else
X				prevobj = otmp;
X		}
X		for(otmp = invent; otmp; otmp = otmp2) {
X			otmp2 = otmp->nobj;
X			if((otmp->olet == GEM_SYM && otmp->otyp < LUCKSTONE)
X					    || otmp->olet == AMULET_SYM) {
X				if(otmp == invent)
X					invent = otmp->nobj;
X				else
X					prevobj->nobj = otmp->nobj;
X				otmp->nobj = jewels;
X				jewels = otmp;
X			} else
X				prevobj = otmp;
X		}
X
X		/* add points for jewels */
X		for(otmp = jewels; otmp; otmp = otmp->nobj) {
X			if(otmp->olet == GEM_SYM)
X				u.urexp += (long) otmp->quan *
X					    objects[otmp->otyp].g_val;
X			else 	/* amulet */
X				u.urexp += (otmp->spe < 0) ? 2 :
X					otmp->otyp == AMULET_OF_YENDOR ?
X							5000 : 500;
X		}
X
X		keepdogs();
X		mtmp = mydogs;
X		if(mtmp) {
X			if(!done_stopprint) Printf("You");
X			while(mtmp) {
X				if(!done_stopprint)
X					Printf(" and %s", mon_nam(mtmp));
X				if(mtmp->mtame)
X					u.urexp += mtmp->mhp;
X				mtmp = mtmp->nmon;
X			}
X			if(!done_stopprint)
X#ifdef ENDGAME
X		    Printf("\n%s with %ld points,\n",
X			how==ASCENDED ? "went to your reward"
X				: "escaped from the dungeon",
X#else
X		    Printf("\nescaped from the dungeon with %ld points,\n",
X#endif
X			u.urexp);
X		} else
X		if(!done_stopprint)
X#ifdef ENDGAME
X		  Printf("You %s with %ld points,\n",
X			how==ASCENDED ? "went to your reward"
X				: "escaped from the dungeon",
X#else
X		  Printf("You escaped from the dungeon with %ld points,\n",
X#endif
X		    u.urexp);
X
X		/* print jewels chain here */
X		for(otmp = jewels; otmp; otmp = otmp->nobj) {
X			makeknown(otmp->otyp);
X			if(otmp->olet == GEM_SYM && otmp->otyp < LUCKSTONE) {
X				i = (long) otmp->quan *
X					objects[otmp->otyp].g_val;
X				if(i == 0) {
X					worthlessct += otmp->quan;
X					continue;
X				}
X				Printf("        %s (worth %ld zorkmids),\n",
X				    doname(otmp), i);
X			} else {		/* amulet */
X				otmp->known = 1;
X				i = (otmp->spe < 0) ? 2 :
X					otmp->otyp == AMULET_OF_YENDOR ?
X							5000 : 500;
X				Printf("        %s (worth %ld zorkmids),\n",
X				    doname(otmp), i);
X			}
X		}
X		if(worthlessct)
X		  Printf("        %u worthless piece%s of colored glass,\n",
X			worthlessct, plur((long)worthlessct));
X	} else
X		if(!done_stopprint) {
X		    Printf("You %s ", ends[how]);
X#ifdef ENDGAME
X		    if (how != ASCENDED) {
X			if(dlevel == ENDLEVEL)
X			     Printf("in the endgame ");
X			else Printf("on dungeon level %d ", dlevel);
X		    }
X#else
X		    Printf("on dungeon level %d ", dlevel);
X#endif
X		    Printf("with %ld points,\n", u.urexp);
X		}
X	if(!done_stopprint)
X	  Printf("and %ld piece%s of gold, after %ld move%s.\n",
X	    u.ugold, plur(u.ugold), moves, plur(moves));
X	if(!done_stopprint)
X  Printf("You were level %u with a maximum of %d hit points when you %s.\n",
X	    u.ulevel, u.uhpmax, ends[how]);
X#if (defined(WIZARD) || defined(EXPLORE_MODE))
X# ifndef LOGFILE
X	if(wizard || discover)
X		Printf("\nSince you were in %s mode, the score list \
Xwill not be checked.\n", wizard ? "wizard" : "discover");
X	else
X# endif
X#endif
X	{
X		if (!done_stopprint) {
X			getret();
X			cls();
X		}
X/* "So when I die, the first thing I will see in Heaven is a score list?" */
X		topten(how);
X	}
X	if(done_stopprint) Printf("\n\n");
X#if defined(APOLLO) || defined(MACOS)
X	getret();
X#endif
X	exit(0);
X}
X
Xvoid
Xclearlocks(){
X#if defined(DGK)
X	eraseall(levels, alllevels);
X	if (ramdisk)
X		eraseall(permbones, alllevels);
X#else
X# if defined(UNIX) || defined(MSDOS) || defined(VMS) || defined(MACOS)
X	register int x;
X#  if defined(UNIX) || defined(VMS)
X	(void) signal(SIGHUP,SIG_IGN);
X#  endif
X#  ifdef MACOS
X	Str255 fileName;
X	int oldVolume;
X	struct term_info *t;
X	extern WindowPtr HackWindow;
X
X	t = (term_info *)GetWRefCon(HackWindow);
X	(void)GetVol(&fileName, &oldVolume);
X	(void)SetVol(0L, t->system.sysVRefNum);
X#  endif
X	for(x = maxdlevel; x >= 0; x--) {
X		glo(x);
X		(void) unlink(lock);	/* not all levels need be present */
X	}
X#  ifdef MACOS
X	(void)SetVol(0L, oldVolume);
X#  endif
X# endif
X#endif
X}
X
X#ifdef NOSAVEONHANGUP
Xint
Xhangup()
X{
X	(void) signal(SIGINT, SIG_IGN);
X	clearlocks();
X# ifndef VMS
X	exit(1);
X# endif
X}
X#endif
X
Xvoid
Xend_box_display()
X{
X	register struct obj *box, *obj;
X	char buf[BUFSZ];
X
X	for(box=invent; box; box=box->nobj) {
X	    if (Is_container(box) && box->otyp != BAG_OF_TRICKS) {
X		int cnt=0;
X
X		for(obj=fcobj; obj; obj=obj->nobj) {
X		    if (obj->cobj == box) {
X			if (!cnt) {
X			    Sprintf(buf, "Contents of the %s:",xname(box));
X			    cornline(0, buf);
X			}
X			makeknown(obj->otyp);
X			obj->known = obj->bknown = obj->dknown = 1;
X			cornline(1,doname(obj));
X			cnt++;
X		    }
X		}
X		if (!cnt) {
X		    pline("The %s is empty.", xname(box));
X		    more();
X		} else cornline(2,"");
X	    }
X	}
X}
END_OF_FILE
if test 16435 -ne `wc -c <'src/end.c'`; then
    echo shar: \"'src/end.c'\" unpacked with wrong size!
fi
# end of 'src/end.c'
fi
if test -f 'src/mondata.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/mondata.c'\"
else
echo shar: Extracting \"'src/mondata.c'\" \(16593 characters\)
sed "s/^X//" >'src/mondata.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)mondata.c	3.0	89/11/21
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include "hack.h"
X#include "eshk.h"
X#include "epri.h"
X
X/*	These routines provide basic data for any type of monster. */
X
X#ifdef OVL0
X
Xboolean
Xattacktype(ptr, atyp)
X	register struct	permonst	*ptr;
X	register int atyp;
X{
X	int	i;
X
X	for(i = 0; i < NATTK; i++)
X	    if(ptr->mattk[i].aatyp == atyp) return(TRUE);
X
X	return(FALSE);
X}
X
X#endif /* OVL0 */
X#ifdef OVLB
X
Xboolean
Xresists_ston(ptr)	/* returns TRUE if monster is petrify resistant */
X	register struct permonst *ptr;
X{
X	return (ptr->mflags1 & (M1_STON_RES | M1_ACID) || dmgtype(ptr, AD_STON));
X}
X
Xboolean
Xresists_drli(ptr)	/* returns TRUE if monster is drain-life resistant */
X
X	register struct permonst *ptr;
X{
X	return(is_undead(ptr) || is_demon(ptr) || is_were(ptr));
X}
X
X#endif /* OVLB */
X#ifdef OVL0
X
Xboolean
Xranged_attk(ptr)	/* returns TRUE if monster can attack at range */
X	register struct permonst *ptr;
X{
X	return (attacktype(ptr, AT_BREA) || attacktype(ptr, AT_WEAP) ||
X		attacktype(ptr, AT_SPIT) || attacktype(ptr, AT_GAZE) ||
X		attacktype(ptr, AT_MAGC));
X}
X
X#endif /* OVL0 */
X#ifdef OVL1
X
Xboolean
Xcan_track(ptr)		/* returns TRUE if monster can track well */
X	register struct permonst *ptr;
X{
X#ifdef NAMED_ITEMS
X	if(uwep && !strcmp(ONAME(uwep), "Excalibur")) return TRUE;
X#endif
X	return(haseyes(ptr));
X}
X
X#endif /* OVL1 */
X#ifdef OVLB
X
X#ifdef POLYSELF
Xboolean
Xbreakarm(ptr)	/* creature will break out of armor */
X	register struct permonst *ptr;
X{
X	return(bigmonst(ptr) || (ptr->msize > MZ_SMALL && !humanoid(ptr))
X#ifdef INFERNO
X	       || ptr == &mons[PM_MARILITH]
X#endif
X	       );
X	/* Marilith is about the only case of a monster which is otherwise
X	 * humanoid but cannot wear armor (too many arms).  Centaurs would
X	 * be another except that they are already accounted for by
X	 * bigmonst.
X	 */
X}
X
Xboolean
Xsliparm(ptr)	/* creature will slide out of armor */
X	register struct permonst *ptr;
X{
X	return(ptr->msize < MZ_LARGE &&
X	       (ptr->msize <= MZ_SMALL || ptr == &mons[PM_GHOST]));
X}
X#endif
X
X#endif /* OVLB */
X#ifdef OVL1
X
Xboolean
Xsticks(ptr)	/* creature sticks other creatures it hits */
X	register struct permonst *ptr;
X{
X	return(dmgtype(ptr,AD_STCK) || dmgtype(ptr,AD_WRAP) ||
X		attacktype(ptr,AT_HUGS));
X}
X
X/* not one hundred percent correct: now a snake may hide under an
X *				    invisible object.
X */
Xboolean
Xcanseemon(mtmp)
X	register struct monst *mtmp;
X{
X	return((!mtmp->minvis || See_invisible)
X		&& (!mtmp->mhide ||
X		    (!OBJ_AT(mtmp->mx, mtmp->my) &&
X		     levl[mtmp->mx][mtmp->my].gmask == 0))
X		&& cansee(mtmp->mx, mtmp->my));
X}
X
Xboolean
Xdmgtype(ptr, dtyp)
X	register struct	permonst	*ptr;
X	register int dtyp;
X{
X	int	i;
X
X	for(i = 0; i < NATTK; i++)
X	    if(ptr->mattk[i].adtyp == dtyp) return TRUE;
X
X	return FALSE;
X}
X
Xint
Xmonsndx(ptr)		/* return an index into the mons array */
X	struct	permonst	*ptr;
X{
X#ifdef LATTICE_504_BUG
X	register int d;
X/* no problem - see, pspace IS bounded (and fits in 32 bits!) KL */
Xconst int pspace= sizeof(struct permonst[NUMMONS])/NUMMONS;
X#endif
X	register int	i;
X
X	if(ptr == &playermon) return(-1);
X#ifndef LATTICE_504_BUG
X	i = (int)(ptr - &mons[0]);
X#else
X	d=(int)((int)ptr-(int)&mons[0]);
X	i= d/pspace;
X#endif
X	if(i < 0 || i >= NUMMONS) {    
X	    panic("monsndx - could not index monster (%x)", ptr);
X	    return FALSE;		/* will not get here */
X	}
X
X	return(i);
X}
X
Xint
Xname_to_mon(str)
Xchar *str;
X{
X	/* Be careful.  We must check the entire string in case it was
X	 * something such as "ettin zombie corpse".  The calling routine
X	 * doesn't know about the "corpse" until the monster name has
X	 * already been taken off the front, so we have to be able to
X	 * read the name with extraneous stuff such as "corpse" stuck on
X	 * the end.
X	 * This causes a problem for names which prefix other names such
X	 * as "ettin" on "ettin zombie".  In this case we want the _longest_
X	 * name which exists.
X	 * This also permits plurals created by adding suffixes such as 's'
X	 * or 'es'.  Other plurals must still be handled explicitly.
X	 */
X	register int i;
X	register int mntmp = -1;
X	register char *s;
X	char buf[BUFSZ];
X	int len=0;
X
X	Strcpy(buf, str);
X	str = buf;
X	if (!strncmp(str, "a ", 2)) str += 2;
X	else if (!strncmp(str, "an ", 3)) str += 3;
X
X	/* Some irregular plurals */
X#ifdef INFERNO
X	if (!strncmp(str, "incubi", 6)) return PM_INCUBUS;
X	if (!strncmp(str, "succubi", 7)) return PM_SUCCUBUS;
X#endif
X	if (!strncmp(str, "violet fungi", 12)) return PM_VIOLET_FUNGUS;
X	if (!strncmp(str, "homunculi", 9)) return PM_HOMUNCULUS;
X	if (!strncmp(str, "baluchitheria", 13)) return PM_BALUCHITHERIUM;
X	if (!strncmp(str, "lurkers above", 13)) return PM_LURKER_ABOVE;
X	if (!strncmp(str, "cavemen", 7)) return PM_CAVEMAN;
X	if (!strncmp(str, "cavewomen", 9)) return PM_CAVEWOMAN;
X	if (!strncmp(str, "zruties", 7)) return PM_ZRUTY;
X	if (!strncmp(str, "djinn", 5)) return PM_DJINNI;
X	for(s=str; *s; s++) {
X		if (!strncmp(s, "vortices", 8)) {
X			Strcpy(s+4, "ex");
X			break;
X		}
X		/* be careful with "ies"; "priest", "zombies" */
X		if (!strncmp(s, "jellies", 7) || !strncmp(s, "mummies", 7)) {
X			Strcpy(s+4, "y");
X			break;
X		}
X		if (!strncmp(s, "ves", 3)) {
X		/* luckily no monster names end in fe or ve with ves plurals */
X			Strcpy(s, "f");
X			break;
X		}
X	}
X	
X	for(i = 0; mons[i].mlet; i++) {
X		if(!strncmp(mons[i].mname, str, strlen(mons[i].mname))) {
X			if (strlen(mons[i].mname) > len) {
X				mntmp = i;
X				len = strlen(mons[i].mname);
X			}
X		}
X	}
X	return mntmp;
X}
X
X#endif /* OVL1 */
X#ifdef OVLB
X
X#ifdef POLYSELF
Xboolean
Xwebmaker(ptr)   /* creature can spin a web */
X	register struct permonst *ptr;
X{
X	return (ptr->mlet == S_SPIDER && ptr != &mons[PM_SCORPION]);
X}
X#endif
X
Xboolean
Xis_female(mtmp)
X	register struct monst *mtmp;
X{
X	if (mtmp->isshk) return !ESHK(mtmp)->ismale;
X#if defined(ALTARS) && defined(THEOLOGY)
X	if (mtmp->ispriest) return !EPRI(mtmp)->ismale;
X#endif
X	return !!(mtmp->data->mflags2 & M2_FEM);
X}
X
X#endif /* OVLB */
X#ifdef OVL2
X
X/* Gender function.  Differs from is_female() in that 1) It allows the monster
X * type of a polymorphed shopkeeper to override ESHK(mtmp)->ismale, and 2)
X * it returns 3 values (0=male, 1=female, 2=none) instead of 2.
X */
Xint
Xgender(mtmp)
X	register struct monst *mtmp;
X{
X	if (!humanoid(mtmp->data)) return 2;
X	if (mtmp->data->mflags2 & M2_FEM) return 1;
X	if (mtmp->data == &mons[PM_CAVEMAN]
X		|| mtmp->data == &mons[PM_PRIEST]
X#ifdef INFERNO
X		|| mtmp->data == &mons[PM_INCUBUS]
X#endif
X						) return 0;
X#if defined(ALTARS) && defined(THEOLOGY)
X	if (mtmp->ispriest) return !EPRI(mtmp)->ismale;
X#endif
X	if (mtmp->isshk) return !ESHK(mtmp)->ismale;
X	return 0;
X}
X
X#endif /* OVL2 */
X#ifdef OVLB
X
Xboolean
Xlevl_follower(mtmp)
Xregister struct monst *mtmp;
X{
X	return (mtmp->mtame || (mtmp->data->mflags2 & M2_STALK) || is_fshk(mtmp)
X		|| (mtmp->iswiz && !mon_has_amulet(mtmp)));
X}
X
Xstruct permonst *
Xplayer_mon()
X{
X	switch (pl_character[0]) {
X		case 'A': return &mons[PM_ARCHEOLOGIST];
X		case 'B': return &mons[PM_BARBARIAN];
X		case 'C': if (flags.female) return &mons[PM_CAVEWOMAN];
X			else return &mons[PM_CAVEMAN];
X		case 'E': return &mons[PM_ELF];
X		case 'H': return &mons[PM_HEALER];
X		case 'K': return &mons[PM_KNIGHT];
X		case 'P': if (flags.female) return &mons[PM_PRIESTESS];
X			else return &mons[PM_PRIEST];
X		case 'R': return &mons[PM_ROGUE];
X		case 'S': return &mons[PM_SAMURAI];
X		case 'T': return &mons[PM_TOURIST];
X		case 'V': return &mons[PM_VALKYRIE];
X		case 'W': return &mons[PM_WIZARD];
X		default: impossible("what are you?");
X			return &mons[PM_HUMAN];
X	}
X}
X
Xconst int grownups[][2] = { {PM_LITTLE_DOG, PM_DOG}, {PM_DOG, PM_LARGE_DOG},
X	{PM_HELL_HOUND_PUP, PM_HELL_HOUND}, {PM_KITTEN, PM_HOUSECAT},
X	{PM_HOUSECAT, PM_LARGE_CAT}, {PM_BABY_GRAY_DRAGON, PM_GRAY_DRAGON},
X	{PM_KOBOLD, PM_LARGE_KOBOLD}, {PM_LARGE_KOBOLD, PM_KOBOLD_LORD},
X	{PM_GNOME, PM_GNOME_LORD}, {PM_GNOME_LORD, PM_GNOME_KING},
X	{PM_DWARF, PM_DWARF_LORD}, {PM_DWARF_LORD, PM_DWARF_KING},
X	{PM_SMALL_MIMIC, PM_LARGE_MIMIC}, {PM_LARGE_MIMIC, PM_GIANT_MIMIC},
X	{PM_BAT, PM_GIANT_BAT},
X	{PM_LICH, PM_DEMILICH}, {PM_DEMILICH, PM_MASTER_LICH},
X	{PM_OGRE, PM_OGRE_LORD}, {PM_OGRE_LORD, PM_OGRE_KING},
X	{PM_VAMPIRE, PM_VAMPIRE_LORD},
X	{PM_BABY_RED_DRAGON, PM_RED_DRAGON},
X	{PM_BABY_WHITE_DRAGON, PM_WHITE_DRAGON},
X	{PM_BABY_BLUE_DRAGON, PM_BLUE_DRAGON},
X	{PM_BABY_GREEN_DRAGON, PM_GREEN_DRAGON},
X	{PM_BABY_ORANGE_DRAGON, PM_ORANGE_DRAGON},
X	{PM_BABY_BLACK_DRAGON, PM_BLACK_DRAGON},
X	{PM_BABY_YELLOW_DRAGON, PM_YELLOW_DRAGON},
X	{PM_RED_NAGA_HATCHLING, PM_RED_NAGA},
X	{PM_BLACK_NAGA_HATCHLING, PM_BLACK_NAGA},
X	{PM_GOLDEN_NAGA_HATCHLING, PM_GOLDEN_NAGA},
X	{PM_GUARDIAN_NAGA_HATCHLING, PM_GUARDIAN_NAGA},
X	{PM_BABY_PURPLE_WORM, PM_PURPLE_WORM},
X#ifdef WORM
X	{PM_BABY_LONG_WORM, PM_LONG_WORM},
X#endif
X#ifdef ARMY
X	{PM_SOLDIER, PM_SERGEANT},
X	{PM_SERGEANT, PM_LIEUTENANT},
X	{PM_LIEUTENANT, PM_CAPTAIN},
X#endif
X	{PM_BABY_CROCODILE, PM_CROCODILE},
X	{-1,-1}
X};
X
Xint little_to_big(montype)
Xint montype;
X{
X#ifndef AIXPS2_BUG
X	register int i;
X	
X	for(i=0; grownups[i][0] >= 0; i++)
X		if(montype == grownups[i][0]) return grownups[i][1];
X	return montype;
X#else
X/* AIX PS/2 C-compiler 1.1.1 optimizer does not like the above for loop,
X * and causes segmentation faults at runtime.  (The problem does not
X * occur if -O is not used.)
X * lehtonen@cs.Helsinki.FI (Tapio Lehtonen) 28031990
X */
X	int i;
X	int monvalue;
X
X	monvalue = montype;
X	for(i=0; grownups[i][0] >= 0; i++)
X		if(montype == grownups[i][0]) monvalue = grownups[i][1];
X	
X	return monvalue;
X#endif
X}
X
Xint big_to_little(montype)
Xint montype;
X{
X	register int i;
X	
X	for(i=0; grownups[i][0] >= 0; i++)
X		if(montype == grownups[i][1]) return grownups[i][0];
X	return montype;
X}
X
X
Xconst char *
Xlocomotion(ptr, def)
Xconst struct permonst *ptr;
Xconst char *def;
X{
X	return (
X		is_floater(ptr) ? "float" :
X		is_flyer(ptr) ? "fly" :
X		slithy(ptr) ? "slither" :
X		amorphous(ptr) ? "ooze" :
X		nolimbs(ptr) ? "crawl" :
X		def
X	       );
X
X}
X
X#ifdef STUPID_CPP	/* otherwise these functions are macros in mondata.h */
X
Xint
Xbigmonst(ptr) struct permonst *ptr; {
X	return(ptr->msize >= MZ_LARGE);
X}
X
Xint
Xverysmall(ptr) struct permonst *ptr; {
X	return(ptr->msize < MZ_SMALL);
X}
X
Xint
Xis_flyer(ptr) struct permonst *ptr; {
X	return((ptr->mflags1 & M1_FLY) != 0L);
X}
X
Xint
Xis_floater(ptr) struct permonst *ptr; {
X	return(ptr->mlet == S_EYE);
X}
X
Xint
Xis_swimmer(ptr) struct permonst *ptr; {
X	return((ptr->mflags1 & M1_SWIM) != 0L);
X}
X
Xint
Xpasses_walls(ptr) struct permonst *ptr; {
X	return((ptr->mflags1 & M1_WALLWALK) != 0L);
X}
X
Xint
Xnoncorporeal(ptr) struct permonst *ptr; {
X	return(ptr->mlet == S_GHOST);
X}
X
Xint
Xamorphous(ptr) struct permonst *ptr; {
X	return((ptr->mflags1 & M1_AMORPHOUS) != 0L);
X}
X
Xint
Xtunnels(ptr) struct permonst *ptr; {
X	return((ptr->mflags1 & M1_TUNNEL) != 0L);
X}
X
Xint
Xneedspick(ptr) struct permonst *ptr; {
X	return((ptr->mflags1 & M1_NEEDPICK) != 0L);
X}
X
Xint
Xhides_under(ptr) struct permonst *ptr; {
X	return((ptr->mflags1 & M1_CONCEAL) != 0L);
X}
X
Xint
Xis_hider(ptr) struct permonst *ptr; {
X	return((ptr->mflags1 & M1_HIDE) != 0L);
X}
X
Xint
Xhaseyes(ptr) struct permonst *ptr; {
X	return((ptr->mflags1 & M1_NOEYES) == 0L);
X}
X
Xint
Xnohands(ptr) struct permonst *ptr; {
X	return((ptr->mflags1 & M1_NOHANDS) != 0L);
X}
X
Xint
Xnolimbs(ptr) struct permonst *ptr; {
X	return((ptr->mflags1 & M1_NOLIMBS) == M1_NOLIMBS);
X}
X
X# ifdef POLYSELF
Xint
Xpolyok(ptr) struct permonst *ptr; {
X	return((ptr->mflags1 & M1_NOPOLY) == 0L);
X}
X# endif
X
Xint
Xis_whirly(ptr) struct permonst *ptr; {
X	return((ptr->mlet == S_VORTEX) || 
X	       (ptr == &mons[PM_AIR_ELEMENTAL]));
X}
X
Xint
Xhumanoid(ptr) struct permonst *ptr; {
X	return((ptr->mflags1 & M1_HUMANOID) != 0L);
X}
X
Xint
Xis_animal(ptr) struct permonst *ptr; {
X	return((ptr->mflags1 & M1_ANIMAL) != 0L);
X}
X
Xint
Xslithy(ptr) struct permonst *ptr; {
X	return((ptr->mflags1 & M1_SLITHY) != 0L);
X}
X
Xint
Xthick_skinned(ptr) struct permonst *ptr; {
X	return((ptr->mflags1 & M1_THICK_HIDE) != 0L);
X}
X
Xint
Xresists_fire(ptr) struct permonst *ptr; {
X	return((ptr->mflags1 & M1_FIRE_RES) != 0L);
X}
X
Xint
Xresists_sleep(ptr) struct permonst *ptr; {
X	return((ptr->mflags1 & M1_SLEE_RES) != 0L || is_undead(ptr));
X}
X
Xint
Xresists_cold(ptr) struct permonst *ptr; {
X	return((ptr->mflags1 & M1_COLD_RES) != 0L);
X}
X
Xint
Xresists_disint(ptr) struct permonst *ptr; {
X	return(ptr == &mons[PM_BLACK_DRAGON] ||
X		ptr == &mons[PM_BABY_BLACK_DRAGON]);
X}
X
Xint
Xresists_elec(ptr) struct permonst *ptr; {
X	return((ptr->mflags1 & M1_ELEC_RES) != 0L);
X}
X
Xint
Xresists_acid(ptr) struct permonst *ptr; {
X	return((ptr->mflags1 & M1_ACID) != 0L);
X}
X
Xint
Xacidic(ptr) struct permonst *ptr; {
X	return((ptr->mflags1 & M1_ACID) != 0L);
X}
X
Xint
Xresists_poison(ptr) struct permonst *ptr; {
X	return((ptr->mflags1 & (M1_POIS | M1_POIS_RES)) != 0L);
X}
X
Xint
Xpoisonous(ptr) struct permonst *ptr; {
X	return((ptr->mflags1 & M1_POIS) != 0L);
X}
X
Xint
Xregenerates(ptr) struct permonst *ptr; {
X	return((ptr->mflags1 & M1_REGEN) != 0L);
X}
X
Xint
Xperceives(ptr) struct permonst *ptr; {
X	return((ptr->mflags1 & M1_SEE_INVIS) != 0L);
X}
X
Xint
Xcan_teleport(ptr) struct permonst *ptr; {
X	return((ptr->mflags1 & M1_TPORT) != 0L);
X}
X
Xint
Xcontrol_teleport(ptr) struct permonst *ptr; {
X	return((ptr->mflags1 & M1_TPORT_CONTROL) != 0L);
X}
X
Xint
Xis_armed(ptr) struct permonst *ptr; {
X	return(attacktype(ptr, AT_WEAP));
X}
X
Xint
Xlikes_gold(ptr) struct permonst *ptr; {
X	return((ptr->mflags1 & M1_GREEDY) != 0L);
X}
X
Xint
Xlikes_gems(ptr) struct permonst *ptr; {
X	return((ptr->mflags1 & M1_JEWELS) != 0L);
X}
X
Xint
Xlikes_objs(ptr) struct permonst *ptr; {
X	return((ptr->mflags1 & M1_COLLECT) != 0L || is_armed(ptr));
X}
X
Xint
Xlikes_magic(ptr) struct permonst *ptr; {
X	return((ptr->mflags1 & M1_MAGIC) != 0L);
X}
X
Xint
Xis_undead(ptr) struct permonst *ptr; {
X	return((ptr->mflags2 & M2_UNDEAD) != 0L);
X}
X
Xint
Xis_were(ptr) struct permonst *ptr; {
X	return((ptr->mflags2 & M2_WERE) != 0L);
X}
X
Xint
Xis_elf(ptr) struct permonst *ptr; {
X	return((ptr->mflags2 & M2_ELF) != 0L);
X}
X
Xint
Xis_dwarf(ptr) struct permonst *ptr; {
X	return((ptr->mflags2 & M2_DWARF) != 0L);
X}
X
Xint
Xis_giant(ptr) struct permonst *ptr; {
X	return((ptr->mflags2 & M2_GIANT) != 0L);
X}
X
X# ifdef GOLEMS
Xint
Xis_golem(ptr) struct permonst *ptr; {
X	return(ptr->mlet == S_GOLEM);
X}
X# endif /* GOLEMS */
X
Xint
Xis_domestic(ptr) struct permonst *ptr; {
X	return((ptr->mflags2 & M2_DOMESTIC) != 0L);
X}
X
X
Xint
Xis_orc(ptr) struct permonst *ptr; {
X	return((ptr->mflags2 & M2_ORC) != 0L);
X}
X
Xint
Xis_human(ptr) struct permonst *ptr; {
X	return((ptr->mflags2 & M2_HUMAN) != 0L);
X}
X
Xint
Xis_demon(ptr) struct permonst *ptr; {
X	return((ptr->mflags2 & M2_DEMON) != 0L);
X}
X
Xint
Xis_mercenary(ptr) struct permonst *ptr; {
X	return((ptr->mflags2 & M2_MERC) != 0L);
X}
X
Xint
Xis_wanderer(ptr) struct permonst *ptr; {
X	return((ptr->mflags2 & M2_WANDER) != 0L);
X}
X
Xint
Xalways_hostile(ptr) struct permonst *ptr; {
X	return((ptr->mflags2 & M2_HOSTILE) != 0L);
X}
X
Xint
Xalways_peaceful(ptr) struct permonst *ptr; {
X	return((ptr->mflags2 & M2_PEACEFUL) != 0L);
X}
X
Xint
Xextra_nasty(ptr) struct permonst *ptr; {
X	return((ptr->mflags2 & M2_NASTY) != 0L);
X}
X
Xint
Xstrongmonst(ptr) struct permonst *ptr; {
X	return((ptr->mflags2 & M2_STRONG) != 0L);
X}
X
X# ifdef POLYSELF
Xint
Xcan_breathe(ptr) struct permonst *ptr; {
X	return(attacktype(ptr, AT_BREA));
X}
X
Xint
Xcantwield(ptr) struct permonst *ptr; {
X	return(nohands(ptr) || verysmall(ptr));
X}
X
Xint
Xcantweararm(ptr) struct permonst *ptr; {
X	return(breakarm(ptr) || sliparm(ptr));
X}
X# endif /* POLYSELF */
X
Xint
Xcarnivorous(ptr) struct permonst *ptr; {
X	return((ptr->mflags2 & M2_CARNIVORE) != 0L);
X}
X
Xint
Xherbivorous(ptr) struct permonst *ptr; {
X	return((ptr->mflags2 & M2_HERBIVORE) != 0L);
X}
X
Xint
Xmetallivorous(ptr) struct permonst *ptr; {
X	return((ptr->mflags2 & M2_METALLIVORE) != 0L);
X}
X
Xint
Xlays_eggs(ptr) struct permonst *ptr; {
X	return((ptr->mflags2 & M2_EGGS) != 0L);
X}
X
Xint
Xthrows_rocks(ptr) struct permonst *ptr; {
X	return((ptr->mflags2 & M2_ROCKTHROW) != 0L);
X}
X
Xint
Xtype_is_pname(ptr) struct permonst *ptr; {
X	return((ptr->mflags2 & M2_PNAME) != 0L);
X}
X
Xint
Xis_lord(ptr) struct permonst *ptr; {
X	return((ptr->mflags2 & M2_LORD) != 0L);
X}
X
Xint
Xis_prince(ptr) struct permonst *ptr; {
X	return((ptr->mflags2 & M2_PRINCE) != 0L);
X}
X
X# ifdef INFERNO
Xint
Xis_ndemon(ptr) struct permonst *ptr; {
X	return(is_demon(ptr) &&
X		(ptr->mflags2 & (M2_LORD | M2_PRINCE)) == 0L);
X}
X# else
Xint
Xis_ndemon(ptr) struct permonst *ptr; {
X	return(ptr == &mons[PM_DEMON]);
X}
X# endif
X
Xint
Xis_dlord(ptr) struct permonst *ptr; {
X	return(is_demon(ptr) && is_lord(ptr));
X}
X
Xint
Xis_dprince(ptr) struct permonst *ptr; {
X	return(is_demon(ptr) && is_prince(ptr));
X}
X
X#endif /* STUPID_CPP */
X
X#endif /* OVLB */
END_OF_FILE
if test 16593 -ne `wc -c <'src/mondata.c'`; then
    echo shar: \"'src/mondata.c'\" unpacked with wrong size!
fi
# end of 'src/mondata.c'
fi
if test -f 'src/sounds.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/sounds.c'\"
else
echo shar: Extracting \"'src/sounds.c'\" \(16191 characters\)
sed "s/^X//" >'src/sounds.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)sounds.c	3.0	90/02/05 */
X/* NetHack may be freely redistributed.  See license for details. */
X/* Copyright (c) 1989 Janet Walz, Mike Threepoint */
X
X#define ONAMES_H	/* comment line for pre-compiled headers */
X/* block some unused #defines to avoid overloading some cpp's */
X
X#include "hack.h"
X#include "edog.h"
X
X#ifdef OVLB
X
Xstatic int FDECL(domonnoise,(struct monst *));
X
Xvoid
Xverbalize(str)
Xregister const char *str;
X{
X	if(flags.soundok) pline("\"%s\"", str);
X}
X
X#endif /* OVLB */
X
X#ifdef SOUNDS
X
X#ifdef OVL0
X
Xvoid
Xdosounds()
X{
X    register xchar hallu;
X    register struct mkroom *sroom;
X    register xchar roomtype;
X    register int croomno;
X    boolean gold_in_vault, u_in_room;
X    register int vx, vy;
X
X#ifdef __GNULINT__
X    gold_in_vault = u_in_room = FALSE;
X#endif
X
X    hallu = Hallucination ? 1 : 0;
X
X    if(!flags.soundok || u.uswallow) return;
X
X    if (fountsound && !rn2(400))
X	switch (rn2(3)+hallu) {
X	    case 0:
X		You("hear bubbling water.");
X		break;
X	    case 1:
X		You("hear water falling on coins...");
X		break;
X	    case 2:
X		You("hear the splashing of a naiad.");
X		break;
X	    case 3:
X		You("seem to hear a soda fountain!");
X		break;
X	}
X    if (sinksound && !rn2(300))
X	switch (rn2(2)+hallu) {
X	    case 0:
X		You("hear a slow drip.");
X		break;
X	    case 1:
X		You("hear a gurgling noise.");
X		break;
X	    case 2:
X		You("seem to hear dishes being washed!");
X		break;
X	}
X    if (!rn2(200)) {
X	roomtype = OROOM;
X	for (sroom = &rooms[0]; ; sroom++) {	/* find any special room */
X	    if (sroom->hx < 0) break;		/* no more rooms */
X	    if (sroom->rtype != OROOM) {
X		croomno = inroom(u.ux,u.uy);
X		u_in_room = croomno >= 0 && sroom == &rooms[croomno];
X		if (sroom->rtype < SHOPBASE)
X		    roomtype = sroom->rtype;
X		else if (!u_in_room) {
X			/* player not presently in shop */
X			/* NOTE: other special room types disappear when player
X			   enters (except VAULT) */
X		    roomtype = SHOPBASE;
X		}
X		break;
X	    }
X	}
X
X	if (roomtype == VAULT) {
X	    gold_in_vault = FALSE;
X	    for (vx = sroom->lx; vx <= sroom->hx && !gold_in_vault; vx++)
X		for (vy = sroom->ly; vy <= sroom->hy; vy++)
X		    if (g_at(vx, vy)) {
X			gold_in_vault = TRUE;
X			break;
X		    }
X	}
X
X	switch (roomtype) {
X#ifdef THRONES
X	    case COURT:
X		switch (rn2(3)+hallu) {
X		    case 0:
X			You("hear the tones of courtly conversation.");
X			break;
X		    case 1:
X			You("hear a sceptre being pounded in judgment.");
X			break;
X		    case 2:
X			pline("Someone just shouted \"Off with %s head!\"",
X			    flags.female ? "her" : "his");
X			break;
X		    case 3:
X			You("seem to hear Queen Beruthiel's cats!");
X			break;
X		}
X		break;
X#endif
X	    case SWAMP:
X		switch (rn2(2)+hallu) {
X		    case 0:
X			You("hear mosquitoes!");
X			break;
X		    case 1:
X			You("smell marsh gas!");	/* so it's a smell...*/
X			break;
X		    case 2:
X			You("seem to hear Donald Duck.");
X			break;
X		}
X		break;
X	    case VAULT:
X		if(gd_sound())
X		  switch (rn2(2)+hallu) {
X		    case 0:
X			if (gold_in_vault && !u_in_room)
X			    You("hear someone counting money.");
X			else
X			    You("hear someone searching.");
X			break;
X		    case 1:
X			You("hear the footsteps of a guard on patrol.");
X			break;
X		    case 2:
X			You("seem to hear Ebenezer Scrooge!");
X			break;
X		}
X		break;
X	    case BEEHIVE:
X		switch (rn2(2)+hallu) {
X		    case 0:
X			You("hear a low buzzing.");
X			break;
X		    case 1:
X			You("hear an angry drone.");
X			break;
X		    case 2:
X			You("seem to hear bees in your %shelmet!",
X			    uarmh ? "" : "(nonexistent) ");
X			break;
X		}
X		break;
X	    case MORGUE:
X		switch (rn2(2)+hallu) {
X		    case 0:
X		    You("suddenly realize it is unnaturally quiet.");
X			break;
X		    case 1:
X			pline("The hair on the back of your %s stands up.",
X				body_part(NECK));
X			break;
X		    case 2:
X			pline("The hair on your %s seems to stand up.",
X				body_part(HEAD));
X			break;
X		}
X		break;
X	    case BARRACKS:
X		switch (rn2(3)+hallu) {
X		    case 0:
X			You("hear dice being thrown.");
X			break;
X		    case 1:
X			You("hear blades being honed.");
X			break;
X		    case 2:
X			You("hear loud snoring.");
X			break;
X		    case 3:
X			You("seem to hear General MacArthur!");
X			break;
X		}
X		break;
X	    case ZOO:
X		switch (rn2(2)+hallu) {
X		    case 0:
XYou("hear a sound reminding you of an elephant stepping on a peanut.");
X			break;
X		    case 1:
X		    You("hear a sound reminding you of a trained seal.");
X			break;
X		    case 2:
X			You("seem to hear Doctor Doolittle!");
X			break;
X		}
X		break;
X	    case SHOPBASE:
X		if(tended_shop(sroom))
X		  switch (rn2(2)+hallu) {
X		    case 0:
X			You("hear the chime of a cash register.");
X			break;
X		    case 1:
X			You("hear someone cursing shoplifters.");
X			break;
X		    case 2:
X			You("seem to hear Neiman and Marcus arguing!");
X			break;
X		  }
X		break;
X	    default:
X		break;
X	}
X    }
X}
X
X#endif /* OVL0 */
X#ifdef OVLB
X
X#include "eshk.h"
X
X#define NOTANGRY(mon)	mon->mpeaceful
X#define ANGRY(mon)	!NOTANGRY(mon)
X
Xvoid
Xgrowl(mtmp)
Xregister struct monst *mtmp;
X{
X    /* presumably nearness and soundok checks have already been made */
X    switch (mtmp->data->msound) {
X	case MS_SILENT:
X	    break;
X	case MS_MEW:
X	case MS_HISS:
X	    pline("%s hisses!", Monnam(mtmp));
X	    break;
X	case MS_BARK:
X	case MS_GROWL:
X	    pline("%s growls!", Monnam(mtmp));
X	    break;
X	case MS_ROAR:
X	    pline("%s roars!", Monnam(mtmp));
X	    break;
X	case MS_BUZZ:
X	    kludge("%s buzzes!", Monnam(mtmp));
X	    break;
X	case MS_SQEEK:
X	    kludge("%s squeals!", Monnam(mtmp));
X	    break;
X	case MS_SQAWK:
X	    kludge("%s screeches!", Monnam(mtmp));
X	    break;
X	case MS_NEIGH:
X	    kludge("%s neighs!", Monnam(mtmp));
X	    break;
X    }
X}
X
Xvoid
Xyelp(mtmp)
Xregister struct monst *mtmp;
X/* the sounds of mistreated pets */
X{
X    /* presumably nearness and soundok checks have already been made */
X    switch (mtmp->data->msound) {
X	case MS_MEW:
X	    pline("%s yowls!", Monnam(mtmp));
X	    break;
X	case MS_BARK:
X	case MS_GROWL:
X	    pline("%s yelps!", Monnam(mtmp));
X	    break;
X	case MS_ROAR:
X	    kludge("%s snarls!", Monnam(mtmp));
X	    break;
X	case MS_SQEEK:
X	    kludge("%s squeals!", Monnam(mtmp));
X	    break;
X	case MS_SQAWK:
X	    kludge("%s screaks!", Monnam(mtmp));
X	    break;
X    }
X}
X
Xvoid
Xwhimper(mtmp)
Xregister struct monst *mtmp;
X/* the sounds of distressed pets */
X{
X    /* presumably nearness and soundok checks have already been made */
X    switch (mtmp->data->msound) {
X	case MS_MEW:
X	case MS_GROWL:
X	    pline("%s whimpers.", Monnam(mtmp));
X	    break;
X	case MS_BARK:
X	    pline("%s whines.", Monnam(mtmp));
X	    break;
X	case MS_SQEEK:
X	    kludge("%s squeals.", Monnam(mtmp));
X	    break;
X    }
X}
X
X#endif /* OVLB */
X
X#endif /* SOUNDS */
X
X#ifdef OVLB
X
X/* for the connoisseurs ... */
Xstatic const char *Qmen[] = {
X	"Max",      /* Born */
X	"Wolfgang", /* Pauli */
X	"Louis",    /* de Broglie */
X	"Erwin",    /* Schroedinger */
X	"Werner",   /* Heisenberg */
X	"Niels",    /* Bohr */
X	"Paul",     /* Dirac */
X	"Pascual",  /* Jordan */
X	"Dick",     /* Feynman */
X	"Sam" }; /* Beckett ("Oh, boy." :-) */
X
Xstruct monst *
Xqname(mtmp)
Xstruct monst *mtmp;
X{
X	return(christen_monst(mtmp, Qmen[rn2(SIZE(Qmen))]));
X}
X
Xstatic int
Xdomonnoise(mtmp)
Xregister struct monst *mtmp;
X{
X    /* presumably nearness checks have already been made */
X    if (!flags.soundok) return(0);
X    switch (mtmp->data->msound) {
X#ifdef ORACLE
X	case MS_ORACLE:
X	    return doconsult(mtmp);
X#endif
X#if defined(ALTARS) && defined(THEOLOGY)
X	case MS_PRIEST:
X	    priest_talk(mtmp);
X	    break;
X#endif
X#ifdef SOUNDS
X	case MS_SILENT:
X	    break;
X	case MS_SQEEK:
X	    kludge("%s squeaks.", Monnam(mtmp));
X	    break;
X	case MS_SQAWK:
X	    kludge("%s squawks.", Monnam(mtmp));
X	    break;
X	case MS_MEW:
X	    if (mtmp->mtame) {
X		if (mtmp->mconf || mtmp->mflee || mtmp->mtrapped || 
X		    moves > EDOG(mtmp)->hungrytime || mtmp->mtame < 5)
X		    kludge("%s yowls.", Monnam(mtmp));
X		else if (EDOG(mtmp)->hungrytime > moves + 1000)
X		    kludge("%s purrs.", Monnam(mtmp));
X		else
X		    kludge("%s mews.", Monnam(mtmp));
X	    }
X	case MS_HISS:
X	    if (!mtmp->mpeaceful && !mtmp->mtame)
X		kludge("%s hisses!", Monnam(mtmp));
X	    break;
X	case MS_BUZZ:
X	    if (!mtmp->mpeaceful && !mtmp->mtame)
X		kludge("%s buzzes angrily.", Monnam(mtmp));
X	    break;
X	case MS_GRUNT:
X	    kludge("%s grunts.", Monnam(mtmp));
X	    break;
X	case MS_BARK:
X	    if (flags.moonphase == FULL_MOON && night()) {
X		kludge("%s howls.", Monnam(mtmp));
X		break;
X	    } else if (mtmp->mtame || mtmp->mpeaceful) {
X		if (mtmp->mtame &&
X		    (mtmp->mconf || mtmp->mflee || mtmp->mtrapped ||
X		     moves > EDOG(mtmp)->hungrytime || mtmp->mtame < 5))
X		    kludge("%s whines.", Monnam(mtmp));
X		else if (EDOG(mtmp)->hungrytime > moves + 1000)
X		    kludge("%s yips.", Monnam(mtmp));
X		else
X		    kludge("%s barks.", Monnam(mtmp));
X		break;
X	    }
X	case MS_GROWL:
X	    if (!mtmp->mpeaceful && !mtmp->mtame)
X		kludge("%s growls!", Monnam(mtmp));
X	    break;
X	case MS_ROAR:
X	    if (!mtmp->mpeaceful && !mtmp->mtame)
X		kludge("%s roars!", Monnam(mtmp));
X	    break;
X	case MS_NEIGH:
X	    kludge("%s neighs.", Monnam(mtmp));
X	    break;
X	case MS_WAIL:
X	    kludge("%s wails mournfully.", Monnam(mtmp));
X	    break;
X	case MS_GURGLE:
X	    kludge("%s gurgles.", Monnam(mtmp));
X	    break;
X	case MS_BURBLE:
X	    kludge("%s burbles.", Monnam(mtmp));
X	    break;
X	case MS_SHRIEK:
X	    kludge("%s shrieks.", Monnam(mtmp));
X	    aggravate();
X	    break;
X	case MS_IMITATE:
X	    kludge("%s imitates you.", Monnam(mtmp));
X	    break;
X	case MS_DJINNI:
X	    if (mtmp->mtame) verbalize("Thank you for freeing me!");
X	    else if (mtmp->mpeaceful) verbalize("I'm free!");
X	    else verbalize("This will teach you not to disturb me!");
X	    break;
X	case MS_MUMBLE:
X	    kludge("%s mumbles incomprehensibly.", Monnam(mtmp));
X	    break;
X	case MS_HUMANOID:
X	    /* Generic humanoid behaviour. */
X	    if (!mtmp->mpeaceful && !mtmp->mtame) break;
X	    if (mtmp->mflee)
X		kludge("%s wants nothing to do with you.", Monnam(mtmp));
X	    else if (mtmp->mhp < mtmp->mhpmax/4)
X		kludge("%s moans.", Monnam(mtmp));
X	    else if (mtmp->mconf || mtmp->mstun)
X		verbalize(!rn2(3) ? "Huh?" : rn2(2) ? "What?" : "Eh?");
X	    else if (!mtmp->mcansee)
X		verbalize("I can't see!");
X	    else if (mtmp->mtrapped)
X		verbalize("I'm trapped!");
X	    else if (mtmp->mhp < mtmp->mhpmax/2)
X		kludge("%s asks for a potion of healing.", Monnam(mtmp));
X	    /* Specific monster's interests */
X	    else if (is_elf(mtmp->data))
X		kludge("%s complains about orcs.", Monnam(mtmp));
X	    else if (is_dwarf(mtmp->data))
X		kludge("%s talks about mining.", Monnam(mtmp));
X	    else if (likes_magic(mtmp->data))
X		kludge("%s talks about spellcraft.", Monnam(mtmp));
X	    else if (carnivorous(mtmp->data))
X		kludge("%s discusses what kinds of meat are safe to eat.", Monnam(mtmp));
X	    else switch (monsndx(mtmp->data)){
X# ifdef TOLKIEN
X		case PM_HOBBIT:
X		    if (mtmp->mhpmax - mtmp->mhp >= 10)
Xkludge("%s complains about unpleasant dungeon conditions.", Monnam(mtmp));
X		    else
X		    	kludge("%s asks you about the One Ring.", Monnam(mtmp));
X		    break;
X# endif
X		case PM_ARCHEOLOGIST:
Xkludge("%s describes a recent article in \"Spelunker Today\" magazine.", Monnam(mtmp));
X		    break;
X		case PM_QUANTUM_MECHANIC:
X		    /* a trademark line for other Quantum Leap cultists -3. */
X		    if (mtmp->mnamelth && strcmp(NAME(mtmp), "Sam") == 0)
X			verbalize("Oh, boy.");
X		    else {
X			const char *Qman;
X
X			do Qman = Qmen[rn2(SIZE(Qmen))];
X			while (mtmp->mnamelth && strcmp(NAME(mtmp), Qman) == 0);
X
X			kludge("%s asks if you've seen %s anywhere around.", 
X				Monnam(mtmp), Qman);
X		    }		    
X		    break;
X		default:
X		    kludge("%s discusses dungeon exploration.", Monnam(mtmp));
X	    }
X	    break;
X	case MS_SEDUCE:
X# ifdef SEDUCE
X	    if (mtmp->data->mlet != S_NYMPH &&
X		could_seduce(mtmp, &youmonst, (struct attack *)0) == 1) {
X			(void) doseduce(mtmp);
X			break;
X	    }
X	    switch ((poly_gender() != is_female(mtmp)) ? rn2(3) : 0) {
X# else
X	    switch ((poly_gender() == 0) ? rn2(3) : 0) {
X# endif
X		case 2:
X			verbalize("Hello, sailor.");
X			break;
X		case 1:
X			kludge("%s comes on to you.", Monnam(mtmp));
X			break;
X		default:
X			kludge("%s cajoles you.", Monnam(mtmp));
X	    }
X	    break;
X# ifdef KOPS
X	case MS_ARREST:
X	    if (mtmp->mpeaceful)
X		pline("\"Just the facts, %s.\"",
X		      flags.female ? "Ma'am" : "Sir");
X	    else switch (rn2(3)) {
X		case 1:
X		    verbalize("Anything you say can be used against you.");
X		    break;
X		case 2:
X		    verbalize("You're under arrest!");
X		    break;
X		default:
X		    verbalize("Stop in the name of the Law!");
X	    }
X	    break;
X# endif
X	case MS_LAUGH:
X	    switch (rn2(4)) {
X		case 1:
X		    kludge("%s giggles.", Monnam(mtmp));
X		    break;
X		case 2:
X		    kludge("%s chuckles.", Monnam(mtmp));
X		    break;
X		case 3:
X		    kludge("%s snickers.", Monnam(mtmp));
X		    break;
X		default:
X		    kludge("%s laughs.", Monnam(mtmp));
X	    }
X	    break;
X# ifdef INFERNO
X	case MS_BRIBE:
X	    if (mtmp->mpeaceful && !mtmp->mtame) {
X		(void) demon_talk(mtmp);
X		break;
X	    }
X	    /* fall through */
X# endif
X	case MS_CUSS:
X	    if (!mtmp->mpeaceful && !mtmp->mtame)
X		cuss(mtmp);
X	    break;
X	case MS_GUARD:
X	    if (u.ugold)
X		verbalize("Please drop that gold and follow me.");
X	    else
X		verbalize("Please follow me.");
X	    break;
X	case MS_NURSE:
X	    if (uwep)
X		verbalize("Put that weapon away before you hurt someone!");
X	    else if (uarmc || uarm || uarmh || uarms || uarmg || uarmf)
X		if (pl_character[0] == 'H')
X		    verbalize("Doc, I can't help you unless you cooperate.");
X		else
X		    verbalize("Please undress so I can examine you.");
X# ifdef SHIRT
X	    else if (uarmu)
X		verbalize("Take off your shirt, please.");
X# endif
X	    else verbalize("Relax, this won't hurt a bit.");
X	    break;
X	case MS_SELL: /* pitch, pay, total */
X	    if (ANGRY(mtmp))
X		kludge("%s mentions how much %s dislikes %s customers.",
X			ESHK(mtmp)->shknam,
X			ESHK(mtmp)->ismale ? "he" : "she",
X			ESHK(mtmp)->robbed ? "non-paying" : "rude");
X	    else if (ESHK(mtmp)->following)
X		if (strncmp(ESHK(mtmp)->customer, plname, PL_NSIZ)) {
X		    pline("\"Hello %s!  I was looking for %s.\"",
X			    plname, ESHK(mtmp)->customer);
X		    ESHK(mtmp)->following = 0;
X		} else {
X		    pline("\"Hello %s!  Didn't you forget to pay?\"",
X			    plname);
X		}
X	    else if (ESHK(mtmp)->robbed)
X		kludge("%s complains about a recent robbery.", ESHK(mtmp)->shknam);
X	    else if (ESHK(mtmp)->billct)
X		kludge("%s reminds you that you haven't paid yet.", ESHK(mtmp)->shknam);
X	    else if (mtmp->mgold < 50)
X		kludge("%s complains that business is bad.", ESHK(mtmp)->shknam);
X	    else if (mtmp->mgold > 4000)
X		kludge("%s says that business is good.", ESHK(mtmp)->shknam);
X	    else
X		kludge("%s talks about the problem of shoplifters.", ESHK(mtmp)->shknam);
X	    break;
X# ifdef ARMY
X	case MS_SOLDIER:
X	    if (!mtmp->mpeaceful)
X	    switch (rn2(3)) {
X		case 2:
X		    verbalize("Resistance is useless!");
X		    break;
X		case 1:
X		    verbalize("You're dog meat!");
X		    break;
X		default:
X		    verbalize("Surrender!");
X	    }
X	    break;
X# endif
X#endif /* SOUNDS */
X    }
X    return(1);
X}
X
X
Xint
Xdotalk()
X{
X    register struct monst *mtmp;
X    register int tx,ty;
X
X    if (u.uswallow) {
X	pline("They won't hear you out there.");
X	return(0);
X    }
X
X    pline("Talk to whom? [in what direction] ");
X    (void) getdir(0);
X
X    if (u.dz) {
X	pline("They won't hear you %s there.", u.dz < 0 ? "up" : "down");
X	return(0);
X    }
X
X    if (u.dx == 0 && u.dy == 0) {
X/*
X * Let's not include this.  It raises all sorts of questions: can you wear
X * 2 helmets, 2 amulets, 3 pairs of gloves or 6 rings as a marilith,
X * etc...  --KAA
X#ifdef POLYSELF
X	if (u.umonnum == PM_ETTIN) {
X	    You("discover that your other head makes boring conversation.");
X	    return(1);
X	}
X#endif
X*/
X	pline("Talking to yourself is a bad habit for a dungeoneer.");
X	return(0);
X    }
X
X    tx = u.ux+u.dx; ty = u.uy+u.dy;
X    if ((Blind && !Telepat) || !MON_AT(tx, ty) ||
X	    (mtmp = m_at(tx, ty))->mimic || mtmp->mundetected) {
X	pline("I see nobody there.");
X	return(0);
X    }
X    if (!mtmp->mcanmove || mtmp->msleep) {
X	kludge("%s seems not to notice you.", Monnam(mtmp));
X	return 0;
X    }
X
X    return domonnoise(mtmp);
X}
X
X#endif /* OVLB */
END_OF_FILE
if test 16191 -ne `wc -c <'src/sounds.c'`; then
    echo shar: \"'src/sounds.c'\" unpacked with wrong size!
fi
# end of 'src/sounds.c'
fi
echo shar: End of archive 40 \(of 56\).
cp /dev/null ark40isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 56 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
    echo Building monst.c from monst.c1 and monst.c2
    cat src/monst.c1 src/monst.c2 > src/monst.c
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
