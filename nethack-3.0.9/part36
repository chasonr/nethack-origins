Path: utzoo!attcan!uunet!cs.utexas.edu!mailrus!cornell!uw-beaver!zephyr.ens.tek.com!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v10i081:  nethack3p9 -  display oriented dungeons & dragons (Ver. 3.0i), Part36/56
Message-ID: <5939@tekred.CNA.TEK.COM>
Date: 12 Jul 90 16:08:51 GMT
Sender: news@tekred.CNA.TEK.COM
Lines: 1852
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 10, Issue 81
Archive-name: nethack3p9/Part36
Supersedes: NetHack3: Volume 7, Issue 56-93



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 36 (of 56)."
# Contents:  auxil/rumors.fal src/priest.c src/topten.c
# Wrapped by billr@saab on Wed Jul 11 17:11:45 1990
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'auxil/rumors.fal' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'auxil/rumors.fal'\"
else
echo shar: Extracting \"'auxil/rumors.fal'\" \(20885 characters\)
sed "s/^X//" >'auxil/rumors.fal' <<'END_OF_FILE'
X"So when I die, the first thing I will see in heaven is a score list?"
X1st Law of Hacking:  leaving is much more difficult than entering.
X2nd Law of Hacking:  first in, first out.
X3rd Law of Hacking:  the last blow counts most.
X4th Law of Hacking:  you will find the exit at the entrance.
XA chameleon imitating a mail daemon often delivers scrolls of fire.
XA cockatrice corpse is guaranteed to be untainted!
XA dead cockatrice is just a dead lizard.
XA dragon is just a snake that ate a scroll of fire.
XA fading corridor enlightens your insight.
XA glowing potion is too hot to drink.
XA good amulet may protect you against guards.
XA lizard corpse is a good thing to turn undead.
XA long worm can be defined recursively.  So how should you attack it?
XA monstrous mind is a toy forever.
XA nymph will be very pleased if you call her by her real name:  Lorelei.
XA ring of dungeon master control is a great find.
XA ring of extra ring finger is useless if not enchanted.
XA rope may form a trail in a maze.
XA staff may recharge if you drop it for awhile.
XA visit to the Zoo is very educational; you meet interesting animals.
XA wand of deaf is a more dangerous weapon than a wand of sheep.
XA wand of vibration might bring the whole cave crashing about your ears.
XA winner never quits.  A quitter never wins.
XA wish?  Okay, make me a fortune cookie!
XAfraid of mimics?  Try to wear a ring of true seeing.
XAll monsters are created evil, but some are more evil than others.
XAlways attack a floating eye from behind!
XAn elven cloak is always the height of fashion.
XAny small object that is accidentally dropped will hide under a larger object.
XBalrogs do not appear above level 20.
XBanana peels work especially well against Keystone Kops.
XBe careful when eating bananas.  Monsters might slip on the peels.
XBetter leave the dungeon; otherwise you might get hurt badly.
XBeware of the potion of nitroglycerin -- it's not for the weak of heart.
XBeware:  there's always a chance that your wand explodes as you try to zap it!
XBeyond the 23rd level lies a happy retirement in a room of your own.
XChanging your suit without dropping your sword?  You must be kidding!
XCockatrices might turn themselves to stone faced with a mirror.
XConsumption of home-made food is strictly forbidden in this dungeon.
XDark room?  Your chance to develop your photographs!
XDark rooms are not *completely* dark:  just wait and let your eyes adjust...
XDavid London sez, "Hey guys, *WIELD* a lizard corpse against a cockatrice!"
XDeath is just life's way of telling you you've been fired.
XDemi-gods don't need any help from the gods.
XDemons *HATE* Priests and Priestesses.
XDidn't you forget to pay?
XDidn't your mother tell you not to eat food off the floor?
XDirect a direct hit on your direct opponent, directing in the right direction.
XDon't eat too much:  you might start hiccoughing!
XDon't play hack at your work; your boss might hit you!
XDon't tell a soul you found a secret door, otherwise it isn't a secret anymore.
XDrinking potions of booze may land you in jail if you are under 21.
XDrop your vanity and get rid of your jewels!  Pickpockets about!
XEat 10 cloves of garlic and keep all humans at a two-square distance.
XEels hide under mud.  Use a unicorn to clear the water and make them visible.
XEngrave your wishes with a wand of wishing.
XEventually you will come to admire the swift elegance of a retreating nymph.
XEver heard hissing outside?  I *knew* you hadn't!
XEver lifted a dragon corpse?
XEver seen a leocrotta dancing the tengu?
XEver seen your weapon glow plaid?
XEver tamed a shopkeeper?
XEver tried digging through a Vault Guard?
XEver tried enchanting a rope?
XExtra staircases lead to extra levels.
XFloating eyes can't stand Hawaiian shirts.
XFor any remedy there is a misery.
XGiant bats turn into giant vampires.
XGood day for overcoming obstacles.  Try a steeplechase.
XHelp!  I'm being held prisoner in a fortune cookie factory!
XHungry?  There is an abundance of food on the next level.
XI guess you've never hit a mail daemon with the Amulet of Yendor...
XIf you are the shopkeeper, you can take things for free.
XIf you can't learn to do it well, learn to enjoy doing it badly.
XIf you thought the Wizard was bad, just wait till you meet the Warlord!
XIf you turn blind, don't expect your dog to be turned into a seeing-eye dog.
XIf you want to feel great, you must eat something real big.
XIf you want to float, you'd better eat a floating eye.
XIf your ghost kills a player, it increases your score.
XIncrease mindpower:  Tame your own ghost!
XIt furthers one to see the great man.
XIt's easy to overlook a monster in a wood.
XJust below any trapdoor there may be another one.  Just keep falling!
XKatanas are very sharp; watch you don't cut yourself.
XKeep a clear mind:  quaff clear potions.
XKicking the terminal doesn't hurt the monsters.
XKiller bees keep appearing till you kill their queen.
XKiller bunnies can be tamed with carrots only.
XLatest news?  Put 'rec.games.hack' in your .newsrc!
XLearn how to spell.  Play NetHack!
XLeprechauns hide their gold in a secret room.
XLet your fingers do the walking on the yulkjhnb keys.
XLet's face it:  this time you're not going to win.
XLet's have a party, drink a lot of booze.
XLiquor sellers do not drink; they hate to see you twice.
XLunar eclipse tonight.  May as well quit now!
XMeeting your own ghost decreases your luck considerably!
XMoney to invest?  Take it to the local branch of the Magic Memory Vault!
XMonsters come from nowhere to hit you everywhere.
XMonsters sleep because you are boring, not because they ever get tired.
XMost monsters prefer minced meat.  That's why they are hitting you!
XMost of the bugs in NetHack are on the floor.
XMuch ado Nothing Happens.
XMulti-player NetHack is a myth.
XNetHack is addictive.  Too late, you're already hooked.
XNever ask a shopkeeper for a price list.
XNever burn a tree, unless you like getting whacked with a +5 shovel.
XNever eat with glowing hands!
XNever mind the monsters hitting you:  they just replace the charwomen.
XNever play leapfrog with a unicorn.
XNever step on a cursed engraving.
XNever swim with a camera:  there's nothing to take pictures of.
XNever teach your pet rust monster to fetch.
XNever trust a random generator in magic fields.
XNever use a wand of death.
XNo level contains two shops.  The maze is no level.  So...
XNo part of this fortune may be reproduced, stored in a retrieval system, ...
XNot all rumors are as misleading as this one.
XNymphs and nurses like beautiful rings.
XNymphs are blondes.  Are you a gentleman?
XOffering a unicorn a worthless piece of glass might prove to be fatal!
XOld hackers never die:  young ones do.
XOne has to leave shops before closing time.
XOne homunculus a day keeps the doctor away.
XOne level further down somebody is getting killed, right now.
XOnly a wizard can use a magic whistle.
XOnly adventurers of evil alignment think of killing their dog.
XOnly chaotic evils kill sleeping monsters.
XOnly real trappers escape traps.
XOnly real wizards can write scrolls.
XOperation OVERKILL has started now.
XPLEASE ignore previous rumor.
XPolymorph into an ettin; meet your opponents face to face to face.
XPraying will frighten demons.
XRow (3x) that boat gently down the stream, Charon (4x), death is but a dream.
XRunning is good for your legs.
XScrew up your courage!  You've screwed up everything else.
XSegmentation fault (core dumped).
XShopkeepers sometimes die from old age.
XSome mazes (especially small ones) have no solutions, says man 6 maze.
XSome questions the Sphynx asks just *don't* have any answers.
XSometimes "mu" is the answer.
XSorry, no fortune this time.  Better luck next cookie!
XSpare your scrolls of make-edible until it's really necessary!
XSuddenly, the dungeon will collapse...
XTaming a mail daemon may cause a system security violation.
XThe leprechauns hide their treasure in a small hidden room.
XThe longer the wand the better.
XThe use of dynamite is dangerous.
XThey say that Demogorgon, Asmodeus, Orcus, Yeenoghu & Juiblex is no law firm.
XThey say that Geryon has an evil twin, beware!
XThey say that Medusa would make a terrible pet.
XThey say that NetHack bugs are Seldon planned.
XThey say that NetHack comes in 256 flavors.
XThey say that NetHack is just a computer game.
XThey say that NetHack is more than just a computer game.
XThey say that NetHack is never what it used to be.
XThey say that a baby dragon is too small to hurt or help you.
XThey say that a black pudding is simply a brown pudding gone bad.
XThey say that a black sheep has 3 bags full of wool.
XThey say that a blank scroll is like a blank check.
XThey say that a cat named Morris has nine lives.
XThey say that a desperate shopper might pay any price in a shop.
XThey say that a diamond dog is everybody's best friend.
XThey say that a dwarf lord can carry a pick-axe because his armor is light.
XThey say that a floating eye can defeat Medusa.
XThey say that a fortune only has 1 line and you can't read between it.
XThey say that a fortune only has 1 line, but you can read between it.
XThey say that a fountain looks nothing like a regularly erupting geyser.
XThey say that a gold doubloon is worth more than its weight in gold.
XThey say that a grid bug won't pay a shopkeeper for zapping you in a shop.
XThey say that a gypsy could tell your fortune for a price.
XThey say that a hacker named Alice once level teleported by using a mirror.
XThey say that a hacker named David once slew a giant with a sling and a rock.
XThey say that a hacker named Dorothy once rode a fog cloud to Oz.
XThey say that a hacker named Mary once lost a white sheep in the mazes.
XThey say that a helm of brilliance is not to be taken lightly.
XThey say that a hot dog and a hell hound are the same thing.
XThey say that a lamp named Aladdin contains a djinni with 3 wishes.
XThey say that a large dog named Lassie will lead you to the amulet.
XThey say that a long sword is not a light sword.
XThey say that a manes won't mince words with you.
XThey say that a mind is a terrible thing to waste.
XThey say that a plain nymph will only wear a wire ring in one ear.
XThey say that a plumed hat could be a previously used crested helmet.
XThey say that a potion of oil is difficult to grasp.
XThey say that a potion of yogurt is a cancelled potion of sickness.
XThey say that a purple worm is not a baby purple dragon.
XThey say that a quivering blob tastes different than a gelatinous cube.
XThey say that a scroll of summoning has other names.
XThey say that a shaman can bestow blessings but usually doesn't.
XThey say that a shaman will bless you for an eye of newt and wing of bat.
XThey say that a shimmering gold shield is not a polished silver shield.
XThey say that a spear will hit a neo-otyugh.  (Do YOU know what that is?)
XThey say that a spotted dragon is the ultimate shape changer.
XThey say that a stethoscope is no good if you can only hear your heartbeat.
XThey say that a succubus named Suzy will sometimes warn you of danger.
XThey say that a wand of cancellation is not like a wand of polymorph.
XThey say that a wide sword named Stormbringer attracts vortices.
XThey say that a wood golem named Pinocchio would be easy to control.
XThey say that after killing a dragon its time for a change of scenery.
XThey say that an amulet of strangulation is worse than ring around the collar.
XThey say that an attic is the best place to hide your toys.
XThey say that an axe named Cleaver once belonged to a hacker named Beaver.
XThey say that an eye of newt and a wing of bat are double the trouble.
XThey say that an incubus named Izzy sometimes makes women feel sensitive.
XThey say that an opulent throne room is rarely a place to wish you'd be in.
XThey say that an unlucky hacker once had a nose bleed at an altar and died.
XThey say that and they say this but they never say never, never!
XThey say that any quantum mechanic knows that speed kills.
XThey say that applying a unicorn horn means you've missed the point.
XThey say that blue stones are radioactive, beware.
XThey say that building a dungeon is a team effort.
XThey say that chaotic characters never get a kick out of altars.
XThey say that collapsing a dungeon often creates a panic.
XThey say that counting your eggs before they hatch shows that you care.
XThey say that dipping a bag of tricks in a fountain won't make it an icebox.
XThey say that dipping an eel and brown mold in hot water makes bouillabaisse.
XThey say that donating a doubloon is extremely pious charity.
XThey say that eating royal jelly attracts grizzly owlbears.
XThey say that eggs, pancakes and juice are just a mundane breakfast.
XThey say that everyone knows why Medusa stands alone in the dark.
XThey say that finding a winning strategy is a deliberate move on your part.
XThey say that finding worthless glass is worth something.
XThey say that fortune cookies are food for thought.
XThey say that gold is only wasted on a pet dragon.
XThey say that good things come to those that wait.
XThey say that if you can't spell then you'll wish you had a spell book.
XThey say that if you live by the sword, you'll die by the sword.
XThey say that if you play like a monster you'll have a better game.
XThey say that if you sleep with a demon you might awake with a headache.
XThey say that if you step on a crack you could break your mother's back.
XThey say that if you're invisible you can still be heard!
XThey say that if you're lucky you can feel the runes on a scroll.
XThey say that in the big picture gold is only small change.
XThey say that in the dungeon it's not what you know that really matters.
XThey say that in the dungeon moon rocks are really dilithium crystals.
XThey say that in the dungeon the boorish customer is never right.
XThey say that in the dungeon you don't need a watch to tell time.
XThey say that in the dungeon you need something old, new, burrowed and blue.
XThey say that in the dungeon you should always count your blessings.
XThey say that iron golem plate mail isn't worth wishing for.
XThey say that it takes four quarterstaffs to make one staff.
XThey say that it's not over till the fat ladies sing.
XThey say that it's not over till the fat lady shouts `Off with its head'.
XThey say that kicking a heavy statue is really a dumb move.
XThey say that kicking a valuable gem doesn't seem to make sense.
XThey say that leprechauns know Latin and you should too.
XThey say that minotaurs get lost outside of the mazes.
XThey say that most trolls are born again.
XThey say that naming your cat Garfield will make you more attractive.
XThey say that no one has ever walked to hell.
XThey say that no one knows everything about everything in the dungeon.
XThey say that no one plays NetHack just for the fun of it.
XThey say that no one really subscribes to rec.games.hack.
XThey say that no one will admit to starting a rumor.
XThey say that nurses sometimes carry scalpels and never use them.
XThey say that once you've met one wizard you've met them all.
XThey say that one troll is worth 10,000 newts.
XThey say that only David can find the zoo!
XThey say that only angels play their harps for their pets.
XThey say that only big spenders carry gold.
XThey say that only female monsters can lay eggs.
XThey say that orc shamans are healthy, wealthy and wise.
XThey say that playing NetHack is like walking into a death trap.
XThey say that problem breathing is best treated by a proper diet.
XThey say that quaffing many potions of levitation can give you a headache.
XThey say that queen bees get that way by eating royal jelly.
XThey say that reading a scare monster scroll is the same as saying Elbereth.
XThey say that real hackers always are controlled.
XThey say that real hackers never burn in hell.
XThey say that real hackers never sleep.
XThey say that shopkeepers never carry more than 20 gold pieces, at night.
XThey say that shopkeepers never sell blessed potions of invisibility.
XThey say that soldiers wear kid gloves and silly helmets.
XThey say that some monsters may kiss your boots to stop your drum playing.
XThey say that sometimes you can be the hit of the party when playing a horn.
XThey say that the NetHack gods generally welcome your sacrifices.
XThey say that the Three Rings are named Vilya, Nenya and Narya.
XThey say that the Wizard of Yendor has a death wish.
XThey say that the `hair of the dog' is sometimes an effective remedy.
XThey say that the best time to save your game is now before its too late.
XThey say that the biggest obstacle in NetHack is your mind.
XThey say that the gods are angry when they hit you with objects.
XThey say that the priesthood are specially favored by the gods.
XThey say that the way to make a unicorn happy is to give it what it wants.
XThey say that there are no black or white stones, only gray.
XThey say that there are no skeletons hence there are no skeleton keys.
XThey say that there is a clever rogue in every hacker just dying to escape.
XThey say that there is no such thing as free advice.
XThey say that there is only one way to win at NetHack.
XThey say that there once was a fearsome chaotic samurai named Luk No.
XThey say that there was a time when cursed holy water wasn't water.
XThey say that there's no point in crying over a gray ooze.
XThey say that there's only hope left after you've opened Pandora's box.
XThey say that trapdoors should always be marked 'Caution:  Trap Door'.
XThey say that using an amulet of change isn't a difficult operation.
XThey say that water walking boots are better if you are fast like Hermes.
XThey say that when you wear a circular amulet you might resemble a troll.
XThey say that when you're hungry you can get a pizza in 30 moves or it's free.
XThey say that when your god is angry you should try another one.
XThey say that wielding a unicorn horn takes strength.
XThey say that with speed boots you never worry about hit and run accidents.
XThey say that you can defeat a killer bee with a unicorn horn.
XThey say that you can only cross the River Styx in Charon's boat.
XThey say that you can only kill a lich once and then you'd better be careful.
XThey say that you can only wish for things you've already had.
XThey say that you can train a cat by talking gently to it.
XThey say that you can train a dog by talking firmly to it.
XThey say that you can trust your gold with the king.
XThey say that you can't wipe your greasy bare hands on a blank scroll.
XThey say that you cannot trust scrolls of rumor.
XThey say that you could fall head over heels for an energy vortex.
XThey say that you need a key in order to open locked doors.
XThey say that you need a mirror to notice a mimic in an antique shop.
XThey say that you really can use a pick-axe unless you really can't.
XThey say that you should always store your tools in the cellar.
XThey say that you should be careful while climbing the ladder to success.
XThey say that you should call your armor `rustproof'.
XThey say that you should keep your hands in your pockets around the gypsies.
XThey say that you should name your dog Spuds to have a cool pet.
XThey say that you should name your weapon after your first monster kill.
XThey say that you should never introduce a rope golem to a succubus.
XThey say that you should never sleep near invisible ring wraiths.
XThey say that you should never try to leave the dungeon with a bag of gems.
XThey say that you should remove your armor before sitting on a throne.
XThey say the gods get angry if you kill your dog.
XThis fortune cookie is the property of Fortune Cookies, Inc.
XTo reach heaven, escape the dungeon while wearing a ring of levitation.
XTourists wear shirts loud enough to wake the dead.
XTridents are for use underwater.
XTry calling your katana Moulinette.
XUlch!  That meat was painted!
XUnfortunately, this message was left intentionally blank.
XUsing a morning star in the evening has no effect.
XWant a hint?  Zap a wand of make invisible on your weapon!
XWarning:  fortune reading can be hazardous to your health.
XWe have new ways of detecting treachery...
XWhat a pity, you cannot read it!
XWhen a piercer drops in on you, you will be tempted to hit the ceiling!
XWhen in a maze follow the right wall and you will never get lost.
XWhen you have a key, you don't have to wait for the guard.
XWhy are you wasting time reading fortunes?
XWhy bother casting fireballs in hell?
XWish for a master key and open the Magic Memory Vault!
XWizard expects every monster to do its duty.
XWow!  You could've had a potion of fruit juice!
XYou are destined to be misled by a fortune.
XYou can get a genuine Amulet of Yendor by doing the following:  --More--
XYou can protect yourself from black dragons by doing the following:  --More--
XYou feel like someone is pulling your leg.
XYou have to outwit the Sphynx or pay her.
XYou hear the fortune cookie's hissing!
XYou may get rich selling letters, but beware of being blackmailed!
XYou offend Shai-Hulud by sheathing your crysknife without having drawn blood.
XYou swallowed the fortune!
XYou want to regain strength?  Two levels ahead is a guesthouse!
XYou will encounter a tall, dark, and gruesome creature...
END_OF_FILE
if test 20885 -ne `wc -c <'auxil/rumors.fal'`; then
    echo shar: \"'auxil/rumors.fal'\" unpacked with wrong size!
fi
# end of 'auxil/rumors.fal'
fi
if test -f 'src/priest.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/priest.c'\"
else
echo shar: Extracting \"'src/priest.c'\" \(14545 characters\)
sed "s/^X//" >'src/priest.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)priest.c	3.0	89/06/26
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* Copyright (c) Izchak Miller, Steve Linhart, 1989. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#define MONATTK_H	/* comment line for pre-compiled headers */
X/* block some unused #defines to avoid overloading some cpp's */
X#include "hack.h"
X#include "mfndpos.h"
X#include "eshk.h"
X#include "epri.h"
X
X#ifdef OVLB
X
X#if defined(ALTARS) && defined(THEOLOGY)
Xstatic boolean FDECL(histemple_at,(struct monst *,int,int));
Xstatic int FDECL(t_alignment,(struct mkroom *));
Xstatic boolean FDECL(is_shrined,(struct mkroom *));
Xstatic boolean FDECL(t_coaligned,(struct mkroom *));
Xstruct monst *FDECL(findpriest,(struct mkroom *));
Xstatic boolean FDECL(p_inhistemple,(struct mkroom *));
X#endif
X
X/* used for the insides of shk_move and pri_move */
Xint
Xmove_special(mtmp,monroom,appr,uondoor,avoid,omx,omy,gx,gy)
Xregister struct monst *mtmp;
Xschar monroom,appr;
Xboolean uondoor,avoid;
Xregister xchar omx,omy,gx,gy;
X{
X	register xchar nx,ny,nix,niy;
X	register schar i;
X	schar chcnt,cnt;
X	coord poss[9];
X	long info[9];
X	long allowflags;
X	struct obj *ib = 0;
X
X	if(omx == gx && omy == gy)
X		return(0);
X	if(mtmp->mconf) {
X		avoid = FALSE;
X		appr = 0;
X	}
X
X	nix = omx;
X	niy = omy;
X	if (mtmp->isshk) allowflags = ALLOW_SSM;
X	else allowflags = ALLOW_SSM | ALLOW_SANCT;
X	if (passes_walls(mtmp->data)) allowflags |= (ALLOW_ROCK|ALLOW_WALL);
X	if (throws_rocks(mtmp->data)) allowflags |= ALLOW_ROCK;
X	if (tunnels(mtmp->data) &&
X		    (!needspick(mtmp->data) || m_carrying(mtmp, PICK_AXE)))
X		allowflags |= ALLOW_DIG;
X	if (!nohands(mtmp->data) && !verysmall(mtmp->data)) {
X		allowflags |= OPENDOOR;
X		if (m_carrying(mtmp, SKELETON_KEY)) allowflags |= BUSTDOOR;
X	}
X	if (is_giant(mtmp->data)) allowflags |= BUSTDOOR;
X	cnt = mfndpos(mtmp, poss, info, allowflags);
X	if (allowflags & ALLOW_DIG) if(!mdig_tunnel(mtmp)) return(-2);
X
X	if(mtmp->isshk && avoid && uondoor) { /* perhaps we cannot avoid him */
X		for(i=0; i<cnt; i++)
X		    if(!(info[i] & NOTONL)) goto pick_move;
X		avoid = FALSE;
X	}
X
X#define	GDIST(x,y)	(dist2(x,y,gx,gy))
Xpick_move:
X	chcnt = 0;
X	for(i=0; i<cnt; i++) {
X		nx = poss[i].x;
X		ny = poss[i].y;
X		if(levl[nx][ny].typ == ROOM ||
X#if defined(ALTARS) && defined(THEOLOGY)
X			(mtmp->ispriest &&
X			    levl[nx][ny].typ == ALTAR) ||
X#endif
X			(mtmp->isshk &&
X			    (monroom != ESHK(mtmp)->shoproom
X			    || ESHK(mtmp)->following))) {
X		    if(avoid && (info[i] & NOTONL))
X			continue;
X		    if((!appr && !rn2(++chcnt)) ||
X			(appr && GDIST(nx,ny) < GDIST(nix,niy))) {
X			    nix = nx;
X			    niy = ny;
X		    }
X		}
X	}
X#if defined(ALTARS) && defined(THEOLOGY)
X	if(mtmp->ispriest && avoid &&
X			nix == omx && niy == omy && online(omx,omy)) {
X		/* might as well move closer as long it's going to stay
X		 * lined up */
X		avoid = FALSE;
X		goto pick_move;
X	}
X#endif
X
X	if(nix != omx || niy != omy) {
X		remove_monster(omx, omy);
X		place_monster(mtmp, nix, niy);
X		pmon(mtmp);
X		if(ib) {
X			if (cansee(mtmp->mx,mtmp->my))
X			    pline("%s picks up %s.", Monnam(mtmp),
X				distant_name(ib,doname));
X			freeobj(ib);
X			mpickobj(mtmp, ib);
X		}
X		return(1);
X	}
X	return(0);
X}
X
X#endif /* OVLB */
X
X#if defined(ALTARS) && defined(THEOLOGY)
X
X#ifdef OVL0
X
Xstruct mkroom *
Xin_temple(x, y)
Xregister int x, y;
X{
X	register int roomno = inroom(x, y);
X
X	if (roomno < 0 || rooms[roomno].rtype != TEMPLE)
X		return((struct mkroom *)0);
X	return(&rooms[roomno]);
X}
X
X#endif /* OVL0 */
X#ifdef OVLB
X
Xstatic boolean
Xhistemple_at(priest, x, y)
Xregister struct monst *priest;
Xregister int x, y;
X{
X	return(EPRI(priest)->shroom == inroom(x, y) && 
X	       EPRI(priest)->shrlevel == dlevel);
X}
X
X/*
X * pri_move: return 1: he moved  0: he didn't  -1: let m_move do it  -2: died
X */
Xint
Xpri_move(priest)
Xregister struct monst *priest;
X{
X	register xchar gx,gy,omx,omy;
X	schar temple;
X	boolean avoid = TRUE;
X
X	omx = priest->mx;
X	omy = priest->my;
X
X	if(!histemple_at(priest, omx, omy)) return(-1);
X
X	temple = EPRI(priest)->shroom;
X	
X	gx = EPRI(priest)->shrpos.x;
X	gy = EPRI(priest)->shrpos.y;
X
X	gx += rn1(3,-1);	/* mill around the altar */
X	gy += rn1(3,-1);
X
X	if(!priest->mpeaceful) {
X		if(monnear(priest, u.ux, u.uy)) {
X			if(Displaced)
X				Your("displaced image doesn't fool %s!",
X					mon_nam(priest));
X			(void) mattacku(priest);
X			return(0);
X		} else if(temple == inroom(u.ux,u.uy)) {
X			/* don't chase player outside temple */
X			long saveBlind = Blinded;
X			struct obj *saveUblindf = ublindf;
X			Blinded = 0;
X			ublindf = (struct obj *)0;
X			if(priest->mcansee && !Invis && cansee(omx,omy)) {
X				gx = u.ux;
X				gy = u.uy;
X			}
X			Blinded = saveBlind;
X			ublindf = saveUblindf;
X			avoid = FALSE;
X		}
X	} else if(Invis) avoid = FALSE;
X	
X	return(move_special(priest,temple,TRUE,FALSE,avoid,omx,omy,gx,gy));
X}
X
X/* exclusively for mktemple() */
Xvoid
Xpriestini(lvl, sx, sy, align)
Xregister int lvl, sx, sy, align;
X{
X	register struct monst *priest;
X	register struct obj *otmp = (struct obj *)0;
X#ifdef SPELLS
X	register int cnt;
X#endif
X	if(MON_AT(sx+1, sy)) rloc(m_at(sx+1, sy)); /* insurance */
X
X	if(priest = makemon(&mons[!rn2(2) ? PM_TEMPLE_PRIEST : 
X			PM_TEMPLE_PRIESTESS], sx+1, sy)) {
X		EPRI(priest)->shroom = inroom(sx, sy);
X		EPRI(priest)->shralign = align;
X		EPRI(priest)->shrpos.x = sx;
X		EPRI(priest)->shrpos.y = sy;
X		EPRI(priest)->shrlevel = lvl;
X		EPRI(priest)->ismale = 
X				(priest->data == &mons[PM_TEMPLE_PRIEST]);
X		Strcpy(EPRI(priest)->deitynam, a_gname_at(sx, sy));
X		priest->mtrapseen = ~0;	/* traps are known */
X		priest->mpeaceful = 1;
X		priest->ispriest = 1;
X		priest->msleep = 0;
X
X		/* now his/her goodies... */
X		(void) mongets(priest, CHAIN_MAIL);
X		(void) mongets(priest, SMALL_SHIELD);
X
X		/* Do NOT put the rest in m_initinv.    */
X		/* Priests created elsewhere than in a  */
X		/* temple should not carry these items, */
X		/* except for the mace.			*/
X#ifdef SPELLS
X		cnt = rn1(2,3);
X		while(cnt) {
X		    otmp = mkobj(SPBOOK_SYM, FALSE);
X		    if(otmp) mpickobj(priest, otmp);
X		    cnt--;
X		}
X#endif
X		if(p_coaligned(priest))
X		    (void) mongets(priest, rn2(2) ? CLOAK_OF_PROTECTION
X						  : CLOAK_OF_MAGIC_RESISTANCE);
X		else {
X		    if(!rn2(5)) 
X			otmp = mksobj(CLOAK_OF_MAGIC_RESISTANCE, FALSE); 
X		    else otmp = mksobj(CLOAK_OF_PROTECTION, FALSE); 
X		    if(otmp) {
X			if(!rn2(2)) curse(otmp);
X			mpickobj(priest, otmp);
X		    }
X		}
X
X		otmp = mksobj(MACE, FALSE);
X		if(otmp) {
X		    otmp->spe = rnd(3);
X		    if(!rn2(2)) curse(otmp);
X		    mpickobj(priest, otmp);
X		}
X	}
X}
X
Xchar *
Xpriestname(priest)
Xregister struct monst *priest;
X{
X	static char NEARDATA pname[PL_NSIZ];
X
X	Strcpy(pname, "the ");
X	if(priest->minvis) Strcat(pname, "invisible ");
X	if(priest->data != &mons[PM_TEMPLE_PRIEST] &&
X			priest->data != &mons[PM_TEMPLE_PRIESTESS]) {
X		Strcat(pname, priest->data->mname);
X		Strcat(pname, " ");
X	}
X	if(EPRI(priest)->ismale)
X		Strcat(pname, "priest of ");
X	else 	Strcat(pname, "priestess of ");
X	Strcat(pname, EPRI(priest)->deitynam);
X	return(pname);
X}
X
Xboolean
Xp_coaligned(priest)
Xstruct monst *priest;
X{
X	return(!strcmp(u_gname(), EPRI(priest)->deitynam));
X}
X
Xstatic int
Xt_alignment(troom)
Xstruct mkroom *troom;
X{
X	int x, y;
X
X	shrine_pos(&x,&y,troom);
X
X	if(IS_ALTAR(levl[x][y].typ) && (levl[x][y].altarmask & A_SHRINE) != 0)
X		return(levl[x][y].altarmask & ~A_SHRINE); 
X	return(-2); /* arbitrary non-alignment type value */
X}
X
Xstatic boolean
Xis_shrined(troom)
Xstruct mkroom *troom;
X{
X	int x, y;
X
X	shrine_pos(&x,&y,troom);
X
X	if(IS_ALTAR(levl[x][y].typ) && (levl[x][y].altarmask & A_SHRINE) != 0)
X		return(TRUE);
X	return(FALSE);
X}
X
Xstatic boolean
Xt_coaligned(troom)
Xstruct mkroom *troom;
X{
X	return(t_alignment(troom) == u.ualigntyp + 1);
X}
X
Xstruct monst *
Xfindpriest(troom)
Xstruct mkroom *troom;
X{
X	register struct monst *mtmp;
X	extern struct monst *fdmon; /* from mon.c */
X
X	for(mtmp = fmon; mtmp; mtmp = mtmp->nmon)
X	    if(mtmp->ispriest && histemple_at(mtmp,mtmp->mx,mtmp->my)
X			&& &rooms[EPRI(mtmp)->shroom] == troom)
X		return(mtmp);
X	for(mtmp = fdmon; mtmp; mtmp = mtmp->nmon)
X	    if(mtmp->ispriest && histemple_at(mtmp,mtmp->mx,mtmp->my)
X			&& &rooms[EPRI(mtmp)->shroom] == troom)
X		return(mtmp);
X	return (struct monst *)0;
X}
X
Xstatic boolean
Xp_inhistemple(troom)
Xstruct mkroom *troom;
X{
X	register struct monst *priest;
X
X	priest = findpriest(troom);
X	if(priest) return(TRUE);
X	return(FALSE);
X}
X
Xvoid
Xintemple() {
X	register struct mkroom *troom;
X
X	if(troom = in_temple(u.ux, u.uy)) {
X	    boolean shrined = is_shrined(troom);
X	    boolean tended = p_inhistemple(troom);
X
X	    if(!in_temple(u.ux0, u.uy0)) {
X		pline("Pilgrim, you enter a%s place!",
X			(!(shrined || tended) ? " desecrated and deserted" :
X			 !shrined ? " desecrated" :
X			 !tended ? "n untended sacred" :
X			  " sacred"));
X		if(!t_coaligned(troom) || u.ualign < -5 || !shrined || !tended)
X		    You("have a%s forbidding feeling...",
X				(!shrined || !tended) ? "" :
X				 " strange");
X		else You("experience a strange sense of peace.");
X	    } else if(!(shrined || tended) && !rn2(5)) {
X		switch(rn2(3)) {
X		    case 0: You("have an eerie feeling..."); break;
X		    case 1: You("feel like you are being watched."); break;
X		    default: pline("A shiver runs down your spine."); break;
X		}
X		if(!rn2(5)) {
X		    struct monst *mtmp;
X
X		    if(!(mtmp = makemon(&mons[PM_GHOST],u.ux,u.uy))) return;
X		    pline("An enormous ghost appears next to you!");
X		    mtmp->mpeaceful = 0;
X		    if(flags.verbose)
X		        You("are frightened to death, and unable to move.");
X		    nomul(-3);
X		    nomovemsg = "You regain your composure.";
X		}
X	    }
X	}
X}
X
Xvoid
Xpriest_talk(priest)
Xregister struct monst *priest;
X{
X	boolean coaligned = p_coaligned(priest);
X	boolean strayed = (u.ualign < 0);
X 
X	if(priest->mflee) {
X	    kludge("%s doesn't want anything to do with you!", 
X				Monnam(priest));
X	    priest->mtame = priest->mpeaceful = 0;
X	    return;
X	}
X
X	/* priests don't chat unless peaceful and in their own temple */
X	if(!histemple_at(priest,priest->mx,priest->my) || priest->mtame ||
X		 !priest->mpeaceful || !priest->mcanmove || priest->msleep) {
X            if(!priest->mcanmove || priest->msleep) {
X	        kludge("%s breaks out of his reverie!", Monnam(priest));
X                priest->mfrozen = priest->msleep = 0;
X		priest->mcanmove = 1;
X	    }
X	    /* The following is now impossible according to monst.c, */
X	    /* but it should stay just in case we change the latter. */
X	    if(priest->mtame)
X		kludge("%s breaks out of your taming spell!", Monnam(priest));
X	    priest->mtame = priest->mpeaceful = 0;
X	    switch(rn2(3)) {
X	        case 0: 
X		   verbalize("Thou wouldst have words, eh?  I'll give thee a word or two!"); 
X		   break;
X	        case 1: 
X		   verbalize("Talk?  Here is what I have to say!"); 
X		   break;
X	        default: 
X		   verbalize("Pilgrim, I have lost mine desire to talk.");
X		   break;
X	    }
X	    return;
X	}
X
X	/* he desecrated the temple and now he wants to chat? */
X	if(!is_shrined(&rooms[inroom(priest->mx, priest->my)])
X		&& priest->mpeaceful) {
X	    verbalize("Begone!  Thou desecratest this holy place with thy presence.");
X	    priest->mpeaceful = 0;
X	    return;
X	} 
X
X	if(!u.ugold) {
X	    if(coaligned && !strayed) {
X	        kludge("%s gives you two bits for an ale.", Monnam(priest));
X	        u.ugold = 2L;
X		if (priest->mgold) priest->mgold -= 2L;
X		flags.botl = 1;
X	    } else
X		kludge("%s is not interested.", Monnam(priest));
X	    return;
X	} else {
X	    long offer;
X
X	    kludge("%s asks you for a contribution for the temple.",
X			Monnam(priest));
X	    if((offer = bribe(priest)) == 0) {
X		verbalize("Thou shalt regret thine action!");
X		if(coaligned) u.ualign--;
X	    } else if(offer < (u.ulevel * 200)) {
X		if(u.ugold > (offer * 2L)) verbalize("Cheapskate.");
X		else {
X		    verbalize("I thank thee for thy contribution.");
X		    /*  give player some token  */
X		}
X	    } else if(offer < (u.ulevel * 400)) {
X		verbalize("Thou art indeed a pious individual.");
X		if(u.ugold < (offer * 2L)) { 
X		    if(coaligned && u.ualign < -5) u.ualign++;
X		    verbalize("I bestow upon thee a blessing.");
X		    Clairvoyant += rn1(500,500);
X		}
X	    } else if(offer < (u.ulevel * 600)) {
X		verbalize("Thy devotion has been rewarded.");
X		if (!(Protection & INTRINSIC))  {
X			Protection |= INTRINSIC;
X			if (!u.ublessed)  u.ublessed = rnd(3) + 1;
X		} else u.ublessed++;
X	    } else {
X		verbalize("Thy selfless generosity is deeply appreciated.");
X		if(u.ugold < (offer * 2L) && coaligned) {
X		    if(strayed && (moves - u.ucleansed) > 5000L) { 
X			u.ualign = 0; /* cleanse him */
X			u.ucleansed = moves;
X		    } else { 
X		        u.ualign += 2;
X		    }
X		}
X	    }
X	}
X}
X
Xboolean
Xu_in_sanctuary(troom) 
Xregister struct mkroom *troom;
X{
X	register struct mkroom *troom2;
X
X	troom2 = in_temple(u.ux, u.uy);
X
X	return(troom && troom2 && troom == troom2 && is_shrined(troom2) && 
X			t_coaligned(troom2) && u.ualign > -5);
X}
X
Xvoid
Xghod_hitsu() 	/* when attacking a priest in his temple */
X{
X	int x, y, ax, ay;
X	struct monst *priest;
X	struct mkroom *troom = in_temple(u.ux, u.uy);
X
X	if(!troom || !is_shrined(troom)) return;
X
X	/* shrine converted by human sacrifice */
X	if((priest = findpriest(troom)) && 
X	    strcmp(EPRI(priest)->deitynam,
X		a_gname_at(EPRI(priest)->shrpos.x, EPRI(priest)->shrpos.y))) 
X		    return;
X
X	shrine_pos(&x,&y,troom);
X	ax = x;
X	ay = y;
X
X	if((u.ux == x && u.uy == y) || !linedup(u.ux, u.uy, x, y)) {
X	    if(IS_DOOR(levl[u.ux][u.uy].typ)) {
X		if(u.ux == troom->lx - 1) {
X		    x = troom->hx;
X		    y = u.uy;
X		} else if(u.ux == troom->hx + 1) {
X		    x = troom->lx;
X		    y = u.uy;
X		} else if(u.uy == troom->ly - 1) {
X		    x = u.ux;
X		    y = troom->hy;
X		} else if(u.uy == troom->hy + 1) {
X		    x = u.ux;
X		    y = troom->ly;
X		}
X	    } else {
X		switch(rn2(4)) {
X		case 0:  x = u.ux; y = troom->ly; break;
X		case 1:  x = u.ux; y = troom->hy; break;
X		case 2:  x = troom->lx; y = u.uy; break;
X		default: x = troom->hx; y = u.uy; break;
X		}
X	    }
X	    if(!linedup(u.ux, u.uy, x, y)) return;
X	}
X
X	switch(rn2(3)) {
X	case 0: 
X	    pline("%s roars in anger:  \"Thou shalt suffer!\"", 
X			a_gname_at(ax, ay));
X	    break;
X	case 1: 
X	    pline("%s's voice booms:  \"How darest thou harm my servant!\"",
X			a_gname_at(ax, ay));
X	    break;
X	default: 
X	    pline("%s roars:  \"Thou dost profane my shrine!\"",
X			a_gname_at(ax, ay));
X	    break;
X	}
X
X	buzz(-15, 6, x, y, sgn(tbx), sgn(tby)); /* -15: bolt of lightning */
X}
X
Xvoid
Xangry_priest()
X{
X	register struct monst *priest;
X
X	if(!(priest = findpriest(in_temple(u.ux, u.uy)))) return;
X	wakeup(priest);
X}
X
X#endif /* OVLB */
X#endif /* ALTARS && THEOLOGY */
X
END_OF_FILE
if test 14545 -ne `wc -c <'src/priest.c'`; then
    echo shar: \"'src/priest.c'\" unpacked with wrong size!
fi
# end of 'src/priest.c'
fi
if test -f 'src/topten.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/topten.c'\"
else
echo shar: Extracting \"'src/topten.c'\" \(20400 characters\)
sed "s/^X//" >'src/topten.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)topten.c	3.0	89/12/31
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#define MONATTK_H	/* comment line for pre-compiled headers */
X#define MONFLAG_H	/* comment line for pre-compiled headers */
X/* block some unused #defines to avoid overloading some cpp's */
X#include "hack.h"
X
X#ifndef MACOS
X#include <errno.h>	/* George Barbanis */
X#else
Xextern short macflags;
Xextern WindowPtr	HackWindow;
X#endif
X
X#ifdef NO_FILE_LINKS
X#include <fcntl.h>	/* Ralf Brown */
X#endif
X#include <ctype.h>
X
X#ifdef NO_SCAN_BRACK
Xstatic void FDECL(nsb_mung_line,(char*));
Xstatic void FDECL(nsb_unmung_line,(char*));
X#endif
X
X#define newttentry() (struct toptenentry *) alloc(sizeof(struct toptenentry))
X#define	NAMSZ	10
X#define	DTHSZ	60
X#define	PERSMAX	 3		/* entries per name/uid per char. allowed */
X#define	POINTSMIN	1	/* must be > 0 */
X#define	ENTRYMAX	100	/* must be >= 10 */
X
X#ifndef MSDOS
X#define	PERS_IS_UID		/* delete for PERSMAX per name; now per uid */
X#endif
Xstruct toptenentry {
X	struct toptenentry *tt_next;
X	long int points;
X	int level,maxlvl,hp,maxhp;
X	int uid;
X	char plchar;
X	char sex;
X	char name[NAMSZ+1];
X	char death[DTHSZ+1];
X	char date[7];		/* yymmdd */
X} *tt_head;
X
Xstatic char *FDECL(itoa, (int));
Xstatic const char *FDECL(ordin, (int));
Xstatic void NDECL(outheader);
Xstatic int FDECL(outentry, (int,struct toptenentry *,int));
Xstatic void FDECL(readentry, (FILE *,struct toptenentry *));
Xstatic void FDECL(writeentry, (FILE *,struct toptenentry *));
Xstatic int FDECL(classmon, (CHAR_P,BOOLEAN_P));
Xstatic boolean FDECL(onlyspace, (const char *));
X
X/* must fit with end.c */
Xstatic const char NEARDATA *killed_by_prefix[] = {
X	"killed by ", "choked on ", "poisoned by ", "", "drowned in ",
X	"", "crushed to death by ", "petrified by ", "",
X	"", "",
X	"", "", "" };
X
Xstatic void
Xreadentry(rfile,tt)
XFILE *rfile;
Xstruct toptenentry *tt;
X{
X# ifdef NO_SCAN_BRACK
X	if(fscanf(rfile,"%6s %d %d %d %d %d %ld%*c%c%c %s %s",
X#  define TTFIELDS 12
X# else
X	if(fscanf(rfile, "%6s %d %d %d %d %d %ld %c%c %[^,],%[^\n]",
X#  define TTFIELDS 11
X# endif
X		tt->date, &tt->uid,
X		&tt->level,
X		&tt->maxlvl, &tt->hp, &tt->maxhp, &tt->points,
X		&tt->plchar, &tt->sex,
X#ifdef LATTICE	/* return value is broken also, sigh */
X		tt->name, tt->death) < 1)
X#else
X		tt->name, tt->death) != TTFIELDS)
X#endif
X#undef TTFIELDS
X			tt->points = 0;
X#ifdef NO_SCAN_BRACK
X	if(tt->points > 0) {
X		nsb_unmung_line(tt->name);
X		nsb_unmung_line(tt->death);
X	}
X#endif
X}
X
Xstatic void
Xwriteentry(rfile,tt)
XFILE *rfile;
Xstruct toptenentry *tt;
X{
X#ifdef NO_SCAN_BRACK
X	nsb_mung_line(tt->name);
X	nsb_mung_line(tt->death);
X#endif
X# ifdef NO_SCAN_BRACK
X	(void) fprintf(rfile,"%6s %d %d %d %d %d %ld %c%c %s %s\n",
X# else
X	(void) fprintf(rfile,"%6s %d %d %d %d %d %ld %c%c %s,%s\n",
X# endif
X		tt->date, tt->uid,
X		tt->level,
X		tt->maxlvl, tt->hp, tt->maxhp, tt->points,
X		tt->plchar, tt->sex,
X		onlyspace(tt->name) ? "_" : tt->name, tt->death);
X#ifdef NO_SCAN_BRACK
X	nsb_unmung_line(tt->name);
X	nsb_unmung_line(tt->death);
X#endif
X}
X
Xstatic boolean
Xonlyspace(s)
Xconst char *s;
X{
X	for (;*s;s++) if (!isspace(*s)) return(FALSE);
X	return(TRUE);
X}
X
Xvoid
Xtopten(how)
Xint how;
X{
X	int uid = getuid();
X	int rank, rank0 = -1, rank1 = 0;
X	int occ_cnt = PERSMAX;
X	register struct toptenentry *t0, *tprev;
X	register struct toptenentry *t1;
X#ifdef UNIX
X	char *reclock = "record_lock";
X# ifdef NO_FILE_LINKS
X	int lockfd ;
X# endif
X#endif /* UNIX */
X#ifdef VMS
X	char *reclock = "record_lock;1";
X	char recfile[] = RECORD;
X#else
X	const char *recfile = RECORD;
X#endif
X#if defined(UNIX) || defined(VMS)
X	int sleepct = 100;
X#endif
X	FILE *rfile;
X	register int flg = 0;
X#ifdef LOGFILE
X	char *lgfile = LOGFILE;
X	FILE *lfile;
X# ifdef UNIX
X	char *loglock = "logfile_lock";
X# endif /* UNIX */
X# ifdef VMS
X	char *loglock = "logfile_lock;1";
X# endif /* VMS */
X# if defined(UNIX) || defined(VMS)
X	int sleeplgct = 30;
X# endif /* UNIX or VMS */
X#endif /* LOGFILE */
X
X#if defined(MSDOS) || defined(MACOS)
X#define HUP
X#else
X#define	HUP	if(!done_hup)
X#endif
X#ifdef MACOS
X	macflags &= ~fDoUpdate;
X	uid = TickCount();
X#endif
X	/* create a new 'topten' entry */
X	t0 = newttentry();
X	t0->level = dlevel;
X	t0->maxlvl = maxdlevel;
X	t0->hp = u.uhp;
X	t0->maxhp = u.uhpmax;
X	t0->points = u.urexp;
X	t0->plchar = pl_character[0];
X	t0->sex = (flags.female ? 'F' : 'M');
X	t0->uid = uid;
X	(void) strncpy(t0->name, plname, NAMSZ);
X	(t0->name)[NAMSZ] = 0;
X	(t0->death)[0] = 0;
X	switch (killer_format) {
X		default: impossible("bad killer format?");
X		case KILLED_BY_AN:
X			Strcat(t0->death, killed_by_prefix[how]),
X			(void) strncat(t0->death, an(killer), DTHSZ);
X			break;
X		case KILLED_BY:
X			Strcat(t0->death, killed_by_prefix[how]),
X			(void) strncat(t0->death, killer, DTHSZ);
X			break;
X		case NO_KILLER_PREFIX:
X			(void) strncat(t0->death, killer, DTHSZ);
X			break;
X	}
X	Strcpy(t0->date, getdate());
X
X#ifdef LOGFILE		/* used for debugging (who dies of what, where) */
X# if defined(UNIX) || defined(VMS)
X#  ifdef NO_FILE_LINKS
X	loglock = (char *)alloc(sizeof(LOCKDIR)+1+strlen(lgfile)+6);
X	Strcpy(loglock,LOCKDIR) ;
X	Strcat(loglock,"/") ;
X	Strcat(loglock,lgfile) ;
X	Strcat(loglock,"_lock") ;
X	while ((lockfd = open(loglock,O_RDWR|O_CREAT|O_EXCL,0666)) == -1) {
X#  else
X	while(link(lgfile, loglock) == -1) {
X#  endif /* NO_FILE_LINKS */
X		extern int errno;
X
X		if (errno == ENOENT) /* If no such file, do not keep log */
X			goto lgend;  /* George Barbanis */
X		HUP perror(loglock);
X		if(!sleeplgct--) {
X			HUP (void) puts("I give up.  Sorry.");
X			HUP (void) puts("Perhaps there is an old logfile_lock around?");
X			goto lgend;
X		}
X		HUP Printf("Waiting for access to log file. (%d)\n",
X 			sleeplgct);
X		HUP (void) fflush(stdout);
X#  if defined(SYSV) || defined(ULTRIX) || defined(VMS)
X		(void)
X#  endif
X		    sleep(1);
X	}
X# endif /* UNIX or VMS */
X	if(!(lfile = fopen(lgfile,"a"))){
X		HUP (void) puts("Cannot open log file!");
X		goto lgend;
X	}
X	writeentry(lfile, t0);
X	(void) fclose(lfile);
X# if defined(UNIX) || defined(VMS)
X	(void) unlink(loglock);
X# endif /* UNIX or VMS */
X      lgend:;
X# ifdef NO_FILE_LINKS
X	(void) close(lockfd) ;
X# endif
X# if defined(WIZARD) || defined(EXPLORE_MODE)
X	if (wizard || discover) {
X Printf("\nSince you were in %s mode, the score list will not be checked.\n",
X	wizard ? "wizard" : "discover");
X		return;
X	}
X# endif
X#endif /* LOGFILE */
X
X#if defined(UNIX) || defined(VMS)
X# ifdef NO_FILE_LINKS
X	reclock = (char *)alloc(sizeof(LOCKDIR)+1+strlen(recfile)+7);
X	Strcpy(reclock,LOCKDIR) ;
X	Strcat(reclock,"/") ;
X	Strcat(reclock,recfile) ;
X	Strcat(reclock,"_lock") ;
X	while ((lockfd = open(reclock,O_RDWR|O_CREAT|O_EXCL,0666)) == -1) {
X# else
X	while(link(recfile, reclock) == -1) {
X# endif /* NO_FILE_LINKS */
X		HUP perror(reclock);
X		if(!sleepct--) {
X			HUP (void) puts("I give up.  Sorry.");
X			HUP (void) puts("Perhaps there is an old record_lock around?");
X			return;
X		}
X		HUP Printf("Waiting for access to record file. (%d)\n",
X			sleepct);
X		HUP (void) fflush(stdout);
X# if defined(SYSV) || defined(ULTRIX) || defined(VMS)
X		(void)
X# endif
X		    sleep(1);
X	}
X#endif /* UNIX or VMS */
X#ifdef MACOS
X	{
X		term_info	*t;
X		
X		t = (term_info *)GetWRefCon(HackWindow);
X		SetVol((StringPtr)0L, t->recordVRefNum);
X		if (!(rfile = fopen(recfile,"r"))) {
X			short	i;
X	
X			rfile = openFile(recfile,"r");
X		}
X	}
X
X	if (!rfile) {
X#else
X	if(!(rfile = fopen(recfile,"r"))){
X#endif
X		HUP (void) puts("Cannot open record file!");
X		goto unlock;
X	}
X#ifdef NO_FILE_LINKS
X	(void) close(lockfd) ;
X#endif
X	HUP (void) putchar('\n');
X
X	/* assure minimum number of points */
X	if(t0->points < POINTSMIN) t0->points = 0;
X
X	t1 = tt_head = newttentry();
X	tprev = 0;
X	/* rank0: -1 undefined, 0 not_on_list, n n_th on list */
X	for(rank = 1; ; ) {
X	    readentry(rfile, t1);
X	    if (t1->points < POINTSMIN) t1->points = 0;
X	    if(rank0 < 0 && t1->points < t0->points) {
X		rank0 = rank++;
X		if(tprev == 0)
X			tt_head = t0;
X		else
X			tprev->tt_next = t0;
X		t0->tt_next = t1;
X		occ_cnt--;
X		flg++;		/* ask for a rewrite */
X	    } else tprev = t1;
X
X	    if(t1->points == 0) break;
X	    if(
X#ifdef PERS_IS_UID
X		t1->uid == t0->uid &&
X#else
X		strncmp(t1->name, t0->name, NAMSZ) == 0 &&
X#endif
X		t1->plchar == t0->plchar && --occ_cnt <= 0) {
X		    if(rank0 < 0) {
X			rank0 = 0;
X			rank1 = rank;
X	HUP Printf("You didn't beat your previous score of %ld points.\n\n",
X				t1->points);
X		    }
X		    if(occ_cnt < 0) {
X			flg++;
X			continue;
X		    }
X		}
X	    if(rank <= ENTRYMAX) {
X		t1 = t1->tt_next = newttentry();
X		rank++;
X	    }
X	    if(rank > ENTRYMAX) {
X		t1->points = 0;
X		break;
X	    }
X	}
X	if(flg) {	/* rewrite record file */
X		(void) fclose(rfile);
X#ifdef VMS
X		{
X			char *sem = rindex(recfile, ';');
X
X			if (sem)
X				*sem = '\0';
X		}
X#endif
X		if(!(rfile = fopen(recfile,"w"))){
X			HUP (void) puts("Cannot write record file\n");
X			goto unlock;
X		}
X
X		if(!done_stopprint) if(rank0 > 0){
X		    if(rank0 <= 10)
X			(void) puts("You made the top ten list!\n");
X		    else
X		Printf("You reached the %d%s place on the top %d list.\n\n",
X			rank0, ordin(rank0), ENTRYMAX);
X		}
X	}
X	if(rank0 == 0) rank0 = rank1;
X	if(rank0 <= 0) rank0 = rank;
X	if(!done_stopprint) outheader();
X	t1 = tt_head;
X	for(rank = 1; t1->points != 0; rank++, t1 = t1->tt_next) {
X	    if(flg) writeentry(rfile, t1);
X	    if(done_stopprint) continue;
X	    if(rank > flags.end_top &&
X	      (rank < rank0-flags.end_around || rank > rank0+flags.end_around)
X	      && (!flags.end_own ||
X#ifdef PERS_IS_UID
X				  t1->uid != t0->uid
X#else
X				  strncmp(t1->name, t0->name, NAMSZ)
X#endif
X		)) continue;
X	    if(rank == rank0-flags.end_around &&
X	       rank0 > flags.end_top+flags.end_around+1 &&
X	       !flags.end_own)
X		(void) putchar('\n');
X	    if(rank != rank0)
X		(void) outentry(rank, t1, 0);
X	    else if(!rank1)
X		(void) outentry(rank, t1, 1);
X	    else {
X		int t0lth = outentry(0, t0, -1);
X		int t1lth = outentry(rank, t1, t0lth);
X		if(t1lth > t0lth) t0lth = t1lth;
X		(void) outentry(0, t0, t0lth);
X	    }
X	}
X	if(rank0 >= rank) if(!done_stopprint)
X		(void) outentry(0, t0, 1);
X	(void) fclose(rfile);
X#ifdef MACOS
X	{
X		Str255	name;
X		FInfo	fndrInfo;
X		term_info	*t;
X		short	oldVol, error;
X		
X		t = (term_info *)GetWRefCon(HackWindow);
X		GetVol(name, &oldVol);
X		SetVol(0L, t->recordVRefNum);
X		Strcpy((char *)name,recfile);
X		CtoPstr((char *)name);
X		error = GetFInfo(name, (short)0, &fndrInfo);
X		fndrInfo.fdCreator = CREATOR;
X		if (error == noErr)
X			SetFInfo(name, (short)0, &fndrInfo);
X		SetVol(0L, oldVol);
X	}
X#endif
X#ifdef VMS
X	if (flg) {
X		delete(RECORD);
X		rename(recfile, RECORD);
X	}
X# undef unlink
X#endif
Xunlock:	;
X#if defined(UNIX) || defined(VMS)
X# ifdef NO_FILE_LINKS
X	(void) close(lockfd) ;
X# endif
X	if (unlink(reclock) < 0)
X		Printf("Can't unlink %s\n",reclock) ;
X#endif
X}
X
Xstatic void
Xoutheader() {
X	char linebuf[BUFSZ];
X	register char *bp;
X
X	Strcpy(linebuf, " No  Points     Name");
X	bp = eos(linebuf);
X	while(bp < linebuf + COLNO - 9) *bp++ = ' ';
X	Strcpy(bp, "Hp [max]");
X	(void) puts(linebuf);
X#ifdef MACOS
X	putchar('\n');
X#endif
X}
X
X/* so>0: standout line; so=0: ordinary line; so<0: no output, return lth */
Xstatic int
Xoutentry(rank, t1, so)
Xregister struct toptenentry *t1;
Xregister int rank, so;
X{
X	register boolean second_line = TRUE;
X	char linebuf[BUFSZ], linebuf2[BUFSZ];
X
X	linebuf[0] = linebuf2[0] = 0;
X	if(rank) Sprintf(eos(linebuf), " %2d", rank);
X	else Strcat(linebuf, "   ");
X
X	Sprintf(eos(linebuf), " %10ld  %.10s", t1->points, t1->name);
X	Sprintf(eos(linebuf), "-%c ", t1->plchar);
X	if(!strncmp("escaped", t1->death, 7)) {
X	  second_line = FALSE;
X	  if(!strcmp(" (with the Amulet)", t1->death+7))
X	    Strcat(linebuf, "escaped the dungeon with the Amulet");
X	  else
X	    Sprintf(eos(linebuf), "escaped the dungeon [max level %d]",
X	      t1->maxlvl);
X#ifdef ENDGAME
X	} else if(!strncmp("ascended", t1->death, 8)) {
X	   Strcat(linebuf, "ascended to demigod");
X	   if (t1->sex == 'F') Strcat(linebuf, "dess");
X	   Strcat(linebuf, "-hood");
X	   second_line = FALSE;
X#endif
X	} else {
X	  if(!strncmp(t1->death,"quit",4)) {
X		Strcat(linebuf, "quit");
X		second_line = FALSE;
X	  } else if(!strncmp(t1->death,"starv",5)) {
X		Strcat(linebuf, "starved to death");
X		second_line = FALSE;
X	  } else if(!strncmp(t1->death,"choked",6)) {
X		Sprintf(eos(linebuf), "choked on h%s food",
X			(t1->sex == 'F') ? "er" : "is");
X	  } else if(!strncmp(t1->death,"poisoned",8)) {
X		Strcat(linebuf, "was poisoned");
X	  } else if(!strncmp(t1->death,"crushed",7)) {
X		Strcat(linebuf, "was crushed to death");
X	  } else if(!strncmp(t1->death, "petrified by ",13)) {
X		Strcat(linebuf, "turned to stone");
X	  } else Strcat(linebuf, "died");
X#ifdef ENDLEVEL
X	  if (t1->level == ENDLEVEL)
X		Strcat(linebuf, " in the endgame");
X	  else
X#endif
X	    Sprintf(eos(linebuf), " on dungeon level %d", t1->level);
X	  if(t1->maxlvl != t1->level)
X	    Sprintf(eos(linebuf), " [max %d]", t1->maxlvl);
X	/* kludge for "quit while already on Charon's boat" */
X	  if(!strncmp(t1->death, "quit ", 5))
X	    Strcat(linebuf, t1->death + 4);
X	}
X	Strcat(linebuf, ".");
X
X	if(t1->maxhp) {
X	  register char *bp = eos(linebuf);
X	  char hpbuf[10];
X	  int hppos;
X	  int lngr = strlen(linebuf);
X	  Strcpy(hpbuf, (t1->hp > 0) ? itoa(t1->hp) : "-");
X	  hppos = COLNO - 7 - strlen(hpbuf);
X	  if (lngr >= hppos) hppos = (2*COLNO) - 7 - strlen(hpbuf);
X	  if(bp <= linebuf + hppos) {
X	    /* pad any necessary blanks to the hit point entry */
X#ifdef MACOS
X	    while(bp <= linebuf + hppos) *bp++ = ' ';
X#else
X	    while(bp < linebuf + hppos) *bp++ = ' ';
X#endif
X	    Strcpy(bp, hpbuf);
X	    if(t1->maxhp < 10)
X		 Sprintf(eos(bp), "   [%d]", t1->maxhp);
X	    else if(t1->maxhp < 100)
X		 Sprintf(eos(bp), "  [%d]", t1->maxhp);
X	    else Sprintf(eos(bp), " [%d]", t1->maxhp);
X	  }
X	}
X
X/*	Line 2 now contains the killer name */
X
X	/* Quit, starved, ascended, and escaped contain no second line */
X	if (second_line) {
X		Strcpy(linebuf2, t1->death);
X		if (islower(*linebuf2)) *linebuf2 = toupper(*linebuf2);
X		Strcat(linebuf2, ".");
X	}
X
X	if(so == 0) {
X	  (void) puts(linebuf);
X	  if (second_line)
X		(void) Printf("                %s\n", linebuf2);
X	} else if(so > 0) {
X	  register char *bp = eos(linebuf);
X	  if(so >= COLNO) so = COLNO-1;
X	  while(bp < linebuf + so) *bp++ = ' ';
X	  *bp = 0;
X	  standoutbeg();
X	  (void) puts(linebuf);
X	  if(second_line)
X		(void) Printf("                %s", linebuf2);
X	  standoutend();
X	  if(second_line)
X		(void) putchar('\n');
X	}
X	return(strlen(linebuf)+strlen(linebuf2));
X}
X
Xstatic char *
Xitoa(a) int a; {
X#ifdef LINT	/* static char buf[12]; */
Xchar buf[12];
X#else
Xstatic char buf[12];
X#endif
X	Sprintf(buf,"%d",a);
X	return(buf);
X}
X
Xstatic const char *
Xordin(n)
Xint n; {
X	register int dd = n%10;
X
X#if ENTRYMAX > 110
X	return((dd==0 || dd>3 || (n/10)%10==1) ? "th" :
X#else
X	return((dd==0 || dd>3 || n/10==1) ? "th" :
X#endif
X	       (dd==1) ? "st" : (dd==2) ? "nd" : "rd");
X}
X
X/*
X * Called with args from main if argc >= 0. In this case, list scores as
X * requested. Otherwise, find scores for the current player (and list them
X * if argc == -1).
X */
Xvoid
Xprscore(argc,argv)
Xint argc;
Xchar **argv;
X{
X	const char **players;
X	int playerct;
X	int rank;
X	register struct toptenentry *t1, *t2;
X	const char *recfile = RECORD;
X	FILE *rfile;
X	register int flg = 0, i;
X#ifdef nonsense
X	long total_score = 0L;
X	char totchars[10];
X	int totcharct = 0;
X#endif
X	int outflg = (argc >= -1);
X#ifdef PERS_IS_UID
X	int uid = -1;
X#else
X	const char *player0;
X#endif
X#ifdef MACOS
X	if(!(rfile = fopen(recfile,"r")))
X		rfile = openFile(recfile,"r");
X	if (!rfile) {
X#else
X	if(!(rfile = fopen(recfile,"r"))){
X#endif
X		(void) puts("Cannot open record file!");
X		return;
X	}
X
X	if(argc > 1 && !strncmp(argv[1], "-s", 2)){
X		if(!argv[1][2]){
X			argc--;
X			argv++;
X		} else if(!argv[1][3] && index(pl_classes, argv[1][2])) {
X			argv[1]++;
X			argv[1][0] = '-';
X		} else	argv[1] += 2;
X	}
X	if(argc <= 1){
X#ifdef PERS_IS_UID
X		uid = getuid();
X		playerct = 0;
X#else
X		player0 = plname;
X		if(!*player0)
X			player0 = "hackplayer";
X		playerct = 1;
X		players = &player0;
X#endif
X	} else {
X		playerct = --argc;
X		players = (const char **)++argv;
X	}
X	if(outflg) (void) putchar('\n');
X
X	t1 = tt_head = newttentry();
X	for(rank = 1; ; rank++) {
X	    readentry(rfile, t1);
X	    if(t1->points == 0) break;
X#ifdef PERS_IS_UID
X	    if(!playerct && t1->uid == uid)
X		flg++;
X	    else
X#endif
X	    for(i = 0; i < playerct; i++){
X		if(strcmp(players[i], "all") == 0 ||
X		   strncmp(t1->name, players[i], NAMSZ) == 0 ||
X		  (players[i][0] == '-' &&
X		   players[i][1] == t1->plchar &&
X		   players[i][2] == 0) ||
X		  (digit(players[i][0]) && rank <= atoi(players[i])))
X			flg++;
X	    }
X	    t1 = t1->tt_next = newttentry();
X	}
X	(void) fclose(rfile);
X	if(!flg) {
X	    if(outflg) {
X		Printf("Cannot find any entries for ");
X		if(playerct < 1) Printf("you.\n");
X		else {
X		  if(playerct > 1) Printf("any of ");
X		  for(i=0; i<playerct; i++)
X			Printf("%s%s", players[i], (i<playerct-1)?", ":".\n");
X		  Printf("Call is: %s -s [-role] [maxrank] [playernames]\n", hname);
X		}
X	    }
X	    return;
X	}
X
X	if(outflg) outheader();
X	t1 = tt_head;
X	for(rank = 1; t1->points != 0; rank++, t1 = t2) {
X		t2 = t1->tt_next;
X#ifdef PERS_IS_UID
X		if(!playerct && t1->uid == uid)
X			goto outwithit;
X		else
X#endif
X		for(i = 0; i < playerct; i++){
X			if(strcmp(players[i], "all") == 0 ||
X			   strncmp(t1->name, players[i], NAMSZ) == 0 ||
X			  (players[i][0] == '-' &&
X			   players[i][1] == t1->plchar &&
X			   players[i][2] == 0) ||
X			  (digit(players[i][0]) && rank <= atoi(players[i]))){
X#ifdef PERS_IS_UID
X			outwithit:
X#endif
X				if(outflg)
X				    (void) outentry(rank, t1, 0);
X#ifdef nonsense
X				total_score += t1->points;
X				if(totcharct < sizeof(totchars)-1)
X				    totchars[totcharct++] = t1->plchar;
X#endif
X				break;
X			}
X		}
X		free((genericptr_t) t1);
X	}
X#ifdef nonsense
X	totchars[totcharct] = 0;
X
X	/* We would like to determine whether he is experienced. However,
X	   the information collected here only tells about the scores/roles
X	   that got into the topten (top 100?). We should maintain a
X	   .hacklog or something in his home directory. */
X	flags.beginner = (total_score < 6000);
X	for(i=0; i<6; i++)
X	    if(!index(totchars, pl_classes[i])) {
X		flags.beginner = 1;
X		if(!pl_character[0]) pl_character[0] = pl_classes[i];
X		break;
X	}
X#endif /* nonsense /**/
X#ifdef MACOS
X	more();
X#endif
X}
X
Xstatic int
Xclassmon(plch, fem)
Xchar plch;
Xboolean fem;
X{
X	switch (plch) {
X		case 'A': return PM_ARCHEOLOGIST;
X		case 'B': return PM_BARBARIAN;
X		case 'C': return (fem ? PM_CAVEWOMAN : PM_CAVEMAN);
X		case 'E': return PM_ELF;
X		case 'H': return PM_HEALER;
X		case 'F':	/* accept old Fighter class */
X		case 'K': return PM_KNIGHT;
X		case 'P': return (fem ? PM_PRIESTESS : PM_PRIEST);
X		case 'R': return PM_ROGUE;
X		case 'N':	/* accept old Ninja class */
X		case 'S': return PM_SAMURAI;
X		case 'T': return PM_TOURIST;
X		case 'V': return PM_VALKYRIE;
X		case 'W': return PM_WIZARD;
X		default: impossible("What weird class is this? (%c)", plch);
X			return PM_HUMAN_ZOMBIE;
X	}
X}
X
X/*
X * Get a random player name and class from the high score list,
X * and attach them to an object (for statues or morgue corpses).
X */
Xstruct obj *
Xtt_oname(otmp)
Xstruct obj *otmp;
X{
X	int rank;
X	register int i;
X	register struct toptenentry *tt;
X	const char *recfile = RECORD;
X	FILE *rfile;
X
X	if (!otmp) return((struct obj *) 0);
X
X#ifdef MACOS
X	if(!(rfile = fopen(recfile,"r")))
X		rfile = openFile(recfile, "r");
X	if (!rfile) {
X#else
X	if(!(rfile = fopen(recfile,"r"))){
X#endif
X		panic("Cannot open record file!");
X	}
X
X	tt = newttentry();
X	rank = rnd(10);
Xpickentry:
X	for(i = rank; i; i--) {
X	    readentry(rfile, tt);
X	    if(tt->points == 0) break;
X	}
X
X	if(tt->points == 0) {
X		if(rank > 1) {
X			rank = 1;
X			goto pickentry;
X		}
X		free((genericptr_t) tt);
X		otmp = (struct obj *) 0;
X	} else {
X		otmp->corpsenm = classmon(tt->plchar, (tt->sex == 'F'));
X		otmp->owt = weight(otmp);
X		/* Note: oname() is safe since otmp is first in chains */
X		otmp = oname(otmp, tt->name, 0);
X		fobj = otmp;
X		level.objects[otmp->ox][otmp->oy] = otmp;
X		free((genericptr_t) tt);
X	}
X
X	(void) fclose(rfile);
X	return otmp;
X}
X
X#ifdef NO_SCAN_BRACK
X/* Lattice scanf isn't up to reading the scorefile.  What */
X/* follows deals with that; I admit it's ugly. (KL) */
X/* Now generally available (KL) */
Xstatic void nsb_mung_line(p)
X	char *p;
X	{
X	while(p=strchr(p,' '))*p='|';
X}
Xstatic void nsb_unmung_line(p)
X	char *p;
X	{
X	while(p=strchr(p,'|'))*p=' ';
X}
X#endif
END_OF_FILE
if test 20400 -ne `wc -c <'src/topten.c'`; then
    echo shar: \"'src/topten.c'\" unpacked with wrong size!
fi
# end of 'src/topten.c'
fi
echo shar: End of archive 36 \(of 56\).
cp /dev/null ark36isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 56 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
