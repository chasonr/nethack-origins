Path: utzoo!attcan!uunet!wuarchive!mailrus!cornell!uw-beaver!zephyr.ens.tek.com!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v10i080:  nethack3p9 -  display oriented dungeons & dragons (Ver. 3.0i), Part35/56
Message-ID: <5938@tekred.CNA.TEK.COM>
Date: 12 Jul 90 16:08:14 GMT
Sender: news@tekred.CNA.TEK.COM
Lines: 2222
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 10, Issue 80
Archive-name: nethack3p9/Part35
Supersedes: NetHack3: Volume 7, Issue 56-93



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 35 (of 56)."
# Contents:  amiga/Makefile.ami src/hack.c src/wield.c
# Wrapped by billr@saab on Wed Jul 11 17:11:44 1990
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'amiga/Makefile.ami' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'amiga/Makefile.ami'\"
else
echo shar: Extracting \"'amiga/Makefile.ami'\" \(21416 characters\)
sed "s/^X//" >'amiga/Makefile.ami' <<'END_OF_FILE'
X#	Hack Makefile.
X#	SCCS Id: @(#)Makefile.ami	3.0	90/02/13
X
X# This makefile is arranged for compiling for the Amiga with Lattice C but
X# can be configured for compiling with Manx C 3.6 with simple changes.
X# The appropriate changes are identified by #[LATTICE] and #[MANX3.6] in
X# this makefile as should be set according to the compiler being used.
X
X# The following assignments should be made before using this makefile:
X#
X#   HackExe:	directory where final executable should go
X#   NetHack:	directory where other runtime support files should go
X#   Amiga:	"amiga" directory
X#   Auxil:	"auxil" directory
X#   Incl:	"include" directory
X#   Others:	"others" directory
X#   Src1:	"src" directory (a* through l*)
X#   Src2:	"src" directory (m* through po*)
X#   Src3:	"src" directory (pr* through z*)
X#   O_Amiga:	destination for object files from Amiga:
X#   O_Others:	destination for object files from Others:
X#   O_Src1:	destination for object files from Src1:
X#   O_Src2:	destination for object files from Src2:
X#   O_Src3:	destination for object files from Src3:
X#
X# Startup makefile with:
X#
X#[LATTICE]
X#	cd NetHack:
X#	lmk -f Amiga:Makefile.ami
X#
X#[MANX3.6]
X#	cd NetHack:
X#	make -f Amiga:Makefile.ami
X#
X# May use following targets on lmk/make command line:
X#   all		do it all (default)
X#   link	just create $(GAME) from object files
X#   obj1	just create O_Src1 object files
X#   obj2	just create O_Src2 object files
X#   obj3	just create O_Src3 object files
X#   obja	just create O_Amiga object files
X#   objo	just create O_Others object files
X#   clean	deletes the object files
X#   spotless	deletes the object files, $(GAME), and more
X#
X
X# Precompiled header file:
X#   $(HDEP) should appear in any dependency list for an object file where
X#   we would want to make use of the precompiled version of Incl:hack.h,
X#   while $(CSYM) should appear in the C compiler command line that creates
X#   any such object file.  (Changes made here should agree with the $(HDEP):
X#   target that appears later in this makefile.)
X#
X#   Notice that since this file would be created on Ram: that we would
X#   end up recompiling everything if we followed the normal make sequence.
X#   Thus, we could use:
X#
X#[LATTICE]
X#	cd NetHack:
X#	lmk -f Amiga:Makefile.ami Ram:hack.sym
X#	setdate Ram:hack.sym {date & time of Incl:hack.h}
X#	lmk -f Amiga:Makefile.ami
X#
X#[MANX3.6]
X#	cd NetHack:
X#	make -f Amiga:Makefile.ami Ram:hack.sym
X#	setdate Ram:hack.sym {date & time of Incl:hack.h}
X#	make -f Amiga:Makefile.ami
X
X#[LATTICE]
X#   If we were to use the precompiled header file feature, we would uncomment
X#   these following two lines.  However, there are still problems in the
X#   behavior of this feature in version 5.04, so these lines are commented
X#   out for now.
X
X#HDEP	= Ram:hack.sym
X#CSYM	= -HRam:hack.sym
X
X#[LATTICE]
X#   If we were to use the precompiled header file feature in a newer version
X#   of Lattice, we would comment out these following two lines.
X
XHDEP	= Incl:hack.h
XCSYM	=
X
X#[MANX3.6]
X#   If we were compiling with Aztec 3.6 and wanted to use the symbol table
X#   pre-loading feature, we would uncomment these following two lines.
X
X#HDEP	= Ram:hack.sym
X#CSYM	= +IRam:hack.sym
X
X
X# Pathname for (optional) uudecode program:
X#   If uudecode is available for use by this makefile, give its name below.
X#   Use a harmless command (like echo) otherwise.
X
XUUDEC	= echo
X#UUDEC	= uudecode
X
X
X# Pathname for the C compiler being used.
X
X#[LATTICE]
X
XCC	= lc
X
X#[MANX3.6]
X
X#CC	= cc
X
X
X# Compilation flags for selected C Compiler:
X#   $(CFLAGS) should appear before filename arguments of $(CC) command line.
X
X#[LATTICE]
X#   Note: do not use -ms with Lattice 5.04 (Others:lev_lex.c fails)
X#   Note: make sure your CLI stack size is large or lev_comp and makedefs
X#	may fail terribly - stack checking is disabled.
XCFLAGS	= -b0 -cfi -d1 -iIncl: -ma -v
X
X#[MANX3.6]
X
X#CFLAGS	= +c +d -e300 -z8000 +q -iIncl:
X
X
X# Components of varous link command lines:
X#   $(LINK) should be the pathname of the linker being used (with any options
X#   that should appear at the beginning of the command line).  The name of the
X#   output file should appear immediately after $(LINK).  $(LIN) should appear
X#   before the list of object files in each link command.  $(LLINK) should
X#   appear as the list of object files in the link command line that creates
X#   the NetHack executable.  $(LLIB) should appear at the end of each link
X#   command line.
X
X#[LATTICE]
X
XLINK	= Blink to
XLIN	= from Lib:catch.o
XLLINK	= with Amiga:ami.lnk
XLLIB	= lib Lib:lc.lib BATCH
X
X#[MANX3.6]
X
X#LINK	= ln +q +ss -o
X#LIN	=
X#LLINK	= -f Amiga:ami.lnk
X#LLIB	= -lcl
X
X
X# Name of the game:
X
XGAME	= HackExe:NetHack
X
X
X# A more reasonable random number generator (recommended for the Amiga):
X
XRANDOBJ	= O_Others:random.o
X
X
X.PRECIOUS:  Incl:config.h Incl:decl.h Incl:hack.h Incl:permonst.h Incl:you.h
X
X
X# Almost nothing below this line should have to be changed.
X# (Exceptions are marked by [LATTICE] and [MANX3.6].)
X#
X# Other things that have to be reconfigured are in config.h,
X# (amiconf.h, pcconf.h), and possibly system.h, tradstdc.h.
X
X
X# HSRC1 = \
X#	Src1:allmain.c		Src1:alloc.c		Src1:apply.c \
X#	Src1:artifact.c		Src1:attrib.c		Src1:bones.c \
X#	Src1:cmd.c		Src1:dbridge.c		Src1:decl.c \
X#	Src1:demon.c		Src1:do.c		Src1:do_name.c \
X#	Src1:do_wear.c		Src1:dog.c		Src1:dogmove.c \
X#	Src1:dokick.c		Src1:dothrow.c		Src1:eat.c \
X#	Src1:end.c		Src1:engrave.c		Src1:exper.c \
X#	Src1:extralev.c		Src1:fountain.c		Src1:getline.c \
X#	Src1:hack.c		Src1:invent.c		Src1:lock.c
X#
X# HSRC2 = \
X#	Src2:mail.c		Src2:makemon.c		Src2:mcastu.c \
X#	Src2:mhitm.c		Src2:mhitu.c		Src2:mklev.c \
X#	Src2:mkmaze.c		Src2:mkobj.c		Src2:mkroom.c \
X#	Src2:mon.c		Src2:mondata.c		Src2:monmove.c \
X#	Src2:monst.c		Src2:mthrowu.c		Src2:music.c \
X#	Src2:o_init.c		Src2:objects.c		Src2:objnam.c \
X#	Src2:options.c		Src2:pager.c		Src2:pickup.c \
X#	Src2:polyself.c		Src2:potion.c
X#
X# HSRC3 = \
X#	Src3:pray.c		Src3:pri.c		Src3:priest.c \
X#	Src3:prisym.c		Src3:read.c		Src3:restore.c \
X#	Src3:rip.c		Src3:rnd.c		Src3:rumors.c \
X#	Src3:save.c		Src3:search.c		Src3:shk.c \
X#	Src3:shknam.c		Src3:sit.c		Src3:sounds.c \
X#	Src3:sp_lev.c		Src3:spell.c		Src3:steal.c \
X#	Src3:timeout.c		Src3:topl.c		Src3:topten.c \
X#	Src3:track.c		Src3:trap.c		Src3:u_init.c \
X#	Src3:uhitm.c		Src3:vault.c		Src3:version.c \
X#	Src3:weapon.c		Src3:were.c		Src3:wield.c \
X#	Src3:wizard.c		Src3:worm.c		Src3:worn.c \
X#	Src3:write.c		Src3:zap.c
X
X
X# All .c that are part of the main NetHack program and not system specific:
X
X# HACKCSRC = $(HSRC1) $(HSRC2) $(HSRC3)
X
X
X# Other .c files (duplicates commented out):
X
X# MAKESRC = \
X#	Src2:makedefs.c #	Src2:monst.c		Src2:objects.c
X#
X# SPLEVSRC = \
X#	Src1:lev_comp.c		Others:lev_lex.c	Src1:lev_main.c
X#
X# AMIGASRC = \
X#	Amiga:amidos.c		Amiga:amitcap.c		Amiga:amitty.c \
X#	Amiga:amiunix.c		Amiga:amiwbench.c	Amiga:amiwind.c
X#
X# OTHERSRC = \
X#	Others:pcmain.c		Others:random.c
X
X
X# All .c that are used:
X
X# CSOURCES = $(HACKCSRC) $(MAKESRC) $(SPLEVSRC) $(AMIGASRC) $(OTHERSRC)
X
X
X# All .h files (except date.h, onames.h, pm.h, and trap.h, which would
X# cause dependency loops in run through "make depend"):
X
X# HACKINCL = \
X#	Incl:amiconf.h		Incl:anime.h		Incl:artifact.h \
X#	Incl:attrib.h		Incl:color.h		Incl:config.h \
X#	Incl:coord.h		Incl:decl.h		Incl:edog.h \
X#	Incl:epri.h		Incl:eshk.h		Incl:extern.h \
X#	Incl:flag.h		Incl:func_tab.h		Incl:global.h \
X#	Incl:gold.h		Incl:hack.h		Incl:lev.h \
X#	Incl:mfndpos.h		Incl:mkroom.h		Incl:monattk.h \
X#	Incl:mondata.h		Incl:monflag.h		Incl:monst.h \
X#	Incl:monsym.h		Incl:msdos.h		Incl:obj.h \
X#	Incl:objclass.h		Incl:patchlevel.h	Incl:pcconf.h \
X#	Incl:permonst.h		Incl:prop.h		Incl:rm.h \
X#	Incl:sp_lev.h		Incl:spell.h		Incl:system.h \
X#	Incl:tradstdc.h		Incl:vault.h		Incl:wseg.h \
X#	Incl:you.h		Incl:youprop.h
X
X
X# All .h files:
X
X# HSOURCES = \
X#	$(HACKINCL)		Incl:date.h		Incl:onames.h \
X#	Incl:pm.h		Incl:trap.h
X
X
X# All source files:
X
X# SOURCES = $(CSOURCES) $(HSOURCES)
X
X
X# Object files for makedefs:
X
XMAKEOBJS = \
X	O_Src2:makedefs.o	O_Src2:monst.o		O_Src2:objects.o
X
X
X# Object files for special levels compiler:
X
XSPLEVOBJS = \
X	O_Src1:lev_comp.o	O_Others:lev_lex.o	O_Src1:lev_main.o \
X	O_Src2:monst.o		O_Src2:objects.o
X
X
X# Object files for NetHack:
X
XHOBJ1 = \
X	O_Src1:allmain.o	O_Src1:alloc.o		O_Src1:apply.o \
X	O_Src1:artifact.o	O_Src1:attrib.o		O_Src1:bones.o \
X	O_Src1:cmd.o		O_Src1:dbridge.o	O_Src1:decl.o \
X	O_Src1:demon.o		O_Src1:do.o		O_Src1:do_name.o \
X	O_Src1:do_wear.o	O_Src1:dog.o		O_Src1:dogmove.o \
X	O_Src1:dokick.o		O_Src1:dothrow.o	O_Src1:eat.o \
X	O_Src1:end.o		O_Src1:engrave.o	O_Src1:exper.o \
X	O_Src1:extralev.o	O_Src1:fountain.o	O_Src1:getline.o \
X	O_Src1:hack.o		O_Src1:invent.o		O_Src1:lock.o
X
XHOBJ2 = \
X	O_Src2:mail.o		O_Src2:makemon.o	O_Src2:mcastu.o \
X	O_Src2:mhitm.o		O_Src2:mhitu.o		O_Src2:mklev.o \
X	O_Src2:mkmaze.o		O_Src2:mkobj.o		O_Src2:mkroom.o \
X	O_Src2:mon.o		O_Src2:mondata.o	O_Src2:monmove.o \
X	O_Src2:monst.o		O_Src2:mthrowu.o	O_Src2:music.o \
X	O_Src2:o_init.o		O_Src2:objects.o	O_Src2:objnam.o \
X	O_Src2:options.o	O_Src2:pager.o		O_Src2:pickup.o \
X	O_Src2:polyself.o	O_Src2:potion.o
X
XHOBJ3 = \
X	O_Src3:pray.o		O_Src3:pri.o		O_Src3:priest.o \
X	O_Src3:prisym.o		O_Src3:read.o		O_Src3:restore.o \
X	O_Src3:rip.o		O_Src3:rnd.o		O_Src3:rumors.o \
X	O_Src3:save.o		O_Src3:search.o		O_Src3:shk.o \
X	O_Src3:shknam.o		O_Src3:sit.o		O_Src3:sounds.o \
X	O_Src3:sp_lev.o		O_Src3:spell.o		O_Src3:steal.o \
X	O_Src3:timeout.o	O_Src3:topl.o		O_Src3:topten.o \
X	O_Src3:track.o		O_Src3:trap.o		O_Src3:u_init.o \
X	O_Src3:uhitm.o		O_Src3:vault.o		O_Src3:version.o \
X	O_Src3:weapon.o		O_Src3:were.o		O_Src3:wield.o \
X	O_Src3:wizard.o		O_Src3:worm.o		O_Src3:worn.o \
X	O_Src3:write.o		O_Src3:zap.o
X
XAMIGAOBJ = \
X	O_Amiga:amidos.o	O_Amiga:amitcap.o	O_Amiga:amitty.o \
X	O_Amiga:amiunix.o	O_Amiga:amiwbench.o	O_Amiga:amiwind.o
X
XOTHEROBJ = \
X	O_Others:pcmain.o	$(RANDOBJ)
X
X
X# All the object files for NetHack:
X
XHOBJ = $(HOBJ1) $(HOBJ2) $(HOBJ3) $(AMIGAOBJ) $(OTHEROBJ)
X
X
X# The auxiliary runtime files:
X
XAUXFILES = \
X	NetHack:data		NetHack:rumors		NetHack:castle \
X	NetHack:endgame		NetHack:tower1		NetHack:cmdhelp \
X	NetHack:help		NetHack:hh		NetHack:history \
X	NetHack:license		NetHack:opthelp		NetHack:oracles \
X	NetHack:perm		NetHack:record		NetHack:NetHack.cnf \
X	NetHack:hack.font	NetHack:hack		NetHack:hack/8 \
X	NetHack:default.icon	HackExe:NetHack.info	NetHack:NewGame.info \
X	NetHack:Guidebook.info	NetHack:Guidebook NetHack:NetHackScore.info
X
X
X# Getting down to business:
X
Xall:  NetHack:lev_comp $(GAME) auxilstuff
X
X$(GAME):  $(HOBJ)
X	$(LINK) $(GAME) $(LIN) $(LLINK) $(LLIB)
X
Xlink:
X	$(LINK) $(GAME) $(LIN) $(LLINK) $(LLIB)
X
Xobj1:  $(HOBJ1)
Xobj2:  $(HOBJ2)
Xobj3:  $(HOBJ3)
Xobja:  $(AMIGAOBJ)
Xobjo:  $(OTHEROBJ)
X
X
X# The default method for creating object files:
X
X#[LATTICE]
X
X.c.o:
X	$(CC) $(CFLAGS) $(CSYM) -o$@ $<
X
X#[MANX3.6]
X
X#$(HOBJ1):
X#	$(CC) $(CFLAGS) $(CSYM) -o$@ Src1:$*.c
X
X#$(HOBJ2):
X#	$(CC) $(CFLAGS) $(CSYM) -o$@ Src2:$*.c
X
X#$(HOBJ3):
X#	$(CC) $(CFLAGS) $(CSYM) -o$@ Src3:$*.c
X
X#$(AMIGAOBJ):
X#	$(CC) $(CFLAGS) $(CSYM) -o$@ Amiga:$*.c
X
X#$(OTHEROBJ):
X#	$(CC) $(CFLAGS) $(CSYM) -o$@ Others:$*.c
X
X
Xclean:
X	-delete O_Amiga:\#?.o O_Others:\#?.o
X	-delete O_Src1:\#?.o O_Src2:\#?.o O_Src3:\#?.o
X
Xspotless:  clean
X	-delete $(GAME) NetHack:lev_comp NetHack:makedefs
X	-delete Auxil:data Auxil:rumors
X	-delete NetHack:data NetHack:rumors
X	-delete NetHack:castle NetHack:endgame
X	-delete NetHack:tower1 NetHack:tower2 NetHack:tower3
X	-delete Incl:onames.h Incl:pm.h
X	-echo > Incl:onames.h "" noline
X	-wait 2
X	-echo > Incl:pm.h "" noline
X	-wait 2
X	-setdate Src2:makedefs.c
X	-wait 2
X# (Make sure files exist and have timestamps in the right order for
X# next compile)
X
X
X# Creating precompiled version of Incl:hack.h to save disk I/O.
X
X#[LATTICE]
X#   If we were to use the precompiled header file feature of Lattice C, we
X#   would uncomment the following lines.  However, there are still problems
X#   in the behavior of this feature in version 5.04, so these lines are
X#   commented out for now.  (Also see defines for HDEP and CSYM near the
X#   beginning of this file, as these should be appropriately defined.)
X
X#$(HDEP):  Incl:hack.h NetHack:makedefs
X#	echo > Ram:hackincl.c "#include <Incl:hack.h>"
X#	$(CC) $(CFLAGS) -ph -o$@ Ram:hackincl.c
X#	-delete Ram:hackincl.c
X
X#[MANX3.6]
X#   If we were compiling with Aztec 3.6 and wanted to use the symbol table
X#   pre-loading feature, we would uncomment these following two lines.
X
X#$(HDEP):  Incl:hack.h NetHack:makedefs
X#	$(CC) $(CFLAGS) -a -oRam:hack.asm +h$@ Incl:hack.h
X#	-delete Ram:hack.asm
X
X
X#
X#	Please note:	The dependency lines for the modules here are
X#			deliberately incorrect.  Including "hack.h" in
X#			the dependency list would cause a dependency
X#			loop.
X#
X
XNetHack:makedefs:  $(MAKEOBJS)
X	$(LINK) NetHack:makedefs $(LIN) $(MAKEOBJS) $(LLIB)
X
XO_Src2:makedefs.o:  Src2:makedefs.c Incl:config.h Incl:permonst.h Incl:objclass.h
X	$(CC) -dMAKEDEFS_C $(CFLAGS) -o$@ Src2:makedefs.c
X
XNetHack:lev_comp:  $(SPLEVOBJS)
X	$(LINK) NetHack:lev_comp $(LIN) $(SPLEVOBJS) $(LLIB)
X
XO_Src1:lev_comp.o:  Src1:lev_comp.c $(HDEP) Incl:sp_lev.h
X	$(CC) -dLEV_LEX_C $(CFLAGS) -o$@ Src1:lev_comp.c
X
XO_Others:lev_lex.o:  Others:lev_lex.c $(HDEP) Incl:lev_comp.h Incl:sp_lev.h
X	$(CC) -dLEV_LEX_C $(CFLAGS) -o$@ Others:lev_lex.c
X
XO_Src1:lev_main.o:  Src1:lev_main.c $(HDEP)
X	$(CC) -dLEV_LEX_C -dAMIGA $(CFLAGS) -o$@ Src1:lev_main.c
X
X#
X#	The following include files depend on makedefs to be created.
X#	As a result, they are not defined in HACKINCL, instead, their
X#	dependencies are explicitly outlined here.
X#
X
X#
X#	date.h should be remade any time any of the source or include code
X#	is modified.  Unfortunately, this would make the contents of this
X#	file far more complex.	Since "hack.h" depends on most of the include
X#	files, we kludge around this by making date.h dependent on hack.h,
X#	even though it doesn't include this file.
X#
X
XIncl:date.h:  $(HDEP) NetHack:makedefs $(AMIGAOBJ)
X	NetHack:makedefs -v
X
XIncl:trap.h:  NetHack:makedefs
X	NetHack:makedefs -t
X	-copy makedefs.1 $@
X
XIncl:onames.h:  NetHack:makedefs
X	NetHack:makedefs -o
X
XIncl:pm.h:  NetHack:makedefs
X	NetHack:makedefs -p
X
X#
X#	The following programs vary depending on what OS you are using.
X#	As a result, they are not defined in HACKSRC and their dependancies
X#	are explicitly outlined here.
X#
X
XO_Amiga:amidos.o:  Amiga:amidos.c $(HDEP)
X
XO_Amiga:amitcap.o:  Amiga:amitcap.c $(HDEP)
X
XO_Amiga:amitty.o:  Amiga:amitty.c $(HDEP)
X
XO_Amiga:amiunix.o:  Amiga:amiunix.c $(HDEP)
X
XO_Amiga:amiwind.o:  Amiga:amiwind.c Amiga:amimenu.c $(HDEP)
X
XO_Amiga:amiwbench.o:  Amiga:amiwbench.c $(HDEP)
X
XO_Others:random.o:  Others:random.c
X	$(CC) $(CFLAGS) -o$@ Others:random.c
X
XO_Others:pcmain.o:  Others:pcmain.c $(HDEP)
X
X
X# Create/copy other stuff into NetHack: directory:
X
Xauxilstuff:  $(AUXFILES)
X
XNetHack:data:  Auxil:data
X	copy Auxil:data $@
X
XAuxil:data:  Auxil:data.base Incl:config.h NetHack:makedefs
X	NetHack:makedefs -d
X
XNetHack:rumors:  Auxil:rumors
X	copy Auxil:rumors $@
X
XAuxil:rumors:  Auxil:rumors.tru Auxil:rumors.fal NetHack:makedefs
X	NetHack:makedefs -r
X
XNetHack:castle:  Auxil:castle.des NetHack:lev_comp
X	NetHack:lev_comp Auxil:castle.des
X
XNetHack:endgame:  Auxil:endgame.des NetHack:lev_comp
X	NetHack:lev_comp Auxil:endgame.des
X
XNetHack:tower1:  Auxil:tower.des NetHack:lev_comp
X	NetHack:lev_comp Auxil:tower.des
X
XNetHack:cmdhelp:  Auxil:cmdhelp
X	copy Auxil:cmdhelp $@
X
XNetHack:help:  Auxil:help
X	copy Auxil:help $@
X
XNetHack:hh:  Auxil:hh
X	copy Auxil:hh $@
X
XNetHack:history:  Auxil:history
X	copy Auxil:history $@
X
XNetHack:license:  Auxil:license
X	copy Auxil:license $@
X
XNetHack:opthelp:  Auxil:opthelp
X	copy Auxil:opthelp $@
X
XNetHack:oracles:  Auxil:oracles
X	copy Auxil:oracles $@
X
XNetHack:perm:
X	echo > $@ "" NOLINE
X
XNetHack:record:
X	echo > $@ "" NOLINE
X
XNetHack:NetHack.cnf:  Amiga:NetHack.cnf
X	copy Amiga:NetHack.cnf $@
X
XNetHack:hack.font:  Amiga:amifont.uu
X	$(UUDEC) Amiga:amifont.uu
X
XNetHack:hack:
X	makedir $@
X
XNetHack:hack/8:  Amiga:amifont8.uu NetHack:hack
X	$(UUDEC) Amiga:amifont8.uu
X	-rename 8 hack/8
X
XNetHack:default.icon:  Amiga:dflticon.uu
X	$(UUDEC) Amiga:dflticon.uu
X
XHackExe:NetHack.info:  Amiga:NHinfo.uu
X	$(UUDEC) Amiga:NHinfo.uu
X
XNetHack:NewGame.info:  Amiga:NewGame.uu
X	$(UUDEC) Amiga:NewGame.uu
X
XNetHack:NetHackScore.info:  Amiga:NHScore.uu
X	$(UUDEC) Amiga:NHScore.uu
X
XNetHack:Guidebook.info:  Amiga:GBinfo.uu
X	$(UUDEC) Amiga:GBinfo.uu
X
XNetHack:Guidebook:  Auxil:Guidebook.mss
X	copy Auxil:Guidebook.mss $@
X
X# DO NOT DELETE THIS LINE
X
XO_Src1:allmain.o:  Src1:allmain.c $(HDEP)
XO_Src1:alloc.o:  Src1:alloc.c Incl:config.h
X	$(CC) $(CFLAGS) -o$@ Src1:alloc.c
XO_Src1:apply.o:  Src1:apply.c $(HDEP) Incl:edog.h
XO_Src1:artifact.o:  Src1:artifact.c $(HDEP) Incl:artifact.h
XO_Src1:attrib.o:  Src1:attrib.c $(HDEP)
XO_Src1:bones.o:  Src1:bones.c $(HDEP)
XO_Src1:cmd.o:  Src1:cmd.c $(HDEP) Incl:func_tab.h
XO_Src1:dbridge.o:  Src1:dbridge.c $(HDEP)
XO_Src1:decl.o:  Src1:decl.c $(HDEP)
XO_Src1:demon.o:  Src1:demon.c $(HDEP)
XO_Src1:do.o:  Src1:do.c $(HDEP)
XO_Src1:do_name.o:  Src1:do_name.c $(HDEP)
XO_Src1:do_wear.o:  Src1:do_wear.c $(HDEP)
XO_Src1:dog.o:  Src1:dog.c $(HDEP) Incl:edog.h
XO_Src1:dogmove.o:  Src1:dogmove.c $(HDEP) Incl:mfndpos.h Incl:edog.h
XO_Src1:dokick.o:  Src1:dokick.c $(HDEP) Incl:eshk.h
XO_Src1:dothrow.o:  Src1:dothrow.c $(HDEP)
XO_Src1:eat.o:  Src1:eat.c $(HDEP)
XO_Src1:end.o:  Src1:end.c $(HDEP) Incl:eshk.h
XO_Src1:engrave.o:  Src1:engrave.c $(HDEP)
XO_Src1:exper.o:  Src1:exper.c $(HDEP)
XO_Src1:extralev.o:  Src1:extralev.c $(HDEP)
XO_Src1:fountain.o:  Src1:fountain.c $(HDEP)
XO_Src1:getline.o:  Src1:getline.c $(HDEP) Incl:func_tab.h
XO_Src1:hack.o:  Src1:hack.c $(HDEP)
XO_Src1:invent.o:  Src1:invent.c $(HDEP) Incl:lev.h Incl:wseg.h
XO_Src1:lock.o:  Src1:lock.c $(HDEP)
XO_Src2:mail.o:  Src2:mail.c $(HDEP)
XO_Src2:makemon.o:  Src2:makemon.c $(HDEP)
XO_Src2:mcastu.o:  Src2:mcastu.c $(HDEP)
XO_Src2:mhitm.o:  Src2:mhitm.c $(HDEP) Incl:artifact.h
XO_Src2:mhitu.o:  Src2:mhitu.c $(HDEP) Incl:artifact.h Incl:edog.h
XO_Src2:mklev.o:  Src2:mklev.c $(HDEP)
XO_Src2:mkmaze.o:  Src2:mkmaze.c $(HDEP)
XO_Src2:mkobj.o:  Src2:mkobj.c $(HDEP)
XO_Src2:mkroom.o:  Src2:mkroom.c $(HDEP)
XO_Src2:mon.o:  Src2:mon.c $(HDEP) Incl:mfndpos.h Incl:wseg.h
XO_Src2:mondata.o:  Src2:mondata.c $(HDEP) Incl:eshk.h Incl:epri.h
XO_Src2:monmove.o:  Src2:monmove.c $(HDEP) Incl:mfndpos.h Incl:artifact.h
XO_Src2:monst.o:  Src2:monst.c Incl:config.h Incl:permonst.h Incl:monsym.h Incl:eshk.h Incl:vault.h Incl:epri.h Incl:color.h
X	$(CC) $(CFLAGS) -o$@ Src2:monst.c
XO_Src2:mthrowu.o:  Src2:mthrowu.c $(HDEP)
XO_Src2:music.o:  Src2:music.c $(HDEP)
XO_Src2:o_init.o:  Src2:o_init.c $(HDEP)
XO_Src2:objects.o:  Src2:objects.c Incl:config.h Incl:obj.h Incl:objclass.h Incl:prop.h Incl:color.h
X	$(CC) $(CFLAGS) -o$@ Src2:objects.c
XO_Src2:objnam.o:  Src2:objnam.c $(HDEP)
XO_Src2:options.o:  Src2:options.c $(HDEP)
XO_Src2:pager.o:  Src2:pager.c $(HDEP)
XO_Src2:pickup.o:  Src2:pickup.c $(HDEP)
XO_Src2:polyself.o:  Src2:polyself.c $(HDEP)
XO_Src2:potion.o:  Src2:potion.c $(HDEP)
XO_Src3:pray.o:  Src3:pray.c $(HDEP)
XO_Src3:pri.o:  Src3:pri.c $(HDEP) Incl:epri.h Incl:termcap.h
XO_Src3:priest.o:  Src3:priest.c $(HDEP) Incl:mfndpos.h Incl:eshk.h Incl:epri.h
XO_Src3:prisym.o:  Src3:prisym.c $(HDEP) Incl:wseg.h Incl:lev.h
XO_Src3:read.o:  Src3:read.c $(HDEP)
XO_Src3:restore.o:  Src3:restore.c $(HDEP) Incl:lev.h Incl:wseg.h
XO_Src3:rip.o:  Src3:rip.c $(HDEP)
XO_Src3:rnd.o:  Src3:rnd.c $(HDEP)
XO_Src3:rumors.o:  Src3:rumors.c $(HDEP)
XO_Src3:save.o:  Src3:save.c $(HDEP) Incl:lev.h Incl:wseg.h
XO_Src3:search.o:  Src3:search.c $(HDEP) Incl:artifact.h
XO_Src3:shk.o:  Src3:shk.c $(HDEP) Incl:eshk.h
XO_Src3:shknam.o:  Src3:shknam.c $(HDEP) Incl:eshk.h
XO_Src3:sit.o:  Src3:sit.c $(HDEP)
XO_Src3:sounds.o:  Src3:sounds.c $(HDEP) Incl:edog.h Incl:eshk.h
XO_Src3:sp_lev.o:  Src3:sp_lev.c $(HDEP) Incl:sp_lev.h
XO_Src3:spell.o:  Src3:spell.c $(HDEP)
XO_Src3:steal.o:  Src3:steal.c $(HDEP)
XO_Src3:timeout.o:  Src3:timeout.c $(HDEP)
XO_Src3:topl.o:  Src3:topl.c $(HDEP)
XO_Src3:topten.o:  Src3:topten.c $(HDEP)
XO_Src3:track.o:  Src3:track.c $(HDEP)
XO_Src3:trap.o:  Src3:trap.c $(HDEP) Incl:edog.h
XO_Src3:u_init.o:  Src3:u_init.c $(HDEP)
XO_Src3:uhitm.o:  Src3:uhitm.c $(HDEP) Incl:artifact.h
XO_Src3:vault.o:  Src3:vault.c $(HDEP) Incl:vault.h
XO_Src3:version.o:  Src3:version.c $(HDEP) Incl:date.h Incl:patchlevel.h
XO_Src3:weapon.o:  Src3:weapon.c $(HDEP)
XO_Src3:were.o:  Src3:were.c $(HDEP)
XO_Src3:wield.o:  Src3:wield.c $(HDEP)
XO_Src3:wizard.o:  Src3:wizard.c $(HDEP)
XO_Src3:worm.o:  Src3:worm.c $(HDEP) Incl:wseg.h
XO_Src3:worn.o:  Src3:worn.c $(HDEP)
XO_Src3:write.o:  Src3:write.c $(HDEP)
XO_Src3:zap.o:  Src3:zap.c $(HDEP)
XIncl:config.h:  Incl:tradstdc.h Incl:global.h
X	-setdate Incl:config.h
X	-wait 2
XIncl:decl.h:  Incl:spell.h Incl:color.h Incl:obj.h Incl:you.h Incl:onames.h Incl:pm.h
X	-setdate Incl:decl.h
X	-wait 2
XIncl:global.h:  Incl:coord.h Incl:vmsconf.h Incl:unixconf.h Incl:pcconf.h Incl:tosconf.h Incl:amiconf.h Incl:macconf.h
X	-setdate Incl:global.h
X	-wait 2
XIncl:hack.h:  Incl:config.h Incl:decl.h Incl:monsym.h Incl:mkroom.h Incl:objclass.h Incl:gold.h Incl:trap.h Incl:flag.h Incl:rm.h Incl:trampoli.h
X	-setdate Incl:hack.h
X	-wait 2
XIncl:permonst.h:  Incl:monattk.h Incl:monflag.h
X	-setdate Incl:permonst.h
X	-wait 2
XIncl:you.h:  Incl:attrib.h Incl:monst.h Incl:youprop.h
X	-setdate Incl:you.h
X	-wait 2
XIncl:youprop.h:  Incl:prop.h Incl:permonst.h Incl:mondata.h Incl:pm.h
X	-setdate Incl:youprop.h
X	-wait 2
X# DEPENDENCIES MUST END AT END OF FILE
X# IF YOU PUT STUFF HERE IT WILL GO AWAY
X# see make depend above
END_OF_FILE
if test 21416 -ne `wc -c <'amiga/Makefile.ami'`; then
    echo shar: \"'amiga/Makefile.ami'\" unpacked with wrong size!
fi
# end of 'amiga/Makefile.ami'
fi
if test -f 'src/hack.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/hack.c'\"
else
echo shar: Extracting \"'src/hack.c'\" \(28166 characters\)
sed "s/^X//" >'src/hack.c' <<'END_OF_FILE'
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include "hack.h"
X
X#if defined(UNIX) && !defined(LINT)
Xstatic	const char	SCCS_Id[] = "@(#)hack.c	3.0\t89/11/20";
X#endif
X
XSTATIC_DCL int NDECL(moverock);
X#ifdef SINKS
XSTATIC_DCL void NDECL(dosinkfall);
X#endif
X
X#ifdef OVL1
Xstatic boolean FDECL(is_edge,(XCHAR_P,XCHAR_P));
Xstatic boolean FDECL(bad_rock,(XCHAR_P,XCHAR_P));
X#endif /* OVL1 */
X
X#ifdef OVLB
X
X/* called on movement:
X	1. when throwing ball+chain far away
X	2. when teleporting
X	3. when walking out of a lit room
X */
Xvoid
Xunsee() {
X	register xchar x,y;
X	register struct rm *lev;
X
X	if(seehx){
X		seehx = 0;
X	} 
X	/*
X	 *  Erase surrounding positions if needed.  We don't need to do this
X	 *  if we are blind, since we can't see them anyway.  This removes the
X	 *  pl6 bug that makes monsters disappear if they are next to you if
X	 *  you teleport while blind and telepathic.
X	 */
X	else if(!Blind)
X	    for(x = u.ux-1; x < u.ux+2; x++)
X	        for(y = u.uy-1; y < u.uy+2; y++) {
X		    if(!isok(x, y)) continue;
X		    lev = &levl[x][y];
X		    if(!lev->lit && lev->scrsym == ROOM_SYM) {
X			lev->scrsym = STONE_SYM;
X			lev->new = 1;
X			on_scr(x,y);
X		    }
X	        }
X}
X
X/* called:
X	in apply.c:  seeoff(0)	- when taking a picture of yourself
X				- when donning a blindfold
X	in do.c:     seeoff(0)	- blind after drinking potion
X	in do.c:     seeoff(1)	- go up or down the stairs
X	in eat.c:    seeoff(0)	- blind after eating rotten food
X	in mhitu.c:  seeoff(0)	- blinded by a glowing eye
X	in mhitu.c:  seeoff(1)	- swallowed
X	in mthrow.c: seeoff(0)	- hit by a cream pie.
X	in potion.c: seeoff(0)	- quaffing or sniffing a potion of blindness
X	in spell.c:  seeoff(0)	- due to a cursed spell book
X	in trap.c:   seeoff(1)	- fall through trap door
X */
Xvoid
Xseeoff(mode)
Xint mode;
X{		/* 1 to redo @, 0 to leave them */
X		/* 1 means misc movement, 0 means blindness */
X	register xchar x,y;
X	register struct rm *lev;
X
X	if(u.udispl && mode){
X		u.udispl = 0;
X		levl[u.udisx][u.udisy].scrsym = news0(u.udisx,u.udisy);
X	}
X	if(seehx) {
X		seehx = 0;
X	} else
X	    if(!mode) {
X		for(x = u.ux-1; x < u.ux+2; x++)
X		    for(y = u.uy-1; y < u.uy+2; y++) {
X			if(!isok(x, y)) continue;
X			lev = &levl[x][y];
X			if(MON_AT(x, y))
X			    unpmon(m_at(x,y));
X			if(!lev->lit && lev->scrsym == ROOM_SYM) {
X			    lev->seen = 0;
X			    atl(x, y, (char)STONE_SYM);
X			}
X		    }
X	    }
X}
X
X#endif /* OVLB */
X#ifdef OVL2
X
XSTATIC_OVL int
Xmoverock() {
X	register xchar rx, ry;
X	register struct obj *otmp, *otmp2;
X	register struct trap *ttmp;
X	register struct	monst *mtmp;
X
X#ifdef POLYSELF
X	if (passes_walls(uasmon)) return 0;
X#endif
X	while(otmp = sobj_at(BOULDER, u.ux+u.dx, u.uy+u.dy)) {
X		rx = u.ux+2*u.dx;
X		ry = u.uy+2*u.dy;
X		nomul(0);
X#ifdef POLYSELF
X		if (verysmall(uasmon)) {
X		    pline("You're too small to push that boulder.");
X		    goto cannot_push;
X		}
X#endif
X		if(isok(rx,ry) && !IS_ROCK(levl[rx][ry].typ) &&
X		    (!IS_DOOR(levl[rx][ry].typ) || !(u.dx && u.dy) || (
X#ifdef REINCARNATION
X			dlevel != rogue_level &&
X#endif
X		     (levl[rx][ry].doormask & ~D_BROKEN) == D_NODOOR)) &&
X		    !sobj_at(BOULDER, rx, ry)) {
X			if(MON_AT(rx, ry)) {
X			    mtmp = m_at(rx,ry);
X			    if(canseemon(mtmp))
X				pline("There's %s on the other side.",
X				      mon_nam(mtmp));
X			    else
X				You("hear a monster behind the boulder.");
X			    if(flags.verbose)
X				pline("Perhaps that's why you cannot move it.");
X			    goto cannot_push;
X			}
X			if(ttmp = t_at(rx,ry))
X			    switch(ttmp->ttyp) {
X			    case SPIKED_PIT:
X			    case PIT:
X				You("push the boulder into a pit!");
X				deltrap(ttmp);
X				delobj(otmp);
X				if(cansee(rx,ry)) newsym(rx,ry);
X				else levl[rx][ry].seen = 0;
X				if(flags.verbose)
X				    pline("It completely fills the pit!");
X				continue;
X			    case TRAPDOOR:
X				if(is_maze_lev
X#ifdef STRONGHOLD
X					&& (dlevel > stronghold_level)
X#endif
X					) break;
X				pline("The boulder falls into and plugs a hole in the ground!");
X				deltrap(ttmp);
X				delobj(otmp);
X				if(cansee(rx,ry)) newsym(rx,ry);
X				else levl[rx][ry].seen = 0;
X				continue;
X			    case LEVEL_TELEP:
X			    case TELEP_TRAP:
X				You("push the boulder and suddenly it disappears!");
X				rloco(otmp);
X				continue;
X			    }
X			if(closed_door(rx, ry))
X				goto nopushmsg;
X			if(is_pool(rx,ry)) {
X#ifdef STRONGHOLD
X				if(levl[rx][ry].typ == DRAWBRIDGE_UP)
X				    levl[rx][ry].drawbridgemask |= DB_FLOOR;
X				else
X#endif
X				    levl[rx][ry].typ = ROOM;
X				mnewsym(rx,ry);
X				if(!Blind) prl(rx,ry);
X				You("push the boulder into the water.");
X				if(flags.verbose && !Blind)
X				    pline("Now you can cross the water!");
X				delobj(otmp);
X				continue;
X			}
X				/*
X				 * Re-link at top of fobj chain so that 
X				 * pile order is preserved when level is 
X				 * restored.
X				 */
X			if (otmp != fobj) {
X				otmp2 = fobj;
X				while (otmp2->nobj && otmp2->nobj != otmp) 
X					otmp2 = otmp2->nobj;
X				if (!otmp2->nobj)
X				    impossible("moverock: error in fobj chain");
X				else {
X					otmp2->nobj = otmp->nobj;	
X					otmp->nobj = fobj;
X					fobj = otmp;
X				}
X			}
X			move_object(otmp, rx, ry);
X			/* pobj(otmp); */
X			if(cansee(rx,ry)) atl(rx,ry,otmp->olet);
X			newsym(u.ux+u.dx, u.uy+u.dy);
X
X			{
X#ifdef LINT	/* static long lastmovetime; */
X			long lastmovetime;
X			lastmovetime = 0;
X#else
X			static long NEARDATA lastmovetime;
X#endif
X			/* note: this var contains garbage initially and
X			   after a restore */
X			if(moves > lastmovetime+2 || moves < lastmovetime)
X			pline("With great effort you move the boulder.");
X			lastmovetime = moves;
X			}
X		} else {
Xnopushmsg:
X		    You("try to move the boulder, but in vain.");
X	    cannot_push:
X#ifdef POLYSELF
X		    if (throws_rocks(uasmon)) {
X			if(!flags.pickup)
X				pline("However, you easily can push it aside.");
X			else
X				pline("However, you easily can pick it up.");
X			break;
X		    }
X#endif
X		    if((!invent || inv_weight()+90 <= 0) &&
X			(!u.dx || !u.dy || (IS_ROCK(levl[u.ux][u.uy+u.dy].typ)
X					&& IS_ROCK(levl[u.ux+u.dx][u.uy].typ)))
X#ifdef POLYSELF
X			|| verysmall(uasmon)
X#endif
X									)
X		    {
X			pline("However, you can squeeze yourself into a small opening.");
X			break;
X		    } else
X			return (-1);
X		}
X	}
X	return (0);
X}
X
X#endif /* OVL2 */
X#ifdef OVLB
X
Xvoid
Xmovobj(obj, ox, oy)
Xregister struct obj *obj;
Xregister xchar ox, oy;
X{
X	remove_object(obj);
X	if (cansee(obj->ox, obj->oy)) {
X		levl[obj->ox][obj->oy].seen = 0;
X		prl(obj->ox, obj->oy);
X	} else
X		newsym(obj->ox, obj->oy);
X	place_object(obj, ox, oy);
X	if (cansee(ox, oy)) {
X		levl[ox][oy].seen = 0;
X		prl(ox, oy);
X	} else
X		newsym(ox, oy);
X}
X
X#ifdef SINKS
XSTATIC_OVL
Xvoid
Xdosinkfall() {
X	register struct obj *obj;
X
X# ifdef POLYSELF
X	if (is_floater(uasmon)) {
X		You("wobble unsteadily for a moment.");
X	} else {
X# endif
X		You("crash to the floor!");
X		losehp((rn1(10, 20 - (int)ACURR(A_CON))),
X			"fell onto a sink", NO_KILLER_PREFIX);
X		for(obj = level.objects[u.ux][u.uy]; obj; obj = obj->nexthere)
X		    if(obj->olet == WEAPON_SYM) {
X			You("fell on %s.",doname(obj));
X			losehp(rn2(3),"fell onto a sink", NO_KILLER_PREFIX);
X		    }
X# ifdef POLYSELF
X	}
X# endif
X
X	HLevitation = (HLevitation & ~TIMEOUT) + 1;
X	if(uleft && uleft->otyp == RIN_LEVITATION) {
X	    obj = uleft;
X	    Ring_off(obj);
X	    off_msg(obj);
X	}
X	if(uright && uright->otyp == RIN_LEVITATION) {
X	    obj = uright;
X	    Ring_off(obj);
X	    off_msg(obj);
X	}
X	if(uarmf && uarmf->otyp == LEVITATION_BOOTS) {
X	    obj = uarmf;
X	    (void)Boots_off();
X	    off_msg(obj);
X	}
X	HLevitation--;
X}
X#endif
X
X#endif /* OVLB */
X#ifdef OVL1
X
Xstatic boolean
Xis_edge(x,y)
Xregister xchar x,y;
X/* return true if (x,y) is on the edge of a room
X * we cannot rely on IS_DOOR(levl[x][y].typ) because some of the stronghold
X * "rooms" are actually outside areas without doors
X */
X{
X	register int roomno = inroom(x,y);
X
X	if(roomno < 0) return FALSE;
X	return((x == rooms[roomno].lx - 1) || (x == rooms[roomno].hx + 1) ||
X	       (y == rooms[roomno].ly - 1) || (y == rooms[roomno].hy + 1));
X}
X
X#endif /* OVL1 */
X#ifdef OVLB
X
Xboolean
Xmay_dig(x,y)
Xregister xchar x,y;
X/* intended to be called only on ROCKs */
X{
Xreturn (!(IS_STWALL(levl[x][y].typ) && (levl[x][y].diggable & W_NONDIGGABLE)));
X}
X
X#endif /* OVLB */
X#ifdef OVL1
X
Xstatic boolean
Xbad_rock(x,y)
Xregister xchar x,y;
X{
X	return(IS_ROCK(levl[x][y].typ)
X#ifdef POLYSELF
X		    && !passes_walls(uasmon)
X		    && (!tunnels(uasmon) || needspick(uasmon) || !may_dig(x,y))
X#endif
X	);
X}
X
Xvoid
Xdomove() {
X	register struct monst *mtmp;
X	register struct rm *tmpr,*ust;
X	register xchar x,y;
X	struct trap *trap;
X
X	u_wipe_engr(rnd(5));
X
X	if(inv_weight() > 0){
X		You("collapse under your load.");
X		nomul(0);
X		return;
X	}
X	if(u.uswallow) {
X		register xchar xx,yy;
X
X		u.dx = u.dy = 0;
X		xx = u.ux;
X		yy = u.uy;
X		x = u.ux = u.ustuck->mx;
X		y = u.uy = u.ustuck->my;
X		if(xx != x || yy != y) newsym(xx,yy);
X		mtmp = u.ustuck;
X	} else {
X		x = u.ux + u.dx;
X		y = u.uy + u.dy;
X		if(Stunned || (Confusion && !rn2(5))) {
X			register int tries = 0;
X
X			do {
X				if(tries++ > 50) {
X					nomul(0);
X					return;
X				}
X				confdir();
X				x = u.ux + u.dx;
X				y = u.uy + u.dy;
X			} while(!isok(x, y) || bad_rock(x, y));
X		}
X		if(!isok(x, y)) {
X			nomul(0);
X			return;
X		}
X		if((trap = t_at(x, y)) && trap->tseen)
X			nomul(0);
X		if(u.ustuck && (x != u.ustuck->mx ||
X				y != u.ustuck->my)) {
X			if(dist(u.ustuck->mx, u.ustuck->my) > 2) {
X			/* perhaps it fled (or was teleported or ... ) */
X				u.ustuck = 0;
X			} else {
X#ifdef POLYSELF
X				/* If polymorphed into a sticking monster,
X				 * u.ustuck means it's stuck to you, not you
X				 * to it.
X				 */
X				if (sticks(uasmon)) {
X					kludge("You release %s.",
X						mon_nam(u.ustuck));
X					u.ustuck = 0;
X				} else {
X#endif
X					kludge("You cannot escape from %s!",
X						mon_nam(u.ustuck));
X					nomul(0);
X					return;
X#ifdef POLYSELF
X				}
X#endif
X			}
X		}
X		mtmp = m_at(x,y);
X		if (mtmp) {
X			/* Don't attack if you're running */
X			if (flags.run && !mtmp->mimic &&
X				    (Blind ? Telepat :
X					 (!mtmp->minvis || See_invisible))) {
X				nomul(0);
X				flags.move = 0;
X				return;
X			}
X		}
X	}
X
X	u.ux0 = u.ux;
X	u.uy0 = u.uy;
X	tmpr = &levl[x][y];
X
X	/* attack monster */
X	if(mtmp) {
X		nomul(0);
X		gethungry();
X		if(multi < 0) return;	/* we just fainted */
X
X		/* try to attack; note that it might evade */
X		if(attack(mtmp)) return;
X	}
X
X	/* not attacking an animal, so we try to move */
X#ifdef POLYSELF
X	if(!uasmon->mmove) {
X		You("are rooted %s.", Levitation ? "in place"
X			: "to the ground");
X		nomul(0);
X		return;
X	}
X#endif
X	if(u.utrap) {
X		if(u.utraptype == TT_PIT) {
X		    if(flags.verbose)
X			Norep("You are still in a pit.");
X		    u.utrap--;
X		} else if (u.utraptype == TT_WEB) {
X		    if(flags.verbose)
X		    	Norep("You are stuck to the web.");
X		    u.utrap--;
X		} else {
X		    if(flags.verbose)
X			Norep("You are caught in a bear trap.");
X		    if((u.dx && u.dy) || !rn2(5)) u.utrap--;
X		}
X		return;
X	}
X	/* check for physical obstacles */
X#ifdef POLYSELF
X	if (!passes_walls(uasmon)) {
X#endif
X#ifdef STRONGHOLD
X	    if(dlevel == stronghold_level && is_db_wall(x,y)) {
X		    pline("The drawbridge is up!");
X		    nomul(0);
X		    return;
X	    }
X#endif
X	    if(closed_door(x, y)) {
X#ifdef POLYSELF
X		if(amorphous(uasmon))
X		    You("ooze under the door.");
X		else {
X#endif
X		    flags.move = 0;
X		    if(x == u.ux || y == u.uy) {
X		        if (Blind || Stunned || ACURR(A_DEX) < 10 || Fumbling)
X			    pline("Ouch!  You bump into a door.");
X		         else pline("That door is closed.");
X		    }
X		    nomul(0);
X		    return;
X#ifdef POLYSELF
X		}
X#endif
X	    }
X#ifdef POLYSELF
X	}
X#endif
X	ust = &levl[u.ux][u.uy];
X
X	if(bad_rock(x,y) ||
X	   (u.dx && u.dy
X#ifdef POLYSELF
X		 && !passes_walls(uasmon)
X#endif
X		 && ( (IS_DOOR(ust->typ) && block_entry(x, y)) ||
X#ifdef REINCARNATION
X			(IS_DOOR(tmpr->typ) &&
X			 ((tmpr->doormask & ~D_BROKEN) 
X			   || dlevel == rogue_level || block_door(x, y))
X                        )  
X		     || (IS_DOOR(ust->typ) &&
X			 ((ust->doormask & ~D_BROKEN) || dlevel == rogue_level)
X                        )
X#else
X			(IS_DOOR(tmpr->typ) &&
X			 ((tmpr->doormask & ~D_BROKEN) || block_door(x, y))) ||
X			(IS_DOOR(ust->typ) && (ust->doormask & ~D_BROKEN))
X#endif
X		    )
X	   )) {
X		flags.move = 0;
X		nomul(0);
X		return;
X	}
X	if(moverock() < 0) return;
X	if(u.dx && u.dy && bad_rock(u.ux,y) &&
X			   bad_rock(x,u.uy)) {
X#ifdef POLYSELF
X	    if (bigmonst(uasmon)) {
X		Your("body is too large to fit through.");
X		nomul(0);
X		return;
X	    }
X#endif
X	    if (invent && inv_weight()+40 > 0) {
X		You("are carrying too much to get through.");
X		nomul(0);
X		return;
X	    }
X	}
X	if(Punished &&
X	   dist2(x, y, uchain->ox, uchain->oy) > 2) {
X		if(carried(uball)) {
X			movobj(uchain, u.ux, u.uy);
X			goto nodrag;
X		}
X
X		if(dist2(x, y, uball->ox, uball->oy) < 3) {
X			/* leave ball, move chain under/over ball */
X			movobj(uchain, uball->ox, uball->oy);
X			goto nodrag;
X		}
X
X		if(inv_weight() + (int)(uball->owt >> 1) > 0) {
X			You("cannot %sdrag the heavy iron ball.",
X			invent ? "carry all that and also " : "");
X			nomul(0);
X			return;
X		}
X
X		movobj(uball, uchain->ox, uchain->oy);
X		movobj(uchain, u.ux, u.uy);
X		nomul(-2);
X		nomovemsg = "";
X	nodrag:	;
X	}
X#ifdef POLYSELF
X	if (tunnels(uasmon) && !needspick(uasmon) && IS_ROCK(tmpr->typ)) {
X		static const char NEARDATA *digtxt;
X
X		if(dig_pos.x != x || dig_pos.y != y
X		    || dig_level != dlevel || dig_down) {
X			dig_down = FALSE;
X			dig_pos.x = x;
X			dig_pos.y = y;
X			dig_level = dlevel;
X			dig_effort = 30;
X			You("start chewing a hole in the rock.");
X			return;
X		} else if ((dig_effort += 30) < 100)  {
X		    if(flags.verbose)
X			You("continue chewing the rock up.");
X		    return;
X		} else {
X			if (IS_WALL(tmpr->typ)) {
X				digtxt = "You chew a hole in the wall.";
X				if(!is_maze_lev)
X				  tmpr->typ = DOOR;
X				else
X				  tmpr->typ = ROOM;
X			} else if (tmpr->typ==SDOOR) {
X				digtxt = "You chew through a secret door.";
X				tmpr->typ = DOOR;
X				if(!(tmpr->doormask & D_TRAPPED))
X					tmpr->doormask = D_BROKEN;
X			} else {
X				digtxt = "You chew a passage through the rock.";
X				tmpr->typ = CORR;
X			}
X			mnewsym(x, y);
X			prl(x, y);
X			pline(digtxt);
X			if(IS_DOOR(tmpr->typ) && (tmpr->doormask & D_TRAPPED)) {
X				b_trapped("door");
X				tmpr->doormask = D_NODOOR;
X				mnewsym(x, y);
X				prl(x, y);
X			}
X			dig_level = -1;
X		}
X	}
X#endif
X	u.ux += u.dx;
X	u.uy += u.dy;
X	reset_occupations();
X	if(flags.run) {
X		if(IS_DOOR(tmpr->typ) ||
X#ifdef POLYSELF
X		(IS_ROCK(tmpr->typ)) ||
X#endif
X		(xupstair == u.ux && yupstair == u.uy) ||
X		(xdnstair == u.ux && ydnstair == u.uy)
X#ifdef STRONGHOLD
X		|| (xupladder == u.ux && yupladder == u.uy)
X		|| (xdnladder == u.ux && ydnladder == u.uy)
X#endif
X#ifdef FOUNTAINS
X		|| IS_FOUNTAIN(tmpr->typ)
X#endif
X#ifdef THRONES
X		|| IS_THRONE(tmpr->typ)
X#endif
X#ifdef SINKS
X		|| IS_SINK(tmpr->typ)
X#endif
X#ifdef ALTARS
X		|| IS_ALTAR(tmpr->typ)
X#endif
X		)
X			nomul(0);
X	}
X#ifdef POLYSELF
X	if (hides_under(uasmon))
X	    u.uundetected = (OBJ_AT(u.ux, u.uy) || levl[u.ux][u.uy].gmask);
X	else if (u.dx || u.dy) { /* piercer */
X	    if (u.usym == S_MIMIC_DEF)
X		u.usym = S_MIMIC;
X	    u.uundetected = 0;
X	}
X#endif
X
X/*
X	if(u.udispl) {
X		u.udispl = 0;
X		newsym(u.ux0,u.uy0);
X	}
X*/
X	if(!Blind) {
X	    register xchar backx = u.ux0 - u.dx;   /* one step beyond old pos */
X	    register xchar backy = u.uy0 - u.dy;
X	    register xchar frontx = u.ux + u.dx;   /* one step beyond new pos */
X	    register xchar fronty = u.uy + u.dy;
X	    register boolean newedge = is_edge(u.ux,u.uy);
X	    register boolean oldedge = is_edge(u.ux0,u.uy0);
X
X	    /* ust is old position, tmpr is new position */
X	    if(oldedge && newedge && inroom(u.ux0,u.uy0) == inroom(u.ux,u.uy)) {
X		/* moving along wall */
X		nose1(backx,backy);
X		prl1(frontx,fronty);
X
X	    } else if(oldedge || newedge) {
X		if(isok(backx,backy) && levl[backx][backy].lit)
X		    setsee();
X		else
X		    nose1(backx,backy);
X
X		if(isok(frontx,fronty) && levl[frontx][fronty].lit)
X		    setsee();
X		else {
X		    prl1(frontx,fronty);
X		    prl1(u.ux,u.uy);    /* make sure side walls are seen */
X		}
X
X	    } else if(!tmpr->lit) {
X		/* we haven't crossed an edge, so old & new are both light or
X		 * both dark.  if both light, we need do nothing.
X		 */
X		nose1(backx,backy);
X		prl1(frontx,fronty);
X	    }
X
X	} else {
X		pru();
X	}
X#ifdef WALKIES
X	check_leash(u.ux0,u.uy0);
X#endif
X	if(u.ux0 != u.ux || u.uy0 != u.uy) u.umoved = TRUE;
X	spoteffects();
X}
X
X#endif /* OVL1 */
X#ifdef OVL2
X
Xvoid
Xspoteffects()
X{
X	register struct trap *trap;
X
X	if(is_pool(u.ux,u.uy) && !(Levitation || Wwalking
X#ifdef POLYSELF
X	    || is_flyer(uasmon)
X#endif
X	    ))
X		drown();	/* not necessarily fatal */
X	else {
X		(void) inshop();
X#ifdef SINKS
X		if(IS_SINK(levl[u.ux][u.uy].typ) && Levitation)
X			dosinkfall();
X#endif
X		if(!flags.nopick &&
X		   (OBJ_AT(u.ux, u.uy) || levl[u.ux][u.uy].gmask))
X			pickup(1);
X		else read_engr_at(u.ux,u.uy);
X		if(trap = t_at(u.ux,u.uy))
X			dotrap(trap);	/* fall into pit, arrow trap, etc. */
X	}
X
X}
X
X#endif /* OVL2 */
X#ifdef OVLB
X
Xint
Xdopickup() {
X	/* uswallow case added by GAN 01/29/87 */
X	if(u.uswallow)  {
X		if (is_animal(u.ustuck->data)) {
X		    You("pick up %s's tongue.", mon_nam(u.ustuck));
X		    pline("But it's kind of slimy, so you drop it.");
X		} else
X		    You("don't %s anything in here to pick up.",
X			  Blind ? "feel" : "see");
X		return(1);
X	}
X	if(!OBJ_AT(u.ux, u.uy) && levl[u.ux][u.uy].gmask == 0) {
X		pline("There is nothing here to pick up.");
X		return(0);
X	}
X	if(Levitation) {
X		You("cannot reach the floor.");
X		return(1);
X	}
X	pickup(0);
X	return(1);
X}
X
X#endif /* OVLB */
X#ifdef OVL2
X
X/* stop running if we see something interesting */
X/* turn around a corner if that is the only way we can proceed */
X/* do not turn left or right twice */
Xvoid
Xlookaround() {
X	register int x, y, i, x0, y0, m0, i0 = 9, corrct = 0, noturn = 0;
X	register struct monst *mtmp;
X#if defined(LINT) || defined(__GNULINT__)
X	/* suppress "used before set" message */
X	x0 = y0 = m0 = 0;
X#endif
X	if(Blind || flags.run == 0) return;
X	for(x = u.ux-1; x <= u.ux+1; x++) for(y = u.uy-1; y <= u.uy+1; y++) {
X		if(!isok(x,y)) continue;
X#ifdef POLYSELF
X		if(u.umonnum == PM_GRID_BUG && x != u.ux && y != u.uy) continue;
X#endif
X		if(x == u.ux && y == u.uy) continue;
X		if((mtmp = m_at(x,y)) && !mtmp->mimic &&
X		    (!mtmp->minvis || See_invisible) && !mtmp->mundetected) {
X			if((flags.run != 1 && !mtmp->mtame)
X					|| (x == u.ux+u.dx && y == u.uy+u.dy))
X				goto stop;
X		}
X		if(levl[x][y].typ == STONE) continue;
X		if(x == u.ux-u.dx && y == u.uy-u.dy) continue;
X		{
X		register uchar sym = levl[x][y].scrsym;
X
X		if (IS_ROCK(levl[x][y].typ) ||
X		   (sym == ROOM_SYM && !IS_DOOR(levl[x][y].typ)))
X		     continue;
X		else if (sym == CLOSED_DOOR_SYM) {
X			if(x != u.ux && y != u.uy) continue;
X			if(flags.run != 1) goto stop;
X			goto bcorr;
X		} else if (sym == CORR_SYM) {
X		bcorr:
X			if(levl[u.ux][u.uy].typ != ROOM) {
X			    if(flags.run == 1 || flags.run == 3) {
X				i = dist2(x,y,u.ux+u.dx,u.uy+u.dy);
X				if(i > 2) continue;
X				if(corrct == 1 && dist2(x,y,x0,y0) != 1)
X					noturn = 1;
X				if(i < i0) {
X					i0 = i;
X					x0 = x;
X					y0 = y;
X					m0 = mtmp ? 1 : 0;
X				}
X			    }
X			    corrct++;
X			}
X			continue;
X		} else if (sym == TRAP_SYM) {
X			if(flags.run == 1) goto bcorr;	/* if you must */
X			if(x == u.ux+u.dx && y == u.uy+u.dy) goto stop;
X			continue;
X		} else if (sym == POOL_SYM) {
X			/* pools only stop you if directly in front, and stop
X			 * you even if you are running
X			 */
X			if(!Levitation &&
X#ifdef POLYSELF
X				!is_flyer(uasmon) &&
X#endif
X				/* No Wwalking check; otherwise they'd be able
X				 * to test boots by trying to SHIFT-direction
X				 * into a pool and seeing if the game allowed it
X				 */
X				x == u.ux+u.dx && y == u.uy+u.dy) goto stop;
X			continue;
X		} else {		/* e.g. objects or trap or stairs */
X			if(flags.run == 1) goto bcorr;
X			if(mtmp) continue;		/* d */
X		}
X		stop:
X			nomul(0);
X			return;
X		}
X	}
X	if(corrct > 1 && flags.run == 2) goto stop;
X	if((flags.run == 1 || flags.run == 3) && !noturn && !m0 && i0 &&
X		(corrct == 1 || (corrct == 2 && i0 == 1))) {
X		/* make sure that we do not turn too far */
X		if(i0 == 2) {
X		    if(u.dx == y0-u.uy && u.dy == u.ux-x0)
X			i = 2;		/* straight turn right */
X		    else
X			i = -2;		/* straight turn left */
X		} else if(u.dx && u.dy) {
X		    if((u.dx == u.dy && y0 == u.uy) ||
X			(u.dx != u.dy && y0 != u.uy))
X			i = -1;		/* half turn left */
X		    else
X			i = 1;		/* half turn right */
X		} else {
X		    if((x0-u.ux == y0-u.uy && !u.dy) ||
X			(x0-u.ux != y0-u.uy && u.dy))
X			i = 1;		/* half turn right */
X		    else
X			i = -1;		/* half turn left */
X		}
X		i += u.last_str_turn;
X		if(i <= 2 && i >= -2) {
X			u.last_str_turn = i;
X			u.dx = x0-u.ux, u.dy = y0-u.uy;
X		}
X	}
X}
X
X/* something like lookaround, but we are not running */
X/* react only to monsters that might hit us */
Xint
Xmonster_nearby() {
X	register int x,y;
X	register struct monst *mtmp;
X
X	if(!Blind)
X	for(x = u.ux-1; x <= u.ux+1; x++)
X	    for(y = u.uy-1; y <= u.uy+1; y++) {
X		if(!isok(x,y)) continue;
X		if(x == u.ux && y == u.uy) continue;
X		if((mtmp = m_at(x,y)) && !mtmp->mimic &&
X		   !mtmp->mtame && !mtmp->mpeaceful &&
X		   !noattacks(mtmp->data) &&
X		   mtmp->mcanmove && !mtmp->msleep &&  /* aplvax!jcn */
X		   (!mtmp->minvis || See_invisible) &&
X		   !onscary(u.ux, u.uy, mtmp))
X			return(1);
X	}
X	return(0);
X}
X
X#endif /* OVL2 */
X#ifdef OVL0
X
Xint
Xcansee(x,y)
Xxchar x,y;
X{
X	if(Blind || (u.uswallow && (x != u.ux || y != u.uy))) return(0);
X	if(IS_ROCK(levl[x][y].typ) && levl[u.ux][u.uy].typ == CORR &&
X				!MON_AT(x, y) && !levl[u.ux][u.uy].lit)
X		return(0);
X	if(dist(x,y) < 3) return(1);
X	if(levl[x][y].lit &&
X		((seelx <= x && x <= seehx && seely <= y && y <= seehy) ||
X		(seelx2 <= x && x <= seehx2 && seely2 <= y && y <= seehy2)))
X		return(1);
X	return(0);
X}
X
X#endif /* OVL0 */
X#ifdef OVL1
X
Xint
Xsgn(a)
X	register int a;
X{
X	return((a > 0) ? 1 : (a == 0) ? 0 : -1);
X}
X
X#endif /* OVL1 */
X#ifdef OVL2
X
Xvoid
Xgetcorners(lx1,hx1,ly1,hy1,lx2,hx2,ly2,hy2)
Xxchar *lx1,*hx1,*ly1,*hy1,*lx2,*hx2,*ly2,*hy2;
X/* return corners of one or two rooms player is in, so we can tell what areas
X * can be seen, or otherwise affected by room-specific things.  (two rooms are
X * possible when in a doorway of the stronghold)
X * the player is already known to be in at least one room
X */
X{
X	register int uroom1,uroom2;
X	register xchar ux,uy;
X
X	uroom1 = inroom(u.ux,u.uy);
X	*lx1 = rooms[uroom1].lx - 1;
X	*hx1 = rooms[uroom1].hx + 1;
X	*ly1 = rooms[uroom1].ly - 1;
X	*hy1 = rooms[uroom1].hy + 1;
X
X	if(!IS_DOOR(levl[u.ux][u.uy].typ)) {
X		*lx2 = 1;
X		*hx2 = 0;
X		*ly2 = 1;
X		*hy2 = 0;
X	} else {
X		for(ux = u.ux-1; ux <= u.ux+1; ux++)
X			for(uy = u.uy-1; uy <= u.uy+1; uy++) {
X				if(!isok(ux,uy)) continue;
X				if(IS_ROCK(levl[ux][uy].typ) ||
X					IS_DOOR(levl[ux][uy].typ)) continue;
X				/* might have side-by-side walls, in which case
X				 * should only be able to see one room */
X				uroom2 = inroom(ux,uy);
X				if(uroom2 >= 0 && uroom2 != uroom1 && 
X				   rooms[uroom2].rlit) {
X					*lx2 = rooms[uroom2].lx - 1;
X					*ly2 = rooms[uroom2].ly - 1;
X					*hx2 = rooms[uroom2].hx + 1;
X					*hy2 = rooms[uroom2].hy + 1;
X					return;
X				}
X			}
X		*lx2 = 1;
X		*hx2 = 0;
X		*ly2 = 1;
X		*hy2 = 0;
X	}
X}
X
X#endif /* OVL2 */
X#ifdef OVL1
X
Xvoid
Xsetsee() {
X	register int x, y;
X
X	if(Blind) {
X		pru();
X		return;
X	}
X	if(!levl[u.ux][u.uy].lit) {
X		seelx = u.ux-1;
X		seehx = u.ux+1;
X		seely = u.uy-1;
X		seehy = u.uy+1;
X		seelx2 = seely2 = 1;
X		seehx2 = seehy2 = 0;
X	} else {
X		getcorners(&seelx,&seehx,&seely,&seehy,
X			   &seelx2,&seehx2,&seely2,&seehy2);
X	}
X	for(y = seely; y <= seehy; y++)
X		for(x = seelx; x <= seehx; x++) {
X			prl(x,y);
X	}
X	for(y = seely2; y <= seehy2; y++)
X		for(x = seelx2; x <= seehx2; x++) {
X			prl(x,y);
X	}
X	if(!levl[u.ux][u.uy].lit) seehx = 0; /* seems necessary elsewhere */
X	else {
X	    if(seely == u.uy) for(x = u.ux-1; x <= u.ux+1; x++) prl(x,seely-1);
X	    if(seehy == u.uy) for(x = u.ux-1; x <= u.ux+1; x++) prl(x,seehy+1);
X	    if(seelx == u.ux) for(y = u.uy-1; y <= u.uy+1; y++) prl(seelx-1,y);
X	    if(seehx == u.ux) for(y = u.uy-1; y <= u.uy+1; y++) prl(seehx+1,y);
X	}
X}
X
X#endif /* OVL1 */
X#ifdef OVL2
X
Xvoid
Xnomul(nval)
X	register int nval;
X{
X	if(multi < nval) return;	/* This is a bug fix by ab@unido */
X	multi = nval;
X	flags.mv = flags.run = 0;
X}
X
X#endif /* OVL2 */
X#ifdef OVL1
X
Xvoid
Xlosehp(n, knam, k_format)
Xregister int n;
Xregister const char *knam;
Xboolean k_format;
X{
X#ifdef POLYSELF
X	if (u.mtimedone) {
X		u.mh -= n;
X		if (u.mhmax < u.mh) u.mhmax = u.mh;
X		flags.botl = 1;
X		if (u.mh < 1) rehumanize();
X		return;
X	}
X#endif
X	u.uhp -= n;
X	if(u.uhp > u.uhpmax)
X		u.uhpmax = u.uhp;	/* perhaps n was negative */
X	flags.botl = 1;
X	if(u.uhp < 1) {
X		killer_format = k_format;
X		killer = knam;		/* the thing that killed you */
X		You("die...");
X		done(DIED);
X	} else if(u.uhp*10 < u.uhpmax && moves-wailmsg > 50 && n > 0){
X		wailmsg = moves;
X		if(index("WEV", pl_character[0])) {
X			if (u.uhp == 1)
X				pline("%s is about to die.", pl_character);
X			else if (4 <= (!!(HTeleportation & INTRINSIC)) +
X				    (!!(HSee_invisible & INTRINSIC)) +
X				    (!!(HPoison_resistance & INTRINSIC)) +
X				    (!!(HCold_resistance & INTRINSIC)) +
X				    (!!(HShock_resistance & INTRINSIC)) +
X				    (!!(HFire_resistance & INTRINSIC)) +
X				    (!!(HSleep_resistance & INTRINSIC)) +
X				    (!!(HDisint_resistance & INTRINSIC)) +
X				    (!!(HTeleport_control & INTRINSIC)) +
X				    (!!(Stealth & INTRINSIC)) +
X				    (!!(Fast & INTRINSIC)) +
X				    (!!(HInvis & INTRINSIC)))
X				pline("%s, all your powers will be lost...",
X					pl_character);
X			else
X				pline("%s, your life force is running out.",
X					pl_character);
X		} else {
X			if(u.uhp == 1)
X				You("hear the wailing of the Banshee...");
X			else
X				You("hear the howling of the CwnAnnwn...");
X		}
X	}
X}
X
Xint
Xweight_cap() {
X	register int carrcap;
X
X#ifdef HARD
X	carrcap = 5 * (((ACURR(A_STR) > 18) ? 20 : ACURR(A_STR)) + u.ulevel);
X#else
X	carrcap = 5 * u.ulevel;      /* New strength stewr 870807 */
X	if (ACURR(A_STR) < 19) carrcap += 5 * ACURR(A_STR);
X	if (ACURR(A_STR) > 18) carrcap += ACURR(A_STR) - 18 + 90;
X	if (ACURR(A_STR) > 68) carrcap += ACURR(A_STR) - 68;
X	if (ACURR(A_STR) > 93) carrcap += ACURR(A_STR) - 93;
X	if (ACURR(A_STR) > 108) carrcap += 2 * (ACURR(A_STR) - 108);
X	if (ACURR(A_STR) > 113) carrcap += 5 * (ACURR(A_STR) - 113);
X	if (ACURR(A_STR) == 118) carrcap += 100;
X#endif
X#ifdef POLYSELF
X	if (u.mtimedone) {
X		/* consistent with can_carry() in mon.c */
X		if (u.usym==S_NYMPH) carrcap = MAX_CARR_CAP;
X		else if (!uasmon->cwt)
X			carrcap = (carrcap * uasmon->mlevel * 6)/45;
X		else if (!strongmonst(uasmon)
X			|| (strongmonst(uasmon) && (uasmon->cwt > 45)))
X			carrcap = (carrcap * uasmon->cwt / 45);
X	}
X#endif
X	if(Levitation) 			/* pugh@cornell */
X		carrcap = MAX_CARR_CAP;
X	else {
X		if(carrcap > MAX_CARR_CAP) carrcap = MAX_CARR_CAP;
X		if(Wounded_legs & LEFT_SIDE) carrcap -= 10;
X		if(Wounded_legs & RIGHT_SIDE) carrcap -= 10;
X	}
X	return(carrcap);
X}
X
Xint
Xinv_weight() {
X	register struct obj *otmp = invent;
X#ifdef LINT	/* long to int conversion */
X	register int wt = 0;
X#else
X	register int wt = (int)((u.ugold + 500L)/1000L);
X#endif /* LINT */
X	while(otmp){
X#ifdef POLYSELF
X		if (otmp->otyp != BOULDER || !throws_rocks(uasmon))
X#endif
X			wt += otmp->owt;
X		otmp = otmp->nobj;
X	}
X	return(wt - weight_cap());
X}
X
X#endif /* OVL1 */
X#ifdef OVLB
X
Xint
Xinv_cnt() {
X	register struct obj *otmp = invent;
X	register int ct = 0;
X
X	while(otmp){
X		ct++;
X		otmp = otmp->nobj;
X	}
X	return(ct);
X}
X
Xint
Xidentify(otmp)		/* also called by newmail() */
X	register struct obj *otmp;
X{
X	makeknown(otmp->otyp);
X	otmp->known = otmp->dknown = otmp->bknown = 1;
X	prinv(otmp);
X	return(1);
X}
X
X#ifdef STUPID_CPP	/* otherwise these functions are macros in hack.h */
Xchar
Xyn() {
X	return(yn_function(ynchars, 'n'));
X}
X
Xchar
Xynq() {
X	return(yn_function(ynqchars, 'q'));
X}
X
Xchar
Xynaq() {
X	return(yn_function(ynaqchars, 'y'));
X}
X
Xchar
Xnyaq() {
X	return(yn_function(nyaqchars, 'n'));
X}
X
Xint
Xmax(a,b) int a,b; {
X	return((a > b) ? a : b);
X}
X
Xint
Xmin(a,b) int a,b; {
X	return((a < b) ? a : b);
X}
X
Xchar *
Xplur(x) long x; {
X	return((x == 1L) ? "" : "s");
X}
X
Xvoid
Xmakeknown(x) unsigned x; {
X	objects[x].oc_name_known = 1;
X}
X#endif /* STUPID_CPP */
X
X#endif /* OVLB */
END_OF_FILE
if test 28166 -ne `wc -c <'src/hack.c'`; then
    echo shar: \"'src/hack.c'\" unpacked with wrong size!
fi
# end of 'src/hack.c'
fi
if test -f 'src/wield.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/wield.c'\"
else
echo shar: Extracting \"'src/wield.c'\" \(6236 characters\)
sed "s/^X//" >'src/wield.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)wield.c	3.0	87/05/10
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include	"hack.h"
X
X/* Note: setuwep() with a null obj, and uwepgone(), are NOT the same!  Sometimes
X * unwielding a weapon can kill you, and lifesaving will then put it back into
X * your hand.  If lifesaving is permitted to do this, use
X * setwuep((struct obj *)0); otherwise use uwepgone().
X * (The second function should probably be #ifdef NAMED_ITEMS since only then
X * may unwielding a weapon kill you, but...)
X */
Xvoid
Xsetuwep(obj)
Xregister struct obj *obj;
X{
X	setworn(obj, W_WEP);
X	if (!obj) unweapon = TRUE;	/* for "bare hands" message */
X}
X
Xvoid
Xuwepgone()
X{
X	if (uwep) {
X		setnotworn(uwep);
X		unweapon = TRUE;
X	}
X}
X
Xstatic const char NEARDATA wield_objs[] = { '#', '-', WEAPON_SYM, TOOL_SYM, 0 };
X
Xint
Xdowield()
X{
X	register struct obj *wep;
X	register int res = 0;
X
X	multi = 0;
X#ifdef POLYSELF
X	if (cantwield(uasmon)) {
X		pline("Don't be ridiculous!");
X		return(0);
X	}
X#endif
X	if(!(wep = getobj(wield_objs, "wield"))) /* nothing */;
X	else if(uwep == wep)
X		You("are already wielding that!");
X	else if(welded(uwep))
X		weldmsg(uwep, TRUE);
X	else if(wep == &zeroobj) {
X	    if(uwep == 0)
X		You("are already empty %s.", body_part(HANDED));
X	    else  {
X	  	You("are empty %s.", body_part(HANDED));
X	  	setuwep((struct obj *) 0);
X	  	res++;
X	    }
X	} else if(!uarmg &&
X#ifdef POLYSELF
X		!resists_ston(uasmon) &&
X#endif
X		(wep->otyp == CORPSE && wep->corpsenm == PM_COCKATRICE)) {
X	    /* Prevent wielding cockatrice when not wearing gloves --KAA */
X	    You("wield the cockatrice corpse in your bare %s.",
X			makeplural(body_part(HAND)));
X	    You("turn to stone...");
X	    killer_format = KILLED_BY;
X	    killer="touching a cockatrice corpse";
X	    done(STONING);
X	} else if(uarms && bimanual(wep))
X	    You("cannot wield a two-handed %s and hold a shield.",
X		 is_sword(wep) ? "sword" : "weapon");
X	else if(wep->owornmask & (W_ARMOR | W_RING | W_AMUL | W_TOOL))
X		You("cannot wield that!");
X	else {
X		res++;
X		if(wep->cursed && (wep->olet == WEAPON_SYM ||
X			wep->otyp == HEAVY_IRON_BALL || wep->otyp == PICK_AXE ||
X			wep->otyp == UNICORN_HORN ||
X			wep->otyp == TIN_OPENER)) {
X		    pline("The %s %s to your %s!",
X			aobjnam(wep, "weld"),
X			(wep->quan == 1) ? "itself" : "themselves", /* a3 */
X			body_part(HAND));
X		    wep->bknown = 1;
X		} else {
X			/* The message must be printed before setuwep (since
X			 * you might die and be revived from changing weapons),
X			 * and the message must be before the death message and
X			 * Lifesaved rewielding.  Yet we want the message to say
X			 * "weapon in hand", thus this kludge.
X			 */
X			long dummy = wep->owornmask;
X			wep->owornmask |= W_WEP;
X			prinv(wep);
X			wep->owornmask = dummy;
X		}
X		setuwep(wep);
X	}
X	/* Note: Explicitly wielding a pick-axe will not give a "bashing"
X	 * message.  Wielding one via 'a'pplying it will.
X	 */
X	if(res && uwep)
X		unweapon = ((uwep->otyp >= BOW || uwep->otyp <= BOOMERANG) &&
X			uwep->otyp != PICK_AXE && uwep->otyp != UNICORN_HORN);
X	return(res);
X}
X
Xvoid
Xcorrode_weapon(){
X	if(!uwep || uwep->olet != WEAPON_SYM) return;	/* %% */
X	if(uwep->rustfree || objects[uwep->otyp].oc_material != METAL)
X		Your("%s not affected.", aobjnam(uwep, "are"));
X	else if (uwep->spe > -6) {
X		Your("%s!", aobjnam(uwep, "corrode"));
X		uwep->spe--;
X	} else	Your("%s quite rusted now.", aobjnam(uwep, Blind ? "feel" : "look"));
X}
X
Xint
Xchwepon(otmp, amount)
Xregister struct obj *otmp;
Xregister int amount;
X{
X	register const char *color = Hallucination ? hcolor() :
X				     (amount < 0) ? black : blue;
X	register const char *xtime;
X
X	if(!uwep || (uwep->olet != WEAPON_SYM && uwep->otyp != PICK_AXE
X			&& uwep->otyp != UNICORN_HORN)) {
X		char buf[36];
X
X		Sprintf(buf, "Your %s %s.", makeplural(body_part(HAND)),
X			(amount > 0) ? "twitch" : "itch");
X		strange_feeling(otmp, buf);
X		return(0);
X	}
X
X#ifdef WORM
X	if(uwep->otyp == WORM_TOOTH && amount > 0) {
X		uwep->otyp = CRYSKNIFE;
X		Your("weapon seems sharper now.");
X		uwep->cursed = 0;
X		return(1);
X	}
X
X	if(uwep->otyp == CRYSKNIFE && amount < 0) {
X		uwep->otyp = WORM_TOOTH;
X		Your("weapon seems duller now.");
X		return(1);
X	}
X#endif
X#ifdef NAMED_ITEMS
X	if(is_artifact(uwep) && restr_name(uwep, ONAME(uwep)) &&
X		amount<0) {
X	    if (!Blind)
X		Your("%s faintly %s.", aobjnam(uwep, "glow"), color);
X	    return(1);
X	}
X#endif
X	/* there is a (soft) upper and lower limit to uwep->spe */
X	if(((uwep->spe > 5 && amount > 0) || (uwep->spe < -5 && amount < 0))
X								&& rn2(3)) {
X	    if (!Blind)
X	    Your("%s violently %s for a while and then evaporate%s.",
X		aobjnam(uwep,"glow"), color, uwep->quan == 1 ? "s" : "");
X	    else
X		Your("%s.", aobjnam(uwep, "evaporate"));
X
X	    while(uwep)		/* let all of them disappear */
X				/* note: uwep->quan = 1 is nogood if unpaid */
X		useup(uwep);
X	    return(1);
X	}
X	if (!Blind) {
X	    xtime = (amount*amount == 1) ? "moment" : "while";
X	    Your("%s %s for a %s.",
X		  aobjnam(uwep, "glow"), color, xtime);
X	}
X	uwep->spe += amount;
X	if(amount > 0) uwep->cursed = 0;
X	return(1);
X}
X
Xint
Xwelded(obj)
Xregister struct obj *obj;
X{
X	if (obj && obj == uwep && obj->cursed &&
X		  (obj->olet == WEAPON_SYM || obj->otyp == HEAVY_IRON_BALL ||
X		   obj->otyp == TIN_OPENER || obj->otyp == PICK_AXE ||
X		   obj->otyp == UNICORN_HORN))
X	{
X		obj->bknown = 1;
X		return 1;
X	}
X	return 0;
X}
X
X/* The reason for "specific" is historical; some parts of the code used
X * the object name and others just used "weapon"/"sword".  This function
X * replaced all of those.  Which one we use is really arbitrary.
X */
Xvoid
Xweldmsg(obj, specific)
Xregister struct obj *obj;
Xboolean specific;
X{
X	char buf[BUFSZ];
X
X	if (specific) {
X		long savewornmask = obj->owornmask;
X		obj->owornmask &= ~W_WEP;
X		Strcpy(buf, Doname2(obj));
X		obj->owornmask = savewornmask;
X	} else
X		Sprintf(buf, "Your %s%s",
X			is_sword(obj) ? "sword" : "weapon",
X			plur((long)obj->quan));
X	Strcat(buf, (obj->quan==1) ? " is" : " are");
X#ifdef POLYSELF
X	Sprintf(eos(buf), " welded to your %s!",
X		bimanual(obj) ? makeplural(body_part(HAND)) : body_part(HAND));
X#else
X	Sprintf(eos(buf), " welded to your hand%s!",
X		bimanual(obj) ? "s" : "");
X#endif
X	pline(buf);
X}
END_OF_FILE
if test 6236 -ne `wc -c <'src/wield.c'`; then
    echo shar: \"'src/wield.c'\" unpacked with wrong size!
fi
# end of 'src/wield.c'
fi
echo shar: End of archive 35 \(of 56\).
cp /dev/null ark35isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 56 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
