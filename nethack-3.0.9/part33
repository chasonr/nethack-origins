Path: utzoo!attcan!uunet!mailrus!cornell!uw-beaver!zephyr.ens.tek.com!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v10i078:  nethack3p9 -  display oriented dungeons & dragons (Ver. 3.0i), Part33/56
Message-ID: <5936@tekred.CNA.TEK.COM>
Date: 12 Jul 90 16:07:08 GMT
Sender: news@tekred.CNA.TEK.COM
Lines: 2081
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 10, Issue 78
Archive-name: nethack3p9/Part33
Supersedes: NetHack3: Volume 7, Issue 56-93



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 33 (of 56)."
# Contents:  include/def_os2.h mac/mac.c others/Makefile.ovl
# Wrapped by billr@saab on Wed Jul 11 17:11:41 1990
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'include/def_os2.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/def_os2.h'\"
else
echo shar: Extracting \"'include/def_os2.h'\" \(2615 characters\)
sed "s/^X//" >'include/def_os2.h' <<'END_OF_FILE'
X/*	SCCS Id: @(#)def_os2.h	3.0	89/08/13
X
X/*  OS/2 defines based on MSC 5.1 OS/2 include files.
X    Only a small portion of all OS/2 defines are needed,
X    so the actual include files are not used.
X
X    Timo Hakulinen
X */
X
X#define APIENTRY pascal far
X
X#define CHAR	char		/* ch  */
X#define SHORT	int		/* s   */
X#define LONG	long		/* l   */
X#define INT	int		/* i   */
X
Xtypedef unsigned char UCHAR;	/* uch */
Xtypedef unsigned int  USHORT;	/* us  */
Xtypedef unsigned long ULONG;	/* ul  */
Xtypedef unsigned int  UINT;	/* ui  */
X
Xtypedef unsigned char BYTE;	/* b   */
Xtypedef BYTE   far *PBYTE;
X
Xtypedef unsigned short	SHANDLE;
Xtypedef SHANDLE 	HKBD;
Xtypedef SHANDLE 	HVIO;
Xtypedef SHANDLE 	HDIR;	/* hdir */
Xtypedef HDIR far *PHDIR;
X
Xtypedef USHORT far *PUSHORT;
Xtypedef char far *PSZ;
X
Xtypedef struct {
X	UCHAR  chChar;
X	UCHAR  chScan;
X	UCHAR  fbStatus;
X	UCHAR  bNlsShift;
X	USHORT fsState;
X	ULONG  time;
X} KBDKEYINFO;
Xtypedef KBDKEYINFO far *PKBDKEYINFO;
X
X/* File time and date types */
X
Xtypedef struct _FTIME { 	/* ftime */
X    unsigned twosecs : 5;
X    unsigned minutes : 6;
X    unsigned hours   : 5;
X} FTIME;
Xtypedef FTIME far *PFTIME;
X
Xtypedef struct _FDATE { 	/* fdate */
X    unsigned day     : 5;
X    unsigned month   : 4;
X    unsigned year    : 7;
X} FDATE;
Xtypedef FDATE far *PFDATE;
X
Xtypedef struct _FILEFINDBUF {	/* findbuf */
X	FDATE  fdateCreation;
X	FTIME  ftimeCreation;
X	FDATE  fdateLastAccess;
X	FTIME  ftimeLastAccess;
X	FDATE  fdateLastWrite;
X	FTIME  ftimeLastWrite;
X	ULONG  cbFile;
X	ULONG  cbFileAlloc;
X	USHORT attrFile;
X	UCHAR  cchName;
X	CHAR   achName[13];
X} FILEFINDBUF;
Xtypedef FILEFINDBUF far *PFILEFINDBUF;
X
X/* KBDINFO structure, for KbdSet/GetStatus */
Xtypedef struct _KBDINFO {	/* kbst */
X	USHORT cb;
X	USHORT fsMask;
X	USHORT chTurnAround;
X	USHORT fsInterim;
X	USHORT fsState;
X} KBDINFO;
Xtypedef KBDINFO far *PKBDINFO;
X
X/* VIOMODEINFO structure, for VioGetMode */
Xtypedef struct _VIOMODEINFO {
X	USHORT cb;
X	UCHAR  fbType;
X	UCHAR  color;
X	USHORT col;
X	USHORT row;
X	USHORT hres;
X	USHORT vres;
X	UCHAR  fmt_ID;
X	UCHAR  attrib;
X} VIOMODEINFO;
Xtypedef VIOMODEINFO far *PVIOMODEINFO;
X
X/* OS2 API functions */
X
XUSHORT APIENTRY KbdGetStatus(PKBDINFO, HKBD);
XUSHORT APIENTRY KbdSetStatus(PKBDINFO, HKBD);
XUSHORT APIENTRY KbdCharIn(PKBDKEYINFO, USHORT, HKBD );
XUSHORT APIENTRY DosQFSInfo(USHORT, USHORT, PBYTE, USHORT);
XUSHORT APIENTRY DosFindFirst(PSZ, PHDIR, USHORT, PFILEFINDBUF, USHORT, PUSHORT, ULONG);
XUSHORT APIENTRY DosFindNext(HDIR, PFILEFINDBUF, USHORT, PUSHORT);
XUSHORT APIENTRY DosSelectDisk(USHORT);
XUSHORT APIENTRY VioGetMode(PVIOMODEINFO, HVIO);
XUSHORT APIENTRY VioSetCurPos(USHORT, USHORT, HVIO);
END_OF_FILE
if test 2615 -ne `wc -c <'include/def_os2.h'`; then
    echo shar: \"'include/def_os2.h'\" unpacked with wrong size!
fi
# end of 'include/def_os2.h'
fi
if test -f 'mac/mac.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mac/mac.c'\"
else
echo shar: Extracting \"'mac/mac.c'\" \(28936 characters\)
sed "s/^X//" >'mac/mac.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)mac.c	3.0	88/08/05
X/*      Copyright (c) Johnny Lee  1989	*/ 
X/* NetHack may be freely redistributed.  See license for details. */
X
X/*	Source file for character I/O and miscellaneous */
X/*	user interface routines for the macintosh */
X
X#include	"hack.h"
X
X/* Global variables */
XWindowPtr	HackWindow;	/* points to Hack's window */
Xextern char	*keys[8];
Xextern short macflags;
Xextern long lowMemLimit;
Xshort cursorPos=0;
Xshort repDelay;
Xlong lastMD;
Xlong segments = SEG_DO;
Xextern short altCurs; /* should be a macflag */
X
Xint
Xtgetch()
X
X{
X	char	ch;
X	EventRecord	theEvent;
X	Rect cursorRect,box,windowRect;
X	long	message,cursorTime,start;
X	MenuHandle	theMenu;
X	register short	keyCode;
X	short	temp;
X	term_info	*t;
X	GrafPtr	oldPort,oldPort1;
X	static char nextCommand;
X	short aboutBox();
X	char mButtonDown();
X	Point	mouseLoc;
X	WindowPtr	theWindow;
X	void	doUpdate();
X#define	clearKey	0x47
X#define ESCAPEkey	0x1B
X	static int see, saw = 0;
X	int eye, cursOff = 100;
X	boolean cursRectInv;	/* should be a macflag */
X	short	fInFront = TRUE;
X
X	t = (term_info *)GetWRefCon(HackWindow);
X	mouseLoc.h = (macflags & fMoveWRTMouse) ? t->tcur_x : (u.ux-1);
X	mouseLoc.v = (macflags & fMoveWRTMouse) ? t->tcur_y : (u.uy+1);
X	cursorRect.left = t->tcur_x * t->charWidth + Screen_Border;
X	cursorRect.right = cursorRect.left + t->charWidth - 1;
X	cursorRect.top = t->height * t->tcur_y + Screen_Border;
X	cursorRect.bottom = cursorRect.top + t->height - 1;
X	cursorTime = GetCaretTime();
X	box.left = mouseLoc.h * t->charWidth + Screen_Border - 1;
X	box.right = box.left + t->charWidth + 2;
X	box.top = mouseLoc.v * t->height + Screen_Border - 1;
X	box.bottom = box.top + t->height + 2;
X	/* permit use of cursor keys and numeric keypad */
X	/* does the same translation as in msdos.c but includes cursor keys */
X	ch = '\0';
X	/* handle extended command from menu */
X	if (nextCommand && (macflags & (fExtCmdSeq1 | fExtCmdSeq2 | fExtCmdSeq3))) {
X	    if (macflags & fExtCmdSeq1) {
X		ch = '#';
X		macflags = macflags ^ (fExtCmdSeq1 | fExtCmdSeq2);
X	    } else if (macflags & fExtCmdSeq2) {
X		ch = nextCommand;
X		macflags = macflags ^ (fExtCmdSeq2 | fExtCmdSeq3);
X		if (!(macflags & fExtCmdSeq3))
X		    nextCommand = '\0';
X	    } else if (macflags & fExtCmdSeq3) {
X		ch = '\r';
X		macflags &= ~fExtCmdSeq3;
X	    }
X	}
X	GetPort(&oldPort);
X	SetPort(HackWindow);
X	if (!(macflags & fDoNonKeyEvt)) {
X		cursorPos = -1;
X		if (! flags.wantspace) SetCursor(&ARROW_CURSOR);
X	}
X	/* initialize cursor blinking */
X	message = TickCount();
X	cursRectInv = FALSE;
X	while (!ch) {
X		(void)WaitNextEvent(everyEvent, &theEvent, (fInFront) ? 0L : 50L, 0L);
X		if (theEvent.what == keyDown || theEvent.what == autoKey) {
X			ch = 0;
X			ObscureCursor();
X			/* use raw key codes */
X			keyCode = (LoWord(theEvent.message) & keyCodeMask)>>8;
X 			if (keyCode == clearKey) {
X				macflags = macflags ^ fToggleNumPad;
X				SetWTitle(HackWindow,
X					(macflags & fToggleNumPad)	? "\016NetHack [MOVE]"
X												: "\015NetHack [NUM]");
X				ch = 0;
X				continue;
X			}
X			if ((macflags & fToggleNumPad) && (keyCode>0x40 &&keyCode < 0x5D) 
X				|| (keyCode > 0x7A && keyCode<0x7F)) {
X				ch = t->keyMap[keyCode-65];
X				if ((theEvent.modifiers & shiftKey) && (ch)) {
X					ch = (ch == '.') ? ':' : (char)toupper(ch);
X				}
X				if (ch)
X					break;
X			}
X			if (t->system.keyBoardType < 4 && keyCode == 50) {
X				ch = (char)ESCAPEkey;	/* ESC */
X				break;
X			}			/* make the command key = control key on all non-adb keyboards
X						 Now, LEAVE it this way ! Otherwise you'll render non-us
Xkeyboards useless, since here is where "<" and ">" are located */
X			if ((theEvent.message & 0xFF) == 0x60) {
X				ch = (char)ESCAPEkey;
X				break;
X			} /* This is the way to fix backquote->esc for all macs */
X			if (theEvent.modifiers & cmdKey) {
X				ch = (char)(theEvent.message & 0x1F);
X				if(ch == ('Q' & 0x1F)) ch = 'Q'; /* For Quit */
X				break;
X			}
X			if (theEvent.modifiers & optionKey) {
X				for(start = 43; start < 56; start++) {
X					if (t->keyMap[start] == (char)(theEvent.message & 0xFFL)) {
X						ch = t->keyMap[start - 13];
X						break;
X					}
X				}
X			}
X			/* not a cursor key or from the numeric keypad */
X			if (!ch) {
X				ch = (char)(theEvent.message & 0xFF);
X			}
X		} else {
X		/* what other events to handle */
X			switch (theEvent.what) {		
X			case nullEvent:
X				if (!fInFront)
X					break;
X				GetPort(&oldPort1);
X				SetPort((GrafPtr)HackWindow);
X				/* wait until something occurs */
X				if ((TickCount() > message) && (FrontWindow() == HackWindow)) {
X					message = TickCount() + cursorTime;
X					InvertRect(&cursorRect);
X					cursRectInv = !cursRectInv;
X				}
X				if (FrontWindow() == HackWindow && (macflags & fDoNonKeyEvt)) {
X					if ((FindWindow(theEvent.where,&theWindow) == inContent)
X						&& (macflags & fDoUpdate) && (HackWindow == theWindow)) {
X						
X						GetMouse(&mouseLoc);
X						if (PtInRect(mouseLoc,&box)) {
X							temp = 8;
X						} else {
X							PtToAngle(&box,mouseLoc,&temp);
X							temp = ((temp + 22) / 45) % 8;	/* 0=N, 1=NE ... 7=NW */
X						}
X						/* since we're not doing anything let's look at the cursor */
X						if (altCurs) {	/* this list is prioritized! */
X							if (Sick) {
X								cursOff = 130;	/* offset for CURS resource set */
X								see = SICK;
X							} else if (Blind) {
X								cursOff = 120;
X								see = BLINDED;
X							} else if (Hallucination) {
X								cursOff = 110;
X								see = HALLUC;
X							} else if (Confusion || Stunned) {
X								see = CONFUSION;
X							} else {
X								cursOff = 100;
X								see = 0;
X							}
X						} else {
X							see = (Confusion || Stunned) ? CONFUSION : 0;
X							cursOff = 100;
X						}
X						if ((cursorPos != temp) || (see != saw)) {
X							if (see != saw) {
X								switch(see) {
X								case CONFUSION:
X									break;
X								default:	/* hmm, a bit much for !altCurs */
X									for (eye=0; eye<=8; eye++) {
X										EmptyHandle(t->cursor[eye]);
X										t->cursor[eye] = GetCursor(eye+cursOff);
X										HNoPurge(t->cursor[eye]);
X									}
X									break;
X								}
X								saw = see;
X							}
X							cursorPos = temp;
X							eye = (Confusion || Stunned) ? rn2(9) : temp;
X							SetCursor(*t->cursor[eye]);
X						}
X					} else if (cursorPos>=0) {
X						cursorPos = -1;
X						SetCursor(&ARROW_CURSOR);
X					}
X				}
X				if (StillDown() && cursorPos>=0 && cursorPos < 8
X					&& TickCount() > lastMD+repDelay) {
X					ch = mButtonDown(theEvent, t, &nextCommand);
X					if (repDelay) {
X#ifdef THINK_C
X						repDelay = KeyRepThresh;
X#else
X						repDelay /= 3;
X#endif
X					}
X					lastMD = TickCount();
X					/*return ch;*/
X				}			
X				SetPort(oldPort1);
X				break;
X			case app4Evt:
X#define	kSuspendResumeMessage	1		/* high byte of suspend/resume event message */
X#define	kMouseMovedMessage		0xFA	/* high byte of mouse-moved event message */
X#define	SuspResIsResume(evtMessage)		((evtMessage) & 0x00000001)
X
X				switch (theEvent.message >> 24) {
X					case kSuspendResumeMessage:
X						if (!SuspResIsResume(theEvent.message)) {
X						/* ---------- SUSPEND EVENT ------------ */
X							fInFront = FALSE;
X							if (macflags & fZoomOnContextSwitch
X								&& !EmptyRect(&(**(HackWindow)->visRgn).rgnBBox))
X							{
X								InvalRect(&HackWindow->portRect);
X								SizeWindow(HackWindow,60,60,FALSE);
X							}
X						} else {
X						/* ---------- RESUME EVENT ------------- */
X							fInFront = TRUE;
X							if (macflags & fZoomOnContextSwitch) {
X								SizeWindow(HackWindow,
X								 (t->maxCol * t->charWidth) + 2 * Screen_Border,
X								 (t->maxRow * t->height) + 2 * Screen_Border,
X								 TRUE);
X								SetPort(HackWindow);
X								InvalRect(&HackWindow->portRect);
X								if ((int) (theMenu = GetMHandle(editMenu))
X									&& FrontWindow() == HackWindow) {
X									SetMenuBar(t->fullMBarHandle);
X									for (temp = fileMenu;temp <= extendMenu;temp++) {
X									if (temp != editMenu)
X										EnableItem(GetMHandle(temp), 0);
X									}
X									EnableItem(GetMHandle(appleMenu), 1);
X									DisableItem(theMenu, 0);
X									DrawMenuBar();
X								}
X							}
X						}
X						break;
X				}
X				break;
X		
X			case updateEvt:
X				if (HackWindow == (WindowPtr)theEvent.message) {
X					doUpdate(t);
X					if (cursRectInv) InvertRect(&cursorRect);	/* restore cursor */
X				}
X				break;
X				
X			case activateEvt:
X				if (HackWindow == (WindowPtr)theEvent.message) {
X					if (theMenu = GetMHandle(editMenu)) {
X						if (theEvent.modifiers & activeFlag) {
X							if (macflags & fDoUpdate) {
X								SetMenuBar(t->fullMBarHandle);
X								for (temp = fileMenu;temp <= extendMenu;temp++) {
X									if (temp != editMenu)
X										EnableItem(GetMHandle(temp), 0);
X								}
X								EnableItem(GetMHandle(appleMenu), 1);
X							}
X							DisableItem(theMenu, 0);
X						} else {
X							EnableItem(theMenu, 0);
X							if (macflags & fDoUpdate) {
X								SetMenuBar(t->shortMBarHandle);
X								for (temp = fileMenu;temp <= extendMenu;temp++) {
X									if (temp != editMenu)
X										DisableItem(GetMHandle(temp), 0);
X								}
X								DisableItem(GetMHandle(appleMenu), 1);
X							}
X						}
X						DrawMenuBar();
X					}
X				}
X				break;
X				
X			case mouseDown:
X				ch = mButtonDown(theEvent, t, &nextCommand);
X#ifdef THINK_C
X				repDelay = KeyThresh;
X#else
X				repDelay = 42;
X#endif
X				lastMD = theEvent.when;
X				break;
X			}
X		}		
X	}
X	if (cursRectInv) InvertRect(&cursorRect);
X
X	SetPort(oldPort);
X	return ((ch == '\r') ? '\n' : ch);
X}
X
Xvoid
XdoUpdate(t)
Xterm_info	*t;
X{
X	register short	temp;
X	GrafPtr	oldPort;
X	register	short i,j;
X	register char	attr, *p;
X#ifdef TEXTCOLOR
X	if (t->system.hasColorQD) {
X		Rect	r;
X		GDHandle	gd;
X		
X		r = (**(*(WindowPeek)HackWindow).contRgn).rgnBBox;
X		LocalToGlobal(&r.top);
X		LocalToGlobal(&r.bottom);
X		gd = GetMaxDevice(&r);
X		HLock((Handle)gd);
X		t->inColor = (**(**gd).gdPMap).pixelSize > 1;
X		HUnlock((Handle)gd);
X	}
X#endif
X	GetPort(&oldPort);
X	SetPort((GrafPtr)HackWindow);
X	BeginUpdate(HackWindow);
X    ForeColor(t->color[0]);
X    BackColor(t->color[7]);
X	for (i = 0; i<t->maxRow; i++) {
X		p = t->scrAttr[i];
X		for (j = temp = 0, attr = *p; j<t->maxCol; j +=1, p++) {
X			if (*p != attr) {
X				MoveTo(Screen_Border + temp*t->charWidth,
X					t->ascent + (i * t->height) +
X					Screen_Border);
X				if (attr & 0x80) {
X				    ForeColor(t->color[7]);
X				    BackColor(t->color[0]);
X				} else if (t->inColor) {
X					ForeColor(t->color[attr]);
X					 /* yellow fgnd hard to see on white bgnd */
X					 /* so change to green background */
X					switch(attr) {
X					case BROWN:
X						BackColor(t->color[GREEN]);
X						break;
X					case BLUE:
X						BackColor(t->color[CYAN]);
X						break;
X					case CYAN:
X						BackColor(t->color[BLUE]);
X						break;
X					default:
X					    BackColor(t->color[7]);
X					   	break;
X					}
X				} else {
X				    ForeColor(t->color[0]);
X				    BackColor(t->color[7]);
X				}
X				DrawText(&(t->screen[i][temp]), 0, j - temp);
X				temp = j;
X				attr = *p;
X			} /* if */
X		} /* for j */
X		if (temp != t->maxCol) {
X			MoveTo(Screen_Border + temp*t->charWidth,
X				t->ascent + (i * t->height) +
X				Screen_Border);
X			if (attr & 0x80) {
X			    ForeColor(t->color[7]);
X			    BackColor(t->color[0]);
X			} else if (t->inColor) {
X				ForeColor(t->color[attr]);
X				 /* yellow fgnd hard to see on white bgnd */
X				 /* so change to green background */
X				switch(attr) {
X				case BROWN:
X					BackColor(t->color[GREEN]);
X					break;
X				case BLUE:
X					BackColor(t->color[CYAN]);
X					break;
X				case CYAN:
X					BackColor(t->color[BLUE]);
X					break;
X				default:
X				    BackColor(t->color[7]);
X				   	break;
X				}
X			} else {
X			    ForeColor(t->color[0]);
X			    BackColor(t->color[7]);
X			}
X			DrawText(&(t->screen[i][temp]), 0, j - temp);
X		} /* if */
X	} /* for i */
X	EndUpdate(HackWindow);
X	SetPort(oldPort);
X}
X
Xchar
XmButtonDown(theEvent, t, nextCommand)
XEventRecord	theEvent;
Xterm_info	*t;
Xchar	*nextCommand;
X{
X	Rect	boundsRect;
X	WindowPtr	theWindow;
X	long	message;
X	char	deskacc[256];
X	MenuHandle	theMenu;
X	char	ch;
X	short	menuBar;
X	GrafPtr	oldPort;
X
X	ch = '\0';
X	if (macflags & fDoNonKeyEvt) {
X		switch (FindWindow(theEvent.where,&theWindow)) {
X	    case inMenuBar:
X		if (!(macflags & fDoMenus))
X			break;
X		SetCursor(&ARROW_CURSOR);
X		message = MenuSelect(theEvent.where);
X
X		if (!HiWord(message))
X		    break;
X
X		switch (HiWord(message)) {
X		    case editMenu:
X			(void)SystemEdit((short)message - 1);
X			break;
X		    case appleMenu:
X			if (LoWord(message) > 1) {
X			    GetItem(GetMHandle(HiWord(message)),LoWord(message),
X					deskacc);
X			    SetMenuBar(t->shortMBarHandle);
X			    DrawMenuBar();
X			    (void)OpenDeskAcc(deskacc);
X			    if (theMenu = GetMHandle(editMenu))
X				    EnableItem(theMenu, 0);
X			} else
X			    if (aboutBox(1))
X				    ch = '?';
X			break;
X		    case fileMenu:
X		    case inventMenu:
X		    case prepMenu:
X		    case actionMenu:
X		    case moveMenu:
X			*nextCommand =
X			    keys[HiWord(message)-appleMenu][LoWord(message)-1];
X			ch = (!(*nextCommand)) ? '\0' : (char)ESCAPEkey;
X			macflags |= (fExtCmdSeq2 | fExtCmdSeq3);
X#ifdef TEXTCOLOR
X#define	MAC_BLACK	0
X#define	MAC_WHITE	7
X			if(HiWord(message) == fileMenu && LoWord(message) == 3) {
X			    theMenu = GetMHandle(HiWord(message));
X			    macflags = macflags ^ fInvertedScreen;
X			    CheckItem(theMenu, 3,
X					(boolean)(macflags & fInvertedScreen));
X
X			    /* switch black & white */
X			    message = t->color[BLACK];
X			    t->color[MAC_BLACK] = t->color[MAC_WHITE];
X			    t->color[MAC_WHITE] = message;
X
X			    /* switch light blue & dark blue */
X			    message = t->color[BLUE];
X			    t->color[BLUE] = t->color[CYAN];
X			    t->color[CYAN] = message;
X
X			    ForeColor(t->color[MAC_BLACK]);
X			    BackColor(t->color[MAC_WHITE]);
X			    /* refresh screen without prompting 'More' */
X			    message = flags.toplin;
X			    flags.toplin = 0;
X			    docrt();
X			    flags.toplin = message;
X			}
X#endif
X			break;
X		    case extendMenu:
X			ch = (char)ESCAPEkey;
X			*nextCommand =
X			 keys[HiWord(message) - appleMenu][LoWord(message) - 1];
X			macflags |= fExtCmdSeq1;
X			break;
X		}
X		HiliteMenu(0);
X		break;
X		
X	    case inSysWindow:
X		SystemClick(&theEvent, theWindow);
X		break;
X
X	    case inDrag:
X		if (!(theEvent.modifiers & cmdKey)) {
X			if (theWindow != FrontWindow()) {
X				SelectWindow(theWindow);
X				break;
X			}
X		}
X		menuBar = (ROM85 == -1) ? 20 : GetMBarHeight();
X
X		{
X		RgnHandle fooRgn = GetGrayRgn();
X			boundsRect = (*fooRgn)->rgnBBox;
X		}
X		SetCursor(&ARROW_CURSOR);
X		DragWindow(theWindow, theEvent.where, &boundsRect);
X		break;
X	
X	case inContent:
X		if (theWindow != FrontWindow()) {
X			SelectWindow(theWindow);
X		} else if (theWindow == HackWindow) {
X			Point	mouseLoc;
X			Rect	box;
X			short	temp;
X
X			if(flags.wantspace) {
X				ch = 0x20;
X			} else {
X				box.left = (u.ux-1) * t->charWidth + Screen_Border + (t->charWidth/2);
X				box.right = box.left + 1;
X				box.top = (u.uy+1) * t->height + Screen_Border + t->height/2;
X				box.bottom = box.top + 1;
X				GetMouse(&mouseLoc);
X				PtToAngle(&box,mouseLoc,&temp);
X				temp = ((temp + 22) / 45) % 8;	/* ~same as above */
X				switch(cursorPos) {
X					case 0:
X						ch = 'k';
X						break;
X					case 1:
X						ch = 'u';
X						break;
X					case 2:
X						ch = 'l';
X						break;
X					case 3:
X						ch = 'n';
X						break;
X					case 4:
X						ch = 'j';
X						break;
X					case 5:
X						ch = 'b';
X						break;
X					case 6:
X						ch = 'h';
X						break;
X					case 7:
X						ch ='y';
X						break;
X					case 8:
X						ch = '.';
X						break;
X				}
X				if ((theEvent.modifiers & shiftKey) && (ch)) {
X					ch = (ch == '.') ? ':' : (char)toupper(ch);
X				}
X			}
X		}			
X		break;
X		}
X	} else {
X		switch (FindWindow(theEvent.where,&theWindow)) {
X		case inContent:
X			if(flags.wantspace) ch = 0x20;
X			break;
X		default:
X			break;
X		}
X	}
X	return ch;
X}
X
Xvoid
Xgethdate(name) char *name;
X{
X/*end gethdate*/}
X
Xint
Xuptodate(fd)
X{
X	return(1);
X}
X
X#ifndef THINKC4
Xchar *
Xgetenv(s)
Xchar *s;
X{
X	return((char *)NULL);
X}
X
Xint
Xmemcmp(x,y,n)
Xchar *x,*y;
Xint	n;
X
X{
X	int i;
X	
X	i = 0;
X	while (i++< n && (*x++) == (*y++)) {
X		/*x++; y++; i++*/
X		;
X	}
X	if (i != n)
X		return ((*x > *y) ? -1 : 1);
X	else
X		return (0);
X}
X#else
Xint
Xkbhit()
X{	
X	EventRecord	theEvent;
X	
X	SystemTask();
X	return (EventAvail(keyDownMask | mDownMask, &theEvent));
X}
X#endif
X
X#ifdef AZTEC
X
Xsleep(x)
Xint	x;
X{
X	long t;
X	
X	Delay((long)x, &t);
X}
X#endif
X	
X
Xint
Xmcurs(col,row)
Xshort	col,row;
X
X{
X	term_info	*t;
X	
X	t = (term_info *)GetWRefCon(HackWindow);
X	t->tcur_y = row;
X	t->tcur_x = col;
X	return 1;
X}
X
Xstatic void
XcheckScroll(t)
Xterm_info *t;
X{
X	if (t->tcur_y >= t->maxRow-1) {
X		short	temp;
X		char	*s, *s1;
X
X		BlockMove((Ptr)t->screen[1], (Ptr)t->screen[0],
X			(Size)((t->maxRow - 1) * t->maxCol));
X		BlockMove((Ptr)t->scrAttr[1], (Ptr)t->scrAttr[0],
X			(Size)((t->maxRow - 1) * t->maxCol));
X		for (temp = 0, s = t->screen[t->maxRow - 1], s1 = t->scrAttr[t->maxRow - 1];
X				temp < t->maxCol; temp++, s++, s1++) {
X			*s = ' ';
X			*s1 = 0;
X		}
X		{
X			Pattern p, o;
X			Rect	window;
X			
X			if (macflags & fInvertedScreen) {
X				BlockMove((Ptr)&((GrafPtr)HackWindow)->bkPat, (Ptr)&o,
X						sizeof(Pattern));
X				GetIndPattern(&p, sysPatListID,1);
X				BackPat(p);
X			}
X			window = HackWindow->portRect;
X			InsetRect(&window, 4,4);
X			window.top += t->height;
X			ScrollRect(&window, 0, -t->height,
X					((WindowPeek)HackWindow)->updateRgn);
X			ValidRect(&window);
X			if (macflags & fInvertedScreen) {
X				BackPat(o);
X			}
X		}
X		t->tcur_y = t->maxRow - 1;
X	}
X}
X
Xvoid
Xmput(s)
Xchar	*s;
X{
X	unsigned short	sLen,temp;
X	GrafPtr		prevPort;
X	register term_info	*t;
X	Point		cur;
X	register short		x,y;
X	Rect		eraseRect;
X	register char		*stmp,*c,*c1;
X	char	savech;
X	
X	t = (term_info *)GetWRefCon(HackWindow);
X	sLen = strlen(s);
X	
X	x = t->tcur_x;
X	y = t->tcur_y;
X	if (y >= t->maxRow)
X		panic("mput - incorrect cursor position\n");
X	cur.h = (x * t->charWidth) + Screen_Border;
X	cur.v = t->ascent + (y * t->height) + Screen_Border;
X	GetPort(&prevPort);
X	SetPort((GrafPtr)HackWindow);
X	TextFont(t->fontNum);
X	TextSize(t->fontSize);
X	TextMode(srcCopy);
X	/* a termcap-type escape string */
X	if (!strncmp(s, "\033[", 2)) {
X	    switch(*(s + 2)) {
X		case 'c':	/* color kluge */
X			temp = (short)(*(s + 3) - 'a');
X			t->curAttr = temp;
X			if (temp >= BLACK && temp < MAXCOLORS &&
X			    (temp % (MAXCOLORS / 2) != GRAY)) /* set colour */
X			    t->curAttr = temp % (MAXCOLORS / 2);
X			if ((temp & 0x07) == GRAY)
X				t->curAttr = 0;
X		    if (t->inColor) {
X			if (temp >= BLACK && temp < MAXCOLORS &&
X			    (temp % (MAXCOLORS / 2) != GRAY)) /* set colour */
X				ForeColor(t->color[temp % (MAXCOLORS / 2)]);
X			if (temp == GRAY)
X		                ForeColor(t->color[0]);
X			 /* yellow fgnd hard to see on white bgnd */
X			 /* so change to green background */
X			if (temp == YELLOW || temp == BROWN)
X				BackColor(t->color[GREEN]);
X			if (temp == BLUE)
X				BackColor(t->color[CYAN]);
X			if (temp == CYAN)
X				BackColor(t->color[BLUE]);
X		    }
X		    break;
X		case '0':	/* normal video begin */
X		    if (*(s + 3) == 'm') {
X			    ForeColor(t->color[0]);
X			    BackColor(t->color[7]);
X			    t->curHilite = FALSE;
X			    t->curAttr = 0;
X		    }
X		    break;
X		case '1':	/* inverse video begin */
X		    if (*(s + 3) == 'm') {
X			    ForeColor(t->color[7]);
X			    BackColor(t->color[0]);
X			    t->curHilite = TRUE;
X			    t->curAttr = 0;
X		    }
X		    break;
X		case 'A':	/* cursor up */
X		    if (y > 0) {
X			    t->tcur_y--;
X			    cur.v -= t->height;
X		    }
X		    break;
X		case 'B':	/* cursor down */
X		    if (y < t->maxRow) {
X			    t->tcur_y++;
X			    cur.v += t->height;
X		    }
X		    break;
X		case 'C':	/* cursor right */
X		    if (x < t->maxCol) {
X			    t->tcur_x++;
X			    cur.h += t->charWidth;
X		    }
X		    break;
X		case 'D':	/* cursor left */
X		    if (x > 0) {
X			    t->tcur_x--;
X			    cur.h -= t->charWidth;
X		    }
X		    break;
X		case 'H':	/* home cursor */
X		    t->tcur_x = t->tcur_y = 0;
X		    cur.h = Screen_Border;
X		    cur.v = t->ascent + Screen_Border;
X		    break;
X		case 'K':	/* clear to end of line */
X		    eraseRect.top = cur.v - (t->ascent);
X		    eraseRect.left = cur.h;
X		    eraseRect.bottom = eraseRect.top + t->height;
X		    eraseRect.right = (t->maxCol*t->charWidth) + Screen_Border;
X		    EraseRect(&eraseRect);
X		    for (temp = x, c = &(t->screen[y][x]), c1 = &(t->scrAttr[y][x]);
X		    	temp < t->maxCol; temp++) {
X			    *c++ = ' ';
X			    *c1++ = 0;
X			}
X		    break;
X		case '2':
X		    if (*(s+3) == 'J') {	/* clear screen */
X			x = y = t->tcur_x = t->tcur_y = 0;
X			eraseRect.top = eraseRect.left = Screen_Border;
X			eraseRect.bottom = t->maxRow*t->height + Screen_Border;
X			eraseRect.right = t->charWidth*t->maxCol + Screen_Border;
X			EraseRect(&eraseRect);
X			for (y = 0, c = t->screen[0], c1 = t->scrAttr[0];
X				y < t->maxCol * t->maxRow; y++) {
X					*c++ = ' ';
X					*c1++ = 0;
X			}
X			cur.h = Screen_Border;
X			cur.v = t->ascent + Screen_Border;
X		    }
X		    break;
X	    }
X	    MoveTo(cur.h, cur.v);
X	} else {
X	    short	charleft = sLen;
X	    
X	    MoveTo(cur.h, cur.v);
X	    stmp = s;
X	    
X	    if (sLen) {
X		while (stmp < (s + sLen)) {
X		    temp = (x + charleft - 1 < t->maxCol - 1) ? charleft : t->maxCol - x;
X		    savech = '\0';
X		    c1 = stmp + temp;	/* point to the char after the end */
X		    c = index(stmp, '\n');
X		    if (c && c < c1) {
X			    c1 = c;
X			    savech = '\n';
X			    temp = (short)(c - stmp);
X			    /* don't want to include '\n' in print */
X		    }
X		    c = index(stmp, '\r');
X		    if (c && c < c1) {
X			    c1 = c;
X			    savech = '\r';
X			    temp = (short)(c - stmp);
X			    /* don't want to include '\r' in print */
X		    }
X		    DrawText((Ptr)stmp, 0, temp);
X		    BlockMove((Ptr)stmp, (Ptr)&(t->screen[y][x]), (long)temp);
X		    memset(&(t->scrAttr[y][x]), ((t->curHilite) ? 128 : 0) + t->curAttr,
X		    	temp);
X		    stmp += temp + 1;
X		    charleft -= temp + 1;
X		    if (!savech) {
X			    t->tcur_x += temp;
X		    }
X
X		    if (t->tcur_x >= t->maxCol-1 || savech) {
X			    if (savech != '\r') {
X				    if (t->tcur_y >= t->maxRow-1) {
X					    checkScroll(t);
X				    } else {
X					    y = (++t->tcur_y);
X				    }
X			    }
X	
X			    x = t->tcur_x = 0;
X			    cur.h = Screen_Border;
X			    cur.v = y * t->height + t->ascent + Screen_Border;
X			    MoveTo(cur.h,cur.v);
X			}
X	    }
X	}
X	}
X	if (t->tcur_x >= t->maxCol-1) {
X	    t->tcur_x = t->tcur_x % t->maxCol;
X	    t->tcur_y++;
X	    checkScroll(t);
X	}
X	SetPort(prevPort);
X}
X
Xint
Xmputc(c)
Xchar	c;
X{
X	GrafPtr		prevPort;
X	register term_info	*t;
X	Point		cur;
X	register short		x,y;
X	Rect		eraseRect;
X	char		savech;
X	PenState	pnState;
X	
X	t = (term_info *)GetWRefCon(HackWindow);
X	
X	x = t->tcur_x;
X	y = t->tcur_y;
X	cur.h = (x * t->charWidth) + Screen_Border;
X	cur.v = t->ascent + (y * t->height) + Screen_Border;
X	GetPort(&prevPort);
X	SetPort((GrafPtr)HackWindow);
X	TextFont(t->fontNum);
X	TextSize(t->fontSize);
X	TextMode(srcCopy);
X	
X	MoveTo(cur.h, cur.v);
X	savech = '\0';
X	if (c == '\b') {
X		if (x > 0) {
X			c = ' ';
X			x = (--t->tcur_x);
X			cur.h = (x * t->charWidth) + Screen_Border;
X			Move(-t->charWidth,0);
X			savech = '\b';
X		} else if (y > 0) {
X				c = ' ';
X				x = t->tcur_x = (t->maxCol - 1);
X				y = (--t->tcur_y);
X				cur.h = (x * t->charWidth) + Screen_Border;
X				cur.v -= t->height;
X				MoveTo(cur.h, cur.v);
X				savech = '\b';
X		}
X	}
X	if (c == '\007') {
X		SysBeep(1);
X	} else if ((c == '\n') || (c == '\r')) {
X		t->tcur_x = 0;
X		if (t->tcur_y >= t->maxRow && c == '\r') {
X			t->tcur_y = t->maxRow - 1;
X		} else if (c == '\n') {
X			if (t->tcur_y >= t->maxRow-1) {
X				checkScroll(t);
X			} else {
X				t->tcur_y++;
X			}
X		}
X	} else {
X		t->screen[y][x] = c;
X		t->scrAttr[y][x] = ((t->curHilite) ? 128 : 0) + t->curAttr;
X		DrawText(&c, 0, 1);
X		if (!savech) {
X			t->tcur_x++;
X			if (t->tcur_x >= t->maxCol)
X			{
X				t->tcur_x = 0;
X				t->tcur_y++;
X				checkScroll(t);
X			}
X		}
X	}
X	cur.h = (t->tcur_x * t->charWidth) + Screen_Border;
X	cur.v = t->ascent + (t->tcur_y * t->height) + Screen_Border;
X	MoveTo(cur.h,cur.v);
X
X	SetPort(prevPort);	
X	return 1;
X}
X
Xint
Xmputs(s)
Xchar	*s;
X{
X	mput(s);
X	return 1;
X}
X		
X		
X		
Xint
Xmprintf(fstr)
Xchar	*fstr;
X{
X#define	Bufsz	14		
X	char		numAsStr[Bufsz];
X	short		numsz;
X	char		*ps;
X	unsigned long	num;
X
X	boolean		convchar;
X	boolean		islong;
X	char		c;
X	char		*s;
X	char		prBuffer[128];
X	register char		*pb;
X	
X	prBuffer[0] = '\0';
X	pb = &prBuffer[0];
X	ps = (char *)&fstr;	/* convert to pointer to params */
X	ps += sizeof(char *);	/* skip over format string ptr */
X	while (*fstr)	{
X	    s = index(fstr, '%');
X	    if (s) {
X		num = (short)(s - fstr);
X		strncpy(pb, fstr, (short)num);
X		pb += num;
X		fstr = s;
X	    } else {
X		Strcpy(pb, fstr);
X		fstr += strlen(fstr)-1;
X	    }
X	    switch (*fstr) {
X		case '%':
X		    fstr++;
X		    convchar = FALSE;
X		    islong = FALSE;
X		    do {
X			switch (*fstr) {
X			    case 'l':	/* long */
X				islong = TRUE;
X				fstr++;
X				break;
X			    case 'u':	/* unsigned decimal */
X			    case 'd':	/* signed decimal */
X				num = (islong) ? *(unsigned long *)ps
X					       : *(unsigned short *)ps;
X				numsz = (islong) ? sizeof(long) : sizeof(short);
X				ps += numsz;
X				s = (islong) ? fstr - 2 : fstr - 1;
X				c = *(fstr + 1);
X				*(fstr + 1) = '\0';
X				if (islong)
X				    Sprintf(numAsStr, s, num);
X				else
X				    Sprintf(numAsStr, s, (short)num);
X				*(fstr + 1) = c;
X				Strcpy(pb, numAsStr);
X				pb = (char *)(pb + strlen(numAsStr));
X				convchar = TRUE;
X				break;
X			    case 's':
X				s = *(char **)ps;
X				Strcpy(pb, s);
X				pb = (char *)(pb + strlen(s));
X				ps += sizeof(char *);
X				convchar = TRUE;
X				break;
X			    case 'c':
X				c = *(unsigned short *)ps;
X				numsz = sizeof(short);
X				(*pb++) = (char)c;
X				(*pb) = '\0';
X				convchar = TRUE;
X				ps += numsz;
X				break;
X			    default:
X				convchar = TRUE;
X			}
X		    } while (!convchar);
X		    break;
X		default:
X		    break;
X	    }
X	    fstr++;
X	}
X	if (prBuffer[0])
X	    mput(&prBuffer[0]);
X		
X	return 1;
X}
X
XDialogTHndl
XcentreDlgBox(resNum, clip)
Xshort	resNum;
XBoolean	clip;
X{
X	DialogTHndl	th = (DialogTHndl) GetResource('DLOG', resNum);
X	Rect	rect;
X	short	dv, dh;
X
X	/* centre dialog box on screen */
X	if (th) {
X		rect = SCREEN_BITS.bounds;
X		HLock((Handle)th);
X		dv = ((**th).boundsRect.bottom - (**th).boundsRect.top)/2;
X		dv -= (clip) ? 20 : 0;
X		dh = ((**th).boundsRect.right - (**th).boundsRect.left)/2;
X	
X		(**th).boundsRect.bottom =
X				(rect.bottom + rect.top + MBarHeight)/2 + dv;
X		(**th).boundsRect.top	 =
X				(rect.bottom + rect.top + MBarHeight)/2 - dv;
X		(**th).boundsRect.right	 = (rect.right + rect.left)/2 + dh;
X		(**th).boundsRect.left	 = (rect.right + rect.left)/2 - dh;
X		HUnlock((Handle)th);
X	} else
X		panic("Couldn't load dialog resource");	
X
X	return th;
X}
X
Xshort
XaboutBox(prompt)
Xshort	prompt;
X{
X#define	OK_BUTTON	1
X#define	MORE_INFO_BUTTON	2
X
X	DialogPtr	theDialog;
X	Rect	rect;
X	Handle	theControl;
X	short	type,itemHit;
X	GrafPtr	oldPort;
X	EventRecord	theEvent;
X	term_info	*t;
X	DialogTHndl	th;
X
X	/* if about box on startup, centre about box on screen */
X	if (!prompt) {
X		th = centreDlgBox(129, TRUE);
X	}
X
X	GetPort(&oldPort);
X	theDialog = GetNewDialog(129, (Ptr)NULL,(WindowPtr)-1);
X	if (!prompt) {
X		HideDItem(theDialog, OK_BUTTON);
X		HideDItem(theDialog, MORE_INFO_BUTTON);
X	} else
X		MoveWindow((WindowPtr)theDialog, LEFT_OFFSET, TOP_OFFSET, TRUE);
X
X	ShowWindow((WindowPtr)theDialog);
X	SetPort(theDialog);
X	TextFont(1);	/* 9 pt. Geneva */
X	TextSize(9);
X	DrawDialog(theDialog);
X	itemHit = 0;
X	if (prompt) {
X		/* BOLD the OK button */
X		GetDItem(theDialog, OK_BUTTON, &type, &theControl, &rect);
X		PenSize(3,3);	
X		InsetRect(&rect,-4,-4);
X		FrameRoundRect(&rect,16,16);
X		PenSize(1,1);
X		while ((itemHit != OK_BUTTON) && (itemHit != MORE_INFO_BUTTON)) {
X			ModalDialog(NULL, &itemHit);
X		}
X	} else {
X		long	tickNum;
X
X		tickNum = TickCount() + 180;	/* 3 second wait max */
X		while (!itemHit && TickCount()<tickNum) {
X		/*	SystemTask();*/
X			if (GetNextEvent(everyEvent,&theEvent))
X				if (theEvent.what == mouseDown ||
X  			            theEvent.what == keyDown ||
X  				    theEvent.what == autoKey)
X					itemHit = OK_BUTTON;
X		}
X	}
X	DisposDialog(theDialog);
X	ReleaseResource((Handle)th);
X	SetPort(oldPort);
X	return (itemHit == MORE_INFO_BUTTON);
X}
X
Xvoid
XfreeSegs(segs)
Xlong	*segs;
X{
X	register long s;
X	
X	s = (segs == (long *)0) ? 0L : (*segs);
X	
X	UnloadSeg(dothrow);
X	UnloadSeg(dowear);
X	UnloadSeg(ddocall);
X	UnloadSeg(castmu);
X	UnloadSeg(doforce);
X	if (!(s & SEG_EAT))
X		UnloadSeg(doeat);
X	if (!(s & SEG_ZAP))
X		UnloadSeg(dozap);
X	UnloadSeg(initterm);
X	if (!(s & SEG_APPLY))
X		UnloadSeg(doapply);
X	UnloadSeg(dokick);
X	UnloadSeg(outrumor);
X	if (!(s & SEG_DO))
X		UnloadSeg(steal);
X	UnloadSeg(done1);
X	if (!(s & SEG_POTION))
X		UnloadSeg(dodrink);
X	UnloadSeg(doturn);
X#ifdef REINCARNATION
X	UnloadSeg(makeroguerooms);
X#endif
X#ifdef STRONGHOLD
X	UnloadSeg(load_special);
X#endif
X	UnloadSeg(mklev);
X#ifdef MUSIC
X	if (!(s & SEG_SPELL))
X		UnloadSeg(do_play_instrument);
X#endif
X#ifdef SPELLS
X	if (!(s & SEG_SPELL))
X		UnloadSeg(docast);
X#endif
X	UnloadSeg(savebones);
X	UnloadSeg(expels);
X	UnloadSeg(attack);
X	UnloadSeg(doname);
X	if (FreeMem() < lowMemLimit)
X	{
X		long	space;
X		
X		space = 0x7FFFFFFFL;
X		MaxMem(&space);
X	}
X
X}
X
END_OF_FILE
if test 28936 -ne `wc -c <'mac/mac.c'`; then
    echo shar: \"'mac/mac.c'\" unpacked with wrong size!
fi
# end of 'mac/mac.c'
fi
if test -f 'others/Makefile.ovl' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'others/Makefile.ovl'\"
else
echo shar: Extracting \"'others/Makefile.ovl'\" \(24533 characters\)
sed "s/^X//" >'others/Makefile.ovl' <<'END_OF_FILE'
X#	SCCS Id: @(#)Makefile.ovl	3.0	90/06/03
X#	PC NetHack 3.0 Makefile for Microsoft(tm) "C" 5.1 -- Pierre Martineau
X#	Overlay Arrangement -- Stephen Spackman, Pierre Martineau, Norm Meluch
X#	Multiple Compilation Hack and so forth -- Stephen Spackman
X#	Additional editing -- Kevin Smolkowski
X#
X#	Other things that have to be reconfigured are in config.h, pcconf.h,
X#	and possibly system.h.
X#
X#	Nota Bene: OVERLAY *must* be defined in pcconf.h to use this makefile!
X#	Also: Rename this file to "makefile", some targets rely on it.
X# -----------------------------------------------------------------------------
X#	In addition to your C compiler,
X#
X#	if you want to change		you will need a
X#	files with suffix		workalike for
X#	       .y			    yacc
X#	       .l			    lex
X#	       .asm			    masm
X# -----------------------------------------------------------------------------
X#	As it is set up, this makefile requires that exesmurf (the
X#	NetHack overlay-aware .exe header editor) be on your path or in the
X#	$(SRC) directory. If you wish to change the path or use Microsoft
X#	EXEMOD instead, see the symbols EXEPATCH and EXEFLAGS.
X#
X# *****************************************************************************
X# ************************ Compiler Info **************************************
X# *****************************************************************************
XCC	 = cl /c
XLINK	 = link
XMODEL	 = L
XASM	 = masm
XEXEPATCH = exesmurf
X# $(MAKE) macro is often predefined, so we use $(MAKEBIN) instead.
XMAKEBIN = make
X# For those of us who have these on PC.
X# YACC	 = yacc
X# LEX	 = lex
XYACC	= bison -y
XLEX	= flex
X# Standard file names may vary in PC installations.
XYTABC	= y_tab.c
XYTABH	= y_tab.h
XLEXYYC	= lexyy.c
X# Register bug, remove stack probes...
X# /Gt22 is currently about the largest value that keeps the initialised data
X# segment below 64K (and keeps the linker happy).
X# 286 or higher machines can use the /G2 CFLAG option for better performance.
XCFLAGS	= /A$(MODEL) /Oa /Gs /Gt22 /Zp1 /W0 /I$(INCL)
XCOSPACE = /Os
XCOSPEED = /Os  # MSC 5.1 seems to be broken, or maybe it's the NetHack code.
X#              # Either way, setting COSPEED to /Ot wreaked jolly flaming havoc.
X#
XLFLAGS	= /noi /seg:512 /map /st:4096
X#
X# Available assembler flags:
X#	/Di386	= Use 386 specific enhancements
X#	/DNOEMS = Do not use EMS memory
X#	/DDEBUG = Report memory usage on startup
XAFLAGS	= /MX
X#
X###############################################################################
X# Use the first line if you are using EXESMURF or the second for EXEMOD.
XEXEFLAGS = /max4500 /min4500
X# EXEFLAGS = /max 1194 /min 1194
X###############################################################################
X#
X# *****************************************************************************
X# ********* Directories (makedefs hardcodes these, don't change them) *********
X# *****************************************************************************
X#
XINCL	= ..\include
XAUX	= ..\auxil
XSRC	= ..\src
XOTHERS	= ..\others
XOBJ	= $(SRC)\o
X#
X# *****************************************************************************
X# ************************ Local Variables ************************************
X# *****************************************************************************
X#
X# The game name
XGAME	 = NetHack
X#
X# The default make target (so just typing 'make' is useful)
XDEFAULT  : $(GAME)
X#
X# The game directory
X# make sure GAMEDIR exists!
XGAMEDIR  = ..
X#
X# The game filename
XGAMEFILE = $(GAMEDIR)\$(GAME).exe
X#
X# Target environment prefix
XTARG	 = pc
X#
X# Overlay manager object file.
XOVLMGR	 = ovlmgr.obj
X#
X# Termcap routines.
XTERMCAPS = $(SRC)\termlib.lib
X#
X###############################################################################
X# Switch the following lines if you have a MASM compatible assembler.
X# $(OBJ)\$(OVLMGR):
X$(OBJ)\$(OVLMGR): ; copy $(OTHERS)\$(OVLMGR) $(OBJ)\$(OVLMGR)
X###############################################################################
X# If you have yacc and lex programs and make any changes, comment out the
X# upper two targets and uncomment the lower two.
Xdo_yacc: yacc_msg
Xdo_lex:  lex_msg
X# do_yacc: yacc_act
X# do_lex:  lex_act
X###############################################################################
X# Optional high-quality BSD random number generation routines (see pcconf.h).
X# Set to nothing if not used.
XRANDOM	 = $(OBJ)\random.o
X# RANDOM =
X###############################################################################
X# Optional C library specifier for those with non-standard libraries or
X# a multiple-target library setup.
X# CLIB	   = llibcer /nod
XCLIB	 =
X###############################################################################
X# If TERMLIB is NOT #defined in the source, comment out the lower line and
X# uncomment the upper. Don't forget to copy the $(TERMCAPS) file to the
X# $(SRC) directory if you have uncommented the lower line.
X# TERMLIB  =
XTERMLIB  = $(TERMCAPS)
X###############################################################################
X#
X# nothing below this line should have to be changed
X
XROOT =  $(OBJ)\$(OVLMGR) $(OBJ)\trampoli.o $(OBJ)\main.o $(OBJ)\msdos.o \
X	$(OBJ)\alloc.o $(OBJ)\random.o $(OBJ)\decl.o $(OBJ)\monst.o \
X	$(OBJ)\objects.o $(OBJ)\invent.0 $(OBJ)\mkobj.0 $(OBJ)\mkroom.0 \
X	$(OBJ)\rnd.0 $(OBJ)\termcap.0
X# main monster code
XOVL01 = $(OBJ)\cmd.0 $(OBJ)\dbridge.0 $(OBJ)\dog.0 $(OBJ)\engrave.0-1 \
X	$(OBJ)\hack.0 $(OBJ)\mon.0-1 $(OBJ)\mondata.0-1 $(OBJ)\monmove.0-1 \
X	$(OBJ)\mthrowu.0 $(OBJ)\priest.0 $(OBJ)\shk.0 $(OBJ)\track.0 \
X	$(OBJ)\trap.0-1 $(OBJ)\were.0
X# pet code
XOVL02 = $(OBJ)\apply.0 $(OBJ)\dog.1 $(OBJ)\dogmove.o
X# advanced monsters
XOVL03 = $(OBJ)\demon.o $(OBJ)\mcastu.o
XOVL04 = $(OBJ)\priest.1-b
XOVL05 = $(OBJ)\shk.1-b
XOVL06 = $(OBJ)\were.1-b
XOVL07 = $(OBJ)\wizard.1-b
XOVL08 = $(OBJ)\worm.o
X# main people things: you take your turn
XOVL09 = $(OBJ)\allmain.0 $(OBJ)\artifact.0 $(OBJ)\attrib.1 $(OBJ)\cmd.1 \
X	$(OBJ)\do.1 $(OBJ)\do.3 $(OBJ)\eat.0 $(OBJ)\engrave.2 \
X	$(OBJ)\getline.0-1 $(OBJ)\hack.1 $(OBJ)\lock.0 $(OBJ)\mail.0 \
X	$(OBJ)\pickup.1 $(OBJ)\pri.1 $(OBJ)\prisym.1 $(OBJ)\sounds.0 \
X	$(OBJ)\timeout.0 $(OBJ)\track.1 $(OBJ)\vault.0 $(OBJ)\wizard.0
XOVL10 = $(OBJ)\attrib.0
XOVL11 = $(OBJ)\attrib.2-b $(OBJ)\exper.o
XOVL12 = $(OBJ)\artifact.2 $(OBJ)\eat.1 $(OBJ)\invent.1
XOVL13 = $(OBJ)\makemon.0-2 $(OBJ)\mkobj.1
XOVL14 = $(OBJ)\makemon.b
XOVL15 = $(OBJ)\mkobj.2-b
XOVL16 = $(OBJ)\hack.2
XOVL17 = $(OBJ)\mhitm.1-b
XOVL18 = $(OBJ)\mthrowu.1
XOVL19 = $(OBJ)\mthrowu.2-b
XOVL20 = $(OBJ)\allmain.1 $(OBJ)\mhitm.0 $(OBJ)\mhitu.0-1 $(OBJ)\rnd.1 \
X	$(OBJ)\weapon.0-1
XOVL21 = $(OBJ)\mon.2-b $(OBJ)\trap.2
XOVL22 = $(OBJ)\artifact.1 $(OBJ)\search.0 $(OBJ)\uhitm.o $(OBJ)\weapon.2-b
XOVL23 = $(OBJ)\do_wear.0-1 $(OBJ)\mhitu.2-b
XOVL24 = $(OBJ)\steal.0-1
XOVL25 = $(OBJ)\monmove.2-b $(OBJ)\steal.2-b
XOVL26 = $(OBJ)\rnd.2-b
XOVL27 = $(OBJ)\do_wear.2 $(OBJ)\getline.b $(OBJ)\mondata.2 $(OBJ)\objnam.0-1 \
X	$(OBJ)\pager.0 $(OBJ)\polyself.0-1
XOVL28 = $(OBJ)\do_name.0
XOVL29 = $(OBJ)\objnam.2-b
XOVL30 = $(OBJ)\pager.1-b
XOVL31 = $(OBJ)\pri.0 $(OBJ)\prisym.0 $(OBJ)\topl.0
XOVL32 = $(OBJ)\pri.b $(OBJ)\topl.1-2
XOVL33 = $(OBJ)\prisym.2
XOVL34 = $(OBJ)\prisym.b
XOVL35 = $(OBJ)\topl.b
XOVL36 = $(OBJ)\termcap.1 $(OBJ)\unix.0
XOVL37 = $(OBJ)\termcap.2-b
XOVL38 = $(OBJ)\dog.b $(OBJ)\sounds.1-b
XOVL39 = $(OBJ)\read.0
XOVL40 = $(OBJ)\invent.b
XOVL41 = $(OBJ)\hack.b
XOVL42 = $(OBJ)\mondata.b $(OBJ)\timeout.1-b
XOVL43 = $(OBJ)\do.0 $(OBJ)\invent.3
XOVL44 = $(OBJ)\cmd.2-b $(OBJ)\getline.2 $(OBJ)\write.o
XOVL45 = $(OBJ)\apply.2-b
XOVL46 = $(OBJ)\do.b
XOVL47 = $(OBJ)\dokick.o
XOVL48 = $(OBJ)\dothrow.o
XOVL49 = $(OBJ)\eat.2-b
XOVL50 = $(OBJ)\invent.2 $(OBJ)\pickup.0 $(OBJ)\pickup.2-b
XOVL51 = $(OBJ)\lock.1-b
XOVL52 = $(OBJ)\polyself.2-b
XOVL53 = $(OBJ)\potion.o
XOVL54 = $(OBJ)\pray.o
XOVL55 = $(OBJ)\read.1-b $(OBJ)\spell.o
XOVL56 = $(OBJ)\search.1-b
X# clothing stuff
XOVL57 = $(OBJ)\do_wear.b $(OBJ)\wield.o $(OBJ)\worn.o
X# Zappage
XOVL58 = $(OBJ)\pri.2 $(OBJ)\zap.o
XOVL59 = $(OBJ)\dbridge.1-b
XOVL60 = $(OBJ)\trap.b
X# Unusual circumstances
XOVL61 = $(OBJ)\artifact.b $(OBJ)\do_name.1-b $(OBJ)\fountain.o $(OBJ)\music.o \
X	$(OBJ)\rumors.o $(OBJ)\shknam.0 $(OBJ)\sit.o $(OBJ)\vault.1-b
X# Uppers and Downers
X# Note: version.o is in OVL62, but in a special way.  See below.
XOVL62 = $(OBJ)\allmain.2-b $(OBJ)\end.o $(OBJ)\engrave.b $(OBJ)\mail.1-b \
X	$(OBJ)\o_init.o $(OBJ)\options.o $(OBJ)\restore.o $(OBJ)\rip.o \
X	$(OBJ)\save.o $(OBJ)\shknam.1-b $(OBJ)\topten.o $(OBJ)\tty.o \
X	$(OBJ)\u_init.o $(OBJ)\unix.1-b
X# Levelling
XOVL63 = $(OBJ)\apply.1 $(OBJ)\bones.o $(OBJ)\do.2 $(OBJ)\dog.2 \
X	$(OBJ)\extralev.o $(OBJ)\mklev.o $(OBJ)\mkmaze.o $(OBJ)\mkroom.1-b \
X	$(OBJ)\sp_lev.o $(OBJ)\track.2-b
X
X
X# *****************************************************************************
X# ************************* Make Objects **************************************
X# *****************************************************************************
X
XMOBJ = $(OVL01) $(OVL02) $(OVL03) $(OVL04) $(OVL05) $(OVL06) $(OVL07) $(OVL08)\
X       $(OVL09) $(OVL10) $(OVL11) $(OVL12) $(OVL13) $(OVL14) $(OVL15) $(OVL16)\
X       $(OVL17) $(OVL18) $(OVL19) $(OVL20) $(OVL21) $(OVL22) $(OVL23) $(OVL24)\
X       $(OVL25) $(OVL26) $(OVL27) $(OVL28) $(OVL29) $(OVL30) $(OVL31) $(OVL32)\
X       $(OVL33) $(OVL34) $(OVL35) $(OVL36) $(OVL37) $(OVL38) $(OVL39) $(OVL40)\
X       $(OVL41) $(OVL42) $(OVL43) $(OVL44) $(OVL45) $(OVL46) $(OVL47) $(OVL48)\
X       $(OVL49) $(OVL50) $(OVL51) $(OVL52) $(OVL53) $(OVL54) $(OVL55) $(OVL56)\
X       $(OVL57) $(OVL58) $(OVL59) $(OVL60) $(OVL61) $(OVL62) $(OVL63)
X
XVOBJ =	$(ROOT) $(MOBJ)
X
XHOBJ =	$(VOBJ) $(OBJ)\version.o
X
X# object files for makedefs
XMAKEOBJS    =	$(OBJ)\makedefs.o $(OBJ)\alloc.o    $(OBJ)\monst.o    \
X		$(OBJ)\objects.o  $(OBJ)\panic.o
X
XOVERLAYS = ($(OVL01)) ($(OVL02)) ($(OVL03)) ($(OVL04)) ($(OVL05)) ($(OVL06)) \
X	   ($(OVL07)) ($(OVL08)) ($(OVL09)) ($(OVL10)) ($(OVL11)) ($(OVL12)) \
X	   ($(OVL13)) ($(OVL14)) ($(OVL15)) ($(OVL16)) ($(OVL17)) ($(OVL18)) \
X	   ($(OVL19)) ($(OVL20)) ($(OVL21)) ($(OVL22)) ($(OVL23)) ($(OVL24)) \
X	   ($(OVL25)) ($(OVL26)) ($(OVL27)) ($(OVL28)) ($(OVL29)) ($(OVL30)) \
X	   ($(OVL31)) ($(OVL32)) ($(OVL33)) ($(OVL34)) ($(OVL35)) ($(OVL36)) \
X	   ($(OVL37)) ($(OVL38)) ($(OVL39)) ($(OVL40)) ($(OVL41)) ($(OVL42)) \
X	   ($(OVL43)) ($(OVL44)) ($(OVL45)) ($(OVL46)) ($(OVL47)) ($(OVL48)) \
X	   ($(OVL49)) ($(OVL50)) ($(OVL51)) ($(OVL52)) ($(OVL53)) ($(OVL54)) \
X	   ($(OVL55)) ($(OVL56)) ($(OVL57)) ($(OVL58)) ($(OVL59)) ($(OVL60)) \
X	   ($(OVL61)) ($(OVL62)      $(OBJ)\version.o) ($(OVL63))
X
X# object files for special levels compiler
XSPLEVOBJS   =	$(OBJ)\lev_comp.o $(OBJ)\lev_lex.o  $(OBJ)\lev_main.o \
X		$(OBJ)\alloc.o	  $(OBJ)\monst.o    $(OBJ)\objects.o  \
X		$(OBJ)\panic.o
X
X# *****************************************************************************
X# ************************** Header Objects ***********************************
X# *****************************************************************************
X
XPCCONF_H   = $(INCL)\$(TARG)conf.h $(INCL)\msdos.h    $(INCL)\system.h
XGLOBAL_H   = $(PCCONF_H)	   $(INCL)\coord.h    $(INCL)\global.h
XCONFIG_H   = $(GLOBAL_H)	   $(INCL)\config.h   $(INCL)\tradstdc.h
XPERMONST_H = $(INCL)\permonst.h    $(INCL)\monattk.h  $(INCL)\monflag.h
XYOUPROP_H  = $(PERMONST_H)	   $(INCL)\prop.h     $(INCL)\mondata.h \
X	     $(INCL)\pm.h	   $(INCL)\youprop.h
XYOU_H	   = $(YOUPROP_H)	   $(INCL)\attrib.h   $(INCL)\monst.h \
X	     $(INCL)\you.h
XDECL_H	   = $(YOU_H)		   $(INCL)\decl.h     $(INCL)\obj.h \
X	     $(INCL)\onames.h	   $(INCL)\spell.h    $(INCL)\color.h
XHACK_H	   = $(CONFIG_H)	   $(DECL_H)	      $(INCL)\trap.h \
X	     $(INCL)\flag.h	   $(INCL)\gold.h     $(INCL)\mkroom.h \
X	     $(INCL)\monsym.h	   $(INCL)\objclass.h $(INCL)\rm.h \
X	     $(INCL)\trampoli.h    $(INCL)\hack.h
X
X# *****************************************************************************
X# ************************ File Dependencies **********************************
X# *****************************************************************************
X
X# Due to an NDMake inadequacy these must accord with a topological sort of the
X# generated-from relation... output on the left, input on the right. Trust me.
X.SUFFIXES:  .exe .0 .0-1 .0-2 .0-3 .1 .1-2 .1-3 .1-b .2 .2-3 .2-b .3 .3-b .b \
X	    .o .c .y .l .obj .asm
X
X.c.o:
X	$(CC) $(CFLAGS) $(COSPACE) /Fo$(OBJ)\$*.o $*.c
X.c.0:
X	$(CC) $(CFLAGS) $(COSPEED) /DOVL0 /NT$*.0 /Fo$(OBJ)\$*.0 $*.c
X.c.0-1:
X	$(CC) $(CFLAGS) $(COSPEED) /DOVL0 /DOVL1 /NT$*.0-1 /Fo$(OBJ)\$*.0-1 $*.c
X.c.0-2:
X	$(CC) $(CFLAGS) $(COSPACE) /DOVL0 /DOVL1 /DOVL2 /NT$*.0-2 /Fo$(OBJ)\$*.0-2 $*.c
X.c.0-3:
X	$(CC) $(CFLAGS) $(COSPACE) /DOVL0 /DOVL1 /DOVL2 /DOVL3 /NT$*.0-3 /Fo$(OBJ)\$*.0-3 $*.c
X.c.1:
X	$(CC) $(CFLAGS) $(COSPACE) /DOVL1 /NT$*.1 /Fo$(OBJ)\$*.1 $*.c
X.c.1-2:
X	$(CC) $(CFLAGS) $(COSPACE) /DOVL1 /DOVL2 /NT$*.1-2 /Fo$(OBJ)\$*.1-2 $*.c
X.c.1-3:
X	$(CC) $(CFLAGS) $(COSPACE) /DOVL1 /DOVL2 /DOVL3 /NT$*.1-3 /Fo$(OBJ)\$*.1-3 $*.c
X.c.1-b:
X	$(CC) $(CFLAGS) $(COSPACE) /DOVL1 /DOVL2 /DOVL3 /DOVLB /NT$*.1-b /Fo$(OBJ)\$*.1-b $*.c
X.c.2:
X	$(CC) $(CFLAGS) $(COSPACE) /DOVL2 /NT$*.2 /Fo$(OBJ)\$*.2 $*.c
X.c.2-3:
X	$(CC) $(CFLAGS) $(COSPACE) /DOVL2 /DOVL3 /NT$*.2-3 /Fo$(OBJ)\$*.2-3 $*.c
X.c.2-b:
X	$(CC) $(CFLAGS) $(COSPACE) /DOVL2 /DOVL3 /DOVLB /NT$*.2-b /Fo$(OBJ)\$*.2-b $*.c
X.c.3:
X	$(CC) $(CFLAGS) $(COSPACE) /DOVL3 /NT$*.3 /Fo$(OBJ)\$*.3 $*.c
X.c.3-b:
X	$(CC) $(CFLAGS) $(COSPACE) /DOVL3 /DOVLB /NT$*.3-b /Fo$(OBJ)\$*.3-b $*.c
X.c.b:
X	$(CC) $(CFLAGS) $(COSPACE) /DOVLB /NT$*.b /Fo$(OBJ)\$*.b $*.c
X.asm.obj:
X	$(ASM) $(AFLAGS) $*.asm,$(OBJ)\$*.obj ;
X
X$(GAME): $(GAMEFILE)
X
X$(GAME).exe: $(GAMEFILE)
X
X$(GAMEFILE): $(OBJ) $(HOBJ)
X	@echo Loading....
X	$(LINK) $(ROOT) $(OVERLAYS),$(GAMEFILE),$(GAME),$(CLIB) $(TERMLIB) $(LFLAGS) ;
X	$(EXEPATCH) $(GAMEFILE) $(EXEFLAGS)
X	@echo NetHack is up to date.
X
X$(OBJ):
X	if not exist .\$(OBJ)\*.* mkdir $(OBJ)
X
X#	The following 3 modules vary depending on what OS you are using.
X
X$(OBJ)\main.o:	$(HACK_H) $(TARG)main.c
X	$(CC) $(CFLAGS) $(COSPACE)  /Fo.\$(OBJ)\main.o $(TARG)main.c
X
X$(OBJ)\tty.o:	$(HACK_H) $(INCL)\func_tab.h $(TARG)tty.c
X	$(CC) $(CFLAGS) $(COSPACE)  /Fo.\$(OBJ)\tty.o  $(TARG)tty.c
X
X$(OBJ)\unix.0:	$(HACK_H) $(TARG)unix.c
X	$(CC) $(CFLAGS) $(COSPEED)  /DOVL0 /Fo.\$(OBJ)\unix.0 $(TARG)unix.c
X$(OBJ)\unix.1-b:	$(HACK_H) $(TARG)unix.c
X	$(CC) $(CFLAGS) $(COSPACE)  /DOVL1 /DOVL2 /DOVL3 /DOVLB /Fo.\$(OBJ)\unix.1-b $(TARG)unix.c
X
X$(OBJ)\makedefs.o:	$(INCL)\config.h $(INCL)\permonst.h $(INCL)\objclass.h
X
Xmakedefs.exe:	$(MAKEOBJS)
X	$(LINK) $(LFLAGS) $(MAKEOBJS), makedefs.exe,, $(CLIB);
X
X#	Targets for the special levels compiler
X
Xlev_comp.c: lev_comp.y
X	$(MAKEBIN) do_yacc
X
Xlev_lex.c:  lev_comp.l
X	$(MAKEBIN) do_lex
X
Xyacc_msg:
X	@echo lev_comp.y has changed. To update lev_comp.c and lev_comp.h run YACC.
X
Xyacc_act:
X	$(YACC) -d lev_comp.y
X	copy $(YTABC) lev_comp.c
X	copy $(YTABH) $(INCL)\lev_comp.h
X	del $(YTABC)
X	del $(YTABH)
X
Xlex_msg:
X	@echo lev_comp.l has changed. To update lev_lex.c run LEX.
X
Xlex_act:
X	$(LEX) lev_comp.l
X	copy $(LEXYYC) lev_lex.c
X	del $(LEXYYC)
X
X#	This is stupid but since the default rule does not work here ...
X
X$(OBJ)\lev_comp.o:	$(HACK_H)   $(INCL)\sp_lev.h	lev_comp.c
X	$(CC) $(CFLAGS) /Fo$(OBJ)\$*.o $*.c
X$(OBJ)\lev_lex.o:	$(HACK_H)   $(INCL)\sp_lev.h	$(INCL)\lev_comp.h \
X			lev_lex.c
X	$(CC) $(CFLAGS) /Fo$(OBJ)\$*.o $*.c
X
Xlev_comp.exe:	$(SPLEVOBJS)
X	$(LINK) $(LFLAGS) $(SPLEVOBJS),lev_comp.exe,, $(CLIB);
X
X# *****************************************************************************
X# *************************  Makedefs Stuff ***********************************
X# *****************************************************************************
X#	The following include files depend on makedefs to be created.
X#	date.h should be remade any time any of the source or include code
X#	is modified.
X
X$(INCL)\date.h: $(VOBJ) makedefs.exe
X	.\makedefs -v
X
X$(INCL)\onames.h: makedefs.exe
X	.\makedefs -o
X
X$(INCL)\pm.h: makedefs.exe
X	.\makedefs -p
X
X$(INCL)\trap.h: makedefs.exe
X	.\makedefs -t
X
Xdata:	$(AUX)\data.bas makedefs.exe
X	.\makedefs -d
X
Xrumors: $(AUX)\rumors.tru $(AUX)\rumors.fal makedefs.exe
X	.\makedefs -r
X
X# *****************************************************************************
X# ************************ Secondary targets **********************************
X# *****************************************************************************
X
Xall:	install
X
Xinstall:	$(OBJ) lev_comp.exe $(GAMEFILE) auxil.tag install.tag
X	@echo Don't forget to check HACKDIR in NetHack.cnf.
X	@echo Done.
X
Xinstall.tag:
X	copy $(OTHERS)\termcap		$(GAMEDIR)
X	copy $(AUX)\*.			$(GAMEDIR)
X	del  $(GAMEDIR)\MacHelp
X	copy $(OTHERS)\NetHack.cnf	$(GAMEDIR)
X	echo install done > install.tag
X
Xspec_lev.tag: lev_comp.exe $(AUX)\castle.des $(AUX)\endgame.des $(AUX)\tower.des
X	lev_comp $(AUX)\castle.des
X	lev_comp $(AUX)\endgame.des
X	lev_comp $(AUX)\tower.des
X	copy castle $(GAMEDIR)
X	copy endgame $(GAMEDIR)
X	copy tower? $(GAMEDIR)
X	del castle
X	del endgame
X	del tower?
X	echo spec_lev done > spec_lev.tag
X
Xauxil.tag:	spec_lev.tag	data	rumors
X	echo special levels created > auxil.tag
X
Xclean:
X	del $(OBJ)\*.o
X	del $(OBJ)\*.0
X	del $(OBJ)\*.0-1
X	del $(OBJ)\*.0-2
X	del $(OBJ)\*.0-3
X	del $(OBJ)\*.1
X	del $(OBJ)\*.1-2
X	del $(OBJ)\*.1-3
X	del $(OBJ)\*.1-b
X	del $(OBJ)\*.2
X	del $(OBJ)\*.2-3
X	del $(OBJ)\*.2-b
X	del $(OBJ)\*.3
X	del $(OBJ)\*.3-b
X	del $(OBJ)\*.b
X	del $(OBJ)\*.obj
X	rmdir $(OBJ)
X
Xspotless: clean
X	del $(INCL)\date.h
X	del $(INCL)\onames.h
X	del $(INCL)\pm.h
X	if exist makedefs.exe del makedefs.exe
X	if exist lev_comp.exe del lev_comp.exe
X	del castle
X	del endgame
X	del tower?
X	del *.bak
X	del *.tag
X	del *.map
X	del *.obj
X	del *.lib
X	del *.txt
X	del $(AUX)\data
X	del $(AUX)\rumors
X
X# *****************************************************************************
X# ************************* Other dependencies ********************************
X# *****************************************************************************
X# Other dependencies
X#
X# I deleted that line.	;-}
X
X$(OBJ)\allmain.0:	$(HACK_H)
X$(OBJ)\allmain.1:	$(HACK_H)
X$(OBJ)\allmain.2-b:	$(HACK_H)
X$(OBJ)\alloc.o: 	$(CONFIG_H)
X$(OBJ)\apply.0: 	$(HACK_H)   $(INCL)\edog.h
X$(OBJ)\apply.1: 	$(HACK_H)   $(INCL)\edog.h
X$(OBJ)\apply.2-b:	$(HACK_H)   $(INCL)\edog.h
X$(OBJ)\artifact.0:	$(HACK_H)   $(INCL)\artifact.h
X$(OBJ)\artifact.1:	$(HACK_H)   $(INCL)\artifact.h
X$(OBJ)\artifact.2:	$(HACK_H)   $(INCL)\artifact.h
X$(OBJ)\artifact.b:	$(HACK_H)   $(INCL)\artifact.h
X$(OBJ)\attrib.0:	$(HACK_H)
X$(OBJ)\attrib.1:	$(HACK_H)
X$(OBJ)\attrib.2-b:	$(HACK_H)
X$(OBJ)\bones.o: 	$(HACK_H)
X$(OBJ)\cmd.0:		$(HACK_H)   $(INCL)\func_tab.h
X$(OBJ)\cmd.1:		$(HACK_H)   $(INCL)\func_tab.h
X$(OBJ)\cmd.2-b: 	$(HACK_H)   $(INCL)\func_tab.h
X$(OBJ)\dbridge.0:	$(HACK_H)
X$(OBJ)\dbridge.1-b:	$(HACK_H)
X$(OBJ)\decl.o:		$(HACK_H)
X$(OBJ)\demon.o: 	$(HACK_H)
X$(OBJ)\do.0:		$(HACK_H)
X$(OBJ)\do.1:		$(HACK_H)
X$(OBJ)\do.2:		$(HACK_H)
X$(OBJ)\do.3:		$(HACK_H)
X$(OBJ)\do.b:		$(HACK_H)
X$(OBJ)\do_name.0:	$(HACK_H)
X$(OBJ)\do_name.1-b:	$(HACK_H)
X$(OBJ)\do_wear.0-1:	$(HACK_H)
X$(OBJ)\do_wear.2:	$(HACK_H)
X$(OBJ)\do_wear.b:	$(HACK_H)
X$(OBJ)\dog.0:		$(HACK_H)   $(INCL)\edog.h
X$(OBJ)\dog.1:		$(HACK_H)   $(INCL)\edog.h
X$(OBJ)\dog.2:		$(HACK_H)   $(INCL)\edog.h
X$(OBJ)\dog.b:		$(HACK_H)   $(INCL)\edog.h
X$(OBJ)\dogmove.o:	$(HACK_H)   $(INCL)\mfndpos.h	 $(INCL)\edog.h
X$(OBJ)\dokick.o:	$(HACK_H)   $(INCL)\eshk.h
X$(OBJ)\dothrow.o:	$(HACK_H)
X$(OBJ)\eat.0:		$(HACK_H)
X$(OBJ)\eat.1:		$(HACK_H)
X$(OBJ)\eat.2-b: 	$(HACK_H)
X$(OBJ)\end.o:		$(HACK_H)   $(INCL)\eshk.h
X$(OBJ)\engrave.0-1:	$(HACK_H)
X$(OBJ)\engrave.2:	$(HACK_H)
X$(OBJ)\engrave.b:	$(HACK_H)
X$(OBJ)\exper.o: 	$(HACK_H)
X$(OBJ)\extralev.o:	$(HACK_H)
X$(OBJ)\fountain.o:	$(HACK_H)
X$(OBJ)\getline.0-1:	$(HACK_H)   $(INCL)\func_tab.h
X$(OBJ)\getline.2:	$(HACK_H)   $(INCL)\func_tab.h
X$(OBJ)\getline.b:	$(HACK_H)   $(INCL)\func_tab.h
X$(OBJ)\hack.0:		$(HACK_H)
X$(OBJ)\hack.1:		$(HACK_H)
X$(OBJ)\hack.2:		$(HACK_H)
X$(OBJ)\hack.b:		$(HACK_H)
X$(OBJ)\invent.0:	$(HACK_H)   $(INCL)\lev.h	 $(INCL)\wseg.h
X$(OBJ)\invent.1:	$(HACK_H)   $(INCL)\lev.h	 $(INCL)\wseg.h
X$(OBJ)\invent.2:	$(HACK_H)   $(INCL)\lev.h	 $(INCL)\wseg.h
X$(OBJ)\invent.3:	$(HACK_H)   $(INCL)\lev.h	 $(INCL)\wseg.h
X$(OBJ)\invent.b:	$(HACK_H)   $(INCL)\lev.h	 $(INCL)\wseg.h
X$(OBJ)\ioctl.o: 	$(HACK_H)
X$(OBJ)\lev_main.o:	$(HACK_H)   $(INCL)\sp_lev.h
X$(OBJ)\lock.0:		$(HACK_H)
X$(OBJ)\lock.1-b:	$(HACK_H)
X$(OBJ)\mail.0:		$(HACK_H)
X$(OBJ)\mail.1-b:	$(HACK_H)
X$(OBJ)\makemon.0-2:	$(HACK_H)
X$(OBJ)\makemon.b:	$(HACK_H)
X$(OBJ)\mcastu.o:	$(HACK_H)
X$(OBJ)\mhitm.0: 	$(HACK_H)   $(INCL)\artifact.h
X$(OBJ)\mhitm.1-b:	$(HACK_H)   $(INCL)\artifact.h
X$(OBJ)\mhitu.0-1:	$(HACK_H)   $(INCL)\artifact.h	 $(INCL)\edog.h
X$(OBJ)\mhitu.2-b:	$(HACK_H)   $(INCL)\artifact.h	 $(INCL)\edog.h
X$(OBJ)\mklev.o: 	$(HACK_H)
X$(OBJ)\mkmaze.o:	$(HACK_H)
X$(OBJ)\mkobj.0: 	$(HACK_H)
X$(OBJ)\mkobj.1: 	$(HACK_H)
X$(OBJ)\mkobj.2-b:	$(HACK_H)
X$(OBJ)\mkroom.0:	$(HACK_H)
X$(OBJ)\mkroom.1-b:	$(HACK_H)
X$(OBJ)\mon.0-1: 	$(HACK_H)   $(INCL)\mfndpos.h	 $(INCL)\wseg.h
X$(OBJ)\mon.2-b: 	$(HACK_H)   $(INCL)\mfndpos.h	 $(INCL)\wseg.h
X$(OBJ)\mondata.0-1:	$(HACK_H)   $(INCL)\eshk.h	 $(INCL)\epri.h
X$(OBJ)\mondata.2:	$(HACK_H)   $(INCL)\eshk.h	 $(INCL)\epri.h
X$(OBJ)\mondata.b:	$(HACK_H)   $(INCL)\eshk.h	 $(INCL)\epri.h
X$(OBJ)\monmove.0-1:	$(HACK_H)   $(INCL)\mfndpos.h	 $(INCL)\artifact.h
X$(OBJ)\monmove.2-b:	$(HACK_H)   $(INCL)\mfndpos.h	 $(INCL)\artifact.h
X$(OBJ)\monst.o: 	$(CONFIG_H) $(PERMONST_H)	 $(INCL)\eshk.h \
X			$(INCL)\vault.h $(INCL)\epri.h	 $(INCL)\color.h
X$(OBJ)\msdos.o: 	$(HACK_H)
X$(OBJ)\mthrowu.0:	$(HACK_H)
X$(OBJ)\mthrowu.1:	$(HACK_H)
X$(OBJ)\mthrowu.2-b:	$(HACK_H)
X$(OBJ)\music.o: 	$(HACK_H)
X$(OBJ)\o_init.o:	$(HACK_H)
X$(OBJ)\objects.o:	$(CONFIG_H) $(INCL)\obj.h	 $(INCL)\objclass.h \
X			$(INCL)\prop.h	$(INCL)\color.h
X$(OBJ)\objnam.0-1:	$(HACK_H)
X$(OBJ)\objnam.2-b:	$(HACK_H)
X$(OBJ)\options.o:	$(HACK_H)
X$(OBJ)\pager.0: 	$(HACK_H)
X$(OBJ)\pager.1-b:	$(HACK_H)
X$(OBJ)\panic.o: 	$(CONFIG_H)
X$(OBJ)\pickup.0:	$(HACK_H)
X$(OBJ)\pickup.1:	$(HACK_H)
X$(OBJ)\pickup.2-b:	$(HACK_H)
X$(OBJ)\polyself.0-1:	$(HACK_H)
X$(OBJ)\polyself.2-b:	$(HACK_H)
X$(OBJ)\potion.o:	$(HACK_H)
X$(OBJ)\pray.o:		$(HACK_H)
X$(OBJ)\pri.0:		$(HACK_H)   $(INCL)\epri.h	 $(INCL)\termcap.h
X$(OBJ)\pri.1:		$(HACK_H)   $(INCL)\epri.h	 $(INCL)\termcap.h
X$(OBJ)\pri.2:		$(HACK_H)   $(INCL)\epri.h	 $(INCL)\termcap.h
X$(OBJ)\pri.b:		$(HACK_H)   $(INCL)\epri.h	 $(INCL)\termcap.h
X$(OBJ)\priest.0:	$(HACK_H)   $(INCL)\mfndpos.h	 $(INCL)\eshk.h \
X			$(INCL)\epri.h
X$(OBJ)\priest.1-b:	$(HACK_H)   $(INCL)\mfndpos.h	 $(INCL)\eshk.h \
X			$(INCL)\epri.h
X$(OBJ)\prisym.0:	$(HACK_H)   $(INCL)\lev.h	 $(INCL)\wseg.h
X$(OBJ)\prisym.1:	$(HACK_H)   $(INCL)\lev.h	 $(INCL)\wseg.h
X$(OBJ)\prisym.2:	$(HACK_H)   $(INCL)\lev.h	 $(INCL)\wseg.h
X$(OBJ)\prisym.b:	$(HACK_H)   $(INCL)\lev.h	 $(INCL)\wseg.h
X$(OBJ)\random.o:
X$(OBJ)\read.0:		$(HACK_H)
X$(OBJ)\read.1-b:	$(HACK_H)
X$(OBJ)\restore.o:	$(HACK_H)   $(INCL)\lev.h	 $(INCL)\wseg.h
X$(OBJ)\rip.o:		$(HACK_H)
X$(OBJ)\rnd.0:		$(HACK_H)
X$(OBJ)\rnd.1:		$(HACK_H)
X$(OBJ)\rnd.2-b: 	$(HACK_H)
X$(OBJ)\rumors.o:	$(HACK_H)
X$(OBJ)\save.o:		$(HACK_H)   $(INCL)\lev.h	 $(INCL)\wseg.h
X$(OBJ)\search.0:	$(HACK_H)   $(INCL)\artifact.h
X$(OBJ)\search.1-b:	$(HACK_H)   $(INCL)\artifact.h
X$(OBJ)\shk.0:		$(HACK_H)   $(INCL)\eshk.h
X$(OBJ)\shk.1-b: 	$(HACK_H)   $(INCL)\eshk.h
X$(OBJ)\shknam.0:	$(HACK_H)   $(INCL)\eshk.h
X$(OBJ)\shknam.1-b:	$(HACK_H)   $(INCL)\eshk.h
X$(OBJ)\sit.o:		$(HACK_H)
X$(OBJ)\sounds.0:	$(HACK_H)   $(INCL)\edog.h	 $(INCL)\eshk.h
X$(OBJ)\sounds.1-b:	$(HACK_H)   $(INCL)\edog.h	 $(INCL)\eshk.h
X$(OBJ)\sp_lev.o:	$(HACK_H)   $(INCL)\sp_lev.h
X$(OBJ)\spell.o: 	$(HACK_H)
X$(OBJ)\steal.0-1:	$(HACK_H)
X$(OBJ)\steal.2-b:	$(HACK_H)
X$(OBJ)\termcap.0:	$(HACK_H)   $(INCL)\termcap.h
X$(OBJ)\termcap.1:	$(HACK_H)   $(INCL)\termcap.h
X$(OBJ)\termcap.2-b:	$(HACK_H)   $(INCL)\termcap.h
X$(OBJ)\timeout.0:	$(HACK_H)
X$(OBJ)\timeout.1-b:	$(HACK_H)
X$(OBJ)\topl.0:		$(HACK_H)
X$(OBJ)\topl.1-2:	$(HACK_H)
X$(OBJ)\topl.b:		$(HACK_H)
X$(OBJ)\topten.o:	$(HACK_H)
X$(OBJ)\track.0: 	$(HACK_H)
X$(OBJ)\track.1: 	$(HACK_H)
X$(OBJ)\track.2-b:	$(HACK_H)
X$(OBJ)\trampoli.o:	$(HACK_H)
X$(OBJ)\trap.0-1:	$(HACK_H)   $(INCL)\edog.h
X$(OBJ)\trap.2:		$(HACK_H)   $(INCL)\edog.h
X$(OBJ)\trap.b:		$(HACK_H)   $(INCL)\edog.h
X$(OBJ)\u_init.o:	$(HACK_H)
X$(OBJ)\uhitm.o: 	$(HACK_H)   $(INCL)\artifact.h
X$(OBJ)\vault.0: 	$(HACK_H)   $(INCL)\vault.h
X$(OBJ)\vault.1-b:	$(HACK_H)   $(INCL)\vault.h
X$(OBJ)\version.o:	$(HACK_H)   $(INCL)\date.h	 $(INCL)\patchlev.h
X$(OBJ)\weapon.0-1:	$(HACK_H)
X$(OBJ)\weapon.2-b:	$(HACK_H)
X$(OBJ)\were.0:		$(HACK_H)
X$(OBJ)\were.1-b:	$(HACK_H)
X$(OBJ)\wield.o: 	$(HACK_H)
X$(OBJ)\wizard.0:	$(HACK_H)
X$(OBJ)\wizard.1-b:	$(HACK_H)
X$(OBJ)\worm.o:		$(HACK_H)   $(INCL)\wseg.h
X$(OBJ)\worn.o:		$(HACK_H)
X$(OBJ)\write.o: 	$(HACK_H)
X$(OBJ)\zap.o:		$(HACK_H)
END_OF_FILE
if test 24533 -ne `wc -c <'others/Makefile.ovl'`; then
    echo shar: \"'others/Makefile.ovl'\" unpacked with wrong size!
fi
# end of 'others/Makefile.ovl'
fi
echo shar: End of archive 33 \(of 56\).
cp /dev/null ark33isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 56 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
