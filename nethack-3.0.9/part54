Path: utzoo!utgpu!news-server.csri.toronto.edu!mailrus!cornell!uw-beaver!zephyr.ens.tek.com!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v10i099:  nethack3p9 -  display oriented dungeons & dragons (Ver. 3.0i), Part54/56
Message-ID: <5959@tekred.CNA.TEK.COM>
Date: 13 Jul 90 19:46:41 GMT
Sender: news@tekred.CNA.TEK.COM
Lines: 2044
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 10, Issue 99
Archive-name: nethack3p9/Part54
Supersedes: NetHack3: Volume 7, Issue 56-93



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 54 (of 56)."
# Contents:  amiga/amifont8.uu auxil/endgame.des auxil/hh auxil/history
#   include/amiconf.h include/monattk.h include/monst.h include/obj.h
#   include/objclass.h include/prop.h include/vmsconf.h
#   others/NetHack.cnf src/demon.c src/lev_comp.l src/version.c
#   src/write.c
# Wrapped by billr@saab on Wed Jul 11 17:12:18 1990
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'amiga/amifont8.uu' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'amiga/amifont8.uu'\"
else
echo shar: Extracting \"'amiga/amifont8.uu'\" \(2955 characters\)
sed "s/^X//" >'amiga/amifont8.uu' <<'END_OF_FILE'
X
Xbegin 644 8
XM```#\P`````````!``````````````'Y```#Z0```?EP_TYU```````````,5
XM`````!H/@``!``````````````````````````````````````````!&140`Y
XM```````````,`````!H`````!W0`"`!```@`!@`!```@_P```&X`?@``!%X`E
XM```````````8;&P8`#@8##````````,\&#P\''X<?CP\```,`#`\?!C\//C^)
XM_CQF?@[F\(+&./PX_#Q^9L/&P\/^/,`\$``8`.``#@`<`.`8!N`X````````?
XM``@````````.&'!RS,%F````9F9F&!@````8&!@``!@88L!F`&9F&``8&``\U
XM;&P^QFP8&!AF&`````9F.&9F/&`P9F9F&!@8`!AFQCQF9FQF9F9F&`9F8,;FD
XM;&9L9F9:9L/&9L/&,&`,.``8`&``!@`V`&```&`8`````````!@````````82
XM&!B<,V-F````9F9F/!@````8&!@``!@\96-F`&9F&``8&``\`/Y@S&@P,`P\B
XM&`````QN&`8&;'Q@!F9F&!@P?@P&WCQFP&9@8,!F&`9L8.[VQF;&9G`89F;&,
XM/&:,,#`,;``,/&P\-CPP.VPX!F889GP\W#WL/CYF9F-C9GX8&!@`S#9F_W_^\
XM9^;G/!@````8&!@``!AF8#9G_^;G&``8&``8`&P\&'8`,`S_?@!^`!A^&!P<*
XMS`9\##P^``!@``8,WF9\P&9X>,Y^&`9X8/[>QGS&?#@89F;6&#P8,!@,Q@``V
XM!G9F;F9X9G88!FP8=V9F9F9V8!AF9FLV9DQP&`X`,QQF`&`&8`8`9AC_'_@?2
XM^/\``-O#?AM@``8`'__X_P`8`/X&,-P`,`P\&````#!V&#`&_@9F&&8&```PS
XM``P8WGYFP&9@8,9F&&9L8M;.QF#&;`X89CS^/!@R,`P,````'F9@9GXP9F88P
XM!G@8:V9F9F9F/!AF9FL<9A@8&!@`S!QF`&`&8`8`9A@`&!@``!@``,/;9NQ@<
XM``8`&!@8`````&Q\9LP`&!AF&!@`&&!F&&9F#&9F&&8,&!@8?A@`P,-F9FQF1
XM8&9F&&9F9L;&;&!L9F889CSN9AAF,`8,````9F9F9F`P/&88!FP88V9F?#Y@)
XM!AIF/#8V/#(8&!@`,S9F_V?F?_[GPQ@`&!@``!AS`&889C9GY^;_&!@8```8F
XM`&P8QG8`##```!@`&,`\?GX\'CP\&#PX&!@,`#`8>,/\//C^\#YF?CSF_L;&M
XM./`\XSP\/AC&PSS^/`,\````.SP\.SQXQN8\9N8\8V8\8`;P?`P[&#9C&'X.8
XM&'``S&-F`&9F``!FPQ@`&!@``!B<&#P89F-F9F8`&!@8````````````````]
XM`#```````````````````#`````````````````````````````&````````F
XM`````````/X`````````?```/```````\`<`````````<```````,\%F`&9F#
XM``!F`!@`&!@``!@``!@8`,!F9F8`&!@8``````@`"``(`!``"``8``@`(``(H
XM`"@`"``P``@`.``(`$``"`!(``@`4``(`%@`"`!@``@`:``(`'``"`!X``@`(
XM@``(`(@`"`"0``@`F``(`*``"`"H``@`L``(`+@`"`#```@`R``(`-``"`#8H
XM``@`X``(`.@`"`#P``@`^``(`0``"`$(``@!$``(`1@`"`$@``@!*``(`3``W
XM"`$X``@!0``(`4@`"`%0``@!6``(`6``"`%H``@!<``(`7@`"`&```@!B``(+
XM`9``"`&8``@!H``(`:@`"`&P``@!N``(`<``"`'(``@!T``(`=@`"`'@``@!,
XMZ``(`?``"`'X``@"```(`@@`"`(0``@"&``(`B``"`(H``@",``(`C@`"`)`<
XM``@"2``(`E``"`)8``@"8``(`F@`"`)P``@">``(`H``"`*(``@"D``(`I@`^
XM"`*@``@"J``(`K``"`*X``@"P``(`L@`"`+0``@"V``(`N``"`+H``@"\``(.
XM`O@`"`,```@#```(`P``"`,```@#```(`P``"`,```@#```(`P``"`,```@#S
XM```(`P``"`,```@#```(`P``"`,```@#```(`P``"`,```@#```(`P``"`,`Y
XM``@#```(`P``"`,```@#```(`P``"`,```@#```(`P``"`,```@#```(`P``Y
XM"``(``@`$``(`!@`"``@``@`*``(`#``"``X``@`0``(`$@`"`!0``@`6``(P
XM`&``"`!H``@`<``(`'@`"`"```@`B``(`)``"`"8``@`H``(`*@`"`"P``@`P
XMN``(`,``"`#(``@`T``(`-@`"`#@``@`Z``(`/``"`#X``@#"``(`Q``"`,8I
XM``@#(``(`R@`"`,P``@#.``(`T``"`-(``@#4``(`U@`"`-@``@#:``(`W``1
XM"`-X``@#@``(`X@`"`.0``@#F``(`Z``"`.H``@#L``(`[@`"`/```@#R``(A
XM`P``"`,```@!V``(`>``"`'H``@!\``(`?@`"`(```@#T``(`]@`"`/@``@#!
XMZ``(`P``"`,```@#```(`P``"`,```@#```(`P``"`,```@#```(`P``"`,`A
XM``@#```(`P``"`,```@#```(`P``"`,```@#```(`P``"`,```@#```(`P``Y
XM"`+8``@"X``(`N@`"`+P``@"^``(````"``````#[`````0`````````#@``+
X2`$0```!<````8@````````/RW
X``
Xend
Xsize 2088
END_OF_FILE
if test 2955 -ne `wc -c <'amiga/amifont8.uu'`; then
    echo shar: \"'amiga/amifont8.uu'\" unpacked with wrong size!
fi
# end of 'amiga/amifont8.uu'
fi
if test -f 'auxil/endgame.des' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'auxil/endgame.des'\"
else
echo shar: Extracting \"'auxil/endgame.des'\" \(3509 characters\)
sed "s/^X//" >'auxil/endgame.des' <<'END_OF_FILE'
X#	SCCS Id: @(#)endgame.des	3.0	89/07/02
X#	Copyright (c) 1989 by Jean-Christophe Collet
X# NetHack may be freely redistributed.  See license for details.
X#
X# This is the ENDGAME level
X# It's made of 3 shrines and a fighting area
X# Players are supposed to sacrifice the Amulet of Yendor on the appropriate
X# shrine. But to get to the shrines, they must cross the fighting area...
X
X# First shrine
XMAZE:"endgame"
XGEOMETRY:left,top
XMAP
X}}}}}}
X}}..}}
X}}....
X}}..}}
X}}}}}}
XENDMAP
XALTAR:(02,02),align[0],shrine
XMAZEWALK:(05,02),east
X
X# Second Shrine
XGEOMETRY:left,center
XMAP
X}}}}}}
X}}..}}
X}}....
X}}..}}
X}}}}}}
XENDMAP
XALTAR:(02,02),align[1],shrine
XMAZEWALK:(05,02),east
X
X# Third Shrine
XGEOMETRY:left,bottom
XMAP
X}}}}}}
X}}..}}
X}}....
X}}..}}
X}}}}}}
XENDMAP
XALTAR:(02,02),align[2],shrine
XMAZEWALK:(05,02),east
X
X# Note that the shrine alignments are random...
X
X# The fighting area : 7 rooms.
X# Each room contains a specific class of monsters.
X# Maybe this a little bit too hard (We have to test it in real game)
X
XGEOMETRY:center,center
XMAP
X.-----------------------------.
X.|........S.........|........S.
X.|........|.........|........|.
X.|........|.........|........|.
X.|........|.........|........|.
X.-S--------.........-S--------.
X.|........|.........|........|.
X.|........|.........|........|.
X.|........|}}}}.}}}}|........|.
X.|........|.........|........|.
X.|........|.........|........|.
X.--------S-.........--------S-.
X.|........|.........|........|.
X.|........|.........|........|.
X.|........|.........|........|.
X.S........|.........S........|.
X.-----------------------------.
XENDMAP
XMAZEWALK:(30,08),east
XMAZEWALK:(00,08),west
X# Non diggable walls
XNON_DIGGABLE:(00,00,30,16)
X# Doors
XDOOR:closed,(10,01)
XDOOR:closed,(29,01)
XDOOR:locked,(02,05)
XDOOR:locked,(21,05)
XDOOR:locked,(09,11)
XDOOR:closed,(28,11)
XDOOR:locked,(01,15)
XDOOR:locked,(20,15)
X# Rooms
XREGION:(02,01,09,04),lit,"ordinary"
XREGION:(21,01,28,04),lit,"ordinary"
XREGION:(02,06,09,10),lit,"ordinary"
XREGION:(21,06,28,10),lit,"ordinary"
XREGION:(02,12,09,15),lit,"ordinary"
XREGION:(21,12,28,15),lit,"ordinary"
XREGION:(11,01,19,15),unlit,"ordinary"
X# Rust monsters in the first room
XMONSTER:'R',random,(22,01)
XMONSTER:'R',random,(27,01)
XMONSTER:'R',random,(24,03)
XMONSTER:'R',random,(22,04)
XMONSTER:'R',random,(27,04)
X# Liches in the second one
XMONSTER:'L',random,(22,06)
XMONSTER:'L',random,(27,06)
XMONSTER:'L',random,(22,08)
XMONSTER:'L',random,(27,08)
XMONSTER:'L',random,(22,10)
XMONSTER:'L',random,(27,10)
X# Nagas in the 3rd one
XMONSTER:'N',random,(22,12)
XMONSTER:'N',random,(27,12)
XMONSTER:'N',random,(24,14)
XMONSTER:'N',random,(22,15)
XMONSTER:'N',random,(27,15)
X# Dragons in the central one
XMONSTER:'D',random,(12,02)
XMONSTER:'D',random,(18,02)
XMONSTER:'D',random,(13,03)
XMONSTER:'D',random,(17,04)
XMONSTER:'D',random,(13,06)
XMONSTER:'D',random,(17,06)
XMONSTER:'D',random,(12,07)
XMONSTER:'D',random,(18,07)
X# with krakens in the trenches
XMONSTER:';',"kraken",(12,08)
XMONSTER:';',"kraken",(14,08)
XMONSTER:';',"kraken",(16,08)
XMONSTER:';',"kraken",(18,08)
X# Giants in the 5th one
XMONSTER:'H',random,(03,01)
XMONSTER:'H',random,(07,01)
XMONSTER:'H',random,(05,03)
XMONSTER:'H',random,(03,04)
XMONSTER:'H',random,(07,04)
X# Ogres in the 6th one
XMONSTER:'O',random,(03,06)
XMONSTER:'O',random,(07,06)
XMONSTER:'O',random,(03,08)
XMONSTER:'O',random,(07,08)
XMONSTER:'O',random,(03,10)
XMONSTER:'O',random,(07,10)
X# Trolls in the last one
XMONSTER:'T',random,(03,12)
XMONSTER:'T',random,(07,12)
XMONSTER:'T',random,(05,14)
XMONSTER:'T',random,(03,15)
XMONSTER:'T',random,(07,15)
END_OF_FILE
if test 3509 -ne `wc -c <'auxil/endgame.des'`; then
    echo shar: \"'auxil/endgame.des'\" unpacked with wrong size!
fi
# end of 'auxil/endgame.des'
fi
if test -f 'auxil/hh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'auxil/hh'\"
else
echo shar: Extracting \"'auxil/hh'\" \(3565 characters\)
sed "s/^X//" >'auxil/hh' <<'END_OF_FILE'
Xy k u	7 8 9	Move commands:
X \|/	 \|/		yuhjklbn: go one step in specified direction
Xh-.-l	4-.-6		YUHJKLBN: go in specified direction until you
X /|\	 /|\			    hit a wall or run into something
Xb j n	1 2 3		g<dir>:   run in direction <dir> until something
X      numberpad 		    interesting is seen
X			G<dir>,   same, except a branching corridor isn't
X			^<dir>:     considered interesting
X			m<dir>:   move without picking up objects
X		If the number_pad option is set, the number keys move instead.
X
XGeneral commands:
X?	help	display one of several informative texts
XQ	quit	end the game
XS	save	save the game (to be continued later)
X!	sh	escape to some SHELL (if allowed)
X^Z	suspend suspend the game (independent of your current suspend char)
XO	options set options
X/	whatis	tell what a map symbol represents
X\	known	display list of what's been discovered
Xv	version	display version number
XV	history	display game history
XX	explore	switch the game to explore (discovery) mode
X^A	again	redo the previous command (^A denotes the keystroke CTRL-A)
X^R	redraw	redraw the screen
X^P	prevmsg	repeat previous message (subsequent ^P's repeat earlier ones)
X#		introduces an extended command (#? for a list of them)
X
XGame commands:
X^D	kick	kick (a door, or something else)
X^T	'port	teleport (if you can)
Xa	apply	apply or use a tool (pick-axe, key, camera, etc.)
XA	armor	take off all armor
Xc	close	close a door
XC	call	name an individual monster (ex. baptize your dog)
Xd	drop	drop an object.  d7a:  drop seven items of object 'a'
XD	Drop	drop selected types of objects
Xe	eat	eat something
XE	engrave write a message in the dust on the floor  (E-  use fingers)
Xi	invent	list your inventory (all objects you are carrying)
XI	Invent	list selected parts of your inventory
X		Iu: list unpaid objects
X		Ix: list unpaid but used up items
X		I$: count your money
Xo	open	open a door
Xp	pay	pay your bill (in a shop)
XP	puton	put on a ring or amulet
Xq	quaff	drink a potion
Xr	read	read a scroll or spell book
XR	remove	remove a ring or amulet
Xs	search	search for secret doors, hidden traps and monsters
Xt	throw	throw or shoot a weapon
XT	takeoff	take off some armor
Xw	wield	wield a weapon	(w-  wield nothing)
XW	wear	put on some armor
Xx	spells	list the spells you know
Xz	zap	zap a wand
XZ	Zap	cast a spell
X<	up	go up the stairs
X>	down	go down the stairs
X^	trap_id identify a previously found trap
X),[,=,",(		ask for current items of specified symbol in use
X$	gold	count your gold
X+	spells	list the spells you know
X.	rest	wait a moment
X,	pickup	pick up all you can carry
X@		toggle "pickup" (auto pickup) option on and off
X:	look	look at what is here
X
XKeyboards that have a meta key can also use these extended commands:
X
XM-c	chat	talk to someone
XM-d	dip	dip an object into something
XM-f	force	force a lock
XM-j	jump	jump to another location
XM-l	loot	loot a box on the floor
XM-m	monster	use a monster's special ability (only if defined)
XM-N	name	name an item or type of object
XM-o	offer	offer a sacrifice to the gods (only if defined)
XM-p	pray	pray to the gods for help (only if defined)
XM-r	rub	rub a lamp
XM-s	sit	sit down
XM-t	turn	turn undead
XM-u	untrap	untrap something (usually a trapped object)
XM-v	version print compile time options for this version
XM-w	wipe	wipe off your face
X
XIf the "number_pad" option is on, these additional commands are available:
X
Xn		followed by number of times to repeat the next command
Xj	jump	jump to another location
Xk	kick	kick something (usually a door)
Xl	loot	loot a box on the floor
XN	name	name an item or type of object
Xu	untrap	untrap something (usually a trapped object)
END_OF_FILE
if test 3565 -ne `wc -c <'auxil/hh'`; then
    echo shar: \"'auxil/hh'\" unpacked with wrong size!
fi
# end of 'auxil/hh'
fi
if test -f 'auxil/history' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'auxil/history'\"
else
echo shar: Extracting \"'auxil/history'\" \(3151 characters\)
sed "s/^X//" >'auxil/history' <<'END_OF_FILE'
X
XBehold, mortal, the origins of NetHack...
X
XJay Fenlason wrote the original Hack with help from Kenny Woodland,
XMike Thome, and Jon Payne.
X
XAndries Brouwer did a major re-write, transforming Hack into a very different
Xgame, and published (at least) three versions (1.0.1, 1.0.2, and 1.0.3) for
XUNIX(tm) machines to the Usenet.
X
XDon G. Kneller ported Hack 1.0.3 to Microsoft(tm) C and MS-DOS(tm), producing
XPC HACK 1.01e, added support for DEC Rainbow graphics in version 1.03g, and
Xwent on to produce at least four more versions (3.0, 3.2, 3.51, and 3.6).
X
XR. Black ported PC HACK 3.51 to Lattice(tm) C and the Atari 520/1040ST,
Xproducing ST Hack 1.03.
X
XMike Stephenson merged these various versions back together, incorporating
Xmany of the added features, and produced NetHack version 1.4.  He then
Xcoordinated a cast of thousands in enhancing and debugging NetHack 1.4 and
Xreleased NetHack versions 2.2 and 2.3.
X 
XLater, Mike coordinated a major rewrite of the game, heading a team which
Xincluded Ken Arromdee, Jean-Christophe Collet, Steve Creps, Eric Hendrickson,
XIzchak Miller, Eric S. Raymond, John Rupley, Mike Threepoint, and Janet Walz,
Xto produce NetHack 3.0c.
X
XNetHack 3.0 was ported to the Atari by Eric R. Smith, to OS/2 by Timo
XHakulinen, and to VMS by David Gentzel.  The three of them and Kevin Darcy
Xlater joined the main development team to produce subsequent revisions of
X3.0.
X
XOlaf Seibert ported NetHack 2.3 and 3.0 to the Amiga.  Norm Meluch, Stephen
XSpackman and Pierre Martineau designed overlay code for PC NetHack 3.0.
XJohnny Lee ported NetHack 3.0 to the Macintosh.  Along with various other
XDungeoneers, they continued to enhance the PC, Macintosh, and Amiga ports
Xthrough the later revisions of 3.0.
X 
X                           - - - - - - - - - -
X 
XFrom time to time, some depraved individual out there in netland sends a
Xparticularly intriguing modification to help out with the game.  The Gods of
Xthe Dungeon sometimes make note of the names of the worst of these miscreants
Xin this, the list of Dungeoneers:
X
X    Richard Addison           Bruce Holloway         Pat Rankin
X    Tom Almy                  Richard P. Hughey      Eric S. Raymond
X    Ken Arromdee              Ari Huttunen           John Rupley
X    Eric Backus               Del Lamb               Olaf Seibert
X    John S. Bien              Greg Laskin            Kevin Sitze
X    Ralf Brown                Johnny Lee             Eric R. Smith
X    Jean-Christophe Collet    Steve Linhart          Kevin Smolkowski
X    Steve Creps               Ken Lorber             Michael Sokolov
X    Kevin Darcy               Benson I. Margulies    Stephen Spackman
X    Matthew Day               Pierre Martineau       Andy Swanson
X    Joshua Delahunty          Roland McGrath         Kevin Sweet
X    Jochen Erwied             Norm Meluch            Scott R. Turner
X    David Gentzel             Bruce Mewborne         Janet Walz
X    Mark Gooderum             Izchak Miller          Jon Watte
X    David Hairston            Gil Neiger             Tom West
X    Timo Hakulinen            Greg Olson             Gregg Wonderly
X    Eric Hendrickson          Mike Passaretti
END_OF_FILE
if test 3151 -ne `wc -c <'auxil/history'`; then
    echo shar: \"'auxil/history'\" unpacked with wrong size!
fi
# end of 'auxil/history'
fi
if test -f 'include/amiconf.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/amiconf.h'\"
else
echo shar: Extracting \"'include/amiconf.h'\" \(3368 characters\)
sed "s/^X//" >'include/amiconf.h' <<'END_OF_FILE'
X/*	SCCS Id: @(#)amiconf.h  3.0     89/09/04
X/* NetHack may be freely redistributed.  See license for details. */
X
X#ifndef AMICONF_H
X#define AMICONF_H
X
X#undef abs		/* avoid using macro form of abs */
X#undef min		/* this gets redefined */
X#undef max		/* this gets redefined */
X
X#include <time.h>	/* get time_t defined before use! */
X
X#ifdef LATTICE		/* since Lattice can prevent re-inclusion */
X#include <stdlib.h>	/* and other things, including builtins */
X#if (__VERSION__==5) && (__REVISION__<=4)
X    /* This enables a fix in src/mondata.c needed to bypass a compiler
X    bug.  If you need it and don't have it you will get monsndx panics and
X    monsters that change type when they die and become corpses.
X    If you don't need it and do have it, even wierder things will happen. */
X#   define LATTICE_504_BUG
X#endif
X#endif
X
X#ifdef LATTICE		/* Lattice defines DEBUG when you use -d1 which */
X# ifdef DEBUG		/* we need for useful SnapShots, but DEBUG is   */
X#  undef DEBUG		/* used in several files to turn on things we   */
X# endif			/* don't want (e.g. eat.c), so we get rid of    */
X#endif			/* DEBUG unless asked for in a particular file  */
X
Xtypedef long off_t;
X
X#define MSDOS		/* must be defined to allow some inclusions */
X
X#define O_BINARY	0
X
X#define DGK		/* You'll probably want this; provides assistance
X			 * for typical personal computer configurations
X			 */
X#define RANDOM
X
Xextern void FDECL(exit, (int));
Xextern void NDECL(CleanUp);
Xextern void FDECL(Abort, (long));
Xextern int NDECL(getpid);
Xextern char *FDECL(CopyFile, (const char *, const char *));
Xextern int NDECL(WindowGetchar);
Xextern void FDECL(WindowPutchar, (CHAR_P));
Xextern void FDECL(WindowPuts, (const char *));
Xextern void FDECL(WindowFPuts, (const char *));
Xextern void VDECL(WindowPrintf, (const char *, ...));
Xextern void FDECL(WindowFlush, (void));
X
X#ifndef MSDOS_H
X#include "msdos.h"
X#endif
X#ifndef PCCONF_H
X#include "pcconf.h"     /* remainder of stuff is almost same as the PC */
X#endif
X
X#ifndef LATTICE
X#define memcpy(dest, source, size)  movmem(source, dest, size)
X#endif
X#define remove(x)       unlink(x)
X
X#ifdef LATTICE
X#define FFLUSH(fp) _flsbf(-1, fp)    /* Was fflush */
X#endif
X
X#ifdef AZTEC_C
X#define FFLUSH(fp) flsh_(fp, -1)     /* Was fflush */
Xextern FILE *FDECL(freopen, (const char *, const char *, FILE *));
Xextern char *FDECL(gets, (char *));
X#endif
X
X/* Use Window functions if not in makedefs.c or lev_lex.c */
X
X#if !defined(MAKEDEFS_C) && !defined(LEV_LEX_C)
X
X#define fopen	    fopenp	/* Open most text files according to PATH */
X
X#undef getchar
X#undef putchar
X#undef fflush
X# ifdef LATTICE
X#undef printf
X# endif
X
X#define getchar()   WindowGetchar()
X#define putchar(c)  WindowPutchar(c)
X#define puts(s)     WindowPuts(s)
X#define fputs(s,f)  WindowFPuts(s)
X#define printf	    WindowPrintf
X#define fflush(fp)  WindowFlush()
X
X#define xputs	    WindowFPuts
X#define xputc	    WindowPutchar
X
X#endif
X
X/*
X *  Configurable Amiga options:
X */
X
X#define TEXTCOLOR		/* Use colored monsters and objects */
X#define HACKFONT		/* Use special hack.font */
X#define SHELL			/* Have a shell escape command (!) */
X#define MAIL			/* Get mail at unexpected occasions */
X#define AMIGA_WBENCH		/* Icon support */
X#define DEFAULT_ICON "NetHack:default.icon"	/* private icon for above */
X#define AMIFLUSH		/* toss typeahead (select flush in .cnf) */
X#undef	TERMLIB
X
X#endif /* AMICONF_H */
END_OF_FILE
if test 3368 -ne `wc -c <'include/amiconf.h'`; then
    echo shar: \"'include/amiconf.h'\" unpacked with wrong size!
fi
# end of 'include/amiconf.h'
fi
if test -f 'include/monattk.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/monattk.h'\"
else
echo shar: Extracting \"'include/monattk.h'\" \(3105 characters\)
sed "s/^X//" >'include/monattk.h' <<'END_OF_FILE'
X/*	SCCS Id: @(#)monattk.h	3.0	89/11/20
X/* NetHack may be freely redistributed.  See license for details. */
X/* Copyright 1988, M. Stephenson */
X
X#ifndef MONATTK_H
X#define MONATTK_H
X
X/*	Add new attack types below - ordering affects experience (exper.c).
X *	Attacks > AT_BUTT are worth extra experience.
X */
X#define	AT_NONE		0		/* passive monster (ex. acid blob) */
X#define	AT_CLAW		1		/* claw (punch, hit, etc.) */
X#define	AT_BITE		2		/* bite */
X#define	AT_KICK		3		/* kick */
X#define	AT_BUTT		4		/* head butt (ex. a unicorn) */
X#define	AT_TUCH		5		/* touches */
X#define	AT_STNG		6		/* sting */
X#define AT_HUGS		7		/* crushing bearhug */
X#define	AT_SPIT		10		/* spits substance - ranged */
X#define	AT_ENGL		11		/* engulf (swallow or by a cloud) */
X#define	AT_BREA		12		/* breath - ranged */
X#define	AT_EXPL		13		/* explodes - proximity */
X#define	AT_GAZE		14		/* gaze - ranged */
X
X#define	AT_WEAP		254		/* uses weapon */
X#define	AT_MAGC		255		/* uses magic spell(s) */
X
X/*	Add new damage types below.
X *
X *	Note that 1-10 correspond to the types of attack used in buzz().
X *	Please don't disturb the order unless you rewrite the buzz() code.
X */
X#define	AD_PHYS		0		/* ordinary physical */
X#define	AD_MAGM		1		/* magic missiles */
X#define	AD_FIRE		2		/* fire damage */
X#define	AD_SLEE		3		/* sleep ray */
X#define	AD_COLD		4		/* frost damage */
X#define	AD_DISN		5		/* disintegration (death ray) */
X#define	AD_ELEC		6		/* shock damage */
X#define	AD_DRST		7		/* drains str (poison) */
X#define	AD_ACID		8		/* acid damage */
X#define	AD_SPC1		9		/* for extension of buzz() */
X#define	AD_SPC2		10		/* for extension of buzz() */
X#define	AD_BLND		11		/* blinds (glowing eye) */
X#define	AD_STUN		12		/* stuns */
X#define	AD_SLOW		13		/* slows */
X#define	AD_PLYS		14		/* paralyses */
X#define	AD_DRLI		15		/* drains life levels (Vampire) */
X#define	AD_DREN		16		/* drains magic energy */
X#define	AD_LEGS		17		/* damages legs (xan) */
X#define	AD_STON		18		/* petrifies (Medusa, Cockatrice) */
X#define	AD_STCK		19		/* sticks to you (Mimic) */
X#define	AD_SGLD		20		/* steals gold (Leppie) */
X#define	AD_SITM		21		/* steals item (Nymphs) */
X#define AD_SEDU		22		/* seduces & steals multiple items */
X#define	AD_TLPT		23		/* teleports you (Quantum Mech.) */
X#define	AD_RUST		24		/* rusts armour (Rust Monster)*/
X#define	AD_CONF		25		/* confuses (Umber Hulk) */
X#define AD_DGST		26		/* digests opponent (trapper, etc.) */
X#define AD_HEAL		27		/* heals opponent's wounds (nurse) */
X#define AD_WRAP		28		/* special "stick" for eels */
X#define	AD_WERE		29		/* confers lycanthropy */
X#define AD_DRDX		30		/* drains dexterity (Quasit) */
X#define AD_DRCO		31		/* drains constitution */
X#define AD_DISE		32		/* confers diseases */
X#define AD_DCAY		33		/* decays organics (Brown pudding) */
X#define AD_SSEX		34		/* Succubus seduction (extended) */
X					/* If no SEDUCE then same as AD_SEDU */
X
X#define	AD_CLRC		240		/* random clerical spell */
X#define	AD_SPEL		241		/* random magic spell */
X
X#define AD_SAMU		252		/* hits, may steal Amulet (Wizard) */
X#define AD_CURS		253		/* random curse (ex. gremlin) */
X
X#endif /* MONATTK_H /**/
END_OF_FILE
if test 3105 -ne `wc -c <'include/monattk.h'`; then
    echo shar: \"'include/monattk.h'\" unpacked with wrong size!
fi
# end of 'include/monattk.h'
fi
if test -f 'include/monst.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/monst.h'\"
else
echo shar: Extracting \"'include/monst.h'\" \(3113 characters\)
sed "s/^X//" >'include/monst.h' <<'END_OF_FILE'
X/*	SCCS Id: @(#)monst.h	3.0	88/04/15
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#ifndef MONST_H
X#define MONST_H
X
Xstruct monst {
X	struct monst *nmon;
X	struct permonst *data;
X	unsigned m_id;
X	uchar m_lev;		/* adjusted difficulty level of monster */
X	schar malign;		/* alignment of this monster, relative to the
X				   player (positive = good to kill) */
X	xchar mx, my;
X	xchar mux, muy;		/* where the monster thinks you are */
X	xchar mdx, mdy;		/* if mdispl then pos where last displayed */
X#define	MTSZ	4
X	coord mtrack[MTSZ];	/* monster track */
X	int mhp, mhpmax;
X	unsigned mappearance;	/* for undetected mimics and the wiz */
X	uchar	 m_ap_type;	/* what mappearance is describing: */
X#define M_AP_NOTHING	0	/* mappearance is unused */
X#define M_AP_FURNITURE	1	/* stairs, a door, an altar, etc. */
X#define M_AP_OBJECT	2	/* an object */
X#define M_AP_MONSTER	3	/* a monster */
X#define M_AP_GOLD	4	/* a quantity (mappearance holds it) of gold */
X
X	schar mtame;		/* level of tameness, implies peaceful */
X	int mspec_used; 	/* monster's special ability attack timeout */
X
X	Bitfield(mimic,1);	/* undetected mimic */
X	Bitfield(mdispl,1);	/* mdx,mdy valid */
X	Bitfield(minvis,1);	/* invisible */
X	Bitfield(cham,1);	/* shape-changer */
X	Bitfield(mhide,1);	/* hides beneath objects */
X	Bitfield(mundetected,1);	/* not seen in present hiding place */
X	Bitfield(mspeed,2);
X
X	Bitfield(mflee,1);	/* fleeing */
X	Bitfield(mfleetim,7);	/* timeout for mflee */
X
X	Bitfield(mcansee,1);	/* cansee 1, temp.blinded 0, blind 0 */
X	Bitfield(mblinded,7);	/* cansee 0, temp.blinded n, blind 0 */
X
X	Bitfield(mcanmove,1);	/* paralysis, similar to mblinded */
X	Bitfield(mfrozen,7);
X
X	Bitfield(msleep,1);	/* sleeping */
X	Bitfield(mstun,1);	/* stunned (off balance) */
X	Bitfield(mconf,1);	/* confused */
X	Bitfield(mcan,1);	/* has been cancelled */
X	Bitfield(mpeaceful,1);	/* does not attack unprovoked */
X	Bitfield(mtrapped,1);	/* trapped in a pit or bear trap */
X	Bitfield(mleashed,1);	/* monster is on a leash */
X	Bitfield(isshk,1);	/* is shopkeeper */
X
X	Bitfield(isgd,1);	/* is guard */
X#if defined(ALTARS) && defined(THEOLOGY)
X	Bitfield(ispriest,1);	/* is a priest */
X#endif
X	Bitfield(iswiz,1);	/* is the Wizard of Yendor */
X#ifdef WORM
X	Bitfield(wormno,5);	/* at most 31 worms on any level */
X#endif
X
X	long mtrapseen;		/* bitmap of traps we've been trapped in */
X	long mlstmv;		/* prevent two moves at once */
X	struct obj *minvent;
X	long mgold;
X	uchar mnamelth;		/* length of name (following mxlth) */
X	short mxlth;		/* length of following data */
X	/* in order to prevent alignment problems mextra should
X	   be (or follow) a long int */
X	int meating;		/* monster is eating timeout */
X	long mextra[1]; 	/* monster dependent info */
X};
X
X#define newmonst(xl)	(struct monst *) alloc((unsigned)(xl) + sizeof(struct monst))
X
Xextern struct monst *mydogs, *fallen_down;
X
X/* these are in mspeed */
X#define MSLOW 1 /* slow monster */
X#define MFAST 2 /* speeded monster */
X
X#define	NAME(mtmp)	(((char *) mtmp->mextra) + mtmp->mxlth)
X
X#endif /* MONST_H /**/
END_OF_FILE
if test 3113 -ne `wc -c <'include/monst.h'`; then
    echo shar: \"'include/monst.h'\" unpacked with wrong size!
fi
# end of 'include/monst.h'
fi
if test -f 'include/obj.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/obj.h'\"
else
echo shar: Extracting \"'include/obj.h'\" \(3727 characters\)
sed "s/^X//" >'include/obj.h' <<'END_OF_FILE'
X/*	SCCS Id: @(#)obj.h	3.0	89/11/10
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#ifndef OBJ_H
X#define OBJ_H
X
Xstruct obj {
X	struct obj *nobj;
X	struct obj *nexthere;		/* for location lists */
X	struct obj *cobj;		/* id of container object is in */
X/*	unsigned o_cwt;			/* container weight capacity */
X	unsigned o_id;
X	xchar ox,oy;
X	xchar odx,ody;
X	unsigned otyp;
X	unsigned owt;
X	unsigned quan;		/* use oextra for tmp gold objects */
X
X	schar spe;		/* quality of weapon, armor or ring (+ or -)
X				   number of charges for wand ( >= -1 )
X				   marks your eggs, spinach tins, key shapes
X				   indicates statues have spellbooks inside
X				   tells which fruit a fruit is
X				   marks diluted potions
X				   special for uball and amulet %% BAH */
X#define N_LOX	10	/* # of key/lock shapes */
X	char	olet;
X	char	invlet;
X	int	corpsenm;	/* type of corpse is mons[corpsenm] */
X#define leashmon  corpsenm	/* gets m_id of attached pet */
X	Bitfield(oinvis,1);	/* not yet implemented */
X	Bitfield(olocked,1);	/* object is locked */
X#define recharged olocked	/* recharged once */
X#define orotten olocked 	/* rotten food */
X	Bitfield(otrapped,1);	/* container is trapped */
X#define opoisoned otrapped	/* object (weapon) is coated with poison */
X	Bitfield(odispl,1);
X	Bitfield(known,1);	/* exact nature known */
X	Bitfield(dknown,1);	/* color or text known */
X	Bitfield(bknown,1);	/* blessing or curse known */
X	Bitfield(cursed,1);
X	Bitfield(blessed,1);
X	Bitfield(unpaid,1);	/* on some bill */
X	Bitfield(rustfree,1);
X#ifndef NO_SIGNAL
X# define in_use rustfree	/* for magic items before useup items */
X#endif
X	Bitfield(no_charge,1);	/* if shk shouldn't charge for this */
X	Bitfield(onamelth,6);
X	unsigned oeaten;	/* nutrition left in food, if partly eaten */
X	long age;		/* creation date */
X	long owornmask;
X
X/* note that TIMEOUT in you.h is defined as 07777L; no bits for items that
X * confer properties may overlap that mask, or timeout.c will happily 
X * rearrange the bits behind the back of the property code
X * shirts, balls, and chains are currently safe
X */
X#define	W_BALL	02000L
X#define	W_CHAIN	04000L
X#define	W_RINGL	010000L	/* make W_RINGL = RING_LEFT (see uprop) */
X#define	W_RINGR	020000L
X#define	W_RING	(W_RINGL | W_RINGR)
X#define	W_ARM	040000L
X#define	W_ARMC	0100000L
X#define	W_ARMH	0200000L
X#define	W_ARMS	0400000L
X#define	W_ARMG	01000000L
X#define	W_ARMF	02000000L
X#define	W_AMUL	04000000L
X#define	W_TOOL	010000000L	/* wearing another tool (see uprop) */
X#define	W_WEP	020000000L
X#ifdef SHIRT
X#define	W_ARMU	01000L
X#define	W_ARMOR	(W_ARM | W_ARMC | W_ARMH | W_ARMS | W_ARMG | W_ARMF | W_ARMU)
X#else
X#define	W_ARMOR	(W_ARM | W_ARMC | W_ARMH | W_ARMS | W_ARMG | W_ARMF)
X#endif
X	long oextra[1];		/* used for name of ordinary objects - length
X				   is flexible; amount for tmp gold objects */
X};
X
X#define newobj(xl)	(struct obj *) alloc((unsigned)(xl) + sizeof(struct obj))
X#define	ONAME(otmp)	((char *) otmp->oextra)
X#define	OGOLD(otmp)	(otmp->oextra[0])
X
X# ifndef STUPID_CPP	/* otherwise these macros are functions */
X
X#define Is_container(otmp)	(otmp->otyp >= ICE_BOX && otmp->otyp <= BAG_OF_TRICKS)
X#define Is_box(otmp)	(otmp->otyp == LARGE_BOX || otmp->otyp == CHEST)
X#define Is_mbag(otmp)	(otmp->otyp == BAG_OF_HOLDING || otmp->otyp == BAG_OF_TRICKS)
X
X#define is_sword(otmp)	(otmp->otyp >= SHORT_SWORD && otmp->otyp <= KATANA)
X#define bimanual(otmp)	((otmp->olet == WEAPON_SYM || otmp->otyp == UNICORN_HORN) && objects[otmp->otyp].oc_bimanual)
X
X#define is_rustprone(otmp)	(objects[otmp->otyp].oc_material == METAL)
X#define is_corrodeable(otmp)	(objects[otmp->otyp].oc_material == COPPER)
X# endif /* STUPID_CPP */
X
X#endif /* OBJ_H /**/
END_OF_FILE
if test 3727 -ne `wc -c <'include/obj.h'`; then
    echo shar: \"'include/obj.h'\" unpacked with wrong size!
fi
# end of 'include/obj.h'
fi
if test -f 'include/objclass.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/objclass.h'\"
else
echo shar: Extracting \"'include/objclass.h'\" \(3230 characters\)
sed "s/^X//" >'include/objclass.h' <<'END_OF_FILE'
X/*	SCCS Id: @(#)objclass.h	3.0	89/01/10
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#ifndef OBJCLASS_H
X#define OBJCLASS_H
X
X/* definition of a class of objects */
X
Xstruct objclass {
X	const char *oc_name;		/* actual name */
X	const char *oc_descr;		/* description when name unknown */
X	char *oc_uname;			/* called by user */
X	Bitfield(oc_name_known,1);
X	Bitfield(oc_merge,1);	/* merge otherwise equal objects */
X	Bitfield(oc_uses_known,1); /* obj->known affects full decription */
X				/* otherwise, obj->dknown and obj->bknown */
X				/* tell all, and obj->known should always */
X				/* be set for proper merging behavior */
X	Bitfield(oc_bool,1);
X#define oc_bimanual	oc_bool	/* for weapons */
X#define oc_bulky	oc_bool	/* for armor */
X#define oc_charged	oc_bool	/* for rings & tools: allow +n or (n) */
X	Bitfield(oc_material,4);
X#define GLASS		1
X#define WOOD		2
X#define COPPER		3 /* Cu */
X#define METAL		4 /* Fe */
X#define SILVER		5 /* Ag */
X#define GOLD		6 /* Au */
X#define PLATINUM	7 /* Pt */
X#define MITHRIL		8
X#define MINERAL		15
X	uchar oc_oprop; 	/* property (invis, &c.) conveyed */
X	char oc_olet;
X	int oc_prob;		/* probability for mkobj() */
X	schar oc_delay;		/* delay when using such an object */
X	uchar oc_weight;
X	int oc_cost;		/* base cost in shops */
X	schar oc_oc1, oc_oc2;
X	int oc_oi;
X#ifdef TEXTCOLOR
X	uchar oc_color;		/* color of the object */
X#endif /* TEXTCOLOR */
X#define	nutrition	oc_oi	/* for foods */
X#define w_propellor	oc_oi	/* for weapons */
X#define WP_BOW		1
X#define WP_SLING	2
X#define WP_CROSSBOW	3
X#define	a_ac		oc_oc1	/* for armors - used in ARM_BONUS in do.c */
X#define	a_can		oc_oc2	/* for armors */
X#define bits		oc_oc1	/* for wands */
X				/* wands */
X#define		NODIR		1
X#define		IMMEDIATE	2
X#define		RAY		4
X  /* Check the AD&D rules!  The FIRST is small monster damage. */
X#define	wsdam		oc_oc1	/* for weapons, PICK_AXE, rocks, and gems */
X#define	wldam		oc_oc2	/* for weapons, PICK_AXE, rocks, and gems */
X
X#define	g_val		oc_cost	/* for gems: value on exit */
X
X#ifdef SPELLS
X#define spl_lev		oc_oi	/* for books: spell level */
X#endif
X};
X
X#if defined(MACOS) && !defined(MAKEDEFS_C)
Xstruct small_objclass{
X	char *oc_name;		/* actual name */
X	char *oc_descr;		/* description when name unknown */
X};
Xextern struct small_objclass sm_obj[];
Xextern struct objclass *objects;
X#else
Xextern struct objclass NEARDATA objects[];
X#endif    /* MACOS && !MAKEDEFS_C */
X
X/* definitions of all object-symbols */
X
X#define	RANDOM_SYM	'\0'	/* used for generating random objects */
X#define	ILLOBJ_SYM	']'	/* should be same as S_MIMIC_DEF      */
X#define	AMULET_SYM	'"'
X#define	FOOD_SYM	'%'
X#define	WEAPON_SYM	')'
X#define	TOOL_SYM	'('
X#define	BALL_SYM	'0'
X#define	CHAIN_SYM	'_'
X#define	ROCK_SYM	'`'
X#define	ARMOR_SYM	'['
X#define	POTION_SYM	'!'
X#define	SCROLL_SYM	'?'
X#define	WAND_SYM	'/'
X#define	RING_SYM	'='
X#define	GEM_SYM		'*'
X#define	GOLD_SYM	'$'
X#define	VENOM_SYM	'.'
X#ifdef SPELLS
X#define	SPBOOK_SYM	'+'	/* actually SPELL-book */
X#endif
X
X#ifdef TUTTI_FRUTTI
Xstruct fruit {
X	char fname[PL_FSIZ];
X	int fid;
X	struct fruit *nextf;
X};
X#define newfruit() (struct fruit *)alloc(sizeof(struct fruit))
X#endif
X#endif /* OBJCLASS_H */
END_OF_FILE
if test 3230 -ne `wc -c <'include/objclass.h'`; then
    echo shar: \"'include/objclass.h'\" unpacked with wrong size!
fi
# end of 'include/objclass.h'
fi
if test -f 'include/prop.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/prop.h'\"
else
echo shar: Extracting \"'include/prop.h'\" \(1223 characters\)
sed "s/^X//" >'include/prop.h' <<'END_OF_FILE'
X/*	SCCS Id: @(#)prop.h	3.0	89/06/24
X/* NetHack may be freely redistributed.  See license for details. */
X/* Copyright (c) 1989 Mike Threepoint */
X
X#ifndef PROP_H
X#define PROP_H
X
X#define FIRE_RES		1
X#define SLEEP_RES		2
X#define COLD_RES		3
X#define DISINT_RES		4
X#define SHOCK_RES		5
X#define POISON_RES		6
X#define ADORNED 		7
X#define REGENERATION		8
X#define SEARCHING		9
X#define SEE_INVIS		10
X#define INVIS			11
X#define TELEPORT		12
X#define TELEPORT_CONTROL	13
X#define POLYMORPH		14
X#define POLYMORPH_CONTROL	15
X#define LEVITATION		16
X#define STEALTH 		17
X#define AGGRAVATE_MONSTER	18
X#define CONFLICT		19
X#define PROTECTION		20
X#define PROT_FROM_SHAPE_CHANGERS	21
X#define WARNING 		22
X#define TELEPAT 		23
X#define FAST			24
X#define STUN			25
X#define CONFUSION		26
X#define SICK			27
X#define BLINDED 		28
X#define SLEEPING		29
X#define WOUNDED_LEGS		30
X#define STONED			31
X#define STRANGLED		32
X#define HALLUC			33
X#define FUMBLING		34
X#define JUMPING 		35
X#define WWALKING		36
X#define HUNGER			37
X#define GLIB			38
X#define REFLECTING		39
X#define LIFESAVED		40
X#define ANTIMAGIC		41
X#define DISPLACED		42
X#define CLAIRVOYANT		43
X#define VOMITING		44
X#define LAST_PROP		(VOMITING)		/* the last property */
X
X#endif /* PROP_H /**/
END_OF_FILE
if test 1223 -ne `wc -c <'include/prop.h'`; then
    echo shar: \"'include/prop.h'\" unpacked with wrong size!
fi
# end of 'include/prop.h'
fi
if test -f 'include/vmsconf.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/vmsconf.h'\"
else
echo shar: Extracting \"'include/vmsconf.h'\" \(3538 characters\)
sed "s/^X//" >'include/vmsconf.h' <<'END_OF_FILE'
X/*	SCCS Id: @(#)vmsconf.h	3.0	88/07/21
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#ifdef VMS
X#ifndef VMSCONF_H
X#define VMSCONF_H
X
X/*
X * Edit these to choose values appropriate for your site.
X * WIZARD is the username allowed to use the debug option of nethack; no harm
X *   is done by leaving it as a username that doesn't exist at your site.
X * HACKDIR can be overridden at run-time with the logical name HACKDIR, as in
X *   $ define hackdir disk$users:[games.nethack]
X */
X#define Local_WIZARD    "GENTZEL"               /*(must be uppercase)*/
X#define Local_HACKDIR   "USR$ROOT0:[GENTZEL.NHDIR]"
X
X/*
X * This section cleans up the stuff done in config.h so that it
X * shouldn't need to be modified.  It's conservative so that if
X * config.h is actually edited, the changes won't impact us.
X */
X#ifdef UNIX
X# undef UNIX
X#endif
X#ifdef HACKDIR
X# undef HACKDIR
X#endif
X#ifdef WIZARD
X# undef WIZARD
X#endif
X#ifdef WIZARD_NAME
X# undef WIZARD_NAME
X#endif
X#define HACKDIR Local_HACKDIR
X#ifndef KR1ED
X# define WIZARD Local_WIZARD
X# define WIZARD_NAME WIZARD
X#else
X# define WIZARD 1
X# define WIZARD_NAME Local_WIZARD
X#endif
X
X#undef RECORD
X#define RECORD "record;1"
X
X#ifdef COMPRESS
X# undef COMPRESS
X#endif
X#ifdef ZEROCOMP
X# undef ZEROCOMP
X#endif
X
X/*
X * If you define MAIL, then the player will be notified of new broadcasts
X * when they arrive.
X */
X#define	MAIL
X
X#define RANDOM          /* use others/random.c instead of vaxcrtl rand/srand */
X
X#define	FCMASK	0660	/* file creation mask */
X
X/* vaxcrtl object library is not available on MicroVMS (4.4 thru 4.6(.7?))
X   unless it's retreived from a full VMS system or leftover from a really
X   ancient version of VAXC.  #define no_c$$translate and also create a
X   linker options file called vaxcrtl.opt containing one line
Xsys$share:vaxcrtl/shareable
X   to link against the vaxcrtl shareable image.  Then include ',vaxcrtl/opt'
X   on the link command instead of either ',sys$library:vaxcrtl/lib' or
X   '$ define lnk$library sys$library:vaxcrtl'
X   Linking against the vaxcrtl sharable image is encouraged and will result
X   in significantly smaller .EXE files.  The routine C$$TRANSLATE (used in
X   vmsunix.c) is not available from the sharable image version of vaxcrtl.
X */
X/* #define no_c$$translate /**/
X
X/*
X * The remainder of the file should not need to be changed.
X */
X
X/* GCC 1.36 (or maybe GAS) for VMS has a bug with extern const declarations.
X   Until it is fixed, eliminate const. */
X#ifdef __GNUC__
X# define const
X#endif
X#if defined(VAXC) && !defined(ANCIENT_VAXC)
X# ifdef volatile
X#  undef volatile
X# endif
X# ifdef const
X#  undef const
X# endif
X#endif
X
X#include <time.h>
X#include <file.h>
X
X#define	HLOCK	"perm;1"	/* an empty file used for locking purposes */
X#define LLOCK	"safelock;1"	/* link to previous */
X
X#ifndef REDO
X# define Getchar vms_getchar
X#else
X# define tgetch vms_getchar
X#endif
X
X#define SHELL		/* do not delete the '!' command */
X
X#include "system.h"
X
X#define index	strchr
X#define rindex	strrchr
X
X/* Use the high quality random number routines. */
X#if defined(RANDOM)
X#define Rand()	random()
X#define Srand(seed) srandom(seed)
X#else
X#define Rand()	rand()
X#define Srand(seed) srand(seed)
X#endif
X
X#define bcopy(s1,s2,sz) memcpy(s2,s1,sz)
X#define unlink(x) delete(x)
X#define exit(x) vms_exit(x)
X#define getuid() vms_getuid()
X#define abort() vms_abort()
X#define creat(f,m) vms_creat(f,m)
X
X/* VMS global names are case insensitive... */
X#define An vms_an
X
X#endif
X#endif /* VMS /* */
END_OF_FILE
if test 3538 -ne `wc -c <'include/vmsconf.h'`; then
    echo shar: \"'include/vmsconf.h'\" unpacked with wrong size!
fi
# end of 'include/vmsconf.h'
fi
if test -f 'others/NetHack.cnf' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'others/NetHack.cnf'\"
else
echo shar: Extracting \"'others/NetHack.cnf'\" \(3565 characters\)
sed "s/^X//" >'others/NetHack.cnf' <<'END_OF_FILE'
X# A '#' at the beginning of a line means the rest of the line is a comment.
X#
X# This configuration file is set up for two cases, for a hard disk
X# (as drive C:), and for two floppy disks.
X#
X# To change the configuration, comment out the unwanted lines, and
X# uncomment the configuration you want.
X
X
X# *** OPTIONS ***
X#
X# These two options should be used for most setups.  If you're machine isn't
X# very IBM-compatible, and NetHack doesn't work, try commenting out this line.
X#
XOPTIONS=rawio,IBM_BIOS,IBMgraphics
X# DEC Rainbows will hang if rawio is set, so they should instead use:
X#OPTIONS=IBM_BIOS,DECgraphics
X#
X#
X# Some options to set personal preferences.  Uncomment and change these to
X# suit your personal preference.  If several people are to use the same
X# configuration, options like these should not be set.
X#
X#OPTIONS=name:Janet-V,female,dogname:Fido,catname:Morris,fruit:apricot
X#OPTIONS=packorder:")[%?+/=!(*0_`,endgame:10 top/2 around/own
X#
X#
X# Other general options.  You might also set "silent" so as not to attract
X# the boss's attention.
X#
XOPTIONS=time,rest_on_space,nopickup,number_pad
X
X
X# *** HARD DISK CONFIGURATION ***
X#
XHACKDIR=c:\games\nethack
X#
X#   LEVELS and SAVE default to HACKDIR
X#
X#LEVELS=c:\games\nethack\bones
X#SAVE=c:\games\nethack\bones;n
X#
X#   appending a ";n" to SAVE means don't prompt to insert a disk.
XSAVE=;n
X#
X#RAMDISK=d:
X
X
X# *** 2-FLOPPY CONFIGURATION ***
X#
X# HACKDIR=a:\
X# LEVELS=b:\
X# SAVE=b:\
X# RAMDISK=c:
X
X
X# *** CHARACTER GRAPHICS ***
X#
X# The 32 GRAPHICS characters (0-31) are:
X# stone, vertical wall, horizontal wall, top left corner, top right corner, 
X# bottom left corner, bottom right corner, crosswall, up T wall, down T wall, 
X# left T wall, right T wall, vertical beam, horizontal beam, left slant, right
X# slant, no door, vertical open door, horizontal open door, closed door,
X# floor, corridor, up stairs, down stairs, trap, web, pool,
X# fountain, sink, throne, altar, up ladder, down ladder, vertical drawbridge
X# wall, horizontal drawbridge wall 
X#
X# If you specify less that 35 ASCII values, the remaining characters will be
X# set to their respective defaults.
X#
X# If you merely set the IBMgraphics option as above, NetHack will use IBM
X# extended ASCII for dungeon characters.  If you don't like the selections,
X# you can make up your own via the graphics option, but you should still set
X# IBMgraphics if you are using IBM graphics characters to get the correct
X# processing.
X#
X# An example using the IBM graphics character set:
X#	   ' '  |   -   .   .   `   '   -   -   -   -   -   |   -   \   /   .   -   |   +   .   #   <   >   ^   "   }   {   #   \   _   <   >   #   #
X#GRAPHICS = 032 179 196 218 191 192 217 197 193 194 180 195 179 196 092 047 249 239 239 254 249 177 060 062 094 157 247 244 035 190 220 060 062 186 205
X# An alternative:
X#GRAPHICS= 032 186 205 201 187 200 188 206 202 203 185 204 179 196 092 047 249 239 239 254 249 177 060 062 094 034 247 244 035 092 095 060 062 179 196
X#
X#
X# Using the DEC Rainbow/ANSI line-drawing character set:
X#
X# If you have compiled with TERMLIB, merely set the DECgraphics option as
X# above.  NetHack will then switch into the VTxxx line-drawing character set
X# (aka ANSI ruling character set '0') for dungeon characters.  If you don't
X# like the selections, you can make up your own via the graphics option,
X# adding 128 to the value of any line-drawing character you want to use.
X# (But you should still set DECgraphics to get the correct processing.)
X#
X#GRAPHICS= 032 248 241 236 235 237 234 238 246 247 245 244 248 241 092 047 254 241 248 043 254 225
END_OF_FILE
if test 3565 -ne `wc -c <'others/NetHack.cnf'`; then
    echo shar: \"'others/NetHack.cnf'\" unpacked with wrong size!
fi
# end of 'others/NetHack.cnf'
fi
if test -f 'src/demon.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/demon.c'\"
else
echo shar: Extracting \"'src/demon.c'\" \(3842 characters\)
sed "s/^X//" >'src/demon.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)demon.c	3.0	88/11/14
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include	"hack.h"
X
Xvoid
Xdsummon(ptr)		/* summon demon */
X	register struct permonst *ptr;
X{
X#ifdef INFERNO
X	register int dtype = 0, cnt = 0;
X
X	if(is_dprince(ptr) || (ptr == &mons[PM_WIZARD_OF_YENDOR])) {
X
X	    dtype = (!rn2(20)) ? dprince() : (!rn2(4)) ? dlord() : ndemon();
X	    cnt = (!rn2(4) && !is_dprince(&mons[dtype])) ? 2 : 1;
X
X	} else if(is_dlord(ptr)) {
X
X	    dtype = (!rn2(50)) ? dprince() : (!rn2(20)) ? dlord() : ndemon();
X	    cnt = (!rn2(4) && is_ndemon(&mons[dtype])) ? 2 : 1;
X
X	} else if(is_ndemon(ptr)) {
X
X	    dtype = (!rn2(20)) ? dlord() : (!rn2(6)) ? ndemon() : monsndx(ptr);
X	    cnt = 1;
X	}
X
X	if(!dtype) return;
X
X	while(cnt > 0) {
X
X	    (void)makemon(&mons[dtype], u.ux, u.uy);
X	    cnt--;
X	}
X#else
X	(void)makemon(&mons[PM_DEMON], u.ux, u.uy);
X#endif
X	return;
X}
X
X#ifdef INFERNO
X#define	Athome	(Inhell && !mtmp->cham)
X
Xint
Xdemon_talk(mtmp)		/* returns 1 if it won't attack. */
Xregister struct monst *mtmp;
X{
X	long	demand, offer;
X
X#ifdef NAMED_ITEMS
X	if(uwep && is_artifact(uwep) && !strcmp(ONAME(uwep), "Excalibur")) {
X
X	    pline("%s looks very angry.", Xmonnam(mtmp));
X	    return mtmp->mpeaceful = mtmp->mtame = 0;
X	}
X#endif /* NAMED_ITEMS */
X
X	/* Slight advantage given. */
X	if(is_dprince(mtmp->data) && mtmp->minvis) {
X	    mtmp->minvis = 0;
X	    if (!Blind) pline("%s appears before you.", Xmonnam(mtmp));
X	    pmon(mtmp);
X	}
X	if(u.usym == S_DEMON) {	/* Won't blackmail their own. */
X
X	    pline("%s says, \"Good hunting, %s.\" and vanishes.",
X		  Xmonnam(mtmp), flags.female ? "Sister" : "Brother");
X	    rloc(mtmp);
X	    return(1);
X	}
X	demand = (u.ugold * (rnd(80) + 20 * Athome)) / 100;
X	if(!demand)  		/* you have no gold */
X	    return mtmp->mpeaceful = 0;
X	else {
X
X	    pline("%s demands %ld zorkmid%s for safe passage.",
X		  Xmonnam(mtmp), demand, plur(demand));
X
X	    if((offer = bribe(mtmp)) >= demand) {
X		pline("%s vanishes, laughing about cowardly mortals.",
X		      Xmonnam(mtmp));
X	    } else {
X		if((long)rnd(40) > (demand - offer)) {
X		    pline("%s scowls at you menacingly, then vanishes.",
X			  Xmonnam(mtmp));
X		} else {
X		    pline("%s gets angry...", Xmonnam(mtmp));
X		    return mtmp->mpeaceful = 0;
X		}
X	    }
X	}
X	mongone(mtmp);
X	return(1);
X}
X#endif
X
X#if defined(INFERNO) || (defined(ALTARS) && defined(THEOLOGY))
Xlong
Xbribe(mtmp)
Xstruct monst *mtmp;
X{
X	char buf[80];
X	long offer;
X
X	pline("How much will you offer? ");
X	getlin(buf);
X	(void) sscanf(buf, "%ld", &offer);
X
X/*Michael Paddon -- fix for negative offer to monster*/	/*JAR880815 - */
X 	if(offer < 0L) {
X 		You("try to shortchange %s, but fumble.", 
X 			x_monnam(mtmp, 0));
X 		offer = 0L;
X 	} else if(offer == 0L) {
X		You("refuse.");
X 	} else if(offer >= u.ugold) {
X		You("give %s all your gold.", x_monnam(mtmp, 0));
X		offer = u.ugold;
X	} else You("give %s %ld zorkmid%s.", x_monnam(mtmp, 0), offer,
X		   plur(offer));
X
X	u.ugold -= offer;
X	mtmp->mgold += offer;
X	flags.botl = 1;
X	return(offer);
X}
X#endif
X
Xint
Xdprince() {
X#ifdef INFERNO
X	int	tryct, pm;
X
X	for(tryct = 0; tryct < 20; tryct++) {
X	    pm = rn1(PM_DEMOGORGON + 1 - PM_ORCUS, PM_ORCUS);
X	    if(!(mons[pm].geno & G_GENOD))
X		return(pm);
X	}
X	return(dlord());	/* approximate */
X#else
X	return(PM_DEMON);
X#endif
X}
X
Xint
Xdlord() {
X#ifdef INFERNO
X	int	tryct, pm;
X
X	for(tryct = 0; tryct < 20; tryct++) {
X	    pm = rn1(PM_YEENOGHU + 1 - PM_JUIBLEX, PM_JUIBLEX);
X	    if(!(mons[pm].geno & G_GENOD))
X		return(pm);
X	}
X	return(ndemon());	/* approximate */
X#else
X	return(PM_DEMON);
X#endif
X}
X
Xint
Xndemon() {
X#ifdef INFERNO
X	int	tryct;
X	struct	permonst *ptr;
X
X	for(tryct = 0; tryct < 20; tryct++)
X	    if(is_ndemon((ptr = mkclass(S_DEMON))))
X		return(monsndx(ptr));
X
X	return(0);
X#else
X	return(PM_DEMON);
X#endif
X}
END_OF_FILE
if test 3842 -ne `wc -c <'src/demon.c'`; then
    echo shar: \"'src/demon.c'\" unpacked with wrong size!
fi
# end of 'src/demon.c'
fi
if test -f 'src/lev_comp.l' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/lev_comp.l'\"
else
echo shar: Extracting \"'src/lev_comp.l'\" \(3754 characters\)
sed "s/^X//" >'src/lev_comp.l' <<'END_OF_FILE'
X%{
X/*	SCCS Id: @(#)lev_lex.c	3.0	90/01/04
X/*	Copyright (c) 1989 by Jean-Christophe Collet */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#define LEV_LEX_C
X
X/* block some unused #defines to avoid overloading some cpp's */
X#define MONDATA_H	/* comment this line for pre-compiled headers */
X#define MONFLAG_H	/* comment this line for pre-compiled headers */
X
X#include "hack.h"
X#include "lev_comp.h"
X#include "sp_lev.h"
X
X/* Most of these don't exist in flex, yywrap is macro and
X * yyunput is properly declared in flex.skel.
X */
X#ifndef FLEX_SCANNER
Xint FDECL (yyback, (int *, int));
Xint NDECL (yylook);
Xint NDECL (yyinput);
Xint NDECL (yywrap);
Xint NDECL (yylex);
Xint FDECL (yyunput, (int));
Xint FDECL (yyoutput, (int));
X#endif
X
X#ifdef MSDOS
X#undef exit
Xextern void FDECL(exit, (int));
X#endif
X
X/* this doesn't always get put in lev_comp.h
X * (esp. when using older versions of bison)
X */
X
Xextern YYSTYPE yylval;
X
X#ifdef MACOS
X#undef putchar
X#undef putc
X#undef printf
X#undef Printf
X#define Printf printf
X# ifdef LSC
X#define	putc(c,stream)	(fputc(c,stream))
X#define	putchar(c)	(fputc(c,stdout))
X# endif
X#endif
Xint line_number = 1;
X
X/* This is *** UGLY *** but I can't think a better way to do it
X * I really need a huge buffer to scan maps...
X */
X
X#undef YYLMAX
X#define YYLMAX	2048
X
X%}
X%s MAPC
X%%
X<MAPC>[-|}{+SK\\#. ]*\n	{ line_number++; yymore(); }	
X<MAPC>ENDMAP\n	{ BEGIN 0;
X		  line_number++;
X		  yytext[yyleng-7] = 0; /* Discard \nENDMAP */
X		  yylval.map = (char *) alloc(strlen(yytext)+1);
X		  strcpy(yylval.map, yytext);
X		  return MAP_ID;
X		}
X^#.*\n		{ line_number++; }
XMAZE		return MAZE_ID;
XLEVEL		return LEVEL_ID;
XGEOMETRY	return GEOMETRY_ID;
X^MAP\n		{ BEGIN MAPC; line_number++; }
XOBJECT		return OBJECT_ID;
XMONSTER		return MONSTER_ID;
XTRAP		return TRAP_ID;
XDOOR		return DOOR_ID;
XDRAWBRIDGE	return DRAWBRIDGE_ID;
XMAZEWALK	return MAZEWALK_ID;
XREGION		return REGION_ID;
XRANDOM_OBJECTS	return RANDOM_OBJECTS_ID;
XRANDOM_MONSTERS	return RANDOM_MONSTERS_ID;
XRANDOM_PLACES	return RANDOM_PLACES_ID;
XALTAR		return ALTAR_ID;
XLADDER		return LADDER_ID;
XNON_DIGGABLE	return NON_DIGGABLE_ID;
XROOM		return ROOM_ID;
Xopen		{ yylval.i=D_ISOPEN; return DOOR_STATE; }
Xclosed		{ yylval.i=D_CLOSED; return DOOR_STATE; }
Xlocked		{ yylval.i=D_LOCKED; return DOOR_STATE; }
Xnodoor		{ yylval.i=D_NODOOR; return DOOR_STATE; }
Xbroken		{ yylval.i=D_BROKEN; return DOOR_STATE; }
Xnorth		{ yylval.i=W_NORTH; return DIRECTION; }
Xeast		{ yylval.i=W_EAST; return DIRECTION; }
Xsouth		{ yylval.i=W_SOUTH; return DIRECTION; }
Xwest		{ yylval.i=W_WEST; return DIRECTION; }
Xrandom		{ yylval.i = -1; return RANDOM_TYPE; }
Xobject		return O_REGISTER;
Xmonster		return M_REGISTER;
Xplace		return P_REGISTER;
Xalign		return A_REGISTER;
Xleft		{ yylval.i=1; return LEFT_OR_RIGHT; }
Xright		{ yylval.i=3; return LEFT_OR_RIGHT; }
Xcenter		{ yylval.i=2; return CENTER; }
Xtop		{ yylval.i=1; return TOP_OR_BOT; }
Xbottom		{ yylval.i=3; return TOP_OR_BOT; }
Xlit		{ yylval.i=1; return LIGHT_STATE; }
Xunlit		{ yylval.i=0; return LIGHT_STATE; }
Xlaw		{ yylval.i=A_LAW; return ALIGNMENT; }
Xneutral		{ yylval.i=A_NEUTRAL; return ALIGNMENT; }
Xchaos		{ yylval.i=A_CHAOS; return ALIGNMENT; }
Xshrine		{ yylval.i=1; return ALTAR_TYPE; }
Xaltar		{ yylval.i=0; return ALTAR_TYPE; }
Xup		{ yylval.i=1; return UP_OR_DOWN; }
Xdown		{ yylval.i=0; return UP_OR_DOWN; }
X[0-9]+		{ yylval.i=atoi(yytext); return INTEGER; }
X\"[^"]*\"	{ yytext[yyleng-1] = 0; /* Discard the trailing \" */
X		  yylval.map = (char *) alloc(strlen(yytext+1)+1);
X		  strcpy(yylval.map, yytext+1); /* Discard the first \" */
X		  return STRING; }
X\n		{ line_number++; }
X[ \t]+		;
X'.'		{ yylval.i = yytext[1]; return CHAR; }
X.		{ return yytext[0]; }
X%%
X#ifdef	AMIGA
Xlong *alloc(n)
X	unsigned n;
X{
X	return ((long *)malloc (n));
X}
X#endif
END_OF_FILE
if test 3754 -ne `wc -c <'src/lev_comp.l'`; then
    echo shar: \"'src/lev_comp.l'\" unpacked with wrong size!
fi
# end of 'src/lev_comp.l'
fi
if test -f 'src/version.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/version.c'\"
else
echo shar: Extracting \"'src/version.c'\" \(3656 characters\)
sed "s/^X//" >'src/version.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)version.c	3.0	89/06/12
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include	"hack.h"
X#include	"date.h"
X#ifndef BETA
X#if defined(MSDOS) && !defined(AMIGA)
X# include	"patchlev.h"
X#else
X# include	"patchlevel.h"
X#endif
X#endif
X
Xint
Xdoversion(){
X
X#ifdef BETA
X	pline("%s NetHack Beta Version %s - last build %s.",
X#else
X	pline("%s NetHack Version %s Patchlevel %d - last build %s.",
X#endif
X#if defined(MSDOS)
X# if defined(TOS)
X		"ST",
X# else
X#  if defined(AMIGA)
X		"Amiga",
X#  else
X#   if defined(OS2)
X		"OS/2",
X#   else
X		"PC",
X#   endif
X#  endif
X# endif
X#endif
X#ifdef MACOS
X		"Macintosh",
X#endif
X#ifdef UNIX
X		"Unix",
X#endif
X#ifdef VMS
X		"VMS",
X#endif
X		VERSION,
X#ifndef BETA
X		PATCHLEVEL,
X#endif
X		datestring);
X	return 0;
X}
X
X#define Next_opt(x) if (next_opt(x)) goto quit;
X#define Page_line(x) if (page_line(x)) goto quit;
X
Xint
Xdoextversion()
X{
X	set_pager(0);
X	(void)page_line("");
X	Page_line("Options compiled into this version of NetHack");
X	Page_line("(in no particular order):");
X	Page_line("");
X#ifdef POLYSELF
X	Next_opt("self-polymorphing, ");
X#endif
X#ifdef THEOLOGY
X	Next_opt("theology, ");
X#endif
X#ifdef SOUNDS
X	Next_opt("sounds, ");
X#endif
X#ifdef KICK
X	Next_opt("kicking, ");
X#endif
X#ifdef THRONES
X	Next_opt("thrones, ");
X#endif
X#ifdef FOUNTAINS
X	Next_opt("fountains, ");
X#endif
X#ifdef SINKS
X	Next_opt("sinks, ");
X#endif
X#ifdef ALTARS
X	Next_opt("altars, ");
X#endif
X#ifdef WALLIFIED_MAZE
X	Next_opt("fancy mazes, ");
X#endif
X#ifdef REINCARNATION
X	Next_opt("Rogue level, ");
X#endif
X#ifdef STRONGHOLD
X	Next_opt("special levels, ");
X#endif
X#ifdef ORACLE
X	Next_opt("oracle, ");
X#endif
X#ifdef MEDUSA
X	Next_opt("Medusa, ");
X#endif
X#ifdef KOPS
X	Next_opt("Kops, ");
X#endif
X#ifdef ARMY
X	Next_opt("armies, ");
X#endif
X#ifdef WORM
X	Next_opt("long worms, ");
X#endif
X#ifdef GOLEMS
X	Next_opt("golems, ");
X#endif
X#ifdef INFERNO
X	Next_opt("inferno, ");
X#endif
X#ifdef SEDUCE
X	Next_opt("seduction, ");
X#endif
X#ifdef TOLKIEN
X	Next_opt("Tolkien extras, ");
X#endif
X#ifdef PROBING
X	Next_opt("wand of probing, ");
X#endif
X#ifdef WALKIES
X	Next_opt("leashes, ");
X#endif
X#ifdef SHIRT
X	Next_opt("Hawaiian shirt, ");
X#endif
X#ifdef MUSIC
X	Next_opt("music, ");
X#endif
X#ifdef TUTTI_FRUTTI
X	Next_opt("fruits, ");
X#endif
X#ifdef SPELLS
X	Next_opt("spells, ");
X#endif
X#ifdef NAMED_ITEMS
X	Next_opt("named items, ");
X#endif
X#ifdef ELBERETH
X	Next_opt("Elbereth, ");
X#endif
X#ifdef EXPLORE_MODE
X	Next_opt("explore mode, ");
X#endif
X#ifdef HARD
X	Next_opt("HARD, ");
X#endif
X#ifdef REDO
X	Next_opt("redo-commands, ");
X#endif
X#ifdef CLIPPING
X	Next_opt("screen clipping, ");
X#endif
X#ifdef TEXTCOLOR
X	Next_opt("color, ");
X#endif
X#ifdef DGK
X	Next_opt("Don Kneller's enhancements, ");
X#endif
X#ifdef OVERLAY
X	Next_opt("overlays, ");
X#endif
X#ifdef SHELL
X	Next_opt("shell command, ");
X#endif
X#ifdef MAIL
X	Next_opt("mail, ");
X#endif
X#ifdef NEWS
X	Next_opt("news file, ");
X#endif
X#ifdef COM_COMPL
X	Next_opt("command line completion, ");
X#endif
X#ifdef AMIGA_WBENCH
X	Next_opt("Amiga WorkBench support, ");
X#endif
X#ifdef WIZARD
X	Next_opt("wizard mode, ");
X#endif
X#ifdef LOGFILE
X	Next_opt("logfile, ");
X#endif
X#ifdef TERMLIB
X	Next_opt("termcap file, ");
X#endif
X#ifdef TERMINFO
X	Next_opt("terminfo, ");
X#endif
X#ifdef ANSI_DEFAULT
X	Next_opt("ANSI default terminal, ");
X#endif
X#ifdef COMPRESS
X	Next_opt("compress bones/level/save files, ");
X#endif
X	Next_opt("basic NetHack features");
X	Next_opt("");
X	set_pager(1);
X	return 0;
Xquit:
X	(void) next_opt("\033");
X	set_pager(2);
X	return 0;
X}
X
X#ifdef MSDOS
Xint
Xcomp_times(filetime)
Xlong filetime;
X{
X	if(filetime < compiletime) return (1);
X	else return (0);
X}
X#endif
END_OF_FILE
if test 3656 -ne `wc -c <'src/version.c'`; then
    echo shar: \"'src/version.c'\" unpacked with wrong size!
fi
# end of 'src/version.c'
fi
if test -f 'src/write.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/write.c'\"
else
echo shar: Extracting \"'src/write.c'\" \(3752 characters\)
sed "s/^X//" >'src/write.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)write.c	3.0	89/01/10
X */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include "hack.h"
X
Xstatic int FDECL(cost,(struct obj *));
X
X/*
X * returns basecost of a scroll
X */
Xstatic int
Xcost(scroll)
Xregister struct obj *scroll;
X{
X	switch(scroll->otyp)  {
X# ifdef MAIL
X	case SCR_MAIL:
X		return(2);
X/*		break; */
X# endif
X	case SCR_LIGHT:
X	case SCR_GOLD_DETECTION:
X	case SCR_FOOD_DETECTION:
X	case SCR_MAGIC_MAPPING:
X	case SCR_AMNESIA:
X	case SCR_FIRE:
X		return(8);
X/*		break; */
X	case SCR_DESTROY_ARMOR:
X	case SCR_CREATE_MONSTER:
X	case SCR_PUNISHMENT:
X		return(10);
X/*		break; */
X	case SCR_CONFUSE_MONSTER:
X		return(12);
X/*		break; */
X	case SCR_IDENTIFY:
X		return(14);
X/*		break; */
X	case SCR_ENCHANT_ARMOR:
X	case SCR_REMOVE_CURSE:
X	case SCR_ENCHANT_WEAPON:
X	case SCR_CHARGING:
X		return(16);
X/*		break; */
X	case SCR_SCARE_MONSTER:
X	case SCR_TAMING:
X	case SCR_TELEPORTATION:
X		return(20);
X/*		break; */
X	case SCR_GENOCIDE:
X		return(30);
X/*		break; */
X	case SCR_BLANK_PAPER:
X	default:
X		impossible("You can't write such a weird scroll!");
X	}
X	return(1000);
X}
X
Xstatic const char NEARDATA write_on[] = { SCROLL_SYM, 0 };
X
Xvoid
Xdowrite(pen)
Xregister struct obj *pen;
X{
X	register struct obj *paper;
X	char namebuf[BUFSZ], scrbuf[BUFSZ];
X	register struct obj *newscroll;
X	int basecost, actualcost;
X	int newquan;
X	int curseval;
X	
X	if(!pen)
X		return;
X	if(pen->otyp != MAGIC_MARKER)  {
X		You("can't write with that!");
X		return;
X	}
X	
X	/* get paper to write on */
X	paper = getobj(write_on,"write on");
X	if(!paper)
X		return;
X	if(!(objects[paper->otyp].oc_name_known))  {
X		pline("In your haste, you rip the scroll to pieces.");
X		useup(paper);
X		return;
X	}
X	if(paper->otyp != SCR_BLANK_PAPER)  {
X		You("fool, that scroll's not blank!");
X		return;
X	}
X	
X	/* what to write */
X	pline("What type of scroll do you want to write? ");
X	getlin(namebuf);
X	if(namebuf[0] == '\033' || !namebuf[0])
X		return;
X	scrbuf[0] = '\0';
X	if(strncmp(namebuf,"scroll of ",10) != 0)
X		Strcpy(scrbuf,"scroll of ");
X	Strcat(scrbuf,namebuf);
X	newscroll = readobjnam(scrbuf);
X
X	newscroll->bknown = (paper->bknown && pen->bknown);
X	/* do this now, before we useup() the paper */
X
X	if(newscroll->olet != SCROLL_SYM ||
X	   newscroll->otyp == SCR_BLANK_PAPER)  {
X		You("can't write that!");
X		pline("It's obscene!");
X		obfree(newscroll, (struct obj *) 0); /* pb@ethz.uucp */
X		return;
X	}
X	
X	/* see if there's enough ink */
X	basecost = cost(newscroll);
X	if(pen->spe < basecost/2)  {
X		Your("marker is too dry to write that!");
X		obfree(newscroll, (struct obj *) 0);
X		return;
X	}
X	
X	/* we're really going to write now, so calculate
X	 * cost and useup old scroll
X	 */
X	actualcost = rn1(basecost/2,basecost/2);
X	curseval = bcsign(pen) + bcsign(paper);
X	useup(paper);
X	
X	/* dry out marker */
X	if(pen->spe < actualcost)  {
X		Your("marker dries out!");
X		pline("The scroll is now useless and disappears!");
X		pen->spe = 0;
X		obfree(newscroll, (struct obj *) 0);
X		return;
X	}
X	pen->spe -= actualcost;
X	
X	/* can't write if we don't know it - unless we're lucky */
X	if(!(objects[newscroll->otyp].oc_name_known) && 
X	   !(objects[newscroll->otyp].oc_uname) && 
X	   (rnl(pl_character[0] == 'W' ? 3 : 15))) {
X		You("don't know how to write that!");
X		You("write \"%s was here!\" and the scroll disappears.",
X			plname);
X		obfree(newscroll, (struct obj *) 0);
X		return;
X	}
X	
X	/* and now you know it! */
X	makeknown(newscroll->otyp);
X	
X	/* success - don't forget to fool prinv() */
X	newscroll = addinv(newscroll);
X	newquan = newscroll->quan;
X	newscroll->quan = 1;
X	newscroll->blessed = (curseval > 0);
X	newscroll->cursed = (curseval < 0);
X	prinv(newscroll);
X	newscroll->quan = newquan;
X#ifdef MAIL
X	if (newscroll->otyp == SCR_MAIL) newscroll->spe = 1;
X#endif
X	newscroll->known = 1;
X}
END_OF_FILE
if test 3752 -ne `wc -c <'src/write.c'`; then
    echo shar: \"'src/write.c'\" unpacked with wrong size!
fi
# end of 'src/write.c'
fi
echo shar: End of archive 54 \(of 56\).
cp /dev/null ark54isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 56 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
    echo Building monst.c from monst.c1 and monst.c2
    cat src/monst.c1 src/monst.c2 > src/monst.c
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
