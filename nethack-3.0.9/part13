Path: utzoo!utgpu!news-server.csri.toronto.edu!cs.utexas.edu!mailrus!cornell!uw-beaver!zephyr.ens.tek.com!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v10i058:  nethack3p9 -  display oriented dungeons & dragons (Ver. 3.0i), Part13/56
Message-ID: <5914@tekred.CNA.TEK.COM>
Date: 12 Jul 90 00:32:29 GMT
Sender: news@tekred.CNA.TEK.COM
Lines: 1986
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 10, Issue 58
Archive-name: nethack3p9/Part13
Supersedes: NetHack3: Volume 7, Issue 56-93



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 13 (of 56)."
# Contents:  mac/MD.proj.hqx src/objnam.c
# Wrapped by billr@saab on Wed Jul 11 17:11:08 1990
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'mac/MD.proj.hqx' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mac/MD.proj.hqx'\"
else
echo shar: Extracting \"'mac/MD.proj.hqx'\" \(17003 characters\)
sed "s/^X//" >'mac/MD.proj.hqx' <<'END_OF_FILE'
X(This file must be converted with BinHex 4.0)
X
X:$@eKDf9NC@Cc,R"bEfS!8&*25NY"5%`!N!JhP#4S!*!%!3#3!cAk!!!dqJ!!!CS
X!!""G$80bD@0VCA3J4h*KF'J#!*!$39"36%0(8NBK"!eYB@YPC'9QFbj`FQpU!J#
X3!e"56dT,38K-!3#3"&J!!&"56dT,38K-!3#3"&J!!%e9!*!0!U)XCN!!N!BhP!#
X3#K8!N!-3A3pQD@jN)%e')'CKBh4[FR-#!*!$39"36%eZ4Q3K"!!+!#`!N!3L#J#
X3$PN8!!"F!+(@VNLKeUj2SGH0eJ#3(Jc-!!%0KJ!@!*!'!r!!N2m!N2m!N2m!N2,
XF!!!"@!!!F!8!!%459P)"8!!`VH`!!2m`!,B!N!83!$#Yl!!!rc!!YJ#3"4!!-+h
XX!!$r-!#f!*!&%!!`VH`!!2m`!,B!N!83!$#Yl!!!rc!!YJ#3"4!!-+hX!!$r-!#
Xf!*!&%!!`VH`!!2m`!,B!N!83!$#Yl!!!rc!!YJ#3"4!!-+hX!!$r-!#f!*!&%!!
X`VH`!!2m`!,B!N!83!$#Yl!!!rc!!YJ#3"4!!-+hX!!$r-!#f!*!&%!!`VH`!!2m
X`!,B!N!83!$#Yl!!!rc!!YJ#3"4!!-+hX!!$r-!#f!*!&%!!`VH`!!2m`!,B!N!8
X3#'eKDf9NC@CcYJ#3"4!!-+hX!!$r-!#f!*!&%!!`VH`!!2m`!,B!N!83!$#Yl!!
X!rc!!YJ#3"4""8&"-EQK04!J!!B!!N!-+#!!!"J#3!`B!N!9J!*!$F!#3"e!!N!-
XJ!"`r2!!"UI!%#Mmm!!'Tm!3H2c`!!DR`"$)r2!!"UI!%6Mmm!!'Tm!5%2c`!!DR
X`"+3r2!!"UI!%aMmm!!'Tm!6Q2c`!!DR`"air2!!"UI!!N!-%!*!("!#30!&B!!"
X`"3!!4&*@8J&3!$#Yl!!!rc!!YJ#3"4!!-+hX!!$r-!#f!*!&%!!`VH`!!2m`!,B
X!N!83!$#Yl!!!rc!!YJ#3"4!!-+hX!!$r-!#f!*!&%!!`VH`!!2m`!,B!N!83!$#
XYl!!!rc!!YJ#3"4!!-+hX!!$r-!#f!*!&%!!`VH`!!2m`!,B!N!83!$#Yl!!!rc!
X!YJ#3"4!!-+hX!!$r-!#f!*!&%!!`VH`!!2m`!,B!N!83!$#Yl!!!rc!!YJ#3"4!
X!-+hX!!$r-!#f!*!&%!!`VH`!!2m`!,B!N!83!$#Yl!!!rc!!YJ#3"4!!-+hX!!$
Xr-!#f!*!&%!!`VH`!!2m`!,B!N!83!$#Yl!!!rc!!YJ#3"4!!-+hX!!$r-!#f!*!
X&%%&38%aYDf3U!!!"J!#3!`J!!2m`!,B!N!d+!*!-*!!!-iUS!$0Qk!!cCi`!!!+
X)!*!&-J#3&N#!lNi!-fES3!!!d!!cCV3!N!8cC[!!-fEd!$0Qq!!cC[`!-fF!!$0
XR"!!cC`J!-fF-!$0R%!!cCa3!-fFB!$0R(!!cCb!!-fFN!$0R+!!cCb`!-fF`!$0
XR0!!cCcJ!-fFm!$0R3!!cCd3!-fG)!$0R6!!cCe!!-fG8!$0R@!!cCe`!-fGJ!$0
XRC!!cCfJ!-fGX!$0RF!!cCh3!-fGi!$0RI!!cCi!!-fH%!$0RL!!cL!!!-i-N!$0
Xq5!!cIK3!-hhN!$0pY!!cH0J!-h0S!$0YC!!cCm#!!!@N!!!"!!)!#3N!!3!!rj!
X)SL3#2!!D!!%!!#R968&,43!+E@&VC@4PCR-ZB`#3!`'JR-eYS*c0ED#Fc@d!'J!
X#!!!RrNe"3dJ"#NeKBdKPB@4PFR-!N!-"SLaT$U)XD3kL,'N1!"J!!3!!+GC$6dj
X'!!KMEfjQD@FZD!"c!!+L(KlhSKiHpk)H([F!'J!"!!!TeP45383!#R4bB@4cG'4
XM,QJ!N!-#SKiG4D)H(8@L(Ke&!"J!!3!!+GC(6%p#!!KRE'pLB@`ZD!"S!!1Jar@
XhS-IeYk$(pEF!&J!#!!!SB&084%N""h0dC'P[,QJ!!!1L(K[jSKiEqD)H'rN!&J!
X"!!!TeN026e)!"f0[Eh*N,QJ!!!1L*`[LSLF,iU)R#q)!'!!"!!!TeNe"3d-!#@e
XKBf0[EQBZD!!!"+)H(JDL(Ki'SKiH"J!@!!%!!#R@690%6`!(EA0NEh-ZD!!!"+)
XH(Y1L(Kl6SKiHd`!B!!%!!#R@8eP69!!)FhPcG'9Y,QJ!N!-%S*cGjD#FhH@JR0h
XP!"B!!J!!+'"858e&!3CdD@eP,QJ!D!!%S*cG0k#Fh6HJR0dh!"B!!J!!+'"'3dj
X8!3G'BfjdE#jS!!!%S*cGV+#FhDbJR0fX!"J!!J!!+'"69%4%!3K6G'4NC@BZD!#
X3!`5JR0h9S*cGeD#FhG8!'!!#!!!SB&084%`"#&0dC'aTBLjS!*!$"+$(p0QJar6
XCS-Idf3!B!!)!!#KJ8e4553%)8h4bD@jR,QJ!N!-%S*c03k#Fc81JR-e$!"J!!J!
X!+!03390$!3K`BA0MB@`ZD!#3!`5JR-BRS*c'*k#FaLF!'J!#!!!S!e&958-"#e&
XeD@0VC(*KGbjS!!!%S*c&jU#FaHDJR-AQ!"J!!J!!+!0'6dj8!3P'Efjd6@Gb,QJ
X!!!5JR-A9S*c&eD#FaG8!'J!#!!!S!d9@48i"#N9fC@jd6@Gb,QJ!N!-%S*c'Hk#
XFaRZJR-Cl!"S!!J!!+!0A58j%!3YAD@jNEhG0Ch)ZD!!!"+#FaJ5JR-B%S*c'"!!
XB!!)!!#J$689193%*6@9ZG8eRFLjS!!!%S*c'Ak#FaPqJR-CI!"`!!J!!+!069%4
X'!3a6G'4'D@aP8'YR,QJ!E`!%S*c'2k#FaMqJR-Br!"`!!J!!+!0648G0!3a6C@G
XYC@jd6'4b,QJ!E`!%S*c'ED#FaQfJR-CY!"`!!J!!+!086dp-!3e8EfpXBQpi9A4
XTE#jS!!!%S*c'$U#FaJkJR-B1!"J!!J!!+!028e98!3K28e9dD@`ZD!"T!!5JR-A
X$S*c&`k#FaF-!'J!#!!!S!d4*38`"#d4TB@a[CdeRFLjS!!!%S*c&fU#FaGUJR-A
XD!"J!!J!!+!0'58a&!3P'D@aP6@Gb,QJ!!!5JR-AXS*c&l+#FaH`!&!!#!!!S!dK
X'8bi""8K'8bjS!!!%S,%p&D#a24@JX6d9!"B!!J!!+!0$6da2!3G$Efa[FLjS!!!
X%S*c'+k#FaLZJR-BV!"`!!J!!+!054902!3e5CA0[GA*MC8eRFLjS!!!%SLQSeU)
XTU0DL+DM@!"J!!3!!+GC&@&4&!!KPH(4PFQiZD!"R!!5L(KZDSKiEQU)H'jS!'J!
X"!!!TeNe"3d%!#NeKBd&XCA*d,QJ!,J!"SKiHBD)H(Q'L(KjK!"S!!3!!+GC349*
X0!!T`CA*YEfjcG#jS!#i!!U)H(DUL(KfUSKiGUJ!B!!%!!#R@68p133!*E@pZBA4
XdDbjS!!!#SKiGiU)H(H+L(KhL!"J!!3!!+GC06dj'!!PYEfjQE'&R,QJ!!!'L(Ki
XZSKiH,U)H(Li!'J!"!!!TeNp#5N-!#QpLDQ0XBA0c,QJ!,J!"S*c&Sk#FaD1JR-@
XM!"`!!J!!+!0$6dj8!!a$EfjdFQpX6@Gb,QJ!!)!!"J3!N!2m!J!*#3!"!!$rN!L
XL(MID!"B!!3!!+G906dj6!!GYEfjcG#jM!!!"S*c0ED#Fc@fJR-eY!"S!!J!!*rj
X0380)!3T0B@0)C@&NCA*c!#i!!D)XD3kL,'N1SLaT$J!B!!%!!#R@3dp14J!)Bfp
XZCQPR,QJ!F`!#SKiHpk)H([HL(Klh!"S!!3!!+GC88N&%!!TdFQ&NFh4NBbjS!#i
X!!U)H(8@L(Ke&SKiG43!B!!%!!#R@4da23J!)Cfa[BQ&X,QJ!D!!$S-IeYk$(pEH
XJar@h!"B!!J!!+'"69%4*!3GcG'4TEbjS!!!$SKiEqD)H'rQL(K[j!"B!!3!!+GC
X$6dp5!!GMEfpbC#jS!!!$SLF,iU)R#q+L*`[L!"J!!3!!+GC0380$!!PYB@0MEfj
XQ,QJ!!!5L(Ki'SKiH"U)H(JB!&J!"!!!TeNe64%m!"fecC'pc,QJ!!!5L(Kl6SKi
XHdk)H(Y-!'!!"!!!TeP0C8e3!#(0jFh4PE5jS!*!$"+#FhH@JR0hPS*cGj3!@!!)
X!!#KJ9%P043%'G'PYC5jS!'J!"+#Fh6HJR0dhS*cG0`!@!!)!!#KJ4N019!%(4Q0
XZG'`ZD!!!"+#FhDbJR0fXS*cGV!!B!!)!!#KJ8e4%4!%)8h4NC'9Q,QJ!N!-%S*c
XGeD#FhG@JR0h9!"J!!J!!+'"69%4-!3K6G'4XD@)ZD!#3!`5Jar6CS-IdfD$(p0N
X!'!!#!!!SB&088NN"#&0dFQPZCbjS!*!$"+#Fc81JR-e$S*c03`!B!!)!!#J$8%&
X63`%)F'&cBf&X,QJ!N!-%S*c'*k#FaLHJR-BR!"S!!J!!+!0498P$!3Y4G@PMDf4
XbBAFZD!!!"+#FaHDJR-AQS*c&jJ!B!!)!!#J$4Np19!%*4QpZG%eRFLjS!!!%S*c
X&eD#FaG@JR-A9!"S!!J!!+!0&9N91!3T&GQ9ZG%eRFLjS!*!$"+#FaRZJR-ClS*c
X'H`!D!!)!!#J$9dP14!%,9fPZC'ph6@Gb,QJ!!!5JR-B%S*c'"+#FaJ3!'!!#!!!
XS!de&6P8"#8ePER90Ch)ZD!!!"+#FaPqJR-CIS*c'A`!F!!)!!#J$8e4%4J%-8h4
XN4QPXC9"VCbjS!*!$"+#FaMqJR-BrS*c'2`!F!!)!!#J$8d9(63%-8f9RE@9ZG%a
XNFLjS!*!$"+#FaQfJR-CYS*c'E3!F!!)!!#J$9%p26!%09'p[E'*[H&9dD@`ZD!!
X!"+#FaJkJR-B1S*c'$J!B!!)!!#J$6e099!%)6e09G'PX,QJ!D3!%S*c&`k#FaF1
XJR-A$!"S!!J!!+!0%58&-!3Y%D@&XEfG0Ch)ZD!!!"+#FaGUJR-ADS*c&fJ!B!!)
X!!#J$4NP-43%*4QPXC8eRFLjS!!!%S*c&l+#FaHbJR-AX!"3!!J!!+!0)4P-Z!39
X)4P-ZD!!!"+#a24@JX6d9S,%p&3!@!!)!!#J$3dp-6`%(3fpXEh)ZD!!!"+#FaLZ
XJR-BVS*c'+`!F!!)!!#J$8N966`%08Q9cEh9bBf90Ch)ZD!!!"+)TU0DL+DM@SLQ
XSeJ!B!!%!!#R@49K843!)CAKdCA*Z,QJ!C`!%SKiEQU)H'jUL(KZD!"S!!3!!+GC
X0380"!!T0B@0"E'9bG#jS!#i!!D)H(Q'L(KjKSKiHB3!D!!%!!#R@8%9563!+F'9
XbE@pZFh3ZD!!Z!!+L(KfUSKiGUU)H(DS!'!!"!!!TeNe26N%!#@e[EQ&dG'XZD!!
X!!U)H(H+L(KhLSKiGiJ!B!!%!!#R@68p14J!*E@pZCQaKCbjS!!!"SKiH!D)H(J'
XL(Ki"!"J!!3!!+GC06dj6!!KYEfjcH@dZD!#3!`'L(K`hSKiF0k)H($F!&J!"!!!
XTeN965%X!"Q9cD'XZD!"S!!'L(Kp&SKiI4D)H(d8!&J!"!!!TePC"98`!"hCKG@a
Xd,QJ!!!'L(K``SKiF-+)H($!!&J!"!!!TeN938NN!"Q9`FQNZD!#3!`'L(K[$SKi
XE`k)H'm-!&J!"!!!TeN026%m!"f0[E'pb,QJ!JJ!&F!#3!rJ#!!N*!!%!!2q3#+)
XN!Zd!'!!"!!!Te8p#5N8!#@pLDQ9MG(-ZB`!!!D#Fc@fJR-eYS*c0E3!D!!)!!#I
Xq68&$5!%+6@&M5'9KC'9bF`!Z!!'L,'N1SLaT$U)XD3i!'!!"!!!TeN026NB!#'0
X[EQCTCbjS!(-!!U)H([HL(KlhSKiHp`!D!!%!!#R@9&*"4!!+G(*KC(0dC'-ZD!!
XZ!!+L(Ke&SKiG4D)H(88!'!!"!!!TeNG-6d)!#'GXEf*KE#jS!'J!!k$(pEHJar@
XhS-IeY`!@!!)!!#KJ8e4%53%(Fh4ND@mZD!!!!k)H'rQL(K[jSKiEq3!@!!%!!#R
X@3dp28J!(Bfp[FQ3ZD!!!!k)R#q+L*`[LSLF,iJ!B!!%!!#R@68&$3`!*E@&MBfp
XZCLjS!!!%SKiH"U)H(JDL(Ki'!"B!!3!!+GC08d42!!GYFf4[FbjS!!!%SKiHdk)
XH(Y1L(Kl6!"J!!3!!+GC6@908!!KcHA0dC@dZD!#3!`5JR0hPS*cGjD#FhH8!&J!
X#!!!SB&4*688""R4TE@8ZD!"S!!5JR0dhS*cG0k#Fh6F!&J!#!!!SB%C$6P3""dC
XMER4X,QJ!!!5JR0fXS*cGV+#FhD`!'!!#!!!SB&084%3"#&0dC'4PCLjS!*!$"+#
XFhG@JR0h9S*cGe3!B!!)!!#KJ8e4%6!%)8h4NE'PL,QJ!N!-%S-IdfD$(p0QJar6
XC!"J!!J!!+'"69&**!3K6G(*TEQFZD!#3!`5JR-e$S*c03k#Fc8-!'!!#!!!S!e"
X"8d-"#("KFf0KE#jS!*!$"+#FaLHJR-BRS*c'*`!D!!)!!#J$899*3`%,8A9TBfY
XNFQ&h,QJ!!!5JR-AQS*c&jU#FaHB!'!!#!!!S!dC26P3"#8C[ER40Ch)ZD!!!"+#
XFaG@JR-A9S*c&e3!D!!)!!#J$49C&6J%+4ACPER40Ch)ZD!#3!`5JR-ClS*c'Hk#
XFaRX!'J!#!!!S!eG*6N3"#eGTEQ4[GdeRFLjS!!!%S*c'"+#FaJ5JR-B%!"J!!J!
X!+!0048j9!3P0C@je6@Gb,QJ!!!5JR-CIS*c'Ak#FaPm!(!!#!!!S!e084%B"$&0
XdC%CTE'93DfFZD!#3!`5JR-BrS*c'2k#FaMm!(!!#!!!S!e0&4dd"$&0PCfePER4
X-C()ZD!#3!`5JR-CYS*c'ED#FaQd!(!!#!!!S!e426d`"$94[EfaLEhK9G'PX,QJ
X!!!5JR-B1S*c'$U#FaJi!'!!#!!!S!dp6993"#%p69A4TE#jS!'N!"+#FaF1JR-A
X$S*c&``!D!!)!!#J$4%P"6!%,4'PKE'pR6@Gb,QJ!!!5JR-ADS*c&fU#FaGS!'!!
X#!!!S!dC*6%8"#8CTE'90Ch)ZD!!!"+#FaHbJR-AXS*c&l!!8!!)!!#J$5%C6,J%
X&5%C6,QJ!!!5JX6d9S,%p&D#a248!&J!#!!!S!d026%m""d0[E'pb,QJ!!!5JR-B
XVS*c'+k#FaLX!(!!#!!!S!e*&8dm"$9*PFfpeFQ0P6@Gb,QJ!!!5L+DM@SLQSeU)
XTU0B!'!!"!!!TeN9B9%8!#'9iG'9bELjS!'F!"+)H'jUL(KZDSKiEQJ!D!!%!!#R
X@68&$33!+6@&M3@aPFR3ZD!!Z!!'L(KiESKiH'k)H(KX!&!!"!!!TeNp#5Li!"@p
XLDLjS!!!"SKiH,U)H(LkL(KiZ!"S!!3!!+GC23NT$!!T[BQTME'&cFbjS!#i!!D)
XH(QQL(KjTSKiHD3!@!!%!!#R@8&*28!!'F(*[F#jS!(-!!D)H'm1L(K[$SKiE``!
X@!!%!!#R@3dp-6`!(BfpXEh)ZD!!!!B)!"0`!N!2d!J!*#3!"!!$rN!LL(MXi!"B
X!!3!!+G9338j*!!G`B@jTBbjM!!!"S*c0ED#Fc@fJR-eY!"S!!J!!*rj0380)!3T
X0B@0)C@&NCA*c!#i!!D)XD3kL,'N1SLaT$J!B!!%!!#R@3dp14J!)BfpZCQPR,QJ
X!F`!#SKiHpk)H([HL(Klh!"S!!3!!+GC88N&%!!TdFQ&NFh4NBbjS!#i!!U)H(8@
XL(Ke&SKiG43!B!!%!!#R@4da23J!)Cfa[BQ&X,QJ!D!!$S-IeYk$(pEHJar@h!"B
X!!J!!+'"69%4*!3GcG'4TEbjS!!!$SKiEqD)H'rQL(K[j!"B!!3!!+GC$6dp5!!G
XMEfpbC#jS!!!$SLF,iU)R#q+L*`[L!"J!!3!!+GC0380$!!PYB@0MEfjQ,QJ!!!5
XL(Ki'SKiH"U)H(JB!&J!"!!!TeNe64%m!"fecC'pc,QJ!!!5L(Kl6SKiHdk)H(Y-
X!'!!"!!!TeP0C8e3!#(0jFh4PE5jS!*!$"+#FhH@JR0hPS*cGj3!@!!)!!#KJ9%P
X043%'G'PYC5jS!'J!"+#Fh6HJR0dhS*cG0`!@!!)!!#KJ4N019!%(4Q0ZG'`ZD!!
X!"+#FhDbJR0fXS*cGV!!B!!)!!#KJ8e4%4!%)8h4NC'9Q,QJ!N!-%S*cGeD#FhG@
XJR0h9!"J!!J!!+'"69%4-!3K6G'4XD@)ZD!#3!`5Jar6CS-IdfD$(p0N!'!!#!!!
XSB&088NN"#&0dFQPZCbjS!*!$"+#Fc81JR-e$S*c03`!B!!)!!#J$8%&63`%)F'&
XcBf&X,QJ!N!-%S*c'*k#FaLHJR-BR!"S!!J!!+!0498P$!3Y4G@PMDf4bBAFZD!!
X!"+#FaHDJR-AQS*c&jJ!B!!)!!#J$4Np19!%*4QpZG%eRFLjS!!!%S*c&eD#FaG@
XJR-A9!"S!!J!!+!0&9N91!3T&GQ9ZG%eRFLjS!*!$"+#FaRZJR-ClS*c'H`!D!!)
X!!#J$9dP14!%,9fPZC'ph6@Gb,QJ!!!5JR-B%S*c'"+#FaJ3!'!!#!!!S!de&6P8
X"#8ePER90Ch)ZD!!!"+#FaPqJR-CIS*c'A`!F!!)!!#J$8e4%4J%-8h4N4QPXC9"
XVCbjS!*!$"+#FaMqJR-BrS*c'2`!F!!)!!#J$8d9(63%-8f9RE@9ZG%aNFLjS!*!
X$"+#FaQfJR-CYS*c'E3!F!!)!!#J$9%p26!%09'p[E'*[H&9dD@`ZD!!!"+#FaJk
XJR-B1S*c'$J!B!!)!!#J$6e099!%)6e09G'PX,QJ!D3!%S*c&`k#FaF1JR-A$!"S
X!!J!!+!0%58&-!3Y%D@&XEfG0Ch)ZD!!!"+#FaGUJR-ADS*c&fJ!B!!)!!#J$4NP
X-43%*4QPXC8eRFLjS!!!%S*c&l+#FaHbJR-AX!"3!!J!!+!0)4P-Z!39)4P-ZD!!
X!"+#a24@JX6d9S,%p&3!@!!)!!#J$3dp-6`%(3fpXEh)ZD!!!"+#FaLZJR-BVS*c
X'+`!F!!)!!#J$8N966`%08Q9cEh9bBf90Ch)ZD!!!"+)TU0DL+DM@SLQSeJ!B!!%
X!!#R@49K843!)CAKdCA*Z,QJ!C`!%SKiEQU)H'jUL(KZD!"S!!3!!+GC0380"!!T
X0B@0"E'9bG#jS!#jMD)!!!$!!N!2`!!!*#3!"!!$rN!LJb!28!"3!!J!!+&P"6P0
X*!!4"6P0*!#k!!!!`!*!$l!!!#3N!!3!!rj!)S-J0[!!8!!)!!#KC98j*@!!%G@j
XTH!!ZJ!!!0!#3!qJ!!!N*!!%!!2q3#+#Z`J)!'!!#!!!S"8e"3e3!#%eKBe4bBA"
Xc!!##!!6F!*!$j!)!#3N!!3!!rj!)SKiPl`!@!!%!!#R938a-6`!(B@aXEf-ZB`!
X!!D#Fc@fJR-eYS*c0E3!D!!)!!#Iq68&$5!%+6@&M5'9KC'9bF`!Z!!'L,'N1SLa
XT$U)XD3i!'!!"!!!TeN026NB!#'0[EQCTCbjS!(-!!U)H([HL(KlhSKiHp`!D!!%
X!!#R@9&*"4!!+G(*KC(0dC'-ZD!!Z!!+L(Ke&SKiG4D)H(88!'!!"!!!TeNG-6d)
X!#'GXEf*KE#jS!'J!!k$(pEHJar@hS-IeY`!@!!)!!#KJ8e4%53%(Fh4ND@mZD!!
X!!k)H'rQL(K[jSKiEq3!@!!%!!#R@3dp28J!(Bfp[FQ3ZD!!!!k)R#q+L*`[LSLF
X,iJ!B!!%!!#R@68&$3`!*E@&MBfpZCLjS!!!%SKiH"U)H(JDL(Ki'!"B!!3!!+GC
X08d42!!GYFf4[FbjS!!!%SKiHdk)H(Y1L(Kl6!"J!!3!!+GC6@908!!KcHA0dC@d
XZD!#3!`5JR0hPS*cGjD#FhH8!&J!#!!!SB&4*688""R4TE@8ZD!"S!!5JR0dhS*c
XG0k#Fh6F!&J!#!!!SB%C$6P3""dCMER4X,QJ!!!5JR0fXS*cGV+#FhD`!'!!#!!!
XSB&084%3"#&0dC'4PCLjS!*!$"+#FhG@JR0h9S*cGe3!B!!)!!#KJ8e4%6!%)8h4
XNE'PL,QJ!N!-%S-IdfD$(p0QJar6C!"J!!J!!+'"69&**!3K6G(*TEQFZD!#3!`5
XJR-e$S*c03k#Fc8-!'!!#!!!S!e""8d-"#("KFf0KE#jS!*!$"+#FaLHJR-BRS*c
X'*`!D!!)!!#J$899*3`%,8A9TBfYNFQ&h,QJ!!!5JR-AQS*c&jU#FaHB!'!!#!!!
XS!dC26P3"#8C[ER40Ch)ZD!!!"+#FaG@JR-A9S*c&e3!D!!)!!#J$49C&6J%+4AC
XPER40Ch)ZD!#3!`5JR-ClS*c'Hk#FaRX!'J!#!!!S!eG*6N3"#eGTEQ4[GdeRFLj
XS!!!%S*c'"+#FaJ5JR-B%!"J!!J!!+!0048j9!3P0C@je6@Gb,QJ!!!5JR-CIS*c
X'Ak#FaPm!(!!#!!!S!e084%B"$&0dC%CTE'93DfFZD!#3!`5JR-BrS*c'2k#FaMm
X!(!!#!!!S!e0&4dd"$&0PCfePER4-C()ZD!#3!`5JR-CYS*c'ED#FaQd!(!!#!!!
XS!e426d`"$94[EfaLEhK9G'PX,QJ!!!5JR-B1S*c'$U#FaJi!'!!#!!!S!dp6993
X"#%p69A4TE#jS!'N!"+#FaF1JR-A$S*c&``!D!!)!!#J$4%P"6!%,4'PKE'pR6@G
Xb,QJ!!!5JR-ADS*c&fU#FaGS!'!!#!!!S!dC*6%8"#8CTE'90Ch)ZD!!!"+#FaHb
XJR-AXS*c&l!!8!!)!!#J$5%C6,J%&5%C6,QJ!!!5JX6d9S,%p&D#a248!&J!#!!!
XS!d026%m""d0[E'pb,QJ!!!5JR-BVS*c'+k#FaLX!(!!#!!!S!e*&8dm"$9*PFfp
XeFQ0P6@Gb,QJ!!!5L+DM@SLQSeU)TU0B!'!!"!!!TeN9B9%8!#'9iG'9bELjS!'F
X!"+)H'jUL(KZDSKiEQJ!D!!%!!#R@68&$33!+6@&M3@aPFR3ZD!!ZS*b!!!6F!*!
X$i!)!#3N!!3!!rj!)SKj,$3!B!!%!!#R968&$4J!*E@&MCQPXC5jM!!!"S*c0ED#
XFc@fJR-eY!"S!!J!!*rj0380)!3T0B@0)C@&NCA*c!#i!!D)XD3kL,'N1SLaT$J!
XB!!%!!#R@3dp14J!)BfpZCQPR,QJ!F`!#SKiHpk)H([HL(Klh!"S!!3!!+GC88N&
X%!!TdFQ&NFh4NBbjS!#i!!U)H(8@L(Ke&SKiG43!B!!%!!#R@4da23J!)Cfa[BQ&
XX,QJ!D!!$S-IeYk$(pEHJar@h!"B!!J!!+'"69%4*!3GcG'4TEbjS!!!$SKiEqD)
XH'rQL(K[j!"B!!3!!+GC$6dp5!!GMEfpbC#jS!!!$SLF,iU)R#q+L*`[L!"J!!3!
X!+GC0380$!!PYB@0MEfjQ,QJ!!!5L(Ki'SKiH"U)H(JB!&J!"!!!TeNe64%m!"fe
XcC'pc,QJ!!!5L(Kl6SKiHdk)H(Y-!'!!"!!!TeP0C8e3!#(0jFh4PE5jS!*!$"+#
XFhH@JR0hPS*cGj3!@!!)!!#KJ9%P043%'G'PYC5jS!'J!"+#Fh6HJR0dhS*cG0`!
X@!!)!!#KJ4N019!%(4Q0ZG'`ZD!!!"+#FhDbJR0fXS*cGV!!B!!)!!#KJ8e4%4!%
X)8h4NC'9Q,QJ!N!-%S*cGeD#FhG@JR0h9!"J!!J!!+'"69%4-!3K6G'4XD@)ZD!#
X3!`5Jar6CS-IdfD$(p0N!'!!#!!!SB&088NN"#&0dFQPZCbjS!*!$"+#Fc81JR-e
X$S*c03`!B!!)!!#J$8%&63`%)F'&cBf&X,QJ!N!-%S*c'*k#FaLHJR-BR!"S!!J!
X!+!0498P$!3Y4G@PMDf4bBAFZD!!!"+#FaHDJR-AQS*c&jJ!B!!)!!#J$4Np19!%
X*4QpZG%eRFLjS!!!%S*c&eD#FaG@JR-A9!"S!!J!!+!0&9N91!3T&GQ9ZG%eRFLj
XS!*!$"+#FaRZJR-ClS*c'H`!D!!)!!#J$9dP14!%,9fPZC'ph6@Gb,QJ!!!5JR-B
X%S*c'"+#FaJ3!'!!#!!!S!de&6P8"#8ePER90Ch)ZD!!!"+#FaPqJR-CIS*c'A`!
XF!!)!!#J$8e4%4J%-8h4N4QPXC9"VCbjS!*!$"+#FaMqJR-BrS*c'2`!F!!)!!#J
X$8d9(63%-8f9RE@9ZG%aNFLjS!*!$"+#FaQfJR-CYS*c'E3!F!!)!!#J$9%p26!%
X09'p[E'*[H&9dD@`ZD!!!"+#FaJkJR-B1S*c'$J!B!!)!!#J$6e099!%)6e09G'P
XX,QJ!D3!%S*c&`k#FaF1JR-A$!"S!!J!!+!0%58&-!3Y%D@&XEfG0Ch)ZD!!!"+#
XFaGUJR-ADS*c&fJ!B!!)!!#J$4NP-43%*4QPXC8eRFLjS!!!%S*c&l+#FaHbJR-A
XX!"3!!J!!+!0)4P-Z!39)4P-ZD!!!"+#a24@JX6d9S,%p&3!@!!)!!#J$3dp-6`%
X(3fpXEh)ZD!!!"+#FaLZJR-BVS*c'+`!F!!)!!#J$8N966`%08Q9cEh9bBf90Ch)
XZD!!!"+)TU0DL+DM@SLQSeJ!B!!%!!#R@49K843!)CAKdCA*Z,QJ!C`!%SKiEQU)
XH'jUL(KZD!"S!!3!!+GC0380"!!T0B@0"E'9bG#jS!#k!!!!S!*!$h!#3#8B!!3#
X3"4S!N!-"!!J%E@&TEL#3!`!!!SJ!"+#FaMqJR-BrS*c'2`!F!!)!!#J$8d9(63%
X-8f9RE@9ZG%aNFLjS!*!$"+#FaQfJR-CYS*c'E3!F!!)!!#J$9%p26!%09'p[E'*
X[H&9dD@`ZD!!!"+#FaJkJR-B1S*c'$J!B!!)!!#J$6e099!%)6e09G'PX,QJ!D3!
X%S*c&`k#FaF1JR-A$!"S!!J!!+!0%58&-!3Y%D@&XEfG0Ch)ZD!!!"+#FaGUJR-A
XDS*c&fJ!B!!)!!#J$4NP-43%*4QPXC8eRFLjS!!!%S*c&l+#FaHbJR-AX!"3!!J!
X!+!0)4P-Z!39)4P-ZD!!!"+#a24@JX6d9S,%p&3!@!!)!!#J$3dp-6`%(3fpXEh)
XZD!!!"+#FaLZJR-BVS*c'+`!F!!)!!#J$8N966`%08Q9cEh9bBf90Ch)ZD!!!"+)
XTU0DL+DM@SLQSeJ!B!!%!!#R@49K843!)CAKdCA*Z,QJ!C`!%SKiEQU)H'jUL(KZ
XD!"S!!3!!+GC0380"!!T0B@0"E'9bG#jS!#jMD)!!!$!!N!2`!!!*#3!"!!$rN!L
XJb!28!"3!!J!!+&P"6P0*!!4"6P0*!#k!!!!`!*!$l!!!#3N!!3!!rj!)S-J0[!!
X8!!)!!#KC98j*@!!%G@jTH!!ZJ!!!0!#3!qJ!!!N*!!%!!2q3#+#Z`J)!'!!#!!!
XS"8e"3e3!#%eKBe4bBA"c!*!&D!#3!``+6%aKFh4$E'PMDb#!!!!S!!!'D!!!"Q`
X!"J!!!QJ!!3!'!!!,+J!"!*!$#!C-3faTBfXJJ!!!,!!!"Q3!N!8'!!!"L!!"!!B
X!!!UU!!%!N!--#%a6CA4$C@aX)*!$!*!$$!!!"Q!!!!CN!!!#3!!!!3#3"'!!N"-
X%!*!H5-!"!`!(!*!$r!#3!f!!N"-%!*!H5-!"!`!)!*!$q!#3!f!!N"-%!*!J!3-
X!"J#3!r3!N!0J!*!6"!#3(NM!!3-!N!A`!*!$B!#3%`3!N"jNFJ)%!!%!N!2X!*!
X$B!#3%`3!N"m#!3-!!J#3!qJ!N!0J!*!6"!#3(Q4b!3-!!`#3!q3!N!0J!*!6"!#
X3(Lf-!3-!"3#3!q!!N!0J!*!6"!#3(L!)!3-!"!!!"c!!N!-+!*!Eh%*i#NUGcNk
Xk!&41ZJ"Q,$a*6N4B6VS&ENIkrmSQM%IkrmJQK%kk!'C1ZJ+S6VS'*Nkk!0a1ZJ#
XS3QG)H2rr5'm!"%KA2c`!!5)krl*1ZJ1#6V83!#"Y!'a1N!#Tp&(i#Pjq!%kk![T
XR#%U3!'F%#0!!"Nje)$J+H'B-,$aD6dj&6VS&"#!-4rVrCLD!6R9CMbmm4%&838*
XRUD!J9b"3)RJ*##!0N!#*4rVr6LD!S#kTSb`m8e458dkk"-j(q[mf*S`X2%4548a
X1ZJ5q)%`J"'F-6VS"YJ5!!*!$$'Ed6[S&DNj@rpT"q!N3)Np`)+!ZF!(3%9S4dX"
X"qJ!5F!@J,P@25'm!!UQA6Pj1G5jbFh*M!%Ik"HiQZ!Tm,cJ+J'B#@)p1G8MRrrJ
Xq,`!m8IJ+AQ!+@Bm[#+QP)"qJ3%kk!L4R4%IkrVJQL#!3CqBL3%U4CLi!%!$!,$a
X$8N9-6VS%,'FN2Lm!2#"-)!4R$%kk!(J%J!#3!`aQp%kk"0"1ZJ'F60mIrdjeF!q
XTb8kk"Aa1ZJ!)6VS%p%je)(J+l+!P)&!L5#)BB!T"k!!)G!'%'0$#8FRrp*!!L0#
X*CJ*1G5)!S#iJH!VX)!'J*#*36qrr`#"23UJ!%M&T!!3!&U!93UG)D3!-)%qTmM)
XB6VS"RL4BeF%d'#)BEM*R&P*"C`C53@FD6R8b+2rd6VS"Z0056R8b+2rd6VS"L00
X56R8b+2rd6VS"MY1Urrj1G8kk!8ib+3!-5QN!#QBF9%*U$("MUFP53QEide*1G8k
Xk!965U3!1de*1G8kk!@c5U3!18N*Q"0056R9$p4!#[P&Qe!aK2caQcP*#CJB+DJ!
XArrib)9K")RVpI0+4NNV68Nje-KK1ZJ%14I83!0AB0"KR-L)BEL4R$P*"CK3b+2r
Xd6VS"&Q!B-LMrp%kk!1KJ$M)Srr41ZJ$`B!C1ZJ%3dSh6NNje)KK1ZJ%%de*1G5"
Xkr4!J1[d35UJ!!'FS-LJ!+'FL*#J!'&P#3qd!%02S!!69@6,m2ca#'4,S!$dbr+R
X`88&Ql%(S!%!%J!#3!d"QaNje)(Vmc#!kr-abrh3!5UJ!!'FB[LJ!2@B50LJ!+'F
X-e%1bU!!%C33L+!!%3HJ!3!5!!*!$3'E@)(VmUL"3"%%!%$$"jNS``Nje@Bm[2%0
X24%8r"kQJ)&p3q!TH)!K1G5Kkr(BLG"J!Nq`!102-6R8SH[aH`[`!3#)d'"JSH[a
XQdT41G5Kkr%V#r!"!)M3B#*+kr%j1G5Kkr$M#r!"!)M3B%0+kr$K1G5Kkr#E#r!"
X!)M3B"!D"!*!$%%je6VVrSM)T!!a+D3!+CJC1Z[qiB!41Z[r@dUN!$Nje)&mb'$3
XBX&KAbIrk5N*RrNl`)2`JAc)B0"L`Q&I*rrT+3QIq6[!JqL"I-KJd',"#EJU3!%&
XY"Y"!3I!!!M!3Crj1m!!!)#m!"#p"!!3L,`!),em!"%MR2!!N!#B"5%,%`bJ!+J&
X)4FM&e%4)3T!$`-(3JNcI!$`L(dje)#m!"#p"!!3L,`!),em!"%MR-3"1ZJ#F60m
X!M#)I6R8J,`!%,d%!"#)[!!J[A`!%51Fa!%kk!(`J!8cI!)`L(dje)#m!"#p"!!3
XL,`!),em!"%MR-3"1ZJ!X60m!M#)I6R8J,`!%,d%!"#)[!!J[A`!%51Fa!%kk!!`
XJ!8cI!)`L(dje5S"U(%U"DJa%J%5"6VS!)%5"6R9%J%kk!"C%J%5"6R9+J@S+4)&
X1ZJ!'4)"1G5im!!$rrl+!B`BL!(!!6R@`Kf)-J-&)3$)!3N")3%jeXSGL'Li!3N"
X)3)$"5%")4ci!5%H1`6!(5%Fb"dje*!!Q!H+)iSQbKf,iJ-(!Kc)$`X!Z!dK(cX"
X)4p+(C3L5JQ)%4)&1G90!B14q!&(i#PjCMbm'2`HTS#!IC`!!VLC!@Bm[#kQP*Km
XJ#bJ$8NI[4e*(1JGJ&PQ2,`Br"kQJ)"pR!!#)8NF'K!!!Irj9Mbm!UDB`(`J!!!9
XQh&$i#Pl24CT(CK`J!k"!,`ZTSL!6C`!!@Lm,UC)S8b",S#P`!8je)!5K(L!)C`!
X!3LK),`ZTSL!6C`!!0L",)!0J'&Q2,`Br"kQJ)"pR!!!L8NFJ3#!m!!"rrLm))&!
XL60R!S#kTSe(0rpUCa#C-F!&1G5",5N9Q"+!M6R@J(dje-MbTm%2kqXC1ZJ"S-Mb
XTmN2kqbK1ZJ"F-MbTmd2kqaa1ZJ"3-MbTp%2kq`K1qJ"%,`JJE`!),fJ!!J!))(J
X#TR!-d*!!X,J#UQBN6VS!C$)mUI"1ZJ"%-MbTmNkk!$`b2+Rc6VS!0$)mUI41ZJ!
XX)&p1G6!"S8BN5(!-5RJ#MQS%T4jJ!U%H-!'J4c$m6VNJb6$m6[NJbNje-!'K4L*
XS!!LJ(c!")%QJ4dje!*!%6R8J1[riC`3J3%+3!%je!!!"!*!$0IS!!$6k!!!"QJ!
XNEb!$8!#3!a`"NJ!15%&65!#3!hTD6dj&!*!$KNY*6N3!N!159da23`#3!jj*6N4
XB!*!$UN024%8!!`#f4%&833#3!qC69&*6!*!$mN4548`!N!2q8eP08`!!!3T$6NC
X(!!!"&P0*@N8!!!%L3e*&6!!"!5j%3P9(!!%"4PK6@8d!!3&H!!%!N!FQl%`!!2r
Xr!!!(IJ!Ql0J!!2rr!!!$p!!QlG!!!2rr!!!(A!!Ql(3!!2rr!!!VJJ!QlD`!!2r
Xr!!!&AJ!QlI`!!rrr!!!&`J#3"36rr`!!"FS!N!8"rrm8!#h'!#EYi!!!rrm!!!A
X5!#EXh!!!rrm!!!A@!#EXY!!!rrm!!!AD!#EYe!!!rrm!!!AH!#EXe!!#rrm!!!G
X`!#EXl2rr!!B!!!93!#EYj!!$rrm!!!AL!*!&"2rr!!!&jJ#3"32rr`!!"HS!N!8
X%rrm!!!AZ!*!&!rrr!!!&mJ#3"36rr`!!"IB!N!3&E@YKD'`"-N@Q!:
END_OF_FILE
if test 17003 -ne `wc -c <'mac/MD.proj.hqx'`; then
    echo shar: \"'mac/MD.proj.hqx'\" unpacked with wrong size!
fi
# end of 'mac/MD.proj.hqx'
fi
if test -f 'src/objnam.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/objnam.c'\"
else
echo shar: Extracting \"'src/objnam.c'\" \(39021 characters\)
sed "s/^X//" >'src/objnam.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)objnam.c	3.0	89/11/15
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include	"hack.h"
X#ifdef TUTTI_FRUTTI
X#include <ctype.h>	/* for isalpha() */
X#endif
X
X/* "an uncursed partly eaten guardian naga hatchling corpse" */
X#define	PREFIX	50
X#define SCHAR_MAX 127
X
X#ifndef OVLB
X
XSTATIC_DCL const char *keystr[N_LOX], *lockstr[N_LOX];
X
X#else /* OVLB */
X/*	We want the player to be able to learn what key goes in what lock.  */
XSTATIC_OVL const char NEARDATA *keystr[N_LOX] = { "round", "square", "triangular", "oval",
X			              "octagonal", "hexagonal", "cylindrical",
X			              "irregular", "conical", "wedge-shaped" },
X	         NEARDATA *lockstr[N_LOX] = { "round", "square", "triangular", "oval",
X			              "octagonal", "hexagonal", "wide",
X			              "notched", "large round", "large square" };
X#endif /* OVLB */
X
XSTATIC_DCL int FDECL(named_key,(const char *));
XSTATIC_DCL int FDECL(named_box,(const char *));
XSTATIC_DCL char *FDECL(strprepend,(char *,const char *));
X
X#ifdef OVL1
Xstatic char *FDECL(sitoa,(int));
X#endif /* OVL1 */
X
Xstruct Jitem {
X	int item;
X	const char *name;
X};
X
X#ifndef OVLB
X
XSTATIC_DCL struct Jitem Japanese_items[];
X
X#else /* OVLB */
X
XSTATIC_OVL struct Jitem Japanese_items[] = {
X	{ SHORT_SWORD, "wakizashi" },
X	{ BROADSWORD, "ninja-to" },
X	{ GLAIVE, "naginata" },
X	/* { BOW, "yumi" }, */
X	{ LOCK_PICK, "osaku" },
X	{0, "" }
X};
X
X#endif /* OVLB */
X
XSTATIC_DCL const char *FDECL(Japanese_item_name,(int));
X
X#ifdef OVL1
X
XSTATIC_OVL int
Xnamed_key(s) register const char *s; {
X	char tc[BUFSZ];
X	register int i;
X
X	for(i=0; i<10; i++) {
X		Strcpy(tc, keystr[i]);
X		Strcat(tc, " key");
X		if(!strcmp(s,tc)) return(i+1);
X	}
X	return(0);
X}
X
XSTATIC_OVL int
Xnamed_box(s)
Xregister const char *s;
X{
X	char tc[BUFSZ];
X	register int i;
X
X	for(i=0; i<10; i++) {
X		Strcpy(tc, lockstr[i]);
X		Strcat(tc, " keyhole)");
X		if(!strcmp(s,tc)) return(i+1);
X	}
X	return(0);
X}
X
XSTATIC_OVL char *
Xstrprepend(s,pref)
Xregister char *s;
Xregister const char *pref; {
Xregister int i = strlen(pref);
X	if(i > PREFIX) {
X		pline("WARNING: prefix too short.");
X		return(s);
X	}
X	s -= i;
X	(void) strncpy(s, pref, i);	/* do not copy trailing 0 */
X	return(s);
X}
X
Xstatic char *
Xsitoa(a) int a; {
X#ifdef LINT	/* static char buf[13]; */
X	char buf[13];
X#else
X	static char NEARDATA buf[13];
X#endif
X	Sprintf(buf, (a < 0) ? "%d" : "+%d", a);
X	return(buf);
X}
X
X#endif /* OVL1 */
X#ifdef OVLB
X
Xchar *
Xtypename(otyp)
Xregister int otyp;
X{
X#ifdef LINT	/* static char buf[BUFSZ]; */
Xchar buf[BUFSZ];
X#else
Xstatic char NEARDATA buf[BUFSZ];
X#endif
Xregister struct objclass *ocl = &objects[otyp];
Xregister const char *actualn = ocl->oc_name;
Xregister const char *dn = ocl->oc_descr;
Xregister const char *un = ocl->oc_uname;
Xregister int nn = ocl->oc_name_known;
X
X	if (pl_character[0] == 'S' && Japanese_item_name(otyp))
X		actualn = Japanese_item_name(otyp);
X	switch(ocl->oc_olet) {
X	case POTION_SYM:
X		Strcpy(buf, "potion");
X		break;
X	case SCROLL_SYM:
X		Strcpy(buf, "scroll");
X		break;
X	case WAND_SYM:
X		Strcpy(buf, "wand");
X		break;
X#ifdef SPELLS
X	case SPBOOK_SYM:
X		Strcpy(buf, "spellbook");
X		break;
X#endif
X	case RING_SYM:
X		Strcpy(buf, "ring");
X		break;
X	case AMULET_SYM:
X		if(nn)
X			Strcpy(buf,actualn);
X		else
X			Strcpy(buf,"amulet");
X		if(un)
X			Sprintf(eos(buf)," called %s",un);
X		if(dn)
X			Sprintf(eos(buf)," (%s)",dn);
X		return(buf);
X	default:
X		if(nn) {
X			Strcpy(buf, actualn);
X			if(otyp >= TURQUOISE && otyp <= JADE)
X				Strcat(buf, " stone");
X			if(un)
X				Sprintf(eos(buf), " called %s", un);
X			if(dn)
X				Sprintf(eos(buf), " (%s)", dn);
X		} else {
X			Strcpy(buf, dn ? dn : actualn);
X			if(ocl->oc_olet == GEM_SYM) {
X				if (otyp == LOADSTONE || otyp == LUCKSTONE)
X					Strcat(buf, " stone");
X				else
X					Strcat(buf, " gem");
X			}
X			if(un)
X				Sprintf(eos(buf), " called %s", un);
X		}
X		return(buf);
X	}
X	/* here for ring/scroll/potion/wand */
X	if(nn)
X		Sprintf(eos(buf), " of %s", actualn);
X	if(un)
X		Sprintf(eos(buf), " called %s", un);
X	if(dn)
X		Sprintf(eos(buf), " (%s)", dn);
X	return(buf);
X}
X
X/* Give the name of an object seen at a distance.  Unlike xname/doname,
X * we don't want to set dknown if it's not set already.  The kludge used is
X * to temporarily set Blind so that xname() skips the dknown setting.  This
X * assumes that we don't want to do this too often; if this function becomes
X * frequently used, it'd probably be better to pass a parameter to xname()
X * or doname() instead.
X */
Xchar *
Xdistant_name(obj, func)
Xregister struct obj *obj;
Xchar *FDECL((*func), (struct obj *));
X{
X	char *str;
X
X	long save_Blinded = Blinded;
X	Blinded = 1;
X	str = (*func)(obj);
X	Blinded = save_Blinded;
X	return str;
X}
X
X#endif /* OVLB */
X#ifdef OVL1
X
Xchar *
Xxname(obj)
Xregister struct obj *obj;
X{
X#ifdef LINT	/* lint may handle static decl poorly -- static char bufr[]; */
Xchar bufr[BUFSZ];
X#else
Xstatic char bufr[BUFSZ];
X#endif
Xregister char *buf = &(bufr[PREFIX]);	/* leave room for "17 -3 " */
Xregister int nn = objects[obj->otyp].oc_name_known;
Xregister const char *actualn = objects[obj->otyp].oc_name;
Xregister const char *dn = objects[obj->otyp].oc_descr;
Xregister const char *un = objects[obj->otyp].oc_uname;
X
X	if (pl_character[0] == 'S' && Japanese_item_name((int)obj->otyp))
X		actualn = Japanese_item_name((int)obj->otyp);
X
X	buf[0] = 0;
X	if(!Blind) obj->dknown=1;
X	switch(obj->olet) {
X	    case AMULET_SYM:
X		if(obj->otyp == AMULET_OF_YENDOR) {
X		    Strcpy(buf, (obj->spe < 0 && obj->known) ?
X			   "cheap plastic imitation of the " : "");
X		    Strcat(buf, actualn);
X		} else if (!obj->dknown)
X			Strcpy(buf, "amulet");
X		else if (nn)
X			Strcpy(buf, actualn);
X		else if (un)
X			Sprintf(buf,"amulet called %s", un);
X		else
X			Sprintf(buf,"%s amulet", dn);
X		break;
X	    case WEAPON_SYM:
X		if(obj->otyp <= SHURIKEN && obj->opoisoned)
X			Strcpy(buf, "poisoned ");
X	    case VENOM_SYM:
X	    case TOOL_SYM:
X		if(un) {
X			/* un must come first here.  If it does not, they could
X			 * tell objects apart by seeing which ones refuse to
X			 * accept names.
X			 */
X			Sprintf(buf, "%s called %s",
X				nn ? actualn : dn, un);
X		} else if(nn)
X			Strcat(buf, actualn);
X		else
X			Strcat(buf, dn);
X		/* If we use an() here we'd have to remember never to use */
X		/* it whenever calling doname() or xname(). */
X		if(obj->otyp == FIGURINE)
X		    Sprintf(eos(buf), " of a%s %s",
X			index(vowels,*(mons[obj->corpsenm].mname)) ? "n" : "",
X			mons[obj->corpsenm].mname);
X		break;
X	    case ARMOR_SYM:
X		if(obj->otyp==DRAGON_SCALE_MAIL) {
X			Sprintf(buf, "%s scale mail",
X						mons[obj->corpsenm].mname);
X			break;
X		}
X
X		if(is_boots(obj) || is_gloves(obj)) Strcpy(buf,"pair of ");
X
X		if(nn)	Strcat(buf, actualn);
X		else if(un) {
X			if(is_boots(obj))
X				Strcat(buf,"boots");
X			else if(is_gloves(obj))
X				Strcat(buf,"gloves");
X			else if(is_cloak(obj))
X				Strcpy(buf,"cloak");
X			else if(is_helmet(obj))
X				Strcpy(buf,"helmet");
X			else if(is_shield(obj))
X				Strcpy(buf,"shield");
X			else
X				Strcpy(buf,"armor");
X			Strcat(buf, " called ");
X			Strcat(buf, un);
X		} else	Strcat(buf, dn);
X		break;
X	    case FOOD_SYM:
X#ifdef TUTTI_FRUTTI
X		if (obj->otyp == SLIME_MOLD) {
X			register struct fruit *f;
X
X			for(f=ffruit; f; f = f->nextf) {
X				if(f->fid == obj->spe) {
X					Strcpy(buf, f->fname);
X					break;
X				}
X			}
X			if (!f) impossible("Bad fruit #%d?", obj->spe);
X			break;
X		}
X#endif
X		Strcpy(buf, actualn);
X		if(obj->otyp == TIN && obj->known) {
X		    if(obj->spe > 0)
X			Strcat(buf, " of spinach");
X		    else if (mons[obj->corpsenm].mlet == S_FUNGUS)
X			Sprintf(eos(buf), " of %s", mons[obj->corpsenm].mname);
X		    else if(obj->corpsenm >= 0)
X			Sprintf(eos(buf), " of %s meat", mons[obj->corpsenm].mname);
X		    else Strcpy(buf, "empty tin");
X		}
X		break;
X	    case CHAIN_SYM:
X		Strcpy(buf, actualn);
X		break;
X	    case ROCK_SYM:
X		if(obj->otyp == STATUE)
X		    Sprintf(buf, "%s of a%s %s", actualn,
X			index(vowels,*(mons[obj->corpsenm].mname)) ? "n" : "",
X			mons[obj->corpsenm].mname);
X		else Strcpy(buf, actualn);
X		break;
X	    case BALL_SYM:
X		Sprintf(buf, "%sheavy iron ball",
X		  (obj->owt > objects[obj->otyp].oc_weight) ? "very " : "");
X		break;
X	    case POTION_SYM:
X		if(nn || un || !obj->dknown) {
X			Strcpy(buf, "potion");
X			if(!obj->dknown) break;
X			if(nn) {
X			    Strcat(buf, " of ");
X			    if(obj->otyp == POT_WATER &&
X			       objects[POT_WATER].oc_name_known &&
X			       (obj->bknown || pl_character[0] == 'P') &&
X			       (obj->blessed || obj->cursed)) {
X				Strcat(buf, obj->blessed ? "holy " : "unholy ");
X			    }
X			    Strcat(buf, actualn);
X			} else {
X				Strcat(buf, " called ");
X				Strcat(buf, un);
X			}
X		} else {
X			Strcpy(buf, dn);
X			Strcat(buf, " potion");
X		}
X		break;
X	case SCROLL_SYM:
X		Strcpy(buf, "scroll");
X		if(!obj->dknown) break;
X		if(nn) {
X			Strcat(buf, " of ");
X			Strcat(buf, actualn);
X		} else if(un) {
X			Strcat(buf, " called ");
X			Strcat(buf, un);
X		} else {
X			Strcat(buf, " labeled ");
X			Strcat(buf, dn);
X		}
X		break;
X	case WAND_SYM:
X		if(!obj->dknown)
X			Sprintf(buf, "wand");
X		else if(nn)
X			Sprintf(buf, "wand of %s", actualn);
X		else if(un)
X			Sprintf(buf, "wand called %s", un);
X		else
X			Sprintf(buf, "%s wand", dn);
X		break;
X#ifdef SPELLS
X	case SPBOOK_SYM:
X		if(!obj->dknown)
X			Sprintf(buf, "spellbook");
X		else if(nn)
X			Sprintf(buf, "spellbook of %s", actualn);
X		else if(un)
X			Sprintf(buf, "spellbook called %s", un);
X		else
X			Sprintf(buf, "%s spellbook", dn);
X		break;
X#endif
X	case RING_SYM:
X		if(!obj->dknown)
X			Sprintf(buf, "ring");
X		else if(nn)
X			Sprintf(buf, "ring of %s", actualn);
X		else if(un)
X			Sprintf(buf, "ring called %s", un);
X		else
X			Sprintf(buf, "%s ring", dn);
X		break;
X	case GEM_SYM:
X		if(!obj->dknown) {
X			if (obj->otyp == ROCK || obj->otyp == LOADSTONE
X					|| obj->otyp == LUCKSTONE)
X				Strcpy(buf, "stone");
X			else
X				Strcpy(buf, "gem");
X			break;
X		}
X		if(!nn) {
X			const char *rock=
X	(obj->otyp==LOADSTONE||obj->otyp==LUCKSTONE) ? "stone" : "gem";
X			if(un)	Sprintf(buf,"%s called %s", rock, un);
X			else	Sprintf(buf, "%s %s", dn, rock);
X			break;
X		}
X		Strcpy(buf, actualn);
X		if(obj->otyp >= TURQUOISE && obj->otyp <= JADE)
X			Strcat(buf, " stone");
X		break;
X	default:
X		Sprintf(buf,"glorkum %c (0%o) %u %d",
X			obj->olet,obj->olet,obj->otyp,obj->spe);
X	}
X	if(obj->quan != 1) Strcpy(buf, makeplural(buf));
X
X	if(obj->onamelth) {
X		Strcat(buf, " named ");
X		Strcat(buf, ONAME(obj));
X	}
X	return(buf);
X}
X
X#endif /* OVL1 */
X#ifdef OVL0
X
Xchar *
Xdoname(obj)
Xregister struct obj *obj;
X{
X	boolean ispoisoned = FALSE;
X	char prefix[PREFIX];
X	char tmpbuf[PREFIX+1];
X	/* when we have to add something at the start of prefix instead of the
X	 * end (Strcat is used on the end)
X	 */
X	register char *bp = xname(obj);
X	/* When using xname, we want "poisoned arrow", and when using
X	 * doname, we want "poisoned +0 arrow".  This kludge is about the only
X	 * way to do it, at least until someone overhauls xname() and doname(),
X	 * combining both into one function taking a parameter.
X	 */
X	if (!strncmp(bp, "poisoned ", 9)) {
X		bp += 9;
X		ispoisoned = TRUE;
X	}
X
X	if(obj->quan != 1)
X		Sprintf(prefix, "%u ", obj->quan);
X	else
X		Strcpy(prefix, "a ");
X	if((obj->bknown || pl_character[0] == 'P') &&
X	    (obj->otyp != POT_WATER || !objects[POT_WATER].oc_name_known
X		|| (!obj->cursed && !obj->blessed))) {
X	    /* allow 'blessed clear potion' if we don't know it's holy water;
X	     * always allow "uncursed potion of water"
X	     */
X	    if(obj->cursed)
X		Strcat(prefix, "cursed ");
X	    else if(obj->blessed)
X		Strcat(prefix, "blessed ");
X	    else if (((obj->olet != ARMOR_SYM
X			&& obj->olet != WAND_SYM
X			&& obj->olet != WEAPON_SYM
X			&& ((obj->olet != TOOL_SYM &&
X			     obj->olet != RING_SYM) ||
X			     !objects[obj->otyp].oc_charged))
X			    || !obj->known)
X		/* For items with charges or +/-, knowing the +/- means that
X		 * the item has been totally identified, and therefore there
X		 * is no doubt as to the object being uncursed if it's
X		 * not described as "blessed" or "cursed".
X		 *
X		 * If the +/- isn't known, "uncursed" must be printed to
X		 * avoid ambiguity between an item whose curse status is
X		 * unknown, and an item known to be uncursed.
X		 */
X#ifdef MAIL
X			&& obj->otyp != SCR_MAIL
X#endif
X			&& obj->otyp != AMULET_OF_YENDOR &&
X			pl_character[0] != 'P')
X		Strcat(prefix, "uncursed ");
X	}
X	switch(obj->olet) {
X	case AMULET_SYM:
X		if(obj->otyp == AMULET_OF_YENDOR)
X		    if(strncmp(bp, "cheap ", 6)) {
X			Strcpy(tmpbuf, "the ");
X			Strcat(tmpbuf, prefix+2); /* skip the "a " */
X			Strcpy(prefix, tmpbuf);
X		    }
X		if(obj->owornmask & W_AMUL)
X			Strcat(bp, " (being worn)");
X		break;
X	case WEAPON_SYM:
X		if(ispoisoned)
X			Strcat(prefix, "poisoned ");
Xplus:
X		if(obj->known) {
X			Strcat(prefix, sitoa(obj->spe));
X			Strcat(prefix, " ");
X		}
X		break;
X	case ARMOR_SYM:
X		if(obj->owornmask & W_ARMOR)
X			Strcat(bp, " (being worn)");
X		goto plus;
X	case TOOL_SYM:			/* temp. hack by GAN 11/18/86 */
X		if(obj->owornmask & W_TOOL) { /* blindfold */
X			Strcat(bp, " (being worn)");
X			break;
X		}
X#ifdef WALKIES
X		if(obj->otyp == LEASH && obj->leashmon != 0) {
X			Strcat(bp, " (in use)");
X			break;
X		}
X#endif
X		if(obj->otyp == KEY ||
X		   (obj->otyp == SKELETON_KEY &&
X		    !objects[obj->otyp].oc_name_known)) {
X			Strcat(prefix, keystr[obj->spe]);
X			Strcat(prefix, " ");
X			break;
X		}
X		if(obj->otyp == LARGE_BOX || obj->otyp == CHEST) {
X			Sprintf(eos(bp), " (%s keyhole)", lockstr[obj->spe]);
X			break;
X		}
X		if(obj->otyp == PICK_AXE || obj->otyp == UNICORN_HORN)
X			goto plus;
X		if(!objects[obj->otyp].oc_charged) break;
X		/* if special tool, fall through to show charges */
X	case WAND_SYM:
X		if(obj->known)
X			Sprintf(eos(bp), " (%d)", obj->spe);
X		break;
X	case RING_SYM:
X		if(obj->owornmask & W_RINGR) Strcat(bp, " (on right ");
X		if(obj->owornmask & W_RINGL) Strcat(bp, " (on left ");
X		if(obj->owornmask & W_RING) {
X		    Strcat(bp, body_part(HAND));
X		    Strcat(bp, ")");
X		}
X		if(obj->known && objects[obj->otyp].oc_charged) {
X			Strcat(prefix, sitoa(obj->spe));
X			Strcat(prefix, " ");
X		}
X		break;
X	case FOOD_SYM:
X		if(obj->oeaten)
X		    Strcat(prefix, "partly eaten ");
X		if(obj->otyp == CORPSE) {
X		    Strcat(prefix, mons[obj->corpsenm].mname);
X		    Strcat(prefix, " ");
X		} else if(obj->otyp == EGG && obj->known) {
X		    if(obj->corpsenm >= 0) {
X			Strcat(prefix, mons[obj->corpsenm].mname);
X			Strcat(prefix, " ");
X#ifdef POLYSELF
X			if (obj->spe)
X			    Strcat(bp, " (laid by you)");
X#endif
X		    }
X		}
X		break;
X	case BALL_SYM:
X		if(obj->owornmask & W_BALL)
X			Strcat(bp, " (chained to you)");
X			break;
X	}
X
X	if((obj->owornmask & W_WEP) && !mrg_to_wielded) {
X		if (obj->quan != 1)
X			Strcat(bp, " (wielded)");
X		else {
X			Strcat(bp, " (weapon in ");
X			Strcat(bp, body_part(HAND));
X			Strcat(bp, ")");
X		}
X	}
X	if(obj->unpaid)
X		Strcat(bp, " (unpaid)");
X	if (!strncmp(prefix, "a ", 2) &&
X			index(vowels, *(prefix+2) ? *(prefix+2) : *bp)
X			&& (*(prefix+2) || (strncmp(bp, "uranium", 7)
X				&& strncmp(bp, "unicorn", 7)))) {
X		Strcpy(tmpbuf, prefix);
X		Strcpy(prefix, "an ");
X		Strcpy(prefix+3, tmpbuf+2);
X	}
X	bp = strprepend(bp, prefix);
X	return(bp);
X}
X
X#endif /* OVL0 */
X#ifdef OVLB
X
X/*
X * Used if only one of a collection of objects is named (e.g. in eat.c).
X */
X
Xchar *
Xsingular(otmp, func)
Xregister struct obj *otmp;
Xchar *FDECL((*func), (struct obj *));
X{
X	unsigned savequan;
X	char *nam;
X
X	/* Note: using xname for corpses will not give the monster type */
X	if (otmp->otyp == CORPSE && func == xname) {
X		static char NEARDATA buf[31];
X
X		Sprintf(buf, "%s corpse", mons[otmp->corpsenm].mname);
X		return buf;
X	}
X	savequan = otmp->quan;
X	otmp->quan = 1;
X	nam = (*func)(otmp);
X	otmp->quan = savequan;
X	return nam;
X}
X
Xchar *
Xan(str)
Xregister const char *str;
X{
X	static char NEARDATA buf[BUFSZ];
X
X	buf[0] = '\0';
X
X	if (strncmp(str, "the ", 4))
X	    if (index(vowels, *str) &&
X		strncmp(str, "useful", 6) &&
X		strncmp(str, "unicorn", 7) &&
X		strncmp(str, "uranium", 7))
X		    Strcpy(buf, "an ");
X	    else
X		    Strcpy(buf, "a ");
X
X	Strcat(buf, str);
X	return buf;
X}
X
Xchar *
XAn(str)
Xconst char *str;
X{
X	register char *tmp;
X
X	tmp = an(str);
X	if (*tmp == 'a') *tmp = 'A';
X	return tmp;
X}
X
Xchar *
Xaobjnam(otmp,verb)
Xregister struct obj *otmp;
Xregister const char *verb;
X{
X	register char *bp = xname(otmp);
X	char prefix[PREFIX];
X
X	if(otmp->quan != 1) {
X		Sprintf(prefix, "%u ", otmp->quan);
X		bp = strprepend(bp, prefix);
X	}
X
X	if(verb) {
X		/* verb is given in plural (without trailing s) */
X		Strcat(bp, " ");
X		if(otmp->quan != 1)
X			Strcat(bp, verb);
X		else if(!strcmp(verb, "are"))
X			Strcat(bp, "is");
X		else {
X			Strcat(bp, verb);
X			Strcat(bp, "s");
X		}
X	}
X	return(bp);
X}
X
Xchar *
XDoname2(obj)
Xregister struct obj *obj;
X{
X	register char *s = doname(obj);
X
X	if('a' <= *s && *s <= 'z') *s -= ('a' - 'A');
X	return(s);
X}
X
Xconst char *wrp[] = { "wand", "ring", "potion", "scroll", "gem", "amulet",
X#ifdef SPELLS
X		"spellbook",
X#endif
X		/* for non-specific wishes */
X		"weapon", "armor", "tool", "food", "comestible",
X	      };
Xconst char wrpsym[] = {WAND_SYM, RING_SYM, POTION_SYM, SCROLL_SYM, GEM_SYM, AMULET_SYM,
X#ifdef SPELLS
X		 SPBOOK_SYM,
X#endif
X		 WEAPON_SYM, ARMOR_SYM, TOOL_SYM, FOOD_SYM, FOOD_SYM
X		};
X
Xvoid
Xlcase(str)
Xregister char *str;
X{
X	register char *p;
X	for (p = str; *p; p++)
X		if('A' <= *p && *p <= 'Z') *p += 'a'-'A';
X}
X
X#endif /* OVLB */
X#ifdef OVL0
X
X/* Plural routine; chiefly used for user-defined fruits.  We have to try to
X * account for everything reasonable the player has; something unreasonable
X * can still break the code.  However, it's still a lot more accurate than
X * "just add an s at the end", which Rogue uses...
X *
X * Also used for plural monster names ("Wiped out all homunculi.")
X * and body parts.
X */
Xchar *
Xmakeplural(oldstr)
Xconst char *oldstr;
X{
X	register char *spot;
X	static char NEARDATA str[BUFSZ];
X	const char *excess;
X	int len;
X
X	while (*oldstr==' ') oldstr++;
X	if (!oldstr || !*oldstr) {
X		impossible("plural of null?");
X		Strcpy(str, "s");
X		return str;
X	}
X	Strcpy(str, oldstr);
X
X	/* Search for common compounds, ex. lump of royal jelly */
X	for(excess=(char *)0, spot=str; *spot; spot++) {
X		if (!strncmp(spot, " of ", 4)
X				|| !strncmp(spot, " labeled ", 9)
X				|| !strncmp(spot, " called ", 8)
X				|| !strncmp(spot, " named ", 7)
X				|| !strcmp(spot, " above") /* lurkers above */
X				|| !strncmp(spot, " versus ", 8)
X#ifdef TUTTI_FRUTTI
X				|| !strncmp(spot, " from ", 6)
X				|| !strncmp(spot, " in ", 4)
X				|| !strncmp(spot, " on ", 4)
X				|| !strncmp(spot, " a la ", 6)
X				|| !strncmp(spot, " with", 5)
X				|| !strncmp(spot, " de ", 4)
X				|| !strncmp(spot, " d'", 3)
X				|| !strncmp(spot, " du ", 4)
X#endif
X				) {
X			excess = oldstr + (int) (spot - str);
X			*spot = 0;
X			break;
X		}
X	}
X	spot--;
X	while (*spot==' ') spot--; /* Strip blanks from end */
X	*(spot+1) = 0;
X	/* Now spot is the last character of the string */
X
X	len = strlen(str);
X#ifdef TUTTI_FRUTTI
X	/* Single letters */
X	if (len==1 || !isalpha(*spot)) {
X		Strcpy(spot+1, "'s");
X		goto bottom;
X	}
X#endif
X
X	/* man/men ("Wiped out all cavemen.") */
X	if (len >= 3 && !strcmp(spot-2, "man") &&
X			(len<6 || strcmp(spot-5, "shaman")) &&
X			(len<5 || strcmp(spot-4, "human"))) {
X		*(spot-1) = 'e';
X		goto bottom;
X	}
X
X	/* tooth/teeth */
X	if (len >= 5 && !strcmp(spot-4, "tooth")) {
X		Strcpy(spot-3, "eeth");
X		goto bottom;
X	}
X
X	/* knife/knives, etc... */
X	if (!strcmp(spot-1, "fe"))
X		*(spot-1) = 'v';
X	else if (*spot == 'f')
X		if (index("lr", *(spot-1)) || index(vowels, *(spot-1)))
X			*spot = 'v';
X		else if (!strncmp(spot-4, "staf", 4))
X			Strcpy(spot-1, "ve");
X
X	/* foot/feet (body part) */
X	if (len >= 4 && !strcmp(spot-3, "foot")) {
X		Strcpy(spot-2, "eet");
X		goto bottom;
X	}
X
X	/* ium/ia (mycelia, baluchitheria) */
X	if (len >= 3 && !strcmp(spot-2, "ium")) {
X		*(spot--) = (char)0;
X		*spot = 'a';
X		goto bottom;
X	}
X
X	/* algae, larvae, hyphae (another fungus part) */
X#ifdef TUTTI_FRUTTI
X	if ((len >= 4 && !strcmp(spot-3, "alga")) ||
X	    (len >= 5 &&
X	     (!strcmp(spot-4, "hypha") || !strcmp(spot-4, "larva")))) {
X#else
X	if (len >= 5 && (!strcmp(spot-4, "hypha"))) {
X#endif
X		Strcpy(spot, "ae");
X		goto bottom;
X	}
X
X	/* fungus/fungi, homunculus/homunculi, but wumpuses */
X	if (!strcmp(spot-1, "us") && strcmp(spot-5, "wumpus")) {
X		*(spot--) = (char)0;
X		*spot = 'i';
X		goto bottom;
X	}
X
X	/* vortex/vortices */
X	if (len >= 6 && !strcmp(spot-3, "rtex")) {
X		Strcpy(spot-1, "ices");
X		goto bottom;
X	}
X
X	/* djinni/djinn (note: also efreeti/efreet) */
X	if (len >= 6 && !strcmp(spot-5, "djinni")) {
X		*(spot--) = (char)0;
X		goto bottom;
X	}
X
X	/* same singular and plural */
X	/* note: also swine, trout, grouse */
X	if ((len >= 7 && !strcmp(spot-6, "samurai")) ||
X	    (len >= 5 &&
X#ifdef TUTTI_FRUTTI
X	     (!strcmp(spot-4, "manes") || !strcmp(spot-4, "sheep"))) ||
X	    (len >= 4 &&
X	     (!strcmp(spot-3, "fish") || !strcmp(spot-3, "tuna") ||
X	      !strcmp(spot-3, "deer"))))
X#else
X	     !strcmp(spot-4, "manes")))
X#endif
X		goto bottom;
X
X#ifdef TUTTI_FRUTTI
X	/* mouse/mice,louse/lice (not a monster, but possible in a food name) */
X	if (len >= 5 && !strcmp(spot-3, "ouse") && index("MmLl", *(spot-4))) {
X		Strcpy(spot-3, "ice");
X		goto bottom;
X	}
X
X	/* matzoh/matzot, possible food name */
X	if (len >= 6 && (!strcmp(spot-5, "matzoh")
X					|| !strcmp(spot-5, "matzah"))) {
X		Strcpy(spot-1, "ot");
X		goto bottom;
X	}
X	if (len >= 5 && (!strcmp(spot-4, "matzo")
X					|| !strcmp(spot-5, "matza"))) {
X		Strcpy(spot, "ot");
X		goto bottom;
X	}
X
X	/* child/children (for the wise guys who give their food funny names) */
X	if (len >= 5 && !strcmp(spot-4, "child")) {
X		Strcpy(spot, "dren");
X		goto bottom;
X	}
X
X	/* sis/ses (oasis, nemesis) */
X	if (len >= 3 && !strcmp(spot-2, "sis")) {
X		*(spot-1) = 'e';
X		goto bottom;
X	}
X
X	/* note: -eau/-eaux (gateau, bordeau...) */
X	/* note: ox/oxen, VAX/VAXen, goose/geese */
X#endif
X
X	/* Ends in z, x, s, ch, sh; add an "es" */
X	if (index("zxsv", *spot) || (*spot=='h' && index("cs", *(spot-1)))
X#ifdef TUTTI_FRUTTI
X	/* Kludge to get "tomatoes" and "potatoes" right */
X				|| (len >= 4 && !strcmp(spot-2, "ato"))
X#endif
X									) {
X		Strcpy(spot+1, "es");
X		goto bottom;
X	}
X
X	/* Ends in y preceded by consonant (note: also "qu"); change to "ies" */
X	if (*spot == 'y' &&
X	    (!index(vowels, *(spot-1)))) {
X		Strcpy(spot, "ies");
X		goto bottom;
X	}
X
X	/* Default: append an 's' */
X	Strcpy(spot+1, "s");
X
Xbottom:	if (excess) Strcpy(str+strlen(str), excess);
X	return str;
X}
X
X#endif /* OVL0 */
X
Xstruct o_range {
X	const char *name, osym;
X	int  f_o_range, l_o_range;
X};
X
X#ifndef OVLB
X
XSTATIC_DCL const struct o_range o_ranges[];
X
X#else /* OVLB */
X
X/* wishable subranges of objects */
XSTATIC_OVL const struct o_range NEARDATA o_ranges[] = {
X	{ "bag",	TOOL_SYM,   SACK,	    BAG_OF_TRICKS },
X	{ "gloves",	ARMOR_SYM,  LEATHER_GLOVES, GAUNTLETS_OF_DEXTERITY },
X	{ "gauntlets",	ARMOR_SYM,  LEATHER_GLOVES, GAUNTLETS_OF_DEXTERITY },
X	{ "boots",	ARMOR_SYM,  LOW_BOOTS,	    LEVITATION_BOOTS },
X	{ "shoes",	ARMOR_SYM,  LOW_BOOTS,	    IRON_SHOES },
X	{ "cloak",	ARMOR_SYM,  MUMMY_WRAPPING, CLOAK_OF_DISPLACEMENT },
X	{ "shield",	ARMOR_SYM,  SMALL_SHIELD,   SHIELD_OF_REFLECTION },
X#ifdef TOLKIEN	/* note: "helmet" is a specific item */
X	{ "helm",	ARMOR_SYM,  ELVEN_LEATHER_HELM, HELM_OF_TELEPATHY },
X#else
X	{ "helm",	ARMOR_SYM,  ORCISH_HELM,    HELM_OF_TELEPATHY },
X#endif
X	{ "sword",	WEAPON_SYM, SHORT_SWORD,    KATANA }
X};
X
X/*
X * Singularize a string the user typed in; this helps reduce the complexity
X * of readobjnam, and is also used in pager.c to singularize the string
X * for which help is sought.
X */
X
Xchar *
Xmakesingular(oldstr)
Xconst char *oldstr;
X{
X	char *p, *bp;
X	static char NEARDATA str[BUFSZ];
X
X	if (!oldstr || !*oldstr) {
X		impossible("singular of null?");
X		str[0] = 0; return str;
X	}
X	Strcpy(str, oldstr);
X	bp = str;
X
X	while (*bp == ' ') bp++;
X	/* find "cloves of garlic", "worthless pieces of blue glass" */
X	for(p = bp; *p; p++) 
X	    if(!strncmp(p, "s of ", 5)){
X		/* but don't singularize "gauntlets" */
X		if(strncmp(p-8, "gauntlet", 8))
X			while(*p = p[1]) p++;
X		return bp;
X	    }
X
X	/* remove -s or -es (boxes) or -ies (rubies) */
X	p = eos(bp);
X	if(p[-1] == 's') {
X		if(p[-2] == 'e') {
X			if(p[-3] == 'i') {
X				if(!strcmp(p-7, "cookies") ||
X				   !strcmp(p-4, "pies"))
X					goto mins;
X				Strcpy(p-3, "y");
X				return bp;
X			}
X
X			/* note: cloves / knives from clove / knife */
X			if(!strcmp(p-6, "knives")) {
X				Strcpy(p-3, "fe");
X				return bp;
X			}
X
X			if(!strcmp(p-6, "staves")) {
X				Strcpy(p-3, "ff");
X				return bp;
X			}
X
X			/* note: nurses, axes but boxes */
X			if(!strcmp(p-5, "boxes")) {
X				p[-2] = 0;
X				return bp;
X			}
X		}
X		/* but don't singularize boots or gloves */
X		else if(!strcmp(p-5, "boots") ||
X			!strcmp(p-6, "gloves"))
X				return bp;
X	mins:
X		p[-1] = 0;
X	} else {
X		if(!strcmp(p-5, "teeth")) {
X			Strcpy(p-5, "tooth");
X			return bp;
X		}
X		/* here we cannot find the plural suffix */
X	}
X	return bp;
X}
X
X/* Return something wished for.  If not an object, return &zeroobj; if an error
X * (no matching object), return (struct obj *)0.  Giving readobjnam() a null
X * pointer skips the error return and creates a random object instead.
X */
Xstruct obj *
Xreadobjnam(bp)
Xregister char *bp;
X{
X	register char *p;
X	register int i;
X	register struct obj *otmp;
X	int cnt, spe, spesgn, typ, heavy, blessed, uncursed, halfeaten;
X	int iscursed, ispoisoned, mntmp, contents;
X	int iskey, isnamedbox;
X#ifdef TUTTI_FRUTTI
X	struct fruit *f;
X	int ftype = current_fruit;
X	char fruitbuf[BUFSZ];
X	/* We want to check for fruits last so that, for example, someone
X	 * who names their fruit "katana" and wishes for a katana gets a real
X	 * one.  But, we have to keep around the old buf since in the meantime
X	 * we have deleted "empty", "+6", etc...
X	 */
X#endif
X	char let;
X	char *un, *dn, *actualn;
X	char *name=0;
X#ifdef WIZARD
X	int fake=0;
X#endif
X
X	cnt = spe = spesgn = typ = heavy = blessed = uncursed = iscursed =
X		ispoisoned = halfeaten = iskey = isnamedbox = 0;
X	mntmp = -1;
X#define UNDEFINED 0
X#define EMPTY 1
X#define SPINACH 2
X	contents = UNDEFINED;
X	let = 0;
X	actualn = dn = un = 0;
X	
X	for(;;) {
X		if (!bp) goto any;
X		if(!strncmp(bp, "an ", 3)) {
X			cnt = 1;
X			bp += 3;
X		} else if(!strncmp(bp, "a ", 2)) {
X			cnt = 1;
X			bp += 2;
X		} else if(!strncmp(bp, "cheap plastic imitation of ", 27)) {
X#ifdef WIZARD
X			fake = 1;
X#endif
X			bp += 27;
X		} else if(!strncmp(bp, "the ", 4)){
X	/*		the = 1; */
X			bp += 4;
X		} else if(!cnt && digit(*bp)){
X			cnt = atoi(bp);
X			while(digit(*bp)) bp++;
X			while(*bp == ' ') bp++;
X		} else if(!strncmp(bp, "partly eaten ", 13)) {
X			halfeaten = 1;
X			bp += 13;
X		} else if(!strncmp(bp,"blessed ",8)) {
X			blessed=1;
X			bp += 8;
X		} else if(!strncmp(bp,"holy ",5)) {
X			blessed=1;
X			bp += 5;
X		} else if(!strncmp(bp,"cursed ",7) || !strncmp(bp,"unholy ",7)){
X			iscursed=1;
X			bp += 7;
X		} else if(!strncmp(bp, "uncursed ",9)) {
X			uncursed=1;
X			bp += 9;
X		} else break;
X	}
X	if(!cnt) cnt = 1;		/* %% what with "gems" etc. ? */
X#ifdef TUTTI_FRUTTI
X	Strcpy(fruitbuf, bp);
X#endif
X	if(!strncmp(bp, "empty ", 6)) {
X		contents = EMPTY;
X		bp += 6;
X	} else if(!strncmp(bp, "poisoned ",9)) {
X		ispoisoned=1;
X		bp += 9;
X#ifdef WIZARD
X	} else if(wizard && !strncmp(bp, "trapped ",8)) {
X		ispoisoned=1;
X		bp += 8;
X#endif
X	}
X	if(*bp == '+' || *bp == '-'){
X		spesgn = (*bp++ == '+') ? 1 : -1;
X		spe = atoi(bp);
X		while(digit(*bp)) bp++;
X		while(*bp == ' ') bp++;
X	} else {
X		p = rindex(bp, '(');
X		if(p) {
X			if(p > bp && p[-1] == ' ') p[-1] = 0;
X			else *p = 0;
X			p++;
X			if (!(isnamedbox = named_box(p))) {
X				spe = atoi(p);
X				while(digit(*p)) p++;
X				if (*p != ')') spe = 0;
X				else {
X				    spesgn = 1;
X				    p++; 
X				    if (*p) Strcat(bp, p);
X				}
X			}
X		}
X	}
X/*
X   otmp->spe is type schar; so we don't want spe to be any bigger or smaller.
X   also, spe should always be positive  -- some cheaters may try to confuse
X   atoi()
X*/
X	if (spe < 0) {
X		spesgn = -1;	/* cheaters get what they deserve */
X		spe = abs(spe);
X	}
X	if (spe > SCHAR_MAX)
X		spe = SCHAR_MAX;
X
X	/* now we have the actual name, as delivered by xname, say
X		green potions called whisky
X		scrolls labeled "QWERTY"
X		egg
X		fortune cookies
X		very heavy iron ball named hoei
X		wand of wishing
X		elven cloak
X	*/
X	for(p = bp; *p; p++) if(!strncmp(p, " named ", 7)) {
X		*p = 0;
X		name = p+7;
X	}
X	for(p = bp; *p; p++) if(!strncmp(p, " called ", 8)) {
X		*p = 0;
X		un = p+8;
X		/* "helmet called telepathy" is not "helmet" (a specific type)
X		 * "shield called reflection" is not "shield" (a general type)
X		 */
X		for(i = 0; i < SIZE(o_ranges); i++)
X		    if(!strcmp(bp, o_ranges[i].name)) {
X			let = o_ranges[i].osym;
X			goto srch;
X		    }
X	}
X	for(p = bp; *p; p++) if(!strncmp(p, " labeled ", 9)) {
X		*p = 0;
X		dn = p+9;
X	}
X	for(p = bp; *p; p++) if(!strncmp(p, " labelled ", 10)) {
X		*p = 0;
X		dn = p+10;
X	}
X	for(p = bp; *p; p++) if(!strncmp(p, " of spinach", 11)) {
X		*p = 0;
X		contents = SPINACH;
X	}
X
X	/* Skip over "pair of ", then jump to the singular so we don't
X	   try to convert "gloves" or "boots". */
X	if(cnt == 1 && !strncmp(bp, "pair of ",8)) {
X		bp += 8;
X		cnt = 2;
X		goto sing;
X		/* cnt is ignored for armor and other non-stackable objects;
X		   DTRT for stackable objects */
X	} else if(cnt > 1 && !strncmp(bp, "pairs of ",9)) {
X		bp += 9;
X		cnt *= 2;
X	}
X
X	/* Find corpse type using "of" (figurine of an orc, tin of orc meat) */
X	for(p = bp; *p; p++)
X		if (!strncmp(p, " of ", 4) && (mntmp = name_to_mon(p+4)) >= 0) {
X			*p = 0;
X			break;
X	}
X	/* Find corpse type w/o "of" (red dragon scale mail, yeti corpse) */
X	if (strncmp(bp, "samurai sword", 13)) /* not the "samurai" monster! */
X	if (strncmp(bp, "wizard lock", 11)) /* not the "wizard" monster! */
X	if (strncmp(bp, "orcish", 6)) /* not the "orc" monster! */
X	if (mntmp < 0) if ((mntmp = name_to_mon(bp)) >= 0) {
X		bp += strlen(mons[mntmp].mname);
X		if (*bp==' ') bp++;
X	}
X
X	/* first change to singular if necessary */
X	if(cnt != 1 && *bp)
X		Strcpy(bp, makesingular(bp));
X
Xsing:
X	/* Maybe we need a special strcmp() which ignores capitalization and
X	 * dashes/spaces/underscores, so some of the below special cases would
X	 * be unnecessary.
X	 */
X	/* Alternate spellings (two-handed sword vs. two handed sword) */
X	if(!strcmp(bp, "two handed sword")) {
X		typ = TWO_HANDED_SWORD;
X		goto typfnd;
X	}
X	/* pick-axe vs. pick axe */
X	if(!strcmp(bp, "pick axe")) {
X		typ = PICK_AXE;
X		goto typfnd;
X	}
X	if(!strcmp(bp, "luck stone")){
X		typ = LUCKSTONE;
X		goto typfnd;
X	}
X	if(!strcmp(bp, "load stone")){
X		typ = LOADSTONE;
X		goto typfnd;
X	}
X	/* Alternate capitalizations (Amulet of Yendor, amulet of esp) */
X	if(!strcmp(bp, "amulet of Yendor")) {
X		typ = AMULET_OF_YENDOR;
X		goto typfnd;
X	}
X	if(!strcmp(bp, "amulet of ESP")) {
X		typ = AMULET_OF_ESP;
X		goto typfnd;
X	}
X	if(!strcmp(bp, "ring mail") ||	/* Note: ring mail is not a ring ! */
X	   !strcmp(bp, "leather armor") || /* Prevent falling to 'armor'. */
X	   !strcmp(bp, "studded leather armor")) {
X		let = ARMOR_SYM;
X		actualn = bp;
X		goto srch;
X	}
X	if(!strcmp(bp, "food ration")){
X		let = FOOD_SYM;
X		actualn = bp;
X		goto srch;
X	}
X	if((iskey = named_key(bp)) > 0) {
X		typ = KEY;
X		goto typfnd;
X	}
X	p = eos(bp);
X	if(!strcmp(p-10, "holy water")) {
X		typ = POT_WATER;
X		if (*(p-12) == 'u') iscursed = 1; /* unholy water */
X		else blessed = 1;
X		goto typfnd;
X	}
X#ifdef SHIRT
X	if (!strcmp(p-5, "shirt")) {
X		typ = HAWAIIAN_SHIRT;
X		goto typfnd;
X	}
X#endif
X	if (strlen(bp) == 1 && index(obj_symbols, *bp) && *bp != ILLOBJ_SYM) {
X		let = *bp;
X		goto any;
X	}
X	if(strncmp(bp, "enchant ", 8) &&
X	   strncmp(bp, "destroy ", 8) &&
X	   strncmp(bp, "food detection", 14))
X	/* allow wishes for "enchant weapon" and "food detection" */
X	for(i = 0; i < sizeof(wrpsym); i++) {
X		register int j = strlen(wrp[i]);
X		if(!strncmp(bp, wrp[i], j)){
X			let = wrpsym[i];
X			if(let != AMULET_SYM) {
X			    bp += j;
X			    if(!strncmp(bp, " of ", 4)) actualn = bp+4;
X			    /* else if(*bp) ?? */
X			} else
X			    actualn = bp;
X			goto srch;
X		}
X		if(!strcmp(p-j, wrp[i])){
X			let = wrpsym[i];
X			p -= j;
X			*p = 0;
X			if(p[-1] == ' ') p[-1] = 0;
X			dn = bp;
X			goto srch;
X		}
X	}
X	if(!strcmp(p-6, " stone")){
X		p[-6] = 0;
X		let = GEM_SYM;
X		dn = actualn = bp;
X		goto srch;
X	}
X	if(!strcmp(p-10, "gold piece") || !strcmp(p-7, "zorkmid") ||
X		   !strcmp(bp, "Zorkmid") ||
X		   !strcmp(bp, "gold") || !strcmp(bp, "money") || *bp == GOLD_SYM) {
X			if (cnt > 5000
X#ifdef WIZARD
X					&& !wizard
X#endif
X						) cnt=5000;
X		if (cnt < 1) cnt=1;
X		pline("%d gold piece%s.", cnt, plur((long)cnt));
X		u.ugold += cnt;
X		flags.botl=1;
X		return (&zeroobj);
X	}
X#ifdef WIZARD
X	/* Let wizards wish for traps --KAA */
X	if (wizard) {
X		int trap;
X		char *tname;
X
X		for (trap = NO_TRAP+1; trap < TRAPNUM; trap++) {
X			tname = index(traps[trap], ' ');
X			if (tname) {
X				if (!strncmp(tname+1, bp, strlen(tname+1))) {
X					(void) maketrap(u.ux, u.uy, trap);
X					pline("A%s.", traps[trap]);
X					if (Invisible) newsym(u.ux,u.uy);
X					return(&zeroobj);
X				}
X			}
X		}
X	}
X#endif
X	if(!strcmp(bp, "very heavy iron ball")) {
X		heavy = 1;
X		typ = HEAVY_IRON_BALL;
X		goto typfnd;
X	}
X	for (i = 0; i < SIZE(o_ranges); i++)
X	    if(!strcmp(bp, o_ranges[i].name)) {
X		typ = rnd_class(o_ranges[i].f_o_range, o_ranges[i].l_o_range);
X		goto typfnd;
X	    }
X
X	actualn = bp;
X	if (!dn) dn = actualn; /* ex. "black cap" */
Xsrch:
X	i = 1;
X	if(let) i = bases[letindex(let)];
X	while(i <= NROFOBJECTS && (!let || objects[i].oc_olet == let)){
X		register const char *zn;
X
X		if(actualn && (zn = objects[i].oc_name) && !strcmp(actualn, zn)) {
X			typ = i;
X			goto typfnd;
X		}
X		if(dn && (zn = objects[i].oc_descr) && !strcmp(dn, zn)) {
X			typ = i;
X			goto typfnd;
X		}
X		if(un && (zn = objects[i].oc_uname) && !strcmp(un, zn)) {
X			typ = i;
X			goto typfnd;
X		}
X		i++;
X	}
X	if (actualn) {
X		struct Jitem *j = Japanese_items;
X		while(j->item) {
X			if (actualn && !strcmp(actualn, j->name)) {
X				typ = j->item;
X				goto typfnd;
X			}
X			j++;
X		}
X	}
X#ifdef TUTTI_FRUTTI
X	for(f=ffruit; f; f = f->nextf) {
X		char *f1 = f->fname, *f2 = makeplural(f->fname);
X
X		if(!strncmp(fruitbuf, f1, strlen(f1)) ||
X					!strncmp(fruitbuf, f2, strlen(f2))) {
X			typ = SLIME_MOLD;
X			ftype = f->fid;
X			goto typfnd;
X		}
X	}
X#endif
X	if(!let) return((struct obj *)0);
Xany:
X	if(!let) let = wrpsym[rn2(sizeof(wrpsym))];
Xtypfnd:
X	if(typ) {
X		let = objects[typ].oc_olet;
X		otmp = mksobj(typ,FALSE);
X	} else {
X		otmp = mkobj(let,FALSE);
X		typ = otmp->otyp;
X	}
X
X	/* venom isn't really an object and can't be wished for; but allow
X	 * wizards to wish for it since it's faster than polymorphing and
X	 * spitting.
X	 */
X	if(otmp->olet==VENOM_SYM) {
X#ifdef WIZARD
X		if (!wizard) {
X#endif
X			free((genericptr_t) otmp);
X			return((struct obj *)0);
X#ifdef WIZARD
X		} else otmp->spe = 1;
X#endif
X	}
X	if(iskey) otmp->spe = (iskey-1);
X	if(isnamedbox && (otmp->otyp==LARGE_BOX || otmp->otyp==CHEST))
X		otmp->spe = (isnamedbox-1);
X
X	if(cnt > 0 && objects[typ].oc_merge && 
X#ifdef SPELLS
X	        let != SPBOOK_SYM &&
X#endif
X		(cnt < rnd(6) ||
X#ifdef WIZARD
X		wizard ||
X#endif
X		 (cnt <= 20 &&
X		  ((let == WEAPON_SYM && typ <= SHURIKEN) || (typ == ROCK)))))
X			otmp->quan = cnt;
X
X	if (spesgn == 0) spe = otmp->spe;
X#ifdef WIZARD
X	else if (wizard) /* no alteration to spe */ ;
X#endif
X	else if (let == ARMOR_SYM || let == WEAPON_SYM || typ == PICK_AXE ||
X			typ == UNICORN_HORN ||
X			(let==RING_SYM && objects[typ].oc_charged)) {
X		if(spe > rnd(5) && spe > otmp->spe) spe = 0;
X		if(spe > 2 && Luck < 0) spesgn = -1;
X	} else {
X		if (let == WAND_SYM) {
X			if (spe > 1 && spesgn == -1) spe = 1;
X		} else {
X			if (spe > 0 && spesgn == -1) spe = 0;
X		}
X		if (spe > otmp->spe) spe = otmp->spe;
X	}
X
X	if (spesgn == -1) spe = -spe;
X
X	/* set otmp->spe.  This may, or may not, use spe... */
X	switch (typ) {
X		case TIN: if (contents==EMPTY) {
X				otmp->corpsenm = -1;
X				otmp->spe = 0;
X			} else if (contents==SPINACH) {
X				otmp->corpsenm = -1;
X				otmp->spe = 1;
X			}
X			break;
X#ifdef TUTTI_FRUTTI
X		case SLIME_MOLD: otmp->spe = ftype;
X			/* Fall through */
X#endif
X		case SKELETON_KEY: case KEY: case CHEST: case LARGE_BOX:
X		case HEAVY_IRON_BALL: case IRON_CHAIN: case STATUE:
X			/* otmp->spe already done in mksobj() */
X				break;
X#ifdef MAIL
X		case SCR_MAIL: otmp->spe = 1; break;
X#endif
X		case AMULET_OF_YENDOR:
X#ifdef WIZARD
X			if (fake || !wizard)
X#endif
X				otmp->spe = -1;
X#ifdef WIZARD
X			else otmp->spe = 0;
X#endif
X			break;
X		case WAN_WISHING:
X#ifdef WIZARD
X			if (!wizard) {
X#endif
X				otmp->spe = (rn2(10) ? -1 : 0);
X				break;
X#ifdef WIZARD
X			}
X			/* fall through (twice), if wizard */
X#endif
X		case MAGIC_LAMP:
X#ifdef WIZARD
X			if (!wizard) {
X#endif
X				otmp->spe = 0;
X				break;
X#ifdef WIZARD
X			}
X			/* fall through, if wizard */
X#endif
X		default: otmp->spe = spe;
X	}
X
X	/* set otmp->corpsenm */
X	if (mntmp > -1) switch(typ) {
X		case TIN:
X			otmp->spe = 0; /* No spinach */
X		case CORPSE:
X			if (!(mons[mntmp].geno & G_NOCORPSE))
X				otmp->corpsenm = mntmp;
X			break;
X		case FIGURINE:
X			if (!(mons[mntmp].geno & G_UNIQ)
X			    && !is_human(&mons[mntmp]))
X				otmp->corpsenm = mntmp;
X			break;
X		case EGG: if (lays_eggs(&mons[mntmp]) || mntmp==PM_KILLER_BEE)
X				otmp->corpsenm = mntmp;
X			break;
X		case STATUE: otmp->corpsenm = mntmp;
X			break;
X		case DRAGON_SCALE_MAIL: /* Not actually possible unless they
X				   typed "red dragon dragon scale mail" */
X		case SCALE_MAIL:
X			if (mntmp >= PM_GRAY_DRAGON &&
X			    mntmp <= PM_YELLOW_DRAGON)
X				otmp->corpsenm = mntmp;
X			if (otmp->corpsenm >= 0)
X				otmp->otyp = DRAGON_SCALE_MAIL;
X			break;
X	}
X
X	/* set blessed/cursed */
X	if (iscursed) {
X		curse(otmp);
X	} else if (uncursed) {
X		otmp->blessed = 0;
X		otmp->cursed = (Luck < 0
X#ifdef WIZARD
X					 && !wizard
X#endif
X							);
X	} else if (blessed) {
X		otmp->blessed = (Luck >= 0
X#ifdef WIZARD
X					 || wizard
X#endif
X							);
X		otmp->cursed = (Luck < 0
X#ifdef WIZARD
X					 && !wizard
X#endif
X							);
X	} else if (spesgn < 0) {
X		curse(otmp);
X	}
X
X	/* prevent wishing abuse */
X	if (
X#ifdef WIZARD
X		!wizard &&
X#endif
X		(otmp->otyp == WAN_WISHING || otmp->otyp == MAGIC_LAMP))
X		otmp->recharged = 1;
X
X	/* set poisoned */
X	if (ispoisoned) {
X	    if (let == WEAPON_SYM && typ <= SHURIKEN)
X		otmp->opoisoned = (Luck >= 0);
X#ifdef WIZARD
X	    else if (Is_box(otmp))
X		otmp->otrapped = 1;
X	    else if (let == FOOD_SYM)
X		/* try to taint by making it as old as possible */
X	    	otmp->age = 1L;
X#endif
X	}
X
X	if (name) otmp = oname(otmp, name, 0);
X	otmp->owt = weight(otmp);
X	if (heavy) otmp->owt += 15;
X	if (halfeaten && otmp->olet == FOOD_SYM) {
X		if (otmp->otyp == CORPSE)
X			otmp->oeaten = mons[otmp->corpsenm].cnutrit;
X		else otmp->oeaten = objects[otmp->otyp].nutrition;
X		otmp->owt /= 2;
X		otmp->oeaten /= 2;
X		if (!otmp->owt) otmp->owt = 1;
X		if (!otmp->oeaten) otmp->oeaten = 1;
X	}
X	return(otmp);
X}
X
Xint
Xrnd_class(first,last)
Xint first,last;
X{
X	int i, x, sum=0;
X	for(i=first; i<=last; i++)
X		sum += objects[i].oc_prob;
X	x = rnd(sum);
X	for(i=first; i<=last; i++)
X		if (objects[i].oc_prob && (x -= objects[i].oc_prob) <= 0)
X			return i;
X	return 0;
X}
X
XSTATIC_OVL const char *
XJapanese_item_name(i)
Xint i;
X{
X	struct Jitem *j = Japanese_items;
X
X	while(j->item) {
X		if (i == j->item)
X			return j->name;
X		j++;
X	}
X	return (const char *)0;
X}
X#endif /* OVLB */
END_OF_FILE
if test 39021 -ne `wc -c <'src/objnam.c'`; then
    echo shar: \"'src/objnam.c'\" unpacked with wrong size!
fi
# end of 'src/objnam.c'
fi
echo shar: End of archive 13 \(of 56\).
cp /dev/null ark13isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 56 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
