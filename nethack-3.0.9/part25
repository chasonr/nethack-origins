Path: utzoo!attcan!uunet!clyde.concordia.ca!news-server.csri.toronto.edu!cs.utexas.edu!rice!uw-beaver!zephyr.ens.tek.com!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v10i070:  nethack3p9 -  display oriented dungeons & dragons (Ver. 3.0i), Part25/56
Message-ID: <5928@tekred.CNA.TEK.COM>
Date: 12 Jul 90 16:02:26 GMT
Sender: news@tekred.CNA.TEK.COM
Lines: 1934
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 10, Issue 70
Archive-name: nethack3p9/Part25
Supersedes: NetHack3: Volume 7, Issue 56-93



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 25 (of 56)."
# Contents:  auxil/tmac.n others/lev_lex.c
# Wrapped by billr@saab on Wed Jul 11 17:11:28 1990
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'auxil/tmac.n' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'auxil/tmac.n'\"
else
echo shar: Extracting \"'auxil/tmac.n'\" \(25078 characters\)
sed "s/^X//" >'auxil/tmac.n' <<'END_OF_FILE'
X\" @(#)$Id: tmac.n,v 2.6 89/04/19 10:39:59 syd Exp $
X.\" The News macro package
X.\"
X.\" This  is  the macro package that is used to format news documents.  It
X.\" was written because many sites do not have one of the -mm or -ms pack-
X.\" ages that the documents use.   This is NOT compatible with EITHER, but
X.\" (I hope) will become the standard for all news  documents  (man  pages
X.\" excepted, since everyone seems to have -man.)
X.\"
X.\" This package was written using  only  the  "NROFF/TROFF Users' Guide",
X.\" and  therefore  if  you  can run NROFF/TROFF, you can legitimately use
X.\" this package.  However, because NROFF/TROFF are proprietary  programs,
X.\" I  cannot  place  this  package in the public domain.  This should not
X.\" matter, because if you legitimately have  NROFF/TROFF,  you  have  the
X.\" documentation; if not, you can't run off the documentation anyway.
X.\"
X.\" This  package may be circulated freely with the news documentation; it
X.\" may not be sold, but is to be distributed with  the  unformatted  news
X.\" documents.  However,  the name of the author and the place at which it
X.\" was written (in the author's own  time,  of  course)  are  not  to  be
X.\" removed  from the package regardless of how it is modified or altered.
X.\" Further, please do not distribute this package if you make any changes
X.\" because  I  don't want to get bug reports of macros I haven't written;
X.\" if you have a goodie you want me to add, send it to me and we'll talk.
X.\" (I really do like feedback!)  I'd really appreciate your cooperation.
X.\"
X.\" Author:	Matt Bishop
X.\"		Research Institute for Advanced Computer Science
X.\"		Mail Stop 230-5
X.\" 		NASA Ames Research Center
X.\"		Moffett Field, CA  94035
X.\"
X.\" version 1.0		September 28, 1985	mab@riacs.arpa
X.\" 	initial version
X.\" version 1.1		October 25, 1985	mab@riacs.arpa
X.\"	fixed an incredibly obscure footnote bug (that occurred twice in
X.\"	the news documentation!) which put footnoted words on  one  page
X.\"	and the footnote on the next if the word was in the next-to-last
X.\"	or last line; commented it, and generally cleaned up
X.\" Version 1.2		October 27, 1985	mab@riacs.arpa
X.\"	Added a few more comments and a check to keep footnotes lined up
X.\"	with the bottom margin.
X.\" Version 1.3		February 12, 1986	mab@riacs.arpa
X.\"	Added an error check to catch unmatched ef's and ed's
X.\" Version 1.4		December 29, 1986	mab@riacs.edu
X.\"	Changed footnote for ux, pd, and vx macros and  added  a  string
X.\"	for rg ("Registered Trademark")
X.\" Version 1.5		January 2, 1989		Matt.Bishop@dartmouth.edu
X.\"	Minor modifications for nroff compatibility
X.\" Version 1.6		March 15, 1989		Matt.Bishop@dartmouth.edu
X.\"						..!bear.dartmouth.edu!bishop
X.\"	Fixed a bug in footnote handling (again, sigh ...)  This one
X.\"	occurred when the the "fo" trap position was reset just beneath
X.\"	the current line; the footnote overflow trap would kick in and
X.\"	never be closed.
X.\"
X.\"
X.\" **********
X.\" these preserve and restore various things
X.\" they are used to shorten other macros
X.de yf					\" restore fonts
X.ft \\n(f2				\" previous font
X.ft \\n(f1				\" current font
X..
X.de yi					\" restore indents
X'in \\n(i2u				\" previous indent
X'in \\n(i1u				\" current indent
X..
X.de ys					\" restore point sizes
X.ps \\n(s2				\" previous point size
X.ps \\n(s1				\" current point size
X..
X.de yv					\" restore vertical spacings
X.vs \\n(v2u				\" previous vertical spacing
X.vs \\n(v1u				\" current vertical spacing
X..
X.de ya					\" restore everything
X.yf					\" restore fonts
X.yi					\" restore indents
X.ys					\" restore point sizes
X.yv					\" restore vertical spacing
X..
X.de zf					\" preserve fonts
X.nr f1 \\n(.f				\" current font
X.ft					\" switch to previous font
X.nr f2 \\n(.f				\" previous font
X.ft					\" back to current font
X..
X.de zi					\" preserve indents
X.nr i1 \\n(.iu				\" current indent
X'in					\" switch to previous indent
X.nr i2 \\n(.iu				\" previous indent
X'in					\" back to current indent
X..
X.de zs					\" preserve point sizes
X.nr s1 \\n(.su				\" current point size
X.ps					\" switch to previous point size
X.nr s2 \\n(.su				\" previous point size
X.ps					\" back to current point size
X..
X.de zv					\" preserve vertical spacings
X.nr v1 \\n(.vu				\" current vertical spacing
X.vs					\" switch to previous vertical spacing
X.nr v2 \\n(.vu				\" previous vertical spacing
X.vs					\" back to current vertical spacing
X..
X.de za					\" save everything
X.zf					\" save fonts
X.zi					\" save indents
X.zs					\" save point sizes
X.zv					\" save vertical spacings
X..
X.\" **********
X.\" these actually print the header and footer titles
X.\" they are defined separately from the "hd" and "fo" macros
X.\" to make user redefinition easy
X.de pt					\" print header title
X.					\" omit header on first page
X.if \\n%>1 \{\
X'	sp |\\$1u			\" move to proper position
X.	ft 1				\" change to default font
X.	ps \\n(ps			\" change to default point size
X.	vs \\n(vs			\" change to default spacing
X.	tl '\\*(h0'\\*(h1'\\*(h2'	\" center title
X.	vs				\" restore current vertical spacing
X.	ps				\" restore current point size
X.	ft				\" restore current font
X.\}
X..
X.de pf					\" print footer title
X.ft 1					\" change to default font
X.ps \\n(ps				\" change to default point size
X.vs \\n(vs				\" change to default spacing
X.ie \\n%=1 .tl '\\*(h0'\\*(h1'\\*(h2'	\" on first page, print the header here
X.el        .tl '\\*(f0'\\*(f1'\\*(f2'	\" on other pages, print the footer
X.vs					\" restore current vertical spacing
X.ps					\" restore current point size
X.ft					\" restore current font
X..
X.\" **********
X.\" these are the top of page (header) and bottom of page (footer) macros
X.\" they don't actually print anything, just call the right macros
X.de hd					\" header -- do top of page processing
X.if t .if \\n(cm .tl '\(rn'''		\" drop cut mark if needed
X.pt \\n(ttu				\" print header
X.nr fc 0 1				\" init footnote count
X.nr fs \\n(.pu-\\n(bmu-1u		\" if any footnotes, start print here
X.nr fp 0-\\n(bmu			\" reset current footer place
X.ch fo -\\n(bmu				\" reset footer trap
X.if \\n(dn .fz				\" put leftover footnotes st bottom
X.ya					\" restore font, etc.
X'sp |\\n(tmu				\" move to top of body
X.ns					\" don't allow any more space
X..
X.de fo					\" footer -- do bottom of page processing
X.za					\" save font, etc.
X.rs					\" you want motions here
X.nr dn 0				\" clobber diversion size register
X.if \\n(fc .fd				\" now print the footnotes, if any
X'bp					\" force out page
X..
X.\" **********
X.\" these are the footnote macros
X.\" here's an overview:
X.\"	Footnotes are processed in environment #1, which is  initialized
X.\"	at the bottom of this package.  When "fn" is called, nroff/troff
X.\"	switches to this environment.  The body of the footnote is saved
X.\"	in  the  diversion  "tf" (for "temporary footnote"), so you will
X.\"	NEVER spring a trap during the first reading of a footnote. When
X.\"	"ef" ("end footnote") is called,  the diversion  is  closed.  If
X.\"	this  is the first footnote on the page (ie, the number register
X.\"	"fc" is 1), and the footnote height (plus the height of 1  line)
X.\"	crosses  the  bottom  margin,  you get the footnoted word on one
X.\"	page and the footnote on the other.  In this case we  just  call
X.\"	"fo"  manually  (taking case it cannot be re-invoked on the same
X.\"	page!)  If this situation does not occur,  we  just  adjust  the
X.\"	footer  trap's  position upwards (we'll get to how far in a min-
X.\"	ute); if this puts the trap above the current line,  we  reposi-
X.\"	tion  the trap just beneath the current line to be sure of trig-
X.\"	triggering it once the current line is forced out.
X.\"	 To reposition the footer trap, we proceed as  follows.  Because
X.\"	the  trap  may be sprung in the middle of a line, it is possible
X.\"	that the footnote will not fit on the page (regardless of  where
X.\"	on the page the footnoted word occurs -- really!) if we move the
X.\"	trap up by the size of  the  footnote  diversion  "tf".  So,  we
X.\"	fudge things a little bit -- for the first footnote on each page
X.\"	we move the footer trap up 1 extra line ("line" being 1v in env-
X.\"	ironment  #0).   Unless  the point size and vertical spacing are
X.\"	increased between the first footnote and the footer trap's being
X.\"	sprung,  this  will  keep  the footnotes on the same page as the
X.\"	footnoted word.  But as there may be now as much as 1v of  space
X.\"	between the footnote and the bottom margin, which looks HIDEOUS,
X.\"	we use the number register "fs" to mark where  the  footer  trap
X.\"	would  REALLY go, and just space to it when it comes time to put
X.\"	out the footnotes.
X.de fd					\" dump footnotes
X.nr gs 1v				\" get a measure of 1 line in env #0
X.ev 1					\" switch to footnote environment
X.nr gs +2v				\" min of 2 lines of footnotes
X.					\" if the number register ns > 0,
X.					\" the last text line may contain a
X.					\" footnote that is too big to fit;
X.					\" this checks for such a note and
X.					\" if so, forces the footnote into
X.					\" the "fy" diversion that carries
X.					\" it onto the next text page
X.ie (\\n(nsu>0)&(\\n(gsu>=\\n(.tu) 'sp \\n(gsu	\" be sure you can get it down
X.el .if \\n(fsu>\\n(nlu 'sp \\n(fsu-\\n(nlu	\" move to footnote start position
X'nf					\" don't reprocess footnotes
X'in 0					\" don't indent them any more either
X.tf					\" drop text of footnotes
X.rm tf
X.if '\\n(.z'fy' .di			\" end overflow diversion, if any
X.nr fc 0				\" re-init footnote count
X.ev					\" return to usual environment
X..
X.de fn					\" start footnote
X.					\" look for nested footnotes -- ILLEGAL
X.ie \\n(if>0 .er "footnote within footnote"
X.el .da tf				\" append footnote to footnote diversion
X.nr if +1				\" increment level of footnoting
X.nr fc +1				\" one more footnote on this page
X.if \\n(fc=1 .nr fp -1v			\" The reason for this "fudge factor"
X.					\" is that there is no way to force
X.					\" NROFF/TROFF to invoke a macro at
X.					\" the end of each line.  At times,
X.					\" the trap boundary will not match up
X.					\" with the bottom of a line, so the
X.					\" "fo" trap which is set at 2320 may
X.					\" not be triggered until 2340 -- and
X.					\" then the footnote won't fit.  This
X.					\" gives some slack so the footnote is
X.					\" more likely to fit. *sigh*
X.ev 1					\" enter footnote environment
X.if \\n(fc=1 .fs			\" drop separator if first footnote
X.br					\" flush out any previous line in footnote
X.fi					\" process footnote in fill mode
X..
X.de ef					\" end footnote
X.br					\" flush out the line in footnote
X.ie \\n(if<=0 .er "end footnote has no corresponding begin footnote"
X.el \{\
X.	nr if -1			\" decrement level of footnoting
X.	nr fg 2v			\" remember this for repositioning fo
X.	ev				\" back to usual environment
X.	if \\n(if=0 \{\
X.		di			\" end of footnote proper
X.		nr fp -\\n(dnu		\" "fo" will be moved at least up this far
X.		nr fs -\\n(dnu		\" increase size of footnote
X.		ch fo \\n(fpu		\" reposition "fo" trap (first guess)
X.					\" the first part of the "ie" clause
X.					\" is taken in the special case
X.					\" described above
X.		ie (\\n(fc=1)&((\\n(nlu+1v+\\n(fgu)>=(\\n(.pu-\\n(bmu)) \{\
X.			nr ns \\n(dnu	\" suppress footnote separator
X.					\" since this footnote contains it
X.					\" keep "fo" from being invoked twice
X.			ch fo \\n(.pu+1i
X.			fo		\" force the page out AT ONCE
X.			nr ns 0		\" re-enable footnote separator
X.		\}
X.					\" footnote won't fit completely
X.					\" invoke the footer trap but
X.					\" don't worry about the footnote
X.					\" separator (it's already there)
X.		el .if (\\n(nlu+1v)>=(\\n(.pu+\\n(fpu) \{\
X.					\" as before we must reposition the
X.					\" "fo" trap to prevent "fo" from
X.					\" being invoked twice
X.			ch fo \\n(.pu+1i
X.			fo		\" force the page out AT ONCE
X.		\}
X.	\}
X.\}
X..
X.de fs					\" drop footnote separator
X.					\" only if not already dropped
X.if \\n(ns=0 \l'1i'
X.nr ns 0				\" in case footnotes are over 1 page long
X..
X.de fx					\" process footnote overflow
X.if \\n(fc .di fy			\" stuff them in the right place
X..
X.de fz					\" deposit footnote overflow
X.fn					\" treat it as a footnote
X.nf					\" it's already been processed
X.in 0					\"   and indented
X.fy					\" "fx" put it here
X.ef					\" end the footnote
X..
X.\" **********
X.\" the ones after here are user-invoked (like "fn" and "ef" above)
X.\" title, author, etc.
X.de mt					\" main title
X\&
X.sp |\\n(mtu				\" space
X.ft 3					\" in bold
X.ps \\n(ps+2p				\" large point size and
X.vs \\n(vs+2p				\" vertical spacing
X.ce 1000				\" center the title
X.nr t2 1				\" space it
X..
X.de au					\" author
X.nr t2 0				\" spacing here
X.sp 2v					\" space
X.ft 2					\" in italics
X.ps \\n(ps				\" usual point size and
X.vs \\n(vs				\" vertical spacing
X.ce 1000				\" center the name(s)
X..
X.de ai					\" author's institution
X.if \\n(t2 .sp 2v			\" space after a title
X.nr t2 0				\" institution
X.ft 2					\" in italics
X.ps \\n(ps				\" usual point size and
X.vs \\n(vs				\" vertical spacing
X.ce 1000				\" center the name(s)
X..
X.de bt					\" begin text macro
X.nr t2 0				\" hold it here
X.nr it +1				\" mark as called
X.ce 0					\" end any centering
X.sn 3v					\" a little bit of space
X..
X.\" paragraph
X.de si					\" start indented section
X.nr lo \\n(lm				\" remember the current level
X.nr lm +1				\" go to the next level
X.ie '\\$1'' .nr l\\n(lm \\n(l\\n(lo+5n	\" if no arg, indent 5n
X.el         .nr l\\n(lm \\$1n		\" otherwise, indent that much
X..
X.de ei					\" end indent
X.nr lm -1				\" down one level
X.if \\n(lm<0 .nr lm 0			\" make sure you don't go too far
X..
X.de pg					\" plain old paragraph
X.if !\\n(it .bt				\" end the title and such
X.sn \\n(pdu				\" inter-paragraph spacing
X.ft 1					\" reset a few things (paranoia)
X.					\" these ONLY if not in footnote
X.ie \\n(if=0 \{\
X.	ps \\n(ps			\" reset point size
X.	vs \\n(vs			\" reset vertical spacing
X.	ne 1v+\\n(.Vu			\" slightly more than 1 line
X.\}
X.el \{\
X.	ps \\n(ps-2p			\" reset point size
X.	vs \\n(vs-2p			\" reset vertical spacing
X.\}
X.in \\n(l\\n(lmu			\" stop any indenting
X.ce 0					\" stop any centering
X.if !'\\$1'L' .if !'\\$1'l' .ti +\\n(piu	\" indent the sucker
X..
X.de lp					\" labelled paragraph
X.pg l					\" reset paragraph
X.if \\n(.$>1 .nr li \\$2n		\" if indent given use it
X.in +\\n(liu				\" indent for paragraph
X.ti -\\n(liu				\" force first line NOT to indent
X.ta +\\n(liu				\" for the label
X\&\\$1\t\c
X.if \\w'\\$1'u>=(\\n(l\\n(lmu+\\n(liu) .br	\" don't overwrite
X..
X.\" The following two macros (hu & hn) have been modified for ELM usage.
X.\" If the macros have text as part of the macro call, the text will be
X.\" increased in size by two points.  After printing the text, the font
X.\" will be returned to normal, otherwise the font will be left bold.
X.\"
X.\" section
X.de hu					\" header, unnumbered
X.					\" format: .hu [text]
X.if !\\n(it .bt				\" end the title and such
X.br					\" force out previous line
X.b
X.ie \\n(hP .ps \\n(hP
X.el        .ps \\n(ps
X.ie \\n(hv .vs \\n(hv
X.el        .vs \\n(vs
X.in \\n(l\\n(lmu			\" stop any indenting
X.sn \\n(hsu				\" inter-section spacing
X.ne 3v+\\n(.Vu				\" slightly more than 3 lines
X.fi					\" process the text, too
X.if \\n(.$>=1 \{\
X.ps +2
X\\$1
X.\}
X.if \\n(.$>=2 \\$2
X.if \\n(.$>=3 \\$3
X.if \\n(.$>=4 \\$4
X.if \\n(.$>=5 \\$5
X.if \\n(.$>=6 \\$6
X.if \\n(.$>=7 \\$7
X.if \\n(.$>=8 \\$8
X.if \\n(.$=9 \\$9
X.if \\n(.$>=1 \{\
X.ps -2
X.br
X.ft 1
X.\}
X..
X.de hn					\" header, numbered
X.					\" format: .hn [level] [text]
X.if !\\n(it .bt				\" end the title and such
X.br					\" force out previous line
X.b
X.ie \\n(hP .ps \\n(hP
X.el        .ps \\n(ps
X.ie \\n(hv .vs \\n(hv
X.el        .vs \\n(vs
X.in \\n(l\\n(lmu			\" stop any indenting
X.sn \\n(hsu				\" inter-section spacing
X.ne 3v+\\n(.Vu				\" slightly more than 3 lines
X.fi					\" process the text, too
X.ie !'\\$1'' .nr hn \\$1
X.el          .nr hn 1
X.ie \\n(hn>0 .nr hn -1
X.el          .nr hn 0
X.ie \\n(hn=0 \{\
X.	nr h0 +1			\" add 1 to main section header
X.	nr h1 0				\" zap remaining section numbers
X.	nr h2 0				\" zap remaining section numbers
X.	nr h3 0				\" zap remaining section numbers
X.ie \\n(.$>=2 \{\
X.ps +2
X\\n(h0.
X.ps -2
X.\}
X.el \\n(h0.
X.\}
X.el .ie \\n(hn=1 \{\
X.	nr h1 +1			\" add 1 to the section header
X.	nr h2 0				\" zap remaining section numbers
X.	nr h3 0				\" zap remaining section numbers
X.ie \\n(.$>=2 \{\
X.ps +2
X\\n(h0.\\n(h1.
X.ps -2
X.\}
X.el \\n(h0.\\n(h1.
X.\}
X.el .ie \\n(hn=2 \{\
X.	nr h2 +1			\" add 1 to the section header
X.	nr h3 0				\" zap remaining section numbers
X.ie \\n(.$>=2 \{\
X.ps +2
X\\n(h0.\\n(h1.\\n(h2.
X.ps -2
X.\}
X.el \\n(h0.\\n(h1.\\n(h2.
X.\}
X.el \{\
X.	nr h3 +1			\" add 1 to the section number
X.ie \\n(.$>=2 \{\
X.ps +2
X\\n(h0.\\n(h1.\\n(h2.\\n(h3.
X.ps -2
X.\}
X.el \\n(h0.\\n(h1.\\n(h2.\\n(h3.
X.\}
X.if \\n(.$>=2 \{\
X.ps +2
X\\$2
X.\}
X.if \\n(.$>=3 \\$3
X.if \\n(.$>=4 \\$4
X.if \\n(.$>=5 \\$5
X.if \\n(.$>=6 \\$6
X.if \\n(.$>=7 \\$7
X.if \\n(.$>=8 \\$8
X.if \\n(.$>=9 \\$9
X.if \\n(.$>=2 \{\
X.br
X.ft 1
X.ps -2
X.\}
X..
X.\" displays (no floats, thank God!)
X.de sd					\" start display
X.					\" look for nested displays -- ILLEGAL
X.ie \\n(id>0 .er "display within display"
X.el \{\
X.	ie '\\$1'c' .nr sf 1		\" center the sucker
X.	el          .nr sf 0		\" don't center it
X.\}
X.sn \\n(pdu				\" a little bit of space
X.ev 2					\" switch to display environment
X.nf					\" what you type is what you get
X.if \\n(id=0 .di dd			\" start saving text
X.rs					\" don't eat leading space
X.nr id +1				\" increment level of display
X..
X.de ed					\" end display
X.br					\" flush line
X.ie \\n(id<=0 .er "end display has no corresponding begin display"
X.el \{\
X.	nr id -1			\" decrement level of display
X.	if \\n(id=0 \{\
X.		di			\" end diversion
X.		fi			\" resume filling
X.		in -\\n(piu		\" dedent
X.		ev			\" pop environment
X.		ne \\n(dnu		\" be sure you have room
X.		nf			\" don't reprocess display
X.		rs			\" don't eat leading space
X.		zi			\" save indents
X.		ie \\n(sf .in (\\n(llu-\\n(dlu)/2u	\" center on the line length
X.		el .in +\\n(piu		\" indent the sucker
X.		dd			\" drop display
X.		yi			\" restore indents
X.	\}
X.\}
X.fi					\" resume filling
X.sn \\n(pdu				\" a little bit of space
X..
X.\" **********
X.\" fonts -- if argument(s), apply only to first
X.de b					\" bold (font 3)
X.ie \\n(.$>0 \\&\\$3\\f3\\$1\\fP\\$2
X.el .ft 3
X..
X.de i					\" italics (font 2)
X.ie \\n(.$>0 \\&\\$3\\f2\\$1\\fP\\$2
X.el .ft 2
X..
X.de r					\" roman (font 1)
X.ft 1					\" just restore it
X..
X.de bi					\" bold italics (embolden font 2)
X\\&\\$3\c
X\\kb\\f2\\$1\\fP\\h'|\\nbu+2u'\\f2\\$1\\fP\\$2
X..
X.\" **********
X.\" point sizes -- if argument(s), apply only to first
X.de sm					\" reduce point size by 2
X.ie \\n(.$>0 \\&\\$3\\s-2\\$1\\s0\\$2
X.el .ps -2
X..
X.de is					\" increase point size by 2
X.ie \\n(.$>0 \\&\\$3\\s+2\\$1\\s0\\$2
X.el .ps +2
X..
X.de nl					\" return to normal size
X.ps \\n(ps				\" just reset the point size
X..
X.\" **********
X.\" handy force space/inhibit more space macros
X.de sn					\" space, then turn on nospace mode
X.sp \\$1				\" space
X.ns					\" ignore any more space requests
X..
X.de sr					\" force out space
X.rs					\" turn on spacing mode
X.sp \\$1				\" space
X..
X.\" **********
X.\" end of text and error macros
X.de et					\" end of text macro
X.					\" this: (1) flushes rest of line
X.					\" (2) trips the footer, taking
X.					\" care of footnotes
X.sp \\n(.pu
X.					\" check for open displays or footnotes
X.if \\n(id>0 .er "unfinished display"
X.if \\n(if>0 .er "unfinished footnote"
X.					\" this one means an -mn bug (*sigh*)
X.if !'\\n(.z'' .er "diversion \\n(.z not closed"
X..
X.de er					\" print error message
X.					\" flag it as an error
X.ds ws "** ERROR **
X.					\" if you have it, give the file name
X.if !'\\*(.f'' .as ws " file \\*(.f,
X.					\" put out the line number
X.as ws " line \\n(.c
X.					\" and finally the error message
X.tm \\*(ws: \\$1
X..
X.\" **********
X.\" macros in this section are VERY specific to the news documentation
X.de pa					\" protocol appellation (darn names!)
X\\&\\$3\\f2\\$1\\fP\\$2
X..
X.de ng					\" news group name
X\\&\\$3\\f3\\$1\\fP\\$2
X..
X.de cn					\" computer name
X\\&\\$3\\f2\\$1\\fP\\$2
X..
X.de hf					\" header field
X\\&\\$3\\*(lq\\$1\\*(rq\\$2
X..
X.de cf					\" contents of field
X\\&\\$3\\*(lq\\$1\\*(rq\\$2
X..
X.de qc					\" quote control char (command)
X\\&\\$3\\f3<\\s-2\\$1\\s0>\\fP\\$2
X..
X.de qp					\" quote printing char (command)
X\\&\\$3\\f3\\$1\\fP\\$2
X..
X.de op					\" option
X\\&\\$3\\f3\\$1\\fP\\$2
X..
X.\" **********
X.\" trademarked names
X.de pd					\" print "PDP-11"
X.ie \\n(p1 \\&\\$2\\s-1PDP\\s0-11\\$1
X.el \{\
X.	nr p1 +1			\" mark footnote as dropped
X\\&\\$2\\s-1PDP\\s0-11\\*(rg\\$1
X.	fn				\" put out the footnote
X\\&\\*(rgPDP-11 is a registered trademark of Digital Equipment Corporation.
X.	ef				\" short and sweet ...
X.\}
X..
X.de ux					\" print "UNIX"
X.ie \\n(ux \\&\\$2\\s-1UNIX\\s0\\$1
X.el \{\
X.	nr ux +1			\" mark footnote as dropped
X\\&\\$2\\s-1UNIX\\s0\\*(rg\\$1
X.	fn				\" put out the footnote
X\\&\\*(rgUNIX is a registered trademark of AT&T.
X.	ef				\" short and sweet ...
X.\}
X..
X.de vx					\" print "VAX"
X.ie \\n(vx \\&\\$2\\s-1VAX\\s0\\$1
X.el \{\
X.	nr vx +1			\" mark footnote as dropped
X\\&\\$2\\s-1VAX\\s0\\*(rg\\$1
X.	fn				\" put out the footnote
X\\&\\*(rgVAX is a trademark of Digital Equipment Corporation.
X.	ef				\" short and sweet ...
X.\}
X..
X.\" **********
X.\" set up string and number registers
X.					\" set up for the date
X.if \n(mo=1  .ds mo January
X.if \n(mo=2  .ds mo February
X.if \n(mo=3  .ds mo March
X.if \n(mo=4  .ds mo April
X.if \n(mo=5  .ds mo May
X.if \n(mo=6  .ds mo June
X.if \n(mo=7  .ds mo July
X.if \n(mo=8  .ds mo August
X.if \n(mo=9  .ds mo September
X.if \n(mo=10 .ds mo October
X.if \n(mo=11 .ds mo November
X.if \n(mo=12 .ds mo December
X.ds dy "\*(mo \n(dy, 19\n(yr
X.if \n(dw=1  .ds dw Sunday
X.if \n(dw=2  .ds dw Monday
X.if \n(dw=3  .ds dw Tuesday
X.if \n(dw=4  .ds dw Wednesday
X.if \n(dw=5  .ds dw Thursday
X.if \n(dw=6  .ds dw Friday
X.if \n(dw=7  .ds dw Saturday
X.					\" NROFF dependencies
X.if n \{\
X.					\" string registers
X.	ds rg (R)
X.	ds lq ""
X.	ds rq ""
X.	ds f1 "\*(dy
X.					\" number registers
X.	nr hs 1v			\" space before section header
X.	nr pd 1v			\" inter-paragraph spacing
X.	nr bm 1.0i			\" height of bottom margin
X.\}
X.					\" NROFF dependencies
X.if t \{\
X.					\" string registers
X.	ds rg \\u\\s-2\\(rg\\s0\\d
X.	ds lq ``
X.	ds rq ''
X.					\" number registers
X.	nr hs 1v			\" space before section header
X.	nr pd 0.3v			\" inter-paragraph spacing
X.	nr bm 1.0i+1v			\" height of bottom margin (wacky laser)
X.\}
X.					\" these are the same for [NT]ROFF
X.ds dg \(dg
X.ds vr "News Version B2.11
X.ds pv "News macros 1.5
X.ds h1 - % -
X.nr bt 0.5i+1v				\" bottom of page to footer
X.nr cm 0				\" no cut marks
X.nr fc 0 1				\" init footnote count
X.nr fl 5.5i				\" footnote line length
X.nr fp 0-\n(bmu				\" fo macro trap location
X.nr h0 0				\" init section header level 0
X.nr h1 0				\" init section header level 1
X.nr h2 0				\" init section header level 2
X.nr h3 0				\" init section header level 3
X.nr id 0				\" 1 in display
X.nr if 0				\" 1 in keep
X.nr it 0				\" 1 when beyond title, etc.
X.nr li 5n				\" indent for labelled paragraph
X.nr ll 6.5i				\" line length
X.nr lm 0				\" left margin
X.nr l0 0				\" first indent level
X.nr mt 1.5i+1v				\" title goes down this far
X.nr pi 5n				\" regular paragraph indent
X.nr po 1.0i				\" page offset
X.nr ps 10				\" point size
X.nr tm 1.0i				\" height of top margin
X.nr tt 0.5i-0.5v			\" top of page to header
X.nr p1 0				\" no PDP-TM message yet
X.nr ux 0				\" no UNIX-TM message yet
X.nr vx 0				\" no VAX-TM message yet
X.nr vs 12				\" vertical spacing
X.\" set things up
X.\" DSINC changes for XROFF
X.nr f1 1
X.nr f2 1
X.nr s1 10
X.nr s2 10
X.nr v1 12
X.nr v2 12
X.ps 10
X.vs 12
X.\" DSINC end changes for XROFF
X.po \n(pou				\" set page offset
X.ps \n(ps				\" set previous, current
X.ps \n(ps				\"   point sizes
X.vs \n(vs				\" set previous, current
X.vs \n(vs				\"   vertical spacings
X.ll \n(llu				\" set line length
X.lt \n(llu				\" set title line length
X.ev 1					\" *** footnote environment
X.ps \n(ps-2p				\" set previous, current
X.ps \n(ps-2p				\"   point sizes
X.vs \n(vs-2p				\" set previous, current
X.vs \n(vs-2p				\"   vertical spacings
X.ll \n(flu				\" set line length
X.lt \n(flu				\" set title line length
X.ev					\" *** pop environment
X.ev 2					\" *** footnote environment
X.ps \n(ps				\" set previous, current
X.ps \n(ps				\"   point sizes
X.vs \n(vs				\" set previous, current
X.vs \n(vs				\"   vertical spacings
X.ll \n(llu				\" set line length
X.lt \n(llu				\" set title line length
X.ev					\" *** pop environment
X.\" now set internal registers (for the first header section)
X.nr f1 \n(.f				\" saved font #1
X.nr f2 \n(.f				\" saved font #2
X.nr s1 \n(.s				\" saved point size #1
X.nr s2 \n(.s				\" saved point size #2
X.nr v1 \n(.v				\" saved vertical spacing #1
X.nr v2 \n(.v				\" saved vertical spacing #2
X.\" install traps
X.wh 0i hd				\" position header trap
X.wh -\n(bmu fo				\" position footer trap
X.wh \n(.pu+1i fx			\" put footnote overflow trap here
X.ch fx -\n(bmu				\" move it over fo
X.wh -\n(btu pf				\" print the bottom margin here
X.em et					\" at end of file, call et
X.\" couple of miscellaneous requests
X.bd S 3 3				\" embolden special font chars if B
X.hy 2					\" don't hyphenate last lines
END_OF_FILE
if test 25078 -ne `wc -c <'auxil/tmac.n'`; then
    echo shar: \"'auxil/tmac.n'\" unpacked with wrong size!
fi
# end of 'auxil/tmac.n'
fi
if test -f 'others/lev_lex.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'others/lev_lex.c'\"
else
echo shar: Extracting \"'others/lev_lex.c'\" \(31273 characters\)
sed "s/^X//" >'others/lev_lex.c' <<'END_OF_FILE'
X#define FLEX_COMPRESSED
X/* A lexical scanner generated by flex */
X
X/* scanner skeleton version:
X * $Header: flex.skel,v 2.0 89/06/20 15:49:46 vern Locked $
X */
X
X#include <stdio.h>
X
X#define FLEX_SCANNER
X
X/* amount of stuff to slurp up with each read */
X#ifndef YY_READ_BUF_SIZE
X#define YY_READ_BUF_SIZE 8192
X#endif
X
X#ifndef YY_BUF_SIZE
X#define YY_BUF_SIZE (YY_READ_BUF_SIZE * 2) /* size of input buffer */
X#endif
X
X/* returned upon end-of-file */
X#define YY_END_TOK 0
X
X/* copy whatever the last rule matched to the standard output */
X
X#define ECHO fputs( yytext, yyout )
X
X/* gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
X * is returned in "result".
X */
X#ifdef atarist
Xstatic __st_read(fd, buf, size)
Xint fd; char *buf; int size;
X{
X	int r, num = 0;
X	char *from;
X
X	if ((r = read(fd, buf, size)) < 0)
X		return r;
X	from = buf;
X	while (r-- > 0) {
X		if (*from == '\r')
X			from++;
X		else {
X			*buf++ = *from++;
X			num++;
X		}
X	}
X	return num;
X}
X
X#define YY_INPUT(buf,result,max_size) \
X	if ( (result = __st_read( fileno(yyin), buf, max_size )) < 0 ) \
X	    YY_FATAL_ERROR( "read() in flex scanner failed" );
X
X#else
X
X#define YY_INPUT(buf,result,max_size) \
X	if ( (result = read( fileno(yyin), buf, max_size )) < 0 ) \
X	    YY_FATAL_ERROR( "read() in flex scanner failed" );
X#endif
X
X#define YY_NULL 0
X#define yyterminate() return ( YY_NULL )
X
X/* report a fatal error */
X#define YY_FATAL_ERROR(msg) \
X	{ \
X	fputs( msg, stderr ); \
X	putc( '\n', stderr ); \
X	exit( 1 ); \
X	}
X
X/* default yywrap function - always treat EOF as an EOF */
X#define yywrap() 1
X
X/* enter a start condition.  This macro really ought to take a parameter,
X * but we do it the disgusting crufty way forced on us by the ()-less
X * definition of BEGIN
X */
X#define BEGIN yy_start = 1 + 2 *
X
X/* action number for EOF rule of a given start state */
X#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
X
X/* special action meaning "start processing a new file" */
X#define YY_NEW_FILE goto new_file
X
X/* default declaration of generated scanner - a define so the user can
X * easily add parameters
X */
X#ifdef __STDC__
X#define YY_DECL int yylex( void )
X#else
X#define YY_DECL int yylex()
X#endif
X
X/* code executed at the end of each rule */
X#define YY_BREAK break;
X
X#define YY_END_OF_BUFFER_CHAR 0
X
X/* done after the current pattern has been matched and before the
X * corresponding action - sets up yytext
X */
X#define YY_DO_BEFORE_ACTION \
X	yytext = yy_bp; \
X	yy_hold_char = *yy_cp; \
X	*yy_cp = '\0'; \
X	yy_c_buf_p = yy_cp;
X
X/* returns the length of the matched text */
X#define yyleng (int)(yy_cp - yy_bp)
X
X#define EOB_ACT_RESTART_SCAN 0
X#define EOB_ACT_END_OF_FILE 1
X#define EOB_ACT_LAST_MATCH 2
X
X/* return all but the first 'n' matched characters back to the input stream */
X#define yyless(n) \
X	{ \
X	*yy_cp = yy_hold_char; /* undo effects of setting up yytext */ \
X	yy_c_buf_p = yy_cp = yy_bp + n; \
X	YY_DO_BEFORE_ACTION; /* set up yytext again */ \
X	}
X
X#define unput(c) yyunput( c, yy_bp )
X
X#define YY_USER_ACTION
X
XFILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
Xchar *yytext;
X
X#ifndef __STDC__
X#define const
X#endif
X
X# line 1 "lev_comp.l"
X#define INITIAL 0
X# line 2 "lev_comp.l"
X/*	SCCS Id: @(#)lev_lex.c	3.0	90/01/04
X/*	Copyright (c) 1989 by Jean-Christophe Collet */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#define LEV_LEX_C
X
X/* block some unused #defines to avoid overloading some cpp's */
X#define MONDATA_H	/* comment this line for pre-compiled headers */
X#define MONFLAG_H	/* comment this line for pre-compiled headers */
X
X#include "hack.h"
X#include "lev_comp.h"
X#include "sp_lev.h"
X
X/* Most of these don't exist in flex, yywrap is macro and
X * yyunput is properly declared in flex.skel.
X */
X#ifndef FLEX_SCANNER
Xint FDECL (yyback, (int *, int));
Xint NDECL (yylook);
Xint NDECL (yyinput);
Xint NDECL (yywrap);
Xint NDECL (yylex);
Xint FDECL (yyunput, (int));
Xint FDECL (yyoutput, (int));
X#endif
X
X#ifdef MSDOS
X#undef exit
Xextern void FDECL(exit, (int));
X#endif
X
X/* this doesn't always get put in lev_comp.h
X * (esp. when using older versions of bison)
X */
X
Xextern YYSTYPE yylval;
X
X#ifdef MACOS
X#undef putchar
X#undef putc
X#undef printf
X#undef Printf
X#define Printf printf
X# ifdef LSC
X#define	putc(c,stream)	(fputc(c,stream))
X#define	putchar(c)	(fputc(c,stdout))
X# endif
X#endif
Xint line_number = 1;
X
X/* This is *** UGLY *** but I can't think a better way to do it
X * I really need a huge buffer to scan maps...
X */
X
X#undef YYLMAX
X#define YYLMAX	2048
X
X#define MAPC 1
X# line 62 "lev_comp.l"
X#define YY_END_OF_BUFFER 57
Xtypedef int yy_state_type;
Xstatic const short int yy_accept[274] =
X    {   0,
X        0,    0,    0,    0,   57,   55,   53,   52,   55,   55,
X       50,   55,   55,   55,   55,   55,   55,   55,   55,   55,
X       55,   55,   55,   55,   55,   55,   55,   55,   55,   55,
X       55,   55,   55,   55,   55,   55,   55,    1,   53,   55,
X       55,   55,   53,    0,   51,    0,   50,    0,    0,    0,
X        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
X        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
X        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
X        0,    0,    0,    0,    0,   48,    0,    0,    3,    0,
X        1,   53,    0,    0,    1,    0,   54,    0,    0,    0,
X
X        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
X        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
X       43,    0,   41,    0,    0,    0,    0,    0,    0,    0,
X        0,    0,    0,    0,    0,   39,    0,    0,    0,    0,
X        0,   11,    0,    0,    0,    0,    4,    0,    0,    0,
X        0,    0,   21,   10,    0,    0,    0,    0,    0,    0,
X        0,   49,   28,   36,    0,    0,    0,    0,    0,    0,
X       22,    0,    0,    0,    0,    0,    0,   30,    7,    0,
X       18,    0,    0,    0,    5,    0,    0,    0,    0,    0,
X        0,   35,   47,    0,    0,    0,   45,    0,    0,    0,
X
X        0,    0,   27,    0,   34,    0,   37,    0,   29,   42,
X        0,    0,    0,   19,    0,    0,    0,    8,    0,   14,
X       40,   26,   38,   23,   24,    0,    0,   25,   32,   31,
X       46,    0,    0,    0,    0,    9,    0,    0,   33,   44,
X        2,    0,    6,   13,    0,    0,    0,    0,    0,    0,
X        0,    0,    0,   12,    0,    0,    0,    0,    0,    0,
X        0,    0,   20,    0,    0,    0,    0,    0,   17,    0,
X       15,   16,    0
X    } ;
X
Xstatic const char yy_ec[128] =
X    {   0,
X        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    4,    1,    5,    6,    1,    1,    1,    7,    1,
X        1,    1,    8,    1,    8,    8,    1,    9,    9,    9,
X        9,    9,    9,    9,    9,    9,    9,    1,    1,    1,
X        1,    1,    1,    1,   10,   11,   12,   13,   14,    1,
X       15,    1,   16,   17,   18,   19,   20,   21,   22,   23,
X        1,   24,   25,   26,    1,   27,   28,    1,   29,   30,
X        1,    8,    1,    1,   31,    1,   32,   33,   34,   35,
X
X       36,   37,   38,   39,   40,   41,   42,   43,   44,   45,
X       46,   47,    1,   48,   49,   50,   51,    1,   52,    1,
X        1,    1,    8,    8,    8,    1,    1
X    } ;
X
Xstatic const char yy_meta[53] =
X    {   0,
X        1,    1,    2,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1
X    } ;
X
Xstatic const short int yy_base[277] =
X    {   0,
X        0,   47,   51,   74,  343,  344,   54,  344,  337,    0,
X      332,  321,   38,  325,   54,   51,  316,  326,   61,  312,
X      292,   24,   48,  288,  301,   49,  286,   50,   46,  288,
X       34,   51,  284,   53,  293,  325,   91,  344,  100,  106,
X      306,  124,  103,  321,  344,  318,  315,  297,  300,  311,
X      298,  306,  291,  287,  295,  294,  297,  292,  297,  289,
X      300,   71,  259,  262,  262,  274,  259,  252,  254,  250,
X      264,  250,  265,  253,  246,   81,  255,  259,  262,  248,
X      254,  243,  239,  242,  245,  344,  238,  283,  344,   92,
X      344,  132,  140,  272,  344,  148,  344,  274,  259,  254,
X
X      261,  267,  265,  264,  252,  245,  261,  261,  257,  252,
X      248,  232,  237,  218,  225,  216,  219,  215,  218,  212,
X      344,  211,  344,  218,  210,  208,  211,  206,  219,  209,
X      219,  217,  212,  210,  199,  344,  208,  197,  243,  225,
X      220,  344,  232,  228,  227,  221,  211,  212,  224,  224,
X      213,  212,  344,  344,  188,  184,  185,  194,  193,  179,
X      191,  344,  344,  344,  190,  175,  176,  177,  183,  187,
X      344,  184,  173,  168,  172,  177,  165,  344,  344,  204,
X      344,  189,  186,  187,  344,  200,  195,  192,  181,  186,
X      184,  344,  344,  160,  158,  154,  344,  166,  165,  163,
X
X      166,  149,  344,  146,  344,  151,  344,  158,  344,  344,
X      170,  176,  167,  344,  171,  165,  173,  344,  156,  344,
X      344,  344,  344,  344,  344,  138,  142,  344,  344,  344,
X      344,  181,  170,  153,  163,  344,  165,   97,  344,  344,
X      344,  164,  344,  344,  168,  150,  160,  151,  155,  157,
X      146,  147,  153,  344,  143,  136,  146,  147,  141,  127,
X      135,  131,  344,  127,  113,  112,  109,  101,  344,   98,
X      344,  344,  344,  173,   62,  175
X    } ;
X
Xstatic const short int yy_def[277] =
X    {   0,
X      273,    1,    1,    1,  273,  273,  273,  273,  274,  275,
X      273,  273,  273,  273,  273,  273,  273,  273,  273,  273,
X      273,  273,  273,  273,  273,  273,  273,  273,  273,  273,
X      273,  273,  273,  273,  273,  276,  273,  273,  273,  273,
X      273,  276,  273,  274,  273,  273,  273,  273,  273,  273,
X      273,  273,  273,  273,  273,  273,  273,  273,  273,  273,
X      273,  273,  273,  273,  273,  273,  273,  273,  273,  273,
X      273,  273,  273,  273,  273,  273,  273,  273,  273,  273,
X      273,  273,  273,  273,  273,  273,  273,  276,  273,  273,
X      273,  273,  273,  273,  273,  276,  273,  273,  273,  273,
X
X      273,  273,  273,  273,  273,  273,  273,  273,  273,  273,
X      273,  273,  273,  273,  273,  273,  273,  273,  273,  273,
X      273,  273,  273,  273,  273,  273,  273,  273,  273,  273,
X      273,  273,  273,  273,  273,  273,  273,  273,  273,  273,
X      273,  273,  273,  273,  273,  273,  273,  273,  273,  273,
X      273,  273,  273,  273,  273,  273,  273,  273,  273,  273,
X      273,  273,  273,  273,  273,  273,  273,  273,  273,  273,
X      273,  273,  273,  273,  273,  273,  273,  273,  273,  273,
X      273,  273,  273,  273,  273,  273,  273,  273,  273,  273,
X      273,  273,  273,  273,  273,  273,  273,  273,  273,  273,
X
X      273,  273,  273,  273,  273,  273,  273,  273,  273,  273,
X      273,  273,  273,  273,  273,  273,  273,  273,  273,  273,
X      273,  273,  273,  273,  273,  273,  273,  273,  273,  273,
X      273,  273,  273,  273,  273,  273,  273,  273,  273,  273,
X      273,  273,  273,  273,  273,  273,  273,  273,  273,  273,
X      273,  273,  273,  273,  273,  273,  273,  273,  273,  273,
X      273,  273,  273,  273,  273,  273,  273,  273,  273,  273,
X      273,  273,    0,  273,  273,  273
X    } ;
X
Xstatic const short int yy_nxt[397] =
X    {   0,
X        6,    7,    8,    7,    9,    6,   10,    6,   11,   12,
X        6,    6,   13,    6,   14,    6,    6,    6,   15,   16,
X       17,   18,    6,   19,    6,   20,    6,    6,    6,    6,
X        6,   21,   22,   23,   24,   25,    6,    6,    6,    6,
X        6,    6,   26,   27,   28,   29,   30,   31,   32,   33,
X       34,   35,   36,   38,   39,   43,   40,   43,   40,   49,
X       54,   50,   46,   52,   41,   80,   37,   53,   40,   63,
X       58,   64,   55,   81,   59,   40,   38,   39,   77,   42,
X       70,   40,   60,   65,   71,   75,   66,   41,   72,   82,
X       67,   40,   78,   37,   73,   76,   83,   85,   40,   86,
X
X       90,   43,   91,   92,   43,   93,   43,   93,   91,   93,
X      112,   93,   55,   93,  139,  127,  246,   93,  247,  248,
X      113,  104,  272,   93,   93,  271,   95,   96,  128,   96,
X       93,   96,  270,   43,   91,   92,  269,   93,  268,   93,
X      267,   96,   91,   93,  266,   93,  265,   93,   96,   93,
X       95,   96,  264,   96,  263,   96,   93,   93,  262,  261,
X      260,  259,  258,  257,   93,   96,  256,  255,  254,  253,
X      252,  251,   96,   44,   44,   88,   88,  250,  249,  245,
X      244,  243,  242,  241,  240,  239,  238,  237,  236,  235,
X      234,  233,  232,  231,  230,  229,  228,  227,  226,  225,
X
X      224,  223,  222,  221,  220,  219,  218,  217,  216,  215,
X      214,  213,  212,  211,  210,  209,  208,  207,  206,  205,
X      204,  203,  202,  201,  200,  199,  198,  197,  196,  195,
X      194,  193,  192,  191,  190,  189,  188,  187,  186,  185,
X      184,  183,  182,  181,  180,  179,  178,  177,  176,  175,
X      174,  173,  172,  171,  170,  169,  168,  167,  166,  165,
X      164,  163,  162,  161,  160,  159,  158,  157,  156,  155,
X      154,  153,  152,  151,  150,  149,  148,  147,  146,  145,
X      144,  143,  142,  141,  140,   89,  138,  137,  136,  135,
X      134,  133,  132,  131,  130,  129,  126,  125,  124,  123,
X
X      122,  121,  120,  119,  118,  117,  116,  115,  114,  111,
X      110,  109,  108,  107,  106,  105,  104,  103,  102,  101,
X      100,   99,   98,   47,   97,   45,   94,   89,   87,   84,
X       79,   74,   69,   68,   62,   61,   57,   56,   51,   48,
X       47,   45,  273,    5,  273,  273,  273,  273,  273,  273,
X      273,  273,  273,  273,  273,  273,  273,  273,  273,  273,
X      273,  273,  273,  273,  273,  273,  273,  273,  273,  273,
X      273,  273,  273,  273,  273,  273,  273,  273,  273,  273,
X      273,  273,  273,  273,  273,  273,  273,  273,  273,  273,
X      273,  273,  273,  273,  273,  273
X
X    } ;
X
Xstatic const short int yy_chk[397] =
X    {   0,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    2,    3,    3,    7,    3,    7,    3,   13,
X       16,   13,  275,   15,    3,   31,    2,   15,    3,   22,
X       19,   22,   16,   31,   19,    3,    4,    4,   29,    4,
X       26,    4,   19,   23,   26,   28,   23,    4,   26,   32,
X       23,    4,   29,    4,   26,   28,   32,   34,    4,   34,
X
X       37,   39,   39,   39,   43,   39,   43,   39,   40,   40,
X       62,   40,   37,   40,   90,   76,  238,   39,  238,  238,
X       62,   90,  270,   40,   39,  268,   42,   42,   76,   42,
X       40,   42,  267,   92,   92,   92,  266,   92,  265,   92,
X      264,   42,   93,   93,  262,   93,  261,   93,   42,   92,
X       96,   96,  260,   96,  259,   96,   92,   93,  258,  257,
X      256,  255,  253,  252,   93,   96,  251,  250,  249,  248,
X      247,  246,   96,  274,  274,  276,  276,  245,  242,  237,
X      235,  234,  233,  232,  227,  226,  219,  217,  216,  215,
X      213,  212,  211,  208,  206,  204,  202,  201,  200,  199,
X
X      198,  196,  195,  194,  191,  190,  189,  188,  187,  186,
X      184,  183,  182,  180,  177,  176,  175,  174,  173,  172,
X      170,  169,  168,  167,  166,  165,  161,  160,  159,  158,
X      157,  156,  155,  152,  151,  150,  149,  148,  147,  146,
X      145,  144,  143,  141,  140,  139,  138,  137,  135,  134,
X      133,  132,  131,  130,  129,  128,  127,  126,  125,  124,
X      122,  120,  119,  118,  117,  116,  115,  114,  113,  112,
X      111,  110,  109,  108,  107,  106,  105,  104,  103,  102,
X      101,  100,   99,   98,   94,   88,   87,   85,   84,   83,
X       82,   81,   80,   79,   78,   77,   75,   74,   73,   72,
X
X       71,   70,   69,   68,   67,   66,   65,   64,   63,   61,
X       60,   59,   58,   57,   56,   55,   54,   53,   52,   51,
X       50,   49,   48,   47,   46,   44,   41,   36,   35,   33,
X       30,   27,   25,   24,   21,   20,   18,   17,   14,   12,
X       11,    9,    5,  273,  273,  273,  273,  273,  273,  273,
X      273,  273,  273,  273,  273,  273,  273,  273,  273,  273,
X      273,  273,  273,  273,  273,  273,  273,  273,  273,  273,
X      273,  273,  273,  273,  273,  273,  273,  273,  273,  273,
X      273,  273,  273,  273,  273,  273,  273,  273,  273,  273,
X      273,  273,  273,  273,  273,  273
X
X    } ;
X
X/* the intent behind this definition is that it'll catch
X * any uses of REJECT which flex missed
X */
X#define REJECT reject_used_but_not_detected
Xstatic char *yy_more_pos = (char *) 0;
X#define yymore() (yy_more_pos = yy_bp)
X
X/* these variables are all declared out here so that section 3 code can
X * manipulate them
X */
Xstatic char *yy_c_buf_p;	/* points to current character in buffer */
Xstatic int yy_init = 1;		/* whether we need to initialize */
Xstatic int yy_start = 0;	/* start state number */
X
X/* true when we've seen an EOF for the current input file */
Xstatic int yy_eof_has_been_seen;
X
Xstatic int yy_n_chars;		/* number of characters read into yy_ch_buf */
X
X/* yy_ch_buf has to be 2 characters longer than YY_BUF_SIZE because we need
X * to put in 2 end-of-buffer characters (this is explained where it is
X * done) at the end of yy_ch_buf
X */
Xstatic char yy_ch_buf[YY_BUF_SIZE + 2];
X
X/* yy_hold_char holds the character lost when yytext is formed */
Xstatic char yy_hold_char;
X
Xstatic yy_state_type yy_last_accepting_state;
Xstatic char *yy_last_accepting_cpos;
X
X#ifdef __STDC__
Xstatic yy_state_type yy_get_previous_state( void );
Xstatic int yy_get_next_buffer( void );
Xstatic void yyunput( int c, char *buf_ptr );
Xstatic int input( void );
Xstatic void yyrestart( FILE *input_file );
X#else
Xstatic yy_state_type yy_get_previous_state();
Xstatic int yy_get_next_buffer();
Xstatic void yyunput();
Xstatic int input();
Xstatic void yyrestart();
X#endif
X
XYY_DECL
X    {
X    register yy_state_type yy_current_state;
X    register char *yy_cp, *yy_bp;
X    register int yy_act;
X
X
X
X    if ( yy_init )
X	{
X	if ( ! yy_start )
X	    yy_start = 1;	/* first start state */
X
X	if ( ! yyin )
X	    yyin = stdin;
X
X	if ( ! yyout )
X	    yyout = stdout;
X
Xnew_file:
X	/* this is where we enter upon encountering an end-of-file and
X	 * yywrap() indicating that we should continue processing
X	 */
X
X	/* we put in the '\n' and start reading from [1] so that an
X	 * initial match-at-newline will be true.
X	 */
X
X	yy_ch_buf[0] = '\n';
X	yy_n_chars = 1;
X
X	/* we always need two end-of-buffer characters.  The first causes
X	 * a transition to the end-of-buffer state.  The second causes
X	 * a jam in that state.
X	 */
X	yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
X	yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;
X
X	yy_eof_has_been_seen = 0;
X
X	yytext = yy_c_buf_p = &yy_ch_buf[1];
X	yy_hold_char = *yy_c_buf_p;
X	yy_init = 0;
X	}
X
X    while ( 1 )		/* loops until end-of-file is reached */
X	{
X	yy_cp = yy_c_buf_p;
X
X	/* support of yytext */
X	*yy_cp = yy_hold_char;
X
X	/* yy_bp points to the position in yy_ch_buf of the start of the
X	 * current run.
X	 */
X	if ( yy_more_pos )
X	    {
X	    yy_bp = yy_more_pos;
X	    yy_more_pos = (char *) 0;
X	    }
X	else
X	    yy_bp = yy_cp;
X
X	yy_current_state = yy_start;
X	if ( yy_bp[-1] == '\n' )
X	    ++yy_current_state;
X	do
X	    {
X	    register char yy_c = yy_ec[*yy_cp];
X	    if ( yy_accept[yy_current_state] )
X		{
X		yy_last_accepting_state = yy_current_state;
X		yy_last_accepting_cpos = yy_cp;
X		}
X	    while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
X		{
X		yy_current_state = yy_def[yy_current_state];
X		if ( yy_current_state >= 274 )
X		    yy_c = yy_meta[yy_c];
X		}
X	    yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
X	    ++yy_cp;
X	    }
X	while ( yy_current_state != 273 );
X	yy_cp = yy_last_accepting_cpos;
X	yy_current_state = yy_last_accepting_state;
X
X	/* bogus while loop to let YY_BACK_TRACK, EOB_ACT_LAST_MATCH,
X	 * and EOF actions branch here without introducing an optimizer-
X	 * daunting goto
X	 */
X	while ( 1 )
X	    {
X	    yy_act = yy_accept[yy_current_state];
X
X	    YY_DO_BEFORE_ACTION;
X	    YY_USER_ACTION;
X
X#ifdef FLEX_DEBUG
X	    fprintf( stderr, "--accepting rule #%d (\"%s\")\n",
X		     yy_act, yytext );
X#endif
X
Xdo_action:	/* this label is used only to access EOF actions */
X	    switch ( yy_act )
X		{
X		case 0: /* must backtrack */
X		/* undo the effects of YY_DO_BEFORE_ACTION */
X		*yy_cp = yy_hold_char;
X		yy_cp = yy_last_accepting_cpos;
X		yy_current_state = yy_last_accepting_state;
X		continue; /* go to "YY_DO_BEFORE_ACTION" */
X
Xcase 1:
X# line 63 "lev_comp.l"
X{ line_number++; yymore(); }	
X	YY_BREAK
Xcase 2:
X# line 64 "lev_comp.l"
X{ BEGIN 0;
X		  line_number++;
X		  yytext[yyleng-7] = 0; /* Discard \nENDMAP */
X		  yylval.map = (char *) alloc(strlen(yytext)+1);
X		  strcpy(yylval.map, yytext);
X		  return MAP_ID;
X		}
X	YY_BREAK
Xcase 3:
X# line 71 "lev_comp.l"
X{ line_number++; }
X	YY_BREAK
Xcase 4:
X# line 72 "lev_comp.l"
Xreturn MAZE_ID;
X	YY_BREAK
Xcase 5:
X# line 73 "lev_comp.l"
Xreturn LEVEL_ID;
X	YY_BREAK
Xcase 6:
X# line 74 "lev_comp.l"
Xreturn GEOMETRY_ID;
X	YY_BREAK
Xcase 7:
X# line 75 "lev_comp.l"
X{ BEGIN MAPC; line_number++; }
X	YY_BREAK
Xcase 8:
X# line 76 "lev_comp.l"
Xreturn OBJECT_ID;
X	YY_BREAK
Xcase 9:
X# line 77 "lev_comp.l"
Xreturn MONSTER_ID;
X	YY_BREAK
Xcase 10:
X# line 78 "lev_comp.l"
Xreturn TRAP_ID;
X	YY_BREAK
Xcase 11:
X# line 79 "lev_comp.l"
Xreturn DOOR_ID;
X	YY_BREAK
Xcase 12:
X# line 80 "lev_comp.l"
Xreturn DRAWBRIDGE_ID;
X	YY_BREAK
Xcase 13:
X# line 81 "lev_comp.l"
Xreturn MAZEWALK_ID;
X	YY_BREAK
Xcase 14:
X# line 82 "lev_comp.l"
Xreturn REGION_ID;
X	YY_BREAK
Xcase 15:
X# line 83 "lev_comp.l"
Xreturn RANDOM_OBJECTS_ID;
X	YY_BREAK
Xcase 16:
X# line 84 "lev_comp.l"
Xreturn RANDOM_MONSTERS_ID;
X	YY_BREAK
Xcase 17:
X# line 85 "lev_comp.l"
Xreturn RANDOM_PLACES_ID;
X	YY_BREAK
Xcase 18:
X# line 86 "lev_comp.l"
Xreturn ALTAR_ID;
X	YY_BREAK
Xcase 19:
X# line 87 "lev_comp.l"
Xreturn LADDER_ID;
X	YY_BREAK
Xcase 20:
X# line 88 "lev_comp.l"
Xreturn NON_DIGGABLE_ID;
X	YY_BREAK
Xcase 21:
X# line 89 "lev_comp.l"
Xreturn ROOM_ID;
X	YY_BREAK
Xcase 22:
X# line 90 "lev_comp.l"
X{ yylval.i=D_ISOPEN; return DOOR_STATE; }
X	YY_BREAK
Xcase 23:
X# line 91 "lev_comp.l"
X{ yylval.i=D_CLOSED; return DOOR_STATE; }
X	YY_BREAK
Xcase 24:
X# line 92 "lev_comp.l"
X{ yylval.i=D_LOCKED; return DOOR_STATE; }
X	YY_BREAK
Xcase 25:
X# line 93 "lev_comp.l"
X{ yylval.i=D_NODOOR; return DOOR_STATE; }
X	YY_BREAK
Xcase 26:
X# line 94 "lev_comp.l"
X{ yylval.i=D_BROKEN; return DOOR_STATE; }
X	YY_BREAK
Xcase 27:
X# line 95 "lev_comp.l"
X{ yylval.i=W_NORTH; return DIRECTION; }
X	YY_BREAK
Xcase 28:
X# line 96 "lev_comp.l"
X{ yylval.i=W_EAST; return DIRECTION; }
X	YY_BREAK
Xcase 29:
X# line 97 "lev_comp.l"
X{ yylval.i=W_SOUTH; return DIRECTION; }
X	YY_BREAK
Xcase 30:
X# line 98 "lev_comp.l"
X{ yylval.i=W_WEST; return DIRECTION; }
X	YY_BREAK
Xcase 31:
X# line 99 "lev_comp.l"
X{ yylval.i = -1; return RANDOM_TYPE; }
X	YY_BREAK
Xcase 32:
X# line 100 "lev_comp.l"
Xreturn O_REGISTER;
X	YY_BREAK
Xcase 33:
X# line 101 "lev_comp.l"
Xreturn M_REGISTER;
X	YY_BREAK
Xcase 34:
X# line 102 "lev_comp.l"
Xreturn P_REGISTER;
X	YY_BREAK
Xcase 35:
X# line 103 "lev_comp.l"
Xreturn A_REGISTER;
X	YY_BREAK
Xcase 36:
X# line 104 "lev_comp.l"
X{ yylval.i=1; return LEFT_OR_RIGHT; }
X	YY_BREAK
Xcase 37:
X# line 105 "lev_comp.l"
X{ yylval.i=3; return LEFT_OR_RIGHT; }
X	YY_BREAK
Xcase 38:
X# line 106 "lev_comp.l"
X{ yylval.i=2; return CENTER; }
X	YY_BREAK
Xcase 39:
X# line 107 "lev_comp.l"
X{ yylval.i=1; return TOP_OR_BOT; }
X	YY_BREAK
Xcase 40:
X# line 108 "lev_comp.l"
X{ yylval.i=3; return TOP_OR_BOT; }
X	YY_BREAK
Xcase 41:
X# line 109 "lev_comp.l"
X{ yylval.i=1; return LIGHT_STATE; }
X	YY_BREAK
Xcase 42:
X# line 110 "lev_comp.l"
X{ yylval.i=0; return LIGHT_STATE; }
X	YY_BREAK
Xcase 43:
X# line 111 "lev_comp.l"
X{ yylval.i=A_LAW; return ALIGNMENT; }
X	YY_BREAK
Xcase 44:
X# line 112 "lev_comp.l"
X{ yylval.i=A_NEUTRAL; return ALIGNMENT; }
X	YY_BREAK
Xcase 45:
X# line 113 "lev_comp.l"
X{ yylval.i=A_CHAOS; return ALIGNMENT; }
X	YY_BREAK
Xcase 46:
X# line 114 "lev_comp.l"
X{ yylval.i=1; return ALTAR_TYPE; }
X	YY_BREAK
Xcase 47:
X# line 115 "lev_comp.l"
X{ yylval.i=0; return ALTAR_TYPE; }
X	YY_BREAK
Xcase 48:
X# line 116 "lev_comp.l"
X{ yylval.i=1; return UP_OR_DOWN; }
X	YY_BREAK
Xcase 49:
X# line 117 "lev_comp.l"
X{ yylval.i=0; return UP_OR_DOWN; }
X	YY_BREAK
Xcase 50:
X# line 118 "lev_comp.l"
X{ yylval.i=atoi(yytext); return INTEGER; }
X	YY_BREAK
Xcase 51:
X# line 119 "lev_comp.l"
X{ yytext[yyleng-1] = 0; /* Discard the trailing \" */
X		  yylval.map = (char *) alloc(strlen(yytext+1)+1);
X		  strcpy(yylval.map, yytext+1); /* Discard the first \" */
X		  return STRING; }
X	YY_BREAK
Xcase 52:
X# line 123 "lev_comp.l"
X{ line_number++; }
X	YY_BREAK
Xcase 53:
X# line 124 "lev_comp.l"
X;
X	YY_BREAK
Xcase 54:
X# line 125 "lev_comp.l"
X{ yylval.i = yytext[1]; return CHAR; }
X	YY_BREAK
Xcase 55:
X# line 126 "lev_comp.l"
X{ return yytext[0]; }
X	YY_BREAK
Xcase 56:
X# line 127 "lev_comp.l"
XECHO;
X	YY_BREAK
Xcase YY_STATE_EOF(INITIAL):
Xcase YY_STATE_EOF(MAPC):
X    yyterminate();
X
X		case YY_END_OF_BUFFER:
X		    /* undo the effects of YY_DO_BEFORE_ACTION */
X		    *yy_cp = yy_hold_char;
X
X		    yytext = yy_bp;
X
X		    switch ( yy_get_next_buffer() )
X			{
X			case EOB_ACT_END_OF_FILE:
X			    {
X			    if ( yywrap() )
X				{
X				/* note: because we've taken care in
X				 * yy_get_next_buffer() to have set up yytext,
X				 * we can now set up yy_c_buf_p so that if some
X				 * total hoser (like flex itself) wants
X				 * to call the scanner after we return the
X				 * YY_NULL, it'll still work - another YY_NULL
X				 * will get returned.
X				 */
X				yy_c_buf_p = yytext;
X
X				yy_act = YY_STATE_EOF((yy_start - 1) / 2);
X				goto do_action;
X				}
X
X			    else
X				YY_NEW_FILE;
X			    }
X			    break;
X
X			case EOB_ACT_RESTART_SCAN:
X			    yy_c_buf_p = yytext;
X			    yy_hold_char = *yy_c_buf_p;
X			    break;
X
X			case EOB_ACT_LAST_MATCH:
X			    yy_c_buf_p = &yy_ch_buf[yy_n_chars];
X
X			    yy_current_state = yy_get_previous_state();
X
X			    yy_cp = yy_c_buf_p;
X			    yy_bp = yytext;
X			    continue; /* go to "YY_DO_BEFORE_ACTION" */
X			}
X		    break;
X
X		default:
X		    printf( "action # %d\n", yy_act );
X		    YY_FATAL_ERROR( "fatal flex scanner internal error" );
X		}
X
X	    break; /* exit bogus while loop */
X	    }
X	}
X    }
X
X
X/* yy_get_next_buffer - try to read in new buffer
X *
X * synopsis
X *     int yy_get_next_buffer();
X *     
X * returns a code representing an action
X *     EOB_ACT_LAST_MATCH - 
X *     EOB_ACT_RESTART_SCAN - restart the scanner
X *     EOB_ACT_END_OF_FILE - end of file
X */
X
Xstatic int yy_get_next_buffer()
X
X    {
X    register char *dest = yy_ch_buf;
X    register char *source = yytext - 1; /* copy prev. char, too */
X    register int number_to_move, i;
X    int ret_val;
X    
X    if ( yy_c_buf_p != &yy_ch_buf[yy_n_chars + 1] )
X	{
X	YY_FATAL_ERROR( "NULL in input" );
X	/*NOTREACHED*/
X	}
X
X    /* try to read more data */
X
X    /* first move last chars to start of buffer */
X    number_to_move = yy_c_buf_p - yytext;
X
X    for ( i = 0; i < number_to_move; ++i )
X	*(dest++) = *(source++);
X
X    if ( yy_eof_has_been_seen )
X	/* don't do the read, it's not guaranteed to return an EOF,
X	 * just force an EOF
X	 */
X	yy_n_chars = 0;
X
X    else
X	{
X	int num_to_read = YY_BUF_SIZE - number_to_move - 1;
X
X	if ( num_to_read > YY_READ_BUF_SIZE )
X	    num_to_read = YY_READ_BUF_SIZE;
X
X	/* read in more data */
X	YY_INPUT( (&yy_ch_buf[number_to_move]), yy_n_chars, num_to_read );
X	}
X
X    if ( yy_n_chars == 0 )
X	{
X	if ( number_to_move == 1 )
X	    ret_val = EOB_ACT_END_OF_FILE;
X	else
X	    ret_val = EOB_ACT_LAST_MATCH;
X
X	yy_eof_has_been_seen = 1;
X	}
X
X    else
X	ret_val = EOB_ACT_RESTART_SCAN;
X
X    yy_n_chars += number_to_move;
X    yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
X    yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;
X
X    /* yytext begins at the second character in
X     * yy_ch_buf; the first character is the one which
X     * preceded it before reading in the latest buffer;
X     * it needs to be kept around in case it's a
X     * newline, so yy_get_previous_state() will have
X     * with '^' rules active
X     */
X
X    yytext = &yy_ch_buf[1];
X
X    return ( ret_val );
X    }
X
X
X/* yy_get_previous_state - get the state just before the EOB char was reached
X *
X * synopsis
X *     yy_state_type yy_get_previous_state();
X */
X
Xstatic yy_state_type yy_get_previous_state()
X
X    {
X    register yy_state_type yy_current_state;
X    register char *yy_cp;
X
X    register char *yy_bp = yytext;
X
X    yy_current_state = yy_start;
X    if ( yy_bp[-1] == '\n' )
X	++yy_current_state;
X
X    for ( yy_cp = yytext; yy_cp < yy_c_buf_p; ++yy_cp )
X	{
X	register char yy_c = yy_ec[*yy_cp];
X	if ( yy_accept[yy_current_state] )
X	    {
X	    yy_last_accepting_state = yy_current_state;
X	    yy_last_accepting_cpos = yy_cp;
X	    }
X	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
X	    {
X	    yy_current_state = yy_def[yy_current_state];
X	    if ( yy_current_state >= 274 )
X		yy_c = yy_meta[yy_c];
X	    }
X	yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
X	}
X
X    return ( yy_current_state );
X    }
X
X
X#ifdef __STDC__
Xstatic void yyunput( int c, register char *yy_bp )
X#else
Xstatic void yyunput( c, yy_bp )
Xint c;
Xregister char *yy_bp;
X#endif
X
X    {
X    register char *yy_cp = yy_c_buf_p;
X
X    *yy_cp = yy_hold_char; /* undo effects of setting up yytext */
X
X    if ( yy_cp < yy_ch_buf + 2 )
X	{ /* need to shift things up to make room */
X	register int number_to_move = yy_n_chars + 2; /* +2 for EOB chars */
X	register char *dest = &yy_ch_buf[YY_BUF_SIZE + 2];
X	register char *source = &yy_ch_buf[number_to_move];
X
X	while ( source > yy_ch_buf )
X	    *--dest = *--source;
X
X	yy_cp += dest - source;
X	yy_bp += dest - source;
X
X	if ( yy_cp < yy_ch_buf + 2 )
X	    YY_FATAL_ERROR( "flex scanner push-back overflow" );
X	}
X
X    if ( yy_cp > yy_bp && yy_cp[-1] == '\n' )
X	yy_cp[-2] = '\n';
X
X    *--yy_cp = c;
X
X    YY_DO_BEFORE_ACTION; /* set up yytext again */
X    }
X
X
Xstatic int input()
X
X    {
X    int c;
X    char *yy_cp = yy_c_buf_p;
X
X    *yy_cp = yy_hold_char;
X
X    if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
X	{ /* need more input */
X	yytext = yy_c_buf_p;
X	++yy_c_buf_p;
X
X	switch ( yy_get_next_buffer() )
X	    {
X	    /* this code, unfortunately, is somewhat redundant with
X	     * that above
X	     */
X	    case EOB_ACT_END_OF_FILE:
X		{
X		if ( yywrap() )
X		    {
X		    yy_c_buf_p = yytext;
X		    return ( EOF );
X		    }
X
X		yy_ch_buf[0] = '\n';
X		yy_n_chars = 1;
X		yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
X		yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;
X		yy_eof_has_been_seen = 0;
X		yytext = yy_c_buf_p = &yy_ch_buf[1];
X		yy_hold_char = *yy_c_buf_p;
X
X		return ( input() );
X		}
X		break;
X
X	    case EOB_ACT_RESTART_SCAN:
X		yy_c_buf_p = yytext;
X		break;
X
X	    case EOB_ACT_LAST_MATCH:
X		YY_FATAL_ERROR( "unexpected last match in input()" );
X	    }
X	}
X
X    c = *yy_c_buf_p;
X    yy_hold_char = *++yy_c_buf_p;
X
X    return ( c );
X    }
X
X
X#ifdef __STDC__
Xstatic void yyrestart( FILE *input_file )
X#else
Xstatic void yyrestart( input_file )
XFILE *input_file;
X#endif
X
X    {
X    if ( yyin != stdin )
X	fclose( yyin );
X
X    yyin = input_file;
X    yy_init = 1;
X    }
X# line 127 "lev_comp.l"
X
X#ifdef	AMIGA
Xlong *alloc(n)
X	unsigned n;
X{
X	return ((long *)malloc (n));
X}
X#endif
END_OF_FILE
if test 31273 -ne `wc -c <'others/lev_lex.c'`; then
    echo shar: \"'others/lev_lex.c'\" unpacked with wrong size!
fi
# end of 'others/lev_lex.c'
fi
echo shar: End of archive 25 \(of 56\).
cp /dev/null ark25isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 56 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
