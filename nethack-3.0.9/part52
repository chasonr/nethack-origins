Path: utzoo!utgpu!news-server.csri.toronto.edu!cs.utexas.edu!mailrus!cornell!uw-beaver!zephyr.ens.tek.com!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v10i097:  nethack3p9 -  display oriented dungeons & dragons (Ver. 3.0i), Part52/56
Message-ID: <5957@tekred.CNA.TEK.COM>
Date: 13 Jul 90 19:45:21 GMT
Sender: news@tekred.CNA.TEK.COM
Lines: 2254
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 10, Issue 97
Archive-name: nethack3p9/Part52
Supersedes: NetHack3: Volume 7, Issue 56-93



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 52 (of 56)."
# Contents:  amiga/amitcap.c auxil/cmdhelp auxil/license
#   include/youprop.h others/exesmurf.c others/splitf.c others/termcap
#   src/allmain.c src/exper.c src/search.c src/unixtty.c
# Wrapped by billr@saab on Wed Jul 11 17:12:14 1990
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'amiga/amitcap.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'amiga/amitcap.c'\"
else
echo shar: Extracting \"'amiga/amitcap.c'\" \(4922 characters\)
sed "s/^X//" >'amiga/amitcap.c' <<'END_OF_FILE'
X/*    SCCS Id: @(#)amitcap.c    3.0    89/07/18
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X/* block some unused #defines to avoid overloading some cpp's */
X#define MONATTK_H
X
X#include "hack.h"       /* for ROWNO, COLNO, *HI, *HE, *AS, *AE */
X
X#ifdef LATTICE
X#undef TRUE
X#undef FALSE
X#undef COUNT
X#undef NULL
X#include <proto/dos.h>
X#endif
X
X#ifndef LATTICE
Xextern void FDECL(Delay, (unsigned long));
X#endif
Xextern void NDECL(Initialize);
X
Xstatic char HO[] = "\233H";         /* Home         CSI H */
Xstatic char CL[] = "\f";            /* Clear        FF */
Xstatic char CE[] = "\233K";         /* Erase EOL    CSI K */
Xstatic char UP[] = "\x0B";          /* Cursor up    VT */
Xstatic char ND[] = "\233C";         /* Cursor right CSI C */
Xstatic char XD[] = "\233B";         /* Cursor down  CSI B */
Xstatic char BC[] = "\b";            /* Cursor left  BS */
Xstatic char MR[] = "\2337m";        /* Reverse on   CSI 7 m */
Xstatic char ME[] = "\2330m";        /* Reverse off  CSI 0 m */
X
X#ifdef TEXTCOLOR
Xstatic char SO[] = "\23337m";       /* Use colormap entry #7 (red) */
Xstatic char SE[] = "\2330m";
X#else
Xstatic char SO[] = "\2337m";        /* Inverse video */
Xstatic char SE[] = "\2330m";
X#endif
X
X#ifdef TEXTCOLOR
X/*
X * Map our amiga-specific colormap into the colormap specified in color.h.
X * See amiwind.c for the amiga specific colormap.
X */
Xstatic int foreg[16] = { 0, 7, 4, 2, 6, 5, 3, 1, 0, 0, 0, 0, 0, 0, 0, 0 };
Xstatic int backg[16] = { 1, 0, 0, 0, 0, 0, 0, 0, 1, 7, 4, 2, 6, 5, 3, 1 };
X#endif
X
Xvoid
Xstartup()
X{
X#ifdef TEXTCOLOR
X    register int c;
X#endif
X    (void) Initialize();        /* This opens screen, window, console, &c */
X    CO = COLNO;
X    LI = ROWNO+3;               /* used in pri.c and pager.c */
X
X    set_whole_screen();
X    CD = "\233J";               /* used in pager.c */
X
X#ifdef TEXTCOLOR
X    /*
X     * Perform amiga to color.h colormap conversion - Please note that the
X     * console device can only handle 8 foreground and 8 background colors
X     * while color.h defines 8 basic and 8 hilite colors.  Hilite colors
X     * are handled as inverses.  For instance, a hilited green color will
X     * appear as green background with a black foreground.
X     */
X    for (c = 0; c < SIZE(hilites); c++) {
X        hilites[c] = (char *) alloc(sizeof("E0;33;44m"));
X        Sprintf(hilites[c], "\2333%d;4%dm", foreg[c], backg[c]);
X    }
X
X    HI = "\2331m";              /* Bold (hilight) */
X    HE = "\2330m";              /* Plain */
X#else
X    HI = "\2334m";              /* Underline */
X    HE = "\2330m";              /* Plain */
X#endif
X}
X
Xvoid
Xstart_screen()
X{
X}
X
Xvoid
Xend_screen()
X{
X    clear_screen();
X}
X
X/* Cursor movements */
Xextern xchar curx, cury;
X
Xvoid
Xcurs(x, y)
Xregister int x, y;
X{
X    if (x != curx || y != cury) {
X        /* Test a few simple cases */
X        if (x == 1) {
X            if (y == cury) {
X                putchar('\r');
X                goto done;
X            }
X            if (y == cury+1) {
X                putchar('\n');  /* console.device is in crmod mode */
X                goto done;
X            }
X        } else if (x == curx) {
X            if (y == cury-1) {
X                putchar('\x0B');
X                goto done;
X            }
X            if (y == cury+1) {
X                xputs(XD);
X                goto done;
X            }
X        } else if (y == cury) {
X            if (x == curx-1) {
X                putchar('\b');
X                goto done;
X            }
X            if (x == curx+1) {
X                xputs(ND);
X                goto done;
X            }
X        }
X        {
X            static char CM[] = "\233--;--H";
X            CM[1] = '0' + y/10;   /* Assumes 0 <= y < 100 */
X            CM[2] = '0' + y%10;
X            CM[4] = '0' + x/10;   /* Assumes 0 <= x < 100 */
X            CM[5] = '0' + x%10;
X            xputs(CM);
X        }
X
Xdone:
X        cury = y;
X        curx = x;
X    }
X}
X
Xvoid
Xcl_end()
X{
X    xputs(CE);
X}
X
Xvoid
Xclear_screen()
X{
X    xputs(CL);
X    home();
X}
X
Xvoid
Xhome()
X{
X    xputs(HO);
X    curx = cury = 1;
X}
X
Xvoid
Xstandoutbeg()
X{
X    xputs(SO);
X}
X
Xvoid
Xstandoutend()
X{
X    xputs(SE);
X}
X
Xvoid
Xrevbeg()
X{
X        xputs(MR);
X}
X
X#if 0   /* if you need one of these, uncomment it */
Xvoid
Xboldbeg()
X{
X        xputs("\2331m");        /* CSI 1 m */
X}
X
Xvoid
Xblinkbeg()
X{
X        /* No blink available */
X}
X
Xvoid
Xdimbeg()
X/* not in most termcap entries */
X{
X        /* No dim available, use italics */
X        xputs("\2333m");        /* CSI 3 m */
X}
X#endif
X
Xvoid
Xm_end()
X{
X        xputs(ME);
X}
X
Xvoid
Xbacksp()
X{
X    xputs(BC);
X}
X
Xvoid
Xbell()
X{
X    if (flags.silent) return;
X    (void) putchar('\007');        /* curx does not change */
X    (void) fflush(stdout);
X}
X
Xvoid
Xdelay_output() {
X    /* delay 50 ms */
X    (void) fflush(stdout);
X    Delay(2L);
X}
X
Xvoid
Xcl_eos()
X{                /* must only be called with curx = 1 */
X    xputs(CD);
X}
END_OF_FILE
if test 4922 -ne `wc -c <'amiga/amitcap.c'`; then
    echo shar: \"'amiga/amitcap.c'\" unpacked with wrong size!
fi
# end of 'amiga/amitcap.c'
fi
if test -f 'auxil/cmdhelp' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'auxil/cmdhelp'\"
else
echo shar: Extracting \"'auxil/cmdhelp'\" \(3908 characters\)
sed "s/^X//" >'auxil/cmdhelp' <<'END_OF_FILE'
X^	Show the type of a trap
X^[	Cancel command
X^A	Redo the previous command
X^C	Quit the game
X^D	Kick something (usually a door)
X^E	Search a room (available in debug mode only)
X^F	Map the level (available in debug mode only)
X^G	Create a monster (available in debug mode only)
X^I	Identify all items (available in debug mode only)
X^O	Show location of special levels (available in debug mode only)
X^P	Show previous message printed out
X^R	Redraw screen
X^T	Teleport around level
X^V	Teleport between levels (available in debug mode only)
X^W	Wish (available in debug mode only)
X^X	Show your intrinsic attributes (in debug or explore mode only)
X^Z	Suspend game (only if defined)
Xa	Apply (use) a tool
XA	Remove all Armor
Xb	Go southwest 1 space
XB	Go southwest until you are on top of something
X^B	Go southwest until you are near something
Xc	Close a door
XC	Call (name) a particular monster
Xd	Drop an item
XD	Drop specific item types
Xe	Eat something
XE	Engrave writing on the floor
Xg	Followed by direction, move until you are near something
XG	Followed by direction, same as control-direction
Xh	Go west 1 space
XH	Go west until you are on top of something
X^H	Go west until you are near something
Xi	Show your inventory
XI	Inventory specific item types
Xj	Go south 1 space (or if number_pad is on, jump to another location)
XJ	Go south until you are on top of something
X^J	Go south until you are near something
Xk	Go north 1 space (or if number_pad is on, kick something)
XK	Go north until you are on top of something
X^K	Go north until you are near something
Xl	Go east 1 space (or if number_pad is on, loot a box on the floor)
XL	Go east until you are on top of something
X^L	Go east until you are near something
Xm	Followed by direction, move without picking anything up
XM	Followed by direction, move a distance without picking anything up
Xn	Go southeast 1 space
XN	Go southeast until you are on something (if number_pad, name an object)
X^N	Go southeast until you are near something
Xo	Open a door
XO	Set options (O? explains options)
Xp	Pay your shopping bill
XP	Put on a ring
Xq	Quaff (drink) something
XQ	Quit the game
Xr	Read a scroll (or spell book, if defined)
XR	Remove a Ring
Xs	Search for traps and secret doors
XS	Save the game
Xt	Throw something
XT	Take off one piece of armor
Xu	Go northeast 1 space (or if number_pad is on, untrap something)
XU	Go northeast until you are on top of something
X^U	Go northeast until you are near something
Xv	Show version
XV	Show long version and game history
Xw	Wield (put in use) a weapon
XW	Wear a piece of armor
Xx	List known spells (only if defined)
XX	Enter explore (discovery) mode (only if defined)
Xy	Go northwest 1 space
XY	Go northwest until you are on top of something
X^Y	Go northwest until you are near something
Xz	Zap a wand
XZ	Zap (cast) a spell (only if defined)
X<	Go up a staircase
X>	Go down a staircase
X/	Show what type of thing a symbol corresponds to
X?	Give a help message
X&	Tell what a command does
X!	Do a shell escape (only if defined)
X\	Show what object types have been discovered
X.	Rest one move while doing nothing
X 	Rest one move while doing nothing (if rest_on_space option is on)
X:	Look at what is on the floor
X@	Toggle the pickup option on/off
X)	Show the weapon currently wielded
X[	Show the armor currently worn
X=	Show the ring(s) currently worn
X"	Show the amulet currently worn
X(	Show the tools currently in use
X$	Count your gold
X+	List known spells (only if defined)
X#	Perform an extended command
XM-c	Talk to someone
XM-d	Dip an object into something
XM-f	Force a lock
XM-j	Jump to another location
XM-l	Loot a box on the floor
XM-m	Use a monster's special ability (only if defined)
XM-N	Name an item or type of object
XM-o	Offer a sacrifice to the gods (only if defined)
XM-p	Pray to the gods for help (only if defined)
XM-r	Rub a lamp
XM-s	Sit down
XM-t	Turn undead
XM-u	Untrap something (usually a trapped object)
XM-v	Print compile time options for this version of NetHack
XM-w	Wipe off your face
END_OF_FILE
if test 3908 -ne `wc -c <'auxil/cmdhelp'`; then
    echo shar: \"'auxil/cmdhelp'\" unpacked with wrong size!
fi
# end of 'auxil/cmdhelp'
fi
if test -f 'auxil/license' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'auxil/license'\"
else
echo shar: Extracting \"'auxil/license'\" \(4910 characters\)
sed "s/^X//" >'auxil/license' <<'END_OF_FILE'
X		    NETHACK GENERAL PUBLIC LICENSE
X		 (Copyright 1989, 1990 M. Stephenson)
X
X	       (Based on the BISON general public license,
X		   copyright 1988 Richard M. Stallman)
X
X Everyone is permitted to copy and distribute verbatim copies of this
X license, but changing it is not allowed.  You can also use this wording to
X make the terms for other programs.
X
X  The license agreements of most software companies keep you at the mercy of
Xthose companies.  By contrast, our general public license is intended to give
Xeveryone the right to share NetHack.  To make sure that you get the rights we
Xwant you to have, we need to make restrictions that forbid anyone to deny you
Xthese rights or to ask you to surrender the rights.  Hence this license
Xagreement.
X
X  Specifically, we want to make sure that you have the right to give away
Xcopies of NetHack, that you receive source code or else can get it if you
Xwant it, that you can change NetHack or use pieces of it in new free
Xprograms, and that you know you can do these things.
X
X  To make sure that everyone has such rights, we have to forbid you to
Xdeprive anyone else of these rights.  For example, if you distribute copies
Xof NetHack, you must give the recipients all the rights that you have.  You
Xmust make sure that they, too, receive or can get the source code.  And you
Xmust tell them their rights.
X
X  Also, for our own protection, we must make certain that everyone finds out
Xthat there is no warranty for NetHack.  If NetHack is modified by someone
Xelse and passed on, we want its recipients to know that what they have is
Xnot what we distributed.
X
X  Therefore we (Mike Stephenson and other holders of NetHack copyrights) make
Xthe following terms which say what you must do to be allowed to distribute or
Xchange NetHack.
X
X
X			COPYING POLICIES
X
X  1. You may copy and distribute verbatim copies of NetHack source code as
Xyou receive it, in any medium, provided that you keep intact the notices on
Xall files that refer to copyrights, to this License Agreement, and to the
Xabsence of any warranty; and give any other recipients of the NetHack
Xprogram a copy of this License Agreement along with the program.
X
X  2. You may modify your copy or copies of NetHack or any portion of it, and
Xcopy and distribute such modifications under the terms of Paragraph 1 above
X(including distributing this License Agreement), provided that you also do the
Xfollowing:
X
X    a) cause the modified files to carry prominent notices stating that you
X    changed the files and the date of any change; and
X
X    b) cause the whole of any work that you distribute or publish, that in
X    whole or in part contains or is a derivative of NetHack or any part
X    thereof, to be licensed at no charge to all third parties on terms
X    identical to those contained in this License Agreement (except that you
X    may choose to grant more extensive warranty protection to some or all
X    third parties, at your option)
X
X    c) You may charge a distribution fee for the physical act of
X    transferring a copy, and you may at your option offer warranty protection
X    in exchange for a fee.
X
X  3. You may copy and distribute NetHack (or a portion or derivative of it,
Xunder Paragraph 2) in object code or executable form under the terms of
XParagraphs 1 and 2 above provided that you also do one of the following:
X
X    a) accompany it with the complete machine-readable source code, which
X    must be distributed under the terms of Paragraphs 1 and 2 above; or,
X
X    b) accompany it with full information as to how to obtain the complete
X    machine-readable source code from an appropriate archive site.  (This
X    alternative is allowed only for noncommercial distribution.)
X
XFor these purposes, complete source code means either the full source
Xdistribution as originally released over Usenet or updated copies of the
Xfiles in this distribution used to create the object code or executable.
X
X  4. You may not copy, sublicense, distribute or transfer NetHack except as
Xexpressly provided under this License Agreement.  Any attempt otherwise to
Xcopy, sublicense, distribute or transfer NetHack is void and your rights to
Xuse the program under this License agreement shall be automatically
Xterminated.  However, parties who have received computer software programs
Xfrom you with this License Agreement will not have their licenses terminated
Xso long as such parties remain in full compliance.
X
X
XStated plainly:  You are prohibited by the terms of this License Agreement from
Xusing NetHack for gainful purposes.  You are permitted to modify NetHack, or 
Xotherwise use parts of NetHack, provided that you comply with the conditions 
Xspecified above; in particular, your modified NetHack or program containing
Xparts of NetHack must remain freely available as provided in this License
XAgreement.  In other words, go ahead and share NetHack, but don't try to stop
Xanyone else from sharing it farther.
END_OF_FILE
if test 4910 -ne `wc -c <'auxil/license'`; then
    echo shar: \"'auxil/license'\" unpacked with wrong size!
fi
# end of 'auxil/license'
fi
if test -f 'include/youprop.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/youprop.h'\"
else
echo shar: Extracting \"'include/youprop.h'\" \(4878 characters\)
sed "s/^X//" >'include/youprop.h' <<'END_OF_FILE'
X/*	SCCS Id: @(#)youprop.h	3.0	89/06/24
X/* NetHack may be freely redistributed.  See license for details. */
X/* Copyright (c) 1989 Mike Threepoint */
X
X#ifndef YOUPROP_H
X#define YOUPROP_H
X
X#ifndef PROP_H
X#include "prop.h"
X#endif
X#ifndef PERMONST_H
X#include "permonst.h"
X#endif
X#ifndef MONDATA_H
X#include "mondata.h"
X#endif
X#ifndef PM_H
X#include "pm.h"
X#endif
X
X#ifndef NAMED_ITEMS
X# define defends(attk,uwep)	0
X#endif
X
X/* two pseudo-properties */
X#define Blindfolded	(ublindf)
X#define Punished	(uball)
X
X/* perhaps these #define's should also be generated by makedefs */
X#define HFire_resistance	u.uprops[FIRE_RES].p_flgs
X#ifdef POLYSELF
X#define Fire_resistance	((HFire_resistance) || resists_fire(uasmon) || defends(AD_FIRE,uwep))
X#else
X#define Fire_resistance	((HFire_resistance) || defends(AD_FIRE,uwep))
X#endif
X
X#define HSleep_resistance	u.uprops[SLEEP_RES].p_flgs
X#ifdef POLYSELF
X#define Sleep_resistance	((HSleep_resistance) || resists_sleep(uasmon))
X#else
X#define Sleep_resistance	HSleep_resistance
X#endif
X
X#define HCold_resistance	u.uprops[COLD_RES].p_flgs
X#ifdef POLYSELF
X#define Cold_resistance	((HCold_resistance) || resists_cold(uasmon) || defends(AD_COLD,uwep))
X#else
X#define Cold_resistance	((HCold_resistance) || defends(AD_COLD,uwep))
X#endif
X
X#define HDisint_resistance	u.uprops[DISINT_RES].p_flgs
X#ifdef POLYSELF
X#define Disint_resistance	((HDisint_resistance) || resists_disint(uasmon))
X#else
X#define Disint_resistance	HDisint_resistance
X#endif
X
X#define HShock_resistance	u.uprops[SHOCK_RES].p_flgs
X#ifdef POLYSELF
X#define Shock_resistance	((HShock_resistance) || resists_elec(uasmon) || defends(AD_ELEC,uwep))
X#else
X#define Shock_resistance	((HShock_resistance) || defends(AD_ELEC,uwep))
X#endif
X
X#define HPoison_resistance	u.uprops[POISON_RES].p_flgs
X#ifdef POLYSELF
X#define Poison_resistance	((HPoison_resistance) || resists_poison(uasmon))
X#else
X#define Poison_resistance	(HPoison_resistance)
X#endif
X
X#define Adornment		u.uprops[ADORNED].p_flgs
X
X#define HRegeneration		u.uprops[REGENERATION].p_flgs
X#ifdef POLYSELF
X#define Regeneration		((HRegeneration) || regenerates(uasmon))
X#else
X#define Regeneration		(HRegeneration)
X#endif
X
X#define Searching		u.uprops[SEARCHING].p_flgs
X
X#define HSee_invisible		u.uprops[SEE_INVIS].p_flgs
X#ifdef POLYSELF
X#define See_invisible		((HSee_invisible) || perceives(uasmon))
X#else
X#define See_invisible		(HSee_invisible)
X#endif
X
X#define HInvis			u.uprops[INVIS].p_flgs
X#ifdef POLYSELF
X#define Invis			((HInvis) || u.usym == S_STALKER)
X#else
X#define Invis			(HInvis)
X#endif
X#define Invisible		(Invis && !See_invisible)
X
X#define HTeleportation		u.uprops[TELEPORT].p_flgs
X#ifdef POLYSELF
X#define Teleportation		((HTeleportation) || can_teleport(uasmon))
X#else
X#define Teleportation		(HTeleportation)
X#endif
X
X#define HTeleport_control	u.uprops[TELEPORT_CONTROL].p_flgs
X#ifdef POLYSELF
X#define Teleport_control	((HTeleport_control) || control_teleport(uasmon))
X#else
X#define Teleport_control	(HTeleport_control)
X#endif
X
X#define Polymorph		u.uprops[POLYMORPH].p_flgs
X#define Polymorph_control	u.uprops[POLYMORPH_CONTROL].p_flgs
X
X#define HLevitation		u.uprops[LEVITATION].p_flgs
X#ifdef POLYSELF
X#define Levitation		((HLevitation) || is_floater(uasmon))
X#else
X#define Levitation		(HLevitation)
X#endif
X
X#define Stealth 		u.uprops[STEALTH].p_flgs
X#define Aggravate_monster	u.uprops[AGGRAVATE_MONSTER].p_flgs
X#define Conflict		u.uprops[CONFLICT].p_flgs
X#define Protection		u.uprops[PROTECTION].p_flgs
X#define Protection_from_shape_changers	u.uprops[PROT_FROM_SHAPE_CHANGERS].p_flgs
X#define Warning 		u.uprops[WARNING].p_flgs
X
X#define HTelepat		u.uprops[TELEPAT].p_flgs
X#ifdef POLYSELF
X#define Telepat 		((HTelepat) || (u.umonnum == PM_FLOATING_EYE))
X#else
X#define Telepat 		(HTelepat)
X#endif
X
X#define Fast			u.uprops[FAST].p_flgs
X
X#define HStun			u.uprops[STUN].p_flgs
X#ifdef POLYSELF
X#define Stunned 	((HStun) || u.usym == S_BAT || u.usym == S_STALKER)
X#else
X#define Stunned 		(HStun)
X#endif
X
X#define HConfusion		u.uprops[CONFUSION].p_flgs
X#define Confusion		(HConfusion)
X
X#define Sick			u.uprops[SICK].p_flgs
X#define Blinded 		u.uprops[BLINDED].p_flgs
X#define Blind			(Blinded || Blindfolded)
X#define Sleeping		u.uprops[SLEEPING].p_flgs
X#define Wounded_legs		u.uprops[WOUNDED_LEGS].p_flgs
X#define Stoned			u.uprops[STONED].p_flgs
X#define Strangled		u.uprops[STRANGLED].p_flgs
X#define Hallucination		u.uprops[HALLUC].p_flgs
X#define Fumbling		u.uprops[FUMBLING].p_flgs
X#define Jumping 		u.uprops[JUMPING].p_flgs
X#define Wwalking		u.uprops[WWALKING].p_flgs
X#define Hunger			u.uprops[HUNGER].p_flgs
X#define Glib			u.uprops[GLIB].p_flgs
X#define Reflecting		u.uprops[REFLECTING].p_flgs
X#define Lifesaved		u.uprops[LIFESAVED].p_flgs
X#define Antimagic		u.uprops[ANTIMAGIC].p_flgs
X#define Displaced		u.uprops[DISPLACED].p_flgs
X#define Clairvoyant		u.uprops[CLAIRVOYANT].p_flgs
X#define Vomiting		u.uprops[VOMITING].p_flgs
X
X#endif /* YOUPROP_H /**/
END_OF_FILE
if test 4878 -ne `wc -c <'include/youprop.h'`; then
    echo shar: \"'include/youprop.h'\" unpacked with wrong size!
fi
# end of 'include/youprop.h'
fi
if test -f 'others/exesmurf.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'others/exesmurf.c'\"
else
echo shar: Extracting \"'others/exesmurf.c'\" \(5158 characters\)
sed "s/^X//" >'others/exesmurf.c' <<'END_OF_FILE'
X/******************************************************************************
X*									      *
X*			  EXE header list and modify			      *
X*									      *
X*			 by Pierre Martineau, 90/05/20			      *
X*									      *
X*				 Version 1.1				      *
X*									      *
X*			  Placed in the public domain			      *
X*									      *
X******************************************************************************/
X
X#include <string.h>
X#include <stdlib.h>
X#include <stdio.h>
X#include <math.h>
X
X#define BOOLEAN int
X#define TRUE	1
X#define FALSE	0
X
XFILE *wrkfile;
Xlong min, max, stk;
XBOOLEAN listflg = FALSE;
XBOOLEAN minflg = FALSE;
XBOOLEAN maxflg = FALSE;
XBOOLEAN stkflg = FALSE;
X
Xstruct exehdr {
Xunsigned signature;
Xunsigned mod512;
Xunsigned pages;
Xunsigned relocitems;
Xunsigned headerparas;
Xunsigned minalloc;
Xunsigned maxalloc;
Xunsigned ss;
Xunsigned sp;
Xunsigned checksum;
Xunsigned ip;
Xunsigned cs;
Xunsigned relocptr;
Xunsigned ovlnum;
X} exehdr_area;
X
Xmain(argc, argv)
Xint argc;
Xchar *argv[];
X{
Xchar *dot, *slash;
Xchar fname[128];
Xchar *args;
Xint i;
Xlong offset, oldstk;
X
X    printf("EXE list and modify V1.1, by Pierre Martineau, 90/05/20.\n");
X    printf("This program is public domain and may be freely distributed.\n");
X
X    if ((argc < 2) || (argc > 6)) {
X	usage();
X	return;
X    }
X
X/*  Extract filename from first argumemt  */
X
X    strcpy(fname, argv[1]);
X    dot = strrchr(fname, '.');
X    slash = strrchr(fname, '\\');
X    if ((dot == NULL) || (slash > dot))
X	strcat(fname, ".exe");
X
X    if ((wrkfile = fopen(fname, "r+b")) == NULL) {
X	printf("\nCouldn't open file %s\n", fname);
X	return;
X    }
X
X/*  Process any remaining arguments  */
X
X    if (argc == 2)
X	listflg = TRUE;
X    else {
X	i = 2;
X	while (argc-- > 2) {
X	    args = argv[i];
X	    if ((args[0] != '-') && (args[0] != '/')) {
X		printf("\nInvalid switch in paramater %s!\n", argv[i]);
X		usage();
X		return;
X	    }
X	    args++;
X	    if (strnicmp(args, "min", 3) == 0) {
X		args += 3;
X		min = atol(args);
X		minflg = TRUE;
X	    }
X	    else if (strnicmp(args, "max", 3) == 0) {
X		args += 3;
X		max = atol(args);
X		maxflg = TRUE;
X	    }
X	    else if (strnicmp(args, "stk", 3) == 0) {
X		args += 3;
X		stk = atol(args);
X		stkflg = TRUE;
X	    }
X	    else if (strnicmp(args, "v", 1) == 0)
X		listflg = TRUE;
X	    else {
X		printf("\nInvalid paramater %s!\n", argv[i]);
X		usage();
X		return;
X	    }
X	    i++;
X	}
X    }
X
X    fread(&exehdr_area, sizeof (struct exehdr), 1, wrkfile);
X    if (exehdr_area.signature != 0x5a4d) {
X	printf("\nNot an EXE file!\n");
X	return;
X    }
X    while(!feof(wrkfile)) {
X	if (listflg)
X	    show_hdr();
X	if ((minflg || maxflg || stkflg) && (exehdr_area.ovlnum == 0) && (exehdr_area.signature == 0x5a4d)) {
X	    if (minflg)
X		exehdr_area.minalloc = min;
X	    if (maxflg)
X		exehdr_area.maxalloc = max;
X	    if (stkflg) {
X		oldstk = exehdr_area.sp;
X		exehdr_area.sp = stk;
X		if (!minflg) {
X		    exehdr_area.minalloc += ((stk - oldstk) / 16);
X		    printf("\nAdjusting size of minalloc!\n");
X		}
X	    }
X	    fseek(wrkfile, ftell(wrkfile) - sizeof (struct exehdr), SEEK_SET);
X	    fwrite(&exehdr_area, sizeof (struct exehdr), 1, wrkfile);
X	    if (ferror(wrkfile)) {
X		printf("Write error while trying to update header!\n");
X		fclose(wrkfile);
X		return;
X	    }
X	}
X	offset = exehdr_area.pages;
X	offset *= 512L;
X	offset -= sizeof(struct exehdr);
X	fseek(wrkfile, offset, SEEK_CUR);
X	fread(&exehdr_area, sizeof (struct exehdr), 1, wrkfile);
X	if (ferror(wrkfile)) {
X	    printf("Read error while trying to get a header!\n");
X	    fclose(wrkfile);
X	    return;
X	}
X    }
X    fclose(wrkfile);
X}
X
Xshow_hdr()
X{
Xlong lsize;
X
X    lsize = exehdr_area.pages;
X    if (exehdr_area.mod512 != 0)
X	lsize--;
X    lsize *= 512L;
X    lsize += exehdr_area.minalloc * 16;
X    lsize += exehdr_area.mod512;
X    lsize -= exehdr_area.headerparas * 16;
X
X    printf("\nOverlay: %d\n", exehdr_area.ovlnum);
X    printf("--------\n");
X    printf("Size (512 byte pages)\t-%6x\t\t%6u\n", exehdr_area.pages, exehdr_area.pages);
X    printf("Remainder (last page)\t-%6x\t\t%6u\n", exehdr_area.mod512, exehdr_area.mod512);
X    printf("Header size (in paras)\t-%6x\t\t%6u\n", exehdr_area.headerparas, exehdr_area.headerparas);
X    printf("Minalloc (in paras)\t-%6x\t\t%6u\n", exehdr_area.minalloc, exehdr_area.minalloc);
X    printf("Maxalloc (in paras)\t-%6x\t\t%6u\n", exehdr_area.maxalloc, exehdr_area.maxalloc);
X    printf("Load size (in bytes)\t-%6lx\t\t%6lu\n", lsize, lsize);
X    printf("Relocation items\t-%6x\t\t%6u\n", exehdr_area.relocitems, exehdr_area.relocitems);
X    printf("Relocation table offset\t-%6x\t\t%6u\n", exehdr_area.relocptr, exehdr_area.relocptr);
X    printf("Checksum\t\t-%6x\t\t%6u\n", exehdr_area.checksum, exehdr_area.checksum);
X    printf("Initial CS:IP\t\t-  %04x:%04x\n", exehdr_area.cs, exehdr_area.ip);
X    printf("Initial SS:SP\t\t-  %04x:%04x\n", exehdr_area.ss, exehdr_area.sp);
X}
X
Xusage()
X{
X    printf("\nUsage: exesmurf exe_file [/v] [/min#####] [/max#####] [/stk#####]\n");
X    printf("       where: min   = minalloc\n");
X    printf("              max   = maxalloc\n");
X    printf("              stk   = stack size\n");
X    printf("              ##### = decimal number of paragraphs.\n");
X}
END_OF_FILE
if test 5158 -ne `wc -c <'others/exesmurf.c'`; then
    echo shar: \"'others/exesmurf.c'\" unpacked with wrong size!
fi
# end of 'others/exesmurf.c'
fi
if test -f 'others/splitf.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'others/splitf.c'\"
else
echo shar: Extracting \"'others/splitf.c'\" \(4920 characters\)
sed "s/^X//" >'others/splitf.c' <<'END_OF_FILE'
X/******************************************************************************
X*									      *
X*			File Splitter and Re-assembler			      *
X*									      *
X*			by Pierre Martineau, 90/05/20			      *
X*									      *
X*				 Version 1.1				      *
X*									      *
X*			 Placed in the public domain			      *
X*									      *
X******************************************************************************/
X
X#include <sys\types.h>
X#include <sys\stat.h>
X#include <string.h>
X#include <stdlib.h>
X#include <stdio.h>
X#include <math.h>
X
XFILE *infile, *outfile;
Xchar fname[16];
Xchar chunk_name[16];
Xint extent = 0;
Xlong hunk_size;
Xunsigned buflen = 0x8000;
Xchar *buf = 0;
X
Xmain(argc, argv)
Xint argc;
Xchar *argv[];
X{
Xstruct stat stat_buf;
Xchar *cptr;
X
X    printf("File Splitter and Re-assembler V1.1, by Pierre Martineau, 90/05/20.\n");
X    printf("This program is public domain and may be freely distributed.\n");
X    if ((argc < 2) || (argc > 3)) {
X	printf("\nUsage: splitf file_to_split [chunk_size]\n");
X	printf("       If chunk_size isn't specified, the file will be split\n");
X	printf("       into two files of (approximately) equal size.\n\n");
X	printf("       splitf dest_file /r\n");
X	printf("       /r will re-assemble the parts back into the whole\n");
X	printf("       specified by dest_file.\n");
X	return;
X    }
X
X/*  Extract filename from first argumemt  */
X
X    if ((cptr = strrchr(argv[1], '\\')) == NULL)
X	cptr = argv[1];
X    else
X	cptr++;
X    strcpy(fname, cptr);
X    if ((cptr = strchr(fname, '.')) != NULL)
X	*++cptr = '\000';
X    else
X	strcat(fname, ".");
X
X    if ((argc == 3) && ((strcmpi(argv[2], "-r") == 0) || (strcmpi(argv[2], "/r") == 0))) {
X	getbuf();
X	printf("\nRe-assembling %s ...\n\n", argv[1]);
X	copy_hunks(argv[1]);
X	fclose(outfile);
X	freebuf();
X	printf("\nDone.\n");
X    }
X    else {
X	getbuf();
X	if ((infile = fopen(argv[1], "rb")) == NULL) {
X	    printf("\nCouldn't open input file!\n");
X	    return;
X	}
X	if (stat(argv[1], &stat_buf) != 0) {
X	    printf("\nBad file handle!\n");
X	    return;
X	}
X	if (argc == 3)
X	    hunk_size = atol(argv[2]);
X	else
X	    hunk_size = (stat_buf.st_size / 2) + 1;
X	if (hunk_size < 1) {
X	    printf("\nInvalid chunk size!\n");
X	    return;
X	}
X	printf("\nSplitting %s ...\n\n", argv[1]);
X	write_hunks();
X	fclose(infile);
X	freebuf();
X	printf("\nDone.\n");
X    }
X}
X
Xwrite_hunks()
X{
Xlong size;
Xunsigned bufsize;
Xunsigned numread;
X
X    for (;;) {
X	if(!next_file()) {
X	    printf("Too many files, please specify a chunk size that\n");
X	    printf("will result in fewer than 1000 output files!\n");
X	    return;
X	}
X	if ((outfile = fopen(chunk_name, "wb")) == NULL) {
X	    printf("Unable to create output file %s\n", chunk_name);
X	    return;
X	}
X	size = hunk_size;
X	numread = 1;
X	while(size > 0 && numread /* Work around TC idiot-syncracy */) {
X	    bufsize = size < buflen ? size : buflen;
X	    numread = fread(buf, sizeof(char), bufsize, infile);
X	    if (ferror(infile)) {
X		printf("Error while reading input file %s\n", chunk_name);
X		fclose(outfile);
X		return;
X	    }
X	    fwrite(buf, sizeof(char), numread, outfile);
X	    if (ferror(outfile)) {
X		printf("Error while writing output file!\n");
X		fclose(outfile);
X		return;
X	    }
X	    size -= numread;
X	    if (numread != bufsize) {
X		printf("    Writing %ld bytes to %s\n", hunk_size-size, chunk_name);
X		fclose(outfile);
X		return;
X	    }
X	}
X	fclose(outfile);
X	printf("    Writing %ld bytes to %s\n", hunk_size-size, chunk_name);
X    }
X}
X
Xcopy_hunks(filename)
Xchar *filename;
X{
Xunsigned numread;
X
X    if(!next_file())
X	return;
X    if ((infile = fopen(chunk_name, "rb")) == NULL) {
X	printf("Nothing to do!\n");
X	return;
X    }
X    if ((outfile = fopen(filename, "wb")) == NULL) {
X	printf("Couldn't open output file!\n");
X	return;
X    }
X    for (;;) {
X	numread = 1;
X	while(!feof(infile) && numread /* Avoid TC problem */) {
X	    numread = fread(buf, sizeof(char), buflen, infile);
X	    if (ferror(infile)) {
X		printf("Error while reading input file %s\n", chunk_name);
X		fclose(infile);
X		return;
X	    }
X	    fwrite(buf, sizeof(char), numread, outfile);
X	    if (ferror(outfile)) {
X		printf("Error while writing output file!\n");
X		fclose(infile);
X		return;
X	    }
X	}
X	printf("    Copying file %s to output file.\n", chunk_name);
X	fclose(infile);
X	if(!next_file())
X	    return;
X	if ((infile = fopen(chunk_name, "rb")) == NULL)
X	    return;
X	    
X    }
X}
X
Xnext_file()
X{
Xchar num[4];
X
X    if (extent > 999)
X	return(0);
X    strcpy(chunk_name, fname);
X    itoa(extent,num, 10);
X    if (strlen(num) == 1) {
X	strcat(chunk_name, "00");
X	strcat(chunk_name, num);
X    }
X    else if (strlen(num) == 2) {
X	strcat(chunk_name, "0");
X	strcat(chunk_name, num);
X    }
X    else
X	strcat(chunk_name, num);
X    ++extent;
X    return(-1);
X}
X
Xgetbuf()
X{
X    while (buflen >= 256 && !(buf = malloc(buflen)))
X	buflen >>= 1;
X    if (!buf) {
X	printf("\nCan't allocate an adequate copy buffer.\n");
X	exit(2);
X	}
X}
X
Xfreebuf()
X{
X    free(buf);
X}
X
END_OF_FILE
if test 4920 -ne `wc -c <'others/splitf.c'`; then
    echo shar: \"'others/splitf.c'\" unpacked with wrong size!
fi
# end of 'others/splitf.c'
fi
if test -f 'others/termcap' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'others/termcap'\"
else
echo shar: Extracting \"'others/termcap'\" \(5356 characters\)
sed "s/^X//" >'others/termcap' <<'END_OF_FILE'
X#
X#	MS/PC-DOS ANSI.SYS termcap
X#
Xansi|color|ansi-color|ibm|ibmpc|ANSI.SYS color:\
X	:co#80:li#24:bs:pt:bl=^G:le=^H:do=^J:\
X	:cl=\E[H\E[2J:ce=\E[K:\
X	:ho=\E[H:cm=\E[%i%d;%dH:\
X	:up=\E[A:do=\E[B:le=\E[C:ri=\E[D:nd=\E[C:\
X	:ti=\E[0;44m:te=\E[0m:\
X	:so=\E[1;35;44m:se=\E[0;44m:\
X	:us=\E[1;31;44m:ue=\E[0;44m:\
X	:mb=\E[5m:md=\E[1m:me=\E[0;44m:
Xmono|ansi-mono|ANSI.SYS:\
X	:co#80:li#24:bs:pt:bl=^G:le=^H:do=^J:\
X	:cl=\E[H\E[2J:ce=\E[K:\
X	:ho=\E[H:cm=\E[%i%d;%dH:\
X	:up=\E[A:do=\E[B:le=\E[C:ri=\E[D:nd=\E[C:\
X	:so=\E[1m:se=\E[m:us=\E[4m:ue=\E[m:\
X	:mb=\E[5m:md=\E[1m:me=\E[m:
X#
X#	This is a termcap for NNANSI.SYS (New & Improved NANSI.SYS),
X#	a faster and more complete public domain replacement for
X#	ANSI.SYS, and two other ANSI.SYS replacements, NANSI.SYS and
X#	ZANSI.SYS.
X#
X#	NANSI and ZANSI support line insert (al) and delete (dl)
X#	and character insert (ic) and delete (dc) where ANSI.SYS
X#	does not.  NNANSI.SYS also supports clear to end of display
X#	(cd), does reverse video (mr) properly, and emulates SGR
X#	more fully, allowing correct end sequences for standout (se)
X#	and end of underline (ue).
X#
Xnnansi-mono|NNANSI.SYS:\
X	:co#80:li#25:bs:pt:bl=^G:le=^H:do=^J:\
X	:cl=\E[2J:cd=\E[J:ce=\E[K:\
X	:ho=\E[H:cm=\E[%i%d;%dH:\
X	:up=\E[A:do=\E[B:le=\E[C:ri=\E[D:nd=\E[C:\
X	:so=\E[1m:se=\E[2m:\
X	:us=\E[4m:ue=\E[24m:\
X	:mb=\E[5m:md=\E[1m:mh=\E[2m:mr=\E[7m:me=\E[m:\
X	:al=\E[L:dl=\E[M:ic=\E[@:dc=\E[P:
Xnnansi|NNANSI.SYS color:\
X	:co#80:li#25:bs:pt:bl=^G:le=^H:do=^J:\
X	:cl=\E[2J:cd=\E[J:ce=\E[K:\
X	:ho=\E[H:cm=\E[%i%d;%dH:\
X	:up=\E[A:do=\E[B:le=\E[C:ri=\E[D:nd=\E[C:\
X	:ti=\E[0;44m:te=\E[0m:\
X	:so=\E[1;35;44m:se=\E[2;37m:\
X	:us=\E[4m:ue=\E[24m:\
X	:mb=\E[5m:md=\E[1m:mh=\E[2m:mr=\E[7m:me=\E[0;44m:\
X	:al=\E[L:dl=\E[M:ic=\E[@:dc=\E[P:
Xnansi-mono|zansi-mono|N/ZANSI.SYS:\
X	:co#80:li#25:bs:pt:bl=^G:le=^H:do=^J:\
X	:cl=\E[2J:ce=\E[K:\
X	:ho=\E[H:cm=\E[%i%d;%dH:\
X	:up=\E[A:do=\E[B:le=\E[C:ri=\E[D:nd=\E[C:\
X	:ti=\E[0m:te=\E[0m:\
X	:so=\E[1;35m:se=\E[0m:\
X	:us=\E[1;31m:ue=\E[0m:\
X	:mb=\E[5m:md=\E[1m:mr=\E[7m:me=\E[m:\
X	:al=\E[L:dl=\E[M:ic=\E[@:dc=\E[P:
Xnansi|zansi|N/ZANSI.SYS color:\
X	:co#80:li#25:bs:pt:bl=^G:le=^H:do=^J:\
X	:cl=\E[2J:ce=\E[K:\
X	:ho=\E[H:cm=\E[%i%d;%dH:\
X	:up=\E[A:do=\E[B:le=\E[C:ri=\E[D:nd=\E[C:\
X	:ti=\E[0;44m:te=\E[0m:\
X	:so=\E[1;35;44m:se=\E[0;44m:\
X	:us=\E[1;31;44m:ue=\E[0;44m:\
X	:mb=\E[5m:md=\E[1m:mr=\E[7m:me=\E[0;44m:\
X	:al=\E[L:dl=\E[M:ic=\E[@:dc=\E[P:
X#
X# For ST NetHack:
X#       for VT100/200/&c in VT52 mode, add :ti=\E[?2l:
Xvt52|atari|DEC VT52:\
X	:co#80:li#24:bs:pt:bl=^G:le=^H:do=^J:\
X	:cl=\EH\EJ:ce=\EK:cd=\EJ:\
X	:ho=\EH:cm=\EY%+ %+ :\
X	:up=\EA:do=\EB:le=\EC:ri=\ED:nd=\EC:\
X	:ku=\EA:kd=\EB:kl=\EC:kr=\ED:kb=^H:\
X	:sr=\EI:as=\EF:ae=\EG:
X#
X# For Amiga or VMS NetHack:
X#       VT100 or clone without the advanced video option installed
Xvt100|amiga|vt100-80|vt100-noavo|DEC VT100:\
X	:co#80:li#24:bs:pt:am:mi:bl=^G:le=^H:do=^J:xo:vt#3:\
X	:cl=50\E[H\E[J:ce=3\E[K:cd=50\E[J:\
X	:ho=\E[H:cm=5\E[%i%d;%dH:cs=\E[%i%d;%dr:\
X	:up=\E[A:do=\E[B:le=\E[C:ri=\E[D:nd=\E[C:\
X	:UP=\E[%dA:DO=\E[%dB:LE=\E[%dC:RI=\E[%dD:\
X	:so=2\E[7m:se=2\E[m:us=2\E[4m:ue=2\E[m:\
X	:mb=2\E[5m:md=2\E[1m:mr=2\E[7m:me=2\E[m:\
X	:ti=4\E<\E(B\E)0:as=^N:ae=^O:\
X	:ks=\E[?1h\E=:ke=\E[?11\E>:ku=\E[A:kd=\E[B:kl=\E[C:kr=\E[D:kb=^H:\
X	:kn#4:k1=\EOP:k2=\EOQ:k3=\EOR:k4=\EOS:\
X	:sc=\E7:ec=\E8:sr=5\EM:
X#
X# VT102 and up:
X#       includes VT100 with advanced video option
Xvt102|vt102-80|vt100-avo|DEC VT102:\
X	:im=\E[4h:ei=\E[4l:al=5\E[L:dl=5\E[M:dc=5\E[P:\
X	:AL=9\E[%dL:DL=9\E[%dM:tc=vt100:
Xvt200|vt200-80|vt220|vt240|vt241|VT200_Series:\
X	:ic=5\E[@:tc=vt102:
Xvt300|vt300-80|vt320|vt330|vt340|VT300_Series:\
X	:tc=vt200:
X# VAXstations (should have full entries with no delays and 8-bit CSI's)
XVWS|UIS:tc=vt200:
XDECterm:tc=vt300:
X#
X# Wide screen (magnifying glass not included;-)
X#       note: vt100 w/o AVO only supports 14 lines when in 132-column mode
Xvt132|vt100-132:vt102-132:\
X	:co#132:ti=9\E<\E(B\E)0\E[?3h:tc=vt102:
Xvt200-132|vt300-132:\
X	:co#132:ti=9\E<\E(B\E)0\E[?3h:tc=vt200:
X#
X#
X# For really complete ANSI emulations (FANSI-CONSOLE?):
X#
XAX|ANSI X3.64|full ANSI X3.64 (1977) standard:\
X	:co#80:li#24:bs:pt:am:mi:bl=^G:le=^H:\
X	:cl=\E[2J:ce=\E[K:cd=\E[J:\
X	:ho=\E[H:cm=\E[%i%d;%dH:cs=\E[%i%d;%dr:\
X	:up=\E[A:do=\E[B:le=\E[C:ri=\E[D:nd=\E[C:\
X	:UP=\E[%dA:DO=\E[%dB:LE=\E[%dC:RI=\E[%dD:\
X	:so=\E[7m:se=\E[m:us=\E[4m:ue=\E[m:\
X	:mb=\E[5m:md=\E[1m:mr=\E[7m:me=\E[m:as=^N:ae=^O:\
X	:ku=\E[A:kd=\E[B:kl=\E[C:kr=\E[D:kb=^H:\
X	:kn#4:k1=\EOP:k2=\EOQ:k3=\EOR:k4=\EOS:\
X	:im=\E[4h:ei=\E[4l:al=\E[L:dl=\E[M:ic=\E[@:dc=\E[P:sf=\ED:sr=\EM:
X#
X# Display hacker's tool
X#
Xdebug|debugging entry:\
X	:ae=<ae>:AL=<AL%d>:al=<al>:am:as=<as>:bl=<bl>:bs:bt=<bt>:bw:CC=<CC>:\
X	:cd=<cd>:ce=<ce>:ch=<ch%d>:cl=<cl>:cm=<cm%d,%d>:co#80:cr=<cr>:\
X	:cs=<cs%d,%d>:ct=<ct>:cv=<cv%d>:da:db:DC=<DC%d>:dc=<dc>:DL=<DL%d>:\
X	:dl=<dl>:dm=<dm>:DO=<DO%d>:do=<do>:ds=<ds>:ec=<ec%d>:ed=<ed>:ei=<ei>:\
X	:es:fs=<fs>:ho=<ho>:hs:IC=<IC%d>:ic=<ic>:im=<im>:ip=<ip>:is=<is>:\
X	:it#8:ke=<ke>:LE=<LE%d>:le=<le>:li#24:ll=<ll>:mb=<mb>:md=<md>:me=<me>:\
X	:mh=<mh>:mi:mk=<mk>:mm=<mm>:mo=<mo>:mp=<mp>:mr=<mr>:ms=<ms>:nd=<nd>:\
X	:nw=<nw>:pc=<pc>:pf=<pf>:pO=<pO%d>:po=<po>:ps=<ps>:rc=<rc>:RI=<RI%d>:\
X	:rp=<rp%.%d>:rs=<rs>:sc=<sc>:se=<se>:SF=<SF%d>:sf=<sf>:so=<so>:\
X	:SR=<SR%d>:sr=<sr>:st=<st>:ta=<ta>:te=<te>:ti=<ti>:uc=<uc>:ue=<ue>:\
X	:UP=<UP%d>:up=<up>:us=<us>:vb=<vb>:ve=<ve>:vi=<vi>:vs=<vs>:
X#
Xdumb:\
X	:am:bl=^G:co#80:do=^J:nl=^M^J:
END_OF_FILE
if test 5356 -ne `wc -c <'others/termcap'`; then
    echo shar: \"'others/termcap'\" unpacked with wrong size!
fi
# end of 'others/termcap'
fi
if test -f 'src/allmain.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/allmain.c'\"
else
echo shar: Extracting \"'src/allmain.c'\" \(5069 characters\)
sed "s/^X//" >'src/allmain.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)allmain.c	3.0	89/12/22
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X/* various code that was replicated in *main.c */
X
X#include "hack.h"
X
X#ifndef NO_SIGNAL
X#include <signal.h>
X#endif
X
X#ifdef OVLB
Xint NDECL((*afternmv));
Xint NDECL((*occupation));
X#endif
X
X#ifdef OVL0
X
Xvoid
Xmoveloop()
X{
X#ifdef MSDOS
X	char ch;
X	int abort_lev;
X#endif
X
X	for(;;) {
X#ifdef MACOS
X	extern	Boolean	lowMem;
X	extern	long	lowMemLimit;
X	if (!(moves % 20) || lowMem || FreeMem() < lowMemLimit) {
X		long tmp = 0;
X
X		freeSegs(&tmp);
X	}
X#endif
X#ifdef CLIPPING
X		cliparound(u.ux, u.uy);
X#endif
X		if(flags.move) {	/* actual time passed */
X
X#ifdef SOUNDS
X			dosounds();
X#endif
X			settrack();
X
X			if(moves%2 == 0 ||
X			  (!(Fast & ~INTRINSIC) && (!Fast || rn2(3)))) {
X				movemon();
X#ifdef HARD
X				if(!rn2(u.udemigod?25:(dlevel>30)?50:70))
X#else
X				if(!rn2(70))
X#endif
X				    (void) makemon((struct permonst *)0, 0, 0);
X				++monstermoves;
X			}
X			if(Glib) glibr();
X			timeout();
X			++moves;
X#ifdef THEOLOGY
X			if (u.ublesscnt)  u.ublesscnt--;
X#endif
X			if(flags.time) flags.botl = 1;
X#ifdef POLYSELF
X			if(u.mtimedone)
X			    if(u.mh < 1) rehumanize();
X			else
X#endif
X			    if(u.uhp < 1) {
X				You("die...");
X				done(DIED);
X			    }
X#ifdef POLYSELF
X			if (u.mtimedone) {
X			    if (u.mh < u.mhmax) {
X				if (Regeneration || !(moves%20)) {
X					flags.botl = 1;
X					u.mh++;
X				}
X			    }
X			}
X#endif
X			if(u.uhp < u.uhpmax) {
X				if(u.ulevel > 9) {
X				    int heal;
X
X				    if(HRegeneration || !(moves%3)) {
X					flags.botl = 1;
X					if (ACURR(A_CON) <= 12) heal = 1;
X					else heal = rnd((int) ACURR(A_CON)-12);
X					if (heal > u.ulevel-9) heal = u.ulevel-9;
X					u.uhp += heal;
X					if(u.uhp > u.uhpmax)
X					    u.uhp = u.uhpmax;
X				    }
X				} else if(HRegeneration ||
X					(!(moves%((MAXULEV+12)/(u.ulevel+2)+1)))) {
X					flags.botl = 1;
X					u.uhp++;
X				}
X			}
X#ifdef SPELLS
X			if ((u.uen<u.uenmax) && (!(moves%(19-ACURR(A_INT)/2)))) {
X				u.uen += rn2((int)ACURR(A_WIS)/5 + 1) + 1;
X				if (u.uen > u.uenmax)  u.uen = u.uenmax;
X				flags.botl = 1;
X			}
X#endif
X			if(Teleportation && !rn2(85)) tele();
X#ifdef POLYSELF
X			if(Polymorph && !rn2(100))
X				polyself();
X			if(u.ulycn >= 0 && !rn2(80 - (20 * night())))
X				you_were();
X#endif
X			if(Searching && multi >= 0) (void) dosearch0(1);
X			hatch_eggs();
X			gethungry();
X			invault();
X			amulet();
X#ifdef HARD
X			if (!rn2(40+(int)(ACURR(A_DEX)*3))) u_wipe_engr(rnd(3));
X			if (u.udemigod) {
X				if (u.udg_cnt) u.udg_cnt--;
X				if (!u.udg_cnt) {
X					intervene();
X					u.udg_cnt = rn1(200, 50);
X				}
X			}
X#endif
X			restore_attrib();
X		}
X		if(multi < 0) {
X			if(!++multi){
X				pline(nomovemsg ? nomovemsg :
X					"You can move again.");
X				nomovemsg = 0;
X				if(afternmv) (*afternmv)();
X				afternmv = 0;
X			}
X		}
X
X		find_ac();
X		if(!flags.mv || Blind)
X		{
X			seeobjs();
X			seemons();
X			seeglds();
X			nscr();
X		}
X		if(flags.botl || flags.botlx) bot();
X
X		flags.move = 1;
X
X		if(multi >= 0 && occupation) {
X#ifdef MSDOS
X			abort_lev = 0;
X			if (kbhit()) {
X				if ((ch = Getchar()) == ABORT)
X					abort_lev++;
X# ifdef REDO
X				else
X					pushch(ch);
X# endif /* REDO */
X			}
X			if (!abort_lev && (*occupation)() == 0)
X#else
X			if ((*occupation)() == 0)
X#endif
X				occupation = 0;
X#ifdef MSDOS
X			if(abort_lev || monster_nearby()) {
X#else
X			if(monster_nearby()) {
X#endif
X				stop_occupation();
X				reset_eat();
X			}
X#ifdef MSDOS
X			if (!(++occtime % 7))
X				(void) fflush(stdout);
X#endif
X			continue;
X		}
X
X		if((u.uhave_amulet || Clairvoyant) && 
X#ifdef ENDGAME
X			dlevel != ENDLEVEL &&
X#endif
X			!(moves%15) && !rn2(2)) do_vicinity_map();
X
X		u.umoved = FALSE;
X		if(multi > 0) {
X			lookaround();
X			if(!multi) {	/* lookaround may clear multi */
X				flags.move = 0;
X				continue;
X			}
X			if(flags.mv) {
X				if(multi < COLNO && !--multi)
X					flags.mv = flags.run = 0;
X				domove();
X			} else {
X				--multi;
X				rhack(save_cm);
X			}
X		} else if(multi == 0) {
X#ifdef MAIL
X			ckmailstatus();
X#endif
X			rhack(NULL);
X		}
X		if(multi && multi%7 == 0)
X			(void) fflush(stdout);
X	}
X}
X
X#endif /* OVL0 */
X#ifdef OVL1
X
Xvoid
Xstop_occupation()
X{
X	if(occupation) {
X		You("stop %s.", occtxt);
X		occupation = 0;
X		sync_hunger();
X#ifdef REDO
X		multi = 0;
X		pushch(0);
X#endif
X	}
X}
X
X#endif /* OVL1 */
X#ifdef OVLB
X
Xvoid
Xnewgame() {
X#ifdef DGK
X	gameDiskPrompt();
X#endif
X
X	fobj = fcobj = invent = 0;
X	fmon = fallen_down = 0;
X	ftrap = 0;
X	fgold = 0;
X	flags.ident = 1;
X
X	init_objects();
X	u_init();
X
X#ifndef NO_SIGNAL
X	(void) signal(SIGINT, (SIG_RET_TYPE) done1);
X#endif
X
X	mklev();
X	u.ux = xupstair;
X	u.uy = yupstair;
X	(void) inshop();
X
X	setsee();
X	flags.botlx = 1;
X
X	/* Move the monster from under you or else
X	 * makedog() will fail when it calls makemon().
X	 * 			- ucsfcgl!kneller
X	 */
X	if(MON_AT(u.ux, u.uy)) mnexto(m_at(u.ux, u.uy));
X
X#ifdef CLIPPING
X	cliparound(u.ux, u.uy);
X#endif
X	(void) makedog();
X	seemons();
X#ifdef NEWS
X	if(flags.nonews || !readnews())
X		/* after reading news we did docrt() already */
X#endif
X		docrt();
X
X	return;
X}
X
X#endif /* OVLB */
END_OF_FILE
if test 5069 -ne `wc -c <'src/allmain.c'`; then
    echo shar: \"'src/allmain.c'\" unpacked with wrong size!
fi
# end of 'src/allmain.c'
fi
if test -f 'src/exper.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/exper.c'\"
else
echo shar: Extracting \"'src/exper.c'\" \(4834 characters\)
sed "s/^X//" >'src/exper.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)exper.c	3.0	89/11/08
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include "hack.h"
X
X#ifdef LINT
X#define	NEW_SCORING
X#endif
Xlong
Xnewuexp(lev)
Xregister unsigned lev;
X{
X#ifdef LINT	/* long conversion */
X	return(0L * lev);
X#else
X	if(lev < 10) return (10L*(1L << lev));
X	if(lev < 20) return (10000L*(1L << (lev-10)));
X	return (10000000L*(lev-19));
X#endif
X}
X
Xint
Xexperience(mtmp, nk)	/* return # of exp points for mtmp after nk killed */
X	register struct	monst *mtmp;
X	register int	nk;
X{
X	register struct permonst *ptr = mtmp->data;
X	int	i, tmp, tmp2;
X
X	tmp = 1 + mtmp->m_lev * mtmp->m_lev;
X
X/*	For higher ac values, give extra experience */
X	if(ptr->ac < 3) tmp += (7 - ptr->ac) * (ptr->ac < 0) ? 2 : 1;
X
X/*	For very fast monsters, give extra experience */
X	if(ptr->mmove >= 12) tmp += (ptr->mmove >= 18) ? 5 : 3;
X
X/*	For each "special" attack type give extra experience */
X	for(i = 0; i < NATTK; i++) {
X
X	    tmp2 = ptr->mattk[i].aatyp;
X	    if(tmp2 > AT_BUTT) {
X
X		if(tmp2 == AT_WEAP) tmp += 5;
X		else if(tmp2 == AT_MAGC) tmp += 10;
X		else tmp += 3;
X	    }
X	}
X
X/*	For each "special" damage type give extra experience */
X	for(i = 0; i < NATTK; i++) {
X
X	    tmp2 = ptr->mattk[i].adtyp;
X	    if(tmp2 > AD_PHYS && tmp2 < AD_BLND) tmp += 2*mtmp->m_lev;
X	    else if((tmp2 == AD_DRLI) || (tmp2 == AD_STON)) tmp += 50;
X	    else if(tmp != AD_PHYS) tmp += mtmp->m_lev;
X		/* extra heavy damage bonus */
X	    if((ptr->mattk[i].damd * ptr->mattk[i].damn) > 23)
X		tmp += mtmp->m_lev;
X	}
X
X/*	For certain "extra nasty" monsters, give even more */
X	if(extra_nasty(ptr)) tmp += (7*mtmp->m_lev);
X	if(ptr->mlet == S_EEL) tmp += 1000;
X
X/*	For higher level monsters, an additional bonus is given */
X	if(mtmp->m_lev > 8) tmp += 50;
X
X#ifdef NEW_SCORING
X	/* ------- recent addition: make nr of points decrease
X		   when this is not the first of this kind */
X	{ unsigned ul = u.ulevel;
X	  int ml = mtmp->m_lev;
X	/* points are given based on present and future level */
X	  if(ul < MAXULEV)
X	    for(tmp2 = 0; !tmp2 || ul + tmp2 <= ml; tmp2++)
X		if(u.uexp + 1 + (tmp + ((tmp2 <= 0) ? 0 : 4<<(tmp2-1)))/nk
X		    >= newuexp(ul) )
X			if(++ul == MAXULEV) break;
X
X	  tmp2 = ml - ul -1;
X	  tmp = (tmp + ((tmp2 < 0) ? 0 : 4<<tmp2))/nk;
X	  if(tmp <= 0) tmp = 1;
X	}
X	/* note: ul is not necessarily the future value of u.ulevel */
X	/* ------- end of recent valuation change ------- */
X#endif /* NEW_SCORING /**/
X
X#ifdef MAIL
X	/* Mail daemons put up no fight. */
X	if(mtmp->data == &mons[PM_MAIL_DAEMON]) tmp = 1;
X#endif
X
X	return(tmp);
X}
X
Xvoid
Xmore_experienced(exp, rexp)
X	register int exp, rexp;
X{
X	u.uexp += exp;
X	u.urexp += 4*exp + rexp;
X	if(exp) flags.botl = 1;
X	if(u.urexp >= ((pl_character[0] == 'W') ? 1000 : 2000))
X		flags.beginner = 0;
X}
X
Xvoid
Xlosexp() {	/* hit by drain life attack */
X
X	register int num;
X
X#ifdef POLYSELF
X	if(resists_drli(uasmon)) return;
X#endif
X
X	if(u.ulevel > 1) {
X		pline("Goodbye level %u.", u.ulevel--);
X		/* remove intrinsic abilities */
X		adjabil((int)u.ulevel+1, (int)u.ulevel);
X	} else
X		u.uhp = -1;
X	num = newhp();
X	u.uhp -= num;
X	u.uhpmax -= num;
X#ifdef SPELLS
X	num = rnd((int)u.ulevel/2+1) + 1;		/* M. Stephenson */
X	u.uen -= num;
X	if (u.uen < 0)		u.uen = 0;
X	u.uenmax -= num;
X	if (u.uenmax < 0)	u.uenmax = 0;
X#endif
X	u.uexp = newuexp(u.ulevel) - 1;
X	flags.botl = 1;
X}
X
X/*
X * Make experience gaining similar to AD&D(tm), whereby you can at most go
X * up by one level at a time, extra expr possibly helping you along.
X * After all, how much real experience does one get shooting a wand of death
X * at a dragon created with a wand of polymorph??
X */
Xvoid
Xnewexplevel() {
X
X	register int tmp;
X
X	if(u.ulevel < MAXULEV && u.uexp >= newuexp(u.ulevel)) {
X
X		u.ulevel++;
X		if (u.uexp >= newuexp(u.ulevel)) u.uexp = newuexp(u.ulevel) - 1;
X		pline("Welcome to experience level %u.", u.ulevel);
X		set_uasmon();	/* set up for the new level. */
X		/* give new intrinsics */
X		adjabil((int)u.ulevel-1, (int)u.ulevel);
X		tmp = newhp();
X		u.uhpmax += tmp;
X		u.uhp += tmp;
X#ifdef SPELLS
X		tmp = rnd((int)ACURR(A_WIS)/2+1) + 1; /* M. Stephenson */
X		u.uenmax += tmp;
X		u.uen += tmp;
X#endif
X		flags.botl = 1;
X	}
X}
X
Xvoid
Xpluslvl() {
X	register int num;
X
X	You("feel more experienced.");
X	num = newhp();
X	u.uhpmax += num;
X	u.uhp += num;
X#ifdef SPELLS
X	num = rnd((int)ACURR(A_WIS)/2+1) + 1;	/* M. Stephenson */
X	u.uenmax += num;
X	u.uen += num;
X#endif
X	if(u.ulevel < MAXULEV) {
X		u.uexp = newuexp(u.ulevel);
X		pline("Welcome to experience level %u.", ++u.ulevel);
X		adjabil((int)u.ulevel-1, (int)u.ulevel);
X	}
X	flags.botl = 1;
X}
X
Xlong
Xrndexp()
X{
X	register long minexp,maxexp;
X
X	if(u.ulevel == 1)
X		return rn2((int)newuexp(1));
X	else {
X		minexp = newuexp(u.ulevel - 1);
X		maxexp = newuexp(u.ulevel);
X		return(minexp + rn2((int)(maxexp - minexp)));
X	}
X}
END_OF_FILE
if test 4834 -ne `wc -c <'src/exper.c'`; then
    echo shar: \"'src/exper.c'\" unpacked with wrong size!
fi
# end of 'src/exper.c'
fi
if test -f 'src/search.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/search.c'\"
else
echo shar: Extracting \"'src/search.c'\" \(4931 characters\)
sed "s/^X//" >'src/search.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)search.c	3.0	88/04/13
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include "hack.h"
X#ifdef NAMED_ITEMS
X#  include "artifact.h"
X#endif
X
X#ifdef OVLB
X
Xstatic void FDECL(findone,(XCHAR_P,XCHAR_P,int *));
X
Xstatic void
Xfindone(zx,zy,num)
Xxchar zx,zy;
Xint *num;
X{
X	register struct trap *ttmp;
X	register struct monst *mtmp;
X
X	if(levl[zx][zy].typ == SDOOR) {
X		levl[zx][zy].typ = DOOR;
X		levl[zx][zy].seen = 0;
X		prl(zx, zy);
X		(*num)++;
X	} else if(levl[zx][zy].typ == SCORR) {
X		levl[zx][zy].typ = CORR;
X		levl[zx][zy].seen = 0;
X		prl(zx, zy);
X		(*num)++;
X	} else if(ttmp = t_at(zx, zy)) {
X		if(ttmp->ttyp == MONST_TRAP) {
X			(void) makemon(&mons[ttmp->pm], zx, zy);
X			(*num)++;
X			deltrap(ttmp);
X		} else if(!ttmp->tseen && ttmp->ttyp != STATUE_TRAP) {
X			ttmp->tseen = 1;
X			if(!vism_at(zx, zy))
X		    atl(zx,zy,(char)((ttmp->ttyp==WEB) ? WEB_SYM : TRAP_SYM));
X			(*num)++;
X		}
X	} else if(MON_AT(zx, zy)) {
X		mtmp = m_at(zx,zy);
X		if(mtmp->mimic) {
X		        seemimic(mtmp);
X		        (*num)++;
X		}
X	}
X}
X
Xint
Xfindit()	/* returns number of things found */
X{
X	int num;
X	register xchar zx,zy;
X	xchar lx,hx,ly,hy;
X	xchar lx2,hx2,ly2,hy2;
X
X	if(u.uswallow) return(0);
X	if(inroom(u.ux,u.uy) < 0) {
X		lx = u.ux - 1;
X		hx = u.ux + 1;
X		ly = u.uy - 1;
X		hy = u.uy + 1;
X		lx2 = ly2 = 1;
X		hx2 = hy2 = 0;
X	} else
X		getcorners(&lx,&hx,&ly,&hy,&lx2,&hx2,&ly2,&hy2);
X	num = 0;
X	for(zy = ly; zy <= hy; zy++)
X		for(zx = lx; zx <= hx; zx++)
X			if(isok(zx,zy))
X				findone(zx,zy,&num);
X	for(zy = ly2; zy <= hy2; zy++)
X		for(zx = lx2; zx <= hx2; zx++)
X			if(isok(zx,zy))
X				findone(zx,zy,&num);
X	return(num);
X}
X
X#endif /* OVLB */
X#ifdef OVL1
X
Xint
Xdosearch()
X{
X	return(dosearch0(0));
X}
X
Xint
Xdosearch0(aflag)
Xregister int aflag;
X{
X	register xchar x, y;
X	register struct trap *trap;
X	register struct monst *mtmp;
X	register struct obj *otmp;
X
X#ifdef NAMED_ITEMS
X	int fund = (spec_ability(uwep, SPFX_SEARCH)) ?
X			((uwep->spe > 5) ? 5 : uwep->spe) : 0;
X#endif /* NAMED_ITEMS */
X
X	if(u.uswallow) {
X		if (!aflag)
X			pline("What are you looking for?  The exit?");
X	} else
X	    for(x = u.ux-1; x < u.ux+2; x++)
X	      for(y = u.uy-1; y < u.uy+2; y++) {
X		if(!isok(x,y)) continue;
X		if(x != u.ux || y != u.uy) {
X		    if(levl[x][y].typ == SDOOR) {
X#ifdef NAMED_ITEMS
X			if(rnl(7-fund)) continue;
X#else
X			if(rnl(7)) continue;
X#endif
X			levl[x][y].typ = DOOR;
X			levl[x][y].seen = 0;	/* force prl */
X			nomul(0);
X			prl(x,y);
X		    } else if(levl[x][y].typ == SCORR) {
X#ifdef NAMED_ITEMS
X			if(rnl(7-fund)) continue;
X#else
X			if(rnl(7)) continue;
X#endif
X			levl[x][y].typ = CORR;
X			levl[x][y].seen = 0;	/* force prl */
X			nomul(0);
X			prl(x,y);
X		    } else {
X		/* Be careful not to find anything in an SCORR or SDOOR */
X			if(MON_AT(x, y)) {
X			    mtmp = m_at(x,y);
X			    if(!aflag && mtmp->mimic) {
X				seemimic(mtmp);
X				You("find %s.", defmonnam(mtmp));
X				return(1);
X			    }
X			}
X
X			for(trap = ftrap; trap; trap = trap->ntrap)
X			    if(trap->tx == x && trap->ty == y &&
X				!trap->tseen && !rnl(8)) {
X				nomul(0);
X				if(trap->ttyp != MONST_TRAP &&
X				   trap->ttyp != STATUE_TRAP)
X				You("find a%s.", traps[Hallucination ?
X				rn2(TRAPNUM-3)+2 : trap->ttyp ]);
X
X				if(trap->ttyp == MONST_TRAP) {
X				    if((mtmp=makemon(&mons[trap->pm], x, y)))
X					You("find %s.", defmonnam(mtmp));
X				    deltrap(trap);
X				    return(1);
X				} else if(trap->ttyp == STATUE_TRAP) {
X				    if((otmp = sobj_at(STATUE, x, y)))
X				      if(otmp->corpsenm == trap->pm) {
X					    
X					if((mtmp=makemon(&mons[trap->pm], x, y)))
X					    You("find %s posing as a statue.",
X						  defmonnam(mtmp));
X					delobj(otmp);
X					newsym(x, y);
X				      }
X				    deltrap(trap);
X				    return(1);
X				}
X				trap->tseen = 1;
X				if(!vism_at(x,y))
X					atl(x,y,(char) ((trap->ttyp==WEB)
X						? WEB_SYM : TRAP_SYM));
X			    }
X		    }
X		}
X	      }
X	return(1);
X}
X
X#endif /* OVL1 */
X#ifdef OVLB
X
Xint
Xdoidtrap() {
X	register struct trap *trap;
X	register int x,y;
X
X	if(!getdir(1)) return 0;
X	x = u.ux + u.dx;
X	y = u.uy + u.dy;
X	for(trap = ftrap; trap; trap = trap->ntrap)
X		if(trap->tx == x && trap->ty == y && trap->tseen) {
X		    if(u.dz)
X			if((u.dz < 0) != (is_maze_lev && trap->ttyp == TRAPDOOR))
X			    continue;
X			pline("That is a%s.",traps[ Hallucination ? rn2(TRAPNUM-3)+3 :
X			trap->ttyp]);
X		    return 0;
X		}
X	pline("I can't see a trap there.");
X	return 0;
X}
X
X#endif /* OVLB */
X#ifdef OVL0
X
Xvoid
Xwakeup(mtmp)
Xregister struct monst *mtmp;
X{
X	mtmp->msleep = 0;
X	mtmp->meating = 0;	/* assume there's no salvagable food left */
X	setmangry(mtmp);
X	if(mtmp->mimic) seemimic(mtmp);
X}
X
X#endif /* OVL0 */
X#ifdef OVLB
X
X/* NOTE: we must check if(mtmp->mimic) before calling this routine */
Xvoid
Xseemimic(mtmp)
Xregister struct monst *mtmp;
X{
X	mtmp->mimic = 0;
X	mtmp->m_ap_type = M_AP_NOTHING;
X	mtmp->mappearance = 0;
X	unpmon(mtmp);
X	pmon(mtmp);
X}
X
X#endif /* OVLB */
END_OF_FILE
if test 4931 -ne `wc -c <'src/search.c'`; then
    echo shar: \"'src/search.c'\" unpacked with wrong size!
fi
# end of 'src/search.c'
fi
if test -f 'src/unixtty.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/unixtty.c'\"
else
echo shar: Extracting \"'src/unixtty.c'\" \(4986 characters\)
sed "s/^X//" >'src/unixtty.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)unixtty.c	3.0	88/05/03
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X/* tty.c - (Unix) version */
X
X/* With thanks to the people who sent code for SYSV - hpscdi!jon,
X * arnold@ucsf-cgl, wcs@bo95b, cbcephus!pds and others.
X */
X
X/* block some unused #defines to avoid overloading some cpp's */
X#define MONATTK_H
X#define ONAMES_H
X#define NEED_VARARGS
X#include "hack.h"
X
X/*
X * The distinctions here are not BSD - rest but rather USG - rest, as
X * BSD still has the old sgttyb structure, but SYSV has termio. Thus:
X */
X#if defined(BSD) || defined(ULTRIX)
X#define	V7
X#else
X#define USG
X#endif
X
X
X#ifdef USG
X
X#include	<termio.h>
X#define termstruct	termio
X#define kill_sym	c_cc[VKILL]
X#define erase_sym	c_cc[VERASE]
X#define intr_sym	c_cc[VINTR]
X#define EXTABS		TAB3
X#define tabflgs		c_oflag
X#define echoflgs	c_lflag
X#define cbrkflgs	c_lflag
X#define CBRKMASK	ICANON
X#define CBRKON		! /* reverse condition */
X#define OSPEED(x)	((x).c_cflag & CBAUD)
X#define IS_7BIT(x)	((x).c_cflag & CS7)
X#define inputflags	c_iflag
X#define STRIPHI		ISTRIP
X#define GTTY(x)		(ioctl(0, TCGETA, x))
X/* STTY now modified to run under Sys V R3.	- may have to be #ifdef'ed */
X#define STTY(x)		(ioctl(0, TCSETAW, x))	/* TCSETAF? TCSETAW? */
X#define GTTY2(x)	1
X#define STTY2(x)	1
X#define nonesuch	0
X#define inittyb2	inittyb
X#define curttyb2	curttyb
X
X#else	/* V7 */
X
X#include	<sgtty.h>
X#define termstruct	sgttyb
X#define	kill_sym	sg_kill
X#define	erase_sym	sg_erase
X#define	intr_sym	t_intrc
X#define EXTABS		XTABS
X#define tabflgs		sg_flags
X#define echoflgs	sg_flags
X#define cbrkflgs	sg_flags
X#define CBRKMASK	CBREAK
X#define CBRKON		/* empty */
X#define inputflags	sg_flags	/* don't know how enabling meta bits */
X#define IS_7BIT(x)	(FALSE)
X#define STRIPHI		0		/* should actually be done on BSD */
X#define OSPEED(x)	(x).sg_ospeed
X#define GTTY(x)		(gtty(0, x))
X#define STTY(x)		(stty(0, x))
X#define GTTY2(x)	(ioctl(0, TIOCGETC, (char *)x))
X#define STTY2(x)	(ioctl(0, TIOCSETC, (char *)x))
X#define nonesuch	-1
Xstruct tchars inittyb2, curttyb2;
X
X#endif
X
Xextern short ospeed;
Xchar erase_char, intr_char, kill_char;
Xstatic boolean settty_needed = FALSE;
Xstruct termstruct inittyb, curttyb;
X
Xstatic void
Xsetctty(){
X	if(STTY(&curttyb) < 0 || STTY2(&curttyb2) < 0)
X		perror("NetHack (setctty)");
X}
X
X/*
X * Get initial state of terminal, set ospeed (for termcap routines)
X * and switch off tab expansion if necessary.
X * Called by startup() in termcap.c and after returning from ! or ^Z
X */
Xvoid
Xgettty(){
X	if(GTTY(&inittyb) < 0 || GTTY2(&inittyb2) < 0)
X		perror("NetHack (gettty)");
X	curttyb = inittyb;
X	curttyb2 = inittyb2;
X	ospeed = OSPEED(inittyb);
X	erase_char = inittyb.erase_sym;
X	kill_char = inittyb.kill_sym;
X	intr_char = inittyb2.intr_sym;
X	getioctls();
X
X	/* do not expand tabs - they might be needed inside a cm sequence */
X	if(curttyb.tabflgs & EXTABS) {
X		curttyb.tabflgs &= ~EXTABS;
X		setctty();
X	}
X	settty_needed = TRUE;
X}
X
X/* reset terminal to original state */
Xvoid
Xsettty(s)
Xconst char *s;
X{
X	clear_screen();
X	end_screen();
X	if(s) Printf(s);
X	(void) fflush(stdout);
X	if(STTY(&inittyb) < 0 || STTY2(&inittyb2) < 0)
X		perror("NetHack (settty)");
X	flags.echo = (inittyb.echoflgs & ECHO) ? ON : OFF;
X	flags.cbreak = (CBRKON(inittyb.cbrkflgs & CBRKMASK)) ? ON : OFF;
X	curttyb.inputflags |= STRIPHI;
X	setioctls();
X}
X
Xvoid
Xsetftty(){
Xregister int ef = 0;			/* desired value of flags & ECHO */
X#ifdef LINT	/* cf = CBRKON(CBRKMASK); const expr to initialize is ok */
Xregister int cf = 0;
X#else
Xregister int cf = CBRKON(CBRKMASK);	/* desired value of flags & CBREAK */
X#endif
Xregister int change = 0;
X	flags.cbreak = ON;
X	flags.echo = OFF;
X	/* Should use (ECHO|CRMOD) here instead of ECHO */
X	if((curttyb.echoflgs & ECHO) != ef){
X		curttyb.echoflgs &= ~ECHO;
X/*		curttyb.echoflgs |= ef;					*/
X		change++;
X	}
X	if((curttyb.cbrkflgs & CBRKMASK) != cf){
X		curttyb.cbrkflgs &= ~CBRKMASK;
X		curttyb.cbrkflgs |= cf;
X#ifdef USG
X		/* be satisfied with one character; no timeout */
X		curttyb.c_cc[VMIN] = 1;		/* was VEOF */
X		curttyb.c_cc[VTIME] = 0;	/* was VEOL */
X#endif
X		change++;
X	}
X	if(!IS_7BIT(inittyb)) curttyb.inputflags &=~ STRIPHI;
X	/* If an interrupt character is used, it will be overriden and
X	 * set to ^C.
X	 */
X	if(intr_char != nonesuch && curttyb2.intr_sym != '\003') {
X	    curttyb2.intr_sym = '\003';
X	    change++;
X	}
X
X	if(change) setctty();
X	start_screen();
X}
X
Xvoid
Xintron() {		/* enable kbd interupts if enabled when game started */
X
X	if(intr_char != nonesuch && curttyb2.intr_sym != '\003') {
X	    curttyb2.intr_sym = '\003';
X	    setctty();
X	}
X}
X
Xvoid
Xintroff() {		/* disable kbd interrupts if required*/
X
X	if(curttyb2.intr_sym != nonesuch) {
X	    curttyb2.intr_sym = nonesuch;
X	    setctty();
X	}
X}
X
X
X/* fatal error */
X/*VARARGS1*/
X
Xvoid
Xerror VA_DECL(const char *,s)
X	VA_START(s);
X	VA_INIT(s, const char *);
X	if(settty_needed)
X		settty(NULL);
X	Vprintf(s,VA_ARGS);
X	(void) putchar('\n');
X	VA_END();
X	exit(1);
X}
END_OF_FILE
if test 4986 -ne `wc -c <'src/unixtty.c'`; then
    echo shar: \"'src/unixtty.c'\" unpacked with wrong size!
fi
# end of 'src/unixtty.c'
fi
echo shar: End of archive 52 \(of 56\).
cp /dev/null ark52isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 56 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
    echo Building monst.c from monst.c1 and monst.c2
    cat src/monst.c1 src/monst.c2 > src/monst.c
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
