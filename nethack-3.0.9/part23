Path: utzoo!attcan!uunet!wuarchive!zaphod.mps.ohio-state.edu!uakari.primate.wisc.edu!dali.cs.montana.edu!milton!uw-beaver!zephyr.ens.tek.com!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v10i068:  nethack3p9 -  display oriented dungeons & dragons (Ver. 3.0i), Part23/56
Message-ID: <5926@tekred.CNA.TEK.COM>
Date: 12 Jul 90 16:01:06 GMT
Sender: news@tekred.CNA.TEK.COM
Lines: 1892
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 10, Issue 68
Archive-name: nethack3p9/Part23
Supersedes: NetHack3: Volume 7, Issue 56-93



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 23 (of 56)."
# Contents:  auxil/data.base src/lev_comp.c
# Wrapped by billr@saab on Wed Jul 11 17:11:25 1990
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'auxil/data.base' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'auxil/data.base'\"
else
echo shar: Extracting \"'auxil/data.base'\" \(22782 characters\)
sed "s/^X//" >'auxil/data.base' <<'END_OF_FILE'
X	NetHack data file - version 3.0i
X	demons should all come first, before the *centaur line
Xbalrog
X		...  It came to the edge of the fire and the light  faded as
X		if a  cloud had  bent over it.  Then  with a rush it  leaped
X		the fissure.  The flames roared up to greet it, and wreathed
X		about  it; and a black smoke swirled in the air. Its stream-
X		ing  mane kindled,  and blazed behind it.  In its right hand
X		was a  blade like a stabbing tongue of fire;  in its left it
X		held a whip of many thongs.
X		'Ai, ai!'  wailed Legolas. 'A Balrog!  A Balrog is come!'
X			   [ The Fellowship of the Ring, by J.R.R. Tolkien ]
Xhorned devil
X		Horned devils lack any real special abilities,  though  they
X		are quite difficult to kill.
Xincubus
Xsuccubus
X		The incubus and succubus are male and female versions of the
X		same  demon, one who lies with a human for its own purposes,
X		usually to the detriment of the mortals who  are  unwise  in
X		their dealings with them.
Xerinyes
X		These female-seeming devils attack hand to hand  and  poison
X		their unwary victims as well.
Xmarilith
X		The marilith, a type V demon, has a torso shaped  like  that
X		of  a human female, and the lower body of a great snake.  It
X		has multiple arms, and can freely attack with all  of  them.
X		Since it is intelligent enough to use weapons, this means it
X		can cause great damage.
Xbarbed devil
X		Barbed devils lack any real special abilities,  though  they
X		are quite difficult to kill.
Xvrock
X		The vrock is one of the weaker forms of demon, being only  a
X		type  I.   It  resembles a cross between a human being and a
X		vulture and does physical damage by biting and by using  the
X		claws on both its arms and feet.
Xhezrou
X		``Hezrou'' is the common name for the type II demon.  It  is
X		among the weaker of demons, but still quite formidable.
Xbone devil
X		Bone devils attack with weapons and with a great hooked tail
X		which causes a loss of strength to those they sting.
Xnalfeshnee
X		Not only do these demons, which are of type IV, do  physical
X		damage  with  their  claws and bite, but they are capable of
X		using magic as well.
Xice devil
X		Ice devils  are  large  semi-insectoid  creatures,  who  are
X		equally  at home in the fires of Hell and the cold of Limbo,
X		and who can cause the traveller to feel the latter with just
X		a touch of their tail.
Xpit fiend
X		Pit fiends are among the more powerful of devils, capable of
X		attacking  twice with weapons as well as grabbing and crush-
X		ing the life out of  thise  unwary  enough  to  enter  their
X		domains.
Xjuiblex
Xjubilex
X		Little is known about the Faceless Lord,  even  the  correct
X		spelling  of  his name.  He does not have a physical form as
X		we know it, and those who have peered into his  realm  claim
X		he  is  a  slime-like  creature who swallows other creatures
X		alive, spits acidic secretions, and causes  disease  in  his
X		victims which can be almost instantly fatal.
Xyeenoghu
X		Yeenoghu, the demon lord of gnolls,  still  exists  although
X		all his followers have been wiped off the face of the earth.
X		He casts magic projectiles at those close to him, and a mere
X		gaze  into  his  piercing  eyes  may  hopelessly confuse the
X		battle-weary adventurer.
Xorcus
X		Orcus, Prince of the Undead, has a rams head  and  a  poison
X		stinger.   He is most feared, though, for his powerful magic
X		abilities.  His wand causes death to those he chooses.
Xgeryon
X		Geryon is an arch-devil sometimes  called  the  Wild  Beast,
X		attacking  with  his claws and poison sting.  His ranking in
X		Hell is rumored to be quite low.
Xdispater
X		Dispater is an arch-devil who rules the city of Dis.  He  is
X		a powerful mage.
Xbaalzebub
X		Baalzebub has been known as the lord of the flies.  His bite
X		drips  poison,  and a mere glance into his eyes can stun the
X		hapless invader of his realm.
Xasmodeus
X		It is said that Asmodeus is the overlord over all  of  hell.
X		His  appearance,  unlike  many  other  demons and devils, is
X		human apart from his horns and tail.  He  can  freeze  flesh
X		with a touch.
Xdemogorgon
X		Demogorgon, the prince of demons, wallows in filth  and  can
X		spread  a quickly fatal illness to his victims while rending
X		them.  He is a mighty spellcaster, and he can drain the life
X		of mortals with a touch of his tail.
X*centaur
X		Of all the monsters put together by  the  Greek  imagination
X		the  Centaurs (Kentauroi) constituted a class in themselves.
X		Despite a strong streak  of  sensuality  in  their  make-up,
X		their  normal  behaviour  was  moral, and they took a kindly
X		thought of man's welfare. The attempted outrage of Nessos on
X		Deianeira,  and  that  of the whole tribe of Centaurs on the
X		Lapith women,  are more than offset  by the  hospitality  of
X		Pholos and  by  the  wisdom of Cheiron,  physician, prophet,
X		lyrist,  and the instructor of Achilles.  Further,  the Cen-
X		taurs  were  peculiar in that their nature, which united the
X		body of a horse with the trunk and head of a  man,  involved
X		an  unthinkable  duplication  of  vital organs and important
X		members.  So grotesque a combination seems almost  un-Greek.
X		These  strange creatures  were said to live in the caves and
X		clefts of the mountains, myths associating  them  especially
X		with the hills of Thessaly and the range of Erymanthos.
X			     [ Mythology of all races, Vol. 1, pp. 270-271 ]
Xcockatrice
X		Once in a great while, when the positions of the  stars  are
X		just right, a seven-year-old rooster will lay an egg.  Then,
X		along will come a snake, to coil around the egg, or a  toad,
X		to  squat  upon  the  egg, keeping it warm and helping it to
X		hatch.  When it hatches, out comes a creature called  basil-
X		isk, or cockatrice, the most deadly of all creatures. A sin-
X		gle glance from its yellow, piercing toad's eyes  will  kill
X		both man  and beast.  Its power of destruction is said to be
X		so great that sometimes simply to hear its  hiss  can  prove
X		fatal.  Its  breath is so venomous  that it causes all vege-
X		tation to wither.
X	
X		There is, however, one  creature  which  can  withstand  the
X		basilisk's deadly gaze, and this is the weasel. No one knows
X		why this is so, but although the fierce weasel can slay  the
X		basilisk, it will itself be killed in the struggle.  Perhaps
X		the weasel knows the basilisk's fatal weakness:  if it  ever
X		sees  its own reflection in a mirror it will perish instant-
X		ly.  But even a dead basilisk is dangerous, for  it is  said
X		that merely touching its lifeless body can cause a person to
X		sicken and die.
X		[ Mythical Beasts by Deirdre Headon (The Leprechaun Library)
X		  and other sources ]
X*dragon
X		In the West  the dragon was  the  natural  enemy   of   man.
X		Although  preferring  to live in bleak and desolate regions,
X		whenever it was seen among men it left in its wake a   trail
X		of   destruction   and disease. Yet any attempt to slay this
X		beast was a perilous undertaking. For the dragon's assailant
X		had  to  contend not  only  with clouds of  sulphurous fumes
X		pouring from its fire-breathing nostrils, but also with  the
X		thrashings  of  its  tail,  the  most   deadly  part  of its
X		serpent-like body.
X		[Mythical Beasts by Deirdre Headon (The Leprechaun Library)]
X*elemental
X		Elementals are manifestations of the  basic  nature  of  the
X		universe.   There  are four known forms of elementals:  air,
X		fire, water, and earth.  Some mystics  have  postulated  the
X		necessity  for  a fifth type, the spirit elemental, but none
X		have ever been encountered, at least on this  plane  of  ex-
X		istence.
X*giant
Xgiant humanoid
X		Giants have always walked the earth, though they are rare in
X		these times.  They range in size from  little over nine feet
X		to a towering twenty feet or more.  The larger ones use huge
X		boulders as weapons, hurling them over large distances.  All
X		types of giants share a love for men  -  roasted, boiled, or
X		fried.  Their table manners are legendary.
Xgnome*
Xgnomish wizard
X		...  And then a gnome came by,  carrying a bundle,   an  old
X		fellow three times  as large as an imp  and wearing  clothes
X		of a sort, especially a hat.  And he was  clearly   just  as
X		frightened   as  the  imps  though  he could not go so fast.
X		Ramon Alonzo saw that there must be some great trouble  that
X		was  vexing  magical  things;   and,  since gnomes speak the
X		language of men, and will answer if spoken  to  gently,   he
X		raised  his  hat,   and  asked  of the gnome  his name.  The
X		gnome did not  stop  his  hasty  shuffle  a  moment   as  he
X		answered 'Alaraba' and grabbed the rim of his hat but forgot
X		to doff it.
X		'What is the trouble, Alaraba?' said Ramon Alonzo.
X		'White magic. Run!' said the gnome ...
X				[ The Charwoman's Shadow, by Lord Dunsany. ]
Xgold
Xpile of gold
X		A metal of characteristic yellow colour, the  most  precious
X		metal  used as a common commercial medium of exchange.  Sym-
X		bol, Au; at.  no. 79; at. wt. 197.2.  It is the most  malle-
X		able  and  ductile  of  all metals, and very heavy (sp. gr.,
X		19.3).  It is quite unalterable by heat, moisture, and  most
X		corrosive  agents,  and therefore well suited for its use in
X		coin and jewelry.
X				[ Webster's New International Dictionary
X				  of the English Language, Second Edition ]
X*golem
X		These creatures, not quite living but not  really  nonliving
X		either,   are   created from inanimate materials by powerful
X		mages or priests.
Xgremlin
X		The  gremlin is a highly  intelligent and  completely   evil
X		creature.   It lives to torment  other creatures and will go
X		to great lengths to inflict pain or cause injury.
Xgrid bug
X		These  electrically based creatures are  not native  to this
X		universe.  They  appear to come from a world  whose  laws of
X		motion are radically different from ours.
Xhobbit
X		Hobbits  are  an unobtrusive  but very ancient people,  more
X		numerous formerly than they are today;  for they love  peace
X		and quiet and good tilled earth:  a  well-ordered and  well-
X		farmed countryside  was their favourite haunt.  They  do not
X		and  did  not  understand  or like machines more complicated
X		than a forge-bellows, a water-mill, or a handloom,  although
X		they  were skillful with tools.  Even  in ancient days  they
X		were, as a rule, shy of "the Big Folk", as they call us, and
X		now they avoid us with dismay and are becoming hard to find.
X			   [ The Fellowship of the Ring, by J.R.R. Tolkien ]
Xhobgoblin
X		Hobgoblin. Used by the  Puritans  and  in  later  times  for
X		wicked  goblin  spirits,  as in Bunyan's 'Hobgoblin nor foul
X		friend', but its more correct use is for the friendly  spir-
X		its  of  the brownie type.  In 'A midsummer night's dream' a
X		fairy says to Shakespeare's Puck:
X		        Those that Hobgoblin call you, and sweet Puck,
X		        You do their work, and they shall have good luck:
X		        Are you not he?
X		and obviously Puck would not wish to be called  a  hobgoblin
X		if that was an ill-omened word.
X		Hobgoblins are on the whole, good-humoured and ready  to  be
X		helpful,  but fond of practical joking, and like most of the
X		fairies rather nasty people to annoy. Boggarts hover on  the
X		verge of hobgoblindom.  Bogles are just over the edge.
X		One Hob mentioned by Henderson, was Hob Headless who haunted
X		the  road  between Hurworth and Neasham, but could not cross
X		the little river Kent, which flowed into the  Tess.  He  was
X		exorcised  and  laid under a large stone by the roadside for
X		ninety-nine years and a day. If anyone was so unwary  as  to
X		sit  on  that stone, he would be unable to quit it for ever.
X		The ninety-nine years is nearly up, so trouble may  soon  be
X		heard of on the road between Hurworth and Neasham.
X		             [ Katharine Briggs, A  dictionary  of Fairies ]
Xhumanoid
X		Humanoids  are all approximately  the size of a human,   and
X		may  be  mistaken for one  at a distance.  They  are usually
X		of a tribal  nature, and will  fiercely defend their  lairs.
X		Usually   hostile, they  may even band  together to raid and
X		pillage human settlements.
Xhuman
Xarcheologist
Xbarbarian
Xcave*man
Xelf
Xhealer
Xknight
Xpriest*
Xrogue
Xsamurai
Xtourist
Xvalkyrie
Xwizard
X		These strange creatures live mostly on the  surface  of  the
X		earth, gathering together in societies of various forms, but
X		occasionally a stray will descend into the depths and commit
X		mayhem  among  the  dungeon  residents who, naturally, often
X		resent the intrusion of such beasts.  They  are  capable  of
X		using  weapons  and  magic,  and it is even rumored that the
X		Wizard of Yendor is a member of this species.
Ximp
X		 ... imps ... little creatures of two feet high  that  could
X		gambol and jump prodigiously; ...
X				 [ The Charwoman's Shadow, by Lord Dunsany ]
X	
X		An 'imp' is an off-shoot or cutting.  Thus an 'ymp tree' was
X		a grafted tree, or one grown from a cutting, not from seed.
X		'Imp' properly means a small devil, an off-shoot  of  Satan,
X		but  the distinction between goblins or bogles and imps from
X		hell is hard to make, and many in the  Celtic  countries  as
X		well as the English Puritans regarded all fairies as devils.
X		The fairies of tradition often hover  uneasily  between  the
X		ghostly and the diabolic state.
X			       [ Katharine Briggs, A Dictionary of Fairies ]
Xjabberwock
X		"Beware the Jabberwock, my son!
X		  The jaws that bite, the claws that catch!
X		Beware the Jubjub bird, and shun
X		  The frumious Bandersnatch!"
X		
X		He took his vorpal sword in hand;
X		  Long time the manxome foe he sought --
X		So rested he by the Tumtum tree,
X		  And stood awhile in thought.
X		
X		And, as in uffish thought he stood,
X		  The Jabberwock, with eyes of flame,
X		Came whiffling through the tulgey wood,
X		  And burbled as it came!
X					[ Jabberwocky, by Lewis Carroll ]
X*kobold*
X		The race of kobolds are reputed to be an artificial creation
X		of a master wizard (demi-god?).  They are about 3' tall with
X		a vaguely dog-like face.  They bear a violent dislike of the
X		Elven race, and  will go out  of their way to  cause trouble
X		for Elves at any time.
Xleprechaun
X		The Irish Leprechaun is the Faeries' shoemaker and is  known
X		under  various names  in different parts of Ireland:  Cluri-
X		caune in Cork, Lurican in Kerry, Lurikeen in Kildare and Lu-
X		rigadaun  in  Tipperary.  Although he works for the Faeries,
X		the Leprechaun is not of the same species.  He is small, has
X		dark  skin  and wears strange clothes.  His nature has some-
X		thing of the manic-depressive about it:  first he  is  quite
X		happy, whistling merrily as he nails a sole on to a shoe;  a
X		few minutes later, he is sullen and  morose,  drunk  on  his
X		home-made heather ale.  The Leprechaun's two great loves are
X		tobacco and whiskey, and he is a first-rate con-man,  impos-
X		sible  to  out-fox.  No  one, no matter how clever, has ever
X		managed to cheat him out of his hidden pot of  gold  or  his
X		magic shilling.  At the last minute he always thinks of some
X		way to divert his captor's attention  and  vanishes  in  the
X		twinkling  of  an eye.
X				     [ A Field Guide to the Little People
X				       by Nancy Arrowsmith & George Moorse ]
Xleocrotta
Xleu*otta
X		...the leucrocotta, a wild beast of extraordinary swiftness,
X		the size of the wild ass, with the legs of a Stag, the neck,
X		tail, and breast of a lion,  the head of a badger,  a cloven
X		hoof, the mouth slit up as far as the ears,  and one contin-
X		uous bone  instead of  teeth;  it is said,  too,  that  this
X		animal can imitate the human voice.
X			       [ Curious Creatures in Zoology, John Ashton ]
X*lich
X		Once in a great  while, an evil master wizard or priest will
X		manage through use of great magics to extend his or her life
X		far beyond the normal  span of a human.  The usual effect of
X		this is to transform the human, over time, into an undead of
X		great magical power.  A Lich  hates life in any form; even a
X		touch from one of these  creatures will cause a numbing cold
X		in the victim.  They all possess the capability to use magic.
Xmedusa
X		This hideous  creature from  ancient Greek myth was the doom
X		of many a valiant adventurer.  It is said that one gaze from
X		its eyes  could turn a man to stone.  One bite from the nest
X		of  snakes which  crown its head could  cause instant death.
X		The only  way to kill this  monstrosity is to turn its  gaze
X		back upon itself.
X*naga*
X		The naga is a mystical creature with the body of a snake and
X		the head of a man or woman.  They will fiercely  protect the
X		territory they consider their own.  Some nagas can be forced
X		to serve as a guardian by a spell caster of great power.
X*ooze
X*pudding
X		These giant amoeboid creatures look like nothing  more  than
X		puddles  of  slime,  but they both live and move, feeding on
X		metal or wood as well as the occasional dungeon explorer  to
X		supplement their diet.
Xorcrist
X		The  Great Goblin  gave a truly awful howl of  rage when  he
X		looked  at  it,  and  all his soldiers  gnashed their teeth,
X		clashed their shields,  and stamped.  They knew the sword at
X		once.  It had killed hundreds of goblins in  its time,  when
X		the  fair elves of Gondolin hunted them in the hills or  did
X		battle  before  their  walls.  They  had called it  Orcrist,
X		Goblin-cleaver, but the goblins called it simply Biter. They
X		hated it and hated worse any one that carried it.
X					   [ The Hobbit, by J.R.R. Tolkien ]
Xpiercer
X		Ye Piercer doth look like unto  a  stalactyte,  and  hangeth
X		from  the  roofs of caves and caverns.  Unto the height of a
X		man, and thicker than a man's thigh do  they  grow,  and  in
X		groups  do they hang.  If a creature doth pass beneath them,
X		they will by its heat and noise perceive it, and  fall  upon
X		it  to kill and devour it, though in any other way they move
X		but exceeding slow.
X						   [ the Bestiary of Xygag ]
Xquantum mechanic
X		These creatures are not native to this universe;  they  seem
X		to have strangely derived powers, and unknown motives.
Xquadruped
X		The woodlands and other regions  are inhabited by multitudes
X		of four-legged creatures  which cannot be simply classified.
X		They might not have fiery breath  or deadly stings,  but ad-
X		venturers  have  nevertheless  met their end  numerous times
X		due to the claws, hooves, or bites of such animals.
Xrust monster
X		These strange creatures live on a   diet  of  metals.   They
X		will  turn  a  suit  of  armour into so much useless  rusted
X		scrap in no time at all.
Xsnickersnee
X		Ah, never shall I forget the cry, 
X		    or the shriek that shrieked he,
X		As I gnashed my teeth, and from my sheath
X		    I drew my Snickersnee!
X		--Koko, Lord high executioner of Titipu
X				     [ The Mikado, by Sir W.S. Gilbert ]
X*soldier
Xsergeant
Xlieutenant
Xcaptain
X		The soldiers  of Yendor are  well-trained in the art of war,
X		many  trained by  the wizard himself.  Some say the soldiers
X		are explorers  who were  unfortunate enough  to be captured,
X		and  put under the wizard's spell.  Those who have  survived
X		encounters  with  soldiers   say  they  travel  together  in
X		platoons,  and are fierce fighters.  Because of the  load of
X		their  combat gear,  however,  one can usually run away from
X		them, and doing so is considered a wise thing.
Xtengu
X		The tengu was the  most  troublesome  creature  of  Japanese
X		legend.   Part  bird  and part man, with red beak for a nose
X		and flashing eyes, the tengu was notorious for  stirring  up
X		feuds  and  prolonging  enmity between families. Indeed, the
X		belligerent tengus were supposed to have  been  man's  first
X		instructors in the use of arms.
X		[Mythical Beasts by Deirdre Headon (The Leprechaun Library)]
X*unicorn
Xunicorn horn
X		Men have always sought the elusive unicorn, for  the  single
X		twisted  horn  which projected from its forehead was thought
X		to be a powerful talisman.  It was said that the unicorn had
X		simply  to  dip  the tip of its horn in a muddy pool for the
X		water to become pure.  Men also believed that to  drink from
X		this horn was a protection against all sickness, and that if
X		the horn was ground to a powder it would act as an  antidote
X		to all poisons.  Less than 200 years ago in France, the horn
X		of a unicorn was used in a ceremony to test the  royal  food
X		for poison.
X	
X		Although only the size of a small horse, the  unicorn  is  a
X		very  fierce  beast,  capable  of killing an elephant with a
X		single thrust from its horn.  Its  fleetness  of  foot  also
X		makes  this solitary creature difficult to capture. However,
X		it can be tamed and captured by a maiden. Made gentle by the
X		sight  of a virgin, the unicorn can be lured to lay its head
X		in her lap, and in this docile mood, the maiden  may  secure
X		it with a golden rope.
X		[Mythical Beasts by Deirdre Headon (The Leprechaun Library)]
X*long worm
Xworm tooth
Xcrysknife
X		[The crysknife] is manufactured in two forms from teeth tak-
X		en  from dead sandworms.  The two forms are "fixed" and "un-
X		fixed." An unfixed  knife  requires  proximity  to  a  human
X		body's  electrical  field  to prevent disintegration.  Fixed
X		knives are treated for storage.  All are about  20  centime-
X		ters long.
X						  [ Dune, by Frank Herbert ]
Xwizard of yendor
X		No  one knows how old this mighty wizard is,  or from whence
X		he came.  It is known that,  having lived a span far greater
X		than any normal man's, he grew weary of lesser mortals;  and
X		so, spurning all human company,  he forsook the dwellings of
X		men  and  went to live in the depths of the  Earth.  He took
X		with him the mystical artifact, the Amulet of Yendor,  which
X		is said to hold great power indeed. Many have sought to find
X		the  wizard and  his treasure,  but none have found  him and
X		lived to tell the tale.  Woe be to the incautious adventurer
X		who disturbs this mighty sorcerer!
Xxan
X		They sent their friend the mosquito [xan] ahead of  them  to
X		find  out  what lay ahead.  "Since you are the one who sucks
X		the blood of men walking along paths," they told the mosqui-
X		to,  "go  and  sting the men of Xibalba."  The mosquito flew
X		down the dark road to the Underworld.  Entering the house of
X		the Lords of Death, he stung the first person that he saw...
X	
X		The mosquito stung this man as well, and when he yelled, the
X		man  next  to him asked, "Gathered Blood, what's wrong?"  So
X		he flew along the row stinging all the seated men  until  he
X		knew the names of all twelve.
X				[ Popul Vuh, as translated by Ralph Nelson ]
X*zombie
X		The zombi...  is a soulless human corpse,  still  dead,  but
X		taken	from  the  grave  and  endowed	by  sorcery  with  a
X		mechanical semblance of life, --  it is a dead body which is
X		made to walk and act and move as if it were alive.
X							  [ W. B. Seabrook ]
Xzruty
X		The zruty are  wild and gigantic beings,  living in the wil-
X		dernesses of the Tatra mountains.
END_OF_FILE
if test 22782 -ne `wc -c <'auxil/data.base'`; then
    echo shar: \"'auxil/data.base'\" unpacked with wrong size!
fi
# end of 'auxil/data.base'
fi
if test -f 'src/lev_comp.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/lev_comp.c'\"
else
echo shar: Extracting \"'src/lev_comp.c'\" \(33297 characters\)
sed "s/^X//" >'src/lev_comp.c' <<'END_OF_FILE'
X
X# line 1 "lev_comp.y"
X 
X/*	SCCS Id: @(#)lev_comp.c	3.0	90/01/03
X/*	Copyright (c) 1989 by Jean-Christophe Collet */
X/* NetHack may be freely redistributed.  See license for details. */
X
X/*
X * This file contains the Level Compiler code
X * It may handle special mazes & special room-levels
X */
X
X/* block some unused #defines to avoid overloading some cpp's */
X#define MONDATA_H	/* comment line for pre-compiled headers */
X#define MONFLAG_H	/* comment line for pre-compiled headers */
X
X#include "hack.h"
X#include "sp_lev.h"
X#ifndef O_WRONLY
X# include <fcntl.h>
X#endif
X#ifndef O_CREAT	/* some older BSD systems do not define O_CREAT in <fcntl.h> */
X# include <sys/file.h>
X#endif
X
Xvoid FDECL(yyerror, (char *));
Xvoid FDECL(yywarning, (char *));
Xint NDECL(yylex);
Xint NDECL(yyparse);
X
Xint FDECL(get_room_type, (char *));
Xint FDECL(get_trap_type, (char *));
Xint FDECL(get_monster_id, (char *, CHAR_P));
Xint FDECL(get_object_id, (char *, CHAR_P));
Xboolean FDECL(check_monster_char, (CHAR_P));
Xboolean FDECL(check_object_char, (CHAR_P));
Xvoid FDECL(scan_map, (char *));
Xvoid NDECL(store_part);
Xvoid FDECL(write_maze, (int, specialmaze *));
X
X#ifdef AMIGA
Xchar *fgets();
X# undef     fopen
X# undef     printf
X# undef     Printf
X# define    Printf  printf
X#ifndef	LATTICE
X# define    memset(addr,val,len)    setmem(addr,len,val)
X#endif
X#endif
X
X#ifdef MSDOS
X# undef exit
Xextern void FDECL(exit, (int));
X#endif
X
X#ifdef MACOS
X# undef printf
X# undef Printf
X# define Printf printf
X#endif
X
X#undef NULL
X
X#define MAX_REGISTERS	10
X#define ERR		(-1)
X
Xstruct reg {
X	int x1, y1;
X	int x2, y2;
X}		current_region;
X
Xstruct coord {
X	int x;
X	int y;
X}		current_coord;
X
Xstruct {
X	char *name;
X	short type;
X} trap_types[TRAPNUM-1] = {
X	"monster",	MONST_TRAP,
X	"statue",	STATUE_TRAP,
X	"bear",		BEAR_TRAP,
X	"arrow",	ARROW_TRAP,
X	"dart",		DART_TRAP,
X	"trapdoor",	TRAPDOOR,
X	"teleport",	TELEP_TRAP,
X	"pit",		PIT,
X	"sleep gas",	SLP_GAS_TRAP,
X	"magic",	MGTRP,
X	"board",	SQBRD,
X	"web",		WEB,
X	"spiked pit",	SPIKED_PIT,
X	"level teleport",LEVEL_TELEP,
X#ifdef SPELLS
X	"anti magic",	ANTI_MAGIC,
X#endif
X	"rust",		RUST_TRAP
X#ifdef POLYSELF
X	, "polymorph",	POLY_TRAP
X#endif
X#ifdef ARMY
X	, "land mine",	LANDMINE
X#endif
X  };
X
Xstruct {
X	char *name;
X	int type;
X} room_types[SHOPBASE-1] = {
X	/* for historical reasons, room types are not contiguous numbers */
X	/* (type 1 is skipped) */
X	"ordinary",	OROOM,
X#ifdef THRONES
X	"throne",	COURT,
X#endif
X	"swamp",	SWAMP,
X	"vault",	VAULT,
X	"beehive",	BEEHIVE,
X	"morgue",	MORGUE,
X#ifdef ARMY
X	"barracks",	BARRACKS,
X#endif
X	"zoo",		ZOO,
X	"temple",	TEMPLE,
X	"shop",		SHOPBASE,
X};
X
Xshort db_dirs[4] = {
X	DB_NORTH,
X	DB_EAST,
X	DB_SOUTH,
X	DB_WEST
X};
X
X#ifdef ALTARS
Xstatic altar *tmpaltar[256];
X#endif /* ALTARS /**/
Xstatic lad *tmplad[256];
Xstatic digpos *tmpdig[256];
Xstatic char *tmpmap[ROWNO];
Xstatic region *tmpreg[16];
Xstatic door *tmpdoor[256];
Xstatic trap *tmptrap[256];
Xstatic monster *tmpmonst[256];
Xstatic object *tmpobj[256];
Xstatic drawbridge *tmpdb[256];
Xstatic walk *tmpwalk[256];
Xstatic mazepart *tmppart[10];
Xstatic room *tmproom[MAXNROFROOMS];
Xstatic specialmaze maze;
X
Xstatic char olist[MAX_REGISTERS], mlist[MAX_REGISTERS];
Xstatic struct coord plist[MAX_REGISTERS];
Xstatic int n_olist = 0, n_mlist = 0, n_plist = 0;
X
Xunsigned int nreg = 0, ndoor = 0, ntrap = 0, nmons = 0, nobj = 0;
Xunsigned int ndb = 0, nwalk = 0, npart = 0, ndig = 0, nlad = 0;
X#ifdef ALTARS
Xunsigned int naltar = 0;
X#endif /* ALTARS /*/
X
Xunsigned int max_x_map, max_y_map;
X
Xextern int fatal_error;
Xextern char* fname;
X
X
X# line 169 "lev_comp.y"
Xtypedef union 
X{
X	int	i;
X	char*	map;
X} YYSTYPE;
X# define CHAR 257
X# define INTEGER 258
X# define MAZE_ID 259
X# define LEVEL_ID 260
X# define GEOMETRY_ID 261
X# define OBJECT_ID 262
X# define MONSTER_ID 263
X# define TRAP_ID 264
X# define DOOR_ID 265
X# define DRAWBRIDGE_ID 266
X# define MAZEWALK_ID 267
X# define REGION_ID 268
X# define RANDOM_OBJECTS_ID 269
X# define RANDOM_MONSTERS_ID 270
X# define RANDOM_PLACES_ID 271
X# define ALTAR_ID 272
X# define LADDER_ID 273
X# define NON_DIGGABLE_ID 274
X# define ROOM_ID 275
X# define DOOR_STATE 276
X# define LIGHT_STATE 277
X# define DIRECTION 278
X# define RANDOM_TYPE 279
X# define O_REGISTER 280
X# define M_REGISTER 281
X# define P_REGISTER 282
X# define A_REGISTER 283
X# define ALIGNMENT 284
X# define LEFT_OR_RIGHT 285
X# define CENTER 286
X# define TOP_OR_BOT 287
X# define ALTAR_TYPE 288
X# define UP_OR_DOWN 289
X# define STRING 290
X# define MAP_ID 291
X#define yyclearin yychar = -1
X#define yyerrok yyerrflag = 0
Xextern int yychar;
Xextern short yyerrflag;
X#ifndef YYMAXDEPTH
X#define YYMAXDEPTH 150
X#endif
XYYSTYPE yylval, yyval;
X# define YYERRCODE 256
X
X# line 654 "lev_comp.y"
X
X
X/* 
X * Find the type of a room in the table, knowing its name.
X */
X
Xint
Xget_room_type(s)
Xchar *s;
X{
X	register int i;
X	
X	for(i=0; i < SHOPBASE -1; i++)
X	    if (!strcmp(s, room_types[i].name))
X		return ((int) room_types[i].type);
X	return ERR;
X}
X
X/* 
X * Find the type of a trap in the table, knowing its name.
X */
X
Xint
Xget_trap_type(s)
Xchar *s;
X{
X	register int i;
X	
X	for(i=0; i < TRAPNUM - 1; i++)
X	    if(!strcmp(s,trap_types[i].name))
X		return((int)trap_types[i].type);
X	return ERR;
X}
X
X/* 
X * Find the index of a monster in the table, knowing its name.
X */
X
Xint
Xget_monster_id(s, c)
Xchar *s;
Xchar c;
X{
X	register int i;
X	
X	for(i=0; mons[i].mname[0]; i++)
X	    if(!strncmp(s, mons[i].mname, strlen(mons[i].mname))
X	       && c == mons[i].mlet)
X		return i;
X	return ERR;
X}
X
X/* 
X * Find the index of an object in the table, knowing its name.
X */
X
Xint
Xget_object_id(s, c)
Xchar *s;
Xchar c;
X{
X	register int i;
X	
X	for(i=0; i<=NROFOBJECTS;i++)
X	    if(objects[i].oc_name &&
X	       !strncmp(s, objects[i].oc_name, strlen(objects[i].oc_name))
X	       && c == objects[i].oc_olet)
X		return i;
X	return ERR;
X}
X
X/* 
X * Is the character 'c' a valid monster class ?
X */
X
Xboolean
Xcheck_monster_char(c)
Xchar c;
X{
X	register int i;
X	
X	for(i=0; mons[i].mname[0]; i++)
X	    if( c ==  mons[i].mlet)
X		return 1;
X	return(0);
X}
X
X/* 
X * Is the character 'c' a valid object class ?
X */
X
Xboolean
Xcheck_object_char(c)
Xchar c;
X{
X	register int i;
X	
X	for(i=0; i<=NROFOBJECTS;i++)
X	    if( c == objects[i].oc_olet)
X		return 1;
X	return 0;
X}
X
X/* 
X * Yep! LEX gives us the map in a raw mode.
X * Just analyze it here.
X */
X
Xvoid scan_map(map)
Xchar *map;
X{
X	register int i, len;
X	register char *s1, *s2;
X	int max_len = 0;
X	int max_hig = 0;
X	
X	/* First : find the max width of the map */
X
X	s1 = map;
X	while (s1 && *s1) {
X		s2 = index(s1, '\n');
X		if (s2) {
X			if (s2-s1 > max_len)
X			    max_len = s2-s1;
X			s1 = s2 + 1;
X		} else {
X			if (strlen(s1) > max_len)
X			    max_len = strlen(s1);
X			s1 = (char *) 0;
X		}
X	}
X
X	/* Then parse it now */
X
X	while (map && *map) {
X		tmpmap[max_hig] = (char *) alloc(max_len);
X		s1 = index(map, '\n');
X		if (s1) {
X			len = s1 - map;
X			s1++;
X		} else {
X			len = strlen(map);
X			s1 = map + len;
X		}
X		for(i=0; i<len; i++)
X		    switch(map[i]) {
X			  case '-' : tmpmap[max_hig][i] = HWALL; break;
X			  case '|' : tmpmap[max_hig][i] = VWALL; break;
X			  case '+' : tmpmap[max_hig][i] = DOOR; break;
X			  case 'S' : tmpmap[max_hig][i] = SDOOR; break;
X			  case '{' : 
X#ifdef FOUNTAINS
X			      tmpmap[max_hig][i] = FOUNTAIN;
X#else
X			      tmpmap[max_hig][i] = ROOM;
X			      yywarning("Fountains are not allowed in this version!  Ignoring...");
X#endif
X			      break;
X			  case '\\' : 
X#ifdef THRONES
X			      tmpmap[max_hig][i] = THRONE;
X#else
X			      tmpmap[max_hig][i] = ROOM;
X			      yywarning("Thrones are not allowed in this version!  Ignoring...");
X#endif
X			      break;
X			  case 'K' : 
X#ifdef SINKS
X			      tmpmap[max_hig][i] = SINK;
X#else
X			      tmpmap[max_hig][i] = ROOM;
X			      yywarning("Sinks are not allowed in this version!  Ignoring...");
X#endif
X			      break;
X			  case '}' : tmpmap[max_hig][i] = MOAT; break;
X			  case '#' : tmpmap[max_hig][i] = CORR; break;
X			  default  : tmpmap[max_hig][i] = ROOM; break;
X		    }
X		while(i < max_len)
X		    tmpmap[max_hig][i++] = ROOM;
X		map = s1;
X		max_hig++;
X	}
X
X	/* Memorize boundaries */
X
X	max_x_map = max_len - 1;
X	max_y_map = max_hig - 1;
X
X	/* Store the map into the mazepart structure */
X
X	tmppart[npart]->xsize = max_len;
X	tmppart[npart]->ysize = max_hig;
X	tmppart[npart]->map = (char **) alloc(max_hig*sizeof(char *));
X	for(i = 0; i< max_hig; i++)
X	    tmppart[npart]->map[i] = tmpmap[i];
X}
X
X/* 
X * Here we want to store the maze part we just got.
X */
X
Xvoid
Xstore_part()
X{
X	register int i;
X
X	/* Ok, We got the whole part, now we store it. */
X	
X	/* The Regions */
X
X	if(tmppart[npart]->nreg = nreg) {
X		tmppart[npart]->regions = (region**)alloc(sizeof(region*) * nreg);
X		for(i=0;i<nreg;i++)
X		    tmppart[npart]->regions[i] = tmpreg[i];
X	}
X	nreg = 0;
X
X	/* the doors */
X
X	if(tmppart[npart]->ndoor = ndoor) {
X		tmppart[npart]->doors = (door **)alloc(sizeof(door *) * ndoor);
X		for(i=0;i<ndoor;i++)
X		    tmppart[npart]->doors[i] = tmpdoor[i];
X	}
X	ndoor = 0;
X
X	/* the traps */
X
X	if(tmppart[npart]->ntraps = ntrap) {
X		tmppart[npart]->traps = (trap **)alloc(sizeof(trap*) * ntrap);
X		for(i=0;i<ntrap;i++)
X		    tmppart[npart]->traps[i] = tmptrap[i];
X	}
X	ntrap = 0;
X
X	/* the monsters */
X
X	if(tmppart[npart]->nmonster = nmons) {
X		tmppart[npart]->monsters = (monster**)alloc(sizeof(monster*)*nmons);
X		for(i=0;i<nmons;i++)
X		    tmppart[npart]->monsters[i] = tmpmonst[i];
X	}
X	nmons = 0;
X
X	/* the objects */
X
X	if(tmppart[npart]->nobjects = nobj) {
X		tmppart[npart]->objects = (object**)alloc(sizeof(object*)*nobj);
X		for(i=0;i<nobj;i++)
X		    tmppart[npart]->objects[i] = tmpobj[i];
X	}
X	nobj = 0;
X
X	/* the drawbridges */
X
X	if(tmppart[npart]->ndrawbridge = ndb) {
X		tmppart[npart]->drawbridges = (drawbridge**)alloc(sizeof(drawbridge*)*ndb);
X		for(i=0;i<ndb;i++)
X		    tmppart[npart]->drawbridges[i] = tmpdb[i];
X	}
X	ndb = 0;
X
X	/* The walkmaze directives */
X
X	if(tmppart[npart]->nwalk = nwalk) {
X		tmppart[npart]->walks = (walk**)alloc(sizeof(walk*)*nwalk);
X		for(i=0;i<nwalk;i++)
X		    tmppart[npart]->walks[i] = tmpwalk[i];
X	}
X	nwalk = 0;
X
X	/* The non_diggable directives */
X
X	if(tmppart[npart]->ndig = ndig) {
X		tmppart[npart]->digs = (digpos **) alloc(sizeof(digpos*) * ndig);
X		for(i=0;i<ndig;i++)
X		    tmppart[npart]->digs[i] = tmpdig[i];
X	}
X	ndig = 0;
X
X	/* The ladders */
X
X	if(tmppart[npart]->nlad = nlad) {
X		tmppart[npart]->lads = (lad **) alloc(sizeof(lad*) * nlad);
X		for(i=0;i<nlad;i++)
X		    tmppart[npart]->lads[i] = tmplad[i];
X	}
X	nlad = 0;
X#ifdef ALTARS
X	/* The altars */
X
X	if(tmppart[npart]->naltar = naltar) {
X		tmppart[npart]->altars = (altar**)alloc(sizeof(altar*) * naltar);
X		for(i=0;i<naltar;i++)
X		    tmppart[npart]->altars[i] = tmpaltar[i];
X	}
X	naltar = 0;
X#endif /* ALTARS /**/
X	npart++;
X	n_plist = n_mlist = n_olist = 0;
X}
X
X/* 
X * Here we write the structure of the maze in the specified file (fd).
X * Also, we have to free the memory allocated via alloc()
X */
X
Xvoid
Xwrite_maze(fd, maze)
Xint fd;
Xspecialmaze *maze;
X{
X	char c;
X	short i,j;
X	mazepart *pt;
X
X	c = 2;
X	(void) write(fd, &c, 1);	/* Header for special mazes */
X	(void) write(fd, &(maze->numpart), 1);	/* Number of parts */
X	for(i=0;i<maze->numpart;i++) {
X	    pt = maze->parts[i];
X
X	    /* First, write the map */
X
X	    (void) write(fd, &(pt->halign), 1);
X	    (void) write(fd, &(pt->valign), 1);
X	    (void) write(fd, &(pt->xsize), 1);
X	    (void) write(fd, &(pt->ysize), 1);
X	    for(j=0;j<pt->ysize;j++) {
X		    (void) write(fd, pt->map[j], pt->xsize);
X		    free(pt->map[j]);
X	    }
X	    free(pt->map);
X
X	    /* The random registers */
X	    (void) write(fd, &(pt->nrobjects), 1);
X	    if(pt->nrobjects) {
X		    (void) write(fd, pt->robjects, pt->nrobjects);
X		    free(pt->robjects);
X	    }
X	    (void) write(fd, &(pt->nloc), 1);
X	    if(pt->nloc) {
X		(void) write(fd,pt->rloc_x, pt->nloc);
X		(void) write(fd,pt->rloc_y, pt->nloc);
X		free(pt->rloc_x);
X		free(pt->rloc_y);
X	    }
X	    (void) write(fd,&(pt->nrmonst), 1);
X	    if(pt->nrmonst) {
X		    (void) write(fd, pt->rmonst, pt->nrmonst);
X		    free(pt->rmonst);
X	    }
X
X	    /* subrooms */
X	    (void) write(fd, &(pt->nreg), 1);
X	    for(j=0;j<pt->nreg;j++) {
X		    (void) write(fd,(genericptr_t) pt->regions[j], sizeof(region));
X		    free(pt->regions[j]);
X	    }
X	    if(pt->nreg > 0)
X		free(pt->regions);
X
X	    /* the doors */
X	    (void) write(fd,&(pt->ndoor),1);
X	    for(j=0;j<pt->ndoor;j++) {
X		    (void) write(fd,(genericptr_t) pt->doors[j], sizeof(door));
X		    free(pt->doors[j]);
X	    }
X	    if (pt->ndoor > 0)
X		free(pt->doors);
X
X	    /* The traps */
X	    (void) write(fd,&(pt->ntraps), 1);
X	    for(j=0;j<pt->ntraps;j++) {
X		    (void) write(fd,(genericptr_t) pt->traps[j], sizeof(trap));
X		    free(pt->traps[j]);
X	    }
X	    if (pt->ntraps)
X		free(pt->traps);
X
X	    /* The monsters */
X	    (void) write(fd, &(pt->nmonster), 1);
X	    for(j=0;j<pt->nmonster;j++) {
X		    (void) write(fd,(genericptr_t) pt->monsters[j], sizeof(monster));
X		    free(pt->monsters[j]);
X	    }
X	    if (pt->nmonster > 0)
X		free(pt->monsters);
X
X	    /* The objects */
X	    (void) write(fd, &(pt->nobjects), 1);
X	    for(j=0;j<pt->nobjects;j++) {
X		    (void) write(fd,(genericptr_t) pt->objects[j], sizeof(object));
X		    free(pt->objects[j]);
X	    }
X	    if(pt->nobjects > 0)
X		free(pt->objects);
X
X	    /* The drawbridges */
X	    (void) write(fd, &(pt->ndrawbridge),1);
X	    for(j=0;j<pt->ndrawbridge;j++) {
X		    (void) write(fd,(genericptr_t) pt->drawbridges[j], sizeof(drawbridge));
X		    free(pt->drawbridges[j]);
X	    }
X	    if(pt->ndrawbridge > 0)
X		free(pt->drawbridges);
X
X	    /* The mazewalk directives */
X	    (void) write(fd, &(pt->nwalk), 1);
X	    for(j=0; j<pt->nwalk; j++) {
X		    (void) write(fd,(genericptr_t) pt->walks[j], sizeof(walk));
X		    free(pt->walks[j]);
X	    }
X	    if (pt->nwalk > 0)
X		free(pt->walks);
X
X	    /* The non_diggable directives */
X	    (void) write(fd, &(pt->ndig), 1);
X	    for(j=0;j<pt->ndig;j++) {
X		    (void) write(fd,(genericptr_t) pt->digs[j], sizeof(digpos));
X		    free(pt->digs[j]);
X	    }
X	    if (pt->ndig > 0)
X		free(pt->digs);
X
X	    /* The ladders */
X	    (void) write(fd, &(pt->nlad), 1);
X	    for(j=0;j<pt->nlad;j++) {
X		    (void) write(fd,(genericptr_t) pt->lads[j], sizeof(lad));
X		    free(pt->lads[j]);
X	    }
X	    if (pt->nlad > 0)
X		free(pt->lads);
X#ifdef ALTARS
X	    /* The altars */
X	    (void) write(fd, &(pt->naltar), 1);
X	    for(j=0;j<pt->naltar;j++) {
X		    (void) write(fd,(genericptr_t) pt->altars[j], sizeof(altar));
X		    free(pt->altars[j]);
X	    }
X	    if (pt->naltar > 0)
X		free(pt->altars);
X#endif /* ALTARS /**/
X	    free(pt);
X	}
X}
Xshort yyexca[] ={
X-1, 1,
X	0, -1,
X	-2, 0,
X-1, 67,
X	44, 27,
X	-2, 26,
X	};
X# define YYNPROD 87
X# define YYLAST 251
Xshort yyact[]={
X
X 165, 130, 126,  91,  16,  19, 169, 146,  69,  72,
X 145,  19,  19,  19,  19, 168,  75,  74,  26,  27,
X 143, 137,  12, 138, 144, 141,  65,  87, 134,   6,
X  88,  78, 174,  80,  40,  39,  42,  41,  43,  46,
X  44, 171, 170, 156,  45,  47,  48, 148,  83,  85,
X  22,  24,  23, 135, 131, 127, 116, 105,  72,  65,
X  18,  92,  93,  86,  66,  70, 172,  63, 154, 152,
X 150, 158, 114, 110, 108,  97,  62,  61,  60,  59,
X  58,  57,  56,  55,  54,  53,  51,  50,  49,  17,
X  13,  64, 173,  71, 166, 157, 155, 153, 151, 149,
X 139, 122, 121, 119, 118, 117, 115, 113, 112, 111,
X 109, 107, 106,  68, 103,  52, 175,  90, 159,  69,
X  98,  99, 100, 101,   8,   2,  94,  84,  79,   7,
X  81,  76,  38,  37,  14,  36,  35,  34, 102,  33,
X  32,  31,  30,  29,  28, 104,  82,  77,  67,  21,
X  11,  20,  15,  10,   9,   4,   3,   1, 128, 124,
X   5, 142, 167, 140, 136, 163,  89,  73, 125,  25,
X 129, 120, 123, 132, 133,   0,   0,   0,   0,   0,
X   0,   0,   0,   0,  68,   0, 147,   0,   0,   0,
X   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
X   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
X   0, 160,   0, 161,   0,   0, 164, 162,   0,   0,
X   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
X   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
X   0,   0,   0,   0,   0,   0,   0,  95,   0,   0,
X  96 };
Xshort yypact[]={
X
X-230,-1000,-1000,-230,-1000,-239,  32,-1000,-1000,-239,
X-1000,-287,  31,-285,-1000,-219,-1000,-267,-1000,-1000,
X-228,-1000,  30,  29,  28,  71,-1000,-1000,-1000,-1000,
X-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,  27,
X  26,  25,  24,  23,  22,  21,  20,  19,  18,-198,
X  79,-199,-270,-248,-231,-249,-276, -32,  80, -32,
X -32, -32,  80,-1000,  70,-1000,-1000,-1000,-1000,-201,
X-1000,  68,-1000,-1000,-1000,-1000,  67,-1000,-1000,-1000,
X -17,  66,-1000,-1000,-1000, -18,  65,-1000,-1000,  64,
X-1000,-1000,  63,-1000,-1000,-1000, -19,  62,-202,  61,
X  60,  59,-1000,-198,  58,  57,-199,-277,-203,-278,
X-204, -32, -32,-250,-205,-256,  56,-259,-268,-282,
X-1000,  79,-211,-1000,  55,-1000,-1000, -23,  54,-1000,
X-1000, -24,-1000,-1000,  53, -25,  52,-1000,-1000,-215,
X  51,-1000,-1000,-1000, -20,-1000,-1000,-1000,  77, -32,
X-1000, -32,-1000,-249,-1000,-279,  50,-273,-216,-1000,
X-1000,-1000,-1000,-1000,-1000,-1000,-217,-1000,-1000,-1000,
X -27,  48,-1000,-226,  75,-1000 };
Xshort yypgo[]={
X
X   0, 169, 167, 166, 165,  63, 164, 163, 162, 161,
X  60, 160, 159, 158, 157, 125, 156, 155, 124, 154,
X 153, 152, 151, 150, 149,  67,  64,  65,  91,  93,
X 148, 145, 144, 143, 142, 141, 140, 139, 137, 136,
X 135, 133, 132, 131,  61, 130,  75, 128, 127,  62,
X 126 };
Xshort yyr1[]={
X
X   0,  14,  14,  15,  15,  16,  17,  11,  18,  18,
X  19,  20,  23,   1,   1,   2,   2,  21,  21,  24,
X  24,  24,  25,  25,  27,  27,  26,  31,  26,  22,
X  22,  32,  32,  32,  32,  32,  32,  32,  32,  32,
X  32,  33,  34,  35,  36,  37,  40,  41,  42,  38,
X  39,  43,  43,  43,  45,  45,  45,  12,  12,  13,
X  13,   3,   3,   4,   4,  44,  44,  44,   5,   5,
X   6,   6,   7,   7,   7,   8,   8,  50,  48,  47,
X   9,  30,  29,  28,  10,  49,  46 };
Xshort yyr2[]={
X
X   0,   0,   1,   1,   2,   1,   2,   3,   1,   2,
X   3,   2,   5,   1,   1,   1,   1,   0,   2,   3,
X   3,   3,   1,   3,   1,   3,   1,   0,   4,   0,
X   2,   1,   1,   1,   1,   1,   1,   1,   1,   1,
X   1,   7,   7,   5,   5,   7,   5,   5,   3,   7,
X   7,   1,   1,   1,   1,   1,   1,   1,   1,   1,
X   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
X   1,   1,   1,   1,   1,   1,   1,   4,   4,   4,
X   4,   1,   1,   1,   1,   5,   9 };
Xshort yychk[]={
X
X-1000, -14, -15, -16, -17, -11, 259, -15, -18, -19,
X -20, -23, 261,  58, -18, -21, 291,  58, -10, 290,
X -22, -24, 269, 271, 270,  -1, 285, 286, -32, -33,
X -34, -35, -36, -37, -38, -39, -40, -41, -42, 263,
X 262, 265, 264, 266, 268, 272, 267, 273, 274,  58,
X  58,  58,  44,  58,  58,  58,  58,  58,  58,  58,
X  58,  58,  58, -25, -28, 257, -26, -30, -49,  40,
X -27, -29, 257,  -2, 287, 286, -43, -29, 279, -47,
X 281, -45, -28, 279, -48, 280,  -5, 276, 279,  -3,
X -10, 279, -44, -49, -50, 279, 282, -46,  40, -44,
X -44, -44, -46,  44, -31, 258,  44,  44,  91,  44,
X  91,  44,  44,  44,  91,  44, 258,  44,  44,  44,
X -25,  44,  44, -27, -12, -10, 279, 258, -13, -10,
X 279, 258, -44, -44, 278, 258,  -6, 277, 279,  44,
X  -7, 284,  -9, 279, 283, 278, 289, -26, 258,  44,
X  93,  44,  93,  44,  93,  44, 258,  44,  91,  41,
X -44, -44,  -5,  -4, -10, 279,  44,  -8, 288, 279,
X 258, 258,  93,  44, 258,  41 };
Xshort yydef[]={
X
X   1,  -2,   2,   3,   5,   0,   0,   4,   6,   8,
X  17,   0,   0,   0,   9,  29,  11,   0,   7,  84,
X  10,  18,   0,   0,   0,   0,  13,  14,  30,  31,
X  32,  33,  34,  35,  36,  37,  38,  39,  40,   0,
X   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
X   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
X   0,   0,   0,  19,  22,  83,  20,  -2,  81,   0,
X  21,  24,  82,  12,  15,  16,   0,  51,  52,  53,
X   0,   0,  54,  55,  56,   0,   0,  68,  69,   0,
X  61,  62,   0,  65,  66,  67,   0,   0,   0,   0,
X   0,   0,  48,   0,   0,   0,   0,   0,   0,   0,
X   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
X  23,   0,   0,  25,   0,  57,  58,   0,   0,  59,
X  60,   0,  43,  44,   0,   0,   0,  70,  71,   0,
X   0,  72,  73,  74,   0,  46,  47,  28,   0,   0,
X  79,   0,  78,   0,  77,   0,   0,   0,   0,  85,
X  41,  42,  45,  49,  63,  64,   0,  50,  75,  76,
X   0,   0,  80,   0,   0,  86 };
X#ifndef lint
Xstatic char yaccpar_sccsid[] = "@(#)yaccpar	4.1	(Berkeley)	2/11/83";
X#endif not lint
X
X#
X# define YYFLAG -1000
X# define YYERROR goto yyerrlab
X# define YYACCEPT return(0)
X# define YYABORT return(1)
X
X/*	parser for yacc output	*/
X
X#ifdef YYDEBUG
Xint yydebug = 0; /* 1 for debugging */
X#endif
XYYSTYPE yyv[YYMAXDEPTH]; /* where the values are stored */
Xint yychar = -1; /* current input token number */
Xint yynerrs = 0;  /* number of errors */
Xshort yyerrflag = 0;  /* error recovery flag */
X
Xyyparse() {
X
X	short yys[YYMAXDEPTH];
X	short yyj, yym;
X	register YYSTYPE *yypvt;
X	register short yystate, *yyps, yyn;
X	register YYSTYPE *yypv;
X	register short *yyxi;
X
X	yystate = 0;
X	yychar = -1;
X	yynerrs = 0;
X	yyerrflag = 0;
X	yyps= &yys[-1];
X	yypv= &yyv[-1];
X
X yystack:    /* put a state and value onto the stack */
X
X#ifdef YYDEBUG
X	if( yydebug  ) printf( "state %d, char 0%o\n", yystate, yychar );
X#endif
X		if( ++yyps> &yys[YYMAXDEPTH] ) { yyerror( "yacc stack overflow" ); return(1); }
X		*yyps = yystate;
X		++yypv;
X		*yypv = yyval;
X
X yynewstate:
X
X	yyn = yypact[yystate];
X
X	if( yyn<= YYFLAG ) goto yydefault; /* simple state */
X
X	if( yychar<0 ) if( (yychar=yylex())<0 ) yychar=0;
X	if( (yyn += yychar)<0 || yyn >= YYLAST ) goto yydefault;
X
X	if( yychk[ yyn=yyact[ yyn ] ] == yychar ){ /* valid shift */
X		yychar = -1;
X		yyval = yylval;
X		yystate = yyn;
X		if( yyerrflag > 0 ) --yyerrflag;
X		goto yystack;
X		}
X
X yydefault:
X	/* default state action */
X
X	if( (yyn=yydef[yystate]) == -2 ) {
X		if( yychar<0 ) if( (yychar=yylex())<0 ) yychar = 0;
X		/* look through exception table */
X
X		for( yyxi=yyexca; (*yyxi!= (-1)) || (yyxi[1]!=yystate) ; yyxi += 2 ) ; /* VOID */
X
X		while( *(yyxi+=2) >= 0 ){
X			if( *yyxi == yychar ) break;
X			}
X		if( (yyn = yyxi[1]) < 0 ) return(0);   /* accept */
X		}
X
X	if( yyn == 0 ){ /* error */
X		/* error ... attempt to resume parsing */
X
X		switch( yyerrflag ){
X
X		case 0:   /* brand new error */
X
X			yyerror( "syntax error" );
X		yyerrlab:
X			++yynerrs;
X
X		case 1:
X		case 2: /* incompletely recovered error ... try again */
X
X			yyerrflag = 3;
X
X			/* find a state where "error" is a legal shift action */
X
X			while ( yyps >= yys ) {
X			   yyn = yypact[*yyps] + YYERRCODE;
X			   if( yyn>= 0 && yyn < YYLAST && yychk[yyact[yyn]] == YYERRCODE ){
X			      yystate = yyact[yyn];  /* simulate a shift of "error" */
X			      goto yystack;
X			      }
X			   yyn = yypact[*yyps];
X
X			   /* the current yyps has no shift onn "error", pop stack */
X
X#ifdef YYDEBUG
X			   if( yydebug ) printf( "error recovery pops state %d, uncovers %d\n", *yyps, yyps[-1] );
X#endif
X			   --yyps;
X			   --yypv;
X			   }
X
X			/* there is no state on the stack with an error shift ... abort */
X
X	yyabort:
X			return(1);
X
X
X		case 3:  /* no shift yet; clobber input char */
X
X#ifdef YYDEBUG
X			if( yydebug ) printf( "error recovery discards char %d\n", yychar );
X#endif
X
X			if( yychar == 0 ) goto yyabort; /* don't discard EOF, quit */
X			yychar = -1;
X			goto yynewstate;   /* try again in the same state */
X
X			}
X
X		}
X
X	/* reduction by production yyn */
X
X#ifdef YYDEBUG
X		if( yydebug ) printf("reduce %d\n",yyn);
X#endif
X		yyps -= yyr2[yyn];
X		yypvt = yypv;
X		yypv -= yyr2[yyn];
X		yyval = yypv[1];
X		yym=yyn;
X			/* consult goto table to find next state */
X		yyn = yyr1[yyn];
X		yyj = yypgo[yyn] + *yyps + 1;
X		if( yyj>=YYLAST || yychk[ yystate = yyact[yyj] ] != -yyn ) yystate = yyact[yypgo[yyn]];
X		switch(yym){
X			
Xcase 6:
X# line 201 "lev_comp.y"
X{
X			  int fout, i;
X
X			  if (fatal_error > 0)
X				  fprintf(stderr,"%s : %d errors detected. No output created!\n", fname, fatal_error);
X			  else {
X#ifdef MACOS
X				  OSErr	result;
X				  
X				  result = Create(CtoPstr(yypvt[-1].map), 0, CREATOR, AUXIL_TYPE);
X				  (void)PtoCstr(yypvt[-1].map);
X#endif		
X				  fout = open(yypvt[-1].map, O_WRONLY | O_CREAT
X#if defined(MSDOS) || defined(MACOS)
X					      | O_BINARY
X#endif /* MSDOS || MACOS */
X					      , 0644);
X				  if (fout < 0) {
X					  yyerror("Can't open output file!!");
X					  exit(1);
X				  }
X				  maze.numpart = npart;
X				  maze.parts = (mazepart**) alloc(sizeof(mazepart*)*npart);
X				  for(i=0;i<npart;i++)
X				      maze.parts[i] = tmppart[i];
X				  write_maze(fout, &maze);
X				  (void) close(fout);
X				  npart = 0;
X			  }
X		  } break;
Xcase 7:
X# line 233 "lev_comp.y"
X{
X			  yyval.map = yypvt[-0].map;
X		  } break;
Xcase 10:
X# line 241 "lev_comp.y"
X{
X			store_part();
X		  } break;
Xcase 11:
X# line 246 "lev_comp.y"
X{
X			tmppart[npart] = (mazepart *) alloc(sizeof(mazepart));
X			tmppart[npart]->halign = yypvt[-1].i % 10;
X			tmppart[npart]->valign = yypvt[-1].i / 10;
X			tmppart[npart]->nrobjects = 0;
X			tmppart[npart]->nloc = 0;
X			tmppart[npart]->nrmonst = 0;
X			scan_map(yypvt[-0].map);
X		  } break;
Xcase 12:
X# line 257 "lev_comp.y"
X{
X			  yyval.i = yypvt[-2].i + ( yypvt[-0].i * 10 );
X		  } break;
Xcase 19:
X# line 271 "lev_comp.y"
X{
X			  if (tmppart[npart]->nrobjects)
X			      yyerror("Object registers already initialized!");
X			  else {
X				  tmppart[npart]->robjects = (char *) alloc(n_olist);
X				  memcpy(tmppart[npart]->robjects, olist, n_olist);
X				  tmppart[npart]->nrobjects = n_olist;
X			  }
X		  } break;
Xcase 20:
X# line 281 "lev_comp.y"
X{
X			  if (tmppart[npart]->nloc)
X			      yyerror("Location registers already initialized!");
X			  else {
X				  register int i;
X				  tmppart[npart]->rloc_x = (char *) alloc(n_plist);
X				  tmppart[npart]->rloc_y = (char *) alloc(n_plist);
X				  for(i=0;i<n_plist;i++) {
X					  tmppart[npart]->rloc_x[i] = plist[i].x;
X					  tmppart[npart]->rloc_y[i] = plist[i].y;
X				  }
X				  tmppart[npart]->nloc = n_plist;
X			  }
X		  } break;
Xcase 21:
X# line 296 "lev_comp.y"
X{
X			  if (tmppart[npart]->nrmonst)
X			      yyerror("Monster registers already initialized!");
X			  else {
X				  tmppart[npart]->rmonst = (char *) alloc(n_mlist);
X				  memcpy(tmppart[npart]->rmonst, mlist, n_mlist);
X				  tmppart[npart]->nrmonst = n_mlist;
X			  }
X		  } break;
Xcase 22:
X# line 307 "lev_comp.y"
X{
X			  if (n_olist < MAX_REGISTERS)
X			      olist[n_olist++] = yypvt[-0].i;
X			  else
X			      yyerror("Object list too long!");
X		  } break;
Xcase 23:
X# line 314 "lev_comp.y"
X{
X			  if (n_olist < MAX_REGISTERS)
X			      olist[n_olist++] = yypvt[-2].i;
X			  else
X			      yyerror("Object list too long!");
X		  } break;
Xcase 24:
X# line 322 "lev_comp.y"
X{
X			  if (n_mlist < MAX_REGISTERS)
X			      mlist[n_mlist++] = yypvt[-0].i;
X			  else
X			      yyerror("Monster list too long!");
X		  } break;
Xcase 25:
X# line 329 "lev_comp.y"
X{
X			  if (n_mlist < MAX_REGISTERS)
X			      mlist[n_mlist++] = yypvt[-2].i;
X			  else
X			      yyerror("Monster list too long!");
X		  } break;
Xcase 26:
X# line 337 "lev_comp.y"
X{
X			  if (n_plist < MAX_REGISTERS)
X			      plist[n_plist++] = current_coord;
X			  else
X			      yyerror("Location list too long!");
X		  } break;
Xcase 27:
X# line 344 "lev_comp.y"
X{
X			  if (n_plist < MAX_REGISTERS)
X			      plist[n_plist++] = current_coord;
X			  else
X			      yyerror("Location list too long!");
X		  } break;
Xcase 41:
X# line 366 "lev_comp.y"
X{
X			  int token;
X
X			  tmpmonst[nmons] = (monster *) alloc(sizeof(monster));
X			  tmpmonst[nmons]->x = current_coord.x;
X			  tmpmonst[nmons]->y = current_coord.y;
X			  tmpmonst[nmons]->class = yypvt[-4].i;
X			  if (!yypvt[-2].map)
X			      tmpmonst[nmons]->id = -1;
X			  else {
X				  token = get_monster_id(yypvt[-2].map, (char) yypvt[-4].i);
X				  if (token == ERR) {
X				      yywarning("Illegal monster name!  Making random monster.");
X				      tmpmonst[nmons]->id = -1;
X				  } else
X				      tmpmonst[nmons]->id = token;
X			  }
X			  nmons++;
X		  } break;
Xcase 42:
X# line 387 "lev_comp.y"
X{
X			  int token;
X
X			  tmpobj[nobj] = (object *) alloc(sizeof(object));
X			  tmpobj[nobj]->x = current_coord.x;
X			  tmpobj[nobj]->y = current_coord.y;
X			  tmpobj[nobj]->class = yypvt[-4].i;
X			  if (!yypvt[-2].map)
X			      tmpobj[nobj]->id = -1;
X			  else {
X				  token = get_object_id(yypvt[-2].map, (char) yypvt[-4].i);
X				  if (token == ERR) {
X				      yywarning("Illegal object name!  Making random object.");
X				      tmpobj[nobj]->id = -1;
X				  } else
X				      tmpobj[nobj]->id = token;
X			  }
X			  nobj++;
X		  } break;
Xcase 43:
X# line 408 "lev_comp.y"
X{
X			tmpdoor[ndoor] = (door *) alloc(sizeof(door));
X			tmpdoor[ndoor]->x = current_coord.x;
X			tmpdoor[ndoor]->y = current_coord.y;
X			tmpdoor[ndoor]->mask = yypvt[-2].i;
X			ndoor++;
X		  } break;
Xcase 44:
X# line 417 "lev_comp.y"
X{
X			tmptrap[ntrap] = (trap *) alloc(sizeof(trap));
X			tmptrap[ntrap]->x = current_coord.x;
X			tmptrap[ntrap]->y = current_coord.y;
X			tmptrap[ntrap]->type = yypvt[-2].i;
X			ntrap++;
X		  } break;
Xcase 45:
X# line 426 "lev_comp.y"
X{
X			tmpdb[ndb] = (drawbridge *) alloc(sizeof(drawbridge));
X			tmpdb[ndb]->x = current_coord.x;
X			tmpdb[ndb]->y = current_coord.y;
X			tmpdb[ndb]->dir = db_dirs[yypvt[-2].i];
X			if ( yypvt[-0].i == D_ISOPEN )
X			  tmpdb[ndb]->open = 1;
X			else if ( yypvt[-0].i == D_CLOSED )
X			  tmpdb[ndb]->open = 0;
X			else
X			  yyerror("A drawbridge can only be open or closed!");
X			ndb++;
X		   } break;
Xcase 46:
X# line 441 "lev_comp.y"
X{
X			tmpwalk[nwalk] = (walk *) alloc(sizeof(walk));
X			tmpwalk[nwalk]->x = current_coord.x;
X			tmpwalk[nwalk]->y = current_coord.y;
X			tmpwalk[nwalk]->dir = yypvt[-0].i;
X			nwalk++;
X		  } break;
Xcase 47:
X# line 450 "lev_comp.y"
X{
X			tmplad[nlad] = (lad *) alloc(sizeof(lad));
X			tmplad[nlad]->x = current_coord.x;
X			tmplad[nlad]->y = current_coord.y;
X			tmplad[nlad]->up = yypvt[-0].i;
X			nlad++;
X		  } break;
Xcase 48:
X# line 459 "lev_comp.y"
X{
X			tmpdig[ndig] = (digpos *) alloc(sizeof(digpos));
X			tmpdig[ndig]->x1 = current_region.x1;
X			tmpdig[ndig]->y1 = current_region.y1;
X			tmpdig[ndig]->x2 = current_region.x2;
X			tmpdig[ndig]->y2 = current_region.y2;
X			ndig++;
X		  } break;
Xcase 49:
X# line 469 "lev_comp.y"
X{
X			tmpreg[nreg] = (region *) alloc(sizeof(region));
X			tmpreg[nreg]->x1 = current_region.x1;
X			tmpreg[nreg]->y1 = current_region.y1;
X			tmpreg[nreg]->x2 = current_region.x2;
X			tmpreg[nreg]->y2 = current_region.y2;
X			tmpreg[nreg]->rlit = yypvt[-2].i;
X			tmpreg[nreg]->rtype = yypvt[-0].i;
X			nreg++;
X		  } break;
Xcase 50:
X# line 481 "lev_comp.y"
X{
X#ifndef ALTARS
X			yywarning("Altars are not allowed in this version!  Ignoring...");
X#else
X			tmpaltar[naltar] = (altar *) alloc(sizeof(altar));
X			tmpaltar[naltar]->x = current_coord.x;
X			tmpaltar[naltar]->y = current_coord.y;
X			tmpaltar[naltar]->align = yypvt[-2].i;
X			tmpaltar[naltar]->shrine = yypvt[-0].i;
X			naltar++;
X#endif /* ALTARS */
X		  } break;
Xcase 52:
X# line 496 "lev_comp.y"
X{
X			  yyval.i = - MAX_REGISTERS - 1;
X		  } break;
Xcase 55:
X# line 503 "lev_comp.y"
X{
X			  yyval.i = - MAX_REGISTERS - 1;
X		  } break;
Xcase 58:
X# line 510 "lev_comp.y"
X{
X			  yyval.map = (char *) 0;
X		  } break;
Xcase 60:
X# line 516 "lev_comp.y"
X{
X			  yyval.map = (char *) 0;
X		  } break;
Xcase 61:
X# line 521 "lev_comp.y"
X{
X			int token = get_trap_type(yypvt[-0].map);
X			if (token == ERR)
X				yyerror("unknown trap type!");
X			yyval.i = token;
X		  } break;
Xcase 63:
X# line 530 "lev_comp.y"
X{
X			int token = get_room_type(yypvt[-0].map);
X			if (token == ERR) {
X				yywarning("Unknown room type!  Making ordinary room...");
X				yyval.i = OROOM;
X			} else
X				yyval.i = token;
X		  } break;
Xcase 67:
X# line 543 "lev_comp.y"
X{
X			  current_coord.x = current_coord.y = -MAX_REGISTERS-1;
X		  } break;
Xcase 74:
X# line 556 "lev_comp.y"
X{
X			  yyval.i = - MAX_REGISTERS - 1;
X		  } break;
Xcase 77:
X# line 564 "lev_comp.y"
X{
X			if ( yypvt[-1].i >= MAX_REGISTERS ) {
X				yyerror("Register Index overflow!");
X			} else {
X				current_coord.x = current_coord.y = - yypvt[-1].i - 1;
X			}
X		  } break;
Xcase 78:
X# line 573 "lev_comp.y"
X{
X			if ( yypvt[-1].i >= MAX_REGISTERS ) {
X				yyerror("Register Index overflow!");
X			} else {
X				yyval.i = - yypvt[-1].i - 1;
X			}
X		  } break;
Xcase 79:
X# line 582 "lev_comp.y"
X{
X			if ( yypvt[-1].i >= MAX_REGISTERS ) {
X				yyerror("Register Index overflow!");
X			} else {
X				yyval.i = - yypvt[-1].i - 1;
X			}
X		  } break;
Xcase 80:
X# line 591 "lev_comp.y"
X{
X			if ( yypvt[-1].i >= 3 ) {
X				yyerror("Register Index overflow!");
X			} else {
X				yyval.i = - yypvt[-1].i - 1;
X			}
X		  } break;
Xcase 82:
X# line 602 "lev_comp.y"
X{
X			if (check_monster_char((char) yypvt[-0].i))
X				yyval.i = yypvt[-0].i ;
X			else {
X				yyerror("unknown monster class!");
X				yyval.i = ERR;
X			}
X		  } break;
Xcase 83:
X# line 612 "lev_comp.y"
X{
X			char c;
X
X			c = yypvt[-0].i;
X#ifndef SPELLS
X			if ( c == '+') {
X				c = '?';
X				yywarning("Spellbooks are not allowed in this version! (converted into scroll)");
X			}
X#endif
X			if (check_object_char(c))
X				yyval.i = c;
X			else {
X				yyerror("Unknown char class!");
X				yyval.i = ERR;
X			}
X		  } break;
Xcase 85:
X# line 632 "lev_comp.y"
X{
X			if (yypvt[-3].i < 0 || yypvt[-3].i > max_x_map ||
X			    yypvt[-1].i < 0 || yypvt[-1].i > max_y_map)
X			    yyerror("Coordinates out of map range!");
X			current_coord.x = yypvt[-3].i;
X			current_coord.y = yypvt[-1].i;
X		  } break;
Xcase 86:
X# line 641 "lev_comp.y"
X{
X			if (yypvt[-7].i < 0 || yypvt[-7].i > max_x_map ||
X			    yypvt[-5].i < 0 || yypvt[-5].i > max_y_map ||
X			    yypvt[-3].i < 0 || yypvt[-3].i > max_x_map ||
X			    yypvt[-1].i < 0 || yypvt[-1].i > max_y_map)
X			    yyerror("Region out of map range!");
X			current_region.x1 = yypvt[-7].i;
X			current_region.y1 = yypvt[-5].i;
X			current_region.x2 = yypvt[-3].i;
X			current_region.y2 = yypvt[-1].i;
X		  } break; 
X		}
X		goto yystack;  /* stack new state and value */
X
X	}
END_OF_FILE
if test 33297 -ne `wc -c <'src/lev_comp.c'`; then
    echo shar: \"'src/lev_comp.c'\" unpacked with wrong size!
fi
# end of 'src/lev_comp.c'
fi
echo shar: End of archive 23 \(of 56\).
cp /dev/null ark23isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 56 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
