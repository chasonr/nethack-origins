Path: utzoo!utgpu!news-server.csri.toronto.edu!cs.utexas.edu!usc!zaphod.mps.ohio-state.edu!uakari.primate.wisc.edu!dali.cs.montana.edu!milton!uw-beaver!zephyr.ens.tek.com!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v10i086:  nethack3p9 -  display oriented dungeons & dragons (Ver. 3.0i), Part41/56
Message-ID: <5946@tekred.CNA.TEK.COM>
Date: 13 Jul 90 19:38:11 GMT
Sender: news@tekred.CNA.TEK.COM
Lines: 1796
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 10, Issue 86
Archive-name: nethack3p9/Part41
Supersedes: NetHack3: Volume 7, Issue 56-93



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 41 (of 56)."
# Contents:  Install.mac others/Makefile.msc src/Makefile.src
#   src/engrave.c
# Wrapped by billr@saab on Wed Jul 11 17:11:54 1990
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'Install.mac' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Install.mac'\"
else
echo shar: Extracting \"'Install.mac'\" \(14959 characters\)
sed "s/^X//" >'Install.mac' <<'END_OF_FILE'
X                Macintosh NetHack 3.0 Installation Guide
X                ========================================
X                last modification date: May 28th, 1990
X
X(Original credit for porting NetHack 3.0 to the Macintosh goes to Johnny
XLee and Michael Sokolov. David Hairston, Kevin Sitze, Andy Swanson, Jon
XWatte and Tom West helped polish this port in later versions.)
X
X0.  Some notes before getting started. These instructions work for the
X    Think C 4.0 compiler. Other Macintosh compilers should be okay (i.e.
X    Lightspeed C 3.0 and Manx Aztec C), however some work may be needed
X    to complete the build. For other compilers you can use the various
X    Makefiles and your compiler errors as guides in building the game.
X
X    You should maintain the file/folder structure given in the distri-
X    bution file "Files". These notes assume the file structure listed
X    below. Place the "top" folder appropriately in your compilers
X    development folder. You'll need ~6M disk space for development.
X    top:
X      Files
X      Install.mac
X      Makefile.top
X      auxil:    (... all files) {auxiliary support files}
X      include:  (... all files) {header files}
X      mac:      (... all files) {Macintosh specific files}
X      others:   (pcconf.c, pcmain.c, pctty.c & random.c only)
X      src:      (... all files) {generic source files}
X
X    Now is a good time to decode the *.hqx files (mac folder), creating
X    3 Think C 4.0 project files and 2 associated resource files. You may
X    use BinHex 4.0 or Stuffit 1.5.1 for this. These 5 files (*.proj and
X    *.rsrc) should be moved from the mac folder into the "top" folder.
X
X    Use your favorite text editor to create an empty file of type "TEXT".
X    This file should be called "news" and should be placed in the auxil
X    folder. If you decide to use the news feature of NetHack you can
X    write an appropriate starting message in this file.
X
X    Create a folder called "dungeon" in your "top" folder. This is where
X    we'll copy the final files needed to run NetHack.
X
X    Finally, you should have no problem compiling the NetHack sources, as
X    distributed. However, if you intend to make changes to the sources you
X    should consider backing up your disk to prevent problems. Also, trash
X    (or perhaps alter the creator signature of) your old versions of NetHack
X    3.0 to avoid conflicts.
X
X    Okay, let's get started. We're going to make 3 applications, in order:
X    (1) makedefs, to create customized files for the game, (2) spec_lev,
X    to create special challenging maze-like levels and (3) nethack! The
X    full build from scratch takes less than an hour using Think C 4.0 .
X
X1a. Make sure all the NetHack files are in the appropriate folder structure.
X    You should have a top folder with subfolders auxil, include, mac, others,
X    and src. The provided Think C 4.0 projects assume this structure (as do
X    the provided Makefiles).
X
X1b. If your compiler doesn't handle subfolders you'll need to place all the
X    inter-related source (*.c) and header (*.h) files in a common folder. It
X    may require some work but you should be able to follow the dependencies
X    in the Makefiles to build the game.
X
X2.  If your compiler utilizes the make/Makefile facilities, you'll need to
X    remove the tags from the Makefiles (auxil, src and top) and edit them
X    appropriately. The Makefiles are not needed if you can use the provided
X    Think C 4.0 project files.
X
X3.  Edit the config.h file making the following changes to configure it
X    properly for the Macintosh:
X
X    Section 1. OS Selection.
X    Comment out: #define UNIX
X    Uncomment  : #define MACOS (bottom of the ifdef __MSDOS__ else clause).
X
X    Within the #ifdef MACOS segment configure the #define's to choose your
X    compiler. The default is to use THINKC4. For now, skip the other
X    #define's there. Note that if your compiler is LSC or AZTEC, the KR1ED
X    compiler directive is automatically defined for you. This directive
X    allows these compilers to use the defined() construct. Additionally,
X    for the LSC a/o AZTEC compilers you'll also need to add the line:
X    #define defined(x) (-x-1 != -1)
X    before the first occurrence of #if defined(x) in random.c and mon.c!
X
X    Section 2. Some global parameters and filenames.
X    For THINKC4 define the WIZARD name. A good choice is "debug" since
X    that is the purpose of this option. For LSC or AZTEC define the
X    WIZARD_NAME appropriately. This is the name that needs to appear in
X    your "NetHack Prefs" file (system folder) in order to use Wizard
X    (Debug) mode.
X
X    Comment out: #define LOGFILE "logfile"
X
X    Section 3. Definitions that may vary with system type.
X    The defaults are all okay here for THINKC4, LSC and AZTEC.
X     
X    Section 4. THE FUN STUFF!!!
X    uncomment:   #define SCORE_ON_BOTL  (This is optional. It will allow
X    you to see your current score on the bottom line during play.)
X    The rest of the #define's default to configuring a "full-featured"
X    NetHack game.
X
X    Save the config.h file.
X
X    If you intend to customize the game you will want to look at the files
X    macconf.h and system.h. This typically isn't needed for simply building
X    the game.
X
X4.  Now we're going to build the makedefs application. This application
X    depends on various header files and the source files:
X    alloc.c  macfile.c  makedefs.c  monst.c  objects.c  & panic.c .
X    If necessary look at the Makefile(.src) to determine the dependencies.
X    You'll need to load the libraries appropriate for your compiler. THINKC4
X    users can simply open the "makedefs.proj" file.
X
X    Re-edit the config.h file! Go to the #ifdef MACOS segment in section 1.
X    Comment out: #define CUSTOM_IO .
X    Uncomment  : #define MAKEDEFS_C .
X
X    Close the config.h file, saving the changes.
X
X    Build the makedefs application. The Think C 4.0 project uses resources
X    from the "makedefs.proj.rsrc" file. Save the application in the "top"
X    folder. Close the project. Run the makedefs application, sequentially
X    choosing all seven options. This will require re-launching each time.
X    You've now created additional auxiliary files for the game and added
X    icons and signatures to these 12 files (auxil folder): cmdhelp, data,
X    help, hh, history, license, MacHelp, news, opthelp, oracles, record,
X    and rumors. These files can now be copied into the dungeon folder.
X
X    If you decide to change features in the game, remember to always
X    rebuild makedefs first to setup the needed data structures and so on
X    for the game.
X
X5.  Next, we're going to build the spec_lev application. This application
X    depends on various header files and the source files:
X    alloc.c  lev_comp.c  lev_lex.c  lev_main.c  macfile.c  monst.c
X    objects.c  & panic.c
X    If you copied the alternate file lev_lex.c in the "others" folder, you
X    should remove (or rename) it to avoid problems with src:lev_lex.c. The
X    dependencies here are similar to the ones for the makedefs project.
X    Again, if necessary, refer to the Makefile(.src) for help. You should
X    need the same libraries for this application as you did for makedefs.
X    THINKC4 users can simply open the "spec_lev.proj" file.
X
X    The changes needed to build this application are more complicated than
X    before, however the checklist provided below should cover all the bases.
X
X   *Edit config.h (Section 1. within the #ifdef MACOS segment)
X    Comment out: #define MAKEDEFS_C
X    Comment out: #define NEED_VARARGS  {more on pre-compiled headers later}
X    Save the changes to config.h and close the file.
X
X   *Edit lev_lex.c. These changes will appear sequentially:
X    Find                                    Replace with
X    {... near the beginning ...}
X    int yyleng; extern char yytext[];       int yyleng; extern char *yytext;
X    int yymorfg;                            int yymorfg;
X    extern char *yysptr, yysbuf[];          extern char *yysptr, *yysbuf;
X    int yytchar;                            int yytchar;
X    FILE *yyin ={stdin}, *yyout ={stdout};  FILE *yyin =stdin, *yyout =stdout;
X    {... near the end ...}
X    {... If you're using LSC or THINKC4 comment out: ...}
X    {... #define NLSTATE yyprevious=YYNEWLINE ...}
X    char yytext[YYLMAX];                    char *yytext;
X    {... Skip a line ...}
X    char yysbuf[YYLMAX];                    char *yysbuf;
X    char *yysptr = yysbuf;                  char *yysptr;
X    Save the changes to lev_lex.c and close the file.
X
X   *Edit lev_comp.c near the middle of the file.
X    Find                                    Replace with
X    #endif not lint                         #endif /* not lint */
X    Save the change to lev_comp.c and close the file.
X
X   *Edit lev_main.c near the beginning of the file.
X    Uncomment:   #include "hack.h"
X    Save the change to lev_main.c and close the file.
X
X    Build the spec_lev application and save it into the "top" folder.
X    Close the spec_lev project. Now run the spec_lev application, it
X    will show you what file it is currently working on and create the
X    5 special levels: castle, endgame, tower1, tower2 and tower3 in
X    the top folder. These 5 files should be moved into the dungeon
X    folder.
X
X    If you're really motivated and want to create customized special
X    levels it should be possible to modify the special level compiler
X    to accomodate your efforts. You'll also want to edit the "descrip[]"
X    and "argc" variables, appropriately in lev_main.c within the ifdef
X    MACOS segments, to get the compiler to recognize your custom levels.
X    This is not trivial! You probably won't bother (no one has)!
X
X    If you decide to change features in the game, remember to rebuild
X    the special levels compiler to reflect those changes and also
X    recreate the special levels.
X
X6.  This is what you've been waiting for! Now we're going to build the
X    game. The file "Segments.mac" shows the source dependencies for this
X    application and suggests a workable scheme for creating properly sized
X    segments. THINKC4 users can simply open the "nethack.proj" file, other
X    users should build segments according to "Segments.mac" and also add
X    in the appropriate libraries.
X
X    Follow the checklist below which indicates the changes needed to build
X    the game.
X
X   *Edit topten.c near the beginning and set the following values:
X    #define POINTSMIN 51
X    #define ENTRYMAX 50
X    comment out: #define PERS_IS_UID
X    This will keep the size of the record file reasonable. Save your
X    changes and close topten.c .
X
X   *Edit config.h within the #ifdef MACOS segment:
X    uncomment:   #define CUSTOM_IO
X    uncomment:   #define NEED_VARARGS
X    Save your changes to config.h and close the file.
X
X    Since we're going to use pre-compiled headers in our THINKC4 project
X    a minor lexical change needs to be made to several files. The
X    affected files are:
X    alloc.c     apply.c     end.c       extralev.c  mkroom.c    monmove.c
X    pager.c     pctty.c     pri.c       priest.c    save.c      shk.c
X    sounds.c    termcap.c   topl.c      topten.c
X    In these files we'll need to comment out the #define's that appear
X    before the first #include compiler directive. Usually this only
X    involves a single #define (end.c, monmove.c and topten.c are exceptions).
X    This can be done fairly easily using the regular expression search
X    feature of the "Find" command. Assuming that all files are in the project
X    invoke the "Find" command from the "Search" menu. Enter these fields:
X    Search For:                            Replace with:
X    ^\(#.*pre-compiled headers \*\/\)      /*\1
X    Check the "Grep" and "Multi-File Search" check boxes (you'll be
X    looking in all .c files) then click the "Don't Find" button.
X    Now repeat this sequence:
X    1) Select "Find in Next File" from the "Search" menu.
X    2) When it finally makes a match, Select "Replace All".
X    3) Click the "Okay" button in the ensuing alert and go back to (1),
X    until there are no more matches. Save the changes to these files
X    and close them all (you may consider doing 6 at a time if having
X    too many open windows is a problem).
X
X    Copy the files hack.h and config.h to oldhack.h. and oldconfig.h,
X    respectively. You'll need the old*.h files (properly renamed) if you
X    make changes to the game and need to rebuild the makedefs and spec_lev
X    applications. Trash the hack.h file and "Open" the "oldhack.h" file
X    for editing. Select "Precompile ..." fom the "Source menu and save the
X    result as "hack.h". Close the oldhack.h file. Now trash the "config.h"
X    file and "Open" the "oldconfig.h" file for editing. Again select
X    "Precompile ..." and save the result as "config.h". Close the file
X    oldconfig.h . Make sure that you aren't auto-including "MacHeaders"
X    by selecting the "Options ..." entry from the "Edit" menu. Click the
X    "Code Generation" radio button and make sure that "<MacHeaders>" is
X    not checked.
X
X    Build the application, this make take a few minutes. Save the game
X    into the dungeon folder. Close the nethack project and you're ready
X    to play the game (I hope all went well).
X
XSpecial Note: If you are attempting to build Nethack 3.0 on a 1M Macintosh
X    using Think C 4.0, then memory may be a problem. It is suggested that
X    you turn off debugging info for monst.c and objects.c . Also, if for
X    some reason, compilation stops in the segment containing these two
X    files after they have been compiled, then you should drag these two
X    files into a separate segment, finish compiling the files of the
X    original segment and then restore these two files to the original
X    segment. Alternatively, you may decide to "Kompile" monst.c and
X    objects.c separately while preserving the given segmentation scheme.
X
X7.  Cleanup. It's a good idea to always rebuild the makedefs and spec_lev
X    applications from scratch. Therefore you can trash these applications
X    and also remove the objects from their respective projects (Think C
X    compilers) to conserve disk space. The same can be done for your
X    nethack project. Consider the changes outlined above and undo them
X    as needed to rebuild the project, if you decide to modify the game.
X    If you're satisfied with the "full-featured" game you can trash all
X    the files for a real saving!
X
XNotes:
X1.  You should trash bones and save files from previous versions since
X    they will not work with this version. Record files will work but
X    notice that new scores will have a different format. It is easiest
X    to just start fresh with a new scoreboard (record file).
X
X2.  If you can afford the RAM space you might consider giving the game
X    a 1M partition in Multifinder instead of the default 750k.
X
X    We, the members of the Macintosh NetHack Development Team, hope you
X    enjoy the game. We've worked hard at porting and polishing it to
X    make it behave in the Macintosh way!
END_OF_FILE
if test 14959 -ne `wc -c <'Install.mac'`; then
    echo shar: \"'Install.mac'\" unpacked with wrong size!
fi
# end of 'Install.mac'
fi
if test -f 'others/Makefile.msc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'others/Makefile.msc'\"
else
echo shar: Extracting \"'others/Makefile.msc'\" \(9664 characters\)
sed "s/^X//" >'others/Makefile.msc' <<'END_OF_FILE'
X#	SCCS Id: @(#)Makefile.msc	3.0	89/08/13
X#	PC NetHack 3.0 Makefile for Microsoft(tm) "C" 5.1 -- Paul Gyugyi
X#
X# Large memory model, register bug, remove stack probes:
XCC	= cl /c
XLINK	= link
XMODEL	= L
X
X# Directories (makedefs hardcodes these, don't change them)
XINCL	= ..\include
XAUX	= ..\auxil
XSRC	= ..\src
X
X# If you don't have a 286 or better, remove the /G2 in the line below.
XCFLAGS	= /A$(MODEL) /DLINT_ARGS /DDGK /Os /Oa /G2 /Gs /Gt28 /I$(INCL) /W0
XLFLAGS	= /noi /st:0x0aff /se:512
XTARG	= pc
X
X.c.o:
X	$(CC) $(CFLAGS) /Foo\$*.o $*.c 
X
X# Optional high-quality BSD random number generation routines (see pcconf.h).
X# Set to nothing if not used.
X# RANDOM = o\random.o
XRANDOM =
X
X# For NDMAKE, to handle the .o suffix.
X.SUFFIXES: .exe .o .c .y .l
X
X# The game name
XGAME= nethack
X
X# The game directory
XGAMEDIR = \games\$(GAME)
X
X# The game filename
XGAMEFILE = $(GAMEDIR)\$(GAME).exe
X
X# object files for makedefs
XMAKEOBJS = o\makedefs.o o\monst.o o\objects.o
X
X# object files for special levels compiler
XSPLEVOBJS = o\lev_comp.o o\lev_lex.o o\lev_main.o o\alloc.o o\monst.o o\objects.o o\panic.o
X
X# nothing below this line should have to be changed
X#
X# other things that have to be reconfigured are in config.h,
X# {unixconf.h, pcconf.h, tosconf.h}, and possibly system.h
X
XVOBJ =	o\allmain.o o\alloc.o o\apply.o o\artifact.o o\attrib.o o\bones.o \
X	o\cmd.o o\dbridge.o o\decl.o o\demon.o o\do.o o\do_name.o o\do_wear.o \
X	o\dog.o o\dogmove.o o\dokick.o o\dothrow.o o\eat.o o\end.o o\engrave.o \
X	o\exper.o o\extralev.o o\fountain.o o\getline.o o\hack.o o\invent.o \
X	o\lock.o o\mail.o o\main.o o\makemon.o o\mcastu.o o\mhitm.o o\mhitu.o \
X	o\mklev.o o\mkmaze.o o\mkobj.o o\mkroom.o o\mon.o o\mondata.o \
X	o\msdos.o o\monmove.o o\monst.o o\mthrowu.o o\music.o o\o_init.o \
X	o\objects.o o\objnam.o o\options.o o\pager.o o\pickup.o o\polyself.o \
X	o\potion.o o\pray.o o\pri.o o\priest.o o\prisym.o $(RANDOM) o\read.o \
X	o\restore.o o\rip.o o\rnd.o o\rumors.o o\save.o o\search.o o\shk.o \
X	o\shknam.o o\sit.o o\sounds.o o\sp_lev.o o\spell.o o\steal.o \
X	o\termcap.o o\timeout.o o\topl.o o\topten.o o\track.o o\trap.o \
X	o\tty.o o\u_init.o o\uhitm.o o\unix.o o\vault.o o\weapon.o o\were.o \
X	o\wield.o o\wizard.o o\worm.o o\worn.o o\write.o o\zap.o
XHOBJ =	$(VOBJ) o\version.o
X
XPCCONF_H   = $(INCL)\$(TARG)conf.h $(INCL)\msdos.h $(INCL)\system.h \
X	     $(INCL)\extern.h 
XGLOBAL_H   = $(INCL)\global.h $(INCL)\coord.h $(PCCONF_H)
XCONFIG_H   = $(INCL)\config.h $(INCL)\tradstdc.h $(GLOBAL_H)
XTRAP_H	   = $(INCL)\trap.h
XPERMONST_H = $(INCL)\permonst.h $(INCL)\monattk.h $(INCL)\monflag.h
XYOU_H	   = $(INCL)\you.h $(INCL)\attrib.h $(PERMONST_H) $(INCL)\mondata.h \
X	     $(INCL)\monst.h $(INCL)\youprop.h $(INCL)\prop.h $(INCL)\pm.h
XDECL_H	   = $(INCL)\decl.h $(INCL)\spell.h $(INCL)\obj.h $(YOU_H) \
X	     $(INCL)\onames.h $(INCL)\color.h
XHACK_H	   = $(CONFIG_H) $(DECL_H) $(INCL)\monsym.h $(INCL)\mkroom.h \
X	     $(INCL)\objclass.h $(INCL)\gold.h $(INCL)\trap.h $(INCL)\flag.h \
X	     $(INCL)\rm.h $(INCL)\hack.h
X
X# The main target
X# NDMAKE automatically generates LINK response files
X$(GAMEDIR)\$(GAME).exe: $(HOBJ) ltermlib.lib
X	$(LINK) $(HOBJ),nethack,nethack,$(SRC)\ltermlib $(LFLAGS)
X
X
X$(GAME): $(GAMEDIR)\$(GAME).exe
X$(GAME).exe: $(GAMEDIR)\$(GAME).exe
X
X
X# make ltermlib.lib -- replaces makefile in termcap.arc
X# unarc termcap.arc into src directory, but be careful that the
X# makefile in the archive does not overwrite this one
XTL_LSOURCES =	tgetent.c tgetflag.c tgetnum.c tgetstr.c tgoto.c tputs.c \
X		isdigit.c fgetlr.c
X
XTL_LOBJECTS =	o\tgetent.o o\tgetflag.o o\tgetnum.o o\tgetstr.o \
X                o\tgoto.o o\tputs.o o\isdigit.o o\fgetlr.o
X
Xltermlib.lib :	$(TL_LOBJECTS)
X		lib ltermlib.lib -+ $(TL_LOBJECTS);
X
X.c.o:
X	$(CC) $(CFLAGS) /Fo.\o\$*.o $*.c
X
Xall:	o lev_comp.exe $(GAME) auxil.tag install.tag
X	@echo Done.
X
Xo:
X	if not exist .\o\*.* mkdir o
X
Xmakedefs.exe:	$(MAKEOBJS)
X	$(LINK) $(LFLAGS) $(MAKEOBJS);
X
Xo\makedefs.o:  $(INCL)\config.h $(INCL)\permonst.h $(INCL)\objclass.h
X
Xlev_comp.exe:  $(SPLEVOBJS)
X	$(LINK) $(LFLAGS) $(SPLEVOBJS),lev_comp.exe;
X
Xo\lev_comp.o:  $(HACK_H) $(INCL)\sp_lev.h
Xo\lev_lex.o:  $(INCL)\lev_comp.h $(HACK_H) $(INCL)\sp_lev.h
Xo\lev_main.o:  $(HACK_H)
X
X# If you have yacc or lex programs, and make any changes,
X# add some .y.c and .l.c rules to your Make.ini.
X
Xlev_comp.c:  lev_comp.y
Xlev_lex.c:  lev_comp.l
X
X#
X#	The following include files depend on makedefs to be created.
X#
X#	date.h should be remade any time any of the source or include code
X#	is modified.
X#
X$(INCL)\date.h:	 $(VOBJ) makedefs.exe
X	.\makedefs -v
X
X$(INCL)\trap.h:	 makedefs.exe
X	.\makedefs -t
X
X$(INCL)\onames.h:  makedefs.exe
X	.\makedefs -o
X
X$(INCL)\pm.h:  makedefs.exe
X	.\makedefs -p
X
Xdata:	$(AUX)\data.base makedefs.exe
X	.\makedefs -d
X
Xrumors: $(AUX)\rumors.tru $(AUX)\rumors.fal makedefs.exe
X	.\makedefs -r
X
X#
X#	The following programs vary depending on what OS you are using.
X#
Xo\main.o:   $(HACK_H) $(TARG)main.c
X	$(CC) $(CFLAGS)  /Fo.\o\main.o $(TARG)main.c
X
Xo\tty.o:   $(HACK_H) $(INCL)\func_tab.h $(TARG)tty.c
X	$(CC) $(CFLAGS)  /Fo.\o\tty.o $(TARG)tty.c
X
Xo\unix.o:   $(HACK_H) $(TARG)unix.c
X	$(CC) $(CFLAGS)  /Fo.\o\unix.o $(TARG)unix.c
X
X#
X# Secondary targets
X#
X
Xauxil.tag:	spec_levs.tag data rumors termcap
X# the tag file is a dummy file to keep from redoing this every make
X        echo special levels created > auxil.tag
X
Xinstall.tag:
X# always done
X# assume \games exists already, but make it just to make sure
X        md \games
X        md $(GAMEDIR)
X        md $(GAMEDIR)\bones
X        echo y>yes.txt
X#
X#       Watch Out!  The next command cleans out the game & bones dirs!
X#       This will delete any config file you have and overwrite it
X#       with the default.
X#       Since the game options may have changed since your last install, 
X#       you should say yes to clean the directory.
X#
X        del $(GAMEDIR)\*.* < yes.txt
X        del $(GAMEDIR)\bones\*.* < yes.txt
X        copy termcap     $(GAMEDIR)\termcap
X        copy castle      $(GAMEDIR)
X	copy endgame     $(GAMEDIR)
X	copy tower?      $(GAMEDIR)
X        copy $(GAME).exe $(GAMEDIR)
X	copy $(AUX)\*.   $(GAMEDIR)
X        copy nethack.cnf $(GAMEDIR)
X        echo record >    $(GAMEDIR)\record
X        echo install done >install.tag
X
X
Xspec_levs.tag: lev_comp.exe $(AUX)\castle.des $(AUX)\endgame.des $(AUX)\tower.des
X	lev_comp $(AUX)\castle.des
X	lev_comp $(AUX)\endgame.des
X	lev_comp $(AUX)\tower.des
X        echo spec_lev done >spec_levs.tag
X
Xclean:
X	del o\*.o
X	rmdir o
X
Xspotless: clean
X	cd $(INCL)
X	del date.h
X	del onames.h
X	del pm.h
X	cd $(SRC)
X	del makedefs.exe
X	del lev_comp.exe
X        del $(AUX)\data
X        del $(AUX)\rumors
X        del castle
X        del endgame
X        del tower?
X        del *.tag
X        del $(GAME).exe
X        del $(GAME).map
X
X#
X# Other dependencies
X#
X
X# GO AHEAD, DELETE THIS LINE
X
Xo\allmain.o:  $(HACK_H)
Xo\alloc.o:  $(CONFIG_H)
Xo\apply.o:  $(HACK_H) $(INCL)\edog.h
Xo\artifact.o:  $(HACK_H) $(INCL)\artifact.h
Xo\attrib.o:  $(HACK_H)
Xo\bones.o:  $(HACK_H)
Xo\cmd.o:  $(HACK_H) $(INCL)\func_tab.h
Xo\dbridge.o: $(HACK_H)
Xo\decl.o:  $(HACK_H)
Xo\demon.o:  $(HACK_H)
Xo\do.o:  $(HACK_H)
Xo\do_name.o:  $(HACK_H)
Xo\do_wear.o:  $(HACK_H)
Xo\dog.o:  $(HACK_H) $(INCL)\edog.h
Xo\dogmove.o:  $(HACK_H) $(INCL)\mfndpos.h $(INCL)\edog.h
Xo\dokick.o:  $(HACK_H) $(INCL)\eshk.h
Xo\dothrow.o:  $(HACK_H)
Xo\eat.o:  $(HACK_H)
Xo\end.o:  $(HACK_H) $(INCL)\eshk.h
Xo\engrave.o:  $(HACK_H)
Xo\exper.o:  $(HACK_H)
Xo\extralev.o:  $(HACK_H)
Xo\fountain.o:  $(HACK_H)
Xo\getline.o:  $(HACK_H) $(INCL)\func_tab.h
Xo\hack.o:  $(HACK_H)
Xo\invent.o:  $(HACK_H) $(INCL)\lev.h $(INCL)\wseg.h
Xo\ioctl.o:  $(HACK_H)
Xo\lock.o:  $(HACK_H)
Xo\makemon.o:  $(HACK_H)
Xo\mail.o:  $(HACK_H)
Xo\mcastu.o:  $(HACK_H)
Xo\mhitm.o:  $(HACK_H) $(INCL)\artifact.h
Xo\mhitu.o:  $(HACK_H) $(INCL)\artifact.h $(INCL)\edog.h
Xo\mklev.o:  $(HACK_H)
Xo\mkmaze.o:  $(HACK_H)
Xo\mkobj.o:  $(HACK_H)
Xo\mkroom.o:  $(HACK_H)
Xo\mon.o:  $(HACK_H) $(INCL)\mfndpos.h $(INCL)\wseg.h
Xo\mondata.o:  $(HACK_H) $(INCL)\eshk.h $(INCL)\epri.h
Xo\monmove.o:  $(HACK_H) $(INCL)\mfndpos.h $(INCL)\artifact.h
Xo\monst.o:  $(CONFIG_H) $(PERMONST_H) $(INCL)\monsym.h $(INCL)\eshk.h $(INCL)\vault.h $(INCL)\epri.h $(INCL)\color.h
Xo\msdos.o:  $(HACK_H)
Xo\mthrowu.o:  $(HACK_H)
Xo\music.o:  $(HACK_H)
Xo\o_init.o:  $(HACK_H)
Xo\objects.o:  $(CONFIG_H) $(INCL)\obj.h $(INCL)\objclass.h $(INCL)\prop.h $(INCL)\color.h
Xo\objnam.o:  $(HACK_H)
Xo\options.o:  $(HACK_H)
Xo\pager.o:  $(HACK_H)
Xo\panic.o:  $(CONFIG_H)
Xo\pickup.o:  $(HACK_H)
Xo\polyself.o:  $(HACK_H)
Xo\potion.o:  $(HACK_H)
Xo\pray.o:  $(HACK_H)
Xo\pri.o:  $(HACK_H) $(INCL)\epri.h $(INCL)\termcap.h
Xo\priest.o:  $(HACK_H) $(INCL)\mfndpos.h $(INCL)\eshk.h $(INCL)\epri.h
Xo\prisym.o:  $(HACK_H) $(INCL)\lev.h $(INCL)\wseg.h
Xo\random.o:
Xo\read.o:  $(HACK_H)
Xo\restore.o:  $(HACK_H) $(INCL)\lev.h $(INCL)\wseg.h
Xo\rip.o:  $(HACK_H)
Xo\rnd.o:  $(HACK_H)
Xo\rumors.o:  $(HACK_H)
Xo\save.o:  $(HACK_H) $(INCL)\lev.h $(INCL)\wseg.h
Xo\search.o:  $(HACK_H) $(INCL)\artifact.h
Xo\shk.o:  $(HACK_H) $(INCL)\eshk.h
Xo\shknam.o:  $(HACK_H) $(INCL)\eshk.h
Xo\sit.o:  $(HACK_H)
Xo\sounds.o:  $(HACK_H) $(INCL)\edog.h $(INCL)\eshk.h
Xo\sp_lev.o:  $(HACK_H) $(INCL)\sp_lev.h
Xo\spell.o:  $(HACK_H)
Xo\steal.o:  $(HACK_H)
Xo\termcap.o:  $(HACK_H) $(INCL)\termcap.h
Xo\timeout.o:  $(HACK_H)
Xo\topl.o:  $(HACK_H)
Xo\topten.o:  $(HACK_H)
Xo\track.o:  $(HACK_H)
Xo\trap.o:  $(HACK_H) $(INCL)\edog.h
Xo\u_init.o:  $(HACK_H)
Xo\uhitm.o:  $(HACK_H) $(INCL)\artifact.h
Xo\vault.o:  $(HACK_H) $(INCL)\vault.h
Xo\version.o:  $(HACK_H) $(INCL)\date.h $(INCL)\patchlev.h
Xo\weapon.o:  $(HACK_H)
Xo\were.o:  $(HACK_H)
Xo\wield.o:  $(HACK_H)
Xo\wizard.o:  $(HACK_H)
Xo\worm.o:  $(HACK_H) $(INCL)\wseg.h
Xo\worn.o:  $(HACK_H)
Xo\write.o:  $(HACK_H)
Xo\zap.o:  $(HACK_H)
END_OF_FILE
if test 9664 -ne `wc -c <'others/Makefile.msc'`; then
    echo shar: \"'others/Makefile.msc'\" unpacked with wrong size!
fi
# end of 'others/Makefile.msc'
fi
if test -f 'src/Makefile.src' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/Makefile.src'\"
else
echo shar: Extracting \"'src/Makefile.src'\" \(16622 characters\)
sed "s/^X//" >'src/Makefile.src' <<'END_OF_FILE'
X#	Hack Makefile.
X#	SCCS Id: @(#)Makefile.unix	3.0	88/10/17
X
X# This makefile replaces the previous Makefile.unix, Makefile.xenix,
X# Makefile.3B2, Makefile.att, and Makefile.tos.
X# Set SYSTEM to one of:
X#	'Sysunix'	-- generic UNIX
X#	'Sys3B2'	-- AT&T 3B2, 3B5, etc.
X#	'Sysatt'	-- AT&T UNIXPC, 7300, 3B1
X#	'Systos'	-- Atari
X#	'SysV-AT'	-- Microport 286 UNIX (put -DDUMB in CFLAGS)
XSYSTEM = Sysunix
X
X#
X# Make sure that your bourne shell is specified here, as you have to spawn
X# some of the commands (eg. depend) in bourne shell for them to work.
X#
XSHELL=/bin/sh
X
X# if you are cross-compiling (eg. from Xenix into a Dos environment) you will
X# have to redefine this filename prefix (which is used to select the filenames
X# *main.c, *tty.c, and *unix.c for the target environment)
X#
X# possible values are 'unix' and 'pc'
X# Systos wants 'pc'; everything else normally wants 'unix'
XTARG = unix
X
X
X# if you are using gcc as your compiler:
X#	uncomment the CC definition below if it's not in your environment
X#	if you get setcgtty() warnings during execution, you are feeding gcc
X#		a non-ANSI <sys/ioctl.h> -- either run fixincludes on it or use
X#		-traditional in CFLAGS
X# CC = gcc
X
X# flags may have to be changed as required
X# flags for 286 Xenix:
X# CFLAGS = -Ml2t16 -O -LARGE -I../include
X# LFLAGS = -Ml -F 4000 -SEG 512
X
X# flags for 286 Microport SysV-AT
X# CFLAGS = -DDUMB -Ml -I../include
X# LFLAGS = -Ml
X
X# flags for Atari GCC
X# CFLAGS = -mshort -O -I../include
X# LFLAGS = -s -mshort
X
X# flags for Apollos using their native cc
X# (as long as it claims to be __STDC__ but isn't)
X# CFLAGS = -DAPOLLO -O -I../include
X
X# flags for debugging:
X# CFLAGS = -g -I../include
X
XCFLAGS = -O -I../include
XLFLAGS =
X
X
X# on some systems the termcap library is in -ltermcap or -lcurses
X# on 386 Xenix, the -ltermlib tputs() seems not to work; use -lcurses instead
X# Sysatt uses shared library in lieu of this option
X# Systos needs -lcurses16 if you use -mshort
X#
X# TERMLIB = -ltermcap
X# TERMLIB = -lcurses
XTERMLIB = -ltermlib
X
X# any other strange libraries your system needs (for Sysunix only -- the more
X# specialized targets should already be right)
X#
X# on HP-UX, the malloc(3x) routines in libmalloc.a seem to align things
X# better than the malloc(3) ones in libc.a
X# LIBS = -lmalloc
XLIBS =
X
X# yacc/lex programs to use to generate lev_comp.c, lev_comp.h, and lev_lex.c.
X# if, instead of yacc/lex you have bison/flex, comment/uncomment the following.
XYACC     = yacc
XLEX      = lex
X# YACC     = bison -y
X# LEX      = flex
X
X# make NetHack
XGAME     = nethack
X
X# if you defined RANDOM in unixconf.h/pcconf.h since your system did not come
X# with a reasonable random number generator -- also remember to get random.c
X# into the src directory
X# RANDOBJ = random.o
XRANDOBJ =
X
X# nothing below this line should have to be changed
X#
X# other things that have to be reconfigured are in config.h,
X# {unixconf.h, pcconf.h, tosconf.h}, and possibly system.h
X
XHACKCSRC = allmain.c alloc.c apply.c artifact.c attrib.c bones.c cmd.c\
X	   dbridge.c decl.c demon.c do.c do_name.c do_wear.c dog.c dogmove.c\
X	   dokick.c dothrow.c eat.c end.c engrave.c exper.c extralev.c\
X	   fountain.c getline.c hack.c invent.c ioctl.c lock.c mail.c makemon.c\
X	   mcastu.c mhitm.c mhitu.c mklev.c mkmaze.c mkobj.c mkroom.c mon.c\
X	   mondata.c monmove.c monst.c mthrowu.c music.c o_init.c objects.c\
X	   objnam.c options.c pager.c pickup.c polyself.c potion.c pray.c pri.c\
X	   priest.c prisym.c read.c restore.c rip.c rnd.c rumors.c save.c\
X	   search.c shk.c shknam.c sit.c sounds.c sp_lev.c spell.c steal.c\
X	   termcap.c timeout.c topl.c topten.c track.c trap.c u_init.c uhitm.c\
X	   vault.c version.c weapon.c were.c wield.c wizard.c worm.c worn.c\
X	   write.c zap.c
X
X# all .c that are part of the main NetHack program and are not system specific
X
X# now the other .c files, with duplicates commented out
XMAKESRC = makedefs.c # monst.c objects.c
XSPLEVSRC = lev_comp.c lev_lex.c lev_main.c panic.c # alloc.c monst.c objects.c
XTARGSRC = $(TARG)main.c $(TARG)tty.c $(TARG)unix.c
X
XCSOURCES = $(HACKCSRC) $(TARGSRC) $(MAKESRC) $(SPLEVSRC)
X
XHACKINCL = amiconf.h artifact.h attrib.h color.h config.h coord.h decl.h\
X	   def_os2.h edog.h epri.h eshk.h extern.h flag.h func_tab.h global.h\
X	   gold.h hack.h lev.h macconf.h mfndpos.h mkroom.h monattk.h mondata.h\
X	   monflag.h monst.h monsym.h msdos.h obj.h objclass.h patchlevel.h\
X	   pcconf.h permonst.h prop.h rm.h sp_lev.h spell.h system.h termcap.h\
X	   tosconf.h tradstdc.h unixconf.h vault.h vmsconf.h wseg.h you.h\
X	   youprop.h
X
X# all .h files except date.h, onames.h, pm.h & trap.h which would cause
X# dependency loops if run through "make depend"
X# and lev_comp.h, a special level file.
X
XHSOURCES = $(HACKINCL) date.h onames.h pm.h trap.h lev_comp.h
X
XSOURCES = $(CSOURCES) $(HSOURCES)
X
X# object files for makedefs
XMAKEOBJS = makedefs.o monst.o objects.o
X
X# object files for special levels compiler
XSPLEVOBJS = lev_comp.o lev_lex.o lev_main.o alloc.o monst.o objects.o panic.o
X
XHOBJ = allmain.o alloc.o apply.o artifact.o attrib.o bones.o cmd.o dbridge.o\
X	decl.o demon.o do.o do_name.o do_wear.o dog.o dogmove.o dokick.o\
X	dothrow.o eat.o end.o engrave.o exper.o extralev.o fountain.o getline.o\
X	hack.o invent.o ioctl.o lock.o mail.o main.o makemon.o mcastu.o mhitm.o\
X	mhitu.o mklev.o mkmaze.o mkobj.o mkroom.o mon.o mondata.o monmove.o\
X	monst.o mthrowu.o music.o o_init.o objects.o objnam.o options.o pager.o\
X	pickup.o polyself.o potion.o pray.o pri.o priest.o prisym.o read.o\
X	restore.o rip.o rnd.o rumors.o save.o search.o shk.o shknam.o sit.o\
X	sounds.o sp_lev.o spell.o steal.o termcap.o timeout.o topl.o topten.o\
X	track.o trap.o tty.o u_init.o uhitm.o unix.o vault.o version.o\
X	weapon.o were.o wield.o wizard.o worm.o worn.o write.o zap.o $(RANDOBJ)
X
X# the .o files from the HACKCSRC list, plus main.o tty.o unix.o
X
X$(GAME):	$(SYSTEM)
X	@echo "$(GAME) is up to date."
X
XSysunix:	$(HOBJ) Makefile
X	@echo "Loading ..."
X	@$(CC) $(LFLAGS) -o $(GAME) $(HOBJ) $(TERMLIB) $(LIBS)
X	@touch Sysunix
X
XSys3B2:	$(HOBJ) Makefile
X	@echo "Loading ..."
X	@$(CC) $(LFLAGS) -o $(GAME) $(HOBJ) $(TERMLIB) -lmalloc
X	@touch Sys3B2
X
XSysatt:	$(HOBJ) Makefile
X	@echo "Loading ..."
X	@$(LD) $(LFLAGS) /lib/crt0s.o /lib/shlib.ifile -o $(GAME) $(HOBJ)
X	@touch Sysatt
X
XSystos:	$(HOBJ) msdos.o Makefile
X	@echo "Loading ..."
X	@$(CC) $(LFLAGS) -o $(GAME) $(HOBJ) msdos.o $(TERMLIB)
X	@touch Systos
X
XSysV-AT:	DUMB.Setup $(HOBJ) Makefile
X	@echo "Loading ..."
X	@$(CC) $(LFLAGS) -o $(GAME) $(HOBJ) $(TERMLIB)
X	@touch SysV-AT
X
XDUMB.Setup:	../include/extern.h
X	cp ../include/extern.h ../include/extern.h.BAK 
X	cat ../include/extern.h | \
X		sed -e '/^E\ int\ /!b' \
X			-e '/[^;/ 	]$$/N' \
X			-e '/[(][*]occupation[)]/b' \
X			-e '/[(][*]afternmv[)]/b' \
X			-e '/float_down/b' \
X			-e '/done1/b' \
X			-e '/identify/b' \
X			-e '/Hear_again/b' \
X			-e '/hangup/b' \
X			-e 's/^\(.*\)$$/\/\* \1 \/\*\*\//' | \
X		sed -e '/^E\ void\ /!b' \
X			-e '/[^;/ 	]$$/N' \
X			-e 's/^\(.*\)$$/\/\* \1 \/\*\*\//' \
X				>../include/extern.DUMB 
X	cp ../include/extern.DUMB ../include/extern.h 
X	@touch DUMB.Setup
X
Xall:	$(GAME)
X
X#
X#	dependencies for auxiliary programs
X#
Xmakedefs:	$(MAKEOBJS)
X	$(CC) $(LFLAGS) -o makedefs $(MAKEOBJS)
X
Xmakedefs.o:  ../include/config.h ../include/permonst.h ../include/objclass.h ../include/patchlevel.h
X
Xlev_comp:  $(SPLEVOBJS)
X	$(CC) $(LFLAGS) -o lev_comp $(SPLEVOBJS)
X
Xlev_comp.o:  ../include/hack.h ../include/sp_lev.h
X
Xlev_lex.o:   ../include/hack.h ../include/lev_comp.h ../include/sp_lev.h
X
Xlev_main.o:  ../include/hack.h
X
X../include/lev_comp.h: lev_comp.c
X
Xlev_comp.c: lev_comp.y
X	$(YACC) -d lev_comp.y
X	mv y.tab.c lev_comp.c
X	mv y.tab.h ../include/lev_comp.h
X
Xlev_lex.c: lev_comp.l
X	$(LEX) lev_comp.l
X	mv lex.yy.c lev_lex.c
X
X#
X#	The following include files depend on makedefs to be created.
X#	As a result, they are not defined in HACKINCL; instead, their
X#	dependencies are explicitly outlined here.
X#
X
X#
X#	date.h should be remade any time any of the source or include code
X#	is modified.  Unfortunately, this would make the contents of this
X#	file far more complex.  Since "hack.h" depends on most of the include
X#	files, we kludge around this by making date.h dependent on hack.h,
X#	even though it doesn't include this file.
X#
X../include/date.h:	$(HACKCSRC) $(TARGSRC) ../include/hack.h makedefs
X	./makedefs -v
X
X../include/trap.h:	makedefs
X	./makedefs -t
X
X../include/onames.h:	makedefs
X	./makedefs -o
X
X../include/pm.h:	makedefs
X	./makedefs -p
X
X#
X#	The following programs vary depending on what OS you are using.
X#	As a result, they are not defined in HACKSRC, and their dependencies
X#	are explicitly outlined here.
X#
Xmain.o:	../include/hack.h $(TARG)main.c
X	$(CC) $(CFLAGS) -c $(TARG)main.c
X	mv $(TARG)main.o main.o
X
Xtty.o:	../include/hack.h $(TARG)tty.c
X	$(CC) $(CFLAGS) -c $(TARG)tty.c
X	mv $(TARG)tty.o tty.o
X
Xunix.o:	../include/hack.h $(TARG)unix.c
X	$(CC) $(CFLAGS) -c $(TARG)unix.c
X	mv $(TARG)unix.o unix.o
X
Xlint:
X# lint cannot have -p here because (i) capitals are meaningful:
X# [Ww]izard, (ii) identifiers may coincide in the first six places:
X# doweararm() versus dowearring().
X# _flsbuf comes from <stdio.h>, a bug in the system libraries.
X	@echo lint -axbh -DLINT ...
X	@lint -axbh -I../include -DLINT $(HACKCSRC) $(TARGSRC) | sed '/_flsbuf/d'
X
X
Xdiff:
X	@- for i in $(SOURCES) ; do \
X		cmp -s $$i $D/$$i || \
X		( echo diff $D/$$i $$i ; diff $D/$$i $$i ; echo ) ; done
X
Xtags: $(CSOURCES)
X	@echo ctags -tw ...
X	@ctags -tw $(CSOURCES)
X	@( cd ../include ; ctags -tw $(HSOURCES) )
X  
Xclean:
X	rm -f *.o
X
Xspotless: clean
X	rm -f a.out core $(GAME) lev_comp makedefs
X	rm -f ../include/onames.h ../include/pm.h
X
X
Xdepend:
X# For the moment we are lazy and disregard /usr/include files because
X# the sources contain them conditionally. Perhaps we should use cpp.
X#		( /bin/grep '^#[ 	]*include' $$i | sed -n \
X#			-e 's,<\(.*\)>,"/usr/include/\1",' \
X#
X# extern.h is ignored, even though its declared function types may affect the
X# compilation of all the .c files, since extern.h changes every time the
X# type of an external function does, and we would spend all our time recompiling
X# if we did not ignore it.  the risk is minimal, as lint should pick up any
X# calls to the modified function that were not modified accordingly.
X#
X# patchlev.h is the name MS-DOS uses to refer to patchlevel.h after it gets
X# through truncating the name, but it does not really exist
X#
X	for i in ${HACKCSRC}; do \
X		( /bin/grep '^#[ 	]*include[ 	]*"' $$i | sed -n \
X			-e 's/[^"]*"\([^"]*\)".*/\1/' \
X			-e 's/patchlev.h//' \
X			-e 's/.*\.h/..\/include\/&/' \
X			-e H -e '$$g' -e '$$s/\n/ /g' \
X			-e '$$s/.*/'$$i': &/' -e '$$s/\.c:/.o:/p' \
X			>> makedep); done
X	for i in ${HACKINCL}; do \
X	    ( /bin/grep '^#[ 	]*include[ 	]*"' ../include/$$i | sed -n \
X			-e 's/[^"]*"\([^"]*\)".*/\1/' \
X			-e 's/extern.h//' \
X			-e 's/.*\.h/..\/include\/&/' \
X			-e H -e '$$g' -e '$$s/\n/ /g' \
X			-e '$$s/.*/..\/include\/'$$i': &\
X				touch ..\/include\/'$$i/p \
X			>> makedep); done
X	@echo '/^# DO NOT DELETE THIS LINE/+2,$$d' >eddep
X	@echo '$$r makedep' >>eddep
X	@echo 'w' >>eddep
X	@cp Makefile Makefile.bak
X	ed - Makefile < eddep
X	@rm -f eddep makedep
X	@echo '# DEPENDENCIES MUST END AT END OF FILE' >> Makefile
X	@echo '# IF YOU PUT STUFF HERE IT WILL GO AWAY' >> Makefile
X	@echo '# see make depend above' >> Makefile
X	- diff Makefile.bak Makefile
X	@rm -f Makefile.bak
X
X# PC dependency for Systos that won't be made on a UNIX system
Xmsdos.o:  ../include/hack.h
X
X# DO NOT DELETE THIS LINE
X
Xallmain.o:  ../include/hack.h
Xalloc.o:  ../include/config.h
Xapply.o:  ../include/hack.h ../include/edog.h
Xartifact.o:  ../include/hack.h ../include/artifact.h
Xattrib.o:  ../include/hack.h
Xbones.o:  ../include/hack.h
Xcmd.o:  ../include/hack.h ../include/func_tab.h
Xdbridge.o:  ../include/hack.h
Xdecl.o:  ../include/hack.h
Xdemon.o:  ../include/hack.h
Xdo.o:  ../include/hack.h
Xdo_name.o:  ../include/hack.h
Xdo_wear.o:  ../include/hack.h
Xdog.o:  ../include/hack.h ../include/edog.h
Xdogmove.o:  ../include/hack.h ../include/mfndpos.h ../include/edog.h
Xdokick.o:  ../include/hack.h ../include/eshk.h
Xdothrow.o:  ../include/hack.h
Xeat.o:  ../include/hack.h
Xend.o:  ../include/hack.h ../include/eshk.h
Xengrave.o:  ../include/hack.h
Xexper.o:  ../include/hack.h
Xextralev.o:  ../include/hack.h
Xfountain.o:  ../include/hack.h
Xgetline.o:  ../include/hack.h ../include/func_tab.h
Xhack.o:  ../include/hack.h
Xinvent.o:  ../include/hack.h ../include/lev.h ../include/wseg.h
Xioctl.o:  ../include/hack.h
Xlock.o:  ../include/hack.h
Xmail.o:  ../include/hack.h
Xmakemon.o:  ../include/hack.h
Xmcastu.o:  ../include/hack.h
Xmhitm.o:  ../include/hack.h ../include/artifact.h
Xmhitu.o:  ../include/hack.h ../include/artifact.h ../include/edog.h
Xmklev.o:  ../include/hack.h
Xmkmaze.o:  ../include/hack.h
Xmkobj.o:  ../include/hack.h
Xmkroom.o:  ../include/hack.h
Xmon.o:  ../include/hack.h ../include/mfndpos.h ../include/wseg.h
Xmondata.o:  ../include/hack.h ../include/eshk.h ../include/epri.h
Xmonmove.o:  ../include/hack.h ../include/mfndpos.h ../include/artifact.h
Xmonst.o:  ../include/config.h ../include/permonst.h ../include/monsym.h ../include/eshk.h ../include/vault.h ../include/epri.h ../include/color.h
Xmthrowu.o:  ../include/hack.h
Xmusic.o:  ../include/hack.h
Xo_init.o:  ../include/hack.h
Xobjects.o:  ../include/config.h ../include/obj.h ../include/objclass.h ../include/prop.h ../include/color.h
Xobjnam.o:  ../include/hack.h
Xoptions.o:  ../include/hack.h
Xpager.o:  ../include/hack.h
Xpickup.o:  ../include/hack.h
Xpolyself.o:  ../include/hack.h
Xpotion.o:  ../include/hack.h
Xpray.o:  ../include/hack.h
Xpri.o:  ../include/hack.h ../include/epri.h ../include/termcap.h
Xpriest.o:  ../include/hack.h ../include/mfndpos.h ../include/eshk.h ../include/epri.h
Xprisym.o:  ../include/hack.h ../include/wseg.h ../include/lev.h
Xread.o:  ../include/hack.h
Xrestore.o:  ../include/hack.h ../include/lev.h ../include/wseg.h
Xrip.o:  ../include/hack.h
Xrnd.o:  ../include/hack.h
Xrumors.o:  ../include/hack.h
Xsave.o:  ../include/hack.h ../include/lev.h ../include/wseg.h
Xsearch.o:  ../include/hack.h ../include/artifact.h
Xshk.o:  ../include/hack.h ../include/eshk.h
Xshknam.o:  ../include/hack.h ../include/eshk.h
Xsit.o:  ../include/hack.h
Xsounds.o:  ../include/hack.h ../include/edog.h ../include/eshk.h
Xsp_lev.o:  ../include/hack.h ../include/sp_lev.h
Xspell.o:  ../include/hack.h
Xsteal.o:  ../include/hack.h
Xtermcap.o:  ../include/hack.h ../include/termcap.h
Xtimeout.o:  ../include/hack.h
Xtopl.o:  ../include/hack.h
Xtopten.o:  ../include/hack.h
Xtrack.o:  ../include/hack.h
Xtrap.o:  ../include/hack.h ../include/edog.h
Xu_init.o:  ../include/hack.h
Xuhitm.o:  ../include/hack.h ../include/artifact.h
Xvault.o:  ../include/hack.h ../include/vault.h
Xversion.o:  ../include/hack.h ../include/date.h  ../include/patchlevel.h
Xweapon.o:  ../include/hack.h
Xwere.o:  ../include/hack.h
Xwield.o:  ../include/hack.h
Xwizard.o:  ../include/hack.h
Xworm.o:  ../include/hack.h ../include/wseg.h
Xworn.o:  ../include/hack.h
Xwrite.o:  ../include/hack.h
Xzap.o:  ../include/hack.h
X../include/amiconf.h:  ../include/msdos.h ../include/pcconf.h
X			touch ../include/amiconf.h
X../include/config.h:  ../include/tradstdc.h ../include/global.h
X			touch ../include/config.h
X../include/decl.h:  ../include/spell.h ../include/color.h ../include/obj.h ../include/you.h ../include/onames.h ../include/pm.h
X			touch ../include/decl.h
X../include/global.h:  ../include/coord.h ../include/vmsconf.h ../include/unixconf.h ../include/pcconf.h ../include/tosconf.h ../include/amiconf.h ../include/macconf.h
X			touch ../include/global.h
X../include/hack.h:  ../include/config.h ../include/decl.h ../include/monsym.h ../include/mkroom.h ../include/objclass.h ../include/gold.h ../include/trap.h ../include/flag.h ../include/rm.h  ../include/trampoli.h 
X			touch ../include/hack.h
X../include/macconf.h:  ../include/msdos.h ../include/system.h  ../include/MacAlert.h
X			touch ../include/macconf.h
X../include/pcconf.h:  ../include/msdos.h ../include/system.h
X			touch ../include/pcconf.h
X../include/permonst.h:  ../include/monattk.h ../include/monflag.h
X			touch ../include/permonst.h
X../include/tosconf.h:  ../include/msdos.h ../include/pcconf.h
X			touch ../include/tosconf.h
X../include/unixconf.h:  ../include/system.h
X			touch ../include/unixconf.h
X../include/vmsconf.h:  ../include/system.h
X			touch ../include/vmsconf.h
X../include/you.h:  ../include/attrib.h ../include/monst.h ../include/youprop.h
X			touch ../include/you.h
X../include/youprop.h:  ../include/prop.h ../include/permonst.h ../include/mondata.h ../include/pm.h
X			touch ../include/youprop.h
X# DEPENDENCIES MUST END AT END OF FILE
X# IF YOU PUT STUFF HERE IT WILL GO AWAY
X# see make depend above
END_OF_FILE
if test 16622 -ne `wc -c <'src/Makefile.src'`; then
    echo shar: \"'src/Makefile.src'\" unpacked with wrong size!
fi
# end of 'src/Makefile.src'
fi
if test -f 'src/engrave.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/engrave.c'\"
else
echo shar: Extracting \"'src/engrave.c'\" \(14925 characters\)
sed "s/^X//" >'src/engrave.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)engrave.c	3.0	89/11/15
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include	"hack.h"
X
XSTATIC_VAR struct engr {
X	struct engr *nxt_engr;
X	char *engr_txt;
X	xchar engr_x, engr_y;
X	unsigned engr_lth;	/* for save & restore; not length of text */
X	long engr_time;	/* moment engraving was (will be) finished */
X	xchar engr_type;
X#define DUST	1
X#define ENGRAVE	2
X#define BURN	3
X#define MARK	4
X#define POLY	5	/* temporary type - for polymorphing engraving */
X} NEARDATA *head_engr;
X
XSTATIC_DCL void FDECL(del_engr, (struct engr *));
XSTATIC_DCL struct engr * FDECL(engr_at,(XCHAR_P,XCHAR_P));
X
X#ifdef OVLB
X/* random engravings */
Xconst char *random_engr[] =
X			 {"Elbereth", "ad ae?ar um",
X			 "?la? ?as he??",
X			 /* more added by Eric Backus */
X			 "?ilroy wa? h?re", "?ala??iel",
X			 "Fo? a ?ood time c?ll 6?6-4311",
X			 /* some other famous engravings -3. */
X			 "Lasc?ate o?ni sp?ranz? o vo? c?'en?rate",
X			 "Y?u won?t get i? up ?he ste?s",
X			 "A.S. ->"};
X
X#endif /* OVLB */
X#ifdef OVL0
X
XSTATIC_OVL struct engr *
Xengr_at(x,y) register xchar x,y; {
Xregister struct engr *ep = head_engr;
X	while(ep) {
X		if(x == ep->engr_x && y == ep->engr_y)
X			return(ep);
X		ep = ep->nxt_engr;
X	}
X	return((struct engr *) 0);
X}
X
X#ifdef ELBERETH
Xint
Xsengr_at(s,x,y)
X	register const char *s;
X	register xchar x,y;
X{
X	register struct engr *ep = engr_at(x,y);
X	register char *t;
X	register int n;
X
X	if(ep && ep->engr_time <= moves) {
X		t = ep->engr_txt;
X/*
X		if(!strcmp(s,t)) return(1);
X*/
X		n = strlen(s);
X		while(*t) {
X			if(!strncmp(s,t,n)) return(1);
X			t++;
X		}
X	}
X	return(0);
X}
X#endif
X
X#endif /* OVL0 */
X#ifdef OVL2
X
Xvoid
Xu_wipe_engr(cnt)
Xregister int cnt;
X{
X	if(!u.uswallow && !Levitation)
X		wipe_engr_at(u.ux, u.uy, cnt);
X}
X
X#endif /* OVL2 */
X#ifdef OVL1
X
Xvoid
Xwipe_engr_at(x,y,cnt) register xchar x,y,cnt; {
Xregister struct engr *ep = engr_at(x,y);
Xregister int lth,pos;
Xchar ch;
X	if(ep){
X	    if(ep->engr_type != BURN) {
X		if(ep->engr_type != DUST) {
X			cnt = rn2(1 + 50/(cnt+1)) ? 0 : 1;
X		}
X		lth = strlen(ep->engr_txt);
X		if(lth && cnt > 0 ) {
X			while(cnt--) {
X				pos = rn2(lth);
X				if((ch = ep->engr_txt[pos]) == ' ')
X					continue;
X				ep->engr_txt[pos] = (ch != '?') ? '?' : ' ';
X			}
X		}
X		while(lth && ep->engr_txt[lth-1] == ' ')
X			ep->engr_txt[--lth] = 0;
X		while(ep->engr_txt[0] == ' ')
X			ep->engr_txt++;
X		if(!ep->engr_txt[0]) del_engr(ep);
X	    }
X	}
X}
X
X#endif /* OVL1 */
X#ifdef OVL2
X
Xvoid
Xread_engr_at(x,y) register int x,y; {
Xregister struct engr *ep = engr_at(x,y);
Xregister int	canfeel;
X	if(ep && ep->engr_txt[0]) {
X	    switch(ep->engr_type) {
X	    case DUST:
X		if(!Blind) pline("Something is written here in the dust.");
X		canfeel = 0;
X		break;
X	    case ENGRAVE:
X		pline("Something is engraved here on the floor.");
X		canfeel = 1;
X		break;
X	    case BURN:
X		pline("Some text has been burned here in the floor.");
X		canfeel = 1;
X		break;
X	    case MARK:
X		if(!Blind) pline("There's some graffiti here on the floor.");
X		canfeel = 0;
X		break;
X	    default:
X		impossible("Something is written in a very strange way.");
X		canfeel = 1;
X	    }
X	    if (canfeel || !Blind)
X		You("%s: \"%s\".",
X		      (Blind) ? "feel the words" : "read",  ep->engr_txt);
X	}
X}
X
X#endif /* OVL2 */
X#ifdef OVLB
X
Xvoid
Xmake_engr_at(x,y,s)
Xregister int x,y;
Xregister const char *s;
X{
X	register struct engr *ep;
X
X	if(ep = engr_at(x,y))
X	    del_engr(ep);
X	ep = (struct engr *)
X	    alloc((unsigned)(sizeof(struct engr) + strlen(s) + 1));
X	ep->nxt_engr = head_engr;
X	head_engr = ep;
X	ep->engr_x = x;
X	ep->engr_y = y;
X	ep->engr_txt = (char *)(ep + 1);
X	Strcpy(ep->engr_txt, s);
X	ep->engr_time = 0;
X	ep->engr_type = DUST;
X	ep->engr_lth = strlen(s) + 1;
X}
X
X/*
X *	freehand - returns true if player has a free hand
X */
Xint
Xfreehand(){
X	return(!uwep ||
X	   !uwep->cursed ||
X	   (uwep->olet != WEAPON_SYM && uwep->otyp != TIN_OPENER
X		&& uwep->otyp != PICK_AXE && uwep->otyp != UNICORN_HORN) || 
X	   (!bimanual(uwep) && (!uarms || !uarms->cursed)));
X/*	if ((uwep && bimanual(uwep)) ||
X	    (uwep && uarms))
X		return(0);
X	else
X		return(1);*/
X}
X
Xstatic const char NEARDATA styluses[] = { '#', '-', TOOL_SYM, WEAPON_SYM, WAND_SYM, 0 };
Xstatic const char NEARDATA too_large[] = { ARMOR_SYM, BALL_SYM, ROCK_SYM, 0 };
Xstatic const char NEARDATA paper[] = { SCROLL_SYM,
X#ifdef SPELLS
X	SPBOOK_SYM,
X#endif
X	0 };
X
Xint
Xdoengrave(){
Xregister int len, tmp;
Xregister char *sp, *sptmp;
Xregister struct engr *ep, *oep = engr_at(u.ux,u.uy);
Xchar buf[BUFSZ];
Xboolean jello = FALSE;
Xxchar type, polytype = 0;
Xint spct;		/* number of leading spaces */
Xregister struct obj *otmp;
X	multi = 0;
X
X	if(u.uswallow) {
X		if (is_animal(u.ustuck->data)) {
X			pline("What would you write?  \"Jonah was here\"?");
X			return(0);
X		} else
X			if (is_whirly(u.ustuck->data)) {
X				You("can't reach the ground.");
X				return(0);
X			} else 
X				jello = TRUE;
X	}
X
X	/* one may write with finger, weapon or wand */
X	/* edited by GAN 10/20/86 so as not to change
X	 * weapon wielded.
X	 */
X	otmp = getobj(styluses, "write with");
X	if(!otmp) return(0);
X
X	/* There's no reason you should be able to write with a wand
X	 * while both your hands are tied up.
X	 */
X	if (!freehand() && otmp != uwep && !otmp->owornmask) {
X		You("have no free %s to write with!", body_part(HAND));
X		return(0);
X	}
X#ifdef POLYSELF
X	if (cantwield(uasmon)) {
X		You("can't even hold anything!");
X		return(0);
X	}
X#endif
X	if(otmp == ublindf) {
X		pline("That is a bit difficult to engrave with, don't you think?");
X		return(1);
X	}
X	if(otmp != &zeroobj && index(too_large,otmp->olet)) {
X		You("can't engrave with such a large object!");
X		return(1);
X       }
X
X	if (jello) {
X		You("tickle %s with your %s.", mon_nam(u.ustuck), 
X		    (otmp == &zeroobj) ? makeplural(body_part(FINGER)) :
X			xname(otmp));
X		Your("message dissolves...");
X		return(0);
X	}
X
X	if(otmp != &zeroobj && index(paper,otmp->olet)) {
X		Your("%s would get dirty.",xname(otmp));
X		return(1);
X	}
X
X	if(Levitation && otmp->olet != WAND_SYM){		/* riv05!a3 */
X		You("can't reach the floor!");
X		return(0);
X	}
X
X	if(otmp == &zeroobj) {
X		You("write in the dust with your %s.",
X			makeplural(body_part(FINGER)));
X		type = DUST;
X	} else if(otmp->olet == WAND_SYM && zappable(otmp)) {
X		/* changed so any wand gets zapped out */
X		if((objects[otmp->otyp].bits & NODIR))  {
X			zapnodir(otmp);
X			type = DUST;
X		}  else  {
X			switch(otmp->otyp)  {
X			case WAN_LIGHTNING:
X				if(!objects[otmp->otyp].oc_name_known) {
X				    if(flags.verbose)
X					pline("The %s is a wand of lightning!",
X						xname(otmp));
X				    makeknown(otmp->otyp);
X				    more_experienced(0,10);
X				}
X				type = BURN;
X				break;
X			case WAN_FIRE:
X				if(!objects[otmp->otyp].oc_name_known) {
X				    if(flags.verbose)
X					pline("The %s is a wand of fire!",
X					   xname(otmp));
X				    makeknown(otmp->otyp);
X				    more_experienced(0,10);
X				}
X				type = BURN;
X				break;
X			case WAN_DIGGING:
X				if(!objects[otmp->otyp].oc_name_known) {
X				    if(flags.verbose)
X					pline("The %s is a wand of digging!",
X					   xname(otmp));
X				    makeknown(otmp->otyp);
X				    more_experienced(0,10);
X				}
X				type = ENGRAVE;
X				break;
X			case WAN_POLYMORPH:
X				if(oep)  {
X					del_engr(oep);
X					oep = 0;
X					type = POLY;
X				}  else
X					type = DUST;
X				break;
X			case WAN_COLD:
X				type = DUST;
X				if(!oep || (oep->engr_type != BURN))
X					break;
X			case WAN_CANCELLATION:
X			case WAN_MAKE_INVISIBLE:
X				if(!oep) {		/* Eric Backus */
X					type = DUST;
X					break;
X				}
X				del_engr(oep);
X				pline("The engraving on the floor vanishes!");
X				return(1);
X				/* break; */
X			case WAN_TELEPORTATION:
X				if(!oep)
X					type = DUST;
X				else  {
X					register int tx,ty;
X
X					do  {
X						tx = rn1(COLNO-3,2);
X						ty = rn2(ROWNO);
X					}  while(!goodpos(tx,ty,(struct permonst *)0));
X					oep->engr_x = tx;
X					oep->engr_y = ty;
X					pline("The engraving on the floor vanishes!");
X					return(1);
X				}
X				break;
X			default:
X				type = DUST;
X			}
X		}
X		if (otmp->spe < 0 && type != POLY) {
Xdust:
X		    /* If POLY, polymorph the writing and _then_ become dust. */
X		    pline("The %s %sturns to dust.",
X			   xname(otmp), Blind ? "" : "glows violently, then ");
X    You("are not going to get anywhere writing in the dust with your dust...");
X		    useup(otmp);
X		    return(1);
X		}
X		if(type == DUST)
X			You("write in the dust with %s.",
X			   doname(otmp));
X
X	} else {
X		if((otmp->otyp >= DAGGER && otmp->otyp <= AXE) ||
X#ifdef WORM
X		   otmp->otyp == CRYSKNIFE ||
X#endif
X		   is_sword(otmp)) {
X			type = ENGRAVE;
X
X			if((int)otmp->spe <= -3) {
X				Your("%s too dull for engraving.",
X					aobjnam(otmp, "are"));
X				type = DUST;
X				/* following messaged added 10/20/86 - GAN */
X				You("write in the dust with %s.",
X				   doname(otmp));
X			}  else
X				You("engrave with %s.", doname(otmp));
X		} else if(otmp->otyp == MAGIC_MARKER)  {
X			if(otmp->spe <= 0)  {
X				Your("marker is dried out.");
X				You("write in the dust with the marker.");
X				type = DUST;
X			}  else  {
X				You("write with %s.", doname(otmp));
X				type = MARK;
X			}
X		}  else  {
X			You("write in the dust with %s.",
X			   doname(otmp));
X			type = DUST;
X		}
X	}
X
X	if(type != POLY && oep && oep->engr_type == DUST){
X		  You("wipe out the message that was written here.");
X		  del_engr(oep);
X		  oep = 0;
X	}
X	if(oep) {
X	    You("cannot wipe out the message that is %s in the rock.",
X		  (oep->engr_type == BURN) ? "burned" :
X		  (oep->engr_type == ENGRAVE) ? "engraved" : "scribbled");
X		  return(1);
X	}
X	if(type == POLY)  {
X		polytype = rnd(4);
X		Strcpy(buf,random_engr[rn2(SIZE(random_engr))]);
X		switch(polytype){
X		case DUST:
X			pline("\"%s\" is now written on the ground.",buf);
X			break;
X		case ENGRAVE:
X			pline("\"%s\" is now engraved in the rock.",buf);
X			break;
X		case BURN:
X			pline("\"%s\" is now burned in the rock.",buf);
X			break;
X		case MARK:
X			pline("\"%s\" is now scribbled on the rock.",buf);
X			break;
X		default:
X			impossible("\"%s\" is now written in a very strange way.",
X			   buf);
X		}
X	}  else  {
X		pline("What do you want to %s on the floor here? ",
X		  (type == ENGRAVE) ? "engrave" : (type == BURN) ? "burn" : "write");
X		getlin(buf);
X		clrlin();
X	}
X	spct = 0;
X	sp = buf;
X	while(*sp == ' ') spct++, sp++;
X	len = strlen(sp);
X	if(!len || *buf == '\033') {
X		/* changed by GAN 11/01/86 to not recharge wand */
X		return(1);
X	}
X	if(otmp->otyp == WAN_FIRE) {
X		if (!Blind) pline("Flames fly from the wand.");
X		else You("feel the wand heat up.");
X	} else if(otmp->otyp == WAN_LIGHTNING) {
X		if (!Blind) {
X			pline("Lightning arcs from the wand.");
X			You("are blinded by the flash!");
X			make_blinded((long)rnd(50),FALSE);
X		} else You("hear crackling!");
X	} else if(otmp->otyp == WAN_DIGGING) {
X		if (!Blind) pline("Gravel flies up from the floor.");
X		else You("hear drilling!");
X  	}
X		/* kludge by stewr 870708 */
X	for (sptmp = sp, tmp=0; !(tmp == len); sptmp++,tmp++) {
X		if (((type == DUST) && !rn2(25))
X		     || (Blind && !rn2(12))
X		     || (Confusion && !rn2(3))) {
X			 *sptmp = '!' + rn2(93); /* ASCII-code only */
X		       }
X	      }
X
X	switch(type) {
X	case DUST:
X	case BURN:
X		if(len > 15) {
X			multi = -(len/10);
X			nomovemsg = "You finish writing.";
X		}
X		break;
X	case ENGRAVE:
X	case MARK:
X		{	int len2;
X
X			if(type == ENGRAVE)
X				len2 = (otmp->spe + 3) * 2 + 1;
X			else
X				len2 = (otmp->spe) * 2;
X			nomovemsg = "You finish writing.";
X			if(type != MARK)
X			nomovemsg = "You finish engraving.";
X			if(otmp->olet != WAND_SYM && (otmp->otyp != ATHAME
X					|| otmp->cursed))  {
X				if(otmp->olet == WEAPON_SYM)
X					Your("%s dull.",
X					       aobjnam(otmp, "get"));
X				if(len2 < len) {
X					len = len2;
X					sp[len] = 0;
X					if(type == ENGRAVE)  {
X						otmp->spe = -3;
X					}  else  {
X						Your("marker dries out!");
X						otmp->spe = 0;
X					}
X					/* next line added by GAN 10/20/86 */
X					You("only write \"%s\".", sp);
X					nomovemsg = "You cannot write more.";
X				} else
X					otmp->spe -= len >> 1;
X				if(type == MARK)
X					multi = -(len/10);
X				else
X					multi = -len;
X			}  else
X				multi = -(len/10);
X			if (multi == 0)
X				nomovemsg = (char *)0;
X		}
X		break;
X	case POLY:
X		type = polytype;
X		multi = 0;
X		break;
X	}
X	if(oep) len += strlen(oep->engr_txt) + spct;
X	ep = (struct engr *) alloc((unsigned)(sizeof(struct engr) + len + 1));
X	ep->nxt_engr = head_engr;
X	head_engr = ep;
X	ep->engr_x = u.ux;
X	ep->engr_y = u.uy;
X	sp = (char *)(ep + 1);	/* (char *)ep + sizeof(struct engr) */
X	ep->engr_txt = sp;
X	if(oep) {
X		Strcpy(sp, oep->engr_txt);
X		Strcat(sp, buf);
X		del_engr(oep);
X	} else
X		Strcpy(sp, buf);
X	ep->engr_lth = len+1;
X	ep->engr_type = type;
X	ep->engr_time = moves-multi;
X
X	/* kludge to protect pline against excessively long texts */
X	if(len > BUFSZ-20) sp[BUFSZ-20] = 0;
X
X	/* cute messages for odd wands */
X	switch(otmp->otyp)  {
X	case WAN_SLOW_MONSTER:
X		pline("The bugs on the ground slow down!");
X		break;
X	case WAN_SPEED_MONSTER:
X		pline("The bugs on the ground speed up!");
X		break;
X	case WAN_MAGIC_MISSILE:
X		pline("The ground is riddled by bullet holes!");
X		break;
X	case WAN_SLEEP:
X	case WAN_DEATH:	/* can't tell sleep from death - Eric Backus */
X		pline("The bugs on the ground stop moving!");
X		break;
X	case WAN_COLD:
X		pline("A few ice cubes drop from your %s.",xname(otmp));
X		break;
X	case WAN_STRIKING:
X		pline("The %s unsuccessfully fights your attempt to write!",xname(otmp));
X	}
X	if (otmp->otyp == WAN_POLYMORPH && otmp->spe < 0) goto dust;
X	return(1);
X}
X
Xvoid
Xsave_engravings(fd) int fd; {
Xregister struct engr *ep = head_engr;
Xregister struct engr *ep2;
X#ifdef __GNULINT__
Xstatic long nulls[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
X#endif
X	while(ep) {
X	    ep2 = ep->nxt_engr;
X	    if(ep->engr_lth && ep->engr_txt[0]){
X		bwrite(fd, (genericptr_t)&(ep->engr_lth), sizeof(ep->engr_lth));
X		bwrite(fd, (genericptr_t)ep, sizeof(struct engr) + ep->engr_lth);
X	    }
X#if defined(DGK)
X	    if (!count_only)
X#endif
X		free((genericptr_t) ep);
X	    ep = ep2;
X	}
X
X#ifdef __GNULINT__
X	bwrite(fd, (genericptr_t)nulls, sizeof(unsigned));
X#else
X	bwrite(fd, (genericptr_t)nul, sizeof(unsigned));
X#endif
X
X#if defined(DGK)
X	if (!count_only)
X#endif
X		head_engr = 0;
X}
X
Xvoid
Xrest_engravings(fd) int fd; {
Xregister struct engr *ep;
Xunsigned lth;
X	head_engr = 0;
X	while(1) {
X		mread(fd, (genericptr_t) &lth, sizeof(unsigned));
X		if(lth == 0) return;
X		ep = (struct engr *) alloc(sizeof(struct engr) + lth);
X		mread(fd, (genericptr_t) ep, sizeof(struct engr) + lth);
X		ep->nxt_engr = head_engr;
X		ep->engr_txt = (char *) (ep + 1);	/* Andreas Bormann */
X		head_engr = ep;
X	}
X}
X
XSTATIC_OVL void
Xdel_engr(ep) register struct engr *ep; {
Xregister struct engr *ept;
X	if(ep == head_engr)
X		head_engr = ep->nxt_engr;
X	else {
X		for(ept = head_engr; ept; ept = ept->nxt_engr) {
X			if(ept->nxt_engr == ep) {
X				ept->nxt_engr = ep->nxt_engr;
X				goto fnd;
X			}
X		}
X		impossible("Error in del_engr?");
X		return;
X	fnd:	;
X	}
X	free((genericptr_t) ep);
X}
X
X#endif /* OVLB */
END_OF_FILE
if test 14925 -ne `wc -c <'src/engrave.c'`; then
    echo shar: \"'src/engrave.c'\" unpacked with wrong size!
fi
# end of 'src/engrave.c'
fi
echo shar: End of archive 41 \(of 56\).
cp /dev/null ark41isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 56 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
    echo Building monst.c from monst.c1 and monst.c2
    cat src/monst.c1 src/monst.c2 > src/monst.c
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
