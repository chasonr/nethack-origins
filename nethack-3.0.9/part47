Path: utzoo!utgpu!news-server.csri.toronto.edu!cs.utexas.edu!mailrus!cornell!uw-beaver!zephyr.ens.tek.com!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v10i092:  nethack3p9 -  display oriented dungeons & dragons (Ver. 3.0i), Part47/56
Message-ID: <5952@tekred.CNA.TEK.COM>
Date: 13 Jul 90 19:41:48 GMT
Sender: news@tekred.CNA.TEK.COM
Lines: 2261
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 10, Issue 92
Archive-name: nethack3p9/Part47
Supersedes: NetHack3: Volume 7, Issue 56-93



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 47 (of 56)."
# Contents:  include/patchlevel.h others/trampoli.c src/bones.c
#   src/decl.c src/extralev.c src/weapon.c
# Wrapped by billr@saab on Wed Jul 11 17:12:05 1990
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'include/patchlevel.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/patchlevel.h'\"
else
echo shar: Extracting \"'include/patchlevel.h'\" \(4179 characters\)
sed "s/^X//" >'include/patchlevel.h' <<'END_OF_FILE'
X/*
X *  Patch 1, July 31, 1989
X *  add support for Atari TOS (courtesy Eric Smith) and Andrew File System
X *	(courtesy Ralf Brown)
X *  include the uuencoded version of termcap.arc for the MSDOS versions that
X *	was included with 2.2 and 2.3
X *  make a number of simple changes to accommodate various compilers
X *  fix a handful of bugs, and do some code cleaning elsewhere
X *  add more instructions for new environments and things commonly done wrong
X */
X
X/*
X *  Patch 2, August 16, 1989
X *  add support for OS/2 (courtesy Timo Hakulinen)
X *  add a better makefile for MicroSoft C (courtesy Paul Gyugyi)
X *  more accomodation of compilers and preprocessors
X *  add better screen-size sensing
X *  expand color use for PCs and introduce it for SVR3 UNIX machines
X *  extend '/' to multiple identifications
X *  allow meta key to be used to invoke extended commands
X *  fix various minor bugs, and do further code cleaning
X */
X
X/*
X *  Patch 3, September 6, 1989
X *  add war hammers and revise object prices
X *  extend prototypes to ANSI compilers in addition to the previous MSDOS ones
X *  move object-on-floor references into functions in preparation for planned
X *	data structures to allow faster access and better colors
X *  fix some more bugs, and extend the portability of things added in earlier
X *	patches
X */
X
X/*
X *  Patch 4, September 27, 1989
X *  add support for VMS (courtesy David Gentzel)
X *  move monster-on-floor references into functions and implement the new
X *	lookup structure for both objects and monsters
X *  extend the definitions of objects and monsters to provide "living color"
X *	in the dungeon, instead of a single monster color
X *  ifdef varargs usage to satisfy ANSI compilers
X *  standardize on the color 'gray'
X *  assorted bug fixes
X */
X
X/*
X *  Patch 5, October 15, 1989
X *  add support for Macintosh OS (courtesy Johnny Lee)
X *  fix annoying dependency loop via new color.h file
X *  allow interruption while eating -- general handling of partially eaten food
X *  smarter treatment of iron balls (courtesy Kevin Darcy)
X *  a handful of other bug fixes
X */
X
X/*
X *  Patch 6, November 19, 1989
X *  add overlay support for MS-DOS (courtesy Pierre Martineau, Stephen
X *	Spackman, and Norm Meluch)
X *  refine Macintosh port
X *  different door states show as different symbols (courtesy Ari Huttunen)
X *  smarter drawbridges (courtesy Kevin Darcy)
X *  add CLIPPING and split INFERNO off HARD
X *  further refine eating code wrt picking up and resumption
X *  make first few levels easier, by adding :x monsters and increasing initial
X *	attribute points and hitting probability
X *  teach '/' about configurable symbols
X */
X
X/*
X *  Patch 7, February 19, 1990
X *  refine overlay support to handle portions of .c files through OVLx
X *	(courtesy above plus Kevin Smolkowski)
X *  update and extend Amiga port and documentation (courtesy Richard Addison,
X *	Jochen Erwied, Mark Gooderum, Ken Lorber, Greg Olson, Mike Passaretti,
X *	and Gregg Wonderly)
X *  refine and extend Macintosh port and documentation (courtesy Johnny Lee,
X *	Kevin Sitze, Michael Sokolov, Andy Swanson, Jon Watte, and Tom West)
X *  refine VMS documentation
X *  continuing ANSIfication, this time of const usage
X *  teach '/' about differences within monster classes
X *  smarter eating code (yet again), death messages, and treatment of
X *	non-animal monsters, monster unconsciousness, and naming
X *  extended version command to give compilation options
X *  and the usual bug fixes and hole plugs
X */
X
X/*
X *  Patch 8, June 3, 1990
X *  further debug and refine Macintosh port
X *  refine the overlay manager, rearrange the OVLx breakdown for better
X *	efficiency, rename the overlay macros, and split off the overlay
X *	instructions to Install.ovl
X *  introduce NEARDATA for better Amiga efficiency
X *  support for more VMS versions (courtesy Joshua Delahunty and Pat Rankin)
X *  more const fixes
X *  better support for common graphics (DEC VT and IBM)
X *  and a number of simple fixes and consistency extensions
X */
X
X/*
X *  Patch 9, June 26, 1990
X *  clear up some confusing documentation
X *  smooth some more rough edges in various ports
X *  and fix a couple more bugs
X */
X
X#define PATCHLEVEL	9
END_OF_FILE
if test 4179 -ne `wc -c <'include/patchlevel.h'`; then
    echo shar: \"'include/patchlevel.h'\" unpacked with wrong size!
fi
# end of 'include/patchlevel.h'
fi
if test -f 'others/trampoli.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'others/trampoli.c'\"
else
echo shar: Extracting \"'others/trampoli.c'\" \(10095 characters\)
sed "s/^X//" >'others/trampoli.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)trampoli.c 	3.0	90/05/31	  */
X/* Copyright (c) 1989, by Norm Meluch and Stephen Spackman	  */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include "hack.h"
X
X/****************************************************************************/
X/*									    */
X/*	This file contains a series of declarations of "one liner"	    */
X/*	functions.  These functions are to avoid calls to functions via     */
X/*	pointers.  This is necessary when the function called is in an      */
X/*	overlay segment.						    */
X/*	The original function (eg foo) has been defined to be foo_ and	    */
X/*	now the declaration of foo is placed in this file calling foo	    */
X/*	directly.  This module is _never_ placed in an overlay so	    */
X/*	calls via pointers to these functions will not cause difficulties.  */
X/*									    */
X/****************************************************************************/
X
X#ifdef OVERLAY
X
X/* ### apply.c ### */
X#undef dig
X#undef doapply
X#undef dojump
X#undef dorub
X
Xint dig()     { return dig_();     }
Xint doapply() { return doapply_(); }
Xint dojump()  { return dojump_();  }
Xint dorub()   { return dorub_();   }
X
X
X/* ### cmd.c ### */
X#undef doextcmd
X#undef doextlist
X
X#ifdef POLYSELF
X#undef domonability
X#endif /* POLYSELF */
X
X#ifdef EXPLORE_MODE
X#undef enter_explore_mode
X
Xint enter_explore_mode() { return enter_explore_mode_(); }
X#endif
X
X#undef timed_occupation
X
X#if defined(WIZARD) || defined(EXPLORE_MODE)
X#undef wiz_attributes
X#endif
X
X#ifdef WIZARD
X#undef wiz_detect
X#undef wiz_genesis
X#undef wiz_identify
X#undef wiz_level_tele
X#undef wiz_map
X#undef wiz_where
X#undef wiz_wish
X#endif
X
Xint doextcmd()         { return doextcmd_();         }
Xint doextlist()        { return doextlist_();        }
X
X#ifdef POLYSELF
Xint domonability()     { return domonability_();     }
X#endif /* POLYSELF */
X
Xint timed_occupation() { return timed_occupation_(); }
X
X#if defined(WIZARD) || defined(EXPLORE_MODE)
Xint wiz_attributes()   { return wiz_attributes_();   }
X#endif
X
X#ifdef WIZARD
Xint wiz_detect()       { return wiz_detect_();       }
Xint wiz_genesis()      { return wiz_genesis_();      }
Xint wiz_identify()     { return wiz_identify_();     }
Xint wiz_level_tele()   { return wiz_level_tele_();   }
Xint wiz_map()          { return wiz_map_();          }
Xint wiz_where()        { return wiz_where_();        }
Xint wiz_wish()         { return wiz_wish_();         }
X#endif
X
X
X/* ### do.c ### */
X#undef doddrop
X#undef dodown
X#undef dodrop
X#undef donull
X#undef doup
X#undef dowipe
X#undef drop
X#undef wipeoff
X
Xint doddrop()             { return doddrop_(); }
Xint dodown()              { return dodown_();  }
Xint dodrop()              { return dodrop_();  }
Xint donull()              { return donull_();  }
Xint doup()                { return doup_();    }
Xint dowipe()              { return dowipe_();  }
Xint drop(obj)
Xregister struct obj *obj; { return drop_(obj); }
Xint wipeoff()             { return wipeoff_(); }
X
X
X/* ### do_name.c ### */
X#undef ddocall
X#undef do_mname
X
Xint ddocall()  { return ddocall_();  }
Xint do_mname() { return do_mname_(); } 
X
X
X/* ### do_wear.c ### */
X
X/* ### do_wear.c ### */
X#undef Armor_off
X#undef Boots_off
X#undef Gloves_off
X#undef Helmet_off
X#undef Armor_on
X#undef Boots_on
X#undef Gloves_on
X#undef Helmet_on
X#undef doddoremarm
X#undef doputon
X#undef doremring
X#undef dotakeoff
X#undef dowear
X#undef select_off
X#undef take_off
X
Xint Armor_off()   { return Armor_off_();   }
Xint Boots_off()   { return Boots_off_();   }
Xint Gloves_off()  { return Gloves_off_();  }
Xint Helmet_off()  { return Helmet_off_();  }
Xint Armor_on()    { return Armor_on_();    }
Xint Boots_on()    { return Boots_on_();    }
Xint Gloves_on()   { return Gloves_on_();   }
Xint Helmet_on()   { return Helmet_on_();   }
Xint doddoremarm() { return doddoremarm_(); }
Xint doputon()     { return doputon_();     }
Xint doremring()   { return doremring_();   }
Xint dotakeoff()   { return dotakeoff_();   }
Xint dowear()      { return dowear_();      }
Xint select_off(otmp) struct obj *otmp; { return select_off_(otmp); }
Xint take_off()    { return take_off_();    }
X
X
X/* ### dokick.c ### */
X#undef dokick
X
Xint dokick() { return dokick_(); }
X
X
X/* ### dothrow.c ### */
X#undef dothrow
X
Xint dothrow() { return dothrow_(); }
X
X
X/* ### eat.c ### */
X#undef Hear_again
X#undef Meatdone
X#undef doeat
X#undef eatfood
X#undef opentin
X#undef unfaint
X
Xint Hear_again()  { return Hear_again_(); }
Xint Meatdone()    { return Meatdone_();   }
Xint doeat()       { return doeat_();      }
Xint eatfood()     { return eatfood_();    }
Xint opentin()     { return opentin_();    }
Xint unfaint()     { return unfaint_();    }
X
X
X/* ### end.c ### */
X#undef done1
X#undef done2
X#undef hangup
X#undef done_intr
X
X#if defined(UNIX) || defined(VMS)
X#undef done_hangup
X#endif /* UNIX || VMS */
X
Xint done1()     { return done1_();     }
Xint done2()     { return done2_();     }
Xint hangup()    { return hangup_();    }
Xint done_intr() { return done_intr_(); }
X
X#if defined(UNIX) || defined(VMS)
Xint done_hangup() { return done_hangup_(); }
X#endif /* UNIX || VMS */
X
X
X/* ### engrave.c ### */
X#undef doengrave
X
Xint doengrave() { return doengrave_(); }
X
X
X/* ### hack.c ### */
X#undef dopickup
X#undef identify
X
Xint dopickup() { return dopickup_(); }
Xint identify(otmp) struct obj *otmp; { return identify_(otmp); }
X
X
X/* ### invent.c ### */
X#undef ckunpaid
X#undef ddoinv
X#undef dolook
X#undef dopramulet
X#undef doprarm
X#undef doprgold
X#undef doprring
X#undef doprtool
X#undef doprwep
X#undef dotypeinv
X
Xint ckunpaid(obj) struct obj *obj; { return ckunpaid_(obj); }
Xint ddoinv()     { return ddoinv_();     }
Xint dolook()     { return dolook_();     }
Xint dopramulet() { return dopramulet_(); }
Xint doprarm()    { return doprarm_();    }
Xint doprgold()   { return doprgold_();   }
Xint doprring()   { return doprring_();   }
Xint doprtool()   { return doprtool_();   }
Xint doprwep()    { return doprwep_();    }
Xint dotypeinv()  { return dotypeinv_();  }
X
X
X/* ### ioctl.c ### */
X#ifdef UNIX
X# ifdef SUSPEND
X#undef dosuspend
X
Xint dosuspend() { return dosuspend_(); }
X# endif /* SUSPEND */
X#endif /* UNIX */
X
X
X/* ### lock.c ### */
X#undef doclose
X#undef doforce
X#undef doopen
X#undef forcelock
X#undef picklock
X
Xint doclose()   { return doclose_();   }
Xint doforce()   { return doforce_();   }
Xint doopen()    { return doopen_();    }
Xint forcelock() { return forcelock_(); }
Xint picklock()  { return picklock_();  }
X
X
X/* ### mklev.c ### */
X#undef comp
X
Xint comp(vx, vy) genericptr_t vx, vy;  { return comp_(vx, vy); }
X
X
X/* ### mondata.c ### */
X/* canseemon() is only called by a macro e_boolean.  If e_boolean ever does
X   become a function for purposes of STUPID_CPP this may need to return. */
X
X/* #undef canseemon */
X
X/* boolean canseemon(x) struct monst *x; { return canseemon_(x); } */
X
X
X/* ### o_init.c ### */
X#undef dodiscovered
X
Xint dodiscovered() { return dodiscovered_(); }
X
X
X/* ### objnam.c ### */
X#undef doname
X#undef xname
X
Xchar *doname(obj) struct obj *obj; { return doname_(obj); }
Xchar *xname(obj)  struct obj *obj; { return xname_(obj); }
X
X
X/* ### options.c ### */
X#undef doset
X#undef dotogglepickup
X
Xint doset()          { return doset_();         }
Xint dotogglepickup() { return dotogglepickup_(); }
X
X
X/* ### pager.c ### */
X#undef dohelp
X#undef dohistory
X#undef dowhatdoes
X#undef dowhatis
X
X#ifdef UNIX
X#undef intruph
X# ifdef SHELL
X#undef dosh
X
Xint dosh()       { return dosh_();       }
X# endif /* SHELL */
Xint intruph()	 { return intruph_();    }
X#endif /* UNIX */
X
Xint dohelp()     { return dohelp_();     }
Xint dohistory()  { return dohistory_();  }
Xint dowhatdoes() { return dowhatdoes_(); }
Xint dowhatis()   { return dowhatis_();   }
X
X
X/* ### pickup.c ### */
X#undef ck_bag
X#undef ck_container
X#undef doloot
X#undef in_container
X#undef out_container
X
Xint ck_bag(obj) struct obj *obj; { return ck_bag_(obj);  }
Xint ck_container(obj)  struct obj *obj; { return ck_container_(obj); }
Xint doloot() { return doloot_(); }
Xint in_container(obj)  struct obj *obj; { return in_container_(obj); }
Xint out_container(obj) struct obj *obj; { return out_container_(obj); }
X
X
X/* ### potion.c ### */
X#undef dodrink
X#undef dodip
X
Xint dodrink() { return dodrink_(); }
Xint dodip()   { return dodip_();   }
X
X
X/* ### pray.c ### */
X#undef doturn
X#ifdef THEOLOGY
X#undef dopray
X#undef dosacrifice
X
Xint dopray()      { return dopray_();      }
Xint dosacrifice() { return dosacrifice_(); }
X#endif /* THEOLOGY */
X
Xint doturn()      { return doturn_();      }
X
X
X/* ### pri.c ### */
X#undef doredraw
X
Xint doredraw()    { return doredraw_(); }
X
X
X/* ### read.c ### */
X#undef doread
X
Xint doread() { return doread_(); }
X
X
X/* ### save.c ### */
X#undef dosave
X
Xint dosave() { return dosave_(); }
X
X
X/* ### search.c ### */
X#undef doidtrap
X#undef dosearch
X
Xint doidtrap() { return doidtrap_(); }
Xint dosearch() { return dosearch_(); }
X
X
X/* ### shk.c ### */
X#undef dopay
X
Xint dopay() { return dopay_(); }
X
X
X/* ### sit.c ### */
X#undef dosit
X
Xint dosit() { return dosit_(); }
X
X
X/* ### sounds.c ### */
X#undef dotalk
X
Xint dotalk() { return dotalk_(); }
X
X
X/* ### spell.c ### */
X#ifdef SPELLS
X#undef learn
X#undef docast
X#undef dovspell
X
Xint learn() { return learn_(); }
Xint docast()   { return docast_();   }
Xint dovspell() { return dovspell_(); }
X#endif
X
X
X/* ### steal.c ### */
X#undef stealarm
X
Xint stealarm() { return stealarm_(); }
X
X
X/* ### topl.c ### */
X#undef doredotopl
X
Xint doredotopl() { return doredotopl_(); }
X
X
X/* ### trap.c ### */
X#undef dotele
X#undef dountrap
X#undef float_down
X
Xint dotele()     { return dotele_();     }
Xint dountrap()   { return dountrap_();   }
Xint float_down() { return float_down_(); }
X
X
X/* ### version.c ### */
X#undef doversion
X#undef doextversion
X
Xint doversion()    { return doversion_();    }
Xint doextversion() { return doextversion_(); }
X
X
X/* ### wield.c ### */
X#undef dowield
X
Xint dowield() { return dowield_(); }
X
X
X/* ### zap.c ### */
X#undef bhitm
X#undef bhito
X#undef dozap
X
Xint bhitm(mtmp, otmp) struct monst *mtmp; struct obj *otmp;
X	{ return bhitm_(mtmp, otmp); }
Xint bhito(obj, otmp) struct obj *obj, *otmp; { return bhito_(obj,  otmp); }
Xint dozap() { return dozap_(); }
X#endif /* OVERLAY */
END_OF_FILE
if test 10095 -ne `wc -c <'others/trampoli.c'`; then
    echo shar: \"'others/trampoli.c'\" unpacked with wrong size!
fi
# end of 'others/trampoli.c'
fi
if test -f 'src/bones.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/bones.c'\"
else
echo shar: Extracting \"'src/bones.c'\" \(9945 characters\)
sed "s/^X//" >'src/bones.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)bones.c	3.0	88/04/13
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include "hack.h"
X
X#define OMASK	0
X
X#ifdef DGK
Xchar bones[FILENAME];
Xextern long bytes_counted;
X#else
Xchar bones[] = "bones.xxxx";
X#endif
X
X#ifdef COMPRESS
Xstatic char cmd[60], proxy[20];
X
Xstatic void NDECL(compress_bones);
X#endif
Xstatic boolean FDECL(no_bones_level, (int));
Xstatic void FDECL(resetobjs,(struct obj *,BOOLEAN_P));
X#ifdef TUTTI_FRUTTI
Xstatic void FDECL(goodfruit, (int));
X#endif
X
X#ifdef COMPRESS
Xstatic void
Xcompress_bones()
X{
X	Strcpy(cmd, COMPRESS);
X	Strcat(cmd, " ");
X# ifdef COMPRESS_OPTIONS
X	Strcat(cmd, COMPRESS_OPTIONS);
X	Strcat(cmd, " ");
X# endif
X	Strcat(cmd, bones);
X	(void) system(cmd);
X}
X#endif /* COMPRESS */
X
Xstatic boolean
Xno_bones_level(lev)
Xint lev;
X{
X	extern int save_dlevel;		/* in do.c */
X
X	if (save_dlevel) lev = save_dlevel;
X
X	return (lev == medusa_level ||
X		lev == wiz_level
X#ifdef REINCARNATION
X		|| lev == rogue_level
X#endif
X#ifdef STRONGHOLD
X		|| lev == stronghold_level ||
X		(lev >= tower_level && lev <= tower_level+2)
X#endif
X#ifdef ENDGAME
X		|| lev == ENDLEVEL
X#endif
X		);
X}
X
X#ifdef TUTTI_FRUTTI
Xstatic void
Xgoodfruit(id)
Xint id;
X{
X	register struct fruit *f;
X
X	for(f=ffruit; f; f=f->nextf) {
X		if(f->fid == -id) {
X			f->fid = id;
X			return;
X		}
X	}
X}
X#endif
X
Xstatic void
Xresetobjs(ochain,restore)
Xstruct obj *ochain;
Xboolean restore;
X{
X	struct obj *otmp;
X
X	for (otmp = ochain; otmp; otmp = otmp->nobj) {
X		if (((otmp->otyp != CORPSE && otmp->otyp != STATUE)
X			|| otmp->corpsenm < PM_ARCHEOLOGIST)
X#ifdef NAMED_ITEMS
X			&& (!is_artifact(otmp) ||
X			    (exist_artifact(otmp,ONAME(otmp)) && restore))
X#endif
X		)
X			otmp->onamelth = 0;
X#ifdef NAMED_ITEMS
X		else if (is_artifact(otmp) && restore)
X			artifact_exists(otmp,ONAME(otmp),TRUE);
X#endif
X		if (!restore) {
X			/* resetting the o_id's after getlev has carefully
X			 * created proper new ones via restobjchn is a Bad
X			 * Idea */
X			otmp->o_id = 0;
X			if(objects[otmp->otyp].oc_uses_known) otmp->known = 0;
X			otmp->dknown = otmp->bknown = 0;
X			otmp->invlet = 0;
X#ifdef TUTTI_FRUTTI
X			if(otmp->otyp == SLIME_MOLD) goodfruit(otmp->spe);
X#endif
X#ifdef MAIL
X			if (otmp->otyp == SCR_MAIL) otmp->spe = 1;
X#endif
X#ifdef POLYSELF
X			if (otmp->otyp == EGG) otmp->spe = 0;
X#endif
X			if(otmp->otyp == AMULET_OF_YENDOR && !otmp->spe) {
X				otmp->spe = -1;
X				/* no longer the actual amulet */
X				curse(otmp);
X			}
X		}
X	}			
X}
X
X/* save bones and possessions of a deceased adventurer */
Xvoid
Xsavebones(){
X	register int fd, x, y;
X	register struct obj *otmp;
X	register struct trap *ttmp;
X	register struct monst *mtmp, *mtmp2;
X#ifdef TUTTI_FRUTTI
X	struct fruit *f;
X#endif
X
X	if(dlevel <= 0 || dlevel > MAXLEVEL) return;
X	if(no_bones_level(dlevel)) return; /* no bones for specific levels */
X	if(!rn2(1 + (dlevel>>2)) /* not so many ghosts on low levels */
X#ifdef WIZARD
X		&& !wizard
X#endif
X		) return;
X#ifdef EXPLORE_MODE
X	/* don't let multiple restarts generate multiple copies of objects
X	 * in bones files */
X	if(discover) return;
X#endif
X
X	name_file(bones, dlevel);
X#ifdef COMPRESS
X	Strcpy(proxy, bones);
X	Strcat(proxy, ".Z");
X
X	if((fd = open(proxy, OMASK)) >= 0) {
X#else
X	if((fd = open(bones, OMASK)) >= 0) {
X#endif
X		(void) close(fd);
X#ifdef WIZARD
X		if(wizard)
X			pline("Bones file already exists.");
X#endif
X		return;
X	}
X#ifdef WALKIES
X	unleash_all();
X#endif
X	/* in case these characters are not in their home bases */
X	mtmp2 = fmon;
X	while((mtmp = mtmp2)) {
X		mtmp2 = mtmp->nmon;
X		if(mtmp->iswiz) mongone(mtmp);
X#ifdef MEDUSA
X		if(mtmp->data == &mons[PM_MEDUSA]) mongone(mtmp);
X#endif
X	}
X#ifdef TUTTI_FRUTTI
X	/* mark all fruits as nonexistent; when we come to them we'll mark
X	 * them as existing (using goodfruit())
X	 */
X	for(f=ffruit; f; f=f->nextf) f->fid = -f->fid;
X#endif
X
X	/* check iron balls separately--maybe they're not carrying it */
X	if (uball) uball->owornmask = uchain->owornmask = 0;
X
X	/* drop everything; the corpse's possessions are usually cursed */
X	otmp = invent;
X	while(otmp) {
X		place_object(otmp, u.ux, u.uy);
X		otmp->owornmask = 0;
X#ifdef TUTTI_FRUTTI
X		if(otmp->otyp == SLIME_MOLD) goodfruit(otmp->spe);
X#endif
X		if(rn2(5)) curse(otmp);
X		if(!otmp->nobj){
X			otmp->nobj = fobj;
X			fobj = invent;
X			invent = 0;	/* superfluous */
X			break;
X		}
X		otmp = otmp->nobj;
X	}
X	in_mklev = TRUE;
X	/* tricks makemon() into allowing monster creation on your square */
X	if (u.ugrave_arise == -1) {
X		mtmp = makemon(&mons[PM_GHOST], u.ux, u.uy);
X		in_mklev = FALSE;
X		if (!mtmp) return;
X		Strcpy((char *) mtmp->mextra, plname);
X	} else {
X		mtmp = makemon(&mons[u.ugrave_arise], u.ux, u.uy);
X		in_mklev = FALSE;
X		if (!mtmp) return;
X		mtmp = christen_monst(mtmp, plname);
X		atl(u.ux, u.uy, mtmp->data->mlet);
X		Your("body rises from the dead as %s...",
X			an(mons[u.ugrave_arise].mname));
X	}
X	mtmp->m_lev = (u.ulevel ? u.ulevel : 1);
X	mtmp->mhp = mtmp->mhpmax = u.uhpmax;
X	mtmp->msleep = 1;
X	if(u.ugold) mkgold(u.ugold, u.ux, u.uy);
X	for(mtmp = fmon; mtmp; mtmp = mtmp->nmon){
X		resetobjs(mtmp->minvent,FALSE);
X		mtmp->m_id = 0;
X		mtmp->mlstmv = 0L;
X		if(mtmp->mtame) mtmp->mtame = mtmp->mpeaceful = 0;
X		if(mtmp->mdispl) unpmon(mtmp);
X	}
X	for(ttmp = ftrap; ttmp; ttmp = ttmp->ntrap)
X		ttmp->tseen = 0;
X
X	resetobjs(fobj,FALSE);
X	/* let's (not) forget about these - KCD, 10/21/89 */
X	resetobjs(fcobj,FALSE);
X
X	for(x=0; x<COLNO; x++) for(y=0; y<ROWNO; y++)
X		levl[x][y].seen = levl[x][y].new = levl[x][y].scrsym = 0;
X
X#ifdef MSDOS
X	fd = open(bones, O_WRONLY | O_BINARY | O_CREAT | O_TRUNC, FCMASK);
X#else
X# ifdef MACOS
X	{
X		Str255	fileName;
X		OSErr	er;
X		struct term_info	*t;
X		extern WindowPtr	HackWindow;
X		short	oldvolume;
X		
X		t = (term_info *)GetWRefCon(HackWindow);
X		(void)GetVol(&fileName,&oldvolume);
X		(void)SetVol(0L, t->recordVRefNum);
X		fileName[0] = (uchar)strlen(bones);
X		Strcpy((char *)&fileName[1],bones);
X		
X		if (er = Create(&fileName,0,CREATOR,BONES_TYPE))
X			SysBeep(1);
X		fd = open(bones,
X			O_WRONLY | O_BINARY | O_TRUNC | ((er) ? O_CREAT : 0));
X		(void)SetVol(0L, oldvolume);
X	}
X# else
X	fd = creat(bones, FCMASK);
X# endif /* MACOS */
X#endif
X	if(fd < 0) {
X#ifdef WIZARD
X		if(wizard)
X			pline("Cannot create bones file - creat failed");
X#endif
X		return;
X	}
X
X#if defined(DGK)	/* check whether there is room */
X	count_only = TRUE;
X# ifdef TUTTI_FRUTTI
X	savefruitchn(fd);
X# endif
X	savelev(fd, dlevel, COUNT);
X# ifdef ZEROCOMP
X	bflush(fd);
X# endif
X	if (bytes_counted > freediskspace(bones)) {	/* not enough room */
X# ifdef WIZARD
X		if (wizard)
X			pline("Insufficient space to create bones file.");
X# endif
X		unlink(bones);
X		return;
X	}
X	count_only = FALSE;
X#endif /* DGK */
X
X#ifdef TUTTI_FRUTTI
X	savefruitchn(fd);
X#endif
X#if defined(DGK)
X	savelev(fd, dlevel, WRITE);
X#else
X	savelev(fd,dlevel);
X#endif
X#ifdef ZEROCOMP
X	bflush(fd);
X#endif
X	(void) close(fd);
X#ifdef MACOS
X	{
X		FInfo	fndrInfo;
X		Str255	name;
X		term_info	*t;
X		short	oldVol, error;
X		
X		t = (term_info *)GetWRefCon(HackWindow);
X		GetVol(name, &oldVol);
X		SetVol(0L, t->recordVRefNum);  
X		Strcpy((char *)name, bones);
X		CtoPstr((char *)name);
X		error = GetFInfo(name, (short)0, &fndrInfo);
X		fndrInfo.fdCreator = CREATOR;
X		fndrInfo.fdType = BONES_TYPE;
X		if (error == noErr)
X			SetFInfo(name, (short)0, &fndrInfo);
X		SetVol(0L, oldVol);
X	}
X#endif
X#ifdef COMPRESS
X	compress_bones();
X#endif
X}
X
Xint
Xgetbones() {
X	register int fd;
X	register int ok;
X#ifdef MACOS
X	Str255	name;
X	short	oldVol;
X	term_info *t;
X	extern WindowPtr	HackWindow;
X	
X	t = (term_info *)GetWRefCon(HackWindow);
X#endif
X#ifdef EXPLORE_MODE
X	if(discover)		/* save bones files for real games */
X		return(0);
X#endif
X	/* wizard check added by GAN 02/05/87 */
X	if(rn2(3)	/* only once in three times do we find bones */
X#ifdef WIZARD
X		&& !wizard
X#endif
X		) return(0);
X	if(no_bones_level(dlevel)) return(0);
X	name_file(bones, dlevel);
X#ifdef MACOS
X	GetVol(name, &oldVol);
X	SetVol(0L, t->recordVRefNum);
X#endif
X#ifdef COMPRESS
X	if((fd = open(bones, OMASK)) >= 0) goto gotbones;
X	Strcpy(proxy, bones);
X	Strcat(proxy, ".Z");
X	if((fd = open(proxy, OMASK)) < 0) return(0);
X	else {
X	    (void) close(fd);
X	    Strcpy(cmd, COMPRESS);
X	    Strcat(cmd, " -d ");	/* uncompress */
X# ifdef COMPRESS_OPTIONS
X	    Strcat(cmd, COMPRESS_OPTIONS);
X	    Strcat(cmd, " ");
X# endif
X	    Strcat(cmd,proxy);
X	    (void) system(cmd);
X	}
X#endif
X	if((fd = open(bones, OMASK)) < 0) {
X#ifdef MACOS
X		SetVol(0L, oldVol);
X#endif
X		return(0);
X	}
X#ifdef MACOS
X	SetVol(0L, oldVol);
X#endif
X#ifdef COMPRESS
Xgotbones:
X#endif
X	if((ok = uptodate(fd)) != 0){
X#ifdef WIZARD
X		if(wizard)  {
X			pline("Get bones? ");
X			if(yn() == 'n') {
X				(void) close(fd);
X# ifdef COMPRESS
X				compress_bones();
X# endif
X				return(0);
X			}
X		}
X#endif
X#ifdef ZEROCOMP
X		minit();
X#endif
X		getlev(fd, 0, dlevel, TRUE);
X	}
X	(void) close(fd);
X#ifdef NAMED_ITEMS
X	/* to correctly reset named artifacts on the level */
X	{
X		register struct monst *mtmp;
X
X		for(mtmp = fmon; mtmp; mtmp = mtmp->nmon)
X			resetobjs(mtmp->minvent,TRUE);
X		resetobjs(fobj,TRUE);
X		resetobjs(fcobj,TRUE);
X	}
X#endif
X#ifdef WIZARD
X	if(wizard) {
X		pline("Unlink bones? ");
X		if(yn() == 'n') {
X# ifdef COMPRESS
X			compress_bones();
X# endif
X			return(ok);
X		}
X	}
X#endif
X#ifdef MACOS
X	GetVol(name, &oldVol);
X	SetVol(0L, t->recordVRefNum);
X#endif
X	if(unlink(bones) < 0){
X		pline("Cannot unlink %s.", bones);
X#ifdef MACOS
X		SetVol(0L, oldVol);
X#endif
X		return(0);
X	}
X#ifdef MACOS
X	SetVol(0L, oldVol);
X#endif
X	return(ok);
X}
X
X/* construct the string  file.level 
X * This assumes there is space on the end of 'file' to append
X * a two digit number.  This is true for 'bones' and 'level'
X * but be careful if you use it for other things -dgk
X */
Xvoid
Xname_file(file, lev)
Xchar *file;
Xint lev;
X{
X	char *tf;
X
X	if (tf = rindex(file, '.'))
X#ifdef VMS
X	    Sprintf(tf+1, "%d;1", lev);
X#else
X  	    Sprintf(tf+1, "%d", lev);
X#endif
X#ifdef MSDOS /* for glo() */
X	else if (tf = eos(file))
X	    Sprintf(tf, ".%d", lev);
X#endif
X	return;
X}
END_OF_FILE
if test 9945 -ne `wc -c <'src/bones.c'`; then
    echo shar: \"'src/bones.c'\" unpacked with wrong size!
fi
# end of 'src/bones.c'
fi
if test -f 'src/decl.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/decl.c'\"
else
echo shar: Extracting \"'src/decl.c'\" \(10321 characters\)
sed "s/^X//" >'src/decl.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)decl.c	3.0	88/10/25
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include	"hack.h"
X
Xint NEARDATA multi = 0;
Xint NEARDATA warnlevel = 0;		/* used by movemon and dochugw */
Xint NEARDATA nroom = 0;
Xint NEARDATA occtime = 0;
X
Xint x_maze_max, y_maze_max;	/* initialized in main, used in mkmaze.c */
X
X#ifdef REDO
Xint NEARDATA in_doagain = 0;
X#endif
X
X/*
X *	The following integers will be initialized at load time with
X *	the level numbers of some "important" things in the game.
X */
X
X int
X	NEARDATA medusa_level = 0,	/* level that the medusa lives on */
X	NEARDATA bigroom_level = 0,	/* level consisting of a single big room */
X#ifdef REINCARNATION
X	NEARDATA rogue_level = 0,	/* level near which rogue level gen'd */
X#endif
X#ifdef ORACLE
X	NEARDATA oracle_level = 0,	/* level near which Oracle gen'd */
X#endif
X#ifdef STRONGHOLD
X	NEARDATA stronghold_level = 3,	/* level the castle is on */
X	/* Not 0, otherwise they start the game in Hell and burn immediately */
X	NEARDATA tower_level = 0,	/* level of the top of Vlad's 3-level tower */
X#endif
X	NEARDATA wiz_level = 0;		/* level that the wiz lives on */
Xboolean NEARDATA is_maze_lev = FALSE;    /* if this is a maze level */
X
Xint NEARDATA smeq[MAXNROFROOMS+1] = DUMMY;
Xint NEARDATA doorindex = 0;
X
Xchar NEARDATA *save_cm = 0;
Xint NEARDATA killer_format = 0;
Xconst char NEARDATA *killer = 0;
Xconst char NEARDATA *nomovemsg = 0;
Xconst char NEARDATA nul[40] = DUMMY;		/* contains zeros */
Xchar NEARDATA plname[PL_NSIZ] = DUMMY;		/* player name */
Xchar NEARDATA pl_character[PL_CSIZ] = DUMMY;
X
X#ifdef TUTTI_FRUTTI
Xchar NEARDATA pl_fruit[PL_FSIZ] = DUMMY;
Xint NEARDATA current_fruit = 0;
Xstruct fruit NEARDATA *ffruit = 0;
X#endif
X
X#ifdef STRONGHOLD
Xchar NEARDATA tune[6] = DUMMY;
X#  ifdef MUSIC
Xschar NEARDATA music_heard = 0;
X#  endif
X#endif
X
X#ifdef SMALLDATA
Xconst char *occtxt = 0;
X#else
Xconst char NEARDATA *occtxt = DUMMY;
X#endif
Xconst char NEARDATA quitchars[] = " \r\n\033";
Xconst char NEARDATA vowels[] = "aeiouAEIOU";
Xconst char NEARDATA ynchars[] = "yn";
Xconst char NEARDATA ynqchars[] = "ynq";
Xconst char NEARDATA ynaqchars[] = "ynaq";
Xconst char NEARDATA nyaqchars[] = "nyaq";
X
X#ifdef SMALLDATA
Xchar *HI = 0, *HE = 0, *AS = 0, *AE = 0, *CD = 0;
X	/* set up in termcap.c */
X#else
Xchar *HI = DUMMY, *HE = DUMMY, *AS = DUMMY, *AE = DUMMY, *CD = DUMMY;
X	/* set up in termcap.c */
X#endif
Xint CO = 0, LI = 0;	/* set up in termcap.c: usually COLNO and ROWNO+3 */
X
X#ifdef CLIPPING
Xboolean clipping = FALSE;	/* clipping on? */
Xint clipx = 0, clipy = 0, clipxmax = 0, clipymax = 0;
X#endif
X
X#ifdef TEXTCOLOR
X# ifdef TOS
Xconst char *hilites[MAXCOLORS];	/* terminal escapes for the various colors */
X# else
Xchar NEARDATA *hilites[MAXCOLORS]; /* terminal escapes for the various colors */
X# endif
X#endif
X#ifdef MSDOS
Xchar hackdir[PATHLEN];		/* where rumors, help, record are */
Xconst char *configfile = "NetHack.cnf";	/* read by read_config_file() */
Xchar levels[PATHLEN];		/* where levels are */
X#endif /* MSDOS */
X
X#ifdef DGK
Xchar lock[FILENAME];		/* pathname of level files */
Xchar permbones[PATHLEN];	/* where permanent copy of bones go */
Xint ramdisk = FALSE;		/* whether to copy bones to levels or not */
Xint saveprompt = TRUE;
Xconst char *alllevels = "levels.*";
Xconst char *allbones = "bones.*";
X#else
X# ifdef VMS
Xchar lock[PL_NSIZ+16] = "1lock";/* long enough for uic+login_name+.99;1 */
X# else
Xchar lock[PL_NSIZ+14] = "1lock";/* long enough for uic+login_name+.99 */
X# endif
X#endif
X
Xint NEARDATA dig_effort = 0;	/* effort expended on current pos */
Xuchar NEARDATA dig_level = 0;
Xcoord NEARDATA dig_pos = DUMMY;
Xboolean NEARDATA dig_down = FALSE;
X
Xxchar NEARDATA dlevel = 1;
Xxchar NEARDATA maxdlevel = 1;
Xint NEARDATA done_stopprint = 0;
Xint NEARDATA done_hup = 0;
Xxchar NEARDATA xupstair = 0, NEARDATA yupstair = 0, 
X	NEARDATA xdnstair = 0, NEARDATA ydnstair = 0;
X#ifdef STRONGHOLD
Xxchar NEARDATA xupladder = 0, NEARDATA yupladder = 0,
X	NEARDATA xdnladder = 0, NEARDATA ydnladder = 0;
X#endif
Xxchar NEARDATA curx = 0, NEARDATA cury = 0;
Xxchar NEARDATA seelx = 0, NEARDATA seehx = 0, NEARDATA seely = 0,
X	NEARDATA seehy = 0; /* corners of lit room */
Xxchar NEARDATA seelx2 = 0, NEARDATA seehx2 = 0, NEARDATA seely2 = 0,
X	NEARDATA  seehy2 = 0; /* corners of lit room */
Xxchar NEARDATA scrlx = 0, NEARDATA scrhx = 0, NEARDATA scrly = 0,
X	NEARDATA scrhy = 0; /* corners of new scr. area*/
Xxchar NEARDATA fountsound = 0;
Xxchar NEARDATA sinksound = 0; /* numbers of other things that make noise */
X
Xboolean NEARDATA in_mklev = FALSE;
Xboolean	NEARDATA stoned = FALSE;	/* done to monsters hit by 'c' */
Xboolean	NEARDATA unweapon = FALSE;
Xboolean NEARDATA mrg_to_wielded = FALSE;
X			 /* weapon picked is merged with wielded one */
X
X#ifdef KOPS
Xboolean NEARDATA allow_kops = TRUE;
X#endif
X
Xcoord NEARDATA bhitpos = DUMMY;
Xcoord NEARDATA doors[DOORMAX] = DUMMY;
X
Xstruct mkroom NEARDATA rooms[MAXNROFROOMS+1] = DUMMY;
Xdlevel_t level;		/* level map */
Xstruct trap *ftrap = 0;
Xstruct gold *fgold = 0;
Xstruct monst NEARDATA youmonst = DUMMY;	/* dummy; used as return value for boomhit */
Xstruct flag NEARDATA flags = DUMMY;
Xstruct you NEARDATA u = DUMMY;
X
Xstruct obj NEARDATA *fcobj = 0, NEARDATA *invent = 0, NEARDATA *uwep = 0,
X	NEARDATA *uarm = 0,
X#ifdef SHIRT
X	NEARDATA *uarmu = 0,		/* under-wear, so to speak */
X#endif
X#ifdef POLYSELF
X	NEARDATA *uskin = 0,		/* dragon armor, if a dragon */
X#endif
X	NEARDATA *uarmc = 0, NEARDATA *uarmh = 0, NEARDATA *uarms = 0,
X	NEARDATA *uarmg = 0, NEARDATA *uarmf = 0, NEARDATA *uamul = 0,
X	NEARDATA *uright = 0, NEARDATA *uleft = 0, NEARDATA *ublindf = 0,
X	NEARDATA *uchain = 0, NEARDATA *uball = 0;
X
Xsymbol_array defsyms = {
X    ' ', /* stone */
X    '|', /* vwall */
X    '-', /* hwall */
X    '-', /* tlcorn */
X    '-', /* trcorn */
X    '-', /* blcorn */
X    '-', /* brcorn */
X    '-', /* crwall */
X    '-', /* tuwall */
X    '-', /* tdwall */
X    '|', /* tlwall */
X    '|', /* trwall */
X    '|', /* vbeam */
X    '-', /* hbeam */
X    '\\', /* lslant */
X    '/', /* rslant */
X    '.', /* ndoor */
X    '-', /* vodoor */
X    '|', /* hodoor */
X    '+', /* cdoor */
X    '.', /* room */
X    '#', /* corr */
X    '<', /* upstair */
X    '>', /* dnstair */
X    '^', /* trap */
X    '"', /* web */
X    '}', /* pool */
X    '{', /* fountain */	/* used ifdef FOUNTAINS */
X    '#', /* sink */	/* used ifdef SINKS */
X    '\\', /* throne */	/* used ifdef THRONES */
X    '_', /* altar */	/* used ifdef ALTARS */
X    '<', /* upladder */	/* used ifdef STRONGHOLD */
X    '>', /* dnladder */	/* used ifdef STRONGHOLD */
X    '#', /* dbvwall */	/* used ifdef STRONGHOLD */
X    '#', /* dbhwall */	/* used ifdef STRONGHOLD */
X};
Xsymbol_array showsyms = DUMMY; /* will contain the symbols actually used */
X#ifdef REINCARNATION
Xsymbol_array savesyms = DUMMY;
X#endif
X
Xconst char *explainsyms[MAXPCHARS] = {
X	"dark part of a room", "wall", "wall",
X	"wall", "wall", "wall",
X	"wall", "wall", "wall",
X	"wall", "wall", "wall",
X	"wall", "wall", "wall",
X	"wall", "doorway", "open door",
X	"open door", "closed door", "floor of a room",
X	"corridor", "staircase up", "staircase down",
X	"trap", "web", "water filled area",
X#ifdef FOUNTAINS
X	"fountain",
X#else
X	"",
X#endif
X#ifdef SINKS
X	"sink",
X#else
X	"",
X#endif
X#ifdef THRONES
X	"opulent throne",
X#else
X	"",
X#endif
X#ifdef ALTARS
X	"altar",
X#else
X	"",
X#endif
X#ifdef STRONGHOLD
X	"ladder up", "ladder down", "drawbridge", "drawbridge"
X#else
X	"", "", "", ""
X#endif
X};
X
X#ifdef SPELLS
Xstruct spell NEARDATA spl_book[MAXSPELL + 1] = DUMMY;
X#endif
X
Xlong NEARDATA moves = 1, NEARDATA monstermoves = 1;
X	 /* These diverge when player is Fast */
Xlong NEARDATA wailmsg = 0;
X
Xstruct obj NEARDATA zeroobj = DUMMY;	/* used to zero all elements of a struct obj */
X
Xstruct obj *billobjs = 0;
X
X#ifdef THINK_C
Xconst char Black[] = "black";
X#else
Xconst char black[] = "black";
X#endif
Xconst char amber[] = "amber";
X#ifdef THEOLOGY
Xconst char golden[] = "golden";
X#endif
Xconst char light_blue[] = "light blue";
Xconst char red[] = "red";
Xconst char green[] = "green";
Xconst char silver[] = "silver";
Xconst char blue[] = "blue";
Xconst char purple[] = "purple";
X#ifdef THINK_C
Xconst char White[] = "white";
X#else
Xconst char white[] = "white";
X#endif
X
Xconst char nothing_happens[] = "Nothing happens.";
Xconst char thats_enough_tries[] = "That's enough tries!";
X
Xconst char monsyms[] = { S_HUMAN, S_GHOST, S_ANT, S_BLOB, S_COCKATRICE, S_DOG,
XS_EYE, S_FELINE, S_GREMLIN, S_HUMANOID, S_IMP, S_JELLY, S_KOBOLD,
XS_LEPRECHAUN, S_MIMIC, S_NYMPH, S_ORC, S_PIERCER, S_QUADRUPED, S_RODENT,
XS_SPIDER, S_TRAPPER, S_UNICORN, S_VORTEX, S_WORM, S_XAN, S_YLIGHT, S_ZRUTY,
XS_APE, S_BAT, S_CENTAUR, S_DRAGON, S_ELEMENTAL, S_FUNGUS, S_GNOME, S_GIANT,
XS_STALKER, S_JABBERWOCK,
X#ifdef KOPS
XS_KOP,
X#endif
XS_LICH, S_MUMMY, S_NAGA, S_OGRE, S_PUDDING, S_QUANTMECH, S_RUSTMONST, S_SNAKE,
XS_TROLL, S_UMBER, S_VAMPIRE, S_WRAITH, S_XORN, S_YETI, S_ZOMBIE,
X#ifdef GOLEMS
XS_GOLEM,
X#endif
XS_DEMON, S_EEL, S_LIZARD,
X#ifdef WORM
XS_WORM_TAIL,
X#endif
X0 };
X
Xconst char objsyms[] = { WEAPON_SYM, ARMOR_SYM, POTION_SYM, SCROLL_SYM,
XWAND_SYM,
X#ifdef SPELLS
XSPBOOK_SYM,
X#endif
XRING_SYM, AMULET_SYM, FOOD_SYM, TOOL_SYM, GEM_SYM, GOLD_SYM,
XROCK_SYM, BALL_SYM, CHAIN_SYM, 0 };
X
Xconst char *monexplain[] = {
X"human", "ghost", "ant or other insect", "blob", "cockatrice",
X"dog or other canine", "eye or sphere", "feline", "gremlin", "humanoid",
X"imp or minor demon", "jelly", "kobold", "leprechaun", "mimic",
X"nymph", "orc", "piercer", "quadruped", "rodent",
X"spider", "trapper or lurker above", "unicorn", "vortex", "worm",
X"xan or other mythical/fantastic insect", "yellow light", "zruty",
X"ape", "bat", "centaur", "dragon", "elemental",
X"fungus or mold", "gnome", "giant humanoid", "invisible stalker", "jabberwock",
X#ifdef KOPS
X"Keystone Kop",
X#endif
X"lich", "mummy", "naga", "ogre", "pudding or ooze",
X"quantum mechanic", "rust monster", "snake", "troll", "umber hulk",
X"vampire", "wraith", "xorn", "yeti", "zombie",
X#ifdef GOLEMS
X"golem",
X#endif
X"demon",  "sea monster", "lizard",
X#ifdef WORM
X"long worm tail",
X#endif
X};
X
Xconst char *objexplain[] = {
X"weapon", "suit or piece of armor", "potion", "scroll", "wand",
X#ifdef SPELLS
X"spell book",
X#endif
X"ring", "amulet", "piece of food", "useful item (pick-axe, key, lamp...)",
X"gem or rock", "pile of gold", "boulder or statue", "iron ball", "iron chain"
X};
END_OF_FILE
if test 10321 -ne `wc -c <'src/decl.c'`; then
    echo shar: \"'src/decl.c'\" unpacked with wrong size!
fi
# end of 'src/decl.c'
fi
if test -f 'src/extralev.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/extralev.c'\"
else
echo shar: Extracting \"'src/extralev.c'\" \(10163 characters\)
sed "s/^X//" >'src/extralev.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)extralev.c	3.0	88/04/11			*/
X/*	Copyright 1988, 1989 by Ken Arromdee				*/
X/* NetHack may be freely redistributed.  See license for details. */
X
X#define MONATTK_H	/* comment line for pre-compiled headers */
X/* block some unused #defines to avoid overloading some cpp's */
X#include "hack.h"
X
X#ifdef REINCARNATION
X
Xstruct rogueroom {
X	xchar rlx, rly;
X	xchar dx, dy;
X	boolean real;
X	uchar doortable;
X	int nroom; /* Only meaningful for "real" rooms */
X};
X#define UP 1
X#define DOWN 2
X#define LEFT 4
X#define RIGHT 8
X
Xstatic struct rogueroom NEARDATA r[3][3];
Xstatic void FDECL(roguejoin,(int,int,int,int,int));
Xstatic void FDECL(roguecorr,(int,int,int));
Xstatic void FDECL(miniwalk,(int,int));
X
Xstatic
Xvoid
Xroguejoin(x1,y1,x2,y2, horiz)
Xint x1,y1,x2,y2;
Xint horiz;
X{
X	register int x,y,middle;
X#ifndef MAX
X#define MAX(a,b) (((a) > (b)) ? (a) : (b))
X#endif
X#ifndef MIN
X#define MIN(a,b) (((a) < (b)) ? (a) : (b))
X#endif
X	if (horiz) {
X		middle = x1 + rn2(x2-x1+1);
X		for(x=MIN(x1,middle); x<=MAX(x1,middle); x++)
X			corr(x, y1);
X		for(y=MIN(y1,y2); y<=MAX(y1,y2); y++)
X			corr(middle,y);
X		for(x=MIN(middle,x2); x<=MAX(middle,x2); x++)
X			corr(x, y2);
X	} else {
X		middle = y1 + rn2(y2-y1+1);
X		for(y=MIN(y1,middle); y<=MAX(y1,middle); y++)
X			corr(x1, y);
X		for(x=MIN(x1,x2); x<=MAX(x1,x2); x++)
X			corr(x, middle);
X		for(y=MIN(middle,y2); y<=MAX(middle,y2); y++)
X			corr(x2,y);
X	}
X}
X
Xstatic
Xvoid
Xroguecorr(x, y, dir)
Xint x,y,dir;
X{
X	register int fromx, fromy, tox, toy;
X
X	if (dir==DOWN) {
X		r[x][y].doortable &= ~DOWN;
X		if (!r[x][y].real) {
X			fromx = r[x][y].rlx; fromy = r[x][y].rly;
X			fromx += 1 + 26*x; fromy += 7*y;
X		} else {
X			fromx = r[x][y].rlx + rn2(r[x][y].dx);
X			fromy = r[x][y].rly + r[x][y].dy;
X			fromx += 1 + 26*x; fromy += 7*y;
X			if (!IS_WALL(levl[fromx][fromy].typ))
X				impossible("down: no wall at %d,%d?",fromx,
X									fromy);
X			dodoor(fromx, fromy, &rooms[r[x][y].nroom]);
X			levl[fromx][fromy].doormask = D_NODOOR;
X			mnewsym(fromx,fromy);
X			fromy++;
X		}
X		if(y >= 2) {
X			impossible("down door from %d,%d going nowhere?",x,y);
X			return;
X		}
X		y++;
X		r[x][y].doortable &= ~UP;
X		if (!r[x][y].real) {
X			tox = r[x][y].rlx; toy = r[x][y].rly;
X			tox += 1 + 26*x; toy += 7*y;
X		} else {
X			tox = r[x][y].rlx + rn2(r[x][y].dx);
X			toy = r[x][y].rly - 1;
X			tox += 1 + 26*x; toy += 7*y;
X			if (!IS_WALL(levl[tox][toy].typ))
X				impossible("up: no wall at %d,%d?",tox,toy);
X			dodoor(tox, toy, &rooms[r[x][y].nroom]);
X			levl[tox][toy].doormask = D_NODOOR;
X			mnewsym(tox,toy);
X			toy--;
X		}
X		roguejoin(fromx, fromy, tox, toy, FALSE);
X		return;
X	} else if (dir == RIGHT) {
X		r[x][y].doortable &= ~RIGHT;
X		if (!r[x][y].real) {
X			fromx = r[x][y].rlx; fromy = r[x][y].rly;
X			fromx += 1 + 26*x; fromy += 7*y;
X		} else {
X			fromx = r[x][y].rlx + r[x][y].dx;
X			fromy = r[x][y].rly + rn2(r[x][y].dy);
X			fromx += 1 + 26*x; fromy += 7*y;
X			if (!IS_WALL(levl[fromx][fromy].typ))
X				impossible("down: no wall at %d,%d?",fromx,
X									fromy);
X			dodoor(fromx, fromy, &rooms[r[x][y].nroom]);
X			levl[fromx][fromy].doormask = D_NODOOR;
X			mnewsym(fromx,fromy);
X			fromx++;
X		}
X		if(x >= 2) {
X			impossible("right door from %d,%d going nowhere?",x,y);
X			return;
X		}
X		x++;
X		r[x][y].doortable &= ~LEFT;
X		if (!r[x][y].real) {
X			tox = r[x][y].rlx; toy = r[x][y].rly;
X			tox += 1 + 26*x; toy += 7*y;
X		} else {
X			tox = r[x][y].rlx - 1;
X			toy = r[x][y].rly + rn2(r[x][y].dy);
X			tox += 1 + 26*x; toy += 7*y;
X			if (!IS_WALL(levl[tox][toy].typ))
X				impossible("left: no wall at %d,%d?",tox,toy);
X			dodoor(tox, toy, &rooms[r[x][y].nroom]);
X			levl[tox][toy].doormask = D_NODOOR;
X			mnewsym(tox,toy);
X			tox--;
X		}
X		roguejoin(fromx, fromy, tox, toy, TRUE);
X		return;
X	} else impossible("corridor in direction %d?",dir);
X}
X			
X/* Modified walkfrom() from mkmaze.c */
Xstatic
Xvoid
Xminiwalk(x, y)
Xint x,y;
X{
X	register int q, dir;
X	int dirs[4];
X
X	while(1) {
X		q = 0;
X#define doorhere (r[x][y].doortable)
X		if (x>0 && (!(doorhere & LEFT)) &&
X					(!r[x-1][y].doortable || !rn2(10)))
X			dirs[q++] = 0;
X		if (x<2 && (!(doorhere & RIGHT)) &&
X					(!r[x+1][y].doortable || !rn2(10)))
X			dirs[q++] = 1;
X		if (y>0 && (!(doorhere & UP)) &&
X					(!r[x][y-1].doortable || !rn2(10)))
X			dirs[q++] = 2;
X		if (y<2 && (!(doorhere & DOWN)) &&
X					(!r[x][y+1].doortable || !rn2(10)))
X			dirs[q++] = 3;
X	/* Rogue levels aren't just 3 by 3 mazes; they have some extra
X	 * connections, thus that 1/10 chance
X	 */
X		if (!q) return;
X		dir = dirs[rn2(q)];
X		switch(dir) { /* Move in direction */
X			case 0: doorhere |= LEFT;
X				x--;
X				doorhere |= RIGHT;
X				break;
X			case 1: doorhere |= RIGHT;
X				x++;
X				doorhere |= LEFT;
X				break;
X			case 2: doorhere |= UP;
X				y--;
X				doorhere |= DOWN;
X				break;
X			case 3: doorhere |= DOWN;
X				y++;
X				doorhere |= UP;
X				break;
X		}
X		miniwalk(x,y);
X	}
X}
X
Xvoid
Xmakeroguerooms() {
X	register struct mkroom *croom;
X	register int x,y;
X	int x2, y2;
X	/* Rogue levels are structured 3 by 3, with each section containing
X	 * a room or an intersection.  The minimum width is 2 each way.
X	 * One difference between these and "real" Rogue levels: real Rogue
X	 * uses 24 rows and NetHack only 23.  So we cheat a bit by making the
X	 * second row of rooms not as deep.
X	 *
X	 * Each normal space has 6/7 rows and 25 columns in which a room may
X	 * actually be placed.  Walls go from rows 0-5/6 and columns 0-24.
X	 * Not counting walls, the room may go in
X	 * rows 1-5 and columns 1-23 (numbering starting at 0).  A room
X	 * coordinate of this type may be converted to a level coordinate
X	 * by adding 1+28*x to the column, and 7*y to the row.  (The 1
X	 * is because column 0 isn't used [we only use 1-78]).
X	 * Room height may be 2-4 (2-5 on last row), length 2-23 (not
X	 * counting walls)
X	 */
X#define here r[x][y]
X
X	nroom = 0;
X	for(y=0; y<3; y++) for(x=0; x<3; x++) {
X		/* Note: we want to insure at least 1 room.  So, if the
X		 * first 8 are all dummies, force the last to be a room.
X		 */
X		if (!rn2(5) && (nroom || (x<2 && y<2))) {
X			/* Arbitrary: dummy rooms may only go where real
X			 * ones do.
X			 */
X			here.real = FALSE;
X			here.rlx = rn1(22, 2);
X			here.rly = rn1((y==2)?4:3, 2);
X		} else {
X			here.real = TRUE;
X			here.dx = rn1(22, 2); /* 2-23 long, plus walls */
X			here.dy = rn1((y==2)?4:3, 2); /* 2-5 high, plus walls */
X
X			/* boundaries of room floor */
X			here.rlx = rnd(23 - here.dx + 1);
X			here.rly = rnd(((y==2) ? 5 : 4)- here.dy + 1);
X			nroom++;
X		}
X		here.doortable = 0;
X	}
X	miniwalk(rn2(3), rn2(3));
X	nroom = 0;
X	for(y=0; y<3; y++) for(x=0; x<3; x++) {
X		if (here.real) { /* Make a room */
X			r[x][y].nroom = nroom;
X			croom = &rooms[nroom];
X			/* Illumination.  Strictly speaking, it should be lit
X			 * only if above level 10, but since Rogue rooms are
X			 * only encountered below level 10...
X			 */
X			if (!rn2(7)) {
X				for(x2 = 1+26*x+here.rlx-1;
X				    x2 <= 1+26*x+here.rlx+here.dx; x2++)
X				for(y2 = 7*y+here.rly-1;
X				    y2 <= 7*y+here.rly+here.dy; y2++)
X					levl[x2][y2].lit = 1;
X				croom->rlit = 1;
X			} else croom->rlit = 0;
X			croom->lx = 1 + 26*x + here.rlx;
X			croom->ly = 7*y + here.rly;
X			croom->hx = 1 + 26*x + here.rlx + here.dx - 1;
X			croom->hy = 7*y + here.rly + here.dy - 1;
X			/* Walls, doors, and floors. */
X#define lowx croom->lx
X#define lowy croom->ly
X#define hix croom->hx
X#define hiy croom->hy
X			for(x2 = lowx-1; x2 <= hix+1; x2++)
X			    for(y2 = lowy-1; y2 <= hiy+1; y2 += (hiy-lowy+2)) {
X				levl[x2][y2].scrsym = HWALL_SYM;
X				levl[x2][y2].typ = HWALL;
X			}
X			for(x2 = lowx-1; x2 <= hix+1; x2 += (hix-lowx+2))
X			    for(y2 = lowy; y2 <= hiy; y2++) {
X				levl[x2][y2].scrsym = VWALL_SYM;
X				levl[x2][y2].typ = VWALL;
X			}
X			for(x2 = lowx; x2 <= hix; x2++)
X			    for(y2 = lowy; y2 <= hiy; y2++) {
X				levl[x2][y2].scrsym = ROOM_SYM;
X				levl[x2][y2].typ = ROOM;
X			}
X			levl[lowx-1][lowy-1].typ = TLCORNER;
X			levl[hix+1][lowy-1].typ = TRCORNER;
X			levl[lowx-1][hiy+1].typ = BLCORNER;
X			levl[hix+1][hiy+1].typ = BRCORNER;
X			levl[lowx-1][lowy-1].scrsym = TLCORN_SYM;
X			levl[hix+1][lowy-1].scrsym = TRCORN_SYM;
X			levl[lowx-1][hiy+1].scrsym = BLCORN_SYM;
X			levl[hix+1][hiy+1].scrsym = BRCORN_SYM;
X
X			/* Misc. */
X			smeq[nroom] = nroom;
X			croom->rtype = OROOM;
X			croom++;
X			croom->hx = -1;
X			nroom++;
X		}
X	}
X
X	/* Now, add connecting corridors. */
X	for(y=0; y<3; y++) for(x=0; x<3; x++) {
X		if (here.doortable & DOWN)
X			roguecorr(x, y, DOWN);
X		if (here.doortable & RIGHT)
X			roguecorr(x, y, RIGHT);
X		if (here.doortable & LEFT)
X			impossible ("left end of %d, %d never connected?",x,y);
X		if (here.doortable & UP)
X			impossible ("up end of %d, %d never connected?",x,y);
X	}
X}
X
Xvoid
Xcorr(x,y)
Xint x, y;
X{
X	if (rn2(50)) {
X		levl[x][y].typ = CORR;
X		levl[x][y].scrsym = CORR_SYM;
X	} else {
X		levl[x][y].typ = SCORR;
X		levl[x][y].scrsym = ' ';	/* _not_ STONE_SYM */
X	}
X}
X
Xvoid
Xmakerogueghost()
X{
X	register struct monst *ghost;
X	struct obj *ghostobj;
X	struct mkroom *croom;
X	int x,y;
X
X	if (!nroom) return; /* Should never happen */
X	croom = &rooms[rn2(nroom)];
X	x = somex(croom); y = somey(croom);
X	if (!(ghost = makemon(&mons[PM_GHOST], x, y)))
X		return;
X	ghost->msleep = 1;
X	Strcpy((char *)ghost->mextra, roguename());
X
X	if (rn2(4)) {
X		ghostobj = mksobj_at(FOOD_RATION,x,y);
X		ghostobj->quan = rnd(7);
X		ghostobj->owt = weight(ghostobj);
X	}
X	if (rn2(2)) {
X		ghostobj = mksobj_at(MACE,x,y);
X		ghostobj->spe = rnd(3);
X		if (rn2(4)) curse(ghostobj);
X	} else {
X		ghostobj = mksobj_at(TWO_HANDED_SWORD,x,y);
X		ghostobj->spe = rnd(5) - 2;
X		if (rn2(4)) curse(ghostobj);
X	}
X	ghostobj = mksobj_at(BOW,x,y);
X	ghostobj->spe = 1;
X	if (rn2(4)) curse(ghostobj);
X
X	ghostobj = mksobj_at(ARROW,x,y);
X	ghostobj->spe = 0;
X	ghostobj->quan = rn1(10,25);
X	ghostobj->owt = weight(ghostobj);
X	if (rn2(4)) curse(ghostobj);
X
X	if (rn2(2)) {
X		ghostobj = mksobj_at(RING_MAIL,x,y);
X		ghostobj->spe = rn2(3);
X		if (!rn2(3)) ghostobj->rustfree = 1;
X		if (rn2(4)) curse(ghostobj);
X	} else {
X		ghostobj = mksobj_at(PLATE_MAIL,x,y);
X		ghostobj->spe = rnd(5) - 2;
X		if (!rn2(3)) ghostobj->rustfree = 1;
X		if (rn2(4)) curse(ghostobj);
X	}
X	if (rn2(2)) {
X		ghostobj = mksobj_at(AMULET_OF_YENDOR,x,y);
X		ghostobj->spe = -1;
X		ghostobj->known = TRUE;
X	}
X}
X#endif /* REINCARNATION /**/
END_OF_FILE
if test 10163 -ne `wc -c <'src/extralev.c'`; then
    echo shar: \"'src/extralev.c'\" unpacked with wrong size!
fi
# end of 'src/extralev.c'
fi
if test -f 'src/weapon.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/weapon.c'\"
else
echo shar: Extracting \"'src/weapon.c'\" \(9919 characters\)
sed "s/^X//" >'src/weapon.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)weapon.c	3.0	89/11/19
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X/*
X *	This module contains code for calculation of "to hit" and damage
X *	bonuses for any given weapon used, as well as weapons selection
X *	code for monsters.
X */
X#include	"hack.h"
X
X#ifdef OVLB
X
Xstatic const char NEARDATA kebabable[] = { S_XORN, S_DRAGON, S_NAGA, S_GIANT, 0 };
X
X/*
X * 	hitval returns an integer representing the "to hit" bonuses
X *	of "otmp" against the monster type "ptr".
X */
Xint
Xhitval(otmp, ptr)
Xstruct	obj *otmp;
Xstruct	permonst *ptr;
X{
X	int	tmp = 0;
X
X	if(otmp->olet == WEAPON_SYM || otmp->otyp == PICK_AXE
X						|| otmp->otyp == UNICORN_HORN)
X		tmp += otmp->spe;
X
X/*	Put weapon specific "to hit" bonuses in below:		*/
X	switch(otmp->otyp) {
X
X#ifdef TOLKIEN
X	    case DWARVISH_MATTOCK:
X#endif
X	    case TWO_HANDED_SWORD:	tmp -= 1; break;
X	    case KATANA:		tmp += 1; break;
X#ifdef TOLKIEN
X	    case ELVEN_DAGGER:
X	    case ORCISH_DAGGER:
X#endif
X	    case DAGGER:
X	    case SCALPEL:
X	    case ATHAME:
X	    case SHURIKEN:		tmp += 2; break;
X#ifdef WORM
X	    case CRYSKNIFE:		tmp += 3; break;
X#endif
X	}
X
X/*	Put weapon vs. monster type "to hit" bonuses in below:	*/
X
X	/* Blessed weapons used against undead or demons */
X	if(otmp->olet == WEAPON_SYM && otmp->blessed &&
X	   (is_demon(ptr) || is_undead(ptr))) tmp += 2;
X
X	if(otmp->otyp >= SPEAR && otmp->otyp <= JAVELIN &&
X	   index(kebabable, ptr->mlet)) tmp += 2;
X
X/*	Put specially named weapon "to hit" bonuses in below:	*/
X#ifdef NAMED_ITEMS
X	tmp += spec_abon(otmp, ptr);
X#endif
X	return(tmp);
X}
X
X/*
X * 	dmgval returns an integer representing the damage bonuses
X *	of "otmp" against the monster type "ptr".
X */
Xint
Xdmgval(otmp, ptr)
Xstruct	obj *otmp;
Xstruct	permonst *ptr;
X{
X	int	tmp = 0;
X
X	if(otmp->otyp == CREAM_PIE)	return(0);
X
X	if(ptr->msize >= MZ_HUMAN) {
X	    if(objects[otmp->otyp].wldam)
X		tmp = rnd(objects[otmp->otyp].wldam);
X	    switch (otmp->otyp) {
X		case CROSSBOW_BOLT:
X		case MORNING_STAR:
X		case PARTISAN:
X#ifdef TOLKIEN
X		case ELVEN_BROADSWORD:
X#endif
X		case BROADSWORD:	tmp++; break;
X
X		case FLAIL:
X		case RANSEUR:
X		case VOULGE:		tmp += rnd(4); break;
X
X		case ACID_VENOM:
X		case HALBERD:
X		case SPETUM:		tmp += rnd(6); break;
X
X		case BARDICHE:
X		case TRIDENT:		tmp += d(2,4); break;
X
X#ifdef TOLKIEN
X		case DWARVISH_MATTOCK:
X#endif
X		case TWO_HANDED_SWORD:	tmp += d(2,6); break;
X	    }
X	} else {
X	    if(objects[otmp->otyp].wsdam)
X		tmp = rnd(objects[otmp->otyp].wsdam);
X	    switch (otmp->otyp) {
X		case CROSSBOW_BOLT:
X		case MACE:
X		case WAR_HAMMER:
X		case FLAIL:
X		case SPETUM:
X		case TRIDENT:		tmp++; break;
X
X		case BARDICHE:
X		case BILL_GUISARME:
X		case GUISARME:
X		case LUCERN_HAMMER:
X		case MORNING_STAR:
X		case RANSEUR:
X		case BROADSWORD:
X#ifdef TOLKIEN
X		case ELVEN_BROADSWORD:
X#endif
X		case VOULGE:		tmp += rnd(4); break;
X
X		case ACID_VENOM:	tmp += rnd(6); break;
X	    }
X	}
X	if (otmp->otyp == BULLWHIP && thick_skinned(ptr))
X		/* thick skinned/scaled creatures don't feel it */
X		tmp = 0;
X	if (otmp->olet == WEAPON_SYM || otmp->otyp == PICK_AXE
X						|| otmp->otyp == UNICORN_HORN)
X		tmp += otmp->spe;
X
X/*	Put weapon vs. monster type damage bonuses in below:	*/
X	if(otmp->olet == WEAPON_SYM) {
X	    if (otmp->blessed && (is_undead(ptr) || is_demon(ptr)))
X		tmp += rnd(4);
X	}
X
X/*	Put specially named weapon damage bonuses in below:	*/
X#ifdef NAMED_ITEMS
X	tmp += spec_dbon(otmp, ptr, tmp);
X#endif
X	return(tmp);
X}
X
Xvoid
Xset_uasmon() {		/* update the "uasmon" structure */
X
X#ifdef POLYSELF
X	if(u.umonnum >= 0) uasmon = &mons[u.umonnum];
X	else {
X#endif
X
X		uasmon = &playermon;
X		playermon.mlevel = u.ulevel;
X		playermon.ac = u.uac;
X		playermon.mr = (u.ulevel > 8) ? 5 * (u.ulevel-7) : u.ulevel;
X#ifdef POLYSELF
X	}
X#endif
X	return;
X}
X
X#endif /* OVLB */
X#ifdef OVL0
X
X#define	Oselect(x)	if((otmp = m_carrying(mtmp, x))) return(otmp);
X
X#ifdef TOLKIEN
Xstatic const int NEARDATA rwep[] =
X	{ DWARVISH_SPEAR, ELVEN_SPEAR, SPEAR, ORCISH_SPEAR, JAVELIN,
X	  SHURIKEN, SILVER_ARROW, ELVEN_ARROW, ARROW, ORCISH_ARROW,
X	  CROSSBOW_BOLT, ELVEN_DAGGER, DAGGER, ORCISH_DAGGER, KNIFE, ROCK,
X	  LOADSTONE, LUCKSTONE, DART, /* BOOMERANG, */ CREAM_PIE
X	  /* note: CREAM_PIE should NOT be #ifdef KOPS */
X	  };
X#else
Xstatic const int NEARDATA rwep[] =
X	{ SPEAR, JAVELIN, SHURIKEN, SILVER_ARROW, ARROW, CROSSBOW_BOLT,
X	  DAGGER, KNIFE, ROCK, LOADSTONE, LUCKSTONE, DART, /* BOOMERANG, */
X	  CREAM_PIE
X	  /* note: CREAM_PIE should NOT be #ifdef KOPS */
X	  };
X#endif
X
Xstruct obj *
Xselect_rwep(mtmp)	/* select a ranged weapon for the monster */
Xregister struct monst *mtmp;
X{
X	register struct obj *otmp;
X	int i;
X#ifdef KOPS
X	char mlet = mtmp->data->mlet;
X
X	if(mlet == S_KOP)	/* pies are first choice for Kops */
X	    Oselect(CREAM_PIE);
X#endif
X	if(throws_rocks(mtmp->data))	/* ...boulders for giants */
X	    Oselect(BOULDER);
X	/*
X	 * other than these two specific cases, always select the
X	 * most potent ranged weapon to hand.
X	 */
X	for (i = 0; i < SIZE(rwep); i++) {
X	    boolean no_propellor = FALSE;
X	    int prop;
X
X	    /* shooting gems from slings; this goes just before the darts */
X	    if (rwep[i]==DART && !likes_gems(mtmp->data)
X			&& m_carrying(mtmp, SLING)) {
X		for(otmp=mtmp->minvent; otmp; otmp=otmp->nobj) {
X		    if(otmp->olet==GEM_SYM &&
X				(otmp->otyp != LOADSTONE || !otmp->cursed))
X			return(otmp);
X		}
X	    }
X	    prop = (objects[rwep[i]]).w_propellor;
X	    if (prop > 0) {
X		switch (prop) {
X		case WP_BOW:
X#ifdef TOLKIEN
X		  no_propellor = !(m_carrying(mtmp, BOW) ||
X				   m_carrying(mtmp, ELVEN_BOW) ||
X				   m_carrying(mtmp, ORCISH_BOW));
X#else
X		  no_propellor = !(m_carrying(mtmp, BOW));
X#endif
X		  break;
X		case WP_SLING:
X		  no_propellor = !(m_carrying(mtmp, SLING));
X		  break;
X		case WP_CROSSBOW:
X		  no_propellor = !(m_carrying(mtmp, CROSSBOW));
X		}
X	      }
X	    if (!no_propellor) {
X		/* Note: cannot use m_carrying for loadstones, since it will
X		 * always select the first object of a type, and maybe the
X		 * monster is carrying two but only the first is unthrowable.
X		 */
X		if (rwep[i] != LOADSTONE) {
X			Oselect(rwep[i]);
X		} else for(otmp=mtmp->minvent; otmp; otmp=otmp->nobj) {
X		    if (otmp->otyp == LOADSTONE && !otmp->cursed)
X			return otmp;
X		}
X	    }
X	  }
X
X	/* failure */
X	return (struct obj *)0;
X}
X
X#ifdef TOLKIEN
X/* 0 = used by any monster; 1 = only used by strong monsters */
Xstatic const int NEARDATA hwep[][2] =
X	{ {DWARVISH_MATTOCK,1}, {TWO_HANDED_SWORD,1}, {KATANA,0},
X	  {UNICORN_HORN,1},
X#ifdef WORM
X	  {CRYSKNIFE,0},
X#endif
X	  {TRIDENT,0}, {LONG_SWORD,0}, {ELVEN_BROADSWORD,0}, {BROADSWORD,0},
X	  {LUCERN_HAMMER,1}, {SCIMITAR,1}, {HALBERD,1}, {PARTISAN,1},
X	  {LANCE,1}, {FAUCHARD,1}, {BILL_GUISARME,1}, {BEC_DE_CORBIN,1},
X	  {GUISARME,1}, {RANSEUR,1}, {SPETUM,1}, {VOULGE,1}, {BARDICHE,0},
X	  {MORNING_STAR,0}, {GLAIVE,0}, {ELVEN_SHORT_SWORD,0},
X	  {DWARVISH_SHORT_SWORD,0}, {SHORT_SWORD,0}, {ORCISH_SHORT_SWORD,0},
X	  {MACE,0}, {AXE,0}, {DWARVISH_SPEAR,0}, {ELVEN_SPEAR,0}, {SPEAR,0},
X	  {ORCISH_SPEAR,0}, {FLAIL,0}, {QUARTERSTAFF,1}, {JAVELIN,0},
X	  {AKLYS,0}, {CLUB,0}, {PICK_AXE,0},
X#ifdef KOPS
X	  {RUBBER_HOSE,0},
X#endif /* KOPS */
X	  {WAR_HAMMER,0}, {ELVEN_DAGGER,0}, {DAGGER,0}, {ORCISH_DAGGER,0},
X	  {ATHAME,0}, {SCALPEL,0}, {KNIFE,0},
X#ifdef WORM
X	  {WORM_TOOTH,0},
X#endif
X	  {BULLWHIP,0}
X	};
X#else /* TOLKIEN */
X/* 0 = used by any monster; 1 = only used by strong monsters */
Xstatic const int NEARDATA hwep[][2] =
X	{ {TWO_HANDED_SWORD,1}, {KATANA,0}, {UNICORN_HORN,1},
X#ifdef WORM
X	  {CRYSKNIFE,0},
X#endif
X	  {TRIDENT,0}, {LONG_SWORD,0}, {BROADSWORD,0}, {LUCERN_HAMMER,1},
X	  {SCIMITAR,1}, {HALBERD,1}, {PARTISAN,1}, {LANCE,1}, {FAUCHARD,1},
X	  {BILL_GUISARME,1}, {BEC_DE_CORBIN,1}, {GUISARME,1}, {RANSEUR,1},
X	  {SPETUM,1}, {VOULGE,1}, {BARDICHE,0}, {MORNING_STAR,0}, {GLAIVE,0},
X	  {SHORT_SWORD,0}, {MACE,0}, {AXE,0}, {SPEAR,0}, {FLAIL,0},
X	  {QUARTERSTAFF,1}, {JAVELIN,0}, {AKLYS,0}, {CLUB,0}, {PICK_AXE,0},
X#ifdef KOPS
X	  {RUBBER_HOSE,0},
X#endif /* KOPS */
X	  {WAR_HAMMER,0}, {DAGGER,0}, {ATHAME,0}, {SCALPEL,0}, {KNIFE,0},
X#ifdef WORM
X	  {WORM_TOOTH,0},
X#endif
X	  {BULLWHIP,0}
X	};
X#endif /* TOLKIEN */
X
Xstruct obj *
Xselect_hwep(mtmp)	/* select a hand to hand weapon for the monster */
Xregister struct monst *mtmp;
X{
X	register struct obj *otmp;
X	int i;
X	boolean strong = strongmonst(mtmp->data);
X
X	if(is_giant(mtmp->data))	/* giants just love to use clubs */
X	    Oselect(CLUB);
X
X	/* only strong monsters can wield big (esp. long) weapons */
X	/* all monsters can wield the remaining weapons */
X	for (i = 0; i < SIZE(hwep); i++)
X	    if (strong || hwep[i][1]==0)
X		Oselect(hwep[i][0]);
X
X	/* failure */
X	return (struct obj *)0;
X}
X
Xint
Xabon() {	/* attack bonus for strength & dexterity */
X	int	sbon;
X
X#ifdef POLYSELF
X	if (u.umonnum >= 0) return(adj_lev(&mons[u.umonnum])-3);
X#endif
X	if(ACURR(A_STR) < 6) sbon = -2;
X	else if(ACURR(A_STR) < 8) sbon = -1;
X	else if(ACURR(A_STR) < 17) sbon = 0;
X	else if(ACURR(A_STR) < 69) sbon = 1;	/* up to 18/50 */
X	else if(ACURR(A_STR) < 118) sbon = 2;
X	else sbon = 3;
X/*
X *	Temporary kludge - make it a bit easier for a low level character
X *			   to hit until we tune the game a little better.
X */
X	sbon += (u.ulevel < 3) ? 2 : (u.ulevel < 5) ? 1 : 0;
X
X	if(ACURR(A_DEX) < 4) return(sbon-3);
X	else if(ACURR(A_DEX) < 6) return(sbon-2);
X	else if(ACURR(A_DEX) < 8) return(sbon-1);
X	else if(ACURR(A_DEX) < 14) return(sbon);
X	else return(sbon+ACURR(A_DEX)-14);
X}
X
X#endif /* OVL0 */
X#ifdef OVL1
X
Xint
Xdbon() {	/* damage bonus for strength */
X#ifdef POLYSELF
X	if (u.umonnum >= 0) return(0);
X#endif
X
X	if(ACURR(A_STR) < 6) return(-1);
X	else if(ACURR(A_STR) < 16) return(0);
X	else if(ACURR(A_STR) < 18) return(1);
X	else if(ACURR(A_STR) == 18) return(2);		/* up to 18 */
X	else if(ACURR(A_STR) < 94) return(3);		/* up to 18/75 */
X	else if(ACURR(A_STR) < 109) return(4);		/* up to 18/90 */
X	else if(ACURR(A_STR) < 118) return(5);	/* up to 18/99 */
X	else return(6);
X}
X
X#endif /* OVL1 */
END_OF_FILE
if test 9919 -ne `wc -c <'src/weapon.c'`; then
    echo shar: \"'src/weapon.c'\" unpacked with wrong size!
fi
# end of 'src/weapon.c'
fi
echo shar: End of archive 47 \(of 56\).
cp /dev/null ark47isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 56 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
    echo Building monst.c from monst.c1 and monst.c2
    cat src/monst.c1 src/monst.c2 > src/monst.c
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
