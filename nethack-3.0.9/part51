Path: utzoo!utgpu!news-server.csri.toronto.edu!cs.utexas.edu!wuarchive!mailrus!cornell!uw-beaver!zephyr.ens.tek.com!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v10i096:  nethack3p9 -  display oriented dungeons & dragons (Ver. 3.0i), Part51/56
Message-ID: <5956@tekred.CNA.TEK.COM>
Date: 13 Jul 90 19:44:38 GMT
Sender: news@tekred.CNA.TEK.COM
Lines: 1920
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 10, Issue 96
Archive-name: nethack3p9/Part51
Supersedes: NetHack3: Volume 7, Issue 56-93



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 51 (of 56)."
# Contents:  Install.unix amiga/amimenu.c amiga/compact.lat
#   auxil/nethack.6 include/decl.h include/hack.h include/monflag.h
#   include/trampoli.h include/unixconf.h vms/oldcrtl.c
# Wrapped by billr@saab on Wed Jul 11 17:12:12 1990
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'Install.unix' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Install.unix'\"
else
echo shar: Extracting \"'Install.unix'\" \(6390 characters\)
sed "s/^X//" >'Install.unix' <<'END_OF_FILE'
XInstructions for installing NetHack 3.0 on a UNIX system
X========================================================
X
X1.  Make sure all the NetHack files are in the appropriate directory structure.
X    You should have a main directory with subdirectories src, include, auxil,
X    amiga, mac, vms, and others.  If you do not follow this structure, the
X    Makefiles will not function properly.  All the UNIX .c files and the
X    source Makefile belong in src; all the .h files belong in include; other
X    assorted data files belong in auxil.  The UNIX version does not use any
X    files from the other directories, except possibly for random.c from
X    others, as explained in step 6.  (A more detailed explanation of the
X    directory structure may be found in Files, which should be in the top
X    directory.)
X
X2.  Your Makefiles may still have tags on the end of them.  Makefile.top should
X    become Makefile in the top directory, Makefile.src Makefile in the src
X    subdirectory, and Makefile.auxil Makefile in the auxil subdirectory.
X
X3.  Go to the include subdirectory and edit config.h according to the comments
X    to match your system and desired set of features.  Similarly edit
X    unixconf.h.
X
X4.  If you want to, look through system.h.  This file attempts to match the
X    types for system calls and library routines with various flavors of
X    operating systems.  Leaving this file alone is unlikely to cause worse
X    problems than lint errors, but it's worth checking if you get compile
X    errors, especially if you have an unusual system.
X
X5.  Go to the src subdirectory and look at the top of topten.c.  You may want
X    to change the definitions of PERSMAX and PERS_IS_UID here to get different
X    behavior from the high score list.
X
X6.  Edit the top section of the src Makefile.  (If you are doing a full
X    recompile, or if you got your files from someplace besides the official
X    distribution, type 'touch makedefs.c' to make sure certain files (onames.h,
X    pm.h) get remade instead of relying on the potentially troublesome
X    timestamps.)  If you elected to use the provided (BSD) random routines,
X    move or link random.c into the src subdirectory from others.  Then type
X    'make' in src and go get a cup of coffee or take a nap.  You should now
X    have created the game executable.
X
X7.  Go back to the main directory and edit that Makefile, explaining where you
X    want everything to be installed.  The Makefile assumes you want to run
X    NetHack setuid 'games' to cut down on possible tampering; it's fairly
X    straightforward to comment out the appropriate chmod if you don't want that,
X    or to change any of the rest of the procedure.  Also edit auxil/nethack.sh
X    at this point.  Type 'make spec_levs' from the main directory to set up
X    files for some of the special levels.  Then become root if necessary and
X    type 'make install'.  Everything should now be set.
X
XNotes:
X
X1.  A number of systems, such as Xenix, support both the termcap and terminfo
X    terminal capability libraries.  Make sure that the TERMINFO definition in
X    config.h and the TERMLIB definition in the source Makefile correspond.
X    If spurious characters appear on the screen while kicking, zapping, etc.,
X    it is likely that you have linked the source to the wrong library or
X    mistakenly defined/undefined TERMINFO.  If your terminal library does not
X    provide suitable delays, NetHack will try to fake its own if you set the
X    nonull option.
X
X2.  Save files and bones files from previous versions will not work with
X    NetHack 3.0.  Don't bother trying to keep them.  Record (score) files
X    from before 3.0 patchlevel 7 will almost work, but you need to make one
X    change manually to them:  At the end of each line is a word or phrase
X    specifying what killed the player.  Change the string to start with the
X    words "killed by", "killed by a", or "killed by an" (whichever is
X    appropriate).  If the death was petrification, it should read "petrified
X    by" instead of "killed by".  Don't change "starvation", "quit", "escaped",
X    or "ascended".
X
X3.  If you insisted on doing the final installation by hand, you probably
X    forgot to make a save directory.  If you don't go back and do this, you
X    won't be able to save games.
X
X4.  To install an update of this version of NetHack after changing something,
X    type 'make update' from the main directory.  If you created the new
X    version yourself, it should be safe to use 'make update' as long as you
X    did not add, delete, or reorder monsters or objects and you did not change
X    the format of saved level files.  If you did any of these things, you
X    should also remove any saved games and bones levels.  (Trying to use such
X    files often produces amusing but useless confusions on the game's part.)
X
X5.  Xenix/286's lex generates a faulty lexical analyser from lev_comp.l.
X    The beta-release of flex 2.1 (avaliable from uunet, osu-cis,
X    prep.ai.mit.edu, etc.) can be used to generate the lexer.
X    The only change to flex is to change "#define yyleng (yy_cp - yy_bp)"
X    to "#define yyleng (int)(yy_cp - yy_bp)" in flex.skel.
X    Flex is not needed with Xenix/386, as its lex generates a proper lexical
X    analyser.  [Xenix instructions by J.T. Conklin]
X
X6.  If you get unexplained deaths by trickery, you are probably running
X    NetHack on a bunch of workstations, but you have overlooked the NETWORK
X    definition in unixconf.h that is necessary in that configuration.
X
X7.  If you are trying to compile NetHack on an AT&T 3B that is running an
X    OS earlier than SVR3, you are likely to have problems with overflowing
X    symbol tables.  This can be worked around by editing the source Makefile
X    to make the Sys.3B2 target work more like the SysV-AT target, adding
X    -DDUMB to CFLAGS and DUMB.Setup to the Sys.3B2 dependency line.  The
X    compiler provided with later versions of the OS has a large enough
X    symbol table that it does not need this workaround.
X
X8.  If NetHack seems to compile fine, starts up, allows you to pick a
X    character, and then either hangs or gets a segmentation fault, you
X    should try changing the schar and uchar definitions in config.h to
X    short ints.  This problem is known to occur on the AT&T 3B series,
X    Silicon Graphics Irises, and IBM PC/RT's running AIX, and may occur
X    on other computers as well.
END_OF_FILE
if test 6390 -ne `wc -c <'Install.unix'`; then
    echo shar: \"'Install.unix'\" unpacked with wrong size!
fi
# end of 'Install.unix'
fi
if test -f 'amiga/amimenu.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'amiga/amimenu.c'\"
else
echo shar: Extracting \"'amiga/amimenu.c'\" \(5890 characters\)
sed "s/^X//" >'amiga/amimenu.c' <<'END_OF_FILE'
X/*
X *  amimenu.c	    (C) Copyright 1989 by Olaf Seibert (KosmoSoft)
X *
X *  Originally by John Toebes.
X */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#define TEXT(nam,str) \
Xstatic struct IntuiText nam = \
X  {0,1,JAM2,0,0,0L,(UBYTE*)str,0L}
X
X	/* Commands */
X	TEXT(T_HELP,  "?   Display help menu");
X	TEXT(T_amp,   "&   Explain a command");
X	TEXT(T_O,     "O   Set options");
X	TEXT(T_SHELL, "!   AmigaDos commands");
X	TEXT(T_v,     "v   Version number");
X	TEXT(T_CR,    "^R  Redraw screen");
X	TEXT(T_CP,    "^P  Repeat last message");
X	TEXT(T_Q,     "Q   Quit game");
X	TEXT(T_S,     "S   Save the game");
X
X	/* Inventory */
X	TEXT(T_i,     "i   Inventory");
X	TEXT(T_p,     "p   Pay your bill");
X	TEXT(T_d,     "d   Drop an object");
X	TEXT(T_D,     "D   Drop several things");
X	TEXT(T_COMMA, ",   Pickup an object");
X	TEXT(T_AT,    "@   Toggle pickup");
X	TEXT(T_SLASH, "/   Identify something");
X	TEXT(T_C,     "C   Christen a monster");
X
X	/* Actions */
X	TEXT(T_a,     "a   Apply/use something");
X	TEXT(T_e,     "e   Eat something");
X	TEXT(T_q,     "q   Quaff a potion");
X	TEXT(T_r,     "r   Read scroll/book");
X	TEXT(T_t,     "t   Throw/shoot weapon");
X	TEXT(T_z,     "z   Zap a wand");
X	TEXT(T_Z,     "Z   Cast a spell");
X	TEXT(T_HASH,  "#   Extended command");
X
X	/* Preparations */
X	TEXT(T_w,     "w   Wield a weapon");
X	TEXT(T_P,     "P   Put on ring");
X	TEXT(T_R,     "R   Remove ring");
X	TEXT(T_T,     "T   Take off armor");
X	TEXT(T_W,     "W   Wear armor");
X	TEXT(T_WPN,   ")   Current weapon");
X	TEXT(T_ARMOR, "[   Current armor");
X	TEXT(T_RING,  "=   Current rings");
X	TEXT(T_AMU,  "\"   Current amulet");
X	TEXT(T_TOOL,  "(   Current tools");
X
X	/* Movement */
X	TEXT(T_o,     "o   Open door");
X	TEXT(T_c,     "c   Close door");
X	TEXT(T_KICK,  "^D  Kick door");
X	TEXT(T_s,     "s   Search");
X	TEXT(T_UP,    "<   Go up stairs");
X	TEXT(T_DOWN,  ">   Go down stairs");
X	TEXT(T_CT,    "^T  Teleport");
X	TEXT(T_WAIT,  ".   Wait a moment");
X	TEXT(T_E,     "E   Engrave msg on floor");
X
X#define IFLAGS ITEMENABLED|ITEMTEXT|HIGHCOMP
X#define IDATA(cmd,str,off) 0,off,WDT,9,IFLAGS,0,(APTR)&str,NULL,cmd,0L,0
X
X/* Commands */
X
X#undef	WDT
X#define WDT 184
X
Xstatic struct MenuItem cmdsub[] = {
X    { &cmdsub[1], IDATA('?', T_HELP,   0) }, /*   Display help */
X    { &cmdsub[2], IDATA('&', T_amp,   10) }, /*   Explain a command */
X    { &cmdsub[3], IDATA('O', T_O,     20) }, /*   Set options */
X    { &cmdsub[4], IDATA('!', T_SHELL, 30) }, /*   AmigaDos commands */
X    { &cmdsub[5], IDATA('v', T_v,     40) }, /*   Version number */
X    { &cmdsub[6], IDATA(022, T_CR,    50) }, /*R  Redraw screen */
X    { &cmdsub[7], IDATA(020 ,T_CP,    60) }, /*P  Repeat last message */
X    { &cmdsub[8], IDATA('Q', T_Q,     70) }, /*   Quit game */
X    { NULL,	  IDATA('S', T_S,     80) }, /*   Save the game */
X};
X
X/* Inventory */
X
X#undef	WDT
X#define WDT 184
X
Xstatic struct MenuItem invsub[] = {
X    { &invsub[1], IDATA('i', T_i,      0) }, /*   Inventory */
X    { &invsub[2], IDATA('p', T_p,     10) }, /*   Pay your bill */
X    { &invsub[3], IDATA('d', T_d,     20) }, /*   Drop an object */
X    { &invsub[4], IDATA('D', T_D,     30) }, /*   Drop several things */
X    { &invsub[5], IDATA(',', T_COMMA, 40) }, /*   Pickup an object */
X    { &invsub[6], IDATA('/', T_SLASH, 50) }, /*   Identify something */
X    { NULL,	  IDATA('C', T_C,     60) }, /*   Christen a monster */
X};
X
X/* Actions */
X
X#undef	WDT
X#define WDT 184
X
Xstatic struct MenuItem actsub[] = {
X    { &actsub[1], IDATA('a', T_a,     0) }, /*   Apply/use something */
X    { &actsub[2], IDATA('e', T_e,    10) }, /*   Eat something */
X    { &actsub[3], IDATA('q', T_q,    20) }, /*   Quaff a potion */
X    { &actsub[4], IDATA('r', T_r,    30) }, /*   Read a scroll/spellbook */
X    { &actsub[5], IDATA('t', T_t,    40) }, /*   Throw/shoot weapon */
X    { &actsub[6], IDATA('z', T_z,    50) }, /*   Zap a wand */
X    { &actsub[7], IDATA('Z', T_Z,    60) }, /*   Cast a spell */
X    { NULL	, IDATA('#', T_HASH, 70) }, /*   Extended command */
X};
X
X/* Preparations */
X
X#undef	WDT
X#define WDT 144
X
Xstatic struct MenuItem armsub[] = {
X    { &armsub[1], IDATA('w', T_w,      0) }, /*   Wield a weapon */
X    { &armsub[2], IDATA('R', T_R,     10) }, /*   Remove ring */
X    { &armsub[3], IDATA('P', T_P,     20) }, /*   Put on ring */
X    { &armsub[4], IDATA('T', T_T,     30) }, /*   Take off armor */
X    { &armsub[5], IDATA('W', T_W,     40) }, /*   Wear armor */
X    { &armsub[6], IDATA(')', T_WPN,   50) }, /*   Current weapon */
X    { &armsub[7], IDATA('[', T_ARMOR, 60) }, /*   Current armor */
X    { &armsub[8], IDATA('=', T_RING,  70) }, /*   Current rings */
X    { &armsub[9], IDATA('"', T_AMU,   80) }, /*   Current amulet */
X    { NULL	, IDATA('(', T_TOOL,  90) }, /*   Current tools */
X};
X
X/* Movement */
X
X#undef	WDT
X#define WDT 192
X
Xstatic struct MenuItem movsub[] = {
X    { &movsub[1], IDATA('o', T_o,     0) }, /*   Open door */
X    { &movsub[2], IDATA('c', T_c,    10) }, /*   Close door */
X    { &movsub[3], IDATA(004, T_KICK, 20) }, /*D  Kick door */
X    { &movsub[4], IDATA('s', T_s,    30) }, /*   Search */
X    { &movsub[5], IDATA('<', T_UP,   40) }, /*   Go up stairs */
X    { &movsub[6], IDATA('>', T_DOWN, 50) }, /*   Go down stairs */
X    { &movsub[7], IDATA(024, T_CT,   60) }, /*T  Teleport */
X    { &movsub[8], IDATA('.', T_WAIT, 70) }, /*   Wait a moment */
X    { NULL	, IDATA('E', T_E,    80) }, /*   Engrave msg on floor */
X};
X
X/* Menustrip */
X
X/* Width = #letters * 8 + 8 + 10 */
X
Xstruct Menu HackMenu[] = {
X   { &HackMenu[1], 10,0, 72,0,MENUENABLED,"Commands",     &cmdsub[0] }, /*8*/
X   { &HackMenu[2], 92,0, 80,0,MENUENABLED,"Inventory",    &invsub[0] }, /*9*/
X   { &HackMenu[3],182,0, 64,0,MENUENABLED,"Actions",      &actsub[0] }, /*7*/
X   { &HackMenu[4],256,0,104,0,MENUENABLED,"Preparations", &armsub[0] }, /*12*/
X   { NULL,	  370,0, 72,0,MENUENABLED,"Movement",     &movsub[0] }, /*8*/
X};
X
END_OF_FILE
if test 5890 -ne `wc -c <'amiga/amimenu.c'`; then
    echo shar: \"'amiga/amimenu.c'\" unpacked with wrong size!
fi
# end of 'amiga/amimenu.c'
fi
if test -f 'amiga/compact.lat' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'amiga/compact.lat'\"
else
echo shar: Extracting \"'amiga/compact.lat'\" \(5512 characters\)
sed "s/^X//" >'amiga/compact.lat' <<'END_OF_FILE'
X;	NetHack header compacting script for Lattice C on Amiga.
X;	SCCS Id: @(#)compact.lat	3.0	90/02/18
X;
X; This script will compact the NetHack header files onto the Ram: disk for
X; Lattice 5.04 on the Amiga.  To use this script, perform the assignments
X; mentioned in Makefile.ami (specifically, assign Incl: to the directory
X; with the NetHack include files).  Make the changes to the header files
X; according to the directions in Install.ami.  Then, invoke this script
X; with:
X;
X;	execute Amiga:compact.lat
X;
X; When completed, this script will have created the directory Ram:Incl
X; which will contain the output from using lcompact on the header files.
X; The script will have also assigned Incl: to Ram:Incl.  The files stored
X; in Ram:Incl will take on the order of 120K.
X;
X; Note:  Using this script effectively causes the entire NetHack source
X; to be re-compiled because the dates on the header files (the lcompact'd
X; versions in Ram:Incl) will be later the any existing object files.
X; This is inconsequential for the first compile, however, since everything
X; needs to be compiled anyway.  The time savings are significant.  For
X; subsequent compiles (for anyone making custom changes), this problem
X; can be circumvented by copying the contents of Ram:Incl to a more
X; permanant storage device (using copy's clone option).  Changes to the
X; text-editable header files need to be propagated through use of lcompact
X; as appropriate.
X;
X; [For the curious:  Two files (hack.h and system.h) cannot be compacted
X; properly with the version of lcompact that comes with Lattice C 5.04.
X; Constructs like '#define Foo (void)foo' get transformed as if they were
X; '#define Foo(void) foo'.  One file (trap.h) cannot be compacted becuase
X; makedefs needs to read and modify it.  Three files (date.h, onames.h,
X; and pm.h) are created within Makefile.ami by makedefs.]
X
Xmakedir Ram:Incl
Xecho "Compacting amiconf.h"
Xlcompact < Incl:amiconf.h > Ram:Incl/amiconf.h
Xecho "Compacting artifact.h"
Xlcompact < Incl:artifact.h > Ram:Incl/artifact.h
Xecho "Compacting attrib.h"
Xlcompact < Incl:attrib.h > Ram:Incl/attrib.h
Xecho "Compacting color.h"
Xlcompact < Incl:color.h > Ram:Incl/color.h
Xecho "Compacting config.h"
Xlcompact < Incl:config.h > Ram:Incl/config.h
Xecho "Compacting coord.h"
Xlcompact < Incl:coord.h > Ram:Incl/coord.h
Xecho "Compacting decl.h"
Xlcompact < Incl:decl.h > Ram:Incl/decl.h
Xecho "Compacting edog.h"
Xlcompact < Incl:edog.h > Ram:Incl/edog.h
Xecho "Compacting epri.h"
Xlcompact < Incl:epri.h > Ram:Incl/epri.h
Xecho "Compacting eshk.h"
Xlcompact < Incl:eshk.h > Ram:Incl/eshk.h
Xecho "Compacting extern.h"
Xlcompact < Incl:extern.h > Ram:Incl/extern.h
Xecho "Compacting flag.h"
Xlcompact < Incl:flag.h > Ram:Incl/flag.h
Xecho "Compacting func_tab.h"
Xlcompact < Incl:func_tab.h > Ram:Incl/func_tab.h
Xecho "Compacting global.h"
Xlcompact < Incl:global.h > Ram:Incl/global.h
Xecho "Compacting gold.h"
Xlcompact < Incl:gold.h > Ram:Incl/gold.h
Xecho "Compacting lev.h"
Xlcompact < Incl:lev.h > Ram:Incl/lev.h
Xecho "Compacting lev_comp.h"
Xlcompact < Incl:lev_comp.h > Ram:Incl/lev_comp.h
Xecho "Compacting macconf.h"
Xlcompact < Incl:macconf.h > Ram:Incl/macconf.h
Xecho "Compacting mfndpos.h"
Xlcompact < Incl:mfndpos.h > Ram:Incl/mfndpos.h
Xecho "Compacting mkroom.h"
Xlcompact < Incl:mkroom.h > Ram:Incl/mkroom.h
Xecho "Compacting monattk.h"
Xlcompact < Incl:monattk.h > Ram:Incl/monattk.h
Xecho "Compacting mondata.h"
Xlcompact < Incl:mondata.h > Ram:Incl/mondata.h
Xecho "Compacting monflag.h"
Xlcompact < Incl:monflag.h > Ram:Incl/monflag.h
Xecho "Compacting monst.h"
Xlcompact < Incl:monst.h > Ram:Incl/monst.h
Xecho "Compacting monsym.h"
Xlcompact < Incl:monsym.h > Ram:Incl/monsym.h
Xecho "Compacting msdos.h"
Xlcompact < Incl:msdos.h > Ram:Incl/msdos.h
Xecho "Compacting obj.h"
Xlcompact < Incl:obj.h > Ram:Incl/obj.h
Xecho "Compacting objclass.h"
Xlcompact < Incl:objclass.h > Ram:Incl/objclass.h
Xecho "Compacting patchlevel.h"
Xlcompact < Incl:patchlevel.h > Ram:Incl/patchlevel.h
Xecho "Compacting pcconf.h"
Xlcompact < Incl:pcconf.h > Ram:Incl/pcconf.h
Xecho "Compacting permonst.h"
Xlcompact < Incl:permonst.h > Ram:Incl/permonst.h
Xecho "Compacting prop.h"
Xlcompact < Incl:prop.h > Ram:Incl/prop.h
Xecho "Compacting rm.h"
Xlcompact < Incl:rm.h > Ram:Incl/rm.h
Xecho "Compacting sp_lev.h"
Xlcompact < Incl:sp_lev.h > Ram:Incl/sp_lev.h
Xecho "Compacting spell.h"
Xlcompact < Incl:spell.h > Ram:Incl/spell.h
Xecho "Compacting termcap.h"
Xlcompact < Incl:termcap.h > Ram:Incl/termcap.h
Xecho "Compacting tosconf.h"
Xlcompact < Incl:tosconf.h > Ram:Incl/tosconf.h
Xecho "Compacting tradstdc.h"
Xlcompact < Incl:tradstdc.h > Ram:Incl/tradstdc.h
Xecho "Compacting trampoli.h"
Xlcompact < Incl:trampoli.h > Ram:Incl/trampoli.h
Xecho "Compacting unixconf.h"
Xlcompact < Incl:unixconf.h > Ram:Incl/unixconf.h
Xecho "Compacting vault.h"
Xlcompact < Incl:vault.h > Ram:Incl/vault.h
Xecho "Compacting vmsconf.h"
Xlcompact < Incl:vmsconf.h > Ram:Incl/vmsconf.h
Xecho "Compacting wseg.h"
Xlcompact < Incl:wseg.h > Ram:Incl/wseg.h
Xecho "Compacting you.h"
Xlcompact < Incl:you.h > Ram:Incl/you.h
Xecho "Compacting youprop.h"
Xlcompact < Incl:youprop.h > Ram:Incl/youprop.h
Xecho "Copying hack.h"
Xcopy Incl:hack.h Ram:Incl/hack.h
Xecho "Copying system.h"
Xcopy Incl:system.h Ram:Incl/system.h
Xecho "Copying trap.h"
Xcopy Incl:trap.h Ram:Incl/trap.h
Xecho "Creating empty date.h"
Xecho > Ram:Incl/date.h NOLINE
Xecho "Creating empty onames.h"
Xecho > Ram:Incl/onames.h NOLINE
Xecho "Creating empty pm.h"
Xecho > Ram:Incl/pm.h NOLINE
Xecho "Assigning Incl: to Ram:Incl"
Xassign Incl: Ram:Incl
END_OF_FILE
if test 5512 -ne `wc -c <'amiga/compact.lat'`; then
    echo shar: \"'amiga/compact.lat'\" unpacked with wrong size!
fi
# end of 'amiga/compact.lat'
fi
if test -f 'auxil/nethack.6' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'auxil/nethack.6'\"
else
echo shar: Extracting \"'auxil/nethack.6'\" \(5666 characters\)
sed "s/^X//" >'auxil/nethack.6' <<'END_OF_FILE'
X.TH NETHACK 6 "28 March 1989"
X.UC 4
X.SH NAME
Xnethack \- Exploring The Mazes of Menace
X.SH SYNOPSIS
X.B nethack
X[
X.B \-d
X.I directory
X]
X[
X.B \-n
X]
X[
X.B \-[ABCEHKPRSTVW]
X]
X[
X.B \-[DX]
X]
X[
X.B \-u
X.I playername
X]
X[
X.B \-dec
X]
X[
X.B \-ibm
X]
X.br
X.B nethack
X[
X.B \-d
X.I directory
X]
X.B \-s
X[
X.B \-[ABCEHKPRSTVW]
X]
X[
X.I playernames
X]
X.SH DESCRIPTION
X.PP
X.I NetHack
Xis a display oriented Dungeons & Dragons(tm) - like game.
XBoth display and command structure resemble rogue.
X.PP
XTo get started you really only need to know two commands.  The command
X.B ?
Xwill give you a list of the available commands (as well as other information)
Xand the command
X.B /
Xwill identify the things you see on the screen.
X.PP
XTo win the game (as opposed to merely playing to beat other people's high
Xscores) you must locate the Amulet of Yendor which is somewhere below
Xthe 20th level of the dungeon and get it out.
XNobody has achieved this yet; anybody who does will probably go down
Xin history as a hero among heros.
X.PP
XWhen the game ends, whether by your dying, quitting, or escaping
Xfrom the caves,
X.I NetHack
Xwill give you (a fragment of) the list of top scorers.
XThe scoring is based on many aspects of your behavior, but a rough estimate
Xis obtained by taking the amount of gold you've found in the cave plus four
Xtimes your (real) experience.
XPrecious stones may be worth a lot of gold when brought to the exit.
XThere is a 10% penalty for getting yourself killed.
X.PP
XThe environment variable NETHACKOPTIONS can be used to initialize many
Xrun-time options.
XThe ? command provides a description of these options and syntax.
X(The
X.B \-dec
Xand
X.B \-ibm
Xcommand line options are equivalent to the
X.B decgraphics
Xand
X.B ibmgraphics
Xrun-time options described there,
Xand are provided purely for convenience on systems
Xsupporting multiple types of terminals.)
X.PP
XThe
X.B \-u
X.I playername
Xoption supplies the answer to the question "Who are you?".
XIt overrides any name from NETHACKOPTIONS, USER, LOGNAME, or getlogin(),
Xwhich will otherwise be tried in order.
XIf none of these provides a useful name, the player will be asked for one.
XA
X.I playername
Xsuffix or a separate option consisting of one of
X.B "\-A \-B \-C \-E \-H \-K \-P \-R \-S \-T \-V \-W"
Xcan be used to determine the character role.
X.PP
XThe
X.B \-s
Xoption alone will print out the list of your scores.
XIt may be followed by arguments
X.B "\-A \-B \-C \-E \-H \-K \-P \-R \-S \-T \-V \-W"
Xto print the
Xscores of Archeologists, Barbarians, Cave(wo)men, Elves, Healers, Knights,
XPriest(esse)s, Rogues, Samurai, Tourists, Valkyries, or Wizards.
XIt may also be followed by one or more player names to print the scores of the
Xplayers mentioned, or by 'all' to print out all scores.
X.PP
XThe
X.B \-n
Xoption suppresses printing of any news from the game administrator.
X.PP
XThe
X.B \-D
Xor
X.B \-X
Xoption will start the game in a special non-scoring discovery mode.
X.B \-D
Xwill, if the player is the game administrator, start in debugging (wizard)
Xmode instead.
X.PP
XThe
X.B \-d
Xoption, which must be the first argument if it appears,
Xsupplies a directory which is to serve as the playground.
XIt overrides the value from HACKDIR or the directory specified by the game
Xadministrator during compilation (usually /usr/games/lib/nethackdir).
XThis option is usually only useful to the game administrator.
XThe playground must contain several auxiliary files such as help files,
Xthe list of top scorers, and a subdirectory
X.I save
Xwhere games are saved.
X.SH AUTHORS
X.PP
XJay Fenlason (+ Kenny Woodland, Mike Thome and Jon Payne) wrote the
Xoriginal hack, very much like rogue (but full of bugs).
X.PP
XAndries Brouwer continuously deformed their sources into an entirely
Xdifferent game.
X.PP
XMike Stephenson has continued the perversion of sources, adding various
Xwarped character classes and sadistic traps with the help of many strange
Xpeople who reside in that place between the worlds, the Usenet Zone.
XA number of these miscreants are immortalized in the historical
Xroll of dishonor and various other places.
X.PP
XThe resulting mess is now called NetHack, to denote its
Xdevelopment by the Usenet.  Andries Brouwer has made this request for the
Xdistinction, as he may eventually release a new version of his own.
X.SH FILES
X.PP
XAll files are in the playground, normally /usr/games/lib/nethackdir.
X.br
X.DT
X.ta \w'tower1, tower2, tower3\ \ \ 'u
Xnethack		The program itself.
X.br
Xdata, oracles, rumors	Data files used by NetHack.
X.br
Xhelp, hh	Help data files.
X.br
Xcmdhelp, opthelp	More help data files.
X.br
Xcastle, endgame	Predefined special levels.
X.br
Xtower1, tower2, tower3	More special levels.
X.br
Xhistory	A short history of NetHack.
X.br
Xlicense	Rules governing redistribution.
X.br
Xrecord	The list of top scorers.
X.br
Xlogfile	An extended list of games played.
X.br
Xsave	A subdirectory containing the saved
X.br
X	games.
X.br
Xbones.dd	Descriptions of the ghost and
X.br
X	belongings of a deceased
X.br
X	adventurer.
X.br
Xxlock.dd	Description of a dungeon level.
X.br
Xperm, safelock	Lock files for xlock.dd.
X.br
Xrecord_lock	Lock file for record.
X.br
Xlogfile_lock	Lock file for logfile.
X.SH ENVIRONMENT
X.DT
X.ta \w'HACKPAGER or PAGER\ \ \ 'u
XUSER or LOGNAME	Your login name.
X.br
XHOME		Your home directory.
X.br
XSHELL		Your shell.
X.br
XTERM		The type of your terminal.
X.br
XHACKPAGER or PAGER	Replacement for default pager.
X.br
XMAIL	Mailbox file.
X.br
XMAILREADER	Replacement for default reader
X.br
X	(probably /bin/mail or /usr/ucb/mail).
X.br
XHACKDIR	Playground.
X.br
XNETHACKOPTIONS	String predefining several NetHack
X.br
X	options.
X.br
X
XIn addition, SHOPTYPE is used in debugging (wizard) mode.
X.SH BUGS
X.PP
XProbably infinite.
X
X
X.PP
XDungeons & Dragons is a Trademark of TSR Inc.
END_OF_FILE
if test 5666 -ne `wc -c <'auxil/nethack.6'`; then
    echo shar: \"'auxil/nethack.6'\" unpacked with wrong size!
fi
# end of 'auxil/nethack.6'
fi
if test -f 'include/decl.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/decl.h'\"
else
echo shar: Extracting \"'include/decl.h'\" \(5460 characters\)
sed "s/^X//" >'include/decl.h' <<'END_OF_FILE'
X/*	SCCS Id: @(#)decl.h	3.0	88/10/24
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#ifndef DECL_H
X#define DECL_H
X
X#define E extern
X
XE int NEARDATA bases[];
XE int NEARDATA warnlevel;	/* defined in mon.c */
XE int NEARDATA occtime;
XE int NEARDATA nroom;
XE int NEARDATA multi;
XE int hackpid;
X#if defined(UNIX) || defined(VMS)
XE int locknum;
X#endif
X#ifdef DEF_PAGER
XE char *catmore;
X#endif	/* DEF_PAGER */
XE char SAVEF[];
XE const char *hname;
XE const char *hu_stat[];	/* defined in eat.c */
XE int NEARDATA medusa_level;
XE int NEARDATA bigroom_level;
X#ifdef REINCARNATION
XE int NEARDATA rogue_level;
X#endif
X#ifdef ORACLE
XE int NEARDATA oracle_level;
X#endif
X#ifdef STRONGHOLD
XE int NEARDATA stronghold_level, NEARDATA tower_level;
X#endif
XE int NEARDATA wiz_level;
XE boolean NEARDATA is_maze_lev;
X
XE xchar NEARDATA xdnstair, NEARDATA ydnstair, NEARDATA xupstair,
X	NEARDATA  yupstair; /* stairs up and down. */
X#ifdef STRONGHOLD
XE xchar NEARDATA xdnladder, NEARDATA ydnladder, NEARDATA xupladder,
X	NEARDATA yupladder; /* ladders up and down. */
X#endif
XE xchar NEARDATA scrlx, NEARDATA scrhx, NEARDATA scrly, NEARDATA scrhy;
X	 /* corners of new area on screen. pri.c */
XE xchar NEARDATA dlevel;
XE xchar NEARDATA maxdlevel; /* dungeon level */
XE int NEARDATA done_stopprint;
XE int NEARDATA done_hup;
XE xchar NEARDATA curx,NEARDATA cury;	/* cursor location on screen */
XE xchar NEARDATA seehx, NEARDATA seelx, NEARDATA seehy, NEARDATA seely;
X	 /* where to see */
XE xchar NEARDATA seehx2, NEARDATA seelx2, NEARDATA seehy2, NEARDATA seely2;
X	 /* where to see */
XE xchar NEARDATA fountsound, NEARDATA sinksound; /* numbers of noisy things */
X
XE char NEARDATA pl_character[PL_CSIZ];
XE const char *pl_classes;
X#ifdef TUTTI_FRUTTI
XE char NEARDATA pl_fruit[PL_FSIZ];
XE int NEARDATA current_fruit;
XE struct fruit NEARDATA *ffruit;
X#endif
X#ifdef STRONGHOLD
XE char NEARDATA tune[6];
X#  ifdef MUSIC
XE schar NEARDATA music_heard;
X#  endif
X#endif
X
XE const char NEARDATA quitchars[];
XE const char NEARDATA vowels[];
XE const char NEARDATA ynchars[];
XE const char NEARDATA ynqchars[];
XE const char NEARDATA ynaqchars[];
XE const char NEARDATA nyaqchars[];
XE int NEARDATA smeq[];
XE int NEARDATA doorindex;
XE char NEARDATA *save_cm;
X#define KILLED_BY_AN 0
X#define KILLED_BY 1
X#define NO_KILLER_PREFIX 2
XE int NEARDATA killer_format;
XE const char NEARDATA *killer;
XE char inv_order[];
XE char NEARDATA plname[PL_NSIZ];
XE char NEARDATA dogname[];
XE char NEARDATA catname[];
XE const char NEARDATA sdir[], NEARDATA ndir[];	/* defined in cmd.c */
XE const char NEARDATA *occtxt;		/* defined when occupation != NULL */
XE const char NEARDATA *nomovemsg;
XE const char NEARDATA nul[];
XE char *HI, *HE, *AS, *AE;	/* set up in termcap.c */
XE char *CD;			/* set up in termcap.c */
XE int CO, LI;			/* set up in termcap.c: COLNO and ROWNO+3 */
XE const char *traps[];
X#ifndef MAKEDEFS_C  /* avoid conflict with lock() */
XE char lock[];
X#endif
XE char morc;
X
XE const schar NEARDATA xdir[], NEARDATA ydir[];	/* idem */
XE schar NEARDATA tbx, NEARDATA tby;		/* set in mthrowu.c */
XE int NEARDATA dig_effort;	/* apply.c, hack.c */
XE uchar NEARDATA dig_level;
XE coord NEARDATA dig_pos;
XE boolean NEARDATA dig_down;
X
XE long NEARDATA moves, NEARDATA monstermoves;
XE long NEARDATA wailmsg;
X
XE boolean NEARDATA in_mklev;
XE boolean NEARDATA stoned;
XE boolean NEARDATA unweapon;
XE boolean NEARDATA mrg_to_wielded;
X
X#ifdef KOPS
XE boolean NEARDATA allow_kops;
X#endif
X
X#ifdef SPELLS
X#ifndef SPELLS_H
X#include "spell.h"
X#endif
XE struct spell NEARDATA spl_book[];	/* sized in decl.c */
X#endif
X
X#ifdef REDO
XE int NEARDATA in_doagain;
X#endif
X
X#ifdef CLIPPING
XE boolean clipping;
XE int clipx, clipy, clipxmax, clipymax;
X#endif
X
X#ifdef TEXTCOLOR
X#ifndef COLOR_H
X#include "color.h"
X#endif
X# ifdef TOS
XE const char *hilites[MAXCOLORS];
X# else
XE char NEARDATA *hilites[MAXCOLORS];
X# endif
X#endif
X
X#ifndef OBJ_H
X#include "obj.h"
X#endif
X
XE struct obj NEARDATA *invent, NEARDATA *uarm, NEARDATA *uarmc,
X	NEARDATA *uarmh, NEARDATA *uarms, NEARDATA *uarmg, NEARDATA *uarmf,
X#ifdef SHIRT
X	NEARDATA *uarmu, /* under-wear, so to speak */
X#endif
X#ifdef POLYSELF
X	NEARDATA *uskin,
X#endif
X	NEARDATA *uamul, NEARDATA *uleft, NEARDATA *uright, NEARDATA *ublindf,
X	NEARDATA *fcobj, NEARDATA *uwep;
X
XE struct obj NEARDATA *uchain;	/* defined iff PUNISHED */
XE struct obj NEARDATA *uball;	/* defined if PUNISHED */
X
X#ifndef YOU_H
X#include "you.h"
X#endif
X
XE struct you NEARDATA u;
X
X#ifndef MAKEDEFS_C
X#ifndef ONAMES_H
X#include "onames.h"
X#endif
X#ifndef PM_H
X#include "pm.h"
X#endif
X#endif /* MAKEDEFS_C */
X
XE struct permonst NEARDATA playermon, NEARDATA *uasmon;
X					/* also decl'd extern in permonst.h */
X					/* init'd in monst.c */
XE struct obj NEARDATA zeroobj;		/* init'd and defined in decl.c */
X
XE struct monst NEARDATA youmonst;	/* init'd and defined in decl.c */
X
XE const char obj_symbols[];		/* init'd in objects.h */
X
XE struct obj *billobjs;
X
XE const char black[];
XE const char amber[];
X#ifdef THEOLOGY
XE const char golden[];
X#endif
XE const char light_blue[];
XE const char red[];
XE const char green[];
XE const char silver[];
XE const char blue[];
XE const char purple[];
XE const char white[];
X
XE const char nothing_happens[];
XE const char thats_enough_tries[];
X
XE const char monsyms[], objsyms[];
XE const char *monexplain[], *objexplain[];
X
X#ifdef NAMED_ITEMS
XE const int artifact_num;
XE boolean artiexist[];
X#endif
X
X#undef E
X
X#endif /* DECL_H /**/
END_OF_FILE
if test 5460 -ne `wc -c <'include/decl.h'`; then
    echo shar: \"'include/decl.h'\" unpacked with wrong size!
fi
# end of 'include/decl.h'
fi
if test -f 'include/hack.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/hack.h'\"
else
echo shar: Extracting \"'include/hack.h'\" \(3395 characters\)
sed "s/^X//" >'include/hack.h' <<'END_OF_FILE'
X/*	SCCS Id: @(#)hack.h	3.0	88/07/19
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#ifndef HACK_H
X#define HACK_H
X
X#ifndef CONFIG_H
X#include "config.h"
X#endif
X
X#define	TELL		1
X#define NOTELL		0
X#define ON 		1
X#define OFF 		0
X#define	BOLT_LIM    8	/* from this distance ranged attacks will be made */
X#ifdef HARD
X#define	MAX_CARR_CAP	120	/* so that boulders can be heavier */
X#else
X#define	MAX_CARR_CAP	500
X#endif
X#define	FAR	(COLNO+2)	/* position outside screen */
X#ifdef NULL
X#undef NULL
X#endif /* NULL */
X#define NULL  ((genericptr_t)0)
X#define DUMMY { 0 }
X
X/* this is the way the game ends */
X/* if these are rearranged, the arrays in end.c will need to be changed */
X#define DIED		0
X#define CHOKING 	1
X#define POISONING	2
X#define STARVING	3
X#define DROWNING	4
X#define BURNING 	5
X#define CRUSHING	6
X#define STONING 	7
X#define GENOCIDED	8
X#define PANICKED	9
X#define TRICKED 	10
X#define QUIT		11
X#define ESCAPED 	12
X#ifdef ENDGAME
X#define ASCENDED	13
X#endif
X
X#ifndef DECL_H
X#include "decl.h"
X#endif
X
X#ifndef MONSYM_H
X#include 	"monsym.h"
X#endif
X#ifndef MKROOM_H
X#include	"mkroom.h"
X#endif
X#ifndef OBJCLASS_H
X#include	"objclass.h"
X#endif
X
Xextern coord bhitpos;	/* place where thrown weapon falls to the ground */
X
X#ifndef GOLD_H
X#include	"gold.h"
X#endif
X#ifndef TRAP_H
X#include	"trap.h"
X#endif
X#ifndef FLAG_H
X#include	"flag.h"
X#endif
X
X#ifndef RM_H
X#include	"rm.h"
X#endif
X
X#ifdef OVERLAY	/* This doesn't belong here, but we have little choice */
X#undef NDECL
X#define NDECL(f) f()
X#endif
X
X#ifndef EXTERN_H
X#include	"extern.h"
X#endif
X
X#ifdef OVERLAY
X#ifndef TRAMPOLI_H
X#include	"trampoli.h"
X#endif
X
X#undef EXTERN_H
X#include	"extern.h"
X#endif /* OVERLAY */
X
X
X#ifdef STRONGHOLD
X# define Inhell		(dlevel > stronghold_level && dlevel <= MAXLEVEL)
X#else
X# define Inhell 	(dlevel >= HELLLEVEL)
X#endif
X
X#ifdef SPELLS
X#define	NO_SPELL	0
X#endif
X
X/*** some utility macros ***/
X# ifndef STUPID_CPP	/* otherwise these macros are functions in hack.c */
X#define yn() yn_function(ynchars, 'n')
X#define ynq() yn_function(ynqchars, 'q')
X#define ynaq() yn_function(ynaqchars, 'y')
X#define nyaq() yn_function(nyaqchars, 'n')
X
X#define max(a, b) ((a) > (b) ? (a) : (b))
X#define min(x,y) ((x) < (y) ? (x) : (y))
X#define	plur(x)	(((x) == 1) ? "" : "s")
X
X#define	makeknown(x)	objects[x].oc_name_known = 1
X# endif /* STUPID_CPP */
X
X#if defined(MSDOS) || defined(MACOS)
X#define getuid() 1
X#define getlogin() ((char *) NULL)
X#endif /* MSDOS */
X
X/* Macro for a few items that are only static if we're not overlaid.... */
X#if defined(OVERLAY)
X# define STATIC_PTR
X#else
X# define STATIC_PTR static
X#endif
X
X#if defined(OVERLAY) && (defined(OVL0) || defined(OVL1) || defined(OVL2) || defined(OVL3) || defined(OVLB))
X# define STATIC_DCL extern
X# define STATIC_OVL
X# ifdef OVLB
X#  define STATIC_VAR
X# else
X#  define STATIC_VAR extern
X# endif
X#else
X# define STATIC_DCL static
X# define STATIC_OVL static
X# define STATIC_VAR static
X#endif
X
X/* Unless explicit control is being taken of what is linked where, */
X/* always compile everything */
X#if !defined(OVERLAY) || (!defined(OVL0) && !defined(OVL1) && !defined(OVL2) && !defined(OVL3) && !defined(OVLB))
X# define OVL0  /* Highest priority */
X# define OVL1
X# define OVL2
X# define OVL3  /* Lowest specified priority */
X# define OVLB  /* The base overlay segment */
X#endif
X
X#endif /* HACK_H /**/
END_OF_FILE
if test 3395 -ne `wc -c <'include/hack.h'`; then
    echo shar: \"'include/hack.h'\" unpacked with wrong size!
fi
# end of 'include/hack.h'
fi
if test -f 'include/monflag.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/monflag.h'\"
else
echo shar: Extracting \"'include/monflag.h'\" \(5432 characters\)
sed "s/^X//" >'include/monflag.h' <<'END_OF_FILE'
X/*	SCCS Id: @(#)monflag.h	3.0	89/11/21
X/* NetHack may be freely redistributed.  See license for details. */
X/* Copyright (c) 1989 Mike Threepoint */
X
X#ifndef MONFLAG_H
X#define MONFLAG_H
X
X#define MS_SILENT	0	/* makes no sound */
X#define MS_SQEEK	1	/* squeaks, as a rodent */
X#define MS_SQAWK	2	/* squawks, as a bird */
X#define MS_HISS 	3	/* hisses */
X#define MS_BUZZ 	4	/* buzzes (killer bee) */
X#define MS_GRUNT	5	/* grunts (or speaks own language) */
X#define MS_GROWL	6	/* growls */
X#define MS_BARK 	7	/* if full moon, may howl */
X#define MS_MEW		8	/* mews or hisses */
X#define MS_ROAR 	9	/* roars */
X#define MS_NEIGH	10	/* neighs, as an equine */
X#define MS_WAIL 	11	/* wails, as a tortured soul */
X#define MS_GURGLE	12	/* gurgles, as liquid or through saliva */
X#define MS_BURBLE	13	/* burbles (jabberwock) */
X#define MS_SHRIEK	15	/* wakes up others */
X#define MS_LAUGH	17	/* grins, smiles, giggles, and laughs */
X#define MS_MUMBLE	18	/* says something or other */
X#define MS_IMITATE	19	/* imitates others (leocrotta) */
X#define MS_SEDUCE	20	/* "Hello, sailor." (Nymphs) */
X#define MS_VAMPIRE	21	/* vampiric seduction, Vlad's exclamations */
X#define MS_ORC		MS_GRUNT	/* intelligent brutes */
X#ifdef INFERNO
X#define MS_BRIBE	25	/* asks for money, or berates you */
X#endif
X#define MS_CUSS 	26	/* berates (demons) or intimidates (Wiz) */
X#define MS_NURSE	27	/* "Take off your shirt, please." */
X#define MS_DJINNI	28	/* "Thank you for freeing me!" */
X#define MS_HUMANOID	29	/* generic traveling companion */
X#define MS_GUARD	30	/* "Please drop that gold and follow me." */
X#define MS_SELL 	31	/* demand payment, complain about shoplifters */
X#ifdef ORACLE
X#define MS_ORACLE	32	/* do a consultation */
X#endif
X#ifdef ALTARS
X#define MS_PRIEST	33	/* ask for contribution; do cleansing */
X#endif
X#ifdef KOPS
X#define MS_ARREST	34	/* "Stop in the name of the law!" (Kops) */
X#endif
X#ifdef ARMY
X#define MS_SOLDIER	35	/* army expressions */
X#endif
X
X#define M1_FLY		0x00000001L	/* can fly or float */
X#define M1_SWIM 	0x00000002L	/* can traverse water */
X#define M1_AMORPHOUS	0x00000004L	/* can flow under doors */
X#define M1_WALLWALK	0x00000008L	/* can phase thru rock */
X#define M1_TUNNEL	0x00000010L	/* can tunnel thru rock */
X#define M1_NEEDPICK	0x00000020L	/* needs pick to tunnel */
X#define M1_CONCEAL	0x00000040L	/* hides under objects */
X#define M1_HIDE 	0x00000080L	/* mimics, blends in with ceiling */
X#define M1_NOEYES	0x00000100L	/* no eyes to gaze into or blind */
X#define M1_NOHANDS	0x00000200L	/* no hands to handle things */
X#define M1_NOLIMBS	0x00000600L	/* no arms/legs to kick/wear on */
X#define M1_NOPOLY	0x00000800L	/* players mayn't poly into one */
X#define M1_HUMANOID	0x00001000L	/* has humanoid body */
X#define M1_ANIMAL	0x00002000L	/* has animal body */
X#define M1_SLITHY	0x00004000L	/* has serpent body */
X#define M1_THICK_HIDE	0x00008000L	/* has thick hide or scales */
X#define M1_FIRE_RES	0x00010000L	/* resists fire */
X#define M1_SLEE_RES	0x00020000L	/* resists sleep */
X#define M1_COLD_RES	0x00040000L	/* resists cold */
X#define M1_ELEC_RES	0x00080000L	/* resists electricity */
X#define M1_STON_RES	0x00100000L	/* resists stoning */
X#define M1_ACID 	0x00200000L	/* acidic to eat */
X#define M1_POIS_RES	0x00400000L	/* resists poison */
X#define M1_POIS 	0x00800000L	/* poisonous to eat */
X#define M1_REGEN	0x01000000L	/* regenerates hit points */
X#define M1_SEE_INVIS	0x02000000L	/* can see invisible creatures */
X#define M1_TPORT	0x04000000L	/* can teleport */
X#define M1_TPORT_CONTROL 0x08000000L	/* controls where it teleports to */
X#define M1_GREEDY	0x10000000L	/* likes gold */
X#define M1_JEWELS	0x20000000L	/* likes gems */
X#define M1_COLLECT	0x40000000L	/* picks up weapons and food */
X#define M1_MAGIC	0x80000000L	/* picks up magic items */
X
X#define M2_UNDEAD	0x00000001L	/* walking dead */
X#define M2_WERE 	0x00000002L	/* lycanthrope */
X#define M2_ELF		0x00000010L	/* is an elf */
X#define M2_DWARF	0x00000020L	/* is a dwarf */
X#define M2_GIANT	0x00000040L	/* is a giant */
X#define M2_ORC		0x00000080L	/* is an orc */
X#define M2_HUMAN	0x00000100L	/* is a human */
X#define M2_DEMON	0x00000200L	/* is a demon */
X#define M2_MERC 	0x00000400L	/* is a guard or soldier */
X#define M2_FEM		0x00000800L	/* characteristically female */
X#define M2_WANDER	0x00001000L	/* wanders randomly */
X#define M2_STALK	0x00002000L	/* follows you to other levels */
X#define M2_DOMESTIC	0x00004000L	/* can be tamed by feeding */
X#define M2_HOSTILE	0x00010000L	/* always starts hostile */
X#define M2_PEACEFUL	0x00020000L	/* always starts peaceful */
X#define M2_NASTY	0x00040000L	/* extra-nasty monster (more xp) */
X#define M2_STRONG	0x00080000L	/* strong (or big) monster */
X#define M2_CARNIVORE	0x00100000L	/* eats corpses */
X#define M2_HERBIVORE	0x00200000L	/* eats fruits */
X#define M2_OMNIVORE	0x00300000L	/* eats both */
X#define M2_METALLIVORE	0x00400000L	/* eats metal */
X#define M2_EGGS 	0x01000000L	/* lays eggs */
X#define M2_ROCKTHROW	0x04000000L	/* throws boulders */
X#define M2_PNAME	0x20000000L	/* monster name is a proper name */
X#define M2_LORD 	0x40000000L	/* a lord to its kind */
X#define M2_PRINCE	0x80000000L	/* an overlord to its kind */
X
X#define MZ_TINY		0		/* < 2' */
X#define MZ_SMALL 	1		/* 2-4' */
X#define MZ_MEDIUM	2		/* 4-7' */
X#define MZ_HUMAN	MZ_MEDIUM	/* human-sized */
X#define MZ_LARGE 	3		/* 7-12' */
X#define MZ_HUGE		4		/* 12-25' */
X#define MZ_GIGANTIC	7		/* off the scale */
X
X#endif /* MONFLAG_H */
END_OF_FILE
if test 5432 -ne `wc -c <'include/monflag.h'`; then
    echo shar: \"'include/monflag.h'\" unpacked with wrong size!
fi
# end of 'include/monflag.h'
fi
if test -f 'include/trampoli.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/trampoli.h'\"
else
echo shar: Extracting \"'include/trampoli.h'\" \(5607 characters\)
sed "s/^X//" >'include/trampoli.h' <<'END_OF_FILE'
X/*	SCCS Id: @(#)trampoli.h 	3.0	90/05/31	  */
X/* Copyright (c) 1989, by Norm Meluch and Stephen Spackman	  */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#ifndef TRAMPOLI_H
X#define TRAMPOLI_H
X
X#ifdef OVERLAY
X
X/* ### apply.c ### */
X#define dig()     dig_()
X#define doapply() doapply_()
X#define dojump()  dojump_()
X#define dorub()   dorub_()
X
X
X/* ### cmd.c ### */
X#define doextcmd()         doextcmd_()
X#define doextlist()        doextlist_()
X#ifdef POLYSELF
X#define domonability()     domonability_()
X#endif /* POLYSELF */
X#ifdef EXPLORE_MODE
X#define enter_explore_mode() enter_explore_mode_()
X#endif /* EXPLORE_MODE */
X#define timed_occupation() timed_occupation_()
X#if defined(WIZARD) || defined(EXPLORE_MODE)
X#define wiz_attributes()   wiz_attributes_()
X#endif
X#ifdef WIZARD
X#define wiz_detect()       wiz_detect_()
X#define wiz_genesis()      wiz_genesis_()
X#define wiz_identify()     wiz_identify_()
X#define wiz_level_tele()   wiz_level_tele_()
X#define wiz_map()          wiz_map_()
X#define wiz_where()        wiz_where_()
X#define wiz_wish()         wiz_wish_()
X#endif
X
X
X/* ### do.c ### */
X#define doddrop()  doddrop_()
X#define dodown()   dodown_()
X#define dodrop()   dodrop_()
X#define donull()   donull_()
X#define doup()     doup_()
X#define dowipe()   dowipe_()
X#define drop(x)    drop_(x)
X#define wipeoff()  wipeoff_()
X
X
X/* ### do_name.c ### */
X#define ddocall()  ddocall_()
X#define do_mname() do_mname_()
X
X
X/* ### do_wear.c ### */
X#define Armor_off()   Armor_off_()
X#define Boots_off()   Boots_off_()
X#define Gloves_off()  Gloves_off_()
X#define Helmet_off()  Helmet_off_()
X#define Armor_on()    Armor_on_()
X#define Boots_on()    Boots_on_()
X#define Gloves_on()   Gloves_on_()
X#define Helmet_on()   Helmet_on_()
X#define doddoremarm() doddoremarm_()
X#define doputon()     doputon_()
X#define doremring()   doremring_()
X#define dotakeoff()   dotakeoff_()
X#define dowear()      dowear_()
X#define select_off(x) select_off_(x)
X#define take_off()    take_off_()
X
X
X/* ### dokick.c ### */
X#define dokick() dokick_()
X
X
X/* ### dothrow.c ### */
X#define dothrow() dothrow_()
X
X
X/* ### eat.c ### */
X#define Hear_again() Hear_again_()
X#define Meatdone()   Meatdone_()
X#define doeat()      doeat_()
X#define eatfood()    eatfood_()
X#define opentin()    opentin_()
X#define unfaint()    unfaint_()
X
X
X/* ### end.c ### */
X#define done1()     done1_()
X#define done2()     done2_()
X#define hangup()    hangup_()
X#define done_intr() done_intr_()
X#if defined(UNIX) || defined (VMS)
X#define done_hangup() done_hangup_()
X#endif /* UNIX || VMS */
X
X
X/* ### engrave.c ### */
X#define doengrave() doengrave_()
X
X
X/* ### hack.c ### */
X#define dopickup() dopickup_()
X#define identify(x) identify_(x)
X
X
X/* ### invent.c ### */
X#define ckunpaid(x)  ckunpaid_(x)
X#define ddoinv()     ddoinv_()
X#define dolook()     dolook_()
X#define dopramulet() dopramulet_()
X#define doprarm()    doprarm_()
X#define doprgold()   doprgold_()
X#define doprring()   doprring_()
X#define doprtool()   doprtool_()
X#define doprwep()    doprwep_()
X#define dotypeinv()  dotypeinv_()
X
X
X/* ### ioctl.c ### */
X#ifdef UNIX
X# ifdef SUSPEND
X#define dosuspend() dosuspend_()
X# endif /* SUSPEND */
X#endif /* UNIX */
X
X
X/* ### lock.c ### */
X#define doclose()   doclose_()
X#define doforce()   doforce_()
X#define doopen()    doopen_()
X#define forcelock() forcelock_()
X#define picklock()  picklock_()
X
X
X/* ### mklev.c ### */
X#define comp(x, y)  comp_(x, y)
X
X
X/* ### mondata.c ### */
X/* See comment in trampoli.c before uncommenting canseemon. */
X/* #define canseemon(x)	canseemon_(x) */
X
X
X/* ### o_init.c ### */
X#define dodiscovered() dodiscovered_()
X
X
X/* ### objnam.c ### */
X#define doname(x)   doname_(x)
X#define xname(x)    xname_(x)
X
X/* ### options.c ### */
X#define doset()          doset_()
X#define dotogglepickup() dotogglepickup_()
X
X
X/* ### pager.c ### */
X#define dohelp()     dohelp_()
X#define dohistory()  dohistory_()
X#ifdef UNIX
X#define intruph()    intruph_()
X# ifdef SHELL
X#define dosh()       dosh_()
X# endif /* SHELL */
X#endif /* UNIX */
X#define dowhatdoes() dowhatdoes_()
X#define dowhatis()   dowhatis_()
X
X
X/* ### pickup.c ### */
X#define ck_bag(x)        ck_bag_(x)
X#define ck_container(x)  ck_container_(x)
X#define doloot()         doloot_()
X#define in_container(x)  in_container_(x)
X#define out_container(x) out_container_(x)
X
X
X/* ### potion.c ### */
X#define dodrink() dodrink_()
X#define dodip()   dodip_()
X
X
X/* ### pray.c ### */
X#ifdef THEOLOGY
X#define dopray()      dopray_()
X#define dosacrifice() dosacrifice_()
X#endif /* THEOLOGY */
X#define doturn()      doturn_()
X
X
X/* ### pri.c ### */
X#define doredraw() doredraw_()
X
X
X/* ### read.c ### */
X#define doread() doread_()
X
X
X/* ### save.c ### */
X#define dosave() dosave_()
X
X
X/* ### search.c ### */
X#define doidtrap() doidtrap_()
X#define dosearch() dosearch_()
X
X
X/* ### shk.c ### */
X#define dopay() dopay_()
X
X
X/* ### sit.c ### */
X#define dosit() dosit_()
X
X
X/* ### sounds.c ### */
X#define dotalk() dotalk_()
X
X
X/* ### spell.c ### */
X#ifdef SPELLS
X#define learn()    learn_()
X#define docast()   docast_()
X#define dovspell() dovspell_()
X#endif
X
X
X/* ### steal.c ### */
X#define stealarm() stealarm_()
X
X
X/* ### topl.c ### */
X#define doredotopl() doredotopl_()
X
X/* ### trap.c ### */
X#define dotele()     dotele_()
X#define dountrap()   dountrap_()
X#define float_down() float_down_()
X
X/* ### version.c ### */
X#define doversion()    doversion_()
X#define doextversion() doextversion_()
X
X/* ### wield.c ### */
X#define dowield() dowield_()
X
X/* ### zap.c ### */
X#define bhitm(x, y) bhitm_(x, y)
X#define bhito(x, y) bhito_(x, y)
X#define dozap()     dozap_()
X
X#endif /* OVERLAY */
X
X#endif /* TRAMPOLI_H */
END_OF_FILE
if test 5607 -ne `wc -c <'include/trampoli.h'`; then
    echo shar: \"'include/trampoli.h'\" unpacked with wrong size!
fi
# end of 'include/trampoli.h'
fi
if test -f 'include/unixconf.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/unixconf.h'\"
else
echo shar: Extracting \"'include/unixconf.h'\" \(6113 characters\)
sed "s/^X//" >'include/unixconf.h' <<'END_OF_FILE'
X/*	SCCS Id: @(#)unixconf.h	3.0	88/07/21
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#ifdef UNIX
X#ifndef UNIXCONF_H
X#define UNIXCONF_H
X
X/*
X * Some include files are in a different place under SYSV
X * 	BSD		   SYSV
X * <sys/time.h>		<time.h>
X * <sgtty.h>		<termio.h>
X *
X * Some routines are called differently
X * index		strchr
X * rindex		strrchr
X *
X */
X
X/* define one of the following */
X/* #define BSD		/* define for 4.n BSD  */
X			/* also for relatives like SunOS and DG/UX */
X#define ULTRIX		/* define for Ultrix v3.0 or higher (but not lower) */
X			/* Use BSD for < v3.0 */
X			/* "ULTRIX" not to be confused with "ultrix" */
X/* #define SYSV		/* define for System V */
X/* #define HPUX		/* Hewlett-Packard's Unix, version 6.5 or higher */
X			/* use SYSV for < v6.5 */
X
X
X/* define any of the following that are appropriate */
X/* #define NETWORK	/* if running on a networked system */
X			/* e.g. Suns sharing a playground through NFS */
X/* #define GENIX	/* Yet Another Unix Clone */
X/* #define HISX		/* Bull Unix for XPS Machines */
X/* #define UNIXPC	/* use in addition to SYSV for AT&T 7300/3B1 */
X			/* also note that the stock cpp qualifies as a
X			   STUPID_CPP for config.h */
X
X/* #define PYRAMID_BUG 	/* avoid a bug on the Pyramid */
X/* #define APOLLO	/* same for the Apollo */
X/* #define BSD_43_BUG	/* for real 4.3BSD cc's without schain botch fix */
X/* #define MICROPORT_BUG /* problems with large arrays in structs */
X/* #define MICROPORT_286_BUG /* Changes needed in termcap.c to get it to
X			   run with Microport Sys V/AT version 2.4.
X			   By Jay Maynard */
X/* #define AIXPS_2BUG	/* avoid a problem with little_to_big() optimization */
X
X/* #define RANDOM	/* if neither random/srandom nor lrand48/srand48
X			   is available from your system */
X/* #define TEXTCOLOR	/* Use System V r3.2 terminfo color support */
X
X
X/*
X * The next two defines are intended mainly for the Andrew File System,
X * which does not allow hard links.  If NO_FILE_LINKS is defined, lock files
X * will be created in LOCKDIR using open() instead of in the playground using
X * link().
X *		Ralf Brown, 7/26/89 (from v2.3 hack of 10/10/88)
X */
X
X/* #define NO_FILE_LINKS	/* if no hard links */
X/* #define LOCKDIR "/usr/games/lib/nethackdir"	/* where to put locks */
X
X
X/*
X * Define DEF_PAGER as your default pager, e.g. "/bin/cat" or "/usr/ucb/more"
X * If defined, it can be overridden by the environment variable PAGER.
X * Hack will use its internal pager if DEF_PAGER is not defined.
X * (This might be preferable for security reasons.)
X * #define DEF_PAGER	".../mydir/mypager"
X */
X
X
X
X/*
X * If you define MAIL, then the player will be notified of new mail
X * when it arrives.  If you also define DEF_MAILREADER then this will
X * be the default mail reader, and can be overridden by the environment
X * variable MAILREADER; otherwise an internal pager will be used.
X * A stat system call is done on the mailbox every MAILCKFREQ moves.
X */
X
X#define MAIL			/* Deliver mail during the game */
X
X/* The Andrew Message System does mail a little differently from normal
X * UNIX.  Mail is deposited in the user's own directory in ~/Mailbox 
X * (another directory).  MAILBOX is the element that will be added on to 
X * the user's home directory path to generate the Mailbox path - just in 
X * case other Andrew sites do it differently from CMU.
X *
X *		dan lovinger
X *		dl2n+@andrew.cmu.edu (dec 19 1989)
X */
X
X/* #define AMS			/* use Andrew message system for mail */
X
X/* NO_MAILREADER is for kerberos authentcating filesystems where it is
X * essentially impossible to securely exec child proccesses, like mail
X * readers, when the game is running under a special token.
X *
X *             dan
X */
X
X/* #define NO_MAILREADER 	/* have mail daemon just tell player of mail */
X
X#ifdef	MAIL
X# if defined(BSD) || defined(ULTRIX)
X#  ifdef AMS
X#define AMS_MAILBOX	"/Mailbox"
X#  else
X#define	DEF_MAILREADER	"/usr/ucb/Mail"
X#  endif
X#else
X# if defined(SYSV) || defined(DGUX) || defined(HPUX)
X#  ifdef M_XENIX
X#define	DEF_MAILREADER	"/usr/bin/mail"
X#  else
X#define	DEF_MAILREADER	"/usr/bin/mailx"
X#  endif
X# else
X#define	DEF_MAILREADER	"/bin/mail"
X# endif
X#endif
X
X#define	MAILCKFREQ	50
X#endif	/* MAIL */
X
X
X
X#ifdef COMPRESS
X/* Some implementations of compress need a 'quiet' option.
X * If you've got one of these versions, put -q here.
X * You can also include any other strange options your compress needs.
X * If you have a normal compress, just leave it commented out.
X */
X/* #define COMPRESS_OPTIONS	"-q"	/* */
X#endif
X
X#define	FCMASK	0660	/* file creation mask */
X
X
X/*
X * The remainder of the file should not need to be changed.
X */
X
X/*
X * BSD/ULTRIX systems are normally the only ones that can suspend processes.
X * Suspending NetHack processes cleanly should be easy to add to other systems
X * that have SIGTSTP.  Currently the only such system known to work is HPUX;
X * other systems will probably require tweaks to unixtty.c and ioctl.c.
X */
X#if defined(BSD) || defined(ULTRIX) || defined (HPUX)
X#define	SUSPEND		/* let ^Z suspend the game */
X#endif
X
X
X#if defined(BSD) || defined(ULTRIX)
X#include	<sys/time.h>
X#else
X#include	<time.h>
X#endif
X
X#define	HLOCK	"perm"	/* an empty file used for locking purposes */
X#define LLOCK	"safelock"	/* link to previous */
X
X#ifndef REDO
X#define Getchar getchar
X#else
X#define tgetch getchar
X#endif
X
X#define SHELL		/* do not delete the '!' command */
X
X#include "system.h"
X
X#if defined(BSD) || defined(ULTRIX)
X# ifndef DGUX
X#define memcpy(d, s, n)		bcopy(s, d, n)
X#define memcmp(s1, s2, n)	bcmp(s2, s1, n)
X# endif
X#else	/* therefore SYSV */
X#define index	strchr
X#define rindex	strrchr
X#endif
X
X/* Use the high quality random number routines. */
X#if defined(BSD) || defined(ULTRIX) || defined(RANDOM)
X#define Rand()	random()
X#define Srand(seed) srandom(seed)
X#else
X#define Rand()	lrand48()
X#define Srand(seed) srand48(seed)
X#endif
X
X#ifdef hc	/* older versions of the MetaWare High-C compiler define this */
X# ifdef __HC__
X#  undef __HC__
X# endif
X# define __HC__ hc
X# undef hc
X#endif
X
X#endif /* UNIXCONF_H /* */
X#endif /* UNIX /* */
END_OF_FILE
if test 6113 -ne `wc -c <'include/unixconf.h'`; then
    echo shar: \"'include/unixconf.h'\" unpacked with wrong size!
fi
# end of 'include/unixconf.h'
fi
if test -f 'vms/oldcrtl.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vms/oldcrtl.c'\"
else
echo shar: Extracting \"'vms/oldcrtl.c'\" \(5259 characters\)
sed "s/^X//" >'vms/oldcrtl.c' <<'END_OF_FILE'
X/*       SCCS Id: @(#)oldcrtl.c   3.0      90/05/24
X/*   	 Pat Rankin  May'90                                       */
X/* VMS NetHack support, not needed for vms 4.6,4.7,or 5.x.        */
X
X#ifdef VERYOLD_VMS
X/*
X * The following routines are used by NetHack but were not available
X * from the C Run-Time Library (VAXCRTL) prior to VMS V4.6.
X *
X *      atexit, memcmp, memcpy, qsort, rename, vprintf, vsprintf
X *
X * Most of them are implemented here, but others will have to be worked
X * around in another fashion [such as '#define USE_OLDARGS' (even though
X * <varargs.h> is available) to avoid the need for vprintf & vsprintf].
X *
X */
X#define REG register
X
X#ifndef SUPPRESS_MEM_FUNCS
X/* note: hand optimized for VAX (hardware pre-decrement & post-increment) */
X
X/* void *memset(void *, int, size_t) -- fill chunk of memory.
X*/
Xchar *memset( dst, fil, cnt )
XREG char *dst;
XREG char  fil;
XREG int   cnt;
X{
X    char *dst_p = dst;
X    while ( --cnt >= 0 )
X	*dst++ = fil;
X    return dst_p;
X}
X
X/* void *memcpy(void *, const void *, size_t) -- copy chunk of memory.
X*/
Xchar *memcpy( dst, src, cnt )       /*[functionally equivalent to memmove()]*/
XREG char *dst;
XREG char *src;
XREG int   cnt;
X{
X    char *dst_p = dst;
X    if ( src == dst || cnt <= 0 ) {
X	;       /* do nothing */
X    } else if ( dst < src || dst >= src + cnt ) {
X	while ( --cnt >= 0 )
X	    *dst++ = *src++;
X    } else {    /* work backwards */
X	dst += cnt,  src += cnt;
X	while ( --cnt >= 0 )
X	    *--dst = *--src;
X    }
X    return dst_p;
X}
X
X/* void *memchr(const void *, int, size_t) -- search for a byte.
X*/
Xchar *memchr( buf, byt, len )
XREG char *buf;
XREG char  byt;
XREG int   len;
X{
X    while ( --len >= 0 )
X	if ( *buf++ == byt )    /* found */
X	    return --buf;
X    return (char *)0;       /* not found */
X}
X
X/* int memcmp(const void *, const void *, size_t) -- compare two chunks.
X*/
Xint memcmp( buf1, buf2, len )
XREG char *buf1;
XREG char *buf2;
XREG int   len;
X{
X    while ( --len >= 0 )
X	if ( *buf1++ != *buf2++ )
X	    return (*--buf1 - *--buf2);
X    return 0;   /* buffers matched */
X}
X#endif /*!SUPPRESS_MEM_FUNCS*/
X
X
X#ifndef SUPPRESS_ATEXIT
X/* int atexit(void (*)(void)) -- register an exit handler.
X*/
X#define MAX_EXIT_FUNCS 32       /* arbitrary (32 matches VAX C v3.x docs) */
Xstruct _ex_hndlr { long reserved, (*routine)(), arg_count, *arg1_addr; };
Xstatic int ex_cnt = 0;          /* number of handlers registered so far */
Xstatic struct { long dummy_arg; struct _ex_hndlr handler;   /*(black box)*/
X       } ex_data[MAX_EXIT_FUNCS];       /* static handler data */
X
Xint atexit( function )
X    int (*function)();          /* note: actually gets called with 1 arg */
X{
X    if ( ex_cnt < MAX_EXIT_FUNCS ) {
X	ex_data[ex_cnt].dummy_arg = 0;  /* ultimately receives exit reason */
X	ex_data[ex_cnt].handler.reserved  = 0;
X	ex_data[ex_cnt].handler.routine   = function;
X	ex_data[ex_cnt].handler.arg_count = 1;          /*(required)*/
X	ex_data[ex_cnt].handler.arg1_addr = &ex_data[ex_cnt].dummy_arg;
X	SYS$DCLEXH( &ex_data[ex_cnt].handler);  /* declare exit handler */
X	return ++ex_cnt;        /*(non-zero)*/
X    } else
X	return 0;
X}
X#endif /*!SUPPRESS_ATEXIT*/
X
X
X#ifndef SUPPRESS_RENAME
X/* int rename(const char *, const char *) -- rename a file (on same device).
X*/
X#ifndef EVMSERR
X#include <errno.h>
X#define C$$TRANSLATE(status)    (errno = EVMSERR,  vaxc$errno = (status))
X#endif
X
Xint rename( old_name, new_name )
X    char *old_name;
X    char *new_name;
X{
X    struct _dsc { int len; char *adr; } old_dsc, new_dsc;
X    unsigned long status, LIB$RENAME_FILE();
X
X    /* put strings into descriptors and call run-time library routine */
X    old_dsc.len = strlen( old_dsc.adr = old_name );
X    new_dsc.len = strlen( new_dsc.adr = new_name );
X    status = LIB$RENAME_FILE( &old_dsc, &new_dsc);  /* omit optional args */
X    if ( !(status & 1) ) {      /* even => failure */
X	C$$TRANSLATE(status);
X	return -1;
X    } else                      /*  odd => success */
X	return 0;
X}
X#endif /*!SUPPRESS_RENAME*/
X
X
X#ifndef SUPPRESS_QSORT
X/* void qsort(void *, size_t, size_t, int (*)()) -- sort arbitrary collection.
X*/
Xvoid qsort( base, count, size, compare )
X    char *base;
X    int   count;
XREG int   size;
X    int (*compare)();
X{
XREG int   i, cmp;
XREG char *next, *prev, *tmp = 0;
X    char  wrk_buf[512], *malloc();      /* assume no alloca() available */
X
X    /* just use a shuffle sort (tradeoff between efficiency & simplicity) */
X    /*  [Optimal if already sorted; worst case when initially reversed.]  */
X    for ( next = base, i = 1;  i < count;  i++ ) {
X	prev = next,  next += size;             /* increment front pointer */
X	if ( (cmp = (*compare)( next, prev)) < 0 ) {
X	    /* found element out of order; move other(s) up then re-insert it */
X	    if ( !tmp )  tmp = (size > sizeof wrk_buf ? malloc(size) : wrk_buf);
X	    memcpy( tmp, next, size);           /* save smaller element */
X	    while ( cmp < 0 ) {
X		memcpy( prev + size, prev, size);   /* move larger elem. up */
X		prev -= size;                   /* decrement back pointer */
X		cmp = (prev >= base ? (*compare)( tmp, prev) : 0);
X	    }
X	    memcpy( prev + size, tmp, size);    /* restore small element */
X	}
X    }
X    if ( tmp != 0 && tmp != wrk_buf )  free(tmp);
X    return;
X}
X#endif /*!SUPPRESS_QSORT*/
X
X#endif /*VERYOLD_VMS*/
END_OF_FILE
if test 5259 -ne `wc -c <'vms/oldcrtl.c'`; then
    echo shar: \"'vms/oldcrtl.c'\" unpacked with wrong size!
fi
# end of 'vms/oldcrtl.c'
fi
echo shar: End of archive 51 \(of 56\).
cp /dev/null ark51isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 56 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
    echo Building monst.c from monst.c1 and monst.c2
    cat src/monst.c1 src/monst.c2 > src/monst.c
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
