Path: utzoo!utgpu!watserv1!watmath!att!linac!pacific.mps.ohio-state.edu!zaphod.mps.ohio-state.edu!think.com!mintaka!ogicse!zephyr.ens.tek.com!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v12i029:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Patch10e
Message-ID: <6987@tekred.CNA.TEK.COM>
Date: 9 Feb 91 01:38:15 GMT
Sender: news@tekred.CNA.TEK.COM
Lines: 1913
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 12, Issue 29
Archive-name: NetHack3/Patch10e
Patch-To: NetHack3: Volume 7, Issue 56-93
Environment: 



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 5 (of 8)."
# Contents:  patch10.02
# Wrapped by billr@saab on Fri Feb  8 17:19:00 1991
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'patch10.02' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'patch10.02'\" to \"'patch10.02.orig'\"
  mv -f 'patch10.02' 'patch10.02.orig'
fi
echo shar: Extracting \"'patch10.02'\" \(50088 characters\)
sed "s/^X//" >'patch10.02' <<'END_OF_FILE'
X*** src/Makefile.src	Wed May 30 00:27:20 1990
X--- src/Makefile.src	Sun Feb  3 17:16:02 1991
X***************
X*** 50,55 ****
X--- 50,62 ----
X  # (as long as it claims to be __STDC__ but isn't)
X  # CFLAGS = -DAPOLLO -O -I../include
X  
X+ # flags for AIX 3.1 cc on IBM RS/6000 to define
X+ # a suitable subset of standard libraries
X+ # CFLAGS = -D_NO_PROTO -D_XOPEN_SOURCE -O -I../include
X+ 
X+ # flags for DECstations running 4.0 or greater using the native C compiler
X+ # CFLAGS = -O -Olimit 1000 -I../include
X+ 
X  # flags for debugging:
X  # CFLAGS = -g -I../include
X  
X***************
X*** 61,66 ****
X--- 68,75 ----
X  # on 386 Xenix, the -ltermlib tputs() seems not to work; use -lcurses instead
X  # Sysatt uses shared library in lieu of this option
X  # Systos needs -lcurses16 if you use -mshort
X+ # AIX 3.1 on RS/6000 likes -lcurses if TERMINFO defined in config.h
X+ # and -ltermcap otherwise
X  #
X  # TERMLIB = -ltermcap
X  # TERMLIB = -lcurses
X*** src/alloc.c	Thu Mar 29 09:13:26 1990
X--- src/alloc.c	Sat Jan  5 15:06:40 1991
X***************
X*** 2,7 ****
X--- 2,9 ----
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X+ /* to get the malloc() prototype from system.h */
X+ #define ALLOC_C		/* comment line for pre-compiled headers */
X  /* since this file is also used in auxiliary programs, don't include all the 
X   * function declarations for all of nethack
X   */
X*** src/apply.c	Tue Jun 26 21:20:14 1990
X--- src/apply.c	Sat Jan  5 15:08:29 1991
X***************
X*** 1269,1275 ****
X  		int did_stat = 0;
X  		int i = rn2(A_MAX);
X  		for(j=0; j<A_MAX; j++) {
X! 			if ((blessed || j==i) && ABASE(i) < AMAX(i)) {
X  				did_something++;
X  				/* They may have to use it several times... */
X  				if (!did_stat) {
X--- 1269,1279 ----
X  		int did_stat = 0;
X  		int i = rn2(A_MAX);
X  		for(j=0; j<A_MAX; j++) {
X! 			/* don't recover strength lost while hungry */
X! 			if ((blessed || j==i) &&
X! 				((j != A_STR || u.uhs < WEAK)
X! 				? (ABASE(i) < AMAX(i))
X! 				: (ABASE(A_STR) < (AMAX(A_STR) - 1)))) {
X  				did_something++;
X  				/* They may have to use it several times... */
X  				if (!did_stat) {
X*** src/artifact.c	Sat May 26 23:17:50 1990
X--- src/artifact.c	Sat Jan  5 14:59:08 1991
X***************
X*** 164,170 ****
X  {
X  	register const struct artifact *artif;
X  
X! 	if(otmp)
X  	    if(strlen(ONAME(otmp)))
X  		for(artif = artilist; artif->otyp; artif++)
X  		    if(artif->otyp == otmp->otyp &&
X--- 164,170 ----
X  {
X  	register const struct artifact *artif;
X  
X! 	if(otmp && otmp->onamelth)
X  	    if(strlen(ONAME(otmp)))
X  		for(artif = artilist; artif->otyp; artif++)
X  		    if(artif->otyp == otmp->otyp &&
X***************
X*** 309,315 ****
X  struct permonst *ptr;
X  {
X  	if(!(weap->spfx & (SPFX_DBONUS | SPFX_ATTK)))
X! 	    return(0);
X  
X  	if(weap->spfx & SPFX_DMONS)
X  	    return((ptr == &mons[(int)weap->mtype]));
X--- 309,315 ----
X  struct permonst *ptr;
X  {
X  	if(!(weap->spfx & (SPFX_DBONUS | SPFX_ATTK)))
X! 	    return(weap->attk.adtyp == AD_PHYS);
X  
X  	if(weap->spfx & SPFX_DMONS)
X  	    return((ptr == &mons[(int)weap->mtype]));
X*** src/bones.c	Mon May 21 22:21:08 1990
X--- src/bones.c	Sat Jan  5 15:06:57 1991
X***************
X*** 92,99 ****
X  			&& (!is_artifact(otmp) ||
X  			    (exist_artifact(otmp,ONAME(otmp)) && restore))
X  #endif
X! 		)
X  			otmp->onamelth = 0;
X  #ifdef NAMED_ITEMS
X  		else if (is_artifact(otmp) && restore)
X  			artifact_exists(otmp,ONAME(otmp),TRUE);
X--- 92,101 ----
X  			&& (!is_artifact(otmp) ||
X  			    (exist_artifact(otmp,ONAME(otmp)) && restore))
X  #endif
X! 		) {
X  			otmp->onamelth = 0;
X+ 			*ONAME(otmp) = '\0';
X+ 		}
X  #ifdef NAMED_ITEMS
X  		else if (is_artifact(otmp) && restore)
X  			artifact_exists(otmp,ONAME(otmp),TRUE);
X***************
X*** 218,223 ****
X--- 220,226 ----
X  		atl(u.ux, u.uy, mtmp->data->mlet);
X  		Your("body rises from the dead as %s...",
X  			an(mons[u.ugrave_arise].mname));
X+ 		more();
X  	}
X  	mtmp->m_lev = (u.ulevel ? u.ulevel : 1);
X  	mtmp->mhp = mtmp->mhpmax = u.uhpmax;
X***************
X*** 307,312 ****
X--- 310,323 ----
X  	bflush(fd);
X  #endif
X  	(void) close(fd);
X+ #if defined(VMS) && !defined(SECURE)
X+ 	/*
X+ 	   Re-protect bones file with world:read+write+execute+delete access.
X+ 	   umask() doesn't seem very reliable; also, vaxcrtl won't let us set
X+ 	   delete access without write access, which is what's really wanted.
X+ 	 */
X+ 	(void) chmod(bones, FCMASK | 007);  /* allow other users full access */
X+ #endif
X  #ifdef MACOS
X  	{
X  		FInfo	fndrInfo;
X***************
X*** 326,332 ****
X  			SetFInfo(name, (short)0, &fndrInfo);
X  		SetVol(0L, oldVol);
X  	}
X! #endif
X  #ifdef COMPRESS
X  	compress_bones();
X  #endif
X--- 337,343 ----
X  			SetFInfo(name, (short)0, &fndrInfo);
X  		SetVol(0L, oldVol);
X  	}
X! #endif /* MACOS */
X  #ifdef COMPRESS
X  	compress_bones();
X  #endif
X*** src/dbridge.c	Thu May 31 00:31:26 1990
X--- src/dbridge.c	Sun Jan 27 13:36:18 1991
X***************
X*** 425,435 ****
X  			done(how);
X  			/* So, you didn't die */
X  			if (!e_survives_at(etmp, etmp->ex, etmp->ey)) {
X  				pline("A %s force teleports you away...",
X! 		      		      Hallucination ? "normal" : "strange");
X! 				(void) enexto(&xy, etmp->ex, etmp->ey,
X! 								etmp->edata);
X  				teleds(xy.x, xy.y);
X  			}
X  		}
X  	} else {
X--- 425,439 ----
X  			done(how);
X  			/* So, you didn't die */
X  			if (!e_survives_at(etmp, etmp->ex, etmp->ey)) {
X+ 			    if (enexto(&xy, etmp->ex, etmp->ey,
X+ 							    etmp->edata)) {
X  				pline("A %s force teleports you away...",
X! 				      Hallucination ? "normal" : "strange");
X  				teleds(xy.x, xy.y);
X+ 			    }
X+ 			    /* otherwise on top of the drawbridge is the
X+ 			     * only viable spot in the dungeon, so stay there
X+ 			     */
X  			}
X  		}
X  	} else {
X***************
X*** 787,798 ****
X--- 791,812 ----
X  	do_entity(&(occupants[0]));
X  	do_entity(&(occupants[1]));
X  	redosym(x, y);
X+ 	if(OBJ_AT(x,y) && flags.soundok)
X+ 		You("hear smashing and crushing.");
X  	for (otmp = level.objects[x][y]; otmp; otmp = otmp2) {
X  		otmp2 = otmp->nexthere;
X+ 		if (otmp == uball)
X+ 			unpunish();
X+ 		if (otmp == uchain)
X+ 			continue;
X  		delobj(otmp);
X  	}
X  	for (otmp = level.objects[x2][y2]; otmp; otmp = otmp2) {
X  		otmp2 = otmp->nexthere;
X+ 		if (otmp == uball)
X+ 			unpunish();
X+ 		if (otmp == uchain)
X+ 			continue;
X  		delobj(otmp);
X  	}
X  	redosym(x2, y2);
X*** src/do.c	Thu May 31 00:31:28 1990
X--- src/do.c	Fri Jan 18 09:32:11 1991
X***************
X*** 11,16 ****
X--- 11,26 ----
X   * below 
X   */
X  #include <errno.h>
X+ 
X+ # ifdef _MSC_VER	/* MSC 6.0 defines errno quite differently */
X+ #  if (_MSC_VER >= 600)
X+ #   define SKIP_ERRNO
X+ #  endif
X+ # endif
X+ #endif /* STUPID_CPP */
X+ 
X+ #ifndef SKIP_ERRNO
X+ extern int errno;
X  #endif
X  
X  #if defined(DGK)
X***************
X*** 640,646 ****
X   *	up a set of stairs sometimes does some very strange things!
X   */
X  #ifdef HARD
X! 	if(Inhell && up && !at_ladder &&
X  			(dlevel < MAXLEVEL-3) && u.uhave_amulet) {
X  	    int olev = newlevel;
X  
X--- 650,659 ----
X   *	up a set of stairs sometimes does some very strange things!
X   */
X  #ifdef HARD
X! 	if(Inhell && up &&
X! # ifdef STRONGHOLD
X!            !at_ladder &&
X! # endif
X  			(dlevel < MAXLEVEL-3) && u.uhave_amulet) {
X  	    int olev = newlevel;
X  
X***************
X*** 818,824 ****
X  #else
X  		if((fd = open(lock,0)) < 0) {
X  #endif
X- 			extern int errno;
X  			pline("Cannot open \"%s\" (errno %d).", lock, errno);
X  			pline("Probably someone removed it.");
X  			done(TRICKED);
X--- 831,836 ----
X*** src/do_name.c	Thu May 31 00:31:28 1990
X--- src/do_name.c	Sat Jan  5 14:59:15 1991
X***************
X*** 149,154 ****
X--- 149,158 ----
X  	register char *curr;
X  	boolean blank;
X  
X+ 	if (Hallucination) {
X+ 		You("would never recognize it anyway.");
X+ 		return 0;
X+ 	}
X  	cc.x = u.ux;
X  	cc.y = u.uy;
X  	getpos(&cc, 0, "the monster you want to name");
X***************
X*** 428,434 ****
X  		 * or 'Asidonhopo the blue dragon'.
X  		 */
X  		Strcat(buf, " ");
X! 	} else if(mtmp->mnamelth && !vb) {
X  		if(isinvis) {
X  		    Strcpy(buf, "the invisible ");
X  		    Strcat(buf, NAME(mtmp));
X--- 432,438 ----
X  		 * or 'Asidonhopo the blue dragon'.
X  		 */
X  		Strcat(buf, " ");
X! 	} else if(mtmp->mnamelth && !vb && !Hallucination) {
X  		if(isinvis) {
X  		    Strcpy(buf, "the invisible ");
X  		    Strcat(buf, NAME(mtmp));
X***************
X*** 460,466 ****
X  			Strcat(buf, "the ");
X  		Strcat(buf, Hallucination ? rndmonnam() : mtmp->data->mname);
X  	}
X! 	if(vb && mtmp->mnamelth) {
X  		Strcat(buf, " called ");
X  		Strcat(buf, NAME(mtmp));
X  	}
X--- 464,470 ----
X  			Strcat(buf, "the ");
X  		Strcat(buf, Hallucination ? rndmonnam() : mtmp->data->mname);
X  	}
X! 	if(vb && mtmp->mnamelth && !Hallucination) {
X  		Strcat(buf, " called ");
X  		Strcat(buf, NAME(mtmp));
X  	}
X*** src/do_wear.c	Sun May 27 00:50:58 1990
X--- src/do_wear.c	Thu Jan 31 12:35:27 1991
X***************
X*** 103,110 ****
X  STATIC_PTR
X  int
X  Boots_on() {
X!     long oldprop =
X! 		u.uprops[objects[uarmf->otyp].oc_oprop].p_flgs & ~(WORN_BOOTS | TIMEOUT);
X  
X      switch(uarmf->otyp) {
X  	case LOW_BOOTS:
X--- 103,109 ----
X  STATIC_PTR
X  int
X  Boots_on() {
X!     long oldprop = u.uprops[objects[uarmf->otyp].oc_oprop].p_flgs & ~WORN_BOOTS;
X  
X      switch(uarmf->otyp) {
X  	case LOW_BOOTS:
X***************
X*** 114,122 ****
X  	case JUMPING_BOOTS:
X  		break;
X  	case SPEED_BOOTS:
X! 		if (!oldprop) {
X  			makeknown(uarmf->otyp);
X! 			You("feel yourself speed up.");
X  		}
X  		break;
X  	case ELVEN_BOOTS:
X--- 113,124 ----
X  	case JUMPING_BOOTS:
X  		break;
X  	case SPEED_BOOTS:
X! 		/* Speed boots are still better than intrinsic speed, */
X! 		/* though not better than potion speed */
X! 		if (!(oldprop & TIMEOUT)) {
X  			makeknown(uarmf->otyp);
X! 			You("feel yourself speed up%s.",
X! 				oldprop ? " a bit more" : "");
X  		}
X  		break;
X  	case ELVEN_BOOTS:
X***************
X*** 126,132 ****
X  		}
X  		break;
X  	case FUMBLE_BOOTS:
X! 		if (!oldprop)
X  			Fumbling += rnd(20);
X  		break;
X  	case LEVITATION_BOOTS:
X--- 128,134 ----
X  		}
X  		break;
X  	case FUMBLE_BOOTS:
X! 		if (!(oldprop & ~TIMEOUT))
X  			Fumbling += rnd(20);
X  		break;
X  	case LEVITATION_BOOTS:
X***************
X*** 146,160 ****
X  	/* For levitation, float_down() returns if Levitation, so we
X  	 * must do a setworn() _before_ the levitation case.
X  	 */
X!     long oldprop =
X! 		u.uprops[objects[uarmf->otyp].oc_oprop].p_flgs & ~(WORN_BOOTS | TIMEOUT);
X  
X      setworn((struct obj *)0, W_ARMF);
X      switch(obj->otyp) {
X  	case SPEED_BOOTS:
X! 		if (!oldprop) {
X  			makeknown(obj->otyp);
X! 			You("feel yourself slow down.");
X  		}
X  		break;
X  	case WATER_WALKING_BOOTS:
X--- 148,162 ----
X  	/* For levitation, float_down() returns if Levitation, so we
X  	 * must do a setworn() _before_ the levitation case.
X  	 */
X!     long oldprop = u.uprops[objects[uarmf->otyp].oc_oprop].p_flgs & ~WORN_BOOTS;
X  
X      setworn((struct obj *)0, W_ARMF);
X      switch(obj->otyp) {
X  	case SPEED_BOOTS:
X! 		if (!(oldprop & TIMEOUT)) {
X  			makeknown(obj->otyp);
X! 			You("feel yourself slow down%s.",
X! 				oldprop ? " a bit" : "");
X  		}
X  		break;
X  	case WATER_WALKING_BOOTS:
X***************
X*** 175,181 ****
X  		}
X  		break;
X  	case FUMBLE_BOOTS:
X! 		if (!oldprop)
X  			Fumbling = 0;
X  		break;
X  	case LEVITATION_BOOTS:
X--- 177,183 ----
X  		}
X  		break;
X  	case FUMBLE_BOOTS:
X! 		if (!(oldprop & ~TIMEOUT))
X  			Fumbling = 0;
X  		break;
X  	case LEVITATION_BOOTS:
X***************
X*** 501,508 ****
X--- 503,516 ----
X  		}
X  		(void)strcat(SAVEF, ".sav");
X  # else
X+ #  ifdef MACOS
X+ 		strncpy(SAVEF, plname, (FILENAME - 2));  /* .e */
X+ 		SAVEF[(FILENAME - 2)] = '\0';
X+ 		regularize(SAVEF);
X+ #  else
X  		Sprintf(SAVEF, "save/%d%s", getuid(), plname);
X  		regularize(SAVEF+5);		/* avoid . or / in name */
X+ #  endif
X  # endif
X  #endif
X  #ifdef WIZARD
X*** src/dogmove.c	Sat May 26 23:17:41 1990
X--- src/dogmove.c	Mon Feb  4 16:32:11 1991
X***************
X*** 29,46 ****
X  
X  	if(edog->hungrytime < moves)
X  	    edog->hungrytime = moves;
X! 	/* Note: to get the correct percentage-eaten in case oeaten is set,
X! 	 * use "obj->owt / obj->quan / base-weight".  It so happens that here
X! 	 * we want to multiply by obj->quan, which thus cancels out.
X  	 * It is arbitrary that the pet takes the same length of time to eat
X! 	 * as a human, but gets 5X as much nutrition.
X  	 */
X  	if(obj->otyp == CORPSE) {
X  	    mtmp->meating = 3 + (mons[obj->corpsenm].cwt >> 2);
X! 	    nutrit = 5 * mons[obj->corpsenm].cnutrit;
X  	} else {
X  	    mtmp->meating = objects[obj->otyp].oc_delay;
X! 	    nutrit = 5 * objects[obj->otyp].nutrition;
X  	}
X  	if(obj->oeaten) {
X  	    mtmp->meating = eaten_stat(mtmp->meating, obj);
X--- 29,44 ----
X  
X  	if(edog->hungrytime < moves)
X  	    edog->hungrytime = moves;
X! 	/*
X  	 * It is arbitrary that the pet takes the same length of time to eat
X! 	 * as a human, but gets 4X as much nutrition.
X  	 */
X  	if(obj->otyp == CORPSE) {
X  	    mtmp->meating = 3 + (mons[obj->corpsenm].cwt >> 2);
X! 	    nutrit = 4 * mons[obj->corpsenm].cnutrit;
X  	} else {
X  	    mtmp->meating = objects[obj->otyp].oc_delay;
X! 	    nutrit = 4 * objects[obj->otyp].nutrition;
X  	}
X  	if(obj->oeaten) {
X  	    mtmp->meating = eaten_stat(mtmp->meating, obj);
X***************
X*** 50,56 ****
X  	mtmp->mconf = 0;
X  	if (mtmp->mtame < 20) mtmp->mtame++;
X  	if(cansee(x,y))
X! 	    pline("%s eats %s.", Monnam(mtmp), doname(obj));
X  	/* perhaps this was a reward */
X  	if(otyp != CADAVER)
X  #ifdef LINT
X--- 48,54 ----
X  	mtmp->mconf = 0;
X  	if (mtmp->mtame < 20) mtmp->mtame++;
X  	if(cansee(x,y))
X! 	    pline("%s eats %s.", Monnam(mtmp), singular(obj, doname));
X  	/* perhaps this was a reward */
X  	if(otyp != CADAVER)
X  #ifdef LINT
X***************
X*** 59,65 ****
X  	    edog->apport += (unsigned)(200L/
X  		((long)edog->dropdist+moves-edog->droptime));
X  #endif
X! 	delobj(obj);
X  }
X  
X  #endif /* OVLB */
X--- 57,66 ----
X  	    edog->apport += (unsigned)(200L/
X  		((long)edog->dropdist+moves-edog->droptime));
X  #endif
X! 	if (obj->quan > 1)
X! 	    obj->quan--;
X! 	else
X! 	    delobj(obj);
X  }
X  
X  #endif /* OVLB */
X*** src/eat.c	Thu May 31 00:31:30 1990
X--- src/eat.c	Sun Feb  3 12:34:00 1991
X***************
X*** 1309,1315 ****
X--- 1309,1318 ----
X  			pline("Stop eating? ");
X  			if(yn() == 'y')
X  #endif
X+ 			{
X  				reset_eat();
X+ 				nomovemsg = NULL;
X+ 			}
X  		    }
X  		}
X  	      }
X***************
X*** 1522,1534 ****
X  register int base;
X  register struct obj *obj;
X  {
X! 	base *= obj->oeaten;
X  
X  	if (obj->otyp == CORPSE) 
X  	    base = mons[obj->corpsenm].cnutrit ?
X! 				base / mons[obj->corpsenm].cnutrit : 0;
X  	else base = objects[obj->otyp].nutrition ?
X! 				base / objects[obj->otyp].nutrition : 0;
X  	return (base < 1) ? 1 : base;
X  }
X  
X--- 1525,1540 ----
X  register int base;
X  register struct obj *obj;
X  {
X! 	long long_base;
X  
X+ 	long_base = (long )base;
X+ 	long_base *= (long )obj->oeaten;
X+ 
X  	if (obj->otyp == CORPSE) 
X  	    base = mons[obj->corpsenm].cnutrit ?
X! 		(int)(long_base / (long )mons[obj->corpsenm].cnutrit) : 0;
X  	else base = objects[obj->otyp].nutrition ?
X! 		(int)(long_base / (long )objects[obj->otyp].nutrition) : 0;
X  	return (base < 1) ? 1 : base;
X  }
X  
X*** src/end.c	Tue Jun 26 21:20:16 1990
X--- src/end.c	Fri Feb  1 10:48:14 1991
X***************
X*** 348,354 ****
X  #endif
X  	if(Lifesaved && how <= GENOCIDED) {
X  		u.uswldtim = 0;
X! 		if(u.uhpmax < 0) u.uhpmax = 10;	/* arbitrary */
X  		u.uhp = u.uhpmax;
X  		adjattrib(A_CON, -1, TRUE);
X  		pline("But wait...");
X--- 348,354 ----
X  #endif
X  	if(Lifesaved && how <= GENOCIDED) {
X  		u.uswldtim = 0;
X! 		if(u.uhpmax <= 0) u.uhpmax = 10;	/* arbitrary */
X  		u.uhp = u.uhpmax;
X  		adjattrib(A_CON, -1, TRUE);
X  		pline("But wait...");
X***************
X*** 355,360 ****
X--- 355,364 ----
X  		makeknown(AMULET_OF_LIFE_SAVING);
X  		Your("medallion %s!",
X  		      !Blind ? "begins to glow" : "feels warm");
X+ 		if (how == CHOKING) {
X+ 			init_uhunger();
X+ 			You("vomit ...");
X+ 		}
X  		You("feel much better!");
X  		pline("The medallion crumbles to dust!");
X  		useup(uamul);
X***************
X*** 377,386 ****
X  		pline("Die? ");
X  		if(yn() == 'y') goto die;
X  		u.uswldtim = 0;
X! 		if(u.uhpmax < 0) u.uhpmax = 100;	/* arbitrary */
X  		u.uhp = u.uhpmax;
X  		if (u.uhunger < 500) u.uhunger = 500;
X! 		pline("Ok, so you don't die.");
X  		nomovemsg = "You survived that attempt on your life.";
X  		curs_on_u();
X  		flags.move = 0;
X--- 381,392 ----
X  		pline("Die? ");
X  		if(yn() == 'y') goto die;
X  		u.uswldtim = 0;
X! 		if(u.uhpmax <= 0) u.uhpmax = 100;	/* arbitrary */
X  		u.uhp = u.uhpmax;
X  		if (u.uhunger < 500) u.uhunger = 500;
X! 		if (how == CHOKING) init_uhunger();
X! 		pline("Ok, so you don't %s.",
X! 			(how == CHOKING) ? "choke" : "die");
X  		nomovemsg = "You survived that attempt on your life.";
X  		curs_on_u();
X  		flags.move = 0;
X*** src/getline.c	Wed Apr 11 22:17:42 1990
X--- src/getline.c	Tue Jan 29 16:32:34 1991
X***************
X*** 9,15 ****
X   * Some systems may have getchar() return EOF for various reasons, and
X   * we should not quit before seeing at least NR_OF_EOFS consecutive EOFs.
X   */
X! #if defined(SYSV) || defined(DGUX)
X  #define	NR_OF_EOFS	20
X  #endif
X  #ifdef MACOS
X--- 9,15 ----
X   * Some systems may have getchar() return EOF for various reasons, and
X   * we should not quit before seeing at least NR_OF_EOFS consecutive EOFs.
X   */
X! #if defined(SYSV) || defined(DGUX) || defined(HPUX)
X  #define	NR_OF_EOFS	20
X  #endif
X  #ifdef MACOS
X***************
X*** 257,266 ****
X  char
X  readchar() {
X  	register int sym;
X  
X  	(void) fflush(stdout);
X  #ifdef UNIX
X! 	if((sym = Getchar()) == EOF)
X  # ifdef NR_OF_EOFS
X  	{ /*
X  	   * Some SYSV systems seem to return EOFs for various reasons
X--- 257,276 ----
X  char
X  readchar() {
X  	register int sym;
X+ #ifdef UNIX
X+ 	/* kludge alert: Some Unix variants return funny values if readchar
X+ 	 * is called, interrupted, and then called again from done2().  There
X+ 	 * is non-reentrant code in the internal _filbuf() routine, called by
X+ 	 * getc().
X+ 	 */
X+ 	static int nesting = 0;
X+ 	char nestbuf;
X+ #endif
X  
X  	(void) fflush(stdout);
X  #ifdef UNIX
X! 	if((sym = ((++nesting == 1) ? Getchar() :
X! 	    (read(fileno(stdin),&nestbuf,1) == 1 ? (int)nestbuf : EOF))) == EOF)
X  # ifdef NR_OF_EOFS
X  	{ /*
X  	   * Some SYSV systems seem to return EOFs for various reasons
X***************
X*** 281,286 ****
X--- 291,299 ----
X  #else
X  	sym = Getchar();
X  #endif /* UNIX */
X+ #ifdef UNIX
X+ 	nesting--;
X+ #endif
X  	if(flags.toplin == 1)
X  		flags.toplin = 2;
X  	return((char) sym);
X*** src/hack.c	Tue Jun 26 21:20:18 1990
X--- src/hack.c	Sat Jan  5 14:59:26 1991
X***************
X*** 788,793 ****
X--- 788,801 ----
X  	/* suppress "used before set" message */
X  	x0 = y0 = m0 = 0;
X  #endif
X+ #ifdef POLYSELF
X+ 	/* Grid bugs stop if trying to move diagonal, even if blind.  Maybe */
X+ 	/* they polymorphed while in the middle of a long move. */
X+ 	if (u.umonnum == PM_GRID_BUG && u.dx && u.dy) {
X+ 		nomul(0);
X+ 		return;
X+ 	}
X+ #endif
X  	if(Blind || flags.run == 0) return;
X  	for(x = u.ux-1; x <= u.ux+1; x++) for(y = u.uy-1; y <= u.uy+1; y++) {
X  		if(!isok(x,y)) continue;
X*** src/invent.c	Thu May 31 00:31:49 1990
X--- src/invent.c	Thu Jan 10 09:52:44 1991
X***************
X*** 14,19 ****
X--- 14,29 ----
X  #ifdef OVL1
X  static boolean FDECL(mergable,(struct obj *,struct obj *));
X  static int FDECL(merged,(struct obj *,struct obj *,int));
X+ # ifdef WIZARD
X+ /* wizards can wish for venom, which will become an invisible inventory
X+  * item without this.  putting it in inv_order would mean venom would
X+  * suddenly become a choice for all the inventory-class commands, which
X+  * would probably cause mass confusion.  the test for inventory venom
X+  * is only WIZARD and not wizard because the wizard can leave venom lying
X+  * around on a bones level for normal players to find.
X+  */
X+ char venom_inv[] = { VENOM_SYM, 0 };
X+ # endif
X  #endif /* OVL1 */
X  STATIC_DCL void FDECL(assigninvlet,(struct obj *));
X  STATIC_DCL struct obj *FDECL(mkgoldobj,(long));
X***************
X*** 167,173 ****
X  		obj->quan--;
X  		obj->owt = weight(obj);
X  	} else {
X! 		if(obj->otyp == CORPSE) food_disappears(obj);
X  		setnotworn(obj);
X  		freeinv(obj);
X  		delete_contents(obj);
X--- 177,183 ----
X  		obj->quan--;
X  		obj->owt = weight(obj);
X  	} else {
X! 		if(obj->olet == FOOD_SYM) food_disappears(obj);
X  		setnotworn(obj);
X  		freeinv(obj);
X  		delete_contents(obj);
X***************
X*** 216,222 ****
X  #ifdef WALKIES
X  	if(obj->otyp == LEASH && obj->leashmon != 0) o_unleash(obj);
X  #endif
X! 	if(obj->otyp == CORPSE) food_disappears(obj);
X  
X  	freeobj(obj);
X  	unpobj(obj);
X--- 226,232 ----
X  #ifdef WALKIES
X  	if(obj->otyp == LEASH && obj->leashmon != 0) o_unleash(obj);
X  #endif
X! 	if(obj->olet == FOOD_SYM) food_disappears(obj);
X  
X  	freeobj(obj);
X  	unpobj(obj);
X***************
X*** 961,967 ****
X  		}
X  		if(!flags.invlet_constant) if(++ilet > 'z') ilet = 'A';
X  	}
X! 	if (flags.sortpack && *++invlet) goto nextclass;
X  	any[ct] = 0;
X  	cornline(2, any);
X  }
X--- 971,985 ----
X  		}
X  		if(!flags.invlet_constant) if(++ilet > 'z') ilet = 'A';
X  	}
X! 	if (flags.sortpack) {
X! 		if (*++invlet) goto nextclass;
X! #ifdef WIZARD
X! 		if (--invlet != venom_inv) {
X! 			invlet = venom_inv;
X! 			goto nextclass;
X! 		}
X! #endif
X! 	}
X  	any[ct] = 0;
X  	cornline(2, any);
X  }
X***************
X*** 1028,1036 ****
X  	    return(0);
X  	}
X  
X! 	if((c == 'u' || c == 'U') && !unpd) {
X  		You("are not carrying any unpaid objects.");
X  		return(0);
X  	}
X  
X  	stct = 0;
X--- 1046,1057 ----
X  	    return(0);
X  	}
X  
X! 	if (c == 'u' || c == 'U') {
X! 	    if (!unpd) {
X  		You("are not carrying any unpaid objects.");
X  		return(0);
X+ 	    } else
X+ 		c = 'u';
X  	}
X  
X  	stct = 0;
X***************
X*** 1385,1394 ****
X--- 1406,1420 ----
X  #endif
X  	"Rings", "Gems"};
X  
X+ #ifdef WIZARD
X+ static const char NEARDATA *venom_name = "Venoms";
X+ #endif
X+ 
X  char *
X  let_to_name(let)
X  char let;
X  {
X+ 	const char *class_name;
X  	const char *pos = index(obj_symbols, let);
X  	/* arbitrary buffer size by Tom May (tom@uw-warp) */
X  	static char NEARDATA *buf = NULL;
X***************
X*** 1401,1411 ****
X  			Boulders/Statues   +  '\0'
X  			1234567890123456 = 16 + 1 = 17
X  */
X! 	if (pos == NULL) pos = obj_symbols;
X  	if (HI && HE)
X! 	    Sprintf(buf, "%s%s%s", HI, names[pos - obj_symbols], HE);
X  	else
X! 	    Sprintf(buf, "%s", names[pos - obj_symbols]);
X  	return (buf);
X  }
X  
X--- 1427,1446 ----
X  			Boulders/Statues   +  '\0'
X  			1234567890123456 = 16 + 1 = 17
X  */
X! #ifdef WIZARD
X! 	if (pos == NULL && let == VENOM_SYM)
X! 		class_name = venom_name;
X! 	else {
X! #endif
X! 		if (pos == NULL) pos = obj_symbols;
X! 		class_name = names[pos - obj_symbols];
X! #ifdef WIZARD
X! 	}
X! #endif
X  	if (HI && HE)
X! 	    Sprintf(buf, "%s%s%s", HI, class_name, HE);
X  	else
X! 	    Sprintf(buf, "%s", class_name);
X  	return (buf);
X  }
X  
X*** src/ioctl.c	Tue May  8 08:52:03 1990
X--- src/ioctl.c	Wed Jan 16 16:42:27 1991
X***************
X*** 12,21 ****
X  #define MONFLAG_H
X  #include "hack.h"
X  
X! #if defined(BSD) || defined(ULTRIX) || defined(HPUX)
X  # ifdef HPUX
X  #include	<bsdtty.h>
X  # else
X  #include	<sgtty.h>
X  # endif
X  struct ltchars ltchars;
X--- 12,24 ----
X  #define MONFLAG_H
X  #include "hack.h"
X  
X! #if defined(BSD) || defined(ULTRIX) || defined(HPUX) || defined(AIX_31)
X  # ifdef HPUX
X  #include	<bsdtty.h>
X  # else
X+ #  if defined(AIX_31) && !defined(_ALL_SOURCE)
X+ #   define _ALL_SOURCE	/* causes struct winsize to be present */
X+ #  endif
X  #include	<sgtty.h>
X  # endif
X  struct ltchars ltchars;
X***************
X*** 30,42 ****
X  
X  void
X  getioctls() {
X! #if defined(BSD) || defined(ULTRIX) || defined(HPUX)
X  	(void) ioctl(fileno(stdin), (int) TIOCGLTC, (char *) &ltchars);
X  	(void) ioctl(fileno(stdin), (int) TIOCSLTC, (char *) &ltchars0);
X  #else
X  	(void) ioctl(fileno(stdin), (int) TCGETA, &termio);
X  #endif
X! #if defined(TIOCGWINSZ) && (defined(BSD) || defined(ULTRIX))
X  	{
X  		/*
X  		 * ttysize is found on Suns and BSD
X--- 33,45 ----
X  
X  void
X  getioctls() {
X! #if defined(BSD) || defined(ULTRIX) || defined(HPUX) || defined(AIX_31)
X  	(void) ioctl(fileno(stdin), (int) TIOCGLTC, (char *) &ltchars);
X  	(void) ioctl(fileno(stdin), (int) TIOCSLTC, (char *) &ltchars0);
X  #else
X  	(void) ioctl(fileno(stdin), (int) TCGETA, &termio);
X  #endif
X! #if defined(TIOCGWINSZ) && (defined(BSD) || defined(ULTRIX) || defined(AIX_31))
X  	{
X  		/*
X  		 * ttysize is found on Suns and BSD
X***************
X*** 61,67 ****
X  
X  void
X  setioctls() {
X! #if defined(BSD) || defined(ULTRIX) || defined(HPUX)
X  	(void) ioctl(fileno(stdin), (int) TIOCSLTC, (char *) &ltchars);
X  #else
X  	/* Now modified to run under Sys V R3.	- may have to be #ifdef'ed */
X--- 64,70 ----
X  
X  void
X  setioctls() {
X! #if defined(BSD) || defined(ULTRIX) || defined(HPUX) || defined(AIX_31)
X  	(void) ioctl(fileno(stdin), (int) TIOCSLTC, (char *) &ltchars);
X  #else
X  	/* Now modified to run under Sys V R3.	- may have to be #ifdef'ed */
X*** src/lev_comp.l	Mon Apr 23 21:56:28 1990
X--- src/lev_comp.l	Mon Feb  4 16:19:20 1991
X***************
X*** 22,31 ****
X--- 22,39 ----
X  int NDECL (yyinput);
X  int NDECL (yywrap);
X  int NDECL (yylex);
X+ # ifdef NeXT
X+ void FDECL (yyunput, (int));
X+ void FDECL (yyoutput, (int));
X+ # else
X  int FDECL (yyunput, (int));
X  int FDECL (yyoutput, (int));
X+ # endif
X  #endif
X  
X+ void FDECL (init_yyin, (FILE *));
X+ void FDECL (init_yyout, (FILE *));
X+ 
X  #ifdef MSDOS
X  #undef exit
X  extern void FDECL(exit, (int));
X***************
X*** 61,67 ****
X  %s MAPC
X  %%
X  <MAPC>[-|}{+SK\\#. ]*\n	{ line_number++; yymore(); }	
X! <MAPC>ENDMAP\n	{ BEGIN 0;
X  		  line_number++;
X  		  yytext[yyleng-7] = 0; /* Discard \nENDMAP */
X  		  yylval.map = (char *) alloc(strlen(yytext)+1);
X--- 69,88 ----
X  %s MAPC
X  %%
X  <MAPC>[-|}{+SK\\#. ]*\n	{ line_number++; yymore(); }	
X! <MAPC>ENDMAP\n	{
X! #ifdef FLEX_SCANNER
X! 		  /*
X! 		   * There is a bug in Flex 2.3 patch level < 6
X! 		   * (absent in previous versions)
X! 		   * that results in the following behaviour :
X! 		   * Once you enter an yymore(), you never exit from it.
X! 		   * This should do the trick!
X! 		   */
X! 		  extern int yy_more_len;
X! 
X! 		  yy_more_len = 0;
X! #endif
X! 		  BEGIN 0;
X  		  line_number++;
X  		  yytext[yyleng-7] = 0; /* Discard \nENDMAP */
X  		  yylval.map = (char *) alloc(strlen(yytext)+1);
X***************
X*** 132,134 ****
X--- 153,174 ----
X  	return ((long *)malloc (n));
X  }
X  #endif
X+ 
X+ /* routine to switch to another input file; needed for flex */
X+ void init_yyin( input_f )
X+ FILE *input_f;
X+ {
X+ #ifdef FLEX_SCANNER
X+ 	if (yyin != NULL)
X+ 	    yyrestart(input_f);
X+ 	else
X+ #endif
X+ 	    yyin = input_f;
X+ }
X+ /* analogous routine (for completeness) */
X+ void init_yyout( output_f )
X+ FILE *output_f;
X+ {
X+ 	yyout = output_f;
X+ }
X+ 
X*** src/lev_lex.c	Mon May 28 16:18:56 1990
X--- src/lev_lex.c	Mon Feb  4 16:46:34 1991
X***************
X*** 48,57 ****
X--- 48,65 ----
X  int NDECL (yyinput);
X  int NDECL (yywrap);
X  int NDECL (yylex);
X+ # ifdef NeXT
X+ void FDECL (yyunput, (int));
X+ void FDECL (yyoutput, (int));
X+ # else
X  int FDECL (yyunput, (int));
X  int FDECL (yyoutput, (int));
X+ # endif
X  #endif
X  
X+ void FDECL (init_yyin, (FILE *));
X+ void FDECL (init_yyout, (FILE *));
X+ 
X  #ifdef MSDOS
X  #undef exit
X  extern void FDECL(exit, (int));
X***************
X*** 95,101 ****
X  { line_number++; yymore(); }
X  break;
X  case 2:
X! { BEGIN 0;
X  		  line_number++;
X  		  yytext[yyleng-7] = 0; /* Discard \nENDMAP */
X  		  yylval.map = (char *) alloc(strlen(yytext)+1);
X--- 103,122 ----
X  { line_number++; yymore(); }
X  break;
X  case 2:
X! {
X! #ifdef FLEX_SCANNER
X! 		  /*
X! 		   * There is a bug in Flex 2.3 patch level < 6
X! 		   * (absent in previous versions)
X! 		   * that results in the following behaviour :
X! 		   * Once you enter an yymore(), you never exit from it.
X! 		   * This should do the trick!
X! 		   */
X! 		  extern int yy_more_len;
X! 
X! 		  yy_more_len = 0;
X! #endif
X! 		  BEGIN 0;
X  		  line_number++;
X  		  yytext[yyleng-7] = 0; /* Discard \nENDMAP */
X  		  yylval.map = (char *) alloc(strlen(yytext)+1);
X***************
X*** 278,283 ****
X--- 299,323 ----
X  	return ((long *)malloc (n));
X  }
X  #endif
X+ 
X+ /* routine to switch to another input file; needed for flex */
X+ void init_yyin( input_f )
X+ FILE *input_f;
X+ {
X+ #ifdef FLEX_SCANNER
X+ 	if (yyin != NULL)
X+ 	    yyrestart(input_f);
X+ 	else
X+ #endif
X+ 	    yyin = input_f;
X+ }
X+ /* analogous routine (for completeness) */
X+ void init_yyout( output_f )
X+ FILE *output_f;
X+ {
X+ 	yyout = output_f;
X+ }
X+ 
X  int yyvstop[] ={
X  0,
X  
X*** src/makedefs.c	Sun May 27 20:44:51 1990
X--- src/makedefs.c	Thu Jan 31 13:45:44 1991
X***************
X*** 103,110 ****
X  
X  char * FDECL(tmpdup, (const char *));
X  
X! #if defined(SYSV) || defined(GENIX) || defined(UNIXDEBUG)
X! void FDECL(rename, (char *, char *));
X  #endif
X  
X  #ifdef SMALLDATA
X--- 103,110 ----
X  
X  char * FDECL(tmpdup, (const char *));
X  
X! #if defined(SYSV) || defined(GENIX)
X! int FDECL(rename, (const char *, const char *));
X  #endif
X  
X  #ifdef SMALLDATA
X***************
X*** 286,292 ****
X  #if defined(MSDOS) || defined(MACOS)
X  	remove(TRAP_FILE);
X  #endif
X! 	rename(tempfile, TRAP_FILE);
X  	return;
X  }
X  
X--- 286,292 ----
X  #if defined(MSDOS) || defined(MACOS)
X  	remove(TRAP_FILE);
X  #endif
X! 	(void) rename(tempfile, TRAP_FILE);
X  	return;
X  }
X  
X***************
X*** 308,315 ****
X--- 308,323 ----
X  	}
X  
X  	/* get size of true rumors file */
X+ #ifndef VMS
X  	(void) fseek(stdin, 0L, 2);
X  	true_rumor_size = ftell(stdin);
X+ #else
X+ 	/* seek+tell is only valid for stream format files; since rumors.%%%
X+ 	   might be in record format, count the acutal data bytes instead.
X+ 	 */
X+ 	true_rumor_size = 0;
X+ 	while (gets(in_line) != NULL)  true_rumor_size += strlen(in_line) + 1;
X+ #endif /* VMS */
X  	(void) fwrite((genericptr_t)&true_rumor_size,sizeof(long),1,stdout);
X  	(void) fseek(stdin, 0L, 0);
X  
X***************
X*** 600,609 ****
X  	return buf;
X  }
X  
X! #if defined(SYSV) || defined(GENIX) || defined(UNIXDEBUG)
X! void
X  rename(oldname, newname)
X! char	*oldname, *newname;
X  {
X  	if (strcmp(oldname, newname)) {
X  		(void) unlink(newname);
X--- 608,621 ----
X  	return buf;
X  }
X  
X! #if defined(SYSV) || defined(GENIX)
X! /* later SYSV (SVR3+?) systems have rename() a la POSIX and BSD.
X!  * redefining it (with the same functionality) should be ok as long
X!  * as it's the same type.
X!  */
X! int
X  rename(oldname, newname)
X! const char	*oldname, *newname;
X  {
X  	if (strcmp(oldname, newname)) {
X  		(void) unlink(newname);
X***************
X*** 610,616 ****
X  		(void) link(oldname, newname);
X  		(void) unlink(oldname);
X  	}
X! 	return;
X  }
X  #endif
X  
X--- 622,628 ----
X  		(void) link(oldname, newname);
X  		(void) unlink(oldname);
X  	}
X! 	return 0;
X  }
X  #endif
X  
X*** src/makemon.c	Tue Jun 26 21:20:21 1990
X--- src/makemon.c	Sun Jan  6 15:55:52 1991
X***************
X*** 119,125 ****
X  				    BOULDER : CLUB);
X  		break;
X  	    case S_HUMAN:
X! 		if(is_mercenary(ptr))
X  		    switch (mm) {
X  
X  #ifdef ARMY
X--- 119,125 ----
X  				    BOULDER : CLUB);
X  		break;
X  	    case S_HUMAN:
X! 		if(is_mercenary(ptr)) {
X  		    switch (mm) {
X  
X  #ifdef ARMY
X***************
X*** 140,146 ****
X  				    if (!rn2(7)) (void) mongets(mtmp, SPEAR);
X  				    break;
X  		    }
X! 		    break;
X  
X  	    case S_HUMANOID:
X  #ifdef TOLKIEN
X--- 140,190 ----
X  				    if (!rn2(7)) (void) mongets(mtmp, SPEAR);
X  				    break;
X  		    }
X! #ifdef TOLKIEN
X! 		} else if (is_elf(ptr)) {
X! 		    (void)mongets(mtmp,
X! 			rn2(2) ? ELVEN_MITHRIL_COAT : ELVEN_CLOAK);
X! 		    if (rn2(2)) (void)mongets(mtmp, ELVEN_LEATHER_HELM);
X! 		    if (rn2(3)) (void)mongets(mtmp, ELVEN_DAGGER);
X! 		    switch (rn2(3)) {
X! 			case 0:
X! 			    if (!rn2(4)) (void)mongets(mtmp, ELVEN_SHIELD);
X! 			    (void)mongets(mtmp, ELVEN_SHORT_SWORD);
X! 			    (void)mongets(mtmp, ELVEN_BOW);
X! 			    m_initthrow(mtmp, ELVEN_ARROW, 12);
X! 			    break;
X! 			case 1:
X! 			    (void)mongets(mtmp, ELVEN_BROADSWORD);
X! 			    if (rn2(2)) (void)mongets(mtmp, ELVEN_SHIELD);
X! 			    break;
X! 			case 2:
X! 			    (void)mongets(mtmp, ELVEN_SPEAR);
X! 			    (void)mongets(mtmp, ELVEN_SHIELD);
X! 			    break;
X! 		    }
X! #else /* TOLKIEN */
X! 		} else if (is_elf(ptr)) {
X! 		    (void)mongets(mtmp, ELVEN_CLOAK);
X! 		    if (rn2(3)) (void)mongets(mtmp, DAGGER);
X! 		    switch (rn2(3)) {
X! 			case 0:
X! 			    if (!rn2(4)) (void)mongets(mtmp, SMALL_SHIELD);
X! 			    (void)mongets(mtmp, SHORT_SWORD);
X! 			    (void)mongets(mtmp, BOW);
X! 			    m_initthrow(mtmp, ARROW, 12);
X! 			    break;
X! 			case 1:
X! 			    (void)mongets(mtmp, BROADSWORD);
X! 			    if (rn2(2)) (void)mongets(mtmp, SMALL_SHIELD);
X! 			    break;
X! 			case 2:
X! 			    (void)mongets(mtmp, SPEAR);
X! 			    (void)mongets(mtmp, SMALL_SHIELD);
X! 			    break;
X! 		    }
X! #endif
X! 		}
X! 		break;
X  
X  	    case S_HUMANOID:
X  #ifdef TOLKIEN
X***************
X*** 174,200 ****
X  		    } else {
X  			(void)mongets(mtmp, PICK_AXE);
X  		    }
X- 		} else if (is_elf(ptr)) {
X- 		    (void)mongets(mtmp,
X- 			rn2(2) ? ELVEN_MITHRIL_COAT : ELVEN_CLOAK);
X- 		    if (rn2(2)) (void)mongets(mtmp, ELVEN_LEATHER_HELM);
X- 		    if (rn2(3)) (void)mongets(mtmp, ELVEN_DAGGER);
X- 		    switch (rn2(3)) {
X- 			case 0:
X- 			    if (!rn2(4)) (void)mongets(mtmp, ELVEN_SHIELD);
X- 			    (void)mongets(mtmp, ELVEN_SHORT_SWORD);
X- 			    (void)mongets(mtmp, ELVEN_BOW);
X- 			    m_initthrow(mtmp, ELVEN_ARROW, 12);
X- 			    break;
X- 			case 1:
X- 			    (void)mongets(mtmp, ELVEN_BROADSWORD);
X- 			    if (rn2(2)) (void)mongets(mtmp, ELVEN_SHIELD);
X- 			    break;
X- 			case 2:
X- 			    (void)mongets(mtmp, ELVEN_SPEAR);
X- 			    (void)mongets(mtmp, ELVEN_SHIELD);
X- 			    break;
X- 		    }
X  		}
X  #else /* TOLKIEN */
X  		if (is_dwarf(ptr)) {
X--- 218,223 ----
X***************
X*** 210,234 ****
X  			    (void)mongets(mtmp, DWARVISH_MITHRIL_COAT);
X  		    } else {
X  			(void)mongets(mtmp, PICK_AXE);
X- 		    }
X- 		} else if (is_elf(ptr)) {
X- 		    (void)mongets(mtmp, ELVEN_CLOAK);
X- 		    if (rn2(3)) (void)mongets(mtmp, DAGGER);
X- 		    switch (rn2(3)) {
X- 			case 0:
X- 			    if (!rn2(4)) (void)mongets(mtmp, SMALL_SHIELD);
X- 			    (void)mongets(mtmp, SHORT_SWORD);
X- 			    (void)mongets(mtmp, BOW);
X- 			    m_initthrow(mtmp, ARROW, 12);
X- 			    break;
X- 			case 1:
X- 			    (void)mongets(mtmp, BROADSWORD);
X- 			    if (rn2(2)) (void)mongets(mtmp, SMALL_SHIELD);
X- 			    break;
X- 			case 2:
X- 			    (void)mongets(mtmp, SPEAR);
X- 			    (void)mongets(mtmp, SMALL_SHIELD);
X- 			    break;
X  		    }
X  		}
X  #endif /* TOLKIEN */
X--- 233,238 ----
X*** src/mhitm.c	Thu May 31 00:31:36 1990
X--- src/mhitm.c	Sun Jan  6 15:56:11 1991
X***************
X*** 274,304 ****
X  
X  	mx = magr->mx;
X  	my = magr->my;
X! 	 /* move over top of the defender */
X  	if(cansee(mdef->mx, mdef->my))	unpmon(mdef);
X  	if(cansee(magr->mx, magr->my))	unpmon(magr);
X! 	magr->mx = mdef->mx;
X! 	magr->my = mdef->my;
X  	if(cansee(magr->mx, magr->my))	pmon(magr);
X! 	if((tmp = mdamagem(magr, mdef, mattk)) == 2) {
X! 		remove_monster(mx, my);
X! 		place_monster(magr, magr->mx, magr->my);
X  		/* if mdamagem left a corpse it erased magr's symbol */
X  		unpmon(magr);
X  		pmon(magr);
X! 		return(2);	/* defender died */
X  	} else {		/* defender survived */
X  		if(cansee(mdef->mx, mdef->my))
X  			pline("%s is regurgitated!", Monnam(mdef));
X  		if(cansee(magr->mx, magr->my))	unpmon(magr);
X! 		magr->mx = mx;
X! 		magr->my = my;
X  		/* move off of defender */
X  		if(cansee(magr->mx, magr->my))	pmon(magr);
X  		if(cansee(mdef->mx, mdef->my))	pmon(mdef);
X- 		nscr();
X- 		return(tmp);
X  	}
X  }
X  
X  static int
X--- 274,305 ----
X  
X  	mx = magr->mx;
X  	my = magr->my;
X! 	/* move over top of the defender */
X  	if(cansee(mdef->mx, mdef->my))	unpmon(mdef);
X  	if(cansee(magr->mx, magr->my))	unpmon(magr);
X! 	remove_monster(mx, my);
X! 	place_monster(magr, mdef->mx, mdef->my);
X  	if(cansee(magr->mx, magr->my))	pmon(magr);
X! 
X! 	if((tmp = mdamagem(magr, mdef, mattk)) == 2) {	/* defender died */
X  		/* if mdamagem left a corpse it erased magr's symbol */
X  		unpmon(magr);
X  		pmon(magr);
X! 	} else if (tmp == -1) {	/* agressor died, put defender back */
X! 		place_monster(mdef, mdef->mx, mdef->my);
X! 		if(cansee(mdef->mx, mdef->my)) pmon(mdef);
X  	} else {		/* defender survived */
X  		if(cansee(mdef->mx, mdef->my))
X  			pline("%s is regurgitated!", Monnam(mdef));
X  		if(cansee(magr->mx, magr->my))	unpmon(magr);
X! 		place_monster(magr, mx, my);
X! 		place_monster(mdef, mdef->mx, mdef->my);
X  		/* move off of defender */
X  		if(cansee(magr->mx, magr->my))	pmon(magr);
X  		if(cansee(mdef->mx, mdef->my))	pmon(mdef);
X  	}
X+ 	nscr();
X+ 	return(tmp);
X  }
X  
X  static int
X***************
X*** 393,399 ****
X  		tmp += destroy_mitem(mdef, SPBOOK_SYM, AD_FIRE);
X  #endif
X  		if(resists_fire(pd)) {
X! 		    pline("The fire doesn't seem to burn %s!", mon_nam(mdef));
X  		    shieldeff(mdef->mx, mdef->my);
X  #ifdef GOLEMS
X  		    golemeffects(mdef, AD_FIRE, tmp);
X--- 394,402 ----
X  		tmp += destroy_mitem(mdef, SPBOOK_SYM, AD_FIRE);
X  #endif
X  		if(resists_fire(pd)) {
X! 		    if (vis)
X! 			pline("The fire doesn't seem to burn %s!",
X! 								mon_nam(mdef));
X  		    shieldeff(mdef->mx, mdef->my);
X  #ifdef GOLEMS
X  		    golemeffects(mdef, AD_FIRE, tmp);
X***************
X*** 410,417 ****
X  		}
X  		if(vis) pline("%s is covered in frost!", Monnam(mdef));
X  		if(resists_cold(pd)) {
X! 		    pline("The frost doesn't seem to chill %s!",
X! 			mon_nam(mdef));
X  		    shieldeff(mdef->mx, mdef->my);
X  #ifdef GOLEMS
X  		    golemeffects(mdef, AD_COLD, tmp);
X--- 413,421 ----
X  		}
X  		if(vis) pline("%s is covered in frost!", Monnam(mdef));
X  		if(resists_cold(pd)) {
X! 		    if (vis)
X! 			pline("The frost doesn't seem to chill %s!",
X! 								mon_nam(mdef));
X  		    shieldeff(mdef->mx, mdef->my);
X  #ifdef GOLEMS
X  		    golemeffects(mdef, AD_COLD, tmp);
X***************
X*** 428,434 ****
X  		if(vis) pline("%s gets zapped!", Monnam(mdef));
X  		tmp += destroy_mitem(mdef, WAND_SYM, AD_ELEC);
X  		if(resists_elec(pd)) {
X! 		    pline("The zap doesn't shock %s!", mon_nam(mdef));
X  		    shieldeff(mdef->mx, mdef->my);
X  #ifdef GOLEMS
X  		    golemeffects(mdef, AD_ELEC, tmp);
X--- 432,438 ----
X  		if(vis) pline("%s gets zapped!", Monnam(mdef));
X  		tmp += destroy_mitem(mdef, WAND_SYM, AD_ELEC);
X  		if(resists_elec(pd)) {
X! 		    if (vis) pline("The zap doesn't shock %s!", mon_nam(mdef));
X  		    shieldeff(mdef->mx, mdef->my);
X  #ifdef GOLEMS
X  		    golemeffects(mdef, AD_ELEC, tmp);
X***************
X*** 444,453 ****
X  		    break;
X  		}
X  		if(resists_acid(pd)) {
X! 		    pline("%s is covered in acid, but it seems harmless.",
X! 			Monnam(mdef));
X  		    tmp = 0;
X! 		} else {
X  		    pline("%s is covered in acid!", Monnam(mdef));
X  		    pline("It burns %s!", mon_nam(mdef));
X  		}
X--- 448,458 ----
X  		    break;
X  		}
X  		if(resists_acid(pd)) {
X! 		    if (vis)
X! 			pline("%s is covered in acid, but it seems harmless.",
X! 							Monnam(mdef));
X  		    tmp = 0;
X! 		} else if (vis) {
X  		    pline("%s is covered in acid!", Monnam(mdef));
X  		    pline("It burns %s!", mon_nam(mdef));
X  		}
X*** src/mhitu.c	Tue Jun 26 21:20:24 1990
X--- src/mhitu.c	Sat Jan  5 14:59:32 1991
X***************
X*** 665,670 ****
X--- 665,671 ----
X  #  ifdef POLYSELF
X  						&& !resists_drli(uasmon)
X  #  endif
X+ 						&& !defends(AD_DRLI, uwep)
X  									) {
X  			    if (Blind)
X  				You("feel an unholy blade drain your life!");
X*** src/mkmaze.c	Tue May 15 14:50:37 1990
X--- src/mkmaze.c	Wed Jan 30 12:05:06 1991
X***************
X*** 413,447 ****
X  bound_digging()
X  /* put a non-diggable boundary around the initial portion of a level map.
X   * assumes that no level will initially put things beyond the isok() range.
X   */
X  {
X  	register int x,y;
X! 	register boolean found;
X  	int xmin,xmax,ymin,ymax;
X  
X! 	found = FALSE;
X! 	for(xmin=1; !found; xmin++)
X! 		for(y=0; y<=ROWNO-1; y++)
X! 			if(levl[xmin][y].typ != STONE) found = TRUE;
X! 	xmin -= 2;
X  
X! 	found = FALSE;
X! 	for(xmax=COLNO-2; !found; xmax--)
X! 		for(y=0; y<=ROWNO-1; y++)
X! 			if(levl[xmax][y].typ != STONE) found = TRUE;
X! 	xmax += 2;
X  
X! 	found = FALSE;
X! 	for(ymin=1; !found; ymin++)
X! 		for(x=xmin; x<=xmax; x++)
X! 			if(levl[x][ymin].typ != STONE) found = TRUE;
X! 	ymin -= 2;
X  
X! 	found = FALSE;
X! 	for(ymax=ROWNO-2; !found; ymax--)
X! 		for(x=xmin; x<=xmax; x++)
X! 			if(levl[x][ymax].typ != STONE) found = TRUE;
X! 	ymax += 2;
X  
X  	for(x=xmin; x<=xmax; x++) {
X  		levl[x][ymin].diggable = W_NONDIGGABLE;
X--- 413,479 ----
X  bound_digging()
X  /* put a non-diggable boundary around the initial portion of a level map.
X   * assumes that no level will initially put things beyond the isok() range.
X+  *
X+  * we can't bound unconditionally on the last line with something in it,
X+  * because that something might be a niche which was already reachable,
X+  * so the boundary would be breached
X+  *
X+  * we can't bound unconditionally on one beyond the last line, because
X+  * that provides a window of abuse for WALLIFIED_MAZE special levels
X   */
X  {
X  	register int x,y;
X! 	register unsigned typ;
X! 	boolean found, nonwall;
X  	int xmin,xmax,ymin,ymax;
X  
X! 	found = nonwall = FALSE;
X! 	for(xmin=0; !found; xmin++)
X! 		for(y=0; y<=ROWNO-1; y++) {
X! 			typ = levl[xmin][y].typ;
X! 			if(typ != STONE) {
X! 				found = TRUE;
X! 				if(!IS_WALL(typ)) nonwall = TRUE;
X! 			}
X! 		}
X! 	xmin -= (nonwall ? 2 : 1);
X! 	if (xmin < 0) xmin = 0;
X  
X! 	found = nonwall = FALSE;
X! 	for(xmax=COLNO-1; !found; xmax--)
X! 		for(y=0; y<=ROWNO-1; y++) {
X! 			typ = levl[xmax][y].typ;
X! 			if(typ != STONE) {
X! 				found = TRUE;
X! 				if(!IS_WALL(typ)) nonwall = TRUE;
X! 			}
X! 		}
X! 	xmax += (nonwall ? 2 : 1);
X! 	if (xmax >= COLNO) xmax = COLNO-1;
X  
X! 	found = nonwall = FALSE;
X! 	for(ymin=0; !found; ymin++)
X! 		for(x=xmin; x<=xmax; x++) {
X! 			typ = levl[x][ymin].typ;
X! 			if(typ != STONE) {
X! 				found = TRUE;
X! 				if(!IS_WALL(typ)) nonwall = TRUE;
X! 			}
X! 		}
X! 	ymin -= (nonwall ? 2 : 1);
X! 	if (ymin < 0) ymin = 0;
X  
X! 	found = nonwall = FALSE;
X! 	for(ymax=ROWNO-1; !found; ymax--)
X! 		for(x=xmin; x<=xmax; x++) {
X! 			typ = levl[x][ymax].typ;
X! 			if(typ != STONE) {
X! 				found = TRUE;
X! 				if(!IS_WALL(typ)) nonwall = TRUE;
X! 			}
X! 		}
X! 	ymax += (nonwall ? 2 : 1);
X! 	if (ymax >= ROWNO) ymax = ROWNO-1;
X  
X  	for(x=xmin; x<=xmax; x++) {
X  		levl[x][ymin].diggable = W_NONDIGGABLE;
X*** src/mon.c	Tue Jun 26 21:20:25 1990
X--- src/mon.c	Tue Feb  5 15:37:59 1991
X***************
X*** 3,17 ****
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X  /* Aztec C on amiga doesn't recognize defined() at this point!
X!    Neither does the Mac Lightspeed C v.3  compiler. If you're using
X!    precompiled headers, you don't want this either */
X! #ifndef AZTEC_C
X! #ifndef THINK_C
X! #if defined(MICROPORT_BUG) || (!defined(LINT) && !defined(__STDC__))
X! #define MKROOM_H
X! #endif /* Avoid the microport bug */
X! #endif
X! #endif
X  
X  #include "hack.h"
X  #include "mfndpos.h"
X--- 3,18 ----
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X  /* Aztec C on amiga doesn't recognize defined() at this point!
X!    Neither does the Mac Lightspeed C v.3  compiler. */
X! #ifdef MICROPORT_BUG		/* comment line for pre-compiled headers */
X! # define MKROOM_H		/* comment line for pre-compiled headers */
X! #else				/* comment line for pre-compiled headers */
X! # ifndef LINT			/* comment line for pre-compiled headers */
X! #  ifndef __STDC__		/* comment line for pre-compiled headers */
X! #   define MKROOM_H		/* comment line for pre-compiled headers */
X! #  endif			/* comment line for pre-compiled headers */
X! # endif				/* comment line for pre-compiled headers */
X! #endif				/* comment line for pre-compiled headers */
X  
X  #include "hack.h"
X  #include "mfndpos.h"
X***************
X*** 30,35 ****
X--- 31,37 ----
X  STATIC_DCL void NDECL(dmonsfree);
X  
X  #ifdef OVL1
X+ #define warnDelay 10
X  long lastwarntime;
X  int lastwarnlev;
X  const char *warnings[] = {
X***************
X*** 125,135 ****
X--- 127,139 ----
X  		pieces = d(2,6);
X  		while (pieces--)
X  			obj = mksobj_at(IRON_CHAIN, x, y);
X+ 		mtmp->mnamelth = 0;
X  		break;
X  	    case PM_CLAY_GOLEM:
X  		obj = mksobj_at(ROCK, x, y);
X  		obj->quan = rn2(20) + 100;
X  		obj->owt = weight(obj);
X+ 		mtmp->mnamelth = 0;
X  		break;
X  	    case PM_STONE_GOLEM:
X  		obj = mkcorpstat(STATUE, mdat, x, y);
X***************
X*** 138,148 ****
X--- 142,154 ----
X  		pieces = d(2,4);
X  		while(pieces--)
X  			obj = mksobj_at(QUARTERSTAFF, x, y);
X+ 		mtmp->mnamelth = 0;
X  		break;
X  	    case PM_LEATHER_GOLEM:
X  		pieces = d(2,4);
X  		while(pieces--)
X  			obj = mksobj_at(LEATHER_ARMOR, x, y);
X+ 		mtmp->mnamelth = 0;
X  		break;
X  #endif
X  	    default_1:
X***************
X*** 187,192 ****
X--- 193,199 ----
X  movemon()
X  {
X  	register struct monst *mtmp;
X+ 	boolean check_tame = TRUE;
X  
X  	warnlevel = 0;
X  
X***************
X*** 201,208 ****
X  		 * attack the tame monster back (which it's permitted to do
X  		 * only if it hasn't made its move yet).
X  		 */
X! 		for(mtmp = fmon; mtmp; mtmp = mtmp->nmon)
X  			if(mtmp->mlstmv < moves && mtmp->mtame) goto next_mon;
X  		for(mtmp = fmon; mtmp; mtmp = mtmp->nmon)
X  			if(mtmp->mlstmv < moves && !mtmp->mtame) goto next_mon;
X  		/* treated all monsters */
X--- 208,218 ----
X  		 * attack the tame monster back (which it's permitted to do
X  		 * only if it hasn't made its move yet).
X  		 */
X! 		if (check_tame) {
X! 		    for(mtmp = fmon; mtmp; mtmp = mtmp->nmon)
X  			if(mtmp->mlstmv < moves && mtmp->mtame) goto next_mon;
X+ 		    check_tame = FALSE;		/* tame monsters all done */
X+ 		}
X  		for(mtmp = fmon; mtmp; mtmp = mtmp->nmon)
X  			if(mtmp->mlstmv < moves && !mtmp->mtame) goto next_mon;
X  		/* treated all monsters */
X***************
X*** 307,315 ****
X  	}
X  #ifdef NAMED_ITEMS
X  	if (warnlevel == 100) {
X  		Your("%s %s!", aobjnam(uwep, "glow"),
X! 			Hallucination ? hcolor() : light_blue);
X! 		warnlevel = 0;
X  	}
X  #endif
X  	warnlevel -= u.ulevel;
X--- 317,331 ----
X  	}
X  #ifdef NAMED_ITEMS
X  	if (warnlevel == 100) {
X+ 	    if(!Blind && (warnlevel > lastwarnlev
X+ 				|| moves > lastwarntime + warnDelay)) {
X  		Your("%s %s!", aobjnam(uwep, "glow"),
X! 		    Hallucination ? hcolor() : light_blue);
X! 		lastwarnlev = warnlevel;
X! 		lastwarntime = moves;
X! 	    }
X! 	    warnlevel = 0;
X! 	    return;
X  	}
X  #endif
X  	warnlevel -= u.ulevel;
X***************
X*** 316,322 ****
X  	if(warnlevel >= SIZE(warnings))
X  		warnlevel = SIZE(warnings)-1;
X  	if(!Blind && warnlevel >= 0)
X! 	if(warnlevel > lastwarnlev || moves > lastwarntime + 5){
X  	    register const char *rr;
X  	
X  	    switch((int) (Warning & (LEFT_RING | RIGHT_RING))){
X--- 332,338 ----
X  	if(warnlevel >= SIZE(warnings))
X  		warnlevel = SIZE(warnings)-1;
X  	if(!Blind && warnlevel >= 0)
X! 	if(warnlevel > lastwarnlev || moves > lastwarntime + warnDelay) {
X  	    register const char *rr;
X  	
X  	    switch((int) (Warning & (LEFT_RING | RIGHT_RING))){
X***************
X*** 405,410 ****
X--- 421,429 ----
X  	for (otmp = level.objects[mtmp->mx][mtmp->my]; otmp; otmp = otmp2) {
X  	    otmp2 = otmp->nexthere;
X  	    if(objects[otmp->otyp].oc_material <= WOOD) {
X+ 		if (otmp->otyp == CORPSE && otmp->corpsenm == PM_COCKATRICE
X+ 						&& !resists_ston(mtmp->data))
X+ 		    continue;
X  		if (cansee(mtmp->mx,mtmp->my) && flags.verbose)
X  		    pline("%s eats %s!", Monnam(mtmp),
X  			    distant_name(otmp, doname));
X***************
X*** 676,692 ****
X  		{ register struct trap *ttmp = t_at(nx, ny);
X  		  register long tt;
X  			if(ttmp) {
X! /*				tt = 1L << ttmp->ttyp;*/
X! /* why don't we just have code look like what it's supposed to do? then it
X! /* might start working for every case. try this instead: -sac */
X! 				tt = (ttmp->ttyp < TRAPNUM && ttmp->ttyp);
X! 				/* below if added by GAN 02/06/87 to avoid
X! 				 * traps out of range
X! 				 */
X! 				if(!(tt & ALLOW_TRAPS))  {
X  impossible("A monster looked at a very strange trap of type %d.", ttmp->ttyp);
X  					continue;
X  				}
X  				if(mon->mtrapseen & tt) {
X  
X  					if(!(flag & tt)) continue;
X--- 695,705 ----
X  		{ register struct trap *ttmp = t_at(nx, ny);
X  		  register long tt;
X  			if(ttmp) {
X! 				if(ttmp->ttyp >= TRAPNUM || ttmp->ttyp == 0)  {
X  impossible("A monster looked at a very strange trap of type %d.", ttmp->ttyp);
X  					continue;
X  				}
X+ 				tt = 1L << ttmp->ttyp;
X  				if(mon->mtrapseen & tt) {
X  
X  					if(!(flag & tt)) continue;
X***************
X*** 1303,1311 ****
X  		return(TRUE);
X  	} else
X  	    if(levl[mtmp->mx][mtmp->my].typ == ROOM)  {
X! 		(void) maketrap(mtmp->mx, mtmp->my, MONST_TRAP);
X  		/* override type selection */
X- 		ftrap->pm = monsndx(mtmp->data);
X  		mondead(mtmp);
X  		return(TRUE);
X  	    }
X--- 1316,1324 ----
X  		return(TRUE);
X  	} else
X  	    if(levl[mtmp->mx][mtmp->my].typ == ROOM)  {
X! 		maketrap(mtmp->mx, mtmp->my, MONST_TRAP)->pm =
X! 			monsndx(mtmp->data);
X  		/* override type selection */
X  		mondead(mtmp);
X  		return(TRUE);
X  	    }
X*** src/monmove.c	Thu May 31 00:31:43 1990
X--- src/monmove.c	Sat Jan  5 15:07:17 1991
X***************
X*** 379,385 ****
X  	register struct monst *mtmp2;
X  	register int nx,ny,omx,omy,appr,nearer,cnt,i,j;
X  	xchar gx,gy,nix,niy,chcnt;
X! 	schar chi;
X  	boolean likegold=0, likegems=0, likeobjs=0, likemagic=0, conceals=0;
X  	boolean likerock=0, can_tunnel=0;
X  	boolean can_open=0, can_unlock=0, doorbuster=0;
X--- 379,385 ----
X  	register struct monst *mtmp2;
X  	register int nx,ny,omx,omy,appr,nearer,cnt,i,j;
X  	xchar gx,gy,nix,niy,chcnt;
X! 	int chi;        /* could be schar except for stupid Sun-2 compiler */
X  	boolean likegold=0, likegems=0, likeobjs=0, likemagic=0, conceals=0;
X  	boolean likerock=0, can_tunnel=0;
X  	boolean can_open=0, can_unlock=0, doorbuster=0;
X***************
X*** 560,566 ****
X  			  otmp->otyp < LAST_GEM + 6) ||
X  			 (conceals && !cansee(otmp->ox,otmp->oy)) ||
X  			 (ptr == &mons[PM_GELATINOUS_CUBE] &&
X! 			  !index(indigestion, otmp->olet))
X  			 ) {
X  			  if(can_carry(mtmp,otmp))
X  			    if(ptr->mlet != S_UNICORN ||
X--- 560,568 ----
X  			  otmp->otyp < LAST_GEM + 6) ||
X  			 (conceals && !cansee(otmp->ox,otmp->oy)) ||
X  			 (ptr == &mons[PM_GELATINOUS_CUBE] &&
X! 			  !index(indigestion, otmp->olet) &&
X! 			  !(otmp->otyp == CORPSE &&
X! 				  otmp->corpsenm == PM_COCKATRICE))
X  			 ) {
X  			  if(can_carry(mtmp,otmp))
X  			    if(ptr->mlet != S_UNICORN ||
X
END_OF_FILE
if test 50088 -ne `wc -c <'patch10.02'`; then
    echo shar: \"'patch10.02'\" unpacked with wrong size!
fi
# end of 'patch10.02'
echo shar: End of archive 5 \(of 8\).
cp /dev/null ark5isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 8 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
