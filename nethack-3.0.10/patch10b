Path: utzoo!utgpu!watserv1!watmath!att!linac!pacific.mps.ohio-state.edu!zaphod.mps.ohio-state.edu!sdd.hp.com!elroy.jpl.nasa.gov!decwrl!ogicse!zephyr.ens.tek.com!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v12i026:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Patch10b
Message-ID: <6984@tekred.CNA.TEK.COM>
Date: 9 Feb 91 01:37:28 GMT
Sender: news@tekred.CNA.TEK.COM
Lines: 2047
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 12, Issue 26
Archive-name: NetHack3/Patch10b
Patch-To: NetHack3: Volume 7, Issue 56-93
Environment: 



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 2 (of 8)."
# Contents:  do_patch10.sh patch10.03
# Wrapped by billr@saab on Fri Feb  8 17:18:57 1991
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'do_patch10.sh' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'do_patch10.sh'\" to \"'do_patch10.sh.orig'\"
  mv -f 'do_patch10.sh' 'do_patch10.sh.orig'
fi
echo shar: Extracting \"'do_patch10.sh'\" \(354 characters\)
sed "s/^X//" >'do_patch10.sh' <<'END_OF_FILE'
X#! /bin/sh
X# script to call patch to apply diff files
X# make sure all of the patch files (and this file) are in your top level
X# NetHack directory
X#
Xecho "deleting outdated files"
Xrm -f others/exesmurf.uu others/splitf.c others/splitf.uu others/suputils.doc
Xecho "applying patch10"
Xcat patch10.?? | patch -p
Xecho "all patches applied, check for rejects"
END_OF_FILE
if test 354 -ne `wc -c <'do_patch10.sh'`; then
    echo shar: \"'do_patch10.sh'\" unpacked with wrong size!
fi
chmod +x 'do_patch10.sh'
# end of 'do_patch10.sh'
if test -f 'patch10.03' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'patch10.03'\" to \"'patch10.03.orig'\"
  mv -f 'patch10.03' 'patch10.03.orig'
fi
echo shar: Extracting \"'patch10.03'\" \(52441 characters\)
sed "s/^X//" >'patch10.03' <<'END_OF_FILE'
X*** src/mthrowu.c	Sat May 26 23:17:25 1990
X--- src/mthrowu.c	Fri Feb  1 10:57:41 1991
X***************
X*** 6,12 ****
X  
X  STATIC_DCL int FDECL(movedist,(int,int,int,int));
X  STATIC_DCL void FDECL(drop_throw,(struct obj *,BOOLEAN_P,int,int));
X! STATIC_DCL void FDECL(m_throw,(int,int,int,int,int,struct obj *));
X  
X  #define URETREATING(x,y) (movedist(u.ux,u.uy,x,y) > movedist(u.ux0,u.uy0,x,y))
X  
X--- 6,12 ----
X  
X  STATIC_DCL int FDECL(movedist,(int,int,int,int));
X  STATIC_DCL void FDECL(drop_throw,(struct obj *,BOOLEAN_P,int,int));
X! STATIC_DCL void FDECL(m_throw,(struct monst *,int,int,int,int,int,struct obj *));
X  
X  #define URETREATING(x,y) (movedist(u.ux,u.uy,x,y) > movedist(u.ux0,u.uy0,x,y))
X  
X***************
X*** 99,105 ****
X  #ifdef OVL1
X  
X  STATIC_OVL void
X! m_throw(x, y, dx, dy, range, obj)
X  	register int x,y,dx,dy,range;		/* direction and range */
X  	register struct obj *obj;
X  {
X--- 99,106 ----
X  #ifdef OVL1
X  
X  STATIC_OVL void
X! m_throw(mon, x, y, dx, dy, range, obj)
X! 	register struct monst *mon;
X  	register int x,y,dx,dy,range;		/* direction and range */
X  	register struct obj *obj;
X  {
X***************
X*** 119,129 ****
X  	 * after obj.
X  	 */
X  	obj->nobj = singleobj->nobj;
X  
X  	if(sym) {
X  		tmp_at(-1, sym);	/* open call */
X  #ifdef TEXTCOLOR
X! 		tmp_at(-3, (int)objects[obj->otyp].oc_color);
X  #else
X  		tmp_at(-3, (int)AT_OBJ);
X  #endif
X--- 120,146 ----
X  	 * after obj.
X  	 */
X  	obj->nobj = singleobj->nobj;
X+ 	/* Get rid of object.  This cannot be done later on; what if the
X+ 	 * player dies before then, leaving the monster with 0 daggers?
X+ 	 * (This caused the infamous 2^32-1 orcish dagger bug).
X+ 	 */
X+ 	if (!obj->quan) {
X+ 		if(obj->olet == VENOM_SYM) {
X+ 			/* venom is not in the monster's inventory chain */
X+ 			free((genericptr_t) obj);
X+ 		} else {
X+ 			m_useup(mon, obj);
X+ 		}
X+ 	}
X  
X+ 	/* Note: drop_throw may destroy singleobj.  Since obj must be destroyed
X+ 	 * early to avoid the dagger bug, anyone who modifies this code should
X+ 	 * be careful not to use either one after it's been freed.
X+ 	 */
X  	if(sym) {
X  		tmp_at(-1, sym);	/* open call */
X  #ifdef TEXTCOLOR
X! 		tmp_at(-3, (int)objects[singleobj->otyp].oc_color);
X  #else
X  		tmp_at(-3, (int)AT_OBJ);
X  #endif
X***************
X*** 137,143 ****
X  		if(MON_AT(bhitpos.x, bhitpos.y)) {
X  		    mtmp = m_at(bhitpos.x,bhitpos.y);
X  
X! 		    if(mtmp->data->ac + 8 + obj->spe <= rnd(20)) {
X  			if (!vis) pline("It is missed.");
X  			else miss(distant_name(singleobj,xname), mtmp);
X  			if (!range) { /* Last position; object drops */
X--- 154,160 ----
X  		if(MON_AT(bhitpos.x, bhitpos.y)) {
X  		    mtmp = m_at(bhitpos.x,bhitpos.y);
X  
X! 		    if(mtmp->data->ac + 8 + singleobj->spe <= rnd(20)) {
X  			if (!vis) pline("It is missed.");
X  			else miss(distant_name(singleobj,xname), mtmp);
X  			if (!range) { /* Last position; object drops */
X***************
X*** 145,158 ****
X  			    break;
X  			}
X  		    } else {
X! 			damage = dmgval(obj, mtmp->data);
X  			if (damage < 1) damage = 1;
X! 			if (obj->otyp==ACID_VENOM && resists_acid(mtmp->data))
X  			    damage = 0;
X  			if (!vis) pline("It is hit%s", exclam(damage));
X  			else hit(distant_name(singleobj,xname),
X  							mtmp,exclam(damage));
X! 			if (obj->opoisoned) {
X  			    if (resists_poison(mtmp->data)) {
X  				if (vis)
X  				  pline("The poison doesn't seem to affect %s.",
X--- 162,175 ----
X  			    break;
X  			}
X  		    } else {
X! 			damage = dmgval(singleobj, mtmp->data);
X  			if (damage < 1) damage = 1;
X! 			if (singleobj->otyp==ACID_VENOM && resists_acid(mtmp->data))
X  			    damage = 0;
X  			if (!vis) pline("It is hit%s", exclam(damage));
X  			else hit(distant_name(singleobj,xname),
X  							mtmp,exclam(damage));
X! 			if (singleobj->opoisoned) {
X  			    if (resists_poison(mtmp->data)) {
X  				if (vis)
X  				  pline("The poison doesn't seem to affect %s.",
X***************
X*** 166,172 ****
X  				}
X  			    }
X  			}
X! 			if (obj->otyp==SILVER_ARROW && (is_were(mtmp->data)
X  				|| is_demon(mtmp->data)
X  				|| mtmp->data->mlet == S_VAMPIRE
X  				|| (mtmp->data->mlet==S_IMP
X--- 183,189 ----
X  				}
X  			    }
X  			}
X! 			if (singleobj->otyp==SILVER_ARROW && (is_were(mtmp->data)
X  				|| is_demon(mtmp->data)
X  				|| mtmp->data->mlet == S_VAMPIRE
X  				|| (mtmp->data->mlet==S_IMP
X***************
X*** 176,182 ****
X  			    else pline("Its flesh is seared!");
X  			    damage += rnd(20);
X  			}
X! 			if (obj->otyp==ACID_VENOM && cansee(mtmp->mx,mtmp->my)){
X  			    if (resists_acid(mtmp->data)) {
X  				pline("%s is unaffected.", vis ? Monnam(mtmp)
X  					: "It");
X--- 193,199 ----
X  			    else pline("Its flesh is seared!");
X  			    damage += rnd(20);
X  			}
X! 			if (singleobj->otyp==ACID_VENOM && cansee(mtmp->mx,mtmp->my)){
X  			    if (resists_acid(mtmp->data)) {
X  				pline("%s is unaffected.", vis ? Monnam(mtmp)
X  					: "It");
X***************
X*** 194,201 ****
X  			    mondied(mtmp);
X  			}
X  
X! 			if((obj->otyp == CREAM_PIE) ||
X! 			   (obj->otyp == BLINDING_VENOM)) {
X  			    if (vis)
X  				pline("%s is blinded by the %s.",
X  				      Monnam(mtmp), xname(singleobj));
X--- 211,218 ----
X  			    mondied(mtmp);
X  			}
X  
X! 			if((singleobj->otyp == CREAM_PIE) ||
X! 			   (singleobj->otyp == BLINDING_VENOM)) {
X  			    if (vis)
X  				pline("%s is blinded by the %s.",
X  				      Monnam(mtmp), xname(singleobj));
X***************
X*** 215,221 ****
X  		if (bhitpos.x == u.ux && bhitpos.y == u.uy) {
X  			if (multi) nomul(0);
X  
X! 			switch(obj->otyp) {
X  			    int dam;
X  			    case CREAM_PIE:
X  			    case BLINDING_VENOM:
X--- 232,238 ----
X  		if (bhitpos.x == u.ux && bhitpos.y == u.uy) {
X  			if (multi) nomul(0);
X  
X! 			switch(singleobj->otyp) {
X  			    int dam;
X  			    case CREAM_PIE:
X  			    case BLINDING_VENOM:
X***************
X*** 222,240 ****
X  				hitu = thitu(8, 0, singleobj, xname(singleobj));
X  				break;
X  			    default:
X! 				dam = dmgval(obj, uasmon);
X  				if (dam < 1) dam = 1;
X! 				hitu = thitu(8+obj->spe, dam, singleobj,
X  					xname(singleobj));
X  			}
X! 			if (hitu && obj->opoisoned)
X  			    /* it's safe to call xname twice because it's the
X  			       same object both times... */
X  			    poisoned(xname(singleobj), A_STR, xname(singleobj), 10);
X! 			if(hitu && (obj->otyp == CREAM_PIE ||
X! 				     obj->otyp == BLINDING_VENOM)) {
X  			    blindinc = rnd(25);
X! 			    if(obj->otyp == CREAM_PIE) {
X  				if(!Blind) pline("Yecch!  You've been creamed.");
X  				else	pline("There's something sticky all over your %s.", body_part(FACE));
X  			    } else {	/* venom in the eyes */
X--- 239,257 ----
X  				hitu = thitu(8, 0, singleobj, xname(singleobj));
X  				break;
X  			    default:
X! 				dam = dmgval(singleobj, uasmon);
X  				if (dam < 1) dam = 1;
X! 				hitu = thitu(8+singleobj->spe, dam, singleobj,
X  					xname(singleobj));
X  			}
X! 			if (hitu && singleobj->opoisoned)
X  			    /* it's safe to call xname twice because it's the
X  			       same object both times... */
X  			    poisoned(xname(singleobj), A_STR, xname(singleobj), 10);
X! 			if(hitu && (singleobj->otyp == CREAM_PIE ||
X! 				     singleobj->otyp == BLINDING_VENOM)) {
X  			    blindinc = rnd(25);
X! 			    if(singleobj->otyp == CREAM_PIE) {
X  				if(!Blind) pline("Yecch!  You've been creamed.");
X  				else	pline("There's something sticky all over your %s.", body_part(FACE));
X  			    } else {	/* venom in the eyes */
X***************
X*** 343,349 ****
X  		    if (canseemon(mtmp))
X  			pline("%s %s %s!", Monnam(mtmp), verb, an(xname(otmp)));
X  		    otmp->quan = savequan;
X! 		    m_throw(mtmp->mx, mtmp->my, sgn(tbx), sgn(tby), 
X  			movedist(mtmp->mx,mtmp->mux,mtmp->my,mtmp->muy), otmp);
X  		    if (!otmp->quan) m_useup(mtmp, otmp);
X  		    nomul(0);
X--- 360,366 ----
X  		    if (canseemon(mtmp))
X  			pline("%s %s %s!", Monnam(mtmp), verb, an(xname(otmp)));
X  		    otmp->quan = savequan;
X! 		    m_throw(mtmp, mtmp->mx, mtmp->my, sgn(tbx), sgn(tby), 
X  			movedist(mtmp->mx,mtmp->mux,mtmp->my,mtmp->muy), otmp);
X  		    if (!otmp->quan) m_useup(mtmp, otmp);
X  		    nomul(0);
X***************
X*** 386,392 ****
X  		if(!rn2(BOLT_LIM-movedist(mtmp->mx,mtmp->mux,mtmp->my,mtmp->muy))) {
X  		    if (canseemon(mtmp))
X  			pline("%s spits venom!", Monnam(mtmp));
X! 		    m_throw(mtmp->mx, mtmp->my, sgn(tbx), sgn(tby), 
X  			movedist(mtmp->mx,mtmp->mux,mtmp->my,mtmp->muy), otmp);
X  		    nomul(0);
X  		    return 0;
X--- 403,409 ----
X  		if(!rn2(BOLT_LIM-movedist(mtmp->mx,mtmp->mux,mtmp->my,mtmp->muy))) {
X  		    if (canseemon(mtmp))
X  			pline("%s spits venom!", Monnam(mtmp));
X! 		    m_throw(mtmp, mtmp->mx, mtmp->my, sgn(tbx), sgn(tby), 
X  			movedist(mtmp->mx,mtmp->mux,mtmp->my,mtmp->muy), otmp);
X  		    nomul(0);
X  		    return 0;
X*** src/o_init.c	Wed May  9 09:24:18 1990
X--- src/o_init.c	Wed Jan 30 08:48:38 1991
X***************
X*** 241,247 ****
X  #ifdef MACOS
X  	char	*descr[TOTAL_OBJS];
X  #endif
X! 	struct objclass *now = &objects[0];
X  	bwrite(fd, (genericptr_t)&now, sizeof now);
X  	bwrite(fd, (genericptr_t)bases, sizeof bases);
X  	bwrite(fd, (genericptr_t)disco, sizeof disco);
X--- 241,247 ----
X  #ifdef MACOS
X  	char	*descr[TOTAL_OBJS];
X  #endif
X! 	const char *now = objects[0].oc_name; /* location of "strange object" */
X  	bwrite(fd, (genericptr_t)&now, sizeof now);
X  	bwrite(fd, (genericptr_t)bases, sizeof bases);
X  	bwrite(fd, (genericptr_t)disco, sizeof disco);
X***************
X*** 273,280 ****
X  {
X  	register int i;
X  	unsigned int len;
X! 	struct objclass *then;
X! 	long differ;
X  #ifdef MACOS
X  	/* provides position-independent save & restore */
X  	/* by giving each object a number, keep track of it */
X--- 273,280 ----
X  {
X  	register int i;
X  	unsigned int len;
X! 	char *then;	/* old location of "strange object" */
X! 	register int differ;	/*(ptrdiff_t)*/
X  #ifdef MACOS
X  	/* provides position-independent save & restore */
X  	/* by giving each object a number, keep track of it */
X***************
X*** 305,334 ****
X  		objects[i].oc_descr = d[switches[i]].descr;
X  	}
X  #else
X! # if !defined(MSDOS) && !defined(M_XENIX) && !defined(HPUX) && !defined(VAXC)
X! 	differ = (genericptr_t)&objects[0] - (genericptr_t)then;
X! # else
X! 	differ = (long)&objects[0] - (long)then;
X! # endif
X  #endif	/* MACOS */
X  	for(i=0; i < TOTAL_OBJS; i++) {
X  #ifndef MACOS
X! 		if (objects[i].oc_name) {
X! # if !defined(MSDOS) && !defined(M_XENIX) && !defined(HPUX) && !defined(VAXC)
X  			objects[i].oc_name += differ;
X! # else
X! 			objects[i].oc_name =
X! 			    (const char *)((long)(objects[i].oc_name) + differ);
X! # endif
X! 		}
X! 		if (objects[i].oc_descr) {
X! # if !defined(MSDOS) && !defined(M_XENIX) && !defined(HPUX) && !defined(VAXC)
X  			objects[i].oc_descr += differ;
X- # else
X- 			objects[i].oc_descr =
X- 			    (const char *)((long)(objects[i].oc_descr) + differ);
X- # endif
X- 		}
X  #endif /* MACOS */
X  		if (objects[i].oc_uname) {
X  			mread(fd, (genericptr_t) &len, sizeof len);
X--- 305,318 ----
X  		objects[i].oc_descr = d[switches[i]].descr;
X  	}
X  #else
X! 	differ = objects[0].oc_name - then;	/* note: expected to be 0 */
X  #endif	/* MACOS */
X  	for(i=0; i < TOTAL_OBJS; i++) {
X  #ifndef MACOS
X! 		if (differ && objects[i].oc_name)
X  			objects[i].oc_name += differ;
X! 		if (differ && objects[i].oc_descr)
X  			objects[i].oc_descr += differ;
X  #endif /* MACOS */
X  		if (objects[i].oc_uname) {
X  			mread(fd, (genericptr_t) &len, sizeof len);
X*** src/objnam.c	Mon Jun  4 13:04:34 1990
X--- src/objnam.c	Tue Jan 15 17:50:50 1991
X***************
X*** 9,15 ****
X  
X  /* "an uncursed partly eaten guardian naga hatchling corpse" */
X  #define	PREFIX	50
X! #define SCHAR_MAX 127
X  
X  #ifndef OVLB
X  
X--- 9,15 ----
X  
X  /* "an uncursed partly eaten guardian naga hatchling corpse" */
X  #define	PREFIX	50
X! #define SCHAR_LIM 127
X  
X  #ifndef OVLB
X  
X***************
X*** 1175,1182 ****
X  		spesgn = -1;	/* cheaters get what they deserve */
X  		spe = abs(spe);
X  	}
X! 	if (spe > SCHAR_MAX)
X! 		spe = SCHAR_MAX;
X  
X  	/* now we have the actual name, as delivered by xname, say
X  		green potions called whisky
X--- 1175,1182 ----
X  		spesgn = -1;	/* cheaters get what they deserve */
X  		spe = abs(spe);
X  	}
X! 	if (spe > SCHAR_LIM)
X! 		spe = SCHAR_LIM;
X  
X  	/* now we have the actual name, as delivered by xname, say
X  		green potions called whisky
X*** src/options.c	Tue Jun 26 21:20:29 1990
X--- src/options.c	Tue Jan  8 09:39:45 1991
X***************
X*** 18,23 ****
X--- 18,26 ----
X  initoptions()
X  {
X  	register char *opts;
X+ #ifdef MACOS
X+ 	char keepname[PL_NSIZ];  /* for save file starts */
X+ #endif
X  
X  	flags.time = flags.nonews = flags.notombstone = flags.end_own =
X  	flags.standout = flags.nonull = flags.ignintr = FALSE;
X***************
X*** 55,61 ****
X--- 58,67 ----
X  	read_config_file();
X  #endif /* MSDOS */
X  #ifdef MACOS
X+ 	if (plname[0] == '\0') keepname[0] = '\0';
X+ 	else Strcpy(keepname, plname);  /* keep name from save file */
X  	read_config_file();
X+ 	if (keepname[0] != '\0') Strcpy(plname, keepname);
X  	flags.standout = TRUE;	
X  #endif
X  	if(opts = getenv("NETHACKOPTIONS"))
X***************
X*** 62,70 ****
X  		parseoptions(opts,TRUE);
X  #ifdef TUTTI_FRUTTI
X  	(void)fruitadd(pl_fruit);
X! 	objects[SLIME_MOLD].oc_name = "\033";
X! 	/* Put something untypable in there */
X! 	/* We cannot just use NULL because that marks the end of objects */
X  #endif
X  }
X  
X--- 68,78 ----
X  		parseoptions(opts,TRUE);
X  #ifdef TUTTI_FRUTTI
X  	(void)fruitadd(pl_fruit);
X! 	/* Remove "slime mold" from list of object names; this will	*/
X! 	/* prevent it from being wished unless it's actually present	*/
X! 	/* as a named (or default) fruit.  Wishing for "fruit" will	*/
X! 	/* result in the player's preferred fruit [better than "\033"].	*/
X! 	objects[SLIME_MOLD].oc_name = "fruit";
X  #endif
X  }
X  
X***************
X*** 171,177 ****
X  assign_ibm_graphics()
X  {
X  #ifdef ASCIIGRAPH
X! 	flags.IBMgraphics = TRUE;	/* not set from command line */
X  
X  	showsyms[S_vwall] = 0xb3;	/* meta-3, vertical rule */
X  	showsyms[S_hwall] = 0xc4;	/* meta-D, horizontal rule */
X--- 179,186 ----
X  assign_ibm_graphics()
X  {
X  #ifdef ASCIIGRAPH
X! 	flags.IBMgraphics = TRUE;
X! 	flags.DECgraphics = FALSE;
X  
X  	showsyms[S_vwall] = 0xb3;	/* meta-3, vertical rule */
X  	showsyms[S_hwall] = 0xc4;	/* meta-D, horizontal rule */
X***************
X*** 199,205 ****
X  assign_dec_graphics()
X  {
X  #ifdef TERMLIB
X! 	flags.DECgraphics = TRUE;	/* not set from command line */
X  
X  	showsyms[S_vwall] = 0xf8;	/* vertical rule */
X  	showsyms[S_hwall] = 0xf1;	/* horizontal rule */
X--- 208,215 ----
X  assign_dec_graphics()
X  {
X  #ifdef TERMLIB
X! 	flags.DECgraphics = TRUE;
X! 	flags.IBMgraphics = FALSE;
X  
X  	showsyms[S_vwall] = 0xf8;	/* vertical rule */
X  	showsyms[S_hwall] = 0xf1;	/* horizontal rule */
X***************
X*** 299,304 ****
X--- 309,317 ----
X  
X  	if (!strncmp(opts, "num", 3)) {
X  		flags.num_pad = !negated;
X+ #ifndef AMIGA
X+ 		if (!from_env) number_pad(flags.num_pad ? 1 : 0);
X+ #endif
X  		return;
X  	}
X  
X*** src/panic.c	Sun Mar  4 13:44:05 1990
X--- src/panic.c	Tue Jan 29 09:13:55 1991
X***************
X*** 6,12 ****
X   */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X! #define NEED_VARARGS
X  #include	"config.h"
X  
X  #ifdef MSDOS
X--- 6,12 ----
X   */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X! #define NEED_VARARGS /* Uses ... */	/* comment line for pre-compiled headers */
X  #include	"config.h"
X  
X  #ifdef MSDOS
X*** src/pickup.c	Tue Jun 26 21:20:30 1990
X--- src/pickup.c	Mon Feb  4 09:57:07 1991
X***************
X*** 278,284 ****
X  			pline("There %s %s here, but %s.",
X  				(obj->quan == 1) ? "is" : "are",
X  				doname(obj),
X! 				!invent ? "it is too heavy for you to lift"
X  					: "you cannot carry any more");
X  				if(obj->otyp == SCR_SCARE_MONSTER)
X  					if(obj->spe) obj->spe = 0;
X--- 278,287 ----
X  			pline("There %s %s here, but %s.",
X  				(obj->quan == 1) ? "is" : "are",
X  				doname(obj),
X! 				!invent ? 
X! 				(obj->quan == 1 ?
X! 				    "it is too heavy for you to lift"
X! 				  : "they are too heavy for you to lift")
X  					: "you cannot carry any more");
X  				if(obj->otyp == SCR_SCARE_MONSTER)
X  					if(obj->spe) obj->spe = 0;
X***************
X*** 619,636 ****
X  struct obj *obj;
X  {
X  	struct obj *otmp, *cobj;
X  
X  	cobj = obj->cobj;
X  	delete_contents(cobj);
X  
X  	for (otmp = invent; otmp; otmp = otmp->nobj)
X! 		if (otmp == cobj) break;
X  
X! 	if (otmp) {
X! 		You("see your %s blow apart!", xname(otmp));
X! 		useup(otmp);
X! 		/*return(0);*/
X! 	} else	panic("explode_bag: bag not in invent.");
X  }
X  
X  void
X--- 622,652 ----
X  struct obj *obj;
X  {
X  	struct obj *otmp, *cobj;
X+ 	boolean found = FALSE;
X  
X  	cobj = obj->cobj;
X  	delete_contents(cobj);
X  
X  	for (otmp = invent; otmp; otmp = otmp->nobj)
X! 		if (otmp == cobj) {
X! 			found = TRUE;
X! 			Your("%s blows apart!", xname(otmp));
X! 			useup(otmp);
X! 			break;
X! 		}
X  
X! 	if (!found) {
X! 	    /* maybe the bag was on the floor */
X! 	    for (otmp=level.objects[u.ux][u.uy]; otmp; otmp=otmp->nexthere)
X! 		if (otmp == cobj) {
X! 			found = TRUE;
X! 			pline("The %s blows apart!", xname(otmp));
X! 			useupf(otmp);
X! 			break;
X! 		}
X! 	}
X! 
X! 	if (!found) panic("explode_bag: bag not found.");
X  }
X  
X  void
X*** src/polyself.c	Thu May 31 00:31:48 1990
X--- src/polyself.c	Sat Jan  5 14:59:48 1991
X***************
X*** 123,130 ****
X--- 123,136 ----
X  		}
X  		(void)strcat(SAVEF, ".sav");
X  # else
X+ #  ifdef MACOS
X+ 		strncpy(SAVEF, plname, (FILENAME - 2));  /* .e */
X+ 		SAVEF[(FILENAME - 2)] = '\0';
X+ 		regularize(SAVEF);
X+ #  else
X  		Sprintf(SAVEF, "save/%d%s", getuid(), plname);
X  		regularize(SAVEF+5);		/* avoid . or / in name */
X+ #  endif
X  # endif
X  #endif
X  #ifdef WIZARD
X***************
X*** 135,140 ****
X--- 141,148 ----
X  	skinback();
X  	find_ac();
X  	if (sticky) uunstick();
X+ 	if(is_pool(u.ux,u.uy) && !Levitation && !u.ustuck && !Wwalking)
X+ 		drown();
X  #endif
X  }
X  
X***************
X*** 326,331 ****
X--- 334,342 ----
X  		pline("Use the command #sit to lay an egg.");
X  	}
X  	find_ac();
X+ 	if(is_pool(u.ux,u.uy) && !Levitation && !u.ustuck && !Wwalking
X+ 			&& !is_flyer(uasmon) && !is_swimmer(uasmon))
X+ 		drown();
X  	return(1);
X  }
X  
X***************
X*** 450,460 ****
X  	prme();
X  	flags.botl = 1;
X  	find_ac();
X  }
X  
X  int
X  dobreathe() {
X! 	if(!getdir(1)) return(0);
X  	if (rn2(4))
X  	    You("produce a loud and noxious belch.");
X  	else {
X--- 461,477 ----
X  	prme();
X  	flags.botl = 1;
X  	find_ac();
X+ 	if(is_pool(u.ux,u.uy) && !Levitation && !u.ustuck && !Wwalking)
X+ 		drown();
X  }
X  
X  int
X  dobreathe() {
X! 	if (Strangled) {
X! 	    You("can't breathe.  Sorry.");
X! 	    return(0);
X! 	}
X! 	if (!getdir(1)) return(0);
X  	if (rn2(4))
X  	    You("produce a loud and noxious belch.");
X  	else {
X*** src/potion.c	Fri Jun  1 16:59:24 1990
X--- src/potion.c	Thu Jan 31 11:24:54 1991
X***************
X*** 516,523 ****
X  #ifdef SPELLS
X  	case SPE_HASTE_SELF:
X  #endif
X! 		if(!(Fast & TIMEOUT))
X! 			You("are suddenly moving much faster.");
X  		else {
X  			Your("%s get new energy.",
X  				makeplural(body_part(LEG)));
X--- 516,524 ----
X  #ifdef SPELLS
X  	case SPE_HASTE_SELF:
X  #endif
X! 		if(!(Fast & ~INTRINSIC)) /* wwf@doe.carleton.ca */
X! 			You("are suddenly moving %sfaster.",
X! 				Fast ? "" : "much ");
X  		else {
X  			Your("%s get new energy.",
X  				makeplural(body_part(LEG)));
X***************
X*** 537,542 ****
X--- 538,546 ----
X  			if((dlevel > 1  || u.uhave_amulet) &&
X  							dlevel <= MAXLEVEL) { 
X  				You("rise up, through the ceiling!");
X+ # ifdef MACOS
X+ 				segments |= SEG_POTION;
X+ # endif
X  				goto_level((dlevel==1) ? ENDLEVEL
X  					: dlevel-1, FALSE, FALSE);
X  			} else You("have an uneasy feeling.");
X***************
X*** 543,551 ****
X  #else
X  			if(dlevel > 1 && dlevel <= MAXLEVEL) {
X  				You("rise up, through the ceiling!");
X! #ifdef MACOS
X  				segments |= SEG_POTION;
X! #endif
X  				goto_level(dlevel-1, FALSE, FALSE);
X  			} else You("have an uneasy feeling.");
X  #endif
X--- 547,555 ----
X  #else
X  			if(dlevel > 1 && dlevel <= MAXLEVEL) {
X  				You("rise up, through the ceiling!");
X! # ifdef MACOS
X  				segments |= SEG_POTION;
X! # endif
X  				goto_level(dlevel-1, FALSE, FALSE);
X  			} else You("have an uneasy feeling.");
X  #endif
X*** src/prisym.co	Wed Feb 06 04:41:48 1991
X--- src/prisym.c	Wed Feb 06 04:48:30 1991
X***************
X*** 24,30 ****
X  		impossible("atl(%d,%d,%c)",x,y,ch);
X  		return;
X  	}
X! 	if(crm->seen && crm->scrsym == ch) return;
X  	/* crm->scrsym = (uchar) ch; */
X  	/* wrong if characters are signed but uchar is larger than char,
X  	 * and ch, when passed, was greater than 127.
X--- 24,38 ----
X  		impossible("atl(%d,%d,%c)",x,y,ch);
X  		return;
X  	}
X! 	if(crm->seen && crm->scrsym == ch
X! #ifdef TEXTCOLOR
X! 	/* Force update if color used.  Otherwise objects with
X! 	 * same screen symbols but different colors show up
X! 	 * in wrong color in certain situations.
X! 	 */
X! 	   && !flags.use_color
X! #endif
X! 	  ) return;
X  	/* crm->scrsym = (uchar) ch; */
X  	/* wrong if characters are signed but uchar is larger than char,
X  	 * and ch, when passed, was greater than 127.
X*** src/read.c	Thu May 31 15:56:51 1990
X--- src/read.c	Wed Jan 16 16:42:50 1991
X***************
X*** 714,720 ****
X  			if(!Blind)
X  			    pline("Oh, look, what a pretty fire in your %s.",
X  				makeplural(body_part(HAND)));
X! 			else You("feal a pleasant warmth in your %s.",
X  				makeplural(body_part(HAND)));
X  		    } else {
X  			pline("The scroll catches fire and you burn your %s.",
X--- 714,720 ----
X  			if(!Blind)
X  			    pline("Oh, look, what a pretty fire in your %s.",
X  				makeplural(body_part(HAND)));
X! 			else You("feel a pleasant warmth in your %s.",
X  				makeplural(body_part(HAND)));
X  		    } else {
X  			pline("The scroll catches fire and you burn your %s.",
X*** src/restore.c	Tue Jun 26 21:20:31 1990
X--- src/restore.c	Sun Jan  6 15:55:35 1991
X***************
X*** 152,167 ****
X  	register struct monst *mtmp, *mtmp2;
X  	register struct monst *first = 0;
X  	int xl;
X- 
X  	struct permonst *monbegin;
X! 	off_t differ;
X  
X  	mread(fd, (genericptr_t)&monbegin, sizeof(monbegin));
X! #if !defined(MSDOS) && !defined(M_XENIX) && !defined(THINKC4) && !defined(HPUX) && !defined(VAXC)
X! 	differ = (genericptr_t)(&mons[0]) - (genericptr_t)(monbegin);
X! #else
X! 	differ = (long)(&mons[0]) - (long)(monbegin);
X! #endif
X  
X  #if defined(LINT) || defined(__GNULINT__)
X  	/* suppress "used before set" warning from lint */
X--- 152,163 ----
X  	register struct monst *mtmp, *mtmp2;
X  	register struct monst *first = 0;
X  	int xl;
X  	struct permonst *monbegin;
X! 	boolean moved;
X  
X+ 	/* get the original base address */
X  	mread(fd, (genericptr_t)&monbegin, sizeof(monbegin));
X! 	moved = (monbegin != mons);
X  
X  #if defined(LINT) || defined(__GNULINT__)
X  	/* suppress "used before set" warning from lint */
X***************
X*** 176,199 ****
X  		mread(fd, (genericptr_t) mtmp, (unsigned) xl + sizeof(struct monst));
X  		if(!mtmp->m_id)
X  			mtmp->m_id = flags.ident++;
X! #if !defined(MSDOS) && !defined(M_XENIX) && !defined(THINKC4) && !defined(HPUX) && !defined(VAXC)
X! 		/* ANSI type for differ is ptrdiff_t --
X! 		 * long may be wrong for segmented architecture --
X! 		 * may be better to cast pointers to (struct permonst *)
X! 		 * rather than (genericptr_t)
X! 		 * this code handles save file -- so any bug should glow
X! 		 * probably best not to keep lint from complaining
X! 		 */
X! /*#ifdef LINT	/* possible compiler/hardware dependency - */
X! /*		if (differ) mtmp->data = NULL;*/
X! /*#else*/
X! 		mtmp->data = (struct permonst *)
X! 			((genericptr_t)mtmp->data + differ);
X! /*#endif	/*LINT*/
X! #else
X! 		mtmp->data = (struct permonst *)
X! 			((long) mtmp->data + differ);
X! #endif
X  		if(mtmp->minvent)
X  			mtmp->minvent = restobjchn(fd, ghostly);
X  		mtmp2 = mtmp;
X--- 172,181 ----
X  		mread(fd, (genericptr_t) mtmp, (unsigned) xl + sizeof(struct monst));
X  		if(!mtmp->m_id)
X  			mtmp->m_id = flags.ident++;
X! 		if (moved && mtmp->data) {
X! 			int offset = mtmp->data - monbegin;	/*(ptrdiff_t)*/
X! 			mtmp->data = mons + offset;  /* new permonst location */
X! 		}
X  		if(mtmp->minvent)
X  			mtmp->minvent = restobjchn(fd, ghostly);
X  		mtmp2 = mtmp;
X***************
X*** 885,892 ****
X  		}
X  	}
X  #endif
X! 	if(ghostly && lev > medusa_level && lev < stronghold_level &&
X! 						xdnstair == 0) {
X  		coord cc;
X  
X  		mazexy(&cc);
X--- 867,879 ----
X  		}
X  	}
X  #endif
X! 	if(ghostly && lev > medusa_level
X! #ifdef STRONGHOLD
X! 				&& lev < stronghold_level
X! #else
X! 				&& !Inhell
X! #endif
X! 				&& xdnstair == 0) {
X  		coord cc;
X  
X  		mazexy(&cc);
X*** src/save.c	Sat May 26 08:35:56 1990
X--- src/save.c	Sat Jan  5 15:07:00 1991
X***************
X*** 333,338 ****
X--- 333,349 ----
X  	bflush(fd);
X  #endif
X  	(void) close(fd);
X+ #if defined(VMS) && !defined(SECURE)
X+ 	/*
X+ 	   Make sure the save file is owned by the current process.  That's
X+ 	   the default for non-privileged users, but for priv'd users the
X+ 	   file will be owned by the directory's owner instead of the user.
X+ 	 */
X+ # ifdef getuid	/*(see vmsunix.c)*/
X+ #  undef getuid
X+ # endif
X+ 	(void) chown(SAVEF, getuid(), getgid());
X+ #endif /* VMS && !SECURE */
X  	glo(dlevel);
X  	(void) unlink(lock);	/* get rid of current level --jgm */
X  	glo(0);
X*** src/shk.c	Thu May 31 21:34:50 1990
X--- src/shk.c	Sat Jan  5 15:01:22 1991
X***************
X*** 830,836 ****
X  	if (ANGRY(shopkeeper) || 
X  		(pl_character[0] == 'T' && u.ulevel < (MAXULEV/2))
X  #ifdef SHIRT
X! 	    || (uarmu && !uarm) /* wearing just a Hawaiian shirt */
X  #endif
X  	   )
X  		tmp += tmp/3;
X--- 830,836 ----
X  	if (ANGRY(shopkeeper) || 
X  		(pl_character[0] == 'T' && u.ulevel < (MAXULEV/2))
X  #ifdef SHIRT
X! 	    || (uarmu && !uarm && !uarmc) /* wearing just a Hawaiian shirt */
X  #endif
X  	   )
X  		tmp += tmp/3;
X***************
X*** 840,845 ****
X--- 840,848 ----
X  	else if (ACURR(A_CHA) < 6)	tmp *= 2;
X  	else if (ACURR(A_CHA) < 8)	tmp = (tmp * 3)/2;
X  	else if (ACURR(A_CHA) < 11)	tmp = (tmp * 4)/3;
X+ #ifdef NAMED_ITEMS
X+ 	if (is_artifact(obj))		tmp *= 4;
X+ #endif
X  	if (!tmp) return 1;
X  	return(tmp);
X  }
X***************
X*** 1135,1140 ****
X--- 1138,1146 ----
X  		pline("Strange... carrying a chain?");
X  		break;
X  	}
X+ #ifdef NAMED_ITEMS
X+ 	if (is_artifact(obj)) tmp *= 25;
X+ #endif
X  	return(tmp);
X  }
X  
X*** src/sounds.c	Thu May 31 15:56:55 1990
X--- src/sounds.c	Sat Jan  5 14:59:56 1991
X***************
X*** 239,244 ****
X--- 239,245 ----
X  growl(mtmp)
X  register struct monst *mtmp;
X  {
X+     if (mtmp->msleep || !mtmp->mcanmove) return;
X      /* presumably nearness and soundok checks have already been made */
X      switch (mtmp->data->msound) {
X  	case MS_SILENT:
X***************
X*** 274,279 ****
X--- 275,281 ----
X  register struct monst *mtmp;
X  /* the sounds of mistreated pets */
X  {
X+     if (mtmp->msleep || !mtmp->mcanmove) return;
X      /* presumably nearness and soundok checks have already been made */
X      switch (mtmp->data->msound) {
X  	case MS_MEW:
X***************
X*** 300,305 ****
X--- 302,308 ----
X  register struct monst *mtmp;
X  /* the sounds of distressed pets */
X  {
X+     if (mtmp->msleep || !mtmp->mcanmove) return;
X      /* presumably nearness and soundok checks have already been made */
X      switch (mtmp->data->msound) {
X  	case MS_MEW:
X***************
X*** 345,351 ****
X  domonnoise(mtmp)
X  register struct monst *mtmp;
X  {
X!     /* presumably nearness checks have already been made */
X      if (!flags.soundok) return(0);
X      switch (mtmp->data->msound) {
X  #ifdef ORACLE
X--- 348,354 ----
X  domonnoise(mtmp)
X  register struct monst *mtmp;
X  {
X!     /* presumably nearness and sleep checks have already been made */
X      if (!flags.soundok) return(0);
X      switch (mtmp->data->msound) {
X  #ifdef ORACLE
X*** src/steal.c	Thu May 31 15:56:56 1990
X--- src/steal.c	Sat Jan  5 15:01:12 1991
X***************
X*** 104,110 ****
X  	/* the following is true if successful on first of two attacks. */
X  	if(!monnear(mtmp, u.ux, u.uy)) return(0);
X  
X! 	if(!invent){
X  	    /* Not even a thousand men in armor can strip a naked man. */
X  	    if(Blind)
X  	      pline("Somebody tries to rob you, but finds nothing to steal.");
X--- 104,114 ----
X  	/* the following is true if successful on first of two attacks. */
X  	if(!monnear(mtmp, u.ux, u.uy)) return(0);
X  
X! 	if(!invent
X! #ifdef POLYSELF
X! 		   || (inv_cnt() == 1 && uskin)
X! #endif
X! 						){
X  	    /* Not even a thousand men in armor can strip a naked man. */
X  	    if(Blind)
X  	      pline("Somebody tries to rob you, but finds nothing to steal.");
X***************
X*** 123,134 ****
X  	}
X  
X  	tmp = 0;
X! 	for(otmp = invent; otmp; otmp = otmp->nobj) if(!uarm || otmp != uarmc)
X! 	    tmp += ((otmp->owornmask & (W_ARMOR | W_RING | W_AMUL | W_TOOL)) ? 5 : 1);
X  	tmp = rn2(tmp);
X! 	for(otmp = invent; otmp; otmp = otmp->nobj) if(!uarm || otmp != uarmc)
X!   	    if((tmp -= ((otmp->owornmask & (W_ARMOR | W_RING | W_AMUL | W_TOOL)) ? 5 : 1))
X! 			< 0) break;
X  	if(!otmp) {
X  		impossible("Steal fails!");
X  		return(0);
X--- 127,150 ----
X  	}
X  
X  	tmp = 0;
X! 	for(otmp = invent; otmp; otmp = otmp->nobj)
X! 	    if((!uarm || otmp != uarmc)
X! #ifdef POLYSELF
X! 					&& otmp != uskin
X! #endif
X! 							)
X! 		tmp += ((otmp->owornmask &
X! 			(W_ARMOR | W_RING | W_AMUL | W_TOOL)) ? 5 : 1);
X  	tmp = rn2(tmp);
X! 	for(otmp = invent; otmp; otmp = otmp->nobj)
X! 	    if((!uarm || otmp != uarmc)
X! #ifdef POLYSELF
X! 					&& otmp != uskin
X! #endif
X! 							)
X! 		if((tmp -= ((otmp->owornmask &
X! 			(W_ARMOR | W_RING | W_AMUL | W_TOOL)) ? 5 : 1)) < 0)
X! 			break;
X  	if(!otmp) {
X  		impossible("Steal fails!");
X  		return(0);
X*** src/termcap.c	Tue Jun 26 21:20:32 1990
X--- src/termcap.c	Thu Jan 10 09:52:41 1991
X***************
X*** 56,61 ****
X--- 56,62 ----
X  #endif
X  
X  #ifdef OVLB
X+ static char *KS = NULL, *KE = NULL;	/* keypad sequences */
X  static char nullstr[] = "";
X  #endif /* OVLB */
X  
X***************
X*** 82,91 ****
X  
X  #ifdef TERMLIB
X  # ifdef VMS
X! 	term = getenv("EMACS_TERM");
X  	if (!term)
X- 	    term = getenv("NETHACK_TERM");
X- 	if (!term)
X  # endif
X  	term = getenv("TERM");
X  #endif
X--- 83,92 ----
X  
X  #ifdef TERMLIB
X  # ifdef VMS
X! 	term = verify_termcap();	/* jump thru some hoops */
X! 	if (!term) term = getenv("NETHACK_TERM");
X! 	if (!term) term = getenv("EMACS_TERM");
X  	if (!term)
X  # endif
X  	term = getenv("TERM");
X  #endif
X***************
X*** 231,249 ****
X  		error("Unknown terminal type: %s.", term);
X  	if(pc = Tgetstr("pc"))
X  		PC = *pc;
X  # ifdef TERMINFO
X! 	if(!(BC = Tgetstr("le"))) {	
X  # else
X! 	if(!(BC = Tgetstr("bc"))) {	
X! # endif
X! # if !defined(MINIMAL_TERM) && !defined(HISX)
X  		if(!tgetflag("bs"))
X  			error("Terminal must backspace.");
X! # endif
X  		BC = tbufptr;
X  		tbufptr += 2;
X  		*BC = '\b';
X! 	}
X  # ifdef MINIMAL_TERM
X  	HO = NULL;
X  # else
X--- 232,253 ----
X  		error("Unknown terminal type: %s.", term);
X  	if(pc = Tgetstr("pc"))
X  		PC = *pc;
X+ 
X+ 	if(!(BC = Tgetstr("le")))	/* both termcap and terminfo use le */	
X  # ifdef TERMINFO
X! 	    error("Terminal must backspace.");
X  # else
X! 	    if(!(BC = Tgetstr("bc"))) {	/* termcap also uses bc/bs */
X! #  if !defined(MINIMAL_TERM) && !defined(HISX)
X  		if(!tgetflag("bs"))
X  			error("Terminal must backspace.");
X! #  endif
X  		BC = tbufptr;
X  		tbufptr += 2;
X  		*BC = '\b';
X! 	    }
X! # endif
X! 
X  # ifdef MINIMAL_TERM
X  	HO = NULL;
X  # else
X***************
X*** 304,309 ****
X--- 308,315 ----
X  # ifdef TERMINFO
X  	VS = Tgetstr("eA");	/* enable graphics */
X  # endif
X+ 	KS = Tgetstr("ks");	/* keypad start (special mode) */
X+ 	KE = Tgetstr("ke");	/* keypad end (ordinary mode [ie, digits]) */
X  # if 0
X  	MB = Tgetstr("mb");	/* blink */
X  	MD = Tgetstr("md");	/* boldface */
X***************
X*** 345,350 ****
X--- 351,373 ----
X  }
X  
X  void
X+ number_pad(state)
X+ int state;
X+ {
X+ 	switch (state) {
X+ 	    case -1:	/* activate keypad mode (escape sequences) */
X+ 		    if (KS && *KS) xputs(KS);
X+ 		    break;
X+ 	    case  1:	/* activate numeric mode for keypad (digits) */
X+ 		    if (KE && *KE) xputs(KE);
X+ 		    break;
X+ 	    case  0:	/* don't need to do anything--leave terminal as-is */
X+ 	    default:
X+ 		    break;
X+ 	}
X+ }
X+ 
X+ void
X  start_screen()
X  {
X  	xputs(TI);
X***************
X*** 356,365 ****
X  		 * since people may reasonably be using the UK set
X  		 */
X  		xputs("\033)0");
X! 		/* 'as' and 'ae' are missing from some termcaps */
X! 		if (!AS) AS = "\016";  /* ^N */
X! 		if (!AE) AE = "\017";  /* ^O */
X  	}
X  }
X  
X  void
X--- 379,391 ----
X  		 * since people may reasonably be using the UK set
X  		 */
X  		xputs("\033)0");
X! 		/* these values are missing from some termcaps */
X! 		if (!AS) AS = "\016";	/* ^N (shift-out [graphics font]) */
X! 		if (!AE) AE = "\017";	/* ^O (shift-in  [regular font])  */
X! 		if (!KS) KS = "\033=";	/* ESC= (application keypad mode) */
X! 		if (!KE) KE = "\033>";	/* ESC> (numeric keypad mode)	  */
X  	}
X+ 	if (flags.num_pad) number_pad(1);	/* make keypad send digits */
X  }
X  
X  void
X***************
X*** 390,396 ****
X  }
X  #endif
X  
X! #endif /* OVLB */
X  #ifdef OVLB
X  void
X  curs(x, y)
X--- 416,422 ----
X  }
X  #endif
X  
X! #endif /* OVL0 */
X  #ifdef OVLB
X  void
X  curs(x, y)
X*** src/timeout.c	Mon May 28 16:48:10 1990
X--- src/timeout.c	Tue Feb  5 08:55:44 1991
X***************
X*** 103,112 ****
X  	 */
X  	    register int time_luck = stone_luck(FALSE);
X  	    boolean nostone = !carrying(LUCKSTONE);
X  
X! 	    if(u.uluck > 0 && (nostone || time_luck < 0))
X  		u.uluck--;
X! 	    else if(u.uluck < 0 && (nostone || time_luck > 0))
X  		u.uluck++;
X  	}
X  
X--- 103,113 ----
X  	 */
X  	    register int time_luck = stone_luck(FALSE);
X  	    boolean nostone = !carrying(LUCKSTONE);
X+ 	    int baseluck = (flags.moonphase == FULL_MOON) ? 1 : 0;
X  
X! 	    if(u.uluck > baseluck && (nostone || time_luck < 0))
X  		u.uluck--;
X! 	    else if(u.uluck < baseluck && (nostone || time_luck > 0))
X  		u.uluck++;
X  	}
X  
X***************
X*** 130,136 ****
X  			done(POISONING);
X  			break;
X  		case FAST:
X! 			You("feel yourself slowing down.");
X  			break;
X  		case CONFUSION:
X  			HConfusion = 1; /* So make_confused works properly */
X--- 131,141 ----
X  			done(POISONING);
X  			break;
X  		case FAST:
X! 			if (Fast & ~INTRINSIC) /* boot speed */
X! 				;
X! 			else
X! 				You("feel yourself slowing down%s.",
X! 							Fast ? " a bit" : "");
X  			break;
X  		case CONFUSION:
X  			HConfusion = 1; /* So make_confused works properly */
X*** src/topten.c	Sun May 27 20:28:03 1990
X--- src/topten.c	Wed Jan 30 08:52:00 1991
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)topten.c	3.0	89/12/31
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)topten.c	3.0	91/01/20
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 7,24 ****
X  /* block some unused #defines to avoid overloading some cpp's */
X  #include "hack.h"
X  
X! #ifndef MACOS
X  #include <errno.h>	/* George Barbanis */
X! #else
X  extern short macflags;
X  extern WindowPtr	HackWindow;
X  #endif
X  
X- #ifdef NO_FILE_LINKS
X- #include <fcntl.h>	/* Ralf Brown */
X- #endif
X- #include <ctype.h>
X- 
X  #ifdef NO_SCAN_BRACK
X  static void FDECL(nsb_mung_line,(char*));
X  static void FDECL(nsb_unmung_line,(char*));
X--- 7,26 ----
X  /* block some unused #defines to avoid overloading some cpp's */
X  #include "hack.h"
X  
X! #if defined(UNIX) || defined(VMS)
X  #include <errno.h>	/* George Barbanis */
X! extern int errno;
X! # if defined(NO_FILE_LINKS) && !defined(O_WRONLY)
X! #include <fcntl.h>	/* Ralf Brown */
X! # endif
X! #endif	/* UNIX || VMS */
X! #include <ctype.h>
X! 
X! #ifdef MACOS
X  extern short macflags;
X  extern WindowPtr	HackWindow;
X  #endif
X  
X  #ifdef NO_SCAN_BRACK
X  static void FDECL(nsb_mung_line,(char*));
X  static void FDECL(nsb_unmung_line,(char*));
X***************
X*** 142,148 ****
X  # endif
X  #endif /* UNIX */
X  #ifdef VMS
X! 	char *reclock = "record_lock;1";
X  	char recfile[] = RECORD;
X  #else
X  	const char *recfile = RECORD;
X--- 144,150 ----
X  # endif
X  #endif /* UNIX */
X  #ifdef VMS
X! 	const char *reclock = "record.lock;1";
X  	char recfile[] = RECORD;
X  #else
X  	const char *recfile = RECORD;
X***************
X*** 159,165 ****
X  	char *loglock = "logfile_lock";
X  # endif /* UNIX */
X  # ifdef VMS
X! 	char *loglock = "logfile_lock;1";
X  # endif /* VMS */
X  # if defined(UNIX) || defined(VMS)
X  	int sleeplgct = 30;
X--- 161,167 ----
X  	char *loglock = "logfile_lock";
X  # endif /* UNIX */
X  # ifdef VMS
X! 	const char *loglock = "logfile.lock;1";
X  # endif /* VMS */
X  # if defined(UNIX) || defined(VMS)
X  	int sleeplgct = 30;
X***************
X*** 216,223 ****
X  #  else
X  	while(link(lgfile, loglock) == -1) {
X  #  endif /* NO_FILE_LINKS */
X- 		extern int errno;
X- 
X  		if (errno == ENOENT) /* If no such file, do not keep log */
X  			goto lgend;  /* George Barbanis */
X  		HUP perror(loglock);
X--- 218,223 ----
X***************
X*** 244,261 ****
X  # if defined(UNIX) || defined(VMS)
X  	(void) unlink(loglock);
X  # endif /* UNIX or VMS */
X!       lgend:;
X  # ifdef NO_FILE_LINKS
X  	(void) close(lockfd) ;
X  # endif
X! # if defined(WIZARD) || defined(EXPLORE_MODE)
X  	if (wizard || discover) {
X   Printf("\nSince you were in %s mode, the score list will not be checked.\n",
X  	wizard ? "wizard" : "discover");
X  		return;
X  	}
X! # endif
X! #endif /* LOGFILE */
X  
X  #if defined(UNIX) || defined(VMS)
X  # ifdef NO_FILE_LINKS
X--- 244,263 ----
X  # if defined(UNIX) || defined(VMS)
X  	(void) unlink(loglock);
X  # endif /* UNIX or VMS */
X!  lgend: ;
X  # ifdef NO_FILE_LINKS
X  	(void) close(lockfd) ;
X+ 	free((genericptr_t) loglock) ;
X  # endif
X! #endif /* LOGFILE */
X! 
X! #if defined(WIZARD) || defined(EXPLORE_MODE)
X  	if (wizard || discover) {
X   Printf("\nSince you were in %s mode, the score list will not be checked.\n",
X  	wizard ? "wizard" : "discover");
X  		return;
X  	}
X! #endif
X  
X  #if defined(UNIX) || defined(VMS)
X  # ifdef NO_FILE_LINKS
X***************
X*** 289,301 ****
X  		
X  		t = (term_info *)GetWRefCon(HackWindow);
X  		SetVol((StringPtr)0L, t->recordVRefNum);
X! 		if (!(rfile = fopen(recfile,"r"))) {
X! 			short	i;
X! 	
X  			rfile = openFile(recfile,"r");
X- 		}
X  	}
X- 
X  	if (!rfile) {
X  #else
X  	if(!(rfile = fopen(recfile,"r"))){
X--- 291,299 ----
X  		
X  		t = (term_info *)GetWRefCon(HackWindow);
X  		SetVol((StringPtr)0L, t->recordVRefNum);
X! 		if (!(rfile = fopen(recfile,"r")))
X  			rfile = openFile(recfile,"r");
X  	}
X  	if (!rfile) {
X  #else
X  	if(!(rfile = fopen(recfile,"r"))){
X***************
X*** 303,311 ****
X  		HUP (void) puts("Cannot open record file!");
X  		goto unlock;
X  	}
X- #ifdef NO_FILE_LINKS
X- 	(void) close(lockfd) ;
X- #endif
X  	HUP (void) putchar('\n');
X  
X  	/* assure minimum number of points */
X--- 301,306 ----
X***************
X*** 359,370 ****
X  	if(flg) {	/* rewrite record file */
X  		(void) fclose(rfile);
X  #ifdef VMS
X! 		{
X! 			char *sem = rindex(recfile, ';');
X! 
X! 			if (sem)
X! 				*sem = '\0';
X! 		}
X  #endif
X  		if(!(rfile = fopen(recfile,"w"))){
X  			HUP (void) puts("Cannot write record file\n");
X--- 354,362 ----
X  	if(flg) {	/* rewrite record file */
X  		(void) fclose(rfile);
X  #ifdef VMS
X! 	    {	char *semi_colon = rindex(recfile, ';');
X! 		if (semi_colon) *semi_colon = '\0';
X! 	    }
X  #endif
X  		if(!(rfile = fopen(recfile,"w"))){
X  			HUP (void) puts("Cannot write record file\n");
X***************
X*** 441,451 ****
X  #endif
X  unlock:	;
X  #if defined(UNIX) || defined(VMS)
X  # ifdef NO_FILE_LINKS
X  	(void) close(lockfd) ;
X  # endif
X- 	if (unlink(reclock) < 0)
X- 		Printf("Can't unlink %s\n",reclock) ;
X  #endif
X  }
X  
X--- 433,444 ----
X  #endif
X  unlock:	;
X  #if defined(UNIX) || defined(VMS)
X+ 	if (unlink(reclock) < 0)
X+ 		Printf("Can't unlink %s\n",reclock) ;
X  # ifdef NO_FILE_LINKS
X  	(void) close(lockfd) ;
X+ 	free((genericptr_t) reclock) ;
X  # endif
X  #endif
X  }
X  
X***************
X*** 474,480 ****
X  	char linebuf[BUFSZ], linebuf2[BUFSZ];
X  
X  	linebuf[0] = linebuf2[0] = 0;
X! 	if(rank) Sprintf(eos(linebuf), " %2d", rank);
X  	else Strcat(linebuf, "   ");
X  
X  	Sprintf(eos(linebuf), " %10ld  %.10s", t1->points, t1->name);
X--- 467,473 ----
X  	char linebuf[BUFSZ], linebuf2[BUFSZ];
X  
X  	linebuf[0] = linebuf2[0] = 0;
X! 	if(rank) Sprintf(eos(linebuf), "%3d", rank);
X  	else Strcat(linebuf, "   ");
X  
X  	Sprintf(eos(linebuf), " %10ld  %.10s", t1->points, t1->name);
X*** src/trap.c	Tue Jun 26 21:20:36 1990
X--- src/trap.c	Sat Feb  2 16:58:28 1991
X***************
X*** 40,45 ****
X--- 40,46 ----
X  
X  #ifdef OVLB
X  
X+ static int FDECL(teleok, (int,int,BOOLEAN_P));
X  static void NDECL(vtele);
X  
X  /* Generic rust-armor function.  Returns TRUE if a message was printed;
X***************
X*** 99,118 ****
X  {
X  	register struct trap *ttmp;
X  	register struct permonst *ptr;
X  
X  	if (ttmp = t_at(x,y)) {
X! 		if (u.utrap &&
X! 		  ((u.utraptype == TT_BEARTRAP && typ != BEAR_TRAP) ||
X! 		  (u.utraptype == TT_WEB && typ != WEB) ||
X! 		  (u.utraptype == TT_PIT && typ != PIT && typ != SPIKED_PIT)))
X! 			u.utrap = 0;
X! 		ttmp->ttyp = typ;
X! 		return ttmp;
X  	}
X- 	ttmp = newtrap();
X  	ttmp->ttyp = typ;
X- 	ttmp->tx = x;
X- 	ttmp->ty = y;
X  	switch(typ) {
X  	    case MONST_TRAP:	    /* create a monster in "hiding" */
X  	    {	int tryct = 0;
X--- 100,121 ----
X  {
X  	register struct trap *ttmp;
X  	register struct permonst *ptr;
X+ 	register boolean oldplace;
X  
X  	if (ttmp = t_at(x,y)) {
X! 	    oldplace = TRUE;
X! 	    if (u.utrap && (x == u.ux) && (y == u.uy) && 
X! 	      ((u.utraptype == TT_BEARTRAP && typ != BEAR_TRAP) ||
X! 	      (u.utraptype == TT_WEB && typ != WEB) ||
X! 	      (u.utraptype == TT_PIT && typ != PIT && typ != SPIKED_PIT)))
X! 		    u.utrap = 0;
X! 	} else {
X! 	    oldplace = FALSE;
X! 	    ttmp = newtrap();
X! 	    ttmp->tx = x;
X! 	    ttmp->ty = y;
X  	}
X  	ttmp->ttyp = typ;
X  	switch(typ) {
X  	    case MONST_TRAP:	    /* create a monster in "hiding" */
X  	    {	int tryct = 0;
X***************
X*** 123,129 ****
X  		} while ((noattacks(&mons[ttmp->pm]) ||
X  			!mons[ttmp->pm].mmove) && ++tryct < 100);
X  		if (tryct == 100) {
X! 			free((genericptr_t)ttmp);
X  			return(struct trap *)0;
X  		}
X  		break;
X--- 126,135 ----
X  		} while ((noattacks(&mons[ttmp->pm]) ||
X  			!mons[ttmp->pm].mmove) && ++tryct < 100);
X  		if (tryct == 100) {
X! 			if (oldplace)
X! 			    deltrap(ttmp);
X! 			else
X! 			    free((genericptr_t)ttmp);
X  			return(struct trap *)0;
X  		}
X  		break;
X***************
X*** 138,184 ****
X  	}
X  	ttmp->tseen = 0;
X  	ttmp->once = 0;
X! 	ttmp->ntrap = ftrap;
X! 	ftrap = ttmp;
X  	return(ttmp);
X  }
X  
X! int
X! teleok(x, y)
X  register int x, y;
X  {				/* might throw him into a POOL
X  				 * removed by GAN 10/20/86
X  				 */
X  #ifdef STUPID
X  	boolean	tmp1, tmp2, tmp3;
X! #  ifdef POLYSELF
X  	tmp1 = isok(x,y) && (!IS_ROCK(levl[x][y].typ) ||
X  		passes_walls(uasmon)) && !MON_AT(x, y);
X! #  else
X  	tmp1 = isok(x,y) && !IS_ROCK(levl[x][y].typ) && !MON_AT(x, y);
X! #  endif
X! 	tmp2 = !sobj_at(BOULDER,x,y) && !t_at(x,y);
X  	tmp3 = !(is_pool(x,y) &&
X  	       !(Levitation || Wwalking
X! #ifdef POLYSELF
X  		 || is_flyer(uasmon)
X! #endif
X  		)) && !closed_door(x,y);
X  	return(tmp1 && tmp2 && tmp3);
X  #else
X  	return( isok(x,y) &&
X! #  ifdef POLYSELF
X  		(!IS_ROCK(levl[x][y].typ) || passes_walls(uasmon)) &&
X! #  else
X  		!IS_ROCK(levl[x][y].typ) &&
X! #  endif
X  		!MON_AT(x, y) &&
X! 		!sobj_at(BOULDER,x,y) && !t_at(x,y) &&
X  		!(is_pool(x,y) &&
X  		!(Levitation || Wwalking
X! #ifdef POLYSELF
X  		  || is_flyer(uasmon)
X! #endif
X  		  )) && !closed_door(x,y));
X  #endif
X  	/* Note: gold is permitted (because of vaults) */
X--- 144,193 ----
X  	}
X  	ttmp->tseen = 0;
X  	ttmp->once = 0;
X! 	if (!oldplace) {
X! 	    ttmp->ntrap = ftrap;
X! 	    ftrap = ttmp;
X! 	}
X  	return(ttmp);
X  }
X  
X! static int
X! teleok(x, y, trapok)
X  register int x, y;
X+ boolean trapok;
X  {				/* might throw him into a POOL
X  				 * removed by GAN 10/20/86
X  				 */
X  #ifdef STUPID
X  	boolean	tmp1, tmp2, tmp3;
X! # ifdef POLYSELF
X  	tmp1 = isok(x,y) && (!IS_ROCK(levl[x][y].typ) ||
X  		passes_walls(uasmon)) && !MON_AT(x, y);
X! # else
X  	tmp1 = isok(x,y) && !IS_ROCK(levl[x][y].typ) && !MON_AT(x, y);
X! # endif
X! 	tmp2 = !sobj_at(BOULDER,x,y) && (trapok || !t_at(x,y));
X  	tmp3 = !(is_pool(x,y) &&
X  	       !(Levitation || Wwalking
X! # ifdef POLYSELF
X  		 || is_flyer(uasmon)
X! # endif
X  		)) && !closed_door(x,y);
X  	return(tmp1 && tmp2 && tmp3);
X  #else
X  	return( isok(x,y) &&
X! # ifdef POLYSELF
X  		(!IS_ROCK(levl[x][y].typ) || passes_walls(uasmon)) &&
X! # else
X  		!IS_ROCK(levl[x][y].typ) &&
X! # endif
X  		!MON_AT(x, y) &&
X! 		!sobj_at(BOULDER,x,y) && (trapok || !t_at(x,y)) &&
X  		!(is_pool(x,y) &&
X  		!(Levitation || Wwalking
X! # ifdef POLYSELF
X  		  || is_flyer(uasmon)
X! # endif
X  		  )) && !closed_door(x,y));
X  #endif
X  	/* Note: gold is permitted (because of vaults) */
X***************
X*** 194,200 ****
X  
X  		x = rn2(2) ? croom->lx : croom->hx;
X  		y = rn2(2) ? croom->ly : croom->hy;
X! 		if(teleok(x,y)) {
X  		    teleds(x,y);
X  		    return;
X  		}
X--- 203,209 ----
X  
X  		x = rn2(2) ? croom->lx : croom->hx;
X  		y = rn2(2) ? croom->ly : croom->hy;
X! 		if(teleok(x,y,FALSE)) {
X  		    teleds(x,y);
X  		    return;
X  		}
X***************
X*** 252,257 ****
X--- 261,267 ----
X  	register int ttype = trap->ttyp;
X  	register struct monst *mtmp;
X  	register struct obj *otmp;
X+ 	int pm = trap->pm;
X  
X  	nomul(0);
X  	if(trap->tseen && !Fumbling && !(ttype == PIT
X***************
X*** 307,314 ****
X  		    deltrap(trap);
X  		    for(otmp=level.objects[u.ux][u.uy];
X  						otmp; otmp = otmp->nexthere)
X! 			if(otmp->otyp == STATUE && otmp->corpsenm == trap->pm)
X! 			    if(mtmp=makemon(&mons[trap->pm],u.ux,u.uy)) {
X  				pline("The statue comes to life!");
X  				delobj(otmp);
X  				break;
X--- 317,324 ----
X  		    deltrap(trap);
X  		    for(otmp=level.objects[u.ux][u.uy];
X  						otmp; otmp = otmp->nexthere)
X! 			if(otmp->otyp == STATUE && otmp->corpsenm == pm)
X! 			    if(mtmp=makemon(&mons[pm],u.ux,u.uy)) {
X  				pline("The statue comes to life!");
X  				delobj(otmp);
X  				break;
X***************
X*** 315,321 ****
X  			    }
X  		    break;
X  		case MONST_TRAP:
X! 		    if(mtmp=makemon(&mons[trap->pm],u.ux,u.uy)) {
X  		      mtmp->mpeaceful = FALSE;
X  		      switch(mtmp->data->mlet) {
X  			case S_PIERCER:
X--- 325,332 ----
X  			    }
X  		    break;
X  		case MONST_TRAP:
X! 		    deltrap(trap);
X! 		    if(mtmp=makemon(&mons[pm],u.ux,u.uy)) {
X  		      mtmp->mpeaceful = FALSE;
X  		      switch(mtmp->data->mlet) {
X  			case S_PIERCER:
X***************
X*** 333,339 ****
X  			    break;
X  		      }
X  		    }
X- 		    deltrap(trap);
X  		    break;
X  		case ARROW_TRAP:
X  		    pline("An arrow shoots out at you!");
X--- 344,349 ----
X***************
X*** 562,581 ****
X  			You("feel momentarily different.");
X  			/* Trap did nothing; don't remove it --KAA */
X  		    } else {
X  			You("feel a change coming over you.");
X  			polyself();
X- 			deltrap(trap);
X  		    }
X  		    break;
X  #endif
X  		case MGTRP:	    /* A magic trap. */
X  		    if (!rn2(30)) {
X- 			You("are caught in a magical explosion!");
X- 			losehp(rnd(10), "magical explosion", KILLED_BY_AN);
X- #ifdef SPELLS
X- 			Your("body absorbs some of the magical energy!");
X- 			u.uen = (u.uenmax += 2);
X- #endif
X  			deltrap(trap);
X  			if(Invisible
X  #ifdef POLYSELF
X--- 572,585 ----
X  			You("feel momentarily different.");
X  			/* Trap did nothing; don't remove it --KAA */
X  		    } else {
X+ 			deltrap(trap);
X  			You("feel a change coming over you.");
X  			polyself();
X  		    }
X  		    break;
X  #endif
X  		case MGTRP:	    /* A magic trap. */
X  		    if (!rn2(30)) {
X  			deltrap(trap);
X  			if(Invisible
X  #ifdef POLYSELF
X***************
X*** 582,587 ****
X--- 586,597 ----
X  				&& !u.uundetected
X  #endif
X  						) newsym(u.ux,u.uy);
X+ 			You("are caught in a magical explosion!");
X+ 			losehp(rnd(10), "magical explosion", KILLED_BY_AN);
X+ #ifdef SPELLS
X+ 			Your("body absorbs some of the magical energy!");
X+ 			u.uen = (u.uenmax += 2);
X+ #endif
X  		    } else domagictrap();
X  		    break;
X  		case SQBRD:	    /* stepped on a squeaky board */
X***************
X*** 1058,1064 ****
X  void
X  tele() {
X  	coord cc;
X! 	register int nux,nuy;
X  
X  #ifdef STRONGHOLD
X  	/* Disable teleportation in stronghold && Vlad's Tower */
X--- 1068,1075 ----
X  void
X  tele() {
X  	coord cc;
X! 	register int nux, nuy;
X! 	short tcnt = 0;
X  
X  #ifdef STRONGHOLD
X  	/* Disable teleportation in stronghold && Vlad's Tower */
X***************
X*** 1081,1087 ****
X  	    You("feel disoriented for a moment.");
X  	    return;
X  	}
X! 	if(Teleport_control) {
X  	    if (unconscious())
X  		pline("Being unconscious, you cannot control your teleport.");
X  	    else {
X--- 1092,1102 ----
X  	    You("feel disoriented for a moment.");
X  	    return;
X  	}
X! 	if(Teleport_control
X! #ifdef WIZARD
X! 			    || wizard
X! #endif
X! 					) {
X  	    if (unconscious())
X  		pline("Being unconscious, you cannot control your teleport.");
X  	    else {
X***************
X*** 1091,1097 ****
X  		    getpos(&cc, 1, "the desired position"); /* 1: force valid */
X  		    /* possible extensions: introduce a small error if
X  		       magic power is low; allow transfer to solid rock */
X! 		    if(teleok(cc.x, cc.y)){
X  			teleds(cc.x, cc.y);
X  			return;
X  		    }
X--- 1106,1112 ----
X  		    getpos(&cc, 1, "the desired position"); /* 1: force valid */
X  		    /* possible extensions: introduce a small error if
X  		       magic power is low; allow transfer to solid rock */
X! 		    if(teleok(cc.x, cc.y, FALSE)){
X  			teleds(cc.x, cc.y);
X  			return;
X  		    }
X***************
X*** 1098,1108 ****
X  		    pline("Sorry...");
X  		}
X  	}
X  	do {
X  		nux = rnd(COLNO-1);
X  		nuy = rn2(ROWNO);
X! 	} while(!teleok(nux, nuy));
X! 	teleds(nux, nuy);
X  }
X  
X  void
X--- 1113,1124 ----
X  		    pline("Sorry...");
X  		}
X  	}
X+ 
X  	do {
X  		nux = rnd(COLNO-1);
X  		nuy = rn2(ROWNO);
X! 	} while (!teleok(nux, nuy, tcnt>200) && tcnt++ < 400);
X! 	if (tcnt < 400) teleds(nux, nuy);
X  }
X  
X  void
X***************
X*** 1219,1229 ****
X  
X  #ifdef SPELLS
X  	if (castit)
X  # ifdef WIZARD
X! 		if (!spelleffects(++sp_no, TRUE) && !wizard) return(0);
X! # else
X! 		return spelleffects(++sp_no, TRUE);
X  # endif
X  #endif
X  
X  #ifdef WALKIES
X--- 1235,1247 ----
X  
X  #ifdef SPELLS
X  	if (castit)
X+ 		if (spelleffects(++sp_no, TRUE))
X+ 			return(1);
X+ 		else
X  # ifdef WIZARD
X! 		    if (!wizard)
X  # endif
X+ 			return(0);
X  #endif
X  
X  #ifdef WALKIES
X*** src/uhitm.c	Tue Jun 26 21:20:37 1990
X--- src/uhitm.c	Sat Jan  5 15:08:19 1991
X***************
X*** 70,75 ****
X--- 70,80 ----
X  	if (mon->mtame) {
X  	    struct monst *m3;
X  
X+ 	    /* because m2 is a copy of mon it is tame but not init'ed.
X+ 	     * however, tamedog will not re-tame a tame dog, so m2
X+ 	     * must be made non-tame to get initialized properly.
X+ 	     */
X+ 	    m2->mtame = 0;
X  	    if (m3 = tamedog(m2, (struct obj *)0))
X  		m2 = m3;
X  	}
X*** src/unixmain.c	Thu May 24 23:00:42 1990
X--- src/unixmain.c	Sat Jan  5 15:00:05 1991
X***************
X*** 345,351 ****
X  	flags.moonphase = phase_of_the_moon();
X  	if(flags.moonphase == FULL_MOON) {
X  		You("are lucky!  Full moon tonight.");
X! 		if(!u.uluck) change_luck(1);
X  	} else if(flags.moonphase == NEW_MOON) {
X  		pline("Be careful!  New moon tonight.");
X  	}
X--- 345,351 ----
X  	flags.moonphase = phase_of_the_moon();
X  	if(flags.moonphase == FULL_MOON) {
X  		You("are lucky!  Full moon tonight.");
X! 		change_luck(1);
X  	} else if(flags.moonphase == NEW_MOON) {
X  		pline("Be careful!  New moon tonight.");
X  	}
X*** src/unixtty.c	Sun Mar  4 13:44:10 1990
X--- src/unixtty.c	Tue Jan 15 17:50:55 1991
X***************
X*** 37,42 ****
X--- 37,45 ----
X  #define cbrkflgs	c_lflag
X  #define CBRKMASK	ICANON
X  #define CBRKON		! /* reverse condition */
X+ #ifndef CBAUD
X+ # define CBAUD		_CBAUD /* for POSIX nitpickers (like RS/6000 cc) */
X+ #endif
X  #define OSPEED(x)	((x).c_cflag & CBAUD)
X  #define IS_7BIT(x)	((x).c_cflag & CS7)
X  #define inputflags	c_iflag
X*** src/unixunix.c	Tue Apr 17 23:57:36 1990
X--- src/unixunix.c	Wed Jan 30 08:49:06 1991
X***************
X*** 112,118 ****
X  static struct stat buf, hbuf;
X  
X  void
X! gethdate(name) char *name; {
X  /* old version - for people short of space */
X  /*
X  /* register char *np;
X--- 112,118 ----
X  static struct stat buf, hbuf;
X  
X  void
X! gethdate(name) const char *name; {
X  /* old version - for people short of space */
X  /*
X  /* register char *np;
X*** src/zap.c	Tue Jun 26 21:20:41 1990
X--- src/zap.c	Sun Jan  6 15:55:18 1991
X***************
X*** 1517,1523 ****
X--- 1517,1530 ----
X  			} else {
X  #endif
X  				lev->typ = ROOM;
X+ #ifdef STUPID
X+ 				if (moat)
X+ 					lev->icedpool = ICED_MOAT;
X+ 				else
X+ 					lev->icedpool = ICED_POOL;
X+ #else
X  				lev->icedpool = (moat ? ICED_MOAT : ICED_POOL);
X+ #endif
X  #ifdef STRONGHOLD
X  			}
X  #endif
X
END_OF_FILE
if test 52441 -ne `wc -c <'patch10.03'`; then
    echo shar: \"'patch10.03'\" unpacked with wrong size!
fi
# end of 'patch10.03'
echo shar: End of archive 2 \(of 8\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 8 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
