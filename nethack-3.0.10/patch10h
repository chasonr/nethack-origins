Path: utzoo!utgpu!news-server.csri.toronto.edu!cs.utexas.edu!swrinde!zaphod.mps.ohio-state.edu!think.com!mintaka!ogicse!zephyr.ens.tek.com!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v12i032:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Patch10h
Message-ID: <6990@tekred.CNA.TEK.COM>
Date: 9 Feb 91 01:39:01 GMT
Sender: news@tekred.CNA.TEK.COM
Lines: 1137
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 12, Issue 32
Archive-name: NetHack3/Patch10h
Patch-To: NetHack3: Volume 7, Issue 56-93
Environment: 



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 8 (of 8)."
# Contents:  Install.mac others/exesmurf.c others/exesmurf.doc
#   src/lev_main.c
# Wrapped by billr@saab on Fri Feb  8 17:19:03 1991
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'Install.mac' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'Install.mac'\" to \"'Install.mac.orig'\"
  mv -f 'Install.mac' 'Install.mac.orig'
fi
echo shar: Extracting \"'Install.mac'\" \(15825 characters\)
sed "s/^X//" >'Install.mac' <<'END_OF_FILE'
XMacintosh NetHack 3.0 (Patchlevel 10) Installation Guide
Xlast modified: January 27th, 1991
X(A fixed width font is recommended for this document, Courier 10)
X
X
XAcknowledgements
X================
XOriginal credit for porting NetHack 3.0 to the Macintosh goes to Johnny
XLee and Michael Sokolov.  David Hairston, Kevin Sitze, Andy Swanson, Jon
XWatte and Tom West helped polish this port in later versions.
X
X
XPreliminary Notes
X================
XThese instructions are optimized for the Think C 4.0 compiler.  Other
XMacintosh compilers should be okay however some work will be needed to
Xcomplete the build.  For other compilers that use "make", you can use the
Xvarious Makefiles and your compiler errors as guides in building the game.
X
XYou should maintain the file/folder structure given in the distribution
Xfile "Files".  These notes assume that file structure which is outlined
Xbelow. Place the "top" folder appropriately in your compilers development
Xfolder.  You'll need ~6MB disk space for Macintosh only development,
Xhowever you will use less space by cleaning up after each phase of the
Xbuild detailed below.
X
X
XDistribution File Structure (Think C 4.0)
X================
Xtop {folder, appropriately placed in Think C 4.0 development tree}
X    Files
X    Install.mac
X    Makefile.top        {if you need Makefiles, Think C 4.0 doesn't}
X    auxil {folder}
X        all auxiliary support files.
X    include {folder}
X        all header files.
X    mac {folder}
X        all Macintosh specific files.
X    others {folder}
X        pcconf.c, pcmain.c, pctty.c & random.c only.
X        **** remove this copy of lev_lex.c! ****
X    src {folder}
X        all source files.
X        **** keep this copy of lev_lex.c! ****
X
X
XNon-Think C 4.0 Users
X================
XIf your compiler doesn't handle subfolders you'll need to place all the
Xinter-related source (*.c) and header (*.h) files in a common folder. It
Xwill require some work but you should be able to follow the dependencies
Xin the Makefiles to build the game.
X
XIf your compiler utilizes the make/Makefile facilities, then remove the
Xtags from the Makefiles (auxil, src and top) and edit appropriately.
X
X
XGetting Started
X================
XUsers of Think C 4.0 should decode the 5 BinHex 4.0 encoded *.hqx files in
Xthe mac folder, thus creating 3 Think C project files and 2 associated
XResEdit resource files.  There are various BinHex 4.0 decoders which can
Xdo this, including the applications BinHex 4.0 and Stuffit and the desk
Xaccessory BinHqx DA 1.02.  Move the 5 extracted files (makedefs.proj,
Xmakedefs.proj.rsrc, sp_lev.proj, nethack.proj and nethack.proj.rsrc) to
Xthe "top" folder.
X
XUse your favorite text editor to create an empty file of type "TEXT".
XName this file "news" and save it in the auxil folder. If you decide to
Xuse the NEWS compile option (recommended) then write a message in the
X"news" file which may get displayed at the start of every game.
X
XCreate a folder called "Dungeon" in the "top" folder. This is where we'll
Xplace the files needed to run NetHack.
X
XFinally, Think C 4.0 users should have no problem compiling the NetHack
Xsources, as distributed.  If you make changes to the sources then consider
Xbacking up your disk to prevent problems.  Also, trash (or alter the
Xcreator signature of) older versions of NetHack 3.0 to avoid conflicts.
X
XOkay, let's get started.  We're going to make 3 applications, in order:
X(1) makedefs, to create customized files for the game, (2) spec_lev, to
Xcreate special challenging maze-like levels and (3) nethack!  The full
Xbuild from scratch takes about an hour using Think C 4.0 .
X
X
XMacintosh Configuration
X================
XEdit the header file "config.h" (in the include folder) as follows.  The
Xchanges below occur sequentially.  Scan forward to find:
X
X * Section 1:	OS selection.
X
XComment out: #define UNIX
XUncomment  : #define MACOS {bottom of the ifdef __MSDOS__ else clause}.
X
XScan forward to the segment:
X
X#ifdef MACOS
X#define THINKC4		/* for the Think C 4.0 compiler */
X
XNote that marginal support has been provided for other compilers but it
Xwill take some work to complete the build using those compilers.  This
Xsegment is configured properly for Think C 4.0 users, by default.  If your
Xcompiler doesn't handle the "defined(x)" compiler directive then you
Xshould define "KR1ED", this is done automatically here for LSC and AZTEC.
X
XScan forward to:
X
X * Section 2:	Some global parameters and filenames.
X
XChange "izchak" to a suitable wizard id.  A good choice is "wizard".
XThis is the name that needs to appear in the NetHack "Set Options..."
Xdialog in order to enable the selection of wizard (debug) mode.
X
XComment out: #define LOGFILE "logfile"
X
XScan forward to:
X
X * Section 3:	Definitions that may vary with system type.
X
XThe configuration here is okay for THINKC4, LSC and AZTEC.
X     
XScan forward to:
X
X * Section 4:  THE FUN STUFF!!!
X
XThe defines here default to configuring a full-featured game.  If you want
Xa current indicator of your score during play (recommended) then
X
XUncomment:   #define SCORE_ON_BOTL
X
XSave the config.h file.
X
XIf you customize the game then look at the header files macconf.h and
Xsystem.h. This isn't necessary for simply building the default game.
X
X
XBuilding Makedefs
X================
XMakedefs depends on the source files:
X    alloc.c  macfile.c  makedefs.c  monst.c  objects.c  panic.c
X
XThink C 4.0 users should open the project file "makedefs.proj".  Others
Xshould refer to Makefile.src for help.
X
XWe need to re-configure for makedefs so Open the header file "config.h".
XScan forward (in Section 1) to:
X
X#ifdef MACOS
X
XComment out: #define CUSTOM_IO .
XUncomment  : #define MAKEDEFS_C .
X
XClose and save the config.h file.
X
XBuild the makedefs application. The Think C 4.0 project uses resources
Xfrom the "makedefs.proj.rsrc" file.
X
XSave the application in the "top" folder and Close the project.
X
XRun the makedefs application, sequentially choosing all seven options.
XThis will require re-launching each time.  You've now created additional
Xauxiliary files for the game and added icons and signatures to these 12
Xfiles (in the auxil folder): cmdhelp, data, help, hh, history, license,
XMacHelp, news, opthelp, oracles, record, and rumors. These files should be
Xcopied into the "Dungeon" folder.
X
XIf you decide to change features in the game, remember to always rebuild
Xmakedefs first to setup the needed data structures and so on for the game.
X
X
XBuilding Spec_levs
X================
XThis application depends on the source files:
X    alloc.c      lev_comp.c  lev_lex.c   lev_main.c
X    macfile.c    monst.c     objects.c   panic.c
X
XIf you copied the alternate file others:lev_lex.c, you should remove it
Xnow to avoid problems with src:lev_lex.c.
X
XThink C 4.0 users should open the project file "spec_lev.proj".  Others
Xshould refer to Makefile.src for help.
X
XThe changes needed to build this application are more complicated than
Xbefore, however the checklist provided below should cover all the bases.
XWe need to re-configure for spec_levs (and subsequently for NetHack) so
XOpen the header file "config.h".
X
XScan forward (in Section 1) to:
X
X#ifdef MACOS
X
XComment out: #define MAKEDEFS_C
X
XClose and save the header file "config.h".
X
XOpen the source file (in the src folder) "lev_lex.c".  Make the following
Xchanges, which appear sequentially:
X    Find                                    Replace with
X    {... near the beginning ...}
X    int yyleng; extern char yytext[];       int yyleng; extern char *yytext;
X    int yymorfg;                            int yymorfg;
X    extern char *yysptr, yysbuf[];          extern char *yysptr, *yysbuf;
X    int yytchar;                            int yytchar;
X    FILE *yyin ={stdin}, *yyout ={stdout};  FILE *yyin =stdin, *yyout =stdout;
X    {... near the end ...}
X    {... If you're using LSC or THINKC4 comment out: ...}
X    {... #define NLSTATE yyprevious=YYNEWLINE ...}
X    char yytext[YYLMAX];                    char *yytext;
X    {... Skip a line ...}
X    char yysbuf[YYLMAX];                    char *yysbuf;
X    char *yysptr = yysbuf;                  char *yysptr;
X
XScan backward (near the beginning) to:
X
X#define MONDATA_H	/* comment this line for pre-compiled headers */
X#define MONFLAG_H	/* comment this line for pre-compiled headers */
X
XComment out: #define MONDATA_H and MONFLAG_H
X
XCut the line:
X
X#include "hack.h"
X
Xand Paste it back in again at the very beginning of the file!
X
XSave the changes to lev_lex.c and close the file.
X
XOpen the source file, "lev_comp.c".
X
XScan forward to:
X
X#define MONDATA_H	/* comment this line for pre-compiled headers */
X#define MONFLAG_H	/* comment this line for pre-compiled headers */
X
XComment out: #define MONDATA_H and MONFLAG_H
X
XCut the line:
X
X#include "hack.h"
X
Xand Paste it back in again at the very beginning of the file!
X
XScan forward (near the middle of the file) and make this change:
X    Find                                    Replace with
X    #endif not lint                         #endif /* not lint */
X
XSave the changes to lev_comp.c and close the file.
X
XFinally, we need to block some compiler directives in the source files
X"alloc.c" and "panic.c" in order to use pre-compiled headers.
X
XOpen the source file "alloc.c".
X
XComment out: #define ALLOC_C and EXTERN_H
X
XSave the changes to alloc.c and close the file.
X
XOpen the source file "panic.c".
X
XComment out: #define NEED_VARARGS
X
XSave the changes to panic.c and close the file.
X
XNow we need to prepare the pre-compiled header files "hack.h"
Xand "config.h".  We'll do this again in the NetHack project.
X
XShell out to the Finder and _copy_ the files hack.h and config.h
Xto pre_hack.h and pre_config.h, respectively.  Be careful not to
Xlose these files as you'll need them to complete the build.  Switch
Xback to the compiler.
X
XOpen the file "pre_hack.h".  Choose the Source menu option Precompile
Xand save the resulting file as "hack.h" (overwriting the old hack.h).
XOpen the file "pre_config.h" and Precompile it saving the result as
X"config.h" (again overwrite the old config.h).
X
XBuild the spec_lev application and save it into the "top" folder.  Close
Xthe spec_lev project.
X
XBefore running the spec_lev application let's restore the pre-compiled
Xheader files.  Trash "hack.h" and "config.h".  Now rename "pre_hack.h" and
X"pre_config.h" to "hack.h" and "config.h", respectively.
X
XRun the spec_lev application, it will show you what file it is currently
Xworking on and create the 5 special levels: castle, endgame, tower1,
Xtower2 and tower3 in the top folder. These 5 files should be moved into
Xthe Dungeon folder.
X
XIf you're motivated to create customized special levels it should be
Xpossible to modify the special level compiler to accommodate your efforts.
XYou'll also want to edit the "descrip[]" and "argc" variables, in
Xlev_main.c within the ifdef MACOS segments, to get the compiler to
Xrecognize your custom levels.  You probably won't bother (no one has)!
X
XIf you decide to change features in the game, remember to always rebuild
Xspec_levs to reflect those changes in the special level files.
X
X
XBuilding NetHack
X================
XThis is what you've been waiting for!  The file "Segments.mac" shows the
Xsource dependencies for this application and suggests a workable scheme
Xfor creating properly sized segments.
X
XThink C 4.0 users should open the project file "nethack.proj".  Others
Xshould refer to the various Makefiles for help.
X
XThe checklist below indicates the changes needed to build the game.
X
XOpen the header file "config.h".
X
XScan forward (in Section 1) to:
X
X#ifdef MACOS
X
XUncomment:   #define CUSTOM_IO
X
XSave the changes to config.h and close the file.
X
XOpen the source file, "topten.c".
X
XScan forward to:
X
X#define MONATTK_H	/* comment line for pre-compiled headers */
X#define MONFLAG_H	/* comment line for pre-compiled headers */
X
XComment out: #define MONATTK_H and MONFLAG_H
X
XScan forward to:
X
X#define	POINTSMIN	1	/* must be > 0 */
X#define	ENTRYMAX	100	/* must be >= 10 */
X
XChange POINTSMIN to 51 and ENTRYMAX to 50 to reduce the size and
Xclutter in the record file.
X
XComment out: #define PERS_IS_UID
X
XClose topten.c and save the changes.
X
XThink C 4.0 users are going to, again, use pre-compiled headers and
Xthis requires a minor lexical change to the files listed below.  We'll
Xuse a feature from the Search menu to make this operation easier.
X
XFiles needing a lexical change for pre-compiled headers:
Xapply.c     end.c       extralev.c  mkroom.c    mon.c       monmove.c
Xpager.c     pctty.c     pri.c       priest.c    save.c      shk.c
Xsounds.c    termcap.c   topl.c
X
XInvoke the "Find" command from the "Search" menu. Enter these fields:
X    Search For:                            Replace with:
X    ^\(#.*pre-compiled headers \*\/\)      /*\1
X
XCheck the "Grep" and "Multi-File Search" check boxes (you'll be
Xlooking in all .c files) then click the "Don't Find" button.
X
XNow repeat this sequence:
X1) Select "Find in Next File" from the "Search" menu.
X2) When it finally makes a match, Select "Replace All".
X3) Click the "Okay" button in the ensuing alert and then close and save
X    the file.  Now go back to (1), until there are no more matches.
X
XShell out to the Finder and then _copy_ the files hack.h and config.h to
Xpre_hack.h. and pre_config.h, respectively.  Switch back to the compiler.
X
XOpen the file "pre_hack.h" and Precompile it, saving the result as "hack.h"
X(overwriting the old hack.h).  Open the file "pre_config.h" and Precompile
Xit, saving the result as "config.h" (overwriting the old config.h).
X
XOpen the "Options" dialog (under the Edit menu) and choose the
X"Code Generation" radio button.  Look to be sure that "MacHeaders" is
X_not_ being automatically being included in the project (unchecked).
XAlso, make sure that the other options here are set to your liking.
X
XBuild the application, this make take a few minutes. Save the game into
Xthe dungeon folder. Close the nethack project and you're ready to play the
Xgame (I hope all went well).
X
X
XMiscellaneous Notes
X================
XLow Memory:
XIf you are attempting to build NetHack 3.0 on a 1M Macintosh using Think C
X4.0, then memory may be a problem.  It is suggested that you turn off
Xdebugging info for monst.c and objects.c .  Also, if for some reason,
Xcompilation stops in the segment containing these two files after they
Xhave been compiled, then you should drag these two files into a separate
Xsegment, finish compiling the files of the original segment and then
Xrestore these two files to the original segment.  Alternatively, you may
Xdecide to "Kompile" monst.c and objects.c separately while preserving the
Xgiven segmentation scheme.
X
XCleanup:
XIt's a good idea to always rebuild the makedefs and spec_lev applications
Xfrom scratch.  Therefore you can trash these applications and also remove
Xthe objects from their respective projects (Think C compilers) to conserve
Xdisk space.  The same can be done for your nethack project. Consider the
Xchanges outlined above and undo them as needed to rebuild the project, if
Xyou decide to modify the game.  If you're satisfied with the "default"
Xgame you can trash all the files for a real saving!
X
XCompatibility:
XYou should trash bones and save files from previous versions since they
Xwill not work with this version.  The single exception is that pl9 bones
Xand saves work with pl10.  Generally, record files will always work however
Xnew scores may have a different format.  It may be more convenient to start
Xfresh with a new scoreboard (record file) for each patchlevel.
X
XExtra Memory:
XIf you can afford the RAM space you might consider giving the game a 1M
Xpartition in Multifinder instead of the default 750k.
X
XSupport:
XBug reports should be submitted to the InterNet e-mail address:
Xnethack-bugs@linc.cis.upenn.edu
X
XWe, the members of the Macintosh NetHack Development Team, hope you enjoy
Xthe game. We've worked hard at porting and polishing it to make it behave
Xin the Macintosh way!
END_OF_FILE
if test 15825 -ne `wc -c <'Install.mac'`; then
    echo shar: \"'Install.mac'\" unpacked with wrong size!
fi
# end of 'Install.mac'
if test -f 'others/exesmurf.c' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'others/exesmurf.c'\" to \"'others/exesmurf.c.orig'\"
  mv -f 'others/exesmurf.c' 'others/exesmurf.c.orig'
fi
echo shar: Extracting \"'others/exesmurf.c'\" \(13430 characters\)
sed "s/^X//" >'others/exesmurf.c' <<'END_OF_FILE'
X/******************************************************************************
X*                                                                             *
X*                         EXE header list and modify                          *
X*                                                                             *
X*                        by Pierre Martineau, 91/01/29                        *
X*                                                                             *
X*                                Version 1.2                                  *
X*                                                                             *
X>*****************************************************************************<
X* Modified (stephen@estragon.uchicago.edu):                                   *
X* 1990oct23 sps Overlay splitter-outer first cut                              *
X*        31     Error handling; some #defines                                 *
X*     nov01     /l                                                            *
X*   91jan29     Changed default overlay file names to conform to ovlmgr 30a0  *
X******************************************************************************/
X
X#include <string.h>
X#include <stdlib.h>
X#include <stdio.h>
X#include <math.h>
X
X/** parameters ***************************************************************/
X#define MAXFILENAME 128   /* Probably overkill - theoretical limit is 80     */
X#define NPARTS	    36	  /* Maximum # of overlay files (excluding root .EXE)*/
X#define COPYBUFSIZE 32768 /* Fair sized buffer for file copy                 */
X#define BAKEXT      ".BAK"/* Extension for .exe backups                      */
X#define OVLEXT      ".OVL"/* Default extension for overlay files             */
X/* #define MANYZEROES */  /* Old style default: foo00001.ovl, not foo0.ovl   */
X/*****************************************************************************/
X
X#define BOOLEAN int
X#define TRUE    1
X#define FALSE   0
X
Xint sstrccnt(register char const *s, register char c)
X  { int n = 0;
X
X    while (*s) if (*s++ == c) n++;
X    return n;
X  }
X
XFILE *wrkfile, *outfile;
Xlong min, max, stk;
XBOOLEAN listflg = FALSE;
XBOOLEAN verbose = FALSE;
XBOOLEAN minflg = FALSE;
XBOOLEAN maxflg = FALSE;
XBOOLEAN stkflg = FALSE;
X
Xint column = 0;
X
Xstruct exehdr {
Xunsigned signature;
Xunsigned mod512;
Xunsigned pages;
Xunsigned relocitems;
Xunsigned headerparas;
Xunsigned minalloc;
Xunsigned maxalloc;
Xunsigned ss;
Xunsigned sp;
Xunsigned checksum;
Xunsigned ip;
Xunsigned cs;
Xunsigned relocptr;
Xunsigned ovlnum;
X} exehdr_area;
X
Xmain(argc, argv)
Xint argc;
Xchar *argv[];
X{
Xchar *dot, *slash;
Xchar fname[MAXFILENAME], oname[MAXFILENAME], zname[MAXFILENAME];
Xchar *jname = NULL;
Xchar *args;
Xint i;
Xlong offset, oldstk;
Xunsigned nparts = 0, part = 0, partstart[NPARTS + 2];
X
X    printf("EXE list and modify V1.1s, by Pierre Martineau, 90/05/20.\n");
X    printf("This program may be freely distributed.\n");
X
X	if ((argc < 2) || (argc > NPARTS + 2)) {
X        usage();
X        return;
X    }
X
X/*  Process any remaining arguments  */
X
X    if (argc == 2) {
X        listflg = TRUE;
X        verbose = TRUE; /* ??? */
X    }
X    else {
X        i = 2;
X        while (argc-- > 2) {
X            args = argv[i];
X	    if ('0' <= args[0] && args[0] <= '9') { /* File split request */
X			if (nparts >= NPARTS) {
X			printf("\nToo many .OVL files requested (max. %d)\n", NPARTS);
X		    usage();
X		    return;
X		}
X		else if (!atoi(args)) {
X		    printf("\nCan't relocate the root overlay (#0)\n");
X		    usage();
X		    return;
X		}
X		else if (nparts && partstart[nparts - 1] >= atoi(args)) {
X		    printf("\nOverlay starts must be in ascending order\n");
X		    usage();
X		    return;
X		}
X		partstart[nparts++] = atoi(args);
X	    } else {
X		if ((args[0] != '-') && (args[0] != '/')) {
X		    printf("\nInvalid switch in paramater %s!\n", argv[i]);
X			usage();
X			return;
X		}
X		args++;
X		if (strnicmp(args, "min", 3) == 0) {
X		    args += 3;
X		    min = atol(args);
X		    minflg = TRUE;
X		}
X		else if (strnicmp(args, "max", 3) == 0) {
X		    args += 3;
X		    max = atol(args);
X		    maxflg = TRUE;
X		}
X		else if (strnicmp(args, "stk", 3) == 0) {
X		    args += 3;
X		    stk = atol(args);
X		    stkflg = TRUE;
X		}
X		else if (strnicmp(args, "v", 1) == 0) {
X		    listflg = TRUE;
X                    verbose = TRUE;
X                }
X                else if (strnicmp(args, "l", 1) == 0)
X                    listflg = TRUE;
X                else if (strnicmp(args, "p", 1) == 0) {
X                    args++;
X                    jname = args;
X                }
X		else {
X		    printf("\nInvalid paramater %s!\n", argv[i]);
X		    usage();
X		    return;
X		}
X            }
X            i++;
X        }
X    }
X
X/*  Extract filename from first argumemt  */
X
X    strcpy(fname, argv[1]);
X    dot = strrchr(fname, '.');
X    slash = strrchr(fname, '\\');
X    if ((dot == NULL) || (slash > dot))
X        strcat(fname, ".exe");
X
X    if (nparts) {
X	strcpy(oname,fname);
X	*strrchr(fname, '.') = '\0';
X	strcat(fname,BAKEXT);
X	if (!stricmp(oname,fname)) {
X	    printf(
X                "\nI refuse to split a file with extension "BAKEXT": %s\n",
X                oname
X            );
X	    return;
X	}
X        if (!jname || nparts > 1 && !sstrccnt(jname, '?')) {
X            char ext[5];
X            char *t;
X
X            if (!jname) {
X                strcpy(zname, oname);
X                *strrchr(zname, '.') = '\0';
X                strcpy(ext, OVLEXT);
X            } else {
X                if (strrchr(jname, '.') &&
X                     (!strrchr(jname, '\\') ||
X                         strrchr(jname, '.') > strrchr(jname, '\\')
X                     )
X                ) {
X                    strncpy(ext, strrchr(jname, '.'), sizeof(ext));
X                    ext[sizeof(ext) - 1] = '\0';
X                    strncpy(zname, jname, strrchr(jname, '.') - jname);
X                    zname[strrchr(jname, '.') - jname] = '\0';
X                } else {
X                    strcpy(zname, jname);
X                    strcpy(ext, OVLEXT);
X                }
X            }
X            t = strrchr(zname, '\\') ? strrchr(zname, '\\') + 1:
X                strrchr(zname, ':') ? strrchr(zname, ':') + 1:
X                zname;
X            if (strlen(t) >= 8)
X                t[7] = '\0';
X#if defined(MANYZEROES)
X	    while (strlen(t) < 8)
X#endif
X	      strcat(t, "?");
X            strcat(zname, ext);
X            jname = zname;
X        }
X	if (rename(oname,fname)) { /* This assumes oldname, newname.
X				      There's some confusion. OK for TC2.0 */
X	    printf("\nCouldn't rename (original) %s to %s\n", oname, fname);
X	    return;
X	}
X	if ((outfile = fopen(oname, "wb")) == NULL) {
X            printf("\nCouldn't create file %s\n",oname);
X            return;
X        }
X    }
X
X    if ((wrkfile = fopen(fname, "r+b")) == NULL) {
X        printf("\nCouldn't open file %s\n", fname);
X        return;
X    }
X
X    fread(&exehdr_area, sizeof (struct exehdr), 1, wrkfile);
X    if (exehdr_area.signature != 0x5a4d) {
X        printf("\nNot an EXE file!\n");
X        return;
X    }
X
X    while(!feof(wrkfile)) {
X        if (nparts) {
X	    if (exehdr_area.ovlnum == partstart[part]) {
X	         fclose(outfile);
X                 {
X                     int p = part + 1;
X                     strcpy(oname, jname);
X                     while (sstrccnt(oname, '?') > 1) {
X                         *strrchr(oname, '?') = '0' + p % 10;
X                         p /= 10;
X                     }
X                     *strchr(oname, '?') = (p > 9 ? 'a' - 10 : '0') + p;
X                 }
X                 part++;
X		 if ((outfile = fopen(oname, "wb")) == NULL) {
X                     printf("\nCan't open file %s\n", oname);
X                     return;
X                 }
X	    }
X            fwrite(&exehdr_area, sizeof (struct exehdr), 1, outfile);
X            if (ferror(outfile)) {
X                printf("\nWrite error while moving overlay header in %s\n", oname);
X                return;
X            }
X	}
X        if (listflg)
X            show_hdr();
X        else if (nparts)
X            printf("[overlay %d]\r", exehdr_area.ovlnum); /* Keep talking... */
X        if ((minflg || maxflg || stkflg) && (exehdr_area.ovlnum == 0) && (exehdr_area.signature == 0x5a4d)) {
X            if (minflg)
X                exehdr_area.minalloc = min;
X            if (maxflg)
X                exehdr_area.maxalloc = max;
X            if (stkflg) {
X                oldstk = exehdr_area.sp;
X                exehdr_area.sp = stk;
X                if (!minflg) {
X                    exehdr_area.minalloc += ((stk - oldstk) / 16);
X                    printf("\nAdjusting size of minalloc!\n");
X                }
X            }
X            fseek(nparts ? outfile : wrkfile, ftell(wrkfile) - sizeof (struct exehdr), SEEK_SET);
X            fwrite(&exehdr_area, sizeof (struct exehdr), 1, nparts ? outfile : wrkfile);
X            if (ferror(nparts ? outfile : wrkfile)) {
X                printf("Write error while trying to update header!\n");
X                fclose(nparts ? outfile : wrkfile);
X                return;
X            }
X        }
X        offset = exehdr_area.pages;
X        offset *= 512L;
X        offset -= sizeof(struct exehdr);
X        if (nparts) { /* Copy the stuff across */
X	    static char buffer[COPYBUFSIZE];
X	    while (offset > sizeof(buffer)) {
X	         fread(buffer, sizeof(buffer), 1, wrkfile);
X                 if (ferror(wrkfile)) {
X                     printf("\nRead error in overlay body\n");
X                     return;
X                 }
X		 fwrite(buffer, sizeof(buffer), 1, outfile);
X                 if (ferror(outfile)) {
X                     printf("\nWrite error moving overlay body, file %s\n", oname);
X                     return;
X                 }
X		 offset -= sizeof(buffer);
X	    }
X	    fread(buffer, (unsigned)offset, 1, wrkfile);
X            if (ferror(wrkfile)) {
X                printf("\nRead error in overlay body\n");
X                return;
X            }
X            fwrite(buffer, (unsigned)offset, 1, outfile);
X            if (ferror(outfile)) {
X                printf("\nWrite error moving overlay body, file %s\n", oname);
X                return;
X            }
X        } else fseek(wrkfile, offset, SEEK_CUR);
X        fread(&exehdr_area, sizeof (struct exehdr), 1, wrkfile);
X        if (ferror(wrkfile)) {
X            printf("Read error while trying to get a header!\n");
X            fclose(wrkfile);
X            return;
X        }
X    }
X    if (nparts) {
X        fclose(outfile);
X        if (!listflg) printf("                    \r");
X    }
X    fclose(wrkfile);
X    if (listflg && !verbose && column % 4) printf("\n");
X}
X
Xshow_hdr()
X{
Xlong lsize;
X
X    lsize = exehdr_area.pages;
X    if (exehdr_area.mod512 != 0)
X        lsize--;
X    lsize *= 512L;
X    lsize += exehdr_area.minalloc * 16;
X    lsize += exehdr_area.mod512;
X    lsize -= exehdr_area.headerparas * 16;
X
X    if (verbose) {
X        printf("\nOverlay: %d\n", exehdr_area.ovlnum);
X        printf("Size (512 byte pages)\t-%6x\t\t%6u\n", exehdr_area.pages, exehdr_area.pages);
X        printf("Remainder (last page)\t-%6x\t\t%6u\n", exehdr_area.mod512, exehdr_area.mod512);
X        printf("Header size (in paras)\t-%6x\t\t%6u\n", exehdr_area.headerparas, exehdr_area.headerparas);
X        printf("Minalloc (in paras)\t-%6x\t\t%6u\n", exehdr_area.minalloc, exehdr_area.minalloc);
X        printf("Maxalloc (in paras)\t-%6x\t\t%6u\n", exehdr_area.maxalloc, exehdr_area.maxalloc);
X        printf("Load size (in bytes)\t-%6lx\t\t%6lu\n", lsize, lsize);
X        printf("Relocation items\t-%6x\t\t%6u\n", exehdr_area.relocitems, exehdr_area.relocitems);
X        printf("Relocation table offset\t-%6x\t\t%6u\n", exehdr_area.relocptr, exehdr_area.relocptr);
X        printf("Checksum\t\t-%6x\t\t%6u\n", exehdr_area.checksum, exehdr_area.checksum);
X        printf("Initial CS:IP\t\t-  %04x:%04x\n", exehdr_area.cs, exehdr_area.ip);
X        printf("Initial SS:SP\t\t-  %04x:%04x\n", exehdr_area.ss, exehdr_area.sp);
X    } else {
X        if (!exehdr_area.ovlnum) {
X            printf("\nOverlay: %d\n", exehdr_area.ovlnum);
X            printf("Minalloc (in paras)\t-%6x\t\t%6u\n", exehdr_area.minalloc, exehdr_area.minalloc);
X            printf("Maxalloc (in paras)\t-%6x\t\t%6u\n", exehdr_area.maxalloc, exehdr_area.maxalloc);
X            printf("Stored size (in bytes)\t-%6lx\t\t%6lu\n", exehdr_area.pages * 512L, exehdr_area.pages * 512L);
X            printf("Load size (in bytes)\t-%6lx\t\t%6lu\n", lsize, lsize);
X            printf("Initial CS:IP, SS:SP\t-  %04x:%04x\t  %04x:%04x\n", exehdr_area.cs, exehdr_area.ip, exehdr_area.ss, exehdr_area.sp);
X	} else {
X	    static bis = 0;
X	    if (!bis++)
X                printf("\nOvl StrdSz LoadSz | Ovl StrdSz LoadSz | Ovl StrdSz LoadSz | Ovl StrdSz LoadSz\n");
X            printf("%3d:%6lu %6lu%s", exehdr_area.ovlnum, exehdr_area.pages * 512L, lsize, ++column % 4 ? " | " : "\n");
X        }
X    }
X}
X
Xusage()
X{
X    printf("\nUsage: exesmurf exe_file [/l] [/v] [/min#####] [/max#####] [/stk#####]\n");
X    printf("                [n1 n2...nn] [/p????????.???]\n");
X    printf("       where: min   = minalloc\n");
X    printf("              max   = maxalloc\n");
X    printf("              stk   = stack size\n");
X    printf("              ##### = decimal number of paragraphs\n");
X    printf("              ni    = overlay starting each new .OVL file, n1 < n2 <...< nn\n");
X    printf("              p     = DOS filename, maybe with ?s, for overlay files.\n");
X}
END_OF_FILE
if test 13430 -ne `wc -c <'others/exesmurf.c'`; then
    echo shar: \"'others/exesmurf.c'\" unpacked with wrong size!
fi
# end of 'others/exesmurf.c'
if test -f 'others/exesmurf.doc' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'others/exesmurf.doc'\" to \"'others/exesmurf.doc.orig'\"
  mv -f 'others/exesmurf.doc' 'others/exesmurf.doc.orig'
fi
echo shar: Extracting \"'others/exesmurf.doc'\" \(4793 characters\)
sed "s/^X//" >'others/exesmurf.doc' <<'END_OF_FILE'
X		     PC NetHack Support Utilities
X		     ============================
X		     Last revision: 1991January29
X
XThis file contains documentation for the NetHack MS-DOS support
Xutility EXESMURF.EXE.  This utility examines and modifies the load
Xparameters of an .EXE file and can be used to split .OVL files off a
Xmonolithic overlaid executable using ovlmgr.
X
XEXESMURF
X--------
Xexesmurf FILENAME[.EXT] /v
Xexesmurf FILENAME[.EXT] /minN
Xexesmurf FILENAME[.EXT] /maxN
Xexesmurf FILENAME[.EXT] /l
Xexesmurf FILENAME[.EXT] N... [/pPATTERN]
X
XThe programme exesmurf is basically a reimplementation of Microsoft's
XEXEMOD utility.  However, this incarnation is one that is
X"overlay-aware" (as they say).  It will provide the user with
Xinformation about the executable and its overlays, and allow you to
Xmodify the executable's parameters and overlay locations.
X
XThis program is made available for all users who were not graced with a
Xrelease of EXEMOD in their Microsoft product, or who need the
Xadditional functionality it provides.
X
X/v.
XIf exesmurf is invoked with a filename as argument, optionally
Xfollowed by a /v, the filename's exeheader is listed for your viewing
Xpleasure, along with the headers of any Microsoft-format overlays the
Xfile may contain.  The listing is verbose; if there are many overlays
Xyou will want to redirect the output.  Note that the redundancy in the
Xoutput listing largely reflects redundancy in the file structure.
X
X/minN, /maxN, /stackN.
XExesmurf may also be used to modify the "minalloc", "maxalloc" and
X"stack" allocation parameters of the executable file.  This can be
Xaccomplished with the /min, /max, and /stack flags respectively.  Any
Xarguments to these flags should be *immediately* followed by a decimal
Xnumber N.  Note that this is inconsistent with the arguments to EXEMOD
Xwhich takes hex numbers, and *needs* a space between the flag and the
Xnumber.
X
X/l.
XThe /l option requests a version of the /v listing (see above) in
Xwhich the information about overlays is very much compressed; only
Xtheir decimal file and load sizes are given, in a multi-column format.
XThe resulting display will generally fit on a single screen.  This
Xturns out to be very useful when contemplating appropriate parameters
Xfor the overlay splitting operation described next.
X
XN... [/pPATTERN].
XThe overlay-unpacking function of exesmurf is invoked by following the
Xfilename argument by a sequence of decimal numbers.  Each of these
Xnumbers is an overlay number at which a new external overlay file is
Xto be started.  The main executable file will keep its old name after
Xthe overlays have been unloaded; the original input file will be
Xretained, with its extension changed to .BAK.  By default, the output
Xfiles will be derived from the input file name by appending a
Xdiscriminating character (in sequence, 0, 1, ..., 9, a, b, ..., z) to
Xthe basename and changing the extension to .OVL; but if the basename
Xis a full 8 characters long, the discriminating character will replace
Xthe last character instead.  This default is chosen for compatibility
Xwith ovlmgr.  The default may be overridden with the /p option, which
Xspecifies a file PATTERN - a file name, possibly complete with
Xextension, containing one or more ? characters (* is not allowed),
Xwhich will be replaced by discriminating characters.  If there is
Xexactly one questionmark, it will be replaced by a digit or letter in
Xthe sequence described above, but if more than one questionmark
Xappears a decimal numbering scheme is used instead.
X	Note that the numeric arguments are overlay numbers, not
Xindices, and they indicate the starting overlays of files.  This
Xpermits us to manipulate files in which (for some reason) the overlays
Xare not stored in ascending order, but it does mean that if a
Xmentioned overlay does not exist in the original file, no new overlay
Xfile will be started.  This is a realistic risk, since the Microsoft
Xlinker does not seem to generate overlays at all if there is no actual
Xcode generated into the segments in question.
X	Note further that this operation can be reversed with the DOS
Xcopy/b operation, always supposing that it works as documented in your
Xrelease of the operating system: the overlays are simply moved
Xpage-by-page to the external files.
X	No guarantees are made as to how this programme will behave if
Xthere is debug information or other strangeness stored after the last
Xoverlay in the file.
X
XWhenever exesmurf is invoked, the extension .EXE is assumed for the
Xfile if no extension is given.  Other extensions are probably only
Xmeaningful for examining overlay files.
X----------------------------------------------------------------------
XStephen P Spackman                       stephen@estragon.uchicago.edu
X----------------------------------------------------------------------
END_OF_FILE
if test 4793 -ne `wc -c <'others/exesmurf.doc'`; then
    echo shar: \"'others/exesmurf.doc'\" unpacked with wrong size!
fi
# end of 'others/exesmurf.doc'
if test -f 'src/lev_main.c' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'src/lev_main.c'\" to \"'src/lev_main.c.orig'\"
  mv -f 'src/lev_main.c' 'src/lev_main.c.orig'
fi
echo shar: Extracting \"'src/lev_main.c'\" \(3435 characters\)
sed "s/^X//" >'src/lev_main.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)lev_main.c	3.0	89/07/02
X/*	Copyright (c) 1989 by Jean-Christophe Collet */
X/* NetHack may be freely redistributed.  See license for details. */
X
X/*
X * This file contains the main function for the parser
X * and some useful functions needed by yacc
X */
X
X#include "hack.h"
X
X#ifdef MSDOS
X# undef exit
X# ifndef AMIGA
Xextern void FDECL(exit, (int));
X# endif
X#endif
X#ifdef LATTICE
Xlong *alloc(unsigned int);
X# ifdef exit
X#  undef exit
X# endif
X#include <stdlib.h>
X#endif
X
X#define MAX_ERRORS	25
X
Xextern int line_number;
Xchar *fname = "(stdin)";
Xint fatal_error = 0;
X
X/* Flex 2.3 bug work around */
Xint yy_more_len = 0;
X
Xint  FDECL (main, (int, char **));
Xint  NDECL (yyparse);
Xvoid FDECL (yyerror, (char *));
Xvoid FDECL (yywarning, (char *));
Xint  NDECL (yywrap);
Xvoid FDECL (init_yyin, (FILE *));
Xvoid FDECL (init_yyout, (FILE *));
X
X#ifdef LSC
X# define main _main
X#endif
Xmain(argc, argv)
Xint argc;
Xchar **argv;
X{
X	FILE *fin;
X	int i;
X
X#if defined(MACOS) && defined(SMALLDATA)
X# ifdef THINKC4
X#include <console.h>
X# endif
X#define YYLMAX	2048
X	extern char	*yysbuf, *yytext, *yysptr;
X	Handle temp;
X	Str255 name;
X	long	j;
X	extern struct permonst *mons;
X	extern struct objclass *objects;
X	/* 3 special level description files */
X	char *descrip[] = {"lev_comp", ":auxil:castle.des",
X			":auxil:endgame.des", ":auxil:tower.des"};
X
X	/* sub in the Nethack resource filename */
X	Strcpy((char *)name, "\021nethack.proj.rsrc");
X	yysbuf = (char *)alloc(YYLMAX);
X	yysptr = yysbuf;
X	yytext = (char *)alloc(YYLMAX);
X
X	(void)OpenResFile(name);
X	temp = GetResource(HACK_DATA, MONST_DATA);
X	if (temp) {
X		DetachResource(temp);
X		MoveHHi(temp);
X		HLock(temp);
X		i = GetHandleSize(temp);
X		mons = (struct permonst *)(*temp);
X	} else {
X		panic("Can't get MONST resource data.");
X	}
X	
X	temp = GetResource(HACK_DATA, OBJECT_DATA);
X	if (temp) {
X		DetachResource(temp);
X		MoveHHi(temp);
X		HLock(temp);
X		i = GetHandleSize(temp);
X		objects = (struct objclass *)(*temp);
X		for (j = 0; j< NROFOBJECTS+1; j++) {
X			objects[j].oc_name = sm_obj[j].oc_name;
X			objects[j].oc_descr = sm_obj[j].oc_descr;
X		}
X	} else {
X		panic("Can't get OBJECT resource data.");
X	}
X    argc = 4;    /* argv[0] is irrelevant, argv[i] = descrip[i] */
X    argv = descrip;
X#endif  /* !MACOS || !SMALLDATA */
X
X	init_yyout(stdout);
X	if (argc == 1) {		/* Read standard input */
X	    init_yyin(stdin);
X	    yyparse();
X	} else {			/* Otherwise every argument is a filename */
X	    for(i=1; i<argc; i++) {
X		    fname = argv[i];
X#ifdef MACOS
X		    fprintf(stdout, "Working on %s\n", fname);
X#endif
X		    fin = freopen(fname, "r", stdin);
X		    if (!fin) {
X			fprintf(stderr,"Can't open \"%s\" for input.\n", fname);
X			perror(fname);
X		    } else {
X			init_yyin(fin);
X			yyparse();
X		    }
X		    line_number = 1;
X		    fatal_error = 0;
X	    }
X	}
X#ifndef VMS
X	return 0;
X#else
X	return 1;       /* vms success */
X#endif /*VMS*/
X}
X
X/* 
X * Each time the parser detects an error, it uses this function.
X * Here we take count of the errors. To continue farther than
X * MAX_ERRORS wouldn't be reasonable.
X */
X
Xvoid yyerror(s)
Xchar *s;
X{
X	fprintf(stderr,"%s : line %d : %s\n",fname,line_number, s);
X	if (++fatal_error > MAX_ERRORS) {
X		fprintf(stderr,"Too many errors, good bye!\n");
X		exit(1);
X	}
X}
X
X/* 
X * Just display a warning (that is : a non fatal error)
X */
X
Xvoid yywarning(s)
Xchar *s;
X{
X	fprintf(stderr,"%s : line %d : WARNING : %s\n",fname,line_number,s);
X}
X
Xyywrap()
X{
X       return 1;
X}
END_OF_FILE
if test 3435 -ne `wc -c <'src/lev_main.c'`; then
    echo shar: \"'src/lev_main.c'\" unpacked with wrong size!
fi
# end of 'src/lev_main.c'
echo shar: End of archive 8 \(of 8\).
cp /dev/null ark8isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 8 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
