Path: utzoo!utgpu!watserv1!watmath!att!linac!pacific.mps.ohio-state.edu!zaphod.mps.ohio-state.edu!think.com!mintaka!ogicse!zephyr.ens.tek.com!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v12i028:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Patch10d
Message-ID: <6986@tekred.CNA.TEK.COM>
Date: 9 Feb 91 01:38:01 GMT
Sender: news@tekred.CNA.TEK.COM
Lines: 1942
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 12, Issue 28
Archive-name: NetHack3/Patch10d
Patch-To: NetHack3: Volume 7, Issue 56-93
Environment: 



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 4 (of 8)."
# Contents:  patch10.04
# Wrapped by billr@saab on Fri Feb  8 17:18:59 1991
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'patch10.04' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'patch10.04'\" to \"'patch10.04.orig'\"
  mv -f 'patch10.04' 'patch10.04.orig'
fi
echo shar: Extracting \"'patch10.04'\" \(50321 characters\)
sed "s/^X//" >'patch10.04' <<'END_OF_FILE'
X*** others/Makefile.os2	Mon May 21 22:15:49 1990
X--- others/Makefile.os2	Tue Jan 15 17:48:17 1991
X***************
X*** 1,5 ****
X! #	SCCS Id: @(#)Makefile.os2	3.0	90/02/22
X! #	OS/2 NetHack 3.0 Makefile for Microsoft(tm) C 5.1 -- Timo Hakulinen
X  #
X  #	NDMAKE ver 4.5 or MS-NMAKE is required, MS-MAKE will not work.
X  #	To enable either make utility, uncomment the respective
X--- 1,6 ----
X! #	SCCS Id: @(#)Makefile.os2	3.0	91/01/13
X! #	OS/2 NetHack 3.0 Makefile for Microsoft(tm) C 5.1 and 6.0
X! #	-- Timo Hakulinen
X  #
X  #	NDMAKE ver 4.5 or MS-NMAKE is required, MS-MAKE will not work.
X  #	To enable either make utility, uncomment the respective
X***************
X*** 27,38 ****
X  
X  # Enable the upper three lines for NDMAKE and lower three for MS-NMAKE.
X  # ($(MAKE) macro is often predefined, so we use $(MAKEBIN) instead).
X! MAKEBIN = make
X! AB	= $*.c
X! CB	= $*.c
X! #MAKEBIN = nmake
X! #AB	= $(@B).c
X! #CB	= $$(@B).c
X  
X  # For those of us who have these on PC.
X  #YACC	= yacc
X--- 28,39 ----
X  
X  # Enable the upper three lines for NDMAKE and lower three for MS-NMAKE.
X  # ($(MAKE) macro is often predefined, so we use $(MAKEBIN) instead).
X! #MAKEBIN = make
X! #AB	= $*.c
X! #CB	= $*.c
X! MAKEBIN = nmake
X! AB	= $(@B).c
X! CB	= $$(@B).c
X  
X  # For those of us who have these on PC.
X  #YACC	= yacc
X***************
X*** 45,72 ****
X  LEXYYC	= lexyy.c
X  
X  # Directories (makedefs hardcodes these, don't change them).
X! INCL	= ..\include
X! AUX	= ..\auxil
X! SRC	= ..\src
X! OBJ	= $(SRC)\o2
X  
X  # The game name and description.
X  GAME	= nethack
X  GAMEDES = NetHack 3.0
X  
X- # The game directory.
X- GAMEDIR = \games\$(GAME)
X- 
X  # Memory model, compile only, disable optimization, remove stack probes,
X  # 80286 instruction set, dedicated datasegment for items >= 5 bytes,
X  # pack structures on 1 byte boundaries, generate code for 8087
X  # coprocessor, compiler warning level, include file path.
X! CFLAGS	= /AL /c /Od /Gs /G2 /Gt5 /Zp1 /FPi87 /W1 /I$(INCL) $(CDFLAGS)
X  
X  # + prepare for CodeView symbolic debugger.
X  CDFLAGS =
X  #CDFLAGS = /Zi
X  
X  # Don't ignore case in symbols, no default lib search, stack 4096 bytes.
X  # (actually a bit of overkill), allow max 1024 segments in program.
X  LFLAGS	= /noig /nod /stack:4096 /seg:1024 $(LDFLAGS)
X--- 46,79 ----
X  LEXYYC	= lexyy.c
X  
X  # Directories (makedefs hardcodes these, don't change them).
X! INCL	= ..\include		# NetHack include files
X! AUX	= ..\auxil		# NetHack data and documentation
X! SRC	= ..\src		# NetHack source
X  
X+ # Modifiable directories.
X+ OBJ	= $(SRC)\o2		# Object files
X+ PLIBP	= c:\libp		# Protected mode C libraries
X+ RLIBP	= c:\lib		# Real mode C libraries
X+ GAMEDIR = \games\nethack	# The game directory
X+ 
X  # The game name and description.
X  GAME	= nethack
X  GAMEDES = NetHack 3.0
X  
X  # Memory model, compile only, disable optimization, remove stack probes,
X  # 80286 instruction set, dedicated datasegment for items >= 5 bytes,
X  # pack structures on 1 byte boundaries, generate code for 8087
X  # coprocessor, compiler warning level, include file path.
X! CFLAGS	= /AL /c /Od /Gs /G2 /Gt5 /Zp1 /FPi /W1 /I$(INCL) $(CDFLAGS) $(STDC)
X  
X  # + prepare for CodeView symbolic debugger.
X  CDFLAGS =
X  #CDFLAGS = /Zi
X  
X+ # Disable for MSC 5.1, enable for 6.0.
X+ STDC	=
X+ #STDC	= /D__STDC__
X+ 
X  # Don't ignore case in symbols, no default lib search, stack 4096 bytes.
X  # (actually a bit of overkill), allow max 1024 segments in program.
X  LFLAGS	= /noig /nod /stack:4096 /seg:1024 $(LDFLAGS)
X***************
X*** 75,89 ****
X  LDFLAGS =
X  #LDFLAGS = /CO
X  
X! # Protected mode C libraries for 8087 (change if necessary),
X! # OS/2 API entry points.
X! PLIBS	= llibc7p doscalls
X  
X  # C libraries used by makedefs and lev_comp (change if necessary).
X  # If compilation is done in DOS, enable the upper line, if in OS/2,
X  # the lower (protected mode libraries).
X! RLIBS	= llibc7r
X! #RLIBS	= $(PLIBS)
X  
X  # Module definition file for OS/2.
X  OS2DEFS	= $(GAME).def
X--- 82,98 ----
X  LDFLAGS =
X  #LDFLAGS = /CO
X  
X! # Protected mode C libraries for 8087 emulation (change if necessary),
X! # OS/2 API entry points.  For MSC 5.1, enable the upper line
X! # for 6.0 the lower.
X! PLIBS	= $(PLIBP)\llibcep $(PLIBP)\doscalls
X! #PLIBS	= $(PLIBP)\llibcep $(PLIBP)\os2
X  
X  # C libraries used by makedefs and lev_comp (change if necessary).
X  # If compilation is done in DOS, enable the upper line, if in OS/2,
X  # the lower (protected mode libraries).
X! #RLIBS	= $(RLIBP)\llibcer
X! RLIBS	= $(PLIBS)
X  
X  # Module definition file for OS/2.
X  OS2DEFS	= $(GAME).def
X*** others/lev_lex.c	Sun Jun  3 15:03:37 1990
X--- others/lev_lex.c	Tue Feb  5 11:36:47 1991
X***************
X*** 161,170 ****
X--- 161,178 ----
X  int NDECL (yyinput);
X  int NDECL (yywrap);
X  int NDECL (yylex);
X+ # ifdef NeXT
X+ void FDECL (yyunput, (int));
X+ void FDECL (yyoutput, (int));
X+ # else
X  int FDECL (yyunput, (int));
X  int FDECL (yyoutput, (int));
X+ # endif
X  #endif
X  
X+ void FDECL (init_yyin, (FILE *));
X+ void FDECL (init_yyout, (FILE *));
X+ 
X  #ifdef MSDOS
X  #undef exit
X  extern void FDECL(exit, (int));
X***************
X*** 197,203 ****
X  #define YYLMAX	2048
X  
X  #define MAPC 1
X! # line 62 "lev_comp.l"
X  #define YY_END_OF_BUFFER 57
X  typedef int yy_state_type;
X  static const short int yy_accept[274] =
X--- 205,211 ----
X  #define YYLMAX	2048
X  
X  #define MAPC 1
X! # line 70 "lev_comp.l"
X  #define YY_END_OF_BUFFER 57
X  typedef int yy_state_type;
X  static const short int yy_accept[274] =
X***************
X*** 585,596 ****
X  		continue; /* go to "YY_DO_BEFORE_ACTION" */
X  
X  case 1:
X! # line 63 "lev_comp.l"
X  { line_number++; yymore(); }	
X  	YY_BREAK
X  case 2:
X! # line 64 "lev_comp.l"
X! { BEGIN 0;
X  		  line_number++;
X  		  yytext[yyleng-7] = 0; /* Discard \nENDMAP */
X  		  yylval.map = (char *) alloc(strlen(yytext)+1);
X--- 593,617 ----
X  		continue; /* go to "YY_DO_BEFORE_ACTION" */
X  
X  case 1:
X! # line 71 "lev_comp.l"
X  { line_number++; yymore(); }	
X  	YY_BREAK
X  case 2:
X! # line 72 "lev_comp.l"
X! {
X! #ifdef FLEX_SCANNER
X! 		  /*
X! 		   * There is a bug in Flex 2.3 patch level < 6
X! 		   * (absent in previous versions)
X! 		   * that results in the following behaviour :
X! 		   * Once you enter an yymore(), you never exit from it.
X! 		   * This should do the trick!
X! 		   */
X! 		  extern int yy_more_len;
X! 
X! 		  yy_more_len = 0;
X! #endif
X! 		  BEGIN 0;
X  		  line_number++;
X  		  yytext[yyleng-7] = 0; /* Discard \nENDMAP */
X  		  yylval.map = (char *) alloc(strlen(yytext)+1);
X***************
X*** 599,797 ****
X  		}
X  	YY_BREAK
X  case 3:
X! # line 71 "lev_comp.l"
X  { line_number++; }
X  	YY_BREAK
X  case 4:
X! # line 72 "lev_comp.l"
X  return MAZE_ID;
X  	YY_BREAK
X  case 5:
X! # line 73 "lev_comp.l"
X  return LEVEL_ID;
X  	YY_BREAK
X  case 6:
X! # line 74 "lev_comp.l"
X  return GEOMETRY_ID;
X  	YY_BREAK
X  case 7:
X! # line 75 "lev_comp.l"
X  { BEGIN MAPC; line_number++; }
X  	YY_BREAK
X  case 8:
X! # line 76 "lev_comp.l"
X  return OBJECT_ID;
X  	YY_BREAK
X  case 9:
X! # line 77 "lev_comp.l"
X  return MONSTER_ID;
X  	YY_BREAK
X  case 10:
X! # line 78 "lev_comp.l"
X  return TRAP_ID;
X  	YY_BREAK
X  case 11:
X! # line 79 "lev_comp.l"
X  return DOOR_ID;
X  	YY_BREAK
X  case 12:
X! # line 80 "lev_comp.l"
X  return DRAWBRIDGE_ID;
X  	YY_BREAK
X  case 13:
X! # line 81 "lev_comp.l"
X  return MAZEWALK_ID;
X  	YY_BREAK
X  case 14:
X! # line 82 "lev_comp.l"
X  return REGION_ID;
X  	YY_BREAK
X  case 15:
X! # line 83 "lev_comp.l"
X  return RANDOM_OBJECTS_ID;
X  	YY_BREAK
X  case 16:
X! # line 84 "lev_comp.l"
X  return RANDOM_MONSTERS_ID;
X  	YY_BREAK
X  case 17:
X! # line 85 "lev_comp.l"
X  return RANDOM_PLACES_ID;
X  	YY_BREAK
X  case 18:
X! # line 86 "lev_comp.l"
X  return ALTAR_ID;
X  	YY_BREAK
X  case 19:
X! # line 87 "lev_comp.l"
X  return LADDER_ID;
X  	YY_BREAK
X  case 20:
X! # line 88 "lev_comp.l"
X  return NON_DIGGABLE_ID;
X  	YY_BREAK
X  case 21:
X! # line 89 "lev_comp.l"
X  return ROOM_ID;
X  	YY_BREAK
X  case 22:
X! # line 90 "lev_comp.l"
X  { yylval.i=D_ISOPEN; return DOOR_STATE; }
X  	YY_BREAK
X  case 23:
X! # line 91 "lev_comp.l"
X  { yylval.i=D_CLOSED; return DOOR_STATE; }
X  	YY_BREAK
X  case 24:
X! # line 92 "lev_comp.l"
X  { yylval.i=D_LOCKED; return DOOR_STATE; }
X  	YY_BREAK
X  case 25:
X! # line 93 "lev_comp.l"
X  { yylval.i=D_NODOOR; return DOOR_STATE; }
X  	YY_BREAK
X  case 26:
X! # line 94 "lev_comp.l"
X  { yylval.i=D_BROKEN; return DOOR_STATE; }
X  	YY_BREAK
X  case 27:
X! # line 95 "lev_comp.l"
X  { yylval.i=W_NORTH; return DIRECTION; }
X  	YY_BREAK
X  case 28:
X! # line 96 "lev_comp.l"
X  { yylval.i=W_EAST; return DIRECTION; }
X  	YY_BREAK
X  case 29:
X! # line 97 "lev_comp.l"
X  { yylval.i=W_SOUTH; return DIRECTION; }
X  	YY_BREAK
X  case 30:
X! # line 98 "lev_comp.l"
X  { yylval.i=W_WEST; return DIRECTION; }
X  	YY_BREAK
X  case 31:
X! # line 99 "lev_comp.l"
X  { yylval.i = -1; return RANDOM_TYPE; }
X  	YY_BREAK
X  case 32:
X! # line 100 "lev_comp.l"
X  return O_REGISTER;
X  	YY_BREAK
X  case 33:
X! # line 101 "lev_comp.l"
X  return M_REGISTER;
X  	YY_BREAK
X  case 34:
X! # line 102 "lev_comp.l"
X  return P_REGISTER;
X  	YY_BREAK
X  case 35:
X! # line 103 "lev_comp.l"
X  return A_REGISTER;
X  	YY_BREAK
X  case 36:
X! # line 104 "lev_comp.l"
X  { yylval.i=1; return LEFT_OR_RIGHT; }
X  	YY_BREAK
X  case 37:
X! # line 105 "lev_comp.l"
X  { yylval.i=3; return LEFT_OR_RIGHT; }
X  	YY_BREAK
X  case 38:
X! # line 106 "lev_comp.l"
X  { yylval.i=2; return CENTER; }
X  	YY_BREAK
X  case 39:
X! # line 107 "lev_comp.l"
X  { yylval.i=1; return TOP_OR_BOT; }
X  	YY_BREAK
X  case 40:
X! # line 108 "lev_comp.l"
X  { yylval.i=3; return TOP_OR_BOT; }
X  	YY_BREAK
X  case 41:
X! # line 109 "lev_comp.l"
X  { yylval.i=1; return LIGHT_STATE; }
X  	YY_BREAK
X  case 42:
X! # line 110 "lev_comp.l"
X  { yylval.i=0; return LIGHT_STATE; }
X  	YY_BREAK
X  case 43:
X! # line 111 "lev_comp.l"
X  { yylval.i=A_LAW; return ALIGNMENT; }
X  	YY_BREAK
X  case 44:
X! # line 112 "lev_comp.l"
X  { yylval.i=A_NEUTRAL; return ALIGNMENT; }
X  	YY_BREAK
X  case 45:
X! # line 113 "lev_comp.l"
X  { yylval.i=A_CHAOS; return ALIGNMENT; }
X  	YY_BREAK
X  case 46:
X! # line 114 "lev_comp.l"
X  { yylval.i=1; return ALTAR_TYPE; }
X  	YY_BREAK
X  case 47:
X! # line 115 "lev_comp.l"
X  { yylval.i=0; return ALTAR_TYPE; }
X  	YY_BREAK
X  case 48:
X! # line 116 "lev_comp.l"
X  { yylval.i=1; return UP_OR_DOWN; }
X  	YY_BREAK
X  case 49:
X! # line 117 "lev_comp.l"
X  { yylval.i=0; return UP_OR_DOWN; }
X  	YY_BREAK
X  case 50:
X! # line 118 "lev_comp.l"
X  { yylval.i=atoi(yytext); return INTEGER; }
X  	YY_BREAK
X  case 51:
X! # line 119 "lev_comp.l"
X  { yytext[yyleng-1] = 0; /* Discard the trailing \" */
X  		  yylval.map = (char *) alloc(strlen(yytext+1)+1);
X  		  strcpy(yylval.map, yytext+1); /* Discard the first \" */
X--- 620,818 ----
X  		}
X  	YY_BREAK
X  case 3:
X! # line 92 "lev_comp.l"
X  { line_number++; }
X  	YY_BREAK
X  case 4:
X! # line 93 "lev_comp.l"
X  return MAZE_ID;
X  	YY_BREAK
X  case 5:
X! # line 94 "lev_comp.l"
X  return LEVEL_ID;
X  	YY_BREAK
X  case 6:
X! # line 95 "lev_comp.l"
X  return GEOMETRY_ID;
X  	YY_BREAK
X  case 7:
X! # line 96 "lev_comp.l"
X  { BEGIN MAPC; line_number++; }
X  	YY_BREAK
X  case 8:
X! # line 97 "lev_comp.l"
X  return OBJECT_ID;
X  	YY_BREAK
X  case 9:
X! # line 98 "lev_comp.l"
X  return MONSTER_ID;
X  	YY_BREAK
X  case 10:
X! # line 99 "lev_comp.l"
X  return TRAP_ID;
X  	YY_BREAK
X  case 11:
X! # line 100 "lev_comp.l"
X  return DOOR_ID;
X  	YY_BREAK
X  case 12:
X! # line 101 "lev_comp.l"
X  return DRAWBRIDGE_ID;
X  	YY_BREAK
X  case 13:
X! # line 102 "lev_comp.l"
X  return MAZEWALK_ID;
X  	YY_BREAK
X  case 14:
X! # line 103 "lev_comp.l"
X  return REGION_ID;
X  	YY_BREAK
X  case 15:
X! # line 104 "lev_comp.l"
X  return RANDOM_OBJECTS_ID;
X  	YY_BREAK
X  case 16:
X! # line 105 "lev_comp.l"
X  return RANDOM_MONSTERS_ID;
X  	YY_BREAK
X  case 17:
X! # line 106 "lev_comp.l"
X  return RANDOM_PLACES_ID;
X  	YY_BREAK
X  case 18:
X! # line 107 "lev_comp.l"
X  return ALTAR_ID;
X  	YY_BREAK
X  case 19:
X! # line 108 "lev_comp.l"
X  return LADDER_ID;
X  	YY_BREAK
X  case 20:
X! # line 109 "lev_comp.l"
X  return NON_DIGGABLE_ID;
X  	YY_BREAK
X  case 21:
X! # line 110 "lev_comp.l"
X  return ROOM_ID;
X  	YY_BREAK
X  case 22:
X! # line 111 "lev_comp.l"
X  { yylval.i=D_ISOPEN; return DOOR_STATE; }
X  	YY_BREAK
X  case 23:
X! # line 112 "lev_comp.l"
X  { yylval.i=D_CLOSED; return DOOR_STATE; }
X  	YY_BREAK
X  case 24:
X! # line 113 "lev_comp.l"
X  { yylval.i=D_LOCKED; return DOOR_STATE; }
X  	YY_BREAK
X  case 25:
X! # line 114 "lev_comp.l"
X  { yylval.i=D_NODOOR; return DOOR_STATE; }
X  	YY_BREAK
X  case 26:
X! # line 115 "lev_comp.l"
X  { yylval.i=D_BROKEN; return DOOR_STATE; }
X  	YY_BREAK
X  case 27:
X! # line 116 "lev_comp.l"
X  { yylval.i=W_NORTH; return DIRECTION; }
X  	YY_BREAK
X  case 28:
X! # line 117 "lev_comp.l"
X  { yylval.i=W_EAST; return DIRECTION; }
X  	YY_BREAK
X  case 29:
X! # line 118 "lev_comp.l"
X  { yylval.i=W_SOUTH; return DIRECTION; }
X  	YY_BREAK
X  case 30:
X! # line 119 "lev_comp.l"
X  { yylval.i=W_WEST; return DIRECTION; }
X  	YY_BREAK
X  case 31:
X! # line 120 "lev_comp.l"
X  { yylval.i = -1; return RANDOM_TYPE; }
X  	YY_BREAK
X  case 32:
X! # line 121 "lev_comp.l"
X  return O_REGISTER;
X  	YY_BREAK
X  case 33:
X! # line 122 "lev_comp.l"
X  return M_REGISTER;
X  	YY_BREAK
X  case 34:
X! # line 123 "lev_comp.l"
X  return P_REGISTER;
X  	YY_BREAK
X  case 35:
X! # line 124 "lev_comp.l"
X  return A_REGISTER;
X  	YY_BREAK
X  case 36:
X! # line 125 "lev_comp.l"
X  { yylval.i=1; return LEFT_OR_RIGHT; }
X  	YY_BREAK
X  case 37:
X! # line 126 "lev_comp.l"
X  { yylval.i=3; return LEFT_OR_RIGHT; }
X  	YY_BREAK
X  case 38:
X! # line 127 "lev_comp.l"
X  { yylval.i=2; return CENTER; }
X  	YY_BREAK
X  case 39:
X! # line 128 "lev_comp.l"
X  { yylval.i=1; return TOP_OR_BOT; }
X  	YY_BREAK
X  case 40:
X! # line 129 "lev_comp.l"
X  { yylval.i=3; return TOP_OR_BOT; }
X  	YY_BREAK
X  case 41:
X! # line 130 "lev_comp.l"
X  { yylval.i=1; return LIGHT_STATE; }
X  	YY_BREAK
X  case 42:
X! # line 131 "lev_comp.l"
X  { yylval.i=0; return LIGHT_STATE; }
X  	YY_BREAK
X  case 43:
X! # line 132 "lev_comp.l"
X  { yylval.i=A_LAW; return ALIGNMENT; }
X  	YY_BREAK
X  case 44:
X! # line 133 "lev_comp.l"
X  { yylval.i=A_NEUTRAL; return ALIGNMENT; }
X  	YY_BREAK
X  case 45:
X! # line 134 "lev_comp.l"
X  { yylval.i=A_CHAOS; return ALIGNMENT; }
X  	YY_BREAK
X  case 46:
X! # line 135 "lev_comp.l"
X  { yylval.i=1; return ALTAR_TYPE; }
X  	YY_BREAK
X  case 47:
X! # line 136 "lev_comp.l"
X  { yylval.i=0; return ALTAR_TYPE; }
X  	YY_BREAK
X  case 48:
X! # line 137 "lev_comp.l"
X  { yylval.i=1; return UP_OR_DOWN; }
X  	YY_BREAK
X  case 49:
X! # line 138 "lev_comp.l"
X  { yylval.i=0; return UP_OR_DOWN; }
X  	YY_BREAK
X  case 50:
X! # line 139 "lev_comp.l"
X  { yylval.i=atoi(yytext); return INTEGER; }
X  	YY_BREAK
X  case 51:
X! # line 140 "lev_comp.l"
X  { yytext[yyleng-1] = 0; /* Discard the trailing \" */
X  		  yylval.map = (char *) alloc(strlen(yytext+1)+1);
X  		  strcpy(yylval.map, yytext+1); /* Discard the first \" */
X***************
X*** 798,820 ****
X  		  return STRING; }
X  	YY_BREAK
X  case 52:
X! # line 123 "lev_comp.l"
X  { line_number++; }
X  	YY_BREAK
X  case 53:
X! # line 124 "lev_comp.l"
X  ;
X  	YY_BREAK
X  case 54:
X! # line 125 "lev_comp.l"
X  { yylval.i = yytext[1]; return CHAR; }
X  	YY_BREAK
X  case 55:
X! # line 126 "lev_comp.l"
X  { return yytext[0]; }
X  	YY_BREAK
X  case 56:
X! # line 127 "lev_comp.l"
X  ECHO;
X  	YY_BREAK
X  case YY_STATE_EOF(INITIAL):
X--- 819,841 ----
X  		  return STRING; }
X  	YY_BREAK
X  case 52:
X! # line 144 "lev_comp.l"
X  { line_number++; }
X  	YY_BREAK
X  case 53:
X! # line 145 "lev_comp.l"
X  ;
X  	YY_BREAK
X  case 54:
X! # line 146 "lev_comp.l"
X  { yylval.i = yytext[1]; return CHAR; }
X  	YY_BREAK
X  case 55:
X! # line 147 "lev_comp.l"
X  { return yytext[0]; }
X  	YY_BREAK
X  case 56:
X! # line 148 "lev_comp.l"
X  ECHO;
X  	YY_BREAK
X  case YY_STATE_EOF(INITIAL):
X***************
X*** 1105,1111 ****
X      yyin = input_file;
X      yy_init = 1;
X      }
X! # line 127 "lev_comp.l"
X  
X  #ifdef	AMIGA
X  long *alloc(n)
X--- 1126,1132 ----
X      yyin = input_file;
X      yy_init = 1;
X      }
X! # line 148 "lev_comp.l"
X  
X  #ifdef	AMIGA
X  long *alloc(n)
X***************
X*** 1114,1116 ****
X--- 1135,1155 ----
X  	return ((long *)malloc (n));
X  }
X  #endif
X+ 
X+ /* routine to switch to another input file; needed for flex */
X+ void init_yyin( input_f )
X+ FILE *input_f;
X+ {
X+ #ifdef FLEX_SCANNER
X+ 	if (yyin != NULL)
X+ 	    yyrestart(input_f);
X+ 	else
X+ #endif
X+ 	    yyin = input_f;
X+ }
X+ /* analogous routine (for completeness) */
X+ void init_yyout( output_f )
X+ FILE *output_f;
X+ {
X+ 	yyout = output_f;
X+ }
X*** others/maintain.ovl	Mon May 28 21:08:14 1990
X--- others/maintain.ovl	Sun Feb  3 15:09:43 1991
X***************
X*** 1,6 ****
X  			Maintaining PC NetHack
X! 		       ========================
X! 		       Last revision: 1990may27
X  
X  The installation of the system of overlay management that currently
X  brings full-featured NetHack to the IBM PC and compatibles has
X--- 1,6 ----
X  			Maintaining PC NetHack
X! 		     ===========================
X! 		     Last revision: 1991january31
X  
X  The installation of the system of overlay management that currently
X  brings full-featured NetHack to the IBM PC and compatibles has
X***************
X*** 25,31 ****
X  traditional candidates for the overlaying strategy, however, NetHack
X  does not exhibit strongly phased behaviour; although much of the code
X  is not being used at any one moment, there is comparatively little
X! code that can be confidently said not to be related to or potentially
X  necessary for the immediate progress of the game.
X  	Furthermore we wished to develop an overlaying strategy that
X  did _not_ involve intimate knowledge of the operation of the
X--- 25,31 ----
X  traditional candidates for the overlaying strategy, however, NetHack
X  does not exhibit strongly phased behaviour; although much of the code
X  is not being used at any one moment, there is comparatively little
X! code that can confidently be said not to be related to or potentially
X  necessary for the immediate progress of the game.
X  	Furthermore we wished to develop an overlaying strategy that
X  did _not_ involve intimate knowledge of the operation of the
X***************
X*** 83,95 ****
X  a function name is typically followed by an open parenthesis if, and
X  only if, it is being declared, defined or invoked; if its address is
X  being taken it will necessarily be followed by some other token.
X! Furthermore (except in the unfortunate case of the ill-conceived
X! new-style ANSI declaration of a function that takes no parameters) it
X! will be observed that the number of parameters to a call of the
X! function (assuming that this number is fixed; if not, I grant, we
X! have a problem) is the same in all these contexts. This implies that
X! if all the modules of a programme are uniformly processed in the
X! context of a macro definition such as
X  
X  	#define zook(a,b) plenk(a,b)
X  
X--- 83,95 ----
X  a function name is typically followed by an open parenthesis if, and
X  only if, it is being declared, defined or invoked; if its address is
X  being taken it will necessarily be followed by some other token.
X! Furthermore it will be observed that (except in the unfortunate case
X! of the ill-conceived new-style ANSI declaration of a function that
X! takes no parameters) the number of parameters to a call of the
X! function (assuming that this number is fixed; if not, I grant, we have
X! a problem) is the same in all these contexts. This implies that if all
X! the modules of a programme are uniformly processed in the context of a
X! macro definition such as
X  
X  	#define zook(a,b) plenk(a,b)
X  
X***************
X*** 99,108 ****
X  map will report the existence of the function plenk() in place of
X  zook() -- UNLESS there was a place in the programme where the address
X  of zook was taken. In that case, the linker would report an
X! unresolved external reference for that symbol.
X  	That unresolved reference is, of course, precisely what we
X  need; if in another source file (one that did not see the macro
X! definition) we placed the function declaration
X  
X  	some_t zook(this_t a, that_t b)
X  	  { extern some_t plenk(this_t, that_t);
X--- 99,108 ----
X  map will report the existence of the function plenk() in place of
X  zook() -- UNLESS there was a place in the programme where the address
X  of zook was taken. In that case, the linker would report an
X! unresolved external reference for zook.
X  	That unresolved reference is, of course, precisely what we
X  need; if in another source file (one that did not see the macro
X! definition) we placed the function definition
X  
X  	some_t zook(this_t a, that_t b)
X  	  { extern some_t plenk(this_t, that_t);
X***************
X*** 218,224 ****
X  is, quite daftly to my mind, that the linker considers the identity
X  of segment names and combine classes better reason to combine
X  segments than the programmer's explicit instructions in the requested
X! overlay pattern are reason to keep them apart. Programmer, ask not
X  why...).
X  
X  Once again, that works fine except for the small matter of
X--- 218,224 ----
X  is, quite daftly to my mind, that the linker considers the identity
X  of segment names and combine classes better reason to combine
X  segments than the programmer's explicit instructions in the requested
X! overlay pattern is reason to keep them apart. Programmer, ask not
X  why...).
X  
X  Once again, that works fine except for the small matter of
X***************
X*** 301,308 ****
X  change or restructuring of the NetHack source code, which must remain
X  portable to many platforms other than the PC.
X  
X! If these observations do not daunt you, you are a true Bit Warrior
X! indeed (or aspiration anyway), and we await your comments with bait.
X  
X  ------------------------------------------------------------------------
X  
X--- 301,308 ----
X  change or restructuring of the NetHack source code, which must remain
X  portable to many platforms other than the PC.
X  
X! If these observations do not daunt you, you are a Bit Warrior indeed
X! (or aspiration anyway), and we await your comments with bait.
X  
X  ------------------------------------------------------------------------
X  
X***************
X*** 331,336 ****
X      same time.
X  
X  ------------------------------------------------------------------------
X! Stephen P Spackman                             stephen@tira.uchicago.edu
X  ------------------------------------------------------------------------
X  			     * Hack On! *
X--- 331,336 ----
X      same time.
X  
X  ------------------------------------------------------------------------
X! Stephen P Spackman                         stephen@estragon.uchicago.edu
X  ------------------------------------------------------------------------
X  			     * Hack On! *
X*** others/msdos.c	Tue Jun 26 21:20:12 1990
X--- others/msdos.c	Mon Feb  4 09:56:57 1991
X***************
X*** 1369,1374 ****
X--- 1369,1375 ----
X  {
X  	int fromfd, tofd, r;
X  	char *buf;
X+ 	extern genericptr_t FDECL(malloc, (size_t));
X  
X  	if ((fromfd = open(from, O_RDONLY|O_BINARY, 0)) < 0)
X  		return -1;
X***************
X*** 1393,1402 ****
X--- 1394,1410 ----
X  init_aline()
X  {
X  # ifdef __GNUC__
X+ /* line A calls nuke registers d0-d2,a0-a2; not all compilers regard these
X+    as scratch registers, though, so we save them
X+  */
X+ 	asm(" moveml d0-d2/a0-a2, sp@-");
X  	asm(" .word 0xa000; movel d0, __a_line");
X+ 	asm(" moveml sp@+, d0-d2/a0-a2");
X  # else
X+ 	asm(" movem.l d0-d2/a0-a2, -(sp)");
X  	asm(" .dc.w 0xa000");	/* tweak as necessary for your compiler */
X  	asm(" move.l d0, __a_line");
X+ 	asm(" movem.l (sp)+, d0-d2/a0-a2");
X  # endif
X  }
X  
X*** others/ovlmgr.asm	Mon May 28 00:49:26 1990
X--- others/ovlmgr.asm	Sun Feb  3 12:33:52 1991
X***************
X*** 1,13 ****
X! ;	SCCS Id: @(#)ovlmgr.asm 		90/05/27
X! ;  Copyright (c) 1989, 1990 Pierre Martineau and Stephen Spackman. All Rights Reserved.
X  ;  This product may be freely redistributed.  See NetHack license for details.
X  
X! VERSION 	EQU	3081h
X  
X  		PAGE	57,132
X  		TITLE	'DOS Overlay Manager for MSC 5.1+'
X! 		SUBTTL	'Copyright (c) 1989, 1990 Pierre Martineau and Stephen Spackman. All Rights Reserved.'
X  
X  ; acknowledgements:   - Many thanks to Norm Meluch for his invaluable help
X  ;		      - No thanks to Microsoft
X  ;		      - alltrsidsctysti!!!
X--- 1,15 ----
X! ;	SCCS Id: @(#)ovlmgr.asm 		91/02/01
X! ;  Copyright (c) 1989, 1990, 1991 Pierre Martineau and Stephen Spackman. All Rights Reserved.
X  ;  This product may be freely redistributed.  See NetHack license for details.
X  
X! VERSION 	EQU	30a0h
X  
X  		PAGE	57,132
X  		TITLE	'DOS Overlay Manager for MSC 5.1+'
X! 		SUBTTL	'Copyright (c) 1989, 1990, 1991 Pierre Martineau and Stephen Spackman. All Rights Reserved.'
X  
X+ ; Multiple overlay file support for v30a0 by Norm Meluch with some input from Stephen.
X+ 
X  ; acknowledgements:   - Many thanks to Norm Meluch for his invaluable help
X  ;		      - No thanks to Microsoft
X  ;		      - alltrsidsctysti!!!
X***************
X*** 20,25 ****
X--- 22,33 ----
X  ;		      - the stack is preserved
X  ;		      - re-entrancy is not required
X  
X+ ; options:	      /Di386	use 80386-specific opcodes
X+ ;				(faster, but no good for weaker machines)
X+ ;		      /DNOEMS	omit EMS support
X+ ;				(needed if application uses EMS)
X+ ;		      /DNOSPLIT	omit support for external .OVL files
X+ 
X  DOSALLOC	EQU	48h			; memory allocation
X  DOSFREE 	EQU	49h			; free allocated memory
X  DOSREALLOC	EQU	4ah			; modify memory block
X***************
X*** 27,32 ****
X--- 35,44 ----
X  DOSSEEK 	EQU	42h			; logical handle seek
X  DOSOPEN 	EQU	3dh			; open handle
X  DOSCLOSE	EQU	3eh			; close handle
X+ DOSSETDTA	EQU	1ah			; Set Data transfer area
X+ DOSGETDTA	EQU	2fh			; Get Data transfer area
X+ DOSSEARCH	EQU	4eh			; Search for 1st file match
X+ DOSNEXTFILE	EQU	4fh			; Search for next file match
X  DOSEXEC 	EQU	4bh			; exec child process
X  DOSPUTC 	EQU	02h			; print a char
X  DOSVERSION	EQU	30h			; get version number
X***************
X*** 41,46 ****
X--- 53,61 ----
X  EMMALLOC	EQU	43h			; allocate EMM pages
X  EMMMAP		EQU	44h			; map EMM pages
X  EMMFREE 	EQU	45h			; free EMM pages
X+ MAXNAMESIZE	EQU	50h			; max path name size
X+ MAXFILES	EQU	0Eh			; max # of *.OVL files
X+ EXESIGNUM	EQU	5a4dh			; Exe header signature
X  CR		EQU	0dh
X  LF		EQU	0ah
X  ESCAPE		EQU	1bh
X***************
X*** 57,62 ****
X--- 72,80 ----
X  RELERR		EQU	6
X  EMSERR		EQU	7
X  HDRERR		EQU	8
X+ NAMERR		EQU	9
X+ OVLERR		EQU	10
X+ NOHDRERR	EQU	11
X  
X  ; The following EXTRNs are supplied by the linker
X  
X***************
X*** 84,90 ****
X  		ENDM
X  ENDIF
X  
X! ovlflgrec	RECORD	locked:1=0,ems:1=0,loaded:1=0 ; overlay flags
X  
X  ; This is a dirty hack. What we need is a virtual segment that will be built
X  ; by the (our) loader in multiple copies, one per overlay. Unfortunately, this
X--- 102,110 ----
X  		ENDM
X  ENDIF
X  
X! ovlflgrec	RECORD	locked:1=0,ems:1=0,loaded:1=0,file:4=0,pad:1 ; overlay flags
X! 		; "file" is the overlay file this overlay is in; 0 is the .EXE
X! 		; itself. Otherwise, the numbers are arbitrary.
X  
X  ; This is a dirty hack. What we need is a virtual segment that will be built
X  ; by the (our) loader in multiple copies, one per overlay. Unfortunately, this
X***************
X*** 107,113 ****
X  
X  ; NOTE: This segment definition MUST be exactly 16 bytes long
X  
X! ovlflg		ovlflgrec	<0,0,0> 	; overlay flags
X  ovlinvcnt	DB	?			; invocation count
X  ovlmemblk	DW	?			; ^ to allocated memory block
X  ovllrudat	DD	?			; misc lru data (pseudo time stamp)
X--- 127,133 ----
X  
X  ; NOTE: This segment definition MUST be exactly 16 bytes long
X  
X! ovlflg		ovlflgrec	<0,0,0,0,0> 	; overlay flags
X  ovlinvcnt	DB	?			; invocation count
X  ovlmemblk	DW	?			; ^ to allocated memory block
X  ovllrudat	DD	?			; misc lru data (pseudo time stamp)
X***************
X*** 127,134 ****
X  
X  ovltbl		ENDS
X  
X  EXEHDR		STRUC				; structure of an EXE header
X! exesign 	DW	5a4dh			; signature
X  exelstpgesiz	DW	?			; last page size (512 byte pages)
X  exesiz		DW	?			; total pages (including partial last page)
X  relocitems	DW	?			; number of relocation entries
X--- 147,165 ----
X  
X  ovltbl		ENDS
X  
X+ DTASTRUC	STRUC				; internal DTA for ovlmgr
X+ 		DB	21 DUP (0)
X+ file_attr	DB	0
X+ file_time	DW	0
X+ file_date	DW	0
X+ file_size	DD	0
X+ file_name	DB	9 DUP (0)
X+ file_ext	DB	3 DUP (0)
X+ dtapad		DB	86 DUP (0)		; Pad to 128 bytes
X+ DTASTRUC	ENDS
X+ 
X  EXEHDR		STRUC				; structure of an EXE header
X! exesign 	DW	EXESIGNUM		; signature
X  exelstpgesiz	DW	?			; last page size (512 byte pages)
X  exesiz		DW	?			; total pages (including partial last page)
X  relocitems	DW	?			; number of relocation entries
X***************
X*** 176,182 ****
X  dsreg		DW	?			; temp save area
X  ssreg		DW	?
X  spreg		DW	?
X! ovlexefilhdl	DW	-1			; always-open file handle of our .EXE
X  ovltblbse	DW	-1			; segment of first overlay descriptor
X  memblks 	DW	16 DUP (-1)		; allocated memory blocks
X  memblk1st	DW	?			; first memory block
X--- 207,213 ----
X  dsreg		DW	?			; temp save area
X  ssreg		DW	?
X  spreg		DW	?
X! ovlfilhdl	DW	MAXFILES+1 DUP (-1)  	; always-open file handles for .EXE, .OVL
X  ovltblbse	DW	-1			; segment of first overlay descriptor
X  memblks 	DW	16 DUP (-1)		; allocated memory blocks
X  memblk1st	DW	?			; first memory block
X***************
X*** 196,217 ****
X  hdr		EXEHDR	<>			; EXE header work area
X  		DB	512-TYPE EXEHDR DUP (?) ; exe hdr buffer for relocations
X  EXEHDRTMPSIZ	EQU	$ - hdr 		; size of temp reloc buffer
X  errortbl	DW	-1			; error message pointers
X  		DW	OFFSET baddos
X  		DW	OFFSET nofile
X  		DW	OFFSET noroom
X! 		DW	OFFSET nofile
X  		DW	OFFSET nocore
X  		DW	OFFSET nocore
X  		DW	OFFSET badems
X! 		DW	OFFSET nofile
X  		DW	OFFSET unknown
X  		DW	OFFSET unknown
X  		DW	OFFSET unknown
X  		DW	OFFSET unknown
X- 		DW	OFFSET unknown
X- 		DW	OFFSET unknown
X- 		DW	OFFSET unknown
X  emmname 	DB	"EMMXXXX0"              ; EMM device driver name
X  emmtot		DW	0			; total emm blocks free
X  emmframesiz	DW	4			; frame size in blocks
X--- 227,254 ----
X  hdr		EXEHDR	<>			; EXE header work area
X  		DB	512-TYPE EXEHDR DUP (?) ; exe hdr buffer for relocations
X  EXEHDRTMPSIZ	EQU	$ - hdr 		; size of temp reloc buffer
X+ filestring	DB	MAXNAMESIZE DUP (0)	; string space for file specs
X+ pathlen		DW	?			; path length of file spec
X+ namelen		DW	?			; length of file names
X+ ovldta		DTASTRUC <>			; DTA for ovlmgr use
X+ dtaseg		DW	?			; DTA segment for program
X+ dtaoffset	DW	?			; DTA offset for program
X  errortbl	DW	-1			; error message pointers
X  		DW	OFFSET baddos
X  		DW	OFFSET nofile
X  		DW	OFFSET noroom
X! 		DW	OFFSET badio
X  		DW	OFFSET nocore
X  		DW	OFFSET nocore
X  		DW	OFFSET badems
X! 		DW	OFFSET badhdr
X! 		DW	OFFSET badnam
X! 		DW	OFFSET noovl
X! 		DW	OFFSET nohdr
X  		DW	OFFSET unknown
X  		DW	OFFSET unknown
X  		DW	OFFSET unknown
X  		DW	OFFSET unknown
X  emmname 	DB	"EMMXXXX0"              ; EMM device driver name
X  emmtot		DW	0			; total emm blocks free
X  emmframesiz	DW	4			; frame size in blocks
X***************
X*** 222,236 ****
X  paragraphs	DB	'H paragraphs.',CR,LF,'$'
X  emsavl		DB	'EMS memory available: $'
X  pages		DB	'H 16K-pages.',CR,LF,'$'
X  noroom		DB	'Not enough free memory left to run this program.$'
X  nocore		DB	'Internal memory allocation failure.$'
X- nofile		DB	'Inaccessible EXE file. Can',27,'t load overlays.$'
X- baddos		DB	'Incorrect DOS version. Must be 3.00 or later.$'
X  badems		DB	'EMS memory manager error.$'
X  unknown 	DB	'Unknown error!$'
X  msghead 	DB	ESCAPE,'[0m',ESCAPE,'[K',CR,LF,ESCAPE,'[K',ESCAPE,'[1mOVLMGR:',ESCAPE,'[0m $'
X  diag		DB	ESCAPE,'[K',CR,LF,ESCAPE,'[K','        ($'
X  msgtail 	DB	ESCAPE,'[K',CR,LF,ESCAPE,'[K',BELL,'$'
X  
X  ;-------------------------------------------------------------------------------
X  
X--- 259,279 ----
X  paragraphs	DB	'H paragraphs.',CR,LF,'$'
X  emsavl		DB	'EMS memory available: $'
X  pages		DB	'H 16K-pages.',CR,LF,'$'
X+ baddos		DB	'Incorrect DOS version. Must be 3.00 or later.$'
X+ nofile		DB	'Inaccessible EXE file. Can',39,'t load overlays.$'
X  noroom		DB	'Not enough free memory left to run this program.$'
X+ badio		DB	'File I/O error.$'
X  nocore		DB	'Internal memory allocation failure.$'
X  badems		DB	'EMS memory manager error.$'
X+ badhdr		DB	'Executable or overlay header missing or damaged.$'
X+ badnam		DB	'Unable to resolve overlay file names.$'
X+ noovl		DB	'Inaccessible OVL file. Can',39,'t load overlays.$'
X+ nohdr		DB	'Incomplete executable.  OVL files missing?$'
X  unknown 	DB	'Unknown error!$'
X  msghead 	DB	ESCAPE,'[0m',ESCAPE,'[K',CR,LF,ESCAPE,'[K',ESCAPE,'[1mOVLMGR:',ESCAPE,'[0m $'
X  diag		DB	ESCAPE,'[K',CR,LF,ESCAPE,'[K','        ($'
X  msgtail 	DB	ESCAPE,'[K',CR,LF,ESCAPE,'[K',BELL,'$'
X+ ovlext		DB	'?.OVL',0
X  
X  ;-------------------------------------------------------------------------------
X  
X***************
X*** 247,252 ****
X--- 290,296 ----
X  		push	bp
X  		push	ds
X  		push	es			; save the world
X+ 
X  		cld
X  		mov	ax,ds			; get our psp
X  		add	ax,10h
X***************
X*** 265,279 ****
X  		cmp	WORD PTR [si],0
X  		jnz	envloop
X  		add	si,4			; point to EXE filename
X! 		mov	al,0			; access code
X! 		mov	ah,DOSOPEN
X! 		mov	dx,si
X! 		int	DOS			; open EXE
X! 		jnc	dontdie
X! 		mov	al,FILEERR		; can't open file!
X! 		jmp	putserr
X! dontdie:
X! 		mov	ovlexefilhdl,ax 	; save handle
X  IFNDEF NOEMS
X  chkems:
X  		mov	ah,DOSGETVEC
X--- 309,316 ----
X  		cmp	WORD PTR [si],0
X  		jnz	envloop
X  		add	si,4			; point to EXE filename
X! 
X! 		call	openfiles		; Search & open overlay files
X  IFNDEF NOEMS
X  chkems:
X  		mov	ah,DOSGETVEC
X***************
X*** 316,323 ****
X  gotovlram:
X  		mov	ovltblbse,ax		; overlay descriptor table begins at start of memory block
X  
X! 		push	cs
X! 		pop	ds
X  IFDEF DEBUG
X  IFDEF i386
X  		mov	ah,print
X--- 353,375 ----
X  gotovlram:
X  		mov	ovltblbse,ax		; overlay descriptor table begins at start of memory block
X  
X! 		mov	cx,ovlcnt
X! zeromem:
X! 		mov	es,ax
X! 		mov	es:ovlflg,0		; initialise ovl flags
X! 		mov	es:ovlinvcnt,0		; initialise invocation count
X! 		mov	es:ovlmemblk,0
X! 		mov	WORD PTR es:ovllrudat,0	 ; initialise ovl lru
X! 		mov	WORD PTR es:ovllrudat+2,0
X! 		mov	es:ovlemshdl,-1
X! 		mov	es:ovlfiloff,0		; initialize file offset
X! 		mov	es:ovlsiz,0		; initialize overlay size
X! 		mov	es:ovlhdrsiz,0
X! 		inc	ax
X! 		loop	zeromem		
X! 
X! 		mov	ax,cs
X! 		mov	ds,ax
X  IFDEF DEBUG
X  IFDEF i386
X  		mov	ah,print
X***************
X*** 357,374 ****
X  
X  		xor	bp,bp
X  		xor	di,di
X! 		xor	si,si
X  filsegtbllpp:					; initialise ovl table
X  		call	gethdr			; get an EXE header
X  		mov	ax,ovltblbse
X  		add	ax,hdr.exeovlnum
X  		mov	es,ax			; ^ to ovl table entry
X! 		xor	ax,ax
X! 		mov	WORD PTR ovllrudat,ax	; initialise ovl lru
X! 		mov	WORD PTR ovllrudat+2,ax
X! 		mov	ovlflg,al		; initialise ovl flags
X! 		mov	ovlinvcnt,al		; initialise invocation count
X! 		mov	ovlemshdl,-1
X  		mov	ax,hdr.exesiz
X  		shl	ax,1
X  		shl	ax,1
X--- 409,426 ----
X  
X  		xor	bp,bp
X  		xor	di,di
X! 		xor	si,si			; file handle loop ctr
X  filsegtbllpp:					; initialise ovl table
X  		call	gethdr			; get an EXE header
X+ 
X  		mov	ax,ovltblbse
X  		add	ax,hdr.exeovlnum
X  		mov	es,ax			; ^ to ovl table entry
X! IFNDEF NOSPLIT
X! 		mov	cx,si			; set file # in ovlflg
X! 		shl	cx,1
X! 		mov	ovlflg,cl
X! ENDIF
X  		mov	ax,hdr.exesiz
X  		shl	ax,1
X  		shl	ax,1
X***************
X*** 412,423 ****
X  		mov	al,0
X  		mov	ah,DOSSEEK		; seek to next ovl
X  		int	DOS
X! 		mov	ax,ovlcnt
X  		dec	ax
X! 		cmp	ax,hdr.exeovlnum	; all overlays done?
X! 		jz	makmemblk
X! 		jmp	filsegtbllpp		; Nope, go for more.
X! makmemblk:
X  		ASSUME	ES:nothing		; prepare first memory block
X  
X  		mov	ax,ovlrootcode		; OVERLAY_AREA segment
X--- 464,490 ----
X  		mov	al,0
X  		mov	ah,DOSSEEK		; seek to next ovl
X  		int	DOS
X! 
X! 		mov	cx,ovlcnt		; check if all overlays found
X! 		mov	ax,ovltblbse
X! 		dec	cx			; ovlcnt includes root
X! 		add	ax,cx
X! ovloop:
X! 		mov	es,ax
X! IFNDEF NOSPLIT
X! 		mov	bl,ovlflg
X! 		and	bx,MASK file
X! 
X! 		cmp	bx,0			; if file # is 0
X! 		jne	again
X! ENDIF
X! 		cmp	ovlfiloff,0		; and offset is 0
X! 		jne	again
X! 		jmp	filsegtbllpp		; then we're still looking
X! again:
X  		dec	ax
X! 		loop	ovloop
X! 
X  		ASSUME	ES:nothing		; prepare first memory block
X  
X  		mov	ax,ovlrootcode		; OVERLAY_AREA segment
X***************
X*** 711,717 ****
X  		adc	cx,0			; position to code
X  		mov	ah,DOSSEEK		; lseek to code
X  		mov	al,0			; from beginning of file
X! 		mov	bx,ovlexefilhdl 	; never closing handle
X  		int	DOS
X  		jc	burnhead		; oops!
X  		xor	dx,dx			; buf = ds:0
X--- 778,786 ----
X  		adc	cx,0			; position to code
X  		mov	ah,DOSSEEK		; lseek to code
X  		mov	al,0			; from beginning of file
X! 		mov	bl,ovlflg
X! 		and	bx,MASK file
X! 		mov	bx,ovlfilhdl[bx] 	; never closing handle
X  		int	DOS
X  		jc	burnhead		; oops!
X  		xor	dx,dx			; buf = ds:0
X***************
X*** 727,733 ****
X  		pop	cx			; position of hdr
X  		mov	ah,DOSSEEK		; lseek to hdr
X  		mov	al,0			; from beginning of file
X! 		mov	bx,ovlexefilhdl 	; never closing handle
X  		int	DOS
X  		jc	burnhead		; oops!
X  		mov	cx,EXEHDRTMPSIZ 	; reloc buffer size
X--- 796,804 ----
X  		pop	cx			; position of hdr
X  		mov	ah,DOSSEEK		; lseek to hdr
X  		mov	al,0			; from beginning of file
X! 		mov	bl,ovlflg
X! 		and	bx,MASK file
X! 		mov	bx,ovlfilhdl[bx] 	; never closing handle
X  		int	DOS
X  		jc	burnhead		; oops!
X  		mov	cx,EXEHDRTMPSIZ 	; reloc buffer size
X***************
X*** 771,777 ****
X  
X  ovlrlc		PROC	NEAR			; ds:0 -> the overlay to relocate
X  
X! 		ASSUME	DS:NOTHING,ES:NOTHING
X  
X  		mov	si,OFFSET hdr
X  		mov	bp,si
X--- 842,848 ----
X  
X  ovlrlc		PROC	NEAR			; ds:0 -> the overlay to relocate
X  
X! 		ASSUME	DS:NOTHING,ES:ovltbl
X  
X  		mov	si,OFFSET hdr
X  		mov	bp,si
X***************
X*** 808,815 ****
X  		inc	si
X  		add	ax,pspadd		; now it is psp relative
X  		add	ax,di			; and now it is relative to the actual load address
X! 		mov	es,ax
X! 		mov	ax,es:[bx]		; pickup item to relocate
X  		add	ax,pspadd		; make it psp relative
X  		cmp	ax,ovlrootcode		; is it below the OVERLAY_AREA?
X  		jc	reloccomputed		; yup. it's relocated
X--- 879,886 ----
X  		inc	si
X  		add	ax,pspadd		; now it is psp relative
X  		add	ax,di			; and now it is relative to the actual load address
X! 		mov	ds,ax
X! 		mov	ax,[bx]			; pickup item to relocate
X  		add	ax,pspadd		; make it psp relative
X  		cmp	ax,ovlrootcode		; is it below the OVERLAY_AREA?
X  		jc	reloccomputed		; yup. it's relocated
X***************
X*** 817,823 ****
X  		jnc	reloccomputed		; yup. it's relocated
X  		add	ax,di			; it's in OVERLAY_AREA, this one's ours.
X  reloccomputed:
X! 		mov	es:[bx],ax		; RAM it home!?!
X  		loop	dorelocs		; what goes around, comes around.
X  relocdone:	ret
X  
X--- 888,894 ----
X  		jnc	reloccomputed		; yup. it's relocated
X  		add	ax,di			; it's in OVERLAY_AREA, this one's ours.
X  reloccomputed:
X! 		mov	[bx],ax			; RAM it home!?!
X  		loop	dorelocs		; what goes around, comes around.
X  relocdone:	ret
X  
X***************
X*** 827,833 ****
X  
X  getnxtreloc	PROC	NEAR
X  
X! 		ASSUME	DS:NOTHING,ES:NOTHING
X  
X  		push	bx
X  		push	cx
X--- 898,904 ----
X  
X  getnxtreloc	PROC	NEAR
X  
X! 		ASSUME	DS:NOTHING,ES:ovltbl
X  
X  		push	bx
X  		push	cx
X***************
X*** 839,845 ****
X  		mov	dx,OFFSET hdr
X  		mov	ax,cs
X  		mov	ds,ax
X! 		mov	bx,ovlexefilhdl 	; never closing handle
X  		mov	ah,DOSREAD		; prevent random DOS behaviour
X  		int	DOS			; read in header
X  		jnc	nxtrelocok
X--- 910,918 ----
X  		mov	dx,OFFSET hdr
X  		mov	ax,cs
X  		mov	ds,ax
X! 		mov	bl,ovlflg
X! 		and	bx,MASK file
X! 		mov	bx,ovlfilhdl[bx] 	; never closing handle
X  		mov	ah,DOSREAD		; prevent random DOS behaviour
X  		int	DOS			; read in header
X  		jnc	nxtrelocok
X***************
X*** 1122,1128 ****
X  		mov	ax,ds			; this is it!
X  		mov	cx,bx
X  		sub	cx,ax			; # of paragraphs between start of memory to release and mem blk
X! 		jz	nosplit
X  		push	es
X  		call	splitblk
X  		or	es:memblkflg,MASK_used	; set high block used
X--- 1195,1201 ----
X  		mov	ax,ds			; this is it!
X  		mov	cx,bx
X  		sub	cx,ax			; # of paragraphs between start of memory to release and mem blk
X! 		jz	unsplit
X  		push	es
X  		call	splitblk
X  		or	es:memblkflg,MASK_used	; set high block used
X***************
X*** 1130,1136 ****
X  		mov	ax,es
X  		mov	ds,ax
X  		pop	es
X! nosplit:
X  		mov	cx,es:ovlsiz
X  		add	cx,MEMCTLBLKSIZ 	; paragraphs needed to load ovl
X  		jmp	splitblklow		; split remaining block
X--- 1203,1209 ----
X  		mov	ax,es
X  		mov	ds,ax
X  		pop	es
X! unsplit:
X  		mov	cx,es:ovlsiz
X  		add	cx,MEMCTLBLKSIZ 	; paragraphs needed to load ovl
X  		jmp	splitblklow		; split remaining block
X***************
X*** 1620,1648 ****
X  
X  		ASSUME	DS:NOTHING,ES:NOTHING
X  
X- 		push	cx
X- 		push	ds
X- 		mov	ax,cs
X- 		mov	ds,ax
X  		mov	dx,OFFSET hdr		; a place to put it
X! 		mov	bx,ovlexefilhdl 	; the file handle
X  		mov	cx,TYPE EXEHDR		; header size in bytes
X  		mov	ah,DOSREAD
X  		int	DOS			; read from file
X! 		jc	exegone 		; oops
X  		cmp	ax,cx			; got correct number of bytes?
X! 		jnz	exegone 		; nope
X! 		pop	ds
X! 		pop	cx
X  		ret				; Wow, it worked!
X  exegone:
X! 		mov	al,HDRERR		; You lose!
X! 		jmp	putserr
X  
X  gethdr		ENDP
X  
X  ;-------------------------------------------------------------------------------
X  
X  putserr 	PROC	NEAR
X  
X  ; display error msg, close file, restore int vectors, free mem and return to DOS.
X--- 1693,1886 ----
X  
X  		ASSUME	DS:NOTHING,ES:NOTHING
X  
X  		mov	dx,OFFSET hdr		; a place to put it
X! 		mov	bx,si
X! 		shl	bx,1
X! 		mov	bx,ovlfilhdl[bx] 	; the file handle
X! readagain:
X  		mov	cx,TYPE EXEHDR		; header size in bytes
X  		mov	ah,DOSREAD
X  		int	DOS			; read from file
X! 		jc	exegone 		; oops?
X  		cmp	ax,cx			; got correct number of bytes?
X! 		je	gothdr
X! IFNDEF NOSPLIT
X! 		cmp	ax,0			; Anything?
X! 		je	gotonxtfil
X! ENDIF
X! 		jmp	exerotten
X! IFNDEF NOSPLIT
X! gotonxtfil:
X! 		inc	si
X! 		cmp	si,MAXFILES+1
X! 		je	exegone			; We're out of files!
X! 		mov	bx,si
X! 		shl	bx,1
X! 		cmp	ovlfilhdl[bx],-1	; Any more files?
X! 		je	gotonxtfil		; not here.
X! 
X! 		mov	bx,ovlfilhdl[bx]	; Slide in new handle
X! 		xor	bp,bp			; reset file offset
X! 		jmp	readagain
X! ENDIF
X! gothdr:
X! 		cmp	hdr.exesign,EXESIGNUM	; sanity check
X! 		jne	exerotten
X! 
X  		ret				; Wow, it worked!
X  exegone:
X! 		mov	al,NOHDRERR		; missing overlays!
X! 		jmp	putserr			; You lose!
X! IFNDEF NOSPLIT
X! exerotten:
X! 		mov	al,HDRERR		; corruption!
X! 		jmp	putserr			; You lose!
X! ENDIF
X  
X  gethdr		ENDP
X  
X  ;-------------------------------------------------------------------------------
X  
X+ openfiles	PROC	NEAR			; Find our cohorts in crime
X+ 
X+ 		push	es
X+ IFNDEF NOSPLIT
X+ 		mov	ah,DOSGETDTA		; Pick up DTA
X+ 		int	DOS			; and
X+ 		mov	dtaseg,es		; store
X+ 		mov	dtaoffset,bx		; it
X+ 
X+ 		push	ds
X+ 		mov	dx,OFFSET ovldta	; Set new DTA for file search
X+ 		mov	ax,cs
X+ 		mov	ds,ax			; point to the right seg
X+ 		mov	ah,DOSSETDTA
X+ 		int	DOS
X+ 		pop	ds			; set this back for upcoming lodsb
X+ ENDIF
X+ 		mov	cx,MAXNAMESIZE/2
X+ 		mov	bx,cs
X+ 		mov	es,bx
X+ 		mov	di, OFFSET filestring
X+ 
X+ 		rep     movsw	    		; load path from si to di
X+ IFNDEF NOSPLIT
X+ 		mov	di, OFFSET filestring
X+ 		mov	al,0
X+ 		mov	cx,MAXNAMESIZE
X+ 		cld
X+ 		repne	scasb			; search null for end of string
X+ 
X+ 		sub	cx,MAXNAMESIZE
X+ 		neg	cx
X+ 		mov	bx,cx
X+ 
X+ 		cmp	cx,MAXNAMESIZE
X+ 		je	searchslash
X+ 
X+ 		dec	bx			; keep string length
X+ 		dec	di			; cause were past null now
X+ 
X+ 		cmp	bx,7
X+ 		jle	patherr			; "C:\.EXE" = 7
X+ searchslash:
X+ 		mov	al,'\'
X+ 		std
X+ 		repne	scasb			; search back for '\'
X+ 		cld
X+ 
X+ 		mov	dx,bx
X+ 		sub	dx,cx			; keep file name length
X+ 		dec	dx
X+ 
X+ 		mov	cx,0			; reset for upcoming loop
X+ 		mov	pathlen,bx		; hold these for recall
X+ 		mov	namelen,dx
X+ 		cmp	dx,12			; "LONGNAME.EXE" = 12
X+ 		jle	openroot		; Path name too long?
X+ patherr:
X+ 		mov	al,NAMERR		; real problems here.
X+ 		jmp	putserr
X+ openroot:
X+ ENDIF
X+ 		mov	ax,cs
X+ 		mov	ds,ax			; set ds to code
X+ 
X+ 		mov	dx, OFFSET filestring	; open root code
X+ 		mov	al,0			; access code
X+ 		mov	ah,DOSOPEN
X+ 		int	DOS			; open sez me
X+ 		jnc	dontdie
X+ 
X+ 		mov	al,FILEERR		; can't open root
X+ 		jmp	putserr
X+ dontdie:
X+ 		mov	ovlfilhdl[0],ax		; save handle in array
X+ IFNDEF NOSPLIT
X+ 		cmp	namelen,11		; Max sized exe name (8.3)?
X+ 		jg	bigfilename		; if not
X+ 		inc	pathlen			; add one to path length
X+ 		inc	namelen
X+ bigfilename:
X+ 		mov	di,OFFSET filestring	; es is still code
X+ 		add	di,pathlen
X+ 		sub	di,5			; append
X+ 		mov	si,OFFSET ovlext	; wildcard extension
X+ 		mov	cx,6			; and null
X+ 		rep	movsb			; to filestring
X+ 
X+ 		mov	cx,0			; Match "normal" files
X+ 		mov	dx,OFFSET filestring
X+ 		mov	ah,DOSSEARCH
X+ 		int	DOS			; Set DTA with Wildcard.
X+ 		jc	aok			; Not a single match
X+ 		mov	cx,MAXFILES		; set upcoming loop
X+ 		mov	dx,namelen
X+ 		sub	pathlen,dx		; shorten absolute path
X+ openloop:
X+ 		push	cx
X+ 		mov	bx,pathlen
X+ 		mov	di,OFFSET filestring	; es is still in code
X+ 		add	di,bx
X+ 		mov	si,OFFSET ovldta.file_name
X+ 		mov	cx,namelen 		; since this *should* be
X+ 		rep	movsb
X+ 		pop	cx
X+ 
X+ 		mov	dx,OFFSET filestring	; path to overlay file
X+ 		mov	al,0			; access code
X+ 		mov	ah,DOSOPEN
X+ 		int	DOS			; open overlay file
X+ 		jnc	dontdie2
X+ fileopenerr:
X+ 		call	itoa
X+ 
X+ 		mov	al,OVLERR		; can't open file!
X+ 		jmp	putserr
X+ dontdie2:
X+ 		mov	bx,cx			; put file number in bx
X+ 		shl	bx,1			; 2 * bx for array index
X+ 		mov	ovlfilhdl[bx],ax	; save handle in array
X+ 
X+ 		mov	ah,DOSNEXTFILE		; Look for more files
X+ 		int	DOS
X+ 		jc	aok
X+ 
X+ 		loop	openloop		; open only 15 overlays
X+ aok:
X+ 		mov	dx,dtaoffset		; Time to unset DTA
X+ 		mov	ds,dtaseg
X+ 		mov	ah,DOSSETDTA
X+ 		int	DOS
X+ ENDIF
X+ 		pop	es
X+ 
X+ 		ret
X+ 
X+ openfiles	ENDP
X+ 
X+ ;-------------------------------------------------------------------------------
X+ 
X  putserr 	PROC	NEAR
X  
X  ; display error msg, close file, restore int vectors, free mem and return to DOS.
X***************
X*** 1739,1750 ****
X  		add	si,2
X  		loop	freeemsmemlp
X  closefile:
X! 		mov	bx,ovlexefilhdl 	; get file handle
X  		cmp	bx,-1			; was the file ever opened?
X  		jz	byebye			; nope
X  		mov	ah,DOSCLOSE		; close it
X  		int	DOS
X  byebye:
X  		pop	ax			; return code in al
X  		mov	ah,TERMINATE
X  		int	DOS			; terminate this process
X--- 1977,2000 ----
X  		add	si,2
X  		loop	freeemsmemlp
X  closefile:
X! IFNDEF NOSPLIT
X! 		mov	cx,MAXFILES+1
X! nextfile:
X! 		mov	bx,cx
X! 		dec	bx
X! 		shl	bx,1
X! 		mov	bx,ovlfilhdl[bx] 	; get file handle
X! ELSE
X! 		mov	bx,ovlfilhdl[0]
X! ENDIF
X  		cmp	bx,-1			; was the file ever opened?
X  		jz	byebye			; nope
X  		mov	ah,DOSCLOSE		; close it
X  		int	DOS
X  byebye:
X+ IFNDEF NOSPLIT
X+ 		loop	nextfile
X+ ENDIF
X  		pop	ax			; return code in al
X  		mov	ah,TERMINATE
X  		int	DOS			; terminate this process
X***************
X*** 1782,1787 ****
X--- 2032,2038 ----
X  
X  nibble		PROC	NEAR
X  
X+ 		push	ax
X  		and	al,0fh
X  		add	al,30h
X  		cmp	al,3ah
X***************
X*** 1788,1796 ****
X--- 2039,2050 ----
X  		jc	nibok
X  		add	al,7
X  nibok:
X+ 		push	dx
X  		mov	dl,al
X  		mov	ah,DOSPUTC
X  		int	DOS
X+ 		pop	dx
X+ 		pop	ax
X  		ret
X  
X  nibble		ENDP
X*** others/pcmain.c	Thu May 31 00:00:34 1990
X--- others/pcmain.c	Sat Jan  5 15:01:44 1991
X***************
X*** 107,123 ****
X  #endif
X  #ifdef MACOS
X  	AppFile	theFile;
X! 	short	message,numFiles;
X  	SFReply	reply;
X  
X  	initterm(24,80);
X  	ObscureCursor();
X  # ifdef SMALLDATA
X  	init_decl();
X  # endif
X  	/* user might have started up with a save file, so check */
X! 	CountAppFiles(&message,&numFiles);
X! 	if (!message && numFiles) {
X  		message = 1;
X  
X  		while(message <= numFiles) {
X--- 107,131 ----
X  #endif
X  #ifdef MACOS
X  	AppFile	theFile;
X! 	short	message,numFiles,wizBang = FALSE;
X  	SFReply	reply;
X  
X  	initterm(24,80);
X+ 	/* check to see if is a special "wiz bang" start */
X+ 	if (! strcmp(plname, "wizard")) wizBang = TRUE;
X+ 
X  	ObscureCursor();
X  # ifdef SMALLDATA
X  	init_decl();
X  # endif
X  	/* user might have started up with a save file, so check */
X! 	/* however, a "wiz bang" start takes precedence */
X! 	if (wizBang) {
X! 		Strcpy(SAVEF, plname);
X! 		numFiles = 0;
X! 	} else CountAppFiles(&message,&numFiles);
X! 
X! 	if (numFiles && !message) {
X  		message = 1;
X  
X  		while(message <= numFiles) {
X***************
X*** 392,398 ****
X  	/* initialize static monster strength array */
X  	init_monstr();
X  #ifdef MACOS
X! 	if (!numFiles) {
X  		askname();
X  		if(justscores){
X  			prscore(1,&classes);
X--- 400,408 ----
X  	/* initialize static monster strength array */
X  	init_monstr();
X  #ifdef MACOS
X! 	if (wizBang) wizard = TRUE;
X! 
X! 	if (!wizBang && !numFiles) {
X  		askname();
X  		if(justscores){
X  			prscore(1,&classes);
X***************
X*** 519,525 ****
X  	flags.moonphase = phase_of_the_moon();
X  	if(flags.moonphase == FULL_MOON) {
X  		You("are lucky!  Full moon tonight.");
X! 		if(!u.uluck) change_luck(1);
X  	} else if(flags.moonphase == NEW_MOON) {
X  		pline("Be careful!  New moon tonight.");
X  	}
X--- 529,535 ----
X  	flags.moonphase = phase_of_the_moon();
X  	if(flags.moonphase == FULL_MOON) {
X  		You("are lucky!  Full moon tonight.");
X! 		change_luck(1);
X  	} else if(flags.moonphase == NEW_MOON) {
X  		pline("Be careful!  New moon tonight.");
X  	}
X*** others/random.c	Mon Apr 23 21:56:28 1990
X--- others/random.c	Thu Jan 31 13:35:42 1991
X***************
X*** 26,40 ****
X   *	- ANSI function prototyping in extern.h - therefore include hack.h
X   *	instead of stdio.h and remove separate declaration of random() from
X   *	the beginning of function srandom
X   */
X  
X  #ifdef LIBC_SCCS
X  # ifndef lint
X  static char sccsid[] = "@(#)random.c	5.5 (Berkeley) 7/6/88";
X  # endif
X  #endif /* LIBC_SCCS and not lint */
X- 
X- #include "hack.h"
X  
X  /*
X   * random.c:
X--- 26,42 ----
X   *	- ANSI function prototyping in extern.h - therefore include hack.h
X   *	instead of stdio.h and remove separate declaration of random() from
X   *	the beginning of function srandom
X+  *	- moving sccsid after hack.h to allow precompiled headers, which
X+  *	means the defined()s would be ok again...
X   */
X  
X+ #include "hack.h"
X+ 
X  #ifdef LIBC_SCCS
X  # ifndef lint
X  static char sccsid[] = "@(#)random.c	5.5 (Berkeley) 7/6/88";
X  # endif
X  #endif /* LIBC_SCCS and not lint */
X  
X  /*
X   * random.c:
X*** others/termcap	Sun May 20 20:02:42 1990
X--- others/termcap	Sat Jan  5 14:59:05 1991
X***************
X*** 91,97 ****
X  	:so=2\E[7m:se=2\E[m:us=2\E[4m:ue=2\E[m:\
X  	:mb=2\E[5m:md=2\E[1m:mr=2\E[7m:me=2\E[m:\
X  	:ti=4\E<\E(B\E)0:as=^N:ae=^O:\
X! 	:ks=\E[?1h\E=:ke=\E[?11\E>:ku=\E[A:kd=\E[B:kl=\E[C:kr=\E[D:kb=^H:\
X  	:kn#4:k1=\EOP:k2=\EOQ:k3=\EOR:k4=\EOS:\
X  	:sc=\E7:ec=\E8:sr=5\EM:
X  #
X--- 91,97 ----
X  	:so=2\E[7m:se=2\E[m:us=2\E[4m:ue=2\E[m:\
X  	:mb=2\E[5m:md=2\E[1m:mr=2\E[7m:me=2\E[m:\
X  	:ti=4\E<\E(B\E)0:as=^N:ae=^O:\
X! 	:ks=\E[?1h\E=:ke=\E[?1l\E>:ku=\E[A:kd=\E[B:kl=\E[C:kr=\E[D:kb=^H:\
X  	:kn#4:k1=\EOP:k2=\EOQ:k3=\EOR:k4=\EOS:\
X  	:sc=\E7:ec=\E8:sr=5\EM:
X  #
X***************
X*** 104,109 ****
X--- 104,111 ----
X  	:ic=5\E[@:tc=vt102:
X  vt300|vt300-80|vt320|vt330|vt340|VT300_Series:\
X  	:tc=vt200:
X+ vt400|vt400-80|vt420|VT400_Series:\
X+ 	:tc=vt300:
X  # VAXstations (should have full entries with no delays and 8-bit CSI's)
X  VWS|UIS:tc=vt200:
X  DECterm:tc=vt300:
X
END_OF_FILE
if test 50321 -ne `wc -c <'patch10.04'`; then
    echo shar: \"'patch10.04'\" unpacked with wrong size!
fi
# end of 'patch10.04'
echo shar: End of archive 4 \(of 8\).
cp /dev/null ark4isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 8 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
