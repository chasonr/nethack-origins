Path: utzoo!utgpu!watserv1!watmath!att!linac!pacific.mps.ohio-state.edu!zaphod.mps.ohio-state.edu!swrinde!elroy.jpl.nasa.gov!decwrl!ogicse!zephyr.ens.tek.com!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v12i027:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Patch10c
Message-ID: <6985@tekred.CNA.TEK.COM>
Date: 9 Feb 91 01:37:46 GMT
Sender: news@tekred.CNA.TEK.COM
Lines: 1562
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 12, Issue 27
Archive-name: NetHack3/Patch10c
Patch-To: NetHack3: Volume 7, Issue 56-93
Environment: 



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 3 (of 8)."
# Contents:  UPDATE10 patch10.05
# Wrapped by billr@saab on Fri Feb  8 17:18:58 1991
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'UPDATE10' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'UPDATE10'\" to \"'UPDATE10.orig'\"
  mv -f 'UPDATE10' 'UPDATE10.orig'
fi
echo shar: Extracting \"'UPDATE10'\" \(1068 characters\)
sed "s/^X//" >'UPDATE10' <<'END_OF_FILE'
XUPDATE10
X
XPatch 10 to NetHack 3.0 adds no new features, and few optimizations.
XIt fixes many mostly rare bugs and extends support to a couple more
Xsystem variants.
X
XThe major change with this patch is that the MSDOS overlay manager is
Xnow bright enough to split up one logical executable among several disk
Xfiles, thus simplifying distribution via floppies since each file can
Xbe <360K.  Entering debugging mode for the Macintosh is simplified.
XThere are provisions for later versions of several compilers, although
Xnot yet Turbo C++, as we have not gotten an executable with adequate
Xperformance (see Install.ovl for gory details).
X
XNetHack should now get along better with Irises, IBM RS/6000s, NeXTs,
Xand possibly even SCO UNIX.
X
XAmong the dead bugs are those involving artifact damage, VMS file
Xmanipulation, crushed iron balls, elven equipment, orcs with 2^32-1
Xdaggers, trolls with ridiculously high hitpoints, exploding bags of
Xholding on the ground, inappropriate messages, saved luck, unbounded
Xdigging on special levels, and several distinct trap problems.
X
END_OF_FILE
if test 1068 -ne `wc -c <'UPDATE10'`; then
    echo shar: \"'UPDATE10'\" unpacked with wrong size!
fi
# end of 'UPDATE10'
if test -f 'patch10.05' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'patch10.05'\" to \"'patch10.05.orig'\"
  mv -f 'patch10.05' 'patch10.05.orig'
fi
echo shar: Extracting \"'patch10.05'\" \(50416 characters\)
sed "s/^X//" >'patch10.05' <<'END_OF_FILE'
X*** auxil/Guidebook.mn	Tue Jun 26 21:19:58 1990
X--- auxil/Guidebook.mn	Sun Feb  3 12:33:05 1991
X***************
X*** 1221,1243 ****
X  .TS S
X  center;
X  c c c.
X! Richard Addison	Bruce Holloway	Pat Rankin
X! Tom Almy	Richard P. Hughey	Eric S. Raymond
X! Ken Arromdee	Ari Huttunen	John Rupley
X! Eric Backus	Del Lamb	Olaf Seibert
X! John S. Bien	Greg Laskin	Kevin Sitze
X! Ralf Brown	Johnny Lee	Eric R. Smith
X! Jean-Christophe Collet	Steve Linhart	Kevin Smolkowski
X! Steve Creps	Ken Lorber	Michael Sokolov
X! Kevin Darcy	Benson I. Margulies	Stephen Spackman
X! Matthew Day	Pierre Martineau	Andy Swanson
X! Joshua Delahunty	Roland McGrath	Kevin Sweet
X! Jochen Erwied	Norm Meluch	Scott R. Turner
X! David Gentzel	Bruce Mewborne	Janet Walz
X! Mark Gooderum	Izchak Miller	Jon Watte
X! David Hairston	Gil Neiger	Tom West
X! Timo Hakulinen	Greg Olson	Gregg Wonderly
X! Eric Hendrickson	Mike Passaretti
X  .TE
X  .ed
X  
X--- 1221,1243 ----
X  .TS S
X  center;
X  c c c.
X! Richard Addison	Bruce Holloway	Mike Passaretti
X! Tom Almy	Richard P. Hughey	Pat Rankin
X! Ken Arromdee	Ari Huttunen	Eric S. Raymond
X! Eric Backus	Del Lamb	John Rupley
X! John S. Bien	Greg Laskin	Olaf Seibert
X! Ralf Brown	Johnny Lee	Kevin Sitze
X! Jean-Christophe Collet	Merlyn LeRoy	Eric R. Smith
X! Steve Creps	Steve Linhart	Kevin Smolkowski
X! Kevin Darcy	Ken Lorber	Michael Sokolov
X! Matthew Day	Benson I. Margulies	Stephen Spackman
X! Joshua Delahunty	Pierre Martineau	Andy Swanson
X! Jochen Erwied	Roland McGrath	Kevin Sweet
X! David Gentzel	Norm Meluch	Scott R. Turner
X! Mark Gooderum	Bruce Mewborne	Janet Walz
X! David Hairston	Izchak Miller	Jon Watte
X! Timo Hakulinen	Gil Neiger	Tom West
X! Eric Hendrickson	Greg Olson	Gregg Wonderly
X  .TE
X  .ed
X  
X*** auxil/Guidebook.mss	Tue Jun 26 21:20:00 1990
X--- auxil/Guidebook.mss	Sun Feb  3 12:33:11 1991
X***************
X*** 1183,1205 ****
X  particularly  intriguing modification to help out with the game.  The Gods of
X  the Dungeon sometimes make note of the names of the worst of these miscreants
X  in this, the list of Dungeoneers:
X! Richard Addison           Bruce Holloway            Pat Rankin
X! Tom Almy                  Richard P. Hughey         Eric S. Raymond
X! Ken Arromdee              Ari Huttunen              John Rupley
X! Eric Backus               Del Lamb                  Olaf Seibert
X! John S. Bien              Greg Laskin               Kevin Sitze
X! Ralf Brown                Johnny Lee                Eric R. Smith
X! Jean-Christophe Collet    Steve Linhart             Kevin Smolkowski
X! Steve Creps               Ken Lorber                Michael Sokolov
X! Kevin Darcy               Benson I. Margulies       Stephen Spackman
X! Matthew Day               Pierre Martineau          Andy Swanson
X! Joshua Delahunty          Roland McGrath            Kevin Sweet
X! Jochen Erwied             Norm Meluch               Scott R. Turner
X! David Gentzel             Bruce Mewborne            Janet Walz
X! Mark Gooderum             Izchak Miller             Jon Watte
X! David Hairston            Gil Neiger                Tom West
X! Timo Hakulinen            Greg Olson                Gregg Wonderly
X! Eric Hendrickson          Mike Passaretti
X  
X      Brand  and product names are trademarks or registered trademarks of their
X  respective holders.
X--- 1183,1205 ----
X  particularly  intriguing modification to help out with the game.  The Gods of
X  the Dungeon sometimes make note of the names of the worst of these miscreants
X  in this, the list of Dungeoneers:
X! Richard Addison           Bruce Holloway         Mike Passaretti
X! Tom Almy                  Richard P. Hughey      Pat Rankin
X! Ken Arromdee              Ari Huttunen           Eric S. Raymond
X! Eric Backus               Del Lamb               John Rupley
X! John S. Bien              Greg Laskin            Olaf Seibert
X! Ralf Brown                Johnny Lee             Kevin Sitze
X! Jean-Christophe Collet    Merlyn LeRoy           Eric R. Smith
X! Steve Creps               Steve Linhart          Kevin Smolkowski
X! Kevin Darcy               Ken Lorber             Michael Sokolov
X! Matthew Day               Benson I. Margulies    Stephen Spackman
X! Joshua Delahunty          Pierre Martineau       Andy Swanson
X! Jochen Erwied             Roland McGrath         Kevin Sweet
X! David Gentzel             Norm Meluch            Scott R. Turner
X! Mark Gooderum             Bruce Mewborne         Janet Walz
X! David Hairston            Izchak Miller          Jon Watte
X! Timo Hakulinen            Gil Neiger             Tom West
X! Eric Hendrickson          Greg Olson             Gregg Wonderly
X  
X      Brand  and product names are trademarks or registered trademarks of their
X  respective holders.
X*** auxil/Guidebook.tex	Tue Jun 26 21:20:02 1990
X--- auxil/Guidebook.tex	Sun Feb  3 12:32:57 1991
X***************
X*** 459,466 ****
X  %.lp
X  \item[\tb{/}]
X  Tell what a symbol represents.  You may choose to specify a location
X- or type a symbol to define.
X- Tell what a symbol represents.  You may choose to specify a location
X  or type a symbol (or even a whole word) to define.  If the
X  %.op
X  {\it help\/}
X--- 459,464 ----
X***************
X*** 1346,1352 ****
X  %.lp
X  \item[\ib{graphics}]
X  Set the graphics symbols for screen displays (default
X! ``\verb&|--------|||-\/.-|+.#<>& \verb&^"}{#\_<>##&''). The
X  %.op
X  {\it graphics\/}
X  option (if used) should come last, followed by a string of up to 35
X--- 1344,1350 ----
X  %.lp
X  \item[\ib{graphics}]
X  Set the graphics symbols for screen displays (default
X! ``\verb&|--------|||-\\/.-|+.#<>& \verb&^"}{#\\_<>##&''). The
X  %.op
X  {\it graphics\/}
X  option (if used) should come last, followed by a string of up to 35
X***************
X*** 1356,1365 ****
X  
X  The
X  %.op
X! {\it DECgraphics}
X  and
X  %.op
X! {\it IBMgraphics}
X  options use predefined selections of graphics symbols, so you need not
X  go to the trouble of setting up a full graphics string for these common
X  cases.  These two options also set up proper handling of graphics
X--- 1354,1363 ----
X  
X  The
X  %.op
X! {\it DECgraphics\/}
X  and
X  %.op
X! {\it IBMgraphics\/}
X  options use predefined selections of graphics symbols, so you need not
X  go to the trouble of setting up a full graphics string for these common
X  cases.  These two options also set up proper handling of graphics
X***************
X*** 1604,1626 ****
X  %.sd
X  \begin{center}
X  \begin{tabular}{lll}
X! Richard Addison         & Bruce Holloway        & Pat Rankin      \\
X! Tom Almy                & Richard P. Hughey     & Eric S. Raymond \\
X! Ken Arromdee            & Ari Huttunen          & John Rupley     \\
X! Eric Backus             & Del Lamb              & Olaf Seibert    \\
X! John S. Bien            & Greg Laskin           & Kevin Sitze     \\
X! Ralf Brown              & Johnny Lee            & Eric R. Smith   \\
X! Jean-Christophe Collet  & Steve Linhart         & Kevin Smolkowski\\
X! Steve Creps             & Ken Lorber            & Michael Sokolov \\
X! Kevin Darcy             & Benson I. Margulies   & Stephen Spackman\\
X! Matthew Day             & Pierre Martineau      & Andy Swanson    \\
X! Joshua Delahunty        & Roland McGrath        & Kevin Sweet     \\
X! Jochen Erwied           & Norm Meluch           & Scott R. Turner \\
X! David Gentzel           & Bruce Mewborne        & Janet Walz      \\
X! Mark Gooderum           & Izchak Miller         & Jon W\"atte     \\
X! David Hairston          & Gil Neiger            & Tom West        \\
X! Timo Hakulinen          & Greg Olson            & Gregg Wonderly  \\
X! Eric Hendrickson        & Mike Passaretti       &
X  \end{tabular}
X  \end{center}
X  %.ed
X--- 1602,1624 ----
X  %.sd
X  \begin{center}
X  \begin{tabular}{lll}
X! Richard Addison         & Bruce Holloway        & Mike Passaretti \\
X! Tom Almy                & Richard P. Hughey     & Pat Rankin      \\
X! Ken Arromdee            & Ari Huttunen          & Eric S. Raymond \\
X! Eric Backus             & Del Lamb              & John Rupley     \\
X! John S. Bien            & Greg Laskin           & Olaf Seibert    \\
X! Ralf Brown              & Johnny Lee            & Kevin Sitze     \\
X! Jean-Christophe Collet  & Merlyn LeRoy          & Eric R. Smith   \\
X! Steve Creps             & Steve Linhart         & Kevin Smolkowski\\
X! Kevin Darcy             & Ken Lorber            & Michael Sokolov \\
X! Matthew Day             & Benson I. Margulies   & Stephen Spackman\\
X! Joshua Delahunty        & Pierre Martineau      & Andy Swanson    \\
X! Jochen Erwied           & Roland McGrath        & Kevin Sweet     \\
X! David Gentzel           & Norm Meluch           & Scott R. Turner \\
X! Mark Gooderum           & Bruce Mewborne        & Janet Walz      \\
X! David Hairston          & Izchak Miller         & Jon W\"atte     \\
X! Timo Hakulinen          & Gil Neiger            & Tom West        \\
X! Eric Hendrickson        & Greg Olson            & Gregg Wonderly
X  \end{tabular}
X  \end{center}
X  %.ed
X*** auxil/history	Sat May 26 19:29:48 1990
X--- auxil/history	Thu Jan 31 16:05:34 1991
X***************
X*** 43,62 ****
X  the Dungeon sometimes make note of the names of the worst of these miscreants
X  in this, the list of Dungeoneers:
X  
X!     Richard Addison           Bruce Holloway         Pat Rankin
X!     Tom Almy                  Richard P. Hughey      Eric S. Raymond
X!     Ken Arromdee              Ari Huttunen           John Rupley
X!     Eric Backus               Del Lamb               Olaf Seibert
X!     John S. Bien              Greg Laskin            Kevin Sitze
X!     Ralf Brown                Johnny Lee             Eric R. Smith
X!     Jean-Christophe Collet    Steve Linhart          Kevin Smolkowski
X!     Steve Creps               Ken Lorber             Michael Sokolov
X!     Kevin Darcy               Benson I. Margulies    Stephen Spackman
X!     Matthew Day               Pierre Martineau       Andy Swanson
X!     Joshua Delahunty          Roland McGrath         Kevin Sweet
X!     Jochen Erwied             Norm Meluch            Scott R. Turner
X!     David Gentzel             Bruce Mewborne         Janet Walz
X!     Mark Gooderum             Izchak Miller          Jon Watte
X!     David Hairston            Gil Neiger             Tom West
X!     Timo Hakulinen            Greg Olson             Gregg Wonderly
X!     Eric Hendrickson          Mike Passaretti
X--- 43,62 ----
X  the Dungeon sometimes make note of the names of the worst of these miscreants
X  in this, the list of Dungeoneers:
X  
X!     Richard Addison           Bruce Holloway         Mike Passaretti
X!     Tom Almy                  Richard P. Hughey      Pat Rankin
X!     Ken Arromdee              Ari Huttunen           Eric S. Raymond
X!     Eric Backus               Del Lamb               John Rupley
X!     John S. Bien              Greg Laskin            Olaf Seibert
X!     Ralf Brown                Johnny Lee             Kevin Sitze
X!     Jean-Christophe Collet    Merlyn LeRoy           Eric R. Smith
X!     Steve Creps               Steve Linhart          Kevin Smolkowski
X!     Kevin Darcy               Ken Lorber             Michael Sokolov
X!     Matthew Day               Benson I. Margulies    Stephen Spackman
X!     Joshua Delahunty          Pierre Martineau       Andy Swanson
X!     Jochen Erwied             Roland McGrath         Kevin Sweet
X!     David Gentzel             Norm Meluch            Scott R. Turner
X!     Mark Gooderum             Bruce Mewborne         Janet Walz
X!     David Hairston            Izchak Miller          Jon Watte
X!     Timo Hakulinen            Gil Neiger             Tom West
X!     Eric Hendrickson          Greg Olson             Gregg Wonderly
X*** include/extern.h	Tue Jun 26 21:20:05 1990
X--- include/extern.h	Wed Jan 30 08:48:46 1991
X***************
X*** 1235,1240 ****
X--- 1235,1241 ----
X  /* ### termcap.c ### */
X  
X  E void NDECL(startup);
X+ E void FDECL(number_pad, (int));
X  E void NDECL(start_screen);
X  E void NDECL(end_screen);
X  #ifdef CLIPPING
X***************
X*** 1307,1313 ****
X  
X  E boolean FDECL(rust_dmg, (struct obj *,const char *,int,BOOLEAN_P));
X  E struct trap *FDECL(maketrap, (int,int,int));
X- E int FDECL(teleok, (int,int));
X  E void FDECL(fall_through, (BOOLEAN_P));
X  E void FDECL(dotrap, (struct trap *));
X  E int FDECL(mintrap, (struct monst *));
X--- 1308,1313 ----
X***************
X*** 1378,1384 ****
X  E int NDECL(phase_of_the_moon);
X  E int NDECL(night);
X  E int NDECL(midnight);
X! E void FDECL(gethdate, (char *));
X  E int FDECL(uptodate, (int));
X  E void NDECL(getlock);
X  E void FDECL(regularize, (char *));
X--- 1378,1384 ----
X  E int NDECL(phase_of_the_moon);
X  E int NDECL(night);
X  E int NDECL(midnight);
X! E void FDECL(gethdate, (const char *));
X  E int FDECL(uptodate, (int));
X  E void NDECL(getlock);
X  E void FDECL(regularize, (char *));
X***************
X*** 1445,1450 ****
X--- 1445,1451 ----
X  E void FDECL(regularize, (char *));
X  E int FDECL(vms_creat, (char *,unsigned int));
X  E int NDECL(vms_getuid);
X+ E const char *NDECL(verify_termcap);
X  E void NDECL(privoff);
X  E void NDECL(privon);
X  # ifdef SHELL
X*** include/global.h	Thu May 17 23:20:32 1990
X--- include/global.h	Tue Feb  5 08:41:45 1991
X***************
X*** 9,15 ****
X  
X  
X  /* #define BETA		/* if a beta-test copy  [MRS] */
X! #define VERSION "3.0i"  /* version number. */
X  
X  /*
X   * Files expected to exist in the playground directory.
X--- 9,15 ----
X  
X  
X  /* #define BETA		/* if a beta-test copy  [MRS] */
X! #define VERSION "3.0j"  /* version number. */
X  
X  /*
X   * Files expected to exist in the playground directory.
X*** include/obj.h	Sat Mar 31 10:39:26 1990
X--- include/obj.h	Tue Jan 29 16:57:57 1991
X***************
X*** 5,10 ****
X--- 5,13 ----
X  #ifndef OBJ_H
X  #define OBJ_H
X  
X+ /* #define obj obj_nh	/* uncomment for SCO UNIX, which has a conflicting
X+ 			 * typedef for "obj" in <sys/types.h> */
X+ 
X  struct obj {
X  	struct obj *nobj;
X  	struct obj *nexthere;		/* for location lists */
X*** include/patchlevel.h	Tue Jun 26 21:20:06 1990
X--- include/patchlevel.h	Mon Feb  4 16:43:42 1991
X***************
X*** 104,107 ****
X   *  and fix a couple more bugs
X   */
X  
X! #define PATCHLEVEL	9
X--- 104,114 ----
X   *  and fix a couple more bugs
X   */
X  
X! /*
X!  *  Patch 10, February 5, 1991
X!  *  extend overlay manager to multiple files for easier binary distribution
X!  *  allow for more system and compiler variance
X!  *  remove more small insects
X!  */
X! 
X! #define PATCHLEVEL	10
X*** include/system.h	Tue Jun 26 21:20:06 1990
X--- include/system.h	Sat Feb  2 16:46:26 1991
X***************
X*** 200,206 ****
X  #  ifdef THINKC4
X  E size_t	FDECL(strlen, (char *));
X  #  else
X! E int	FDECL(strlen, (char *));
X  #  endif /* THINKC4 */
X  # endif /* HPUX */
X  #endif /* MSDOS */
X--- 200,206 ----
X  #  ifdef THINKC4
X  E size_t	FDECL(strlen, (char *));
X  #  else
X! E int	FDECL(strlen, (const char *));
X  #  endif /* THINKC4 */
X  # endif /* HPUX */
X  #endif /* MSDOS */
X***************
X*** 262,276 ****
X  E char *FDECL(tgoto, (const char *,int,int));
X  E void FDECL(tputs, (const char *,int,int (*)()));
X  #else
X! E int FDECL(tgetent, (char *,char *));
X  E int FDECL(tgetnum, (char *));
X  E int FDECL(tgetflag, (char *));
X  E char *FDECL(tgetstr, (char *,char **));
X  E char *FDECL(tgoto, (char *,int,int));
X! E void FDECL(tputs, (char *,int,int (*)()));
X  #endif
X  
X! #ifndef MACOS
X  E genericptr_t FDECL(malloc, (size_t));
X  #endif
X  
X--- 262,276 ----
X  E char *FDECL(tgoto, (const char *,int,int));
X  E void FDECL(tputs, (const char *,int,int (*)()));
X  #else
X! E int FDECL(tgetent, (char *,const char *));
X  E int FDECL(tgetnum, (char *));
X  E int FDECL(tgetflag, (char *));
X  E char *FDECL(tgetstr, (char *,char **));
X  E char *FDECL(tgoto, (char *,int,int));
X! E void FDECL(tputs, (const char *,int,int (*)()));
X  #endif
X  
X! #if defined(ALLOC_C) && !defined(MACOS)
X  E genericptr_t FDECL(malloc, (size_t));
X  #endif
X  
X*** include/unixconf.h	Sun Apr  8 23:47:45 1990
X--- include/unixconf.h	Sat Feb  2 16:52:38 1991
X***************
X*** 37,42 ****
X--- 37,44 ----
X  /* #define UNIXPC	/* use in addition to SYSV for AT&T 7300/3B1 */
X  			/* also note that the stock cpp qualifies as a
X  			   STUPID_CPP for config.h */
X+ /* #define AIX_31	/* In AIX 3.1 (IBM RS/6000) use BSD ioctl's to gain
X+ 			   job control (note that AIX is SYSV otherwise) */
X  
X  /* #define PYRAMID_BUG 	/* avoid a bug on the Pyramid */
X  /* #define APOLLO	/* same for the Apollo */
X***************
X*** 148,157 ****
X  /*
X   * BSD/ULTRIX systems are normally the only ones that can suspend processes.
X   * Suspending NetHack processes cleanly should be easy to add to other systems
X!  * that have SIGTSTP.  Currently the only such system known to work is HPUX;
X!  * other systems will probably require tweaks to unixtty.c and ioctl.c.
X   */
X! #if defined(BSD) || defined(ULTRIX) || defined (HPUX)
X  #define	SUSPEND		/* let ^Z suspend the game */
X  #endif
X  
X--- 150,160 ----
X  /*
X   * BSD/ULTRIX systems are normally the only ones that can suspend processes.
X   * Suspending NetHack processes cleanly should be easy to add to other systems
X!  * that have SIGTSTP.  Currently the only such systems known to work are HPUX
X!  * and AIX 3.1; other systems will probably require tweaks to unixtty.c and
X!  * ioctl.c.
X   */
X! #if defined(BSD) || defined(ULTRIX) || defined (HPUX) || defined(AIX_31)
X  #define	SUSPEND		/* let ^Z suspend the game */
X  #endif
X  
X*** include/vmsconf.h	Thu May 17 23:20:33 1990
X--- include/vmsconf.h	Sat Feb  2 16:52:37 1991
X***************
X*** 42,66 ****
X  # define WIZARD_NAME Local_WIZARD
X  #endif
X  
X  #undef RECORD
X! #define RECORD "record;1"
X  
X  #ifdef COMPRESS
X  # undef COMPRESS
X  #endif
X! #ifdef ZEROCOMP
X! # undef ZEROCOMP
X  #endif
X  
X  /*
X   * If you define MAIL, then the player will be notified of new broadcasts
X   * when they arrive.
X   */
X! #define	MAIL
X  
X! #define RANDOM          /* use others/random.c instead of vaxcrtl rand/srand */
X  
X! #define	FCMASK	0660	/* file creation mask */
X  
X  /* vaxcrtl object library is not available on MicroVMS (4.4 thru 4.6(.7?))
X     unless it's retreived from a full VMS system or leftover from a really
X--- 42,81 ----
X  # define WIZARD_NAME Local_WIZARD
X  #endif
X  
X+ /* filenames require punctuation to avoid redirection via logical names */
X  #undef RECORD
X! #define RECORD	"record;1"	/* scoreboard file (retains high scores) */
X! #undef LOGFILE
X! #define LOGFILE	"logfile;0"	/* optional file (records all games) */
X  
X+ #define HLOCK	"perm;1"	/* an empty file used for locking purposes */
X+ #define LLOCK	"perm.lock;1"	/* temporary link to previous */
X+ 
X+ /* want compression--for level & save files--performed within NetHack itself */
X  #ifdef COMPRESS
X  # undef COMPRESS
X  #endif
X! #ifndef ZEROCOMP
X! # define ZEROCOMP
X  #endif
X  
X  /*
X+  * If nethack.exe will be installed with privilege so that the playground
X+  * won't need to be left unprotected, define SECURE to suppress a couple
X+  * of file protection fixups (protection of bones files and ownership of
X+  * save files).
X+  */
X+ /* #define SECURE /**/
X+ 
X+ /*
X   * If you define MAIL, then the player will be notified of new broadcasts
X   * when they arrive.
X   */
X! #define MAIL
X  
X! #define RANDOM		/* use others/random.c instead of vaxcrtl rand/srand */
X  
X! #define FCMASK	0660	/* file creation mask */
X  
X  /* vaxcrtl object library is not available on MicroVMS (4.4 thru 4.6(.7?))
X     unless it's retreived from a full VMS system or leftover from a really
X***************
X*** 95,104 ****
X  #endif
X  
X  #include <time.h>
X  #include <file.h>
X! 
X! #define	HLOCK	"perm;1"	/* an empty file used for locking purposes */
X! #define LLOCK	"safelock;1"	/* link to previous */
X  
X  #ifndef REDO
X  # define Getchar vms_getchar
X--- 110,123 ----
X  #endif
X  
X  #include <time.h>
X+ #ifndef __GNUC__
X  #include <file.h>
X! #else	/* values needed from missing include file */
X! # define O_RDONLY 0
X! # define O_WRONLY 1
X! # define O_RDWR   2
X! # define O_CREAT 0x200
X! #endif /* __GNUC__ */
X  
X  #ifndef REDO
X  # define Getchar vms_getchar
X*** mac/mac.c	Tue Jun 26 21:20:08 1990
X--- mac/mac.c	Sat Jan  5 14:58:53 1991
X***************
X*** 81,91 ****
X  		if (! flags.wantspace) SetCursor(&ARROW_CURSOR);
X  	}
X  	/* initialize cursor blinking */
X! 	message = TickCount();
X  	cursRectInv = FALSE;
X  	while (!ch) {
X  		(void)WaitNextEvent(everyEvent, &theEvent, (fInFront) ? 0L : 50L, 0L);
X! 		if (theEvent.what == keyDown || theEvent.what == autoKey) {
X  			ch = 0;
X  			ObscureCursor();
X  			/* use raw key codes */
X--- 81,91 ----
X  		if (! flags.wantspace) SetCursor(&ARROW_CURSOR);
X  	}
X  	/* initialize cursor blinking */
X! 	message = TickCount() + ((Invisible || (macflags & fMoveWRTMouse)) ? 0L : cursorTime);
X  	cursRectInv = FALSE;
X  	while (!ch) {
X  		(void)WaitNextEvent(everyEvent, &theEvent, (fInFront) ? 0L : 50L, 0L);
X! 		if ((theEvent.what == keyDown || theEvent.what == autoKey) && (FrontWindow() == HackWindow)) {
X  			ch = 0;
X  			ObscureCursor();
X  			/* use raw key codes */
X***************
X*** 228,233 ****
X--- 228,237 ----
X  					case kSuspendResumeMessage:
X  						if (!SuspResIsResume(theEvent.message)) {
X  						/* ---------- SUSPEND EVENT ------------ */
X+ 							if (cursRectInv) {
X+ 								InvertRect(&cursorRect);
X+ 								cursRectInv = FALSE;
X+ 							}
X  							fInFront = FALSE;
X  							if (macflags & fZoomOnContextSwitch
X  								&& !EmptyRect(&(**(HackWindow)->visRgn).rgnBBox))
X***************
X*** 264,271 ****
X  		
X  			case updateEvt:
X  				if (HackWindow == (WindowPtr)theEvent.message) {
X  					doUpdate(t);
X- 					if (cursRectInv) InvertRect(&cursorRect);	/* restore cursor */
X  				}
X  				break;
X  				
X--- 268,276 ----
X  		
X  			case updateEvt:
X  				if (HackWindow == (WindowPtr)theEvent.message) {
X+ 					if (cursRectInv) InvertRect(&cursorRect);	/* clear cursor */
X+ 					cursRectInv = FALSE;
X  					doUpdate(t);
X  				}
X  				break;
X  				
X***************
X*** 299,304 ****
X--- 304,313 ----
X  				break;
X  				
X  			case mouseDown:
X+ 				if (cursRectInv) {
X+ 					InvertRect(&cursorRect);
X+ 					cursRectInv = FALSE;
X+ 				}
X  				ch = mButtonDown(theEvent, t, &nextCommand);
X  #ifdef THINK_C
X  				repDelay = KeyThresh;
X*** mac/macinit.c	Mon May 21 22:21:10 1990
X--- mac/macinit.c	Thu Jan 31 11:24:36 1991
X***************
X*** 239,248 ****
X--- 239,263 ----
X  	t->curHilite = 0;
X  	t->curAttr = 0;
X  
X+ #define all4Mods	(cmdKey | shiftKey | optionKey | controlKey)
X+ #define nKeyCmd		(all4Mods - cmdKey)
X+ #define nKeyShf		(all4Mods - shiftKey)
X+ #define nKeyOpt		(all4Mods - optionKey)
X+ #define nKeyCtl		(all4Mods - controlKey)
X  	/* give time for Multifinder to bring NetHack window to front */
X+ 	/* check to see if this is a "wiz bang" start */
X  	for(tempFont = 0; tempFont<10; tempFont++) {
X+ 		int	theMod;
X+ 
X  		SystemTask();
X  		(void)GetNextEvent(nullEvent,&theEvent);
X+ 
X+ 		theMod = theEvent.modifiers & all4Mods;
X+ 		if ((theMod == nKeyCmd) || (theMod == nKeyShf) ||
X+ 			(theMod == nKeyOpt) || (theMod == nKeyCtl)) {
X+ 			Strcpy(plname, "wizard");
X+ /*			SysBeep(1);	/* useful only for debugging */
X+ 		}
X  	}
X  
X  	HackWindow = NewWindow(0L, &boundsRect, "\016NetHack [MOVE]",
X***************
X*** 416,421 ****
X--- 431,437 ----
X  	int fd;
X  	short temp_flags;
X  	term_info	*t;
X+ 	boolean		saveWizard, newPrefs = FALSE;
X  
X  	t = (term_info *)GetWRefCon(HackWindow);
X  	SetVol(0L, t->system.sysVRefNum);
X***************
X*** 430,436 ****
X--- 446,455 ----
X  			tmp = CtoPstr(OPTIONS);
X  			result = Create((StringPtr)tmp, (short)0, CREATOR, AUXIL_TYPE);
X  		 	if (result == noErr)
X+ 			{
X  		 		fd = open(OPTIONS, O_WRONLY | O_BINARY);
X+ 				newPrefs = TRUE;
X+ 			}
X  		}
X  	 }
X  
X***************
X*** 437,442 ****
X--- 456,469 ----
X  	if (fd < 0)
X  		pline("can't create options file!");
X  	else {
X+ 		/* if we initially store TRUE for wizard then
X+ 		 * the user will have intrinsic wizardry!
X+ 		 */
X+ 		if (newPrefs) {
X+ 			saveWizard = wizard;
X+ 			wizard = FALSE;
X+ 		}
X+ 
X  		write(fd, &flags, sizeof(flags));
X  	
X  		write(fd, plname, PL_NSIZ);
X***************
X*** 455,460 ****
X--- 482,489 ----
X  #endif
X  		write(fd, inv_order, strlen(inv_order)+1);
X  		close(fd);
X+ 
X+ 		if (newPrefs) wizard = saveWizard;
X  	}
X  	
X  	SetVol(0L, t->recordVRefNum);
X*** others/Makefile.ovl	Tue Jun 26 21:20:10 1990
X--- others/Makefile.ovl	Mon Feb  4 16:19:03 1991
X***************
X*** 1,4 ****
X! #	SCCS Id: @(#)Makefile.ovl	3.0	90/06/03
X  #	PC NetHack 3.0 Makefile for Microsoft(tm) "C" 5.1 -- Pierre Martineau
X  #	Overlay Arrangement -- Stephen Spackman, Pierre Martineau, Norm Meluch
X  #	Multiple Compilation Hack and so forth -- Stephen Spackman
X--- 1,4 ----
X! #	SCCS Id: @(#)Makefile.ovl	3.0	90/01/29
X  #	PC NetHack 3.0 Makefile for Microsoft(tm) "C" 5.1 -- Pierre Martineau
X  #	Overlay Arrangement -- Stephen Spackman, Pierre Martineau, Norm Meluch
X  #	Multiple Compilation Hack and so forth -- Stephen Spackman
X***************
X*** 32,38 ****
X  ASM	 = masm
X  EXEPATCH = exesmurf
X  # $(MAKE) macro is often predefined, so we use $(MAKEBIN) instead.
X! MAKEBIN = make
X  # For those of us who have these on PC.
X  # YACC	 = yacc
X  # LEX	 = lex
X--- 32,38 ----
X  ASM	 = masm
X  EXEPATCH = exesmurf
X  # $(MAKE) macro is often predefined, so we use $(MAKEBIN) instead.
X! MAKEBIN = ndmake45l
X  # For those of us who have these on PC.
X  # YACC	 = yacc
X  # LEX	 = lex
X***************
X*** 57,69 ****
X  #	/Di386	= Use 386 specific enhancements
X  #	/DNOEMS = Do not use EMS memory
X  #	/DDEBUG = Report memory usage on startup
X  AFLAGS	= /MX
X  #
X- ###############################################################################
X- # Use the first line if you are using EXESMURF or the second for EXEMOD.
X  EXEFLAGS = /max4500 /min4500
X- # EXEFLAGS = /max 1194 /min 1194
X- ###############################################################################
X  #
X  # *****************************************************************************
X  # ********* Directories (makedefs hardcodes these, don't change them) *********
X--- 57,66 ----
X  #	/Di386	= Use 386 specific enhancements
X  #	/DNOEMS = Do not use EMS memory
X  #	/DDEBUG = Report memory usage on startup
X+ #	/DNOSPLIT = EXE file is not split out to OVL files
X  AFLAGS	= /MX
X  #
X  EXEFLAGS = /max4500 /min4500
X  #
X  # *****************************************************************************
X  # ********* Directories (makedefs hardcodes these, don't change them) *********
X***************
X*** 82,88 ****
X  # The game name
X  GAME	 = NetHack
X  #
X! # The default make target (so just typing 'make' is useful)
X  DEFAULT  : $(GAME)
X  #
X  # The game directory
X--- 79,85 ----
X  # The game name
X  GAME	 = NetHack
X  #
X! # The default make target (so just typing 'ndmake45l' is useful)
X  DEFAULT  : $(GAME)
X  #
X  # The game directory
X***************
X*** 137,229 ****
X  	$(OBJ)\objects.o $(OBJ)\invent.0 $(OBJ)\mkobj.0 $(OBJ)\mkroom.0 \
X  	$(OBJ)\rnd.0 $(OBJ)\termcap.0
X  # main monster code
X! OVL01 = $(OBJ)\cmd.0 $(OBJ)\dbridge.0 $(OBJ)\dog.0 $(OBJ)\engrave.0-1 \
X  	$(OBJ)\hack.0 $(OBJ)\mon.0-1 $(OBJ)\mondata.0-1 $(OBJ)\monmove.0-1 \
X  	$(OBJ)\mthrowu.0 $(OBJ)\priest.0 $(OBJ)\shk.0 $(OBJ)\track.0 \
X  	$(OBJ)\trap.0-1 $(OBJ)\were.0
X- # pet code
X- OVL02 = $(OBJ)\apply.0 $(OBJ)\dog.1 $(OBJ)\dogmove.o
X  # advanced monsters
X! OVL03 = $(OBJ)\demon.o $(OBJ)\mcastu.o
X! OVL04 = $(OBJ)\priest.1-b
X! OVL05 = $(OBJ)\shk.1-b
X! OVL06 = $(OBJ)\were.1-b
X! OVL07 = $(OBJ)\wizard.1-b
X! OVL08 = $(OBJ)\worm.o
X  # main people things: you take your turn
X! OVL09 = $(OBJ)\allmain.0 $(OBJ)\artifact.0 $(OBJ)\attrib.1 $(OBJ)\cmd.1 \
X  	$(OBJ)\do.1 $(OBJ)\do.3 $(OBJ)\eat.0 $(OBJ)\engrave.2 \
X  	$(OBJ)\getline.0-1 $(OBJ)\hack.1 $(OBJ)\lock.0 $(OBJ)\mail.0 \
X  	$(OBJ)\pickup.1 $(OBJ)\pri.1 $(OBJ)\prisym.1 $(OBJ)\sounds.0 \
X  	$(OBJ)\timeout.0 $(OBJ)\track.1 $(OBJ)\vault.0 $(OBJ)\wizard.0
X! OVL10 = $(OBJ)\attrib.0
X! OVL11 = $(OBJ)\attrib.2-b $(OBJ)\exper.o
X! OVL12 = $(OBJ)\artifact.2 $(OBJ)\eat.1 $(OBJ)\invent.1
X! OVL13 = $(OBJ)\makemon.0-2 $(OBJ)\mkobj.1
X! OVL14 = $(OBJ)\makemon.b
X! OVL15 = $(OBJ)\mkobj.2-b
X! OVL16 = $(OBJ)\hack.2
X! OVL17 = $(OBJ)\mhitm.1-b
X! OVL18 = $(OBJ)\mthrowu.1
X! OVL19 = $(OBJ)\mthrowu.2-b
X! OVL20 = $(OBJ)\allmain.1 $(OBJ)\mhitm.0 $(OBJ)\mhitu.0-1 $(OBJ)\rnd.1 \
X! 	$(OBJ)\weapon.0-1
X! OVL21 = $(OBJ)\mon.2-b $(OBJ)\trap.2
X! OVL22 = $(OBJ)\artifact.1 $(OBJ)\search.0 $(OBJ)\uhitm.o $(OBJ)\weapon.2-b
X! OVL23 = $(OBJ)\do_wear.0-1 $(OBJ)\mhitu.2-b
X! OVL24 = $(OBJ)\steal.0-1
X! OVL25 = $(OBJ)\monmove.2-b $(OBJ)\steal.2-b
X! OVL26 = $(OBJ)\rnd.2-b
X! OVL27 = $(OBJ)\do_wear.2 $(OBJ)\getline.b $(OBJ)\mondata.2 $(OBJ)\objnam.0-1 \
X! 	$(OBJ)\pager.0 $(OBJ)\polyself.0-1
X! OVL28 = $(OBJ)\do_name.0
X! OVL29 = $(OBJ)\objnam.2-b
X! OVL30 = $(OBJ)\pager.1-b
X! OVL31 = $(OBJ)\pri.0 $(OBJ)\prisym.0 $(OBJ)\topl.0
X! OVL32 = $(OBJ)\pri.b $(OBJ)\topl.1-2
X! OVL33 = $(OBJ)\prisym.2
X! OVL34 = $(OBJ)\prisym.b
X! OVL35 = $(OBJ)\topl.b
X! OVL36 = $(OBJ)\termcap.1 $(OBJ)\unix.0
X! OVL37 = $(OBJ)\termcap.2-b
X! OVL38 = $(OBJ)\dog.b $(OBJ)\sounds.1-b
X! OVL39 = $(OBJ)\read.0
X! OVL40 = $(OBJ)\invent.b
X! OVL41 = $(OBJ)\hack.b
X! OVL42 = $(OBJ)\mondata.b $(OBJ)\timeout.1-b
X! OVL43 = $(OBJ)\do.0 $(OBJ)\invent.3
X! OVL44 = $(OBJ)\cmd.2-b $(OBJ)\getline.2 $(OBJ)\write.o
X! OVL45 = $(OBJ)\apply.2-b
X! OVL46 = $(OBJ)\do.b
X! OVL47 = $(OBJ)\dokick.o
X! OVL48 = $(OBJ)\dothrow.o
X! OVL49 = $(OBJ)\eat.2-b
X! OVL50 = $(OBJ)\invent.2 $(OBJ)\pickup.0 $(OBJ)\pickup.2-b
X! OVL51 = $(OBJ)\lock.1-b
X  OVL52 = $(OBJ)\polyself.2-b
X! OVL53 = $(OBJ)\potion.o
X! OVL54 = $(OBJ)\pray.o
X! OVL55 = $(OBJ)\read.1-b $(OBJ)\spell.o
X! OVL56 = $(OBJ)\search.1-b
X  # clothing stuff
X! OVL57 = $(OBJ)\do_wear.b $(OBJ)\wield.o $(OBJ)\worn.o
X  # Zappage
X! OVL58 = $(OBJ)\pri.2 $(OBJ)\zap.o
X! OVL59 = $(OBJ)\dbridge.1-b
X! OVL60 = $(OBJ)\trap.b
X  # Unusual circumstances
X  OVL61 = $(OBJ)\artifact.b $(OBJ)\do_name.1-b $(OBJ)\fountain.o $(OBJ)\music.o \
X  	$(OBJ)\rumors.o $(OBJ)\shknam.0 $(OBJ)\sit.o $(OBJ)\vault.1-b
X  # Uppers and Downers
X! # Note: version.o is in OVL62, but in a special way.  See below.
X! OVL62 = $(OBJ)\allmain.2-b $(OBJ)\end.o $(OBJ)\engrave.b $(OBJ)\mail.1-b \
X  	$(OBJ)\o_init.o $(OBJ)\options.o $(OBJ)\restore.o $(OBJ)\rip.o \
X  	$(OBJ)\save.o $(OBJ)\shknam.1-b $(OBJ)\topten.o $(OBJ)\tty.o \
X  	$(OBJ)\u_init.o $(OBJ)\unix.1-b
X- # Levelling
X- OVL63 = $(OBJ)\apply.1 $(OBJ)\bones.o $(OBJ)\do.2 $(OBJ)\dog.2 \
X- 	$(OBJ)\extralev.o $(OBJ)\mklev.o $(OBJ)\mkmaze.o $(OBJ)\mkroom.1-b \
X- 	$(OBJ)\sp_lev.o $(OBJ)\track.2-b
X  
X  
X  # *****************************************************************************
X--- 134,226 ----
X  	$(OBJ)\objects.o $(OBJ)\invent.0 $(OBJ)\mkobj.0 $(OBJ)\mkroom.0 \
X  	$(OBJ)\rnd.0 $(OBJ)\termcap.0
X  # main monster code
X! OVL01 = $(OBJ)\attrib.0
X! OVL02 = $(OBJ)\prisym.b
X! OVL03 = $(OBJ)\read.0
X! OVL04 = $(OBJ)\rnd.2-b
X! OVL05 = $(OBJ)\steal.0-1
X! OVL06 = $(OBJ)\prisym.2
X! OVL07 = $(OBJ)\termcap.1 $(OBJ)\unix.0
X! OVL08 = $(OBJ)\were.1-b
X! OVL09 = $(OBJ)\do_name.0
X! OVL10 = $(OBJ)\mthrowu.2-b
X! OVL11 = $(OBJ)\topl.b
X! OVL12 = $(OBJ)\hack.b
X! OVL13 = $(OBJ)\makemon.b
X! OVL14 = $(OBJ)\mondata.b $(OBJ)\timeout.1-b
X! OVL15 = $(OBJ)\wizard.1-b
X! OVL16 = $(OBJ)\do.b
X! OVL17 = $(OBJ)\do.0 $(OBJ)\invent.3
X! OVL18 = $(OBJ)\worm.o
X! OVL19 = $(OBJ)\pri.b $(OBJ)\topl.1-2
X! OVL20 = $(OBJ)\mkobj.2-b
X! OVL21 = $(OBJ)\termcap.2-b
X! OVL22 = $(OBJ)\mthrowu.1
X! OVL23 = $(OBJ)\attrib.2-b $(OBJ)\exper.o
X! OVL24 = $(OBJ)\monmove.2-b $(OBJ)\steal.2-b
X! OVL25 = $(OBJ)\hack.2
X! OVL26 = $(OBJ)\demon.o $(OBJ)\mcastu.o
X! OVL27 = $(OBJ)\dothrow.o
X! OVL28 = $(OBJ)\cmd.2-b $(OBJ)\getline.2 $(OBJ)\write.o
X! OVL29 = $(OBJ)\artifact.2 $(OBJ)\eat.1 $(OBJ)\invent.1
X! OVL30 = $(OBJ)\dog.b $(OBJ)\sounds.1-b
X! OVL31 = $(OBJ)\priest.1-b
X! # pet code
X! OVL32 = $(OBJ)\apply.0 $(OBJ)\dog.1 $(OBJ)\dogmove.o
X! OVL33 = $(OBJ)\invent.b
X! OVL34 = $(OBJ)\pager.1-b
X! OVL35 = $(OBJ)\mhitm.1-b
X! OVL36 = $(OBJ)\objnam.2-b
X! OVL37 = $(OBJ)\pri.0 $(OBJ)\prisym.0 $(OBJ)\topl.0
X! OVL38 = $(OBJ)\dokick.o
X! OVL39 = $(OBJ)\do_wear.2 $(OBJ)\getline.b $(OBJ)\mondata.2 $(OBJ)\objnam.0-1 \
X! 	$(OBJ)\pager.0 $(OBJ)\polyself.0-1
X! OVL40 = $(OBJ)\makemon.0-2 $(OBJ)\mkobj.1
X! OVL41 = $(OBJ)\mon.2-b $(OBJ)\trap.2
X! OVL42 = $(OBJ)\do_wear.0-1 $(OBJ)\mhitu.2-b
X! OVL43 = $(OBJ)\allmain.1 $(OBJ)\mhitm.0 $(OBJ)\mhitu.0-1 $(OBJ)\rnd.1 \
X! 	$(OBJ)\weapon.0-1
X! OVL44 = $(OBJ)\apply.2-b
X! OVL45 = $(OBJ)\artifact.1 $(OBJ)\search.0 $(OBJ)\uhitm.o $(OBJ)\weapon.2-b
X! OVL46 = $(OBJ)\cmd.0 $(OBJ)\dbridge.0 $(OBJ)\dog.0 $(OBJ)\engrave.0-1 \
X  	$(OBJ)\hack.0 $(OBJ)\mon.0-1 $(OBJ)\mondata.0-1 $(OBJ)\monmove.0-1 \
X  	$(OBJ)\mthrowu.0 $(OBJ)\priest.0 $(OBJ)\shk.0 $(OBJ)\track.0 \
X  	$(OBJ)\trap.0-1 $(OBJ)\were.0
X  # advanced monsters
X! OVL47 = $(OBJ)\shk.1-b
X  # main people things: you take your turn
X! OVL48 = $(OBJ)\allmain.0 $(OBJ)\artifact.0 $(OBJ)\attrib.1 $(OBJ)\cmd.1 \
X  	$(OBJ)\do.1 $(OBJ)\do.3 $(OBJ)\eat.0 $(OBJ)\engrave.2 \
X  	$(OBJ)\getline.0-1 $(OBJ)\hack.1 $(OBJ)\lock.0 $(OBJ)\mail.0 \
X  	$(OBJ)\pickup.1 $(OBJ)\pri.1 $(OBJ)\prisym.1 $(OBJ)\sounds.0 \
X  	$(OBJ)\timeout.0 $(OBJ)\track.1 $(OBJ)\vault.0 $(OBJ)\wizard.0
X! OVL49 = $(OBJ)\search.1-b
X! OVL50 = $(OBJ)\lock.1-b
X! OVL51 = $(OBJ)\dbridge.1-b
X  OVL52 = $(OBJ)\polyself.2-b
X! OVL53 = $(OBJ)\invent.2 $(OBJ)\pickup.0 $(OBJ)\pickup.2-b
X! OVL54 = $(OBJ)\eat.2-b
X! OVL55 = $(OBJ)\pray.o
X! OVL56 = $(OBJ)\potion.o
X! OVL57 = $(OBJ)\trap.b
X! OVL58 = $(OBJ)\read.1-b $(OBJ)\spell.o
X  # clothing stuff
X! OVL59 = $(OBJ)\do_wear.b $(OBJ)\wield.o $(OBJ)\worn.o
X  # Zappage
X! OVL60 = $(OBJ)\pri.2 $(OBJ)\zap.o
X  # Unusual circumstances
X  OVL61 = $(OBJ)\artifact.b $(OBJ)\do_name.1-b $(OBJ)\fountain.o $(OBJ)\music.o \
X  	$(OBJ)\rumors.o $(OBJ)\shknam.0 $(OBJ)\sit.o $(OBJ)\vault.1-b
X+ # Levelling
X+ OVL62 = $(OBJ)\apply.1 $(OBJ)\bones.o $(OBJ)\do.2 $(OBJ)\dog.2 \
X+ 	$(OBJ)\extralev.o $(OBJ)\mklev.o $(OBJ)\mkmaze.o $(OBJ)\mkroom.1-b \
X+ 	$(OBJ)\sp_lev.o $(OBJ)\track.2-b
X  # Uppers and Downers
X! # Note: version.o is in OVL63, but in a special way.  See below.
X! OVL63 = $(OBJ)\allmain.2-b $(OBJ)\end.o $(OBJ)\engrave.b $(OBJ)\mail.1-b \
X  	$(OBJ)\o_init.o $(OBJ)\options.o $(OBJ)\restore.o $(OBJ)\rip.o \
X  	$(OBJ)\save.o $(OBJ)\shknam.1-b $(OBJ)\topten.o $(OBJ)\tty.o \
X  	$(OBJ)\u_init.o $(OBJ)\unix.1-b
X  
X  
X  # *****************************************************************************
X***************
X*** 257,263 ****
X  	   ($(OVL43)) ($(OVL44)) ($(OVL45)) ($(OVL46)) ($(OVL47)) ($(OVL48)) \
X  	   ($(OVL49)) ($(OVL50)) ($(OVL51)) ($(OVL52)) ($(OVL53)) ($(OVL54)) \
X  	   ($(OVL55)) ($(OVL56)) ($(OVL57)) ($(OVL58)) ($(OVL59)) ($(OVL60)) \
X! 	   ($(OVL61)) ($(OVL62)      $(OBJ)\version.o) ($(OVL63))
X  
X  # object files for special levels compiler
X  SPLEVOBJS   =	$(OBJ)\lev_comp.o $(OBJ)\lev_lex.o  $(OBJ)\lev_main.o \
X--- 254,260 ----
X  	   ($(OVL43)) ($(OVL44)) ($(OVL45)) ($(OVL46)) ($(OVL47)) ($(OVL48)) \
X  	   ($(OVL49)) ($(OVL50)) ($(OVL51)) ($(OVL52)) ($(OVL53)) ($(OVL54)) \
X  	   ($(OVL55)) ($(OVL56)) ($(OVL57)) ($(OVL58)) ($(OVL59)) ($(OVL60)) \
X! 	   ($(OVL61)) ($(OVL62)) ($(OBJ)\version.o      $(OVL63))
X  
X  # object files for special levels compiler
X  SPLEVOBJS   =	$(OBJ)\lev_comp.o $(OBJ)\lev_lex.o  $(OBJ)\lev_main.o \
X***************
X*** 329,338 ****
X  
X  $(GAME).exe: $(GAMEFILE)
X  
X! $(GAMEFILE): $(OBJ) $(HOBJ)
X  	@echo Loading....
X  	$(LINK) $(ROOT) $(OVERLAYS),$(GAMEFILE),$(GAME),$(CLIB) $(TERMLIB) $(LFLAGS) ;
X  	$(EXEPATCH) $(GAMEFILE) $(EXEFLAGS)
X  	@echo NetHack is up to date.
X  
X  $(OBJ):
X--- 326,336 ----
X  
X  $(GAME).exe: $(GAMEFILE)
X  
X! $(GAMEFILE): $(EXEPATCH) $(OBJ) $(HOBJ)
X  	@echo Loading....
X  	$(LINK) $(ROOT) $(OVERLAYS),$(GAMEFILE),$(GAME),$(CLIB) $(TERMLIB) $(LFLAGS) ;
X  	$(EXEPATCH) $(GAMEFILE) $(EXEFLAGS)
X+ 	$(EXEPATCH) $(GAMEFILE) 1 49
X  	@echo NetHack is up to date.
X  
X  $(OBJ):
X***************
X*** 392,397 ****
X--- 390,403 ----
X  
X  lev_comp.exe:	$(SPLEVOBJS)
X  	$(LINK) $(LFLAGS) $(SPLEVOBJS),lev_comp.exe,, $(CLIB);
X+ 
X+ $(EXEPATCH): $(EXEPATCH).exe
X+ 
X+ $(EXEPATCH).exe: $(OBJ)\$(EXEPATCH).o
X+ 	$(LINK) $(OBJ)\$*.o,$*.exe;
X+ 
X+ $(OBJ)\$(EXEPATCH).o: $(EXEPATCH).c
X+ 	$(CC) /W0 /Fo$(OBJ)\$*.o $*.c
X  
X  # *****************************************************************************
X  # *************************  Makedefs Stuff ***********************************
X*** vms/install.com	Thu May 24 00:44:05 1990
X--- vms/install.com	Sat Jan  5 15:06:11 1991
X***************
X*** 14,19 ****
X--- 14,20 ----
X  $	play_files = "PERM.,RECORD.,LOGFILE."
X  $	help_files = "HELP.,HH.,CMDHELP.,HISTORY.,OPTHELP.,ORACLES.,LICENSE."
X  $	data_files = "DATA.,RUMORS."
X+ $	trmcp_file = "[.others]termcap"
X  $	spec_files = "ENDGAME.,CASTLE.,TOWER%."
X  $	spec_input = "endgame.des castle.des tower.des"
X  $ makedefs := $sys$disk:[-.src]makedefs
X***************
X*** 25,43 ****
X  $	set default [-.auxil]	!move to auxiliary directory
X  $ makedefs -d	!data
X  $ makedefs -r	!rumors
X! $! lev_comp 'spec_input' !special levels
X! $! (flex'd version doesn't handle multiple inputs, so do them one at a time)
X! $ lev_comp endgame.des
X! $ lev_comp castle.des
X! $ lev_comp tower.des
X  $	set default [-]		!move up
X  $
X! $! set up the directories
X! $ create/directory/owner='gameuic'/prot=(s:rwe,o:rwe,g:rwe,w:rwe)/log -
X! 	'f$string(gamedir - "]" + ".SAVE]")'
X! $! create empty writeable files
X  $ create/owner='gameuic'/prot=(s:rwed,o:rwed,g:rwed,w:rwed) -
X  	'gamedir''play_files'
X  $! copy over the remaining game files, then make them readonly
X  $ copy/prot=(s:rwed,o:rwed,g:re,w:re) -
X  	[.auxil]'help_files','data_files','spec_files',[.src]nethack.exe -
X--- 26,50 ----
X  $	set default [-.auxil]	!move to auxiliary directory
X  $ makedefs -d	!data
X  $ makedefs -r	!rumors
X! $ lev_comp 'spec_input' !special levels
X  $	set default [-]		!move up
X  $
X! $!
X! $! set up the playground and save directories
X! $	srctree = f$environment("DEFAULT")
X! $	set default 'gamedir'
X! $ if f$parse("[-]").eqs."" then  create/dir/log [-] !default owner & protection
X! $ if f$parse("[]" ).eqs."" then - !needs to be world writable
X!    create/directory/owner='gameuic'/prot=(s:rwe,o:rwe,g:rwe,w:rwe)/log []
X! $ if f$search("SAVE.DIR;1").eqs."" then -
X!    create/directory/owner='gameuic'/prot=(s:rwe,o:rwe,g:rwe,w:rwe)/log -
X! 	[.SAVE]/version_limit=2
X! $	set default 'srctree'
X! $!
X! $! create empty writeable files -- logfile, scoreboard, multi-user access lock
X  $ create/owner='gameuic'/prot=(s:rwed,o:rwed,g:rwed,w:rwed) -
X  	'gamedir''play_files'
X+ $!
X  $! copy over the remaining game files, then make them readonly
X  $ copy/prot=(s:rwed,o:rwed,g:re,w:re) -
X  	[.auxil]'help_files','data_files','spec_files',[.src]nethack.exe -
X***************
X*** 44,49 ****
X--- 51,63 ----
X  	'gamedir'*.*
X  $ set file/owner='gameuic'/prot=(s:re,o:re) -
X  	'gamedir''help_files','data_files','spec_files',nethack.exe
X+ $!
X+ $! provide last-resort termcap file (if available)
X+ $ if f$search(trmcp_file).eqs."" then  goto skip_termcap
X+ $  copy/prot=(s:rwed,o:rwed,g:re,w:re) 'trmcp_file' 'gamedir'termcap
X+ $  set file/owner='gameuic'/prot=(s:re,o:re) 'gamedir'termcap
X+ $skip_termcap:
X+ $!
X  $! done
X  $ define/nolog hackdir 'gamedir'
X  $ write sys$output -
X*** vms/lev_lex.h	Tue Jun 26 21:20:41 1990
X--- vms/lev_lex.h	Thu Jan 31 13:46:10 1991
X***************
X*** 5,13 ****
X   * src/lev_main.c, where stdin & stdout are still correctly defined.
X   */
X  #ifdef VAXC
X! # module lev_lex "3.0.9"
X  #endif
X  
X  #include <stdio.h>
X  #define stdin  0
X  #define stdout 0
X--- 5,19 ----
X   * src/lev_main.c, where stdin & stdout are still correctly defined.
X   */
X  #ifdef VAXC
X! # module lev_lex "3.0.10"
X  #endif
X  
X  #include <stdio.h>
X+ #ifdef stdin
X+ # undef stdin
X+ #endif
X  #define stdin  0
X+ #ifdef stdout
X+ # undef stdout
X+ #endif
X  #define stdout 0
X*** vms/vmsbuild.com	Tue Feb  5 22:14:41 1991
X--- vms/vmsbuild.com	Tue Feb  5 22:15:48 1991
X***************
X*** 1,4 ****
X! $ ! vms/vmsbuild.com -- compile and link NetHack 3.0 patchlevel 9	[pr]
X  $ !
X  $ ! usage:
X  $ !   $ set default [.src]	!or [-.src] if starting from [.vms]
X--- 1,4 ----
X! $ ! vms/vmsbuild.com -- compile and link NetHack 3.0 patchlevel 10	[pr]
X  $ !
X  $ ! usage:
X  $ !   $ set default [.src]	!or [-.src] if starting from [.vms]
X***************
X*** 17,23 ****
X  $ !	Default wizard definition moved to include/vmsconf.h.
X  $
X  $	vaxc_ = "CC/NOLIST/OPTIMIZE=NOINLINE"	    !vaxc v3.x (2.x fixed below)
X! $	gnuc_ = "GCC/CC1=""-fwritable-strings"""
X  $	gnulib = "gnu_cc:[000000]gcclib/Library"    !(not used w/ vaxc)
X  $ ! common CC options (/obj=file doesn't work for GCC 1.36, use rename instead)
X  $	c_c_  = "/INCLUDE=[-.INCLUDE]"	!/DEFINE=(""WIZARD=""""GENTZEL"""""")
X--- 17,23 ----
X  $ !	Default wizard definition moved to include/vmsconf.h.
X  $
X  $	vaxc_ = "CC/NOLIST/OPTIMIZE=NOINLINE"	    !vaxc v3.x (2.x fixed below)
X! $	gnuc_ = "GCC"
X  $	gnulib = "gnu_cc:[000000]gcclib/Library"    !(not used w/ vaxc)
X  $ ! common CC options (/obj=file doesn't work for GCC 1.36, use rename instead)
X  $	c_c_  = "/INCLUDE=[-.INCLUDE]"	!/DEFINE=(""WIZARD=""""GENTZEL"""""")
X***************
X*** 113,119 ****
X  $ milestone "<compiling...>"
X  $ cc [-.vms]vmsmisc	!try simplest one first
X  $ cc alloc.c
X! $ if f$search("monst.c").eqs."" then  copy/Concat monst.c1+.c2 *.c
X  $ cc monst.c
X  $ milestone " (monst)"
X  $ cc objects.c
X--- 113,119 ----
X  $ milestone "<compiling...>"
X  $ cc [-.vms]vmsmisc	!try simplest one first
X  $ cc alloc.c
X! $ if f$search("monst.c").eqs."" then  copy/Concat monst.c1+.c2 monst.c
X  $ cc monst.c
X  $ milestone " (monst)"
X  $ cc objects.c
X***************
X*** 121,127 ****
X  $ cc makedefs.c
X  $ link makedefs.obj,monst.obj,objects.obj,vmsmisc.obj,-
X  	'vaxcrtl''gnulib',sys$input:/Opt
X! identification="makedefs 3.0.9"
X  $ milestone "makedefs"
X  $! create some build-time files
X  $ makedefs -p	!pm.h
X--- 121,127 ----
X  $ cc makedefs.c
X  $ link makedefs.obj,monst.obj,objects.obj,vmsmisc.obj,-
X  	'vaxcrtl''gnulib',sys$input:/Opt
X! identification="makedefs 3.0.10"
X  $ milestone "makedefs"
X  $! create some build-time files
X  $ makedefs -p	!pm.h
X***************
X*** 162,171 ****
X  $list_done:
X  $     i = i + 1
X  $   if i.le.5 then  goto list_loop
X! $! one special case left
X! $ cc [-.vms]vmstermcap.c -
X! 	/Define=("bcopy(s,d,n)=memcpy((d),(s),(n))","exit=vms_exit")
X  $ libr/Obj 'nethacklib' vmstermcap.obj/Insert
X  $!
X  $link:
X  $ milestone "<linking...>"
X--- 162,173 ----
X  $list_done:
X  $     i = i + 1
X  $   if i.le.5 then  goto list_loop
X! $! one special case left:  gcc chokes on these commas, but has real bcopy
X! $	vmstermcap_options = "/Define=(""bcopy(s,d,n)=memcpy(d,s,n)"",""exit=vms_exit"")"
X! $	if c_opt.eq.5 then  vmstermcap_options = "/Define=(""exit=vms_exit"")"
X! $ cc 'vmstermcap_options' [-.vms]vmstermcap.c
X  $ libr/Obj 'nethacklib' vmstermcap.obj/Insert
X+ $ delete vmstermcap.obj;*
X  $!
X  $link:
X  $ milestone "<linking...>"
X***************
X*** 172,178 ****
X  $ link/Exe=nethack 'nethacklib'/Lib/Incl=(vmsmain,allmain,vmsunix,vmstty,decl),-
X  	sys$disk:[]monst.obj,objects.obj,-	!(data-only modules, like decl)
X  	sys$input:/Opt,'vaxcrtl''gnulib'
X! identification="NetHack 3.0.9"
X  $ milestone "NetHack"
X  $     if c_opt.eq.10 then  goto done	!"LINK" only
X  $special:
X--- 174,180 ----
X  $ link/Exe=nethack 'nethacklib'/Lib/Incl=(vmsmain,allmain,vmsunix,vmstty,decl),-
X  	sys$disk:[]monst.obj,objects.obj,-	!(data-only modules, like decl)
X  	sys$input:/Opt,'vaxcrtl''gnulib'
X! identification="NetHack 3.0.10"
X  $ milestone "NetHack"
X  $     if c_opt.eq.10 then  goto done	!"LINK" only
X  $special:
X***************
X*** 188,194 ****
X  $ link lev_comp.obj,lev_lex.obj,lev_main.obj,-
X  	monst.obj,objects.obj,alloc.obj,panic.obj,vmsmisc.obj,-
X  	'vaxcrtl''gnulib',sys$input:/Opt
X! identification="lev_comp 3.0.9"
X  $ milestone "lev_comp"
X  $!
X  $done:
X--- 190,196 ----
X  $ link lev_comp.obj,lev_lex.obj,lev_main.obj,-
X  	monst.obj,objects.obj,alloc.obj,panic.obj,vmsmisc.obj,-
X  	'vaxcrtl''gnulib',sys$input:/Opt
X! identification="lev_comp 3.0.10"
X  $ milestone "lev_comp"
X  $!
X  $done:
X*** vms/vmsmain.c	Tue Jun 26 21:20:43 1990
X--- vms/vmsmain.c	Sat Jan  5 15:00:18 1991
X***************
X*** 283,289 ****
X  	flags.moonphase = phase_of_the_moon();
X  	if(flags.moonphase == FULL_MOON) {
X  		You("are lucky!  Full moon tonight.");
X! 		if(!u.uluck) change_luck(1);
X  	} else if(flags.moonphase == NEW_MOON) {
X  		pline("Be careful!  New moon tonight.");
X  	}
X--- 283,289 ----
X  	flags.moonphase = phase_of_the_moon();
X  	if(flags.moonphase == FULL_MOON) {
X  		You("are lucky!  Full moon tonight.");
X! 		change_luck(1);
X  	} else if(flags.moonphase == NEW_MOON) {
X  		pline("Be careful!  New moon tonight.");
X  	}
X***************
X*** 425,433 ****
X--- 425,435 ----
X      if (condition == SS$_ACCVIO         /* access violation */
X       || condition >= SS$_ASTFLT && condition <= SS$_TBIT
X       || condition >= SS$_ARTRES && condition <= SS$_INHCHME) {
X+ # ifdef WIZARD
X  	if (wizard)
X  	    abort();    /* enter the debugger */
X  	else
X+ # endif
X  	    hu = TRUE;  /* pretend that hangup has already been attempted */
X      }
X      return SS$_RESIGNAL;
X*** vms/vmstty.c	Tue Jun 26 22:46:12 1990
X--- vms/vmstty.c	Sat Jan  5 15:00:22 1991
X***************
X*** 8,15 ****
X--- 8,24 ----
X  
X  #include	<descrip.h>
X  #include	<iodef.h>
X+ #ifndef __GNUC__
X  #include	<smgdef.h>
X  #include	<ttdef.h>
X+ #else	/* values needed from missing include files */
X+ # define SMG$K_TRM_UP	 274
X+ # define SMG$K_TRM_DOWN  275
X+ # define SMG$K_TRM_LEFT  276
X+ # define SMG$K_TRM_RIGHT 277
X+ # define TT$M_MECHTAB	 0x00000100
X+ # define TT$M_MECHFORM	 0x00080000
X+ #endif /* __GNUC__ */
X  #include <errno.h>
X  
X  #define vms_ok(sts) ((sts)&1)
X*** vms/vmsunix.c	Thu May 24 20:21:46 1990
X--- vms/vmsunix.c	Thu Jan 31 13:46:15 1991
X***************
X*** 23,31 ****
X  #undef off_t
X  #ifndef VAXC
X  #include <sys/stat.h>
X! #else   VAXC
X  #include <stat.h>
X! #endif  VAXC
X  #include <ctype.h>
X  #ifdef no_c$$translate
X  #include <errno.h>
X--- 23,31 ----
X  #undef off_t
X  #ifndef VAXC
X  #include <sys/stat.h>
X! #else
X  #include <stat.h>
X! #endif
X  #include <ctype.h>
X  #ifdef no_c$$translate
X  #include <errno.h>
X***************
X*** 106,112 ****
X  static struct stat buf, hbuf;
X  
X  void
X! gethdate(name) char *name; {
X  	register char *np;
X  
X  	if(stat(name, &hbuf))
X--- 106,112 ----
X  static struct stat buf, hbuf;
X  
X  void
X! gethdate(name) const char *name; {
X  	register char *np;
X  
X  	if(stat(name, &hbuf))
X***************
X*** 351,358 ****
X      return (getgid() << 16) | getuid();
X  }
X  
X  #if defined(CHDIR) || defined(SHELL)
X! unsigned int oprv[2];
X  
X  void
X  privoff()
X--- 351,451 ----
X      return (getgid() << 16) | getuid();
X  }
X  
X+ /*------*/
X+ #ifndef LNM$_STRING
X+ #include <lnmdef.h>	/* logical name definitions */
X+ #endif
X+ #define ENVSIZ LNM$C_NAMLENGTH  /*255*/
X+ 
X+ #define ENV_USR 0	/* user-mode */
X+ #define ENV_SUP 1	/* supervisor-mode */
X+ #define ENV_JOB 2	/* job-wide entry */
X+ 
X+ /* vms_define() - assign a value to a logical name */
X+ int
X+ vms_define(name, value, flag)
X+ const char *name;
X+ const char *value;
X+ int flag;
X+ {
X+     struct dsc { int len; const char *adr; };	/* string descriptor */
X+     struct itm3 { short buflen, itmcode; const char *bufadr; short *retlen; };
X+     static struct itm3 itm_lst[] = { {0,LNM$_STRING,0,0}, {0,0} };
X+     struct dsc nam_dsc, val_dsc, tbl_dsc;
X+     unsigned long result, SYS$CRELNM(), LIB$SET_LOGICAL();
X+ 
X+     /* set up string descriptors */
X+     nam_dsc.len = strlen( nam_dsc.adr = name );
X+     val_dsc.len = strlen( val_dsc.adr = value );
X+     tbl_dsc.len = strlen( tbl_dsc.adr = "LNM$PROCESS" );
X+ 
X+     switch (flag) {
X+ 	case ENV_JOB:	/* job logical name */
X+ 		tbl_dsc.len = strlen( tbl_dsc.adr = "LNM$JOB" );
X+ 	    /*FALLTHRU*/
X+ 	case ENV_SUP:	/* supervisor-mode process logical name */
X+ 		result = LIB$SET_LOGICAL(&nam_dsc, &val_dsc, &tbl_dsc);
X+ 	    break;
X+ 	case ENV_USR:	/* user-mode process logical name */
X+ 		itm_lst[0].buflen = val_dsc.len;
X+ 		itm_lst[0].bufadr = val_dsc.adr;
X+ 		result = SYS$CRELNM(0, &tbl_dsc, &nam_dsc, 0, itm_lst);
X+ 	    break;
X+ 	default:	/*[ bad input ]*/
X+ 		result = 0;
X+ 	    break;
X+     }
X+     result &= 1;	/* odd => success (== 1), even => failure (== 0) */
X+     return !result;	/* 0 == success, 1 == failure */
X+ }
X+ 
X+ /* vms_putenv() - create or modify an environment value */
X+ int
X+ vms_putenv(string)
X+ const char *string;
X+ {
X+     char name[ENVSIZ+1], value[ENVSIZ+1], *p;   /* [255+1] */
X+ 
X+     p = strchr(string, '=');
X+     if (p > string && p < string + sizeof name && strlen(p+1) < sizeof value) {
X+ 	(void)strncpy(name, string, p - string),  name[p - string] = '\0';
X+ 	(void)strcpy(value, p+1);
X+ 	return vms_define(name, value, ENV_USR);
X+     } else
X+ 	return 1;	/* failure */
X+ }
X+ 
X+ /*
X+    Figure out whether the termcap code will find a termcap file; if not,
X+    try to help it out.  This avoids modifying the GNU termcap sources and
X+    can simplify configuration for sites which don't already use termcap.
X+  */
X+ #define GNU_DEFAULT_TERMCAP "emacs_library:[etc]termcap.dat"
X+ #define NETHACK_DEF_TERMCAP "hackdir:termcap"
X+ 
X+ const char *
X+ verify_termcap()	/* called from startup(src/termcap.c) */
X+ {
X+     struct stat dummy;
X+     char *tc = getenv("TERMCAP");
X+     if (tc) return (const char *)0;	/* no fixups needed */
X+     if (!tc && !stat(GNU_DEFAULT_TERMCAP, &dummy)) tc = GNU_DEFAULT_TERMCAP;
X+     if (!tc && !stat(NETHACK_DEF_TERMCAP, &dummy)) tc = NETHACK_DEF_TERMCAP;
X+     if (!tc && !stat("termcap", &dummy))  tc = "termcap";  /* current dir */
X+     if (!tc && !stat("$TERMCAP", &dummy)) tc = "$TERMCAP"; /* alt environ */
X+     if (tc) {
X+ 	/* putenv(strcat(strcpy(buffer,"TERMCAP="),tc)); */
X+ 	vms_define("TERMCAP", tc, ENV_USR);
X+     } else {
X+ 	/* Perhaps later we'll construct a termcap entry string and return that
X+ 	   when no file is found; for now, just return NULL unconditionally. */
X+     }
X+     return (const char *)0;
X+ }
X+ /*------*/
X+ 
X  #if defined(CHDIR) || defined(SHELL)
X! static unsigned long oprv[2];
X  
X  void
X  privoff()
X***************
X*** 380,387 ****
X  	int status;
X  
X  	settty((char *) NULL);	/* also calls end_screen() */
X- 	(void) signal(SIGINT,SIG_DFL);
X  	(void) signal(SIGQUIT,SIG_IGN);
X  	if (!dosh_pid || !((status = LIB$ATTACH(&dosh_pid)) & 1))
X  	{
X  #ifdef CHDIR
X--- 473,480 ----
X  	int status;
X  
X  	settty((char *) NULL);	/* also calls end_screen() */
X  	(void) signal(SIGQUIT,SIG_IGN);
X+ 	(void) signal(SIGINT,SIG_DFL);
X  	if (!dosh_pid || !((status = LIB$ATTACH(&dosh_pid)) & 1))
X  	{
X  #ifdef CHDIR
X***************
X*** 403,409 ****
X  #endif
X  	docrt();
X  	if (!(status & 1))
X! 	    pline("Spawn failed.  Try again.");
X  	return 0;
X  }
X  #endif
X--- 496,502 ----
X  #endif
X  	docrt();
X  	if (!(status & 1))
X! 	    pline("Spawn failed.  (%%x%08X) ", status);
X  	return 0;
X  }
X  #endif
X
END_OF_FILE
if test 50416 -ne `wc -c <'patch10.05'`; then
    echo shar: \"'patch10.05'\" unpacked with wrong size!
fi
# end of 'patch10.05'
echo shar: End of archive 3 \(of 8\).
cp /dev/null ark3isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 8 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
